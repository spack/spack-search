{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-swig-4.0.2-fortran-g56ercorgz6iqsj2oxpaerfkjervkynd/spack-src/configure.ac": "dnl Process this file with autoconf to produce a configure script.\ndnl The macros which aren't shipped with the autotools are stored in the\ndnl Tools/config directory in .m4 files.\n\nAC_INIT([swig],[4.0.2+fortran],[http://www.swig.org])\nAC_PREREQ(2.60)\n\nAC_CONFIG_SRCDIR([Source/Swig/swig.h])\nAC_CONFIG_AUX_DIR([Tools/config])\nAC_CONFIG_HEADERS([Source/Include/swigconfig.h])\nAC_CANONICAL_HOST\nAM_INIT_AUTOMAKE\n\ndnl Some extra defines for the config file\nAH_BOTTOM([\n/* Deal with attempt by Microsoft to deprecate C standard runtime functions */\n#if defined(_MSC_VER)\n# define _CRT_SECURE_NO_DEPRECATE\n#endif\n])\n\ndnl Check for programs that a user requires to build SWIG\nAC_PROG_CC\nAC_PROG_CXX\nAM_PROG_CC_C_O  # Needed for subdir-objects in AUTOMAKE_OPTIONS\n\nAC_COMPILE_WARNINGS # Increase warning levels\n\nAC_DEFINE_UNQUOTED(SWIG_CXX, [\"$CXX\"], [Compiler that built SWIG])\nAC_DEFINE_UNQUOTED(SWIG_PLATFORM, [\"$host\"], [Platform that SWIG is built for])\n\ndnl Checks for header files.\nAC_HEADER_STDC\n\ndnl Look for popen\nAC_ARG_WITH(popen, AS_HELP_STRING([--without-popen], [Disable popen]), with_popen=\"$withval\")\nif test x\"${with_popen}\" = xno ; then\nAC_MSG_NOTICE([Disabling popen])\nelse\nAC_CHECK_FUNC(popen, AC_DEFINE(HAVE_POPEN, 1, [Define if popen is available]), AC_MSG_NOTICE([Disabling popen]))\nfi\n\ndnl PCRE\nAC_ARG_WITH([pcre],\n  [AS_HELP_STRING([--without-pcre],\n                  [Disable support for regular expressions using PCRE])],\n  [],\n  [with_pcre=yes])\n\nAC_MSG_CHECKING([whether to enable PCRE support])\nAC_MSG_RESULT([$with_pcre])\n\ndnl To make configuring easier, check for a locally built PCRE using the Tools/pcre-build.sh script\nif test x\"${with_pcre}\" = xyes ; then\n  AC_MSG_CHECKING([whether to use local PCRE])\n  local_pcre_config=no\n  if test -z $PCRE_CONFIG; then\n    if test -f `pwd`/pcre/pcre-swig-install/bin/pcre-config; then\n      PCRE_CONFIG=`pwd`/pcre/pcre-swig-install/bin/pcre-config\n      local_pcre_config=$PCRE_CONFIG\n    fi\n  fi\n  AC_MSG_RESULT([$local_pcre_config])\nfi\nAS_IF([test \"x$with_pcre\" != xno],\n  [AX_PATH_GENERIC([pcre],\n    [], dnl Minimal version of PCRE we need -- accept any\n    [], dnl custom sed script for version parsing is not needed\n    [AC_DEFINE([HAVE_PCRE], [1], [Define if you have PCRE library])\n     LIBS=\"$LIBS $PCRE_LIBS\"\n     CPPFLAGS=\"$CPPFLAGS $PCRE_CFLAGS\"\n    ],\n    [AC_MSG_FAILURE([\n        Cannot find pcre-config script from PCRE (Perl Compatible Regular Expressions)\n        library package. This dependency is needed for configure to complete,\n        Either:\n        - Install the PCRE developer package on your system (preferred approach).\n        - Download the PCRE source tarball, build and install on your system\n          as you would for any package built from source distribution.\n        - Use the Tools/pcre-build.sh script to build PCRE just for SWIG to statically\n          link against. Run 'Tools/pcre-build.sh --help' for instructions.\n          (quite easy and does not require privileges to install PCRE on your system)\n        - Use configure --without-pcre to disable regular expressions support in SWIG\n          (not recommended).])\n    ])\n  ])\n\n\ndnl CCache\nAC_ARG_ENABLE([ccache], AS_HELP_STRING([--disable-ccache], [disable building and installation of ccache-swig executable (default enabled)]), [enable_ccache=$enableval], [enable_ccache=yes])\nAC_MSG_CHECKING([whether to enable ccache-swig])\nAC_MSG_RESULT([$enable_ccache])\n\nif test \"$enable_ccache\" = yes; then\n  AC_CONFIG_SUBDIRS(CCache)\n  ENABLE_CCACHE=1\nfi\nAC_SUBST(ENABLE_CCACHE)\n\n\necho \"\"\necho \"Checking packages required for SWIG developers.\"\necho \"Note : None of the following packages are required for users to compile and install SWIG from the distributed tarball\"\necho \"\"\n\nAC_PROG_YACC\n\necho \"\"\necho \"Checking for installed target languages and other information in order to compile and run\"\necho \"the examples and test-suite invoked by 'make check'.\"\necho \"Note : None of the following packages are required for users to compile and install SWIG from the distributed tarball\"\necho \"\"\n\ndnl Some test cases require Boost\nAX_BOOST_BASE(,,,)\nAC_SUBST(BOOST_CPPFLAGS)\n\ndnl Info for building shared libraries ... in order to run the examples\n\n# SO is the extension of shared libraries (including the dot!)\nAC_MSG_CHECKING(SO)\nif test -z \"$SO\"\nthen\n\tcase $host in\n\t*-*-hp*) SO=.sl;;\n\t*-*-darwin*) SO=.bundle;;\n\t*-*-cygwin* | *-*-mingw*) SO=.dll;;\n\t*) SO=.so;;\n\tesac\nfi\nAC_MSG_RESULT($SO)\n\n# LDSHARED is the ld *command* used to create shared library\n# -- \"ld\" on SunOS 4.x.x, \"ld -G\" on SunOS 5.x, \"ld -shared\" on IRIX 5\n# (Shared libraries in this instance are shared modules to be loaded into\n# Python, as opposed to building Python itself as a shared library.)\nAC_MSG_CHECKING(LDSHARED)\nif test -z \"$LDSHARED\"\nthen\n\tcase $host in\n\t*-*-aix*) LDSHARED=\"\\$(srcdir)/ld_so_aix \\$(CC)\";;\n\t*-*-cygwin* | *-*-mingw*)\n            if test \"$GCC\" = yes; then\n                LDSHARED=\"$CC -shared\"\n            else\n                if test \"cl\" = $CC ;  then\n                    # Microsoft Visual C++ (MSVC)\n                    LDSHARED=\"$CC -nologo -LD\"\n                else\n                    # Unknown compiler try gcc approach\n                    LDSHARED=\"$CC -shared\"\n                fi\n            fi ;;\n\t*-*-irix5*) LDSHARED=\"ld -shared\";;\n\t*-*-irix6*) LDSHARED=\"ld ${SGI_ABI} -shared -all\";;\n\t*-*-sunos4*) LDSHARED=\"ld\";;\n\t*-*-solaris*) LDSHARED=\"ld -G\";;\n\t*-*-hp*) LDSHARED=\"ld -b\";;\n\t*-*-osf*) LDSHARED=\"ld -shared -expect_unresolved \\\"*\\\"\";;\n\t*-sequent-sysv4) LDSHARED=\"ld -G\";;\n\t*-*-next*)\n\t\tif test \"$ns_dyld\"\n\t\tthen LDSHARED='$(CC) $(LDFLAGS) -bundle -prebind'\n\t\telse LDSHARED='$(CC) $(CFLAGS) -nostdlib -r'\n\t\tfi\n                if test \"$with_next_framework\" ; then\n\t\t    LDSHARED=\"$LDSHARED \\$(LDLIBRARY)\"\n\t\tfi ;;\n\t*-*-linux*) LDSHARED=\"$CC -shared\";;\n\t*-*-dgux*) LDSHARED=\"ld -G\";;\n\t*-*-freebsd3*) LDSHARED=\"$CC -shared\";;\n\t*-*-freebsd* | *-*-openbsd*) LDSHARED=\"ld -Bshareable\";;\n\t*-*-netbsd*)\n\t\tif [[ \"`$CC -dM -E - </dev/null | grep __ELF__`\" != \"\" ]]\n\t\tthen\n\t\t\tLDSHARED=\"$CC -shared\"\n\t\telse\n\t\t\tLDSHARED=\"ld -Bshareable\"\n\t\tfi;;\n\t*-sco-sysv*) LDSHARED=\"$CC -G -KPIC -Ki486 -belf -Wl,-Bexport\";;\n\t*-*-darwin*) LDSHARED=\"$CC -bundle -undefined suppress -flat_namespace\";;\n\t*)\tLDSHARED=\"ld\";;\n\tesac\nfi\nAC_MSG_RESULT($LDSHARED)\n# CXXSHARED is the ld *command* used to create C++ shared library\n# -- \"ld\" on SunOS 4.x.x, \"ld -G\" on SunOS 5.x, \"ld -shared\" on IRIX 5\n# (Shared libraries in this instance are shared modules to be loaded into\n# Python, as opposed to building Python itself as a shared library.)\nAC_MSG_CHECKING(CXXSHARED)\nif test -z \"$CXXSHARED\"\nthen\n\tCXXSHARED=\"$LDSHARED\"\nfi\nAC_MSG_RESULT($CXXSHARED)\n\n#\nAC_MSG_CHECKING(TRYLINKINGWITHCXX)\nif test -z \"$TRYLINKINGWITHCXX\"\nthen\n\tcase $host in\n\t*-*-solaris*) if test \"$GCC\" = yes\n             then TRYLINKINGWITHCXX=\"CXXSHARED= $CXX -Wl,-G\"\n             else TRYLINKINGWITHCXX=\"CXXSHARED= $CXX -G -L/opt/SUNWspro/lib -lCrun -lCstd\"\n             fi;;\n        *-*-hp*) TRYLINKINGWITHCXX=\"CXXSHARED= $CXX +z \";;\n        *-*-darwin*) TRYLINKINGWITHCXX=\"CXXSHARED= $CXX -bundle -undefined suppress -flat_namespace\";;\n        *-*-cygwin* | *-*-mingw*)\n            if test \"$GCC\" = yes; then\n                TRYLINKINGWITHCXX=\"CXXSHARED= $CXX -shared \"\n            else\n                if test \"cl\" = $CXX ;  then\n                    # Microsoft Visual C++ (MSVC)\n                    TRYLINKINGWITHCXX=\"CXXSHARED= $CXX -nologo -LD\"\n                else\n                    TRYLINKINGWITHCXX=\"#unknown Windows compiler\"\n                fi\n            fi ;;\n        *)       TRYLINKINGWITHCXX=\"CXXSHARED= $CXX -shared \";;\n        esac\nfi\nAC_MSG_RESULT($TRYLINKINGWITHCXX)\n# CCSHARED are the C *flags* used to create objects to go into a shared\n# library (module) -- this is only needed for a few systems\nAC_MSG_CHECKING(CCSHARED)\nif test -z \"$CCSHARED\"\nthen\n\tcase $host in\n\t*-*-hp*) if test \"$GCC\" = yes\n\t\t then CCSHARED=\"-fpic\"\n\t\t else CCSHARED=\"+z\"\n\t\t fi;;\n\ts390x*-*-*) CCSHARED=\"-fpic\" ;;\n\ts390*-*-*) CCSHARED=\"-fPIC\" ;;\n\t*-*-linux*) CCSHARED=\"-fpic\";;\n\t*-*-freebsd* | *-*-openbsd*) CCSHARED=\"-fpic\";;\n\t*-*-netbsd*) CCSHARED=\"-fPIC\";;\n\t*-sco-sysv*) CCSHARED=\"-KPIC -dy -Bdynamic\";;\n\t*-*-irix6*)  case $CC in\n\t\t   *gcc*) CCSHARED=\"-shared\";;\n\t\t   *) CCSHARED=\"\";;\n\t\t   esac;;\n\tesac\nfi\nAC_MSG_RESULT($CCSHARED)\n\n# RPATH is the path used to look for shared library files.\nAC_MSG_CHECKING(RPATH)\nif test -z \"$RPATH\"\nthen\n\tcase $host in\n\t*-*-solaris*) RPATH='-R. -R$(exec_prefix)/lib';;\n        *-*-irix*) RPATH='-rpath .:$(exec_prefix)/lib';;\n\t*-*-linux*) RPATH='-Xlinker -rpath $(exec_prefix)/lib -Xlinker -rpath .';;\n\t*)\tRPATH='';;\n\tesac\nfi\nAC_MSG_RESULT($RPATH)\n\n# LINKFORSHARED are the flags passed to the $(CC) command that links\n# a few executables -- this is only needed for a few systems\n\nAC_MSG_CHECKING(LINKFORSHARED)\nif test -z \"$LINKFORSHARED\"\nthen\n\tcase $host in\n\t*-*-aix*)\tLINKFORSHARED='-Wl,-bE:$(srcdir)/python.exp -lld';;\n\t*-*-hp*)\n\t    LINKFORSHARED=\"-Wl,-E -Wl,+s -Wl,+b\\$(BINLIBDEST)/lib-dynload\";;\n\t*-*-linux*) LINKFORSHARED=\"-Xlinker -export-dynamic\";;\n\t*-*-next*) LINKFORSHARED=\"-u libsys_s\";;\n\t*-sco-sysv*) LINKFORSHARED=\"-Bdynamic -dy -Wl,-Bexport\";;\n\t*-*-irix6*) LINKFORSHARED=\"-all\";;\n\tesac\nfi\nAC_MSG_RESULT($LINKFORSHARED)\n\n# Optional CFLAGS used to silence/enhance compiler warnings on some platforms.\nAC_MSG_CHECKING(PLATCFLAGS)\ncase $host in\n  *-*-solaris*) if test \"$GCC\" = yes\n    then PLATCFLAGS=\n    else PLATCFLAGS=\n      #    else PLATCFLAGS=\"-errtags=yes\" # Need more work as C examples use ld for linking\n    fi;;\n  *) PLATCFLAGS=\nesac\nAC_MSG_RESULT($PLATCFLAGS)\n\n# Add switch if necessary to enable C++11 support - just for tests\nAC_ARG_ENABLE([cpp11-testing], AS_HELP_STRING([--enable-cpp11-testing], [enable C++11 testing if supported by compiler (default disabled)]), [enable_cpp11_testing=$enableval], [enable_cpp11_testing=no])\nAC_MSG_CHECKING([whether to enable C++11 testing])\nAC_MSG_RESULT([$enable_cpp11_testing])\n\nPLATCXXFLAGS=\"$PLATCFLAGS\"\nif test x\"$enable_cpp11_testing\" = xyes; then\n  AC_LANG_PUSH([C++])\n  CXXFLAGS_SAVED=$CXXFLAGS\n  CXXFLAGS=\n  AX_CXX_COMPILE_STDCXX_11([noext], [nostop])\n  CXXFLAGS=$CXXFLAGS_SAVED\n  AC_LANG_POP([C++])\n  if test x\"$CXX11FLAGS\" != x; then\n    PLATCXXFLAGS=\"$CXX11FLAGS $PLATCXXFLAGS\"\n  fi\n  AC_MSG_CHECKING([for C++11 enabled compiler])\n  if test x\"$HAVE_CXX11_COMPILER\" = x; then\n    AC_MSG_RESULT([no])\n  else\n    AC_MSG_RESULT([$HAVE_CXX11_COMPILER])\n  fi\nfi\n\n# On darwin 10.7,10.8,10.9 using clang++, need to ensure using\n# libc++ for tests and examples to run under mono. May affect\n# other language targets as well - problem is a Mac OS X incompatibility\n# between libraries depending on libstdc++ and libc++.\nCLANGXX=\n$CXX -v 2>&1 | grep -i clang >/dev/null && CLANGXX=yes\ncase $host in\n  *-*-darwin11* | *-*-darwin12* |*-*-darwin13*  ) if test \"$CLANGXX\" = \"yes\";\n    then PLATCXXFLAGS=\"$PLATCXXFLAGS -stdlib=libc++\"\n    fi;;\n  *) ;;\nesac\n\n# Check for compiler pre-compiled header support\nAC_MSG_CHECKING([if compiler supports pre-compiled headers])\nPCHSUPPORT=no\nif test \"$CLANGXX\" = \"yes\"; then\n   PCHINCLUDEARG=\"-include-pch\"\n   PCHINCLUDEEXT=\".gch\"\nelse\n   PCHINCLUDEARG=\"-include\"\n   PCHINCLUDEEXT=\"\"\nfi\nAC_LANG_PUSH([C++])\necho '#include <cstdlib>' > conftest.hpp\necho '#include \"conftest.hpp\"' > conftest.cpp\n$CXX -c conftest.hpp 2>/dev/null\nif test $? -eq 0; then\n   if test -f conftest.hpp.gch; then\n      $CXX -H -c -I. ${PCHINCLUDEARG} ./conftest.hpp${PCHINCLUDEEXT} -o conftest.o conftest.cpp >conftest.out 2>&1\n      if test $? -eq 0; then\n         if test \"$CLANGXX\" = \"yes\"; then\n            PCHSUPPORT=yes\n         elif grep -q '^!.*conftest.hpp.gch$' conftest.out; then\n            PCHSUPPORT=yes\n         fi\n      fi\n   fi\nfi\nrm -f conftest.hpp conftest.cpp conftest.out\nAC_LANG_POP([C++])\nAC_MSG_RESULT([$PCHSUPPORT])\nAC_SUBST(PCHSUPPORT)\nAC_SUBST(PCHINCLUDEARG)\nAC_SUBST(PCHINCLUDEEXT)\n\n# Set info about shared libraries.\nAC_SUBST(SO)\nAC_SUBST(LDSHARED)\nAC_SUBST(CCSHARED)\nAC_SUBST(CXXSHARED)\nAC_SUBST(TRYLINKINGWITHCXX)\nAC_SUBST(RPATH)\nAC_SUBST(PLATCFLAGS)\nAC_SUBST(PLATCXXFLAGS)\nAC_SUBST(HAVE_CXX11_COMPILER)\nAC_SUBST(LINKFORSHARED)\n\n# This variation is needed on OS-X because there is no (apparent) consistency in shared library naming.\n# Sometimes .bundle works, but sometimes .so is needed.  It depends on the target language\n\nAC_SUBST(PYTHON_SO)\ncase $host in\n   *-*-mingw*) PYTHON_SO=.pyd;;\n   *-*-darwin*) PYTHON_SO=.so;;\n   *) PYTHON_SO=$SO;;\nesac\n\nAC_SUBST(TCL_SO)\ncase $host in\n   *-*-darwin*) TCL_SO=.dylib;;\n   *) TCL_SO=$SO;;\nesac\n\nAC_SUBST(GUILE_SO)\ncase $host in\n   *-*-darwin*) GUILE_SO=.so;;\n   *) GUILE_SO=$SO;;\nesac\n\nAC_SUBST(PHP_SO)\ncase $host in\n   *-*-darwin*) PHP_SO=.so;;\n   *) PHP_SO=$SO;;\nesac\n\nAC_SUBST(MZSCHEME_SO)\ncase $host in\n   *) MZSCHEME_SO=.so;;\nesac\n\nAC_SUBST(LUA_SO)\ncase $host in\n   *-*-darwin*) LUA_SO=.so;;\n   *) LUA_SO=$SO;;\nesac\n\nAC_SUBST(FORTRAN_SO)\ncase $host in\n   *-*-darwin*) FORTRAN_SO=.dylib;;\n   *) FORTRAN_SO=$SO;;\nesac\n\n# Check for specific libraries.   Used for SWIG examples\nAC_CHECK_LIB(dl, dlopen)\t# Dynamic linking for SunOS/Solaris and SYSV\nAC_CHECK_LIB(dld, shl_load)\t# Dynamic linking for HP-UX\n\ndnl The following three libraries (nsl,inet,socket) are needed on Sequent,\ndnl and must be checked for in this order since each library depends on the\ndnl preceding one.\ndnl\ndnl Most SVR4 platforms will need -lsocket and -lnsl.  However on SGI IRIX 5,\ndnl these exist but are broken, so we use AC_SEARCH_LIBS which will only try\ndnl the library if the function isn't already available without it.\nAC_SEARCH_LIBS(t_open, nsl) # SVR4\nAC_SEARCH_LIBS(gethostbyname, inet) # Sequent\nAC_SEARCH_LIBS(socket, socket) # SVR4 sockets\n\nAC_CHECK_LIB(swill, swill_init, [SWIGLIBS=\"-lswill $LIBS\" SWILL=\"-DSWIG_SWILL\"])\nAC_SUBST(SWIGLIBS)\nAC_SUBST(SWILL)\n\n# check for --with-libm=...\nAC_SUBST(LIBM)\nLIBM=-lm\nAC_ARG_WITH(libm, [  --with-libm=STRING      math library], [\nif test \"$withval\" != yes\nthen LIBM=$withval\nelse AC_MSG_ERROR([proper usage is --with-libm=STRING])\nfi])\nAC_CHECK_LIB(ieee, main, [LIBM=\"-lieee $LIBM\"])\nAC_CHECK_LIB(crypt,crypt, [LIBCRYPT=\"-lcrypt\"])\nAC_SUBST(LIBCRYPT)\n\n# check for --with-libc=...\nAC_SUBST(LIBC)\nAC_ARG_WITH(libc, [  --with-libc=STRING      C library], [\nif test \"$withval\" != yes\nthen LIBC=$withval\nelse AC_MSG_ERROR([proper usage is --with-libc=STRING])\nfi])\n\n#--------------------------------------------------------------------\n# Target languages\n#--------------------------------------------------------------------\n\nAC_ARG_WITH(alllang, AS_HELP_STRING([--without-alllang], [Disable all languages]), with_alllang=\"$withval\")\n\nif test \"$with_alllang\" = \"no\"; then\n  alllang_default=no\nelse\n  alllang_default=yes\nfi\n\nAC_CHECK_PROGS(PKGCONFIG, [pkg-config])\n\n#--------------------------------------------------------------------\n# Look for Tcl\n#--------------------------------------------------------------------\n\nTCLINCLUDE=\nTCLLIB=\nTCLPACKAGE=\n\nAC_ARG_WITH(tclconfig, AS_HELP_STRING([--without-tcl], [Disable Tcl])\nAS_HELP_STRING([--with-tclconfig=path], [Set location of tclConfig.sh]), [with_tclconfig=\"$withval\"], [with_tclconfig=])\nAC_ARG_WITH(tcl,\n [  --with-tcl=path         Set location of Tcl package],[\n\tTCLPACKAGE=\"$withval\"], [TCLPACKAGE=\"$alllang_default\"])\nAC_ARG_WITH(tclincl,[  --with-tclincl=path     Set location of Tcl include directory],[\n\tTCLINCLUDE=\"-I$withval\"], [TCLINCLUDE=])\nAC_ARG_WITH(tcllib,[  --with-tcllib=path      Set location of Tcl library directory],[\n\tTCLLIB=\"-L$withval\"], [TCLLIB=])\n\n# First, check for \"--without-tcl\" or \"--with-tcl=no\".\nif test x\"${TCLPACKAGE}\" = xno; then\nAC_MSG_NOTICE([Disabling Tcl])\nelse\nAC_MSG_CHECKING([for Tcl configuration])\n# First check to see if --with-tclconfig was specified.\nif test x\"${with_tclconfig}\" != x ; then\n   if test -f \"${with_tclconfig}/tclConfig.sh\" ; then\n      TCLCONFIG=`(cd ${with_tclconfig}; pwd)`\n   else\n      AC_MSG_ERROR([${with_tcl} directory does not contain tclConfig.sh])\n   fi\nfi\n# check in a few common install locations\ndirs=\"/usr/lib*/ /usr/lib*/tcl*/ /usr/local/lib*/ /usr/local/lib*/tcl*/\"\ncase $host in\n*-*-darwin*)\n  dirs=\"/System/Library/Frameworks/Tcl.framework/ $dirs\"\n  ;;\n*)\n  ;;\nesac\nif test x\"${TCLCONFIG}\" = x ; then\n  for d in $dirs ; do\n    for i in `ls -d -r $d 2>/dev/null` ; do\n      if test -f $i\"tclConfig.sh\" ; then\n        TCLCONFIG=`(cd $i; pwd)`\n        break\n      fi\n    done\n  done\nfi\nif test x\"${TCLCONFIG}\" = x ; then\n    AC_MSG_RESULT(no)\nelse\n    AC_MSG_RESULT(found $TCLCONFIG/tclConfig.sh)\n    . $TCLCONFIG/tclConfig.sh\n    if test -z \"$TCLINCLUDE\"; then\n        TCLINCLUDE=`echo $TCL_INCLUDE_SPEC`\n    fi\n    if test -z \"$TCLLIB\"; then\n        TCLLIB=$TCL_LIB_SPEC\n    fi\nfi\n\nif test -z \"$TCLINCLUDE\"; then\n   if test \"x$TCLPACKAGE\" != xyes; then\n\tTCLINCLUDE=\"-I$TCLPACKAGE/include\"\n   fi\nfi\n\nif test -z \"$TCLLIB\"; then\n   if test \"x$TCLPACKAGE\" != xyes; then\n\tTCLLIB=\"-L$TCLPACKAGE/lib -ltcl\"\n   fi\nfi\n\nAC_MSG_CHECKING(for Tcl header files)\nif test -z \"$TCLINCLUDE\"; then\nAC_TRY_CPP([#include <tcl.h>], , TCLINCLUDE=\"\")\nif test -z \"$TCLINCLUDE\"; then\n\tdirs=\"/usr/local/include /usr/include /opt/local/include\"\n\tfor i in $dirs ; do\n\t\tif test -r $i/tcl.h; then\n\t\t\tAC_MSG_RESULT($i)\n\t\t\tTCLINCLUDE=\"-I$i\"\n\t\t\tbreak\n\t\tfi\n\tdone\nfi\nif test -z \"$TCLINCLUDE\"; then\n    \tAC_MSG_RESULT(not found)\nfi\nelse\n        AC_MSG_RESULT($TCLINCLUDE)\nfi\n\nAC_MSG_CHECKING(for Tcl library)\nif test -z \"$TCLLIB\"; then\ndirs=\"/usr/local/lib /usr/lib /opt/local/lib\"\nfor i in $dirs ; do\n\tif test -r $i/libtcl.a; then\n\t    AC_MSG_RESULT($i)\n\t    TCLLIB=\"-L$i -ltcl\"\n\t    break\n\tfi\ndone\nif test -z \"$TCLLIB\"; then\n\tAC_MSG_RESULT(not found)\nfi\nelse\nAC_MSG_RESULT($TCLLIB)\nfi\n\n# Cygwin (Windows) needs the library for dynamic linking\ncase $host in\n*-*-cygwin* | *-*-mingw*) TCLDYNAMICLINKING=\"$TCLLIB\";;\n*)TCLDYNAMICLINKING=\"\";;\nesac\n\ncase $host in\n*-*-darwin*)\n    TCLLDSHARED='$(CC) -dynamiclib -undefined suppress -flat_namespace'\n    TCLCXXSHARED='$(CXX) -dynamiclib -undefined suppress -flat_namespace'\n    ;;\n*)\n    TCLLDSHARED='$(LDSHARED)'\n    TCLCXXSHARED='$(CXXSHARED)'\n    ;;\nesac\n\nfi\n\nAC_SUBST(TCLINCLUDE)\nAC_SUBST(TCLLIB)\nAC_SUBST(TCLDYNAMICLINKING)\nAC_SUBST(TCLLDSHARED)\nAC_SUBST(TCLCXXSHARED)\n\n#----------------------------------------------------------------\n# Look for Python\n#----------------------------------------------------------------\n\nPYINCLUDE=\nPYLIB=\nPYLINK=\nPYPACKAGE=\n\nAC_ARG_WITH(python, AS_HELP_STRING([--without-python], [Disable Python])\nAS_HELP_STRING([--with-python=path], [Set location of Python executable]),[ PYBIN=\"$withval\"], [PYBIN=\"$alllang_default\"])\n\n# First, check for \"--without-python\" or \"--with-python=no\".\nif test x\"${PYBIN}\" = xno; then\n  AC_MSG_NOTICE([Disabling Python])\nelse\n  # First figure out the name of the Python executable\n  if test \"x$PYBIN\" = xyes; then\n    AC_CHECK_PROGS(PYTHON, [python python2.7])\n  else\n    PYTHON=\"$PYBIN\"\n  fi\n\n  PYVER=0\n  if test -n \"$PYTHON\"; then\n    AC_MSG_CHECKING([for $PYTHON major version number])\n    PYVER=`($PYTHON -c \"import sys; sys.stdout.write(sys.version[[0]])\") 2>/dev/null`\n    AC_MSG_RESULT($PYVER)\n    if test -z \"$PYVER\"; then\n      PYVER=0\n    else\n      AC_MSG_CHECKING(for Python os.name)\n      PYOSNAME=`($PYTHON -c \"import sys, os; sys.stdout.write(os.name)\") 2>/dev/null`\n      AC_MSG_RESULT($PYOSNAME)\n      AC_MSG_CHECKING(for Python path separator)\n      PYSEPARATOR=`($PYTHON -c \"import sys, os; sys.stdout.write(os.sep)\") 2>/dev/null`\n      AC_MSG_RESULT($PYSEPARATOR)\n    fi\n  fi\n\n  if test $PYVER -eq 1 -o $PYVER -eq 2; then\n    AC_MSG_CHECKING(for Python prefix)\n    PYPREFIX=`($PYTHON -c \"import sys; sys.stdout.write(sys.prefix)\") 2>/dev/null`\n    AC_MSG_RESULT($PYPREFIX)\n    AC_MSG_CHECKING(for Python exec-prefix)\n    PYEPREFIX=`($PYTHON -c \"import sys; sys.stdout.write(sys.exec_prefix)\") 2>/dev/null`\n    AC_MSG_RESULT($PYEPREFIX)\n\n    if test x\"$PYOSNAME\" = x\"nt\" -a x\"$PYSEPARATOR\" = x\"\\\\\"; then\n      # Windows installations are quite different to posix installations (MinGW path separator is a forward slash)\n      PYPREFIX=`echo \"$PYPREFIX\" | sed -e 's,\\\\\\\\,/,g'` # Forward slashes are easier to use and even work on Windows most of the time\n      PYTHON_SO=.pyd\n\n      AC_MSG_CHECKING(for Python header files)\n      if test -r $PYPREFIX/include/Python.h; then\n        PYINCLUDE=\"-I$PYPREFIX/include\"\n      fi\n      AC_MSG_RESULT($PYINCLUDE)\n\n      AC_MSG_CHECKING(for Python library directory)\n      if test -d $PYPREFIX/libs; then\n        PYLIB=$PYPREFIX/libs\n        PYLINKFILE=`ls $PYLIB/python*.lib | grep \"python[[0-9]][[0-9]]\\.lib\"`\n        if test -r \"$PYLINKFILE\"; then\n          PYLINK=-l`basename $PYLINKFILE | sed -e 's/\\.lib$//'`\n        else\n          PYLIB=\n        fi\n      fi\n    else\n      # Note: I could not think of a standard way to get the version string from different versions.\n      # This trick pulls it out of the file location for a standard library file.\n\n      AC_MSG_CHECKING(for Python version)\n\n      # Need to do this hack since autoconf replaces __file__ with the name of the configure file\n      filehack=\"file__\"\n      PYVERSION=`($PYTHON -c \"import sys,string,operator,os.path; sys.stdout.write(operator.getitem(os.path.split(operator.getitem(os.path.split(string.__$filehack),0)),1))\") 2>/dev/null`\n      AC_MSG_RESULT($PYVERSION)\n\n      # Find the directory for libraries this is necessary to deal with\n      # platforms that can have apps built for multiple archs: e.g. x86_64\n      AC_MSG_CHECKING(for Python lib dir)\n      PYLIBDIR=`($PYTHON -c \"import sys; sys.stdout.write(sys.lib)\") 2>/dev/null`\n      if test -z \"$PYLIBDIR\"; then\n        # Fedora patch Python to add sys.lib, for other distros we assume \"lib\".\n        PYLIBDIR=\"lib\"\n      fi\n      AC_MSG_RESULT($PYLIBDIR)\n\n      # Set the include directory\n\n      AC_MSG_CHECKING(for Python header files)\n      if test -r $PYPREFIX/include/$PYVERSION/Python.h; then\n        PYINCLUDE=\"-I$PYPREFIX/include/$PYVERSION -I$PYEPREFIX/$PYLIBDIR/$PYVERSION/config\"\n      fi\n      if test -z \"$PYINCLUDE\"; then\n        if test -r $PYPREFIX/include/Py/Python.h; then\n          PYINCLUDE=\"-I$PYPREFIX/include/Py -I$PYEPREFIX/$PYLIBDIR/python/lib\"\n        fi\n      fi\n      AC_MSG_RESULT($PYINCLUDE)\n\n      # Set the library directory blindly.   This probably won't work with older versions\n      AC_MSG_CHECKING(for Python library directory)\n      dirs=\"$PYVERSION/config $PYVERSION/$PYLIBDIR python/$PYLIBDIR\"\n      for i in $dirs; do\n        if test -d $PYEPREFIX/$PYLIBDIR/$i; then\n          PYLIB=\"$PYEPREFIX/$PYLIBDIR/$i\"\n          break\n        fi\n      done\n\n      PYLINK=\"-l$PYVERSION\"\n    fi\n\n    if test -z \"$PYLIB\"; then\n      AC_MSG_RESULT(Not found)\n    else\n      AC_MSG_RESULT($PYLIB)\n    fi\n    AC_MSG_CHECKING(for Python library)\n    if test -z \"$PYLINK\"; then\n      AC_MSG_RESULT(Not found)\n    else\n      AC_MSG_RESULT($PYLINK)\n    fi\n  fi\n\n  # Cygwin (Windows) needs the library for dynamic linking\n  case $host in\n  *-*-cygwin* | *-*-mingw*)\n    PYTHONDYNAMICLINKING=\"-L$PYLIB $PYLINK\"\n    DEFS=\"-DUSE_DL_IMPORT $DEFS\"\n    ;;\n  *)PYTHONDYNAMICLINKING=\"\";;\n  esac\nfi\n\nAC_SUBST(PYINCLUDE)\nAC_SUBST(PYLIB)\nAC_SUBST(PYLINK)\nAC_SUBST(PYTHONDYNAMICLINKING)\n\n\n#----------------------------------------------------------------\n# Look for Python 3.x\n#----------------------------------------------------------------\n\nPY3INCLUDE=\nPY3LIB=\nPY3LINK=\nPY3PACKAGE=\n\nAC_ARG_WITH(python3, AS_HELP_STRING([--without-python3], [Disable Python 3.x support])\nAS_HELP_STRING([--with-python3=path], [Set location of Python 3.x executable]),[ PY3BIN=\"$withval\"], [PY3BIN=\"$alllang_default\"])\n\n# First, check for \"--without-python3\" or \"--with-python3=no\".\nif test x\"${PY3BIN}\" = xno; then\n  AC_MSG_NOTICE([Disabling Python 3.x support])\nelse\n  if test -z \"$PYVER\"; then\n    PYVER=0\n  fi\n  if test \"x$PY3BIN\" = xyes; then\n    if test x\"$PYOSNAME\" = x\"nt\" -a x\"$PYSEPARATOR\" = x\"\\\\\" -a $PYVER -ge 3; then\n      PYTHON3=\"$PYTHON\"\n    else\n      for py_ver in 3 3.9 3.8 3.7 3.6 3.5 3.4 3.3 3.2 \"\"; do\n        AC_CHECK_PROGS(PYTHON3, [python$py_ver])\n        if test -n \"$PYTHON3\"; then\n          AC_CHECK_PROGS(PY3CONFIG, [$PYTHON3-config])\n          if test -n \"$PY3CONFIG\"; then\n            break\n          fi\n        fi\n      done\n    fi\n  else\n    PYTHON3=\"$PY3BIN\"\n    AC_CHECK_PROGS(PY3CONFIG, [$PYTHON3-config])\n  fi\n\n  if test -n \"$PYTHON3\"; then\n    AC_MSG_CHECKING([for $PYTHON3 major version number])\n    PYVER=`($PYTHON3 -c \"import sys; sys.stdout.write(sys.version[[0]])\") 2>/dev/null`\n    AC_MSG_RESULT($PYVER)\n    if test -z \"$PYVER\"; then\n      PYVER=0\n    fi\n  fi\n\n  if test $PYVER -ge 3; then\n    AC_MSG_CHECKING(for Python 3.x os.name)\n    PY3OSNAME=`($PYTHON3 -c \"import sys, os; sys.stdout.write(os.name)\") 2>/dev/null`\n    AC_MSG_RESULT($PY3OSNAME)\n    AC_MSG_CHECKING(for Python 3.x path separator)\n    PYSEPARATOR=`($PYTHON3 -c \"import sys, os; sys.stdout.write(os.sep)\") 2>/dev/null`\n    AC_MSG_RESULT($PYSEPARATOR)\n\n    if test x\"$PY3OSNAME\" = x\"nt\" -a x\"$PYSEPARATOR\" = x\"\\\\\"; then\n      # Windows installations are quite different to posix installations\n      # There is no python-config to use\n      AC_MSG_CHECKING(for Python 3.x prefix)\n      PY3PREFIX=`($PYTHON3 -c \"import sys; sys.stdout.write(sys.prefix)\") 2>/dev/null`\n      AC_MSG_RESULT($PY3PREFIX)\n      PY3PREFIX=`echo \"$PY3PREFIX\" | sed -e 's,\\\\\\\\,/,g'` # Forward slashes are easier to use and even work on Windows most of the time\n      PYTHON_SO=.pyd\n\n      AC_MSG_CHECKING(for Python 3.x header files)\n      if test -r $PY3PREFIX/include/Python.h; then\n        PY3INCLUDE=\"-I$PY3PREFIX/include\"\n      fi\n      AC_MSG_RESULT($PY3INCLUDE)\n\n      AC_MSG_CHECKING(for Python 3.x library directory)\n      if test -d $PY3PREFIX/libs; then\n        PY3LIB=$PY3PREFIX/libs\n        PY3LINKFILE=`ls $PY3LIB/python*.lib | grep \"python[[0-9]][[0-9]]\\.lib\"`\n        if test -r \"$PY3LINKFILE\"; then\n          PY3LINK=-l`basename $PY3LINKFILE | sed -e 's/\\.lib$//'`\n        else\n          PY3LIB=\n        fi\n      fi\n      if test -z \"$PY3LIB\"; then\n        AC_MSG_RESULT([Not found])\n      else\n        AC_MSG_RESULT($PY3LIB)\n      fi\n      AC_MSG_CHECKING([for Python 3.x library])\n      if test -z \"$PY3LINK\"; then\n        AC_MSG_RESULT(Not found)\n      else\n        AC_MSG_RESULT($PY3LINK)\n      fi\n    elif test -n \"$PY3CONFIG\"; then\n      AC_MSG_CHECKING([for Python 3.x prefix])\n      PY3PREFIX=`($PY3CONFIG --prefix) 2>/dev/null`\n      AC_MSG_RESULT($PY3PREFIX)\n      AC_MSG_CHECKING(for Python 3.x exec-prefix)\n      # Piped through xargs to strip trailing whitespace (bug in msys2 + mingw Python)\n      PY3EPREFIX=`($PY3CONFIG --exec-prefix | xargs) 2>/dev/null`\n      AC_MSG_RESULT($PY3EPREFIX)\n\n      # Note: I could not think of a standard way to get the version string from different versions.\n      # This trick pulls it out of the file location for a standard library file.\n\n      AC_MSG_CHECKING([for Python 3.x version])\n\n      # Need to do this hack since autoconf replaces __file__ with the name of the configure file\n      filehack=\"file__\"\n      PY3VERSION=`($PYTHON3 -c \"import string,operator,os.path; print(operator.getitem(os.path.split(operator.getitem(os.path.split(string.__$filehack),0)),1))\") 2>/dev/null`\n      AC_MSG_RESULT($PY3VERSION)\n\n      # Find the directory for libraries this is necessary to deal with\n      # platforms that can have apps built for multiple archs: e.g. x86_64\n      AC_MSG_CHECKING([for Python 3.x lib dir])\n      PY3LIBDIR=`($PYTHON3 -c \"import sys; print(sys.lib)\") 2>/dev/null`\n      if test -z \"$PY3LIBDIR\"; then\n        # some dists don't have sys.lib  so the best we can do is assume lib\n        PY3LIBDIR=\"lib\"\n      fi\n      AC_MSG_RESULT($PY3LIBDIR)\n\n      # Set the include directory\n\n      AC_MSG_CHECKING([for Python 3.x header files])\n      PY3INCLUDE=`($PY3CONFIG --includes) 2>/dev/null`\n      AC_MSG_RESULT($PY3INCLUDE)\n\n      # Set the library directory blindly.   This probably won't work with older versions\n      AC_MSG_CHECKING([for Python 3.x library directory])\n      dirs=\"$PY3VERSION/config $PY3VERSION/$PY3LIBDIR python/$PY3LIBDIR\"\n      for i in $dirs; do\n        if test -d $PY3EPREFIX/$PY3LIBDIR/$i; then\n          PY3LIB=\"$PY3EPREFIX/$PY3LIBDIR/$i\"\n          break\n        fi\n      done\n      if test -z \"$PY3LIB\"; then\n        AC_MSG_RESULT([Not found])\n      else\n        AC_MSG_RESULT($PY3LIB)\n      fi\n\n      PY3LINK=\"-l$PY3VERSION\"\n\n      AC_MSG_CHECKING([for Python 3.x library])\n      if test -z \"$PY3LINK\"; then\n        AC_MSG_RESULT(Not found)\n      else\n        AC_MSG_RESULT($PY3LINK)\n      fi\n    fi\n  fi\n\n  # Cygwin (Windows) needs the library for dynamic linking\n  case $host in\n  *-*-cygwin* | *-*-mingw*)\n    PYTHON3DYNAMICLINKING=\"-L$PY3LIB $PY3LINK\"\n    DEFS=\"-DUSE_DL_IMPORT $DEFS\"\n    ;;\n  *)PYTHON3DYNAMICLINKING=\"\";;\n  esac\n\n  AC_SUBST(PY3INCLUDE)\n  AC_SUBST(PY3LIB)\n  AC_SUBST(PY3LINK)\n  AC_SUBST(PYTHON3DYNAMICLINKING)\nfi\n\nif test -n \"$PYINCLUDE\" || test -n \"$PY3INCLUDE\" ; then\n  AC_CHECK_PROGS(PYCODESTYLE, pycodestyle)\n  if test -n \"$PYCODESTYLE\"; then\n    AC_MSG_CHECKING(pycodestyle version)\n    pycodestyle_version=`$PYCODESTYLE --version 2>/dev/null`\n    AC_MSG_RESULT($pycodestyle_version)\n  fi\nfi\n\nAC_ARG_WITH(2to3, AS_HELP_STRING([--with-2to3=path], [Set location of Python 2to3 tool]), [PY2TO3BIN=\"$withval\"], [PY2TO3BIN=\"yes\"])\nif test -n \"$PYTHON3\"; then\n  if test \"x$PY2TO3BIN\" = xyes; then\n    py3to2=`echo $PYTHON3 | sed -e \"s/python/2to3-/\"`\n    AC_CHECK_PROGS(PY2TO3, $py3to2 2to3)\n    if test -z \"$PY2TO3\"; then\n      # Windows distributions don't always have the 2to3 executable\n      AC_MSG_CHECKING(for 2to3.py)\n      py2to3script=\"$PY3PREFIX/Tools/scripts/2to3.py\"\n      if test -f \"$py2to3script\"; then\n        AC_MSG_RESULT($py2to3script)\n        PY2TO3=\"$PYTHON3 $py2to3script\"\n      else\n        AC_MSG_RESULT(Not found)\n      fi\n    fi\n  else\n    PY2TO3=\"$PY2TO3BIN\"\n  fi\n  if test -z \"$PY2TO3\"; then\n    PYTHON3=\n  fi\nfi\n\n#----------------------------------------------------------------\n# Look for Perl5\n#----------------------------------------------------------------\n\nPERLBIN=\n\nAC_ARG_WITH(perl5, AS_HELP_STRING([--without-perl5], [Disable Perl5])\nAS_HELP_STRING([--with-perl5=path], [Set location of Perl5 executable]),[ PERLBIN=\"$withval\"], [PERLBIN=\"$alllang_default\"])\n\n# First, check for \"--without-perl5\" or \"--with-perl5=no\".\nif test x\"${PERLBIN}\" = xno; then\nAC_MSG_NOTICE([Disabling Perl5])\nPERL=\nelse\n\n# First figure out what the name of Perl5 is\n\nif test \"x$PERLBIN\" = xyes; then\nAC_CHECK_PROGS(PERL, perl perl5.6.1 perl5.6.0 perl5.004 perl5.003 perl5.002 perl5.001 perl5 perl)\nelse\nPERL=\"$PERLBIN\"\nfi\n\n\n# This could probably be simplified as for all platforms and all versions of Perl the following apparently should be run to get the compilation options:\n# perl -MExtUtils::Embed -e ccopts\nAC_MSG_CHECKING(for Perl5 header files)\nif test -n \"$PERL\"; then\n\tPERL5DIR=`($PERL -MConfig -le 'print $Config{archlibexp}') 2>/dev/null`\n\tif test -n \"$PERL5DIR\" ; then\n\t\tdirs=\"$PERL5DIR $PERL5DIR/CORE\"\n\t\tPERL5EXT=none\n\t\tfor i in $dirs; do\n\t\t\tif test -r $i/perl.h; then\n\t\t\t\tAC_MSG_RESULT($i)\n\t\t\t\tPERL5EXT=\"$i\"\n\t\t\t\tbreak\n\t\t\tfi\n\t\tdone\n\t\tif test \"$PERL5EXT\" = none; then\n\t\t\tPERL5EXT=\"$PERL5DIR/CORE\"\n\t\t\tAC_MSG_RESULT(could not locate perl.h...using $PERL5EXT)\n\t\tfi\n\n\t\tAC_MSG_CHECKING(for Perl5 library)\n\t\tPERL5LIB=`($PERL -e 'use Config; $_=$Config{libperl}; s/^lib//; s/$Config{_a}$//; s/\\.$Config{so}.*//; print $_, \"\\n\"') 2>/dev/null`\n\t\tif test -z \"$PERL5LIB\" ; then\n\t\t\tAC_MSG_RESULT(not found)\n\t\telse\n\t\t\tAC_MSG_RESULT($PERL5LIB)\n\t\tfi\n    AC_MSG_CHECKING(for Perl5 ccflags)\n \t\tPERL5CCFLAGS=`($PERL -e 'use Config; print $Config{ccflags}, \"\\n\"' | sed \"s/-Wdeclaration-after-statement//\") 2>/dev/null`\n \t\tif test -z \"$PERL5CCFLAGS\" ; then\n \t\t\tAC_MSG_RESULT(not found)\n \t\telse\n \t\t\tAC_MSG_RESULT($PERL5CCFLAGS)\n \t\tfi\n    AC_MSG_CHECKING(for Perl5 ccdlflags)\n    PERL5CCDLFLAGS=`($PERL -e 'use Config; print $Config{ccdlflags}, \"\\n\"') 2>/dev/null`\n    if test -z \"$PERL5CCDLFLAGS\" ; then\n      AC_MSG_RESULT(not found)\n      else\n      AC_MSG_RESULT($PERL5CCDLFLAGS)\n    fi\n    AC_MSG_CHECKING(for Perl5 cccdlflags)\n    PERL5CCCDLFLAGS=`($PERL -e 'use Config; print $Config{cccdlflags}, \"\\n\"') 2>/dev/null`\n    if test -z \"$PERL5CCCDLFLAGS\" ; then\n      AC_MSG_RESULT(not found)\n      else\n      AC_MSG_RESULT($PERL5CCCDLFLAGS)\n    fi\n    AC_MSG_CHECKING(for Perl5 ldflags)\n    PERL5LDFLAGS=`($PERL -e 'use Config; print $Config{ldflags}, \"\\n\"') 2>/dev/null`\n    if test -z \"$PERL5LDFLAGS\" ; then\n      AC_MSG_RESULT(not found)\n      else\n      AC_MSG_RESULT($PERL5LDFLAGS)\n    fi\n    AC_MSG_CHECKING(for Perl5 Test::More module) # For test-suite\n    PERL5TESTMORE=`($PERL -e 'use Test::More; print \"good\";') 2>/dev/null`\n    if test -z \"$PERL5TESTMORE\" ; then\n      AC_MSG_RESULT(not found)\n      else\n      AC_MSG_RESULT(found)\n    fi\n\telse\n\t\tAC_MSG_RESULT(unable to determine perl5 configuration)\n\t\tPERL5EXT=$PERL5DIR\n\tfi\nelse\n       \tAC_MSG_RESULT(could not figure out how to run perl5)\nfi\n\n# Cygwin (Windows) needs the library for dynamic linking\ncase $host in\n*-*-cygwin* | *-*-mingw*) PERL5DYNAMICLINKING=\"-L$PERL5EXT -l$PERL5LIB\";;\n*)PERL5DYNAMICLINKING=\"\";;\nesac\nfi\n\nAC_SUBST(PERL)\nAC_SUBST(PERL5EXT)\nAC_SUBST(PERL5DYNAMICLINKING)\nAC_SUBST(PERL5LIB)\nAC_SUBST(PERL5CCFLAGS)\nAC_SUBST(PERL5CCDLFLAGS)\nAC_SUBST(PERL5CCCDLFLAGS)\nAC_SUBST(PERL5LDFLAGS)\n\n#----------------------------------------------------------------\n# Look for Octave\n#----------------------------------------------------------------\n\nOCTAVEBIN=\nOCTAVE_SO=.oct\n\nAC_ARG_WITH(octave, AS_HELP_STRING([--without-octave], [Disable Octave])\nAS_HELP_STRING([--with-octave=path], [Set location of Octave executable]),[OCTAVEBIN=\"$withval\"], [OCTAVEBIN=\"$alllang_default\"])\n\n# Check for \"--without-octave\" or \"--with-octave=no\".\nif test x\"${OCTAVEBIN}\" = xno; then\n   AC_MSG_NOTICE([Disabling Octave])\n   OCTAVE=\n\n# Check for Octave; prefer command-line program \"octave-cli\" to (in newer versions) GUI program \"octave\"\nelif test \"x$OCTAVEBIN\" = xyes; then\n   AC_PATH_PROG(OCTAVE, [octave-cli octave])\n\nelse\n   OCTAVE=\"$OCTAVEBIN\"\nfi\n\n# Check if Octave works\nif test -n \"$OCTAVE\"; then\n   AC_MSG_CHECKING([if ${OCTAVE} works])\n   AS_IF([test \"x`${OCTAVE} --version 2>/dev/null | sed -n -e '1p' | sed -n -e '/Octave, version/p'`\" != x],[\n      AC_MSG_RESULT([yes])\n   ],[\n      AC_MSG_RESULT([no])\n      OCTAVE=\n   ])\nfi\n\n# Check for required Octave helper program \"mkoctfile\"\nif test -n \"$OCTAVE\"; then\n  AC_MSG_CHECKING([for mkoctfile])\n  version_suffix=[\"`echo $OCTAVE | sed -e 's|.*\\(-[0-9][0-9.]*\\)$|\\1|'`\"]\n  case $version_suffix in\n    -*) ;;\n    *) version_suffix=\"\" ;;\n  esac\n  octave_directory=`dirname $OCTAVE`\n  if test \"$octave_directory\" = \".\" ; then\n    mkoctfile=\"mkoctfile${version_suffix}\"\n  else\n    mkoctfile=\"${octave_directory}/mkoctfile${version_suffix}\"\n  fi\n  AC_MSG_RESULT([${mkoctfile}])\n  AC_MSG_CHECKING([if ${mkoctfile} works])\n  mkoctfile=\"env - PATH=$PATH LD_LIBRARY_PATH=$LD_LIBRARY_PATH ${mkoctfile}\"\n  AS_IF([test \"x`${mkoctfile} --version 2>/dev/null | sed -n -e '1p' | sed -n -e '/mkoctfile, version/p'`\" != x],[\n      AC_MSG_RESULT([yes])\n    ],[\n      AC_MSG_RESULT([no])\n      OCTAVE=\n    ])\nfi\n\n# Check for Octave preprocessor/compiler/linker flags\nif test -n \"$OCTAVE\"; then\n\n   AC_MSG_CHECKING([for Octave preprocessor flags])\n   OCTAVE_CPPFLAGS=\n   for var in CPPFLAGS INCFLAGS ALL_CXXFLAGS; do\n      for flag in `${mkoctfile} -p ${var}`; do\n         case ${flag} in\n            -D*|-I*) OCTAVE_CPPFLAGS=\"${OCTAVE_CPPFLAGS} ${flag}\";;\n            *) ;;\n         esac\n      done\n   done\n   AC_MSG_RESULT([$OCTAVE_CPPFLAGS])\n\n   AC_MSG_CHECKING([for Octave compiler flags])\n   OCTAVE_CXXFLAGS=\n   for var in CXX ALL_CXXFLAGS; do\n      for flag in `${mkoctfile} -p ${var}`; do\n         case ${flag} in\n            -std=*|-g*|-W*) OCTAVE_CXXFLAGS=\"${OCTAVE_CXXFLAGS} ${flag}\";;\n            *) ;;\n         esac\n      done\n   done\n   save_CXXFLAGS=\"${CXXFLAGS}\"\n   CXXFLAGS=\"-Werror -O0\"\n   AC_COMPILE_IFELSE([\n      AC_LANG_PROGRAM([],[])\n   ],[\n      OCTAVE_CXXFLAGS=\"${OCTAVE_CXXFLAGS} -O0\"\n   ])\n   CXXFLAGS=\"${save_CXXFLAGS}\"\n   AC_MSG_RESULT([$OCTAVE_CXXFLAGS])\n\n   AC_MSG_CHECKING([for Octave linker flags])\n   OCTAVE_LDFLAGS=\n   for var in OCTLIBDIR; do\n     OCTAVE_LDFLAGS=\"${OCTAVE_LDFLAGS} \"-L`${mkoctfile} -p ${var}`\n   done\n   for var in RDYNAMIC_FLAG RLD_FLAG OCTAVE_LIBS LIBS; do\n     OCTAVE_LDFLAGS=\"${OCTAVE_LDFLAGS} \"`${mkoctfile} -p ${var}`\n   done\n   AC_MSG_RESULT([$OCTAVE_LDFLAGS])\n\nfi\n\n# Check for Octave options\nif test -n \"$OCTAVE\"; then\n   for octave_opt in --no-window-system --silent --norc --no-history; do\n      AC_MSG_CHECKING([if Octave option '${octave_opt}' is supported])\n      octave_out=`${OCTAVE} ${octave_opt} /dev/null 2>&1 | sed -n '1p' | sed -n '/unrecognized/p'`\n      AS_IF([test \"x${octave_out}\" = x],[\n         AC_MSG_RESULT([yes])\n         OCTAVE=\"${OCTAVE} ${octave_opt}\"\n      ],[\n         AC_MSG_RESULT([no])\n      ])\n   done\nfi\n\nAC_SUBST(OCTAVE)\nAC_SUBST(OCTAVE_SO)\nAC_SUBST(OCTAVE_CPPFLAGS)\nAC_SUBST(OCTAVE_CXXFLAGS)\nAC_SUBST(OCTAVE_LDFLAGS)\n\n#----------------------------------------------------------------\n# Look for Scilab\n#----------------------------------------------------------------\n\nAC_ARG_WITH(scilab, AS_HELP_STRING([--without-scilab], [Disable Scilab])\nAS_HELP_STRING([--with-scilab=path], [Set location of Scilab executable]),[SCILABBIN=\"$withval\"], [SCILABBIN=\"$alllang_default\"])\nAC_ARG_WITH(scilab-inc, [  --with-scilab-inc=path  Set location of Scilab include directory], [SCILABINCDIR=\"$withval\"], [SCILABINCDIR=\"\"])\n\n# First, check for \"--without-scilab\" or \"--with-scilab=no\".\nif test x\"${SCILABBIN}\" = xno; then\n  AC_MSG_NOTICE([Disabling Scilab])\n  SCILAB=\nelse\n  # Check for Scilab executable\n  if test \"x$SCILABBIN\" = xyes; then\n    AC_CHECK_PROGS(SCILAB, scilab)\n  else\n    AC_MSG_CHECKING(for scilab)\n    if test -f \"$SCILABBIN\"; then\n      AC_MSG_RESULT($SCILABBIN)\n      SCILAB=\"$SCILABBIN\"\n    else\n      AC_MSG_RESULT(not found)\n    fi\n  fi\n\n  if test -n \"$SCILAB\"; then\n    # Check for Scilab version (needs api_scilab so needs version 5.3.3 or higher)\n    SCILAB_FULL_VERSION=`$SCILAB -version | head -1 | sed -e 's|Scilab version \\\"\\(.*\\)\\\"|\\1|g'`\n\n    AC_MSG_CHECKING(Scilab version is 5.3.3 or higher)\n    SCILAB_MAJOR_VERSION=`echo $SCILAB_FULL_VERSION | cut -d. -f1`\n    SCILAB_MINOR_VERSION=`echo $SCILAB_FULL_VERSION | cut -d. -f2`\n    SCILAB_MAINTENANCE_VERSION=`echo $SCILAB_FULL_VERSION | cut -d. -f3`\n    SCILAB_VERSION=\"$SCILAB_MAJOR_VERSION$SCILAB_MINOR_VERSION$SCILAB_MAINTENANCE_VERSION\"\n\n    if test $SCILAB_VERSION -ge 533; then\n      AC_MSG_RESULT(yes)\n    else\n      AC_MSG_RESULT(no)\n      SCILAB=\n    fi\n\n    if test -n \"$SCILAB\"; then\n      # Set Scilab startup options depending on version\n      AC_MSG_CHECKING(for Scilab startup options)\n      SCILABOPT=\"-nwni -nb\"\n      if test $SCILAB_VERSION -ge 540; then\n        SCILABOPT+=\" -noatomsautoload\"\n      fi\n      AC_MSG_RESULT($SCILABOPT)\n\n      # Check for Scilab header files\n      AC_MSG_CHECKING(for Scilab header files)\n      if test \"$SCILABINCDIR\" != \"\"; then\n        dirs=\"$SCILABINCDIR\"\n      elif test -n \"$PKGCONFIG\"; then\n        dirs=`$PKGCONFIG scilab --cflags-only-I | sed -e 's/-I//g'`\n      else\n        dirs=\"\"\n      fi\n      for i in $dirs; do\n        if test -r $i/api_scilab.h; then\n          AC_MSG_RESULT($i)\n          SCILABINCLUDE=\"-I$i\"\n          break\n        fi\n        if test -r $i/scilab/api_scilab.h; then\n          AC_MSG_RESULT($i/scilab)\n          SCILABINCLUDE=\"-I$i/scilab\"\n          break\n        fi\n      done\n      if test \"$SCILABINCLUDE\" = \"\" ; then\n        AC_MSG_RESULT(not found)\n        SCILAB=\n      fi\n    fi\n  fi\nfi\n\nAC_SUBST(SCILAB)\nAC_SUBST(SCILABINCLUDE)\nAC_SUBST(SCILABOPT)\n\n\n#----------------------------------------------------------------\n# Look for java\n#----------------------------------------------------------------\n\nAC_ARG_WITH(java, AS_HELP_STRING([--without-java], [Disable Java])\nAS_HELP_STRING([--with-java=path], [Set location of java executable]),[JAVABIN=\"$withval\"], [JAVABIN=\"$alllang_default\"])\nAC_ARG_WITH(javac, [  --with-javac=path       Set location of javac executable],[JAVACBIN=\"$withval\"], [JAVACBIN=])\n\n# First, check for \"--without-java\" or \"--with-java=no\".\nif test x\"${JAVABIN}\" = xno; then\nAC_MSG_NOTICE([Disabling Java])\nJAVA=\nelse\n\ndnl Detect everything we need for Java: java for running Java tests, javac for\ndnl compiling them and C headers for compiling C code.\ndnl\ndnl If JAVA_HOME is defined and contains everything needed, as it's supposed to,\ndnl just use it. Otherwise try to locate the necessary files in the path.\ncase $host in\n  *-*-cygwin*)\n    dnl Ensure that JAVA_HOME is in the form we can use, it's typically set to Windows path by the installer.\n    if test -n \"$JAVA_HOME\"; then\n      JAVA_HOME=`cygpath --mixed \"$JAVA_HOME\"`\n    fi\n    dnl Java uses semicolons and not colons as separators in its classes search path under Windows.\n    JAVA_CLASSPATH_SEP=\";\"\n    ;;\n  *-*-mingw*)\n    if test -n \"$JAVA_HOME\"; then\n      JAVA_HOME=`${srcdir}/Tools/convertpath -u \"$JAVA_HOME\"`\n    fi\n    JAVA_CLASSPATH_SEP=\";\"\n    ;;\n  *-*-darwin*)\n    dnl Under OS X JAVA_HOME is not set by default, try to use the system default JRE.\n    if test -z \"$JAVA_HOME\" -a -x /usr/libexec/java_home; then\n      JAVA_HOME=`/usr/libexec/java_home`\n    fi\n    dnl The JAVA_HOME doesn't contain the JDK headers though, but they seem to\n    dnl always be in the same location, according to Apple JNI documentation.\n    JAVA_OSX_STD_INCDIR=\"/System/Library/Frameworks/JavaVM.framework/Headers\"\n    if test -r \"$JAVA_OSX_STD_INCDIR/jni.h\"; then\n      JAVA_HOME_INCDIR=$JAVA_OSX_STD_INCDIR\n    fi\n    JAVA_CLASSPATH_SEP=\":\"\n    ;;\n  *)\n    dnl Assume generic Unix.\n    JAVA_CLASSPATH_SEP=\":\"\n    ;;\nesac\n\nAC_MSG_CHECKING(for java JDK)\nif test -n \"$JAVA_HOME\"; then\n  dnl Don't complain about missing executables/headers if they had been\n  dnl explicitly overridden from the command line, but otherwise verify that we\n  dnl have everything we need.\n  java_home_ok=1\n  if test -z \"$JAVABIN\" -a ! -x \"$JAVA_HOME/bin/java\"; then\n    AC_MSG_WARN([No java executable under JAVA_HOME.])\n    java_home_ok=0\n  fi\n  if test -z \"$JAVACBIN\" -a ! -x \"$JAVA_HOME/bin/javac\"; then\n    AC_MSG_WARN([No javac executable under JAVA_HOME.])\n    java_home_ok=0\n  fi\n\n  dnl By default the headers are under JAVA_HOME/include, but OS X is special\n  dnl and defines JAVA_HOME_INCDIR differently above.\n  if test -z \"$JAVA_HOME_INCDIR\"; then\n    JAVA_HOME_INCDIR=\"$JAVA_HOME/include\"\n  fi\n  if test -z \"$JAVAINCDIR\" -a ! -r \"$JAVA_HOME_INCDIR/jni.h\"; then\n    AC_MSG_WARN([No java headers under JAVA_HOME (does it point to a JDK and not just JRE?).])\n    java_home_ok=0\n  fi\n  if test \"$java_home_ok\" = 1; then\n    AC_MSG_RESULT([found (in $JAVA_HOME)])\n  else\n    AC_MSG_RESULT(no)\n    AC_MSG_WARN([JAVA_HOME ($JAVA_HOME) is defined but does not point to a complete JDK installation, ignoring it.])\n    JAVA_HOME=\n  fi\nelse\n  AC_MSG_RESULT([no (JAVA_HOME is not defined)])\nfi\n\nif test \"x$JAVABIN\" = xyes; then\n  if test -n \"$JAVA_HOME\"; then\n    JAVA=\"$JAVA_HOME/bin/java\"\n  else\n    AC_CHECK_PROGS(JAVA, java kaffe guavac)\n  fi\nelse\n  JAVA=\"$JAVABIN\"\nfi\n\nif test -z \"$JAVACBIN\"; then\n  if test -n \"$JAVA_HOME\"; then\n    JAVAC=\"$JAVA_HOME/bin/javac\"\n  else\n    AC_CHECK_PROGS(JAVAC, javac)\n  fi\nelse\n  JAVAC=\"$JAVACBIN\"\nfi\n\n# Check Java version: we require Java 9 or later for Doxygen tests.\nif test -n \"$JAVAC\"; then\n    AC_MSG_CHECKING(if java version is 9 or greater)\n    javac_version=`\"$JAVAC\" -version 2>&1`\n    java_version_num=`echo $javac_version | sed -n 's/^javac //p'`\n    if test -z \"$java_version_num\"; then\n        AC_MSG_WARN([unknown format for Java version returned by \"$JAVAC\" ($javac_version)])\n        JAVA_SKIP_DOXYGEN_TEST_CASES=1\n        AC_MSG_RESULT(unknown)\n    else\n        dnl Until Java 8 version number was in format \"1.x\", starting from\n        dnl Java 9 it's just \"x\".\n        case $java_version_num in\n            1.*)\n                JAVA_SKIP_DOXYGEN_TEST_CASES=1\n                AC_MSG_RESULT([no, disabling Doxygen tests])\n                ;;\n\n            *)\n                AC_MSG_RESULT(yes)\n                ;;\n        esac\n    fi\n\n    AC_SUBST(JAVA_SKIP_DOXYGEN_TEST_CASES)\nfi\n\nAC_MSG_CHECKING(for java include file jni.h)\nAC_ARG_WITH(javaincl, [  --with-javaincl=path    Set location of Java include directory], [JAVAINCDIR=\"$withval\"], [JAVAINCDIR=])\n\nJAVAINC=\"\"\nif test -z \"$JAVAINCDIR\" ; then\n  if test -n \"$JAVA_HOME\"; then\n    JAVAINCDIR=\"$JAVA_HOME_INCDIR\"\n    JAVAINC=-I\\\"$JAVAINCDIR\\\"\n  else\n    JAVAINCDIR=\"/usr/j2sdk*/include /usr/local/j2sdk*/include /usr/jdk*/include /usr/local/jdk*/include /opt/j2sdk*/include /opt/jdk*/include /usr/java/include /usr/java/j2sdk*/include /usr/java/jdk*/include /usr/local/java/include /opt/java/include /usr/include/java /usr/local/include/java /usr/lib/java/include /usr/lib/jvm/java*/include /usr/lib64/jvm/java*/include /usr/include/kaffe /usr/local/include/kaffe /usr/include\"\n\n    # Add in default installation directory on Windows for Cygwin\n    case $host in\n    *-*-cygwin* | *-*-mingw*) JAVAINCDIR=\"c:/Program*Files*/Java/jdk*/include d:/Program*Files*/Java/jdk*/include c:/j2sdk*/include d:/j2sdk*/include c:/jdk*/include d:/jdk*/include $JAVAINCDIR\";;\n    *-*-darwin*) JAVAINCDIR=\"$JAVA_OSX_STD_INCDIR $JAVAINCDIR\";;\n    *);;\n    esac\n\n    for d in $JAVAINCDIR ; do\n      if test -r \"$d/jni.h\" ; then\n\tJAVAINCDIR=$d\n\tJAVAINC=-I\\\"$d\\\"\n\tJAVA_HOME_MAYBE=\"`dirname $d`\"\n\tbreak\n      fi\n    done\n  fi\nelse\n  if test -r \"$JAVAINCDIR/jni.h\" ; then\n    JAVAINC=-I\\\"$JAVAINCDIR\\\"\n  fi\nfi\n\nif test \"$JAVAINC\" = \"\" ; then\n  AC_MSG_RESULT(not found)\nelse\n  AC_MSG_RESULT($JAVAINC)\n  # now look for <arch>/jni_md.h\n  AC_MSG_CHECKING(for java include file jni_md.h)\n  JAVAMDDIR=`find \"$JAVAINCDIR\" -follow -name jni_md.h -print`\n  if test \"$JAVAMDDIR\" = \"\" ; then\n    AC_MSG_RESULT(not found)\n  else\n    JAVAMDDIR=-I\\\"`dirname \"$JAVAMDDIR\" | tail -1`\\\"\n    AC_MSG_RESULT($JAVAMDDIR)\n    JAVAINC=\"${JAVAINC} ${JAVAMDDIR}\"\n  fi\nfi\n\n# Auto-detecting JAVA_HOME is not so easy, below will only work up to and including jdk8\nif test -z \"$JAVA_HOME\" && test -n \"$JAVA_HOME_MAYBE\" ; then\n  AC_MSG_CHECKING(for java jdk from jni include paths)\n  if test -r \"$JAVA_HOME_MAYBE/lib/tools.jar\" ; then\n    JAVA_HOME=$JAVA_HOME_MAYBE\n    AC_MSG_RESULT([$JAVA_HOME])\n  else\n    AC_MSG_RESULT(not found)\n  fi\nfi\n\ncase $host in\n*-*-cygwin*)\n        # TODO: Only use this flag if the compiler supports it, later versions of gcc no longer have it\n        GCC_MNO_CYGWIN=\" -mno-cygwin\"\n        ;;\n*)\n        GCC_MNO_CYGWIN=\"\"\n        ;;\nesac\n\n# java.exe on Cygwin requires the Windows standard (Pascal) calling convention as it is a normal Windows executable and not a Cygwin built executable\ncase $host in\n*-*-cygwin* | *-*-mingw*)\n    if test \"$GCC\" = yes; then\n        JAVADYNAMICLINKING=\"$GCC_MNO_CYGWIN -mthreads -Wl,--add-stdcall-alias\"\n        JAVACFLAGS=\"$GCC_MNO_CYGWIN -mthreads\"\n    else\n        JAVADYNAMICLINKING=\"\"\n        JAVACFLAGS=\"\"\n    fi ;;\n*-*-darwin*)\n        JAVADYNAMICLINKING=\"-dynamiclib -framework JavaVM\"\n        JAVACFLAGS=\"\"\n        ;;\n*)\n        JAVADYNAMICLINKING=\"\"\n        JAVACFLAGS=\"\"\n        ;;\nesac\n\n# Java on Windows platforms including Cygwin doesn't use libname.dll, rather name.dll when loading dlls\ncase $host in\n*-*-cygwin* | *-*-mingw*) JAVALIBRARYPREFIX=\"\";;\n*)JAVALIBRARYPREFIX=\"lib\";;\nesac\n\n# Java on Mac OS X tweaks\ncase $host in\n*-*-darwin*)\n    JAVASO=\".jnilib\"\n    JAVALDSHARED='$(CC)'\n    JAVACXXSHARED='$(CXX)'\n    ;;\n*)\n    JAVASO=$SO\n    JAVALDSHARED='$(LDSHARED)'\n    JAVACXXSHARED='$(CXXSHARED)'\n    ;;\nesac\nfi\n\n# Quote for spaces in path to executables\nif test -n \"$JAVA\"; then\n  JAVA=\\\"$JAVA\\\"\nfi\nif test -n \"$JAVAC\"; then\n  JAVAC=\\\"$JAVAC\\\"\nfi\n\n# Turned off due to spurious warnings in later versions of openjdk-1.8\n# JAVAFLAGS=-Xcheck:jni\n\nAC_SUBST(JAVA)\nAC_SUBST(JAVAC)\nAC_SUBST(JAVAINC)\nAC_SUBST(JAVA_CLASSPATH_SEP)\nAC_SUBST(JAVADYNAMICLINKING)\nAC_SUBST(JAVALIBRARYPREFIX)\nAC_SUBST(JAVASO)\nAC_SUBST(JAVALDSHARED)\nAC_SUBST(JAVACXXSHARED)\nAC_SUBST(JAVAFLAGS)\nAC_SUBST(JAVACFLAGS)\n\n#----------------------------------------------------------------\n# Look for Javascript\n#----------------------------------------------------------------\nAC_ARG_WITH(javascript, AS_HELP_STRING([--without-javascript], [Disable Javascript]), [with_javascript=\"$withval\"], [with_javascript=\"$alllang_default\"])\n\n# First, check for \"--without-javascript\" or \"--with-javascript=no\".\nif test x\"${with_javascript}\" = xno; then\n  AC_MSG_NOTICE([Disabling Javascript])\n  JAVASCRIPT=\nelse\n  JAVASCRIPT=1\n\n  #----------------------------------------------------------------\n  # General Javascript settings shared by JSC and V8\n  #----------------------------------------------------------------\n\n  case $host in\n  *-*-darwin*)\n    JSSO=\".dylib\"\n    # HACK: didn't manage to get dynamic module loading working with a g++ compiled interpreter\n    JSINTERPRETERCXX='c++'\n    JSINTERPRETERLINKFLAGS='-g -Wl,-search_paths_first -Wl,-headerpad_max_install_names'\n    ;;\n  *)\n    JSSO=$SO\n    JSINTERPRETERCXX='$(CXX)'\n    JSINTERPRETERLINKFLAGS='-ldl'\n    ;;\n  esac\n\n  #----------------------------------------------------------------\n  # Look for Node.js which is the default Javascript engine\n  #----------------------------------------------------------------\n\n  AC_CHECK_PROGS(NODEJS, [nodejs node])\n\n  if test -n \"$NODEJS\"; then\n    # node-gyp is needed to run the test-suite/examples\n    AC_CHECK_PROGS(NODEGYP, node-gyp)\n    if test -z \"$NODEGYP\"; then\n      NODEJS=\n    fi\n  fi\n\n  #----------------------------------------------------------------\n  # Look for JavascriptCore (Webkit) settings (JSCOREINCDIR, JSCOREDYNAMICLINKING)\n  #----------------------------------------------------------------\n\n  # check for include files\n  AC_MSG_CHECKING(for JavaScriptCore/JavaScript.h)\n  AC_ARG_WITH(jscoreinc, [  --with-jscoreinc=path      Set location of Javascript include directory], [JSCOREINCDIR=\"$withval\"], [JSCOREINCDIR=])\n\n  JSCOREVERSION=\n\n  if test -z \"$JSCOREINCDIR\"; then\n    JSCOREINCDIR=\"/usr/include/ /usr/local/include/\"\n\n    # Add in default directory for JavaScriptCore headers for Linux and Mac OS X\n    case $host in\n    *-*-linux*)\n      JSCOREINCDIR=\"/usr/include/webkit-1.0/ /usr/include/webkitgtk-1.0/ /usr/local/include/webkit-1.0/JavaScriptCore/ $JSCOREINCDIR\"\n      ;;\n    *-*-darwin*)\n      JSCOREINCDIR=\"/System/Library/Frameworks/JavaScriptCore.framework/Headers/ $JSCOREINCDIR\"\n      ;;\n    *)\n      ;;\n    esac\n  fi\n\n  for d in $JSCOREINCDIR ; do\n    if test -r \"$d/JavaScriptCore/JavaScript.h\" || test -r \"$d/JavaScript.h\" ; then\n      AC_MSG_RESULT($d)\n      JSCOREINCDIR=$d\n      JSCOREINC=-I\\\"$d\\\"\n      break\n    fi\n  done\n\n  if test \"$JSCOREINC\" = \"\" ; then\n    AC_MSG_RESULT(not found)\n  fi\n\n  # check for JavaScriptCore/Webkit libraries\n  AC_ARG_WITH(jscorelib,[  --with-jscorelib=path      Set location of the JavaScriptCore/Webkit library directory],[JSCORELIB=\"-L$withval\"], [JSCORELIB=])\n\n  if test -z \"$JSCORELIB\" -a -n \"$PKGCONFIG\"; then\n    AC_MSG_CHECKING(for JavaScriptCore/Webkit library)\n    if $PKGCONFIG javascriptcoregtk-1.0; then\n      JSCORELIB=`$PKGCONFIG --libs javascriptcoregtk-1.0`\n      JSCOREVERSION=`$PKGCONFIG --modversion javascriptcoregtk-1.0`\n    fi\n    if test -z \"$JSCORELIB\"; then\n      AC_MSG_RESULT(not found)\n      JSCENABLED=\n    else\n      AC_MSG_RESULT([$JSCORELIB])\n      JSCOREDYNAMICLINKING=\"$JSCORELIB\"\n      JSCENABLED=1\n    fi\n  fi\n\n  #----------------------------------------------------------------\n  # Look for V8 settings (JSV8INCDIR, JSV8DYNAMICLINKING)\n  #----------------------------------------------------------------\n\n  # check for include files\n  AC_MSG_CHECKING(for V8 Javascript v8.h)\n  AC_ARG_WITH(jsv8inc, [  --with-jsv8inc=path     Set location of Javascript v8 include directory], [JSV8INCDIR=\"$withval\"], [JSV8INCDIR=])\n\n  # if not include dir is specified we try to find\n  if test -z \"$JSV8INCDIR\"; then\n    # Add in default directory for JavaScriptCore headers for Linux and Mac OS X\n    case $host in\n    *-*-linux*)\n      JSV8INCDIR=\"/usr/include /usr/local/include/ $JSV8INCDIR\"\n      ;;\n    *-*-darwin*)\n      JSV8INCDIR=\"$JSV8INCDIR\"\n      ;;\n    *)\n      ;;\n    esac\n  fi\n\n  for d in $JSV8INCDIR ; do\n    if test -r \"$d/v8.h\" ; then\n      JSV8INCDIR=$d\n      JSV8INC=-I\\\"$d\\\"\n      break\n    fi\n  done\n\n  if test \"$JSV8INC\" = \"\" ; then\n    AC_MSG_RESULT(not found)\n  else\n    AC_MSG_RESULT($JSV8INCDIR)\n  fi\n\n  # check for V8 library\n  AC_MSG_CHECKING(for V8 Javascript library)\n  AC_ARG_WITH(jsv8lib,[  --with-jsv8lib=path     Set location of V8 Javascript library directory],[JSV8LIBDIR=\"$withval\"], [JSV8LIB=])\n\n  v8libdirs=\"$JSV8LIBDIR /usr/lib64/ /usr/local/lib64/ /usr/lib/ /usr/local/lib/\"\n  for d in $v8libdirs ; do\n    if test -r $d/libv8$JSSO; then\n      JSV8LIBDIR=$d\n      JSV8LIB=\"-L$d -lv8\"\n      break\n    fi\n  done\n\n  if test \"$JSV8LIB\" = \"\" ; then\n    AC_MSG_RESULT(not found)\n    JSV8ENABLED=\n  else\n    AC_MSG_RESULT($JSV8LIBDIR)\n    JSV8ENABLED=1\n  fi\n\n\n  # linking options\n  case $host in\n  *-*-darwin*)\n    JSV8DYNAMICLINKING=\"$JSV8LIB\"\n    ;;\n  *-*-linux*)\n    JSV8DYNAMICLINKING=\"$JSV8LIB\"\n    ;;\n  *)\n    JSV8DYNAMICLINKING=\"\"\n    ;;\n  esac\n\nfi\n\nAC_SUBST(JSINTERPRETERCXX)\nAC_SUBST(JSINTERPRETERLINKFLAGS)\n\nAC_SUBST(JSCOREINC)\nAC_SUBST(JSCOREDYNAMICLINKING)\nAC_SUBST(JSCOREVERSION)\nAC_SUBST(JSV8INC)\nAC_SUBST(JSV8DYNAMICLINKING)\n\nAC_SUBST(JSCENABLED)\nAC_SUBST(JSV8ENABLED)\n\nAC_SUBST(NODEJS)\nAC_SUBST(NODEGYP)\n\n#----------------------------------------------------------------\n# Look for Android\n#----------------------------------------------------------------\n\nAC_ARG_WITH(android, AS_HELP_STRING([--without-android], [Disable Android])\nAS_HELP_STRING([--with-android=path], [Set location of android executable]),[ANDROIDBIN=\"$withval\"], [ANDROIDBIN=\"$alllang_default\"])\nAC_ARG_WITH(adb, [  --with-adb=path         Set location of adb executable - Android Debug Bridge],[ADBBIN=\"$withval\"], [ADBBIN=])\nAC_ARG_WITH(ant, [  --with-ant=path         Set location of ant executable for Android],[ANTBIN=\"$withval\"], [ANTBIN=])\nAC_ARG_WITH(ndk-build, [  --with-ndk-build=path   Set location of Android ndk-build executable],[NDKBUILDBIN=\"$withval\"], [NDKBUILDBIN=])\n\n# First, check for \"--without-android\" or \"--with-android=no\".\nif test x\"${ANDROIDBIN}\" = xno; then\n  AC_MSG_NOTICE([Disabling Android])\n  ANDROID=\nelse\n  if test \"x$ANDROIDBIN\" = xyes; then\n    AC_CHECK_PROGS(ANDROID, android)\n  else\n    ANDROID=\"$ANDROIDBIN\"\n  fi\n\n  if test -z \"$ADBBIN\"; then\n    AC_CHECK_PROGS(ADB, adb)\n  else\n    ADB=\"$ADBBIN\"\n  fi\n\n  if test -z \"$ANTBIN\"; then\n    AC_CHECK_PROGS(ANT, ant)\n  else\n    ANT=\"$ANTBIN\"\n  fi\n\n  if test -z \"$NDKBUILDBIN\"; then\n    AC_CHECK_PROGS(NDKBUILD, ndk-build)\n  else\n    NDKBUILD=\"$NDKBUILDBIN\"\n  fi\nfi\n\nAC_SUBST(ANDROID)\nAC_SUBST(ADB)\nAC_SUBST(ANT)\nAC_SUBST(NDKBUILD)\n\n#----------------------------------------------------------------\n# Look for Guile\n#----------------------------------------------------------------\n\nGUILE=\nGUILE_CFLAGS=\nGUILE_LIBS=\n\nAC_ARG_WITH(guile-config, AS_HELP_STRING([--without-guile], [Disable Guile])\nAS_HELP_STRING([--with-guile-config=path], [Set location of guile-config]),[ GUILE_CONFIG=\"$withval\"], [GUILE_CONFIG=])\nAC_ARG_WITH(guile,[  --with-guile=path       Set location of Guile executable],[\n\tGUILE=\"$withval\"], [GUILE=\"$alllang_default\"])\nAC_ARG_WITH(guile-cflags,[  --with-guile-cflags=cflags   Set cflags required to compile against Guile],[\n\tGUILE_CFLAGS=\"$withval\"])\nAC_ARG_WITH(guile-libs,[  --with-guile-libs=ldflags    Set ldflags needed to link with Guile],[\n\tGUILE_LIBS=\"$withval\"])\n\n# First, check for \"--without-guile\" or \"--with-guile=no\".\nif test x\"${GUILE}\" = xno; then\n  AC_MSG_NOTICE([Disabling Guile])\nelse\n  if test -z \"$GUILE_CONFIG\" ; then\n    AC_PATH_PROG(GUILE_CONFIG, guile-config)\n  fi\n  if test -n \"$GUILE_CONFIG\" ; then\n    if test x\"$GUILE\" = xyes; then\n      AC_MSG_CHECKING([for guile executable])\n      # Try extracting it via guile-config first. If it's defined there it's the most reliable result\n      GUILE=\"`$GUILE_CONFIG info guile 2>/dev/null`\"\n      if test -n \"$GUILE\";  then\n        AC_MSG_RESULT([$GUILE])\n      else\n        AC_MSG_RESULT([not found via guile-config - constructing path])\n        AC_MSG_CHECKING([for guile bindir])\n        guile_bindir=\"`$GUILE_CONFIG info bindir`\"\n        AC_MSG_RESULT([$guile_bindir])\n        GUILE=\"$guile_bindir/guile\"\n      fi\n      if ! test -f \"$GUILE\" ; then\n        GUILE=\n        AC_PATH_PROG(GUILE, guile)\n      fi\n      if test -z \"$GUILE\" ; then\n        AC_MSG_WARN([no suitable guile executable found. Disabling Guile])\n      fi\n    fi\n\n    if test -n \"$GUILE\" ; then\n      AC_MSG_CHECKING([for guile version])\n      guile_version=`$GUILE -c '(display (effective-version))'`\n      AC_MSG_RESULT([$guile_version])\n      AC_MSG_CHECKING([for guile version >= 1.8])\n      guile_good_version=`$GUILE -c '(if (>= (string->number (effective-version)) 1.8) (display \"yes\") (display \"no\"))'`\n      AC_MSG_RESULT([$guile_good_version])\n      if test x\"$guile_good_version\" != xyes ; then\n        AC_MSG_WARN([at least guile version 1.8 is required. Disabling Guile])\n        GUILE=\n      fi\n    fi\n\n    if test -n \"$GUILE\" ; then\n      # Test if guile-config and guile versions match. They should.\n      gc_version=\"`$GUILE_CONFIG --version 2>&1 | sed '1 s/.* //;q'`\"\n      g_version=\"`$GUILE --version | sed '1 s/.* //;q'`\"\n      if test \"$gc_version\" != \"$g_version\"; then\n        AC_MSG_WARN([different versions reported by $GUILE_CONFIG ($gc_version) and $GUILE ($g_version). Disabling Guile])\n        GUILE=\n      fi\n    fi\n\n    if test -n \"$GUILE\" ; then\n      if test -z \"$GUILE_CFLAGS\" ; then\n        AC_MSG_CHECKING([for guile compile flags])\n        GUILE_CFLAGS=\"`$GUILE_CONFIG compile`\" # Note that this can sometimes be empty\n        AC_MSG_RESULT([$GUILE_CFLAGS])\n      fi\n\n      if test -z \"$GUILE_LIBS\" ; then\n        AC_MSG_CHECKING([for guile link flags])\n        GUILE_LIBS=\"`$GUILE_CONFIG link`\"\n        AC_MSG_RESULT([$GUILE_LIBS])\n      fi\n    fi\n  fi\nfi\n\nAC_SUBST(GUILE)\nAC_SUBST(GUILE_CFLAGS)\nAC_SUBST(GUILE_LIBS)\n\n#----------------------------------------------------------------\n# Look for MzScheme\n#----------------------------------------------------------------\n\nAC_ARG_WITH(mzscheme, AS_HELP_STRING([--without-mzscheme], [Disable MzScheme])\nAS_HELP_STRING([--with-mzscheme=path], [Set location of MzScheme executable]),[ MZSCHEMEBIN=\"$withval\"], [MZSCHEMEBIN=\"$alllang_default\"])\nAC_ARG_WITH(mzc, AS_HELP_STRING([--with-mzc=path], [Set location of MzScheme's mzc]), [ MZCBIN=\"$withval\"], [MZCBIN=])\n\n# First, check for \"--without-mzscheme\" or \"--with-mzscheme=no\".\nif test x\"${MZSCHEMEBIN}\" = xno; then\n  AC_MSG_NOTICE([Disabling MzScheme])\n  MZC=\nelse\n  if test \"x$MZSCHEMEBIN\" = xyes; then\n     AC_PATH_PROG(MZSCHEME, mzscheme)\n  else\n     MZSCHEME=\"$MZSCHEMEBIN\"\n  fi\n\n  if test -z \"$MZCBIN\"; then\n     AC_PATH_PROG(MZC, mzc)\n  fi\n\n  if test -n \"$MZSCHEME\"; then\n    AC_MSG_CHECKING(for MzScheme dynext object)\n    MZDYNOBJ=`$MZSCHEME --eval '(begin (require dynext/link) (with-handlers (((lambda args #t) (lambda args #f))) (for-each (lambda (x) (printf \"~a\" x)) (expand-for-link-variant (current-standard-link-libraries)))))' 2>/dev/null`\n    if test -f \"$MZDYNOBJ\"; then\n      :\n    else\n      # older versions (3.72 approx and earlier)\n      MZDYNOBJ=`$MZSCHEME --mute-banner --version --eval '(begin (require (lib \"link.ss\" \"dynext\")) (with-handlers (((lambda args #t) (lambda args #f))) (for-each (lambda (x) (display x) (display \" \")) ((current-make-standard-link-libraries)))) (with-handlers (((lambda args #t) (lambda args #f))) (for-each (lambda (x) (display x)) (expand-for-link-variant (current-standard-link-libraries)))))' 2>/dev/null`\n    fi\n    if test -f \"$MZDYNOBJ\"; then\n      AC_MSG_RESULT($MZDYNOBJ)\n    else\n      AC_MSG_RESULT(not found)\n      MZDYNOBJ=\"\"\n    fi\n  fi\nfi\nAC_SUBST(MZDYNOBJ)\n\n#----------------------------------------------------------------\n# Look for Ruby\n#----------------------------------------------------------------\n\nRUBYBIN=\n\nAC_ARG_WITH(ruby, AS_HELP_STRING([--without-ruby], [Disable Ruby])\nAS_HELP_STRING([--with-ruby=path], [Set location of Ruby executable]),[ RUBYBIN=\"$withval\"], [RUBYBIN=\"$alllang_default\"])\n\n# First, check for \"--without-ruby\" or \"--with-ruby=no\".\nRUBYSO=$SO\nif test x\"${RUBYBIN}\" = xno; then\nAC_MSG_NOTICE([Disabling Ruby])\nRUBY=\nelse\n\n# First figure out what the name of Ruby is\n\nif test \"x$RUBYBIN\" = xyes; then\n\tAC_CHECK_PROGS(RUBY, ruby)\nelse\n\tRUBY=\"$RUBYBIN\"\nfi\n\nAC_MSG_CHECKING(for Ruby header files)\nif test -n \"$RUBY\"; then\n        # Try Ruby1.9+ first\n        RUBYDIR=`($RUBY -rrbconfig -e 'print RbConfig::CONFIG[[\"rubyhdrdir\"]] || $rubyhdrdir') 2>/dev/null`\n        RUBYARCHHDRDIR=`($RUBY -rrbconfig -e 'print RbConfig::CONFIG[[\"rubyarchhdrdir\"]] || $rubyarchhdrdir') 2>/dev/null`\n\tif test x\"$RUBYDIR\" = x\"\" || test x\"$RUBYDIR\" = x\"nil\"; then\n\t\tRUBYDIR=`($RUBY -rrbconfig -e 'print RbConfig::CONFIG[[\"archdir\"]] || $archdir') 2>/dev/null`\n        else\n                RUBYARCH=`($RUBY -rrbconfig -e 'print RbConfig::CONFIG[[\"arch\"]] || $arch') 2>/dev/null`\n        fi\n\tif test x\"$RUBYDIR\" != x\"\"; then\n\t\tdirs=\"$RUBYDIR\"\n\t\tRUBYINCLUDE=\n\t\tfor i in $dirs; do\n\t\t\tif test -r $i/ruby.h; then\n\t\t\t\tif test x\"$RUBYARCH\" = x\"\"; then\n\t\t\t\t\tRUBYINCLUDE=\"-I$i\"\n\t\t\t\telif test -n \"$RUBYARCHHDRDIR\"; then\n\t\t\t\t\tRUBYINCLUDE=\"-I$i -I$RUBYARCHHDRDIR\"\n\t\t\t\telse\n\t\t\t\t\tRUBYINCLUDE=\"-I$i -I$i/$RUBYARCH\"\n\t\t\t\tfi\n\t\t\t\tAC_MSG_RESULT($RUBYINCLUDE)\n\t\t\t\tbreak\n\t\t\tfi\n\t\tdone\n\t\tif test x\"$RUBYINCLUDE\" = x\"\"; then\n\t\t\tAC_MSG_RESULT(could not locate ruby.h)\n\t\tfi\n\n\t\t# Find library and path for linking.\n\t\tAC_MSG_CHECKING(for Ruby library)\n\t\tRUBYLIB=\"\"\n\t\trb_archlibdir=`($RUBY -rrbconfig -e 'print RbConfig::CONFIG[[\"archlibdir\"]]') 2>/dev/null`\n\t\trb_libdir=`($RUBY -rrbconfig -e 'print RbConfig::CONFIG[[\"libdir\"]]') 2>/dev/null`\n\t\trb_bindir=`($RUBY -rrbconfig -e 'print RbConfig::CONFIG[[\"bindir\"]]') 2>/dev/null`\n\t\tdirs=\"$dirs $rb_archlibdir $rb_libdir $rb_bindir\"\n\n        rb_libruby=`($RUBY -rrbconfig -e 'print RbConfig::CONFIG[[\"LIBRUBY_A\"]]') 2>/dev/null`\n        RUBYLINK=`($RUBY -rrbconfig -e '\n            c = RbConfig::CONFIG\n            if c.has_key? \"LIBRUBYARG_STATIC\" # 1.8.x\n                if c[[\"LIBRUBY\"]] == c[[\"LIBRUBY_A\"]]\n                    link = c[[\"LIBRUBYARG_STATIC\"]]\n                else\n                    link = c[[\"LIBRUBYARG_SHARED\"]]\n                end\n            else # 1.6.x\n                link = \"-l\" + c[[\"RUBY_INSTALL_NAME\"]]\n            end\n\n            # Get the target Ruby was built for\n            target = c[[\"target\"]]\n\n            if target == \"i386-pc-mswin32\"\n              # Need to change msvcrt-ruby*.lib to -lmsvcrt-ruby*\n              ext = File.extname(link)\n              # Get index that counts backwards from end of string\n              index = -1 - ext.size\n              # Strip off the extension\n              link = link.slice(0..index)\n              puts \"-l#{link}\"\n            else\n              puts link\n            end') 2>/dev/null`\n\n\t\tif test \"$rb_libruby\" != \"\"; then\n\t\t\tfor i in $dirs; do\n\t\t\t\tif (test -r $i/$rb_libruby;) then\n\t\t\t\t\tRUBYLIB=\"$i\"\n\t\t\t\t\tbreak\n\t\t\t\tfi\n\t\t\tdone\n\t\tfi\n\t\tif test \"$RUBYLIB\" = \"\"; then\n\t\t\tRUBYLIB=\"$RUBYDIR\"\n\t\t\tAC_MSG_RESULT(not found... using $RUBYDIR)\n\t\telse\n\t\t\tAC_MSG_RESULT($RUBYLINK in $RUBYLIB)\n\t\tfi\n\telse\n\t\tAC_MSG_RESULT(unable to determine ruby configuration)\n\tfi\n\n\tcase $host in\n\t\t*-*-mingw*) ;; # do nothing, the default windows libraries are already included\n\t\t*) RUBYLINK=\"$RUBYLINK `($RUBY -rrbconfig -e 'print RbConfig::CONFIG[[\"LIBS\"]]') 2>/dev/null`\";;\n\tesac\n\n\tRUBYCCDLFLAGS=`($RUBY -rrbconfig -e 'print RbConfig::CONFIG[[\"CCDLFLAGS\"]]') 2>/dev/null`\n\tRUBYSO=.`($RUBY -rrbconfig -e 'print RbConfig::CONFIG[[\"DLEXT\"]]') 2>/dev/null`\nelse\n\tAC_MSG_RESULT(could not figure out how to run ruby)\nfi\n\ncase $host in\n*-*-cygwin* | *-*-mingw*)\tRUBYDYNAMICLINKING=\"-L$RUBYLIB $RUBYLINK\";;\n*)\t\tRUBYDYNAMICLINKING=\"\";;\nesac\nfi\n\nAC_SUBST(RUBYINCLUDE)\nAC_SUBST(RUBYLIB)\nAC_SUBST(RUBYLINK)\nAC_SUBST(RUBYCCDLFLAGS)\nAC_SUBST(RUBYSO)\nAC_SUBST(RUBYDYNAMICLINKING)\n\n#-------------------------------------------------------------------------\n# Look for PHP7\n#-------------------------------------------------------------------------\n\nPHPBIN=\n\nAC_ARG_WITH(php, AS_HELP_STRING([--without-php], [Disable PHP])\nAS_HELP_STRING([--with-php=path], [Set location of PHP executable]),[ PHPBIN=\"$withval\"], [PHPBIN=\"$alllang_default\"])\n\n# First, check for \"--without-php\" or \"--with-php=no\".\nif test x\"${PHPBIN}\" = xno; then\n    AC_MSG_NOTICE([Disabling PHP])\n    PHP=\nelse\n    if test \"x$PHPBIN\" = xyes; then\n      AC_CHECK_PROGS(PHP, [php7.3 php7.2 php7.1 php7.0 php])\n    else\n      PHP=$PHPBIN\n    fi\n\n    if test -n \"$PHP\"; then\n      AC_MSG_CHECKING(for PHP header files)\n      dnl /usr/bin/php7.0 -> /usr/bin/php-config7.0\n      case $PHP in\n        *7.*)\n          PHPCONFIG=`echo \"$PHP\"|sed 's/7\\...*$/-config&/'` ;;\n        *)\n          PHPCONFIG=$PHP-config ;;\n      esac\n      php_version=`$PHPCONFIG --version 2>/dev/null`\n      case $php_version in\n      7.*)\n        PHPINC=`$PHPCONFIG --includes 2>/dev/null`\n        if test -n \"$PHPINC\"; then\n          AC_MSG_RESULT($PHPINC)\n        else\n          AC_MSG_RESULT(not found)\n        fi\n        ;;\n      \"\")\n        AC_MSG_RESULT([could not find $PHPCONFIG or obtain PHP version from it]) ;;\n      *)\n        AC_MSG_RESULT([found PHP $php_version - not PHP 7]) ;;\n      esac\n    fi\nfi\nAC_SUBST(PHP)\nAC_SUBST(PHPINC)\n\n#----------------------------------------------------------------\n# Look for OCaml\n#----------------------------------------------------------------\n\nAC_ARG_WITH(ocaml, AS_HELP_STRING([--without-ocaml], [Disable OCaml]), [with_ocaml=\"$withval\"], [with_ocaml=\"$alllang_default\"])\nAC_ARG_WITH(ocamlc,[  --with-ocamlc=path      Set location of ocamlc executable],[ OCAMLC=\"$withval\"], [OCAMLC=])\nAC_ARG_WITH(ocamldlgen,[  --with-ocamldlgen=path  Set location of ocamldlgen],[ OCAMLDLGEN=\"$withval\" ], [OCAMLDLGEN=])\nAC_ARG_WITH(ocamlfind,[  --with-ocamlfind=path   Set location of ocamlfind],[OCAMLFIND=\"$withval\"],[OCAMLFIND=])\nAC_ARG_WITH(ocamlmktop,[  --with-ocamlmktop=path  Set location of ocamlmktop executable],[ OCAMLMKTOP=\"$withval\"], [OCAMLMKTOP=])\nAC_ARG_WITH(camlp4,[  --with-camlp4=path  Set location of camlp4 executable],[ CAMLP4=\"$withval\"], [CAMLP4=])\n\n# First, check for \"--without-ocaml\" or \"--with-ocaml=no\".\nif test x\"${with_ocaml}\" = xno; then\n    AC_MSG_NOTICE([Disabling OCaml])\n    OCAMLC=\nelse\n    # OCaml compiler\n    if test -z \"$OCAMLC\"; then\n\tAC_CHECK_PROGS(OCAMLC, ocamlc)\n    fi\n\n    # OCaml Pre-Processor-Pretty-Printer\n    if test -z \"$CAMLP4\"; then\n\tAC_CHECK_PROGS(CAMLP4, camlp4)\n    fi\n\n    # OCaml DL load generator\n    if test -z \"$OCAMLDLGEN\"; then\n\tAC_CHECK_PROGS(OCAMLDLGEN, ocamldlgen)\n    fi\n\n    # OCaml package tool\n    if test -z \"$OCAMLFIND\"; then\n\tAC_CHECK_PROGS(OCAMLFIND, ocamlfind)\n    fi\n\n    # OCaml toplevel creator\n    if test -z \"$OCAMLMKTOP\"; then\n\tAC_CHECK_PROGS(OCAMLMKTOP, ocamlmktop)\n    fi\nfi\n\nAC_SUBST(OCAMLC)\nAC_SUBST(CAMLP4)\nAC_SUBST(OCAMLDLGEN)\nAC_SUBST(OCAMLFIND)\nAC_SUBST(OCAMLMKTOP)\n\n#----------------------------------------------------------------\n# Look for C#\n#----------------------------------------------------------------\n\nAC_ARG_WITH(csharp, AS_HELP_STRING([--without-csharp], [Disable CSharp]), [with_csharp=\"$withval\"], [with_csharp=\"$alllang_default\"])\nAC_ARG_WITH(cil-interpreter, [  --with-cil-interpreter=path     Set location of CIL interpreter for CSharp],[CSHARPBIN=\"$withval\"], [CSHARPBIN=])\nAC_ARG_WITH(csharp-compiler, [  --with-csharp-compiler=path     Set location of CSharp compiler],[CSHARPCOMPILERBIN=\"$withval\"], [CSHARPCOMPILERBIN=])\n\n# First, check for \"--without-csharp\" or \"--with-csharp=no\".\nif test x\"${with_csharp}\" = xno; then\nAC_MSG_NOTICE([Disabling CSharp])\nCSHARPCOMPILER=\nelse\n\nif test -z \"$CSHARPCOMPILERBIN\" ; then\n  case $host in\n  *-*-cygwin* | *-*-mingw*)\n    # prefer unified Mono mcs compiler (not to be confused with the ancient .NET 1 mcs) over older/alternative names.\n    AC_CHECK_PROGS(CSHARPCOMPILER, csc mcs mono-csc gmcs cscc)\n    if test -n \"$CSHARPCOMPILER\" && test \"$CSHARPCOMPILER\" = \"csc\" ; then\n      AC_MSG_CHECKING(whether csc is the Microsoft CSharp compiler)\n      csc 2>/dev/null | grep \"C#\" > /dev/null || CSHARPCOMPILER=\"\"\n      if test -z \"$CSHARPCOMPILER\" ; then\n        AC_MSG_RESULT(no)\n        AC_CHECK_PROGS(CSHARPCOMPILER, mcs mono-csc gmcs cscc)\n      else\n        AC_MSG_RESULT(yes)\n      fi\n    fi\n    ;;\n  *)AC_CHECK_PROGS(CSHARPCOMPILER, mono-csc gmcs mcs cscc);;\n  esac\nelse\n  CSHARPCOMPILER=\"$CSHARPCOMPILERBIN\"\nfi\n\nCSHARPCONVERTPATH=\"Tools/convertpath -u\"\nif test -z \"$CSHARPBIN\" ; then\n  CSHARPCILINTERPRETER=\"\"\n  CSHARPCILINTERPRETER_FLAGS=\"\"\n  if test \"cscc\" = \"$CSHARPCOMPILER\" ; then\n    AC_CHECK_PROGS(CSHARPCILINTERPRETER, ilrun)\n  else\n    if test \"mcs\" = \"$CSHARPCOMPILER\"; then\n      # Check that mcs is the C# compiler and not the Unix mcs utility by examining the output of 'mcs --version'\n      # The Mono compiler should emit: Mono C# compiler version a.b.c.d\n      csharp_version_raw=`(mcs --version) 2>/dev/null`\n      csharp_version_searched=`(mcs --version | sed -e \"/C#/b\" -e \"/Mono/b\" -e d) 2>/dev/null` # return string if contains 'Mono' or 'C#'\n      CSHARPCOMPILER=\"\"\n      if test -n \"$csharp_version_raw\" ; then\n        if test \"$csharp_version_raw\" = \"$csharp_version_searched\" ; then\n          CSHARPCOMPILER=\"mcs\"\n        fi\n      fi\n      if test \"mcs\" != \"$CSHARPCOMPILER\" ; then\n        echo \"mcs is not a working Mono C# compiler\"\n      fi\n    fi\n    if test \"mcs\" = \"$CSHARPCOMPILER\" || test \"gmcs\" = \"$CSHARPCOMPILER\" || test \"mono-csc\" = \"$CSHARPCOMPILER\"; then\n        AC_CHECK_PROGS(CSHARPCILINTERPRETER, mono) # Mono JIT\n        CSHARPCILINTERPRETER_FLAGS=\"--debug\"\n    else\n      if test \"csc\" = \"$CSHARPCOMPILER\"; then\n          CSHARPCONVERTPATH=\"Tools/convertpath -w\"\n      fi\n    fi\n  fi\nelse\n  CSHARPCILINTERPRETER=\"$CSHARPBIN\"\nfi\n\n# Cygwin requires the Windows standard (Pascal) calling convention as it is a Windows executable and not a Cygwin built executable\ncase $host in\n*-*-cygwin* | *-*-mingw*)\n    if test \"$GCC\" = yes; then\n        CSHARPDYNAMICLINKING=\"$GCC_MNO_CYGWIN -mthreads -Wl,--add-stdcall-alias\"\n        CSHARPCFLAGS=\"$GCC_MNO_CYGWIN -mthreads\"\n    else\n        CSHARPDYNAMICLINKING=\"\"\n        CSHARPCFLAGS=\"\"\n    fi ;;\n*)\n        CSHARPDYNAMICLINKING=\"\"\n        CSHARPCFLAGS=\"\"\n        ;;\nesac\n\n# CSharp on Windows platforms including Cygwin doesn't use libname.dll, rather name.dll when loading dlls\ncase $host in\n*-*-cygwin* | *-*-mingw*) CSHARPLIBRARYPREFIX=\"\";;\n*)CSHARPLIBRARYPREFIX=\"lib\";;\nesac\n\n# C#/Mono on Mac OS X tweaks\ncase $host in\n*-*-darwin*)\n    CSHARPSO=\".so\"\n    ;;\n*)\n    CSHARPSO=$SO\n    ;;\nesac\nfi\n\nAC_SUBST(CSHARPCILINTERPRETER_FLAGS)\nAC_SUBST(CSHARPCILINTERPRETER)\nAC_SUBST(CSHARPCONVERTPATH)\nAC_SUBST(CSHARPCOMPILER)\nAC_SUBST(CSHARPDYNAMICLINKING)\nAC_SUBST(CSHARPLIBRARYPREFIX)\nAC_SUBST(CSHARPCFLAGS)\nAC_SUBST(CSHARPSO)\n\n#----------------------------------------------------------------\n# Look for Lua\n#----------------------------------------------------------------\n\nLUABIN=\nLUAINCLUDE=\nLUALIB=\nLUADYNAMICLOADLIB=\nLUAFLAGS=\nLUALINK=\n# note: if LUABIN is empty then lua tests will not be done\n# LUABIN will be cleared if certain dependencies cannot be found\n\nAC_ARG_WITH(lua, AS_HELP_STRING([--without-lua], [Disable Lua])\nAS_HELP_STRING([--with-lua=path], [Set location of Lua executable]),[ LUABIN=\"$withval\"], [LUABIN=\"$alllang_default\"])\nAC_ARG_WITH(luaincl,[  --with-luaincl=path     Set location of Lua include directory],[\n\tLUAINCLUDE=\"$withval\"], [LUAINCLUDE=])\nAC_ARG_WITH(lualib,[  --with-lualib=path      Set location of Lua library directory],[\n\tLUALIB=\"$withval\"], [LUALIB=])\n\n# First, check for \"--without-lua\" or \"--with-lua=no\".\nif test x\"${LUABIN}\" = xno; then\nAC_MSG_NOTICE([Disabling Lua])\nelse\n\n# can we find lua?\nif test \"x$LUABIN\" = xyes; then\n   # We look for a versioned Lua binary first, as there can be\n   # multiple versions of Lua installed on some systems (like Debian).\n   AC_PATH_PROGS(LUABIN, [lua5.4 lua5.3 lua5.2 lua5.1 lua])\nfi\n\n# check version: we need Lua 5.x\nif test \"$LUABIN\"; then\n  AC_MSG_CHECKING(Lua version)\n  [LUA_VERSION=`$LUABIN -e 'print(string.match(_VERSION, \"%d+[.]%d+\"))'`]\n  # For 5.0 and 5.1 header and libraries may be named using 50 or 51.\n  LUA_VERSION_NO_DOTS=\n  if test -n \"$LUA_VERSION\" ; then\n    AC_MSG_RESULT([Lua $LUA_VERSION.x])\n  else\n    AC_MSG_RESULT([failed])\n  fi\n  case $LUA_VERSION in\n    5.0) LUA_VERSION_NO_DOTS=50 ;;\n    5.1) LUA_VERSION_NO_DOTS=51 ;;\n    5.*) ;;\n    *)\n      AC_MSG_WARN([Not Lua 5.x, SWIG does not support this version of Lua])\n      LUABIN=\"\"\n      ;;\n  esac\nfi\n\nif test \"$LUABIN\"; then\n  AC_MSG_CHECKING(whether Lua dynamic loading is enabled)\n  # using Lua to check Lua\n  # lua 5.0 & 5.1 have different fn names\n  if test \"$LUA_VERSION\" = \"5.0\"; then\n    LUADYNAMICLOADLIB=`$LUABIN -e '_,_,c=loadlib(\"no_such_lib\",\"\") if c~=\"absent\" then print \"1\" end'`\n  else\n    LUADYNAMICLOADLIB=`$LUABIN -e '_,_,c=package.loadlib(\"no_such_lib\",\"\") if c~=\"absent\" then print \"1\" end'`\n  fi\n\n  if test -z \"$LUADYNAMICLOADLIB\"; then\n    AC_MSG_RESULT(no)\n  else\n    AC_MSG_RESULT(yes)\n  fi\n\n  # look for the header files & set LUAFLAGS accordingly\n  # will clear LUABIN if not present\n  if test -n \"$LUAINCLUDE\"; then\n    AC_CHECK_FILE($LUAINCLUDE/lua.h,[LUAFLAGS=\"-I$LUAINCLUDE\"],[LUABIN=])\n  else\n    LUA_OK=\"1\"\n    CFLAGS_SAVED=$CFLAGS\n    CFLAGS= # Use empty CFLAGS to avoid failure: \"present but cannot be compiled\"\n    AC_CHECK_HEADER([lua.h],[LUAFLAGS=\"\"],[LUA_OK=\"\"])\n    CFLAGS=$CFLAGS_SAVED\n    # if we didn't get it, going to have to look elsewhere (the hard way)\n    if test -z \"$LUA_OK\"; then\n      AC_MSG_CHECKING(for lua.h in other locations)\n      # note: Debian/Ubuntu seem to like /usr/include/lua5.1/lua.h\n      # The ordering of the include directories to search should match\n      # the ordering of libraries to search in the library test below.\n      inc=/usr/include\n      incloc=/usr/local/include\n      dirs=\"$inc/lua$LUA_VERSION\"\n      test -z \"$LUA_VERSION_NO_DOTS\" || dirs=\"$dirs $inc/lua$LUA_VERSION_NO_DOTS\"\n      dirs=\"$dirs $incloc/lua$LUA_VERSION\"\n      test -z \"$LUA_VERSION_NO_DOTS\" || dirs=\"$dirs $incloc/lua$LUA_VERSION_NO_DOTS\"\n      dirs=\"$dirs $incloc\"\n      for i in $dirs; do\n        #echo \"$i\"\n        if test -r $i/lua.h; then\n          AC_MSG_RESULT($i/lua.h)\n          LUAFLAGS=\"-I$i\"\n          break\n        fi\n      done\n      if test -z \"$LUAFLAGS\"; then\n        AC_MSG_RESULT(not found)\n        LUABIN=\"\" # clear the bin\n      fi\n    fi\n  fi\n\n  # look for the library files & set LUALINK accordingly\n  # will clear LUABIN if not present\n  lua_save_LIBS=$LIBS # the code seems to disrupt LIBS, so saving\n\n  if test -n \"$LUALIB\"; then\n    AC_CHECK_FILE($LUALIB/liblua.a,[LUALINK=\"-L$LUALIB -llua\"],[LUABIN=])\n  else\n    libs=\"lua lua$LUA_VERSION\"\n    test -z \"$LUA_VERSION_NO_DOTS\" || libs=\"$libs lua$LUA_VERSION_NO_DOTS\"\n    AC_SEARCH_LIBS(lua_close, [$libs], [LUALINK=\"-l$ac_lib\"],[LUABIN=])\n  fi\n\n  # adding lualib for lua 5.0\n  if test \"$LUA_VERSION\" = \"5.0\"; then\n    LUALINK=\"$LUALINK -llualib\"\n  fi\n\n  LIBS=$lua_save_LIBS\t# restore LIBS\nfi\n\nfi # if not disabled\n\nAC_SUBST(LUADYNAMICLINKING)\nAC_SUBST(LUAFLAGS)\nAC_SUBST(LUALINK)\nAC_SUBST(LUABIN)\n\n#----------------------------------------------------------------\n# Look for GNU R\n#----------------------------------------------------------------\n\nRBIN=\n\nAC_ARG_WITH(r, AS_HELP_STRING([--without-r], [Disable R])\nAS_HELP_STRING([--with-r=path], [Set location of R executable (r)]),[ RBIN=\"$withval\"], [RBIN=\"$alllang_default\"])\n\n# First, check for \"--without-r\" or \"--with-r=no\".\nif test x\"${RBIN}\" = xno; then\nAC_MSG_NOTICE([Disabling R])\nRBIN=\nelse\n\n# can we find R?\nif test \"x$RBIN\" = xyes; then\n   AC_PATH_PROG(RBIN, R)\nfi\nfi\n\nAC_SUBST(RBIN)\n\n#----------------------------------------------------------------\n# Look for Go compilers\n#----------------------------------------------------------------\n\nAC_ARG_WITH(go, AS_HELP_STRING([--without-go], [Disable Go])\nAS_HELP_STRING([--with-go=path], [Set location of Go compiler]),[GOBIN=\"$withval\"], [GOBIN=\"$alllang_default\"])\n\nif test x\"${GOBIN}\" = xno; then\n  AC_MSG_NOTICE([Disabling Go])\n  GO=\n  GOGCC=false\n  GCCGO=\n  GOOPT=\n  GCCGOOPT=\n  GOVERSIONOPTION=\nelse\n\n  if test \"x$GOBIN\" = xyes; then\n    AC_CHECK_PROGS(GO, go)\n  else\n    GO=\"$GOBIN\"\n  fi\n\n  GOGCC=false\n  GCCGO=\n  GOOPT=\n  GCCGOOPT=\n  GOVERSIONOPTION=\n\n  if test -n \"$GO\" ; then\n    GOVERSIONOPTION=version\n    go_version=$($GO $GOVERSIONOPTION | sed -e 's/go version //')\n    AC_MSG_CHECKING([whether go version is too old])\n    case $go_version in\n    go1.[012]*)\n      AC_MSG_RESULT([yes - minimum version is 1.3])\n      GO=\n      GOOPT=\"-intgosize 32\"\n      ;;\n    *)\n      AC_MSG_RESULT([no])\n      case \"$(go env GOARCH)\" in\n      amd64 | arm64 | ppc64*)\n        GOOPT=\"-intgosize 64\"\n\t;;\n      *)\n        GOOPT=\"-intgosize 32\"\n\t;;\n      esac\n      ;;\n    esac\n  fi\n\n  AC_CHECK_PROGS(GCCGO, gccgo)\n\n  if test -n \"$GCCGO\" ; then\n    if $GCCGO --help 2>/dev/null | grep gccgo >/dev/null 2>&1 ; then\n      AC_MSG_CHECKING([whether gccgo version is too old])\n      go_version=[`$GO $GOVERSIONOPTION | sed -n '1p' | sed -e 's/^.* \\([0-9.]*\\) *$/\\1/' -e 's/[.]//g'`]\n      if test \"x$go_version\" = x; then\n        AC_MSG_RESULT([could not determine gccgo version])\n        GCCGO=\n      elif test \"$go_version\" -lt 470; then\n        AC_MSG_RESULT([yes - minimum version is 4.7.0])\n        GCCGO=\n      else\n        AC_MSG_RESULT([no])\n        if test \"$go_version\" -lt 480; then\n          GCCGOOPT=\"-intgosize 32\"\n        else\n          AC_CHECK_SIZEOF([void *], [4])\n          if test \"$ac_cv_sizeof_void_p\" = \"8\"; then\n            GCCGOOPT=\"-intgosize 64\"\n          else\n            GCCGOOPT=\"-intgosize 32\"\n          fi\n        fi\n      fi\n    fi\n  fi\nfi\n\nAC_SUBST(GOGCC)\nAC_SUBST(GCCGO)\nAC_SUBST(GO)\nAC_SUBST(GOC)\nAC_SUBST(GO1)\nAC_SUBST(GO12)\nAC_SUBST(GO13)\nAC_SUBST(GO15)\nAC_SUBST(GOOPT)\nAC_SUBST(GCCGOOPT)\nAC_SUBST(GOVERSIONOPTION)\n\n#----------------------------------------------------------------\n# Look for D\n#----------------------------------------------------------------\n\nAC_ARG_WITH(d, AS_HELP_STRING([--without-d], [Disable D]), [with_d=\"$withval\"], [with_d=\"$alllang_default\"])\nAC_ARG_WITH(d1-compiler, [  --with-d1-compiler=path  Set location of D1/Tango compiler (DMD compatible)],[D1COMPILERBIN=\"$withval\"], [D1COMPILERBIN=])\nAC_ARG_WITH(d2-compiler, [  --with-d2-compiler=path  Set location of D2 compiler (DMD compatible)],[D2COMPILERBIN=\"$withval\"], [D2COMPILERBIN=])\n\n\n# First, check for \"--without-d\" or \"--with-d=no\".\nif test x\"${with_d}\" = xno; then\n  AC_MSG_NOTICE([Disabling D])\n  D1COMPILER=\n  D2COMPILER=\nelse\n  old_ac_ext=$ac_ext\n  ac_ext=d\n\n  if test -z \"$D1COMPILERBIN\" ; then\n    AC_CHECK_PROGS(D1COMPILER, dmd ldmd gdmd)\n\n    if test -n \"$D1COMPILER\" ; then\n      AC_MSG_CHECKING(whether the D1/Tango compiler works)\n      cat > conftest.$ac_ext <<_ACEOF\nimport tango.io.Stdout;\nvoid main() {\n}\n_ACEOF\n      rm -f conftest.$ac_objext\n      AS_IF(\n        [$D1COMPILER conftest.$ac_ext 2>&AS_MESSAGE_LOG_FD && test ! -s conftest.err && test -s conftest.$ac_objext],\n        [AC_MSG_RESULT([yes])],\n        [_AC_MSG_LOG_CONFTEST AC_MSG_RESULT([no])\n        D1COMPILER=]\n      )\n      rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n    fi\n  else\n    D1COMPILER=\"$D1COMPILERBIN\"\n  fi\n\n  if test -z \"$D2COMPILERBIN\" ; then\n    AC_CHECK_PROGS(D2COMPILER, dmd gdmd)\n\n    if test -n \"$D2COMPILER\" ; then\n      AC_MSG_CHECKING(whether the D2 compiler works)\n      cat > conftest.$ac_ext <<_ACEOF\nimport std.algorithm;\nvoid main() {\n}\n_ACEOF\n      rm -f conftest.$ac_objext\n      AS_IF(\n        [$D2COMPILER conftest.$ac_ext 2>&AS_MESSAGE_LOG_FD && test ! -s conftest.err && test -s conftest.$ac_objext],\n        [AC_MSG_RESULT([yes])],\n        [_AC_MSG_LOG_CONFTEST AC_MSG_RESULT([no])\n        D2COMPILER=]\n      )\n      rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n    fi\n  else\n    D2COMPILER=\"$D2COMPILERBIN\"\n  fi\n\n  ac_ext=$old_ac_ext\nfi\n\nif test -n \"$D1COMPILER\"; then\n  DDEFAULTVERSION=1\nelif test -n \"$D2COMPILER\"; then\n  DDEFAULTVERSION=2\nfi\n\n# Do not prefix library file names with \"lib\" on Windows.\ncase $host in\n*-*-cygwin* | *-*-mingw*) DLIBPREFIX=\"\";;\n*)DLIBPREFIX=\"lib\";;\nesac\n\nAC_SUBST(D1COMPILER)\nAC_SUBST(D2COMPILER)\nAC_SUBST(DDEFAULTVERSION)\nAC_SUBST(DLIBPREFIX)\n\n#---------------------------------------------------------------\n# Look for Fortran\n#---------------------------------------------------------------\n\nAC_ARG_WITH(fortran,\nAS_HELP_STRING([--without-fortran], [Disable Fortran])\nAS_HELP_STRING([--with-fortran=path], [Set location of Fortran compiler]),\n[FORTRAN=\"$withval\"], [FORTRAN=\"$alllang_default\"])\n\nif test x\"${FORTRAN}\" = xno; then\n  AC_MSG_NOTICE([Disabling Fortran])\n  FC=\nelse\n  if test -n \"$FCFLAGS\" && test \"x$GCC\" = xyes; then\n    FCFLAGS=\"-std=f2003 -Wall -Wimplicit-procedure -Wimplicit-interface\"\n  fi\n\n  if test \"x$FORTRAN\" = xyes; then\n    AC_PROG_FC dnl This command also sets FCFLAGS\n  else\n    FC=$FORTRAN\n    FCFLAGS=$FCFLAGS\n  fi\n\n  if test -n \"$FC\"; then\n    AC_FC_LIBRARY_LDFLAGS dnl Set up Fortran library flags\n  fi\n\n  # FORTRANLDSHARED is the ld *command* used to create shared library\n  # This must make a dynamic library as opposerd to a bundle.\n  case $host in\n    *-*-darwin*)\n        FORTRANLDSHARED='$(CC) -dynamiclib'\n        FORTRANCXXSHARED='$(CXX) -dynamiclib'\n        ;;\n      *)\n        FORTRANLDSHARED='$(LDSHARED)'\n        FORTRANCXXSHARED='$(CXXSHARED)'\n        ;;\n  esac\nfi\n\nAC_SUBST(FC)\nAC_SUBST(FCFLAGS)\nAC_SUBST(FCLIBS)\nAC_SUBST(FORTRANLDSHARED)\nAC_SUBST(FORTRANCXXSHARED)\n\n\n#----------------------------------------------------------------\n# Determine which languages to use for examples/test-suite\n#----------------------------------------------------------------\n\nSKIP_TCL=\nif test -z \"$TCLINCLUDE\" || test -z \"$TCLLIB\" ; then\n    SKIP_TCL=\"1\"\nfi\nAC_SUBST(SKIP_TCL)\n\n\nSKIP_PERL5=\nif test -z \"$PERL\" || test -z \"$PERL5EXT\" || test -z \"$PERL5TESTMORE\"; then\n    SKIP_PERL5=\"1\"\nfi\nAC_SUBST(SKIP_PERL5)\n\n\nSKIP_OCTAVE=\nif test -z \"$OCTAVE\" ; then\n    SKIP_OCTAVE=\"1\"\nfi\nAC_SUBST(SKIP_OCTAVE)\n\n\nSKIP_PYTHON=\nif (test -z \"$PYINCLUDE\" || test -z \"$PYLINK\") &&\n   (test -z \"$PY3INCLUDE\" || test -z \"$PY3LINK\") ; then\n    SKIP_PYTHON=\"1\"\nfi\nAC_SUBST(SKIP_PYTHON)\n\nSKIP_PYTHON3=\nif test -z \"$PY3INCLUDE\" || test -z \"$PY3LINK\" ; then\n    SKIP_PYTHON3=\"1\"\nfi\nAC_SUBST(SKIP_PYTHON3)\n\nSKIP_JAVA=\nif test -z \"$JAVA\" || test -z \"$JAVAC\" || test -z \"$JAVAINC\" ; then\n    SKIP_JAVA=\"1\"\nfi\nAC_SUBST(SKIP_JAVA)\n\nSKIP_JAVASCRIPT=\nif test -z \"$JAVASCRIPT\" || ( test -z \"$NODEJS\" && test -z \"$JSCENABLED\" && test -z \"$JSV8ENABLED\" ) ; then\n    SKIP_JAVASCRIPT=\"1\"\nfi\nAC_SUBST(SKIP_JAVASCRIPT)\n\nSKIP_GUILE=\nif test -z \"$GUILE\" || test -z \"$GUILE_LIBS\" ; then\n    SKIP_GUILE=\"1\"\nfi\nAC_SUBST(SKIP_GUILE)\n\n\nSKIP_MZSCHEME=\nif test -z \"$MZC\" || test -z \"$MZDYNOBJ\" ; then\n    SKIP_MZSCHEME=\"1\"\nfi\nAC_SUBST(SKIP_MZSCHEME)\n\n\nSKIP_RUBY=\nif test -z \"$RUBY\" || test -z \"$RUBYINCLUDE\" || test -z \"$RUBYLIB\" ; then\n    SKIP_RUBY=\"1\"\nfi\nAC_SUBST(SKIP_RUBY)\n\n\nSKIP_PHP=\nif test -z \"$PHP\" || test -z \"$PHPINC\" ; then\n    SKIP_PHP=\"1\"\nfi\nAC_SUBST(SKIP_PHP)\n\n\nSKIP_OCAML=\nif test -z \"$OCAMLC\" || test -z \"$CAMLP4\" ; then\n    SKIP_OCAML=\"1\"\nfi\nAC_SUBST(SKIP_OCAML)\n\n\nSKIP_CSHARP=\nif test -z \"$CSHARPCOMPILER\" ; then\n    SKIP_CSHARP=\"1\"\nelse\n    if test \"cscc\" = \"$CSHARPCOMPILER\" && test -z \"$CSHARPCILINTERPRETER\" ; then\n      SKIP_CSHARP=\"1\"\n    fi\nfi\nAC_SUBST(SKIP_CSHARP)\n\nSKIP_LUA=\n# we need LUABIN & dynamic loading\nif test -z \"$LUABIN\" || test -z \"$LUADYNAMICLOADLIB\"; then\n    SKIP_LUA=\"1\"\nfi\nAC_SUBST(SKIP_LUA)\n\nSKIP_R=\nif test -z \"$RBIN\" ; then\n    SKIP_R=\"1\"\nfi\nAC_SUBST(SKIP_R)\n\nSKIP_SCILAB=\nif test -z \"$SCILAB\"; then\n    SKIP_SCILAB=\"1\"\nfi\nAC_SUBST(SKIP_SCILAB)\n\nSKIP_GO=\nif test -z \"$GO\" ; then\n    SKIP_GO=\"1\"\nfi\nAC_SUBST(SKIP_GO)\n\nSKIP_D=\nif test -z \"$DDEFAULTVERSION\" ; then\n    SKIP_D=\"1\"\nfi\nAC_SUBST(SKIP_D)\n\nSKIP_FORTRAN=\nif test -z \"$FC\" ; then\n    SKIP_FORTRAN=\"1\"\nfi\nAC_SUBST(SKIP_FORTRAN)\n\n#----------------------------------------------------------------\n# Additional language dependencies\n#----------------------------------------------------------------\n\nSKIP_ANDROID=\nif test -z \"$ANDROID\" || test -z \"$ADB\" || test -z \"$ANT\" || test -z \"$NDKBUILD\" ; then\n    SKIP_ANDROID=\"1\"\nfi\nAC_SUBST(SKIP_ANDROID)\n\n\n\n#----------------------------------------------------------------\n# Miscellaneous\n#----------------------------------------------------------------\n\nABS_SRCDIR=`(cd ${srcdir} && pwd)`\n\ndnl Under Cygwin, we may need native absolute path as it is used by SWIG, which\ndnl may be a native, and not a Cygwin, program (this is the case when it's\ndnl built using MinGW or cccl compiler in Cygwin environment). However it may,\ndnl although this is probably more rare, also be built as a Cygwin program.\ndnl Using \"mixed\" path like we do here allows the path to work in both cases.\ncase $host in\n  *-*-mingw* ) ABS_SRCDIR=`${srcdir}/Tools/convertpath -m $ABS_SRCDIR` ;;\n  *-*-cygwin* ) ABS_SRCDIR=`cygpath --mixed $ABS_SRCDIR` ;;\nesac\n\n# Root directory\nROOT_DIR=`pwd`\ncase $host in\n*-*-cygwin*)\n  # Translate path for native Windows compilers for use with 'make check'\n  if (cygpath --mixed $ROOT_DIR) >/dev/null 2>/dev/null; then\n    ROOT_DIR=`cygpath --mixed $ROOT_DIR`\n  fi\n  ;;\nesac\n\ncase $host in\n*-*-cygwin* | *-*-mingw*)\n  # Extra files generated by some Windows compilers\n  EXTRA_CLEAN=\"*.stackdump *.exp *.lib *.pdb *.ilk\"\n  ;;\nesac\n\nAC_SUBST(ROOT_DIR)\nAC_SUBST(EXTRA_CLEAN)\nAC_SUBST(ac_aux_dir)\n\n# Configure SWIG_LIB path\n\nAC_ARG_WITH(swiglibdir,[  --with-swiglibdir=DIR   Put SWIG system-independent libraries into DIR.],\n  [swig_lib=\"$withval\"], [swig_lib=\"${datadir}/swig/${PACKAGE_VERSION}\"])\nSWIG_LIB_INSTALL=${swig_lib}\nAC_SUBST(SWIG_LIB_INSTALL)\nAC_DEFINE_DIR(SWIG_LIB, swig_lib, [Directory for SWIG system-independent libraries])\n\ncase $build in\n  # Windows does not understand unix directories. Convert into a windows directory with drive letter.\n  *-*-mingw*) SWIG_LIB_WIN_UNIX=`${srcdir}/Tools/convertpath -m $SWIG_LIB`;;\n  *-*-cygwin*) SWIG_LIB_WIN_UNIX=`cygpath --mixed \"$SWIG_LIB\"`;;\n  *) SWIG_LIB_WIN_UNIX=\"\";;\nesac\nAC_DEFINE_UNQUOTED(SWIG_LIB_WIN_UNIX, [\"$SWIG_LIB_WIN_UNIX\"], [Directory for SWIG system-independent libraries (Unix install on native Windows)])\n\nSWIG_LIB_PREINST=$ABS_SRCDIR/Lib\nAC_SUBST(SWIG_LIB_PREINST)\n\ndnl For testing purposes, clear SWIG_LIB when building SWIG in the source\ndnl directory under Windows because it is supposed to work without SWIG_LIB\ndnl being set. Otherwise it always needs to be set.\nSWIG_LIB_SET=\"env SWIG_LIB=\\$(SWIG_LIB_DIR)\"\nif test \"${srcdir}\" = \".\"; then\n    AC_EGREP_CPP([yes],\n    [#ifdef _WIN32\n     yes\n    #endif\n    ], [SWIG_LIB_SET=\"env SWIG_LIB=\"], [])\nfi\nAC_SUBST(SWIG_LIB_SET)\n\nAC_CONFIG_FILES([\n    Makefile\n    swig.spec\n    Examples/Makefile\n    Examples/d/example.mk\n    Examples/xml/Makefile\n    Examples/test-suite/errors/Makefile\n    Examples/test-suite/csharp/Makefile\n    Examples/test-suite/d/Makefile\n    Examples/test-suite/guile/Makefile\n    Examples/test-suite/java/Makefile\n    Examples/test-suite/javascript/Makefile\n    Examples/test-suite/mzscheme/Makefile\n    Examples/test-suite/ocaml/Makefile\n    Examples/test-suite/octave/Makefile\n    Examples/test-suite/perl5/Makefile\n    Examples/test-suite/php/Makefile\n    Examples/test-suite/python/Makefile\n    Examples/test-suite/ruby/Makefile\n    Examples/test-suite/scilab/Makefile\n    Examples/test-suite/tcl/Makefile\n    Examples/test-suite/lua/Makefile\n    Examples/test-suite/r/Makefile\n    Examples/test-suite/go/Makefile\n    Examples/test-suite/fortran/Makefile\n    Source/Makefile\n    Tools/javascript/Makefile\n])\nAC_CONFIG_FILES([preinst-swig], [chmod +x preinst-swig])\nAC_CONFIG_FILES([CCache/ccache_swig_config.h])\n\n#--------------------------------------------------------------------\n# Building Examples/ out of source directory\n#--------------------------------------------------------------------\n\n# If building out of source tree, replicate Examples/ source tree in\n# build directory, and copy over Makefiles from source directory.\n# Prefix each Makefile with a header which sets SRCDIR to the relative\n# source directory, and provides a rule for updating the Makefile from\n# its original source.\nAC_CONFIG_COMMANDS([Examples],[\n  if test \"x${srcdir}\" != \"x.\" ; then\n    AC_MSG_NOTICE([generating Examples build tree])\n    for mkfile in `cd ${srcdir} && find Examples/ -type f -name Makefile`; do\n      dir=`dirname ${mkfile}`\n      d=${dir}\n      reldir=\"\"\n      while test \"x$d\" != \"x.\" ; do\n        d=`dirname $d`\n        reldir=\"${reldir}../\"\n      done\n      relsrcdir=${reldir}${srcdir}/\n      AS_MKDIR_P([${dir}])\n      cat <<EOF >${mkfile}\n# DO NOT EDIT: instead edit ${relsrcdir}${mkfile}\n# and run (cd ${reldir} && ./config.status) to regenerate\nTOP_BUILDDIR_TO_TOP_SRCDIR = ${srcdir}/\nSRCDIR = ${relsrcdir}${dir}/\n\nEOF\n      cat ${srcdir}/${mkfile} >>${mkfile}\n    done\n  fi\n])\n\n#--------------------------------------------------------------------\n\nAC_OUTPUT\n\nlangs=\"\"\ntest -n \"$SKIP_CSHARP\"\t\t|| langs=\"${langs}csharp \"\ntest -n \"$SKIP_D\"\t\t|| langs=\"${langs}d \"\ntest -n \"$SKIP_FORTRAN\"\t\t|| langs=\"${langs}fortran \"\ntest -n \"$SKIP_GO\"\t\t|| langs=\"${langs}go \"\ntest -n \"$SKIP_GUILE\"\t\t|| langs=\"${langs}guile \"\ntest -n \"$SKIP_JAVA\"\t\t|| langs=\"${langs}java \"\ntest -n \"$SKIP_JAVASCRIPT\"\t|| langs=\"${langs}javascript \"\ntest -n \"$SKIP_LUA\"\t\t|| langs=\"${langs}lua \"\ntest -n \"$SKIP_MZSCHEME\"\t|| langs=\"${langs}mzscheme \"\ntest -n \"$SKIP_OCAML\"\t\t|| langs=\"${langs}ocaml \"\ntest -n \"$SKIP_OCTAVE\"\t\t|| langs=\"${langs}octave \"\ntest -n \"$SKIP_PERL5\"\t\t|| langs=\"${langs}perl5 \"\ntest -n \"$SKIP_PHP\"\t\t|| langs=\"${langs}php \"\ntest -n \"$SKIP_PYTHON\"\t\t|| langs=\"${langs}python \"\ntest -n \"$SKIP_R\"\t\t|| langs=\"${langs}r \"\ntest -n \"$SKIP_RUBY\"\t\t|| langs=\"${langs}ruby \"\ntest -n \"$SKIP_SCILAB\"\t\t|| langs=\"${langs}scilab \"\ntest -n \"$SKIP_TCL\"\t\t|| langs=\"${langs}tcl \"\n\necho \"\nThe SWIG test-suite and examples are configured for the following languages:\n$langs\n\"\n\ndnl configure.ac ends here\n",
        "/tmp/vanessa/spack-stage/spack-stage-swig-4.0.2-fortran-g56ercorgz6iqsj2oxpaerfkjervkynd/spack-src/Lib/d/wrapperloader.swg": "/* -----------------------------------------------------------------------------\n * wrapperloader.swg\n *\n * Support code for dynamically linking the C wrapper library from the D\n * wrapper module.\n *\n * The loading code was adapted from the Derelict project and is used with\n * permission from Michael Parker, the original author.\n * ----------------------------------------------------------------------------- */\n\n%pragma(d) wrapperloadercode = %{\nprivate {\n  version(linux) {\n    version = Nix;\n  } else version(darwin) {\n    version = Nix;\n  } else version(OSX) {\n    version = Nix;\n  } else version(FreeBSD) {\n    version = Nix;\n    version = freebsd;\n  } else version(freebsd) {\n    version = Nix;\n  } else version(Unix) {\n    version = Nix;\n  } else version(Posix) {\n    version = Nix;\n  }\n\n  version(Tango) {\n    static import tango.stdc.string;\n    static import tango.stdc.stringz;\n\n    version (PhobosCompatibility) {\n    } else {\n      alias char[] string;\n      alias wchar[] wstring;\n      alias dchar[] dstring;\n    }\n  } else {\n    version(D_Version2) {\n      static import std.conv;\n    } else {\n      static import std.c.string;\n    }\n    static import std.string;\n  }\n\n  version(D_Version2) {\n    mixin(\"alias const(char)* CCPTR;\");\n  } else {\n    alias char* CCPTR;\n  }\n\n  CCPTR swigToCString(string str) {\n    version(Tango) {\n      return tango.stdc.stringz.toStringz(str);\n    } else {\n      return std.string.toStringz(str);\n    }\n  }\n\n  string swigToDString(CCPTR cstr) {\n    version(Tango) {\n      return tango.stdc.stringz.fromStringz(cstr);\n    } else {\n      version(D_Version2) {\n        mixin(\"return std.conv.to!string(cstr);\");\n      } else {\n        return std.c.string.toString(cstr);\n      }\n    }\n  }\n}\n\nclass SwigSwigSharedLibLoadException : Exception {\n  this(in string[] libNames, in string[] reasons) {\n    string msg = \"Failed to load one or more shared libraries:\";\n    foreach(i, n; libNames) {\n      msg ~= \"\\n\\t\" ~ n ~ \" - \";\n      if(i < reasons.length)\n        msg ~= reasons[i];\n      else\n        msg ~= \"Unknown\";\n    }\n    super(msg);\n  }\n}\n\nclass SwigSymbolLoadException : Exception {\n  this(string SwigSharedLibName, string symbolName) {\n    super(\"Failed to load symbol \" ~ symbolName ~ \" from shared library \" ~ SwigSharedLibName);\n    _symbolName = symbolName;\n  }\n\n  string symbolName() {\n    return _symbolName;\n  }\n\nprivate:\n  string _symbolName;\n}\n\nprivate {\n  version(Nix) {\n    version(freebsd) {\n      // the dl* functions are in libc on FreeBSD\n    }\n    else {\n      pragma(lib, \"dl\");\n    }\n\n    version(Tango) {\n      import tango.sys.Common;\n    } else version(linux) {\n      import core.sys.posix.dlfcn;\n    } else {\n      extern(C) {\n        const RTLD_NOW = 2;\n\n        void *dlopen(CCPTR file, int mode);\n        int dlclose(void* handle);\n        void *dlsym(void* handle, CCPTR name);\n        CCPTR dlerror();\n      }\n    }\n\n    alias void* SwigSharedLibHandle;\n\n    SwigSharedLibHandle swigLoadSharedLib(string libName) {\n      return dlopen(swigToCString(libName), RTLD_NOW);\n    }\n\n    void swigUnloadSharedLib(SwigSharedLibHandle hlib) {\n      dlclose(hlib);\n    }\n\n    void* swigGetSymbol(SwigSharedLibHandle hlib, string symbolName) {\n      return dlsym(hlib, swigToCString(symbolName));\n    }\n\n    string swigGetErrorStr() {\n      CCPTR err = dlerror();\n      if (err is null) {\n        return \"Unknown Error\";\n      }\n      return swigToDString(err);\n    }\n  } else version(Windows) {\n    alias ushort WORD;\n    alias uint DWORD;\n    alias CCPTR LPCSTR;\n    alias void* HMODULE;\n    alias void* HLOCAL;\n    alias int function() FARPROC;\n    struct VA_LIST {}\n\n    extern (Windows) {\n      HMODULE LoadLibraryA(LPCSTR);\n      FARPROC GetProcAddress(HMODULE, LPCSTR);\n      void FreeLibrary(HMODULE);\n      DWORD GetLastError();\n      DWORD FormatMessageA(DWORD, in void*, DWORD, DWORD, LPCSTR, DWORD, VA_LIST*);\n      HLOCAL LocalFree(HLOCAL);\n    }\n\n    DWORD MAKELANGID(WORD p, WORD s) {\n      return (((cast(WORD)s) << 10) | cast(WORD)p);\n    }\n\n    enum {\n      LANG_NEUTRAL                    = 0,\n      SUBLANG_DEFAULT                 = 1,\n      FORMAT_MESSAGE_ALLOCATE_BUFFER  = 256,\n      FORMAT_MESSAGE_IGNORE_INSERTS   = 512,\n      FORMAT_MESSAGE_FROM_SYSTEM      = 4096\n    }\n\n    alias HMODULE SwigSharedLibHandle;\n\n    SwigSharedLibHandle swigLoadSharedLib(string libName) {\n      return LoadLibraryA(swigToCString(libName));\n    }\n\n    void swigUnloadSharedLib(SwigSharedLibHandle hlib) {\n      FreeLibrary(hlib);\n    }\n\n    void* swigGetSymbol(SwigSharedLibHandle hlib, string symbolName) {\n      return GetProcAddress(hlib, swigToCString(symbolName));\n    }\n\n    string swigGetErrorStr() {\n      DWORD errcode = GetLastError();\n\n      LPCSTR msgBuf;\n      DWORD i = FormatMessageA(\n        FORMAT_MESSAGE_ALLOCATE_BUFFER |\n        FORMAT_MESSAGE_FROM_SYSTEM |\n        FORMAT_MESSAGE_IGNORE_INSERTS,\n        null,\n        errcode,\n        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n        cast(LPCSTR)&msgBuf,\n        0,\n        null);\n\n      string text = swigToDString(msgBuf);\n      LocalFree(cast(HLOCAL)msgBuf);\n\n      if (i >= 2) {\n        i -= 2;\n      }\n      return text[0 .. i];\n    }\n  } else {\n    static assert(0, \"Operating system not supported by the wrapper loading code.\");\n  }\n\n  final class SwigSharedLib {\n    void load(string[] names) {\n      if (_hlib !is null) return;\n\n      string[] failedLibs;\n      string[] reasons;\n\n      foreach(n; names) {\n        _hlib = swigLoadSharedLib(n);\n        if (_hlib is null) {\n          failedLibs ~= n;\n          reasons ~= swigGetErrorStr();\n          continue;\n        }\n        _name = n;\n        break;\n      }\n\n      if (_hlib is null) {\n        throw new SwigSwigSharedLibLoadException(failedLibs, reasons);\n      }\n    }\n\n    void* loadSymbol(string symbolName, bool doThrow = true) {\n      void* sym = swigGetSymbol(_hlib, symbolName);\n      if(doThrow && (sym is null)) {\n        throw new SwigSymbolLoadException(_name, symbolName);\n      }\n      return sym;\n    }\n\n    void unload() {\n      if(_hlib !is null) {\n        swigUnloadSharedLib(_hlib);\n        _hlib = null;\n      }\n    }\n\n  private:\n    string _name;\n    SwigSharedLibHandle _hlib;\n  }\n}\n\nstatic this() {\n  string[] possibleFileNames;\n  version (Posix) {\n    version (OSX) {\n      possibleFileNames ~= [\"lib$wraplibrary.dylib\", \"lib$wraplibrary.bundle\"];\n    }\n    possibleFileNames ~= [\"lib$wraplibrary.so\"];\n  } else version (Windows) {\n    possibleFileNames ~= [\"$wraplibrary.dll\", \"lib$wraplibrary.so\"];\n  } else {\n    static assert(false, \"Operating system not supported by the wrapper loading code.\");\n  }\n\n  auto library = new SwigSharedLib;\n  library.load(possibleFileNames);\n\n  string bindCode(string functionPointer, string symbol) {\n    return functionPointer ~ \" = cast(typeof(\" ~ functionPointer ~\n      \"))library.loadSymbol(`\" ~ symbol ~ \"`);\";\n  }\n\n  //#if !defined(SWIG_D_NO_EXCEPTION_HELPER)\n  mixin(bindCode(\"swigRegisterExceptionCallbacks$module\", \"SWIGRegisterExceptionCallbacks_$module\"));\n  //#endif // SWIG_D_NO_EXCEPTION_HELPER\n  //#if !defined(SWIG_D_NO_STRING_HELPER)\n  mixin(bindCode(\"swigRegisterStringCallback$module\", \"SWIGRegisterStringCallback_$module\"));\n  //#endif // SWIG_D_NO_STRING_HELPER\n  $wrapperloaderbindcode\n}\n\n//#if !defined(SWIG_D_NO_EXCEPTION_HELPER)\nextern(C) void function(\n  SwigExceptionCallback exceptionCallback,\n  SwigExceptionCallback illegalArgumentCallback,\n  SwigExceptionCallback illegalElementCallback,\n  SwigExceptionCallback ioCallback,\n  SwigExceptionCallback noSuchElementCallback) swigRegisterExceptionCallbacks$module;\n//#endif // SWIG_D_NO_EXCEPTION_HELPER\n\n//#if !defined(SWIG_D_NO_STRING_HELPER)\nextern(C) void function(SwigStringCallback callback) swigRegisterStringCallback$module;\n//#endif // SWIG_D_NO_STRING_HELPER\n%}\n\n%pragma(d) wrapperloaderbindcommand = %{\n  mixin(bindCode(\"$function\", \"$symbol\"));%}\n",
        "/tmp/vanessa/spack-stage/spack-stage-swig-4.0.2-fortran-g56ercorgz6iqsj2oxpaerfkjervkynd/spack-src/Lib/mzscheme/mzrun.swg": "/* -----------------------------------------------------------------------------\n * mzrun.swg\n * ----------------------------------------------------------------------------- */\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <escheme.h>\n#include <assert.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* Common SWIG API */\n  \n#define SWIG_ConvertPtr(s, result, type, flags) \\\n  SWIG_MzScheme_ConvertPtr(s, result, type, flags)\n#define SWIG_NewPointerObj(ptr, type, owner) \\\n  SWIG_MzScheme_NewPointerObj((void *)ptr, type, owner)\n#define SWIG_MustGetPtr(s, type, argnum, flags) \\\n  SWIG_MzScheme_MustGetPtr(s, type, argnum, flags, FUNC_NAME, argc, argv)\n\n#define SWIG_contract_assert(expr,msg) \\\n if (!(expr)) { \\\n    char *m=(char *) scheme_malloc(strlen(msg)+1000); \\\n    sprintf(m,\"SWIG contract, assertion failed: function=%s, message=%s\", \\\n            (char *) FUNC_NAME,(char *) msg); \\\n    scheme_signal_error(m); \\\n }\n\n/* Runtime API */\n#define SWIG_GetModule(clientdata) SWIG_MzScheme_GetModule((Scheme_Env *)(clientdata))\n#define SWIG_SetModule(clientdata, pointer) SWIG_MzScheme_SetModule((Scheme_Env *) (clientdata), pointer)\n#define SWIG_MODULE_CLIENTDATA_TYPE Scheme_Env *\n\n/* MzScheme-specific SWIG API */\n  \n#define SWIG_malloc(size) SWIG_MzScheme_Malloc(size, FUNC_NAME)\n#define SWIG_free(mem) free(mem)\n#define SWIG_NewStructFromPtr(ptr,type) \\\n        _swig_convert_struct_##type##(ptr)\n\n#define MAXVALUES 6\n#define swig_make_boolean(b) (b ? scheme_true : scheme_false)\n\nstatic long\nSWIG_convert_integer(Scheme_Object *o,\n\t\t     long lower_bound, long upper_bound, \n\t\t     const char *func_name, int argnum, int argc,\n\t\t     Scheme_Object **argv)\n{\n  long value;\n  int status = scheme_get_int_val(o, &value);\n  if (!status)\n    scheme_wrong_type(func_name, \"integer\", argnum, argc, argv);\n  if (value < lower_bound || value > upper_bound)\n    scheme_wrong_type(func_name, \"integer\", argnum, argc, argv);\n  return value;\n}\n\nstatic int\nSWIG_is_integer(Scheme_Object *o)\n{\n  long value;\n  return scheme_get_int_val(o, &value);\n}\n\nstatic unsigned long\nSWIG_convert_unsigned_integer(Scheme_Object *o,\n\t\t\t      unsigned long lower_bound, unsigned long upper_bound, \n\t\t\t      const char *func_name, int argnum, int argc,\n\t\t\t      Scheme_Object **argv)\n{\n  unsigned long value;\n  int status = scheme_get_unsigned_int_val(o, &value);\n  if (!status)\n    scheme_wrong_type(func_name, \"integer\", argnum, argc, argv);\n  if (value < lower_bound || value > upper_bound)\n    scheme_wrong_type(func_name, \"integer\", argnum, argc, argv);\n  return value;\n}\n\nstatic int\nSWIG_is_unsigned_integer(Scheme_Object *o)\n{\n  unsigned long value;\n  return scheme_get_unsigned_int_val(o, &value);\n}\n  \n/* ----------------------------------------------------------------------- \n * mzscheme 30X support code\n * ----------------------------------------------------------------------- */\n\n#ifndef SCHEME_STR_VAL\n#define MZSCHEME30X 1\n#endif\n\n#ifdef MZSCHEME30X \n/* \n * This is MZSCHEME 299.100 or higher (30x).  From version 299.100 of\n * mzscheme upwards, strings are in unicode. These functions convert\n * to and from utf8 encodings of these strings.  NB! strlen(s) will be\n * the size in bytes of the string, not the actual length.\n */\n#define SCHEME_STR_VAL(obj)  \t       SCHEME_BYTE_STR_VAL(scheme_char_string_to_byte_string(obj))\n#define SCHEME_STRLEN_VAL(obj)         SCHEME_BYTE_STRLEN_VAL(scheme_char_string_to_byte_string(obj))\n#define SCHEME_STRINGP(obj)            SCHEME_CHAR_STRINGP(obj)\n#define scheme_make_string(s)          scheme_make_utf8_string(s)\n#define scheme_make_sized_string(s,l)  scheme_make_sized_utf8_string(s,l)\n#define scheme_make_sized_offset_string(s,d,l) \\\n                   scheme_make_sized_offset_utf8_string(s,d,l)\n#define SCHEME_MAKE_STRING(s) scheme_make_utf8_string(s)\n#else\n#define SCHEME_MAKE_STRING(s) scheme_make_string_without_copying(s)\n#endif\n/* ----------------------------------------------------------------------- \n * End of mzscheme 30X support code \n * ----------------------------------------------------------------------- */\n  \nstruct swig_mz_proxy {\n  Scheme_Type mztype;\n  swig_type_info *type;\n  void *object;\n};\n\nstatic Scheme_Type swig_type;\n\nstatic void \nmz_free_swig(void *p, void *data) {\n  struct swig_mz_proxy *proxy = (struct swig_mz_proxy *) p;\n  if (SCHEME_NULLP((Scheme_Object*)p) || SCHEME_TYPE((Scheme_Object*)p) != swig_type)\n    return;\n  if (proxy->type) {\n    if (proxy->type->clientdata) {\n      ((Scheme_Prim *)proxy->type->clientdata)(1, (Scheme_Object **)&proxy);\n    }\n  }\n}\n\nstatic Scheme_Object *\nSWIG_MzScheme_NewPointerObj(void *ptr, swig_type_info *type, int owner) {\n  struct swig_mz_proxy *new_proxy;\n  new_proxy = (struct swig_mz_proxy *) scheme_malloc(sizeof(struct swig_mz_proxy));\n  new_proxy->mztype = swig_type;\n  new_proxy->type = type;\n  new_proxy->object = ptr;\n  if (owner) {\n    scheme_add_finalizer(new_proxy, mz_free_swig, NULL);\n  }\n  return (Scheme_Object *) new_proxy;\n}\n\nstatic int\nSWIG_MzScheme_ConvertPtr(Scheme_Object *s, void **result, swig_type_info *type, int flags) {\n  swig_cast_info *cast;\n\n  if (SCHEME_NULLP(s)) {\n    *result = NULL;\n    return (flags & SWIG_POINTER_NO_NULL) ? SWIG_NullReferenceError : SWIG_OK;\n  } else if (SCHEME_TYPE(s) == swig_type) {\n    struct swig_mz_proxy *proxy = (struct swig_mz_proxy *) s;\n    if (type) {\n      cast = SWIG_TypeCheckStruct(proxy->type, type);\n      if (cast) {\n        int newmemory = 0;\n        *result = SWIG_TypeCast(cast, proxy->object, &newmemory);\n        assert(!newmemory); /* newmemory handling not yet implemented */\n        return 0;\n      } else {\n        return 1;\n      }\n    } else {\n      *result = proxy->object;\n      return 0;\n    }\n  }\n  return 1;\n}\n\nstatic SWIGINLINE void *\nSWIG_MzScheme_MustGetPtr(Scheme_Object *s, swig_type_info *type, \n                         int argnum, int flags, const char *func_name,\n                         int argc, Scheme_Object **argv) {\n  void *result;\n  if (SWIG_MzScheme_ConvertPtr(s, &result, type, flags)) {\n    scheme_wrong_type(func_name, type->str ? type->str : \"void *\", argnum - 1, argc, argv);\n  }\n  return result;\n}\n\nstatic SWIGINLINE void *\nSWIG_MzScheme_Malloc(size_t size, const char *func_name) {\n  void *p = malloc(size);\n  if (p == NULL) {\n    scheme_signal_error(\"swig-memory-error\");\n  } else return p;\n}\n\nstatic Scheme_Object *\nSWIG_MzScheme_PackageValues(int num, Scheme_Object **values) {\n    /* ignore first value if void */\n    if (num > 0 && SCHEME_VOIDP(values[0]))\n\tnum--, values++;\n    if (num == 0) return scheme_void;\n    else if (num == 1) return values[0];\n    else return scheme_values(num, values);\n}\n\n#ifndef scheme_make_inspector\n#define scheme_make_inspector(x,y) \\\n        _scheme_apply(scheme_builtin_value(\"make-inspector\"), x, y)\n#endif\n\n/* Function to create a new struct. */\nstatic Scheme_Object *\nSWIG_MzScheme_new_scheme_struct (Scheme_Env* env, const char* basename, \n\t\t\t\t int num_fields, char** field_names)\n{\n    Scheme_Object *new_type;\n    int count_out, i;\n    Scheme_Object **struct_names;\n    Scheme_Object **vals;\n    Scheme_Object **a = (Scheme_Object**) \\\n        scheme_malloc(num_fields*sizeof(Scheme_Object*));\n    \n    for (i=0; i<num_fields; ++i) {\n        a[i] = (Scheme_Object*) scheme_intern_symbol(field_names[i]);\n    }\n\n    new_type = scheme_make_struct_type(scheme_intern_symbol(basename),\n                                       NULL /*super_type*/,\n                                       scheme_make_inspector(0, NULL),\n                                       num_fields,\n                                       0 /* auto_fields */,\n                                       NULL /* auto_val */,\n                                       NULL /* properties */\n#ifdef MZSCHEME30X\n\t\t\t\t       ,NULL /* Guard */\n#endif\n\t\t\t\t       );\n    struct_names = scheme_make_struct_names(scheme_intern_symbol(basename),\n                                            scheme_build_list(num_fields,a),\n                                            0 /*flags*/, &count_out);\n    vals = scheme_make_struct_values(new_type, struct_names, count_out, 0);\n\n    for (i = 0; i < count_out; i++)\n        scheme_add_global_symbol(struct_names[i], vals[i],env);\n\n    return new_type;\n}\n\n#if defined(_WIN32) || defined(__WIN32__)\n#define __OS_WIN32\n#endif\n\n#ifdef __OS_WIN32\n#include <windows.h>\n#else\n#include <dlfcn.h>\n#endif\n\n  static char **mz_dlopen_libraries=NULL;\n  static void **mz_libraries=NULL;\n  static char **mz_dynload_libpaths=NULL;\n\n  static void mz_set_dlopen_libraries(const char *_libs)\n  {\n    int   i,k,n;\n    int   mz_dynload_debug=(1==0);\n    char *extra_paths[1000];\n    char *EP;\n    \n    {\n      char *dbg=getenv(\"MZ_DYNLOAD_DEBUG\");\n      if (dbg!=NULL) {\n\tmz_dynload_debug=atoi(dbg);\n      }\n    }\n\n    {\n      char *ep=getenv(\"MZ_DYNLOAD_LIBPATH\");\n      int   i,k,j;\n      k=0;\n      if (ep!=NULL) {\n\tEP=strdup(ep);\n\tfor(i=0,j=0;EP[i]!='\\0';i++) {\n\t  if (EP[i]==':') {\n\t    EP[i]='\\0';\n\t    extra_paths[k++]=&EP[j];\n\t    j=i+1;\n\t  }\n\t}\n\tif (j!=i) {\n\t  extra_paths[k++]=&EP[j];\n\t}\n      }\n      else {\n\tEP=strdup(\"\");\n      }\n      extra_paths[k]=NULL;\n      k+=1;\n\n      if (mz_dynload_debug) {\n\tfprintf(stderr,\"SWIG:mzscheme:MZ_DYNLOAD_LIBPATH=%s\\n\",(ep==NULL) ? \"(null)\" : ep);\n\tfprintf(stderr,\"SWIG:mzscheme:extra_paths[%d]\\n\",k-1);\n\tfor(i=0;i<k-1;i++) {\n\t  fprintf(stderr,\"SWIG:mzscheme:extra_paths[%d]=%s\\n\",i,extra_paths[i]);\n\t}\n      }\n\n      mz_dynload_libpaths=(char **) malloc(sizeof(char *)*k);\n      for(i=0;i<k;i++) {\n\tif (extra_paths[i]!=NULL) {\n\t  mz_dynload_libpaths[i]=strdup(extra_paths[i]);\n\t}\n\telse {\n\t  mz_dynload_libpaths[i]=NULL;\n\t}\n      }\n\n      if (mz_dynload_debug) {\n\tint i;\n\tfor(i=0;extra_paths[i]!=NULL;i++) {\n\t  fprintf(stderr,\"SWIG:mzscheme:%s\\n\",extra_paths[i]);\n\t}\n      }\n    }\n\n    {\n#ifdef MZ_DYNLOAD_LIBS\n      char *libs=(char *) malloc((strlen(MZ_DYNLOAD_LIBS)+1)*sizeof(char));\n      strcpy(libs,MZ_DYNLOAD_LIBS);\n#else\n      char *libs=(char *) malloc((strlen(_libs)+1)*sizeof(char));\n      strcpy(libs,_libs);\n#endif\n      \n      for(i=0,n=strlen(libs),k=0;i<n;i++) {\n\tif (libs[i]==',') { k+=1; }\n      }\n      k+=1;\n      mz_dlopen_libraries=(char **) malloc(sizeof(char *)*(k+1));\n      mz_dlopen_libraries[0]=libs;\n      for(i=0,k=1,n=strlen(libs);i<n;i++) {\n\tif (libs[i]==',') {\n\t  libs[i]='\\0';\n\t  mz_dlopen_libraries[k++]=&libs[i+1];\n\t  i+=1;\n\t}\n      }\n      \n      if (mz_dynload_debug) {\n\tfprintf(stderr,\"k=%d\\n\",k);\n      }\n      mz_dlopen_libraries[k]=NULL;\n      \n      free(EP);\n    }\n  }\n\n  static void *mz_load_function(char *function)\n  {\n    int mz_dynload_debug=(1==0);\n    \n    {\n      char *dbg=getenv(\"MZ_DYNLOAD_DEBUG\");\n      if (dbg!=NULL) {\n\tmz_dynload_debug=atoi(dbg);\n      }\n    }\n\n    if (mz_dlopen_libraries==NULL) {\n      return NULL;\n    }\n    else {\n      if (mz_libraries==NULL) {\n        int i,n;\n        for(n=0;mz_dlopen_libraries[n]!=NULL;n++);\n\tif (mz_dynload_debug) {\n\t  fprintf(stderr,\"SWIG:mzscheme:n=%d\\n\",n);\n\t}\n        mz_libraries=(void **) malloc(sizeof(void*)*n);\n        for(i=0;i<n;i++) { \n\t  if (mz_dynload_debug) {\n\t   fprintf(stderr,\"SWIG:mzscheme:loading %s\\n\",mz_dlopen_libraries[i]);\n\t  }\n#ifdef __OS_WIN32\n\t  mz_libraries[i]=(void *) LoadLibrary(mz_dlopen_libraries[i]); \n#else\n\t  mz_libraries[i]=(void *) dlopen(mz_dlopen_libraries[i],RTLD_LAZY); \n#endif\n\t  if (mz_libraries[i]==NULL) {\n\t    int k;\n\t    char *libp;\n\t    for(k=0;mz_dynload_libpaths[k]!=NULL && mz_libraries[i]==NULL;k++) {\n\t      int L=strlen(mz_dynload_libpaths[k])+strlen(\"\\\\\")+strlen(mz_dlopen_libraries[i])+1;\n\t      libp=(char *) malloc(L*sizeof(char));\n#ifdef __OS_WIN32\n\t      sprintf(libp,\"%s\\\\%s\",mz_dynload_libpaths[k],mz_dlopen_libraries[i]);\n\t      mz_libraries[i]=(void *) LoadLibrary(libp); \n#else\n\t      sprintf(libp,\"%s/%s\",mz_dynload_libpaths[k],mz_dlopen_libraries[i]);\n\t      mz_libraries[i]=(void *) dlopen(libp,RTLD_LAZY); \n#endif\n\t      if (mz_dynload_debug) {\n\t\tfprintf(stderr,\"SWIG:mzscheme:trying %s --> %p\\n\",libp,mz_libraries[i]);\n\t      }\n\t      free(libp);\n\t    }\n\t  }\n        }\n      }\n      {\n        int i;\n        void *func=NULL;\n\n        for(i=0;mz_dlopen_libraries[i]!=NULL && func==NULL;i++) {\n          if (mz_libraries[i]!=NULL) {\n#ifdef __OS_WIN32\n            func=GetProcAddress(mz_libraries[i],function);\n#else\n            func=dlsym(mz_libraries[i],function);\n#endif\n          }\n\t  if (mz_dynload_debug) {\n\t    fprintf(stderr,\n\t\t    \"SWIG:mzscheme:library:%s;dlopen=%p,function=%s,func=%p\\n\",\n\t\t    mz_dlopen_libraries[i],mz_libraries[i],function,func\n\t\t    );\n\t  }\n        }\n\n        return func;\n      }\n    }\n  }\n\n/* The interpreter will store a pointer to this structure in a global\n   variable called swig-runtime-data-type-pointer.  The instance of this\n   struct is only used if no other module has yet been loaded */\nstruct swig_mzscheme_runtime_data {\n  swig_module_info *module_head;\n  Scheme_Type type;\n};\nstatic struct swig_mzscheme_runtime_data swig_mzscheme_runtime_data;\n\n\nstatic swig_module_info *\nSWIG_MzScheme_GetModule(Scheme_Env *env) {\n  Scheme_Object *pointer, *symbol;\n  struct swig_mzscheme_runtime_data *data;\n\n  /* first check if pointer already created */\n  symbol = scheme_intern_symbol(\"swig-runtime-data-type-pointer\" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME);\n  pointer = scheme_lookup_global(symbol, env);\n  if (pointer && SCHEME_CPTRP(pointer)) {\n      data = (struct swig_mzscheme_runtime_data *) SCHEME_CPTR_VAL(pointer);\n      swig_type = data->type;\n      return data->module_head;\n  } else {\n      return NULL;\n  }\n}\n\nstatic void\nSWIG_MzScheme_SetModule(Scheme_Env *env, swig_module_info *module) {\n  Scheme_Object *pointer, *symbol;\n  struct swig_mzscheme_runtime_data *data;\n\n  /* first check if pointer already created */\n  symbol = scheme_intern_symbol(\"swig-runtime-data-type-pointer\" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME);\n  pointer = scheme_lookup_global(symbol, env);\n  if (pointer && SCHEME_CPTRP(pointer)) {\n    data = (struct swig_mzscheme_runtime_data *) SCHEME_CPTR_VAL(pointer);\n    swig_type = data->type;\n    data->module_head = module;\n  } else {\n    /* create a new type for wrapped pointer values */\n    swig_type = scheme_make_type((char *)\"swig\");\n    swig_mzscheme_runtime_data.module_head = module;\n    swig_mzscheme_runtime_data.type = swig_type;\n    \n    /* create a new pointer */\n#ifndef MZSCHEME30X\n    pointer = scheme_make_cptr((void *) &swig_mzscheme_runtime_data, \"swig_mzscheme_runtime_data\");\n#else\n    pointer = scheme_make_cptr((void *) &swig_mzscheme_runtime_data,\n\t\t\t       scheme_make_byte_string(\"swig_mzscheme_runtime_data\"));\n#endif\n    scheme_add_global_symbol(symbol, pointer, env);\n  }\n}\n\n#ifdef __cplusplus\n}\n#endif\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-swig-4.0.2-fortran-g56ercorgz6iqsj2oxpaerfkjervkynd/spack-src/Tools/javascript/js_shell.cxx": "#include \"js_shell.h\"\n\n#include <iostream>\n#include <fstream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\n#ifdef __GNUC__\n#ifdef __APPLE__\n#define LIBRARY_EXT \".bundle\"\n#else\n#define LIBRARY_EXT \".so\"\n#endif\n#include <dlfcn.h>\n#define LOAD_LIBRARY(name) dlopen(name, RTLD_LAZY)\n#define CLOSE_LIBRARY(handle) dlclose(handle)\n#define LIBRARY_ERROR dlerror\n#define LIBRARYFILE(name) std::string(\"lib\").append(name).append(LIBRARY_EXT)\n#else\n#error \"implement dll loading\"\n#endif\n\n\nJSShell::~JSShell() {\n\n  for(std::vector<HANDLE>::iterator it = loaded_modules.begin();\n    it != loaded_modules.end(); ++it) {\n      HANDLE handle = *it;\n      CLOSE_LIBRARY(handle);\n  }\n\n}\n\n// TODO: this could be done more intelligent...\n// - can we achieve source file relative loading?\n// - better path resolution\nstd::string JSShell::LoadModule(const std::string& name, HANDLE* library) {\n\n  // works only for posix like OSs\n  size_t pathIdx = name.find_last_of(\"/\");\n\n  std::string lib_name;\n  std::string module_name;\n\n  if (pathIdx == std::string::npos) {\n    module_name = name;\n    lib_name = std::string(name).append(LIBRARY_EXT);\n  } else {\n    std::string path = name.substr(0, pathIdx+1);\n    module_name = name.substr(pathIdx+1);\n    lib_name = path.append(module_name).append(LIBRARY_EXT);\n  }\n\n  std::string lib_path;\n  HANDLE handle = 0;\n\n  for (int i = 0; i < module_path.size(); ++i) {\n    lib_path = module_path[i] + \"/\" + lib_name;\n    if (access( lib_path.c_str(), F_OK ) != -1) {\n      handle = LOAD_LIBRARY(lib_path.c_str());\n    }\n  }\n\n  if(handle == 0) {\n    std::cerr << \"Could not find module \" << lib_path << \":\"\n              << std::endl << LIBRARY_ERROR() << std::endl;\n    return 0;\n  }\n\n  loaded_modules.push_back(handle);\n\n  *library = handle;\n\n  return module_name;\n}\n\nbool JSShell::RunScript(const std::string& scriptPath) {\n  std::string source = ReadFile(scriptPath);\n  if(!InitializeEngine()) return false;\n\n  // Node.js compatibility: make `print` available as `console.log()`\n  ExecuteScript(\"var console = {}; console.log = print;\", \"<console>\");\n\n  if(!ExecuteScript(source, scriptPath)) {\n    return false;\n  }\n\n  return DisposeEngine();\n}\n\nbool JSShell::RunShell() {\n\n  if(!InitializeEngine()) return false;\n\n  static const int kBufferSize = 1024;\n  while (true) {\n    char buffer[kBufferSize];\n    printf(\"> \");\n    char* str = fgets(buffer, kBufferSize, stdin);\n    if (str == NULL) break;\n    std::string source(str);\n    ExecuteScript(source, \"(shell)\");\n  }\n  printf(\"\\n\");\n  return true;\n}\n\nstd::string JSShell::ReadFile(const std::string& fileName)\n{\n  std::string script;\n\n  std::ifstream file(fileName.c_str());\n  if (file.is_open()) {\n    while ( file.good() ) {\n      std::string line;\n      getline(file, line);\n      script.append(line);\n      script.append(\"\\n\");\n    }\n    file.close();\n  } else {\n    std::cout << \"Unable to open file \" << fileName << \".\" << std::endl;\n  }\n\n  return script;\n}\n\n#ifdef ENABLE_JSC\nextern JSShell* JSCShell_Create();\n#endif\n#ifdef ENABLE_V8\nextern JSShell* V8Shell_Create();\n#endif\n\ntypedef JSShell*(*ShellFactory)();\n\nstatic ShellFactory js_shell_factories[2] = {\n#ifdef ENABLE_JSC\nJSCShell_Create,\n#else\n0,\n#endif\n#ifdef ENABLE_V8\nV8Shell_Create,\n#else\n0,\n#endif\n};\n\nJSShell *JSShell::Create(Engine engine) {\n  if(js_shell_factories[engine] == 0) {\n    throw \"Engine not available.\";\n  }\n  return js_shell_factories[engine]();\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-swig-4.0.2-fortran-g56ercorgz6iqsj2oxpaerfkjervkynd/spack-src/Source/Modules/mzscheme.cxx": "/* ----------------------------------------------------------------------------- \n * This file is part of SWIG, which is licensed as a whole under version 3 \n * (or any later version) of the GNU General Public License. Some additional\n * terms also apply to certain portions of SWIG. The full details of the SWIG\n * license and copyrights can be found in the LICENSE and COPYRIGHT files\n * included with the SWIG source code as distributed by the SWIG developers\n * and at http://www.swig.org/legal.html.\n *\n * mzscheme.cxx\n *\n * Mzscheme language module for SWIG.\n * ----------------------------------------------------------------------------- */\n\n#include \"swigmod.h\"\n\n#include <ctype.h>\n\nstatic const char *usage = \"\\\nMzscheme Options (available with -mzscheme)\\n\\\n     -declaremodule                - Create extension that declares a module\\n\\\n     -dynamic-load <lib>,[lib,...] - Do not link with these libraries, dynamic load them\\n\\\n     -noinit                       - Do not emit module initialization code\\n\\\n     -prefix <name>                - Set a prefix <name> to be prepended to all names\\n\\\n\";\n\nstatic String *fieldnames_tab = 0;\nstatic String *convert_tab = 0;\nstatic String *convert_proto_tab = 0;\nstatic String *struct_name = 0;\nstatic String *mangled_struct_name = 0;\n\nstatic String *prefix = 0;\nstatic bool declaremodule = false;\nstatic bool noinit = false;\nstatic String *load_libraries = NULL;\nstatic String *module = 0;\nstatic const char *mzscheme_path = \"mzscheme\";\nstatic String *init_func_def = 0;\n\nstatic File *f_begin = 0;\nstatic File *f_runtime = 0;\nstatic File *f_header = 0;\nstatic File *f_wrappers = 0;\nstatic File *f_init = 0;\n\n// Used for garbage collection\nstatic int exporting_destructor = 0;\nstatic String *swigtype_ptr = 0;\nstatic String *cls_swigtype = 0;\n\nclass MZSCHEME:public Language {\npublic:\n\n  /* ------------------------------------------------------------\n   * main()\n   * ------------------------------------------------------------ */\n\n  virtual void main(int argc, char *argv[]) {\n\n    int i;\n\n     SWIG_library_directory(mzscheme_path);\n\n    // Look for certain command line options\n    for (i = 1; i < argc; i++) {\n      if (argv[i]) {\n\tif (strcmp(argv[i], \"-help\") == 0) {\n\t  fputs(usage, stdout);\n\t  SWIG_exit(0);\n\t} else if (strcmp(argv[i], \"-prefix\") == 0) {\n\t  if (argv[i + 1]) {\n\t    prefix = NewString(argv[i + 1]);\n\t    Swig_mark_arg(i);\n\t    Swig_mark_arg(i + 1);\n\t    i++;\n\t  } else {\n\t    Swig_arg_error();\n\t  }\n\t} else if (strcmp(argv[i], \"-declaremodule\") == 0) {\n\t  declaremodule = true;\n\t  Swig_mark_arg(i);\n\t} else if (strcmp(argv[i], \"-noinit\") == 0) {\n\t  noinit = true;\n\t  Swig_mark_arg(i);\n\t}\n\telse if (strcmp(argv[i], \"-dynamic-load\") == 0) {\n\t  if (argv[i + 1]) {\n\t    Delete(load_libraries);\n\t    load_libraries = NewString(argv[i + 1]);\n\t    Swig_mark_arg(i++);\n\t    Swig_mark_arg(i);\n\t  } else {\n\t    Swig_arg_error();\n\t  }\n\t}\n      }\n    }\n\n    // If a prefix has been specified make sure it ends in a '_' (not actually used!)\n    if (prefix) {\n      const char *px = Char(prefix);\n      if (px[Len(prefix) - 1] != '_')\n\tPrintf(prefix, \"_\");\n    } else\n      prefix = NewString(\"swig_\");\n\n    // Add a symbol for this module\n\n    Preprocessor_define(\"SWIGMZSCHEME 1\", 0);\n\n    // Set name of typemaps\n\n    SWIG_typemap_lang(\"mzscheme\");\n\n    // Read in default typemaps */\n    SWIG_config_file(\"mzscheme.swg\");\n    allow_overloading();\n\n  }\n\n  /* ------------------------------------------------------------\n   * top()\n   * ------------------------------------------------------------ */\n\n  virtual int top(Node *n) {\n\n    /* Initialize all of the output files */\n    String *outfile = Getattr(n, \"outfile\");\n\n    f_begin = NewFile(outfile, \"w\", SWIG_output_files());\n    if (!f_begin) {\n      FileErrorDisplay(outfile);\n      SWIG_exit(EXIT_FAILURE);\n    }\n    f_runtime = NewString(\"\");\n    f_init = NewString(\"\");\n    f_header = NewString(\"\");\n    f_wrappers = NewString(\"\");\n\n    /* Register file targets with the SWIG file handler */\n    Swig_register_filebyname(\"header\", f_header);\n    Swig_register_filebyname(\"wrapper\", f_wrappers);\n    Swig_register_filebyname(\"begin\", f_begin);\n    Swig_register_filebyname(\"runtime\", f_runtime);\n\n    init_func_def = NewString(\"\");\n    Swig_register_filebyname(\"init\", init_func_def);\n\n    Swig_banner(f_begin);\n\n    Printf(f_runtime, \"\\n\\n#ifndef SWIGMZSCHEME\\n#define SWIGMZSCHEME\\n#endif\\n\\n\");\n\n    module = Getattr(n, \"name\");\n\n    Language::top(n);\n\n    SwigType_emit_type_table(f_runtime, f_wrappers);\n    if (!noinit) {\n      if (declaremodule) {\n\tPrintf(f_init, \"#define SWIG_MZSCHEME_CREATE_MENV(env) scheme_primitive_module(scheme_intern_symbol(\\\"%s\\\"), env)\\n\", module);\n      } else {\n\tPrintf(f_init, \"#define SWIG_MZSCHEME_CREATE_MENV(env) (env)\\n\");\n      }\n      Printf(f_init, \"%s\\n\", Char(init_func_def));\n      if (declaremodule) {\n\tPrintf(f_init, \"\\tscheme_finish_primitive_module(menv);\\n\");\n      }\n      Printf(f_init, \"\\treturn scheme_void;\\n}\\n\");\n      Printf(f_init, \"Scheme_Object *scheme_initialize(Scheme_Env *env) {\\n\");\n\n      if (load_libraries) {\n\tPrintf(f_init, \"mz_set_dlopen_libraries(\\\"%s\\\");\\n\", load_libraries);\n      }\n\n      Printf(f_init, \"\\treturn scheme_reload(env);\\n\");\n      Printf(f_init, \"}\\n\");\n\n      Printf(f_init, \"Scheme_Object *scheme_module_name(void) {\\n\");\n      if (declaremodule) {\n\tPrintf(f_init, \"   return scheme_intern_symbol((char*)\\\"%s\\\");\\n\", module);\n      } else {\n\tPrintf(f_init, \"   return scheme_make_symbol((char*)\\\"%s\\\");\\n\", module);\n      }\n      Printf(f_init, \"}\\n\");\n    }\n\n    /* Close all of the files */\n    Dump(f_runtime, f_begin);\n    Dump(f_header, f_begin);\n    Dump(f_wrappers, f_begin);\n    Wrapper_pretty_print(f_init, f_begin);\n    Delete(f_header);\n    Delete(f_wrappers);\n    Delete(f_init);\n    Delete(f_runtime);\n    Delete(f_begin);\n    return SWIG_OK;\n  }\n\n  /* ------------------------------------------------------------\n   * functionWrapper()\n   * Create a function declaration and register it with the interpreter.\n   * ------------------------------------------------------------ */\n\n  void throw_unhandled_mzscheme_type_error(SwigType *d) {\n    Swig_warning(WARN_TYPEMAP_UNDEF, input_file, line_number, \"Unable to handle type %s.\\n\", SwigType_str(d, 0));\n  }\n\n  /* Return true iff T is a pointer type */\n\n  int\n   is_a_pointer(SwigType *t) {\n    return SwigType_ispointer(SwigType_typedef_resolve_all(t));\n  }\n\n  virtual int functionWrapper(Node *n) {\n    char *iname = GetChar(n, \"sym:name\");\n    SwigType *d = Getattr(n, \"type\");\n    ParmList *l = Getattr(n, \"parms\");\n    Parm *p;\n\n    Wrapper *f = NewWrapper();\n    String *proc_name = NewString(\"\");\n    String *target = NewString(\"\");\n    String *arg = NewString(\"\");\n    String *cleanup = NewString(\"\");\n    String *outarg = NewString(\"\");\n    String *build = NewString(\"\");\n    String *tm;\n    int i = 0;\n    int numargs;\n    int numreq;\n    String *overname = 0;\n\n    if (load_libraries) {\n      ParmList *parms = Getattr(n, \"parms\");\n      SwigType *type = Getattr(n, \"type\");\n      String *name = NewString(\"caller\");\n      Setattr(n, \"wrap:action\", Swig_cresult(type, Swig_cresult_name(), Swig_cfunction_call(name, parms)));\n    }\n\n    // Make a wrapper name for this\n    String *wname = Swig_name_wrapper(iname);\n    if (Getattr(n, \"sym:overloaded\")) {\n      overname = Getattr(n, \"sym:overname\");\n    } else {\n      if (!addSymbol(iname, n)) {\n        DelWrapper(f);\n\treturn SWIG_ERROR;\n      }\n    }\n    if (overname) {\n      Append(wname, overname);\n    }\n    Setattr(n, \"wrap:name\", wname);\n\n    // Build the name for Scheme.\n    Printv(proc_name, iname, NIL);\n    Replaceall(proc_name, \"_\", \"-\");\n\n    // writing the function wrapper function\n    Printv(f->def, \"static Scheme_Object *\", wname, \" (\", NIL);\n    Printv(f->def, \"int argc, Scheme_Object **argv\", NIL);\n    Printv(f->def, \")\\n{\", NIL);\n\n    /* Define the scheme name in C. This define is used by several\n       macros. */\n    Printv(f->def, \"#define FUNC_NAME \\\"\", proc_name, \"\\\"\", NIL);\n\n    // Emit all of the local variables for holding arguments.\n    emit_parameter_variables(l, f);\n\n    /* Attach the standard typemaps */\n    emit_attach_parmmaps(l, f);\n    Setattr(n, \"wrap:parms\", l);\n\n    numargs = emit_num_arguments(l);\n    numreq = emit_num_required(l);\n\n    /* Add the holder for the pointer to the function to be opened */\n    if (load_libraries) {\n      Wrapper_add_local(f, \"_function_loaded\", \"static int _function_loaded=(1==0)\");\n      Wrapper_add_local(f, \"_the_function\", \"static void *_the_function=NULL\");\n      {\n\tString *parms = ParmList_protostr(l);\n\tString *func = NewStringf(\"(*caller)(%s)\", parms);\n\tWrapper_add_local(f, \"caller\", SwigType_lstr(d, func));\t/*\"(*caller)()\")); */\n      }\n    }\n\n    // adds local variables\n    Wrapper_add_local(f, \"lenv\", \"int lenv = 1\");\n    Wrapper_add_local(f, \"values\", \"Scheme_Object *values[MAXVALUES]\");\n\n    if (load_libraries) {\n      Printf(f->code, \"if (!_function_loaded) { _the_function=mz_load_function(\\\"%s\\\");_function_loaded=(1==1); }\\n\", iname);\n      Printf(f->code, \"if (!_the_function) { scheme_signal_error(\\\"Cannot load C function '%s'\\\"); }\\n\", iname);\n      Printf(f->code, \"caller=_the_function;\\n\");\n    }\n\n    // Now write code to extract the parameters (this is super ugly)\n\n    for (i = 0, p = l; i < numargs; i++) {\n      /* Skip ignored arguments */\n\n      while (checkAttribute(p, \"tmap:in:numinputs\", \"0\")) {\n\tp = Getattr(p, \"tmap:in:next\");\n      }\n\n      SwigType *pt = Getattr(p, \"type\");\n      String *ln = Getattr(p, \"lname\");\n\n      // Produce names of source and target\n      Clear(target);\n      Clear(arg);\n      String *source = NewStringf(\"argv[%d]\", i);\n      Printf(target, \"%s\", ln);\n      Printv(arg, Getattr(p, \"name\"), NIL);\n\n      if (i >= numreq) {\n\tPrintf(f->code, \"if (argc > %d) {\\n\", i);\n      }\n      // Handle parameter types.\n      if ((tm = Getattr(p, \"tmap:in\"))) {\n\tReplaceall(tm, \"$source\", source);\n\tReplaceall(tm, \"$target\", target);\n\tReplaceall(tm, \"$input\", source);\n\tSetattr(p, \"emit:input\", source);\n\tPrintv(f->code, tm, \"\\n\", NIL);\n\tp = Getattr(p, \"tmap:in:next\");\n      } else {\n\t// no typemap found\n\t// check if typedef and resolve\n\tthrow_unhandled_mzscheme_type_error(pt);\n\tp = nextSibling(p);\n      }\n      if (i >= numreq) {\n\tPrintf(f->code, \"}\\n\");\n      }\n      Delete(source);\n    }\n\n    /* Insert constraint checking code */\n    for (p = l; p;) {\n      if ((tm = Getattr(p, \"tmap:check\"))) {\n\tReplaceall(tm, \"$target\", Getattr(p, \"lname\"));\n\tPrintv(f->code, tm, \"\\n\", NIL);\n\tp = Getattr(p, \"tmap:check:next\");\n      } else {\n\tp = nextSibling(p);\n      }\n    }\n\n    // Pass output arguments back to the caller.\n\n    for (p = l; p;) {\n      if ((tm = Getattr(p, \"tmap:argout\"))) {\n\tReplaceall(tm, \"$source\", Getattr(p, \"emit:input\"));\t/* Deprecated */\n\tReplaceall(tm, \"$target\", Getattr(p, \"lname\"));\t/* Deprecated */\n\tReplaceall(tm, \"$arg\", Getattr(p, \"emit:input\"));\n\tReplaceall(tm, \"$input\", Getattr(p, \"emit:input\"));\n\tPrintv(outarg, tm, \"\\n\", NIL);\n\tp = Getattr(p, \"tmap:argout:next\");\n      } else {\n\tp = nextSibling(p);\n      }\n    }\n\n    // Free up any memory allocated for the arguments.\n\n    /* Insert cleanup code */\n    for (p = l; p;) {\n      if ((tm = Getattr(p, \"tmap:freearg\"))) {\n\tReplaceall(tm, \"$target\", Getattr(p, \"lname\"));\n\tPrintv(cleanup, tm, \"\\n\", NIL);\n\tp = Getattr(p, \"tmap:freearg:next\");\n      } else {\n\tp = nextSibling(p);\n      }\n    }\n\n    // Now write code to make the function call\n\n    String *actioncode = emit_action(n);\n\n    // Now have return value, figure out what to do with it.\n    if ((tm = Swig_typemap_lookup_out(\"out\", n, Swig_cresult_name(), f, actioncode))) {\n      Replaceall(tm, \"$source\", Swig_cresult_name());\n      Replaceall(tm, \"$target\", \"values[0]\");\n      Replaceall(tm, \"$result\", \"values[0]\");\n      if (GetFlag(n, \"feature:new\"))\n\tReplaceall(tm, \"$owner\", \"1\");\n      else\n\tReplaceall(tm, \"$owner\", \"0\");\n      Printv(f->code, tm, \"\\n\", NIL);\n    } else {\n      throw_unhandled_mzscheme_type_error(d);\n    }\n    emit_return_variable(n, d, f);\n\n    // Dump the argument output code\n    Printv(f->code, Char(outarg), NIL);\n\n    // Dump the argument cleanup code\n    Printv(f->code, Char(cleanup), NIL);\n\n    // Look for any remaining cleanup\n\n    if (GetFlag(n, \"feature:new\")) {\n      if ((tm = Swig_typemap_lookup(\"newfree\", n, Swig_cresult_name(), 0))) {\n\tReplaceall(tm, \"$source\", Swig_cresult_name());\n\tPrintv(f->code, tm, \"\\n\", NIL);\n      }\n    }\n    // Free any memory allocated by the function being wrapped..\n\n    if ((tm = Swig_typemap_lookup(\"ret\", n, Swig_cresult_name(), 0))) {\n      Replaceall(tm, \"$source\", Swig_cresult_name());\n      Printv(f->code, tm, \"\\n\", NIL);\n    }\n    // Wrap things up (in a manner of speaking)\n\n    Printv(f->code, tab4, \"return SWIG_MzScheme_PackageValues(lenv, values);\\n\", NIL);\n    Printf(f->code, \"#undef FUNC_NAME\\n\");\n    Printv(f->code, \"}\\n\", NIL);\n\n    /* Substitute the function name */\n    Replaceall(f->code, \"$symname\", iname);\n\n    Wrapper_print(f, f_wrappers);\n\n    if (!Getattr(n, \"sym:overloaded\")) {\n\n      // Now register the function\n      char temp[256];\n      sprintf(temp, \"%d\", numargs);\n      if (exporting_destructor) {\n\tPrintf(init_func_def, \"SWIG_TypeClientData(SWIGTYPE%s, (void *) %s);\\n\", swigtype_ptr, wname);\n      }\n      Printf(init_func_def, \"scheme_add_global(\\\"%s\\\", scheme_make_prim_w_arity(%s,\\\"%s\\\",%d,%d),menv);\\n\", proc_name, wname, proc_name, numreq, numargs);\n    } else {\n      if (!Getattr(n, \"sym:nextSibling\")) {\n\t/* Emit overloading dispatch function */\n\n\tint maxargs;\n\tString *dispatch = Swig_overload_dispatch(n, \"return %s(argc,argv);\", &maxargs);\n\n\t/* Generate a dispatch wrapper for all overloaded functions */\n\n\tWrapper *df = NewWrapper();\n\tString *dname = Swig_name_wrapper(iname);\n\n\tPrintv(df->def, \"static Scheme_Object *\\n\", dname, \"(int argc, Scheme_Object **argv) {\", NIL);\n\tPrintv(df->code, dispatch, \"\\n\", NIL);\n\tPrintf(df->code, \"scheme_signal_error(\\\"No matching function for overloaded '%s'\\\");\\n\", iname);\n\tPrintf(df->code, \"return NULL;\\n\", iname);\n\tPrintv(df->code, \"}\\n\", NIL);\n\tWrapper_print(df, f_wrappers);\n\tPrintf(init_func_def, \"scheme_add_global(\\\"%s\\\", scheme_make_prim_w_arity(%s,\\\"%s\\\",%d,%d),menv);\\n\", proc_name, dname, proc_name, 0, maxargs);\n\tDelWrapper(df);\n\tDelete(dispatch);\n\tDelete(dname);\n      }\n    }\n\n    Delete(proc_name);\n    Delete(target);\n    Delete(arg);\n    Delete(outarg);\n    Delete(cleanup);\n    Delete(build);\n    DelWrapper(f);\n    return SWIG_OK;\n  }\n\n  /* ------------------------------------------------------------\n   * variableWrapper()\n   *\n   * Create a link to a C variable.\n   * This creates a single function _wrap_swig_var_varname().\n   * This function takes a single optional argument.   If supplied, it means\n   * we are setting this variable to some value.  If omitted, it means we are\n   * simply evaluating this variable.  Either way, we return the variables\n   * value.\n   * ------------------------------------------------------------ */\n\n  virtual int variableWrapper(Node *n) {\n\n    char *name = GetChar(n, \"name\");\n    char *iname = GetChar(n, \"sym:name\");\n    SwigType *t = Getattr(n, \"type\");\n\n    String *proc_name = NewString(\"\");\n    String *tm;\n    String *tm2 = NewString(\"\");\n    String *argnum = NewString(\"0\");\n    String *arg = NewString(\"argv[0]\");\n    Wrapper *f;\n\n    if (!addSymbol(iname, n))\n      return SWIG_ERROR;\n\n    f = NewWrapper();\n\n    // evaluation function names\n    String *var_name = Swig_name_wrapper(iname);\n\n    // Build the name for scheme.\n    Printv(proc_name, iname, NIL);\n    Replaceall(proc_name, \"_\", \"-\");\n    Setattr(n, \"wrap:name\", proc_name);\n\n    if ((SwigType_type(t) != T_USER) || (is_a_pointer(t))) {\n\n      Printf(f->def, \"static Scheme_Object *%s(int argc, Scheme_Object** argv) {\\n\", var_name);\n      Printv(f->def, \"#define FUNC_NAME \\\"\", proc_name, \"\\\"\", NIL);\n\n      Wrapper_add_local(f, \"swig_result\", \"Scheme_Object *swig_result\");\n\n      if (!GetFlag(n, \"feature:immutable\")) {\n\t/* Check for a setting of the variable value */\n\tPrintf(f->code, \"if (argc) {\\n\");\n\tif ((tm = Swig_typemap_lookup(\"varin\", n, name, 0))) {\n\t  Replaceall(tm, \"$source\", \"argv[0]\");\n\t  Replaceall(tm, \"$target\", name);\n\t  Replaceall(tm, \"$input\", \"argv[0]\");\n\t  Replaceall(tm, \"$argnum\", \"1\");\n\t  emit_action_code(n, f->code, tm);\n\t} else {\n\t  throw_unhandled_mzscheme_type_error(t);\n\t}\n\tPrintf(f->code, \"}\\n\");\n      }\n      // Now return the value of the variable (regardless\n      // of evaluating or setting)\n\n      if ((tm = Swig_typemap_lookup(\"varout\", n, name, 0))) {\n\tReplaceall(tm, \"$source\", name);\n\tReplaceall(tm, \"$target\", \"swig_result\");\n\tReplaceall(tm, \"$result\", \"swig_result\");\n\t/* Printf (f->code, \"%s\\n\", tm); */\n\temit_action_code(n, f->code, tm);\n      } else {\n\tthrow_unhandled_mzscheme_type_error(t);\n      }\n      Printf(f->code, \"\\nreturn swig_result;\\n\");\n      Printf(f->code, \"#undef FUNC_NAME\\n\");\n      Printf(f->code, \"}\\n\");\n\n      Wrapper_print(f, f_wrappers);\n\n      // Now add symbol to the MzScheme interpreter\n\n      Printv(init_func_def,\n\t     \"scheme_add_global(\\\"\", proc_name, \"\\\", scheme_make_prim_w_arity(\", var_name, \", \\\"\", proc_name, \"\\\", \", \"0\", \", \", \"1\", \"), menv);\\n\", NIL);\n\n    } else {\n      Swig_warning(WARN_TYPEMAP_VAR_UNDEF, input_file, line_number, \"Unsupported variable type %s (ignored).\\n\", SwigType_str(t, 0));\n    }\n    Delete(var_name);\n    Delete(proc_name);\n    Delete(argnum);\n    Delete(arg);\n    Delete(tm2);\n    DelWrapper(f);\n    return SWIG_OK;\n  }\n\n  /* ------------------------------------------------------------\n   * constantWrapper()\n   * ------------------------------------------------------------ */\n\n  virtual int constantWrapper(Node *n) {\n    char *name = GetChar(n, \"name\");\n    char *iname = GetChar(n, \"sym:name\");\n    SwigType *type = Getattr(n, \"type\");\n    String *value = Getattr(n, \"value\");\n\n    String *var_name = NewString(\"\");\n    String *proc_name = NewString(\"\");\n    String *rvalue = NewString(\"\");\n    String *temp = NewString(\"\");\n    String *tm;\n\n    // Make a static variable;\n\n    Printf(var_name, \"_wrap_const_%s\", Swig_name_mangle(Getattr(n, \"sym:name\")));\n\n    // Build the name for scheme.\n    Printv(proc_name, iname, NIL);\n    Replaceall(proc_name, \"_\", \"-\");\n\n    if ((SwigType_type(type) == T_USER) && (!is_a_pointer(type))) {\n      Swig_warning(WARN_TYPEMAP_CONST_UNDEF, input_file, line_number, \"Unsupported constant value.\\n\");\n      return SWIG_NOWRAP;\n    }\n    // See if there's a typemap\n\n    Printv(rvalue, value, NIL);\n    if ((SwigType_type(type) == T_CHAR) && (is_a_pointer(type) == 1)) {\n      temp = Copy(rvalue);\n      Clear(rvalue);\n      Printv(rvalue, \"\\\"\", temp, \"\\\"\", NIL);\n    }\n    if ((SwigType_type(type) == T_CHAR) && (is_a_pointer(type) == 0)) {\n      Delete(temp);\n      temp = Copy(rvalue);\n      Clear(rvalue);\n      Printv(rvalue, \"'\", temp, \"'\", NIL);\n    }\n    if ((tm = Swig_typemap_lookup(\"constant\", n, name, 0))) {\n      Replaceall(tm, \"$source\", rvalue);\n      Replaceall(tm, \"$value\", rvalue);\n      Replaceall(tm, \"$target\", name);\n      Printf(f_init, \"%s\\n\", tm);\n    } else {\n      // Create variable and assign it a value\n\n      Printf(f_header, \"static %s = \", SwigType_lstr(type, var_name));\n      bool is_enum_item = (Cmp(nodeType(n), \"enumitem\") == 0);\n      if ((SwigType_type(type) == T_STRING)) {\n\tPrintf(f_header, \"\\\"%s\\\";\\n\", value);\n      } else if (SwigType_type(type) == T_CHAR && !is_enum_item) {\n\tPrintf(f_header, \"\\'%s\\';\\n\", value);\n      } else {\n\tPrintf(f_header, \"%s;\\n\", value);\n      }\n\n      // Now create a variable declaration\n\n      {\n\t/* Hack alert: will cleanup later -- Dave */\n\tNode *nn = NewHash();\n\tSetfile(nn, Getfile(n));\n\tSetline(nn, Getline(n));\n\tSetattr(nn, \"name\", var_name);\n\tSetattr(nn, \"sym:name\", iname);\n\tSetattr(nn, \"type\", type);\n\tSetFlag(nn, \"feature:immutable\");\n\tvariableWrapper(nn);\n\tDelete(nn);\n      }\n    }\n    Delete(proc_name);\n    Delete(rvalue);\n    Delete(temp);\n    return SWIG_OK;\n  }\n\n  virtual int destructorHandler(Node *n) {\n    exporting_destructor = true;\n    Language::destructorHandler(n);\n    exporting_destructor = false;\n    return SWIG_OK;\n  }\n\n  /* ------------------------------------------------------------\n   * classHandler()\n   * ------------------------------------------------------------ */\n  virtual int classHandler(Node *n) {\n    String *mangled_classname = 0;\n    String *real_classname = 0;\n    String *scm_structname = NewString(\"\");\n    SwigType *ctype_ptr = NewStringf(\"p.%s\", getClassType());\n\n    SwigType *t = NewStringf(\"p.%s\", Getattr(n, \"name\"));\n    swigtype_ptr = SwigType_manglestr(t);\n    Delete(t);\n\n    cls_swigtype = SwigType_manglestr(Getattr(n, \"name\"));\n\n\n    fieldnames_tab = NewString(\"\");\n    convert_tab = NewString(\"\");\n    convert_proto_tab = NewString(\"\");\n\n    struct_name = Getattr(n, \"sym:name\");\n    mangled_struct_name = Swig_name_mangle(Getattr(n, \"sym:name\"));\n\n    Printv(scm_structname, struct_name, NIL);\n    Replaceall(scm_structname, \"_\", \"-\");\n\n    real_classname = Getattr(n, \"name\");\n    mangled_classname = Swig_name_mangle(real_classname);\n\n    Printv(fieldnames_tab, \"static const char *_swig_struct_\", cls_swigtype, \"_field_names[] = { \\n\", NIL);\n\n    Printv(convert_proto_tab, \"static Scheme_Object *_swig_convert_struct_\", cls_swigtype, \"(\", SwigType_str(ctype_ptr, \"ptr\"), \");\\n\", NIL);\n\n    Printv(convert_tab, \"static Scheme_Object *_swig_convert_struct_\", cls_swigtype, \"(\", SwigType_str(ctype_ptr, \"ptr\"), \")\\n {\\n\", NIL);\n\n    Printv(convert_tab,\n\t   tab4, \"Scheme_Object *obj;\\n\", tab4, \"Scheme_Object *fields[_swig_struct_\", cls_swigtype, \"_field_names_cnt];\\n\", tab4, \"int i = 0;\\n\\n\", NIL);\n\n    /* Generate normal wrappers */\n    Language::classHandler(n);\n\n    Printv(convert_tab, tab4, \"obj = scheme_make_struct_instance(\", \"_swig_struct_type_\", cls_swigtype, \", i, fields);\\n\", NIL);\n    Printv(convert_tab, tab4, \"return obj;\\n}\\n\\n\", NIL);\n\n    Printv(fieldnames_tab, \"};\\n\", NIL);\n\n    Printv(f_header, \"static Scheme_Object *_swig_struct_type_\", cls_swigtype, \";\\n\", NIL);\n\n    Printv(f_header, fieldnames_tab, NIL);\n    Printv(f_header, \"#define  _swig_struct_\", cls_swigtype, \"_field_names_cnt (sizeof(_swig_struct_\", cls_swigtype, \"_field_names)/sizeof(char*))\\n\", NIL);\n\n    Printv(f_header, convert_proto_tab, NIL);\n    Printv(f_wrappers, convert_tab, NIL);\n\n    Printv(init_func_def, \"_swig_struct_type_\", cls_swigtype,\n\t   \" = SWIG_MzScheme_new_scheme_struct(menv, \\\"\", scm_structname, \"\\\", \",\n\t   \"_swig_struct_\", cls_swigtype, \"_field_names_cnt,\", \"(char**) _swig_struct_\", cls_swigtype, \"_field_names);\\n\", NIL);\n\n    Delete(mangled_classname);\n    Delete(swigtype_ptr);\n    swigtype_ptr = 0;\n    Delete(fieldnames_tab);\n    Delete(convert_tab);\n    Delete(ctype_ptr);\n    Delete(convert_proto_tab);\n    struct_name = 0;\n    mangled_struct_name = 0;\n    Delete(cls_swigtype);\n    cls_swigtype = 0;\n\n    return SWIG_OK;\n  }\n\n  /* ------------------------------------------------------------\n   * membervariableHandler()\n   * ------------------------------------------------------------ */\n\n  virtual int membervariableHandler(Node *n) {\n    Language::membervariableHandler(n);\n\n    if (!is_smart_pointer()) {\n      String *symname = Getattr(n, \"sym:name\");\n      String *name = Getattr(n, \"name\");\n      SwigType *type = Getattr(n, \"type\");\n      String *swigtype = SwigType_manglestr(Getattr(n, \"type\"));\n      String *tm = 0;\n      String *access_mem = NewString(\"\");\n      SwigType *ctype_ptr = NewStringf(\"p.%s\", Getattr(n, \"type\"));\n\n      Printv(fieldnames_tab, tab4, \"\\\"\", symname, \"\\\",\\n\", NIL);\n      Printv(access_mem, \"(ptr)->\", name, NIL);\n      if ((SwigType_type(type) == T_USER) && (!is_a_pointer(type))) {\n\tPrintv(convert_tab, tab4, \"fields[i++] = \", NIL);\n\tPrintv(convert_tab, \"_swig_convert_struct_\", swigtype, \"((\", SwigType_str(ctype_ptr, 0), \")&((ptr)->\", name, \"));\\n\", NIL);\n      } else if ((tm = Swig_typemap_lookup(\"varout\", n, access_mem, 0))) {\n\tReplaceall(tm, \"$result\", \"fields[i++]\");\n\tPrintv(convert_tab, tm, \"\\n\", NIL);\n      } else\n\tSwig_warning(WARN_TYPEMAP_VAR_UNDEF, input_file, line_number, \"Unsupported member variable type %s (ignored).\\n\", SwigType_str(type, 0));\n\n      Delete(access_mem);\n    }\n    return SWIG_OK;\n  }\n\n\n  /* ------------------------------------------------------------\n   * validIdentifier()\n   * ------------------------------------------------------------ */\n\n  virtual int validIdentifier(String *s) {\n    char *c = Char(s);\n    /* Check whether we have an R5RS identifier. */\n    /* <identifier> --> <initial> <subsequent>* | <peculiar identifier> */\n    /* <initial> --> <letter> | <special initial> */\n    if (!(isalpha(*c) || (*c == '!') || (*c == '$') || (*c == '%')\n\t  || (*c == '&') || (*c == '*') || (*c == '/') || (*c == ':')\n\t  || (*c == '<') || (*c == '=') || (*c == '>') || (*c == '?')\n\t  || (*c == '^') || (*c == '_') || (*c == '~'))) {\n      /* <peculiar identifier> --> + | - | ... */\n      if ((strcmp(c, \"+\") == 0)\n\t  || strcmp(c, \"-\") == 0 || strcmp(c, \"...\") == 0)\n\treturn 1;\n      else\n\treturn 0;\n    }\n    /* <subsequent> --> <initial> | <digit> | <special subsequent> */\n    while (*c) {\n      if (!(isalnum(*c) || (*c == '!') || (*c == '$') || (*c == '%')\n\t    || (*c == '&') || (*c == '*') || (*c == '/') || (*c == ':')\n\t    || (*c == '<') || (*c == '=') || (*c == '>') || (*c == '?')\n\t    || (*c == '^') || (*c == '_') || (*c == '~') || (*c == '+')\n\t    || (*c == '-') || (*c == '.') || (*c == '@')))\n\treturn 0;\n      c++;\n    }\n    return 1;\n  }\n\n  String *runtimeCode() {\n    String *s = Swig_include_sys(\"mzrun.swg\");\n    if (!s) {\n      Printf(stderr, \"*** Unable to open 'mzrun.swg'\\n\");\n      s = NewString(\"\");\n    }\n    return s;\n  }\n\n  String *defaultExternalRuntimeFilename() {\n    return NewString(\"swigmzrun.h\");\n  }\n};\n\n/* -----------------------------------------------------------------------------\n * swig_mzscheme()    - Instantiate module\n * ----------------------------------------------------------------------------- */\n\nstatic Language *new_swig_mzscheme() {\n  return new MZSCHEME();\n}\nextern \"C\" Language *swig_mzscheme(void) {\n  return new_swig_mzscheme();\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-swig-4.0.2-fortran-g56ercorgz6iqsj2oxpaerfkjervkynd/spack-src/Doc/Manual/swig16.png",
        "/tmp/vanessa/spack-stage/spack-stage-swig-4.0.2-fortran-g56ercorgz6iqsj2oxpaerfkjervkynd/spack-src/Doc/Manual/ch2.1.png",
        "/tmp/vanessa/spack-stage/spack-stage-swig-4.0.2-fortran-g56ercorgz6iqsj2oxpaerfkjervkynd/spack-src/Doc/Manual/fortran-data.png",
        "/tmp/vanessa/spack-stage/spack-stage-swig-4.0.2-fortran-g56ercorgz6iqsj2oxpaerfkjervkynd/spack-src/Doc/Manual/android-simple.png",
        "/tmp/vanessa/spack-stage/spack-stage-swig-4.0.2-fortran-g56ercorgz6iqsj2oxpaerfkjervkynd/spack-src/Doc/Manual/android-class.png",
        "/tmp/vanessa/spack-stage/spack-stage-swig-4.0.2-fortran-g56ercorgz6iqsj2oxpaerfkjervkynd/spack-src/Examples/test-suite/enum_thorough.i",
        "/tmp/vanessa/spack-stage/spack-stage-swig-4.0.2-fortran-g56ercorgz6iqsj2oxpaerfkjervkynd/spack-src/Examples/test-suite/char_constant.i",
        "/tmp/vanessa/spack-stage/spack-stage-swig-4.0.2-fortran-g56ercorgz6iqsj2oxpaerfkjervkynd/spack-src/Examples/test-suite/chartest.i",
        "/tmp/vanessa/spack-stage/spack-stage-swig-4.0.2-fortran-g56ercorgz6iqsj2oxpaerfkjervkynd/spack-src/Examples/test-suite/ruby/char_constant_runme.rb"
    ],
    "total_files": 5410
}