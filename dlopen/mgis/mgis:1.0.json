{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-mgis-1.0-nmblp7q46mtpwreujnldfh76phmcjxoa/spack-src/src/LibrariesManager.cxx": "/*!\n * \\file   LibrariesManager.cxx\n * \\brief\n * \\author Thomas Helfer\n * \\date   19/06/2018\n * \\copyright (C) Copyright Thomas Helfer 2018.\n * Use, modification and distribution are subject\n * to one of the following licences:\n * - GNU Lesser General Public License (LGPL), Version 3.0. (See accompanying\n *   file LGPL-3.0.txt)\n * - CECILL-C,  Version 1.0 (See accompanying files\n *   CeCILL-C_V1-en.txt and CeCILL-C_V1-fr.txt).\n */\n\n#include <algorithm>\n#include <cstring>\n#if !((defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__))\n#include <dlfcn.h>\n#endif /* !((defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__)) */\n\n#include \"MGIS/LibrariesManager.hxx\"\n#include \"MGIS/Raise.hxx\"\n\nnamespace mgis {\n\n#if (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__)\n// code retrieved from\n// http://www.codeproject.com/Tips/479880/GetLastError-as-std-string\nstatic std::string getLastWin32Error() {\n  const DWORD error = GetLastError();\n  if (error) {\n    LPVOID lpMsgBuf;\n    DWORD bufLen = FormatMessage(\n        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM |\n            FORMAT_MESSAGE_IGNORE_INSERTS,\n        nullptr, error, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n        (LPTSTR)&lpMsgBuf, 0, nullptr);\n    if (bufLen) {\n      LPCSTR lpMsgStr = (LPTSTR)lpMsgBuf;\n      std::string result(lpMsgStr, lpMsgStr + bufLen);\n      LocalFree(lpMsgBuf);\n      return result;\n    }\n  }\n  return std::string();\n}\n#endif /*  (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__) */\n\nstatic std::string getErrorMessage() {\n#if (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__)\n  return getLastWin32Error();\n#else\n  const auto e = ::dlerror();\n  if (e != nullptr) {\n    return std::string(e);\n  }\n  return \"\";\n#endif /* (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__) */\n} // end of  getErrorMessage\n\nstatic LibrariesManager::libhandler load_library(const std::string &l) {\n#if (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__)\n  return ::LoadLibrary(TEXT(l.c_str()));\n#else\n  return ::dlopen(l.c_str(), RTLD_NOW);\n#endif /* (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__) */\n} // end of load_library\n\nstatic std::pair<LibrariesManager::libhandler, std::string>\ntry_open(const std::string &l) {\n  auto starts_with = [](const std::string &s1, const char *const s2) {\n    const auto ls2 = std::strlen(s2);\n    return ((s1.size() >= ls2) && (std::equal(s2, s2 + ls2, s1.begin())));\n  }; // end of starts_with\n  auto ends_with = [](const std::string &s1, const char *const s2) {\n    const auto ls2 = std::strlen(s2);\n    if (!(s1.size() >= ls2)) {\n      return false;\n    }\n    return std::equal(s2, s2 + ls2, s1.begin() + (s1.size() - ls2));\n  }; // end of ends_with\n#if (defined(macintosh) || defined(Macintosh) ||                               \\\n     (defined(__APPLE__) && defined(__MACH__)))\n  const char *const ext = \".dylib\";\n#elif (defined(_WIN32) || defined(_WIN64) || defined(__CYGWIN__))\n  const char *const ext = \".dll\";\n#else\n  const char *const ext = \".so\";\n#endif\n  auto ln = l;\n  auto lib = load_library(l);\n#if defined(__CYGWIN__)\n  if ((lib == nullptr) && (!starts_with(l, \"cyg\"))) {\n    ln = \"cyg\" + l;\n    lib = load_library(ln);\n    if (lib == nullptr) {\n      if (!ends_with(l, ext)) {\n        ln = \"cyg\" + l + ext;\n        lib = load_library(ln);\n      }\n    }\n  }\n#endif\n#if !(defined(_WIN32) || defined(_WIN64))\n  if ((lib == nullptr) && (!starts_with(l, \"lib\"))) {\n    ln = \"lib\" + l;\n    lib = load_library(ln);\n    if (lib == nullptr) {\n      if (!ends_with(l, ext)) {\n        ln = \"lib\" + l + ext;\n        lib = load_library(ln);\n      }\n    }\n  }\n#endif\n  if ((lib == nullptr) && (!ends_with(l, ext))) {\n    ln = l + ext;\n    lib = load_library(ln);\n  }\n  // retrieving the initial error message\n  if (lib == nullptr) {\n    ln = l;\n    lib = load_library(ln);\n  }\n  return {lib, ln};\n} // end of try_open\n\nLibrariesManager &LibrariesManager::get() {\n  static LibrariesManager lm;\n  return lm;\n} // end of LibrariesManager::get\n\nLibrariesManager::LibrariesManager() = default;\n\nmgis::behaviour::BehaviourFctPtr LibrariesManager::getBehaviour(\n    const std::string &l, const std::string &b, const Hypothesis h) {\n  const auto hn = toString(h);\n  const auto p = this->getSymbolAddress(l, b + \"_\" + hn);\n  if (p == nullptr) {\n    mgis::raise(\n        \"LibrariesManager::getBehaviour: \"\n        \"can't load behaviour '\" +\n        b + \"' in library '\" + l + \"' for hypothesis '\" + hn + \"'\");\n  }\n  return reinterpret_cast<mgis::behaviour::BehaviourFctPtr>(p);\n}  // end of LibrariesManager::getBehaviour\n\nstd::string LibrariesManager::getTFELVersion(const std::string &l,\n                                             const std::string &n) {\n  const auto p = this->getSymbolAddress(l, n + \"_tfel_version\");\n  if (p == nullptr) {\n    return \"\";\n  }\n  return *(static_cast<const char *const *>(p));\n} // end of LibrariesManager::getTFELVersion\n\nunsigned short LibrariesManager::getMaterialKnowledgeType(\n    const std::string &l, const std::string &b) {\n  return *(this->extract<unsigned short>(l, b + \"_mfront_mkt\"));\n} // end of LibrariesManager::getMaterialKnowledgeType\n\nstd::string LibrariesManager::getSource(const std::string &l,\n                                        const std::string &n) {\n  const auto p = this->getSymbolAddress(l, n + \"_src\");\n  if (p == nullptr) {\n    return \"\";\n  }\n  return *(static_cast<const char *const *>(p));\n} // end of LibrariesManager::getSource\n\nstd::string LibrariesManager::getInterface(const std::string &l,\n                                           const std::string &n) {\n  const auto p = this->getSymbolAddress(l, n + \"_mfront_interface\");\n  if (p == nullptr) {\n    return \"\";\n  }\n  return *(static_cast<const char *const *>(p));\n} // end of LibrariesManager::getInterface\n\nunsigned short LibrariesManager::getBehaviourType(const std::string &l,\n                                                  const std::string &b) {\n  return *(this->extract<unsigned short>(l, b + \"_BehaviourType\"));\n} // end of LibrariesManager::getBehaviourType\n\nunsigned short LibrariesManager::getBehaviourKinematic(const std::string &l,\n                                                       const std::string &b) {\n  return *(this->extract<unsigned short>(l, b + \"_BehaviourKinematic\"));\n} // end of LibrariesManager::getBehaviourKinematic\n\nunsigned short LibrariesManager::getBehaviourSymmetry(const std::string & l,\n                                                      const std::string & b){\n  return *(this->extract<unsigned short>(l, b + \"_SymmetryType\"));\n} // end of LibrariesManager::getBehaviourSymmetry\n\nunsigned short\nLibrariesManager::getElasticStiffnessSymmetry(const std::string &l,\n                                              const std::string &b) {\n  return *(this->extract<unsigned short>(l, b + \"_ElasticSymmetryType\"));\n} // end of LibrariesManager::getElasticStiffnessSymmetry\n\nbool LibrariesManager::requiresStiffnessTensor(const std::string &l,\n                                               const std::string &b,\n                                               const Hypothesis h) {\n  const auto sn = \"_requiresStiffnessTensor\";\n  const auto bv =\n      *(this->extract<unsigned short>(l, b + \"_\" + toString(h) + sn, b + sn));\n  return bv == 1 ? true : false;\n} // end of LibrariesManager::requiresStiffnessTensor\n\nbool LibrariesManager::requiresThermalExpansionCoefficientTensor(\n    const std::string &l, const std::string &b, const Hypothesis h) {\n  const auto sn = \"_requiresThermalExpansionCoefficientTensor\";\n  const auto bv =\n      *(this->extract<unsigned short>(l, b + \"_\" + toString(h) + sn, b + sn));\n  return bv == 1 ? true : false;\n} // end of LibrariesManager::requiresThermalExpansionCoefficientTensor\n\ntemplate <typename T>\nconst T *LibrariesManager::extract(const std::string &l, const std::string &n) {\n  const auto p = this->getSymbolAddress(l, n);\n  if (p == nullptr) {\n    raise(\"LibrariesManager::extract: could not load symbol '\" + n + \"'\");\n  }\n  return static_cast<const T *const>(p);\n} // end of LibrariesManager::extract\n\ntemplate <typename T>\nconst T *LibrariesManager::extract(const std::string &l, const std::string &n1,\n                                   const std::string &n2) {\n  const auto p = this->getSymbolAddress(l, n1, n2);\n  if (p == nullptr) {\n    raise(\"LibrariesManager::extract: could not load symbol '\" + n1 +\n          \"' nor '\" + n2 + \"'\");\n  }\n  return static_cast<const T *const>(p);\n} // end of LibrariesManager::extract\n\nstd::vector<std::string> LibrariesManager::getNames(const std::string &l,\n                                                    const std::string &f,\n                                                    const Hypothesis h,\n                                                    const std::string &n) {\n  std::vector<std::string> vars;\n  const auto hn = toString(h);\n  const auto nb = *(\n      this->extract<unsigned short>(l, f + \"_\" + hn + \"_n\" + n, f + \"_n\" + n));\n  const auto res =\n      this->extract<const char *const>(l, f + \"_\" + hn + '_' + n, f + '_' + n);\n  std::copy(res, res + nb, std::back_inserter(vars));\n  return vars;\n} // end of LibrariesManager::getNames\n\nstd::vector<std::string> LibrariesManager::getGradientsNames(\n    const std::string &l, const std::string &b, const Hypothesis h) {\n  return this->getNames(l, b, h, \"Gradients\");\n}  // end of LibrariesManager::getGradientsNames\n\nstd::vector<int> LibrariesManager::getGradientsTypes(\n    const std::string &l, const std::string &b, const Hypothesis h) {\n  std::vector<int> types;\n  const auto hn = toString(h);\n  const auto nb = *(this->extract<unsigned short>(\n      l, b + \"_\" + hn + \"_nGradients\",\n      b + \"_nGradients\"));\n  const auto res =\n      this->extract<const int>(l, b + \"_\" + hn + \"_GradientsTypes\",\n                               b + \"_GradientsTypes\");\n  std::copy(res, res + nb, std::back_inserter(types));\n  return types;\n} // end of LibrariesManager::getGradientsTypes\n\nstd::vector<std::string> LibrariesManager::getThermodynamicForcesNames(\n    const std::string &l, const std::string &b, const Hypothesis h) {\n  return this->getNames(l, b, h, \"ThermodynamicForces\");\n} // end of LibrariesManager::getThermodynamicForcesNames\n\nstd::vector<int> LibrariesManager::getThermodynamicForcesTypes(\n    const std::string &l, const std::string &b, const Hypothesis h) {\n  std::vector<int> types;\n  const auto hn = toString(h);\n  const auto nb = *(this->extract<unsigned short>(\n      l, b + \"_\" + hn + \"_nThermodynamicForces\",\n      b + \"_nThermodynamicForces\"));\n  const auto res =\n      this->extract<const int>(l, b + \"_\" + hn + \"_ThermodynamicForcesTypes\",\n                               b + \"_ThermodynamicForcesTypes\");\n  std::copy(res, res + nb, std::back_inserter(types));\n  return types;\n} // end of LibrariesManager::getThermodynamicForcesTypes\n\nstd::vector<std::string> LibrariesManager::getMaterialPropertiesNames(\n    const std::string &l, const std::string &b, const Hypothesis h) {\n  return this->getNames(l, b, h, \"MaterialProperties\");\n} // end of LibrariesManager::getMaterialPropertiesNames\n\nstd::vector<std::string> LibrariesManager::getInternalStateVariablesNames(\n    const std::string &l, const std::string &b, const Hypothesis h) {\n  return this->getNames(l, b, h, \"InternalStateVariables\");\n} // end of LibrariesManager::getInternalStateVariablesNames\n\nstd::vector<int> LibrariesManager::getInternalStateVariablesTypes(\n    const std::string &l, const std::string &b, const Hypothesis h) {\n  std::vector<int> types;\n  const auto hn = toString(h);\n  const auto nb = *(this->extract<unsigned short>(\n      l, b + \"_\" + hn + \"_nInternalStateVariables\",\n      b + \"_nInternalStateVariables\"));\n  const auto res =\n      this->extract<const int>(l, b + \"_\" + hn + \"_InternalStateVariablesTypes\",\n                               b + \"_InternalStateVariablesTypes\");\n  std::copy(res, res + nb, std::back_inserter(types));\n  return types;\n} // end of LibrariesManager::getInternalStateVariablesTypes\n\nstd::vector<std::string> LibrariesManager::getExternalStateVariablesNames(\n    const std::string &l, const std::string &b, const Hypothesis h) {\n  return this->getNames(l, b, h, \"ExternalStateVariables\");\n} // end of LibrariesManager::getMaterialPropertiesNames\n\n\nvoid *LibrariesManager::getSymbolAddress(const std::string &l,\n                                         const std::string &n) {\n  auto lib = this->loadLibrary(l);\n#if (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__)\n  return ::GetProcAddress(lib, n.c_str());\n#else  /* (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__)*/\n  return ::dlsym(lib, n.c_str());\n#endif /* (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__) */\n} // end of getSymbolAddress\n\nvoid *LibrariesManager::getSymbolAddress(const std::string &l,\n                                         const std::string &n1,\n                                         const std::string &n2) {\n  const auto p = this->getSymbolAddress(l, n1);\n  if (p == nullptr) {\n    return this->getSymbolAddress(l, n2);\n  }\n  return p;\n} // end of getSymbolAddress\n\nLibrariesManager::libhandler\nLibrariesManager::loadLibrary(const std::string &l) {\n  auto p = this->libraries.find(l);\n  if (p == this->libraries.end()) {\n    // this library has not been\n    auto r = try_open(l);\n    auto lib = r.first;\n    if (lib == nullptr) {\n      raise(\"LibrariesManager::loadLibrary:\"\n            \" library '\" +\n            l +\n            \"' could not be loaded, \"\n            \"(\" +\n            getErrorMessage() + \")\");\n    }\n    this->libraries.insert({l, lib});\n    return lib;\n  }\n  return p->second;\n} // end of LibrariesManager::loadLibrary\n\nLibrariesManager::~LibrariesManager() {\n  for (const auto &l : this->libraries) {\n#if (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__)\n    ::FreeLibrary(l.second);\n#else  /* (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__) */\n    ::dlclose(l.second);\n#endif /* (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__) */\n  }\n} // end of LibrariesManager::~LibrariesManager\n\n} // namespace mgis\n"
    },
    "skipped": [],
    "total_files": 113
}