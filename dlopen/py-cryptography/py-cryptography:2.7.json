{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-py-cryptography-2.7-ru7g5ht3axx2l5iwajbz4ckojcl7pejf/spack-src/tests/hazmat/backends/test_openssl_memleak.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import absolute_import, division, print_function\n\nimport json\nimport os\nimport subprocess\nimport sys\nimport textwrap\n\nimport pytest\n\nfrom cryptography.hazmat.bindings.openssl.binding import Binding\n\n\nMEMORY_LEAK_SCRIPT = \"\"\"\nimport sys\n\n\ndef main(argv):\n    import gc\n    import json\n\n    import cffi\n\n    from cryptography.hazmat.bindings._openssl import ffi, lib\n\n    heap = {}\n\n    BACKTRACE_ENABLED = False\n    if BACKTRACE_ENABLED:\n        backtrace_ffi = cffi.FFI()\n        backtrace_ffi.cdef('''\n            int backtrace(void **, int);\n            char **backtrace_symbols(void *const *, int);\n        ''')\n        backtrace_lib = backtrace_ffi.dlopen(None)\n\n        def backtrace():\n            buf = backtrace_ffi.new(\"void*[]\", 24)\n            length = backtrace_lib.backtrace(buf, len(buf))\n            return (buf, length)\n\n        def symbolize_backtrace(trace):\n            (buf, length) = trace\n            symbols = backtrace_lib.backtrace_symbols(buf, length)\n            stack = [\n                backtrace_ffi.string(symbols[i]).decode()\n                for i in range(length)\n            ]\n            lib.Cryptography_free_wrapper(symbols, backtrace_ffi.NULL, 0)\n            return stack\n    else:\n        def backtrace():\n            return None\n\n        def symbolize_backtrace(trace):\n            return None\n\n    @ffi.callback(\"void *(size_t, const char *, int)\")\n    def malloc(size, path, line):\n        ptr = lib.Cryptography_malloc_wrapper(size, path, line)\n        heap[ptr] = (size, path, line, backtrace())\n        return ptr\n\n    @ffi.callback(\"void *(void *, size_t, const char *, int)\")\n    def realloc(ptr, size, path, line):\n        if ptr != ffi.NULL:\n            del heap[ptr]\n        new_ptr = lib.Cryptography_realloc_wrapper(ptr, size, path, line)\n        heap[new_ptr] = (size, path, line, backtrace())\n        return new_ptr\n\n    @ffi.callback(\"void(void *, const char *, int)\")\n    def free(ptr, path, line):\n        if ptr != ffi.NULL:\n            del heap[ptr]\n            lib.Cryptography_free_wrapper(ptr, path, line)\n\n    result = lib.Cryptography_CRYPTO_set_mem_functions(malloc, realloc, free)\n    assert result == 1\n\n    # Trigger a bunch of initialization stuff.\n    import cryptography.hazmat.backends.openssl\n\n    start_heap = set(heap)\n\n    func(*argv[1:])\n    gc.collect()\n    gc.collect()\n    gc.collect()\n\n    if lib.Cryptography_HAS_OPENSSL_CLEANUP:\n        lib.OPENSSL_cleanup()\n\n    # Swap back to the original functions so that if OpenSSL tries to free\n    # something from its atexit handle it won't be going through a Python\n    # function, which will be deallocated when this function returns\n    result = lib.Cryptography_CRYPTO_set_mem_functions(\n        ffi.addressof(lib, \"Cryptography_malloc_wrapper\"),\n        ffi.addressof(lib, \"Cryptography_realloc_wrapper\"),\n        ffi.addressof(lib, \"Cryptography_free_wrapper\"),\n    )\n    assert result == 1\n\n    remaining = set(heap) - start_heap\n\n    if remaining:\n        sys.stdout.write(json.dumps(dict(\n            (int(ffi.cast(\"size_t\", ptr)), {\n                \"size\": heap[ptr][0],\n                \"path\": ffi.string(heap[ptr][1]).decode(),\n                \"line\": heap[ptr][2],\n                \"backtrace\": symbolize_backtrace(heap[ptr][3]),\n            })\n            for ptr in remaining\n        )))\n        sys.stdout.flush()\n        sys.exit(255)\n\nmain(sys.argv)\n\"\"\"\n\n\ndef assert_no_memory_leaks(s, argv=[]):\n    env = os.environ.copy()\n    env[\"PYTHONPATH\"] = os.pathsep.join(sys.path)\n    argv = [\n        sys.executable, \"-c\", \"{}\\n\\n{}\".format(s, MEMORY_LEAK_SCRIPT)\n    ] + argv\n    # Shell out to a fresh Python process because OpenSSL does not allow you to\n    # install new memory hooks after the first malloc/free occurs.\n    proc = subprocess.Popen(\n        argv,\n        env=env,\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n    )\n    try:\n        proc.wait()\n        if proc.returncode == 255:\n            # 255 means there was a leak, load the info about what mallocs\n            # weren't freed.\n            out = json.loads(proc.stdout.read().decode())\n            raise AssertionError(out)\n        elif proc.returncode != 0:\n            # Any exception type will do to be honest\n            raise ValueError(proc.stdout.read(), proc.stderr.read())\n    finally:\n        proc.stdout.close()\n        proc.stderr.close()\n\n\ndef skip_if_memtesting_not_supported():\n    return pytest.mark.skipif(\n        not Binding().lib.Cryptography_HAS_MEM_FUNCTIONS,\n        reason=\"Requires OpenSSL memory functions (>=1.1.0)\"\n    )\n\n\n@skip_if_memtesting_not_supported()\nclass TestAssertNoMemoryLeaks(object):\n    def test_no_leak_no_malloc(self):\n        assert_no_memory_leaks(textwrap.dedent(\"\"\"\n        def func():\n            pass\n        \"\"\"))\n\n    def test_no_leak_free(self):\n        assert_no_memory_leaks(textwrap.dedent(\"\"\"\n        def func():\n            from cryptography.hazmat.bindings.openssl.binding import Binding\n            b = Binding()\n            name = b.lib.X509_NAME_new()\n            b.lib.X509_NAME_free(name)\n        \"\"\"))\n\n    def test_no_leak_gc(self):\n        assert_no_memory_leaks(textwrap.dedent(\"\"\"\n        def func():\n            from cryptography.hazmat.bindings.openssl.binding import Binding\n            b = Binding()\n            name = b.lib.X509_NAME_new()\n            b.ffi.gc(name, b.lib.X509_NAME_free)\n        \"\"\"))\n\n    def test_leak(self):\n        with pytest.raises(AssertionError):\n            assert_no_memory_leaks(textwrap.dedent(\"\"\"\n            def func():\n                from cryptography.hazmat.bindings.openssl.binding import (\n                    Binding\n                )\n                b = Binding()\n                b.lib.X509_NAME_new()\n            \"\"\"))\n\n    def test_errors(self):\n        with pytest.raises(ValueError):\n            assert_no_memory_leaks(textwrap.dedent(\"\"\"\n            def func():\n                raise ZeroDivisionError\n            \"\"\"))\n\n\n@skip_if_memtesting_not_supported()\nclass TestOpenSSLMemoryLeaks(object):\n    @pytest.mark.parametrize(\"path\", [\n        \"x509/PKITS_data/certs/ValidcRLIssuerTest28EE.crt\",\n    ])\n    def test_der_x509_certificate_extensions(self, path):\n        assert_no_memory_leaks(textwrap.dedent(\"\"\"\n        def func(path):\n            from cryptography import x509\n            from cryptography.hazmat.backends.openssl import backend\n\n            import cryptography_vectors\n\n            with cryptography_vectors.open_vector_file(path, \"rb\") as f:\n                cert = x509.load_der_x509_certificate(\n                    f.read(), backend\n                )\n\n            cert.extensions\n        \"\"\"), [path])\n\n    @pytest.mark.parametrize(\"path\", [\n        \"x509/cryptography.io.pem\",\n    ])\n    def test_pem_x509_certificate_extensions(self, path):\n        assert_no_memory_leaks(textwrap.dedent(\"\"\"\n        def func(path):\n            from cryptography import x509\n            from cryptography.hazmat.backends.openssl import backend\n\n            import cryptography_vectors\n\n            with cryptography_vectors.open_vector_file(path, \"rb\") as f:\n                cert = x509.load_pem_x509_certificate(\n                    f.read(), backend\n                )\n\n            cert.extensions\n        \"\"\"), [path])\n\n    def test_x509_csr_extensions(self):\n        assert_no_memory_leaks(textwrap.dedent(\"\"\"\n        def func():\n            from cryptography import x509\n            from cryptography.hazmat.backends.openssl import backend\n            from cryptography.hazmat.primitives import hashes\n            from cryptography.hazmat.primitives.asymmetric import rsa\n\n            private_key = rsa.generate_private_key(\n                key_size=2048, public_exponent=65537, backend=backend\n            )\n            cert = x509.CertificateSigningRequestBuilder().subject_name(\n                x509.Name([])\n            ).add_extension(\n               x509.OCSPNoCheck(), critical=False\n            ).sign(private_key, hashes.SHA256(), backend)\n\n            cert.extensions\n        \"\"\"))\n\n    def test_ec_private_numbers_private_key(self):\n        assert_no_memory_leaks(textwrap.dedent(\"\"\"\n        def func():\n            from cryptography.hazmat.backends.openssl import backend\n            from cryptography.hazmat.primitives.asymmetric import ec\n\n            ec.EllipticCurvePrivateNumbers(\n                private_value=int(\n                    '280814107134858470598753916394807521398239633534281633982576099083'\n                    '35787109896602102090002196616273211495718603965098'\n                ),\n                public_numbers=ec.EllipticCurvePublicNumbers(\n                    curve=ec.SECP384R1(),\n                    x=int(\n                        '10036914308591746758780165503819213553101287571902957054148542'\n                        '504671046744460374996612408381962208627004841444205030'\n                    ),\n                    y=int(\n                        '17337335659928075994560513699823544906448896792102247714689323'\n                        '575406618073069185107088229463828921069465902299522926'\n                    )\n                )\n            ).private_key(backend)\n        \"\"\"))\n\n    def test_ec_derive_private_key(self):\n        assert_no_memory_leaks(textwrap.dedent(\"\"\"\n        def func():\n            from cryptography.hazmat.backends.openssl import backend\n            from cryptography.hazmat.primitives.asymmetric import ec\n            ec.derive_private_key(1, ec.SECP256R1(), backend)\n        \"\"\"))\n\n    def test_x25519_pubkey_from_private_key(self):\n        assert_no_memory_leaks(textwrap.dedent(\"\"\"\n        def func():\n            from cryptography.hazmat.primitives.asymmetric import x25519\n            private_key = x25519.X25519PrivateKey.generate()\n            private_key.public_key()\n        \"\"\"))\n\n    def test_create_ocsp_request(self):\n        assert_no_memory_leaks(textwrap.dedent(\"\"\"\n        def func():\n            from cryptography import x509\n            from cryptography.hazmat.backends.openssl import backend\n            from cryptography.hazmat.primitives import hashes\n            from cryptography.x509 import ocsp\n            import cryptography_vectors\n\n            path = \"x509/PKITS_data/certs/ValidcRLIssuerTest28EE.crt\"\n            with cryptography_vectors.open_vector_file(path, \"rb\") as f:\n                cert = x509.load_der_x509_certificate(\n                    f.read(), backend\n                )\n            builder = ocsp.OCSPRequestBuilder()\n            builder = builder.add_certificate(\n                cert, cert, hashes.SHA1()\n            ).add_extension(x509.OCSPNonce(b\"0000\"), False)\n            req = builder.build()\n        \"\"\"))\n\n    @pytest.mark.parametrize(\"path\", [\n        \"pkcs12/cert-aes256cbc-no-key.p12\",\n        \"pkcs12/cert-key-aes256cbc.p12\",\n    ])\n    def test_load_pkcs12_key_and_certificates(self, path):\n        assert_no_memory_leaks(textwrap.dedent(\"\"\"\n        def func(path):\n            from cryptography import x509\n            from cryptography.hazmat.backends.openssl import backend\n            from cryptography.hazmat.primitives.serialization import pkcs12\n            import cryptography_vectors\n\n            with cryptography_vectors.open_vector_file(path, \"rb\") as f:\n                pkcs12.load_key_and_certificates(\n                    f.read(), b\"cryptography\", backend\n                )\n        \"\"\"), [path])\n\n    def test_create_crl_with_idp(self):\n        assert_no_memory_leaks(textwrap.dedent(\"\"\"\n        def func():\n            import datetime\n            from cryptography import x509\n            from cryptography.hazmat.backends.openssl import backend\n            from cryptography.hazmat.primitives import hashes\n            from cryptography.hazmat.primitives.asymmetric import ec\n            from cryptography.x509.oid import NameOID\n\n            key = ec.generate_private_key(ec.SECP256R1(), backend)\n            last_update = datetime.datetime(2002, 1, 1, 12, 1)\n            next_update = datetime.datetime(2030, 1, 1, 12, 1)\n            idp = x509.IssuingDistributionPoint(\n                full_name=None,\n                relative_name=x509.RelativeDistinguishedName([\n                    x509.NameAttribute(\n                        oid=x509.NameOID.ORGANIZATION_NAME, value=u\"PyCA\")\n                ]),\n                only_contains_user_certs=False,\n                only_contains_ca_certs=True,\n                only_some_reasons=None,\n                indirect_crl=False,\n                only_contains_attribute_certs=False,\n            )\n            builder = x509.CertificateRevocationListBuilder().issuer_name(\n                x509.Name([\n                    x509.NameAttribute(\n                        NameOID.COMMON_NAME, u\"cryptography.io CA\"\n                    )\n                ])\n            ).last_update(\n                last_update\n            ).next_update(\n                next_update\n            ).add_extension(\n                idp, True\n            )\n\n            crl = builder.sign(key, hashes.SHA256(), backend)\n            crl.extensions.get_extension_for_class(\n                x509.IssuingDistributionPoint\n            )\n        \"\"\"))\n\n    def test_create_certificate_with_extensions(self):\n        assert_no_memory_leaks(textwrap.dedent(\"\"\"\n        def func():\n            import datetime\n\n            from cryptography import x509\n            from cryptography.hazmat.backends.openssl import backend\n            from cryptography.hazmat.primitives import hashes\n            from cryptography.hazmat.primitives.asymmetric import ec\n            from cryptography.x509.oid import (\n                AuthorityInformationAccessOID, ExtendedKeyUsageOID, NameOID\n            )\n\n            private_key = ec.generate_private_key(ec.SECP256R1(), backend)\n\n            not_valid_before = datetime.datetime.now()\n            not_valid_after = not_valid_before + datetime.timedelta(days=365)\n\n            aia = x509.AuthorityInformationAccess([\n                x509.AccessDescription(\n                    AuthorityInformationAccessOID.OCSP,\n                    x509.UniformResourceIdentifier(u\"http://ocsp.domain.com\")\n                ),\n                x509.AccessDescription(\n                    AuthorityInformationAccessOID.CA_ISSUERS,\n                    x509.UniformResourceIdentifier(u\"http://domain.com/ca.crt\")\n                )\n            ])\n            sans = [u'*.example.org', u'foobar.example.net']\n            san = x509.SubjectAlternativeName(list(map(x509.DNSName, sans)))\n\n            ski = x509.SubjectKeyIdentifier.from_public_key(\n                private_key.public_key()\n            )\n            eku = x509.ExtendedKeyUsage([\n                ExtendedKeyUsageOID.CLIENT_AUTH,\n                ExtendedKeyUsageOID.SERVER_AUTH,\n                ExtendedKeyUsageOID.CODE_SIGNING,\n            ])\n\n            builder = x509.CertificateBuilder().serial_number(\n                777\n            ).issuer_name(x509.Name([\n                x509.NameAttribute(NameOID.COUNTRY_NAME, u'US'),\n            ])).subject_name(x509.Name([\n                x509.NameAttribute(NameOID.COUNTRY_NAME, u'US'),\n            ])).public_key(\n                private_key.public_key()\n            ).add_extension(\n                aia, critical=False\n            ).not_valid_before(\n                not_valid_before\n            ).not_valid_after(\n                not_valid_after\n            )\n\n            cert = builder.sign(private_key, hashes.SHA256(), backend)\n            cert.extensions\n        \"\"\"))\n"
    },
    "skipped": [],
    "total_files": 307
}