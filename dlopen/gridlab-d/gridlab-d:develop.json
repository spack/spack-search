{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/configure.ac": "# $Id: configure.ac 4738 2014-07-03 00:55:39Z dchassin $                                            -*- Autoconf -*-\n# Copyright (C) 2008 Battelle Memorial Institute\n# Process this file with autoconf to produce a configure script.\n# This file is distributed under the same terms as GridLAB-D.\n\n###############################################################################\n# Init autoconf\n###############################################################################\n\ndnl m4 magic from Eric Blake <e...@byu.net>\ndnl autoconf 2.63 does not have m4_esyscmd_s\nm4_define([m4_chomp_all],\n[m4_format([[%.*s]], m4_bregexp(m4_translit([[$1]], [\n/], [/ ]), [/*$]), [$1])])  \n\nm4_define([m4_esyscmd_s], [m4_chomp_all(m4_esyscmd([$1]))])     \n\n\nm4_define([sbuild_m4_chomp],\n[m4_format([[%.*s]], m4_bregexp(m4_translit([$1], [\n]]m4_dquote(_m4_defn([m4_cr_all]))[, [/]]m4_format([%255s], [])[),\n  [/*$]), [$1])])\nm4_define([sbuild_m4_esyscmd_s],\n[sbuild_m4_chomp(m4_esyscmd([$1]))])\n\ndnl GridLAB-D version information\nm4_define([pkgversion], sbuild_m4_esyscmd_s([build-aux/version.sh --version]))\nm4_define([pkgbranch],  sbuild_m4_esyscmd_s([build-aux/version.sh --branch]))\nm4_define([svnversion], sbuild_m4_esyscmd_s([build-aux/version.sh --svn]))\n\nAC_PREREQ([2.63])\nAC_INIT([GridLAB-D], pkgversion, [gridlabd@pnnl.gov], [gridlabd])\nAC_CONFIG_SRCDIR([gldcore/aggregate.c])\nAC_CONFIG_HEADER([gldcore/config.h])\nAC_CONFIG_MACRO_DIR([m4])\nAC_CONFIG_AUX_DIR([build-aux])\n\n###############################################################################\n# Init automake\n###############################################################################\nAM_INIT_AUTOMAKE([foreign subdir-objects -Wall])\nm4_ifdef([AM_SILENT_RULES], [AM_SILENT_RULES])\n\n###############################################################################\n# Misc. information and package setup.\n###############################################################################\nGLD_TOP_BUILDDIR=\"`pwd`\"\ncd \"$srcdir\"\nGLD_TOP_SRCDIR=\"`pwd`\"\ncd \"$GLD_TOP_BUILDDIR\"\nAS_IF([test \"$GLD_TOP_BUILDDIR\" != \"$GLD_TOP_SRCDIR\"],\n      [AC_MSG_NOTICE([Detected VPATH build])])\n\nAC_CANONICAL_HOST\n\n# Export version info as autoconf variables\nAC_SUBST(PACKAGE_BASEVERSION, pkgversion)\nAC_SUBST(PACKAGE_BRANCH, pkgbranch)\nAC_SUBST(PACKAGE_REVISION, svnversion)\n\nAM_SILENT_RULES([yes])\n\nAC_ARG_ENABLE([debug],\n    [AS_HELP_STRING([--enable-debug],\n                    [turn on debugging @<:@default=yes@:>@])],\n    [AS_CASE([$enableval],\n        [yes], [debug=true],\n        [no],  [debug=false],\n        [AC_MSG_ERROR([bad value $enableval for --enable-debug])])],\n    [debug=true])\n\nAC_ARG_ENABLE([optimization],\n    [AS_HELP_STRING([--enable-optimization@<:@=LEVEL@:>@],\n                    [turn on optimization @<:@default=0@:>@])],\n    [AS_CASE([${enableval}],\n        [0|1|2|3|s], [optimization=${enableval}],\n        [yes],       [optimization=2],\n        [no],        [optimization=0],\n        [AC_MSG_ERROR([bad value ${enableval} for --enable-optimization])])],\n    [optimization=0])\n\n###############################################################################\n#windows-mingw specific flag runs\n###############################################################################\n\n\nis_linux=false\nis_windows=false\nis_mac=false\nmingw=false\nplatform=\"unknown\"\n\nAC_CANONICAL_HOST\ncase \"${host_os}\" in\n    *linux* )\n        is_linux=true;\n        platform=\"linux\"\n        ;;\n    *mingw*|*msys* )\n        is_windows=true\n        platform=\"windows\"\n        is_mingw=true\n        ;;\n    *cygwin* )\n    \tis_windows=true\n    \tplatform=\"windows\"\n    \t;;\n    *darwin* )\n        is_mac=true\n\t\tplatform=\"darwin\"\n        ;;\n    * )\n        AC_MSG_ERROR([\"OS $host_os is not supported\"])\n        ;;\nesac\n\n# Pass the conditionals to automake\nAM_CONDITIONAL([LINUX], [test \"$is_linux\" = \"true\"])\nAM_CONDITIONAL([WINDOWS], [test \"$is_windows\" = \"true\"])\nAM_CONDITIONAL([OSX], [test \"$is_mac\" = \"true\"])\nAM_CONDITIONAL([HAVE_MINGW], [test \"$is_mingw\" = \"true\"])\n\n###############################################################################\n# C compiler\n###############################################################################\nAC_MSG_NOTICE\nAC_MSG_NOTICE([C compiler])\nAC_MSG_NOTICE\n\nAC_PROG_CC\nAC_GNU_SOURCE   # defines _GNU_SOURCE\nAM_PROG_CC_C_O  # required for automake to support subdir-objects\n\nAS_IF([test \"x$debug\" = \"true\"], [GLD_CFLAGS=\"$GLD_CFLAGS -g\"])\nGLD_CFLAGS=\"$GLD_CFLAGS\"\n\n#--------------------------------------\n# Checks for C header files.\n#--------------------------------------\n\n#--------------------------------------\n# Checks for C typedefs, structures, and compiler characteristics.\n#--------------------------------------\nAX_PTHREAD\n# check whether -lpthread is ok when linking and add it if so\nAC_MSG_CHECKING([whether to add -lpthread to PTHREAD_LIBS])\nAS_CASE([$PTHREAD_LIBS],\n[*-lpthread*], [result=no],\n[SAVE_LIBS=\"$LIBS\"\nLIBS=\"$LIBS -lpthread\"\nAC_LINK_IFELSE(\n    [AC_LANG_PROGRAM(\n[[\n#include <pthread.h>\nstatic void routine(void *a) { a = 0; }\nstatic void *start_routine(void *a) { return a; }\nvoid function() {\n    pthread_t th;\n    pthread_attr_t attr;\n    pthread_create(&th, 0, start_routine, 0);\n    pthread_join(th, 0);\n    pthread_attr_init(&attr);\n    pthread_cleanup_push(routine, 0);\n    pthread_cleanup_pop(0);\n}\n]],\n[[function();]])],\n    [PTHREAD_LIBS=\"$PTHREAD_LIBS -lpthread\"\n     result=yes],\n    [result=no])\nLIBS=\"$SAVE_LIBS\"\n])\nAC_MSG_RESULT([$result])\n\n\n#--------------------------------------\n# Checks for C type sizes.\n#--------------------------------------\n\n#--------------------------------------\n# Checks for C library functions.\n#--------------------------------------\n\n#--------------------------------------\n# Checks for C libraries.\n#--------------------------------------\n\n# Check for curses\nAX_WITH_CURSES\nAS_IF([test \"x$ax_cv_curses\" = xyes],\n      [HAVE_CURSES=yes\n       GLD_CPPFLAGS=\"$GLD_CPPFLAGS -DHAVE_CURSES\"],\n      [HAVE_CURSES=no])\n\nAC_SUBST([GLD_CFLAGS])\n\n###############################################################################\n# C++ compiler\n###############################################################################\nAC_MSG_NOTICE\nAC_MSG_NOTICE([C++ compiler])\nAC_MSG_NOTICE\n\nAC_LANG_PUSH([C++])\n\nAC_PROG_CXX\n\nAS_IF([test \"x$debug\" = \"true\"], [GLD_CXXFLAGS=\"$GLD_CXXFLAGS -g\"])\nGLD_CXXFLAGS=\"$GLD_CXXFLAGS\"\n\n#--------------------------------------\n# Checks for C++ header files.\n#--------------------------------------\nAC_PATH_XTRA\nAC_CHECK_HEADERS([arpa/inet.h])\nAC_CHECK_HEADERS([fcntl.h])\nAC_CHECK_HEADERS([float.h])\nAC_CHECK_HEADERS([inttypes.h])\nAC_CHECK_HEADERS([limits.h])\nAC_CHECK_HEADERS([malloc.h])\nAC_CHECK_HEADERS([malloc.h])\nAC_CHECK_HEADERS([math.h])\nAC_CHECK_HEADERS([memory.h])\nAC_CHECK_HEADERS([memory.h])\nAC_CHECK_HEADERS([netdb.h])\nAC_CHECK_HEADERS([netinet/in.h])\nAC_CHECK_HEADERS([sched.h])\nAC_CHECK_HEADERS([stddef.h])\nAC_CHECK_HEADERS([stdint.h])\nAC_CHECK_HEADERS([stdint.h])\nAC_CHECK_HEADERS([stdlib.h])\nAC_CHECK_HEADERS([stdlib.h])\nAC_CHECK_HEADERS([string.h])\nAC_CHECK_HEADERS([string.h])\nAC_CHECK_HEADERS([sys/ioctl.h])\nAC_CHECK_HEADERS([sys/param.h])\nAC_CHECK_HEADERS([sys/socket.h])\nAC_CHECK_HEADERS([sys/timeb.h])\nAC_CHECK_HEADERS([sys/time.h])\nAC_CHECK_HEADERS([unistd.h])\nAC_CHECK_HEADERS([unistd.h])\nAC_CHECK_HEADERS([wchar.h])\n\n#--------------------------------------\n# Checks for C++ typedefs, structures, and compiler characteristics.\n#--------------------------------------\nAC_C_CONST\nAC_C_INLINE\nAC_C_RESTRICT\nAC_HEADER_STDBOOL\nAC_HEADER_STDC\nAC_STRUCT_TM\nAC_TYPE_INT8_T\nAC_TYPE_INT16_T\nAC_TYPE_INT32_T\nAC_TYPE_INT64_T\nAC_TYPE_MODE_T\nAC_TYPE_PID_T\nAC_TYPE_SIZE_T\nAC_TYPE_UINT16_T\nAC_TYPE_UINT32_T\nAC_TYPE_UINT64_T\n\nGLD_CHECK_BUILTIN(\n    [__sync_bool_compare_and_swap],\n    [],\n    [volatile unsigned int value = 0;\n     __sync_bool_compare_and_swap(&value, value, 1);],\n    [HAVE_SYNC_BOOL_COMPARE_AND_SWAP=yes],\n    [HAVE_SYNC_BOOL_COMPARE_AND_SWAP=no])\n\nGLD_CHECK_BUILTIN(\n    [__sync_add_and_fetch],\n    [],\n    [volatile unsigned int value = 0;\n     __sync_add_and_fetch(&value, 1);],\n    [HAVE_SYNC_ADD_AND_FETCH=yes],\n    [HAVE_SYNC_ADD_AND_FETCH=no])\n\n# AX_PTHREAD is a C-only test. We assume its flags work for CXX, as well. But\n# we need to introduce a similar PTHREAD_CXX variable.\n# More AIX lossage: compile with *_r variant\nif test \"x$GCC\" != xyes; then\n    case $host_os in\n        aix*)\n        AS_CASE([\"x/$CXX\"],\n          [x*/c89|x*/c89_128|x*/c99|x*/c99_128|x*/cc|x*/cc128|x*/xlc|x*/xlc_v6|x*/xlc128|x*/xlc128_v6],\n          [#handle absolute path differently from PATH based program lookup\n           AS_CASE([\"x$CXX\"],\n             [x/*],\n             [AS_IF([AS_EXECUTABLE_P([${CXX}_r])],[PTHREAD_CC=\"${CXX}_r\"])],\n             [AC_CHECK_PROGS([PTHREAD_CC],[${CXX}_r],[$CXX])])])\n        ;;\n    esac\nfi\ntest -n \"$PTHREAD_CXX\" || PTHREAD_CXX=\"$CXX\"\nAC_SUBST([PTHREAD_CXX])\n\n#--------------------------------------\n# Checks for C++ type sizes.\n#--------------------------------------\n\n#--------------------------------------\n# Checks for C++ library functions.\n#--------------------------------------\nAC_FUNC_ERROR_AT_LINE\nAC_FUNC_MALLOC\nAC_FUNC_MKTIME\nAC_FUNC_REALLOC\nAC_FUNC_STRFTIME\nAC_FUNC_STRTOD\nAC_FUNC_VPRINTF\nAC_CHECK_FUNCS([alarm])\nAC_CHECK_FUNCS([atexit])\nAC_CHECK_FUNCS([floor])\nAC_CHECK_FUNCS([ftime])\nAC_CHECK_FUNCS([getcwd])\nAC_CHECK_FUNCS([gethostbyname])\nAC_CHECK_FUNCS([gethrtime])\nAC_CHECK_FUNCS([gettimeofday])\nAC_CHECK_FUNCS([inet_ntoa])\nAC_CHECK_FUNCS([memset])\nAC_CHECK_FUNCS([mkdir])\nAC_CHECK_FUNCS([pow])\nAC_CHECK_FUNCS([putenv])\nAC_CHECK_FUNCS([select])\nAC_CHECK_FUNCS([setenv])\nAC_CHECK_FUNCS([socket])\nAC_CHECK_FUNCS([sqrt])\nAC_CHECK_FUNCS([strchr])\nAC_CHECK_FUNCS([strcspn])\nAC_CHECK_FUNCS([strerror])\nAC_CHECK_FUNCS([strpbrk])\nAC_CHECK_FUNCS([strrchr])\nAC_CHECK_FUNCS([strstr])\nAC_CHECK_FUNCS([strtol])\nAC_CHECK_FUNCS([tzset])\n\n#--------------------------------------\n# Checks for C++ function-like macros.\n#--------------------------------------\n\n# isfinite\nAC_CACHE_CHECK([for isfinite], [gld_cv_func_isfinite],\n    [AC_LINK_IFELSE(\n        [AC_LANG_PROGRAM(\n            [[#include <math.h>]],\n            [[int result = isfinite(1.0);]])],\n        [gld_cv_func_isfinite=yes],\n        [gld_cv_func_isfinite=no])])\nAS_IF([test \"x$gld_cv_func_isfinite\" = xyes],\n    [AC_DEFINE([HAVE_ISFINITE], [1],\n        [Define to 1 if you have the isfinite function.])])\n\n# CPU_ALLOC\nAC_CACHE_CHECK([for CPU_ALLOC], [gld_cv_func_CPU_ALLOC],\n    [AC_LINK_IFELSE(\n        [AC_LANG_PROGRAM(\n            [[#include <sched.h>]],\n            [[cpu_set_t *cpu = CPU_ALLOC(2);]])],\n        [gld_cv_func_CPU_ALLOC=yes],\n        [gld_cv_func_CPU_ALLOC=no])])\nAS_IF([test \"x$gld_cv_func_CPU_ALLOC\" = xyes],\n    [AC_DEFINE([DYN_PROC_AFFINITY],[1],\n        [\"Check for existence of dynamic proc functions\"])])\nGLD_GET_NPROCS\n\n# Check for the Linux functions for controlling processor affinity.\n# LINUX: sched_setaffinity\n# AIX:   bindprocessor\n# OSX (Leopard): thread_policy_set\nAC_CHECK_FUNCS([sched_setaffinity])\nAC_CHECK_FUNCS([sched_getaffinity])\nAC_CHECK_FUNCS([bindprocessor])\nAC_CHECK_FUNCS([thread_policy_set])\nAC_CACHE_CHECK([whether cpu_set_t available],\n    [gld_cv_have_cpu_set_t],\n    [AC_COMPILE_IFELSE(\n        [AC_LANG_PROGRAM(\n            [[#include <sched.h>]],\n            [[cpu_set_t t;]])],\n        [gld_cv_have_cpu_set_t=yes],\n        [gld_cv_have_cpu_set_t=no])])\nAS_IF([test \"$gld_cv_have_cpu_set_t\" = \"yes\"],\n    [AC_DEFINE([HAVE_CPU_SET_T], [1],\n        [Define if cpu_set_t is defined in sched.h])])\nAC_CACHE_CHECK([whether the CPU_SET and CPU_ZERO macros are defined],\n    [gld_cv_cpu_set_defined],\n    [AC_LINK_IFELSE(\n        [AC_LANG_PROGRAM(\n            [[#include <sched.h>]],\n            [[cpu_set_t t; CPU_ZERO(&t); CPU_SET(1,&t);]])],\n        [gld_cv_cpu_set_defined=yes],\n        [gld_cv_cpu_set_defined=no])])\nAS_IF([test \"$gld_cv_cpu_set_defined\" = \"yes\"],\n    [AC_DEFINE([HAVE_CPU_SET_MACROS], [1],\n        [Define if CPU_SET and CPU_ZERO defined])])\nAC_CACHE_CHECK([whether thread affinity macros defined],\n    [gld_cv_have_thread_affinity_policy],\n    [AC_COMPILE_IFELSE(\n        [AC_LANG_PROGRAM(\n            [[#include <mach/thread_policy.h>]],\n[[\n#if !defined(THREAD_AFFINITY_POLICY) || !defined(THREAD_AFFINITY_TAG_NULL)\n    :'thread macros not defined'\n#endif\n]],\n        [gld_cv_have_thread_affinity_policy=yes],\n        [gld_cv_have_thread_affinity_policy=no])])])\nAS_IF([test \"$gld_cv_have_thread_affinity_policy\" = \"yes\"],\n    [AC_DEFINE([HAVE_OSX_THREAD_AFFINITY], [1],\n        [Define is the OSX thread affinity policy macros defined])])\n\n#--------------------------------------\n# Checks for C++ libraries.\n#--------------------------------------\n\n# Check for xerces\nunset XERCES_VERSION\nAX_LIB_XERCES([2.7])\nAM_CONDITIONAL([MISSING_XERCES], [test x$HAVE_XERCES != xyes])\nAC_SUBST([HAVE_XERCES])\n\n# Check for hdf5\nunset HDF5_VERSION\nAX_LIB_HDF5([serial])\nif test \"$with_hdf5\" = \"yes\"; then\n      LDFLAGS=\"$LDFLAGS $HDF5_LDFLAGS  -lhdf5_cpp  $HDF5_LIBS\"\nfi\nAC_MSG_CHECKING([for HDF5])\nAC_MSG_RESULT([$with_hdf5])\n\n\n# Check for CppUnit\nAM_PATH_CPPUNIT([1.12], [HAVE_CPPUNIT=yes], [HAVE_CPPUNIT=no])\nAS_IF([test x\"$HAVE_CPPUNIT\" = xyes],\n    [AC_MSG_CHECKING([if compiler can link libcppunit])\n     SAVED_CXXFLAGS=\"$CXXFLAGS\"\n     SAVED_LIBS=\"$LIBS\"\n     CXXFLAGS=\"$CXXFLAGS $CPPUNIT_CFLAGS\"\n     LIBS=\"$LIBS $CPPUNIT_LIBS\"\n     AC_LINK_IFELSE(\n        [AC_LANG_PROGRAM(\n            [[#include <cppunit/extensions/TestFactoryRegistry.h>]],\n            [[CppUnit::TestFactoryRegistry::getRegistry();]])],\n        [],\n        [HAVE_CPPUNIT=no])\n     CXXFLAGS=\"$SAVED_CXXFLAGS\"\n     LIBS=\"$SAVED_LIBS\"\n     AC_MSG_RESULT([$HAVE_CPPUNIT])])\nAS_IF([test x\"$HAVE_CPPUNIT\" = xyes],\n    [# CppUnit does not separate its flags appropriately\n     COMBINED_CPPUNIT_FLAGS=\"$CPPUNIT_CFLAGS $CPPUNIT_LIBS\"\n     CPPUNIT_CFLAGS=\n     CPPUNIT_LIBS=\n     GLD_FLAG_PARSE([COMBINED_CPPUNIT_FLAGS],\n        [CPPUNIT_LIBS], [CPPUNIT_LDFLAGS], [CPPUNIT_CPPFLAGS])],\n    [GLD_CPPFLAGS=\"$GLD_CPPFLAGS -D_NO_CPPUNIT\"])\nAC_SUBST([CPPUNIT_CPPFLAGS])\nAC_SUBST([CPPUNIT_LDFLAGS])\nAC_SUBST([CPPUNIT_LIBS])\n\n# Check for Framework for Network Co-Simulation (FNCS)\nAC_ARG_WITH([fncs],\n    [AS_HELP_STRING([--with-fncs],\n                    [Link to FNCS from the given prefix (=path)  @<:@default=no@:>@])],\n    [],\n    [with_fncs=no])\nAS_CASE([$with_fncs],\n        [yes],  [],\n        [no],   [],\n                [GLD_FLAG_PARSE([with_fncs],\n                        [FNCS_LIBS],\n                        [FNCS_LDFLAGS],\n                        [FNCS_CPPFLAGS])])\ngld_save_LIBS=\"$LIBS\"; LIBS=\"$LIBS $FNCS_LIBS\"\ngld_save_LDFLAGS=\"$LDFLAGS\"; LDFLAGS=\"$LDFLAGS $FNCS_LDFLAGS\"\ngld_save_CPPFLAGS=\"$CPPFLAGS\"; CPPFLAGS=\"$CPPFLAGS $FNCS_CPPFLAGS\"\n# add libfncs to FNCS_LIBS if missing\nAS_CASE([$FNCS_LIBS],\n        [*lfncs*], [], [FNCS_LIBS=\"$FNCS_LIBS -lfncs\"])\nAS_CASE([$LIBS],\n        [*lfncs*], [], [LIBS=\"$LIBS -lfncs\"])\n# add libczmq to FNCS_LIBS if missing\nAS_CASE([$FNCS_LIBS],\n        [*lczmq*], [], [FNCS_LIBS=\"$FNCS_LIBS -lczmq\"])\nAS_CASE([$LIBS],\n        [*lczmq*], [], [LIBS=\"$LIBS -lczmq\"])\n# add libzmq to FNCS_LIBS if missing\nAS_CASE([$FNCS_LIBS],\n        [*lzmq*], [], [FNCS_LIBS=\"$FNCS_LIBS -lzmq\"])\nAS_CASE([$LIBS],\n        [*lzmq*], [], [LIBS=\"$LIBS -lzmq\"])\nhave_fncs=yes\nAC_MSG_CHECKING([for FNCS])\nAC_LINK_IFELSE(\n    [AC_LANG_PROGRAM([[\n#include<fncs.hpp>\n]],\n[[\nfncs::time t;\nfncs::initialize();\n]])],\n    [have_fncs=yes; have_fncs_int=1],\n    [have_fncs=no; have_fncs_int=0])\nLIBS=\"$gld_save_LIBS\"\nLDFLAGS=\"$gld_save_LDFLAGS\"\nCPPFLAGS=\"$gld_save_CPPFLAGS\"\nAC_SUBST([FNCS_LIBS])\nAC_SUBST([FNCS_LDFLAGS])\nAC_SUBST([FNCS_CPPFLAGS])\nAC_MSG_RESULT([$have_fncs])\nAC_DEFINE_UNQUOTED([HAVE_FNCS], [$have_fncs_int], [whether FNCS was found])\nAM_CONDITIONAL([HAVE_FNCS], [test \"x$have_fncs\" = xyes])\n\n# Check for HELICS\nAC_ARG_WITH([helics],\n    [AS_HELP_STRING([--with-helics],\n                    [Link to HELICS from the given prefix (=path)  @<:@default=no@:>@])],\n    [],\n    [with_helics=no])\nAS_CASE([$with_helics],\n        [yes],  [],\n        [no],   [],\n                [GLD_FLAG_PARSE([with_helics],\n                        [HELICS_LIBS],\n                        [HELICS_LDFLAGS],\n                        [HELICS_CPPFLAGS])])\ngld_save_LIBS=\"$LIBS\"; LIBS=\"$LIBS $HELICS_LIBS\"\ngld_save_LDFLAGS=\"$LDFLAGS\"; LDFLAGS=\"$LDFLAGS $HELICS_LDFLAGS\"\ngld_save_CPPFLAGS=\"$CPPFLAGS\"; CPPFLAGS=\"$CPPFLAGS $HELICS_CPPFLAGS\"\n# add libhelics to HELICS_LIBS if missing\nAS_CASE([$platform],\n\t[*linux*], [AS_CASE([$HELICS_LIBS],\n\t\t\t\t\t[*lhelics*], [], [HELICS_LIBS=\"$HELICS_LIBS -lhelicsSharedLib\"])\n\t\t\t\tAS_CASE([$LIBS],\n\t\t\t\t\t[*lhelics*], [], [LIBS=\"$LIBS -lhelicsSharedLib\"])],\n\t[*darwin*], [AS_CASE([$HELICS_LIBS],\n\t\t\t\t\t[*lhelics*], [], [HELICS_LIBS=\"$HELICS_LIBS -lhelicsSharedLib\"])\n\t\t\t\tAS_CASE([$LIBS],\n\t\t\t\t\t[*lhelics*], [], [LIBS=\"$LIBS -lhelicsSharedLib\"])],\n\t[*windows*], [AS_CASE([$HELICS_LIBS],\n\t\t\t\t\t[*lhelics*], [], [HELICS_LIBS=\"$HELICS_LIBS -lhelicsSharedLib\"])\n\t\t\t\tAS_CASE([$LIBS],\n\t\t\t\t\t[*lhelics*], [], [LIBS=\"$LIBS -lhelicsSharedLib\"])])\nhave_helics=yes\nAC_MSG_CHECKING([for HELICS])\nAC_LINK_IFELSE(\n\t[AC_LANG_PROGRAM([[ \n#include <helics/helics98.hpp>\n]],\n[[ \nhelicscpp::Input ipt; \n]])],\n    [have_helics=yes; have_helics_int=1],\n    [have_helics=no; have_helics_int=0])\nLIBS=\"$gld_save_LIBS\"\nLDFLAGS=\"$gld_save_LDFLAGS\"\nCPPFLAGS=\"$gld_save_CPPFLAGS\"\nAC_SUBST([HELICS_LIBS])\nAC_SUBST([HELICS_LDFLAGS])\nAC_SUBST([HELICS_CPPFLAGS])\nAC_MSG_RESULT([$have_helics])\nAC_DEFINE_UNQUOTED([HAVE_HELICS], [$have_helics_int], [whether HELICS was found])\nAM_CONDITIONAL([HAVE_HELICS], [test \"x$have_helics\" = xyes])\n\nAC_SUBST([GLD_CPPFLAGS])\n\nAC_LANG_POP([C++])\n\n###############################################################################\n# Libtool\n###############################################################################\nAC_MSG_NOTICE\nAC_MSG_NOTICE([Libtool])\nAC_MSG_NOTICE\n\nm4_ifdef([AM_PROG_AR], [AM_PROG_AR])\nLT_PREREQ([2.2])\n\ndnl override platform specific check for dependent libraries\ndnl otherwise libtool linking of shared libraries will\ndnl fail on anything other than pass_all.\nAC_CACHE_VAL(lt_cv_deplibs_check_method,\n    [lt_cv_deplibs_check_method=pass_all])\n\nLT_INIT([dlopen win32-dll shared disable-static])\nAC_SUBST([LIBTOOL_DEPS])\n\nAC_MSG_NOTICE([platform is $platform])\n\ncase \"${platform}\" in\n*linux* )\nLIBEXT=.so\n;;\n*darwin* )\nLIBEXT=.so\nGLD_CPPFLAGS=\"$GLD_CPPFLAGS -stdlib=libc++\"\n# LIBEXT=.dylib # This is the proper extension for MacOS now, but libtool does not build it properly.\n;;\n*windows* )\nLIBEXT=.dll\n;;\n* )\nLIBEXT=.so\nGLD_LDFLAGS=\"$GLD_LDFLAGS -Wl,--no-undefined\"\n;;\nesac\n\nAC_DEFINE_UNQUOTED([DLEXT], [\"$LIBEXT\"], [Dynamic library extension])\nAC_MSG_NOTICE([Dynamic Library Extension is $LIBEXT])\n\nAC_SUBST([LIBEXT])\nAC_SUBST([GLD_LDFLAGS])\nAC_SUBST([GLD_LIBS])\n\n###############################################################################\n# Checks for additional programs.\n###############################################################################\nAC_MSG_NOTICE\nAC_MSG_NOTICE([Checks for additional programs])\nAC_MSG_NOTICE\n\nAC_PROG_AWK\nAC_PROG_CPP\nAC_PROG_INSTALL\nAC_PROG_LN_S\nAC_PROG_MAKE_SET\nAC_PROG_MKDIR_P\n\nDX_INIT_DOXYGEN([gridlabd], [['$(top_srcdir)/doxygen/gridlabd.conf']])\nDX_HTML_FEATURE([ON])\nDX_CHM_FEATURE([OFF])\nDX_CHI_FEATURE([OFF])\nDX_MAN_FEATURE([OFF])\nDX_RTF_FEATURE([OFF])\nDX_XML_FEATURE([OFF])\nDX_PDF_FEATURE([OFF])\nDX_PS_FEATURE([OFF])\nAS_IF([test -n \"$DX_DOXYGEN\"],\n      [HAVE_DOXYGEN=\"$DX_DOXYGEN\"],\n      [HAVE_DOXYGEN=no])\n\n# Check for Matlab\nAC_ARG_WITH([matlab],\n\t[AS_HELP_STRING([--with-matlab],\n\t\t[Link to MATLAB from a given prefix (=path) @<:@default=no@:>@])],\n\t[],\n\t[with_matlab=no])\nMATLAB=$with_matlab\nAS_CASE([$with_matlab],\n\t[yes], [],\n\t[no], [],)\nAS_IF([test \"x$MATLAB\" != \"xno\"],\n\t[MATLAB_CPPFLAGS=\"'-I$MATLAB/extern/include'\"\n\tAS_CASE([$platform],\n\t\t[*linux*], [AS_CASE([$build_cpu],\n\t\t\t\t\t\t\t[*x86_64*], [MATLAB_LDFLAGS=\"'-L$MATLAB/bin/glnxa64' '-L$MATLAB/extern/lib/glnxa64'\"],\n\t\t\t\t\t\t\t[*i686*], [MATLAB_LDFLAGS=\"'-L$MATLAB/bin/glnx86' '-L$MATLAB/extern/lib/glnx86'\"])],\n\t\t[*darwin*], [AS_CASE([$build_cpu],\n\t\t\t\t\t\t\t[*x86_64*], [MATLAB_LDFLAGS=\"'-L$MATLAB/bin/maci64' '-L$MATLAB/extern/lib/maci64'\"],\n\t\t\t\t\t\t\t[*i686*], [MATLAB_LDFLAGS=\"'-L$MATLAB/bin/macx86' '-L$MATLAB/extern/lib/macx86'\"])],\n\t\t[*windows*], [AS_CASE([$build_cpu],\n\t\t\t\t\t\t\t[*x86_64*], [MATLAB_LDFLAGS=\"'-L$MATLAB/bin/win64' '-L$MATLAB/extern/lib/win64/microsoft'\"],\n\t\t\t\t\t\t\t[*i686*], [MATLAB_LDFLAGS=\"'-L$MATLAB/bin/win32' '-L$MATLAB/extern/lib/win32/microsoft'\"])])\n\tMATLAB_LIBS=\"-lmx -leng\"\n\tGLD_CPPFLAGS=\"$GLD_CPPFLAG -DHAVE_MATLAB\"\n\tHAVE_MATLAB=yes],\n\t[HAVE_MATLAB=no])\nAC_SUBST([MATLAB_CPPFLAGS])\nAC_SUBST([MATLAB_LDFLAGS])\nAC_SUBST([MATLAB_LDPATH])\nAC_SUBST([MATLAB_LIBS])\n\t\n# Check for MinGW\nAS_IF([test \"x$is_mingw\" = \"xtrue\"],\n\t[HAS_MINGW=yes],\n\t[AS_CASE([$platform],\n\t\t[*linux*], [HAS_MINGW=no],\n\t\t[*darwin*], [HAS_MINGW=no],\n\t\t[*windows*], [HAS_MINGW=\"no (required)\"])])\nAC_SUBST([HAS_MINGW])\t\t\n\n# Check for mysql\n\nAC_ARG_WITH([mysql],\n\t[AS_HELP_STRING([--with-mysql],\n\t\t[Link to MySQL from a given prefix (=path)])],\n\t[],\n\t[with_mysql=no])\nMYSQL=$with_mysql\nAS_IF([test \"x$MYSQL\" != \"xno\"],\n\t[MYSQL_CPPFLAGS=\"'-I$MYSQL/include'\"\n\t\tAS_CASE([$platform],\n\t\t\t[*windows*], [MYSQL_LDFLAGS=\"'-L$MYSQL/lib'\"\n\t\t\t\tMYSQL_LIBS=\"-lmysql\"],\n\t\t\t[*linux*], [MYSQL_LDFLAGS=\"'-L$MYSQL/lib'\"\n\t\t\t\tMYSQL_LIBS=\"-lmysqlclient\"],\n\t\t\t[*darwin*], [MYSQL_LDFLAGS=\"'-L$MYSQL/lib'\"\n\t\t\t\tMYSQL_LIBS=\"-lmysqlclient\"])\n\t\tGLD_CPPFLAGS=\"$GLD_CPPFLAGS -DHAVE_MYSQL\"\n\t\tHAVE_MYSQL=yes],\n\t[HAVE_MYSQL=no])\n\t\nAC_MSG_RESULT([Is single-location MySQL configured: $HAVE_MYSQL])\n\n\t\nAC_ARG_WITH([rhel-mysql-libs],\n\t[AS_HELP_STRING[--with-rhel-mysql-libs],\n\t[Link to MySQL libs on RHEL from a given prefix (=path)])],\n\t[],\n\t[with_rhel_mysql_libs=no])\n\nAC_ARG_WITH([rhel-mysql-headers],\n\t[AS_HELP_STRING([--with-rhel-mysql-headers],\n\t\t[Link to MySQL headers on RHEL from a given prefix (=path)])],\n\t[],\n\t[with_rhel_mysql_headers=no])\n\t\nAC_MSG_RESULT([Is RHEL MySQL Libs configured: $with_rhel_mysql_libs])\nAC_MSG_RESULT([Is RHEL MySQL Headers configured: $with_rhel_mysql_headers])\n\n\t\nAS_IF([test \"x$HAVE_MYSQL\" != \"xyes\" && \n       test \"x$with_rhel_mysql_libs\" != \"xno\" && \n\t   test \"x$with_rhel_mysql_headers\" != \"xno\"],\n\t\t\t[MYSQL_CPPFLAGS=\"'-I$with_rhel_mysql_headers'\"\n\t \t\tMYSQL_LDFLAGS=\"'-L$with_rhel_mysql_libs'\"\n\t\t\tMYSQL_LIBS=\"-lmysqlclient\"\n\t\t\tGLD_CPPFLAGS=\"$GLD_CPPFLAGS -DHAVE_MYSQL\"\n\t\t\tHAVE_MYSQL=yes]\n\t,[HAVE_MYSQL=$HAVE_MYSQL]) \n\t\n#AC_MSG_RESULT([Is MySQL configured: $HAVE_MYSQL])\n#AC_MSG_RESULT([MySQL_CPPFLAGS: $MYSQL_CPPFLAGS])\n#AC_MSG_RESULT([MYSQL_LDFLAGS: $MYSQL_LDFLAGS])\n#AC_MSG_RESULT([MYSQL_LIBS: $MYSQL_LIBS])\n#AC_MSG_RESULT([GLD_CPPFLAGS: $GLD_CPPFLAGS])\n\n\nAC_SUBST([MYSQL_CPPFLAGS])\nAC_SUBST([MYSQL_LDFLAGS])\nAC_SUBST([MYSQL_LIBS])\n\n###############################################################################\n# The End\n###############################################################################\n\nAC_CONFIG_FILES([Makefile])\nAC_CONFIG_FILES([gridlabd.spec])\nAC_CONFIG_FILES([gldcore/gridlabd.sh], [chmod +x gldcore/gridlabd.sh])\nAC_OUTPUT\n\nBINVAR=(`eval echo $bindir`)\nBINDIR=(`eval echo ${BINVAR}`)\n\nLIBVAR=(`eval echo $libdir`)\nLIBDIR=(`eval echo ${LIBVAR}`)\n\nDOCVAR=(`eval echo $docdir`)\nDOCDIR=(`eval echo ${DOCVAR}`)\n\nAS_IF([test \"x$HAVE_XERCES\" = xyes],\n    [CONFIG_RESULT=OK\n     AS_IF([test -z \"$XERCES_VERSION\" || expr \"$XERCES_VERSION\" \\< 3 >/dev/null],\n        [AC_MSG_WARN([libxerces-c version $XERCES_VERSION])\n         AC_MSG_WARN([may not be suitable for building $PACKAGE])])],\n    [CONFIG_RESULT=failed\n     HAVE_XERCES=\"$HAVE_XERCES (required)\"\n     AC_MSG_WARN([missing libxerces-c; build will fail until dependency is met])])\n\nAC_MSG_RESULT([\n-----------------------------------------------------------------------\n\n  $PACKAGE $VERSION: Automatic configuration $CONFIG_RESULT.\n\n  Dependencies:\n\n    MinGW/MSYS: ................. $HAS_MINGW\n    Doxygen: .................... $HAVE_DOXYGEN\n    hdf5: ....................... $with_hdf5\n    libcppunit: ................. $HAVE_CPPUNIT\n    libxerces-c: ................ $HAVE_XERCES\n    matlab: ..................... $HAVE_MATLAB\n    mysql-connector-c: .......... $HAVE_MYSQL\n    curses: ..................... $HAVE_CURSES\n    FNCS: ....................... $have_fncs\n    HELICS: ..................... $have_helics\n\n  Atomic Builtins:\n\n    __sync_bool_compare_and_swap: $HAVE_SYNC_BOOL_COMPARE_AND_SWAP\n    __sync_add_and_fetch: ....... $HAVE_SYNC_ADD_AND_FETCH\n\n  Installation paths:\n\n    Scripts: .................... $BINDIR\n    Libraries: .................. $LIBDIR/$PACKAGE\n    Documentation: .............. $DOCDIR\n\n  Building:\n\n    type 'make' to compile $PACKAGE.\n    type 'make install' to install $PACKAGE in $prefix.\n\n-----------------------------------------------------------------------\n])\n",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/gldcore/gridlabd.h": "/** $Id: gridlabd.h 4738 2014-07-03 00:55:39Z dchassin $\n\tCopyright (C) 2008 Battelle Memorial Institute\n\t@file gridlabd.h\n\t@author David P. Chassin\n\t@addtogroup module_api C/C++ Module API\n\t@brief The GridLAB-D external C module header file\n\n\tThe runtime module API links the GridLAB-D core to modules that are created to\n\tperform various modeling tasks.  The core interacts with each module according\n\tto a set script that determines which exposed module functions are called and\n\twhen.  The general sequence of calls is as follows:\n\t- <b>Registration</b>: A module registers the object classes it implements and\n\tregisters the variables that each class publishes.\n\t- <b>Creation</b>: The core calls object creation functions during the model\n\tload operation for each object that is created.  Basic initialization can be\n\tcompleted at this point.\n\t- <b>Definition</b>: The core sets the values of all published variables that have\n\tbeen specified in the model being loaded.  After this is completed, all references\n\tto other objects have been resolved.\n\t- <b>Validation</b>: The core gives the module an opportunity to check the model\n\tbefore initialization begins.  This gives the module an opportunity to validate\n\tthe model and reject it or fix it if it fails to meet module-defined criteria.\n\t- <b>Initialization</b>: The core calls the final initialization procedure with\n\tthe object's full context now defined.  Properties that are derived based on the\n\tobject's context should be initialized only at this point.\n\t- <b>Synchronization</b>: This operation is performed repeatedly until every object\n\treports that it no longer expects any state changes.  The return value from a\n\tsynchronization operation is the amount time expected to elapse before the object's\n\tnext state change.  The side effect of a synchronization is a change to one or\n\tmore properties of the object, and possible an update to the property of another\n\tobject.\n\n\tNote that object destruction is not supported at this time.\n\n\t GridLAB-D modules usually require a number of functions to access data and interaction\n\t with the core.  These include\n\t - memory locking,\n\t - memory exception handlers,\n\t - variable publishers,\n\t - output functions,\n\t - management routines,\n\t - module management,\n\t - class registration,\n\t - object management,\n\t - property management,\n\t - object search,\n\t - random number generators, and\n\t - time management.\n @{\n **/\n\n#ifndef _GRIDLABD_H\n#define _GRIDLABD_H\n\n/* permanently disable use of CPPUNIT */\n#ifndef _NO_CPPUNIT\n#define _NO_CPPUNIT\n#endif\n\n// module version info (must match core version info)\n#define MAJOR 4\n#define MINOR 3\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#ifdef _WIN32\n#define HAVE_LIBCPPUNIT\n#endif\n\n#ifdef __cplusplus\n\t#ifndef CDECL\n\t\t/** Defines a function as a C-type function **/\n\t\t#define CDECL extern \"C\"\n\t#endif\n#else\n\t#define CDECL\n#endif\n\n#ifdef _WIN32\n#ifndef EXPORT\n/** Defines a function as exported to core **/\n#define EXPORT CDECL __declspec(dllexport)\n#endif\n#else\n#define EXPORT CDECL\n#endif\n\n#include <stdarg.h>\n#include \"platform.h\"\n#include \"schedule.h\"\n#include \"transform.h\"\n#include \"object.h\"\n#include \"find.h\"\n#include \"gldrandom.h\"\n#define STREAM_MODULE\n#include \"stream.h\"\n#pragma GCC diagnostic ignored \"-Wwrite-strings\"\n\n\n#ifdef DLMAIN\n#define EXTERN\n#define INIT(X) =(X)\n#else\n#ifdef __cplusplus\n#define EXTERN\n#else\n#define EXTERN extern\n#endif /* __cplusplus */\n#define INIT(X)\n#endif\nCDECL EXTERN CALLBACKS *callback INIT(NULL);\n#undef INIT\n#undef EXTERN\n\n#ifndef MODULENAME\n#define MODULENAME(obj) (obj->oclass->module->name)\n#endif\n\n/******************************************************************************\n * Access information about version of core\n */\n#define gl_version_major (*callback->version.major)\n#define gl_version_minor (*callback->version.minor)\n#define gl_version_patch (*callback->version.patch)\n#define gl_version_build (*callback->version.build)\n#define gl_version_branch (*callback->version.branch)\n\n/******************************************************************************\n * Variable publishing\n */\n/**\t@defgroup gridlabd_h_publishing Publishing variables\n\n\tModules must register public variables that are accessed by other modules, and the core by publishing them.\n\n\tThe typical modules will register a class, and immediately publish the variables supported by the class:\n\t@code\n\n\tEXPORT CLASS *init(CALLBACKS *fntable, MODULE *module, int argc, char *argv[])\n\t{\n\t\textern CLASS* node_class; // defined globally in the module\n\t\tif (set_callback(fntable)==NULL)\n\t\t{\n\t\t\terrno = EINVAL;\n\t\t\treturn NULL;\n\t\t}\n\n\t\tnode_class = gl_register_class(module,\"node\",sizeof(node),PC_BOTTOMUP);\n\t\tPUBLISH_CLASS(node,complex,V);\n\t\tPUBLISH_CLASS(node,complex,S);\n\n\t\treturn node_class; // always return the *first* class registered\n\t}\n\t@endcode\n\n\t@{\n **/\n/** The PUBLISH_STRUCT macro is used to publish a member of a structure.\n **/\n#define PUBLISH_STRUCT(C,T,N) {struct C *_t=NULL;if (gl_publish_variable(C##_class,PT_##T,#N,(char*)&(_t->N)-(char*)_t,NULL)<1) return NULL;}\n/** The PUBLISH_CLASS macro is used to publish a member of a class (C++ only).\n **/\n#define PUBLISH_CLASS(C,T,N) {class C *_t=NULL;if (gl_publish_variable(C##_class,PT_##T,#N,(char*)&(_t->N)-(char*)_t,NULL)<1) return NULL;}\n/** The PUBLISH_CLASSX macro is used to publish a member of a class (C++ only) using a different name from the member name.\n **/\n#define PUBLISH_CLASSX(C,T,N,V) {class C *_t=NULL;if (gl_publish_variable(C##_class,PT_##T,V,(char*)&(_t->N)-(char*)_t,NULL)<1) return NULL;}\n\n/** The PUBLISH_CLASS_UNT macros is used to publish a member of a class (C++ only) including a unit specification.\n**/\n//#define PUBLISH_CLASS_UNIT(C,T,N,U) {class C _t;if (gl_publish_variable(C##_class,PT_##T,#N\"[\"U\"]\",(char*)&_t.N-(char*)&_t,NULL)<1) return NULL;}\n/** The PUBLISH_DELEGATED macro is used to publish a variable that uses a delegated type.\n\n**/\n#define PUBLISH_DELEGATED(C,T,N) {class C *_t=NULL;if (gl_publish_variable(C##_class,PT_delegated,T,#N,(char*)&(_t->N)-(char*)_t,NULL)<1) return NULL;}\n\n/** The PUBLISH_ENUM(C,N,E) macro is used to define a keyword for an enumeration variable\n **/\n//#define PUBLISH_ENUM(C,N,E) (*callback->define_enumeration_member)(C##_class,#N,#E,C::E)\n\n/** The PUBLISH_SET(C,N,E) macro is used to define a keyword for a set variable\n **/\n//#define PUBLISH_SET(C,N,E) (*callback->define_set_member)(C##_class,#N,#E,C::E)\n/** @} **/\n\n#define PADDR(X) ((char*)&(this->X)-(char*)this)\n\n/******************************************************************************\n * Exception handling\n */\n/**\t@defgroup gridlabd_h_exception Exception handling\n\n\tModule exception handling is provided for modules implemented in C to perform exception handling,\n\tas well to allow C++ code to throw exceptions to the core's main exception handler.\n\n\tTypical use is like this:\n\n\t@code\n\t#include <errno.h>\n\t#include <string.h>\n\tGL_TRY {\n\n\t\t// block of code\n\n\t\t// exception\n\t\tif (errno!=0)\n\t\t\tGL_THROW(\"Error condition %d: %s\", errno, strerror(errno));\n\n\t\t// more code\n\n\t} GL_CATCH(char *msg) {\n\n\t\t// exception handler\n\n\t} GL_ENDCATCH;\n\t@endcode\n\n\tNote: it is ok to use GL_THROW inside a C++ catch statement.  This behavior is defined\n\t(unlike using C++ throw inside C++ catch) because GL_THROW is implemented using longjmp().\n\n\tSee \\ref exception \"Exception handling\" for detail on the message format conventions.\n\n\t@{\n **/\n/** You may create your own #GL_TRY block and throw exception using GL_THROW(Msg,...) within\n\tthe block.  Declaring this block will change the behavior of GL_THROW(Msg,...) only\n\twithin the block.  Calls to GL_THROW(Msg,...) within this try block will be transfer\n\tcontrol to the GL_CATCH(Msg) block.\n **/\n#define GL_TRY { EXCEPTIONHANDLER *_handler = (*callback->exception.create_exception_handler)(); if (_handler==NULL) (*callback->output_error)(\"%s(%d): module exception handler creation failed\",__FILE__,__LINE__); else if (setjmp(_handler->buf)==0) {\n/* TROUBLESHOOT\n\tThis error is caused when the system is unable to implement an exception handler for a module.\n\tThis is an internal error and should be reported to the module developer.\n */\n/** The behavior of GL_THROW(Msg,...) differs depending on the situation:\n\t- Inside a #GL_TRY block, program flow is transfered to the GL_CATCH(Msg) block that follows.\n\t- Inside a GL_CATCH(Msg) block, GL_THROW(Msg,...) behavior is undefined (read \\em bad).\n\t- Outside a #GL_TRY or GL_CATCH(Msg) block, control is transfered to the main core exception handler.\n **/\n#ifdef __cplusplus\ninline void GL_THROW(char *format, ...)\n{\n\tstatic char buffer[1024];\n\tva_list ptr;\n\tva_start(ptr,format);\n\tvsprintf(buffer,format,ptr);\n\tva_end(ptr);\n\tthrow (const char*) buffer;\n}\n#else\n#define GL_THROW (*callback->exception.throw_exception)\n/** The argument \\p msg provides access to the exception message thrown.\n\tOtherwise, GL_CATCH(Msg) blocks function like all other code blocks.\n\n\tThe behavior of GL_THROW(Msg) is not defined inside GL_CATCH(Msg) blocks.\n\n\tGL_CATCH blocks must always be terminated by a #GL_ENDCATCH statement.\n **/\n#endif\n#define GL_CATCH(Msg) } else {Msg = (*callback->exception.exception_msg)();\n/** GL_CATCH(Msg) blocks must always be terminated by a #GL_ENDCATCH statement.\n **/\n#define GL_ENDCATCH } (*callback->exception.delete_exception_handler)(_handler);}\n/** @} **/\n\n/******************************************************************************\n * Output functions\n */\n/**\t@defgroup gridlabd_h_output Output functions\n\n\tModule may output messages to stdout, stderr, and the core test record file\n\tusing the output functions.\n\n\tSee \\ref output \"Output function\" for details on message format conventions.\n\t@{\n **/\n\n#define gl_verbose (*callback->output_verbose)\n\n/** Produces a message on stdout.\n\t@see output_message(char *format, ...)\n **/\n#define gl_output (*callback->output_message)\n\n/** Produces a warning message on stderr, but only when \\b --warning is provided on the command line.\n\t@see output_warning(char *format, ...)\n **/\n#define gl_warning (*callback->output_warning)\n\n/** Produces an error message on stderr, but only when \\b --quiet is not provided on the command line.\n \t@see output_error(char *format, ...)\n**/\n#define gl_error (*callback->output_error)\n\n/** Produces a debug message on stderr, but only when \\b --debug is provided on the command line.\n \t@see output_debug(char *format, ...)\n **/\n#define gl_debug (*callback->output_debug)\n\n/** Produces a test message in the test record file, but only when \\b --testfile is provided on the command line.\n\t@see output_testmsg(char *format, ...)\n **/\n#define gl_testmsg (*callback->output_test)\n/** @} **/\n\n/******************************************************************************\n * Memory allocation\n */\n/**\t@defgroup gridlabd_h_memory Memory allocation functions\n\n\tThe core is responsible for managing any memory that is shared.  Use these\n\tmacros to manage the allocation of objects that are registered classes.\n\n\t@{\n **/\n/** Allocate a block of memory from the core's heap.\n\tThis is necessary for any memory that the core will have to manage.\n\t@see malloc()\n **/\n#define gl_malloc (*callback->malloc)\n/** @} **/\n\n/******************************************************************************\n * Core access\n */\n/**\t@defgroup gridlabd_h_corelib Core access functions\n\n\tMost module function use core library functions and variables.\n\tUse these macros to access the core library and other global module variables.\n\n\t@{\n **/\n/** Defines the callback table for the module.\n\tCallback function provide module with direct access to important core functions.\n\t@see struct s_callback\n **/\n#define set_callback(CT) (callback=(CT))\n\n/** Provides access to a global module variable.\n\t@see global_getvar(), global_setvar()\n **/\n#define gl_get_module_var (*callback->module.getvar)\n\n/** Provide file search function\n\t@see find_file()\n **/\n#define gl_findfile (*callback->file.find_file)\n\n#define gl_find_module (*callback->module_find)\n\n#define gl_find_property (*callback->find_property)\n\n/** Declare a module dependency.  This will automatically load\n    the module if it is not already loaded.\n\t@return 1 on success, 0 on failure\n **/\n#ifdef __cplusplus\ninline int gl_module_depends(char *name, /**< module name */\n\t\t\t\t\t\t\t unsigned char major=0, /**< major version, if any required (module must match exactly) */\n\t\t\t\t\t\t\t unsigned char minor=0, /**< minor version, if any required (module must be greater or equal) */\n\t\t\t\t\t\t\t unsigned short build=0) /**< build number, if any required (module must be greater or equal) */\n{\n\treturn (*callback->module.depends)(name,major,minor,build);\n}\n#else\n#define gl_module_getfirst (*callback->module.getfirst)\n#define gl_module_depends (*callback->module.depends)\n#endif\n\n\n/** @} **/\n\n/******************************************************************************\n * Class registration\n */\n/**\t@defgroup gridlabd_h_class Class registration\n\n\tClass registration is used to make sure the core knows how objects are implemented\n\tin modules.  Use the class management macros to create and destroy classes.\n\n\t@{\n **/\n/** Allow an object class to be registered with the core.\n\tNote that C file may publish structures, even they are not implemented as classes.\n\t@see class_register()\n **/\n#define gl_register_class (*callback->register_class)\n#define gl_class_get_first (*callback->class_getfirst)\n#define gl_class_get_by_name (*callback->class_getname)\n/** @} **/\n\n/******************************************************************************\n * Object management\n */\n/**\t@defgroup gridlabd_h_object Object management\n\n\tObject management macros are create to allow modules to create, test,\n\tcontrol ranks, and reveal members of objects and registered classes.\n\n\t@{\n **/\n/** Creates an object by allocating on from core heap.\n\t@see object_create_single()\n */\n#define gl_create_object (*callback->create.single)\n\n/** Creates an array of objects on core heap.\n\t@see object_create_array()\n **/\n#define gl_create_array (*callback->create.array)\n\n/** Creates an array of objects on core heap.\n\t@see object_create_array()\n **/\n#define gl_create_foreign (*callback->create.foreign)\n\n/** Object type test\n\n\tChecks the type (and supertypes) of an object.\n\n\t@see object_isa()\n **/\n#ifdef __cplusplus\ninline bool gl_object_isa(OBJECT *obj, /**< object to test */\n\t\t\t\t\t\t  char *type,\n\t\t\t\t\t\t  char *modname=NULL) /**< type to test */\n{\tbool rv = (*callback->object_isa)(obj,type)!=0;\n\tbool mv = modname ? obj->oclass->module == (*callback->module_find)(modname) : true;\n\treturn (rv && mv);}\n#else\n#define gl_object_isa (*callback->object_isa)\n#endif\n\n/** Declare an object property as publicly accessible.\n\t@see object_define_map()\n **/\n#define gl_publish_variable (*callback->define_map)\n\n#define gl_publish_loadmethod (*callback->loadmethod)\n\n/** Publishes an object function.  This is currently unused.\n\t@see object_define_function()\n **/\n#ifdef __cplusplus\ninline FUNCTION *gl_publish_function(CLASS *oclass, /**< class to which function belongs */\n\t\t\t\t\t\t\t\t\t FUNCTIONNAME functionname, /**< name of function */\n\t\t\t\t\t\t\t\t\t FUNCTIONADDR call) /**< address of function entry */\n{ return (*callback->function.define)(oclass, functionname, call);}\ninline FUNCTIONADDR gl_get_function(OBJECT *obj, char *name)\n{ return obj?(*callback->function.get)(obj->oclass->name,name):NULL;}\n#else\n#define gl_publish_function (*callback->function.define)\n#define gl_get_function (*callback->function.get)\n#endif\n\n/** Changes the dependency rank of an object.\n\tNormally dependency rank is determined by the object parent,\n\tbut an object's rank may be increased using this call.\n\tAn object's rank may not be decreased.\n\t@see object_set_rank(), object_set_parent()\n **/\n#ifdef __cplusplus\ninline int gl_set_dependent(OBJECT *obj, /**< object to set dependency */\n\t\t\t\t\t\t\tOBJECT *dep) /**< object dependent on */\n{ return (*callback->object.set_dependent)(obj,dep);}\n#else\n#define gl_set_dependent (*callback->object.set_dependent)\n#endif\n\n/** Establishes the rank of an object relative to another object (it's parent).\n\tWhen an object is parent to another object, it's rank is always greater.\n\tObject of higher rank are processed first on top-down passes,\n\tand later on bottom-up passes.\n\tObjects of the same rank may be processed in parallel,\n\tif system resources make it possible.\n\t@see object_set_rank(), object_set_parent()\n **/\n#ifdef __cplusplus\ninline int gl_set_parent(OBJECT *obj, /**< object to set parent of */\n\t\t\t\t\t\t OBJECT *parent) /**< parent object */\n{ return (*callback->object.set_parent)(obj,parent);}\n#else\n#define gl_set_parent (*callback->object.set_parent)\n#endif\n\n/** Adjusts the rank of an object relative to another object (it's parent).\n\tWhen an object is parent to another object, it's rank is always greater.\n\tObject of higher rank are processed first on top-down passes,\n\tand later on bottom-up passes.\n\tObjects of the same rank may be processed in parallel,\n\tif system resources make it possible.\n\t@see object_set_rank(), object_set_parent()\n **/\n#ifdef __cplusplus\ninline int gl_set_rank(OBJECT *obj, /**< object to change rank */\n\t\t\t\t\t   int rank)\t/**< new rank of object */\n{ return (*callback->object.set_rank)(obj,rank);}\n#else\n#define gl_set_rank (*callback->object.set_rank)\n#endif\n\n#define gl_object_get_first (*callback->object.get_first)\n#define gl_object_find_by_id (*callback->object_find_by_id)\n/** @} **/\n\n/******************************************************************************\n * Property management\n */\n/**\t@defgroup gridlabd_h_property Property management\n\n\tUse the property management functions to provide and gain access to published\n\tvariables from other modules.  This include getting property information\n\tand unit conversion.\n\n\t@{\n **/\n/** Create an object\n\t@see class_register()\n **/\n#define gl_register_type (*callback->register_type)\n#define gl_class_add_extended_property (*callback->class_add_extended_property)\n\n/** Publish an delegate property type for a class\n\t@note This is not supported in Version 1.\n **/\n#define gl_publish_delegate (*callback->define_type)\n\n/** Get a property of an object\n\t@see object_get_property()\n **/\n#ifdef __cplusplus\ninline PROPERTY *gl_get_property(OBJECT *obj, /**< a pointer to the object */\n\t\t\t\t\t\t\t\t PROPERTYNAME name, /**< the name of the property */\n\t\t\t\t\t\t\t\t PROPERTYSTRUCT *part=NULL) /**< part info */\n{ return (*callback->properties.get_property)(obj,name,part); }\n#else\n#define gl_get_property (*callback->properties.get_property)\n#endif\n\n/** Get the value of a property in an object\n\t@see object_get_value_by_addr()\n **/\n#ifdef __cplusplus\ninline int gl_get_value(OBJECT *obj, /**< the object from which to get the data */\n\t\t\t\t\t\tvoid *addr, /**< the addr of the data to get */\n\t\t\t\t\t\tchar *value, /**< the buffer to which to write the result */\n\t\t\t\t\t\tint size, /**< the size of the buffer */\n\t\t\t\t\t\tPROPERTY *prop=NULL) /**< the property to use or NULL if unknown */\n{ return (*callback->properties.get_value_by_addr)(obj,addr,value,size,prop);}\n#else\n#define gl_get_value (*callback->properties.get_value_by_addr)\n#endif\n#define gl_set_value_by_type (*callback->properties.set_value_by_type)\n\n/** Set the value of a property in an object\n\t@see object_set_value_by_addr()\n **/\n#ifdef __cplusplus\ninline int gl_set_value(OBJECT *obj, /**< the object to alter */\n\t\t\t\t\t\tvoid *addr, /**< the address of the property */\n\t\t\t\t\t\tchar *value, /**< the value to set */\n\t\t\t\t\t\tPROPERTY *prop) /**< the property to use or NULL if unknown */\n{ return (*callback->properties.set_value_by_addr)(obj,addr,value,prop);}\n#else\n#define gl_set_value (*callback->properties.set_value_by_addr)\n#endif\n\nchar* gl_name(OBJECT *my, char *buffer, size_t size);\n#ifdef __cplusplus\n/* 'stolen' from rt/gridlabd.h, something dchassin squirreled in. -mhauer */\n/// Set the typed value of a property\n/// @return nothing\ntemplate <class T> inline int gl_set_value(OBJECT *obj, ///< the object whose property value is being obtained\n\t\t\t\t\t\t\t\t\t\t\tPROPERTY *prop, ///< the name of the property being obtained\n\t\t\t\t\t\t\t\t\t\t\tT &value) ///< a reference to the local value where the property's value is being copied\n{\n\t//T *ptr = (T*)gl_get_addr(obj,propname);\n\tchar buffer[256];\n\tT *ptr = (T *)((char *)(obj + 1) + (int64)(prop->addr)); /* warning: cast from pointer to integer of different size */\n\t// @todo it would be a good idea to check the property type here\n\tif (ptr==NULL)\n\t\tGL_THROW(\"property %s not found in object %s\", prop->name, gl_name(obj, buffer, 255));\n\tif(obj->oclass->notify){\n\t\tif(obj->oclass->notify(obj,NM_PREUPDATE,prop) == 0){\n\t\t\tgl_error(\"preupdate notify failure on %s in %s\", prop->name, obj->name ? obj->name : \"an unnamed object\");\n\t\t}\n\t}\n\t*ptr = value;\n\tif(obj->oclass->notify){\n\t\tif(obj->oclass->notify(obj,NM_POSTUPDATE,prop) == 0){\n\t\t\tgl_error(\"postupdate notify failure on %s in %s\", prop->name, obj->name ? obj->name : \"an unnamed object\");\n\t\t}\n\t}\n\treturn 1;\n}\n#endif\n\n/** Get a reference to another object\n\t@see object_get_reference()\n **/\n#define gl_get_reference (*callback->properties.get_reference)\n\n/** Get the value of a property in an object\n\t@see object_get_value_by_name()\n **/\n#ifdef __cplusplus\ninline int gl_get_value_by_name(OBJECT *obj,\n\t\t\t\t\t\t\t\tPROPERTYNAME name,\n\t\t\t\t\t\t\t\tchar *value,\n\t\t\t\t\t\t\t\tint size)\n{ return (*callback->properties.get_value_by_name)(obj,name,value,size);}\n#else\n#define gl_get_value_by_name (*callback->properties.get_value_by_name)\n#endif\n\n#ifdef __cplusplus\ninline char *gl_getvalue(OBJECT *obj,\n\t\t\t\t\t\t PROPERTYNAME name, char *buffer, int sz)\n{\n\treturn gl_get_value_by_name(obj,name,buffer,sz)>=0 ? buffer : NULL;\n}\n#endif\n\n/** Set the value of a property in an object\n\t@see object_set_value_by_name()\n **/\n#define gl_set_value_by_name (*callback->properties.set_value_by_name)\n\n/** Get unit of property\n\t@see object_get_unit()\n **/\n#define gl_get_unit (*callback->properties.get_unit)\n\n/** Convert the units of a property using unit name\n\t@see unit_convert()\n **/\n#define gl_convert (*callback->unit_convert)\n\n/** Convert the units of a property using unit data\n\t@see unit_convert_ex()\n **/\n#define gl_convert_ex (*callback->unit_convert_ex)\n\n#define gl_find_unit (*callback->unit_find)\n\n#define gl_get_object (*callback->get_object)\n\n#define gl_name_object (*callback->name_object)\n\n#define gl_get_object_count (*callback->object_count)\n\n#ifdef __cplusplus\ninline OBJECT **gl_get_object_prop(OBJECT *obj, PROPERTY *prop){\n    return (*callback->objvar.object_var)(obj, prop);\n}\n#else\n#define gl_get_object_prop (*callback->objvar.object_var)\n#endif\n\n#ifdef __cplusplus\ninline bool *gl_get_bool(OBJECT *obj, /**< object to set dependency */\n\t\t\t\t\t\t\tPROPERTY *prop) /**< object dependent on */\n{\n    return (*callback->objvar.bool_var)(obj,prop);\n}\n#else\n#define gl_get_bool (*callback->objvar.bool_var)\n#endif\n\n#ifdef __cplusplus\ninline bool *gl_get_bool(OBJECT *obj, /**< object to set dependency */\n\t\t\t\t\t\t\tchar *propname) /**< object dependent on */\n{\n    return (*callback->objvarname.bool_var)(obj,propname);\n}\n#else\n#define gl_get_bool_by_name (*callback->objvarname.bool_var)\n#endif\n\n/** Retrieve the complex value associated with the property\n\t@see object_get_complex()\n**/\n#define gl_get_complex (*callback->objvar.complex_var)\n\n#define gl_get_complex_by_name (*callback->objvarname.complex_var)\n\n#define gl_get_enum (*callback->objvar.enum_var)\n\n#define gl_get_enum_by_name (*callback->objvarname.enum_var)\n\n#define gl_get_set (*callback->objvar.set_var)\n\n#define gl_get_set_by_name (*callback->objvarname.set_var)\n\n#define gl_get_int16 (*callback->objvar.int16_var)\n\n#define gl_get_int16_by_name (*callback->objvarname.int16_var)\n\n#define gl_get_int32_by_name (*callback->objvarname.int32_var)\n\n#define gl_get_int32 (*callback->objvar.int32_var)\n\n#define gl_get_int64_by_name (*callback->objvarname.int64_var)\n\n#define gl_get_int64 (*callback->objvar.int64_var)\n\n#define gl_get_double_by_name (*callback->objvarname.double_var)\n\n#define gl_get_double (*callback->objvar.double_var)\n\n#define gl_get_string_by_name (*callback->objvarname.string_var)\n\n#define gl_get_object_prop_by_name (*callback->objvarname.object_var)\n\n#define gl_get_string (*callback->objvar.string_var)\n\n#define gl_get_addr (*callback->properties.get_addr)\n\n/** @} **/\n\n/******************************************************************************\n * Object search\n */\n/**\t@defgroup gridlabd_h_search Object search\n\n\tSearches and navigates object lists.\n\n\t@{\n **/\n/** Find one or more object\n\t@see find_objects()\n **/\n#define gl_find_objects (*callback->find.objects)\n\n/** Scan a list of found objects\n\t@see find_first(), find_next()\n **/\n#define gl_find_next (*callback->find.next)\n\n/** Duplicate a list of found objects\n\t@see find_copylist()\n **/\n#define gl_findlist_copy (*callback->find.copy)\n#define gl_findlist_add (*callback->find.add)\n#define gl_findlist_del (*callback->find.del)\n#define gl_findlist_clear (*callback->find.clear)\n/** Release memory used by a find list\n\t@see free()\n **/\n#define gl_free (*callback->free)\n\n/** Create an aggregate property from a find list\n\t@see aggregate_mkgroup()\n **/\n#define gl_create_aggregate (*callback->aggregate.create)\n\n/** Evaluate an aggregate property\n\t@see aggregate_value()\n **/\n#define gl_run_aggregate (*callback->aggregate.refresh)\n/** @} **/\n\n/******************************************************************************\n * Random number generation\n */\n/**\t@defgroup gridlabd_h_random Random numbers\n\n\tThe random number library provides a variety of random number generations\n\tfor different distributions.\n\n\t@{\n **/\n\n#define RNGSTATE (&(OBJECTHDR(this))->rng_state)\n\n/** Determine the distribution type to be used from its name\n\t@see RANDOMTYPE, random_type()\n **/\n#define gl_randomtype (*callback->random.type)\n\n/** Obtain an arbitrary random value using RANDOMTYPE\n\t@see RANDOMTYPE, random_value()\n **/\n#define gl_randomvalue (*callback->random.value)\n\n/** Obtain an arbitrary random value using RANDOMTYPE\n\t@see RANDOMTYPE, pseudorandom_value()\n **/\n#define gl_pseudorandomvalue (*callback->random.pseudo)\n\n/** Generate a uniformly distributed random number\n\t@see random_uniform()\n **/\n#define gl_random_uniform (*callback->random.uniform)\n\n/** Generate a normal distributed random number\n\t@see random_normal()\n **/\n#define gl_random_normal (*callback->random.normal)\n\n/** Generate a log normal distributed random number\n\t@see random_lognormal()\n **/\n#define gl_random_lognormal (*callback->random.lognormal)\n\n/** Generate a Bernoulli distributed random number\n\t@see random_bernoulli()\n **/\n#define gl_random_bernoulli (*callback->random.bernoulli)\n\n/** Generate a Pareto distributed random number\n\t@see random_pareto()\n **/\n#define gl_random_pareto (*callback->random.pareto)\n\n/** Generate a random number drawn uniformly from a sample\n\t@see random_sampled()\n **/\n#define gl_random_sampled (*callback->random.sampled)\n\n/** Generate an examponentially distributed random number\n\t@see random_exponential()\n **/\n#define gl_random_exponential (*callback->random.exponential)\n#define gl_random_triangle (*callback->random.triangle)\n#define gl_random_gamma (*callback->random.gamma)\n#define gl_random_beta (*callback->random.beta)\n#define gl_random_weibull (*callback->random.weibull)\n#define gl_random_rayleigh (*callback->random.rayleigh)\n/** @} **/\n\n/******************************************************************************\n * Timestamp handling\n */\n/** @defgroup gridlabd_h_timestamp Time handling functions\n @{\n **/\n\n#define gl_globalclock (*(callback->global_clock))\n\n/** Link to double precision deltamode clock (offset by global_clock) **/\n#define gl_globaldeltaclock (*(callback->global_delta_curr_clock))\n\n/** Link to stop time of the simulation **/\n#define gl_globalstoptime (*(callback->global_stoptime))\n\n/** Convert a string to a timestamp\n\t@see convert_to_timestamp()\n **/\n#define gl_parsetime (*callback->time.convert_to_timestamp)\n\n#define gl_delta_parsetime (*callback->time.convert_to_timestamp_delta)\n\n#define gl_printtime (*callback->time.convert_from_timestamp)\n\n#define gl_printtimedelta (*callback->time.convert_from_deltatime_timestamp)\n\n/** Convert a timestamp to a date/time structure\n\t@see mkdatetime()\n **/\n#define gl_mktime (*callback->time.mkdatetime)\n\n/** Convert a date/time structure to a string\n\t@see strdatetime()\n **/\n#define gl_strtime (*callback->time.strdatetime)\n\n/** Convert a timestamp to days\n\t@see timestamp_to_days()\n **/\n#define gl_todays (*callback->time.timestamp_to_days)\n\n/** Convert a timestamp to hours\n\t@see timestamp_to_hours()\n **/\n#define gl_tohours (*callback->time.timestamp_to_hours)\n\n/** Convert a timestamp to minutes\n\t@see timestamp_to_minutes()\n **/\n#define gl_tominutes (*callback->time.timestamp_to_minutes)\n\n/** Convert a timestamp to seconds\n\t@see timestamp_to_seconds()\n **/\n#define gl_toseconds (*callback->time.timestamp_to_seconds)\n\n/** Convert a timestamp to a local date/time structure\n\t@see local_datetime()\n **/\n#define gl_localtime (*callback->time.local_datetime)\n\n/** Convert a timestamp to a local date/time structure\n\tUse this if it is a double precision time (deltamode)\n\t@see local_datetime()\n **/\n#define gl_localtime_delta (*callback->time.local_datetime_delta)\n\n#ifdef __cplusplus\ninline int gl_getweekday(TIMESTAMP t)\n{\n\tDATETIME dt;\n\tgl_localtime(t, &dt);\n\treturn dt.weekday;\n}\ninline int gl_gethour(TIMESTAMP t)\n{\n\tDATETIME dt;\n\tgl_localtime(t, &dt);\n\treturn dt.hour;\n}\n#endif\n/**@}*/\n/******************************************************************************\n * Global variables\n */\n/** @defgroup gridlabd_h_globals Global variables\n @{\n **/\n\n/** Create a new global variable\n\t@see global_create()\n **/\n#define gl_global_create (*callback->global.create)\n\n/** Set a global variable\n\t@see global_setvar()\n **/\n#define gl_global_setvar (*callback->global.setvar)\n\n/** Get a global variable\n\t@see global_getvar()\n **/\n#define gl_global_getvar (*callback->global.getvar)\n\n/** Find a global variable\n\t@see global_find()\n **/\n#define gl_global_find (*callback->global.find)\n\n#define gl_get_oflags (*callback->get_oflags)\n/**@}*/\n\n#ifdef __cplusplus\n/******************************************************************************\n * Utilities\n */\n/** @defgroup gridlabd_h_utility Utility functions\n @{\n **/\n\n/** Clip a value \\p x if outside the range (\\p a, \\p b)\n\t@return the clipped value of x\n\t@note \\f clip() is only supported in C++\n **/\ninline double clip(double x, /**< the value to clip **/\n\t\t\t\t   double a, /**< the lower limit of the range **/\n\t\t\t\t   double b) /**< the upper limit of the range **/\n{\n\tif (x<a) return a;\n\telse if (x>b) return b;\n\telse return x;\n}\n\n/** Determine which bit is set in a bit pattern\n\t@return the bit number \\e n; \\p -7f is no bit found; \\e -n if more than one bit found\n **/\ninline char bitof(unsigned int64 x,/**< bit pattern to scan */\n\t\t\t\t\t\t   bool use_throw=false) /**< flag to use throw when more than one bit is set */\n{\n\tchar n=0;\n\tif (x==0)\n\t{\n\t\tif (use_throw)\n\t\t\tthrow \"bitof empty bit pattern\";\n\t\treturn -0x7f;\n\t}\n\twhile ((x&1)==0)\n\t{\n\t\tx>>=1;\n\t\tn++;\n\t}\n\tif (x!=0)\n\t{\n\t\tif (use_throw)\n\t\t\tthrow \"bitof found more than one bit\";\n\t\telse\n\t\t\treturn -n;\n\t}\n\treturn n;\n}\n/** Construct a proper object object\n    @return a pointer to the struct buffer or NULL if failed\n **/\ninline char* gl_name(OBJECT *my, char *buffer, size_t size)\n{\n\tchar temp[256];\n\tif(my == NULL || buffer == NULL) return NULL;\n\tif (my->name==NULL)\n\t\tsprintf(temp,\"%s:%d\", my->oclass->name, my->id);\n\telse\n\t\tsprintf(temp,\"%s\", my->name);\n\tif(size < strlen(temp))\n\t\treturn NULL;\n\tstrcpy(buffer, temp);\n\treturn buffer;\n}\n\n/** Find a schedule \n **/\ninline SCHEDULE *gl_schedule_find(char *name)\n{\n\treturn callback->schedule.find(name);\n}\n/** Create a schedule\n **/\ninline SCHEDULE *gl_schedule_create(char *name, char *definition)\n{\n\treturn callback->schedule.create(name,definition);\n}\n/** Find the time index in a schedule\n **/\ninline SCHEDULEINDEX gl_schedule_index(SCHEDULE *sch, TIMESTAMP ts)\n{\n\treturn callback->schedule.index(sch,ts);\n}\n/** Find the value at a time index in a schedule\n **/\ninline double gl_schedule_value(SCHEDULE *sch, SCHEDULEINDEX index)\n{\n\treturn callback->schedule.value(sch,index);\n}\n/** Find the elapsed time until the value at an index changes\n **/\ninline int32 gl_schedule_dtnext(SCHEDULE *sch, SCHEDULEINDEX index)\n{\n\treturn callback->schedule.dtnext(sch,index);\n}\ninline SCHEDULE *gl_schedule_getfirst(void)\n{\n\treturn callback->schedule.getfirst();\n}\n/** Create an enduse\n **/\ninline int gl_enduse_create(enduse *e)\n{\n\treturn callback->enduse.create(e);\n}\n/** Synchronize an enduse\n **/\ninline TIMESTAMP gl_enduse_sync(enduse *e, TIMESTAMP t1)\n{\n\treturn callback->enduse.sync(e,PC_BOTTOMUP,t1);\n}\n/** Create a loadshape \n **/\ninline loadshape *gl_loadshape_create(SCHEDULE *s)\n{\n\tloadshape *ls = (loadshape*)malloc(sizeof(loadshape));\n\tmemset(ls,0,sizeof(loadshape));\n\tif (0 == callback->loadshape.create(ls)){\n\t\treturn NULL;\n\t}\n\tls->schedule = s;\n\treturn ls;\n}\n/** Get the current value of a loadshape\n **/\ninline double gl_get_loadshape_value(loadshape *shape)\n{\n\tif (shape)\n\t\treturn shape->load;\n\telse\n\t\treturn 0;\n}\n/** Format a DATETIME into a string buffer\n **/\ninline char *gl_strftime(DATETIME *dt, char *buffer, int size) { return callback->time.strdatetime(dt,buffer,size)?buffer:NULL;};\n/** Format a TIMESTAMP into a string buffer\n **/\ninline char *gl_strftime(TIMESTAMP ts, char *buffer, int size)\n{\n\t//static char buffer[64];\n\tDATETIME dt;\n\tif(buffer == 0){\n\t\tgl_error(\"gl_strftime: buffer is a null pointer\");\n\t\treturn 0;\n\t}\n\tif(size < 15){\n\t\tgl_error(\"gl_strftime: buffer size is too small\");\n\t\treturn 0;\n\t}\n\tif(gl_localtime(ts,&dt)){\n\t\treturn gl_strftime(&dt,buffer,size);\n\t} else {\n\t\tstrncpy(buffer,\"(invalid time)\", size);\n\t}\n\treturn buffer;\n}\n/** Calculate the next power of 2 greater than a number\n **/\ninline size_t nextpow2(register size_t x)\n{\n\tif (x<0) return 0;\n\tx--;\n\tx|=x>>1;\n\tx|=x>>2;\n\tx|=x>>4;\n\tx|=x>>8;\n\tx|=x>>16;\n\t// won't work for anything over 2^30\n\treturn x+1;\n}\n\n/**@}*/\n#endif //__cplusplus\n\n\n/******************************************************************************\n * Interpolation routines\n */\n/** @defgroup gridlabd_h_interpolation Interpolation routines\n @{\n **/\n\n/** Linearly interpolate a value between two points\n\n **/\n#define gl_lerp (*callback->interpolate.linear)\n\n/** Quadratically interpolate a value between two points\n\n **/\n#define gl_qerp (*callback->interpolate.quadratic)\n/**@}*/\n\n/******************************************************************************\n * Forecasting routines\n */\n/** @defgroup gridlabd_h_forecasting Forecasting routines\n @{\n **/\n\n/** Create a forecast entity for an object\n **/\n#define gl_forecast_create (*callback->forecast.create)\n\n/** Find a forecast entity for an object\n **/\n#define gl_forecast_find (*callback->forecast.find)\n\n/** Read a forecast entity for an object\n **/\n#define gl_forecast_read (*callback->forecast.read)\n\n/** Save a forecast entity for an object\n **/\n#define gl_forecast_save (*callback->forecast.save)\n/**@}*/\n\n\n/******************************************************************************\n * Init/Sync/Create catchall macros\n */\n/** @defgroup gridlabd_h_catchall Init/Sync/Create catchall macros\n @{\n **/\n///\n/// Catchall for sync\n///\n#define SYNC_CATCHALL(C) catch (char *msg) { gl_error(\"sync_\" #C \"(obj=%d;%s): %s\", obj->id, obj->name?obj->name:\"unnamed\", msg); return TS_INVALID; } catch (const char *msg) { gl_error(\"sync_\" #C \"(obj=%d;%s): %s\", obj->id, obj->name?obj->name:\"unnamed\", msg); return TS_INVALID; } catch (...) { gl_error(\"sync_\" #C \"(obj=%d;%s): unhandled exception\", obj->id, obj->name?obj->name:\"unnamed\"); return TS_INVALID; }\n///\n/// Catchall for init\n///\n#define INIT_CATCHALL(C) catch (char *msg) { gl_error(\"init_\" #C \"(obj=%d;%s): %s\", obj->id, obj->name?obj->name:\"unnamed\", msg); return 0; } catch (const char *msg) { gl_error(\"init_\" #C \"(obj=%d;%s): %s\", obj->id, obj->name?obj->name:\"unnamed\", msg); return 0; } catch (...) { gl_error(\"init_\" #C \"(obj=%d;%s): unhandled exception\", obj->id, obj->name?obj->name:\"unnamed\"); return 0; }\n///\n/// Catchall for create\n///\n#define CREATE_CATCHALL(C) catch (char *msg) { gl_error(\"create_\" #C \": %s\", msg); return 0; } catch (const char *msg) { gl_error(\"create_\" #C \": %s\", msg); return 0; } catch (...) { gl_error(\"create_\" #C \": unhandled exception\"); return 0; }\n#define I_CATCHALL(T,C) catch (char *msg) { gl_error(#T \"_\" #C \": %s\", msg); return 0; } catch (const char *msg) { gl_error(#T \"_\" #C \": %s\", msg); return 0; } catch (...) { gl_error(#T \"_\" #C \": unhandled exception\"); return 0; }\n#define T_CATCHALL(T,C) catch (char *msg) { gl_error(#T \"_\" #C \"(obj=%d;%s): %s\", obj->id, obj->name?obj->name:\"unnamed\", msg); return TS_INVALID; } catch (const char *msg) { gl_error(#T \"_\" #C \"(obj=%d;%s): %s\", obj->id, obj->name?obj->name:\"unnamed\", msg); return TS_INVALID; } catch (...) { gl_error(#T \"_\" #C \"(obj=%d;%s): unhandled exception\", obj->id, obj->name?obj->name:\"unnamed\"); return TS_INVALID; }\n/**@}*/\n\n/****************************\n * Transform access\n */\n/** @defgroup gridlabd_h_transform Transform access\n * @{\n */\n#ifdef __cplusplus\ninline TRANSFORM *gl_transform_getfirst(void) { return callback->transform.getnext(NULL); };\ninline TRANSFORM *gl_transform_getnext(TRANSFORM *xform) { return callback->transform.getnext(xform); };\ninline int gl_transform_add_linear(TRANSFORMSOURCE stype,double *source,void *target,double scale,double bias,OBJECT *obj,PROPERTY *prop,SCHEDULE *sched) { return callback->transform.add_linear(stype,source,target,scale,bias,obj,prop,sched); };\ninline int gl_transform_add_external(OBJECT *target_obj, PROPERTY *target_prop,char *function,OBJECT *source_obj, PROPERTY* source_prop) { return callback->transform.add_external(target_obj,target_prop,function,source_obj,source_prop); };\ninline const char *gl_module_find_transform_function(TRANSFORMFUNCTION function) { return callback->module.find_transform_function(function); };\n#else\n#define gl_transform_getnext (*callback->transform.getnext) /* TRANSFORM *(*transform.getnext)(TRANSFORM*); */\n#define gl_transform_add_linear (*callback->transfor.add_linear) /* int transform_add_linear(TRANSFORMSOURCE stype,double *source,void *target,double scale,double bias,OBJECT *obj,PROPERTY *prop,SCHEDULE *sched) */\n#define gl_transform_add_external (*callback->transform.add_external) /* int (*transform.add_external)(OBJECT*,PROPERTY*,char*,OBJECT*,PROPERTY*); */\n#define gl_module_find_transform_function (*callback->module.find_transform_function)\n#endif\n/**@}*/\n\n#ifdef __cplusplus\ninline randomvar *gl_randomvar_getfirst(void) { return callback->randomvar.getnext(NULL); };\ninline randomvar *gl_randomvar_getnext(randomvar *var) { return callback->randomvar.getnext(var); };\ninline size_t gl_randomvar_getspec(char *str, size_t size, const randomvar *var) { return callback->randomvar.getspec(str,size,var); };\n#else\n#define gl_randomvar_getnext (*callback->randomvar.getnext) /* randomvar *(*randomvar.getnext)(randomvar*) */\n#define gl_randomvar_getspec (*callback->randomvar.getspec) /* size_t (*randomvar.getspec(char*,size_t,randomvar*) */\n#endif\n\n/******************************************************************************\n * Remote data access\n */\n/** @defgroup gridlabd_h_remote Remote data access\n @{\n **/\n\n#ifdef __cplusplus\n/** read remote object data **/\ninline void *gl_read(void *local, /**< local memory for data (must be correct size for property) */\n\t\t\t\t\t OBJECT *obj, /**< object from which to get data */\n\t\t\t\t\t PROPERTY *prop) /**< property from which to get data */\n{\n\treturn callback->remote.readobj(local,obj,prop);\n}\n/** write remote object data **/\ninline void gl_write(void *local, /** local memory for data */\n\t\t\t\t\t OBJECT *obj, /** object to which data is written */\n\t\t\t\t\t PROPERTY *prop) /**< property to which data is written */\n{\n\t/* @todo */\n\treturn callback->remote.writeobj(local,obj,prop);\n}\n/** read remote global data **/\ninline void *gl_read(void *local, /** local memory for data (must be correct size for global */\n\t\t\t\t\t GLOBALVAR *var) /** global variable from which to get data */\n{\n\t/* @todo */\n\treturn callback->remote.readvar(local,var);\n}\n/** write remote global data **/\ninline void gl_write(void *local, /** local memory for data */\n\t\t\t\t\t GLOBALVAR *var) /** global variable to which data is written */\n{\n\t/* @todo */\n\treturn callback->remote.writevar(local,var);\n}\n#endif\n/**@}*/\n\n// locking functions \n#ifdef __cplusplus\n#define READLOCK(X) ::rlock(X); /**< Locks an item for reading (allows other reads but blocks write) */\n#define WRITELOCK(X) ::wlock(X); /**< Locks an item for writing (blocks all operations) */\n#define READUNLOCK(X) ::runlock(X); /**< Unlocks an read lock */\n#define WRITEUNLOCK(X) ::wunlock(X); /**< Unlocks a write lock */\n\ninline void rlock(unsigned int* lock) { callback->lock.read(lock); }\ninline void wlock(unsigned int* lock) { callback->lock.write(lock); }\ninline void runlock(unsigned int* lock) { callback->unlock.read(lock); }\ninline void wunlock(unsigned int* lock) { callback->unlock.write(lock); }\n\n#else\n#define READLOCK(X) rlock(X); /**< Locks an item for reading (allows other reads but blocks write) */\n#define WRITELOCK(X) wlock(X); /**< Locks an item for writing (blocks all operations) */\n#define READUNLOCK(X) runlock(X); /**< Unlocks an read lock */\n#define WRITEUNLOCK(X) wunlock(X); /**< Unlocks a write lock */\n#endif\n#define LOCK(X) WRITELOCK(X); /**< @todo this is deprecated and should not be used anymore */\n#define UNLOCK(X) WRITEUNLOCK(X); /**< @todo this is deprecated and should not be used anymore */\n\n#define READLOCK_OBJECT(X) READLOCK(&((X)->lock)) /**< Locks an object for reading */\n#define WRITELOCK_OBJECT(X) WRITELOCK(&((X)->lock)) /**< Locks an object for writing */\n#define READUNLOCK_OBJECT(X) READUNLOCK(&((X)->lock)) /**< Unlocks an object */\n#define WRITEUNLOCK_OBJECT(X) WRITEUNLOCK(&((X)->lock)) /**< Unlocks an object */\n#define LOCK_OBJECT(X) WRITELOCK_OBJECT(X); /**< @todo this is deprecated and should not be used anymore */\n#define UNLOCK_OBJECT(X) WRITEUNLOCK_OBJECT(X); /**< @todo this is deprecated and should not be used anymore */\n\n#define LOCKED(X,C) {WRITELOCK_OBJECT(X);(C);WRITEUNLOCK_OBJECT(X);} /**< @todo this is deprecated and should not be used anymore */\n\nstatic unsigned long _nan[] = { 0xffffffff, 0x7fffffff, };\n#ifdef _WIN32\n#define NaN (*(double*)&_nan)\n#else// UNIX/LINUX\n#include <math.h>\n#define NaN NAN\n#endif\n\n\n#ifdef __cplusplus\n\n/**************************************************************************************\n * GRIDLABD BASE CLASSES (Version 3.0 and later)\n * @defgroup gridlabd_h_classes Module API Classes\n * @{\n **************************************************************************************/\n#include <ctype.h>\n#include <stdio.h>\n#include \"module.h\"\n#include \"class.h\"\n#include \"property.h\"\n\n/// General string encapsulation\nclass gld_string {\nprivate: // data\n\ttypedef struct strbuf {\n\t\tunsigned int lock; // TODO implement locking\n\t\tsize_t len;\n\t\tunsigned int nrefs;\n\t\tchar *str;\n\t} STRBUF;\n\tSTRBUF *buf;\npublic: // construction/destructor\n\t/// construct an empty string\n\tinline gld_string(void) : buf(NULL) { init(); };\n\t/// construct a linked string\n\tinline gld_string(gld_string&s) : buf(NULL) { init(); link(s); };\n\t/// construct a new string\n\tinline gld_string(const char *s) : buf(NULL) { init(); copy(s); };\n\t/// construct a new string of a particular length\n\tinline gld_string(const char *s, size_t n) : buf(NULL) { init(); copy(s,n); };\n\t/// destroy a string (or unlink from one)\n\tinline ~gld_string(void) { unlink(); };\npublic: // copy\n\t/// copy a string\n\tinline gld_string &operator=(const char *s) { copy(s); return *this; };\n\t/// link to a string\n\tinline gld_string &operator=(gld_string&s) { link(s); return *this; };\npublic: // casts\n\t/// cast to a pointer to the string buffer\n\tinline operator const char*(void) { return buf->str; };\n\t/// cast to the size of the string\n\tinline operator size_t(void) { return buf->len; };\n\t/// cast to a pointer to the string data\n\tinline operator STRBUF *(void) { return buf; };\nprivate: // internals\n\tinline void init(void) { buf=(STRBUF*)malloc(sizeof(STRBUF)); memset(buf,0,sizeof(STRBUF)); }; \n\tinline void lock(void) { if ( buf ) ::wlock(&buf->lock); };\n\tinline void unlock(void) { if ( buf ) ::wunlock(&buf->lock); };\n\tinline void fit(size_t n) { if ( buf==NULL || n>buf->len) alloc(n); };\n\tinline void alloc(size_t n) \n\t{\n\t\tsize_t len = nextpow2(n);\n\t\tif ( len<sizeof(NATIVE) ) \n\t\t\tlen=sizeof(NATIVE); \n\t\tchar *newstr=(char*)malloc(len);\n\t\tif ( buf->str!=NULL )\n\t\t{\n\t\t\tstrcpy(newstr,buf->str);\n\t\t\tfree(buf->str);\n\t\t}\n\t\telse\n\t\t\tbuf->nrefs=1;\n\t\tbuf->str = newstr;\n\t\tbuf->len = len;\n\t};\n\tinline void copy(const char *s) { fit(strlen(s)+1); strcpy(buf->str,s); };\n\tinline void copy(const char *s, size_t n) { fit(n+1); strncpy(buf->str,s,n); };\n\tinline void link(gld_string&s) { unlink(); buf=(STRBUF*)s; buf->nrefs++;};\n\tinline void unlink() { if ( buf->nrefs<=1 ) {free(buf->str); free(buf);} else buf->nrefs--; };\npublic: // status accessors\n\t/// determine whether a string is valid\n\tinline bool is_valid(void) { return buf!=NULL; };\n\t/// determine whether a string is null\n\tinline bool is_null(void) { return is_valid() && buf->str==NULL; };\npublic: // read accessors\n\t/// get a pointer to the string buffer\n\tinline const char* get_buffer(void) { return buf ? buf->str : NULL; };\n\t/// get the size of the string buffer (as allocated)\n\tinline size_t get_size(void) { return buf ? buf->len : -1; };\n\t/// get the length of the string (up to the null termination)\n\tinline size_t get_length(void) { return buf && buf->str ? strlen(buf->str) : -1; };\npublic: // write accessors\n\t/// set the string\n\tinline void set_string(const char *s) { copy(s); };\n\t/// set the string buffer size\n\tinline void set_size(size_t n) { fit(n); };\n\t/// format the string (a la printf)\n\tinline size_t format(const char *fmt,...) { va_list ptr; va_start(ptr,fmt); int len=vsnprintf(buf->str,buf->len,fmt,ptr); va_end(ptr); return len;};\n\t/// format the string with a specific buffer size\n\tinline size_t format(size_t len,const char *fmt,...) { fit(len); va_list ptr; va_start(ptr,fmt); int rv=vsnprintf(buf->str,buf->len,fmt,ptr); va_end(ptr); return rv;};\npublic: // compare ops\n\t/// alphabetic before comparison\n\tinline bool operator<(const char*s) { return strcmp(buf->str,s)<0; };\n\t/// alphabetic before or same comparison\n\tinline bool operator<=(const char*s) { return strcmp(buf->str,s)<=0; };\n\t/// alphabetic same comparison\n\tinline bool operator==(const char*s) { return strcmp(buf->str,s)==0; };\n\t/// alphabetic after or same comparison\n\tinline bool operator>=(const char*s) { return strcmp(buf->str,s)>=0; };\n\t/// alphabetic after comparison\n\tinline bool operator>(const char*s) { return strcmp(buf->str,s)>0; };\n\t/// alphabetic differs comparison\n\tinline bool operator!=(const char*s) { return strcmp(buf->str,s)!=0; };\npublic: // manipulation\n\t/// trim left whitespace\n\tinline void trimleft(void) { if ( is_null() ) return; size_t n=0; while (buf->str[n]!='\\0'&&isspace(*buf->str)) n++; strcpy(buf->str,buf->str+n); };\n\t/// trim right whitespace\n\tinline void trimright(void) { if ( is_null() ) return; size_t n=strlen(buf->str); while (n>0&&isspace(buf->str[n-1])) buf->str[--n]='\\0'; };\n\t/// extract left string\n\tinline gld_string left(size_t n) { if ( is_null() ) return gld_string(); return gld_string(buf->str,n); };\n\t/// extract right string\n\tinline gld_string right(size_t n) { if ( is_null() ) return gld_string(); return gld_string(buf->str+buf->len-n); };\n\t/// extract mid string\n\tinline gld_string mid(size_t n, size_t m) { if ( is_null() ) return gld_string(); return gld_string(buf->str+buf->len-n,m); };\n\t/// locate substring\n\tinline size_t findstr(const char *s) { if ( is_null() ) return -1; char *p=strstr(buf->str,s); return p==NULL ? -1 : (p-buf->str); };\n\t/// find character\n\tinline size_t findchr(char c) { if ( is_null() ) return -1; char *p=strchr(buf->str,c); return p==NULL ? -1 : (p-buf->str); };\n\tinline size_t split(gld_string *&list, const char *delim=\" \") \n\t{\n\t\t// TODO\n\t\tif ( is_null() ) return 0;\n\t\treturn 0;\n\t}\n\tinline gld_string merge(gld_string *&list, size_t n, const char *delim=\" \")\n\t{\n\t\t// TODO\n\t\treturn gld_string();\n\t}\n};\n\n/// Date/time encapsulation\nclass gld_clock {\nprivate: // data\n\tDATETIME dt;\npublic: // constructors\n\t/// Clock constructor for current global clock\n\tgld_clock(void) { callback->time.local_datetime(*(callback->global_clock),&dt); }; \n\t/// Clock constructor for an arbitrary TIMESTAMP\n\tgld_clock(TIMESTAMP ts) { if ( !callback->time.local_datetime(ts,&dt)) memset(&dt,0,sizeof(dt)); };\n\t/// Clock constructor for a time string\n\tgld_clock(char *str) { from_string(str); };\n\t/// Clock constructor for year, month, day, hour, minute, second, nanosecond values\n\tgld_clock(unsigned short y, unsigned short m=0, unsigned short d=0, unsigned short H=0, unsigned short M=0, unsigned short S=0, unsigned short int ms=0, char *tz=NULL, int dst=-1)\n\t{\n\t\tdt.year = y; dt.month=m; dt.day=d; dt.hour=H; dt.minute=M; dt.second=S; dt.nanosecond=ms;\n\t\tif ( dst>=0 ) dt.is_dst=dst;\n\t\tif ( tz!=NULL ) set_tz(tz); else callback->time.mkdatetime(&dt);\n\t}\npublic: // cast operators\n\t/// Cast to TIMESTAMP\n\tinline operator TIMESTAMP (void) { return dt.timestamp; };\npublic: // comparison operators\n\t/// Compare after TIMESTAMP\n\tinline bool operator > (TIMESTAMP t) { return dt.timestamp>t; };\n\t/// Compare after or same TIMESTAMP\n\tinline bool operator >= (TIMESTAMP t) { return dt.timestamp>=t; };\n\t/// Compare before TIMESTAMP\n\tinline bool operator < (TIMESTAMP t) { return dt.timestamp<t; };\n\t/// Compare before or same TIMESTAMP\n\tinline bool operator <= (TIMESTAMP t) { return dt.timestamp<=t; };\n\t/// Compare same TIMESTAMP\n\tinline bool operator == (TIMESTAMP t) { return dt.timestamp==t; };\n\t/// Compare different TIMESTAMP\n\tinline bool operator != (TIMESTAMP t) { return dt.timestamp!=t; };\n\t/// Check if valid TIMESTAMP\n\tinline bool is_valid(void) { return dt.timestamp>0; };\n\t/// Check if NEVER\n\tinline bool is_never(void) { return dt.timestamp==TS_NEVER; };\npublic: // read accessors\n\t/// Get the year\n\tinline unsigned short get_year(void) { return dt.year; };\n\t/// Get the month (0-11)\n\tinline unsigned short get_month(void) { return dt.month; };\n\t/// Get the day (1-31)\n\tinline unsigned short get_day(void) { return dt.day; };\n\t/// Get the hour (0-23)\n\tinline unsigned short get_hour(void) { return dt.hour; };\n\t/// Get the minute (0-59)\n\tinline unsigned short get_minute(void) { return dt.minute; };\n\t/// Get the second (0-59)\n\tinline unsigned short get_second(void) { return dt.second; };\n\t/// Get the nanosecond (0-999999)\n\tinline unsigned int get_nanosecond(void) { return dt.nanosecond; };\n\t/// Get the Unix Day Number (full days since the Unix Epoch)\n\tinline unsigned int get_uday(void) { return dt.timestamp / 86400; };\n\t/// Get the Julian Day Number\n\tinline unsigned int get_jday(void) { return (dt.timestamp / 86400) + 2440587.5; };\n\t/// Get the timezone spec\n\tinline char* get_tz(void) { return dt.tz; };\n\t/// Get the summer/daylight time flag\n\tinline bool get_is_dst(void) { return dt.is_dst?true:false; };\n\t/// Get the weekday (Sunday=0)\n\tinline unsigned short get_weekday(void) { return dt.weekday; };\n\t/// Get the day of the year (Jan 1=0)\n\tinline unsigned short get_yearday(void) { return dt.yearday; };\n\t/// Get the timezone offer (in seconds)\n\tinline int get_tzoffset(void) { return dt.tzoffset; };\n\t/// Get the TIMESTAMP value (UTC)\n\tinline TIMESTAMP get_timestamp(void) { return dt.timestamp; };\n\t/// Get the local TIMESTAMP value (ignoring DST)\n\tinline TIMESTAMP get_localtimestamp(void) { return dt.timestamp - dt.tzoffset; };\n\t/// Get the local TIMESTAMP value (including DST)\n\tinline TIMESTAMP get_localtimestamp_dst(bool force_dst=false) { return dt.timestamp - dt.tzoffset + (dt.is_dst||force_dst?3600:0); };\npublic: // write accessors\n\t/// Set the date\n\tinline TIMESTAMP set_date(unsigned short y, unsigned short m, unsigned short d) { dt.year=y; dt.month=m; dt.day=d; return callback->time.mkdatetime(&dt); };\n\t/// Set the time\n\tinline TIMESTAMP set_time(unsigned short H, unsigned short M, unsigned short S, unsigned long u=0, char *t=NULL, bool force_dst=false) { dt.hour=H; dt.minute=M; dt.second=S; dt.nanosecond=u; strncpy(dt.tz,t,sizeof(dt.tz)); if (force_dst) dt.is_dst=true; return callback->time.mkdatetime(&dt); };\n\t/// Set the date and time\n\tinline TIMESTAMP set_datetime(unsigned short y, unsigned short m, unsigned short d, unsigned short H, unsigned short M, unsigned short S, unsigned long u=0, char *t=NULL, bool force_dst=false) { dt.year=y; dt.month=m; dt.day=d; dt.hour=H; dt.minute=M; dt.second=S; dt.nanosecond=u; strncpy(dt.tz,t,sizeof(dt.tz)); if (force_dst) dt.is_dst=true; return callback->time.mkdatetime(&dt); };\n\t/// Set the year\n\tinline TIMESTAMP set_year(unsigned short y) { dt.year=y; return callback->time.mkdatetime(&dt); };\n\t/// Set the month (Jan=0)\n\tinline TIMESTAMP set_month(unsigned short m) { dt.month=m; return callback->time.mkdatetime(&dt); };\n\t/// Set the day (1-31)\n\tinline TIMESTAMP set_day(unsigned short d) { dt.day=d; return callback->time.mkdatetime(&dt); };\n\t/// Set the hour (0-23)\n\tinline TIMESTAMP set_hour(unsigned short h) { dt.hour=h; return callback->time.mkdatetime(&dt); };\n\t/// Set the minute (0-59)\n\tinline TIMESTAMP set_minute(unsigned short m) { dt.minute=m; return callback->time.mkdatetime(&dt); };\n\t/// Set the second (0-59)\n\tinline TIMESTAMP set_second(unsigned short s) { dt.second=s; return callback->time.mkdatetime(&dt); };\n\t/// Set the nanosecond (0-999999)\n\tinline TIMESTAMP set_nanosecond(unsigned int u) { dt.nanosecond=u; return callback->time.mkdatetime(&dt); };\n\t/// Set the timezone (see tzinfo.txt)\n\tinline TIMESTAMP set_tz(char* t) { strncpy(dt.tz,t,sizeof(dt.tz)); return callback->time.mkdatetime(&dt); };\n\t/// Set the DST flag\n\tinline TIMESTAMP set_is_dst(bool i) { dt.is_dst=i; return callback->time.mkdatetime(&dt); };\npublic: // special functions\n\t/// Convert from string\n\tinline bool from_string(char *str) { return callback->time.local_datetime(callback->time.convert_to_timestamp(str),&dt)?true:false; };\n\t/// Convert to string\n\tinline unsigned int to_string(char *str, int size) {return callback->time.convert_from_timestamp(dt.timestamp,str,size); };\n\t/// Extract the total number of days since 1/1/1970 0:00:00 UTC\n\tinline double to_days(TIMESTAMP ts=0) { return (dt.timestamp-ts)/86400.0 + dt.nanosecond*1e-9; };\n\t/// Extract the total number of hours since 1/1/1970 0:00:00 UTC\n\tinline double to_hours(TIMESTAMP ts=0) { return (dt.timestamp-ts)/3600.0 + dt.nanosecond*1e-9; };\n\t/// Extract the total number of minutes since 1/1/1970 0:00:00 UTC\n\tinline double to_minutes(TIMESTAMP ts=0) { return (dt.timestamp-ts)/60.0 + dt.nanosecond*1e-9; };\n\t/// Extract the total number of seconds since 1/1/1970 0:00:00 UTC\n\tinline double to_seconds(TIMESTAMP ts=0) { return dt.timestamp-ts + dt.nanosecond*1e-9; };\n\t/// Extract the total number of nanoseconds since 1/1/1970 0:00:00 UTC\n\tinline double to_nanoseconds(TIMESTAMP ts=0) { return (dt.timestamp-ts)*1e9 + dt.nanosecond; };\n\t/// Get the timestamp as a string\n\tinline gld_string get_string(const size_t sz=1024) \n\t{\n\t\tgld_string res;\n\t\tchar buf[1024];\n\t\tif ( sizeof(buf)<sz ) throw \"get_string() over size limit\";\n\t\tif ( to_string(buf,(int)sz)>=0 )\n\t\t\tres = buf;\n\t\treturn res;\n\t};\n};\n\n/// Read lock container\nclass gld_rlock {\nprivate: OBJECT *my;\n\t/// Constructor\npublic: inline gld_rlock(OBJECT *obj) : my(obj) {::rlock(&my->lock);}; \n\t/// Destructor\npublic: inline ~gld_rlock(void) {::runlock(&my->lock);};\n};\n/// Write lock container\nclass gld_wlock {\nprivate: OBJECT *my;\n\t\t /// Constructor\npublic: inline gld_wlock(OBJECT *obj) : my(obj) {::wlock(&my->lock);}; \n\t\t/// Destructor\npublic: inline ~gld_wlock(void) {::wunlock(&my->lock);};\n};\n\nclass gld_class;\n/// Module container\nclass gld_module {\n\nprivate: // data\n\tMODULE core;\n\npublic: // constructors/casts\n\t/// Constructor\n\tinline gld_module(void) { MODULE *m = callback->module.getfirst(); if (m) core=*m; else throw \"no modules loaded\";};\n\t/// Cast to MODULE\n\tinline operator MODULE*(void) { return &core; };\n\npublic: // read accessors\n\t/// Get module name\n\tinline char* get_name(void) { return core.name; };\n\t/// Get module major version number\n\tinline unsigned short get_major(void) { return core.major; };\n\t/// Get module minor version number\n\tinline unsigned short get_minor(void) { return core.minor; };\n\t/// Get first class in module\n\tinline gld_class* get_first_class(void) { return (gld_class*)core.oclass; };\n\npublic: // write accessors\n\npublic: // iterators\n\t/// Check if last module loaded\n\tinline bool is_last(void) { return core.next==NULL; };\n\t/// Get next module loaded\n\tinline void get_next(void) { core = *(core.next); };\n};\n\nclass gld_property;\nclass gld_function;\n/// Class container\nclass gld_class {\n\nprivate: // data\n\tCLASS core;\n\npublic: // constructors\n\t/// Constructor (blocker implementation)\n\tinline gld_class(void) { throw \"gld_class constructor not permitted\"; };\n\t/// Cast to CLASS\n\tinline operator CLASS*(void) { return &core; };\n\npublic: // read accessors\n\t/// Get class name\n\tinline char* get_name(void) { return core.name; };\n\t/// Get class size\n\tinline size_t get_size(void) { return core.size; };\n\t/// Get class parent\n\tinline gld_class* get_parent(void) { return (gld_class*)core.parent; };\n\t/// Get module that implements the class\n\tinline gld_module* get_module(void) { return (gld_module*)core.module; };\n\t/// Get the first property in the class\n\tinline gld_property* get_first_property(void) { return (gld_property*)core.pmap; };\n\t/// Get the next property in the class\n\tinline gld_property* get_next_property(PROPERTY*p) { PROPERTY *prop=(PROPERTY*)p->next; return ( prop && prop->oclass==&core ) ? (gld_property*)prop : NULL; };\n\t/// Get the first function in the class\n\tinline gld_function* get_first_function(void) { return (gld_function*)core.fmap; };\n\t/// Get the next function in the class\n\tinline gld_function* get_next_function(FUNCTION*f) { return (gld_function*)f->next; };\n\t/// Get TRL \n\tinline TECHNOLOGYREADINESSLEVEL get_trl(void) { return core.trl; };\n\npublic: // write accessors\n\t/// Set TRL\n\tinline void set_trl(TECHNOLOGYREADINESSLEVEL t) { core.trl=t; };\n\npublic: // special functions\n\t/// Register a class\t\n\tstatic inline CLASS *create(MODULE *m, char *n, size_t s, unsigned int f) { return callback->register_class(m,n,(unsigned int)s,f); };\n\t\npublic: // iterators\n\t/// Check if last class registered\n\tinline bool is_last(void) { return core.next==NULL; };\n\t/// Check if last class defined by this class' module\n\tinline bool is_module_last(void) { return core.next==NULL || core.module!=core.next->module; };\n\t/// Get the next class\n\tinline gld_class* get_next(void) { return (gld_class*)core.next; };\n};\n\n/// Function container\nclass gld_function {\n\nprivate: // data\n\tFUNCTION core;\n\npublic: // constructors\n\t/// Construct a function (blocker implementation)\n\tinline gld_function(void) { throw \"gld_function constructor not permitted\"; };\n\t/// Cast to a FUNCTION pointer\n\tinline operator FUNCTION*(void) { return &core; };\n\npublic: // read accessors\n\t/// Get function name\n\tinline char *get_name(void) { return core.name; };\n\t/// Get function class\n\tinline gld_class* get_class(void) { return (gld_class*)core.oclass; };\n\t/// Get function address\n\tinline FUNCTIONADDR get_addr(void) { return core.addr; };\n\npublic: // write accessors\n\npublic: // iterators\n\t/// Check whether this is the last function defined\n\tinline bool is_last(void) { return core.next==NULL; };\n\t/// Get the next function in the list\n\tinline gld_function* get_next(void) { return (gld_function*)core.next; };\n};\n\n/// Built-in type container\nclass gld_type {\n\nprivate: // data\n\tPROPERTYTYPE type;\n\npublic: // constructors/casts\n\t/// Constructor\n\tinline gld_type(PROPERTYTYPE t) : type(t) {};\n\t/// Cast to PROPERTYTYPE\n\tinline operator PROPERTYTYPE(void) { return type; };\n\npublic: // read accessors\n\t// TODO size,conversions,etc...\n\tPROPERTYSPEC *get_spec(void) { return callback->properties.get_spec(type);};\n\npublic: // write accessors\n\npublic: // iterators\n\t/// Get the first property type\n\tstatic inline PROPERTYTYPE get_first(void) { return PT_double; };\n\t/// Get the next property type\n\tinline PROPERTYTYPE get_next(void) { return (PROPERTYTYPE)(((int)type)+1); };\n\t/// Check whether this is the last property type\n\tinline bool is_last(void) { return (PROPERTYTYPE)(((int)type)+1)==_PT_LAST; }; \n};\n\n/// Unit container\nclass gld_unit {\n\nprivate: // data\n\tUNIT core;\n\npublic: // constructors/casts\n\t/// Construct empty unit container\n\tinline gld_unit(void) { memset(&core,0,sizeof(core)); };\n\t/// Construct a container for a named or derived unit\n\tinline gld_unit(char *name) { UNIT *unit=callback->unit_find(name); if (unit) memcpy(&core,unit,sizeof(UNIT)); else memset(&core,0,sizeof(UNIT)); };\n\t/// Cast to a UNIT structure\n\tinline operator UNIT*(void) { return &core; };\n\npublic: // read accessors\n\t/// Get the name or derivation of the unit\n\tinline char* get_name(void) { return core.name; };\n\t/// Get the C exponent\n\tinline double get_c(void) { return core.c; };\n\t/// Get the E exponent\n\tinline double get_e(void) { return core.e; };\n\t/// Get the H exponent\n\tinline double get_h(void) { return core.h; };\n\t/// Get the K exponent\n\tinline double get_k(void) { return core.k; };\n\t/// Get the M exponent\n\tinline double get_m(void) { return core.m; };\n\t/// Get the S exponent\n\tinline double get_s(void) { return core.s; };\n\t/// Get the A constant\n\tinline double get_a(void) { return core.a; };\n\t/// Get the B constant\n\tinline double get_b(void) { return core.b; };\n\t/// Get the unit precision\n\tinline int get_prec(void) { return core.prec; };\n\t/// Check whether the unit is valid\n\tinline bool is_valid(void) { return core.name[0]!='\\0'; };\n\npublic: // write accessors\n\t/// Change the unit\n\tinline bool set_unit(char *name){ UNIT *unit=callback->unit_find(name); if (unit) {memcpy(&core,unit,sizeof(UNIT));return true;} else {memset(&core,0,sizeof(UNIT));return false;} };\n\npublic: // special functions\n\t/// Convert a value to another named or derived unit\n\tinline bool convert(char *name, double &value) { UNIT *unit=callback->unit_find(name); return unit&&(callback->unit_convert_ex(&core,unit,&value))?true:false; }\n\t/// Convert a value to another UNIT\n\tinline bool convert(UNIT *unit, double &value) { return callback->unit_convert_ex(&core,unit,&value)?true:false; }\n\t/// Convert a value to another gld_unit\n\tinline bool convert(gld_unit &unit, double &value) { return callback->unit_convert_ex(&core,(UNIT*)unit,&value)?true:false; }\n\npublic: // iterators\n\t/// Check whether this is the last defined unit\n\tinline bool is_last(void) { return core.next==NULL?true:false; };\n\t/// Get the next unit\n\tinline gld_unit* get_next(void) { return (gld_unit*)core.next; };\n};\n\n/// Keyword container\nclass gld_keyword {\n\nprivate: // data\n\tKEYWORD core;\n\npublic: // constructors/casts\n\t/// Construct a key word\n\tinline gld_keyword(KEYWORD &key) { core=key; };\n\t/// Cast to a keyword pointer\n\tinline operator KEYWORD* (void) { return &core; };\n\tinline operator const char* (void) { return core.name; };\n\tinline operator long unsigned int (void) { return core.value;};\n\npublic: // read accessors\n\t/// Get the name of a keyword\n\tinline const char* get_name(void) { return core.name; };\n\t/// Get the bit pattern for the keyword\n\tinline long unsigned int get_value(void) { return core.value; };\n\tinline enumeration get_enumeration_value(void) { return (enumeration)get_value(); };\n\tinline set get_set_value(void) { return (set)get_value(); };\n\npublic: // write accessors\n\tinline int compare(const char *name) { return strcmp(name,core.name); };\n\tinline bool operator == (const char *name) { return compare(name)==0; };\n\tinline bool operator <= (const char *name) { return compare(name)<=0; };\n\tinline bool operator >= (const char *name) { return compare(name)>=0; };\n\tinline bool operator < (const char *name) { return compare(name)<0; };\n\tinline bool operator > (const char *name) { return compare(name)>0; };\n\tinline bool operator != (const char *name) { return compare(name)!=0; };\n\tinline int compare(long unsigned int value) { return value<(long unsigned int)core.value ? -1 : ( value>core.value ? +1 : 0 ); };\n\tinline bool operator == (long unsigned int value) { return compare(value)==0; };\n\tinline bool operator <= (long unsigned int value) { return compare(value)<=0; };\n\tinline bool operator >= (long unsigned int value) { return compare(value)>=0; };\n\tinline bool operator < (long unsigned int value) { return compare(value)<0; };\n\tinline bool operator > (long unsigned int value) { return compare(value)>0; };\n\tinline bool operator != (long unsigned int value) { return compare(value)!=0; };\n\npublic: // iterators\n\t/// Get the next keyword (NULL if last)\n\tinline gld_keyword* get_next(void) { return (gld_keyword*)core.next; };\n\ttemplate <class T> inline gld_keyword* find(T value)\n\t{\n\t\tif ( compare(value)==0 ) return this;\n\t\tif ( get_next()==NULL ) return NULL;\n\t\treturn get_next()->find(value);\n\t};\n};\n\n\n// object data declaration/accessors\n/// Define an atomic property\n#define GL_ATOMIC(T,X) protected: T X; public: \\\n\tstatic inline size_t get_##X##_offset(void) { return (char*)&(defaults->X)-(char*)defaults; }; \\\n\tinline T get_##X(void) { return X; }; \\\n\tinline gld_property get_##X##_property(void) { return gld_property(my(),#X); }; \\\n\tinline T get_##X(gld_rlock&) { return X; }; \\\n\tinline T get_##X(gld_wlock&) { return X; }; \\\n\tinline void set_##X(T p) { X=p; }; \\\n\tinline void set_##X(T p, gld_wlock&) { X=p; }; \\\n\tinline gld_string get_##X##_string(void) { return get_##X##_property().get_string(); }; \\\n\tinline void set_##X(char *str) { get_##X##_property().from_string(str); }; \\\n\n/// Define a structured property\n#define GL_STRUCT(T,X) protected: T X; public: \\\n\tstatic inline size_t get_##X##_offset(void) { return (char*)&(defaults->X)-(char*)defaults; }; \\\n\tinline T get_##X(void) { gld_rlock _lock(my()); return X; }; \\\n\tinline gld_property get_##X##_property(void) { return gld_property(my(),#X); }; \\\n\tinline T get_##X(gld_rlock&) { return X; }; \\\n\tinline T get_##X(gld_wlock&) { return X; }; \\\n\tinline void set_##X(T p) { gld_wlock _lock(my()); X=p; }; \\\n\tinline void set_##X(T p, gld_wlock&) { X=p; }; \\\n\tinline gld_string get_##X##_string(void) { return get_##X##_property().get_string(); }; \\\n\tinline void set_##X(char *str) { get_##X##_property().from_string(str); }; \\\n\n/// Define a string property\n#define GL_STRING(T,X) \tprotected: T X; public: \\\n\tstatic inline size_t get_##X##_offset(void) { return (char*)&(defaults->X)-(char*)defaults; }; \\\n\tinline char* get_##X(void) { gld_rlock _lock(my()); return X.get_string(); }; \\\n\tinline gld_property get_##X##_property(void) { return gld_property(my(),#X); }; \\\n\tinline char* get_##X(gld_rlock&) { return X.get_string(); }; \\\n\tinline char* get_##X(gld_wlock&) { return X.get_string(); }; \\\n\tinline char get_##X(size_t n) { gld_rlock _lock(my()); return X[n]; }; \\\n\tinline char get_##X(size_t n, gld_rlock&) { return X[n]; }; \\\n\tinline char get_##X(size_t n, gld_wlock&) { return X[n]; }; \\\n\tinline void set_##X(char *p) { gld_wlock _lock(my()); strncpy(X,p,sizeof(X)); }; \\\n\tinline void set_##X(char *p, gld_wlock&) { strncpy(X,p,sizeof(X)); }; \\\n\tinline void set_##X(size_t n, char c) { gld_wlock _lock(my()); X[n]=c; }; \\\n\tinline void set_##X(size_t n, char c, gld_wlock&) { X[n]=c; };  \\\n\n/// Define an array property\n#define GL_ARRAY(T,X,S) protected: T X[S]; public: \\\n\tstatic inline size_t get_##X##_offset(void) { return (char*)&(defaults->X)-(char*)defaults; }; \\\n\tinline gld_property get_##X##_property(void) { return gld_property(my(),#X); }; \\\n\tinline T* get_##X(void) { gld_rlock _lock(my()); return X; }; \\\n\tinline T* get_##X(gld_rlock&) { return X; }; \\\n\tinline T* get_##X(gld_wlock&) { return X; }; \\\n\tinline T get_##X(size_t n) { gld_rlock _lock(my()); return X[n]; }; \\\n\tinline T get_##X(size_t n, gld_rlock&) { return X[n]; }; \\\n\tinline T get_##X(size_t n, gld_wlock&) { return X[n]; }; \\\n\tinline void set_##X(T* p) { gld_wlock _lock(my()); memcpy(X,p,sizeof(X)); }; \\\n\tinline void set_##X(T* p, gld_wlock&) { memcpy(X,p,sizeof(X)); }; \\\n\tinline void set_##X(size_t n, T m) { gld_wlock _lock(my()); X[n]=m; }; \\\n\tinline void set_##X(size_t n, T m, gld_wlock&) { X[n]=m; };  \\\n\n/// Define a bitflag property\n#define GL_BITFLAGS(T,X) protected: T X; public: \\\n\tstatic inline size_t get_##X##_offset(void) { return (char*)&(defaults->X)-(char*)defaults; }; \\\n\tinline T get_##X(T mask=-1) { return X&mask; }; \\\n\tinline gld_property get_##X##_property(void) { return gld_property(my(),#X); }; \\\n\tinline T get_##X(gld_rlock&) { return X; }; \\\n\tinline T get_##X(gld_wlock&) { return X; }; \\\n\tinline void set_##X(T p) { X=p; }; \\\n\tinline void set_##X##_bits(T p) { gld_rlock _lock(my()); (X)|=(p); }; \\\n\tinline void clr_##X##_bits(T p) { gld_rlock _lock(my()); (X)&=~(p); }; \\\n\tinline void set_##X(T p, gld_wlock&) { X=p; }; \\\n\tinline gld_string get_##X##_string(void) { return get_##X##_property().get_string(); }; \\\n\tinline void set_##X(char *str) { get_##X##_property().from_string(str); }; \\\n\n/// Define a method property\n#define GL_METHOD(C,X) public: int X(char *buffer, size_t len); \\\n\tstatic inline size_t get_##X##_offset(void) { return (size_t)method_##C##_##X; }; \\\n\tinline int get_##X(char *buffer, size_t len) { return X(buffer,len); }; \\\n\tinline int set_##X(char *buffer) { return X(buffer,0); }\n#define IMPL_METHOD(C,X) int C::X(char *buffer, size_t len)  // use this to implement a method\n\n/// Set bits of a bitflag property\ninline void setbits(unsigned long &flags, unsigned int bits) { flags|=bits; }; \n/// Clear bits of a bitflag property\ninline void clearbits(unsigned long &flags, unsigned int bits) { flags&=~bits; }; \n/// Test bits of a bitflag property\ninline bool hasbits(unsigned long flags, unsigned int bits) { return (flags&bits) ? true : false; };\n\n/// Object container\nclass gld_object {\npublic:\n\tinline OBJECT *my() { return this?(((OBJECT*)this)-1):NULL; }\nprivate:\n\t// Make gld_object not copy-constructable.\n\tgld_object& operator=(const gld_object&) = delete;\n\npublic: // constructors\n\tinline static gld_object *find_object(char *n) { OBJECT *obj = callback->get_object(n); if (obj) return (gld_object*)(obj+1); else return NULL; };\n\npublic: // header read accessors (no locking)\n\tinline OBJECTNUM get_id(void) { return my()->id; };\n\tinline char* get_groupid(void) { return my()->groupid.get_string(); };\n\tinline gld_class* get_oclass(void) { return (gld_class*)my()->oclass; };\n\tinline gld_object* get_parent(void) { return my()->parent?OBJECTDATA(my()->parent,gld_object):NULL; };\n\tinline OBJECTRANK get_rank(void) { return my()->rank; };\n\tinline TIMESTAMP get_clock(void) { return my()->clock; };\n\tinline TIMESTAMP get_valid_to(void) { return my()->valid_to; };\n\tinline TIMESTAMP get_schedule_skew(void) { return my()->schedule_skew; };\n\tinline FORECAST* get_forecast(void) { return my()->forecast; };\n\tinline double get_latitude(void) { return my()->latitude; };\n\tinline double get_longitude(void) { return my()->longitude; };\n\tinline TIMESTAMP get_in_svc(void) { return my()->in_svc; };\n\tinline TIMESTAMP get_out_svc(void) { return my()->out_svc; };\n\tinline const char* get_name(void) {\n\t\tstatic char _name[sizeof(CLASS) + 16];\n\t\tif(my()->name){\n\t\t\t\treturn my()->name;\n\t\t} else if(my()->oclass){\n\t\t\tsnprintf(_name, sizeof(CLASS) + 16, \"%s:%d\",\n\t\t\t\t\tmy()->oclass->name, my()->id);\n\t\t} else {\n\t\t\tsnprintf(_name, sizeof(CLASS) + 16, \"Unknown\");\n\t\t}\n\t\treturn _name;\n\t}\n\t;\n\tinline NAMESPACE* get_space(void) { return my()->space; };\n\tinline unsigned int get_lock(void) { return my()->lock; };\n\tinline unsigned int get_rng_state(void) { return my()->rng_state; };\n\tinline TIMESTAMP get_heartbeat(void) { return my()->heartbeat; };\n\tinline unsigned long get_flags(unsigned long mask=0xffffffff) { return (my()->flags)&mask; };\n\nprotected: // header write accessors (no locking)\n\tinline void set_clock(TIMESTAMP ts=0) { my()->clock=(ts?ts:gl_globalclock); };\n\tinline void set_heartbeat(TIMESTAMP dt) { my()->heartbeat=dt; };\n\tinline void set_forecast(FORECAST *fs) { my()->forecast=fs; };\n\tinline void set_latitude(double x) { my()->latitude=x; };\n\tinline void set_longitude(double x) { my()->longitude=x; };\n\tinline void set_flags(unsigned long flags) { my()->flags=flags; };\n\tinline void set_flags_bits(unsigned long bits) { my()->flags|=bits; };\n\tinline void unset_flags_bits(unsigned long bits) { my()->flags&=~bits; };\n\nprotected: // locking (self)\n\tinline void rlock(void) { ::rlock(&my()->lock); };\n\tinline void runlock(void) { ::runlock(&my()->lock); };\n\tinline void wlock(void) { ::wlock(&my()->lock); };\n\tinline void wunlock(void) { ::wunlock(&my()->lock); };\nprotected: // locking (others)\n\tinline void rlock(OBJECT *obj) { ::rlock(&obj->lock); };\n\tinline void runlock(OBJECT *obj) { ::runlock(&obj->lock); };\n\tinline void wlock(OBJECT *obj) { ::wlock(&obj->lock); };\n\tinline void wunlock(OBJECT *obj) { ::wunlock(&obj->lock); };\n\nprotected: // special functions\n\tinline bool operator == (gld_object *o) { return o!=NULL && my()==o->my(); };\n\tinline bool operator == (OBJECT *o) { return o!=NULL && my()==o; };\n\npublic: // member lookup functions\n\tinline PROPERTY* get_property(char *name, PROPERTYSTRUCT *pstruct=NULL) { return callback->properties.get_property(my(),name,pstruct); };\n\tinline FUNCTIONADDR get_function(char *name) { return (*callback->function.get)(my()->oclass->name,name); };\n\npublic: // external accessors\n\ttemplate <class T> inline void getp(PROPERTY &prop, T &value) { rlock(); value=*(T*)(GETADDR(my(),&prop)); wunlock(); };\n\ttemplate <class T> inline void setp(PROPERTY &prop, T &value) { wlock(); *(T*)(GETADDR(my(),&prop))=value; wunlock(); };\n\ttemplate <class T> inline void getp(PROPERTY &prop, T &value, gld_rlock&) { value=*(T*)(GETADDR(my(),&prop)); };\n\ttemplate <class T> inline void getp(PROPERTY &prop, T &value, gld_wlock&) { value=*(T*)(GETADDR(my(),&prop)); };\n\ttemplate <class T> inline void setp(PROPERTY &prop, T &value, gld_wlock&) { *(T*)(GETADDR(my(),&prop))=value; };\n\npublic: // core interface\n\tinline int set_dependent(OBJECT *obj) { return callback->object.set_dependent(my(),obj); };\n\tinline int set_parent(OBJECT *obj) { return callback->object.set_parent(my(),obj); };\n\tinline int set_rank(unsigned int r) { return callback->object.set_rank(my(),r); };\n\tinline bool isa(char *type) { return callback->object_isa(my(),type) ? true : false; };\n\tinline bool is_valid(void) { return my()!=NULL && my()==OBJECTHDR(this); };\n\npublic: // iterators\n\tinline bool is_last(void) { return my()->next==NULL; };\n\tinline static gld_object *get_first(void) { OBJECT *o=callback->object.get_first(); return OBJECTDATA(o,gld_object);};\n\tinline gld_object* get_next(void) { return OBJECTDATA(my()->next,gld_object); };\n\npublic: // exceptions\n\tinline void exception(const char *msg, ...) { static char buf[1024]; va_list ptr; va_start(ptr,msg); vsprintf(buf+sprintf(buf,\"%s: \",get_name()),msg,ptr); va_end(ptr); throw (const char*)buf;};\n\tinline void error(const char *msg, ...) { static char buf[1024]; va_list ptr; va_start(ptr,msg); vsprintf(buf+sprintf(buf,\"%s: \",get_name()),msg,ptr); va_end(ptr); gl_error(\"%s\",buf);};\n\tinline void warning(const char *msg, ...) { static char buf[1024]; va_list ptr; va_start(ptr,msg); vsprintf(buf+sprintf(buf,\"%s: \",get_name()),msg,ptr); va_end(ptr); gl_warning(\"%s\",buf);};\n\tinline void debug(const char *msg, ...) { static char buf[1024]; va_list ptr; va_start(ptr,msg); vsprintf(buf+sprintf(buf,\"%s: \",get_name()),msg,ptr); va_end(ptr); gl_debug(\"%s\",buf);};\n};\n/// Create a gld_object from an OBJECT\nstatic inline gld_object* get_object(OBJECT*obj)\n{\n\treturn obj ? (gld_object*)(obj+1) : NULL;\n}\n/// Find a gld_object from an object name\nstatic inline gld_object* get_object(char *n)\n{\n\tOBJECT *obj = callback->get_object(n);\n\treturn get_object(obj);\n}\n\nstatic PROPERTYSTRUCT nullpstruct;\n/// Property container\nclass gld_property {\n\nprivate: // data\n\tPROPERTYSTRUCT pstruct;\n\tOBJECT *obj;\n\npublic: // constructors/casts\n\tinline gld_property(void) : obj(NULL), pstruct(nullpstruct) {};\n\tinline gld_property(gld_object *o, char *n) : obj(o->my()), pstruct(nullpstruct)  \n\t{ \n\t\tif (o) \n\t\t\tcallback->properties.get_property(o->my(),n,&pstruct); \n\t\telse \n\t\t{\n\t\t\tGLOBALVAR *v=callback->global.find(n); \n\t\t\tpstruct.prop= (v?v->prop:NULL);\n\t\t} \n\t};\n\tinline gld_property(OBJECT *o, char *n) : obj(o), pstruct(nullpstruct)  \n\t{ \n\t\tif (o) \n\t\t\tcallback->properties.get_property(o,n,&pstruct); \n\t\telse \n\t\t{\n\t\t\tGLOBALVAR *v=callback->global.find(n); \n\t\t\tpstruct.prop= (v?v->prop:NULL);\n\t\t} \n\t};\n\tinline gld_property(OBJECT *o) : obj(o), pstruct(nullpstruct) { pstruct.prop=o->oclass->pmap; };\n\tinline gld_property(OBJECT *o, PROPERTY *p) : obj(o), pstruct(nullpstruct) { pstruct.prop=p; };\n\tinline gld_property(OBJECT *o, PROPERTYSTRUCT *p) : obj(o), pstruct(nullpstruct) { pstruct=*p; };\n\tinline gld_property(GLOBALVAR *v) : obj(NULL), pstruct(nullpstruct) { pstruct.prop=v->prop; };\n\tinline gld_property(char *n) : obj(NULL), pstruct(nullpstruct)\n\t{\n\t\tchar oname[256], vname[256];\n\t\tif ( sscanf(n,\"%[A-Za-z0-9_].%[A-Za-z0-9_.]\",oname,vname)==2 )\n\t\t{\n\t\t\tobj = callback->get_object(oname);\n\t\t\tif ( obj )\n\t\t\t{\n\t\t\t\tcallback->properties.get_property(obj,vname,&pstruct);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tGLOBALVAR *v=callback->global.find(n); \n\t\tpstruct.prop = (v?v->prop:NULL);  \n\t};\n\tinline gld_property(char *m, char *n) : obj(NULL), pstruct(nullpstruct) \n\t{\n\t\tobj = callback->get_object(m);\n\t\tif ( obj != NULL ) {\n\t\t\tcallback->properties.get_property(obj, n, &pstruct);\n\t\t\treturn;\n\t\t} \n\t\tchar1024 vn; \n\t\tsprintf(vn,\"%s::%s\",m,n); \n\t\tGLOBALVAR *v=callback->global.find(vn); \n\t\tpstruct.prop= (v?v->prop:NULL);  \n\t};\n\tinline operator PROPERTY*(void) { return pstruct.prop; };\n\tinline operator OBJECT*(void) { return obj; };\n\npublic: // read accessors\n\tinline OBJECT *get_object(void) { return obj; };\n\tinline PROPERTY *get_property(void) { return pstruct.prop; };\n\tinline PROPERTYSTRUCT *get_property_struct(void) { return &pstruct; };\n\tinline gld_class* get_class(void) { return (gld_class*)pstruct.prop->oclass; };\n\tinline char *get_name(void) { return pstruct.prop->name; };\n\tinline char *get_sql_safe_name(char* return_val) {\n\t\tif (pstruct.part[0] != '\\0') {\n\t\t\tsprintf(return_val, \"%s_%s\", pstruct.prop->name, pstruct.part);\n\t\t} else {\n\t\t\tsprintf(return_val, \"%s\", pstruct.prop->name);\n\t\t}\n\t\treturn return_val;\n\t};\n\tinline gld_type get_type(void) { return gld_type(pstruct.prop->ptype); };\n\tinline size_t get_size(void) { return (size_t)(pstruct.prop->size); };\n\tinline size_t get_width(void) { return (size_t)(pstruct.prop->width); };\n\tinline PROPERTYACCESS get_access(void) { return pstruct.prop->access; };\n\tinline bool get_access(unsigned int bits, unsigned int mask=0xffff) {  return ((pstruct.prop->access&mask)|bits); };\n\tinline gld_unit* get_unit(void) { return (gld_unit*)pstruct.prop->unit; };\n\tinline void* get_addr(void) { return obj?((void*)((char*)(obj+1)+(unsigned int64)(pstruct.prop->addr))):pstruct.prop->addr; };\n\tinline gld_keyword* get_first_keyword(void) { return (gld_keyword*)pstruct.prop->keywords; };\n\tinline char* get_description(void) { return pstruct.prop->description; };\n\tinline PROPERTYFLAGS get_flags(void) { return pstruct.prop->flags; };\n\tinline int to_string(char *buffer, int size) { return callback->convert.property_to_string(pstruct.prop,get_addr(),buffer,size); };\n\tinline gld_string get_string(const size_t sz=1024)\n\t{\n\t\tgld_string res;\n\t\tchar buf[1024];\n\t\tif ( sizeof(buf)<sz ) throw \"get_string() over size limit\";\n\t\tif ( to_string(buf,(int)sz)>=0 )\n\t\t\tres = buf;\n\t\treturn res;\n\t};\n\tinline int from_string(char *string) { return callback->convert.string_to_property(pstruct.prop,get_addr(),string); };\n\tinline char *get_partname(void) { return pstruct.part; };\n\tinline double get_part(char *part=NULL) { return callback->properties.get_part(obj,pstruct.prop,part?part:pstruct.part); };\n\npublic: // write accessors\n\tinline void set_object(OBJECT *o) { obj=o; };\n\tinline void set_object(gld_object *o) { obj=o->my(); };\n\tinline void set_property(char *n) { callback->properties.get_property(obj,n,&pstruct); };\n\tinline void set_property(PROPERTY *p) { pstruct.prop=p; };\n\npublic: // special operations\n\tinline bool is_valid(void) { return pstruct.prop!=NULL; }\n\tinline bool has_part(void) { return pstruct.part[0]!='\\0'; };\n\tinline bool is_complex(void) { if(pstruct.prop->ptype == PT_complex) return true; return false;}\n\tinline bool is_double(void) { switch(pstruct.prop->ptype) { case PT_double: case PT_random: case PT_enduse: case PT_loadshape: return true; default: return false;} };\n\tinline bool is_integer(void) { switch(pstruct.prop->ptype) { case PT_int16: case PT_int32: case PT_int64: return true; default: return false;} };\n\tinline bool is_enumeration(void) { return pstruct.prop->ptype==PT_enumeration; };\n\tinline bool is_set(void) { return pstruct.prop->ptype==PT_set; };\n\tinline bool is_character(void) { switch(pstruct.prop->ptype) { case PT_char8: case PT_char32: case PT_char256: case PT_char1024: return true; default: return false;} };\n\tinline bool is_random(void) { return pstruct.prop->ptype==PT_random; };\n\tinline bool is_enduse(void) { return pstruct.prop->ptype==PT_enduse; };\n\tinline bool is_loadshape(void) { return pstruct.prop->ptype==PT_loadshape; };\n\tinline bool is_double_array(void) { return pstruct.prop->ptype==PT_double_array; };\n\tinline bool is_complex_array(void) { return pstruct.prop->ptype==PT_complex_array; };\n\tinline bool is_objectref(void) { return pstruct.prop->ptype==PT_object; };\n\tinline bool is_bool(void) { return pstruct.prop->ptype==PT_bool; };\n\tinline bool is_timestamp(void) { return pstruct.prop->ptype==PT_timestamp; };\n\n\t// TODO these need to use throw instead of returning overloaded values\n\tinline bool get_bool(void) {errno=0; if ( pstruct.prop->ptype != PT_bool ) exception(\"get_bool() called on a property that is not a bool\"); return *(bool*)get_addr();};\n\tinline double get_double(void) { errno=0; switch(pstruct.prop->ptype) { case PT_double: case PT_random: case PT_enduse: case PT_loadshape: return has_part() ? get_part() : *(double*)get_addr(); default: errno=EINVAL; return NaN;} };\n\tinline double get_double(UNIT*to) { double rv = get_double(); return get_unit()->convert(to,rv) ? rv : QNAN; };\n\tinline double get_double(gld_unit&to) { double rv = get_double(); return get_unit()->convert(to,rv) ? rv : QNAN; };\n\tinline double get_double(char*to) { double rv = get_double(); return get_unit()->convert(to,rv) ? rv : QNAN; };\n\tinline complex get_complex(void) { errno=0; if ( pstruct.prop->ptype==PT_complex ) return *(complex*)get_addr(); else return complex(QNAN,QNAN); };\n\tinline int64 get_integer(void) { errno=0; switch(pstruct.prop->ptype) { case PT_int16: return (int64)*(int16*)get_addr(); case PT_int32: return (int64)*(int32*)get_addr(); case PT_int64: return *(int64*)get_addr(); default: errno=EINVAL; return 0;} };\n//\tinline TIMESTAMP get_timestamp(void) { if (pstruct.prop->ptype == PT_timestamp) return *(TIMESTAMP*)get_addr(); exception(\"get_timestamp() called on a property that is not a timestamp\"); };\n\tinline TIMESTAMP get_timestamp(void) { if (pstruct.prop->ptype != PT_timestamp) exception(\"get_timestamp() called on a property that is not a timestamp\");return *(TIMESTAMP*) get_addr();};\n//\tinline enumeration get_enumeration(void) { if ( pstruct.prop->ptype == PT_enumeration ) return *(enumeration*)get_addr(); exception(\"get_enumeration() called on a property that is not an enumeration\"); };\n\tinline enumeration get_enumeration(void) { if ( pstruct.prop->ptype != PT_enumeration ) exception(\"get_enumeration() called on a property that is not an enumeration\"); return *(enumeration*)get_addr(); };\n//\tinline set get_set(void) { if ( pstruct.prop->ptype == PT_set ) return *(set*)get_addr(); exception(\"get_set() called on a property that is not a set\"); };\n\tinline set get_set(void) { if ( pstruct.prop->ptype != PT_set ) exception(\"get_set() called on a property that is not a set\"); return *(set*)get_addr(); };\n\tinline gld_object* get_objectref(void) { if ( is_objectref() ) return ::get_object(*(OBJECT**)get_addr()); else return NULL; };\n\ttemplate <class T> inline void getp(T &value) { ::rlock(&obj->lock); value = *(T*)get_addr(); ::runlock(&obj->lock); };\n\ttemplate <class T> inline void setp(T &value) { ::wlock(&obj->lock); *(T*)get_addr()=value; ::wunlock(&obj->lock); };\n\ttemplate <class T> inline void getp(T &value, gld_rlock&) { value = *(T*)get_addr(); };\n\ttemplate <class T> inline void getp(T &value, gld_wlock&) { value = *(T*)get_addr(); };\n\ttemplate <class T> inline void setp(T &value, gld_wlock&) { *(T*)get_addr()=value; };\n\tinline void setp(enumeration value) { ::wlock(&obj->lock); *(enumeration*)get_addr()=value; ::wunlock(&obj->lock); };\n\tinline void setp(set value) { ::wlock(&obj->lock); *(set*)get_addr()=value; ::wunlock(&obj->lock); };\n\tinline gld_keyword* find_keyword(unsigned long value) { return get_first_keyword()->find(value); };\n\tinline gld_keyword* find_keyword(const char *name) { return get_first_keyword()->find(name); };\n\tinline bool compare(char *op, char *a, char *b=NULL, char *p=NULL) \n\t{ \n\t\tPROPERTYCOMPAREOP n = callback->properties.get_compare_op(pstruct.prop->ptype,op); \n\t\tif (n==TCOP_ERR) throw \"invalid property compare operation\"; \n\t\treturn compare((enumeration)n,a,b,p); \n\t};\n\tinline bool compare(enumeration op, char *a, char *b=NULL) \n\t{ \n\t\tchar v1[1024], v2[1024]; \n\t\treturn callback->convert.string_to_property(pstruct.prop,(void*)v1,a)>0 && callback->properties.compare_basic(pstruct.prop->ptype,(PROPERTYCOMPAREOP)op,get_addr(),(void*)v1,(b&&callback->convert.string_to_property(pstruct.prop,(void*)v2,b)>0)?(void*)v2:NULL, NULL);\n\t};\n\tinline bool compare(enumeration op, char *a, char *b, char *p) \n\t{\n\t\tdouble v1, v2; v1=atof(a); v2=b?atof(b):0;\n\t\treturn callback->properties.compare_basic(pstruct.prop->ptype,(PROPERTYCOMPAREOP)op,get_addr(),(void*)&v1,b?(void*)&v2:NULL, p);\n\t};\n\tinline bool compare(enumeration op, double *a, double *b=NULL, char *p=NULL) \n\t{ \n\t\treturn callback->properties.compare_basic(pstruct.prop->ptype,(PROPERTYCOMPAREOP)op,get_addr(),a,b,p);\n\t};\n\tinline bool compare(enumeration op, void *a, void *b=NULL) \n\t{ \n\t\treturn callback->properties.compare_basic(pstruct.prop->ptype,(PROPERTYCOMPAREOP)op,get_addr(),a,b,NULL);\n\t};\n\npublic: // iterators\n\tinline bool is_last(void) { return pstruct.prop==NULL || pstruct.prop->next==NULL || pstruct.prop->oclass!=pstruct.prop->next->oclass; };\n\tinline PROPERTY* get_next(void) { return is_last() ? NULL : pstruct.prop->next; };\n\npublic: // comparators\n\tinline bool operator == (char* a) { return compare(TCOP_EQ,a,NULL); };\n\tinline bool operator <= (char* a) { return compare(TCOP_LE,a,NULL); };\n\tinline bool operator >= (char* a) { return compare(TCOP_GE,a,NULL); };\n\tinline bool operator != (char* a) { return compare(TCOP_NE,a,NULL); };\n\tinline bool operator < (char* a) { return compare(TCOP_LT,a,NULL); };\n\tinline bool operator > (char* a) { return compare(TCOP_GT,a,NULL); };\n\tinline bool inside(char* a, char* b) { return compare(TCOP_IN,a,b); };\n\tinline bool outside(char* a, char* b) { return compare(TCOP_NI,a,b); };\n\nprivate: // exceptions\n\tinline void exception(const char *msg, ...)\n\t{ \n\t\tstatic char buf[1024]; \n\t\tva_list ptr; \n\t\tva_start(ptr,msg); \n\t\tvsprintf(buf+sprintf(buf,\"%s.%s: \",OBJECTDATA(obj,gld_object)->get_name(),pstruct.prop->name),msg,ptr); \n\t\tva_end(ptr); \n\t\tthrow (const char*)buf;\n\t};\n};\n\n/// Global variable container\nclass gld_global {\n\nprivate: // data\n\tGLOBALVAR *var;\n\npublic: // constructors\n\tinline gld_global(void) { var=callback->global.find(NULL); };\n\tinline gld_global(GLOBALVAR *v) : var(v) {};\n\tinline gld_global(char *n) { var=callback->global.find(n); };\n\tinline gld_global(char *n, PROPERTYTYPE t, void *p) { var=callback->global.create(n,t,p,NULL); };\n\npublic: // read accessors\n\tinline operator GLOBALVAR*(void) { return var; };\n\tinline bool is_valid(void) { return var!=NULL; };\n\tinline PROPERTY* get_property(void) { if (!var) return NULL; return var->prop; };\n\tinline unsigned long get_flags(void) { if (!var) return -1; return var->flags; };\n\tinline size_t to_string(char *bp, size_t sz) { if (!var) return -1; gld_property p(var); return p.to_string(bp,(int)sz); };\n\tinline gld_string get_string(const size_t sz=1024)\n\t{\n\t\tgld_string res;\n\t\tchar buf[1024];\n\t\tif ( sizeof(buf)<sz ) throw \"get_string() over size limit\";\n\t\tif ( to_string(buf,(int)sz)>=0 )\n\t\t\tres = buf;\n\t\treturn res;\n\t};\n\tinline bool get_bool(void) { return *(bool*)(var->prop->addr); };\n\tinline int16 get_int16(void) { return *(int16*)(var->prop->addr); };\n\tinline int32 get_int32(void) { return *(int32*)(var->prop->addr); };\n\tinline int64 get_int64(void) { return *(int64*)(var->prop->addr); };\n\tinline double get_double(void) { return *(double*)(var->prop->addr); };\n\tinline complex get_complex(void) { return *(complex*)(var->prop->addr); };\n\tinline TIMESTAMP get_timestamp(void) { return *(TIMESTAMP*)(var->prop->addr); };\n\npublic: // write accessors\n\tinline size_t from_string(char *bp) { if (!var) return -1; gld_property p(var); return p.from_string(bp); };\n\tinline bool get(char *n) { var=callback->global.find(n); return var!=NULL; };\n\tinline bool create(char *n, PROPERTYTYPE t, void *p) { var=callback->global.create(n,t,p,NULL); return var!=NULL; };\n\npublic: // external accessors\n\t// TODO\n\npublic: // iterators\n\tinline GLOBALVAR* get_first(void) { return callback->global.find(NULL); };\n\tinline bool is_last(void) { if (!var) return false; else return (var->next==NULL); };\n\tinline GLOBALVAR* get_next(void) { if (!var) return NULL; else return var->next; };\n};\n\n/// Aggregation container\nclass gld_aggregate {\nprivate:\n\tAGGREGATION *aggr;\npublic:\n\tinline gld_aggregate(void) { aggr=NULL; };\n\tinline gld_aggregate(char *spec, char *group) { set_aggregate(spec,group); };\npublic:\n\tinline bool set_aggregate(char *spec, char *group) { aggr=callback->aggregate.create(spec,group); return aggr!=NULL; };\n\tinline bool is_valid(void) { return aggr!=NULL; };\n\tinline double get_value(void) { if (!aggr) throw \"null aggregate\"; return callback->aggregate.refresh(aggr); };\n};\n\n/// Object list container\nclass gld_objlist {\nprivate:\n\tstruct s_objlist *list;\npublic:\n\tinline operator OBJLIST*() { return list; };\npublic:\n\tinline gld_objlist(void) : list(NULL) {};\n\tinline gld_objlist(char *group) { list=callback->objlist.search(group); };\n\tinline gld_objlist(CLASS *c, PROPERTY *m, char *p, char *o, void *a, void *b=NULL) { list=callback->objlist.create(c,m,p,o,a,b); };\n\tinline gld_objlist(char *cn, char *mn, char *p, char *o, void *a, void *b=NULL) \n\t{ \n\t\tCLASS *c=callback->class_getname(cn); if (!c) exception(\"gld_objlist(): class '%s' is not found\",cn); \n\t\tPROPERTY *m=callback->find_property(c,mn); if (!m) exception(\"gld_objlist(): property '%s' is not found in class '%s'\",mn,cn);\n\t\tlist=callback->objlist.create(c,m,p,o,a,b); \n\t};\n\tinline ~gld_objlist(void) { callback->objlist.destroy(list); };\npublic:\n\tinline size_t set(char *group) { if ( list ) callback->objlist.destroy(list); list=callback->objlist.search(group); return list?list->size:-1; };\n\tinline size_t add(PROPERTY *m, char *p, char *o, void *a, void *b=NULL) { return callback->objlist.add(list,m,p,o,a,b); };\n\tinline size_t del(PROPERTY *m, char *p, char *o, void *a, void *b=NULL) { return callback->objlist.add(list,m,p,o,a,b); };\n\tinline size_t add(char *cn, char *mn, char *p, char *o, void *a, void *b=NULL) \n\t{\n\t\tCLASS *c=callback->class_getname(cn); if (!c) exception(\"gld_objlist(): class '%s' is not found\",cn); \n\t\tPROPERTY *m=callback->find_property(c,mn); if (!m) exception(\"gld_objlist(): property '%s' is not found in class '%s'\",mn,cn);\n\t\treturn callback->objlist.add(list,m,p,o,a,b); \n\t};\n\tinline size_t del(char *cn, char *mn, char *p, char *o, void *a, void *b=NULL) \n\t{ \n\t\tCLASS *c=callback->class_getname(cn); if (!c) exception(\"gld_objlist(): class '%s' is not found\",cn); \n\t\tPROPERTY *m=callback->find_property(c,mn); if (!m) exception(\"gld_objlist(): property '%s' is not found in class '%s'\",mn,cn);\n\t\treturn callback->objlist.add(list,m,p,o,a,b); \n\t};\npublic:\n\tinline bool is_valid(void) { return list!=NULL; };\n\tinline size_t get_size(void) { return list->size; };\n\tinline OBJECT *get(size_t n) { return list->objlist[n]; };\n\tinline int apply(void *arg, int (*function)(OBJECT *,void*,int)) { return callback->objlist.apply(list,arg,function);};\n\tinline void exception(const char *msg, ...) { static char buf[1024]; va_list ptr; va_start(ptr,msg); vsprintf(buf,msg,ptr); va_end(ptr); throw (const char*)buf;};\n};\n\n/// Web data container\nclass gld_webdata {\nprivate:\n\tstruct s_http {\n\t\tstruct {\n\t\t\tchar *data;\n\t\t\tint size;\n\t\t} header, body; // keep consistent with struct s_http_result in core/http_client.h\n\t\tint status;\n\t} *result;\npublic:\n\tinline gld_webdata(void) {result=NULL;};\n\tinline gld_webdata(char *url, size_t maxlen=4096) {open(url,maxlen);};\n\tinline ~gld_webdata(void) {};\npublic:\n\tinline bool open(char *url, size_t maxlen=4096) { result = (struct s_http*)callback->http.read(url,(int)maxlen); return is_valid();};\n\tinline void close(void) { callback->http.free((void*)result);};\n\tinline bool is_valid(void) { return result!=NULL; };\n\tinline char *get_header(void) { return result->header.data;};\n\tinline size_t get_header_size(void) { return result->header.size; };\n\tinline char *get_body(void) { return result->body.data; };\n\tinline size_t get_body_size(void) { return result->body.size; };\n\tinline int get_status(void) { return result->status; };\n};\n////////////////////////////////////////////////////////////////////////////////////\n// Module-Core Linkage Export Macros\n////////////////////////////////////////////////////////////////////////////////////\n\n#ifdef DLMAIN\nEXPORT int do_kill(void*);\n#ifdef _WIN32\n#define WIN32_LEAN_AND_MEAN\n#include <windows.h>\nEXPORT int gld_major=MAJOR, gld_minor=MINOR; \nBOOL APIENTRY DllMain(HANDLE h, DWORD r) { if (r==DLL_PROCESS_DETACH) do_kill(h); return TRUE; }\n#else // !WIN32\nCDECL int gld_major, gld_minor; \nint gld_major=MAJOR;\nint gld_minor=MINOR;\nCDECL int dllinit() __attribute__((constructor));\nCDECL int dllkill() __attribute__((destructor));\nCDECL int dllinit() { return 0; }\nCDECL int dllkill() { return do_kill(NULL); }\n#endif // !WIN32\n#elif defined CONSOLE\n#ifdef _WIN32\n#define WIN32_LEAN_AND_MEAN\n#include <windows.h>\n#endif\n#include \"console.h\"\n#endif // DLMAIN\n\n#define EXPORT_CREATE_C(X,C) EXPORT int create_##X(OBJECT **obj, OBJECT *parent) \\\n{\ttry { *obj = gl_create_object(C::oclass); \\\n\tif ( *obj != NULL ) { C *my = OBJECTDATA(*obj,C); \\\n\t\tgl_set_parent(*obj,parent); return my->create(); \\\n\t} else return 0; } CREATE_CATCHALL(X); }\n/// Implement class create export\n#define EXPORT_CREATE(X) EXPORT_CREATE_C(X,X)\n\n#define EXPORT_INIT_C(X,C) EXPORT int init_##X(OBJECT *obj, OBJECT *parent) \\\n{\ttry { if (obj!=NULL) return OBJECTDATA(obj,C)->init(parent); else return 0; } \\\n\tINIT_CATCHALL(X); }\n/// Implement class init export\n#define EXPORT_INIT(X) EXPORT_INIT_C(X,X)\n\n#define EXPORT_COMMIT_C(X,C) EXPORT TIMESTAMP commit_##X(OBJECT *obj, TIMESTAMP t1, TIMESTAMP t2) \\\n{\tC *my = OBJECTDATA(obj,C); try { return obj!=NULL ? my->commit(t1,t2) : TS_NEVER; } \\\n\tT_CATCHALL(C,commit); }\n/// Implement class commit export\n#define EXPORT_COMMIT(X) EXPORT_COMMIT_C(X,X)\n\n#define EXPORT_NOTIFY_C(X,C) EXPORT int notify_##X(OBJECT *obj, int notice, PROPERTY *prop, char *value) \\\n{\tC *my = OBJECTDATA(obj,C); try { if ( obj!=NULL ) { \\\n\tswitch (notice) { \\\n\tcase NM_POSTUPDATE: return my->postnotify(prop,value); \\\n\tcase NM_PREUPDATE: return my->prenotify(prop,value); \\\n\tdefault: return 0; } } else return 0; } \\\n\tT_CATCHALL(X,commit); return 1; }\n/// Implement class notify export\n#define EXPORT_NOTIFY(X) EXPORT_NOTIFY_C(X,X)\n\n#define EXPORT_SYNC_C(X,C) EXPORT TIMESTAMP sync_##X(OBJECT *obj, TIMESTAMP t0, PASSCONFIG pass) { \\\n\ttry { TIMESTAMP t1=TS_NEVER; C *p=OBJECTDATA(obj,C); \\\n\tswitch (pass) { \\\n\tcase PC_PRETOPDOWN: t1 = p->presync(t0); break; \\\n\tcase PC_BOTTOMUP: t1 = p->sync(t0); break; \\\n\tcase PC_POSTTOPDOWN: t1 = p->postsync(t0); break; \\\n\tdefault: throw \"invalid pass request\"; break; } \\\n\tif ( (obj->oclass->passconfig&(PC_PRETOPDOWN|PC_BOTTOMUP|PC_POSTTOPDOWN)&(~pass)) <= pass ) obj->clock = t0; \\\n\treturn t1; } \\\n\tSYNC_CATCHALL(X); }\n/// Implement class sync export\n#define EXPORT_SYNC(X) EXPORT_SYNC_C(X,X)\n\n#define EXPORT_ISA_C(X,C) EXPORT int isa_##X(OBJECT *obj, char *name) { \\\n\treturn ( obj!=0 && name!=0 ) ? OBJECTDATA(obj,C)->isa(name) : 0; }\n/// Implement class isa export\n#define EXPORT_ISA(X) EXPORT_ISA_C(X,X)\n\n#define EXPORT_PLC_C(X,C) EXPORT TIMESTAMP plc_##X(OBJECT *obj, TIMESTAMP t1) { \\\n\ttry { return OBJECTDATA(obj,C)->plc(t1); } \\\n\tT_CATCHALL(plc,X); }\n/// Implement class plc export\n#define EXPORT_PLC(X) EXPORT_PLC_C(X,X)\n\n// TODO add other linkages as needed\n#define EXPORT_PRECOMMIT_C(X,C) EXPORT int precommit_##X(OBJECT *obj, TIMESTAMP t1) \\\n{\tC *my = OBJECTDATA(obj,C); try { return obj!=NULL ? my->precommit(t1) : 0; } \\\n\tT_CATCHALL(C,precommit); }\n/// Implement class precommit export\n#define EXPORT_PRECOMMIT(X) EXPORT_PRECOMMIT_C(X,X)\n\n#define EXPORT_FINALIZE_C(X,C) EXPORT int finalize_##X(OBJECT *obj) \\\n{\tC *my = OBJECTDATA(obj,C); try { return obj!=NULL ? my->finalize() : 0; } \\\n\tT_CATCHALL(C,finalize); }\n/// Implement class finalize export\n#define EXPORT_FINALIZE(X) EXPORT_FINALIZE_C(X,X)\n\n#define EXPORT_NOTIFY_C_P(X,C,P) EXPORT int notify_##X##_##P(OBJECT *obj, char *value) \\\n{\tC *my = OBJECTDATA(obj,C); try { if ( obj!=NULL ) { \\\n\treturn my->notify_##P(value); \\\n\t} else return 0; } \\\n\tT_CATCHALL(X,notify_##P); return 1; }\n/// Implement property notify export\n#define EXPORT_NOTIFY_PROP(X,P) EXPORT_NOTIFY_C_P(X,X,P)\n\n#define EXPORT_LOADMETHOD_C(X,C,N) EXPORT int loadmethod_##X##_##N(OBJECT *obj, char *value) \\\n{\tC *my = OBJECTDATA(obj,C); try { if ( obj!=NULL ) { \\\n\treturn my->N(value); \\\n\t} else return 0; } \\\n\tT_CATCHALL(X,loadmethod); }\n#define EXPORT_LOADMETHOD(X,N) EXPORT_LOADMETHOD_C(X,X,N)\n\n\n#define DECL_METHOD(X,N) EXPORT int method_##X##_##N(OBJECT *obj, char *value, size_t size)\n#define EXPORT_METHOD_C(X,C,N) DECL_METHOD(X,N) \\\n\t\t{\tC *my = OBJECTDATA(obj,C); try { if ( obj!=NULL ) { \\\n\t\t\treturn my->N(value,size); \\\n\t\t\t} else return 0; } \\\n\t\t\tT_CATCHALL(X,method); }\n\t\t#define EXPORT_METHOD(X,N) EXPORT_METHOD_C(X,X,N)\n\n#endif\n\n/****************************************\n * GENERAL SOLVERS \n ****************************************/\n#ifdef USE_GLSOLVERS\n\n#if defined WIN32 && ! defined __MINGW32__\n\t#define _WIN32_WINNT 0x0400\n\t#undef int64 // wtypes.h also used int64\n\t#include <windows.h>\n\t#define int64 _int64\n\t#define PREFIX \"\"\n\t#ifndef DLEXT\n\t\t#define DLEXT \".dll\"\n\t#endif\n\t#define DLLOAD(P) LoadLibrary(P)\n\t#define DLSYM(H,S) GetProcAddress((HINSTANCE)H,S)\n\t#define snprintf _snprintf\n#else /* ANSI */\n#ifndef __MINGW32__\n\t#include \"dlfcn.h\"\n#endif\n\t#define PREFIX \"\"\n\t#ifndef DLEXT\n\t\t#define DLEXT \".so\"\n\t#endif\n#ifndef __MINGW32__\n\t#define DLLOAD(P) dlopen(P,RTLD_LAZY)\n#else\n\t#include \"dlfcn.h\"\n\t#define DLLOAD(P) dlopen(P,RTLD_LAZY)\n#endif\n\t#define DLSYM(H,S) dlsym(H,S)\n#endif\n\nclass glsolver {\npublic:\n\tint (*init)(void*);\n\tint (*solve)(void*);\n\tint (*set)(char*,...);\n\tint (*get)(char*,...);\nprivate:\n\tinline void exception(const char *fmt,...)\n\t{\n\t\tstatic char buffer[1024]=\"\";\n\t\tva_list ptr;\n\t\tva_start(ptr,fmt);\n\t\tint len = vsprintf(buffer,fmt,ptr);\n\t\tva_end(ptr);\n\t\tif ( errno!=0 )\n\t\t\tsprintf(buffer+len,\" (%s)\", strerror(errno));\n\t\tthrow (const char*)buffer;\n\t};\npublic:\n\tinline glsolver(char *name, char *lib=\"glsolvers\" DLEXT)\n\t{\n\t\tchar path[1024];\n\t\terrno = 0;\n\t\tif ( callback->file.find_file(lib,NULL,X_OK,path,sizeof(path))!=NULL )\n\t\t{\n\t\t\terrno = 0;\n\t\t\tvoid* handle = DLLOAD(path);\n\t\t\tif ( handle==NULL )\n\t\t\t\texception(\"glsolver(char *name='%s'): load of '%s' failed\",name,path);\n\t\t\telse\n\t\t\t{\n\t\t\t\tchar fname[64];\n\t\t\t\tstruct {\n\t\t\t\t\tchar *part;\n\t\t\t\t\tvoid **func;\n\t\t\t\t} map[] = {\n\t\t\t\t\t{\"init\", (void**)&init},\n\t\t\t\t\t{\"solve\", (void**)&solve},\n\t\t\t\t\t{\"set\", (void**)&set},\n\t\t\t\t\t{\"get\", (void**)&get},\n\t\t\t\t};\n\t\t\t\tint n;\n\t\t\t\tfor ( n=0 ; n<sizeof(map)/sizeof(map[0]) ; n++ )\n\t\t\t\t{\n\t\t\t\t\tstrcpy(fname,name);\n\t\t\t\t\tstrcat(fname,\"_\");\n\t\t\t\t\tstrcat(fname,map[n].part);\n\t\t\t\t\terrno = 0;\n\t\t\t\t\t*(map[n].func) = (void*)DLSYM(handle,fname);\n\t\t\t\t\tif ( *(map[n].func)==NULL )\n\t\t\t\t\t\texception(\"glsolver(char *name='%s'): function '%s' not found in '%s'\",name,fname,path);\n\t\t\t\t}\n\t\t\t\terrno = 0;\n\t\t\t\tif ( !(*init)(callback) )\n\t\t\t\t\texception(\"glsolver(char *name='%s'): init failed\",name);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\texception(\"glsolver(char *name='%s'): solver library '%s' not found\", name, lib);\n\t};\n};\n\n#endif // __cplusplus\n\n/** @} **/\n#endif\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/gldcore/class.c": "/** $Id: class.c 4738 2014-07-03 00:55:39Z dchassin $\n\tCopyright (C) 2008 Battelle Memorial Institute\n\t@file class.c\n\t@addtogroup class Classes of objects\n\t@ingroup core\n **/\n\n#include \"exec.h\"\n#include \"property.h\"\n#include \"class.h\"\n#include \"output.h\"\n#include \"convert.h\"\n#include \"module.h\"\n#include \"exception.h\"\n#include \"timestamp.h\"\n#include \"loadshape.h\"\n#include \"enduse.h\"\n#include \"stream.h\"\n#include \"gldrandom.h\"\n\n#if defined(_WIN32) && !defined(__MINGW32__)\n#define WIN32_LEAN_AND_MEAN\t\t// Exclude rarely-used stuff from Windows headers\n#define _WIN32_WINNT 0x0400\n#include <windows.h>\n#ifndef DLEXT\n#define DLEXT \".dll\"\n#endif\n#define DLLOAD(P) LoadLibrary(P)\n#define DLSYM(H,S) (void *)GetProcAddress((HINSTANCE)H,S)\n#define snprintf _snprintf\n#else /* ANSI */\n#include \"dlfcn.h\"\n#ifndef DLEXT\n#ifdef __MINGW32__\n#define DLEXT \".dll\"\n#else\n#define DLEXT \".so\"\n#endif\n#endif\n#define DLLOAD(P) dlopen(P,RTLD_LAZY)\n#define DLSYM(H,S) dlsym(H,S)\n#endif\nstatic unsigned int class_count = 0;\n\n/* defined in property.c */\nextern struct s_property_specs property_type[_PT_LAST];\n\n/* object class list */\nstatic CLASS *first_class = NULL; /**< first class in class list */\nstatic CLASS *last_class = NULL; /**< last class in class list */\n\n/** Get the first property in a class's property list.\n\tAll subsequent properties that have the same class\n\tcan be scanned.  Be careful not to scan off the end\n\tof the list onto the next class.  The iterator\n\tshould look like this\n\n\t@code\n\tPROPERTY *p;\n\tfor (p=class_get_first_property(oclass);\n\t\tp!=NULL && p->otype==oclass->type;\n\t\tp=p->next)\n\t{\n\t// your code goes here\n\t}\n\t@endcode\n\n\t@return a pointer to first PROPERTY in the CLASS definition,\n\tor \\p NULL is none defined\n **/\nPROPERTY *class_get_first_property(CLASS *oclass) /**< the object class */\n{\n\tif (oclass==NULL)\n\t\tthrow_exception(\"class_get_first_property(CLASS *oclass=NULL): oclass is NULL\");\n\t\t/* TROUBLESHOOT\n\t\t\tA call to <code>class_get_first_property()</code> was made with a NULL pointer.\n\t\t\tThis is a bug and should be reported.\n\t\t */\n\treturn oclass->pmap;\n}\n\n/** Get the next property of within the current class\n\t@return a pointer to the PROPERTY, or \\p NULL if there are no properties left\n **/\nPROPERTY *class_get_next_property(PROPERTY *prop)\n{\n\tif (prop->next && prop->oclass==prop->next->oclass)\n\t\treturn prop->next;\n\telse\n\t\treturn NULL;\n}\n\n/** Search class hierarchy for a property\n\t@return property pointer if found, NULL if not in class hierarchy\n **/\nPROPERTY *class_prop_in_class(CLASS *oclass, PROPERTY *prop)\n{\n\tif(oclass == prop->oclass)\n\t{\n\t\treturn prop;\n\t}\n\telse\n\t{\n\t\tif(oclass->parent != NULL)\n\t\t{\n\t\t\treturn class_prop_in_class(oclass->parent, prop);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn NULL;\n\t\t}\n\t}\n}\n\n#if 0\n/** Get the size of a single instance of a property\n\t@return the size in bytes of the a property\n **/\nuint32 property_size(PROPERTY *prop)\n{\n\tif (prop && prop->ptype>_PT_FIRST && prop->ptype<_PT_LAST)\n\t\treturn property_type[prop->ptype].size;\n\telse\n\t\treturn 0;\n}\n\nuint32 property_size_by_type(PROPERTYTYPE type)\n{\n\treturn property_type[type].size;\n}\n\nint property_create(PROPERTY *prop, void *addr)\n{\n\tif (prop && prop->ptype>_PT_FIRST && prop->ptype<_PT_LAST)\n\t{\n\t\tif (property_type[prop->ptype].create)\n\t\t\treturn property_type[prop->ptype].create(addr);\n\t\t//memset(addr,0,(prop->size==0?1:prop->size)*property_type[prop->ptype].size);\n\t\tmemset(addr,0,property_type[prop->ptype].size);\n\t\treturn 1;\n\t}\n\telse\n\t\treturn 0;\n}\n#endif\n\n/* though improbable, this is to prevent more complicated, specifically crafted\n\tinheritence loops.  these should be impossible if a class_register call is\n\timmediately followed by a class_define_map call. -d3p988 */\nPROPERTY *class_find_property_rec(CLASS *oclass, \n                                  PROPERTYNAME name, \n                                  CLASS *pclass)\n{\n\tPROPERTY *prop;\n\tfor (prop=oclass->pmap; prop!=NULL && prop->oclass==oclass; prop=prop->next)\n\t{\n\t\tif (strcmp(name,prop->name)==0)\n\t\t\treturn prop;\n\t}\n\tif (oclass->parent==pclass)\n\t{\n\t\toutput_error(\"class_find_property_rec(CLASS *oclass='%s', PROPERTYNAME name='%s', CLASS *pclass='%s') causes an infinite class inheritance loop\", oclass->name, name, pclass->name);\n\t\t/*\tTROUBLESHOOT\n\t\t\tA class has somehow specified itself as a parent class, either directly or indirectly.\n\t\t\tThis means there is a problem with the module that publishes the class.\n\t\t */\n\t\treturn NULL;\n\t}\n\telse if (oclass->parent!=NULL)\n\t\treturn class_find_property_rec(oclass->parent,name, pclass);\n\telse\n\t\treturn NULL;\n\n}\n\nstatic PROPERTY *find_header_property(CLASS *oclass, \n                                      PROPERTYNAME name)\n{\n\tPROPERTY *prop = NULL;\n\treturn prop;\n}\n\n/** Find the named property in the class\n\n\t@return a pointer to the PROPERTY, or \\p NULL if the property is not found.\n **/\nPROPERTY *class_find_property(CLASS *oclass,     /**< the object class */\n                              PROPERTYNAME name) /**< the property name */\n{\n\tPROPERTY *prop = find_header_property(oclass,name);\n\tif ( prop ) return prop;\n\n\tif(oclass == NULL)\n\t\treturn NULL;\n\n\tfor (prop=oclass->pmap; prop!=NULL && prop->oclass==oclass; prop=prop->next)\n\t{\n\t\tif (strcmp(name,prop->name)==0)\n\t\t{\n\t\t\tif (prop->flags&PF_DEPRECATED && !(prop->flags&PF_DEPRECATED_NONOTICE) && !global_suppress_deprecated_messages)\n\t\t\t{\n\t\t\t\toutput_warning(\"class_find_property(CLASS *oclass='%s', PROPERTYNAME name='%s': property is deprecated\", oclass->name, name);\n\t\t\t\t/* TROUBLESHOOT\n\t\t\t\t\tYou have done a search on a property that has been flagged as deprecated and will most likely not be supported soon.\n\t\t\t\t\tCorrect the usage of this property to get rid of this message.\n\t\t\t\t */\n\t\t\t\tif (global_suppress_repeat_messages)\n\t\t\t\t\tprop->flags |= ~PF_DEPRECATED_NONOTICE;\n\t\t\t}\n\t\t\treturn prop;\n\t\t}\n\t}\n\tif (oclass->parent==oclass)\n\t{\n\t\toutput_error(\"class_find_property(oclass='%s', name='%s') causes an infinite class inheritance loop\", oclass->name, name);\n\t\t/*\tTROUBLESHOOT\n\t\t\tA class has somehow specified itself as a parent class, either directly or indirectly.\n\t\t\tThis means there is a problem with the module that publishes the class.\n\t\t */\n\t\treturn NULL;\n\t}\n\telse if (oclass->parent!=NULL)\n\t\treturn class_find_property_rec(oclass->parent,name, oclass);\n\telse\n\t\treturn NULL;\n}\n\n/** Add a property to a class\n **/\nvoid class_add_property(CLASS *oclass,  /**< the class to which the property is to be added */\n                        PROPERTY *prop) /**< the property to be added */\n{\n\tPROPERTY *last = oclass->pmap;\n\twhile (last!=NULL && last->next!=NULL)\n\t\tlast = last->next;\n\tif (last==NULL)\n\t\toclass->pmap = prop;\n\telse\n\t\tlast->next = prop;\n}\n\n/** Add an extended property to a class \n    @return the property pointer\n **/\nPROPERTY *class_add_extended_property(CLASS *oclass,      /**< the class to which the property is to be added */\n                                      char *name,         /**< the name of the property */\n                                      PROPERTYTYPE ptype, /**< the type of the property */\n                                      char *unit)         /**< the unit of the property */\n{\n\tPROPERTY *prop = malloc(sizeof(PROPERTY));\n\tUNIT *pUnit = NULL;\n\n\tTRY {\n\t\tif (unit)\n\t\t\tpUnit = unit_find(unit);\n\t} CATCH (char *msg) {\n\t\t// will get picked up later\n\t} ENDCATCH;\n\n\tif (prop==NULL)\n\t\tthrow_exception(\"class_add_extended_property(oclass='%s', name='%s', ...): memory allocation failed\", oclass->name, name);\n\t\t/* TROUBLESHOOT\n\t\t\tThe system has run out of memory.  Try making the model smaller and trying again.\n\t\t */\n\tif (ptype<=_PT_FIRST || ptype>=_PT_LAST)\n\t\tthrow_exception(\"class_add_extended_property(oclass='%s', name='%s', ...): property type is invalid\", oclass->name, name);\n\t\t/* TROUBLESHOOT\n\t\t\tThe function was called with a property type that is not recognized.  This is a bug that should be reported.\n\t\t */\n\tif (unit!=NULL && pUnit==NULL)\n\t\tthrow_exception(\"class_add_extended_property(oclass='%s', name='%s', ...): unit '%s' is not found\", oclass->name, name, unit);\n\t\t/* TROUBLESHOOT\n\t\t\tThe function was called with unit that is defined in units file <code>.../etc/unitfile.txt</code>.  Try using a defined unit or adding\n\t\t\tthe desired unit to the units file and try again.\n\t\t */\n\tmemset(prop, 0, sizeof(PROPERTY));\n\tprop->access = PA_PUBLIC;\n\tprop->addr = (void*)(int64)oclass->size;\n\tprop->size = 0;\n\tprop->delegation = NULL;\n\tprop->flags = PF_EXTENDED;\n\tprop->keywords = NULL;\n\tprop->description = NULL;\n\tprop->unit = pUnit;\n\tstrncpy(prop->name,name,sizeof(prop->name));\n\tprop->next = NULL;\n\tprop->oclass = oclass;\n\tprop->ptype = ptype;\n\tprop->width = property_type[ptype].size;\n\n\toclass->size += property_type[ptype].size;\n\n\tclass_add_property(oclass,prop);\n\treturn prop;\n}\n\n/** Get the last registered class\n    @return the last class registered\n **/\nCLASS *class_get_last_class(void)\n{\n\treturn last_class;\n}\n\n/** Get the number of registered class\n\t@return the number of classes registered\n **/\nunsigned int class_get_count(void)\n{\n\treturn class_count;\n}\n\n/** Get the name of a property from its type\n\t@return a pointer to a string containing the name of the property type\n **/\nchar *class_get_property_typename(PROPERTYTYPE type) /**< the property type */\n{\n\tif (type<=_PT_FIRST || type>=_PT_LAST)\n\t\treturn \"//UNDEF//\";\n\telse\n\t\treturn property_type[type].name;\n}\n\n/** Get the name of a property from its type\n\t@return a pointer to a string containing the name of the property type\n **/\nchar *class_get_property_typexsdname(PROPERTYTYPE type) /**< the property type */\n{\n\tif (type<=_PT_FIRST || type>=_PT_LAST)\n\t\treturn \"//UNDEF//\";\n\telse\n\t\treturn property_type[type].xsdname;\n}\n\n\n/** Get the type of a property from its \\p name\n\t@return the property type\n **/\nPROPERTYTYPE class_get_propertytype_from_typename(char *name) /**< a string containing the name of the property type */\n{\n\tint i;\n\tfor (i=0; i<sizeof(property_type)/sizeof(property_type[0]); i++)\n\t{\n\t\tif (strcmp(property_type[i].name,name)==0)\n\t\t\treturn i;\n\t}\n\treturn PT_void;\n}\n\n/** Convert a string to a property of the given type\n    @return non-zero on success, 0 on failure\n **/\nint class_string_to_propertytype(PROPERTYTYPE type, \n                                 void *addr, \n                                 char *value)\n{\n\tif (type > _PT_FIRST && type < _PT_LAST)\n\t\treturn (*property_type[type].string_to_data)(value,addr,NULL);\n\telse\n\t\treturn 0;\n}\n/** Convert a string value to property data.\n\tThe \\p addr must be the physical address in memory.\n\t@return the number of value read from the \\p value string; 0 on failure\n **/\nint class_string_to_property(PROPERTY *prop, /**< the type of the property at the \\p addr */\n                             void *addr,     /**< the address of the property's data */\n                             char *value)    /**< the string from which the data is read */\n{\n\tif (prop->ptype > _PT_FIRST && prop->ptype < _PT_LAST)\n\t\treturn (*property_type[prop->ptype].string_to_data)(value,addr,prop);\n\telse\n\t\treturn 0;\n}\n\n/** Convert a property value to a string.\n\tThe \\p addr must be the physical address in memory.\n\t@return the number character written to \\p value\n **/\nint class_property_to_string(PROPERTY *prop, /**< the property type */\n                             void *addr,     /**< the address of the property's data */\n                             char *value,    /**< the value buffer to which the string is to be written */\n                             int size)       /**< the maximum number of characters that can be written to the \\p value buffer*/\n{\n\tint rv = 0;\n\tif (prop->ptype==PT_delegated)\n\t{\n\t\toutput_error(\"unable to convert from delegated property value\");\n\t\t/*\tTROUBLESHOOT\n\t\t\tProperty delegation is not yet fully implemented, so you should never get this error.\n\t\t\tIf you do, there is a problem with the system that is causing it to become unstable.\n\t\t */\n\t\treturn 0;\n\t}\n\telse if (prop->ptype>_PT_FIRST && prop->ptype<_PT_LAST){\n\t\t// note, need to append unit type\n\t\trv = (*property_type[prop->ptype].data_to_string)(value,size,addr,prop);\n\t\tif(rv > 0 && prop->unit != 0)\n\t\t{\n\t\t\tstrcat(value+rv,\" \");\n\t\t\tstrcat(value+rv+1,prop->unit->name);\n\t\t\trv += (int)(1+strlen(prop->unit->name));\n\t\t}\n\t}\n\telse\n\t{\n\t\trv = 0;\n\t}\n\treturn rv;\n}\n\n\n/** Register an object class\n\t@return the object class; \\p NULL on error \\p errno:\n\t- \\p E2BIG: class name too long\n\t- \\p ENOMEM: memory allocation failed\n\n **/\nCLASS *class_register(MODULE *module,        /**< the module that implements the class */\n                      CLASSNAME name,        /**< the class name */\n                      unsigned int size,     /**< the size of the data block */\n                      PASSCONFIG passconfig) /**< the passes for which \\p sync should be called */\n{\n\tCLASS *oclass = class_get_class_from_classname(name);\n\n\t/* check the property list */\n\tint a = sizeof(property_type);\n\tint b = sizeof(property_type[0]);\n\tint c = _PT_LAST - _PT_FIRST - 1;\n\n\tif (_PT_LAST-_PT_FIRST-1!=sizeof(property_type)/sizeof(property_type[0]))\n\t{\n\t\toutput_fatal(\"property_type[] in class.c has an incorrect number of members (%i vs %i)\", a/b, c);\n\t\t/* TROUBLESHOOT\n\t\t\tThis error occurs when an improper definition of a class is used.  This is not usually\n\t\t\tcaused by an error in a GLM file but is most likely caused by a bug in a module\n\t\t\tor incorrectly defined class.\n\t\t */\n\t\texit(XC_EXCEPTION);\n\t}\n\tif (oclass!=NULL)\n\t{\n\t\tif(strcmp(oclass->module->name, module->name) == 0){\n\t\t\toutput_error(\"module %s cannot register class %s, it is already registered by module %s\", module->name,name,oclass->module->name);\n\t\t\t/*\tTROUBLESHOOT\n\t\t\t\tThis error is caused by an attempt to define a new class which is already\n\t\t\t\tdefined in the module or namespace given.  This is generally caused by\n\t\t\t\tbug in a module or an incorrectly defined class.\n\t\t\t */\n\t\t\treturn NULL;\n\t\t} else {\n\t\t\toutput_verbose(\"module %s is registering a 2nd class %s, previous one in module %s\", module->name, name, oclass->module->name);\n\t\t}\n\t}\n\tif (strlen(name)>=sizeof(oclass->name) )\n\t{\n\t\terrno = E2BIG;\n\t\treturn 0;\n\t}\n\toclass = (CLASS*)malloc(sizeof(CLASS));\n\tif (oclass==NULL)\n\t{\n\t\terrno = ENOMEM;\n\t\treturn 0;\n\t}\n\tmemset(oclass,0,sizeof(CLASS));\n\toclass->magic = CLASSVALID;\n\toclass->id = \tclass_count++;\n\toclass->module = module;\n\tstrncpy(oclass->name,name,sizeof(oclass->name));\n\toclass->size = size;\n\toclass->passconfig = passconfig;\n\toclass->profiler.numobjs=0;\n\toclass->profiler.count=0;\n\toclass->profiler.clocks=0;\n\tif (first_class==NULL)\n\t\tfirst_class = oclass;\n\telse\n\t\tlast_class->next = oclass;\n\tlast_class = oclass;\n\toutput_verbose(\"class %s registered ok\", name);\n\treturn oclass;\n}\n\n/** Get the first registered class\n\t@return a pointer to the first registered CLASS,\n\tor \\p NULL if none registered.\n **/\nCLASS *class_get_first_class(void)\n{\n\treturn first_class;\n}\n\n/** Get the class from the class name and a module pointer.\n\t@return a pointer to the class registered to that module\n\thaving that \\p name, or \\p NULL if no match found.\n **/\nCLASS *class_get_class_from_classname_in_module(char *name, MODULE *mod){\n\tCLASS *oclass = NULL;\n\tif(name == NULL) return NULL;\n\tif(mod == NULL) return NULL;\n\tfor (oclass=first_class; oclass!=NULL; oclass=oclass->next)\n\t{\n\t\tif(oclass->module == (MODULE *)mod)\n\t\t\tif(strcmp(oclass->name,name)==0)\n\t\t\t\treturn oclass;\n\t}\n\treturn NULL;\n}\n\n/** Get the number of runtime classes defined\n    @return the number of runtime classes defined\n **/\nsize_t class_get_runtimecount(void)\n{\n\tCLASS *oclass;\n\tsize_t count = 0;\n\tfor ( oclass=first_class ; oclass!=NULL ; oclass=oclass->next )\n\t{\n\t\tif ( oclass->has_runtime )\n\t\t\tcount++;\n\t}\n\treturn count;\n}\n\n/** Get the first runtime class defined\n    @return the pointer to the first runtime class\n **/\nCLASS *class_get_first_runtime(void)\n{\n\tCLASS *oclass;\n\tfor ( oclass=first_class ; oclass!=NULL ; oclass=oclass->next )\n\t{\n\t\tif ( oclass->has_runtime )\n\t\t\treturn oclass;\n\t}\n\treturn NULL;\n}\n\n/** Get the next runtime class defined\n    @return the point to the next runtime class\n **/\nCLASS *class_get_next_runtime(CLASS *oclass) /**< the class to search from */\n{\n\toclass=oclass->next;\n\twhile ( oclass!=NULL )\n\t{\n\t\tif ( oclass->has_runtime )\n\t\t\treturn oclass;\n\t\toclass=oclass->next;\n\t}\n\treturn NULL;\n}\n/** get count of extended properties */\nsize_t class_get_extendedcount(CLASS *oclass)\n{\n\tPROPERTY *prop;\n\tsize_t count = 0;\n\tfor ( prop=oclass->pmap ; prop!=NULL ; prop=prop->next )\n\t{\n\t\tif ( prop->flags&PF_EXTENDED ) count++;\n\t}\n\treturn count;\n}\n\n/** Get the class from the class name.\n\t@return a pointer to the class having that \\p name,\n\tor \\p NULL if no match found.\n **/\nCLASS *class_get_class_from_classname(char *name) /**< a pointer to a \\p NULL -terminated string containing the class name */\n{\n\tCLASS *oclass = NULL;\n\tMODULE *mod = NULL;\n\tchar *ptr = NULL;\n\tchar temp[1024]; /* we get access violations when name is from another DLL. -mh */\n\tstrcpy(temp, name);\n\tptr = strchr(temp, '.');\n\tif(ptr != NULL){\t/* check module for the class */\n\t\tptr[0] = 0;\n\t\t++ptr;\n\t\tmod = module_find(temp);\n\t\tif(mod == NULL){\n\t\t\toutput_verbose(\"could not search for '%s.%s', module not loaded\", name, ptr);\n\t\t\treturn NULL;\n\t\t}\n\t\tfor (oclass=first_class; oclass!=NULL; oclass=oclass->next)\n\t\t{\n\t\t\tif(oclass->module == mod)\n\t\t\t\tif(strcmp(oclass->name,ptr)==0)\n\t\t\t\t\treturn oclass;\n\t\t}\n\t\treturn NULL;\n\t}\n\tfor (oclass=first_class; oclass!=NULL; oclass=oclass->next)\n\t{\n\t\tif (strcmp(oclass->name,name)==0)\n\t\t\treturn oclass;\n\t}\n\treturn NULL;\n}\n\n/** Define one or more class properties.\n\n\tThe variable argument list must be \\p NULL -terminated.\n\tEach property declaration begins with a PROPERTYTYPE value,\n\tfollowed by a \\e char* pointing to the name of the\n\tproperty, followed the offset from the end of the\n\tOBJECT header's address (or the absolution address of the data\n\tif PT_SIZE is used).  If the property name includes units in square\n\tbrackets, they will be separated from the name and added to\n\tthe property's definition, provided the are defined in the\n\tfile \\b unitfile.txt.\n\n\tYou may use the flag PT_INHERIT to specify a parent class from which\n\tto inherit published properties.  If this is used, you may add the\n\tPC_UNSAFE_OVERRIDE_OMIT flag in class_register to force child classes\n\tto use all the pass configured.\n\n\tYou may use special flags to customize the property registration:\n\t- \\p PT_ACCESS will set special access rights (see PROPERTYACCESS)\n\t- \\p PT_SIZE will cause memory to be allocated for the value.  If\n\t  \\p addr is non-NULL, the data is points to will be converted to\n\t  the property.\n\t- \\p PT_FLAGS will allow you set property flags (see PROPERTYFLAGS)\n\t- \\p PT_INHERIT will allow you to include the parent classes properties\n\t- \\p PT_UNITS will allow you to specify the units (instead of using [] syntax)\n\t- \\p PT_EXTEND will expand the size of the class by the size of the property being mapped\n\t- \\p PT_EXTENDBY will expand the size of the class by the unsigned int provided in the next argument\n\n\t@return a count of variables mapped; <=0 indicates not all mapped\n\t(-count successfully mapped before it failed), errno:\n\t- \\p E2BIG: variable name too long to store\n\t- \\p ENOMEM: memory allocation failed\n\t- \\p ENOENT: \\p oclass type not found\n\t- \\p EINVAL: keyword is invalid\n **/\nint class_define_map(CLASS *oclass, /**< the object class */\n                     ...) /**< definition arguments (see remarks) */\n{\n\tva_list arg;\n\tPROPERTYTYPE proptype;\n\tint count=0;\n\tPROPERTY *prop=NULL;\n\tva_start(arg,oclass);\n\terrno = 0;\n\twhile ((proptype=va_arg(arg,PROPERTYTYPE))!=0)\n\t{\n\t\tif (proptype>_PT_LAST)\n\t\t{\n\t\t\tif (proptype==PT_INHERIT)\n\t\t\t{\n\t\t\t\tif (oclass->parent!=NULL)\n\t\t\t\t{\n\t\t\t\t\terrno = EINVAL;\n\t\t\t\t\toutput_error(\"class_define_map(oclass='%s',...): PT_INHERIT unexpected; class already inherits properties from class %s\", oclass->name, oclass->parent);\n\t\t\t\t\t/* TROUBLESHOOT\n\t\t\t\t\t\tThis error is caused by an attempt to incorrectly specify a class that\n\t\t\t\t\t\tinherits variables from more than one other class.  This is almost\n\t\t\t\t\t\talways caused by a bug in the module's constructor for that class.\n\t\t\t\t\t */\n\t\t\t\t\tgoto Error;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tchar *classname = va_arg(arg,char*);\n\t\t\t\t\tPASSCONFIG no_override;\n\t\t\t\t\toclass->parent = class_get_class_from_classname_in_module(classname,oclass->module);\n\t\t\t\t\tif (oclass->parent==NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\terrno = EINVAL;\n\t\t\t\t\t\toutput_error(\"class_define_map(oclass='%s',...): parent property class name '%s' is not defined\", oclass->name, classname);\n\t\t\t\t\t\t/*\tTROUBLESHOOT\n\t\t\t\t\t\t\tA class is trying to inherit properties from another class that has not been defined.\n\t\t\t\t\t\t\tThis is usually caused by a problem in the module(s) that publishes the classes.  Either\n\t\t\t\t\t\t\tthe child class is in not specifying the parent class correctly, or the parent class is\n\t\t\t\t\t\t\tnot created before the child class.  If the child class depends on a class implemented\n\t\t\t\t\t\t\tin another module, the module publishing the child class must load the module publishing\n\t\t\t\t\t\t\tthe parent class before attempting to use it.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tgoto Error;\n\t\t\t\t\t}\n\t\t\t\t\tif (oclass->parent == oclass){\n\t\t\t\t\t\terrno = EINVAL;\n\t\t\t\t\t\toutput_error(\"class_define_map(oclass='%s',...): parent property class name '%s' attempting to inherit from self!\", oclass->name, classname);\n\t\t\t\t\t\t/*\tTROUBLESHOOT\n\t\t\t\t\t\t\tA class is attempting to directly inherit properties from itself.  This is caused by\n\t\t\t\t\t\t\ta problem with the module that publishes the class.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tgoto Error;\n\t\t\t\t\t}\n\t\t\t\t\tno_override = ~(~oclass->parent->passconfig|oclass->passconfig); /* parent bool-implies child (p->q=~p|q) */\n\t\t\t\t\tif (oclass->parent->passconfig&PC_UNSAFE_OVERRIDE_OMIT\n\t\t\t\t\t\t\t&& !(oclass->passconfig&PC_PARENT_OVERRIDE_OMIT)\n\t\t\t\t\t\t\t&& no_override&PC_PRETOPDOWN)\n\t\t\t\t\t\toutput_warning(\"class_define_map(oclass='%s',...): class '%s' suppresses parent class '%s' PRETOPDOWN sync behavior by omitting override\", oclass->name, oclass->name, oclass->parent->name);\n\t\t\t\t\t\t/*\tTROUBLESHOOT\n\t\t\t\t\t\t\tA class is suppressing the <i>presync</i> event implemented by its parent\n\t\t\t\t\t\t\teven though the parent is published with a flag that indicates this is unsafe.  Presumably\n\t\t\t\t\t\t\tthis is deliberate, but the warning is given just in case it's not intended.\n\t\t\t\t\t\t */\n\t\t\t\t\tif (oclass->parent->passconfig&PC_UNSAFE_OVERRIDE_OMIT\n\t\t\t\t\t\t\t&& !(oclass->passconfig&PC_PARENT_OVERRIDE_OMIT)\n\t\t\t\t\t\t\t&& no_override&PC_BOTTOMUP)\n\t\t\t\t\t\toutput_warning(\"class_define_map(oclass='%s',...): class '%s' suppresses parent class '%s' BOTTOMUP sync behavior by omitting override\", oclass->name, oclass->name, oclass->parent->name);\n\t\t\t\t\t\t/*\tTROUBLESHOOT\n\t\t\t\t\t\t\tA class is suppressing the <i>sync</i> event implemented by its parent\n\t\t\t\t\t\t\teven though the parent is published with a flag that indicates this is unsafe.  Presumably\n\t\t\t\t\t\t\tthis is deliberate, but the warning is given just in case it's not intended.\n\t\t\t\t\t\t */\n\t\t\t\t\tif (oclass->parent->passconfig&PC_UNSAFE_OVERRIDE_OMIT\n\t\t\t\t\t\t\t&& !(oclass->passconfig&PC_PARENT_OVERRIDE_OMIT)\n\t\t\t\t\t\t\t&& no_override&PC_POSTTOPDOWN)\n\t\t\t\t\t\toutput_warning(\"class_define_map(oclass='%s',...): class '%s' suppresses parent class '%s' POSTTOPDOWN sync behavior by omitting override\", oclass->name, oclass->name, oclass->parent->name);\n\t\t\t\t\t\t/*\tTROUBLESHOOT\n\t\t\t\t\t\t\tA class is suppressing the <i>postsync</i> event implemented by its parent\n\t\t\t\t\t\t\teven though the parent is published with a flag that indicates this is unsafe.  Presumably\n\t\t\t\t\t\t\tthis is deliberate, but the warning is given just in case it's not intended.\n\t\t\t\t\t\t */\n\t\t\t\t\tif (oclass->parent->passconfig&PC_UNSAFE_OVERRIDE_OMIT\n\t\t\t\t\t\t\t&& !(oclass->passconfig&PC_PARENT_OVERRIDE_OMIT)\n\t\t\t\t\t\t\t&& no_override&PC_UNSAFE_OVERRIDE_OMIT)\n\t\t\t\t\t\toutput_warning(\"class_define_map(oclass='%s',...): class '%s' does not assert UNSAFE_OVERRIDE_OMIT when parent class '%s' does\", oclass->name, oclass->name, oclass->parent->name);\n\t\t\t\t\t\t/*\tTROUBLESHOOT\n\t\t\t\t\t\t\tA class is not asserting that it is unsafe to suppress synchronization behavior\n\t\t\t\t\t\t\tbut its parent does assert that this is unsafe.  This permits stealth omission\n\t\t\t\t\t\t\tby any classes that inherits behavior from this class and the warning is given\n\t\t\t\t\t\t\tin case this is not intended.\n\t\t\t\t\t\t */\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* this test will catch use of PT_? tokens outside the context of a property */\n\t\t\telse if (prop==NULL)\n\t\t\t{\n\t\t\t\terrno = EINVAL;\n\t\t\t\toutput_error(\"class_define_map(oclass='%s',...): expected keyword missing after '%s'\", oclass->name, class_get_property_typename(proptype));\n\t\t\t\t/*\tTROUBLESHOOT\n\t\t\t\t\tThe structure of class is being published with some special properties that only work in the context\n\t\t\t\t\tof a published variable.  This is caused by a problem with the module that publishes the class.\n\t\t\t\t */\n\t\t\t\tgoto Error;\n\t\t\t}\n\t\t\telse if (proptype==PT_KEYWORD && prop->ptype==PT_enumeration)\n\t\t\t{\n\t\t\t\tchar *keyword = va_arg(arg,char*);\n\t\t\t\tint32 keyvalue = va_arg(arg,int32);\n\t\t\t\tif (!class_define_enumeration_member(oclass,prop->name,keyword,keyvalue))\n\t\t\t\t{\n\t\t\t\t\terrno = EINVAL;\n\t\t\t\t\toutput_error(\"class_define_map(oclass='%s',...): property keyword '%s' could not be defined as value %d\", oclass->name, keyword,keyvalue);\n\t\t\t\t\t/*\tTROUBLESHOOT\n\t\t\t\t\t\tAn attempt to define an <i>enumeration</i> property is using a value that cannot be used, either because it is\n\t\t\t\t\t\talready being used, or because it is outside of range of allowed values for that property.  That is caused\n\t\t\t\t\t\tby a problem in the module that publishes the class.\n\t\t\t\t\t */\n\t\t\t\t\tgoto Error;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (proptype==PT_KEYWORD && prop->ptype==PT_set)\n\t\t\t{\n\t\t\t\tchar *keyword = va_arg(arg,char*);\n\t\t\t\tunsigned int64 keyvalue = va_arg(arg, int64);\n\t\t\t\tif (!class_define_set_member(oclass,prop->name,keyword,keyvalue))\n\t\t\t\t{\n\t\t\t\t\terrno = EINVAL;\n\t\t\t\t\toutput_error(\"class_define_map(oclass='%s',...): property keyword '%s' could not be defined as value %d\", oclass->name, keyword,keyvalue);\n\t\t\t\t\t/*\tTROUBLESHOOT\n\t\t\t\t\t\tAn attempt to define an <i>set</i> property is using a value that cannot be used, either because it is\n\t\t\t\t\t\talready being used, or because it is outside of range of allowed values for that property.  That is caused\n\t\t\t\t\t\tby a problem in the module that publishes the class.\n\t\t\t\t\t */\n\t\t\t\t\tgoto Error;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (proptype==PT_ACCESS)\n\t\t\t{\n\t\t\t\tPROPERTYACCESS pa = va_arg(arg,PROPERTYACCESS);\n\t\t\t\tswitch (pa) {\n\t\t\t\tcase PA_PUBLIC:\n\t\t\t\tcase PA_PROTECTED:\n\t\t\t\tcase PA_PRIVATE:\n\t\t\t\tcase PA_REFERENCE:\n\t\t\t\tcase PA_HIDDEN:\n\t\t\t\t\tprop->access = pa;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\terrno = EINVAL;\n\t\t\t\t\toutput_error(\"class_define_map(oclass='%s',...): unrecognized property access code (value=%d is not valid)\", oclass->name, pa);\n\t\t\t\t\t/*\tTROUBLESHOOT\n\t\t\t\t\t\tA class is attempting specify a type variable access that is unknown.  This is caused by a problem\n\t\t\t\t\t\tin the module that publishes the class.\n\t\t\t\t\t */\n\t\t\t\t\tgoto Error;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (proptype==PT_SIZE)\n\t\t\t{\n\t\t\t\tprop->size = va_arg(arg,uint32);\n\t\t\t\tif (prop->size<1)\n\t\t\t\t{\n\t\t\t\t\terrno = EINVAL;\n\t\t\t\t\toutput_error(\"class_define_map(oclass='%s',...): property size must be greater than 0\", oclass->name, proptype);\n\t\t\t\t\t/*\tTROUBLESHOOT\n\t\t\t\t\t\tA class is attempting to define a repeated variable (such as an array) that contains less than 1 item.\n\t\t\t\t\t\tThis is caused by a problem in the module that published the class.\n\t\t\t\t\t */\n\t\t\t\t\tgoto Error;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (proptype==PT_EXTEND)\n\t\t\t{\n\t\t\t\toclass->size += property_type[prop->ptype].size;\n\t\t\t}\n\t\t\telse if (proptype==PT_EXTENDBY)\n\t\t\t{\n\t\t\t\toclass->size += va_arg(arg,unsigned int);\n\t\t\t}\n\t\t\telse if (proptype==PT_FLAGS)\n\t\t\t{\n\t\t\t\tprop->flags |= va_arg(arg,unsigned int);\n\t\t\t}\n\t\t\telse if (proptype==PT_DEPRECATED)\n\t\t\t{\n\t\t\t\tprop->flags |= PF_DEPRECATED;\n\t\t\t}\n\t\t\telse if (proptype==PT_UNITS)\n\t\t\t{\n\t\t\t\tchar *unitspec = va_arg(arg,char*);\n\t\t\t\tTRY {\n\t\t\t\t\tif ((prop->unit = unit_find(unitspec))==NULL)\n\t\t\t\t\t\tthrow_exception(\"unable to define unit '%s'\", unitspec); \n\t\t\t\t} CATCH (const char *msg) {\n\t\t\t\t\t\toutput_error(\"class_define_map(oclass='%s',...): property %s unit '%s' is not recognized: %s\",oclass->name, prop->name,unitspec,msg);\n\t\t\t\t\t\t/*\tTROUBLESHOOT\n\t\t\t\t\t\t\tA class is attempting to publish a variable using a unit that is not defined.\n\t\t\t\t\t\t\tThis is caused by an incorrect unit specification in a variable publication (in C++) or declaration (in GLM).\n\t\t\t\t\t\t\tUnits are defined in the unit file located in the GridLAB-D <b>etc</b> folder.\n\t\t\t\t\t\t\tThis error immediately follows a throw event with the same message.\n\t\t\t\t\t\t */\n\t\t\t\t} ENDCATCH;\n\t\t\t}\n\t\t\telse if (proptype==PT_DESCRIPTION)\n\t\t\t{\n\t\t\t\tprop->description = va_arg(arg,char*);\n\t\t\t}\n\t\t\telse if(proptype == PT_HAS_NOTIFY || proptype == PT_HAS_NOTIFY_OVERRIDE)\n\t\t\t{\n\t\t\t\tchar notify_fname[128];\n\t\t\t\tsprintf(notify_fname, \"notify_%s_%s\", prop->oclass->name, prop->name);\n\t\t\t\tprop->notify = (FUNCTIONADDR)DLSYM(prop->oclass->module->hLib, notify_fname);\n\t\t\t\tif(prop->notify == 0){\n\t\t\t\t\terrno = EINVAL;\n\t\t\t\t\toutput_error(\"Unable to find function '%s' in %s module\", notify_fname, prop->oclass->module->name);\n\t\t\t\t\tgoto Error;\n\t\t\t\t}\n\t\t\t\tif(proptype == PT_HAS_NOTIFY_OVERRIDE){\n\t\t\t\t\tprop->notify_override = true;\n\t\t\t\t} else {\n\t\t\t\t\tprop->notify_override = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tchar tcode[32];\n\t\t\t\tchar *ptypestr=class_get_property_typename(proptype);\n\t\t\t\tsprintf(tcode,\"%d\",proptype);\n\t\t\t\tif (strcmp(ptypestr,\"//UNDEF//\")==0)\n\t\t\t\t\tptypestr = tcode;\n\t\t\t\terrno = EINVAL;\n\t\t\t\toutput_error(\"class_define_map(oclass='%s',...): unrecognized extended property (PROPERTYTYPE=%s)\", oclass->name, ptypestr?ptypestr:tcode);\n\t\t\t\t/*\tTROUBLESHOOT\n\t\t\t\t\tA property extension given in a published class specification uses a property type (PT_*) is that not valid.\n\t\t\t\t\tThis is caused by a problem in the module that publishes the class.\n\t\t\t\t */\n\t\t\t\tgoto Error;\n\t\t\t}\n\t\t}\n\t\telse if (proptype==PT_enduse) /// @todo class_define_map support for enduse has to be done explicitly until structures are supported\n\t\t{\n\t\t\tchar *name = va_arg(arg,char*);\n\t\t\tPROPERTYADDR addr = va_arg(arg,PROPERTYADDR);\n\t\t\tif (enduse_publish(oclass,addr,name)<=0)\n\t\t\t{\n\t\t\t\toutput_error(\"class_define_map(oclass='%s',...): substructure of property '%s' substructure could not be published\", oclass->name, prop->name);\n\t\t\t\t/*\tTROUBLESHOOT\n\t\t\t\t\tA class is publishing a property that has a substructure, which couldn't be published.\n\t\t\t\t\tThis must be corrected in the code the declares the property or publishes the class.\n\t\t\t\t */\n\t\t\t\terrno = E2BIG;\n\t\t\t\tgoto Error;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDELEGATEDTYPE *delegation=(proptype==PT_delegated?va_arg(arg,DELEGATEDTYPE*):NULL);\n\t\t\tchar *name = va_arg(arg,char*);\n\t\t\tPROPERTYADDR addr = va_arg(arg,PROPERTYADDR);\n\t\t\tif (prop!=NULL && strlen(name)>=sizeof(prop->name))\n\t\t\t{\n\t\t\t\toutput_error(\"class_define_map(oclass='%s',...): property name '%s' is too big\", oclass->name, name);\n\t\t\t\t/*\tTROUBLESHOOT\n\t\t\t\t\tA class is publishing a property using a name that is too big for the system.\n\t\t\t\t\tProperty names are limited in length.\n\t\t\t\t\tThis must be corrected in the code the declares the property or publishes the class.\n\t\t\t\t */\n\t\t\t\terrno = E2BIG;\n\t\t\t\tgoto Error;\n\t\t\t}\n\t\t\tif (strcmp(name,\"parent\")==0){\n\t\t\t\toutput_error(\"class_define_map(oclass='%s',...): property name '%s' conflicts with built-in property\", oclass->name, name);\n\t\t\t\t/*\tTROUBLESHOOT\n\t\t\t\t\tA class is attempting to publish a variable with a name normally reserved for object headers.\n\t\t\t\t\tThis is not allowed.  If the class is implemented in a module, this is problem with the module.\n\t\t\t\t\tIf the class is declared in a GLM file, you must correct the problem to avoid unpredictable\n\t\t\t\t\tsimulation behavior.\n\t\t\t\t */\n\t\t\t\tgoto Error;\n\t\t\t} else if (strcmp(name,\"rank\")==0) {\n\t\t\t\toutput_error(\"class_define_map(oclass='%s',...): property name '%s' conflicts with built-in property\", oclass->name, name);\n\t\t\t\t/* no need to repeat troubleshoot message */\n\t\t\t\tgoto Error;\n\t\t\t} else if (strcmp(name,\"clock\")==0) {\n\t\t\t\toutput_error(\"class_define_map(oclass='%s',...): property name '%s' conflicts with built-in property\", oclass->name, name);\n\t\t\t\t/* no need to repeat troubleshoot message */\n\t\t\t\tgoto Error;\n\t\t\t} else if (strcmp(name,\"valid_to\")==0) {\n\t\t\t\toutput_error(\"class_define_map(oclass='%s',...): property name '%s' conflicts with built-in property\", oclass->name, name);\n\t\t\t\t/* no need to repeat troubleshoot message */\n\t\t\t\tgoto Error;\n\t\t\t} else if (strcmp(name,\"latitude\")==0) {\n\t\t\t\toutput_error(\"class_define_map(oclass='%s',...): property name '%s' conflicts with built-in property\", oclass->name, name);\n\t\t\t\t/* no need to repeat troubleshoot message */\n\t\t\t\tgoto Error;\n\t\t\t} else if (strcmp(name,\"longitude\")==0) {\n\t\t\t\toutput_error(\"class_define_map(oclass='%s',...): property name '%s' conflicts with built-in property\", oclass->name, name);\n\t\t\t\t/* no need to repeat troubleshoot message */\n\t\t\t\tgoto Error;\n\t\t\t} else if (strcmp(name,\"in_svc\")==0) {\n\t\t\t\toutput_error(\"class_define_map(oclass='%s',...): property name '%s' conflicts with built-in property\", oclass->name, name);\n\t\t\t\t/* no need to repeat troubleshoot message */\n\t\t\t\tgoto Error;\n\t\t\t} else if (strcmp(name,\"out_svc\")==0) {\n\t\t\t\toutput_error(\"class_define_map(oclass='%s',...): property name '%s' conflicts with built-in property\", oclass->name, name);\n\t\t\t\t/* no need to repeat troubleshoot message */\n\t\t\t\tgoto Error;\n\t\t\t} else if (strcmp(name,\"name\")==0) {\n\t\t\t\toutput_error(\"class_define_map(oclass='%s',...): property name '%s' conflicts with built-in property\", oclass->name, name);\n\t\t\t\t/* no need to repeat troubleshoot message */\n\t\t\t\tgoto Error;\n\t\t\t} else if (strcmp(name,\"flags\")==0) {\n\t\t\t\toutput_error(\"class_define_map(oclass='%s',...): property name '%s' conflicts with built-in property\", oclass->name, name);\n\t\t\t\t/* no need to repeat troubleshoot message */\n\t\t\t\tgoto Error;\n\t\t\t}\n\t\t\tprop = property_malloc(proptype,oclass,name,addr,delegation);\n\t\t\tif (prop==NULL)\n\t\t\t\tgoto Error;\n\n\t\t\tif ( proptype==PT_method )\n\t\t\t{\n\t\t\t\tprop->addr = 0;\n\t\t\t\tprop->method = (METHODCALL*)addr;\n\t\t\t}\n\n\t\t\t/* attach to property list */\n\t\t\tclass_add_property(oclass,prop);\n\t\t\tcount++;\n\n\t\t\t/* save property types in case extended property comes up */\n\t\t\tif (prop->ptype>_PT_LAST)\n\t\t\t\tprop = NULL;\n\t\t}\n\t}\n\tva_end(arg);\n\treturn count;\nError:\n\tif (prop!=NULL)\n\t\toutput_error(\"class_define_map(oclass='%s',...): processed up to '%s' before encountering error\", oclass->name, prop->name);\n\treturn -count;\n}\n\n/** Define an enumeration member\n\t@return 0 on failure, 1 on success\n **/\nint class_define_enumeration_member(CLASS *oclass, /**< pointer to the class which implements the enumeration */\n                                    char *property_name, /**< property name of the enumeration */\n                                    char *member, /**< member name to define */\n                                    enumeration value) /**< enum value to associate with the name */\n{\n\tPROPERTY *prop = class_find_property(oclass,property_name);\n\tKEYWORD *key = (KEYWORD*)malloc(sizeof(KEYWORD));\n\tif (prop==NULL || key==NULL) return 0;\n\tkey->next = prop->keywords;\n\tstrncpy(key->name,member,sizeof(key->name));\n\tkey->value = value;\n\tprop->keywords = key;\n\treturn 1;\n}\n\n/** Define a set member\n **/\nint class_define_set_member(CLASS *oclass, /**< pointer to the class which implements the set */\n                            char *property_name, /**< property name of the set */\n                            char *member, /**< member name to define */\n                            unsigned int64 value) /**< set value to associate with the name */\n{\n\tPROPERTY *prop = class_find_property(oclass,property_name);\n\tKEYWORD *key = (KEYWORD*)malloc(sizeof(KEYWORD));\n\tif (prop==NULL || key==NULL) return 0;\n\tif (prop->keywords==NULL)\n\t\tprop->flags |= PF_CHARSET; /* enable single character keywords until a long keyword is defined */\n\tkey->next = prop->keywords;\n\tstrncpy(key->name,member,sizeof(key->name));\n\tkey->name[sizeof(key->name)-1]='\\0'; /* null terminate name in case is was too long for strncpy */\n\tif (strlen(key->name)>1 && (prop->flags&PF_CHARSET)) /* long keyword detected */\n\t\tprop->flags ^= PF_CHARSET; /* disable single character keywords */\n\tkey->value = value;\n\tprop->keywords = key;\n\treturn 1;\n}\n\n/**\tDefine a class function.\n\t@return A structure with the function pointer and the function's published name.\n */\nFUNCTION *class_define_function(CLASS *oclass, FUNCTIONNAME functionname, FUNCTIONADDR call)\n{\n\tFUNCTION *func, *tempfunc;\n\tif (class_get_function(oclass->name,functionname)!=NULL)\n\t{\n\t\toutput_error(\"class_define_function(CLASS *class={name='%s',...}, FUNCTIONNAME functionname='%s', ...) the function name has already been defined\", oclass->name, functionname);\n\t\t/* TROUBLESHOOT\n\t\t\tThe function in question has already been defined for the class.\n\t\t\tOnly one function of any given name is permitted in each class.\n\t\t\tRemove or correct the duplicate function declaration and try again.\n\t\t */\n\t\terrno = 1;\n\t\treturn NULL;\n\t}\n\n\tfunc = (FUNCTION*)malloc(sizeof(FUNCTION));\n\tif (func==NULL)\n\t{\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\tfunc->addr = call;\n\tstrcpy(func->name,functionname);\n\tfunc->next = NULL;\n\tfunc->oclass = oclass;\n\tif (oclass->fmap==NULL)\n\t\toclass->fmap = func;\n\telse if (oclass->fmap->next == NULL)\n\t\toclass->fmap->next = func;\n\telse\t//More than one attached\n\t{\n\t\ttempfunc = oclass->fmap;\n\t\twhile (tempfunc->next != NULL)\n\t\t\ttempfunc = tempfunc->next;\n\n\t\ttempfunc->next = func;\n\t}\n\n\treturn func;\n}\n\n/* Get the entry point of a class function\n */\nFUNCTIONADDR class_get_function(char *classname, char *functionname)\n{\n\tCLASS *oclass = class_get_class_from_classname(classname);\n\tFUNCTION *func;\n\tfor (func=oclass->fmap; func!=NULL && func->oclass==oclass; func=func->next)\n\t{\n\t\tif (strcmp(functionname,func->name)==0)\n\t\t\treturn func->addr;\n\t}\n\terrno = ENOENT;\n\treturn NULL;\n}\n\n/** Save all class information to a stream in \\b glm format\n\t@return the number of characters written to the stream\n **/\nint class_saveall(FILE *fp) /**< a pointer to the stream FILE structure */\n{\n\tunsigned count=0;\n\tcount += fprintf(fp,\"\\n////////////////////////////////////////////////////////\\n\");\n\tcount += fprintf(fp,\"// classes\\n\");\n\t{\tCLASS\t*oclass;\n\t\tfor (oclass=class_get_first_class(); oclass!=NULL; oclass=oclass->next)\n\t\t{\n\t\t\tPROPERTY *prop;\n\t\t\tFUNCTION *func;\n\t\t\tcount += fprintf(fp,\"class %s {\\n\",oclass->name);\n\t\t\tif (oclass->parent)\n\t\t\t\tcount += fprintf(fp,\"#ifdef INCLUDE_PARENT_CLASS\\n\\tparent %s;\\n#endif\\n\", oclass->parent->name);\n\t\t\tfor (func=oclass->fmap; func!=NULL && func->oclass==oclass; func=func->next)\n\t\t\t\tcount += fprintf(fp, \"#ifdef INCLUDE_FUNCTIONS\\n\\tfunction %s();\\n#endif\\n\", func->name);\n\t\t\tfor (prop=oclass->pmap; prop!=NULL && prop->oclass==oclass; prop=prop->next)\n\t\t\t{\n\t\t\t\tchar *ptype = class_get_property_typename(prop->ptype);\n\t\t\t\tif ( ptype != NULL )\n\t\t\t\t{\n\t\t\t\t\tif ( strchr(prop->name,'.') == NULL )\n\t\t\t\t\t\tcount += fprintf(fp,\"\\t%s %s;\\n\", ptype, prop->name);\n\t\t\t\t\telse\n\t\t\t\t\t\tcount += fprintf(fp,\"#ifdef INCLUDE_DOTTED_PROPERTIES\\t%s %s;\\n#endif\\n\", ptype, prop->name);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcount += fprintf(fp,\"}\\n\");\n\t\t}\n\t}\n\treturn count;\n}\n\n/** Save all class information to a stream in \\b xml format\n\t@return the number of characters written to the stream\n **/\nint class_saveall_xml(FILE *fp) /**< a pointer to the stream FILE structure */\n{\n\tunsigned count=0;\n\tcount += fprintf(fp,\"\\t<classes>\\n\");\n\t{\tCLASS\t*oclass;\n\t\tfor (oclass=class_get_first_class(); oclass!=NULL; oclass=oclass->next)\n\t\t{\n\t\t\tPROPERTY *prop;\n\t\t\tFUNCTION *func;\n\t\t\tcount += fprintf(fp,\"\\t\\t<class name=\\\"%s\\\">\\n\",oclass->name);\n\t\t\tif (oclass->parent)\n\t\t\t\tcount += fprintf(fp,\"\\t\\t<parent>%s</parent>\\n\", oclass->parent->name);\n\t\t\tfor (func=oclass->fmap; func!=NULL && func->oclass==oclass; func=func->next)\n\t\t\t\tcount += fprintf(fp, \"\\t\\t<function>%s</function>\\n\", func->name);\n\t\t\tfor (prop=oclass->pmap; prop!=NULL && prop->oclass==oclass; prop=prop->next)\n\t\t\t{\n\t\t\t\tchar *propname = class_get_property_typename(prop->ptype);\n\t\t\t\tif (propname!=NULL)\n\t\t\t\t\tcount += fprintf(fp,\"\\t\\t\\t<property type=\\\"%s\\\">%s</property>\\n\", propname, prop->name);\n\t\t\t}\n\t\t\tcount += fprintf(fp,\"\\t\\t</class>\\n\");\n\t\t}\n\t}\n\tcount += fprintf(fp,\"\\t</classes>\\n\");\n\treturn count;\n}\n\n/** Generate profile information for the classes used\n **/\nvoid class_profiles(void)\n{\n\tCLASS *cl;\n\tint64 total=0;\n\tint count=0, i=0, hits;\n\tCLASS **index;\n\toutput_profile(\"Model profiler results\");\n\toutput_profile(\"======================\\n\");\n\toutput_profile(\"Class            Time (s) Time (%%) msec/obj\");\n\toutput_profile(\"---------------- -------- -------- --------\");\n\tfor (cl=first_class; cl!=NULL; cl=cl->next)\n\t{\n\t\ttotal+=cl->profiler.clocks;\n\t\tcount++;\n\t}\n\tif(0 == count){\n\t\treturn;\t// short-circuit\n\t}\n\tindex = (CLASS**)malloc(sizeof(CLASS*)*count);\n\tif(0 == index){\n\t\t// error\n\t\treturn;\n\t}\n\tfor (cl=first_class; cl!=NULL; cl=cl->next)\n\t\tindex[i++]=cl;\n\thits=-1;\n\twhile (hits!=0)\n\t{\n\t\thits=0;\n\t\tfor (i=0; i<count-1; i++)\n\t\t{\n\t\t\tif (index[i]->profiler.clocks<index[i+1]->profiler.clocks)\n\t\t\t{\n\t\t\t\tCLASS *tmp = index[i];\n\t\t\t\tindex[i]=index[i+1];\n\t\t\t\tindex[i+1]=tmp;\n\t\t\t\thits++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (i=0; i<count; i++)\n\t{\n\t\tcl = index[i];\n\t\tif (cl->profiler.clocks>0)\n\t\t{\n\t\t\tdouble ts = (double)cl->profiler.clocks/CLOCKS_PER_SEC;\n\t\t\tdouble tp = (double)cl->profiler.clocks/total*100;\n\t\t\tdouble mt = ts/cl->profiler.numobjs*1000;\n\t\t\toutput_profile(\"%-16.16s %7.3f %8.1f%% %8.1f\", cl->name, ts,tp,mt);\n\t\t}\n\t\telse\n\t\t\tbreak;\n\t}\n\tfree(index);\n\tindex = NULL;\n\toutput_profile(\"================ ======== ======== ========\");\n\toutput_profile(\"%-16.16s %7.3f %8.1f%% %8.1f\\n\",\n\t\t\"Total\", (double)total/CLOCKS_PER_SEC,100.0,1000*(double)total/CLOCKS_PER_SEC/object_get_count());\n\n}\n\n/** Register a type delegation for a property\n\t@return a pointer DELEGATEDTYPE struct if successful, \\p NULL if delegation failed\n\n\tType delegation is used to transform data to string and string to data conversion\n\tto routines implemented in a module, instead of in the core.   This allows custom\n\tdata type to be implemented, including enumerations, sets, and special objects.\n **/\nDELEGATEDTYPE *class_register_type(CLASS *oclass, /**< the object class */\n                                   char *type, /**< the property type */\n                                   int (*from_string)(void*,char*), /**< the converter from string to data */\n                                   int (*to_string)(void*,char*,int)) /**< the converter from data to string */\n{\n\tDELEGATEDTYPE *dt = (DELEGATEDTYPE*)malloc(sizeof(DELEGATEDTYPE));\n\tif (dt!=NULL)\n\t{\n\t\tdt->oclass = oclass;\n\t\tstrncpy(dt->type,type,sizeof(dt->type));\n\t\tdt->from_string = (int (*)(void*,const char*))from_string;\n\t\tdt->to_string = to_string;\n\t}\n\telse\n\t\toutput_error(\"unable to register delegated type (memory allocation failed)\");\n\t\t/*\tTROUBLESHOOT\n\t\t\tProperty delegation is not supported yet so this should never happen.\n\t\t\tThis is most likely caused by a lack of memory or an unstable system.\n\t\t */\n\treturn dt;\n}\n\nint class_add_loadmethod(CLASS *oclass, char *name, int (*call)(void*,char*))\n{\n\tLOADMETHOD *method = (LOADMETHOD*)malloc(sizeof(LOADMETHOD));\n\tmethod->name = name;\n\tmethod->call = call;\n\tmethod->next = oclass->loadmethods;\n\toclass->loadmethods = method;\n\treturn 1;\n}\n\nLOADMETHOD *class_get_loadmethod(CLASS *oclass,char *name)\n{\n\tLOADMETHOD *method;\n\tfor ( method=oclass->loadmethods ; method!=NULL ; method=method->next )\n\t{\n\t\tif ( strcmp(method->name,name)==0 )\n\t\t\treturn method;\n\t}\n\treturn NULL;\n}\n\n/* this is not supported */\nint class_define_type(CLASS *oclass, DELEGATEDTYPE *delegation, ...)\n{\n\toutput_error(\"delegated types not supported using class_define_type (use class_define_map instead)\");\n\t/*\tTROUBLESHOOT\n\t\t\tProperty delegation is not supported yet so this should never happen.\n\t\t\tThis is most likely caused by a lack of memory or an unstable system.\n\t */\n\treturn 0;\n}\n\nstatic int check = 0;  /* there must be a better way to do this, but this works. -MH */\n\n/**\tWrites a formatted string into a temporary buffer prior and verifies that enough space exists prior to writing to the destination.\n\t@return the number of characters written to the buffer\n **/\nstatic int buffer_write(char *buffer, /**< buffer into which string is written */\n                        size_t len,   /**< size of the buffer into which the string is written */\n                        char *format, /**< format of string to write into buffer, followed by the variable arguments */\n                        ...)\n{\n\tchar temp[1025];\n\tunsigned int count = 0;\n\tva_list ptr;\n\n\tif(buffer == NULL)\n\t\treturn 0;\n\tif(len < 1)\n\t\treturn 0;\n\tif(check == 0)\n\t\treturn 0;\n\n\tva_start(ptr,format);\n\tcount = vsprintf(temp, format, ptr);\n\tva_end(ptr);\n\n\tif(count < len){\n\t\tstrncpy(buffer, temp, count);\n\t\treturn count;\n\t} else {\n\t\tcheck = 0;\n\t\treturn 0;\n\t}\n}\n\n/** Generate the XSD snippet of a class\n\t@return the number of characters written to the buffer\n **/\nint class_get_xsd(CLASS *oclass, /**< a pointer to the class to convert to XSD */\n\t\t\t\t  char *buffer, /**< a pointer to the first character in the buffer */\n\t\t\t\t  size_t len) /**< the size of the buffer */\n{\n\tsize_t n=0;\n\tPROPERTY *prop;\n\tint i;\n\tCLASS *oc = oclass;\n\textern KEYWORD oflags[];\n\tstruct {\n\t\tchar *name;\n\t\tchar *type;\n\t\tKEYWORD *keys;\n\t} attribute[]={\n\t\t{\"id\", \"integer\",NULL},\n\t\t{\"parent\", \"string\",NULL},\n\t\t{\"rank\", \"integer\",NULL},\n\t\t{\"clock\", \"string\",NULL},\n\t\t{\"valid_to\", \"string\",NULL},\n\t\t{\"latitude\", \"string\",NULL},\n\t\t{\"longitude\", \"string\",NULL},\n\t\t{\"in_svc\", \"string\",NULL},\n\t\t{\"out_svc\", \"string\",NULL},\n\t\t{\"flags\", \"string\",oflags},\n\t};\n\tcheck = 1;\n\tn += buffer_write(buffer+n, len-n, \"<xs:element name=\\\"%s\\\">\\n\", oclass->name);\n\tn += buffer_write(buffer+n, len-n, \"\\t<xs:complexType>\\n\");\n\tn += buffer_write(buffer+n, len-n, \"\\t\\t<xs:all>\\n\");\n\tfor (i=0; i < sizeof(attribute) / sizeof(attribute[0]); i++)\n\t{\n\t\tn += buffer_write(buffer+n, len-n, \"\\t\\t\\t<xs:element name=\\\"%s\\\">\\n\", attribute[i].name);\n\t\tn += buffer_write(buffer+n, len-n, \"\\t\\t\\t\\t<xs:simpleType>\\n\");\n\t\tif (attribute[i].keys==NULL){\n\t\t\tn += buffer_write(buffer+n, len-n, \"\\t\\t\\t\\t\\t<xs:restriction base=\\\"xs:%s\\\"/>\\n\", attribute[i].type);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tKEYWORD *key;\n\t\t\tn += buffer_write(buffer+n, len-n, \"\\t\\t\\t\\t\\t<xs:restriction base=\\\"xs:string\\\">\\n\");\n\t\t\tn += buffer_write(buffer+n, len-n, \"\\t\\t\\t\\t\\t\\t<xs:pattern value=\\\"\");\n\t\t\tfor (key=attribute[i].keys; key!=NULL; key=key->next){\n\t\t\t\tn += buffer_write(buffer+n, len-n, \"%s%s\", key==attribute[i].keys?\"\":\"|\", key->name);\n\t\t\t}\n\t\t\tn += buffer_write(buffer+n, len-n, \"\\\"/>\\n\");\n\t\t\tn += buffer_write(buffer+n, len-n, \"\\t\\t\\t\\t\\t</xs:restriction>\\n\");\n\t\t}\n\t\tn += buffer_write(buffer+n, len-n, \"\\t\\t\\t\\t</xs:simpleType>\\n\");\n\t\tn += buffer_write(buffer+n, len-n, \"\\t\\t\\t</xs:element>\\n\");\n\t}\n\tfor(; oc != 0; oc = oc->parent){\n\t\tfor (prop=oc->pmap; prop!=NULL && prop->oclass==oc; prop=prop->next)\n\t\t{\n\t\t\tchar *proptype=class_get_property_typexsdname(prop->ptype);\n\t\t\tif (prop->unit!=NULL){\n\t\t\t\tn += buffer_write(buffer+n, len-n, \"\\t\\t\\t\\t<xs:element name=\\\"%s\\\" type=\\\"xs:string\\\"/>\\n\", prop->name);\n\t\t\t} else {\n\t\t\t\tn += buffer_write(buffer+n, len-n, \"\\t\\t\\t<xs:element name=\\\"%s\\\">\\n\", prop->name);\n\t\t\t\tn += buffer_write(buffer+n, len-n, \"\\t\\t\\t\\t<xs:simpleType>\\n\");\n\t\t\t\tn += buffer_write(buffer+n, len-n, \"\\t\\t\\t\\t\\t<xs:restriction base=\\\"xs:%s\\\">\\n\", proptype==NULL?\"string\":proptype);\n\t\t\t\tif (prop->keywords!=NULL)\n\t\t\t\t{\n\t\t\t\t\tKEYWORD *key;\n\t\t\t\t\tn += buffer_write(buffer+n, len-n, \"\\t\\t\\t\\t\\t<xs:pattern value=\\\"\");\n\t\t\t\t\tfor (key=prop->keywords; key!=NULL; key=key->next){\n\t\t\t\t\t\tn += buffer_write(buffer+n, len-n, \"%s%s\", key==prop->keywords?\"\":\"|\", key->name);\n\t\t\t\t\t}\n\t\t\t\t\tn += buffer_write(buffer+n, len-n, \"\\\"/>\\n\");\n\t\t\t\t}\n\t\t\t\tn += buffer_write(buffer+n, len-n, \"\\t\\t\\t\\t\\t</xs:restriction>\\n\");\n\t\t\t\tn += buffer_write(buffer+n, len-n, \"\\t\\t\\t\\t</xs:simpleType>\\n\");\n\t\t\t\tn += buffer_write(buffer+n, len-n, \"\\t\\t\\t</xs:element>\\n\");\n\t\t\t}\n\t\t}\n\t}\n\tn += buffer_write(buffer+n, len-n, \"\\t\\t</xs:all>\\n\");\n\tn += buffer_write(buffer+n, len-n, \"\\t</xs:complexType>\\n\");\n\tn += buffer_write(buffer+n, len-n, \"</xs:element>\\n\");\n\tbuffer[n] = 0;\n\tif(check == 0){\n\t\tprintf(\"class_get_xsd() overflowed.\\n\");\n\t\tbuffer[0] = 0;\n\t\treturn 0;\n\t}\n\treturn (int)n;\n}\n\n\n/**@}**/\n",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/gldcore/module.c": "/** $Id: module.c 4738 2014-07-03 00:55:39Z dchassin $\n\tCopyright (C) 2008 Battelle Memorial Institute\n\t@file module.cpp\n\t@addtogroup modules Runtime modules\n\n @{\n **/\n\n/* absolutely nothing must be placed before this per feature_test_macros(7) man page */\n#ifndef WIN32\n#ifndef __APPLE__\n#define _GNU_SOURCE\n#include <features.h>\n#endif\n#endif\n\n#include \"version.h\"\n\n#if defined WIN32\n#include <io.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#else\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <dirent.h>\n#endif\n#include <math.h>\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include \"http_client.h\"\n\n#if defined(_WIN32) && !defined(__MINGW32__)\n#define WIN32_LEAN_AND_MEAN\t\t// Exclude rarely-used stuff from Windows headers\n#define _WIN32_WINNT 0x0400\n#include <windows.h>\n#ifndef DLEXT\n#define DLEXT \".dll\"\n#endif\n#define DLLOAD(P) LoadLibrary(P)\n#define DLSYM(H,S) (void *)GetProcAddress((HINSTANCE)H,S)\n#define snprintf _snprintf\n#else /* ANSI */\n#include \"dlfcn.h\"\n#ifndef DLEXT\n#ifdef __MINGW32__\n#define DLEXT \".dll\"\n#else\n#define DLEXT \".so\"\n#endif\n#endif\n#define DLLOAD(P) dlopen(P,RTLD_LAZY)\n#define DLSYM(H,S) dlsym(H,S)\n#endif\n\n#if !defined(HAVE_CONFIG_H) || defined(HAVE_MALLOC_H)\n#include <malloc.h>\n#endif\n\n#if HAVE_SCHED_H\n#include <sched.h>\n#endif\n\n#include <errno.h>\n#include \"platform.h\"\n#include \"globals.h\"\n#include \"output.h\"\n#include \"module.h\"\n#include \"find.h\"\n#include \"gldrandom.h\"\n#include \"test_callbacks.h\"\n#include \"exception.h\"\n#include \"unit.h\"\n#include \"interpolate.h\"\n#include \"lock.h\"\n#include \"schedule.h\"\n#include \"exec.h\"\n#include \"stream.h\"\n#include \"transform.h\"\n\n#include \"console.h\"\n\n#include \"matlab.h\"\n\nint get_exe_path(char *buf, int len, void *mod){\t/* void for GetModuleFileName, a windows func */\n\tint rv = 0, i = 0;\n\tif(buf == NULL)\n\t\treturn 0;\n\tif(len < 1)\n\t\treturn 0;\n#if defined WIN32 && ! defined __MINGW32__\n\trv = GetModuleFileName((HMODULE) mod, buf, len);\n\tif(rv){\n\t\tfor(i = rv; ((buf[i] != '/') && (buf[i] != '\\\\') && (i >= 0)); --i){\n\t\t\tbuf[i] = 0;\n\t\t\t--rv;\n\t\t}\n\t}\n#else /* POSIX */\n\tif(mod == NULL){ /* \"/bin/gridlabd\"?*/\n\t\t;\n\t} else {\n\t\t;\n\t}\n#endif\n\treturn rv;\n}\n\nint module_get_exe_path(char *buf, int len){\n\treturn get_exe_path(buf, len, NULL);\n}\n\nint module_get_path(char *buf, int len, MODULE *mod){\n\treturn get_exe_path(buf, len, mod->hLib);\n}\n\nvoid dlload_error(const char *filename)\n{\n#ifndef __MINGW32__\n#if defined WIN32\n\tLPTSTR error;\n\tLPTSTR end;\n\tDWORD result = FormatMessage(\n\t\t\t\tFORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,\n\t\t\t\tNULL, GetLastError(), MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n\t\t\t\t(LPTSTR) &error, 0, NULL);\n\tif (!result)\n\t\terror = TEXT(\"[FormatMessage failed]\");\n\telse for (end = error + strlen(error) - 1; end >= error && isspace(*end); end--)\n\t\t*end = 0;\n#else\n\tchar *error = dlerror();\n#endif\n#else\n\tchar *error = \"unknown error\";\n#endif\n\toutput_debug(\"%s: %s (LD_LIBRARY_PATH=%s)\", filename, error,getenv(\"LD_LIBRARY_PATH\"));\n#if defined WIN32 && ! defined __MINGW32__\n\tif (result)\n\t\tLocalFree(error);\n#endif\n}\n\n/* MALLOC/FREE - GL threadsafe versions */\nstatic int malloc_lock = 0;\nvoid *module_malloc(size_t size)\n{\n\tvoid *ptr;\n\twlock(&malloc_lock);\n\tptr = (void*)malloc(size);\n\twunlock(&malloc_lock);\n\treturn ptr;\n}\nvoid module_free(void *ptr)\n{\n\twlock(&malloc_lock);\n\tfree(ptr);\n\twunlock(&malloc_lock);\n}\n\n/* these are the core functions available to loadable modules\n * the structure is defined in object.h */\n#define MAGIC 0x012BB0B9\nint64 lock_count;\nint64 lock_spin;\nstatic CALLBACKS callbacks = {\n\t&global_clock,\n\t&global_delta_curr_clock,\n\t&global_stoptime,\n\toutput_verbose,\n\toutput_message,\n\toutput_warning,\n\toutput_error,\n\toutput_debug,\n\toutput_test,\n\tclass_register,\n\t{object_create_single,object_create_array,object_create_foreign},\n\tclass_define_map, class_add_loadmethod,\n\tclass_get_first_class,\n\tclass_get_class_from_classname,\n\tclass_add_extended_property,\n\t{class_define_function,class_get_function},\n\tclass_define_enumeration_member,\n\tclass_define_set_member,\n\t{object_get_first,object_set_dependent,object_set_parent,object_set_rank,},\n\t{object_get_property, object_set_value_by_addr,object_get_value_by_addr, object_set_value_by_name,object_get_value_by_name,object_get_reference,object_get_unit,object_get_addr,class_string_to_propertytype,property_compare_basic,property_compare_op,property_get_part,property_getspec},\n\t{find_objects,find_next,findlist_copy,findlist_add,findlist_del,findlist_clear},\n\tclass_find_property,\n\tmodule_malloc,\n\tmodule_free,\n\t{aggregate_mkgroup,aggregate_value,},\n\t{module_getvar_addr,module_get_first,module_depends,module_find_transform_function},\n\t{random_uniform, random_normal, random_bernoulli, random_pareto, random_lognormal, random_sampled, random_exponential, random_type, random_value, pseudorandom_value, random_triangle, random_beta, random_gamma, random_weibull, random_rayleigh},\n\tobject_isa,\n\tclass_register_type,\n\tclass_define_type,\n\t{mkdatetime,strdatetime,timestamp_to_days,timestamp_to_hours,timestamp_to_minutes,timestamp_to_seconds,local_datetime,local_datetime_delta,convert_to_timestamp,convert_to_timestamp_delta,convert_from_timestamp,convert_from_deltatime_timestamp},\n\tunit_convert, unit_convert_ex, unit_find,\n\t{create_exception_handler,delete_exception_handler,throw_exception,exception_msg},\n\t{global_create, global_setvar, global_getvar, global_find},\n\t{rlock, wlock}, {runlock, wunlock},\n\t{find_file},\n\t{object_get_bool, object_get_complex, object_get_enum, object_get_set, object_get_int16, object_get_int32, object_get_int64, object_get_double, object_get_string, object_get_object},\n\t{object_get_bool_by_name, object_get_complex_by_name, object_get_enum_by_name, object_get_set_by_name, object_get_int16_by_name, object_get_int32_by_name, object_get_int64_by_name,\n\t\tobject_get_double_by_name, object_get_string_by_name, object_get_object_by_name},\n\t{class_string_to_property, class_property_to_string,},\n\tmodule_find,\n\tobject_find_name, object_find_by_id,\n\tobject_build_name,\n\tobject_get_oflags,\n\tobject_get_count,\n\t{schedule_create, schedule_index, schedule_value, schedule_dtnext, schedule_find_byname, schedule_getfirst},\n\t{loadshape_create,loadshape_init},\n\t{enduse_create,enduse_sync},\n\t{interpolate_linear, interpolate_quadratic},\n\t{forecast_create, forecast_find, forecast_read, forecast_save},\n\t{object_remote_read, object_remote_write, global_remote_read, global_remote_write},\n\t{objlist_create,objlist_search,objlist_destroy,objlist_add,objlist_del,objlist_size,objlist_get,objlist_apply},\n\t{{convert_from_latitude, convert_to_latitude},{convert_from_longitude,convert_to_longitude}},\n\t{http_read,http_delete_result},\n\t{transform_getnext,transform_add_linear,transform_add_external,transform_apply},\n\t{randomvar_getnext,randomvar_getspec},\n\t{version_major,version_minor,version_patch,version_build,version_branch},\n\tMAGIC /* used to check structure */\n};\nCALLBACKS *module_callbacks(void) { return &callbacks; }\n\nstatic MODULE *first_module = NULL;\nstatic MODULE *last_module = NULL;\nstatic size_t module_count = 0;\nsize_t module_getcount(void) { return module_count; }\n\n/** Load a runtime module\n\t@return a pointer to the MODULE structure\n\t\\p NULL on failure, errno set to:\n    - \\p ENOEXEC to indicate init() not defined in module\n    - \\p EINVAL to indicate call to init failed\n    - \\p ENOENT to indicate class not defined by module\n **/\ntypedef MODULE *(*LOADER)(const char *, int, char *[]);\nMODULE *module_load(const char *file, /**< module filename, searches \\p PATH */\n\t\t\t\t\t\t\t   int argc, /**< count of arguments in \\p argv */\n\t\t\t\t\t\t\t   char *argv[]) /**< arguments passed from the command line */\n{\n\t/* check for already loaded */\n\tMODULE *mod = module_find((char *)file);\n\tchar buffer[FILENAME_MAX+1];\n\tchar *fmod;\n\tbool isforeign = false;\n\tchar pathname[1024];\n\tchar tpath[1024];\n#ifdef _WIN32\n\tchar from='/', to='\\\\';\n#else\n\tchar from='\\\\', to='/';\n#endif\n\tchar *p = NULL;\n\tvoid *hLib = NULL;\n\tLIBINIT init = NULL;\n\tint *pMajor = NULL, *pMinor = NULL;\n\tCLASS *previous = NULL;\n\tCLASS *c;\n\n\tif ( callbacks.magic != MAGIC )\n\t{\n\t\toutput_fatal(\"callback function table alignment error (magic number position mismatch)\");\n\t\treturn NULL;\n\t}\n#ifdef NEVER /* this shouldn't ever be necessary but sometimes for debugging purposes it is helpful */\n\t/* if LD_LIBRARY_PATH is not set, default to current directory */\n\tif (getenv(\"LD_LIBRARY_PATH\")==NULL)\n\t{\n\t\tputenv(\"LD_LIBRARY_PATH=.\");\n\t\toutput_verbose(\"Setting default LD_LIBRARY_DEFAULT to current directory\");\n\t}\n#endif\n\n\tif (mod!=NULL)\n\t{\n\t\toutput_verbose(\"%s(%d): module '%s' already loaded\", __FILE__, __LINE__, file);\n\t\treturn mod;\n\t}\n\telse\n\t{\n\t\toutput_verbose(\"%s(%d): module '%s' not yet loaded\", __FILE__, __LINE__, file);\n\t}\n\n\t/* check for foreign modules */\n\tstrcpy(buffer,file);\n\tfmod = strtok(buffer,\"::\");\n\tif (fmod!=NULL && strcmp(fmod, file) != 0)\n\t{\n\t\tchar *modname = strtok(NULL,\"::\");\n\t\tMODULE *parent_mod = module_find(fmod);\n\t\tif(parent_mod == NULL)\n\t\t\tparent_mod = module_load(fmod, 0, NULL);\n\t\tprevious = class_get_last_class();\n\t\tif(parent_mod != NULL && parent_mod->subload != NULL)\n\t\t{\t/* if we've defined a subload routine and already loaded the parent module*/\n\t\t\tMODULE *child_mod;\n\t\t\tif(module_find(fmod) == NULL)\n\t\t\t\tmodule_load(fmod, 0, NULL);\n\t\t\tchild_mod = parent_mod->subload(modname, &mod, (previous ? &(previous->next) : &previous), argc, argv);\n\t\t\tif(child_mod == NULL)\n\t\t\t{\t/* failure */\n\t\t\t\toutput_error(\"module_load(file='%s::%s'): subload failed\", fmod, modname);\n\t\t\t\t/* TROUBLESHOOT\n\t\t\t\t   A module is unable to load a submodule require for operation.\n\t\t\t\t   Check that the indicated submodule is installed and try again.\n\t\t\t\t */\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (mod != NULL)\n\t\t\t{\t/* if we want to register another module */\n\t\t\t\tlast_module->next = mod;\n\t\t\t\tlast_module = mod;\n\t\t\t\tmod->oclass = previous ? previous->next : class_get_first_class();\n\t\t\t}\n\t\t\treturn last_module;\n\t\t} else {\n\t\t\tstruct {\n\t\t\t\tchar *name;\n\t\t\t\tLOADER loader;\n\t\t\t} fmap[] = {\n\t\t\t\t{\"matlab\",NULL},\n\t\t\t\t{\"java\",load_java_module},\n\t\t\t\t{\"python\",load_python_module},\n\t\t\t\t{NULL,NULL} /* DO NOT DELETE THIS TERMINATOR ENTRY */\n\t\t\t}, *p;\n\t\t\tfor (p=fmap; p->name!=NULL; p++)\n\t\t\t{\n\t\t\t\tif (strcmp(p->name, fmod)==0)\n\t\t\t\t{\n\t\t\t\t\tstatic char *args[1];\n\t\t\t\t\tisforeign = true;\n\t\t\t\t\tif (p->loader!=NULL)\n\t\t\t\t\t\t/* use external loader */\n\t\t\t\t\t\treturn p->loader(modname,argc,argv);\n\n\t\t\t\t\t/* use a module with command args */\n\t\t\t\t\targv = args;\n\t\t\t\t\targc=1;\n\t\t\t\t\targv[0] = modname;\n\t\t\t\t\tfile=buffer;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (p==NULL)\n\t\t\t{\n\t\t\t\toutput_error(\"module_load(file='%s',...): foreign module type %s not recognized or supported\", fmod);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* create a new module entry */\n\tmod = (MODULE *)malloc(sizeof(MODULE));\n\tif (mod==NULL)\n\t{\n\t\toutput_verbose(\"%s(%d): module '%s' memory allocation failed\", __FILE__, __LINE__, file);\n\t\terrno=ENOMEM;\n\t\treturn NULL;\n\t}\n\telse\n\t\toutput_verbose(\"%s(%d): module '%s' memory allocated\", __FILE__, __LINE__, file);\n\n\t/* locate the module */\n\tsnprintf(pathname, sizeof(pathname), \"%s\" DLEXT, file);\n\n\tif(find_file(pathname, NULL, X_OK|R_OK, tpath,sizeof(tpath)) == NULL)\n\t{\n\t\toutput_verbose(\"unable to locate %s in GLPATH, using library loader instead\", pathname);\n\t\tstrncpy(tpath,pathname,sizeof(tpath));\n\t}\n\telse\n\t{\n#ifndef WIN32\n\t\t/* if the path is a relative path */\n\t\tstruct stat buf;\n\t\tif (tpath[0]!='/' && stat(tpath,&buf)==0) \n\t\t{\n\t\t\tchar buffer[1024];\n\n\t\t\t/* add ./ to the beginning of the path */\n\t\t\tsprintf(buffer,\"./%s\", tpath);\n\t\t\tstrcpy(tpath,buffer);\n\t\t}\n#endif\n\t\toutput_verbose(\"full path to library '%s' is '%s'\", file, tpath);\n\t}\n\n\t/* convert path delims based on OS preference */\n\tfor (p=strchr(tpath,from); p!=NULL; p=strchr(p,from))\n\t\t*p=to;\n\n\t/* ok, let's do it */\n\thLib = DLLOAD(tpath);\n\tif (hLib==NULL)\n\t{\n#if defined(_WIN32) && ! defined(__MINGW32__)\n\t\tif ( GetLastError()==193 ) /* invalid exe format -- happens when wrong version of MinGW is used */\n\t\t{\n\t\t\toutput_error(\"module '%s' load failed - invalid DLL format\",file);\n\t\t\t/* TROUBLESHOOT\n\t\t\t   GridLAB-D and MinGW are not compatible.  Most likely the 32-bit version of \n\t\t\t   MinGW is installed on a 64-bit machine running the 64-bit version of GridLAB-D.\n\t\t\t   Try installing MinGW64 instead.\n\t\t\t */\n\t\t\terrno = ENOEXEC;\n\t\t}\n\t\telse\n\t\t{\n\t\t\toutput_error(\"%s(%d): module '%s' load failed - %s (error code %d)\", __FILE__, __LINE__, file, strerror(errno), GetLastError());\n\t\t\terrno = ENOENT;\n\t\t}\n#else\n\t\toutput_error(\"%s(%d): module '%s' load failed - %s\", __FILE__, __LINE__, file, dlerror());\n\t\toutput_debug(\"%s(%d): path to module is '%s'\", __FILE__, __LINE__, tpath);\n#endif\n\t\tdlload_error(pathname);\n\t\terrno = ENOENT;\n\t\tfree(mod);\n\t\tmod = NULL;\n\t\treturn NULL;\n\t}\n\telse\n\t{\n\t\toutput_verbose(\"%s(%d): module '%s' loaded ok\", __FILE__, __LINE__, file);\n\t}\n\n\t/* get the initialization function */\n\tinit = (LIBINIT)DLSYM(hLib,\"init\");\n\tif (init==NULL)\n\t{\n\t\toutput_error(\"%s(%d): module '%s' does not export init()\", __FILE__, __LINE__, file);\n\t\tdlload_error(pathname);\n\t\terrno = ENOEXEC;\n\t\tfree(mod);\n\t\tmod = NULL;\n\t\treturn NULL;\n\t}\n\telse\n\t{\n\t\toutput_verbose(\"%s(%d): module '%s' exports init()\", __FILE__, __LINE__, file);\n\t}\n\n\t/* connect the module's exported data & functions */\n\tmod->hLib = (void*)hLib;\n\tpMajor = (int*)DLSYM(hLib, \"gld_major\");\n\tpMinor = (int*)DLSYM(hLib, \"gld_minor\");\n\tmod->major = pMajor?*pMajor:0;\n\tmod->minor = pMinor?*pMinor:0;\n\tmod->import_file = (int(*)(const char*))DLSYM(hLib,\"import_file\");\n\tmod->export_file = (int(*)(const char*))DLSYM(hLib,\"export_file\");\n\tmod->setvar = (int(*)(const char*,char*))DLSYM(hLib,\"setvar\");\n\tmod->getvar = (void*(*)(const char*,char*,unsigned int))DLSYM(hLib,\"getvar\");\n\tmod->check = (int(*)())DLSYM(hLib,\"check\");\n\t/* deltamode */\n\tmod->deltadesired = (unsigned long(*)(DELTAMODEFLAGS*))DLSYM(hLib,\"deltamode_desired\");\n\tmod->preupdate = (unsigned long(*)(void*,int64,unsigned int64))DLSYM(hLib,\"preupdate\");\n\tmod->interupdate = (SIMULATIONMODE(*)(void*,int64,unsigned int64,unsigned long, unsigned int))DLSYM(hLib,\"interupdate\");\n\tmod->deltaClockUpdate = (SIMULATIONMODE(*)(void *, double, unsigned long, SIMULATIONMODE))DLSYM(hLib,\"deltaClockUpdate\");\n\tmod->postupdate = (STATUS(*)(void*,int64,unsigned int64))DLSYM(hLib,\"postupdate\");\n\t/* clock  update */\n\tmod->clockupdate = (TIMESTAMP(*)(TIMESTAMP))DLSYM(hLib,\"clock_update\");\n\tmod->cmdargs = (int(*)(int,char**))DLSYM(hLib,\"cmdargs\");\n\tmod->kmldump = (int(*)(int(*)(const char*,...),OBJECT*))DLSYM(hLib,\"kmldump\");\n\tmod->subload = (MODULE *(*)(char *, MODULE **, CLASS **, int, char **))DLSYM(hLib, \"subload\");\n\tmod->test = (void(*)(int,char*[]))DLSYM(hLib,\"test\");\n\tmod->stream = (STREAMCALL)DLSYM(hLib,\"stream\");\n\tmod->globals = NULL;\n\tmod->term = (void(*)(void))DLSYM(hLib,\"term\");\n\tstrcpy(mod->name,file);\n\tmod->next = NULL;\n\n\t/* check the module version before trying to initialize */\n\tif ( mod->major!=REV_MAJOR || mod->minor!=REV_MINOR )\n\t{\n\t\toutput_error(\"Module version %d.%d mismatch from core version %d.%d\", mod->major, mod->minor, REV_MAJOR, REV_MINOR);\n\t\treturn NULL;\n\t}\n\n\t/* call the initialization function */\n\terrno = 0;\n\tmod->oclass = (*init)(&callbacks,(void*)mod,argc,argv);\n\tif ( mod->oclass==NULL && errno!=0 )\n\t\treturn NULL;\n\n\t/* connect intrinsic functions */\n\tfor (c=mod->oclass; c!=NULL; c=c->next) {\n\t\tchar fname[1024];\n\t\tstruct {\n\t\t\tFUNCTIONADDR *func;\n\t\t\tchar *name;\n\t\t\tint optional;\n\t\t} map[] = {\n\t\t\t{&c->create,\"create\",FALSE},\n\t\t\t{&c->init,\"init\",TRUE},\n\t\t\t{&c->precommit,\"precommit\",TRUE},\n\t\t\t{&c->sync,\"sync\",TRUE},\n\t\t\t{&c->commit,\"commit\",TRUE},\n\t\t\t{&c->finalize,\"finalize\",TRUE},\n\t\t\t{&c->notify,\"notify\",TRUE},\n\t\t\t{&c->isa,\"isa\",TRUE},\n\t\t\t{&c->plc,\"plc\",TRUE},\n\t\t\t{&c->recalc,\"recalc\",TRUE},\n\t\t\t{&c->update,\"update\",TRUE},\n\t\t\t{&c->heartbeat,\"heartbeat\",TRUE},\n\t\t};\n\t\tint i;\n\t\tfor (i=0; i<sizeof(map)/sizeof(map[0]); i++)\n\t\t{\n\t\t\tsnprintf(fname, sizeof(fname) ,\"%s_%s\",map[i].name,isforeign?fmod:c->name);\n\t\t\tif ((*(map[i].func) = (FUNCTIONADDR)DLSYM(hLib,fname))==NULL && !map[i].optional)\n\t\t\t{\n\t\t\t\toutput_fatal(\"intrinsic %s is not defined in class %s\", fname,file);\n\t\t\t\t/*\tTROUBLESHOOT\n\t\t\t\t\tA required intrinsic function was not found.  Please review and modify the class definition.\n\t\t\t\t */\n\t\t\t\terrno=EINVAL;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\telse\n\t\t\t\tif(!map[i].optional)\n\t\t\t\t\toutput_verbose(\"%s(%d): module '%s' intrinsic %s found\", __FILE__, __LINE__, file, fname);\n\t\t}\n\t}\n\n\t/* attach to list of known modules */\n\tif (first_module==NULL)\n\t{\n\t\tmod->id = 0;\n\t\tfirst_module = mod;\n\t}\n\telse\n\t{\n\t\tlast_module->next = mod;\n\t\tmod->id = last_module->id + 1;\n\t}\n\tlast_module = mod;\n\tmodule_count++;\n\n\t/* register the module stream, if any */\n\tif ( mod->stream!=NULL )\n\t\tstream_register(mod->stream);\n\n\treturn last_module;\n}\n\n#ifdef _WIN32\n#include <winnt.h>\nstatic bool _checkimg(const char *fname)\n{\n\tFILE *fh = fopen(fname,\"r\");\n\tif ( fh!=NULL )\n\t{\n\t\tstruct _IMAGE_DOS_HEADER dh;\n\t\t// access DLL image\n\t\tfclose(fh);\n\t}\n\treturn true;\n}\n#endif\n\nstatic void _module_list (char *path)\n{\n\tstruct stat info;\n\tstatic int count = 0;\n\tint gsrm = global_suppress_repeat_messages;\n#ifdef _WIN32\n\tchar search[1024];\n\tHANDLE hFind;\n\tWIN32_FIND_DATA sFind;\n#else\n\tDIR *dir;\n\tstruct dirent *ent;\n#endif\n\tif(path == NULL){\n\t\treturn;\n\t}\n\t/* access directory */\n\tif ( stat(path,&info)!=0 )\n\t\treturn;\n\t\n\t/* write header if necessary */\n\tif ( (count++%25) == 0 )\n\t{\n\t\toutput_message(\"Module name              Version Location\");\n\t\toutput_message(\"------------------------ ------- ----------------------------------------\");\n\t}\n\n\t/* open directory */\n#ifdef _WIN32\n\tsprintf(search,\"%s\\\\*.dll\",path);\n\thFind=FindFirstFile(search,&sFind);\n\tif ( hFind==INVALID_HANDLE_VALUE )\n\t\treturn;\n\tdo {\n#else\n\tif ( (dir=opendir(path))==NULL )\n\t\treturn;\n\twhile((ent = readdir(dir)) != NULL) {\n#endif\n\n\t/* iterate files list */\n\t\tchar fname[1024];\n\t\tchar *ext;\n\t\tvoid *hLib = NULL;\n\t\tint *pMajor = NULL, *pMinor = NULL;\n\t\tLIBINIT init = NULL;\n\t\tglobal_suppress_repeat_messages = 0;\n#ifdef _WIN32\n\t\tstrcpy(fname,sFind.cFileName);\n\t\t/* check image */\n\t\tif ( !_checkimg(fname) ) continue;\n#else\n\t\t// TODO Posix version\n\t\t/* isolate so files only */\n\t\tstrcpy(fname, ent->d_name);\n\t\text = strrchr(fname,'.');\n\t\tif ( ext==NULL ) continue; /* no extension */\n\t\tif ( strcmp(ext,\".so\")!=0 ) continue; /* not the right extension */\n#endif\n\t\t/* access DLL */\n\t\thLib = DLLOAD(fname);\n\t\tif ( hLib==NULL ) continue;\n\t\tif ( DLSYM(hLib,\"init\")==NULL ) continue;\n\t\tpMajor = (int*)DLSYM(hLib, \"major\");\n\t\tpMinor = (int*)DLSYM(hLib, \"minor\");\n\t\tif ( pMajor==NULL || pMinor==NULL ) continue;\n\n\t\t/* TODO print info */\n\t\toutput_message(\"%-24.24s %5d.%d %s\", fname, *pMajor, *pMinor, path);\n#ifdef _WIN32\n\t\tglobal_suppress_repeat_messages = gsrm;\n\t} while ( FindNextFile(hFind,&sFind) );\n\tFindClose(hFind);\n#else\n\t}\n\tclosedir(dir);\n#endif\n}\n\nvoid module_list(void)\n{\n\tchar *glpath = getenv(\"GLPATH\");\n\tchar *gridlabd = getenv(\"GRIDLABD\");\n\tchar *tokPath = NULL;\n\tchar *tokPathPtr = NULL;\n#ifdef _WIN32\n\tchar *pathDelim = \";\";\n#else\n\tchar *pathDelim = \":\";\n#endif\n\n\t_module_list(global_workdir);\n\t_module_list(global_execdir);\n\tif(glpath != NULL){\n\t\tchar *glPath = malloc(sizeof(char) * (unsigned)strlen(glpath));\n\t\tstrncpy(glPath, glpath, (unsigned)strlen(glpath));\n\t\ttokPath = strtok_r(glPath, pathDelim, &tokPathPtr);\n\t\twhile (tokPath != NULL){\n\t\t\t_module_list(tokPath);\n\t\t\ttokPath = strtok_r(NULL, pathDelim, &tokPathPtr);\n\t\t}\n\t\ttokPathPtr = NULL;\n\t\tfree(glPath);\n\t}\n\tif(gridlabd != NULL){\n\t\tchar *gridLabD = malloc(sizeof(char) * (unsigned)strlen(gridlabd));\n\t\tstrncpy(gridLabD, gridlabd, (unsigned)strlen(gridlabd));\n\t\ttokPath = strtok_r(gridLabD, pathDelim, &tokPathPtr);\n\t\twhile (tokPath != NULL){\n\t\t\t_module_list(tokPath);\n\t\t\ttokPath = strtok_r(NULL, pathDelim, &tokPathPtr);\n\t\t}\n\t\tfree(gridLabD);\n\t}\n}\nint module_setvar(MODULE *mod, const char *varname, char *value)\n{\n\tchar modvarname[1024];\n\tsprintf(modvarname,\"%s::%s\",mod->name,varname);\n\treturn global_setvar(modvarname,value)==SUCCESS;\n}\n\nvoid* module_getvar(MODULE *mod, const char *varname, char *value, unsigned int size)\n{\n\tchar modvarname[1024];\n\tsprintf(modvarname,\"%s::%s\",mod->name,varname);\n\treturn global_getvar(modvarname,value,size);\n}\n\nvoid* module_getvar_old(MODULE *mod, const char *varname, char *value, unsigned int size)\n{\n\tif (mod->getvar!=NULL)\n\t{\n\t\tif (strcmp(varname,\"major\")==0)\n\t\t{\n\t\t\tsprintf(value,\"%d\",mod->major);\n\t\t\treturn value;\n\t\t}\n\t\telse if (strcmp(varname,\"minor\")==0)\n\t\t{\n\t\t\tsprintf(value,\"%d\",mod->minor);\n\t\t\treturn value;\n\t\t}\n\t\telse\n\t\t\treturn (*mod->getvar)(varname,value,size);\n\t}\n\telse\n\t\treturn 0;\n}\n\ndouble* module_getvar_addr(MODULE *mod, const char *varname)\n{\n\tchar modvarname[1024];\n\tGLOBALVAR *var;\n\tsprintf(modvarname,\"%s::%s\",mod->name,varname);\n\tvar = global_find(modvarname);\n\tif (var!=NULL)\n\t\treturn var->prop->addr;\n\telse\n\t\treturn NULL;\n}\n\nint module_saveall(FILE *fp)\n{\n\tMODULE *mod;\n\tint count=0;\n\tCLASS *oclass = NULL;\n\tchar varname[1024];\n\tchar buffer[1024];\n\tcount += fprintf(fp,\"\\n////////////////////////////////////////////////////////\\n\");\n\tcount += fprintf(fp,\"// modules\\n\");\n\tfor (mod=first_module; mod!=NULL; mod=mod->next)\n\t{\n\t\tvarname[0] = '\\0';\n\t\toclass = NULL;\n\n\t\tcount += fprintf(fp,\"module %s {\\n\",mod->name);\n\t\tif (mod->major>0 || mod->minor>0)\n\t\t\tcount += fprintf(fp,\"\\tmajor %d;\\n\\tminor %d;\\n\",mod->major,mod->minor);\n\t\tfor (oclass=mod->oclass; oclass!=NULL ; oclass=oclass->next)\n\t\t{\n\t\t\tif (oclass->module==mod)\n\t\t\t\tcount += fprintf(fp,\"\\tclass %s;\\n\",oclass->name);\n\t\t}\n\n\t\twhile (module_getvar(mod,varname,buffer,sizeof(buffer)))\n\t\t{\n\t\t\tcount += fprintf(fp,\"\\t%s %s;\\n\",varname,buffer);\n\t\t}\n\t\tcount += fprintf(fp,\"}\\n\");\n\t}\n\treturn count;\n}\n\nint module_saveall_xml(FILE *fp){\n\tMODULE *mod;\n\tint count = 0;\n\tchar32 varname = \"\";\n\tchar32 value = \"\";\n\tGLOBALVAR *gvptr = NULL;\n\tchar1024 buffer;\n\n\tfor (mod = first_module; mod != NULL; mod = mod->next){\n\t\tchar tname[67];\n\t\tsize_t tlen;\n\t\tgvptr = global_getnext(NULL);\n\t\tsprintf(tname, \"%s::\", mod->name);\n\t\ttlen = strlen(tname);\n\t\tcount += fprintf(fp, \"\\t<module type=\\\"%s\\\" \", mod->name);\n\t\tif (mod->major > 0){\n\t\t\tcount += fprintf(fp, \"major=\\\"%d\\\" minor=\\\"%d\\\">\\n\", mod->major, mod->minor);\n\t\t} else {\n\t\t\tcount += fprintf(fp, \">\\n\");\n\t\t}\n\t\tcount += fprintf(fp, \"\\t\\t<properties>\\n\");\n\t\twhile(gvptr != NULL){\n\t\t\tif(strncmp(tname, gvptr->prop->name, tlen) == 0){\n\t\t\t\tcount += fprintf(fp, \"\\t\\t\\t<%s>%s</%s>\\n\", gvptr->prop->name+tlen, class_property_to_string(gvptr->prop,(void*)gvptr->prop->addr,buffer,1024)>0 ? buffer : \"...\", gvptr->prop->name+tlen);\n\t\t\t} // else we have a module::prop name\n\t\t\tgvptr = global_getnext(gvptr);\n\t\t}\n\t\tcount += fprintf(fp, \"\\t\\t</properties>\\n\");\n\t\tmodule_saveobj_xml(fp, mod);\t/* insert objects w/in module tag */\n\t\tcount += fprintf(fp,\"\\t</module>\\n\");\n\t}\n\treturn count;\n}\n\n#if defined WIN32 && ! defined __MINGW32__\n#define isnan _isnan  /* map isnan to appropriate function under Windows */\n#endif\n\nint module_saveobj_xml(FILE *fp, MODULE *mod){ /**< the stream to write to */\n\tunsigned count = 0;\n\tchar buffer[1024];\n\tPROPERTY *prop = NULL;\n\tOBJECT *obj;\n\tCLASS *oclass=NULL;\n\tCLASS *pclass = NULL;\n\n\tfor(obj = object_get_first(); obj != NULL; obj = obj->next){\n\t\tchar32 oname = \"(unidentified)\";\n\t\tif(obj->oclass->module != mod){\n\t\t\tcontinue;\n\t\t}\n\n\t\tif(obj->name != NULL){\n\t\t\tstrcpy(oname, obj->name);\n\t\t} else {\n\t\t\tsprintf(oname, \"%s:%i\", obj->oclass->name, obj->id);\n\t\t}\n\t\tif ((oclass == NULL) || (obj->oclass != oclass))\n\t\t\toclass = obj->oclass;\n\t\tcount += fprintf(fp,\"\\t\\t<object type=\\\"%s\\\" id=\\\"%i\\\" name=\\\"%s\\\">\\n\", obj->oclass->name, obj->id, oname);\n\n\t\t/* dump internal properties */\n\t\tif (obj->parent!=NULL){\n\t\t\tif(obj->parent->name != NULL){\n\t\t\t\tstrcpy(oname, obj->parent->name);\n\t\t\t} else {\n\t\t\t\tsprintf(oname, \"%s:%i\", obj->parent->oclass->name, obj->parent->id);\n\t\t\t}\n\t\t\tcount += fprintf(fp,\"\\t\\t\\t<parent>%s</parent>\\n\", oname);\n\t\t} else {\n\t\t\tcount += fprintf(fp,\"\\t\\t\\t<parent>root</parent>\\n\");\n\t\t}\n\t\tcount += fprintf(fp,\"\\t\\t\\t<rank>%d</rank>\\n\", obj->rank);\n\t\tcount += fprintf(fp,\"\\t\\t\\t<clock>\\n\", obj->clock);\n\t\tcount += fprintf(fp,\"\\t\\t\\t\\t <timestamp>%s</timestamp>\\n\", convert_from_timestamp(obj->clock,buffer,sizeof(buffer))>0?buffer:\"(invalid)\");\n\t\tcount += fprintf(fp,\"\\t\\t\\t</clock>\\n\");\n\t\t/* why do latitude/longitude have 2 values?  I currently only store as float in the schema... -dc */\n\t\tif (!isnan(obj->latitude))\n\t\t\tcount += fprintf(fp,\"\\t\\t\\t<latitude>%s</latitude>\\n\", convert_from_latitude(obj->latitude,buffer,sizeof(buffer))?buffer:\"(invalid)\");\n\t\telse\n\t\t\tcount += fprintf(fp, \"\\t\\t\\t<latitude>NONE</latitude>\\n\");\n\t\tif (!isnan(obj->longitude))\n\t\t\tcount += fprintf(fp,\"\\t\\t\\t<longitude>%s</longitude>\\n\",convert_from_longitude(obj->longitude,buffer,sizeof(buffer))?buffer:\"(invalid)\");\n\t\telse\n\t\t\tcount += fprintf(fp,\"\\t\\t\\t<longitude>NONE</longitude>\\n\");\n\n\t\t/* dump properties */\n\t\tfor (prop=oclass->pmap;prop!=NULL && prop->oclass==oclass;prop=prop->next)\n\t\t{\n\t\t\tchar *value = NULL;\n\t\t\tif((prop->access != PA_PUBLIC) && (prop->access != PA_REFERENCE))\n\t\t\t\tcontinue;\n\t\t\tvalue = object_property_to_string(obj,prop->name, buffer, 1023);\n\t\t\tif (value!=NULL){\n\t\t\t\tcount += fprintf(fp, \"\\t\\t\\t<%s>%s</%s>\\n\", prop->name, value, prop->name);\n\t\t\t}\n\t\t}\n\t\tpclass = oclass->parent;\n\t\twhile(pclass != NULL){ /* inherited properties */\n\t\t\tfor (prop=pclass->pmap;prop!=NULL && prop->oclass==pclass;prop=prop->next){\n\t\t\t\tchar *value = object_property_to_string(obj,prop->name, buffer, 1023);\n\t\t\t\tif (value!=NULL){\n\t\t\t\t\tcount += fprintf(fp, \"\\t\\t\\t<%s>%s</%s>\\n\", prop->name, value, prop->name);\n\t\t\t\t}\n\t\t\t}\n\t\t\tpclass = pclass->parent;\n\t\t}\n\t\tcount += fprintf(fp,\"\\t\\t</object>\\n\");\n\t}\n\treturn count;\n}\n\nMODULE *module_get_first(void)\n{\n\treturn first_module;\n}\n\nint module_saveall_xml_old(FILE *fp);\n\nint module_saveall_xml_old(FILE *fp)\n{\n\tMODULE *mod;\n\tint count=0;\n\tcount += fprintf(fp,\"\\t<modules>\\n\");\n\tfor (mod=first_module; mod!=NULL; mod=mod->next)\n\t{\n\t\tCLASS *oclass;\n\t\tchar32 varname=\"\";\n\t\tcount += fprintf(fp,\"\\t\\t<module> \\n\");\n\t\tcount += fprintf(fp,\"\\t\\t\\t<name>%s</name>\\n\",mod->name);\n\t\tif(mod->major > 0)\n\t\t\tcount += fprintf(fp,\"\\t\\t\\t<major>%d</major>\\n\",mod->major );\n\t\tif(mod->minor > 0)\n\t\t\tcount += fprintf(fp,\"\\t\\t\\t<minor>%d</minor>\\n\",mod->minor);\n\t\tcount += fprintf(fp,\"\\t\\t\\t<classes>\\n\");\n\t\tfor (oclass=mod->oclass; oclass!=NULL ; oclass=oclass->next)\n\t\t{\n\t\t\tif (oclass->module==mod){\n\t\t\t\tcount += fprintf(fp, \"\\t\\t\\t\\t<class> \\n\");\n\t\t\t\tcount += fprintf(fp, \"\\t\\t\\t\\t\\t<classname>%s</classname>\\n\", oclass->name);\n\t\t\t\tcount += fprintf(fp, \"\\t\\t\\t\\t\\t<module name=\\\"%s\\\" />\\n\", mod->name);\n\t\t\t\tcount += fprintf(fp, \"\\t\\t\\t\\t</class>\\n\");\n\t\t\t}\n\t\t}\n\t\tcount += fprintf(fp,\"\\t\\t\\t</classes>\\n\");\n\t\tcount += fprintf(fp,\"\\t\\t\\t<properties>\\n\");\n\t\twhile (module_getvar(mod,varname,NULL,0))\n\t\t{\n\t\t\tchar32 value;\n\t\t\tif (module_getvar(mod,varname,value,sizeof(value)))\n\t\t\t{\t/* TODO: support other types (ticket #46) */\n\t\t\t\tcount += fprintf(fp,\"\\t\\t\\t\\t<property> \\n\");\n\t\t\t\tcount += fprintf(fp,\"\\t\\t\\t\\t\\t <type>double</type>\\n\", varname);\n\t\t\t\tcount += fprintf(fp,\"\\t\\t\\t\\t\\t <name>%s</name>\\n\", value);\n\t\t\t\tcount += fprintf(fp,\"\\t\\t\\t\\t</property> \\n\");\n\t\t\t}\n\t\t}\n\t\tcount += fprintf(fp,\"\\t\\t\\t</properties>\\n\");\n\t\tcount += fprintf(fp,\"\\t\\t</module>\\n\");\n\t}\n\tcount += fprintf(fp,\"\\t</modules>\\n\");\n\treturn count;\n}\n\nMODULE *module_find(char *modname)\n{\n\tMODULE *mod = NULL;\n\tfor (mod=first_module; mod!=NULL; mod=mod->next)\n\t{\n\t\tif (strcmp(mod->name,modname)==0)\n\t\t\tbreak;\n\t}\n\treturn mod;\n\n}\n\nint module_import(MODULE *mod, const char *filename)\n{\n\tif (mod->import_file == NULL)\n\t{\n\t\terrno = ENOENT;\n\t\treturn 0;\n\t}\n\treturn (*mod->import_file)(filename);\n}\n\nint module_export(MODULE *mod, const char *filename)\n{\n\tif (mod->export_file == NULL)\n\t{\n\t\terrno = ENOENT;\n\t\treturn 0;\n\t}\n\treturn (*mod->export_file)(filename);\n}\n\nint module_save(MODULE *mod, const char *filename)\n{\n\tif (mod->export_file == NULL)\n\t{\n\t\terrno = ENOENT;\n\t\treturn 0;\n\t}\n\treturn (*mod->export_file)(filename);\n}\n\nint module_dumpall(void)\n{\n\tMODULE *mod;\n\tint count=0;\n\tfor (mod=first_module; mod!=NULL; mod=mod->next)\n\t{\n\t\tif (mod->export_file!=NULL)\n\t\t\tcount += module_save(mod,NULL);\n\t}\n\treturn count;\n}\n\nint module_checkall(void)\n{\n\tMODULE *mod;\n\tint count=0;\n\tfor (mod=first_module; mod!=NULL; mod=mod->next)\n\t\t\tcount += module_check(mod);\n\treturn count;\n}\n\nint module_check(MODULE *mod)\n{\n\tif (mod->check==NULL)\n\t\treturn 0;\n\treturn (*mod->check)();\n}\n\nvoid module_libinfo(const char *module_name)\n{\n\tMODULE *mod = module_load(module_name,0,NULL);\n\tif (mod!=NULL)\n\t{\n\t\tCLASS *c;\n\t\tPROPERTY *p;\n\t\tGLOBALVAR *v=NULL;\n\t\toutput_raw(\"Module name....... %s\\n\", mod->name);\n\t\toutput_raw(\"Major version..... %d\\n\", mod->major);\n\t\toutput_raw(\"Minor version..... %d\\n\", mod->minor);\n\t\toutput_raw(\"Classes........... \");\n\t\tfor (c=mod->oclass; c!=NULL; c=c->next)\n\t\t\toutput_raw(\"%s%s\", c->name, c->next!=NULL?\", \":\"\");\n\t\toutput_raw(\"\\n\");\n\t\toutput_raw(\"Implementations... \");\n\t\tif (mod->cmdargs!=NULL) output_raw(\"cmdargs \");\n\t\tif (mod->getvar!=NULL) output_raw(\"getvar \");\n\t\tif (mod->setvar!=NULL) output_raw(\"setvar \");\n\t\tif (mod->import_file!=NULL) output_raw(\"import_file \");\n\t\tif (mod->export_file!=NULL) output_raw(\"export_file \");\n\t\tif (mod->check!=NULL) output_raw(\"check \");\n\t\tif (mod->kmldump!=NULL) output_raw(\"kmldump \");\n\t\tif (mod->stream!=NULL) output_raw(\"stream \");\n\t\toutput_raw(\"\\nGlobals........... \");\n\t\tfor (p=mod->globals; p!=NULL; p=p->next)\n\t\t\toutput_raw(\"%s \", p->name);\n\t\twhile ((v=global_getnext(v))!=NULL)\n\t\t{\n\t\t\tif (strncmp(v->prop->name,module_name,strlen(module_name))==0)\n\t\t\t{\n\t\t\t\tchar *vn = strstr(v->prop->name,\"::\");\n\t\t\t\tif (vn!=NULL)\n\t\t\t\t\toutput_raw(\"%s \", vn+2);\n\t\t\t}\n\t\t}\n\t\toutput_raw(\"\\n\");\n\t}\n\telse\n\t\toutput_error(\"Module %s load failed\", module_name);\n}\n\nint module_cmdargs(int argc, char **argv)\n{\n\tMODULE *mod;\n\tfor (mod=first_module; mod!=NULL; mod=mod->next)\n\t{\n\t\tif (mod!=NULL && mod->cmdargs!=NULL)\n\t\t\treturn (*(mod->cmdargs))(argc,argv);\n\t}\n\treturn 0;\n}\n\nint module_depends(const char *name, unsigned char major, unsigned char minor, unsigned short build)\n{\n\tMODULE *mod;\n\tfor (mod=first_module; mod!=NULL; mod=mod->next)\n\t{\n\t\tif (strcmp(mod->name,name)==0)\n\t\t\tif( major>0 && mod->major>0 )\n\t\t\t\tif( mod->major==major && mod->minor>=minor )\n\t\t\t\t\treturn 1; // version matched\n\t\t\t\telse\n\t\t\t\t\treturn 0; // version mismatched\n\t\t\telse\n\t\t\t\treturn 1; // indifferent to version\n\t}\n\treturn module_load(name,0,NULL)!=NULL;\n}\n\nMODULE *module_get_next(MODULE*module)\n{\n\treturn module->next;\n}\n\nvoid module_termall(void)\n{\n\tMODULE *mod;\n\tfor (mod=first_module; mod!=NULL; mod=mod->next)\n\t{\n\t\tif ( mod->term ) mod->term();\n\t}\n}\n\n\n/***************************************************************************\n * EXTERNAL COMPILER SUPPORT\n ***************************************************************************/\n\n#include <sys/stat.h>\n\n#ifdef _WIN32\n#ifdef X64\n#define CC \"gcc\"\n#define CCFLAGS \"-DWIN32 -DX64\"\n#define LDFLAGS \"\" /* \"--export-all-symbols,--add-stdcall,--add-stdcall-alias,--subsystem,windows,--enable-runtime-pseudo-reloc,-no-undefined\" */\n#else // !X64\n#define CC \"gcc\"\n#define CCFLAGS \"-DWIN32\"\n#define LDFLAGS \"\" /* \"--export-all-symbols,--add-stdcall,--add-stdcall-alias,--subsystem,windows,--enable-runtime-pseudo-reloc,-no-undefined\" */\n#endif // X64\n#define fstat _fstat\n#define stat _stat\n#else // !WIN32\n#define CC \"/usr/bin/gcc\"\n#ifdef __APPLE__\n#define CCFLAGS \"-DMACOSX\"\n#define LDFLAGS \"-dylib\"\n#else // !__APPLE__\n#define CCFLAGS \"-DLINUX -fPIC\"\n#define LDFLAGS \"\" /* --export-all-symbols\" */\n#endif // __APPLE__\n#endif // WIN32\n\nstatic int cc_verbose=0;\nstatic int cc_debug=0;\nstatic int cc_clean=0;\nstatic int cc_keepwork=0;\n\n/** Get file modify time\n    @return modification time in seconds of epoch, 0 on missing file or fstat failure\n **/\nstatic time_t file_modtime(char *file) /**< file name to query */\n{\n\tFILE *fp = fopen(file,\"r\");\n\tif (fp)\n\t{\n\t\tstruct stat status;\n\t\tif ( fstat(fileno(fp),&status)==0 )\n\t\t\treturn status.st_mtime;\n\t}\n\treturn 0;\n}\n\n/** Execute a command using formatted strings\n    @return command return code\n **/\nstatic int execf(char *format, /**< format string  */\n\t\t\t\t ...) /**< parameters  */\n{\n\tchar command[4096];\n\tint rc;\n\tva_list ptr;\n\tva_start(ptr,format);\n\tvsprintf(command,format,ptr); /* note the lack of check on buffer overrun */\n\tva_end(ptr);\n\tif (cc_verbose || global_verbose_mode ) output_message(command);\n\telse output_debug(\"command: %s\",command);\n\trc = system(command);\n\toutput_debug(\"return code=%d\",rc);\n\treturn rc;\n}\n\n/** Compile C source code into a dynamic link library \n    @return 0 on success\n **/\nint module_compile(char *name,\t/**< name of library */\n\t\t\t\t   char *code,\t/**< listing of source code */\n\t\t\t\t   int flags,\t/**< compile options (see MC_?) */\n\t\t\t\t   char *prefix, /**< file prefix */\n\t\t\t\t   char *source,/**< source file (for context) */\n\t\t\t\t   int line)\t/**< source line (for context) */\n{\n\tchar cfile[1024];\n\tchar ofile[1024];\n\tchar afile[1024];\n\tchar *cc = getenv(\"CC\")?getenv(\"CC\"):CC;\n\tchar *ccflags = getenv(\"CCFLAGS\")?getenv(\"CCFLAGS\"):CCFLAGS;\n\tchar *ldflags = getenv(\"LDFLAGS\")?getenv(\"LDFLAGS\"):LDFLAGS;\n\tint rc;\n\tsize_t codesize = strlen(code), len;\n\tFILE *fp;\n\tchar srcfile[1024];\n\tchar mopt[8] = \"\";\n\tchar *libs = \"-lstdc++\";\n#ifdef _WIN32\n\tsnprintf(mopt,sizeof(mopt),\"-m%d\",sizeof(void*)*8);\n\tlibs = \"\";\n#endif\n\n\t/* normalize source file name */\n\tif ( source )\n\t{\n\t\tchar *c, *p=srcfile;\n\t\tstrcpy(srcfile,source);\n\t\tfor ( c=srcfile; *c!='\\0'; c++ )\n\t\t{\n\t\t\tswitch (*c) {\n\t\t\t\tcase '\\\\': *p++='/'; break;\n\t\t\t\tdefault: *p++=*c; break;\n\t\t\t}\n\t\t}\n\t\t*c='\\0';\n\t\tsource = srcfile;\n\t}\n\n\n\t/* set flags */\n\tcc_verbose = (flags&MC_VERBOSE);\n\tcc_debug = (flags&MC_DEBUG);\n\tcc_clean = (flags&MC_CLEAN);\n\tcc_keepwork = (flags&MC_KEEPWORK);\n\n\t/* construct the file names */\n\tsnprintf(cfile,sizeof(cfile),\"%s.c\",name);\n\tsnprintf(ofile,sizeof(ofile),\"%s.o\",name);\n\tsnprintf(afile,sizeof(afile),\"%s\" DLEXT,name);\n\n\t/* create the C source file */\n\tif ( (fp=fopen(cfile,\"wt\"))==NULL)\n\t{\n\t\toutput_error(\"unable to open '%s' for writing\", cfile);\n\t\treturn -1;\n\t}\n\n\t/* store prefix code */\n\tfprintf(fp,\"/* automatically generated code\\nSource: %s(%d)\\n */\\n%s\\n\",source,line,prefix?prefix:\"\");\n\n\t/* store file/line reference */\n\tif (source!=NULL) fprintf(fp,\"#line %d \\\"%s\\\"\\n\",line,source); \n\n\t/* write C source code */\n\tif ( (len=fwrite(code,1,codesize,fp))<codesize )\n\t{\n\t\toutput_error(\"unable to write code to '%s' (%d of %d bytes written)\", cfile, len, codesize);\n\t\treturn -1;\n\t}\n\n\t/* C file done */\n\tfclose(fp);\n\n\t/* compile the code */\n\tif ( (rc=execf(\"%s %s %s -c \\\"%s\\\" -o \\\"%s\\\" \", cc, mopt, ccflags, cfile, ofile))!=0 )\n\t\treturn rc;\n\n\t/* create needed DLL files on windows */\n\tif ( (rc=execf(\"%s %s %s%s -shared \\\"%s\\\" -o \\\"%s\\\"\", cc, mopt, ((ldflags[0]==0)?\"\":\"-Wl,\"), ldflags, ofile,afile))!=0 )\n\t\treturn rc;\n\n#ifdef LINUX\n\t/* address SE textrel_shlib_t issue */\n\tif (global_getvar(\"control_textrel_shlib_t\",tbuf,63)!=NULL)\n\t{\n\t\t/* SE linux needs the new module marked as relocatable (textrel_shlib_t) */\n\t\texecf(\"chcon -t textrel_shlib_t '%s'\", afile);\n\t}\n#endif\n\n\tif ( !cc_keepwork )\n\t{\n\t\tunlink(cfile);\n\t\tunlink(ofile);\n\t}\n\n\treturn 0;\n}\n\n/***************************************************************************\n * EXTERN SUPPORT\n ***************************************************************************/\n\ntypedef struct s_exfnmap {\n\tchar *fname;\n\tchar *libname;\n\tvoid *lib;\n\tvoid *call;\n\tstruct s_exfnmap *next;\n} EXTERNALFUNCTION;\nEXTERNALFUNCTION *external_function_list = NULL;\n\n/* saves mapping - fctname will be stored in new malloc copy, libname must already be a copy in heap */\nstatic int add_external_function(char *fctname, char *libname, void *lib)\n{\n\tif ( module_get_transform_function(fctname)==NULL )\n\t{\n\t\tint ordinal;\n\t\tchar function[1024];\n\t\tEXTERNALFUNCTION *item = malloc(sizeof(EXTERNALFUNCTION));\n\t\tif ( item==NULL ) \n\t\t{\n\t\t\toutput_error(\"add_external_function(char *fn='%s',lib='%s',...): memory allocation failed\", fctname, libname);\n\t\t\treturn 0;\n\t\t}\n\t\titem->fname = malloc(strlen(fctname)+1);\n\t\tif ( item->fname==NULL )\n\t\t{\n\t\t\toutput_error(\"add_external_function(char *fn='%s',lib='%s',...): memory allocation failed\", fctname, libname);\n\t\t\treturn 0;\n\t\t}\n\t\titem->libname = libname;\n\t\titem->lib = lib;\n\t\titem->next = external_function_list;\n\t\texternal_function_list = item;\n\n\t\t/* this is to address a frequent MinGW/MSVC incompatibility with DLLs */\n\t\tif ( sscanf(fctname,\"%[^@]@%d\",function,&ordinal)==2)\n\t\t{\n#ifdef _WIN32\n\t\t\titem->call = DLSYM(lib,(LPCSTR)(short)ordinal);\n#else\n\t\t\titem->call = DLSYM(lib,function);\n#endif\n\t\t\tstrcpy(item->fname,function);\n\t\t}\n\t\telse\n\t\t{\n\t\t\titem->call = DLSYM(lib,fctname);\n\t\t\tstrcpy(item->fname,fctname);\n\t\t}\n\t\tif ( item->call )\n\t\t\toutput_debug(\"external function '%s' added from library '%s' (lib=%8x)\", item->fname, libname, (int64)lib);\n\t\telse\n\t\t\toutput_warning(\"external function '%s' not found in library '%s'\", fctname, libname);\n\t\treturn 1;\n\t}\n\telse\n\t{\n\t\toutput_warning(\"external function '%s' is already defined\", fctname);\n\t\treturn 1;\n\t}\n}\n\n/* loads the DLL and maps the comma separate function list */\nint module_load_function_list(char *libname, char *fnclist)\n{\n\tchar libpath[1024];\n\tchar *static_name = malloc(strlen(libname)+1);\n\tvoid *lib;\n\tchar *s, *e;\n\t\n\tif ( static_name==0 ) return 0; // malloc failed\n\tstrcpy(static_name,libname); // use this copy to map functions\n\n\t/* load the library */\n\tif ( strchr(libname,'/')==NULL )\n\t\tsnprintf(libpath,sizeof(libpath),\"./%s\" DLEXT, libname);\n\telse\n\t\tsnprintf(libpath,sizeof(libpath),\"%s\" DLEXT, libname);\n\n\tlib = DLLOAD(libpath);\n\terrno = GetLastError();\n\tif (lib==NULL)\n\t{\n#ifdef _WIN32\n\t\tLPTSTR error;\n\t\tLPTSTR end;\n\t\tDWORD result = FormatMessage(\n\t\t\t\tFORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,\n\t\t\t\tNULL, GetLastError(), 0,\n\t\t\t\t(LPTSTR) &error, 0, NULL);\n\t\tif (!result)\n\t\t\terror = TEXT(\"[FormatMessage failed]\");\n\t\telse for (end = error + strlen(error) - 1; end >= error && isspace(*end); end--)\n\t\t\t*end = 0;\n#else\n\t\tchar *error = dlerror();\n#endif\n\t\toutput_error(\"unable to load external library '%s': %s (errno=%d)\", libpath, error, errno);\n\t\treturn 0;\n\t}\n\toutput_debug(\"loaded external function library '%s' ok\",libname);\n\n\t/* map the functions */\n\tfor ( s=fnclist; *s!='\\0' ; s++ )\n\t{\n\t\tif ( !isspace(*s) && *s!=',' ) // start of a name\n\t\t{\n\t\t\t// span valid characters\n\t\t\tchar c;\n\t\t\tfor ( e=s; !isspace(*s) && *e!=',' && *e!='\\0'; e++ );\n\t\t\tc = *e; *e = '\\0';\n\t\t\tadd_external_function(s,static_name,lib);\n\t\t\ts = e;\n\t\t\tif ( c=='\\0' ) break;\n\t\t}\n\t}\n\n\treturn 1; // ok\n}\n\n/* gets an external function from a module to use as a transform function */\nTRANSFORMFUNCTION module_get_transform_function(const char *function)\n{\n\tEXTERNALFUNCTION *item;\n\tfor ( item=external_function_list; item!=NULL ; item=item->next )\n\t{\n\t\tif ( strcmp(item->fname,function)==0 )\n\t\t\treturn item->call;\n\t}\n\terrno = ENOENT;\n\treturn NULL;\n}\n\nconst char *module_find_transform_function(TRANSFORMFUNCTION function)\n{\n\tEXTERNALFUNCTION *item;\n\tfor ( item=external_function_list; item!=NULL ; item=item->next )\n\t{\n\t\tif ( strcmp(item->call,function)==0 )\n\t\t\treturn item->fname;\n\t}\n\terrno = ENOENT;\n\treturn NULL;\n}\n\n#include \"class.h\"\n\nvoid module_profiles(void)\n{\n\tif ( global_mt_analysis>0 )\n\t{\n\t\tOBJECT *obj;\n\t\tunsigned int n_ranks = 0;\n\t\tstruct s_rankdata {\n\t\t\tint64 t_presync, t_sync, t_postsync;\n\t\t\tint64 n_presync, n_sync, n_postsync;\n\t\t\tdouble total;\n\t\t} *rankdata;\n\t\tunsigned int n, r;\n\n\t\toutput_profile(\"Multithreading analysis\");\n\t\toutput_profile(\"=======================\\n\");\n\t\t\n\t\t/* analysis assumes data was collected during a single threaded run */\n\t\tif ( global_threadcount>1 )\n\t\t{\n\t\t\toutput_profile(\"thread count must be 1 to complete analysis\");\n\t\t\treturn;\n\t\t}\n\n\t\t/* determine number of ranks used */\n\t\tfor ( obj=object_get_first(); obj!=NULL ; obj=obj->next )\n\t\t{\n\t\t\tif ( n_ranks < obj->rank + 1 )\n\t\t\t\tn_ranks = obj->rank + 1;\n\t\t}\n\t\tn_ranks;\n\n\t\t/* allocate working buffers */\n\t\trankdata = (struct s_rankdata*)malloc(n_ranks*sizeof(struct s_rankdata));\n\t\tmemset(rankdata,0,n_ranks*sizeof(struct s_rankdata));\n\n\t\t/* gather rank data */\n\t\tfor ( obj=object_get_first(); obj!=NULL ; obj=obj->next )\n\t\t{\n\t\t\tstruct s_rankdata *rank = &rankdata[obj->rank];\n\t\t\tif ( obj->oclass->passconfig&PC_PRETOPDOWN )\n\t\t\t{\n\t\t\t\trank->t_presync += obj->synctime[0];\n\t\t\t\trank->n_presync++;\n\t\t\t}\n\t\t\tif ( obj->oclass->passconfig&PC_BOTTOMUP )\n\t\t\t{\n\t\t\t\trank->t_sync += obj->synctime[1];\n\t\t\t\trank->n_sync++;\n\t\t\t}\n\t\t\tif ( obj->oclass->passconfig&PC_POSTTOPDOWN )\n\t\t\t{\n\t\t\t\trank->t_postsync += obj->synctime[2];\n\t\t\t\trank->n_postsync++;\n\t\t\t}\n\t\t}\n\n\t\tfor ( n=1 ; n<=(unsigned int)global_mt_analysis ; n*=2 )\n\t\t{\n\t\t\tstatic double total1 = 0;\n\t\t\tdouble total = 0;\n\t\t\tfor ( r=0 ; r<n_ranks ; r++ )\n\t\t\t{\n\t\t\t\tstruct s_rankdata *rank = &rankdata[r];\n\t\t\t\trank->total = rank->n_presync==0 ? 0 : (double)rank->t_presync/(double)CLOCKS_PER_SEC/(double)rank->n_presync * (double)( rank->n_presync/n + rank->n_presync%n );\n\t\t\t\trank->total += rank->n_sync==0 ? 0 : (double)rank->t_sync/(double)CLOCKS_PER_SEC/(double)rank->n_sync * (double)( rank->n_sync/n + rank->n_sync%n );\n\t\t\t\trank->total += rank->n_postsync==0 ? 0 : (double)rank->t_postsync/(double)CLOCKS_PER_SEC/(double)rank->n_postsync * (double)( rank->n_postsync/n + rank->n_postsync%n );\n\t\t\t\ttotal += rank->total;\n\t\t\t}\n\t\t\tif ( n==1 ) \n\t\t\t{\n\t\t\t\ttotal1 = total;\n\t\t\t\toutput_profile(\"%2d thread model time    %.1f s (actual time)\", n, total);\n\t\t\t}\n\t\t\telse\n\t\t\t\toutput_profile(\"%2d thread model time    %.1f s (%+.0f%% est.)\", n, total,(total-total1)/total1*100);\n\t\t}\n\t\toutput_profile(\"\");\n\t}\n}\n\n/***************************************************************************\n * THREAD SCHEDULER\n *\n * Note: This is added in module.c because module is the only core element that\n *       has the WINAPI.  Someday this should be split off into a separate file.\n *\n * This is an early prototype of processor/thread scheduling.  For now it\n * only supports a single-threaded run, and it allocates a single processor\n * exclusively to a single gridlabd run.\n *\n * @todo thread scheduling needs the following enhancements:\n *\n * 1. Support multithreaded operation, which means that available processors\n *    need to be assigned to threads, not processes.\n *\n * 2. Support waiting until processors become available instead of overloading.\n *\n ***************************************************************************/\n\n#ifdef _WIN32\n/* WIN32 requires use of the compatibility kill implementation */\n#include \"signal.h\"\nextern int kill(pid_t,int); /* defined in kill.c */\n#else\n#include <signal.h>\n#ifdef MACOSX\n#include <mach/mach_init.h>\n#include <mach/thread_policy.h>\nstruct thread_affinity_policy policy;\n#else /* linux */\n#include <sched.h>\n#endif\n\n#endif\n\n#include \"gui.h\"\n\nstatic unsigned char procs[65536]; /* processor map */\nstatic unsigned char n_procs=0; /* number of processors in map */\n\n#define MAPNAME \"gridlabd-pmap-3\" /* TODO: change the pmap number each time the structure changes */\ntypedef struct s_gldprocinfo {\n\tunsigned int lock;\t\t/* field lock */\n\tpid_t pid;\t\t\t/* process id */\n\tTIMESTAMP progress;\t\t/* current simtime */\n\tTIMESTAMP starttime;\t\t/* sim starttime */\n\tTIMESTAMP stoptime;\t\t/* sim stoptime */\n\tenumeration status;\t\t/* current status */\n\tchar1024 model;\t\t\t/* model name */\n\ttime_t start;\t\t\t/* wall time of start */\n} GLDPROCINFO;\nstatic GLDPROCINFO *process_map = NULL; /* global process map */\n\ntypedef struct {\n\tunsigned short n_procs; /* number of processors used by this process */\n\tunsigned short *list; /* list of processors assigned to this process */\n} MYPROCINFO;\nstatic MYPROCINFO *my_proc=NULL; /* processors assigned to this process */\n#define PROCERR ((unsigned short)-1)\n\nstatic unsigned int show_progress = 1; /* flag to toggle progress/runtime display */\n\nunsigned short sched_get_cpuid(unsigned short n)\n{\n\tif ( my_proc==NULL || my_proc->list==NULL || n>=my_proc->n_procs )\n\t\treturn PROCERR;\n\treturn my_proc->list[n];\n}\npid_t sched_get_procid()\n{\n\tunsigned short cpuid = sched_get_cpuid(0);\n\tif(PROCERR == cpuid){\n\t\toutput_warning(\"proc_map %x, myproc not assigned\", process_map, sched_get_cpuid(0));\n\t\treturn 0;\n\t}\n\toutput_debug(\"proc_map %x, myproc %ui\", process_map, sched_get_cpuid(0));\n\treturn process_map[cpuid].pid;\n}\n\nvoid sched_lock(unsigned short proc)\n{\n\tif ( process_map )\n\t\twlock(&process_map[proc].lock);\n}\n\nvoid sched_unlock(unsigned short proc)\n{\n\tif ( process_map )\n\t\twunlock(&process_map[proc].lock);\n}\n\n/** update the process info **/\nvoid sched_update(TIMESTAMP clock, enumeration status)\n{\n\tint t;\n\tif ( my_proc==NULL || my_proc->list==NULL ) return;\n\tfor ( t=0 ; t<my_proc->n_procs ; t++ )\n\t{\n\t\tint n = my_proc->list[t];\n\t\tsched_lock(n);\n\t\tprocess_map[n].status = status;\n\t\tprocess_map[n].progress = clock;\n\t\tprocess_map[n].starttime = global_starttime;\n\t\tprocess_map[n].stoptime = global_stoptime;\n\t\tsched_unlock(n);\n\t}\n}\nint sched_isdefunct(pid_t pid)\n{\n\t/* signal 0 only checks process existence */\n\tif(pid != 0)\n\t\treturn kill(pid,0)==-1;\n\telse\n\t\treturn 0;\n}\n\n/** Unschedule process\n **/\nvoid sched_finish(void)\n{\n\tint t;\n\tif ( my_proc==NULL || my_proc->list==NULL ) return;\n\tfor ( t=0 ; t<my_proc->n_procs ; t++ )\n\t{\n\t\tint n = my_proc->list[t];\n\t\tsched_lock(n);\n\t\tprocess_map[n].status = MLS_DONE;\n\t\tsched_unlock(n);\n\t}\n}\n\n/** Clear process map\n **/\nvoid sched_clear(void)\n{\n\tif ( process_map!=NULL )\n\t{\n\t\tunsigned int n;\n\t\tfor ( n=0 ; n<n_procs ; n++ )\n\t\t{\n\t\t\tif (sched_isdefunct(process_map[n].pid) )\n\t\t\t{\n\t\t\t\tsched_lock(n);\n\t\t\t\tprocess_map[n].pid = 0;\n\t\t\t\tsched_unlock(n);\n\t\t\t}\n\t\t}\n\t}\n}\nvoid sched_pkill(pid_t pid)\n{\n\tif ( process_map!=NULL && process_map[pid].pid!=0 )\n\t{\n\t\tkill(process_map[pid].pid, SIGINT);\n\t}\n}\n\nstatic char HEADING_R[] = \"PROC PID   RUNTIME    STATE   CLOCK                   MODEL\" ;\nstatic char HEADING_P[] = \"PROC PID   PROGRESS   STATE   CLOCK                   MODEL\" ;\nint sched_getinfo(int n,char *buf, size_t sz)\n{\n\tchar *status;\n\tchar ts[64];\n\tstruct tm *tm;\n\ttime_t ptime;\n\tint width = 80, namesize;\n\tstatic char *name=NULL;\n\tchar *HEADING = show_progress ? HEADING_P : HEADING_R;\n\tsize_t HEADING_SZ = strlen(HEADING);\n#ifdef _WIN32\n\tHANDLE console = GetStdHandle(STD_OUTPUT_HANDLE);\n\tif ( console )\n\t{\n\t\tCONSOLE_SCREEN_BUFFER_INFO cbsi;\n\t\tGetConsoleScreenBufferInfo(console,&cbsi);\n\t\twidth = cbsi.dwSize.X-1;\n\t}\n#else\n\tstruct winsize ws;\n\tif ( ioctl(1,TIOCGWINSZ,&ws)!=-1 )\n\t\twidth = ws.ws_col-1;\n#endif\n\tnamesize = (int)(width - (strstr(HEADING,\"MODEL\")-HEADING));\n\tif ( namesize<8 ) namesize=8;\n\tif ( namesize>1024 ) namesize=1024;\n\tif ( name!=NULL ) free(name);\n\tname = (char*)malloc(namesize+1);\n\n\tif ( n==-1 ) /* heading string */\n\t{\n\t\tstrncpy(buf,HEADING,sz);\n\t\treturn (int)strlen(buf);\t\t\n\t}\n\telse if ( n==-2 ) /* heading underlines */\n\t{\n\t\tfor ( n=0 ; n<width ; n++ )\n\t\t{\n\t\t\tif ( n>0 && n<HEADING_SZ-1 && HEADING[n]==' ' && HEADING[n+1]!=' ' )\n\t\t\t\tbuf[n] = ' ';\n\t\t\telse\n\t\t\t\tbuf[n]='-';\n\t\t}\n\t\tbuf[n]='\\0';\n\t\treturn width;\n\t}\n\telse if ( n==-3 ) /* bottom underline */\n\t{\tfor ( n=0 ; n<width ; n++ )\n\t\t\tbuf[n] = '-';\n\t\tbuf[n]='\\0';\n\t\treturn width;\n\t}\n\n\tif ( process_map==NULL )\n\t\treturn -1;\n\n\tsched_lock(n);\n\tptime = (time_t)process_map[n].progress;\n\ttm = gmtime(&ptime);\n\tswitch ( process_map[n].status ) {\n\tcase MLS_INIT: status = \"Init\"; break;\n\tcase MLS_RUNNING: status = \"Running\"; break;\n\tcase MLS_PAUSED: status = \"Paused\"; break;\n\tcase MLS_DONE: status = \"Done\"; break;\n\tcase MLS_LOCKED: status = \"Locked\"; break;\n\tdefault: status = \"Unknown\"; break;\n\t}\n\tif ( process_map[n].pid!=0 )\n\t{\n\t\tchar *modelname = process_map[n].model;\n\t\tint len;\n\t\tchar t[64]=\" - \";\n\t\tint is_defunct = 0;\n\t\tsched_unlock(n);\n\t\tis_defunct = sched_isdefunct(process_map[n].pid);\n\t\tsched_lock(n);\n\t\tif ( process_map[n].start>0 && process_map[n].status!=MLS_DONE && !is_defunct )\n\t\t{\n\t\t\tif ( !show_progress )\n\t\t\t{\n\t\t\t\ttime_t s = (time(NULL)-process_map[n].start);\n\t\t\t\tint h = 0;\n\t\t\t\tint m = 0;\n\t\n\t\t\t\t/* compute elapsed time */\n\t\t\t\th = (int)(s/3600); s=s%3600;\n\t\t\t\tm = (int)(s/60); s=s%60;\n\t\t\t\tif ( h>0 ) sprintf(t,\"%4d:%02d:%02d\",h,m,(int)s);\n\t\t\t\telse if ( m>0 ) sprintf(t,\"     %2d:%02d\",m,(int)s);\n\t\t\t\telse sprintf(t,\"       %2ds\", (int)s);\n\t\t\t}\n\t\t\telse if ( process_map[n].stoptime!=TS_NEVER )\n\t\t\t{\n\t\t\t\tsprintf(t,\"%.0f%%\",100.0*(process_map[n].progress - process_map[n].starttime)/(process_map[n].stoptime-process_map[n].starttime));\n\t\t\t}\n\t\t}\n\n\t\t/* check for defunct process */\n\t\tif ( sched_isdefunct(process_map[n].pid) )\n\t\t\tstatus = \"Defunct\";\n\n\t\t/* format clock (without localization) */\n\t\tstrftime(ts,sizeof(ts),\"%Y-%m-%d %H:%M:%S UTC\",tm);\n\n\t\t/* truncate path if match with cwd */\n\t\tif ( strnicmp(global_workdir,modelname,strlen(global_workdir))==0 )\n\t\t{\n\t\t\tmodelname+=strlen(global_workdir);\n\t\t\tif ( modelname[0]=='/' || modelname[0]=='\\\\' ) modelname++; /* truncate remaining / */\n\t\t}\n\t\t\n\t\t/* rewrite model name to fit length limit */\n\t\tlen = (int)strlen(modelname);\n\t\tif ( len<namesize )\n\t\t\tstrcpy(name,modelname);\n\t\telse\n\t\t{\n\t\t\t/* remove the middle */\n\t\t\tint mid=namesize/2 - 3;\n\t\t\tstrncpy(name,modelname,mid+1);\n\t\t\tstrcpy(name+mid+1,\" ... \");\n\t\t\tstrcat(name,modelname+len-mid);\n\t\t}\n\n\t\t/* print info */\n\t\tsz = sprintf(buf,\"%4d %5d %10s %-7s %-23s %s\", n, process_map[n].pid, t, status, process_map[n].progress==TS_ZERO?\"INIT\":ts, name);\n\t}\n\telse\n\t\tsz = sprintf(buf,\"%4d   -\", n);\n\tsched_unlock(n);\n\treturn (int)sz;\n}\n\nvoid sched_print(int flags) /* flag=0 for single listing, flag=1 for continuous listing */\n{\n\tchar line[1024];\n\tint width = 80, namesize;\n\tstatic char *name=NULL;\n\tchar *HEADING = show_progress ? HEADING_P : HEADING_R;\n#ifdef _WIN32\n\tHANDLE console = GetStdHandle(STD_OUTPUT_HANDLE);\n\tif ( console )\n\t{\n\t\tCONSOLE_SCREEN_BUFFER_INFO cbsi;\n\t\tGetConsoleScreenBufferInfo(console,&cbsi);\n\t\twidth = cbsi.dwSize.X-1;\n\t}\n#else\n\tstruct winsize ws;\n\tif ( ioctl(1,TIOCGWINSZ,&ws)!=-1 )\n\t\twidth = ws.ws_col;\n#endif\n\tnamesize = (int)(width - (strstr(HEADING,\"MODEL\")-HEADING));\n\tif ( namesize<8 ) namesize=8;\n\tif ( namesize>1024 ) namesize=1024;\n\tif ( name!=NULL ) free(name);\n\tname = (char*)malloc(namesize+1);\n\tif ( process_map!=NULL )\n\t{\n\t\tunsigned int n;\n\t\tint first=1;\n\t\tif ( flags==1 )\n\t\t{\n\t\t\tsched_getinfo(-1,line,sizeof(line));\n\t\t\tprintf(\"%s\\n\",line);\n\t\t\tsched_getinfo(-2,line,sizeof(line));\n\t\t\tprintf(\"%s\\n\",line);\n\t\t}\n\t\tfor ( n=0 ; n<n_procs ; n++ )\n\t\t{\n\t\t\tif ( process_map[n].pid!=0 || flags==1 )\n\t\t\t{\n\t\t\t\tif ( sched_getinfo(n,line,sizeof(line))>0 )\n\t\t\t\t\tprintf(\"%s\\n\",line);\n\t\t\t\telse\n\t\t\t\t\tprintf(\"%4d (error)\\n\",n);\n\t\t\t}\n\t\t}\n\t}\n}\n\nMYPROCINFO *sched_allocate_procs(unsigned int n_threads, pid_t pid)\n{\n\tint t;\n\n#if defined WIN32\n\tint cpu;\n\n\t/* get process info */\n\tHANDLE hProc = OpenProcess(PROCESS_ALL_ACCESS,FALSE,pid);\n\tif ( hProc==NULL )\n\t{\n\t\tunsigned long  err = GetLastError();\n\t\toutput_warning(\"unable to access current process info, err code %d--job not added to process map\", err);\n\t\treturn NULL;\n\t}\n#elif defined MACOSX\n\tint cpu;\n#elif defined DYN_PROC_AFFINITY\n\tcpu_set_t *cpuset = CPU_ALLOC(n_procs);\n#elif defined HAVE_CPU_SET_T && defined HAVE_CPU_SET_MACROS\n\tcpu_set_t *cpuset = malloc(sizeof(cpu_set_t));\n\tCPU_ZERO(cpuset);\n#endif\n\n\tif ( n_threads==0 ) n_threads = n_procs;\n\tmy_proc = malloc(sizeof(MYPROCINFO));\n\tmy_proc->list = malloc(sizeof(unsigned short)*n_threads);\n\tmy_proc->n_procs = n_threads;\n\tfor ( t=0 ; t<(int)n_threads ; t++ )\n\t{\n\t\tint n;\n\t\tfor ( n=0 ; n<n_procs ; n++ )\n\t\t{\n\t\t\tsched_lock(n);\n\t\t\tif ( process_map[n].pid==0 )\n\t\t\t\tbreak;\n\t\t\tsched_unlock(n);\n\t\t}\n\t\tif ( n==n_procs )\n\t\t{\n\t\t\tgoto Error;\n\t\t\t/** @todo wait for a processor to free up before running */\n\t\t}\n\t\tmy_proc->list[t] = n;\n\t\tprocess_map[n].pid = pid;\n\t\tstrncpy(process_map[n].model,global_modelname,sizeof(process_map[n].model)-1);\n\t\tprocess_map[n].start = time(NULL);\n\t\tsched_unlock(n);\n\n#ifdef _WIN32\n\t\t// TODO add this cpu to affinity\n\t\tcpu = n;\n#elif defined MACOSX\n\t\t// TODO add this cpu to affinity\n\t\tcpu = n;\n#elif defined DYN_PROC_AFFINITY /* linux */\n\t\tCPU_SET_S(n,CPU_ALLOC_SIZE(n_procs),cpuset);\t\n#elif defined HAVE_CPU_SET_T && defined HAVE_CPU_SET_MACROS\n\t\tCPU_SET(n,cpuset);\n#endif\n\t}\n#ifdef _WIN32\n\t// TODO set mp affinity\n\tif ( global_threadcount==1 && SetProcessAffinityMask(hProc,(DWORD_PTR)(1<<cpu))==0 )\n\t{\n\t\tunsigned long  err = GetLastError();\n\t\toutput_error(\"unable to set current process affinity mask, err code %d\", err);\n\t}\n\tCloseHandle(hProc);\n#elif defined MACOSX\n\t// TODO set mp affinity\n\tif ( global_threadcount==1 )\n\t{\n\t\tpolicy.affinity_tag = cpu;\n\t\tif ( thread_policy_set(mach_thread_self(), THREAD_AFFINITY_POLICY, &policy, THREAD_AFFINITY_POLICY_COUNT)!=KERN_SUCCESS )\n\t\t\toutput_warning(\"unable to set thread policy: %s\", strerror(errno));\n\t}\n#elif defined DYN_PROC_AFFINITY\n\tif (sched_setaffinity(pid,CPU_ALLOC_SIZE(n_procs),cpuset) )\n\t\toutput_warning(\"unable to set current process affinity mask: %s\", strerror(errno));\n#elif defined HAVE_SCHED_SETAFFINITY\n\tif (sched_setaffinity(pid,sizeof(cpu_set_t),cpuset) )\n\t\toutput_warning(\"unable to set current process affinity mask: %s\", strerror(errno));\n#endif\n\treturn my_proc;\nError:\n\tif ( my_proc!=NULL )\n\t{\n\t\tif ( my_proc->list!=NULL ) free(my_proc->list);\n\t\tfree(my_proc);\n\t}\n#ifdef _WIN32\n\tCloseHandle(hProc);\n#endif\n\treturn NULL;\n}\n\n/** Initialize the processor scheduling system\n\n    This function sets up the processor scheduling system\n\tthat is responsible to keep thread from migrating once\n\tthey are committed to a particular processor.\n **/\n#ifdef _WIN32\nvoid sched_init(int readonly)\n{\n\tstatic int has_run = 0;\n\tSYSTEM_INFO info;\n\tpid_t pid = (unsigned short)GetCurrentProcessId();\n\tHANDLE hMap;\n\tunsigned long mapsize;\n\n\tif(has_run == 0){\n\t\thas_run = 1;\n\t} else {\n\t\toutput_verbose(\"sched_init(): second call, short-circuiting gracefully\");\n\t\treturn;\n\t}\n\n\t/* get total number of processors */\n\tGetSystemInfo(&info);\n\tn_procs = (unsigned char)info.dwNumberOfProcessors;\n\tmapsize = sizeof(GLDPROCINFO)*n_procs;\n\n\t/* get global process map */\n\thMap = OpenFileMapping(FILE_MAP_ALL_ACCESS, FALSE, MAPNAME);\n\tif ( hMap==NULL ) \n\t{\n\t\t/** @todo implement locking before creating the global process map */\n\n\t\t/* create global process map */\n\t\thMap = CreateFileMapping(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, mapsize, MAPNAME);\n\t\tif ( hMap==NULL )\n\t\t{\n\t\t\toutput_warning(\"unable to create global process map, error code %d--job not added to process map\", GetLastError());\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* access global process map */\n\tprocess_map = (GLDPROCINFO*) MapViewOfFile(hMap, FILE_MAP_ALL_ACCESS,0,0,mapsize);\n\tif ( process_map==NULL )\n\t{\n\t\toutput_warning(\"unable to access global process map, error code %d--job not added to process map\", GetLastError());\n\t\treturn;\n\t}\n\n\t/* automatic cleanup of defunct jobs */\n\tif ( global_autoclean )\n\t\tsched_clear();\n\n\t/* readonly means don't record this job */\n\tif ( readonly ) return;\n\n\t/* find an available processor */\n\tmy_proc = sched_allocate_procs(global_threadcount,pid);\n\tif ( my_proc==NULL )\n\t{\n\t\toutput_warning(\"no processor available to avoid overloading--job not added to process map\");\n\t\treturn;\n\t}\n\tatexit(sched_finish);\n}\n\n#else\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <sys/mman.h>\n#include <sys/shm.h>\n\nvoid sched_init(int readonly)\n{\n\tstatic int has_run = 0;\n\tchar *mfile = \"/tmp/\" MAPNAME;\n\tunsigned long mapsize;\n\tint fd = open(mfile,O_CREAT,0666);\n\tkey_t shmkey = ftok(mfile,sizeof(GLDPROCINFO));\n\tpid_t pid = getpid();\n\tint shmid;\n\tint n;\n\n\t/* get total number of processors */\n#ifndef DYN_PROC_AFFINITY\n\tn_procs = sysconf(_SC_NPROCESSORS_ONLN)>1024 ? 1024 : sysconf(_SC_NPROCESSORS_ONLN);\n#else\n\tn_procs = sysconf(_SC_NPROCESSORS_ONLN);\n#endif\n\tmapsize = sizeof(GLDPROCINFO)*n_procs;\n\n\tif(has_run == 0){\n\t\thas_run = 1;\n\t} else {\n\t\toutput_verbose(\"sched_init(): second call, short-circuiting gracefully\");\n\t\treturn;\n\t}\n\n\t/* check key */\n\tif ( shmkey==-1 )\n\t{\n\t\toutput_error(\"error generating key to global process map: %s\", strerror(errno));\n\t\treturn;\n\t}\n\telse\n\t\tclose(fd);\n\n\t/* get global process map */\n\tshmid = shmget(shmkey,mapsize,IPC_CREAT|0666);\n\tif ( shmid<0 ) \n\t{\n\t\toutput_error(\"unable to create global process map: %s\", strerror(errno));\n\t\tswitch ( errno ) {\n\t\tcase EACCES: output_error(\"access to global process map %s is denied\", mfile); break;\n\t\t/* TROUBLESHOOT\n\t\t   Access to the process map is denied.  Consult with the system administrator\n\t\t   to obtain access to the process map.\n\t\t */\n\t\tcase EEXIST: output_error(\"global process map already exists\"); break;\n\t\tcase EINVAL: output_error(\"size of existing process map is not %d bytes or map size exceed system limit for shared memory\", mapsize); break;\n\t\t/* TROUBLESHOOT\n\t\t   The process map changed size or it is too big for the limits on shared memory.\n\t\t   Reboot your system to clear the old process map.  If the problem persists,\n\t\t   consult your system's manuals to learn how to increase the size of shared memory.\n\t\t */\n\t\tcase ENOENT: output_error(\"process map %s not found\", mfile); break;\n\t\tcase ENOMEM: output_error(\"process map too big\"); break;\n\t\t/* TROUBLESHOOT\n\t\t   The process map is too big for the resources available.\n\t\t   Try freeing up resources.  If the problem persists,\n\t\t   consult your system's manuals to learn how to reserve more shared memory.\n\t\t */\n\t\tcase ENOSPC: output_error(\"shared memory limit exceeded (need %.1fkB)\",mapsize/1000.0); break;\n\t\t/* TROUBLESHOOT\n\t\t   The process map is too big for the limits on shared memory.\n\t\t   Consult your system's manuals to learn how to increase the size of shared memory.\n\t\t */\n\t\tdefault: output_error(\"unknown shmget error\");\n\t\t}\n\t\treturn;\n\t}\n\n\t/* access global process map */\n\tprocess_map = (GLDPROCINFO*) shmat(shmid,NULL,0);\n\tif ( process_map==NULL )\n\t{\n\t\toutput_error(\"unable to access global process map: %s\", strerror(errno));\n\t\treturn;\n\t}\n\n\t/* automatic cleanup of defunct jobs */\n\tif ( global_autoclean )\n\t\tsched_clear();\n\n\t/* readonly means don't record this job */\n\tif ( readonly )\n\t\treturn;\n\n\t/* find an available processor */\n\tmy_proc = sched_allocate_procs(global_threadcount,pid);\n\tif ( my_proc==NULL )\n\t{\n\t\toutput_warning(\"no processor available to avoid overloading--job not added to process map\");\n\t\treturn;\n\t}\n\tatexit(sched_finish);\n}\n#endif\n\n/*********************************************************************\n * INTERACTIVE PROCESS CONTROLLER\n *********************************************************************/\n\ntypedef struct s_args {\n\tsize_t n; /* number of args found */\n\tsize_t a; /* size of arg list */\n\tchar **arg; /* argument list */\n} ARGS;\nARGS* get_args(char *line)\n{\n\tint n=0;\n\tchar *p, *tag;\n\tenum {P_INIT, P_SPACE, P_TEXT, P_QUOTE, P_QUOTES} state = P_INIT;\n\tARGS *args = (ARGS*)malloc(sizeof(ARGS));\n\n\t/* prepare args structure */\n\tif ( args==NULL ) \n\t{\n\t\toutput_fatal(\"memory allocation error\");\n\t\treturn NULL;\n\t}\n\tmemset(args,0,sizeof(args));\n\n\t/* determine maximum number of args needed */\n\tfor ( p=line ; *p!='\\0' ; p++ )\n\t\tif ( isspace(*p) ) n++;\n\targs->a = n;\n\targs->arg = (char**)malloc(sizeof(char*)*n);\n\n\t/* extract arguments */\n\tfor ( p=line ; *p!='\\0' ; p++ )\n\t{\n\t\tswitch (state) {\n\t\tcase P_INIT:\n\t\tcase P_SPACE:\t\t\t\n\t\t\tif ( !isspace(*p) )\n\t\t\t{\n\t\t\t\tstate = P_TEXT;\n\t\t\t\ttag = p;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase P_TEXT:\n\t\t\tif ( isspace(*p) )\n\t\t\t{\n\t\t\t\tint len = (int)(p-tag);\n\t\t\t\targs->arg[args->n] = (char*)malloc(sizeof(char)*(len+1));\n\t\t\t\tstrncpy(args->arg[args->n],tag,len);\n\t\t\t\targs->arg[args->n][len] = '\\0';\n\t\t\t\targs->n++;\n\t\t\t\tstate = P_SPACE;\n\t\t\t}\n\t\t\telse if ( *p=='\\'' )\n\t\t\t\tstate = P_QUOTE;\n\t\t\telse if ( *p=='\"' )\n\t\t\t\tstate = P_QUOTES;\n\t\t\tbreak;\n\t\tcase P_QUOTE:\n\t\t\tif ( *p=='\\'')\n\t\t\t\tstate = P_TEXT;\n\t\t\tbreak;\n\t\tcase P_QUOTES:\n\t\t\tif ( *p=='\"')\n\t\t\t\tstate = P_TEXT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\toutput_fatal(\"get_args(char *line='%s'): unknown parser state '%d'\", line, state);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn args;\n}\nvoid free_args(ARGS *args)\n{\n\tunsigned int n;\n\tfor ( n=0 ; n<args->n ; n++ )\n\t\tfree(args->arg[n]);\n\tfree(args->arg);\n\tfree(args);\n}\n\nstatic int sched_stop = 0;\n#ifdef _WIN32\nBOOL WINAPI sched_signal(DWORD type)\n{\n\tif ( type==CTRL_C_EVENT )\n\t{\n#else\nvoid sched_signal(int sig)\n{\n#endif\n\t\t/* purge input stream */\n\t\t//while ( !feof(stdin) ) getchar();\n\n\t\t/* print a friendly message */\n\t\tprintf(\"\\n*** SIGINT ***\\n\");\n\n\t\t/* stop processing */\n\t\tsched_stop = 1;\n#ifdef _WIN32\n\t\treturn TRUE;\n\t}\n\treturn FALSE;\n#endif\n}\n\nvoid sched_continuous(void)\n{\n#ifdef HAVE_CURSES\n\tchar message[1024]=\"Ready.\";\n\tint sel=0;\n\tunsigned int refresh_mod=10;\n\tunsigned int refresh_count=0;\n\n\tsched_init(1);\n\n\tinitscr();\n\tcbreak();\n\techo();\n\tintrflush(stdscr,TRUE);\n\tkeypad(stdscr,TRUE);\n\trefresh();\n\thalfdelay(1);\n\n\twhile ( sel>=0 && !sched_stop )\n\t{\n\t\tint c;\n\t\tchar ts[64];\n\t\tstruct tm *tb;\n\t\ttime_t now = time(NULL);\n\t\tif ( refresh_count++%refresh_mod==0 )\n\t\t{\n\t\t\tint n;\n\t\t\tchar line[1024];\n\t\t\tclear();\n\t\t\tmvprintw(0,0,\"GridLAB-D Process Control - Version %d.%d.%d-%d (%s)\",REV_MAJOR,REV_MINOR,REV_PATCH,version_build(),version_branch());\n\t\t\tsched_getinfo(-1,line,sizeof(line));\n\t\t\tmvprintw(2,0,\"%s\",line);\n\t\t\tsched_getinfo(-2,line,sizeof(line));\n\t\t\tmvprintw(3,0,\"%s\",line);\n\t\t\tfor ( n=0 ; n<n_procs ; n++ )\n\t\t\t{\n\t\t\t\tif ( sched_getinfo(n,line,sizeof(line))<0 )\n\t\t\t\t\tsprintf(message,\"ERROR: unable to read process %d\", n);\n\t\t\t\tif ( n==sel ) attron(A_BOLD);\n\t\t\t\tmvprintw(n+4,0,\"%s\",line);\n\t\t\t\tif ( n==sel ) attroff(A_BOLD);\n\t\t\t}\n\t\t\tsched_getinfo(-3,line,sizeof(line));\n\t\t\tmvprintw(n_procs+5,0,\"%s\",line);\n\t\t\ttb = localtime(&now);\n\t\t\tstrftime(ts,sizeof(ts),\"%Y/%m/%d %H:%M:%S\",tb);\n\t\t\tmvprintw(n_procs+7,0,\"%s: %s\",ts,message);\n\t\t\tmvprintw(n_procs+8,0,\"C to clear defunct, Up/Down to select, R/P to display runtime/progress, K to kill, Q to quit: \");\n\t\t}\n\t\tc = wgetch(stdscr);\n\t\tswitch (c) {\n\t\tcase KEY_UP:\n\t\t\tif ( sel>0 ) sel--;\n\t\t\tsprintf(message,\"Process %d selected\", sel);\n\t\t\trefresh_count=0;\n\t\t\tbreak;\n\t\tcase KEY_DOWN:\n\t\t\tif ( sel<n_procs-1 ) sel++;\n\t\t\trefresh_count=0;\n\t\t\tsprintf(message,\"Process %d selected\", sel);\n\t\t\tbreak;\n\t\tcase 'q':\n\t\tcase 'Q':\n\t\t\tsel = -1;\n\t\t\tbreak;\n\t\tcase 'k':\n\t\tcase 'K':\n\t\t\tsched_pkill(sel);\n\t\t\tsprintf(message,\"Kill signal sent to process %d\",sel);\n\t\t\trefresh_count=0;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\tcase 'C':\n\t\t\tsched_clear();\n\t\t\tsprintf(message,\"Defunct processes cleared ok\");\n\t\t\trefresh_count=0;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\tcase 'R':\n\t\t\tshow_progress = 0;\n\t\t\tsprintf(message,\"Runtime display selected\");\n\t\t\trefresh_count = 0;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\tcase 'P':\n\t\t\tshow_progress = 1;\n\t\t\tsprintf(message,\"Progress display selected\");\n\t\t\trefresh_count = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tendwin();\n#else\n\toutput_error(\"unable to show screen without curses library\");\n#endif\n}\n\nvoid sched_controller(void)\n{\n\tchar command[1024];\n\tARGS *last = NULL;\n\n\tsched_continuous();\n\treturn;\n\n\tglobal_suppress_repeat_messages = 0;\n#ifdef _WIN32\n\tif ( !SetConsoleCtrlHandler(sched_signal,TRUE) )\n\t\toutput_warning(\"unable to suppress console Ctrl-C handler\");\n#else\n\tsignal(SIGINT,sched_signal);\n#endif\n\n\tprintf(\"Gridlabd process controller starting\");\n\twhile ( sched_stop==0 )\n\t{\n\t\tARGS *args;\n\t\tsched_stop = 0;\n\t\twhile ( printf(\"\\ngridlabd>> \"), fgets(command,sizeof(command),stdin)==NULL );\n \t\targs = get_args(command);\n\t\tif ( args->n==0 ) { free_args(args); args=NULL; }\n\t\tif ( args==NULL && last!=NULL ) { args=last; printf(\"gridlabd>> %s\\n\", last->arg[0]); }\n\t\tif ( args!=NULL )\n\t\t{\n\t\t\tchar *cmd = args->arg[0];\n\t\t\tsize_t argc = args->n - 1;\n\t\t\tchar **argv = args->arg + 1;\n\t\t\tif ( strnicmp(cmd,\"quit\",strlen(cmd))==0 )\n\t\t\t\texit(XC_SUCCESS);\n\t\t\telse if ( strnicmp(cmd,\"exit\",strlen(cmd))==0 )\n\t\t\t\texit(argc>0 ? atoi(argv[0]) : 0);\n\t\t\telse if ( strnicmp(cmd,\"list\",strlen(cmd))==0 )\n\t\t\t\tsched_print(0);\n\t\t\telse if ( strnicmp(cmd,\"continuous\",strlen(cmd))==0)\n\t\t\t\tsched_continuous();\n\t\t\telse if ( strnicmp(cmd,\"clear\",strlen(cmd))==0 )\n\t\t\t\tsched_clear();\n\t\t\telse if ( strnicmp(cmd,\"kill\",strlen(cmd))==0 )\n\t\t\t{\n\t\t\t\tif ( argc>0 )\n\t\t\t\t\tsched_pkill(atoi(argv[0]));\n\t\t\t\telse\n\t\t\t\t\toutput_error(\"missing process id\");\n\t\t\t}\n\t\t\telse if ( strnicmp(cmd,\"help\",strlen(cmd))==0 )\n\t\t\t{\n\t\t\t\tprintf(\"Process controller help:\\n\");\n\t\t\t\tprintf(\"  clear     clear process map\\n\");\n\t\t\t\tprintf(\"  exit <n>  exit with status <n>\\n\");\n\t\t\t\tprintf(\"  kill <n>  kill process <n>\\n\");\n\t\t\t\tprintf(\"  list      list process map\\n\");\n\t\t\t\tprintf(\"  quit      exit with status 0\\n\");\n\t\t\t}\n\t\t\telse\n\t\t\t\toutput_error(\"command '%s' not found\",cmd);\n\t\t\tif ( last!=NULL && last!=args )\n\t\t\t\tfree_args(last);\n\t\t\tlast = args;\n\t\t}\n\t}\n}\n\n\n/**@}*/\n",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/gldcore/link.cpp": "/* $Id: link.cpp 4738 2014-07-03 00:55:39Z dchassin $\n */\n\n#include \"gridlabd.h\"\n#include <stdio.h>\n#include \"platform.h\"\n#include \"output.h\"\n#include \"find.h\"\n#include \"timestamp.h\"\n\n#include \"link.h\"\n\n#if defined WIN32 && ! defined __MINGW32__\n\t#define _WIN32_WINNT 0x0400\n\t#undef int64 // wtypes.h also used int64\n\t#include <windows.h>\n\t#define int64 _int64\n\t#define PREFIX \"\"\n\t#ifndef DLEXT\n\t\t#define DLEXT \".dll\"\n\t#endif\n\t#define DLLOAD(P) LoadLibrary(P)\n\t#define DLSYM(H,S) GetProcAddress((HINSTANCE)H,S)\n\t#define DLERR \"no diagnostics available\"\n\t#define snprintf _snprintf\n#else /* ANSI */\n#ifndef __MINGW32__\n\t#include \"dlfcn.h\"\n#endif\n\t#define PREFIX \"\"\n\t#ifndef DLEXT\n\t\t#define DLEXT \".so\"\n\t#endif\n#ifndef __MINGW32__\n\t#define DLLOAD(P) dlopen(P,RTLD_LAZY)\n#else\n\t#include \"dlfcn.h\"\n\t#define DLLOAD(P) dlopen(P,RTLD_LAZY)\n#endif\n\t#define DLSYM(H,S) dlsym(H,S)\n\t#define DLERR dlerror()\n#endif\n\nglxlink *glxlink::first = NULL;\n\nLINKLIST * glxlink::add_global(char *name)\n{\n\tLINKLIST *item = new LINKLIST;\n\tif ( item==NULL ) return NULL;\n\titem->next = globals;\n\titem->data = NULL;\n\titem->name = (char*)malloc(strlen(name)+1);\n\titem->addr = NULL;\n\titem->size = 0;\n\tif ( item->name==NULL ) return NULL;\n\tstrcpy(item->name,name);\n\tglobals = item;\n\treturn item;\n}\n\nLINKLIST * glxlink::add_object(char *name)\n{\n\tLINKLIST *item = new LINKLIST;\n\titem->next = objects;\n\titem->data = NULL;\n\titem->name = (char*)malloc(strlen(name)+1);\n\titem->addr = NULL;\n\titem->size = 0;\n\tstrcpy(item->name,name);\n\tobjects = item;\n\treturn item;\n}\n\nLINKLIST * glxlink::add_export(char *name)\n{\n\tLINKLIST *item = new LINKLIST;\n\titem->next = exports;\n\titem->data = NULL;\n\titem->name = (char*)malloc(strlen(name)+1);\n\titem->addr = NULL;\n\titem->size = 0;\n\tstrcpy(item->name,name);\n\texports = item;\n\treturn item;\n}\n\nLINKLIST * glxlink::add_import(char *name)\n{\n\tLINKLIST *item = new LINKLIST;\n\titem->next = imports;\n\titem->data = NULL;\n\titem->name = (char*)malloc(strlen(name)+1);\n\titem->addr = NULL;\n\titem->size = 0;\n\tstrcpy(item->name,name);\n\timports = item;\n\treturn item;\n}\n\n/* create a link module */\nint link_create(char *file)\n{\n\ttry {\n\t\tglxlink *lt = new glxlink(file);\n\t\treturn 1;\n\t}\n\tcatch (char *msg)\n\t{\n\t\toutput_error(\"link '%s' failed: %s\", file, msg);\n\t\treturn 0;\n\t}\n\tcatch (...)\n\t{\n\t\toutput_error(\"link '%s' failed: unhandled exception\", file);\n\t\treturn 0;\n\t}\n}\n\n/* initialize modules */\nint link_initall(void)\n{\n\toutput_debug(\"link_initall(): link startup in progress...\");\n\tglxlink *mod;\n\tfor ( mod=glxlink::get_first() ; mod!=NULL ; mod=mod->get_next() )\n\t{\n\t\tLINKLIST *item;\n\n\t\toutput_debug(\"link_initall(): setting up %s link\", mod->get_target());\n\n\t\t// set default global list (if needed)\n\t\tif ( mod->get_globals()==NULL )\n\t\t{\n\t\t\tGLOBALVAR *var = NULL;\n\t\t\twhile ( (var=global_getnext(var))!=NULL )\n\t\t\t{\n\t\t\t\tif ( var->prop!=NULL && var->prop->name!=NULL )\n\t\t\t\t{\n\t\t\t\t\tLINKLIST *item = mod->add_global(var->prop->name);\n\t\t\t\t\tif ( item!=NULL )\n\t\t\t\t\t\titem->data = (void*)var;\n\t\t\t\t\telse\n\t\t\t\t\t\toutput_error(\"link_initall(): unable to link %s\", var->prop->name);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\toutput_warning(\"link_initall(): a variable property definition is null\"); \n\t\t\t}\n\t\t}\n\t\telse \n\t\t{\n\t\t\t// link global variables\n\t\t\tfor ( item=mod->get_globals() ; item!=NULL ; item=mod->get_next(item) )\n\t\t\t{\n\t\t\t\tif ( strcmp(item->name,\"\")==0 ) continue;\n\t\t\t\titem->data = (void*)global_find(item->name);\n\t\t\t\tif ( item->data==NULL )\n\t\t\t\t\toutput_error(\"link_initall(target='%s'): global '%s' is not found\", mod->get_target(), item->name);\n\t\t\t}\n\t\t}\n\n\t\t// link objects\n\t\tif ( mod->get_objects()==NULL )\n\t\t{\n\t\t\t// set default object list\n\t\t\tOBJECT *obj = NULL;\n\t\t\tfor ( obj=object_get_first() ; obj!=NULL ; obj=object_get_next(obj) )\n\t\t\t{\n\t\t\t\t// add named objects\n\t\t\t\tLINKLIST *item = NULL;\n\t\t\t\tif ( obj->name!=NULL )\n\t\t\t\t\titem = mod->add_object(obj->name);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tchar id[256];\n\t\t\t\t\tsprintf(id,\"%s:%d\",obj->oclass->name,obj->id);\n\t\t\t\t\titem = mod->add_object(id);\n\t\t\t\t}\n\t\t\t\titem->data = (void*)obj;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tLINKLIST *item;\n\n\t\t\t// link global variables\n\t\t\tfor ( item=mod->get_objects() ; item!=NULL ; item=mod->get_next(item) )\n\t\t\t{\n\t\t\t\tif ( strcmp(item->name,\"\")==0 ) continue;\n\t\t\t\tOBJECT *obj = NULL;\n\t\t\t\titem->data = (void*)object_find_name(item->name);\n\t\t\t\tif ( item->data==NULL)\n\t\t\t\t\toutput_error(\"link_initall(target='%s'): object '%s' is not found\", mod->get_target(), item->name);\n\t\t\t}\n\t\t}\n\n\t\t// link exports\n\t\tfor ( item=mod->get_exports() ; item!=NULL ; item=mod->get_next(item) )\n\t\t{\n\t\t\tchar objname[64], propname[64], varname[64];\n\t\t\tif ( sscanf(item->name,\"%[^.].%s %s\",objname,propname,varname)==3 )\n\t\t\t{\n\t\t\t\tOBJECTPROPERTY *objprop = (OBJECTPROPERTY*)malloc(sizeof(OBJECTPROPERTY));\n\t\t\t\tobjprop->obj = object_find_name(objname);\n\t\t\t\tif ( objprop->obj )\n\t\t\t\t{\n\t\t\t\t\tobjprop->prop = class_find_property(objprop->obj->oclass,propname);\n\t\t\t\t\tif ( objprop->prop==NULL )\n\t\t\t\t\t\toutput_error(\"link_initall(target='%s'): export '%s' property not found\", mod->get_target(), item->name);\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\titem->data = objprop;\n\t\t\t\t\t\tstrcpy(item->name,varname);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\toutput_error(\"link_initall(target='%s'): export '%s' object not found\", mod->get_target(), item->name);\n\t\t\t}\n\t\t\telse\n\t\t\t\toutput_error(\"link_initall(target='%s'): '%s' is not a valid export specification\", mod->get_target(), item->name);\n\t\t}\n\n\t\t// link imports\n\t\tfor ( item=mod->get_imports() ; item!=NULL ; item=mod->get_next(item) )\n\t\t{\n\t\t\tchar objname[64], propname[64], varname[64];\n\t\t\tif ( sscanf(item->name,\"%[^.].%s %s\",objname,propname,varname)==3 )\n\t\t\t{\n\t\t\t\tOBJECTPROPERTY *objprop = (OBJECTPROPERTY*)malloc(sizeof(OBJECTPROPERTY));\n\t\t\t\tobjprop->obj = object_find_name(objname);\n\t\t\t\tif ( objprop->obj )\n\t\t\t\t{\n\t\t\t\t\tobjprop->prop = class_find_property(objprop->obj->oclass,propname);\n\t\t\t\t\tif ( objprop->prop==NULL )\n\t\t\t\t\t\toutput_error(\"link_initall(target='%s'): import '%s' property not found\", mod->get_target(), item->name);\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\titem->data = objprop;\n\t\t\t\t\t\tstrcpy(item->name,varname);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\toutput_error(\"link_initall(target='%s'): import '%s' object not found\", mod->get_target(), item->name);\n\t\t\t}\n\t\t\telse\n\t\t\t\toutput_error(\"link_initall(target='%s'): '%s' is not a valid import specification\", mod->get_target(), item->name);\n\t\t}\n\n\t\t// initialize link module\n\t\tif ( !mod->do_init() )\n\t\t{\n\t\t\toutput_error(\"link_initall(): link startup failed\");\n\t\t\tlink_termall();\n\t\t\treturn 0;\n\t\t}\n\t}\n\toutput_debug(\"link_initall(): link startup done ok\");\n\tatexit((void(*)(void))link_termall);\n\treturn 1;\n}\n\nTIMESTAMP link_syncall(TIMESTAMP t0)\n{\n\tTIMESTAMP t1 = TS_NEVER;\n\tglxlink *mod;\n\tfor ( mod=glxlink::get_first() ; mod!=NULL ; mod=mod->get_next() )\n\t{\n\t\tTIMESTAMP t2 = mod->do_sync(t0);\n\t\tif ( absolute_timestamp(t2)<absolute_timestamp(t1) ) t1 = t2;\n\t}\n\treturn t1;\n}\n\nint link_termall(void)\n{\n\tbool ok = true;\n\tglxlink *mod;\n\tfor ( mod=glxlink::get_first() ; mod!=NULL ; mod=mod->get_next() )\n\t{\n\t\toutput_debug(\"link_initall(): terminating %s link...\",mod->get_target());\n\t\tif ( !mod->do_term() ) ok = false;\n\t}\n\treturn ok;\n}\n\n\nglxlink::glxlink(char *filename)\n{\n\tbool ok = true;\n\tglobals = NULL;\n\timports = NULL;\n\texports = NULL;\n\tobjects = NULL;\n\thandle = NULL;\n\tsettag = NULL;\n\tinit = NULL;\n\tsync = NULL;\n\tterm = NULL;\n\tglxflags = 0;\n\tvalid_to = 0;\n\tlast_t = 0;\n\n\tFILE *fp = fopen(filename,\"rt\");\n\tif ( fp==NULL )\n\t\tthrow \"file open failed\";\n\toutput_debug(\"opened link '%s'\", filename);\n\n\tchar line[1024];\n\tint linenum=0;\n\twhile ( fgets(line,sizeof(line),fp)!=NULL )\n\t{\n\t\tlinenum++;\n\t\tif ( line[0]=='#' ) continue;\n\t\tchar tag[64], data[1024]=\"\";\n\t\tif ( sscanf(line,\"%s %[^\\r\\n]\",tag,data)>0 )\n\t\t{\n\t\t\toutput_debug(\"%s(%d): %s %s\", filename, linenum, tag,data);\n\t\t\tif ( settag!=NULL )\n\t\t\t{\n\t\t\t\tif ( strcmp(tag,\"global\")==0 )\n\t\t\t\t{\n\t\t\t\t\tadd_global(data);\n\t\t\t\t}\n\t\t\t\telse if ( strcmp(tag,\"object\")==0 )\n\t\t\t\t{\n\t\t\t\t\tadd_object(data);\n\t\t\t\t}\n\t\t\t\telse if ( strcmp(tag,\"export\")==0 )\n\t\t\t\t{\n\t\t\t\t\tadd_export(data);\n\t\t\t\t}\n\t\t\t\telse if ( strcmp(tag,\"import\")==0 )\n\t\t\t\t{\n\t\t\t\t\tadd_import(data);\n\t\t\t\t}\n\t\t\t\telse if ( !(*settag)(this,tag,data) )\n\t\t\t\t\toutput_error(\"%s(%d): tag '%s' not accepted\", filename, linenum, tag);\n\t\t\t}\n\t\t\telse if ( strcmp(tag,\"target\")==0)\n\t\t\t{\n\t\t\t\tif ( !set_target(data) )\n\t\t\t\t{\n\t\t\t\t\toutput_error(\"%s(%d): target '%s' is not valid\", filename, linenum, data);\n\t\t\t\t\tok = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\toutput_warning(\"%s(%d): tag '%s' cannot be processed until target module is loaded\", filename, linenum, tag);\n\t\t}\n\t}\n\n\tfclose(fp);\n\n\t// append to link list\n\tnext = first;\n\tfirst = this;\n\n\tif ( ok )\n\t\toutput_verbose(\"link '%s' ok\", filename);\n\telse\n\t\tthrow \"cannot establish link\";\n}\n\nbool glxlink::set_target(char *name)\n{\n\tchar libname[1024];\n\tchar path[1024];\n\tsprintf(libname,PREFIX \"glx%s\" DLEXT,name);\n\tif ( find_file(libname,NULL,X_OK,path,sizeof(path))!=NULL )\n\t{\n\t\t// load library\n\t\thandle = DLLOAD(path);\n\t\tif ( handle==NULL )\n\t\t{\n\t\t\toutput_error(\"unable to load '%s' for target '%s': %s\", path,name,DLERR);\n\t\t\treturn false;\n\t\t}\n\n\t\t// attach functions\n\t\tsettag = (bool(*)(glxlink*,char*,char*))DLSYM(handle,\"glx_settag\");\n\t\tinit = (bool(*)(glxlink*))DLSYM(handle,\"glx_init\");\n\t\tsync = (TIMESTAMP(*)(glxlink*,TIMESTAMP))DLSYM(handle,\"glx_sync\");\n\t\tterm = (bool(*)(glxlink*))DLSYM(handle,\"glx_term\");\n\n\t\t// call create routine\n\t\tbool (*create)(glxlink*,CALLBACKS*) = (bool(*)(glxlink*,CALLBACKS*))DLSYM(handle,\"glx_create\");\n\t\tif ( create!=NULL && create(this,module_callbacks()) )\n\t\t{\n\t\t\tstrcpy(target,name);\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\toutput_error(\"library '%s' for target '%s' does not define/export glx_create properly\", path,name);\n\t\t\treturn false;\n\t\t}\n\t}\n\telse\n\t{\n\t\toutput_error(\"library '%s' for target '%s' not found\", libname, name);\n\t\treturn false;\n\t}\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/third_party/dlfcn-win32-read-only/dlfcn.h": "/*\n * dlfcn-win32\n * Copyright (c) 2007 Ramiro Polla\n *\n * dlfcn-win32 is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * dlfcn-win32 is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with dlfcn-win32; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n#ifndef DLFCN_H\n#define DLFCN_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* POSIX says these are implementation-defined.\n * To simplify use with Windows API, we treat them the same way.\n */\n\n#define RTLD_LAZY   0\n#define RTLD_NOW    0\n\n#define RTLD_GLOBAL (1 << 1)\n#define RTLD_LOCAL  (1 << 2)\n\n/* These two were added in The Open Group Base Specifications Issue 6.\n * Note: All other RTLD_* flags in any dlfcn.h are not standard compliant.\n */\n\n#define RTLD_DEFAULT    0\n#define RTLD_NEXT       0\n\nvoid *dlopen ( const char *file, int mode );\nint   dlclose( void *handle );\nvoid *dlsym  ( void *handle, const char *name );\nchar *dlerror( void );\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* DLFCN_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/third_party/dlfcn-win32-read-only/test.c": "/*\n * dlfcn-win32\n * Copyright (c) 2007-2009 Ramiro Polla\n * Copyright (c) 2014      Tiancheng \"Timothy\" Gu\n *\n * dlfcn-win32 is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * dlfcn-win32 is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with dlfcn-win32; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n#include <stdio.h>\n#include \"dlfcn.h\"\n\n/* If these dlclose's fails, we don't care as the handles are going to be\n   closed eventually when the program ends. */\n#define CLOSE_LIB    dlclose( library )\n#define CLOSE_GLOBAL dlclose( global  )\n\n#define RETURN_ERROR return 1\n#define RUNFUNC do { \\\n                    ret = function (); \\\n                    if( ret != 0) {    \\\n                        CLOSE_LIB;     \\\n                        CLOSE_GLOBAL;  \\\n                        RETURN_ERROR;  \\\n                    }                  \\\n                } while( 0 )\n                        \n\n/* This is what this test does:\n * - Open library with RTLD_GLOBAL\n * - Get global object\n * - Get symbol from library through library object <- works\n * - Run function if it worked\n * - Get nonexistent symbol from library through library object <- fails\n * - Get symbol from library through global object  <- works\n * - Run function if it worked\n * - Get nonexistent symbol from library through global object <- fails\n * - Close library\n * - Open library with RTLD_LOCAL\n * - Get symbol from library through library object <- works\n * - Run function if it worked\n * - Get nonexistent symbol from library through library object <- fails\n * - Get local symbol from library through global object  <- fails\n * - Get nonexistent local symbol from library through global object <- fails\n * - Open library again (without closing it first) with RTLD_GLOBAL\n * - Get symbol from library through global object  <- works\n * - Get nonexistent symbol from library through global object <- fails\n * - Close library\n * - Close global object\n *\n * If one test fails, the program terminates itself.\n */\n\nint main()\n{\n    void *global;\n    void *library;\n    char *error;\n    int (*function)( void );\n    int (*nonexistentfunction)( void );\n    int ret;\n\n    library = dlopen( \"testdll.dll\", RTLD_GLOBAL );\n    if( !library )\n    {\n        error = dlerror( );\n        printf( \"ERROR\\tCould not open library globally: %s\\n\", error ? error : \"\" );\n        RETURN_ERROR; \n    }\n    else\n        printf( \"SUCCESS\\tOpened library globally: %p\\n\", library );\n\n    global = dlopen( 0, RTLD_GLOBAL );\n    if( !global )\n    {\n        error = dlerror( );\n        printf( \"ERROR\\tCould not open global handle: %s\\n\", error ? error : \"\" );\n        CLOSE_LIB;\n        RETURN_ERROR;\n    }\n    else\n        printf( \"SUCCESS\\tGot global handle: %p\\n\", global );\n\n    function = dlsym( library, \"function\" );\n    if( !function )\n    {\n        error = dlerror( );\n        printf( \"ERROR\\tCould not get symbol from library handle: %s\\n\",\n                error ? error : \"\" );\n        CLOSE_LIB;\n        CLOSE_GLOBAL;\n        RETURN_ERROR;\n    }\n    else\n        printf( \"SUCCESS\\tGot symbol from library handle: %p\\n\", function );\n\n    RUNFUNC;\n\n    nonexistentfunction = dlsym( library, \"nonexistentfunction\" );\n    if( nonexistentfunction )\n    {\n        error = dlerror( );\n        printf( \"ERROR\\tGot nonexistent symbol from library handle: %p\\n\", nonexistentfunction );\n        CLOSE_LIB;\n        CLOSE_GLOBAL;\n        RETURN_ERROR;\n    }\n    else {\n        error = dlerror( );\n        printf( \"SUCCESS\\tCould not get nonexistent symbol from library handle: %s\\n\",\n                error ? error : \"\" );\n    }\n\n    function = dlsym( global, \"function\" );\n    if( !function )\n    {\n        error = dlerror( );\n        printf( \"ERROR\\tCould not get symbol from global handle: %s\\n\",\n                error ? error : \"\" );\n        CLOSE_LIB;\n        CLOSE_GLOBAL;\n        RETURN_ERROR;\n    }\n    else\n        printf( \"SUCCESS\\tGot symbol from global handle: %p\\n\", function );\n\n    RUNFUNC;\n\n    nonexistentfunction = dlsym( global, \"nonexistentfunction\" );\n    if( nonexistentfunction )\n    {\n        error = dlerror( );\n        printf( \"ERROR\\tGot nonexistent symbol from global handle: %p\\n\", nonexistentfunction );\n        CLOSE_LIB;\n        CLOSE_GLOBAL;\n        RETURN_ERROR;\n    }\n    else {\n        error = dlerror( );\n        printf( \"SUCCESS\\tCould not get nonexistent symbol from global handle: %s\\n\",\n                error ? error : \"\" );\n    }\n\n    ret = dlclose( library );\n    if( ret )\n    {\n        error = dlerror( );\n        printf( \"ERROR\\tCould not close library: %s\\n\", error ? error : \"\" );\n        RETURN_ERROR;\n    }\n    else\n        printf( \"SUCCESS\\tClosed library.\\n\" );\n\n    library = dlopen( \"testdll.dll\", RTLD_LOCAL );\n    if( !library )\n    {\n        error = dlerror( );\n        printf( \"ERROR\\tCould not open library locally: %s\\n\", error ? error : \"\" );\n        CLOSE_LIB;\n        CLOSE_GLOBAL;\n        RETURN_ERROR;\n    }\n    else\n        printf( \"SUCCESS\\tOpened library locally: %p\\n\", library );\n\n    function = dlsym( library, \"function\" );\n    if( !function )\n    {\n        error = dlerror( );\n        printf( \"ERROR\\tCould not get symbol from library handle: %s\\n\",\n                error ? error : \"\" );\n        CLOSE_LIB;\n        CLOSE_GLOBAL;\n        RETURN_ERROR;\n    }\n    else\n        printf( \"SUCCESS\\tGot symbol from library handle: %p\\n\", function );\n\n    RUNFUNC;\n\n    nonexistentfunction = dlsym( library, \"nonexistentfunction\" );\n    if( nonexistentfunction )\n    {\n        error = dlerror( );\n        printf( \"ERROR\\tGot nonexistent symbol from library handle: %p\\n\", nonexistentfunction );\n        CLOSE_LIB;\n        CLOSE_GLOBAL;\n        RETURN_ERROR;\n    }\n    else {\n        error = dlerror( );\n        printf( \"SUCCESS\\tCould not get nonexistent symbol from library handle: %s\\n\",\n                error ? error : \"\" );\n    }\n\n    function = dlsym( global, \"function\" );\n    if( function )\n    {\n        error = dlerror( );\n        printf( \"ERROR\\tGot local symbol from global handle: %s @ %p\\n\",\n                error ? error : \"\", function );\n        CLOSE_LIB;\n        CLOSE_GLOBAL;\n        RETURN_ERROR;\n    }\n    else\n        printf( \"SUCCESS\\tDid not get local symbol from global handle.\\n\" );\n\n    nonexistentfunction = dlsym( global, \"nonexistentfunction\" );\n    if( nonexistentfunction )\n    {\n        error = dlerror( );\n        printf( \"ERROR\\tGot nonexistent local symbol from global handle: %p\\n\", nonexistentfunction );\n        CLOSE_LIB;\n        CLOSE_GLOBAL;\n        RETURN_ERROR;\n    }\n    else {\n        error = dlerror( );\n        printf( \"SUCCESS\\tDid not get nonexistent local symbol from global handle: %s\\n\",\n                error ? error : \"\" );\n    }\n\n    library = dlopen( \"testdll.dll\", RTLD_GLOBAL );\n    if( !library )\n    {\n        error = dlerror( );\n        printf( \"ERROR\\tCould not open library globally without closing it first: %s\\n\", error ? error : \"\" );\n        CLOSE_LIB;\n        CLOSE_GLOBAL;\n        RETURN_ERROR;\n    }\n    else\n        printf( \"SUCCESS\\tOpened library globally without closing it first: %p\\n\", library );\n\n    function = dlsym( global, \"function\" );\n    if( !function )\n    {\n        error = dlerror( );\n        printf( \"ERROR\\tCould not get symbol from global handle: %s\\n\",\n                error ? error : \"\" );\n        CLOSE_LIB;\n        CLOSE_GLOBAL;\n        RETURN_ERROR;\n    }\n    else\n        printf( \"SUCCESS\\tGot symbol from global handle: %p\\n\", function );\n\n    RUNFUNC;\n\n    nonexistentfunction = dlsym( global, \"nonexistentfunction\" );\n    if( nonexistentfunction )\n    {\n        error = dlerror( );\n        printf( \"ERROR\\tGot nonexistent symbol from global handle: %p\\n\", nonexistentfunction );\n        CLOSE_LIB;\n        CLOSE_GLOBAL;\n        RETURN_ERROR;\n    }\n    else {\n        error = dlerror( );\n        printf( \"SUCCESS\\tCould not get nonexistent symbol from global handle: %s\\n\",\n                error ? error : \"\" );\n    }\n\n    ret = dlclose( library );\n    if( ret )\n    {\n        error = dlerror( );\n        printf( \"ERROR\\tCould not close library: %s\\n\", error ? error : \"\" );\n        CLOSE_GLOBAL;\n        RETURN_ERROR;\n    }\n    else\n        printf( \"SUCCESS\\tClosed library.\\n\" );\n\n    ret = dlclose( global );\n    if( ret )\n    {\n        error = dlerror( );\n        printf( \"ERROR\\tCould not close global handle: %s\\n\", error ? error : \"\" );\n        RETURN_ERROR;\n    }\n    else\n        printf( \"SUCCESS\\tClosed global handle.\\n\" );\n\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/third_party/dlfcn-win32-read-only/dlfcn.c": "/*\n * dlfcn-win32\n * Copyright (c) 2007 Ramiro Polla\n *\n * dlfcn-win32 is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * dlfcn-win32 is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with dlfcn-win32; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include <windows.h>\n#include <stdio.h>\n\n#include \"dlfcn.h\"\n\n/* Note:\n * MSDN says these functions are not thread-safe. We make no efforts to have\n * any kind of thread safety.\n */\n\ntypedef struct global_object {\n    HMODULE hModule;\n    struct global_object *previous;\n    struct global_object *next;\n} global_object;\n\nstatic global_object first_object;\n\n/* These functions implement a double linked list for the global objects. */\nstatic global_object *global_search( HMODULE hModule )\n{\n    global_object *pobject;\n\n    if( hModule == NULL )\n        return NULL;\n\n    for( pobject = &first_object; pobject ; pobject = pobject->next )\n        if( pobject->hModule == hModule )\n            return pobject;\n\n    return NULL;\n}\n\nstatic void global_add( HMODULE hModule )\n{\n    global_object *pobject;\n    global_object *nobject;\n\n    if( hModule == NULL )\n        return;\n\n    pobject = global_search( hModule );\n\n    /* Do not add object again if it's already on the list */\n    if( pobject )\n        return;\n\n    for( pobject = &first_object; pobject->next ; pobject = pobject->next );\n\n    nobject = malloc( sizeof(global_object) );\n\n    /* Should this be enough to fail global_add, and therefore also fail\n     * dlopen?\n     */\n    if( !nobject )\n        return;\n\n    pobject->next = nobject;\n    nobject->next = NULL;\n    nobject->previous = pobject;\n    nobject->hModule = hModule;\n}\n\nstatic void global_rem( HMODULE hModule )\n{\n    global_object *pobject;\n\n    if( hModule == NULL )\n        return;\n\n    pobject = global_search( hModule );\n\n    if( !pobject )\n        return;\n\n    if( pobject->next )\n        pobject->next->previous = pobject->previous;\n    if( pobject->previous )\n        pobject->previous->next = pobject->next;\n\n    free( pobject );\n}\n\n/* POSIX says dlerror( ) doesn't have to be thread-safe, so we use one\n * static buffer.\n * MSDN says the buffer cannot be larger than 64K bytes, so we set it to\n * the limit.\n */\nstatic char error_buffer[65535];\nstatic char *current_error;\n\nstatic int copy_string( char *dest, int dest_size, const char *src )\n{\n    int i = 0;\n\n    /* gcc should optimize this out */\n    if( !src || !dest )\n        return 0;\n\n    for( i = 0 ; i < dest_size-1 ; i++ )\n    {\n        if( !src[i] )\n            break;\n        else\n            dest[i] = src[i];\n    }\n    dest[i] = '\\0';\n\n    return i;\n}\n\nstatic void save_err_str( const char *str )\n{\n    DWORD dwMessageId;\n    DWORD pos;\n\n    dwMessageId = GetLastError( );\n\n    if( dwMessageId == 0 )\n        return;\n\n    /* Format error message to:\n     * \"<argument to function that failed>\": <Windows localized error message>\n     */\n    pos  = copy_string( error_buffer,     sizeof(error_buffer),     \"\\\"\" );\n    pos += copy_string( error_buffer+pos, sizeof(error_buffer)-pos, str );\n    pos += copy_string( error_buffer+pos, sizeof(error_buffer)-pos, \"\\\": \" );\n    pos += FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwMessageId,\n                          MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT ),\n                          error_buffer+pos, sizeof(error_buffer)-pos, NULL );\n\n    if( pos > 1 )\n    {\n        /* POSIX says the string must not have trailing <newline> */\n        if( error_buffer[pos-2] == '\\r' && error_buffer[pos-1] == '\\n' )\n            error_buffer[pos-2] = '\\0';\n    }\n\n    current_error = error_buffer;\n}\n\nstatic void save_err_ptr_str( const void *ptr )\n{\n    char ptr_buf[19]; /* 0x<pointer> up to 64 bits. */\n\n    sprintf( ptr_buf, \"0x%p\", ptr );\n\n    save_err_str( ptr_buf );\n}\n\nvoid *dlopen( const char *file, int mode )\n{\n    HMODULE hModule;\n    UINT uMode;\n\n    current_error = NULL;\n\n    /* Do not let Windows display the critical-error-handler message box */\n    uMode = SetErrorMode( SEM_FAILCRITICALERRORS );\n\n    if( file == 0 )\n    {\n        /* POSIX says that if the value of file is 0, a handle on a global\n         * symbol object must be provided. That object must be able to access\n         * all symbols from the original program file, and any objects loaded\n         * with the RTLD_GLOBAL flag.\n         * The return value from GetModuleHandle( ) allows us to retrieve\n         * symbols only from the original program file. For objects loaded with\n         * the RTLD_GLOBAL flag, we create our own list later on.\n         */\n        hModule = GetModuleHandle( NULL );\n\n        if( !hModule )\n            save_err_ptr_str( file );\n    }\n    else\n    {\n        char lpFileName[MAX_PATH];\n        int i;\n\n        /* MSDN says backslashes *must* be used instead of forward slashes. */\n        for( i = 0 ; i < sizeof(lpFileName)-1 ; i++ )\n        {\n            if( !file[i] )\n                break;\n            else if( file[i] == '/' )\n                lpFileName[i] = '\\\\';\n            else\n                lpFileName[i] = file[i];\n        }\n        lpFileName[i] = '\\0';\n\n        /* POSIX says the search path is implementation-defined.\n         * LOAD_WITH_ALTERED_SEARCH_PATH is used to make it behave more closely\n         * to UNIX's search paths (start with system folders instead of current\n         * folder).\n         */\n        hModule = LoadLibraryEx( (LPSTR) lpFileName, NULL, \n                                 LOAD_WITH_ALTERED_SEARCH_PATH );\n\n        /* If the object was loaded with RTLD_GLOBAL, add it to list of global\n         * objects, so that its symbols may be retrieved even if the handle for\n         * the original program file is passed. POSIX says that if the same\n         * file is specified in multiple invocations, and any of them are\n         * RTLD_GLOBAL, even if any further invocations use RTLD_LOCAL, the\n         * symbols will remain global.\n         */\n        if( !hModule )\n            save_err_str( lpFileName );\n        else if( (mode & RTLD_GLOBAL) )\n            global_add( hModule );\n    }\n\n    /* Return to previous state of the error-mode bit flags. */\n    SetErrorMode( uMode );\n\n    return (void *) hModule;\n}\n\nint dlclose( void *handle )\n{\n    HMODULE hModule = (HMODULE) handle;\n    BOOL ret;\n\n    current_error = NULL;\n\n    ret = FreeLibrary( hModule );\n\n    /* If the object was loaded with RTLD_GLOBAL, remove it from list of global\n     * objects.\n     */\n    if( ret )\n        global_rem( hModule );\n    else\n        save_err_ptr_str( handle );\n\n    /* dlclose's return value in inverted in relation to FreeLibrary's. */\n    ret = !ret;\n\n    return (int) ret;\n}\n\nvoid *dlsym( void *handle, const char *name )\n{\n    FARPROC symbol;\n\n    current_error = NULL;\n\n    symbol = GetProcAddress( handle, name );\n\n    if( symbol == NULL )\n    {\n        HMODULE hModule;\n\n        /* If the handle for the original program file is passed, also search\n         * in all globally loaded objects.\n         */\n\n        hModule = GetModuleHandle( NULL );\n\n        if( hModule == handle )\n        {\n            global_object *pobject;\n\n            for( pobject = &first_object; pobject ; pobject = pobject->next )\n            {\n                if( pobject->hModule )\n                {\n                    symbol = GetProcAddress( pobject->hModule, name );\n                    if( symbol != NULL )\n                        break;\n                }\n            }\n        }\n    }\n\n    if( symbol == NULL )\n        save_err_str( name );\n\n    return (void*) symbol;\n}\n\nchar *dlerror( void )\n{\n    char *error_pointer = current_error;\n\n    /* POSIX says that invoking dlerror( ) a second time, immediately following\n     * a prior invocation, shall result in NULL being returned.\n     */\n    current_error = NULL;\n\n    return error_pointer;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/rest/mongoose.c": "// Copyright (c) 2004-2013 Sergey Lyubka <valenok@gmail.com>\n// Copyright (c) 2013 Cesanta Software Limited\n// All rights reserved\n//\n// This library is dual-licensed: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License version 2 as\n// published by the Free Software Foundation. For the terms of this\n// license, see <http://www.gnu.org/licenses/>.\n//\n// You are free to use this library under the terms of the GNU General\n// Public License, but WITHOUT ANY WARRANTY; without even the implied\n// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n// See the GNU General Public License for more details.\n//\n// Alternatively, you can license this library under a commercial\n// license, as set out in <http://cesanta.com/products.html>.\n\n#if defined(_WIN32)\n#undef _UNICODE\n#define _MBCS\n#if !defined(_CRT_SECURE_NO_WARNINGS)\n#define _CRT_SECURE_NO_WARNINGS // Disable deprecation warning in VS2005\n#endif\n#else\n#ifdef __linux__\n#define _XOPEN_SOURCE 600     // For flockfile() on Linux\n#endif\n#if !defined(_LARGEFILE_SOURCE)\n#define _LARGEFILE_SOURCE     // Enable 64-bit file offsets\n#endif\n#define __STDC_FORMAT_MACROS  // <inttypes.h> wants this for C++\n#define __STDC_LIMIT_MACROS   // C++ wants that for INT64_MAX\n#endif\n\n#if defined (_MSC_VER)\n// conditional expression is constant: introduced by FD_SET(..)\n#pragma warning (disable : 4127)\n// non-constant aggregate initializer: issued due to missing C99 support\n#pragma warning (disable : 4204)\n#endif\n\n// Disable WIN32_LEAN_AND_MEAN.\n// This makes windows.h always include winsock2.h\n#ifdef _WIN32_LEAN_AND_MEAN\n#undef WIN32_LEAN_AND_MEAN\n#endif\n\n#if defined(__SYMBIAN32__)\n#define NO_SSL // SSL is not supported\n#define NO_CGI // CGI is not supported\n#define PATH_MAX FILENAME_MAX\n#endif // __SYMBIAN32__\n\n#ifndef _WIN32_WCE // Some ANSI #includes are not available on Windows CE\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <signal.h>\n#include <fcntl.h>\n#endif // !_WIN32_WCE\n\n#include <time.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <assert.h>\n#include <string.h>\n#include <ctype.h>\n#include <limits.h>\n#include <stddef.h>\n#include <stdio.h>\n\n#if defined(_WIN32) && !defined(__SYMBIAN32__) // Windows specific\n#undef _WIN32_WINNT\n#define _WIN32_WINNT 0x0400 // To make it link in VS2005\n#include <windows.h>\n\n#ifndef PATH_MAX\n#define PATH_MAX MAX_PATH\n#endif\n\n#ifndef _WIN32_WCE\n#include <process.h>\n#include <direct.h>\n#include <io.h>\n#else // _WIN32_WCE\n#define NO_CGI // WinCE has no pipes\n\ntypedef long off_t;\n\n#define errno   GetLastError()\n#define strerror(x)  _ultoa(x, (char *) _alloca(sizeof(x) *3 ), 10)\n#endif // _WIN32_WCE\n\n#define MAKEUQUAD(lo, hi) ((uint64_t)(((uint32_t)(lo)) | \\\n      ((uint64_t)((uint32_t)(hi))) << 32))\n#define RATE_DIFF 10000000 // 100 nsecs\n#define EPOCH_DIFF MAKEUQUAD(0xd53e8000, 0x019db1de)\n#define SYS2UNIX_TIME(lo, hi) \\\n  (time_t) ((MAKEUQUAD((lo), (hi)) - EPOCH_DIFF) / RATE_DIFF)\n\n// Visual Studio 6 does not know __func__ or __FUNCTION__\n// The rest of MS compilers use __FUNCTION__, not C99 __func__\n// Also use _strtoui64 on modern M$ compilers\n#if defined(_MSC_VER) && _MSC_VER < 1300\n#define STRX(x) #x\n#define STR(x) STRX(x)\n#define __func__ __FILE__ \":\" STR(__LINE__)\n#define strtoull(x, y, z) (unsigned __int64) _atoi64(x)\n#define strtoll(x, y, z) _atoi64(x)\n#else\n#define __func__  __FUNCTION__\n#define strtoull(x, y, z) _strtoui64(x, y, z)\n#define strtoll(x, y, z) _strtoi64(x, y, z)\n#endif // _MSC_VER\n\n#define ERRNO   GetLastError()\n#define NO_SOCKLEN_T\n#define SSL_LIB   \"ssleay32.dll\"\n#define CRYPTO_LIB  \"libeay32.dll\"\n#define O_NONBLOCK  0\n#if !defined(EWOULDBLOCK)\n#define EWOULDBLOCK  WSAEWOULDBLOCK\n#endif // !EWOULDBLOCK\n#define _POSIX_\n#define INT64_FMT  \"I64d\"\n\n#define WINCDECL __cdecl\n#define SHUT_WR 1\n#define snprintf _snprintf\n#define vsnprintf _vsnprintf\n#define mg_sleep(x) Sleep(x)\n\n#define pipe(x) _pipe(x, MG_BUF_LEN, _O_BINARY)\n#ifndef popen\n#define popen(x, y) _popen(x, y)\n#endif\n#ifndef pclose\n#define pclose(x) _pclose(x)\n#endif\n#define close(x) _close(x)\n#define dlsym(x,y) GetProcAddress((HINSTANCE) (x), (y))\n#define RTLD_LAZY  0\n#define fseeko(x, y, z) _lseeki64(_fileno(x), (y), (z))\n#define fdopen(x, y) _fdopen((x), (y))\n#define write(x, y, z) _write((x), (y), (unsigned) z)\n#define read(x, y, z) _read((x), (y), (unsigned) z)\n#define flockfile(x)\n#define funlockfile(x)\n#define sleep(x) Sleep((x) * 1000)\n#define rmdir(x) _rmdir(x)\n\n#if !defined(va_copy)\n#define va_copy(x, y) x = y\n#endif // !va_copy MINGW #defines va_copy\n\n#if !defined(fileno)\n#define fileno(x) _fileno(x)\n#endif // !fileno MINGW #defines fileno\n\ntypedef HANDLE pthread_mutex_t;\ntypedef struct {HANDLE signal, broadcast;} pthread_cond_t;\ntypedef DWORD pthread_t;\n#define pid_t HANDLE // MINGW typedefs pid_t to int. Using #define here.\n\nstatic int pthread_mutex_lock(pthread_mutex_t *);\nstatic int pthread_mutex_unlock(pthread_mutex_t *);\nstatic void to_unicode(const char *path, wchar_t *wbuf, size_t wbuf_len);\n\n#if defined(HAVE_STDINT)\n#include <stdint.h>\n#else\ntypedef unsigned int  uint32_t;\ntypedef unsigned short  uint16_t;\ntypedef unsigned __int64 uint64_t;\ntypedef __int64   int64_t;\n#define INT64_MAX  9223372036854775807\n#endif // HAVE_STDINT\n\n// POSIX dirent interface\nstruct dirent {\n  char d_name[PATH_MAX];\n};\n\ntypedef struct DIR {\n  HANDLE   handle;\n  WIN32_FIND_DATAW info;\n  struct dirent  result;\n} DIR;\n\n#ifndef HAVE_POLL\nstruct pollfd {\n  SOCKET fd;\n  short events;\n  short revents;\n};\n#define POLLIN 1\n#endif\n\n\n// Mark required libraries\n#ifdef _MSC_VER\n#pragma comment(lib, \"Ws2_32.lib\")\n#endif\n\n#else    // UNIX  specific\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/poll.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <sys/time.h>\n#include <stdint.h>\n#include <inttypes.h>\n#include <netdb.h>\n\n#include <pwd.h>\n#include <unistd.h>\n#include <dirent.h>\n#if !defined(NO_SSL_DL) && !defined(NO_SSL)\n#include <dlfcn.h>\n#endif\n#include <pthread.h>\n#if defined(__MACH__)\n#define SSL_LIB   \"libssl.dylib\"\n#define CRYPTO_LIB  \"libcrypto.dylib\"\n#else\n#if !defined(SSL_LIB)\n#define SSL_LIB   \"libssl.so\"\n#endif\n#if !defined(CRYPTO_LIB)\n#define CRYPTO_LIB  \"libcrypto.so\"\n#endif\n#endif\n#ifndef O_BINARY\n#define O_BINARY  0\n#endif // O_BINARY\n#define closesocket(a) close(a)\n#define mg_mkdir(x, y) mkdir(x, y)\n#define mg_remove(x) remove(x)\n#define mg_sleep(x) usleep((x) * 1000)\n#define ERRNO errno\n#define INVALID_SOCKET (-1)\n#define INT64_FMT PRId64\ntypedef int SOCKET;\n#define WINCDECL\n\n#endif // End of Windows and UNIX specific includes\n\n#include \"mongoose.h\"\n\n#define MONGOOSE_VERSION \"4.2\"\n#define PASSWORDS_FILE_NAME \".htpasswd\"\n#define CGI_ENVIRONMENT_SIZE 4096\n#define MAX_CGI_ENVIR_VARS 64\n#define MG_BUF_LEN 8192\n#define MAX_REQUEST_SIZE 16384\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\n#ifdef DEBUG_TRACE\n#undef DEBUG_TRACE\n#define DEBUG_TRACE(x)\n#else\n#if defined(DEBUG)\n#define DEBUG_TRACE(x) do { \\\n  flockfile(stdout); \\\n  printf(\"*** %lu.%p.%s.%d: \", \\\n         (unsigned long) time(NULL), (void *) pthread_self(), \\\n         __func__, __LINE__); \\\n  printf x; \\\n  putchar('\\n'); \\\n  fflush(stdout); \\\n  funlockfile(stdout); \\\n} while (0)\n#else\n#define DEBUG_TRACE(x)\n#endif // DEBUG\n#endif // DEBUG_TRACE\n\n// Darwin prior to 7.0 and Win32 do not have socklen_t\n#ifdef NO_SOCKLEN_T\ntypedef int socklen_t;\n#endif // NO_SOCKLEN_T\n#define _DARWIN_UNLIMITED_SELECT\n\n#define IP_ADDR_STR_LEN 50  // IPv6 hex string is 46 chars\n\n#if !defined(MSG_NOSIGNAL)\n#define MSG_NOSIGNAL 0\n#endif\n\n#if !defined(SOMAXCONN)\n#define SOMAXCONN 100\n#endif\n\n#if !defined(PATH_MAX)\n#define PATH_MAX 4096\n#endif\n\n// Size of the accepted socket queue\n#if !defined(MGSQLEN)\n#define MGSQLEN 20\n#endif\n\n// Extra HTTP headers to send in every static file reply\n#if !defined(EXTRA_HTTP_HEADERS)\n#define EXTRA_HTTP_HEADERS \"\"\n#endif\n\nstatic const char *http_500_error = \"Internal Server Error\";\n\n#if defined(NO_SSL_DL)\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#else\n// SSL loaded dynamically from DLL.\n// I put the prototypes here to be independent from OpenSSL source installation.\ntypedef struct ssl_st SSL;\ntypedef struct ssl_method_st SSL_METHOD;\ntypedef struct ssl_ctx_st SSL_CTX;\n\nstruct ssl_func {\n  const char *name;   // SSL function name\n  void  (*ptr)(void); // Function pointer\n};\n\nstatic struct ssl_func ssl_sw[30];\n\n#define SSL_free (* (void (*)(SSL *)) ssl_sw[0].ptr)\n#define SSL_accept (* (int (*)(SSL *)) ssl_sw[1].ptr)\n#define SSL_connect (* (int (*)(SSL *)) ssl_sw[2].ptr)\n#define SSL_read (* (int (*)(SSL *, void *, int)) ssl_sw[3].ptr)\n#define SSL_write (* (int (*)(SSL *, const void *,int)) ssl_sw[4].ptr)\n#define SSL_get_error (* (int (*)(SSL *, int)) ssl_sw[5].ptr)\n#define SSL_set_fd (* (int (*)(SSL *, SOCKET)) ssl_sw[6].ptr)\n#define SSL_new (* (SSL * (*)(SSL_CTX *)) ssl_sw[7].ptr)\n#define SSL_CTX_new (* (SSL_CTX * (*)(SSL_METHOD *)) ssl_sw[8].ptr)\n#define SSLv23_server_method (* (SSL_METHOD * (*)(void)) ssl_sw[9].ptr)\n#define SSL_library_init (* (int (*)(void)) ssl_sw[10].ptr)\n#define SSL_CTX_use_PrivateKey_file (* (int (*)(SSL_CTX *, \\\n        const char *, int)) ssl_sw[11].ptr)\n#define SSL_CTX_use_certificate_file (* (int (*)(SSL_CTX *, \\\n        const char *, int)) ssl_sw[12].ptr)\n#define SSL_CTX_set_default_passwd_cb \\\n  (* (void (*)(SSL_CTX *, mg_event_handler_t)) ssl_sw[13].ptr)\n#define SSL_CTX_free (* (void (*)(SSL_CTX *)) ssl_sw[14].ptr)\n#define SSL_load_error_strings (* (void (*)(void)) ssl_sw[15].ptr)\n#define SSL_CTX_use_certificate_chain_file \\\n  (* (int (*)(SSL_CTX *, const char *)) ssl_sw[16].ptr)\n#define SSLv23_client_method (* (SSL_METHOD * (*)(void)) ssl_sw[17].ptr)\n#define SSL_pending (* (int (*)(SSL *)) ssl_sw[18].ptr)\n#define SSL_CTX_set_verify (* (void (*)(SSL_CTX *, int, int)) ssl_sw[19].ptr)\n#define SSL_shutdown (* (int (*)(SSL *)) ssl_sw[20].ptr)\n\n#define CRYPTO_num_locks (* (int (*)(void)) crypto_sw[0].ptr)\n#define CRYPTO_set_locking_callback \\\n  (* (void (*)(void (*)(int, int, const char *, int))) crypto_sw[1].ptr)\n#define CRYPTO_set_id_callback \\\n  (* (void (*)(unsigned long (*)(void))) crypto_sw[2].ptr)\n#define ERR_get_error (* (unsigned long (*)(void)) crypto_sw[3].ptr)\n#define ERR_error_string (* (char * (*)(unsigned long,char *)) crypto_sw[4].ptr)\n#endif // NO_SSL_DL\n\n// Unified socket address. For IPv6 support, add IPv6 address structure\n// in the union u.\nunion usa {\n  struct sockaddr sa;\n  struct sockaddr_in sin;\n#if defined(USE_IPV6)\n  struct sockaddr_in6 sin6;\n#endif\n};\n\n// Describes a string (chunk of memory).\nstruct vec {\n  const char *ptr;\n  size_t len;\n};\n\nstruct file {\n  int is_directory;\n  time_t modification_time;\n  int64_t size;\n  // set to 1 if the content is gzipped\n  // in which case we need a content-encoding: gzip header\n  int gzipped;\n};\n#define STRUCT_FILE_INITIALIZER { 0, 0, 0, 0 }\n\n// Describes listening socket, or socket which was accept()-ed by the master\n// thread and queued for future handling by the worker thread.\nstruct socket {\n  SOCKET sock;          // Listening socket\n  union usa lsa;        // Local socket address\n  union usa rsa;        // Remote socket address\n  unsigned is_ssl:1;    // Is port SSL-ed\n  unsigned ssl_redir:1; // Is port supposed to redirect everything to SSL port\n};\n\n// NOTE(lsm): this enum shoulds be in sync with the config_options.\nenum {\n  CGI_EXTENSIONS, CGI_ENVIRONMENT, PUT_DELETE_PASSWORDS_FILE, CGI_INTERPRETER,\n  PROTECT_URI, AUTHENTICATION_DOMAIN, SSI_EXTENSIONS, THROTTLE,\n  ACCESS_LOG_FILE, ENABLE_DIRECTORY_LISTING, ERROR_LOG_FILE,\n  GLOBAL_PASSWORDS_FILE, INDEX_FILES, ENABLE_KEEP_ALIVE, ACCESS_CONTROL_LIST,\n  EXTRA_MIME_TYPES, LISTENING_PORTS, DOCUMENT_ROOT, SSL_CERTIFICATE,\n  NUM_THREADS, RUN_AS_USER, REWRITE, HIDE_FILES, REQUEST_TIMEOUT,\n  NUM_OPTIONS\n};\n\nstruct mg_context {\n  volatile int stop_flag;         // Should we stop event loop\n  SSL_CTX *ssl_ctx;               // SSL context\n  char *config[NUM_OPTIONS];      // Mongoose configuration parameters\n  mg_event_handler_t event_handler;  // User-defined callback function\n  void *user_data;                // User-defined data\n\n  struct socket *listening_sockets;\n  int num_listening_sockets;\n\n  volatile int num_threads;  // Number of threads\n  pthread_mutex_t mutex;     // Protects (max|num)_threads\n  pthread_cond_t  cond;      // Condvar for tracking workers terminations\n\n  struct socket queue[MGSQLEN];   // Accepted sockets\n  volatile int sq_head;      // Head of the socket queue\n  volatile int sq_tail;      // Tail of the socket queue\n  pthread_cond_t sq_full;    // Signaled when socket is produced\n  pthread_cond_t sq_empty;   // Signaled when socket is consumed\n};\n\nstruct mg_connection {\n  struct mg_request_info request_info;\n  struct mg_event event;\n  struct mg_context *ctx;\n  SSL *ssl;                   // SSL descriptor\n  SSL_CTX *client_ssl_ctx;    // SSL context for client connections\n  struct socket client;       // Connected client\n  time_t birth_time;          // Time when request was received\n  int64_t num_bytes_sent;     // Total bytes sent to client\n  int64_t content_len;        // Content-Length header value\n  int64_t num_bytes_read;     // Bytes read from a remote socket\n  char *buf;                  // Buffer for received data\n  char *path_info;            // PATH_INFO part of the URL\n  int must_close;             // 1 if connection must be closed\n  int buf_size;               // Buffer size\n  int request_len;            // Size of the request + headers in a buffer\n  int data_len;               // Total size of data in a buffer\n  int status_code;            // HTTP reply status code, e.g. 200\n  int throttle;               // Throttling, bytes/sec. <= 0 means no throttle\n  time_t last_throttle_time;  // Last time throttled data was sent\n  int64_t last_throttle_bytes;// Bytes sent this second\n};\n\n// Directory entry\nstruct de {\n  struct mg_connection *conn;\n  char *file_name;\n  struct file file;\n};\n\nstatic FILE *mg_fopen(const char *path, const char *mode);\nstatic int mg_stat(const char *path, struct file *filep);\nstatic void send_http_error(struct mg_connection *, int, const char *,\n                            PRINTF_FORMAT_STRING(const char *fmt), ...)\n                            PRINTF_ARGS(4, 5);\nstatic void cry(struct mg_connection *conn,\n                PRINTF_FORMAT_STRING(const char *fmt), ...) PRINTF_ARGS(2, 3);\nstatic int getreq(struct mg_connection *conn, char *ebuf, size_t ebuf_len);\n\n#ifdef USE_LUA\n#include \"lua_5.2.1.h\"\nstatic int handle_lsp_request(struct mg_connection *, const char *,\n                              struct file *, struct lua_State *);\n#endif\n\n// Return fake connection structure. Used for logging, if connection\n// is not applicable at the moment of logging.\nstatic struct mg_connection *fc(struct mg_context *ctx) {\n  static struct mg_connection fake_connection;\n  fake_connection.ctx = ctx;\n  // See https://github.com/cesanta/mongoose/issues/236\n  fake_connection.event.user_data = ctx->user_data;\n  return &fake_connection;\n}\n\nstatic void mg_strlcpy(register char *dst, register const char *src, size_t n) {\n  for (; *src != '\\0' && n > 1; n--) {\n    *dst++ = *src++;\n  }\n  *dst = '\\0';\n}\n\nstatic int lowercase(const char *s) {\n  return tolower(* (const unsigned char *) s);\n}\n\nstatic int mg_strncasecmp(const char *s1, const char *s2, size_t len) {\n  int diff = 0;\n\n  if (len > 0)\n    do {\n      diff = lowercase(s1++) - lowercase(s2++);\n    } while (diff == 0 && s1[-1] != '\\0' && --len > 0);\n\n  return diff;\n}\n\nstatic int mg_strcasecmp(const char *s1, const char *s2) {\n  int diff;\n\n  do {\n    diff = lowercase(s1++) - lowercase(s2++);\n  } while (diff == 0 && s1[-1] != '\\0');\n\n  return diff;\n}\n\nstatic char * mg_strndup(const char *ptr, size_t len) {\n  char *p;\n\n  if ((p = (char *) malloc(len + 1)) != NULL) {\n    mg_strlcpy(p, ptr, len + 1);\n  }\n\n  return p;\n}\n\nstatic char * mg_strdup(const char *str) {\n  return mg_strndup(str, strlen(str));\n}\n\nstatic const char *mg_strcasestr(const char *big_str, const char *small_str) {\n  int i, big_len = strlen(big_str), small_len = strlen(small_str);\n\n  for (i = 0; i <= big_len - small_len; i++) {\n    if (mg_strncasecmp(big_str + i, small_str, small_len) == 0) {\n      return big_str + i;\n    }\n  }\n\n  return NULL;\n}\n\n// Like snprintf(), but never returns negative value, or a value\n// that is larger than a supplied buffer.\n// Thanks to Adam Zeldis to pointing snprintf()-caused vulnerability\n// in his audit report.\nstatic int mg_vsnprintf(char *buf, size_t buflen, const char *fmt, va_list ap) {\n  int n;\n\n  if (buflen == 0) {\n    return 0;\n  }\n\n  n = vsnprintf(buf, buflen, fmt, ap);\n\n  if (n < 0) {\n    n = 0;\n  } else if (n >= (int) buflen) {\n    n = (int) buflen - 1;\n  }\n  buf[n] = '\\0';\n\n  return n;\n}\n\nstatic int mg_snprintf(char *buf, size_t buflen,\n    PRINTF_FORMAT_STRING(const char *fmt), ...) PRINTF_ARGS(3, 4);\n\nstatic int mg_snprintf(char *buf, size_t buflen, const char *fmt, ...) {\n  va_list ap;\n  int n;\n\n  va_start(ap, fmt);\n  n = mg_vsnprintf(buf, buflen, fmt, ap);\n  va_end(ap);\n\n  return n;\n}\n\n// Skip the characters until one of the delimiters characters found.\n// 0-terminate resulting word. Skip the delimiter and following whitespaces.\n// Advance pointer to buffer to the next word. Return found 0-terminated word.\n// Delimiters can be quoted with quotechar.\nstatic char *skip_quoted(char **buf, const char *delimiters,\n                         const char *whitespace, char quotechar) {\n  char *p, *begin_word, *end_word, *end_whitespace;\n\n  begin_word = *buf;\n  end_word = begin_word + strcspn(begin_word, delimiters);\n\n  // Check for quotechar\n  if (end_word > begin_word) {\n    p = end_word - 1;\n    while (*p == quotechar) {\n      // If there is anything beyond end_word, copy it\n      if (*end_word == '\\0') {\n        *p = '\\0';\n        break;\n      } else {\n        size_t end_off = strcspn(end_word + 1, delimiters);\n        memmove (p, end_word, end_off + 1);\n        p += end_off; // p must correspond to end_word - 1\n        end_word += end_off + 1;\n      }\n    }\n    for (p++; p < end_word; p++) {\n      *p = '\\0';\n    }\n  }\n\n  if (*end_word == '\\0') {\n    *buf = end_word;\n  } else {\n    end_whitespace = end_word + 1 + strspn(end_word + 1, whitespace);\n\n    for (p = end_word; p < end_whitespace; p++) {\n      *p = '\\0';\n    }\n\n    *buf = end_whitespace;\n  }\n\n  return begin_word;\n}\n\n// Simplified version of skip_quoted without quote char\n// and whitespace == delimiters\nstatic char *skip(char **buf, const char *delimiters) {\n  return skip_quoted(buf, delimiters, delimiters, 0);\n}\n\n\n// Return HTTP header value, or NULL if not found.\nstatic const char *get_header(const struct mg_request_info *ri,\n                              const char *name) {\n  int i;\n\n  for (i = 0; i < ri->num_headers; i++)\n    if (!mg_strcasecmp(name, ri->http_headers[i].name))\n      return ri->http_headers[i].value;\n\n  return NULL;\n}\n\nconst char *mg_get_header(const struct mg_connection *conn, const char *name) {\n  return get_header(&conn->request_info, name);\n}\n\n// A helper function for traversing a comma separated list of values.\n// It returns a list pointer shifted to the next value, or NULL if the end\n// of the list found.\n// Value is stored in val vector. If value has form \"x=y\", then eq_val\n// vector is initialized to point to the \"y\" part, and val vector length\n// is adjusted to point only to \"x\".\nstatic const char *next_option(const char *list, struct vec *val,\n                               struct vec *eq_val) {\n  if (list == NULL || *list == '\\0') {\n    // End of the list\n    list = NULL;\n  } else {\n    val->ptr = list;\n    if ((list = strchr(val->ptr, ',')) != NULL) {\n      // Comma found. Store length and shift the list ptr\n      val->len = list - val->ptr;\n      list++;\n    } else {\n      // This value is the last one\n      list = val->ptr + strlen(val->ptr);\n      val->len = list - val->ptr;\n    }\n\n    if (eq_val != NULL) {\n      // Value has form \"x=y\", adjust pointers and lengths\n      // so that val points to \"x\", and eq_val points to \"y\".\n      eq_val->len = 0;\n      eq_val->ptr = (const char *) memchr(val->ptr, '=', val->len);\n      if (eq_val->ptr != NULL) {\n        eq_val->ptr++;  // Skip over '=' character\n        eq_val->len = val->ptr + val->len - eq_val->ptr;\n        val->len = (eq_val->ptr - val->ptr) - 1;\n      }\n    }\n  }\n\n  return list;\n}\n\n// Perform case-insensitive match of string against pattern\nstatic int match_prefix(const char *pattern, int pattern_len, const char *str) {\n  const char *or_str;\n  int i, j, len, res;\n\n  if ((or_str = (const char *) memchr(pattern, '|', pattern_len)) != NULL) {\n    res = match_prefix(pattern, or_str - pattern, str);\n    return res > 0 ? res :\n        match_prefix(or_str + 1, (pattern + pattern_len) - (or_str + 1), str);\n  }\n\n  i = j = 0;\n  res = -1;\n  for (; i < pattern_len; i++, j++) {\n    if (pattern[i] == '?' && str[j] != '\\0') {\n      continue;\n    } else if (pattern[i] == '$') {\n      return str[j] == '\\0' ? j : -1;\n    } else if (pattern[i] == '*') {\n      i++;\n      if (pattern[i] == '*') {\n        i++;\n        len = (int) strlen(str + j);\n      } else {\n        len = (int) strcspn(str + j, \"/\");\n      }\n      if (i == pattern_len) {\n        return j + len;\n      }\n      do {\n        res = match_prefix(pattern + i, pattern_len - i, str + j + len);\n      } while (res == -1 && len-- > 0);\n      return res == -1 ? -1 : j + res + len;\n    } else if (lowercase(&pattern[i]) != lowercase(&str[j])) {\n      return -1;\n    }\n  }\n  return j;\n}\n\n\nstatic const char *month_names[] = {\n  \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n  \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"\n};\n\n// Convert month to the month number. Return -1 on error, or month number\nstatic int get_month_index(const char *s) {\n  int i;\n\n  for (i = 0; i < (int) ARRAY_SIZE(month_names); i++)\n    if (!strcmp(s, month_names[i]))\n      return i;\n\n  return -1;\n}\n\nstatic int num_leap_years(int year) {\n  return year / 4 - year / 100 + year / 400;\n}\n\n// Parse UTC date-time string, and return the corresponding time_t value.\nstatic time_t parse_date_string(const char *datetime) {\n  static const unsigned short days_before_month[] = {\n    0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334\n  };\n  char month_str[32];\n  int second, minute, hour, day, month, year, leap_days, days;\n  time_t result = (time_t) 0;\n\n  if (((sscanf(datetime, \"%d/%3s/%d %d:%d:%d\",\n               &day, month_str, &year, &hour, &minute, &second) == 6) ||\n       (sscanf(datetime, \"%d %3s %d %d:%d:%d\",\n               &day, month_str, &year, &hour, &minute, &second) == 6) ||\n       (sscanf(datetime, \"%*3s, %d %3s %d %d:%d:%d\",\n               &day, month_str, &year, &hour, &minute, &second) == 6) ||\n       (sscanf(datetime, \"%d-%3s-%d %d:%d:%d\",\n               &day, month_str, &year, &hour, &minute, &second) == 6)) &&\n      year > 1970 &&\n      (month = get_month_index(month_str)) != -1) {\n    leap_days = num_leap_years(year) - num_leap_years(1970);\n    year -= 1970;\n    days = year * 365 + days_before_month[month] + (day - 1) + leap_days;\n    result = days * 24 * 3600 + hour * 3600 + minute * 60 + second;\n  }\n\n  return result;\n}\n\n// This array must be in sync with enum in internal.h\nstatic const char *config_options[] = {\n  \"cgi_pattern\", \"**.cgi$|**.pl$|**.php$\",\n  \"cgi_environment\", NULL,\n  \"put_delete_auth_file\", NULL,\n  \"cgi_interpreter\", NULL,\n  \"protect_uri\", NULL,\n  \"authentication_domain\", \"mydomain.com\",\n  \"ssi_pattern\", \"**.shtml$|**.shtm$\",\n  \"throttle\", NULL,\n  \"access_log_file\", NULL,\n  \"enable_directory_listing\", \"yes\",\n  \"error_log_file\", NULL,\n  \"global_auth_file\", NULL,\n  \"index_files\",\n    \"index.html,index.htm,index.cgi,index.shtml,index.php,index.lp\",\n  \"enable_keep_alive\", \"no\",\n  \"access_control_list\", NULL,\n  \"extra_mime_types\", NULL,\n  \"listening_ports\", \"8080\",\n  \"document_root\",  NULL,\n  \"ssl_certificate\", NULL,\n  \"num_threads\", \"50\",\n  \"run_as_user\", NULL,\n  \"url_rewrite_patterns\", NULL,\n  \"hide_files_patterns\", NULL,\n  \"request_timeout_ms\", \"30000\",\n  NULL\n};\n\nconst char **mg_get_valid_option_names(void) {\n  return config_options;\n}\n\nstatic int get_option_index(const char *name) {\n  int i;\n\n  for (i = 0; config_options[i * 2] != NULL; i++) {\n    if (strcmp(config_options[i * 2], name) == 0) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nconst char *mg_get_option(const struct mg_context *ctx, const char *name) {\n  int i;\n  if ((i = get_option_index(name)) == -1) {\n    return NULL;\n  } else if (ctx->config[i] == NULL) {\n    return \"\";\n  } else {\n    return ctx->config[i];\n  }\n}\nstatic int is_big_endian(void) {\n  static const int n = 1;\n  return ((char *) &n)[0] == 0;\n}\n\n#ifndef HAVE_MD5\ntypedef struct MD5Context {\n  uint32_t buf[4];\n  uint32_t bits[2];\n  unsigned char in[64];\n} MD5_CTX;\n\nstatic void byteReverse(unsigned char *buf, unsigned longs) {\n  uint32_t t;\n\n  // Forrest: MD5 expect LITTLE_ENDIAN, swap if BIG_ENDIAN\n  if (is_big_endian()) {\n    do {\n      t = (uint32_t) ((unsigned) buf[3] << 8 | buf[2]) << 16 |\n        ((unsigned) buf[1] << 8 | buf[0]);\n      * (uint32_t *) buf = t;\n      buf += 4;\n    } while (--longs);\n  }\n}\n\n#define F1(x, y, z) (z ^ (x & (y ^ z)))\n#define F2(x, y, z) F1(z, x, y)\n#define F3(x, y, z) (x ^ y ^ z)\n#define F4(x, y, z) (y ^ (x | ~z))\n\n#define MD5STEP(f, w, x, y, z, data, s) \\\n  ( w += f(x, y, z) + data,  w = w<<s | w>>(32-s),  w += x )\n\n// Start MD5 accumulation.  Set bit count to 0 and buffer to mysterious\n// initialization constants.\nstatic void MD5Init(MD5_CTX *ctx) {\n  ctx->buf[0] = 0x67452301;\n  ctx->buf[1] = 0xefcdab89;\n  ctx->buf[2] = 0x98badcfe;\n  ctx->buf[3] = 0x10325476;\n\n  ctx->bits[0] = 0;\n  ctx->bits[1] = 0;\n}\n\nstatic void MD5Transform(uint32_t buf[4], uint32_t const in[16]) {\n  register uint32_t a, b, c, d;\n\n  a = buf[0];\n  b = buf[1];\n  c = buf[2];\n  d = buf[3];\n\n  MD5STEP(F1, a, b, c, d, in[0] + 0xd76aa478, 7);\n  MD5STEP(F1, d, a, b, c, in[1] + 0xe8c7b756, 12);\n  MD5STEP(F1, c, d, a, b, in[2] + 0x242070db, 17);\n  MD5STEP(F1, b, c, d, a, in[3] + 0xc1bdceee, 22);\n  MD5STEP(F1, a, b, c, d, in[4] + 0xf57c0faf, 7);\n  MD5STEP(F1, d, a, b, c, in[5] + 0x4787c62a, 12);\n  MD5STEP(F1, c, d, a, b, in[6] + 0xa8304613, 17);\n  MD5STEP(F1, b, c, d, a, in[7] + 0xfd469501, 22);\n  MD5STEP(F1, a, b, c, d, in[8] + 0x698098d8, 7);\n  MD5STEP(F1, d, a, b, c, in[9] + 0x8b44f7af, 12);\n  MD5STEP(F1, c, d, a, b, in[10] + 0xffff5bb1, 17);\n  MD5STEP(F1, b, c, d, a, in[11] + 0x895cd7be, 22);\n  MD5STEP(F1, a, b, c, d, in[12] + 0x6b901122, 7);\n  MD5STEP(F1, d, a, b, c, in[13] + 0xfd987193, 12);\n  MD5STEP(F1, c, d, a, b, in[14] + 0xa679438e, 17);\n  MD5STEP(F1, b, c, d, a, in[15] + 0x49b40821, 22);\n\n  MD5STEP(F2, a, b, c, d, in[1] + 0xf61e2562, 5);\n  MD5STEP(F2, d, a, b, c, in[6] + 0xc040b340, 9);\n  MD5STEP(F2, c, d, a, b, in[11] + 0x265e5a51, 14);\n  MD5STEP(F2, b, c, d, a, in[0] + 0xe9b6c7aa, 20);\n  MD5STEP(F2, a, b, c, d, in[5] + 0xd62f105d, 5);\n  MD5STEP(F2, d, a, b, c, in[10] + 0x02441453, 9);\n  MD5STEP(F2, c, d, a, b, in[15] + 0xd8a1e681, 14);\n  MD5STEP(F2, b, c, d, a, in[4] + 0xe7d3fbc8, 20);\n  MD5STEP(F2, a, b, c, d, in[9] + 0x21e1cde6, 5);\n  MD5STEP(F2, d, a, b, c, in[14] + 0xc33707d6, 9);\n  MD5STEP(F2, c, d, a, b, in[3] + 0xf4d50d87, 14);\n  MD5STEP(F2, b, c, d, a, in[8] + 0x455a14ed, 20);\n  MD5STEP(F2, a, b, c, d, in[13] + 0xa9e3e905, 5);\n  MD5STEP(F2, d, a, b, c, in[2] + 0xfcefa3f8, 9);\n  MD5STEP(F2, c, d, a, b, in[7] + 0x676f02d9, 14);\n  MD5STEP(F2, b, c, d, a, in[12] + 0x8d2a4c8a, 20);\n\n  MD5STEP(F3, a, b, c, d, in[5] + 0xfffa3942, 4);\n  MD5STEP(F3, d, a, b, c, in[8] + 0x8771f681, 11);\n  MD5STEP(F3, c, d, a, b, in[11] + 0x6d9d6122, 16);\n  MD5STEP(F3, b, c, d, a, in[14] + 0xfde5380c, 23);\n  MD5STEP(F3, a, b, c, d, in[1] + 0xa4beea44, 4);\n  MD5STEP(F3, d, a, b, c, in[4] + 0x4bdecfa9, 11);\n  MD5STEP(F3, c, d, a, b, in[7] + 0xf6bb4b60, 16);\n  MD5STEP(F3, b, c, d, a, in[10] + 0xbebfbc70, 23);\n  MD5STEP(F3, a, b, c, d, in[13] + 0x289b7ec6, 4);\n  MD5STEP(F3, d, a, b, c, in[0] + 0xeaa127fa, 11);\n  MD5STEP(F3, c, d, a, b, in[3] + 0xd4ef3085, 16);\n  MD5STEP(F3, b, c, d, a, in[6] + 0x04881d05, 23);\n  MD5STEP(F3, a, b, c, d, in[9] + 0xd9d4d039, 4);\n  MD5STEP(F3, d, a, b, c, in[12] + 0xe6db99e5, 11);\n  MD5STEP(F3, c, d, a, b, in[15] + 0x1fa27cf8, 16);\n  MD5STEP(F3, b, c, d, a, in[2] + 0xc4ac5665, 23);\n\n  MD5STEP(F4, a, b, c, d, in[0] + 0xf4292244, 6);\n  MD5STEP(F4, d, a, b, c, in[7] + 0x432aff97, 10);\n  MD5STEP(F4, c, d, a, b, in[14] + 0xab9423a7, 15);\n  MD5STEP(F4, b, c, d, a, in[5] + 0xfc93a039, 21);\n  MD5STEP(F4, a, b, c, d, in[12] + 0x655b59c3, 6);\n  MD5STEP(F4, d, a, b, c, in[3] + 0x8f0ccc92, 10);\n  MD5STEP(F4, c, d, a, b, in[10] + 0xffeff47d, 15);\n  MD5STEP(F4, b, c, d, a, in[1] + 0x85845dd1, 21);\n  MD5STEP(F4, a, b, c, d, in[8] + 0x6fa87e4f, 6);\n  MD5STEP(F4, d, a, b, c, in[15] + 0xfe2ce6e0, 10);\n  MD5STEP(F4, c, d, a, b, in[6] + 0xa3014314, 15);\n  MD5STEP(F4, b, c, d, a, in[13] + 0x4e0811a1, 21);\n  MD5STEP(F4, a, b, c, d, in[4] + 0xf7537e82, 6);\n  MD5STEP(F4, d, a, b, c, in[11] + 0xbd3af235, 10);\n  MD5STEP(F4, c, d, a, b, in[2] + 0x2ad7d2bb, 15);\n  MD5STEP(F4, b, c, d, a, in[9] + 0xeb86d391, 21);\n\n  buf[0] += a;\n  buf[1] += b;\n  buf[2] += c;\n  buf[3] += d;\n}\n\nstatic void MD5Update(MD5_CTX *ctx, unsigned char const *buf, unsigned len) {\n  uint32_t t;\n\n  t = ctx->bits[0];\n  if ((ctx->bits[0] = t + ((uint32_t) len << 3)) < t)\n    ctx->bits[1]++;\n  ctx->bits[1] += len >> 29;\n\n  t = (t >> 3) & 0x3f;\n\n  if (t) {\n    unsigned char *p = (unsigned char *) ctx->in + t;\n\n    t = 64 - t;\n    if (len < t) {\n      memcpy(p, buf, len);\n      return;\n    }\n    memcpy(p, buf, t);\n    byteReverse(ctx->in, 16);\n    MD5Transform(ctx->buf, (uint32_t *) ctx->in);\n    buf += t;\n    len -= t;\n  }\n\n  while (len >= 64) {\n    memcpy(ctx->in, buf, 64);\n    byteReverse(ctx->in, 16);\n    MD5Transform(ctx->buf, (uint32_t *) ctx->in);\n    buf += 64;\n    len -= 64;\n  }\n\n  memcpy(ctx->in, buf, len);\n}\n\nstatic void MD5Final(unsigned char digest[16], MD5_CTX *ctx) {\n  unsigned count;\n  unsigned char *p;\n  uint32_t *a;\n\n  count = (ctx->bits[0] >> 3) & 0x3F;\n\n  p = ctx->in + count;\n  *p++ = 0x80;\n  count = 64 - 1 - count;\n  if (count < 8) {\n    memset(p, 0, count);\n    byteReverse(ctx->in, 16);\n    MD5Transform(ctx->buf, (uint32_t *) ctx->in);\n    memset(ctx->in, 0, 56);\n  } else {\n    memset(p, 0, count - 8);\n  }\n  byteReverse(ctx->in, 14);\n\n  a = (uint32_t *)ctx->in;\n  a[14] = ctx->bits[0];\n  a[15] = ctx->bits[1];\n\n  MD5Transform(ctx->buf, (uint32_t *) ctx->in);\n  byteReverse((unsigned char *) ctx->buf, 4);\n  memcpy(digest, ctx->buf, 16);\n  memset((char *) ctx, 0, sizeof(*ctx));\n}\n#endif // !HAVE_MD5\n\n\n\n// Stringify binary data. Output buffer must be twice as big as input,\n// because each byte takes 2 bytes in string representation\nstatic void bin2str(char *to, const unsigned char *p, size_t len) {\n  static const char *hex = \"0123456789abcdef\";\n\n  for (; len--; p++) {\n    *to++ = hex[p[0] >> 4];\n    *to++ = hex[p[0] & 0x0f];\n  }\n  *to = '\\0';\n}\n\n// Return stringified MD5 hash for list of strings. Buffer must be 33 bytes.\nchar *mg_md5(char buf[33], ...) {\n  unsigned char hash[16];\n  const char *p;\n  va_list ap;\n  MD5_CTX ctx;\n\n  MD5Init(&ctx);\n\n  va_start(ap, buf);\n  while ((p = va_arg(ap, const char *)) != NULL) {\n    MD5Update(&ctx, (const unsigned char *) p, (unsigned) strlen(p));\n  }\n  va_end(ap);\n\n  MD5Final(hash, &ctx);\n  bin2str(buf, hash, sizeof(hash));\n  return buf;\n}\n\n// Check the user's password, return 1 if OK\nstatic int check_password(const char *method, const char *ha1, const char *uri,\n                          const char *nonce, const char *nc, const char *cnonce,\n                          const char *qop, const char *response) {\n  char ha2[32 + 1], expected_response[32 + 1];\n\n  // Some of the parameters may be NULL\n  if (method == NULL || nonce == NULL || nc == NULL || cnonce == NULL ||\n      qop == NULL || response == NULL) {\n    return 0;\n  }\n\n  // NOTE(lsm): due to a bug in MSIE, we do not compare the URI\n  // TODO(lsm): check for authentication timeout\n  if (// strcmp(dig->uri, c->ouri) != 0 ||\n      strlen(response) != 32\n      // || now - strtoul(dig->nonce, NULL, 10) > 3600\n      ) {\n    return 0;\n  }\n\n  mg_md5(ha2, method, \":\", uri, NULL);\n  mg_md5(expected_response, ha1, \":\", nonce, \":\", nc,\n      \":\", cnonce, \":\", qop, \":\", ha2, NULL);\n\n  return mg_strcasecmp(response, expected_response) == 0;\n}\n\n// Use the global passwords file, if specified by auth_gpass option,\n// or search for .htpasswd in the requested directory.\nstatic FILE *open_auth_file(struct mg_connection *conn, const char *path) {\n  char name[PATH_MAX];\n  const char *p, *e, *gpass = conn->ctx->config[GLOBAL_PASSWORDS_FILE];\n  struct file file = STRUCT_FILE_INITIALIZER;\n  FILE *fp = NULL;\n\n  if (gpass != NULL) {\n    // Use global passwords file\n    fp = mg_fopen(gpass, \"r\");\n    // Important: using local struct file to test path for is_directory flag.\n    // If filep is used, mg_stat() makes it appear as if auth file was opened.\n  } else if (mg_stat(path, &file) && file.is_directory) {\n    mg_snprintf(name, sizeof(name), \"%s%c%s\",\n                path, '/', PASSWORDS_FILE_NAME);\n    fp = mg_fopen(name, \"r\");\n  } else {\n     // Try to find .htpasswd in requested directory.\n    for (p = path, e = p + strlen(p) - 1; e > p; e--)\n      if (e[0] == '/')\n        break;\n    mg_snprintf(name, sizeof(name), \"%.*s%c%s\",\n                (int) (e - p), p, '/', PASSWORDS_FILE_NAME);\n    fp = mg_fopen(name, \"r\");\n  }\n\n  return fp;\n}\n\n// Parsed Authorization header\nstruct ah {\n  char *user, *uri, *cnonce, *response, *qop, *nc, *nonce;\n};\n\n// Return 1 on success. Always initializes the ah structure.\nstatic int parse_auth_header(struct mg_connection *conn, char *buf,\n                             size_t buf_size, struct ah *ah) {\n  char *name, *value, *s;\n  const char *auth_header;\n\n  (void) memset(ah, 0, sizeof(*ah));\n  if ((auth_header = mg_get_header(conn, \"Authorization\")) == NULL ||\n      mg_strncasecmp(auth_header, \"Digest \", 7) != 0) {\n    return 0;\n  }\n\n  // Make modifiable copy of the auth header\n  (void) mg_strlcpy(buf, auth_header + 7, buf_size);\n  s = buf;\n\n  // Parse authorization header\n  for (;;) {\n    // Gobble initial spaces\n    while (isspace(* (unsigned char *) s)) {\n      s++;\n    }\n    name = skip_quoted(&s, \"=\", \" \", 0);\n    // Value is either quote-delimited, or ends at first comma or space.\n    if (s[0] == '\\\"') {\n      s++;\n      value = skip_quoted(&s, \"\\\"\", \" \", '\\\\');\n      if (s[0] == ',') {\n        s++;\n      }\n    } else {\n      value = skip_quoted(&s, \", \", \" \", 0);  // IE uses commas, FF uses spaces\n    }\n    if (*name == '\\0') {\n      break;\n    }\n\n    if (!strcmp(name, \"username\")) {\n      ah->user = value;\n    } else if (!strcmp(name, \"cnonce\")) {\n      ah->cnonce = value;\n    } else if (!strcmp(name, \"response\")) {\n      ah->response = value;\n    } else if (!strcmp(name, \"uri\")) {\n      ah->uri = value;\n    } else if (!strcmp(name, \"qop\")) {\n      ah->qop = value;\n    } else if (!strcmp(name, \"nc\")) {\n      ah->nc = value;\n    } else if (!strcmp(name, \"nonce\")) {\n      ah->nonce = value;\n    }\n  }\n\n  // CGI needs it as REMOTE_USER\n  if (ah->user != NULL) {\n    conn->request_info.remote_user = mg_strdup(ah->user);\n  } else {\n    return 0;\n  }\n\n  return 1;\n}\n\n// Authorize against the opened passwords file. Return 1 if authorized.\nstatic int authorize(struct mg_connection *conn, FILE *fp) {\n  struct ah ah;\n  char line[256], f_user[256], ha1[256], f_domain[256], buf[MG_BUF_LEN];\n\n  if (!parse_auth_header(conn, buf, sizeof(buf), &ah)) {\n    return 0;\n  }\n\n  // Loop over passwords file\n  while (fgets(line, sizeof(line), fp) != NULL) {\n    if (sscanf(line, \"%[^:]:%[^:]:%s\", f_user, f_domain, ha1) != 3) {\n      continue;\n    }\n\n    if (!strcmp(ah.user, f_user) &&\n        !strcmp(conn->ctx->config[AUTHENTICATION_DOMAIN], f_domain))\n      return check_password(conn->request_info.request_method, ha1, ah.uri,\n                            ah.nonce, ah.nc, ah.cnonce, ah.qop, ah.response);\n  }\n\n  return 0;\n}\n\n// Return 1 if request is authorised, 0 otherwise.\nstatic int check_authorization(struct mg_connection *conn, const char *path) {\n  char fname[PATH_MAX];\n  struct vec uri_vec, filename_vec;\n  const char *list;\n  FILE *fp = NULL;\n  int authorized = 1;\n\n  list = conn->ctx->config[PROTECT_URI];\n  while ((list = next_option(list, &uri_vec, &filename_vec)) != NULL) {\n    if (!memcmp(conn->request_info.uri, uri_vec.ptr, uri_vec.len)) {\n      mg_snprintf(fname, sizeof(fname), \"%.*s\",\n                  (int) filename_vec.len, filename_vec.ptr);\n      fp = mg_fopen(fname, \"r\");\n      break;\n    }\n  }\n\n  if (fp == NULL) {\n    fp = open_auth_file(conn, path);\n  }\n\n  if (fp != NULL) {\n    authorized = authorize(conn, fp);\n    fclose(fp);\n  }\n\n  return authorized;\n}\n\nstatic void send_authorization_request(struct mg_connection *conn) {\n  conn->status_code = 401;\n  mg_printf(conn,\n            \"HTTP/1.1 401 Unauthorized\\r\\n\"\n            \"Content-Length: 0\\r\\n\"\n            \"WWW-Authenticate: Digest qop=\\\"auth\\\", \"\n            \"realm=\\\"%s\\\", nonce=\\\"%lu\\\"\\r\\n\\r\\n\",\n            conn->ctx->config[AUTHENTICATION_DOMAIN],\n            (unsigned long) time(NULL));\n}\n\nstatic int is_authorized_for_put(struct mg_connection *conn) {\n  const char *passfile = conn->ctx->config[PUT_DELETE_PASSWORDS_FILE];\n  FILE *fp;\n  int ret = 0;\n\n  if (passfile != NULL && (fp = mg_fopen(passfile, \"r\")) != NULL) {\n    ret = authorize(conn, fp);\n    fclose(fp);\n  }\n\n  return ret;\n}\n\nint mg_modify_passwords_file(const char *fname, const char *domain,\n                             const char *user, const char *pass) {\n  int found;\n  char line[512], u[512], d[512], ha1[33], tmp[PATH_MAX];\n  FILE *fp, *fp2;\n\n  found = 0;\n  fp = fp2 = NULL;\n\n  // Regard empty password as no password - remove user record.\n  if (pass != NULL && pass[0] == '\\0') {\n    pass = NULL;\n  }\n\n  (void) snprintf(tmp, sizeof(tmp), \"%s.tmp\", fname);\n\n  // Create the file if does not exist\n  if ((fp = fopen(fname, \"a+\")) != NULL) {\n    fclose(fp);\n  }\n\n  // Open the given file and temporary file\n  if ((fp = fopen(fname, \"r\")) == NULL) {\n    return 0;\n  } else if ((fp2 = fopen(tmp, \"w+\")) == NULL) {\n    fclose(fp);\n    return 0;\n  }\n\n  // Copy the stuff to temporary file\n  while (fgets(line, sizeof(line), fp) != NULL) {\n    if (sscanf(line, \"%[^:]:%[^:]:%*s\", u, d) != 2) {\n      continue;\n    }\n\n    if (!strcmp(u, user) && !strcmp(d, domain)) {\n      found++;\n      if (pass != NULL) {\n        mg_md5(ha1, user, \":\", domain, \":\", pass, NULL);\n        fprintf(fp2, \"%s:%s:%s\\n\", user, domain, ha1);\n      }\n    } else {\n      fprintf(fp2, \"%s\", line);\n    }\n  }\n\n  // If new user, just add it\n  if (!found && pass != NULL) {\n    mg_md5(ha1, user, \":\", domain, \":\", pass, NULL);\n    fprintf(fp2, \"%s:%s:%s\\n\", user, domain, ha1);\n  }\n\n  // Close files\n  fclose(fp);\n  fclose(fp2);\n\n  // Put the temp file in place of real file\n  remove(fname);\n  rename(tmp, fname);\n\n  return 1;\n}\n\n#if defined(_WIN32)\nstatic pthread_t pthread_self(void) {\n  return GetCurrentThreadId();\n}\n\nstatic int pthread_mutex_init(pthread_mutex_t *mutex, void *unused) {\n  (void) unused;\n  *mutex = CreateMutex(NULL, FALSE, NULL);\n  return *mutex == NULL ? -1 : 0;\n}\n\nstatic int pthread_mutex_destroy(pthread_mutex_t *mutex) {\n  return CloseHandle(*mutex) == 0 ? -1 : 0;\n}\n\nstatic int pthread_mutex_lock(pthread_mutex_t *mutex) {\n  return WaitForSingleObject(*mutex, INFINITE) == WAIT_OBJECT_0? 0 : -1;\n}\n\nstatic int pthread_mutex_unlock(pthread_mutex_t *mutex) {\n  return ReleaseMutex(*mutex) == 0 ? -1 : 0;\n}\n\nstatic int pthread_cond_init(pthread_cond_t *cv, const void *unused) {\n  (void) unused;\n  cv->signal = CreateEvent(NULL, FALSE, FALSE, NULL);\n  cv->broadcast = CreateEvent(NULL, TRUE, FALSE, NULL);\n  return cv->signal != NULL && cv->broadcast != NULL ? 0 : -1;\n}\n\nstatic int pthread_cond_wait(pthread_cond_t *cv, pthread_mutex_t *mutex) {\n  HANDLE handles[] = {cv->signal, cv->broadcast};\n  ReleaseMutex(*mutex);\n  WaitForMultipleObjects(2, handles, FALSE, INFINITE);\n  return WaitForSingleObject(*mutex, INFINITE) == WAIT_OBJECT_0? 0 : -1;\n}\n\nstatic int pthread_cond_signal(pthread_cond_t *cv) {\n  return SetEvent(cv->signal) == 0 ? -1 : 0;\n}\n\nstatic int pthread_cond_broadcast(pthread_cond_t *cv) {\n  // Implementation with PulseEvent() has race condition, see\n  // http://www.cs.wustl.edu/~schmidt/win32-cv-1.html\n  return PulseEvent(cv->broadcast) == 0 ? -1 : 0;\n}\n\nstatic int pthread_cond_destroy(pthread_cond_t *cv) {\n  return CloseHandle(cv->signal) && CloseHandle(cv->broadcast) ? 0 : -1;\n}\n\n// For Windows, change all slashes to backslashes in path names.\nstatic void change_slashes_to_backslashes(char *path) {\n  int i;\n\n  for (i = 0; path[i] != '\\0'; i++) {\n    if (path[i] == '/')\n      path[i] = '\\\\';\n    // i > 0 check is to preserve UNC paths, like \\\\server\\file.txt\n    if (path[i] == '\\\\' && i > 0)\n      while (path[i + 1] == '\\\\' || path[i + 1] == '/')\n        (void) memmove(path + i + 1,\n            path + i + 2, strlen(path + i + 1));\n  }\n}\n\n// Encode 'path' which is assumed UTF-8 string, into UNICODE string.\n// wbuf and wbuf_len is a target buffer and its length.\nstatic void to_unicode(const char *path, wchar_t *wbuf, size_t wbuf_len) {\n  char buf[PATH_MAX * 2], buf2[PATH_MAX * 2];\n\n  mg_strlcpy(buf, path, sizeof(buf));\n  change_slashes_to_backslashes(buf);\n\n  // Convert to Unicode and back. If doubly-converted string does not\n  // match the original, something is fishy, reject.\n  memset(wbuf, 0, wbuf_len * sizeof(wchar_t));\n  MultiByteToWideChar(CP_UTF8, 0, buf, -1, wbuf, (int) wbuf_len);\n  WideCharToMultiByte(CP_UTF8, 0, wbuf, (int) wbuf_len, buf2, sizeof(buf2),\n                      NULL, NULL);\n  if (strcmp(buf, buf2) != 0) {\n    wbuf[0] = L'\\0';\n  }\n}\n\n#if defined(_WIN32_WCE)\nstatic time_t time(time_t *ptime) {\n  time_t t;\n  SYSTEMTIME st;\n  FILETIME ft;\n\n  GetSystemTime(&st);\n  SystemTimeToFileTime(&st, &ft);\n  t = SYS2UNIX_TIME(ft.dwLowDateTime, ft.dwHighDateTime);\n\n  if (ptime != NULL) {\n    *ptime = t;\n  }\n\n  return t;\n}\n\nstatic struct tm *localtime(const time_t *ptime, struct tm *ptm) {\n  int64_t t = ((int64_t) *ptime) * RATE_DIFF + EPOCH_DIFF;\n  FILETIME ft, lft;\n  SYSTEMTIME st;\n  TIME_ZONE_INFORMATION tzinfo;\n\n  if (ptm == NULL) {\n    return NULL;\n  }\n\n  * (int64_t *) &ft = t;\n  FileTimeToLocalFileTime(&ft, &lft);\n  FileTimeToSystemTime(&lft, &st);\n  ptm->tm_year = st.wYear - 1900;\n  ptm->tm_mon = st.wMonth - 1;\n  ptm->tm_wday = st.wDayOfWeek;\n  ptm->tm_mday = st.wDay;\n  ptm->tm_hour = st.wHour;\n  ptm->tm_min = st.wMinute;\n  ptm->tm_sec = st.wSecond;\n  ptm->tm_yday = 0; // hope nobody uses this\n  ptm->tm_isdst =\n    GetTimeZoneInformation(&tzinfo) == TIME_ZONE_ID_DAYLIGHT ? 1 : 0;\n\n  return ptm;\n}\n\nstatic struct tm *gmtime(const time_t *ptime, struct tm *ptm) {\n  // FIXME(lsm): fix this.\n  return localtime(ptime, ptm);\n}\n\nstatic size_t strftime(char *dst, size_t dst_size, const char *fmt,\n                       const struct tm *tm) {\n  (void) snprintf(dst, dst_size, \"implement strftime() for WinCE\");\n  return 0;\n}\n#endif\n\n// Windows happily opens files with some garbage at the end of file name.\n// For example, fopen(\"a.cgi    \", \"r\") on Windows successfully opens\n// \"a.cgi\", despite one would expect an error back.\n// This function returns non-0 if path ends with some garbage.\nstatic int path_cannot_disclose_cgi(const char *path) {\n  static const char *allowed_last_characters = \"_-\";\n  int last = path[strlen(path) - 1];\n  return isalnum(last) || strchr(allowed_last_characters, last) != NULL;\n}\n\nstatic int mg_stat(const char *path, struct file *filep) {\n  wchar_t wbuf[PATH_MAX] = L\"\\\\\\\\?\\\\\";\n  WIN32_FILE_ATTRIBUTE_DATA info;\n\n  filep->modification_time = 0;\n  to_unicode(path, wbuf + 4, ARRAY_SIZE(wbuf) - 4);\n  if (GetFileAttributesExW(wbuf, GetFileExInfoStandard, &info) != 0) {\n    filep->size = MAKEUQUAD(info.nFileSizeLow, info.nFileSizeHigh);\n    filep->modification_time = SYS2UNIX_TIME(\n        info.ftLastWriteTime.dwLowDateTime,\n        info.ftLastWriteTime.dwHighDateTime);\n    filep->is_directory = info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY;\n    // If file name is fishy, reset the file structure and return error.\n    // Note it is important to reset, not just return the error, cause\n    // functions like is_file_opened() check the struct.\n    if (!filep->is_directory && !path_cannot_disclose_cgi(path)) {\n      memset(filep, 0, sizeof(*filep));\n    }\n  }\n\n  return filep->modification_time != 0;\n}\n\nstatic int mg_remove(const char *path) {\n  wchar_t wbuf[PATH_MAX];\n  to_unicode(path, wbuf, ARRAY_SIZE(wbuf));\n  return DeleteFileW(wbuf) ? 0 : -1;\n}\n\nstatic int mg_mkdir(const char *path, int mode) {\n  char buf[PATH_MAX];\n  wchar_t wbuf[PATH_MAX];\n\n  (void) mode;\n  mg_strlcpy(buf, path, sizeof(buf));\n  change_slashes_to_backslashes(buf);\n\n  (void) MultiByteToWideChar(CP_UTF8, 0, buf, -1, wbuf, ARRAY_SIZE(wbuf));\n\n  return CreateDirectoryW(wbuf, NULL) ? 0 : -1;\n}\n\n// Implementation of POSIX opendir/closedir/readdir for Windows.\nstatic DIR * opendir(const char *name) {\n  DIR *dir = NULL;\n  wchar_t wpath[PATH_MAX];\n  DWORD attrs;\n\n  if (name == NULL) {\n    SetLastError(ERROR_BAD_ARGUMENTS);\n  } else if ((dir = (DIR *) malloc(sizeof(*dir))) == NULL) {\n    SetLastError(ERROR_NOT_ENOUGH_MEMORY);\n  } else {\n    to_unicode(name, wpath, ARRAY_SIZE(wpath));\n    attrs = GetFileAttributesW(wpath);\n    if (attrs != 0xFFFFFFFF &&\n        ((attrs & FILE_ATTRIBUTE_DIRECTORY) == FILE_ATTRIBUTE_DIRECTORY)) {\n      (void) wcscat(wpath, L\"\\\\*\");\n      dir->handle = FindFirstFileW(wpath, &dir->info);\n      dir->result.d_name[0] = '\\0';\n    } else {\n      free(dir);\n      dir = NULL;\n    }\n  }\n\n  return dir;\n}\n\nstatic int closedir(DIR *dir) {\n  int result = 0;\n\n  if (dir != NULL) {\n    if (dir->handle != INVALID_HANDLE_VALUE)\n      result = FindClose(dir->handle) ? 0 : -1;\n\n    free(dir);\n  } else {\n    result = -1;\n    SetLastError(ERROR_BAD_ARGUMENTS);\n  }\n\n  return result;\n}\n\nstatic struct dirent *readdir(DIR *dir) {\n  struct dirent *result = 0;\n\n  if (dir) {\n    if (dir->handle != INVALID_HANDLE_VALUE) {\n      result = &dir->result;\n      (void) WideCharToMultiByte(CP_UTF8, 0,\n          dir->info.cFileName, -1, result->d_name,\n          sizeof(result->d_name), NULL, NULL);\n\n      if (!FindNextFileW(dir->handle, &dir->info)) {\n        (void) FindClose(dir->handle);\n        dir->handle = INVALID_HANDLE_VALUE;\n      }\n\n    } else {\n      SetLastError(ERROR_FILE_NOT_FOUND);\n    }\n  } else {\n    SetLastError(ERROR_BAD_ARGUMENTS);\n  }\n\n  return result;\n}\n\n#ifndef HAVE_POLL\nstatic int poll(struct pollfd *pfd, int n, int milliseconds) {\n  struct timeval tv;\n  fd_set set;\n  int i, result;\n  SOCKET maxfd = 0;\n\n  tv.tv_sec = milliseconds / 1000;\n  tv.tv_usec = (milliseconds % 1000) * 1000;\n  FD_ZERO(&set);\n\n  for (i = 0; i < n; i++) {\n    FD_SET((SOCKET) pfd[i].fd, &set);\n    pfd[i].revents = 0;\n\n    if (pfd[i].fd > maxfd) {\n        maxfd = pfd[i].fd;\n    }\n  }\n\n  if ((result = select(maxfd + 1, &set, NULL, NULL, &tv)) > 0) {\n    for (i = 0; i < n; i++) {\n      if (FD_ISSET(pfd[i].fd, &set)) {\n        pfd[i].revents = POLLIN;\n      }\n    }\n  }\n\n  return result;\n}\n#endif // HAVE_POLL\n\nstatic void set_close_on_exec(SOCKET sock) {\n  (void) SetHandleInformation((HANDLE) sock, HANDLE_FLAG_INHERIT, 0);\n}\n\nint mg_start_thread(mg_thread_func_t f, void *p) {\n  return (long)_beginthread((void (__cdecl *)(void *)) f, 0, p) == -1L ? -1 : 0;\n}\n\nstatic HANDLE dlopen(const char *dll_name, int flags) {\n  wchar_t wbuf[PATH_MAX];\n  (void) flags;\n  to_unicode(dll_name, wbuf, ARRAY_SIZE(wbuf));\n  return LoadLibraryW(wbuf);\n}\n\n#if !defined(NO_CGI)\n#define SIGKILL 0\nstatic int kill(pid_t pid, int sig_num) {\n  (void) TerminateProcess(pid, sig_num);\n  (void) CloseHandle(pid);\n  return 0;\n}\n\nstatic void trim_trailing_whitespaces(char *s) {\n  char *e = s + strlen(s) - 1;\n  while (e > s && isspace(* (unsigned char *) e)) {\n    *e-- = '\\0';\n  }\n}\n\nstatic pid_t spawn_process(struct mg_connection *conn, const char *prog,\n                           char *envblk, char *envp[], int fdin,\n                           int fdout, const char *dir) {\n  HANDLE me;\n  char *interp, full_interp[PATH_MAX], full_dir[PATH_MAX],\n       cmdline[PATH_MAX], buf[PATH_MAX];\n  FILE *fp;\n  STARTUPINFOA si;\n  PROCESS_INFORMATION pi = { 0 };\n\n  (void) envp;\n\n  memset(&si, 0, sizeof(si));\n  si.cb = sizeof(si);\n\n  // TODO(lsm): redirect CGI errors to the error log file\n  si.dwFlags = STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;\n  si.wShowWindow = SW_HIDE;\n\n  me = GetCurrentProcess();\n  DuplicateHandle(me, (HANDLE) _get_osfhandle(fdin), me,\n                  &si.hStdInput, 0, TRUE, DUPLICATE_SAME_ACCESS);\n  DuplicateHandle(me, (HANDLE) _get_osfhandle(fdout), me,\n                  &si.hStdOutput, 0, TRUE, DUPLICATE_SAME_ACCESS);\n\n  // If CGI file is a script, try to read the interpreter line\n  interp = conn->ctx->config[CGI_INTERPRETER];\n  if (interp == NULL) {\n    buf[0] = buf[1] = '\\0';\n\n    // Read the first line of the script into the buffer\n    snprintf(cmdline, sizeof(cmdline), \"%s%c%s\", dir, '/', prog);\n    if ((fp = mg_fopen(cmdline, \"r\")) != NULL) {\n      fgets(buf, sizeof(buf), fp);\n      fclose(fp);\n      buf[sizeof(buf) - 1] = '\\0';\n    }\n\n    if (buf[0] == '#' && buf[1] == '!') {\n      trim_trailing_whitespaces(buf + 2);\n    } else {\n      buf[2] = '\\0';\n    }\n    interp = buf + 2;\n  }\n\n  if (interp[0] != '\\0') {\n    GetFullPathNameA(interp, sizeof(full_interp), full_interp, NULL);\n    interp = full_interp;\n  }\n  GetFullPathNameA(dir, sizeof(full_dir), full_dir, NULL);\n\n  mg_snprintf(cmdline, sizeof(cmdline), \"%s%s\\\"%s\\\\%s\\\"\",\n              interp, interp[0] == '\\0' ? \"\" : \" \", full_dir, prog);\n\n  DEBUG_TRACE((\"Running [%s]\", cmdline));\n  if (CreateProcessA(NULL, cmdline, NULL, NULL, TRUE,\n        CREATE_NEW_PROCESS_GROUP, envblk, NULL, &si, &pi) == 0) {\n    cry(conn, \"%s: CreateProcess(%s): %ld\",\n        __func__, cmdline, ERRNO);\n    pi.hProcess = (pid_t) -1;\n  }\n\n  (void) CloseHandle(si.hStdOutput);\n  (void) CloseHandle(si.hStdInput);\n  (void) CloseHandle(pi.hThread);\n\n  return (pid_t) pi.hProcess;\n}\n#endif // !NO_CGI\n\nstatic int set_non_blocking_mode(SOCKET sock) {\n  unsigned long on = 1;\n  return ioctlsocket(sock, FIONBIO, &on);\n}\n#endif\n\n#if !defined(_WIN32)\nstatic int mg_stat(const char *path, struct file *filep) {\n  struct stat st;\n\n  filep->modification_time = (time_t) 0;\n  if (stat(path, &st) == 0) {\n    filep->size = st.st_size;\n    filep->modification_time = st.st_mtime;\n    filep->is_directory = S_ISDIR(st.st_mode);\n\n    // See https://github.com/cesanta/mongoose/issues/109\n    // Some filesystems report modification time as 0. Artificially\n    // bump it up to mark mg_stat() success.\n    if (filep->modification_time == (time_t) 0) {\n      filep->modification_time = (time_t) 1;\n    }\n  }\n\n  return filep->modification_time != (time_t) 0;\n}\n\nstatic void set_close_on_exec(int fd) {\n  fcntl(fd, F_SETFD, FD_CLOEXEC);\n}\n\nint mg_start_thread(mg_thread_func_t func, void *param) {\n  pthread_t thread_id;\n  pthread_attr_t attr;\n  int result;\n\n  (void) pthread_attr_init(&attr);\n  (void) pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n\n#if USE_STACK_SIZE > 1\n  // Compile-time option to control stack size, e.g. -DUSE_STACK_SIZE=16384\n  (void) pthread_attr_setstacksize(&attr, USE_STACK_SIZE);\n#endif\n\n  result = pthread_create(&thread_id, &attr, func, param);\n  pthread_attr_destroy(&attr);\n\n  return result;\n}\n\n#ifndef NO_CGI\nstatic pid_t spawn_process(struct mg_connection *conn, const char *prog,\n                           char *envblk, char *envp[], int fdin,\n                           int fdout, const char *dir) {\n  pid_t pid;\n  const char *interp;\n\n  (void) envblk;\n\n  if ((pid = fork()) == -1) {\n    // Parent\n    send_http_error(conn, 500, http_500_error, \"fork(): %s\", strerror(ERRNO));\n  } else if (pid == 0) {\n    // Child\n    if (chdir(dir) != 0) {\n      cry(conn, \"%s: chdir(%s): %s\", __func__, dir, strerror(ERRNO));\n    } else if (dup2(fdin, 0) == -1) {\n      cry(conn, \"%s: dup2(%d, 0): %s\", __func__, fdin, strerror(ERRNO));\n    } else if (dup2(fdout, 1) == -1) {\n      cry(conn, \"%s: dup2(%d, 1): %s\", __func__, fdout, strerror(ERRNO));\n    } else {\n      // Not redirecting stderr to stdout, to avoid output being littered\n      // with the error messages.\n      (void) close(fdin);\n      (void) close(fdout);\n\n      // After exec, all signal handlers are restored to their default values,\n      // with one exception of SIGCHLD. According to POSIX.1-2001 and Linux's\n      // implementation, SIGCHLD's handler will leave unchanged after exec\n      // if it was set to be ignored. Restore it to default action.\n      signal(SIGCHLD, SIG_DFL);\n\n      interp = conn->ctx->config[CGI_INTERPRETER];\n      if (interp == NULL) {\n        (void) execle(prog, prog, NULL, envp);\n        cry(conn, \"%s: execle(%s): %s\", __func__, prog, strerror(ERRNO));\n      } else {\n        (void) execle(interp, interp, prog, NULL, envp);\n        cry(conn, \"%s: execle(%s %s): %s\", __func__, interp, prog,\n            strerror(ERRNO));\n      }\n    }\n    exit(EXIT_FAILURE);\n  }\n\n  return pid;\n}\n#endif // !NO_CGI\n\nstatic int set_non_blocking_mode(SOCKET sock) {\n  int flags;\n\n  flags = fcntl(sock, F_GETFL, 0);\n  (void) fcntl(sock, F_SETFL, flags | O_NONBLOCK);\n\n  return 0;\n}\n#endif // _WIN32\n\n\n// Print message to buffer. If buffer is large enough to hold the message,\n// return buffer. If buffer is to small, allocate large enough buffer on heap,\n// and return allocated buffer.\nstatic int alloc_vprintf(char **buf, size_t size, const char *fmt, va_list ap) {\n  va_list ap_copy;\n  int len;\n\n  // Windows is not standard-compliant, and vsnprintf() returns -1 if\n  // buffer is too small. Also, older versions of msvcrt.dll do not have\n  // _vscprintf().  However, if size is 0, vsnprintf() behaves correctly.\n  // Therefore, we make two passes: on first pass, get required message length.\n  // On second pass, actually print the message.\n  va_copy(ap_copy, ap);\n  len = vsnprintf(NULL, 0, fmt, ap_copy);\n\n  if (len > (int) size &&\n      (size = len + 1) > 0 &&\n      (*buf = (char *) malloc(size)) == NULL) {\n    len = -1;  // Allocation failed, mark failure\n  } else {\n    va_copy(ap_copy, ap);\n    vsnprintf(*buf, size, fmt, ap_copy);\n  }\n\n  return len;\n}\n\nint mg_vprintf(struct mg_connection *conn, const char *fmt, va_list ap) {\n  char mem[MG_BUF_LEN], *buf = mem;\n  int len;\n\n  if ((len = alloc_vprintf(&buf, sizeof(mem), fmt, ap)) > 0) {\n    len = mg_write(conn, buf, (size_t) len);\n  }\n  if (buf != mem && buf != NULL) {\n    free(buf);\n  }\n\n  return len;\n}\n\nint mg_printf(struct mg_connection *conn, const char *fmt, ...) {\n  va_list ap;\n  va_start(ap, fmt);\n  return mg_vprintf(conn, fmt, ap);\n}\n\nstatic int mg_chunked_printf(struct mg_connection *conn, const char *fmt, ...) {\n  char mem[MG_BUF_LEN], *buf = mem;\n  int len;\n\n  va_list ap;\n  va_start(ap, fmt);\n  if ((len = alloc_vprintf(&buf, sizeof(mem), fmt, ap)) > 0) {\n    len = mg_printf(conn, \"%X\\r\\n%s\\r\\n\", len, buf);\n  }\n\n  if (buf != mem && buf != NULL) {\n    free(buf);\n  }\n\n  return len;\n}\n\n\n\n#if !defined(NO_SSL)\n// set_ssl_option() function updates this array.\n// It loads SSL library dynamically and changes NULLs to the actual addresses\n// of respective functions. The macros above (like SSL_connect()) are really\n// just calling these functions indirectly via the pointer.\nstatic struct ssl_func ssl_sw[] = {\n  {\"SSL_free\",   NULL},\n  {\"SSL_accept\",   NULL},\n  {\"SSL_connect\",   NULL},\n  {\"SSL_read\",   NULL},\n  {\"SSL_write\",   NULL},\n  {\"SSL_get_error\",  NULL},\n  {\"SSL_set_fd\",   NULL},\n  {\"SSL_new\",   NULL},\n  {\"SSL_CTX_new\",   NULL},\n  {\"SSLv23_server_method\", NULL},\n  {\"SSL_library_init\",  NULL},\n  {\"SSL_CTX_use_PrivateKey_file\", NULL},\n  {\"SSL_CTX_use_certificate_file\",NULL},\n  {\"SSL_CTX_set_default_passwd_cb\",NULL},\n  {\"SSL_CTX_free\",  NULL},\n  {\"SSL_load_error_strings\", NULL},\n  {\"SSL_CTX_use_certificate_chain_file\", NULL},\n  {\"SSLv23_client_method\", NULL},\n  {\"SSL_pending\", NULL},\n  {\"SSL_CTX_set_verify\", NULL},\n  {\"SSL_shutdown\",   NULL},\n  {NULL,    NULL}\n};\n\n// Similar array as ssl_sw. These functions could be located in different lib.\nstatic struct ssl_func crypto_sw[] = {\n  {\"CRYPTO_num_locks\",  NULL},\n  {\"CRYPTO_set_locking_callback\", NULL},\n  {\"CRYPTO_set_id_callback\", NULL},\n  {\"ERR_get_error\",  NULL},\n  {\"ERR_error_string\", NULL},\n  {NULL,    NULL}\n};\n\nstatic pthread_mutex_t *ssl_mutexes;\n\nstatic int sslize(struct mg_connection *conn, SSL_CTX *s, int (*func)(SSL *)) {\n  return (conn->ssl = SSL_new(s)) != NULL &&\n    SSL_set_fd(conn->ssl, conn->client.sock) == 1 &&\n    func(conn->ssl) == 1;\n}\n\n// Return OpenSSL error message\nstatic const char *ssl_error(void) {\n  unsigned long err;\n  err = ERR_get_error();\n  return err == 0 ? \"\" : ERR_error_string(err, NULL);\n}\n\nstatic void ssl_locking_callback(int mode, int mutex_num, const char *file,\n                                 int line) {\n  (void) line;\n  (void) file;\n\n  if (mode & 1) {  // 1 is CRYPTO_LOCK\n    (void) pthread_mutex_lock(&ssl_mutexes[mutex_num]);\n  } else {\n    (void) pthread_mutex_unlock(&ssl_mutexes[mutex_num]);\n  }\n}\n\nstatic unsigned long ssl_id_callback(void) {\n  return (unsigned long) pthread_self();\n}\n\n#if !defined(NO_SSL_DL)\nstatic int load_dll(struct mg_context *ctx, const char *dll_name,\n                    struct ssl_func *sw) {\n  union {void *p; void (*fp)(void);} u;\n  void  *dll_handle;\n  struct ssl_func *fp;\n\n  if ((dll_handle = dlopen(dll_name, RTLD_LAZY)) == NULL) {\n    cry(fc(ctx), \"%s: cannot load %s\", __func__, dll_name);\n    return 0;\n  }\n\n  for (fp = sw; fp->name != NULL; fp++) {\n#ifdef _WIN32\n    // GetProcAddress() returns pointer to function\n    u.fp = (void (*)(void)) dlsym(dll_handle, fp->name);\n#else\n    // dlsym() on UNIX returns void *. ISO C forbids casts of data pointers to\n    // function pointers. We need to use a union to make a cast.\n    u.p = dlsym(dll_handle, fp->name);\n#endif // _WIN32\n    if (u.fp == NULL) {\n      cry(fc(ctx), \"%s: %s: cannot find %s\", __func__, dll_name, fp->name);\n      return 0;\n    } else {\n      fp->ptr = u.fp;\n    }\n  }\n\n  return 1;\n}\n#endif // NO_SSL_DL\n\n// Dynamically load SSL library. Set up ctx->ssl_ctx pointer.\nstatic int set_ssl_option(struct mg_context *ctx) {\n  int i, size;\n  const char *pem;\n\n  // If PEM file is not specified and the init_ssl callback\n  // is not specified, skip SSL initialization.\n  if ((pem = ctx->config[SSL_CERTIFICATE]) == NULL) {\n    //  MG_INIT_SSL\n    //  ctx->callbacks.init_ssl == NULL) {\n    return 1;\n  }\n\n#if !defined(NO_SSL_DL)\n  if (!load_dll(ctx, SSL_LIB, ssl_sw) ||\n      !load_dll(ctx, CRYPTO_LIB, crypto_sw)) {\n    return 0;\n  }\n#endif // NO_SSL_DL\n\n  // Initialize SSL library\n  SSL_library_init();\n  SSL_load_error_strings();\n\n  if ((ctx->ssl_ctx = SSL_CTX_new(SSLv23_server_method())) == NULL) {\n    cry(fc(ctx), \"SSL_CTX_new (server) error: %s\", ssl_error());\n    return 0;\n  }\n\n  // If user callback returned non-NULL, that means that user callback has\n  // set up certificate itself. In this case, skip sertificate setting.\n  // MG_INIT_SSL\n  if (SSL_CTX_use_certificate_file(ctx->ssl_ctx, pem, 1) == 0 ||\n      SSL_CTX_use_PrivateKey_file(ctx->ssl_ctx, pem, 1) == 0) {\n    cry(fc(ctx), \"%s: cannot open %s: %s\", __func__, pem, ssl_error());\n    return 0;\n  }\n\n  if (pem != NULL) {\n    (void) SSL_CTX_use_certificate_chain_file(ctx->ssl_ctx, pem);\n  }\n\n  // Initialize locking callbacks, needed for thread safety.\n  // http://www.openssl.org/support/faq.html#PROG1\n  size = sizeof(pthread_mutex_t) * CRYPTO_num_locks();\n  if ((ssl_mutexes = (pthread_mutex_t *) malloc((size_t)size)) == NULL) {\n    cry(fc(ctx), \"%s: cannot allocate mutexes: %s\", __func__, ssl_error());\n    return 0;\n  }\n\n  for (i = 0; i < CRYPTO_num_locks(); i++) {\n    pthread_mutex_init(&ssl_mutexes[i], NULL);\n  }\n\n  CRYPTO_set_locking_callback(&ssl_locking_callback);\n  CRYPTO_set_id_callback(&ssl_id_callback);\n\n  return 1;\n}\n\nstatic void uninitialize_ssl(struct mg_context *ctx) {\n  int i;\n  if (ctx->ssl_ctx != NULL) {\n    CRYPTO_set_locking_callback(NULL);\n    for (i = 0; i < CRYPTO_num_locks(); i++) {\n      pthread_mutex_destroy(&ssl_mutexes[i]);\n    }\n    CRYPTO_set_locking_callback(NULL);\n    CRYPTO_set_id_callback(NULL);\n  }\n}\n#endif // !NO_SSL\n\n\nstatic SOCKET conn2(const char *host, int port, int use_ssl,\n                    char *ebuf, size_t ebuf_len) {\n  struct sockaddr_in sin;\n  struct hostent *he;\n  SOCKET sock = INVALID_SOCKET;\n\n  if (host == NULL) {\n    snprintf(ebuf, ebuf_len, \"%s\", \"NULL host\");\n  } else if (use_ssl && SSLv23_client_method == NULL) {\n    snprintf(ebuf, ebuf_len, \"%s\", \"SSL is not initialized\");\n    // TODO(lsm): use something threadsafe instead of gethostbyname()\n  } else if ((he = gethostbyname(host)) == NULL) {\n    snprintf(ebuf, ebuf_len, \"gethostbyname(%s): %s\", host, strerror(ERRNO));\n  } else if ((sock = socket(PF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET) {\n    snprintf(ebuf, ebuf_len, \"socket(): %s\", strerror(ERRNO));\n  } else {\n    set_close_on_exec(sock);\n    sin.sin_family = AF_INET;\n    sin.sin_port = htons((uint16_t) port);\n    sin.sin_addr = * (struct in_addr *) he->h_addr_list[0];\n    if (connect(sock, (struct sockaddr *) &sin, sizeof(sin)) != 0) {\n      snprintf(ebuf, ebuf_len, \"connect(%s:%d): %s\",\n               host, port, strerror(ERRNO));\n      closesocket(sock);\n      sock = INVALID_SOCKET;\n    }\n  }\n  return sock;\n}\n\nstruct mg_connection *mg_connect(const char *host, int port, int use_ssl,\n                                 char *ebuf, size_t ebuf_len) {\n  static struct mg_context fake_ctx;\n  struct mg_connection *conn = NULL;\n  SOCKET sock;\n\n  if ((sock = conn2(host, port, use_ssl, ebuf, ebuf_len)) == INVALID_SOCKET) {\n  } else if ((conn = (struct mg_connection *)\n              calloc(1, sizeof(*conn) + MAX_REQUEST_SIZE)) == NULL) {\n    snprintf(ebuf, ebuf_len, \"calloc(): %s\", strerror(ERRNO));\n    closesocket(sock);\n#ifndef NO_SSL\n  } else if (use_ssl && (conn->client_ssl_ctx =\n                         SSL_CTX_new(SSLv23_client_method())) == NULL) {\n    snprintf(ebuf, ebuf_len, \"SSL_CTX_new error\");\n    closesocket(sock);\n    free(conn);\n    conn = NULL;\n#endif // NO_SSL\n  } else {\n    socklen_t len = sizeof(struct sockaddr);\n    conn->buf_size = MAX_REQUEST_SIZE;\n    conn->buf = (char *) (conn + 1);\n    conn->ctx = &fake_ctx;\n    conn->client.sock = sock;\n    getsockname(sock, &conn->client.rsa.sa, &len);\n    conn->client.is_ssl = use_ssl;\n#ifndef NO_SSL\n    if (use_ssl) {\n      // SSL_CTX_set_verify call is needed to switch off server certificate\n      // checking, which is off by default in OpenSSL and on in yaSSL.\n      SSL_CTX_set_verify(conn->client_ssl_ctx, 0, 0);\n      sslize(conn, conn->client_ssl_ctx, SSL_connect);\n    }\n#endif\n  }\n\n  return conn;\n}\n\nstruct mg_connection *mg_download(const char *host, int port, int use_ssl,\n                                  char *ebuf, size_t ebuf_len,\n                                  const char *fmt, ...) {\n  struct mg_connection *conn;\n  va_list ap;\n\n  va_start(ap, fmt);\n  ebuf[0] = '\\0';\n  if ((conn = mg_connect(host, port, use_ssl, ebuf, ebuf_len)) == NULL) {\n  } else if (mg_vprintf(conn, fmt, ap) <= 0) {\n    snprintf(ebuf, ebuf_len, \"%s\", \"Error sending request\");\n  } else {\n    getreq(conn, ebuf, ebuf_len);\n  }\n  if (ebuf[0] != '\\0' && conn != NULL) {\n    mg_close_connection(conn);\n    conn = NULL;\n  }\n\n  return conn;\n}\n\n// Return number of bytes left to read for this connection\nstatic int64_t left_to_read(const struct mg_connection *conn) {\n  return conn->content_len + conn->request_len - conn->num_bytes_read;\n}\n\nstatic int call_user(int type, struct mg_connection *conn, void *p) {\n  if (conn != NULL && conn->ctx != NULL) {\n    conn->event.user_data = conn->ctx->user_data;\n    conn->event.type = type;\n    conn->event.event_param = p;\n    conn->event.request_info = &conn->request_info;\n    conn->event.conn = conn;\n  }\n  return conn == NULL || conn->ctx == NULL || conn->ctx->event_handler == NULL ?\n    0 : conn->ctx->event_handler(&conn->event);\n}\n\nstatic FILE *mg_fopen(const char *path, const char *mode) {\n#ifdef _WIN32\n  wchar_t wbuf[PATH_MAX], wmode[20];\n  to_unicode(path, wbuf, ARRAY_SIZE(wbuf));\n  MultiByteToWideChar(CP_UTF8, 0, mode, -1, wmode, ARRAY_SIZE(wmode));\n  return _wfopen(wbuf, wmode);\n#else\n  return fopen(path, mode);\n#endif\n}\n\nstatic void sockaddr_to_string(char *buf, size_t len,\n                                     const union usa *usa) {\n  buf[0] = '\\0';\n#if defined(USE_IPV6)\n  inet_ntop(usa->sa.sa_family, usa->sa.sa_family == AF_INET ?\n            (void *) &usa->sin.sin_addr :\n            (void *) &usa->sin6.sin6_addr, buf, len);\n#elif defined(_WIN32)\n  // Only Windoze Vista (and newer) have inet_ntop()\n  strncpy(buf, inet_ntoa(usa->sin.sin_addr), len);\n#else\n  inet_ntop(usa->sa.sa_family, (void *) &usa->sin.sin_addr, buf, len);\n#endif\n}\n\n// Print error message to the opened error log stream.\nstatic void cry(struct mg_connection *conn, const char *fmt, ...) {\n  char buf[MG_BUF_LEN], src_addr[IP_ADDR_STR_LEN];\n  va_list ap;\n  FILE *fp;\n  time_t timestamp;\n\n  va_start(ap, fmt);\n  (void) vsnprintf(buf, sizeof(buf), fmt, ap);\n  va_end(ap);\n\n  // Do not lock when getting the callback value, here and below.\n  // I suppose this is fine, since function cannot disappear in the\n  // same way string option can.\n  if (call_user(MG_EVENT_LOG, conn, buf) == 0) {\n    fp = conn->ctx == NULL || conn->ctx->config[ERROR_LOG_FILE] == NULL ? NULL :\n      fopen(conn->ctx->config[ERROR_LOG_FILE], \"a+\");\n\n    if (fp != NULL) {\n      flockfile(fp);\n      timestamp = time(NULL);\n\n      sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);\n      fprintf(fp, \"[%010lu] [error] [client %s] \", (unsigned long) timestamp,\n              src_addr);\n\n      if (conn->request_info.request_method != NULL) {\n        fprintf(fp, \"%s %s: \", conn->request_info.request_method,\n                conn->request_info.uri);\n      }\n\n      fprintf(fp, \"%s\", buf);\n      fputc('\\n', fp);\n      funlockfile(fp);\n      fclose(fp);\n    }\n  }\n}\n\nconst char *mg_version(void) {\n  return MONGOOSE_VERSION;\n}\n\n// HTTP 1.1 assumes keep alive if \"Connection:\" header is not set\n// This function must tolerate situations when connection info is not\n// set up, for example if request parsing failed.\nstatic int should_keep_alive(const struct mg_connection *conn) {\n  const char *http_version = conn->request_info.http_version;\n  const char *header = mg_get_header(conn, \"Connection\");\n  if (conn->must_close ||\n      conn->status_code == 401 ||\n      mg_strcasecmp(conn->ctx->config[ENABLE_KEEP_ALIVE], \"yes\") != 0 ||\n      (header != NULL && mg_strcasecmp(header, \"keep-alive\") != 0) ||\n      (header == NULL && http_version && strcmp(http_version, \"1.1\"))) {\n    return 0;\n  }\n  return 1;\n}\n\nstatic const char *suggest_connection_header(const struct mg_connection *conn) {\n  return should_keep_alive(conn) ? \"keep-alive\" : \"close\";\n}\n\nstatic void send_http_error(struct mg_connection *conn, int status,\n                            const char *reason, const char *fmt, ...) {\n  char buf[MG_BUF_LEN];\n  va_list ap;\n  int len = 0;\n\n  conn->status_code = status;\n  buf[0] = '\\0';\n\n  // Errors 1xx, 204 and 304 MUST NOT send a body\n  if (status > 199 && status != 204 && status != 304) {\n    len = mg_snprintf(buf, sizeof(buf), \"Error %d: %s\", status, reason);\n    buf[len++] = '\\n';\n\n    va_start(ap, fmt);\n    len += mg_vsnprintf(buf + len, sizeof(buf) - len, fmt, ap);\n    va_end(ap);\n  }\n  DEBUG_TRACE((\"[%s]\", buf));\n\n  if (call_user(MG_HTTP_ERROR, conn, (void *) (long) status) == 0) {\n    mg_printf(conn, \"HTTP/1.1 %d %s\\r\\n\"\n              \"Content-Length: %d\\r\\n\"\n              \"Connection: %s\\r\\n\\r\\n\", status, reason, len,\n              suggest_connection_header(conn));\n    conn->num_bytes_sent += mg_printf(conn, \"%s\", buf);\n  }\n}\n\n// Write data to the IO channel - opened file descriptor, socket or SSL\n// descriptor. Return number of bytes written.\nstatic int64_t push(FILE *fp, SOCKET sock, SSL *ssl, const char *buf,\n                    int64_t len) {\n  int64_t sent;\n  int n, k;\n\n  (void) ssl;  // Get rid of warning\n  sent = 0;\n  while (sent < len) {\n\n    // How many bytes we send in this iteration\n    k = len - sent > INT_MAX ? INT_MAX : (int) (len - sent);\n\n    if (ssl != NULL) {\n      n = SSL_write(ssl, buf + sent, k);\n    } else if (fp != NULL) {\n      n = (int) fwrite(buf + sent, 1, (size_t) k, fp);\n      if (ferror(fp))\n        n = -1;\n    } else {\n      n = send(sock, buf + sent, (size_t) k, MSG_NOSIGNAL);\n    }\n\n    if (n <= 0)\n      break;\n\n    sent += n;\n  }\n\n  return sent;\n}\n\n// Read from IO channel - opened file descriptor, socket, or SSL descriptor.\n// Return negative value on error, or number of bytes read on success.\nstatic int pull(FILE *fp, struct mg_connection *conn, char *buf, int len) {\n  int nread;\n\n  if (len <= 0) return 0;\n  if (fp != NULL) {\n    // Use read() instead of fread(), because if we're reading from the CGI\n    // pipe, fread() may block until IO buffer is filled up. We cannot afford\n    // to block and must pass all read bytes immediately to the client.\n    nread = read(fileno(fp), buf, (size_t) len);\n#ifndef NO_SSL\n  } else if (conn->ssl != NULL) {\n    nread = SSL_read(conn->ssl, buf, len);\n#endif\n  } else {\n    nread = recv(conn->client.sock, buf, (size_t) len, 0);\n  }\n  if (nread > 0) {\n    conn->num_bytes_read += nread;\n  }\n\n  return conn->ctx->stop_flag ? -1 : nread;\n}\n\nstatic int pull_all(FILE *fp, struct mg_connection *conn, char *buf, int len) {\n  int n, nread = 0;\n\n  while (len > 0 && conn->ctx->stop_flag == 0) {\n    n = pull(fp, conn, buf + nread, len);\n    if (n < 0) {\n      nread = n;  // Propagate the error\n      break;\n    } else if (n == 0) {\n      break;  // No more data to read\n    } else {\n      nread += n;\n      len -= n;\n    }\n  }\n\n  return nread;\n}\n\nint mg_read(struct mg_connection *conn, void *buf, int len) {\n  int n, buffered_len, nread = 0;\n  int64_t left;\n\n  if (conn->content_len <= 0) {\n    return 0;\n  }\n\n  // conn->buf           body\n  //    |=================|==========|===============|\n  //    |<--request_len-->|                          |\n  //    |<-----------data_len------->|      conn->buf + conn->buf_size\n\n  // First, check for data buffered in conn->buf by read_request().\n  if (len > 0 && (buffered_len = conn->data_len - conn->request_len) > 0) {\n    char *body = conn->buf + conn->request_len;\n    if (buffered_len > len) buffered_len = len;\n    if (buffered_len > conn->content_len) buffered_len = (int)conn->content_len;\n\n    memcpy(buf, body, (size_t) buffered_len);\n    memmove(body, body + buffered_len,\n            &conn->buf[conn->data_len] - &body[buffered_len]);\n    len -= buffered_len;\n    conn->data_len -= buffered_len;\n    nread += buffered_len;\n  }\n\n  // Read data from the socket.\n  if (len > 0 && (left = left_to_read(conn)) > 0) {\n    if (left < len) {\n      len = (int) left;\n    }\n    n = pull_all(NULL, conn, (char *) buf + nread, (int) len);\n    nread = n >= 0 ? nread + n : n;\n  }\n\n  return nread;\n}\n\nint mg_write(struct mg_connection *conn, const void *buf, int len) {\n  time_t now;\n  int64_t n, total, allowed;\n\n  if (conn->throttle > 0) {\n    if ((now = time(NULL)) != conn->last_throttle_time) {\n      conn->last_throttle_time = now;\n      conn->last_throttle_bytes = 0;\n    }\n    allowed = conn->throttle - conn->last_throttle_bytes;\n    if (allowed > (int64_t) len) {\n      allowed = len;\n    }\n    if ((total = push(NULL, conn->client.sock, conn->ssl, (const char *) buf,\n                      (int64_t) allowed)) == allowed) {\n      buf = (char *) buf + total;\n      conn->last_throttle_bytes += total;\n      while (total < (int64_t) len && conn->ctx->stop_flag == 0) {\n        allowed = conn->throttle > (int64_t) len - total ?\n          (int64_t) len - total : conn->throttle;\n        if ((n = push(NULL, conn->client.sock, conn->ssl, (const char *) buf,\n                      (int64_t) allowed)) != allowed) {\n          break;\n        }\n        sleep(1);\n        conn->last_throttle_bytes = allowed;\n        conn->last_throttle_time = time(NULL);\n        buf = (char *) buf + n;\n        total += n;\n      }\n    }\n  } else {\n    total = push(NULL, conn->client.sock, conn->ssl, (const char *) buf,\n                 (int64_t) len);\n  }\n  return (int) total;\n}\n\nint mg_url_decode(const char *src, int src_len, char *dst,\n                  int dst_len, int is_form_url_encoded) {\n  int i, j, a, b;\n#define HEXTOI(x) (isdigit(x) ? x - '0' : x - 'W')\n\n  for (i = j = 0; i < src_len && j < dst_len - 1; i++, j++) {\n    if (src[i] == '%' && i < src_len - 2 &&\n        isxdigit(* (const unsigned char *) (src + i + 1)) &&\n        isxdigit(* (const unsigned char *) (src + i + 2))) {\n      a = tolower(* (const unsigned char *) (src + i + 1));\n      b = tolower(* (const unsigned char *) (src + i + 2));\n      dst[j] = (char) ((HEXTOI(a) << 4) | HEXTOI(b));\n      i += 2;\n    } else if (is_form_url_encoded && src[i] == '+') {\n      dst[j] = ' ';\n    } else {\n      dst[j] = src[i];\n    }\n  }\n\n  dst[j] = '\\0'; // Null-terminate the destination\n\n  return i >= src_len ? j : -1;\n}\n\nint mg_get_var(const char *data, size_t data_len, const char *name,\n               char *dst, size_t dst_len) {\n  const char *p, *e, *s;\n  size_t name_len;\n  int len;\n\n  if (dst == NULL || dst_len == 0) {\n    len = -2;\n  } else if (data == NULL || name == NULL || data_len == 0) {\n    len = -1;\n    dst[0] = '\\0';\n  } else {\n    name_len = strlen(name);\n    e = data + data_len;\n    len = -1;\n    dst[0] = '\\0';\n\n    // data is \"var1=val1&var2=val2...\". Find variable first\n    for (p = data; p + name_len < e; p++) {\n      if ((p == data || p[-1] == '&') && p[name_len] == '=' &&\n          !mg_strncasecmp(name, p, name_len)) {\n\n        // Point p to variable value\n        p += name_len + 1;\n\n        // Point s to the end of the value\n        s = (const char *) memchr(p, '&', (size_t)(e - p));\n        if (s == NULL) {\n          s = e;\n        }\n        assert(s >= p);\n\n        // Decode variable into destination buffer\n        len = mg_url_decode(p, (size_t)(s - p), dst, dst_len, 1);\n\n        // Redirect error code from -1 to -2 (destination buffer too small).\n        if (len == -1) {\n          len = -2;\n        }\n        break;\n      }\n    }\n  }\n\n  return len;\n}\n\nint mg_get_cookie(const char *cookie_header, const char *var_name,\n                  char *dst, size_t dst_size) {\n  const char *s, *p, *end;\n  int name_len, len = -1;\n\n  if (dst == NULL || dst_size == 0) {\n    len = -2;\n  } else if (var_name == NULL || (s = cookie_header) == NULL) {\n    len = -1;\n    dst[0] = '\\0';\n  } else {\n    name_len = (int) strlen(var_name);\n    end = s + strlen(s);\n    dst[0] = '\\0';\n\n    for (; (s = mg_strcasestr(s, var_name)) != NULL; s += name_len) {\n      if (s[name_len] == '=') {\n        s += name_len + 1;\n        if ((p = strchr(s, ' ')) == NULL)\n          p = end;\n        if (p[-1] == ';')\n          p--;\n        if (*s == '\"' && p[-1] == '\"' && p > s + 1) {\n          s++;\n          p--;\n        }\n        if ((size_t) (p - s) < dst_size) {\n          len = p - s;\n          mg_strlcpy(dst, s, (size_t) len + 1);\n        } else {\n          len = -3;\n        }\n        break;\n      }\n    }\n  }\n  return len;\n}\n\n// Return 1 if real file has been found, 0 otherwise\nstatic int convert_uri_to_file_name(struct mg_connection *conn, char *buf,\n                                    size_t buf_len, struct file *filep) {\n  struct vec a, b;\n  const char *rewrite, *uri = conn->request_info.uri,\n        *root = conn->ctx->config[DOCUMENT_ROOT];\n  char *p;\n  int match_len;\n  char gz_path[PATH_MAX];\n  char const* accept_encoding;\n\n  // No filesystem access\n  if (root == NULL) {\n    return 0;\n  }\n\n  // Using buf_len - 1 because memmove() for PATH_INFO may shift part\n  // of the path one byte on the right.\n  // If document_root is NULL, leave the file empty.\n  mg_snprintf(buf, buf_len - 1, \"%s%s\", root, uri);\n\n  rewrite = conn->ctx->config[REWRITE];\n  while ((rewrite = next_option(rewrite, &a, &b)) != NULL) {\n    if ((match_len = match_prefix(a.ptr, a.len, uri)) > 0) {\n      mg_snprintf(buf, buf_len - 1, \"%.*s%s\", (int) b.len, b.ptr,\n                  uri + match_len);\n      break;\n    }\n  }\n\n  if (mg_stat(buf, filep)) {\n    return 1;\n  }\n\n  // if we can't find the actual file, look for the file\n  // with the same name but a .gz extension. If we find it,\n  // use that and set the gzipped flag in the file struct\n  // to indicate that the response need to have the content-\n  // encoding: gzip header\n  // we can only do this if the browser declares support\n  if ((accept_encoding = mg_get_header(conn, \"Accept-Encoding\")) != NULL) {\n    if (strstr(accept_encoding,\"gzip\") != NULL) {\n      snprintf(gz_path, sizeof(gz_path), \"%s.gz\", buf);\n      if (mg_stat(gz_path, filep)) {\n        filep->gzipped = 1;\n        return 1;\n      }\n    }\n  }\n\n  // Support PATH_INFO for CGI scripts.\n  for (p = buf + strlen(root == NULL ? \"\" : root); *p != '\\0'; p++) {\n    if (*p == '/') {\n      *p = '\\0';\n      if (match_prefix(conn->ctx->config[CGI_EXTENSIONS],\n                       strlen(conn->ctx->config[CGI_EXTENSIONS]), buf) > 0 &&\n          mg_stat(buf, filep)) {\n        // Shift PATH_INFO block one character right, e.g.\n        //  \"/x.cgi/foo/bar\\x00\" => \"/x.cgi\\x00/foo/bar\\x00\"\n        // conn->path_info is pointing to the local variable \"path\" declared\n        // in handle_request(), so PATH_INFO is not valid after\n        // handle_request returns.\n        conn->path_info = p + 1;\n        memmove(p + 2, p + 1, strlen(p + 1) + 1);  // +1 is for trailing \\0\n        p[1] = '/';\n        return 1;\n      } else {\n        *p = '/';\n      }\n    }\n  }\n\n  return 0;\n}\n\n// Check whether full request is buffered. Return:\n//   -1  if request is malformed\n//    0  if request is not yet fully buffered\n//   >0  actual request length, including last \\r\\n\\r\\n\nstatic int get_request_len(const char *buf, int buf_len) {\n  int i;\n\n  for (i = 0; i < buf_len; i++) {\n    // Control characters are not allowed but >=128 is.\n    // Abort scan as soon as one malformed character is found;\n    // don't let subsequent \\r\\n\\r\\n win us over anyhow\n    if (!isprint(* (const unsigned char *) &buf[i]) && buf[i] != '\\r' &&\n        buf[i] != '\\n' && * (const unsigned char *) &buf[i] < 128) {\n      return -1;\n    } else if (buf[i] == '\\n' && i + 1 < buf_len && buf[i + 1] == '\\n') {\n      return i + 2;\n    } else if (buf[i] == '\\n' && i + 2 < buf_len && buf[i + 1] == '\\r' &&\n               buf[i + 2] == '\\n') {\n      return i + 3;\n    }\n  }\n\n  return 0;\n}\n\n// Protect against directory disclosure attack by removing '..',\n// excessive '/' and '\\' characters\nstatic void remove_double_dots_and_double_slashes(char *s) {\n  char *p = s;\n\n  while (*s != '\\0') {\n    *p++ = *s++;\n    if (s[-1] == '/' || s[-1] == '\\\\') {\n      // Skip all following slashes, backslashes and double-dots\n      while (s[0] != '\\0') {\n        if (s[0] == '/' || s[0] == '\\\\') {\n          s++;\n        } else if (s[0] == '.' && s[1] == '.') {\n          s += 2;\n        } else {\n          break;\n        }\n      }\n    }\n  }\n  *p = '\\0';\n}\n\nstatic const struct {\n  const char *extension;\n  size_t ext_len;\n  const char *mime_type;\n} builtin_mime_types[] = {\n  {\".html\", 5, \"text/html\"},\n  {\".htm\", 4, \"text/html\"},\n  {\".shtm\", 5, \"text/html\"},\n  {\".shtml\", 6, \"text/html\"},\n  {\".css\", 4, \"text/css\"},\n  {\".js\",  3, \"application/x-javascript\"},\n  {\".ico\", 4, \"image/x-icon\"},\n  {\".gif\", 4, \"image/gif\"},\n  {\".jpg\", 4, \"image/jpeg\"},\n  {\".jpeg\", 5, \"image/jpeg\"},\n  {\".png\", 4, \"image/png\"},\n  {\".svg\", 4, \"image/svg+xml\"},\n  {\".txt\", 4, \"text/plain\"},\n  {\".torrent\", 8, \"application/x-bittorrent\"},\n  {\".wav\", 4, \"audio/x-wav\"},\n  {\".mp3\", 4, \"audio/x-mp3\"},\n  {\".mid\", 4, \"audio/mid\"},\n  {\".m3u\", 4, \"audio/x-mpegurl\"},\n  {\".ogg\", 4, \"application/ogg\"},\n  {\".ram\", 4, \"audio/x-pn-realaudio\"},\n  {\".xml\", 4, \"text/xml\"},\n  {\".json\",  5, \"text/json\"},\n  {\".xslt\", 5, \"application/xml\"},\n  {\".xsl\", 4, \"application/xml\"},\n  {\".ra\",  3, \"audio/x-pn-realaudio\"},\n  {\".doc\", 4, \"application/msword\"},\n  {\".exe\", 4, \"application/octet-stream\"},\n  {\".zip\", 4, \"application/x-zip-compressed\"},\n  {\".xls\", 4, \"application/excel\"},\n  {\".tgz\", 4, \"application/x-tar-gz\"},\n  {\".tar\", 4, \"application/x-tar\"},\n  {\".gz\",  3, \"application/x-gunzip\"},\n  {\".arj\", 4, \"application/x-arj-compressed\"},\n  {\".rar\", 4, \"application/x-arj-compressed\"},\n  {\".rtf\", 4, \"application/rtf\"},\n  {\".pdf\", 4, \"application/pdf\"},\n  {\".swf\", 4, \"application/x-shockwave-flash\"},\n  {\".mpg\", 4, \"video/mpeg\"},\n  {\".webm\", 5, \"video/webm\"},\n  {\".mpeg\", 5, \"video/mpeg\"},\n  {\".mov\", 4, \"video/quicktime\"},\n  {\".mp4\", 4, \"video/mp4\"},\n  {\".m4v\", 4, \"video/x-m4v\"},\n  {\".asf\", 4, \"video/x-ms-asf\"},\n  {\".avi\", 4, \"video/x-msvideo\"},\n  {\".bmp\", 4, \"image/bmp\"},\n  {\".ttf\", 4, \"application/x-font-ttf\"},\n  {NULL,  0, NULL}\n};\n\nconst char *mg_get_builtin_mime_type(const char *path) {\n  const char *ext;\n  size_t i, path_len;\n\n  path_len = strlen(path);\n\n  for (i = 0; builtin_mime_types[i].extension != NULL; i++) {\n    ext = path + (path_len - builtin_mime_types[i].ext_len);\n    if (path_len > builtin_mime_types[i].ext_len &&\n        mg_strcasecmp(ext, builtin_mime_types[i].extension) == 0) {\n      return builtin_mime_types[i].mime_type;\n    }\n  }\n\n  return \"text/plain\";\n}\n\n// Look at the \"path\" extension and figure what mime type it has.\n// Store mime type in the vector.\nstatic void get_mime_type(struct mg_context *ctx, const char *path,\n                          struct vec *vec) {\n  struct vec ext_vec, mime_vec;\n  const char *list, *ext;\n  size_t path_len;\n\n  path_len = strlen(path);\n\n  // Scan user-defined mime types first, in case user wants to\n  // override default mime types.\n  list = ctx->config[EXTRA_MIME_TYPES];\n  while ((list = next_option(list, &ext_vec, &mime_vec)) != NULL) {\n    // ext now points to the path suffix\n    ext = path + path_len - ext_vec.len;\n    if (mg_strncasecmp(ext, ext_vec.ptr, ext_vec.len) == 0) {\n      *vec = mime_vec;\n      return;\n    }\n  }\n\n  vec->ptr = mg_get_builtin_mime_type(path);\n  vec->len = strlen(vec->ptr);\n}\n\nvoid mg_url_encode(const char *src, char *dst, size_t dst_len) {\n  static const char *dont_escape = \"._-$,;~()\";\n  static const char *hex = \"0123456789abcdef\";\n  const char *end = dst + dst_len - 1;\n\n  for (; *src != '\\0' && dst < end; src++, dst++) {\n    if (isalnum(*(const unsigned char *) src) ||\n        strchr(dont_escape, * (const unsigned char *) src) != NULL) {\n      *dst = *src;\n    } else if (dst + 2 < end) {\n      dst[0] = '%';\n      dst[1] = hex[(* (const unsigned char *) src) >> 4];\n      dst[2] = hex[(* (const unsigned char *) src) & 0xf];\n      dst += 2;\n    }\n  }\n\n  *dst = '\\0';\n}\n\nstatic void print_dir_entry(const struct de *de) {\n  char size[64], mod[64], href[PATH_MAX * 3];\n  const char *slash = de->file.is_directory ? \"/\" : \"\";\n\n  if (de->file.is_directory) {\n    mg_snprintf(size, sizeof(size), \"%s\", \"[DIRECTORY]\");\n  } else {\n     // We use (signed) cast below because MSVC 6 compiler cannot\n     // convert unsigned __int64 to double. Sigh.\n    if (de->file.size < 1024) {\n      mg_snprintf(size, sizeof(size), \"%d\", (int) de->file.size);\n    } else if (de->file.size < 0x100000) {\n      mg_snprintf(size, sizeof(size),\n                  \"%.1fk\", (double) de->file.size / 1024.0);\n    } else if (de->file.size < 0x40000000) {\n      mg_snprintf(size, sizeof(size),\n                  \"%.1fM\", (double) de->file.size / 1048576);\n    } else {\n      mg_snprintf(size, sizeof(size),\n                  \"%.1fG\", (double) de->file.size / 1073741824);\n    }\n  }\n  strftime(mod, sizeof(mod), \"%d-%b-%Y %H:%M\",\n           localtime(&de->file.modification_time));\n  mg_url_encode(de->file_name, href, sizeof(href));\n  de->conn->num_bytes_sent += mg_chunked_printf(de->conn,\n      \"<tr><td><a href=\\\"%s%s%s\\\">%s%s</a></td>\"\n      \"<td>&nbsp;%s</td><td>&nbsp;&nbsp;%s</td></tr>\\n\",\n      de->conn->request_info.uri, href, slash, de->file_name, slash, mod, size);\n}\n\n// This function is called from send_directory() and used for\n// sorting directory entries by size, or name, or modification time.\n// On windows, __cdecl specification is needed in case if project is built\n// with __stdcall convention. qsort always requires __cdels callback.\nstatic int WINCDECL compare_dir_entries(const void *p1, const void *p2) {\n  const struct de *a = (const struct de *) p1, *b = (const struct de *) p2;\n  const char *query_string = a->conn->request_info.query_string;\n  int cmp_result = 0;\n\n  if (query_string == NULL) {\n    query_string = \"na\";\n  }\n\n  if (a->file.is_directory && !b->file.is_directory) {\n    return -1;  // Always put directories on top\n  } else if (!a->file.is_directory && b->file.is_directory) {\n    return 1;   // Always put directories on top\n  } else if (*query_string == 'n') {\n    cmp_result = strcmp(a->file_name, b->file_name);\n  } else if (*query_string == 's') {\n    cmp_result = a->file.size == b->file.size ? 0 :\n      a->file.size > b->file.size ? 1 : -1;\n  } else if (*query_string == 'd') {\n    cmp_result = a->file.modification_time == b->file.modification_time ? 0 :\n      a->file.modification_time > b->file.modification_time ? 1 : -1;\n  }\n\n  return query_string[1] == 'd' ? -cmp_result : cmp_result;\n}\n\nstatic int must_hide_file(struct mg_connection *conn, const char *path) {\n  const char *pw_pattern = \"**\" PASSWORDS_FILE_NAME \"$\";\n  const char *pattern = conn->ctx->config[HIDE_FILES];\n  return match_prefix(pw_pattern, strlen(pw_pattern), path) > 0 ||\n    (pattern != NULL && match_prefix(pattern, strlen(pattern), path) > 0);\n}\n\nstatic int scan_directory(struct mg_connection *conn, const char *dir,\n                          void *data, void (*cb)(struct de *, void *)) {\n  char path[PATH_MAX];\n  struct dirent *dp;\n  DIR *dirp;\n  struct de de;\n\n  if ((dirp = opendir(dir)) == NULL) {\n    return 0;\n  } else {\n    de.conn = conn;\n\n    while ((dp = readdir(dirp)) != NULL) {\n      // Do not show current dir and hidden files\n      if (!strcmp(dp->d_name, \".\") ||\n          !strcmp(dp->d_name, \"..\") ||\n          must_hide_file(conn, dp->d_name)) {\n        continue;\n      }\n\n      mg_snprintf(path, sizeof(path), \"%s%c%s\", dir, '/', dp->d_name);\n\n      // If we don't memset stat structure to zero, mtime will have\n      // garbage and strftime() will segfault later on in\n      // print_dir_entry(). memset is required only if mg_stat()\n      // fails. For more details, see\n      // http://code.google.com/p/mongoose/issues/detail?id=79\n      memset(&de.file, 0, sizeof(de.file));\n      mg_stat(path, &de.file);\n\n      de.file_name = dp->d_name;\n      cb(&de, data);\n    }\n    (void) closedir(dirp);\n  }\n  return 1;\n}\n\nstatic int remove_directory(struct mg_connection *conn, const char *dir) {\n  char path[PATH_MAX];\n  struct dirent *dp;\n  DIR *dirp;\n  struct de de;\n\n  if ((dirp = opendir(dir)) == NULL) {\n    return 0;\n  } else {\n    de.conn = conn;\n\n    while ((dp = readdir(dirp)) != NULL) {\n      // Do not show current dir, but show hidden files\n      if (!strcmp(dp->d_name, \".\") ||\n          !strcmp(dp->d_name, \"..\")) {\n        continue;\n      }\n\n      mg_snprintf(path, sizeof(path), \"%s%c%s\", dir, '/', dp->d_name);\n\n      // If we don't memset stat structure to zero, mtime will have\n      // garbage and strftime() will segfault later on in\n      // print_dir_entry(). memset is required only if mg_stat()\n      // fails. For more details, see\n      // http://code.google.com/p/mongoose/issues/detail?id=79\n      memset(&de.file, 0, sizeof(de.file));\n      mg_stat(path, &de.file);\n      if(de.file.modification_time) {\n          if(de.file.is_directory) {\n              remove_directory(conn, path);\n          } else {\n              mg_remove(path);\n          }\n      }\n\n    }\n    (void) closedir(dirp);\n\n    rmdir(dir);\n  }\n\n  return 1;\n}\n\nstruct dir_scan_data {\n  struct de *entries;\n  int num_entries;\n  int arr_size;\n};\n\n// Behaves like realloc(), but frees original pointer on failure\nstatic void *realloc2(void *ptr, size_t size) {\n  void *new_ptr = realloc(ptr, size);\n  if (new_ptr == NULL) {\n    free(ptr);\n  }\n  return new_ptr;\n}\n\nstatic void dir_scan_callback(struct de *de, void *data) {\n  struct dir_scan_data *dsd = (struct dir_scan_data *) data;\n\n  if (dsd->entries == NULL || dsd->num_entries >= dsd->arr_size) {\n    dsd->arr_size *= 2;\n    dsd->entries = (struct de *) realloc2(dsd->entries, dsd->arr_size *\n                                          sizeof(dsd->entries[0]));\n  }\n  if (dsd->entries == NULL) {\n    // TODO(lsm): propagate an error to the caller\n    dsd->num_entries = 0;\n  } else {\n    dsd->entries[dsd->num_entries].file_name = mg_strdup(de->file_name);\n    dsd->entries[dsd->num_entries].file = de->file;\n    dsd->entries[dsd->num_entries].conn = de->conn;\n    dsd->num_entries++;\n  }\n}\n\nstatic void handle_directory_request(struct mg_connection *conn,\n                                     const char *dir) {\n  int i, sort_direction;\n  struct dir_scan_data data = { NULL, 0, 128 };\n\n  if (!scan_directory(conn, dir, &data, dir_scan_callback)) {\n    send_http_error(conn, 500, \"Cannot open directory\",\n                    \"Error: opendir(%s): %s\", dir, strerror(ERRNO));\n    return;\n  }\n\n  sort_direction = conn->request_info.query_string != NULL &&\n    conn->request_info.query_string[1] == 'd' ? 'a' : 'd';\n\n  conn->must_close = 1;\n  mg_printf(conn, \"%s\",\n            \"HTTP/1.1 200 OK\\r\\n\"\n            \"Transfer-Encoding: Chunked\\r\\n\"\n            \"Content-Type: text/html; charset=utf-8\\r\\n\\r\\n\");\n\n  conn->num_bytes_sent += mg_chunked_printf(conn,\n      \"<html><head><title>Index of %s</title>\"\n      \"<style>th {text-align: left;}</style></head>\"\n      \"<body><h1>Index of %s</h1><pre><table cellpadding=\\\"0\\\">\"\n      \"<tr><th><a href=\\\"?n%c\\\">Name</a></th>\"\n      \"<th><a href=\\\"?d%c\\\">Modified</a></th>\"\n      \"<th><a href=\\\"?s%c\\\">Size</a></th></tr>\"\n      \"<tr><td colspan=\\\"3\\\"><hr></td></tr>\",\n      conn->request_info.uri, conn->request_info.uri,\n      sort_direction, sort_direction, sort_direction);\n\n  // Print first entry - link to a parent directory\n  conn->num_bytes_sent += mg_chunked_printf(conn,\n      \"<tr><td><a href=\\\"%s%s\\\">%s</a></td>\"\n      \"<td>&nbsp;%s</td><td>&nbsp;&nbsp;%s</td></tr>\\n\",\n      conn->request_info.uri, \"..\", \"Parent directory\", \"-\", \"-\");\n\n  // Sort and print directory entries\n  qsort(data.entries, (size_t) data.num_entries, sizeof(data.entries[0]),\n        compare_dir_entries);\n  for (i = 0; i < data.num_entries; i++) {\n    print_dir_entry(&data.entries[i]);\n    free(data.entries[i].file_name);\n  }\n  free(data.entries);\n\n  conn->num_bytes_sent += mg_chunked_printf(conn, \"%s\",\n                                            \"</table></body></html>\");\n  conn->num_bytes_sent += mg_write(conn, \"0\\r\\n\\r\\n\", 5);\n  conn->status_code = 200;\n}\n\n// Send len bytes from the opened file to the client.\nstatic void send_file_data(struct mg_connection *conn, FILE *fp,\n                           int64_t offset, int64_t len) {\n  char buf[MG_BUF_LEN];\n  int num_read, num_written, to_read;\n\n  // If offset is beyond file boundaries, don't send anything\n  if (offset > 0 && fseeko(fp, offset, SEEK_SET) != 0) {\n    return;\n  }\n\n  while (len > 0) {\n    // Calculate how much to read from the file in the buffer\n    to_read = sizeof(buf);\n    if ((int64_t) to_read > len) {\n      to_read = (int) len;\n    }\n\n    // Read from file, exit the loop on error\n    if ((num_read = fread(buf, 1, (size_t) to_read, fp)) <= 0) {\n      break;\n    }\n\n    // Send read bytes to the client, exit the loop on error\n    if ((num_written = mg_write(conn, buf, (size_t) num_read)) != num_read) {\n      break;\n    }\n\n    // Both read and were successful, adjust counters\n    conn->num_bytes_sent += num_written;\n    len -= num_written;\n  }\n}\n\nstatic int parse_range_header(const char *header, int64_t *a, int64_t *b) {\n  return sscanf(header, \"bytes=%\" INT64_FMT \"-%\" INT64_FMT, a, b);\n}\n\nstatic void gmt_time_string(char *buf, size_t buf_len, time_t *t) {\n  strftime(buf, buf_len, \"%a, %d %b %Y %H:%M:%S GMT\", gmtime(t));\n}\n\nstatic void construct_etag(char *buf, size_t buf_len,\n                           const struct file *filep) {\n  snprintf(buf, buf_len, \"\\\"%lx.%\" INT64_FMT \"\\\"\",\n           (unsigned long) filep->modification_time, filep->size);\n}\n\nstatic void fclose_on_exec(FILE *fp) {\n  if (fp != NULL) {\n#ifndef _WIN32\n    fcntl(fileno(fp), F_SETFD, FD_CLOEXEC);\n#endif\n  }\n}\n\nstatic void handle_file_request(struct mg_connection *conn, const char *path,\n                                struct file *filep) {\n  char date[64], lm[64], etag[64], range[64];\n  const char *msg = \"OK\", *hdr;\n  time_t curtime = time(NULL);\n  int64_t cl, r1, r2;\n  struct vec mime_vec;\n  int n;\n  char gz_path[PATH_MAX];\n  char const* encoding = \"\";\n  FILE *fp;\n\n  get_mime_type(conn->ctx, path, &mime_vec);\n  cl = filep->size;\n  conn->status_code = 200;\n  range[0] = '\\0';\n\n  // if this file is in fact a pre-gzipped file, rewrite its filename\n  // it's important to rewrite the filename after resolving\n  // the mime type from it, to preserve the actual file's type\n  if (filep->gzipped) {\n    snprintf(gz_path, sizeof(gz_path), \"%s.gz\", path);\n    path = gz_path;\n    encoding = \"Content-Encoding: gzip\\r\\n\";\n  }\n\n  if ((fp = mg_fopen(path, \"rb\")) == NULL) {\n    send_http_error(conn, 500, http_500_error,\n                    \"fopen(%s): %s\", path, strerror(ERRNO));\n    return;\n  }\n\n  fclose_on_exec(fp);\n\n  // If Range: header specified, act accordingly\n  r1 = r2 = 0;\n  hdr = mg_get_header(conn, \"Range\");\n  if (hdr != NULL && (n = parse_range_header(hdr, &r1, &r2)) > 0 &&\n      r1 >= 0 && r2 >= 0) {\n    // actually, range requests don't play well with a pre-gzipped\n    // file (since the range is specified in the uncmpressed space)\n    if (filep->gzipped) {\n      send_http_error(conn, 501, \"Not Implemented\",\n                      \"range requests in gzipped files are not supported\");\n      return;\n    }\n    conn->status_code = 206;\n    cl = n == 2 ? (r2 > cl ? cl : r2) - r1 + 1: cl - r1;\n    mg_snprintf(range, sizeof(range),\n                \"Content-Range: bytes \"\n                \"%\" INT64_FMT \"-%\"\n                INT64_FMT \"/%\" INT64_FMT \"\\r\\n\",\n                r1, r1 + cl - 1, filep->size);\n    msg = \"Partial Content\";\n  }\n\n  // Prepare Etag, Date, Last-Modified headers. Must be in UTC, according to\n  // http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3\n  gmt_time_string(date, sizeof(date), &curtime);\n  gmt_time_string(lm, sizeof(lm), &filep->modification_time);\n  construct_etag(etag, sizeof(etag), filep);\n\n  (void) mg_printf(conn,\n      \"HTTP/1.1 %d %s\\r\\n\"\n      \"Date: %s\\r\\n\"\n      \"Last-Modified: %s\\r\\n\"\n      \"Etag: %s\\r\\n\"\n      \"Content-Type: %.*s\\r\\n\"\n      \"Content-Length: %\" INT64_FMT \"\\r\\n\"\n      \"Connection: %s\\r\\n\"\n      \"Accept-Ranges: bytes\\r\\n\"\n      \"%s%s%s\\r\\n\",\n      conn->status_code, msg, date, lm, etag, (int) mime_vec.len,\n      mime_vec.ptr, cl, suggest_connection_header(conn), range, encoding,\n      EXTRA_HTTP_HEADERS);\n\n  if (strcmp(conn->request_info.request_method, \"HEAD\") != 0) {\n    send_file_data(conn, fp, r1, cl);\n  }\n  fclose(fp);\n}\n\nvoid mg_send_file(struct mg_connection *conn, const char *path) {\n  struct file file = STRUCT_FILE_INITIALIZER;\n  if (mg_stat(path, &file)) {\n    handle_file_request(conn, path, &file);\n  } else {\n    send_http_error(conn, 404, \"Not Found\", \"%s\", \"File not found\");\n  }\n}\n\n\n// Parse HTTP headers from the given buffer, advance buffer to the point\n// where parsing stopped.\nstatic void parse_http_headers(char **buf, struct mg_request_info *ri) {\n  int i;\n\n  for (i = 0; i < (int) ARRAY_SIZE(ri->http_headers); i++) {\n    ri->http_headers[i].name = skip_quoted(buf, \":\", \" \", 0);\n    ri->http_headers[i].value = skip(buf, \"\\r\\n\");\n    if (ri->http_headers[i].name[0] == '\\0')\n      break;\n    ri->num_headers = i + 1;\n  }\n}\n\nstatic int is_valid_http_method(const char *method) {\n  return !strcmp(method, \"GET\") || !strcmp(method, \"POST\") ||\n    !strcmp(method, \"HEAD\") || !strcmp(method, \"CONNECT\") ||\n    !strcmp(method, \"PUT\") || !strcmp(method, \"DELETE\") ||\n    !strcmp(method, \"OPTIONS\") || !strcmp(method, \"PROPFIND\")\n    || !strcmp(method, \"MKCOL\")\n          ;\n}\n\n// Parse HTTP request, fill in mg_request_info structure.\n// This function modifies the buffer by NUL-terminating\n// HTTP request components, header names and header values.\nstatic int parse_http_message(char *buf, int len, struct mg_request_info *ri) {\n  int is_request, request_length = get_request_len(buf, len);\n  if (request_length > 0) {\n    // Reset attributes. DO NOT TOUCH is_ssl, remote_ip, remote_port\n    ri->remote_user = ri->request_method = ri->uri = ri->http_version = NULL;\n    ri->num_headers = 0;\n\n    buf[request_length - 1] = '\\0';\n\n    // RFC says that all initial whitespaces should be ingored\n    while (*buf != '\\0' && isspace(* (unsigned char *) buf)) {\n      buf++;\n    }\n    ri->request_method = skip(&buf, \" \");\n    ri->uri = skip(&buf, \" \");\n    ri->http_version = skip(&buf, \"\\r\\n\");\n\n    // HTTP message could be either HTTP request or HTTP response, e.g.\n    // \"GET / HTTP/1.0 ....\" or  \"HTTP/1.0 200 OK ...\"\n    is_request = is_valid_http_method(ri->request_method);\n    if ((is_request && memcmp(ri->http_version, \"HTTP/\", 5) != 0) ||\n        (!is_request && memcmp(ri->request_method, \"HTTP/\", 5) != 0)) {\n      request_length = -1;\n    } else {\n      if (is_request) {\n        ri->http_version += 5;\n      }\n      parse_http_headers(&buf, ri);\n    }\n  }\n  return request_length;\n}\n\n// Keep reading the input (either opened file descriptor fd, or socket sock,\n// or SSL descriptor ssl) into buffer buf, until \\r\\n\\r\\n appears in the\n// buffer (which marks the end of HTTP request). Buffer buf may already\n// have some data. The length of the data is stored in nread.\n// Upon every read operation, increase nread by the number of bytes read.\nstatic int read_request(FILE *fp, struct mg_connection *conn,\n                        char *buf, int bufsiz, int *nread) {\n  int request_len, n = 0;\n\n  request_len = get_request_len(buf, *nread);\n  while (conn->ctx->stop_flag == 0 &&\n         *nread < bufsiz &&\n         request_len == 0 &&\n         (n = pull(fp, conn, buf + *nread, bufsiz - *nread)) > 0) {\n    *nread += n;\n    assert(*nread <= bufsiz);\n    request_len = get_request_len(buf, *nread);\n  }\n\n  return request_len <= 0 && n <= 0 ? -1 : request_len;\n}\n\n// For given directory path, substitute it to valid index file.\n// Return 0 if index file has been found, -1 if not found.\n// If the file is found, it's stats is returned in stp.\nstatic int substitute_index_file(struct mg_connection *conn, char *path,\n                                 size_t path_len, struct file *filep) {\n  const char *list = conn->ctx->config[INDEX_FILES];\n  struct file file = STRUCT_FILE_INITIALIZER;\n  struct vec filename_vec;\n  size_t n = strlen(path);\n  int found = 0;\n\n  // The 'path' given to us points to the directory. Remove all trailing\n  // directory separator characters from the end of the path, and\n  // then append single directory separator character.\n  while (n > 0 && path[n - 1] == '/') {\n    n--;\n  }\n  path[n] = '/';\n\n  // Traverse index files list. For each entry, append it to the given\n  // path and see if the file exists. If it exists, break the loop\n  while ((list = next_option(list, &filename_vec, NULL)) != NULL) {\n\n    // Ignore too long entries that may overflow path buffer\n    if (filename_vec.len > path_len - (n + 2))\n      continue;\n\n    // Prepare full path to the index file\n    mg_strlcpy(path + n + 1, filename_vec.ptr, filename_vec.len + 1);\n\n    // Does it exist?\n    if (mg_stat(path, &file)) {\n      // Yes it does, break the loop\n      *filep = file;\n      found = 1;\n      break;\n    }\n  }\n\n  // If no index file exists, restore directory path\n  if (!found) {\n    path[n] = '\\0';\n  }\n\n  return found;\n}\n\n// Return True if we should reply 304 Not Modified.\nstatic int is_not_modified(const struct mg_connection *conn,\n                           const struct file *filep) {\n  char etag[64];\n  const char *ims = mg_get_header(conn, \"If-Modified-Since\");\n  const char *inm = mg_get_header(conn, \"If-None-Match\");\n  construct_etag(etag, sizeof(etag), filep);\n  return (inm != NULL && !mg_strcasecmp(etag, inm)) ||\n    (ims != NULL && filep->modification_time <= parse_date_string(ims));\n}\n\nstatic int forward_body_data(struct mg_connection *conn, FILE *fp,\n                             SOCKET sock, SSL *ssl) {\n  const char *expect, *body;\n  char buf[MG_BUF_LEN];\n  int nread, buffered_len, success = 0;\n  int64_t left;\n\n  expect = mg_get_header(conn, \"Expect\");\n  assert(fp != NULL);\n\n  if (conn->content_len == INT64_MAX) {\n    send_http_error(conn, 411, \"Length Required\", \"%s\", \"\");\n  } else if (expect != NULL && mg_strcasecmp(expect, \"100-continue\")) {\n    send_http_error(conn, 417, \"Expectation Failed\", \"%s\", \"\");\n  } else {\n    if (expect != NULL) {\n      (void) mg_printf(conn, \"%s\", \"HTTP/1.1 100 Continue\\r\\n\\r\\n\");\n    }\n\n    buffered_len = conn->data_len - conn->request_len;\n    body = conn->buf + conn->request_len;\n    assert(buffered_len >= 0);\n\n    if (buffered_len > 0) {\n      if ((int64_t) buffered_len > conn->content_len) {\n        buffered_len = (int) conn->content_len;\n      }\n      push(fp, sock, ssl, body, (int64_t) buffered_len);\n      memmove((char *) body, body + buffered_len, buffered_len);\n      conn->data_len -= buffered_len;\n    }\n\n    nread = 0;\n    while (conn->num_bytes_read < conn->content_len + conn->request_len) {\n      left = left_to_read(conn);\n      if (left > (int64_t) sizeof(buf)) {\n        left = sizeof(buf);\n      }\n      nread = pull(NULL, conn, buf, (int) left);\n      if (nread <= 0 || push(fp, sock, ssl, buf, nread) != nread) {\n        break;\n      }\n    }\n\n    if (left_to_read(conn) == 0) {\n      success = nread >= 0;\n    }\n\n    // Each error code path in this function must send an error\n    if (!success) {\n      send_http_error(conn, 577, http_500_error, \"%s\", \"\");\n    }\n  }\n\n  return success;\n}\n\n#if !defined(NO_CGI)\n// This structure helps to create an environment for the spawned CGI program.\n// Environment is an array of \"VARIABLE=VALUE\\0\" ASCIIZ strings,\n// last element must be NULL.\n// However, on Windows there is a requirement that all these VARIABLE=VALUE\\0\n// strings must reside in a contiguous buffer. The end of the buffer is\n// marked by two '\\0' characters.\n// We satisfy both worlds: we create an envp array (which is vars), all\n// entries are actually pointers inside buf.\nstruct cgi_env_block {\n  struct mg_connection *conn;\n  char buf[CGI_ENVIRONMENT_SIZE]; // Environment buffer\n  int len; // Space taken\n  char *vars[MAX_CGI_ENVIR_VARS]; // char **envp\n  int nvars; // Number of variables\n};\n\nstatic char *addenv(struct cgi_env_block *block,\n                    PRINTF_FORMAT_STRING(const char *fmt), ...)\n  PRINTF_ARGS(2, 3);\n\n// Append VARIABLE=VALUE\\0 string to the buffer, and add a respective\n// pointer into the vars array.\nstatic char *addenv(struct cgi_env_block *block, const char *fmt, ...) {\n  int n, space;\n  char *added;\n  va_list ap;\n\n  // Calculate how much space is left in the buffer\n  space = sizeof(block->buf) - block->len - 2;\n  assert(space >= 0);\n\n  // Make a pointer to the free space int the buffer\n  added = block->buf + block->len;\n\n  // Copy VARIABLE=VALUE\\0 string into the free space\n  va_start(ap, fmt);\n  n = mg_vsnprintf(added, (size_t) space, fmt, ap);\n  va_end(ap);\n\n  // Make sure we do not overflow buffer and the envp array\n  if (n > 0 && n + 1 < space &&\n      block->nvars < (int) ARRAY_SIZE(block->vars) - 2) {\n    // Append a pointer to the added string into the envp array\n    block->vars[block->nvars++] = added;\n    // Bump up used length counter. Include \\0 terminator\n    block->len += n + 1;\n  } else {\n    cry(block->conn, \"%s: CGI env buffer truncated for [%s]\", __func__, fmt);\n  }\n\n  return added;\n}\n\nstatic void prepare_cgi_environment(struct mg_connection *conn,\n                                    const char *prog,\n                                    struct cgi_env_block *blk) {\n  const struct mg_request_info *ri = &conn->request_info;\n  const char *s, *slash;\n  struct vec var_vec;\n  char *p, src_addr[IP_ADDR_STR_LEN];\n  int  i;\n\n  blk->len = blk->nvars = 0;\n  blk->conn = conn;\n  sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);\n\n  addenv(blk, \"SERVER_NAME=%s\", conn->ctx->config[AUTHENTICATION_DOMAIN]);\n  addenv(blk, \"SERVER_ROOT=%s\", conn->ctx->config[DOCUMENT_ROOT]);\n  addenv(blk, \"DOCUMENT_ROOT=%s\", conn->ctx->config[DOCUMENT_ROOT]);\n  addenv(blk, \"SERVER_SOFTWARE=%s/%s\", \"Mongoose\", mg_version());\n\n  // Prepare the environment block\n  addenv(blk, \"%s\", \"GATEWAY_INTERFACE=CGI/1.1\");\n  addenv(blk, \"%s\", \"SERVER_PROTOCOL=HTTP/1.1\");\n  addenv(blk, \"%s\", \"REDIRECT_STATUS=200\"); // For PHP\n\n  // TODO(lsm): fix this for IPv6 case\n  addenv(blk, \"SERVER_PORT=%d\", ntohs(conn->client.lsa.sin.sin_port));\n\n  addenv(blk, \"REQUEST_METHOD=%s\", ri->request_method);\n  addenv(blk, \"REMOTE_ADDR=%s\", src_addr);\n  addenv(blk, \"REMOTE_PORT=%d\", ri->remote_port);\n  addenv(blk, \"REQUEST_URI=%s%s%s\", ri->uri,\n         ri->query_string == NULL ? \"\" : \"?\",\n         ri->query_string == NULL ? \"\" : ri->query_string);\n\n  // SCRIPT_NAME\n  if (conn->path_info != NULL) {\n    addenv(blk, \"SCRIPT_NAME=%.*s\",\n           (int) (strlen(ri->uri) - strlen(conn->path_info)), ri->uri);\n    addenv(blk, \"PATH_INFO=%s\", conn->path_info);\n  } else {\n    s = strrchr(prog, '/');\n    slash = strrchr(ri->uri, '/');\n    addenv(blk, \"SCRIPT_NAME=%.*s%s\",\n           slash == NULL ? 0 : (int) (slash - ri->uri), ri->uri,\n           s == NULL ? prog : s);\n  }\n\n  addenv(blk, \"SCRIPT_FILENAME=%s\", prog);\n  addenv(blk, \"PATH_TRANSLATED=%s\", prog);\n  addenv(blk, \"HTTPS=%s\", conn->ssl == NULL ? \"off\" : \"on\");\n\n  if ((s = mg_get_header(conn, \"Content-Type\")) != NULL)\n    addenv(blk, \"CONTENT_TYPE=%s\", s);\n\n  if (ri->query_string != NULL) {\n    addenv(blk, \"QUERY_STRING=%s\", ri->query_string);\n  }\n\n  if ((s = mg_get_header(conn, \"Content-Length\")) != NULL)\n    addenv(blk, \"CONTENT_LENGTH=%s\", s);\n\n  if ((s = getenv(\"PATH\")) != NULL)\n    addenv(blk, \"PATH=%s\", s);\n\n#if defined(_WIN32)\n  if ((s = getenv(\"COMSPEC\")) != NULL) {\n    addenv(blk, \"COMSPEC=%s\", s);\n  }\n  if ((s = getenv(\"SYSTEMROOT\")) != NULL) {\n    addenv(blk, \"SYSTEMROOT=%s\", s);\n  }\n  if ((s = getenv(\"SystemDrive\")) != NULL) {\n    addenv(blk, \"SystemDrive=%s\", s);\n  }\n  if ((s = getenv(\"ProgramFiles\")) != NULL) {\n    addenv(blk, \"ProgramFiles=%s\", s);\n  }\n  if ((s = getenv(\"ProgramFiles(x86)\")) != NULL) {\n    addenv(blk, \"ProgramFiles(x86)=%s\", s);\n  }\n  if ((s = getenv(\"CommonProgramFiles(x86)\")) != NULL) {\n    addenv(blk, \"CommonProgramFiles(x86)=%s\", s);\n  }\n#else\n  if ((s = getenv(\"LD_LIBRARY_PATH\")) != NULL)\n    addenv(blk, \"LD_LIBRARY_PATH=%s\", s);\n#endif // _WIN32\n\n  if ((s = getenv(\"PERLLIB\")) != NULL)\n    addenv(blk, \"PERLLIB=%s\", s);\n\n  if (ri->remote_user != NULL) {\n    addenv(blk, \"REMOTE_USER=%s\", ri->remote_user);\n    addenv(blk, \"%s\", \"AUTH_TYPE=Digest\");\n  }\n\n  // Add all headers as HTTP_* variables\n  for (i = 0; i < ri->num_headers; i++) {\n    p = addenv(blk, \"HTTP_%s=%s\",\n        ri->http_headers[i].name, ri->http_headers[i].value);\n\n    // Convert variable name into uppercase, and change - to _\n    for (; *p != '=' && *p != '\\0'; p++) {\n      if (*p == '-')\n        *p = '_';\n      *p = (char) toupper(* (unsigned char *) p);\n    }\n  }\n\n  // Add user-specified variables\n  s = conn->ctx->config[CGI_ENVIRONMENT];\n  while ((s = next_option(s, &var_vec, NULL)) != NULL) {\n    addenv(blk, \"%.*s\", (int) var_vec.len, var_vec.ptr);\n  }\n\n  blk->vars[blk->nvars++] = NULL;\n  blk->buf[blk->len++] = '\\0';\n\n  assert(blk->nvars < (int) ARRAY_SIZE(blk->vars));\n  assert(blk->len > 0);\n  assert(blk->len < (int) sizeof(blk->buf));\n}\n\nstatic void handle_cgi_request(struct mg_connection *conn, const char *prog) {\n  int headers_len, data_len, i, fdin[2], fdout[2];\n  const char *status, *status_text;\n  char buf[16384], *pbuf, dir[PATH_MAX], *p;\n  struct mg_request_info ri;\n  struct cgi_env_block blk;\n  FILE *in = NULL, *out = NULL;\n  pid_t pid = (pid_t) -1;\n\n  prepare_cgi_environment(conn, prog, &blk);\n\n  // CGI must be executed in its own directory. 'dir' must point to the\n  // directory containing executable program, 'p' must point to the\n  // executable program name relative to 'dir'.\n  (void) mg_snprintf(dir, sizeof(dir), \"%s\", prog);\n  if ((p = strrchr(dir, '/')) != NULL) {\n    *p++ = '\\0';\n  } else {\n    dir[0] = '.', dir[1] = '\\0';\n    p = (char *) prog;\n  }\n\n  if (pipe(fdin) != 0 || pipe(fdout) != 0) {\n    send_http_error(conn, 500, http_500_error,\n        \"Cannot create CGI pipe: %s\", strerror(ERRNO));\n    goto done;\n  }\n\n  pid = spawn_process(conn, p, blk.buf, blk.vars, fdin[0], fdout[1], dir);\n  if (pid == (pid_t) -1) {\n    send_http_error(conn, 500, http_500_error,\n        \"Cannot spawn CGI process [%s]: %s\", prog, strerror(ERRNO));\n    goto done;\n  }\n\n  // Make sure child closes all pipe descriptors. It must dup them to 0,1\n  set_close_on_exec(fdin[0]);\n  set_close_on_exec(fdin[1]);\n  set_close_on_exec(fdout[0]);\n  set_close_on_exec(fdout[1]);\n\n  // Parent closes only one side of the pipes.\n  // If we don't mark them as closed, close() attempt before\n  // return from this function throws an exception on Windows.\n  // Windows does not like when closed descriptor is closed again.\n  (void) close(fdin[0]);\n  (void) close(fdout[1]);\n  fdin[0] = fdout[1] = -1;\n\n\n  if ((in = fdopen(fdin[1], \"wb\")) == NULL ||\n      (out = fdopen(fdout[0], \"rb\")) == NULL) {\n    send_http_error(conn, 500, http_500_error,\n        \"fopen: %s\", strerror(ERRNO));\n    goto done;\n  }\n\n  setbuf(in, NULL);\n  setbuf(out, NULL);\n\n  // Send POST data to the CGI process if needed\n  if (!strcmp(conn->request_info.request_method, \"POST\") &&\n      !forward_body_data(conn, in, INVALID_SOCKET, NULL)) {\n    goto done;\n  }\n\n  // Close so child gets an EOF.\n  fclose(in);\n  in = NULL;\n  fdin[1] = -1;\n\n  // Now read CGI reply into a buffer. We need to set correct\n  // status code, thus we need to see all HTTP headers first.\n  // Do not send anything back to client, until we buffer in all\n  // HTTP headers.\n  data_len = 0;\n  headers_len = read_request(out, conn, buf, sizeof(buf), &data_len);\n  if (headers_len <= 0) {\n    send_http_error(conn, 500, http_500_error,\n                    \"CGI program sent malformed or too big (>%u bytes) \"\n                    \"HTTP headers: [%.*s]\",\n                    (unsigned) sizeof(buf), data_len, buf);\n    goto done;\n  }\n  pbuf = buf;\n  buf[headers_len - 1] = '\\0';\n  parse_http_headers(&pbuf, &ri);\n\n  // Make up and send the status line\n  status_text = \"OK\";\n  if ((status = get_header(&ri, \"Status\")) != NULL) {\n    conn->status_code = atoi(status);\n    status_text = status;\n    while (isdigit(* (unsigned char *) status_text) || *status_text == ' ') {\n      status_text++;\n    }\n  } else if (get_header(&ri, \"Location\") != NULL) {\n    conn->status_code = 302;\n  } else {\n    conn->status_code = 200;\n  }\n  if (get_header(&ri, \"Connection\") != NULL &&\n      !mg_strcasecmp(get_header(&ri, \"Connection\"), \"keep-alive\")) {\n    conn->must_close = 1;\n  }\n  (void) mg_printf(conn, \"HTTP/1.1 %d %s\\r\\n\", conn->status_code,\n                   status_text);\n\n  // Send headers\n  for (i = 0; i < ri.num_headers; i++) {\n    mg_printf(conn, \"%s: %s\\r\\n\",\n              ri.http_headers[i].name, ri.http_headers[i].value);\n  }\n  mg_write(conn, \"\\r\\n\", 2);\n\n  // Send chunk of data that may have been read after the headers\n  conn->num_bytes_sent += mg_write(conn, buf + headers_len,\n                                   (size_t)(data_len - headers_len));\n\n  // Read the rest of CGI output and send to the client\n  send_file_data(conn, out, 0, INT64_MAX);\n\ndone:\n  if (pid != (pid_t) -1) {\n    kill(pid, SIGKILL);\n  }\n  if (fdin[0] != -1) {\n    close(fdin[0]);\n  }\n  if (fdout[1] != -1) {\n    close(fdout[1]);\n  }\n\n  if (in != NULL) {\n    fclose(in);\n  } else if (fdin[1] != -1) {\n    close(fdin[1]);\n  }\n\n  if (out != NULL) {\n    fclose(out);\n  } else if (fdout[0] != -1) {\n    close(fdout[0]);\n  }\n}\n#endif // !NO_CGI\n\n// For a given PUT path, create all intermediate subdirectories\n// for given path. Return 0 if the path itself is a directory,\n// or -1 on error, 1 if OK.\nstatic int put_dir(const char *path) {\n  char buf[PATH_MAX];\n  const char *s, *p;\n  struct file file = STRUCT_FILE_INITIALIZER;\n  int len, res = 1;\n\n  for (s = p = path + 2; (p = strchr(s, '/')) != NULL; s = ++p) {\n    len = p - path;\n    if (len >= (int) sizeof(buf)) {\n      res = -1;\n      break;\n    }\n    memcpy(buf, path, len);\n    buf[len] = '\\0';\n\n    // Try to create intermediate directory\n    DEBUG_TRACE((\"mkdir(%s)\", buf));\n    if (!mg_stat(buf, &file) && mg_mkdir(buf, 0755) != 0) {\n      res = -1;\n      break;\n    }\n\n    // Is path itself a directory?\n    if (p[1] == '\\0') {\n      res = 0;\n    }\n  }\n\n  return res;\n}\n\nstatic void mkcol(struct mg_connection *conn, const char *path) {\n  int rc, body_len;\n  struct de de;\n\n  memset(&de.file, 0, sizeof(de.file));\n  mg_stat(path, &de.file);\n\n  if (de.file.modification_time) {\n      send_http_error(conn, 405, \"Method Not Allowed\",\n                      \"mkcol(%s): %s\", path, strerror(ERRNO));\n      return;\n  }\n\n  body_len = conn->data_len - conn->request_len;\n  if(body_len > 0) {\n      send_http_error(conn, 415, \"Unsupported media type\",\n                      \"mkcol(%s): %s\", path, strerror(ERRNO));\n      return;\n  }\n\n  rc = mg_mkdir(path, 0755);\n\n  if (rc == 0) {\n    conn->status_code = 201;\n    mg_printf(conn, \"HTTP/1.1 %d Created\\r\\n\\r\\n\", conn->status_code);\n  } else if (rc == -1) {\n      if(errno == EEXIST)\n        send_http_error(conn, 405, \"Method Not Allowed\",\n                      \"mkcol(%s): %s\", path, strerror(ERRNO));\n      else if(errno == EACCES)\n          send_http_error(conn, 403, \"Forbidden\",\n                        \"mkcol(%s): %s\", path, strerror(ERRNO));\n      else if(errno == ENOENT)\n          send_http_error(conn, 409, \"Conflict\",\n                        \"mkcol(%s): %s\", path, strerror(ERRNO));\n      else\n          send_http_error(conn, 500, http_500_error,\n                          \"fopen(%s): %s\", path, strerror(ERRNO));\n  }\n}\n\nstatic void put_file(struct mg_connection *conn, const char *path) {\n  struct file file = STRUCT_FILE_INITIALIZER;\n  FILE *fp;\n  const char *range;\n  int64_t r1, r2;\n  int rc;\n\n  conn->status_code = mg_stat(path, &file) ? 200 : 201;\n\n  if ((rc = put_dir(path)) == 0) {\n    mg_printf(conn, \"HTTP/1.1 %d OK\\r\\n\\r\\n\", conn->status_code);\n  } else if (rc == -1) {\n    send_http_error(conn, 500, http_500_error,\n                    \"put_dir(%s): %s\", path, strerror(ERRNO));\n  } else if ((fp = mg_fopen(path, \"wb+\")) == NULL) {\n    fclose(fp);\n    send_http_error(conn, 500, http_500_error,\n                    \"fopen(%s): %s\", path, strerror(ERRNO));\n  } else {\n    fclose_on_exec(fp);\n    range = mg_get_header(conn, \"Content-Range\");\n    r1 = r2 = 0;\n    if (range != NULL && parse_range_header(range, &r1, &r2) > 0) {\n      conn->status_code = 206;\n      fseeko(fp, r1, SEEK_SET);\n    }\n    if (!forward_body_data(conn, fp, INVALID_SOCKET, NULL)) {\n      conn->status_code = 500;\n    }\n    mg_printf(conn, \"HTTP/1.1 %d OK\\r\\nContent-Length: 0\\r\\n\\r\\n\",\n              conn->status_code);\n    fclose(fp);\n  }\n}\n\nstatic void send_ssi_file(struct mg_connection *, const char *, FILE *, int);\nstatic void do_ssi_include(struct mg_connection *conn, const char *ssi,\n                           char *tag, int include_level) {\n  char file_name[MG_BUF_LEN], path[PATH_MAX], *p;\n  FILE *fp;\n\n  // sscanf() is safe here, since send_ssi_file() also uses buffer\n  // of size MG_BUF_LEN to get the tag. So strlen(tag) is always < MG_BUF_LEN.\n  if (sscanf(tag, \" virtual=\\\"%[^\\\"]\\\"\", file_name) == 1) {\n    // File name is relative to the webserver root\n    (void) mg_snprintf(path, sizeof(path), \"%s%c%s\",\n        conn->ctx->config[DOCUMENT_ROOT], '/', file_name);\n  } else if (sscanf(tag, \" abspath=\\\"%[^\\\"]\\\"\", file_name) == 1) {\n    // File name is relative to the webserver working directory\n    // or it is absolute system path\n    (void) mg_snprintf(path, sizeof(path), \"%s\", file_name);\n  } else if (sscanf(tag, \" file=\\\"%[^\\\"]\\\"\", file_name) == 1 ||\n             sscanf(tag, \" \\\"%[^\\\"]\\\"\", file_name) == 1) {\n    // File name is relative to the currect document\n    (void) mg_snprintf(path, sizeof(path), \"%s\", ssi);\n    if ((p = strrchr(path, '/')) != NULL) {\n      p[1] = '\\0';\n    }\n    (void) mg_snprintf(path + strlen(path),\n        sizeof(path) - strlen(path), \"%s\", file_name);\n  } else {\n    cry(conn, \"Bad SSI #include: [%s]\", tag);\n    return;\n  }\n\n  if ((fp = mg_fopen(path, \"rb\")) == NULL) {\n    cry(conn, \"Cannot open SSI #include: [%s]: fopen(%s): %s\",\n        tag, path, strerror(ERRNO));\n  } else {\n    fclose_on_exec(fp);\n    if (match_prefix(conn->ctx->config[SSI_EXTENSIONS],\n                     strlen(conn->ctx->config[SSI_EXTENSIONS]), path) > 0) {\n      send_ssi_file(conn, path, fp, include_level + 1);\n    } else {\n      send_file_data(conn, fp, 0, INT64_MAX);\n    }\n    fclose(fp);\n  }\n}\n\n#if !defined(NO_POPEN)\nstatic void do_ssi_exec(struct mg_connection *conn, char *tag) {\n  char cmd[MG_BUF_LEN];\n  FILE *fp;\n\n  if (sscanf(tag, \" \\\"%[^\\\"]\\\"\", cmd) != 1) {\n    cry(conn, \"Bad SSI #exec: [%s]\", tag);\n  } else if ((fp = popen(cmd, \"r\")) == NULL) {\n    cry(conn, \"Cannot SSI #exec: [%s]: %s\", cmd, strerror(ERRNO));\n  } else {\n    send_file_data(conn, fp, 0, INT64_MAX);\n    pclose(fp);\n  }\n}\n#endif // !NO_POPEN\n\nstatic void send_ssi_file(struct mg_connection *conn, const char *path,\n                          FILE *fp, int include_level) {\n  char buf[MG_BUF_LEN];\n  int ch, offset, len, in_ssi_tag;\n\n  if (include_level > 10) {\n    cry(conn, \"SSI #include level is too deep (%s)\", path);\n    return;\n  }\n\n  in_ssi_tag = len = offset = 0;\n  while ((ch = fgetc(fp)) != EOF) {\n    if (in_ssi_tag && ch == '>') {\n      in_ssi_tag = 0;\n      buf[len++] = (char) ch;\n      buf[len] = '\\0';\n      assert(len <= (int) sizeof(buf));\n      if (len < 6 || memcmp(buf, \"<!--#\", 5) != 0) {\n        // Not an SSI tag, pass it\n        (void) mg_write(conn, buf, (size_t) len);\n      } else {\n        if (!memcmp(buf + 5, \"include\", 7)) {\n          do_ssi_include(conn, path, buf + 12, include_level);\n#if !defined(NO_POPEN)\n        } else if (!memcmp(buf + 5, \"exec\", 4)) {\n          do_ssi_exec(conn, buf + 9);\n#endif // !NO_POPEN\n        } else {\n          cry(conn, \"%s: unknown SSI \" \"command: \\\"%s\\\"\", path, buf);\n        }\n      }\n      len = 0;\n    } else if (in_ssi_tag) {\n      if (len == 5 && memcmp(buf, \"<!--#\", 5) != 0) {\n        // Not an SSI tag\n        in_ssi_tag = 0;\n      } else if (len == (int) sizeof(buf) - 2) {\n        cry(conn, \"%s: SSI tag is too large\", path);\n        len = 0;\n      }\n      buf[len++] = ch & 0xff;\n    } else if (ch == '<') {\n      in_ssi_tag = 1;\n      if (len > 0) {\n        mg_write(conn, buf, (size_t) len);\n      }\n      len = 0;\n      buf[len++] = ch & 0xff;\n    } else {\n      buf[len++] = ch & 0xff;\n      if (len == (int) sizeof(buf)) {\n        mg_write(conn, buf, (size_t) len);\n        len = 0;\n      }\n    }\n  }\n\n  // Send the rest of buffered data\n  if (len > 0) {\n    mg_write(conn, buf, (size_t) len);\n  }\n}\n\nstatic void handle_ssi_file_request(struct mg_connection *conn,\n                                    const char *path) {\n  struct vec mime_vec;\n  FILE *fp;\n\n  if ((fp = mg_fopen(path, \"rb\")) == NULL) {\n    send_http_error(conn, 500, http_500_error, \"fopen(%s): %s\", path,\n                    strerror(ERRNO));\n  } else {\n    conn->must_close = 1;\n    fclose_on_exec(fp);\n    get_mime_type(conn->ctx, path, &mime_vec);\n    mg_printf(conn, \"HTTP/1.1 200 OK\\r\\n\"\n              \"Content-Type: %.*s\\r\\n\"\n              \"Connection: close\\r\\n\\r\\n\",\n              (int) mime_vec.len, mime_vec.ptr);\n    send_ssi_file(conn, path, fp, 0);\n    fclose(fp);\n  }\n}\n\nstatic void handle_options_request(struct mg_connection *conn) {\n  static const char reply[] = \"HTTP/1.1 200 OK\\r\\n\"\n    \"Allow: GET, POST, HEAD, CONNECT, PUT, DELETE, OPTIONS, PROPFIND, MKCOL\\r\\n\"\n    \"DAV: 1\\r\\n\\r\\n\";\n\n  conn->status_code = 200;\n  mg_write(conn, reply, sizeof(reply) - 1);\n}\n\n// Writes PROPFIND properties for a collection element\nstatic void print_props(struct mg_connection *conn, const char* uri,\n                        struct file *filep) {\n  char mtime[64];\n  gmt_time_string(mtime, sizeof(mtime), &filep->modification_time);\n  conn->num_bytes_sent += mg_printf(conn,\n      \"<d:response>\"\n       \"<d:href>%s</d:href>\"\n       \"<d:propstat>\"\n        \"<d:prop>\"\n         \"<d:resourcetype>%s</d:resourcetype>\"\n         \"<d:getcontentlength>%\" INT64_FMT \"</d:getcontentlength>\"\n         \"<d:getlastmodified>%s</d:getlastmodified>\"\n        \"</d:prop>\"\n        \"<d:status>HTTP/1.1 200 OK</d:status>\"\n       \"</d:propstat>\"\n      \"</d:response>\\n\",\n      uri,\n      filep->is_directory ? \"<d:collection/>\" : \"\",\n      filep->size,\n      mtime);\n}\n\nstatic void print_dav_dir_entry(struct de *de, void *data) {\n  char href[PATH_MAX];\n  char href_encoded[PATH_MAX];\n  struct mg_connection *conn = (struct mg_connection *) data;\n  mg_snprintf(href, sizeof(href), \"%s%s\",\n              conn->request_info.uri, de->file_name);\n  mg_url_encode(href, href_encoded, PATH_MAX-1);\n  print_props(conn, href_encoded, &de->file);\n}\n\nstatic void handle_propfind(struct mg_connection *conn, const char *path,\n                            struct file *filep) {\n  const char *depth = mg_get_header(conn, \"Depth\");\n\n  conn->must_close = 1;\n  conn->status_code = 207;\n  mg_printf(conn, \"HTTP/1.1 207 Multi-Status\\r\\n\"\n            \"Connection: close\\r\\n\"\n            \"Content-Type: text/xml; charset=utf-8\\r\\n\\r\\n\");\n\n  conn->num_bytes_sent += mg_printf(conn,\n      \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\"\n      \"<d:multistatus xmlns:d='DAV:'>\\n\");\n\n  // Print properties for the requested resource itself\n  print_props(conn, conn->request_info.uri, filep);\n\n  // If it is a directory, print directory entries too if Depth is not 0\n  if (filep->is_directory &&\n      !mg_strcasecmp(conn->ctx->config[ENABLE_DIRECTORY_LISTING], \"yes\") &&\n      (depth == NULL || strcmp(depth, \"0\") != 0)) {\n    scan_directory(conn, path, conn, &print_dav_dir_entry);\n  }\n\n  conn->num_bytes_sent += mg_printf(conn, \"%s\\n\", \"</d:multistatus>\");\n}\n\n#if defined(USE_WEBSOCKET)\n\n// START OF SHA-1 code\n// Copyright(c) By Steve Reid <steve@edmweb.com>\n#define SHA1HANDSOFF\n#if defined(__sun)\n#include \"solarisfixes.h\"\n#endif\n\nunion char64long16 { unsigned char c[64]; uint32_t l[16]; };\n\n#define rol(value, bits) (((value) << (bits)) | ((value) >> (32 - (bits))))\n\nstatic uint32_t blk0(union char64long16 *block, int i) {\n  // Forrest: SHA expect BIG_ENDIAN, swap if LITTLE_ENDIAN\n  if (!is_big_endian()) {\n    block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |\n      (rol(block->l[i], 8) & 0x00FF00FF);\n  }\n  return block->l[i];\n}\n\n#define blk(i) (block->l[i&15] = rol(block->l[(i+13)&15]^block->l[(i+8)&15] \\\n    ^block->l[(i+2)&15]^block->l[i&15],1))\n#define R0(v,w,x,y,z,i) z+=((w&(x^y))^y)+blk0(block, i)+0x5A827999+rol(v,5);w=rol(w,30);\n#define R1(v,w,x,y,z,i) z+=((w&(x^y))^y)+blk(i)+0x5A827999+rol(v,5);w=rol(w,30);\n#define R2(v,w,x,y,z,i) z+=(w^x^y)+blk(i)+0x6ED9EBA1+rol(v,5);w=rol(w,30);\n#define R3(v,w,x,y,z,i) z+=(((w|x)&y)|(w&x))+blk(i)+0x8F1BBCDC+rol(v,5);w=rol(w,30);\n#define R4(v,w,x,y,z,i) z+=(w^x^y)+blk(i)+0xCA62C1D6+rol(v,5);w=rol(w,30);\n\ntypedef struct {\n    uint32_t state[5];\n    uint32_t count[2];\n    unsigned char buffer[64];\n} SHA1_CTX;\n\nstatic void SHA1Transform(uint32_t state[5], const unsigned char buffer[64]) {\n  uint32_t a, b, c, d, e;\n  union char64long16 block[1];\n\n  memcpy(block, buffer, 64);\n  a = state[0];\n  b = state[1];\n  c = state[2];\n  d = state[3];\n  e = state[4];\n  R0(a,b,c,d,e, 0); R0(e,a,b,c,d, 1); R0(d,e,a,b,c, 2); R0(c,d,e,a,b, 3);\n  R0(b,c,d,e,a, 4); R0(a,b,c,d,e, 5); R0(e,a,b,c,d, 6); R0(d,e,a,b,c, 7);\n  R0(c,d,e,a,b, 8); R0(b,c,d,e,a, 9); R0(a,b,c,d,e,10); R0(e,a,b,c,d,11);\n  R0(d,e,a,b,c,12); R0(c,d,e,a,b,13); R0(b,c,d,e,a,14); R0(a,b,c,d,e,15);\n  R1(e,a,b,c,d,16); R1(d,e,a,b,c,17); R1(c,d,e,a,b,18); R1(b,c,d,e,a,19);\n  R2(a,b,c,d,e,20); R2(e,a,b,c,d,21); R2(d,e,a,b,c,22); R2(c,d,e,a,b,23);\n  R2(b,c,d,e,a,24); R2(a,b,c,d,e,25); R2(e,a,b,c,d,26); R2(d,e,a,b,c,27);\n  R2(c,d,e,a,b,28); R2(b,c,d,e,a,29); R2(a,b,c,d,e,30); R2(e,a,b,c,d,31);\n  R2(d,e,a,b,c,32); R2(c,d,e,a,b,33); R2(b,c,d,e,a,34); R2(a,b,c,d,e,35);\n  R2(e,a,b,c,d,36); R2(d,e,a,b,c,37); R2(c,d,e,a,b,38); R2(b,c,d,e,a,39);\n  R3(a,b,c,d,e,40); R3(e,a,b,c,d,41); R3(d,e,a,b,c,42); R3(c,d,e,a,b,43);\n  R3(b,c,d,e,a,44); R3(a,b,c,d,e,45); R3(e,a,b,c,d,46); R3(d,e,a,b,c,47);\n  R3(c,d,e,a,b,48); R3(b,c,d,e,a,49); R3(a,b,c,d,e,50); R3(e,a,b,c,d,51);\n  R3(d,e,a,b,c,52); R3(c,d,e,a,b,53); R3(b,c,d,e,a,54); R3(a,b,c,d,e,55);\n  R3(e,a,b,c,d,56); R3(d,e,a,b,c,57); R3(c,d,e,a,b,58); R3(b,c,d,e,a,59);\n  R4(a,b,c,d,e,60); R4(e,a,b,c,d,61); R4(d,e,a,b,c,62); R4(c,d,e,a,b,63);\n  R4(b,c,d,e,a,64); R4(a,b,c,d,e,65); R4(e,a,b,c,d,66); R4(d,e,a,b,c,67);\n  R4(c,d,e,a,b,68); R4(b,c,d,e,a,69); R4(a,b,c,d,e,70); R4(e,a,b,c,d,71);\n  R4(d,e,a,b,c,72); R4(c,d,e,a,b,73); R4(b,c,d,e,a,74); R4(a,b,c,d,e,75);\n  R4(e,a,b,c,d,76); R4(d,e,a,b,c,77); R4(c,d,e,a,b,78); R4(b,c,d,e,a,79);\n  state[0] += a;\n  state[1] += b;\n  state[2] += c;\n  state[3] += d;\n  state[4] += e;\n  a = b = c = d = e = 0;\n  memset(block, '\\0', sizeof(block));\n}\n\nstatic void SHA1Init(SHA1_CTX* context) {\n  context->state[0] = 0x67452301;\n  context->state[1] = 0xEFCDAB89;\n  context->state[2] = 0x98BADCFE;\n  context->state[3] = 0x10325476;\n  context->state[4] = 0xC3D2E1F0;\n  context->count[0] = context->count[1] = 0;\n}\n\nstatic void SHA1Update(SHA1_CTX* context, const unsigned char* data,\n                       uint32_t len) {\n  uint32_t i, j;\n\n  j = context->count[0];\n  if ((context->count[0] += len << 3) < j)\n    context->count[1]++;\n  context->count[1] += (len>>29);\n  j = (j >> 3) & 63;\n  if ((j + len) > 63) {\n    memcpy(&context->buffer[j], data, (i = 64-j));\n    SHA1Transform(context->state, context->buffer);\n    for ( ; i + 63 < len; i += 64) {\n      SHA1Transform(context->state, &data[i]);\n    }\n    j = 0;\n  }\n  else i = 0;\n  memcpy(&context->buffer[j], &data[i], len - i);\n}\n\nstatic void SHA1Final(unsigned char digest[20], SHA1_CTX* context) {\n  unsigned i;\n  unsigned char finalcount[8], c;\n\n  for (i = 0; i < 8; i++) {\n    finalcount[i] = (unsigned char)((context->count[(i >= 4 ? 0 : 1)]\n                                     >> ((3-(i & 3)) * 8) ) & 255);\n  }\n  c = 0200;\n  SHA1Update(context, &c, 1);\n  while ((context->count[0] & 504) != 448) {\n    c = 0000;\n    SHA1Update(context, &c, 1);\n  }\n  SHA1Update(context, finalcount, 8);\n  for (i = 0; i < 20; i++) {\n    digest[i] = (unsigned char)\n      ((context->state[i>>2] >> ((3-(i & 3)) * 8) ) & 255);\n  }\n  memset(context, '\\0', sizeof(*context));\n  memset(&finalcount, '\\0', sizeof(finalcount));\n}\n// END OF SHA1 CODE\n\nstatic void base64_encode(const unsigned char *src, int src_len, char *dst) {\n  static const char *b64 =\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n  int i, j, a, b, c;\n\n  for (i = j = 0; i < src_len; i += 3) {\n    a = src[i];\n    b = i + 1 >= src_len ? 0 : src[i + 1];\n    c = i + 2 >= src_len ? 0 : src[i + 2];\n\n    dst[j++] = b64[a >> 2];\n    dst[j++] = b64[((a & 3) << 4) | (b >> 4)];\n    if (i + 1 < src_len) {\n      dst[j++] = b64[(b & 15) << 2 | (c >> 6)];\n    }\n    if (i + 2 < src_len) {\n      dst[j++] = b64[c & 63];\n    }\n  }\n  while (j % 4 != 0) {\n    dst[j++] = '=';\n  }\n  dst[j++] = '\\0';\n}\n\nvoid mg_websocket_handshake(struct mg_connection *conn) {\n  static const char *magic = \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\";\n  char buf[100], sha[20], b64_sha[sizeof(sha) * 2];\n  SHA1_CTX sha_ctx;\n\n  mg_snprintf(buf, sizeof(buf), \"%s%s\",\n              mg_get_header(conn, \"Sec-WebSocket-Key\"), magic);\n  SHA1Init(&sha_ctx);\n  SHA1Update(&sha_ctx, (unsigned char *) buf, strlen(buf));\n  SHA1Final((unsigned char *) sha, &sha_ctx);\n  base64_encode((unsigned char *) sha, sizeof(sha), b64_sha);\n  mg_printf(conn, \"%s%s%s\",\n            \"HTTP/1.1 101 Switching Protocols\\r\\n\"\n            \"Upgrade: websocket\\r\\n\"\n            \"Connection: Upgrade\\r\\n\"\n            \"Sec-WebSocket-Accept: \", b64_sha, \"\\r\\n\\r\\n\");\n}\n\nint mg_websocket_read(struct mg_connection *conn, int *bits, char **data) {\n  // Pointer to the beginning of the portion of the incoming websocket message\n  // queue. The original websocket upgrade request is never removed,\n  // so the queue begins after it.\n  unsigned char *buf = (unsigned char *) conn->buf + conn->request_len;\n  int n, stop = 0;\n  size_t i, len, mask_len, data_len, header_len, body_len;\n  char mask[4];\n\n  assert(conn->content_len == 0);\n\n  // Loop continuously, reading messages from the socket, invoking the callback,\n  // and waiting repeatedly until an error occurs.\n  while (!stop) {\n    header_len = 0;\n    // body_len is the length of the entire queue in bytes\n    // len is the length of the current message\n    // data_len is the length of the current message's data payload\n    // header_len is the length of the current message's header\n    if ((body_len = conn->data_len - conn->request_len) >= 2) {\n      len = buf[1] & 127;\n      mask_len = buf[1] & 128 ? 4 : 0;\n      if (len < 126 && body_len >= mask_len) {\n        data_len = len;\n        header_len = 2 + mask_len;\n      } else if (len == 126 && body_len >= 4 + mask_len) {\n        header_len = 4 + mask_len;\n        data_len = ((((int) buf[2]) << 8) + buf[3]);\n      } else if (body_len >= 10 + mask_len) {\n        header_len = 10 + mask_len;\n        data_len = (((uint64_t) htonl(* (uint32_t *) &buf[2])) << 32) +\n          htonl(* (uint32_t *) &buf[6]);\n      }\n    }\n\n    // Data layout is as follows:\n    //  conn->buf               buf\n    //     v                     v              frame1           | frame2\n    //     |---------------------|----------------|--------------|-------\n    //     |                     |<--header_len-->|<--data_len-->|\n    //     |<-conn->request_len->|<-----body_len----------->|\n    //     |<-------------------conn->data_len------------->|\n\n    if (header_len > 0) {\n      // Allocate space to hold websocket payload\n      if ((*data = malloc(data_len)) == NULL) {\n        // Allocation failed, exit the loop and then close the connection\n        // TODO: notify user about the failure\n        data_len = 0;\n        break;\n      }\n\n      // Save mask and bits, otherwise it may be clobbered by memmove below\n      *bits = buf[0];\n      memcpy(mask, buf + header_len - mask_len, mask_len);\n\n      // Read frame payload into the allocated buffer.\n      assert(body_len >= header_len);\n      if (data_len + header_len > body_len) {\n        len = body_len - header_len;\n        memcpy(*data, buf + header_len, len);\n        // TODO: handle pull error\n        pull_all(NULL, conn, *data + len, data_len - len);\n        conn->data_len = conn->request_len;\n      } else {\n        len = data_len + header_len;\n        memcpy(*data, buf + header_len, data_len);\n        memmove(buf, buf + len, body_len - len);\n        conn->data_len -= len;\n      }\n\n      // Apply mask if necessary\n      if (mask_len > 0) {\n        for (i = 0; i < data_len; i++) {\n          (*data)[i] ^= mask[i % 4];\n        }\n      }\n\n      return data_len;\n    } else {\n      // Buffering websocket request\n      if ((n = pull(NULL, conn, conn->buf + conn->data_len,\n                    conn->buf_size - conn->data_len)) <= 0) {\n        break;\n      }\n      conn->data_len += n;\n    }\n  }\n\n  return 0;\n}\n\nint mg_websocket_write(struct mg_connection* conn, int opcode,\n                       const char *data, size_t data_len) {\n    unsigned char *copy;\n    size_t copy_len = 0;\n    int retval = -1;\n\n    if ((copy = (unsigned char *) malloc(data_len + 10)) == NULL) {\n      return -1;\n    }\n\n    copy[0] = 0x80 + (opcode & 0x0f);\n\n    // Frame format: http://tools.ietf.org/html/rfc6455#section-5.2\n    if (data_len < 126) {\n      // Inline 7-bit length field\n      copy[1] = data_len;\n      memcpy(copy + 2, data, data_len);\n      copy_len = 2 + data_len;\n    } else if (data_len <= 0xFFFF) {\n      // 16-bit length field\n      copy[1] = 126;\n      * (uint16_t *) (copy + 2) = htons(data_len);\n      memcpy(copy + 4, data, data_len);\n      copy_len = 4 + data_len;\n    } else {\n      // 64-bit length field\n      copy[1] = 127;\n      * (uint32_t *) (copy + 2) = htonl((uint64_t) data_len >> 32);\n      * (uint32_t *) (copy + 6) = htonl(data_len & 0xffffffff);\n      memcpy(copy + 10, data, data_len);\n      copy_len = 10 + data_len;\n    }\n\n    // Not thread safe\n    if (copy_len > 0) {\n      retval = mg_write(conn, copy, copy_len);\n    }\n    free(copy);\n\n    return retval;\n}\n#endif // !USE_WEBSOCKET\n\nstatic int isbyte(int n) {\n  return n >= 0 && n <= 255;\n}\n\nstatic int parse_net(const char *spec, uint32_t *net, uint32_t *mask) {\n  int n, a, b, c, d, slash = 32, len = 0;\n\n  if ((sscanf(spec, \"%d.%d.%d.%d/%d%n\", &a, &b, &c, &d, &slash, &n) == 5 ||\n      sscanf(spec, \"%d.%d.%d.%d%n\", &a, &b, &c, &d, &n) == 4) &&\n      isbyte(a) && isbyte(b) && isbyte(c) && isbyte(d) &&\n      slash >= 0 && slash < 33) {\n    len = n;\n    *net = ((uint32_t)a << 24) | ((uint32_t)b << 16) | ((uint32_t)c << 8) | d;\n    *mask = slash ? 0xffffffffU << (32 - slash) : 0;\n  }\n\n  return len;\n}\n\nstatic int set_throttle(const char *spec, uint32_t remote_ip, const char *uri) {\n  int throttle = 0;\n  struct vec vec, val;\n  uint32_t net, mask;\n  char mult;\n  double v;\n\n  while ((spec = next_option(spec, &vec, &val)) != NULL) {\n    mult = ',';\n    if (sscanf(val.ptr, \"%lf%c\", &v, &mult) < 1 || v < 0 ||\n        (lowercase(&mult) != 'k' && lowercase(&mult) != 'm' && mult != ',')) {\n      continue;\n    }\n    v *= lowercase(&mult) == 'k' ? 1024 : lowercase(&mult) == 'm' ? 1048576 : 1;\n    if (vec.len == 1 && vec.ptr[0] == '*') {\n      throttle = (int) v;\n    } else if (parse_net(vec.ptr, &net, &mask) > 0) {\n      if ((remote_ip & mask) == net) {\n        throttle = (int) v;\n      }\n    } else if (match_prefix(vec.ptr, vec.len, uri) > 0) {\n      throttle = (int) v;\n    }\n  }\n\n  return throttle;\n}\n\nstatic uint32_t get_remote_ip(const struct mg_connection *conn) {\n  return ntohl(* (uint32_t *) &conn->client.rsa.sin.sin_addr);\n}\n\nFILE *mg_upload(struct mg_connection *conn, const char *destination_dir,\n                char *path, int path_len) {\n  const char *content_type_header, *boundary_start;\n  char *buf, fname[1024], boundary[100], *s;\n  int bl, n, i, j, headers_len, boundary_len, eof, buf_len, to_read, len = 0;\n  FILE *fp;\n\n  // Request looks like this:\n  //\n  // POST /upload HTTP/1.1\n  // Host: 127.0.0.1:8080\n  // Content-Length: 244894\n  // Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryRVr\n  //\n  // ------WebKitFormBoundaryRVr\n  // Content-Disposition: form-data; name=\"file\"; filename=\"accum.png\"\n  // Content-Type: image/png\n  //\n  //  <89>PNG\n  //  <PNG DATA>\n  // ------WebKitFormBoundaryRVr\n\n  // Extract boundary string from the Content-Type header\n  if ((content_type_header = mg_get_header(conn, \"Content-Type\")) == NULL ||\n      (boundary_start = mg_strcasestr(content_type_header,\n                                      \"boundary=\")) == NULL ||\n      (sscanf(boundary_start, \"boundary=\\\"%99[^\\\"]\\\"\", boundary) == 0 &&\n       sscanf(boundary_start, \"boundary=%99s\", boundary) == 0) ||\n      boundary[0] == '\\0') {\n    return NULL;\n  }\n\n  boundary_len = strlen(boundary);\n  bl = boundary_len + 4;  // \\r\\n--<boundary>\n\n  //                     buf\n  // conn->buf            |<--------- buf_len ------>|\n  //    |=================|==========|===============|\n  //    |<--request_len-->|<--len--->|               |\n  //    |<-----------data_len------->|      conn->buf + conn->buf_size\n\n  buf = conn->buf + conn->request_len;\n  buf_len = conn->buf_size - conn->request_len;\n  len = conn->data_len - conn->request_len;\n\n  for (;;) {\n    // Pull in headers\n    assert(len >= 0 && len <= buf_len);\n    to_read = buf_len - len;\n    if (to_read > left_to_read(conn)) {\n      to_read = (int) left_to_read(conn);\n    }\n    while (len < buf_len &&\n           (n = pull(NULL, conn, buf + len, to_read)) > 0) {\n      len += n;\n    }\n    if ((headers_len = get_request_len(buf, len)) <= 0) {\n      break;\n    }\n\n    // Fetch file name.\n    fname[0] = '\\0';\n    for (i = j = 0; i < headers_len; i++) {\n      if (buf[i] == '\\r' && buf[i + 1] == '\\n') {\n        buf[i] = buf[i + 1] = '\\0';\n        // TODO(lsm): don't expect filename to be the 3rd field,\n        // parse the header properly instead.\n        sscanf(&buf[j], \"Content-Disposition: %*s %*s filename=\\\"%1023[^\\\"]\",\n               fname);\n        j = i + 2;\n      }\n    }\n\n    // Give up if the headers are not what we expect\n    if (fname[0] == '\\0') {\n      break;\n    }\n\n    // Move data to the beginning of the buffer\n    assert(len >= headers_len);\n    memmove(buf, &buf[headers_len], len - headers_len);\n    len -= headers_len;\n    conn->data_len = conn->request_len + len;\n\n    // We open the file with exclusive lock held. This guarantee us\n    // there is no other thread can save into the same file simultaneously.\n    fp = NULL;\n\n    // Construct destination file name. Do not allow paths to have slashes.\n    if ((s = strrchr(fname, '/')) == NULL &&\n        (s = strrchr(fname, '\\\\')) == NULL) {\n      s = fname;\n    }\n\n    // Open file in binary mode. TODO: set an exclusive lock.\n    snprintf(path, path_len, \"%s/%s\", destination_dir, s);\n    if ((fp = fopen(path, \"wb\")) == NULL) {\n      break;\n    }\n\n    // Read POST data, write into file until boundary is found.\n    eof = n = 0;\n    do {\n      len += n;\n      for (i = 0; i < len - bl; i++) {\n        if (!memcmp(&buf[i], \"\\r\\n--\", 4) &&\n            !memcmp(&buf[i + 4], boundary, boundary_len)) {\n          // Found boundary, that's the end of file data.\n          fwrite(buf, 1, i, fp);\n          eof = 1;\n          memmove(buf, &buf[i + bl], len - (i + bl));\n          len -= i + bl;\n          break;\n        }\n      }\n      if (!eof && len > bl) {\n        fwrite(buf, 1, len - bl, fp);\n        memmove(buf, &buf[len - bl], bl);\n        len = bl;\n      }\n      to_read = buf_len - len;\n      if (to_read > left_to_read(conn)) {\n        to_read = (int) left_to_read(conn);\n      }\n    } while (!eof && (n = pull(NULL, conn, buf + len, to_read)) > 0);\n    conn->data_len = conn->request_len + len;\n\n    if (eof) {\n      rewind(fp);\n      return fp;\n    } else {\n      fclose(fp);\n    }\n  }\n\n  return NULL;\n}\n\nstatic int is_put_or_delete_request(const struct mg_connection *conn) {\n  const char *s = conn->request_info.request_method;\n  return s != NULL && (!strcmp(s, \"PUT\") ||\n                       !strcmp(s, \"DELETE\") ||\n                       !strcmp(s, \"MKCOL\"));\n}\n\nstatic int get_first_ssl_listener_index(const struct mg_context *ctx) {\n  int i, index = -1;\n  for (i = 0; index == -1 && i < ctx->num_listening_sockets; i++) {\n    index = ctx->listening_sockets[i].is_ssl ? i : -1;\n  }\n  return index;\n}\n\nstatic void redirect_to_https_port(struct mg_connection *conn, int ssl_index) {\n  char host[1025];\n  const char *host_header;\n\n  if ((host_header = mg_get_header(conn, \"Host\")) == NULL ||\n      sscanf(host_header, \"%1024[^:]\", host) == 0) {\n    // Cannot get host from the Host: header. Fallback to our IP address.\n    sockaddr_to_string(host, sizeof(host), &conn->client.lsa);\n  }\n\n  mg_printf(conn, \"HTTP/1.1 302 Found\\r\\nLocation: https://%s:%d%s\\r\\n\\r\\n\",\n            host, (int) ntohs(conn->ctx->listening_sockets[ssl_index].\n                              lsa.sin.sin_port), conn->request_info.uri);\n}\n\nstatic void handle_delete_request(struct mg_connection *conn,\n                                  const char *path) {\n  struct file file = STRUCT_FILE_INITIALIZER;\n\n  if (!mg_stat(path, &file)) {\n    send_http_error(conn, 404, \"Not Found\", \"%s\", \"File not found\");\n  } else if (!file.modification_time) {\n    send_http_error(conn, 500, http_500_error, \"remove(%s): %s\", path,\n                    strerror(ERRNO));\n  } else if (file.is_directory) {\n    remove_directory(conn, path);\n    send_http_error(conn, 204, \"No Content\", \"%s\", \"\");\n  } else if (mg_remove(path) == 0) {\n    send_http_error(conn, 204, \"No Content\", \"%s\", \"\");\n  } else {\n    send_http_error(conn, 423, \"Locked\", \"remove(%s): %s\", path,\n                    strerror(ERRNO));\n  }\n}\n\n// This is the heart of the Mongoose's logic.\n// This function is called when the request is read, parsed and validated,\n// and Mongoose must decide what action to take: serve a file, or\n// a directory, or call embedded function, etcetera.\nstatic void handle_request(struct mg_connection *conn) {\n  struct mg_request_info *ri = &conn->request_info;\n  char path[PATH_MAX];\n  int uri_len, ssl_index;\n  struct file file = STRUCT_FILE_INITIALIZER;\n\n  if ((conn->request_info.query_string = strchr(ri->uri, '?')) != NULL) {\n    * ((char *) conn->request_info.query_string++) = '\\0';\n  }\n  uri_len = (int) strlen(ri->uri);\n  mg_url_decode(ri->uri, uri_len, (char *) ri->uri, uri_len + 1, 0);\n  remove_double_dots_and_double_slashes((char *) ri->uri);\n  conn->throttle = set_throttle(conn->ctx->config[THROTTLE],\n                                get_remote_ip(conn), ri->uri);\n  path[0] = '\\0';\n  convert_uri_to_file_name(conn, path, sizeof(path), &file);\n\n  // Perform redirect and auth checks before calling begin_request() handler.\n  // Otherwise, begin_request() would need to perform auth checks and redirects.\n  if (!conn->client.is_ssl && conn->client.ssl_redir &&\n      (ssl_index = get_first_ssl_listener_index(conn->ctx)) > -1) {\n    redirect_to_https_port(conn, ssl_index);\n  } else if (!is_put_or_delete_request(conn) &&\n             !check_authorization(conn, path)) {\n    send_authorization_request(conn);\n  } else if (call_user(MG_REQUEST_BEGIN, conn, (void *) ri->uri) == 1) {\n    // Do nothing, callback has served the request\n  } else if (!strcmp(ri->request_method, \"OPTIONS\")) {\n    handle_options_request(conn);\n  } else if (conn->ctx->config[DOCUMENT_ROOT] == NULL) {\n    send_http_error(conn, 404, \"Not Found\", \"Not Found\");\n  } else if (is_put_or_delete_request(conn) &&\n             (is_authorized_for_put(conn) != 1)) {\n    send_authorization_request(conn);\n  } else if (!strcmp(ri->request_method, \"PUT\")) {\n    put_file(conn, path);\n  } else if (!strcmp(ri->request_method, \"MKCOL\")) {\n    mkcol(conn, path);\n  } else if (!strcmp(ri->request_method, \"DELETE\")) {\n    handle_delete_request(conn, path);\n  } else if (file.modification_time == (time_t) 0 ||\n             must_hide_file(conn, path)) {\n    send_http_error(conn, 404, \"Not Found\", \"%s\", \"File not found\");\n  } else if (file.is_directory && ri->uri[uri_len - 1] != '/') {\n    mg_printf(conn, \"HTTP/1.1 301 Moved Permanently\\r\\n\"\n              \"Location: %s/\\r\\n\\r\\n\", ri->uri);\n  } else if (!strcmp(ri->request_method, \"PROPFIND\")) {\n    handle_propfind(conn, path, &file);\n  } else if (file.is_directory &&\n             !substitute_index_file(conn, path, sizeof(path), &file)) {\n    if (!mg_strcasecmp(conn->ctx->config[ENABLE_DIRECTORY_LISTING], \"yes\")) {\n      handle_directory_request(conn, path);\n    } else {\n      send_http_error(conn, 403, \"Directory Listing Denied\",\n          \"Directory listing denied\");\n    }\n#ifdef USE_LUA\n  } else if (match_prefix(\"**.lp$\", 6, path) > 0) {\n    handle_lsp_request(conn, path, &file, NULL);\n#endif\n#if !defined(NO_CGI)\n  } else if (match_prefix(conn->ctx->config[CGI_EXTENSIONS],\n                          strlen(conn->ctx->config[CGI_EXTENSIONS]),\n                          path) > 0) {\n    if (strcmp(ri->request_method, \"POST\") &&\n        strcmp(ri->request_method, \"HEAD\") &&\n        strcmp(ri->request_method, \"GET\")) {\n      send_http_error(conn, 501, \"Not Implemented\",\n                      \"Method %s is not implemented\", ri->request_method);\n    } else {\n      handle_cgi_request(conn, path);\n    }\n#endif // !NO_CGI\n  } else if (match_prefix(conn->ctx->config[SSI_EXTENSIONS],\n                          strlen(conn->ctx->config[SSI_EXTENSIONS]),\n                          path) > 0) {\n    handle_ssi_file_request(conn, path);\n  } else if (is_not_modified(conn, &file)) {\n    send_http_error(conn, 304, \"Not Modified\", \"%s\", \"\");\n  } else {\n    handle_file_request(conn, path, &file);\n  }\n}\n\nstatic void close_all_listening_sockets(struct mg_context *ctx) {\n  int i;\n  for (i = 0; i < ctx->num_listening_sockets; i++) {\n    closesocket(ctx->listening_sockets[i].sock);\n  }\n  free(ctx->listening_sockets);\n}\n\nstatic int is_valid_port(unsigned int port) {\n  return port > 0 && port < 0xffff;\n}\n\n// Valid listening port specification is: [ip_address:]port[s]\n// Examples: 80, 443s, 127.0.0.1:3128, 1.2.3.4:8080s\n// TODO(lsm): add parsing of the IPv6 address\nstatic int parse_port_string(const struct vec *vec, struct socket *so) {\n  unsigned int a, b, c, d, ch, port;\n  int len;\n#if defined(USE_IPV6)\n  char buf[100];\n#endif\n\n  // MacOS needs that. If we do not zero it, subsequent bind() will fail.\n  // Also, all-zeroes in the socket address means binding to all addresses\n  // for both IPv4 and IPv6 (INADDR_ANY and IN6ADDR_ANY_INIT).\n  memset(so, 0, sizeof(*so));\n  so->lsa.sin.sin_family = AF_INET;\n\n  if (sscanf(vec->ptr, \"%u.%u.%u.%u:%u%n\", &a, &b, &c, &d, &port, &len) == 5) {\n    // Bind to a specific IPv4 address, e.g. 192.168.1.5:8080\n    so->lsa.sin.sin_addr.s_addr = htonl((a << 24) | (b << 16) | (c << 8) | d);\n    so->lsa.sin.sin_port = htons((uint16_t) port);\n#if defined(USE_IPV6)\n\n  } else if (sscanf(vec->ptr, \"[%49[^]]]:%d%n\", buf, &port, &len) == 2 &&\n             inet_pton(AF_INET6, buf, &so->lsa.sin6.sin6_addr)) {\n    // IPv6 address, e.g. [3ffe:2a00:100:7031::1]:8080\n    so->lsa.sin6.sin6_family = AF_INET6;\n    so->lsa.sin6.sin6_port = htons((uint16_t) port);\n#endif\n  } else if (sscanf(vec->ptr, \"%u%n\", &port, &len) == 1) {\n    // If only port is specified, bind to IPv4, INADDR_ANY\n    so->lsa.sin.sin_port = htons((uint16_t) port);\n  } else {\n    port = len = 0;   // Parsing failure. Make port invalid.\n  }\n\n  ch = vec->ptr[len];  // Next character after the port number\n  so->is_ssl = ch == 's';\n  so->ssl_redir = ch == 'r';\n\n  // Make sure the port is valid and vector ends with 's', 'r' or ','\n  return is_valid_port(port) &&\n    (ch == '\\0' || ch == 's' || ch == 'r' || ch == ',');\n}\n\nstatic int set_ports_option(struct mg_context *ctx) {\n  const char *list = ctx->config[LISTENING_PORTS];\n  int on = 1, success = 1;\n#if defined(USE_IPV6)\n  int off = 0;\n#endif\n  struct vec vec;\n  struct socket so, *ptr;\n\n  while (success && (list = next_option(list, &vec, NULL)) != NULL) {\n    if (!parse_port_string(&vec, &so)) {\n      cry(fc(ctx), \"%s: %.*s: invalid port spec. Expecting list of: %s\",\n          __func__, (int) vec.len, vec.ptr, \"[IP_ADDRESS:]PORT[s|r]\");\n      success = 0;\n    } else if (so.is_ssl && ctx->ssl_ctx == NULL) {\n      cry(fc(ctx), \"Cannot add SSL socket, is -ssl_certificate option set?\");\n      success = 0;\n    } else if ((so.sock = socket(so.lsa.sa.sa_family, SOCK_STREAM, 6)) ==\n               INVALID_SOCKET ||\n               // On Windows, SO_REUSEADDR is recommended only for\n               // broadcast UDP sockets\n               setsockopt(so.sock, SOL_SOCKET, SO_REUSEADDR,\n                          (void *) &on, sizeof(on)) != 0 ||\n#if defined(USE_IPV6)\n               (so.lsa.sa.sa_family == AF_INET6 &&\n                setsockopt(so.sock, IPPROTO_IPV6, IPV6_V6ONLY, (void *) &off,\n                           sizeof(off)) != 0) ||\n#endif\n               bind(so.sock, &so.lsa.sa, so.lsa.sa.sa_family == AF_INET ?\n                    sizeof(so.lsa.sin) : sizeof(so.lsa)) != 0 ||\n               listen(so.sock, SOMAXCONN) != 0) {\n      cry(fc(ctx), \"%s: cannot bind to %.*s: %d (%s)\", __func__,\n          (int) vec.len, vec.ptr, ERRNO, strerror(errno));\n      closesocket(so.sock);\n      success = 0;\n    } else if ((ptr = (struct socket *) realloc(ctx->listening_sockets,\n                              (ctx->num_listening_sockets + 1) *\n                              sizeof(ctx->listening_sockets[0]))) == NULL) {\n      closesocket(so.sock);\n      success = 0;\n    } else {\n      set_close_on_exec(so.sock);\n      ctx->listening_sockets = ptr;\n      ctx->listening_sockets[ctx->num_listening_sockets] = so;\n      ctx->num_listening_sockets++;\n    }\n  }\n\n  if (!success) {\n    close_all_listening_sockets(ctx);\n  }\n\n  return success;\n}\n\nstatic void log_header(const struct mg_connection *conn, const char *header,\n                       FILE *fp) {\n  const char *header_value;\n\n  if ((header_value = mg_get_header(conn, header)) == NULL) {\n    (void) fprintf(fp, \"%s\", \" -\");\n  } else {\n    (void) fprintf(fp, \" \\\"%s\\\"\", header_value);\n  }\n}\n\nstatic void log_access(const struct mg_connection *conn) {\n  const struct mg_request_info *ri;\n  FILE *fp;\n  char date[64], src_addr[IP_ADDR_STR_LEN];\n\n  fp = conn->ctx->config[ACCESS_LOG_FILE] == NULL ?  NULL :\n    fopen(conn->ctx->config[ACCESS_LOG_FILE], \"a+\");\n\n  if (fp == NULL)\n    return;\n\n  strftime(date, sizeof(date), \"%d/%b/%Y:%H:%M:%S %z\",\n           localtime(&conn->birth_time));\n\n  ri = &conn->request_info;\n  flockfile(fp);\n\n  sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);\n  fprintf(fp, \"%s - %s [%s] \\\"%s %s HTTP/%s\\\" %d %\" INT64_FMT,\n          src_addr, ri->remote_user == NULL ? \"-\" : ri->remote_user, date,\n          ri->request_method ? ri->request_method : \"-\",\n          ri->uri ? ri->uri : \"-\", ri->http_version,\n          conn->status_code, conn->num_bytes_sent);\n  log_header(conn, \"Referer\", fp);\n  log_header(conn, \"User-Agent\", fp);\n  fputc('\\n', fp);\n  fflush(fp);\n\n  funlockfile(fp);\n  fclose(fp);\n}\n\n// Verify given socket address against the ACL.\n// Return -1 if ACL is malformed, 0 if address is disallowed, 1 if allowed.\nstatic int check_acl(struct mg_context *ctx, uint32_t remote_ip) {\n  int allowed, flag;\n  uint32_t net, mask;\n  struct vec vec;\n  const char *list = ctx->config[ACCESS_CONTROL_LIST];\n\n  // If any ACL is set, deny by default\n  allowed = list == NULL ? '+' : '-';\n\n  while ((list = next_option(list, &vec, NULL)) != NULL) {\n    flag = vec.ptr[0];\n    if ((flag != '+' && flag != '-') ||\n        parse_net(&vec.ptr[1], &net, &mask) == 0) {\n      cry(fc(ctx), \"%s: subnet must be [+|-]x.x.x.x[/x]\", __func__);\n      return -1;\n    }\n\n    if (net == (remote_ip & mask)) {\n      allowed = flag;\n    }\n  }\n\n  return allowed == '+';\n}\n\n#if !defined(_WIN32)\nstatic int set_uid_option(struct mg_context *ctx) {\n  struct passwd *pw;\n  const char *uid = ctx->config[RUN_AS_USER];\n  int success = 0;\n\n  if (uid == NULL) {\n    success = 1;\n  } else {\n    if ((pw = getpwnam(uid)) == NULL) {\n      cry(fc(ctx), \"%s: unknown user [%s]\", __func__, uid);\n    } else if (setgid(pw->pw_gid) == -1) {\n      cry(fc(ctx), \"%s: setgid(%s): %s\", __func__, uid, strerror(errno));\n    } else if (setuid(pw->pw_uid) == -1) {\n      cry(fc(ctx), \"%s: setuid(%s): %s\", __func__, uid, strerror(errno));\n    } else {\n      success = 1;\n    }\n  }\n\n  return success;\n}\n#endif // !_WIN32\n\nstatic int set_gpass_option(struct mg_context *ctx) {\n  struct file file = STRUCT_FILE_INITIALIZER;\n  const char *path = ctx->config[GLOBAL_PASSWORDS_FILE];\n  if (path != NULL && !mg_stat(path, &file)) {\n    cry(fc(ctx), \"Cannot open %s: %s\", path, strerror(ERRNO));\n    return 0;\n  }\n  return 1;\n}\n\nstatic int set_acl_option(struct mg_context *ctx) {\n  return check_acl(ctx, (uint32_t) 0x7f000001UL) != -1;\n}\n\nstatic void reset_per_request_attributes(struct mg_connection *conn) {\n  conn->path_info = NULL;\n  conn->num_bytes_sent = conn->num_bytes_read = 0;\n  conn->status_code = -1;\n  conn->must_close = conn->request_len = conn->throttle = 0;\n}\n\nstatic void close_socket_gracefully(struct mg_connection *conn) {\n#if defined(_WIN32)\n  char buf[MG_BUF_LEN];\n  int n;\n#endif\n  struct linger linger;\n\n  // Set linger option to avoid socket hanging out after close. This prevent\n  // ephemeral port exhaust problem under high QPS.\n  linger.l_onoff = 1;\n  linger.l_linger = 1;\n  setsockopt(conn->client.sock, SOL_SOCKET, SO_LINGER,\n             (char *) &linger, sizeof(linger));\n\n  // Send FIN to the client\n  shutdown(conn->client.sock, SHUT_WR);\n  set_non_blocking_mode(conn->client.sock);\n\n#if defined(_WIN32)\n  // Read and discard pending incoming data. If we do not do that and close the\n  // socket, the data in the send buffer may be discarded. This\n  // behaviour is seen on Windows, when client keeps sending data\n  // when server decides to close the connection; then when client\n  // does recv() it gets no data back.\n  do {\n    n = pull(NULL, conn, buf, sizeof(buf));\n  } while (n > 0);\n#endif\n\n  // Now we know that our FIN is ACK-ed, safe to close\n  closesocket(conn->client.sock);\n}\n\nstatic void close_connection(struct mg_connection *conn) {\n  conn->must_close = 1;\n\n#ifndef NO_SSL\n  if (conn->ssl != NULL) {\n    // Run SSL_shutdown twice to ensure completly close SSL connection\n    SSL_shutdown(conn->ssl);\n    SSL_free(conn->ssl);\n    conn->ssl = NULL;\n  }\n#endif\n  if (conn->client.sock != INVALID_SOCKET) {\n    close_socket_gracefully(conn);\n    conn->client.sock = INVALID_SOCKET;\n  }\n}\n\nvoid mg_close_connection(struct mg_connection *conn) {\n#ifndef NO_SSL\n  if (conn->client_ssl_ctx != NULL) {\n    SSL_CTX_free((SSL_CTX *) conn->client_ssl_ctx);\n  }\n#endif\n  close_connection(conn);\n  free(conn);\n}\n\nstatic int is_valid_uri(const char *uri) {\n  // Conform to http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1.2\n  // URI can be an asterisk (*) or should start with slash.\n  return uri[0] == '/' || (uri[0] == '*' && uri[1] == '\\0');\n}\n\nstatic int getreq(struct mg_connection *conn, char *ebuf, size_t ebuf_len) {\n  const char *cl;\n\n  ebuf[0] = '\\0';\n  reset_per_request_attributes(conn);\n  conn->request_len = read_request(NULL, conn, conn->buf, conn->buf_size,\n                                   &conn->data_len);\n  assert(conn->request_len < 0 || conn->data_len >= conn->request_len);\n\n  if (conn->request_len == 0 && conn->data_len == conn->buf_size) {\n    snprintf(ebuf, ebuf_len, \"%s\", \"Request Too Large\");\n  } else if (conn->request_len <= 0) {\n    snprintf(ebuf, ebuf_len, \"%s\", \"Client closed connection\");\n  } else if (parse_http_message(conn->buf, conn->buf_size,\n                                &conn->request_info) <= 0) {\n    snprintf(ebuf, ebuf_len, \"Bad request: [%.*s]\", conn->data_len, conn->buf);\n  } else {\n    // Request is valid. Set content_len attribute by parsing Content-Length\n    // If Content-Length is absent, set content_len to 0 if request is GET,\n    // and set it to INT64_MAX otherwise. Setting to INT64_MAX instructs\n    // mg_read() to read from the socket until socket is closed.\n    // The reason for treating GET and POST/PUT differently is that libraries\n    // like jquery do not set Content-Length in GET requests, and we don't\n    // want mg_read() to hang waiting until socket is timed out.\n    // See https://github.com/cesanta/mongoose/pull/121 for more.\n    conn->content_len = INT64_MAX;\n    if (!mg_strcasecmp(conn->request_info.request_method, \"GET\")) {\n      conn->content_len = 0;\n    }\n    if ((cl = get_header(&conn->request_info, \"Content-Length\")) != NULL) {\n      conn->content_len = strtoll(cl, NULL, 10);\n    }\n    conn->birth_time = time(NULL);\n  }\n  return ebuf[0] == '\\0';\n}\n\nstatic void process_new_connection(struct mg_connection *conn) {\n  struct mg_request_info *ri = &conn->request_info;\n  int keep_alive_enabled, keep_alive, discard_len;\n  char ebuf[100];\n\n  keep_alive_enabled = !strcmp(conn->ctx->config[ENABLE_KEEP_ALIVE], \"yes\");\n  keep_alive = 0;\n\n  // Important: on new connection, reset the receiving buffer. Credit goes\n  // to crule42.\n  conn->data_len = 0;\n  do {\n    if (!getreq(conn, ebuf, sizeof(ebuf))) {\n      send_http_error(conn, 500, \"Server Error\", \"%s\", ebuf);\n      conn->must_close = 1;\n    } else if (!is_valid_uri(conn->request_info.uri)) {\n      snprintf(ebuf, sizeof(ebuf), \"Invalid URI: [%s]\", ri->uri);\n      send_http_error(conn, 400, \"Bad Request\", \"%s\", ebuf);\n    } else if (strcmp(ri->http_version, \"1.0\") &&\n               strcmp(ri->http_version, \"1.1\")) {\n      snprintf(ebuf, sizeof(ebuf), \"Bad HTTP version: [%s]\", ri->http_version);\n      send_http_error(conn, 505, \"Bad HTTP version\", \"%s\", ebuf);\n    }\n\n    if (ebuf[0] == '\\0') {\n      handle_request(conn);\n      call_user(MG_REQUEST_END, conn, (void *) conn->status_code);\n      log_access(conn);\n    }\n    if (ri->remote_user != NULL) {\n      free((void *) ri->remote_user);\n      // Important! When having connections with and without auth\n      // would cause double free and then crash\n      ri->remote_user = NULL;\n    }\n\n    // NOTE(lsm): order is important here. should_keep_alive() call\n    // is using parsed request, which will be invalid after memmove's below.\n    // Therefore, memorize should_keep_alive() result now for later use\n    // in loop exit condition.\n    keep_alive = conn->ctx->stop_flag == 0 && keep_alive_enabled &&\n      conn->content_len >= 0 && should_keep_alive(conn);\n\n    // Discard all buffered data for this request\n    discard_len = conn->content_len >= 0 && conn->request_len > 0 &&\n      conn->request_len + conn->content_len < (int64_t) conn->data_len ?\n      (int) (conn->request_len + conn->content_len) : conn->data_len;\n    assert(discard_len >= 0);\n    memmove(conn->buf, conn->buf + discard_len, conn->data_len - discard_len);\n    conn->data_len -= discard_len;\n    assert(conn->data_len >= 0);\n    assert(conn->data_len <= conn->buf_size);\n  } while (keep_alive);\n}\n\n// Worker threads take accepted socket from the queue\nstatic int consume_socket(struct mg_context *ctx, struct socket *sp) {\n  (void) pthread_mutex_lock(&ctx->mutex);\n  DEBUG_TRACE((\"going idle\"));\n\n  // If the queue is empty, wait. We're idle at this point.\n  while (ctx->sq_head == ctx->sq_tail && ctx->stop_flag == 0) {\n    pthread_cond_wait(&ctx->sq_full, &ctx->mutex);\n  }\n\n  // If we're stopping, sq_head may be equal to sq_tail.\n  if (ctx->sq_head > ctx->sq_tail) {\n    // Copy socket from the queue and increment tail\n    *sp = ctx->queue[ctx->sq_tail % ARRAY_SIZE(ctx->queue)];\n    ctx->sq_tail++;\n    DEBUG_TRACE((\"grabbed socket %d, going busy\", sp->sock));\n\n    // Wrap pointers if needed\n    while (ctx->sq_tail > (int) ARRAY_SIZE(ctx->queue)) {\n      ctx->sq_tail -= ARRAY_SIZE(ctx->queue);\n      ctx->sq_head -= ARRAY_SIZE(ctx->queue);\n    }\n  }\n\n  (void) pthread_cond_signal(&ctx->sq_empty);\n  (void) pthread_mutex_unlock(&ctx->mutex);\n\n  return !ctx->stop_flag;\n}\n\nstatic void *worker_thread(void *thread_func_param) {\n  struct mg_context *ctx = (struct mg_context *) thread_func_param;\n  struct mg_connection *conn;\n\n  conn = (struct mg_connection *) calloc(1, sizeof(*conn) + MAX_REQUEST_SIZE);\n  if (conn == NULL) {\n    cry(fc(ctx), \"%s\", \"Cannot create new connection struct, OOM\");\n  } else {\n    conn->buf_size = MAX_REQUEST_SIZE;\n    conn->buf = (char *) (conn + 1);\n    conn->ctx = ctx;\n    conn->event.user_data = ctx->user_data;\n\n    call_user(MG_THREAD_BEGIN, conn, NULL);\n\n    // Call consume_socket() even when ctx->stop_flag > 0, to let it signal\n    // sq_empty condvar to wake up the master waiting in produce_socket()\n    while (consume_socket(ctx, &conn->client)) {\n      conn->birth_time = time(NULL);\n\n      // Fill in IP, port info early so even if SSL setup below fails,\n      // error handler would have the corresponding info.\n      // Thanks to Johannes Winkelmann for the patch.\n      // TODO(lsm): Fix IPv6 case\n      conn->request_info.remote_port = ntohs(conn->client.rsa.sin.sin_port);\n      memcpy(&conn->request_info.remote_ip,\n             &conn->client.rsa.sin.sin_addr.s_addr, 4);\n      conn->request_info.remote_ip = ntohl(conn->request_info.remote_ip);\n      conn->request_info.is_ssl = conn->client.is_ssl;\n\n      if (!conn->client.is_ssl\n#ifndef NO_SSL\n          || sslize(conn, conn->ctx->ssl_ctx, SSL_accept)\n#endif\n         ) {\n        process_new_connection(conn);\n      }\n\n      close_connection(conn);\n    }\n    call_user(MG_THREAD_END, conn, NULL);\n    free(conn);\n  }\n\n  // Signal master that we're done with connection and exiting\n  (void) pthread_mutex_lock(&ctx->mutex);\n  ctx->num_threads--;\n  (void) pthread_cond_signal(&ctx->cond);\n  assert(ctx->num_threads >= 0);\n  (void) pthread_mutex_unlock(&ctx->mutex);\n\n  DEBUG_TRACE((\"exiting\"));\n  return NULL;\n}\n\n// Master thread adds accepted socket to a queue\nstatic void produce_socket(struct mg_context *ctx, const struct socket *sp) {\n  (void) pthread_mutex_lock(&ctx->mutex);\n\n  // If the queue is full, wait\n  while (ctx->stop_flag == 0 &&\n         ctx->sq_head - ctx->sq_tail >= (int) ARRAY_SIZE(ctx->queue)) {\n    (void) pthread_cond_wait(&ctx->sq_empty, &ctx->mutex);\n  }\n\n  if (ctx->sq_head - ctx->sq_tail < (int) ARRAY_SIZE(ctx->queue)) {\n    // Copy socket to the queue and increment head\n    ctx->queue[ctx->sq_head % ARRAY_SIZE(ctx->queue)] = *sp;\n    ctx->sq_head++;\n    DEBUG_TRACE((\"queued socket %d\", sp->sock));\n  }\n\n  (void) pthread_cond_signal(&ctx->sq_full);\n  (void) pthread_mutex_unlock(&ctx->mutex);\n}\n\nstatic int set_sock_timeout(SOCKET sock, int milliseconds) {\n#ifdef _WIN32\n  DWORD t = milliseconds;\n#else\n  struct timeval t;\n  t.tv_sec = milliseconds / 1000;\n  t.tv_usec = (milliseconds * 1000) % 1000000;\n#endif\n  return setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, (void *) &t, sizeof(t)) ||\n    setsockopt(sock, SOL_SOCKET, SO_SNDTIMEO, (void *) &t, sizeof(t));\n}\n\nstatic void accept_new_connection(const struct socket *listener,\n                                  struct mg_context *ctx) {\n  struct socket so;\n  char src_addr[IP_ADDR_STR_LEN];\n  socklen_t len = sizeof(so.rsa);\n  int on = 1;\n\n  if ((so.sock = accept(listener->sock, &so.rsa.sa, &len)) == INVALID_SOCKET) {\n  } else if (!check_acl(ctx, ntohl(* (uint32_t *) &so.rsa.sin.sin_addr))) {\n    sockaddr_to_string(src_addr, sizeof(src_addr), &so.rsa);\n    cry(fc(ctx), \"%s: %s is not allowed to connect\", __func__, src_addr);\n    closesocket(so.sock);\n  } else {\n    // Put so socket structure into the queue\n    DEBUG_TRACE((\"Accepted socket %d\", (int) so.sock));\n    set_close_on_exec(so.sock);\n    so.is_ssl = listener->is_ssl;\n    so.ssl_redir = listener->ssl_redir;\n    getsockname(so.sock, &so.lsa.sa, &len);\n    // Set TCP keep-alive. This is needed because if HTTP-level keep-alive\n    // is enabled, and client resets the connection, server won't get\n    // TCP FIN or RST and will keep the connection open forever. With TCP\n    // keep-alive, next keep-alive handshake will figure out that the client\n    // is down and will close the server end.\n    // Thanks to Igor Klopov who suggested the patch.\n    setsockopt(so.sock, SOL_SOCKET, SO_KEEPALIVE, (void *) &on, sizeof(on));\n    set_sock_timeout(so.sock, atoi(ctx->config[REQUEST_TIMEOUT]));\n    produce_socket(ctx, &so);\n  }\n}\n\nstatic void *master_thread(void *thread_func_param) {\n  struct mg_context *ctx = (struct mg_context *) thread_func_param;\n  struct pollfd *pfd;\n  int i;\n\n  // Increase priority of the master thread\n#if defined(_WIN32)\n  SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_ABOVE_NORMAL);\n#endif\n\n#if defined(ISSUE_317)\n  struct sched_param sched_param;\n  sched_param.sched_priority = sched_get_priority_max(SCHED_RR);\n  pthread_setschedparam(pthread_self(), SCHED_RR, &sched_param);\n#endif\n\n  call_user(MG_THREAD_BEGIN, fc(ctx), NULL);\n\n  pfd = (struct pollfd *) calloc(ctx->num_listening_sockets, sizeof(pfd[0]));\n  while (pfd != NULL && ctx->stop_flag == 0) {\n    for (i = 0; i < ctx->num_listening_sockets; i++) {\n      pfd[i].fd = ctx->listening_sockets[i].sock;\n      pfd[i].events = POLLIN;\n    }\n\n    if (poll(pfd, ctx->num_listening_sockets, 200) > 0) {\n      for (i = 0; i < ctx->num_listening_sockets; i++) {\n        // NOTE(lsm): on QNX, poll() returns POLLRDNORM after the\n        // successfull poll, and POLLIN is defined as (POLLRDNORM | POLLRDBAND)\n        // Therefore, we're checking pfd[i].revents & POLLIN, not\n        // pfd[i].revents == POLLIN.\n        if (ctx->stop_flag == 0 && (pfd[i].revents & POLLIN)) {\n          accept_new_connection(&ctx->listening_sockets[i], ctx);\n        }\n      }\n    }\n  }\n  free(pfd);\n  DEBUG_TRACE((\"stopping workers\"));\n\n  // Stop signal received: somebody called mg_stop. Quit.\n  close_all_listening_sockets(ctx);\n\n  // Wakeup workers that are waiting for connections to handle.\n  pthread_cond_broadcast(&ctx->sq_full);\n\n  // Wait until all threads finish\n  (void) pthread_mutex_lock(&ctx->mutex);\n  while (ctx->num_threads > 0) {\n    (void) pthread_cond_wait(&ctx->cond, &ctx->mutex);\n  }\n  (void) pthread_mutex_unlock(&ctx->mutex);\n\n  // All threads exited, no sync is needed. Destroy mutex and condvars\n  (void) pthread_mutex_destroy(&ctx->mutex);\n  (void) pthread_cond_destroy(&ctx->cond);\n  (void) pthread_cond_destroy(&ctx->sq_empty);\n  (void) pthread_cond_destroy(&ctx->sq_full);\n\n#if !defined(NO_SSL)\n  uninitialize_ssl(ctx);\n#endif\n  DEBUG_TRACE((\"exiting\"));\n\n  call_user(MG_THREAD_END, fc(ctx), NULL);\n\n  // Signal mg_stop() that we're done.\n  // WARNING: This must be the very last thing this\n  // thread does, as ctx becomes invalid after this line.\n  ctx->stop_flag = 2;\n  return NULL;\n}\n\nstatic void free_context(struct mg_context *ctx) {\n  int i;\n\n  // Deallocate config parameters\n  for (i = 0; i < NUM_OPTIONS; i++) {\n    if (ctx->config[i] != NULL)\n      free(ctx->config[i]);\n  }\n\n#ifndef NO_SSL\n  // Deallocate SSL context\n  if (ctx->ssl_ctx != NULL) {\n    SSL_CTX_free(ctx->ssl_ctx);\n  }\n  if (ssl_mutexes != NULL) {\n    free(ssl_mutexes);\n    ssl_mutexes = NULL;\n  }\n#endif // !NO_SSL\n\n  // Deallocate context itself\n  free(ctx);\n}\n\nvoid mg_stop(struct mg_context *ctx) {\n  ctx->stop_flag = 1;\n\n  // Wait until mg_fini() stops\n  while (ctx->stop_flag != 2) {\n    (void) mg_sleep(10);\n  }\n  free_context(ctx);\n\n#if defined(_WIN32) && !defined(__SYMBIAN32__)\n  (void) WSACleanup();\n#endif // _WIN32\n}\n\nstruct mg_context *mg_start(const char **options,\n                            mg_event_handler_t func,\n                            void *user_data) {\n  struct mg_context *ctx;\n  const char *name, *value, *default_value;\n  int i;\n\n#if defined(_WIN32) && !defined(__SYMBIAN32__)\n  WSADATA data;\n  WSAStartup(MAKEWORD(2,2), &data);\n#endif // _WIN32\n\n  // Allocate context and initialize reasonable general case defaults.\n  // TODO(lsm): do proper error handling here.\n  if ((ctx = (struct mg_context *) calloc(1, sizeof(*ctx))) == NULL) {\n    return NULL;\n  }\n  ctx->event_handler = func;\n  ctx->user_data = user_data;\n\n  while (options && (name = *options++) != NULL) {\n    if ((i = get_option_index(name)) == -1) {\n      cry(fc(ctx), \"Invalid option: %s\", name);\n      free_context(ctx);\n      return NULL;\n    } else if ((value = *options++) == NULL) {\n      cry(fc(ctx), \"%s: option value cannot be NULL\", name);\n      free_context(ctx);\n      return NULL;\n    }\n    if (ctx->config[i] != NULL) {\n      cry(fc(ctx), \"warning: %s: duplicate option\", name);\n      free(ctx->config[i]);\n    }\n    ctx->config[i] = mg_strdup(value);\n    DEBUG_TRACE((\"[%s] -> [%s]\", name, value));\n  }\n\n  // Set default value if needed\n  for (i = 0; config_options[i * 2] != NULL; i++) {\n    default_value = config_options[i * 2 + 1];\n    if (ctx->config[i] == NULL && default_value != NULL) {\n      ctx->config[i] = mg_strdup(default_value);\n    }\n  }\n\n  // NOTE(lsm): order is important here. SSL certificates must\n  // be initialized before listening ports. UID must be set last.\n  if (!set_gpass_option(ctx) ||\n#if !defined(NO_SSL)\n      !set_ssl_option(ctx) ||\n#endif\n      !set_ports_option(ctx) ||\n#if !defined(_WIN32)\n      !set_uid_option(ctx) ||\n#endif\n      !set_acl_option(ctx)) {\n    free_context(ctx);\n    return NULL;\n  }\n\n#if !defined(_WIN32) && !defined(__SYMBIAN32__)\n  // Ignore SIGPIPE signal, so if browser cancels the request, it\n  // won't kill the whole process.\n  (void) signal(SIGPIPE, SIG_IGN);\n#endif // !_WIN32\n\n  (void) pthread_mutex_init(&ctx->mutex, NULL);\n  (void) pthread_cond_init(&ctx->cond, NULL);\n  (void) pthread_cond_init(&ctx->sq_empty, NULL);\n  (void) pthread_cond_init(&ctx->sq_full, NULL);\n\n  // Start master (listening) thread\n  mg_start_thread(master_thread, ctx);\n\n  // Start worker threads\n  for (i = 0; i < atoi(ctx->config[NUM_THREADS]); i++) {\n    if (mg_start_thread(worker_thread, ctx) != 0) {\n      cry(fc(ctx), \"Cannot start worker thread: %ld\", (long) ERRNO);\n    } else {\n      ctx->num_threads++;\n    }\n  }\n\n  return ctx;\n}\n\n#ifdef USE_LUA\n#ifdef _WIN32\nstatic void *mmap(void *addr, int64_t len, int prot, int flags, int fd,\n                  int offset) {\n  HANDLE fh = (HANDLE) _get_osfhandle(fd);\n  HANDLE mh = CreateFileMapping(fh, 0, PAGE_READONLY, 0, 0, 0);\n  void *p = MapViewOfFile(mh, FILE_MAP_READ, 0, 0, (size_t) len);\n  CloseHandle(mh);\n  return p;\n}\n#define munmap(x, y)  UnmapViewOfFile(x)\n#define MAP_FAILED NULL\n#define MAP_PRIVATE 0\n#define PROT_READ 0\n#else\n#include <sys/mman.h>\n#endif\n\nstatic const char *LUASOCKET = \"luasocket\";\n\n// Forward declarations\nstatic int handle_lsp_request(struct mg_connection *, const char *,\n                              struct file *, struct lua_State *);\n\nstatic void reg_string(struct lua_State *L, const char *name, const char *val) {\n  lua_pushstring(L, name);\n  lua_pushstring(L, val);\n  lua_rawset(L, -3);\n}\n\nstatic void reg_int(struct lua_State *L, const char *name, int val) {\n  lua_pushstring(L, name);\n  lua_pushinteger(L, val);\n  lua_rawset(L, -3);\n}\n\nstatic void reg_function(struct lua_State *L, const char *name,\n                         lua_CFunction func, struct mg_connection *conn) {\n  lua_pushstring(L, name);\n  lua_pushlightuserdata(L, conn);\n  lua_pushcclosure(L, func, 1);\n  lua_rawset(L, -3);\n}\n\nstatic int lsp_sock_close(lua_State *L) {\n  if (lua_gettop(L) > 0 && lua_istable(L, -1)) {\n    lua_getfield(L, -1, \"sock\");\n    closesocket((SOCKET) lua_tonumber(L, -1));\n  } else {\n    return luaL_error(L, \"invalid :close() call\");\n  }\n  return 1;\n}\n\nstatic int lsp_sock_recv(lua_State *L) {\n  char buf[2000];\n  int n;\n\n  if (lua_gettop(L) > 0 && lua_istable(L, -1)) {\n    lua_getfield(L, -1, \"sock\");\n    n = recv((SOCKET) lua_tonumber(L, -1), buf, sizeof(buf), 0);\n    if (n <= 0) {\n      lua_pushnil(L);\n    } else {\n      lua_pushlstring(L, buf, n);\n    }\n  } else {\n    return luaL_error(L, \"invalid :close() call\");\n  }\n  return 1;\n}\n\nstatic int lsp_sock_send(lua_State *L) {\n  const char *buf;\n  size_t len, sent = 0;\n  int n, sock;\n\n  if (lua_gettop(L) > 1 && lua_istable(L, -2) && lua_isstring(L, -1)) {\n    buf = lua_tolstring(L, -1, &len);\n    lua_getfield(L, -2, \"sock\");\n    sock = (int) lua_tonumber(L, -1);\n    while (sent < len) {\n      if ((n = send(sock, buf + sent, len - sent, 0)) <= 0) {\n        break;\n      }\n      sent += n;\n    }\n    lua_pushnumber(L, n);\n  } else {\n    return luaL_error(L, \"invalid :close() call\");\n  }\n  return 1;\n}\n\nstatic const struct luaL_Reg luasocket_methods[] = {\n  {\"close\", lsp_sock_close},\n  {\"send\", lsp_sock_send},\n  {\"recv\", lsp_sock_recv},\n  {NULL, NULL}\n};\n\nstatic int lsp_connect(lua_State *L) {\n  char ebuf[100];\n  SOCKET sock;\n\n  if (lua_isstring(L, -3) && lua_isnumber(L, -2) && lua_isnumber(L, -1)) {\n    sock = conn2(lua_tostring(L, -3), (int) lua_tonumber(L, -2),\n                 (int) lua_tonumber(L, -1), ebuf, sizeof(ebuf));\n    if (sock == INVALID_SOCKET) {\n      return luaL_error(L, ebuf);\n    } else {\n      lua_newtable(L);\n      reg_int(L, \"sock\", sock);\n      reg_string(L, \"host\", lua_tostring(L, -4));\n      luaL_getmetatable(L, LUASOCKET);\n      lua_setmetatable(L, -2);\n    }\n  } else {\n    return luaL_error(L, \"connect(host,port,is_ssl): invalid parameter given.\");\n  }\n  return 1;\n}\n\nstatic int lsp_error(lua_State *L) {\n  lua_getglobal(L, \"mg\");\n  lua_getfield(L, -1, \"onerror\");\n  lua_pushvalue(L, -3);\n  lua_pcall(L, 1, 0, 0);\n  return 0;\n}\n\n// Silently stop processing chunks.\nstatic void lsp_abort(lua_State *L) {\n  int top = lua_gettop(L);\n  lua_getglobal(L, \"mg\");\n  lua_pushnil(L);\n  lua_setfield(L, -2, \"onerror\");\n  lua_settop(L, top);\n  lua_pushstring(L, \"aborting\");\n  lua_error(L);\n}\n\nstatic int lsp(struct mg_connection *conn, const char *path,\n               const char *p, int64_t len, lua_State *L) {\n  int i, j, pos = 0, lines = 1, lualines = 0;\n  char chunkname[MG_BUF_LEN];\n\n  for (i = 0; i < len; i++) {\n    if (p[i] == '\\n') lines++;\n    if (p[i] == '<' && p[i + 1] == '?') {\n      for (j = i + 1; j < len ; j++) {\n        if (p[j] == '\\n') lualines++;\n        if (p[j] == '?' && p[j + 1] == '>') {\n          mg_write(conn, p + pos, i - pos);\n\n          snprintf(chunkname, sizeof(chunkname), \"@%s+%i\", path, lines);\n          lua_pushlightuserdata(L, conn);\n          lua_pushcclosure(L, lsp_error, 1);\n          if (luaL_loadbuffer(L, p + (i + 2), j - (i + 2), chunkname)) {\n            // Syntax error or OOM. Error message is pushed on stack.\n            lua_pcall(L, 1, 0, 0);\n          } else {\n            // Success loading chunk. Call it.\n            lua_pcall(L, 0, 0, 1);\n          }\n\n          pos = j + 2;\n          i = pos - 1;\n          break;\n        }\n      }\n      if (lualines > 0) {\n        lines += lualines;\n        lualines = 0;\n      }\n    }\n  }\n\n  if (i > pos) {\n    mg_write(conn, p + pos, i - pos);\n  }\n\n  return 0;\n}\n\nstatic int lsp_write(lua_State *L) {\n  int i, num_args;\n  const char *str;\n  size_t size;\n  struct mg_connection *conn = lua_touserdata(L, lua_upvalueindex(1));\n\n  num_args = lua_gettop(L);\n  for (i = 1; i <= num_args; i++) {\n    if (lua_isstring(L, i)) {\n      str = lua_tolstring(L, i, &size);\n      mg_write(conn, str, size);\n    }\n  }\n\n  return 0;\n}\n\nstatic int lsp_read(lua_State *L) {\n  struct mg_connection *conn = lua_touserdata(L, lua_upvalueindex(1));\n  char buf[1024];\n  int len = mg_read(conn, buf, sizeof(buf));\n\n  if (len <= 0) return 0;\n  lua_pushlstring(L, buf, len);\n\n  return 1;\n}\n\n// mg.include: Include another .lp file\nstatic int lsp_include(lua_State *L) {\n  struct mg_connection *conn = lua_touserdata(L, lua_upvalueindex(1));\n  struct file file = STRUCT_FILE_INITIALIZER;\n  if (handle_lsp_request(conn, lua_tostring(L, -1), &file, L)) {\n    // handle_lsp_request returned an error code, meaning an error occured in\n    // the included page and mg.onerror returned non-zero. Stop processing.\n    lsp_abort(L);\n  }\n  return 0;\n}\n\n// mg.cry: Log an error. Default value for mg.onerror.\nstatic int lsp_cry(lua_State *L){\n  struct mg_connection *conn = lua_touserdata(L, lua_upvalueindex(1));\n  cry(conn, \"%s\", lua_tostring(L, -1));\n  return 0;\n}\n\n// mg.redirect: Redirect the request (internally).\nstatic int lsp_redirect(lua_State *L) {\n  struct mg_connection *conn = lua_touserdata(L, lua_upvalueindex(1));\n  conn->request_info.uri = lua_tostring(L, -1);\n  handle_request(conn);\n  lsp_abort(L);\n  return 0;\n}\n\nstatic void prepare_lua_environment(struct mg_connection *conn, lua_State *L) {\n  const struct mg_request_info *ri = &conn->request_info;\n  extern void luaL_openlibs(lua_State *);\n  int i;\n\n  luaL_openlibs(L);\n#ifdef USE_LUA_SQLITE3\n  { extern int luaopen_lsqlite3(lua_State *); luaopen_lsqlite3(L); }\n#endif\n\n  luaL_newmetatable(L, LUASOCKET);\n  lua_pushliteral(L, \"__index\");\n  luaL_newlib(L, luasocket_methods);\n  lua_rawset(L, -3);\n  lua_pop(L, 1);\n  lua_register(L, \"connect\", lsp_connect);\n\n  if (conn == NULL) return;\n\n  // Register mg module\n  lua_newtable(L);\n\n  reg_function(L, \"read\", lsp_read, conn);\n  reg_function(L, \"write\", lsp_write, conn);\n  reg_function(L, \"cry\", lsp_cry, conn);\n  reg_function(L, \"include\", lsp_include, conn);\n  reg_function(L, \"redirect\", lsp_redirect, conn);\n  reg_string(L, \"version\", MONGOOSE_VERSION);\n\n  // Export request_info\n  lua_pushstring(L, \"request_info\");\n  lua_newtable(L);\n  reg_string(L, \"request_method\", ri->request_method);\n  reg_string(L, \"uri\", ri->uri);\n  reg_string(L, \"http_version\", ri->http_version);\n  reg_string(L, \"query_string\", ri->query_string);\n  reg_int(L, \"remote_ip\", ri->remote_ip);\n  reg_int(L, \"remote_port\", ri->remote_port);\n  reg_int(L, \"num_headers\", ri->num_headers);\n  lua_pushstring(L, \"http_headers\");\n  lua_newtable(L);\n  for (i = 0; i < ri->num_headers; i++) {\n    reg_string(L, ri->http_headers[i].name, ri->http_headers[i].value);\n  }\n  lua_rawset(L, -3);\n  lua_rawset(L, -3);\n\n  lua_setglobal(L, \"mg\");\n\n  // Register default mg.onerror function\n  luaL_dostring(L, \"mg.onerror = function(e) mg.write('\\\\nLua error:\\\\n', \"\n                \"debug.traceback(e, 1)) end\");\n}\n\nstatic int lua_error_handler(lua_State *L) {\n  const char *error_msg =  lua_isstring(L, -1) ?  lua_tostring(L, -1) : \"?\\n\";\n\n  lua_getglobal(L, \"mg\");\n  if (!lua_isnil(L, -1)) {\n    lua_getfield(L, -1, \"write\");   // call mg.write()\n    lua_pushstring(L, error_msg);\n    lua_pushliteral(L, \"\\n\");\n    lua_call(L, 2, 0);\n    luaL_dostring(L, \"mg.write(debug.traceback(), '\\\\n')\");\n  } else {\n    printf(\"Lua error: [%s]\\n\", error_msg);\n    luaL_dostring(L, \"print(debug.traceback(), '\\\\n')\");\n  }\n  // TODO(lsm): leave the stack balanced\n\n  return 0;\n}\n\nvoid mg_exec_lua_script(struct mg_connection *conn, const char *path,\n                        const void **exports) {\n  int i;\n  lua_State *L;\n\n  if (path != NULL && (L = luaL_newstate()) != NULL) {\n    prepare_lua_environment(conn, L);\n    lua_pushcclosure(L, &lua_error_handler, 0);\n\n    lua_pushglobaltable(L);\n    if (exports != NULL) {\n      for (i = 0; exports[i] != NULL && exports[i + 1] != NULL; i += 2) {\n        lua_pushstring(L, exports[i]);\n        lua_pushcclosure(L, (lua_CFunction) exports[i + 1], 0);\n        lua_rawset(L, -3);\n      }\n    }\n\n    if (luaL_loadfile(L, path) != 0) {\n      lua_error_handler(L);\n    }\n    lua_pcall(L, 0, 0, -2);\n    lua_close(L);\n  }\n}\n\nstatic void lsp_send_err(struct mg_connection *conn, struct lua_State *L,\n                         const char *fmt, ...) {\n  char buf[MG_BUF_LEN];\n  va_list ap;\n\n  va_start(ap, fmt);\n  vsnprintf(buf, sizeof(buf), fmt, ap);\n  va_end(ap);\n\n  if (L == NULL) {\n    send_http_error(conn, 500, http_500_error, \"%s\", buf);\n  } else {\n    lua_pushstring(L, buf);\n    lua_error(L);\n  }\n}\n\nstatic int handle_lsp_request(struct mg_connection *conn, const char *path,\n                               struct file *filep, struct lua_State *ls) {\n  void *p = NULL;\n  lua_State *L = NULL;\n  FILE *fp = NULL;\n  int error = 1;\n\n  // We need both mg_stat to get file size, and mg_fopen to get fd\n  if (!mg_stat(path, filep) || (fp = mg_fopen(path, \"r\")) == NULL) {\n    lsp_send_err(conn, ls, \"File [%s] not found\", path);\n  } else if ((p = mmap(NULL, (size_t) filep->size, PROT_READ, MAP_PRIVATE,\n                       fileno(fp), 0)) == MAP_FAILED) {\n    lsp_send_err(conn, ls, \"mmap(%s, %zu, %d): %s\", path, (size_t) filep->size,\n              fileno(fp), strerror(errno));\n  } else if ((L = ls != NULL ? ls : luaL_newstate()) == NULL) {\n    send_http_error(conn, 500, http_500_error, \"%s\", \"luaL_newstate failed\");\n  } else {\n    // We're not sending HTTP headers here, Lua page must do it.\n    if (ls == NULL) {\n      prepare_lua_environment(conn, L);\n    }\n    error = lsp(conn, path, p, filep->size, L);\n  }\n\n  if (L != NULL && ls == NULL) lua_close(L);\n  if (p != NULL) munmap(p, filep->size);\n  fclose(fp);\n\n  return error;\n}\n#endif // USE_LUA\n",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/plc/main.cpp": "// main.cpp : Defines the entry point for the DLL application.\n//\tCopyright (C) 2008 Battelle Memorial Institute\n//\n\n#define DLMAIN\n\n#include <stdlib.h>\n#include \"gridlabd.h\"\n\n#ifdef _WIN32\n// code for loading and initializing PLC machines\n#include \"machine.h\"\nint load_library(char *name, PLCCODE *code, PLCINIT *init, PLCDATA *data)\n{\n\tvoid *hLib = LoadLibrary(name);\n\tif (hLib)\n\t{\n\t\t*data = (PLCDATA)GetProcAddress((HMODULE)hLib,\"data\");\n\t\t*init = (PLCINIT)GetProcAddress((HMODULE)hLib,\"init\");\n\t\t*code= (PLCCODE)GetProcAddress((HMODULE)hLib,\"code\");\n\t\treturn (*data!=NULL && *init!=NULL && *code!=NULL) ? 0 : -1;\n\t}\n\treturn -1;\n}\n\n#else // !WIN32\n#include \"machine.h\"\n#include <dlfcn.h>\nint load_library(char *name, PLCCODE *code, PLCINIT *init, PLCDATA *data)\n{\n\tvoid *hLib = dlopen(name, RTLD_LAZY);\n\tif (hLib)\n\t{\n\t\t*data = (PLCDATA)dlsym(hLib,\"data\");\n\t\t*init = (PLCINIT)dlsym(hLib,\"init\");\n\t\t*code = (PLCCODE)dlsym(hLib,\"code\");\n\t\treturn (*data!=NULL && *init!=NULL && *code!=NULL) ? 0 : -1;\n\t}\n\treturn -1;\n}\n#endif // !WIN32\n",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/powerflow/node.cpp": "/** $Id: node.cpp 1215 2009-01-22 00:54:37Z d3x593 $\n\tCopyright (C) 2008 Battelle Memorial Institute\n\t@file node.cpp\n\t@addtogroup powerflow_node Node\n\t@ingroup powerflow_object\n\t\n\tThe node is one of the major components of the method used for solving a \n\tpowerflow network.  In essense the distribution network can be seen as a \n\tseries of nodes and links.  Nodes primary responsibility is to act as an\n\taggregation point for the links that are attached to it, and to hold the\n\tcurrent and voltage values that will be used in the matrix calculations\n\tdone in the link.\n\t\n\tThree types of nodes are defined in this file.  Nodes are simply a basic \n\tobject that exports the voltages for each phase.  Triplex nodes export\n\tvoltages for 3 lines; line1_voltage, line2_voltage, lineN_voltage.\n\n\t@par Voltage control\n\n\tWhen the global variable require_voltage_control is set to \\p TRUE,\n\tthe bus type is used to determine how voltage control is implemented.\n\tVoltage control is only performed when the bus has no link that\n\tconsiders it a to node.  When the flag \\#NF_HASSOURCE is cleared, then\n\tthe following is in effect:\n\n\t- \\#SWING buses are considered infinite sources and the voltage will\n\t  remain fixed regardless of conditions.\n\t- \\#PV buses are considered constrained sources and the voltage will\n\t  fall to zero if there is insufficient voltage support at the bus.\n\t  A generator object is required to provide the voltage support explicitly.\n\t  The voltage will be set to zero if the generator does not provide\n\t  sufficient support.\n\t- \\#PQ buses will always go to zero voltage.\n\n\t@par Fault support\n\n\tThe following conditions are used to describe a fault impedance \\e X (e.g., 1e-6), \n\tbetween phase \\e x and neutral or group, or between phases \\e x and \\e y, and leaving\n\tphase \\e z unaffected at iteration \\e t:\n\t- \\e phase-to-phase contact at the node\n\t\t- \\e Forward-sweep: \\f$ V_x(t) = V_y(t) = \\frac{V_x(t-1) + V_y(t-1)}{2} \\f$\n\t\t- \\e Back-sweep: \\f$ I_x(t+1) = -I_y(t+1) = \\frac{V_x(t)-V_y(t)}{X} \\f$;\n    - \\e phase-to-ground/neutral contact at the node\n\t\t- \\e Forward-sweep: \\f$ V_x(t) = \\frac{1}{2} V_x(t-1)  \\f$\n\t\t- \\e Back-sweep: \\f$ I_x(t+1) = \\frac{V_x(t)}{X} \\f$;\n\t\n\t@{\n*/\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <math.h>\n\n#include \"solver_nr.h\"\n#include \"node.h\"\n\n//Library imports items - for external LU solver - stolen from somewhere else in GridLAB-D (tape, I believe)\n#if defined(_WIN32) && !defined(__MINGW32__)\n#define WIN32_LEAN_AND_MEAN\t\t// Exclude rarely-used stuff from Windows headers\n#define _WIN32_WINNT 0x0400\n#include <windows.h>\n#ifndef DLEXT\n#define DLEXT \".dll\"\n#endif\n#define DLLOAD(P) LoadLibrary(P)\n#define DLSYM(H,S) (void *)GetProcAddress((HINSTANCE)H,S)\n#define snprintf _snprintf\n#else /* ANSI */\n#include \"dlfcn.h\"\n#ifndef DLEXT\n#ifdef __MINGW32__\n#define DLEXT \".dll\"\n#else\n#define DLEXT \".so\"\n#endif\n#endif\n#define DLLOAD(P) dlopen(P,RTLD_LAZY)\n#define DLSYM(H,S) dlsym(H,S)\n#endif\n\n//\"Small\" multiplier for restoring voltages in in-rush.  Zeros seem to make it angry\n//TODO: See if this is a \"zero-catch\" somewhere making it useless, or legitimate numerical stability\n#define MULTTERM 0.00000000000001\n\n//******************* TODO SOON -- Check history and saturation mapping for children (probably doesn't work **********//\n\nCLASS *node::oclass = NULL;\nCLASS *node::pclass = NULL;\n\nunsigned int node::n = 0; \n\nnode::node(MODULE *mod) : powerflow_object(mod)\n{\n\tif(oclass == NULL)\n\t{\n\t\tpclass = powerflow_object::oclass;\n\t\toclass = gl_register_class(mod,\"node\",sizeof(node),PC_PRETOPDOWN|PC_BOTTOMUP|PC_POSTTOPDOWN|PC_UNSAFE_OVERRIDE_OMIT|PC_AUTOLOCK);\n\t\tif (oclass==NULL)\n\t\t\tthrow \"unable to register class node\";\n\t\telse\n\t\t\toclass->trl = TRL_PROVEN;\n\n\t\tif(gl_publish_variable(oclass,\n\t\t\tPT_INHERIT, \"powerflow_object\",\n\t\t\tPT_enumeration, \"bustype\", PADDR(bustype),PT_DESCRIPTION,\"defines whether the node is a PQ, PV, or SWING node\",\n\t\t\t\tPT_KEYWORD, \"PQ\", (enumeration)PQ,\n\t\t\t\tPT_KEYWORD, \"PV\", (enumeration)PV,\n\t\t\t\tPT_KEYWORD, \"SWING\", (enumeration)SWING,\n\t\t\t\tPT_KEYWORD, \"SWING_PQ\", (enumeration)SWING_PQ,\n\t\t\tPT_set, \"busflags\", PADDR(busflags),PT_DESCRIPTION,\"flag indicates node has a source for voltage, i.e. connects to the swing node\",\n\t\t\t\tPT_KEYWORD, \"HASSOURCE\", (set)NF_HASSOURCE,\n\t\t\t\tPT_KEYWORD, \"ISSOURCE\", (set)NF_ISSOURCE,\n\t\t\tPT_object, \"reference_bus\", PADDR(reference_bus),PT_DESCRIPTION,\"reference bus from which frequency is defined\",\n\t\t\tPT_double,\"maximum_voltage_error[V]\",PADDR(maximum_voltage_error),PT_DESCRIPTION,\"convergence voltage limit or convergence criteria\",\n\n\t\t\tPT_complex, \"voltage_A[V]\", PADDR(voltage[0]),PT_DESCRIPTION,\"bus voltage, Phase A to ground\",\n\t\t\tPT_complex, \"voltage_B[V]\", PADDR(voltage[1]),PT_DESCRIPTION,\"bus voltage, Phase B to ground\",\n\t\t\tPT_complex, \"voltage_C[V]\", PADDR(voltage[2]),PT_DESCRIPTION,\"bus voltage, Phase C to ground\",\n\t\t\tPT_complex, \"voltage_AB[V]\", PADDR(voltaged[0]),PT_DESCRIPTION,\"line voltages, Phase AB\",\n\t\t\tPT_complex, \"voltage_BC[V]\", PADDR(voltaged[1]),PT_DESCRIPTION,\"line voltages, Phase BC\",\n\t\t\tPT_complex, \"voltage_CA[V]\", PADDR(voltaged[2]),PT_DESCRIPTION,\"line voltages, Phase CA\",\n\t\t\tPT_complex, \"current_A[A]\", PADDR(current[0]),PT_ACCESS,PA_HIDDEN,PT_DESCRIPTION,\"bus current injection (in = positive), this an accumulator only, not a output or input variable\",\n\t\t\tPT_complex, \"current_B[A]\", PADDR(current[1]),PT_ACCESS,PA_HIDDEN,PT_DESCRIPTION,\"bus current injection (in = positive), this an accumulator only, not a output or input variable\",\n\t\t\tPT_complex, \"current_C[A]\", PADDR(current[2]),PT_ACCESS,PA_HIDDEN,PT_DESCRIPTION,\"bus current injection (in = positive), this an accumulator only, not a output or input variable\",\n\t\t\tPT_complex, \"power_A[VA]\", PADDR(power[0]),PT_ACCESS,PA_HIDDEN,PT_DESCRIPTION,\"bus power injection (in = positive), this an accumulator only, not a output or input variable\",\n\t\t\tPT_complex, \"power_B[VA]\", PADDR(power[1]),PT_ACCESS,PA_HIDDEN,PT_DESCRIPTION,\"bus power injection (in = positive), this an accumulator only, not a output or input variable\",\n\t\t\tPT_complex, \"power_C[VA]\", PADDR(power[2]),PT_ACCESS,PA_HIDDEN,PT_DESCRIPTION,\"bus power injection (in = positive), this an accumulator only, not a output or input variable\",\n\t\t\tPT_complex, \"shunt_A[S]\", PADDR(shunt[0]),PT_ACCESS,PA_HIDDEN,PT_DESCRIPTION,\"bus shunt admittance, this an accumulator only, not a output or input variable\",\n\t\t\tPT_complex, \"shunt_B[S]\", PADDR(shunt[1]),PT_ACCESS,PA_HIDDEN,PT_DESCRIPTION,\"bus shunt admittance, this an accumulator only, not a output or input variable\",\n\t\t\tPT_complex, \"shunt_C[S]\", PADDR(shunt[2]),PT_ACCESS,PA_HIDDEN,PT_DESCRIPTION,\"bus shunt admittance, this an accumulator only, not a output or input variable\",\n\n\t\t\tPT_complex, \"prerotated_current_A[A]\", PADDR(pre_rotated_current[0]),PT_ACCESS,PA_HIDDEN,PT_DESCRIPTION,\"deltamode-functionality - bus current injection (in = positive), but will not be rotated by powerflow for off-nominal frequency, this an accumulator only, not a output or input variable\",\n\t\t\tPT_complex, \"prerotated_current_B[A]\", PADDR(pre_rotated_current[1]),PT_ACCESS,PA_HIDDEN,PT_DESCRIPTION,\"deltamode-functionality - bus current injection (in = positive), but will not be rotated by powerflow for off-nominal frequency, this an accumulator only, not a output or input variable\",\n\t\t\tPT_complex, \"prerotated_current_C[A]\", PADDR(pre_rotated_current[2]),PT_ACCESS,PA_HIDDEN,PT_DESCRIPTION,\"deltamode-functionality - bus current injection (in = positive), but will not be rotated by powerflow for off-nominal frequency, this an accumulator only, not a output or input variable\",\n\n\t\t\tPT_complex, \"deltamode_generator_current_A[A]\", PADDR(deltamode_dynamic_current[0]),PT_ACCESS,PA_HIDDEN,PT_DESCRIPTION,\"deltamode-functionality - bus current injection (in = positive), direct generator injection (so may be overwritten internally), this an accumulator only, not a output or input variable\",\n\t\t\tPT_complex, \"deltamode_generator_current_B[A]\", PADDR(deltamode_dynamic_current[1]),PT_ACCESS,PA_HIDDEN,PT_DESCRIPTION,\"deltamode-functionality - bus current injection (in = positive), direct generator injection (so may be overwritten internally), this an accumulator only, not a output or input variable\",\n\t\t\tPT_complex, \"deltamode_generator_current_C[A]\", PADDR(deltamode_dynamic_current[2]),PT_ACCESS,PA_HIDDEN,PT_DESCRIPTION,\"deltamode-functionality - bus current injection (in = positive), direct generator injection (so may be overwritten internally), this an accumulator only, not a output or input variable\",\n\n\t\t\tPT_complex, \"deltamode_PGenTotal\",PADDR(deltamode_PGenTotal),PT_ACCESS,PA_HIDDEN,PT_DESCRIPTION,\"deltamode-functionality - power value for a diesel generator -- accumulator only, not an output or input\",\n\n\t\t\tPT_complex_array, \"deltamode_full_Y_matrix\",  PADDR(full_Y_matrix),PT_ACCESS,PA_HIDDEN,PT_DESCRIPTION,\"deltamode-functionality full_Y matrix exposes so generator objects can interact for Norton equivalents\",\n\t\t\tPT_complex_array, \"deltamode_full_Y_all_matrix\",  PADDR(full_Y_all_matrix),PT_ACCESS,PA_HIDDEN,PT_DESCRIPTION,\"deltamode-functionality full_Y_all matrix exposes so generator objects can interact for Norton equivalents\",\n\n\t\t\tPT_complex, \"current_inj_A[A]\", PADDR(current_inj[0]),PT_ACCESS,PA_HIDDEN,PT_DESCRIPTION,\"bus current injection (in = positive), but will not be rotated by powerflow for off-nominal frequency, this an accumulator only, not a output or input variable\",\n\t\t\tPT_complex, \"current_inj_B[A]\", PADDR(current_inj[1]),PT_ACCESS,PA_HIDDEN,PT_DESCRIPTION,\"bus current injection (in = positive), but will not be rotated by powerflow for off-nominal frequency, this an accumulator only, not a output or input variable\",\n\t\t\tPT_complex, \"current_inj_C[A]\", PADDR(current_inj[2]),PT_ACCESS,PA_HIDDEN,PT_DESCRIPTION,\"bus current injection (in = positive), but will not be rotated by powerflow for off-nominal frequency, this an accumulator only, not a output or input variable\",\n\n\t\t\tPT_complex, \"current_AB[A]\", PADDR(current_dy[0]),PT_ACCESS,PA_HIDDEN,PT_DESCRIPTION,\"bus current delta-connected injection (in = positive), this an accumulator only, not a output or input variable\",\n\t\t\tPT_complex, \"current_BC[A]\", PADDR(current_dy[1]),PT_ACCESS,PA_HIDDEN,PT_DESCRIPTION,\"bus current delta-connected injection (in = positive), this an accumulator only, not a output or input variable\",\n\t\t\tPT_complex, \"current_CA[A]\", PADDR(current_dy[2]),PT_ACCESS,PA_HIDDEN,PT_DESCRIPTION,\"bus current delta-connected injection (in = positive), this an accumulator only, not a output or input variable\",\n\t\t\tPT_complex, \"current_AN[A]\", PADDR(current_dy[3]),PT_ACCESS,PA_HIDDEN,PT_DESCRIPTION,\"bus current wye-connected injection (in = positive), this an accumulator only, not a output or input variable\",\n\t\t\tPT_complex, \"current_BN[A]\", PADDR(current_dy[4]),PT_ACCESS,PA_HIDDEN,PT_DESCRIPTION,\"bus current wye-connected injection (in = positive), this an accumulator only, not a output or input variable\",\n\t\t\tPT_complex, \"current_CN[A]\", PADDR(current_dy[5]),PT_ACCESS,PA_HIDDEN,PT_DESCRIPTION,\"bus current wye-connected injection (in = positive), this an accumulator only, not a output or input variable\",\n\t\t\tPT_complex, \"power_AB[VA]\", PADDR(power_dy[0]),PT_ACCESS,PA_HIDDEN,PT_DESCRIPTION,\"bus power delta-connected injection (in = positive), this an accumulator only, not a output or input variable\",\n\t\t\tPT_complex, \"power_BC[VA]\", PADDR(power_dy[1]),PT_ACCESS,PA_HIDDEN,PT_DESCRIPTION,\"bus power delta-connected injection (in = positive), this an accumulator only, not a output or input variable\",\n\t\t\tPT_complex, \"power_CA[VA]\", PADDR(power_dy[2]),PT_ACCESS,PA_HIDDEN,PT_DESCRIPTION,\"bus power delta-connected injection (in = positive), this an accumulator only, not a output or input variable\",\n\t\t\tPT_complex, \"power_AN[VA]\", PADDR(power_dy[3]),PT_ACCESS,PA_HIDDEN,PT_DESCRIPTION,\"bus power wye-connected injection (in = positive), this an accumulator only, not a output or input variable\",\n\t\t\tPT_complex, \"power_BN[VA]\", PADDR(power_dy[4]),PT_ACCESS,PA_HIDDEN,PT_DESCRIPTION,\"bus power wye-connected injection (in = positive), this an accumulator only, not a output or input variable\",\n\t\t\tPT_complex, \"power_CN[VA]\", PADDR(power_dy[5]),PT_ACCESS,PA_HIDDEN,PT_DESCRIPTION,\"bus power wye-connected injection (in = positive), this an accumulator only, not a output or input variable\",\n\t\t\tPT_complex, \"shunt_AB[S]\", PADDR(power_dy[0]),PT_ACCESS,PA_HIDDEN,PT_DESCRIPTION,\"bus shunt delta-connected admittance, this an accumulator only, not a output or input variable\",\n\t\t\tPT_complex, \"shunt_BC[S]\", PADDR(power_dy[1]),PT_ACCESS,PA_HIDDEN,PT_DESCRIPTION,\"bus shunt delta-connected admittance, this an accumulator only, not a output or input variable\",\n\t\t\tPT_complex, \"shunt_CA[S]\", PADDR(power_dy[2]),PT_ACCESS,PA_HIDDEN,PT_DESCRIPTION,\"bus shunt delta-connected admittance, this an accumulator only, not a output or input variable\",\n\t\t\tPT_complex, \"shunt_AN[S]\", PADDR(power_dy[3]),PT_ACCESS,PA_HIDDEN,PT_DESCRIPTION,\"bus shunt wye-connected admittance, this an accumulator only, not a output or input variable\",\n\t\t\tPT_complex, \"shunt_BN[S]\", PADDR(power_dy[4]),PT_ACCESS,PA_HIDDEN,PT_DESCRIPTION,\"bus shunt wye-connected admittance, this an accumulator only, not a output or input variable\",\n\t\t\tPT_complex, \"shunt_CN[S]\", PADDR(power_dy[5]),PT_ACCESS,PA_HIDDEN,PT_DESCRIPTION,\"bus shunt wye-connected admittance, this an accumulator only, not a output or input variable\",\n\n\t\t\t//House-related variables - for 3-phase house connections\n\t\t\tPT_complex, \"residential_nominal_current_A[A]\", PADDR(nom_res_curr[0]),PT_ACCESS,PA_HIDDEN,PT_DESCRIPTION,\"posted current on phase A from a residential object, if attached\",\n\t\t\tPT_complex, \"residential_nominal_current_B[A]\", PADDR(nom_res_curr[1]),PT_ACCESS,PA_HIDDEN,PT_DESCRIPTION,\"posted current on phase B from a residential object, if attached\",\n\t\t\tPT_complex, \"residential_nominal_current_C[A]\", PADDR(nom_res_curr[2]),PT_ACCESS,PA_HIDDEN,PT_DESCRIPTION,\"posted current on phase C from a residential object, if attached\",\n\t\t\tPT_double, \"residential_nominal_current_A_real[A]\", PADDR(nom_res_curr[0].Re()),PT_ACCESS,PA_HIDDEN,PT_DESCRIPTION,\"posted current on phase A, real, from a residential object, if attached\",\n\t\t\tPT_double, \"residential_nominal_current_A_imag[A]\", PADDR(nom_res_curr[0].Im()),PT_ACCESS,PA_HIDDEN,PT_DESCRIPTION,\"posted current on phase A, imag, from a residential object, if attached\",\n\t\t\tPT_double, \"residential_nominal_current_B_real[A]\", PADDR(nom_res_curr[1].Re()),PT_ACCESS,PA_HIDDEN,PT_DESCRIPTION,\"posted current on phase B, real, from a residential object, if attached\",\n\t\t\tPT_double, \"residential_nominal_current_B_imag[A]\", PADDR(nom_res_curr[1].Im()),PT_ACCESS,PA_HIDDEN,PT_DESCRIPTION,\"posted current on phase B, imag, from a residential object, if attached\",\n\t\t\tPT_double, \"residential_nominal_current_C_real[A]\", PADDR(nom_res_curr[2].Re()),PT_ACCESS,PA_HIDDEN,PT_DESCRIPTION,\"posted current on phase C, real, from a residential object, if attached\",\n\t\t\tPT_double, \"residential_nominal_current_C_imag[A]\", PADDR(nom_res_curr[2].Im()),PT_ACCESS,PA_HIDDEN,PT_DESCRIPTION,\"posted current on phase C, imag, from a residential object, if attached\",\n\n\t\t\tPT_bool, \"house_present\", PADDR(house_present),PT_ACCESS,PA_HIDDEN,PT_DESCRIPTION,\"boolean for detecting whether a house is attached, not an input\",\n\n\t\t\tPT_double, \"mean_repair_time[s]\",PADDR(mean_repair_time), PT_DESCRIPTION, \"Time after a fault clears for the object to be back in service\",\n\n\t\t\t//Properties for frequency measurement\n\t\t\tPT_enumeration,\"frequency_measure_type\",PADDR(fmeas_type),PT_DESCRIPTION,\"Frequency measurement dynamics-capable implementation\",\n\t\t\t\tPT_KEYWORD,\"NONE\",(enumeration)FM_NONE,PT_DESCRIPTION,\"No frequency measurement\",\n\t\t\t\tPT_KEYWORD,\"SIMPLE\",(enumeration)FM_SIMPLE,PT_DESCRIPTION,\"Simplified frequency measurement\",\n\t\t\t\tPT_KEYWORD,\"PLL\",(enumeration)FM_PLL,PT_DESCRIPTION,\"PLL frequency measurement\",\n\n\t\t\tPT_double,\"sfm_Tf[s]\",PADDR(freq_sfm_Tf),PT_DESCRIPTION,\"Transducer time constant for simplified frequency measurement (seconds)\",\n\t\t\tPT_double,\"pll_Kp[pu]\",PADDR(freq_pll_Kp),PT_DESCRIPTION,\"Proportional gain of PLL frequency measurement\",\n\t\t\tPT_double,\"pll_Ki[pu]\",PADDR(freq_pll_Ki),PT_DESCRIPTION,\"Integration gain of PLL frequency measurement\",\n\n\t\t\t//Frequency measurement output variables\n\t\t\tPT_double,\"measured_angle_A[rad]\", PADDR(curr_freq_state.anglemeas[0]),PT_DESCRIPTION,\"bus angle measurement, phase A\",\n\t\t\tPT_double,\"measured_frequency_A[Hz]\", PADDR(curr_freq_state.fmeas[0]),PT_DESCRIPTION,\"frequency measurement, phase A\",\n\t\t\tPT_double,\"measured_angle_B[rad]\", PADDR(curr_freq_state.anglemeas[1]),PT_DESCRIPTION,\"bus angle measurement, phase B\",\n\t\t\tPT_double,\"measured_frequency_B[Hz]\", PADDR(curr_freq_state.fmeas[1]),PT_DESCRIPTION,\"frequency measurement, phase B\",\n\t\t\tPT_double,\"measured_angle_C[rad]\", PADDR(curr_freq_state.anglemeas[2]),PT_DESCRIPTION,\"bus angle measurement, phase C\",\n\t\t\tPT_double,\"measured_frequency_C[Hz]\", PADDR(curr_freq_state.fmeas[2]),PT_DESCRIPTION,\"frequency measurement, phase C\",\n\t\t\tPT_double,\"measured_frequency[Hz]\", PADDR(curr_freq_state.average_freq), PT_DESCRIPTION, \"frequency measurement - average of present phases\",\n\n\t\t\tPT_enumeration, \"service_status\", PADDR(service_status),PT_DESCRIPTION,\"In and out of service flag\",\n\t\t\t\tPT_KEYWORD, \"IN_SERVICE\", (enumeration)ND_IN_SERVICE,\n\t\t\t\tPT_KEYWORD, \"OUT_OF_SERVICE\", (enumeration)ND_OUT_OF_SERVICE,\n\t\t\tPT_double, \"service_status_double\", PADDR(service_status_dbl),PT_DESCRIPTION,\"In and out of service flag - type double - will indiscriminately override service_status - useful for schedules\",\n\t\t\tPT_double, \"previous_uptime[min]\", PADDR(previous_uptime),PT_DESCRIPTION,\"Previous time between disconnects of node in minutes\",\n\t\t\tPT_double, \"current_uptime[min]\", PADDR(current_uptime),PT_DESCRIPTION,\"Current time since last disconnect of node in minutes\",\n\t\t\tPT_bool, \"Norton_dynamic\", PADDR(dynamic_norton),PT_ACCESS,PA_HIDDEN,PT_DESCRIPTION,\"Flag to indicate a Norton-equivalent connection -- used for generators and deltamode\",\n\t\t\tPT_bool, \"generator_dynamic\", PADDR(dynamic_generator),PT_ACCESS,PA_HIDDEN,PT_DESCRIPTION,\"Flag to indicate a voltage-sourcing or swing-type generator is present -- used for generators and deltamode\",\n\n\t\t\tPT_bool, \"reset_disabled_island_state\", PADDR(reset_island_state), PT_ACCESS, PA_HIDDEN, PT_DESCRIPTION, \"Deltamode/multi-island flag -- used to reset disabled status (and reform an island)\",\n\n\t\t\t//GFA - stuff\n\t\t\tPT_bool, \"GFA_enable\", PADDR(GFA_enable), PT_DESCRIPTION, \"Disable/Enable Grid Friendly Appliance(TM)-type functionality\",\n\t\t\tPT_double, \"GFA_freq_low_trip[Hz]\", PADDR(GFA_freq_low_trip), PT_DESCRIPTION, \"Low frequency trip point for Grid Friendly Appliance(TM)-type functionality\",\n\t\t\tPT_double, \"GFA_freq_high_trip[Hz]\", PADDR(GFA_freq_high_trip), PT_DESCRIPTION, \"High frequency trip point for Grid Friendly Appliance(TM)-type functionality\",\n\t\t\tPT_double, \"GFA_volt_low_trip[pu]\", PADDR(GFA_voltage_low_trip), PT_DESCRIPTION, \"Low voltage trip point for Grid Friendly Appliance(TM)-type functionality\",\n\t\t\tPT_double, \"GFA_volt_high_trip[pu]\", PADDR(GFA_voltage_high_trip), PT_DESCRIPTION, \"High voltage trip point for Grid Friendly Appliance(TM)-type functionality\",\n\t\t\tPT_double, \"GFA_reconnect_time[s]\", PADDR(GFA_reconnect_time), PT_DESCRIPTION, \"Reconnect time for Grid Friendly Appliance(TM)-type functionality\",\n\t\t\tPT_double, \"GFA_freq_disconnect_time[s]\", PADDR(GFA_freq_disconnect_time), PT_DESCRIPTION, \"Frequency violation disconnect time for Grid Friendly Appliance(TM)-type functionality\",\n\t\t\tPT_double, \"GFA_volt_disconnect_time[s]\", PADDR(GFA_volt_disconnect_time), PT_DESCRIPTION, \"Voltage violation disconnect time for Grid Friendly Appliance(TM)-type functionality\",\n\t\t\tPT_bool, \"GFA_status\", PADDR(GFA_status), PT_DESCRIPTION, \"Grid Friendly Appliance(TM)-type functionality - whether it is in service (not tripped) or not\",\n\n\t\t\tPT_enumeration, \"GFA_trip_method\", PADDR(GFA_trip_method), PT_DESCRIPTION, \"Reason for GFA trip - what caused the GFA to activate\",\n\t\t\t\tPT_KEYWORD, \"NONE\", (enumeration)GFA_NONE, PT_DESCRIPTION, \"No GFA trip\",\n\t\t\t\tPT_KEYWORD, \"UNDER_FREQUENCY\", (enumeration)GFA_UF, PT_DESCRIPTION, \"GFA trip for under-frequency\",\n\t\t\t\tPT_KEYWORD, \"OVER_FREQUENCY\", (enumeration)GFA_OF, PT_DESCRIPTION, \"GFA trip for over-frequency\",\n\t\t\t\tPT_KEYWORD, \"UNDER_VOLTAGE\", (enumeration)GFA_UV, PT_DESCRIPTION, \"GFA trip for under-voltage\",\n\t\t\t\tPT_KEYWORD, \"OVER_VOLTAGE\", (enumeration)GFA_OV, PT_DESCRIPTION, \"GFA trip for over-voltage\",\n\n\t\t\tPT_object, \"topological_parent\", PADDR(TopologicalParent),PT_DESCRIPTION,\"topological parent as per GLM configuration\",\n\t\t\tNULL) < 1) GL_THROW(\"unable to publish properties in %s\",__FILE__);\n\n\t\tif (gl_publish_function(oclass,\t\"interupdate_pwr_object\", (FUNCTIONADDR)interupdate_node)==NULL)\n\t\t\tGL_THROW(\"Unable to publish node deltamode function\");\n\t\tif (gl_publish_function(oclass,\t\"pwr_object_swing_swapper\", (FUNCTIONADDR)swap_node_swing_status)==NULL)\n\t\t\tGL_THROW(\"Unable to publish node swing-swapping function\");\n\t\tif (gl_publish_function(oclass,\t\"pwr_current_injection_update_map\", (FUNCTIONADDR)node_map_current_update_function)==NULL)\n\t\t\tGL_THROW(\"Unable to publish node current injection update mapping function\");\n\t\tif (gl_publish_function(oclass,\t\"attach_vfd_to_pwr_object\", (FUNCTIONADDR)attach_vfd_to_node)==NULL)\n\t\t\tGL_THROW(\"Unable to publish node VFD attachment function\");\n\t\tif (gl_publish_function(oclass, \"pwr_object_reset_disabled_status\", (FUNCTIONADDR)node_reset_disabled_status) == NULL)\n\t\t\tGL_THROW(\"Unable to publish node island-status-reset function\");\n\t\tif (gl_publish_function(oclass, \"pwr_object_swing_status_check\", (FUNCTIONADDR)node_swing_status) == NULL)\n\t\t\tGL_THROW(\"Unable to publish node swing-status check function\");\n\t}\n}\n\nint node::isa(char *classname)\n{\n\treturn strcmp(classname,\"node\")==0 || powerflow_object::isa(classname);\n}\n\nint node::create(void)\n{\n\tint result = powerflow_object::create();\n\n#ifdef SUPPORT_OUTAGES\n\tcondition=OC_NORMAL;\n#endif\n\n\tn++;\n\n\tbustype = PQ;\n\tbusflags = NF_HASSOURCE;\n\tbusphasesIn = 0;\n\tbusphasesOut = 0;\n\treference_bus = NULL;\n\tnominal_voltage = 0.0;\n\tmaximum_voltage_error = 0.0;\n\tfrequency = nominal_frequency;\n\tfault_Z = 1e-6;\n\tprev_NTime = 0;\n\tSubNode = NONE;\n\tSubNodeParent = NULL;\n\tTopologicalParent = NULL;\n\tNR_subnode_reference = NULL;\n\tExtra_Data=NULL;\n\tNR_link_table = NULL;\n\tNR_connected_links[0] = NR_connected_links[1] = 0;\n\tNR_number_child_nodes[0] = NR_number_child_nodes[1] = 0;\n\tNR_child_nodes = NULL;\n\n\tNR_node_reference = -1;\t//Newton-Raphson bus index, set to -1 initially\n\thouse_present = false;\t//House attachment flag\n\tnom_res_curr[0] = nom_res_curr[1] = nom_res_curr[2] = 0.0;\t//Nominal house current variables\n\n\tprev_phases = 0x00;\n\n\tmean_repair_time = 0.0;\n\n\t// Only used in capacitors, at this time, but put into node for future functionality (maybe with reliability?)\n\tservice_status = ND_IN_SERVICE;\n\tservice_status_dbl = -1.0;\t//Initial flag is to ignore it.  As soon as this changes, it overrides service_status\n\tlast_disconnect = 0;\t\t//Will get set in init\n\tprevious_uptime = -1.0;\t\t///< Flags as not initialized\n\tcurrent_uptime = -1.0;\t\t///< Flags as not initialized\n\n\tfull_Y = NULL;\t\t//Not used by default\n\tfull_Y_load = NULL;\t//Not used by default\n\tfull_Y_all = NULL;\t//Not used by default   **** NOTE -- full_Y_all only appears to be used by diesel QSTS exciter code - it can probably be removed when that is fixed *****\n\tBusHistTerm[0] = complex(0.0,0.0);\n\tBusHistTerm[1] = complex(0.0,0.0);\n\tBusHistTerm[2] = complex(0.0,0.0);\n\tprev_delta_time = -1.0;\n\tahrlloadstore = NULL;\n\tbhrlloadstore = NULL;\n\tchrcloadstore = NULL;\n\tLoadHistTermL = NULL;\n\tLoadHistTermC = NULL;\n\n\tmemset(voltage,0,sizeof(voltage));\n\tmemset(voltaged,0,sizeof(voltaged));\n\tmemset(current,0,sizeof(current));\n\tmemset(pre_rotated_current,0,sizeof(pre_rotated_current));\n\tmemset(power,0,sizeof(power));\n\tmemset(shunt,0,sizeof(shunt));\n\n\tdeltamode_dynamic_current[0] = deltamode_dynamic_current[1] = deltamode_dynamic_current[2] = complex(0.0,0.0);\n\n\tdeltamode_PGenTotal = complex(0.0,0.0);\n\n\tcurrent_dy[0] = current_dy[1] = current_dy[2] = complex(0.0,0.0);\n\tcurrent_dy[3] = current_dy[4] = current_dy[5] = complex(0.0,0.0);\n\tpower_dy[0] = power_dy[1] = power_dy[2] = complex(0.0,0.0);\n\tpower_dy[3] = power_dy[4] = power_dy[5] = complex(0.0,0.0);\n\tshunt_dy[0] = shunt_dy[1] = shunt_dy[2] = complex(0.0,0.0);\n\tshunt_dy[3] = shunt_dy[4] = shunt_dy[5] = complex(0.0,0.0);\n\n\tprev_voltage_value = NULL;\t//NULL the pointer, just for the sake of doing so\n\tprev_power_value = NULL;\t//NULL the pointer, again just for the sake of doing so\n\tnode_type = NORMAL_NODE;\t//Assume we're nothing special by default\n\tcurrent_accumulated = false;\n\tdeltamode_inclusive = false;\t//Begin assuming we aren't delta-enabled\n\tdynamic_norton = false;\t\t\t//By default, no one needs the Norton equivalent posting\n\tdynamic_generator = false;\t\t//By default, we don't have any generator attached\n\n\t//Check to see if we need to enable an overall frequency method, by default (individual object can override)\n\tif (all_powerflow_freq_measure_method == FMM_SIMPLE)\t//Default to simple method\n\t{\n\t\tfmeas_type = FM_SIMPLE;\t//By default, use the simple frequency measurement method\n\t}\n\telse if (all_powerflow_freq_measure_method == FMM_PLL)\t//Default to PLL\n\t{\n\t\tfmeas_type = FM_PLL;\t//By default, use the PLL frequency measurement method\n\t}\n\telse\t//Probably \"NONE\", but just default to nothing, whatever this was\n\t{\n\t\tfmeas_type = FM_NONE;\t//By default, no frequency measurement occurs\n\t}\n\n\t//Default frequency measurement parameters\n\tfreq_omega_ref=0.0;\n\tfreq_sfm_Tf=0.01;\n\tfreq_pll_Kp=10;\n\tfreq_pll_Ki=100;\n\tfirst_freq_init=true;\t//Start with saying we haven't been in yet\n\n\t//Set default values\n\tcurr_freq_state.fmeas[0] = nominal_frequency;\n\tcurr_freq_state.fmeas[1] = nominal_frequency;\n\tcurr_freq_state.fmeas[2] = nominal_frequency;\n\tcurr_freq_state.average_freq = nominal_frequency;\n\n\t//GFA functionality - put in node, in case it needs to be added\n\tGFA_enable = false;\t\t\t//disabled, by default\n\tGFA_freq_low_trip = 59.5;\n\tGFA_freq_high_trip = 60.5;\n\tGFA_voltage_low_trip = 0.8;\n\tGFA_voltage_high_trip = 1.2;\n\tGFA_reconnect_time = 300.0;\n\tGFA_freq_disconnect_time = 0.2;\n\tGFA_volt_disconnect_time = 0.2;\n\tGFA_status = true;\n\tprev_time_dbl = 0.0;\t\t\t\t//Tracking variable\n\tGFA_Update_time = 0.0;\n\tGFA_trip_method = GFA_NONE;\t\t//By default, not tripped\n\n\t//VFD-related additional functionality\n\tVFD_attached = false;\t//Not connected to a VFD\n\tVFD_updating_function = NULL;\t//Make sure is set empty\n\tVFD_object = NULL;\t//Make empty\n\n\t//Multi-island tracking\n\treset_island_state = false;\t//Reset is disabled, by default\n\n\t//Triplex/FBS variable\n\ttn_values = NULL;\n\n\treturn result;\n}\n\nint node::init(OBJECT *parent)\n{\n\tOBJECT *obj = OBJECTHDR(this);\n\n\t//Put the phase_S check right on the top, since it will apply to both solvers\n\tif (has_phase(PHASE_S))\n\t{\n\t\t//Make sure we're a valid class\n\t\tif (!(gl_object_isa(obj,\"triplex_node\",\"powerflow\") || gl_object_isa(obj,\"triplex_meter\",\"powerflow\") || gl_object_isa(obj,\"triplex_load\",\"powerflow\") || gl_object_isa(obj,\"motor\",\"powerflow\")))\n\t\t{\n\t\t\tGL_THROW(\"Object:%d - %s -- has a phase S, but is not triplex!\",obj->id,(obj->name ? obj->name : \"Unnamed\"));\n\t\t\t/*  TROUBLESHOOT\n\t\t\tA node-based object has an \"S\" in the phases, but is not a triplex_node, triplex_load, nor triplex_meter.  These are the only\n\t\t\tobjects that support this phase.  Please check your phases and try again.\n\t\t\t*/\n\t\t}\n\t\t//Default else - implies it is one of these objects, and therefore can have a phase S\n\t}\n\n\tif (solver_method==SM_NR)\n\t{\n\t\tchar ext_lib_file_name[1025];\n\t\tchar extpath[1024];\n\t\tCALLBACKS **cbackval = NULL;\n\t\tbool ExtLinkFailure;\n\t\tSTATUS status_ret_value;\n\n\t\t// Store the topological parent before anyone overwrites it\n\t\tTopologicalParent = obj->parent;\n\n\t\t//Check for a swing bus if we haven't found one already\n\t\tif (NR_swing_bus == NULL)\n\t\t{\n\t\t\t//See if a node is a master swing\n\t\t\tNR_swing_bus = NR_master_swing_search(\"node\",true);\n\n\t\t\t//If one hasn't been found, see if there's a substation one\n\t\t\tif (NR_swing_bus == NULL)\n\t\t\t{\n\t\t\t\tNR_swing_bus = NR_master_swing_search(\"substation\",true);\n\t\t\t}\n\t\t\t//Default else -- one already found, progress through this\n\n\t\t\t//If one hasn't been found, see if there's a meter one\n\t\t\tif (NR_swing_bus == NULL)\n\t\t\t{\n\t\t\t\tNR_swing_bus = NR_master_swing_search(\"meter\",true);\n\t\t\t}\n\t\t\t//Default else -- one already found, progress through this\n\n\t\t\t//If one hasn't been found, see if there's an elec_frequency one\n\t\t\tif (NR_swing_bus == NULL)\n\t\t\t{\n\t\t\t\tNR_swing_bus = NR_master_swing_search(\"elec_frequency\",true);\n\t\t\t}\n\t\t\t//Default else -- one already found, progress through this\n\n\t\t\t//If one hasn't been found, see if there's a load one\n\t\t\tif (NR_swing_bus == NULL)\n\t\t\t{\n\t\t\t\t//Do the same for loads\n\t\t\t\tNR_swing_bus = NR_master_swing_search(\"load\",true);\n\t\t\t}\n\t\t\t//Default else -- one already found, progress through this\n\n\t\t\t//If one hasn't been found, see if there's a triplex_node one\n\t\t\tif (NR_swing_bus == NULL)\n\t\t\t{\n\t\t\t\t//Do the same for triplex nodes\n\t\t\t\tNR_swing_bus = NR_master_swing_search(\"triplex_node\",true);\n\t\t\t}\n\t\t\t//Default else -- one already found, progress through this\n\n\t\t\t//If one hasn't been found, see if there's a triplex_meter one\n\t\t\tif (NR_swing_bus == NULL)\n\t\t\t{\n\t\t\t\t//And one more time for triplex meters\n\t\t\t\tNR_swing_bus = NR_master_swing_search(\"triplex_meter\",true);\n\t\t\t}\n\t\t\t//Default else -- one already found, progress through this\n\n\t\t\t//If one hasn't been found, see if there's a triplex_load one\n\t\t\tif (NR_swing_bus == NULL)\n\t\t\t{\n\t\t\t\t//And one more time for triplex loads\n\t\t\t\tNR_swing_bus = NR_master_swing_search(\"triplex_load\",true);\n\t\t\t}\n\t\t\t//Default else -- one already found, progress through this\n\n\t\t\t//Now repeat this process for SWING_PQ designations\n\t\t\t//Check nodes\n\t\t\tif (NR_swing_bus == NULL)\n\t\t\t{\n\t\t\t\tNR_swing_bus = NR_master_swing_search(\"node\",false);\n\t\t\t}\n\n\t\t\t//If one hasn't been found, see if there's a substation one\n\t\t\tif (NR_swing_bus == NULL)\n\t\t\t{\n\t\t\t\tNR_swing_bus = NR_master_swing_search(\"substation\",false);\n\t\t\t}\n\t\t\t//Default else -- one already found, progress through this\n\n\t\t\t//If one hasn't been found, see if there's a meter one\n\t\t\tif (NR_swing_bus == NULL)\n\t\t\t{\n\t\t\t\tNR_swing_bus = NR_master_swing_search(\"meter\",false);\n\t\t\t}\n\t\t\t//Default else -- one already found, progress through this\n\n\t\t\t//If one hasn't been found, see if there's an elec_frequency one\n\t\t\tif (NR_swing_bus == NULL)\n\t\t\t{\n\t\t\t\tNR_swing_bus = NR_master_swing_search(\"elec_frequency\",false);\n\t\t\t}\n\t\t\t//Default else -- one already found, progress through this\n\n\t\t\t//If one hasn't been found, see if there's a load one\n\t\t\tif (NR_swing_bus == NULL)\n\t\t\t{\n\t\t\t\t//Do the same for loads\n\t\t\t\tNR_swing_bus = NR_master_swing_search(\"load\",false);\n\t\t\t}\n\t\t\t//Default else -- one already found, progress through this\n\n\t\t\t//If one hasn't been found, see if there's a triplex_node one\n\t\t\tif (NR_swing_bus == NULL)\n\t\t\t{\n\t\t\t\t//Do the same for triplex nodes\n\t\t\t\tNR_swing_bus = NR_master_swing_search(\"triplex_node\",false);\n\t\t\t}\n\t\t\t//Default else -- one already found, progress through this\n\n\t\t\t//If one hasn't been found, see if there's a triplex_meter one\n\t\t\tif (NR_swing_bus == NULL)\n\t\t\t{\n\t\t\t\t//And one more time for triplex meters\n\t\t\t\tNR_swing_bus = NR_master_swing_search(\"triplex_meter\",false);\n\t\t\t}\n\t\t\t//Default else -- one already found, progress through this\n\n\t\t\t//If one hasn't been found, see if there's a triplex_load one\n\t\t\tif (NR_swing_bus == NULL)\n\t\t\t{\n\t\t\t\t//And one more time for triplex loads\n\t\t\t\tNR_swing_bus = NR_master_swing_search(\"triplex_load\",false);\n\t\t\t}\n\t\t\t//Default else -- one already found, progress through this\n\n\t\t\t//Make sure there is one bus to rule them all, even if it actually has rivals\n\t\t\tif (NR_swing_bus == NULL)\n\t\t\t{\n\t\t\t\tGL_THROW(\"NR: no swing bus found\");\n\t\t\t\t/*\tTROUBLESHOOT\n\t\t\t\tNo swing bus was located in the test system.  Newton-Raphson requires at least one node\n\t\t\t\tbe designated \"bustype SWING\".\n\t\t\t\t*/\n\t\t\t}\n\n\t\t\t//Now that we have one bus to rule them all, make sure it has space for its variables\n\t\t\t//Assumes one monolithic grid, by default\n\t\t\tstatus_ret_value = NR_array_structure_allocate(&NR_powerflow,1);\n\n\t\t\t//Make sure it worked\n\t\t\tif (status_ret_value == FAILED)\n\t\t\t{\n\t\t\t\tGL_THROW(\"NR: Failed to allocate monolithic grid solver arrays\");\n\t\t\t\t/*  TROUBLESHOOT\n\t\t\t\tWhile attempting to allocate the initial, single-island/monolithic array,\n\t\t\t\tan error occurred.  Please try again.  If the error persists, please submit your\n\t\t\t\tcode and a report via the ticketing/issues system.\n\t\t\t\t*/\n\t\t\t}\n\n\t\t\t//And update the master counter\n\t\t\tNR_islands_detected = 1;\n\t\t}//end swing bus search\n\n\t\t//Check for parents to see if they are a parent/childed load\n\t\tif (obj->parent!=NULL) \t//Has a parent, let's see if it is a node and link it up \n\t\t{\t\t\t\t\t\t//(this will break anything intentionally done this way - e.g. switch between two nodes)\n\t\t\t//See if it is a node/load/meter/substation\n\t\t\t\n\t\t\t\n\t\t\t/********************* FIX *******************************/\n\t\t\t/* TODO: Does this need to be revisited for other types */\n\n\n\n\n\t\t\tif (!(gl_object_isa(obj->parent,\"load\",\"powerflow\") | gl_object_isa(obj->parent,\"node\",\"powerflow\") | gl_object_isa(obj->parent,\"meter\",\"powerflow\") | gl_object_isa(obj->parent,\"substation\",\"powerflow\")))\n\t\t\t\tGL_THROW(\"NR: Parent is not a node, load or meter!\");\n\t\t\t\t/*  TROUBLESHOOT\n\t\t\t\tA Newton-Raphson parent-child connection was attempted on a non-node.  The parent object must be a node, load, or meter object in the \n\t\t\t\tpowerflow module for this connection to be successful.\n\t\t\t\t*/\n\n\t\t\tnode *parNode = OBJECTDATA(obj->parent,node);\n\n\t\t\t//See if it is a swing, just to toss a warning\n\t\t\tif ((parNode->bustype==SWING) || (parNode->bustype==SWING_PQ))\n\t\t\t{\n\t\t\t\tgl_warning(\"Node:%s is parented to a swing node and will get folded into it.\",obj->name);\n\t\t\t\t/*  TROUBLESHOOT\n\t\t\t\tWhen a node has the parent field populated, it is assumed this is for a \"zero-length\" line connection.\n\t\t\t\tIf a swing node is specified, it will assume the node is linked to the swing node via a zero-length\n\t\t\t\tconnection.  If this is undesired, remove the parenting to the swing node.\n\t\t\t\t*/\n\t\t\t}\n\n\t\t\t//Phase variable\n\t\t\tset p_phase_to_check, c_phase_to_check;\n\n\t\t\t//N-less version\n\t\t\tp_phase_to_check = (parNode->phases & (~(PHASE_N)));\n\t\t\tc_phase_to_check = (phases & (~(PHASE_N)));\n\n\t\t\t//Make sure our phases align, otherwise become angry\n\t\t\tif ((parNode->phases!=phases) && (p_phase_to_check != c_phase_to_check))\n\t\t\t{\n\t\t\t\t//Create D-less and N-less versions of both for later comparisons\n\t\t\t\tp_phase_to_check = (parNode->phases & (~(PHASE_D | PHASE_N)));\n\t\t\t\tc_phase_to_check = (phases & (~(PHASE_D | PHASE_N)));\n\n\t\t\t\t//May not necessarily be a failure, let's investiage\n\t\t\t\tif ((p_phase_to_check & c_phase_to_check) != c_phase_to_check)\t//Our parent is lacking, fail\n\t\t\t\t{\n\t\t\t\t\tGL_THROW(\"NR: Parent and child node phases for nodes %s and %s do not match!\",obj->parent->name,obj->name);\n\t\t\t\t\t//Defined above\n\t\t\t\t}\n\t\t\t\telse\t\t\t\t\t//We should be successful, but let's flag ourselves appropriately\n\t\t\t\t{\t//Essentially a replication of the no-phase section with more check\n\t\t\t\t\tif ((parNode->SubNode==CHILD) | (parNode->SubNode==DIFF_CHILD) | ((obj->parent->parent!=NR_swing_bus) && (obj->parent->parent!=NULL)))\t//Our parent is another child\n\t\t\t\t\t{\n\t\t\t\t\t\tGL_THROW(\"NR: Grandchildren are not supported at this time!\");\n\t\t\t\t\t\t/*  TROUBLESHOOT\n\t\t\t\t\t\tParent-child connections in Newton-Raphson may not go more than one level deep.  Grandchildren\n\t\t\t\t\t\t(a node parented to a node parented to a node) are unsupported at this time.  Please rearrange your\n\t\t\t\t\t\tparent-child connections appropriately, figure out a different way of performing the required connection,\n\t\t\t\t\t\tor, if your system is radial, consider using forward-back sweep.\n\t\t\t\t\t\t*/\n\t\t\t\t\t}\n\t\t\t\t\telse\t//Our parent is unchilded (or has the swing bus as a parent)\n\t\t\t\t\t{\n\t\t\t\t\t\t//Check and see if the parent or child is a delta - if so, proceed as normal\n\t\t\t\t\t\tif (((phases & PHASE_D) == PHASE_D) || ((parNode->phases & PHASE_D) == PHASE_D))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//Set appropriate flags (store parent name and flag self & parent)\n\t\t\t\t\t\t\tSubNode = DIFF_CHILD;\n\t\t\t\t\t\t\tSubNodeParent = obj->parent;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tparNode->SubNode = DIFF_PARENT;\n\t\t\t\t\t\t\tparNode->SubNodeParent = obj;\t//This may get overwritten if we have multiple children, so try not to use it anywhere mission critical.\n\t\t\t\t\t\t\tparNode->NR_number_child_nodes[0]++;\t//Increment the counter of child nodes - we'll alloc and link them later\n\n\t\t\t\t\t\t\t//Update the pointer to our parent's NR pointer (so links can go there appropriately)\n\t\t\t\t\t\t\tNR_subnode_reference = &(parNode->NR_node_reference);\n\n\t\t\t\t\t\t\t//Allocate and point our properties up to the parent node\n\t\t\t\t\t\t\tif (parNode->Extra_Data == NULL)\t//Make sure someone else hasn't allocated it for us\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tparNode->Extra_Data = (complex *)gl_malloc(9*sizeof(complex));\n\t\t\t\t\t\t\t\tif (parNode->Extra_Data == NULL)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tGL_THROW(\"NR: Memory allocation failure for differently connected load.\");\n\t\t\t\t\t\t\t\t\t/*  TROUBLESHOOT\n\t\t\t\t\t\t\t\t\tThis is a bug.  Newton-Raphson tried to allocate memory for other necessary\n\t\t\t\t\t\t\t\t\tinformation to handle a parent-child relationship with differently connected loads.\n\t\t\t\t\t\t\t\t\tPlease submit your code and a bug report using the trac website.\n\t\t\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\t//None are delta, so handle partial phasing a little better\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//Replicate \"normal phasing\" code below\n\n\t\t\t\t\t\t\t//Parent node check occurred above as part of this logic chain, so forgot from copy below\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t//Set appropriate flags (store parent name and flag self & parent)\n\t\t\t\t\t\t\tSubNode = CHILD;\n\t\t\t\t\t\t\tSubNodeParent = obj->parent;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tparNode->SubNode = PARENT;\n\t\t\t\t\t\t\tparNode->SubNodeParent = obj;\t//This may get overwritten if we have multiple children, so try not to use it anywhere mission critical.\n\t\t\t\t\t\t\tparNode->NR_number_child_nodes[0]++;\t//Increment the counter of child nodes - we'll alloc and link them later\n\n\t\t\t\t\t\t\t//Update the pointer to our parent's NR pointer (so links can go there appropriately)\n\t\t\t\t\t\t\tNR_subnode_reference = &(parNode->NR_node_reference);\n\n\t\t\t\t\t\t\t//Zero out last child power vector (used for updates)\n\t\t\t\t\t\t\tlast_child_power[0][0] = last_child_power[0][1] = last_child_power[0][2] = complex(0,0);\n\t\t\t\t\t\t\tlast_child_power[1][0] = last_child_power[1][1] = last_child_power[1][2] = complex(0,0);\n\t\t\t\t\t\t\tlast_child_power[2][0] = last_child_power[2][1] = last_child_power[2][2] = complex(0,0);\n\t\t\t\t\t\t\tlast_child_power[3][0] = last_child_power[3][1] = last_child_power[3][2] = complex(0,0);\n\t\t\t\t\t\t\tlast_child_current12 = 0.0;\n\n\t\t\t\t\t\t\t//Do the same for the delta/wye explicit portions\n\t\t\t\t\t\t\tlast_child_power_dy[0][0] = last_child_power_dy[0][1] = last_child_power_dy[0][2] = complex(0.0,0.0);\n\t\t\t\t\t\t\tlast_child_power_dy[1][0] = last_child_power_dy[1][1] = last_child_power_dy[1][2] = complex(0.0,0.0);\n\t\t\t\t\t\t\tlast_child_power_dy[2][0] = last_child_power_dy[2][1] = last_child_power_dy[2][2] = complex(0.0,0.0);\n\t\t\t\t\t\t\tlast_child_power_dy[3][0] = last_child_power_dy[3][1] = last_child_power_dy[3][2] = complex(0.0,0.0);\n\t\t\t\t\t\t\tlast_child_power_dy[4][0] = last_child_power_dy[4][1] = last_child_power_dy[4][2] = complex(0.0,0.0);\n\t\t\t\t\t\t\tlast_child_power_dy[5][0] = last_child_power_dy[5][1] = last_child_power_dy[5][2] = complex(0.0,0.0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t//Flag our index as a child as well, as yet another catch\n\t\t\t\t\tNR_node_reference = -99;\n\n\t\t\t\t\t//Adjust our rank appropriately\n\t\t\t\t\t//Ranking - similar to GS\n\t\t\t\t\tgl_set_rank(obj,3);\t\t\t\t//Put us below normal nodes (but above links)\n\t\t\t\t\t\t\t\t\t\t\t\t\t//This way load postings should propogate during sync (bottom-up)\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\t\t//Phase compatible, no issues\n\t\t\t{\n\t\t\t\tif ((parNode->SubNode==CHILD) | (parNode->SubNode==DIFF_CHILD) | (obj->parent->parent!=NULL))\t//Our parent is another child\n\t\t\t\t{\n\t\t\t\t\tGL_THROW(\"NR: Grandchildren are not supported at this time!\");\n\t\t\t\t\t//Defined above\n\t\t\t\t}\n\t\t\t\telse\t//Our parent is unchilded (or has the swing bus as a parent)\n\t\t\t\t{\n\t\t\t\t\t//Set appropriate flags (store parent name and flag self & parent)\n\t\t\t\t\tSubNode = CHILD;\n\t\t\t\t\tSubNodeParent = obj->parent;\n\n\t\t\t\t\t//Check our parent -- if it is already differently flagged, don't override it\n\t\t\t\t\tif (parNode->SubNode != DIFF_PARENT)\n\t\t\t\t\t{\n\t\t\t\t\t\tparNode->SubNode = PARENT;\n\t\t\t\t\t}\n\t\t\t\t\tparNode->SubNodeParent = obj;\t//This may get overwritten if we have multiple children, so try not to use it anywhere mission critical.\n\t\t\t\t\tparNode->NR_number_child_nodes[0]++;\t//Increment the counter of child nodes - we'll alloc and link them later\n\n\t\t\t\t\t//Update the pointer to our parent's NR pointer (so links can go there appropriately)\n\t\t\t\t\tNR_subnode_reference = &(parNode->NR_node_reference);\n\t\t\t\t}\n\n\t\t\t\t//Flag our index as a child as well, as yet another catch\n\t\t\t\tNR_node_reference = -99;\n\n\t\t\t\t//Adjust our rank appropriately\n\t\t\t\t//Ranking - similar to GS\n\t\t\t\tgl_set_rank(obj,3);\t\t\t\t//Put us below normal nodes (but above links)\n\t\t\t\t\t\t\t\t\t\t\t\t//This way load postings should propogate during sync (bottom-up)\n\n\t\t\t\t//Zero out last child power vector (used for updates)\n\t\t\t\tlast_child_power[0][0] = last_child_power[0][1] = last_child_power[0][2] = complex(0,0);\n\t\t\t\tlast_child_power[1][0] = last_child_power[1][1] = last_child_power[1][2] = complex(0,0);\n\t\t\t\tlast_child_power[2][0] = last_child_power[2][1] = last_child_power[2][2] = complex(0,0);\n\t\t\t\tlast_child_power[3][0] = last_child_power[3][1] = last_child_power[3][2] = complex(0,0);\n\t\t\t\tlast_child_current12 = 0.0;\n\n\t\t\t\t//Do the same for the delta/wye explicit portions\n\t\t\t\tlast_child_power_dy[0][0] = last_child_power_dy[0][1] = last_child_power_dy[0][2] = complex(0.0,0.0);\n\t\t\t\tlast_child_power_dy[1][0] = last_child_power_dy[1][1] = last_child_power_dy[1][2] = complex(0.0,0.0);\n\t\t\t\tlast_child_power_dy[2][0] = last_child_power_dy[2][1] = last_child_power_dy[2][2] = complex(0.0,0.0);\n\t\t\t\tlast_child_power_dy[3][0] = last_child_power_dy[3][1] = last_child_power_dy[3][2] = complex(0.0,0.0);\n\t\t\t\tlast_child_power_dy[4][0] = last_child_power_dy[4][1] = last_child_power_dy[4][2] = complex(0.0,0.0);\n\t\t\t\tlast_child_power_dy[5][0] = last_child_power_dy[5][1] = last_child_power_dy[5][2] = complex(0.0,0.0);\n\t\t\t}//end no issues phase\n\n\t\t\t//Make sure nominal voltages match\n\t\t\tif (nominal_voltage != parNode->nominal_voltage)\n\t\t\t{\n\t\t\t\tgl_warning(\"Node:%s does not have the same nominal voltage as its parent - copying voltage from parent.\",(obj->name ? obj->name : \"unnamed\"));\n\t\t\t\t/*  TROUBLESHOOT\n\t\t\t\tA node object was parented to another node object with a different nominal_voltage set.  The childed object will now\n\t\t\t\ttake the parent nominal_voltage.  If this is not intended, please add a transformer between these nodes.\n\t\t\t\t*/\n\n\t\t\t\tnominal_voltage = parNode->nominal_voltage;\n\t\t\t}\n\t\t}\n\t\telse\t//Non-childed node gets the count updated\n\t\t{\n\t\t\tNR_bus_count++;\t\t//Update global bus count for NR solver\n\n\t\t\t//Update ranking\n\t\t\t//Ranking - similar to GS\n\t\t\tif (obj==NR_swing_bus)\t//Make sure we're THE swing bus and not just A swing bus\n\t\t\t{\n\t\t\t\tgl_set_rank(obj,6);\n\t\t\t}\n\t\t\telse\t//Normal nodes and rival swing buses end up in the same rank\n\t\t\t{\t\t\n\t\t\t\tgl_set_rank(obj,4);\n\t\t\t}\n\t\t}\n\n\t\t//Use SWING node to hook in the solver - since it's called by SWING, might as well\n\t\t//Make sure it is the \"master swing\" too\n\t\tif (obj == NR_swing_bus)\n\t\t{\n\t\t\tif (LUSolverName[0]=='\\0')\t//Empty name, default to superLU\n\t\t\t{\n\t\t\t\tmatrix_solver_method=MM_SUPERLU;\t//This is the default, but we'll set it here anyways\n\t\t\t}\n\t\t\telse\t//Something is there, see if we can find it\n\t\t\t{\n\t\t\t\t//Initialize the global\n\t\t\t\tLUSolverFcns.dllLink = NULL;\n\t\t\t\tLUSolverFcns.ext_init = NULL;\n\t\t\t\tLUSolverFcns.ext_alloc = NULL;\n\t\t\t\tLUSolverFcns.ext_solve = NULL;\n\t\t\t\tLUSolverFcns.ext_destroy = NULL;\n\n#ifdef _WIN32\n\t\t\t\tsnprintf(ext_lib_file_name, 1024, \"solver_%s\" DLEXT,LUSolverName.get_string());\n#else\n\t\t\t\tsnprintf(ext_lib_file_name, 1024, \"lib_solver_%s\" DLEXT,LUSolverName.get_string());\n#endif\n\n\t\t\t\tif (gl_findfile(ext_lib_file_name, NULL, 0|4, extpath,sizeof(extpath))!=NULL)\t//Link up\n\t\t\t\t{\n\t\t\t\t\t//Link to the library\n\t\t\t\t\tLUSolverFcns.dllLink = DLLOAD(extpath);\n\n\t\t\t\t\t//Make sure it worked\n\t\t\t\t\tif (LUSolverFcns.dllLink==NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tgl_warning(\"Failure to load solver_%s as a library, defaulting to superLU\",LUSolverName.get_string());\n\t\t\t\t\t\t/*  TROUBLESHOOT\n\t\t\t\t\t\tWhile attempting to load the DLL for an external LU solver, the file did not appear to meet\n\t\t\t\t\t\tthe libary specifications.  superLU is being used instead.  Please check the library file and\n\t\t\t\t\t\ttry again.\n\t\t\t\t\t\t*/\n\t\t\t\t\t\t\n\t\t\t\t\t\t//Set to superLU\n\t\t\t\t\t\tmatrix_solver_method = MM_SUPERLU;\n\t\t\t\t\t}\n\t\t\t\t\telse\t//Found it right\n\t\t\t\t\t{\n\t\t\t\t\t\t//Set tracking flag - if anything fails, just revert to superLU and leave\n\t\t\t\t\t\tExtLinkFailure = false;\n\n\t\t\t\t\t\t//Link the callback\n\t\t\t\t\t\tcbackval = (CALLBACKS **)DLSYM(LUSolverFcns.dllLink, \"callback\");\n\t\t\t\t\t\t\n\t\t\t\t\t\t//I don't know what this does\n\t\t\t\t\t\tif(cbackval)\n\t\t\t\t\t\t\t*cbackval = callback;\n\t\t\t\t\t\t\n\t\t\t\t\t\t//Now link functions - Init\n\t\t\t\t\t\tLUSolverFcns.ext_init = DLSYM(LUSolverFcns.dllLink,\"LU_init\");\n\t\t\t\t\t\t\n\t\t\t\t\t\t//Make sure it worked\n\t\t\t\t\t\tif (LUSolverFcns.ext_init == NULL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tgl_warning(\"LU_init of external solver solver_%s not found, defaulting to superLU\",LUSolverName.get_string());\n\t\t\t\t\t\t\t/*  TROUBLESHOOT\n\t\t\t\t\t\t\tWhile attempting to link the LU_init routine of an external LU matrix solver library, the routine\n\t\t\t\t\t\t\tfailed to be found.  Check the external library and try again.  At this failure, powerflow will revert\n\t\t\t\t\t\t\tto the superLU solver for Newton-Raphson.\n\t\t\t\t\t\t\t*/\n\n\t\t\t\t\t\t\t//Flag the failure\n\t\t\t\t\t\t\tExtLinkFailure = true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//Now link functions - alloc\n\t\t\t\t\t\tLUSolverFcns.ext_alloc = DLSYM(LUSolverFcns.dllLink,\"LU_alloc\");\n\n\t\t\t\t\t\t//Make sure it worked\n\t\t\t\t\t\tif (LUSolverFcns.ext_alloc == NULL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tgl_warning(\"LU_init of external solver solver_%s not found, defaulting to superLU\",LUSolverName.get_string());\n\t\t\t\t\t\t\t/*  TROUBLESHOOT\n\t\t\t\t\t\t\tWhile attempting to link the LU_init routine of an external LU matrix solver library, the routine\n\t\t\t\t\t\t\tfailed to be found.  Check the external library and try again.  At this failure, powerflow will revert\n\t\t\t\t\t\t\tto the superLU solver for Newton-Raphson.\n\t\t\t\t\t\t\t*/\n\n\t\t\t\t\t\t\t//Flag the failure\n\t\t\t\t\t\t\tExtLinkFailure = true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//Now link functions - solve\n\t\t\t\t\t\tLUSolverFcns.ext_solve = DLSYM(LUSolverFcns.dllLink,\"LU_solve\");\n\n\t\t\t\t\t\t//Make sure it worked\n\t\t\t\t\t\tif (LUSolverFcns.ext_solve == NULL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tgl_warning(\"LU_init of external solver solver_%s not found, defaulting to superLU\",LUSolverName.get_string());\n\t\t\t\t\t\t\t/*  TROUBLESHOOT\n\t\t\t\t\t\t\tWhile attempting to link the LU_init routine of an external LU matrix solver library, the routine\n\t\t\t\t\t\t\tfailed to be found.  Check the external library and try again.  At this failure, powerflow will revert\n\t\t\t\t\t\t\tto the superLU solver for Newton-Raphson.\n\t\t\t\t\t\t\t*/\n\n\t\t\t\t\t\t\t//Flag the failure\n\t\t\t\t\t\t\tExtLinkFailure = true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//Now link functions - destroy\n\t\t\t\t\t\tLUSolverFcns.ext_destroy = DLSYM(LUSolverFcns.dllLink,\"LU_destroy\");\n\n\t\t\t\t\t\t//Make sure it worked\n\t\t\t\t\t\tif (LUSolverFcns.ext_destroy == NULL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tgl_warning(\"LU_init of external solver solver_%s not found, defaulting to superLU\",LUSolverName.get_string());\n\t\t\t\t\t\t\t/*  TROUBLESHOOT\n\t\t\t\t\t\t\tWhile attempting to link the LU_init routine of an external LU matrix solver library, the routine\n\t\t\t\t\t\t\tfailed to be found.  Check the external library and try again.  At this failure, powerflow will revert\n\t\t\t\t\t\t\tto the superLU solver for Newton-Raphson.\n\t\t\t\t\t\t\t*/\n\n\t\t\t\t\t\t\t//Flag the failure\n\t\t\t\t\t\t\tExtLinkFailure = true;\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t//If any failed, just revert to superLU (probably shouldn't even check others after a failure, but meh)\n\t\t\t\t\t\tif (ExtLinkFailure)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//Someone failed, just use superLU\n\t\t\t\t\t\t\tmatrix_solver_method=MM_SUPERLU;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tgl_verbose(\"External solver solver_%s found, utilizing for NR\",LUSolverName.get_string());\n\t\t\t\t\t\t\t/*  TROUBLESHOOT\n\t\t\t\t\t\t\tAn external LU matrix solver library was specified and found, so NR will be calculated\n\t\t\t\t\t\t\tusing that instead of superLU.\n\t\t\t\t\t\t\t*/\n\n\t\t\t\t\t\t\t//Flag as an external solver\n\t\t\t\t\t\t\tmatrix_solver_method=MM_EXTERN;\n\t\t\t\t\t\t}\n\t\t\t\t\t}//End found proper DLL\n\t\t\t\t}//end found external and linked\n\t\t\t\telse\t//Not found, just default to superLU\n\t\t\t\t{\n\t\t\t\t\tgl_warning(\"The external solver solver_%s could not be found, defaulting to superLU\",LUSolverName.get_string());\n\t\t\t\t\t/*  TROUBLESHOOT\n\t\t\t\t\tWhile attempting to link an external LU matrix solver library, the file could not be found.  Ensure it is\n\t\t\t\t\tin the proper GridLAB-D folder and is named correctly.  If the error persists, please submit your code and\n\t\t\t\t\ta bug report via the trac website.\n\t\t\t\t\t*/\n\n\t\t\t\t\t//Flag as superLU\n\t\t\t\t\tmatrix_solver_method=MM_SUPERLU;\n\t\t\t\t}//end failed to find/load\n\t\t\t}//end somethign was attempted\n\n\t\t\tif(default_resistance <= 0.0){\n\t\t\t\tgl_error(\"INIT: The global default_resistance was less than or equal to zero. default_resistance must be greater than zero.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}//End matrix solver if\n\n\t\tif (mean_repair_time < 0.0)\n\t\t{\n\t\t\tgl_warning(\"node:%s has a negative mean_repair_time, set to 1 hour\",obj->name);\n\t\t\t/*  TROUBLESHOOT\n\t\t\tA node object had a mean_repair_time that is negative.  This ia not a valid setting.\n\t\t\tThe value has been changed to 0.  Please set the variable to an appropriate variable\n\t\t\t*/\n\n\t\t\tmean_repair_time = 0.0;\t//Set to zero by default\n\t\t}\n\t}\n\telse if (solver_method==SM_GS)\n\t{\n\t\tGL_THROW(\"Gauss_Seidel is a deprecated solver and has been removed\");\n\t\t/*  TROUBLESHOOT \n\t\tThe Gauss-Seidel solver implementation has been removed as of version 3.0.\n\t\tIt was never fully functional and has not been updated in a couple versions.  The source\n\t\tcode still exists in older repositories, so if you have an interest in that implementation, please\n\t\ttry an older subversion number.\n\t\t*/\n\t}\n\telse if (solver_method == SM_FBS)\t//Forward back sweep\n\t{\n\t\t// Store the topological parent before anyone overwrites it\n\t\tTopologicalParent = obj->parent;\n\n\t\tif (obj->parent != NULL)\n\t\t{\n\t\t\tif((gl_object_isa(obj->parent,\"load\",\"powerflow\") | gl_object_isa(obj->parent,\"node\",\"powerflow\") | gl_object_isa(obj->parent,\"meter\",\"powerflow\") | gl_object_isa(obj->parent,\"substation\",\"powerflow\")))\t//Parent is another node\n\t\t\t{\n\t\t\t\tnode *parNode = OBJECTDATA(obj->parent,node);\n\n\t\t\t\t//Phase variable\n\t\t\t\tset p_phase_to_check, c_phase_to_check;\n\n\t\t\t\t//Create D-less and N-less versions of both for later comparisons\n\t\t\t\tp_phase_to_check = (parNode->phases & (~(PHASE_D | PHASE_N)));\n\t\t\t\tc_phase_to_check = (phases & (~(PHASE_D | PHASE_N)));\n\n\t\t\t\t//Make sure our phases align, otherwise become angry\n\t\t\t\tif ((p_phase_to_check & c_phase_to_check) != c_phase_to_check)\t//Our parent is lacking, fail\n\t\t\t\t{\n\t\t\t\t\tGL_THROW(\"Parent and child node phases are incompatible for nodes %s and %s.\",obj->parent->name,obj->name);\n\t\t\t\t\t/*  TROUBLESHOOT\n\t\t\t\t\tA child object does not have compatible phases with its parent.  The parent needs to at least have the phases of\n\t\t\t\t\tthe child object.  Please check your connections and try again.\n\t\t\t\t\t*/\n\t\t\t\t}\n\n\t\t\t\t//Make sure nominal voltages match\n\t\t\t\tif (nominal_voltage != parNode->nominal_voltage)\n\t\t\t\t{\n\t\t\t\t\tgl_warning(\"Node:%s does not have the same nominal voltage as its parent - copying voltage from parent.\",(obj->name ? obj->name : \"unnamed\"));\n\t\t\t\t\t//Define above\n\n\t\t\t\t\tnominal_voltage = parNode->nominal_voltage;\n\t\t\t\t}\n\t\t\t}//No else here, may be a line due to FBS implementation, so we don't want to fail on that\n\t\t}\n\t}\n\telse\n\t\tGL_THROW(\"unsupported solver method\");\n\t\t/*Defined below*/\n\n\t/* initialize the powerflow base object */\n\tint result = powerflow_object::init(parent);\n\n\t/* Ranking stuff for GS parent/child relationship - needs to be rethought - premise of loads/nodes above links MUST remain true */\n\tif (solver_method==SM_GS)\n\t{\n\t\tGL_THROW(\"Gauss_Seidel is a deprecated solver and has been removed\");\n\t\t/*  TROUBLESHOOT \n\t\tThe Gauss-Seidel solver implementation has been removed as of version 3.0.\n\t\tIt was never fully functional and has not been updated in a couple versions.  The source\n\t\tcode still exists in older repositories, so if you have an interest in that implementation, please\n\t\ttry an older subversion number.\n\t\t*/\n\t}\n\n\t/* unspecified phase inherits from parent, if any */\n\tif (nominal_voltage==0 && parent)\n\t{\n\t\tpowerflow_object *pParent = OBJECTDATA(parent,powerflow_object);\n\t\tif (gl_object_isa(parent,\"transformer\"))\n\t\t{\n\t\t\tPROPERTY *transformer_config,*transformer_secondary_voltage;\n\t\t\tOBJECT *trans_config_obj;\n\t\t\tdouble *trans_secondary_voltage_value;\n\t\t\tsize_t offset_val;\n\t\t\tchar buffer[128];\n\n\t\t\t//Get configuration link\n\t\t\ttransformer_config = gl_get_property(parent,\"configuration\");\n\n\t\t\t//Check it\n\t\t\tif (transformer_config == NULL)\n\t\t\t{\n\t\t\t\tGL_THROW(\"Error mapping secondary voltage property from transformer:%d %s\",parent->id,parent->name?parent->name:\"unnamed\");\n\t\t\t\t/*  TROUBLESHOOT\n\t\t\t\tWhile attempting to map to the secondary voltage of a transformer to get a value for nominal voltage, an error\n\t\t\t\toccurred.  Please try again.  If the problem persists, please submit your code and a bug report via the ticketing\n\t\t\t\tsystem.\n\t\t\t\t*/\n\t\t\t}\n\n\t\t\t//Pull the object pointer\n\t\t\toffset_val = gl_get_value(parent, GETADDR(parent, transformer_config), buffer, 127, transformer_config);\n\n\t\t\t//Make sure it worked\n\t\t\tif (offset_val == 0)\n\t\t\t{\n\t\t\t\tGL_THROW(\"Error mapping secondary voltage property from transformer:%d %s\",parent->id,parent->name?parent->name:\"unnamed\");\n\t\t\t\t//Defined above\n\t\t\t}\n\n\t\t\t//trans_config_obj = gl_get_object(parent,transformer_config);\n\t\t\ttrans_config_obj = gl_get_object(buffer);\n\n\t\t\tif (trans_config_obj == 0)\n\t\t\t{\n\t\t\t\tGL_THROW(\"Error mapping secondary voltage property from transformer:%d %s\",parent->id,parent->name?parent->name:\"unnamed\");\n\t\t\t\t//Defined above\n\t\t\t}\n\n\t\t\t//Now get secondary voltage\n\t\t\ttransformer_secondary_voltage = gl_get_property(trans_config_obj,\"secondary_voltage\");\n\n\t\t\t//Make sure it worked\n\t\t\tif (transformer_secondary_voltage == NULL)\n\t\t\t{\n\t\t\t\tGL_THROW(\"Error mapping secondary voltage property from transformer:%d %s\",parent->id,parent->name?parent->name:\"unnamed\");\n\t\t\t\t//Defined above\n\t\t\t}\n\n\t\t\t//Now get the final one, the double value for secondary voltage\n\t\t\ttrans_secondary_voltage_value = gl_get_double(trans_config_obj,transformer_secondary_voltage);\n\n\t\t\t//Make sure it worked\n\t\t\tif (trans_secondary_voltage_value == NULL)\n\t\t\t{\n\t\t\t\tGL_THROW(\"Error mapping secondary voltage property from transformer:%d %s\",parent->id,parent->name?parent->name:\"unnamed\");\n\t\t\t\t//Defined above\n\t\t\t}\n\n\t\t\t//Now steal the value\n\t\t\tnominal_voltage = *trans_secondary_voltage_value;\n\t\t}\n\t\telse\n\t\t\tnominal_voltage = pParent->nominal_voltage;\n\t}\n\n\t/* make sure the sync voltage limit is positive */\n\tif (maximum_voltage_error<0)\n\t\tthrow \"negative maximum_voltage_error is invalid\";\n\t\t/*\tTROUBLESHOOT\n\t\tA negative maximum voltage error was specified.  This can not be checked.  Specify a\n\t\tpositive maximum voltage error, or omit this value to let the powerflow solver automatically\n\t\tcalculate it for you.\n\t\t*/\n\n\t/* set sync_v_limit to default if needed */\n\tif (maximum_voltage_error==0.0)\n\t\tmaximum_voltage_error =  nominal_voltage * default_maximum_voltage_error;\n\n\t/* make sure fault_Z is positive */\n\tif (fault_Z<=0)\n\t\tthrow \"negative fault impedance is invalid\";\n\t\t/*\tTROUBLESHOOT\n\t\tThe node of interest has a negative or zero fault impedance value.  Specify this value as a\n\t\tpositive number to enable proper solver operation.\n\t\t*/\n\n\t/* check that nominal voltage is set */\n\tif (nominal_voltage<=0)\n\t\tthrow \"nominal_voltage is not set\";\n\t\t/*\tTROUBLESHOOT\n\t\tThe powerflow solver has detected that a nominal voltage was not specified or is invalid.\n\t\tSpecify this voltage as a positive value via nominal_voltage to enable the solver to work.\n\t\t*/\n\n\t/* update geographic degree */\n\tif (k>1)\n\t{\n\t\tif (geographic_degree>0)\n\t\t\tgeographic_degree = n/(1/(geographic_degree/n) + log((double)k));\n\t\telse\n\t\t\tgeographic_degree = n/log((double)k);\n\t}\n\n\t/* set source flags for SWING and PV buses */\n\tif ((bustype==SWING) || (bustype==SWING_PQ) || (bustype==PV))\n\t\tbusflags |= NF_HASSOURCE;\n\n\t//Pre-zero non existant phases - deltas handled by phase (for open delta)\n\tif (has_phase(PHASE_S))\t//Single phase\n\t{\n\t\tif (has_phase(PHASE_A))\n\t\t{\n\t\t\tif (voltage[0] == 0)\n\t\t\t{\n\t\t\t\tvoltage[0].SetPolar(nominal_voltage,0.0);\n\t\t\t}\n\t\t\tif (voltage[1] == 0)\n\t\t\t{\n\t\t\t\tvoltage[1].SetPolar(nominal_voltage,0.0);\n\t\t\t}\n\t\t}\n\t\telse if (has_phase(PHASE_B))\n\t\t{\n\t\t\tif (voltage[0] == 0)\n\t\t\t{\n\t\t\t\tvoltage[0].SetPolar(nominal_voltage,-PI*2/3);\n\t\t\t}\n\t\t\tif (voltage[1] == 0)\n\t\t\t{\n\t\t\t\tvoltage[1].SetPolar(nominal_voltage,-PI*2/3);\n\t\t\t}\n\t\t}\n\t\telse if (has_phase(PHASE_C))\n\t\t{\n\t\t\tif (voltage[0] == 0)\n\t\t\t{\n\t\t\t\tvoltage[0].SetPolar(nominal_voltage,PI*2/3);\n\t\t\t}\n\t\t\tif (voltage[1] == 0)\n\t\t\t{\n\t\t\t\tvoltage[1].SetPolar(nominal_voltage,PI*2/3);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//This could be a verbose - leaving it as a warning though for now\n\t\t\tgl_warning(\"node:%d - %s - triplex-based node does not specify phase connection - assuming phase A basis\",obj->id,(obj->name?obj->name:\"Unnamed\"));\n\t\t\t/*  TROUBLESHOOT\n\t\t\tA triplex-based node just has phase S specified.  Without a three-phase phase designation, it will assume this is phase A-based and set all\n\t\t\tangles appropriately.  If this is not desired, set a proper phase basis.\n\t\t\t*/\n\t\t\tif (voltage[0] == 0)\n\t\t\t{\n\t\t\t\tvoltage[0].SetPolar(nominal_voltage,0.0);\n\t\t\t}\n\t\t\tif (voltage[1] == 0)\n\t\t\t{\n\t\t\t\tvoltage[1].SetPolar(nominal_voltage,0.0);\n\t\t\t}\n\t\t}\n\n\t\tvoltage[2] = complex(0,0);\t//Ground always assumed it seems\n\t}\n\telse if (has_phase(PHASE_A|PHASE_B|PHASE_C))\t//three phase\n\t{\n\t\tif (voltage[0] == 0)\n\t\t{\n\t\t\tvoltage[0].SetPolar(nominal_voltage,0.0);\n\t\t}\n\t\tif (voltage[1] == 0)\n\t\t{\n\t\t\tvoltage[1].SetPolar(nominal_voltage,-2*PI/3);\n\t\t}\n\t\tif (voltage[2] == 0)\n\t\t{\n\t\t\tvoltage[2].SetPolar(nominal_voltage,2*PI/3);\n\t\t}\n\t}\n\telse\t//Not three phase - check for individual phases and zero them if they aren't already\n\t{\n\t\tif (!has_phase(PHASE_A))\n\t\t\tvoltage[0]=0.0;\n\t\telse if (voltage[0] == 0)\n\t\t\tvoltage[0].SetPolar(nominal_voltage,0);\n\n\t\tif (!has_phase(PHASE_B))\n\t\t\tvoltage[1]=0.0;\n\t\telse if (voltage[1] == 0)\n\t\t\tvoltage[1].SetPolar(nominal_voltage,-2*PI/3);\n\n\t\tif (!has_phase(PHASE_C))\n\t\t\tvoltage[2]=0.0;\n\t\telse if (voltage[2] == 0)\n\t\t\tvoltage[2].SetPolar(nominal_voltage,2*PI/3);\n\t}\n\n\tif (has_phase(PHASE_D) & voltageAB==0)\n\t{\t// compute 3phase voltage differences\n\t\tvoltageAB = voltageA - voltageB;\n\t\tvoltageBC = voltageB - voltageC;\n\t\tvoltageCA = voltageC - voltageA;\n\t}\n\telse if (has_phase(PHASE_S))\n\t{\n\t\t//Compute differential voltages (1-2, 1-N, 2-N)\n\t\tvoltaged[0] = voltage[0] + voltage[1];\t//12\n\t\tvoltaged[1] = voltage[1] - voltage[2];\t//2N\n\t\tvoltaged[2] = voltage[0] - voltage[2];\t//1N -- odd order\n\t}\n\n\t//Populate last_voltage with initial values - just in case\n\tif (solver_method == SM_NR)\n\t{\n\t\tlast_voltage[0] = voltage[0];\n\t\tlast_voltage[1] = voltage[1];\n\t\tlast_voltage[2] = voltage[2];\n\t}\n\n\t//Initialize uptime variables\n\tlast_disconnect = gl_globalclock;\t//Set to current clock\n\n\t//Deltamode checks - init, so no locking yet\n\tif ((obj->flags & OF_DELTAMODE) == OF_DELTAMODE)\n\t{\n\t\t//Flag the variable for later use\n\t\tdeltamode_inclusive = true;\n\n\t\t//Increment the counter for allocation\n\t\tpwr_object_count++;\n\n\t\t//Check out parent and toss some warnings\n\t\tif (TopologicalParent != NULL)\n\t\t{\n\t\t\tif ((TopologicalParent->flags & OF_DELTAMODE) != OF_DELTAMODE)\n\t\t\t{\n\t\t\t\tgl_warning(\"Object %s (node:%d) is flagged for deltamode, but it's parent is not.  This may lead to incorrect answers!\",obj->name?obj->name:\"Unknown\",obj->id);\n\t\t\t\t/*  TROUBLESHOOT\n\t\t\t\tA childed node's parent is not flagged for deltamode.  This may lead to some erroneous errors in the powerflow.  Please apply the\n\t\t\t\tflags DELTAMODE property to the parent, or utilize the all_powerflow_delta module-level flag to fix this.\n\t\t\t\t*/\n\t\t\t}\n\t\t}\n\n\t\t//update GFA-type \n\t\tprev_time_dbl = (double)gl_globalclock;\n\t}\n\n\t//See if frequency measurements are enabled\n\tif (fmeas_type != FM_NONE)\n\t{\n\t\t//Set the frequency reference, based on the system value\n\t\tfreq_omega_ref = 2.0 * PI * nominal_frequency;\n\t}\n\n\treturn result;\n}\n\n//Functionalized presync pass routines for NR solver\n//Put in place so deltamode can call it and properly udpate\nTIMESTAMP node::NR_node_presync_fxn(TIMESTAMP t0_val)\n{\n\tTIMESTAMP tresults_val;\n\tdouble curr_delta_time;\n\tdouble curr_ts_dbl, diff_dbl;\n\n\t//Set flag, just because\n\ttresults_val = TS_NEVER;\n\n\t//Zero the accumulators for later (meters and such)\n\tcurrent_inj[0] = current_inj[1] = current_inj[2] = 0.0;\n\n\t//Reset flag\n\tcurrent_accumulated = false;\n\n\t//See if in-rush is enabled and we're in deltamode\n\tif (enable_inrush_calculations == true)\n\t{\n\t\tif (deltatimestep_running > 0)\n\t\t{\n\t\t\t//Get current deltamode timestep\n\t\t\tcurr_delta_time = gl_globaldeltaclock;\n\n\t\t\t//Check and see if we're in a different timestep -- if so, zero the accumulators\n\t\t\tif (curr_delta_time != prev_delta_time)\n\t\t\t{\n\t\t\t\t//Zero the accumulators\n\t\t\t\tBusHistTerm[0] = BusHistTerm[1] = BusHistTerm[2] = complex(0.0,0.0);\n\t\t\t}\n\t\t\t//Default else - not a new time, so keep going with same values (no rezero)\n\t\t}//End deltamode running\n\t\telse\t//Enabled, but not running\n\t\t{\n\t\t\t//set the time tracking variable, just in case we are going in and out\n\t\t\tprev_delta_time = -1.0;\n\t\t}\n\t}//End inrush enabled\n\t//Defaulted else -- no in-rush or not deltamode\n\n\tif ((SubNode==DIFF_PARENT))\t//Differently connected parent - zero our accumulators\n\t{\n\t\t//Zero them.  Row 1 is power, row 2 is admittance, row 3 is current\n\t\tExtra_Data[0] = Extra_Data[1] = Extra_Data[2] = 0.0;\n\n\t\tExtra_Data[3] = Extra_Data[4] = Extra_Data[5] = 0.0;\n\n\t\tExtra_Data[6] = Extra_Data[7] = Extra_Data[8] = 0.0;\n\t}\n\n\t//Uncomment us eventually, like when houses work in deltamode\n\t////If we're a parent and \"have house\", zero our accumulator\n\t//if ((SubNode==PARENT) && (house_present==true))\n\t//{\n\t//\tnom_res_curr[0] = nom_res_curr[1] = nom_res_curr[2] = 0.0;\n\t//}\n\n\t//Base GFA Functionality\n\t//Call the GFA-type functionality, if appropriate\n\t//See if it is enabled, and we're not in deltamode\n\t//Deltamode handled explicitly elsewhere\n\tif ((GFA_enable == true) && (deltatimestep_running < 0))\n\t{\n\t\t//Extract the current timestamp, as a double\n\t\tcurr_ts_dbl = (double)t0_val;\n\n\t\t//See if we're a new timestep, otherwise, we don't care\n\t\tif (prev_time_dbl < curr_ts_dbl)\n\t\t{\n\t\t\t//Figure out how far we moved forward\n\t\t\tdiff_dbl = curr_ts_dbl - prev_time_dbl;\n\n\t\t\t//Update the value\n\t\t\tprev_time_dbl = curr_ts_dbl;\n\n\t\t\t//Do the checks\n\t\t\tGFA_Update_time = perform_GFA_checks(diff_dbl);\n\n\t\t\t//Check it\n\t\t\tif (GFA_Update_time > 0.0)\n\t\t\t{\n\t\t\t\t//See which mode we're in\n\t\t\t\tif (deltamode_inclusive == true)\n\t\t\t\t{\n\t\t\t\t\ttresults_val = t0_val + (TIMESTAMP)(floor(GFA_Update_time));\n\n\t\t\t\t\t//Regardless of the return, schedule us for a delta transition - if it clears by then, we should\n\t\t\t\t\t//hop right back out\n\t\t\t\t\tschedule_deltamode_start(tresults_val);\n\t\t\t\t}\n\t\t\t\telse\t//Steady state\n\t\t\t\t{\n\t\t\t\t\ttresults_val = t0_val + (TIMESTAMP)(ceil(GFA_Update_time));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//Default else -- same timestep, so don't care\n\t}\n\t//Default else - GFA is not enabled, or in deltamode\n\n\t//Return value\n\treturn tresults_val;\n}\n\n//Full node presync function\nTIMESTAMP node::presync(TIMESTAMP t0)\n{\n\tunsigned int index_val;\n\tFILE *NRFileDump;\n\tOBJECT *obj = OBJECTHDR(this);\n\tTIMESTAMP t1 = powerflow_object::presync(t0); \n\tTIMESTAMP temp_time_value, temp_t1_value;\n\tnode *temp_par_node = NULL;\n\tgld_property *temp_complex_property;\n\tgld_wlock *test_rlock;\n\tcomplex temp_complex_value;\n\tcomplex_array temp_complex_array;\n\tint temp_idx_x, temp_idx_y;\n\n\t//Determine the flag state - see if a schedule is overriding us\n\tif (service_status_dbl>-1.0)\n\t{\n\t\tif (service_status_dbl == 0.0)\n\t\t{\n\t\t\tservice_status = ND_OUT_OF_SERVICE;\n\t\t}\n\t\telse if (service_status_dbl == 1.0)\n\t\t{\n\t\t\tservice_status = ND_IN_SERVICE;\n\t\t}\n\t\telse\t//Unknown, toss an error to stop meddling kids\n\t\t{\n\t\t\tGL_THROW(\"Invalid value for service_status_double\");\n\t\t\t/*  TROUBLESHOOT\n\t\t\tservice_status_double was set to a value other than 0 or 1.  This variable\n\t\t\tis meant as a convenience for schedules to drive the service_status variable, so\n\t\t\tIN_SERVICE=1 and OUT_OF_SERVICE=0 are the only valid states.  Please fix the value\n\t\t\tput into this variable.\n\t\t\t*/\n\t\t}\n\t}\n\n\t//Handle disconnect items - only do at new times\n\tif (prev_NTime!=t0)\n\t{\n\t\tif (service_status == ND_IN_SERVICE)\n\t\t{\n\t\t\t//See when the last update was\n\t\t\tif ((last_disconnect == prev_NTime) && (current_uptime == -1.0))\t//Just reconnected\n\t\t\t{\n\t\t\t\t//Store one more\n\t\t\t\tlast_disconnect = t0;\n\t\t\t}\n\n\t\t\t//Update uptime value\n\t\t\ttemp_time_value = t0 - last_disconnect;\n\t\t\tcurrent_uptime = ((double)(temp_time_value))/60.0;\t//Put into minutes\n\t\t}\n\t\telse //Must be out of service\n\t\t{\n\t\t\tif (last_disconnect != prev_NTime)\t//Just disconnected\n\t\t\t{\n\t\t\t\ttemp_time_value = t0 - last_disconnect;\n\t\t\t\tprevious_uptime = ((double)(temp_time_value))/60.0;\t//Put into minutes - automatically shift into prev\n\t\t\t}\n\t\t\t//Default else - already out of service\n\t\t\tcurrent_uptime = -1.0;\t//Flag current\n\t\t\tlast_disconnect = t0;\t//Update tracking variable\n\t\t}//End out of service\n\t}//End disconnect uptime counter\n\n\t//Initial phase check - moved so all methods check now\n\tif (prev_NTime==0)\t//Should only be the very first run\n\t{\n\t\tset phase_to_check;\n\t\tphase_to_check = (phases & (~(PHASE_D | PHASE_N)));\n\t\t\n\t\t//See if everything has a source\n\t\tif (((phase_to_check & busphasesIn) != phase_to_check) && (busphasesIn != 0) && (solver_method != SM_NR))\t//Phase mismatch (and not top level node)\n\t\t{\n\t\t\tGL_THROW(\"node:%d (%s) has more phases leaving than entering\",obj->id,obj->name);\n\t\t\t/* TROUBLESHOOT\n\t\t\tA node has more phases present than it has sources coming in.  Under the Forward-Back sweep algorithm,\n\t\t\tthe system should be strictly radial.  This scenario implies either a meshed system or unconnected\n\t\t\tphases between the from and to nodes of a connected line.  Please adjust the phases appropriately.  Also\n\t\t\tbe sure no open switches are the sole connection for a phase, else this will fail as well.  In a few NR\n\t\t\tcircumstances, this can also be seen if the \"from\" and \"to\" nodes are in reverse order - the \"from\" node\n\t\t\tof a link object should be nearest the SWING node, or the node with the most phases - this error check\n\t\t\twill be updated in future versions.\n\t\t\t*/\n\t\t}\n\n\t\tif (((phase_to_check & (busphasesIn | busphasesOut) != phase_to_check) && (busphasesIn != 0 && busphasesOut != 0) && (solver_method == SM_NR)))\n\t\t{\n\t\t\tgl_error(\"node:%d (%s) has more phases leaving than entering\",obj->id,obj->name);\n\t\t\t/* TROUBLESHOOT\n\t\t\tA node has more phases present than it has sources coming in.  This scenario implies an unconnected\n\t\t\tphases between the from and to nodes of a connected line.  Please adjust the phases appropriately.  Also\n\t\t\tbe sure no open switches are the sole connection for a phase, else this will fail as well.  In a few NR\n\t\t\tcircumstances, this can also be seen if the \"from\" and \"to\" nodes are in reverse order - the \"from\" node \n\t\t\tof a link object should be nearest the SWING node, or the node with the most phases - this error check\n\t\t\twill be updated in future versions.\n\t\t\t*/\n\n\t\t\t//This used to be a throw, so make us fail (invalid just lets it finish the step)\n\t\t\treturn TS_INVALID;\n\t\t}\n\n\t\t//Deltamode check - let every object do it, for giggles\n\t\tif (enable_subsecond_models == true)\n\t\t{\n\t\t\tif (solver_method != SM_NR)\n\t\t\t{\n\t\t\t\tGL_THROW(\"deltamode simulations only support powerflow in Newton-Raphson (NR) mode at this time\");\n\t\t\t\t/*  TROUBLESHOOT\n\t\t\t\tdeltamode and dynamics simulations will only work with the powerflow module in Newton-Raphson mode.\n\t\t\t\tPlease swap to that solver and try again.\n\t\t\t\t*/\n\t\t\t}\n\t\t}\n\n\t\t//Special FBS code\n\t\tif ((solver_method==SM_FBS) && (FBS_swing_set==false))\n\t\t{\n\t\t\t//We're the first one in, we must be the SWING - set us as such\n\t\t\tbustype=SWING;\n\n\t\t\t//Deflag us\n\t\t\tFBS_swing_set=true;\n\t\t}\n\t}\n\n\tif (solver_method==SM_NR)\n\t{\n\t\tif (prev_NTime==0)\t//First run, if we are a child, make sure no one linked us before we knew that\n\t\t{\n\t\t\t//Make sure an overall SWING bus exists\n\t\t\tif (NR_swing_bus==NULL)\n\t\t\t{\n\t\t\t\tGL_THROW(\"NR: no swing bus found or specified\");\n\t\t\t\t/*\tTROUBLESHOOT\n\t\t\t\tNewton-Raphson failed to automatically assign a swing bus to the node (unchilded nodes are referenced\n\t\t\t\tto the swing bus).  This should have been detected by this point and represents a bug in the solver.\n\t\t\t\tPlease submit a bug report detailing how you obtained this message.\n\t\t\t\t*/\n\t\t\t}\n\n\t\t\tif (((SubNode == CHILD) || (SubNode == DIFF_CHILD)) && (NR_connected_links[0] > 0))\n\t\t\t{\n\t\t\t\tGL_THROW(\"NR: node:%d - %s - extra links acquired outside of init routine\",obj->id,(obj->name?obj->name : \"Unnamed\"));\n\t\t\t\t/*  TROUBLESHOOT\n\t\t\t\tWhile attempting to initialize a childed node for the NR solver, extra links that were not detected in the node::init\n\t\t\t\troutine were discovered.  This should not have happen.  Please submit your GLM and a bug report to the issues tracker.\n\t\t\t\t*/\n\t\t\t}\n\n\t\t\t//See if we need to alloc our child space\n\t\t\tif (NR_number_child_nodes[0] > 0)\t//Malloc it up\n\t\t\t{\n\t\t\t\tNR_child_nodes = (node**)gl_malloc(NR_number_child_nodes[0] * sizeof(node*));\n\n\t\t\t\t//Make sure it worked\n\t\t\t\tif (NR_child_nodes == NULL)\n\t\t\t\t{\n\t\t\t\t\tGL_THROW(\"NR: Failed to allocate child node pointing space\");\n\t\t\t\t\t/*  TROUBLESHOOT\n\t\t\t\t\tWhile attempting to allocate memory for child node connections, something failed.\n\t\t\t\t\tPlease try again.  If the error persists, please submit your code and a bug report\n\t\t\t\t\tvia the trac website.\n\t\t\t\t\t*/\n\t\t\t\t}\n\n\t\t\t\t//Ensure the pointer is zerod\n\t\t\t\tNR_number_child_nodes[1] = 0;\n\t\t\t}\n\n\t\t\t//Rank wise, children should be firing after the above malloc is done - link them beasties up\n\t\t\tif ((SubNode == CHILD) || (SubNode == DIFF_CHILD))\n\t\t\t{\n\t\t\t\t//Link the parental\n\t\t\t\tnode *parNode = OBJECTDATA(SubNodeParent,node);\n\n\t\t\t\tWRITELOCK_OBJECT(SubNodeParent);\t//Lock\n\n\t\t\t\t//Check and see if we're a house-triplex.  If so, flag our parent so NR works - just draconian write (won't hurt anything)\n\t\t\t\tif (house_present==true)\n\t\t\t\t{\n\t\t\t\t\tparNode->house_present=true;\n\t\t\t\t}\n\n\t\t\t\t//Make sure there's still room\n\t\t\t\tif (parNode->NR_number_child_nodes[1]>=parNode->NR_number_child_nodes[0])\n\t\t\t\t{\n\t\t\t\t\tgl_error(\"NR: %s tried to parent to a node that has too many children already\",obj->name);\n\t\t\t\t\t/*  TROUBLESHOOT\n\t\t\t\t\tWhile trying to link a child to its parent, a memory overrun was encountered.  Please try\n\t\t\t\t\tagain.  If the error persists, please submit you code and a bug report via the trac website.\n\t\t\t\t\t*/\n\n\t\t\t\t\tWRITEUNLOCK_OBJECT(SubNodeParent);\t//Unlock\n\n\t\t\t\t\treturn TS_INVALID;\n\t\t\t\t}\n\t\t\t\telse\t//There's space\n\t\t\t\t{\n\t\t\t\t\t//Link us\n\t\t\t\t\tparNode->NR_child_nodes[parNode->NR_number_child_nodes[1]] = OBJECTDATA(obj,node);\n\n\t\t\t\t\t//Accumulate the index\n\t\t\t\t\tparNode->NR_number_child_nodes[1]++;\n\t\t\t\t}\n\n\t\t\t\tWRITEUNLOCK_OBJECT(SubNodeParent);\t//Unlock\n\t\t\t}\n\t\t}\n\n\t\tif (NR_busdata==NULL || NR_branchdata==NULL)\t//First time any NR in (this should be the swing bus doing this)\n\t\t{\n\t\t\tif ( NR_swing_bus!=obj) WRITELOCK_OBJECT(NR_swing_bus);\t//Lock Swing for flag\n\n\t\t\tNR_busdata = (BUSDATA *)gl_malloc(NR_bus_count * sizeof(BUSDATA));\n\t\t\tif (NR_busdata==NULL)\n\t\t\t{\n\t\t\t\tgl_error(\"NR: memory allocation failure for bus table\");\n\t\t\t\t/*\tTROUBLESHOOT\n\t\t\t\tThis is a bug.  GridLAB-D failed to allocate memory for the bus table for Newton-Raphson.\n\t\t\t\tPlease submit this bug and your code.\n\t\t\t\t*/\n\n\t\t\t\t//Unlock the swing bus\n\t\t\t\tif ( NR_swing_bus!=obj) WRITEUNLOCK_OBJECT(NR_swing_bus);\n\n\t\t\t\treturn TS_INVALID;\n\t\t\t}\n\t\t\tNR_curr_bus = 0;\t//Pull pointer off flag so other objects know it's built\n\n\t\t\t//initialize the bustype - will be used for detection\n\t\t\tfor (index_val=0; index_val<NR_bus_count; index_val++)\n\t\t\t\tNR_busdata[index_val].type = -1;\n\n\t\t\tNR_branchdata = (BRANCHDATA *)gl_malloc(NR_branch_count * sizeof(BRANCHDATA));\n\t\t\tif (NR_branchdata==NULL)\n\t\t\t{\n\t\t\t\tgl_error(\"NR: memory allocation failure for branch table\");\n\t\t\t\t/*\tTROUBLESHOOT\n\t\t\t\tThis is a bug.  GridLAB-D failed to allocate memory for the link table for Newton-Raphson.\n\t\t\t\tPlease submit this bug and your code.\n\t\t\t\t*/\n\n\t\t\t\t//Unlock the swing bus\n\t\t\t\tif ( NR_swing_bus!=obj) WRITEUNLOCK_OBJECT(NR_swing_bus);\n\n\t\t\t\treturn TS_INVALID;\n\t\t\t}\n\t\t\tNR_curr_branch = 0;\t//Pull pointer off flag so other objects know it's built\n\n\t\t\t//Initialize the from - will be used for detection\n\t\t\tfor (index_val=0; index_val<NR_branch_count; index_val++)\n\t\t\t\tNR_branchdata[index_val].from = -1;\n\n\t\t\t//Allocate deltamode stuff as well\n\t\t\tif (enable_subsecond_models==true)\t//If enabled in powerflow, swing bus rules them all\n\t\t\t{\n\t\t\t\t//Make sure no one else has done it yet\n\t\t\t\tif ((pwr_object_current == -1) || (delta_objects==NULL))\n\t\t\t\t{\n\t\t\t\t\t//Allocate the deltamode object array\n\t\t\t\t\tdelta_objects = (OBJECT**)gl_malloc(pwr_object_count*sizeof(OBJECT*));\n\n\t\t\t\t\t//Make sure it worked\n\t\t\t\t\tif (delta_objects == NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tGL_THROW(\"Failed to allocate deltamode objects array for powerflow module!\");\n\t\t\t\t\t\t/*  TROUBLESHOOT\n\t\t\t\t\t\tWhile attempting to create a reference array for powerflow module deltamode-enabled\n\t\t\t\t\t\tobjects, an error was encountered.  Please try again.  If the error persists, please\n\t\t\t\t\t\tsubmit your code and a bug report via the trac website.\n\t\t\t\t\t\t*/\n\t\t\t\t\t}\n\n\t\t\t\t\t//Allocate the function reference list as well\n\t\t\t\t\tdelta_functions = (FUNCTIONADDR*)gl_malloc(pwr_object_count*sizeof(FUNCTIONADDR));\n\n\t\t\t\t\t//Make sure it worked\n\t\t\t\t\tif (delta_functions == NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tGL_THROW(\"Failed to allocate deltamode objects function array for powerflow module!\");\n\t\t\t\t\t\t/*  TROUBLESHOOT\n\t\t\t\t\t\tWhile attempting to create a reference array for powerflow module deltamode-enabled\n\t\t\t\t\t\tobjects, an error was encountered.  Please try again.  If the error persists, please\n\t\t\t\t\t\tsubmit your code and a bug report via the trac website.\n\t\t\t\t\t\t*/\n\t\t\t\t\t}\n\n\t\t\t\t\t//Allocate the post update array\n\t\t\t\t\tpost_delta_functions = (FUNCTIONADDR*)gl_malloc(pwr_object_count*sizeof(FUNCTIONADDR));\n\n\t\t\t\t\t//Make sure it worked\n\t\t\t\t\tif (post_delta_functions == NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tGL_THROW(\"Failed to allocate deltamode objects function array for powerflow module!\");\n\t\t\t\t\t\t//Defined above\n\t\t\t\t\t}\n\n\t\t\t\t\t//Initialize index\n\t\t\t\t\tpwr_object_current = 0;\n\t\t\t\t}\n\n\t\t\t\t//See if we are the swing bus AND our flag is enabled, otherwise warn\n\t\t\t\tif ((obj == NR_swing_bus) && (deltamode_inclusive == false))\n\t\t\t\t{\n\t\t\t\t\tgl_warning(\"SWING bus:%s is not flagged for deltamode\",obj->name);\n\t\t\t\t\t/*  TROUBLESHOOT\n\t\t\t\t\tDeltamode is enabled for the overall powerflow module, but not for the SWING node\n\t\t\t\t\tof the powerflow.  This means the overall powerflow is not being calculated or included\n\t\t\t\t\tin any deltamode calculations.  If this is not a desired run method, please enable the\n\t\t\t\t\tdeltamode_inclusive flag on the SWING node.\n\t\t\t\t\t*/\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//Open the NR dump file, if needed (set handle and empty it)\n\t\t\tif (NRMatDumpMethod != MD_NONE)\n\t\t\t{\n\t\t\t\t//Make sure the file name isn't empty either\n\t\t\t\tif (MDFileName[0] == '\\0')\n\t\t\t\t{\n\t\t\t\t\tgl_warning(\"NR: A matrix dump was requested, but no filename was specified. No dump will occur\");\n\t\t\t\t\t/*  TROUBLESHOOT\n\t\t\t\t\tThe powerflow module was configured such that a Newton-Raphson-based matrix dump was desired.  However, no file\n\t\t\t\t\twas specified in NR_matrix_file.  No output will be performed.\n\t\t\t\t\t*/\n\n\t\t\t\t\t//Set us to none\n\t\t\t\t\tNRMatDumpMethod = MD_NONE;\n\t\t\t\t}\n\t\t\t\telse\t//Valid, just empty us\n\t\t\t\t{\n\t\t\t\t\t//Get a file handle and empty the file\n\t\t\t\t\tNRFileDump = fopen(MDFileName,\"wt\");\n\n\t\t\t\t\t//Print a header\n\t\t\t\t\tfprintf(NRFileDump,\"Note: All indices are zero-referenced.\\n\\n\");\n\n\t\t\t\t\t//Close it, now that it's empty\n\t\t\t\t\tfclose(NRFileDump);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//Default else - no file output desired, so don't make one\n\n\t\t\t//Unlock the swing bus\n\t\t\tif ( NR_swing_bus!=obj) WRITEUNLOCK_OBJECT(NR_swing_bus);\n\n\t\t\tif (obj == NR_swing_bus)\t//Make sure we're the great MASTER SWING, as a final check\n\t\t\t{\n\t\t\t\tNR_populate();\t\t//Force a first population via the swing bus.  Not really necessary, but I'm saying it has to be this way.\n\t\t\t\tNR_admit_change = true;\t//Ensure the admittance update variable is flagged\n\t\t\t\tNR_swing_bus_reference = NR_node_reference;\t//Populate our reference too -- pretty good chance it is 0, but just to be safe\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tGL_THROW(\"NR: An order requirement has been violated\");\n\t\t\t\t/*  TROUBLESHOOT\n\t\t\t\tWhen initializing the solver, the swing bus should be initialized first for\n\t\t\t\tNewton-Raphson.  If this does not happen, unexpected results can occur.  Try moving\n\t\t\t\tthe SWING bus to the top of your file.  If the bug persists, submit your code and\n\t\t\t\ta bug report via the trac website.\n\t\t\t\t*/\n\t\t\t}\n\t\t}//End busdata and branchdata null (first in)\n\n\t\t//Comment us out eventually, when houses work in deltamode\n\t\t//If we're a parent and \"have house\", zero our accumulator\n\t\tif ((SubNode==PARENT) && (house_present==true))\n\t\t{\n\t\t\tnom_res_curr[0] = nom_res_curr[1] = nom_res_curr[2] = 0.0;\n\t\t}\n\n\t\t//Populate individual object references into deltamode, if needed\n\t\tif ((deltamode_inclusive==true) && (enable_subsecond_models == true) && (prev_NTime==0))\n\t\t{\n\t\t\tint temp_pwr_object_current;\n\n\t\t\t//Check limits first\n\t\t\tif (pwr_object_current>=pwr_object_count)\n\t\t\t{\n\t\t\t\tGL_THROW(\"Too many objects tried to populate deltamode objects array in the powerflow module!\");\n\t\t\t\t/*  TROUBLESHOOT\n\t\t\t\tWhile attempting to populate a reference array of deltamode-enabled objects for the powerflow\n\t\t\t\tmodule, an attempt was made to write beyond the allocated array space.  Please try again.  If the\n\t\t\t\terror persists, please submit a bug report and your code via the trac website.\n\t\t\t\t*/\n\t\t\t}\n\n\t\t\t//Lock the SWING bus and get us a value\n\t\t\tif ( NR_swing_bus!=obj) WRITELOCK_OBJECT(NR_swing_bus);\t//Lock Swing for flag\n\n\t\t\t\t//Get the value\n\t\t\t\ttemp_pwr_object_current = pwr_object_current;\n\n\t\t\t\t//Increment\n\t\t\t\tpwr_object_current++;\n\n\t\t\t//Unlock\n\t\t\tif ( NR_swing_bus!=obj) WRITEUNLOCK_OBJECT(NR_swing_bus);\t//Lock Swing for flag\n\n\t\t\t//Add us into the list\n\t\t\tdelta_objects[temp_pwr_object_current] = obj;\n\n\t\t\t//Map up the function\n\t\t\tdelta_functions[temp_pwr_object_current] = (FUNCTIONADDR)(gl_get_function(obj,\"interupdate_pwr_object\"));\n\n\t\t\t//Make sure it worked\n\t\t\tif (delta_functions[temp_pwr_object_current] == NULL)\n\t\t\t{\n\t\t\t\tgl_warning(\"Failure to map deltamode function for device:%s\",obj->name);\n\t\t\t\t/*  TROUBLESHOOT\n\t\t\t\tAttempts to map up the interupdate function of a specific device failed.  Please try again and ensure\n\t\t\t\tthe object supports deltamode.  This error may simply be an indication that the object of interest\n\t\t\t\tdoes not support deltamode.  If the error persists and the object does, please submit your code and\n\t\t\t\ta bug report via the trac website.\n\t\t\t\t*/\n\t\t\t}\n\n\t\t\t//Map up the post update, if we have one\n\t\t\tpost_delta_functions[temp_pwr_object_current] = (FUNCTIONADDR)(gl_get_function(obj,\"postupdate_pwr_object\"));\n\n\t\t\t//No null check, since this one just may not work (post update may not exist)\n\n\t\t\t//Do any additional parent/child mappings for deltamode -- if necessary\n\t\t\tif (((SubNode==CHILD) || (SubNode==DIFF_CHILD)) && ((dynamic_norton==true) || (dynamic_generator==true)))\n\t\t\t{\n\t\t\t\t//Map our parent\n\t\t\t\ttemp_par_node = OBJECTDATA(SubNodeParent,node);\n\n\t\t\t\t//Make sure it worked, for giggles\n\t\t\t\tif (temp_par_node == NULL)\n\t\t\t\t{\n\t\t\t\t\tGL_THROW(\"node:%s - failed to map parent object for childed node\",obj->name);\n\t\t\t\t\t/*  TROUBLESHOOT\n\t\t\t\t\tWhile attempting to link to the parent node, an error occurred.  Please try again.\n\t\t\t\t\tIf the error persists, please submit your code and a bug report via the trac website.\n\t\t\t\t\t*/\n\t\t\t\t}\n\n\t\t\t\t//Lock the parent for all of our shenanigans\n\t\t\t\tLOCK_OBJECT(SubNodeParent);\n\n\t\t\t\t//See if we're a Norton equivalent\n\t\t\t\tif (dynamic_norton==true)\n\t\t\t\t{\n\t\t\t\t\t//Flag our parent, just to make sure things work properly\n\t\t\t\t\ttemp_par_node->dynamic_norton = true;\n\n\t\t\t\t\t//See if we even have anything to contribute on the full_Y matrix\n\t\t\t\t\tif (full_Y_matrix.is_valid(0,0) == true)\n\t\t\t\t\t{\n\t\t\t\t\t\t//Make sure it is the right size\n\t\t\t\t\t\tif ((full_Y_matrix.get_rows() == 3) && (full_Y_matrix.get_cols() == 3))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//Allocate ourself\n\t\t\t\t\t\t\tfull_Y = (complex *)gl_malloc(9*sizeof(complex));\n\n\t\t\t\t\t\t\t//Check it\n\t\t\t\t\t\t\tif (full_Y==NULL)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tGL_THROW(\"Node:%s failed to allocate space for the a deltamode variable\",(obj->name?obj->name:\"Unnamed\"));\n\t\t\t\t\t\t\t\t/*  TROUBLESHOOT\n\t\t\t\t\t\t\t\tWhile attempting to allocate memory for a dynamics-required (deltamode) variable, an error\n\t\t\t\t\t\t\t\toccurred. Please try again.  If the error persists, please submit your code and a bug\n\t\t\t\t\t\t\t\treport via the trac website.\n\t\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t//Map to the parent property\n\t\t\t\t\t\t\ttemp_complex_property = new gld_property(SubNodeParent,\"deltamode_full_Y_matrix\");\n\n\t\t\t\t\t\t\t//Check it\n\t\t\t\t\t\t\tif ((temp_complex_property->is_valid() != true) || (temp_complex_property->is_complex_array() != true))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tGL_THROW(\"Node:%d - %s - parent deltamode matrix property is not valid!\",obj->id,(obj->name ? obj->name : \"Unnamed\"));\n\t\t\t\t\t\t\t\t/*  TROUBLESHOOT\n\t\t\t\t\t\t\t\tWhile attempting to map to the exposed deltamode matrix property of a powerflow parent, an error occurred.\n\t\t\t\t\t\t\t\tPlease try again.  If the error persists, please submit your model and an issue via the ticketing system.\n\t\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t//Pull down the variable\n\t\t\t\t\t\t\ttemp_complex_property->getp<complex_array>(temp_complex_array,*test_rlock);\n\n\t\t\t\t\t\t\t//See if it is valid\n\t\t\t\t\t\t\tif (temp_complex_array.is_valid(0,0) != true)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t//Create it\n\t\t\t\t\t\t\t\ttemp_complex_array.grow_to(3,3);\n\n\t\t\t\t\t\t\t\t//Zero it, by default\n\t\t\t\t\t\t\t\tfor (temp_idx_x=0; temp_idx_x<3; temp_idx_x++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tfor (temp_idx_y=0; temp_idx_y<3; temp_idx_y++)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\ttemp_complex_array.set_at(temp_idx_x,temp_idx_y,complex(0.0,0.0));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\t//Already populated, make sure it is the right size!\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif ((temp_complex_array.get_rows() != 3) && (temp_complex_array.get_cols() != 3))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tGL_THROW(\"node:%s exposed Norton-equivalent matrix is the wrong size!\",obj->name?obj->name:\"unnamed\");\n\t\t\t\t\t\t\t\t\t/*  TROUBLESHOOT\n\t\t\t\t\t\t\t\t\tWhile mapping to an admittance matrix on the parent node device, it was found it is the wrong size.\n\t\t\t\t\t\t\t\t\tPlease try again.  If the error persists, please submit your code and model via the issue tracking system.\n\t\t\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t//Default else -- right size\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t//Made it this far, just try adding them\n\t\t\t\t\t\t\ttemp_complex_array += full_Y_matrix;\n\n\t\t\t\t\t\t\t//Push it back up\n\t\t\t\t\t\t\ttemp_complex_property->setp<complex_array>(temp_complex_array,*test_rlock);\n\n\t\t\t\t\t\t\t//Loop through and store the local values, while we're at it\n\t\t\t\t\t\t\tfull_Y[0] = full_Y_matrix.get_at(0,0);\n\t\t\t\t\t\t\tfull_Y[1] = full_Y_matrix.get_at(0,1);\n\t\t\t\t\t\t\tfull_Y[2] = full_Y_matrix.get_at(0,2);\n\n\t\t\t\t\t\t\tfull_Y[3] = full_Y_matrix.get_at(1,0);\n\t\t\t\t\t\t\tfull_Y[4] = full_Y_matrix.get_at(1,1);\n\t\t\t\t\t\t\tfull_Y[5] = full_Y_matrix.get_at(1,2);\n\n\t\t\t\t\t\t\tfull_Y[6] = full_Y_matrix.get_at(2,0);\n\t\t\t\t\t\t\tfull_Y[7] = full_Y_matrix.get_at(2,1);\n\t\t\t\t\t\t\tfull_Y[8] = full_Y_matrix.get_at(2,2);\n\t\t\t\t\t\t}//End size is 3x3\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tGL_THROW(\"Node:%d - %s - Invalid deltamode matrix size!\",obj->id,(obj->name ? obj->name : \"Unnamed\"));\n\t\t\t\t\t\t\t/*  TROUBLESHOOT\n\t\t\t\t\t\t\tWhile attempting to link up to one of the deltamode dynamic matrices, an unexpected size was encountered.\n\t\t\t\t\t\t\tPlease try again.  If the error persists, please submit your code and a bug report via the issue tracker.\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t}\n\t\t\t\t\t}//End we have values\n\n\t\t\t\t\t//NULL our overall pointer -- we don't need it\n\t\t\t\t\tfull_Y_all = NULL;\n\n\t\t\t\t\t//See if we've somehow already been allocated\n\t\t\t\t\tif (full_Y_all_matrix.is_valid(0,0) == true)\n\t\t\t\t\t{\n\t\t\t\t\t\t//See if we're the right size already\n\t\t\t\t\t\tif ((full_Y_all_matrix.get_rows() != 3) && (full_Y_all_matrix.get_cols() != 3))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tGL_THROW(\"node:%s exposed Norton-equivalent matrix is the wrong size!\",obj->name?obj->name:\"unnamed\");\n\t\t\t\t\t\t\t//Defined above\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\t//Try allocating it\n\t\t\t\t\t{\n\t\t\t\t\t\tfull_Y_all_matrix.grow_to(3,3);\n\t\t\t\t\t}\n\n\t\t\t\t\t//Now zero it\n\t\t\t\t\tfor (temp_idx_x=0; temp_idx_x<3; temp_idx_x++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (temp_idx_y=0; temp_idx_y<3; temp_idx_y++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfull_Y_all_matrix.set_at(temp_idx_x,temp_idx_y,complex(0.0,0.0));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}//End Norton equivalent\n\n\t\t\t\t//Now do the other variable\n\t\t\t\tif (dynamic_generator==true)\n\t\t\t\t{\n\t\t\t\t\t//Flag our parent\n\t\t\t\t\ttemp_par_node->dynamic_generator = true;\n\t\t\t\t}\n\n\t\t\t\t//Unlock our parent\n\t\t\t\tUNLOCK_OBJECT(SubNodeParent);\n\n\t\t\t\t//NULL the pointers, if necessary (paranoia)\n\t\t\t\tif (dynamic_norton!=true)\n\t\t\t\t{\n\t\t\t\t\tfull_Y = NULL;\n\t\t\t\t\tfull_Y_all = NULL;\n\t\t\t\t}\n\n\t\t\t\t//No need to do NR mappings - we don't get hit anyways\n\t\t\t}//End child Norton equivalent/dynamic generator postings code\n\t\t}//end deltamode allocations\n\n\t\t//Call NR presync function\n\t\ttemp_time_value = NR_node_presync_fxn(t0);\n\n\t\t//Copy return value for checking\n\t\ttemp_t1_value = t1;\n\n\t\t//If we returned anything beyond TS_NEVER, see how it stacks up to t1\n\t\tif ((temp_t1_value != TS_NEVER) && (temp_time_value != TS_NEVER))\n\t\t{\n\t\t\t//See which is smaller - do manual, since abs seems to confuse things\n\t\t\tif (temp_t1_value < 0)\n\t\t\t{\n\t\t\t\tif (-temp_t1_value < temp_time_value)\n\t\t\t\t{\n\t\t\t\t\tt1 = temp_t1_value;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tt1 = -temp_time_value;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\t//Not negative\n\t\t\t{\n\t\t\t\tif (temp_t1_value < temp_time_value)\n\t\t\t\t{\n\t\t\t\t\tt1 = -temp_t1_value;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tt1 = -temp_time_value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (temp_t1_value != TS_NEVER)\n\t\t{\n\t\t\tt1 = temp_t1_value;\t//Assume negated in node, if appropriate\n\t\t}\n\t\telse if (temp_time_value != TS_NEVER)\n\t\t{\n\t\t\tt1 = -temp_time_value;\n\t\t}\n\t\telse\t//Implies both are TS_NEVER\n\t\t{\n\t\t\tt1 = TS_NEVER;\n\t\t}\n\t}//end solver_NR call\n\telse if (solver_method==SM_FBS)\n\t{\n#ifdef SUPPORT_OUTAGES\n\t\tif (condition!=OC_NORMAL)\t//We're in an abnormal state\n\t\t{\n\t\t\tvoltage[0] = voltage[1] = voltage[2] = 0.0;\t//Zero the voltages\n\t\t\tcondition = OC_NORMAL;\t//Clear the flag in case we're a switch\n\t\t}\n#endif\n\t\t/* reset the current accumulator */\n\t\tcurrent_inj[0] = current_inj[1] = current_inj[2] = complex(0,0);\n\n\t\t/* record the last sync voltage */\n\t\tlast_voltage[0] = voltage[0];\n\t\tlast_voltage[1] = voltage[1];\n\t\tlast_voltage[2] = voltage[2];\n\n\t\t/* get frequency from reference bus */\n\t\tif (reference_bus!=NULL)\n\t\t{\n\t\t\tnode *pRef = OBJECTDATA(reference_bus,node);\n\t\t\tfrequency = pRef->frequency;\n\t\t}\n\t}\n\t\n\treturn t1;\n}\n\n//Functionalized sync pass routines for NR solver\n//Put in place so deltamode can call it and properly udpate\nvoid node::NR_node_sync_fxn(OBJECT *obj)\n{\n\tint loop_index_var;\n\tSTATUS fxn_ret_value;\n\n\t//Reliability check - sets and removes voltages (theory being previous answer better than starting at 0)\n\tunsigned char phase_checks_var;\n\n\t//See if we've been initialized or not\n\tif (NR_node_reference!=-1)\n\t{\n\t\t//Do a check to see if we need to be \"islanded reset\" -- do this to re-enable phases, if needed\n\t\tif ((reset_island_state == true) && (NR_island_fail_method == true))\n\t\t{\n\t\t\t//Call the reset function - easier this way -- don't really care about the status here -- warning messages will suffice for this call\n\t\t\tfxn_ret_value = reset_node_island_condition();\n\t\t}\n\t\t//Default else -- our current state is acceptable\n\n\t\t//Make sure we're a real boy - if we're not, do nothing (we'll steal mommy's or daddy's voltages in postsync)\n\t\tif ((SubNode!=CHILD) && (SubNode!=DIFF_CHILD))\n\t\t{\n\t\t\t//Figre out what has changed\n\t\t\tphase_checks_var = ((NR_busdata[NR_node_reference].phases ^ prev_phases) & 0x8F);\n\n\t\t\tif (phase_checks_var != 0x00)\t//Something's changed\n\t\t\t{\n\t\t\t\t//See if it is a triplex\n\t\t\t\tif ((NR_busdata[NR_node_reference].origphases & 0x80) == 0x80)\n\t\t\t\t{\n\t\t\t\t\t//See if A, B, or C appeared, or disappeared\n\t\t\t\t\tif ((NR_busdata[NR_node_reference].phases & 0x80) == 0x00)\t//No phases means it was just removed\n\t\t\t\t\t{\n\t\t\t\t\t\t//Store V1 and V2\n\t\t\t\t\t\tlast_voltage[0] = voltage[0];\n\t\t\t\t\t\tlast_voltage[1] = voltage[1];\n\t\t\t\t\t\tlast_voltage[2] = voltage[2];\n\n\t\t\t\t\t\t//Clear them out\n\t\t\t\t\t\tvoltage[0] = 0.0;\n\t\t\t\t\t\tvoltage[1] = 0.0;\n\t\t\t\t\t\tvoltage[2] = 0.0;\n\t\t\t\t\t}\n\t\t\t\t\telse\t//Put back in service\n\t\t\t\t\t{\n\t\t\t\t\t\t//See if in-rush is enabled or not\n\t\t\t\t\t\tif (enable_inrush_calculations == false)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvoltage[0] = last_voltage[0];\n\t\t\t\t\t\t\tvoltage[1] = last_voltage[1];\n\t\t\t\t\t\t\tvoltage[2] = last_voltage[2];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\t//When restoring from inrush, a very small term is needed (or nothing happens)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvoltage[0] = last_voltage[0] * MULTTERM;\n\t\t\t\t\t\t\tvoltage[1] = last_voltage[1] * MULTTERM;\n\t\t\t\t\t\t\tvoltage[2] = last_voltage[2] * MULTTERM;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//Default else - leave it be and just leave them to zero (more fun!)\n\t\t\t\t\t}\n\n\t\t\t\t\t//Recalculated V12, V1N, V2N in case a child uses them\n\t\t\t\t\tvoltaged[0] = voltage[0] + voltage[1];\t//12\n\t\t\t\t\tvoltaged[1] = voltage[1] - voltage[2];\t//2N\n\t\t\t\t\tvoltaged[2] = voltage[0] - voltage[2];\t//1N -- unsure why odd\n\n\t\t\t\t}//End triplex\n\t\t\t\telse\t//Nope\n\t\t\t\t{\n\t\t\t\t\t//Find out changes, and direction\n\t\t\t\t\tif ((phase_checks_var & 0x04) == 0x04)\t//Phase A change\n\t\t\t\t\t{\n\t\t\t\t\t\t//See which way\n\t\t\t\t\t\tif ((prev_phases & 0x04) == 0x04)\t//Means A just disappeared\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlast_voltage[0] = voltage[0];\t//Store the last value\n\t\t\t\t\t\t\tvoltage[0] = 0.0;\t\t\t\t//Put us to zero, so volt_dump is happy\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\t//A just came back\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (enable_inrush_calculations == false)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvoltage[0] = last_voltage[0];\t//Read in the previous values\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\t//When restoring from inrush, a very small term is needed (or nothing happens)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvoltage[0] = last_voltage[0] * MULTTERM;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t//Default else -- in-rush enabled, just leave as they were\n\t\t\t\t\t\t}\n\t\t\t\t\t}//End Phase A change\n\n\t\t\t\t\t//Find out changes, and direction\n\t\t\t\t\tif ((phase_checks_var & 0x02) == 0x02)\t//Phase B change\n\t\t\t\t\t{\n\t\t\t\t\t\t//See which way\n\t\t\t\t\t\tif ((prev_phases & 0x02) == 0x02)\t//Means B just disappeared\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlast_voltage[1] = voltage[1];\t//Store the last value\n\t\t\t\t\t\t\tvoltage[1] = 0.0;\t\t\t\t//Put us to zero, so volt_dump is happy\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\t//B just came back\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (enable_inrush_calculations == false)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvoltage[1] = last_voltage[1];\t//Read in the previous values\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\t//When restoring from inrush, a very small term is needed (or nothing happens)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvoltage[1] = last_voltage[1] * MULTTERM;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t//Default else - in-rush enabled, we want these to be zero\n\t\t\t\t\t\t}\n\t\t\t\t\t}//End Phase B change\n\n\t\t\t\t\t//Find out changes, and direction\n\t\t\t\t\tif ((phase_checks_var & 0x01) == 0x01)\t//Phase C change\n\t\t\t\t\t{\n\t\t\t\t\t\t//See which way\n\t\t\t\t\t\tif ((prev_phases & 0x01) == 0x01)\t//Means C just disappeared\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlast_voltage[2] = voltage[2];\t//Store the last value\n\t\t\t\t\t\t\tvoltage[2] = 0.0;\t\t\t\t//Put us to zero, so volt_dump is happy\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\t//C just came back\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (enable_inrush_calculations == false)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvoltage[2] = last_voltage[2];\t//Read in the previous values\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\t//When restoring from inrush, a very small term is needed (or nothing happens)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvoltage[2] = last_voltage[2] * MULTTERM;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t//Default else - in-rush enabled and want them zero\n\t\t\t\t\t\t}\n\t\t\t\t\t}//End Phase C change\n\n\t\t\t\t\t//Recalculated VAB, VBC, and VCA, in case a child uses them\n\t\t\t\t\tvoltaged[0] = voltage[0] - voltage[1];\n\t\t\t\t\tvoltaged[1] = voltage[1] - voltage[2];\n\t\t\t\t\tvoltaged[2] = voltage[2] - voltage[0];\n\t\t\t\t}//End not triplex\n\n\t\t\t\t//Assign current value in\n\t\t\t\tprev_phases = NR_busdata[NR_node_reference].phases;\n\t\t\t}//End Phase checks for reliability\n\t\t}//End normal node\n\n\t\tif (SubNode==CHILD)\n\t\t{\n\t\t\t//Post our loads up to our parent\n\t\t\tnode *ParToLoad = OBJECTDATA(SubNodeParent,node);\n\n\t\t\t//Lock the parent for accumulation\n\t\t\tLOCK_OBJECT(SubNodeParent);\n\n\t\t\t//Import power and \"load\" characteristics\n\t\t\tParToLoad->power[0]+=power[0]-last_child_power[0][0];\n\t\t\tParToLoad->power[1]+=power[1]-last_child_power[0][1];\n\t\t\tParToLoad->power[2]+=power[2]-last_child_power[0][2];\n\n\t\t\tParToLoad->shunt[0]+=shunt[0]-last_child_power[1][0];\n\t\t\tParToLoad->shunt[1]+=shunt[1]-last_child_power[1][1];\n\t\t\tParToLoad->shunt[2]+=shunt[2]-last_child_power[1][2];\n\n\t\t\tParToLoad->current[0]+=current[0]-last_child_power[2][0];\n\t\t\tParToLoad->current[1]+=current[1]-last_child_power[2][1];\n\t\t\tParToLoad->current[2]+=current[2]-last_child_power[2][2];\n\n\t\t\tParToLoad->pre_rotated_current[0] += pre_rotated_current[0]-last_child_power[3][0];\n\t\t\tParToLoad->pre_rotated_current[1] += pre_rotated_current[1]-last_child_power[3][1];\n\t\t\tParToLoad->pre_rotated_current[2] += pre_rotated_current[2]-last_child_power[3][2];\n\n\t\t\t//And the deltamode accumulators too -- if deltamode\n\t\t\tif (deltamode_inclusive == true)\n\t\t\t{\n\t\t\t\t//Pull our parent value down -- everything is being pushed up there anyways\n\t\t\t\t//Pulling to keep meters accurate (theoretically)\n\t\t\t\tdeltamode_dynamic_current[0] = ParToLoad->deltamode_dynamic_current[0];\n\t\t\t\tdeltamode_dynamic_current[1] = ParToLoad->deltamode_dynamic_current[1];\n\t\t\t\tdeltamode_dynamic_current[2] = ParToLoad->deltamode_dynamic_current[2];\n\t\t\t}\n\n\t\t\t//Do the same for the explicit delta/wye loads - last_child_power is set up as columns of ZIP, not ABC\n\t\t\tfor (loop_index_var=0; loop_index_var<6; loop_index_var++)\n\t\t\t{\n\t\t\t\tParToLoad->power_dy[loop_index_var] += power_dy[loop_index_var] - last_child_power_dy[loop_index_var][0];\n\t\t\t\tParToLoad->shunt_dy[loop_index_var] += shunt_dy[loop_index_var] - last_child_power_dy[loop_index_var][1];\n\t\t\t\tParToLoad->current_dy[loop_index_var] += current_dy[loop_index_var] - last_child_power_dy[loop_index_var][2];\n\t\t\t}\n\n\t\t\tif (has_phase(PHASE_S))\t//Triplex gets another term as well\n\t\t\t{\n\t\t\t\tParToLoad->current12 +=current12-last_child_current12;\n\t\t\t}\n\n\t\t\t//See if we have a house!\n\t\t\tif (house_present==true)\t//Add our values into our parent's accumulator!\n\t\t\t{\n\t\t\t\tParToLoad->nom_res_curr[0] += nom_res_curr[0];\n\t\t\t\tParToLoad->nom_res_curr[1] += nom_res_curr[1];\n\t\t\t\tParToLoad->nom_res_curr[2] += nom_res_curr[2];\n\t\t\t}\n\n\t\t\t//Unlock the parent now that we are done\n\t\t\tUNLOCK_OBJECT(SubNodeParent);\n\n\t\t\t//Update previous power tracker\n\t\t\tlast_child_power[0][0] = power[0];\n\t\t\tlast_child_power[0][1] = power[1];\n\t\t\tlast_child_power[0][2] = power[2];\n\n\t\t\tlast_child_power[1][0] = shunt[0];\n\t\t\tlast_child_power[1][1] = shunt[1];\n\t\t\tlast_child_power[1][2] = shunt[2];\n\n\t\t\tlast_child_power[2][0] = current[0];\n\t\t\tlast_child_power[2][1] = current[1];\n\t\t\tlast_child_power[2][2] = current[2];\n\n\t\t\tlast_child_power[3][0] = pre_rotated_current[0];\n\t\t\tlast_child_power[3][1] = pre_rotated_current[1];\n\t\t\tlast_child_power[3][2] = pre_rotated_current[2];\n\n\t\t\t//Do the same for delta/wye explicit loads\n\t\t\tfor (loop_index_var=0; loop_index_var<6; loop_index_var++)\n\t\t\t{\n\t\t\t\tlast_child_power_dy[loop_index_var][0] = power_dy[loop_index_var];\n\t\t\t\tlast_child_power_dy[loop_index_var][1] = shunt_dy[loop_index_var];\n\t\t\t\tlast_child_power_dy[loop_index_var][2] = current_dy[loop_index_var];\n\t\t\t}\n\n\t\t\tif (has_phase(PHASE_S))\t\t//Triplex extra current update\n\t\t\t\tlast_child_current12 = current12;\n\t\t}\n\n\t\t//Accumulations for \"differently connected nodes\" is still basically the same for delta/wye combination loads\n\t\tif (SubNode==DIFF_CHILD)\n\t\t{\n\t\t\t//Post our loads up to our parent - in the appropriate fashion\n\t\t\tnode *ParToLoad = OBJECTDATA(SubNodeParent,node);\n\n\t\t\t//Lock the parent for accumulation\n\t\t\tLOCK_OBJECT(SubNodeParent);\n\n\t\t\t//Update post them.  Row 1 is power, row 2 is admittance, row 3 is current\n\t\t\tParToLoad->Extra_Data[0] += power[0];\n\t\t\tParToLoad->Extra_Data[1] += power[1];\n\t\t\tParToLoad->Extra_Data[2] += power[2];\n\n\t\t\tParToLoad->Extra_Data[3] += shunt[0];\n\t\t\tParToLoad->Extra_Data[4] += shunt[1];\n\t\t\tParToLoad->Extra_Data[5] += shunt[2];\n\n\t\t\tParToLoad->Extra_Data[6] += current[0];\n\t\t\tParToLoad->Extra_Data[7] += current[1];\n\t\t\tParToLoad->Extra_Data[8] += current[2];\n\n\t\t\t//Add in the unrotated stuff too -- it should never be subject to \"connectivity\"\n\t\t\tParToLoad->pre_rotated_current[0] += pre_rotated_current[0];\n\t\t\tParToLoad->pre_rotated_current[1] += pre_rotated_current[1];\n\t\t\tParToLoad->pre_rotated_current[2] += pre_rotated_current[2];\n\n\t\t\t//And the deltamode accumulators too -- if deltamode\n\t\t\tif (deltamode_inclusive == true)\n\t\t\t{\n\t\t\t\t//Pull our parent value down -- everything is being pushed up there anyways\n\t\t\t\t//Pulling to keep meters accurate (theoretically)\n\t\t\t\tdeltamode_dynamic_current[0] = ParToLoad->deltamode_dynamic_current[0];\n\t\t\t\tdeltamode_dynamic_current[1] = ParToLoad->deltamode_dynamic_current[1];\n\t\t\t\tdeltamode_dynamic_current[2] = ParToLoad->deltamode_dynamic_current[2];\n\t\t\t}\n\n\t\t\t//Import power and \"load\" characteristics for explicit delta/wye portions\n\t\t\tfor (loop_index_var=0; loop_index_var<6; loop_index_var++)\n\t\t\t{\n\t\t\t\tParToLoad->power_dy[loop_index_var] += power_dy[loop_index_var];\n\t\t\t\tParToLoad->shunt_dy[loop_index_var] += shunt_dy[loop_index_var];\n\t\t\t\tParToLoad->current_dy[loop_index_var] += current_dy[loop_index_var];\n\t\t\t}\n\n\t\t\t//Finished, unlock parent\n\t\t\tUNLOCK_OBJECT(SubNodeParent);\n\n\t\t\t//Update our tracking variable\n\t\t\tfor (loop_index_var=0; loop_index_var<6; loop_index_var++)\n\t\t\t{\n\t\t\t\tlast_child_power_dy[loop_index_var][0] = power_dy[loop_index_var];\n\t\t\t\tlast_child_power_dy[loop_index_var][1] = shunt_dy[loop_index_var];\n\t\t\t\tlast_child_power_dy[loop_index_var][2] = current_dy[loop_index_var];\n\t\t\t}\n\n\t\t\t//Store the unrotated too\n\t\t\tlast_child_power[3][0] = pre_rotated_current[0];\n\t\t\tlast_child_power[3][1] = pre_rotated_current[1];\n\t\t\tlast_child_power[3][2] = pre_rotated_current[2];\n\t\t}//End differently connected child\n\n\t\t//Call the VFD update, if we need it\n\t\t//Note -- this basically precludes childed nodes from working, which is acceptable (programmer says so)\n\t\tif (VFD_attached == true)\n\t\t{\n\t\t\t//Call the function - make the VFD move us along\n\t\t\tfxn_ret_value = ((STATUS (*)(OBJECT *))(*VFD_updating_function))(VFD_object);\n\n\t\t\t//Check the return value\n\t\t\tif (fxn_ret_value == FAILED)\n\t\t\t{\n\t\t\t\tGL_THROW(\"node:%d - %s -- Failed VFD updating function\",obj->id,(obj->name ? obj->name : \"Unnamed\"));\n\t\t\t\t/*  TROUBLESHOOT\n\t\t\t\tWhile attempting to call the VFD current injection function, an error occurred.  Please try again.\n\t\t\t\tIf the error persists, please submit an issue.\n\t\t\t\t*/\n\t\t\t}\n\t\t}\n\t}//end not uninitialized\n}\n\nTIMESTAMP node::sync(TIMESTAMP t0)\n{\n\tTIMESTAMP t1 = powerflow_object::sync(t0);\n\tOBJECT *obj = OBJECTHDR(this);\n\tcomplex delta_current[3];\n\tcomplex power_current[3];\n\tcomplex delta_shunt[3];\n\tcomplex delta_shunt_curr[3];\n\tcomplex dy_curr_accum[3];\n\tcomplex temp_current_val[3];\n\tchar loop_index_val;\n\tcomplex temp_curr_rotate_value, temp_curr_calc_value;\n\tgld_property *temp_property;\n\t\n\t//Final initialization issue - has to be here, or childed deltamode stuff fails\n\t//This catches any orphaned/islanded single nodes (that link wouldn't catch), so error checks work\n\t//and don't segfault things - needs to be duplicated to subclass objects that reference NR before node::sync is called\n\tif ((prev_NTime==0) && (solver_method == SM_NR))\n\t{\n\t\t//See if we've been initialized yet - links typically do this, but single buses get missed\n\t\tif (NR_node_reference == -1)\n\t\t{\n\t\t\t//Call the populate routine\n\t\t\tNR_populate();\n\t\t}\n\t}\n\n\t//Generic time keeping variable - used for phase checks (GS does this explicitly below)\n\tif (t0!=prev_NTime)\n\t{\n\t\t//Update time tracking variable\n\t\tprev_NTime=t0;\n\t}\n\n\tswitch (solver_method)\n\t{\n\tcase SM_FBS:\n\t\t{\n\t\tif (phases&PHASE_S)\n\t\t{\t// Split phase\n\t\t\tcomplex temp_inj[2];\n\t\t\tcomplex adjusted_curr[3];\n\t\t\tcomplex temp_curr_val[3];\n\n\t\t\tif (house_present)\n\t\t\t{\n\t\t\t\t//Update phase adjustments\n\t\t\t\tadjusted_curr[0].SetPolar(1.0,voltage[0].Arg());\t//Pull phase of V1\n\t\t\t\tadjusted_curr[1].SetPolar(1.0,voltage[1].Arg());\t//Pull phase of V2\n\t\t\t\tadjusted_curr[2].SetPolar(1.0,voltaged[0].Arg());\t//Pull phase of V12\n\n\t\t\t\t//Update these current contributions\n\t\t\t\ttemp_curr_val[0] = nom_res_curr[0]/(~adjusted_curr[0]);\t\t//Just denominator conjugated to keep math right (rest was conjugated in house)\n\t\t\t\ttemp_curr_val[1] = nom_res_curr[1]/(~adjusted_curr[1]);\n\t\t\t\ttemp_curr_val[2] = nom_res_curr[2]/(~adjusted_curr[2]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttemp_curr_val[0] = temp_curr_val[1] = temp_curr_val[2] = 0.0;\t//No house present, just zero em\n\t\t\t}\n\n#ifdef SUPPORT_OUTAGES\n\t\t\tif (voltage[0]!=0.0)\n\t\t\t{\n#endif\n\t\t\tcomplex d1 = (voltage1.IsZero() || (power1.IsZero() && shunt1.IsZero())) ? (current1 + temp_curr_val[0]) : (current1 + ~(power1/voltage1) + voltage1*shunt1 + temp_curr_val[0]);\n\t\t\tcomplex d2 = ((voltage1+voltage2).IsZero() || (power12.IsZero() && shunt12.IsZero())) ? (current12 + temp_curr_val[2]) : (current12 + ~(power12/(voltage1+voltage2)) + (voltage1+voltage2)*shunt12 + temp_curr_val[2]);\n\t\t\t\n\t\t\tcurrent_inj[0] += d1;\n\t\t\ttemp_inj[0] = current_inj[0];\n\t\t\tcurrent_inj[0] += d2;\n\n#ifdef SUPPORT_OUTAGES\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttemp_inj[0] = 0.0;\n\t\t\t\t//WRITELOCK_OBJECT(obj);\n\t\t\t\tcurrent_inj[0]=0.0;\n\t\t\t\t//UNLOCK_OBJECT(obj);\n\t\t\t}\n\n\t\t\tif (voltage[1]!=0)\n\t\t\t{\n#endif\n\t\t\td1 = (voltage2.IsZero() || (power2.IsZero() && shunt2.IsZero())) ? (-current2 - temp_curr_val[1]) : (-current2 - ~(power2/voltage2) - voltage2*shunt2 - temp_curr_val[1]);\n\t\t\td2 = ((voltage1+voltage2).IsZero() || (power12.IsZero() && shunt12.IsZero())) ? (-current12 - temp_curr_val[2]) : (-current12 - ~(power12/(voltage1+voltage2)) - (voltage1+voltage2)*shunt12 - temp_curr_val[2]);\n\n\t\t\tcurrent_inj[1] += d1;\n\t\t\ttemp_inj[1] = current_inj[1];\n\t\t\tcurrent_inj[1] += d2;\n\t\t\t\n#ifdef SUPPORT_OUTAGES\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttemp_inj[0] = 0.0;\n\t\t\t\t//WRITELOCK_OBJECT(obj);\n\t\t\t\tcurrent_inj[1] = 0.0;\n\t\t\t\t//UNLOCK_OBJECT(obj);\n\t\t\t}\n#endif\n\n\t\t\tif (obj->parent!=NULL && gl_object_isa(obj->parent,\"triplex_line\",\"powerflow\")) {\n\n\t\t\t\t//See if we've mapped yet\n\t\t\t\tif (tn_values == NULL)\n\t\t\t\t{\n\t\t\t\t\t//Allocate space\n\t\t\t\t\ttn_values = (complex *)gl_malloc(2*sizeof(complex));\n\n\t\t\t\t\t//Make sure it worked\n\t\t\t\t\tif (tn_values == NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tGL_THROW(\"node:%d - %s -- Failed to allocate for triplex current data\",obj->id,(obj->name ? obj->name : \"Unnamed\"));\n\t\t\t\t\t\t/*  TROUBLESHOOT\n\t\t\t\t\t\tWhile attempting to allocate memory for triplex neutral calculation values, an error occurred.\n\t\t\t\t\t\tPlease try again.  If the error persists, please submit you GLM and a report via the issue tracker system.\n\t\t\t\t\t\t*/\n\t\t\t\t\t}\n\n\t\t\t\t\t//Map to neutral current properties\n\n\t\t\t\t\t//Get first one\n\t\t\t\t\ttemp_property = new gld_property(obj->parent,\"triplex_neutral_1_value\");\n\n\t\t\t\t\t//Make sure it worked\n\t\t\t\t\tif ((temp_property->is_valid() != true) || (temp_property->is_complex() != true))\n\t\t\t\t\t{\n\t\t\t\t\t\tGL_THROW(\"node:%d - %s -- Failed to map triplex current data\",obj->id,(obj->name ? obj->name : \"Unnamed\"));\n\t\t\t\t\t\t/* TROUBLESHOOT\n\t\t\t\t\t\tWhile attempting to map one of the triplex-line-related multiplier properties, an error occurred.\n\t\t\t\t\t\tPlease try again.  If the error persists, please submit your GLM into the issue tracker with a description.\n\t\t\t\t\t\t*/\n\t\t\t\t\t}\n\n\t\t\t\t\t//Pull the value\n\t\t\t\t\ttn_values[0] = temp_property->get_complex();\n\n\t\t\t\t\t//Remove it\n\t\t\t\t\tdelete temp_property;\n\n\t\t\t\t\t//Get the other one\n\t\t\t\t\t//Get first one\n\t\t\t\t\ttemp_property = new gld_property(obj->parent,\"triplex_neutral_2_value\");\n\n\t\t\t\t\t//Make sure it worked\n\t\t\t\t\tif ((temp_property->is_valid() != true) || (temp_property->is_complex() != true))\n\t\t\t\t\t{\n\t\t\t\t\t\tGL_THROW(\"node:%d - %s -- Failed to map triplex current data\",obj->id,(obj->name ? obj->name : \"Unnamed\"));\n\t\t\t\t\t\t//Defined above\n\t\t\t\t\t}\n\n\t\t\t\t\t//Pull the value\n\t\t\t\t\ttn_values[1] = temp_property->get_complex();\n\n\t\t\t\t\t//Remove it\n\t\t\t\t\tdelete temp_property;\n\t\t\t\t}\n\t\t\t\t//Default else - already mapped, so go forth\n\n\t\t\t\tcomplex d = tn_values[0]*current_inj[0] + tn_values[1]*current_inj[1];\n\t\t\t\tcurrent_inj[2] += d;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcomplex d = ((voltage1.IsZero() || (power1.IsZero() && shunt1.IsZero())) ||\n\t\t\t\t\t\t\t\t   (voltage2.IsZero() || (power2.IsZero() && shunt2.IsZero()))) \n\t\t\t\t\t\t\t\t\t? currentN : -(temp_inj[0] + temp_inj[1]);\n\t\t\t\tcurrent_inj[2] += d;\n\t\t\t}\n\t\t}\n\t\telse if (has_phase(PHASE_D)) \n\t\t{   // 'Delta' connected load\n\t\t\t\n\t\t\t//Convert delta connected power to appropriate line current\n\t\t\tdelta_current[0]= (voltaged[0].IsZero()) ? 0 : ~(power[0]/voltaged[0]);\n\t\t\tdelta_current[1]= (voltaged[1].IsZero()) ? 0 : ~(power[1]/voltaged[1]);\n\t\t\tdelta_current[2]= (voltaged[2].IsZero()) ? 0 : ~(power[2]/voltaged[2]);\n\n\t\t\tpower_current[0]=delta_current[0]-delta_current[2];\n\t\t\tpower_current[1]=delta_current[1]-delta_current[0];\n\t\t\tpower_current[2]=delta_current[2]-delta_current[1];\n\n\t\t\t//Convert delta connected load to appropriate line current\n\t\t\tdelta_shunt[0] = voltaged[0]*shunt[0];\n\t\t\tdelta_shunt[1] = voltaged[1]*shunt[1];\n\t\t\tdelta_shunt[2] = voltaged[2]*shunt[2];\n\n\t\t\tdelta_shunt_curr[0] = delta_shunt[0]-delta_shunt[2];\n\t\t\tdelta_shunt_curr[1] = delta_shunt[1]-delta_shunt[0];\n\t\t\tdelta_shunt_curr[2] = delta_shunt[2]-delta_shunt[1];\n\n\t\t\t//Convert delta-current into a phase current - reuse temp variable\n\t\t\tdelta_current[0]=current[0]-current[2];\n\t\t\tdelta_current[1]=current[1]-current[0];\n\t\t\tdelta_current[2]=current[2]-current[1];\n\n#ifdef SUPPORT_OUTAGES\n\t\t\tfor (char kphase=0;kphase<3;kphase++)\n\t\t\t{\n\t\t\t\tif (voltaged[kphase]==0.0)\n\t\t\t\t{\n\t\t\t\t\t//WRITELOCK_OBJECT(obj);\n\t\t\t\t\tcurrent_inj[kphase] = 0.0;\n\t\t\t\t\t//UNLOCK_OBJECT(obj);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t//WRITELOCK_OBJECT(obj);\n\t\t\t\t\tcurrent_inj[kphase] += delta_current[kphase] + power_current[kphase] + delta_shunt_curr[kphase];\n\t\t\t\t\t//UNLOCK_OBJECT(obj);\n\t\t\t\t}\n\t\t\t}\n#else\n\t\t\ttemp_current_val[0] = delta_current[0] + power_current[0] + delta_shunt_curr[0];\n\t\t\ttemp_current_val[1] = delta_current[1] + power_current[1] + delta_shunt_curr[1];\n\t\t\ttemp_current_val[2] = delta_current[2] + power_current[2] + delta_shunt_curr[2];\n\n\t\t\tcurrent_inj[0] += temp_current_val[0];\n\t\t\tcurrent_inj[1] += temp_current_val[1];\n\t\t\tcurrent_inj[2] += temp_current_val[2];\n#endif\n\t\t}\n\t\telse \n\t\t{\t// 'WYE' connected load\n\n#ifdef SUPPORT_OUTAGES\n\t\t\tfor (char kphase=0;kphase<3;kphase++)\n\t\t\t{\n\t\t\t\tif (voltage[kphase]==0.0)\n\t\t\t\t{\n\t\t\t\t\t//WRITELOCK_OBJECT(obj);\n\t\t\t\t\tcurrent_inj[kphase] = 0.0;\n\t\t\t\t\t//UNLOCK_OBJECT(obj);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcomplex d = ((voltage[kphase]==0.0) || ((power[kphase] == 0) && shunt[kphase].IsZero())) ? current[kphase] : current[kphase] + ~(power[kphase]/voltage[kphase]) + voltage[kphase]*shunt[kphase];\n\t\t\t\t\t//WRITELOCK_OBJECT(obj);\n\t\t\t\t\tcurrent_inj[kphase] += d;\n\t\t\t\t\t//UNLOCK_OBJECT(obj);\n\t\t\t\t}\n\t\t\t}\n#else\n\n\t\t\ttemp_current_val[0] = (voltage[0].IsZero() || (power[0].IsZero() && shunt[0].IsZero())) ? current[0] : current[0] + ~(power[0]/voltage[0]) + voltage[0]*shunt[0];\n\t\t\ttemp_current_val[1] = (voltage[1].IsZero() || (power[1].IsZero() && shunt[1].IsZero())) ? current[1] : current[1] + ~(power[1]/voltage[1]) + voltage[1]*shunt[1];\n\t\t\ttemp_current_val[2] = (voltage[2].IsZero() || (power[2].IsZero() && shunt[2].IsZero())) ? current[2] : current[2] + ~(power[2]/voltage[2]) + voltage[2]*shunt[2];\n\n\t\t\tcurrent_inj[0] += temp_current_val[0];\n\t\t\tcurrent_inj[1] += temp_current_val[1];\n\t\t\tcurrent_inj[2] += temp_current_val[2];\n#endif\n\t\t}\n\n\t\t//Handle explicit delta-wye connections now -- no triplex\n\t\tif (!(has_phase(PHASE_S)))\n\t\t{\n\t\t\t//Convert delta connected power to appropriate line current\n\t\t\tdelta_current[0]= (voltageAB.IsZero()) ? 0 : ~(power_dy[0]/voltageAB);\n\t\t\tdelta_current[1]= (voltageBC.IsZero()) ? 0 : ~(power_dy[1]/voltageBC);\n\t\t\tdelta_current[2]= (voltageCA.IsZero()) ? 0 : ~(power_dy[2]/voltageCA);\n\n\t\t\tpower_current[0]=delta_current[0]-delta_current[2];\n\t\t\tpower_current[1]=delta_current[1]-delta_current[0];\n\t\t\tpower_current[2]=delta_current[2]-delta_current[1];\n\n\t\t\t//Convert delta connected load to appropriate line current\n\t\t\tdelta_shunt[0] = voltageAB*shunt_dy[0];\n\t\t\tdelta_shunt[1] = voltageBC*shunt_dy[1];\n\t\t\tdelta_shunt[2] = voltageCA*shunt_dy[2];\n\n\t\t\tdelta_shunt_curr[0] = delta_shunt[0]-delta_shunt[2];\n\t\t\tdelta_shunt_curr[1] = delta_shunt[1]-delta_shunt[0];\n\t\t\tdelta_shunt_curr[2] = delta_shunt[2]-delta_shunt[1];\n\n\t\t\t//Convert delta-current into a phase current - reuse temp variable\n\t\t\tdelta_current[0]=current_dy[0]-current_dy[2];\n\t\t\tdelta_current[1]=current_dy[1]-current_dy[0];\n\t\t\tdelta_current[2]=current_dy[2]-current_dy[1];\n\n\t\t\t//Accumulate\n\t\t\tdy_curr_accum[0] = delta_current[0] + power_current[0] + delta_shunt_curr[0];\n\t\t\tdy_curr_accum[1] = delta_current[1] + power_current[1] + delta_shunt_curr[1];\n\t\t\tdy_curr_accum[2] = delta_current[2] + power_current[2] + delta_shunt_curr[2];\n\n\t\t\t//Wye-connected portions\n\t\t\tdy_curr_accum[0] += (voltageA.IsZero() || (power_dy[3].IsZero() && shunt_dy[3].IsZero())) ? current_dy[3] : current_dy[3] + ~(power_dy[3]/voltageA) + voltageA*shunt_dy[3];\n\t\t\tdy_curr_accum[1] += (voltageB.IsZero() || (power_dy[4].IsZero() && shunt_dy[4].IsZero())) ? current_dy[4] : current_dy[4] + ~(power_dy[4]/voltageB) + voltageB*shunt_dy[4];\n\t\t\tdy_curr_accum[2] += (voltageC.IsZero() || (power_dy[5].IsZero() && shunt_dy[5].IsZero())) ? current_dy[5] : current_dy[5] + ~(power_dy[5]/voltageC) + voltageC*shunt_dy[5];\n\t\t\t\t\n\t\t\t//Accumulate in to final portion\n\t\t\tcurrent_inj[0] += dy_curr_accum[0];\n\t\t\tcurrent_inj[1] += dy_curr_accum[1];\n\t\t\tcurrent_inj[2] += dy_curr_accum[2];\n\n\t\t\t//Do \"non-triplex\" houses in here too, since they're explicit\n\t\t\tif (house_present)\n\t\t\t{\n\t\t\t\t//Do in a loop, just becaus\n\t\t\t\tfor (loop_index_val=0; loop_index_val<3; loop_index_val++)\n\t\t\t\t{\n\t\t\t\t\t//See if it is even a valid voltage first\n\t\t\t\t\tif (voltage[loop_index_val].Mag() != 0.0)\n\t\t\t\t\t{\n\t\t\t\t\t\t//Get the phase rotation\n\t\t\t\t\t\ttemp_curr_rotate_value.SetPolar(1.0,voltage[loop_index_val].Arg());\n\n\t\t\t\t\t\t//Update the values\n\t\t\t\t\t\ttemp_curr_calc_value = nom_res_curr[loop_index_val]/(~temp_curr_rotate_value);\t//Just denominator conjugated to keep math right (rest was conjugated in house)\n\n\t\t\t\t\t\t//Accumulate it, because we like extra steps\n\t\t\t\t\t\tcurrent_inj[loop_index_val] += temp_curr_calc_value;\n\t\t\t\t\t}\n\t\t\t\t\t//Default else - wasn't valid, so don't accumulate anything\n\t\t\t\t}//End phase loop\n\t\t\t}//End not-so-triplex house\n\t\t}//End delta/wye explicit\n\n#ifdef SUPPORT_OUTAGES\n\tif (is_open_any())\n\t\tthrow \"unable to handle node open phase condition\";\n\n\tif (is_contact_any())\n\t{\n\t\t/* phase-phase contact */\n\t\tif (is_contact(PHASE_A|PHASE_B|PHASE_C))\n\t\t\tvoltageA = voltageB = voltageC = (voltageA + voltageB + voltageC)/3;\n\t\telse if (is_contact(PHASE_A|PHASE_B))\n\t\t\tvoltageA = voltageB = (voltageA + voltageB)/2;\n\t\telse if (is_contact(PHASE_B|PHASE_C))\n\t\t\tvoltageB = voltageC = (voltageB + voltageC)/2;\n\t\telse if (is_contact(PHASE_A|PHASE_C))\n\t\t\tvoltageA = voltageC = (voltageA + voltageC)/2;\n\n\t\t/* phase-neutral/ground contact */\n\t\tif (is_contact(PHASE_A|PHASE_N) || is_contact(PHASE_A|GROUND))\n\t\t\tvoltageA /= 2;\n\t\tif (is_contact(PHASE_B|PHASE_N) || is_contact(PHASE_B|GROUND))\n\t\t\tvoltageB /= 2;\n\t\tif (is_contact(PHASE_C|PHASE_N) || is_contact(PHASE_C|GROUND))\n\t\t\tvoltageC /= 2;\n\t}\n#endif\n\n\t\t// if the parent object is another node\n\t\tif (obj->parent!=NULL && gl_object_isa(obj->parent,\"node\",\"powerflow\"))\n\t\t{\n\t\t\tnode *pNode = OBJECTDATA(obj->parent,node);\n\n\t\t\t//Check to make sure phases are correct - ignore Deltas and neutrals (load changes take care of those)\n\t\t\tif (((pNode->phases & phases) & (!(PHASE_D | PHASE_N))) == (phases & (!(PHASE_D | PHASE_N))))\n\t\t\t{\n\t\t\t\t// add the injections on this node to the parent\n\t\t\t\tWRITELOCK_OBJECT(obj->parent);\n\t\t\t\tpNode->current_inj[0] += current_inj[0];\n\t\t\t\tpNode->current_inj[1] += current_inj[1];\n\t\t\t\tpNode->current_inj[2] += current_inj[2];\n\t\t\t\tWRITEUNLOCK_OBJECT(obj->parent);\n\t\t\t}\n\t\t\telse\n\t\t\t\tGL_THROW(\"Node:%d's parent does not have the proper phase connection to be a parent.\",obj->id);\n\t\t\t\t/*  TROUBLESHOOT\n\t\t\t\tA parent-child relationship was attempted when the parent node does not contain the phases\n\t\t\t\tof the child node.  Ensure parent nodes have at least the phases of the child object.\n\t\t\t\t*/\n\t\t}\n\n\t\tbreak;\n\t\t}\n\tcase SM_NR:\n\t\t{\n\t\t\t//Call NR sync function items\n\t\t\tNR_node_sync_fxn(obj);\n\n\t\t\tif ((NR_curr_bus==NR_bus_count) && (obj==NR_swing_bus))\t//Only run the solver once everything has populated\n\t\t\t{\n\t\t\t\tbool bad_computation=false;\n\t\t\t\tNRSOLVERMODE powerflow_type;\n\t\t\t\t\n\t\t\t\t//See if we're the special fault_check mode\n\t\t\t\tif (fault_check_override_mode == true)\n\t\t\t\t{\n\t\t\t\t\t//Just return a reiteration time -- fault_check will terminate the simulation\n\t\t\t\t\treturn t0;\n\t\t\t\t}\n\n\t\t\t\t//Depending on operation mode, call solver appropriately\n\t\t\t\tif (deltamode_inclusive)\t//Dynamics mode, solve the static in a way that generators are handled right\n\t\t\t\t{\n\t\t\t\t\tif (NR_dyn_first_run==true)\t//If it is the first run, perform the initialization powerflow\n\t\t\t\t\t{\n\t\t\t\t\t\tpowerflow_type = PF_DYNINIT;\n\t\t\t\t\t\tNR_dyn_first_run = false;\t//Deflag us for future powerflow solutions\n\t\t\t\t\t}\n\t\t\t\t\telse\t//After first run - call the \"dynamic\" version of the powerflow solver (SWING bus different)\n\t\t\t\t\t{\n\t\t\t\t\t\tpowerflow_type = PF_DYNCALC;\n\t\t\t\t\t}\n\t\t\t\t}//End deltamode\n\t\t\t\telse\t//Normal mode\n\t\t\t\t{\n\t\t\t\t\tpowerflow_type = PF_NORMAL;\n\t\t\t\t}\n\n\t\t\t\tint64 result = solver_nr(NR_bus_count, NR_busdata, NR_branch_count, NR_branchdata, &NR_powerflow, powerflow_type, NULL, &bad_computation);\n\n\t\t\t\t//De-flag the change - no contention should occur\n\t\t\t\tNR_admit_change = false;\n\n\t\t\t\tif (bad_computation==true)\n\t\t\t\t{\n\t\t\t\t\tGL_THROW(\"Newton-Raphson method is unable to converge to a solution at this operation point\");\n\t\t\t\t\t/*  TROUBLESHOOT\n\t\t\t\t\tNewton-Raphson has failed to complete even a single iteration on the powerflow.  This is an indication\n\t\t\t\t\tthat the method will not solve the system and may have a singularity or other ill-favored condition in the\n\t\t\t\t\tsystem matrices.\n\t\t\t\t\t*/\n\t\t\t\t}\n\t\t\t\telse if (result<0)\t//Failure to converge, but we just let it stay where we are for now\n\t\t\t\t{\n\t\t\t\t\tgl_verbose(\"Newton-Raphson failed to converge, sticking at same iteration.\");\n\t\t\t\t\t/*  TROUBLESHOOT\n\t\t\t\t\tNewton-Raphson failed to converge in the number of iterations specified in NR_iteration_limit.\n\t\t\t\t\tIt will try again (if the global iteration limit has not been reached).\n\t\t\t\t\t*/\n\t\t\t\t\tNR_retval=t0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tNR_retval=t1;\n\n\t\t\t\t//See where we wanted to go\n\t\t\t\treturn NR_retval;\n\t\t\t}\n\t\t\telse if (NR_curr_bus==NR_bus_count)\t//Population complete, we're not swing, let us go (or we never go on)\n\t\t\t\treturn t1;\n\t\t\telse\t//Population of data busses is not complete.  Flag us for a go-around, they should be ready next time\n\t\t\t{\n\t\t\t\tif (obj == NR_swing_bus)\t//Only error on MASTER swing - if errors with others, seems to be upset.  Too lazy to track down why.\n\t\t\t\t{\n\t\t\t\t\tGL_THROW(\"All nodes were not properly populated\");\n\t\t\t\t\t/*  TROUBLESHOOT\n\t\t\t\t\tThe NR solver is still waiting to initialize an object on the second pass.  Everything should have\n\t\t\t\t\tinitialized on the first pass.  Look for orphaned node objects that do not have a line attached and\n\t\t\t\t\ttry again.  If the error persists, please submit your code and a bug report via the trac website.\n\t\t\t\t\t*/\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t//See if we're a disconnected node\n\t\t\t\t\tif (NR_node_reference == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\t//Output an error (but don't fail) - SWING bus will cause the explicit failure\n\t\t\t\t\t\tgl_error(\"Unconnected node - %s id:%d\",obj->name?obj->name:\"Unknown\",obj->id);\n\t\t\t\t\t\t/*  TROUBLESHOOT\n\t\t\t\t\t\tWhile parsing a GLM, the Newton-Raphson powerflow solver encountered a node\n\t\t\t\t\t\tthat does not appear to be connected anywhere.  This will cause problems with the\n\t\t\t\t\t\tsolver.  Please verify that this node is supposed to be islanded.\n\t\t\t\t\t\t*/\n\t\t\t\t\t}\n\n\t\t\t\t\treturn t0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\tdefault:\n\t\tGL_THROW(\"unsupported solver method\");\n\t\t/*\tTROUBLESHOOT\n\t\tAn invalid powerflow solver was specified.  Currently acceptable values are FBS for forward-back\n\t\tsweep (Kersting's method) and NR for Newton-Raphson.\n\t\t*/\n\t\tbreak;\n\t}\n\treturn t1;\n}\n\n//Functionalized postsync pass routines for NR solver and generic items\n//Put in place so deltamode can call it and properly udpate\nvoid node::BOTH_node_postsync_fxn(OBJECT *obj)\n{\n\tdouble curr_delta_time;\n\tcomplex_array temp_complex_array;\n\tint index_x_val, index_y_val;\n\tgld_property *temp_property;\n\tgld_wlock *test_rlock;\n\n\t//See if we're a generator-attached bus (needs full_Y_all) - if so, update it\n\tif ((deltamode_inclusive == true) && (dynamic_norton==true))\n\t{\n\t\t//See if we're a child or a parent\n\t\tif ((SubNode==CHILD) || (SubNode==DIFF_CHILD))\n\t\t{\n\t\t\t//Map to our parent\n\t\t\ttemp_property = new gld_property(SubNodeParent,\"deltamode_full_Y_all_matrix\");\n\n\t\t\t//Make sure it worked\n\t\t\tif ((temp_property->is_valid() != true) || (temp_property->is_complex_array() != true))\n\t\t\t{\n\t\t\t\tGL_THROW(\"Node:%d - %s - Failed to map deltamode matrix to parent\",obj->id,(obj->name ? obj->name : \"Unnamed\"));\n\t\t\t\t/*  TROUBLESHOOT\n\t\t\t\tWhile attempting to map to a parent's deltamode-related matrix, a node device encountered an issue.  Please try again.\n\t\t\t\tIf the error persists, please submit a ticket with your code/model to the issue tracker.\n\t\t\t\t*/\n\t\t\t}\n\n\t\t\t//Pull down the value\n\t\t\ttemp_property->getp<complex_array>(temp_complex_array,*test_rlock);\n\n\t\t\t//See if it is the right size\n\t\t\tif ((temp_complex_array.get_rows() == 3) && (temp_complex_array.get_cols() == 3))\n\t\t\t{\n\t\t\t\t//Store it directly into ours\n\t\t\t\tfull_Y_all_matrix = temp_complex_array;\n\t\t\t}\n\t\t\t//Default else - wrong size, just ignore it\n\n\t\t\t//Delete the link\n\t\t\tdelete temp_property;\n\t\t}\n\t\telse\t//Parent or stand-alone\n\t\t{\n\t\t\t//Make sure we're valid and a right size\n\t\t\tif (full_Y_all_matrix.is_valid(0,0) == true)\n\t\t\t{\n\t\t\t\t//Make sure it is the right size\n\t\t\t\tif ((full_Y_all_matrix.get_rows() != 3) || (full_Y_matrix.get_cols() != 3))\n\t\t\t\t{\n\t\t\t\t\t//Try forcing to be 3x3\n\t\t\t\t\tfull_Y_all_matrix.grow_to(3,3);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\t//Not allocated yet -- allocate it\n\t\t\t{\n\t\t\t\tfull_Y_all_matrix.grow_to(3,3);\n\t\t\t}\n\n\t\t\t//Make sure it valid, just for giggles\n\t\t\tif (full_Y_all != NULL)\n\t\t\t{\n\t\t\t\t//Copy our values in\n\t\t\t\tfor (index_x_val=0; index_x_val<3; index_x_val++)\n\t\t\t\t{\n\t\t\t\t\tfor (index_y_val=0; index_y_val<3; index_y_val++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfull_Y_all_matrix.set_at(index_x_val,index_y_val,full_Y_all[index_x_val*3+index_y_val]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\t//If we got here, yell\n\t\t\t{\n\t\t\t\tGL_THROW(\"Node:%d - %s - Node tried to update a deltamode matrix that does not exist!\",obj->id,(obj->name ? obj->name : \"Unnamed\"));\n\t\t\t\t/*  TROUBLESHOOT\n\t\t\t\tWhile attempting to update an exposed deltamode matrix, the underlying data was found to not exist!  Please submit your code\n\t\t\t\tand a bug report via the issue tracker system.\n\t\t\t\t*/\n\t\t\t}\n\t\t}//End parent update\n\t}\n\t//Default else -- not needing this to be updated\n\n\t//Update tracking variables for nodes/loads/meters\n\tif ((deltatimestep_running > 0) && (enable_inrush_calculations == true))\n\t{\n\t\t//Get current deltamode timestep\n\t\tcurr_delta_time = gl_globaldeltaclock;\n\n\t\t//Check and see if we're in a different timestep -- if so, zero the accumulators\n\t\tif (curr_delta_time != prev_delta_time)\n\t\t{\n\t\t\t//Update the tracker\n\t\t\tprev_delta_time = curr_delta_time;\n\t\t}\n\t}//End deltamode and in-rush\n\t//Default else -- no in-rush and no deltamode\n\n\t/* check for voltage control requirement */\n\tif (require_voltage_control==TRUE)\n\t{\n\t\t/* PQ bus must have a source */\n\t\tif ((busflags&NF_HASSOURCE)==0 && bustype==PQ)\n\t\t\tvoltage[0] = voltage[1] = voltage[2] = complex(0,0);\n\t}\n\n\t//Update appropriate \"other\" voltages\n\tif (has_phase(PHASE_S))\n\t{\t// split-tap voltage diffs are different\n\t\tvoltaged[0] = voltage[0] + voltage[1];\t//V12\n\t\tvoltaged[1] = voltage[1] - voltage[2];\t//V2N\n\t\tvoltaged[2] = voltage[0] - voltage[2];\t//V1N -- not sure why these are backwards\n\t}\n\telse\n\t{\t// compute 3phase voltage differences\n\t\tvoltaged[0] = voltage[0] - voltage[1];\t//AB\n\t\tvoltaged[1] = voltage[1] - voltage[2];\t//BC\n\t\tvoltaged[2] = voltage[2] - voltage[0];\t//CA\n\t}\n\t\n\t//This code performs the new \"flattened\" NR calculations.\n\tif (solver_method == SM_NR)\n\t{\n\t\tint result = NR_current_update(false);\n\n\t\t//Make sure it worked, just to be thorough\n\t\tif (result != 1)\n\t\t{\n\t\t\tGL_THROW(\"Attempt to update current/power on node:%s failed!\",obj->name);\n\t\t\t//Defined elsewhere\n\t\t}\n\t}\n}\n\nTIMESTAMP node::postsync(TIMESTAMP t0)\n{\n\tTIMESTAMP t1 = powerflow_object::postsync(t0);\n\tTIMESTAMP RetValue=t1;\n\tOBJECT *obj = OBJECTHDR(this);\n\n#ifdef SUPPORT_OUTAGES\n\tif (condition!=OC_NORMAL)\t//Zero all the voltages, just in case\n\t{\n\t\tvoltage[0] = voltage[1] = voltage[2] = 0.0;\n\t}\n\n\tif (is_contact_any())\n\t{\n\t\tcomplex dVAB = voltageA - voltageB;\n\t\tcomplex dVBC = voltageB - voltageC;\n\t\tcomplex dVCA = voltageC - voltageA;\n\n\t\t/* phase-phase contact */\n\t\t//WRITELOCK_OBJECT(obj);\n\t\tif (is_contact(PHASE_A|PHASE_B|PHASE_C))\n\t\t\t/** @todo calculate three-way contact fault current */\n\t\t\tthrow \"three-way contact not supported yet\";\n\t\telse if (is_contact(PHASE_A|PHASE_B))\n\t\t\tcurrent_inj[0] = - current_inj[1] = dVAB/fault_Z;\n\t\telse if (is_contact(PHASE_B|PHASE_C))\n\t\t\tcurrent_inj[1] = - current_inj[2] = dVBC/fault_Z;\n\t\telse if (is_contact(PHASE_A|PHASE_C))\n\t\t\tcurrent_inj[2] = - current_inj[0] = dVCA/fault_Z;\n\n\t\t/* phase-neutral/ground contact */\n\t\tif (is_contact(PHASE_A|PHASE_N) || is_contact(PHASE_A|GROUND))\n\t\t\tcurrent_inj[0] = voltageA / fault_Z;\n\t\tif (is_contact(PHASE_B|PHASE_N) || is_contact(PHASE_B|GROUND))\n\t\t\tcurrent_inj[1] = voltageB / fault_Z;\n\t\tif (is_contact(PHASE_C|PHASE_N) || is_contact(PHASE_C|GROUND))\n\t\t\tcurrent_inj[2] = voltageC / fault_Z;\n\t\t//UNLOCK_OBJECT(obj);\n\t}\n\n\t/* record the power in for posterity */\n\t//kva_in = (voltageA*~current[0] + voltageB*~current[1] + voltageC*~current[2])/1000; /*...or not.  Note sure how this works for a node*/\n\n#endif\n\t//Call NR-related and some \"common\" node postsync routines\n\tBOTH_node_postsync_fxn(obj);\n\n\tif (solver_method==SM_FBS)\n\t{\n\t\t// if the parent object is a node\n\t\tif (obj->parent!=NULL && (gl_object_isa(obj->parent,\"node\",\"powerflow\")))\n\t\t{\n\t\t\t// copy the voltage from the parent - check for mismatch handled earlier\n\t\t\tnode *pNode = OBJECTDATA(obj->parent,node);\n\t\t\tvoltage[0] = pNode->voltage[0];\n\t\t\tvoltage[1] = pNode->voltage[1];\n\t\t\tvoltage[2] = pNode->voltage[2];\n\n\t\t\t//Re-update our Delta or single-phase equivalents since we now have a new voltage\n\t\t\t//Update appropriate \"other\" voltages\n\t\t\tif (phases&PHASE_S) \n\t\t\t{\t// split-tap voltage diffs are different\n\t\t\t\tvoltage12 = voltage1 + voltage2;\n\t\t\t\tvoltage1N = voltage1 - voltageN;\n\t\t\t\tvoltage2N = voltage2 - voltageN;\n\t\t\t}\n\t\t\telse\n\t\t\t{\t// compute 3phase voltage differences\n\t\t\t\tvoltageAB = voltageA - voltageB;\n\t\t\t\tvoltageBC = voltageB - voltageC;\n\t\t\t\tvoltageCA = voltageC - voltageA;\n\t\t\t}\n\t\t}\n\t}\n\n#ifdef SUPPORT_OUTAGES\n\t/* check the voltage status for loads */\n\tif (phases&PHASE_S) // split-phase node\n\t{\n\t\tdouble V1pu = voltage1.Mag()/nominal_voltage;\n\t\tdouble V2pu = voltage2.Mag()/nominal_voltage;\n\t\tif (V1pu<0.8 || V2pu<0.8)\n\t\t\tstatus=UNDERVOLT;\n\t\telse if (V1pu>1.2 || V2pu>1.2)\n\t\t\tstatus=OVERVOLT;\n\t\telse\n\t\t\tstatus=NOMINAL;\n\t}\n\telse // three-phase node\n\t{\n\t\tdouble VApu = voltageA.Mag()/nominal_voltage;\n\t\tdouble VBpu = voltageB.Mag()/nominal_voltage;\n\t\tdouble VCpu = voltageC.Mag()/nominal_voltage;\n\t\tif (VApu<0.8 || VBpu<0.8 || VCpu<0.8)\n\t\t\tstatus=UNDERVOLT;\n\t\telse if (VApu>1.2 || VBpu>1.2 || VCpu>1.2)\n\t\t\tstatus=OVERVOLT;\n\t\telse\n\t\t\tstatus=NOMINAL;\n\t}\n#endif\n\tif (solver_method==SM_FBS)\n\t{\n\t\t/* compute the sync voltage change */\n\t\tdouble sync_V = (last_voltage[0]-voltage[0]).Mag() + (last_voltage[1]-voltage[1]).Mag() + (last_voltage[2]-voltage[2]).Mag();\n\t\t\n\t\t/* if the sync voltage limit is defined and the sync voltage is larger */\n\t\tif (sync_V > maximum_voltage_error){\n\n\t\t\t/* request another pass */\n\t\t\tRetValue=t0;\n\t\t}\n\t}\n\n\t/* the solution is satisfactory */\n\treturn RetValue;\n}\n\nint node::kmlinit(int (*stream)(const char*,...))\n{\n\tgld_global host(\"hostname\");\n\tgld_global port(\"server_portnum\");\n#define STYLE(X) stream(\"<Style id=\\\"\" #X \"_g\\\"><IconStyle><Icon><href>http://%s:%u/rt/\" #X \"_g.png</href></Icon></IconStyle></Style>\\n\", (const char*)host.get_string(), port.get_int32());\\\n\t\tstream(\"<Style id=\\\"\" #X \"_r\\\"><IconStyle><Icon><href>http://%s:%u/rt/\" #X \"_r.png</href></Icon></IconStyle></Style>\\n\", (const char*)host.get_string(), port.get_int32());\\\n\t\tstream(\"<Style id=\\\"\" #X \"_b\\\"><IconStyle><Icon><href>http://%s:%u/rt/\" #X \"_b.png</href></Icon></IconStyle></Style>\\n\", (const char*)host.get_string(), port.get_int32());\\\n\t\tstream(\"<Style id=\\\"\" #X \"_k\\\"><IconStyle><Icon><href>http://%s:%u/rt/\" #X \"_k.png</href></Icon></IconStyle></Style>\\n\", (const char*)host.get_string(), port.get_int32());\n\tSTYLE(node);\n\tSTYLE(capacitor);\n\tSTYLE(load);\n\tSTYLE(triplex_meter);\n\n\treturn 0;\n}\nint node::kmldump(int (*stream)(const char*,...))\n{\n\tOBJECT *obj = OBJECTHDR(this);\n\tFUNCTIONADDR temp_funadd = NULL;\n\n\tif (isnan(get_latitude()) || isnan(get_longitude()))\n\t\treturn 0;\n\tstream(\"<Placemark>\\n\");\n\tstream(\"<name>%s</name>\\n\", get_name() );\n\tstream(\"<description>\\n\");\n\tstream(\"<![CDATA[\\n\");\n\tstream(\"<TABLE>\\n\");\n\n\tchar status_code[]=\"kbgr\";\n\tint status = 2; // green\n\tif ( gl_object_isa(my(),\"triplex_meter\") )\n\t{\n\t\t//Map to the function\n\t\ttemp_funadd = (FUNCTIONADDR)(gl_get_function(obj,\"pwr_object_kmldata\"));\n\n\t\t//See if it was located\n\t\tif (temp_funadd == NULL)\n\t\t{\n\t\t\tGL_THROW(\"object:%s - failed to map kmldata function\",(obj->name?obj->name:\"unnamed\"));\n\t\t\t/*  TROUBLESHOOT\n\t\t\tWhile attempting to map the kmldata function, an error was encountered.\n\t\t\tPlease try again.  If the error persists, please submit your code and a bug report via the trac website.\n\t\t\t*/\n\t\t}\n\n\t\t//Call the function\n\t\t// TODO use triplex_node to get to triplex_meter\n\t\tstatus = ((int (*)(OBJECT *,int (*stream)(const char*,...)))(*temp_funadd))(obj,stream);\n\t}\n\telse\n\t{\n\t\tstream(\"<CAPTION>%s #%d</CAPTION>\\n<TR><TH WIDTH=\\\"25%\\\" ALIGN=CENTER>Property<HR></TH>\"\n\t\t\t\t\"<TH WIDTH=\\\"25%\\\" COLSPAN=2 ALIGN=CENTER><NOBR>Phase A</NOBR><HR></TH>\"\n\t\t\t\t\"<TH WIDTH=\\\"25%\\\" COLSPAN=2 ALIGN=CENTER><NOBR>Phase B</NOBR><HR></TH>\"\n\t\t\t\t\"<TH WIDTH=\\\"25%\\\" COLSPAN=2 ALIGN=CENTER><NOBR>Phase C</NOBR><HR></TH></TR>\\n\", get_oclass()->get_name(), get_id());\n\n\t\tint phase[3] = {has_phase(PHASE_A),has_phase(PHASE_B),has_phase(PHASE_C)};\n\t\tdouble basis[3] = {0,240,120};\n\n\t\t// voltages\n\t\tstream(\"<TR><TH ALIGN=LEFT>Voltage</TH>\");\n\t\tfor ( int i = 0 ; i<sizeof(phase)/sizeof(phase[0]) ; i++ )\n\t\t{\n\t\t\tif ( phase[i] )\n\t\t\t{\n\t\t\t\tstream(\"<TD ALIGN=RIGHT STYLE=\\\"font-family:courier;\\\"><NOBR>%.3f</NOBR></TD><TD ALIGN=LEFT>kV</TD>\", voltage[i].Mag()/1000);\n\t\t\t\tif ( status>0 && voltage[i].Mag() <= 0.5*nominal_voltage ) status = 0; // black\n\t\t\t\telse if ( status==2 && voltage[i].Mag() < 0.95*nominal_voltage ) status = 1; // blue\n\t\t\t\telse if ( status==2 && voltage[i].Mag() > 1.05*nominal_voltage ) status = 3; // red\n\t\t\t}\n\t\t\telse\n\t\t\t\tstream(\"<TD ALIGN=RIGHT STYLE=\\\"font-family:courier;\\\">&mdash;</TD><TD>&nbsp;</TD>\");\n\t\t}\n\t\tstream(\"</TR>\\n\");\n\t\tstream(\"<TR><TH ALIGN=LEFT>&nbsp</TH>\");\n\t\tfor ( int i = 0 ; i<sizeof(phase)/sizeof(phase[0]) ; i++ )\n\t\t{\n\t\t\tif ( phase[i] )\n\t\t\t\tstream(\"<TD ALIGN=RIGHT STYLE=\\\"font-family:courier;\\\"><NOBR>%.3f</NOBR></TD><TD ALIGN=LEFT>&deg;</TD>\", voltage[i].Arg()*180/3.1416 - basis[i]);\n\t\t\telse\n\t\t\t\tstream(\"<TD ALIGN=RIGHT STYLE=\\\"font-family:courier;\\\">&mdash;</TD><TD>&nbsp;</TD>\");\n\t\t}\n\t\tstream(\"</TR>\\n\");\n\n\t\t//Check others - de-\"macrotized\" so it can do things indirectly\n\t\tif ((gl_object_isa(my(),\"load\",\"powerflow\") == true) || (gl_object_isa(my(),\"capacitor\",\"powerflow\") == true))\n\t\t{\n\t\t\t//Map to the function\n\t\t\ttemp_funadd = (FUNCTIONADDR)(gl_get_function(obj,\"pwr_object_kmldata\"));\n\n\t\t\t//See if it was located\n\t\t\tif (temp_funadd == NULL)\n\t\t\t{\n\t\t\t\tGL_THROW(\"object:%s - failed to map kmldata function\",(obj->name?obj->name:\"unnamed\"));\n\t\t\t\t//Defined above\n\t\t\t}\n\n\t\t\t//Call the function\n\t\t\t// TODO use triplex_node to get to triplex_meter\n\t\t\tstatus = ((int (*)(OBJECT *,int (*stream)(const char*,...)))(*temp_funadd))(obj,stream);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// power\n\t\t\tstream(\"<TR><TH ALIGN=LEFT>Power</TH>\");\n\t\t\tfor ( int i = 0 ; i<sizeof(phase)/sizeof(phase[0]) ; i++ )\n\t\t\t{\n\t\t\t\tif ( phase[i] )\n\t\t\t\t\tstream(\"<TD ALIGN=RIGHT STYLE=\\\"font-family:courier;\\\"><NOBR>%.3f</NOBR></TD><TD ALIGN=LEFT>kW</TD>\", power[i].Re()/1000);\n\t\t\t\telse\n\t\t\t\t\tstream(\"<TD ALIGN=RIGHT STYLE=\\\"font-family:courier;\\\">&mdash;</TD><TD>&nbsp;</TD>\");\n\t\t\t}\n\t\t\tstream(\"</TR>\\n\");\n\t\t\tstream(\"<TR><TH ALIGN=LEFT>&nbsp</TH>\");\n\t\t\tfor ( int i = 0 ; i<sizeof(phase)/sizeof(phase[0]) ; i++ )\n\t\t\t{\n\t\t\t\tif ( phase[i] )\n\t\t\t\t\tstream(\"<TD ALIGN=RIGHT STYLE=\\\"font-family:courier;\\\"><NOBR>%.3f</NOBR></TD><TD ALIGN=LEFT>kVAR</TD>\", power[i].Im()/1000);\n\t\t\t\telse\n\t\t\t\t\tstream(\"<TD ALIGN=RIGHT STYLE=\\\"font-family:courier;\\\">&mdash;</TD><TD>&nbsp;</TD>\");\n\t\t\t}\n\t\t\tstream(\"</TR>\\n\");\n\t\t}\n\t}\n\tstream(\"</TABLE>\\n\");\n\tstream(\"]]>\\n\");\n\tstream(\"</description>\\n\");\n\tstream(\"<styleUrl>#%s_%c</styleUrl>\\n\",obj->oclass->name, status_code[status]);\n\tstream(\"<Point>\\n\");\n\tstream(\"<coordinates>%f,%f</coordinates>\\n\",get_longitude(),get_latitude());\n\tstream(\"</Point>\\n\");\n\tstream(\"</Placemark>\\n\");\n\treturn 0;\n}\n\n//Notify function\n//NOTE: The NR-based notify stuff may no longer be needed after NR is \"flattened\", since it will\n//      effectively be like FBS at that point.\nint node::notify(int update_mode, PROPERTY *prop, char *value)\n{\n\tcomplex diff_val;\n\n\tif (solver_method == SM_NR)\n\t{\n\t\t//Only even bother with voltage updates if we're properly populated\n\t\tif (prev_voltage_value != NULL)\n\t\t{\n\t\t\t//See if there is a voltage update - phase A\n\t\t\tif (strcmp(prop->name,\"voltage_A\")==0)\n\t\t\t{\n\t\t\t\tif (update_mode==NM_PREUPDATE)\n\t\t\t\t{\n\t\t\t\t\t//Store the last value\n\t\t\t\t\tprev_voltage_value[0] = voltage[0];\n\t\t\t\t}\n\t\t\t\telse if (update_mode==NM_POSTUPDATE)\n\t\t\t\t{\n\t\t\t\t\t//Handle the logics\n\t\t\t\t\t//See what the difference is - if it is above the convergence limit, send an NR update\n\t\t\t\t\tdiff_val = voltage[0] - prev_voltage_value[0];\n\n\t\t\t\t\tif (diff_val.Mag() >= maximum_voltage_error)\t//Outside of range, so force a new iteration\n\t\t\t\t\t{\n\t\t\t\t\t\tNR_retval = gl_globalclock;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//See if there is a voltage update - phase B\n\t\t\tif (strcmp(prop->name,\"voltage_B\")==0)\n\t\t\t{\n\t\t\t\tif (update_mode==NM_PREUPDATE)\n\t\t\t\t{\n\t\t\t\t\t//Store the last value\n\t\t\t\t\tprev_voltage_value[1] = voltage[1];\n\t\t\t\t}\n\t\t\t\telse if (update_mode==NM_POSTUPDATE)\n\t\t\t\t{\n\t\t\t\t\t//Handle the logics\n\t\t\t\t\t//See what the difference is - if it is above the convergence limit, send an NR update\n\t\t\t\t\tdiff_val = voltage[1] - prev_voltage_value[1];\n\n\t\t\t\t\tif (diff_val.Mag() >= maximum_voltage_error)\t//Outside of range, so force a new iteration\n\t\t\t\t\t{\n\t\t\t\t\t\tNR_retval = gl_globalclock;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//See if there is a voltage update - phase C\n\t\t\tif (strcmp(prop->name,\"voltage_C\")==0)\n\t\t\t{\n\t\t\t\tif (update_mode==NM_PREUPDATE)\n\t\t\t\t{\n\t\t\t\t\t//Store the last value\n\t\t\t\t\tprev_voltage_value[2] = voltage[2];\n\t\t\t\t}\n\t\t\t\telse if (update_mode==NM_POSTUPDATE)\n\t\t\t\t{\n\t\t\t\t\t//Handle the logics\n\t\t\t\t\t//See what the difference is - if it is above the convergence limit, send an NR update\n\t\t\t\t\tdiff_val = voltage[2] - prev_voltage_value[2];\n\n\t\t\t\t\tif (diff_val.Mag() >= maximum_voltage_error)\t//Outside of range, so force a new iteration\n\t\t\t\t\t{\n\t\t\t\t\t\tNR_retval = gl_globalclock;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}//End NR\n\t//Default else - FBS's iteration methods aren't sensitive to this\n\n\treturn 1;\n}\n\n//////////////////////////////////////////////////////////////////////////\n// IMPLEMENTATION OF CORE LINKAGE: node\n//////////////////////////////////////////////////////////////////////////\n\n/**\n* REQUIRED: allocate and initialize an object.\n*\n* @param obj a pointer to a pointer of the last object in the list\n* @param parent a pointer to the parent of this object\n* @return 1 for a successfully created object, 0 for error\n*/\nEXPORT int create_node(OBJECT **obj, OBJECT *parent)\n{\n\ttry\n\t{\n\t\t*obj = gl_create_object(node::oclass);\n\t\tif (*obj!=NULL)\n\t\t{\n\t\t\tnode *my = OBJECTDATA(*obj,node);\n\t\t\tgl_set_parent(*obj,parent);\n\t\t\treturn my->create();\n\t\t}\n\t\telse\n\t\t\treturn 0;\n\t}\n\tCREATE_CATCHALL(node);\n}\n\n// Commit function\nEXPORT TIMESTAMP commit_node(OBJECT *obj, TIMESTAMP t1, TIMESTAMP t2)\n{\n\tnode *pNode = OBJECTDATA(obj,node);\n\ttry {\n\t\t// This zeroes out all of the unused phases at each node in the FBS method\n\t\tif (solver_method==SM_FBS)\n\t\t{\n\t\t\tif (pNode->has_phase(PHASE_A)) {\n\t\t\t//leave it\n\t\t\t}\n\t\t\telse\n\t\t\t\tpNode->voltage[0] = complex(0,0);\n\n\t\t\tif (pNode->has_phase(PHASE_B)) {\n\t\t\t\t//leave it\n\t\t\t}\n\t\t\telse\n\t\t\t\tpNode->voltage[1] = complex(0,0);\n\n\t\t\tif (pNode->has_phase(PHASE_C)) {\n\t\t\t\t//leave it\n\t\t\t}\n\t\t\telse\n\t\t\t\tpNode->voltage[2] = complex(0,0);\n\t\t\t\n\t\t}\n\t\treturn TS_NEVER;\n\t}\n\tcatch (char *msg)\n\t{\n\t\tgl_error(\"%s (node:%d): %s\", pNode->get_name(), pNode->get_id(), msg);\n\t\treturn 0; \n\t}\n\n}\n\n/**\n* Object initialization is called once after all object have been created\n*\n* @param obj a pointer to this object\n* @return 1 on success, 0 on error\n*/\nEXPORT int init_node(OBJECT *obj)\n{\n\ttry {\n\t\tnode *my = OBJECTDATA(obj,node);\n\t\treturn my->init(obj->parent);\n\t}\n\tINIT_CATCHALL(node);\n}\n\n/**\n* Sync is called when the clock needs to advance on the bottom-up pass (PC_BOTTOMUP)\n*\n* @param obj the object we are sync'ing\n* @param t0 this objects current timestamp\n* @param pass the current pass for this sync call\n* @return t1, where t1>t0 on success, t1=t0 for retry, t1<t0 on failure\n*/\nEXPORT TIMESTAMP sync_node(OBJECT *obj, TIMESTAMP t0, PASSCONFIG pass)\n{\n\ttry {\n\t\tnode *pObj = OBJECTDATA(obj,node);\n\t\tTIMESTAMP t1 = TS_NEVER;\n\t\tswitch (pass) {\n\t\tcase PC_PRETOPDOWN:\n\t\t\treturn pObj->presync(t0);\n\t\tcase PC_BOTTOMUP:\n\t\t\treturn pObj->sync(t0);\n\t\tcase PC_POSTTOPDOWN:\n\t\t\tt1 = pObj->postsync(t0);\n\t\t\tobj->clock = t0;\n\t\t\treturn t1;\n\t\tdefault:\n\t\t\tthrow \"invalid pass request\";\n\t\t}\n\t}\n\tSYNC_CATCHALL(node);\n}\n\n/**\n* Function to search for a master swing node, one swing to rule them all\n* Functionalized to help compartmentalize the code\n* node_type_value is the class name\n* main_swing determines if we're looking for SWING or SWING_PQ (swing parses first)\n*/\nOBJECT *node::NR_master_swing_search(char *node_type_value,bool main_swing)\n{\n\tOBJECT *return_val = NULL;\n\tOBJECT *temp_obj = NULL;\n\tnode *list_node;\n\tFINDLIST *bus_list = gl_find_objects(FL_NEW,FT_CLASS,SAME,node_type_value,FT_END);\n\n\t//Parse the findlist\n\twhile(temp_obj=gl_find_next(bus_list,temp_obj))\n\t{\n\t\tlist_node = OBJECTDATA(temp_obj,node);\n\n\t\t//See which kind we are looking for\n\t\tif (main_swing == true)\n\t\t{\n\t\t\tif (list_node->bustype==SWING)\n\t\t\t{\n\t\t\t\treturn_val=temp_obj;\n\t\t\t\tbreak;\t//Only need to find one\n\t\t\t}\n\t\t}\n\t\telse\t//Look for secondary swings\n\t\t{\n\t\t\tif (list_node->bustype==SWING_PQ)\n\t\t\t{\n\t\t\t\treturn_val=temp_obj;\n\t\t\t\tbreak;\t//Only need to find one\n\t\t\t}\n\t\t}\n\t}\n\n\t//Free the list, before continuing\n\tgl_free(bus_list);\n\n\t//Return the pointer\n\treturn return_val;\n}\n\n/**\n* NR_populate is called by link objects during their first presync if a node is not\n* \"initialized\".  This function \"initializes\" the node into the Newton-Raphson data\n* structure NR_busdata\n*\n*/\nint node::NR_populate(void)\n{\n\t//Object header for names\n\tOBJECT *me = OBJECTHDR(this);\n\tnode *temp_par_node = NULL;\n\tgld_property *temp_bool_property;\n\tgld_wlock *test_rlock;\n\tbool temp_bool_val;\n\n\t//Lock the SWING for global operations\n\tif ( NR_swing_bus!=me ) LOCK_OBJECT(NR_swing_bus);\n\n\tNR_node_reference = NR_curr_bus;\t//Grab the current location and keep it as our own\n\tNR_curr_bus++;\t\t\t\t\t//Increment the current bus pointer for next variable\n\tif ( NR_swing_bus!=me ) UNLOCK_OBJECT(NR_swing_bus);\t//All done playing with globals, unlock the swing so others can proceed\n\n\t//Quick check to see if there problems\n\tif (NR_node_reference == -1)\n\t{\n\t\tGL_THROW(\"NR: node:%s failed to grab a unique bus index value!\",me->name);\n\t\t/*  TROUBLESHOOT\n\t\tWhile attempting to gain a unique bus id for the Newton-Raphson solver, an error\n\t\twas encountered.  This may be related to a parallelization effort.  Please try again.\n\t\tIf the error persists, please submit your code and a bug report via the trac website.\n\t\t*/\n\t}\n\n\t//Bus type\n\tNR_busdata[NR_node_reference].type = (int)bustype;\n\n\t//For all initial implementations, we're all part of the same big/happy island - island #0!\n\tNR_busdata[NR_node_reference].island_number = 0;\n\n\t//Interim check to make sure it isn't a PV bus, since those aren't supported yet - this will get removed when that functionality is put in place\n\tif (NR_busdata[NR_node_reference].type==1)\n\t{\n\t\tGL_THROW(\"NR: node:%s is a PV bus - these are not yet supported.\",(me->name?me->name:\"Unnamed\"));\n\t\t/*  TROUBLESHOOT\n\t\tThe Newton-Raphson solver implemented does not currently support the PV bus type.\n\t\t*/\n\t}\n\n\t//Populate the swing flag - it will get \"deflagged\" elsewhere\n\tif ((bustype == SWING) || (bustype == SWING_PQ))\n\t{\n\t\t//See if we're a SWING_PQ\n\t\tif (bustype == SWING_PQ)\n\t\t{\n\t\t\t//Check for fault_check\n\t\t\tif (fault_check_object == NULL)\n\t\t\t{\n\t\t\t\tgl_warning(\"node:%d - %s - Set as a SWING_PQ, but no fault_check present - will be treated as SWING\",me->id,(me->name?me->name:\"Unnamed\"));\n\t\t\t\t/*  TROUBLESHOOT\n\t\t\t\tA node is set up as a SWING_PQ, but there is no fault_check object on the system.  This will just be treated as a SWING bus for all calculations.\n\t\t\t\t*/\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//Fault check present - see if it is in the proper mode!\n\t\t\t\ttemp_bool_property = new gld_property(fault_check_object,\"grid_association\");\n\n\t\t\t\t//Make sure it worked\n\t\t\t\tif ((temp_bool_property->is_valid() != true) || (temp_bool_property->is_bool() != true))\n\t\t\t\t{\n\t\t\t\t\tGL_THROW(\"NR: node:%s failed to map fault_check object property\",(me->name?me->name:\"Unnamed\"));\n\t\t\t\t\t/*  TROUBLESHOOT\n\t\t\t\t\tWhile attempting to map a property of a fault_check object, an error was encountered.  Please try again.\n\t\t\t\t\tIf the error persists, please submit an item to the issue tracker.\n\t\t\t\t\t*/\n\t\t\t\t}\n\n\t\t\t\t//Pull the value\n\t\t\t\ttemp_bool_property->getp<bool>(temp_bool_val,*test_rlock);\n\n\t\t\t\t//Clear the property\n\t\t\t\tdelete temp_bool_property;\n\n\t\t\t\t//Compare the value\n\t\t\t\tif (temp_bool_val == false)\t//Not in grid_association mode!\n\t\t\t\t{\n\t\t\t\t\tgl_warning(\"node:%d - %s - Set as a SWING_PQ, but fault_check in wrong mode - will be treated as SWING\",me->id,(me->name?me->name:\"Unnamed\"));\n\t\t\t\t\t/*  TROUBLESHOOT\n\t\t\t\t\tA node is set up as a SWING_PQ, but the fault_check object is not set to do grid_association, so this bus will just be treated as a\n\t\t\t\t\tSWING bus for all calculations.\n\t\t\t\t\t*/\n\t\t\t\t}\n\t\t\t}\n\t\t}//End SWING PQ check\n\t\t//Must be a SWING\n\n\t\t//Flag it, regardless (unflagged elsewhere, if set right)\n\t\tNR_busdata[NR_node_reference].swing_functions_enabled = true;\n\t}\n\telse\n\t{\n\t\tNR_busdata[NR_node_reference].swing_functions_enabled = false;\n\t}\n\n\t//Default us to topological not the source (mostly used by SWING_PQ - set elsewhere)\n\tNR_busdata[NR_node_reference].swing_topology_entry = false;\n\n\t//Populate phases\n\tNR_busdata[NR_node_reference].phases = 128*has_phase(PHASE_S) + 8*has_phase(PHASE_D) + 4*has_phase(PHASE_A) + 2*has_phase(PHASE_B) + has_phase(PHASE_C);\n\n\t//Link our name in\n\tNR_busdata[NR_node_reference].name = me->name;\n\n\t//Link us in as well\n\tNR_busdata[NR_node_reference].obj = me;\n\n\t//Populate our maximum error vlaue\n\tNR_busdata[NR_node_reference].max_volt_error = maximum_voltage_error;\n\n\t//Link the busflags property\n\tNR_busdata[NR_node_reference].busflag = &busflags;\n\n\t//Populate voltage\n\tNR_busdata[NR_node_reference].V = &voltage[0];\n\t\n\t//Populate power\n\tNR_busdata[NR_node_reference].S = &power[0];\n\n\t//Populate admittance\n\tNR_busdata[NR_node_reference].Y = &shunt[0];\n\n\t//Populate current\n\tNR_busdata[NR_node_reference].I = &current[0];\n\n\t//Populate unrotated current\n\tNR_busdata[NR_node_reference].prerot_I = &pre_rotated_current[0];\n\n\t//Populate explicit power\n\tNR_busdata[NR_node_reference].S_dy = &power_dy[0];\n\n\t//Populate explicit admittance\n\tNR_busdata[NR_node_reference].Y_dy = &shunt_dy[0];\n\n\t//Populate explicit current\n\tNR_busdata[NR_node_reference].I_dy = &current_dy[0];\n\n\t//Allocate our link list\n\tNR_busdata[NR_node_reference].Link_Table = (int *)gl_malloc(NR_connected_links[0]*sizeof(int));\n\t\n\tif (NR_busdata[NR_node_reference].Link_Table == NULL)\n\t{\n\t\tGL_THROW(\"NR: Failed to allocate link table for node:%d\",me->id);\n\t\t/*  TROUBLESHOOT\n\t\tWhile attempting to allocate memory for the linking table for NR, memory failed to be\n\t\tallocated.  Make sure you have enough memory and try again.  If this problem happens a second\n\t\ttime, submit your code and a bug report using the trac website.\n\t\t*/\n\t}\n\n\t//Populate our size\n\tNR_busdata[NR_node_reference].Link_Table_Size = NR_connected_links[0];\n\n\t//See if we're a triplex\n\tif (has_phase(PHASE_S))\n\t{\n\t\tif (house_present)\t//We're a proud parent of a house!\n\t\t{\n\t\t\tNR_busdata[NR_node_reference].house_var = &nom_res_curr[0];\t//Separate storage area for nominal house currents\n\t\t\tNR_busdata[NR_node_reference].phases |= 0x40;\t\t\t\t\t//Flag that we are a house-attached node\n\t\t}\n\n\t\tNR_busdata[NR_node_reference].extra_var = &current12;\t//Stored in a separate variable and this is the easiest way for me to get it\n\t}\n\telse\t//Implies it is non-triplex\n\t{\n\t\tif (SubNode==DIFF_PARENT)\t//Differently connected load/node (only can't be S)\n\t\t{\n\t\t\tNR_busdata[NR_node_reference].extra_var = Extra_Data;\n\t\t\tNR_busdata[NR_node_reference].phases |= 0x10;\t\t\t//Special flag for a phase mismatch being present\n\t\t}\n\n\t\t//See if we have any houses of the three-phase/non-triplex variety\n\t\tif (house_present)\t//We're a proud parent of a house!\n\t\t{\n\t\t\tNR_busdata[NR_node_reference].house_var = &nom_res_curr[0];\t//Separate storage area for nominal house currents\n\t\t\tNR_busdata[NR_node_reference].phases |= 0x40;\t\t\t\t\t//Flag that we are a house-attached node\n\t\t}\n\t}\n\n\t//Per unit values - populate nominal voltage on a whim\n\tNR_busdata[NR_node_reference].volt_base = nominal_voltage;\n\tNR_busdata[NR_node_reference].mva_base = -1.0;\n\n\t//Set the matrix value to -1 to know it hasn't been set (probably not necessary)\n\tNR_busdata[NR_node_reference].Matrix_Loc = -1;\n\n\t//Populate original phases\n\tNR_busdata[NR_node_reference].origphases = NR_busdata[NR_node_reference].phases;\n\n\t//Populate our tracking variable\n\tprev_phases = NR_busdata[NR_node_reference].phases;\n\n\t//Populate dynamic mode flag address\n\tNR_busdata[NR_node_reference].dynamics_enabled = &deltamode_inclusive;\n\n\t//Check and see if we're in deltamode, and in-rush is enabled to allocation a variable\n\tif ((deltamode_inclusive==true) && (enable_inrush_calculations==true))\n\t{\n\t\t//Link up the array (prealloced now, so always exists)\n\t\tNR_busdata[NR_node_reference].BusHistTerm = BusHistTerm;\n\n\t\t//Link our load matrix -- if we're a load, it was done in init\n\t\t//If we're not a load, one of our children will do it later (and this is NULL anyways)\n\t\tNR_busdata[NR_node_reference].full_Y_load = full_Y_load;\n\t}\n\telse\t//One of these isn't true\n\t{\n\t\t//Null it, just to be safe - do with both\n\t\tNR_busdata[NR_node_reference].BusHistTerm = NULL;\n\t\tNR_busdata[NR_node_reference].full_Y_load = NULL;\n\t}\n\n\t//Always null the saturation term -- if it is needed, the link will populate it\n\tNR_busdata[NR_node_reference].BusSatTerm = NULL;\n\n\t//Null the extra function pointer -- the individual object will call to populate this\n\tNR_busdata[NR_node_reference].ExtraCurrentInjFunc = NULL;\n\tNR_busdata[NR_node_reference].ExtraCurrentInjFuncObject = NULL;\n\n\t//Allocate dynamic variables -- only if something has requested it\n\tif ((deltamode_inclusive==true) && ((dynamic_norton==true) || (dynamic_generator==true)))\n\t{\n\t\t//Check our status - shouldn't be necessary, but let's be paranoid\n\t\tif ((SubNode!=CHILD) && (SubNode!=DIFF_CHILD))\t//We're stand-alone or a parent\n\t\t{\n\t\t\t//Only do admittance allocation if we're a Norton\n\t\t\tif (dynamic_norton==true)\n\t\t\t{\n\t\t\t\t//Make sure no pesky children have already allocated us\n\t\t\t\tif (full_Y == NULL)\n\t\t\t\t{\n\t\t\t\t\t//Allocate it\n\t\t\t\t\tfull_Y = (complex *)gl_malloc(9*sizeof(complex));\n\n\t\t\t\t\t//Check it\n\t\t\t\t\tif (full_Y==NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tGL_THROW(\"Node:%s failed to allocate space for the a deltamode variable\",me->name);\n\t\t\t\t\t\t/*  TROUBLESHOOT\n\t\t\t\t\t\tWhile attempting to allocate memory for a dynamics-required (deltamode) variable, an error\n\t\t\t\t\t\toccurred. Please try again.  If the error persists, please submit your code and a bug\n\t\t\t\t\t\treport via the trac website.\n\t\t\t\t\t\t*/\n\t\t\t\t\t}\n\n\t\t\t\t\t//See if our published matrix has anything in it\n\t\t\t\t\tif ((full_Y_matrix.get_rows() == 3) && (full_Y_matrix.get_cols() == 3))\n\t\t\t\t\t{\n\t\t\t\t\t\tfull_Y[0] = full_Y_matrix.get_at(0,0);\n\t\t\t\t\t\tfull_Y[1] = full_Y_matrix.get_at(0,1);\n\t\t\t\t\t\tfull_Y[2] = full_Y_matrix.get_at(0,2);\n\n\t\t\t\t\t\tfull_Y[3] = full_Y_matrix.get_at(1,0);\n\t\t\t\t\t\tfull_Y[4] = full_Y_matrix.get_at(1,1);\n\t\t\t\t\t\tfull_Y[5] = full_Y_matrix.get_at(1,2);\n\n\t\t\t\t\t\tfull_Y[6] = full_Y_matrix.get_at(2,0);\n\t\t\t\t\t\tfull_Y[7] = full_Y_matrix.get_at(2,1);\n\t\t\t\t\t\tfull_Y[8] = full_Y_matrix.get_at(2,2);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t//Zero it, just to be safe (gens will accumulate into it)\n\t\t\t\t\t\tfull_Y[0] = full_Y[1] = full_Y[2] = complex(0.0,0.0);\n\t\t\t\t\t\tfull_Y[3] = full_Y[4] = full_Y[5] = complex(0.0,0.0);\n\t\t\t\t\t\tfull_Y[6] = full_Y[7] = full_Y[8] = complex(0.0,0.0);\n\t\t\t\t\t}\n\n\t\t\t\t\t//Allocate another matrix for admittance - this will have the full value\n\t\t\t\t\tfull_Y_all = (complex *)gl_malloc(9*sizeof(complex));\n\n\t\t\t\t\t//Check it\n\t\t\t\t\tif (full_Y_all==NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tGL_THROW(\"Node:%s failed to allocate space for the a deltamode variable\",me->name);\n\t\t\t\t\t\t//Defined above\n\t\t\t\t\t}\n\n\t\t\t\t\t//See if our published matrix has anything in it\n\t\t\t\t\tif ((full_Y_all_matrix.get_rows() == 3) && (full_Y_all_matrix.get_cols() == 3))\n\t\t\t\t\t{\n\t\t\t\t\t\tfull_Y_all[0] = full_Y_all_matrix.get_at(0,0);\n\t\t\t\t\t\tfull_Y_all[1] = full_Y_all_matrix.get_at(0,1);\n\t\t\t\t\t\tfull_Y_all[2] = full_Y_all_matrix.get_at(0,2);\n\n\t\t\t\t\t\tfull_Y_all[3] = full_Y_all_matrix.get_at(1,0);\n\t\t\t\t\t\tfull_Y_all[4] = full_Y_all_matrix.get_at(1,1);\n\t\t\t\t\t\tfull_Y_all[5] = full_Y_all_matrix.get_at(1,2);\n\n\t\t\t\t\t\tfull_Y_all[6] = full_Y_all_matrix.get_at(2,0);\n\t\t\t\t\t\tfull_Y_all[7] = full_Y_all_matrix.get_at(2,1);\n\t\t\t\t\t\tfull_Y_all[8] = full_Y_all_matrix.get_at(2,2);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t//Try growing it to the proper size\n\t\t\t\t\t\tfull_Y_all_matrix.grow_to(3,3);\n\n\t\t\t\t\t\t//Zero it, just to be safe (gens will accumulate into it)\n\t\t\t\t\t\tfull_Y_all[0] = full_Y_all[1] = full_Y_all[2] = complex(0.0,0.0);\n\t\t\t\t\t\tfull_Y_all[3] = full_Y_all[4] = full_Y_all[5] = complex(0.0,0.0);\n\t\t\t\t\t\tfull_Y_all[6] = full_Y_all[7] = full_Y_all[8] = complex(0.0,0.0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\t//Not needed, make sure we're nulled\n\t\t\t\t{\n\t\t\t\t\tfull_Y_all = NULL;\n\t\t\t\t}\n\t\t\t}//End Norton equivalent needing admittance\n\t\t\telse\t//Null them out of paranoia\n\t\t\t{\n\t\t\t\t//Null this one too\n\t\t\t\tfull_Y = NULL;\n\n\t\t\t\t//Null it, just because\n\t\t\t\tfull_Y_all = NULL;\n\t\t\t}\n\t\t}//End we're a parent\n\n\t\t//Map all relevant variables to the NR structure\n\t\tNR_busdata[NR_node_reference].full_Y = full_Y;\n\t\tNR_busdata[NR_node_reference].full_Y_all = full_Y_all;\n\t\tNR_busdata[NR_node_reference].DynCurrent = &deltamode_dynamic_current[0];\n\t\tNR_busdata[NR_node_reference].PGenTotal = &deltamode_PGenTotal;\n\t}\n\telse\t//Ensure it is empty\n\t{\n\t\tNR_busdata[NR_node_reference].full_Y = NULL;\n\t\tNR_busdata[NR_node_reference].full_Y_all = NULL;\n\t\tNR_busdata[NR_node_reference].DynCurrent = NULL;\n\t\tNR_busdata[NR_node_reference].PGenTotal = NULL;\n\t}\n\n\treturn 0;\n}\n\n//Computes \"load\" portions of current injection\n//parentcall is set when a parent object has called this update - mainly for locking purposes\nint node::NR_current_update(bool parentcall)\n{\n\tunsigned int table_index;\n\tFUNCTIONADDR temp_funadd = NULL;\n\tint temp_result, loop_index;\n\tOBJECT *obj = OBJECTHDR(this);\n\tOBJECT *tmp_obj;\n\tcomplex temp_current_inj[3];\n\tcomplex temp_current_val[3];\n\tcomplex adjusted_current_val[3];\n\tcomplex delta_shunt[3];\n\tcomplex delta_current[3];\n\tcomplex assumed_nominal_voltage[6];\n\tdouble nominal_voltage_dval;\n\tcomplex house_pres_current[3];\n\tcomplex temp_store[3];\n\n\t//Don't do anything if we've already been \"updated\"\n\tif (current_accumulated==false)\n\t{\n\t\tif (SubNode==CHILD)\t//Remove child contributions\n\t\t{\n\t\t\tnode *ParToLoad = OBJECTDATA(SubNodeParent,node);\n\n\t\t\tif (!parentcall)\t//We weren't called by our parent, so lock us to create sibling rivalry!\n\t\t\t{\n\t\t\t\t//Lock the parent for writing\n\t\t\t\tLOCK_OBJECT(SubNodeParent);\n\t\t\t}\n\n\t\t\t//Remove power and \"load\" characteristics\n\t\t\tParToLoad->power[0]-=last_child_power[0][0];\n\t\t\tParToLoad->power[1]-=last_child_power[0][1];\n\t\t\tParToLoad->power[2]-=last_child_power[0][2];\n\n\t\t\tParToLoad->shunt[0]-=last_child_power[1][0];\n\t\t\tParToLoad->shunt[1]-=last_child_power[1][1];\n\t\t\tParToLoad->shunt[2]-=last_child_power[1][2];\n\n\t\t\tParToLoad->current[0]-=last_child_power[2][0];\n\t\t\tParToLoad->current[1]-=last_child_power[2][1];\n\t\t\tParToLoad->current[2]-=last_child_power[2][2];\n\n\t\t\tif (has_phase(PHASE_S))\t//Triplex slightly different\n\t\t\t\tParToLoad->current12-=last_child_current12;\n\n\t\t\t//Unrotated stuff too\n\t\t\tParToLoad->pre_rotated_current[0] -= last_child_power[3][0];\n\t\t\tParToLoad->pre_rotated_current[1] -= last_child_power[3][1];\n\t\t\tParToLoad->pre_rotated_current[2] -= last_child_power[3][2];\n\n\t\t\t//And the deltamode accumulators too -- if deltamode\n\t\t\tif (deltamode_inclusive == true)\n\t\t\t{\n\t\t\t\t//Pull our parent value down -- everything is being pushed up there anyways\n\t\t\t\t//Pulling to keep meters accurate (theoretically)\n\t\t\t\tdeltamode_dynamic_current[0] = ParToLoad->deltamode_dynamic_current[0];\n\t\t\t\tdeltamode_dynamic_current[1] = ParToLoad->deltamode_dynamic_current[1];\n\t\t\t\tdeltamode_dynamic_current[2] = ParToLoad->deltamode_dynamic_current[2];\n\t\t\t}\n\n\t\t\t//Remove power and \"load\" characteristics for explicit delta/wye values\n\t\t\tfor (loop_index=0; loop_index<6; loop_index++)\n\t\t\t{\n\t\t\t\tParToLoad->power_dy[loop_index] -= last_child_power_dy[loop_index][0];\t\t//Power\n\t\t\t\tParToLoad->shunt_dy[loop_index] -= last_child_power_dy[loop_index][1];\t\t//Shunt\n\t\t\t\tParToLoad->current_dy[loop_index] -= last_child_power_dy[loop_index][2];\t//Current\n\t\t\t}\n\n\t\t\tif (!parentcall)\t//Wasn't a parent call - unlock us so our siblings get a shot\n\t\t\t{\n\t\t\t\t//Unlock the parent now that it is done\n\t\t\t\tUNLOCK_OBJECT(SubNodeParent);\n\t\t\t}\n\n\t\t\t//Update previous power tracker - if we haven't really converged, things will mess up without this\n\t\t\t//Power\n\t\t\tlast_child_power[0][0] = last_child_power[0][1] = last_child_power[0][2] = 0.0;\n\n\t\t\t//Shunt\n\t\t\tlast_child_power[1][0] = last_child_power[1][1] = last_child_power[1][2] = 0.0;\n\n\t\t\t//Current\n\t\t\tlast_child_power[2][0] = last_child_power[2][1] = last_child_power[2][2] = 0.0;\n\n\t\t\t//Zero the last power accumulators\n\t\t\tfor (loop_index=0; loop_index<6; loop_index++)\n\t\t\t{\n\t\t\t\tlast_child_power_dy[loop_index][0] = complex(0.0);\t//Power\n\t\t\t\tlast_child_power_dy[loop_index][1] = complex(0.0);\t//Shunt\n\t\t\t\tlast_child_power_dy[loop_index][2] = complex(0.0);\t//Current\n\t\t\t}\n\n\t\t\t//Current 12 if we are triplex\n\t\t\tif (has_phase(PHASE_S))\n\t\t\t\tlast_child_current12 = 0.0;\n\n\t\t\t//Do the same for the prerorated stuff\n\t\t\tlast_child_power[3][0] = last_child_power[3][1] = last_child_power[3][2] = complex(0.0,0.0);\n\t\t}\n\t\telse if (SubNode==DIFF_CHILD)\t//Differently connected \n\t\t{\n\t\t\tnode *ParToLoad = OBJECTDATA(SubNodeParent,node);\n\n\t\t\tif (!parentcall)\t//We weren't called by our parent, so lock us to create sibling rivalry!\n\t\t\t{\n\t\t\t\t//Lock the parent for writing\n\t\t\t\tLOCK_OBJECT(SubNodeParent);\n\t\t\t}\n\n\t\t\t//Remove power and \"load\" characteristics for explicit delta/wye values\n\t\t\tfor (loop_index=0; loop_index<6; loop_index++)\n\t\t\t{\n\t\t\t\tParToLoad->power_dy[loop_index] -= last_child_power_dy[loop_index][0];\t\t//Power\n\t\t\t\tParToLoad->shunt_dy[loop_index] -= last_child_power_dy[loop_index][1];\t\t//Shunt\n\t\t\t\tParToLoad->current_dy[loop_index] -= last_child_power_dy[loop_index][2];\t//Current\n\t\t\t}\n\n\t\t\t//Do this for the unrotated stuff too - it never gets auto-zeroed (like the above)\n\t\t\tParToLoad->pre_rotated_current[0] -= last_child_power[3][0];\n\t\t\tParToLoad->pre_rotated_current[1] -= last_child_power[3][1];\n\t\t\tParToLoad->pre_rotated_current[2] -= last_child_power[3][2];\n\n\t\t\tif (!parentcall)\t//Wasn't a parent call - unlock us so our siblings get a shot\n\t\t\t{\n\t\t\t\t//Unlock the parent now that it is done\n\t\t\t\tUNLOCK_OBJECT(SubNodeParent);\n\t\t\t}\n\n\t\t\t//Zero the last power accumulators\n\t\t\tfor (loop_index=0; loop_index<6; loop_index++)\n\t\t\t{\n\t\t\t\tlast_child_power_dy[loop_index][0] = complex(0.0);\t//Power\n\t\t\t\tlast_child_power_dy[loop_index][1] = complex(0.0);\t//Shunt\n\t\t\t\tlast_child_power_dy[loop_index][2] = complex(0.0);\t//Current\n\t\t\t}\n\n\t\t\t//Now zero the accmulator, just in case\n\t\t\tlast_child_power[3][0] = last_child_power[3][1] = last_child_power[3][2] = complex(0.0,0.0);\n\t\t}\n\n\t\tif ((SubNode==CHILD) || (SubNode==DIFF_CHILD))\t//Child Voltage Updates\n\t\t{\n\t\t\tnode *ParStealLoad = OBJECTDATA(SubNodeParent,node);\n\n\t\t\t//Steal our paren't voltages as well\n\t\t\t//this will either be parent called or a child \"no way it can change\" rank read - no lock needed\n\t\t\tvoltage[0] = ParStealLoad->voltage[0];\n\t\t\tvoltage[1] = ParStealLoad->voltage[1];\n\t\t\tvoltage[2] = ParStealLoad->voltage[2];\n\n\t\t\t//Compute \"delta\" voltages, so current injections upward are correct\n\t\t\tif (has_phase(PHASE_S))\n\t\t\t{\n\t\t\t\t//Compute the delta voltages\n\t\t\t\tvoltaged[0] = voltage[0] + voltage[1];\t//12\n\t\t\t\tvoltaged[1] = voltage[1] - voltage[2];\t//2N\n\t\t\t\tvoltaged[2] = voltage[0] - voltage[2];\t//1N -- unsure why it is odd\n\t\t\t}\n\t\t\telse\t//\"Normal\" three phase - compute normal deltas\n\t\t\t{\n\t\t\t\t//Compute the delta voltages\n\t\t\t\tvoltaged[0] = voltage[0] - voltage[1];\n\t\t\t\tvoltaged[1] = voltage[1] - voltage[2];\n\t\t\t\tvoltaged[2] = voltage[2] - voltage[0];\n\t\t\t}\n\t\t}\n\n\t\t//Handle relvant children first\n\t\tif (NR_number_child_nodes[0]>0)\t//We have children\n\t\t{\n\t\t\tfor (table_index=0; table_index<NR_number_child_nodes[0]; table_index++)\n\t\t\t{\n\t\t\t\t//Call their update - By this call's nature, it is being called by a parent here\n\t\t\t\ttemp_result = NR_child_nodes[table_index]->NR_current_update(true);\n\n\t\t\t\t//Make sure it worked, just to be thorough\n\t\t\t\tif (temp_result != 1)\n\t\t\t\t{\n\t\t\t\t\tGL_THROW(\"Attempt to update current on child of node:%s failed!\",obj->name);\n\t\t\t\t\t/*  TROUBLESHOOT\n\t\t\t\t\tWhile attempting to update the current on a childed node object, an error was encountered.  Please try again.  If the error persists,\n\t\t\t\t\tplease submit your code and a bug report via the trac website.\n\t\t\t\t\t*/\n\t\t\t\t}\n\t\t\t}//End FOR child table\n\t\t}//End we have children\n\n\t\t//Handle our \"self\" - do this in a \"temporary fashion\" for children problems\n\t\ttemp_current_inj[0] = temp_current_inj[1] = temp_current_inj[2] = complex(0.0,0.0);\n\n\t\t//If deltamode - adjust these accumulations, since this is already done inside powerflow (so numbers match)\n\t\tif (deltamode_inclusive == true)\n\t\t{\n\t\t\t//See if we're a triplex\n\t\t\tif (has_phase(PHASE_S))\n\t\t\t{\n\t\t\t\tassumed_nominal_voltage[0].SetPolar(nominal_voltage,0.0);\t\t\t//1\n\t\t\t\tassumed_nominal_voltage[1].SetPolar(nominal_voltage,0.0);\t\t\t//2\n\t\t\t\tassumed_nominal_voltage[2] = assumed_nominal_voltage[0] + assumed_nominal_voltage[1];\t//12\n\t\t\t\tassumed_nominal_voltage[3] = complex(0.0,0.0);\t//Not needed - zero for giggles\n\t\t\t\tassumed_nominal_voltage[4] = complex(0.0,0.0);\n\t\t\t\tassumed_nominal_voltage[5] = complex(0.0,0.0);\n\n\t\t\t\t//Populate LL value\n\t\t\t\tnominal_voltage_dval = 2.0 * nominal_voltage;\n\t\t\t}\n\t\t\telse //Standard fare\n\t\t\t{\n\t\t\t\tassumed_nominal_voltage[0].SetPolar(nominal_voltage,0.0);\t\t\t//AN\n\t\t\t\tassumed_nominal_voltage[1].SetPolar(nominal_voltage,(-2.0*PI/3.0));\t//BN\n\t\t\t\tassumed_nominal_voltage[2].SetPolar(nominal_voltage,(2.0*PI/3.0));\t//CN\n\t\t\t\tassumed_nominal_voltage[3] = assumed_nominal_voltage[0] - assumed_nominal_voltage[1];\t//AB\n\t\t\t\tassumed_nominal_voltage[4] = assumed_nominal_voltage[1] - assumed_nominal_voltage[2];\t//BC\n\t\t\t\tassumed_nominal_voltage[5] = assumed_nominal_voltage[2] - assumed_nominal_voltage[0];\t//CA\n\n\t\t\t\t//Populate LL value\n\t\t\t\tnominal_voltage_dval = assumed_nominal_voltage[3].Mag();\n\t\t\t}\n\t\t}\n\t\t//Default else - not deltamode, so don't care (don't even zero them)\n\n\t\tif (has_phase(PHASE_D))\t//Delta connection\n\t\t{\n\t\t\t//Convert delta connected impedance\n\t\t\tdelta_shunt[0] = voltaged[0]*shunt[0];\n\t\t\tdelta_shunt[1] = voltaged[1]*shunt[1];\n\t\t\tdelta_shunt[2] = voltaged[2]*shunt[2];\n\n\t\t\t//Convert delta connected power\n\t\t\tdelta_current[0]= (voltaged[0]==0) ? complex(0,0) : ~(power[0]/voltaged[0]);\n\t\t\tdelta_current[1]= (voltaged[1]==0) ? complex(0,0) : ~(power[1]/voltaged[1]);\n\t\t\tdelta_current[2]= (voltaged[2]==0) ? complex(0,0) : ~(power[2]/voltaged[2]);\n\n\t\t\t//Adjust constant current values, if deltamode\n\t\t\tif (deltamode_inclusive == true)\n\t\t\t{\n\t\t\t\t//Loop through the phases\n\t\t\t\tfor (loop_index=0; loop_index<3; loop_index++)\n\t\t\t\t{\n\t\t\t\t\t//Check existence of phases and adjust the currents appropriately\n\t\t\t\t\tif (voltaged[loop_index] != 0.0)\n\t\t\t\t\t{\n\t\t\t\t\t\tadjusted_current_val[loop_index] =  ~((assumed_nominal_voltage[loop_index+3]*~current[loop_index]*voltaged[loop_index].Mag())/(voltaged[loop_index]*nominal_voltage_dval));\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tadjusted_current_val[loop_index] = complex(0.0,0.0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//Standard approach\n\t\t\t\tadjusted_current_val[0] = current[0];\n\t\t\t\tadjusted_current_val[1] = current[1];\n\t\t\t\tadjusted_current_val[2] = current[2];\n\t\t\t}\n\n\t\t\t//Translate into a line current\n\t\t\ttemp_current_val[0] = delta_shunt[0]-delta_shunt[2] + delta_current[0]-delta_current[2] + adjusted_current_val[0]-adjusted_current_val[2];\n\t\t\ttemp_current_val[1] = delta_shunt[1]-delta_shunt[0] + delta_current[1]-delta_current[0] + adjusted_current_val[1]-adjusted_current_val[0];\n\t\t\ttemp_current_val[2] = delta_shunt[2]-delta_shunt[1] + delta_current[2]-delta_current[1] + adjusted_current_val[2]-adjusted_current_val[1];\n\n\t\t\ttemp_current_inj[0] = temp_current_val[0];\n\t\t\ttemp_current_inj[1] = temp_current_val[1];\n\t\t\ttemp_current_inj[2] = temp_current_val[2];\n\t\t}\n\t\telse if (has_phase(PHASE_S))\t//Split phase node\n\t\t{\n\t\t\tcomplex vdel;\n\t\t\tcomplex temp_current[3];\n\t\t\tcomplex temp_val[3];\n\n\t\t\t//Find V12 (just in case)\n\t\t\tvdel=voltage[0] + voltage[1];\n\n\t\t\t//Find contributions\n\t\t\t//Adjust constant current values, if deltamode\n\t\t\tif (deltamode_inclusive == true)\n\t\t\t{\n\t\t\t\t//Check existence of phases and adjust the currents appropriately\n\t\t\t\t//Phase 1\n\t\t\t\tif (voltage[0] != 0.0)\n\t\t\t\t{\n\t\t\t\t\tadjusted_current_val[0] =  ~((assumed_nominal_voltage[0]*~current[0]*voltage[0].Mag())/(voltage[0]*nominal_voltage));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tadjusted_current_val[0] = complex(0.0,0.0);\n\t\t\t\t}\n\n\t\t\t\t//Phase 2\n\t\t\t\tif (voltage[1] != 0.0)\n\t\t\t\t{\n\t\t\t\t\tadjusted_current_val[1] =  ~((assumed_nominal_voltage[1]*~current[1]*voltage[1].Mag())/(voltage[1]*nominal_voltage));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tadjusted_current_val[1] = complex(0.0,0.0);\n\t\t\t\t}\n\n\t\t\t\t//Phase 12\n\t\t\t\tif (vdel != 0.0)\n\t\t\t\t{\n\t\t\t\t\tadjusted_current_val[2] =  ~((assumed_nominal_voltage[2]*~current12*vdel.Mag())/(vdel*nominal_voltage_dval));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tadjusted_current_val[2] = complex(0.0,0.0);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//Standard approach\n\t\t\t\tadjusted_current_val[0] = current[0];\n\t\t\t\tadjusted_current_val[1] = current[1];\n\t\t\t\tadjusted_current_val[2] = current12;\t//current12 is not part of the standard current array\n\t\t\t}\n\n\t\t\t//Start with the currents (just put them in)\n\t\t\ttemp_current[0] = adjusted_current_val[0];\n\t\t\ttemp_current[1] = adjusted_current_val[1];\n\t\t\ttemp_current[2] = adjusted_current_val[2];\n\n\t\t\t//Add in the unrotated bit, if we're deltamode\n\t\t\tif (deltamode_inclusive == true)\n\t\t\t{\n\t\t\t\ttemp_current[0] += pre_rotated_current[0];\t//1\n\t\t\t\ttemp_current[1] += pre_rotated_current[1];\t//2\n\t\t\t\ttemp_current[2] += pre_rotated_current[2];\t//12\n\t\t\t}\n\n\t\t\t//Now add in power contributions\n\t\t\ttemp_current[0] += voltage[0] == 0.0 ? 0.0 : ~(power[0]/voltage[0]);\n\t\t\ttemp_current[1] += voltage[1] == 0.0 ? 0.0 : ~(power[1]/voltage[1]);\n\t\t\ttemp_current[2] += vdel == 0.0 ? 0.0 : ~(power[2]/vdel);\n\n\t\t\tif (house_present)\t//House present\n\t\t\t{\n\t\t\t\t//Update phase adjustments\n\t\t\t\ttemp_store[0].SetPolar(1.0,voltage[0].Arg());\t//Pull phase of V1\n\t\t\t\ttemp_store[1].SetPolar(1.0,voltage[1].Arg());\t//Pull phase of V2\n\t\t\t\ttemp_store[2].SetPolar(1.0,vdel.Arg());\t\t//Pull phase of V12\n\n\t\t\t\t//Update these current contributions\n\t\t\t\thouse_pres_current[0] = nom_res_curr[0]/(~temp_store[0]);\t\t//Just denominator conjugated to keep math right (rest was conjugated in house)\n\t\t\t\thouse_pres_current[1] = nom_res_curr[1]/(~temp_store[1]);\n\t\t\t\thouse_pres_current[2] = nom_res_curr[2]/(~temp_store[2]);\n\n\t\t\t\t//Now add it into the current contributions\n\t\t\t\ttemp_current[0] += house_pres_current[0];\n\t\t\t\ttemp_current[1] += house_pres_current[1];\n\t\t\t\ttemp_current[2] += house_pres_current[2];\n\t\t\t}//End house-attached splitphase\n\n\t\t\t//Last, but not least, admittance/impedance contributions\n\t\t\ttemp_current[0] += shunt[0]*voltage[0];\n\t\t\ttemp_current[1] += shunt[1]*voltage[1];\n\t\t\ttemp_current[2] += shunt[2]*vdel;\n\n\t\t\t//Convert 'em to line currents\n\t\t\ttemp_current_val[0] = temp_current[0] + temp_current[2];\n\t\t\ttemp_current_val[1] = -temp_current[1] - temp_current[2];\n\n\t\t\ttemp_current_inj[0] = temp_current_val[0];\n\t\t\ttemp_current_inj[1] = temp_current_val[1];\n\n\t\t\t//Get information\n\t\t\tif ((Triplex_Data != NULL) && ((Triplex_Data[0] != 0.0) || (Triplex_Data[1] != 0.0)))\n\t\t\t{\n\t\t\t\t/* normally the calc would not be inside the lock, but it's reflexive so that's ok */\n\t\t\t\ttemp_current_inj[2] = Triplex_Data[0]*temp_current_inj[0] + Triplex_Data[1]*temp_current_inj[1];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* normally the calc would not be inside the lock, but it's reflexive so that's ok */\n\t\t\t\ttemp_current_inj[2] = ((voltage1.IsZero() || (power1.IsZero() && shunt1.IsZero())) ||\n\t\t\t\t\t\t\t\t   (voltage2.IsZero() || (power2.IsZero() && shunt2.IsZero()))) \n\t\t\t\t\t\t\t\t\t? currentN : -((temp_current_inj[0]-temp_current[2])+(temp_current_inj[1]-temp_current[2]));\n\t\t\t}\n\t\t}\n\t\telse\t\t\t\t\t//Wye connection\n\t\t{\n\t\t\t//Adjust constant current values, if deltamode\n\t\t\tif (deltamode_inclusive == true)\n\t\t\t{\n\t\t\t\t//Loop through the phases\n\t\t\t\tfor (loop_index=0; loop_index<3; loop_index++)\n\t\t\t\t{\n\t\t\t\t\t//Check existence of phases and adjust the currents appropriately\n\t\t\t\t\tif (voltage[loop_index] != 0.0)\n\t\t\t\t\t{\n\t\t\t\t\t\tadjusted_current_val[loop_index] =  ~((assumed_nominal_voltage[loop_index]*~current[loop_index]*voltage[loop_index].Mag())/(voltage[loop_index]*nominal_voltage));\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tadjusted_current_val[loop_index] = complex(0.0,0.0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//Standard approach\n\t\t\t\tadjusted_current_val[0] = current[0];\n\t\t\t\tadjusted_current_val[1] = current[1];\n\t\t\t\tadjusted_current_val[2] = current[2];\n\t\t\t}\n\n\t\t\t//PQP needs power converted to current\n\t\t\t//PQZ needs load currents calculated as well\n\t\t\t//Update load current values if PQI\n\t\t\ttemp_current_val[0] = ((voltage[0]==0) ? complex(0,0) : ~(power[0]/voltage[0])) + voltage[0]*shunt[0] + adjusted_current_val[0] + pre_rotated_current[0];\n\t\t\ttemp_current_val[1] = ((voltage[1]==0) ? complex(0,0) : ~(power[1]/voltage[1])) + voltage[1]*shunt[1] + adjusted_current_val[1] + pre_rotated_current[1];\n\t\t\ttemp_current_val[2] = ((voltage[2]==0) ? complex(0,0) : ~(power[2]/voltage[2])) + voltage[2]*shunt[2] + adjusted_current_val[2] + pre_rotated_current[2];\n\n\t\t\ttemp_current_inj[0] = temp_current_val[0];\n\t\t\ttemp_current_inj[1] = temp_current_val[1];\n\t\t\ttemp_current_inj[2] = temp_current_val[2];\n\t\t}\n\n\t\t//Explicit delta-wye portions (do both) -- make sure not triplex though\n\t\tif (!(has_phase(PHASE_S)))\n\t\t{\n\t\t\t//Do delta-connected portions\n\n\t\t\t//Convert delta connected impedance\n\t\t\tdelta_shunt[0] = voltaged[0]*shunt_dy[0];\n\t\t\tdelta_shunt[1] = voltaged[1]*shunt_dy[1];\n\t\t\tdelta_shunt[2] = voltaged[2]*shunt_dy[2];\n\n\t\t\t//Convert delta connected power\n\t\t\tdelta_current[0]= (voltaged[0]==0) ? complex(0,0) : ~(power_dy[0]/voltaged[0]);\n\t\t\tdelta_current[1]= (voltaged[1]==0) ? complex(0,0) : ~(power_dy[1]/voltaged[1]);\n\t\t\tdelta_current[2]= (voltaged[2]==0) ? complex(0,0) : ~(power_dy[2]/voltaged[2]);\n\n\t\t\t//Adjust constant current values of delta-connected, if deltamode\n\t\t\tif (deltamode_inclusive == true)\n\t\t\t{\n\t\t\t\t//Loop through the phases\n\t\t\t\tfor (loop_index=0; loop_index<3; loop_index++)\n\t\t\t\t{\n\t\t\t\t\t//Check existence of phases and adjust the currents appropriately\n\t\t\t\t\tif (voltaged[loop_index] != 0.0)\n\t\t\t\t\t{\n\t\t\t\t\t\tadjusted_current_val[loop_index] =  ~((assumed_nominal_voltage[loop_index+3]*~current_dy[loop_index]*voltaged[loop_index].Mag())/(voltaged[loop_index]*nominal_voltage_dval));\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tadjusted_current_val[loop_index] = complex(0.0,0.0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//Standard approach\n\t\t\t\tadjusted_current_val[0] = current_dy[0];\n\t\t\t\tadjusted_current_val[1] = current_dy[1];\n\t\t\t\tadjusted_current_val[2] = current_dy[2];\n\t\t\t}\n\n\n\t\t\t//Put into accumulator\n\t\t\ttemp_current_inj[0] += delta_shunt[0]-delta_shunt[2] + delta_current[0]-delta_current[2] + adjusted_current_val[0]-adjusted_current_val[2];\n\t\t\ttemp_current_inj[1] += delta_shunt[1]-delta_shunt[0] + delta_current[1]-delta_current[0] + adjusted_current_val[1]-adjusted_current_val[0];\n\t\t\ttemp_current_inj[2] += delta_shunt[2]-delta_shunt[1] + delta_current[2]-delta_current[1] + adjusted_current_val[2]-adjusted_current_val[1];\n\n\t\t\t//Adjust constant current values for Wye-connected, if deltamode\n\t\t\tif (deltamode_inclusive == true)\n\t\t\t{\n\t\t\t\t//Loop through the phases\n\t\t\t\tfor (loop_index=0; loop_index<3; loop_index++)\n\t\t\t\t{\n\t\t\t\t\tif (voltage[loop_index] != 0.0)\n\t\t\t\t\t{\n\t\t\t\t\t\tadjusted_current_val[loop_index] =  ~((assumed_nominal_voltage[loop_index]*~current_dy[loop_index+3]*voltage[loop_index].Mag())/(voltage[loop_index]*nominal_voltage));\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tadjusted_current_val[loop_index] = complex(0.0,0.0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//Standard approach\n\t\t\t\tadjusted_current_val[0] = current_dy[3];\n\t\t\t\tadjusted_current_val[1] = current_dy[4];\n\t\t\t\tadjusted_current_val[2] = current_dy[5];\n\t\t\t}\n\n\t\t\t//Now put in Wye components\n\t\t\ttemp_current_inj[0] += ((voltage[0]==0) ? complex(0,0) : ~(power_dy[3]/voltage[0])) + voltage[0]*shunt_dy[3] + adjusted_current_val[0];\n\t\t\ttemp_current_inj[1] += ((voltage[1]==0) ? complex(0,0) : ~(power_dy[4]/voltage[1])) + voltage[1]*shunt_dy[4] + adjusted_current_val[1];\n\t\t\ttemp_current_inj[2] += ((voltage[2]==0) ? complex(0,0) : ~(power_dy[5]/voltage[2])) + voltage[2]*shunt_dy[5] + adjusted_current_val[2];\n\n\t\t\t//Explicit house inclusion for \"non-triplex\" houses\n\t\t\tif (house_present)\t//House present\n\t\t\t{\n\t\t\t\t//Do it in a loop, just because\n\t\t\t\tfor (loop_index=0; loop_index<3; loop_index++)\n\t\t\t\t{\n\t\t\t\t\t//See if we're even a valid voltage\n\t\t\t\t\tif (voltage[loop_index].Mag() != 0.0)\n\t\t\t\t\t{\n\t\t\t\t\t\t//Update phase adjustments\n\t\t\t\t\t\ttemp_store[loop_index].SetPolar(1.0,voltage[loop_index].Arg());\t//Pull phase of this voltage phase\n\n\t\t\t\t\t\t//Update these current contributions\n\t\t\t\t\t\thouse_pres_current[loop_index] = nom_res_curr[loop_index]/(~temp_store[loop_index]);\t\t//Just denominator conjugated to keep math right (rest was conjugated in house)\n\n\t\t\t\t\t\t//Now add it into the current contributions\n\t\t\t\t\t\ttemp_current_inj[loop_index] += ((voltage[loop_index]==0) ? complex(0,0) : house_pres_current[loop_index]);\n\t\t\t\t\t}\n\t\t\t\t\t//Default else - voltage is zero, do nothing\n\t\t\t\t}//End phase loop for houses\n\t\t\t}//End house-attached not-so-split-phase\n\t\t}//End both delta/wye\n\n\t\t//If we are a child, apply our current injection directly up to our parent - links accumulate afterwards now because they bypass child relationships\n\t\tif ((SubNode==CHILD) || (SubNode==DIFF_CHILD))\n\t\t{\n\t\t\tnode *ParLoadObj=OBJECTDATA(SubNodeParent,node);\n\n\t\t\tif (ParLoadObj->current_accumulated==false)\t//Locking not needed here - if parent hasn't accumulated yet, it is the one that called us (rank split)\n\t\t\t{\n\t\t\t\tParLoadObj->current_inj[0] += temp_current_inj[0];\t//This ensures link-related injections are not counted\n\t\t\t\tParLoadObj->current_inj[1] += temp_current_inj[1];\n\t\t\t\tParLoadObj->current_inj[2] += temp_current_inj[2];\n\n\t\t\t\t//See if we have a house - if we do, we're inadvertently biasing our parent\n\t\t\t\t//Not only a house, but a triplex-connected house\n\t\t\t\tif ((house_present) && has_phase(PHASE_S))\n\t\t\t\t{\n\t\t\t\t\t//Remove the line_12 current appropriately\n\t\t\t\t\tParLoadObj->current_inj[0] -= house_pres_current[0] + house_pres_current[2];\n\t\t\t\t\tParLoadObj->current_inj[1] -= -house_pres_current[1] - house_pres_current[2];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//Update our accumulator as well, otherwise things break\n\t\t\tcurrent_inj[0] += temp_current_inj[0];\n\t\t\tcurrent_inj[1] += temp_current_inj[1];\n\t\t\tcurrent_inj[2] += temp_current_inj[2];\n\t\t}\n\t\telse\t//Not a child, just put this in our accumulator - we're already locked, so no need to separately lock\n\t\t{\n\t\t\tcurrent_inj[0] += temp_current_inj[0];\n\t\t\tcurrent_inj[1] += temp_current_inj[1];\n\t\t\tcurrent_inj[2] += temp_current_inj[2];\n\t\t}\n\n\t\t//See if we're delta-enabled and need to accumulate those items\n\t\t//Note that this is done after the parent/child update due to child deltamode objects mapping \"through\"\n\t\t//To the parent.  If this was above the previous code, deltamode-related postings get counted twice.\n\t\tif ((deltamode_inclusive == true) && (dynamic_norton == true))\n\t\t{\n\t\t\t//Injections from generators -- always accumulate (may be zero)\n\t\t\tcurrent_inj[0] -= deltamode_dynamic_current[0];\n\t\t\tcurrent_inj[1] -= deltamode_dynamic_current[1];\n\t\t\tcurrent_inj[2] -= deltamode_dynamic_current[2];\n\n\t\t\t//See if the shunt exists\n\t\t\tif (full_Y != NULL)\n\t\t\t{\n\t\t\t\t//This assumes three-phase right now\n\t\t\t\tcurrent_inj[0] += full_Y[0]*voltage[0] + full_Y[1]*voltage[1] + full_Y[2]*voltage[2];\n\t\t\t\tcurrent_inj[1] += full_Y[3]*voltage[0] + full_Y[4]*voltage[1] + full_Y[5]*voltage[2];\n\t\t\t\tcurrent_inj[2] += full_Y[6]*voltage[0] + full_Y[7]*voltage[1] + full_Y[8]*voltage[2];\n\t\t\t}\n\t\t}\n\n\t\t//Handle our links - \"child\" contributions are bypassed into their parents due to NR structure, so this order works\n\t\tif ((SubNode!=CHILD) && (SubNode!=DIFF_CHILD))\t//Make sure we aren't children as well, since we'll get NULL pointers and make everyone upset\n\t\t{\n\t\t\tfor (table_index=0; table_index<NR_busdata[NR_node_reference].Link_Table_Size; table_index++)\n\t\t\t{\n\t\t\t\t//Extract the object pointer - just for readability\n\t\t\t\ttmp_obj = NR_branchdata[NR_busdata[NR_node_reference].Link_Table[table_index]].obj;\n\n\t\t\t\t//Extract the function address\n\t\t\t\ttemp_funadd = (FUNCTIONADDR)(gl_get_function(tmp_obj,\"perform_current_calculation_pwr_link\"));\n\t\t\t\t\n\t\t\t\t//Make sure it worked\n\t\t\t\tif (temp_funadd == NULL)\n\t\t\t\t{\n\t\t\t\t\tGL_THROW(\"Attemped to update current for object:%s failed!\",(tmp_obj->name?tmp_obj->name:\"Unnamed\"));\n\t\t\t\t\t/*  TROUBLESHOOT\n\t\t\t\t\tThe current node object tried to update the current injections for what it thought was a link object.  This does\n\t\t\t\t\tnot appear to be true.  Try your code again.  If the error persists, please submit your GLM and a bug report to the\n\t\t\t\t\tissue tracker.\n\t\t\t\t\t*/\n\t\t\t\t}\n\n\t\t\t\t//Call a lock on that link - just in case multiple nodes call it at once\n\t\t\t\tWRITELOCK_OBJECT(tmp_obj);\n\n\t\t\t\t//Call its update - tell it who is asking so it knows what to lock\n\t\t\t\ttemp_result = ((int (*)(OBJECT *,int, bool))(*temp_funadd))(tmp_obj,NR_node_reference,false);\n\n\t\t\t\t//Unlock the link\n\t\t\t\tWRITEUNLOCK_OBJECT(tmp_obj);\n\n\t\t\t\t//See if it worked, just in case this gets added in the future\n\t\t\t\tif (temp_result != 1)\n\t\t\t\t{\n\t\t\t\t\tGL_THROW(\"Attempt to update current on link:%s failed!\",NR_branchdata[NR_busdata[NR_node_reference].Link_Table[table_index]].name);\n\t\t\t\t\t/*  TROUBLESHOOT\n\t\t\t\t\tWhile attempting to update the current on link object, an error was encountered.  Please try again.  If the error persists,\n\t\t\t\t\tplease submit your code and a bug report via the trac website.\n\t\t\t\t\t*/\n\t\t\t\t}\n\t\t\t}//End link traversion\n\t\t}//End not children\n\n\t\t//Flag us as done\n\t\tcurrent_accumulated = true;\n\t}//End current already handled\n\n\treturn 1;\t//Always successful\n}\n\n//////////////////////////////////////////////////////////////////////////\n// IMPLEMENTATION OF DELTA MODE\n//////////////////////////////////////////////////////////////////////////\n//Module-level call\nSIMULATIONMODE node::inter_deltaupdate_node(unsigned int64 delta_time, unsigned long dt, unsigned int iteration_count_val,bool interupdate_pos)\n{\n\t//unsigned char pass_mod;\n\tdouble deltat;\n\tOBJECT *hdr = OBJECTHDR(this);\n\tSTATUS return_status_val;\n\n\t////See what we're on, for tracking\n\t//pass_mod = iteration_count_val - ((iteration_count_val >> 1) << 1);\n\n\t//Create delta_t variable\n\tdeltat = (double)dt/(double)DT_SECOND;\n\n\t//Update time tracking variable - mostly for GFA functionality calls\n\tif ((iteration_count_val==0) && (interupdate_pos == false)) //Only update timestamp tracker on first iteration\n\t{\n\t\t//Update tracking variable\n\t\tprev_time_dbl = gl_globaldeltaclock;\n\n\t\t//Update frequency calculation values (if needed)\n\t\tif (fmeas_type != FM_NONE)\n\t\t{\n\t\t\t//See which pass\n\t\t\tif (delta_time == 0)\n\t\t\t{\n\t\t\t\t//Initialize dynamics - first run of new delta call\n\t\t\t\tinit_freq_dynamics(deltat);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//Copy the tracker value\n\t\t\t\tmemcpy(&prev_freq_state,&curr_freq_state,sizeof(FREQM_STATES));\n\t\t\t}\n\t\t}\n\t}\n\n\t//Perform the GFA update, if enabled\n\tif ((GFA_enable == true) && (iteration_count_val == 0) && (interupdate_pos == false))\t//Always just do on the first pass\n\t{\n\t\t//Do the checks\n\t\tGFA_Update_time = perform_GFA_checks(deltat);\n\t}\n\n\t//Determine what to run\n\tif (interupdate_pos == false)\t//Before powerflow call\n\t{\n\t\t//Call presync-equivalent items\n\t\tNR_node_presync_fxn(0);\n\n\t\t//Call sync-equivalent items (solver occurs at end of sync)\n\t\tNR_node_sync_fxn(hdr);\n\n\t\treturn SM_DELTA;\t//Just return something other than SM_ERROR for this call\n\n\t}//End Before NR solver (or inclusive)\n\telse\t//After the call\n\t{\n\t\t//Perform postsync-like updates on the values\n\t\tBOTH_node_postsync_fxn(hdr);\n\n\t\t//Frequency measurement stuff\n\t\tif (fmeas_type != FM_NONE)\n\t\t{\n\t\t\treturn_status_val = calc_freq_dynamics(deltat);\n\n\t\t\t//Check it\n\t\t\tif (return_status_val == FAILED)\n\t\t\t{\n\t\t\t\treturn SM_ERROR;\n\t\t\t}\n\t\t}//End frequency measurement desired\n\t\t//Default else -- don't calculate it\n\n\t\t//See if GFA functionality is required, since it may require iterations or \"continance\"\n\t\tif (GFA_enable == true)\n\t\t{\n\t\t\t//See if our return is value\n\t\t\tif ((GFA_Update_time > 0.0) && (GFA_Update_time < 1.7))\n\t\t\t{\n\t\t\t\t//Force us to stay\n\t\t\t\treturn SM_DELTA;\n\t\t\t}\n\t\t\telse\t//Just return whatever we were going to do\n\t\t\t{\n\t\t\t\treturn SM_EVENT;\n\t\t\t}\n\t\t}\n\t\telse\t//Normal mode\n\t\t{\n\t\t\treturn SM_EVENT;\n\t\t}\n\n\t\t//No control required at this time - powerflow defers to the whims of other modules\n\t\t//Code below implements predictor/corrector-type logic, even though it effectively does nothing\n\t\t//return SM_EVENT;\n\n\t\t////Do deltamode-related logic\n\t\t//if (bustype==SWING)\t//We're the SWING bus, control our destiny (which is really controlled elsewhere)\n\t\t//{\n\t\t//\t//See what we're on\n\t\t//\tpass_mod = iteration_count_val - ((iteration_count_val >> 1) << 1);\n\n\t\t//\t//Check pass\n\t\t//\tif (pass_mod==0)\t//Predictor pass\n\t\t//\t{\n\t\t//\t\treturn SM_DELTA_ITER;\t//Reiterate - to get us to corrector pass\n\t\t//\t}\n\t\t//\telse\t//Corrector pass\n\t\t//\t{\n\t\t//\t\t//As of right now, we're always ready to leave\n\t\t//\t\t//Other objects will dictate if we stay (powerflow is indifferent)\n\t\t//\t\treturn SM_EVENT;\n\t\t//\t}//End corrector pass\n\t\t//}//End SWING bus handling\n\t\t//else\t//Normal bus\n\t\t//{\n\t\t//\treturn SM_EVENT;\t//Normal nodes want event mode all the time here - SWING bus will\n\t\t//\t\t\t\t\t\t//control the reiteration process for pred/corr steps\n\t\t//}\n\t}//End \"After NR solver\" branch\n}\n\n//Performs the frequency measurement calculations in a nice, compact form\n//for easy copy-paste\nSTATUS node::calc_freq_dynamics(double deltat)\n{\n\tunsigned char phase_conf, phase_mask;\n\tunsigned int indexval;\n\tdouble dfmeasdt, errorval, deltaom, dxdt, fbus, adiffval;\n\tSTATUS return_status;\n\tbool is_triplex_node;\n\n\t//Init for success\n\treturn_status = SUCCESS;\n\n\t//Extract the phases\n\tif ((SubNode!=CHILD) && (SubNode!=DIFF_CHILD))\n\t{\n\t\tif ((NR_busdata[NR_node_reference].phases & 0x80) == 0x80)\n\t\t{\n\t\t\tphase_conf = 0x80;\n\t\t\tis_triplex_node = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tphase_conf=NR_busdata[NR_node_reference].phases & 0x07;\n\t\t\tis_triplex_node = false;\n\t\t}\n\t}\n\telse\t//It is a child - look at parent\n\t{\n\t\tif ((NR_busdata[*NR_subnode_reference].phases & 0x80) == 0x80)\n\t\t{\n\t\t\tphase_conf = 0x80;\n\t\t\tis_triplex_node = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tphase_conf=NR_busdata[*NR_subnode_reference].phases & 0x07;\n\t\t\tis_triplex_node = false;\n\t\t}\n\t}\n\n\t//Pull voltage updates\n\tfor (indexval=0; indexval<3; indexval++)\n\t{\n\t\tif (is_triplex_node == true)\n\t\t{\n\t\t\tphase_mask = 0x80;\n\t\t}\n\t\telse\t//three-phase, of some sort\n\t\t{\n\t\t\t//Get the mask\n\t\t\tphase_mask = (1 << (2 - indexval));\n\t\t}\n\n\t\t//Check the phase\n\t\tif ((phase_conf & phase_mask) == phase_mask)\n\t\t{\n\t\t\t//See what our reference is - steal parent voltages\n\t\t\tif ((SubNode!=CHILD) && (SubNode!=DIFF_CHILD))\n\t\t\t{\n\t\t\t\tif (is_triplex_node == true)\n\t\t\t\t{\n\t\t\t\t\tif (indexval < 2)\n\t\t\t\t\t{\n\t\t\t\t\t\tcurr_freq_state.voltage_val[indexval]=NR_busdata[NR_node_reference].V[indexval];\n\t\t\t\t\t}\n\t\t\t\t\telse\t//Must be 2\n\t\t\t\t\t{\n\t\t\t\t\t\tcurr_freq_state.voltage_val[indexval]=NR_busdata[NR_node_reference].V[0] + NR_busdata[NR_node_reference].V[1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcurr_freq_state.voltage_val[indexval]=NR_busdata[NR_node_reference].V[indexval];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\t//It is a child - look at parent\n\t\t\t{\n\t\t\t\tif (is_triplex_node == true)\n\t\t\t\t{\n\t\t\t\t\tif (indexval < 2)\n\t\t\t\t\t{\n\t\t\t\t\t\tcurr_freq_state.voltage_val[indexval]=NR_busdata[*NR_subnode_reference].V[indexval];\n\t\t\t\t\t}\n\t\t\t\t\telse\t//Must be 2\n\t\t\t\t\t{\n\t\t\t\t\t\tcurr_freq_state.voltage_val[indexval]=NR_busdata[*NR_subnode_reference].V[0] + NR_busdata[*NR_subnode_reference].V[1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcurr_freq_state.voltage_val[indexval]=NR_busdata[*NR_subnode_reference].V[indexval];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//Extract the angle - use ATAN2, since it divides better than the complex-oriented .Arg function\n\t\t\tcurr_freq_state.anglemeas[indexval] = atan2(curr_freq_state.voltage_val[indexval].Im(),curr_freq_state.voltage_val[indexval].Re());\n\n\t\t\t//Perform update\n\t\t\tif (fmeas_type == FM_SIMPLE)\n\t\t\t{\n\t\t\t\t//Use a function to get the difference\n\t\t\t\tadiffval = compute_angle_diff(curr_freq_state.anglemeas[indexval],prev_freq_state.anglemeas[indexval]);\n\n\t\t\t\tfbus = (adiffval/deltat + freq_omega_ref) / (2.0 * PI);\n\t\t\t\tdfmeasdt = (fbus - prev_freq_state.fmeas[indexval]) / freq_sfm_Tf;\n\t\t\t\tcurr_freq_state.fmeas[indexval] = prev_freq_state.fmeas[indexval] + dfmeasdt*deltat;\n\t\t\t}\n\t\t\telse if (fmeas_type == FM_PLL)\n\t\t\t{\n\t\t\t\t//Compute error - make sure isn't zero - if it is, ignore this\n\t\t\t\tif (prev_freq_state.voltage_val[indexval].Mag() > 0.0)\n\t\t\t\t{\n\t\t\t\t\terrorval = prev_freq_state.voltage_val[indexval].Re()*prev_freq_state.sinangmeas[indexval];\n\t\t\t\t\terrorval -= prev_freq_state.voltage_val[indexval].Im()*prev_freq_state.cosangmeas[indexval];\n\t\t\t\t\terrorval /= prev_freq_state.voltage_val[indexval].Mag();\n\t\t\t\t\terrorval *= -1.0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terrorval = 0.0;\n\t\t\t\t}\n\n\t\t\t\tdeltaom = freq_pll_Kp * errorval + prev_freq_state.x[indexval];\n\t\t\t\tdxdt = freq_pll_Ki * errorval;\n\n\t\t\t\t//Updates\n\t\t\t\tcurr_freq_state.fmeas[indexval] = (freq_omega_ref + deltaom) / (2.0 * PI);\n\t\t\t\tcurr_freq_state.x[indexval] = prev_freq_state.x[indexval] + dxdt*deltat;\n\t\t\t\tcurr_freq_state.anglemeas[indexval] = prev_freq_state.anglemeas[indexval] + deltaom*deltat;\n\n\t\t\t\t//Update trig values\n\t\t\t\tcurr_freq_state.sinangmeas[indexval] = sin(curr_freq_state.anglemeas[indexval]);\n\t\t\t\tcurr_freq_state.cosangmeas[indexval] = cos(curr_freq_state.anglemeas[indexval]);\n\t\t\t}\n\t\t\t//Default else -- other method (or not a valid method)\n\t\t}//End valid phase\n\t\telse\t//Not a valid phase\n\t\t{\n\t\t\tcurr_freq_state.fmeas[indexval] = 0.0;\n\t\t}\n\t}//End phase loop\n\n\t//Update the \"average\" frequency value\n\tswitch(phase_conf) {\n\t\tcase 0x00:\t//No phases (we've been faulted out\n\t\t\t{\n\t\t\t\tcurr_freq_state.average_freq = 0.0;\n\t\t\t\tbreak;\t//Just get us outta here\n\t\t\t}\n\t\tcase 0x01:\t//Only C\n\t\t\t{\n\t\t\t\tcurr_freq_state.average_freq = curr_freq_state.fmeas[2];\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase 0x02:\t//Only B\n\t\t\t{\n\t\t\t\tcurr_freq_state.average_freq = curr_freq_state.fmeas[1];\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase 0x03:\t//B & C\n\t\t\t{\n\t\t\t\tcurr_freq_state.average_freq = (curr_freq_state.fmeas[1] + curr_freq_state.fmeas[2]) / 2.0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase 0x04:\t//Only A\n\t\t\t{\n\t\t\t\tcurr_freq_state.average_freq = curr_freq_state.fmeas[0];\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase 0x05:\t//A & C\n\t\t\t{\n\t\t\t\tcurr_freq_state.average_freq = (curr_freq_state.fmeas[0] + curr_freq_state.fmeas[2]) / 2.0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase 0x06:\t//A & B\n\t\t\t{\n\t\t\t\tcurr_freq_state.average_freq = (curr_freq_state.fmeas[0] + curr_freq_state.fmeas[1]) / 2.0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase 0x07:\t//ABC\n\t\t\t{\n\t\t\t\tcurr_freq_state.average_freq = (curr_freq_state.fmeas[0] + curr_freq_state.fmeas[1] + curr_freq_state.fmeas[2]) / 3.0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase 0x80:\t//Triplex stuff\n\t\t\t{\n\t\t\t\tcurr_freq_state.average_freq = curr_freq_state.fmeas[2];\t//Just take the 12 value, for now\n\t\t\t\tbreak;\n\t\t\t}\n\t\tdefault:\t//How'd we get here?\n\t\t\t{\n\t\t\t\tgl_error(\"Node frequency update: unknown state encountered\");\n\t\t\t\t/*  TROUBLESHOOT\n\t\t\t\tWhile running the frequency/angle estimation routine for a node object, it somehow entered an unknown state.\n\t\t\t\tPlease try again.  If the error persists, please submit your GLM and a bug report via the ticketing system.\n\t\t\t\t*/\n\n\t\t\t\treturn_status = FAILED;\n\n\t\t\tbreak;\n\t\t\t}\n\t}\t//switch end\n\n\treturn return_status;\n}\n\n//Initializes dynamic equations for first entry\n//Returns a SUCCESS/FAIL\n//curr_time is the initial states/information\nvoid node::init_freq_dynamics(double deltat)\n{\n\tunsigned char phase_conf, phase_mask;\n\tint indexval;\n\tbool is_triplex_node;\n\tdouble frequency_offset_val, angle_offset;\n\tcomplex angle_rotate_value;\n\n\t//Extract the phases\n\tif ((SubNode!=CHILD) && (SubNode!=DIFF_CHILD))\n\t{\n\t\tif ((NR_busdata[NR_node_reference].phases & 0x80) == 0x80)\n\t\t{\n\t\t\tphase_conf = 0x80;\n\t\t\tis_triplex_node = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tphase_conf=NR_busdata[NR_node_reference].phases & 0x07;\n\t\t\tis_triplex_node = false;\n\t\t}\n\t}\n\telse\t//It is a child - look at parent\n\t{\n\t\tif ((NR_busdata[*NR_subnode_reference].phases & 0x80) == 0x80)\n\t\t{\n\t\t\tphase_conf = 0x80;\n\t\t\tis_triplex_node = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tphase_conf=NR_busdata[*NR_subnode_reference].phases & 0x07;\n\t\t\tis_triplex_node = false;\n\t\t}\n\t}\n\n\t//Pull voltage updates\n\tfor (indexval=0; indexval<3; indexval++)\n\t{\n\t\tif (is_triplex_node == true)\n\t\t{\n\t\t\tphase_mask = 0x80;\n\t\t}\n\t\telse\t//three-phase, of some sort\n\t\t{\n\t\t\t//Get the mask\n\t\t\tphase_mask = (1 << (2 - indexval));\n\t\t}\n\n\t\t//Check the phase\n\t\tif ((phase_conf & phase_mask) == phase_mask)\n\t\t{\n\t\t\t//See what our reference is - steal parent voltages\n\t\t\tif ((SubNode!=CHILD) && (SubNode!=DIFF_CHILD))\n\t\t\t{\n\t\t\t\tif (is_triplex_node == true)\n\t\t\t\t{\n\t\t\t\t\tif (indexval < 2)\n\t\t\t\t\t{\n\t\t\t\t\t\tcurr_freq_state.voltage_val[indexval]=NR_busdata[NR_node_reference].V[indexval];\n\t\t\t\t\t}\n\t\t\t\t\telse\t//Must be 2\n\t\t\t\t\t{\n\t\t\t\t\t\tcurr_freq_state.voltage_val[indexval]=NR_busdata[NR_node_reference].V[0] + NR_busdata[NR_node_reference].V[1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcurr_freq_state.voltage_val[indexval]=NR_busdata[NR_node_reference].V[indexval];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\t//It is a child - look at parent\n\t\t\t{\n\t\t\t\tif (is_triplex_node == true)\n\t\t\t\t{\n\t\t\t\t\tif (indexval < 2)\n\t\t\t\t\t{\n\t\t\t\t\t\tcurr_freq_state.voltage_val[indexval]=NR_busdata[*NR_subnode_reference].V[indexval];\n\t\t\t\t\t}\n\t\t\t\t\telse\t//Must be 2\n\t\t\t\t\t{\n\t\t\t\t\t\tcurr_freq_state.voltage_val[indexval]=NR_busdata[*NR_subnode_reference].V[0] + NR_busdata[*NR_subnode_reference].V[1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcurr_freq_state.voltage_val[indexval]=NR_busdata[*NR_subnode_reference].V[indexval];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//See if we're the first start or not\n\t\t\tif (first_freq_init == true)\n\t\t\t{\n\t\t\t\t//Assume \"current\" start\n\t\t\t\tcurr_freq_state.fmeas[indexval] = current_frequency;\n\t\t\t\tprev_freq_state.fmeas[indexval] = current_frequency;\n\t\t\t}\n\t\t\t//Default else, just leave what was already in our accumulator\n\n\t\t\t//Assume the frequency was at least \"stable\" prior to entering - adjust prior value to reflect this\n\t\t\t//Compute the frequency deviation\n\t\t\tfrequency_offset_val = (curr_freq_state.fmeas[indexval] * 2.0 * PI - freq_omega_ref);\n\n\t\t\t//Calculate the associated angle offset - negative, for past\n\t\t\tangle_offset = -1.0 * frequency_offset_val * deltat;\n\t\t\t\n\t\t\t//Translate it into a multiplier\n\t\t\t//exp(jx) = cos(x)+j*sin(x)\n\t\t\tangle_rotate_value = complex(cos(angle_offset),sin(angle_offset));\n\n\t\t\t//Adjust the previous voltage value by this\n\t\t\tprev_freq_state.voltage_val[indexval] = curr_freq_state.voltage_val[indexval] * angle_rotate_value;\n\n\t\t\t//Populate the angle - use ATAN2, since it divides better than the complex-oriented .Arg function\n\t\t\tcurr_freq_state.anglemeas[indexval] = atan2(curr_freq_state.voltage_val[indexval].Im(),curr_freq_state.voltage_val[indexval].Re());\n\t\t\tprev_freq_state.anglemeas[indexval] = atan2(prev_freq_state.voltage_val[indexval].Im(),prev_freq_state.voltage_val[indexval].Re());\n\n\t\t\t//Populate other fields, if necessary\n\t\t\tif (fmeas_type == FM_PLL)\n\t\t\t{\n\t\t\t\t//Initialize other relevant variables\n\t\t\t\tcurr_freq_state.x[indexval] = frequency_offset_val;\n\t\t\t\tprev_freq_state.x[indexval] = frequency_offset_val;\n\n\t\t\t\t//Current values of angles\n\t\t\t\tcurr_freq_state.sinangmeas[indexval] = sin(curr_freq_state.anglemeas[indexval]);\n\t\t\t\tcurr_freq_state.cosangmeas[indexval] = cos(curr_freq_state.anglemeas[indexval]);\n\n\t\t\t\t//Previous values, just because\n\t\t\t\tprev_freq_state.sinangmeas[indexval] = sin(prev_freq_state.anglemeas[indexval]);\n\t\t\t\tprev_freq_state.cosangmeas[indexval] = cos(prev_freq_state.anglemeas[indexval]);\n\t\t\t}\n\t\t}//End valid phase\n\t\telse\t//Not a valid phase, just zero it all\n\t\t{\n\t\t\tcurr_freq_state.voltage_val[indexval] = complex(0.0,0.0);\n\t\t\tcurr_freq_state.x[indexval] = 0.0;\n\t\t\tcurr_freq_state.anglemeas[indexval] = 0.0;\n\t\t\tcurr_freq_state.fmeas[indexval] = 0.0;\n\t\t\tcurr_freq_state.average_freq = current_frequency;\n\t\t\tcurr_freq_state.sinangmeas[indexval] = 0.0;\n\t\t\tcurr_freq_state.cosangmeas[indexval] = 0.0;\n\n\t\t\t//DO the same for previous state, out of paranoia\n\t\t\tprev_freq_state.voltage_val[indexval] = complex(0.0,0.0);\n\t\t\tprev_freq_state.x[indexval] = 0.0;\n\t\t\tprev_freq_state.anglemeas[indexval] = 0.0;\n\t\t\tprev_freq_state.fmeas[indexval] = 0.0;\n\t\t\tprev_freq_state.average_freq = current_frequency;\n\t\t\tprev_freq_state.sinangmeas[indexval] = 0.0;\n\t\t\tprev_freq_state.cosangmeas[indexval] = 0.0;\n\t\t}\n\t}//End FOR loop\n\n\t//Final check for \"first run\" to deflag us and to update angle calculation\n\tif (first_freq_init == true)\n\t{\n\t\tfirst_freq_init = false;\n\t}\n}\n\n//Function to perform the GFA-type responses\ndouble node::perform_GFA_checks(double timestepvalue)\n{\n\tbool voltage_violation, frequency_violation, trigger_disconnect, check_phase;\n\tdouble temp_pu_voltage;\n\tdouble return_time_freq, return_time_volt, return_value;\n\tchar indexval;\n\tunsigned char phasevals;\n\tOBJECT *hdr = OBJECTHDR(this);\n\n\t//By default, we're subject to the whims of deltamode\n\treturn_time_freq = -1.0;\n\treturn_time_volt = -1.0;\n\treturn_value = -1.0;\n\n\t//Pull our phasing information\n\tif ((SubNode!=CHILD) && (SubNode!=DIFF_CHILD))\n\t{\n\t\tphasevals = NR_busdata[NR_node_reference].phases & 0x87;\n\t}\n\telse\t//Must be a child, pull from our parent\n\t{\n\t\tphasevals = NR_busdata[*NR_subnode_reference].phases & 0x87;\n\t}\n\n\t//Perform frequency check\n\tif ((curr_freq_state.average_freq > GFA_freq_high_trip) || (curr_freq_state.average_freq < GFA_freq_low_trip))\n\t{\n\t\t//Flag it\n\t\tfrequency_violation = true;\n\n\t\t//Increment \"outage trigger\" timer\n\t\tfreq_violation_time_total += timestepvalue;\n\n\t\t//Reset \"restoration\" time\n\t\tout_of_violation_time_total = 0.0;\n\n\t\t//Check the times - split out\n\t\tif (curr_freq_state.average_freq > GFA_freq_high_trip)\n\t\t{\n\t\t\tif (freq_violation_time_total > GFA_freq_disconnect_time)\n\t\t\t{\n\t\t\t\ttrigger_disconnect = true;\n\t\t\t\treturn_time_freq = GFA_reconnect_time;\n\n\t\t\t\t//Flag us as over frequency\n\t\t\t\tGFA_trip_method = GFA_OF;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttrigger_disconnect = false;\n\t\t\t\treturn_time_freq = GFA_freq_disconnect_time - freq_violation_time_total;\n\t\t\t}\n\t\t}\n\t\telse if (curr_freq_state.average_freq < GFA_freq_low_trip)\n\t\t{\n\t\t\tif (freq_violation_time_total > GFA_freq_disconnect_time)\n\t\t\t{\n\t\t\t\ttrigger_disconnect = true;\n\t\t\t\treturn_time_freq = GFA_reconnect_time;\n\n\t\t\t\t//Flag as under-frequency\n\t\t\t\tGFA_trip_method = GFA_UF;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttrigger_disconnect = false;\n\t\t\t\treturn_time_freq = GFA_freq_disconnect_time - freq_violation_time_total;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tgl_error(\"Node%d %s GFA checks failed- invalid state!\",hdr->id,hdr->name ? hdr->name : \"Unnamed\");\n\t\t\t/*  TROUBLESHOOT\n\t\t\tWhile performing the GFA update on the node, it entered an unknown state.  Please try again.\n\t\t\tIf the error persists, please submit your code and a bug report via the ticketing system.\n\t\t\t*/\n\t\t}\n\t}\n\telse\t//Must be in a good range\n\t{\n\t\t//Set flags to indicate as much\n\t\tfrequency_violation = false;\n\t\ttrigger_disconnect = false;\n\n\t\t//Zero the frequency violation indicator\n\t\tfreq_violation_time_total = 0.0;\n\n\t\t//Flag the return, just to be safe\n\t\treturn_time_freq = -1.0;\n\t}\n\n\t//Default to no voltage violation\n\tvoltage_violation = false;\n\n\t//See if we're already triggered or in a frequency violation (no point checking, if we are)\n\t//Loop through voltages present & check - if we find one, we'll break out\n\tfor (indexval = 0; indexval < 3; indexval++)\n\t{\n\t\t//See if this phase exists\n\t\tif ((phasevals & 0x80) == 0x80)\t//Triplex check first\n\t\t{\n\t\t\t//Make sure we're one of the first two\n\t\t\tif (indexval < 2)\n\t\t\t{\n\t\t\t\tcheck_phase = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcheck_phase = false;\n\t\t\t}\n\t\t}//end triplex\n\t\telse if ((indexval == 0) && ((phasevals & 0x04) == 0x04))\t//A\n\t\t{\n\t\t\tcheck_phase = true;\n\t\t}\n\t\telse if ((indexval == 1) && ((phasevals & 0x02) == 0x02))\t//B\n\t\t{\n\t\t\tcheck_phase = true;\n\t\t}\n\t\telse if ((indexval == 2) && ((phasevals & 0x01) == 0x01))\t//C\n\t\t{\n\t\t\tcheck_phase = true;\n\t\t}\n\t\telse\t//Not a proper combination\n\t\t{\n\t\t\tcheck_phase = false;\n\t\t}\n\n\t\t//See if we were valid\n\t\tif (check_phase == true)\n\t\t{\n\t\t\t//See if it is a violation\n\t\t\ttemp_pu_voltage = voltage[indexval].Mag()/nominal_voltage;\n\n\t\t\t//Check it\n\t\t\tif ((temp_pu_voltage < GFA_voltage_low_trip) || (temp_pu_voltage > GFA_voltage_high_trip))\n\t\t\t{\n\t\t\t\t//flag a violation\n\t\t\t\tvoltage_violation = true;\n\n\t\t\t\t//Accumulate the time\n\t\t\t\tvolt_violation_time_total += timestepvalue;\n\n\t\t\t\t//Clear the \"no violation timer\"\n\t\t\t\tout_of_violation_time_total = 0.0;\n\n\t\t\t\t//See which case we are\n\t\t\t\tif (temp_pu_voltage < GFA_voltage_low_trip)\n\t\t\t\t{\n\t\t\t\t\tif (volt_violation_time_total > GFA_volt_disconnect_time)\n\t\t\t\t\t{\n\t\t\t\t\t\ttrigger_disconnect = true;\n\t\t\t\t\t\treturn_time_volt = GFA_reconnect_time;\n\n\t\t\t\t\t\t//Flag us as under-voltage\n\t\t\t\t\t\tGFA_trip_method = GFA_UV;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ttrigger_disconnect = false;\n\t\t\t\t\t\treturn_time_volt = GFA_volt_disconnect_time - volt_violation_time_total;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (temp_pu_voltage >= GFA_voltage_high_trip)\n\t\t\t\t{\n\t\t\t\t\tif (volt_violation_time_total > GFA_volt_disconnect_time)\n\t\t\t\t\t{\n\t\t\t\t\t\ttrigger_disconnect = true;\n\t\t\t\t\t\treturn_time_volt = GFA_reconnect_time;\n\n\t\t\t\t\t\t//Flag us as over-voltage\n\t\t\t\t\t\tGFA_trip_method = GFA_OV;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ttrigger_disconnect = false;\n\t\t\t\t\t\treturn_time_volt = GFA_volt_disconnect_time - volt_violation_time_total;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\t//must not have tripped a time limit\n\t\t\t\t{\n\t\t\t\t\tgl_error(\"Node%d %s GFA checks failed- invalid state!\",hdr->id,hdr->name ? hdr->name : \"Unnamed\");\n\t\t\t\t\t//Defined above\n\t\t\t\t}\n\n\t\t\t\t//At least one violation condition was met, break us out of the for\n\t\t\t\tbreak;\n\t\t\t}//End of a violation occurred\n\t\t\t//Default else, normal operating range - loop\n\t\t}//End was a valid phase\n\t\t//Default else - go to next phase\n\t}//End phase loop\n\n\t//See if we detected a voltage violation - if not, reset the counter\n\tif (voltage_violation == false)\n\t{\n\t\tvolt_violation_time_total = 0.0;\n\t\treturn_time_volt = -1.0;\t//Set it again, for paranoia\n\t}\n\n\t//COmpute the \"next expected update\"\n\tif ((return_time_volt > 0.0) && (return_time_freq > 0.0))\t//Both counting - take the minimum\n\t{\n\t\t//Find the minimum\n\t\tif (return_time_volt < return_time_freq)\n\t\t{\n\t\t\treturn_value = return_time_volt;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn_value = return_time_freq;\n\t\t}\n\t}\n\telse if ((return_time_volt > 0.0) && (return_time_freq < 0.0))\t//Voltage event\n\t{\n\t\treturn_value = return_time_volt;\n\t}\n\telse if ((return_time_volt < 0.0) && (return_time_freq > 0.0)) //Frequency event\n\t{\n\t\treturn_value = return_time_freq;\n\t}\n\telse\t//Nothing pending\n\t{\n\t\treturn_value = -1.0;\n\t}\n\n\t//Check voltage values first\n\tif ((frequency_violation == true) || (voltage_violation == true))\n\t{\n\t\t//Reset the out of violation time\n\t\tout_of_violation_time_total = 0.0;\n\t}\n\telse\t//No failures, reset and increment\n\t{\n\t\t//Increment the \"restoration\" one, just in case\n\t\tout_of_violation_time_total += timestepvalue;\n\t}\n\n\t//See what we are - if we're out of service, see if we can be restored\n\tif (GFA_status == false)\n\t{\n\t\tif (out_of_violation_time_total >= GFA_reconnect_time)\n\t\t{\n\t\t\t//Set us back into service\n\t\t\tGFA_status = true;\n\n\t\t\t//Reset us back to no violation\n\t\t\tGFA_trip_method = GFA_NONE;\n\n\t\t\t//Implies no violations, so force return a -1.0\n\t\t\treturn -1.0;\n\t\t}\n\t\telse\t//Still delayed, just reaffirm our status\n\t\t{\n\t\t\tGFA_status = false;\n\n\t\t\t//Calculate the new return time\n\t\t\treturn_value = GFA_reconnect_time - out_of_violation_time_total;\n\n\t\t\t//Return the minimum from above\n\t\t\treturn return_value;\n\t\t}\n\t}\n\telse\t//We're true, see if we need to not be\n\t{\n\t\tif (trigger_disconnect == true)\n\t\t{\n\t\t\tGFA_status = false;\t//Trigger\n\n\t\t\t//Return our expected next status interval\n\t\t\treturn return_value;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//Re-affirm we are not having any issues\n\t\t\tGFA_trip_method = GFA_NONE;\n\n\t\t\t//All is well, indicate as much\n\t\t\treturn return_value;\n\t\t}\n\t}\n}\n\n//Function to set a node's SWING status mid-simulation, without the SWING_PQ functionality\nSTATUS node::NR_swap_swing_status(bool desired_status)\n{\n\tOBJECT *hdr = OBJECTHDR(this);\n\n\t//See if we're a child or not\n\tif ((SubNode!=CHILD) && (SubNode!=DIFF_CHILD))\n\t{\n\t\t//Make sure we're a SWING or SWING_PQ first\n\t\tif (NR_busdata[NR_node_reference].type > 1)\n\t\t{\n\t\t\t//Just set us to our status -- it is assumed that if you did this, you know what you are doing\n\t\t\tNR_busdata[NR_node_reference].swing_functions_enabled = desired_status;\n\t\t}\n\t\telse\t//Indicate we're not one\n\t\t{\n\t\t\t//Put as a verbose, since mostly just useful for debugging\n\t\t\tgl_verbose(\"node:%s - Not a SWING-capable bus, so no swing status swap changed\",(hdr->name ? hdr->name : \"unnamed\"));\n\t\t\t/*  TROUBLESHOOT\n\t\t\tWhile attempting to swap a node from being a \"swing node\", it was tried on a node that was not already a SWING or SWING_PQ\n\t\t\tnode, which is not a valid attempt.\n\t\t\t*/\n\t\t}\n\t}\n\telse\t//It is a child - look at parent\n\t{\n\t\t//Make sure we're a SWING or SWING_PQ first\n\t\tif (NR_busdata[*NR_subnode_reference].type > 1)\n\t\t{\n\t\t\t//Just set us to our status -- it is assumed that if you did this, you know what you are doing\n\t\t\tNR_busdata[*NR_subnode_reference].swing_functions_enabled = desired_status;\n\t\t}\n\t\telse\t//Indicate we're not one\n\t\t{\n\t\t\tgl_verbose(\"node:%s - Not a SWING-capable bus, so no swing status swap changed\",(hdr->name ? hdr->name : \"unnamed\"));\n\t\t\t//Defined above\n\t\t}\n\t}\n\n\t//Always a success, we think\n\treturn SUCCESS;\n}\n\n//Function to check if a node object is \"behaving in a SWING manner\"\nvoid node::NR_swing_status_check(bool *swing_status_check_value, bool *swing_pq_status_value)\n{\n\t//By default, assume we aren't a SWING\n\t*swing_status_check_value = false;\n\n\t//See if we're a child or not\n\tif ((SubNode!=CHILD) && (SubNode!=DIFF_CHILD))\n\t{\n\t\t//Make sure we're a SWING or SWING_PQ first\n\t\tif (NR_busdata[NR_node_reference].type > 1)\n\t\t{\n\t\t\t//Pull it out of our NR structure\n\t\t\t*swing_status_check_value = NR_busdata[NR_node_reference].swing_functions_enabled;\n\n\t\t\t//See if we are a SWING_PQ, then copy that flag\n\t\t\tif (NR_busdata[NR_node_reference].type == 3)\n\t\t\t{\n\t\t\t\t*swing_pq_status_value = NR_busdata[NR_node_reference].swing_topology_entry;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//Swing and \"normal bus\" just get set to false - not needed\n\t\t\t\t*swing_pq_status_value = false;\n\t\t\t}\n\t\t}\n\t\t//Default else - we're a PQ, and by definition, not a SWING\n\t}\n\telse\t//It is a child - look at parent\n\t{\n\t\t//Make sure we're a SWING or SWING_PQ first\n\t\tif (NR_busdata[*NR_subnode_reference].type > 1)\n\t\t{\n\t\t\t//Pull the value out\n\t\t\t*swing_status_check_value = NR_busdata[*NR_subnode_reference].swing_functions_enabled;\n\n\t\t\t//See if we are a SWING_PQ, then copy that flag\n\t\t\tif (NR_busdata[*NR_subnode_reference].type == 3)\n\t\t\t{\n\t\t\t\t*swing_pq_status_value = NR_busdata[*NR_subnode_reference].swing_topology_entry;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//Swing and \"normal bus\" just get set to false - not needed\n\t\t\t\t*swing_pq_status_value = false;\n\t\t\t}\n\t\t}\n\t\t//Default else - we're a PQ and not a SWING of any type\n\t}\n}\n\n//Function to reset the \"disabled state\" of the node, if called (re-enable an island, basically)\nSTATUS node::reset_node_island_condition(void)\n{\n\tOBJECT *obj = OBJECTHDR(this);\n\tSTATUS temp_status;\n\tFUNCTIONADDR temp_fxn_val;\n\tint node_calling_reference;\n\n\t//Deflag the overall variable, just in case\n\treset_island_state = false;\n\n\t//Check and see if this was even something we wanted to do\n\tif ((SubNode != CHILD) && (SubNode!=DIFF_CHILD))\n\t{\n\t\t//Check our status\n\t\tif (NR_busdata[NR_node_reference].island_number != -1)\n\t\t{\n\t\t\tgl_warning(\"node:%d - %s - Tried to re-enable a node that wasn't disabled!\",obj->id,(obj->name ? obj->name : \"Unnamed\"));\n\t\t\t/*  TROUBLESHOOT\n\t\t\tWhile attempting to reset a node from a \"disabled island\" state, it was not already disabled.  Therefore, no action occurred.\n\t\t\t*/\n\n\t\t\t//Return a \"failure\" - just in case\n\t\t\treturn FAILED;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//Reset our phases (assume full-on reset)\n\t\t\tNR_busdata[NR_node_reference].phases = NR_busdata[NR_node_reference].origphases;\n\t\t}\n\t}\n\telse\t//We're a child, see if our parent is appropriately disabled\n\t{\n\t\tif (NR_busdata[*NR_subnode_reference].island_number != -1)\n\t\t{\n\t\t\tgl_warning(\"node:%d - %s - Tried to re-enable a node that wasn't disabled!\",obj->id,(obj->name ? obj->name : \"Unnamed\"));\n\t\t\t//Defined above\n\n\t\t\t//Return the failure\n\t\t\treturn FAILED;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//Reset our parent's phases\n\t\t\tNR_busdata[*NR_subnode_reference].phases = NR_busdata[*NR_subnode_reference].origphases;\n\t\t}\n\t}\n\n\t//If we made it this far, we've been \"re-validated\" - call the reset function\n\t//Make sure it will even remotely work first\n\tif (fault_check_object == NULL)\t//Make sure we actually have a fault check object\n\t{\n\t\t//Hard throw this one -- this can't be ignored\n\t\tGL_THROW(\"node:%d - %s -- Island condition reset failed - no fault_check object mapped!\",obj->id,(obj->name ? obj->name : \"Unnamed\"));\n\t\t/*  TROUBLESHOOT\n\t\tA node attempted to reset its \"disabled from powerflow/islands\" status, but there is no fault_check object in the system.  It's unclear\n\t\thow this call was made.  Please check your system and try again.  If this message was encountered in error, please submit your code, models, and\n\t\ta bug report via the issue tracker system.\n\t\t*/\n\t}\n\n\t//Map the function\n\ttemp_fxn_val = (FUNCTIONADDR)(gl_get_function(fault_check_object,\"rescan_topology\"));\n\n\t//Make sure it worked\n\tif (temp_fxn_val == NULL)\n\t{\n\t\t//Another hard failure\n\t\tGL_THROW(\"node:%d - %s -- Island condition reset failed - reset function mapping failed!\",obj->id,(obj->name ? obj->name : \"Unnamed\"));\n\t\t/*  TROUBLESHOOT\n\t\tWhile attempting to call the topology rescan functionality, an error occurred.  Please check your model and try again.  If the error persists,\n\t\tplease submit your code, models, and a bug report via the issue tracking system.\n\t\t*/\n\t}\n\n\t//Set it up as a \"SWING-related call\" - basically start over\n\tnode_calling_reference = -99;\n\n\t//Then call the reset\n\ttemp_status = ((STATUS (*)(OBJECT *,int))(temp_fxn_val))(fault_check_object,node_calling_reference);\n\t\n\t//Just pass its result\n\treturn temp_status;\n}\n\n//Function to perform a mapping of the \"internal iteration\" current injection update\n//Primarily used for deltamode and voltage-source inverters, but could be used in other places\nSTATUS node::NR_map_current_update_function(OBJECT *callObj)\n{\n\tOBJECT *hdr = OBJECTHDR(this);\n\tOBJECT *phdr = NULL;\n\n\t//Do a simple check -- if we're not in NR, this won't do anything anyways\n\tif (solver_method == SM_NR)\n\t{\n\t\t//See if we're a pesky child\n\t\tif ((SubNode!=CHILD) && (SubNode!=DIFF_CHILD))\n\t\t{\n\t\t\t//Make sure no one has mapped us yet\n\t\t\tif (NR_busdata[NR_node_reference].ExtraCurrentInjFunc == NULL)\n\t\t\t{\n\t\t\t\t//Map the function\n\t\t\t\tNR_busdata[NR_node_reference].ExtraCurrentInjFunc = (FUNCTIONADDR)(gl_get_function(callObj,\"current_injection_update\"));\n\n\t\t\t\t//Make sure it worked\n\t\t\t\tif (NR_busdata[NR_node_reference].ExtraCurrentInjFunc == NULL)\n\t\t\t\t{\n\t\t\t\t\tgl_error(\"node:%d - %s - Failed to map current_injection_update from calling object:%d - %s\",hdr->id,(hdr->name ? hdr->name : \"Unnamed\"),callObj->id,(callObj->name ? callObj->name : \"Unnamed\"));\n\t\t\t\t\t/*  TROUBLESHOOT\n\t\t\t\t\tThe attached node was unable to find the exposed function \"current_injection_update\" on the calling object.  Be sure\n\t\t\t\t\tit supports this functionality and try again.\n\t\t\t\t\t*/\n\n\t\t\t\t\treturn FAILED;\n\t\t\t\t}\n\t\t\t\t//Default else -- it worked\n\n\t\t\t\t//Store the object pointer too\n\t\t\t\tNR_busdata[NR_node_reference].ExtraCurrentInjFuncObject = callObj;\n\t\t\t}\n\t\t\telse\t//Already mapped\n\t\t\t{\n\t\t\t\tgl_error(\"node:%d - %s - Already has an extra current injection function mapped\",hdr->id,(hdr->name ? hdr->name : \"Unnamed\"));\n\t\t\t\t/*  TROUBLESHOOT\n\t\t\t\tAn object attempted to map a current injection update function, but that node already has such a function mapped.  Only one\n\t\t\t\tis allowed per node.  Note this includes any attachments to child nodes, since those end up on the parent object.\n\t\t\t\t*/\n\n\t\t\t\treturn FAILED;\n\t\t\t}//End already mapped\n\t\t}\n\t\telse\t//Child - push this to the parent\n\t\t{\n\t\t\t//Map the parent - mostly just so we have a shorter variable name\n\t\t\tphdr = NR_busdata[*NR_subnode_reference].obj;\n\n\t\t\t//Make sure no one has mapped us yet\n\t\t\tif (NR_busdata[*NR_subnode_reference].ExtraCurrentInjFunc == NULL)\n\t\t\t{\n\t\t\t\t//Map the function\n\t\t\t\tNR_busdata[*NR_subnode_reference].ExtraCurrentInjFunc = (FUNCTIONADDR)(gl_get_function(callObj,\"current_injection_update\"));\n\n\t\t\t\t//Make sure it worked\n\t\t\t\tif (NR_busdata[*NR_subnode_reference].ExtraCurrentInjFunc == NULL)\n\t\t\t\t{\n\t\t\t\t\tgl_error(\"node:%d - %s - Failed to map current_injection_update from calling object:%d - %s\",hdr->id,(hdr->name ? hdr->name : \"Unnamed\"),callObj->id,(callObj->name ? callObj->name : \"Unnamed\"));\n\t\t\t\t\t//Defined above\n\n\t\t\t\t\treturn FAILED;\n\t\t\t\t}\n\t\t\t\t//Default else -- it worked\n\n\t\t\t\t//Store the object pointer too\n\t\t\t\tNR_busdata[*NR_subnode_reference].ExtraCurrentInjFuncObject = callObj;\n\t\t\t}\n\t\t\telse\t//Already mapped\n\t\t\t{\n\t\t\t\tgl_error(\"node:%d - %s - Parent node:%d - %s - Already has an extra current injection function mapped\",hdr->id,(hdr->name ? hdr->name : \"Unnamed\"),phdr->id,(phdr->name ? phdr->name : \"Unnamed\"));\n\t\t\t\t/*  TROUBLESHOOT\n\t\t\t\tAn object attempted to map a current injection update function to its parent, but that node already has such a function mapped.  Only one\n\t\t\t\tis allowed per node.  Note this includes any attachments to child nodes, since those end up on the parent object.\n\t\t\t\t*/\n\n\t\t\t\treturn FAILED;\n\t\t\t}//End already mapped\n\t\t}\n\t}\n\telse\t//Other method\n\t{\n\t\tgl_warning(\"node:%d - %s - Attempted to map an NR-based function, but is not using an NR solver\",hdr->id,(hdr->name ? hdr->name : \"Unnamed\"));\n\t\t/*  TROUBLESHOOT\n\t\tAn object just attempted to map a current injection update function that only works with the Newton-Raphson solver, but that\n\t\tmethod is not being used.\n\t\t*/\n\n\t\t//Succeed, mostly because it just won't do anything\n\t\treturn SUCCESS;\n\t}\n\n\t//Theoretically only get here if we succeed a map\n\treturn SUCCESS;\n}\n\n//VFD linking/mapping function\nSTATUS node::link_VFD_functions(OBJECT *linkVFD)\n{\n\tOBJECT *obj = OBJECTHDR(this);\n\n\t//Set the VFD object\n\tVFD_object = linkVFD;\n\n\t//Try mapping the VFD current injection function\n\tVFD_updating_function = (FUNCTIONADDR)(gl_get_function(linkVFD,\"vfd_current_injection_update\"));\n\n\t//Make sure it worked\n\tif (VFD_updating_function == NULL)\n\t{\n\t\tgl_warning(\"Failure to map VFD current injection update for device:%s\",(obj->name ? obj->name : \"Unnamed\"));\n\t\t/*  TROUBLESHOOT\n\t\tAttempts to map a function for the proper VFD updates did not work.  Please try again, making sure\n\t\tthis node is connected to a VFD properly.  If the error persists, please submit an issue ticket.\n\t\t*/\n\n\t\t//Fail us\n\t\treturn FAILED;\n\t}\n\n\t//Flag us as successful\n\tVFD_attached = true;\n\n\t//Always succeed, if we made it this far\n\treturn SUCCESS;\n}\n\n//Function to compute the difference between two angles\n//Note that the inputs are in radians\n//Mainly used by frequency calculations\n//Effectively the code from https://stackoverflow.com/questions/11498169/dealing-with-angle-wrap-in-c-code\n//Should do \"B-A\"\ndouble node::compute_angle_diff(double angle_B, double angle_A)\n{\n\tdouble diff_val, two_PI;\n\n\t//Constant - save a multiply\n\ttwo_PI = 2.0 * PI;\n\n\t//Compute the raw difference\n\tdiff_val = fmod((angle_B - angle_A + PI), two_PI);\n   \n   //See if we need to wrap it around\n   if (diff_val < 0.0)\n   {\n\t   diff_val += two_PI;\n   }\n\n   //Return the result, with the offset removed\n   return (diff_val - PI);\n}\n\n//////////////////////////////////////////////////////////////////////////\n// IMPLEMENTATION OF OTHER EXPORT FUNCTIONS\n//////////////////////////////////////////////////////////////////////////\nEXPORT int isa_node(OBJECT *obj, char *classname)\n{\n\tif(obj != 0 && classname != 0){\n\t\treturn OBJECTDATA(obj,node)->isa(classname);\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nEXPORT int notify_node(OBJECT *obj, int update_mode, PROPERTY *prop, char *value){\n\tnode *n = OBJECTDATA(obj, node);\n\tint rv = 1;\n\t\n\trv = n->notify(update_mode, prop, value);\n\t\n\treturn rv;\n}\n\n//Exported function for attaching this to a VFD - basically sets a flag and maps a function\nEXPORT STATUS attach_vfd_to_node(OBJECT *obj,OBJECT *calledVFD)\n{\n\tnode *nodeObj = OBJECTDATA(obj,node);\n\n\t//Call the function\n\treturn nodeObj->link_VFD_functions(calledVFD);\n}\n\n//Deltamode export\nEXPORT SIMULATIONMODE interupdate_node(OBJECT *obj, unsigned int64 delta_time, unsigned long dt, unsigned int iteration_count_val, bool interupdate_pos)\n{\n\tnode *my = OBJECTDATA(obj,node);\n\tSIMULATIONMODE status = SM_ERROR;\n\ttry\n\t{\n\t\tstatus = my->inter_deltaupdate_node(delta_time,dt,iteration_count_val,interupdate_pos);\n\t\treturn status;\n\t}\n\tcatch (char *msg)\n\t{\n\t\tgl_error(\"interupdate_node(obj=%d;%s): %s\", obj->id, obj->name?obj->name:\"unnamed\", msg);\n\t\treturn status;\n\t}\n}\n\n//Function to set a node as a SWING inside NR - basically converts a SWING to a PQ, without the SWING_PQ requirement\nEXPORT STATUS swap_node_swing_status(OBJECT *obj, bool desired_status)\n{\n\tSTATUS temp_status;\n\n\t//Map the node\n\tnode *my = OBJECTDATA(obj,node);\n\n\t//Call the function, where we can see our internals\n\ttemp_status = my->NR_swap_swing_status(desired_status);\n\n\t//Return what the sub function said we were\n\treturn temp_status;\n}\n\n//Function to query a current node's status as a SWING node -- basically lets generators see how \"swing_functions_enabled\" is behaving\nEXPORT STATUS node_swing_status(OBJECT *this_obj, bool *swing_status_check_value, bool *swing_pq_status_value)\n{\n\t//Map ourselves\n\tnode *my = OBJECTDATA(this_obj,node);\n\n\t//Run the query\n\tmy->NR_swing_status_check(swing_status_check_value,swing_pq_status_value);\n\n\t//Return success, because reasons\n\treturn SUCCESS;\n}\n\n//Exposed function to map a \"current injection update\" routine from another object\n//Used primarily for deltamode and voltage-source inverters right now\nEXPORT STATUS node_map_current_update_function(OBJECT *nodeObj, OBJECT *callObj)\n{\n\tSTATUS temp_status;\n\n\t//Map the node\n\tnode *my = OBJECTDATA(nodeObj,node);\n\n\t//Call the mapping function\n\ttemp_status = my->NR_map_current_update_function(callObj);\n\n\t//Return the value\n\treturn temp_status;\n}\n\n//Exposed function to reset the \"disabled island\" state of this node\nEXPORT STATUS node_reset_disabled_status(OBJECT *nodeObj)\n{\n\tSTATUS temp_status;\n\n\t//Map the node\n\tnode *my = OBJECTDATA(nodeObj,node);\n\n\t//Call our local function\n\ttemp_status = my->reset_node_island_condition();\n\n\t//Return\n\treturn temp_status;\n}\n/**@}*/\n",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/tape/tape.c": "/** $Id: tape.c 1182 2008-12-22 22:08:36Z dchassin $\n\tCopyright (C) 2008 Battelle Memorial Institute\n\t@file tape.c\n\t@addtogroup tapes Players and recorders (tape)\n\t@ingroup modules\n\n\tTape players and recorders are used to manage the boundary conditions\n\tand record properties of objects during simulation.  There are two kinds\n\tof players and two kinds of recorders:\n\t- \\p player is used to play a recording of a single value to property of an object\n\t- \\p shaper is used to play a periodic scaled shape to a property of groups of objects\n\t- \\p recorder is used to collect a recording of one of more properties of an object\n\t- \\p collector is used to collect an aggregation of a property from a group of objects\n @{\n **/\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <ctype.h>\n#include \"gridlabd.h\"\n#include \"object.h\"\n#include \"aggregate.h\"\n#include \"histogram.h\"\n#include \"group_recorder.h\"\n\n#define _TAPE_C\n\n#include \"tape.h\"\n#include \"file.h\"\n#include \"odbc.h\"\n\n#define MAP_DOUBLE(X,LO,HI) {#X,VT_DOUBLE,&X,LO,HI}\n#define MAP_INTEGER(X,LO,HI) {#X,VT_INTEGER,&X,LO,HI}\n#define MAP_STRING(X) {#X,VT_STRING,X,sizeof(X),0}\n#define MAP_END {NULL}\n\nVARMAP varmap[] = {\n\t/* add module variables you want to be available using module_setvar in core */\n\tMAP_STRING(timestamp_format),\n\tMAP_END\n};\n\nextern CLASS *player_class;\nextern CLASS *shaper_class;\nextern CLASS *recorder_class;\nextern CLASS *multi_recorder_class;\nextern CLASS *collector_class;\n\n/* delta mode control */\nTIMESTAMP delta_mode_needed = TS_NEVER; /* the time at which delta mode needs to start */\n\n#ifdef _WIN32\n#define WIN32_LEAN_AND_MEAN\t\t// Exclude rarely-used stuff from Windows headers\n#define _WIN32_WINNT 0x0400\n#include <windows.h>\n#ifndef DLEXT\n#define DLEXT \".dll\"\n#endif\n#define DLLOAD(P) LoadLibrary(P)\n#define DLSYM(H,S) GetProcAddress((HINSTANCE)H,S)\n#define snprintf _snprintf\n#else /* ANSI */\n#include \"dlfcn.h\"\n#ifndef DLEXT\n#define DLEXT \".so\"\n#else\n#endif\n#define DLLOAD(P) dlopen(P,RTLD_LAZY)\n#define DLSYM(H,S) dlsym(H,S)\n#endif\n\nstatic TAPEFUNCS *funcs = NULL;\nstatic char1024 tape_gnuplot_path;\nint32 flush_interval = 0;\nint csv_data_only = 0; /* enable this option to suppress addition of lines starting with # in CSV */\nint csv_keep_clean = 0; /* enable this option to keep data flushed at end of line */\nvoid (*update_csv_data_only)(void)=NULL;\nvoid (*update_csv_keep_clean)(void)=NULL;\n\nvoid set_csv_options(void)\n{\n\tif (csv_data_only && update_csv_data_only)\n\t\t(*update_csv_data_only)();\n\tif (csv_keep_clean && update_csv_keep_clean)\n\t\t(*update_csv_keep_clean)();\n}\n\ntypedef int (*OPENFUNC)(void *, char *, char *);\ntypedef char *(*READFUNC)(void *, char *, unsigned int);\ntypedef int (*WRITEFUNC)(void *, char *, char *);\ntypedef int (*REWINDFUNC)(void *);\ntypedef void (*CLOSEFUNC)(void *);\ntypedef void (*VOIDCALL)(void);\ntypedef void (*FLUSHFUNC)(void*);\n\nTAPEFUNCS *get_ftable(char *mode){\n\t/* check what we've already loaded */\n\tchar256 modname;\n\tTAPEFUNCS *fptr = funcs;\n\tTAPEOPS *ops = NULL;\n\tvoid *lib = NULL;\n\tCALLBACKS **c = NULL;\n\tchar tpath[1024];\n\twhile(fptr != NULL){\n\t\tif(strcmp(fptr->mode, mode) == 0)\n\t\t\treturn fptr;\n\t\tfptr = fptr->next;\n\t}\n\t/* fptr = NULL */\n\tfptr = malloc(sizeof(TAPEFUNCS));\n\tif(fptr == NULL)\n\t{\n\t\tgl_error(\"get_ftable(char *mode='%s'): out of memory\", mode);\n\t\treturn NULL; /* out of memory */\n\t}\n\tsnprintf(modname, sizeof(modname), \"tape_%s\" DLEXT, mode);\n\t\n\tif(gl_findfile(modname, NULL, 0|4, tpath,sizeof(tpath)) == NULL){\n\t\tgl_error(\"unable to locate %s\", modname);\n\t\treturn NULL;\n\t}\n\tlib = fptr->hLib = DLLOAD(tpath);\n\tif(fptr->hLib == NULL){\n\t\tgl_error(\"tape module: unable to load DLL for %s\", modname);\n\t\treturn NULL;\n\t}\n\tc = (CALLBACKS **)DLSYM(lib, \"callback\");\n\tif(c)\n\t\t*c = callback;\n\n\t//\tnonfatal ommission\n\tops = fptr->collector = malloc(sizeof(TAPEOPS));\n\tmemset(ops,0,sizeof(TAPEOPS));\n\tops->open = (OPENFUNC)DLSYM(lib, \"open_collector\");\n\tops->read = NULL;\n\tops->write = (WRITEFUNC)DLSYM(lib, \"write_collector\");\n\tops->rewind = NULL;\n\tops->close = (CLOSEFUNC)DLSYM(lib, \"close_collector\");\n\tops->flush = (FLUSHFUNC)DLSYM(lib, \"flush_collector\");\n\n\tops = fptr->player = malloc(sizeof(TAPEOPS));\n\tmemset(ops,0,sizeof(TAPEOPS));\n\tops->open = (OPENFUNC)DLSYM(lib, \"open_player\");\n\tops->read = (READFUNC)DLSYM(lib, \"read_player\");\n\tops->write = NULL;\n\tops->rewind = (REWINDFUNC)DLSYM(lib, \"rewind_player\");\n\tops->close = (CLOSEFUNC)DLSYM(lib, \"close_player\");\n\tops->flush = NULL;\n\n\tops = fptr->recorder = malloc(sizeof(TAPEOPS));\n\tmemset(ops,0,sizeof(TAPEOPS));\n\tops->open = (OPENFUNC)DLSYM(lib, \"open_recorder\");\n\tops->read = NULL;\n\tops->write = (WRITEFUNC)DLSYM(lib, \"write_recorder\");\n\tops->rewind = NULL;\n\tops->close = (CLOSEFUNC)DLSYM(lib, \"close_recorder\");\n\tops->flush = (FLUSHFUNC)DLSYM(lib, \"flush_recorder\");\n\n\tops = fptr->histogram = malloc(sizeof(TAPEOPS));\n\tmemset(ops,0,sizeof(TAPEOPS));\n\tops->open = (OPENFUNC)DLSYM(lib, \"open_histogram\");\n\tops->read = NULL;\n\tops->write = (WRITEFUNC)DLSYM(lib, \"write_histogram\");\n\tops->rewind = NULL;\n\tops->close = (CLOSEFUNC)DLSYM(lib, \"close_histogram\");\n\tops->flush = (FLUSHFUNC)DLSYM(lib, \"flush_histogram\");\n\n\tops = fptr->shaper = malloc(sizeof(TAPEOPS));\n\tmemset(ops,0,sizeof(TAPEOPS));\n\tops->open = (OPENFUNC)DLSYM(lib, \"open_shaper\");\n\tops->read = (READFUNC)DLSYM(lib, \"read_shaper\");\n\tops->write = NULL;\n\tops->rewind = (REWINDFUNC)DLSYM(lib, \"rewind_shaper\");\n\tops->close = (CLOSEFUNC)DLSYM(lib, \"close_shaper\");\n\n\tfptr->next = funcs;\n\tfuncs = fptr;\n\n\tupdate_csv_data_only = (VOIDCALL)DLSYM(lib,\"set_csv_data_only\");\n\tupdate_csv_keep_clean = (VOIDCALL)DLSYM(lib,\"set_csv_keep_clean\");\n\treturn funcs;\n}\n\nEXPORT CLASS *init(CALLBACKS *fntable, void *module, int argc, char *argv[])\n{\n\tstruct recorder my;\n\tstruct collector my2;\n\n\tif (set_callback(fntable)==NULL)\n\t{\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\t/* globals for the tape module*/\n#ifdef _WIN32\n\tsprintf(tape_gnuplot_path, \"c:/Program Files/GnuPlot/bin/wgnuplot.exe\");\n#else\n\tsprintf(tape_gnuplot_path,\"/usr/bin/gnuplot\");\n#endif\n\tgl_global_create(\"tape::gnuplot_path\",PT_char1024,&tape_gnuplot_path,NULL);\n\tgl_global_create(\"tape::flush_interval\",PT_int32,&flush_interval,NULL);\n\tgl_global_create(\"tape::csv_data_only\",PT_int32,&csv_data_only,NULL);\n\tgl_global_create(\"tape::csv_keep_clean\",PT_int32,&csv_keep_clean,NULL);\n\n\t/* control delta mode */\n\tgl_global_create(\"tape::delta_mode_needed\", PT_timestamp, &delta_mode_needed,NULL);\n\n\t/* register the first class implemented, use SHARE to reveal variables */\n\tplayer_class = gl_register_class(module,\"player\",sizeof(struct player),PC_PRETOPDOWN); \n\tplayer_class->trl = TRL_PROVEN;\n\tPUBLISH_STRUCT(player,char256,property);\n\tPUBLISH_STRUCT(player,char1024,file);\n\tPUBLISH_STRUCT(player,char8,filetype);\n\tPUBLISH_STRUCT(player,char32,mode);\n\tPUBLISH_STRUCT(player,int32,loop);\n\n\t/* register the first class implemented, use SHARE to reveal variables */\n\tshaper_class = gl_register_class(module,\"shaper\",sizeof(struct shaper),PC_PRETOPDOWN); \n\tshaper_class->trl = TRL_QUALIFIED;\n\tPUBLISH_STRUCT(shaper,char1024,file);\n\tPUBLISH_STRUCT(shaper,char8,filetype);\n\tPUBLISH_STRUCT(shaper,char32,mode);\n\tPUBLISH_STRUCT(shaper,char256,group);\n\tPUBLISH_STRUCT(shaper,char256,property);\n\tPUBLISH_STRUCT(shaper,double,magnitude);\n\tPUBLISH_STRUCT(shaper,double,events);\n\n\t/* register the other classes as needed, */\n\trecorder_class = gl_register_class(module,\"recorder\",sizeof(struct recorder),PC_POSTTOPDOWN|PC_OBSERVER);\n\trecorder_class->trl = TRL_PROVEN;\n\tPUBLISH_STRUCT(recorder,char1024,property);\n\tPUBLISH_STRUCT(recorder,char32,trigger);\n\tPUBLISH_STRUCT(recorder,char1024,file);\n\tPUBLISH_STRUCT(recorder,char8,filetype);\n\tPUBLISH_STRUCT(recorder,char32,mode);\n\tPUBLISH_STRUCT(recorder,char1024,multifile);\n\t//PUBLISH_STRUCT(recorder,int64,interval);\n\tPUBLISH_STRUCT(recorder,int32,limit);\n\tPUBLISH_STRUCT(recorder,char1024,plotcommands);\n\tPUBLISH_STRUCT(recorder,char32,xdata);\n\tPUBLISH_STRUCT(recorder,char32,columns);\n\tPUBLISH_STRUCT(recorder,int32,flush);\n    PUBLISH_STRUCT(recorder,bool,format);\n\t\n\tif(gl_publish_variable(recorder_class,\n\t\tPT_double, \"interval[s]\", ((char*)&(my.dInterval) - (char *)&my),\n\t\tPT_enumeration, \"output\", ((char*)&(my.output) - (char *)&my),\n\t\t\tPT_KEYWORD, \"SCREEN\", SCREEN,\n\t\t\tPT_KEYWORD, \"EPS\",    EPS,\n\t\t\tPT_KEYWORD, \"GIF\",    GIF,\n\t\t\tPT_KEYWORD, \"JPG\",    JPG,\n\t\t\tPT_KEYWORD, \"PDF\",    PDF,\n\t\t\tPT_KEYWORD, \"PNG\",    PNG,\n\t\t\tPT_KEYWORD, \"SVG\",    SVG, \n\t\tPT_enumeration, \"header_units\", ((char*)&(my.header_units) - (char *)&my),\n\t\t\tPT_KEYWORD, \"DEFAULT\", HU_DEFAULT,\n\t\t\tPT_KEYWORD, \"ALL\", HU_ALL,\n\t\t\tPT_KEYWORD, \"NONE\", HU_NONE,\n\t\tPT_enumeration, \"line_units\", ((char*)&(my.line_units) - (char *)&my),\n\t\t\tPT_KEYWORD, \"DEFAULT\", LU_DEFAULT,\n\t\t\tPT_KEYWORD, \"ALL\", LU_ALL,\n\t\t\tPT_KEYWORD, \"NONE\", LU_NONE,\n\t\t\tNULL) < 1)\n\t\tGL_THROW(\"Could not publish property output for recorder\");\n\n\t\t/* register the other classes as needed, */\n\tmulti_recorder_class = gl_register_class(module,\"multi_recorder\",sizeof(struct recorder),PC_POSTTOPDOWN|PC_OBSERVER);\n\tmulti_recorder_class->trl = TRL_QUALIFIED;\n\tif(gl_publish_variable(multi_recorder_class,\n\t\tPT_double, \"interval[s]\", ((char*)&(my.dInterval) - (char *)&my),\n\t\tPT_char1024, \"property\", ((char*)&(my.property) - (char *)&my),\n\t\tPT_char32, \"trigger\", ((char*)&(my.trigger) - (char *)&my),\n\t\tPT_char1024, \"file\", ((char*)&(my.file) - (char *)&my),\n\t\tPT_char8, \"filetype\", ((char*)&(my.filetype) - (char *)&my),\n\t\tPT_char32, \"mode\", ((char*)&(my.mode) - (char *)&my),\n\t\tPT_char1024, \"multifile\", ((char*)&(my.multifile) - (char *)&my),\n\t\tPT_int32, \"limit\", ((char*)&(my.limit) - (char *)&my),\n\t\tPT_char1024, \"plotcommands\", ((char*)&(my.plotcommands) - (char *)&my),\n\t\tPT_char32, \"xdata\", ((char*)&(my.xdata) - (char *)&my),\n\t\tPT_char32, \"columns\", ((char*)&(my.columns) - (char *)&my),\n        PT_char32, \"format\", ((char*)&(my.format) - (char *)&my),\n\t\tPT_enumeration, \"output\", ((char*)&(my.output) - (char *)&my),\n\t\t\tPT_KEYWORD, \"SCREEN\", SCREEN,\n\t\t\tPT_KEYWORD, \"EPS\",    EPS,\n\t\t\tPT_KEYWORD, \"GIF\",    GIF,\n\t\t\tPT_KEYWORD, \"JPG\",    JPG,\n\t\t\tPT_KEYWORD, \"PDF\",    PDF,\n\t\t\tPT_KEYWORD, \"PNG\",    PNG,\n\t\t\tPT_KEYWORD, \"SVG\",    SVG, \n\t\tPT_enumeration, \"header_units\", ((char*)&(my.header_units) - (char *)&my),\n\t\t\tPT_KEYWORD, \"DEFAULT\", HU_DEFAULT,\n\t\t\tPT_KEYWORD, \"ALL\", HU_ALL,\n\t\t\tPT_KEYWORD, \"NONE\", HU_NONE,\n\t\tPT_enumeration, \"line_units\", ((char*)&(my.line_units) - (char *)&my),\n\t\t\tPT_KEYWORD, \"DEFAULT\", LU_DEFAULT,\n\t\t\tPT_KEYWORD, \"ALL\", LU_ALL,\n\t\t\tPT_KEYWORD, \"NONE\", LU_NONE,\n\t\t\tNULL) < 1)\n\t\tGL_THROW(\"Could not publish property output for multi_recorder\");\n\n\t/* register the other classes as needed, */\n\tcollector_class = gl_register_class(module,\"collector\",sizeof(struct collector),PC_POSTTOPDOWN|PC_OBSERVER);\n\tcollector_class->trl = TRL_PROVEN;\n\tPUBLISH_STRUCT(collector,char1024,property);\n\tPUBLISH_STRUCT(collector,char32,trigger);\n\tPUBLISH_STRUCT(collector,char1024,file);\n\t//PUBLISH_STRUCT(collector,int64,interval);\n\tPUBLISH_STRUCT(collector,int32,limit);\n\tPUBLISH_STRUCT(collector,char256,group);\n\tPUBLISH_STRUCT(collector,int32,flush);\n\tif(gl_publish_variable(collector_class,\n\t\tPT_double, \"interval[s]\", ((char*)&(my2.dInterval) - (char *)&my2),\n\t\t\tNULL) < 1)\n\t\tGL_THROW(\"Could not publish property output for collector\");\n\n\t/* new histogram() */\n  new_histogram(module);\n\n\t/* new group_recorder() */\n  new_group_recorder(module);\n\n\t/* new violation_recorder() */\n  new_violation_recorder(module);\n\n\t/* new metrics_collector() */\n  new_metrics_collector(module);\n\n\t/* new metrics_collector_writer() */\n  new_metrics_collector_writer(module);\n\n#if 0\n\tnew_loadshape(module);\n#endif // zero\n\n//\tnew_schedule(module);\n\n\t/* always return the first class registered */\n\treturn player_class;\n}\n\nEXPORT int check(void)\n{\n\tunsigned int errcount=0;\n\tchar fpath[1024];\n\t/* check players */\n\t{\tOBJECT *obj=NULL;\n\t\tFINDLIST *players = gl_find_objects(FL_NEW,FT_CLASS,SAME,\"tape\",FT_END);\n\t\twhile ((obj=gl_find_next(players,obj))!=NULL)\n\t\t{\n\t\t\tstruct player *pData = OBJECTDATA(obj,struct player);\n\t\t\tif (gl_findfile(pData->file,NULL,F_OK,fpath,sizeof(fpath))==NULL)\n\t\t\t{\n\t\t\t\terrcount++;\n\t\t\t\tgl_error(\"player %s (id=%d) uses the file '%s', which cannot be found\", obj->name?obj->name:\"(unnamed)\", obj->id, pData->file);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* check shapers */\n\t{\tOBJECT *obj=NULL;\n\t\tFINDLIST *shapers = gl_find_objects(FL_NEW,FT_CLASS,SAME,\"shaper\",FT_END);\n\t\twhile ((obj=gl_find_next(shapers,obj))!=NULL)\n\t\t{\n\t\t\tstruct shaper *pData = OBJECTDATA(obj,struct shaper);\n\t\t\tif (gl_findfile(pData->file,NULL,F_OK,fpath,sizeof(fpath))==NULL)\n\t\t\t{\n\t\t\t\terrcount++;\n\t\t\t\tgl_error(\"shaper %s (id=%d) uses the file '%s', which cannot be found\", obj->name?obj->name:\"(unnamed)\", obj->id, pData->file);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn errcount;\n}\n\n/* DELTA MODE SUPPORT */\n/*\n\tDelta mode is supported by maintaining a list of recorders that are enabled\n\tfor high-speed sampling.  This list is populated for sync_recorder based on\n\twhether OF_DELTAMODE is set.  Objects in the list are recorded to the output\n\tduring the interupdate() operation and not during the object update (which is\n\ttoo slow and could happen at the wrong time).\n */\n\ndouble recorder_delta_clock = 0.0;\nDELTAOBJ_LIST *delta_tape_objects = NULL;\n\n/* Function to add a tape module object into a deltamode list */\nint delta_add_tape_device(OBJECT *obj, DELTATAPEOBJ tape_type)\n{\n\tDELTAOBJ_LIST *temp_ll_item, *index_item;\n\n\t/* Allocate one */\n\ttemp_ll_item = (DELTAOBJ_LIST*)gl_malloc(sizeof(DELTAOBJ_LIST));\n\n\t/* Make sure it worked */\n\tif (temp_ll_item == NULL)\n\t{\n\t\tgl_error(\"tape object:%d - unable to allocate space for deltamode\",obj->id);\n\t\t/*  TROUBLESHOOT\n\t\tWhile attempting to allocate space for a tape module deltamode-capable object, an error occurred.  Please try again.\n\t\tIf the error persists, please submit your code and a bug report via the ticketing system.\n\t\t*/\n\t\treturn FAILED;\n\t}\n\n\t/* Populate it */\n\ttemp_ll_item->obj = obj;\n\ttemp_ll_item->obj_type = tape_type;\n\ttemp_ll_item->next = NULL;\n\n\t/* Find the place */\n\tif (delta_tape_objects != NULL)\n\t{\n\t\t/* Get initial value */\n\t\tindex_item = delta_tape_objects;\n\n\t\twhile (index_item->next != NULL)\n\t\t{\n\t\t\tindex_item = index_item->next;\n\t\t}\n\n\t\t//This should be the place to insert\n\t\tindex_item->next = temp_ll_item;\n\t}\n\telse /* Only one item, just add us in there */\n\t{\n\t\tdelta_tape_objects = temp_ll_item;\n\t}\n\n\t/* If we made it this far, must be successful */\n\treturn SUCCESS;\n}\n\n\nvoid enable_deltamode(TIMESTAMP t)\n{\n\tif ((t<delta_mode_needed) && ((t-gl_globalclock)<0x7fffffff )) // cannot exceed 31 bit integer\n\t\tdelta_mode_needed = t;\n}\n\nEXPORT unsigned long deltamode_desired(int *flags)\n{\n\tTIMESTAMP tdiff = delta_mode_needed-gl_globalclock;\n\n\t/* delta mode is desired if any tape have subsecond data next */\n\t/* Prevents a DT_INVALID, since no real need for it here (>0 check) */\n\tif ((delta_mode_needed!=TS_NEVER) && (tdiff<0x7fffffff) && (tdiff>=0)) /* 31 bit limit */\n\t\treturn (unsigned long)tdiff;\n\telse\n\t\treturn DT_INFINITY;\n}\n\nEXPORT unsigned long preupdate(MODULE *module, TIMESTAMP t0, unsigned int64 dt)\n{\n\t/* no need to step faster than any other object does */\n\treturn DT_INFINITY;\n}\n\nEXPORT SIMULATIONMODE interupdate(MODULE *module, TIMESTAMP t0, unsigned int64 delta_time, unsigned long dt, unsigned int iteration_count_val)\n{\n\tDELTAOBJ_LIST *index_item;\n\tSIMULATIONMODE mode = SM_EVENT;\n\n\t/* determine the timestamp */\n\tdouble clock_val = (double)gl_globalclock + (double)delta_time/(double)DT_SECOND;\n\tchar recorder_timestamp[64];\n\n\t/* prepare the timestamp */\n\tstatic char global_dateformat[8]=\"\";\n\t\n\tTIMESTAMP integer_clock = (TIMESTAMP)clock_val;\t/* Whole seconds - update from global clock because we could be in delta for over 1 second */\n\tint microseconds = (int)((clock_val-(int)(clock_val))*1000000+0.5);\t/* microseconds roll-over - biased upward (by 0.5) */\n\t\n\t/* Recorders should only \"fire\" on the 0th iteration - may need to adjust if \"0\" is implemented in deltamode */\n\tif (iteration_count_val==0)\n\t{\n\t\t/* Set up recorder clock - ignore \"first\" entry since that is just steady state */\n\t\tif ((integer_clock != t0) || (microseconds != 0))\n\t\t{\n\t\t\tDATETIME rec_date_time;\n\t\t\tTIMESTAMP rec_integer_clock = (TIMESTAMP)recorder_delta_clock;\t/* Whole seconds - update from global clock because we could be in delta for over 1 second */\n\t\t\tint rec_microseconds = (int)((recorder_delta_clock-(int)(recorder_delta_clock))*1000000+0.5);\t/* microseconds roll-over - biased upward (by 0.5) */\n\t\t\tif ( gl_localtime(rec_integer_clock,&rec_date_time)!=0 )\n\t\t\t{\n\t\t\t\tif ( global_dateformat[0]=='\\0')\n\t\t\t\t\tgl_global_getvar(\"dateformat\",global_dateformat,sizeof(global_dateformat));\n\t\t\t\tif ( strcmp(global_dateformat,\"ISO\")==0)\n\t\t\t\t\tsprintf(recorder_timestamp,\"%04d-%02d-%02d %02d:%02d:%02d.%.06d %s\",rec_date_time.year,rec_date_time.month,rec_date_time.day,rec_date_time.hour,rec_date_time.minute,rec_date_time.second,rec_microseconds,rec_date_time.tz);\n\t\t\t\telse if ( strcmp(global_dateformat,\"US\")==0)\n\t\t\t\t\tsprintf(recorder_timestamp,\"%02d-%02d-%04d %02d:%02d:%02d.%.06d %s\",rec_date_time.month,rec_date_time.day,rec_date_time.year,rec_date_time.hour,rec_date_time.minute,rec_date_time.second,rec_microseconds,rec_date_time.tz);\n\t\t\t\telse if ( strcmp(global_dateformat,\"EURO\")==0)\n\t\t\t\t\tsprintf(recorder_timestamp,\"%02d-%02d-%04d %02d:%02d:%02d.%.06d %s\",rec_date_time.day,rec_date_time.month,rec_date_time.year,rec_date_time.hour,rec_date_time.minute,rec_date_time.second,rec_microseconds,rec_date_time.tz);\n\t\t\t\telse\n\t\t\t\t\tsprintf(recorder_timestamp,\"%.09f\",recorder_delta_clock);\n\t\t\t}\n\t\t\telse\n\t\t\t\tsprintf(recorder_timestamp,\"%.09f\",recorder_delta_clock);\n\n\t\t\t/* Initialize loop */\n\t\t\tindex_item = delta_tape_objects;\n\n\t\t\t/* Loop through and find a recorder */\n\t\t\twhile (index_item != NULL)\n\t\t\t{\n\t\t\t\tif (index_item->obj_type == RECORDER)\n\t\t\t\t{\n\t\t\t\t\tOBJECT *obj = index_item->obj;\n\t\t\t\t\tstruct recorder *my = (struct recorder *)OBJECTDATA(obj,struct recorder);\n\t\t\t\t\tchar value[1024];\n\t\t\t\t\textern int read_properties(struct recorder *my, OBJECT *obj, PROPERTY *prop, char *buffer, int size);\n\n\t\t\t\t\t/* See if we're in service */\n\t\t\t\t\tif ((obj->in_svc_double <= gl_globaldeltaclock) && (obj->out_svc_double >= gl_globaldeltaclock))\n\t\t\t\t\t{\n\t\t\t\t\t\tif( read_properties(my, obj->parent,my->target,value,sizeof(value)) )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif ( !my->ops->write(my, recorder_timestamp, value) )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tgl_error(\"recorder:%d: unable to write sample to file\", obj->id);\n\t\t\t\t\t\t\t\treturn SM_ERROR;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/* Defaulted else, not in service, do nothing */\n\t\t\t\t}/* End recorder */\n\t\t\t\t/* Default else -- not a recorder, so skip */\n\n\t\t\t\t/* Grab the next item */\n\t\t\t\tindex_item = index_item->next;\n\t\t\t}//End list loop\n\t\t}\n\t\t\n\t\t/* Store recorder clock (to be used next time) */\n\t\trecorder_delta_clock = clock_val;\n\t}/* End Recorder only on 0th iteration loop */\n\n\t/*** Keep going below here ***/\n\t/* input samples from players */\n\t/* Initialize loop */\n\tindex_item = delta_tape_objects;\n\n\t/* Loop through and find a recorder */\n\twhile (index_item != NULL)\n\t{\n\t\tif (index_item->obj_type == PLAYER)\n\t\t{\n\t\t\tOBJECT *obj = index_item->obj;\n\t\t\tstruct player *my = (struct player *)OBJECTDATA(obj,struct player);\n\t\t\tint y=0,m=0,d=0,H=0,M=0,S=0,ms=0, n=0;\n\t\t\tchar *fmt = \"%d/%d/%d %d:%d:%d.%d,%*s\";\n\t\t\tdouble t = (double)my->next.ts + (double)my->next.ns/1e9;\n\t\t\tchar256 curr_value;\n\n\t\t\t/* See if we're in service */\n\t\t\tif ((obj->in_svc_double <= gl_globaldeltaclock) && (obj->out_svc_double >= gl_globaldeltaclock))\n\t\t\t{\n\t\t\t\tstrcpy(curr_value,my->next.value);\n\n\t\t\t\t/* post the current value */\n\t\t\t\tif ( t<=clock_val )\n\t\t\t\t{\n\t\t\t\t\textern TIMESTAMP player_read(OBJECT *obj);\n\n\t\t\t\t\t/* Check to make sure we've be initialized -- if a deltamode timestep is first, it may be before this was initialized */\n\t\t\t\t\tif (my->target == NULL)\t/* Not set yet */\n\t\t\t\t\t{\n\t\t\t\t\t\t/*  This fails on Mac builds under 4.0 for some odd reason.  Commenting code and putting an error for now.\n\t\t\t\t\t\tWill be investigated further for 4.1 release.\n\t\t\t\t\t\t*/\n\n\t\t\t\t\t\tgl_error(\"deltamode player: player \\\"%s\\\" has a deltamode timestep starting it - please avoid this\",(obj->name ? obj->name : \"(anon)\"));\n\t\t\t\t\t\t/*  TROUBLESHOOT\n\t\t\t\t\t\tStarting a player with a deltamode timestep causes segmentation faults.  A fix was developed, but still has issues with\n\t\t\t\t\t\tcertain platforms and must be investigated further.  For now, start all player files with non-deltamode timesteps.  This\n\t\t\t\t\t\tissues is documented at #1001 on the GridLAB-D Git site, and it expected to be resolved in release 4.1.\n\t\t\t\t\t\t*/\n\n\t\t\t\t\t\treturn SM_ERROR;\n\n\t\t\t\t\t\t/* *** Commenting -- all existing comment braces turned to ***\n\t\t\t\t\t\t*** Make sure we actually opened the file (this part is new - paranoia check ***\n\t\t\t\t\t\tif (my->status != TS_OPEN)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tgl_error(\"deltamode player: player \\\"%s\\\" has not been opened yet!\",obj->name?obj->name:\"(anon)\");\n\t\t\t\t\t\t\t***  TROUBLESHOOT\n\t\t\t\t\t\t\tWhile attempting to start a player with a deltamode timestep, it was found the player hasn't been opened yet.\n\t\t\t\t\t\t\tPlease submit your code and a bug report via the issue system.  To work around this, put a non-deltamode timestep\n\t\t\t\t\t\t\tat the beginning of your player file\n\t\t\t\t\t\t\t***\n\n\t\t\t\t\t\t\t*** Set our status, just in case ***\n\t\t\t\t\t\t\tmy->status = TS_ERROR;\n\n\t\t\t\t\t\t\treturn SM_ERROR;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t*** Code copied from player sync ***\n\t\t\t\t\t\tmy->target = player_link_properties(my, obj->parent, my->property);\n\n\t\t\t\t\t\t*** Make sure it worked ***\n\t\t\t\t\t\tif (my->target==NULL){\n\t\t\t\t\t\t\tgl_error(\"deltamode player: Unable to find property \\\"%s\\\" in object %s\", my->property, obj->name?obj->name:\"(anon)\");\n\t\t\t\t\t\t\t***  TROUBLESHOOT\n\t\t\t\t\t\t\tWhile attempting to link up the property of a player in deltamode, the property could not be found.  Make sure the object\n\t\t\t\t\t\t\texists and has the specified property and try again.\n\t\t\t\t\t\t\t***\n\t\t\t\t\t\t\tmy->status = TS_ERROR;\n\t\t\t\t\t\t\treturn SM_ERROR;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t*** Do an initialization of it ***\n\t\t\t\t\t\tif (my->target!=NULL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tOBJECT *target = obj->parent ? obj->parent : obj; *** target myself if no parent ***\n\t\t\t\t\t\t\tplayer_write_properties(my, target, my->target, my->next.value);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t*** Copy the current value into our \"tracking\" variable ***\n\t\t\t\t\t\tmy->delta_track.ns = my->next.ns;\n\t\t\t\t\t\tmy->delta_track.ts = my->next.ts;\n\t\t\t\t\t\tmemcpy(my->delta_track.value,my->next.value,sizeof(char1024));\n\t\t\t\t\t\t*/\n\t\t\t\t\t}/* Target not already set */\n\n\t\t\t\t\t/* Behave similar to \"supersecond\" players */\n\t\t\t\t\twhile ( t<=clock_val )\n\t\t\t\t\t{\n\t\t\t\t\t\tgl_set_value(obj->parent,GETADDR(obj->parent,my->target),my->next.value,my->target); /* pointer => int64 */\n\n\t\t\t\t\t\t/* read the next value */\n\t\t\t\t\t\tplayer_read(obj);\n\n\t\t\t\t\t\t/* update time */\n\t\t\t\t\t\tt = (double)my->next.ts + (double)my->next.ns/1e9;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* Determine if we are at the end of the player or not (time check) */\n\t\t\t\tif (my->next.ts != TS_NEVER)\n\t\t\t\t{\n\t\t\t\t\t/* Update time */\n\t\t\t\t\tt = (double)my->next.ts + (double)my->next.ns/1e9;\n\n\t\t\t\t\t/* Make sure we haven't passed this time already (last value) */\n\t\t\t\t\t/* Check to see if we're within the next second too, so we aren't stuck in delta */\n\t\t\t\t\tif ((t>=clock_val) && (t<(clock_val+1.0)))\n\t\t\t\t\t{\n\t\t\t\t\t\t/* determine whether deltamode remains necessary */\n\t\t\t\t\t\tif (my->next.ns!=0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmode = SM_DELTA;\n\t\t\t\t\t\t\tgl_verbose(\"Tape object:%d - %s - requested deltamode to continue\",obj->id,(obj->name ? obj->name : \"Unnamed\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}/*End not TS_NEVER */\n\t\t\t\telse\t/* Player is done - set the flag variables, just to prevent some other issues in sync_player */\n\t\t\t\t{\n\t\t\t\t\t/* These prevent the code on player.c:488 from overwriting with an older value */\n\t\t\t\t\tmy->delta_track.ns = 0;\n\t\t\t\t\tmy->delta_track.ts = TS_NEVER;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Default else - not in service */\n\t\t}/* End of player loop */\n\t\t/* Default else - not a player */\n\n\t\t/*Next item in the loop */\n\t\tindex_item = index_item->next;\n\t}\n\n\treturn mode;\n}\n\nEXPORT STATUS postupdate(MODULE *module, TIMESTAMP t0, unsigned int64 dt)\n{\n\tDELTAOBJ_LIST *index_item;\n\tOBJECT *obj = NULL;\n\tstruct recorder *myrec = NULL;\n\tstruct player *myplayer = NULL;\n\tFUNCTIONADDR temp_fxn;\n\tchar value[1024];\n\textern int read_properties(struct recorder *my, OBJECT *obj, PROPERTY *prop, char *buffer, int size);\n\n\t/* Perform one final update of recorder - otherwise it misses the last \"value\" */\n\t/* Code copied out of interupdate above */\n\t/* determine the timestamp */\n\tchar recorder_timestamp[64];\n\tDATETIME rec_date_time;\n\tTIMESTAMP rec_integer_clock;\n\tint rec_microseconds;\n\tbool recorder_init_items = false;\n\tchar global_dateformat[8]=\"\";\n\tint return_val;\n\n\t/* Initialize loop */\n\tindex_item = delta_tape_objects;\n\n\t/* Loop through objects and look for recorder */\n\t/* Only look for recorders first -- ensures they pull the last value before a player overwrites it */\n\twhile (index_item != NULL)\n\t{\n\t\tif (index_item->obj_type == RECORDER)\n\t\t{\n\t\t\tif (recorder_init_items == false)\n\t\t\t{\n\t\t\t\t/* Set up recorder clock */\n\t\t\t\trec_integer_clock = (TIMESTAMP)recorder_delta_clock;\t/* Whole seconds - update from global clock because we could be in delta for over 1 second */\n\t\t\t\trec_microseconds = (int)((recorder_delta_clock-(int)(recorder_delta_clock))*1000000+0.5);\t/* microseconds roll-over - biased upward (by 0.5) */\n\t\t\t\tif ( gl_localtime(rec_integer_clock,&rec_date_time)!=0 )\n\t\t\t\t{\n\t\t\t\t\tif ( global_dateformat[0]=='\\0')\n\t\t\t\t\t\tgl_global_getvar(\"dateformat\",global_dateformat,sizeof(global_dateformat));\n\t\t\t\t\tif ( strcmp(global_dateformat,\"ISO\")==0)\n\t\t\t\t\t\tsprintf(recorder_timestamp,\"%04d-%02d-%02d %02d:%02d:%02d.%.06d %s\",rec_date_time.year,rec_date_time.month,rec_date_time.day,rec_date_time.hour,rec_date_time.minute,rec_date_time.second,rec_microseconds,rec_date_time.tz);\n\t\t\t\t\telse if ( strcmp(global_dateformat,\"US\")==0)\n\t\t\t\t\t\tsprintf(recorder_timestamp,\"%02d-%02d-%04d %02d:%02d:%02d.%.06d %s\",rec_date_time.month,rec_date_time.day,rec_date_time.year,rec_date_time.hour,rec_date_time.minute,rec_date_time.second,rec_microseconds,rec_date_time.tz);\n\t\t\t\t\telse if ( strcmp(global_dateformat,\"EURO\")==0)\n\t\t\t\t\t\tsprintf(recorder_timestamp,\"%02d-%02d-%04d %02d:%02d:%02d.%.06d %s\",rec_date_time.day,rec_date_time.month,rec_date_time.year,rec_date_time.hour,rec_date_time.minute,rec_date_time.second,rec_microseconds,rec_date_time.tz);\n\t\t\t\t\telse\n\t\t\t\t\t\tsprintf(recorder_timestamp,\"%.09f\",recorder_delta_clock);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tsprintf(recorder_timestamp,\"%.09f\",recorder_delta_clock);\n\n\t\t\t\t/*Deflag */\n\t\t\t\trecorder_init_items = true;\n\t\t\t}/*End recorder time init */\n\n\t\t\tobj = index_item->obj;\n\t\t\tmyrec = (struct recorder *)OBJECTDATA(obj,struct recorder);\n\n\t\t\t/* See if we're in service */\n\t\t\tif ((obj->in_svc_double <= gl_globaldeltaclock) && (obj->out_svc_double >= gl_globaldeltaclock))\n\t\t\t{\n\t\t\t\tif( read_properties(myrec, obj->parent,myrec->target,value,sizeof(value)) )\n\t\t\t\t{\n\t\t\t\t\tif ( !myrec->ops->write(myrec, recorder_timestamp, value) )\n\t\t\t\t\t{\n\t\t\t\t\t\tgl_error(\"recorder:%d: unable to write sample to file\", obj->id);\n\t\t\t\t\t\treturn FAILED;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Update recorders so they don't \"minimum timestep up\" to where we exited! */\n\t\t\t\t\tmyrec->last.ts = rec_integer_clock;\n\t\t\t\t\tmyrec->last.ns = rec_microseconds;\n\n\t\t\t\t\t/*  Copy in the last value, just in case */\n\t\t\t\t\tstrcpy(myrec->last.value,value);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Defaulted else - not in service */\n\t\t}//End deltamode recorders requested check\n\t\telse if (index_item->obj_type == GROUPRECORDER)\n\t\t{\n\t\t\t/* Extract the object */\n\t\t\tobj = index_item->obj;\n\n\t\t\t/* Map up function - have to do a modified version (C call), which is why this looks odd*/\n\t\t\ttemp_fxn = (FUNCTIONADDR)(gl_get_function(obj->oclass->name,\"obj_postupdate_fxn\"));\n\n\t\t\tif (temp_fxn == NULL)\n\t\t\t{\n\t\t\t\tgl_error(\"Unable to map group_recorder postupdate function\");\n\t\t\t\t/*  TROUBLESHOOT\n\t\t\t\tWhile trying to map up a deltamode function for group_recorders, the function was not found.\n\t\t\t\tPlease try again.  If the error persists, please submit your code and a bug report via the ticketing\n\t\t\t\tsystem.\n\t\t\t\t*/\n\n\t\t\t\treturn FAILED;\n\t\t\t}\n\n\t\t\t/* Call the function */\n\t\t\treturn_val = ((int (*)(OBJECT *,double))(*temp_fxn))(index_item->obj,gl_globaldeltaclock);\n\n\t\t\t/* Make sure it worked */\n\t\t\tif (return_val != 1)\n\t\t\t{\n\t\t\t\tgl_error(\"Failed to perform postupdate for group_recorder object\");\n\t\t\t\t/*  TROUBLESHOOT\n\t\t\t\tWhile trying to perform the final write for a group recorder deltamode call, an error occurred.  Please\n\t\t\t\tlook at the output console for more details.\n\t\t\t\t*/\n\n\t\t\t\treturn FAILED;\n\t\t\t}\n\n\t\t\t/* Renull the function */\n\t\t\ttemp_fxn = NULL;\n\t\t}\n\t\t/* Default else - not a recorder */\n\n\t\t/* Update pointer */\n\t\tindex_item = index_item->next;\n\t}/* End while loop for recorders */\n\n\t/* If any existed, do a flush */\n\tif (recorder_init_items == true)\n\t{\n\t\t/* flush the output streams */\n\t\tfflush(NULL);\n\t}\n\n\t/* check if any players still need delta mode */\n\tdelta_mode_needed = TS_NEVER;\n\t/* Initialize loop */\n\tindex_item = delta_tape_objects;\n\n\t/* Loop through objects and look for players */\n\twhile (index_item != NULL)\n\t{\n\t\t/* See if it is a player */\n\t\tif (index_item->obj_type == PLAYER)\n\t\t{\n\t\t\tobj = index_item->obj;\n\t\t\tmyplayer = (struct player *)OBJECTDATA(obj,struct player);\n\n\t\t\t/* See if we're in service */\n\t\t\tif ((obj->in_svc_double <= gl_globaldeltaclock) && (obj->out_svc_double >= gl_globaldeltaclock))\n\t\t\t{\n\t\t\t\tif (( myplayer->next.ns!=0 ) && (myplayer->next.ts != t0))\t/* See if we need to go back into deltamode, but make sure we aren't stuck! */\n\t\t\t\t\tenable_deltamode(myplayer->next.ts);\n\t\t\t}\n\t\t}\n\t\t/* Default else, not a player */\n\n\t\t/* update pointer */\n\t\tindex_item = index_item->next;\n\t}/* End object loop */\n\n\treturn SUCCESS;\n}\n\nint do_kill()\n{\n\t/* if global memory needs to be released, this is the time to do it */\n\treturn 0;\n}\n\n/**@}*/\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/BuildingGridlabdOnWindowsWithMsys2.docx",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/MinGW_Eclipse_Instructions.docx",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/gridlabd-64.iss",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/obsolete_test_case/residential_test/etp_solution_check.xls",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/obsolete_test_case/powerflow_test/37node/Ieee37VnodeLN.mat",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/obsolete_test_case/gldcore_test/please_wait.png",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/obsolete_test_case/gldcore_test/elcap_reference_loadshapes.xls",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/obsolete_test_case/gldcore_test/olypen_expmt.glm",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/obsolete_test_case/test/core_test/core_test.aps",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/obsolete_test_case/test/master_test/master_test.aps",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/obsolete_test_case/test/externals/ieee14bus.tif",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/VS2005/gridlabd2.iss",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/VS2005/gridlabd.iss",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/VS2005/gridlabd-64.iss",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/gldcore/link/matlab/matlab.ncb",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/gldcore/rt/switch_b.png",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/gldcore/rt/load_g.png",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/gldcore/rt/transformer_k.png",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/gldcore/rt/regulator_b.png",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/gldcore/rt/transformer_b.png",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/gldcore/rt/capacitor_k.png",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/gldcore/rt/node_b.png",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/gldcore/rt/node_r.png",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/gldcore/rt/triplex_meter_b.png",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/gldcore/rt/node_k.png",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/gldcore/rt/switch_k.png",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/gldcore/rt/capacitor_b.png",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/gldcore/rt/triplex_meter_g.png",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/gldcore/rt/regulator_r.png",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/gldcore/rt/node_g.png",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/gldcore/rt/triplex_meter_r.png",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/gldcore/rt/load_k.png",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/gldcore/rt/regulator_k.png",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/gldcore/rt/capacitor_g.png",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/gldcore/rt/triplex_meter_k.png",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/gldcore/rt/favicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/gldcore/rt/load_r.png",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/gldcore/rt/load_b.png",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/gldcore/rt/meter_g.png",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/gldcore/rt/regulator_g.png",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/gldcore/rt/gridlabd.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/gldcore/rt/capacitor_r.png",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/gldcore/rt/switch_r.png",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/gldcore/rt/kml_icons.pptx",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/gldcore/rt/transformer_g.png",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/gldcore/rt/transformer_r.png",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/gldcore/rt/switch_g.png",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/gldcore/gui/tab_l.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/gldcore/gui/tab_b.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/gldcore/gui/tab_r.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/third_party/cppunit-1.12.0.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/third_party/xerces-c-3.2.0.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/third_party/FNCS-2.3.3.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/residential/data/evcharger/home-work.xls",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/residential/docs/evcharger.ppt",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/residential/docs/evcharger/Slide1.PNG",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/residential/docs/evcharger/Slide2.PNG",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/connection/connection.pptx",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/connection/json_link/doc/html/objects.inv",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/connection/json_link/doc/html/_static/comment-close.png",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/connection/json_link/doc/html/_static/down.png",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/connection/json_link/doc/html/_static/down-pressed.png",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/connection/json_link/doc/html/_static/plus.png",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/connection/json_link/doc/html/_static/comment-bright.png",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/connection/json_link/doc/html/_static/comment.png",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/connection/json_link/doc/html/_static/up-pressed.png",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/connection/json_link/doc/html/_static/file.png",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/connection/json_link/doc/html/_static/ajax-loader.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/connection/json_link/doc/html/_static/contents.png",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/connection/json_link/doc/html/_static/navigation.png",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/connection/json_link/doc/html/_static/up.png",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/connection/json_link/doc/html/_static/minus.png",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/.git/objects/pack/pack-2c11fee95b72c182808ce0cb944066e8852f70ac.idx",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/.git/objects/pack/pack-2c11fee95b72c182808ce0cb944066e8852f70ac.pack",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/tape_memory/tape_memory.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/models/SimpleMarket.zip",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/models/8500 Node System/Post Processing/coordinates.mat",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/GLDebug/src/images/gdlogo.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/GLDebug/src/images/GLSplash.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/GLDebug/lib/jdom.jar",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/network/autotest/TS9Bus_2node.pwb",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/network/autotest/TS9Bus.PWB",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/network/autotest/TS9Bus_1node.pwb",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/Resources/Background.png",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/rest/gui_root/gsimages/overhead_line.png",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/rest/gui_root/gsimages/switch.png",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/rest/gui_root/gsimages/transformer.png",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/rest/gui_root/gsimages/house.png",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/rest/gui_root/gsimages/node.png",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/rest/gui_root/gsimages/powersubstation.png",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/rest/gui_root/gsimages/triplex_node.png",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/rest/gui_root/gsimages/underground_line.png",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/rest/gui_root/gsimages/meter.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/rest/gui_root/gsimages/regulator.png",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/rest/gui_root/gsimages/lightning.png",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/python/doc/build/html/objects.inv",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/python/doc/build/html/_static/comment-close.png",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/python/doc/build/html/_static/down.png",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/python/doc/build/html/_static/down-pressed.png",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/python/doc/build/html/_static/plus.png",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/python/doc/build/html/_static/comment-bright.png",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/python/doc/build/html/_static/comment.png",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/python/doc/build/html/_static/up-pressed.png",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/python/doc/build/html/_static/file.png",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/python/doc/build/html/_static/ajax-loader.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/python/doc/build/html/_static/up.png",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/python/doc/build/html/_static/minus.png",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/xml/ExportSynXML.xlsm",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/optimize/particle_swarm_optimization.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/matpower/matpower40_src/mips.m",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/matpower/matpower40_src/mips6.m",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/matpower/matpower40_src/extras/se/se_intro.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/matpower/matpower40_src/extras/cpf/cpf_intro.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/matpower/matpower40_src/docs/TN2-OPF-Derivatives.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/matpower/matpower40_src/docs/TN1-OPF-Auctions.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/matpower/matpower40_src/docs/manual.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/matpower/matpower40_src/t/soln9_opf_PQcap.mat",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/matpower/matpower40_src/t/soln9_dcopf.mat",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/matpower/matpower40_src/t/soln9_opf_Plim.mat",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/matpower/matpower40_src/t/soln9_pf.mat",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/matpower/matpower40_src/t/soln9_dcpf.mat",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/matpower/matpower40_src/t/soln9_opf.mat",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/matpower/matpower40_src/t/soln9_opf_extras1.mat",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/matpower/matpower40_src/t/soln9_opf_ang.mat",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/GldEditor/GldEditor.aps",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/GldEditor/res/Toolbar.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/GldEditor/res/GldEditorDoc.ico",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/GldEditor/res/GldEditor.ico",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/java/cvwin.class",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/java/ButtonPanel$BPAction.class",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/java/ButtonPanel$DoneListener.class",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/java/ClimateView.class",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/java/ButtonPanel.class",
        "/tmp/vanessa/spack-stage/spack-stage-gridlab-d-develop-rldcb3t4dxrxolmsmcgk5ttgyew7qkim/spack-src/java/gridlabd.jar"
    ],
    "total_files": 3604
}