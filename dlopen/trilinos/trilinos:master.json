{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/kokkos/core/src/impl/Kokkos_Profiling.cpp": "/*\n//@HEADER\n// ************************************************************************\n//\n//                        Kokkos v. 3.0\n//       Copyright (2020) National Technology & Engineering\n//               Solutions of Sandia, LLC (NTESS).\n//\n// Under the terms of Contract DE-NA0003525 with NTESS,\n// the U.S. Government retains certain rights in this software.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n// 1. Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright\n// notice, this list of conditions and the following disclaimer in the\n// documentation and/or other materials provided with the distribution.\n//\n// 3. Neither the name of the Corporation nor the names of the\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY NTESS \"AS IS\" AND ANY\n// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n// PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NTESS OR THE\n// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Questions? Contact Christian R. Trott (crtrott@sandia.gov)\n//\n// ************************************************************************\n//@HEADER\n*/\n\n#include <Kokkos_Macros.hpp>\n#include <Kokkos_Tuners.hpp>\n#include <impl/Kokkos_Profiling.hpp>\n#if defined(KOKKOS_ENABLE_LIBDL)\n#include <dlfcn.h>\n#endif\n\n#include <cstring>\n#include <unordered_map>\n#include <unordered_set>\n#include <algorithm>\n#include <vector>\n#include <array>\n#include <stack>\n#include <iostream>\nnamespace Kokkos {\n\nnamespace Tools {\n\nnamespace Experimental {\n#ifdef KOKKOS_ENABLE_TUNING\nstatic size_t kernel_name_context_variable_id;\nstatic size_t kernel_type_context_variable_id;\nstatic std::unordered_map<size_t, std::unordered_set<size_t>>\n    features_per_context;\nstatic std::unordered_set<size_t> active_features;\nstatic std::unordered_map<size_t, VariableValue> feature_values;\nstatic std::unordered_map<size_t, VariableInfo> variable_metadata;\n#endif\nstatic EventSet current_callbacks;\nstatic EventSet backup_callbacks;\nstatic EventSet no_profiling;\n\nbool eventSetsEqual(const EventSet& l, const EventSet& r) {\n  return l.init == r.init && l.finalize == r.finalize &&\n         l.begin_parallel_for == r.begin_parallel_for &&\n         l.end_parallel_for == r.end_parallel_for &&\n         l.begin_parallel_reduce == r.begin_parallel_reduce &&\n         l.end_parallel_reduce == r.end_parallel_reduce &&\n         l.begin_parallel_scan == r.begin_parallel_scan &&\n         l.end_parallel_scan == r.end_parallel_scan &&\n         l.push_region == r.push_region && l.pop_region == r.pop_region &&\n         l.allocate_data == r.allocate_data &&\n         l.deallocate_data == r.deallocate_data &&\n         l.create_profile_section == r.create_profile_section &&\n         l.start_profile_section == r.start_profile_section &&\n         l.stop_profile_section == r.stop_profile_section &&\n         l.destroy_profile_section == r.destroy_profile_section &&\n         l.profile_event == r.profile_event &&\n         l.begin_deep_copy == r.begin_deep_copy &&\n         l.end_deep_copy == r.end_deep_copy && l.begin_fence == r.begin_fence &&\n         l.end_fence == r.end_fence && l.sync_dual_view == r.sync_dual_view &&\n         l.modify_dual_view == r.modify_dual_view &&\n         l.declare_input_type == r.declare_input_type &&\n         l.declare_output_type == r.declare_output_type &&\n         l.end_tuning_context == r.end_tuning_context &&\n         l.begin_tuning_context == r.begin_tuning_context &&\n         l.request_output_values == r.request_output_values &&\n         l.declare_optimization_goal == r.declare_optimization_goal;\n}\n}  // namespace Experimental\nbool profileLibraryLoaded() {\n  return !Experimental::eventSetsEqual(Experimental::current_callbacks,\n                                       Experimental::no_profiling);\n}\n\nvoid beginParallelFor(const std::string& kernelPrefix, const uint32_t devID,\n                      uint64_t* kernelID) {\n  if (Experimental::current_callbacks.begin_parallel_for != nullptr) {\n    Kokkos::fence();\n    (*Experimental::current_callbacks.begin_parallel_for)(kernelPrefix.c_str(),\n                                                          devID, kernelID);\n  }\n#ifdef KOKKOS_ENABLE_TUNING\n  if (Kokkos::tune_internals()) {\n    auto context_id = Experimental::get_new_context_id();\n    Experimental::begin_context(context_id);\n    Experimental::VariableValue contextValues[] = {\n        Experimental::make_variable_value(\n            Experimental::kernel_name_context_variable_id, kernelPrefix),\n        Experimental::make_variable_value(\n            Experimental::kernel_type_context_variable_id, \"parallel_for\")};\n    Experimental::set_input_values(context_id, 2, contextValues);\n  }\n#endif\n}\n\nvoid endParallelFor(const uint64_t kernelID) {\n  if (Experimental::current_callbacks.end_parallel_for != nullptr) {\n    Kokkos::fence();\n    (*Experimental::current_callbacks.end_parallel_for)(kernelID);\n  }\n#ifdef KOKKOS_ENABLE_TUNING\n  if (Kokkos::tune_internals()) {\n    Experimental::end_context(Experimental::get_current_context_id());\n  }\n#endif\n}\n\nvoid beginParallelScan(const std::string& kernelPrefix, const uint32_t devID,\n                       uint64_t* kernelID) {\n  if (Experimental::current_callbacks.begin_parallel_scan != nullptr) {\n    Kokkos::fence();\n    (*Experimental::current_callbacks.begin_parallel_scan)(kernelPrefix.c_str(),\n                                                           devID, kernelID);\n  }\n#ifdef KOKKOS_ENABLE_TUNING\n  if (Kokkos::tune_internals()) {\n    auto context_id = Experimental::get_new_context_id();\n    Experimental::begin_context(context_id);\n    Experimental::VariableValue contextValues[] = {\n        Experimental::make_variable_value(\n            Experimental::kernel_name_context_variable_id, kernelPrefix),\n        Experimental::make_variable_value(\n            Experimental::kernel_type_context_variable_id, \"parallel_for\")};\n    Experimental::set_input_values(context_id, 2, contextValues);\n  }\n#endif\n}\n\nvoid endParallelScan(const uint64_t kernelID) {\n  if (Experimental::current_callbacks.end_parallel_scan != nullptr) {\n    Kokkos::fence();\n    (*Experimental::current_callbacks.end_parallel_scan)(kernelID);\n  }\n#ifdef KOKKOS_ENABLE_TUNING\n  if (Kokkos::tune_internals()) {\n    Experimental::end_context(Experimental::get_current_context_id());\n  }\n#endif\n}\n\nvoid beginParallelReduce(const std::string& kernelPrefix, const uint32_t devID,\n                         uint64_t* kernelID) {\n  if (Experimental::current_callbacks.begin_parallel_reduce != nullptr) {\n    Kokkos::fence();\n    (*Experimental::current_callbacks.begin_parallel_reduce)(\n        kernelPrefix.c_str(), devID, kernelID);\n  }\n#ifdef KOKKOS_ENABLE_TUNING\n  if (Kokkos::tune_internals()) {\n    auto context_id = Experimental::get_new_context_id();\n    Experimental::begin_context(context_id);\n    Experimental::VariableValue contextValues[] = {\n        Experimental::make_variable_value(\n            Experimental::kernel_name_context_variable_id, kernelPrefix),\n        Experimental::make_variable_value(\n            Experimental::kernel_type_context_variable_id, \"parallel_for\")};\n    Experimental::set_input_values(context_id, 2, contextValues);\n  }\n#endif\n}\n\nvoid endParallelReduce(const uint64_t kernelID) {\n  if (Experimental::current_callbacks.end_parallel_reduce != nullptr) {\n    Kokkos::fence();\n    (*Experimental::current_callbacks.end_parallel_reduce)(kernelID);\n  }\n#ifdef KOKKOS_ENABLE_TUNING\n  if (Kokkos::tune_internals()) {\n    Experimental::end_context(Experimental::get_current_context_id());\n  }\n#endif\n}\n\nvoid pushRegion(const std::string& kName) {\n  if (Experimental::current_callbacks.push_region != nullptr) {\n    Kokkos::fence();\n    (*Experimental::current_callbacks.push_region)(kName.c_str());\n  }\n}\n\nvoid popRegion() {\n  if (Experimental::current_callbacks.pop_region != nullptr) {\n    Kokkos::fence();\n    (*Experimental::current_callbacks.pop_region)();\n  }\n}\n\nvoid allocateData(const SpaceHandle space, const std::string label,\n                  const void* ptr, const uint64_t size) {\n  if (Experimental::current_callbacks.allocate_data != nullptr) {\n    (*Experimental::current_callbacks.allocate_data)(space, label.c_str(), ptr,\n                                                     size);\n  }\n}\n\nvoid deallocateData(const SpaceHandle space, const std::string label,\n                    const void* ptr, const uint64_t size) {\n  if (Experimental::current_callbacks.deallocate_data != nullptr) {\n    (*Experimental::current_callbacks.deallocate_data)(space, label.c_str(),\n                                                       ptr, size);\n  }\n}\n\nvoid beginDeepCopy(const SpaceHandle dst_space, const std::string dst_label,\n                   const void* dst_ptr, const SpaceHandle src_space,\n                   const std::string src_label, const void* src_ptr,\n                   const uint64_t size) {\n  if (Experimental::current_callbacks.begin_deep_copy != nullptr) {\n    (*Experimental::current_callbacks.begin_deep_copy)(\n        dst_space, dst_label.c_str(), dst_ptr, src_space, src_label.c_str(),\n        src_ptr, size);\n#ifdef KOKKOS_ENABLE_TUNING\n    if (Kokkos::tune_internals()) {\n      auto context_id = Experimental::get_new_context_id();\n      Experimental::begin_context(context_id);\n      Experimental::VariableValue contextValues[] = {\n          Experimental::make_variable_value(\n              Experimental::kernel_name_context_variable_id,\n              \"deep_copy_kernel\"),\n          Experimental::make_variable_value(\n              Experimental::kernel_type_context_variable_id, \"deep_copy\")};\n      Experimental::set_input_values(context_id, 2, contextValues);\n    }\n#endif\n  }\n}\n\nvoid endDeepCopy() {\n  if (Experimental::current_callbacks.end_deep_copy != nullptr) {\n    (*Experimental::current_callbacks.end_deep_copy)();\n#ifdef KOKKOS_ENABLE_TUNING\n    if (Kokkos::tune_internals()) {\n      Experimental::end_context(Experimental::get_current_context_id());\n    }\n#endif\n  }\n}\n\nvoid beginFence(const std::string name, const uint32_t deviceId,\n                uint64_t* handle) {\n  if (Experimental::current_callbacks.begin_fence != nullptr) {\n    (*Experimental::current_callbacks.begin_fence)(name.c_str(), deviceId,\n                                                   handle);\n  }\n}\n\nvoid endFence(const uint64_t handle) {\n  if (Experimental::current_callbacks.end_fence != nullptr) {\n    (*Experimental::current_callbacks.end_fence)(handle);\n  }\n}\n\nvoid createProfileSection(const std::string& sectionName, uint32_t* secID) {\n  if (Experimental::current_callbacks.create_profile_section != nullptr) {\n    (*Experimental::current_callbacks.create_profile_section)(\n        sectionName.c_str(), secID);\n  }\n}\n\nvoid startSection(const uint32_t secID) {\n  if (Experimental::current_callbacks.start_profile_section != nullptr) {\n    (*Experimental::current_callbacks.start_profile_section)(secID);\n  }\n}\n\nvoid stopSection(const uint32_t secID) {\n  if (Experimental::current_callbacks.stop_profile_section != nullptr) {\n    (*Experimental::current_callbacks.stop_profile_section)(secID);\n  }\n}\n\nvoid destroyProfileSection(const uint32_t secID) {\n  if (Experimental::current_callbacks.destroy_profile_section != nullptr) {\n    (*Experimental::current_callbacks.destroy_profile_section)(secID);\n  }\n}\n\nvoid markEvent(const std::string& eventName) {\n  if (Experimental::current_callbacks.profile_event != nullptr) {\n    (*Experimental::current_callbacks.profile_event)(eventName.c_str());\n  }\n}\n\nSpaceHandle make_space_handle(const char* space_name) {\n  SpaceHandle handle;\n  strncpy(handle.name, space_name, 63);\n  return handle;\n}\n\nvoid initialize() {\n  // Make sure initialize calls happens only once\n  static int is_initialized = 0;\n  if (is_initialized) return;\n  is_initialized = 1;\n\n#ifdef KOKKOS_ENABLE_LIBDL\n  void* firstProfileLibrary = nullptr;\n\n  char* envProfileLibrary = getenv(\"KOKKOS_PROFILE_LIBRARY\");\n\n  // If we do not find a profiling library in the environment then exit\n  // early.\n  if (envProfileLibrary == nullptr) {\n    return;\n  }\n\n  char* envProfileCopy =\n      (char*)malloc(sizeof(char) * (strlen(envProfileLibrary) + 1));\n  sprintf(envProfileCopy, \"%s\", envProfileLibrary);\n\n  char* profileLibraryName = strtok(envProfileCopy, \";\");\n\n  if ((profileLibraryName != nullptr) &&\n      (strcmp(profileLibraryName, \"\") != 0)) {\n    firstProfileLibrary = dlopen(profileLibraryName, RTLD_NOW | RTLD_GLOBAL);\n\n    if (firstProfileLibrary == nullptr) {\n      std::cerr << \"Error: Unable to load KokkosP library: \"\n                << profileLibraryName << std::endl;\n      std::cerr << \"dlopen(\" << profileLibraryName\n                << \", RTLD_NOW | RTLD_GLOBAL) failed with \" << dlerror()\n                << '\\n';\n    } else {\n#ifdef KOKKOS_ENABLE_PROFILING_LOAD_PRINT\n      std::cout << \"KokkosP: Library Loaded: \" << profileLibraryName\n                << std::endl;\n#endif\n      // dlsym returns a pointer to an object, while we want to assign to\n      // pointer to function A direct cast will give warnings hence, we have to\n      // workaround the issue by casting pointer to pointers.\n      auto p1 = dlsym(firstProfileLibrary, \"kokkosp_begin_parallel_for\");\n      Experimental::set_begin_parallel_for_callback(\n          *reinterpret_cast<beginFunction*>(&p1));\n      auto p2 = dlsym(firstProfileLibrary, \"kokkosp_begin_parallel_scan\");\n      Experimental::set_begin_parallel_scan_callback(\n          *reinterpret_cast<beginFunction*>(&p2));\n      auto p3 = dlsym(firstProfileLibrary, \"kokkosp_begin_parallel_reduce\");\n      Experimental::set_begin_parallel_reduce_callback(\n          *reinterpret_cast<beginFunction*>(&p3));\n\n      auto p4 = dlsym(firstProfileLibrary, \"kokkosp_end_parallel_scan\");\n      Experimental::set_end_parallel_scan_callback(\n          *reinterpret_cast<endFunction*>(&p4));\n      auto p5 = dlsym(firstProfileLibrary, \"kokkosp_end_parallel_for\");\n      Experimental::set_end_parallel_for_callback(\n          *reinterpret_cast<endFunction*>(&p5));\n      auto p6 = dlsym(firstProfileLibrary, \"kokkosp_end_parallel_reduce\");\n      Experimental::set_end_parallel_reduce_callback(\n          *reinterpret_cast<endFunction*>(&p6));\n\n      auto p7 = dlsym(firstProfileLibrary, \"kokkosp_init_library\");\n      Experimental::set_init_callback(*reinterpret_cast<initFunction*>(&p7));\n      auto p8 = dlsym(firstProfileLibrary, \"kokkosp_finalize_library\");\n      Experimental::set_finalize_callback(\n          *reinterpret_cast<finalizeFunction*>(&p8));\n\n      auto p9 = dlsym(firstProfileLibrary, \"kokkosp_push_profile_region\");\n      Experimental::set_push_region_callback(\n          *reinterpret_cast<pushFunction*>(&p9));\n      auto p10 = dlsym(firstProfileLibrary, \"kokkosp_pop_profile_region\");\n      Experimental::set_pop_region_callback(\n          *reinterpret_cast<popFunction*>(&p10));\n\n      auto p11 = dlsym(firstProfileLibrary, \"kokkosp_allocate_data\");\n      Experimental::set_allocate_data_callback(\n          *reinterpret_cast<allocateDataFunction*>(&p11));\n      auto p12 = dlsym(firstProfileLibrary, \"kokkosp_deallocate_data\");\n      Experimental::set_deallocate_data_callback(\n          *reinterpret_cast<deallocateDataFunction*>(&p12));\n\n      auto p13 = dlsym(firstProfileLibrary, \"kokkosp_begin_deep_copy\");\n      Experimental::set_begin_deep_copy_callback(\n          *reinterpret_cast<beginDeepCopyFunction*>(&p13));\n      auto p14 = dlsym(firstProfileLibrary, \"kokkosp_end_deep_copy\");\n      Experimental::set_end_deep_copy_callback(\n          *reinterpret_cast<endDeepCopyFunction*>(&p14));\n\n      auto p15 = dlsym(firstProfileLibrary, \"kokkosp_begin_fence\");\n      Experimental::set_begin_fence_callback(\n          *reinterpret_cast<beginFenceFunction*>(&p15));\n      auto p16 = dlsym(firstProfileLibrary, \"kokkosp_end_fence\");\n      Experimental::set_end_fence_callback(\n          *reinterpret_cast<endFenceFunction*>(&p16));\n\n      auto p17 = dlsym(firstProfileLibrary, \"kokkosp_dual_view_sync\");\n      Experimental::set_dual_view_sync_callback(\n          *reinterpret_cast<dualViewSyncFunction*>(&p17));\n      auto p18 = dlsym(firstProfileLibrary, \"kokkosp_dual_view_modify\");\n      Experimental::set_dual_view_modify_callback(\n          *reinterpret_cast<dualViewModifyFunction*>(&p18));\n\n      auto p19 = dlsym(firstProfileLibrary, \"kokkosp_create_profile_section\");\n      Experimental::set_create_profile_section_callback(\n          *(reinterpret_cast<createProfileSectionFunction*>(&p19)));\n      auto p20 = dlsym(firstProfileLibrary, \"kokkosp_start_profile_section\");\n      Experimental::set_start_profile_section_callback(\n          *reinterpret_cast<startProfileSectionFunction*>(&p20));\n      auto p21 = dlsym(firstProfileLibrary, \"kokkosp_stop_profile_section\");\n      Experimental::set_stop_profile_section_callback(\n          *reinterpret_cast<stopProfileSectionFunction*>(&p21));\n      auto p22 = dlsym(firstProfileLibrary, \"kokkosp_destroy_profile_section\");\n      Experimental::set_destroy_profile_section_callback(\n          *(reinterpret_cast<destroyProfileSectionFunction*>(&p22)));\n\n      auto p23 = dlsym(firstProfileLibrary, \"kokkosp_profile_event\");\n      Experimental::set_profile_event_callback(\n          *reinterpret_cast<profileEventFunction*>(&p23));\n\n#ifdef KOKKOS_ENABLE_TUNING\n      auto p24 = dlsym(firstProfileLibrary, \"kokkosp_declare_output_type\");\n      Experimental::set_declare_output_type_callback(\n          *reinterpret_cast<Experimental::outputTypeDeclarationFunction*>(\n              &p24));\n\n      auto p25 = dlsym(firstProfileLibrary, \"kokkosp_declare_input_type\");\n      Experimental::set_declare_input_type_callback(\n          *reinterpret_cast<Experimental::inputTypeDeclarationFunction*>(&p25));\n      auto p26 = dlsym(firstProfileLibrary, \"kokkosp_request_values\");\n      Experimental::set_request_output_values_callback(\n          *reinterpret_cast<Experimental::requestValueFunction*>(&p26));\n      auto p27 = dlsym(firstProfileLibrary, \"kokkosp_end_context\");\n      Experimental::set_end_context_callback(\n          *reinterpret_cast<Experimental::contextEndFunction*>(&p27));\n      auto p28 = dlsym(firstProfileLibrary, \"kokkosp_begin_context\");\n      Experimental::set_begin_context_callback(\n          *reinterpret_cast<Experimental::contextBeginFunction*>(&p28));\n      auto p29 =\n          dlsym(firstProfileLibrary, \"kokkosp_declare_optimization_goal\");\n      Experimental::set_declare_optimization_goal_callback(\n          *reinterpret_cast<Experimental::optimizationGoalDeclarationFunction*>(\n              &p29));\n#endif  // KOKKOS_ENABLE_TUNING\n    }\n  }\n#endif  // KOKKOS_ENABLE_LIBDL\n  if (Experimental::current_callbacks.init != nullptr) {\n    (*Experimental::current_callbacks.init)(\n        0, (uint64_t)KOKKOSP_INTERFACE_VERSION, (uint32_t)0, nullptr);\n  }\n\n#ifdef KOKKOS_ENABLE_TUNING\n  Experimental::VariableInfo kernel_name;\n  kernel_name.type = Experimental::ValueType::kokkos_value_string;\n  kernel_name.category =\n      Experimental::StatisticalCategory::kokkos_value_categorical;\n  kernel_name.valueQuantity =\n      Experimental::CandidateValueType::kokkos_value_unbounded;\n\n  std::array<std::string, 4> candidate_values = {\n      \"parallel_for\",\n      \"parallel_reduce\",\n      \"parallel_scan\",\n      \"parallel_copy\",\n  };\n\n  Experimental::SetOrRange kernel_type_variable_candidates =\n      Experimental::make_candidate_set(4, candidate_values.data());\n\n  Experimental::kernel_name_context_variable_id =\n      Experimental::declare_input_type(\"kokkos.kernel_name\", kernel_name);\n\n  Experimental::VariableInfo kernel_type;\n  kernel_type.type = Experimental::ValueType::kokkos_value_string;\n  kernel_type.category =\n      Experimental::StatisticalCategory::kokkos_value_categorical;\n  kernel_type.valueQuantity =\n      Experimental::CandidateValueType::kokkos_value_set;\n  kernel_type.candidates = kernel_type_variable_candidates;\n  Experimental::kernel_type_context_variable_id =\n      Experimental::declare_input_type(\"kokkos.kernel_type\", kernel_type);\n\n#endif\n\n  Experimental::no_profiling.init     = nullptr;\n  Experimental::no_profiling.finalize = nullptr;\n\n  Experimental::no_profiling.begin_parallel_for    = nullptr;\n  Experimental::no_profiling.begin_parallel_scan   = nullptr;\n  Experimental::no_profiling.begin_parallel_reduce = nullptr;\n  Experimental::no_profiling.end_parallel_scan     = nullptr;\n  Experimental::no_profiling.end_parallel_for      = nullptr;\n  Experimental::no_profiling.end_parallel_reduce   = nullptr;\n\n  Experimental::no_profiling.push_region     = nullptr;\n  Experimental::no_profiling.pop_region      = nullptr;\n  Experimental::no_profiling.allocate_data   = nullptr;\n  Experimental::no_profiling.deallocate_data = nullptr;\n\n  Experimental::no_profiling.begin_deep_copy = nullptr;\n  Experimental::no_profiling.end_deep_copy   = nullptr;\n\n  Experimental::no_profiling.create_profile_section  = nullptr;\n  Experimental::no_profiling.start_profile_section   = nullptr;\n  Experimental::no_profiling.stop_profile_section    = nullptr;\n  Experimental::no_profiling.destroy_profile_section = nullptr;\n\n  Experimental::no_profiling.profile_event = nullptr;\n\n  Experimental::no_profiling.declare_input_type    = nullptr;\n  Experimental::no_profiling.declare_output_type   = nullptr;\n  Experimental::no_profiling.request_output_values = nullptr;\n  Experimental::no_profiling.end_tuning_context    = nullptr;\n#ifdef KOKKOS_ENABLE_LIBDL\n  free(envProfileCopy);\n#endif\n}\n\nvoid finalize() {\n  // Make sure finalize calls happens only once\n  static int is_finalized = 0;\n  if (is_finalized) return;\n  is_finalized = 1;\n\n  if (Experimental::current_callbacks.finalize != nullptr) {\n    (*Experimental::current_callbacks.finalize)();\n\n    Experimental::pause_tools();\n  }\n#ifdef KOKKOS_ENABLE_TUNING\n  // clean up string candidate set\n  for (auto& metadata_pair : Experimental::variable_metadata) {\n    auto metadata = metadata_pair.second;\n    if ((metadata.type == Experimental::ValueType::kokkos_value_string) &&\n        (metadata.valueQuantity ==\n         Experimental::CandidateValueType::kokkos_value_set)) {\n      auto candidate_set = metadata.candidates.set;\n      delete[] candidate_set.values.string_value;\n    }\n  }\n#endif\n}\n\nvoid syncDualView(const std::string& label, const void* const ptr,\n                  bool to_device) {\n  if (Experimental::current_callbacks.sync_dual_view != nullptr) {\n    (*Experimental::current_callbacks.sync_dual_view)(label.c_str(), ptr,\n                                                      to_device);\n  }\n}\nvoid modifyDualView(const std::string& label, const void* const ptr,\n                    bool on_device) {\n  if (Experimental::current_callbacks.modify_dual_view != nullptr) {\n    (*Experimental::current_callbacks.modify_dual_view)(label.c_str(), ptr,\n                                                        on_device);\n  }\n}\n\n}  // namespace Tools\n\nnamespace Tools {\nnamespace Experimental {\nvoid set_init_callback(initFunction callback) {\n  current_callbacks.init = callback;\n}\nvoid set_finalize_callback(finalizeFunction callback) {\n  current_callbacks.finalize = callback;\n}\nvoid set_begin_parallel_for_callback(beginFunction callback) {\n  current_callbacks.begin_parallel_for = callback;\n}\nvoid set_end_parallel_for_callback(endFunction callback) {\n  current_callbacks.end_parallel_for = callback;\n}\nvoid set_begin_parallel_reduce_callback(beginFunction callback) {\n  current_callbacks.begin_parallel_reduce = callback;\n}\nvoid set_end_parallel_reduce_callback(endFunction callback) {\n  current_callbacks.end_parallel_reduce = callback;\n}\nvoid set_begin_parallel_scan_callback(beginFunction callback) {\n  current_callbacks.begin_parallel_scan = callback;\n}\nvoid set_end_parallel_scan_callback(endFunction callback) {\n  current_callbacks.end_parallel_scan = callback;\n}\nvoid set_push_region_callback(pushFunction callback) {\n  current_callbacks.push_region = callback;\n}\nvoid set_pop_region_callback(popFunction callback) {\n  current_callbacks.pop_region = callback;\n}\nvoid set_allocate_data_callback(allocateDataFunction callback) {\n  current_callbacks.allocate_data = callback;\n}\nvoid set_deallocate_data_callback(deallocateDataFunction callback) {\n  current_callbacks.deallocate_data = callback;\n}\nvoid set_create_profile_section_callback(\n    createProfileSectionFunction callback) {\n  current_callbacks.create_profile_section = callback;\n}\nvoid set_start_profile_section_callback(startProfileSectionFunction callback) {\n  current_callbacks.start_profile_section = callback;\n}\nvoid set_stop_profile_section_callback(stopProfileSectionFunction callback) {\n  current_callbacks.stop_profile_section = callback;\n}\nvoid set_destroy_profile_section_callback(\n    destroyProfileSectionFunction callback) {\n  current_callbacks.destroy_profile_section = callback;\n}\nvoid set_profile_event_callback(profileEventFunction callback) {\n  current_callbacks.profile_event = callback;\n}\nvoid set_begin_deep_copy_callback(beginDeepCopyFunction callback) {\n  current_callbacks.begin_deep_copy = callback;\n}\nvoid set_end_deep_copy_callback(endDeepCopyFunction callback) {\n  current_callbacks.end_deep_copy = callback;\n}\nvoid set_begin_fence_callback(beginFenceFunction callback) {\n  current_callbacks.begin_fence = callback;\n}\nvoid set_end_fence_callback(endFenceFunction callback) {\n  current_callbacks.end_fence = callback;\n}\n\nvoid set_dual_view_sync_callback(dualViewSyncFunction callback) {\n  current_callbacks.sync_dual_view = callback;\n}\nvoid set_dual_view_modify_callback(dualViewModifyFunction callback) {\n  current_callbacks.modify_dual_view = callback;\n}\n\nvoid set_declare_output_type_callback(outputTypeDeclarationFunction callback) {\n  current_callbacks.declare_output_type = callback;\n}\nvoid set_declare_input_type_callback(inputTypeDeclarationFunction callback) {\n  current_callbacks.declare_input_type = callback;\n}\nvoid set_request_output_values_callback(requestValueFunction callback) {\n  current_callbacks.request_output_values = callback;\n}\nvoid set_end_context_callback(contextEndFunction callback) {\n  current_callbacks.end_tuning_context = callback;\n}\nvoid set_begin_context_callback(contextBeginFunction callback) {\n  current_callbacks.begin_tuning_context = callback;\n}\nvoid set_declare_optimization_goal_callback(\n    optimizationGoalDeclarationFunction callback) {\n  current_callbacks.declare_optimization_goal = callback;\n}\n\nvoid pause_tools() {\n  backup_callbacks  = current_callbacks;\n  current_callbacks = no_profiling;\n}\n\nvoid resume_tools() { current_callbacks = backup_callbacks; }\n\nEventSet get_callbacks() { return current_callbacks; }\nvoid set_callbacks(EventSet new_events) { current_callbacks = new_events; }\n}  // namespace Experimental\n}  // namespace Tools\n\nnamespace Profiling {\nbool profileLibraryLoaded() { return Kokkos::Tools::profileLibraryLoaded(); }\n\nvoid beginParallelFor(const std::string& kernelPrefix, const uint32_t devID,\n                      uint64_t* kernelID) {\n  Kokkos::Tools::beginParallelFor(kernelPrefix, devID, kernelID);\n}\nvoid beginParallelReduce(const std::string& kernelPrefix, const uint32_t devID,\n                         uint64_t* kernelID) {\n  Kokkos::Tools::beginParallelReduce(kernelPrefix, devID, kernelID);\n}\nvoid beginParallelScan(const std::string& kernelPrefix, const uint32_t devID,\n                       uint64_t* kernelID) {\n  Kokkos::Tools::beginParallelScan(kernelPrefix, devID, kernelID);\n}\nvoid endParallelFor(const uint64_t kernelID) {\n  Kokkos::Tools::endParallelFor(kernelID);\n}\nvoid endParallelReduce(const uint64_t kernelID) {\n  Kokkos::Tools::endParallelReduce(kernelID);\n}\nvoid endParallelScan(const uint64_t kernelID) {\n  Kokkos::Tools::endParallelScan(kernelID);\n}\n\nvoid pushRegion(const std::string& kName) { Kokkos::Tools::pushRegion(kName); }\nvoid popRegion() { Kokkos::Tools::popRegion(); }\n\nvoid createProfileSection(const std::string& sectionName, uint32_t* secID) {\n  Kokkos::Tools::createProfileSection(sectionName, secID);\n}\nvoid destroyProfileSection(const uint32_t secID) {\n  Kokkos::Tools::destroyProfileSection(secID);\n}\n\nvoid startSection(const uint32_t secID) { Kokkos::Tools::startSection(secID); }\n\nvoid stopSection(const uint32_t secID) { Kokkos::Tools::stopSection(secID); }\n\nvoid markEvent(const std::string& eventName) {\n  Kokkos::Tools::markEvent(eventName);\n}\nvoid allocateData(const SpaceHandle handle, const std::string name,\n                  const void* data, const uint64_t size) {\n  Kokkos::Tools::allocateData(handle, name, data, size);\n}\nvoid deallocateData(const SpaceHandle space, const std::string label,\n                    const void* ptr, const uint64_t size) {\n  Kokkos::Tools::deallocateData(space, label, ptr, size);\n}\n\nvoid beginDeepCopy(const SpaceHandle dst_space, const std::string dst_label,\n                   const void* dst_ptr, const SpaceHandle src_space,\n                   const std::string src_label, const void* src_ptr,\n                   const uint64_t size) {\n  Kokkos::Tools::beginDeepCopy(dst_space, dst_label, dst_ptr, src_space,\n                               src_label, src_ptr, size);\n}\nvoid endDeepCopy() { Kokkos::Tools::endDeepCopy(); }\n\nvoid finalize() { Kokkos::Tools::finalize(); }\nvoid initialize() { Kokkos::Tools::initialize(); }\n\nSpaceHandle make_space_handle(const char* space_name) {\n  return Kokkos::Tools::make_space_handle(space_name);\n}\n}  // namespace Profiling\n\n}  // namespace Kokkos\n\n// Tuning\n\nnamespace Kokkos {\nnamespace Tools {\nnamespace Experimental {\nstatic size_t& get_context_counter() {\n  static size_t x;\n  return x;\n}\nstatic size_t& get_variable_counter() {\n  static size_t x;\n  return ++x;\n}\n\nsize_t get_new_context_id() { return ++get_context_counter(); }\nsize_t get_current_context_id() { return get_context_counter(); }\nvoid decrement_current_context_id() { --get_context_counter(); }\nsize_t get_new_variable_id() { return get_variable_counter(); }\n\nsize_t declare_output_type(const std::string& variableName, VariableInfo info) {\n  size_t variableId = get_new_variable_id();\n#ifdef KOKKOS_ENABLE_TUNING\n  if (Experimental::current_callbacks.declare_output_type != nullptr) {\n    (*Experimental::current_callbacks.declare_output_type)(variableName.c_str(),\n                                                           variableId, &info);\n  }\n  variable_metadata[variableId] = info;\n#else\n  (void)variableName;\n  (void)info;\n#endif\n  return variableId;\n}\n\nsize_t declare_input_type(const std::string& variableName, VariableInfo info) {\n  size_t variableId = get_new_variable_id();\n#ifdef KOKKOS_ENABLE_TUNING\n  if (Experimental::current_callbacks.declare_input_type != nullptr) {\n    (*Experimental::current_callbacks.declare_input_type)(variableName.c_str(),\n                                                          variableId, &info);\n  }\n  variable_metadata[variableId] = info;\n#else\n  (void)variableName;\n  (void)info;\n#endif\n  return variableId;\n}\n\nvoid set_input_values(size_t contextId, size_t count, VariableValue* values) {\n#ifdef KOKKOS_ENABLE_TUNING\n  if (features_per_context.find(contextId) == features_per_context.end()) {\n    features_per_context[contextId] = std::unordered_set<size_t>();\n  }\n  for (size_t x = 0; x < count; ++x) {\n    values[x].metadata = &variable_metadata[values[x].type_id];\n    features_per_context[contextId].insert(values[x].type_id);\n    active_features.insert(values[x].type_id);\n    feature_values[values[x].type_id] = values[x];\n  }\n#else\n  (void)contextId;\n  (void)count;\n  (void)values;\n#endif\n}\n#include <iostream>\nvoid request_output_values(size_t contextId, size_t count,\n                           VariableValue* values) {\n#ifdef KOKKOS_ENABLE_TUNING\n  std::vector<size_t> context_ids;\n  std::vector<VariableValue> context_values;\n  for (auto id : active_features) {\n    context_values.push_back(feature_values[id]);\n  }\n  if (Experimental::current_callbacks.request_output_values != nullptr) {\n    for (size_t x = 0; x < count; ++x) {\n      values[x].metadata = &variable_metadata[values[x].type_id];\n    }\n    (*Experimental::current_callbacks.request_output_values)(\n        contextId, context_values.size(), context_values.data(), count, values);\n  }\n#else\n  (void)contextId;\n  (void)count;\n  (void)values;\n#endif\n}\n\n#ifdef KOKKOS_ENABLE_TUNING\nstatic std::unordered_map<size_t, size_t> optimization_goals;\n#endif\n\nvoid begin_context(size_t contextId) {\n  if (Experimental::current_callbacks.begin_tuning_context != nullptr) {\n    (*Experimental::current_callbacks.begin_tuning_context)(contextId);\n  }\n}\nvoid end_context(size_t contextId) {\n#ifdef KOKKOS_ENABLE_TUNING\n  for (auto id : features_per_context[contextId]) {\n    active_features.erase(id);\n  }\n  if (Experimental::current_callbacks.end_tuning_context != nullptr) {\n    (*Experimental::current_callbacks.end_tuning_context)(\n        contextId, feature_values[optimization_goals[contextId]]);\n  }\n  optimization_goals.erase(contextId);\n  decrement_current_context_id();\n#else\n  (void)contextId;\n#endif\n}\n\nbool have_tuning_tool() {\n#ifdef KOKKOS_ENABLE_TUNING\n  return (Experimental::current_callbacks.request_output_values != nullptr);\n#else\n  return false;\n#endif\n}\n\nVariableValue make_variable_value(size_t id, int64_t val) {\n  VariableValue variable_value;\n  variable_value.type_id         = id;\n  variable_value.value.int_value = val;\n  return variable_value;\n}\nVariableValue make_variable_value(size_t id, double val) {\n  VariableValue variable_value;\n  variable_value.type_id            = id;\n  variable_value.value.double_value = val;\n  return variable_value;\n}\nVariableValue make_variable_value(size_t id, const std::string& val) {\n  VariableValue variable_value;\n  variable_value.type_id = id;\n  strncpy(variable_value.value.string_value, val.c_str(),\n          KOKKOS_TOOLS_TUNING_STRING_LENGTH - 1);\n  return variable_value;\n}\nSetOrRange make_candidate_set(size_t size, std::string* data) {\n  SetOrRange value_set;\n  value_set.set.values.string_value = new TuningString[size];\n  for (size_t x = 0; x < size; ++x) {\n    strncpy(value_set.set.values.string_value[x], data[x].c_str(),\n            KOKKOS_TOOLS_TUNING_STRING_LENGTH - 1);\n  }\n  value_set.set.size = size;\n  return value_set;\n}\nSetOrRange make_candidate_set(size_t size, int64_t* data) {\n  SetOrRange value_set;\n  value_set.set.size             = size;\n  value_set.set.values.int_value = data;\n  return value_set;\n}\nSetOrRange make_candidate_set(size_t size, double* data) {\n  SetOrRange value_set;\n  value_set.set.size                = size;\n  value_set.set.values.double_value = data;\n  return value_set;\n}\nSetOrRange make_candidate_range(double lower, double upper, double step,\n                                bool openLower = false,\n                                bool openUpper = false) {\n  SetOrRange value_range;\n  value_range.range.lower.double_value = lower;\n  value_range.range.upper.double_value = upper;\n  value_range.range.step.double_value  = step;\n  value_range.range.openLower          = openLower;\n  value_range.range.openUpper          = openUpper;\n  return value_range;\n}\n\nSetOrRange make_candidate_range(int64_t lower, int64_t upper, int64_t step,\n                                bool openLower = false,\n                                bool openUpper = false) {\n  SetOrRange value_range;\n  value_range.range.lower.int_value = lower;\n  value_range.range.upper.int_value = upper;\n  value_range.range.step.int_value  = step;\n  value_range.range.openLower       = openLower;\n  value_range.range.openUpper       = openUpper;\n  return value_range;\n}\n\nsize_t get_new_context_id();\nsize_t get_current_context_id();\nvoid decrement_current_context_id();\nsize_t get_new_variable_id();\nvoid declare_optimization_goal(const size_t context,\n                               const OptimizationGoal& goal) {\n#ifdef KOKKOS_ENABLE_TUNING\n  if (Experimental::current_callbacks.declare_optimization_goal != nullptr) {\n    (*Experimental::current_callbacks.declare_optimization_goal)(context, goal);\n  }\n  optimization_goals[context] = goal.type_id;\n#else\n  (void)context;\n  (void)goal;\n#endif\n}\n}  // end namespace Experimental\n}  // end namespace Tools\n\n}  // end namespace Kokkos\n",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/sacado/test/GTestSuite/googletest/googletest/cmake/libgtest.la.in": "# libgtest.la - a libtool library file\n# Generated by libtool (GNU libtool) 2.4.6\n\n# Please DO NOT delete this file!\n# It is necessary for linking the library.\n\n# Names of this library.\nlibrary_names='libgtest.so'\n\n# Is this an already installed library?\ninstalled=yes\n\n# Should we warn about portability when linking against -modules?\nshouldnotlink=no\n\n# Files to dlopen/dlpreopen\ndlopen=''\ndlpreopen=''\n\n# Directory that this library needs to be installed in:\nlibdir='@CMAKE_INSTALL_FULL_LIBDIR@'\n",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/PyTrilinos/ReleaseNotes.txt": "Release Notes for PyTrilinos for Trilinos 12.12\n===============================================\n\nGeneral\n  * PyTrilinos now works with both Python versions 2 and 3\n  * Internally, PyTrilinos now uses relative imports\n  * Protect against Doxygen version 1.8.13\n\nTeuchos\n  * Fix ParameterList __cmp__() operator\n  * Improved memory management for wrapped version of sublists\n  * Fixed a memory leak in the definitions for certain directorin\n    typemaps\n\nEpetra\n  * Add AsMap() method to Epetra.BlockMap class\n\nML\n  * Fixed a dangling reference error in an ML example script.\n\nLOCA\n  * Fixed a memory leak in LOCA example script\n  * Fixed a memory leak in the wrappers for the\n    LOCA::Abstract::Iterator::StepStatus enumeration\n\nAnasazi\n  * Fixed a memory leak that PyTrilinos introduced with the\n    Eigensolution<...>::evecs() and espace() methods\n\nRelease Notes for PyTrilinos for Trilinos 12.8\n==============================================\n\nGeneral\n  * Improved formatting in example scripts\n\nDomi\n  * Update MDMap constructor for replicated boundaries\n  * Fixed ETI bugs\n\nNOX/LOCA\n  * Fixed memory leak by updating NOX typemaps\n\nTpetra\n  * Fix difficult-to-wrap Map class by using %inline\n\nRelease Notes for PyTrilinos for Trilinos 12.4\n==============================================\n\nGeneral\n  * Fixed several memory management bugs\n  * Fixed a pervasive bug where C++ exceptions were caught in the\n    wrong order. This fix results in Python errors that have much\n    better messages, making it easier to debug problems that employ\n    cross-language polymorphism.\n\nTeuchos\n  * Upgraded Teuchos.ParameterList to support an Array(string) value\n    type.\n\nEpetra\n  * Added new Python-to-C++ converters that convert a wider variety of\n    Python objects to distributed Epetra vectors (Epetra_MultiVector,\n    Epetra_Vector, Epetra_IntVector).  This includes any Python object\n    that exports the Distributed Array Protocol, such as Enthought's\n    DistArray.  It also includes NumPy arrays when running in a serial\n    environment.\n  * Added __distarray__() method to Epetra vector classes, so that\n    they now export the Distributed Array Protocol.\n  * Memory management issues associated with the Epetra.LinearProblem\n    class and the new Epetra vector converters were fixed.\n\nTpetra\n  * Fixed wrappers for Tpetra MultiVector and Vector classes.\n  * Added __distarray__() method to Tpetra vector classes, so that\n    they now export the Distributed Array Protocol.\n  * Bug fixes related to latest Tpetra upgrade\n\nLOCA\n  * Introduced a new LOCA test in which the Chan problem is solved\n    using a preconditioner.\n\nRelease Notes for PyTrilinos for Trilinos 12.0\n==============================================\n\nGeneral\n  * Changed to BSD license\n  * Mpi4Py support has been made optional.  Previously, if Mpi4Py was\n    found, it was automatically enabled within PyTrilinos.  Now that\n    behavior can be turned off.\n\nLOCA\n  * The LOCA module has been refactored and now has been demonstrated\n    to work for the Chan problem.  We have two example problems\n    working, one without preconditioning, and one with.\n\nTpetra\n  * Package is still experimental.  The recent refactor has broken\n    MultiVectors and Vectors.\n  * Map support has been improved\n\nAnasazi\n  * Fixed a bug where return eigenvalues are converted to a NumPy\n    array, but the dimension used the wrong type.\n\nKokkos\n  * Fixed a macro issue\n\nNOX\n  * Started PETSc compatibility.  This is still experimental, and\n    includes compatibility with petsc4py.\n\nSTK\n  * Removed PyPercept, as it is currently not a part of the new STK.\n\nDomi\n  * Added package\n\nRelease Notes for PyTrilinos 4.12 (Trilinos 11.12)\n==================================================\n\nGeneral\n  * Got rid of NestedEpetra paradigm and now use relative imports to\n    address the problem that NestedEpetra wass supposed to solve.\n  * Changed build system for docstrings.  The docstrings are no longer\n    stored in the repository.  If the user wants docstrings, then\n    doxygen needs to be installed.  Docstrings are built during the\n    configuration phase.\n  * Fixed warnings due to Epetra 32/64 bit handling\n  * Added mpi4py support.  Specifically, the Eptra_MpiComm\n    constructors and Teuchos::MpiComm<> constructors can now take MPI\n    sub-communicators, provided by mpi4py.MPI.Comm class.  Ignored if\n    mpi4py is not found.\n  * Updated Developers Guide\n\nTeuchos module\n  * Support for the Teuchos::DataAccess enumeration.  This enables\n    certain Tpetra and Domi constructors\n  * Add Teuchos::Arrays of int, long, float and double, as valid types\n    for PyTrilinos ParameterLists\n\nDistArray Protocol\n  * Added support for the DistArray Protocol.  This is preliminary and\n    unfortunatley, does not provide any functionality with this\n    release.\n\nLOCA module\n  * Re-instated the LOCA wrappers.  These are still experimentaland\n    require SWIG 3.0.0 and Python 2.5.\n  * Re-introduction of the LOCA interface required the introduction of\n    relative imports, which require Python 2.5 or higher.\n\nIsorropia module\n  * Refactor of Isorropia directory structure.  This should not affect\n    users.\n\nRelease Notes for PyTrilinos 4.10 (Trilinos 11.8)\n=================================================\n\nGeneral\n  * Various changes to improve the stability and robustness of the\n    build system.  Addresses some instability in PyTrilinos introduced\n    with new 64 bit capabilities in Epetra.  Some compilation warnings\n    eliminated.  SWIG version checks added.\n\nRelease Notes for PyTrilinos 4.10 (Trilinos 11.4)\n=================================================\n\nGeneral\n  * Updated the NumPy interface to properly deal with deprecated\n    code.  If PyTrilinos if compiled an older NumPy, it still works,\n    but if compiled against newer versions of NumPy, the deprecated\n    code is avoided, as are the warnings.\n\n\nRelease Notes for PyTrilinos 4.8 (Trilinos 11.2)\n================================================\n\nGeneral\n  * Added STK as an optional dependency of PyTrilinos\n  * Added Pliris as a supported package\n  * Provide better compatibility with external MPI implementations.\n    Specifically, if the user were to \"import mpi4py\" (for example)\n    prior to importing Teuchos or Epetra, then the Teuchos or Epetra\n    modules will not take responsibility for calling MPI_Finalize().\n  * Fixed some build errors\n\nEpetra module\n  * Priliminary support for Epetra64.  Ultimately, I would like the\n    default behavior to be using 64-bit methods without refering to\n    64-bit method names.\n  * Added PyTrilnos.Epetra.FECrsMatrix InsertGlobalValues method that\n    had been hidden by a %extend SWIG directive.\n\nEpetraExt module\n  * Gave names to EpetraExt template classes.  Using the nameless\n    versions had caused problems with newer versions of SWIG.  This\n    should get rid of the need for a patch distributed with\n    Archlinux.\n  * Added the EpetraExt::CrsMatrix_SubCopy class to\n    PyTrilinos.EpetraExt.\n\nNOX module\n  * Improved NOX support, especially NOX.Epetra.  This should be\n    largely invisible to the user, but I used to have to always import\n    NOX whether the user wanted it or not, due to nested namespace\n    issues.  These issues have been resolved now, and you only import\n    NOX if you specifically request it.\n\nAnasazi module\n  * Added EpetraMultiVecAccessor base class.  Anasazi added this base\n    class, and now the PyTrilinos version supports it as well.\n\nRelease Notes for PyTrilinos 4.6 (Trilinos 10.10)\n=================================================\n\nAdded support for the use case when Trilinos requests a\nTeuchos::ArrayView<>.  In Python, the user can supply a NumPy array or\na Python sequence (input arguments only) and PyTrilinos will convert\nit to the necessary ArrayView type automatically.  This currently only\napplies to the Teuchos.Comm classes, but the infrastructure is there\nfor future needs.\n\nChanged PyTrilinos string checks to accommodate older Pythons in which\nstrings can only be regular strings and newer Pythons in which strings\ncan be either unicode or regular strings.\n\nAdded experimental support for STK package Percept mesh module.\n\nRelease Notes for PyTrilinos 4.6 (Trilinos 10.8)\n================================================\n\nImproved the MPI initialization logic in Teuchos and Epetra modules.\nPreviously, both modules would call MPI_Init() when they were imported\ninto the python interpretter and register MPI_Finalize() with the\natexit module (each module did perform checks before executing the\ncalls in case the other module beat it to the punch).  Now, each\nmodule checks to see if MPI_Init() has already been called, and if so,\nit does not register MPI_Finalize() with atexit.  This way, if the\nuser initializes MPI ahead of importing Teuchos or Epetra (such as\nwith mpi4py, for example), then the user is responsible for\nfinalization, and can assume finer control.\n\nAdded the Isorropia package, for partitioning Epetra objects.  This\nincludes an IsorropiaVisualizer.py script.\n\nThis release contains a large number of internal changes mostly not\nvisible to end users, except for increased stability and bug fixes.\nOne big change is that C++ referenced counted pointers (via the\nTeuchos::RCP class) are now properly handled.  Fixed a couple of bugs\nin the Amesos, AztecOO and EpetraExt wrappers.  Changed the Amesos\nexample scripts to follow PyTrilinos coding standards.  Put all C++\ncode within the PyTrilinos namespace.  Changed C++ file names to have\nPyTrilinos_ prefix.\n\nRelease Notes for PyTrilinos 4.4 (Trilinos 10.4)\n================================================\n\nThe logic for determining the prefix for the install directory for PyTrilinos has\nbeen improved.  Highest precedence is given to the configure variable\nPyTrilinos_INSTALL_PREFIX.  If this is not set by the user, then next\nhighest precedence is given to CMAKE_INSTALL_PREFIX.  If this has not\nbeen set by the user, then the prefix of the python interpreter that\nPyTrilinos is being compiled against is used.\n\nRelease Notes for PyTrilinos 4.3 (Trilinos 10.2)\n================================================\n\nPyTrilinos.NOX notes:\n\n  Updated the wrappers so that the Jacobian can be specified using the\n  NOX.Epetra.Interface.Jacobian base class.  To get this to work\n  required that the directorin %typemaps for Epetra_Operator used by\n  NOX.Epetra.Interface.Jacobian be updated to downcast the\n  Epetra_Operator argument to our best guess at the derived class.\n  Such a downcast had already been written for the EpetraExt\n  ModelEvaluator, so code was moved around to make it more generally\n  accessible.  This uncovered a memory management bug that took some\n  time to track down, but the result now is much more stable memory\n  management all-around.\n\n  The new capability is demonstrated in serial in example script\n  exNOX_2DSim.\n\nRelease Notes for PyTrilinos 4.2 (Trilinos 10.0)\n================================================\n\nGeneral notes for PyTrilinos:\n\n  * Converted to CMake build system\n\n  * Added const-correctness for char* function arguments.  This\n    improves compatibility with newer gnu compilers.\n\nPyTrilinos.Teuchos notes:\n\n  * LabeledObject and Describable classes converted to director\n    classes so that virtual methods can be overridden in python.\n\nPyTrilinos.EpetraExt notes:\n\n  * Added wrappers for ModelEvaluator and all associated classes\n\nPyTrilinos.Komplex notes:\n\n  * Added Komplex module\n\nPyTrilinos.Pliris notes:\n\n  * Added Pliris module\n\nPyTrilinos.NOX notes:\n\n  * Improved robustness of NOX sub-packages\n\n  * Added wrappers for ModelEvaluatorInterface class\n\n  * Added default builder functions:\n\n    + defaultNonlinearParameters()\n    + defaultGroup()\n    + defaultStatusTest()\n    + defaultSolver()\n\n\n\nRelease Notes for PyTrilinos 4.1 (Trilinos 9.0)\n===============================================\n\nGeneral notes for PyTrilinos:\n\n  * Added auto-generated documentation.\n\n  * Standardized and upgraded PyTrilinos module docstrings.\n\n  * Improved exception handling.\n\n  * Fixed problem with patch for numpy 0.9.8 bug; moved fix for python\n    2.5 compatibility into file where it is directly needed.\n\n  * Fixed problem some PyTrilinos modules had interpreting elements of\n    numpy arrays as integers.\n\n  * Added logic to python extension module builds so that compile\n    flags -ansi and -pedantic will be ignored.\n\n  * Fixed some incompatibilities between the generated code from swig\n    version 1.3.35 and earlier versions.\n\n  * Better error checking when a python argument is converted to an\n    array of char* strings.\n\n  * Eliminated certain runtime type information errors by moving to\n    shared laibraries, thus ensuring that no symbols get duplicated.\n\n  * Added C89 compliance.\n\n  * Changed PyTrilinos/__init__.py to alter the python dlopen flags so\n    that symbols are shared across all of the PyTrilinos extension\n    modules.  This fixed many bugs associated with symbols crossing\n    shared library boundaries.\n\n  * Added fixes for installation on Fedora Core.\n\nPyTrilinos.Teuchos notes:\n\n  * Added support for Teuchos::Comm, Teuchos::SerialComm,\n    Teuchos::MpiComm and Teuchos::DefaultComm, including tests.\n\nPyTrilinos.Epetra notes:\n\n  * Added support for the Epetra.Comm Broadcast method with string\n    data, including additions to testEpetra_Comm.py to test the\n    capability.  Since these are in-place, users must use numpy arrays\n    of strings.\n\n  * Some PyTrilinos.Epetra MPI reduction operations were returning\n    garbage.  This was fixed by clearing out those arrays prior to the\n    call.\n\n  * Epetra.Finalize() (called automatically when the Epetra module is\n    destroyed) now checks MPI_Finalized() before calling\n    MPI_Finalize().  This should help it play nice with Teuchos MPI\n    support.\n\n  * Upgraded Epetra.FEVector to reflect its new multivector nature.\n\n  * Fixed Epetra.Vector and Epetra.MultiVector objects so that slices\n    return new Epetra.[Multi]Vector objects with accurate Maps.\n\nPyTrilinos.AztecOO notes:\n\n  * Improved the AztecOO wrappers for better compatibility with older\n    versions of numpy.\n\n  * Fixed exAztecOO_Operator.py, exAztecOO_RowMatrix.py and\n    exAztecOO_BasicRowMatrix.py example scripts so that they work in\n    parallel.\n\nPyTrilinos.ML notes:\n\n  * Updated PyTrilinos.ML to be more robust.\n\nPyTrilinos.NOX notes:\n\n  * Fixed NOX.Solver.myBuildSolver to properly use new Teuchos::Ptr\n    templated class.\n\nPyTrilinos.Anasazi notes:\n\n  * Added MPI support to Anasazi wrappers.\n\n  * Updated PyTrilinos w.r.t. changes in Anasazi::SortManager interface.\n\n  * Added support to Anasazi wrappers for extracting eigenvalues and\n    eigenvectors.\n",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/PyTrilinos/src/PyTrilinos/__init__.py.in": "#! ${PYTHON_EXECUTABLE}\n# -*- python -*-\n\n# @HEADER\n# ***********************************************************************\n#\n#          PyTrilinos: Python Interfaces to Trilinos Packages\n#                 Copyright (2014) Sandia Corporation\n#\n# Under the terms of Contract DE-AC04-94AL85000 with Sandia\n# Corporation, the U.S. Government retains certain rights in this\n# software.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are\n# met:\n#\n# 1. Redistributions of source code must retain the above copyright\n# notice, this list of conditions and the following disclaimer.\n#\n# 2. Redistributions in binary form must reproduce the above copyright\n# notice, this list of conditions and the following disclaimer in the\n# documentation and/or other materials provided with the distribution.\n#\n# 3. Neither the name of the Corporation nor the names of the\n# contributors may be used to endorse or promote products derived from\n# this software without specific prior written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION \"AS IS\" AND ANY\n# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE\n# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n#\n# Questions? Contact William F. Spotz (wfspotz@sandia.gov)\n#\n# ***********************************************************************\n# @HEADER\n\n\"\"\"\n\nPyTrilinos: A python interface to selected Trilinos packages.  This installation\n  of PyTrilinos was built with the following python-wrapped packages enabled:\n\n${PyTrilinos_LIST}\n\"\"\"\n\n# We need symbol names to be recognized across PyTrilinos extension modules.  On\n# some systems, this requires that the dynamic library opener be given certain\n# flags: runtime load now and runtime load global.  This has to be set before\n# any PyTrilinos extension modules are loaded.  Unfortunately, the python module\n# we want that contains the named values of these flags is called \"dl\" on some\n# systems, \"DLFCN\" on others, and does not even exist on some.  The following\n# logic loads the module into name \"dl\" if it exists and extracts the needed\n# flags.  If the module we need does not exist, we use our best guess at what\n# the flags values are.  After all this, the sys module setdlopenflags()\n# function is called.\ndl = None\ntry:\n    import dl\nexcept (SystemError, ImportError):\n    try:\n        import DLFCN as dl\n    except (SystemError, ImportError):\n        pass\nif dl:\n    dlopenflags = dl.RTLD_NOW | dl.RTLD_GLOBAL\n    del dl\nelse:\n    dlopenflags = 258\nimport sys\nsys.setdlopenflags(dlopenflags)\n\n# Set the __all__ special variable, a list of strings which define all of the\n# PyTrilinos public names, namely the Trilinos packages that are enabled.\n${PyTrilinos_ALL}\n\n# Versioning.  Set the __version__ special variable and define a version()\n# function.\n__version__ = '${PyTrilinos_VERSION}'\ndef version():\n    return 'Trilinos version: ${Trilinos_VERSION}\\nPyTrilinos version: ' + __version__\n\n#\n# Import utility class\nfrom .PropertyBase import PropertyBase\n#\n# Import the typed tuple factory and classes\nfrom .typed_tuple import *\n#\n# Import the typed dict factory\nfrom .typed_dict import *\n",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/stk/stk_util/stk_util/diag/UserPlugin.cpp": "/*\n// Copyright 2002 - 2008, 2010, 2011 National Technology Engineering\n// Solutions of Sandia, LLC (NTESS). Under the terms of Contract\n// DE-NA0003525 with NTESS, the U.S. Government retains certain rights\n// in this software.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n// \n//     * Redistributions of source code must retain the above copyright\n//       notice, this list of conditions and the following disclaimer.\n// \n//     * Redistributions in binary form must reproduce the above\n//       copyright notice, this list of conditions and the following\n//       disclaimer in the documentation and/or other materials provided\n//       with the distribution.\n// \n//     * Neither the name of NTESS nor the names of its contributors\n//       may be used to endorse or promote products derived from this\n//       software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// \n */\n\n#include <stdexcept>\n#include <sstream>\n#include <string>\n\n#include <stk_util/diag/UserPlugin.hpp>\n#include <stk_util/diag/SlibDiagWriter.hpp>\n\n#ifdef SIERRA_DLOPEN_ENABLED\n#include <dlfcn.h>\n#endif\n\nnamespace sierra {\nnamespace Plugin {\n\nstd::string\nderived_id_name(\n  int\t\t\tderived_id)\n{\n  std::ostringstream derived_name;\n  derived_name << \"enum id \" << derived_id;\n  return derived_name.str();\n}\n\n\nRegistry::RegistryMap &\nRegistry::getRegistryMap()\n{\n  static RegistryMap s_registryMap;\n\n  return s_registryMap;\n}\n\n\nRegistry &\nRegistry::rootInstance()\n{\n  static Registry registry;\n\n  return registry;\n}\n\n\n\nvoid\nRegistry::registerIt(\n  const NamePair &\tname_pair,\n  void *\t\tfunc_ptr)\n{\n  slibout.m(Slib::LOG_PLUGIN) << \"Registering \" << name_pair.second\n\t\t\t      << \" of type \" << demangle(name_pair.first->name())\n\t\t\t      << \" at \" << func_ptr << stk::diag::dendl;\n\n  RegistryMap::const_iterator registry_entry = getRegistryMap().find(name_pair);\n  if (registry_entry != getRegistryMap().end() && (*registry_entry).second != func_ptr) {\n    std::ostringstream strout;\n    strout << \"Function with signature \" << demangle((*registry_entry).first.first->name())\n\t   << \" and derived name '\" << (*registry_entry).first.second\n\t   << \"' already registered to create function at address \" << (*registry_entry).second;\n    throw std::invalid_argument(strout.str());\n  }\n  getRegistryMap()[name_pair] = func_ptr;\n}\n\n\nvoid *\nRegistry::getPluginPtr(\n  const NamePair &\tname_pair) const\n{\n  void *creator_function = getFuncPtr(name_pair);\n  if (creator_function)\n    return creator_function;\n  else {\n    std::ostringstream strout;\n\n    strout << \"User plugin creator function with base class '\" << demangle(name_pair.first->name())\n\t   << \"' and derived class name '\" << name_pair.second\n\t   << \"' not found in registry\";\n    throw std::invalid_argument(strout.str());\n  }\n}\n\n\nvoid *\nRegistry::getFunctionPtr(\n  const NamePair &\tname_pair) const\n{\n  void *creator_function = getFuncPtr(name_pair);\n  if (creator_function)\n    return creator_function;\n  else {\n    std::ostringstream strout;\n    strout << \"User subroutine \" << name_pair.second << \"\\n\"\n\t   << \" with signature \" << demangle(name_pair.first->name()) << \"\\n\"\n           << \" not found in registry\";\n    throw std::invalid_argument(strout.str());\n  }\n}\n\n\nRegistry *\nRegistry::getFactoryPtr(\n  const NamePair &\tname_pair) const\n{\n  Registry *creator_function = reinterpret_cast<Registry *>(getFuncPtr(name_pair));\n  if (creator_function)\n    return creator_function;\n  else {\n    std::ostringstream strout;\n    strout << \"Registry does not contain function with signature \" << demangle(name_pair.first->name())\n\t   << \" and derived name '\" << name_pair.second << \"'\";\n    throw std::invalid_argument(strout.str());\n  }\n}\n\n\nvoid *\nRegistry::getFuncPtr(\n  const NamePair &\tname_pair) const\n{\n  RegistryMap::const_iterator registry_entry = getRegistryMap().find(name_pair);\n  return registry_entry == getRegistryMap().end() ? nullptr : (*registry_entry).second;\n}\n\n\nstd::vector<std::string>\nRegistry::getDerivedNames(\n  const std::type_info &\ttype) const\n{\n  std::vector<std::string> derived_names;\n\n  for (RegistryMap::const_iterator it = getRegistryMap().begin(); it != getRegistryMap().end(); ++it)\n    if (*(*it).first.first == type)\n      derived_names.push_back((*it).first.second);\n\n  return derived_names;\n}\n\n\ntypedef void (*dl_register_t)();\n\nvoid\nRegistry::registerDL(\n  const char *\t\tso_path,\n  const char *\t\tfunction_name)\n{\n#ifdef SIERRA_DLOPEN_ENABLED\n  slibout.m(Slib::LOG_PLUGIN) << \"Loading dynamic library \" << so_path << stk::diag::dendl;\n  void *dl = dlopen(so_path, RTLD_NOW);\n  if (!dl){\n    throw std::runtime_error(dlerror());\n  }\n\n  if (function_name) {\n    std::string s = std::strlen(function_name) ? function_name : \"dl_register\";\n\n    dl_register_t f = reinterpret_cast<dl_register_t>(dlsym(dl, s.c_str()));\n    if (!f) {\n      s = s + SIERRA_FORTRAN_SUFFIX;\n\n      f = reinterpret_cast<dl_register_t>(dlsym(dl, s.c_str()));\n    }\n\n    if (f) {\n      slibout.m(Slib::LOG_PLUGIN) << \"Executing dynamic library \" << so_path << \" function \" << s << \"()\" << stk::diag::dendl;\n      (*f)();\n    }\n    else {\n      if (std::strlen(function_name)) {\n        std::ostringstream str;\n        str << \"Registration function \" << function_name << \" not found in \" << so_path;\n        throw std::runtime_error(str.str().c_str());\n      }\n    }\n  }\n\n#else\n  throw std::runtime_error(\"Dynamic linkage is not supported on this platform\");\n#endif\n}\n\n\ntemplate <>\nvoid *\nRegistry::getsym<void *>(\n  const char *  sym)\n{\n#ifdef SIERRA_DLOPEN_ENABLED\n  void *s = nullptr;\n  void *dl = dlopen(nullptr, RTLD_LAZY);\n  if (dl) {\n    s = dlsym(dl, sym);\n    dlclose(dl);\n  }\n\n  return s;\n#else\n  return nullptr;\n#endif\n}\n\n\nstd::ostream &\nRegistry::verbose_print(\n  std::ostream &\t\tos) const\n{\n  for (RegistryMap::const_iterator it = getRegistryMap().begin(); it != getRegistryMap().end(); ++it)\n    os << (*it).first.second << \" of type \" << demangle((*it).first.first->name()) << \" at \" << (*it).second << std::endl;\n  return os;\n}\n\n\nstk::diag::Writer &\nRegistry::verbose_print(\n  stk::diag::Writer &\t\tdout) const\n{\n  if (dout.shouldPrint()) {\n    dout << \"Registry, size \" << getRegistryMap().size() << stk::diag::push << stk::diag::dendl;\n\n    for (RegistryMap::const_iterator it = getRegistryMap().begin(); it != getRegistryMap().end(); ++it)\n      dout << (*it).first.second << \" of type \" << demangle((*it).first.first->name()) << \" at \" << (*it).second << stk::diag::dendl;\n    dout << stk::diag::pop;\n  }\n  return dout;\n}\n\n\nextern \"C\" {\n\nvoid SIERRA_FORTRAN(register_user_subroutine)(\n  type_info_func *\t\ttype_id,\n  void *\t\t\tuser_subroutine,\n  const char *\t\t\tname,\n  int\t\t\t\tname_len)\n{\n  sierra::Plugin::Registry::rootInstance().registerIt(std::make_pair(type_id(), std::string(name, name_len)), user_subroutine);\n}\n\n} // extern \"C\"\n\n} // namespace Plugin\n} // namespace sierra\n",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/stk/stk_util/stk_util/util/FeatureTest.hpp": "// Copyright 2002 - 2008, 2010, 2011 National Technology Engineering\n// Solutions of Sandia, LLC (NTESS). Under the terms of Contract\n// DE-NA0003525 with NTESS, the U.S. Government retains certain rights\n// in this software.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n// \n//     * Redistributions of source code must retain the above copyright\n//       notice, this list of conditions and the following disclaimer.\n// \n//     * Redistributions in binary form must reproduce the above\n//       copyright notice, this list of conditions and the following\n//       disclaimer in the documentation and/or other materials provided\n//       with the distribution.\n// \n//     * Neither the name of NTESS nor the names of its contributors\n//       may be used to endorse or promote products derived from this\n//       software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// \n\n#ifndef STK_UTIL_UTIL_FeatureTest_h\n#define STK_UTIL_UTIL_FeatureTest_h\n\n///\n/// @addtogroup FeatureTestDetail\n/// @{\n///\n/// The following feature test and bug macros been defined to conditionally compile in\n/// specific features and compile workarounds for known bugs.\n///\n/// Bugs and workarounds:\n///\n/// @def SIERRA_TYPE_INFO_BEFORE_EQUALITY_BUG\n/// SIERRA_TYPE_INFO_BEFORE_EQUALITY_BUG -- The before() function of the std::type_info\n///   class has been implemented improperly, resulting in type_info which are equal to\n///   always return true.  Equal std::type_info objects should alway return false.  Define\n///   this is type_info::before() is not implemented properly.\n///\n/// @def SIERRA_TEMPLATE_FUNCTION_SELECT_BUG\n/// SIERRA_TEMPLATE_FUNCTION_SELECT_BUG -- The function selection algorithm is broken and\n///   special workaround code must included to allow the compile to complete.\n///\n/// @def SIERRA_USE_PLATFORM_DEMANGLER\n/// SIERRA_USE_PLATFORM_DEMANGLER -- The platform type_info::name() function returns a\n///   mangled name which needs to be demangled.\n///\n/// Features:\n///\n/// @def SIERRA_DLOPEN_ENABLED\n/// SIERRA_DLOPEN_ENABLED -- The dlopen functionality is built into the sierra\n///   applications.  However it may not function on all platforms or be desired on all\n///   distributions. Define this macro if you wish to implement this functionality.\n///\n/// @def SIERRA_MEMORY_INFO\n/// SIERRA_MEMORY_INFO -- The platform supports memory usage information.\n///\n/// @def SIERRA_HEAP_INFO\n/// SIERRA_HEAP_INFO -- The platform supports heap usage information.\n///\n/// @def SIERRA_MPI_ABORT_SIGNAL\n/// SIERRA_MPI_ABORT_SIGNAL -- The MPI sends this signal to abort the processes.\n///\n/// @def SIERRA_USER_SHUTDOWN_SIGNAL\n/// SIERRA_USER_SHUTDOWN_SIGNAL -- The user sends this signal to tell the application to\n///   exit gracefully at it earliest convenience.\n///\n/// @def SIERRA_SHUTDOWN_SIGNAL\n/// SIERRA_SHUTDOWN_SIGNAL -- The platform sends this signal to tell the application to\n///   exit gracefully at it earliest convenience.\n///\n\n// Platform/operating system based features and bugs\n#if defined(_CRAYXE)\t\t\t        // Cray\n#  define SIERRA_HEAP_INFO\n#  define SIERRA_MEMORY_INFO\n#  define SIERRA_SHUTDOWN_SIGNAL SIGTERM\n#  define SIERRA_USER_SHUTDOWN_SIGNAL SIGURG\n\n#elif defined(__linux__)\t// Generic linux\n#  define SIERRA_USE_PLATFORM_DEMANGLER\n#  define SIERRA_HEAP_INFO\n#  define SIERRA_MEMORY_INFO\n#  define SIERRA_MPI_ABORT_SIGNAL SIGTERM\n#  define SIERRA_USER_SHUTDOWN_SIGNAL SIGUSR1\n\n#elif defined(__APPLE__)\t// MacOS\n#  define SIERRA_USE_PLATFORM_DEMANGLER\n#  define SIERRA_HEAP_INFO\n#  define SIERRA_MEMORY_INFO\n#  define SIERRA_MPI_ABORT_SIGNAL SIGTERM\n#  define SIERRA_USER_SHUTDOWN_SIGNAL SIGUSR1\n\n#else // Unknown platform\n#  warning Could not determine platform/operating system\n#endif\n\n// Compiler/runtime specific features and bugs\n\n#if defined(__xlC__)\t\t\t\t// IBM compiler\n#  if __xlC__ < 0x0800\n#    define SIERRA_TEMPLATE_FUNCTION_SELECT_BUG\n#  endif\n#  define SIERRA_TYPE_INFO_BEFORE_EQUALITY_BUG\n\n#elif defined(__INTEL_COMPILER)\t\t\t// Intel compiler\n#  if __INTEL_COMPILER/100 == 10 && defined(__ia64) // Version 10 Intel compiler on ia64\n#    define SIERRA_IA64_OPTIMIZER_FIX\n#  elif __INTEL_COMPILER/100 == 11 && defined(__ia64) // Version 11 Intel compiler on ia64\n#    define SIERRA_IA64_OPTIMIZER_FIX\n#  elif __INTEL_COMPILER/100 >= 12 && defined(__ia64) // Version 12+ Intel compiler on ia64\n#    define SIERRA_IA64_OPTIMIZER_WARN\n#  endif\n\n#elif defined(__PGI)\t\t\t\t// PGI compiler\n\n#elif defined(_CRAYC)\t\t\t\t// CRAY compiler\n\n#elif defined(__APPLE_CC__)\t\t\t// Apple compiler\n\n#elif defined(__GNUC__)\t\t\t\t// GNU compiler, do this last since *every* compiler thinks its gcc\n\n#else // Unknown compiler\n#  warning Could not determine compiler/runtime\n#endif\n\n///\n/// @}\n///\n\n#endif // STK_UTIL_UTIL_FeatureTest_h\n",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/seacas/libraries/ioss/src/visualization/Iovs_DatabaseIO.C": "// Copyright(C) 1999-2020 National Technology & Engineering Solutions\n// of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with\n// NTESS, the U.S. Government retains certain rights in this software.\n//\n// See packages/seacas/LICENSE for details\n\n/*--------------------------------------------------------------------*/\n/*    Copyright 2000-2010 NTESS.                         */\n/*    Under the terms of Contract DE-AC04-94AL85000, there is a       */\n/*    non-exclusive license for use of this work by or on behalf      */\n/*    of the U.S. Government.  Export of this program may require     */\n/*    a license from the United States Government.                    */\n/*--------------------------------------------------------------------*/\n\n#include <Ioss_CodeTypes.h>\n#include <ParaViewCatalystIossAdapter.h>\n#include <tokenize.h>\n#include <visualization/Iovs_DatabaseIO.h>\n\n#include <cctype>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iterator>\n\n#include <Ioss_ElementTopology.h>\n#include <Ioss_FileInfo.h>\n#include <Ioss_ParallelUtils.h>\n#include <Ioss_SerializeIO.h>\n#include <Ioss_SubSystem.h>\n#include <Ioss_SurfaceSplit.h>\n#include <Ioss_Utils.h>\n\n#include <libgen.h>\n#include <sys/stat.h>\n\n#ifdef IOSS_DLOPEN_ENABLED\n#include <dlfcn.h>\n#endif\n\n#include <cassert>\n\n#if defined(__APPLE__)\nconst char *CATALYST_PLUGIN_DYNAMIC_LIBRARY = \"libParaViewCatalystIossAdapter.dylib\";\n#else\nconst char *CATALYST_PLUGIN_DYNAMIC_LIBRARY = \"libParaViewCatalystIossAdapter.so\";\n#endif\n\nconst char *CATALYST_PLUGIN_PYTHON_MODULE = \"PhactoriDriver.py\";\nconst char *CATALYST_PLUGIN_PATH          = \"viz/catalyst/install\";\nconst char *CATALYST_FILE_SUFFIX          = \".dummy.pv.catalyst.e\";\nconst char *CATALYST_OUTPUT_DIRECTORY     = \"CatalystOutput\";\n\nnamespace { // Internal helper functions\n  enum class entity_type { NODAL, ELEM_BLOCK, NODE_SET, SIDE_SET };\n  bool file_exists(const std::string &filepath)\n  {\n    struct stat buffer\n    {\n    };\n    return (stat(filepath.c_str(), &buffer) == 0);\n  }\n\n  int64_t get_id(const Ioss::GroupingEntity *entity, Iovs::EntityIdSet *idset);\n  bool    set_id(const Ioss::GroupingEntity *entity, Iovs::EntityIdSet *idset);\n  int64_t extract_id(const std::string &name_id);\n\n  void build_catalyst_plugin_paths(std::string &      plugin_library_path,\n                                   std::string &      plugin_python_path,\n                                   const std::string &plugin_library_name);\n\n  int number_of_catalyst_blocks = 0;\n} // End anonymous namespace\n\nnamespace Iovs {\n  void *      globalCatalystIossDlHandle = nullptr;\n  int         DatabaseIO::useCount       = 0;\n  std::string DatabaseIO::paraview_script_filename;\n  int         field_warning(const Ioss::GroupingEntity *ge, const Ioss::Field &field,\n                            const std::string &inout);\n\n  DatabaseIO::DatabaseIO(Ioss::Region *region, const std::string &filename,\n                         Ioss::DatabaseUsage db_usage, MPI_Comm communicator,\n                         const Ioss::PropertyManager &props)\n      : Ioss::DatabaseIO(region, DatabaseIO::create_output_file_path(filename, props), db_usage,\n                         communicator, props),\n        enableLogging(0), debugLevel(0), underscoreVectors(0), applyDisplacements(0),\n        createSideSets(0), createNodeSets(0), nodeBlockCount(0), elementBlockCount(0)\n  {\n\n    std::ostringstream errmsg;\n    if (db_usage == Ioss::WRITE_HEARTBEAT) {\n      errmsg << \"ParaView catalyst database type cannot be used in a HEARTBEAT block.\\n\";\n      IOSS_ERROR(errmsg);\n    }\n    else if (db_usage == Ioss::WRITE_HISTORY) {\n      errmsg << \"ParaView catalyst database type cannot be used in a HISTORY block.\\n\";\n      IOSS_ERROR(errmsg);\n    }\n    else if (db_usage == Ioss::READ_MODEL || db_usage == Ioss::READ_RESTART) {\n      errmsg << \"ParaView catalyst database type cannot be used to read a model.\\n\";\n      IOSS_ERROR(errmsg);\n    }\n\n    std::string dbfname = DatabaseIO::create_output_file_path(filename, props);\n    number_of_catalyst_blocks++;\n    useCount++;\n    if (Ioss::SerializeIO::getRank() == 0) {\n      if (!file_exists(dbfname)) {\n        std::ofstream output_file;\n        output_file.open(dbfname.c_str(), std::ios::out | std::ios::trunc);\n\n        if (!output_file) {\n          errmsg << \"Unable to create output file: \" << dbfname << \".\\n\";\n          IOSS_ERROR(errmsg);\n          return;\n        }\n        output_file.close();\n      }\n    }\n    dbState                              = Ioss::STATE_UNKNOWN;\n    this->pvcsa                          = nullptr;\n    this->globalNodeAndElementIDsCreated = false;\n\n    if (props.exists(\"CATALYST_BLOCK_PARSE_JSON_STRING\")) {\n      this->paraview_json_parse = props.get(\"CATALYST_BLOCK_PARSE_JSON_STRING\").get_string();\n    }\n\n    if (props.exists(\"CATALYST_SCRIPT\")) {\n      DatabaseIO::paraview_script_filename = props.get(\"CATALYST_SCRIPT\").get_string();\n    }\n\n    if (props.exists(\"CATALYST_SCRIPT_EXTRA_FILE\")) {\n      this->paraview_script_extra_filename = props.get(\"CATALYST_SCRIPT_EXTRA_FILE\").get_string();\n    }\n\n    this->underscoreVectors = 1;\n    if (props.exists(\"CATALYST_UNDERSCORE_VECTORS\")) {\n      this->underscoreVectors = props.get(\"CATALYST_UNDERSCORE_VECTORS\").get_int();\n    }\n\n    this->applyDisplacements = 1;\n    if (props.exists(\"CATALYST_APPLY_DISPLACEMENTS\")) {\n      this->applyDisplacements = props.get(\"CATALYST_APPLY_DISPLACEMENTS\").get_int();\n    }\n\n    this->createNodeSets = 0;\n    if (props.exists(\"CATALYST_CREATE_NODE_SETS\")) {\n      this->createNodeSets = props.get(\"CATALYST_CREATE_NODE_SETS\").get_int();\n    }\n\n    this->createSideSets = 0;\n    if (props.exists(\"CATALYST_CREATE_SIDE_SETS\")) {\n      this->createSideSets = props.get(\"CATALYST_CREATE_SIDE_SETS\").get_int();\n    }\n\n    if (props.exists(\"CATALYST_BLOCK_PARSE_INPUT_DECK_NAME\")) {\n      this->sierra_input_deck_name = props.get(\"CATALYST_BLOCK_PARSE_INPUT_DECK_NAME\").get_string();\n    }\n\n    this->enableLogging = 0;\n    if (props.exists(\"CATALYST_ENABLE_LOGGING\")) {\n      this->enableLogging = props.get(\"CATALYST_ENABLE_LOGGING\").get_int();\n    }\n\n    this->debugLevel = 0;\n    if (props.exists(\"CATALYST_DEBUG_LEVEL\")) {\n      this->enableLogging = props.get(\"CATALYST_DEBUG_LEVEL\").get_int();\n    }\n\n    this->catalyst_output_directory = CATALYST_OUTPUT_DIRECTORY;\n    if (props.exists(\"CATALYST_OUTPUT_DIRECTORY\")) {\n      this->catalyst_output_directory = props.get(\"CATALYST_OUTPUT_DIRECTORY\").get_string();\n    }\n  }\n\n  DatabaseIO::~DatabaseIO()\n  {\n    useCount--;\n    try {\n      if (this->pvcsa != nullptr) {\n        this->pvcsa->DeletePipeline(this->DBFilename.c_str());\n        if (useCount <= 0) {\n          this->pvcsa->CleanupCatalyst();\n        }\n        delete this->pvcsa;\n        this->pvcsa = nullptr;\n      }\n\n#ifdef IOSS_DLOPEN_ENABLED\n      if ((globalCatalystIossDlHandle != nullptr) && useCount <= 0) {\n        dlclose(globalCatalystIossDlHandle);\n      }\n#endif\n    }\n    catch (...) {\n    }\n  }\n\n  std::string DatabaseIO::create_output_file_path(const std::string &          input_deck_name,\n                                                  const Ioss::PropertyManager &properties)\n  {\n    if (!properties.exists(\"CATALYST_OUTPUT_DIRECTORY\")) {\n      std::ostringstream s;\n      s << input_deck_name << \".\" << number_of_catalyst_blocks << CATALYST_FILE_SUFFIX;\n      return std::string(CATALYST_OUTPUT_DIRECTORY) + \"/\" + s.str();\n    }\n    {\n      return input_deck_name;\n    }\n  }\n\n  ParaViewCatalystIossAdapterBase *\n  DatabaseIO::load_plugin_library(const std::string & /*plugin_name*/,\n                                  const std::string &plugin_library_name)\n  {\n\n    std::string plugin_library_path;\n    std::string plugin_python_module_path;\n\n    build_catalyst_plugin_paths(plugin_library_path, plugin_python_module_path,\n                                plugin_library_name);\n\n    if (getenv(\"CATALYST_PLUGIN\") != nullptr) {\n      plugin_library_path = getenv(\"CATALYST_PLUGIN\");\n    }\n\n    if (DatabaseIO::paraview_script_filename.empty()) {\n      DatabaseIO::paraview_script_filename = plugin_python_module_path;\n    }\n\n    if (!file_exists(DatabaseIO::paraview_script_filename)) {\n      std::ostringstream errmsg;\n      errmsg << \"Catalyst Python module path does not exist.\\n\"\n             << \"Python module path: \" << DatabaseIO::paraview_script_filename << \"\\n\";\n      IOSS_ERROR(errmsg);\n    }\n\n#ifdef IOSS_DLOPEN_ENABLED\n    globalCatalystIossDlHandle = dlopen(plugin_library_path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n    if (globalCatalystIossDlHandle == nullptr) {\n      throw std::runtime_error(dlerror());\n    }\n\n    using PvCatSrrAdapterMakerFuncType = ParaViewCatalystIossAdapterBase *(*)();\n\n#ifdef __GNUC__\n    __extension__\n#endif\n        auto mkr = reinterpret_cast<PvCatSrrAdapterMakerFuncType>(\n            dlsym(globalCatalystIossDlHandle, \"ParaViewCatalystIossAdapterCreateInstance\"));\n    if (mkr == nullptr) {\n      throw std::runtime_error(\"dlsym call failed to load function \"\n                               \"'ParaViewCatalystIossAdapterCreateInstance'\");\n    }\n\n    return (*mkr)();\n#else\n    return NULL;\n#endif\n  }\n\n  bool DatabaseIO::begin__(Ioss::State state)\n  {\n    dbState              = state;\n    Ioss::Region *region = this->get_region();\n    if (region->model_defined() && (this->pvcsa == nullptr)) {\n      this->pvcsa = DatabaseIO::load_plugin_library(\"ParaViewCatalystIossAdapter\",\n                                                    CATALYST_PLUGIN_DYNAMIC_LIBRARY);\n\n      std::string separator(1, this->get_field_separator());\n\n      // See if we are in a restart by looking for '.e-s' in the output filename\n      std::string            restart_tag;\n      std::string::size_type pos = this->DBFilename.rfind(\".e-s\");\n      if (pos != std::string::npos) {\n        if (pos + 3 <= this->DBFilename.length()) {\n          restart_tag = this->DBFilename.substr(pos + 3, 5);\n        }\n      }\n\n      std::vector<std::string> catalyst_sierra_data;\n      catalyst_sierra_data.push_back(this->paraview_script_extra_filename);\n\n      if (this->pvcsa != nullptr) {\n        this->pvcsa->CreateNewPipeline(\n            DatabaseIO::paraview_script_filename.c_str(), this->paraview_json_parse.c_str(),\n            separator.c_str(), this->sierra_input_deck_name.c_str(), this->underscoreVectors,\n            this->applyDisplacements, restart_tag.c_str(), this->enableLogging, this->debugLevel,\n            this->DBFilename.c_str(), this->catalyst_output_directory.c_str(),\n            catalyst_sierra_data);\n      }\n      std::vector<int>                   element_block_id_list;\n      Ioss::ElementBlockContainer const &ebc = region->get_element_blocks();\n      for (auto i : ebc) {\n        element_block_id_list.push_back(get_id(i, &ids_));\n      }\n      if (this->pvcsa != nullptr) {\n        this->pvcsa->InitializeElementBlocks(element_block_id_list, this->DBFilename.c_str());\n      }\n    }\n    return true;\n  }\n\n  bool DatabaseIO::end__(Ioss::State state)\n  {\n    // Transitioning out of state 'state'\n    assert(state == dbState);\n    switch (state) {\n    case Ioss::STATE_DEFINE_MODEL: write_meta_data(); break;\n    case Ioss::STATE_DEFINE_TRANSIENT:\n      // TODO, is there metadata we can prep through ITAPS?\n      // write_results_metadata();\n      break;\n    default: // ignore everything else...\n      break;\n    }\n\n    {\n      dbState = Ioss::STATE_UNKNOWN;\n    }\n\n    return true;\n  }\n\n  // Default versions do nothing at this time...\n  // Will be used for global variables...\n  bool DatabaseIO::begin_state__(int state, double time)\n  {\n    Ioss::SerializeIO serializeIO__(this);\n\n    if (!this->globalNodeAndElementIDsCreated) {\n      this->create_global_node_and_element_ids();\n    }\n\n    if (this->pvcsa != nullptr) {\n      this->pvcsa->SetTimeData(time, state - 1, this->DBFilename.c_str());\n    }\n\n    return true;\n  }\n\n  bool DatabaseIO::end_state__(int /*state*/, double /*time*/)\n  {\n    Ioss::SerializeIO serializeIO__(this);\n\n    if (this->pvcsa != nullptr) {\n      std::vector<int>         error_codes;\n      std::vector<std::string> error_messages;\n      this->pvcsa->logMemoryUsageAndTakeTimerReading(this->DBFilename.c_str());\n      this->pvcsa->PerformCoProcessing(this->DBFilename.c_str(), error_codes, error_messages);\n      this->pvcsa->logMemoryUsageAndTakeTimerReading(this->DBFilename.c_str());\n      this->pvcsa->ReleaseMemory(this->DBFilename.c_str());\n      if (!error_codes.empty() && !error_messages.empty() &&\n          error_codes.size() == error_messages.size()) {\n        for (unsigned int i = 0; i < error_codes.size(); i++) {\n          if (error_codes[i] > 0) {\n            Ioss::WARNING() << \"\\n\\n** ParaView Catalyst Plugin Warning Message Severity Level \"\n                            << error_codes[i] << \", On Processor \" << this->myProcessor\n                            << \" **\\n\\n\";\n            Ioss::WARNING() << error_messages[i];\n          }\n          else {\n            std::ostringstream errmsg;\n            errmsg << \"\\n\\n** ParaView Catalyst Plugin Error Message Severity Level \"\n                   << error_codes[i] << \", On Processor \" << this->myProcessor << \" **\\n\\n\"\n                   << error_messages[i];\n            IOSS_ERROR(errmsg);\n          }\n        }\n      }\n    }\n    return true;\n  }\n\n  void DatabaseIO::read_meta_data__() {}\n\n  int DatabaseIO::parseCatalystFile(const std::string &filepath, std::string &json_result)\n  {\n    ParaViewCatalystIossAdapterBase *pvcsp = nullptr;\n\n    pvcsp = DatabaseIO::load_plugin_library(\"ParaViewCatalystIossAdapter\",\n                                            CATALYST_PLUGIN_DYNAMIC_LIBRARY);\n\n    CatalystParserInterface::parse_info pinfo;\n\n    int ret     = pvcsp->parseFile(filepath, pinfo);\n    json_result = pinfo.json_result;\n\n    delete pvcsp;\n    return ret;\n  }\n\n  void DatabaseIO::create_global_node_and_element_ids() const\n  {\n    const Ioss::ElementBlockContainer &element_blocks = this->get_region()->get_element_blocks();\n    Ioss::ElementBlockContainer::const_iterator I;\n    std::vector<std::string>                    component_names;\n    component_names.emplace_back(\"GlobalElementId\");\n    for (I = element_blocks.begin(); I != element_blocks.end(); ++I) {\n      int     bid       = get_id((*I), &ids_);\n      int64_t eb_offset = (*I)->get_offset();\n      if (this->pvcsa != nullptr) {\n        this->pvcsa->CreateElementVariable(\n            component_names, bid, &this->elemMap.map()[eb_offset + 1], this->DBFilename.c_str());\n      }\n    }\n\n    component_names.clear();\n    component_names.emplace_back(\"GlobalNodeId\");\n    if (this->pvcsa != nullptr) {\n      this->pvcsa->CreateNodalVariable(component_names, &this->nodeMap.map()[1],\n                                       this->DBFilename.c_str());\n    }\n\n    this->globalNodeAndElementIDsCreated = true;\n  }\n\n  //------------------------------------------------------------------------\n  int64_t DatabaseIO::put_field_internal(const Ioss::Region * /* region */,\n                                         const Ioss::Field &field, void *data,\n                                         size_t data_size) const\n  {\n    // For now, assume that all TRANSIENT fields on a region\n    // are REDUCTION fields (1 value).  We need to gather these\n    // and output them all at one time.  The storage location is a\n    // 'globalVariables' array\n    Ioss::SerializeIO serializeIO__(this);\n\n    size_t                    num_to_get = field.verify(data_size);\n    Ioss::Field::RoleType     role       = field.get_role();\n    const Ioss::VariableType *var_type   = field.transformed_storage();\n    if ((role == Ioss::Field::TRANSIENT || role == Ioss::Field::REDUCTION) && num_to_get == 1) {\n      const char *           complex_suffix[] = {\".re\", \".im\"};\n      Ioss::Field::BasicType ioss_type        = field.get_type();\n      auto *                 rvar             = static_cast<double *>(data);\n      int *                  ivar             = static_cast<int *>(data);\n      auto *                 ivar64           = static_cast<int64_t *>(data);\n\n      int comp_count = var_type->component_count();\n\n      int re_im = 1;\n      if (field.get_type() == Ioss::Field::COMPLEX) {\n        re_im = 2;\n      }\n      for (int complex_comp = 0; complex_comp < re_im; complex_comp++) {\n        std::string field_name = field.get_name();\n        if (re_im == 2) {\n          field_name += complex_suffix[complex_comp];\n        }\n\n        std::vector<std::string> component_names;\n        std::vector<double>      globalValues;\n        char                     field_suffix_separator = get_field_separator();\n        for (int i = 0; i < comp_count; i++) {\n          std::string var_name = var_type->label_name(field_name, i + 1, field_suffix_separator);\n          component_names.push_back(var_name);\n\n          // Transfer from 'variables' array.\n          if (ioss_type == Ioss::Field::REAL || ioss_type == Ioss::Field::COMPLEX) {\n            globalValues.push_back(rvar[i]);\n          }\n          else if (ioss_type == Ioss::Field::INTEGER) {\n            globalValues.push_back(ivar[i]);\n          }\n          else if (ioss_type == Ioss::Field::INT64) {\n            globalValues.push_back(ivar64[i]);\n          }\n        }\n        if (this->pvcsa != nullptr) {\n          this->pvcsa->CreateGlobalVariable(component_names, globalValues.data(),\n                                            this->DBFilename.c_str());\n        }\n      }\n    }\n    else if (num_to_get != 1) {\n      // There should have been a warning/error message printed to the\n      // log file earlier for this, so we won't print anything else\n      // here since it would be printed for each and every timestep....\n      ;\n    }\n    else {\n      std::ostringstream errmsg;\n      errmsg << \"The variable named '\" << field.get_name()\n             << \"' is of the wrong type. A region variable must be of type\"\n             << \" TRANSIENT or REDUCTION.\\n\"\n             << \"This is probably an internal error; please notify gdsjaar@sandia.gov\";\n      IOSS_ERROR(errmsg);\n    }\n    return num_to_get;\n  }\n\n  int64_t DatabaseIO::put_field_internal(const Ioss::NodeBlock *nb, const Ioss::Field &field,\n                                         void *data, size_t data_size) const\n  {\n    Ioss::SerializeIO serializeIO__(this);\n    size_t            num_to_get = field.verify(data_size);\n\n    if (num_to_get > 0) {\n      Ioss::Field::RoleType role = field.get_role();\n\n      if (role == Ioss::Field::MESH) {\n        if (field.get_name() == \"mesh_model_coordinates\") {\n          if (this->pvcsa != nullptr) {\n            this->pvcsa->InitializeGlobalPoints(\n                num_to_get, nb->get_property(\"component_degree\").get_int(),\n                static_cast<double *>(data), this->DBFilename.c_str());\n          }\n        }\n        else if (field.get_name() == \"ids\") {\n          // The ids coming in are the global ids; their position is the\n          // local id -1 (That is, data[0] contains the global id of local\n          // node 1)\n\n          // Another 'const-cast' since we are modifying the database just\n          // for efficiency; which the client does not see...\n          auto *new_this = const_cast<DatabaseIO *>(this);\n          /*64 bit should be okay*/\n          new_this->handle_node_ids(data, num_to_get);\n        }\n        else if (field.get_name() == \"connectivity\") {\n          // Do nothing, just handles an idiosyncrasy of the GroupingEntity\n        }\n        else {\n          return field_warning(nb, field, \"mesh output\");\n        }\n      }\n      else if (role == Ioss::Field::TRANSIENT) {\n        const char *              complex_suffix[] = {\".re\", \".im\"};\n        Ioss::Field::BasicType    ioss_type        = field.get_type();\n        const Ioss::VariableType *var_type         = field.transformed_storage();\n        std::vector<double>       temp(num_to_get);\n        int                       comp_count = var_type->component_count();\n        int                       re_im      = 1;\n        if (ioss_type == Ioss::Field::COMPLEX) {\n          re_im = 2;\n        }\n        for (int complex_comp = 0; complex_comp < re_im; complex_comp++) {\n          std::string field_name = field.get_name();\n          if (re_im == 2) {\n            field_name += complex_suffix[complex_comp];\n          }\n\n          std::vector<double>      interleaved_data(num_to_get * comp_count);\n          std::vector<std::string> component_names;\n          char                     field_suffix_separator = get_field_separator();\n          for (int i = 0; i < comp_count; i++) {\n            std::string var_name = var_type->label_name(field_name, i + 1, field_suffix_separator);\n            component_names.push_back(var_name);\n\n            size_t begin_offset = (re_im * i) + complex_comp;\n            size_t stride       = re_im * comp_count;\n\n            if (ioss_type == Ioss::Field::REAL || ioss_type == Ioss::Field::COMPLEX) {\n              this->nodeMap.map_field_to_db_scalar_order(static_cast<double *>(data), temp,\n                                                         begin_offset, num_to_get, stride, 0);\n            }\n            else if (ioss_type == Ioss::Field::INTEGER) {\n              this->nodeMap.map_field_to_db_scalar_order(static_cast<int *>(data), temp,\n                                                         begin_offset, num_to_get, stride, 0);\n            }\n            else if (ioss_type == Ioss::Field::INT64) {\n              this->nodeMap.map_field_to_db_scalar_order(static_cast<int64_t *>(data), temp,\n                                                         begin_offset, num_to_get, stride, 0);\n            }\n\n            for (unsigned int j = 0; j < num_to_get; j++) {\n              interleaved_data[j * comp_count + i] = temp[j];\n            }\n          }\n\n          if (this->pvcsa != nullptr) {\n            this->pvcsa->CreateNodalVariable(component_names, interleaved_data.data(),\n                                             this->DBFilename.c_str());\n          }\n        }\n      }\n      else if (role == Ioss::Field::REDUCTION) {\n        // TODO imesh version\n        // write_global_field(entity_type::NODAL, field, nb, data);\n      }\n    }\n    return num_to_get;\n  }\n\n  int64_t DatabaseIO::put_field_internal(const Ioss::ElementBlock *eb, const Ioss::Field &field,\n                                         void *data, size_t data_size) const\n  {\n    Ioss::SerializeIO serializeIO__(this);\n\n    size_t num_to_get = field.verify(data_size);\n    if (num_to_get > 0) {\n\n      // Get the element block id and element count\n\n      int64_t               element_count = eb->entity_count();\n      Ioss::Field::RoleType role          = field.get_role();\n\n      if (role == Ioss::Field::MESH) {\n        // Handle the MESH fields required for an ExodusII file model.\n        // (The 'genesis' portion)\n        if (field.get_name() == \"connectivity\") {\n          if (element_count > 0) {\n            // Map element connectivity from global node id to local node id.\n            // Do it in 'data' ...\n            int element_nodes = eb->topology()->number_nodes();\n            assert(field.transformed_storage()->component_count() == element_nodes);\n            nodeMap.reverse_map_data(data, field, num_to_get * element_nodes);\n            Ioss::Field::BasicType ioss_type = field.get_type();\n            int64_t                eb_offset = eb->get_offset();\n            int                    id        = get_id(eb, &ids_);\n\n            if (ioss_type == Ioss::Field::INTEGER) {\n              if (this->pvcsa != nullptr) {\n                this->pvcsa->CreateElementBlock(\n                    eb->name().c_str(), id, eb->topology()->name(),\n                    element_nodes, num_to_get, &this->elemMap.map()[eb_offset + 1],\n                    static_cast<int *>(data), this->DBFilename.c_str());\n              }\n            }\n            else if (ioss_type == Ioss::Field::INT64) {\n              if (this->pvcsa != nullptr) {\n                this->pvcsa->CreateElementBlock(\n                    eb->name().c_str(), id, eb->topology()->name(),\n                    element_nodes, num_to_get, &this->elemMap.map()[eb_offset + 1],\n                    static_cast<int64_t *>(data), this->DBFilename.c_str());\n              }\n            }\n          }\n        }\n        else if (field.get_name() == \"ids\") {\n          // Another 'const-cast' since we are modifying the database just\n          // for efficiency; which the client does not see...\n          auto *new_this = const_cast<DatabaseIO *>(this);\n          new_this->handle_element_ids(eb, data, num_to_get);\n        }\n        else if (field.get_name() == \"skin\") {\n          // Not applicable to viz output.\n        }\n        else {\n          Ioss::WARNING() << \" ElementBlock \" << eb->name() << \". Unknown field \"\n                          << field.get_name();\n          num_to_get = 0;\n        }\n      }\n      else if (role == Ioss::Field::ATTRIBUTE) {\n        /* TODO */\n      }\n      else if (role == Ioss::Field::TRANSIENT) {\n        const char *              complex_suffix[] = {\".re\", \".im\"};\n        const Ioss::VariableType *var_type         = field.transformed_storage();\n        Ioss::Field::BasicType    ioss_type        = field.get_type();\n        std::vector<double>       temp(num_to_get);\n        ssize_t                   eb_offset  = eb->get_offset();\n        int                       comp_count = var_type->component_count();\n        int                       bid        = get_id(eb, &ids_);\n\n        int re_im = 1;\n        if (ioss_type == Ioss::Field::COMPLEX) {\n          re_im = 2;\n        }\n        for (int complex_comp = 0; complex_comp < re_im; complex_comp++) {\n          std::string field_name = field.get_name();\n          if (re_im == 2) {\n            field_name += complex_suffix[complex_comp];\n          }\n\n          std::vector<double>      interleaved_data(num_to_get * comp_count);\n          std::vector<std::string> component_names;\n          char                     field_suffix_separator = get_field_separator();\n          for (int i = 0; i < comp_count; i++) {\n            std::string var_name = var_type->label_name(field_name, i + 1, field_suffix_separator);\n            component_names.push_back(var_name);\n\n            ssize_t begin_offset = (re_im * i) + complex_comp;\n            ssize_t stride       = re_im * comp_count;\n\n            if (ioss_type == Ioss::Field::REAL || ioss_type == Ioss::Field::COMPLEX) {\n              this->elemMap.map_field_to_db_scalar_order(\n                  static_cast<double *>(data), temp, begin_offset, num_to_get, stride, eb_offset);\n            }\n            else if (ioss_type == Ioss::Field::INTEGER) {\n              this->elemMap.map_field_to_db_scalar_order(\n                  static_cast<int *>(data), temp, begin_offset, num_to_get, stride, eb_offset);\n            }\n            else if (ioss_type == Ioss::Field::INT64) {\n              this->elemMap.map_field_to_db_scalar_order(\n                  static_cast<int64_t *>(data), temp, begin_offset, num_to_get, stride, eb_offset);\n            }\n            for (unsigned int j = 0; j < num_to_get; j++) {\n              interleaved_data[j * comp_count + i] = temp[j];\n            }\n          }\n          if (this->pvcsa != nullptr) {\n            this->pvcsa->CreateElementVariable(component_names, bid, interleaved_data.data(),\n                                               this->DBFilename.c_str());\n          }\n        }\n      }\n      else if (role == Ioss::Field::REDUCTION) {\n        // TODO replace with ITAPS\n        // write_global_field(entity_type::ELEM_BLOCK, field, eb, data);\n      }\n    }\n    return num_to_get;\n  }\n\n  void DatabaseIO::write_meta_data()\n  {\n    Ioss::Region *region = get_region();\n\n    // Node Blocks --\n    {\n      // std::cerr << \"DatabaseIO::write_meta_data node blocks\\n\";\n      const Ioss::NodeBlockContainer &node_blocks = region->get_node_blocks();\n      assert(node_blocks.size() == 1);\n      nodeCount = node_blocks[0]->entity_count();\n      // std::cerr << \"DatabaseIO::write_meta_data nodeCount:\" << nodeCount << \"\\n\";\n    }\n\n    // NodeSets ...\n    {\n      const Ioss::NodeSetContainer &         nodesets = region->get_nodesets();\n      Ioss::NodeSetContainer::const_iterator I;\n      for (I = nodesets.begin(); I != nodesets.end(); ++I) {\n        set_id(*I, &ids_);\n      }\n    }\n\n    // SideSets ...\n    {\n      const Ioss::SideSetContainer &         ssets = region->get_sidesets();\n      Ioss::SideSetContainer::const_iterator I;\n\n      for (I = ssets.begin(); I != ssets.end(); ++I) {\n        set_id(*I, &ids_);\n      }\n    }\n\n    // Element Blocks --\n    {\n      const Ioss::ElementBlockContainer &         element_blocks = region->get_element_blocks();\n      Ioss::ElementBlockContainer::const_iterator I;\n      // Set ids of all entities that have \"id\" property...\n      for (I = element_blocks.begin(); I != element_blocks.end(); ++I) {\n        set_id(*I, &ids_);\n      }\n\n      elementBlockCount = 0;\n      elementCount      = 0;\n      // std::cerr << \"DatabaseIO::write_meta_data element num blocks:\" << element_blocks.size() <<\n      // \"\\n\";\n      for (I = element_blocks.begin(); I != element_blocks.end(); ++I) {\n        elementBlockCount++;\n        elementCount += (*I)->entity_count();\n        // std::cerr << \"DatabaseIO::write_meta_data element num in block \" << elementBlockCount <<\n        // \": \" << (*I)->entity_count() << \"\\n\";\n      }\n      // std::cerr << \"DatabaseIO::write_meta_data elementCount:\" << elementCount << \"\\n\";\n    }\n    // std::cerr << \"DatabaseIO::write_meta_data returning\\n\";\n  }\n\n  int64_t DatabaseIO::handle_node_ids(void *ids, int64_t num_to_get)\n  {\n    // std::cerr << \"DatabaseIO::handle_node_ids executing\\n\";\n    /*!\n     * There are two modes we need to support in this routine:\n     * 1. Initial definition of node map (local->global) and\n     * reverseNodeMap (global->local).\n     * 2. Redefinition of node map via 'reordering' of the original\n     * map when the nodes on this processor are the same, but their\n     * order is changed (or count because of ghosting)\n     *\n     * So, there will be two maps the 'nodeMap' map is a 'direct lookup'\n     * map which maps current local position to global id and the\n     * 'reverseNodeMap' is an associative lookup which maps the\n     * global id to 'original local'.  There is also a\n     * 'reorderNodeMap' which is direct lookup and maps current local\n     * position to original local.\n\n     * The ids coming in are the global ids; their position is the\n     * \"local id-1\" (That is, data[0] contains the global id of local\n     * node 1 in this node block).\n     *\n     * int local_position = reverseNodeMap[NodeMap[i+1]]\n     * (the nodeMap and reverseNodeMap are 1-based)\n     *\n     * To determine which map to update on a call to this function, we\n     * use the following hueristics:\n     * -- If the database state is 'STATE_MODEL:', then update the\n     *    'reverseNodeMap' and 'nodeMap'\n     *\n     * -- If the database state is not STATE_MODEL, then leave the\n     *    'reverseNodeMap' and 'nodeMap' alone since they correspond to the\n     *    information already written to the database. [May want to add a\n     *    STATE_REDEFINE_MODEL]\n     *\n     * -- In both cases, update the reorderNodeMap\n     *\n     * NOTE: The mapping is done on TRANSIENT fields only; MODEL fields\n     *       should be in the original order...\n     */\n    assert(num_to_get == nodeCount);\n\n    nodeMap.set_size(nodeCount);\n\n    // std::cerr << \"DatabaseIO::handle_node_ids nodeMap tagged serial, doing mapping\\n\";\n    bool in_define = (dbState == Ioss::STATE_MODEL) || (dbState == Ioss::STATE_DEFINE_MODEL);\n    if (int_byte_size_api() == 4) {\n      nodeMap.set_map(static_cast<int *>(ids), num_to_get, 0, in_define);\n    }\n    else {\n      nodeMap.set_map(static_cast<int64_t *>(ids), num_to_get, 0, in_define);\n    }\n\n    if (in_define) {\n      // Only a single nodeblock and all set\n      assert(get_region()->get_property(\"node_block_count\").get_int() == 1);\n    }\n    return num_to_get;\n  }\n\n  size_t handle_block_ids(const Ioss::EntityBlock *eb, Ioss::State db_state, Ioss::Map &entity_map,\n                          void *ids, size_t int_byte_size, size_t num_to_get,\n                          /*int file_pointer,*/ int /*my_processor*/)\n  {\n    // std::cerr << \"DatabaseIO::handle_block_ids executing\\n\";\n    /*!\n     * NOTE: \"element\" is generic for \"element\", \"face\", or \"edge\"\n     *\n     * There are two modes we need to support in this routine:\n     * 1. Initial definition of element map (local->global) and\n     * reverseElementMap (global->local).\n     * 2. Redefinition of element map via 'reordering' of the original\n     * map when the elements on this processor are the same, but their\n     * order is changed.\n     *\n     * So, there will be two maps the 'elementMap' map is a 'direct lookup'\n     * map which maps current local position to global id and the\n     * 'reverseElementMap' is an associative lookup which maps the\n     * global id to 'original local'.  There is also a\n     * 'reorderElementMap' which is direct lookup and maps current local\n     * position to original local.\n\n     * The ids coming in are the global ids; their position is the\n     * local id -1 (That is, data[0] contains the global id of local\n     * element 1 in this element block).  The 'model-local' id is\n     * given by eb_offset + 1 + position:\n     *\n     * int local_position = reverseElementMap[ElementMap[i+1]]\n     * (the elementMap and reverseElementMap are 1-based)\n     *\n     * But, this assumes 1..numel elements are being output at the same\n     * time; we are actually outputting a blocks worth of elements at a\n     * time, so we need to consider the block offsets.\n     * So... local-in-block position 'i' is index 'eb_offset+i' in\n     * 'elementMap' and the 'local_position' within the element\n     * blocks data arrays is 'local_position-eb_offset'.  With this, the\n     * position within the data array of this element block is:\n     *\n     * int eb_position =\n     * reverseElementMap[elementMap[eb_offset+i+1]]-eb_offset-1\n     *\n     * To determine which map to update on a call to this function, we\n     * use the following hueristics:\n     * -- If the database state is 'Ioss::STATE_MODEL:', then update the\n     *    'reverseElementMap'.\n     * -- If the database state is not Ioss::STATE_MODEL, then leave\n     *    the 'reverseElementMap' alone since it corresponds to the\n     *    information already written to the database. [May want to add\n     *    a Ioss::STATE_REDEFINE_MODEL]\n     * -- Always update elementMap to match the passed in 'ids'\n     *    array.\n     *\n     * NOTE: the maps are built an element block at a time...\n     * NOTE: The mapping is done on TRANSIENT fields only; MODEL fields\n     *       should be in the original order...\n     */\n\n    // Overwrite this portion of the 'elementMap', but keep other\n    // parts as they were.  We are adding elements starting at position\n    // 'eb_offset+offset' and ending at\n    // 'eb_offset+offset+num_to_get'. If the entire block is being\n    // processed, this reduces to the range 'eb_offset..eb_offset+my_element_count'\n\n    int64_t eb_offset = eb->get_offset();\n\n    bool in_define = (db_state == Ioss::STATE_MODEL) || (db_state == Ioss::STATE_DEFINE_MODEL);\n    if (int_byte_size == 4) {\n      entity_map.set_map(static_cast<int *>(ids), num_to_get, eb_offset, in_define);\n    }\n    else {\n      entity_map.set_map(static_cast<int64_t *>(ids), num_to_get, eb_offset, in_define);\n    }\n    return num_to_get;\n  }\n\n  int64_t DatabaseIO::handle_element_ids(const Ioss::ElementBlock *eb, void *ids, size_t num_to_get)\n  {\n    // std::cerr << \"DatabaseIO::handle_element_ids executing num_to_get: \" << num_to_get << \"\\n\";\n    elemMap.set_size(elementCount);\n    // std::cerr << \"DatabaseIO::handle_element_ids elementMap size: \" << elementMap.size() << \"\\n\";\n    return handle_block_ids(eb, dbState, elemMap, ids, int_byte_size_api(), num_to_get,\n                            /*get_file_pointer(),*/ myProcessor);\n  }\n\n  const Ioss::Map &DatabaseIO::get_node_map() const\n  {\n    // std::cerr << \"in new nathan Iovs DatabaseIO::get_node_reorder_map\\n\";\n    // Allocate space for node number map and read it in...\n    // Can be called multiple times, allocate 1 time only\n    if (nodeMap.map().empty()) {\n      // std::cerr << \"DatabaseIO::get_node_map  nodeMap was empty, resizing and tagging\n      // sequential\\n\";\n      nodeMap.set_size(nodeCount);\n\n      // Output database; nodeMap not set yet... Build a default map.\n      for (int64_t i = 1; i < nodeCount + 1; i++) {\n        nodeMap.map()[i] = i;\n      }\n    }\n    return nodeMap;\n  }\n\n  // Not used...\n  const Ioss::Map &DatabaseIO::get_element_map() const\n  {\n    // std::cercercerrn new nathan Iovs DatabaseIO::get_element_map\\n\";\n    // Allocate space for element number map and read it in...\n    // Can be called multiple times, allocate 1 time only\n    if (elemMap.map().empty()) {\n      elemMap.set_size(elementCount);\n\n      // Output database; elementMap not set yet... Build a default map.\n      for (int64_t i = 1; i < elementCount + 1; i++) {\n        elemMap.map()[i] = i;\n      }\n    }\n    return elemMap;\n  }\n\n  int field_warning(const Ioss::GroupingEntity *ge, const Ioss::Field &field,\n                    const std::string &inout)\n  {\n    Ioss::WARNING() << ge->type() << \" '\" << ge->name() << \"'. Unknown \" << inout << \" field '\"\n                    << field.get_name() << \"'\";\n    return -4;\n  }\n\n  int64_t DatabaseIO::put_field_internal(const Ioss::NodeSet *ns, const Ioss::Field &field,\n                                         void *data, size_t data_size) const\n  {\n    int64_t num_to_get          = field.verify(data_size);\n    int64_t cns_save_num_to_get = 0;\n\n    if (num_to_get > 0 && (field.get_name() == \"ids\" || field.get_name() == \"ids_raw\")) {\n\n      int id = get_id(ns, &this->ids_);\n\n      if (this->createNodeSets == 0) {\n        cns_save_num_to_get = num_to_get;\n        num_to_get          = 0;\n      }\n\n      if (field.get_type() == Ioss::Field::INTEGER) {\n        this->nodeMap.reverse_map_data(data, field, num_to_get);\n        if (this->pvcsa != nullptr) {\n          this->pvcsa->CreateNodeSet(ns->name().c_str(), id, num_to_get, static_cast<int *>(data),\n                                     this->DBFilename.c_str());\n        }\n      }\n      else if (field.get_type() == Ioss::Field::INT64) {\n        this->nodeMap.reverse_map_data(data, field, num_to_get);\n        if (this->pvcsa != nullptr) {\n          this->pvcsa->CreateNodeSet(ns->name().c_str(), id, num_to_get,\n                                     static_cast<int64_t *>(data), this->DBFilename.c_str());\n        }\n      }\n\n      if (this->createNodeSets == 0) {\n        num_to_get = cns_save_num_to_get;\n      }\n    }\n    return num_to_get;\n  }\n\n  int64_t DatabaseIO::put_field_internal(const Ioss::SideSet *fs, const Ioss::Field &field,\n                                         void * /*data*/, size_t data_size) const\n  {\n    size_t num_to_get = field.verify(data_size);\n    if (field.get_name() == \"ids\") {\n      // Do nothing, just handles an idiosyncrasy of the GroupingEntity\n    }\n    else {\n      num_to_get = Ioss::Utils::field_warning(fs, field, \"output\");\n    }\n    return num_to_get;\n  }\n\n  int64_t DatabaseIO::put_field_internal(const Ioss::SideBlock *eb, const Ioss::Field &field,\n                                         void *data, size_t data_size) const\n  {\n    int64_t num_to_get          = field.verify(data_size);\n    int64_t css_save_num_to_get = 0;\n\n    if ((field.get_name() == \"element_side\") || (field.get_name() == \"element_side_raw\")) {\n      size_t side_offset = Ioss::Utils::get_side_offset(eb);\n\n      int id = get_id(eb, &this->ids_);\n\n      size_t index = 0;\n\n      if (field.get_type() == Ioss::Field::INTEGER) {\n        Ioss::IntVector element(num_to_get);\n        Ioss::IntVector side(num_to_get);\n        int *           el_side = static_cast<int *>(data);\n\n        for (unsigned int i = 0; i < num_to_get; i++) {\n          element[i] = el_side[index++];\n          side[i]    = el_side[index++] + side_offset;\n        }\n\n        if (this->createSideSets == 0) {\n          css_save_num_to_get = num_to_get;\n          num_to_get          = 0;\n        }\n\n        // std::cerr << \"Iovs_DatabaseIO::\"\n        //    \"put_field_internal doing CreateSideSet (1)\\n\";\n        if (this->pvcsa != nullptr) {\n          const Ioss::SideSet *ebowner = eb->owner();\n          /*\n          if(ebowner == NULL)\n            {\n            std::cerr << \"eb->owner() returned null\\n\";\n            }\n          else\n            {\n            std::cerr << \"eb->owner() not null\\n\";\n            std::cerr << \"ebowner->name(): \" << ebowner->name() << \"\\n\";\n            }\n          */\n          /*NOTE: Jeff Mauldin JAM 2015Oct8\n           CreateSideSet is called once for each block which the sideset\n           spans, and the eb->name() for the side set is the ebowner->name()\n           with additional characters to indicate which block we are doing.\n           The current implementation of the sierra/catalyst sideset\n           construction creates a single independent sideset and collects all\n           the nodes and elements from the side set from each block spanned\n           by the sideset into that single sideset.  It needs to have the\n           ebowner->name(), not the eb->name(), because that is the name\n           in the input deck for the sideset for reference for things like\n           extractblock.  It may become necessary at a later date to\n           pass in both ebowner->name() AND eb->name(), but for now we\n           are just passing in ebowner->name() to give us correct\n           functionality while not changing the function interface*/\n          this->pvcsa->CreateSideSet(/*eb->name().c_str(),*/\n                                     ebowner->name().c_str(), id, num_to_get, &element[0], &side[0],\n                                     this->DBFilename.c_str());\n        }\n        // std::cerr << \"Iovs_DatabaseIO::\"\n        //    \"put_field_internal back from CreateSideSet (1) \\n\";\n        //\n        //\n        if (this->createSideSets == 0) {\n          num_to_get = css_save_num_to_get;\n        }\n      }\n      else {\n        Ioss::Int64Vector element(num_to_get);\n        Ioss::Int64Vector side(num_to_get);\n        auto *            el_side = static_cast<int64_t *>(data);\n\n        for (unsigned int i = 0; i < num_to_get; i++) {\n          element[i] = el_side[index++];\n          side[i]    = el_side[index++] + side_offset;\n        }\n\n        if (this->createSideSets == 0) {\n          css_save_num_to_get = num_to_get;\n          num_to_get          = 0;\n        }\n\n        // std::cerr << \"Iovs_DatabaseIO::\"\n        //    \"put_field_internal doing CreateSideSet (2)\\n\";\n        if (this->pvcsa != nullptr) {\n          const Ioss::SideSet *ebowner = eb->owner();\n          /*\n          if(ebowner == NULL)\n            {\n            std::cerr << \"eb->owner() returned null\\n\";\n            }\n          else\n            {\n            std::cerr << \"eb->owner() not null\\n\";\n            std::cerr << \"ebowner->name(): \" << ebowner->name() << \"\\n\";\n            }\n          */\n          /*NOTE: Jeff Mauldin JAM 2015Oct8\n           CreateSideSet is called once for each block which the sideset\n           spans, and the eb->name() for the side set is the ebowner->name()\n           with additional characters to indicate which block we are doing.\n           The current implementation of the sierra/catalyst sideset\n           construction creates a single independent sideset and collects all\n           the nodes and elements from the side set from each block spanned\n           by the sideset into that single sideset.  It needs to have the\n           ebowner->name(), not the eb->name(), because that is the name\n           in the input deck for the sideset for reference for things like\n           extractblock.  It may become necessary at a later date to\n           pass in both ebowner->name() AND eb->name(), but for now we\n           are just passing in ebowner->name() to give us correct\n           functionality while not changing the function interface*/\n          this->pvcsa->CreateSideSet(/*eb->name().c_str(),*/\n                                     ebowner->name().c_str(), id, num_to_get, &element[0], &side[0],\n                                     this->DBFilename.c_str());\n        }\n        // std::cerr << \"Iovs_DatabaseIO::\"\n        //    \"put_field_internal back from CreateSideSet (2) \\n\";\n        //\n        if (this->createSideSets == 0) {\n          num_to_get = css_save_num_to_get;\n        }\n      }\n    }\n    return num_to_get;\n  }\n} // namespace Iovs\n\nnamespace {\n\n  int64_t get_id(const Ioss::GroupingEntity *entity, Iovs::EntityIdSet *idset)\n  {\n    // Sierra uses names to refer to grouping entities; however,\n    // exodusII requires integer ids.  When reading an exodusII file,\n    // the DatabaseIO creates a name by concatenating the entity\n    // type (e.g., 'block') and the id separated by an underscore.  For\n    // example, an exodusII element block with an id of 100 would be\n    // encoded into \"block_100\"\n\n    // This routine tries to determine the id of the entity using 3\n    // approaches:\n    //\n    // 1. If the entity contains a property named 'id', this is used.\n    // The DatabaseIO actually stores the id in the \"id\" property;\n    // however, other grouping entity creators are not required to do\n    // this so the property is not guaranteed to exist.\n    //\n    // 2.If property does not exist, it tries to decode the entity name\n    // based on the above encoding.  Again, it is not required that the\n    // name follow this convention so success is not guaranteed.\n    //\n    // 3. If all other schemes fail, the routine picks an id for the entity\n    // and returns it.  It also stores this id in the \"id\" property so an\n    // entity will always return the same id for multiple calls.\n    // Note that this violates the 'const'ness of the entity so we use\n    // a const-cast.\n\n    // Avoid a few string constructors/destructors\n    static std::string prop_name(\"name\");\n    static std::string id_prop(\"id\");\n\n    int64_t id = 1;\n\n    if (entity->property_exists(id_prop)) {\n      id = entity->get_property(id_prop).get_int();\n      return id;\n    }\n\n    // Try to decode an id from the name.\n    std::string name_string = entity->get_property(prop_name).get_string();\n    id                      = extract_id(name_string);\n    if (id <= 0) {\n      id = 1;\n    }\n\n    // At this point, we either have an id equal to '1' or we have an id\n    // extracted from the entities name. Increment it until it is\n    // unique...\n    int type = static_cast<int>(entity->type());\n    while (idset->find(std::make_pair(type, id)) != idset->end()) {\n      ++id;\n    }\n\n    // 'id' is a unique id for this entity type...\n    idset->insert(std::make_pair(type, id));\n    auto *new_entity = const_cast<Ioss::GroupingEntity *>(entity);\n    new_entity->property_add(Ioss::Property(id_prop, id));\n    return id;\n  }\n\n  bool set_id(const Ioss::GroupingEntity *entity, Iovs::EntityIdSet *idset)\n  {\n    // See description of 'get_id' function.  This function just primes\n    // the idset with existing ids so that when we start generating ids,\n    // we don't overwrite an existing one.\n\n    // Avoid a few string constructors/destructors\n    static std::string prop_name(\"name\");\n    static std::string id_prop(\"id\");\n\n    bool succeed = false;\n    if (entity->property_exists(id_prop)) {\n      int64_t id = entity->get_property(id_prop).get_int();\n\n      // See whether it already exists...\n      int type = static_cast<int>(entity->type());\n      succeed  = idset->insert(std::make_pair(type, id)).second;\n      if (!succeed) {\n        // Need to remove the property so it doesn't cause problems\n        // later...\n        auto *new_entity = const_cast<Ioss::GroupingEntity *>(entity);\n        new_entity->property_erase(id_prop);\n        assert(!entity->property_exists(id_prop));\n      }\n    }\n    return succeed;\n  }\n\n  int64_t extract_id(const std::string &name_id)\n  {\n    std::vector<std::string> tokens = Ioss::tokenize(name_id, \"_\");\n\n    if (tokens.size() == 1) {\n      return 0;\n    }\n\n    // Check whether last token is an integer...\n    std::string str_id = tokens[tokens.size() - 1];\n    size_t      len    = str_id.length();\n    bool        is_int = true;\n    for (size_t i = 0; i < len; i++) {\n      if (str_id[i] < '0' || str_id[i] > '9') {\n        is_int = false;\n        break;\n      }\n    }\n    if (is_int) {\n      return std::atoi(str_id.c_str());\n    }\n\n    return 0;\n  }\n\n  void build_catalyst_plugin_paths(std::string &      plugin_library_path,\n                                   std::string &      plugin_python_path,\n                                   const std::string &plugin_library_name)\n  {\n\n    if (getenv(\"CATALYST_ADAPTER_INSTALL_DIR\") != nullptr) {\n      std::string catalyst_ins_dir = getenv(\"CATALYST_ADAPTER_INSTALL_DIR\");\n\n      if (!file_exists(catalyst_ins_dir)) {\n        std::ostringstream errmsg;\n        errmsg << \"CATALYST_ADAPTER_INSTALL_DIR directory does not exist.\\n\"\n               << \"Directory path: \" << catalyst_ins_dir << \"\\n\"\n               << \"Unable to find ParaView catalyst dynamic library.\\n\";\n        IOSS_ERROR(errmsg);\n        return;\n      }\n\n      plugin_library_path = catalyst_ins_dir + \"/lib/\" + plugin_library_name;\n\n      plugin_python_path = catalyst_ins_dir + \"/python/\" + CATALYST_PLUGIN_PYTHON_MODULE;\n      return;\n    }\n\n    std::string sierra_ins_dir;\n    if (getenv(\"SIERRA_INSTALL_DIR\") != nullptr) {\n      sierra_ins_dir = getenv(\"SIERRA_INSTALL_DIR\");\n    }\n    else {\n      std::ostringstream errmsg;\n      errmsg << \"Environment variable SIERRA_INSTALL_DIR not set.\\n\"\n             << \"\\tUnable to find ParaView catalyst dynamic library.\";\n      IOSS_ERROR(errmsg);\n      return;\n    }\n\n    std::string sierra_system;\n    if (getenv(\"SIERRA_SYSTEM\") != nullptr) {\n      sierra_system = getenv(\"SIERRA_SYSTEM\");\n    }\n    else {\n      std::ostringstream errmsg;\n      errmsg << \"Environment variable SIERRA_SYSTEM not set.\\n\"\n             << \"\\tUnable to find ParaView catalyst dynamic library.\";\n      IOSS_ERROR(errmsg);\n      return;\n    }\n\n    std::string sierra_version;\n    if (getenv(\"SIERRA_VERSION\") != nullptr) {\n      sierra_version = getenv(\"SIERRA_VERSION\");\n    }\n    else {\n      std::ostringstream errmsg;\n      errmsg << \"Environment variable SIERRA_VERSION not set.\\n\"\n             << \"\\tUnable to find ParaView catalyst dynamic library.\";\n      IOSS_ERROR(errmsg);\n      return;\n    }\n\n#ifdef _WIN32\n    char *cbuf = _fullpath(nullptr, sierra_ins_dir.c_str(), _MAX_PATH);\n#else\n    char *cbuf = realpath(sierra_ins_dir.c_str(), nullptr);\n#endif\n    std::string sierra_ins_path = cbuf;\n    free(cbuf);\n\n    if (!file_exists(sierra_ins_path)) {\n      std::ostringstream errmsg;\n      errmsg << \"SIERRA_INSTALL_DIR directory does not exist.\\n\"\n             << \"Directory path: \" << sierra_ins_path << \"\\n\"\n             << \" Unable to find ParaView catalyst dynamic library.\\n\";\n      IOSS_ERROR(errmsg);\n      return;\n    }\n\n    char *cbase = strdup(sierra_ins_path.c_str());\n    char *cdir  = strdup(sierra_ins_path.c_str());\n    char *bname = basename(cbase);\n    char *dname = dirname(cdir);\n\n    while (strcmp(dname, \"/\") != 0 && strcmp(dname, \".\") != 0 && strcmp(bname, \"sierra\") != 0) {\n      bname = basename(dname);\n      dname = dirname(dname);\n    }\n\n    if (strcmp(bname, \"sierra\") == 0) {\n      sierra_ins_path = dname;\n    }\n\n    free(cbase);\n    free(cdir);\n\n    plugin_library_path = sierra_ins_path + \"/\" + CATALYST_PLUGIN_PATH + \"/\" + sierra_system + \"/\" +\n                          sierra_version + \"/\" + plugin_library_name;\n\n    plugin_python_path = sierra_ins_path + \"/\" + CATALYST_PLUGIN_PATH + \"/\" + sierra_system + \"/\" +\n                         sierra_version + \"/\" + CATALYST_PLUGIN_PYTHON_MODULE;\n  }\n} // namespace\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/.git/objects/pack/pack-50f5bee682de38aa6907d2519b20d1fb84e867d3.idx",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/.git/objects/pack/pack-50f5bee682de38aa6907d2519b20d1fb84e867d3.pack",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/tpetra/core/example/BlockCrs/white-blockcrs-64x64x64x5-sha-44e225.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/tpetra/core/example/BlockCrs/blake-blockcrs-64x64x64x5-sha-44e225.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/tpetra/core/example/BlockCrs/blake-blockcrs-64x64x64x5-sha-302420bc.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/tpetra/core/example/BlockCrs/white-blockcrs-64x64x64x5-sha-302420bc.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/tpetra/core/guide/src/Images/Tpetra-FEM-Assembly-Example-E0-Clique.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/tpetra/core/guide/src/Images/petra.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/tpetra/core/guide/src/Images/export_hatfun.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/tpetra/core/guide/src/Images/epetra.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/tpetra/core/guide/src/Images/Tpetra-FEM-Assembly-Example-Mesh.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/tpetra/core/guide/src/Images/Tpetra-FEM-Assembly-Example-Node-Connectivity.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/tpetra/core/guide/src/Images/eight_tri_unit_square.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/tpetra/core/guide/src/Images/Tpetra-FEM-Assembly-Example-CrsGraph.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/tpetra/core/test/inout/rmat_11.bin",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/tpetra/core/test/inout/rmat_11_lap.bin",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/tpetra/core/doc/tpetra.gif",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/tpetra/core/doc/TpetraDesign/TpetraDesign.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/tpetra/core/doc/TpetraDesign/DOEbwlogo.eps",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/tpetra/core/doc/MatrixMatrixReport/DOEbwlogo.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/tpetra/core/doc/MatrixMatrixReport/snllineblk.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/xpetra/doc/images/xpetra.ico",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/xpetra/doc/images/xpetra.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/xpetra/doc/references/Xpetra_Spring2012DeveloperDay.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/pliris/doc/matrix_12.gif",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/pliris/doc/matrix_22_eq.gif",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/pliris/doc/matrix_22.gif",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/pliris/doc/matrix_21.gif",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/rol/example/PDE-OPT/topo-opt/elasticity/meshfiles/brick1.e",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/rol/example/PDE-OPT/topo-opt/elasticity/meshfiles/wheel1.e",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/rol/example/PDE-OPT/topo-opt/elasticity/meshfiles/wheel0.e",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/rol/example/PDE-OPT/topo-opt/elasticity/meshfiles/brick.e",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/rol/example/PDE-OPT/topo-opt/elasticity/meshfiles/brick2.e",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/rol/example/PDE-OPT/thermal-fluids/tf-cube.cub",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/rol/example/PDE-OPT/poisson/p-cube-8x8x8.e",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/rol/example/PDE-OPT/poisson/p-cube-4x4x4.e",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/rol/example/PDE-OPT/published/Helmholtz_KouriRidzalTuminaro2020/mesh/helmholtz-mesh-1.e",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/rol/example/PDE-OPT/published/Helmholtz_KouriRidzalTuminaro2020/mesh/helmholtz-mesh-0.e",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/rol/example/PDE-OPT/binary/elasticity/meshfiles/brick1.e",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/rol/example/PDE-OPT/binary/elasticity/meshfiles/wheel1.e",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/rol/example/PDE-OPT/binary/elasticity/meshfiles/wheel0.e",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/rol/example/PDE-OPT/binary/elasticity/meshfiles/brick.e",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/rol/example/PDE-OPT/binary/elasticity/meshfiles/brick2.e",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/rol/doc/rol_small.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/rol/doc/rol_small.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/rol/doc/ROL_Doxygen_Dec-11-2013.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/rol/doc/rol.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/rol/doc/rol.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/rol/doc/rol.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/shards/doc/UserGuide/DOEbwlogo.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/shards/doc/UserGuide/snllineblk.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/shards/doc/UserGuide/topo_figs/pyr_edge.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/shards/doc/UserGuide/topo_figs/wedge_edge.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/shards/doc/UserGuide/topo_figs/tet_node.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/shards/doc/UserGuide/topo_figs/wedge_face.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/shards/doc/UserGuide/topo_figs/tet_edge.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/shards/doc/UserGuide/topo_figs/hex_edge.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/shards/doc/UserGuide/topo_figs/tet_face.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/shards/doc/UserGuide/topo_figs/hex_face.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/shards/doc/UserGuide/topo_figs/hex_node.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/shards/doc/UserGuide/topo_figs/quad_node.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/shards/doc/UserGuide/topo_figs/tri_node.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/shards/doc/UserGuide/topo_figs/pyr_node.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/shards/doc/UserGuide/topo_figs/pentagon.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/shards/doc/UserGuide/topo_figs/quad_edge.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/shards/doc/UserGuide/topo_figs/hexagon.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/shards/doc/UserGuide/topo_figs/pyr_face.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/shards/doc/UserGuide/topo_figs/line.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/shards/doc/UserGuide/topo_figs/tri_edge.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/shards/doc/UserGuide/topo_figs/wedge_node.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/kokkos/doc/SAND2017-10464-Kokkos-Task-DAG.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/galeri/doc/galeri.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/galeri/doc/LaplaceSquareInSquare.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/galeri/doc/AdvDiffSquare.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/galeri/doc/LaplaceCircle.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/galeri/doc/LaplaceSquare.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/trilinoscouplings/examples/scaling/unit_cube_int_tri.exo",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/trilinoscouplings/examples/scaling/unit_cube_5int_tet.exo",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/trilinoscouplings/examples/scaling/unit_cube_10int_hex.exo",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/aztecoo/doc/azteclogo.gif",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/aztecoo/doc/UserGuide/DOEbwlogo.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/aztecoo/doc/UserGuide/AztecOOUserGuide.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/aztecoo/doc/UserGuide/snllineblk.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/epetra/ReleaseNotes.txt",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/epetra/doc/Epetra.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/epetra/doc/PerfOptGuide/EpetraPerformanceGuide.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/epetra/doc/PerfOptGuide/EpetraPerformanceGuideCoverPage.doc",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/epetra/doc/PerfOptGuide/EpetraPerformanceGuideDistributionList.doc",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/epetra/doc/PerfOptGuide/EpetraPerformanceGuide.doc",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/epetra/doc/OskiInterface/plots/hypnotoadtunebig.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/epetra/doc/OskiInterface/plots/c3tune.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/epetra/doc/OskiInterface/plots/weakcomposed.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/epetra/doc/OskiInterface/plots/hypnotoadscale.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/epetra/doc/OskiInterface/plots/hypnotoadscalebig.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/epetra/doc/OskiInterface/plots/weakmatvec.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/epetra/doc/OskiInterface/plots/weaktune.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/epetra/doc/OskiInterface/plots/c3scale.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/epetra/doc/OskiInterface/plots/hypnotoadtune.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/epetra/doc/OskiInterface/plots/c3serial.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/epetra/doc/OskiInterface/plots/hypnotoadserial.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/epetra/doc/CodingGuidelines/EpetraCodingGuidelinesDistributionList.doc",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/epetra/doc/CodingGuidelines/EpetraCodingGuidelines.doc",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/epetra/doc/CodingGuidelines/EpetraCodingGuidelinesCoverPage.doc",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/epetra/doc/CodingGuidelines/henricson_nyquist.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/epetra/doc/CodingGuidelines/EpetraCodingGuidelines.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/epetra/doc/CodingGuidelines/RAFormOct2003.doc",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/epetra/doc/UserGuide/EpetraPackagesDiagram.ppt",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/epetra/doc/UserGuide/EpetraDirectoryStructure.ppt",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/epetra/doc/UserGuide/DOEbwlogo.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/epetra/doc/UserGuide/snllineblk.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/epetra/doc/UserGuide/EpetraPackageDependencies.ppt",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/komplex/doc/komplex.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/komplex/doc/KomplexDiagram831.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/komplex/doc/KomplexStaticClassDiagram.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/komplex/doc/komplex_user_guide.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/belos/doc/images/gold_rule01.gif",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/belos/doc/images/snl_globe_left.gif",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/belos/doc/images/red_vert_bar.gif",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/PyTrilinos/doc/UsersGuide/UsersGuide.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/PyTrilinos/doc/UsersGuide/DOEbwlogo.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/PyTrilinos/doc/UsersGuide/biblio.bib",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/PyTrilinos/doc/UsersGuide/snllineblk.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/PyTrilinos/doc/UsersGuide/figures/organization.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/PyTrilinos/doc/UsersGuide/figures/PyTrilinos.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/PyTrilinos/doc/UsersGuide/figures/sparsity.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/PyTrilinos/doc/UsersGuide/figures/distributed_object.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/rythmos/doc/manual/RythmosSAND2017-1417.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/rythmos/doc/manual/logos/DOEbwlogo.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/rythmos/doc/manual/logos/SANDbackground.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/rythmos/doc/manual/logos/snllineblk.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/rythmos/doc/manual/logos/SANDbackground.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/rythmos/doc/manual/figures/IRK1StageTheta1.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/rythmos/doc/manual/figures/ForwardEuler.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/rythmos/doc/manual/figures/ERK_3Stage3OrderTVD.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/rythmos/doc/manual/figures/BackwardEuler_FirstOrderError_var_dt_RelError=1.0e-4.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/rythmos/doc/manual/figures/logtime-log.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/rythmos/doc/manual/figures/SDIRK_5Stage5Order.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/rythmos/doc/manual/figures/BDF.pptx",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/rythmos/doc/manual/figures/IntegratorStepperDesign.pptx",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/rythmos/doc/manual/figures/ERK_ForwardEuler.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/rythmos/doc/manual/figures/ERK_2Stage2OrderRunge.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/rythmos/doc/manual/figures/ERK_3Stage3OrderHeun.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/rythmos/doc/manual/figures/StepControlStrategy.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/rythmos/doc/manual/figures/BackwardEuler_FirstOrderError_var_dt_RelError=1.0e-5.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/rythmos/doc/manual/figures/IntegratorStepperDesign.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/rythmos/doc/manual/figures/IRK_BackwardEuler.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/rythmos/doc/manual/figures/ERK_4Stage3OrderRunge.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/rythmos/doc/manual/figures/sincos.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/rythmos/doc/manual/figures/InterpolationBuffer.pptx",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/rythmos/doc/manual/figures/SDIRK_2Stage3OrderLStable.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/rythmos/doc/manual/figures/SDIRK_5Stage4Order.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/rythmos/doc/manual/figures/BackwardEuler.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/rythmos/doc/manual/figures/BackwardEuler_FirstOrderError_var_dt_RelError=1.0e-3.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/rythmos/doc/manual/figures/IRK2StageTheta1.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/rythmos/doc/manual/figures/ImplicitBDF4.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/rythmos/doc/manual/figures/StepControlStrategy.pptx",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/rythmos/doc/manual/figures/logtime-linear.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/rythmos/doc/manual/figures/SDIRK_3Stage4Order.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/rythmos/doc/manual/figures/BDF2.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/rythmos/doc/manual/figures/IntegratorStepperDesign.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/rythmos/doc/manual/figures/SDIRK_2Stage2Order.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/rythmos/doc/manual/figures/ERK_3_8_Rule.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/rythmos/doc/manual/figures/ERK_3Stage3Order.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/rythmos/doc/manual/figures/DIRK_2Stage3Order.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/rythmos/doc/manual/figures/ERK_4Stage.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/rythmos/doc/manual/figures/BackwardEuler_FirstOrderError_var_dt_RelError=1.0e-2.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/rythmos/doc/manual/figures/ERK_Trapezoidal.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/rythmos/doc/manual/figures/InterpolationBuffer.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/ifpack2/doc/UsersGuide/DOEbwlogo.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/ifpack2/doc/UsersGuide/SANDbackground.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/ifpack2/doc/UsersGuide/snllineblk.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/ifpack2/doc/UsersGuide/ifpack2guide.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/panzer/adapters-stk/example/PoissonInterfaceTpetra/diffsideids.exo",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/panzer/adapters-stk/example/PoissonInterfaceTpetra/twoblock.exo",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/panzer/adapters-stk/example/PoissonInterfaceExample/diffsideids.exo",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/panzer/adapters-stk/example/PoissonInterfaceExample/twoblock.exo",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/panzer/adapters-stk/test/stk_interface_test/meshes/basic.gen",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/panzer/adapters-stk/test/stk_interface_test/meshes/basic.gen.2.1",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/panzer/adapters-stk/test/stk_interface_test/meshes/basic.gen.2.0",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/panzer/adapters-stk/test/local_mesh/test_mesh.exo.2.1",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/panzer/adapters-stk/test/local_mesh/test_mesh.exo.2.0",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/panzer/adapters-stk/test/initial_condition_builder/block-decomp.exo",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/panzer/adapters-stk/test/initial_condition_builder/block-decomp.exo.2.0",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/panzer/adapters-stk/test/initial_condition_builder/block-decomp.exo.2.1",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/panzer/doc/panzer_domain_model.docx",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/percept/src/percept/mesh/geometry/stk_geom/3D/FarinHansford-Agnostic-tri-quad-Gregory_paper.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/intrepid/doc/intrepid.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/intrepid/doc/intrepid.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/intrepid/matlab/intrelab/mesh/vtk-file-formats.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/intrepid/matlab/intrelab/mesh/vtk-file-formats.html",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/epetraext/example/model_evaluator/GLpApp/Parallel2DMeshGeneratorFormat.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/epetraext/example/inout/matlab.h5",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/epetraext/doc/Epetra.gif",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/epetraext/doc/UserGuide/snllineblk.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/epetraext/doc/UserGuide/DOEbwlogo.eps",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/muelu.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/UsersGuide/SANDbackground_2.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/UsersGuide/DOEbwlogo.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/UsersGuide/SANDbackground_1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/UsersGuide/SANDbackground.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/UsersGuide/snllineblk.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/Tutorial/tex/pics/2level_10jac09.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/Tutorial/tex/pics/5sweeps_1level_10jac09.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/Tutorial/tex/pics/s4al1.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/Tutorial/tex/pics/lubuntu_2.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/Tutorial/tex/pics/installation_2.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/Tutorial/tex/pics/tut1_5.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/Tutorial/tex/pics/lubuntu_5.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/Tutorial/tex/pics/1level_10jac09.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/Tutorial/tex/pics/tut1_15.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/Tutorial/tex/pics/tut1_3.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/Tutorial/tex/pics/tut1_1.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/Tutorial/tex/pics/s4bl2.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/Tutorial/tex/pics/aggsSymm.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/Tutorial/tex/pics/5sweeps_2level_100jac09.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/Tutorial/tex/pics/5sweeps_1level_100jac09.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/Tutorial/tex/pics/s4bl1.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/Tutorial/tex/pics/s4bl3.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/Tutorial/tex/pics/tut1_14.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/Tutorial/tex/pics/1level_1000jac09.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/Tutorial/tex/pics/1level_1jac09.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/Tutorial/tex/pics/aggsNonSymm.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/Tutorial/tex/pics/tut1_2.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/Tutorial/tex/pics/lubuntu_4.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/Tutorial/tex/pics/5sweeps_3level_1jac09.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/Tutorial/tex/pics/5sweeps_1level_1jac09.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/Tutorial/tex/pics/2level_1jac09.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/Tutorial/tex/pics/5sweeps_3level_100jac09.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/Tutorial/tex/pics/tut1_17.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/Tutorial/tex/pics/3level_1jac09.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/Tutorial/tex/pics/tut1_13.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/Tutorial/tex/pics/installation_1.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/Tutorial/tex/pics/1level_100jac09.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/Tutorial/tex/pics/tut1_7.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/Tutorial/tex/pics/tut1_12.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/Tutorial/tex/pics/lubuntu_1.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/Tutorial/tex/pics/tut1_16.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/Tutorial/tex/pics/s4al2.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/Tutorial/tex/pics/tut1_6.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/Tutorial/tex/pics/5sweeps_3level_10jac09.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/Tutorial/tex/pics/5sweeps_2level_1jac09.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/Tutorial/tex/pics/3level_10jac09.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/Tutorial/tex/pics/3level_100jac09.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/Tutorial/tex/pics/s4al3.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/Tutorial/tex/pics/lubuntu_3.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/Tutorial/tex/pics/tut1_4.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/Tutorial/tex/pics/tut1_10.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/Tutorial/tex/pics/aggsSymmCoupled.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/Tutorial/tex/pics/tut1_11.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/Tutorial/tex/pics/tut1_9.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/Tutorial/tex/pics/aggsSymmReb.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/Tutorial/tex/pics/2level_100jac09.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/Tutorial/tex/pics/lubuntu_6.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/Tutorial/tex/pics/dep_graph.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/Tutorial/tex/pics/2level_1000jac09.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/Tutorial/tex/pics/tut1_8.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/Tutorial/tex/pics/background.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/Tutorial/tex/pics/5sweeps_2level_10jac09.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/muelu/doc/Tutorial/tex/pics/tut1_18.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/pamgen/rtcompiler/diag1.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/pamgen/rtcompiler/diag2.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/pamgen/doc/sand_report/figures/bias_example.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/pamgen/doc/sand_report/figures/str_inline_sphere.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/pamgen/doc/sand_report/figures/MaterialOrder.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/pamgen/doc/sand_report/figures/rect_inline.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/pamgen/doc/sand_report/figures/DOEbwlogo.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/pamgen/doc/sand_report/figures/brick-hex.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/pamgen/doc/sand_report/figures/brick.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/pamgen/doc/sand_report/figures/seq_7_white.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/pamgen/doc/sand_report/figures/int_surf_picture2_rv.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/pamgen/doc/sand_report/figures/snllineblk.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/pamgen/doc/sand_report/figures/mesh_warp_2d_white_bg.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/pamgen/doc/sand_report/figures/block_ss.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/pamgen/doc/sand_report/figures/proc_layout7_white.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/pamgen/doc/sand_report/figures/cubit_tris_rad_grad_trans.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/pamgen/doc/sand_report/figures/cylinder.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/pamgen/doc/sand_report/figures/bisect_7_white.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/pamgen/doc/sand_report/figures/mesh_warp_2d_white_bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/pamgen/doc/sand_report/figures/3d_warped_geometry_white_bg.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/pamgen/doc/sand_report/figures/brick-brick.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/pamgen/doc/sand_report/figures/ss_block.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/pamgen/doc/sand_report/figures/3d_warped_geometry_white_bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/pamgen/doc/sand_report/figures/cubit_radial_trisection2.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/pamgen/doc/sand_report/figures/numprocs_8.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/pamgen/doc/sand_report/figures/cubit_radial_trisection.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/pamgen/doc/sand_report/figures/cubit_radial1.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/pamgen/doc/sand_report/figures/trisection_decomp.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/pamgen/doc/sand_report/figures/test_radial.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/pamgen/doc/sand_report/figures/brk.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/pamgen/doc/sand_report/figures/cubit_radial2.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/amesos2/doc/amesos2_logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/amesos2/doc/design_review/amesos2_review.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/anasazi/doc/images/gold_rule01.gif",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/anasazi/doc/images/snl_globe_left.gif",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/anasazi/doc/images/red_vert_bar.gif",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/ifpack/doc/IFPACKLogo.gif",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/ifpack/doc/UsersGuide/IfpackUserGuide.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/ifpack/doc/UsersGuide/biblio.bib",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/teuchos/doc/images/gold_rule01.gif",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/teuchos/doc/images/snl_globe_left.gif",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/teuchos/doc/images/red_vert_bar.gif",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/domi/doc/Domi.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/amesos/doc/AmesosLogo.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/amesos/doc/AmesosReferenceGuide/AmesosReferenceGuide.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/thyra/emacs/sources/gnu-global-5.7.7.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/thyra/core/src/interfaces/operator_vector/fundamental/doc/images/ThyraOperatorVector.gif",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/thyra/core/src/interfaces/operator_vector/fundamental/doc/images/StateBehaviorOfViews.gif",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/thyra/core/src/interfaces/operator_vector/fundamental/doc/images/ThyraOperatorVectorSimple.gif",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/thyra/core/src/support/operator_vector/doc/images/ThyraOperatorVectorSimple.gif",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/thyra/core/src/support/operator_vector/doc/images/ScalarProdVectorSpaceBase.gif",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/thyra/core/src/support/operator_vector/doc/images/MPIVectorSpaceBase.gif",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/thyra/core/src/support/operator_vector/doc/images/MPIVectorSpaceStd.gif",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/thyra/core/src/support/operator_vector/doc/images/SerialVectorSpaceStd.gif",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/thyra/core/src/support/operator_vector/doc/images/DefaultSpmdVectorSpace.gif",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/thyra/core/src/support/operator_vector/doc/images/SerialVectorSpaceBase.gif",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/thyra/core/src/support/operator_vector/doc/images/SpmdVectorSpaceDefaultBase.gif",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/thyra/doc/images/gold_rule01.gif",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/thyra/doc/images/ModelEvaluator.gif",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/thyra/doc/images/LinearOpWithSolveAndFactory75.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/thyra/doc/images/snl_globe_left.gif",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/thyra/doc/images/LinearOpWithSolveBase75.gif",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/thyra/doc/images/ModelEvaluator75.gif",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/thyra/doc/images/PreconditionerFactory75.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/thyra/doc/images/red_vert_bar.gif",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/thyra/doc/images/LinearOpWithSolveAndFactory.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/thyra/doc/images/LinearOpWithSolveBase.gif",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/zoltan2/test/core/partition/pumiTri14/plate0.smb",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/zoltan2/test/core/partition/pumiTri14/2/0.smb",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/zoltan2/test/core/partition/pumiTri14/2/1.smb",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/zoltan2/test/core/partition/4/0.smb",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/zoltan2/test/core/partition/4/1.smb",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/zoltan2/test/core/partition/4/3.smb",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/zoltan2/test/core/partition/4/2.smb",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/zoltan2/doc/images/usage.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/nox/doc/images/chan_tp.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/nox/doc/images/chan.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/adelus/doc/matrix_12.gif",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/adelus/doc/matrix_22_eq.gif",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/adelus/doc/matrix_22.gif",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/adelus/doc/matrix_21.gif",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/ml/python/websolver/web/common/sandia_normal.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/ml/python/websolver/web/common/sandia_over.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/ml/python/websolver/web/common/trilinos_title_over.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/ml/python/websolver/web/common/trilinos_normal.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/ml/python/websolver/web/common/trilinos_over.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/ml/python/websolver/web/common/rd100.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/ml/python/websolver/web/common/trilinos_title_normal.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/ml/python/websolver/web/common/spacer.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/ml/python/websolver/web/common/favicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/ml/test/BlockCheby/localids_in_blocks.dat.gz",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/ml/test/BlockCheby/samplemat.dat.gz",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/ml/test/BlockCheby/blockids.dat.gz",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/ml/examples/BasicExamples/.data.gz",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/ml/doc/ml-logo.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/ml/doc/ml-image.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/ml/doc/mlguide.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/ml/doc/SemiCoarsen.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/ml/doc/UsersGuide/analysis_dense_A.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/ml/doc/UsersGuide/before_cycle.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/ml/doc/UsersGuide/after_cycle.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/ml/doc/UsersGuide/aggregate_decomposition.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/ml/doc/UsersGuide/analysis_dense_PA.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/ml/doc/MLAPI/MLAPI.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/intrepid2/doc/intrepid.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/intrepid2/doc/intrepid.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/zoltan/doc/Zoltan_pdf/ug.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/zoltan/doc/Zoltan_html/Zoltan_pubs.html",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/zoltan/doc/Zoltan_html/dev_html/hammondMesh.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/zoltan/doc/Zoltan_html/dev_html/brack3d.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/zoltan/doc/Zoltan_html/dev_html/hammondPoints.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/zoltan/doc/Zoltan_html/dev_html/film2d.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/zoltan/doc/Zoltan_html/dev_html/figures/arrow.gif",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/zoltan/doc/Zoltan_html/ug_html/Structural_MATVEC_Avg_Time.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/zoltan/doc/Zoltan_html/ug_html/figures/HGFigure.gif",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/zoltan/doc/Zoltan_html/ug_html/figures/Z.gif",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/zoltan/doc/Zoltan_html/ug_html/figures/arrow.gif",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/zoltan/doc/Zoltan_html/ug_html/figures/hierexample.gif",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/zoltan/doc/Tutorial/zoltan_tutorial_document.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/zoltan/doc/Tutorial/zoltan_tutorial_presentation.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/zoltan/doc/NEA_docs/writeup/128_time.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/zoltan/doc/NEA_docs/writeup/2_time.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/zoltan/doc/NEA_docs/writeup/odin-data.ods",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/zoltan/doc/NEA_docs/writeup/hybrid_current.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/zoltan/doc/NEA_docs/writeup/128_breakdown_percent.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/zoltan/doc/NEA_docs/writeup/128_cutl.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/zoltan/doc/NEA_docs/writeup/2_breakdown_percent.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/zoltan/doc/NEA_docs/writeup/2_cutl.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/seacas/applications/aprepro/exodus.g",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/seacas/libraries/ioss/src/main/test/generated.cgns",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/seacas/libraries/ioss/src/main/test/pre-split-old.cgns.4.0",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/seacas/libraries/ioss/src/main/test/transient-fields.cgns",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/seacas/libraries/ioss/src/main/test/exodus_bc_parents.gold",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/seacas/libraries/ioss/src/main/test/5blocks-struc.cgns",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/seacas/libraries/ioss/src/main/test/BC_Q2_parents.cgns",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/seacas/libraries/ioss/src/main/test/8-block.g",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/seacas/libraries/ioss/src/main/test/BC_without_parents.cgns",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/seacas/libraries/ioss/src/main/test/multiple_zones_fields.cgns",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/seacas/libraries/ioss/src/main/test/structured_with_nodeblock_fields.cgns",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/seacas/libraries/ioss/src/main/test/exodus_Q2_bc_parents.gold",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/seacas/libraries/ioss/src/main/test/pre-split-old.cgns.4.2",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/seacas/libraries/ioss/src/main/test/BC_Q2_without_parents.cgns",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/seacas/libraries/ioss/src/main/test/pre-split-old.cgns.4.3",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/seacas/libraries/ioss/src/main/test/pre-split_cgns.gold",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/seacas/libraries/ioss/src/main/test/blottner.cgns",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/seacas/libraries/ioss/src/main/test/two-block.g",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/seacas/libraries/ioss/src/main/test/self-looping-grid.cgns",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/seacas/libraries/ioss/src/main/test/cube.g",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/seacas/libraries/ioss/src/main/test/exodus_generated.gold",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/seacas/libraries/ioss/src/main/test/assemblies.cgns",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/seacas/libraries/ioss/src/main/test/bump_str.cgns",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/seacas/libraries/ioss/src/main/test/sparc1.cgns",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/seacas/libraries/ioss/src/main/test/exodus_struc.gold",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/seacas/libraries/ioss/src/main/test/pre-split-old.cgns.4.1",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/seacas/libraries/ioss/src/utest/cbr2.ncf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/seacas/libraries/ioss/doc/Block_Diagram_Model.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/seacas/libraries/ioss/doc/GroupingEntity__coll__graph.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/seacas/libraries/ioss/doc/Ioss_Region.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/seacas/libraries/ioss/doc/DatabaseIO__inherit__graph.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/seacas/libraries/ioss/doc/VariableType__inherit__graph.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/seacas/libraries/ioss/doc/GroupingEntity__inherit__graph.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/shylu/shylu_dd/frosch/test/Thyra_Xpetra_Stokes_HDF5/stokes.h5",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/shylu/doc/intro/SANDbackground.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/shylu/doc/intro/figures/DOEbwlogo.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/packages/shylu/doc/intro/figures/SNL_Stacked_Black_Blue.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/doc/DocumentingParameterLists/webfiles/bootstrap/img/glyphicons-halflings.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/doc/DocumentingParameterLists/webfiles/bootstrap/img/glyphicons-halflings-white.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/doc/DocumentingParameterLists/webfiles/img/bg_content.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/doc/DocumentingParameterLists/webfiles/img/t-icon-images.png",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/doc/DocumentingParameterLists/memo/snllineblubrd.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/doc/DocumentingParameterLists/memo/ClosedTopLevelParameterList.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/doc/DocumentingParameterLists/memo/OpenIntegerParameterWithValidator.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/doc/DocumentingParameterLists/memo/OpenTopLevelParameterList.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-trilinos-master-64zveuutdwtpw6xkd4dajb5tihjbcq33/spack-src/doc/DocumentingParameterLists/memo/OpenStringParameterWithValidator.pdf"
    ],
    "total_files": 49584
}