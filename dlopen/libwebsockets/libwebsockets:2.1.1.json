{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-libwebsockets-2.1.1-wl4mcny2cwnkjjbmkopeosrtr3vocn2b/spack-src/lib/libuv.c": "/*\n * libwebsockets - small server side websockets and web server implementation\n *\n * Copyright (C) 2010-2016 Andy Green <andy@warmcat.com>\n *\n *  This library is free software; you can redistribute it and/or\n *  modify it under the terms of the GNU Lesser General Public\n *  License as published by the Free Software Foundation:\n *  version 2.1 of the License.\n *\n *  This library is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *  Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; if not, write to the Free Software\n *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n *  MA  02110-1301  USA\n */\n\n#include \"private-libwebsockets.h\"\n\nvoid\nlws_feature_status_libuv(struct lws_context_creation_info *info)\n{\n\tif (lws_check_opt(info->options, LWS_SERVER_OPTION_LIBUV))\n\t\tlwsl_notice(\"libuv support compiled in and enabled\\n\");\n\telse\n\t\tlwsl_notice(\"libuv support compiled in but disabled\\n\");\n}\n\nstatic void\nlws_uv_idle(uv_idle_t *handle\n#if UV_VERSION_MAJOR == 0\n\t\t, int status\n#endif\n)\n{\n\tstruct lws_context_per_thread *pt = lws_container_of(handle,\n\t\t\t\t\tstruct lws_context_per_thread, uv_idle);\n\n\tlwsl_debug(\"%s\\n\", __func__);\n\n\t/*\n\t * is there anybody with pending stuff that needs service forcing?\n\t */\n\tif (!lws_service_adjust_timeout(pt->context, 1, pt->tid)) {\n\t\t/* -1 timeout means just do forced service */\n\t\tlws_plat_service_tsi(pt->context, -1, pt->tid);\n\t\t/* still somebody left who wants forced service? */\n\t\tif (!lws_service_adjust_timeout(pt->context, 1, pt->tid))\n\t\t\t/* yes... come back again later */\n\t\t\tlwsl_debug(\"%s: done again\\n\", __func__);\n\t\treturn;\n\t}\n\n\t/* there is nobody who needs service forcing, shut down idle */\n\tuv_idle_stop(handle);\n\n\tlwsl_debug(\"%s: done stop\\n\", __func__);\n}\n\nstatic void\nlws_io_cb(uv_poll_t *watcher, int status, int revents)\n{\n\tstruct lws_io_watcher *lws_io = lws_container_of(watcher,\n\t\t\t\t\tstruct lws_io_watcher, uv_watcher);\n\tstruct lws *wsi = lws_container_of(lws_io, struct lws, w_read);\n\tstruct lws_context *context = lws_io->context;\n\tstruct lws_pollfd eventfd;\n\n#if defined(WIN32) || defined(_WIN32)\n\teventfd.fd = watcher->socket;\n#else\n\teventfd.fd = watcher->io_watcher.fd;\n#endif\n\teventfd.events = 0;\n\teventfd.revents = 0;\n\n\tif (status < 0) {\n\t\t/* at this point status will be an UV error, like UV_EBADF,\n\t\twe treat all errors as LWS_POLLHUP */\n\n\t\t/* you might want to return; instead of servicing the fd in some cases */\n\t\tif (status == UV_EAGAIN)\n\t\t\treturn;\n\n\t\teventfd.events |= LWS_POLLHUP;\n\t\teventfd.revents |= LWS_POLLHUP;\n\t} else {\n\t\tif (revents & UV_READABLE) {\n\t\t\teventfd.events |= LWS_POLLIN;\n\t\t\teventfd.revents |= LWS_POLLIN;\n\t\t}\n\t\tif (revents & UV_WRITABLE) {\n\t\t\teventfd.events |= LWS_POLLOUT;\n\t\t\teventfd.revents |= LWS_POLLOUT;\n\t\t}\n\t}\n\tlws_service_fd(context, &eventfd);\n\n\tuv_idle_start(&context->pt[(int)wsi->tsi].uv_idle, lws_uv_idle);\n}\n\nLWS_VISIBLE void\nlws_uv_sigint_cb(uv_signal_t *watcher, int signum)\n{\n\tlwsl_err(\"internal signal handler caught signal %d\\n\", signum);\n\tlws_libuv_stop(watcher->data);\n}\n\nLWS_VISIBLE int\nlws_uv_sigint_cfg(struct lws_context *context, int use_uv_sigint,\n\t\t  uv_signal_cb cb)\n{\n\tcontext->use_ev_sigint = use_uv_sigint;\n\tif (cb)\n\t\tcontext->lws_uv_sigint_cb = cb;\n\telse\n\t\tcontext->lws_uv_sigint_cb = &lws_uv_sigint_cb;\n\n\treturn 0;\n}\n\nstatic void\nlws_uv_timeout_cb(uv_timer_t *timer\n#if UV_VERSION_MAJOR == 0\n\t\t, int status\n#endif\n)\n{\n\tstruct lws_context_per_thread *pt = lws_container_of(timer,\n\t\t\tstruct lws_context_per_thread, uv_timeout_watcher);\n\n\tif (pt->context->requested_kill)\n\t\treturn;\n\n\tlwsl_debug(\"%s\\n\", __func__);\n\n\tlws_service_fd_tsi(pt->context, NULL, pt->tid);\n}\n\nstatic const int sigs[] = { SIGINT, SIGTERM, SIGSEGV, SIGFPE };\n\nLWS_VISIBLE int\nlws_uv_initloop(struct lws_context *context, uv_loop_t *loop, int tsi)\n{\n\tstruct lws_context_per_thread *pt = &context->pt[tsi];\n\tstruct lws_vhost *vh = context->vhost_list;\n\tint status = 0, n, ns;\n\n\tif (!loop) {\n\t\tloop = lws_malloc(sizeof(*loop));\n\t\tif (!loop) {\n\t\t\tlwsl_err(\"OOM\\n\");\n\t\t\treturn -1;\n\t\t}\n#if UV_VERSION_MAJOR > 0\n\t\tuv_loop_init(loop);\n#else\n\t\tlwsl_err(\"This libuv is too old to work...\\n\");\n\t\treturn 1;\n#endif\n\t\tpt->ev_loop_foreign = 0;\n\t} else {\n\t\tlwsl_notice(\" Using foreign event loop...\\n\");\n\t\tpt->ev_loop_foreign = 1;\n\t}\n\n\tpt->io_loop_uv = loop;\n\tuv_idle_init(loop, &pt->uv_idle);\n\n\tns = ARRAY_SIZE(sigs);\n\tif (lws_check_opt(context->options, LWS_SERVER_OPTION_UV_NO_SIGSEGV_SIGFPE_SPIN))\n\t\tns = 2;\n\n\tif (pt->context->use_ev_sigint) {\n\t\tassert(ns <= ARRAY_SIZE(pt->signals));\n\t\tfor (n = 0; n < ns; n++) {\n\t\t\tuv_signal_init(loop, &pt->signals[n]);\n\t\t\tpt->signals[n].data = pt->context;\n\t\t\tuv_signal_start(&pt->signals[n],\n\t\t\t\t\tcontext->lws_uv_sigint_cb, sigs[n]);\n\t\t}\n\t}\n\n\t/*\n\t * Initialize the accept wsi read watcher with all the listening sockets\n\t * and register a callback for read operations\n\t *\n\t * We have to do it here because the uv loop(s) are not\n\t * initialized until after context creation.\n\t */\n\twhile (vh) {\n\t\tif (vh->lserv_wsi) {\n\t\t\tvh->lserv_wsi->w_read.context = context;\n\t\t\tn = uv_poll_init_socket(pt->io_loop_uv,\n\t\t\t\t\t\t&vh->lserv_wsi->w_read.uv_watcher,\n\t\t\t\t\t\tvh->lserv_wsi->sock);\n\t\t\tif (n) {\n\t\t\t\tlwsl_err(\"uv_poll_init failed %d, sockfd=%p\\n\",\n\t\t\t\t\tn, (void *)(long)vh->lserv_wsi->sock);\n\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tlws_libuv_io(vh->lserv_wsi, LWS_EV_START | LWS_EV_READ);\n\t\t}\n\t\tvh = vh->vhost_next;\n\t}\n\n\tuv_timer_init(pt->io_loop_uv, &pt->uv_timeout_watcher);\n\tuv_timer_start(&pt->uv_timeout_watcher, lws_uv_timeout_cb, 10, 1000);\n\n\treturn status;\n}\n\nstatic void lws_uv_close_cb(uv_handle_t *handle)\n{\n\t//lwsl_err(\"%s: handle %p\\n\", __func__, handle);\n}\n\nstatic void lws_uv_walk_cb(uv_handle_t *handle, void *arg)\n{\n\tuv_close(handle, lws_uv_close_cb);\n}\n\nvoid\nlws_libuv_destroyloop(struct lws_context *context, int tsi)\n{\n\tstruct lws_context_per_thread *pt = &context->pt[tsi];\n\tint m, budget = 100, ns;\n\n\tif (!lws_check_opt(context->options, LWS_SERVER_OPTION_LIBUV))\n\t\treturn;\n\n\tif (!pt->io_loop_uv)\n\t\treturn;\n\n\tif (context->use_ev_sigint) {\n\t\tuv_signal_stop(&pt->w_sigint.uv_watcher);\n\n\t\tns = ARRAY_SIZE(sigs);\n\t\tif (lws_check_opt(context->options, LWS_SERVER_OPTION_UV_NO_SIGSEGV_SIGFPE_SPIN))\n\t\t\tns = 2;\n\n\t\tfor (m = 0; m < ns; m++) {\n\t\t\tuv_signal_stop(&pt->signals[m]);\n\t\t\tuv_close((uv_handle_t *)&pt->signals[m], lws_uv_close_cb);\n\t\t}\n\t}\n\n\tuv_timer_stop(&pt->uv_timeout_watcher);\n\tuv_close((uv_handle_t *)&pt->uv_timeout_watcher, lws_uv_close_cb);\n\n\tuv_idle_stop(&pt->uv_idle);\n\tuv_close((uv_handle_t *)&pt->uv_idle, lws_uv_close_cb);\n\n\twhile (budget-- && uv_run(pt->io_loop_uv, UV_RUN_NOWAIT))\n\t\t;\n\n\tif (pt->ev_loop_foreign)\n\t\treturn;\n\n\tuv_stop(pt->io_loop_uv);\n\n\tuv_walk(pt->io_loop_uv, lws_uv_walk_cb, NULL);\n\n\twhile (uv_run(pt->io_loop_uv, UV_RUN_NOWAIT))\n\t\t;\n#if UV_VERSION_MAJOR > 0\n\tm = uv_loop_close(pt->io_loop_uv);\n\tif (m == UV_EBUSY)\n\t\tlwsl_err(\"%s: uv_loop_close: UV_EBUSY\\n\", __func__);\n#endif\n\tlws_free(pt->io_loop_uv);\n}\n\nvoid\nlws_libuv_accept(struct lws *wsi, lws_sockfd_type accept_fd)\n{\n\tstruct lws_context *context = lws_get_context(wsi);\n\tstruct lws_context_per_thread *pt = &context->pt[(int)wsi->tsi];\n\n\tif (!LWS_LIBUV_ENABLED(context))\n\t\treturn;\n\n\tlwsl_debug(\"%s: new wsi %p\\n\", __func__, wsi);\n\n\twsi->w_read.context = context;\n\n\tuv_poll_init_socket(pt->io_loop_uv, &wsi->w_read.uv_watcher, accept_fd);\n}\n\nvoid\nlws_libuv_io(struct lws *wsi, int flags)\n{\n\tstruct lws_context *context = lws_get_context(wsi);\n\tstruct lws_context_per_thread *pt = &wsi->context->pt[(int)wsi->tsi];\n#if defined(WIN32) || defined(_WIN32)\n\tint current_events = wsi->w_read.uv_watcher.events &\n\t\t\t     (UV_READABLE | UV_WRITABLE);\n#else\n\tint current_events = wsi->w_read.uv_watcher.io_watcher.pevents &\n\t\t\t     (UV_READABLE | UV_WRITABLE);\n#endif\n\tstruct lws_io_watcher *w = &wsi->w_read;\n\n\tif (!LWS_LIBUV_ENABLED(context))\n\t\treturn;\n\n\t// lwsl_notice(\"%s: wsi: %p, flags:0x%x\\n\", __func__, wsi, flags);\n\n\tif (!pt->io_loop_uv) {\n\t\tlwsl_info(\"%s: no io loop yet\\n\", __func__);\n\t\treturn;\n\t}\n\n\tif (!((flags & (LWS_EV_START | LWS_EV_STOP)) &&\n\t      (flags & (LWS_EV_READ | LWS_EV_WRITE)))) {\n\t\tlwsl_err(\"%s: assert: flags %d\", __func__, flags);\n\t\tassert(0);\n\t}\n\n\tif (flags & LWS_EV_START) {\n\t\tif (flags & LWS_EV_WRITE)\n\t\t\tcurrent_events |= UV_WRITABLE;\n\n\t\tif (flags & LWS_EV_READ)\n\t\t\tcurrent_events |= UV_READABLE;\n\n\t\tuv_poll_start(&w->uv_watcher, current_events, lws_io_cb);\n\t} else {\n\t\tif (flags & LWS_EV_WRITE)\n\t\t\tcurrent_events &= ~UV_WRITABLE;\n\n\t\tif (flags & LWS_EV_READ)\n\t\t\tcurrent_events &= ~UV_READABLE;\n\n\t\tif (!(current_events & (UV_READABLE | UV_WRITABLE)))\n\t\t\tuv_poll_stop(&w->uv_watcher);\n\t\telse\n\t\t\tuv_poll_start(&w->uv_watcher, current_events,\n\t\t\t\t      lws_io_cb);\n\t}\n}\n\nint\nlws_libuv_init_fd_table(struct lws_context *context)\n{\n\tint n;\n\n\tif (!LWS_LIBUV_ENABLED(context))\n\t\treturn 0;\n\n\tfor (n = 0; n < context->count_threads; n++)\n\t\tcontext->pt[n].w_sigint.context = context;\n\n\treturn 1;\n}\n\nLWS_VISIBLE void\nlws_libuv_run(const struct lws_context *context, int tsi)\n{\n\tif (context->pt[tsi].io_loop_uv && LWS_LIBUV_ENABLED(context))\n\t\tuv_run(context->pt[tsi].io_loop_uv, 0);\n}\n\nstatic void\nlws_libuv_kill(const struct lws_context *context)\n{\n\tint n;\n\n\tfor (n = 0; n < context->count_threads; n++)\n\t\tif (context->pt[n].io_loop_uv &&\n\t\t    LWS_LIBUV_ENABLED(context) &&\n\t\t    !context->pt[n].ev_loop_foreign)\n\t\t\tuv_stop(context->pt[n].io_loop_uv);\n}\n\n/*\n * This does not actually stop the event loop.  The reason is we have to pass\n * libuv handle closures through its event loop.  So this tries to close all\n * wsi, and set a flag; when all the wsi closures are finalized then we\n * actually stop the libuv event loops.\n */\n\nLWS_VISIBLE void\nlws_libuv_stop(struct lws_context *context)\n{\n\tstruct lws_context_per_thread *pt;\n\tint n, m;\n\n\tif (context->requested_kill)\n\t\treturn;\n\n\tcontext->requested_kill = 1;\n\n\tm = context->count_threads;\n\tcontext->being_destroyed = 1;\n\n\twhile (m--) {\n\t\tpt = &context->pt[m];\n\n\t\tfor (n = 0; (unsigned int)n < context->pt[m].fds_count; n++) {\n\t\t\tstruct lws *wsi = wsi_from_fd(context, pt->fds[n].fd);\n\n\t\t\tif (!wsi)\n\t\t\t\tcontinue;\n\t\t\tlws_close_free_wsi(wsi,\n\t\t\t\tLWS_CLOSE_STATUS_NOSTATUS_CONTEXT_DESTROY\n\t\t\t\t/* no protocol close */);\n\t\t\tn--;\n\t\t}\n\t}\n\n\tlwsl_info(\"%s: feels everything closed\\n\", __func__);\n\tif (context->count_wsi_allocated == 0)\n\t\tlws_libuv_kill(context);\n}\n\nLWS_VISIBLE uv_loop_t *\nlws_uv_getloop(struct lws_context *context, int tsi)\n{\n\tif (context->pt[tsi].io_loop_uv && LWS_LIBUV_ENABLED(context))\n\t\treturn context->pt[tsi].io_loop_uv;\n\n\treturn NULL;\n}\n\nstatic void\nlws_libuv_closewsi(uv_handle_t* handle)\n{\n\tstruct lws *n = NULL, *wsi = (struct lws *)(((char *)handle) -\n\t\t\t  (char *)(&n->w_read.uv_watcher));\n\tstruct lws_context *context = lws_get_context(wsi);\n\n\tlws_close_free_wsi_final(wsi);\n\n\tif (context->requested_kill && context->count_wsi_allocated == 0)\n\t\tlws_libuv_kill(context);\n}\n\nvoid\nlws_libuv_closehandle(struct lws *wsi)\n{\n\tstruct lws_context *context = lws_get_context(wsi);\n\n\t/* required to defer actual deletion until libuv has processed it */\n\n\tuv_close((uv_handle_t*)&wsi->w_read.uv_watcher, lws_libuv_closewsi);\n\n\tif (context->requested_kill && context->count_wsi_allocated == 0)\n\t\tlws_libuv_kill(context);\n}\n\n#if defined(LWS_WITH_PLUGINS) && (UV_VERSION_MAJOR > 0)\n\nLWS_VISIBLE int\nlws_plat_plugins_init(struct lws_context * context, const char * const *d)\n{\n\tstruct lws_plugin_capability lcaps;\n\tstruct lws_plugin *plugin;\n\tlws_plugin_init_func initfunc;\n\tint m, ret = 0;\n\tvoid *v;\n\tuv_dirent_t dent;\n\tuv_fs_t req;\n\tchar path[256];\n\tuv_loop_t loop;\n\tuv_lib_t lib;\n\n\tlib.errmsg = NULL;\n\tlib.handle = NULL;\n\n\tuv_loop_init(&loop);\n\n\tlwsl_notice(\"  Plugins:\\n\");\n\n\twhile (d && *d) {\n\n\t\tlwsl_notice(\"  Scanning %s\\n\", *d);\n\t\tm =uv_fs_scandir(&loop, &req, *d, 0, NULL);\n\t\tif (m < 1) {\n\t\t\tlwsl_err(\"Scandir on %s failed\\n\", *d);\n\t\t\treturn 1;\n\t\t}\n\n\t\twhile (uv_fs_scandir_next(&req, &dent) != UV_EOF) {\n\t\t\tif (strlen(dent.name) < 7)\n\t\t\t\tcontinue;\n\n\t\t\tlwsl_notice(\"   %s\\n\", dent.name);\n\n\t\t\tlws_snprintf(path, sizeof(path) - 1, \"%s/%s\", *d, dent.name);\n\t\t\tif (uv_dlopen(path, &lib)) {\n\t\t\t\tuv_dlerror(&lib);\n\t\t\t\tlwsl_err(\"Error loading DSO: %s\\n\", lib.errmsg);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\t/* we could open it, can we get his init function? */\n#if !defined(WIN32)\n\t\t\tm = lws_snprintf(path, sizeof(path) - 1, \"init_%s\",\n\t\t\t\t     dent.name + 3 /* snip lib... */);\n\t\t\tpath[m - 3] = '\\0'; /* snip the .so */\n#else\n\t\t\tm = lws_snprintf(path, sizeof(path) - 1, \"init_%s\",\n\t\t\t\t     dent.name);\n\t\t\tpath[m - 4] = '\\0'; /* snip the .dll */\n#endif\n\t\t\tif (uv_dlsym(&lib, path, &v)) {\n\t\t\t\tuv_dlerror(&lib);\n\t\t\t\tlwsl_err(\"Failed to get init on %s: %s\",\n\t\t\t\t\t\tdent.name, lib.errmsg);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tinitfunc = (lws_plugin_init_func)v;\n\t\t\tlcaps.api_magic = LWS_PLUGIN_API_MAGIC;\n\t\t\tm = initfunc(context, &lcaps);\n\t\t\tif (m) {\n\t\t\t\tlwsl_err(\"Initializing %s failed %d\\n\", dent.name, m);\n\t\t\t\tgoto skip;\n\t\t\t}\n\n\t\t\tplugin = lws_malloc(sizeof(*plugin));\n\t\t\tif (!plugin) {\n\t\t\t\tlwsl_err(\"OOM\\n\");\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tplugin->list = context->plugin_list;\n\t\t\tcontext->plugin_list = plugin;\n\t\t\tstrncpy(plugin->name, dent.name, sizeof(plugin->name) - 1);\n\t\t\tplugin->name[sizeof(plugin->name) - 1] = '\\0';\n\t\t\tplugin->lib = lib;\n\t\t\tplugin->caps = lcaps;\n\t\t\tcontext->plugin_protocol_count += lcaps.count_protocols;\n\t\t\tcontext->plugin_extension_count += lcaps.count_extensions;\n\n\t\t\tcontinue;\n\nskip:\n\t\t\tuv_dlclose(&lib);\n\t\t}\nbail:\n\t\tuv_fs_req_cleanup(&req);\n\t\td++;\n\t}\n\n\tuv_loop_close(&loop);\n\n\treturn ret;\n\n}\n\nLWS_VISIBLE int\nlws_plat_plugins_destroy(struct lws_context * context)\n{\n\tstruct lws_plugin *plugin = context->plugin_list, *p;\n\tlws_plugin_destroy_func func;\n\tchar path[256];\n\tvoid *v;\n\tint m;\n\n\tif (!plugin)\n\t\treturn 0;\n\n\t// lwsl_notice(\"%s\\n\", __func__);\n\n\twhile (plugin) {\n\t\tp = plugin;\n#if !defined(WIN32)\n\t\tm = lws_snprintf(path, sizeof(path) - 1, \"destroy_%s\", plugin->name + 3);\n\t\tpath[m - 3] = '\\0';\n#else\n\t\tm = lws_snprintf(path, sizeof(path) - 1, \"destroy_%s\", plugin->name);\n\t\tpath[m - 4] = '\\0';\n#endif\n\n\t\tif (uv_dlsym(&plugin->lib, path, &v)) {\n\t\t\tuv_dlerror(&plugin->lib);\n\t\t\tlwsl_err(\"Failed to get init on %s: %s\",\n\t\t\t\t\tplugin->name, plugin->lib.errmsg);\n\t\t} else {\n\t\t\tfunc = (lws_plugin_destroy_func)v;\n\t\t\tm = func(context);\n\t\t\tif (m)\n\t\t\t\tlwsl_err(\"Destroying %s failed %d\\n\",\n\t\t\t\t\t\tplugin->name, m);\n\t\t}\n\n\t\tuv_dlclose(&p->lib);\n\t\tplugin = p->list;\n\t\tp->list = NULL;\n\t\tfree(p);\n\t}\n\n\tcontext->plugin_list = NULL;\n\n\treturn 0;\n}\n\n#endif\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-libwebsockets-2.1.1-wl4mcny2cwnkjjbmkopeosrtr3vocn2b/spack-src/lib/lws-plat-unix.c": "#include \"private-libwebsockets.h\"\n\n#include <pwd.h>\n#include <grp.h>\n\n#ifdef LWS_WITH_PLUGINS\n#include <dlfcn.h>\n#endif\n#include <dirent.h>\n\n\n/*\n * included from libwebsockets.c for unix builds\n */\n\nunsigned long long time_in_microseconds(void)\n{\n\tstruct timeval tv;\n\tgettimeofday(&tv, NULL);\n\treturn ((unsigned long long)tv.tv_sec * 1000000LL) + tv.tv_usec;\n}\n\nLWS_VISIBLE int\nlws_get_random(struct lws_context *context, void *buf, int len)\n{\n\treturn read(context->fd_random, (char *)buf, len);\n}\n\nLWS_VISIBLE int\nlws_send_pipe_choked(struct lws *wsi)\n{\n\tstruct lws_pollfd fds;\n\n\t/* treat the fact we got a truncated send pending as if we're choked */\n\tif (wsi->trunc_len)\n\t\treturn 1;\n\n\tfds.fd = wsi->sock;\n\tfds.events = POLLOUT;\n\tfds.revents = 0;\n\n\tif (poll(&fds, 1, 0) != 1)\n\t\treturn 1;\n\n\tif ((fds.revents & POLLOUT) == 0)\n\t\treturn 1;\n\n\t/* okay to send another packet without blocking */\n\n\treturn 0;\n}\n\nLWS_VISIBLE int\nlws_poll_listen_fd(struct lws_pollfd *fd)\n{\n\treturn poll(fd, 1, 0);\n}\n\nLWS_VISIBLE void\nlws_cancel_service_pt(struct lws *wsi)\n{\n\tstruct lws_context_per_thread *pt = &wsi->context->pt[(int)wsi->tsi];\n\tchar buf = 0;\n\n\tif (write(pt->dummy_pipe_fds[1], &buf, sizeof(buf)) != 1)\n\t\tlwsl_err(\"Cannot write to dummy pipe\");\n}\n\nLWS_VISIBLE void\nlws_cancel_service(struct lws_context *context)\n{\n\tstruct lws_context_per_thread *pt = &context->pt[0];\n\tchar buf = 0, m = context->count_threads;\n\n\twhile (m--) {\n\t\tif (write(pt->dummy_pipe_fds[1], &buf, sizeof(buf)) != 1)\n\t\t\tlwsl_err(\"Cannot write to dummy pipe\");\n\t\tpt++;\n\t}\n}\n\nLWS_VISIBLE void lwsl_emit_syslog(int level, const char *line)\n{\n\tint syslog_level = LOG_DEBUG;\n\n\tswitch (level) {\n\tcase LLL_ERR:\n\t\tsyslog_level = LOG_ERR;\n\t\tbreak;\n\tcase LLL_WARN:\n\t\tsyslog_level = LOG_WARNING;\n\t\tbreak;\n\tcase LLL_NOTICE:\n\t\tsyslog_level = LOG_NOTICE;\n\t\tbreak;\n\tcase LLL_INFO:\n\t\tsyslog_level = LOG_INFO;\n\t\tbreak;\n\t}\n\tsyslog(syslog_level, \"%s\", line);\n}\n\nLWS_VISIBLE LWS_EXTERN int\nlws_plat_service_tsi(struct lws_context *context, int timeout_ms, int tsi)\n{\n\tstruct lws_context_per_thread *pt;\n\tint n = -1, m, c;\n\tchar buf;\n\n\t/* stay dead once we are dead */\n\n\tif (!context || !context->vhost_list)\n\t\treturn 1;\n\n\tpt = &context->pt[tsi];\n\n\tif (timeout_ms < 0)\n\t\tgoto faked_service;\n\n\tlws_libev_run(context, tsi);\n\tlws_libuv_run(context, tsi);\n\n\tif (!context->service_tid_detected) {\n\t\tstruct lws _lws;\n\n\t\tmemset(&_lws, 0, sizeof(_lws));\n\t\t_lws.context = context;\n\n\t\tcontext->service_tid_detected =\n\t\t\tcontext->vhost_list->protocols[0].callback(\n\t\t\t&_lws, LWS_CALLBACK_GET_THREAD_ID, NULL, NULL, 0);\n\t}\n\tcontext->service_tid = context->service_tid_detected;\n\n\t/*\n\t * is there anybody with pending stuff that needs service forcing?\n\t */\n\tif (!lws_service_adjust_timeout(context, 1, tsi)) {\n\t\t/* -1 timeout means just do forced service */\n\t\tlws_plat_service_tsi(context, -1, pt->tid);\n\t\t/* still somebody left who wants forced service? */\n\t\tif (!lws_service_adjust_timeout(context, 1, pt->tid))\n\t\t\t/* yes... come back again quickly */\n\t\t\ttimeout_ms = 0;\n\t}\n\n\tn = poll(pt->fds, pt->fds_count, timeout_ms);\n\n#ifdef LWS_OPENSSL_SUPPORT\n\tif (!pt->rx_draining_ext_list &&\n\t    !lws_ssl_anybody_has_buffered_read_tsi(context, tsi) && !n) {\n#else\n\tif (!pt->rx_draining_ext_list && !n) /* poll timeout */ {\n#endif\n\t\tlws_service_fd_tsi(context, NULL, tsi);\n\t\treturn 0;\n\t}\n\nfaked_service:\n\tm = lws_service_flag_pending(context, tsi);\n\tif (m)\n\t\tc = -1; /* unknown limit */\n\telse\n\t\tif (n < 0) {\n\t\t\tif (LWS_ERRNO != LWS_EINTR)\n\t\t\t\treturn -1;\n\t\t\treturn 0;\n\t\t} else\n\t\t\tc = n;\n\n\t/* any socket with events to service? */\n\tfor (n = 0; n < pt->fds_count && c; n++) {\n\t\tif (!pt->fds[n].revents)\n\t\t\tcontinue;\n\n\t\tc--;\n\n\t\tif (pt->fds[n].fd == pt->dummy_pipe_fds[0]) {\n\t\t\tif (read(pt->fds[n].fd, &buf, 1) != 1)\n\t\t\t\tlwsl_err(\"Cannot read from dummy pipe.\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tm = lws_service_fd_tsi(context, &pt->fds[n], tsi);\n\t\tif (m < 0)\n\t\t\treturn -1;\n\t\t/* if something closed, retry this slot */\n\t\tif (m)\n\t\t\tn--;\n\t}\n\n\treturn 0;\n}\n\nLWS_VISIBLE int\nlws_plat_check_connection_error(struct lws *wsi)\n{\n\treturn 0;\n}\n\nLWS_VISIBLE int\nlws_plat_service(struct lws_context *context, int timeout_ms)\n{\n\treturn lws_plat_service_tsi(context, timeout_ms, 0);\n}\n\nLWS_VISIBLE int\nlws_plat_set_socket_options(struct lws_vhost *vhost, int fd)\n{\n\tint optval = 1;\n\tsocklen_t optlen = sizeof(optval);\n\n#if defined(__APPLE__) || \\\n    defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || \\\n    defined(__NetBSD__) || \\\n    defined(__OpenBSD__)\n\tstruct protoent *tcp_proto;\n#endif\n\n\tif (vhost->ka_time) {\n\t\t/* enable keepalive on this socket */\n\t\toptval = 1;\n\t\tif (setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE,\n\t\t\t       (const void *)&optval, optlen) < 0)\n\t\t\treturn 1;\n\n#if defined(__APPLE__) || \\\n    defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || \\\n    defined(__NetBSD__) || \\\n        defined(__CYGWIN__) || defined(__OpenBSD__) || defined (__sun)\n\n\t\t/*\n\t\t * didn't find a way to set these per-socket, need to\n\t\t * tune kernel systemwide values\n\t\t */\n#else\n\t\t/* set the keepalive conditions we want on it too */\n\t\toptval = vhost->ka_time;\n\t\tif (setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE,\n\t\t\t       (const void *)&optval, optlen) < 0)\n\t\t\treturn 1;\n\n\t\toptval = vhost->ka_interval;\n\t\tif (setsockopt(fd, IPPROTO_TCP, TCP_KEEPINTVL,\n\t\t\t       (const void *)&optval, optlen) < 0)\n\t\t\treturn 1;\n\n\t\toptval = vhost->ka_probes;\n\t\tif (setsockopt(fd, IPPROTO_TCP, TCP_KEEPCNT,\n\t\t\t       (const void *)&optval, optlen) < 0)\n\t\t\treturn 1;\n#endif\n\t}\n\n\t/* Disable Nagle */\n\toptval = 1;\n#if defined (__sun)\n\tif (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, (const void *)&optval, optlen) < 0)\n\t\treturn 1;\n#elif !defined(__APPLE__) && \\\n      !defined(__FreeBSD__) && !defined(__FreeBSD_kernel__) &&        \\\n      !defined(__NetBSD__) && \\\n      !defined(__OpenBSD__)\n\tif (setsockopt(fd, SOL_TCP, TCP_NODELAY, (const void *)&optval, optlen) < 0)\n\t\treturn 1;\n#else\n\ttcp_proto = getprotobyname(\"TCP\");\n\tif (setsockopt(fd, tcp_proto->p_proto, TCP_NODELAY, &optval, optlen) < 0)\n\t\treturn 1;\n#endif\n\n\t/* We are nonblocking... */\n\tif (fcntl(fd, F_SETFL, O_NONBLOCK) < 0)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nLWS_VISIBLE void\nlws_plat_drop_app_privileges(struct lws_context_creation_info *info)\n{\n\tif (info->gid != -1)\n\t\tif (setgid(info->gid))\n\t\t\tlwsl_warn(\"setgid: %s\\n\", strerror(LWS_ERRNO));\n\n\tif (info->uid != -1) {\n\t\tstruct passwd *p = getpwuid(info->uid);\n\n\t\tif (p) {\n\t\t\tinitgroups(p->pw_name, info->gid);\n\t\t\tif (setuid(info->uid))\n\t\t\t\tlwsl_warn(\"setuid: %s\\n\", strerror(LWS_ERRNO));\n\t\t\telse\n\t\t\t\tlwsl_notice(\"Set privs to user '%s'\\n\", p->pw_name);\n\t\t} else\n\t\t\tlwsl_warn(\"getpwuid: unable to find uid %d\", info->uid);\n\t}\n}\n\n#ifdef LWS_WITH_PLUGINS\n\n#if defined(LWS_USE_LIBUV) && UV_VERSION_MAJOR > 0\n\n/* libuv.c implements these in a cross-platform way */\n\n#else\n\nstatic int filter(const struct dirent *ent)\n{\n\tif (!strcmp(ent->d_name, \".\") || !strcmp(ent->d_name, \"..\"))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nLWS_VISIBLE int\nlws_plat_plugins_init(struct lws_context * context, const char * const *d)\n{\n\tstruct lws_plugin_capability lcaps;\n\tstruct lws_plugin *plugin;\n\tlws_plugin_init_func initfunc;\n\tstruct dirent **namelist;\n\tint n, i, m, ret = 0;\n\tchar path[256];\n\tvoid *l;\n\n\tlwsl_notice(\"  Plugins:\\n\");\n\n\twhile (d && *d) {\n\t\tn = scandir(*d, &namelist, filter, alphasort);\n\t\tif (n < 0) {\n\t\t\tlwsl_err(\"Scandir on %s failed\\n\", *d);\n\t\t\treturn 1;\n\t\t}\n\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tif (strlen(namelist[i]->d_name) < 7)\n\t\t\t\tgoto inval;\n\n\t\t\tlwsl_notice(\"   %s\\n\", namelist[i]->d_name);\n\n\t\t\tlws_snprintf(path, sizeof(path) - 1, \"%s/%s\", *d,\n\t\t\t\t namelist[i]->d_name);\n\t\t\tl = dlopen(path, RTLD_NOW);\n\t\t\tif (!l) {\n\t\t\t\tlwsl_err(\"Error loading DSO: %s\\n\", dlerror());\n\t\t\t\twhile (i++ < n)\n\t\t\t\t\tfree(namelist[i]);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\t/* we could open it, can we get his init function? */\n\t\t\tm = lws_snprintf(path, sizeof(path) - 1, \"init_%s\",\n\t\t\t\t     namelist[i]->d_name + 3 /* snip lib... */);\n\t\t\tpath[m - 3] = '\\0'; /* snip the .so */\n\t\t\tinitfunc = dlsym(l, path);\n\t\t\tif (!initfunc) {\n\t\t\t\tlwsl_err(\"Failed to get init on %s: %s\",\n\t\t\t\t\t\tnamelist[i]->d_name, dlerror());\n\t\t\t\tdlclose(l);\n\t\t\t}\n\t\t\tlcaps.api_magic = LWS_PLUGIN_API_MAGIC;\n\t\t\tm = initfunc(context, &lcaps);\n\t\t\tif (m) {\n\t\t\t\tlwsl_err(\"Initializing %s failed %d\\n\",\n\t\t\t\t\tnamelist[i]->d_name, m);\n\t\t\t\tdlclose(l);\n\t\t\t\tgoto skip;\n\t\t\t}\n\n\t\t\tplugin = lws_malloc(sizeof(*plugin));\n\t\t\tif (!plugin) {\n\t\t\t\tlwsl_err(\"OOM\\n\");\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tplugin->list = context->plugin_list;\n\t\t\tcontext->plugin_list = plugin;\n\t\t\tstrncpy(plugin->name, namelist[i]->d_name, sizeof(plugin->name) - 1);\n\t\t\tplugin->name[sizeof(plugin->name) - 1] = '\\0';\n\t\t\tplugin->l = l;\n\t\t\tplugin->caps = lcaps;\n\t\t\tcontext->plugin_protocol_count += lcaps.count_protocols;\n\t\t\tcontext->plugin_extension_count += lcaps.count_extensions;\n\n\t\t\tfree(namelist[i]);\n\t\t\tcontinue;\n\n\tskip:\n\t\t\tdlclose(l);\n\tinval:\n\t\t\tfree(namelist[i]);\n\t\t}\n\t\tfree(namelist);\n\t\td++;\n\t}\n\nbail:\n\tfree(namelist);\n\n\treturn ret;\n}\n\nLWS_VISIBLE int\nlws_plat_plugins_destroy(struct lws_context * context)\n{\n\tstruct lws_plugin *plugin = context->plugin_list, *p;\n\tlws_plugin_destroy_func func;\n\tchar path[256];\n\tint m;\n\n\tif (!plugin)\n\t\treturn 0;\n\n\tlwsl_notice(\"%s\\n\", __func__);\n\n\twhile (plugin) {\n\t\tp = plugin;\n\t\tm = lws_snprintf(path, sizeof(path) - 1, \"destroy_%s\", plugin->name + 3);\n\t\tpath[m - 3] = '\\0';\n\t\tfunc = dlsym(plugin->l, path);\n\t\tif (!func) {\n\t\t\tlwsl_err(\"Failed to get destroy on %s: %s\",\n\t\t\t\t\tplugin->name, dlerror());\n\t\t\tgoto next;\n\t\t}\n\t\tm = func(context);\n\t\tif (m)\n\t\t\tlwsl_err(\"Initializing %s failed %d\\n\",\n\t\t\t\tplugin->name, m);\nnext:\n\t\tdlclose(p->l);\n\t\tplugin = p->list;\n\t\tp->list = NULL;\n\t\tfree(p);\n\t}\n\n\tcontext->plugin_list = NULL;\n\n\treturn 0;\n}\n\n#endif\n#endif\n\n\n#if 0\nstatic void\nsigabrt_handler(int x)\n{\n\tprintf(\"%s\\n\", __func__);\n\t//*(char *)0 = 0;\n}\n#endif\n\nLWS_VISIBLE int\nlws_plat_context_early_init(void)\n{\n\tsignal(SIGPIPE, SIG_IGN);\n\n//\tsignal(SIGABRT, sigabrt_handler);\n\n\treturn 0;\n}\n\nLWS_VISIBLE void\nlws_plat_context_early_destroy(struct lws_context *context)\n{\n}\n\nLWS_VISIBLE void\nlws_plat_context_late_destroy(struct lws_context *context)\n{\n\tstruct lws_context_per_thread *pt = &context->pt[0];\n\tint m = context->count_threads;\n\n#ifdef LWS_WITH_PLUGINS\n\tif (context->plugin_list)\n\t\tlws_plat_plugins_destroy(context);\n#endif\n\n\tif (context->lws_lookup)\n\t\tlws_free(context->lws_lookup);\n\n\twhile (m--) {\n\t\tclose(pt->dummy_pipe_fds[0]);\n\t\tclose(pt->dummy_pipe_fds[1]);\n\t\tpt++;\n\t}\n\tclose(context->fd_random);\n}\n\n/* cast a struct sockaddr_in6 * into addr for ipv6 */\n\nLWS_VISIBLE int\nlws_interface_to_sa(int ipv6, const char *ifname, struct sockaddr_in *addr,\n\t\t    size_t addrlen)\n{\n\tint rc = -1;\n\n\tstruct ifaddrs *ifr;\n\tstruct ifaddrs *ifc;\n#ifdef LWS_USE_IPV6\n\tstruct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)addr;\n#endif\n\n\tgetifaddrs(&ifr);\n\tfor (ifc = ifr; ifc != NULL && rc; ifc = ifc->ifa_next) {\n\t\tif (!ifc->ifa_addr)\n\t\t\tcontinue;\n\n\t\tlwsl_info(\" interface %s vs %s\\n\", ifc->ifa_name, ifname);\n\n\t\tif (strcmp(ifc->ifa_name, ifname))\n\t\t\tcontinue;\n\n\t\tswitch (ifc->ifa_addr->sa_family) {\n\t\tcase AF_INET:\n#ifdef LWS_USE_IPV6\n\t\t\tif (ipv6) {\n\t\t\t\t/* map IPv4 to IPv6 */\n\t\t\t\tbzero((char *)&addr6->sin6_addr,\n\t\t\t\t\t\tsizeof(struct in6_addr));\n\t\t\t\taddr6->sin6_addr.s6_addr[10] = 0xff;\n\t\t\t\taddr6->sin6_addr.s6_addr[11] = 0xff;\n\t\t\t\tmemcpy(&addr6->sin6_addr.s6_addr[12],\n\t\t\t\t\t&((struct sockaddr_in *)ifc->ifa_addr)->sin_addr,\n\t\t\t\t\t\t\tsizeof(struct in_addr));\n\t\t\t} else\n#endif\n\t\t\t\tmemcpy(addr,\n\t\t\t\t\t(struct sockaddr_in *)ifc->ifa_addr,\n\t\t\t\t\t\t    sizeof(struct sockaddr_in));\n\t\t\tbreak;\n#ifdef LWS_USE_IPV6\n\t\tcase AF_INET6:\n\t\t\tmemcpy(&addr6->sin6_addr,\n\t\t\t  &((struct sockaddr_in6 *)ifc->ifa_addr)->sin6_addr,\n\t\t\t\t\t\t       sizeof(struct in6_addr));\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t\trc = 0;\n\t}\n\n\tfreeifaddrs(ifr);\n\n\tif (rc == -1) {\n\t\t/* check if bind to IP address */\n#ifdef LWS_USE_IPV6\n\t\tif (inet_pton(AF_INET6, ifname, &addr6->sin6_addr) == 1)\n\t\t\trc = 0;\n\t\telse\n#endif\n\t\tif (inet_pton(AF_INET, ifname, &addr->sin_addr) == 1)\n\t\t\trc = 0;\n\t}\n\n\treturn rc;\n}\n\nLWS_VISIBLE void\nlws_plat_insert_socket_into_fds(struct lws_context *context, struct lws *wsi)\n{\n\tstruct lws_context_per_thread *pt = &context->pt[(int)wsi->tsi];\n\n\tlws_libev_io(wsi, LWS_EV_START | LWS_EV_READ);\n\tlws_libuv_io(wsi, LWS_EV_START | LWS_EV_READ);\n\n\tpt->fds[pt->fds_count++].revents = 0;\n}\n\nLWS_VISIBLE void\nlws_plat_delete_socket_from_fds(struct lws_context *context,\n\t\t\t\t\t\tstruct lws *wsi, int m)\n{\n\tstruct lws_context_per_thread *pt = &context->pt[(int)wsi->tsi];\n\n\tlws_libev_io(wsi, LWS_EV_STOP | LWS_EV_READ | LWS_EV_WRITE);\n\tlws_libuv_io(wsi, LWS_EV_STOP | LWS_EV_READ | LWS_EV_WRITE);\n\n\tpt->fds_count--;\n}\n\nLWS_VISIBLE void\nlws_plat_service_periodic(struct lws_context *context)\n{\n\t/* if our parent went down, don't linger around */\n\tif (context->started_with_parent &&\n\t    kill(context->started_with_parent, 0) < 0)\n\t\tkill(getpid(), SIGTERM);\n}\n\nLWS_VISIBLE int\nlws_plat_change_pollfd(struct lws_context *context,\n\t\t      struct lws *wsi, struct lws_pollfd *pfd)\n{\n\treturn 0;\n}\n\nLWS_VISIBLE const char *\nlws_plat_inet_ntop(int af, const void *src, char *dst, int cnt)\n{\n\treturn inet_ntop(af, src, dst, cnt);\n}\n\nstatic lws_filefd_type\n_lws_plat_file_open(struct lws *wsi, const char *filename,\n\t\t    unsigned long *filelen, int flags)\n{\n\tstruct stat stat_buf;\n\tint ret = open(filename, flags, 0664);\n\n\tif (ret < 0)\n\t\treturn LWS_INVALID_FILE;\n\n\tif (fstat(ret, &stat_buf) < 0) {\n\t\tclose(ret);\n\t\treturn LWS_INVALID_FILE;\n\t}\n\t*filelen = stat_buf.st_size;\n\treturn ret;\n}\n\nstatic int\n_lws_plat_file_close(struct lws *wsi, lws_filefd_type fd)\n{\n\treturn close(fd);\n}\n\nunsigned long\n_lws_plat_file_seek_cur(struct lws *wsi, lws_filefd_type fd, long offset)\n{\n\treturn lseek(fd, offset, SEEK_CUR);\n}\n\nstatic int\n_lws_plat_file_read(struct lws *wsi, lws_filefd_type fd, unsigned long *amount,\n\t\t    unsigned char *buf, unsigned long len)\n{\n\tlong n;\n\n\tn = read((int)fd, buf, len);\n\tif (n == -1) {\n\t\t*amount = 0;\n\t\treturn -1;\n\t}\n\n\t*amount = n;\n\n\treturn 0;\n}\n\nstatic int\n_lws_plat_file_write(struct lws *wsi, lws_filefd_type fd, unsigned long *amount,\n\t\t     unsigned char *buf, unsigned long len)\n{\n\tlong n;\n\n\tn = write((int)fd, buf, len);\n\tif (n == -1) {\n\t\t*amount = 0;\n\t\treturn -1;\n\t}\n\n\t*amount = n;\n\n\treturn 0;\n}\n\n\nLWS_VISIBLE int\nlws_plat_init(struct lws_context *context,\n\t      struct lws_context_creation_info *info)\n{\n\tstruct lws_context_per_thread *pt = &context->pt[0];\n\tint n = context->count_threads, fd;\n\n\t/* master context has the global fd lookup array */\n\tcontext->lws_lookup = lws_zalloc(sizeof(struct lws *) *\n\t\t\t\t\t context->max_fds);\n\tif (context->lws_lookup == NULL) {\n\t\tlwsl_err(\"OOM on lws_lookup array for %d connections\\n\",\n\t\t\t context->max_fds);\n\t\treturn 1;\n\t}\n\n\tlwsl_notice(\" mem: platform fd map: %5lu bytes\\n\",\n\t\t    (unsigned long)(sizeof(struct lws *) * context->max_fds));\n\tfd = open(SYSTEM_RANDOM_FILEPATH, O_RDONLY);\n\n\tcontext->fd_random = fd;\n\tif (context->fd_random < 0) {\n\t\tlwsl_err(\"Unable to open random device %s %d\\n\",\n\t\t\t SYSTEM_RANDOM_FILEPATH, context->fd_random);\n\t\treturn 1;\n\t}\n\n\tif (!lws_libev_init_fd_table(context) &&\n\t    !lws_libuv_init_fd_table(context)) {\n\t\t/* otherwise libev handled it instead */\n\n\t\twhile (n--) {\n\t\t\tif (pipe(pt->dummy_pipe_fds)) {\n\t\t\t\tlwsl_err(\"Unable to create pipe\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t/* use the read end of pipe as first item */\n\t\t\tpt->fds[0].fd = pt->dummy_pipe_fds[0];\n\t\t\tpt->fds[0].events = LWS_POLLIN;\n\t\t\tpt->fds[0].revents = 0;\n\t\t\tpt->fds_count = 1;\n\t\t\tpt++;\n\t\t}\n\t}\n\n\tcontext->fops.open\t= _lws_plat_file_open;\n\tcontext->fops.close\t= _lws_plat_file_close;\n\tcontext->fops.seek_cur\t= _lws_plat_file_seek_cur;\n\tcontext->fops.read\t= _lws_plat_file_read;\n\tcontext->fops.write\t= _lws_plat_file_write;\n\n#ifdef LWS_WITH_PLUGINS\n\tif (info->plugin_dirs)\n\t\tlws_plat_plugins_init(context, info->plugin_dirs);\n#endif\n\n\treturn 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-libwebsockets-2.1.1-wl4mcny2cwnkjjbmkopeosrtr3vocn2b/spack-src/test-server/android/app/src/main/jni/NativeLibs.mk": "#\n# GNU Make makefile for building static libraries for use with the Android NDK\n# Copyright (C) 2016, Alexander Bruines <alexander.bruines@gmail.com>\n#\n# This file is made available under the Creative Commons CC0 1.0\n# Universal Public Domain Dedication.\n#\n# The person who associated a work with this deed has dedicated\n# the work to the public domain by waiving all of his or her rights\n# to the work worldwide under copyright law, including all related\n# and neighboring rights, to the extent allowed by law. You can copy,\n# modify, distribute and perform the work, even for commercial purposes,\n# all without asking permission.\n#\n# The test apps are intended to be adapted for use in your code, which\n# may be proprietary.  So unlike the library itself, they are licensed\n# Public Domain.\n#\n\n#\n# This makefile is fully intergrated with this Android Studio project and\n# it will be called automaticaly when you build the project with Gradle.\n#\n# The source packages for the libraries will be automaticaly downloaded.\n# Alternativly you can provide your own sources by placing the following\n# files in the 'jni' directory:\n#\n#  zlib-1.2.8.tar.gz\n#  openssl-1.0.2g.tar.gz\n#  libwebsockets.tar.gz\n#\n# This makefile was tested with the latest NDK/SDK and Android Studio at the\n# time of this writing. As these software packages evolve changes to this\n# makefile may be needed or it may become obselete...\n#\n# This makefile was made for use in Linux but you may be able to edit it\n# and make it work under Windows.\n#\n# At least on Debian, building openssl requires package xutils-dev\n# for makedepend. Ofcourse the standard development packages must also be\n# installed, but xutils-dev is not that obvious in this case...\n#\n# Makedepend will most likely print a lot of warnings during the 'make depend'\n# stage of building openssl. In this case these warnings can be safely ignored.\n#\n\n# Include Application.mk but do not complain if it is not found\n#\nifeq ($(MAKE_NO_INCLUDES),)\n-include Application.mk\nendif\n\n# Location of the NDK.\n#\nifeq ($(NDK_ROOT),)\nNDK_ROOT := /opt/Android/SDK/ndk-bundle\nendif\n\n# Select the ABIs to compile for\n#\nNDK_APP_ABI = $(APP_ABI)\nifeq ($(NDK_APP_ABI),)\n# Set to 'all' if APP_ABI is undefined\nNDK_APP_ABI = all\nendif\nifeq ($(NDK_APP_ABI),all)\n# Translate 'all' to the individual targets\nNDK_APP_ABI = armeabi armeabi-v7a arm64-v8a mips mips64 x86 x86_64\nelse\n# Use the targets from APP_ABI\nNDK_APP_ABI = $(APP_ABI)\nendif\n\n# Select the Android platform to compile for\n#\nifeq ($(APP_PLATFORM),)\n# use a level that supports all specified ABIs if none was specified\nAPP_PLATFORM = android-21\nendif\n\nNDK_MAKE_TOOLCHAIN := $(NDK_ROOT)/build/tools/make_standalone_toolchain.py\n\n#\n# The source packages we want/need\n# Zlib and openssl should be defined in Application.mk, libwebsockets is\n# cloned from github\n#\n\nifeq ($(ZLIB_VERSION),)\nZLIB_VERSION := 1.2.8\nendif\nifeq ($(OPENSSL_VERSION),)\nOPENSSL_VERSION := 1.0.2g\nendif\n\nifeq ($(ZLIB_TGZ_SOURCE),)\nZLIB_TGZ_SOURCE := zlib-$(ZLIB_VERSION).tar.gz\nendif\nifeq ($(OPENSSL_TGZ_SOURCE),)\nOPENSSL_TGZ_SOURCE := openssl-$(OPENSSL_VERSION).tar.gz\nendif\nLIBWEBSOCKETS_TGZ_SOURCE := libwebsockets.tar.gz\n\n# The names of the directories in the source tgz files\nZLIB_DIR := $(basename $(basename $(ZLIB_TGZ_SOURCE)))\nOPENSSL_DIR := $(basename $(basename $(OPENSSL_TGZ_SOURCE)))\nLIBWEBSOCKETS_DIR := $(basename $(basename $(LIBWEBSOCKETS_TGZ_SOURCE)))\n\n# The URLs used to fetch the source tgz files\nZLIB_TGZ_URL := http://prdownloads.sourceforge.net/libpng/$(ZLIB_TGZ_SOURCE)\nOPENSSL_TGZ_URL := https://openssl.org/source/$(OPENSSL_TGZ_SOURCE)\nifeq ($(LIBWEBSOCKETS_GIT_URL),)\nLIBWEBSOCKETS_GIT_URL := https://github.com/warmcat/libwebsockets.git\nendif\n\n# These values are the same as the values for $TARGET_ARCH_ABI in Android.mk\n# This way 'make $TARGET_ARCH_ABI' builds libraries for that ABI.\n# This is also the name for the directory where the libraries are installed to.\n#\nTARGET_X86 := x86\nTARGET_X86_64 := x86_64\nTARGET_ARM := armeabi\nTARGET_ARM_V7A := armeabi-v7a\nTARGET_ARM_V7A_HARD := armeabi-v7a-hard\nTARGET_ARM64_V8A := arm64-v8a\nTARGET_MIPS := mips\nTARGET_MIPS64 := mips64\n\n# The Android NDK API version to build the libraries with.\n#\n#  android-9 ... android-19 support arm mips and x86\n#  android-21 and higher also support arm64 mips64 and x86_64\n#\n# These should be set to the same value as APP_PLATFORM (Application.mk)\n#\n# http://developer.android.com/ndk/guides/stable_apis.html\n#\n# If you change these or APP_PLATFORM you must do a 'make clean'\n#\n# Note:\n# libraries compiled for android-21 and upwards are incompatible with devices below that version!\n# http://stackoverflow.com/questions/28740315/android-ndk-getting-java-lang-unsatisfiedlinkerror-dlopen-failed-cannot-loca\n#\nTARGET_X86_NDK_API := $(subst android-,,$(APP_PLATFORM))\nTARGET_X86_64_NDK_API := $(subst android-,,$(APP_PLATFORM))\nTARGET_ARM_NDK_API := $(subst android-,,$(APP_PLATFORM))\nTARGET_ARM_V7A_NDK_API := $(subst android-,,$(APP_PLATFORM))\nTARGET_ARM_V7A_HARD_NDK_API := $(subst android-,,$(APP_PLATFORM))\nTARGET_ARM64_V8A_NDK_API := $(subst android-,,$(APP_PLATFORM))\nTARGET_MIPS_NDK_API := $(subst android-,,$(APP_PLATFORM))\nTARGET_MIPS64_NDK_API := $(subst android-,,$(APP_PLATFORM))\n\n# The configure arguments to pass to the OpenSSL Configure script\n# (--prefix and --openssldir are added automaticaly).\n# (note: use no-asm on x86 and x86_64 to generate fully position independent code)\n#\n# x86\nTARGET_X86_OPENSSL_CONFIG_TARGET := android-x86\nTARGET_X86_OPENSSL_CONFIG := no-asm no-shared no-idea no-mdc2 no-rc5 no-zlib no-zlib-dynamic enable-tlsext no-ssl2 no-ssl3 enable-ec enable-ecdh enable-ecp\n# x86_64\nTARGET_X86_64_OPENSSL_CONFIG_TARGET := linux-x86_64\nTARGET_X86_64_OPENSSL_CONFIG := no-asm no-shared no-idea no-mdc2 no-rc5 no-zlib no-zlib-dynamic enable-tlsext no-ssl2 no-ssl3 enable-ec enable-ecdh enable-ecp enable-ec_nistp_64_gcc_128\n# armeabi\nTARGET_ARM_OPENSSL_CONFIG_TARGET := android\nTARGET_ARM_OPENSSL_CONFIG := no-shared no-idea no-mdc2 no-rc5 no-zlib no-zlib-dynamic enable-tlsext no-ssl2 no-ssl3 enable-ec enable-ecdh enable-ecp\n# armeabi-v7a\nTARGET_ARM_V7A_OPENSSL_CONFIG_TARGET := android-armv7\nTARGET_ARM_V7A_OPENSSL_CONFIG := no-shared no-idea no-mdc2 no-rc5 no-zlib no-zlib-dynamic enable-tlsext no-ssl2 no-ssl3 enable-ec enable-ecdh enable-ecp\n# armeabi-v7a-hard\nTARGET_ARM_V7A_HARD_OPENSSL_CONFIG_TARGET := android-armv7\nTARGET_ARM_V7A_HARD_OPENSSL_CONFIG := no-shared no-idea no-mdc2 no-rc5 no-zlib no-zlib-dynamic enable-tlsext no-ssl2 no-ssl3 enable-ec enable-ecdh enable-ecp\n# arm64-v8a\nTARGET_ARM64_V8A_OPENSSL_CONFIG_TARGET := android\nTARGET_ARM64_V8A_OPENSSL_CONFIG := no-shared no-idea no-mdc2 no-rc5 no-zlib no-zlib-dynamic enable-tlsext no-ssl2 no-ssl3 enable-ec enable-ecdh enable-ecp\n# mips\nTARGET_MIPS_OPENSSL_CONFIG_TARGET := android-mips\nTARGET_MIPS_OPENSSL_CONFIG := no-shared no-idea no-mdc2 no-rc5 no-zlib no-zlib-dynamic enable-tlsext no-ssl2 no-ssl3 enable-ec enable-ecdh enable-ecp\n# mips64\nTARGET_MIPS64_OPENSSL_CONFIG_TARGET := android\nTARGET_MIPS64_OPENSSL_CONFIG := no-shared no-idea no-mdc2 no-rc5 no-zlib no-zlib-dynamic enable-tlsext no-ssl2 no-ssl3 enable-ec enable-ecdh enable-ecp\n\n# The cmake configuration options for libwebsockets per target ABI,\n# --prefix and openssl library/header paths are set automaticaly and\n# the location of zlib should be picked up by CMake\n# x86\nTARGET_X86_LWS_OPTIONS = \\\n -DCMAKE_C_COMPILER=$(shell pwd)/$(TOOLCHAIN_X86)/bin/$(TOOLCHAIN_X86_PREFIX)-gcc \\\n -DCMAKE_AR=$(shell pwd)/$(TOOLCHAIN_X86)/bin/$(TOOLCHAIN_X86_PREFIX)-ar \\\n -DCMAKE_RANLIB=$(shell pwd)/$(TOOLCHAIN_X86)/bin/$(TOOLCHAIN_X86_PREFIX)-ranlib \\\n -DCMAKE_C_FLAGS=\"$$CFLAGS\" \\\n -DLWS_WITH_SHARED=OFF \\\n -DLWS_WITH_STATIC=ON \\\n -DLWS_WITHOUT_DAEMONIZE=ON \\\n -DLWS_WITHOUT_TESTAPPS=ON \\\n -DLWS_IPV6=OFF \\\n -DLWS_USE_BUNDLED_ZLIB=OFF \\\n -DLWS_WITH_SSL=ON  \\\n -DLWS_WITH_HTTP2=ON \\\n -DCMAKE_BUILD_TYPE=Release\n# x86_64\nTARGET_X86_64_LWS_OPTIONS = \\\n -DCMAKE_C_COMPILER=$(shell pwd)/$(TOOLCHAIN_X86_64)/bin/$(TOOLCHAIN_X86_64_PREFIX)-gcc \\\n -DCMAKE_AR=$(shell pwd)/$(TOOLCHAIN_X86_64)/bin/$(TOOLCHAIN_X86_64_PREFIX)-ar \\\n -DCMAKE_RANLIB=$(shell pwd)/$(TOOLCHAIN_X86_64)/bin/$(TOOLCHAIN_X86_64_PREFIX)-ranlib \\\n -DCMAKE_C_FLAGS=\"$$CFLAGS\" \\\n -DLWS_WITH_SHARED=OFF \\\n -DLWS_WITH_STATIC=ON \\\n -DLWS_WITHOUT_DAEMONIZE=ON \\\n -DLWS_WITHOUT_TESTAPPS=ON \\\n -DLWS_IPV6=OFF \\\n -DLWS_USE_BUNDLED_ZLIB=OFF \\\n -DLWS_WITH_SSL=ON  \\\n -DLWS_WITH_HTTP2=ON \\\n -DCMAKE_BUILD_TYPE=Release\n# armeabi\nTARGET_ARM_LWS_OPTIONS = \\\n -DCMAKE_C_COMPILER=$(shell pwd)/$(TOOLCHAIN_ARM)/bin/$(TOOLCHAIN_ARM_PREFIX)-gcc \\\n -DCMAKE_AR=$(shell pwd)/$(TOOLCHAIN_ARM)/bin/$(TOOLCHAIN_ARM_PREFIX)-ar \\\n -DCMAKE_RANLIB=$(shell pwd)/$(TOOLCHAIN_ARM)/bin/$(TOOLCHAIN_ARM_PREFIX)-ranlib \\\n -DCMAKE_C_FLAGS=\"$$CFLAGS\" \\\n -DLWS_WITH_SHARED=OFF \\\n -DLWS_WITH_STATIC=ON \\\n -DLWS_WITHOUT_DAEMONIZE=ON \\\n -DLWS_WITHOUT_TESTAPPS=ON \\\n -DLWS_IPV6=OFF \\\n -DLWS_USE_BUNDLED_ZLIB=OFF \\\n -DLWS_WITH_SSL=ON  \\\n -DLWS_WITH_HTTP2=ON \\\n -DCMAKE_BUILD_TYPE=Release\n# armeabi-v7a\nTARGET_ARM_V7A_LWS_OPTIONS = \\\n -DCMAKE_C_COMPILER=$(shell pwd)/$(TOOLCHAIN_ARM_V7A)/bin/$(TOOLCHAIN_ARM_V7A_PREFIX)-gcc \\\n -DCMAKE_AR=$(shell pwd)/$(TOOLCHAIN_ARM_V7A)/bin/$(TOOLCHAIN_ARM_V7A_PREFIX)-ar \\\n -DCMAKE_RANLIB=$(shell pwd)/$(TOOLCHAIN_ARM_V7A)/bin/$(TOOLCHAIN_ARM_V7A_PREFIX)-ranlib \\\n -DCMAKE_C_FLAGS=\"$$CFLAGS\" \\\n -DLWS_WITH_SHARED=OFF \\\n -DLWS_WITH_STATIC=ON \\\n -DLWS_WITHOUT_DAEMONIZE=ON \\\n -DLWS_WITHOUT_TESTAPPS=ON \\\n -DLWS_IPV6=OFF \\\n -DLWS_USE_BUNDLED_ZLIB=OFF \\\n -DLWS_WITH_SSL=ON  \\\n -DLWS_WITH_HTTP2=ON \\\n -DCMAKE_BUILD_TYPE=Release\n# armeabi-v7a-hard\nTARGET_ARM_V7A_HARD_LWS_OPTIONS = \\\n -DCMAKE_C_COMPILER=$(shell pwd)/$(TOOLCHAIN_ARM_V7A_HARD)/bin/$(TOOLCHAIN_ARM_V7A_HARD_PREFIX)-gcc \\\n -DCMAKE_AR=$(shell pwd)/$(TOOLCHAIN_ARM_V7A_HARD)/bin/$(TOOLCHAIN_ARM_V7A_HARD_PREFIX)-ar \\\n -DCMAKE_RANLIB=$(shell pwd)/$(TOOLCHAIN_ARM_V7A_HARD)/bin/$(TOOLCHAIN_ARM_V7A_HARD_PREFIX)-ranlib \\\n -DCMAKE_C_FLAGS=\"$$CFLAGS\" \\\n -DLWS_WITH_SHARED=OFF \\\n -DLWS_WITH_STATIC=ON \\\n -DLWS_WITHOUT_DAEMONIZE=ON \\\n -DLWS_WITHOUT_TESTAPPS=ON \\\n -DLWS_IPV6=OFF \\\n -DLWS_USE_BUNDLED_ZLIB=OFF \\\n -DLWS_WITH_SSL=ON  \\\n -DLWS_WITH_HTTP2=ON \\\n -DCMAKE_BUILD_TYPE=Release\n# arm64-v8a\nTARGET_ARM64_V8A_LWS_OPTIONS = \\\n -DCMAKE_C_COMPILER=$(shell pwd)/$(TOOLCHAIN_ARM64_V8A)/bin/$(TOOLCHAIN_ARM64_V8A_PREFIX)-gcc \\\n -DCMAKE_AR=$(shell pwd)/$(TOOLCHAIN_ARM64_V8A)/bin/$(TOOLCHAIN_ARM64_V8A_PREFIX)-ar \\\n -DCMAKE_RANLIB=$(shell pwd)/$(TOOLCHAIN_ARM64_V8A)/bin/$(TOOLCHAIN_ARM64_V8A_PREFIX)-ranlib \\\n -DCMAKE_C_FLAGS=\"$$CFLAGS\" \\\n -DLWS_WITH_SHARED=OFF \\\n -DLWS_WITH_STATIC=ON \\\n -DLWS_WITHOUT_DAEMONIZE=ON \\\n -DLWS_WITHOUT_TESTAPPS=ON \\\n -DLWS_IPV6=OFF \\\n -DLWS_USE_BUNDLED_ZLIB=OFF \\\n -DLWS_WITH_SSL=ON  \\\n -DLWS_WITH_HTTP2=ON \\\n -DCMAKE_BUILD_TYPE=Release\n# mips\nTARGET_MIPS_LWS_OPTIONS = \\\n -DCMAKE_C_COMPILER=$(shell pwd)/$(TOOLCHAIN_MIPS)/bin/$(TOOLCHAIN_MIPS_PREFIX)-gcc \\\n -DCMAKE_AR=$(shell pwd)/$(TOOLCHAIN_MIPS)/bin/$(TOOLCHAIN_MIPS_PREFIX)-ar \\\n -DCMAKE_RANLIB=$(shell pwd)/$(TOOLCHAIN_MIPS)/bin/$(TOOLCHAIN_MIPS_PREFIX)-ranlib \\\n -DCMAKE_C_FLAGS=\"$$CFLAGS\" \\\n -DLWS_WITH_SHARED=OFF \\\n -DLWS_WITH_STATIC=ON \\\n -DLWS_WITHOUT_DAEMONIZE=ON \\\n -DLWS_WITHOUT_TESTAPPS=ON \\\n -DLWS_IPV6=OFF \\\n -DLWS_USE_BUNDLED_ZLIB=OFF \\\n -DLWS_WITH_SSL=ON  \\\n -DLWS_WITH_HTTP2=ON \\\n -DCMAKE_BUILD_TYPE=Release\n# mips64\nTARGET_MIPS64_LWS_OPTIONS = \\\n -DCMAKE_C_COMPILER=$(shell pwd)/$(TOOLCHAIN_MIPS64)/bin/$(TOOLCHAIN_MIPS64_PREFIX)-gcc \\\n -DCMAKE_AR=$(shell pwd)/$(TOOLCHAIN_MIPS64)/bin/$(TOOLCHAIN_MIPS64_PREFIX)-ar \\\n -DCMAKE_RANLIB=$(shell pwd)/$(TOOLCHAIN_MIPS64)/bin/$(TOOLCHAIN_MIPS64_PREFIX)-ranlib \\\n -DCMAKE_C_FLAGS=\"$$CFLAGS\" \\\n -DLWS_WITH_SHARED=OFF \\\n -DLWS_WITH_STATIC=ON \\\n -DLWS_WITHOUT_DAEMONIZE=ON \\\n -DLWS_WITHOUT_TESTAPPS=ON \\\n -DLWS_IPV6=OFF \\\n -DLWS_USE_BUNDLED_ZLIB=OFF \\\n -DLWS_WITH_SSL=ON  \\\n -DLWS_WITH_HTTP2=ON \\\n -DCMAKE_BUILD_TYPE=Release\n\n#\n# Toolchain configuration\n#\n\n# The directory names for the different toolchains\nTOOLCHAIN_X86 := toolchains/x86\nTOOLCHAIN_X86_64 := toolchains/x86_64\nTOOLCHAIN_ARM := toolchains/arm\nTOOLCHAIN_ARM_V7A := toolchains/arm-v7a\nTOOLCHAIN_ARM_V7A_HARD := toolchains/arm-v7a-hard\nTOOLCHAIN_ARM64_V8A := toolchains/arm64-v8a\nTOOLCHAIN_MIPS := toolchains/mips\nTOOLCHAIN_MIPS64 := toolchains/mips64\n\n# Use APP_STL to determine what STL to use.\n#\nifeq ($(APP_STL),stlport_static)\nTOOLCHAIN_STL := stlport\nelse ifeq ($(APP_STL),stlport_shared)\nTOOLCHAIN_STL := stlport\nelse ifeq ($(APP_STL),gnustl_static)\nTOOLCHAIN_STL := gnustl\nelse ifeq ($(APP_STL),gnustl_shared)\nTOOLCHAIN_STL := gnustl\nelse ifeq ($(APP_STL),c++_static)\nTOOLCHAIN_STL := libc++\nelse ifeq ($(APP_STL),c++_shared)\nTOOLCHAIN_STL := libc++\nendif\n\n# The settings to use for the individual toolchains:\n# x86\nTOOLCHAIN_X86_API := $(TARGET_X86_NDK_API)\nTOOLCHAIN_X86_PREFIX := i686-linux-android\nTOOLCHAIN_X86_FLAGS := -march=i686 -msse3 -mstackrealign -mfpmath=sse\nTOOLCHAIN_X86_LINK :=\nTOOLCHAIN_X86_PLATFORM_HEADERS := $(shell pwd)/$(TOOLCHAIN_X86)/sysroot/usr/include\nTOOLCHAIN_X86_PLATFORM_LIBS := $(shell pwd)/$(TOOLCHAIN_X86)/sysroot/usr/lib\n# x86_64\nTOOLCHAIN_X86_64_API := $(TARGET_X86_64_NDK_API)\nTOOLCHAIN_X86_64_PREFIX := x86_64-linux-android\nTOOLCHAIN_X86_64_FLAGS :=\nTOOLCHAIN_X86_64_LINK :=\nTOOLCHAIN_X86_64_PLATFORM_HEADERS := $(shell pwd)/$(TOOLCHAIN_X86_64)/sysroot/usr/include\nTOOLCHAIN_X86_64_PLATFORM_LIBS := $(shell pwd)/$(TOOLCHAIN_X86_64)/sysroot/usr/lib\n# arm\nTOOLCHAIN_ARM_API := $(TARGET_ARM_NDK_API)\nTOOLCHAIN_ARM_PREFIX := arm-linux-androideabi\nTOOLCHAIN_ARM_FLAGS := -mthumb\nTOOLCHAIN_ARM_LINK :=\nTOOLCHAIN_ARM_PLATFORM_HEADERS := $(shell pwd)/$(TOOLCHAIN_ARM)/sysroot/usr/include\nTOOLCHAIN_ARM_PLATFORM_LIBS := $(shell pwd)/$(TOOLCHAIN_ARM)/sysroot/usr/lib\n# arm-v7a\nTOOLCHAIN_ARM_V7A_API := $(TARGET_ARM_V7A_NDK_API)\nTOOLCHAIN_ARM_V7A_PREFIX := arm-linux-androideabi\nTOOLCHAIN_ARM_V7A_FLAGS := -march=armv7-a -mfloat-abi=softfp -mfpu=vfpv3-d16\nTOOLCHAIN_ARM_V7A_LINK := -march=armv7-a -Wl,--fix-cortex-a8\nTOOLCHAIN_ARM_V7A_PLATFORM_HEADERS :=  $(shell pwd)/$(TOOLCHAIN_ARM_V7A)/sysroot/usr/include\nTOOLCHAIN_ARM_V7A_PLATFORM_LIBS := $(shell pwd)/$(TOOLCHAIN_ARM_V7A)/sysroot/usr/lib\n# arm-v7a-hard\nTOOLCHAIN_ARM_V7A_HARD_API := $(TARGET_ARM_V7A_HARD_NDK_API)\nTOOLCHAIN_ARM_V7A_HARD_PREFIX := arm-linux-androideabi\nTOOLCHAIN_ARM_V7A_HARD_FLAGS := -march=armv7-a -mfpu=vfpv3-d16 -mhard-float -mfloat-abi=hard -D_NDK_MATH_NO_SOFTFP=1\nTOOLCHAIN_ARM_V7A_HARD_LINK := -march=armv7-a -Wl,--fix-cortex-a8 -Wl,--no-warn-mismatch -lm_hard\nTOOLCHAIN_ARM_V7A_HARD_PLATFORM_HEADERS :=  $(shell pwd)/$(TOOLCHAIN_ARM_V7A_HARD)/sysroot/usr/include\nTOOLCHAIN_ARM_V7A_HARD_PLATFORM_LIBS := $(shell pwd)/$(TOOLCHAIN_ARM_V7A_HARD)/sysroot/usr/lib\n# arm64-v8a\nTOOLCHAIN_ARM64_V8A_API := $(TARGET_ARM64_V8A_NDK_API)\nTOOLCHAIN_ARM64_V8A_PREFIX := aarch64-linux-android\nTOOLCHAIN_ARM64_V8A_FLAGS :=\nTOOLCHAIN_ARM64_V8A_LINK :=\nTOOLCHAIN_ARM64_V8A_PLATFORM_HEADERS := $(shell pwd)/$(TOOLCHAIN_ARM64_V8A)/sysroot/usr/include\nTOOLCHAIN_ARM64_V8A_PLATFORM_LIBS := $(shell pwd)/$(TOOLCHAIN_ARM64_V8A)/sysroot/usr/lib\n# mips\nTOOLCHAIN_MIPS_API := $(TARGET_MIPS_NDK_API)\nTOOLCHAIN_MIPS_PREFIX := mipsel-linux-android\nTOOLCHAIN_MIPS_FLAGS :=\nTOOLCHAIN_MIPS_LINK :=\nTOOLCHAIN_MIPS_PLATFORM_HEADERS := $(shell pwd)/$(TOOLCHAIN_MIPS)/sysroot/usr/include\nTOOLCHAIN_MIPS_PLATFORM_LIBS := $(shell pwd)/$(TOOLCHAIN_MIPS)/sysroot/usr/lib\n# mips64\nTOOLCHAIN_MIPS64_API := $(TARGET_MIPS64_NDK_API)\nTOOLCHAIN_MIPS64_PREFIX := mips64el-linux-android\nTOOLCHAIN_MIPS64_FLAGS :=\nTOOLCHAIN_MIPS64_LINK :=\nTOOLCHAIN_MIPS64_PLATFORM_HEADERS := $(shell pwd)/$(TOOLCHAIN_MIPS64)/sysroot/usr/include\nTOOLCHAIN_MIPS64_PLATFORM_LIBS := $(shell pwd)/$(TOOLCHAIN_MIPS64)/sysroot/usr/lib\n\n# Environment variables to set while compiling for each ABI\n# x86\nTOOLCHAIN_X86_ENV = \\\n ANDROID_DEV=\"$(shell pwd)/$(TOOLCHAIN_X86)/bin\" \\\n CC=$(TOOLCHAIN_X86_PREFIX)-gcc \\\n CXX=$(TOOLCHAIN_X86_PREFIX)-g++ \\\n LINK=$(TOOLCHAIN_X86_PREFIX)-g++ \\\n LD=$(TOOLCHAIN_X86_PREFIX)-ld \\\n AR=$(TOOLCHAIN_X86_PREFIX)-ar \\\n RANLIB=$(TOOLCHAIN_X86_PREFIX)-ranlib \\\n STRIP=$(TOOLCHAIN_X86_PREFIX)-strip \\\n ARCH_FLAGS=\"$(TOOLCHAIN_X86_FLAGS)\" \\\n ARCH_LINK=\"$(TOOLCHAIN_X86_LINK)\" \\\n CPPFLAGS=\"-I. $(TOOLCHAIN_X86_FLAGS) -I$(TOOLCHAIN_X86_PLATFORM_HEADERS) -fpic -ffunction-sections -funwind-tables -fstack-protector -fno-strict-aliasing -finline-limit=64\" \\\n CXXFLAGS=\"-I. $(TOOLCHAIN_X86_FLAGS) -I$(TOOLCHAIN_X86_PLATFORM_HEADERS) -fpic -ffunction-sections -funwind-tables -fstack-protector -fno-strict-aliasing -finline-limit=64 -frtti -fexceptions\" \\\n CFLAGS=\"-I. $(TOOLCHAIN_X86_FLAGS) -I$(TOOLCHAIN_X86_PLATFORM_HEADERS) -fpic -ffunction-sections -funwind-tables -fstack-protector -fno-strict-aliasing -finline-limit=64\" \\\n LDFLAGS=\"$(TOOLCHAIN_X86_LINK)\" \\\n PATH=\"$(shell pwd)/$(TOOLCHAIN_X86)/bin:$$PATH\"\n# x86_64\nTOOLCHAIN_X86_64_ENV = \\\n ANDROID_DEV=\"$(shell pwd)/$(TOOLCHAIN_X86_64)/bin\" \\\n CC=$(TOOLCHAIN_X86_64_PREFIX)-gcc \\\n CXX=$(TOOLCHAIN_X86_64_PREFIX)-g++ \\\n LINK=$(TOOLCHAIN_X86_64_PREFIX)-g++ \\\n LD=$(TOOLCHAIN_X86_64_PREFIX)-ld \\\n AR=$(TOOLCHAIN_X86_64_PREFIX)-ar \\\n RANLIB=$(TOOLCHAIN_X86_64_PREFIX)-ranlib \\\n STRIP=$(TOOLCHAIN_X86_64_PREFIX)-strip \\\n ARCH_FLAGS=\"$(TOOLCHAIN_X86_64_FLAGS)\" \\\n ARCH_LINK=\"$(TOOLCHAIN_X86_64_LINK)\" \\\n CPPFLAGS=\"-I. $(TOOLCHAIN_X86_64_FLAGS) -I$(TOOLCHAIN_X86_64_PLATFORM_HEADERS) -fpic -ffunction-sections -funwind-tables -fstack-protector -fno-strict-aliasing -finline-limit=64\" \\\n CXXFLAGS=\"-I. $(TOOLCHAIN_X86_64_FLAGS) -I$(TOOLCHAIN_X86_64_PLATFORM_HEADERS) -fpic -ffunction-sections -funwind-tables -fstack-protector -fno-strict-aliasing -finline-limit=64 -frtti -fexceptions\" \\\n CFLAGS=\"-I. $(TOOLCHAIN_X86_64_FLAGS) -I$(TOOLCHAIN_X86_64_PLATFORM_HEADERS) -fpic -ffunction-sections -funwind-tables -fstack-protector -fno-strict-aliasing -finline-limit=64\" \\\n LDFLAGS=\"$(TOOLCHAIN_X86_64_LINK)\" \\\n PATH=\"$(shell pwd)/$(TOOLCHAIN_X86_64)/bin:$$PATH\"\n# arm\nTOOLCHAIN_ARM_ENV = \\\n ANDROID_DEV=\"$(shell pwd)/$(TOOLCHAIN_ARM)/bin\" \\\n CC=$(TOOLCHAIN_ARM_PREFIX)-gcc \\\n CXX=$(TOOLCHAIN_ARM_PREFIX)-g++ \\\n LINK=$(TOOLCHAIN_ARM_PREFIX)-g++ \\\n LD=$(TOOLCHAIN_ARM_PREFIX)-ld \\\n AR=$(TOOLCHAIN_ARM_PREFIX)-ar \\\n RANLIB=$(TOOLCHAIN_ARM_PREFIX)-ranlib \\\n STRIP=$(TOOLCHAIN_ARM_PREFIX)-strip \\\n ARCH_FLAGS=\"$(TOOLCHAIN_ARM_FLAGS)\" \\\n ARCH_LINK=\"$(TOOLCHAIN_ARM_LINK)\" \\\n CPPFLAGS=\"-I. $(TOOLCHAIN_ARM_FLAGS) -I$(TOOLCHAIN_ARM_PLATFORM_HEADERS) -fpic -ffunction-sections -funwind-tables -fstack-protector -fno-strict-aliasing -finline-limit=64\" \\\n CXXFLAGS=\"-I. $(TOOLCHAIN_ARM_FLAGS) -I$(TOOLCHAIN_ARM_PLATFORM_HEADERS) -fpic -ffunction-sections -funwind-tables -fstack-protector -fno-strict-aliasing -finline-limit=64 -frtti -fexceptions\" \\\n CFLAGS=\"-I. $(TOOLCHAIN_ARM_FLAGS) -I$(TOOLCHAIN_ARM_PLATFORM_HEADERS) -fpic -ffunction-sections -funwind-tables -fstack-protector -fno-strict-aliasing -finline-limit=64\" \\\n LDFLAGS=\"$(TOOLCHAIN_ARM_LINK)\" \\\n PATH=\"$(shell pwd)/$(TOOLCHAIN_ARM)/bin:$$PATH\"\n# arm-v7a\nTOOLCHAIN_ARM_V7A_ENV = \\\n ANDROID_DEV=\"$(shell pwd)/$(TOOLCHAIN_ARM_V7A)/bin\" \\\n CC=$(TOOLCHAIN_ARM_V7A_PREFIX)-gcc \\\n CXX=$(TOOLCHAIN_ARM_V7A_PREFIX)-g++ \\\n LINK=$(TOOLCHAIN_ARM_V7A_PREFIX)-g++ \\\n LD=$(TOOLCHAIN_ARM_V7A_PREFIX)-ld \\\n AR=$(TOOLCHAIN_ARM_V7A_PREFIX)-ar \\\n RANLIB=$(TOOLCHAIN_ARM_V7A_PREFIX)-ranlib \\\n STRIP=$(TOOLCHAIN_ARM_V7A_PREFIX)-strip \\\n ARCH_FLAGS=\"$(TOOLCHAIN_ARM_V7A_FLAGS)\" \\\n ARCH_LINK=\"$(TOOLCHAIN_ARM_V7A_LINK)\" \\\n CPPFLAGS=\"-I. $(TOOLCHAIN_ARM_V7A_FLAGS) -I$(TOOLCHAIN_ARM_V7A_PLATFORM_HEADERS) -fpic -ffunction-sections -funwind-tables -fstack-protector -fno-strict-aliasing -finline-limit=64\" \\\n CXXFLAGS=\"-I. $(TOOLCHAIN_ARM_V7A_FLAGS) -I$(TOOLCHAIN_ARM_V7A_PLATFORM_HEADERS) -fpic -ffunction-sections -funwind-tables -fstack-protector -fno-strict-aliasing -finline-limit=64 -frtti -fexceptions\" \\\n CFLAGS=\"-I. $(TOOLCHAIN_ARM_V7A_FLAGS) -I$(TOOLCHAIN_ARM_V7A_PLATFORM_HEADERS) -fpic -ffunction-sections -funwind-tables -fstack-protector -fno-strict-aliasing -finline-limit=64\" \\\n LDFLAGS=\"$(TOOLCHAIN_ARM_V7A_LINK)\" \\\n PATH=\"$(shell pwd)/$(TOOLCHAIN_ARM_V7A)/bin:$$PATH\"\n# arm-v7a-hard\nTOOLCHAIN_ARM_V7A_HARD_ENV = \\\n ANDROID_DEV=\"$(shell pwd)/$(TOOLCHAIN_ARM_V7A_HARD)/bin\" \\\n CC=$(TOOLCHAIN_ARM_V7A_HARD_PREFIX)-gcc \\\n CXX=$(TOOLCHAIN_ARM_V7A_HARD_PREFIX)-g++ \\\n LINK=$(TOOLCHAIN_ARM_V7A_HARD_PREFIX)-g++ \\\n LD=$(TOOLCHAIN_ARM_V7A_HARD_PREFIX)-ld \\\n AR=$(TOOLCHAIN_ARM_V7A_HARD_PREFIX)-ar \\\n RANLIB=$(TOOLCHAIN_ARM_V7A_HARD_PREFIX)-ranlib \\\n STRIP=$(TOOLCHAIN_ARM_V7A_HARD_PREFIX)-strip \\\n ARCH_FLAGS=\"$(TOOLCHAIN_ARM_V7A_HARD_FLAGS)\" \\\n ARCH_LINK=\"$(TOOLCHAIN_ARM_V7A_HARD_LINK)\" \\\n CPPFLAGS=\"-I. $(TOOLCHAIN_ARM_V7A_HARD_FLAGS) -I$(TOOLCHAIN_ARM_V7A_HARD_PLATFORM_HEADERS) -fpic -ffunction-sections -funwind-tables -fstack-protector -fno-strict-aliasing -finline-limit=64\" \\\n CXXFLAGS=\"-I. $(TOOLCHAIN_ARM_V7A_HARD_FLAGS) -I$(TOOLCHAIN_ARM_V7A_HARD_PLATFORM_HEADERS) -fpic -ffunction-sections -funwind-tables -fstack-protector -fno-strict-aliasing -finline-limit=64 -frtti -fexceptions\" \\\n CFLAGS=\"-I. $(TOOLCHAIN_ARM_V7A_HARD_FLAGS) -I$(TOOLCHAIN_ARM_V7A_HARD_PLATFORM_HEADERS) -fpic -ffunction-sections -funwind-tables -fstack-protector -fno-strict-aliasing -finline-limit=64\" \\\n LDFLAGS=\"$(TOOLCHAIN_ARM_V7A_HARD_LINK)\" \\\n PATH=\"$(shell pwd)/$(TOOLCHAIN_ARM_V7A_HARD)/bin:$$PATH\"\n# arm64-v8a\nTOOLCHAIN_ARM64_V8A_ENV = \\\n ANDROID_DEV=\"$(shell pwd)/$(TOOLCHAIN_ARM64_V8A)/bin\" \\\n CC=$(TOOLCHAIN_ARM64_V8A_PREFIX)-gcc \\\n CXX=$(TOOLCHAIN_ARM64_V8A_PREFIX)-g++ \\\n LINK=$(TOOLCHAIN_ARM64_V8A_PREFIX)-g++ \\\n LD=$(TOOLCHAIN_ARM64_V8A_PREFIX)-ld \\\n AR=$(TOOLCHAIN_ARM64_V8A_PREFIX)-ar \\\n RANLIB=$(TOOLCHAIN_ARM64_V8A_PREFIX)-ranlib \\\n STRIP=$(TOOLCHAIN_ARM64_V8A_PREFIX)-strip \\\n ARCH_FLAGS=\"$(TOOLCHAIN_ARM64_V8A_FLAGS)\" \\\n ARCH_LINK=\"$(TOOLCHAIN_ARM64_V8A_LINK)\" \\\n CPPFLAGS=\"-I. $(TOOLCHAIN_ARM64_V8A_FLAGS) -I$(TOOLCHAIN_ARM64_V8A_PLATFORM_HEADERS) -fpic -ffunction-sections -funwind-tables -fstack-protector -fno-strict-aliasing -finline-limit=64\" \\\n CXXFLAGS=\"-I. $(TOOLCHAIN_ARM64_V8A_FLAGS) -I$(TOOLCHAIN_ARM64_V8A_PLATFORM_HEADERS) -fpic -ffunction-sections -funwind-tables -fstack-protector -fno-strict-aliasing -finline-limit=64 -frtti -fexceptions\" \\\n CFLAGS=\"-I. $(TOOLCHAIN_ARM64_V8A_FLAGS) -I$(TOOLCHAIN_ARM64_V8A_PLATFORM_HEADERS) -fpic -ffunction-sections -funwind-tables -fstack-protector -fno-strict-aliasing -finline-limit=64\" \\\n LDFLAGS=\"$(TOOLCHAIN_ARM64_V8A_LINK)\" \\\n PATH=\"$(shell pwd)/$(TOOLCHAIN_ARM64_V8A)/bin:$$PATH\"\n# mips\nTOOLCHAIN_MIPS_ENV = \\\n ANDROID_DEV=\"$(shell pwd)/$(TOOLCHAIN_MIPS)/bin\" \\\n CC=$(TOOLCHAIN_MIPS_PREFIX)-gcc \\\n CXX=$(TOOLCHAIN_MIPS_PREFIX)-g++ \\\n LINK=$(TOOLCHAIN_MIPS_PREFIX)-g++ \\\n LD=$(TOOLCHAIN_MIPS_PREFIX)-ld \\\n AR=$(TOOLCHAIN_MIPS_PREFIX)-ar \\\n RANLIB=$(TOOLCHAIN_MIPS_PREFIX)-ranlib \\\n STRIP=$(TOOLCHAIN_MIPS_PREFIX)-strip \\\n ARCH_FLAGS=\"$(TOOLCHAIN_MIPS_FLAGS)\" \\\n ARCH_LINK=\"$(TOOLCHAIN_MIPS_LINK)\" \\\n CPPFLAGS=\"-I. $(TOOLCHAIN_MIPS_FLAGS) -I$(TOOLCHAIN_MIPS_PLATFORM_HEADERS) -fpic -ffunction-sections -funwind-tables -fstack-protector -fno-strict-aliasing -finline-limit=64\" \\\n CXXFLAGS=\"-I. $(TOOLCHAIN_MIPS_FLAGS) -I$(TOOLCHAIN_MIPS_PLATFORM_HEADERS) -fpic -ffunction-sections -funwind-tables -fstack-protector -fno-strict-aliasing -finline-limit=64 -frtti -fexceptions\" \\\n CFLAGS=\"-I. $(TOOLCHAIN_MIPS_FLAGS) -I$(TOOLCHAIN_MIPS_PLATFORM_HEADERS) -fpic -ffunction-sections -funwind-tables -fstack-protector -fno-strict-aliasing -finline-limit=64\" \\\n LDFLAGS=\"$(TOOLCHAIN_MIPS_LINK)\" \\\n PATH=\"$(shell pwd)/$(TOOLCHAIN_MIPS)/bin:$$PATH\"\n# mips64\nTOOLCHAIN_MIPS64_ENV = \\\n ANDROID_DEV=\"$(shell pwd)/$(TOOLCHAIN_MIPS64)/bin\" \\\n CC=$(TOOLCHAIN_MIPS64_PREFIX)-gcc \\\n CXX=$(TOOLCHAIN_MIPS64_PREFIX)-g++ \\\n LINK=$(TOOLCHAIN_MIPS64_PREFIX)-g++ \\\n LD=$(TOOLCHAIN_MIPS64_PREFIX)-ld \\\n AR=$(TOOLCHAIN_MIPS64_PREFIX)-ar \\\n RANLIB=$(TOOLCHAIN_MIPS64_PREFIX)-ranlib \\\n STRIP=$(TOOLCHAIN_MIPS64_PREFIX)-strip \\\n ARCH_FLAGS=\"$(TOOLCHAIN_MIPS64_FLAGS)\" \\\n ARCH_LINK=\"$(TOOLCHAIN_MIPS64_LINK)\" \\\n CPPFLAGS=\"-I. $(TOOLCHAIN_MIPS64_FLAGS) -I$(TOOLCHAIN_MIPS64_PLATFORM_HEADERS) -fpic -ffunction-sections -funwind-tables -fstack-protector -fno-strict-aliasing -finline-limit=64\" \\\n CXXFLAGS=\"-I. $(TOOLCHAIN_MIPS64_FLAGS) -I$(TOOLCHAIN_MIPS64_PLATFORM_HEADERS) -fpic -ffunction-sections -funwind-tables -fstack-protector -fno-strict-aliasing -finline-limit=64 -frtti -fexceptions\" \\\n CFLAGS=\"-I. $(TOOLCHAIN_MIPS64_FLAGS) -I$(TOOLCHAIN_MIPS64_PLATFORM_HEADERS) -fpic -ffunction-sections -funwind-tables -fstack-protector -fno-strict-aliasing -finline-limit=64\" \\\n LDFLAGS=\"$(TOOLCHAIN_MIPS64_LINK)\" \\\n PATH=\"$(shell pwd)/$(TOOLCHAIN_MIPS64)/bin:$$PATH\"\n\n#\n# All the external tools we use in this Makefile\n#\n\nAWK := awk\nCD := cd\nCMAKE := cmake\nECHO := echo\nEGREP := egrep\nGIT := git\nLN := ln\nMKDIR := mkdir\nRM := rm\nSORT := sort\nTAR := tar\nWGET := wget\n\n#\n# End of user configurable options.\n#\n\n.PHONY: \\\n all \\\n all-x86 \\\n all-x86_64 \\\n all-armeabi \\\n all-armeabi-v7a \\\n all-armeabi-v7a-hard \\\n all-arm64-v8a \\\n all-mips \\\n all-mips64 \\\n common \\\n sources \\\n toolchains \\\n toolchain-x86 \\\n toolchain-x86_64 \\\n toolchain-armeabi \\\n toolchain-armeabi-v7a \\\n toolchain-armeabi-v7a-hard \\\n toolchain-arm64-v8a \\\n toolchain-mips \\\n toolchain-mips64 \\\n zlib \\\n zlib-x86 \\\n zlib-x86_64 \\\n zlib-armeabi \\\n zlib-armeabi-v7a \\\n zlib-armeabi-v7a-hard \\\n zlib-arm64-v8a \\\n zlib-mips \\\n zlib-mips64 \\\n openssl \\\n openssl-x86 \\\n openssl-x86_64 \\\n openssl-armeabi \\\n openssl-armeabi-v7a \\\n openssl-armeabi-v7a-hard \\\n openssl-arm64-v8a \\\n openssl-mips \\\n openssl-mips64 \\\n libwebsockets \\\n libwebsockets-x86 \\\n libwebsockets-x86_64 \\\n libwebsockets-armeabi \\\n libwebsockets-armeabi-v7a \\\n libwebsockets-armeabi-v7a-hard \\\n libwebsockets-arm64-v8a \\\n libwebsockets-mips \\\n libwebsockets-mips64 \\\n clean-ndk \\\n clean \\\n dist-clean \\\n clean-targets \\\n clean-target-x86 \\\n clean-target-x86_64 \\\n clean-target-armeabi \\\n clean-target-armeabi-v7a \\\n clean-target-armeabi-v7a-hard \\\n clean-target-arm64-v8a \\\n clean-target-mips \\\n clean-target-mips64 \\\n clean-sources \\\n clean-source-zlib \\\n clean-source-openssl \\\n clean-source-libwebsockets \\\n clean-toolchains \\\n clean-toolchain-x86 \\\n clean-toolchain-x86_64 \\\n clean-toolchain-armeabi \\\n clean-toolchain-armeabi-v7a \\\n clean-toolchain-armeabi-v7a-hard \\\n clean-toolchain-arm64-v8a \\\n clean-toolchain-mips \\\n clean-toolchain-mips64 \\\n list-targets\n\n# Default rule: build the libraries for all ABIs defined in NDK_APP_ABI then run ndk-build\nall: $(NDK_APP_ABI)\n\t$(NDK_ROOT)/ndk-build clean\n\t$(NDK_ROOT)/ndk-build\n\n# Libraries may also be build per ABI\nall-x86: $(TARGET_X86)\nall-x86_64: $(TARGET_X86_64)\nall-armeabi: $(TARGET_ARM)\nall-armeabi-v7a: $(TARGET_ARM_V7A)\nall-armeabi-v7a-hard: $(TARGET_ARM_V7A_HARD)\nall-arm64-v8a: $(TARGET_ARM64_V8A)\nall-mips: $(TARGET_MIPS)\nall-mips64: $(TARGET_MIPS64)\n\n# Common rule all targets depend on\ncommon: ../jniLibs\n\n# These rules are called from Android.mk when executing ndk-build\n$(TARGET_X86): common zlib-x86 openssl-x86 libwebsockets-x86\n$(TARGET_X86_64): common zlib-x86_64 openssl-x86_64 libwebsockets-x86_64\n$(TARGET_ARM): common zlib-armeabi openssl-armeabi libwebsockets-armeabi\n$(TARGET_ARM_V7A): common zlib-armeabi-v7a openssl-armeabi-v7a libwebsockets-armeabi-v7a\n$(TARGET_ARM_V7A_HARD): common zlib-armeabi-v7a-hard openssl-armeabi-v7a-hard libwebsockets-armeabi-v7a-hard\n$(TARGET_ARM64_V8A): common zlib-arm64-v8a openssl-arm64-v8a libwebsockets-arm64-v8a\n$(TARGET_MIPS): common zlib-mips openssl-mips libwebsockets-mips\n$(TARGET_MIPS64): common zlib-mips64 openssl-mips64 libwebsockets-mips64\n\n#\n# A rule to ensure ../jniLibs points to ../libs\n# (ndk-build creates ../libs but Gradle looks for ../jniLibs)\n#\n\n../libs:\n\t$(MKDIR) ../libs\n\n../jniLibs: ../libs\n\t$(CD) .. && $(LN) -s libs jniLibs\n\n#\n# Some rules to download the sources\n#\n\nsources: $(ZLIB_TGZ_SOURCE) $(OPENSSL_TGZ_SOURCE) $(LIBWEBSOCKETS_TGZ_SOURCE)\n\n$(ZLIB_TGZ_SOURCE):\n\t$(WGET) -q $(ZLIB_TGZ_URL)\n\n$(OPENSSL_TGZ_SOURCE):\n\t$(WGET) -q $(OPENSSL_TGZ_URL)\n\n$(LIBWEBSOCKETS_TGZ_SOURCE):\n\tif [ -d $(LIBWEBSOCKETS_DIR) ]; then $(RM) -fr $(LIBWEBSOCKETS_DIR); fi\n\t$(GIT) clone $(LIBWEBSOCKETS_GIT_URL)\n\t$(TAR) caf $(LIBWEBSOCKETS_TGZ_SOURCE) $(LIBWEBSOCKETS_DIR)\n\t$(RM) -fR $(LIBWEBSOCKETS_DIR)\n\n#\n# Some rules to install the required toolchains\n#\n\ntoolchains: \\\n toolchain-x86 \\\n toolchain-x86_64 \\\n toolchain-armeabi \\\n toolchain-armeabi-v7a \\\n toolchain-armeabi-v7a-hard \\\n toolchain-arm64-v8a \\\n toolchain-mips \\\n toolchain-mips64\n\ntoolchain-x86: $(TOOLCHAIN_X86)\ntoolchain-x86_64: $(TOOLCHAIN_X86_64)\ntoolchain-armeabi: $(TOOLCHAIN_ARM)\ntoolchain-armeabi-v7a: $(TOOLCHAIN_ARM_V7A)\ntoolchain-armeabi-v7a-hard: $(TOOLCHAIN_ARM_V7A_HARD)\ntoolchain-arm64-v8a: $(TOOLCHAIN_ARM64_V8A)\ntoolchain-mips: $(TOOLCHAIN_MIPS)\ntoolchain-mips64: $(TOOLCHAIN_MIPS64)\n\n$(TOOLCHAIN_X86):\nifneq ($(TOOLCHAIN_STL),)\n\t$(NDK_MAKE_TOOLCHAIN) \\\n\t  --stl $(TOOLCHAIN_STL) \\\n\t  --api $(TOOLCHAIN_X86_API) \\\n\t  --arch x86 \\\n\t  --install-dir $(shell pwd)/$(TOOLCHAIN_X86)\nelse\n\t$(NDK_MAKE_TOOLCHAIN) \\\n\t  --api $(TOOLCHAIN_X86_API) \\\n\t  --arch x86 \\\n\t  --install-dir $(shell pwd)/$(TOOLCHAIN_X86)\nendif\n\n$(TOOLCHAIN_X86_64):\nifneq ($(TOOLCHAIN_STL),)\n\t$(NDK_MAKE_TOOLCHAIN) \\\n\t  --stl $(TOOLCHAIN_STL) \\\n\t  --api $(TOOLCHAIN_X86_64_API) \\\n\t  --arch x86_64 \\\n\t  --install-dir $(shell pwd)/$(TOOLCHAIN_X86_64)\nelse\n\t$(NDK_MAKE_TOOLCHAIN) \\\n\t  --api $(TOOLCHAIN_X86_64_API) \\\n\t  --arch x86_64 \\\n\t  --install-dir $(shell pwd)/$(TOOLCHAIN_X86_64)\nendif\n\n$(TOOLCHAIN_ARM):\nifneq ($(TOOLCHAIN_STL),)\n\t$(NDK_MAKE_TOOLCHAIN) \\\n\t  --stl $(TOOLCHAIN_STL) \\\n\t  --api $(TOOLCHAIN_ARM_API) \\\n\t  --arch arm \\\n\t  --install-dir $(shell pwd)/$(TOOLCHAIN_ARM)\nelse\n\t$(NDK_MAKE_TOOLCHAIN) \\\n\t  --api $(TOOLCHAIN_ARM_API) \\\n\t  --arch arm \\\n\t  --install-dir $(shell pwd)/$(TOOLCHAIN_ARM)\nendif\n\n$(TOOLCHAIN_ARM_V7A):\nifneq ($(TOOLCHAIN_STL),)\n\t$(NDK_MAKE_TOOLCHAIN) \\\n\t  --stl $(TOOLCHAIN_STL) \\\n\t  --api $(TOOLCHAIN_ARM_V7A_API) \\\n\t  --arch arm \\\n\t  --install-dir $(shell pwd)/$(TOOLCHAIN_ARM_V7A)\nelse\n\t$(NDK_MAKE_TOOLCHAIN) \\\n\t  --api $(TOOLCHAIN_ARM_V7A_API) \\\n\t  --arch arm \\\n\t  --install-dir $(shell pwd)/$(TOOLCHAIN_ARM_V7A)\nendif\n\n$(TOOLCHAIN_ARM_V7A_HARD):\nifneq ($(TOOLCHAIN_STL),)\n\t$(NDK_MAKE_TOOLCHAIN) \\\n\t  --stl $(TOOLCHAIN_STL) \\\n\t  --api $(TOOLCHAIN_ARM_V7A_HARD_API) \\\n\t  --arch arm \\\n\t  --install-dir $(shell pwd)/$(TOOLCHAIN_ARM_V7A_HARD)\nelse\n\t$(NDK_MAKE_TOOLCHAIN) \\\n\t  --api $(TOOLCHAIN_ARM_V7A_HARD_API) \\\n\t  --arch arm \\\n\t  --install-dir $(shell pwd)/$(TOOLCHAIN_ARM_V7A_HARD)\nendif\n\n$(TOOLCHAIN_ARM64_V8A):\nifneq ($(TOOLCHAIN_STL),)\n\t$(NDK_MAKE_TOOLCHAIN) \\\n\t  --stl $(TOOLCHAIN_STL) \\\n\t  --api $(TOOLCHAIN_ARM64_V8A_API) \\\n\t  --arch arm64 \\\n\t  --install-dir $(shell pwd)/$(TOOLCHAIN_ARM64_V8A)\nelse\n\t$(NDK_MAKE_TOOLCHAIN) \\\n\t  --api $(TOOLCHAIN_ARM64_V8A_API) \\\n\t  --arch arm64 \\\n\t  --install-dir $(shell pwd)/$(TOOLCHAIN_ARM64_V8A)\nendif\n\n$(TOOLCHAIN_MIPS):\nifneq ($(TOOLCHAIN_STL),)\n\t$(NDK_MAKE_TOOLCHAIN) \\\n\t  --stl $(TOOLCHAIN_STL) \\\n\t  --api $(TOOLCHAIN_MIPS_API) \\\n\t  --arch mips \\\n\t  --install-dir $(shell pwd)/$(TOOLCHAIN_MIPS)\nelse\n\t$(NDK_MAKE_TOOLCHAIN) \\\n\t  --api $(TOOLCHAIN_MIPS_API) \\\n\t  --arch mips \\\n\t  --install-dir $(shell pwd)/$(TOOLCHAIN_MIPS)\nendif\n\n$(TOOLCHAIN_MIPS64):\nifneq ($(TOOLCHAIN_STL),)\n\t$(NDK_MAKE_TOOLCHAIN) \\\n\t  --stl $(TOOLCHAIN_STL) \\\n\t  --api $(TOOLCHAIN_MIPS64_API) \\\n\t  --arch mips64 \\\n\t  --install-dir $(shell pwd)/$(TOOLCHAIN_MIPS64)\nelse\n\t$(NDK_MAKE_TOOLCHAIN) \\\n\t  --api $(TOOLCHAIN_MIPS64_API) \\\n\t  --arch mips64 \\\n\t  --install-dir $(shell pwd)/$(TOOLCHAIN_MIPS64)\nendif\n\n#\n# Rules to build zlib\n#\n\nzlib: \\\n zlib-x86 \\\n zlib-x86_64 \\\n zlib-armeabi \\\n zlib-armeabi-v7a \\\n zlib-armeabi-v7a-hard \\\n zlib-arm64-v8a \\\n zlib-mips \\\n zlib-mips64\n\nzlib-x86: $(TARGET_X86)/lib/libz.a\nzlib-x86_64: $(TARGET_X86_64)/lib/libz.a\nzlib-armeabi: $(TARGET_ARM)/lib/libz.a\nzlib-armeabi-v7a: $(TARGET_ARM_V7A)/lib/libz.a\nzlib-armeabi-v7a-hard: $(TARGET_ARM_V7A_HARD)/lib/libz.a\nzlib-arm64-v8a: $(TARGET_ARM64_V8A)/lib/libz.a\nzlib-mips: $(TARGET_MIPS)/lib/libz.a\nzlib-mips64: $(TARGET_MIPS64)/lib/libz.a\n\n# Extracting/configuring sources\n\n$(TARGET_X86)/src/$(ZLIB_DIR): $(ZLIB_TGZ_SOURCE) $(TOOLCHAIN_X86)\n\t-$(MKDIR) -p $(TARGET_X86)/src\n\t$(TAR) xf $(ZLIB_TGZ_SOURCE) -C $(TARGET_X86)/src\n\t$(CD) $(TARGET_X86)/src/$(ZLIB_DIR) && $(TOOLCHAIN_X86_ENV) \\\n\t  ./configure --static --prefix=$(shell pwd)/$(TARGET_X86)\n\n$(TARGET_X86_64)/src/$(ZLIB_DIR): $(ZLIB_TGZ_SOURCE) $(TOOLCHAIN_X86_64)\n\t-$(MKDIR) -p $(TARGET_X86_64)/src\n\t$(TAR) xf $(ZLIB_TGZ_SOURCE) -C $(TARGET_X86_64)/src\n\t$(CD) $(TARGET_X86_64)/src/$(ZLIB_DIR) && $(TOOLCHAIN_X86_64_ENV) \\\n\t  ./configure --static --prefix=$(shell pwd)/$(TARGET_X86_64)\n\n$(TARGET_ARM)/src/$(ZLIB_DIR): $(ZLIB_TGZ_SOURCE) $(TOOLCHAIN_ARM)\n\t-$(MKDIR) -p $(TARGET_ARM)/src\n\t$(TAR) xf $(ZLIB_TGZ_SOURCE) -C $(TARGET_ARM)/src\n\t$(CD) $(TARGET_ARM)/src/$(ZLIB_DIR) && $(TOOLCHAIN_ARM_ENV) \\\n\t  ./configure --static --prefix=$(shell pwd)/$(TARGET_ARM)\n\n$(TARGET_ARM_V7A)/src/$(ZLIB_DIR): $(ZLIB_TGZ_SOURCE) $(TOOLCHAIN_ARM_V7A)\n\t-$(MKDIR) -p $(TARGET_ARM_V7A)/src\n\t$(TAR) xf $(ZLIB_TGZ_SOURCE) -C $(TARGET_ARM_V7A)/src\n\t$(CD) $(TARGET_ARM_V7A)/src/$(ZLIB_DIR) && $(TOOLCHAIN_ARM_V7A_ENV) \\\n\t  ./configure --static --prefix=$(shell pwd)/$(TARGET_ARM_V7A)\n\n$(TARGET_ARM_V7A_HARD)/src/$(ZLIB_DIR): $(ZLIB_TGZ_SOURCE) $(TOOLCHAIN_ARM_V7A_HARD)\n\t-$(MKDIR) -p $(TARGET_ARM_V7A_HARD)/src\n\t$(TAR) xf $(ZLIB_TGZ_SOURCE) -C $(TARGET_ARM_V7A_HARD)/src\n\t$(CD) $(TARGET_ARM_V7A_HARD)/src/$(ZLIB_DIR) && $(TOOLCHAIN_ARM_V7A_HARD_ENV) \\\n\t  ./configure --static --prefix=$(shell pwd)/$(TARGET_ARM_V7A_HARD)\n\n$(TARGET_ARM64_V8A)/src/$(ZLIB_DIR): $(ZLIB_TGZ_SOURCE) $(TOOLCHAIN_ARM64_V8A)\n\t-$(MKDIR) -p $(TARGET_ARM64_V8A)/src\n\t$(TAR) xf $(ZLIB_TGZ_SOURCE) -C $(TARGET_ARM64_V8A)/src\n\t$(CD) $(TARGET_ARM64_V8A)/src/$(ZLIB_DIR) && $(TOOLCHAIN_ARM64_V8A_ENV) \\\n\t  ./configure --static --prefix=$(shell pwd)/$(TARGET_ARM64_V8A)\n\n$(TARGET_MIPS)/src/$(ZLIB_DIR): $(ZLIB_TGZ_SOURCE) $(TOOLCHAIN_MIPS)\n\t-$(MKDIR) -p $(TARGET_MIPS)/src\n\t$(TAR) xf $(ZLIB_TGZ_SOURCE) -C $(TARGET_MIPS)/src\n\t$(CD) $(TARGET_MIPS)/src/$(ZLIB_DIR) && $(TOOLCHAIN_MIPS_ENV) \\\n\t  ./configure --static --prefix=$(shell pwd)/$(TARGET_MIPS)\n\n$(TARGET_MIPS64)/src/$(ZLIB_DIR): $(ZLIB_TGZ_SOURCE) $(TOOLCHAIN_MIPS64)\n\t-$(MKDIR) -p $(TARGET_MIPS64)/src\n\t$(TAR) xf $(ZLIB_TGZ_SOURCE) -C $(TARGET_MIPS64)/src\n\t$(CD) $(TARGET_MIPS64)/src/$(ZLIB_DIR) && $(TOOLCHAIN_MIPS64_ENV) \\\n\t  ./configure --static --prefix=$(shell pwd)/$(TARGET_MIPS64)\n\n# Build/install library\n\n$(TARGET_X86)/lib/libz.a: $(TARGET_X86)/src/$(ZLIB_DIR)\n\t$(CD) $(TARGET_X86)/src/$(ZLIB_DIR) && $(TOOLCHAIN_X86_ENV) $(MAKE) libz.a\n\t$(CD) $(TARGET_X86)/src/$(ZLIB_DIR) && $(TOOLCHAIN_X86_ENV) $(MAKE) install\n\n$(TARGET_X86_64)/lib/libz.a: $(TARGET_X86_64)/src/$(ZLIB_DIR)\n\t$(CD) $(TARGET_X86_64)/src/$(ZLIB_DIR) && $(TOOLCHAIN_X86_64_ENV) $(MAKE) libz.a\n\t$(CD) $(TARGET_X86_64)/src/$(ZLIB_DIR) && $(TOOLCHAIN_X86_64_ENV) $(MAKE) install\n\n$(TARGET_ARM)/lib/libz.a: $(TARGET_ARM)/src/$(ZLIB_DIR)\n\t$(CD) $(TARGET_ARM)/src/$(ZLIB_DIR) && $(TOOLCHAIN_ARM_ENV) $(MAKE) libz.a\n\t$(CD) $(TARGET_ARM)/src/$(ZLIB_DIR) && $(TOOLCHAIN_ARM_ENV) $(MAKE) install\n\n$(TARGET_ARM_V7A)/lib/libz.a: $(TARGET_ARM_V7A)/src/$(ZLIB_DIR)\n\t$(CD) $(TARGET_ARM_V7A)/src/$(ZLIB_DIR) && $(TOOLCHAIN_ARM_V7A_ENV) $(MAKE) libz.a\n\t$(CD) $(TARGET_ARM_V7A)/src/$(ZLIB_DIR) && $(TOOLCHAIN_ARM_V7A_ENV) $(MAKE) install\n\n$(TARGET_ARM_V7A_HARD)/lib/libz.a: $(TARGET_ARM_V7A_HARD)/src/$(ZLIB_DIR)\n\t$(CD) $(TARGET_ARM_V7A_HARD)/src/$(ZLIB_DIR) && $(TOOLCHAIN_ARM_V7A_HARD_ENV) $(MAKE) libz.a\n\t$(CD) $(TARGET_ARM_V7A_HARD)/src/$(ZLIB_DIR) && $(TOOLCHAIN_ARM_V7A_HARD_ENV) $(MAKE) install\n\n$(TARGET_ARM64_V8A)/lib/libz.a: $(TARGET_ARM64_V8A)/src/$(ZLIB_DIR)\n\t$(CD) $(TARGET_ARM64_V8A)/src/$(ZLIB_DIR) && $(TOOLCHAIN_ARM64_V8A_ENV) $(MAKE) libz.a\n\t$(CD) $(TARGET_ARM64_V8A)/src/$(ZLIB_DIR) && $(TOOLCHAIN_ARM64_V8A_ENV) $(MAKE) install\n\n$(TARGET_MIPS)/lib/libz.a: $(TARGET_MIPS)/src/$(ZLIB_DIR)\n\t$(CD) $(TARGET_MIPS)/src/$(ZLIB_DIR) && $(TOOLCHAIN_MIPS_ENV) $(MAKE) libz.a\n\t$(CD) $(TARGET_MIPS)/src/$(ZLIB_DIR) && $(TOOLCHAIN_MIPS_ENV) $(MAKE) install\n\n$(TARGET_MIPS64)/lib/libz.a: $(TARGET_MIPS64)/src/$(ZLIB_DIR)\n\t$(CD) $(TARGET_MIPS64)/src/$(ZLIB_DIR) && $(TOOLCHAIN_MIPS64_ENV) $(MAKE) libz.a\n\t$(CD) $(TARGET_MIPS64)/src/$(ZLIB_DIR) && $(TOOLCHAIN_MIPS64_ENV) $(MAKE) install\n\n#\n# Rules to build OpenSSL\n#\n\nopenssl: \\\n openssl-x86 \\\n openssl-x86_64 \\\n openssl-armeabi \\\n openssl-armeabi-v7a \\\n openssl-armeabi-v7a-hard \\\n openssl-arm64-v8a \\\n openssl-mips \\\n openssl-mips64\n\nopenssl-x86: $(TARGET_X86)/lib/libssl.a\nopenssl-x86_64: $(TARGET_X86_64)/lib/libssl.a\nopenssl-armeabi: $(TARGET_ARM)/lib/libssl.a\nopenssl-armeabi-v7a: $(TARGET_ARM_V7A)/lib/libssl.a\nopenssl-armeabi-v7a-hard: $(TARGET_ARM_V7A_HARD)/lib/libssl.a\nopenssl-arm64-v8a: $(TARGET_ARM64_V8A)/lib/libssl.a\nopenssl-mips: $(TARGET_MIPS)/lib/libssl.a\nopenssl-mips64: $(TARGET_MIPS64)/lib/libssl.a\n\n# Extracting/configuring sources\n\n$(TARGET_X86)/src/$(OPENSSL_DIR): $(OPENSSL_TGZ_SOURCE) $(TOOLCHAIN_X86)\n\t-$(MKDIR) -p $(TARGET_X86)/src\n\t$(TAR) xf $(OPENSSL_TGZ_SOURCE) -C $(TARGET_X86)/src\n\t$(CD) $(TARGET_X86)/src/$(OPENSSL_DIR) && $(TOOLCHAIN_X86_ENV) \\\n\t  ./Configure $(TARGET_X86_OPENSSL_CONFIG_TARGET) \\\n\t    --prefix=$(shell pwd)/$(TARGET_X86) \\\n\t    --openssldir=$(shell pwd)/$(TARGET_X86)/lib/ssl \\\n\t    $(TARGET_X86_OPENSSL_CONFIG)\n\n$(TARGET_X86_64)/src/$(OPENSSL_DIR): $(OPENSSL_TGZ_SOURCE) $(TOOLCHAIN_X86_64)\n\t-$(MKDIR) -p $(TARGET_X86_64)/src\n\t$(TAR) xf $(OPENSSL_TGZ_SOURCE) -C $(TARGET_X86_64)/src\n\t$(CD) $(TARGET_X86_64)/src/$(OPENSSL_DIR) && $(TOOLCHAIN_X86_64_ENV) \\\n\t  ./Configure $(TARGET_X86_64_OPENSSL_CONFIG_TARGET) \\\n\t    --prefix=$(shell pwd)/$(TARGET_X86_64) \\\n\t    --openssldir=$(shell pwd)/$(TARGET_X86_64)/lib/ssl \\\n\t    $(TARGET_X86_64_OPENSSL_CONFIG)\n\n$(TARGET_ARM)/src/$(OPENSSL_DIR): $(OPENSSL_TGZ_SOURCE) $(TOOLCHAIN_ARM)\n\t-$(MKDIR) -p $(TARGET_ARM)/src\n\t$(TAR) xf $(OPENSSL_TGZ_SOURCE) -C $(TARGET_ARM)/src\n\t$(CD) $(TARGET_ARM)/src/$(OPENSSL_DIR) && $(TOOLCHAIN_ARM_ENV) \\\n\t  ./Configure $(TARGET_ARM_OPENSSL_CONFIG_TARGET) \\\n\t    --prefix=$(shell pwd)/$(TARGET_ARM) \\\n\t    --openssldir=$(shell pwd)/$(TARGET_ARM)/lib/ssl \\\n\t    $(TARGET_ARM_OPENSSL_CONFIG)\n\n$(TARGET_ARM_V7A)/src/$(OPENSSL_DIR): $(OPENSSL_TGZ_SOURCE) $(TOOLCHAIN_ARM_V7A)\n\t-$(MKDIR) -p $(TARGET_ARM_V7A)/src\n\t$(TAR) xf $(OPENSSL_TGZ_SOURCE) -C $(TARGET_ARM_V7A)/src\n\t$(CD) $(TARGET_ARM_V7A)/src/$(OPENSSL_DIR) && $(TOOLCHAIN_ARM_V7A_ENV) \\\n\t  ./Configure $(TARGET_ARM_V7A_OPENSSL_CONFIG_TARGET) \\\n\t    --prefix=$(shell pwd)/$(TARGET_ARM_V7A) \\\n\t    --openssldir=$(shell pwd)/$(TARGET_ARM_V7A)/lib/ssl \\\n\t    $(TARGET_ARM_V7A_OPENSSL_CONFIG)\n\n$(TARGET_ARM_V7A_HARD)/src/$(OPENSSL_DIR): $(OPENSSL_TGZ_SOURCE) $(TOOLCHAIN_ARM_V7A_HARD)\n\t-$(MKDIR) -p $(TARGET_ARM_V7A_HARD)/src\n\t$(TAR) xf $(OPENSSL_TGZ_SOURCE) -C $(TARGET_ARM_V7A_HARD)/src\n\t$(CD) $(TARGET_ARM_V7A_HARD)/src/$(OPENSSL_DIR) && $(TOOLCHAIN_ARM_V7A_HARD_ENV) \\\n\t  ./Configure $(TARGET_ARM_V7A_HARD_OPENSSL_CONFIG_TARGET) \\\n\t    --prefix=$(shell pwd)/$(TARGET_ARM_V7A_HARD) \\\n\t    --openssldir=$(shell pwd)/$(TARGET_ARM_V7A_HARD)/lib/ssl \\\n\t    $(TARGET_ARM_V7A_HARD_OPENSSL_CONFIG)\n\n$(TARGET_ARM64_V8A)/src/$(OPENSSL_DIR): $(OPENSSL_TGZ_SOURCE) $(TOOLCHAIN_ARM64_V8A)\n\t-$(MKDIR) -p $(TARGET_ARM64_V8A)/src\n\t$(TAR) xf $(OPENSSL_TGZ_SOURCE) -C $(TARGET_ARM64_V8A)/src\n\t$(CD) $(TARGET_ARM64_V8A)/src/$(OPENSSL_DIR) && $(TOOLCHAIN_ARM64_V8A_ENV) \\\n\t  ./Configure $(TARGET_ARM64_V8A_OPENSSL_CONFIG_TARGET) \\\n\t    --prefix=$(shell pwd)/$(TARGET_ARM64_V8A) \\\n\t    --openssldir=$(shell pwd)/$(TARGET_ARM64_V8A)/lib/ssl \\\n\t    $(TARGET_ARM64_V8A_OPENSSL_CONFIG)\n\n$(TARGET_MIPS)/src/$(OPENSSL_DIR): $(OPENSSL_TGZ_SOURCE) $(TOOLCHAIN_MIPS)\n\t-$(MKDIR) -p $(TARGET_MIPS)/src\n\t$(TAR) xf $(OPENSSL_TGZ_SOURCE) -C $(TARGET_MIPS)/src\n\t$(CD) $(TARGET_MIPS)/src/$(OPENSSL_DIR) && $(TOOLCHAIN_MIPS_ENV) \\\n\t  ./Configure $(TARGET_MIPS_OPENSSL_CONFIG_TARGET) \\\n\t    --prefix=$(shell pwd)/$(TARGET_MIPS) \\\n\t    --openssldir=$(shell pwd)/$(TARGET_MIPS)/lib/ssl \\\n\t    $(TARGET_MIPS_OPENSSL_CONFIG)\n\n$(TARGET_MIPS64)/src/$(OPENSSL_DIR): $(OPENSSL_TGZ_SOURCE) $(TOOLCHAIN_MIPS64)\n\t-$(MKDIR) -p $(TARGET_MIPS64)/src\n\t$(TAR) xf $(OPENSSL_TGZ_SOURCE) -C $(TARGET_MIPS64)/src\n\t$(CD) $(TARGET_MIPS64)/src/$(OPENSSL_DIR) && $(TOOLCHAIN_MIPS64_ENV) \\\n\t  ./Configure $(TARGET_MIPS64_OPENSSL_CONFIG_TARGET) \\\n\t    --prefix=$(shell pwd)/$(TARGET_MIPS64) \\\n\t    --openssldir=$(shell pwd)/$(TARGET_MIPS64)/lib/ssl \\\n\t    $(TARGET_MIPS64_OPENSSL_CONFIG)\n\n# Build/install library\n\n$(TARGET_X86)/lib/libssl.a: $(TARGET_X86)/src/$(OPENSSL_DIR)\n\t$(CD) $(TARGET_X86)/src/$(OPENSSL_DIR) && $(TOOLCHAIN_X86_ENV) $(MAKE) depend\n\t$(CD) $(TARGET_X86)/src/$(OPENSSL_DIR) && $(TOOLCHAIN_X86_ENV) $(MAKE) build_libs\n\t$(CD) $(TARGET_X86)/src/$(OPENSSL_DIR) && $(ECHO) '#!/bin/sh\\n\\nfalse\\n' > apps/openssl\n\t$(CD) $(TARGET_X86)/src/$(OPENSSL_DIR) && $(TOOLCHAIN_X86_ENV) $(MAKE) install_sw\n\n$(TARGET_X86_64)/lib/libssl.a: $(TARGET_X86_64)/src/$(OPENSSL_DIR)\n\t$(CD) $(TARGET_X86_64)/src/$(OPENSSL_DIR) && $(TOOLCHAIN_X86_64_ENV) $(MAKE) depend\n\t$(CD) $(TARGET_X86_64)/src/$(OPENSSL_DIR) && $(TOOLCHAIN_X86_64_ENV) $(MAKE) build_libs\n\t$(CD) $(TARGET_X86_64)/src/$(OPENSSL_DIR) && $(ECHO) '#!/bin/sh\\n\\nfalse\\n' > apps/openssl\n\t$(CD) $(TARGET_X86_64)/src/$(OPENSSL_DIR) && $(TOOLCHAIN_X86_64_ENV) $(MAKE) install_sw\n\n$(TARGET_ARM)/lib/libssl.a: $(TARGET_ARM)/src/$(OPENSSL_DIR)\n\t$(CD) $(TARGET_ARM)/src/$(OPENSSL_DIR) && $(TOOLCHAIN_ARM_ENV) $(MAKE) depend\n\t$(CD) $(TARGET_ARM)/src/$(OPENSSL_DIR) && $(TOOLCHAIN_ARM_ENV) $(MAKE) build_libs\n\t$(CD) $(TARGET_ARM)/src/$(OPENSSL_DIR) && $(ECHO) '#!/bin/sh\\n\\nfalse\\n' > apps/openssl\n\t$(CD) $(TARGET_ARM)/src/$(OPENSSL_DIR) && $(TOOLCHAIN_ARM_ENV) $(MAKE) install_sw\n\n$(TARGET_ARM_V7A)/lib/libssl.a: $(TARGET_ARM_V7A)/src/$(OPENSSL_DIR)\n\t$(CD) $(TARGET_ARM_V7A)/src/$(OPENSSL_DIR) && $(TOOLCHAIN_ARM_V7A_ENV) $(MAKE) depend\n\t$(CD) $(TARGET_ARM_V7A)/src/$(OPENSSL_DIR) && $(TOOLCHAIN_ARM_V7A_ENV) $(MAKE) build_libs\n\t$(CD) $(TARGET_ARM_V7A)/src/$(OPENSSL_DIR) && $(ECHO) '#!/bin/sh\\n\\nfalse\\n' > apps/openssl\n\t$(CD) $(TARGET_ARM_V7A)/src/$(OPENSSL_DIR) && $(TOOLCHAIN_ARM_V7A_ENV) $(MAKE) install_sw\n\n$(TARGET_ARM_V7A_HARD)/lib/libssl.a: $(TARGET_ARM_V7A_HARD)/src/$(OPENSSL_DIR)\n\t$(CD) $(TARGET_ARM_V7A_HARD)/src/$(OPENSSL_DIR) && $(TOOLCHAIN_ARM_V7A_HARD_ENV) $(MAKE) depend\n\t$(CD) $(TARGET_ARM_V7A_HARD)/src/$(OPENSSL_DIR) && $(TOOLCHAIN_ARM_V7A_HARD_ENV) $(MAKE) build_libs\n\t$(CD) $(TARGET_ARM_V7A_HARD)/src/$(OPENSSL_DIR) && $(ECHO) '#!/bin/sh\\n\\nfalse\\n' > apps/openssl\n\t$(CD) $(TARGET_ARM_V7A_HARD)/src/$(OPENSSL_DIR) && $(TOOLCHAIN_ARM_V7A_HARD_ENV) $(MAKE) install_sw\n\n$(TARGET_ARM64_V8A)/lib/libssl.a: $(TARGET_ARM64_V8A)/src/$(OPENSSL_DIR)\n\t$(CD) $(TARGET_ARM64_V8A)/src/$(OPENSSL_DIR) && $(TOOLCHAIN_ARM64_V8A_ENV) $(MAKE) depend\n\t$(CD) $(TARGET_ARM64_V8A)/src/$(OPENSSL_DIR) && $(TOOLCHAIN_ARM64_V8A_ENV) $(MAKE) build_libs\n\t$(CD) $(TARGET_ARM64_V8A)/src/$(OPENSSL_DIR) && $(ECHO) '#!/bin/sh\\n\\nfalse\\n' > apps/openssl\n\t$(CD) $(TARGET_ARM64_V8A)/src/$(OPENSSL_DIR) && $(TOOLCHAIN_ARM64_V8A_ENV) $(MAKE) install_sw\n\n$(TARGET_MIPS)/lib/libssl.a: $(TARGET_MIPS)/src/$(OPENSSL_DIR)\n\t$(CD) $(TARGET_MIPS)/src/$(OPENSSL_DIR) && $(TOOLCHAIN_MIPS_ENV) $(MAKE) depend\n\t$(CD) $(TARGET_MIPS)/src/$(OPENSSL_DIR) && $(TOOLCHAIN_MIPS_ENV) $(MAKE) build_libs\n\t$(CD) $(TARGET_MIPS)/src/$(OPENSSL_DIR) && $(ECHO) '#!/bin/sh\\n\\nfalse\\n' > apps/openssl\n\t$(CD) $(TARGET_MIPS)/src/$(OPENSSL_DIR) && $(TOOLCHAIN_MIPS_ENV) $(MAKE) install_sw\n\n$(TARGET_MIPS64)/lib/libssl.a: $(TARGET_MIPS64)/src/$(OPENSSL_DIR)\n\t$(CD) $(TARGET_MIPS64)/src/$(OPENSSL_DIR) && $(TOOLCHAIN_MIPS64_ENV) $(MAKE) depend\n\t$(CD) $(TARGET_MIPS64)/src/$(OPENSSL_DIR) && $(TOOLCHAIN_MIPS64_ENV) $(MAKE) build_libs\n\t$(CD) $(TARGET_MIPS64)/src/$(OPENSSL_DIR) && $(ECHO) '#!/bin/sh\\n\\nfalse\\n' > apps/openssl\n\t$(CD) $(TARGET_MIPS64)/src/$(OPENSSL_DIR) && $(TOOLCHAIN_MIPS64_ENV) $(MAKE) install_sw\n\n#\n# Rules to build libwebsockets\n#\n\nlibwebsockets: \\\n libwebsockets-x86 \\\n libwebsockets-x86_64 \\\n libwebsockets-armeabi \\\n libwebsockets-armeabi-v7a \\\n libwebsockets-armeabi-v7a-hard \\\n libwebsockets-arm64-v8a \\\n libwebsockets-mips \\\n libwebsockets-mips64 \\\n\nlibwebsockets-x86: $(TARGET_X86)/lib/libwebsockets.a\nlibwebsockets-x86_64: $(TARGET_X86_64)/lib/libwebsockets.a\nlibwebsockets-armeabi: $(TARGET_ARM)/lib/libwebsockets.a\nlibwebsockets-armeabi-v7a: $(TARGET_ARM_V7A)/lib/libwebsockets.a\nlibwebsockets-armeabi-v7a-hard: $(TARGET_ARM_V7A_HARD)/lib/libwebsockets.a\nlibwebsockets-arm64-v8a: $(TARGET_ARM64_V8A)/lib/libwebsockets.a\nlibwebsockets-mips: $(TARGET_MIPS)/lib/libwebsockets.a\nlibwebsockets-mips64: $(TARGET_MIPS64)/lib/libwebsockets.a\n\n# Extracting/configuring sources\n\n$(TARGET_X86)/src/$(LIBWEBSOCKETS_DIR): $(LIBWEBSOCKETS_TGZ_SOURCE) $(TOOLCHAIN_X86) $(TARGET_X86)/lib/libssl.a $(TARGET_X86)/lib/libz.a\n\t-$(MKDIR) -p $(TARGET_X86)/src\n\t$(TAR) xf $(LIBWEBSOCKETS_TGZ_SOURCE) -C $(TARGET_X86)/src\n\t-$(MKDIR) -p $(TARGET_X86)/src/$(LIBWEBSOCKETS_DIR)/build\n\t$(CD) $(TARGET_X86)/src/$(LIBWEBSOCKETS_DIR)/build && $(TOOLCHAIN_X86_ENV) \\\n\t  $(CMAKE) $(TARGET_X86_LWS_OPTIONS) \\\n\t    -DCMAKE_INSTALL_PREFIX=$(shell pwd)/$(TARGET_X86) \\\n\t    -DLWS_OPENSSL_LIBRARIES=\"$(shell pwd)/$(TARGET_X86)/lib/libssl.a;$(shell pwd)/$(TARGET_X86)/lib/libcrypto.a\" \\\n\t    -DLWS_OPENSSL_INCLUDE_DIRS=\"$(shell pwd)/$(TARGET_X86)/include\" \\\n\t    ..\n\n$(TARGET_X86_64)/src/$(LIBWEBSOCKETS_DIR): $(LIBWEBSOCKETS_TGZ_SOURCE) $(TOOLCHAIN_X86_64) $(TARGET_X86_64)/lib/libssl.a $(TARGET_X86_64)/lib/libz.a\n\t-$(MKDIR) -p $(TARGET_X86_64)/src\n\t$(TAR) xf $(LIBWEBSOCKETS_TGZ_SOURCE) -C $(TARGET_X86_64)/src\n\t-$(MKDIR) -p $(TARGET_X86_64)/src/$(LIBWEBSOCKETS_DIR)/build\n\t$(CD) $(TARGET_X86_64)/src/$(LIBWEBSOCKETS_DIR)/build && $(TOOLCHAIN_X86_64_ENV) \\\n\t  $(CMAKE) $(TARGET_X86_64_LWS_OPTIONS) \\\n\t    -DCMAKE_INSTALL_PREFIX=$(shell pwd)/$(TARGET_X86_64) \\\n\t    -DLWS_OPENSSL_LIBRARIES=\"$(shell pwd)/$(TARGET_X86_64)/lib/libssl.a;$(shell pwd)/$(TARGET_X86_64)/lib/libcrypto.a\" \\\n\t    -DLWS_OPENSSL_INCLUDE_DIRS=\"$(shell pwd)/$(TARGET_X86_64)/include\" \\\n\t    ..\n\n$(TARGET_ARM)/src/$(LIBWEBSOCKETS_DIR): $(LIBWEBSOCKETS_TGZ_SOURCE) $(TOOLCHAIN_ARM) $(TARGET_ARM)/lib/libssl.a $(TARGET_ARM)/lib/libz.a\n\t-$(MKDIR) -p $(TARGET_ARM)/src\n\t$(TAR) xf $(LIBWEBSOCKETS_TGZ_SOURCE) -C $(TARGET_ARM)/src\n\t-$(MKDIR) -p $(TARGET_ARM)/src/$(LIBWEBSOCKETS_DIR)/build\n\t$(CD) $(TARGET_ARM)/src/$(LIBWEBSOCKETS_DIR)/build && $(TOOLCHAIN_ARM_ENV) \\\n\t  $(CMAKE) $(TARGET_ARM_LWS_OPTIONS) \\\n\t    -DCMAKE_INSTALL_PREFIX=$(shell pwd)/$(TARGET_ARM) \\\n\t    -DLWS_OPENSSL_LIBRARIES=\"$(shell pwd)/$(TARGET_ARM)/lib/libssl.a;$(shell pwd)/$(TARGET_ARM)/lib/libcrypto.a\" \\\n\t    -DLWS_OPENSSL_INCLUDE_DIRS=\"$(shell pwd)/$(TARGET_ARM)/include\" \\\n\t    ..\n\n$(TARGET_ARM_V7A)/src/$(LIBWEBSOCKETS_DIR): $(LIBWEBSOCKETS_TGZ_SOURCE) $(TOOLCHAIN_ARM_V7A) $(TARGET_ARM_V7A)/lib/libssl.a $(TARGET_ARM_V7A)/lib/libz.a\n\t-$(MKDIR) -p $(TARGET_ARM_V7A)/src\n\t$(TAR) xf $(LIBWEBSOCKETS_TGZ_SOURCE) -C $(TARGET_ARM_V7A)/src\n\t-$(MKDIR) -p $(TARGET_ARM_V7A)/src/$(LIBWEBSOCKETS_DIR)/build\n\t$(CD) $(TARGET_ARM_V7A)/src/$(LIBWEBSOCKETS_DIR)/build && $(TOOLCHAIN_ARM_V7A_ENV) \\\n\t  $(CMAKE) $(TARGET_ARM_V7A_LWS_OPTIONS) \\\n\t    -DCMAKE_INSTALL_PREFIX=$(shell pwd)/$(TARGET_ARM_V7A) \\\n\t    -DLWS_OPENSSL_LIBRARIES=\"$(shell pwd)/$(TARGET_ARM_V7A)/lib/libssl.a;$(shell pwd)/$(TARGET_ARM_V7A)/lib/libcrypto.a\" \\\n\t    -DLWS_OPENSSL_INCLUDE_DIRS=\"$(shell pwd)/$(TARGET_ARM_V7A)/include\" \\\n\t    ..\n\n$(TARGET_ARM_V7A_HARD)/src/$(LIBWEBSOCKETS_DIR): $(LIBWEBSOCKETS_TGZ_SOURCE) $(TOOLCHAIN_ARM_V7A_HARD) $(TARGET_ARM_V7A_HARD)/lib/libssl.a $(TARGET_ARM_V7A_HARD)/lib/libz.a\n\t-$(MKDIR) -p $(TARGET_ARM_V7A_HARD)/src\n\t$(TAR) xf $(LIBWEBSOCKETS_TGZ_SOURCE) -C $(TARGET_ARM_V7A_HARD)/src\n\t-$(MKDIR) -p $(TARGET_ARM_V7A_HARD)/src/$(LIBWEBSOCKETS_DIR)/build\n\t$(CD) $(TARGET_ARM_V7A_HARD)/src/$(LIBWEBSOCKETS_DIR)/build && $(TOOLCHAIN_ARM_V7A_HARD_ENV) \\\n\t  $(CMAKE) $(TARGET_ARM_V7A_HARD_LWS_OPTIONS) \\\n\t    -DCMAKE_INSTALL_PREFIX=$(shell pwd)/$(TARGET_ARM_V7A_HARD) \\\n\t    -DLWS_OPENSSL_LIBRARIES=\"$(shell pwd)/$(TARGET_ARM_V7A_HARD)/lib/libssl.a;$(shell pwd)/$(TARGET_ARM_V7A_HARD)/lib/libcrypto.a\" \\\n\t    -DLWS_OPENSSL_INCLUDE_DIRS=\"$(shell pwd)/$(TARGET_ARM_V7A_HARD)/include\" \\\n\t    ..\n\n$(TARGET_ARM64_V8A)/src/$(LIBWEBSOCKETS_DIR): $(LIBWEBSOCKETS_TGZ_SOURCE) $(TOOLCHAIN_ARM64_V8A) $(TARGET_ARM64_V8A)/lib/libssl.a $(TARGET_ARM64_V8A)/lib/libz.a\n\t-$(MKDIR) -p $(TARGET_ARM64_V8A)/src\n\t$(TAR) xf $(LIBWEBSOCKETS_TGZ_SOURCE) -C $(TARGET_ARM64_V8A)/src\n\t-$(MKDIR) -p $(TARGET_ARM64_V8A)/src/$(LIBWEBSOCKETS_DIR)/build\n\t$(CD) $(TARGET_ARM64_V8A)/src/$(LIBWEBSOCKETS_DIR)/build && $(TOOLCHAIN_ARM64_V8A_ENV) \\\n\t  $(CMAKE) $(TARGET_ARM64_V8A_LWS_OPTIONS) \\\n\t    -DCMAKE_INSTALL_PREFIX=$(shell pwd)/$(TARGET_ARM64_V8A) \\\n\t    -DLWS_OPENSSL_LIBRARIES=\"$(shell pwd)/$(TARGET_ARM64_V8A)/lib/libssl.a;$(shell pwd)/$(TARGET_ARM64_V8A)/lib/libcrypto.a\" \\\n\t    -DLWS_OPENSSL_INCLUDE_DIRS=\"$(shell pwd)/$(TARGET_ARM64_V8A)/include\" \\\n\t    ..\n\n$(TARGET_MIPS)/src/$(LIBWEBSOCKETS_DIR): $(LIBWEBSOCKETS_TGZ_SOURCE) $(TOOLCHAIN_MIPS) $(TARGET_MIPS)/lib/libssl.a $(TARGET_MIPS)/lib/libz.a\n\t-$(MKDIR) -p $(TARGET_MIPS)/src\n\t$(TAR) xf $(LIBWEBSOCKETS_TGZ_SOURCE) -C $(TARGET_MIPS)/src\n\t-$(MKDIR) -p $(TARGET_MIPS)/src/$(LIBWEBSOCKETS_DIR)/build\n\t$(CD) $(TARGET_MIPS)/src/$(LIBWEBSOCKETS_DIR)/build && $(TOOLCHAIN_MIPS_ENV) \\\n\t  $(CMAKE) $(TARGET_MIPS_LWS_OPTIONS) \\\n\t    -DCMAKE_INSTALL_PREFIX=$(shell pwd)/$(TARGET_MIPS) \\\n\t    -DLWS_OPENSSL_LIBRARIES=\"$(shell pwd)/$(TARGET_MIPS)/lib/libssl.a;$(shell pwd)/$(TARGET_MIPS)/lib/libcrypto.a\" \\\n\t    -DLWS_OPENSSL_INCLUDE_DIRS=\"$(shell pwd)/$(TARGET_MIPS)/include\" \\\n\t    ..\n\n$(TARGET_MIPS64)/src/$(LIBWEBSOCKETS_DIR): $(LIBWEBSOCKETS_TGZ_SOURCE) $(TOOLCHAIN_MIPS64) $(TARGET_MIPS64)/lib/libssl.a $(TARGET_MIPS64)/lib/libz.a\n\t-$(MKDIR) -p $(TARGET_MIPS64)/src\n\t$(TAR) xf $(LIBWEBSOCKETS_TGZ_SOURCE) -C $(TARGET_MIPS64)/src\n\t-$(MKDIR) -p $(TARGET_MIPS64)/src/$(LIBWEBSOCKETS_DIR)/build\n\t$(CD) $(TARGET_MIPS64)/src/$(LIBWEBSOCKETS_DIR)/build && $(TOOLCHAIN_MIPS64_ENV) \\\n\t  $(CMAKE) $(TARGET_MIPS64_LWS_OPTIONS) \\\n\t    -DCMAKE_INSTALL_PREFIX=$(shell pwd)/$(TARGET_MIPS64) \\\n\t    -DLWS_OPENSSL_LIBRARIES=\"$(shell pwd)/$(TARGET_MIPS64)/lib/libssl.a;$(shell pwd)/$(TARGET_MIPS64)/lib/libcrypto.a\" \\\n\t    -DLWS_OPENSSL_INCLUDE_DIRS=\"$(shell pwd)/$(TARGET_MIPS64)/include\" \\\n\t    ..\n\n# Build/install library\n\n$(TARGET_X86)/lib/libwebsockets.a: $(TARGET_X86)/src/$(LIBWEBSOCKETS_DIR)\n\t$(CD) $(TARGET_X86)/src/$(LIBWEBSOCKETS_DIR)/build && $(TOOLCHAIN_X86_ENV) $(MAKE)\n\t$(CD) $(TARGET_X86)/src/$(LIBWEBSOCKETS_DIR)/build && $(TOOLCHAIN_X86_ENV) $(MAKE) install\n\n$(TARGET_X86_64)/lib/libwebsockets.a: $(TARGET_X86_64)/src/$(LIBWEBSOCKETS_DIR)\n\t$(CD) $(TARGET_X86_64)/src/$(LIBWEBSOCKETS_DIR)/build && $(TOOLCHAIN_X86_64_ENV) $(MAKE)\n\t$(CD) $(TARGET_X86_64)/src/$(LIBWEBSOCKETS_DIR)/build && $(TOOLCHAIN_X86_64_ENV) $(MAKE) install\n\n$(TARGET_ARM)/lib/libwebsockets.a: $(TARGET_ARM)/src/$(LIBWEBSOCKETS_DIR)\n\t$(CD) $(TARGET_ARM)/src/$(LIBWEBSOCKETS_DIR)/build && $(TOOLCHAIN_ARM_ENV) $(MAKE)\n\t$(CD) $(TARGET_ARM)/src/$(LIBWEBSOCKETS_DIR)/build && $(TOOLCHAIN_ARM_ENV) $(MAKE) install\n\n$(TARGET_ARM_V7A)/lib/libwebsockets.a: $(TARGET_ARM_V7A)/src/$(LIBWEBSOCKETS_DIR)\n\t$(CD) $(TARGET_ARM_V7A)/src/$(LIBWEBSOCKETS_DIR)/build && $(TOOLCHAIN_ARM_V7A_ENV) $(MAKE)\n\t$(CD) $(TARGET_ARM_V7A)/src/$(LIBWEBSOCKETS_DIR)/build && $(TOOLCHAIN_ARM_V7A_ENV) $(MAKE) install\n\n$(TARGET_ARM_V7A_HARD)/lib/libwebsockets.a: $(TARGET_ARM_V7A_HARD)/src/$(LIBWEBSOCKETS_DIR)\n\t$(CD) $(TARGET_ARM_V7A_HARD)/src/$(LIBWEBSOCKETS_DIR)/build && $(TOOLCHAIN_ARM_V7A_HARD_ENV) $(MAKE)\n\t$(CD) $(TARGET_ARM_V7A_HARD)/src/$(LIBWEBSOCKETS_DIR)/build && $(TOOLCHAIN_ARM_V7A_HARD_ENV) $(MAKE) install\n\n$(TARGET_ARM64_V8A)/lib/libwebsockets.a: $(TARGET_ARM64_V8A)/src/$(LIBWEBSOCKETS_DIR)\n\t$(CD) $(TARGET_ARM64_V8A)/src/$(LIBWEBSOCKETS_DIR)/build && $(TOOLCHAIN_ARM64_V8A_ENV) $(MAKE)\n\t$(CD) $(TARGET_ARM64_V8A)/src/$(LIBWEBSOCKETS_DIR)/build && $(TOOLCHAIN_ARM64_V8A_ENV) $(MAKE) install\n\n$(TARGET_MIPS)/lib/libwebsockets.a: $(TARGET_MIPS)/src/$(LIBWEBSOCKETS_DIR)\n\t$(CD) $(TARGET_MIPS)/src/$(LIBWEBSOCKETS_DIR)/build && $(TOOLCHAIN_MIPS_ENV) $(MAKE)\n\t$(CD) $(TARGET_MIPS)/src/$(LIBWEBSOCKETS_DIR)/build && $(TOOLCHAIN_MIPS_ENV) $(MAKE) install\n\n$(TARGET_MIPS64)/lib/libwebsockets.a: $(TARGET_MIPS64)/src/$(LIBWEBSOCKETS_DIR)\n\t$(CD) $(TARGET_MIPS64)/src/$(LIBWEBSOCKETS_DIR)/build && $(TOOLCHAIN_MIPS64_ENV) $(MAKE)\n\t$(CD) $(TARGET_MIPS64)/src/$(LIBWEBSOCKETS_DIR)/build && $(TOOLCHAIN_MIPS64_ENV) $(MAKE) install\n\n#\n# Some rules for housekeeping\n#\n\nclean-ndk:\n\t$(NDK_ROOT)/ndk-build clean\n\nclean: clean-targets clean-toolchains\n\ndist-clean: clean clean-sources\n\nclean-targets: \\\n clean-target-x86 \\\n clean-target-x86_64 \\\n clean-target-armeabi \\\n clean-target-armeabi-v7a \\\n clean-target-armeabi-v7a-hard \\\n clean-target-arm64-v8a \\\n clean-target-mips \\\n clean-target-mips64\n\nclean-target-x86:\n\t-$(RM) -fr $(TARGET_X86)\n\nclean-target-x86_64:\n\t-$(RM) -fr $(TARGET_X86_64)\n\nclean-target-armeabi:\n\t-$(RM) -fr $(TARGET_ARM)\n\nclean-target-armeabi-v7a:\n\t-$(RM) -fr $(TARGET_ARM_V7A)\n\nclean-target-armeabi-v7a-hard:\n\t-$(RM) -fr $(TARGET_ARM_V7A_HARD)\n\nclean-target-arm64-v8a:\n\t-$(RM) -fr $(TARGET_ARM64_V8A)\n\nclean-target-mips:\n\t-$(RM) -fr $(TARGET_MIPS)\n\nclean-target-mips64:\n\t-$(RM) -fr $(TARGET_MIPS64)\n\nclean-sources: \\\n clean-source-zlib \\\n clean-source-openssl \\\n clean-source-libwebsockets\n\nclean-source-zlib:\n\t-$(RM) $(ZLIB_TGZ_SOURCE)\n\nclean-source-openssl:\n\t-$(RM) $(OPENSSL_TGZ_SOURCE)\n\nclean-source-libwebsockets:\n\t-$(RM) $(LIBWEBSOCKETS_TGZ_SOURCE)\n\nclean-toolchains: \\\n clean-toolchain-x86 \\\n clean-toolchain-x86_64 \\\n clean-toolchain-armeabi \\\n clean-toolchain-armeabi-v7a \\\n clean-toolchain-armeabi-v7a-hard \\\n clean-toolchain-arm64-v8a \\\n clean-toolchain-mips \\\n clean-toolchain-mips64\n\t-$(RM) -fr toolchains\n\nclean-toolchain-x86:\n\t-$(RM) -fr $(TOOLCHAIN_X86)\n\nclean-toolchain-x86_64:\n\t-$(RM) -fr $(TOOLCHAIN_X86_64)\n\nclean-toolchain-armeabi:\n\t-$(RM) -fr $(TOOLCHAIN_ARM)\n\nclean-toolchain-armeabi-v7a:\n\t-$(RM) -fr $(TOOLCHAIN_ARM_V7A)\n\nclean-toolchain-armeabi-v7a-hard:\n\t-$(RM) -fr $(TOOLCHAIN_ARM_V7A_HARD)\n\nclean-toolchain-arm64-v8a:\n\t-$(RM) -fr $(TOOLCHAIN_ARM64_V8A)\n\nclean-toolchain-mips:\n\t-$(RM) -fr $(TOOLCHAIN_MIPS)\n\nclean-toolchain-mips64:\n\t-$(RM) -fr $(TOOLCHAIN_MIPS64)\n\n# 'make list-targets' prints a list of all targets.\n# Thanks to: http://stackoverflow.com/questions/4219255/how-do-you-get-the-list-of-targets-in-a-makefile\n# Modified to allow us to include files in this Makefile.\nlist-targets: MAKE_NO_INCLUDES := 1\nexport MAKE_NO_INCLUDES\nlist-targets:\n\t@$(MAKE) -s list-targets-no-includes\nlist-targets-no-includes:\n\t@$(MAKE) -pRrq -f $(lastword $(MAKEFILE_LIST)) : 2>/dev/null | $(AWK) -v RS= -F: '/^# File/,/^# Finished Make data base/ {if ($$1 !~ \"^[#.]\") {print $$1}}' | $(SORT) | $(EGREP) -v -e '^[^[:alnum:]]' -e '^$@$$'\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-libwebsockets-2.1.1-wl4mcny2cwnkjjbmkopeosrtr3vocn2b/spack-src/test-server/android/app/src/main/jni/Application.mk": "#\n# Zlib, OpenSSL and libwebsockets will be downloaded automatically unless you place\n# their source .tar.gz files in the jni directory...\n#\n\n# The location of the NDK\n#\nNDK_ROOT := /opt/Android/Sdk/ndk-bundle\n\n# Update these to the latest versions before building\n#\nZLIB_VERSION := 1.2.8\nOPENSSL_VERSION := 1.0.2h\n\n# This will be executed as 'git clone $(LIBWEBSOCKETS_GIT_URL)'\n#\nLIBWEBSOCKETS_GIT_URL := --branch master https://github.com/warmcat/libwebsockets.git\n\n#\n# Note: If you build for API level 21 or higher in APP_PLATFORM,\n#       the resulting application will only run on API 21+ devices.\n#       Even if minSdkVersion has been set to a lower level!\n#       This is the result of API changes for the native signal() function.\n#       The recommended solution is to build two packages, one for API 17+ and the other for API 21+ devices.\n#       http://stackoverflow.com/questions/28740315/android-ndk-getting-java-lang-unsatisfiedlinkerror-dlopen-failed-cannot-loca\n#\n# Note: If you change the API level the JNI code must be rebuild completely.\n#       (Run 'make clean' from the app/src/main/jni directory.)\n#\nAPP_PLATFORM := android-23\n\n# Builds for armeabi armeabi-v7a x86 mips arm64-v8a x86_64 mips64\n#\n#APP_ABI := all\n\n# The same as above.\n#\n#APP_ABI := armeabi armeabi-v7a x86 mips arm64-v8a x86_64 mips64\n\n# Good enough for most current devices + x86 AVD\n#\nAPP_ABI := armeabi-v7a x86\n\n# Enable (GNU) c++11 extentions\nAPP_CPPFLAGS += -std=gnu++11\n\n# Use the GNU standard template library\nAPP_STL := gnustl_shared\n\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-libwebsockets-2.1.1-wl4mcny2cwnkjjbmkopeosrtr3vocn2b/spack-src/doc-assets/lwsgt-overview.png",
        "/tmp/vanessa/spack-stage/spack-stage-libwebsockets-2.1.1-wl4mcny2cwnkjjbmkopeosrtr3vocn2b/spack-src/plugins/lwsws-logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-libwebsockets-2.1.1-wl4mcny2cwnkjjbmkopeosrtr3vocn2b/spack-src/plugins/generic-sessions/assets/lwsgs-logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-libwebsockets-2.1.1-wl4mcny2cwnkjjbmkopeosrtr3vocn2b/spack-src/plugins/generic-sessions/assets/seats.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-libwebsockets-2.1.1-wl4mcny2cwnkjjbmkopeosrtr3vocn2b/spack-src/test-server/leaf.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-libwebsockets-2.1.1-wl4mcny2cwnkjjbmkopeosrtr3vocn2b/spack-src/test-server/favicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-libwebsockets-2.1.1-wl4mcny2cwnkjjbmkopeosrtr3vocn2b/spack-src/test-server/libwebsockets.org-logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-libwebsockets-2.1.1-wl4mcny2cwnkjjbmkopeosrtr3vocn2b/spack-src/test-server/android/app/src/main/res/mipmap-xxhdpi/ic_launcher.png",
        "/tmp/vanessa/spack-stage/spack-stage-libwebsockets-2.1.1-wl4mcny2cwnkjjbmkopeosrtr3vocn2b/spack-src/test-server/android/app/src/main/res/mipmap-xxxhdpi/ic_launcher.png",
        "/tmp/vanessa/spack-stage/spack-stage-libwebsockets-2.1.1-wl4mcny2cwnkjjbmkopeosrtr3vocn2b/spack-src/test-server/android/app/src/main/res/mipmap-hdpi/ic_launcher.png",
        "/tmp/vanessa/spack-stage/spack-stage-libwebsockets-2.1.1-wl4mcny2cwnkjjbmkopeosrtr3vocn2b/spack-src/test-server/android/app/src/main/res/mipmap-mdpi/ic_launcher.png",
        "/tmp/vanessa/spack-stage/spack-stage-libwebsockets-2.1.1-wl4mcny2cwnkjjbmkopeosrtr3vocn2b/spack-src/test-server/android/app/src/main/res/drawable/warmcat.png",
        "/tmp/vanessa/spack-stage/spack-stage-libwebsockets-2.1.1-wl4mcny2cwnkjjbmkopeosrtr3vocn2b/spack-src/test-server/android/app/src/main/res/mipmap-xhdpi/ic_launcher.png",
        "/tmp/vanessa/spack-stage/spack-stage-libwebsockets-2.1.1-wl4mcny2cwnkjjbmkopeosrtr3vocn2b/spack-src/doc/html/nav_g.png",
        "/tmp/vanessa/spack-stage/spack-stage-libwebsockets-2.1.1-wl4mcny2cwnkjjbmkopeosrtr3vocn2b/spack-src/doc/html/classlws__conn__listener.png",
        "/tmp/vanessa/spack-stage/spack-stage-libwebsockets-2.1.1-wl4mcny2cwnkjjbmkopeosrtr3vocn2b/spack-src/doc/html/splitbar.png",
        "/tmp/vanessa/spack-stage/spack-stage-libwebsockets-2.1.1-wl4mcny2cwnkjjbmkopeosrtr3vocn2b/spack-src/doc/html/tab_h.png",
        "/tmp/vanessa/spack-stage/spack-stage-libwebsockets-2.1.1-wl4mcny2cwnkjjbmkopeosrtr3vocn2b/spack-src/doc/html/tab_s.png",
        "/tmp/vanessa/spack-stage/spack-stage-libwebsockets-2.1.1-wl4mcny2cwnkjjbmkopeosrtr3vocn2b/spack-src/doc/html/tab_a.png",
        "/tmp/vanessa/spack-stage/spack-stage-libwebsockets-2.1.1-wl4mcny2cwnkjjbmkopeosrtr3vocn2b/spack-src/doc/html/lwsgt-overview.png",
        "/tmp/vanessa/spack-stage/spack-stage-libwebsockets-2.1.1-wl4mcny2cwnkjjbmkopeosrtr3vocn2b/spack-src/doc/html/folderopen.png",
        "/tmp/vanessa/spack-stage/spack-stage-libwebsockets-2.1.1-wl4mcny2cwnkjjbmkopeosrtr3vocn2b/spack-src/doc/html/sync_on.png",
        "/tmp/vanessa/spack-stage/spack-stage-libwebsockets-2.1.1-wl4mcny2cwnkjjbmkopeosrtr3vocn2b/spack-src/doc/html/nav_f.png",
        "/tmp/vanessa/spack-stage/spack-stage-libwebsockets-2.1.1-wl4mcny2cwnkjjbmkopeosrtr3vocn2b/spack-src/doc/html/folderclosed.png",
        "/tmp/vanessa/spack-stage/spack-stage-libwebsockets-2.1.1-wl4mcny2cwnkjjbmkopeosrtr3vocn2b/spack-src/doc/html/arrowdown.png",
        "/tmp/vanessa/spack-stage/spack-stage-libwebsockets-2.1.1-wl4mcny2cwnkjjbmkopeosrtr3vocn2b/spack-src/doc/html/tab_b.png",
        "/tmp/vanessa/spack-stage/spack-stage-libwebsockets-2.1.1-wl4mcny2cwnkjjbmkopeosrtr3vocn2b/spack-src/doc/html/open.png",
        "/tmp/vanessa/spack-stage/spack-stage-libwebsockets-2.1.1-wl4mcny2cwnkjjbmkopeosrtr3vocn2b/spack-src/doc/html/bdwn.png",
        "/tmp/vanessa/spack-stage/spack-stage-libwebsockets-2.1.1-wl4mcny2cwnkjjbmkopeosrtr3vocn2b/spack-src/doc/html/arrowright.png",
        "/tmp/vanessa/spack-stage/spack-stage-libwebsockets-2.1.1-wl4mcny2cwnkjjbmkopeosrtr3vocn2b/spack-src/doc/html/bc_s.png",
        "/tmp/vanessa/spack-stage/spack-stage-libwebsockets-2.1.1-wl4mcny2cwnkjjbmkopeosrtr3vocn2b/spack-src/doc/html/nav_h.png",
        "/tmp/vanessa/spack-stage/spack-stage-libwebsockets-2.1.1-wl4mcny2cwnkjjbmkopeosrtr3vocn2b/spack-src/doc/html/classlws__conn.png",
        "/tmp/vanessa/spack-stage/spack-stage-libwebsockets-2.1.1-wl4mcny2cwnkjjbmkopeosrtr3vocn2b/spack-src/doc/html/doc.png",
        "/tmp/vanessa/spack-stage/spack-stage-libwebsockets-2.1.1-wl4mcny2cwnkjjbmkopeosrtr3vocn2b/spack-src/doc/html/sync_off.png",
        "/tmp/vanessa/spack-stage/spack-stage-libwebsockets-2.1.1-wl4mcny2cwnkjjbmkopeosrtr3vocn2b/spack-src/doc/html/libwebsockets.org-logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-libwebsockets-2.1.1-wl4mcny2cwnkjjbmkopeosrtr3vocn2b/spack-src/doc/html/closed.png",
        "/tmp/vanessa/spack-stage/spack-stage-libwebsockets-2.1.1-wl4mcny2cwnkjjbmkopeosrtr3vocn2b/spack-src/doc/html/doxygen.png"
    ],
    "total_files": 400
}