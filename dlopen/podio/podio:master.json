{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-podio-master-7k2gw3k24uusvgcr3v4r6lsfxubg6dx7/spack-src/src/SIOBlock.cc": "#include \"podio/SIOBlock.h\"\n\n#include <map>\n#include <dlfcn.h>\n#include <cstdlib>\n#include <sstream>\n#include <algorithm>\n#ifdef USE_BOOST_FILESYSTEM\n #include <boost/filesystem.hpp>\n#else\n #include <filesystem>\n#endif\n\nnamespace podio {\n  void SIOCollectionIDTableBlock::read(sio::read_device& device, sio::version_type version) {\n    std::vector<std::string> names;\n    std::vector<int> ids;\n    device.data(names);\n    device.data(ids);\n    device.data(_types);\n\n    _table = new CollectionIDTable(ids, names);\n  }\n\n  void SIOCollectionIDTableBlock::write(sio::write_device& device) {\n    device.data(_table->names());\n    device.data(_table->ids());\n\n    std::vector<std::string> typeNames;\n    typeNames.reserve(_table->ids().size());\n    for (const int id : _table->ids()) {\n      CollectionBase* tmp;\n      if (!_store->get(id, tmp)) {\n        std::cerr << \"ERROR during writing of CollectionID table\" << std::endl;\n      }\n      typeNames.push_back(tmp->getValueTypeName());\n    }\n    device.data(typeNames);\n  }\n\n  template<typename MappedT>\n  void writeParamMap(sio::write_device& device, const GenericParameters::MapType<MappedT>& map) {\n    device.data((int) map.size());\n    for (const auto& [key, value] : map) {\n      device.data(key);\n      device.data(value);\n    }\n  }\n\n  template<typename MappedT>\n  void readParamMap(sio::read_device& device, GenericParameters::MapType<MappedT>& map) {\n    int size;\n    device.data(size);\n    while(size--) {\n      std::string key;\n      device.data(key);\n      std::vector<MappedT> values;\n      device.data(values);\n      map.emplace(std::move(key), std::move(values));\n    }\n  }\n\n\n  void writeGenericParameters(sio::write_device& device, const GenericParameters& params) {\n    writeParamMap(device, params.getIntMap());\n    writeParamMap(device, params.getFloatMap());\n    writeParamMap(device, params.getStringMap());\n  }\n\n  void readGenericParameters(sio::read_device& device, GenericParameters& params) {\n    readParamMap(device, params.getIntMap());\n    readParamMap(device, params.getFloatMap());\n    readParamMap(device, params.getStringMap());\n  }\n\n\n  void SIOEventMetaDataBlock::read(sio::read_device& device, sio::version_type version) {\n    readGenericParameters(device, *metadata);\n  }\n\n  void SIOEventMetaDataBlock::write(sio::write_device& device) {\n    writeGenericParameters(device, *metadata);\n  }\n\n\n  void SIONumberedMetaDataBlock::read(sio::read_device& device, sio::version_type version) {\n    int size;\n    device.data(size);\n    while(size--) {\n      int id;\n      device.data(id);\n      GenericParameters params;\n      readGenericParameters(device, params);\n\n      data->emplace(id, std::move(params));\n    }\n  }\n\n  void SIONumberedMetaDataBlock::write(sio::write_device& device) {\n    device.data((int) data->size());\n    for (const auto& [id, params] : *data) {\n      device.data(id);\n      writeGenericParameters(device, params);\n    }\n  }\n\n\n  std::shared_ptr<SIOBlock> SIOBlockFactory::createBlock(const std::string& typeStr, const std::string& name) const {\n    const auto it = _map.find(typeStr) ;\n\n    if( it != _map.end() ){\n      auto blk = std::shared_ptr<SIOBlock>(it->second->create( name ));\n      blk->createCollection() ;\n      return blk;\n    } else {\n      return nullptr;\n    }\n  }\n\n  std::shared_ptr<SIOBlock> SIOBlockFactory::createBlock(const podio::CollectionBase* col, const std::string& name) const {\n    const std::string typeStr = col->getValueTypeName() ;\n    const auto it = _map.find(typeStr) ;\n\n    if( it!= _map.end() ) {\n      auto blk = std::shared_ptr<SIOBlock>(it->second->create(name));\n      blk->setCollection( const_cast< podio::CollectionBase* > ( col ) ) ;\n      return blk;\n    } else {\n      return nullptr;\n    }\n  }\n\n\n  SIOBlockLibraryLoader::SIOBlockLibraryLoader() {\n    for (const auto& lib : getLibNames()) {\n      loadLib(lib);\n    }\n  }\n\n  void SIOBlockLibraryLoader::loadLib(const std::string& libname) {\n    if (_loadedLibs.find(libname) != _loadedLibs.end()) {\n      std::cerr << \"SIOBlocks library \\'\" << libname << \"\\' already loaded. Not loading it again\" << std::endl;\n      return;\n    }\n\n    void* libhandle = dlopen(libname.c_str(), RTLD_LAZY | RTLD_GLOBAL);\n    if (libhandle) {\n      std::cout << \"Loading SIOBlocks library \\'\" << libname << \"\\'\" << std::endl;\n      _loadedLibs.insert({libname, libhandle});\n    } else {\n      std::cerr << \"ERROR while loading SIOBlocks library \\'\" << libname << \"\\'\" << std::endl;\n    }\n  }\n\n  std::vector<std::string> SIOBlockLibraryLoader::getLibNames() {\n#ifdef USE_BOOST_FILESYSTEM\n    namespace fs = boost::filesystem;\n#else\n    namespace fs = std::filesystem;\n#endif\n    std::vector<std::string> libs;\n\n    std::string dir;\n    std::istringstream stream(std::getenv(\"LD_LIBRARY_PATH\"));\n    while(std::getline(stream, dir, ':')) {\n      if (not fs::exists(dir)) continue;\n\n      for (auto& lib : fs::directory_iterator(dir)) {\n        const auto filename = lib.path().filename().string();\n        if (filename.find(\"SioBlocks\") != std::string::npos) {\n          libs.emplace_back(std::move(filename));\n        }\n      }\n\n    }\n\n    return libs;\n  }\n\n\n  void SIOFileTOCRecord::addRecord(const std::string &name, PositionType startPos) {\n    auto it = std::find_if(m_recordMap.begin(), m_recordMap.end(),\n                           [&name](const auto& entry) { return entry.first == name; });\n\n    if (it == m_recordMap.end()) {\n      m_recordMap.push_back({name, {startPos}});\n    } else {\n      it->second.push_back(startPos);\n    }\n\n  }\n\n  size_t SIOFileTOCRecord::getNRecords(const std::string& name) const {\n    const auto it = std::find_if(m_recordMap.cbegin(), m_recordMap.cend(),\n                                 [&name](const auto& entry) { return entry.first == name; });\n    if (it != m_recordMap.cend()) {\n      return it->second.size();\n    }\n    return 0;\n  }\n\n  void SIOFileTOCRecordBlock::read(sio::read_device& device, sio::version_type version) {\n    int size;\n    device.data(size);\n    while(size--) {\n      std::string name;\n      device.data(name);\n      std::vector<SIOFileTOCRecord::PositionType> positions;\n      device.data(positions);\n\n      record->m_recordMap.emplace_back(std::move(name), std::move(positions));\n    }\n  }\n\n  void SIOFileTOCRecordBlock::write(sio::write_device& device) {\n    device.data((int) record->m_recordMap.size());\n    for (const auto& [name, positions] : record->m_recordMap) {\n      device.data(name);\n      device.data(positions);\n    }\n  }\n\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-podio-master-7k2gw3k24uusvgcr3v4r6lsfxubg6dx7/spack-src/include/podio/SIOBlock.h": "#ifndef SIOBlock_H\n#define SIOBlock_H\n\n#include <podio/CollectionBase.h>\n#include <podio/CollectionIDTable.h>\n#include <podio/GenericParameters.h>\n#include <podio/EventStore.h>\n\n#include <sio/block.h>\n#include <sio/version.h>\n#include <sio/io_device.h>\n\n#include <map>\n#include <string>\n#include <memory>\n\nnamespace podio {\n\n  template <typename devT, typename PODData>\n  void handlePODDataSIO( devT &device , PODData* data, size_t size) {\n    unsigned count =  size * sizeof(PODData) ;\n    char* dataPtr = reinterpret_cast<char*> (data) ;\n    device.data( dataPtr , count ) ;\n  }\n\n\n/// Base class for sio::block handlers used with PODIO\n  class SIOBlock: public sio::block {\n\n  public:\n\n    SIOBlock( const std::string &nam, sio::version_type vers) :\n      sio::block( nam, vers ){\n    }\n\n    podio::CollectionBase* getCollection() { return _col; }\n\n    std::string name(){ return sio::block::name() ; }\n\n    void setCollection(podio::CollectionBase* col) {\n      _col = col ;\n    }\n\n    virtual SIOBlock* create(const std::string& name) const=0 ;\n\n    // create a new collection for this block\n    virtual void createCollection() = 0;\n\n  protected:\n\n    podio::CollectionBase*  _col{} ;\n  };\n\n  /**\n   * A dedicated block for handling the I/O of the CollectionIDTable\n   */\n  class SIOCollectionIDTableBlock : public sio::block {\n  public:\n    SIOCollectionIDTableBlock() :\n      sio::block(\"CollectionIDs\", sio::version::encode_version(0, 1)) {}\n\n    SIOCollectionIDTableBlock(podio::EventStore* store) :\n      sio::block(\"CollectionIDs\", sio::version::encode_version(0, 1)),\n      _store(store), _table(store->getCollectionIDTable()) {}\n\n    virtual void read(sio::read_device& device, sio::version_type version) override;\n    virtual void write(sio::write_device& device) override;\n\n    podio::CollectionIDTable* getTable() { return _table; }\n    const std::vector<std::string>& getTypeNames() const { return _types; }\n\n  private:\n    podio::EventStore* _store{nullptr};\n    podio::CollectionIDTable* _table {nullptr};\n    std::vector<std::string> _types;\n  };\n\n\n  /**\n   * A block for handling the EventMeta data\n   */\n  class SIOEventMetaDataBlock : public sio::block {\n  public:\n    SIOEventMetaDataBlock() :\n      sio::block(\"EventMetaData\", sio::version::encode_version(0, 1)) {}\n\n    virtual void read(sio::read_device& device, sio::version_type version) override;\n    virtual void write(sio::write_device& device) override;\n\n    podio::GenericParameters* metadata{nullptr};\n  };\n\n  /**\n   * A block for handling the run and collection meta data\n   */\n  class SIONumberedMetaDataBlock : public sio::block {\n  public:\n    SIONumberedMetaDataBlock(const std::string& name) :\n      sio::block(name, sio::version::encode_version(0, 1)) {}\n\n    virtual void read(sio::read_device& device, sio::version_type version) override;\n    virtual void write(sio::write_device& device) override;\n\n    std::map<int, GenericParameters>* data{nullptr};\n  };\n\n\n/// factory for creating sio::blocks for a given type of EDM-collection\n  class SIOBlockFactory {\n  private:\n    SIOBlockFactory(){};\n\n    typedef std::map<std::string, SIOBlock*> BlockMap ;\n    BlockMap  _map ;\n  public:\n    void registerBlockForCollection(std::string type, SIOBlock* b){ _map[type] = b ; }\n\n    std::shared_ptr<SIOBlock> createBlock( const podio::CollectionBase* col, const std::string& name) const;\n\n    // return a block with a new collection (used for reading )\n    std::shared_ptr<SIOBlock> createBlock( const std::string& typeStr, const std::string& name) const;\n\n    static SIOBlockFactory& instance() {\n      static SIOBlockFactory me ;\n      return me ;\n    }\n  };\n\n\n  class SIOBlockLibraryLoader {\n  private:\n    SIOBlockLibraryLoader();\n    /**\n     * Load a library with the given name via dlopen\n     */\n    void loadLib(const std::string& libname);\n    /**\n     * Get all files that are found on LD_LIBRARY_PATH and that have \"SioBlocks\"\n     * in their name\n     */\n    static std::vector<std::string> getLibNames();\n\n    std::map<std::string, void*> _loadedLibs{};\n\n  public:\n    static SIOBlockLibraryLoader& instance() {\n      static SIOBlockLibraryLoader instance;\n      return instance;\n    }\n  };\n\n  namespace sio_helpers {\n    /// marker for showing that a TOC has been stored in the file\n    static constexpr uint32_t SIOTocMarker = 0xc001fea7;\n    /// the number of bits necessary to store the SIOTocMarker and the actual\n    /// position of the start of the SIOFileTOCRecord\n    static constexpr int SIOTocInfoSize = sizeof(uint64_t); // i.e. usually 8\n    /// The name of the TOCRecord\n    static constexpr const char* SIOTocRecordName = \"podio_SIO_TOC_Record\";\n\n    // should hopefully be enough for all practical purposes\n    using position_type = uint32_t;\n  }\n\n\n  class SIOFileTOCRecord {\n  public:\n    using PositionType = sio_helpers::position_type;\n    void addRecord(const std::string& name, PositionType startPos);\n\n    size_t getNRecords(const std::string& name) const;\n\n  private:\n    friend class SIOFileTOCRecordBlock;\n\n    using RecordListType = std::pair<std::string, std::vector<PositionType>>;\n    using MapType = std::vector<RecordListType>;\n\n    MapType m_recordMap{};\n  };\n\n  struct SIOFileTOCRecordBlock : public sio::block {\n      SIOFileTOCRecordBlock() : sio::block(sio_helpers::SIOTocRecordName, sio::version::encode_version(0, 1)) {}\n\n    virtual void read(sio::read_device& device, sio::version_type version) override;\n    virtual void write(sio::write_device& device) override;\n\n    SIOFileTOCRecord* record;\n  };\n\n} // end namespace\n#endif\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-podio-master-7k2gw3k24uusvgcr3v4r6lsfxubg6dx7/spack-src/.git/objects/pack/pack-1efeedb4df5e3044035f2f58b32a0e4017c190d7.idx",
        "/tmp/vanessa/spack-stage/spack-stage-podio-master-7k2gw3k24uusvgcr3v4r6lsfxubg6dx7/spack-src/.git/objects/pack/pack-1efeedb4df5e3044035f2f58b32a0e4017c190d7.pack"
    ],
    "total_files": 135
}