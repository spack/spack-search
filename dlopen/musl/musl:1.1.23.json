{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-musl-1.1.23-koymjxfdijnnlzhctmvcu4hzzijfegyd/spack-src/src/ldso/dlopen.c": "#include <dlfcn.h>\n#include \"dynlink.h\"\n\nstatic void *stub_dlopen(const char *file, int mode)\n{\n\t__dl_seterr(\"Dynamic loading not supported\");\n\treturn 0;\n}\n\nweak_alias(stub_dlopen, dlopen);\n",
        "/tmp/vanessa/spack-stage/spack-stage-musl-1.1.23-koymjxfdijnnlzhctmvcu4hzzijfegyd/spack-src/include/dlfcn.h": "#ifndef\t_DLFCN_H\n#define\t_DLFCN_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include <features.h>\n\n#define RTLD_LAZY   1\n#define RTLD_NOW    2\n#define RTLD_NOLOAD 4\n#define RTLD_NODELETE 4096\n#define RTLD_GLOBAL 256\n#define RTLD_LOCAL  0\n\n#define RTLD_NEXT    ((void *)-1)\n#define RTLD_DEFAULT ((void *)0)\n\n#define RTLD_DI_LINKMAP 2\n\nint    dlclose(void *);\nchar  *dlerror(void);\nvoid  *dlopen(const char *, int);\nvoid  *dlsym(void *__restrict, const char *__restrict);\n\n#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)\ntypedef struct {\n\tconst char *dli_fname;\n\tvoid *dli_fbase;\n\tconst char *dli_sname;\n\tvoid *dli_saddr;\n} Dl_info;\nint dladdr(const void *, Dl_info *);\nint dlinfo(void *, int, void *);\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-musl-1.1.23-koymjxfdijnnlzhctmvcu4hzzijfegyd/spack-src/ldso/dynlink.c": "#define _GNU_SOURCE\n#define SYSCALL_NO_TLS 1\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <stddef.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <elf.h>\n#include <sys/mman.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <link.h>\n#include <setjmp.h>\n#include <pthread.h>\n#include <ctype.h>\n#include <dlfcn.h>\n#include <semaphore.h>\n#include <sys/membarrier.h>\n#include \"pthread_impl.h\"\n#include \"libc.h\"\n#include \"dynlink.h\"\n#include \"malloc_impl.h\"\n\nstatic void error(const char *, ...);\n\n#define MAXP2(a,b) (-(-(a)&-(b)))\n#define ALIGN(x,y) ((x)+(y)-1 & -(y))\n\n#define container_of(p,t,m) ((t*)((char *)(p)-offsetof(t,m)))\n#define countof(a) ((sizeof (a))/(sizeof (a)[0]))\n\nstruct debug {\n\tint ver;\n\tvoid *head;\n\tvoid (*bp)(void);\n\tint state;\n\tvoid *base;\n};\n\nstruct td_index {\n\tsize_t args[2];\n\tstruct td_index *next;\n};\n\nstruct dso {\n#if DL_FDPIC\n\tstruct fdpic_loadmap *loadmap;\n#else\n\tunsigned char *base;\n#endif\n\tchar *name;\n\tsize_t *dynv;\n\tstruct dso *next, *prev;\n\n\tPhdr *phdr;\n\tint phnum;\n\tsize_t phentsize;\n\tSym *syms;\n\tElf_Symndx *hashtab;\n\tuint32_t *ghashtab;\n\tint16_t *versym;\n\tchar *strings;\n\tstruct dso *syms_next, *lazy_next;\n\tsize_t *lazy, lazy_cnt;\n\tunsigned char *map;\n\tsize_t map_len;\n\tdev_t dev;\n\tino_t ino;\n\tchar relocated;\n\tchar constructed;\n\tchar kernel_mapped;\n\tchar mark;\n\tchar bfs_built;\n\tchar runtime_loaded;\n\tstruct dso **deps, *needed_by;\n\tsize_t ndeps_direct;\n\tsize_t next_dep;\n\tint ctor_visitor;\n\tchar *rpath_orig, *rpath;\n\tstruct tls_module tls;\n\tsize_t tls_id;\n\tsize_t relro_start, relro_end;\n\tuintptr_t *new_dtv;\n\tunsigned char *new_tls;\n\tstruct td_index *td_index;\n\tstruct dso *fini_next;\n\tchar *shortname;\n#if DL_FDPIC\n\tunsigned char *base;\n#else\n\tstruct fdpic_loadmap *loadmap;\n#endif\n\tstruct funcdesc {\n\t\tvoid *addr;\n\t\tsize_t *got;\n\t} *funcdescs;\n\tsize_t *got;\n\tchar buf[];\n};\n\nstruct symdef {\n\tSym *sym;\n\tstruct dso *dso;\n};\n\nstatic struct builtin_tls {\n\tchar c;\n\tstruct pthread pt;\n\tvoid *space[16];\n} builtin_tls[1];\n#define MIN_TLS_ALIGN offsetof(struct builtin_tls, pt)\n\n#define ADDEND_LIMIT 4096\nstatic size_t *saved_addends, *apply_addends_to;\n\nstatic struct dso ldso;\nstatic struct dso *head, *tail, *fini_head, *syms_tail, *lazy_head;\nstatic char *env_path, *sys_path;\nstatic unsigned long long gencnt;\nstatic int runtime;\nstatic int ldd_mode;\nstatic int ldso_fail;\nstatic int noload;\nstatic int shutting_down;\nstatic jmp_buf *rtld_fail;\nstatic pthread_rwlock_t lock;\nstatic struct debug debug;\nstatic struct tls_module *tls_tail;\nstatic size_t tls_cnt, tls_offset, tls_align = MIN_TLS_ALIGN;\nstatic size_t static_tls_cnt;\nstatic pthread_mutex_t init_fini_lock;\nstatic pthread_cond_t ctor_cond;\nstatic struct dso *builtin_deps[2];\nstatic struct dso *const no_deps[1];\nstatic struct dso *builtin_ctor_queue[4];\nstatic struct dso **main_ctor_queue;\nstatic struct fdpic_loadmap *app_loadmap;\nstatic struct fdpic_dummy_loadmap app_dummy_loadmap;\n\nstruct debug *_dl_debug_addr = &debug;\n\nextern hidden int __malloc_replaced;\n\nhidden void (*const __init_array_start)(void)=0, (*const __fini_array_start)(void)=0;\n\nextern hidden void (*const __init_array_end)(void), (*const __fini_array_end)(void);\n\nweak_alias(__init_array_start, __init_array_end);\nweak_alias(__fini_array_start, __fini_array_end);\n\nstatic int dl_strcmp(const char *l, const char *r)\n{\n\tfor (; *l==*r && *l; l++, r++);\n\treturn *(unsigned char *)l - *(unsigned char *)r;\n}\n#define strcmp(l,r) dl_strcmp(l,r)\n\n/* Compute load address for a virtual address in a given dso. */\n#if DL_FDPIC\nstatic void *laddr(const struct dso *p, size_t v)\n{\n\tsize_t j=0;\n\tif (!p->loadmap) return p->base + v;\n\tfor (j=0; v-p->loadmap->segs[j].p_vaddr >= p->loadmap->segs[j].p_memsz; j++);\n\treturn (void *)(v - p->loadmap->segs[j].p_vaddr + p->loadmap->segs[j].addr);\n}\nstatic void *laddr_pg(const struct dso *p, size_t v)\n{\n\tsize_t j=0;\n\tsize_t pgsz = PAGE_SIZE;\n\tif (!p->loadmap) return p->base + v;\n\tfor (j=0; ; j++) {\n\t\tsize_t a = p->loadmap->segs[j].p_vaddr;\n\t\tsize_t b = a + p->loadmap->segs[j].p_memsz;\n\t\ta &= -pgsz;\n\t\tb += pgsz-1;\n\t\tb &= -pgsz;\n\t\tif (v-a<b-a) break;\n\t}\n\treturn (void *)(v - p->loadmap->segs[j].p_vaddr + p->loadmap->segs[j].addr);\n}\n#define fpaddr(p, v) ((void (*)())&(struct funcdesc){ \\\n\tladdr(p, v), (p)->got })\n#else\n#define laddr(p, v) (void *)((p)->base + (v))\n#define laddr_pg(p, v) laddr(p, v)\n#define fpaddr(p, v) ((void (*)())laddr(p, v))\n#endif\n\nstatic void decode_vec(size_t *v, size_t *a, size_t cnt)\n{\n\tsize_t i;\n\tfor (i=0; i<cnt; i++) a[i] = 0;\n\tfor (; v[0]; v+=2) if (v[0]-1<cnt-1) {\n\t\ta[0] |= 1UL<<v[0];\n\t\ta[v[0]] = v[1];\n\t}\n}\n\nstatic int search_vec(size_t *v, size_t *r, size_t key)\n{\n\tfor (; v[0]!=key; v+=2)\n\t\tif (!v[0]) return 0;\n\t*r = v[1];\n\treturn 1;\n}\n\nstatic uint32_t sysv_hash(const char *s0)\n{\n\tconst unsigned char *s = (void *)s0;\n\tuint_fast32_t h = 0;\n\twhile (*s) {\n\t\th = 16*h + *s++;\n\t\th ^= h>>24 & 0xf0;\n\t}\n\treturn h & 0xfffffff;\n}\n\nstatic uint32_t gnu_hash(const char *s0)\n{\n\tconst unsigned char *s = (void *)s0;\n\tuint_fast32_t h = 5381;\n\tfor (; *s; s++)\n\t\th += h*32 + *s;\n\treturn h;\n}\n\nstatic Sym *sysv_lookup(const char *s, uint32_t h, struct dso *dso)\n{\n\tsize_t i;\n\tSym *syms = dso->syms;\n\tElf_Symndx *hashtab = dso->hashtab;\n\tchar *strings = dso->strings;\n\tfor (i=hashtab[2+h%hashtab[0]]; i; i=hashtab[2+hashtab[0]+i]) {\n\t\tif ((!dso->versym || dso->versym[i] >= 0)\n\t\t    && (!strcmp(s, strings+syms[i].st_name)))\n\t\t\treturn syms+i;\n\t}\n\treturn 0;\n}\n\nstatic Sym *gnu_lookup(uint32_t h1, uint32_t *hashtab, struct dso *dso, const char *s)\n{\n\tuint32_t nbuckets = hashtab[0];\n\tuint32_t *buckets = hashtab + 4 + hashtab[2]*(sizeof(size_t)/4);\n\tuint32_t i = buckets[h1 % nbuckets];\n\n\tif (!i) return 0;\n\n\tuint32_t *hashval = buckets + nbuckets + (i - hashtab[1]);\n\n\tfor (h1 |= 1; ; i++) {\n\t\tuint32_t h2 = *hashval++;\n\t\tif ((h1 == (h2|1)) && (!dso->versym || dso->versym[i] >= 0)\n\t\t    && !strcmp(s, dso->strings + dso->syms[i].st_name))\n\t\t\treturn dso->syms+i;\n\t\tif (h2 & 1) break;\n\t}\n\n\treturn 0;\n}\n\nstatic Sym *gnu_lookup_filtered(uint32_t h1, uint32_t *hashtab, struct dso *dso, const char *s, uint32_t fofs, size_t fmask)\n{\n\tconst size_t *bloomwords = (const void *)(hashtab+4);\n\tsize_t f = bloomwords[fofs & (hashtab[2]-1)];\n\tif (!(f & fmask)) return 0;\n\n\tf >>= (h1 >> hashtab[3]) % (8 * sizeof f);\n\tif (!(f & 1)) return 0;\n\n\treturn gnu_lookup(h1, hashtab, dso, s);\n}\n\n#define OK_TYPES (1<<STT_NOTYPE | 1<<STT_OBJECT | 1<<STT_FUNC | 1<<STT_COMMON | 1<<STT_TLS)\n#define OK_BINDS (1<<STB_GLOBAL | 1<<STB_WEAK | 1<<STB_GNU_UNIQUE)\n\n#ifndef ARCH_SYM_REJECT_UND\n#define ARCH_SYM_REJECT_UND(s) 0\n#endif\n\nstatic struct symdef find_sym(struct dso *dso, const char *s, int need_def)\n{\n\tuint32_t h = 0, gh = gnu_hash(s), gho = gh / (8*sizeof(size_t)), *ght;\n\tsize_t ghm = 1ul << gh % (8*sizeof(size_t));\n\tstruct symdef def = {0};\n\tfor (; dso; dso=dso->syms_next) {\n\t\tSym *sym;\n\t\tif ((ght = dso->ghashtab)) {\n\t\t\tsym = gnu_lookup_filtered(gh, ght, dso, s, gho, ghm);\n\t\t} else {\n\t\t\tif (!h) h = sysv_hash(s);\n\t\t\tsym = sysv_lookup(s, h, dso);\n\t\t}\n\t\tif (!sym) continue;\n\t\tif (!sym->st_shndx)\n\t\t\tif (need_def || (sym->st_info&0xf) == STT_TLS\n\t\t\t    || ARCH_SYM_REJECT_UND(sym))\n\t\t\t\tcontinue;\n\t\tif (!sym->st_value)\n\t\t\tif ((sym->st_info&0xf) != STT_TLS)\n\t\t\t\tcontinue;\n\t\tif (!(1<<(sym->st_info&0xf) & OK_TYPES)) continue;\n\t\tif (!(1<<(sym->st_info>>4) & OK_BINDS)) continue;\n\t\tdef.sym = sym;\n\t\tdef.dso = dso;\n\t\tbreak;\n\t}\n\treturn def;\n}\n\nstatic void do_relocs(struct dso *dso, size_t *rel, size_t rel_size, size_t stride)\n{\n\tunsigned char *base = dso->base;\n\tSym *syms = dso->syms;\n\tchar *strings = dso->strings;\n\tSym *sym;\n\tconst char *name;\n\tvoid *ctx;\n\tint type;\n\tint sym_index;\n\tstruct symdef def;\n\tsize_t *reloc_addr;\n\tsize_t sym_val;\n\tsize_t tls_val;\n\tsize_t addend;\n\tint skip_relative = 0, reuse_addends = 0, save_slot = 0;\n\n\tif (dso == &ldso) {\n\t\t/* Only ldso's REL table needs addend saving/reuse. */\n\t\tif (rel == apply_addends_to)\n\t\t\treuse_addends = 1;\n\t\tskip_relative = 1;\n\t}\n\n\tfor (; rel_size; rel+=stride, rel_size-=stride*sizeof(size_t)) {\n\t\tif (skip_relative && IS_RELATIVE(rel[1], dso->syms)) continue;\n\t\ttype = R_TYPE(rel[1]);\n\t\tif (type == REL_NONE) continue;\n\t\treloc_addr = laddr(dso, rel[0]);\n\n\t\tif (stride > 2) {\n\t\t\taddend = rel[2];\n\t\t} else if (type==REL_GOT || type==REL_PLT|| type==REL_COPY) {\n\t\t\taddend = 0;\n\t\t} else if (reuse_addends) {\n\t\t\t/* Save original addend in stage 2 where the dso\n\t\t\t * chain consists of just ldso; otherwise read back\n\t\t\t * saved addend since the inline one was clobbered. */\n\t\t\tif (head==&ldso)\n\t\t\t\tsaved_addends[save_slot] = *reloc_addr;\n\t\t\taddend = saved_addends[save_slot++];\n\t\t} else {\n\t\t\taddend = *reloc_addr;\n\t\t}\n\n\t\tsym_index = R_SYM(rel[1]);\n\t\tif (sym_index) {\n\t\t\tsym = syms + sym_index;\n\t\t\tname = strings + sym->st_name;\n\t\t\tctx = type==REL_COPY ? head->syms_next : head;\n\t\t\tdef = (sym->st_info&0xf) == STT_SECTION\n\t\t\t\t? (struct symdef){ .dso = dso, .sym = sym }\n\t\t\t\t: find_sym(ctx, name, type==REL_PLT);\n\t\t\tif (!def.sym && (sym->st_shndx != SHN_UNDEF\n\t\t\t    || sym->st_info>>4 != STB_WEAK)) {\n\t\t\t\tif (dso->lazy && (type==REL_PLT || type==REL_GOT)) {\n\t\t\t\t\tdso->lazy[3*dso->lazy_cnt+0] = rel[0];\n\t\t\t\t\tdso->lazy[3*dso->lazy_cnt+1] = rel[1];\n\t\t\t\t\tdso->lazy[3*dso->lazy_cnt+2] = addend;\n\t\t\t\t\tdso->lazy_cnt++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\terror(\"Error relocating %s: %s: symbol not found\",\n\t\t\t\t\tdso->name, name);\n\t\t\t\tif (runtime) longjmp(*rtld_fail, 1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tsym = 0;\n\t\t\tdef.sym = 0;\n\t\t\tdef.dso = dso;\n\t\t}\n\n\t\tsym_val = def.sym ? (size_t)laddr(def.dso, def.sym->st_value) : 0;\n\t\ttls_val = def.sym ? def.sym->st_value : 0;\n\n\t\tif ((type == REL_TPOFF || type == REL_TPOFF_NEG)\n\t\t    && runtime && def.dso->tls_id > static_tls_cnt) {\n\t\t\terror(\"Error relocating %s: %s: initial-exec TLS \"\n\t\t\t\t\"resolves to dynamic definition in %s\",\n\t\t\t\tdso->name, name, def.dso->name);\n\t\t\tlongjmp(*rtld_fail, 1);\n\t\t}\n\n\t\tswitch(type) {\n\t\tcase REL_NONE:\n\t\t\tbreak;\n\t\tcase REL_OFFSET:\n\t\t\taddend -= (size_t)reloc_addr;\n\t\tcase REL_SYMBOLIC:\n\t\tcase REL_GOT:\n\t\tcase REL_PLT:\n\t\t\t*reloc_addr = sym_val + addend;\n\t\t\tbreak;\n\t\tcase REL_RELATIVE:\n\t\t\t*reloc_addr = (size_t)base + addend;\n\t\t\tbreak;\n\t\tcase REL_SYM_OR_REL:\n\t\t\tif (sym) *reloc_addr = sym_val + addend;\n\t\t\telse *reloc_addr = (size_t)base + addend;\n\t\t\tbreak;\n\t\tcase REL_COPY:\n\t\t\tmemcpy(reloc_addr, (void *)sym_val, sym->st_size);\n\t\t\tbreak;\n\t\tcase REL_OFFSET32:\n\t\t\t*(uint32_t *)reloc_addr = sym_val + addend\n\t\t\t\t- (size_t)reloc_addr;\n\t\t\tbreak;\n\t\tcase REL_FUNCDESC:\n\t\t\t*reloc_addr = def.sym ? (size_t)(def.dso->funcdescs\n\t\t\t\t+ (def.sym - def.dso->syms)) : 0;\n\t\t\tbreak;\n\t\tcase REL_FUNCDESC_VAL:\n\t\t\tif ((sym->st_info&0xf) == STT_SECTION) *reloc_addr += sym_val;\n\t\t\telse *reloc_addr = sym_val;\n\t\t\treloc_addr[1] = def.sym ? (size_t)def.dso->got : 0;\n\t\t\tbreak;\n\t\tcase REL_DTPMOD:\n\t\t\t*reloc_addr = def.dso->tls_id;\n\t\t\tbreak;\n\t\tcase REL_DTPOFF:\n\t\t\t*reloc_addr = tls_val + addend - DTP_OFFSET;\n\t\t\tbreak;\n#ifdef TLS_ABOVE_TP\n\t\tcase REL_TPOFF:\n\t\t\t*reloc_addr = tls_val + def.dso->tls.offset + TPOFF_K + addend;\n\t\t\tbreak;\n#else\n\t\tcase REL_TPOFF:\n\t\t\t*reloc_addr = tls_val - def.dso->tls.offset + addend;\n\t\t\tbreak;\n\t\tcase REL_TPOFF_NEG:\n\t\t\t*reloc_addr = def.dso->tls.offset - tls_val + addend;\n\t\t\tbreak;\n#endif\n\t\tcase REL_TLSDESC:\n\t\t\tif (stride<3) addend = reloc_addr[1];\n\t\t\tif (runtime && def.dso->tls_id > static_tls_cnt) {\n\t\t\t\tstruct td_index *new = malloc(sizeof *new);\n\t\t\t\tif (!new) {\n\t\t\t\t\terror(\n\t\t\t\t\t\"Error relocating %s: cannot allocate TLSDESC for %s\",\n\t\t\t\t\tdso->name, sym ? name : \"(local)\" );\n\t\t\t\t\tlongjmp(*rtld_fail, 1);\n\t\t\t\t}\n\t\t\t\tnew->next = dso->td_index;\n\t\t\t\tdso->td_index = new;\n\t\t\t\tnew->args[0] = def.dso->tls_id;\n\t\t\t\tnew->args[1] = tls_val + addend - DTP_OFFSET;\n\t\t\t\treloc_addr[0] = (size_t)__tlsdesc_dynamic;\n\t\t\t\treloc_addr[1] = (size_t)new;\n\t\t\t} else {\n\t\t\t\treloc_addr[0] = (size_t)__tlsdesc_static;\n#ifdef TLS_ABOVE_TP\n\t\t\t\treloc_addr[1] = tls_val + def.dso->tls.offset\n\t\t\t\t\t+ TPOFF_K + addend;\n#else\n\t\t\t\treloc_addr[1] = tls_val - def.dso->tls.offset\n\t\t\t\t\t+ addend;\n#endif\n\t\t\t}\n#ifdef TLSDESC_BACKWARDS\n\t\t\t/* Some archs (32-bit ARM at least) invert the order of\n\t\t\t * the descriptor members. Fix them up here. */\n\t\t\tsize_t tmp = reloc_addr[0];\n\t\t\treloc_addr[0] = reloc_addr[1];\n\t\t\treloc_addr[1] = tmp;\n#endif\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"Error relocating %s: unsupported relocation type %d\",\n\t\t\t\tdso->name, type);\n\t\t\tif (runtime) longjmp(*rtld_fail, 1);\n\t\t\tcontinue;\n\t\t}\n\t}\n}\n\nstatic void redo_lazy_relocs()\n{\n\tstruct dso *p = lazy_head, *next;\n\tlazy_head = 0;\n\tfor (; p; p=next) {\n\t\tnext = p->lazy_next;\n\t\tsize_t size = p->lazy_cnt*3*sizeof(size_t);\n\t\tp->lazy_cnt = 0;\n\t\tdo_relocs(p, p->lazy, size, 3);\n\t\tif (p->lazy_cnt) {\n\t\t\tp->lazy_next = lazy_head;\n\t\t\tlazy_head = p;\n\t\t} else {\n\t\t\tfree(p->lazy);\n\t\t\tp->lazy = 0;\n\t\t\tp->lazy_next = 0;\n\t\t}\n\t}\n}\n\n/* A huge hack: to make up for the wastefulness of shared libraries\n * needing at least a page of dirty memory even if they have no global\n * data, we reclaim the gaps at the beginning and end of writable maps\n * and \"donate\" them to the heap. */\n\nstatic void reclaim(struct dso *dso, size_t start, size_t end)\n{\n\tif (start >= dso->relro_start && start < dso->relro_end) start = dso->relro_end;\n\tif (end   >= dso->relro_start && end   < dso->relro_end) end = dso->relro_start;\n\tif (start >= end) return;\n\tchar *base = laddr_pg(dso, start);\n\t__malloc_donate(base, base+(end-start));\n}\n\nstatic void reclaim_gaps(struct dso *dso)\n{\n\tPhdr *ph = dso->phdr;\n\tsize_t phcnt = dso->phnum;\n\n\tfor (; phcnt--; ph=(void *)((char *)ph+dso->phentsize)) {\n\t\tif (ph->p_type!=PT_LOAD) continue;\n\t\tif ((ph->p_flags&(PF_R|PF_W))!=(PF_R|PF_W)) continue;\n\t\treclaim(dso, ph->p_vaddr & -PAGE_SIZE, ph->p_vaddr);\n\t\treclaim(dso, ph->p_vaddr+ph->p_memsz,\n\t\t\tph->p_vaddr+ph->p_memsz+PAGE_SIZE-1 & -PAGE_SIZE);\n\t}\n}\n\nstatic void *mmap_fixed(void *p, size_t n, int prot, int flags, int fd, off_t off)\n{\n\tstatic int no_map_fixed;\n\tchar *q;\n\tif (!no_map_fixed) {\n\t\tq = mmap(p, n, prot, flags|MAP_FIXED, fd, off);\n\t\tif (!DL_NOMMU_SUPPORT || q != MAP_FAILED || errno != EINVAL)\n\t\t\treturn q;\n\t\tno_map_fixed = 1;\n\t}\n\t/* Fallbacks for MAP_FIXED failure on NOMMU kernels. */\n\tif (flags & MAP_ANONYMOUS) {\n\t\tmemset(p, 0, n);\n\t\treturn p;\n\t}\n\tssize_t r;\n\tif (lseek(fd, off, SEEK_SET) < 0) return MAP_FAILED;\n\tfor (q=p; n; q+=r, off+=r, n-=r) {\n\t\tr = read(fd, q, n);\n\t\tif (r < 0 && errno != EINTR) return MAP_FAILED;\n\t\tif (!r) {\n\t\t\tmemset(q, 0, n);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn p;\n}\n\nstatic void unmap_library(struct dso *dso)\n{\n\tif (dso->loadmap) {\n\t\tsize_t i;\n\t\tfor (i=0; i<dso->loadmap->nsegs; i++) {\n\t\t\tif (!dso->loadmap->segs[i].p_memsz)\n\t\t\t\tcontinue;\n\t\t\tmunmap((void *)dso->loadmap->segs[i].addr,\n\t\t\t\tdso->loadmap->segs[i].p_memsz);\n\t\t}\n\t\tfree(dso->loadmap);\n\t} else if (dso->map && dso->map_len) {\n\t\tmunmap(dso->map, dso->map_len);\n\t}\n}\n\nstatic void *map_library(int fd, struct dso *dso)\n{\n\tEhdr buf[(896+sizeof(Ehdr))/sizeof(Ehdr)];\n\tvoid *allocated_buf=0;\n\tsize_t phsize;\n\tsize_t addr_min=SIZE_MAX, addr_max=0, map_len;\n\tsize_t this_min, this_max;\n\tsize_t nsegs = 0;\n\toff_t off_start;\n\tEhdr *eh;\n\tPhdr *ph, *ph0;\n\tunsigned prot;\n\tunsigned char *map=MAP_FAILED, *base;\n\tsize_t dyn=0;\n\tsize_t tls_image=0;\n\tsize_t i;\n\n\tssize_t l = read(fd, buf, sizeof buf);\n\teh = buf;\n\tif (l<0) return 0;\n\tif (l<sizeof *eh || (eh->e_type != ET_DYN && eh->e_type != ET_EXEC))\n\t\tgoto noexec;\n\tphsize = eh->e_phentsize * eh->e_phnum;\n\tif (phsize > sizeof buf - sizeof *eh) {\n\t\tallocated_buf = malloc(phsize);\n\t\tif (!allocated_buf) return 0;\n\t\tl = pread(fd, allocated_buf, phsize, eh->e_phoff);\n\t\tif (l < 0) goto error;\n\t\tif (l != phsize) goto noexec;\n\t\tph = ph0 = allocated_buf;\n\t} else if (eh->e_phoff + phsize > l) {\n\t\tl = pread(fd, buf+1, phsize, eh->e_phoff);\n\t\tif (l < 0) goto error;\n\t\tif (l != phsize) goto noexec;\n\t\tph = ph0 = (void *)(buf + 1);\n\t} else {\n\t\tph = ph0 = (void *)((char *)buf + eh->e_phoff);\n\t}\n\tfor (i=eh->e_phnum; i; i--, ph=(void *)((char *)ph+eh->e_phentsize)) {\n\t\tif (ph->p_type == PT_DYNAMIC) {\n\t\t\tdyn = ph->p_vaddr;\n\t\t} else if (ph->p_type == PT_TLS) {\n\t\t\ttls_image = ph->p_vaddr;\n\t\t\tdso->tls.align = ph->p_align;\n\t\t\tdso->tls.len = ph->p_filesz;\n\t\t\tdso->tls.size = ph->p_memsz;\n\t\t} else if (ph->p_type == PT_GNU_RELRO) {\n\t\t\tdso->relro_start = ph->p_vaddr & -PAGE_SIZE;\n\t\t\tdso->relro_end = (ph->p_vaddr + ph->p_memsz) & -PAGE_SIZE;\n\t\t} else if (ph->p_type == PT_GNU_STACK) {\n\t\t\tif (!runtime && ph->p_memsz > __default_stacksize) {\n\t\t\t\t__default_stacksize =\n\t\t\t\t\tph->p_memsz < DEFAULT_STACK_MAX ?\n\t\t\t\t\tph->p_memsz : DEFAULT_STACK_MAX;\n\t\t\t}\n\t\t}\n\t\tif (ph->p_type != PT_LOAD) continue;\n\t\tnsegs++;\n\t\tif (ph->p_vaddr < addr_min) {\n\t\t\taddr_min = ph->p_vaddr;\n\t\t\toff_start = ph->p_offset;\n\t\t\tprot = (((ph->p_flags&PF_R) ? PROT_READ : 0) |\n\t\t\t\t((ph->p_flags&PF_W) ? PROT_WRITE: 0) |\n\t\t\t\t((ph->p_flags&PF_X) ? PROT_EXEC : 0));\n\t\t}\n\t\tif (ph->p_vaddr+ph->p_memsz > addr_max) {\n\t\t\taddr_max = ph->p_vaddr+ph->p_memsz;\n\t\t}\n\t}\n\tif (!dyn) goto noexec;\n\tif (DL_FDPIC && !(eh->e_flags & FDPIC_CONSTDISP_FLAG)) {\n\t\tdso->loadmap = calloc(1, sizeof *dso->loadmap\n\t\t\t+ nsegs * sizeof *dso->loadmap->segs);\n\t\tif (!dso->loadmap) goto error;\n\t\tdso->loadmap->nsegs = nsegs;\n\t\tfor (ph=ph0, i=0; i<nsegs; ph=(void *)((char *)ph+eh->e_phentsize)) {\n\t\t\tif (ph->p_type != PT_LOAD) continue;\n\t\t\tprot = (((ph->p_flags&PF_R) ? PROT_READ : 0) |\n\t\t\t\t((ph->p_flags&PF_W) ? PROT_WRITE: 0) |\n\t\t\t\t((ph->p_flags&PF_X) ? PROT_EXEC : 0));\n\t\t\tmap = mmap(0, ph->p_memsz + (ph->p_vaddr & PAGE_SIZE-1),\n\t\t\t\tprot, MAP_PRIVATE,\n\t\t\t\tfd, ph->p_offset & -PAGE_SIZE);\n\t\t\tif (map == MAP_FAILED) {\n\t\t\t\tunmap_library(dso);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tdso->loadmap->segs[i].addr = (size_t)map +\n\t\t\t\t(ph->p_vaddr & PAGE_SIZE-1);\n\t\t\tdso->loadmap->segs[i].p_vaddr = ph->p_vaddr;\n\t\t\tdso->loadmap->segs[i].p_memsz = ph->p_memsz;\n\t\t\ti++;\n\t\t\tif (prot & PROT_WRITE) {\n\t\t\t\tsize_t brk = (ph->p_vaddr & PAGE_SIZE-1)\n\t\t\t\t\t+ ph->p_filesz;\n\t\t\t\tsize_t pgbrk = brk + PAGE_SIZE-1 & -PAGE_SIZE;\n\t\t\t\tsize_t pgend = brk + ph->p_memsz - ph->p_filesz\n\t\t\t\t\t+ PAGE_SIZE-1 & -PAGE_SIZE;\n\t\t\t\tif (pgend > pgbrk && mmap_fixed(map+pgbrk,\n\t\t\t\t\tpgend-pgbrk, prot,\n\t\t\t\t\tMAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS,\n\t\t\t\t\t-1, off_start) == MAP_FAILED)\n\t\t\t\t\tgoto error;\n\t\t\t\tmemset(map + brk, 0, pgbrk-brk);\n\t\t\t}\n\t\t}\n\t\tmap = (void *)dso->loadmap->segs[0].addr;\n\t\tmap_len = 0;\n\t\tgoto done_mapping;\n\t}\n\taddr_max += PAGE_SIZE-1;\n\taddr_max &= -PAGE_SIZE;\n\taddr_min &= -PAGE_SIZE;\n\toff_start &= -PAGE_SIZE;\n\tmap_len = addr_max - addr_min + off_start;\n\t/* The first time, we map too much, possibly even more than\n\t * the length of the file. This is okay because we will not\n\t * use the invalid part; we just need to reserve the right\n\t * amount of virtual address space to map over later. */\n\tmap = DL_NOMMU_SUPPORT\n\t\t? mmap((void *)addr_min, map_len, PROT_READ|PROT_WRITE|PROT_EXEC,\n\t\t\tMAP_PRIVATE|MAP_ANONYMOUS, -1, 0)\n\t\t: mmap((void *)addr_min, map_len, prot,\n\t\t\tMAP_PRIVATE, fd, off_start);\n\tif (map==MAP_FAILED) goto error;\n\tdso->map = map;\n\tdso->map_len = map_len;\n\t/* If the loaded file is not relocatable and the requested address is\n\t * not available, then the load operation must fail. */\n\tif (eh->e_type != ET_DYN && addr_min && map!=(void *)addr_min) {\n\t\terrno = EBUSY;\n\t\tgoto error;\n\t}\n\tbase = map - addr_min;\n\tdso->phdr = 0;\n\tdso->phnum = 0;\n\tfor (ph=ph0, i=eh->e_phnum; i; i--, ph=(void *)((char *)ph+eh->e_phentsize)) {\n\t\tif (ph->p_type != PT_LOAD) continue;\n\t\t/* Check if the programs headers are in this load segment, and\n\t\t * if so, record the address for use by dl_iterate_phdr. */\n\t\tif (!dso->phdr && eh->e_phoff >= ph->p_offset\n\t\t    && eh->e_phoff+phsize <= ph->p_offset+ph->p_filesz) {\n\t\t\tdso->phdr = (void *)(base + ph->p_vaddr\n\t\t\t\t+ (eh->e_phoff-ph->p_offset));\n\t\t\tdso->phnum = eh->e_phnum;\n\t\t\tdso->phentsize = eh->e_phentsize;\n\t\t}\n\t\tthis_min = ph->p_vaddr & -PAGE_SIZE;\n\t\tthis_max = ph->p_vaddr+ph->p_memsz+PAGE_SIZE-1 & -PAGE_SIZE;\n\t\toff_start = ph->p_offset & -PAGE_SIZE;\n\t\tprot = (((ph->p_flags&PF_R) ? PROT_READ : 0) |\n\t\t\t((ph->p_flags&PF_W) ? PROT_WRITE: 0) |\n\t\t\t((ph->p_flags&PF_X) ? PROT_EXEC : 0));\n\t\t/* Reuse the existing mapping for the lowest-address LOAD */\n\t\tif ((ph->p_vaddr & -PAGE_SIZE) != addr_min || DL_NOMMU_SUPPORT)\n\t\t\tif (mmap_fixed(base+this_min, this_max-this_min, prot, MAP_PRIVATE|MAP_FIXED, fd, off_start) == MAP_FAILED)\n\t\t\t\tgoto error;\n\t\tif (ph->p_memsz > ph->p_filesz && (ph->p_flags&PF_W)) {\n\t\t\tsize_t brk = (size_t)base+ph->p_vaddr+ph->p_filesz;\n\t\t\tsize_t pgbrk = brk+PAGE_SIZE-1 & -PAGE_SIZE;\n\t\t\tmemset((void *)brk, 0, pgbrk-brk & PAGE_SIZE-1);\n\t\t\tif (pgbrk-(size_t)base < this_max && mmap_fixed((void *)pgbrk, (size_t)base+this_max-pgbrk, prot, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) == MAP_FAILED)\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\tfor (i=0; ((size_t *)(base+dyn))[i]; i+=2)\n\t\tif (((size_t *)(base+dyn))[i]==DT_TEXTREL) {\n\t\t\tif (mprotect(map, map_len, PROT_READ|PROT_WRITE|PROT_EXEC)\n\t\t\t    && errno != ENOSYS)\n\t\t\t\tgoto error;\n\t\t\tbreak;\n\t\t}\ndone_mapping:\n\tdso->base = base;\n\tdso->dynv = laddr(dso, dyn);\n\tif (dso->tls.size) dso->tls.image = laddr(dso, tls_image);\n\tfree(allocated_buf);\n\treturn map;\nnoexec:\n\terrno = ENOEXEC;\nerror:\n\tif (map!=MAP_FAILED) unmap_library(dso);\n\tfree(allocated_buf);\n\treturn 0;\n}\n\nstatic int path_open(const char *name, const char *s, char *buf, size_t buf_size)\n{\n\tsize_t l;\n\tint fd;\n\tfor (;;) {\n\t\ts += strspn(s, \":\\n\");\n\t\tl = strcspn(s, \":\\n\");\n\t\tif (l-1 >= INT_MAX) return -1;\n\t\tif (snprintf(buf, buf_size, \"%.*s/%s\", (int)l, s, name) < buf_size) {\n\t\t\tif ((fd = open(buf, O_RDONLY|O_CLOEXEC))>=0) return fd;\n\t\t\tswitch (errno) {\n\t\t\tcase ENOENT:\n\t\t\tcase ENOTDIR:\n\t\t\tcase EACCES:\n\t\t\tcase ENAMETOOLONG:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* Any negative value but -1 will inhibit\n\t\t\t\t * futher path search. */\n\t\t\t\treturn -2;\n\t\t\t}\n\t\t}\n\t\ts += l;\n\t}\n}\n\nstatic int fixup_rpath(struct dso *p, char *buf, size_t buf_size)\n{\n\tsize_t n, l;\n\tconst char *s, *t, *origin;\n\tchar *d;\n\tif (p->rpath || !p->rpath_orig) return 0;\n\tif (!strchr(p->rpath_orig, '$')) {\n\t\tp->rpath = p->rpath_orig;\n\t\treturn 0;\n\t}\n\tn = 0;\n\ts = p->rpath_orig;\n\twhile ((t=strchr(s, '$'))) {\n\t\tif (strncmp(t, \"$ORIGIN\", 7) && strncmp(t, \"${ORIGIN}\", 9))\n\t\t\treturn 0;\n\t\ts = t+1;\n\t\tn++;\n\t}\n\tif (n > SSIZE_MAX/PATH_MAX) return 0;\n\n\tif (p->kernel_mapped) {\n\t\t/* $ORIGIN searches cannot be performed for the main program\n\t\t * when it is suid/sgid/AT_SECURE. This is because the\n\t\t * pathname is under the control of the caller of execve.\n\t\t * For libraries, however, $ORIGIN can be processed safely\n\t\t * since the library's pathname came from a trusted source\n\t\t * (either system paths or a call to dlopen). */\n\t\tif (libc.secure)\n\t\t\treturn 0;\n\t\tl = readlink(\"/proc/self/exe\", buf, buf_size);\n\t\tif (l == -1) switch (errno) {\n\t\tcase ENOENT:\n\t\tcase ENOTDIR:\n\t\tcase EACCES:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t\tif (l >= buf_size)\n\t\t\treturn 0;\n\t\tbuf[l] = 0;\n\t\torigin = buf;\n\t} else {\n\t\torigin = p->name;\n\t}\n\tt = strrchr(origin, '/');\n\tif (t) {\n\t\tl = t-origin;\n\t} else {\n\t\t/* Normally p->name will always be an absolute or relative\n\t\t * pathname containing at least one '/' character, but in the\n\t\t * case where ldso was invoked as a command to execute a\n\t\t * program in the working directory, app.name may not. Fix. */\n\t\torigin = \".\";\n\t\tl = 1;\n\t}\n\t/* Disallow non-absolute origins for suid/sgid/AT_SECURE. */\n\tif (libc.secure && *origin != '/')\n\t\treturn 0;\n\tp->rpath = malloc(strlen(p->rpath_orig) + n*l + 1);\n\tif (!p->rpath) return -1;\n\n\td = p->rpath;\n\ts = p->rpath_orig;\n\twhile ((t=strchr(s, '$'))) {\n\t\tmemcpy(d, s, t-s);\n\t\td += t-s;\n\t\tmemcpy(d, origin, l);\n\t\td += l;\n\t\t/* It was determined previously that the '$' is followed\n\t\t * either by \"ORIGIN\" or \"{ORIGIN}\". */\n\t\ts = t + 7 + 2*(t[1]=='{');\n\t}\n\tstrcpy(d, s);\n\treturn 0;\n}\n\nstatic void decode_dyn(struct dso *p)\n{\n\tsize_t dyn[DYN_CNT];\n\tdecode_vec(p->dynv, dyn, DYN_CNT);\n\tp->syms = laddr(p, dyn[DT_SYMTAB]);\n\tp->strings = laddr(p, dyn[DT_STRTAB]);\n\tif (dyn[0]&(1<<DT_HASH))\n\t\tp->hashtab = laddr(p, dyn[DT_HASH]);\n\tif (dyn[0]&(1<<DT_RPATH))\n\t\tp->rpath_orig = p->strings + dyn[DT_RPATH];\n\tif (dyn[0]&(1<<DT_RUNPATH))\n\t\tp->rpath_orig = p->strings + dyn[DT_RUNPATH];\n\tif (dyn[0]&(1<<DT_PLTGOT))\n\t\tp->got = laddr(p, dyn[DT_PLTGOT]);\n\tif (search_vec(p->dynv, dyn, DT_GNU_HASH))\n\t\tp->ghashtab = laddr(p, *dyn);\n\tif (search_vec(p->dynv, dyn, DT_VERSYM))\n\t\tp->versym = laddr(p, *dyn);\n}\n\nstatic size_t count_syms(struct dso *p)\n{\n\tif (p->hashtab) return p->hashtab[1];\n\n\tsize_t nsym, i;\n\tuint32_t *buckets = p->ghashtab + 4 + (p->ghashtab[2]*sizeof(size_t)/4);\n\tuint32_t *hashval;\n\tfor (i = nsym = 0; i < p->ghashtab[0]; i++) {\n\t\tif (buckets[i] > nsym)\n\t\t\tnsym = buckets[i];\n\t}\n\tif (nsym) {\n\t\thashval = buckets + p->ghashtab[0] + (nsym - p->ghashtab[1]);\n\t\tdo nsym++;\n\t\twhile (!(*hashval++ & 1));\n\t}\n\treturn nsym;\n}\n\nstatic void *dl_mmap(size_t n)\n{\n\tvoid *p;\n\tint prot = PROT_READ|PROT_WRITE, flags = MAP_ANONYMOUS|MAP_PRIVATE;\n#ifdef SYS_mmap2\n\tp = (void *)__syscall(SYS_mmap2, 0, n, prot, flags, -1, 0);\n#else\n\tp = (void *)__syscall(SYS_mmap, 0, n, prot, flags, -1, 0);\n#endif\n\treturn (unsigned long)p > -4096UL ? 0 : p;\n}\n\nstatic void makefuncdescs(struct dso *p)\n{\n\tstatic int self_done;\n\tsize_t nsym = count_syms(p);\n\tsize_t i, size = nsym * sizeof(*p->funcdescs);\n\n\tif (!self_done) {\n\t\tp->funcdescs = dl_mmap(size);\n\t\tself_done = 1;\n\t} else {\n\t\tp->funcdescs = malloc(size);\n\t}\n\tif (!p->funcdescs) {\n\t\tif (!runtime) a_crash();\n\t\terror(\"Error allocating function descriptors for %s\", p->name);\n\t\tlongjmp(*rtld_fail, 1);\n\t}\n\tfor (i=0; i<nsym; i++) {\n\t\tif ((p->syms[i].st_info&0xf)==STT_FUNC && p->syms[i].st_shndx) {\n\t\t\tp->funcdescs[i].addr = laddr(p, p->syms[i].st_value);\n\t\t\tp->funcdescs[i].got = p->got;\n\t\t} else {\n\t\t\tp->funcdescs[i].addr = 0;\n\t\t\tp->funcdescs[i].got = 0;\n\t\t}\n\t}\n}\n\nstatic struct dso *load_library(const char *name, struct dso *needed_by)\n{\n\tchar buf[2*NAME_MAX+2];\n\tconst char *pathname;\n\tunsigned char *map;\n\tstruct dso *p, temp_dso = {0};\n\tint fd;\n\tstruct stat st;\n\tsize_t alloc_size;\n\tint n_th = 0;\n\tint is_self = 0;\n\n\tif (!*name) {\n\t\terrno = EINVAL;\n\t\treturn 0;\n\t}\n\n\t/* Catch and block attempts to reload the implementation itself */\n\tif (name[0]=='l' && name[1]=='i' && name[2]=='b') {\n\t\tstatic const char reserved[] =\n\t\t\t\"c.pthread.rt.m.dl.util.xnet.\";\n\t\tconst char *rp, *next;\n\t\tfor (rp=reserved; *rp; rp=next) {\n\t\t\tnext = strchr(rp, '.') + 1;\n\t\t\tif (strncmp(name+3, rp, next-rp) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (*rp) {\n\t\t\tif (ldd_mode) {\n\t\t\t\t/* Track which names have been resolved\n\t\t\t\t * and only report each one once. */\n\t\t\t\tstatic unsigned reported;\n\t\t\t\tunsigned mask = 1U<<(rp-reserved);\n\t\t\t\tif (!(reported & mask)) {\n\t\t\t\t\treported |= mask;\n\t\t\t\t\tdprintf(1, \"\\t%s => %s (%p)\\n\",\n\t\t\t\t\t\tname, ldso.name,\n\t\t\t\t\t\tldso.base);\n\t\t\t\t}\n\t\t\t}\n\t\t\tis_self = 1;\n\t\t}\n\t}\n\tif (!strcmp(name, ldso.name)) is_self = 1;\n\tif (is_self) {\n\t\tif (!ldso.prev) {\n\t\t\ttail->next = &ldso;\n\t\t\tldso.prev = tail;\n\t\t\ttail = &ldso;\n\t\t}\n\t\treturn &ldso;\n\t}\n\tif (strchr(name, '/')) {\n\t\tpathname = name;\n\t\tfd = open(name, O_RDONLY|O_CLOEXEC);\n\t} else {\n\t\t/* Search for the name to see if it's already loaded */\n\t\tfor (p=head->next; p; p=p->next) {\n\t\t\tif (p->shortname && !strcmp(p->shortname, name)) {\n\t\t\t\treturn p;\n\t\t\t}\n\t\t}\n\t\tif (strlen(name) > NAME_MAX) return 0;\n\t\tfd = -1;\n\t\tif (env_path) fd = path_open(name, env_path, buf, sizeof buf);\n\t\tfor (p=needed_by; fd == -1 && p; p=p->needed_by) {\n\t\t\tif (fixup_rpath(p, buf, sizeof buf) < 0)\n\t\t\t\tfd = -2; /* Inhibit further search. */\n\t\t\tif (p->rpath)\n\t\t\t\tfd = path_open(name, p->rpath, buf, sizeof buf);\n\t\t}\n\t\tif (fd == -1) {\n\t\t\tif (!sys_path) {\n\t\t\t\tchar *prefix = 0;\n\t\t\t\tsize_t prefix_len;\n\t\t\t\tif (ldso.name[0]=='/') {\n\t\t\t\t\tchar *s, *t, *z;\n\t\t\t\t\tfor (s=t=z=ldso.name; *s; s++)\n\t\t\t\t\t\tif (*s=='/') z=t, t=s;\n\t\t\t\t\tprefix_len = z-ldso.name;\n\t\t\t\t\tif (prefix_len < PATH_MAX)\n\t\t\t\t\t\tprefix = ldso.name;\n\t\t\t\t}\n\t\t\t\tif (!prefix) {\n\t\t\t\t\tprefix = \"\";\n\t\t\t\t\tprefix_len = 0;\n\t\t\t\t}\n\t\t\t\tchar etc_ldso_path[prefix_len + 1\n\t\t\t\t\t+ sizeof \"/etc/ld-musl-\" LDSO_ARCH \".path\"];\n\t\t\t\tsnprintf(etc_ldso_path, sizeof etc_ldso_path,\n\t\t\t\t\t\"%.*s/etc/ld-musl-\" LDSO_ARCH \".path\",\n\t\t\t\t\t(int)prefix_len, prefix);\n\t\t\t\tFILE *f = fopen(etc_ldso_path, \"rbe\");\n\t\t\t\tif (f) {\n\t\t\t\t\tif (getdelim(&sys_path, (size_t[1]){0}, 0, f) <= 0) {\n\t\t\t\t\t\tfree(sys_path);\n\t\t\t\t\t\tsys_path = \"\";\n\t\t\t\t\t}\n\t\t\t\t\tfclose(f);\n\t\t\t\t} else if (errno != ENOENT) {\n\t\t\t\t\tsys_path = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!sys_path) sys_path = \"/lib:/usr/local/lib:/usr/lib\";\n\t\t\tfd = path_open(name, sys_path, buf, sizeof buf);\n\t\t}\n\t\tpathname = buf;\n\t}\n\tif (fd < 0) return 0;\n\tif (fstat(fd, &st) < 0) {\n\t\tclose(fd);\n\t\treturn 0;\n\t}\n\tfor (p=head->next; p; p=p->next) {\n\t\tif (p->dev == st.st_dev && p->ino == st.st_ino) {\n\t\t\t/* If this library was previously loaded with a\n\t\t\t * pathname but a search found the same inode,\n\t\t\t * setup its shortname so it can be found by name. */\n\t\t\tif (!p->shortname && pathname != name)\n\t\t\t\tp->shortname = strrchr(p->name, '/')+1;\n\t\t\tclose(fd);\n\t\t\treturn p;\n\t\t}\n\t}\n\tmap = noload ? 0 : map_library(fd, &temp_dso);\n\tclose(fd);\n\tif (!map) return 0;\n\n\t/* Avoid the danger of getting two versions of libc mapped into the\n\t * same process when an absolute pathname was used. The symbols\n\t * checked are chosen to catch both musl and glibc, and to avoid\n\t * false positives from interposition-hack libraries. */\n\tdecode_dyn(&temp_dso);\n\tif (find_sym(&temp_dso, \"__libc_start_main\", 1).sym &&\n\t    find_sym(&temp_dso, \"stdin\", 1).sym) {\n\t\tunmap_library(&temp_dso);\n\t\treturn load_library(\"libc.so\", needed_by);\n\t}\n\t/* Past this point, if we haven't reached runtime yet, ldso has\n\t * committed either to use the mapped library or to abort execution.\n\t * Unmapping is not possible, so we can safely reclaim gaps. */\n\tif (!runtime) reclaim_gaps(&temp_dso);\n\n\t/* Allocate storage for the new DSO. When there is TLS, this\n\t * storage must include a reservation for all pre-existing\n\t * threads to obtain copies of both the new TLS, and an\n\t * extended DTV capable of storing an additional slot for\n\t * the newly-loaded DSO. */\n\talloc_size = sizeof *p + strlen(pathname) + 1;\n\tif (runtime && temp_dso.tls.image) {\n\t\tsize_t per_th = temp_dso.tls.size + temp_dso.tls.align\n\t\t\t+ sizeof(void *) * (tls_cnt+3);\n\t\tn_th = libc.threads_minus_1 + 1;\n\t\tif (n_th > SSIZE_MAX / per_th) alloc_size = SIZE_MAX;\n\t\telse alloc_size += n_th * per_th;\n\t}\n\tp = calloc(1, alloc_size);\n\tif (!p) {\n\t\tunmap_library(&temp_dso);\n\t\treturn 0;\n\t}\n\tmemcpy(p, &temp_dso, sizeof temp_dso);\n\tp->dev = st.st_dev;\n\tp->ino = st.st_ino;\n\tp->needed_by = needed_by;\n\tp->name = p->buf;\n\tp->runtime_loaded = runtime;\n\tstrcpy(p->name, pathname);\n\t/* Add a shortname only if name arg was not an explicit pathname. */\n\tif (pathname != name) p->shortname = strrchr(p->name, '/')+1;\n\tif (p->tls.image) {\n\t\tp->tls_id = ++tls_cnt;\n\t\ttls_align = MAXP2(tls_align, p->tls.align);\n#ifdef TLS_ABOVE_TP\n\t\tp->tls.offset = tls_offset + ( (p->tls.align-1) &\n\t\t\t(-tls_offset + (uintptr_t)p->tls.image) );\n\t\ttls_offset = p->tls.offset + p->tls.size;\n#else\n\t\ttls_offset += p->tls.size + p->tls.align - 1;\n\t\ttls_offset -= (tls_offset + (uintptr_t)p->tls.image)\n\t\t\t& (p->tls.align-1);\n\t\tp->tls.offset = tls_offset;\n#endif\n\t\tp->new_dtv = (void *)(-sizeof(size_t) &\n\t\t\t(uintptr_t)(p->name+strlen(p->name)+sizeof(size_t)));\n\t\tp->new_tls = (void *)(p->new_dtv + n_th*(tls_cnt+1));\n\t\tif (tls_tail) tls_tail->next = &p->tls;\n\t\telse libc.tls_head = &p->tls;\n\t\ttls_tail = &p->tls;\n\t}\n\n\ttail->next = p;\n\tp->prev = tail;\n\ttail = p;\n\n\tif (DL_FDPIC) makefuncdescs(p);\n\n\tif (ldd_mode) dprintf(1, \"\\t%s => %s (%p)\\n\", name, pathname, p->base);\n\n\treturn p;\n}\n\nstatic void load_direct_deps(struct dso *p)\n{\n\tsize_t i, cnt=0;\n\n\tif (p->deps) return;\n\t/* For head, all preloads are direct pseudo-dependencies.\n\t * Count and include them now to avoid realloc later. */\n\tif (p==head) for (struct dso *q=p->next; q; q=q->next)\n\t\tcnt++;\n\tfor (i=0; p->dynv[i]; i+=2)\n\t\tif (p->dynv[i] == DT_NEEDED) cnt++;\n\t/* Use builtin buffer for apps with no external deps, to\n\t * preserve property of no runtime failure paths. */\n\tp->deps = (p==head && cnt<2) ? builtin_deps :\n\t\tcalloc(cnt+1, sizeof *p->deps);\n\tif (!p->deps) {\n\t\terror(\"Error loading dependencies for %s\", p->name);\n\t\tif (runtime) longjmp(*rtld_fail, 1);\n\t}\n\tcnt=0;\n\tif (p==head) for (struct dso *q=p->next; q; q=q->next)\n\t\tp->deps[cnt++] = q;\n\tfor (i=0; p->dynv[i]; i+=2) {\n\t\tif (p->dynv[i] != DT_NEEDED) continue;\n\t\tstruct dso *dep = load_library(p->strings + p->dynv[i+1], p);\n\t\tif (!dep) {\n\t\t\terror(\"Error loading shared library %s: %m (needed by %s)\",\n\t\t\t\tp->strings + p->dynv[i+1], p->name);\n\t\t\tif (runtime) longjmp(*rtld_fail, 1);\n\t\t\tcontinue;\n\t\t}\n\t\tp->deps[cnt++] = dep;\n\t}\n\tp->deps[cnt] = 0;\n\tp->ndeps_direct = cnt;\n}\n\nstatic void load_deps(struct dso *p)\n{\n\tif (p->deps) return;\n\tfor (; p; p=p->next)\n\t\tload_direct_deps(p);\n}\n\nstatic void extend_bfs_deps(struct dso *p)\n{\n\tsize_t i, j, cnt, ndeps_all;\n\tstruct dso **tmp;\n\n\t/* Can't use realloc if the original p->deps was allocated at\n\t * program entry and malloc has been replaced, or if it's\n\t * the builtin non-allocated trivial main program deps array. */\n\tint no_realloc = (__malloc_replaced && !p->runtime_loaded)\n\t\t|| p->deps == builtin_deps;\n\n\tif (p->bfs_built) return;\n\tndeps_all = p->ndeps_direct;\n\n\t/* Mark existing (direct) deps so they won't be duplicated. */\n\tfor (i=0; p->deps[i]; i++)\n\t\tp->deps[i]->mark = 1;\n\n\t/* For each dependency already in the list, copy its list of direct\n\t * dependencies to the list, excluding any items already in the\n\t * list. Note that the list this loop iterates over will grow during\n\t * the loop, but since duplicates are excluded, growth is bounded. */\n\tfor (i=0; p->deps[i]; i++) {\n\t\tstruct dso *dep = p->deps[i];\n\t\tfor (j=cnt=0; j<dep->ndeps_direct; j++)\n\t\t\tif (!dep->deps[j]->mark) cnt++;\n\t\ttmp = no_realloc ? \n\t\t\tmalloc(sizeof(*tmp) * (ndeps_all+cnt+1)) :\n\t\t\trealloc(p->deps, sizeof(*tmp) * (ndeps_all+cnt+1));\n\t\tif (!tmp) {\n\t\t\terror(\"Error recording dependencies for %s\", p->name);\n\t\t\tif (runtime) longjmp(*rtld_fail, 1);\n\t\t\tcontinue;\n\t\t}\n\t\tif (no_realloc) {\n\t\t\tmemcpy(tmp, p->deps, sizeof(*tmp) * (ndeps_all+1));\n\t\t\tno_realloc = 0;\n\t\t}\n\t\tp->deps = tmp;\n\t\tfor (j=0; j<dep->ndeps_direct; j++) {\n\t\t\tif (dep->deps[j]->mark) continue;\n\t\t\tdep->deps[j]->mark = 1;\n\t\t\tp->deps[ndeps_all++] = dep->deps[j];\n\t\t}\n\t\tp->deps[ndeps_all] = 0;\n\t}\n\tp->bfs_built = 1;\n\tfor (p=head; p; p=p->next)\n\t\tp->mark = 0;\n}\n\nstatic void load_preload(char *s)\n{\n\tint tmp;\n\tchar *z;\n\tfor (z=s; *z; s=z) {\n\t\tfor (   ; *s && (isspace(*s) || *s==':'); s++);\n\t\tfor (z=s; *z && !isspace(*z) && *z!=':'; z++);\n\t\ttmp = *z;\n\t\t*z = 0;\n\t\tload_library(s, 0);\n\t\t*z = tmp;\n\t}\n}\n\nstatic void add_syms(struct dso *p)\n{\n\tif (!p->syms_next && syms_tail != p) {\n\t\tsyms_tail->syms_next = p;\n\t\tsyms_tail = p;\n\t}\n}\n\nstatic void revert_syms(struct dso *old_tail)\n{\n\tstruct dso *p, *next;\n\t/* Chop off the tail of the list of dsos that participate in\n\t * the global symbol table, reverting them to RTLD_LOCAL. */\n\tfor (p=old_tail; p; p=next) {\n\t\tnext = p->syms_next;\n\t\tp->syms_next = 0;\n\t}\n\tsyms_tail = old_tail;\n}\n\nstatic void do_mips_relocs(struct dso *p, size_t *got)\n{\n\tsize_t i, j, rel[2];\n\tunsigned char *base = p->base;\n\ti=0; search_vec(p->dynv, &i, DT_MIPS_LOCAL_GOTNO);\n\tif (p==&ldso) {\n\t\tgot += i;\n\t} else {\n\t\twhile (i--) *got++ += (size_t)base;\n\t}\n\tj=0; search_vec(p->dynv, &j, DT_MIPS_GOTSYM);\n\ti=0; search_vec(p->dynv, &i, DT_MIPS_SYMTABNO);\n\tSym *sym = p->syms + j;\n\trel[0] = (unsigned char *)got - base;\n\tfor (i-=j; i; i--, sym++, rel[0]+=sizeof(size_t)) {\n\t\trel[1] = R_INFO(sym-p->syms, R_MIPS_JUMP_SLOT);\n\t\tdo_relocs(p, rel, sizeof rel, 2);\n\t}\n}\n\nstatic void reloc_all(struct dso *p)\n{\n\tsize_t dyn[DYN_CNT];\n\tfor (; p; p=p->next) {\n\t\tif (p->relocated) continue;\n\t\tdecode_vec(p->dynv, dyn, DYN_CNT);\n\t\tif (NEED_MIPS_GOT_RELOCS)\n\t\t\tdo_mips_relocs(p, laddr(p, dyn[DT_PLTGOT]));\n\t\tdo_relocs(p, laddr(p, dyn[DT_JMPREL]), dyn[DT_PLTRELSZ],\n\t\t\t2+(dyn[DT_PLTREL]==DT_RELA));\n\t\tdo_relocs(p, laddr(p, dyn[DT_REL]), dyn[DT_RELSZ], 2);\n\t\tdo_relocs(p, laddr(p, dyn[DT_RELA]), dyn[DT_RELASZ], 3);\n\n\t\tif (head != &ldso && p->relro_start != p->relro_end &&\n\t\t    mprotect(laddr(p, p->relro_start), p->relro_end-p->relro_start, PROT_READ)\n\t\t    && errno != ENOSYS) {\n\t\t\terror(\"Error relocating %s: RELRO protection failed: %m\",\n\t\t\t\tp->name);\n\t\t\tif (runtime) longjmp(*rtld_fail, 1);\n\t\t}\n\n\t\tp->relocated = 1;\n\t}\n}\n\nstatic void kernel_mapped_dso(struct dso *p)\n{\n\tsize_t min_addr = -1, max_addr = 0, cnt;\n\tPhdr *ph = p->phdr;\n\tfor (cnt = p->phnum; cnt--; ph = (void *)((char *)ph + p->phentsize)) {\n\t\tif (ph->p_type == PT_DYNAMIC) {\n\t\t\tp->dynv = laddr(p, ph->p_vaddr);\n\t\t} else if (ph->p_type == PT_GNU_RELRO) {\n\t\t\tp->relro_start = ph->p_vaddr & -PAGE_SIZE;\n\t\t\tp->relro_end = (ph->p_vaddr + ph->p_memsz) & -PAGE_SIZE;\n\t\t} else if (ph->p_type == PT_GNU_STACK) {\n\t\t\tif (!runtime && ph->p_memsz > __default_stacksize) {\n\t\t\t\t__default_stacksize =\n\t\t\t\t\tph->p_memsz < DEFAULT_STACK_MAX ?\n\t\t\t\t\tph->p_memsz : DEFAULT_STACK_MAX;\n\t\t\t}\n\t\t}\n\t\tif (ph->p_type != PT_LOAD) continue;\n\t\tif (ph->p_vaddr < min_addr)\n\t\t\tmin_addr = ph->p_vaddr;\n\t\tif (ph->p_vaddr+ph->p_memsz > max_addr)\n\t\t\tmax_addr = ph->p_vaddr+ph->p_memsz;\n\t}\n\tmin_addr &= -PAGE_SIZE;\n\tmax_addr = (max_addr + PAGE_SIZE-1) & -PAGE_SIZE;\n\tp->map = p->base + min_addr;\n\tp->map_len = max_addr - min_addr;\n\tp->kernel_mapped = 1;\n}\n\nvoid __libc_exit_fini()\n{\n\tstruct dso *p;\n\tsize_t dyn[DYN_CNT];\n\tint self = __pthread_self()->tid;\n\n\t/* Take both locks before setting shutting_down, so that\n\t * either lock is sufficient to read its value. The lock\n\t * order matches that in dlopen to avoid deadlock. */\n\tpthread_rwlock_wrlock(&lock);\n\tpthread_mutex_lock(&init_fini_lock);\n\tshutting_down = 1;\n\tpthread_rwlock_unlock(&lock);\n\tfor (p=fini_head; p; p=p->fini_next) {\n\t\twhile (p->ctor_visitor && p->ctor_visitor!=self)\n\t\t\tpthread_cond_wait(&ctor_cond, &init_fini_lock);\n\t\tif (!p->constructed) continue;\n\t\tdecode_vec(p->dynv, dyn, DYN_CNT);\n\t\tif (dyn[0] & (1<<DT_FINI_ARRAY)) {\n\t\t\tsize_t n = dyn[DT_FINI_ARRAYSZ]/sizeof(size_t);\n\t\t\tsize_t *fn = (size_t *)laddr(p, dyn[DT_FINI_ARRAY])+n;\n\t\t\twhile (n--) ((void (*)(void))*--fn)();\n\t\t}\n#ifndef NO_LEGACY_INITFINI\n\t\tif ((dyn[0] & (1<<DT_FINI)) && dyn[DT_FINI])\n\t\t\tfpaddr(p, dyn[DT_FINI])();\n#endif\n\t}\n}\n\nstatic struct dso **queue_ctors(struct dso *dso)\n{\n\tsize_t cnt, qpos, spos, i;\n\tstruct dso *p, **queue, **stack;\n\n\tif (ldd_mode) return 0;\n\n\t/* Bound on queue size is the total number of indirect deps.\n\t * If a bfs deps list was built, we can use it. Otherwise,\n\t * bound by the total number of DSOs, which is always safe and\n\t * is reasonable we use it (for main app at startup). */\n\tif (dso->bfs_built) {\n\t\tfor (cnt=0; dso->deps[cnt]; cnt++)\n\t\t\tdso->deps[cnt]->mark = 0;\n\t\tcnt++; /* self, not included in deps */\n\t} else {\n\t\tfor (cnt=0, p=head; p; cnt++, p=p->next)\n\t\t\tp->mark = 0;\n\t}\n\tcnt++; /* termination slot */\n\tif (dso==head && cnt <= countof(builtin_ctor_queue))\n\t\tqueue = builtin_ctor_queue;\n\telse\n\t\tqueue = calloc(cnt, sizeof *queue);\n\n\tif (!queue) {\n\t\terror(\"Error allocating constructor queue: %m\\n\");\n\t\tif (runtime) longjmp(*rtld_fail, 1);\n\t\treturn 0;\n\t}\n\n\t/* Opposite ends of the allocated buffer serve as an output queue\n\t * and a working stack. Setup initial stack with just the argument\n\t * dso and initial queue empty... */\n\tstack = queue;\n\tqpos = 0;\n\tspos = cnt;\n\tstack[--spos] = dso;\n\tdso->next_dep = 0;\n\tdso->mark = 1;\n\n\t/* Then perform pseudo-DFS sort, but ignoring circular deps. */\n\twhile (spos<cnt) {\n\t\tp = stack[spos++];\n\t\twhile (p->next_dep < p->ndeps_direct) {\n\t\t\tif (p->deps[p->next_dep]->mark) {\n\t\t\t\tp->next_dep++;\n\t\t\t} else {\n\t\t\t\tstack[--spos] = p;\n\t\t\t\tp = p->deps[p->next_dep];\n\t\t\t\tp->next_dep = 0;\n\t\t\t\tp->mark = 1;\n\t\t\t}\n\t\t}\n\t\tqueue[qpos++] = p;\n\t}\n\tqueue[qpos] = 0;\n\tfor (i=0; i<qpos; i++) queue[i]->mark = 0;\n\n\treturn queue;\n}\n\nstatic void do_init_fini(struct dso **queue)\n{\n\tstruct dso *p;\n\tsize_t dyn[DYN_CNT], i;\n\tint self = __pthread_self()->tid;\n\n\tpthread_mutex_lock(&init_fini_lock);\n\tfor (i=0; (p=queue[i]); i++) {\n\t\twhile ((p->ctor_visitor && p->ctor_visitor!=self) || shutting_down)\n\t\t\tpthread_cond_wait(&ctor_cond, &init_fini_lock);\n\t\tif (p->ctor_visitor || p->constructed)\n\t\t\tcontinue;\n\t\tp->ctor_visitor = self;\n\t\t\n\t\tdecode_vec(p->dynv, dyn, DYN_CNT);\n\t\tif (dyn[0] & ((1<<DT_FINI) | (1<<DT_FINI_ARRAY))) {\n\t\t\tp->fini_next = fini_head;\n\t\t\tfini_head = p;\n\t\t}\n\n\t\tpthread_mutex_unlock(&init_fini_lock);\n\n#ifndef NO_LEGACY_INITFINI\n\t\tif ((dyn[0] & (1<<DT_INIT)) && dyn[DT_INIT])\n\t\t\tfpaddr(p, dyn[DT_INIT])();\n#endif\n\t\tif (dyn[0] & (1<<DT_INIT_ARRAY)) {\n\t\t\tsize_t n = dyn[DT_INIT_ARRAYSZ]/sizeof(size_t);\n\t\t\tsize_t *fn = laddr(p, dyn[DT_INIT_ARRAY]);\n\t\t\twhile (n--) ((void (*)(void))*fn++)();\n\t\t}\n\n\t\tpthread_mutex_lock(&init_fini_lock);\n\t\tp->ctor_visitor = 0;\n\t\tp->constructed = 1;\n\t\tpthread_cond_broadcast(&ctor_cond);\n\t}\n\tpthread_mutex_unlock(&init_fini_lock);\n}\n\nvoid __libc_start_init(void)\n{\n\tdo_init_fini(main_ctor_queue);\n\tif (!__malloc_replaced && main_ctor_queue != builtin_ctor_queue)\n\t\tfree(main_ctor_queue);\n\tmain_ctor_queue = 0;\n}\n\nstatic void dl_debug_state(void)\n{\n}\n\nweak_alias(dl_debug_state, _dl_debug_state);\n\nvoid __init_tls(size_t *auxv)\n{\n}\n\nstatic void update_tls_size()\n{\n\tlibc.tls_cnt = tls_cnt;\n\tlibc.tls_align = tls_align;\n\tlibc.tls_size = ALIGN(\n\t\t(1+tls_cnt) * sizeof(void *) +\n\t\ttls_offset +\n\t\tsizeof(struct pthread) +\n\t\ttls_align * 2,\n\ttls_align);\n}\n\nstatic void install_new_tls(void)\n{\n\tsigset_t set;\n\tpthread_t self = __pthread_self(), td;\n\tstruct dso *dtv_provider = container_of(tls_tail, struct dso, tls);\n\tuintptr_t (*newdtv)[tls_cnt+1] = (void *)dtv_provider->new_dtv;\n\tstruct dso *p;\n\tsize_t i, j;\n\tsize_t old_cnt = self->dtv[0];\n\n\t__block_app_sigs(&set);\n\t__tl_lock();\n\t/* Copy existing dtv contents from all existing threads. */\n\tfor (i=0, td=self; !i || td!=self; i++, td=td->next) {\n\t\tmemcpy(newdtv+i, td->dtv,\n\t\t\t(old_cnt+1)*sizeof(uintptr_t));\n\t\tnewdtv[i][0] = tls_cnt;\n\t}\n\t/* Install new dtls into the enlarged, uninstalled dtv copies. */\n\tfor (p=head; ; p=p->next) {\n\t\tif (p->tls_id <= old_cnt) continue;\n\t\tunsigned char *mem = p->new_tls;\n\t\tfor (j=0; j<i; j++) {\n\t\t\tunsigned char *new = mem;\n\t\t\tnew += ((uintptr_t)p->tls.image - (uintptr_t)mem)\n\t\t\t\t& (p->tls.align-1);\n\t\t\tmemcpy(new, p->tls.image, p->tls.len);\n\t\t\tnewdtv[j][p->tls_id] =\n\t\t\t\t(uintptr_t)new + DTP_OFFSET;\n\t\t\tmem += p->tls.size + p->tls.align;\n\t\t}\n\t\tif (p->tls_id == tls_cnt) break;\n\t}\n\n\t/* Broadcast barrier to ensure contents of new dtv is visible\n\t * if the new dtv pointer is. The __membarrier function has a\n\t * fallback emulation using signals for kernels that lack the\n\t * feature at the syscall level. */\n\n\t__membarrier(MEMBARRIER_CMD_PRIVATE_EXPEDITED, 0);\n\n\t/* Install new dtv for each thread. */\n\tfor (j=0, td=self; !j || td!=self; j++, td=td->next) {\n\t\ttd->dtv = td->dtv_copy = newdtv[j];\n\t}\n\n\t__tl_unlock();\n\t__restore_sigs(&set);\n}\n\n/* Stage 1 of the dynamic linker is defined in dlstart.c. It calls the\n * following stage 2 and stage 3 functions via primitive symbolic lookup\n * since it does not have access to their addresses to begin with. */\n\n/* Stage 2 of the dynamic linker is called after relative relocations \n * have been processed. It can make function calls to static functions\n * and access string literals and static data, but cannot use extern\n * symbols. Its job is to perform symbolic relocations on the dynamic\n * linker itself, but some of the relocations performed may need to be\n * replaced later due to copy relocations in the main program. */\n\nhidden void __dls2(unsigned char *base, size_t *sp)\n{\n\tif (DL_FDPIC) {\n\t\tvoid *p1 = (void *)sp[-2];\n\t\tvoid *p2 = (void *)sp[-1];\n\t\tif (!p1) {\n\t\t\tsize_t *auxv, aux[AUX_CNT];\n\t\t\tfor (auxv=sp+1+*sp+1; *auxv; auxv++);\n\t\t\tauxv++;\n\t\t\tdecode_vec(auxv, aux, AUX_CNT);\n\t\t\tif (aux[AT_BASE]) ldso.base = (void *)aux[AT_BASE];\n\t\t\telse ldso.base = (void *)(aux[AT_PHDR] & -4096);\n\t\t}\n\t\tapp_loadmap = p2 ? p1 : 0;\n\t\tldso.loadmap = p2 ? p2 : p1;\n\t\tldso.base = laddr(&ldso, 0);\n\t} else {\n\t\tldso.base = base;\n\t}\n\tEhdr *ehdr = (void *)ldso.base;\n\tldso.name = ldso.shortname = \"libc.so\";\n\tldso.phnum = ehdr->e_phnum;\n\tldso.phdr = laddr(&ldso, ehdr->e_phoff);\n\tldso.phentsize = ehdr->e_phentsize;\n\tkernel_mapped_dso(&ldso);\n\tdecode_dyn(&ldso);\n\n\tif (DL_FDPIC) makefuncdescs(&ldso);\n\n\t/* Prepare storage for to save clobbered REL addends so they\n\t * can be reused in stage 3. There should be very few. If\n\t * something goes wrong and there are a huge number, abort\n\t * instead of risking stack overflow. */\n\tsize_t dyn[DYN_CNT];\n\tdecode_vec(ldso.dynv, dyn, DYN_CNT);\n\tsize_t *rel = laddr(&ldso, dyn[DT_REL]);\n\tsize_t rel_size = dyn[DT_RELSZ];\n\tsize_t symbolic_rel_cnt = 0;\n\tapply_addends_to = rel;\n\tfor (; rel_size; rel+=2, rel_size-=2*sizeof(size_t))\n\t\tif (!IS_RELATIVE(rel[1], ldso.syms)) symbolic_rel_cnt++;\n\tif (symbolic_rel_cnt >= ADDEND_LIMIT) a_crash();\n\tsize_t addends[symbolic_rel_cnt+1];\n\tsaved_addends = addends;\n\n\thead = &ldso;\n\treloc_all(&ldso);\n\n\tldso.relocated = 0;\n\n\t/* Call dynamic linker stage-2b, __dls2b, looking it up\n\t * symbolically as a barrier against moving the address\n\t * load across the above relocation processing. */\n\tstruct symdef dls2b_def = find_sym(&ldso, \"__dls2b\", 0);\n\tif (DL_FDPIC) ((stage3_func)&ldso.funcdescs[dls2b_def.sym-ldso.syms])(sp);\n\telse ((stage3_func)laddr(&ldso, dls2b_def.sym->st_value))(sp);\n}\n\n/* Stage 2b sets up a valid thread pointer, which requires relocations\n * completed in stage 2, and on which stage 3 is permitted to depend.\n * This is done as a separate stage, with symbolic lookup as a barrier,\n * so that loads of the thread pointer and &errno can be pure/const and\n * thereby hoistable. */\n\nvoid __dls2b(size_t *sp)\n{\n\t/* Setup early thread pointer in builtin_tls for ldso/libc itself to\n\t * use during dynamic linking. If possible it will also serve as the\n\t * thread pointer at runtime. */\n\tlibc.tls_size = sizeof builtin_tls;\n\tlibc.tls_align = tls_align;\n\tif (__init_tp(__copy_tls((void *)builtin_tls)) < 0) {\n\t\ta_crash();\n\t}\n\n\tstruct symdef dls3_def = find_sym(&ldso, \"__dls3\", 0);\n\tif (DL_FDPIC) ((stage3_func)&ldso.funcdescs[dls3_def.sym-ldso.syms])(sp);\n\telse ((stage3_func)laddr(&ldso, dls3_def.sym->st_value))(sp);\n}\n\n/* Stage 3 of the dynamic linker is called with the dynamic linker/libc\n * fully functional. Its job is to load (if not already loaded) and\n * process dependencies and relocations for the main application and\n * transfer control to its entry point. */\n\nvoid __dls3(size_t *sp)\n{\n\tstatic struct dso app, vdso;\n\tsize_t aux[AUX_CNT], *auxv;\n\tsize_t i;\n\tchar *env_preload=0;\n\tchar *replace_argv0=0;\n\tsize_t vdso_base;\n\tint argc = *sp;\n\tchar **argv = (void *)(sp+1);\n\tchar **argv_orig = argv;\n\tchar **envp = argv+argc+1;\n\n\t/* Find aux vector just past environ[] and use it to initialize\n\t * global data that may be needed before we can make syscalls. */\n\t__environ = envp;\n\tfor (i=argc+1; argv[i]; i++);\n\tlibc.auxv = auxv = (void *)(argv+i+1);\n\tdecode_vec(auxv, aux, AUX_CNT);\n\t__hwcap = aux[AT_HWCAP];\n\tsearch_vec(auxv, &__sysinfo, AT_SYSINFO);\n\t__pthread_self()->sysinfo = __sysinfo;\n\tlibc.page_size = aux[AT_PAGESZ];\n\tlibc.secure = ((aux[0]&0x7800)!=0x7800 || aux[AT_UID]!=aux[AT_EUID]\n\t\t|| aux[AT_GID]!=aux[AT_EGID] || aux[AT_SECURE]);\n\n\t/* Only trust user/env if kernel says we're not suid/sgid */\n\tif (!libc.secure) {\n\t\tenv_path = getenv(\"LD_LIBRARY_PATH\");\n\t\tenv_preload = getenv(\"LD_PRELOAD\");\n\t}\n\n\t/* If the main program was already loaded by the kernel,\n\t * AT_PHDR will point to some location other than the dynamic\n\t * linker's program headers. */\n\tif (aux[AT_PHDR] != (size_t)ldso.phdr) {\n\t\tsize_t interp_off = 0;\n\t\tsize_t tls_image = 0;\n\t\t/* Find load address of the main program, via AT_PHDR vs PT_PHDR. */\n\t\tPhdr *phdr = app.phdr = (void *)aux[AT_PHDR];\n\t\tapp.phnum = aux[AT_PHNUM];\n\t\tapp.phentsize = aux[AT_PHENT];\n\t\tfor (i=aux[AT_PHNUM]; i; i--, phdr=(void *)((char *)phdr + aux[AT_PHENT])) {\n\t\t\tif (phdr->p_type == PT_PHDR)\n\t\t\t\tapp.base = (void *)(aux[AT_PHDR] - phdr->p_vaddr);\n\t\t\telse if (phdr->p_type == PT_INTERP)\n\t\t\t\tinterp_off = (size_t)phdr->p_vaddr;\n\t\t\telse if (phdr->p_type == PT_TLS) {\n\t\t\t\ttls_image = phdr->p_vaddr;\n\t\t\t\tapp.tls.len = phdr->p_filesz;\n\t\t\t\tapp.tls.size = phdr->p_memsz;\n\t\t\t\tapp.tls.align = phdr->p_align;\n\t\t\t}\n\t\t}\n\t\tif (DL_FDPIC) app.loadmap = app_loadmap;\n\t\tif (app.tls.size) app.tls.image = laddr(&app, tls_image);\n\t\tif (interp_off) ldso.name = laddr(&app, interp_off);\n\t\tif ((aux[0] & (1UL<<AT_EXECFN))\n\t\t    && strncmp((char *)aux[AT_EXECFN], \"/proc/\", 6))\n\t\t\tapp.name = (char *)aux[AT_EXECFN];\n\t\telse\n\t\t\tapp.name = argv[0];\n\t\tkernel_mapped_dso(&app);\n\t} else {\n\t\tint fd;\n\t\tchar *ldname = argv[0];\n\t\tsize_t l = strlen(ldname);\n\t\tif (l >= 3 && !strcmp(ldname+l-3, \"ldd\")) ldd_mode = 1;\n\t\targv++;\n\t\twhile (argv[0] && argv[0][0]=='-' && argv[0][1]=='-') {\n\t\t\tchar *opt = argv[0]+2;\n\t\t\t*argv++ = (void *)-1;\n\t\t\tif (!*opt) {\n\t\t\t\tbreak;\n\t\t\t} else if (!memcmp(opt, \"list\", 5)) {\n\t\t\t\tldd_mode = 1;\n\t\t\t} else if (!memcmp(opt, \"library-path\", 12)) {\n\t\t\t\tif (opt[12]=='=') env_path = opt+13;\n\t\t\t\telse if (opt[12]) *argv = 0;\n\t\t\t\telse if (*argv) env_path = *argv++;\n\t\t\t} else if (!memcmp(opt, \"preload\", 7)) {\n\t\t\t\tif (opt[7]=='=') env_preload = opt+8;\n\t\t\t\telse if (opt[7]) *argv = 0;\n\t\t\t\telse if (*argv) env_preload = *argv++;\n\t\t\t} else if (!memcmp(opt, \"argv0\", 5)) {\n\t\t\t\tif (opt[5]=='=') replace_argv0 = opt+6;\n\t\t\t\telse if (opt[5]) *argv = 0;\n\t\t\t\telse if (*argv) replace_argv0 = *argv++;\n\t\t\t} else {\n\t\t\t\targv[0] = 0;\n\t\t\t}\n\t\t}\n\t\targv[-1] = (void *)(argc - (argv-argv_orig));\n\t\tif (!argv[0]) {\n\t\t\tdprintf(2, \"musl libc (\" LDSO_ARCH \")\\n\"\n\t\t\t\t\"Version %s\\n\"\n\t\t\t\t\"Dynamic Program Loader\\n\"\n\t\t\t\t\"Usage: %s [options] [--] pathname%s\\n\",\n\t\t\t\t__libc_version, ldname,\n\t\t\t\tldd_mode ? \"\" : \" [args]\");\n\t\t\t_exit(1);\n\t\t}\n\t\tfd = open(argv[0], O_RDONLY);\n\t\tif (fd < 0) {\n\t\t\tdprintf(2, \"%s: cannot load %s: %s\\n\", ldname, argv[0], strerror(errno));\n\t\t\t_exit(1);\n\t\t}\n\t\tEhdr *ehdr = (void *)map_library(fd, &app);\n\t\tif (!ehdr) {\n\t\t\tdprintf(2, \"%s: %s: Not a valid dynamic program\\n\", ldname, argv[0]);\n\t\t\t_exit(1);\n\t\t}\n\t\tclose(fd);\n\t\tldso.name = ldname;\n\t\tapp.name = argv[0];\n\t\taux[AT_ENTRY] = (size_t)laddr(&app, ehdr->e_entry);\n\t\t/* Find the name that would have been used for the dynamic\n\t\t * linker had ldd not taken its place. */\n\t\tif (ldd_mode) {\n\t\t\tfor (i=0; i<app.phnum; i++) {\n\t\t\t\tif (app.phdr[i].p_type == PT_INTERP)\n\t\t\t\t\tldso.name = laddr(&app, app.phdr[i].p_vaddr);\n\t\t\t}\n\t\t\tdprintf(1, \"\\t%s (%p)\\n\", ldso.name, ldso.base);\n\t\t}\n\t}\n\tif (app.tls.size) {\n\t\tlibc.tls_head = tls_tail = &app.tls;\n\t\tapp.tls_id = tls_cnt = 1;\n#ifdef TLS_ABOVE_TP\n\t\tapp.tls.offset = GAP_ABOVE_TP;\n\t\tapp.tls.offset += (-GAP_ABOVE_TP + (uintptr_t)app.tls.image)\n\t\t\t& (app.tls.align-1);\n\t\ttls_offset = app.tls.offset + app.tls.size;\n#else\n\t\ttls_offset = app.tls.offset = app.tls.size\n\t\t\t+ ( -((uintptr_t)app.tls.image + app.tls.size)\n\t\t\t& (app.tls.align-1) );\n#endif\n\t\ttls_align = MAXP2(tls_align, app.tls.align);\n\t}\n\tdecode_dyn(&app);\n\tif (DL_FDPIC) {\n\t\tmakefuncdescs(&app);\n\t\tif (!app.loadmap) {\n\t\t\tapp.loadmap = (void *)&app_dummy_loadmap;\n\t\t\tapp.loadmap->nsegs = 1;\n\t\t\tapp.loadmap->segs[0].addr = (size_t)app.map;\n\t\t\tapp.loadmap->segs[0].p_vaddr = (size_t)app.map\n\t\t\t\t- (size_t)app.base;\n\t\t\tapp.loadmap->segs[0].p_memsz = app.map_len;\n\t\t}\n\t\targv[-3] = (void *)app.loadmap;\n\t}\n\n\t/* Initial dso chain consists only of the app. */\n\thead = tail = syms_tail = &app;\n\n\t/* Donate unused parts of app and library mapping to malloc */\n\treclaim_gaps(&app);\n\treclaim_gaps(&ldso);\n\n\t/* Load preload/needed libraries, add symbols to global namespace. */\n\tldso.deps = (struct dso **)no_deps;\n\tif (env_preload) load_preload(env_preload);\n \tload_deps(&app);\n\tfor (struct dso *p=head; p; p=p->next)\n\t\tadd_syms(p);\n\n\t/* Attach to vdso, if provided by the kernel, last so that it does\n\t * not become part of the global namespace.  */\n\tif (search_vec(auxv, &vdso_base, AT_SYSINFO_EHDR) && vdso_base) {\n\t\tEhdr *ehdr = (void *)vdso_base;\n\t\tPhdr *phdr = vdso.phdr = (void *)(vdso_base + ehdr->e_phoff);\n\t\tvdso.phnum = ehdr->e_phnum;\n\t\tvdso.phentsize = ehdr->e_phentsize;\n\t\tfor (i=ehdr->e_phnum; i; i--, phdr=(void *)((char *)phdr + ehdr->e_phentsize)) {\n\t\t\tif (phdr->p_type == PT_DYNAMIC)\n\t\t\t\tvdso.dynv = (void *)(vdso_base + phdr->p_offset);\n\t\t\tif (phdr->p_type == PT_LOAD)\n\t\t\t\tvdso.base = (void *)(vdso_base - phdr->p_vaddr + phdr->p_offset);\n\t\t}\n\t\tvdso.name = \"\";\n\t\tvdso.shortname = \"linux-gate.so.1\";\n\t\tvdso.relocated = 1;\n\t\tvdso.deps = (struct dso **)no_deps;\n\t\tdecode_dyn(&vdso);\n\t\tvdso.prev = tail;\n\t\ttail->next = &vdso;\n\t\ttail = &vdso;\n\t}\n\n\tfor (i=0; app.dynv[i]; i+=2) {\n\t\tif (!DT_DEBUG_INDIRECT && app.dynv[i]==DT_DEBUG)\n\t\t\tapp.dynv[i+1] = (size_t)&debug;\n\t\tif (DT_DEBUG_INDIRECT && app.dynv[i]==DT_DEBUG_INDIRECT) {\n\t\t\tsize_t *ptr = (size_t *) app.dynv[i+1];\n\t\t\t*ptr = (size_t)&debug;\n\t\t}\n\t}\n\n\t/* This must be done before final relocations, since it calls\n\t * malloc, which may be provided by the application. Calling any\n\t * application code prior to the jump to its entry point is not\n\t * valid in our model and does not work with FDPIC, where there\n\t * are additional relocation-like fixups that only the entry point\n\t * code can see to perform. */\n\tmain_ctor_queue = queue_ctors(&app);\n\n\t/* The main program must be relocated LAST since it may contin\n\t * copy relocations which depend on libraries' relocations. */\n\treloc_all(app.next);\n\treloc_all(&app);\n\n\tupdate_tls_size();\n\tif (libc.tls_size > sizeof builtin_tls || tls_align > MIN_TLS_ALIGN) {\n\t\tvoid *initial_tls = calloc(libc.tls_size, 1);\n\t\tif (!initial_tls) {\n\t\t\tdprintf(2, \"%s: Error getting %zu bytes thread-local storage: %m\\n\",\n\t\t\t\targv[0], libc.tls_size);\n\t\t\t_exit(127);\n\t\t}\n\t\tif (__init_tp(__copy_tls(initial_tls)) < 0) {\n\t\t\ta_crash();\n\t\t}\n\t} else {\n\t\tsize_t tmp_tls_size = libc.tls_size;\n\t\tpthread_t self = __pthread_self();\n\t\t/* Temporarily set the tls size to the full size of\n\t\t * builtin_tls so that __copy_tls will use the same layout\n\t\t * as it did for before. Then check, just to be safe. */\n\t\tlibc.tls_size = sizeof builtin_tls;\n\t\tif (__copy_tls((void*)builtin_tls) != self) a_crash();\n\t\tlibc.tls_size = tmp_tls_size;\n\t}\n\tstatic_tls_cnt = tls_cnt;\n\n\tif (ldso_fail) _exit(127);\n\tif (ldd_mode) _exit(0);\n\n\t/* Determine if malloc was interposed by a replacement implementation\n\t * so that calloc and the memalign family can harden against the\n\t * possibility of incomplete replacement. */\n\tif (find_sym(head, \"malloc\", 1).dso != &ldso)\n\t\t__malloc_replaced = 1;\n\n\t/* Switch to runtime mode: any further failures in the dynamic\n\t * linker are a reportable failure rather than a fatal startup\n\t * error. */\n\truntime = 1;\n\n\tdebug.ver = 1;\n\tdebug.bp = dl_debug_state;\n\tdebug.head = head;\n\tdebug.base = ldso.base;\n\tdebug.state = 0;\n\t_dl_debug_state();\n\n\tif (replace_argv0) argv[0] = replace_argv0;\n\n\terrno = 0;\n\n\tCRTJMP((void *)aux[AT_ENTRY], argv-1);\n\tfor(;;);\n}\n\nstatic void prepare_lazy(struct dso *p)\n{\n\tsize_t dyn[DYN_CNT], n, flags1=0;\n\tdecode_vec(p->dynv, dyn, DYN_CNT);\n\tsearch_vec(p->dynv, &flags1, DT_FLAGS_1);\n\tif (dyn[DT_BIND_NOW] || (dyn[DT_FLAGS] & DF_BIND_NOW) || (flags1 & DF_1_NOW))\n\t\treturn;\n\tn = dyn[DT_RELSZ]/2 + dyn[DT_RELASZ]/3 + dyn[DT_PLTRELSZ]/2 + 1;\n\tif (NEED_MIPS_GOT_RELOCS) {\n\t\tsize_t j=0; search_vec(p->dynv, &j, DT_MIPS_GOTSYM);\n\t\tsize_t i=0; search_vec(p->dynv, &i, DT_MIPS_SYMTABNO);\n\t\tn += i-j;\n\t}\n\tp->lazy = calloc(n, 3*sizeof(size_t));\n\tif (!p->lazy) {\n\t\terror(\"Error preparing lazy relocation for %s: %m\", p->name);\n\t\tlongjmp(*rtld_fail, 1);\n\t}\n\tp->lazy_next = lazy_head;\n\tlazy_head = p;\n}\n\nvoid *dlopen(const char *file, int mode)\n{\n\tstruct dso *volatile p, *orig_tail, *orig_syms_tail, *orig_lazy_head, *next;\n\tstruct tls_module *orig_tls_tail;\n\tsize_t orig_tls_cnt, orig_tls_offset, orig_tls_align;\n\tsize_t i;\n\tint cs;\n\tjmp_buf jb;\n\tstruct dso **volatile ctor_queue = 0;\n\n\tif (!file) return head;\n\n\tpthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &cs);\n\tpthread_rwlock_wrlock(&lock);\n\t__inhibit_ptc();\n\n\tp = 0;\n\tif (shutting_down) {\n\t\terror(\"Cannot dlopen while program is exiting.\");\n\t\tgoto end;\n\t}\n\torig_tls_tail = tls_tail;\n\torig_tls_cnt = tls_cnt;\n\torig_tls_offset = tls_offset;\n\torig_tls_align = tls_align;\n\torig_lazy_head = lazy_head;\n\torig_syms_tail = syms_tail;\n\torig_tail = tail;\n\tnoload = mode & RTLD_NOLOAD;\n\n\trtld_fail = &jb;\n\tif (setjmp(*rtld_fail)) {\n\t\t/* Clean up anything new that was (partially) loaded */\n\t\trevert_syms(orig_syms_tail);\n\t\tfor (p=orig_tail->next; p; p=next) {\n\t\t\tnext = p->next;\n\t\t\twhile (p->td_index) {\n\t\t\t\tvoid *tmp = p->td_index->next;\n\t\t\t\tfree(p->td_index);\n\t\t\t\tp->td_index = tmp;\n\t\t\t}\n\t\t\tfree(p->funcdescs);\n\t\t\tif (p->rpath != p->rpath_orig)\n\t\t\t\tfree(p->rpath);\n\t\t\tfree(p->deps);\n\t\t\tunmap_library(p);\n\t\t\tfree(p);\n\t\t}\n\t\tfree(ctor_queue);\n\t\tctor_queue = 0;\n\t\tif (!orig_tls_tail) libc.tls_head = 0;\n\t\ttls_tail = orig_tls_tail;\n\t\tif (tls_tail) tls_tail->next = 0;\n\t\ttls_cnt = orig_tls_cnt;\n\t\ttls_offset = orig_tls_offset;\n\t\ttls_align = orig_tls_align;\n\t\tlazy_head = orig_lazy_head;\n\t\ttail = orig_tail;\n\t\ttail->next = 0;\n\t\tp = 0;\n\t\tgoto end;\n\t} else p = load_library(file, head);\n\n\tif (!p) {\n\t\terror(noload ?\n\t\t\t\"Library %s is not already loaded\" :\n\t\t\t\"Error loading shared library %s: %m\",\n\t\t\tfile);\n\t\tgoto end;\n\t}\n\n\t/* First load handling */\n\tload_deps(p);\n\textend_bfs_deps(p);\n\tpthread_mutex_lock(&init_fini_lock);\n\tif (!p->constructed) ctor_queue = queue_ctors(p);\n\tpthread_mutex_unlock(&init_fini_lock);\n\tif (!p->relocated && (mode & RTLD_LAZY)) {\n\t\tprepare_lazy(p);\n\t\tfor (i=0; p->deps[i]; i++)\n\t\t\tif (!p->deps[i]->relocated)\n\t\t\t\tprepare_lazy(p->deps[i]);\n\t}\n\tif (!p->relocated || (mode & RTLD_GLOBAL)) {\n\t\t/* Make new symbols global, at least temporarily, so we can do\n\t\t * relocations. If not RTLD_GLOBAL, this is reverted below. */\n\t\tadd_syms(p);\n\t\tfor (i=0; p->deps[i]; i++)\n\t\t\tadd_syms(p->deps[i]);\n\t}\n\tif (!p->relocated) {\n\t\treloc_all(p);\n\t}\n\n\t/* If RTLD_GLOBAL was not specified, undo any new additions\n\t * to the global symbol table. This is a nop if the library was\n\t * previously loaded and already global. */\n\tif (!(mode & RTLD_GLOBAL))\n\t\trevert_syms(orig_syms_tail);\n\n\t/* Processing of deferred lazy relocations must not happen until\n\t * the new libraries are committed; otherwise we could end up with\n\t * relocations resolved to symbol definitions that get removed. */\n\tredo_lazy_relocs();\n\n\tupdate_tls_size();\n\tif (tls_cnt != orig_tls_cnt)\n\t\tinstall_new_tls();\n\t_dl_debug_state();\n\torig_tail = tail;\nend:\n\t__release_ptc();\n\tif (p) gencnt++;\n\tpthread_rwlock_unlock(&lock);\n\tif (ctor_queue) {\n\t\tdo_init_fini(ctor_queue);\n\t\tfree(ctor_queue);\n\t}\n\tpthread_setcancelstate(cs, 0);\n\treturn p;\n}\n\nhidden int __dl_invalid_handle(void *h)\n{\n\tstruct dso *p;\n\tfor (p=head; p; p=p->next) if (h==p) return 0;\n\terror(\"Invalid library handle %p\", (void *)h);\n\treturn 1;\n}\n\nstatic void *addr2dso(size_t a)\n{\n\tstruct dso *p;\n\tsize_t i;\n\tif (DL_FDPIC) for (p=head; p; p=p->next) {\n\t\ti = count_syms(p);\n\t\tif (a-(size_t)p->funcdescs < i*sizeof(*p->funcdescs))\n\t\t\treturn p;\n\t}\n\tfor (p=head; p; p=p->next) {\n\t\tif (DL_FDPIC && p->loadmap) {\n\t\t\tfor (i=0; i<p->loadmap->nsegs; i++) {\n\t\t\t\tif (a-p->loadmap->segs[i].p_vaddr\n\t\t\t\t    < p->loadmap->segs[i].p_memsz)\n\t\t\t\t\treturn p;\n\t\t\t}\n\t\t} else {\n\t\t\tPhdr *ph = p->phdr;\n\t\t\tsize_t phcnt = p->phnum;\n\t\t\tsize_t entsz = p->phentsize;\n\t\t\tsize_t base = (size_t)p->base;\n\t\t\tfor (; phcnt--; ph=(void *)((char *)ph+entsz)) {\n\t\t\t\tif (ph->p_type != PT_LOAD) continue;\n\t\t\t\tif (a-base-ph->p_vaddr < ph->p_memsz)\n\t\t\t\t\treturn p;\n\t\t\t}\n\t\t\tif (a-(size_t)p->map < p->map_len)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void *do_dlsym(struct dso *p, const char *s, void *ra)\n{\n\tsize_t i;\n\tuint32_t h = 0, gh = 0, *ght;\n\tSym *sym;\n\tif (p == head || p == RTLD_DEFAULT || p == RTLD_NEXT) {\n\t\tif (p == RTLD_DEFAULT) {\n\t\t\tp = head;\n\t\t} else if (p == RTLD_NEXT) {\n\t\t\tp = addr2dso((size_t)ra);\n\t\t\tif (!p) p=head;\n\t\t\tp = p->next;\n\t\t}\n\t\tstruct symdef def = find_sym(p, s, 0);\n\t\tif (!def.sym) goto failed;\n\t\tif ((def.sym->st_info&0xf) == STT_TLS)\n\t\t\treturn __tls_get_addr((tls_mod_off_t []){def.dso->tls_id, def.sym->st_value-DTP_OFFSET});\n\t\tif (DL_FDPIC && (def.sym->st_info&0xf) == STT_FUNC)\n\t\t\treturn def.dso->funcdescs + (def.sym - def.dso->syms);\n\t\treturn laddr(def.dso, def.sym->st_value);\n\t}\n\tif (__dl_invalid_handle(p))\n\t\treturn 0;\n\tif ((ght = p->ghashtab)) {\n\t\tgh = gnu_hash(s);\n\t\tsym = gnu_lookup(gh, ght, p, s);\n\t} else {\n\t\th = sysv_hash(s);\n\t\tsym = sysv_lookup(s, h, p);\n\t}\n\tif (sym && (sym->st_info&0xf) == STT_TLS)\n\t\treturn __tls_get_addr((tls_mod_off_t []){p->tls_id, sym->st_value-DTP_OFFSET});\n\tif (DL_FDPIC && sym && sym->st_shndx && (sym->st_info&0xf) == STT_FUNC)\n\t\treturn p->funcdescs + (sym - p->syms);\n\tif (sym && sym->st_value && (1<<(sym->st_info&0xf) & OK_TYPES))\n\t\treturn laddr(p, sym->st_value);\n\tfor (i=0; p->deps[i]; i++) {\n\t\tif ((ght = p->deps[i]->ghashtab)) {\n\t\t\tif (!gh) gh = gnu_hash(s);\n\t\t\tsym = gnu_lookup(gh, ght, p->deps[i], s);\n\t\t} else {\n\t\t\tif (!h) h = sysv_hash(s);\n\t\t\tsym = sysv_lookup(s, h, p->deps[i]);\n\t\t}\n\t\tif (sym && (sym->st_info&0xf) == STT_TLS)\n\t\t\treturn __tls_get_addr((tls_mod_off_t []){p->deps[i]->tls_id, sym->st_value-DTP_OFFSET});\n\t\tif (DL_FDPIC && sym && sym->st_shndx && (sym->st_info&0xf) == STT_FUNC)\n\t\t\treturn p->deps[i]->funcdescs + (sym - p->deps[i]->syms);\n\t\tif (sym && sym->st_value && (1<<(sym->st_info&0xf) & OK_TYPES))\n\t\t\treturn laddr(p->deps[i], sym->st_value);\n\t}\nfailed:\n\terror(\"Symbol not found: %s\", s);\n\treturn 0;\n}\n\nint dladdr(const void *addr_arg, Dl_info *info)\n{\n\tsize_t addr = (size_t)addr_arg;\n\tstruct dso *p;\n\tSym *sym, *bestsym;\n\tuint32_t nsym;\n\tchar *strings;\n\tsize_t best = 0;\n\tsize_t besterr = -1;\n\n\tpthread_rwlock_rdlock(&lock);\n\tp = addr2dso(addr);\n\tpthread_rwlock_unlock(&lock);\n\n\tif (!p) return 0;\n\n\tsym = p->syms;\n\tstrings = p->strings;\n\tnsym = count_syms(p);\n\n\tif (DL_FDPIC) {\n\t\tsize_t idx = (addr-(size_t)p->funcdescs)\n\t\t\t/ sizeof(*p->funcdescs);\n\t\tif (idx < nsym && (sym[idx].st_info&0xf) == STT_FUNC) {\n\t\t\tbest = (size_t)(p->funcdescs + idx);\n\t\t\tbestsym = sym + idx;\n\t\t\tbesterr = 0;\n\t\t}\n\t}\n\n\tif (!best) for (; nsym; nsym--, sym++) {\n\t\tif (sym->st_value\n\t\t && (1<<(sym->st_info&0xf) & OK_TYPES)\n\t\t && (1<<(sym->st_info>>4) & OK_BINDS)) {\n\t\t\tsize_t symaddr = (size_t)laddr(p, sym->st_value);\n\t\t\tif (symaddr > addr || symaddr <= best)\n\t\t\t\tcontinue;\n\t\t\tbest = symaddr;\n\t\t\tbestsym = sym;\n\t\t\tbesterr = addr - symaddr;\n\t\t\tif (addr == symaddr)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (best && besterr > bestsym->st_size-1) {\n\t\tbest = 0;\n\t\tbestsym = 0;\n\t}\n\n\tinfo->dli_fname = p->name;\n\tinfo->dli_fbase = p->map;\n\n\tif (!best) {\n\t\tinfo->dli_sname = 0;\n\t\tinfo->dli_saddr = 0;\n\t\treturn 1;\n\t}\n\n\tif (DL_FDPIC && (bestsym->st_info&0xf) == STT_FUNC)\n\t\tbest = (size_t)(p->funcdescs + (bestsym - p->syms));\n\tinfo->dli_sname = strings + bestsym->st_name;\n\tinfo->dli_saddr = (void *)best;\n\n\treturn 1;\n}\n\nhidden void *__dlsym(void *restrict p, const char *restrict s, void *restrict ra)\n{\n\tvoid *res;\n\tpthread_rwlock_rdlock(&lock);\n\tres = do_dlsym(p, s, ra);\n\tpthread_rwlock_unlock(&lock);\n\treturn res;\n}\n\nint dl_iterate_phdr(int(*callback)(struct dl_phdr_info *info, size_t size, void *data), void *data)\n{\n\tstruct dso *current;\n\tstruct dl_phdr_info info;\n\tint ret = 0;\n\tfor(current = head; current;) {\n\t\tinfo.dlpi_addr      = (uintptr_t)current->base;\n\t\tinfo.dlpi_name      = current->name;\n\t\tinfo.dlpi_phdr      = current->phdr;\n\t\tinfo.dlpi_phnum     = current->phnum;\n\t\tinfo.dlpi_adds      = gencnt;\n\t\tinfo.dlpi_subs      = 0;\n\t\tinfo.dlpi_tls_modid = current->tls_id;\n\t\tinfo.dlpi_tls_data  = current->tls.image;\n\n\t\tret = (callback)(&info, sizeof (info), data);\n\n\t\tif (ret != 0) break;\n\n\t\tpthread_rwlock_rdlock(&lock);\n\t\tcurrent = current->next;\n\t\tpthread_rwlock_unlock(&lock);\n\t}\n\treturn ret;\n}\n\nstatic void error(const char *fmt, ...)\n{\n\tva_list ap;\n\tva_start(ap, fmt);\n\tif (!runtime) {\n\t\tvdprintf(2, fmt, ap);\n\t\tdprintf(2, \"\\n\");\n\t\tldso_fail = 1;\n\t\tva_end(ap);\n\t\treturn;\n\t}\n\t__dl_vseterr(fmt, ap);\n\tva_end(ap);\n}\n"
    },
    "skipped": [],
    "total_files": 2502
}