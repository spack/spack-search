{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-nbdkit-1.23.4-zdmjm7bz4ia3c42zyid3wwz4ba2luhs6/spack-src/server/internal.h": "/* nbdkit\n * Copyright (C) 2013-2020 Red Hat Inc.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * * Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * * Neither the name of Red Hat nor the names of its contributors may be\n * used to endorse or promote products derived from this software without\n * specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY RED HAT AND CONTRIBUTORS ''AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RED HAT OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#ifndef NBDKIT_INTERNAL_H\n#define NBDKIT_INTERNAL_H\n\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <pthread.h>\n\n#ifdef HAVE_SYS_SOCKET_H\n#include <sys/socket.h>\n#endif\n\n#define NBDKIT_API_VERSION 2\n#define NBDKIT_INTERNAL\n#include \"nbdkit-plugin.h\"\n#include \"nbdkit-filter.h\"\n#include \"cleanup.h\"\n#include \"nbd-protocol.h\"\n#include \"unix-path-max.h\"\n#include \"vector.h\"\n#include \"windows-compat.h\"\n\n/* Define unlikely macro, but only for GCC.  These are used to move\n * debug and error handling code out of hot paths.\n */\n#if defined(__GNUC__)\n#define unlikely(x) __builtin_expect (!!(x), 0)\n#define if_verbose if (unlikely (verbose))\n#else\n#define unlikely(x) (x)\n#define if_verbose if (verbose)\n#endif\n\n#if HAVE_VALGRIND\n# include <valgrind.h>\n/* http://valgrind.org/docs/manual/faq.html#faq.unhelpful */\n# define DO_DLCLOSE !RUNNING_ON_VALGRIND\n#elif defined(__SANITIZE_ADDRESS__)\n# define DO_DLCLOSE 0\n#elif ENABLE_LIBFUZZER\n/* XXX This causes dlopen in the server to leak during fuzzing.\n * However it is necessary because of\n * https://bugs.llvm.org/show_bug.cgi?id=43917\n */\n# define DO_DLCLOSE 0\n#else\n# define DO_DLCLOSE 1\n#endif\n\n/* Declare program_name. */\n#if HAVE_DECL_PROGRAM_INVOCATION_SHORT_NAME == 1\n#include <errno.h>\n#define program_name program_invocation_short_name\n#else\n#define program_name \"nbdkit\"\n#endif\n\n#define container_of(ptr, type, member) ({                       \\\n      const typeof (((type *) 0)->member) *__mptr = (ptr);       \\\n      (type *) ((char *) __mptr - offsetof(type, member));       \\\n    })\n\n#define debug(fs, ...)                                   \\\n  do {                                                   \\\n    if_verbose                                           \\\n      nbdkit_debug ((fs), ##__VA_ARGS__);                \\\n  } while (0)\n\n/* Maximum read or write request that we will handle. */\n#define MAX_REQUEST_SIZE (64 * 1024 * 1024)\n\n/* main.c */\nenum log_to {\n  LOG_TO_DEFAULT,        /* --log not specified: log to stderr, unless\n                            we forked into the background in which\n                            case log to syslog */\n  LOG_TO_STDERR,         /* --log=stderr forced on the command line */\n  LOG_TO_SYSLOG,         /* --log=syslog forced on the command line */\n  LOG_TO_NULL,           /* --log=null forced on the command line */\n};\n\nextern struct debug_flag *debug_flags;\nextern const char *export_name;\nextern bool foreground;\nextern const char *ipaddr;\nextern enum log_to log_to;\nextern unsigned mask_handshake;\nextern bool newstyle;\nextern bool no_sr;\nextern const char *port;\nextern bool read_only;\nextern const char *run;\nextern bool listen_stdin;\nextern bool configured;\nextern const char *selinux_label;\nextern unsigned threads;\nextern int tls;\nextern const char *tls_certificates_dir;\nextern const char *tls_psk;\nextern bool tls_verify_peer;\nextern char *unixsocket;\nextern const char *user, *group;\nextern bool verbose;\nextern int saved_stdin;\nextern int saved_stdout;\n\n/* Linked list of backends.  Each backend struct is followed by either\n * a filter or plugin struct.  \"top\" points to the first one.  They\n * are linked through the backend->next field.\n *\n *         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n * top \u2500\u2500\u2500\u25b6\u2502 backend  \u2502\u2500\u2500\u2500\u25b6\u2502 backend  \u2502\u2500\u2500\u2500\u25b6\u2502 backend  \u2502\n *         \u2502 b->i = 2 \u2502    \u2502 b->i = 1 \u2502    \u2502 b->i = 0 \u2502\n *         \u2502 filter   \u2502    \u2502 filter   \u2502    \u2502 plugin   \u2502\n *         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n */\nextern struct backend *top;\n#define for_each_backend(b) for (b = top; b != NULL; b = b->next)\n\n/* quit.c */\nextern volatile int quit;\n#ifndef WIN32\nextern int quit_fd;\n#else\nextern HANDLE quit_fd;\n#endif\nextern void set_up_quit_pipe (void);\nextern void close_quit_pipe (void);\nextern void handle_quit (int sig);\n\n/* signals.c */\nextern void set_up_signals (void);\n\n/* background.c */\nextern bool forked_into_background;\nextern void fork_into_background (void);\n\n/* captive.c */\nextern void run_command (void);\n\n/* socket-activation.c */\n#define FIRST_SOCKET_ACTIVATION_FD 3 /* defined by systemd ABI */\nextern unsigned int get_socket_activation (void);\n\n/* usergroup.c */\nextern void change_user (void);\n\n/* connections.c */\n\n/* Flags for connection_send_function */\nenum {\n  SEND_MORE = 1, /* Hint to use MSG_MORE/corking to group send()s */\n};\n\ntypedef int (*connection_recv_function) (void *buf, size_t len)\n  __attribute__((__nonnull__ (1)));\ntypedef int (*connection_send_function) (const void *buf, size_t len,\n                                         int flags)\n  __attribute__((__nonnull__ (1)));\ntypedef void (*connection_close_function) (void);\n\n/* struct handle stores data per connection and backend.  Primarily\n * this is the filter or plugin handle, but other state is also stored\n * here.\n *\n * Use get_handle (conn, 0) to return the struct handle for the\n * plugin, and get_handle (conn, b->i) to return the struct handle for\n * the i'th backend (if b->i >= 1 then for a filter).\n */\nenum {\n  HANDLE_OPEN = 1,      /* Set if .open passed, so .close is needed */\n  HANDLE_CONNECTED = 2, /* Set if .prepare passed, so .finalize is needed */\n  HANDLE_FAILED = 4,    /* Set if .finalize failed */\n};\n\nstruct handle {\n  void *handle;         /* Plugin or filter handle. */\n\n  unsigned char state;  /* Bitmask of HANDLE_* values */\n\n  char *default_exportname;\n\n  uint64_t exportsize;\n  int can_write;\n  int can_flush;\n  int is_rotational;\n  int can_trim;\n  int can_zero;\n  int can_fast_zero;\n  int can_fua;\n  int can_multi_conn;\n  int can_extents;\n  int can_cache;\n};\n\nstatic inline void\nreset_handle (struct handle *h)\n{\n  h->handle = NULL;\n  h->state = 0;\n  free (h->default_exportname);\n  h->default_exportname = NULL;\n  h->exportsize = -1;\n  h->can_write = -1;\n  h->can_flush = -1;\n  h->is_rotational = -1;\n  h->can_trim = -1;\n  h->can_zero = -1;\n  h->can_fast_zero = -1;\n  h->can_fua = -1;\n  h->can_multi_conn = -1;\n  h->can_extents = -1;\n  h->can_cache = -1;\n}\n\nDEFINE_VECTOR_TYPE(string_vector, char *);\nstruct connection {\n  pthread_mutex_t request_lock;\n  pthread_mutex_t read_lock;\n  pthread_mutex_t write_lock;\n  pthread_mutex_t status_lock;\n\n  int status; /* 1 for more I/O with client, 0 for shutdown, -1 on error */\n  int status_pipe[2]; /* track status changes via poll when nworkers > 1 */\n  void *crypto_session;\n  int nworkers;\n\n  struct handle *handles;       /* One per plugin and filter. */\n  size_t nr_handles;\n\n  uint32_t cflags;\n  uint16_t eflags;\n  bool handshake_complete;\n  bool using_tls;\n  bool structured_replies;\n  bool meta_context_base_allocation;\n\n  string_vector interns;\n  char *exportname_from_set_meta_context;\n  const char *exportname;\n\n  int sockin, sockout;\n  connection_recv_function recv;\n  connection_send_function send;\n  connection_close_function close;\n};\n\nstatic inline struct handle *\nget_handle (struct connection *conn, int i)\n{\n  return &conn->handles[i];\n}\n\nextern void handle_single_connection (int sockin, int sockout);\nextern int connection_get_status (void);\nextern int connection_set_status (int value);\n\n/* protocol-handshake.c */\nextern int protocol_handshake (void);\nextern int protocol_common_open (uint64_t *exportsize, uint16_t *flags,\n                                 const char *exportname)\n  __attribute__((__nonnull__ (1, 2, 3)));\n\n/* protocol-handshake-oldstyle.c */\nextern int protocol_handshake_oldstyle (void);\n\n/* protocol-handshake-newstyle.c */\nextern int protocol_handshake_newstyle (void);\n\n/* protocol.c */\nextern int protocol_recv_request_send_reply (void);\n\n/* The context ID of base:allocation.  As far as I can tell it doesn't\n * matter what this is as long as nbdkit always returns the same\n * number.\n */\n#define base_allocation_id 1\n\n/* public.c */\nextern void free_interns (void);\n\n/* crypto.c */\n#define root_tls_certificates_dir sysconfdir \"/pki/\" PACKAGE_NAME\nextern void crypto_init (bool tls_set_on_cli);\nextern void crypto_free (void);\nextern int crypto_negotiate_tls (int sockin, int sockout);\n\n/* debug-flags.c */\n/* This macro only needs to be used for server debug flags\n * (-D nbdkit.*) and it's only needed because of Windows.\n */\n#ifndef WIN32\n#define SERVER_DEBUG_FLAG(flag) int flag\n#else\n#define SERVER_DEBUG_FLAG(flag) extern __declspec(dllexport) int flag; int flag\n#endif\nextern void add_debug_flag (const char *arg);\nextern void apply_debug_flags (void *dl, const char *name);\nextern void free_debug_flags (void);\n\n/* log.c */\nextern void log_verror (const char *fs, va_list args);\n\n/* log-*.c */\nextern void log_stderr_verror (const char *fs, va_list args)\n  __attribute__((__format__ (printf, 1, 0)));\nextern void log_syslog_verror (const char *fs, va_list args)\n  __attribute__((__format__ (printf, 1, 0)));\n\n/* vfprintf.c */\n#if !HAVE_VFPRINTF_PERCENT_M\n#include <stdio.h>\n#define vfprintf replace_vfprintf\nextern int replace_vfprintf (FILE *f, const char *fmt, va_list args)\n  __attribute__((__format__ (printf, 2, 0)));\n#endif\n\n/* backend.c */\nstruct backend {\n  /* Next filter or plugin in the chain.  This is always NULL for\n   * plugins and never NULL for filters.\n   */\n  struct backend *next;\n\n  /* A unique index used to fetch the handle from the connections\n   * object.  The plugin (last in the chain) has index 0, and the\n   * filters have index 1, 2, ... depending how \"far\" they are from\n   * the plugin.\n   */\n  size_t i;\n\n  /* The type of backend: filter or plugin. */\n  const char *type;\n\n  /* A copy of the backend name that survives a dlclose. */\n  char *name;\n\n  /* The file the backend was loaded from. */\n  char *filename;\n\n  /* The dlopen handle for the backend. */\n  void *dl;\n\n  /* Backend callbacks. All are required. */\n  void (*free) (struct backend *);\n  int (*thread_model) (struct backend *);\n  const char *(*plugin_name) (struct backend *);\n  void (*usage) (struct backend *);\n  const char *(*version) (struct backend *);\n  void (*dump_fields) (struct backend *);\n  void (*config) (struct backend *, const char *key, const char *value);\n  void (*config_complete) (struct backend *);\n  const char *(*magic_config_key) (struct backend *);\n  void (*get_ready) (struct backend *);\n  void (*after_fork) (struct backend *);\n  int (*preconnect) (struct backend *, int readonly);\n  int (*list_exports) (struct backend *, int readonly, int default_only,\n                       struct nbdkit_exports *exports);\n  void *(*open) (struct backend *, int readonly, const char *exportname,\n                 int is_tls);\n  int (*prepare) (struct backend *, void *handle, int readonly);\n  int (*finalize) (struct backend *, void *handle);\n  void (*close) (struct backend *, void *handle);\n\n  int64_t (*get_size) (struct backend *, void *handle);\n  int (*can_write) (struct backend *, void *handle);\n  int (*can_flush) (struct backend *, void *handle);\n  int (*is_rotational) (struct backend *, void *handle);\n  int (*can_trim) (struct backend *, void *handle);\n  int (*can_zero) (struct backend *, void *handle);\n  int (*can_fast_zero) (struct backend *, void *handle);\n  int (*can_extents) (struct backend *, void *handle);\n  int (*can_fua) (struct backend *, void *handle);\n  int (*can_multi_conn) (struct backend *, void *handle);\n  int (*can_cache) (struct backend *, void *handle);\n\n  int (*pread) (struct backend *, void *handle,\n                void *buf, uint32_t count, uint64_t offset,\n                uint32_t flags, int *err);\n  int (*pwrite) (struct backend *, void *handle,\n                 const void *buf, uint32_t count, uint64_t offset,\n                 uint32_t flags, int *err);\n  int (*flush) (struct backend *, void *handle, uint32_t flags, int *err);\n  int (*trim) (struct backend *, void *handle,\n               uint32_t count, uint64_t offset, uint32_t flags, int *err);\n  int (*zero) (struct backend *, void *handle,\n               uint32_t count, uint64_t offset, uint32_t flags, int *err);\n  int (*extents) (struct backend *, void *handle,\n                  uint32_t count, uint64_t offset, uint32_t flags,\n                  struct nbdkit_extents *extents, int *err);\n  int (*cache) (struct backend *, void *handle,\n                uint32_t count, uint64_t offset, uint32_t flags, int *err);\n};\n\nextern void backend_init (struct backend *b, struct backend *next, size_t index,\n                          const char *filename, void *dl, const char *type)\n  __attribute__((__nonnull__ (1, 4, 5, 6)));\nextern void backend_load (struct backend *b, const char *name,\n                          void (*load) (void))\n  __attribute__((__nonnull__ (1 /* not 2 */)));\nextern void backend_unload (struct backend *b, void (*unload) (void))\n  __attribute__((__nonnull__ (1)));\n\nextern int backend_list_exports (struct backend *b, int readonly,\n                                 int default_only,\n                                 struct nbdkit_exports *exports)\n  __attribute__((__nonnull__ (1, 4)));\n/* exportname is only valid for this call and almost certainly will be\n * freed on return of this function, so backends must save the\n * exportname if they need to refer to it later.\n */\nextern int backend_open (struct backend *b,\n                         int readonly, const char *exportname)\n  __attribute__((__nonnull__ (1, 3)));\nextern int backend_prepare (struct backend *b)\n  __attribute__((__nonnull__ (1)));\nextern int backend_finalize (struct backend *b)\n  __attribute__((__nonnull__ (1)));\nextern void backend_close (struct backend *b)\n  __attribute__((__nonnull__ (1)));\nextern bool backend_valid_range (struct backend *b,\n                                 uint64_t offset, uint32_t count)\n  __attribute__((__nonnull__ (1)));\n\nextern int backend_reopen (struct backend *b,\n                           int readonly, const char *exportname)\n  __attribute__((__nonnull__ (1, 3)));\nextern int64_t backend_get_size (struct backend *b)\n  __attribute__((__nonnull__ (1)));\nextern int backend_can_write (struct backend *b)\n  __attribute__((__nonnull__ (1)));\nextern int backend_can_flush (struct backend *b)\n  __attribute__((__nonnull__ (1)));\nextern int backend_is_rotational (struct backend *b)\n  __attribute__((__nonnull__ (1)));\nextern int backend_can_trim (struct backend *b)\n  __attribute__((__nonnull__ (1)));\nextern int backend_can_zero (struct backend *b)\n  __attribute__((__nonnull__ (1)));\nextern int backend_can_fast_zero (struct backend *b)\n  __attribute__((__nonnull__ (1)));\nextern int backend_can_extents (struct backend *b)\n  __attribute__((__nonnull__ (1)));\nextern int backend_can_fua (struct backend *b)\n  __attribute__((__nonnull__ (1)));\nextern int backend_can_multi_conn (struct backend *b)\n  __attribute__((__nonnull__ (1)));\nextern int backend_can_cache (struct backend *b)\n  __attribute__((__nonnull__ (1)));\n\nextern int backend_pread (struct backend *b,\n                          void *buf, uint32_t count, uint64_t offset,\n                          uint32_t flags, int *err)\n  __attribute__((__nonnull__ (1, 2, 6)));\nextern int backend_pwrite (struct backend *b,\n                           const void *buf, uint32_t count, uint64_t offset,\n                           uint32_t flags, int *err)\n  __attribute__((__nonnull__ (1, 2, 6)));\nextern int backend_flush (struct backend *b,\n                          uint32_t flags, int *err)\n  __attribute__((__nonnull__ (1, 3)));\nextern int backend_trim (struct backend *b,\n                         uint32_t count, uint64_t offset, uint32_t flags,\n                         int *err)\n  __attribute__((__nonnull__ (1, 5)));\nextern int backend_zero (struct backend *b,\n                         uint32_t count, uint64_t offset, uint32_t flags,\n                         int *err)\n  __attribute__((__nonnull__ (1, 5)));\nextern int backend_extents (struct backend *b,\n                            uint32_t count, uint64_t offset, uint32_t flags,\n                            struct nbdkit_extents *extents, int *err)\n  __attribute__((__nonnull__ (1, 5, 6)));\nextern int backend_cache (struct backend *b,\n                          uint32_t count, uint64_t offset,\n                          uint32_t flags, int *err)\n  __attribute__((__nonnull__ (1, 5)));\n\n/* plugins.c */\nextern struct backend *plugin_register (size_t index, const char *filename,\n                                        void *dl, struct nbdkit_plugin *(*plugin_init) (void))\n  __attribute__((__nonnull__ (2, 3, 4)));\n\n/* filters.c */\nextern struct backend *filter_register (struct backend *next, size_t index,\n                                        const char *filename, void *dl,\n                                        struct nbdkit_filter *(*filter_init) (void))\n  __attribute__((__nonnull__ (1, 3, 4, 5)));\n\n/* locks.c */\nextern unsigned thread_model;\nextern void lock_init_thread_model (void);\nextern const char *name_of_thread_model (int model);\nextern void lock_connection (void);\nextern void unlock_connection (void);\nextern void lock_request (void);\nextern void unlock_request (void);\nextern void lock_unload (void);\nextern void unlock_unload (void);\n\n/* sockets.c */\nDEFINE_VECTOR_TYPE(sockets, int);\nextern void bind_unix_socket (sockets *) __attribute__((__nonnull__ (1)));\nextern void bind_tcpip_socket (sockets *) __attribute__((__nonnull__ (1)));\nextern void bind_vsock (sockets *) __attribute__((__nonnull__ (1)));\nextern void accept_incoming_connections (const sockets *socks)\n  __attribute__((__nonnull__ (1)));\n\n/* threadlocal.c */\nextern void threadlocal_init (void);\nextern void threadlocal_new_server_thread (void);\nextern void threadlocal_set_name (const char *name)\n  __attribute__((__nonnull__ (1)));\nextern const char *threadlocal_get_name (void);\nextern void threadlocal_set_instance_num (size_t instance_num);\nextern size_t threadlocal_get_instance_num (void);\nextern void threadlocal_set_error (int err);\nextern int threadlocal_get_error (void);\nextern void *threadlocal_buffer (size_t size);\nextern void threadlocal_set_conn (struct connection *conn);\nextern struct connection *threadlocal_get_conn (void);\n\n/* Macro which sets local variable struct connection *conn from\n * thread-local storage, asserting that it is non-NULL.  If you want\n * to check if conn could be NULL (eg. outside a connection context)\n * then call threadlocal_get_conn instead.\n */\n#define GET_CONN                                        \\\n  struct connection *conn = threadlocal_get_conn ();    \\\n  assert (conn != NULL)\n\n#endif /* NBDKIT_INTERNAL_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-nbdkit-1.23.4-zdmjm7bz4ia3c42zyid3wwz4ba2luhs6/spack-src/server/main.c": "/* nbdkit\n * Copyright (C) 2013-2020 Red Hat Inc.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * * Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * * Neither the name of Red Hat nor the names of its contributors may be\n * used to endorse or promote products derived from this software without\n * specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY RED HAT AND CONTRIBUTORS ''AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RED HAT OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#include <config.h>\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <getopt.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n\n#ifdef HAVE_SYS_MMAN_H\n#include <sys/mman.h>\n#endif\n\n#ifdef HAVE_SYS_SOCKET_H\n#include <sys/socket.h>\n#endif\n\n#ifdef HAVE_LINUX_VM_SOCKETS_H\n#include <linux/vm_sockets.h>\n#endif\n\n#include <pthread.h>\n\n#include <dlfcn.h>\n\n#include \"ascii-string.h\"\n#include \"exit-with-parent.h\"\n#include \"nbd-protocol.h\"\n#include \"realpath.h\"\n#include \"strndup.h\"\n#include \"syslog.h\"\n#include \"utils.h\"\n\n#include \"internal.h\"\n#include \"options.h\"\n\n#ifdef ENABLE_LIBFUZZER\n#define main fuzzer_main\n#endif\n\nstatic char *make_random_fifo (void);\nstatic struct backend *open_plugin_so (size_t i, const char *filename, int short_name);\nstatic struct backend *open_filter_so (struct backend *next, size_t i, const char *filename, int short_name);\nstatic void start_serving (void);\nstatic void write_pidfile (void);\nstatic bool is_config_key (const char *key, size_t len);\nstatic void error_if_stdio_closed (void);\nstatic void switch_stdio (void);\nstatic void winsock_init (void);\n\nstruct debug_flag *debug_flags; /* -D */\nbool exit_with_parent;          /* --exit-with-parent */\nconst char *export_name;        /* -e */\nbool foreground;                /* -f */\nconst char *ipaddr;             /* -i */\nenum log_to log_to = LOG_TO_DEFAULT; /* --log */\nunsigned mask_handshake = ~0U;  /* --mask-handshake */\nbool newstyle = true;           /* false = -o, true = -n */\nbool no_sr;                     /* --no-sr */\nchar *pidfile;                  /* -P */\nconst char *port;               /* -p */\nbool read_only;                 /* -r */\nconst char *run;                /* --run */\nbool listen_stdin;              /* -s */\nconst char *selinux_label;      /* --selinux-label */\nbool swap;                      /* --swap */\nunsigned threads;               /* -t */\nint tls;                        /* --tls : 0=off 1=on 2=require */\nconst char *tls_certificates_dir; /* --tls-certificates */\nconst char *tls_psk;            /* --tls-psk */\nbool tls_verify_peer;           /* --tls-verify-peer */\nchar *unixsocket;               /* -U */\nconst char *user, *group;       /* -u & -g */\nbool verbose;                   /* -v */\nbool vsock;                     /* --vsock */\nunsigned int socket_activation; /* $LISTEN_FDS and $LISTEN_PID set */\nbool configured;                /* .config_complete done */\nint saved_stdin = -1;           /* dup'd stdin during -s/--run */\nint saved_stdout = -1;          /* dup'd stdout during -s/--run */\n\n/* The linked list of zero or more filters, and one plugin. */\nstruct backend *top;\n\nstatic char *random_fifo_dir = NULL;\nstatic char *random_fifo = NULL;\n\nstatic void\nusage (void)\n{\n  /* --{short,long}-options remain undocumented */\n  const char *opt_list =\n#include \"synopsis.c\"\n\t  ;\n  printf (\"%s\\n\", opt_list);\n  printf (\"Please read the nbdkit(1) manual page for full usage.\\n\");\n}\n\nstatic void\ndisplay_version (void)\n{\n  printf (\"%s %s\\n\", PACKAGE_NAME, PACKAGE_VERSION);\n}\n\nstatic void\ndump_config (void)\n{\n  CLEANUP_FREE char *binary = NULL;\n\n#ifdef __linux__\n  binary = realpath (\"/proc/self/exe\", NULL);\n#else\n#ifdef WIN32\n  /* GetModuleFileNameA has a crappy interface that prevents us from\n   * getting the length of the path so we just have to guess at an\n   * upper limit here.  It will at least truncate it properly with \\0.\n   * _get_pgmptr would be a better alternative except that it isn't\n   * implemented in MinGW.  XXX\n   */\n  binary = malloc (256);\n  if (!GetModuleFileNameA (NULL, binary, 256)) {\n    free (binary);\n    binary = NULL;\n  }\n#endif\n#endif\n\n  if (binary != NULL)\n    printf (\"%s=%s\\n\", \"binary\", binary);\n  printf (\"%s=%s\\n\", \"bindir\", bindir);\n  printf (\"%s=%s\\n\", \"filterdir\", filterdir);\n  printf (\"%s=%s\\n\", \"host_cpu\", host_cpu);\n  printf (\"%s=%s\\n\", \"host_os\", host_os);\n  printf (\"%s=%s\\n\", \"libdir\", libdir);\n  printf (\"%s=%s\\n\", \"mandir\", mandir);\n  printf (\"%s=%s\\n\", \"name\", PACKAGE_NAME);\n  printf (\"%s=%s\\n\", \"plugindir\", plugindir);\n  printf (\"%s=%s\\n\", \"root_tls_certificates_dir\", root_tls_certificates_dir);\n  printf (\"%s=%s\\n\", \"sbindir\", sbindir);\n#ifdef HAVE_LIBSELINUX\n  printf (\"selinux=yes\\n\");\n#else\n  printf (\"selinux=no\\n\");\n#endif\n  printf (\"%s=%s\\n\", \"sysconfdir\", sysconfdir);\n#ifdef HAVE_GNUTLS\n  printf (\"tls=yes\\n\");\n#else\n  printf (\"tls=no\\n\");\n#endif\n  printf (\"%s=%s\\n\", \"version\", PACKAGE_VERSION);\n  printf (\"%s=%d\\n\", \"version_major\", NBDKIT_VERSION_MAJOR);\n  printf (\"%s=%d\\n\", \"version_minor\", NBDKIT_VERSION_MINOR);\n#ifdef HAVE_LIBZSTD\n  printf (\"zstd=yes\\n\");\n#else\n  printf (\"zstd=no\\n\");\n#endif\n}\n\nint\nmain (int argc, char *argv[])\n{\n  int c;\n  bool help = false, version = false, dump_plugin = false;\n  int tls_set_on_cli = false;\n  bool short_name;\n  const char *filename;\n  char *p;\n  static struct filter_filename {\n    struct filter_filename *next;\n    const char *filename;\n  } *filter_filenames = NULL;\n  size_t i;\n  const char *magic_config_key;\n\n  error_if_stdio_closed ();\n  winsock_init ();\n\n#if !ENABLE_LIBFUZZER\n  threadlocal_init ();\n#else\n  static bool main_called = false;\n  if (!main_called) {\n    threadlocal_init ();\n    main_called = true;\n  }\n#endif\n\n  /* The default setting for TLS depends on whether we were\n   * compiled with GnuTLS.\n   */\n#ifdef HAVE_GNUTLS\n  tls = 1;\n#else\n  tls = 0;\n#endif\n\n  /* Returns 0 if no socket activation, or the number of FDs. */\n  socket_activation = get_socket_activation ();\n\n  for (;;) {\n    c = getopt_long (argc, argv, short_options, long_options, NULL);\n    if (c == -1)\n      break;\n\n    switch (c) {\n    case DUMP_CONFIG_OPTION:\n      dump_config ();\n      exit (EXIT_SUCCESS);\n\n    case DUMP_PLUGIN_OPTION:\n      dump_plugin = true;\n      break;\n\n    case EXIT_WITH_PARENT_OPTION:\n#ifdef HAVE_EXIT_WITH_PARENT\n      exit_with_parent = true;\n      foreground = true;\n      break;\n#else\n      fprintf (stderr,\n               \"%s: --exit-with-parent is not implemented \"\n               \"for this operating system\\n\",\n               program_name);\n      exit (EXIT_FAILURE);\n#endif\n\n    case FILTER_OPTION:\n      {\n        struct filter_filename *t;\n\n        t = malloc (sizeof *t);\n        if (t == NULL) {\n          perror (\"malloc\");\n          exit (EXIT_FAILURE);\n        }\n        t->next = filter_filenames;\n        t->filename = optarg;\n        filter_filenames = t;\n      }\n      break;\n\n    case LOG_OPTION:\n      if (strcmp (optarg, \"stderr\") == 0)\n        log_to = LOG_TO_STDERR;\n      else if (strcmp (optarg, \"syslog\") == 0)\n        log_to = LOG_TO_SYSLOG;\n      else if (strcmp (optarg, \"null\") == 0)\n        log_to = LOG_TO_NULL;\n      else {\n        fprintf (stderr, \"%s: \"\n                 \"--log must be \\\"stderr\\\", \\\"syslog\\\" or \\\"null\\\"\\n\",\n                 program_name);\n        exit (EXIT_FAILURE);\n      }\n      break;\n\n    case LONG_OPTIONS_OPTION:\n      for (i = 0; long_options[i].name != NULL; ++i) {\n        if (strcmp (long_options[i].name, \"long-options\") != 0 &&\n            strcmp (long_options[i].name, \"short-options\") != 0)\n          printf (\"--%s\\n\", long_options[i].name);\n      }\n      exit (EXIT_SUCCESS);\n\n    case RUN_OPTION:\n      if (socket_activation) {\n        fprintf (stderr, \"%s: cannot use socket activation with --run flag\\n\",\n                 program_name);\n        exit (EXIT_FAILURE);\n      }\n      run = optarg;\n      foreground = true;\n      break;\n\n    case SELINUX_LABEL_OPTION:\n      selinux_label = optarg;\n      break;\n\n    case SHORT_OPTIONS_OPTION:\n      for (i = 0; short_options[i]; ++i) {\n        if (short_options[i] != ':')\n          printf (\"-%c\\n\", short_options[i]);\n      }\n      exit (EXIT_SUCCESS);\n\n    case SWAP_OPTION:\n      swap = 1;\n      break;\n\n    case TLS_OPTION:\n      tls_set_on_cli = true;\n      if (ascii_strcasecmp (optarg, \"require\") == 0 ||\n          ascii_strcasecmp (optarg, \"required\") == 0 ||\n          ascii_strcasecmp (optarg, \"force\") == 0)\n        tls = 2;\n      else {\n        tls = nbdkit_parse_bool (optarg);\n        if (tls == -1)\n          exit (EXIT_FAILURE);\n      }\n      break;\n\n    case TLS_CERTIFICATES_OPTION:\n      tls_certificates_dir = optarg;\n      break;\n\n    case TLS_PSK_OPTION:\n      tls_psk = optarg;\n      break;\n\n    case TLS_VERIFY_PEER_OPTION:\n      tls_verify_peer = true;\n      break;\n\n    case VSOCK_OPTION:\n#ifdef AF_VSOCK\n      vsock = true;\n      break;\n#else\n      fprintf (stderr, \"%s: AF_VSOCK is not supported on this platform\\n\",\n               program_name);\n      exit (EXIT_FAILURE);\n#endif\n\n    case 'D':\n      add_debug_flag (optarg);\n      break;\n\n    case 'e':\n      export_name = optarg;\n      break;\n\n    case 'f':\n      foreground = true;\n      break;\n\n    case 'g':\n      group = optarg;\n      break;\n\n    case 'i':\n      if (socket_activation) {\n        fprintf (stderr, \"%s: cannot use socket activation with -i flag\\n\",\n                 program_name);\n        exit (EXIT_FAILURE);\n      }\n      ipaddr = optarg;\n      break;\n\n    case MASK_HANDSHAKE_OPTION:\n      if (nbdkit_parse_unsigned (\"mask-handshake\",\n                                 optarg, &mask_handshake) == -1)\n        exit (EXIT_FAILURE);\n      break;\n\n    case 'n':\n      newstyle = true;\n      break;\n\n    case NO_SR_OPTION:\n      no_sr = true;\n      break;\n\n    case 'o':\n      newstyle = false;\n      break;\n\n    case 'P':\n      pidfile = nbdkit_absolute_path (optarg);\n      if (pidfile == NULL)\n        exit (EXIT_FAILURE);\n      break;\n\n    case 'p':\n      if (socket_activation) {\n        fprintf (stderr, \"%s: cannot use socket activation with -p flag\\n\",\n                 program_name);\n        exit (EXIT_FAILURE);\n      }\n      port = optarg;\n      break;\n\n    case 'r':\n      read_only = true;\n      break;\n\n    case 's':\n      if (socket_activation) {\n        fprintf (stderr, \"%s: cannot use socket activation with -s flag\\n\",\n                 program_name);\n        exit (EXIT_FAILURE);\n      }\n      listen_stdin = true;\n#ifdef WIN32\n      /* This could be implemented with a bit of work.  The problem\n       * currently is that we try to use recv() on the stdio file\n       * descriptor which winsock does not support (nor Linux in\n       * fact).  We would need to implement a test to see if the file\n       * descriptor is a socket or not and use either read or recv as\n       * appropriate.\n       */\n      NOT_IMPLEMENTED_ON_WINDOWS (\"-s\");\n#endif\n      break;\n\n    case 't':\n      if (nbdkit_parse_unsigned (\"threads\", optarg, &threads) == -1)\n        exit (EXIT_FAILURE);\n      /* XXX Worth a maximimum limit on threads? */\n      break;\n\n    case 'U':\n      if (socket_activation) {\n        fprintf (stderr, \"%s: cannot use socket activation with -U flag\\n\",\n                 program_name);\n        exit (EXIT_FAILURE);\n      }\n      if (strcmp (optarg, \"-\") == 0)\n        unixsocket = make_random_fifo ();\n      else\n        unixsocket = nbdkit_absolute_path (optarg);\n      if (unixsocket == NULL)\n        exit (EXIT_FAILURE);\n      break;\n\n    case 'u':\n      user = optarg;\n      break;\n\n    case 'v':\n      verbose = true;\n      break;\n\n    case 'V':\n      version = true;\n      break;\n\n    case HELP_OPTION:\n      help = true;\n      break;\n\n    default:\n      usage ();\n      exit (EXIT_FAILURE);\n    }\n  }\n\n  /* No extra parameters. */\n  if (optind >= argc) {\n    if (help) {\n      usage ();\n      exit (EXIT_SUCCESS);\n    }\n    if (version) {\n      display_version ();\n      exit (EXIT_SUCCESS);\n    }\n    if (dump_plugin) {\n      /* Incorrect use of --dump-plugin. */\n      fprintf (stderr,\n               \"%s: use 'nbdkit plugin --dump-plugin' or\\n\"\n               \"'nbdkit /path/to/plugin.\" SOEXT \" --dump-plugin'\\n\",\n               program_name);\n      exit (EXIT_FAILURE);\n    }\n\n    /* Otherwise this is an error. */\n    fprintf (stderr,\n             \"%s: no plugins given on the command line.\\n\"\n             \"Use '%s --help' or \"\n             \"read the nbdkit(1) manual page for documentation.\\n\",\n             program_name, program_name);\n    exit (EXIT_FAILURE);\n  }\n\n  /* --tls=require and oldstyle won't work. */\n  if (tls == 2 && !newstyle) {\n    fprintf (stderr,\n             \"%s: cannot use oldstyle protocol (-o) and require TLS\\n\",\n             program_name);\n    exit (EXIT_FAILURE);\n  }\n\n  /* Set the umask to a known value.  This makes the behaviour of\n   * plugins when creating files more predictable, and also removes an\n   * implicit dependency on umask when calling mkstemp(3).\n   */\n  umask (0022);\n\n  /* If we will or might use syslog. */\n  if (log_to == LOG_TO_SYSLOG || log_to == LOG_TO_DEFAULT)\n    openlog (program_name, LOG_PID, 0);\n\n  /* Initialize TLS. */\n  crypto_init (tls_set_on_cli);\n  assert (tls != -1);\n\n  /* Implement --exit-with-parent early in case plugin initialization\n   * takes a long time and the parent exits during that time.\n   */\n#ifdef HAVE_EXIT_WITH_PARENT\n  if (exit_with_parent) {\n    if (set_exit_with_parent () == -1) {\n      perror (\"nbdkit: --exit-with-parent\");\n      exit (EXIT_FAILURE);\n    }\n  }\n#endif\n\n  /* If the user has mixed up -p/--run/-s/-U/--vsock options, then\n   * give an error.\n   *\n   * XXX Actually the server could easily be extended to handle both\n   * TCP/IP and Unix sockets, or even multiple TCP/IP ports.\n   */\n  if ((port && unixsocket) ||\n      (port && listen_stdin) ||\n      (unixsocket && listen_stdin) ||\n      (listen_stdin && run) ||\n      (listen_stdin && dump_plugin) ||\n      (vsock && unixsocket) ||\n      (vsock && listen_stdin) ||\n      (vsock && run)) {\n    fprintf (stderr,\n             \"%s: --dump-plugin, -p, --run, -s, -U or --vsock options \"\n             \"cannot be used in this combination\\n\",\n             program_name);\n    exit (EXIT_FAILURE);\n  }\n\n  /* The remaining command line arguments are the plugin name and\n   * parameters.  If --help, --version or --dump-plugin were specified\n   * then we open the plugin so that we can display the per-plugin\n   * help/version/plugin information.\n   */\n  filename = argv[optind++];\n  short_name = is_short_name (filename);\n\n  /* Is there an executable script located in the plugindir?\n   * If so we simply execute it with the current command line.\n   */\n  if (short_name) {\n    struct stat statbuf;\n    CLEANUP_FREE char *script;\n\n    if (asprintf (&script,\n                  \"%s/nbdkit-%s-plugin\", plugindir, filename) == -1) {\n      perror (\"asprintf\");\n      exit (EXIT_FAILURE);\n    }\n\n    if (stat (script, &statbuf) == 0 &&\n        (statbuf.st_mode & S_IXUSR) != 0) {\n      /* We're going to execute the plugin directly.\n       * Replace argv[0] with argv[optind-1] and move further arguments\n       * down the list.\n       */\n      argv[0] = argv[optind-1];\n      for (i = optind; i <= argc; i++)\n        argv[i-1] = argv[i];\n      execv (script, argv);\n      perror (script);\n      exit (EXIT_FAILURE);\n    }\n  }\n\n  /* Open the plugin (first) and then wrap the plugin with the\n   * filters.  The filters are wrapped in reverse order that they\n   * appear on the command line so that in the end \u2018top\u2019 points to\n   * the first filter on the command line.\n   */\n  top = open_plugin_so (0, filename, short_name);\n  i = 1;\n  while (filter_filenames) {\n    struct filter_filename *t = filter_filenames;\n\n    filename = t->filename;\n    short_name = is_short_name (filename);\n\n    top = open_filter_so (top, i++, filename, short_name);\n\n    filter_filenames = t->next;\n    free (t);\n  }\n\n  /* Apply nbdkit.* flags for the server. */\n  apply_debug_flags (RTLD_DEFAULT, \"nbdkit\");\n\n  /* Check all debug flags were used, and free them. */\n  free_debug_flags ();\n\n  if (help) {\n    struct backend *b;\n\n    usage ();\n    for_each_backend (b) {\n      printf (\"\\n\");\n      b->usage (b);\n    }\n    top->free (top);\n    exit (EXIT_SUCCESS);\n  }\n\n  if (version) {\n    const char *v;\n    struct backend *b;\n\n    display_version ();\n    for_each_backend (b) {\n      printf (\"%s\", b->name);\n      if ((v = b->version (b)) != NULL)\n        printf (\" %s\", v);\n      printf (\"\\n\");\n    }\n    top->free (top);\n    exit (EXIT_SUCCESS);\n  }\n\n  /* Call config and config_complete to parse the parameters.\n   *\n   * If the plugin provides magic_config_key then any \"bare\" values\n   * (ones not containing \"=\") are prefixed with this key.\n   *\n   * For backwards compatibility with old plugins, and to support\n   * scripting languages, if magic_config_key == NULL then if the\n   * first parameter is bare it is prefixed with the key \"script\", and\n   * any other bare parameters are errors.\n   *\n   * Keys must live for the life of nbdkit.  Since we want to avoid\n   * modifying argv (so that /proc/PID/cmdline remains sane) but we\n   * need to create a key from argv[i] = \"key=value\" we must intern\n   * the keys, which are then freed at the end of main().\n   */\n  magic_config_key = top->magic_config_key (top);\n  for (i = 0; optind < argc; ++i, ++optind) {\n    size_t n;\n\n    p = strchr (argv[optind], '=');\n    n = p - argv[optind];\n    if (p && is_config_key (argv[optind], n)) { /* Is it key=value? */\n      const char *key = nbdkit_strndup_intern (argv[optind], n);\n      if (key == NULL)\n        exit (EXIT_FAILURE);\n      top->config (top, key, p+1);\n    }\n    else if (magic_config_key == NULL) {\n      if (i == 0)               /* magic script parameter */\n        top->config (top, \"script\", argv[optind]);\n      else {\n        fprintf (stderr,\n                 \"%s: expecting key=value on the command line but got: %s\\n\",\n                 program_name, argv[optind]);\n        exit (EXIT_FAILURE);\n      }\n    }\n    else {                      /* magic config key */\n      top->config (top, magic_config_key, argv[optind]);\n    }\n  }\n\n  /* This must run after parsing the parameters so that the script can\n   * be loaded for scripting languages.  But it must be called before\n   * config_complete so that the plugin doesn't check for missing\n   * parameters.\n   */\n  if (dump_plugin) {\n    top->dump_fields (top);\n    top->free (top);\n    free_interns ();\n    exit (EXIT_SUCCESS);\n  }\n\n  top->config_complete (top);\n\n  /* Select the correct thread model based on config. */\n  lock_init_thread_model ();\n\n  /* Tell the plugin that we are about to start serving.  This must be\n   * called before we change user, fork, or open any sockets.\n   */\n  top->get_ready (top);\n\n  switch_stdio ();\n  configured = true;\n\n  start_serving ();\n\n  top->free (top);\n  top = NULL;\n\n  free (unixsocket);\n  free (pidfile);\n\n  if (random_fifo) {\n    unlink (random_fifo);\n    free (random_fifo);\n  }\n\n  if (random_fifo_dir) {\n    rmdir (random_fifo_dir);\n    free (random_fifo_dir);\n  }\n\n  crypto_free ();\n  close_quit_pipe ();\n\n  free_interns ();\n\n  /* Note: Don't exit here, otherwise this won't work when compiled\n   * for libFuzzer.\n   */\n  return EXIT_SUCCESS;\n}\n\n/* Implementation of '-U -' */\nstatic char *\nmake_random_fifo (void)\n{\n  char *sock;\n\n  random_fifo_dir = make_temporary_directory ();\n  if (random_fifo_dir == NULL) {\n    perror (\"make_temporary_directory\");\n    return NULL;\n  }\n\n  if (asprintf (&random_fifo, \"%s\" DIR_SEPARATOR_STR \"socket\",\n                random_fifo_dir) == -1) {\n    perror (\"asprintf\");\n    goto error;\n  }\n\n  sock = strdup (random_fifo);\n  if (sock == NULL) {\n    perror (\"strdup\");\n    goto error;\n  }\n\n  return sock;\n\n error:\n  free (random_fifo);\n  random_fifo = NULL;\n  rmdir (random_fifo_dir);\n  free (random_fifo_dir);\n  random_fifo_dir = NULL;\n  return NULL;\n}\n\nstatic struct backend *\nopen_plugin_so (size_t i, const char *name, int short_name)\n{\n  struct backend *ret;\n  char *filename = (char *) name;\n  bool free_filename = false;\n  void *dl;\n  struct nbdkit_plugin *(*plugin_init) (void);\n  char *error;\n\n  if (short_name) {\n    /* Short names are rewritten relative to the plugindir. */\n    if (asprintf (&filename,\n                  \"%s/nbdkit-%s-plugin.\" SOEXT, plugindir, name) == -1) {\n      perror (\"asprintf\");\n      exit (EXIT_FAILURE);\n    }\n    free_filename = true;\n  }\n\n  dl = dlopen (filename, RTLD_NOW|RTLD_GLOBAL);\n  if (dl == NULL) {\n    fprintf (stderr,\n             \"%s: error: cannot open plugin '%s': %s\\n\"\n             \"Use '%s --help' or \"\n             \"read the nbdkit(1) manual page for documentation.\\n\",\n             program_name, name, dlerror (),\n             program_name);\n    exit (EXIT_FAILURE);\n  }\n\n  /* Initialize the plugin.  See dlopen(3) to understand C weirdness. */\n  dlerror ();\n  *(void **) (&plugin_init) = dlsym (dl, \"plugin_init\");\n  if ((error = dlerror ()) != NULL) {\n    fprintf (stderr, \"%s: %s: %s\\n\", program_name, name, error);\n    exit (EXIT_FAILURE);\n  }\n  if (!plugin_init) {\n    fprintf (stderr, \"%s: %s: invalid plugin_init\\n\", program_name, name);\n    exit (EXIT_FAILURE);\n  }\n\n  /* Register the plugin. */\n  ret = plugin_register (i, filename, dl, plugin_init);\n\n  if (free_filename)\n    free (filename);\n\n  return ret;\n}\n\nstatic struct backend *\nopen_filter_so (struct backend *next, size_t i,\n                const char *name, int short_name)\n{\n  struct backend *ret;\n  char *filename = (char *) name;\n  bool free_filename = false;\n  void *dl;\n  struct nbdkit_filter *(*filter_init) (void);\n  char *error;\n\n  if (short_name) {\n    /* Short names are rewritten relative to the filterdir. */\n    if (asprintf (&filename,\n                  \"%s/nbdkit-%s-filter.\" SOEXT, filterdir, name) == -1) {\n      perror (\"asprintf\");\n      exit (EXIT_FAILURE);\n    }\n    free_filename = true;\n  }\n\n  dl = dlopen (filename, RTLD_NOW|RTLD_GLOBAL);\n  if (dl == NULL) {\n    fprintf (stderr, \"%s: error: cannot open filter '%s': %s\\n\",\n             program_name, name, dlerror ());\n    exit (EXIT_FAILURE);\n  }\n\n  /* Initialize the filter.  See dlopen(3) to understand C weirdness. */\n  dlerror ();\n  *(void **) (&filter_init) = dlsym (dl, \"filter_init\");\n  if ((error = dlerror ()) != NULL) {\n    fprintf (stderr, \"%s: %s: %s\\n\", program_name, name, error);\n    exit (EXIT_FAILURE);\n  }\n  if (!filter_init) {\n    fprintf (stderr, \"%s: %s: invalid filter_init\\n\", program_name, name);\n    exit (EXIT_FAILURE);\n  }\n\n  /* Register the filter. */\n  ret = filter_register (next, i, filename, dl, filter_init);\n\n  if (free_filename)\n    free (filename);\n\n  return ret;\n}\n\nstatic void\nstart_serving (void)\n{\n  sockets socks = empty_vector;\n  size_t i;\n\n  set_up_quit_pipe ();\n#if !ENABLE_LIBFUZZER\n  set_up_signals ();\n#endif\n\n  /* Lock the process into memory if requested. */\n  if (swap) {\n#ifdef HAVE_MLOCKALL\n    if (mlockall (MCL_CURRENT | MCL_FUTURE) == -1) {\n      fprintf (stderr, \"%s: --swap: mlockall: %m\\n\", program_name);\n      exit (EXIT_FAILURE);\n    }\n    debug (\"mlockall done\");\n#else\n    fprintf (stderr, \"%s: mlockall (--swap option) \"\n             \"is not supported on this platform\\n\", program_name);\n    exit (EXIT_FAILURE);\n#endif\n  }\n\n  /* Socket activation: the \u2018socket_activation\u2019 variable (> 0) is the\n   * number of file descriptors from FIRST_SOCKET_ACTIVATION_FD to\n   * FIRST_SOCKET_ACTIVATION_FD+socket_activation-1.\n   */\n  if (socket_activation) {\n      if (sockets_reserve (&socks, socket_activation) == -1) {\n        perror (\"realloc\");\n        exit (EXIT_FAILURE);\n      }\n    for (i = 0; i < socket_activation; ++i) {\n      int s = FIRST_SOCKET_ACTIVATION_FD + i, r;\n      /* This can't fail because of the reservation above. */\n      r = sockets_append (&socks, s);\n      assert (r == 0);\n    }\n    debug (\"using socket activation, nr_socks = %zu\", socks.size);\n    change_user ();\n    write_pidfile ();\n    top->after_fork (top);\n    accept_incoming_connections (&socks);\n    return;\n  }\n\n  /* Handling a single connection on stdin/stdout. */\n  if (listen_stdin) {\n    change_user ();\n    write_pidfile ();\n    top->after_fork (top);\n    threadlocal_new_server_thread ();\n    handle_single_connection (saved_stdin, saved_stdout);\n    return;\n  }\n\n  /* Handling multiple connections on TCP/IP, Unix domain socket or\n   * AF_VSOCK.\n   */\n  if (unixsocket)\n    bind_unix_socket (&socks);\n  else if (vsock)\n    bind_vsock (&socks);\n  else\n    bind_tcpip_socket (&socks);\n\n  run_command ();\n  change_user ();\n  fork_into_background ();\n  write_pidfile ();\n  top->after_fork (top);\n  accept_incoming_connections (&socks);\n}\n\nstatic void\nwrite_pidfile (void)\n{\n  int fd;\n  pid_t pid;\n  char pidstr[64];\n  size_t len;\n\n  if (!pidfile)\n    return;\n\n  pid = getpid ();\n  /* Don't put a trailing \\n after the PID file on Windows. It is\n   * turned into \\r\\n which causes problems if you process the file\n   * using a Unix tool like bash, especially when running the test\n   * suite.\n   */\n  snprintf (pidstr, sizeof pidstr, \"%d\"\n#ifndef WIN32\n            \"\\n\"\n#endif\n            , (int) pid);\n  len = strlen (pidstr);\n\n  fd = open (pidfile, O_WRONLY|O_TRUNC|O_CREAT|O_CLOEXEC|O_NOCTTY, 0644);\n  if (fd == -1) {\n    perror (pidfile);\n    exit (EXIT_FAILURE);\n  }\n\n  if (write (fd, pidstr, len) < len ||\n      close (fd) == -1) {\n    perror (pidfile);\n    exit (EXIT_FAILURE);\n  }\n\n  debug (\"written pidfile %s\", pidfile);\n}\n\n/* When parsing plugin and filter config key=value from the command\n * line, is the key a simple alphanumeric with period, underscore or\n * dash?\n */\nstatic bool\nis_config_key (const char *key, size_t len)\n{\n  static const char allowed_first[] =\n    \"abcdefghijklmnopqrstuvwxyz\"\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n  static const char allowed[] =\n    \"._-\"\n    \"0123456789\"\n    \"abcdefghijklmnopqrstuvwxyz\"\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\n  if (len == 0)\n    return false;\n\n  if (strchr (allowed_first, key[0]) == NULL)\n    return false;\n\n  /* This works in context of the caller since key[len] == '='. */\n  if (strspn (key, allowed) != len)\n    return false;\n\n  return true;\n}\n\n/* Refuse to run if stdin/out/err are closed, whether or not -s is used. */\nstatic void\nerror_if_stdio_closed (void)\n{\n#ifdef F_GETFL\n  if (fcntl (STDERR_FILENO, F_GETFL) == -1) {\n    /* Nowhere we can report the error. Oh well. */\n    exit (EXIT_FAILURE);\n  }\n  if (fcntl (STDIN_FILENO, F_GETFL) == -1 ||\n      fcntl (STDOUT_FILENO, F_GETFL) == -1) {\n    perror (\"expecting stdin/stdout to be opened\");\n    exit (EXIT_FAILURE);\n  }\n#endif\n}\n\n/* Sanitize stdin/stdout to /dev/null, after saving the originals\n * when needed.  We are still single-threaded at this point, and\n * already checked that stdin/out were open, so we don't have to\n * worry about other threads accidentally grabbing our intended fds,\n * or races on FD_CLOEXEC.  POSIX says that 'fflush(NULL)' is\n * supposed to reset the underlying offset of seekable stdin, but\n * glibc is buggy and requires an explicit fflush(stdin) as\n * well. https://sourceware.org/bugzilla/show_bug.cgi?id=12799\n */\nstatic void\nswitch_stdio (void)\n{\n#if defined(F_DUPFD_CLOEXEC) || defined(F_DUPFD)\n  fflush (stdin);\n  fflush (NULL);\n  if (listen_stdin || run) {\n#ifndef F_DUPFD_CLOEXEC\n#define F_DUPFD_CLOEXEC F_DUPFD\n#endif\n    saved_stdin = fcntl (STDIN_FILENO, F_DUPFD_CLOEXEC, STDERR_FILENO + 1);\n    saved_stdout = fcntl (STDOUT_FILENO, F_DUPFD_CLOEXEC, STDERR_FILENO + 1);\n#if F_DUPFD == F_DUPFD_CLOEXEC\n    saved_stdin = set_cloexec (saved_stdin);\n    saved_stdout = set_cloexec (saved_stdout);\n#endif\n    if (saved_stdin == -1 || saved_stdout == -1) {\n      perror (\"fcntl\");\n      exit (EXIT_FAILURE);\n    }\n  }\n#endif\n#ifndef WIN32\n  close (STDIN_FILENO);\n  close (STDOUT_FILENO);\n  if (open (\"/dev/null\", O_RDONLY) != STDIN_FILENO ||\n      open (\"/dev/null\", O_WRONLY) != STDOUT_FILENO) {\n    perror (\"open\");\n    exit (EXIT_FAILURE);\n  }\n#endif\n}\n\n/* On Windows the Winsock library must be initialized early.\n * https://docs.microsoft.com/en-us/windows/win32/winsock/initializing-winsock\n */\nstatic void\nwinsock_init (void)\n{\n#ifdef WIN32\n  WSADATA wsaData;\n  int result;\n\n  result = WSAStartup (MAKEWORD (2, 2), &wsaData);\n  if (result != 0) {\n    fprintf (stderr, \"WSAStartup failed: %d\\n\", result);\n    exit (EXIT_FAILURE);\n  }\n#endif\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-nbdkit-1.23.4-zdmjm7bz4ia3c42zyid3wwz4ba2luhs6/spack-src/plugins/vddk/reexec.c": "/* nbdkit\n * Copyright (C) 2013-2020 Red Hat Inc.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * * Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * * Neither the name of Red Hat nor the names of its contributors may be\n * used to endorse or promote products derived from this software without\n * specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY RED HAT AND CONTRIBUTORS ''AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RED HAT OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#include <config.h>\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <assert.h>\n#include <sys/types.h>\n\n#define NBDKIT_API_VERSION 2\n#include <nbdkit-plugin.h>\n\n#include \"cleanup.h\"\n#include \"vector.h\"\n\n#include \"vddk.h\"\n\nbool noreexec = false;          /* hidden noreexec option */\nchar *reexeced;                 /* orig LD_LIBRARY_PATH on reexec */\n\n/* Extensible buffer (string). */\nDEFINE_VECTOR_TYPE(buffer, char);\n\n#define CLEANUP_FREE_BUFFER \\\n  __attribute__((cleanup (cleanup_free_buffer)))\n\nstatic void\ncleanup_free_buffer (buffer *v)\n{\n  free (v->ptr);\n}\n\n/* List of strings. */\nDEFINE_VECTOR_TYPE(string_vector, char *);\n\n#define CLEANUP_FREE_STRING_VECTOR \\\n  __attribute__((cleanup (cleanup_free_string_vector)))\n\nstatic void\ncleanup_free_string_vector (string_vector *v)\n{\n  free (v->ptr);\n}\n\n/* Perform a re-exec that temporarily modifies LD_LIBRARY_PATH.  Does\n * not return on success.  Some failures such as /proc/self/... not\n * present are not errors - it means we are not on a Linux-like\n * platform, VDDK probably doesn't work anyway, and we simply return.\n * Memory allocation failures etc result in an exit.\n */\nstatic void\nperform_reexec (const char *env, const char *prepend)\n{\n  static const char cmdline_file[] = \"/proc/self/cmdline\";\n  static const char exe_file[] = \"/proc/self/exe\";\n  CLEANUP_FREE char *library = NULL;\n  CLEANUP_FREE_BUFFER buffer buf = empty_vector;\n  CLEANUP_FREE_STRING_VECTOR string_vector argv = empty_vector;\n  int fd;\n  size_t len;\n  bool seen_password = false;\n  char tmpfile[] = \"/tmp/XXXXXX\";\n  CLEANUP_FREE char *password_fd = NULL;\n\n  /* In order to re-exec, we need our original command line.  The\n   * Linux kernel does not make it easy to know in advance how large\n   * it was, so we just slurp in the whole file, doubling our reads\n   * until we get a short read.  This assumes nbdkit did not alter its\n   * original argv[].\n   */\n  fd = open (cmdline_file, O_RDONLY|O_CLOEXEC);\n  if (fd == -1) {\n    /* Not an error. */\n    nbdkit_debug (\"open: %s: %m\", cmdline_file);\n    return;\n  }\n\n  for (;;) {\n    ssize_t r;\n\n    if (buffer_reserve (&buf, 512) == -1) {\n      nbdkit_error (\"realloc: %m\");\n      exit (EXIT_FAILURE);\n    }\n    r = read (fd, buf.ptr + buf.size, buf.alloc - buf.size);\n    if (r == -1) {\n      nbdkit_error (\"read: %s: %m\", cmdline_file);\n      exit (EXIT_FAILURE);\n    }\n    if (r == 0)\n      break;\n    buf.size += r;\n  }\n  close (fd);\n  nbdkit_debug (\"original command line occupies %zu bytes\", buf.size);\n\n  /* Split cmdline into argv, then append one more arg. */\n  for (len = 0; len < buf.size; len += strlen (buf.ptr + len) + 1) {\n    char *arg = buf.ptr + len;  /* Next \\0-terminated argument. */\n\n    /* See below for why we eat password parameter(s). */\n    if (strncmp (arg, \"password=\", 9) == 0)\n      seen_password = true;\n    else {\n      if (string_vector_append (&argv, arg) == -1) {\n      argv_realloc_fail:\n        nbdkit_error (\"argv: realloc: %m\");\n        exit (EXIT_FAILURE);\n      }\n    }\n  }\n\n  /* password parameter requires special handling for reexec.  For\n   * password=- and password=-FD, after reexec we might try to\n   * reread these, but stdin has gone away and FD has been consumed\n   * already so that won't work.  Even password=+FILE is a little\n   * problematic since the file will be read twice, which may break\n   * for special files.\n   *\n   * However we may write the password to a temporary file and\n   * substitute password=-<FD> of the opened temporary file here.\n   * The trick is described by Eric Blake here:\n   * https://www.redhat.com/archives/libguestfs/2020-June/msg00021.html\n   *\n   * (RHBZ#1842440)\n   */\n  if (seen_password && password) {\n    fd = mkstemp (tmpfile);\n    if (fd == -1) {\n      nbdkit_error (\"mkstemp: %m\");\n      exit (EXIT_FAILURE);\n    }\n    unlink (tmpfile);\n    if (write (fd, password, strlen (password)) != strlen (password)) {\n      nbdkit_error (\"write: %m\");\n      exit (EXIT_FAILURE);\n    }\n    lseek (fd, 0, SEEK_SET);\n    if (asprintf (&password_fd, \"password=-%d\", fd) == -1) {\n      nbdkit_error (\"asprintf: %m\");\n      exit (EXIT_FAILURE);\n    }\n    if (string_vector_append (&argv, password_fd) == -1)\n      goto argv_realloc_fail;\n  }\n\n  if (!env)\n    env = \"\";\n  nbdkit_debug (\"adding reexeced_=%s\", env);\n  if (asprintf (&reexeced, \"reexeced_=%s\", env) == -1)\n    goto argv_realloc_fail;\n  if (string_vector_append (&argv, reexeced) == -1)\n    goto argv_realloc_fail;\n  if (string_vector_append (&argv, NULL) == -1)\n    goto argv_realloc_fail;\n\n  if (env[0]) {\n    if (asprintf (&library, \"%s:%s\", prepend, env) == -1)\n      assert (library == NULL);\n  }\n  else\n    library = strdup (prepend);\n  if (!library || setenv (\"LD_LIBRARY_PATH\", library, 1) == -1) {\n    nbdkit_error (\"failure to set LD_LIBRARY_PATH: %m\");\n    exit (EXIT_FAILURE);\n  }\n\n  nbdkit_debug (\"re-executing with updated LD_LIBRARY_PATH=%s\", library);\n  fflush (NULL);\n  execvp (exe_file, argv.ptr);\n  nbdkit_debug (\"execvp: %s: %m\", exe_file);\n  /* Not an error. */\n}\n\n/* See if prepend is already in LD_LIBRARY_PATH; if not, re-exec. */\nvoid\nreexec_if_needed (const char *prepend)\n{\n  const char *env = getenv (\"LD_LIBRARY_PATH\");\n  CLEANUP_FREE char *haystack = NULL;\n  CLEANUP_FREE char *needle = NULL;\n\n  if (noreexec)\n    return;\n  if (reexeced)\n    return;\n  if (env && asprintf (&haystack, \":%s:\", env) >= 0 &&\n      asprintf (&needle, \":%s:\", prepend) >= 0 &&\n      strstr (haystack, needle) != NULL)\n    return;\n\n  perform_reexec (env, prepend);\n}\n\n/* If load_library caused a re-execution with an expanded\n * LD_LIBRARY_PATH, restore it back to its original contents, passed\n * as the value of \"reexeced_\".  dlopen uses the value of\n * LD_LIBRARY_PATH cached at program startup; our change is for the\n * sake of child processes (such as --run) to see the same\n * environment as the original nbdkit saw before re-exec.\n */\nint\nrestore_ld_library_path (void)\n{\n  if (reexeced) {\n    char *env = getenv (\"LD_LIBRARY_PATH\");\n\n    nbdkit_debug (\"cleaning up after re-exec\");\n    if (!env || strstr (env, reexeced) == NULL ||\n        (libdir && strncmp (env, libdir, strlen (libdir)) != 0)) {\n      nbdkit_error (\"'reexeced_' set with garbled environment\");\n      return -1;\n    }\n    if (reexeced[0]) {\n      if (setenv (\"LD_LIBRARY_PATH\", reexeced, 1) == -1) {\n        nbdkit_error (\"setenv: %m\");\n        return -1;\n      }\n    }\n    else if (unsetenv (\"LD_LIBRARY_PATH\") == -1) {\n      nbdkit_error (\"unsetenv: %m\");\n      return -1;\n    }\n  }\n\n  return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-nbdkit-1.23.4-zdmjm7bz4ia3c42zyid3wwz4ba2luhs6/spack-src/plugins/vddk/README.VDDK": "VDDK (Virtual Disk Development Kit) is a proprietary VMware library\nfor accessing VMDK files and VMware ESX servers.  Note that the\nlicense of the VDDK library is highly restrictive, preventing any\ncommercial usage without negotiating a separate license from VMware.\n\nIn order to obtain the VDDK library you have to register for an\naccount and download it from:\n\n  https://www.vmware.com/support/developer/vddk/\n\nThis directory contains an nbdkit plugin which uses this library to\nexport VMDK files and VMware disks over NBD.\n\nYou do NOT require VDDK to compile the plugin, and the plugin does not\ncontain any VMware code.  You only need VDDK at runtime.  The plugin\nuses dlopen to load the library from a directory determined by the\nconfiguration parameter libdir (LD_LIBRARY_PATH or the standard shared\nlibrary locations can also be used, although that approach is not\nrecommended).\n\nAfter building nbdkit-vddk-plugin.so, read the man page to find out\nhow to use it (nbdkit-vddk-plugin(1)).  You'll probably also want to\nread the VDDK developer documentation.\n\nBugs\n----\n\nWrite calls sometimes return VIX_E_DISK_OUTOFRANGE even for write\nrequests which are well inside the disk.\n\nThe way we do threading in nbdkit is not congruent with the way you're\nsupposed to call VDDK from multithreaded programs.  For more\ninformation see:\nhttps://www.redhat.com/archives/libguestfs/2019-October/msg00062.html\n",
        "/tmp/vanessa/spack-stage/spack-stage-nbdkit-1.23.4-zdmjm7bz4ia3c42zyid3wwz4ba2luhs6/spack-src/plugins/vddk/vddk.c": "/* nbdkit\n * Copyright (C) 2013-2020 Red Hat Inc.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * * Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * * Neither the name of Red Hat nor the names of its contributors may be\n * used to endorse or promote products derived from this software without\n * specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY RED HAT AND CONTRIBUTORS ''AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RED HAT OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#include <config.h>\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <inttypes.h>\n#include <string.h>\n#include <unistd.h>\n#include <assert.h>\n#include <dlfcn.h>\n#include <libgen.h>\n\n#include <pthread.h>\n\n#define NBDKIT_API_VERSION 2\n#include <nbdkit-plugin.h>\n\n#include \"cleanup.h\"\n#include \"isaligned.h\"\n#include \"minmax.h\"\n#include \"rounding.h\"\n\n#include \"vddk.h\"\n#include \"vddk-structs.h\"\n\n/* Debug flags. */\nint vddk_debug_diskinfo;\nint vddk_debug_extents;\nint vddk_debug_datapath = 1;\n\n/* For each VDDK API define a static global variable.  These globals\n * are initialized when the plugin is loaded (by vddk_get_ready).\n */\n#define STUB(fn,ret,args) static ret (*fn) args\n#define OPTIONAL_STUB(fn,ret,args) static ret (*fn) args\n#include \"vddk-stubs.h\"\n#undef STUB\n#undef OPTIONAL_STUB\n\n/* Parameters passed to InitEx. */\n#define VDDK_MAJOR 5\n#define VDDK_MINOR 5\n\nstatic void *dl;                           /* dlopen handle */\nstatic bool init_called;                   /* was InitEx called */\nstatic __thread int error_suppression;     /* threadlocal error suppression */\n\nstatic char *config;                       /* config */\nstatic const char *cookie;                 /* cookie */\nstatic const char *filename;               /* file */\nchar *libdir;                              /* libdir */\nstatic uint16_t nfc_host_port;             /* nfchostport */\nchar *password;                            /* password */\nstatic uint16_t port;                      /* port */\nstatic const char *server_name;            /* server */\nstatic bool single_link;                   /* single-link */\nstatic const char *snapshot_moref;         /* snapshot */\nstatic const char *thumb_print;            /* thumbprint */\nstatic const char *transport_modes;        /* transports */\nstatic bool unbuffered;                    /* unbuffered */\nstatic const char *username;               /* user */\nstatic const char *vmx_spec;               /* vm */\nstatic bool is_remote;\n\n#define VDDK_ERROR(err, fs, ...)                                \\\n  do {                                                          \\\n    char *vddk_err_msg;                                         \\\n    vddk_err_msg = VixDiskLib_GetErrorText ((err), NULL);       \\\n    nbdkit_error (fs \": %s\", ##__VA_ARGS__, vddk_err_msg);      \\\n    VixDiskLib_FreeErrorText (vddk_err_msg);                    \\\n  } while (0)\n\n#define DEBUG_CALL(fn, fs, ...)                                 \\\n  nbdkit_debug (\"VDDK call: %s (\" fs \")\", fn, ##__VA_ARGS__)\n#define DEBUG_CALL_DATAPATH(fn, fs, ...)                        \\\n  if (vddk_debug_datapath)                                      \\\n    nbdkit_debug (\"VDDK call: %s (\" fs \")\", fn, ##__VA_ARGS__)\n\n/* Unload the plugin. */\nstatic void\nvddk_unload (void)\n{\n  if (init_called) {\n    DEBUG_CALL (\"VixDiskLib_Exit\", \"\");\n    VixDiskLib_Exit ();\n  }\n  if (dl)\n    dlclose (dl);\n  free (config);\n  free (libdir);\n  free (password);\n}\n\nstatic void\ntrim (char *str)\n{\n  size_t len = strlen (str);\n\n  if (len > 0 && str[len-1] == '\\n')\n    str[len-1] = '\\0';\n}\n\n/* Turn log messages from the library into nbdkit_debug. */\nstatic void\ndebug_function (const char *fs, va_list args)\n{\n  CLEANUP_FREE char *str = NULL;\n\n  if (vasprintf (&str, fs, args) == -1) {\n    nbdkit_debug (\"lost debug message: %s\", fs);\n    return;\n  }\n\n  trim (str);\n\n  nbdkit_debug (\"%s\", str);\n}\n\n/* Turn error messages from the library into nbdkit_error. */\nstatic void\nerror_function (const char *fs, va_list args)\n{\n  CLEANUP_FREE char *str = NULL;\n\n  /* If the thread-local error_suppression flag is non-zero then we\n   * will suppress error messages from VDDK in this thread.\n   */\n  if (error_suppression) return;\n\n  if (vasprintf (&str, fs, args) == -1) {\n    nbdkit_error (\"lost error message: %s\", fs);\n    return;\n  }\n\n  trim (str);\n\n  /* VDDK 7 added a useless error message about their \"phone home\"\n   * system called CEIP which only panics users.  Demote it to a debug\n   * statement.  https://bugzilla.redhat.com/show_bug.cgi?id=1834267\n   */\n  if (strstr (str, \"Get CEIP status failed\") != NULL) {\n    nbdkit_debug (\"%s\", str);\n    return;\n  }\n\n  nbdkit_error (\"%s\", str);\n}\n\n/* Configuration. */\nstatic int\nvddk_config (const char *key, const char *value)\n{\n  int r;\n\n  if (strcmp (key, \"config\") == 0) {\n    /* See FILENAMES AND PATHS in nbdkit-plugin(3). */\n    free (config);\n    config = nbdkit_realpath (value);\n    if (!config)\n      return -1;\n  }\n  else if (strcmp (key, \"cookie\") == 0) {\n    cookie = value;\n  }\n  else if (strcmp (key, \"file\") == 0) {\n    /* NB: Don't convert this to an absolute path, because in the\n     * remote case this can be a path located on the VMware server.\n     * For local paths the user must supply an absolute path.\n     */\n    filename = value;\n  }\n  else if (strcmp (key, \"libdir\") == 0) {\n    /* See FILENAMES AND PATHS in nbdkit-plugin(3). */\n    free (libdir);\n    libdir = nbdkit_realpath (value);\n    if (!libdir)\n      return -1;\n  }\n  else if (strcmp (key, \"nfchostport\") == 0) {\n    if (nbdkit_parse_uint16_t (\"nfchostport\", value, &nfc_host_port) == -1)\n      return -1;\n  }\n  else if (strcmp (key, \"noreexec\") == 0) {\n    /* This undocumented option disables reexec.  The caller must set\n     * LD_LIBRARY_PATH correctly as for older versions of the plugin.\n     * This option is only for use when debugging reexec, eg. to see\n     * if it causing a problem.\n     */\n    r = nbdkit_parse_bool (value);\n    if (r == -1)\n      return -1;\n    noreexec = r;\n  }\n  else if (strcmp (key, \"password\") == 0) {\n    free (password);\n    if (nbdkit_read_password (value, &password) == -1)\n      return -1;\n  }\n  else if (strcmp (key, \"port\") == 0) {\n    if (nbdkit_parse_uint16_t (\"port\", value, &port) == -1)\n      return -1;\n  }\n  else if (strcmp (key, \"reexeced_\") == 0) {\n    /* Special name because it is only for internal use. */\n    reexeced = (char *)value;\n  }\n  else if (strcmp (key, \"server\") == 0) {\n    server_name = value;\n  }\n  else if (strcmp (key, \"single-link\") == 0) {\n    r = nbdkit_parse_bool (value);\n    if (r == -1)\n      return -1;\n    single_link = r;\n  }\n  else if (strcmp (key, \"snapshot\") == 0) {\n    snapshot_moref = value;\n  }\n  else if (strcmp (key, \"thumbprint\") == 0) {\n    thumb_print = value;\n  }\n  else if (strcmp (key, \"transports\") == 0) {\n    transport_modes = value;\n  }\n  else if (strcmp (key, \"unbuffered\") == 0) {\n    r = nbdkit_parse_bool (value);\n    if (r == -1)\n      return -1;\n    unbuffered = r;\n  }\n  else if (strcmp (key, \"user\") == 0) {\n    username = value;\n  }\n  else if (strcmp (key, \"vimapiver\") == 0) {\n    /* Ignored for backwards compatibility. */\n  }\n  else if (strcmp (key, \"vm\") == 0) {\n    vmx_spec = value;\n  }\n  else {\n    nbdkit_error (\"unknown parameter '%s'\", key);\n    return -1;\n  }\n\n  return 0;\n}\n\n/* Load the VDDK library. */\nstatic void\nload_library (bool load_error_is_fatal)\n{\n  static const char *sonames[] = {\n    /* Prefer the newest library in case multiple exist.  Check two\n     * possible directories: the usual VDDK installation puts .so\n     * files in an arch-specific subdirectory of $libdir (our minimum\n     * supported version is VDDK 5.5.5, which only supports x64-64);\n     * but our testsuite is easier to write if we point libdir\n     * directly to a stub .so.\n     */\n    \"lib64/libvixDiskLib.so.7\",\n    \"libvixDiskLib.so.7\",\n    \"lib64/libvixDiskLib.so.6\",\n    \"libvixDiskLib.so.6\",\n    \"lib64/libvixDiskLib.so.5\",\n    \"libvixDiskLib.so.5\",\n  };\n  size_t i;\n  CLEANUP_FREE char *orig_error = NULL;\n\n  if (!libdir) {\n    libdir = strdup (VDDK_LIBDIR);\n    if (!libdir) {\n      nbdkit_error (\"strdup: %m\");\n      exit (EXIT_FAILURE);\n    }\n  }\n\n  for (i = 0; i < sizeof sonames / sizeof sonames[0]; ++i) {\n    CLEANUP_FREE char *path;\n\n    /* Set the full path so that dlopen will preferentially load the\n     * system libraries from the same directory.\n     */\n    if (asprintf (&path, \"%s/%s\", libdir, sonames[i]) == -1) {\n      nbdkit_error (\"asprintf: %m\");\n      exit (EXIT_FAILURE);\n    }\n\n    dl = dlopen (path, RTLD_NOW);\n    if (dl != NULL) {\n      /* Now that we found the library, ensure that LD_LIBRARY_PATH\n       * includes its directory for all future loads.  This may modify\n       * path in-place and/or re-exec nbdkit, but that's okay.\n       */\n      reexec_if_needed (dirname (path));\n      break;\n    }\n    if (i == 0) {\n      orig_error = dlerror ();\n      if (orig_error)\n        orig_error = strdup (orig_error);\n    }\n  }\n  if (dl == NULL) {\n    if (!load_error_is_fatal)\n      return;\n    nbdkit_error (\"%s\\n\\n\"\n                  \"If '%s' is located on a non-standard path you may need to\\n\"\n                  \"set libdir=/path/to/vmware-vix-disklib-distrib.\\n\\n\"\n                  \"See the nbdkit-vddk-plugin(1) man page for details.\",\n                  orig_error ? : \"(unknown error)\", sonames[0]);\n    exit (EXIT_FAILURE);\n  }\n\n  /* Load symbols. */\n#define STUB(fn,ret,args)                                         \\\n  do {                                                            \\\n    fn = dlsym (dl, #fn);                                         \\\n    if (fn == NULL) {                                             \\\n      nbdkit_error (\"required VDDK symbol \\\"%s\\\" is missing: %s\", \\\n                    #fn, dlerror ());                             \\\n      exit (EXIT_FAILURE);                                        \\\n    }                                                             \\\n  } while (0)\n#define OPTIONAL_STUB(fn,ret,args) fn = dlsym (dl, #fn)\n#include \"vddk-stubs.h\"\n#undef STUB\n#undef OPTIONAL_STUB\n}\n\nstatic int\nvddk_config_complete (void)\n{\n  if (filename == NULL) {\n    nbdkit_error (\"you must supply the file=<FILENAME> parameter \"\n                  \"after the plugin name on the command line\");\n    return -1;\n  }\n\n  /* For remote connections, check all the parameters have been\n   * passed.  Note that VDDK will segfault if parameters that it\n   * expects are NULL (and there's no real way to tell what parameters\n   * it is expecting).  This implements the same test that the VDDK\n   * sample program does.\n   */\n  is_remote =\n    vmx_spec ||\n    server_name ||\n    username ||\n    password ||\n    cookie ||\n    thumb_print ||\n    port ||\n    nfc_host_port;\n\n  if (is_remote) {\n#define missing(test, param)                                            \\\n    if (test) {                                                         \\\n      nbdkit_error (\"remote connection requested, missing parameter: %s\", \\\n                    param);                                             \\\n      return -1;                                                        \\\n    }\n    missing (!server_name, \"server\");\n    missing (!username, \"user\");\n    missing (!password, \"password\");\n    missing (!vmx_spec, \"vm\");\n#undef missing\n  }\n\n  /* Restore original LD_LIBRARY_PATH after reexec. */\n  if (restore_ld_library_path () == -1)\n    return -1;\n\n  return 0;\n}\n\n#define vddk_config_help \\\n  \"[file=]<FILENAME>   (required) The filename (eg. VMDK file) to serve.\\n\" \\\n  \"Many optional parameters are supported, see nbdkit-vddk-plugin(3).\"\n\nstatic int\nvddk_get_ready (void)\n{\n  load_library (true);\n  return 0;\n}\n\n/* Defer VDDK initialization until after fork because it is known to\n * create background threads from VixDiskLib_InitEx.  Unfortunately\n * error reporting from this callback is difficult, but we have\n * already checked in .get_ready that the library is dlopenable.\n *\n * For various hangs and failures which were caused by background\n * threads and fork see:\n * https://bugzilla.redhat.com/show_bug.cgi?id=1846309#c9\n * https://www.redhat.com/archives/libguestfs/2019-April/msg00090.html\n */\nstatic int\nvddk_after_fork (void)\n{\n  VixError err;\n\n  /* Initialize VDDK library. */\n  DEBUG_CALL (\"VixDiskLib_InitEx\",\n              \"%d, %d, &debug_fn, &error_fn, &error_fn, %s, %s\",\n              VDDK_MAJOR, VDDK_MINOR,\n              libdir, config ? : \"NULL\");\n  err = VixDiskLib_InitEx (VDDK_MAJOR, VDDK_MINOR,\n                           &debug_function, /* log function */\n                           &error_function, /* warn function */\n                           &error_function, /* panic function */\n                           libdir, config);\n  if (err != VIX_OK) {\n    VDDK_ERROR (err, \"VixDiskLib_InitEx\");\n    exit (EXIT_FAILURE);\n  }\n  init_called = true;\n\n  return 0;\n}\n\nstatic void\nvddk_dump_plugin (void)\n{\n  load_library (false);\n\n  printf (\"vddk_default_libdir=%s\\n\", VDDK_LIBDIR);\n  printf (\"vddk_has_nfchostport=1\\n\");\n\n#if defined(HAVE_DLADDR)\n  /* It would be nice to print the version of VDDK from the shared\n   * library, but VDDK does not provide it.  Instead we can get the\n   * path to the library using the glibc extension dladdr, and then\n   * resolve symlinks using realpath.  The final pathname should\n   * contain the version number.\n   */\n  Dl_info info;\n  CLEANUP_FREE char *p = NULL;\n  if (dl != NULL &&\n      dladdr (VixDiskLib_InitEx, &info) != 0 &&\n      info.dli_fname != NULL &&\n      (p = nbdkit_realpath (info.dli_fname)) != NULL) {\n    printf (\"vddk_dll=%s\\n\", p);\n  }\n#endif\n}\n\n/* The rules on threads and VDDK are here:\n * https://code.vmware.com/docs/11750/virtual-disk-development-kit-programming-guide/GUID-6BE903E8-DC70-46D9-98E4-E34A2002C2AD.html\n *\n * Before nbdkit 1.22 we used SERIALIZE_ALL_REQUESTS.  Since nbdkit\n * 1.22 we changed this to SERIALIZE_REQUESTS and added a mutex around\n * calls to VixDiskLib_Open and VixDiskLib_Close.  This is not quite\n * within the letter of the rules, but is within the spirit.\n */\n#define THREAD_MODEL NBDKIT_THREAD_MODEL_SERIALIZE_REQUESTS\n\n/* Lock protecting open/close calls - see above. */\nstatic pthread_mutex_t open_close_lock = PTHREAD_MUTEX_INITIALIZER;\n\n/* The per-connection handle. */\nstruct vddk_handle {\n  VixDiskLibConnectParams *params; /* connection parameters */\n  VixDiskLibConnection connection; /* connection */\n  VixDiskLibHandle handle;         /* disk handle */\n};\n\nstatic inline VixDiskLibConnectParams *\nallocate_connect_params (void)\n{\n  VixDiskLibConnectParams *ret;\n\n  if (VixDiskLib_AllocateConnectParams != NULL) {\n    DEBUG_CALL (\"VixDiskLib_AllocateConnectParams\", \"\");\n    ret = VixDiskLib_AllocateConnectParams ();\n  }\n  else\n    ret = calloc (1, sizeof (VixDiskLibConnectParams));\n\n  return ret;\n}\n\nstatic inline void\nfree_connect_params (VixDiskLibConnectParams *params)\n{\n  /* Only use FreeConnectParams if AllocateConnectParams was\n   * originally called.  Otherwise use free.\n   */\n  if (VixDiskLib_AllocateConnectParams != NULL) {\n    DEBUG_CALL (\"VixDiskLib_FreeConnectParams\", \"params\");\n    VixDiskLib_FreeConnectParams (params);\n  }\n  else\n    free (params);\n}\n\n/* Create the per-connection handle. */\nstatic void *\nvddk_open (int readonly)\n{\n  ACQUIRE_LOCK_FOR_CURRENT_SCOPE (&open_close_lock);\n  struct vddk_handle *h;\n  VixError err;\n  uint32_t flags;\n\n  h = malloc (sizeof *h);\n  if (h == NULL) {\n    nbdkit_error (\"malloc: %m\");\n    return NULL;\n  }\n\n  h->params = allocate_connect_params ();\n  if (h->params == NULL) {\n    nbdkit_error (\"allocate VixDiskLibConnectParams: %m\");\n    goto err0;\n  }\n\n  if (is_remote) {\n    h->params->vmxSpec = (char *) vmx_spec;\n    h->params->serverName = (char *) server_name;\n    if (cookie == NULL) {\n      h->params->credType = VIXDISKLIB_CRED_UID;\n      h->params->creds.uid.userName = (char *) username;\n      h->params->creds.uid.password = password;\n    }\n    else {\n      h->params->credType = VIXDISKLIB_CRED_SESSIONID;\n      h->params->creds.sessionId.cookie = (char *) cookie;\n      h->params->creds.sessionId.userName = (char *) username;\n      h->params->creds.sessionId.key = password;\n    }\n    h->params->thumbPrint = (char *) thumb_print;\n    h->params->port = port;\n    h->params->nfcHostPort = nfc_host_port;\n    h->params->specType = VIXDISKLIB_SPEC_VMX;\n  }\n\n  /* XXX Some documentation suggests we should call\n   * VixDiskLib_PrepareForAccess here.  It may be required for\n   * Advanced Transport modes, but I could not make it work with\n   * either ESXi or vCenter servers.\n   */\n\n  DEBUG_CALL (\"VixDiskLib_ConnectEx\",\n              \"h->params, %d, %s, %s, &connection\",\n              readonly,\n              snapshot_moref ? : \"NULL\",\n              transport_modes ? : \"NULL\");\n  err = VixDiskLib_ConnectEx (h->params,\n                              readonly,\n                              snapshot_moref,\n                              transport_modes,\n                              &h->connection);\n  if (err != VIX_OK) {\n    VDDK_ERROR (err, \"VixDiskLib_ConnectEx\");\n    goto err1;\n  }\n\n  flags = 0;\n  if (readonly)\n    flags |= VIXDISKLIB_FLAG_OPEN_READ_ONLY;\n  if (single_link)\n    flags |= VIXDISKLIB_FLAG_OPEN_SINGLE_LINK;\n  if (unbuffered)\n    flags |= VIXDISKLIB_FLAG_OPEN_UNBUFFERED;\n\n  DEBUG_CALL (\"VixDiskLib_Open\",\n              \"connection, %s, %d, &handle\", filename, flags);\n  err = VixDiskLib_Open (h->connection, filename, flags, &h->handle);\n  if (err != VIX_OK) {\n    VDDK_ERROR (err, \"VixDiskLib_Open: %s\", filename);\n    goto err2;\n  }\n\n  nbdkit_debug (\"transport mode: %s\",\n                VixDiskLib_GetTransportMode (h->handle));\n\n  return h;\n\n err2:\n  DEBUG_CALL (\"VixDiskLib_Disconnect\", \"connection\");\n  VixDiskLib_Disconnect (h->connection);\n err1:\n  free_connect_params (h->params);\n err0:\n  free (h);\n  return NULL;\n}\n\n/* Free up the per-connection handle. */\nstatic void\nvddk_close (void *handle)\n{\n  ACQUIRE_LOCK_FOR_CURRENT_SCOPE (&open_close_lock);\n  struct vddk_handle *h = handle;\n\n  DEBUG_CALL (\"VixDiskLib_Close\", \"handle\");\n  VixDiskLib_Close (h->handle);\n  DEBUG_CALL (\"VixDiskLib_Disconnect\", \"connection\");\n  VixDiskLib_Disconnect (h->connection);\n  free_connect_params (h->params);\n  free (h);\n}\n\n/* Get the file size. */\nstatic int64_t\nvddk_get_size (void *handle)\n{\n  struct vddk_handle *h = handle;\n  VixDiskLibInfo *info;\n  VixError err;\n  uint64_t size;\n\n  DEBUG_CALL (\"VixDiskLib_GetInfo\", \"handle, &info\");\n  err = VixDiskLib_GetInfo (h->handle, &info);\n  if (err != VIX_OK) {\n    VDDK_ERROR (err, \"VixDiskLib_GetInfo\");\n    return -1;\n  }\n\n  size = info->capacity * (uint64_t)VIXDISKLIB_SECTOR_SIZE;\n\n  if (vddk_debug_diskinfo) {\n    nbdkit_debug (\"disk info: capacity: %\" PRIu64 \" (size: %\" PRIi64 \")\",\n                  info->capacity, size);\n    nbdkit_debug (\"disk info: biosGeo: C:%\" PRIu32 \" H:%\" PRIu32 \" S:%\" PRIu32,\n                  info->biosGeo.cylinders,\n                  info->biosGeo.heads,\n                  info->biosGeo.sectors);\n    nbdkit_debug (\"disk info: physGeo: C:%\" PRIu32 \" H:%\" PRIu32 \" S:%\" PRIu32,\n                  info->physGeo.cylinders,\n                  info->physGeo.heads,\n                  info->physGeo.sectors);\n    nbdkit_debug (\"disk info: adapter type: %d\",\n                  (int) info->adapterType);\n    nbdkit_debug (\"disk info: num links: %d\", info->numLinks);\n    nbdkit_debug (\"disk info: parent filename hint: %s\",\n                  info->parentFileNameHint ? : \"NULL\");\n    nbdkit_debug (\"disk info: uuid: %s\",\n                  info->uuid ? : \"NULL\");\n  }\n\n  DEBUG_CALL (\"VixDiskLib_FreeInfo\", \"info\");\n  VixDiskLib_FreeInfo (info);\n\n  return (int64_t) size;\n}\n\n/* Read data from the file.\n *\n * Note that reads have to be aligned to sectors (XXX).\n */\nstatic int\nvddk_pread (void *handle, void *buf, uint32_t count, uint64_t offset,\n            uint32_t flags)\n{\n  struct vddk_handle *h = handle;\n  VixError err;\n\n  /* Align to sectors. */\n  if (!IS_ALIGNED (offset, VIXDISKLIB_SECTOR_SIZE)) {\n    nbdkit_error (\"%s is not aligned to sectors\", \"read\");\n    return -1;\n  }\n  if (!IS_ALIGNED (count, VIXDISKLIB_SECTOR_SIZE)) {\n    nbdkit_error (\"%s is not aligned to sectors\", \"read\");\n    return -1;\n  }\n  offset /= VIXDISKLIB_SECTOR_SIZE;\n  count /= VIXDISKLIB_SECTOR_SIZE;\n\n  DEBUG_CALL_DATAPATH (\"VixDiskLib_Read\",\n                       \"handle, %\" PRIu64 \" sectors, \"\n                       \"%\" PRIu32 \" sectors, buffer\",\n                       offset, count);\n  err = VixDiskLib_Read (h->handle, offset, count, buf);\n  if (err != VIX_OK) {\n    VDDK_ERROR (err, \"VixDiskLib_Read\");\n    return -1;\n  }\n\n  return 0;\n}\n\nstatic int vddk_flush (void *handle, uint32_t flags);\n\n/* Write data to the file.\n *\n * Note that writes have to be aligned to sectors (XXX).\n */\nstatic int\nvddk_pwrite (void *handle, const void *buf, uint32_t count, uint64_t offset,\n             uint32_t flags)\n{\n  const bool fua = flags & NBDKIT_FLAG_FUA;\n  struct vddk_handle *h = handle;\n  VixError err;\n\n  /* Align to sectors. */\n  if (!IS_ALIGNED (offset, VIXDISKLIB_SECTOR_SIZE)) {\n    nbdkit_error (\"%s is not aligned to sectors\", \"write\");\n    return -1;\n  }\n  if (!IS_ALIGNED (count, VIXDISKLIB_SECTOR_SIZE)) {\n    nbdkit_error (\"%s is not aligned to sectors\", \"write\");\n    return -1;\n  }\n  offset /= VIXDISKLIB_SECTOR_SIZE;\n  count /= VIXDISKLIB_SECTOR_SIZE;\n\n  DEBUG_CALL_DATAPATH (\"VixDiskLib_Write\",\n                       \"handle, %\" PRIu64 \" sectors, \"\n                       \"%\" PRIu32 \" sectors, buffer\",\n                       offset, count);\n  err = VixDiskLib_Write (h->handle, offset, count, buf);\n  if (err != VIX_OK) {\n    VDDK_ERROR (err, \"VixDiskLib_Write\");\n    return -1;\n  }\n\n  if (fua && vddk_flush (handle, 0) == -1)\n    return -1;\n\n  return 0;\n}\n\n/* Flush data to the file. */\nstatic int\nvddk_flush (void *handle, uint32_t flags)\n{\n  struct vddk_handle *h = handle;\n  VixError err;\n\n  /* The Flush call was not available in VDDK < 6.0 so this is simply\n   * ignored on earlier versions.\n   */\n  if (VixDiskLib_Flush == NULL)\n    return 0;\n\n  DEBUG_CALL (\"VixDiskLib_Flush\", \"handle\");\n  err = VixDiskLib_Flush (h->handle);\n  if (err != VIX_OK) {\n    VDDK_ERROR (err, \"VixDiskLib_Flush\");\n    return -1;\n  }\n\n  return 0;\n}\n\nstatic int\nvddk_can_extents (void *handle)\n{\n  struct vddk_handle *h = handle;\n  VixError err;\n  VixDiskLibBlockList *block_list;\n\n  /* This call was added in VDDK 6.7.  In earlier versions the\n   * function pointer will be NULL and we cannot query extents.\n   */\n  if (VixDiskLib_QueryAllocatedBlocks == NULL) {\n    nbdkit_debug (\"can_extents: VixDiskLib_QueryAllocatedBlocks == NULL, \"\n                  \"probably this is VDDK < 6.7\");\n    return 0;\n  }\n\n  /* Suppress errors around this call.  See:\n   * https://bugzilla.redhat.com/show_bug.cgi?id=1709211#c7\n   */\n  error_suppression = 1;\n\n  /* However even when the call is available it rarely works well so\n   * the best thing we can do here is to try the call and if it's\n   * non-functional return false.\n   */\n  DEBUG_CALL (\"VixDiskLib_QueryAllocatedBlocks\",\n              \"handle, 0, %d sectors, %d sectors\",\n              VIXDISKLIB_MIN_CHUNK_SIZE, VIXDISKLIB_MIN_CHUNK_SIZE);\n  err = VixDiskLib_QueryAllocatedBlocks (h->handle,\n                                         0, VIXDISKLIB_MIN_CHUNK_SIZE,\n                                         VIXDISKLIB_MIN_CHUNK_SIZE,\n                                         &block_list);\n  error_suppression = 0;\n  if (err == VIX_OK) {\n    DEBUG_CALL (\"VixDiskLib_FreeBlockList\", \"block_list\");\n    VixDiskLib_FreeBlockList (block_list);\n  }\n  if (err != VIX_OK) {\n    char *errmsg = VixDiskLib_GetErrorText (err, NULL);\n    nbdkit_debug (\"can_extents: VixDiskLib_QueryAllocatedBlocks test failed, \"\n                  \"extents support will be disabled: \"\n                  \"original error: %s\",\n                  errmsg);\n    VixDiskLib_FreeErrorText (errmsg);\n    return 0;\n  }\n\n  return 1;\n}\n\nstatic int\nadd_extent (struct nbdkit_extents *extents,\n            uint64_t *position, uint64_t next_position, bool is_hole)\n{\n  uint32_t type = 0;\n  const uint64_t length = next_position - *position;\n\n  if (is_hole) {\n    type = NBDKIT_EXTENT_HOLE;\n    /* Images opened as single link might be backed by another file in the\n       chain, so the holes are not guaranteed to be zeroes. */\n    if (!single_link)\n      type |= NBDKIT_EXTENT_ZERO;\n  }\n\n  assert (*position <= next_position);\n  if (*position == next_position)\n    return 0;\n\n  if (vddk_debug_extents)\n    nbdkit_debug (\"adding extent type %s at [%\" PRIu64 \"...%\" PRIu64 \"]\",\n                  is_hole ? \"hole\" : \"allocated data\",\n                  *position, next_position-1);\n  if (nbdkit_add_extent (extents, *position, length, type) == -1)\n    return -1;\n\n  *position = next_position;\n  return 0;\n}\n\nstatic int\nvddk_extents (void *handle, uint32_t count, uint64_t offset, uint32_t flags,\n              struct nbdkit_extents *extents)\n{\n  struct vddk_handle *h = handle;\n  bool req_one = flags & NBDKIT_FLAG_REQ_ONE;\n  uint64_t position, end, start_sector;\n\n  position = offset;\n  end = offset + count;\n\n  /* We can only query whole chunks.  Therefore start with the first\n   * chunk before offset.\n   */\n  start_sector =\n    ROUND_DOWN (offset, VIXDISKLIB_MIN_CHUNK_SIZE * VIXDISKLIB_SECTOR_SIZE)\n    / VIXDISKLIB_SECTOR_SIZE;\n  while (start_sector * VIXDISKLIB_SECTOR_SIZE < end) {\n    VixError err;\n    uint32_t i;\n    uint64_t nr_chunks, nr_sectors;\n    VixDiskLibBlockList *block_list;\n\n    assert (IS_ALIGNED (start_sector, VIXDISKLIB_MIN_CHUNK_SIZE));\n\n    nr_chunks =\n      ROUND_UP (end - start_sector * VIXDISKLIB_SECTOR_SIZE,\n                VIXDISKLIB_MIN_CHUNK_SIZE * VIXDISKLIB_SECTOR_SIZE)\n      / (VIXDISKLIB_MIN_CHUNK_SIZE * VIXDISKLIB_SECTOR_SIZE);\n    nr_chunks = MIN (nr_chunks, VIXDISKLIB_MAX_CHUNK_NUMBER);\n    nr_sectors = nr_chunks * VIXDISKLIB_MIN_CHUNK_SIZE;\n\n    DEBUG_CALL (\"VixDiskLib_QueryAllocatedBlocks\",\n                \"handle, %\" PRIu64 \" sectors, %\" PRIu64 \" sectors, \"\n                \"%d sectors\",\n                start_sector, nr_sectors, VIXDISKLIB_MIN_CHUNK_SIZE);\n    err = VixDiskLib_QueryAllocatedBlocks (h->handle,\n                                           start_sector, nr_sectors,\n                                           VIXDISKLIB_MIN_CHUNK_SIZE,\n                                           &block_list);\n    if (err != VIX_OK) {\n      VDDK_ERROR (err, \"VixDiskLib_QueryAllocatedBlocks\");\n      return -1;\n    }\n\n    for (i = 0; i < block_list->numBlocks; ++i) {\n      uint64_t blk_offset, blk_length;\n\n      blk_offset = block_list->blocks[i].offset * VIXDISKLIB_SECTOR_SIZE;\n      blk_length = block_list->blocks[i].length * VIXDISKLIB_SECTOR_SIZE;\n\n      /* The query returns allocated blocks.  We must insert holes\n       * between the blocks as necessary.\n       */\n      if ((position < blk_offset &&\n           add_extent (extents, &position, blk_offset, true) == -1) ||\n          (add_extent (extents,\n                       &position, blk_offset + blk_length, false) == -1)) {\n        DEBUG_CALL (\"VixDiskLib_FreeBlockList\", \"block_list\");\n        VixDiskLib_FreeBlockList (block_list);\n        return -1;\n      }\n    }\n    DEBUG_CALL (\"VixDiskLib_FreeBlockList\", \"block_list\");\n    VixDiskLib_FreeBlockList (block_list);\n\n    /* There's an implicit hole after the returned list of blocks, up\n     * to the end of the QueryAllocatedBlocks request.\n     */\n    if (add_extent (extents,\n                    &position,\n                    (start_sector + nr_sectors) * VIXDISKLIB_SECTOR_SIZE,\n                    true) == -1)\n      return -1;\n\n    start_sector += nr_sectors;\n\n    /* If one extent was requested, as long as we've added an extent\n     * overlapping the original offset we're done.\n     */\n    if (req_one && position > offset)\n      break;\n  }\n\n  return 0;\n}\n\nstatic struct nbdkit_plugin plugin = {\n  .name              = \"vddk\",\n  .longname          = \"VMware VDDK plugin\",\n  .version           = PACKAGE_VERSION,\n  .unload            = vddk_unload,\n  .config            = vddk_config,\n  .config_complete   = vddk_config_complete,\n  .config_help       = vddk_config_help,\n  .magic_config_key  = \"file\",\n  .dump_plugin       = vddk_dump_plugin,\n  .get_ready         = vddk_get_ready,\n  .after_fork        = vddk_after_fork,\n  .open              = vddk_open,\n  .close             = vddk_close,\n  .get_size          = vddk_get_size,\n  .pread             = vddk_pread,\n  .pwrite            = vddk_pwrite,\n  .flush             = vddk_flush,\n  .can_extents       = vddk_can_extents,\n  .extents           = vddk_extents,\n};\n\nNBDKIT_REGISTER_PLUGIN(plugin)\n",
        "/tmp/vanessa/spack-stage/spack-stage-nbdkit-1.23.4-zdmjm7bz4ia3c42zyid3wwz4ba2luhs6/spack-src/plugins/cc/cc.c": "/* nbdkit\n * Copyright (C) 2018-2020 Red Hat Inc.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * * Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * * Neither the name of Red Hat nor the names of its contributors may be\n * used to endorse or promote products derived from this software without\n * specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY RED HAT AND CONTRIBUTORS ''AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RED HAT OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#include <config.h>\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <dlfcn.h>\n\n#define NBDKIT_API_VERSION 2\n#include <nbdkit-plugin.h>\n\n#include \"cleanup.h\"\n#include \"utils.h\"\n#include \"vector.h\"\n\n/* The script name. */\nstatic char *script;\nstatic bool unlink_on_exit = false;\n\n/* C compiler and flags. */\nstatic const char *cc = CC;\nstatic const char *cflags = CFLAGS;\nstatic const char *extra_cflags;\n\n/* List of parameters for the subplugin. */\nstruct key_value { const char *key, *value; };\nDEFINE_VECTOR_TYPE(string_vector, struct key_value);\nstatic string_vector params = empty_vector;\n\n/* The subplugin. */\nstatic void *dl;\nstatic struct nbdkit_plugin subplugin;\n\nstatic void\ncc_unload (void)\n{\n  if (subplugin.unload)\n    subplugin.unload ();\n\n  if (unlink_on_exit)\n    unlink (script);\n  if (dl)\n    dlclose (dl);\n  free (params.ptr);\n  free (script);\n}\n\nstatic void\ncc_dump_plugin (void)\n{\n  printf (\"CC=%s\\n\", CC);\n  printf (\"CFLAGS=%s\\n\", CFLAGS);\n}\n\n#define cc_config_help \\\n  \"[script=]<FILENAME>   (required) The shell script to run.\\n\" \\\n  \"CC=<CC>                          C compiler.\\n\" \\\n  \"CFLAGS=<CFLAGS>                  C compiler flags.\\n\" \\\n  \"EXTRA_CFLAGS=<CFLAGS>            Extra C compiler flags.\\n\" \\\n  \"[other arguments may be used by the plugin that you load]\"\n\nstatic char *\ninline_script (void)\n{\n  CLEANUP_FREE char *cmd = NULL;\n  int fd;\n\n  if (!nbdkit_stdio_safe ()) {\n    nbdkit_error (\"inline script is incompatible with -s\");\n    return NULL;\n  }\n\n  script = strdup (\"/tmp/ccXXXXXX.c\");\n  if (script == NULL) {\n    nbdkit_error (\"strdup: %m\");\n    return NULL;\n  }\n\n  fd = mkstemps (script, 2);\n  if (fd == -1) {\n    nbdkit_error (\"mkstemps: %m\");\n    return NULL;\n  }\n  close (fd);\n  unlink_on_exit = true;\n\n  if (asprintf (&cmd, \"cat > %s\", script) == -1) {\n    nbdkit_error (\"asprintf: %m\");\n    return NULL;\n  }\n\n  if (system (cmd) != 0) {\n    nbdkit_error (\"cc: failed to copy inline script to temporary file\");\n    return NULL;\n  }\n\n  return script;\n}\n\nstatic int\ncc_config (const char *key, const char *value)\n{\n  if (!script) {\n    /* The first parameter must be \"script\". */\n    if (strcmp (key, \"script\") != 0) {\n      nbdkit_error (\"cc: the first parameter must be the C file or \\\"-\\\"\");\n      return -1;\n    }\n    if (strcmp (value, \"-\") != 0)\n      script = nbdkit_realpath (value);\n    else\n      script = inline_script ();\n    if (script == NULL)\n      return -1;\n\n    return 0;\n  }\n  else {\n    /* Although not impossible, it's likely to be a bug if there is a\n     * further parameter called \"script\" so disallow it.\n     */\n    if (strcmp (key, \"script\") == 0) {\n      nbdkit_error (\"cc: script parameter must appear only once\");\n      return -1;\n    }\n    /* Otherwise parse our parameters. */\n    else if (strcmp (key, \"CC\") == 0)\n      cc = value;\n    else if (strcmp (key, \"CFLAGS\") == 0)\n      cflags = value;\n    else if (strcmp (key, \"EXTRA_CFLAGS\") == 0)\n      extra_cflags = value;\n    else {\n      /* Anything else is saved for the subplugin. */\n      struct key_value kv = { .key = key, .value = value };\n\n      if (string_vector_append (&params, kv) == -1) {\n        nbdkit_error (\"realloc: %m\");\n        return -1;\n      }\n    }\n    return 0;\n  }\n}\n\n/* We must compile and load the subplugin here (not in get_ready)\n * because we must find the subplugin's thread model, and the core\n * server will query that straight after config_complete.\n */\nstatic int\ncc_config_complete (void)\n{\n  CLEANUP_FREE char *command = NULL;\n  size_t len = 0, size, i;\n  FILE *fp;\n  int fd, r;\n  char tmpfile[] = \"/tmp/ccXXXXXX.so\";\n  struct nbdkit_plugin *(*plugin_init) (void);\n  char *error;\n  const struct nbdkit_plugin *ptr;\n\n  if (!script) {\n    nbdkit_error (\"cc: no C program name (or \\\"-\\\") given\");\n    return -1;\n  }\n\n  /* Create a temporary file to store the compiled plugin. */\n  fd = mkstemps (tmpfile, 3);\n  if (fd == -1) {\n    nbdkit_error (\"mkstemps: %m\");\n    return -1;\n  }\n  close (fd);\n\n  /* Compile the C program. */\n  fp = open_memstream (&command, &len);\n  if (fp == NULL) {\n    nbdkit_error (\"open_memstream: %m\");\n    return -1;\n  }\n  /* The C compiler and C flags don't need to be quoted. */\n  fprintf (fp, \"%s %s \", cc, cflags);\n  if (extra_cflags)\n    fprintf (fp, \"%s \", extra_cflags);\n  shell_quote (script, fp);\n  fprintf (fp, \" -o \");\n  shell_quote (tmpfile, fp);\n  if (fclose (fp) == EOF) {\n    nbdkit_error (\"memstream failed: %m\");\n    return -1;\n  }\n\n  nbdkit_debug (\"cc: %s\", command);\n  r = system (command);\n  if (exit_status_to_nbd_error (r, cc) == -1) {\n    unlink (tmpfile);\n    return -1;\n  }\n\n  /* Load the subplugin. */\n  dl = dlopen (tmpfile, RTLD_NOW);\n  unlink (tmpfile);\n  if (dl == NULL) {\n    nbdkit_error (\"cannot open the compiled plugin: %s\", dlerror ());\n    return -1;\n  }\n\n  /* Now we basically behave like core nbdkit when it loads a plugin. */\n  dlerror ();\n  *(void **) (&plugin_init) = dlsym (dl, \"plugin_init\");\n  if ((error = dlerror ()) != NULL) {\n    nbdkit_error (\"no plugin_init symbol found: %s\", dlerror ());\n    return -1;\n  }\n  if (!plugin_init) {\n    nbdkit_error (\"invalid plugin_init symbol\");\n    return -1;\n  }\n  ptr = plugin_init ();\n  if (!ptr) {\n    nbdkit_error (\"plugin registration failed\");\n    return -1;\n  }\n\n  /* Are the APIs compatible? */\n  if (ptr->_api_version != NBDKIT_API_VERSION) {\n    nbdkit_error (\"plugin uses the wrong NBDKIT_API_VERSION, it must be %d\",\n                  NBDKIT_API_VERSION);\n    return -1;\n  }\n\n  /* Copy the subplugins struct into our plugin global, padding or\n   * truncating as necessary.\n   */\n  size = sizeof subplugin;      /* Size of our struct. */\n  if (size > ptr->_struct_size)\n    size = ptr->_struct_size;\n  memcpy (&subplugin, ptr, size);\n\n  /* Check that the plugin has .open, .get_size and .pread. */\n  if (subplugin.open == NULL) {\n    nbdkit_error (\"plugin must have a .open callback\");\n    return -1;\n  }\n  if (subplugin.get_size == NULL) {\n    nbdkit_error (\"plugin must have a .get_size callback\");\n    return -1;\n  }\n  if (subplugin.pread == NULL) {\n    nbdkit_error (\"plugin must have a .pread callback\");\n    return -1;\n  }\n\n  /* Now we have to call the subplugin's load, config and\n   * config_complete.  Everything after that will be called via the\n   * core server through our forwarding functions below.\n   */\n  if (subplugin.load)\n    subplugin.load ();\n  if (subplugin.config) {\n    for (i = 0; i < params.size; ++i) {\n      if (subplugin.config (params.ptr[i].key, params.ptr[i].value) == -1)\n        return -1;\n    }\n  }\n  else if (params.size > 0) {\n    /* Just print the first one in the error message. */\n    nbdkit_error (\"unknown parameter: %s\", params.ptr[0].key);\n    return -1;\n  }\n  if (subplugin.config_complete) {\n    if (subplugin.config_complete () == -1)\n      return -1;\n  }\n\n  return 0;\n}\n\n/* This is adjusted when we load the subplugin. */\n#define THREAD_MODEL NBDKIT_THREAD_MODEL_PARALLEL\n\n/* Set the thread model from the subplugin. */\nstatic int\ncc_thread_model (void)\n{\n  if (subplugin.thread_model != NULL)\n    return subplugin.thread_model ();\n  else\n    return subplugin._thread_model;\n}\n\n/* All other calls are forwarded to the subplugin. */\nstatic int\ncc_get_ready (void)\n{\n  if (subplugin.get_ready)\n    return subplugin.get_ready ();\n  return 0;\n}\n\nstatic int\ncc_after_fork (void)\n{\n  if (subplugin.after_fork)\n    return subplugin.after_fork ();\n  return 0;\n}\n\nstatic int\ncc_preconnect (int readonly)\n{\n  if (subplugin.preconnect)\n    return subplugin.preconnect (readonly);\n  return 0;\n}\n\nstatic void *\ncc_open (int readonly)\n{\n  return subplugin.open (readonly);\n}\n\nstatic void\ncc_close (void *handle)\n{\n  if (subplugin.close)\n    subplugin.close (handle);\n}\n\nstatic int64_t\ncc_get_size (void *handle)\n{\n  return subplugin.get_size (handle);\n}\n\nstatic int\ncc_can_write (void *handle)\n{\n  if (subplugin.can_write)\n    return subplugin.can_write (handle);\n  else\n    return !!subplugin.pwrite;\n}\n\nstatic int\ncc_can_flush (void *handle)\n{\n  if (subplugin.can_flush)\n    return subplugin.can_flush (handle);\n  else\n    return !!subplugin.flush;\n}\n\nstatic int\ncc_is_rotational (void *handle)\n{\n  if (subplugin.is_rotational)\n    return subplugin.is_rotational (handle);\n  else\n    return 0;\n}\n\nstatic int\ncc_can_trim (void *handle)\n{\n  if (subplugin.can_trim)\n    return subplugin.can_trim (handle);\n  else\n    return !!subplugin.trim;\n}\n\nstatic int\ncc_can_zero (void *handle)\n{\n  if (subplugin.can_zero)\n    return subplugin.can_zero (handle);\n  else\n    return !!subplugin.zero;\n}\n\nstatic int\ncc_can_fast_zero (void *handle)\n{\n  if (subplugin.can_fast_zero)\n    return subplugin.can_fast_zero (handle);\n  else\n    return 0;\n}\n\nstatic int\ncc_can_extents (void *handle)\n{\n  if (subplugin.can_extents)\n    return subplugin.can_extents (handle);\n  else\n    return !!subplugin.extents;\n}\n\nstatic int\ncc_can_fua (void *handle)\n{\n  if (subplugin.can_fua)\n    return subplugin.can_fua (handle);\n  else if (cc_can_flush (handle))\n    return NBDKIT_FUA_EMULATE;\n  else\n    return NBDKIT_FUA_NONE;\n}\n\nstatic int\ncc_can_multi_conn (void *handle)\n{\n  if (subplugin.can_multi_conn)\n    return subplugin.can_multi_conn (handle);\n  else\n    return 0;\n}\n\nstatic int\ncc_can_cache (void *handle)\n{\n  if (subplugin.can_cache)\n    return subplugin.can_cache (handle);\n  else if (subplugin.cache)\n    return NBDKIT_CACHE_NATIVE;\n  else\n    return NBDKIT_CACHE_NONE;\n}\n\nstatic int\ncc_pread (void *handle, void *buf, uint32_t count, uint64_t offset,\n          uint32_t flags)\n{\n  return subplugin.pread (handle, buf, count, offset, flags);\n}\n\nstatic int\ncc_pwrite (void *handle, const void *buf, uint32_t count, uint64_t offset,\n           uint32_t flags)\n{\n  if (subplugin.pwrite)\n    return subplugin.pwrite (handle, buf, count, offset, flags);\n  else {\n    nbdkit_error (\"missing %s callback\", \"pwrite\");\n    errno = EROFS;\n    return -1;\n  }\n}\n\nstatic int\ncc_flush (void *handle, uint32_t flags)\n{\n  if (subplugin.flush)\n    return subplugin.flush (handle, flags);\n  else {\n    nbdkit_error (\"missing %s callback\", \"flush\");\n    errno = EINVAL;\n    return -1;\n  }\n}\n\nstatic int\ncc_trim (void *handle, uint32_t count, uint64_t offset, uint32_t flags)\n{\n  if (subplugin.trim)\n    return subplugin.trim (handle, count, offset, flags);\n  else {\n    nbdkit_error (\"missing %s callback\", \"trim\");\n    errno = EINVAL;\n    return -1;\n  }\n}\n\nstatic int\ncc_zero (void *handle, uint32_t count, uint64_t offset, uint32_t flags)\n{\n  if (subplugin.zero)\n    return subplugin.zero (handle, count, offset, flags);\n  else {\n    /* Inform nbdkit to fall back to pwrite. */\n    nbdkit_error (\"missing %s callback\", \"zero\");\n    errno = EOPNOTSUPP;\n    return -1;\n  }\n}\n\nstatic int\ncc_extents (void *handle, uint32_t count, uint64_t offset,\n            uint32_t flags, struct nbdkit_extents *extents)\n{\n  if (subplugin.extents)\n    return subplugin.extents (handle, count, offset, flags, extents);\n  else {\n    nbdkit_error (\"missing %s callback\", \"extents\");\n    errno = EINVAL;\n    return -1;\n  }\n}\n\nstatic int\ncc_cache (void *handle, uint32_t count, uint64_t offset, uint32_t flags)\n{\n  if (subplugin.cache)\n    return subplugin.cache (handle, count, offset, flags);\n  else\n    /* A plugin may advertise caching but not provide .cache; in that\n     * case, caching is explicitly a no-op.\n     */\n    return 0;\n}\n\nstatic struct nbdkit_plugin plugin = {\n  .name              = \"cc\",\n  .longname          = \"nbdkit C compiler plugin\",\n  .version           = PACKAGE_VERSION,\n\n  /* These are the callbacks that this plugin overrides. */\n  .unload            = cc_unload,\n  .dump_plugin       = cc_dump_plugin,\n  .config            = cc_config,\n  .config_complete   = cc_config_complete,\n  .config_help       = cc_config_help,\n  .thread_model      = cc_thread_model,\n\n  /* And we must provide callbacks for everything else, which are\n   * passed through to the subplugin.\n   */\n  .get_ready         = cc_get_ready,\n  .after_fork        = cc_after_fork,\n\n  .preconnect        = cc_preconnect,\n  .open              = cc_open,\n  .close             = cc_close,\n\n  .get_size          = cc_get_size,\n  .can_write         = cc_can_write,\n  .can_flush         = cc_can_flush,\n  .is_rotational     = cc_is_rotational,\n  .can_trim          = cc_can_trim,\n  .can_zero          = cc_can_zero,\n  .can_fast_zero     = cc_can_fast_zero,\n  .can_extents       = cc_can_extents,\n  .can_fua           = cc_can_fua,\n  .can_multi_conn    = cc_can_multi_conn,\n  .can_cache         = cc_can_cache,\n\n  .pread             = cc_pread,\n  .pwrite            = cc_pwrite,\n  .flush             = cc_flush,\n  .trim              = cc_trim,\n  .zero              = cc_zero,\n  .extents           = cc_extents,\n  .cache             = cc_cache,\n\n  .errno_is_preserved = 1,\n};\n\nNBDKIT_REGISTER_PLUGIN(plugin)\n",
        "/tmp/vanessa/spack-stage/spack-stage-nbdkit-1.23.4-zdmjm7bz4ia3c42zyid3wwz4ba2luhs6/spack-src/valgrind/glibc.suppressions": "# glibc valgrind suppressions\n# Copyright (C) 2016-2020 Red Hat Inc.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are\n# met:\n#\n# * Redistributions of source code must retain the above copyright\n# notice, this list of conditions and the following disclaimer.\n#\n# * Redistributions in binary form must reproduce the above copyright\n# notice, this list of conditions and the following disclaimer in the\n# documentation and/or other materials provided with the distribution.\n#\n# * Neither the name of Red Hat nor the names of its contributors may be\n# used to endorse or promote products derived from this software without\n# specific prior written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY RED HAT AND CONTRIBUTORS ''AS IS'' AND\n# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n# PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RED HAT OR\n# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n# USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n# OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n# SUCH DAMAGE.\n\n# Allow thread-local storage from pthread_create to leak.\n{\n  glibc_1\n  Memcheck:Leak\n  fun:calloc\n  ...\n  fun:_dl_allocate_tls\n}\n\n# Suppress leaks from dlopen.  When running under valgrind we\n# deliberately don't run dlclose because otherwise valgrind cannot\n# print symbols.  So it's expected that dlopen will leak.\n{\n  glibc_2\n  Memcheck:Leak\n  ...\n  obj:/usr/lib*/libdl-*\n}\n\n# bindtextdomain leaks.\n{\n  glibc_3\n  Memcheck:Leak\n  ...\n  fun:bindtextdomain\n}\n\n# Both gmtime_r and locatime_r leak some sort of timezone-related\n# struct inside glibc.  These are used by the log filter and the\n# floppy plugin.\n{\n  glibc_4\n  Memcheck:Leak\n  fun:malloc\n  ...\n  fun:tzset_internal\n}\n\n# __printf_chk leaks.\n{\n  glibc_5\n  Memcheck:Leak\n  fun:malloc\n  ...\n  fun:__printf_chk\n}\n\n# iconv is very leaky, even if we close the handle.\n{\n  glibc_6\n  Memcheck:Leak\n  fun:malloc\n  ...\n  fun:__gconv_open\n}\n\n{\n  glibc_7\n  Memcheck:Leak\n  fun:calloc\n  ...\n  fun:__gconv_open\n}\n\n# getaddrinfo leaks a memory allocation even though we\n# call freeaddrinfo.\n{\n  glibc_8\n  Memcheck:Leak\n  fun:malloc\n  ...\n  fun:__check_pf\n  fun:getaddrinfo\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-nbdkit-1.23.4-zdmjm7bz4ia3c42zyid3wwz4ba2luhs6/spack-src/docs/nbdkit-plugin.pod": "=head1 NAME\n\nnbdkit-plugin - how to write nbdkit plugins\n\n=head1 SYNOPSIS\n\n #define NBDKIT_API_VERSION 2\n #include <nbdkit-plugin.h>\n \n #define THREAD_MODEL NBDKIT_THREAD_MODEL_SERIALIZE_ALL_REQUESTS\n \n static void *\n myplugin_open (void)\n {\n   /* create a handle ... */\n   return handle;\n }\n \n static struct nbdkit_plugin plugin = {\n   .name              = \"myplugin\",\n   .open              = myplugin_open,\n   .get_size          = myplugin_get_size,\n   .pread             = myplugin_pread,\n   .pwrite            = myplugin_pwrite,\n   /* etc */\n };\n NBDKIT_REGISTER_PLUGIN(plugin)\n\nCompile the plugin as a shared library:\n\n gcc -fPIC -shared myplugin.c -o myplugin.so\n\nand load it into nbdkit:\n\n nbdkit [--args ...] ./myplugin.so [key=value ...]\n\nWhen debugging, use the I<-fv> options:\n\n nbdkit -fv ./myplugin.so [key=value ...]\n\n=head1 DESCRIPTION\n\nAn nbdkit plugin is a new source device which can be served using the\nNetwork Block Device (NBD) protocol.  This manual page describes how\nto create an nbdkit plugin in C.\n\nTo see example plugins:\nL<https://github.com/libguestfs/nbdkit/tree/master/plugins>\n\nTo write plugins in other languages, see:\n__LANG_PLUGIN_LINKS__.\n\n=head2 API and ABI guarantee for C plugins\n\nPlugins written in C have an ABI guarantee: a plugin compiled against\nan older version of nbdkit will still work correctly when loaded with\na newer nbdkit.  We also try (but cannot guarantee) to support plugins\ncompiled against a newer version of nbdkit when loaded with an older\nnbdkit, although the plugin may have reduced functionality if it\ndepends on features only provided by newer nbdkit.\n\nFor plugins written in C, we also provide an API guarantee: a plugin\nwritten against an older header will still compile unmodified with a\nnewer nbdkit.\n\nThe API guarantee does not always apply to plugins written in other\n(non-C) languages which may have to adapt to changes when recompiled\nagainst a newer nbdkit.\n\n=head1 WRITING AN NBDKIT PLUGIN\n\n=head2 C<#define NBDKIT_API_VERSION 2>\n\nPlugins must choose which API version they want to use, by defining\nNBDKIT_API_VERSION before including C<E<lt>nbdkit-plugin.hE<gt>> (or\nany other nbdkit header).\n\nIf omitted, the default version is 1 for backwards-compatibility with\nnbdkit v1.1.26 and earlier; however, it is recommended that new\nplugins be written to the maximum version (currently 2) as it enables\nmore features and better interaction with nbdkit filters.\n\nThe rest of this document only covers the version 2 interface.  A\nnewer nbdkit will always support plugins written in C which use any\nprior API version.\n\n=head2 C<#include E<lt>nbdkit-plugin.hE<gt>>\n\nAll plugins should start by including this header file (after\noptionally choosing an API version).\n\n=head2 C<#define THREAD_MODEL ...>\n\nAll plugins must define a thread model.  See L</Threads> below for\ndetails.  It is generally safe to use:\n\n #define THREAD_MODEL NBDKIT_THREAD_MODEL_SERIALIZE_ALL_REQUESTS\n\n=head2 C<struct nbdkit_plugin>\n\nAll plugins must define and register one C<struct nbdkit_plugin>,\nwhich contains the name of the plugin and pointers to callback\nfunctions, and use the C<NBDKIT_REGISTER_PLUGIN(plugin)> macro:\n\n static struct nbdkit_plugin plugin = {\n   .name              = \"myplugin\",\n   .longname          = \"My Plugin\",\n   .description       = \"This is my great plugin for nbdkit\",\n   .open              = myplugin_open,\n   .get_size          = myplugin_get_size,\n   .pread             = myplugin_pread,\n   .pwrite            = myplugin_pwrite,\n   /* etc */\n };\n NBDKIT_REGISTER_PLUGIN(plugin)\n\nThe C<.name> field is the name of the plugin.\n\nThe callbacks are described below (see L</CALLBACKS>).  Only C<.name>,\nC<.open>, C<.get_size> and C<.pread> are required.  All other\ncallbacks can be omitted, although typical plugins need to use more.\n\n=head2 Callback lifecycle\n\nCallbacks are called in the following order over the lifecycle of\nthe plugin:\n\n         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         \u2502 load             \u2502\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                   \u2502           configuration phase starts     \u2500\u2510\n         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                  \u2506\n         \u2502 config           \u2502  config is called once per       \u2506\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u21ba key=value on the command line   \u2506\n         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                  \u2506\n         \u2502 config_complete  \u2502                                  \u2506\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                  \u2506\n         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                  \u2506\n         \u2502 thread_model     \u2502                                  \u2506\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  configuration phase ends       \u2500\u2518\n         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         \u2502 get_ready        \u2502\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                   \u2502           nbdkit forks into the background\n         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         \u2502 after_fork       \u2502\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                   \u2502           nbdkit starts serving clients\n                   \u2502\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500\n \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2510 client #1        \u2502\n \u2502 preconnect \u2502                  \u2502\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518                  \u2502\n \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2510                  \u2502\n \u2502list_exports\u2502                  \u2502\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518                  \u2502\n \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2510                  \u2502\n \u2502 open       \u2502                  \u2502\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518                  \u2502\n \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2510  NBD option      \u2502\n \u2502 can_write  \u2502  negotiation     \u2502\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518                  \u2502\n \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2510           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2510 client #2\n \u2502 get_size   \u2502           \u2502 preconnect \u2502\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518\n \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2510 data\n \u2502 pread      \u2502 serving\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518\u21ba                ...\n \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2510\n \u2502 pwrite     \u2502\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518\u21ba          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2510\n \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2510           \u2502 close      \u2502\n \u2502 close      \u2502           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n \n                   \u2502           before nbdkit exits\n                   \u2502\n         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         \u2502 unload           \u2502\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n=over 4\n\n=item C<.load>\n\nis called once just after the plugin is loaded into memory.\n\n=item C<.config> and C<.config_complete>\n\nC<.config> is called zero or more times during command line parsing.\nC<.config_complete> is called once after all configuration information\nhas been passed to the plugin (but not during C<nbdkit --dump-plugin>).\n\nBoth are called after loading the plugin but before any connections\nare accepted.\n\n=item C<.thread_model>\n\nIn normal operation, C<.thread_model> is called once after\nC<.config_complete> has validated all configuration information, and\nbefore any connections are accepted.  However, during C<nbdkit\n--dump-plugin>, it is called after any C<.config> calls but without\nC<.config_complete> (so a plugin which determines the results from a\nscript must be prepared for a missing script).\n\n=item C<.get_ready>\n\nIn normal operation, C<.get_ready> is called before the server starts\nserving.  It is called before the server forks or changes directory.\nIt is normally the last chance to do any global preparation that is\nneeded to serve connections.\n\nPlugins should not create background threads here.  Use C<.after_fork>\ninstead.\n\n=item C<.after_fork>\n\nIn normal operation, C<.after_fork> is called after the server has\nforked into the background and changed UID and directory.  If a plugin\nneeds to create background threads (or uses an external library that\ncreates threads) it should do so here, because background threads are\ninvalidated by fork.\n\nBecause the server may have forked into the background, error messages\nand failures from C<.after_fork> cannot be seen by the user unless\nthey look through syslog.  An error in C<.after_fork> can appear to\nthe user as if nbdkit \u201cjust died\u201d.  So in almost all cases it is\nbetter to use C<.get_ready> instead of this callback, or to do as much\npreparation work as possible in C<.get_ready> and only start\nbackground threads here.\n\nThe server doesn't always fork (eg. if the I<-f> flag is used), but\neven so this callback will be called.  If you want to find out if the\nserver forked between C<.get_ready> and C<.after_fork> use\nL<getpid(2)>.\n\n=item C<.preconnect>\n\nCalled when a TCP connection has been made to the server.  This\nhappens early, before NBD or TLS negotiation.\n\n=item C<.list_exports>\n\nEarly in option negotiation the client may try to list the exports\nserved by the plugin, and plugins can optionally implement this\ncallback to answer the client.  See L</EXPORT NAME> below.\n\n=item C<.open>\n\nA new client has connected and finished the NBD handshake.  TLS\nnegotiation (if required) has been completed successfully.\n\n=item C<.can_write>, C<.get_size> and other option negotiation callbacks\n\nThese are called during option negotiation with the client, but before\nany data is served.  These callbacks may return different values\nacross different C<.open> calls, but within a single connection, they\nare called at most once and cached by nbdkit for that connection.\n\n=item C<.pread>, C<.pwrite> and other data serving callbacks\n\nAfter option negotiation has finished, these may be called to serve\ndata.  Depending on the thread model chosen, they might be called in\nparallel from multiple threads.  The data serving callbacks include a\nflags argument; the results of the negotiation callbacks influence\nwhether particular flags will ever be passed to a data callback.\n\n=item C<.close>\n\nThe client has disconnected.\n\n=item C<.preconnect>, C<.open> ... C<.close>\n\nThe sequence C<.preconnect>, C<.open> ... C<.close> can be called\nrepeatedly over the lifetime of the plugin, and can be called in\nparallel (depending on the thread model).\n\n=item C<.unload>\n\nis called once just before the plugin is unloaded from memory.\n\n=back\n\n=head2 Flags\n\nThe following flags are defined by nbdkit, and used in various data\nserving callbacks as follows:\n\n=over 4\n\n=item C<NBDKIT_FLAG_MAY_TRIM>\n\nThis flag is used by the C<.zero> callback; there is no way to disable\nthis flag, although a plugin that does not support trims as a way to\nwrite zeroes may ignore the flag without violating expected semantics.\n\n=item C<NBDKIT_FLAG_FUA>\n\nThis flag represents Forced Unit Access semantics.  It is used by the\nC<.pwrite>, C<.zero>, and C<.trim> callbacks to indicate that the\nplugin must not return a result until the action has landed in\npersistent storage.  This flag will not be sent to the plugin unless\nC<.can_fua> is provided and returns C<NBDKIT_FUA_NATIVE>.\n\n=back\n\nThe following defines are valid as successful return values for\nC<.can_fua>:\n\n=over 4\n\n=item C<NBDKIT_FUA_NONE>\n\nForced Unit Access is not supported; the client must manually request\na flush after writes have completed.  The C<NBDKIT_FLAG_FUA> flag will\nnot be passed to the plugin's write callbacks.\n\n=item C<NBDKIT_FUA_EMULATE>\n\nThe client may request Forced Unit Access, but it is implemented by\nemulation, where nbdkit calls C<.flush> after a write operation; this\nis semantically correct, but may hurt performance as it tends to flush\nmore data than just what the client requested.  The C<NBDKIT_FLAG_FUA>\nflag will not be passed to the plugin's write callbacks.\n\n=item C<NBDKIT_FUA_NATIVE>\n\nThe client may request Forced Unit Access, which results in the\nC<NBDKIT_FLAG_FUA> flag being passed to the plugin's write callbacks\n(C<.pwrite>, C<.trim>, and C<.zero>).  When the flag is set, these\ncallbacks must not return success until the client's request has\nlanded in persistent storage.\n\n=back\n\nThe following defines are valid as successful return values for\nC<.can_cache>:\n\n=over 4\n\n=item C<NBDKIT_CACHE_NONE>\n\nThe server does not advertise caching support, and rejects any\nclient-requested caching. Any C<.cache> callback is ignored.\n\n=item C<NBDKIT_CACHE_EMULATE>\n\nThe nbdkit server advertises cache support to the client, where the\nclient may request that the server cache a region of the export to\npotentially speed up future read and/or write operations on that\nregion. The nbdkit server implements the caching by calling C<.pread>\nand ignoring the results. This option exists to ease the\nimplementation of a common form of caching; any C<.cache> callback is\nignored.\n\n=item C<NBDKIT_CACHE_NATIVE>\n\nThe nbdkit server advertises cache support to the client, where the\nclient may request that the server cache a region of the export to\npotentially speed up future read and/or write operations on that\nregion. The nbdkit server calls the C<.cache> callback to perform the\ncaching; if that callback is missing, the client's cache request\nsucceeds without doing anything.\n\n=back\n\n=head2 Threads\n\nEach nbdkit plugin must declare its maximum thread safety model by\ndefining the C<THREAD_MODEL> macro.  (This macro is used by\nC<NBDKIT_REGISTER_PLUGIN>).  Additionally, a plugin may implement the\nC<.thread_model> callback, called right after C<.config_complete> to\nmake a runtime decision on which thread model to use.  The nbdkit\nserver chooses the most restrictive model between the plugin's\nC<THREAD_MODEL>, the C<.thread_model> if present, any restrictions\nrequested by filters, and any limitations imposed by the operating\nsystem.\n\nIn C<nbdkit --dump-plugin PLUGIN> output, the C<max_thread_model> line\nmatches the C<THREAD_MODEL> macro, and the C<thread_model> line\nmatches what the system finally settled on after applying all\nrestrictions.\n\nThe possible settings for C<THREAD_MODEL> are defined below.\n\n=over 4\n\n=item C<#define THREAD_MODEL NBDKIT_THREAD_MODEL_SERIALIZE_CONNECTIONS>\n\nOnly a single handle can be open at any time, and all requests happen\nfrom one thread.\n\nNote this means only one client can connect to the server at any time.\nIf a second client tries to connect it will block waiting for the\nfirst client to close the connection.\n\n=item C<#define THREAD_MODEL NBDKIT_THREAD_MODEL_SERIALIZE_ALL_REQUESTS>\n\nI<This is a safe default for most plugins>.\n\nMultiple handles can be open at the same time, but requests are\nserialized so that for the plugin as a whole only one\nopen/read/write/close (etc) request will be in progress at any time.\n\nThis is a useful setting if the library you are using is not\nthread-safe.  However performance may not be good.\n\n=item C<#define THREAD_MODEL NBDKIT_THREAD_MODEL_SERIALIZE_REQUESTS>\n\nMultiple handles can be open and multiple data requests can happen in\nparallel.  However only one request will happen per handle at a time\n(but requests on different handles might happen concurrently).\n\n=item C<#define THREAD_MODEL NBDKIT_THREAD_MODEL_PARALLEL>\n\nMultiple handles can be open and multiple data requests can happen in\nparallel (even on the same handle).  The server may reorder replies,\nanswering a later request before an earlier one.\n\nAll the libraries you use must be thread-safe and reentrant, and any\ncode that creates a file descriptor should atomically set\nC<FD_CLOEXEC> if you do not want it accidentally leaked to another\nthread's child process.  You may also need to provide mutexes for\nfields in your connection handle.\n\n=back\n\nIf none of the above thread models are suitable, use\nC<NBDKIT_THREAD_MODEL_PARALLEL> and implement your own locking using\nC<pthread_mutex_t> etc.\n\n=head2 Error handling\n\nIf there is an error in the plugin, the plugin should call\nC<nbdkit_error> to report an error message; additionally, if the\ncallback is involved in serving data, the plugin should call\nC<nbdkit_set_error> to influence the error code that will be sent to\nthe client.  These two functions can be called in either order.  Then,\nthe callback should return the appropriate error indication,\neg. C<NULL> or C<-1>.\n\nIf the call to C<nbdkit_set_error> is omitted while serving data, then\nthe global variable C<errno> may be used.  For plugins which have\nC<.errno_is_preserved != 0> the core code will use C<errno>.  In\nplugins written in non-C languages, we usually cannot trust that\nC<errno> will not be overwritten when returning from that language to\nC.  In that case, either the plugin must call C<nbdkit_set_error> or\nhard-coded C<EIO> is used.\n\nC<nbdkit_error> has the following prototype and works like\nL<printf(3)>:\n\n void nbdkit_error (const char *fs, ...);\n void nbdkit_verror (const char *fs, va_list args);\n\nFor convenience, C<nbdkit_error> preserves the value of C<errno>, and\nalso supports the glibc extension of a single C<%m> in a format string\nexpanding to C<strerror(errno)>, even on platforms that don't support\nthat natively.\n\nC<nbdkit_set_error> can be called at any time, but only has an impact\nduring callbacks for serving data, and only when the callback returns\nan indication of failure.  It has the following prototype:\n\n void nbdkit_set_error (int err);\n\n=head1 CALLBACKS\n\n=head2 C<.name>\n\n const char *name;\n\nThis field (a string) is required, and B<must> contain only ASCII\nalphanumeric characters or non-leading dashes, and be unique amongst\nall plugins.\n\n=head2 C<.version>\n\n const char *version;\n\nPlugins may optionally set a version string which is displayed in help\nand debugging output.\n\n=head2 C<.longname>\n\n const char *longname;\n\nAn optional free text name of the plugin.  This field is used in error\nmessages.\n\n=head2 C<.description>\n\n const char *description;\n\nAn optional multi-line description of the plugin.\n\n=head2 C<.load>\n\n void load (void);\n\nThis is called once just after the plugin is loaded into memory.  You\ncan use this to perform any global initialization needed by the\nplugin.\n\n=head2 C<.unload>\n\n void unload (void);\n\nThis may be called once just before the plugin is unloaded from\nmemory.  Note that it's not guaranteed that C<.unload> will always be\ncalled (eg. the server might be killed or segfault), so you should try\nto make the plugin as robust as possible by not requiring cleanup.\nSee also L</SHUTDOWN> below.\n\n=head2 C<.dump_plugin>\n\n void dump_plugin (void);\n\nThis optional callback is called when the\nS<C<nbdkit plugin --dump-plugin>> command is used.  It should print\nany additional informative C<key=value> fields to stdout as needed.\nPrefixing the keys with the name of the plugin will avoid conflicts.\n\n=head2 C<.config>\n\n int config (const char *key, const char *value);\n\nOn the nbdkit command line, after the plugin filename, come an\noptional list of C<key=value> arguments.  These are passed to the\nplugin through this callback when the plugin is first loaded and\nbefore any connections are accepted.\n\nThis callback may be called zero or more times.\n\nBoth C<key> and C<value> parameters will be non-NULL.  The strings are\nowned by nbdkit but will remain valid for the lifetime of the plugin,\nso the plugin does not need to copy them.\n\nThe key will be a non-empty string beginning with an ASCII alphabetic\ncharacter (C<A-Z> C<a-z>).  The rest of the key must contain only\nASCII alphanumeric plus period, underscore or dash characters (C<A-Z>\nC<a-z> C<0-9> C<.> C<_> C<->).  The value may be an arbitrary string,\nincluding an empty string.\n\nThe names of C<key>s accepted by plugins is up to the plugin, but you\nshould probably look at other plugins and follow the same conventions.\n\nIf the value is a relative path, then note that the server changes\ndirectory when it starts up.  See L</FILENAMES AND PATHS> above.\n\nIf C<nbdkit_stdio_safe> returns 1, the value of the configuration\nparameter may be used to trigger reading additional data through stdin\n(such as a password or inline script).\n\nIf the C<.config> callback is not provided by the plugin, and the user\ntries to specify any C<key=value> arguments, then nbdkit will exit\nwith an error.\n\nIf there is an error, C<.config> should call C<nbdkit_error> with an\nerror message and return C<-1>.\n\n=head2 C<.magic_config_key>\n\n const char *magic_config_key;\n\nThis optional string can be used to set a \"magic\" key used when\nparsing plugin parameters.  It affects how \"bare parameters\" (those\nwhich do not contain an C<=> character) are parsed on the command\nline.\n\nIf C<magic_config_key != NULL> then any bare parameters are passed to\nthe C<.config> method as: S<C<config (magic_config_key, argv[i]);>>.\n\nIf C<magic_config_key> is not set then we behave as in nbdkit E<lt>\n1.7: If the first parameter on the command line is bare then it is\npassed to the C<.config> method as: S<C<config (\"script\", value);>>.\nAny other bare parameters give errors.\n\n=head2 C<.config_complete>\n\n int config_complete (void);\n\nThis optional callback is called after all the configuration has been\npassed to the plugin.  It is a good place to do checks, for example\nthat the user has passed the required parameters to the plugin.\n\nIf there is an error, C<.config_complete> should call C<nbdkit_error>\nwith an error message and return C<-1>.\n\n=head2 C<.config_help>\n\n const char *config_help;\n\nThis optional multi-line help message should summarize any\nC<key=value> parameters that it takes.  It does I<not> need to repeat\nwhat already appears in C<.description>.\n\nIf the plugin doesn't take any config parameters you should probably\nomit this.\n\n=head2 C<.thread_model>\n\n int thread_model (void)\n\nThis optional callback is called after all the configuration has been\npassed to the plugin.  It can be used to force a stricter thread model\nbased on configuration, compared to C<THREAD_MODEL>.  See L</Threads>\nabove for details.  Attempts to request a looser (more parallel) model\nare silently ignored.\n\nIf there is an error, C<.thread_model> should call C<nbdkit_error>\nwith an error message and return C<-1>.\n\n=head2 C<.get_ready>\n\n int get_ready (void);\n\nThis optional callback is called before the server starts serving.  It\nis called before the server forks or changes directory.  It is\nordinarily the last chance to do any global preparation that is needed\nto serve connections.\n\nIf there is an error, C<.get_ready> should call C<nbdkit_error> with\nan error message and return C<-1>.\n\n=head2 C<.after_fork>\n\n int after_fork (void);\n\nThis optional callback is called before the server starts serving.  It\nis called after the server forks and changes directory.  If a plugin\nneeds to create background threads (or uses an external library that\ncreates threads) it should do so here, because background threads are\nkilled by fork.  However you should try to do as little as possible\nhere because error reporting is difficult.  See L</Callback lifecycle>\nabove.\n\nIf there is an error, C<.after_fork> should call C<nbdkit_error> with\nan error message and return C<-1>.\n\n=head2 C<.preconnect>\n\n int preconnect (int readonly);\n\nThis optional callback is called when a TCP connection has been made\nto the server.  This happens early, before NBD or TLS negotiation.  If\nTLS authentication is required to access the server, then it has\nB<not> been negotiated at this point.\n\nFor security reasons (to avoid denial of service attacks) this\ncallback should be written to be as fast and take as few resources as\npossible.  If you use this callback, only use it to do basic access\ncontrol, such as checking C<nbdkit_peer_name> against a whitelist (see\nL</PEER NAME> and L<nbdkit-ip-filter(1)>).  It may be better to do\naccess control outside the server, for example using TCP wrappers or a\nfirewall.\n\nThe C<readonly> flag informs the plugin that the server was started\nwith the I<-r> flag on the command line.\n\nReturning C<0> will allow the connection to continue.  If there is an\nerror or you want to deny the connection, call C<nbdkit_error> with an\nerror message and return C<-1>.\n\n=head2 C<.list_exports>\n\n int list_exports (int readonly, int default_only,\n                   struct nbdkit_exports *exports);\n\nThis optional callback is called if the client tries to list the\nexports served by the plugin (using C<NBD_OPT_LIST>).  If the plugin\ndoes not supply this callback then a single export called C<\"\"> is\nreturned.  The NBD protocol defines C<\"\"> as the default export, so\nthis is suitable for plugins which ignore the export name and always\nserve the same content.  See also L</EXPORT NAME> below.\n\nThe C<readonly> flag informs the plugin that the server was started\nwith the I<-r> flag on the command line, which is the same value\npassed to C<.preconnect> and C<.open>.  However, the NBD protocol does\nnot yet have a way to let the client advertise an intent to be\nread-only even when the server allows writes, so this parameter may\nnot be as useful as it appears.\n\nIf the C<default_only> flag is set then the client is querying for the\nname of the default export, and the plugin may optimize by adding only\na single export to the returned list (the default export name, usually\nC<\"\">).  The plugin can ignore this flag and return all exports if it\nwants.\n\nThe C<exports> parameter is an opaque object for collecting the list\nof exports.  Call C<nbdkit_add_export> to add a single export to the\nlist.  If the plugin has a concept of a default export (usually but\nnot always called C<\"\">) then it should return that first in the list.\n\n int nbdkit_add_export (struct nbdkit_export *exports,\n                        const char *name, const char *description);\n\nThe C<name> must be a non-NULL, UTF-8 string between 0 and 4096 bytes\nin length.  Export names must be unique.  C<description> is an\noptional description of the export which some clients can display but\nwhich is otherwise unused (if you don't want a description, you can\npass this parameter as C<NULL>).  The string(s) are copied into the\nexports list so you may free them immediately after calling this\nfunction.  C<nbdkit_add_export> returns C<0> on success or C<-1> on\nfailure; on failure C<nbdkit_error> has already been called, with\nC<errno> set to a suitable value.\n\nReturning C<0> will send the list of exports back to the client.  If\nthere is an error, C<.list_exports> should call C<nbdkit_error> with\nan error message and return C<-1>.\n\n=head2 C<.open>\n\n void *open (int readonly);\n\nThis is called when a new client connects to the nbdkit server.  The\ncallback should allocate a handle and return it.  This handle\nis passed back to other callbacks and could be freed in the C<.close>\ncallback.\n\nNote that the handle is completely opaque to nbdkit, but it must not\nbe NULL.  If you don't need to use a handle, return\nC<NBDKIT_HANDLE_NOT_NEEDED> which is a static non-NULL pointer.\n\nThe C<readonly> flag informs the plugin that the server was started\nwith the I<-r> flag on the command line which forces connections to be\nread-only.  Note that the plugin may I<additionally> force the\nconnection to be readonly (even if this flag is false) by returning\nfalse from the C<.can_write> callback.  So if your plugin can only\nserve read-only, you can ignore this parameter.\n\nIf the plugin wants to differentiate the content it serves based on\nclient input, then this is the spot to use C<nbdkit_export_name()> to\ndetermine which export the client requested.  See also L</EXPORT NAME>\nbelow.\n\nThis callback is called after the NBD handshake has completed; if the\nserver requires TLS authentication, then that has occurred as well.\nBut if the server is set up to have optional TLS authentication, you\nmay check C<nbdkit_is_tls> to learn whether the client has completed\nTLS authentication.  When running the server in a mode that permits\nbut not requires TLS, be careful that you do not allow unauthenticated\nclients to cause a denial of service against authentication.\n\nIf there is an error, C<.open> should call C<nbdkit_error> with an\nerror message and return C<NULL>.\n\n=head2 C<.close>\n\n void close (void *handle);\n\nThis is called when the client closes the connection.  It should clean\nup any per-connection resources.\n\nNote there is no way in the NBD protocol to communicate close errors\nback to the client, for example if your plugin calls L<close(2)> and\nyou are checking for errors (as you should do).  Therefore the best\nyou can do is to log the error on the server.  Well-behaved NBD\nclients I<should> try to flush the connection before it is closed and\ncheck for errors, but obviously this is outside the scope of nbdkit.\n\n=head2 C<.get_size>\n\n int64_t get_size (void *handle);\n\nThis is called during the option negotiation phase of the protocol\nto get the size (in bytes) of the block device being exported.\n\nThe returned size must be E<ge> 0.  If there is an error, C<.get_size>\nshould call C<nbdkit_error> with an error message and return C<-1>.\n\n=head2 C<.can_write>\n\n int can_write (void *handle);\n\nThis is called during the option negotiation phase to find out if the\nhandle supports writes.\n\nIf there is an error, C<.can_write> should call C<nbdkit_error> with\nan error message and return C<-1>.\n\nThis callback is not required.  If omitted, then we return true iff a\nC<.pwrite> callback has been defined.\n\n=head2 C<.can_flush>\n\n int can_flush (void *handle);\n\nThis is called during the option negotiation phase to find out if the\nhandle supports the flush-to-disk operation.\n\nIf there is an error, C<.can_flush> should call C<nbdkit_error> with\nan error message and return C<-1>.\n\nThis callback is not required.  If omitted, then we return true iff a\nC<.flush> callback has been defined.\n\n=head2 C<.is_rotational>\n\n int is_rotational (void *handle);\n\nThis is called during the option negotiation phase to find out if the\nbacking disk is a rotational medium (like a traditional hard disk) or\nnot (like an SSD).  If true, this may cause the client to reorder\nrequests to make them more efficient for a slow rotating disk.\n\nIf there is an error, C<.is_rotational> should call C<nbdkit_error>\nwith an error message and return C<-1>.\n\nThis callback is not required.  If omitted, then we return false.\n\n=head2 C<.can_trim>\n\n int can_trim (void *handle);\n\nThis is called during the option negotiation phase to find out if the\nplugin supports the trim/discard operation for punching holes in the\nbacking storage.\n\nIf there is an error, C<.can_trim> should call C<nbdkit_error> with an\nerror message and return C<-1>.\n\nThis callback is not required.  If omitted, then we return true iff a\nC<.trim> callback has been defined.\n\n=head2 C<.can_zero>\n\n int can_zero (void *handle);\n\nThis is called during the option negotiation phase to find out if the\nplugin wants the C<.zero> callback to be utilized.  Support for\nwriting zeroes is still advertised to the client (unless the\nL<nbdkit-nozero-filter(1)> is also used), so returning false merely\nserves as a way to avoid complicating the C<.zero> callback to have to\nfail with C<ENOTSUP> or C<EOPNOTSUPP> on the connections where it will\nnever be more efficient than using C<.pwrite> up front.\n\nIf there is an error, C<.can_zero> should call C<nbdkit_error> with an\nerror message and return C<-1>.\n\nThis callback is not required.  If omitted, then for a normal zero\nrequest, nbdkit always tries C<.zero> first if it is present, and\ngracefully falls back to C<.pwrite> if C<.zero> was absent or failed\nwith C<ENOTSUP> or C<EOPNOTSUPP>.\n\n=head2 C<.can_fast_zero>\n\n int can_fast_zero (void *handle);\n\nThis is called during the option negotiation phase to find out if the\nplugin wants to advertise support for fast zero requests.  If this\nsupport is not advertised, a client cannot attempt fast zero requests,\nand has no way to tell if writing zeroes offers any speedups compared\nto using C<.pwrite> (other than compressed network traffic).  If\nsupport is advertised, then C<.zero> will have\nC<NBDKIT_FLAG_FAST_ZERO> set when the client has requested a fast\nzero, in which case the plugin must fail with C<ENOTSUP> or\nC<EOPNOTSUPP> up front if the request would not offer any benefits\nover C<.pwrite>.  Advertising support for fast zero requests does not\nrequire that writing zeroes be fast, only that the result (whether\nsuccess or failure) is fast, so this should be advertised when\nfeasible.\n\nIf there is an error, C<.can_fast_zero> should call C<nbdkit_error>\nwith an error message and return C<-1>.\n\nThis callback is not required.  If omitted, then nbdkit returns true\nif C<.zero> is absent or C<.can_zero> returns false (in those cases,\nnbdkit fails all fast zero requests, as its fallback to C<.pwrite> is\nnot inherently faster), otherwise false (since it cannot be determined\nin advance if the plugin's C<.zero> will properly honor the semantics\nof C<NBDKIT_FLAG_FAST_ZERO>).\n\n=head2 C<.can_extents>\n\n int can_extents (void *handle);\n\nThis is called during the option negotiation phase to find out if the\nplugin supports detecting allocated (non-sparse) regions of the disk\nwith the C<.extents> callback.\n\nIf there is an error, C<.can_extents> should call C<nbdkit_error> with\nan error message and return C<-1>.\n\nThis callback is not required.  If omitted, then we return true iff a\nC<.extents> callback has been defined.\n\n=head2 C<.can_fua>\n\n int can_fua (void *handle);\n\nThis is called during the option negotiation phase to find out if the\nplugin supports the Forced Unit Access (FUA) flag on write, zero, and\ntrim requests.  If this returns C<NBDKIT_FUA_NONE>, FUA support is not\nadvertised to the client; if this returns C<NBDKIT_FUA_EMULATE>, the\nC<.flush> callback must work (even if C<.can_flush> returns false),\nand FUA support is emulated by calling C<.flush> after any write\noperation; if this returns C<NBDKIT_FUA_NATIVE>, then the C<.pwrite>,\nC<.zero>, and C<.trim> callbacks (if implemented) must handle the flag\nC<NBDKIT_FLAG_FUA>, by not returning until that action has landed in\npersistent storage.\n\nIf there is an error, C<.can_fua> should call C<nbdkit_error> with an\nerror message and return C<-1>.\n\nThis callback is not required unless a plugin wants to specifically\nhandle FUA requests.  If omitted, nbdkit checks whether C<.flush>\nexists, and behaves as if this function returns C<NBDKIT_FUA_NONE> or\nC<NBDKIT_FUA_EMULATE> as appropriate.\n\n=head2 C<.can_multi_conn>\n\n int can_multi_conn (void *handle);\n\nThis is called during the option negotiation phase to find out if the\nplugin is prepared to handle multiple connections from a single\nclient.  If the plugin sets this to true then a client may try to open\nmultiple connections to the nbdkit server and spread requests across\nall connections to maximize parallelism.  If the plugin sets it to\nfalse (which is the default) then well-behaved clients should only\nopen a single connection, although we cannot control what clients do\nin practice.\n\nSpecifically it means that either the plugin does not cache requests\nat all.  Or if it does cache them then the effects of a C<.flush>\nrequest or setting C<NBDKIT_FLAG_FUA> on a request must be visible\nacross all connections to the plugin before the plugin replies to that\nrequest.\n\nProperly working clients should send the same export name for each of\nthese connections.\n\nIf you use Linux L<nbd-client(8)> option S<I<-C num>> with\nS<num E<gt> 1> then Linux checks this flag and will refuse to connect\nif C<.can_multi_conn> is false.\n\nIf there is an error, C<.can_multi_conn> should call C<nbdkit_error>\nwith an error message and return C<-1>.\n\nThis callback is not required.  If omitted, then we return false.\n\n=head2 C<.can_cache>\n\n int can_cache (void *handle);\n\nThis is called during the option negotiation phase to find out if the\nplugin supports a cache operation. The nature of the caching is\nunspecified (including whether there are limits on how much can be\ncached at once, and whether writes to a cached region have\nwrite-through or write-back semantics), but the command exists to let\nclients issue a hint to the server that they will be accessing that\nregion of the export.\n\nIf this returns C<NBDKIT_CACHE_NONE>, cache support is not advertised\nto the client; if this returns C<NBDKIT_CACHE_EMULATE>, caching is\nemulated by the server calling C<.pread> and ignoring the results; if\nthis returns C<NBDKIT_CACHE_NATIVE>, then the C<.cache> callback will\nbe used.  If there is an error, C<.can_cache> should call\nC<nbdkit_error> with an error message and return C<-1>.\n\nThis callback is not required.  If omitted, then we return\nC<NBDKIT_CACHE_NONE> if the C<.cache> callback is missing, or\nC<NBDKIT_CACHE_NATIVE> if it is defined.\n\n=head2 C<.pread>\n\n int pread (void *handle, void *buf, uint32_t count, uint64_t offset,\n            uint32_t flags);\n\nDuring the data serving phase, nbdkit calls this callback to read data\nfrom the backing store.  C<count> bytes starting at C<offset> in the\nbacking store should be read and copied into C<buf>.  nbdkit takes\ncare of all bounds- and sanity-checking, so the plugin does not need\nto worry about that.\n\nThe parameter C<flags> exists in case of future NBD protocol\nextensions; at this time, it will be 0 on input.\n\nThe callback must read the whole C<count> bytes if it can.  The NBD\nprotocol doesn't allow partial reads (instead, these would be errors).\nIf the whole C<count> bytes was read, the callback should return C<0>\nto indicate there was I<no> error.\n\nIf there is an error (including a short read which couldn't be\nrecovered from), C<.pread> should call C<nbdkit_error> with an error\nmessage, and C<nbdkit_set_error> to record an appropriate error\n(unless C<errno> is sufficient), then return C<-1>.\n\n=head2 C<.pwrite>\n\n int pwrite (void *handle, const void *buf, uint32_t count, uint64_t offset,\n             uint32_t flags);\n\nDuring the data serving phase, nbdkit calls this callback to write\ndata to the backing store.  C<count> bytes starting at C<offset> in\nthe backing store should be written using the data in C<buf>.  nbdkit\ntakes care of all bounds- and sanity-checking, so the plugin does not\nneed to worry about that.\n\nThis function will not be called if C<.can_write> returned false.  The\nparameter C<flags> may include C<NBDKIT_FLAG_FUA> on input based on\nthe result of C<.can_fua>.\n\nThe callback must write the whole C<count> bytes if it can.  The NBD\nprotocol doesn't allow partial writes (instead, these would be\nerrors).  If the whole C<count> bytes was written successfully, the\ncallback should return C<0> to indicate there was I<no> error.\n\nIf there is an error (including a short write which couldn't be\nrecovered from), C<.pwrite> should call C<nbdkit_error> with an error\nmessage, and C<nbdkit_set_error> to record an appropriate error\n(unless C<errno> is sufficient), then return C<-1>.\n\n=head2 C<.flush>\n\n int flush (void *handle, uint32_t flags);\n\nDuring the data serving phase, this callback is used to\nL<fdatasync(2)> the backing store, ie. to ensure it has been\ncompletely written to a permanent medium.  If that is not possible\nthen you can omit this callback.\n\nThis function will not be called directly by the client if\nC<.can_flush> returned false; however, it may still be called by\nnbdkit if C<.can_fua> returned C<NBDKIT_FUA_EMULATE>.  The parameter\nC<flags> exists in case of future NBD protocol extensions; at this\ntime, it will be 0 on input.\n\nIf there is an error, C<.flush> should call C<nbdkit_error> with an\nerror message, and C<nbdkit_set_error> to record an appropriate error\n(unless C<errno> is sufficient), then return C<-1>.\n\n=head2 C<.trim>\n\n int trim (void *handle, uint32_t count, uint64_t offset, uint32_t flags);\n\nDuring the data serving phase, this callback is used to \"punch holes\"\nin the backing store.  If that is not possible then you can omit this\ncallback.\n\nThis function will not be called if C<.can_trim> returned false.  The\nparameter C<flags> may include C<NBDKIT_FLAG_FUA> on input based on\nthe result of C<.can_fua>.\n\nIf there is an error, C<.trim> should call C<nbdkit_error> with an\nerror message, and C<nbdkit_set_error> to record an appropriate error\n(unless C<errno> is sufficient), then return C<-1>.\n\n=head2 C<.zero>\n\n int zero (void *handle, uint32_t count, uint64_t offset, uint32_t flags);\n\nDuring the data serving phase, this callback is used to write C<count>\nbytes of zeroes at C<offset> in the backing store.\n\nThis function will not be called if C<.can_zero> returned false.  On\ninput, the parameter C<flags> may include C<NBDKIT_FLAG_MAY_TRIM>\nunconditionally, C<NBDKIT_FLAG_FUA> based on the result of\nC<.can_fua>, and C<NBDKIT_FLAG_FAST_ZERO> based on the result of\nC<.can_fast_zero>.\n\nIf C<NBDKIT_FLAG_MAY_TRIM> is requested, the operation can punch a\nhole instead of writing actual zero bytes, but only if subsequent\nreads from the hole read as zeroes.\n\nIf C<NBDKIT_FLAG_FAST_ZERO> is requested, the plugin must decide up\nfront if the implementation is likely to be faster than a\ncorresponding C<.pwrite>; if not, then it must immediately fail with\nC<ENOTSUP> or C<EOPNOTSUPP> (whether by C<nbdkit_set_error> or\nC<errno>) and preferably without modifying the exported image.  It is\nacceptable to always fail a fast zero request (as a fast failure is\nbetter than attempting the write only to find out after the fact that\nit was not fast after all).  Note that on Linux, support for\nC<ioctl(BLKZEROOUT)> is insufficient for determining whether a zero\nrequest to a block device will be fast (because the kernel will\nperform a slow fallback when needed).\n\nThe callback must write the whole C<count> bytes if it can.  The NBD\nprotocol doesn't allow partial writes (instead, these would be\nerrors).  If the whole C<count> bytes was written successfully, the\ncallback should return C<0> to indicate there was I<no> error.\n\nIf there is an error, C<.zero> should call C<nbdkit_error> with an\nerror message, and C<nbdkit_set_error> to record an appropriate error\n(unless C<errno> is sufficient), then return C<-1>.\n\nIf this callback is omitted, or if it fails with C<ENOTSUP> or\nC<EOPNOTSUPP> (whether by C<nbdkit_set_error> or C<errno>), then\nC<.pwrite> will be used as an automatic fallback except when the\nclient requested a fast zero.\n\n=head2 C<.extents>\n\n int extents (void *handle, uint32_t count, uint64_t offset,\n              uint32_t flags, struct nbdkit_extents *extents);\n\nDuring the data serving phase, this callback is used to detect\nallocated, sparse and zeroed regions of the disk.\n\nThis function will not be called if C<.can_extents> returned false.\nnbdkit's default behaviour in this case is to treat the whole virtual\ndisk as if it was allocated.  Also, this function will not be called\nby a client that does not request structured replies (the I<--no-sr>\noption of nbdkit can be used to test behavior when C<.extents> is\nunavailable to the client).\n\nThe callback should detect and return the list of extents overlapping\nthe range C<[offset...offset+count-1]>.  The C<extents> parameter\npoints to an opaque object which the callback should fill in by\ncalling C<nbdkit_add_extent>.  See L</Extents list> below.\n\nIf there is an error, C<.extents> should call C<nbdkit_error> with an\nerror message, and C<nbdkit_set_error> to record an appropriate error\n(unless C<errno> is sufficient), then return C<-1>.\n\n=head3 Extents list\n\nThe plugin C<extents> callback is passed an opaque pointer C<struct\nnbdkit_extents *extents>.  This structure represents a list of\nL<filesystem extents|https://en.wikipedia.org/wiki/Extent_(file_systems)>\ndescribing which areas of the disk are allocated, which are sparse\n(\u201choles\u201d), and, if supported, which are zeroes.\n\nThe C<extents> callback should scan the disk starting at C<offset> and\ncall C<nbdkit_add_extent> for each extent found.\n\nExtents overlapping the range C<[offset...offset+count-1]> should be\nreturned if possible.  However nbdkit ignores extents E<lt> offset so\nthe plugin may, if it is easier to implement, return all extent\ninformation for the whole disk.  The plugin may return extents beyond\nthe end of the range.  It may also return extent information for less\nthan the whole range, but it must return at least one extent\noverlapping C<offset>.\n\nThe extents B<must> be added in ascending order, and B<must> be\ncontiguous.\n\nThe C<flags> parameter of the C<.extents> callback may contain the\nflag C<NBDKIT_FLAG_REQ_ONE>.  This means that the client is only\nrequesting information about the extent overlapping C<offset>.  The\nplugin may ignore this flag, or as an optimization it may return just\na single extent for C<offset>.\n\n int nbdkit_add_extent (struct nbdkit_extents *extents,\n                        uint64_t offset, uint64_t length, uint32_t type);\n\nAdd an extent covering C<[offset...offset+length-1]> of one of\nthe following four types:\n\n=over 4\n\n=item C<type = 0>\n\nA normal, allocated data extent.\n\n=item C<type = NBDKIT_EXTENT_HOLE|NBDKIT_EXTENT_ZERO>\n\nAn unallocated extent, a.k.a. a \u201chole\u201d, which reads back as zeroes.\nThis is the normal type of hole applicable to most disks.\n\n=item C<type = NBDKIT_EXTENT_ZERO>\n\nAn allocated extent which is known to contain only zeroes.\n\n=item C<type = NBDKIT_EXTENT_HOLE>\n\nAn unallocated extent (hole) which does not read back as zeroes.  Note\nthis should only be used in specialized circumstances such as when\nwriting a plugin for (or to emulate) certain SCSI drives which do not\nguarantee that trimmed blocks read back as zeroes.\n\n=back\n\nC<nbdkit_add_extent> returns C<0> on success or C<-1> on failure.  On\nfailure C<nbdkit_error> and/or C<nbdkit_set_error> has already been\ncalled.  C<errno> will be set to a suitable value.\n\n=head2 C<.cache>\n\n int cache (void *handle, uint32_t count, uint64_t offset, uint32_t flags);\n\nDuring the data serving phase, this callback is used to give the\nplugin a hint that the client intends to make further accesses to the\ngiven region of the export.  The nature of caching is not specified\nfurther by the NBD specification (for example, a server may place\nlimits on how much may be cached at once, and there is no way to\ncontrol if writes to a cached area have write-through or write-back\nsemantics).  In fact, the cache command can always fail and still be\ncompliant, and success might not guarantee a performance gain.  If\nthis callback is omitted, then the results of C<.can_cache> determine\nwhether nbdkit will reject cache requests, treat them as instant\nsuccess, or emulate caching by calling C<.pread> over the same region\nand ignoring the results.\n\nThis function will not be called if C<.can_cache> did not return\nC<NBDKIT_CACHE_NATIVE>.  The parameter C<flags> exists in case of\nfuture NBD protocol extensions; at this time, it will be 0 on input. A\nplugin must fail this function if C<flags> includes an unrecognized\nflag, as that may indicate a requirement that the plugin comply must\nwith a specific caching semantic.\n\nIf there is an error, C<.cache> should call C<nbdkit_error> with an\nerror message, and C<nbdkit_set_error> to record an appropriate error\n(unless C<errno> is sufficient), then return C<-1>.\n\n=head2 C<.errno_is_preserved>\n\nThis field defaults to 0; if non-zero, nbdkit can reliably use the\nvalue of C<errno> when a callback reports failure, rather than the\nplugin having to call C<nbdkit_set_error>.\n\n=head1 SHUTDOWN\n\nWhen nbdkit receives certain signals it will shut down (see\nL<nbdkit(1)/SIGNALS>).  The server will wait for any currently running\nplugin callbacks to finish and also call the C<.unload> callback\nbefore unloading the plugin.\n\nNote that it's not guaranteed this can always happen (eg. the server\nmight be killed by C<SIGKILL> or segfault).\n\n=head2 Requesting asynchronous shutdown\n\nPlugins and filters can call L<exit(3)> in the configuration phase\n(before and including C<.get_ready>, but not in connected callbacks).\n\nOnce nbdkit has started serving connections, plugins and filters\nshould not call L<exit(3)>.  However they may instruct nbdkit to shut\ndown by calling C<nbdkit_shutdown>:\n\n void nbdkit_shutdown (void);\n\nThis function requests an asynchronous shutdown and returns (I<note>\nthat it does I<not> exit the process immediately).  It ensures that\nthe plugin and all filters are unloaded cleanly which may take some\ntime.  Further callbacks from nbdkit into the plugin or filter may\noccur after you have called this.\n\n=head1 PARSING COMMAND LINE PARAMETERS\n\n=head2 Parsing numbers\n\nThere are several functions for parsing numbers.  These all deal\ncorrectly with overflow, out of range and parse errors, and you should\nuse them instead of unsafe functions like L<sscanf(3)>, L<atoi(3)> and\nsimilar.\n\n int nbdkit_parse_int (const char *what, const char *str, int *r);\n int nbdkit_parse_unsigned (const char *what,\n                            const char *str, unsigned *r);\n int nbdkit_parse_int8_t (const char *what,\n                          const char *str, int8_t *r);\n int nbdkit_parse_uint8_t (const char *what,\n                           const char *str, uint8_t *r);\n int nbdkit_parse_int16_t (const char *what,\n                           const char *str, int16_t *r);\n int nbdkit_parse_uint16_t (const char *what,\n                            const char *str, uint16_t *r);\n int nbdkit_parse_int32_t (const char *what,\n                           const char *str, int32_t *r);\n int nbdkit_parse_uint32_t (const char *what,\n                            const char *str, uint32_t *r);\n int nbdkit_parse_int64_t (const char *what,\n                           const char *str, int64_t *r);\n int nbdkit_parse_uint64_t (const char *what,\n                            const char *str, uint64_t *r);\n\nParse string C<str> into an integer of various types.  These functions\nparse a decimal, hexadecimal (C<\"0x...\">) or octal (C<\"0...\">) number.\n\nOn success the functions return C<0> and set C<*r> to the parsed value\n(unless C<*r == NULL> in which case the result is discarded).  On\nerror, C<nbdkit_error> is called and the functions return C<-1>.  On\nerror C<*r> is always unchanged.\n\nThe C<what> parameter is printed in error messages to provide context.\nIt should usually be a short descriptive string of what you are trying\nto parse, eg:\n\n if (nbdkit_parse_int (\"random seed\", argv[1], &seed) == -1)\n   return -1;\n\nmight print an error:\n\n random seed: could not parse number: \"lalala\"\n\n=head2 Parsing sizes\n\nUse the C<nbdkit_parse_size> utility function to parse human-readable\nsize strings such as \"100M\" into the size in bytes.\n\n int64_t nbdkit_parse_size (const char *str);\n\nC<str> can be a string in a number of common formats.  The function\nreturns the size in bytes.  If there was an error, it returns C<-1>.\n\n=head2 Parsing booleans\n\nUse the C<nbdkit_parse_bool> utility function to parse human-readable\nstrings such as \"on\" into a boolean value.\n\n int nbdkit_parse_bool (const char *str);\n\nC<str> can be a string containing a case-insensitive form of various\ncommon toggle values.  The function returns 0 or 1 if the parse was\nsuccessful.  If there was an error, it returns C<-1>.\n\n=head2 Reading passwords\n\nThe C<nbdkit_read_password> utility function can be used to read\npasswords from config parameters:\n\n int nbdkit_read_password (const char *value, char **password);\n\nFor example:\n\n char *password = NULL;\n \n static int\n myplugin_config (const char *key, const char *value)\n {\n   ..\n   if (strcmp (key, \"password\") == 0) {\n     free (password);\n     if (nbdkit_read_password (value, &password) == -1)\n       return -1;\n   }\n   ..\n }\n\nThe C<password> result string is allocated by malloc, and so you may\nneed to free it.\n\nThis function recognizes several password formats.  A password may be\nused directly on the command line, eg:\n\n nbdkit myplugin password=mostsecret\n\nBut more securely this function can also read a password\ninteractively:\n\n nbdkit myplugin password=-\n\nor from a file:\n\n nbdkit myplugin password=+/tmp/secret\n\nor from a file descriptor inherited by nbdkit:\n\n nbdkit myplugin password=-99\n\n=head3 Notes on reading passwords\n\nIf the password begins with a C<-> or C<+> character then it must be\npassed in a file.\n\nC<password=-> can only be used when stdin is a terminal.\n\nC<password=-FD> cannot be used with stdin, stdout or stderr\n(ie. C<-0>, C<-1> or C<-2>).  The reason is that after reading the\npassword the file descriptor is closed, which causes bad stuff to\nhappen.\n\n=head2 Safely interacting with stdin and stdout\n\n int nbdkit_stdio_safe (void);\n\nThe C<nbdkit_stdio_safe> utility function returns C<1> if it is safe\nto interact with stdin and stdout during the configuration phase, and\nC<0> otherwise.  This is because when the nbdkit I<-s> option is used\nthe plugin must not directly interact with stdin, because that would\ninterfere with the client.\n\nThe result of this function only matters in callbacks up to\nC<.config_complete>.  Once nbdkit reaches C<.get_ready>, the plugin\nshould assume that nbdkit may have closed the original stdin and\nstdout in order to become a daemon.\n\nL<nbdkit-sh-plugin(3)> uses this function to determine whether it is\nsafe to support C<script=-> to read a script from stdin.  Also\nconstructs like C<password=-> (see L</Reading passwords> above) are\ndisabled when reading from stdio is not safe.\n\n=head1 FILENAMES AND PATHS\n\nThe server usually (not always) changes directory to C</> before it\nstarts serving connections.  This means that any relative paths passed\nduring configuration will not work when the server is running\n(example: S<C<nbdkit plugin.so disk.img>>).\n\nTo avoid problems, prepend relative paths with the current directory\nbefore storing them in the handle.  Or open files and store the file\ndescriptor.\n\n=head2 C<nbdkit_absolute_path>\n\n char *nbdkit_absolute_path (const char *filename);\n\nThe utility function C<nbdkit_absolute_path> converts any path to an\nabsolute path: if it is relative, then all this function does is\nprepend the current working directory to the path, with no extra\nchecks.\n\nNote that this function works I<only> when used in the C<.config>,\nC<.config_complete> and C<.get_ready> callbacks.\n\nIf conversion was not possible, this calls C<nbdkit_error> and returns\nC<NULL>.  Note that this function does not check that the file exists.\n\nThe returned string must be freed by the caller.\n\n=head2 C<nbdkit_realpath>\n\n char *nbdkit_realpath (const char *filename);\n\nThe utility function C<nbdkit_realpath> converts any path to an\nabsolute path, resolving symlinks.  Under the hood it uses the\nC<realpath> function, and thus it fails if the path does not exist,\nor it is not possible to access to any of the components of the path.\n\nNote that this function works I<only> when used in the C<.config>,\nC<.config_complete> and C<.get_ready> callbacks.\n\nIf the path resolution was not possible, this calls C<nbdkit_error>\nand returns C<NULL>.\n\nThe returned string must be freed by the caller.\n\n=head2 umask\n\nAll plugins will see a L<umask(2)> of C<0022>.\n\n=head1 SLEEPING\n\nA plugin that needs to sleep may call L<sleep(2)>, L<nanosleep(2)> and\nsimilar.  However that can cause nbdkit to delay excessively when\nshutting down (since it must wait for any plugin or filter which is\nsleeping).  To avoid this there is a special wrapper around nanosleep\nwhich plugins and filters should use instead.\n\n=head2 C<nbdkit_nanosleep>\n\n int nbdkit_nanosleep (unsigned sec, unsigned nsec);\n\nThe utility function C<nbdkit_nanosleep> suspends the current thread,\nand returns 0 if it slept at least as many seconds and nanoseconds as\nrequested, or -1 after calling C<nbdkit_error> if there is no point in\ncontinuing the current command.  Attempts to sleep more than\nC<INT_MAX> seconds are treated as an error.\n\n=head1 EXPORT NAME\n\nIf the client negotiated an NBD export name with nbdkit then plugins\nmay read this from any connected callbacks.  Nbdkit's normal behaviour\nis to accept any export name passed by the client, log it in debug\noutput, but otherwise ignore it.  By using C<nbdkit_export_name>\nplugins may choose to filter by export name or serve different\ncontent.\n\n=head2 C<nbdkit_export_name>\n\n const char *nbdkit_export_name (void);\n\nReturn the optional NBD export name if one was negotiated with the\ncurrent client (this uses thread-local magic so no parameter is\nrequired).  The returned string is valid at least through the\nC<.close> of the current connection, but if you need to store it\nin the plugin for use by more than one client you must copy it.\n\nThe export name is a free-form text string, it is not necessarily a\npath or filename and it does not need to begin with a C<'/'>\ncharacter.  The NBD protocol describes the empty string (C<\"\">) as a\nrepresenting a \"default export\" or to be used in cases where the\nexport name does not make sense.  B<The export name is untrusted\nclient data, be cautious when parsing it.>\n\nOn error, C<nbdkit_error> is called and the call returns C<NULL>.\n\n=head1 STRING LIFETIME\n\nSome callbacks are specified to return C<const char *>, even when a\nplugin may not have a suitable compile-time constant to return.\nReturning dynamically-allocated memory for such a callback would\ninduce a memory leak or otherwise complicate the plugin to perform\nadditional bookkeeping.  For these cases, nbdkit provides several\nconvenience functions for creating a copy of a string for better\nlifetime management.\n\n=head2 C<nbdkit_strdup_intern>\n\n=head2 C<nbdkit_strndup_intern>\n\n const char *nbdkit_strdup_intern (const char *str);\n const char *nbdkit_strndup_intern (const char *str, size_t n);\n\nReturns a copy of C<str>, possibly limited to a maximum of C<n> bytes,\nso that the caller may reclaim str and use the copy in its place.  If\nthe copy is created outside the scope of a connection (such as during\nC<.load> or C<.config>), the lifetime of the copy will last at least\nthrough C<.unload>.  If the copy is created after a client has\ntriggered a connection (such as during C<.preconnect> or C<.open>),\nthe lifetime will last at least through C<.close>, but the copy is not\nsafe to share with other connections.\n\nOn error, C<nbdkit_error> is called and the call returns C<NULL>.\n\n=head2 C<nbdkit_printf_intern>\n\n=head2 C<nbdkit_vprintf_intern>\n\n const char *nbdkit_printf_intern (const char *fmt, ...);\n const char *nbdkit_vprintf_intern (const char *fmt, va_list ap);\n\nReturn a string created from a format template, with a lifetime longer\nthan the current connection.  Shorthand for passing C<fmt> to\nL<asprintf(3)> on a temporary string, then passing that result to\nC<nbdkit_strdup_intern>.\n\nOn error, C<nbdkit_error> is called and the call returns C<NULL>.\n\n=head1 AUTHENTICATION\n\nA server may use C<nbdkit_is_tls> to limit which export names work\nuntil after a client has completed TLS authentication.  See\nL<nbdkit-tls(1)>.  It is also possible to use\nL<nbdkit-tls-fallback-filter(1)> to automatically ensure that the\nplugin is only used with authentication.\n\n=head2 C<nbdkit_is_tls>\n\n int nbdkit_is_tls (void);\n\nReturn true if the client has completed TLS authentication, or false\nif the connection is still plaintext.\n\nOn error (such as calling this function outside of the context of\nC<.open>), C<nbdkit_error> is called and the call returns C<-1>.\n\n=head1 PEER NAME\n\nIt is possible to get the address of the client when you are running\nin any connected callback.\n\n=head2 C<nbdkit_peer_name>\n\n int nbdkit_peer_name (struct sockaddr *addr, socklen_t *addrlen);\n\nReturn the peer (client) address, if available.  The C<addr> and\nC<addrlen> parameters behave like L<getpeername(2)>.  In particular\nyou must initialize C<addrlen> with the size of the buffer pointed to\nby C<addr>, and if C<addr> is not large enough then the address will\nbe truncated.\n\nIn some cases this is not available or the address returned will be\nmeaningless (eg. if there is a proxy between the client and nbdkit).\nThis call uses thread-local magic so no parameter is required to\nspecify the current connection.\n\nOn success this returns C<0>.  On error, C<nbdkit_error> is called and\nthis call returns C<-1>.\n\n=head1 DEBUGGING\n\nRun the server with I<-f> and I<-v> options so it doesn't fork and you\ncan see debugging information:\n\n nbdkit -fv ./myplugin.so [key=value [key=value [...]]]\n\nTo print debugging information from within the plugin, call\nC<nbdkit_debug>, which has the following prototype and works like\nL<printf(3)>:\n\n void nbdkit_debug (const char *fs, ...);\n void nbdkit_vdebug (const char *fs, va_list args);\n\nFor convenience, C<nbdkit_debug> preserves the value of C<errno>, and\nalso supports the glibc extension of a single C<%m> in a format string\nexpanding to C<strerror(errno)>, even on platforms that don't support\nthat natively. Note that C<nbdkit_debug> only prints things when the\nserver is in verbose mode (I<-v> option).\n\n=head2 Debug Flags\n\nThe I<-v> option switches general debugging on or off, and this\ndebugging should be used for messages which are useful for all users\nof your plugin.\n\nIn cases where you want to enable specific extra debugging to track\ndown bugs in plugins or filters \u2014 mainly for use by the plugin/filter\ndevelopers themselves \u2014 you can define Debug Flags.  These are global\nints called C<myplugin_debug_*>:\n\n int myplugin_debug_foo;\n int myplugin_debug_bar;\n ...\n if (myplugin_debug_foo) {\n   nbdkit_debug (\"lots of extra debugging about foo: ...\");\n }\n\nDebug Flags can be controlled on the command line using the I<-D> (or\nI<--debug>) option:\n\n nbdkit -f -v -D myplugin.foo=1 -D myplugin.bar=2 myplugin [...]\n\nNote C<myplugin> is the name passed to C<.name> in the C<struct\nnbdkit_plugin>.\n\nYou should only use this feature for debug settings.  For general\nsettings use ordinary plugin parameters.  Debug Flags can only be C\nints.  They are not supported by non-C language plugins.\n\nFor convenience C<'.'> characters are replaced with C<'_'> characters\nin the variable name, so both of these parameters:\n\n -D myplugin.foo_bar=1\n -D myplugin.foo.bar=1\n\ncorrespond to the plugin variable C<myplugin_debug_foo_bar>.\n\n=head1 COMPILING THE PLUGIN\n\nPlugins should be compiled as shared libraries.  There are various\nways to achieve this, but most Linux compilers support a I<-shared>\noption to create the shared library directly, for example:\n\n gcc -fPIC -shared myplugin.c -o myplugin.so\n\nNote that the shared library will have undefined symbols for functions\nthat you call like C<nbdkit_parse_int> or C<nbdkit_error>.  These will\nbe resolved by the server binary when nbdkit dlopens the plugin.\n\n=head2 PKG-CONFIG/PKGCONF\n\nnbdkit provides a pkg-config/pkgconf file called C<nbdkit.pc> which\nshould be installed on the correct path when the nbdkit plugin\ndevelopment environment is installed.  You can use this in autoconf\nF<configure.ac> scripts to test for the development environment:\n\n PKG_CHECK_MODULES([NBDKIT], [nbdkit >= 1.2.3])\n\nThe above will fail unless nbdkit E<ge> 1.2.3 and the header file is\ninstalled, and will set C<NBDKIT_CFLAGS> and C<NBDKIT_LIBS>\nappropriately for compiling plugins.\n\nYou can also run pkg-config/pkgconf directly, for example:\n\n if ! pkg-config nbdkit --exists; then\n   echo \"you must install the nbdkit plugin development environment\"\n   exit 1\n fi\n\nYou can also substitute the plugindir variable by doing:\n\n PKG_CHECK_VAR([NBDKIT_PLUGINDIR], [nbdkit], [plugindir])\n\nwhich defines C<$(NBDKIT_PLUGINDIR)> in automake-generated Makefiles.\n\nIf nbdkit development headers are installed in a non-standard location\nthen you may need to compile plugins using:\n\n gcc -fPIC -shared myplugin.c -o myplugin.so \\\n   `pkg-config nbdkit --cflags --libs`\n\n=head1 INSTALLING THE PLUGIN\n\nThe plugin is a C<*.so> file and possibly a manual page.  You can of\ncourse install the plugin C<*.so> file wherever you want, and users\nwill be able to use it by running:\n\n nbdkit /path/to/plugin.so [args]\n\nHowever B<if> the shared library has a name of the form\nC<nbdkit-I<name>-plugin.so> B<and if> the library is installed in the\nC<$plugindir> directory, then users can be run it by only typing:\n\n nbdkit name [args]\n\nThe location of the C<$plugindir> directory is set when nbdkit is\ncompiled and can be found by doing:\n\n nbdkit --dump-config\n\nIf using the pkg-config/pkgconf system then you can also find the\nplugin directory at compile time by doing:\n\n pkg-config nbdkit --variable=plugindir\n\n=head1 WRITING PLUGINS IN OTHER PROGRAMMING LANGUAGES\n\nYou can also write nbdkit plugins in Go, Lua, OCaml, Perl, Python,\nRuby, Rust, shell script or Tcl.  Other programming languages may be\noffered in future.\n\nFor more information see:\n__LANG_PLUGIN_LINKS__.\n\nPlugins written in scripting languages may also be installed in\nC<$plugindir>.  These must be called C<nbdkit-I<name>-plugin> without\nany extension.  They must be executable, and they must use the shebang\nheader (see L<nbdkit(1)/Shebang scripts>).  For example a plugin\nwritten in Perl called C<foo.pl> might be installed like this:\n\n $ head -1 foo.pl\n #!/usr/sbin/nbdkit perl\n\n $ sudo install -m 0755 foo.pl $plugindir/nbdkit-foo-plugin\n\nand then users will be able to run it like this:\n\n $ nbdkit foo [args ...]\n\n=head1 SEE ALSO\n\nL<nbdkit(1)>,\nL<nbdkit-nozero-filter(1)>,\nL<nbdkit-tls-fallback-filter(1)>,\nL<nbdkit-filter(3)>.\n\nStandard plugins provided by nbdkit:\n\n__PLUGIN_LINKS__.\n\n=head1 AUTHORS\n\nEric Blake\n\nRichard W.M. Jones\n\nPino Toscano\n\n=head1 COPYRIGHT\n\nCopyright (C) 2013-2020 Red Hat Inc.\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-nbdkit-1.23.4-zdmjm7bz4ia3c42zyid3wwz4ba2luhs6/spack-src/tests/old-plugins/i686/Linux/v1.8.4-3-g11f5a90d/nbdkit-file-plugin.so",
        "/tmp/vanessa/spack-stage/spack-stage-nbdkit-1.23.4-zdmjm7bz4ia3c42zyid3wwz4ba2luhs6/spack-src/tests/old-plugins/i686/Linux/v1.0.0/nbdkit-file-plugin.so",
        "/tmp/vanessa/spack-stage/spack-stage-nbdkit-1.23.4-zdmjm7bz4ia3c42zyid3wwz4ba2luhs6/spack-src/tests/old-plugins/i686/Linux/v1.12.8-2-g1e2ccc27/nbdkit-file-plugin.so",
        "/tmp/vanessa/spack-stage/spack-stage-nbdkit-1.23.4-zdmjm7bz4ia3c42zyid3wwz4ba2luhs6/spack-src/tests/old-plugins/i686/Linux/v1.2.8-2-gd2d934df/nbdkit-file-plugin.so",
        "/tmp/vanessa/spack-stage/spack-stage-nbdkit-1.23.4-zdmjm7bz4ia3c42zyid3wwz4ba2luhs6/spack-src/tests/old-plugins/i686/Linux/v1.18.4/nbdkit-file-plugin.so",
        "/tmp/vanessa/spack-stage/spack-stage-nbdkit-1.23.4-zdmjm7bz4ia3c42zyid3wwz4ba2luhs6/spack-src/tests/old-plugins/x86_64/Linux/v1.0.0/nbdkit-file-plugin.so",
        "/tmp/vanessa/spack-stage/spack-stage-nbdkit-1.23.4-zdmjm7bz4ia3c42zyid3wwz4ba2luhs6/spack-src/tests/old-plugins/x86_64/Linux/v1.8.4/nbdkit-file-plugin.so",
        "/tmp/vanessa/spack-stage/spack-stage-nbdkit-1.23.4-zdmjm7bz4ia3c42zyid3wwz4ba2luhs6/spack-src/tests/old-plugins/x86_64/Linux/v1.18.2/nbdkit-file-plugin.so",
        "/tmp/vanessa/spack-stage/spack-stage-nbdkit-1.23.4-zdmjm7bz4ia3c42zyid3wwz4ba2luhs6/spack-src/tests/old-plugins/x86_64/Linux/v1.2.8/nbdkit-file-plugin.so",
        "/tmp/vanessa/spack-stage/spack-stage-nbdkit-1.23.4-zdmjm7bz4ia3c42zyid3wwz4ba2luhs6/spack-src/tests/old-plugins/x86_64/Linux/v1.12.8/nbdkit-file-plugin.so"
    ],
    "total_files": 748
}