{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-gatepet2stir-1.3.2-qskkbuvdg66mcrxq5ek7447nwea4b6ze/spack-src/include/root/Reflex/SharedLibrary.h": "// @(#)root/reflex:$Id: SharedLibrary.h 42838 2012-01-31 17:06:48Z axel $\n// Author: Stefan Roiser 2006\n\n// Copyright CERN, CH-1211 Geneva 23, 2004-2006, All rights reserved.\n//\n// Permission to use, copy, modify, and distribute this software for any\n// purpose is hereby granted without fee, provided that this copyright and\n// permissions notice appear in all copies and derivatives.\n//\n// This software is provided \"as is\" without express or implied warranty.\n\n#ifndef Reflex_SharedLibrary\n#define Reflex_SharedLibrary\n\n// Include files\n#ifdef _WIN32\n# include <windows.h>\n#else\n# include <dlfcn.h>\n# include <errno.h>\n#endif\n\n\nnamespace Reflex {\n/**\n * @class SharedLibrary SharedLibrary.h Reflex/SharedLibrary.h\n * @author Stefan Roiser\n * @date 24/11/2006\n * @ingroup Ref\n * Parts of this implementation are copyied from SEAL (http://cern.ch/seal)\n */\nclass SharedLibrary {\npublic:\n   SharedLibrary(const std::string& libname);\n\n   bool Load();\n\n   bool Unload();\n\n   bool Symbol(const std::string& symname,\n               void*& sym);\n\n   std::string Error();\n\nprivate:\n   /** a handle to the loaded library */\n#ifdef _WIN32\n   HMODULE fHandle;\n#else\n   void* fHandle;\n#endif\n   /** the name of the shared library to handle */\n   std::string fLibName;\n};\n\n} // namespace Reflex\n\n\n//-------------------------------------------------------------------------------\ninline Reflex::SharedLibrary::SharedLibrary(const std::string& libname):\n//-------------------------------------------------------------------------------\n   fHandle(0),\n   fLibName(libname) {\n}\n\n\n//-------------------------------------------------------------------------------\ninline std::string\nReflex::SharedLibrary::Error() {\n//-------------------------------------------------------------------------------\n   std::string errString;\n#ifdef _WIN32\n   int error = ::GetLastError();\n   LPVOID lpMessageBuffer;\n   ::FormatMessage(\n      FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,\n      NULL,\n      error,\n      MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), //The user default language\n      (LPTSTR) &lpMessageBuffer,\n      0,\n      NULL);\n   errString = (const char*) lpMessageBuffer;\n   // Free the buffer allocated by the system\n   ::LocalFree(lpMessageBuffer);\n#else\n   const char* err = dlerror();\n   if (err) {\n      errString = err;\n   }\n#endif\n   return errString;\n} // Error\n\n\n//-------------------------------------------------------------------------------\ninline bool\nReflex::SharedLibrary::Load() {\n//-------------------------------------------------------------------------------\n\n#ifdef _WIN32\n   ::SetErrorMode(0);\n   fHandle = ::LoadLibrary(fLibName.c_str());\n#else\n   fHandle = ::dlopen(fLibName.c_str(), RTLD_LAZY | RTLD_GLOBAL);\n#endif\n\n   if (!fHandle) {\n      return false;\n   } else { return true; }\n}\n\n\n//-------------------------------------------------------------------------------\ninline bool\nReflex::SharedLibrary::Symbol(const std::string& symname,\n                              void*& sym) {\n//-------------------------------------------------------------------------------\n\n   if (fHandle) {\n#ifdef _WIN32\n      sym = GetProcAddress(fHandle, symname.c_str());\n#else\n      sym = dlsym(fHandle, symname.c_str());\n#endif\n\n      if (sym) {\n         return true;\n      }\n   }\n   return false;\n}\n\n\n//-------------------------------------------------------------------------------\ninline bool\nReflex::SharedLibrary::Unload() {\n//-------------------------------------------------------------------------------\n\n#ifdef _WIN32\n\n   if (FreeLibrary(fHandle) == 0) {\n      return false;\n   }\n#else\n\n   if (dlclose(fHandle) == -1) {\n      return false;\n   }\n#endif\n   else { return true; }\n}\n\n\n#endif // Reflex_SharedLibrary\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-gatepet2stir-1.3.2-qskkbuvdg66mcrxq5ek7447nwea4b6ze/spack-src/main_icon.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gatepet2stir-1.3.2-qskkbuvdg66mcrxq5ek7447nwea4b6ze/spack-src/include/root/TFumiliFCN.h",
        "/tmp/vanessa/spack-stage/spack-stage-gatepet2stir-1.3.2-qskkbuvdg66mcrxq5ek7447nwea4b6ze/spack-src/.git/objects/pack/pack-bfa253d42ce3961a66914daf090d561cebf99629.pack",
        "/tmp/vanessa/spack-stage/spack-stage-gatepet2stir-1.3.2-qskkbuvdg66mcrxq5ek7447nwea4b6ze/spack-src/.git/objects/pack/pack-bfa253d42ce3961a66914daf090d561cebf99629.idx",
        "/tmp/vanessa/spack-stage/spack-stage-gatepet2stir-1.3.2-qskkbuvdg66mcrxq5ek7447nwea4b6ze/spack-src/libraries/qwt-6.0.2/libqwtmathml.so.6.0.2",
        "/tmp/vanessa/spack-stage/spack-stage-gatepet2stir-1.3.2-qskkbuvdg66mcrxq5ek7447nwea4b6ze/spack-src/libraries/qwt-6.0.2/libqwt.so.6.0.2",
        "/tmp/vanessa/spack-stage/spack-stage-gatepet2stir-1.3.2-qskkbuvdg66mcrxq5ek7447nwea4b6ze/spack-src/libraries/qwt-6.0.2/libqwt.so.6.0",
        "/tmp/vanessa/spack-stage/spack-stage-gatepet2stir-1.3.2-qskkbuvdg66mcrxq5ek7447nwea4b6ze/spack-src/libraries/qwt-6.0.2/libqwt.so",
        "/tmp/vanessa/spack-stage/spack-stage-gatepet2stir-1.3.2-qskkbuvdg66mcrxq5ek7447nwea4b6ze/spack-src/libraries/qwt-6.0.2/libqwt.so.6"
    ],
    "total_files": 2303
}