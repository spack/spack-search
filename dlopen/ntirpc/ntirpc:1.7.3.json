{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-ntirpc-1.7.3-465qfzcbzxrewsdxa3szlxyog3mspjck/spack-src/ntirpc/misc/winpthreads.h": "/*\n * Posix Threads library for Microsoft Windows\n *\n * Use at own risk, there is no implied warranty to this code.\n * It uses undocumented features of Microsoft Windows that can change\n * at any time in the future.\n *\n * (C) 2010 Lockless Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n *\n *  * Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *  * Neither the name of Lockless Inc. nor the names of its contributors may be\n *    used to endorse or promote products derived from this software without\n *    specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AN ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n * FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE\n * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n * OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*\n * You may want to use the MingW64 winpthreads library instead.\n * It is based on this, but adds error checking.\n */\n\n/*\n * Version 1.0.1 Released 2 Feb 2012\n * Fixes pthread_barrier_destroy() to wait for threads to exit the barrier.\n */\n\n#ifndef WIN_PTHREADS\n#define WIN_PTHREADS\n\n#include <windows.h>\n#include <process.h>\n\n#include <setjmp.h>\n#include <errno.h>\n#include <sys/timeb.h>\n\n#if !defined(__MINGW32__)\t/* XXX 64? */\n#define ETIMEDOUT\t110\n#define ENOTSUP\t\t134\n#endif\n\n#define PTHREAD_CANCEL_DISABLE 0\n#define PTHREAD_CANCEL_ENABLE 0x01\n\n#define PTHREAD_CANCEL_DEFERRED 0\n#define PTHREAD_CANCEL_ASYNCHRONOUS 0x02\n\n#define PTHREAD_CREATE_JOINABLE 0\n#define PTHREAD_CREATE_DETACHED 0x04\n\n#define PTHREAD_EXPLICT_SCHED 0\n#define PTHREAD_INHERIT_SCHED 0x08\n\n#define PTHREAD_SCOPE_PROCESS 0\n#define PTHREAD_SCOPE_SYSTEM 0x10\n\n#define PTHREAD_DEFAULT_ATTR (PTHREAD_CANCEL_ENABLE)\n\n#define PTHREAD_CANCELED ((void *) 0xDEADBEEF)\n\n#define PTHREAD_ONCE_INIT 0\n#define PTHREAD_MUTEX_INITIALIZER {(void *) -1, -1, 0, 0, 0, 0}\n#define PTHREAD_RWLOCK_INITIALIZER {0}\n#define PTHREAD_COND_INITIALIZER {0}\n#define PTHREAD_BARRIER_INITIALIZER \\\n\t{0, 0, PTHREAD_MUTEX_INITIALIZER, PTHREAD_COND_INITIALIZER}\n#define PTHREAD_SPINLOCK_INITIALIZER 0\n\n#define PTHREAD_DESTRUCTOR_ITERATIONS 256\n#define PTHREAD_KEYS_MAX (1<<20)\n\n#define PTHREAD_MUTEX_NORMAL 0\n#define PTHREAD_MUTEX_ERRORCHECK 1\n#define PTHREAD_MUTEX_RECURSIVE 2\n#define PTHREAD_MUTEX_DEFAULT 3\n#define PTHREAD_MUTEX_SHARED 4\n#define PTHREAD_MUTEX_PRIVATE 0\n#define PTHREAD_PRIO_NONE 0\n#define PTHREAD_PRIO_INHERIT 8\n#define PTHREAD_PRIO_PROTECT 16\n#define PTHREAD_PRIO_MULT 32\n#define PTHREAD_PROCESS_SHARED 0\n#define PTHREAD_PROCESS_PRIVATE 1\n\n#define PTHREAD_BARRIER_SERIAL_THREAD 1\n\n#if !defined(__MINGW32__)\n/* Windows doesn't have this, so declare it ourselves. */\nstruct timespec {\n\t/* long long in windows is the same as long in unix for 64bit */\n\tlong long tv_sec;\n\tlong long tv_nsec;\n};\n#endif\n\ntypedef struct _pthread_cleanup _pthread_cleanup;\nstruct _pthread_cleanup {\n\tvoid (*func) (void *);\n\tvoid *arg;\n\t_pthread_cleanup *next;\n};\n\nstruct _pthread_v {\n\tvoid *ret_arg;\n\tvoid *(*func) (void *);\n\t_pthread_cleanup *clean;\n\tuintptr_t h;\n\tint cancelled;\n\tunsigned p_state;\n\tint keymax;\n\tvoid **keyval;\n\n\tjmp_buf jb;\n};\n\ntypedef struct _pthread_v *pthread_t;\n\n#if defined(__MINGW32__)\n#include <winbase.h>\n\ntypedef struct _RTL_CONDITION_VARIABLE {\n\tPVOID Ptr;\n} CONDITION_VARIABLE, *PCONDITION_VARIABLE;\n\ntypedef struct _RTL_SRWLOCK {\n\tPVOID Ptr;\n} SRWLOCK, *PSRWLOCK;\n\n#endif\n\ntypedef struct pthread_barrier_t pthread_barrier_t;\nstruct pthread_barrier_t {\n\tint count;\n\tint total;\n\tCRITICAL_SECTION m;\n\tCONDITION_VARIABLE cv;\n};\n\ntypedef struct pthread_attr_t pthread_attr_t;\nstruct pthread_attr_t {\n\tunsigned p_state;\n\tvoid *stack;\n\tsize_t s_size;\n};\n\ntypedef long pthread_once_t;\ntypedef unsigned pthread_mutexattr_t;\ntypedef SRWLOCK pthread_rwlock_t;\ntypedef CRITICAL_SECTION pthread_mutex_t;\ntypedef unsigned pthread_key_t;\ntypedef void *pthread_barrierattr_t;\ntypedef long pthread_spinlock_t;\ntypedef int pthread_condattr_t;\ntypedef CONDITION_VARIABLE pthread_cond_t;\ntypedef int pthread_rwlockattr_t;\n\nvolatile long _pthread_cancelling;\n\nint _pthread_concur;\n\n/* Will default to zero as needed */\npthread_once_t _pthread_tls_once;\nDWORD _pthread_tls;\n\n/* Note initializer is zero, so this works */\npthread_rwlock_t _pthread_key_lock;\nlong _pthread_key_max;\nlong _pthread_key_sch;\nvoid (**_pthread_key_dest) (void *);\n\n#define pthread_cleanup_push(F, A)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tconst _pthread_cleanup _pthread_cup = {(F), (A),\t\\\n\t\t\t\t\t\t       pthread_self()->clean}; \\\n\t\t_ReadWriteBarrier();\t\t\t\t\t\\\n\t\tpthread_self()->clean = (_pthread_cleanup *) &_pthread_cup; \\\n\t\t_ReadWriteBarrier();\t\t\t\t\t\\\n\t} while (0)\n\n#define pthread_cleanup_pop(E) \\\n\tdo {\t\t\t\t\t\t    \\\n\t\t_pthread_cleanup *_pthread_cup = pthread_self()->clean; \\\n\t\tif (_pthread_cup)  {\t\t\t\t\t\\\n\t\t\t_pthread_cup->func(_pthread_cup->arg);\t\t\\\n\t\t\tpthread_self()->clean = _pthread_cup->next;\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n\nstatic void\n_pthread_once_cleanup(void *arg)\n{\n\tpthread_once_t *o = (pthread_once_t *) arg;\n\t*o = 0;\n}\n\nstatic pthread_t pthread_self(void);\n\nstatic int\npthread_once(pthread_once_t *o, void (*func) (void))\n{\n\tlong state = *o;\n\n\t_ReadWriteBarrier();\n\n\twhile (state != 1) {\n\t\tif (!state) {\n\t\t\tif (!_InterlockedCompareExchange(o, 2, 0)) {\n\t\t\t\t/* Success */\n\t\t\t\tpthread_cleanup_push(_pthread_once_cleanup, o);\n\t\t\t\tfunc();\n\t\t\t\tpthread_cleanup_pop(0);\n\n\t\t\t\t/* Mark as done */\n\t\t\t\t*o = 1;\n\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tYieldProcessor();\n\n\t\t_ReadWriteBarrier();\n\n\t\tstate = *o;\n\t}\n\n\t/* Done */\n\treturn 0;\n}\n\nstatic int\n_pthread_once_raw(pthread_once_t *o, void (*func) (void))\n{\n\tlong state = *o;\n\n\t_ReadWriteBarrier();\n\n\twhile (state != 1) {\n\t\tif (!state) {\n\t\t\tif (!_InterlockedCompareExchange(o, 2, 0)) {\n\t\t\t\t/* Success */\n\t\t\t\tfunc();\n\n\t\t\t\t/* Mark as done */\n\t\t\t\t*o = 1;\n\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tYieldProcessor();\n\n\t\t_ReadWriteBarrier();\n\n\t\tstate = *o;\n\t}\n\n\t/* Done */\n\treturn 0;\n}\n\nstatic int\npthread_mutex_lock(pthread_mutex_t *m)\n{\n\tEnterCriticalSection(m);\n\treturn 0;\n}\n\nstatic int\npthread_mutex_unlock(pthread_mutex_t *m)\n{\n\tLeaveCriticalSection(m);\n\treturn 0;\n}\n\nstatic int\npthread_mutex_trylock(pthread_mutex_t *m)\n{\n\treturn TryEnterCriticalSection(m) ? 0 : EBUSY;\n}\n\nstatic int\npthread_mutex_init(pthread_mutex_t *m, pthread_mutexattr_t *a)\n{\n\t(void)a;\n\tInitializeCriticalSection(m);\n\n\treturn 0;\n}\n\nstatic int\npthread_mutex_destroy(pthread_mutex_t *m)\n{\n\tDeleteCriticalSection(m);\n\treturn 0;\n}\n\n#define pthread_mutex_getprioceiling(M, P) ENOTSUP\n#define pthread_mutex_setprioceiling(M, P) ENOTSUP\n\nstatic int pthread_equal(pthread_t t1, pthread_t t2)\n{\n\treturn t1 == t2;\n}\n\nstatic void pthread_testcancel(void);\n\nstatic int\npthread_rwlock_init(pthread_rwlock_t *l, pthread_rwlockattr_t *a)\n{\n\t(void)a;\n\tInitializeSRWLock(l);\n\n\treturn 0;\n}\n\nstatic int\npthread_rwlock_destroy(pthread_rwlock_t *l)\n{\n\t(void)*l;\n\treturn 0;\n}\n\nstatic int\npthread_rwlock_rdlock(pthread_rwlock_t *l)\n{\n\tpthread_testcancel();\n\tAcquireSRWLockShared(l);\n\n\treturn 0;\n}\n\nstatic int\npthread_rwlock_wrlock(pthread_rwlock_t *l)\n{\n\tpthread_testcancel();\n\tAcquireSRWLockExclusive(l);\n\n\treturn 0;\n}\n\nstatic int\npthread_rwlock_unlock(pthread_rwlock_t *l)\n{\n\tvoid *state = *(void **)l;\n\n\tif (state == (void *)1) {\n\t\t/* Known to be an exclusive lock */\n\t\tReleaseSRWLockExclusive(l);\n\t} else {\n\t\t/* A shared unlock will work */\n\t\tReleaseSRWLockShared(l);\n\t}\n\n\treturn 0;\n}\n\nstatic void\npthread_tls_init(void)\n{\n\t_pthread_tls = TlsAlloc();\n\n\t/* Cannot continue if out of indexes */\n\tif (_pthread_tls == TLS_OUT_OF_INDEXES)\n\t\tabort();\n}\n\nstatic void\n_pthread_cleanup_dest(pthread_t t)\n{\n\tint i, j;\n\n\tfor (j = 0; j < PTHREAD_DESTRUCTOR_ITERATIONS; j++) {\n\t\tint flag = 0;\n\n\t\tfor (i = 0; i < t->keymax; i++) {\n\t\t\tvoid *val = t->keyval[i];\n\n\t\t\tif (val) {\n\t\t\t\tpthread_rwlock_rdlock(&_pthread_key_lock);\n\t\t\t\tif ((uintptr_t) _pthread_key_dest[i] > 1) {\n\t\t\t\t\t/* Call destructor */\n\t\t\t\t\tt->keyval[i] = NULL;\n\t\t\t\t\t_pthread_key_dest[i] (val);\n\t\t\t\t\tflag = 1;\n\t\t\t\t}\n\t\t\t\tpthread_rwlock_unlock(&_pthread_key_lock);\n\t\t\t}\n\t\t}\n\n\t\t/* Nothing to do? */\n\t\tif (!flag)\n\t\t\treturn;\n\t}\n}\n\nstatic\npthread_t pthread_self(void)\n{\n\tpthread_t t;\n\n\t_pthread_once_raw(&_pthread_tls_once, pthread_tls_init);\n\n\tt = TlsGetValue(_pthread_tls);\n\n\t/* Main thread? */\n\tif (!t) {\n\t\tt = malloc(sizeof(struct _pthread_v));\n\n\t\t/* If cannot initialize main thread, then the only thing we\n\t\t * can do is abort */\n\t\tif (!t)\n\t\t\tabort();\n\n\t\tt->ret_arg = NULL;\n\t\tt->func = NULL;\n\t\tt->clean = NULL;\n\t\tt->cancelled = 0;\n\t\tt->p_state = PTHREAD_DEFAULT_ATTR;\n\t\tt->keymax = 0;\n\t\tt->keyval = NULL;\n\t\tt->h = (uintptr_t) GetCurrentThread();\n\n\t\t/* Save for later */\n\t\tTlsSetValue(_pthread_tls, t);\n\n\t\tif (setjmp(t->jb)) {\n\t\t\t/* Make sure we free ourselves if we are detached */\n\t\t\tif (!t->h)\n\t\t\t\tfree(t);\n\n\t\t\t/* Time to die */\n\t\t\t_endthreadex(0);\n\t\t}\n\t}\n\n\treturn t;\n}\n\nstatic int\npthread_rwlock_tryrdlock(pthread_rwlock_t *l)\n{\n\t/* Get the current state of the lock */\n\tvoid *state = *(void **)l;\n\n\tif (!state) {\n\t\t/* Unlocked to locked */\n\t\tif (!_InterlockedCompareExchangePointer\n\t\t    ((void *)l, (void *)0x11, NULL))\n\t\t\treturn 0;\n\t\treturn EBUSY;\n\t}\n\n\t/* A single writer exists */\n\tif (state == (void *)1)\n\t\treturn EBUSY;\n\n\t/* Multiple writers exist? */\n\tif ((uintptr_t) state & 14)\n\t\treturn EBUSY;\n\n\tif (_InterlockedCompareExchangePointer\n\t    ((void *)l, (void *)((uintptr_t) state + 16), state) == state)\n\t\treturn 0;\n\n\treturn EBUSY;\n}\n\nstatic int\npthread_rwlock_trywrlock(pthread_rwlock_t *l)\n{\n\t/* Try to grab lock if it has no users */\n\tif (!_InterlockedCompareExchangePointer((void *)l, (void *)1, NULL))\n\t\treturn 0;\n\n\treturn EBUSY;\n}\n\nstatic unsigned long long\n_pthread_time_in_ms(void)\n{\n\tstruct __timeb64 tb;\n\n\t_ftime64(&tb);\n\n\treturn tb.time * 1000 + tb.millitm;\n}\n\nstatic unsigned long long\n_pthread_time_in_ms_from_timespec(const struct timespec *ts)\n{\n\tunsigned long long t = ts->tv_sec * 1000;\n\tt += ts->tv_nsec / 1000000;\n\n\treturn t;\n}\n\nstatic unsigned long long\n_pthread_rel_time_in_ms(const struct timespec *ts)\n{\n\tunsigned long long t1 = _pthread_time_in_ms_from_timespec(ts);\n\tunsigned long long t2 = _pthread_time_in_ms();\n\n\t/* Prevent underflow */\n\tif (t1 < t2)\n\t\treturn 0;\n\treturn t1 - t2;\n}\n\nstatic int\npthread_rwlock_timedrdlock(pthread_rwlock_t *l,\n\t\t\t\t      const struct timespec *ts)\n{\n\tunsigned long long ct = _pthread_time_in_ms();\n\tunsigned long long t = _pthread_time_in_ms_from_timespec(ts);\n\n\tpthread_testcancel();\n\n\t/* Use a busy-loop */\n\twhile (1) {\n\t\t/* Try to grab lock */\n\t\tif (!pthread_rwlock_tryrdlock(l))\n\t\t\treturn 0;\n\n\t\t/* Get current time */\n\t\tct = _pthread_time_in_ms();\n\n\t\t/* Have we waited long enough? */\n\t\tif (ct > t)\n\t\t\treturn ETIMEDOUT;\n\t}\n}\n\nstatic int\npthread_rwlock_timedwrlock(pthread_rwlock_t *l,\n\t\t\t   const struct timespec *ts)\n{\n\tunsigned long long ct = _pthread_time_in_ms();\n\tunsigned long long t = _pthread_time_in_ms_from_timespec(ts);\n\n\tpthread_testcancel();\n\n\t/* Use a busy-loop */\n\twhile (1) {\n\t\t/* Try to grab lock */\n\t\tif (!pthread_rwlock_trywrlock(l))\n\t\t\treturn 0;\n\n\t\t/* Get current time */\n\t\tct = _pthread_time_in_ms();\n\n\t\t/* Have we waited long enough? */\n\t\tif (ct > t)\n\t\t\treturn ETIMEDOUT;\n\t}\n}\n\nstatic int\npthread_get_concurrency(int *val)\n{\n\t*val = _pthread_concur;\n\treturn 0;\n}\n\nstatic int\npthread_set_concurrency(int val)\n{\n\t_pthread_concur = val;\n\treturn 0;\n}\n\n#define pthread_getschedparam(T, P, S) ENOTSUP\n#define pthread_setschedparam(T, P, S) ENOTSUP\n#define pthread_getcpuclockid(T, C) ENOTSUP\n\nstatic int\npthread_exit(void *res)\n{\n\tpthread_t t = pthread_self();\n\n\tt->ret_arg = res;\n\n\t_pthread_cleanup_dest(t);\n\n\tlongjmp(t->jb, 1);\n}\n\nstatic void\n_pthread_invoke_cancel(void)\n{\n\t_pthread_cleanup *pcup;\n\n\t_InterlockedDecrement(&_pthread_cancelling);\n\n\t/* Call cancel queue */\n\tfor (pcup = pthread_self()->clean; pcup; pcup = pcup->next) {\n\t\t/* suppress block warning */\n\t\tpcup->func(pcup->arg);\n\t}\n\n\tpthread_exit(PTHREAD_CANCELED);\n}\n\nstatic void\npthread_testcancel(void)\n{\n\tif (_pthread_cancelling) {\n\t\tpthread_t t = pthread_self();\n\n\t\tif (t->cancelled && (t->p_state & PTHREAD_CANCEL_ENABLE))\n\t\t\t_pthread_invoke_cancel();\n\t}\n}\n\nstatic int\npthread_cancel(pthread_t t)\n{\n\tif (t->p_state & PTHREAD_CANCEL_ASYNCHRONOUS) {\n\t\t/* Dangerous asynchronous cancelling */\n\t\tCONTEXT ctxt;\n\n\t\t/* Already done? */\n\t\tif (t->cancelled)\n\t\t\treturn ESRCH;\n\n\t\tctxt.ContextFlags = CONTEXT_CONTROL;\n\n\t\tSuspendThread((HANDLE) t->h);\n\t\tGetThreadContext((HANDLE) t->h, &ctxt);\n#ifdef _M_X64\n\t\tctxt.Rip = (uintptr_t) _pthread_invoke_cancel;\n#else\n\t\tctxt.Eip = (uintptr_t) _pthread_invoke_cancel;\n#endif\n\t\tSetThreadContext((HANDLE) t->h, &ctxt);\n\n\t\t/* Also try deferred Cancelling */\n\t\tt->cancelled = 1;\n\n\t\t/* Notify everyone to look */\n\t\t_InterlockedIncrement(&_pthread_cancelling);\n\n\t\tResumeThread((HANDLE) t->h);\n\t} else {\n\t\t/* Safe deferred Cancelling */\n\t\tt->cancelled = 1;\n\n\t\t/* Notify everyone to look */\n\t\t_InterlockedIncrement(&_pthread_cancelling);\n\t}\n\n\treturn 0;\n}\n\nstatic unsigned\n_pthread_get_state(pthread_attr_t *attr, unsigned flag)\n{\n\treturn attr->p_state & flag;\n}\n\nstatic int\n_pthread_set_state(pthread_attr_t *attr, unsigned flag,\n\t\t   unsigned val)\n{\n\tif (~flag & val)\n\t\treturn EINVAL;\n\tattr->p_state &= ~flag;\n\tattr->p_state |= val;\n\n\treturn 0;\n}\n\nstatic int\npthread_attr_init(pthread_attr_t *attr)\n{\n\tattr->p_state = PTHREAD_DEFAULT_ATTR;\n\tattr->stack = NULL;\n\tattr->s_size = 0;\n\treturn 0;\n}\n\nstatic int\npthread_attr_destroy(pthread_attr_t *attr)\n{\n\t/* No need to do anything */\n\treturn 0;\n}\n\nstatic int\npthread_attr_setdetachstate(pthread_attr_t *a, int flag)\n{\n\treturn _pthread_set_state(a, PTHREAD_CREATE_DETACHED, flag);\n}\n\nstatic int\npthread_attr_getdetachstate(pthread_attr_t *a, int *flag)\n{\n\t*flag = _pthread_get_state(a, PTHREAD_CREATE_DETACHED);\n\treturn 0;\n}\n\nstatic int\npthread_attr_setinheritsched(pthread_attr_t *a, int flag)\n{\n\treturn _pthread_set_state(a, PTHREAD_INHERIT_SCHED, flag);\n}\n\nstatic int\npthread_attr_getinheritsched(pthread_attr_t *a, int *flag)\n{\n\t*flag = _pthread_get_state(a, PTHREAD_INHERIT_SCHED);\n\treturn 0;\n}\n\nstatic int\npthread_attr_setscope(pthread_attr_t *a, int flag)\n{\n\treturn _pthread_set_state(a, PTHREAD_SCOPE_SYSTEM, flag);\n}\n\nstatic int\npthread_attr_getscope(pthread_attr_t *a, int *flag)\n{\n\t*flag = _pthread_get_state(a, PTHREAD_SCOPE_SYSTEM);\n\treturn 0;\n}\n\nstatic int\npthread_attr_getstackaddr(pthread_attr_t *attr, void **stack)\n{\n\t*stack = attr->stack;\n\treturn 0;\n}\n\nstatic int\npthread_attr_setstackaddr(pthread_attr_t *attr, void *stack)\n{\n\tattr->stack = stack;\n\treturn 0;\n}\n\nstatic int\npthread_attr_getstacksize(pthread_attr_t *attr, size_t *size)\n{\n\t*size = attr->s_size;\n\treturn 0;\n}\n\nstatic int\npthread_attr_setstacksize(pthread_attr_t *attr, size_t size)\n{\n\tattr->s_size = size;\n\treturn 0;\n}\n\n#define pthread_attr_getguardsize(A, S) ENOTSUP\n#define pthread_attr_setgaurdsize(A, S) ENOTSUP\n#define pthread_attr_getschedparam(A, S) ENOTSUP\n#define pthread_attr_setschedparam(A, S) ENOTSUP\n#define pthread_attr_getschedpolicy(A, S) ENOTSUP\n#define pthread_attr_setschedpolicy(A, S) ENOTSUP\n\nstatic int\npthread_setcancelstate(int state, int *oldstate)\n{\n\tpthread_t t = pthread_self();\n\n\tif ((state & PTHREAD_CANCEL_ENABLE) != state)\n\t\treturn EINVAL;\n\tif (oldstate)\n\t\t*oldstate = t->p_state & PTHREAD_CANCEL_ENABLE;\n\tt->p_state &= ~PTHREAD_CANCEL_ENABLE;\n\tt->p_state |= state;\n\n\treturn 0;\n}\n\nstatic int\npthread_setcanceltype(int type, int *oldtype)\n{\n\tpthread_t t = pthread_self();\n\n\tif ((type & PTHREAD_CANCEL_ASYNCHRONOUS) != type)\n\t\treturn EINVAL;\n\tif (oldtype)\n\t\t*oldtype = t->p_state & PTHREAD_CANCEL_ASYNCHRONOUS;\n\tt->p_state &= ~PTHREAD_CANCEL_ASYNCHRONOUS;\n\tt->p_state |= type;\n\n\treturn 0;\n}\n\nstatic unsigned int\npthread_create_wrapper(void *args)\n{\n\tstruct _pthread_v *tv = args;\n\tint i, j;\n\n\t_pthread_once_raw(&_pthread_tls_once, pthread_tls_init);\n\n\tTlsSetValue(_pthread_tls, tv);\n\n\tif (!setjmp(tv->jb)) {\n\t\t/* Call function and save return value */\n\t\ttv->ret_arg = tv->func(tv->ret_arg);\n\n\t\t/* Clean up destructors */\n\t\t_pthread_cleanup_dest(tv);\n\t}\n\n\t/* If we exit too early, then we can race with create */\n\twhile ((HANDLE) tv->h == (HANDLE) - 1) {\n\t\tYieldProcessor();\n\t\t_ReadWriteBarrier();\n\t}\n\n\t/* Make sure we free ourselves if we are detached */\n\tif (!tv->h)\n\t\tfree(tv);\n\n\treturn 0;\n}\n\nstatic int\npthread_create(pthread_t *th, pthread_attr_t *attr,\n\t       void *(*func) (void *), void *arg)\n{\n\tstruct _pthread_v *tv = malloc(sizeof(struct _pthread_v));\n\tunsigned ssize = 0;\n\n\tif (!tv)\n\t\treturn 1;\n\n\t*th = tv;\n\n\t/* Save data in pthread_t */\n\ttv->ret_arg = arg;\n\ttv->func = func;\n\ttv->clean = NULL;\n\ttv->cancelled = 0;\n\ttv->p_state = PTHREAD_DEFAULT_ATTR;\n\ttv->keymax = 0;\n\ttv->keyval = NULL;\n\ttv->h = (uintptr_t) -1;\n\n\tif (attr) {\n\t\ttv->p_state = attr->p_state;\n\t\tssize = attr->s_size;\n\t}\n\n\t/* Make sure tv->h has value of -1 */\n\t_ReadWriteBarrier();\n\n\ttv->h =\n\t    _beginthreadex(NULL, ssize, pthread_create_wrapper, tv, 0, NULL);\n\n\t/* Failed */\n\tif (!tv->h)\n\t\treturn 1;\n\n\tif (tv->p_state & PTHREAD_CREATE_DETACHED) {\n\t\tCloseHandle((HANDLE) tv->h);\n\t\t_ReadWriteBarrier();\n\t\ttv->h = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int\npthread_join(pthread_t t, void **res)\n{\n\tstruct _pthread_v *tv = t;\n\n\tpthread_testcancel();\n\n\tWaitForSingleObject((HANDLE) tv->h, INFINITE);\n\tCloseHandle((HANDLE) tv->h);\n\n\t/* Obtain return value */\n\tif (res)\n\t\t*res = tv->ret_arg;\n\n\tfree(tv);\n\n\treturn 0;\n}\n\nstatic int\npthread_detach(pthread_t t)\n{\n\tstruct _pthread_v *tv = t;\n\n\t/*\n\t * This can't race with thread exit because\n\t * our call would be undefined if called on a dead thread.\n\t */\n\n\tCloseHandle((HANDLE) tv->h);\n\t_ReadWriteBarrier();\n\ttv->h = 0;\n\n\treturn 0;\n}\n\nstatic int\npthread_mutexattr_init(pthread_mutexattr_t *a)\n{\n\t*a = 0;\n\treturn 0;\n}\n\nstatic int\npthread_mutexattr_destroy(pthread_mutexattr_t *a)\n{\n\t(void)a;\n\treturn 0;\n}\n\nstatic int\npthread_mutexattr_gettype(pthread_mutexattr_t *a, int *type)\n{\n\t*type = *a & 3;\n\n\treturn 0;\n}\n\nstatic int\npthread_mutexattr_settype(pthread_mutexattr_t *a, int type)\n{\n\tif ((unsigned)type > 3)\n\t\treturn EINVAL;\n\t*a &= ~3;\n\t*a |= type;\n\n\treturn 0;\n}\n\nstatic int\npthread_mutexattr_getpshared(pthread_mutexattr_t *a, int *type)\n{\n\t*type = *a & 4;\n\n\treturn 0;\n}\n\nstatic int\npthread_mutexattr_setpshared(pthread_mutexattr_t *a, int type)\n{\n\tif ((type & 4) != type)\n\t\treturn EINVAL;\n\n\t*a &= ~4;\n\t*a |= type;\n\n\treturn 0;\n}\n\nstatic int\npthread_mutexattr_getprotocol(pthread_mutexattr_t *a, int *type)\n{\n\t*type = *a & (8 + 16);\n\n\treturn 0;\n}\n\nstatic int\npthread_mutexattr_setprotocol(pthread_mutexattr_t *a, int type)\n{\n\tif ((type & (8 + 16)) != 8 + 16)\n\t\treturn EINVAL;\n\n\t*a &= ~(8 + 16);\n\t*a |= type;\n\n\treturn 0;\n}\n\nstatic int\npthread_mutexattr_getprioceiling(pthread_mutexattr_t *a, int *prio)\n{\n\t*prio = *a / PTHREAD_PRIO_MULT;\n\treturn 0;\n}\n\nstatic int\npthread_mutexattr_setprioceiling(pthread_mutexattr_t *a, int prio)\n{\n\t*a &= (PTHREAD_PRIO_MULT - 1);\n\t*a += prio * PTHREAD_PRIO_MULT;\n\n\treturn 0;\n}\n\nstatic int\npthread_mutex_timedlock(pthread_mutex_t *m, struct timespec *ts)\n{\n\tunsigned long long t, ct;\n\n\tstruct _pthread_crit_t {\n\t\tvoid *debug;\n\t\tLONG count;\n\t\tLONG r_count;\n\t\tHANDLE owner;\n\t\tHANDLE sem;\n\t\tULONG_PTR spin;\n\t};\n\n\t/* Try to lock it without waiting */\n\tif (!pthread_mutex_trylock(m))\n\t\treturn 0;\n\n\tct = _pthread_time_in_ms();\n\tt = _pthread_time_in_ms_from_timespec(ts);\n\n\twhile (1) {\n\t\t/* Have we waited long enough? */\n\t\tif (ct > t)\n\t\t\treturn ETIMEDOUT;\n\n\t\t/* Wait on semaphore within critical section */\n\t\tWaitForSingleObject(((struct _pthread_crit_t *)m)->sem, t - ct);\n\n\t\t/* Try to grab lock */\n\t\tif (!pthread_mutex_trylock(m))\n\t\t\treturn 0;\n\n\t\t/* Get current time */\n\t\tct = _pthread_time_in_ms();\n\t}\n}\n\n#define _PTHREAD_BARRIER_FLAG (1<<30)\n\nstatic int\npthread_barrier_destroy(pthread_barrier_t *b)\n{\n\tEnterCriticalSection(&b->m);\n\n\twhile (b->total > _PTHREAD_BARRIER_FLAG) {\n\t\t/* Wait until everyone exits the barrier */\n\t\tSleepConditionVariableCS(&b->cv, &b->m, INFINITE);\n\t}\n\n\tLeaveCriticalSection(&b->m);\n\n\tDeleteCriticalSection(&b->m);\n\n\treturn 0;\n}\n\nstatic int\npthread_barrier_init(pthread_barrier_t *b, void *attr, int count)\n{\n\t/* Ignore attr */\n\t(void)attr;\n\n\tb->count = count;\n\tb->total = 0;\n\n\tInitializeCriticalSection(&b->m);\n\tInitializeConditionVariable(&b->cv);\n\n\treturn 0;\n}\n\nstatic int\npthread_barrier_wait(pthread_barrier_t *b)\n{\n\tEnterCriticalSection(&b->m);\n\n\twhile (b->total > _PTHREAD_BARRIER_FLAG) {\n\t\t/* Wait until everyone exits the barrier */\n\t\tSleepConditionVariableCS(&b->cv, &b->m, INFINITE);\n\t}\n\n\t/* Are we the first to enter? */\n\tif (b->total == _PTHREAD_BARRIER_FLAG)\n\t\tb->total = 0;\n\n\tb->total++;\n\n\tif (b->total == b->count) {\n\t\tb->total += _PTHREAD_BARRIER_FLAG - 1;\n\t\tWakeAllConditionVariable(&b->cv);\n\n\t\tLeaveCriticalSection(&b->m);\n\n\t\treturn 1;\n\t} else {\n\t\twhile (b->total < _PTHREAD_BARRIER_FLAG) {\n\t\t\t/* Wait until enough threads enter the barrier */\n\t\t\tSleepConditionVariableCS(&b->cv, &b->m, INFINITE);\n\t\t}\n\n\t\tb->total--;\n\n\t\t/* Get entering threads to wake up */\n\t\tif (b->total == _PTHREAD_BARRIER_FLAG)\n\t\t\tWakeAllConditionVariable(&b->cv);\n\n\t\tLeaveCriticalSection(&b->m);\n\n\t\treturn 0;\n\t}\n}\n\nstatic int\npthread_barrierattr_init(void **attr)\n{\n\t*attr = NULL;\n\treturn 0;\n}\n\nstatic int\npthread_barrierattr_destroy(void **attr)\n{\n\t/* Ignore attr */\n\t(void)attr;\n\n\treturn 0;\n}\n\nstatic int\npthread_barrierattr_setpshared(void **attr, int s)\n{\n\t*attr = (void *)(uintptr_t) s;\n\treturn 0;\n}\n\nstatic int\npthread_barrierattr_getpshared(void **attr, int *s)\n{\n\t*s = (int)(size_t) *attr;\n\n\treturn 0;\n}\n\nstatic int\npthread_key_create(pthread_key_t *key, void (*dest) (void *))\n{\n\tint i;\n\tlong nmax;\n\tvoid (**d) (void *);\n\n\tif (!key)\n\t\treturn EINVAL;\n\n\tpthread_rwlock_wrlock(&_pthread_key_lock);\n\n\tfor (i = _pthread_key_sch; i < _pthread_key_max; i++) {\n\t\tif (!_pthread_key_dest[i]) {\n\t\t\t*key = i;\n\t\t\tif (dest)\n\t\t\t\t_pthread_key_dest[i] = dest;\n\t\t\telse\n\t\t\t\t_pthread_key_dest[i] = (void (*)(void *))1;\n\t\t\tpthread_rwlock_unlock(&_pthread_key_lock);\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tfor (i = 0; i < _pthread_key_sch; i++) {\n\t\tif (!_pthread_key_dest[i]) {\n\t\t\t*key = i;\n\t\t\tif (dest)\n\t\t\t\t_pthread_key_dest[i] = dest;\n\t\t\telse\n\t\t\t\t_pthread_key_dest[i] = (void (*)(void *))1;\n\t\t\tpthread_rwlock_unlock(&_pthread_key_lock);\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (!_pthread_key_max)\n\t\t_pthread_key_max = 1;\n\tif (_pthread_key_max == PTHREAD_KEYS_MAX) {\n\t\tpthread_rwlock_unlock(&_pthread_key_lock);\n\t\treturn ENOMEM;\n\t}\n\n\tnmax = _pthread_key_max * 2;\n\tif (nmax > PTHREAD_KEYS_MAX)\n\t\tnmax = PTHREAD_KEYS_MAX;\n\n\t/* No spare room anywhere */\n\td = realloc(_pthread_key_dest, nmax * sizeof(*d));\n\tif (!d) {\n\t\tpthread_rwlock_unlock(&_pthread_key_lock);\n\t\treturn ENOMEM;\n\t}\n\n\t/* Clear new region */\n\tmemset((void *)&d[_pthread_key_max], 0,\n\t       (nmax - _pthread_key_max) * sizeof(void *));\n\n\t/* Use new region */\n\t_pthread_key_dest = d;\n\t_pthread_key_sch = _pthread_key_max + 1;\n\t*key = _pthread_key_max;\n\t_pthread_key_max = nmax;\n\n\tif (dest)\n\t\t_pthread_key_dest[*key] = dest;\n\telse\n\t\t_pthread_key_dest[*key] = (void (*)(void *))1;\n\tpthread_rwlock_unlock(&_pthread_key_lock);\n\n\treturn 0;\n}\n\nstatic int\npthread_key_delete(pthread_key_t key)\n{\n\tif (key > _pthread_key_max)\n\t\treturn EINVAL;\n\tif (!_pthread_key_dest)\n\t\treturn EINVAL;\n\n\tpthread_rwlock_wrlock(&_pthread_key_lock);\n\t_pthread_key_dest[key] = NULL;\n\n\t/* Start next search from our location */\n\tif (_pthread_key_sch > key)\n\t\t_pthread_key_sch = key;\n\n\tpthread_rwlock_unlock(&_pthread_key_lock);\n\n\treturn 0;\n}\n\nstatic void *\npthread_getspecific(pthread_key_t key)\n{\n\tpthread_t t = pthread_self();\n\n\tif (key >= t->keymax)\n\t\treturn NULL;\n\n\treturn t->keyval[key];\n\n}\n\nstatic int\npthread_setspecific(pthread_key_t key, const void *value)\n{\n\tpthread_t t = pthread_self();\n\n\tif (key > t->keymax) {\n\t\tint keymax = (key + 1) * 2;\n\t\tvoid **kv = realloc(t->keyval, keymax * sizeof(void *));\n\n\t\tif (!kv)\n\t\t\treturn ENOMEM;\n\n\t\t/* Clear new region */\n\t\tmemset(&kv[t->keymax], 0,\n\t\t       (keymax - t->keymax) * sizeof(void *));\n\n\t\tt->keyval = kv;\n\t\tt->keymax = keymax;\n\t}\n\n\tt->keyval[key] = (void *)value;\n\n\treturn 0;\n}\n\nstatic int\npthread_spin_init(pthread_spinlock_t *l, int pshared)\n{\n\t(void)pshared;\n\n\t*l = 0;\n\treturn 0;\n}\n\nstatic int\npthread_spin_destroy(pthread_spinlock_t *l)\n{\n\t(void)l;\n\treturn 0;\n}\n\n/* No-fair spinlock due to lack of knowledge of thread number */\nstatic int\npthread_spin_lock(pthread_spinlock_t *l)\n{\n\twhile (_InterlockedExchange(l, EBUSY)) {\n\t\t/* Don't lock the bus whilst waiting */\n\t\twhile (*l) {\n\t\t\tYieldProcessor();\n\n\t\t\t/* Compiler barrier.  Prevent caching of *l */\n\t\t\t_ReadWriteBarrier();\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int\npthread_spin_trylock(pthread_spinlock_t *l)\n{\n\treturn _InterlockedExchange(l, EBUSY);\n}\n\nstatic int\npthread_spin_unlock(pthread_spinlock_t *l)\n{\n\t/* Compiler barrier.  The store below acts with release symmantics */\n\t_ReadWriteBarrier();\n\n\t*l = 0;\n\n\treturn 0;\n}\n\nstatic int\npthread_cond_init(pthread_cond_t *c, pthread_condattr_t *a)\n{\n\t(void)a;\n\n\tInitializeConditionVariable(c);\n\treturn 0;\n}\n\nstatic int\npthread_cond_signal(pthread_cond_t *c)\n{\n\tWakeConditionVariable(c);\n\treturn 0;\n}\n\nstatic int\npthread_cond_broadcast(pthread_cond_t *c)\n{\n\tWakeAllConditionVariable(c);\n\treturn 0;\n}\n\nstatic int\npthread_cond_wait(pthread_cond_t *c, pthread_mutex_t *m)\n{\n\tpthread_testcancel();\n\tSleepConditionVariableCS(c, m, INFINITE);\n\treturn 0;\n}\n\nstatic int\npthread_cond_destroy(pthread_cond_t *c)\n{\n\t(void)c;\n\treturn 0;\n}\n\nstatic int\npthread_cond_timedwait(pthread_cond_t *c, pthread_mutex_t *m,\n\t\t       struct timespec *t)\n{\n\tunsigned long long tm = _pthread_rel_time_in_ms(t);\n\n\tpthread_testcancel();\n\n\tif (!SleepConditionVariableCS(c, m, tm))\n\t\treturn ETIMEDOUT;\n\n\t/* We can have a spurious wakeup after the timeout */\n\tif (!_pthread_rel_time_in_ms(t))\n\t\treturn ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic int\npthread_condattr_destroy(pthread_condattr_t *a)\n{\n\t(void)a;\n\treturn 0;\n}\n\n#define pthread_condattr_getclock(A, C) ENOTSUP\n#define pthread_condattr_setclock(A, C) ENOTSUP\n\nstatic int\npthread_condattr_init(pthread_condattr_t *a)\n{\n\t*a = 0;\n\treturn 0;\n}\n\nstatic int\npthread_condattr_getpshared(pthread_condattr_t *a, int *s)\n{\n\t*s = *a;\n\treturn 0;\n}\n\nstatic int\npthread_condattr_setpshared(pthread_condattr_t *a, int s)\n{\n\t*a = s;\n\treturn 0;\n}\n\nstatic int\npthread_rwlockattr_destroy(pthread_rwlockattr_t *a)\n{\n\t(void)a;\n\treturn 0;\n}\n\nstatic int\npthread_rwlockattr_init(pthread_rwlockattr_t *a)\n{\n\t*a = 0;\n}\n\nstatic int\npthread_rwlockattr_getpshared(pthread_rwlockattr_t *a, int *s)\n{\n\t*s = *a;\n\treturn 0;\n}\n\nstatic int\npthread_rwlockattr_setpshared(pthread_rwlockattr_t *a, int s)\n{\n\t*a = s;\n\treturn 0;\n}\n\n/* No fork() in windows - so ignore this */\n#define pthread_atfork(F1, F2, F3) 0\n\n/* Windows has rudimentary signals support */\n#define pthread_kill(T, S) 0\n#define pthread_sigmask(H, S1, S2) 0\n\n/* Wrap cancellation points -- seems incompatible with decls in stdio.h */\n#define accept(...) (pthread_testcancel(), accept(__VA_ARGS__))\n#define aio_suspend(...) (pthread_testcancel(), aio_suspend(__VA_ARGS__))\n#define clock_nanosleep(...) \\\n\t(pthread_testcancel(), clock_nanosleep(__VA_ARGS__))\n#define close(...) (pthread_testcancel(), close(__VA_ARGS__))\n#define connect(...) (pthread_testcancel(), connect(__VA_ARGS__))\n#define creat(...) (pthread_testcancel(), creat(__VA_ARGS__))\n#define fcntl(...) (pthread_testcancel(), fcntl(__VA_ARGS__))\n#define fdatasync(...) (pthread_testcancel(), fdatasync(__VA_ARGS__))\n#define fsync(...) (pthread_testcancel(), fsync(__VA_ARGS__))\n#define getmsg(...) (pthread_testcancel(), getmsg(__VA_ARGS__))\n#define getpmsg(...) (pthread_testcancel(), getpmsg(__VA_ARGS__))\n#define lockf(...) (pthread_testcancel(), lockf(__VA_ARGS__))\n#define mg_receive(...) (pthread_testcancel(), mg_receive(__VA_ARGS__))\n#define mg_send(...) (pthread_testcancel(), mg_send(__VA_ARGS__))\n#define mg_timedreceive(...) \\\n\t(pthread_testcancel(), mg_timedreceive(__VA_ARGS__))\n#define mg_timessend(...) (pthread_testcancel(), mg_timedsend(__VA_ARGS__))\n#define msgrcv(...) (pthread_testcancel(), msgrecv(__VA_ARGS__))\n#define msgsnd(...) (pthread_testcancel(), msgsnd(__VA_ARGS__))\n#define msync(...) (pthread_testcancel(), msync(__VA_ARGS__))\n#define nanosleep(...) (pthread_testcancel(), nanosleep(__VA_ARGS__))\n#define open(...) (pthread_testcancel(), open(__VA_ARGS__))\n#define pause(...) (pthread_testcancel(), pause(__VA_ARGS__))\n#define poll(...) (pthread_testcancel(), poll(__VA_ARGS__))\n#define pread(...) (pthread_testcancel(), pread(__VA_ARGS__))\n#define pselect(...) (pthread_testcancel(), pselect(__VA_ARGS__))\n#define putmsg(...) (pthread_testcancel(), putmsg(__VA_ARGS__))\n#define putpmsg(...) (pthread_testcancel(), putpmsg(__VA_ARGS__))\n#define pwrite(...) (pthread_testcancel(), pwrite(__VA_ARGS__))\n#define read(...) (pthread_testcancel(), read(__VA_ARGS__))\n#define readv(...) (pthread_testcancel(), readv(__VA_ARGS__))\n#define recv(...) (pthread_testcancel(), recv(__VA_ARGS__))\n#define recvfrom(...) (pthread_testcancel(), recvfrom(__VA_ARGS__))\n#define recvmsg(...) (pthread_testcancel(), recvmsg(__VA_ARGS__))\n#define select(...) (pthread_testcancel(), select(__VA_ARGS__))\n#define sem_timedwait(...) (pthread_testcancel(), sem_timedwait(__VA_ARGS__))\n#define sem_wait(...) (pthread_testcancel(), sem_wait(__VA_ARGS__))\n#define send(...) (pthread_testcancel(), send(__VA_ARGS__))\n#define sendmsg(...) (pthread_testcancel(), sendmsg(__VA_ARGS__))\n#define sendto(...) (pthread_testcancel(), sendto(__VA_ARGS__))\n#define sigpause(...) (pthread_testcancel(), sigpause(__VA_ARGS__))\n#define sigsuspend(...) (pthread_testcancel(), sigsuspend(__VA_ARGS__))\n#define sigwait(...) (pthread_testcancel(), sigwait(__VA_ARGS__))\n#define sigwaitinfo(...) (pthread_testcancel(), sigwaitinfo(__VA_ARGS__))\n#define sleep(...) (pthread_testcancel(), sleep(__VA_ARGS__))\n/* #define Sleep(...) (pthread_testcancel(), Sleep(__VA_ARGS__)) */\n#define system(...) (pthread_testcancel(), system(__VA_ARGS__))\n\n#define access(...) (pthread_testcancel(), access(__VA_ARGS__))\n#define asctime(...) (pthread_testcancel(), asctime(__VA_ARGS__))\n#define asctime_r(...) (pthread_testcancel(), asctime_r(__VA_ARGS__))\n#define catclose(...) (pthread_testcancel(), catclose(__VA_ARGS__))\n#define catgets(...) (pthread_testcancel(), catgets(__VA_ARGS__))\n#define catopen(...) (pthread_testcancel(), catopen(__VA_ARGS__))\n#define closedir(...) (pthread_testcancel(), closedir(__VA_ARGS__))\n#define closelog(...) (pthread_testcancel(), closelog(__VA_ARGS__))\n#define ctermid(...) (pthread_testcancel(), ctermid(__VA_ARGS__))\n#define ctime(...) (pthread_testcancel(), ctime(__VA_ARGS__))\n#define ctime_r(...) (pthread_testcancel(), ctime_r(__VA_ARGS__))\n#define dbm_close(...) (pthread_testcancel(), dbm_close(__VA_ARGS__))\n#define dbm_delete(...) (pthread_testcancel(), dbm_delete(__VA_ARGS__))\n#define dbm_fetch(...) (pthread_testcancel(), dbm_fetch(__VA_ARGS__))\n#define dbm_nextkey(...) (pthread_testcancel(), dbm_nextkey(__VA_ARGS__))\n#define dbm_open(...) (pthread_testcancel(), dbm_open(__VA_ARGS__))\n#define dbm_store(...) (pthread_testcancel(), dbm_store(__VA_ARGS__))\n#define dlclose(...) (pthread_testcancel(), dlclose(__VA_ARGS__))\n#define dlopen(...) (pthread_testcancel(), dlopen(__VA_ARGS__))\n#define endgrent(...) (pthread_testcancel(), endgrent(__VA_ARGS__))\n#define endhostent(...) (pthread_testcancel(), endhostent(__VA_ARGS__))\n#define endnetent(...) (pthread_testcancel(), endnetent(__VA_ARGS__))\n#define endprotoent(...) (pthread_testcancel(), endprotoend(__VA_ARGS__))\n#define endpwent(...) (pthread_testcancel(), endpwent(__VA_ARGS__))\n#define endservent(...) (pthread_testcancel(), endservent(__VA_ARGS__))\n#define endutxent(...) (pthread_testcancel(), endutxent(__VA_ARGS__))\n#define fclose(...) (pthread_testcancel(), fclose(__VA_ARGS__))\n#define fflush(...) (pthread_testcancel(), fflush(__VA_ARGS__))\n#define fgetc(...) (pthread_testcancel(), fgetc(__VA_ARGS__))\n#define fgetpos(...) (pthread_testcancel(), fgetpos(__VA_ARGS__))\n#define fgets(...) (pthread_testcancel(), fgets(__VA_ARGS__))\n#define fgetwc(...) (pthread_testcancel(), fgetwc(__VA_ARGS__))\n#define fgetws(...) (pthread_testcancel(), fgetws(__VA_ARGS__))\n#define fmtmsg(...) (pthread_testcancel(), fmtmsg(__VA_ARGS__))\n#define fopen(...) (pthread_testcancel(), fopen(__VA_ARGS__))\n#define fpathconf(...) (pthread_testcancel(), fpathconf(__VA_ARGS__))\n#define fprintf(...) (pthread_testcancel(), fprintf(__VA_ARGS__))\n#define fputc(...) (pthread_testcancel(), fputc(__VA_ARGS__))\n#define fputs(...) (pthread_testcancel(), fputs(__VA_ARGS__))\n#define fputwc(...) (pthread_testcancel(), fputwc(__VA_ARGS__))\n#define fputws(...) (pthread_testcancel(), fputws(__VA_ARGS__))\n#define fread(...) (pthread_testcancel(), fread(__VA_ARGS__))\n#define freopen(...) (pthread_testcancel(), freopen(__VA_ARGS__))\n#define fscanf(...) (pthread_testcancel(), fscanf(__VA_ARGS__))\n#define fseek(...) (pthread_testcancel(), fseek(__VA_ARGS__))\n#define fseeko(...) (pthread_testcancel(), fseeko(__VA_ARGS__))\n#define fsetpos(...) (pthread_testcancel(), fsetpos(__VA_ARGS__))\n#define fstat(...) (pthread_testcancel(), fstat(__VA_ARGS__))\n#define ftell(...) (pthread_testcancel(), ftell(__VA_ARGS__))\n#define ftello(...) (pthread_testcancel(), ftello(__VA_ARGS__))\n#define ftw(...) (pthread_testcancel(), ftw(__VA_ARGS__))\n#define fwprintf(...) (pthread_testcancel(), fwprintf(__VA_ARGS__))\n#define fwrite(...) (pthread_testcancel(), fwrite(__VA_ARGS__))\n#define fwscanf(...) (pthread_testcancel(), fwscanf(__VA_ARGS__))\n#define getaddrinfo(...) (pthread_testcancel(), getaddrinfo(__VA_ARGS__))\n#define getc(...) (pthread_testcancel(), getc(__VA_ARGS__))\n#define getc_unlocked(...) (pthread_testcancel(), getc_unlocked(__VA_ARGS__))\n#define getchar(...) (pthread_testcancel(), getchar(__VA_ARGS__))\n#define getchar_unlocked(...) \\\n\t(pthread_testcancel(), getchar_unlocked(__VA_ARGS__))\n#define getcwd(...) (pthread_testcancel(), getcwd(__VA_ARGS__))\n#define getdate(...) (pthread_testcancel(), getdate(__VA_ARGS__))\n#define getgrent(...) (pthread_testcancel(), getgrent(__VA_ARGS__))\n#define getgrgid(...) (pthread_testcancel(), getgrgid(__VA_ARGS__))\n#define getgrgid_r(...) (pthread_testcancel(), getgrgid_r(__VA_ARGS__))\n#define gergrnam(...) (pthread_testcancel(), getgrnam(__VA_ARGS__))\n#define getgrnam_r(...) (pthread_testcancel(), getgrnam_r(__VA_ARGS__))\n#define gethostbyaddr(...) (pthread_testcancel(), gethostbyaddr(__VA_ARGS__))\n#define gethostbyname(...) (pthread_testcancel(), gethostbyname(__VA_ARGS__))\n#define gethostent(...) (pthread_testcancel(), gethostent(__VA_ARGS__))\n#define gethostid(...) (pthread_testcancel(), gethostid(__VA_ARGS__))\n#define gethostname(...) (pthread_testcancel(), gethostname(__VA_ARGS__))\n#define getlogin(...) (pthread_testcancel(), getlogin(__VA_ARGS__))\n#define getlogin_r(...) (pthread_testcancel(), getlogin_r(__VA_ARGS__))\n#define getnameinfo(...) (pthread_testcancel(), getnameinfo(__VA_ARGS__))\n#define getnetbyaddr(...) (pthread_testcancel(), getnetbyaddr(__VA_ARGS__))\n#define getnetbyname(...) (pthread_testcancel(), getnetbyname(__VA_ARGS__))\n#define getnetent(...) (pthread_testcancel(), getnetent(__VA_ARGS__))\n#define getopt(...) (pthread_testcancel(), getopt(__VA_ARGS__))\n#define getprotobyname(...) (pthread_testcancel(), getprotobyname(__VA_ARGS__))\n#define getprotobynumber(...) \\\n\t(pthread_testcancel(), getprotobynumber(__VA_ARGS__))\n#define getprotoent(...) (pthread_testcancel(), getprotoent(__VA_ARGS__))\n#define getpwent(...) (pthread_testcancel(), getpwent(__VA_ARGS__))\n#define getpwnam(...) (pthread_testcancel(), getpwnam(__VA_ARGS__))\n#define getpwnam_r(...) (pthread_testcancel(), getpwnam_r(__VA_ARGS__))\n#define getpwuid(...) (pthread_testcancel(), getpwuid(__VA_ARGS__))\n#define getpwuid_r(...) (pthread_testcancel(), getpwuid_r(__VA_ARGS__))\n#define gets(...) (pthread_testcancel(), gets(__VA_ARGS__))\n#define getservbyname(...) (pthread_testcancel(), getservbyname(__VA_ARGS__))\n#define getservbyport(...) (pthread_testcancel(), getservbyport(__VA_ARGS__))\n#define getservent(...) (pthread_testcancel(), getservent(__VA_ARGS__))\n#define getutxent(...) (pthread_testcancel(), getutxent(__VA_ARGS__))\n#define getutxid(...) (pthread_testcancel(), getutxid(__VA_ARGS__))\n#define getutxline(...) (pthread_testcancel(), getutxline(__VA_ARGS__))\n#undef getwc\n#define getwc(...) (pthread_testcancel(), getwc(__VA_ARGS__))\n#undef getwchar\n#define getwchar(...) (pthread_testcancel(), getwchar(__VA_ARGS__))\n#define getwd(...) (pthread_testcancel(), getwd(__VA_ARGS__))\n#define glob(...) (pthread_testcancel(), glob(__VA_ARGS__))\n#define iconv_close(...) (pthread_testcancel(), iconv_close(__VA_ARGS__))\n#define iconv_open(...) (pthread_testcancel(), iconv_open(__VA_ARGS__))\n#define ioctl(...) (pthread_testcancel(), ioctl(__VA_ARGS__))\n#define link(...) (pthread_testcancel(), link(__VA_ARGS__))\n#define localtime(...) (pthread_testcancel(), localtime(__VA_ARGS__))\n#define localtime_r(...) (pthread_testcancel(), localtime_r(__VA_ARGS__))\n#define lseek(...) (pthread_testcancel(), lseek(__VA_ARGS__))\n#define lstat(...) (pthread_testcancel(), lstat(__VA_ARGS__))\n#define mkstemp(...) (pthread_testcancel(), mkstemp(__VA_ARGS__))\n#define nftw(...) (pthread_testcancel(), nftw(__VA_ARGS__))\n#define opendir(...) (pthread_testcancel(), opendir(__VA_ARGS__))\n#define openlog(...) (pthread_testcancel(), openlog(__VA_ARGS__))\n#define pathconf(...) (pthread_testcancel(), pathconf(__VA_ARGS__))\n#define pclose(...) (pthread_testcancel(), pclose(__VA_ARGS__))\n#define perror(...) (pthread_testcancel(), perror(__VA_ARGS__))\n#define popen(...) (pthread_testcancel(), popen(__VA_ARGS__))\n#define posix_fadvise(...) (pthread_testcancel(), posix_fadvise(__VA_ARGS__))\n#define posix_fallocate(...) \\\n\t(pthread_testcancel(), posix_fallocate(__VA_ARGS__))\n#define posix_madvise(...) (pthread_testcancel(), posix_madvise(__VA_ARGS__))\n#define posix_openpt(...) (pthread_testcancel(), posix_openpt(__VA_ARGS__))\n#define posix_spawn(...) (pthread_testcancel(), posix_spawn(__VA_ARGS__))\n#define posix_spawnp(...) (pthread_testcancel(), posix_spawnp(__VA_ARGS__))\n#define posix_trace_clear(...) \\\n\t(pthread_testcancel(), posix_trace_clear(__VA_ARGS__))\n#define posix_trace_close(...) \\\n\t(pthread_testcancel(), posix_trace_close(__VA_ARGS__))\n#define posix_trace_create(...) \\\n\t(pthread_testcancel(), posix_trace_create(__VA_ARGS__))\n#define posix_trace_create_withlog(...) \\\n\t(pthread_testcancel(), posix_trace_create_withlog(__VA_ARGS__))\n#define posix_trace_eventtypelist_getne(...) \\\n\t(pthread_testcancel(), posix_trace_eventtypelist_getne(__VA_ARGS__))\n#define posix_trace_eventtypelist_rewin(...) \\\n\t(pthread_testcancel(), posix_trace_eventtypelist_rewin(__VA_ARGS__))\n#define posix_trace_flush(...) \\\n\t(pthread_testcancel(), posix_trace_flush(__VA_ARGS__))\n#define posix_trace_get_attr(...) \\\n\t(pthread_testcancel(), posix_trace_get_attr(__VA_ARGS__))\n#define posix_trace_get_filter(...) \\\n\t(pthread_testcancel(), posix_trace_get_filter(__VA_ARGS__))\n#define posix_trace_get_status(...) \\\n\t(pthread_testcancel(), posix_trace_get_status(__VA_ARGS__))\n#define posix_trace_getnext_event(...) \\\n\t(pthread_testcancel(), posix_trace_getnext_event(__VA_ARGS__))\n#define posix_trace_open(...) \\\n\t(pthread_testcancel(), posix_trace_open(__VA_ARGS__))\n#define posix_trace_rewind(...) \\\n\t(pthread_testcancel(), posix_trace_rewind(__VA_ARGS__))\n#define posix_trace_setfilter(...) \\\n\t(pthread_testcancel(), posix_trace_setfilter(__VA_ARGS__))\n#define posix_trace_shutdown(...) \\\n\t(pthread_testcancel(), posix_trace_shutdown(__VA_ARGS__))\n#define posix_trace_timedgetnext_event(...) \\\n\t(pthread_testcancel(), posix_trace_timedgetnext_event(__VA_ARGS__))\n#define posix_typed_mem_open(...) \\\n\t(pthread_testcancel(), posix_typed_mem_open(__VA_ARGS__))\n#define printf(...) (pthread_testcancel(), printf(__VA_ARGS__))\n#define putc(...) (pthread_testcancel(), putc(__VA_ARGS__))\n#define putc_unlocked(...) (pthread_testcancel(), putc_unlocked(__VA_ARGS__))\n#define putchar(...) (pthread_testcancel(), putchar(__VA_ARGS__))\n#define putchar_unlocked(...) \\\n\t(pthread_testcancel(), putchar_unlocked(__VA_ARGS__))\n#define puts(...) (pthread_testcancel(), puts(__VA_ARGS__))\n#define pututxline(...) (pthread_testcancel(), pututxline(__VA_ARGS__))\n#undef putwc\n#define putwc(...) (pthread_testcancel(), putwc(__VA_ARGS__))\n#undef putwchar\n#define putwchar(...) (pthread_testcancel(), putwchar(__VA_ARGS__))\n#define readdir(...) (pthread_testcancel(), readdir(__VA_ARSG__))\n#define readdir_r(...) (pthread_testcancel(), readdir_r(__VA_ARGS__))\n#define remove(...) (pthread_testcancel(), remove(__VA_ARGS__))\n#define rename(...) (pthread_testcancel(), rename(__VA_ARGS__))\n#define rewind(...) (pthread_testcancel(), rewind(__VA_ARGS__))\n#define rewinddir(...) (pthread_testcancel(), rewinddir(__VA_ARGS__))\n#define scanf(...) (pthread_testcancel(), scanf(__VA_ARGS__))\n#define seekdir(...) (pthread_testcancel(), seekdir(__VA_ARGS__))\n#define semop(...) (pthread_testcancel(), semop(__VA_ARGS__))\n#define setgrent(...) (pthread_testcancel(), setgrent(__VA_ARGS__))\n#define sethostent(...) (pthread_testcancel(), sethostemt(__VA_ARGS__))\n#define setnetent(...) (pthread_testcancel(), setnetent(__VA_ARGS__))\n#define setprotoent(...) (pthread_testcancel(), setprotoent(__VA_ARGS__))\n#define setpwent(...) (pthread_testcancel(), setpwent(__VA_ARGS__))\n#define setservent(...) (pthread_testcancel(), setservent(__VA_ARGS__))\n#define setutxent(...) (pthread_testcancel(), setutxent(__VA_ARGS__))\n#define stat(...) (pthread_testcancel(), stat(__VA_ARGS__))\n#define strerror(...) (pthread_testcancel(), strerror(__VA_ARGS__))\n#define strerror_r(...) (pthread_testcancel(), strerror_r(__VA_ARGS__))\n#define strftime(...) (pthread_testcancel(), strftime(__VA_ARGS__))\n#define symlink(...) (pthread_testcancel(), symlink(__VA_ARGS__))\n#define sync(...) (pthread_testcancel(), sync(__VA_ARGS__))\n#define syslog(...) (pthread_testcancel(), syslog(__VA_ARGS__))\n#define tmpfile(...) (pthread_testcancel(), tmpfile(__VA_ARGS__))\n#define tmpnam(...) (pthread_testcancel(), tmpnam(__VA_ARGS__))\n#define ttyname(...) (pthread_testcancel(), ttyname(__VA_ARGS__))\n#define ttyname_r(...) (pthread_testcancel(), ttyname_r(__VA_ARGS__))\n#define tzset(...) (pthread_testcancel(), tzset(__VA_ARGS__))\n#define ungetc(...) (pthread_testcancel(), ungetc(__VA_ARGS__))\n#define ungetwc(...) (pthread_testcancel(), ungetwc(__VA_ARGS__))\n#define unlink(...) (pthread_testcancel(), unlink(__VA_ARGS__))\n#define vfprintf(...) (pthread_testcancel(), vfprintf(__VA_ARGS__))\n#define vfwprintf(...) (pthread_testcancel(), vfwprintf(__VA_ARGS__))\n#define vprintf(...) (pthread_testcancel(), vprintf(__VA_ARGS__))\n#define vwprintf(...) (pthread_testcancel(), vwprintf(__VA_ARGS__))\n#define wcsftime(...) (pthread_testcancel(), wcsftime(__VA_ARGS__))\n#define wordexp(...) (pthread_testcancel(), wordexp(__VA_ARGS__))\n#define wprintf(...) (pthread_testcancel(), wprintf(__VA_ARGS__))\n#define wscanf(...) (pthread_testcancel(), wscanf(__VA_ARGS__))\n\n#endif\t\t\t\t/* WIN_PTHREADS */\n",
        "/tmp/vanessa/spack-stage/spack-stage-ntirpc-1.7.3-465qfzcbzxrewsdxa3szlxyog3mspjck/spack-src/src/lttng/main.c": "/*\n * vim:noexpandtab:shiftwidth=8:tabstop=8:\n *\n * Copyright 2018 Red Hat, Inc. and/or its affiliates.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n * - Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n * - Neither the name of Sun Microsystems, Inc. nor the names of its\n *   contributors may be used to endorse or promote products derived\n *   from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"config.h\"\n\n/**\n * @brief LTTng trace enabling magic\n *\n * Every trace include file must be added here regardless whether it\n * is actually used in this source file.  The file must also be\n * included ONLY ONCE.  Failure to do so will create interesting\n * build time failure messages.  The key bit is the definitions of\n * TRACEPOINT_DEFINE and TRACEPOINT_PROBE_DYNAMIC_LINKAGE that are here\n * to trigger the global definitions as a shared object with the right\n * (weak) symbols to make the module loading optional.\n *\n * If and when this file gets some tracepoints of its own, the include\n * here is necessary and sufficient.\n */\n\n#ifdef USE_LTTNG_NTIRPC\n#define TRACEPOINT_DEFINE\n#define TRACEPOINT_PROBE_DYNAMIC_LINKAGE\n\n#include \"lttng/rpcping.h\"\n#include \"lttng/xprt.h\"\n\n/* This is a hack to make older versions of LTTng link */\nstruct lttng_ust_tracepoint_dlopen tracepoint_dlopen\n\t__attribute__((weak));\n\n#endif /* USE_LTTNG_NTIRPC */\n"
    },
    "skipped": [],
    "total_files": 198
}