{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-gccxml-latest-w5xt6m3ulksz5ujtgruzzb6jkeam5q55/spack-src/GCC/gcc/sys-protos.h": "extern int                    TLappend(/* ??? */);\nextern int                    TLassign(/* ??? */);\nextern int                    TLclose(/* ??? */);\nextern int                    TLdelete(/* ??? */);\nextern int                    TLfreeentry(/* ??? */);\nextern ENTRY                  TLgetentry(/* ??? */);\nextern unsigned char *        TLgetfield(/* ??? */);\nextern int                    TLopen(/* ??? */);\nextern int                    TLread(/* ??? */);\nextern int                    TLsearch1(/* ??? */);\nextern int                    TLsubst(/* ??? */);\nextern int                    TLsync(/* ??? */);\nextern int                    TLwrite(/* ??? */);\nextern int                    __acancel(int, const long int *, int);\nextern int                    __aread(int, int, char *, uint, ecb_t *);\nextern void                   __assert(const char *, const char *, int);\nextern int                    __asyncio(int, aioop_t *, int);\nextern int                    __awrite(int, int, char *, uint, ecb_t *);\nextern int                    __evcntl(evver_t, evcntlcmds_t, long int, long int);\nextern int                    __evexit(evver_t, idtype_t, id_t, const ecb_t *);\nextern int                    __evexitset(evver_t, const procset_t *, hostid_t, const ecb_t *);\nextern int                    __evpoll(evver_t, evpollcmds_t, event_t *, int, const hrtime_t *);\nextern int                    __evpollmore(evver_t, event_t *, int);\nextern int                    __evpost(evver_t, event_t *, int, int);\nextern int                    __evqcntl(evver_t, int, evqcntlcmds_t, long int);\nextern int                    __evsig(evver_t, const sigset_t *, const ecb_t *, evsiginfo_t *, int);\nextern int                    __evtrap(evver_t, evpollcmds_t, event_t *, int, long int, void (*) (event_t *, int, long int, evcontext_t *), const evta_t *);\nextern int                    __evtrapcancel(evver_t, long int *, int);\nextern int                    __filbuf(FILE *);\nextern int                    __flsbuf(int, FILE *);\nextern major_t                __major(int, dev_t);\nextern dev_t                  __makedev(int, major_t, minor_t);\nextern minor_t                __minor(int, dev_t);\nextern long int               __priocntl(/* ??? */);\nextern long int               __priocntlset(/* ??? */);\nextern void                   _exit(int);\nextern int                    _filbuf(FILE *);\nextern int                    _flsbuf(unsigned int, FILE *);\nextern int                    _fxstat(int, int, struct stat *);\nextern u_long                 _getlong(/* ??? */);\nextern u_short                _getshort(/* ??? */);\nextern int                    _getsyx(int *, int *);\nextern int                    _longjmp(jmp_buf, int);\nextern int                    _lxstat(int, const char *, struct stat *);\nextern int                    _meta(int);\nextern struct nd_hostservlist _netdir_getbyaddr(struct netconfig *, struct netbuf *);\nextern struct nd_addrlist *   _netdir_getbyname(struct netconfig *, struct nd_hostserv *);\nextern int                    _overlay(WINDOW *, WINDOW *, int);\nextern int                    _ring(int);\nextern int                    _rpc_dtbsize(/* ??? */);\nextern int                    _rpc_endconf(/* ??? */);\nextern u_int                  _rpc_get_a_size(/* ??? */);\nextern u_int                  _rpc_get_t_size(/* ??? */);\nextern struct netconfig *     _rpc_getconf(/* ??? */);\nextern struct netconfig *     _rpc_getconfip(/* ??? */);\nextern char *                 _rpc_gethostname(/* ??? */);\nextern int                    _rpc_setconf(/* ??? */);\nextern void                   _s_aligned_copy(/* ??? */);\nextern struct _si_user *      _s_checkfd(/* ??? */);\nextern void                   _s_close(/* ??? */);\nextern int                    _s_do_ioctl(/* ??? */);\nextern int                    _s_getfamily(/* ??? */);\nextern int                    _s_getudata(/* ??? */);\nextern int                    _s_is_ok(/* ??? */);\nextern struct netconfig *     _s_match(/* ??? */);\nextern int                    _s_max(/* ??? */);\nextern int                    _s_min(/* ??? */);\nextern struct _si_user *      _s_open(/* ??? */);\nextern int                    _s_soreceive(/* ??? */);\nextern int                    _s_sosend(/* ??? */);\nextern int                    _s_uxpathlen(/* ??? */);\nextern int                    _setecho(int);\nextern int                    _setjmp(jmp_buf);\nextern int                    _setnonl(int);\nextern void                   _setqiflush(int);\nextern char *                 _taddr2uaddr(struct netconfig *, struct netbuf *);\nextern int                    _tolower(int);\nextern int                    _toupper(int);\nextern struct netbuf *        _uaddr2taddr(struct netconfig *, char *);\nextern bool                   _xdr_yprequest(/* ??? */);\nextern bool                   _xdr_ypresponse(/* ??? */);\nextern int                    _xftw(int, const char *, int (*) (const char *, const struct stat *, int), int);\nextern int                    _xmknod(int, const char *, mode_t, dev_t);\nextern int                    _xstat(int, const char *, struct stat *);\nextern int                    _yp_dobind(/* ??? */);\nextern long int               a64l(const char *);\nextern char *                 aatos(char *, struct address *, int);\nextern void                   abort(void);\nextern int                    abs(int);\nextern int                    access(const char *, int);\nextern int                    acct(const char *);\nextern double                 acos(double);\nextern float                  acosf(float);\nextern double                 acosh(double);\nextern int                    addexportent(FILE *, char *, char *);\nextern int                    addseverity(int, const char *);\nextern int                    adjtime(struct timeval *, struct timeval *);\nextern int                    advance(const char *, const char *);\nextern unsigned int           alarm(unsigned int);\nextern void *                 alloca(size_t);\nextern int                    and(void);\nextern int                    ascftime(char *, const char *, const struct tm *);\nextern char *                 asctime(const struct tm *);\nextern double                 asin(double);\nextern float                  asinf(float);\nextern double                 asinh(double);\nextern struct address *       astoa(char *, struct address *);\nextern double                 atan(double);\nextern double                 atan2(double, double);\nextern float                  atan2f(float, float);\nextern float                  atanf(float);\nextern double                 atanh(double);\nextern int                    atexit(void (*) (void));\nextern double                 atof(const char *);\nextern int                    atoi(const char *);\nextern long int               atol(const char *);\nextern char *                 atos(char *, struct netbuf *, int);\nextern void                   auth_destroy(AUTH *);\nextern AUTH *                 authdes_create(/* ??? */);\nextern void                   authdes_getcred(struct authdes_cred *, short *, short *, short *, int *);\nextern AUTH *                 authdes_seccreate(/* ??? */);\nextern AUTH *                 authnone_create(void);\nextern AUTH *                 authsys_create(char *, int, int, int, int *);\nextern AUTH *                 authsys_create_default(void);\nextern AUTH *                 authunix_create(char *, int, int, int, int *);\nextern AUTH *                 authunix_create_default(void);\nextern char *                 basename(char *);\nextern int                    baudrate(void);\nextern int                    bcmp(const void *, const void *, size_t);\nextern void                   bcopy(const void *, void *, size_t);\nextern int                    beep(void);\nextern void (*                berk_signal(int, void (*) (int, ...))) (int, ...);\nextern char *                 bgets(char *, size_t, FILE *, char *);\nextern int                    bottom_panel(PANEL *);\nextern int                    box32(WINDOW *, chtype, chtype);\nextern int                    brk(void *);\nextern void *                 bsearch(const void *, const void *, size_t, size_t, int (*) (const void *, const void *));\nextern size_t                 bufsplit(char *, size_t, char *);\nextern void                   bzero(void *, size_t);\nextern long int               calchash(/* ??? */);\nextern void *                 calloc(size_t, size_t);\nextern void                   callrpc(char *, unsigned long, unsigned long, unsigned long, xdrproc_t, char *, xdrproc_t, char *);\nextern bool                   can_change_color(void);\nextern int                    catclose(nl_catd);\nextern char *                 catgets(nl_catd, int, int, char *);\nextern nl_catd                catopen(const char *, int);\nextern int                    cbreak(void);\nextern double                 cbrt(double);\nextern double                 ceil(double);\nextern float                  ceilf(float);\nextern speed_t                cfgetispeed(const struct termios *);\nextern speed_t                cfgetospeed(const struct termios *);\nextern void                   cfree(void *);\nextern int                    cfsetispeed(struct termios *, speed_t);\nextern int                    cfsetospeed(struct termios *, speed_t);\nextern int                    cftime(char *, char *, const time_t *);\nextern int                    chdir(const char *);\nextern int                    chmod(const char *, mode_t);\nextern int                    chown(const char *, uid_t, gid_t);\nextern int                    chroot(const char *);\nextern void                   clean_GEN_rd(/* ??? */);\nextern void                   cleanup(/* ??? */);\nextern void                   clearerr(FILE *);\nextern int                    clearok(WINDOW *, int);\nextern enum clnt_stat         clnt_broadcast(unsigned long, unsigned long, unsigned long, xdrproc_t, char *, xdrproc_t, char *, resultproc_t);\nextern enum clnt_stat         clnt_call(CLIENT *, unsigned long, xdrproc_t, char *, xdrproc_t, char *, struct timeval);\nextern bool_t                 clnt_control(CLIENT *, int, char *);\nextern CLIENT *               clnt_create(char *, unsigned long, unsigned long, char *);\nextern void                   clnt_destroy(CLIENT *);\nextern int                    clnt_freeres(CLIENT *, xdrproc_t, char *);\nextern void                   clnt_geterr(CLIENT *, struct rpc_err *);\nextern void                   clnt_pcreateerror(char *);\nextern void                   clnt_perrno(enum clnt_stat);\nextern void                   clnt_perror(CLIENT *, char *);\nextern char *                 clnt_spcreateerror(char *);\nextern char *                 clnt_sperrno(enum clnt_stat);\nextern char *                 clnt_sperror(CLIENT *, char *);\nextern CLIENT *               clnt_tli_create(/* ??? */);\nextern CLIENT *               clnt_tp_create(/* ??? */);\nextern CLIENT *               clnt_vc_create(/* ??? */);\nextern CLIENT *               clntraw_create(unsigned long, unsigned long);\nextern CLIENT *               clnttcp_create(struct sockaddr_in *, unsigned long, unsigned long, int *, unsigned int, unsigned int *);\nextern CLIENT *               clntudp_bufcreate(struct sockaddr_in *, unsigned long, unsigned long, struct timeval, int *, unsigned int, unsigned int);\nextern CLIENT *               clntudp_create(struct sockaddr_in *, unsigned long, unsigned long, struct timeval, int *);\nextern clock_t                clock(void);\nextern int                    close(int);\nextern int                    closedir(DIR *);\nextern int                    color_content(int, short int *, short int *, short int *);\nextern char *                 compile(const char *, char *, char *);\nextern char *                 copylist(const char *, off_t *);\nextern double                 copysign(double, double);\nextern int                    copywin(WINDOW *, WINDOW *, int, int, int, int, int, int, int);\nextern double                 cos(double);\nextern float                  cosf(float);\nextern double                 cosh(double);\nextern float                  coshf(float);\nextern struct rd_user *       cr_rduser(/* ??? */);\nextern int                    creat(const char *, mode_t);\nextern int                    crmode(void);\nextern char *                 crypt(const char *, const char *);\nextern int                    crypt_close(int *);\nextern char *                 ctermid(char *);\nextern char *                 ctime(const time_t *);\nextern FIELD *                current_field(FORM *);\nextern ITEM *                 current_item(MENU *);\nextern int                    curs_set(int);\nextern void                   curserr(void);\nextern char *                 cuserid(char *);\nextern int                    data_ahead(FORM *);\nextern int                    data_behind(FORM *);\nextern void                   dbmclose(void);\nextern void                   dbminit(const char *);\nextern int                    def_prog_mode(void);\nextern int                    def_shell_mode(void);\nextern char *                 defread(/* ??? */);\nextern int                    del_panel(PANEL *);\nextern void                   del_rduser(/* ??? */);\nextern void                   delay(long int);\nextern int                    delay_output(int);\nextern void                   delete(datum);\nextern void                   delscreen(SCREEN *);\nextern int                    delterm(TERMINAL *);\nextern int                    delwin(WINDOW *);\nextern WINDOW *               derwin(WINDOW *, int, int, int, int);\nextern char *                 des_crypt(const char *, const char *);\nextern void                   des_encrypt(char *, int);\nextern void                   des_setkey(const char *);\nextern char *                 devattr(/* ??? */);\nextern int                    devfree(/* ??? */);\nextern char **                devreserv(/* ??? */);\nextern int                    dial(CALL);\nextern double                 difftime(time_t, time_t);\nextern char *                 dirname(char *);\nextern div_t                  div(int, int);\nextern int                    dlclose(void *);\nextern char *                 dlerror(void);\nextern void *                 dlopen(char *, int);\nextern void *                 dlsym(void *, char *);\nextern void                   dma_access(u_char, u_int, u_int, u_char, u_char);\nextern int                    doupdate(void);\nextern int                    drainio(int);\nextern double                 drand48(void);\nextern double                 drem(double, double);\nextern int                    drv_getevtoken(/* ??? */);\nextern void                   drv_relevtoken(/* ??? */);\nextern int                    dup(int);\nextern int                    dup2(int, int);\nextern FIELD *                dup_field(FIELD *, int, int);\nextern WINDOW *               dupwin(WINDOW *);\nextern int                    dynamic_field_info(FIELD *, int *, int *, int *);\nextern int                    dysize(int);\nextern int                    eaccess(const char *, int);\nextern int                    echo(void);\nextern char *                 ecvt(double, int, int *, int *);\nextern size_t                 elf32_fsize(Elf_Type, size_t, unsigned int);\nextern Elf32_Ehdr *           elf32_getehdr(Elf *);\nextern Elf32_Phdr *           elf32_getphdr(Elf *);\nextern Elf32_Shdr *           elf32_getshdr(Elf_Scn *);\nextern Elf32_Ehdr *           elf32_newehdr(Elf *);\nextern Elf32_Phdr *           elf32_newphdr(Elf *, size_t);\nextern Elf_Data *             elf32_xlatetof(Elf_Data *, const Elf_Data *, unsigned int);\nextern Elf_Data *             elf32_xlatetom(Elf_Data *, const Elf_Data *, unsigned int);\nextern Elf *                  elf_begin(int, Elf_Cmd, Elf *);\nextern int                    elf_cntl(Elf *, Elf_Cmd);\nextern int                    elf_end(Elf *);\nextern const char *           elf_errmsg(int);\nextern int                    elf_errno(void);\nextern void                   elf_fill(int);\nextern unsigned int           elf_flagdata(Elf_Data *, Elf_Cmd, unsigned int);\nextern unsigned int           elf_flagehdr(Elf *, Elf_Cmd, unsigned int);\nextern unsigned int           elf_flagelf(Elf *, Elf_Cmd, unsigned int);\nextern unsigned int           elf_flagphdr(Elf *, Elf_Cmd, unsigned int);\nextern unsigned int           elf_flagscn(Elf_Scn *, Elf_Cmd, unsigned int);\nextern unsigned int           elf_flagshdr(Elf_Scn *, Elf_Cmd, unsigned int);\nextern Elf_Arhdr *            elf_getarhdr(Elf *);\nextern Elf_Arsym *            elf_getarsym(Elf *, size_t *);\nextern off_t                  elf_getbase(Elf *);\nextern Elf_Data *             elf_getdata(Elf_Scn *, Elf_Data *);\nextern char *                 elf_getident(Elf *, size_t *);\nextern Elf_Scn *              elf_getscn(Elf *, size_t);\nextern long unsigned int      elf_hash(const char *);\nextern Elf_Kind               elf_kind(Elf *);\nextern size_t                 elf_ndxscn(Elf_Scn *);\nextern Elf_Data *             elf_newdata(Elf_Scn *);\nextern Elf_Scn *              elf_newscn(Elf *);\nextern Elf_Cmd                elf_next(Elf *);\nextern Elf_Scn *              elf_nextscn(Elf *, Elf_Scn *);\nextern size_t                 elf_rand(Elf *, size_t);\nextern Elf_Data *             elf_rawdata(Elf_Scn *, Elf_Data *);\nextern char *                 elf_rawfile(Elf *, size_t *);\nextern char *                 elf_strptr(Elf *, size_t, size_t);\nextern off_t                  elf_update(Elf *, Elf_Cmd);\nextern unsigned int           elf_version(unsigned int);\nextern void                   encrypt(char *, int);\nextern void                   endgrent(void);\nextern int                    endnetconfig(void *);\nextern int                    endnetpath(void *);\nextern void                   endpwent(void);\nextern void                   endrpcent(void);\nextern void                   endspent(void);\nextern void                   endutent(void);\nextern void                   endutxent(void);\nextern int                    endwin(void);\nextern double                 erand(short *);\nextern double                 erand48(short unsigned int *);\nextern char                   erasechar(void);\nextern double                 erf(double);\nextern double                 erfc(double);\nextern int                    execl(const char *, const char *, ...);\nextern int                    execle(const char *, const char *, ...);\nextern int                    execlp(const char *, const char *, ...);\nextern int                    exect(const char *,  const char **,  char **);\nextern int                    execv(const char *, char *const *);\nextern int                    execve(const char *, char *const *, char *const *);\nextern int                    execvp(const char *, char *const *);\nextern void                   exit(int);\nextern double                 exp(double);\nextern float                  expf(float);\nextern double                 fabs(double);\nextern float                  fabsf(float);\nextern int                    fattach(int, const char *);\nextern int                    fchdir(int);\nextern int                    fchmod(int, mode_t);\nextern int                    fchown(int, uid_t, gid_t);\nextern int                    fclose(FILE *);\nextern int                    fcntl(int, int, ...);\nextern char *                 fcvt(double, int, int *, int *);\nextern int                    fdetach(const char *);\nextern FILE *                 fdopen(int, const char *);\nextern int                    feof(FILE *);\nextern int                    ferror(FILE *);\nextern datum                  fetch(datum);\nextern int                    fflush(FILE *);\nextern int                    ffs(int);\nextern int                    fgetc(FILE *);\nextern struct group *         fgetgrent(FILE *);\nextern int                    fgetpos(FILE *, fpos_t *);\nextern struct passwd *        fgetpwent(FILE *);\nextern char *                 fgets(char *, int, FILE *);\nextern struct spwd *          fgetspent(FILE *);\nextern char *                 field_arg(FIELD *);\nextern chtype                 field_back(FIELD *);\nextern char *                 field_buffer(FIELD *, int);\nextern int                    field_count(FORM *);\nextern chtype                 field_fore(FIELD *);\nextern int                    field_index(FIELD *);\nextern int                    field_info(FIELD *, int *, int *, int *, int *, int *, int *);\nextern PTF_void               field_init(FORM *);\nextern int                    field_just(FIELD *);\nextern OPTIONS                field_opts(FIELD *);\nextern int                    field_opts_off(FIELD *, OPTIONS);\nextern int                    field_opts_on(FIELD *, OPTIONS);\nextern int                    field_pad(FIELD *);\nextern int                    field_status(FIELD *);\nextern PTF_void               field_term(FORM *);\nextern FIELDTYPE *            field_type(FIELD *);\nextern char *                 field_userptr(FIELD *);\nextern int                    fileno(FILE *);\nextern int                    filter(void);\nextern int                    finite(double);\nextern datum                  firsthash(/* ??? */);\nextern datum                  firstkey(void);\nextern int                    flash(void);\nextern int                    flock(int, int);\nextern double                 floor(double);\nextern float                  floorf(float);\nextern int                    flushinp(void);\nextern double                 fmod(double, double);\nextern float                  fmodf(float, float);\nextern int                    fmtmsg(long int, const char *, int, const char *, const char *, const char *);\nextern FILE *                 fopen(const char *, const char *);\nextern pid_t                  fork(void);\nextern int                    form_driver(FORM *, int);\nextern FIELD **               form_fields(FORM *);\nextern PTF_void               form_init(FORM *);\nextern OPTIONS                form_opts(FORM *);\nextern int                    form_opts_off(FORM *, OPTIONS);\nextern int                    form_opts_on(FORM *, OPTIONS);\nextern int                    form_page(FORM *);\nextern WINDOW *               form_sub(FORM *);\nextern PTF_void               form_term(FORM *);\nextern char *                 form_userptr(FORM *);\nextern WINDOW *               form_win(FORM *);\nextern long int               fpathconf(int, int);\nextern fpclass_t              fpclass(double);\nextern int                    fpgetmask(void);\nextern fp_rnd                 fpgetround(void);\nextern int                    fpgetsticky(void);\nextern int                    fprintf(FILE *, const char *, ...);\nextern int                    fpsetmask(int);\nextern fp_rnd                 fpsetround(fp_rnd);\nextern int                    fpsetsticky(int);\nextern int                    fputc(int, FILE *);\nextern int                    fputs(const char *, FILE *);\nextern size_t                 fread(void *, size_t, size_t, FILE *);\nextern void                   free(void *);\nextern int                    free_field(FIELD *);\nextern int                    free_fieldtype(FIELDTYPE *);\nextern int                    free_form(FORM *);\nextern int                    free_item(ITEM *);\nextern int                    free_menu(MENU *);\nextern void                   freenetconfigent(struct netconfig *);\nextern FILE *                 freopen(const char *, const char *, FILE *);\nextern double                 frexp(double, int *);\nextern int                    fscanf(FILE *, const char *, ...);\nextern int                    fseek(FILE *, long int, int);\nextern int                    fsetpos(FILE *, const fpos_t *);\nextern int                    fstat(int, struct stat *);\nextern int                    fstatfs(int, struct statfs *, int, int);\nextern int                    fstatvfs(int, struct statvfs *);\nextern int                    fsync(int);\nextern long int               ftell(FILE *);\nextern key_t                  ftok(const char *, int);\nextern int                    ftruncate(int, off_t);\nextern int                    ftw(const char *, int (*) (const char *, const struct stat *, int), int);\nextern size_t                 fwrite(const void *, size_t, size_t, FILE *);\nextern double                 gamma(double);\nextern char *                 gcvt(double, int, char *);\nextern int                    get_error(/* ??? */);\nextern chtype                 getattrs(WINDOW *);\nextern int                    getbegx(WINDOW *);\nextern int                    getbegy(WINDOW *);\nextern chtype                 getbkgd(WINDOW *);\nextern long unsigned int      getbmap(void);\nextern int                    getc(FILE *);\nextern char *                 getcap(/* ??? */);\nextern int                    getchar(void);\nextern int                    getcontext(ucontext_t *);\nextern int                    getcurx(WINDOW *);\nextern int                    getcury(WINDOW *);\nextern char *                 getcwd(char *, size_t);\nextern struct tm *            getdate(const char *);\nextern int                    getdents(int, struct dirent *, unsigned int);\nextern char **                getdev(/* ??? */);\nextern char **                getdgrp(/* ??? */);\nextern int                    getdomainname(char *, int);\nextern int                    getdtablesize(void);\nextern gid_t                  getegid(void);\nextern char *                 getenv(const char *);\nextern struct errhdr *        geterec(/* ??? */);\nextern struct errhdr *        geteslot(/* ??? */);\nextern uid_t                  geteuid(void);\nextern gid_t                  getgid(void);\nextern struct group *         getgrent(void);\nextern struct group *         getgrgid(gid_t);\nextern struct group *         getgrnam(const char *);\nextern int                    getgroups(int, TARGET_GETGROUPS_T []);\nextern struct hostent *       gethostbyaddr(/* ??? */);\nextern struct hostent *       gethostbyname(/* ??? */);\nextern struct hostent *       gethostent(/* ??? */);\n#ifdef __alpha__\nextern int                    gethostid(void);\n#else\nextern long                   gethostid(void);\n#endif\nextern int                    gethostname(char *, size_t);\nextern int                    getitimer(int, struct itimerval *);\nextern char *                 getlogin(void);\nextern int                    getmaxx(WINDOW *);\nextern int                    getmaxy(WINDOW *);\nextern int                    getmntany(FILE *, struct mnttab *, struct mnttab *);\nextern int                    getmntent(/* ??? */);\nextern long unsigned int      getmouse(void);\nextern int                    getmsg(int, struct strbuf *, struct strbuf *, int *);\nextern struct netent *        getnetbyaddr(/* ??? */);\nextern struct netent *        getnetbyname(/* ??? */);\nextern struct netconfig *     getnetconfig(void *);\nextern struct netconfig *     getnetconfigent(char *);\nextern struct netent *        getnetent(/* ??? */);\nextern struct netconfig *     getnetpath(void *);\nextern int                    getopt(int, char *const *, const char *);\nextern int                    getpagesize(void);\nextern int                    getparx(WINDOW *);\nextern int                    getpary(WINDOW *);\nextern char *                 getpass(const char *);\nextern pid_t                  getpgid(pid_t);\nextern pid_t                  getpgrp(void);\nextern pid_t                  getpgrp2(pid_t);\nextern pid_t                  getpid(void);\nextern int                    getpmsg(int, struct strbuf *, struct strbuf *, int *, int *);\nextern pid_t                  getppid(void);\nextern int                    getpriority(int, int);\nextern struct protoent *      getprotobyname(/* ??? */);\nextern struct protoent *      getprotobynumber(/* ??? */);\nextern struct protoent *      getprotoent(/* ??? */);\nextern int                    getpw(int, char *);\nextern struct passwd *        getpwent(void);\nextern struct passwd *        getpwnam(const char *);\nextern struct passwd *        getpwuid(uid_t);\nextern int                    getrlimit(int, struct rlimit *);\nextern int                    getrnge(char *);\nextern struct rpcent *        getrpcbyname(const char *);\nextern struct rpcent *        getrpcbynumber(int);\nextern struct rpcent *        getrpcent(void);\nextern int                    getrusage(int, struct rusage *);\nextern char *                 gets(char *);\nextern struct servent *       getservbyname(/* ??? */);\nextern struct servent *       getservbyport(/* ??? */);\nextern struct servent *       getservent(/* ??? */);\nextern pid_t                  getsid(pid_t);\nextern struct spwd *          getspent(void);\nextern struct spwd *          getspnam(const char *);\nextern int                    getsubopt(char **, char *const *, char **);\nextern int                    gettmode(void);\nextern char *                 gettxt(const char *, const char *);\nextern uid_t                  getuid(void);\nextern struct utmp *          getutent(void);\nextern struct utmp *          getutid(const struct utmp *);\nextern struct utmp *          getutline(const struct utmp *);\nextern void                   getutmp(const struct utmpx *, struct utmp *);\nextern void                   getutmpx(const struct utmp *, struct utmpx *);\nextern struct utmpx *         getutxent(void);\nextern struct utmpx *         getutxid(const struct utmpx *);\nextern struct utmpx *         getutxline(const struct utmpx *);\nextern int                    getvfsany(FILE *, struct vfstab *, struct vfstab *);\nextern int                    getvfsent(FILE *, struct vfstab *);\nextern int                    getvfsfile(FILE *, struct vfstab *, char *);\nextern int                    getvfsspec(FILE *, struct vfstab *, char *);\nextern int                    getvol(/* ??? */);\nextern int                    getw(FILE *);\nextern char *                 getwd(char *);\nextern void                   getwidth(eucwidth_t *);\nextern WINDOW *               getwin(FILE *);\nextern int                    gmatch(const char *, const char *);\nextern struct tm *            gmtime(const time_t *);\nextern int                    gsignal(int);\nextern int                    halfdelay(int);\nextern bool                   has_colors(void);\nextern int                    has_ic(void);\nextern int                    has_il(void);\nextern long int               hashinc(/* ??? */);\nextern char *                 hasmntopt(/* ??? */);\nextern int                    hcreate(size_t);\nextern void                   hdestroy(void);\nextern int                    hide_panel(PANEL *);\nextern int                    host2netname(char *, char *, char *);\nextern int                    hrtalarm(hrtcmd_t *, int);\nextern int                    hrtcancel(const long int *, int);\nextern int                    hrtcntl(int, int, interval_t *, hrtime_t *);\nextern int                    hrtsleep(hrtcmd_t *);\nextern ENTRY *                hsearch(ENTRY, ACTION);\nextern long unsigned int      htonl(long unsigned int);\nextern short unsigned int     htons(unsigned int);\nextern double                 hypot(double, double);\nextern void                   idcok(WINDOW *, int);\nextern int                    idlok(WINDOW *, int);\nextern void                   immedok(WINDOW *, int);\nextern char *                 index(const char *, int);\nextern long unsigned int      inet_addr(/* ??? */);\nextern struct in_addr         inet_makeaddr(/* ??? */);\nextern long unsigned int      inet_network(/* ??? */);\nextern char *                 inet_ntoa(/* ??? */);\nextern int                    init_color(int, int, int, int);\nextern int                    init_pair(int, int, int);\nextern int                    initgroups(const char *, gid_t);\nextern WINDOW *               initscr(/* ??? */);\nextern WINDOW *               initscr32(void);\nextern char *                 initstate(unsigned, char *, int);\nextern void                   insque(struct qelem *, struct qelem *);\nextern int                    intrflush(WINDOW *, int);\nextern int                    ioctl(int, int, ...);\nextern int                    is_linetouched(WINDOW *, int);\nextern int                    is_wintouched(WINDOW *);\nextern int                    isalnum(int);\nextern int                    isalpha(int);\nextern int                    isascii(int);\nextern int                    isatty(int);\nextern int                    iscntrl(int);\nextern int                    isdigit(int);\nextern int                    isencrypt(const char *, size_t);\nextern int                    isendwin(void);\nextern int                    isgraph(int);\nextern int                    isinf(double);\nextern int                    islower(int);\nextern int                    isnan(double);\nextern int                    isnand(double);\nextern int                    isnanf(float);\nextern int                    isprint(int);\nextern int                    ispunct(int);\nextern int                    isspace(int);\nextern int                    isupper(int);\nextern int                    isxdigit(int);\nextern int                    item_count(MENU *);\nextern char *                 item_description(ITEM *);\nextern int                    item_index(ITEM *);\nextern PTF_void               item_init(MENU *);\nextern char *                 item_name(ITEM *);\nextern OPTIONS                item_opts(ITEM *);\nextern int                    item_opts_off(ITEM *, OPTIONS);\nextern int                    item_opts_on(ITEM *, OPTIONS);\nextern PTF_void               item_term(MENU *);\nextern char *                 item_userptr(ITEM *);\nextern int                    item_value(ITEM *);\nextern int                    item_visible(ITEM *);\nextern long int               itol(/* ??? */);\nextern double                 j0(double);\nextern double                 j1(double);\nextern double                 jn(int, double);\nextern long int               jrand48(short unsigned int *);\nextern char *                 keyname(int);\nextern int                    keypad(WINDOW *, int);\nextern int                    kill(pid_t, int);\nextern char                   killchar(void);\nextern int                    killpg(int, int);\nextern void                   l3tol(long int *, const char *, int);\nextern char *                 l64a(long int);\nextern long int               labs(long int);\nextern dl_t                   ladd(/* ??? */);\nextern int                    lchown(const char *, uid_t, gid_t);\nextern int                    lckpwdf(void);\nextern void                   lcong48(short unsigned int *);\nextern int                    ldaclose(struct ldfile *);\nextern int                    ldahread(struct ldfile *, archdr *);\nextern struct ldfile *        ldaopen(const char *, struct ldfile *);\nextern int                    ldclose(struct ldfile *);\nextern double                 ldexp(double, int);\nextern int                    ldfhread(struct ldfile *, struct filehdr *);\nextern char *                 ldgetname(struct ldfile *, const struct syment *);\nextern ldiv_t                 ldiv(long int, long int);\nextern dl_t                   ldivide(/* ??? */);\nextern int                    ldlinit(struct ldfile *, long int);\nextern int                    ldlitem(struct ldfile *, unsigned int, struct lineno *);\nextern int                    ldlread(struct ldfile *, long int, unsigned int, struct lineno *);\nextern int                    ldlseek(struct ldfile *, unsigned int);\nextern int                    ldnlseek(struct ldfile *, const char *);\nextern int                    ldnrseek(struct ldfile *, const char *);\nextern int                    ldnshread(struct ldfile *, const char *, struct scnhdr *);\nextern int                    ldnsseek(struct ldfile *, const char *);\nextern int                    ldohseek(struct ldfile *);\nextern struct ldfile *        ldopen(const char *, struct ldfile *);\nextern int                    ldrseek(struct ldfile *, unsigned int);\nextern int                    ldshread(struct ldfile *, unsigned int, struct scnhdr *);\nextern int                    ldsseek(struct ldfile *, unsigned int);\nextern long int               ldtbindex(struct ldfile *);\nextern int                    ldtbread(struct ldfile *, long int, struct syment *);\nextern int                    ldtbseek(struct ldfile *);\nextern int                    leaveok(WINDOW *, int);\nextern dl_t                   lexp10(/* ??? */);\nextern void *                 lfind(const void *, const void *, size_t *, size_t, int (*) (const void *, const void *));\nextern double                 lgamma(double);\nextern int                    link(const char *, const char *);\nextern FIELD *                link_field(FIELD *, int, int);\nextern FIELDTYPE *            link_fieldtype(FIELDTYPE *, FIELDTYPE *);\nextern char **                listdev(/* ??? */);\nextern char **                listdgrp(/* ??? */);\nextern dl_t                   llog10(/* ??? */);\nextern dl_t                   lmul(/* ??? */);\nextern struct lconv *         localeconv(void);\nextern struct tm *            localtime(const time_t *);\nextern int                    lock(int, int, long);\nextern int                    lockf(int, int, off_t);\nextern double                 log(double);\nextern double                 log10(double);\nextern float                  log10f(float);\nextern double                 logb(double);\nextern float                  logf(float);\nextern char *                 logname(void);\nextern void                   longjmp(jmp_buf, int);\nextern char *                 longname(void);\nextern long int               lrand48(void);\nextern void *                 lsearch(const void *, void *, size_t *, size_t, int (*) (const void *, const void *));\nextern off_t                  lseek(int, off_t, int);\nextern dl_t                   lshiftl(/* ??? */);\nextern int                    lstat(const char *, struct stat *);\nextern dl_t                   lsub(/* ??? */);\nextern void                   ltol3(char *, const long int *, int);\nextern int                    m_addch(int);\nextern int                    m_addstr(char *);\nextern int                    m_clear(void);\nextern int                    m_erase(void);\nextern WINDOW *               m_initscr(void);\nextern int                    m_move(int, int);\nextern SCREEN *               m_newterm(char *, FILE *, FILE *);\nextern int                    m_refresh(void);\nextern int                    maillock(char *, int);\nextern int                    mailunlock(void);\nextern major_t                major(dev_t);\nextern datum                  makdatum(/* ??? */);\nextern void                   makecontext(ucontext_t *, void (*) (/* ??? */), int, ...);\nextern dev_t                  makedev(major_t, minor_t);\nextern struct utmpx *         makeutx(const struct utmpx *);\nextern struct mallinfo        mallinfo(void);\nextern void *                 malloc(size_t);\nextern int                    mallopt(int, int);\nextern int                    map_button(long unsigned int);\nextern int                    matherr(struct exception *);\nextern int                    mbftowc(char *, wchar_t *, int (*) (/* ??? */), int *);\nextern int                    mblen(const char *, size_t);\nextern size_t                 mbstowcs(wchar_t *, const char *, size_t);\nextern int                    mbtowc(wchar_t *, const char *, size_t);\nextern void *                 memalign(size_t, size_t);\nextern void *                 memccpy(void *, const void *, int, size_t);\nextern void *                 memchr(const void *, int, size_t);\nextern int                    memcmp(const void *, const void *, size_t);\nextern void *                 memcpy(void *, const void *, size_t);\nextern int                    memlock(/* ??? */);\nextern int                    memlocked(/* ??? */);\nextern void *                 memmove(void *, const void *, size_t);\nextern void *                 memset(void *, int, size_t);\nextern int                    memunlock(/* ??? */);\nextern chtype                 menu_back(MENU *);\nextern int                    menu_driver(MENU *, int);\nextern chtype                 menu_fore(MENU *);\nextern void                   menu_format(MENU *, int *, int *);\nextern chtype                 menu_grey(MENU *);\nextern PTF_void               menu_init(MENU *);\nextern ITEM **                menu_items(MENU *);\nextern char *                 menu_mark(MENU *);\nextern OPTIONS                menu_opts(MENU *);\nextern int                    menu_opts_off(MENU *, OPTIONS);\nextern int                    menu_opts_on(MENU *, OPTIONS);\nextern int                    menu_pad(MENU *);\nextern char *                 menu_pattern(MENU *);\nextern WINDOW *               menu_sub(MENU *);\nextern PTF_void               menu_term(MENU *);\nextern char *                 menu_userptr(MENU *);\nextern WINDOW *               menu_win(MENU *);\nextern int                    meta(WINDOW *, int);\nextern void                   mfree(struct map *, size_t, u_long);\nextern int                    mincore(caddr_t, size_t, char *);\nextern minor_t                minor(dev_t);\nextern int                    mkdir(const char *, mode_t);\nextern int                    mkdirp(const char *, mode_t);\nextern int                    mkfifo(const char *, mode_t);\nextern int                    mknod(const char *, mode_t, dev_t);\nextern int                    mkstemp(char *);\nextern char *                 mktemp(char *);\nextern time_t                 mktime(struct tm *);\nextern caddr_t                mmap(/* ??? */);\nextern double                 modf(double, double *);\nextern float                  modff(float, float *);\nextern struct utmpx *         modutx(const struct utmpx *);\nextern void                   monitor(int (*) (/* ??? */), int (*) (/* ??? */), WORD *, int, int);\nextern int                    mount(const char *, const char *, int, ...);\nextern int                    mouse_off(long int);\nextern int                    mouse_on(long int);\nextern int                    mouse_set(long int);\nextern int                    move_field(FIELD *, int, int);\nextern int                    move_panel(PANEL *, int, int);\nextern int                    mprotect(/* ??? */);\nextern long int               mrand48(void);\nextern int                    msgctl(int, int, ...);\nextern int                    msgget(key_t, int);\nextern int                    msgrcv(int, void *, size_t, long int, int);\nextern int                    msgsnd(int, const void *, size_t, int);\nextern int                    munmap(/* ??? */);\nextern int                    mvcur(int, int, int, int);\nextern int                    mvderwin(WINDOW *, int, int);\nextern int                    mvprintw(int, int, ...);\nextern int                    mvscanw(int, int, ...);\nextern int                    mvwin(WINDOW *, int, int);\nextern int                    mvwprintw(WINDOW *, int, int, ...);\nextern int                    mvwscanw(WINDOW *, int, int, ...);\nextern int                    napms(int);\nextern void                   netdir_free(char *, int);\nextern int                    netdir_getbyaddr(struct netconfig *, struct nd_hostservlist **, struct netbuf *);\nextern int                    netdir_getbyname(struct netconfig *, struct nd_hostserv *, struct nd_addrlist **);\nextern int                    netdir_options(struct netconfig *, int, int, char *);\nextern void                   netdir_perror(char *);\nextern char *                 netdir_sperror(/* ??? */);\nextern FIELD *                new_field(int, int, int, int, int, int);\nextern FIELDTYPE *            new_fieldtype(PTF_int, PTF_int);\nextern FORM *                 new_form(FIELD **);\nextern ITEM *                 new_item(char *, char *);\nextern MENU *                 new_menu(ITEM **);\nextern int                    new_page(FIELD *);\nextern PANEL *                new_panel(WINDOW *);\nextern int                    newkey(char *, int, int);\nextern WINDOW *               newpad(int, int);\nextern SCREEN *               newscreen(char *, int, int, int, FILE *, FILE *);\nextern SCREEN *               newterm32(char *, FILE *, FILE *);\nextern WINDOW *               newwin(int, int, int, int);\nextern double                 nextafter(double, double);\nextern datum                  nextkey(datum);\nextern int                    nftw(const char *, int (*) (const char *, const struct stat *, int, struct FTW *), int, int);\nextern int                    nice(int);\nextern int                    nl(void);\nextern char *                 nl_langinfo(nl_item);\nextern int                    nlist(const char *, struct nlist *);\nextern int                    nocbreak(void);\nextern int                    nocrmode(void);\nextern int                    nodelay(WINDOW *, int);\nextern int                    noecho(void);\nextern int                    nonl(void);\nextern int                    noraw(void);\nextern int                    notimeout(WINDOW *, int);\nextern long int               nrand48(short unsigned int *);\nextern int                    ns_close(/* ??? */);\nextern struct nssend *        ns_rcv(/* ??? */);\nextern int                    ns_send(/* ??? */);\nextern int                    ns_setup(/* ??? */);\nextern long unsigned int      ntohl(long unsigned int);\nextern short unsigned int     ntohs(unsigned int);\nextern int                    nuname(struct utsname *);\nextern int                    open(const char *, int, ...);\nextern DIR *                  opendir(const char *);\nextern int                    openprivwait(/* ??? */);\nextern int                    openwait(/* ??? */);\nextern int                    overlay(WINDOW *, WINDOW *);\nextern int                    overwrite(WINDOW *, WINDOW *);\nextern int                    p2close(FILE **);\nextern int                    p2open(const char *, FILE **);\nextern int                    p32echochar(WINDOW *, chtype);\nextern char *                 p_cdname(/* ??? */);\nextern char *                 p_class(/* ??? */);\nextern char *                 p_rr(/* ??? */);\nextern char *                 p_type(/* ??? */);\nextern int                    pair_content(int, short int *, short int *);\nextern PANEL *                panel_above(PANEL *);\nextern PANEL *                panel_below(PANEL *);\nextern char *                 panel_userptr(PANEL *);\nextern WINDOW *               panel_window(PANEL *);\nextern long int               pathconf(const char *, int);\nextern char *                 pathfind(const char *, const char *, const char *);\nextern int                    pause(void);\nextern int                    pclose(FILE *);\nextern void                   perror(const char *);\nextern struct pfdat *         pfind(/* ??? */);\nextern int                    pglstlk(/* ??? */);\nextern int                    pglstunlk(/* ??? */);\nextern int                    pid_slot(proc_t *);\nextern int                    pipe(int *);\nextern int                    plock(int);\nextern struct pmaplist *      pmap_getmaps(/* ??? */);\nextern u_short                pmap_getport(/* ??? */);\nextern enum clnt_stat         pmap_rmtcall(/* ??? */);\nextern int                    pmap_set(/* ??? */);\nextern int                    pmap_unset(/* ??? */);\nextern int                    pnoutrefresh(WINDOW *, int, int, int, int, int, int);\nextern int                    poll(struct pollfd *, long unsigned int, int);\nextern FILE *                 popen(const char *, const char *);\nextern int                    pos_form_cursor(FORM *);\nextern int                    pos_menu_cursor(MENU *);\nextern int                    post_form(FORM *);\nextern int                    post_menu(MENU *);\nextern double                 pow(double, double);\nextern float                  powf(float, float);\nextern int                    prefresh(WINDOW *, int, int, int, int, int, int);\nextern int                    printf(const char *, ...);\nextern int                    printw(char *, ...);\nextern void                   privsig(/* ??? */);\nextern void                   profil(short unsigned int *, size_t, int, unsigned int);\nextern void                   psiginfo(siginfo_t *, char *);\nextern void                   psignal(int, const char *);\nextern int                    ptrace(int, pid_t, int, int);\nextern int                    putc(int, FILE *);\nextern int                    putchar(int);\nextern int                    putenv(char *);\nextern int                    putmsg(int, const struct strbuf *, const struct strbuf *, int);\nextern int                    putp(char *);\nextern int                    putpmsg(int, const struct strbuf *, const struct strbuf *, int, int);\nextern int                    putpwent(const struct passwd *, FILE *);\nextern int                    puts(const char *);\nextern int                    putspent(const struct spwd *, FILE *);\nextern struct utmp *          pututline(const struct utmp *);\nextern struct utmpx *         pututxline(const struct utmpx *);\nextern int                    putw(int, FILE *);\nextern int                    putwin(WINDOW *, FILE *);\nextern void                   qsort(void *, size_t, size_t, int (*) (const void *, const void *));\nextern int                    raise(int);\nextern int                    rand(void);\nextern long                   random(void);\nextern int                    raw(void);\nextern ssize_t                read(int, void *, size_t);\nextern struct dirent *        readdir(DIR *);\nextern ssize_t                readlink(const char *, char *, size_t);\nextern void *                 realloc(void *, size_t);\nextern char *                 realpath(char *, char *);\nextern int                    redrawwin(WINDOW *);\nextern char *                 regcmp(const char *, ...);\nextern char *                 regex(const char *, const char *, ...);\nextern double                 remainder(double, double);\nextern int                    remio(/* ??? */);\nextern int                    remove(const char *);\nextern void                   remque(struct qelem *);\nextern int                    rename(const char *, const char *);\nextern int                    replace_panel(PANEL *, WINDOW *);\nextern int                    request_mouse_pos(void);\nextern struct reservdev **    reservdev(/* ??? */);\nextern int                    reset_prog_mode(void);\nextern int                    reset_shell_mode(void);\nextern int                    resetty(void);\nextern int                    restartterm(char *, int, int *);\nextern void                   rewind(FILE *); \nextern void                   rewinddir(DIR *);\nextern int                    rf_falloc(/* ??? */);\nextern char *                 rindex(const char *, int);\nextern double                 rint(double);\nextern int                    ripoffline(int, int (*) (WINDOW *, int));\nextern int                    rmdir(const char *);               \nextern int                    rmdirp(char *, char *);\nextern enum clnt_stat         rpc_broadcast(/* ??? */);\nextern enum clnt_stat         rpc_call(/* ??? */);\nextern int                    rpcb_getaddr(/* ??? */);\nextern RPCBLIST *             rpcb_getmaps(/* ??? */);\nextern int                    rpcb_gettime(/* ??? */);\nextern enum clnt_stat         rpcb_rmtcall(/* ??? */);\nextern int                    rpcb_set(/* ??? */);\nextern char *                 rpcb_taddr2uaddr(/* ??? */);\nextern struct netbuf *        rpcb_uaddr2taddr(/* ??? */);\nextern int                    rpcb_unset(/* ??? */);\nextern void                   rpctest_service(/* ??? */);\nextern int                    run_crypt(long int, char *, unsigned int, int *);\nextern int                    run_setkey(int *, const char *);\nextern int                    savetty(void);\nextern void *                 sbrk(int);              \nextern double                 scalb(double, double);\nextern int                    scale_form(FORM *, int *, int *);\nextern int                    scale_menu(MENU *, int *, int *);\nextern int                    scanf(const char *, ...);\nextern int                    scanw(char *, ...);\nextern int                    scr_dump(char *);\nextern int                    scr_init(char *);\nextern int                    scr_restore(char *);\nextern int                    scroll(WINDOW *);\nextern int                    scrollok(WINDOW *, int);\nextern int                    scrwidth(wchar_t);\nextern int                    sdfree(char *);\nextern char *                 sdget(char *, int, ...);\nextern short unsigned int *   seed48(short unsigned int *);\nextern void                   seekdir(DIR *, long int);\nextern int                    semctl(int, int, int, ...);\nextern int                    semget(key_t, int, int);\nextern int                    semop(int, struct sembuf *, unsigned int);\nextern int                    send(int, char *, int, int);\nextern int                    set_current_field(FORM *, FIELD *);\nextern int                    set_current_item(MENU *, ITEM *);\nextern int                    set_field_back(FIELD *, chtype);\nextern int                    set_field_buffer(FIELD *, int, char *);\nextern int                    set_field_fore(FIELD *, chtype);\nextern int                    set_field_init(FORM *, PTF_void);\nextern int                    set_field_just(FIELD *, int);\nextern int                    set_field_opts(FIELD *, OPTIONS);\nextern int                    set_field_pad(FIELD *, int);\nextern int                    set_field_status(FIELD *, int);\nextern int                    set_field_term(FORM *, PTF_void);\nextern int                    set_field_type(FIELD *, FIELDTYPE *, ...);\nextern int                    set_field_userptr(FIELD *, char *);\nextern int                    set_fieldtype_arg(FIELDTYPE *, PTF_charP, PTF_charP, PTF_void);\nextern int                    set_fieldtype_choice(FIELDTYPE *, PTF_int, PTF_int);\nextern int                    set_form_fields(FORM *, FIELD **);\nextern int                    set_form_init(FORM *, PTF_void);\nextern int                    set_form_opts(FORM *, OPTIONS);\nextern int                    set_form_page(FORM *, int);\nextern int                    set_form_sub(FORM *, WINDOW *);\nextern int                    set_form_term(FORM *, PTF_void);\nextern int                    set_form_userptr(FORM *, char *);\nextern int                    set_form_win(FORM *, WINDOW *);\nextern int                    set_item_init(MENU *, PTF_void);\nextern int                    set_item_opts(ITEM *, OPTIONS);\nextern int                    set_item_term(MENU *, PTF_void);\nextern int                    set_item_userptr(ITEM *, char *);\nextern int                    set_item_value(ITEM *, int);\nextern int                    set_max_field(FIELD *, int);\nextern int                    set_menu_back(MENU *, chtype);\nextern int                    set_menu_fore(MENU *, chtype);\nextern int                    set_menu_format(MENU *, int, int);\nextern int                    set_menu_grey(MENU *, chtype);\nextern int                    set_menu_init(MENU *, PTF_void);\nextern int                    set_menu_items(MENU *, ITEM **);\nextern int                    set_menu_mark(MENU *, char *);\nextern int                    set_menu_opts(MENU *, OPTIONS);\nextern int                    set_menu_pad(MENU *, int);\nextern int                    set_menu_pattern(MENU *, char *);\nextern int                    set_menu_sub(MENU *, WINDOW *);\nextern int                    set_menu_term(MENU *, PTF_void);\nextern int                    set_menu_userptr(MENU *, char *);\nextern int                    set_menu_win(MENU *, WINDOW *);\nextern int                    set_new_page(FIELD *, int);\nextern int                    set_panel_userptr(PANEL *, char *);\nextern int                    set_top_row(MENU *, int);\nextern void                   setbuf(FILE *, char *);\nextern int                    setcontext(ucontext_t *);\nextern SCREEN *               setcurscreen(SCREEN *);\nextern TERMINAL *             setcurterm(TERMINAL *);\nextern FILE *                 setexportent(void);\nextern int                    setgid(gid_t);\nextern void                   setgrent(void);\nextern int                    setgroups(int, const gid_t *);\nextern int                    sethostname(char *, int);\nextern int                    setitimer(int, struct itimerval *, struct itimerval *);\nextern int                    setjmp(jmp_buf);\nextern void                   setkey(const char *);\nextern char *                 setlocale(int, const char *);\nextern FILE *                 setmntent(char *, char *);\nextern void *                 setnetconfig(void);\nextern void *                 setnetpath(void);\nextern int                    setpgid(pid_t, pid_t);\nextern pid_t                  setpgrp(void);\nextern int                    setpgrp2(pid_t, pid_t);\nextern int                    setpriority(int, int, int);\nextern int                    setprivwait(/* ??? */);\nextern void                   setpwent(void);\nextern int                    setregid(gid_t, gid_t);\nextern int                    setreuid(uid_t, uid_t);\nextern int                    setrlimit(int, struct rlimit *);\nextern int                    setrpcent(int);\nextern pid_t                  setsid(void);\nextern void                   setspent(void);\nextern char *                 setstate(char *);\nextern int                    setsyx(int, int);\nextern int                    setterm(char *);\nextern int                    setuid(uid_t);\nextern int                    setupterm(char *, int, int *);\nextern void                   setutent(void);\nextern void                   setutxent(void);\nextern int                    setvbuf(FILE *, char *, int, size_t);\nextern long int               sgetl(const char *);\nextern void *                 shmat(int, void *, int);\nextern int                    shmctl(int, int, ...);\nextern int                    shmdt(void *);\nextern int                    shmget(key_t, int, int);\nextern int                    show_panel(PANEL *);\nextern int                    sigaction(int, const struct sigaction *, struct sigaction *);\nextern int                    sigaddset(sigset_t *, int);\nextern int                    sigaltstack(const stack_t *, stack_t *);\nextern int                    sigblock(int);\nextern int                    sigdelset(sigset_t *, int);\nextern int                    sigemptyset(sigset_t *);\nextern int                    sigfillset(sigset_t *);\nextern int                    sighold(int);\nextern int                    sigignore(int);\nextern int                    siginterrupt(int, int);\nextern int                    sigismember(const sigset_t *, int);\nextern void                   siglongjmp(sigjmp_buf, int);\nextern signal_ret_t (*        signal(int, signal_ret_t (*) (int))) (int);\nextern int                    sigpause(int);\nextern int                    sigpending(sigset_t *);\nextern int                    sigprocmask(int, const sigset_t *, sigset_t *);\nextern int                    sigrelse(int);\nextern int                    sigsend(idtype_t, id_t, int);\nextern int                    sigsendset(const procset_t *, int);\nextern void (*                sigset(int, void (*) (int))) (int);\nextern int                    sigsetjmp(sigjmp_buf, int);\nextern int                    sigsetmask(int);\nextern int                    sigsuspend(sigset_t *);\nextern double                 sin(double);\nextern float                  sinf(float);\nextern double                 sinh(double);\nextern float                  sinhf(float);\nextern unsigned int           sleep(unsigned int);\nextern int                    slk_attroff(chtype);\nextern int                    slk_attron(chtype);\nextern int                    slk_attrset(chtype);\nextern int                    slk_clear(void);\nextern int                    slk_init(int);\nextern char *                 slk_label(int);\nextern int                    slk_noutrefresh(void);\nextern int                    slk_refresh(void);\nextern int                    slk_restore(void);\nextern int                    slk_set(int, char *, int);\nextern int                    slk_start(int, int *);\nextern int                    slk_touch(void);\nextern int                    socket (int, int, int);\nextern void *                 sprayproc_clear_1(/* ??? */);\nextern spraycumul *           sprayproc_get_1(/* ??? */);\nextern void *                 sprayproc_spray_1(/* ??? */);\nextern int                    sprintf(char *, const char *, ...);\nextern void                   sputl(long int, char *);\nextern double                 sqrt(double);\nextern float                  sqrtf(float);\nextern void                   srand(unsigned int);\nextern void                   srand48(long int);\nextern void                   srandom(int);\nextern int                    sscanf(const char *, const char *, ...);\nextern int (*                 ssignal(int, int (*) (int))) (int);\nextern int                    start_color(void);\nextern int                    stat(const char *, struct stat *);\nextern int                    statfs(const char *, struct statfs *, int, int);\nextern int                    statvfs(const char *, struct statvfs *);\nextern int                    step(const char *, const char *);\nextern int                    stime(const time_t *);\nextern struct netbuf *        stoa(char *, struct netbuf *);\nextern void                   store(datum, datum);\nextern char *                 strcadd(char *, const char *);\nextern int                    strcasecmp(const char *, const char *);\nextern char *                 strcat(char *, const char *);\nextern char *                 strccpy(char *, const char *);\nextern char *                 strchr(const char *, int);\nextern void                   strclearctty(/* ??? */);\nextern void                   strclearpg(/* ??? */);\nextern void                   strclearsid(/* ??? */);\nextern int                    strcmp(const char *, const char *);\nextern int                    strcoll(const char *, const char *);\nextern char *                 strcpy(char *, const char *);\nextern size_t                 strcspn(const char *, const char *);\nextern char *                 strdup(const char *);\nextern char *                 streadd(char *, const char *, const char *);\nextern char *                 strecpy(char *, const char *, const char *);\nextern char *                 strerror(int);\nextern int                    strfind(const char *, const char *);\nextern size_t                 strftime(char *, size_t, const char *, const struct tm *);\nextern size_t                 strlen(const char *);\nextern int                    strncasecmp(const char *, const char *, size_t);\nextern char *                 strncat(char *, const char *, size_t);\nextern int                    strncmp(const char *, const char *, size_t);\nextern char *                 strncpy(char *, const char *, size_t);\nextern char *                 strpbrk(const char *, const char *);\nextern char *                 strrchr(const char *, int);\nextern char *                 strrspn(const char *, const char *);\nextern size_t                 strspn(const char *, const char *);\nextern char *                 strstr(const char *, const char *);\nextern double                 strtod(const char *, char **);\nextern char *                 strtok(char *, const char *);\nextern long int               strtol(const char *, char **, int);\nextern long unsigned int      strtoul(const char *, char **, int);\nextern char *                 strtrns(const char *, const char *, const char *, char *);\nextern size_t                 strxfrm(char *, const char *, size_t);\nextern WINDOW *               subpad(WINDOW *, int, int, int, int);\nextern WINDOW *               subwin(WINDOW *, int, int, int, int);\nextern int                    svc_create(/* ??? */);\nextern SVCXPRT *              svc_fd_create(/* ??? */);\nextern void                   svc_getreqset(/* ??? */);\nextern SVCXPRT *              svc_raw_create(/* ??? */);\nextern int                    svc_reg(/* ??? */);\nextern SVCXPRT *              svc_tli_create(/* ??? */);\nextern SVCXPRT *              svc_tp_create(/* ??? */);\nextern void                   svc_unreg(/* ??? */);\nextern SVCXPRT *              svc_vc_create(/* ??? */);\nextern void                   svcerr_systemerr(/* ??? */);\nextern SVCXPRT *              svcfd_create(/* ??? */);\nextern SVCXPRT *              svcraw_create(/* ??? */);\nextern SVCXPRT *              svctcp_create(/* ??? */);\nextern SVCXPRT *              svcudp_bufcreate(/* ??? */);\nextern SVCXPRT *              svcudp_create(/* ??? */);\nextern void                   swab(const char *, char *, int);\nextern int                    swapcontext(ucontext_t *, ucontext_t *);\nextern int                    symlink(const char *, const char *);\nextern void                   sync(void);\nextern int                    syncok(WINDOW *, int);\nextern int                    syscall(int, ...);\nextern long int               sysconf(int);\nextern int                    sysfs(int, ...);\nextern int                    sysinfo(int, char *, long int);\nextern int                    system(const char *);\nextern char *                 taddr2uaddr(struct netconfig *, struct netbuf *);\nextern double                 tan(double);\nextern float                  tanf(float);\nextern double                 tanh(double);\nextern float                  tanhf(float);\nextern int                    tcdrain(int);\nextern int                    tcflow(int, int);\nextern int                    tcflush(int, int);\nextern int                    tcgetattr(int, struct termios *);\nextern pid_t                  tcgetpgrp(int);\nextern pid_t                  tcgetsid(int);\nextern int                    tcsendbreak(int, int);\nextern int                    tcsetattr(int, int, const struct termios *);\nextern int                    tcsetpgrp(int, pid_t);\nextern void *                 tdelete(const void *, void **, int (*) (const void *, const void *));\nextern long int               telldir(DIR *);\nextern char *                 tempnam(const char *, const char *);\nextern chtype                 termattrs(void);\nextern void                   termerr(void);\nextern char *                 termname(void);\nextern void *                 tfind(const void *, void *const *, int (*) (const void *, const void *));\nextern int                    tgetent(char *, char *);\nextern int                    tgetflag(char *);\nextern int                    tgetnum(char *);\nextern char *                 tgetstr(char *, char **);\nextern char *                 tgoto(char *, int, int);\nextern char *                 tigetstr(char *);\nextern time_t                 time(time_t *);\nextern clock_t                times(struct tms *);\nextern char *                 timezone(int, int);\nextern void                   tinputfd(int);\nextern FILE *                 tmpfile(void);\nextern char *                 tmpnam(char *);\nextern int                    toascii(int);\nextern int                    tolower(int);\nextern int                    top_panel(PANEL *);\nextern int                    top_row(MENU *);\nextern int                    touchline(WINDOW *, int, int);\nextern int                    touchwin(WINDOW *);\nextern int                    toupper(int);\nextern char *                 tparm(/* ??? */);\nextern int                    tputs(char *, int, int (*) (char));\nextern int                    traceoff(void);\nextern int                    traceon(void);\nextern int                    truncate(const char *, off_t);\nextern void *                 tsearch(const void *, void **, int (*) (const void *, const void *));\nextern char *                 ttyname(int);\nextern int                    ttyslot(void);\nextern void                   twalk(void *, void (*) (void *, VISIT, int));\nextern int                    typeahead(int);\nextern void                   tzset(void);\nextern struct netbuf *        uaddr2taddr(struct netconfig *, char *);\nextern int                    uadmin(int, int, int);\nextern unsigned               ualarm(unsigned, unsigned);\nextern int                    ulckpwdf(void);\nextern long int               ulimit(int, ...);\nextern mode_t                 umask(mode_t);\nextern int                    umount(const char *);\nextern int                    uname(struct utsname *);\nextern char *                 unctrl(int);\nextern void                   undial(int);\nextern int                    ungetc(int, FILE *);\nextern int                    ungetch(int);\nextern int                    unlink(const char *);\nextern int                    unordered(double, double);\nextern int                    unpost_form(FORM *);\nextern int                    unpost_menu(MENU *);\nextern int                    unremio(/* ??? */);\nextern int                    untouchwin(WINDOW *);\nextern void                   update_panels(void);\nextern void                   updwtmp(const char *, struct utmp *);\nextern void                   updwtmpx(const char *, struct utmpx *);\nextern void                   use_env(int);\nextern unsigned               usleep(unsigned);\nextern int                    ustat(dev_t, struct ustat *);\nextern int                    utime(const char *, const struct utimbuf *);\nextern int                    utmpname(const char *);\nextern int                    utmpxname(const char *);\nextern void                   va_end(__gnuc_va_list);\nextern int                    vadvise(int);\nextern void *                 valloc(size_t);\nextern pid_t                  vfork(void);\nextern int                    vfprintf(FILE *, const char *, __gnuc_va_list);\nextern int                    vhangup(void);\nextern int                    vid32attr(chtype);\nextern int                    vid32puts(chtype, int (*) (char));\nextern void                   vidupdate(chtype, chtype, int (*) (char));\nextern int                    vn_close(/* ??? */);\nextern int                    vprintf(const char *, __gnuc_va_list);\nextern int                    vsprintf(char *, const char *, __gnuc_va_list);\nextern int                    vwprintw(WINDOW *, char *, void *);\nextern int                    vwscanw(WINDOW *, char *, void *);\nextern int                    w32addch(WINDOW *, chtype);\nextern int                    w32attroff(WINDOW *, chtype);\nextern int                    w32attron(WINDOW *, chtype);\nextern int                    w32attrset(WINDOW *, chtype);\nextern int                    w32echochar(WINDOW *, chtype);\nextern int                    w32insch(WINDOW *, chtype);\nextern int                    waddchnstr(WINDOW *, chtype *, int);\nextern int                    waddnstr(WINDOW *, char *, int);\nextern int                    waddstr(WINDOW *, char *);\nextern pid_t                  wait(wait_arg_t *);\nextern pid_t                  wait3(union wait *, int, struct rusage *);\nextern int                    waitid(idtype_t, id_t, siginfo_t *, int);\nextern pid_t                  waitpid(pid_t, int *, int);\nextern void *                 wallproc_wall_1(/* ??? */);\nextern int                    wbkgd(WINDOW *, chtype);\nextern void                   wbkgdset(WINDOW *, chtype);\nextern int                    wborder(WINDOW *, chtype, chtype, chtype, chtype, chtype, chtype, chtype, chtype);\nextern int                    wclear(WINDOW *);\nextern int                    wclrtobot(WINDOW *);\nextern int                    wclrtoeol(WINDOW *);\nextern size_t                 wcstombs(char *, const wchar_t *, size_t);\nextern int                    wctomb(char *, wchar_t);\nextern void                   wcursyncup(WINDOW *);\nextern int                    wdelch(WINDOW *);\nextern int                    wdeleteln(WINDOW *);\nextern int                    werase(WINDOW *);\nextern int                    wgetch(WINDOW *);\nextern int                    wgetnstr(WINDOW *, char *, int);\nextern int                    wgetstr(WINDOW *, char *);\nextern int                    whline(WINDOW *, chtype, int);\nextern chtype                 winch(WINDOW *);\nextern int                    winchnstr(WINDOW *, chtype *, int);\nextern int                    winchstr(WINDOW *, chtype *);\nextern int                    winnstr(WINDOW *, char *, int);\nextern int                    winsdelln(WINDOW *, int);\nextern int                    winsertln(WINDOW *);\nextern int                    winsnstr(WINDOW *, char *, int);\nextern int                    winstr(WINDOW *, char *);\nextern int                    wisprint(wchar_t);\nextern void                   wmouse_position(WINDOW *, int *, int *);\nextern int                    wmove(WINDOW *, int, int);\nextern int                    wnoutrefresh(WINDOW *);\nextern int                    wprintw(WINDOW *, ...);\nextern int                    wredrawln(WINDOW *, int, int);\nextern int                    wrefresh(WINDOW *);\nextern ssize_t                write(int, const void *, size_t);\nextern int                    wscanw(WINDOW *, ...);\nextern int                    wscrl(WINDOW *, int);\nextern int                    wsetscrreg(WINDOW *, int, int);\nextern int                    wstandend(WINDOW *);\nextern int                    wstandout(WINDOW *);\nextern void                   wsyncdown(WINDOW *);\nextern void                   wsyncup(WINDOW *);\nextern void                   wtimeout(WINDOW *, int);\nextern int                    wtouchln(WINDOW *, int, int, int);\nextern int                    wvline(WINDOW *, chtype, int);\nextern bool                   xdr_datum(/* ??? */);\nextern int                    xdr_double(/* ??? */);\nextern int                    xdr_exports(/* ??? */);\nextern int                    xdr_fhstatus(/* ??? */);\nextern int                    xdr_float(/* ??? */);\nextern int                    xdr_keybuf(/* ??? */);\nextern int                    xdr_mountlist(/* ??? */);\nextern int                    xdr_netbuf(/* ??? */);\nextern int                    xdr_path(/* ??? */);\nextern int                    xdr_pmap(/* ??? */);\nextern int                    xdr_pmaplist(/* ??? */);\nextern int                    xdr_pointer(/* ??? */);\nextern int                    xdr_reference(/* ??? */);\nextern int                    xdr_rmtcall_args(/* ??? */);\nextern int                    xdr_rmtcallres(/* ??? */);\nextern int                    xdr_rpcb(/* ??? */);\nextern int                    xdr_rpcb_rmtcallargs(/* ??? */);\nextern int                    xdr_rpcb_rmtcallres(/* ??? */);\nextern int                    xdr_rpcblist(/* ??? */);\nextern int                    xdr_sprayarr(/* ??? */);\nextern int                    xdr_spraycumul(/* ??? */);\nextern int                    xdr_spraytimeval(/* ??? */);\nextern int                    xdr_u_char(/* ??? */);\nextern int                    xdr_utmparr(/* ??? */);\nextern int                    xdr_utmpidlearr(/* ??? */);\nextern int                    xdr_vector(/* ??? */);\nextern int                    xdr_yp_buf(/* ??? */);\nextern bool                   xdr_yp_inaddr(/* ??? */);\nextern bool                   xdr_ypall(/* ??? */);\nextern int                    xdr_ypdelete_args(/* ??? */);\nextern bool                   xdr_ypdomain_wrap_string(/* ??? */);\nextern bool                   xdr_ypmap_parms(/* ??? */);\nextern bool                   xdr_ypmap_wrap_string(/* ??? */);\nextern bool                   xdr_ypowner_wrap_string(/* ??? */);\nextern bool                   xdr_yppushresp_xfr(/* ??? */);\nextern bool                   xdr_ypreq_key(/* ??? */);\nextern bool                   xdr_ypreq_newxfr(/* ??? */);\nextern bool                   xdr_ypreq_nokey(/* ??? */);\nextern bool                   xdr_ypreq_xfr(/* ??? */);\nextern bool                   xdr_ypresp_key_val(/* ??? */);\nextern bool                   xdr_ypresp_maplist(/* ??? */);\nextern bool                   xdr_ypresp_master(/* ??? */);\nextern bool                   xdr_ypresp_order(/* ??? */);\nextern bool                   xdr_ypresp_val(/* ??? */);\nextern int                    xdr_ypupdate_args(/* ??? */);\nextern void                   xdrrec_create(/* ??? */);\nextern int                    xdrrec_endofrecord(/* ??? */);\nextern int                    xdrrec_eof(/* ??? */);\nextern int                    xdrrec_skiprecord(/* ??? */);\nextern void                   xdrstdio_create(/* ??? */);\nextern void                   xprt_register(/* ??? */);\nextern void                   xprt_unregister(/* ??? */);\nextern double                 y0(double);\nextern double                 y1(double);\nextern double                 yn(int, double);\nextern int                    yp_all(char *, char *, struct ypall_callback *);\nextern int                    yp_bind(const char *);\nextern int                    yp_first(char *, char *, char **, int *, char **, int *);\nextern int                    yp_get_default_domain(char **);\nextern int                    yp_master(char *, char *, char **);\nextern int                    yp_match(char *, char *, char *, int, char **, int *);\nextern int                    yp_next(char *, char *, char *, int, char **, int *, char **, int *);\nextern int                    yp_order(char *, char *, int *);\nextern void                   yp_unbind(const char *);\nextern char *                 yperr_string(int);\nextern int                    ypprot_err(unsigned int);\nextern u_int *                ypu_change_1(/* ??? */);\nextern u_int *                ypu_delete_1(/* ??? */);\nextern u_int *                ypu_insert_1(/* ??? */);\nextern u_int *                ypu_store_1(/* ??? */);\n",
        "/tmp/vanessa/spack-stage/spack-stage-gccxml-latest-w5xt6m3ulksz5ujtgruzzb6jkeam5q55/spack-src/GCC/gcc/config/darwin-crt3.c": "/* __cxa_atexit backwards-compatibility support for Darwin.\n   Copyright (C) 2006 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nIn addition to the permissions in the GNU General Public License, the\nFree Software Foundation gives you unlimited permission to link the\ncompiled version of this file into combinations with other programs,\nand to distribute those combinations without any restriction coming\nfrom the use of this file.  (The General Public License restrictions\ndo apply in other respects; for example, they cover modification of\nthe file, and distribution when not linked into a combine\nexecutable.)\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n02110-1301, USA.  */\n\n/* Don't do anything if we are compiling for a kext multilib. */\n#ifdef __PIC__\n\n/* It is incorrect to include config.h here, because this file is being\n   compiled for the target, and hence definitions concerning only the host\n   do not apply.  */\n\n#include \"tconfig.h\"\n#include \"tsystem.h\"\n\n#include <dlfcn.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <string.h>\n\n/* This file works around two different problems.\n\n   The first problem is that there is no __cxa_atexit on Mac OS versions\n   before 10.4.  It fixes this by providing a complete atexit and\n   __cxa_atexit emulation called from the regular atexit.\n\n   The second problem is that on all shipping versions of Mac OS,\n   __cxa_finalize and exit() don't work right: they don't run routines\n   that were registered while other atexit routines are running.  This\n   is worked around by wrapping each atexit/__cxa_atexit routine with\n   our own routine which ensures that any __cxa_atexit calls while it\n   is running are honoured.\n\n   There are still problems which this does not solve.  Before 10.4,\n   shared objects linked with previous compilers won't have their\n   atexit calls properly interleaved with code compiled with newer\n   compilers.  Also, atexit routines registered from shared objects\n   linked with previous compilers won't get the bug fix.  */\n\ntypedef int (*cxa_atexit_p)(void (*func) (void*), void* arg, const void* dso);\ntypedef void (*cxa_finalize_p)(const void *dso);\ntypedef int (*atexit_p)(void (*func)(void));\n\n/* These are from \"keymgr.h\".  */\nextern void *_keymgr_get_and_lock_processwide_ptr (unsigned key);\nextern int _keymgr_get_and_lock_processwide_ptr_2 (unsigned, void **);\nextern int _keymgr_set_and_unlock_processwide_ptr (unsigned key, void *ptr);\n\nextern void *__keymgr_global[];\ntypedef struct _Sinfo_Node {\n        unsigned int size ;             /*size of this node*/\n        unsigned short major_version ;  /*API major version.*/\n        unsigned short minor_version ;  /*API minor version.*/\n        } _Tinfo_Node ;\n\n#ifdef __ppc__\n#define CHECK_KEYMGR_ERROR(e) \\\n  (((_Tinfo_Node *)__keymgr_global[2])->major_version >= 4 ? (e) : 0)\n#else\n#define CHECK_KEYMGR_ERROR(e) (e)\n#endif\n\n/* Our globals are stored under this keymgr index.  */\n#define KEYMGR_ATEXIT_LIST\t14\n\n/* The different kinds of callback routines.  */\ntypedef void (*atexit_callback)(void);\ntypedef void (*cxa_atexit_callback)(void *);\n\n/* This structure holds a routine to call.  There may be extra fields\n   at the end of the structure that this code doesn't know about.  */\nstruct one_atexit_routine \n{\n  union {\n    atexit_callback ac;\n    cxa_atexit_callback cac;\n  } callback;\n  /* has_arg is 0/2/4 if 'ac' is live, 1/3/5 if 'cac' is live.  \n     Higher numbers indicate a later version of the structure that this\n     code doesn't understand and will ignore.  */\n  int has_arg;\n  void * arg;\n};\n\nstruct atexit_routine_list\n{\n  struct atexit_routine_list * next;\n  struct one_atexit_routine r;\n};\n\n/* The various possibilities for status of atexit().  */\nenum atexit_status {\n  atexit_status_unknown = 0,\n  atexit_status_missing = 1,\n  atexit_status_broken = 2,\n  atexit_status_working = 16\n};\n\nstruct keymgr_atexit_list\n{\n  /* Version of this list.  This code knows only about version 0.\n     If the version is higher than 0, this code may add new atexit routines\n     but should not attempt to run the list.  */\n  short version;\n  /* 1 if an atexit routine is currently being run by this code, 0\n     otherwise.  */\n  char running_routines;\n  /* Holds a value from 'enum atexit_status'.  */\n  unsigned char atexit_status;\n  /* The list of atexit and cxa_atexit routines registered.  If\n   atexit_status_missing it contains all routines registered while\n   linked with this code.  If atexit_status_broken it contains all\n   routines registered during cxa_finalize while linked with this\n   code.  */\n  struct atexit_routine_list *l;\n  /* &__cxa_atexit; set if atexit_status >= atexit_status_broken.  */\n  cxa_atexit_p cxa_atexit_f;\n  /* &__cxa_finalize; set if atexit_status >= atexit_status_broken.  */\n  cxa_finalize_p cxa_finalize_f;\n  /* &atexit; set if atexit_status >= atexit_status_working\n     or atexit_status == atexit_status_missing.  */\n  atexit_p atexit_f;\n};\n\n/* Return 0 if __cxa_atexit has the bug it has in Mac OS 10.4: it\n   fails to call routines registered while an atexit routine is\n   running.  Return 1 if it works properly, and -1 if an error occurred.  */\n\nstruct atexit_data \n{\n  int result;\n  cxa_atexit_p cxa_atexit;\n};\n\nstatic void cxa_atexit_check_2 (void *arg)\n{\n  ((struct atexit_data *)arg)->result = 1;\n}\n\nstatic void cxa_atexit_check_1 (void *arg)\n{\n  struct atexit_data * aed = arg;\n  if (aed->cxa_atexit (cxa_atexit_check_2, arg, arg) != 0)\n    aed->result = -1;\n}\n\nstatic int\ncheck_cxa_atexit (cxa_atexit_p cxa_atexit, cxa_finalize_p cxa_finalize)\n{\n  struct atexit_data aed = { 0, cxa_atexit };\n\n  /* We re-use &aed as the 'dso' parameter, since it's a unique address.  */\n  if (cxa_atexit (cxa_atexit_check_1, &aed, &aed) != 0)\n    return -1;\n  cxa_finalize (&aed);\n  if (aed.result == 0)\n    {\n      /* Call __cxa_finalize again to make sure that cxa_atexit_check_2\n\t is removed from the list before AED goes out of scope.  */\n      cxa_finalize (&aed);\n      aed.result = 0;\n    }\n  return aed.result;\n}\n\n#ifdef __ppc__\n/* This comes from Csu.  It works only before 10.4.  The prototype has\n   been altered a bit to avoid casting.  */\nextern int _dyld_func_lookup(const char *dyld_func_name,\n     void *address) __attribute__((visibility(\"hidden\")));\n\nstatic void our_atexit (void);\n\n/* We're running on 10.3.9.  Find the address of the system atexit()\n   function.  So easy to say, so hard to do.  */\nstatic atexit_p\nfind_atexit_10_3 (void)\n{\n  unsigned int (*dyld_image_count_fn)(void);\n  const char *(*dyld_get_image_name_fn)(unsigned int image_index);\n  const void *(*dyld_get_image_header_fn)(unsigned int image_index);\n  const void *(*NSLookupSymbolInImage_fn)(const void *image, \n\t\t\t\t\t  const char *symbolName,\n\t\t\t\t\t  unsigned int options);\n  void *(*NSAddressOfSymbol_fn)(const void *symbol);\n  unsigned i, count;\n  \n  /* Find some dyld functions.  */\n  _dyld_func_lookup(\"__dyld_image_count\", &dyld_image_count_fn);\n  _dyld_func_lookup(\"__dyld_get_image_name\", &dyld_get_image_name_fn);\n  _dyld_func_lookup(\"__dyld_get_image_header\", &dyld_get_image_header_fn);\n  _dyld_func_lookup(\"__dyld_NSLookupSymbolInImage\", &NSLookupSymbolInImage_fn);\n  _dyld_func_lookup(\"__dyld_NSAddressOfSymbol\", &NSAddressOfSymbol_fn);\n\n  /* If any of these don't exist, that's an error.  */\n  if (! dyld_image_count_fn || ! dyld_get_image_name_fn\n      || ! dyld_get_image_header_fn || ! NSLookupSymbolInImage_fn\n      || ! NSAddressOfSymbol_fn)\n    return NULL;\n  \n  count = dyld_image_count_fn ();\n  for (i = 0; i < count; i++)\n    {\n      const char * path = dyld_get_image_name_fn (i);\n      const void * image;\n      const void * symbol;\n      \n      if (strcmp (path, \"/usr/lib/libSystem.B.dylib\") != 0)\n\tcontinue;\n      image = dyld_get_image_header_fn (i);\n      if (! image)\n\treturn NULL;\n      /* '4' is NSLOOKUPSYMBOLINIMAGE_OPTION_RETURN_ON_ERROR.  */\n      symbol = NSLookupSymbolInImage_fn (image, \"_atexit\", 4);\n      if (! symbol)\n\treturn NULL;\n      return NSAddressOfSymbol_fn (symbol);\n    }\n  return NULL;\n}\n#endif\n\n/* Create (if necessary), find, lock, fill in, and return our globals.  \n   Return NULL on error, in which case the globals will not be locked.  \n   The caller should call keymgr_set_and_unlock.  */\nstatic struct keymgr_atexit_list *\nget_globals (void)\n{\n  struct keymgr_atexit_list * r;\n  \n#ifdef __ppc__\n  /* 10.3.9 doesn't have _keymgr_get_and_lock_processwide_ptr_2 so the\n     PPC side can't use it.  On 10.4 this just means the error gets\n     reported a little later when\n     _keymgr_set_and_unlock_processwide_ptr finds that the key was\n     never locked.  */\n  r = _keymgr_get_and_lock_processwide_ptr (KEYMGR_ATEXIT_LIST);\n#else\n  void * rr;\n  if (_keymgr_get_and_lock_processwide_ptr_2 (KEYMGR_ATEXIT_LIST, &rr))\n    return NULL;\n  r = rr;\n#endif\n  \n  if (r == NULL)\n    {\n      r = calloc (sizeof (struct keymgr_atexit_list), 1);\n      if (! r)\n\treturn NULL;\n    }\n\n  if (r->atexit_status == atexit_status_unknown)\n    {\n      void *handle;\n\n      handle = dlopen (\"/usr/lib/libSystem.B.dylib\", RTLD_NOLOAD);\n      if (!handle)\n\t{\n#ifdef __ppc__\n\t  r->atexit_status = atexit_status_missing;\n\t  r->atexit_f = find_atexit_10_3 ();\n\t  if (! r->atexit_f)\n\t    goto error;\n\t  if (r->atexit_f (our_atexit))\n\t    goto error;\n#else\n\t  goto error;\n#endif\n\t}\n      else\n\t{\n\t  int chk_result;\n\n\t  r->cxa_atexit_f = (cxa_atexit_p)dlsym (handle, \"__cxa_atexit\");\n\t  r->cxa_finalize_f = (cxa_finalize_p)dlsym (handle, \"__cxa_finalize\");\n\t  if (! r->cxa_atexit_f || ! r->cxa_finalize_f)\n\t    goto error;\n\n\t  chk_result = check_cxa_atexit (r->cxa_atexit_f, r->cxa_finalize_f);\n\t  if (chk_result == -1)\n\t    goto error;\n\t  else if (chk_result == 0)\n\t    r->atexit_status = atexit_status_broken;\n\t  else\n\t    {\n\t      r->atexit_f = (atexit_p)dlsym (handle, \"atexit\");\n\t      if (! r->atexit_f)\n\t\tgoto error;\n\t      r->atexit_status = atexit_status_working;\n\t    }\n\t}\n    }\n\n  return r;\n  \n error:\n  _keymgr_set_and_unlock_processwide_ptr (KEYMGR_ATEXIT_LIST, r);\n  return NULL;\n}\n\n/* Add TO_ADD to ATEXIT_LIST.  ATEXIT_LIST may be NULL but is\n   always the result of calling _keymgr_get_and_lock_processwide_ptr and\n   so KEYMGR_ATEXIT_LIST is known to be locked; this routine is responsible\n   for unlocking it.  */\n\nstatic int\nadd_routine (struct keymgr_atexit_list * g,\n\t     const struct one_atexit_routine * to_add)\n{\n  struct atexit_routine_list * s\n    = malloc (sizeof (struct atexit_routine_list));\n  int result;\n  \n  if (!s)\n    {\n      _keymgr_set_and_unlock_processwide_ptr (KEYMGR_ATEXIT_LIST, g);\n      return -1;\n    }\n  s->r = *to_add;\n  s->next = g->l;\n  g->l = s;\n  result = _keymgr_set_and_unlock_processwide_ptr (KEYMGR_ATEXIT_LIST, g);\n  return CHECK_KEYMGR_ERROR (result) == 0 ? 0 : -1;\n}\n\n/* This runs the routines in G->L up to STOP.  */\nstatic struct keymgr_atexit_list *\nrun_routines (struct keymgr_atexit_list *g,\n\t      struct atexit_routine_list *stop)\n{\n  for (;;)\n    {\n      struct atexit_routine_list * cur = g->l;\n      if (! cur || cur == stop)\n\tbreak;\n      g->l = cur->next;\n      _keymgr_set_and_unlock_processwide_ptr (KEYMGR_ATEXIT_LIST, g);\n\n      switch (cur->r.has_arg) {\n      case 0: case 2: case 4:\n\tcur->r.callback.ac ();\n\tbreak;\n      case 1: case 3: case 5:\n\tcur->r.callback.cac (cur->r.arg);\n\tbreak;\n      default:\n\t/* Don't understand, so don't call it.  */\n\tbreak;\n      }\n      free (cur);\n\n      g = _keymgr_get_and_lock_processwide_ptr (KEYMGR_ATEXIT_LIST);\n      if (! g)\n\tbreak;\n    }\n  return g;\n}\n\n/* Call the routine described by ROUTINE_PARAM and then call any\n   routines added to KEYMGR_ATEXIT_LIST while that routine was\n   running, all with in_cxa_finalize set.  */\n\nstatic void\ncxa_atexit_wrapper (void* routine_param)\n{\n  struct one_atexit_routine * routine = routine_param;\n  struct keymgr_atexit_list *g;\n  struct atexit_routine_list * base = NULL;\n  char prev_running = 0;\n  \n  g = _keymgr_get_and_lock_processwide_ptr (KEYMGR_ATEXIT_LIST);\n  if (g)\n    {\n      prev_running = g->running_routines;\n      g->running_routines = 1;\n      base = g->l;\n      _keymgr_set_and_unlock_processwide_ptr (KEYMGR_ATEXIT_LIST, g);\n    }\n\n  if (routine->has_arg)\n    routine->callback.cac (routine->arg);\n  else\n    routine->callback.ac ();\n\n  if (g)\n    g = _keymgr_get_and_lock_processwide_ptr (KEYMGR_ATEXIT_LIST);\n  if (g)\n    g = run_routines (g, base);\n  if (g)\n    {\n      g->running_routines = prev_running;\n      _keymgr_set_and_unlock_processwide_ptr (KEYMGR_ATEXIT_LIST, g);\n    }\n}\n\n#ifdef __ppc__\n/* This code is used while running on 10.3.9, when __cxa_atexit doesn't\n   exist in the system library.  10.3.9 only supported regular PowerPC,\n   so this code isn't necessary on x86 or ppc64.  */\n\n/* This routine is called from the system atexit(); it runs everything\n   registered on the KEYMGR_ATEXIT_LIST.  */\n\nstatic void\nour_atexit (void)\n{\n  struct keymgr_atexit_list *g;\n  char prev_running;\n\n  g = _keymgr_get_and_lock_processwide_ptr (KEYMGR_ATEXIT_LIST);\n  if (! g || g->version != 0 || g->atexit_status != atexit_status_missing)\n    return;\n  \n  prev_running = g->running_routines;\n  g->running_routines = 1;\n  g = run_routines (g, NULL);\n  if (! g)\n    return;\n  g->running_routines = prev_running;\n  _keymgr_set_and_unlock_processwide_ptr (KEYMGR_ATEXIT_LIST, g);\n}\n#endif\n\n/* This is our wrapper around atexit and __cxa_atexit.  It will return\n   nonzero if an error occurs, and otherwise:\n   - if in_cxa_finalize is set, or running on 10.3.9, add R to\n     KEYMGR_ATEXIT_LIST; or\n   - call the system __cxa_atexit to add cxa_atexit_wrapper with an argument\n     that indicates how cxa_atexit_wrapper should call R.  */\n\nstatic int\natexit_common (const struct one_atexit_routine *r, const void *dso)\n{\n  struct keymgr_atexit_list *g = get_globals ();\n\n  if (! g)\n    return -1;\n  \n  if (g->running_routines || g->atexit_status == atexit_status_missing)\n    return add_routine (g, r);\n\n  if (g->atexit_status >= atexit_status_working)\n    {\n      int result;\n      if (r->has_arg)\n\t{\n\t  cxa_atexit_p cxa_atexit = g->cxa_atexit_f;\n\t  result = _keymgr_set_and_unlock_processwide_ptr (KEYMGR_ATEXIT_LIST,\n\t\t\t\t\t\t\t   g);\n\t  if (CHECK_KEYMGR_ERROR (result))\n\t    return -1;\n\t  return cxa_atexit (r->callback.cac, r->arg, dso);\n\t}\n      else\n\t{\n\t  atexit_p atexit_f = g->atexit_f;\n\t  result = _keymgr_set_and_unlock_processwide_ptr (KEYMGR_ATEXIT_LIST,\n\t\t\t\t\t\t\t   g);\n\t  if (CHECK_KEYMGR_ERROR (result))\n\t    return -1;\n\t  return atexit_f (r->callback.ac);\n\t}\n    }\n  else\n    {\n      cxa_atexit_p cxa_atexit = g->cxa_atexit_f;\n      struct one_atexit_routine *alloced;\n      int result;\n\n      result = _keymgr_set_and_unlock_processwide_ptr (KEYMGR_ATEXIT_LIST, g);\n      if (CHECK_KEYMGR_ERROR (result))\n\treturn -1;\n\n      alloced = malloc (sizeof (struct one_atexit_routine));\n      if (! alloced)\n\treturn -1;\n      *alloced = *r;\n      return cxa_atexit (cxa_atexit_wrapper, alloced, dso);\n    }\n}\n\n/* These are the actual replacement routines; they just funnel into\n   atexit_common.  */\n\nint __cxa_atexit (cxa_atexit_callback func, void* arg, \n\t\t  const void* dso) __attribute__((visibility(\"hidden\")));\n\nint\n__cxa_atexit (cxa_atexit_callback func, void* arg, const void* dso)\n{\n  struct one_atexit_routine r;\n  r.callback.cac = func;\n  r.has_arg = 1;\n  r.arg = arg;\n  return atexit_common (&r, dso);\n}\n\nint atexit (atexit_callback func) __attribute__((visibility(\"hidden\")));\n\n/* Use __dso_handle to allow even bundles that call atexit() to be unloaded\n   on 10.4.  */\nextern void __dso_handle;\n\nint\natexit (atexit_callback func)\n{\n  struct one_atexit_routine r;\n  r.callback.ac = func;\n  r.has_arg = 0;\n  return atexit_common (&r, &__dso_handle);\n}\n\n#endif /* __PIC__ */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gccxml-latest-w5xt6m3ulksz5ujtgruzzb6jkeam5q55/spack-src/GCC_XML/KWSys/DynamicLoader.cxx": "/*============================================================================\n  KWSys - Kitware System Library\n  Copyright 2000-2009 Kitware, Inc., Insight Software Consortium\n\n  Distributed under the OSI-approved BSD License (the \"License\");\n  see accompanying file Copyright.txt for details.\n\n  This software is distributed WITHOUT ANY WARRANTY; without even the\n  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n  See the License for more information.\n============================================================================*/\n#include \"kwsysPrivate.h\"\n#include KWSYS_HEADER(DynamicLoader.hxx)\n\n#include KWSYS_HEADER(Configure.hxx)\n\n// Work-around CMake dependency scanning limitation.  This must\n// duplicate the above list of headers.\n#if 0\n# include \"DynamicLoader.hxx.in\"\n# include \"Configure.hxx.in\"\n#endif\n\n// This file is actually 3 different implementations.\n// 1. HP machines which uses shl_load\n// 2. Mac OS X 10.2.x and earlier which uses NSLinkModule\n// 3. Windows which uses LoadLibrary\n// 4. Most unix systems (including Mac OS X 10.3 and later) which use dlopen\n// (default) Each part of the ifdef contains a complete implementation for\n// the static methods of DynamicLoader.\n\n// ---------------------------------------------------------------\n// 1. Implementation for HPUX  machines\n#ifdef __hpux\n#include <errno.h>\n#include <dl.h>\n#define DYNAMICLOADER_DEFINED 1\n\nnamespace KWSYS_NAMESPACE\n{\n\n//----------------------------------------------------------------------------\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(const char* libname )\n{\n  return shl_load(libname, BIND_DEFERRED | DYNAMIC_PATH, 0L);\n}\n\n//----------------------------------------------------------------------------\nint DynamicLoader::CloseLibrary(DynamicLoader::LibraryHandle lib)\n{\n  return !shl_unload(lib);\n}\n\n//----------------------------------------------------------------------------\nDynamicLoader::SymbolPointer\nDynamicLoader::GetSymbolAddress(DynamicLoader::LibraryHandle lib, const char* sym)\n{\n  void* addr;\n  int status;\n\n  /* TYPE_PROCEDURE Look for a function or procedure. (This used to be default)\n   * TYPE_DATA      Look for a symbol in the data segment (for example, variables).\n   * TYPE_UNDEFINED Look for any symbol.\n   */\n  status = shl_findsym (&lib, sym, TYPE_UNDEFINED, &addr);\n  void* result = (status < 0) ? (void*)0 : addr;\n\n  // Hack to cast pointer-to-data to pointer-to-function.\n  return *reinterpret_cast<DynamicLoader::SymbolPointer*>(&result);\n}\n\nconst char* DynamicLoader::LastError()\n{\n  // TODO: Need implementation with errno/strerror\n  /* If successful, shl_findsym returns an integer (int) value zero. If\n   * shl_findsym cannot find sym, it returns -1 and sets errno to zero.\n   * If any other errors occur, shl_findsym returns -1 and sets errno to one\n   * of these values (defined in <errno.h>):\n   * ENOEXEC\n   * A format error was detected in the specified library.\n   * ENOSYM\n   * A symbol on which sym depends could not be found.\n   * EINVAL\n   * The specified handle is invalid.\n   */\n\n  if(  errno == ENOEXEC\n    || errno == ENOSYM\n    || errno == EINVAL )\n    {\n    return strerror(errno);\n    }\n  // else\n  return 0;\n}\n\n} // namespace KWSYS_NAMESPACE\n\n#endif //__hpux\n\n\n// ---------------------------------------------------------------\n// 2. Implementation for Mac OS X 10.2.x and earlier\n#ifdef __APPLE__\n#if MAC_OS_X_VERSION_MAX_ALLOWED < 1030\n#include <string.h> // for strlen\n#include <mach-o/dyld.h>\n#define DYNAMICLOADER_DEFINED 1\n\nnamespace KWSYS_NAMESPACE\n{\n\n//----------------------------------------------------------------------------\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(const char* libname )\n{\n  NSObjectFileImageReturnCode rc;\n  NSObjectFileImage image = 0;\n\n  rc = NSCreateObjectFileImageFromFile(libname, &image);\n  // rc == NSObjectFileImageInappropriateFile when trying to load a dylib file\n  if( rc != NSObjectFileImageSuccess )\n    {\n    return 0;\n    }\n  NSModule handle = NSLinkModule(image, libname,\n    NSLINKMODULE_OPTION_BINDNOW|NSLINKMODULE_OPTION_RETURN_ON_ERROR);\n  NSDestroyObjectFileImage(image);\n  return handle;\n}\n\n//----------------------------------------------------------------------------\nint DynamicLoader::CloseLibrary( DynamicLoader::LibraryHandle lib)\n{\n  // NSUNLINKMODULE_OPTION_KEEP_MEMORY_MAPPED\n  // With  this  option  the memory for the module is not deallocated\n  // allowing pointers into the module to still be valid.\n  // You should use this option instead if your code experience some problems\n  // reported against Panther 10.3.9 (fixed in Tiger 10.4.2 and up)\n  bool success = NSUnLinkModule(lib, NSUNLINKMODULE_OPTION_NONE);\n  return success;\n}\n\n//----------------------------------------------------------------------------\nDynamicLoader::SymbolPointer DynamicLoader::GetSymbolAddress(\n  DynamicLoader::LibraryHandle lib, const char* sym)\n{\n  void *result=0;\n  // Need to prepend symbols with '_' on Apple-gcc compilers\n  size_t len = strlen(sym);\n  char *rsym = new char[len + 1 + 1];\n  strcpy(rsym, \"_\");\n  strcat(rsym+1, sym);\n\n  NSSymbol symbol = NSLookupSymbolInModule(lib, rsym);\n  if(symbol)\n    {\n    result = NSAddressOfSymbol(symbol);\n    }\n\n  delete[] rsym;\n  // Hack to cast pointer-to-data to pointer-to-function.\n  return *reinterpret_cast<DynamicLoader::SymbolPointer*>(&result);\n}\n\n//----------------------------------------------------------------------------\nconst char* DynamicLoader::LastError()\n{\n  return 0;\n}\n\n} // namespace KWSYS_NAMESPACE\n\n#endif // MAC_OS_X_VERSION_MAX_ALLOWED < 1030\n#endif // __APPLE__\n\n// ---------------------------------------------------------------\n// 3. Implementation for Windows win32 code but not cygwin\n#if defined(_WIN32) && !defined(__CYGWIN__)\n#include <windows.h>\n#define DYNAMICLOADER_DEFINED 1\n\nnamespace KWSYS_NAMESPACE\n{\n\n//----------------------------------------------------------------------------\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(const char* libname)\n{\n  DynamicLoader::LibraryHandle lh;\n#ifdef UNICODE\n  wchar_t libn[MB_CUR_MAX];\n  mbstowcs(libn, libname, MB_CUR_MAX);\n  lh = LoadLibrary(libn);\n#else\n  lh = LoadLibrary(libname);\n#endif\n  return lh;\n}\n\n//----------------------------------------------------------------------------\nint DynamicLoader::CloseLibrary(DynamicLoader::LibraryHandle lib)\n{\n  return (int)FreeLibrary(lib);\n}\n\n//----------------------------------------------------------------------------\nDynamicLoader::SymbolPointer DynamicLoader::GetSymbolAddress(\n  DynamicLoader::LibraryHandle lib, const char* sym)\n{\n  // TODO: The calling convention affects the name of the symbol.  We\n  // should have a tool to help get the symbol with the desired\n  // calling convention.  Currently we assume cdecl.\n  //\n  // Borland:\n  //   __cdecl    = \"_func\" (default)\n  //   __fastcall = \"@_func\"\n  //   __stdcall  = \"func\"\n  //\n  // Watcom:\n  //   __cdecl    = \"_func\"\n  //   __fastcall = \"@_func@X\"\n  //   __stdcall  = \"_func@X\"\n  //   __watcall  = \"func_\" (default)\n  //\n  // MSVC:\n  //   __cdecl    = \"func\" (default)\n  //   __fastcall = \"@_func@X\"\n  //   __stdcall  = \"_func@X\"\n  //\n  // Note that the \"@X\" part of the name above is the total size (in\n  // bytes) of the arguments on the stack.\n  void *result;\n#if defined(__BORLANDC__) || defined(__WATCOMC__)\n  // Need to prepend symbols with '_'\n  size_t len = strlen(sym);\n  char *rsym = new char[len + 1 + 1];\n  strcpy(rsym, \"_\");\n  strcat(rsym, sym);\n#else\n  const char *rsym = sym;\n#endif\n#ifdef UNICODE\n  wchar_t wsym[MB_CUR_MAX];\n  mbstowcs(wsym, rsym, MB_CUR_MAX);\n  result = GetProcAddress(lib, wsym);\n#else\n  result = (void*)GetProcAddress(lib, rsym);\n#endif\n#if defined(__BORLANDC__) || defined(__WATCOMC__)\n  delete[] rsym;\n#endif\n  // Hack to cast pointer-to-data to pointer-to-function.\n#ifdef __WATCOMC__\n  return *(DynamicLoader::SymbolPointer*)(&result);\n#else\n  return *reinterpret_cast<DynamicLoader::SymbolPointer*>(&result);\n#endif\n}\n\n//----------------------------------------------------------------------------\nconst char* DynamicLoader::LastError()\n{\n  LPVOID lpMsgBuf=NULL;\n\n  FormatMessage(\n    FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,\n    NULL,\n    GetLastError(),\n    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language\n    (LPTSTR) &lpMsgBuf,\n    0,\n    NULL\n    );\n\n  if(!lpMsgBuf)\n    {\n    return NULL;\n    }\n\n  static char* str = 0;\n  delete [] str;\n  str = strcpy(new char[strlen((char*)lpMsgBuf)+1], (char*)lpMsgBuf);\n  // Free the buffer.\n  LocalFree( lpMsgBuf );\n  return str;\n}\n\n} // namespace KWSYS_NAMESPACE\n\n#endif //_WIN32\n\n// ---------------------------------------------------------------\n// 4. Implementation for BeOS\n#if defined __BEOS__\n\n#include <string.h> // for strerror()\n\n#include <be/kernel/image.h>\n#include <be/support/Errors.h>\n\n#define DYNAMICLOADER_DEFINED 1\n\nnamespace KWSYS_NAMESPACE\n{\n\nstatic image_id last_dynamic_err = B_OK;\n\n//----------------------------------------------------------------------------\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(const char* libname )\n{\n  // image_id's are integers, errors are negative. Add one just in case we\n  //  get a valid image_id of zero (is that even possible?).\n  image_id rc = load_add_on(libname);\n  if (rc < 0)\n    {\n    last_dynamic_err = rc;\n    return 0;\n    }\n\n  return rc+1;\n}\n\n//----------------------------------------------------------------------------\nint DynamicLoader::CloseLibrary(DynamicLoader::LibraryHandle lib)\n{\n  if (!lib)\n    {\n      last_dynamic_err = B_BAD_VALUE;\n      return 0;\n    }\n  else\n    {\n    // The function dlclose() returns 0 on success, and non-zero on error.\n    status_t rc = unload_add_on(lib-1);\n    if (rc != B_OK)\n      {\n      last_dynamic_err = rc;\n      return 0;\n      }\n    }\n\n  return 1;\n}\n\n//----------------------------------------------------------------------------\nDynamicLoader::SymbolPointer DynamicLoader::GetSymbolAddress(\n  DynamicLoader::LibraryHandle lib, const char* sym)\n{\n  // Hack to cast pointer-to-data to pointer-to-function.\n  union \n  {\n    void* pvoid;\n    DynamicLoader::SymbolPointer psym;\n  } result;\n\n  result.psym = NULL;\n\n  if (!lib)\n    {\n      last_dynamic_err = B_BAD_VALUE;\n    }\n  else\n    {\n    // !!! FIXME: BeOS can do function-only lookups...does this ever\n    // !!! FIXME:  actually _want_ a data symbol lookup, or was this union\n    // !!! FIXME:  a leftover of dlsym()? (s/ANY/TEXT for functions only).\n    status_t rc = get_image_symbol(lib-1,sym,B_SYMBOL_TYPE_ANY,&result.pvoid);\n    if (rc != B_OK)\n      {\n      last_dynamic_err = rc;\n      result.psym = NULL;\n      }\n    }\n  return result.psym;\n}\n\n//----------------------------------------------------------------------------\nconst char* DynamicLoader::LastError()\n{\n  const char *retval = strerror(last_dynamic_err);\n  last_dynamic_err = B_OK;\n  return retval;\n}\n\n} // namespace KWSYS_NAMESPACE\n#endif\n\n// ---------------------------------------------------------------\n// 5. Implementation for systems without dynamic libs\n// __gnu_blrts__ is IBM BlueGene/L\n// __LIBCATAMOUNT__ is defined on Catamount on Cray compute nodes\n#if defined(__gnu_blrts__) || defined(__LIBCATAMOUNT__) || defined(__CRAYXT_COMPUTE_LINUX_TARGET)\n#include <string.h> // for strerror()\n#define DYNAMICLOADER_DEFINED 1\n\nnamespace KWSYS_NAMESPACE\n{\n\n//----------------------------------------------------------------------------\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(const char* libname )\n{\n  return 0;\n}\n\n//----------------------------------------------------------------------------\nint DynamicLoader::CloseLibrary(DynamicLoader::LibraryHandle lib)\n{\n  if (!lib)\n    {\n    return 0;\n    }\n\n  return 1;\n}\n\n//----------------------------------------------------------------------------\nDynamicLoader::SymbolPointer DynamicLoader::GetSymbolAddress(\n    DynamicLoader::LibraryHandle lib, const char* sym)\n{\n  return 0;\n}\n\n//----------------------------------------------------------------------------\nconst char* DynamicLoader::LastError()\n  {\n  return \"General error\";\n  }\n\n} // namespace KWSYS_NAMESPACE\n#endif\n\n// ---------------------------------------------------------------\n// 6. Implementation for default UNIX machines.\n// if nothing has been defined then use this\n#ifndef DYNAMICLOADER_DEFINED\n#define DYNAMICLOADER_DEFINED 1\n// Setup for most unix machines\n#include <dlfcn.h>\n\nnamespace KWSYS_NAMESPACE\n{\n\n//----------------------------------------------------------------------------\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(const char* libname )\n{\n  return dlopen(libname, RTLD_LAZY);\n}\n\n//----------------------------------------------------------------------------\nint DynamicLoader::CloseLibrary(DynamicLoader::LibraryHandle lib)\n{\n  if (lib)\n    {\n    // The function dlclose() returns 0 on success, and non-zero on error.\n    return !dlclose(lib);\n    }\n  // else\n  return 0;\n}\n\n//----------------------------------------------------------------------------\nDynamicLoader::SymbolPointer DynamicLoader::GetSymbolAddress(\n  DynamicLoader::LibraryHandle lib, const char* sym)\n{\n  // Hack to cast pointer-to-data to pointer-to-function.\n  union \n  {\n    void* pvoid;\n    DynamicLoader::SymbolPointer psym;\n  } result;\n  result.pvoid = dlsym(lib, sym);\n  return result.psym;\n}\n\n//----------------------------------------------------------------------------\nconst char* DynamicLoader::LastError()\n{\n  return dlerror();\n}\n\n} // namespace KWSYS_NAMESPACE\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-gccxml-latest-w5xt6m3ulksz5ujtgruzzb6jkeam5q55/spack-src/GCC_XML/KWSys/DynamicLoader.hxx.in": "/*============================================================================\n  KWSys - Kitware System Library\n  Copyright 2000-2009 Kitware, Inc., Insight Software Consortium\n\n  Distributed under the OSI-approved BSD License (the \"License\");\n  see accompanying file Copyright.txt for details.\n\n  This software is distributed WITHOUT ANY WARRANTY; without even the\n  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n  See the License for more information.\n============================================================================*/\n#ifndef @KWSYS_NAMESPACE@_DynamicLoader_hxx\n#define @KWSYS_NAMESPACE@_DynamicLoader_hxx\n\n#include <@KWSYS_NAMESPACE@/Configure.h>\n\n#if defined(__hpux)\n  #include <dl.h>\n#elif defined(_WIN32) && !defined(__CYGWIN__)\n  #include <windows.h>\n#elif defined(__APPLE__)\n  #include <AvailabilityMacros.h>\n  #if MAC_OS_X_VERSION_MAX_ALLOWED < 1030\n    #include <mach-o/dyld.h>\n  #endif\n#elif defined(__BEOS__)\n  #include <be/kernel/image.h>\n#endif\n\nnamespace @KWSYS_NAMESPACE@\n{\n/** \\class DynamicLoader\n * \\brief Portable loading of dynamic libraries or dll's.\n *\n * DynamicLoader provides a portable interface to loading dynamic\n * libraries or dll's into a process.\n *\n * Directory currently works with Windows, Apple, HP-UX and Unix (POSIX)\n * operating systems\n *\n * \\warning dlopen on *nix system works the following way:\n * If filename contains a slash (\"/\"), then it is interpreted as a (relative\n * or absolute) pathname.  Otherwise, the dynamic linker searches for the\n * library as follows : see ld.so(8) for further details):\n * Whereas this distinction does not exist on Win32. Therefore ideally you\n * should be doing full path to garantee to have a consistent way of dealing\n * with dynamic loading of shared library.\n *\n * \\warning the Cygwin implementation do not use the Win32 HMODULE. Put extra\n * condition so that we can include the correct declaration (POSIX)\n */\n\nclass @KWSYS_NAMESPACE@_EXPORT DynamicLoader\n{\npublic:\n// Ugly stuff for library handles\n// They are different on several different OS's\n#if defined(__hpux)\n  typedef shl_t LibraryHandle;\n#elif defined(_WIN32) && !defined(__CYGWIN__)\n  typedef HMODULE LibraryHandle;\n#elif defined(__APPLE__)\n  #if MAC_OS_X_VERSION_MAX_ALLOWED < 1030\n    typedef NSModule LibraryHandle;\n  #else\n    typedef void* LibraryHandle;\n  #endif\n#elif defined(__BEOS__)\n  typedef image_id LibraryHandle;\n#else  // POSIX\n  typedef void* LibraryHandle;\n#endif\n\n  // Return type from DynamicLoader::GetSymbolAddress.\n  typedef void (*SymbolPointer)();\n\n  /** Load a dynamic library into the current process.\n   * The returned LibraryHandle can be used to access the symbols in the\n   * library. */\n  static LibraryHandle OpenLibrary(const char*);\n\n  /** Attempt to detach a dynamic library from the\n   * process.  A value of true is returned if it is sucessful. */\n  static int CloseLibrary(LibraryHandle);\n\n  /** Find the address of the symbol in the given library. */\n  static SymbolPointer GetSymbolAddress(LibraryHandle, const char*);\n\n  /** Return the default module prefix for the current platform.  */\n  static const char* LibPrefix() { return \"@KWSYS_DynamicLoader_PREFIX@\"; }\n\n  /** Return the default module suffix for the current platform.  */\n  static const char* LibExtension() { return \"@KWSYS_DynamicLoader_SUFFIX@\"; }\n\n  /** Return the last error produced from a calls made on this class. */\n  static const char* LastError();\n}; // End Class: DynamicLoader\n\n} // namespace @KWSYS_NAMESPACE@\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-gccxml-latest-w5xt6m3ulksz5ujtgruzzb6jkeam5q55/spack-src/GCC_XML/KWSys/testDynamicLoader.cxx": "/*============================================================================\n  KWSys - Kitware System Library\n  Copyright 2000-2009 Kitware, Inc., Insight Software Consortium\n\n  Distributed under the OSI-approved BSD License (the \"License\");\n  see accompanying file Copyright.txt for details.\n\n  This software is distributed WITHOUT ANY WARRANTY; without even the\n  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n  See the License for more information.\n============================================================================*/\n#include \"kwsysPrivate.h\"\n\n#include KWSYS_HEADER(DynamicLoader.hxx)\n#include KWSYS_HEADER(ios/iostream)\n#include KWSYS_HEADER(stl/string)\n\n#if defined(__BEOS__) && !defined(__HAIKU__)\n#include <be/kernel/OS.h>  /* disable_debugger() API. */\n#endif\n\n#if defined(__HAIKU__)\n#include <os/kernel/OS.h>  /* disable_debugger() API. */\n#endif\n\n// Work-around CMake dependency scanning limitation.  This must\n// duplicate the above list of headers.\n#if 0\n# include \"DynamicLoader.hxx.in\"\n# include \"kwsys_ios_iostream.h.in\"\n# include \"kwsys_stl_string.hxx.in\"\n#endif\n\n// Include with <> instead of \"\" to avoid getting any in-source copy\n// left on disk.\n#include <testSystemTools.h>\n\nkwsys_stl::string GetLibName(const char* lname)\n{\n  // Construct proper name of lib\n  kwsys_stl::string slname;\n  slname = EXECUTABLE_OUTPUT_PATH;\n#ifdef CMAKE_INTDIR\n  slname += \"/\";\n  slname += CMAKE_INTDIR;\n#endif\n  slname += \"/\";\n  slname += kwsys::DynamicLoader::LibPrefix();\n  slname += lname;\n  slname += kwsys::DynamicLoader::LibExtension();\n\n  return slname;\n}\n\n/* libname = Library name (proper prefix, proper extension)\n * System  = symbol to lookup in libname\n * r1: should OpenLibrary succeed ?\n * r2: should GetSymbolAddress succeed ?\n * r3: should CloseLibrary succeed ?\n */\nint TestDynamicLoader(const char* libname, const char* symbol, int r1, int r2, int r3)\n{\n  kwsys_ios::cerr << \"Testing: \" << libname << kwsys_ios::endl;\n  kwsys::DynamicLoader::LibraryHandle l\n    = kwsys::DynamicLoader::OpenLibrary(libname);\n  // If result is incompatible with expectation just fails (xor):\n  if( (r1 && !l) || (!r1 && l) )\n    {\n    kwsys_ios::cerr\n      << kwsys::DynamicLoader::LastError() << kwsys_ios::endl;\n    return 1;\n    }\n  kwsys::DynamicLoader::SymbolPointer f\n    = kwsys::DynamicLoader::GetSymbolAddress(l, symbol);\n  if( (r2 && !f) || (!r2 && f) )\n    {\n    kwsys_ios::cerr\n      << kwsys::DynamicLoader::LastError() << kwsys_ios::endl;\n    return 1;\n    }\n#ifndef __APPLE__\n  int s = kwsys::DynamicLoader::CloseLibrary(l);\n  if( (r3 && !s) || (!r3 && s) )\n    {\n    kwsys_ios::cerr\n      << kwsys::DynamicLoader::LastError() << kwsys_ios::endl;\n    return 1;\n    }\n#else\n  (void)r3;\n#endif\n  return 0;\n}\n\nint testDynamicLoader(int argc, char *argv[])\n{\n#if defined(_WIN32)\n  SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOGPFAULTERRORBOX);\n#elif defined(__BEOS__) || defined(__HAIKU__)\n  disable_debugger(1);\n#endif\n  int res = 0;\n  if( argc == 3 )\n    {\n    // User specify a libname and symbol to check.\n    res = TestDynamicLoader(argv[1], argv[2],1,1,1);\n    return res;\n    }\n\n// dlopen() on Syllable before 11/22/2007 doesn't return 0 on error\n#ifndef __SYLLABLE__\n  // Make sure that inexistant lib is giving correct result\n  res += TestDynamicLoader(\"azerty_\", \"foo_bar\",0,0,0);\n  // Make sure that random binary file cannnot be assimilated as dylib\n  res += TestDynamicLoader(TEST_SYSTEMTOOLS_BIN_FILE, \"wp\",0,0,0);\n#endif\n\n#ifdef __linux__\n  // This one is actually fun to test, since dlopen is by default loaded...wonder why :)\n  res += TestDynamicLoader(\"foobar.lib\", \"dlopen\",0,1,0);\n  res += TestDynamicLoader(\"libdl.so\", \"dlopen\",1,1,1);\n  res += TestDynamicLoader(\"libdl.so\", \"TestDynamicLoader\",1,0,1);\n#endif\n  // Now try on the generated library\n  kwsys_stl::string libname = GetLibName(KWSYS_NAMESPACE_STRING \"TestDynload\");\n  res += TestDynamicLoader(libname.c_str(), \"dummy\",1,0,1);\n  res += TestDynamicLoader(libname.c_str(), \"TestDynamicLoaderSymbolPointer\",1,1,1);\n  res += TestDynamicLoader(libname.c_str(), \"_TestDynamicLoaderSymbolPointer\",1,0,1);\n  res += TestDynamicLoader(libname.c_str(), \"TestDynamicLoaderData\",1,1,1);\n  res += TestDynamicLoader(libname.c_str(), \"_TestDynamicLoaderData\",1,0,1);\n\n  return res;\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-gccxml-latest-w5xt6m3ulksz5ujtgruzzb6jkeam5q55/spack-src/.git/objects/pack/pack-a9c47d22ff6c09a20e570c8cce33c4374463aad2.pack",
        "/tmp/vanessa/spack-stage/spack-stage-gccxml-latest-w5xt6m3ulksz5ujtgruzzb6jkeam5q55/spack-src/.git/objects/pack/pack-a9c47d22ff6c09a20e570c8cce33c4374463aad2.idx",
        "/tmp/vanessa/spack-stage/spack-stage-gccxml-latest-w5xt6m3ulksz5ujtgruzzb6jkeam5q55/spack-src/GCC/gcc/config/sh/coff.h",
        "/tmp/vanessa/spack-stage/spack-stage-gccxml-latest-w5xt6m3ulksz5ujtgruzzb6jkeam5q55/spack-src/GCC/libcpp/po/el.po",
        "/tmp/vanessa/spack-stage/spack-stage-gccxml-latest-w5xt6m3ulksz5ujtgruzzb6jkeam5q55/spack-src/GCC/libcpp/po/es.po",
        "/tmp/vanessa/spack-stage/spack-stage-gccxml-latest-w5xt6m3ulksz5ujtgruzzb6jkeam5q55/spack-src/GCC/libcpp/po/sv.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gccxml-latest-w5xt6m3ulksz5ujtgruzzb6jkeam5q55/spack-src/GCC/libcpp/po/ca.po",
        "/tmp/vanessa/spack-stage/spack-stage-gccxml-latest-w5xt6m3ulksz5ujtgruzzb6jkeam5q55/spack-src/GCC/libcpp/po/sv.po",
        "/tmp/vanessa/spack-stage/spack-stage-gccxml-latest-w5xt6m3ulksz5ujtgruzzb6jkeam5q55/spack-src/GCC/libcpp/po/rw.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gccxml-latest-w5xt6m3ulksz5ujtgruzzb6jkeam5q55/spack-src/GCC/libcpp/po/ja.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gccxml-latest-w5xt6m3ulksz5ujtgruzzb6jkeam5q55/spack-src/GCC/libcpp/po/fr.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gccxml-latest-w5xt6m3ulksz5ujtgruzzb6jkeam5q55/spack-src/GCC/libcpp/po/de.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gccxml-latest-w5xt6m3ulksz5ujtgruzzb6jkeam5q55/spack-src/GCC/libcpp/po/be.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gccxml-latest-w5xt6m3ulksz5ujtgruzzb6jkeam5q55/spack-src/GCC/libcpp/po/nl.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gccxml-latest-w5xt6m3ulksz5ujtgruzzb6jkeam5q55/spack-src/GCC/libcpp/po/ja.po",
        "/tmp/vanessa/spack-stage/spack-stage-gccxml-latest-w5xt6m3ulksz5ujtgruzzb6jkeam5q55/spack-src/GCC/libcpp/po/vi.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gccxml-latest-w5xt6m3ulksz5ujtgruzzb6jkeam5q55/spack-src/GCC/libcpp/po/zh_CN.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gccxml-latest-w5xt6m3ulksz5ujtgruzzb6jkeam5q55/spack-src/GCC/libcpp/po/el.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gccxml-latest-w5xt6m3ulksz5ujtgruzzb6jkeam5q55/spack-src/GCC/libcpp/po/fr.po",
        "/tmp/vanessa/spack-stage/spack-stage-gccxml-latest-w5xt6m3ulksz5ujtgruzzb6jkeam5q55/spack-src/GCC/libcpp/po/da.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gccxml-latest-w5xt6m3ulksz5ujtgruzzb6jkeam5q55/spack-src/GCC/libcpp/po/zh_TW.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gccxml-latest-w5xt6m3ulksz5ujtgruzzb6jkeam5q55/spack-src/GCC/libcpp/po/es.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gccxml-latest-w5xt6m3ulksz5ujtgruzzb6jkeam5q55/spack-src/GCC/libcpp/po/ca.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gccxml-latest-w5xt6m3ulksz5ujtgruzzb6jkeam5q55/spack-src/GCC/libcpp/po/tr.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gccxml-latest-w5xt6m3ulksz5ujtgruzzb6jkeam5q55/spack-src/GCC/libcpp/po/da.po",
        "/tmp/vanessa/spack-stage/spack-stage-gccxml-latest-w5xt6m3ulksz5ujtgruzzb6jkeam5q55/spack-src/GCC/config_cmake/nawk.exe",
        "/tmp/vanessa/spack-stage/spack-stage-gccxml-latest-w5xt6m3ulksz5ujtgruzzb6jkeam5q55/spack-src/GCC/libiberty/strverscmp.c",
        "/tmp/vanessa/spack-stage/spack-stage-gccxml-latest-w5xt6m3ulksz5ujtgruzzb6jkeam5q55/spack-src/GCC_XML/VcInstall/vcPatch.exe",
        "/tmp/vanessa/spack-stage/spack-stage-gccxml-latest-w5xt6m3ulksz5ujtgruzzb6jkeam5q55/spack-src/GCC_XML/VcInstall/vcCat.exe",
        "/tmp/vanessa/spack-stage/spack-stage-gccxml-latest-w5xt6m3ulksz5ujtgruzzb6jkeam5q55/spack-src/GCC_XML/Support/Borland/5.5/gccxml_fstream.h",
        "/tmp/vanessa/spack-stage/spack-stage-gccxml-latest-w5xt6m3ulksz5ujtgruzzb6jkeam5q55/spack-src/GCC_XML/Support/Borland/5.5/gccxml_new.h",
        "/tmp/vanessa/spack-stage/spack-stage-gccxml-latest-w5xt6m3ulksz5ujtgruzzb6jkeam5q55/spack-src/GCC_XML/Support/Borland/5.5/valarray.cc",
        "/tmp/vanessa/spack-stage/spack-stage-gccxml-latest-w5xt6m3ulksz5ujtgruzzb6jkeam5q55/spack-src/GCC_XML/Support/Borland/5.5/gccxml_valarray.h",
        "/tmp/vanessa/spack-stage/spack-stage-gccxml-latest-w5xt6m3ulksz5ujtgruzzb6jkeam5q55/spack-src/GCC_XML/Support/Borland/5.5/gccxml_vector.h",
        "/tmp/vanessa/spack-stage/spack-stage-gccxml-latest-w5xt6m3ulksz5ujtgruzzb6jkeam5q55/spack-src/GCC_XML/Support/Borland/5.5/Wrappers/rw/rwstderr_macros.h",
        "/tmp/vanessa/spack-stage/spack-stage-gccxml-latest-w5xt6m3ulksz5ujtgruzzb6jkeam5q55/spack-src/GCC_XML/Support/Borland/5.5/rw/locimpl.h",
        "/tmp/vanessa/spack-stage/spack-stage-gccxml-latest-w5xt6m3ulksz5ujtgruzzb6jkeam5q55/spack-src/GCC_XML/Support/Borland/5.5/rw/rwlocale.h",
        "/tmp/vanessa/spack-stage/spack-stage-gccxml-latest-w5xt6m3ulksz5ujtgruzzb6jkeam5q55/spack-src/GCC_XML/KWSys/testSystemTools.bin"
    ],
    "total_files": 2115
}