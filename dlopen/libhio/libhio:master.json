{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-libhio-master-nrfvlowvo6m3roe76nnwdjzmnqna7vvk/spack-src/configure.ac": "# -*- mode: shell-script-mode -*-\n#\n# Copyright (c) 2014-2018 Los Alamos National Security, LLC. All rights\n#                         reserved.\n# Copyright (c) 2019      Triad National Security, LLC. All rights\n#                         reserved.\n# $COPYRIGHT$\n#\n# Additional copyrights may follow\n#\n# $HEADER$\n#\n\nAC_PREREQ([2.69])\nAC_INIT([libhio], [1.4.1.3], [hjelmn@lanl.gov])\nAC_CONFIG_SRCDIR([src/hio_context.c])\nAC_CONFIG_HEADERS([src/include/hio_config.h])\nAC_CONFIG_MACRO_DIR([m4])\nAC_CHECK_PROG(MPICC, [mpicc], [mpicc], [none])\nAC_CHECK_PROG(MPICXX, [mpicxx], [mpicxx], [none])\nAM_SILENT_RULES([yes])\n\nhio_use_mpi=0\n\nif ( test -n \"$XTOS_VERSION\" || test -n \"$CRAYPE_DIR\" ) && (test -z $CC || test \"$CC\" = cc) ; then\n    # Work around Cray idiosyncrasies\n    # Don't let the Cray wrapper bring in extra crap\n    PE_VERSION=`echo $XTOS_VERSION | sed 's/\\..*//g'`\n    # force the cray wrappers to act in a predictable way\n    if test x$PE_VERSION = x4 ; then\n        CC=\"cc -target=native -dynamic\"\n        CXX=\"CC -target=native -dynamic\"\n    else\n        CC=\"cc --cray-bypass-pkgconfig -dynamic\"\n        CXX=\"CC --cray-bypass-pkgconfig -dynamic\"\n    fi\n    # We may be cross-compiling so trick configure\n    cross_compiling=yes\n    if test ! -n \"$LD\" ; then\n        LD=ld\n    fi\nelif test ! \"$MPICC\" = \"none\" ; then\n    CC=${MPICC}\n    CXX=${MPICXX}\n    hio_use_mpi=1\nfi\n\nAM_INIT_AUTOMAKE([serial-tests])\nLT_INIT\n\nAC_ARG_ENABLE([tests], [AC_HELP_STRING([--enable-tests],\n    \t\t\t\t       [Enable hio tests @<:@default=yes@:>@])],\n\t      [hio_enable_tests=$enable_tests],[hio_enable_tests=$enable_static])\n\nif test $hio_enable_tests = yes && test \"x$enable_static\" = \"xno\" ; then\n    AC_ERROR([Must have static libraries enabled to enable unit tests])\nfi\n\nHIO_CHECK_JSON\nHIO_CHECK_DATAWARP\nHIO_CHECK_XPMEM\nHIO_CHECK_CVERSION\nHIO_CHECK_BZ2\n\nif test $hio_use_mpi = 0 ; then\n    AC_MSG_CHECKING([for craypich])\n    if test -n \"$CRAY_MPICH2_DIR\" ; then\n        AC_MSG_RESULT([yes])\n        CPPFLAGS=\"$CPPFLAGS -I$CRAY_MPICH2_DIR/include\"\n        LDFLAGS=\"$LDFLAGS -L$CRAY_MPICH2_DIR/lib\"\n        LIBS=\"$LIBS -lmpich\"\n        hio_use_mpi=1\n    else\n        AC_MSG_RESULT([no])\n    fi\nfi\n\nif test $hio_use_mpi ; then\n   HIO_CHECK_MPI_FEATURES\nfi\n\n#Check for HDF5\nHIO_CHECK_HDF5\n\n# Checks for programs.\nAC_PROG_CC_C99\n\nAC_PROG_LEX\n\nAC_ARG_VAR([HAVE_PDFLATEX], [Whether pdflatex exists and is executable])\nAC_CHECK_PROG([HAVE_PDFLATEX], [pdflatex], [yes], [no])\n\n# Checks for libraries.\n\n# Checks for header files.\nAC_CHECK_HEADERS_ONCE([strings.h sys/types.h sys/time.h pthread.h dlfcn.h sys/stat.h \\\n                       sys/param.h sys/mount.h sys/vfs.h bzlib.h AvailabilityMacros.h])\nAC_CHECK_FUNCS_ONCE([access gettimeofday stat statfs MPI_Win_allocate_shared \\\n                     MPI_Comm_split_type MPI_Win_flush clock_gettime])\nAC_SEARCH_LIBS([dlopen],[dl],[hio_dynamic_component=1],[hio_dynamic_component=0])\nAC_SEARCH_LIBS([floor],[m],[],[AC_ERROR([Could not find math libraries])])\n\nAX_PTHREAD([])\n\nLIBS=\"$PTHREAD_LIBS $LIBS\"\nCFLAGS=\"$PTHREAD_CFLAGS $CFLAGS\"\n\n#Check for LUSTRE \nHIO_CHECK_LUSTRE\n\n# Checks for typedefs, structures, and compiler characteristics.\nAC_CHECK_HEADER_STDBOOL\n\nAC_TYPE_INT64_T\nAC_TYPE_OFF_T\nAC_TYPE_SIZE_T\nAC_TYPE_SSIZE_T\n\nAC_DEFINE_UNQUOTED([HIO_USE_MPI], [$hio_use_mpi], [Whether to use mpi with hio])\nAC_DEFINE_UNQUOTED([USE_DYNAMIC_COMPONENTS], [$hio_dynamic_component], [Whether to use dynamic components])\nAC_DEFINE([_GNU_SOURCE], [1], [Define _GNU_SOURCE feature macro])\nAC_DEFINE_UNQUOTED([HIO_PREFIX], [\"$prefix\"], [HIO install prefix])\nAM_CONDITIONAL([HAVE_PDFLATEX], [test $HAVE_PDFLATEX = yes])\nAM_CONDITIONAL([HAVE_MPI], [test $hio_use_mpi = 1])\nAM_CONDITIONAL([ENABLE_TESTS], [test $hio_enable_tests = yes])\n\nAC_SUBST([HIO_PKGCONFIG_REQUIRES], [$hio_pkgconfig_requires])\n\nAC_SUBST(HIO_BUILD_TIMESTAMP,[$(date \"+%A %B %d, %Y at %l:%M %p %Z\")])\n\n# Checks for library functions.\n\nAC_CONFIG_FILES([Makefile design/Makefile src/Makefile test/Makefile test/xexec/Makefile tools/Makefile libhio.pc design/doxygen.conf design/template/header.tex hdf5-hio/Makefile hdf5-hio/src/Makefile hdf5-hio/test/Makefile hdf5-hio/doc/Makefile hdf5-hio/doc/doxygen.conf hdf5-hio/doc/template/header.tex])\nAC_OUTPUT\n",
        "/tmp/vanessa/spack-stage/spack-stage-libhio-master-nrfvlowvo6m3roe76nnwdjzmnqna7vvk/spack-src/src/hio_component.c": "/* -*- Mode: C; c-basic-offset:2 ; indent-tabs-mode:nil -*- */\n/*\n * Copyright (c) 2014-2018 Los Alamos National Security, LLC.  All rights\n *                         reserved. \n * $COPYRIGHT$\n * \n * Additional copyrights may follow\n * \n * $HEADER$\n */\n\n#include \"hio_internal.h\"\n\n#if USE_DYNAMIC_COMPONENTS\n#include <dlfcn.h>\n#include <dirent.h>\n#endif\n\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n\nextern hio_component_t builtin_posix_component;\n#if HIO_USE_DATAWARP\nextern hio_component_t builtin_datawarp_component;\n#endif\n\n#define MAX_COMPONENTS 128\n\nstatic hio_component_t *hio_builtin_components[] = {\n#if HIO_USE_DATAWARP\n                                                    &builtin_datawarp_component,\n#endif\n                                                    &builtin_posix_component,\n                                                    NULL};\n\nstatic int hio_component_init_count = 0;\n\n#if USE_DYNAMIC_COMPONENTS\ntypedef struct hio_dynamic_component_t {\n  void *dl_ctx;\n  hio_component_t *component;\n} hio_dynamic_component_t;\n\nstatic hio_dynamic_component_t hio_external_components[MAX_COMPONENTS];\nstatic int hio_external_component_count;\n\nstatic int hioi_dynamic_component_init (hio_context_t context) {\n  const char *module_dir = HIO_PREFIX \"/lib/hio_\" PACKAGE_VERSION \"/modules\";\n  char component_name[128], component_symbol[512];\n  hio_component_t *component_ptr;\n  int rc = HIO_SUCCESS;\n  struct dirent *entry;\n  void *dl_ctx;\n  char *path;\n  DIR *dir;\n\n  hioi_log(context, HIO_VERBOSE_DEBUG_LOW, \"Looking for plugins in %s ...\", module_dir);\n\n  dir = opendir (module_dir);\n  if (NULL != dir) {\n    hio_dynamic_component_t *external_component = hio_external_components;\n\n    while (NULL != (entry = readdir (dir))) {\n      if ('.' == entry->d_name[0]) {\n        continue;\n      }\n\n      hioi_log (context, HIO_VERBOSE_DEBUG_LOW, \"Checking file %s\", entry->d_name);\n      if (strncmp (entry->d_name, \"hio_plugin_\", 11)) {\n        hioi_log (context, HIO_VERBOSE_DEBUG_LOW, \"File %s does not match expected name pattern. Skipping...\", entry->d_name);\n        continue;\n      }\n      sscanf (entry->d_name, \"hio_plugin_%128s\", component_name);\n\n      rc = asprintf (&path, \"%s/%s\", module_dir, entry->d_name);\n      if (0 > rc) {\n        rc = HIO_ERR_OUT_OF_RESOURCE;\n        break;\n      }\n\n      dl_ctx = dlopen (path, RTLD_LAZY);\n      free (path);\n      if (NULL == dl_ctx) {\n        rc = hioi_err_errno (errno);\n        hioi_log (context, HIO_VERBOSE_DEBUG_LOW, \"Failed to dlopen() plugin. Reason: %s\", strerror (errno));\n        continue;\n      }\n\n      snprintf (component_symbol, 512, \"%s_component\", component_name);\n\n      component_ptr = (hio_component_t *) dlsym (dl_ctx, component_symbol);\n      if (NULL == component_ptr) {\n        hioi_log (context, HIO_VERBOSE_DEBUG_LOW, \"Could not find component symbol: %s\", component_symbol);\n        rc = hioi_err_errno (errno);\n        dlclose (dl_ctx);\n        continue;\n      }\n\n      if (NULL == component_ptr->init) {\n        hioi_log (context, HIO_VERBOSE_DEBUG_LOW, \"Component %s does not define the required init() function\", component_name);\n        dlclose (dl_ctx);\n        continue;\n      }\n\n      rc = component_ptr->init (context);\n      if (HIO_SUCCESS != rc) {\n        hioi_log (context, HIO_VERBOSE_DEBUG_LOW, \"Component %s initialize function failed\", component_name);\n        dlclose (dl_ctx);\n        continue;\n      }\n\n      external_component->dl_ctx = dl_ctx;\n      external_component->component = component_ptr;\n\n      ++external_component;\n      ++hio_external_component_count;\n\n      rc = HIO_SUCCESS;\n\n      if (MAX_COMPONENTS == hio_external_component_count) {\n        break;\n      }\n    }\n\n    closedir (dir);\n  }\n\n  return rc;\n}\n#endif\n\nint hioi_component_init (hio_context_t context) {\n  int rc = HIO_SUCCESS;\n\n  if (hio_component_init_count++ > 0) {\n    return HIO_SUCCESS;\n  }\n\n  for (int i = 0 ; hio_builtin_components[i] ; ++i) {\n    hio_component_t *component = hio_builtin_components[i];\n\n    rc = component->init (context);\n    if (HIO_SUCCESS != rc) {\n      return rc;\n    }\n  }\n\n  if (HIO_SUCCESS != rc) {\n    return rc;\n  }\n\n#if USE_DYNAMIC_COMPONENTS\n  return hioi_dynamic_component_init (context);\n#endif\n\n  return HIO_SUCCESS;\n}\n\nint hioi_component_fini (void) {\n  if (0 == hio_component_init_count || --hio_component_init_count) {\n    return HIO_SUCCESS;\n  }\n\n  for (int i = 0 ; hio_builtin_components[i] ; ++i) {\n    hio_component_t *component = hio_builtin_components[i];\n\n    (void) component->fini ();\n  }\n\n#if USE_DYNAMIC_COMPONENTS\n  for (int i = 0 ; i < hio_external_component_count ; ++i) {\n    hio_dynamic_component_t *component = hio_external_components + i;\n    (void) component->component->fini ();\n    dlclose (component->dl_ctx);\n  }\n\n  memset (hio_external_components, 0, sizeof (hio_external_components));\n#endif\n\n  return HIO_SUCCESS;\n}\n\nvoid hioi_module_retain (hio_module_t *module) {\n  (void) atomic_fetch_add (&module->ref_count, 1);\n}\n\nvoid hioi_module_release (hio_module_t *module) {\n  int ref_count = atomic_fetch_add (&module->ref_count, -1);\n  if (1 == ref_count) {\n    module->fini (module);\n  }\n}\n\nint hioi_component_query (hio_context_t context, const char *data_root, char * const *next_data_roots,\n                          hio_module_t **module) {\n  int rc;\n\n  for (int i = 0 ; hio_builtin_components[i] ; ++i) {\n    hio_component_t *component = hio_builtin_components[i];\n\n    rc = component->query (context, data_root, next_data_roots, module);\n    if (HIO_SUCCESS == rc) {\n      atomic_init (&(*module)->ref_count, 1);\n      return HIO_SUCCESS;\n    }\n  }\n\n#if USE_DYNAMIC_COMPONENTS\n  for (int i = 0 ; i < hio_external_component_count ; ++i) {\n    hio_dynamic_component_t *component = hio_external_components + i;\n\n    rc = component->component->query (context, data_root, next_data_roots, module);\n    if (HIO_SUCCESS == rc) {\n      atomic_init (&(*module)->ref_count, 1);\n      return HIO_SUCCESS;\n    }\n  }\n#endif\n\n  return HIO_ERR_NOT_FOUND;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-libhio-master-nrfvlowvo6m3roe76nnwdjzmnqna7vvk/spack-src/test/xexec/xexec.c": "/* -*- Mode: C; c-basic-offset:2 ; indent-tabs-mode:nil -*- */\n/*\n * Copyright (c) 2014-2017 Los Alamos National Security, LLC.  All rights\n *                         reserved.\n * $COPYRIGHT$\n *\n * Additional copyrights may follow\n *\n * $HEADER$\n */\n\n//----------------------------------------------------------------------------\n// xexec.c - xexec is a multi-purpose HPC system testing tool.  See the help\n// text a few lines below for a description of its capabilities.\n//----------------------------------------------------------------------------\n#include \"xexec.h\"\n#define _GNU_SOURCE 1\n#include <errno.h>\n#include <signal.h>\n#include <execinfo.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n#ifdef MPI\n#include <mpi.h>\n#endif  // MPI\n\n#define VERB_LEV_MULTI 2\n\nchar * help_pre =\n  \"xexec - multi-pupose HPC exercise and testing tool.  Processes command\\n\"\n  \"        line arguments and file input in sequence to control actions.\\n\"\n  \"        Version \" XEXEC_VERSION \" \" __DATE__ \" \" __TIME__ \"\\n\"\n  \"\\n\"\n  \"  Syntax:  xexec -h | [ action [param ...] ] ...\\n\"\n  \"\\n\"\n  \"  Where valid actions and their parameters are:\"\n  \"\\n\"\n;  \n\nchar * help_post =\n  \"\\n\"\n  \"Notes:\\n\"\n  \" Numbers can be specified with suffixes %s\\n\"\n  \"\\n\"\n  \" Strings can be specified as %%NULL (null pointer) or %%0 (zero length string)\\n\"\n  \"\\n\"\n  \" Comments are delimited with /@, /@@ and @/, however those must stand alone in the \\n\"\n  \" actions as separate tokens.  Also, /@ is only recognized if it is the first\\n\"\n  \" token of an action. Comments starting with /@@ are printed. Comments may be nested.\\n\"\n  \"\\n\"\n  \" [1] <regex> parameters are POSIX extended regular expressions. See man 7 regex\\n\"\n  \"\\n\"\n  \" [2] Output only if MPI not active or if rank 0 or if verbose >= \" STRINGIFY(VERB_LEV_MULTI) \".\\n\"\n  \"\\n\"\n  \" Example action sequences:\\n\"\n  \"    v 1 d 1\\n\"\n  \"    opt +ROF-RCHK\\n\"\n  \"    lc 3 s 0 le\\n\"\n  \"    lt 3 s 1 le\\n\"\n  \"    o 3 e 2\\n\"\n  \"    va 1M vt 4K vf\\n\"\n  #ifdef MPI\n  \"    mi mb mf\\n\"\n  #endif // MPI\n  \"    ni 32 1M nr 8 1 nf\\n\"\n  \"    x 99\\n\"\n  \"\\n\"\n  #ifndef MPI\n  \" MPI actions can be enabled by building with -DMPI.\\n\"\n  \"\\n\"\n  #endif // MPI\n  #ifndef DLFCN\n  \" dlopen and related actions can be enabled by building with -DDLFCN.\\n\"\n  \"\\n\"\n  #endif // DLFCN\n;\n\n//----------------------------------------------------------------------------\n// Global variables\n//----------------------------------------------------------------------------\nstatic GLOBAL * xexec_global_ptr;\n#define G (*gptr)\n#define MY_MSG_CTX (&G.xexec_msg_context)\n\nENUM_START(etab_opt)\nENUM_NAMP(OPT_, ROF)\nENUM_NAMP(OPT_, RCHK)\nENUM_NAMP(OPT_, XPERF)\nENUM_NAMP(OPT_, PERFXCHK)\nENUM_NAMP(OPT_, SMSGV1)\nENUM_NAMP(OPT_, PAVM)\nENUM_NAMP(OPT_, SIGHAND)\nENUM_NAMP(OPT_, FAILDLY)\nENUM_END(etab_opt, 1, \"+\")\n\nstatic const char * options_init = \"-ROF+RCHK+XPERF-PERFXCHK-SMSGV1-PAVM+SIGHAND\"; \n\n#define MAX_LOOP 16\nenum looptype {COUNT, TIME, SYNC};\n\nstruct mod_table {\n  module_init * init;\n  module_help * help;\n  void * state;\n};\n\n// State local to this module, used for parsing and execution control\ntypedef struct ctrl_state {\n  size_t modsN;            // size of modules table\n  struct mod_table * mods; // xexec modules table\n  int parseN;          // Parse table count \n  struct xexec_act_parse * parse; // Parse table\n  int tokc;            // size of tokv array\n  char * * tokv;       // Token array \n  int tokn;            // In parse, next token after current action, used by im\n  int actN;            // Total number of actions in array\n  ACTION * actv;       // Action array\n  int act_cur;         // Currently active action \n  struct loop_ctl {    \n    enum looptype type;\n    int count;\n    double ltime;\n    int top;\n    ETIMER tmr;\n  } lctl[MAX_LOOP+1];\n  struct loop_ctl * lcur;\n} CTRL;\n\nstatic CTRL ctrl_state;\n\n//----------------------------------------------------------------------------\n// Common subroutines and macros\n//----------------------------------------------------------------------------\nint mpi_active(void) {\n  #ifdef MPI\n    int mpi_init_flag, mpi_final_flag;\n    MPI_Initialized(&mpi_init_flag);\n    if (mpi_init_flag) {\n      MPI_Finalized(&mpi_final_flag);\n      if (! mpi_final_flag) {\n        return 1;\n      } \n    }\n  #endif \n  return 0;\n}\n\n\nvoid set_msg_id(GLOBAL * gptr) {\n  char * p;\n  char tmp_id[sizeof(G.id_string)];\n  int rc;\n\n  rc = gethostname(tmp_id, sizeof(tmp_id));\n  if (rc != 0) ERRX(\"gethostname rc: %d %s\", rc, strerror(errno));\n  p = strchr(tmp_id, '.');\n  if (p) *p = '\\0';\n\n  IF_MPI(\n    MPI_CK(MPI_Comm_rank(G.mpi_comm, &G.myrank));\n    G.my_prior_rank = G.myrank;\n    sprintf(tmp_id+strlen(tmp_id), \".%d\", G.myrank);\n    MPI_CK(MPI_Comm_size(G.mpi_comm, &G.mpi_size));\n    sprintf(tmp_id+strlen(tmp_id), \"/%d\", G.mpi_size);\n  ) ELSE_MPI(\n    G.myrank = 0;\n    G.mpi_size = 0;\n  )\n\n  strcat(tmp_id, \" \");\n  strcpy(G.id_string, tmp_id);\n  G.id_string_len = strlen(G.id_string);\n  MY_MSG_CTX->id_string=G.id_string;\n}\n\n//----------------------------------------------------------------------------\n// lfsr_22_byte - bytewise 22 bit linear feedback shift register.\n// Taps at bits 21 & 22 (origin 1) to provide 2^22-1 repeat cycle.\n//----------------------------------------------------------------------------\nstatic unsigned char lfsr_state[23]; // One extra byte to hold shift out\n\n#define LFSR_22_CYCLE (4 * 1024 * 1024 - 1)\n\nvoid lfsr_22_byte(unsigned char * p, U64 len) {\n  while (len--) {\n    memmove(lfsr_state+1, lfsr_state, sizeof(lfsr_state) - 1);\n    lfsr_state[0] = lfsr_state[21] ^ lfsr_state[22] ^ 0xFF;\n    *p++ = lfsr_state[22];\n  }\n}\n\nvoid lfsr_22_byte_init(void) {\n  srandom(15485863); // The 1 millionth prime\n  for (size_t i = 0; i<sizeof(lfsr_state); ++i) {\n    lfsr_state[i] = random() % 256;\n  }\n}\n\nvoid lfsr_22_byte_init_p(void) {\n  // Use a very simple PRNG to initialize lfsr_state\n  int prime = 15485863; // The 1 millionth prime\n  lfsr_state[0] = 0xA5;\n  for (size_t i = 1; i<sizeof(lfsr_state); ++i) {\n    lfsr_state[i] = (lfsr_state[i-1] * prime) % 256;\n  }\n  // Cycle a few times to mix things up\n  unsigned char t[1000];\n  lfsr_22_byte(t, sizeof(t));\n}\n\n# if 0\nvoid lfsr_test(GLOBAL * gptr) {\n  // A few tests for lfsr properties\n  U64 size = 8 * 1024 * 1024;\n  unsigned char * buf = MALLOCX(size);\n\n  lfsr_22_byte_init();\n\n  printf(\"lfsr_state:\\n\");\n  hex_dump(lfsr_state, sizeof(lfsr_state));\n\n  lfsr_22_byte(buf, size);\n\n  printf(\"buf:\\n\");\n  hex_dump(buf, 256);\n\n  printf(\"buf + %d:\\n\", LFSR_22_CYCLE);\n  hex_dump(buf+LFSR_22_CYCLE, 256);\n\n  int b[8] = {0,0,0,0,0,0,0,0};\n  int j = 0;\n  for (int i = 0; i<256; ++i) {\n    int n = ((unsigned char *)buf)[i];\n    j += n;\n    for (int k=0; k<8; ++k) {\n      unsigned char m = 1 << k;\n      if (m & n) b[k]++;\n    }\n       \n  }\n  VERB0(\"j: %d\", j);\n  for (int k=0; k<8; ++k) {\n    VERB0(\"b[%d]: %d\", k, b[k]);\n  } \n\n\n  for (int j=0; j<100; ++j) {\n    int sum = 0;\n    for (int i=0; i<100; ++i) {\n      sum += buf[j*1000+i];\n    }\n    printf(\"sum: %d sum/100: %f\\n\", sum, sum/100.0);\n  }\n\n  for (int i = 0; i<4*1024*1024; ++i) {\n    if (0 == i%1000) printf(\"i=%d\\n\", i);\n    for (int j = i+1; j<4*1024*1024; ++j) {\n      if (!memcmp(buf+i, buf+j, 8)) {\n        printf(\"match at %d, %d\\n\", i, j);\n      }\n     }\n  }\n}\n#endif\n\n//----------------------------------------------------------------------------\n// fread and fwrite with redrive\n//----------------------------------------------------------------------------\nssize_t fwrite_rd (FILE *file, const void *ptr, size_t count) {\n  ssize_t actual, total = 0;\n\n  do {\n    actual = fwrite (ptr, 1, count, file);\n\n    if (actual > 0) {\n      total += actual;\n      count -= actual;\n      ptr = (void *) ((intptr_t) ptr + actual);\n    }\n  } while (count > 0 && (actual > 0 || (-1 == actual && EINTR == errno)) );\n\n  return (actual < 0) ? actual: total;\n}\n\nssize_t fread_rd (FILE *file, void *ptr, size_t count) {\n  ssize_t actual, total = 0;\n\n  do {\n    actual = fread (ptr, 1, count, file);\n\n    if (actual > 0) {\n      total += actual;\n      count -= actual;\n      ptr = (void *) ((intptr_t) ptr + actual);\n    }\n  } while (count > 0 && (actual > 0 || (-1 == actual && EINTR == errno)) );\n\n  return (actual < 0) ? actual: total;\n}\n\n//----------------------------------------------------------------------------\n// If MPI & Rank 0, VERB1 message with collective min/mean/max/stddev/total\n// Always VERB2 local value message\n//----------------------------------------------------------------------------\nstruct mm_val_s {\n  double val;\n  char id[24];\n};\n\nstruct min_max_s {\n  struct mm_val_s min;\n  struct mm_val_s max;\n};\n\n#ifdef MPI\nvoid min_max_who(void *invec, void *inoutvec, int *len, MPI_Datatype *datatype) {\n  for (int j=0; j<*len; ++j) {\n    struct min_max_s *vi = ((struct min_max_s *)invec) + j;\n    struct min_max_s *vo = ((struct min_max_s *)inoutvec) + j;\n\n    if ( (*vi).min.val < (*vo).min.val ) {\n      (*vo).min = (*vi).min;\n    }\n    if ( (*vi).max.val > (*vo).max.val ) {\n      (*vo).max = (*vi).max;\n    }\n  }\n}\n#endif // MPI\n\nvoid prt_mmmst(GLOBAL * gptr, double val, char * desc, char * unit) {\n  double sum = 0, mean, diff, sumdiff = 0, sd;\n  char b1[32], b2[32], b3[32], b4[32], b5[32];\n  if (mpi_active()) {\n    struct min_max_s mm;\n    struct min_max_s mmr;\n    #ifdef MPI\n      MPI_Datatype mmtype;\n      MPI_Op mmw_op;\n    #endif // MPI\n\n    // Set up MPI data type and op\n    MPI_CK( MPI_Type_contiguous(sizeof(struct min_max_s), MPI_BYTE, &mmtype) );\n    MPI_CK( MPI_Type_commit(&mmtype) );\n    MPI_CK( MPI_Op_create(min_max_who, true, & mmw_op) );\n\n    // Use two pass method to calculate variance\n    MPI_CK( MPI_Allreduce(&val, &sum, 1, MPI_DOUBLE, MPI_SUM, G.mpi_comm) );\n    mean = sum/(double)G.mpi_size;\n    diff = (val - mean) * (val - mean);\n    MPI_CK( MPI_Reduce(&diff, &sumdiff, 1, MPI_DOUBLE, MPI_SUM, 0, G.mpi_comm) );\n    sd = sqrt(sumdiff / G.mpi_size);\n\n    // Get min, max\n    mm.min.val = mm.max.val = val;\n    strncpy(mm.min.id, G.id_string, sizeof(mm.min.id)); \n    mm.min.id[sizeof(mm.min.id)-1] = '\\0';\n    char * p = strchr(mm.min.id, ' ');\n    if (p) *p = '\\0';\n    strncpy(mm.max.id, mm.min.id, sizeof(mm.max.id)); \n    MPI_CK( MPI_Reduce(&mm, &mmr, 1, mmtype, mmw_op, 0, G.mpi_comm) );\n    MPI_CK( MPI_Type_free(&mmtype) );\n    MPI_CK( MPI_Op_free(&mmw_op) );\n\n    if (0 == G.myrank) VERB1(\"%s mean/min/max/s/tot: %s %s %s %s %s %s   min/max: %s %s\", desc,\n                              eng_not(b1, sizeof(b1), mean, \"D6.4\", \"\"),\n                              eng_not(b2, sizeof(b2), mmr.min.val,  \"D6.4\", \"\"), \n                              eng_not(b3, sizeof(b3), mmr.max.val,  \"D6.4\", \"\"), \n                              eng_not(b4, sizeof(b4), sd,   \"D6.4\", \"\"),\n                              eng_not(b5, sizeof(b5), sum,  \"D6.4\", \"\"), unit,\n                              mmr.min.id, mmr.max.id);\n  } else { \n    VERB1(\"%s: %s\", desc, eng_not(b1, sizeof(b1), val, \"D6.4\", unit));\n  } \n}\n\n//----------------------------------------------------------------------------\n// data buffer setup and data check routines\n//----------------------------------------------------------------------------\nENUM_START(etab_dbuf)  // Write buffer type\nENUM_NAME(\"RAND22P\", RAND22P)\nENUM_NAME(\"RAND22\", RAND22)\nENUM_NAME(\"OFS20\",  OFS20)\nENUM_END(etab_dbuf, 0, NULL)\n\n#define PRIME_LT_64KI    65521 // A prime a little less than 2**16\n#define PRIME_75PCT_2MI 786431 // A prime about 75% of 2**20\n#define PRIME_LT_2MI   1048573 // A prime a little less that 2**20\n\nvoid dbuf_init(GLOBAL * gptr, enum dbuf_type type, U64 size) {\n  G.rwbuf_len = size;\n  int rc;\n\n  FREEX(G.wbuf_ptr);\n  FREEX(G.rbuf_ptr);\n\n  switch (type) {\n    case RAND22P:\n      G.wbuf_bdy = 1;\n      G.wbuf_repeat_len = LFSR_22_CYCLE;\n      G.wbuf_data_object_hash_mod = PRIME_LT_64KI;\n      rc = posix_memalign((void * *)&G.wbuf_ptr, 4096, G.rwbuf_len + G.wbuf_repeat_len);\n      if (rc) ERRX(\"G.wbuf posix_memalign %d bytes failed: %s\", G.rwbuf_len + G.wbuf_repeat_len, strerror(rc));\n      lfsr_22_byte_init_p();\n      lfsr_22_byte(G.wbuf_ptr, G.rwbuf_len + G.wbuf_repeat_len);\n      break;\n    case RAND22:\n      G.wbuf_bdy = 1;\n      G.wbuf_repeat_len = LFSR_22_CYCLE;\n      G.wbuf_data_object_hash_mod = PRIME_LT_2MI;\n      rc = posix_memalign((void * *)&G.wbuf_ptr, 4096, G.rwbuf_len + G.wbuf_repeat_len);\n      if (rc) ERRX(\"G.wbuf posix_memalign %d bytes failed: %s\", G.rwbuf_len + G.wbuf_repeat_len, strerror(rc));\n      lfsr_22_byte_init();\n      lfsr_22_byte(G.wbuf_ptr, G.rwbuf_len + G.wbuf_repeat_len);\n      break;\n    case OFS20:\n      G.wbuf_bdy = sizeof(uint32_t); \n      G.wbuf_repeat_len = 1024 * 1024;\n      G.wbuf_data_object_hash_mod = 1024 * 1024;\n      rc = posix_memalign((void * *)&G.wbuf_ptr, 4096, G.rwbuf_len + G.wbuf_repeat_len);\n      if (rc) ERRX(\"G.wbuf posix_memalign %d bytes failed: %s\", G.rwbuf_len + G.wbuf_repeat_len, strerror(rc));\n      for (U64 i = 0; i<(G.rwbuf_len+G.wbuf_repeat_len)/sizeof(uint32_t); ++i) {\n        ((uint32_t *)G.wbuf_ptr)[i] = i * sizeof(uint32_t);\n      }\n      break;\n  }\n\n  G.rbuf_ptr = MALLOCX(G.rwbuf_len);\n\n  DBG3(\"dbuf_init type: %s size: %lld G.wbuf_ptr: 0x%lX\",              \\\n        enum_name(MY_MSG_CTX, &etab_dbuf, type), size, G.wbuf_ptr);  \n  IFDBG3( hex_dump(G.wbuf_ptr, 32) );                                             \n\n}\n\n// Returns a pointer into wbuf based on offset and data object hash\nvoid * get_wbuf_ptr(GLOBAL * gptr, char * ctx, U64 offset, U64 data_object_hash) {\n  void * expected = (char *)G.wbuf_ptr + ( (offset + data_object_hash) % G.wbuf_repeat_len);\n  DBG2(\"%s: object_hash: 0x%lX  G.wbuf_ptr: 0x%lX expected-G.wbuf_ptr: 0x%lX\", ctx, data_object_hash, G.wbuf_ptr, (char *)expected - (char *)G.wbuf_ptr);  \n  return expected;\n}\n\n// Convert string that uniquely identifies a data object into a hash\nU64 get_data_object_hash(GLOBAL * gptr, char * obj_desc_string) {\n  U64 obj_desc_hash = BDYDN(crc32(0, obj_desc_string, strlen(obj_desc_string)) % G.wbuf_data_object_hash_mod, G.wbuf_bdy);\n  DBG4(\"data_object_desc_hash: \\\"%s\\\" 0x%lX\", obj_desc_string, obj_desc_hash);\n  return obj_desc_hash;\n}\n\nint check_read_data(GLOBAL * gptr, char * ctx, void * buf, size_t len, U64 offset, U64 data_object_hash) {\n  int rc;\n  void * expected = get_wbuf_ptr(&G, \"hew\", offset, data_object_hash);\n  void * mis_comp;\n  if ( ! (mis_comp = memdiff(buf, expected, len)) ) {\n    rc = 0;\n    VERB3(\"hio_element_read data check successful\");\n  } else {\n    // Read data miscompare - dump lots of data about it\n    rc = 1;\n    I64 misc_ofs = (char*)mis_comp - (char*)buf;\n    I64 dump_start = MAX(0, misc_ofs - 16) & (~15);\n    VERB0(\"Error: %s data check miscompare\", ctx);\n    VERB0(\"       Data offset: 0x%llX  %lld\", offset, offset); \n    VERB0(\"       Data length: 0x%llX  %lld\", len, len); \n    VERB0(\"      Data address: 0x%llX\", buf); \n    VERB0(\"Miscompare address: 0x%llX\", mis_comp); \n    VERB0(\" Miscompare offset: 0x%llX  %lld\", (char*)mis_comp - (char*)buf, (char*)mis_comp - (char*)buf); \n\n    VERB0(\"Debug: G.wbuf_ptr addr: 0x%lX:\", G.wbuf_ptr); hex_dump(G.wbuf_ptr, 32);\n\n    VERB0(\"Miscompare expected data at offset 0x%llX %lld follows:\", dump_start, dump_start);\n    hex_dump( (char*)expected + dump_start, 96);\n\n    VERB0(\"Miscompare actual data at offset 0x%llX %lld follows:\", dump_start, dump_start);\n    hex_dump( (char*)buf + dump_start, 96);\n\n    VERB0(\"XOR of Expected addr: 0x%lX  Miscomp addr: 0x%lX\", expected, mis_comp);\n    char * xorbuf_ptr = MALLOCX(len);\n    for (size_t i=0; i<len; i++) {\n      ((char *)xorbuf_ptr)[i] = ((char *)buf)[i] ^ ((char *)expected)[i];\n    }\n    hex_dump( xorbuf_ptr, len);\n    FREEX(xorbuf_ptr);\n\n  }\n  return rc;\n}\n\n//----------------------------------------------------------------------------\n// Compare regex, handle errors. Returns 0 on match or REG_NOMATCH\n//----------------------------------------------------------------------------\nint rx_run(GLOBAL * gptr, int n, struct action * actionp, char * line) {\n  int rc = regexec(A.v[n].rxp, line, 0, NULL, 0);\n  if (rc != 0 && rc != REG_NOMATCH) {\n    char buf[512];\n    regerror(rc, A.v[n].rxp, buf, sizeof(buf));\n    ERRX(\"%s; regex: %s\", A.desc, buf);\n  }\n  return rc;\n}\n\n//----------------------------------------------------------------------------\n// Enum conversion tables\n//----------------------------------------------------------------------------\nENUM_START(etab_onff)  // On, Off + case variants\nENUM_NAME(\"OFF\", 0)\nENUM_NAME(\"ON\",  1)\nENUM_NAME(\"off\", 0)\nENUM_NAME(\"on\",  1)\nENUM_NAME(\"Off\", 0)\nENUM_NAME(\"On\",  1)\nENUM_END(etab_onff, 0, NULL)\n\n//----------------------------------------------------------------------------\n// Local module for actions related action sequence and other controls\n// State data for this module controls action sequence and is shared\n// with action_runner \n//----------------------------------------------------------------------------\nstatic char * help = \n  \"  opt +-<option> ...  Set (+) or unset (-) options. Valid options are:\\n\"\n  \"                %s\\n\"\n  \"                Initial value is: %s plus env XEXEC_OPT\\n\"\n  \"                ? displays current set options\\n\"\n  \"  name <test name> Set test name for final success / fail message\\n\"\n  \"  im <file>     imbed a file of actions at this point, - means stdin\\n\"\n  \"  lc <count>    loop start; repeat the following actions (up to the matching\\n\"\n  \"                loop end) <count> times\\n\"\n  \"  lcr <min> <max>  like lc, but count random within inclusive range\\n\"\n  \"  lt <seconds>  loop start; repeat the following actions (up to the matching\\n\"\n  \"                loop end) for at least <seconds>\\n\"\n  #ifdef MPI\n  \"  ls <seconds>  like lt, but synchronized via MPI_Bcast from rank 0\\n\"\n  #endif\n  \"  le            loop end; loops may be nested up to 16 deep\\n\"\n  \"  ifr <rank>    execute following if rank matches, always exec if mpi not init'd\\n\"\n  \"                <rank> = -1 tests for last rank, -2, -3, etc. similarly\\n\"\n  \"  eif           terminates ifr conditional, may not be nested\\n\"\n;\n\n\nMODULE_INIT(xexec_ctrl_init) {\n  CTRL * s = state;\n  s->act_cur = -1;  \n  s->lcur = &(s->lctl[0]);  \n  return 0;\n}\n\nMODULE_HELP(xexec_ctrl_help) {\n  fprintf(file, help, enum_list(MY_MSG_CTX, &etab_opt), options_init);\n  return 0;\n}\n\n//----------------------------------------------------------------------------\n// ztest action handler - for misc testing, modify as needed\n//----------------------------------------------------------------------------\nACTION_RUN(ztest_run) {\n  I64 i0 = V0.u;\n  double d1 = V1.d;\n  char * s2 = V2.s; \n  char * s3 = V3.s; \n\n  VERB0(\"Nothing to see here, move along\", i0, d1, s2, s3); // Vars passed to avoid warning\n\n  //char buf[32];\n  //printf(\"eng_not(%lg, %s, %s) --> \\\"%s\\\"\\n\", d1, s2, s3, eng_not(buf, sizeof(buf), d1, s2, s3));\n\n  //lfsr_test();\n\n  //prt_mmmst((double) G.myrank, \"rank\", \"\");\n \n}\n\n//----------------------------------------------------------------------------\n// opt (set option flag) action handler\n//----------------------------------------------------------------------------\n\nvoid parse_opt(GLOBAL * gptr, char *ctx, const char *flags, int *set, int *clear) {\n  int rc = flag2enum(MY_MSG_CTX, &etab_opt, flags, set, clear);\n  if (rc) ERRX(\"%s; invalid option. Valid values are +/- %s\", ctx, enum_list(MY_MSG_CTX, &etab_opt));\n  DBG4(\"%s: flags: %s set: 0x%X  clear: 0x%X\", ctx, flags, *set, *clear);\n}\n\nvoid show_opt(GLOBAL * gptr, char *ctx, int val) {\n  char * opt_desc;\n  enum2str(MY_MSG_CTX, &etab_opt, val, &opt_desc);\n  VERB1(\"%s options: %s\", ctx, opt_desc);\n  FREEX(opt_desc);\n}\n\nACTION_CHECK(opt_check) {\n  char * flags = V0.s;\n  if (0 == strcmp(\"?\", flags)) V0.c = ~(V0.i = 0);\n  else parse_opt(&G, A.desc, flags, &V0.i, &V0.c);\n  DBG4(\"opt: flags: %s set: 0x%X  clear: 0x%X \\n\", flags, V0.i, V0.c);\n}\n\nACTION_RUN(opt_run) {\n  if (0 == V0.i && ~0 == V0.c) show_opt(&G, A.desc, G.options);\n  else G.options = (enum options) ( V0.c & (V0.i | G.options) ); \n}\n\n//----------------------------------------------------------------------------\n// name action handler\n//----------------------------------------------------------------------------\nACTION_RUN(name_run) {\n  G.test_name = V0.s;\n}\n\n//----------------------------------------------------------------------------\n// im (imbed) action handler\n//----------------------------------------------------------------------------\n#define S (*state)\nvoid add2actv(GLOBAL * gptr, CTRL * state, ACTION * newact) {\n  S.actv = REALLOCX(S.actv, (S.actN + 1) * sizeof(ACTION));\n  memcpy(S.actv+S.actN, newact, sizeof(ACTION));\n  S.actN++;\n}\n\nvoid add2tokv(GLOBAL * gptr, CTRL * state, int n, char * * newtok) {\n  if (n == 0) return;\n  S.tokv = REALLOCX(S.tokv, (S.tokc + n) * sizeof(char *));\n  memcpy(S.tokv+S.tokc, newtok, n * sizeof(char *));\n  S.tokc += n;\n}\n#undef S\n\n#define S (* ((CTRL *)(actionp->state)) )\nACTION_CHECK(imbed_check) {\n    // Open file and read into buffer\n    FILE * file;\n    char * fn = V0.s;\n    if (!strcmp(fn, \"-\")) file = stdin;\n    else file = fopen(fn, \"r\");\n    if (!file) ERRX(\"%s: unable to open file %s: %s\", A.desc, fn, strerror(errno));\n    #define BUFSZ 1024*1024\n    void * p = MALLOCX(BUFSZ);\n    size_t size;\n    size = fread(p, 1, BUFSZ, file);\n    DBG4(\"fread %s returns %d\", fn, size);\n    if (ferror(file)) ERRX(\"%s: error reading file %s %d %s\", A.desc, fn, ferror(file), strerror(ferror(file)));\n    if (!feof(file)) ERRX(\"%s: imbed file %s larger than buffer (%d bytes)\", A.desc, fn, BUFSZ);\n    fclose(file);\n    p = REALLOCX(p, size);\n\n    // Save old S.tokc / S.tokv, copy up through current action into new S.tokc / S.tokv\n    int old_tokc = S.tokc;\n    char * * old_tokv = S.tokv;\n    S.tokc = 0;\n    S.tokv = NULL;\n    add2tokv(&G, &S, S.tokn+1, old_tokv);\n\n    // tokenize buffer, append to S.tokc / S.tokv\n    char * sep = \" \\t\\n\\f\\r\";\n    char * a = strtok(p, sep);\n    while (a) {\n      DBG4(\"imbed_hand add tok: \\\"%s\\\" S.tokc: %d\", a, S.tokc);\n      add2tokv(&G, &S, 1, &a);\n      a = strtok(NULL, sep);\n    }\n\n    // append remainder of old S.tokc / S.tokv to new\n    add2tokv(&G, &S, old_tokc - S.tokn - 1, &old_tokv[S.tokn + 1]);\n    FREEX(old_tokv);\n}\n\n//----------------------------------------------------------------------------\n// lc, lt, ls, le (looping) action handlers\n//----------------------------------------------------------------------------\n\nACTION_CHECK(loop_check) {\n  if ( !strcmp(A.action, \"lc\")  ||\n       !strcmp(A.action, \"lcr\") ||\n    #ifdef MPI\n       !strcmp(A.action, \"ls\")  ||\n    #endif\n       !strcmp(A.action, \"lt\") ) {\n    if (++S.lcur - S.lctl >= MAX_LOOP) ERRX(\"%s: Maximum nested loop depth of %d exceeded\", A.desc, MAX_LOOP);\n  } else if (!strcmp(A.action, \"le\")) {\n    if (S.lcur <= S.lctl) ERRX(\"%s: loop end when no loop active - more loop ends than loop starts\", A.desc);\n    S.lcur--;\n  } else ERRX(\"%s: internal error loop_hand invalid action: %s\", A.desc, A.action);\n}\n\nACTION_RUN(lc_run) {\n  S.lcur++;\n  DBG4(\"loop count start; depth: %d top act_cur: %d count: %d\", S.lcur-S.lctl, S.act_cur, V0.u);\n  S.lcur->type = COUNT;\n  S.lcur->count = V0.u;\n  S.lcur->top = S.act_cur;\n}\n\nACTION_RUN(lcr_run) {\n  int count = rand_range(V0.u, V1.u, 1);\n  S.lcur++;\n  DBG4(\"loop count rand start; depth: %d top act_cur: %d count: %d\", S.lcur-S.lctl, S.act_cur, count);\n  S.lcur->type = COUNT;\n  S.lcur->count = count;\n  S.lcur->top = S.act_cur;\n}\n\nACTION_RUN(lt_run) {\n  S.lcur++;\n  DBG4(\"loop time start; depth: %d top act_cur: %d time: %d\", S.lcur - S.lctl, S.act_cur, V0.u);\n  S.lcur->type = TIME;\n  S.lcur->top = S.act_cur;\n  S.lcur->ltime = V0.d;\n  ETIMER_START(&S.lcur->tmr);\n}\n\n#ifdef MPI\nACTION_RUN(ls_run) {\n  S.lcur++;\n  DBG4(\"loop sync start; depth: %d top act_cur: %d time: %d\", S.lcur - S.lctl, S.act_cur, V0.u);\n  S.lcur->type = SYNC;\n  S.lcur->top = S.act_cur;\n  S.lcur->ltime = V0.d;\n  if (G.myrank == 0) {\n    ETIMER_START(&S.lcur->tmr);\n  }\n}\n#endif // MPI\n\nACTION_RUN(le_run) {\n  #ifdef MPI\n  int time2stop = 0;\n  #endif\n  switch (S.lcur->type) {\n    case COUNT:;\n      if (--S.lcur->count > 0) {\n        S.act_cur = S.lcur->top;\n        DBG4(\"loop count end, not done; depth: %d top actn: %d count: %d\", S.lcur-S.lctl, S.lcur->top, S.lcur->count);\n      } else {\n        DBG4(\"loop count end, done; depth: %d top actn: %d count: %d\", S.lcur-S.lctl, S.lcur->top, S.lcur->count);\n        S.lcur--;\n      }\n      break;\n    case TIME:;\n      if (S.lcur->ltime <= ETIMER_ELAPSED(&S.lcur->tmr)) {\n        DBG4(\"loop time end, done; depth: %d top actn: %d\", S.lcur-S.lctl, S.lcur->top);\n        S.lcur--;\n      } else {\n        S.act_cur = S.lcur->top;\n        DBG4(\"loop time end, not done; depth: %d top actn: %d\", S.lcur-S.lctl, S.lcur->top);\n      }\n      break;\n    #ifdef MPI\n    case SYNC:;\n      if (G.myrank == 0) {\n        if (S.lcur->ltime <= ETIMER_ELAPSED(&S.lcur->tmr)) {\n          DBG4(\"loop sync rank 0 end, done; depth: %d top actn: %d\", S.lcur-S.lctl, S.lcur->top);\n          time2stop = 1;\n        } else {\n          DBG4(\"loop sync rank 0 end, not done; depth: %d top actn: %d\", S.lcur-S.lctl, S.lcur->top);\n        }\n      }\n      MPI_CK(MPI_Bcast(&time2stop, 1, MPI_INT, 0, G.mpi_comm));\n      if (time2stop) {\n        VERB1(\"loop sync end, done; depth: %d top actn: %d\", S.lcur-S.lctl, S.lcur->top);\n        S.lcur--;\n      } else {\n        S.act_cur = S.lcur->top;\n        DBG4(\"loop sync end, not done; depth: %d top actn: %d\", S.lcur-S.lctl, S.lcur->top);\n      }\n      break;\n    #endif // MPI\n    default:\n      ERRX(\"%s: internal error le_run invalid looptype %d\", A.desc, S.lcur->type);\n  }\n}\n\n//----------------------------------------------------------------------------\n// ifr, eif action handler\n//----------------------------------------------------------------------------\nint ifr_depth = 0;\nint ifr_num;\n\nACTION_CHECK(ifr_check) {\n  if (ifr_depth > 0) \n    ERRX(\"%s: nested ifr\", A.desc);\n  ifr_depth++; \n  ifr_num = A.actn;\n}\n\nACTION_CHECK(eif_check) {\n  if (ifr_depth != 1) \n    ERRX(\"%s: ife without preceeding ifr\", A.desc);\n  ifr_depth--;\n  S.actv[ifr_num].ife_num = A.actn;\n}\n\nACTION_RUN(ifr_run) {\n  int req_rank = V0.u;\n  int cond = false;  // false --> don't run body of ifr\n  \n  if (mpi_active()) {\n    if (req_rank >= 0) {\n      if (G.myrank == req_rank) cond = true;\n    } else {\n      if ( G.myrank == G.mpi_size + req_rank) cond = true;\n    } \n  } else {\n    cond = true;\n  }\n  \n  if (!cond) S.act_cur = A.ife_num - 1;\n\n  DBG4(\"ifr done req_rank: %d cond: %d act_cur: %d\", req_rank, cond, S.act_cur);\n}\n\nACTION_RUN(eif_run) {\n  DBG4(\"ife done act_cur: %d\", S.act_cur);\n}\n\n// Special action runner for printing out /@@ comments\nACTION_RUN(cmsg_run) {\n  R0_OR_VERB_START\n    VERB1(\"%s\", V0.s);\n  R0_OR_VERB_END\n}\n#undef S\n\nMODULE_INSTALL(xexec_ctrl_install) {\n  struct xexec_act_parse parse[] = {\n  // Command   V0    V1    V2    V3    V4     Check          Run\n    {\"ztest\", {SINT, DOUB, STR,  STR,  NONE}, NULL,          ztest_run   },   // For testing code fragments  \n    {\"opt\",   {STR,  NONE, NONE, NONE, NONE}, opt_check,     opt_run     },\n    {\"name\",  {STR,  NONE, NONE, NONE, NONE}, NULL,          name_run    },\n    {\"im\",    {STR,  NONE, NONE, NONE, NONE}, imbed_check,   NULL        },\n    {\"lc\",    {UINT, NONE, NONE, NONE, NONE}, loop_check,    lc_run      },\n    {\"lcr\",   {UINT, UINT, NONE, NONE, NONE}, loop_check,    lcr_run     },\n    {\"lt\",    {DOUB, NONE, NONE, NONE, NONE}, loop_check,    lt_run      },\n    {\"ifr\",   {SINT, NONE, NONE, NONE, NONE}, ifr_check,     ifr_run     },\n    {\"eif\",   {NONE, NONE, NONE, NONE, NONE}, eif_check,     eif_run     },\n    #ifdef MPI\n    {\"ls\",    {DOUB, NONE, NONE, NONE, NONE}, loop_check,    ls_run      },\n    #endif\n    {\"le\",    {NONE, NONE, NONE, NONE, NONE}, loop_check,    le_run      },\n  };\n\n  xexec_act_add(&G, parse, DIM1(parse), xexec_ctrl_init, &ctrl_state, xexec_ctrl_help);\n\n  return 0;\n}\n\n//----------------------------------------------------------------------------\n// Argument string parser - call check routines, build action vector\n//----------------------------------------------------------------------------\nvoid decode(GLOBAL * gptr, ENUM_TABLE * etptr, char * tok, char * name, char * desc, PVAL * val) {\n  int rc = str2enum(MY_MSG_CTX, etptr, tok, &val->i);\n  if (rc) ERRX(\"%s ...; invalid %s \\\"%s\\\". Valid values are %s\",\n               desc, name, tok, enum_list(MY_MSG_CTX, etptr));\n  rc = enum2str(MY_MSG_CTX, etptr, val->i, &val->s);\n  if (rc) ERRX(\"%s ...; invalid %s \\\"%s\\\"\", desc, name, tok);\n}\n\nvoid decode_int(GLOBAL * gptr, ENUM_TABLE * etptr, char * tok, char * name, char * desc, PVAL * val) {\n  int i, rc;\n  char buf[128];\n\n  // Try enum\n  rc = str2enum(MY_MSG_CTX, etptr, tok, &i);\n\n  if (rc == 0) {\n    val->u = (U64)i;\n  } else {\n    // Not valid enum, try integer\n    rc = cvt_num(CVT_SINT, tok, &(val->u), buf, sizeof(buf));\n    // Neither, issue error message\n    if (rc) ERRX(\"%s and not a valid %s, recognized values are %s\",\n                 buf, name, enum_list(MY_MSG_CTX, etptr));\n  }\n}\n\n// Compare parse table cmd strings for qsort and bsearch\nint parse_comp(const void * p1, const void * p2) {\n  return strcmp( ((struct xexec_act_parse *)p1)->cmd,\n                 ((struct xexec_act_parse *)p2)->cmd );\n}\n\n// hio related enums defined in xexec_hio.c\nextern ENUM_TABLE etab_hflg, etab_hdsm, etab_herr, etab_hulm, etab_hdsi, etab_hcpr, etab_hvat, etab_hvao;\n#if HIO_USE_DATAWARP\n  extern ENUM_TABLE etab_dwst;\n#endif\n\n// Convert one parameter token to its value based on type\nvoid cvt_param(GLOBAL * gptr, char * token, enum ptype type, PVAL * val, char * desc) {\n  char buf[256];\n  int rc;\n\n  switch (type) {\n    case SINT:\n    case UINT:\n    case PINT:\n      rc = cvt_num((enum cvt_num_type)type, token, &val->u, buf, sizeof(buf));\n      if (rc) ERRX(\"%s ...; %s\", desc, buf);\n       break;\n    case DOUB:\n      rc = cvt_num((enum cvt_num_type)type, token, &val->d, buf, sizeof(buf));\n      if (rc) ERRX(\"%s ...; %s\", desc, buf);\n      break;\n    case STR:\n      if (0 == strcmp(token, \"%NULL\"))\n        val->s = NULL;\n      else if (0 == strcmp(token, \"%0\"))\n        val->s = \"\";\n      else\n        val->s = token;\n      break;\n    case REGX:\n      val->rxp = MALLOCX(sizeof(regex_t));\n      rc = regcomp(val->rxp, token, REG_EXTENDED | REG_NOSUB);\n      if (rc) {\n        regerror(rc, NULL, buf, sizeof(buf));\n        ERRX(\"%s; regex: %s\", desc, buf);\n      }\n      break;\n    case DBUF:\n      decode(&G, &etab_dbuf, token, \"Data buffer pattern type\", desc, val);\n      break;\n    #ifdef HIO\n    case HFLG:\n      decode(&G, &etab_hflg, token, \"hio flag\", desc, val);\n      break;\n    case HDSM:\n      decode(&G, &etab_hdsm, token, \"hio mode\", desc, val);\n      break;\n    case HERR:\n      decode(&G, &etab_herr, token, \"hio return\", desc, val);\n      break;\n    case HULM:\n      decode(&G, &etab_hulm, token, \"hio unlink mode\", desc, val);\n      break;\n    case HDSI:\n      decode_int(&G, &etab_hdsi, token, \"hio dataset ID\", desc, val);\n      break;\n    case HCPR:\n      decode(&G, &etab_hcpr, token, \"hio recommendation\", desc, val);\n      break;\n    case HVAT:\n      decode(&G, &etab_hvat, token, \"value assert type\", desc, val);\n      break;\n    case HVAO:\n      decode(&G, &etab_hvao, token, \"value assert operator\", desc, val);\n      break;\n    #if HIO_USE_DATAWARP\n    case DWST:\n      decode(&G, &etab_dwst, token, \"DataWarp stage type\", desc, val);\n      break;\n    #endif\n    #endif\n    case ONFF:\n      decode(&G, &etab_onff, token, \"ON / OFF value\", desc, val);\n      break;\n    default:\n      ERRX(\"internal error: param type invalid; token: \\\"%s\\\" desc: \\\"%s\\\" type: %d\", token, desc, type);\n  } // end switch\n}\n\n// Parse every action and its params from tokens into action array\n#define S (*state)\nvoid parse_action(GLOBAL * gptr, CTRL * state) {\n  int t = -1, j;\n  ACTION nact;\n  memset(&nact, 0, sizeof(nact));\n\n  msg_context_set_verbose(MY_MSG_CTX, 0);\n  msg_context_set_debug(MY_MSG_CTX, 0);\n\n  int comment_depth=0;\n  char * comment_msg = NULL;\n\n  for (size_t i=0; i<S.modsN; ++i) if (S.mods[i].init) S.mods[i].init(&G, S.mods[i].state);\n\n  while ( ++t < S.tokc ) {\n    if (0 == strcmp(S.tokv[t], \"/@\")) {\n      comment_depth++;\n      DBG3(\"comment start: S.tokv[%d]: %s depth: %d\", t, S.tokv[t], comment_depth);\n    } else if (0 == strcmp(S.tokv[t], \"/@@\")) {\n      comment_depth++;\n      comment_msg = STRDUPX(\"***\");\n      DBG3(\"comment start: S.tokv[%d]: %s depth: %d\", t, S.tokv[t], comment_depth);\n    } else if (0 == strcmp(S.tokv[t], \"@/\")) {\n      comment_depth = MAX(0, comment_depth - 1);\n      DBG3(\"comment end: S.tokv[%d]: %s depth: %d\", t, S.tokv[t], comment_depth);\n      if (comment_msg) {\n        nact.tokn = t;\n        nact.actn = S.actN;\n        nact.action = S.tokv[t];\n        nact.desc = ALLOC_PRINTF(\"action %d: /@@ %s\", S.actN, comment_msg);\n        nact.runner = cmsg_run;\n        nact.v[0].s = comment_msg;\n        add2actv(&G, &S, &nact);\n        comment_msg = NULL;\n      }\n    } else if (comment_depth > 0) {\n      if (comment_msg) comment_msg = STRCATRX(STRCATRX(comment_msg, \" \"), S.tokv[t]);\n      DBG3(\"Token in comment skipped: S.tokv[%d]: %s depth: %d\", t, S.tokv[t], comment_depth);\n    } else {\n      struct xexec_act_parse xap, *act_desc;\n      xap.cmd = S.tokv[t];\n      act_desc = bsearch(&xap, S.parse, S.parseN, sizeof(xap), parse_comp);\n      if (act_desc) {\n        DBG3(\"match: S.tokv[%d]: %s act_desc->cmd: %s\", t, S.tokv[t], act_desc->cmd);\n        nact.tokn = t;\n        nact.actn = S.actN;\n        nact.action = S.tokv[t];\n        nact.desc = ALLOC_PRINTF(\"action %d: %s\", S.actN, S.tokv[t]);\n\n        for (j = 0; j < MAX_PARAM; ++j) { // loop over params\n          if (act_desc->param[j] == NONE) break; // for j loop over params\n          t++;\n          if (t >= S.tokc) ERRX(\"action %d \\\"%s\\\" missing param %d\", nact.tokn, nact.action, j+1);\n          nact.desc = STRCATRX(STRCATRX(nact.desc, \" \"), S.tokv[t]);\n          DBG5(\"%s ...; act_desc->param[%d]: %d\", nact.desc, j, act_desc->param[j]);\n\n          cvt_param(&G, S.tokv[t], act_desc->param[j], &nact.v[j], nact.desc);\n        } // end for j loop\n        nact.runner = act_desc->runner;\n        nact.state = act_desc->state;\n        add2actv(&G, &S, &nact);\n        DBG2(\"Checking %s action.actn: %d\", nact.desc, nact.actn);\n        memset(&nact, 0, sizeof(nact));\n        S.tokn = t;  // next token after current action\n        if (act_desc->checker) act_desc->checker(&G, &S.actv[S.actN-1]);\n      } else {\n        ERRX(\"action %d: \\\"%s\\\" not recognized.\", t, S.tokv[t]);\n      }\n    }\n  }\n  if (S.lcur-S.lctl > 0) ERRX(\"Unterminated loop - more loop starts than loop ends\");\n  if (ifr_depth != 0) ERRX(\"Unterminated ifr - ifr without eif\");\n  if (comment_depth > 0) ERRX(\"Unterminated comment - more comment starts than comment ends\");\n  IFDBG4( for (int a=0; a<S.actN; a++) DBG0(\"S.actv[%d].desc: %s\", a, S.actv[a].desc) );\n  DBG1(\"Parse complete S.actN: %d\", S.actN);\n\n  IFDBG4( for (int i = 0; i< S.actN; ++i) { DBG4(\"ife_num: %d  %s\", S.actv[i].ife_num, S.actv[i].desc); } )\n\n\n\n}\n\n//----------------------------------------------------------------------------\n// Action runner - call run routines for action vector entries\n//----------------------------------------------------------------------------\nvoid run_action(GLOBAL * gptr, CTRL * state) {\n  S.act_cur = -1;\n\n  msg_context_set_verbose(MY_MSG_CTX, 1);\n  msg_context_set_debug(MY_MSG_CTX, 0);\n\n  for (size_t i=0; i<S.modsN; ++i) if (S.mods[i].init) S.mods[i].init(&G, S.mods[i].state);\n  while ( ++(S.act_cur) < S.actN ) {\n    VERB2(\"--- Running %s\", S.actv[S.act_cur].desc);\n    // Runner routine may modify variable a for looping or conditional\n    int old_a = S.act_cur;\n    errno = 0;\n    if (S.actv[S.act_cur].runner) S.actv[S.act_cur].runner(&G, &S.actv[S.act_cur]);\n    DBG3(\"Done %s; fails: %d ROF: %d act_cur: %d\", S.actv[old_a].desc, G.local_fails, (G.options & OPT_ROF) ? 1: 0, S.act_cur);\n    if (G.local_fails > 0 && !(G.options & OPT_ROF)) {\n      VERB0(\"Quiting due to fails: %d and ROF not set\", G.local_fails);\n      break;\n    }\n  }\n  VERB2(\"Action execution ended, Fails: %d\", G.local_fails);\n\n}\n#undef S\n\n//----------------------------------------------------------------------------\n// Signal handler - init and run\n//----------------------------------------------------------------------------\n#undef G\n#define G (*xexec_global_ptr)\nvoid xexec_signal_handler(int signum, siginfo_t *siginfo  , void * ptr) {\n  // Verbose name for this routine to better show up on backtrace\n  MSGE(\"xexec received signal: %d (%s) from pid: %d\", signum, sys_siglist[signum], siginfo->si_pid);\n\n  #ifdef __linux__\n    psiginfo(siginfo, \"xexec received signal:\");\n  #endif\n\n  // Print backtrace on signals potentially caused by program error\n  if ( SIGILL  == signum ||\n       SIGABRT == signum ||\n       SIGFPE  == signum ||\n       SIGBUS  == signum ||\n       SIGSEGV == signum ) {\n    void * buf[128];\n    int n = backtrace(buf, DIM1(buf));\n    backtrace_symbols_fd(buf, n, STDERR_FILENO);\n    fflush(stderr);\n  }\n\n}\n\nvoid sig_add(int signum) {\n  struct sigaction sa;\n   \n  sa.sa_sigaction = xexec_signal_handler;\n  // Provide siginfo structure and reset signal handler to default\n  sa.sa_flags = SA_SIGINFO | SA_RESETHAND;\n  sigaction(signum, &sa, NULL);\n}\n\nvoid sig_init(void) {\n  // Intercept every known signal\n  sig_add(SIGHUP);\n  sig_add(SIGINT);\n  sig_add(SIGQUIT);\n  sig_add(SIGILL);\n  sig_add(SIGABRT);\n  sig_add(SIGKILL);\n  sig_add(SIGBUS);\n  sig_add(SIGFPE);\n  sig_add(SIGSEGV);\n  sig_add(SIGSYS);\n  sig_add(SIGPIPE);\n  sig_add(SIGALRM);\n  sig_add(SIGTERM);\n  sig_add(SIGSTOP);\n  sig_add(SIGTSTP);\n  sig_add(SIGCONT);\n  sig_add(SIGCHLD);\n  sig_add(SIGTTIN);\n  sig_add(SIGTTOU);\n  sig_add(SIGIO);\n  sig_add(SIGXCPU);\n  sig_add(SIGXFSZ);\n  sig_add(SIGVTALRM);\n  sig_add(SIGPROF);\n  sig_add(SIGWINCH);\n  sig_add(SIGUSR1);\n  sig_add(SIGUSR2);\n}\n#undef G\n\n//----------------------------------------------------------------------------\n// Main - write help, call parser / dispatcher\n//----------------------------------------------------------------------------\nint main(int argc, char * * argv) {\n  // Establish global data - must be first since everything uses it\n  xexec_global_ptr = calloc(1, sizeof(GLOBAL));\n  if (!xexec_global_ptr) {\n    fprintf(stderr, \"calloc %lu bytes failed, exitting\\n\", sizeof(GLOBAL));\n    return EXIT_FAILURE;\n  }\n  GLOBAL * gptr = xexec_global_ptr;\n  #define G (*gptr)\n  G.test_name = \"<unnamed>\";\n\n  msg_context_init(MY_MSG_CTX, 0, 0);\n  set_msg_id(&G);\n\n  #define S ctrl_state\n\n  add2tokv(&G, &S, argc-1, argv+1); // Make initial copy of argv so im works\n\n  // Parse init and env option values\n  int set, clear, rc;\n  enum options newopt;\n  char * xexec_opt = getenv(\"XEXEC_OPT\");\n\n  parse_opt(&G, \"internal options_init\", options_init, &set, &clear);\n  newopt = (enum options) (clear & set);\n\n  if (xexec_opt) { \n    parse_opt(&G, \"XEXEC_OPT env var\", xexec_opt, &set, &clear);\n    newopt = (enum options) (clear & (set | newopt));\n  }   \n  G.options = newopt;\n\n  if (G.options & OPT_SIGHAND) {\n    sig_init();\n  }\n\n  // Add action routines to parse table\n  rc = xexec_ctrl_install(&G); if (rc) ERRX(\"xexec_ctrl_init rc: %d\", rc);\n  rc = xexec_base_install(&G); if (rc) ERRX(\"xexec_base_init rc: %d\", rc);\n  #ifdef MPI\n  rc = xexec_mpi_install(&G);  if (rc) ERRX(\"xexec_mpi_init rc: %d\", rc);\n  #endif // MPI \n  rc = xexec_fio_install(&G);  if (rc) ERRX(\"xexec_fio_init rc: %d\", rc);\n  rc = xexec_hio_install(&G);  if (rc) ERRX(\"xexec_hio_init rc: %d\", rc);\n\n  if (argc <= 1 || 0 == strncmp(\"-h\", argv[1], 2)) {\n    fprintf(stdout, \"%s\", help_pre);\n    for (size_t i=0; i<S.modsN; ++i) if (S.mods[i].help) S.mods[i].help(&G, S.mods[i].state, stdout);\n    fprintf(stdout, help_post, cvt_num_suffix());\n    return 0;\n  }\n\n  // Make two passes through args, first to check, second to run.\n  G.options = newopt;\n  parse_action(&G, &S);\n\n  G.options = newopt;\n  run_action(&G, &S);\n\n  // Suppress SUCCESS result message from all but rank 0\n  // Suppress  if G.gather_fails, not rank 0 and local fails = 0\n  if (G.gather_fails && G.my_prior_rank != 0 && G.local_fails == 0) {\n    // do nothing\n  } else {\n    if (G.local_fails + G.global_fails == 0) { \n\n      if (G.options & OPT_SMSGV1) { // SMSGV1 option allows really quiet output on V0\n        VERB1(\"xexec \" XEXEC_VERSION \" done.  Result: %s  Fails: %d  Test name: %s\",\n              \"SUCCESS\", G.local_fails + G.global_fails, G.test_name);\n      } else {\n        VERB0(\"xexec \" XEXEC_VERSION \" done.  Result: %s  Fails: %d  Test name: %s\",\n              \"SUCCESS\", G.local_fails + G.global_fails, G.test_name);\n      }\n\n    } else { // But failure always prints message\n      VERB0(\"xexec done.  Result: %s  Fails: %d  Test name: %s\",\n            \"FAILURE\", G.local_fails + G.global_fails, G.test_name);\n    }\n\n    // Pavilion message\n    if (G.options & OPT_PAVM) {\n      printf(\"<result> %s <<< xexec done.  Test name: %s  Fails: %d >>>\\n\",\n             (G.local_fails + G.global_fails) ? \"fail\" : \"pass\",\n             G.test_name, G.local_fails + G.global_fails);\n    }\n  }\n\n  rc = (G.local_fails + G.global_fails) ? EXIT_FAILURE : EXIT_SUCCESS;\n\n  if (rc != EXIT_SUCCESS && (G.options & OPT_FAILDLY) ) {\n    VERB0(\"60 second sleep due to opt +FAILDLY\");\n    sleep(60);\n  }\n\n  #ifdef MPI\n  if (rc != EXIT_SUCCESS && mpi_active()) {\n    VERB0(\"MPI_abort due to error exit from main with MPI active rc: %d\", rc);\n    fflush(stdout);\n    fflush(stderr);\n    MPI_CK(MPI_Abort(G.mpi_comm, rc));\n  }\n  #endif // MPI\n\n  return rc;\n}\n\nint xexec_act_add(GLOBAL *gptr, struct xexec_act_parse * parse_add, int n_add, \n                  module_init * init, void * state, module_help * help) {\n  S.parse = REALLOCX(S.parse, sizeof(struct xexec_act_parse) * (S.parseN + n_add));\n\n  for (int i=0; i<n_add; ++i) {\n    S.parse[i+S.parseN] = parse_add[i];\n    S.parse[i+S.parseN].state = state;\n  }\n  S.parseN += n_add;\n  qsort(S.parse, S.parseN, sizeof(struct xexec_act_parse), parse_comp);\n \n  for (int i=0; i<(S.parseN-1); ++i) {\n    if (!strcmp(S.parse[i].cmd, S.parse[i+1].cmd)) ERRX(\"Duplicate action name: %s\", S.parse[i].cmd);      \n  } \n \n  S.mods = REALLOCX(S.mods, sizeof(struct mod_table) * ++S.modsN);\n  S.mods[S.modsN-1].init = init;\n  S.mods[S.modsN-1].help = help;\n  S.mods[S.modsN-1].state = state;\n  \n  return 0;\n}\n\n// --- end of xexec.c ---\n",
        "/tmp/vanessa/spack-stage/spack-stage-libhio-master-nrfvlowvo6m3roe76nnwdjzmnqna7vvk/spack-src/test/xexec/xexec_base.c": "/* -*- Mode: C; c-basic-offset:2 ; indent-tabs-mode:nil -*- */\n/*\n * Copyright (c) 2014-2016 Los Alamos National Security, LLC.  All rights\n *                         reserved.\n * $COPYRIGHT$\n *\n * Additional copyrights may follow\n *\n * $HEADER$\n */\n\n#include \"xexec.h\"\n#include <unistd.h>\n#include <errno.h>\n#include <string.h>\n#include <signal.h>\n#include <math.h>\n#ifdef DLFCN\n  #include <dlfcn.h>\n#endif  // DLFCN\n\n//----------------------------------------------------------------------------\n// xexec base module - contains basic functions\n//----------------------------------------------------------------------------\n#define G (*gptr)\n#define MY_MSG_CTX (&G.xexec_msg_context)\n\nstatic char * help =\n  \"  v <level>     set verbosity level\\n\"\n  \"                0 = program start and end, failures\\n\"\n  \"                1 = 0 + summary performance messages\\n\"\n  \"                2 = 1 + detailed performance messages\\n\"\n  \"                3 = 2 + API result messages\\n\"\n  \"  d <level>     set debug message level\\n\"\n  \"                0 = no debug messages\\n\"\n  \"                1 = Action start messages\\n\"\n  \"                2 = 1 + API pre-call messages\\n\"\n  \"                3 = 2 + action parsing messages\\n\"\n  \"                4 = 3 + detailed action progress messages\\n\"\n  \"                5 = 4 + detailed repetitive action progress messages - if\\n\"\n  \"                enabled at compile time which will impact performance.\\n\"\n  \"  o <count>     write <count> lines to stdout\\n\"\n  \"  e <count>     write <count> lines to stderr\\n\"\n  \"  s <seconds>   sleep for <seconds>\\n\"\n  \"  srr <seed>    seed random rank - seed RNG with <seed> mixed with rank (if MPI)\\n\"\n  \"  va <bytes>    allocate <bytes> of memory with malloc\\n\"\n  \"  vt <stride>   touch latest allocation every <stride> bytes\\n\"\n  \"  vw            write data pattern to latest allocation\\n\" \n  \"  vr            read (and check) data pattern from latest allocation\\n\" \n  \"  vf            free latest allocation\\n\"\n  \"  hx <min> <max> <blocks> <limit> <count>\\n\"\n  \"                Perform <count> malloc/touch/free cycles on memory blocks ranging\\n\"\n  \"                in size from <min> to <max>.  Allocate no more than <limit> bytes\\n\"\n  \"                in <blocks> separate allocations.  Sequence and sizes of\\n\"\n  \"                allocations are randomized.\\n\"\n  \"  ni <size> <count>\\n\"\n  \"                Creates <count> blocks of <size> doubles each.  All\\n\"\n  \"                but one double in each block is populated with sequential\\n\"\n  \"                values starting with 1.0.\\n\"\n  \"  nr <rep> <stride>\\n\"\n  \"                The values in each block are added and written to the\\n\"\n  \"                remaining double in the block. The summing of the block is\\n\"\n  \"                repeated <rep> times.  All <count> blocks are processed in\\n\"\n  \"                sequence offset by <stride>. The sum of all blocks is\\n\"\n  \"                computed and compared with an expected value.\\n\"\n  \"                <size> must be 2 or greater, <count> must be 1 greater than\\n\"\n  \"                a multiple of <stride>.\\n\"\n  \"  nf            Free allocated blocks\\n\"\n  #ifdef DLFCN\n  \"  dlo <name>    Issue dlopen for specified file name\\n\"\n  \"  dls <symbol>  Issue dlsym for specified symbol in most recently opened library\\n\"\n  \"  dlc           Issue dlclose for most recently opened library\\n\"\n  #endif // DLFCN\n  \"  grep <regex>  <file>  Search <file> and print (verbose 1) matching lines [1]\\n\"\n  \"                <file> = \\\"@ENV\\\" searches environment\\n\"\n  #ifdef __linux__\n  \"  dca           Display CPU Affinity\\n\"\n  #endif\n  \"  k <signal>    raise <signal> (number)\\n\"\n  \"  x <status>    exit with <status>\\n\"\n  \"  segv          force SIGSEGV\\n\" \n;\n\nstruct memblk {            // memblk queue element\n  size_t size;\n  struct memblk * prev;\n};\n\nstatic struct base_state {\n  int memcount;            // Number of entries in memblk queue\n  struct memblk * memptr;  // memblk queue\n  double * fp_nums;\n  U64 flap_size;\n  U64 fp_count;\n\n  #ifdef DLFCN\n    int dl_num;\n    void * dl_handle[20];\n  #endif\n} base_state;\n\nMODULE_INIT(xexec_base_init) {\n  struct base_state * s = state;\n  #ifdef DLFCN\n    s->dl_num = -1;\n  #endif\n  return 0;\n}\n\nMODULE_HELP(xexec_base_help) {\n  fprintf(file, \"%s\", help);\n  return 0;\n}\n\n//----------------------------------------------------------------------------\n// v, d (verbose, debug) action handlers\n//----------------------------------------------------------------------------\n#define S (* ((struct base_state *)(actionp->state)) )\n\nACTION_CHECK(verbose_check) {\n  int verbose = V0.u;\n  if (verbose > MAX_VERBOSE) ERRX(\"%s: Verbosity level %d > maximum %d\", A.desc, verbose, MAX_VERBOSE);\n}\n\nACTION_RUN(verbose_run) {\n  int verbose = V0.u;\n  msg_context_set_verbose(MY_MSG_CTX, verbose);\n  VERB2(\"Verbosity level set to %d\", verbose);\n}\n\nACTION_CHECK(debug_check) {\n  int debug = V0.u;\n  if (debug > DBGMAXLEV) ERRX(\"%s: requested debug level %d > maximum %d.\"\n                              \" Rebuild with -DDBGMAXLEV=<n> to increase\"\n                              \" (see comments in source.)\", A.desc, debug, DBGMAXLEV);\n  if (A.actn == 0) {\n    msg_context_set_debug(MY_MSG_CTX, debug);\n    VERB2(\"Parse debug level set to %d\", debug);\n  }\n}\n\nACTION_RUN(debug_run) {\n  int debug = V0.u;\n  if (A.actn != 0) {\n    msg_context_set_debug(MY_MSG_CTX, debug);\n    VERB2(\"Run debug level set to %d\", debug);\n  }\n}\n\n//----------------------------------------------------------------------------\n// o, e (stdout, stderr) action handlers\n//----------------------------------------------------------------------------\nACTION_RUN(stdout_run) {\n  U64 line;\n  for (line = 1; line <= V0.u; line++) {\n    // Message padded to exactly 100 bytes long.\n    MSG(\"action %-4u stdout line %-8lu of %-8lu %*s\", A.actn + 1, line, V0.u, 34 - G.id_string_len, \"\");\n  }\n}\n\nACTION_RUN(stderr_run) {\n  U64 line;\n  for (line = 1; line <= V0.u; line++) {\n    // Message padded to exactly 100 bytes long.\n    MSGE(\"action %-4u stderr line %-8lu of %-8lu %*s\", A.actn + 1, line, V0.u, 34 - G.id_string_len, \"\");\n  }\n}\n\n//----------------------------------------------------------------------------\n// s (sleep) action handler\n//----------------------------------------------------------------------------\nACTION_CHECK(sleep_check) {\n  if (V0.d < 0) ERRX(\"%s; negative sleep seconds\", A.desc);\n}\n\nACTION_RUN(sleep_run) {\n  fsleep(V0.d);\n}\n\n//----------------------------------------------------------------------------\n// srr (seed random rank) action handler\n//----------------------------------------------------------------------------\nACTION_RUN(srr_run) {\n  I64 seed = V0.u;\n  #define PR231_100 (U64)2147481317              // Prime close to but < 2^31\n  #define PR231_200 (U64)2147479259              // Prime close to but < 2^31\n  unsigned short seed16v[3];\n\n  // Multiply by prime so seed48(rank+1, seed) != seed(48(rank, seed+1)\n  seed *= PR231_100;\n  #ifdef MPI\n    seed += (G.myrank * PR231_200);\n  #endif\n  seed16v[0] = seed & 0xFFFF;\n  seed16v[1] = seed >> 16;\n  seed16v[2] = 0;\n  DBG3(\"srr seed: %lld; calling seed48(0x%04hX 0x%04hX 0x%04hX)\", seed, seed16v[2], seed16v[1], seed16v[0]);\n  seed48(seed16v);\n}\n\n//----------------------------------------------------------------------------\n// va, vt, vf (memory allocate, touch, free) action handlers\n//----------------------------------------------------------------------------\n\nACTION_CHECK(va_check) {\n  S.memcount++;\n}\n\nACTION_CHECK(vtwr_check) {\n  if (S.memcount <= 0) ERRX(\"%s: %s without corresponding va allocation\", A.desc, A.action);\n}\n\nACTION_CHECK(vf_check) {\n  if (S.memcount-- <= 0) ERRX(\"%s: free without corresponding allocate\", A.desc);\n}\n\n\nACTION_RUN(va_run) {\n  S.memcount++;\n  size_t len = V0.u;\n  struct memblk * p;\n  DBG2(\"Calling malloc(%lld)\", len);\n  p = (struct memblk *)malloc(len);\n  VERB3(\"malloc returns %p\", p);\n  if (p) {\n    p->size = len;\n    p->prev = S.memptr;\n    S.memptr = p;\n  } else {\n    VERB0(\"mem_hand - Warning: malloc returned NULL\");\n    S.memcount--;\n  }\n}\n\nACTION_RUN(vt_run) {\n  U64 stride = V0.u;\n  char *p, *end_p1;\n  ETIMER tmr;\n  if (S.memcount > 0) {\n    p = (char*)S.memptr + sizeof(struct memblk);\n    end_p1 = p + S.memptr->size;\n    DBG4(\"Touching memory at %p, length 0x%llx, stride: %lld\", p, S.memptr->size, stride);\n    ETIMER_START(&tmr);\n    while (p < end_p1) {\n      DBG5(\"touch S.memptr: %p memlen: 0x%llx: end_p1: %p p: %p\", S.memptr, S.memptr->size, end_p1, p);\n      *p = 'x';\n      p += stride;\n    }\n    double delta_t = ETIMER_ELAPSED(&tmr);\n    U64 count = S.memptr->size / stride;\n    prt_mmmst(&G, (double)count/delta_t, \"vt rate\", \"TpS\");\n\n  } else {\n    VERB0(\"mem_hand - Warning: no memory allocation to touch\");\n  }\n}\n\nACTION_RUN(vw_run) {\n  if (S.memcount > 0) {\n    ETIMER tmr;\n    char * p = (char*)S.memptr + sizeof(struct memblk);\n    size_t len = S.memptr->size - sizeof(struct memblk);\n    if (! G.wbuf_ptr ) dbuf_init(&G,RAND22, 20 * 1024 * 1024); \n    DBG4(\"Writing memory at %p, length 0x%llx\", p, len);\n    void * expected = get_wbuf_ptr(&G, \"vw\", 0, (U64)p);\n    ETIMER_START(&tmr);\n    memcpy(p, expected, len);\n    double delta_t = ETIMER_ELAPSED(&tmr);\n    prt_mmmst(&G, (double)len/delta_t, \"vw rate\", \"B/S\");\n  } else {\n    VERB0(\"mem_hand - Warning: no memory allocation to write\");\n  }\n}\n\nACTION_RUN(vr_run) {\n  if (S.memcount > 0) {\n    ETIMER tmr;\n    char * p = (char*)S.memptr + sizeof(struct memblk);\n    size_t len = S.memptr->size - sizeof(struct memblk);\n    if (! G.wbuf_ptr ) dbuf_init(&G,RAND22, 20 * 1024 * 1024); \n    DBG4(\"Reading memory at %p, length 0x%llx\", p, len);\n    ETIMER_START(&tmr);\n    if (G.options & OPT_RCHK) {\n      int rc = check_read_data(&G, \"vr\", p, len, 0, (U64)p);\n      if (rc) { \n        G.local_fails++;\n      }\n    } else {\n      memcpy(G.rbuf_ptr, p, len);\n    }\n    double delta_t = ETIMER_ELAPSED(&tmr);\n    prt_mmmst(&G, (double)len/delta_t, \"vr rate\", \"B/S\");\n  } else {\n    VERB0(\"mem_hand - Warning: no memory allocation to read\");\n  }\n}\n\nACTION_RUN(vf_run) {\n  if (S.memcount > 0) {\n    struct memblk * p;\n    p = S.memptr->prev;\n    DBG2(\"Calling free(%p)\", S.memptr);\n    free(S.memptr);\n    S.memptr = p;\n    S.memcount--;\n  } else {\n    VERB0(\"mem_hand - Warning: no memory allocation to free\");\n  }\n}\n\n//----------------------------------------------------------------------------\n// hx (heap exerciser) action handler\n//----------------------------------------------------------------------------\nACTION_CHECK(hx_check) {\n  U64 min = V0.u;\n  U64 max = V1.u;\n  U64 limit = V3.u;\n\n  if (min < 1) ERRX(\"%s; min < 1\", A.desc);\n  if (min > max) ERRX(\"%s; min > max\", A.desc);\n  if (max > limit) ERRX(\"%s; max > limit\", A.desc);\n}\n\nACTION_RUN(hx_run) {\n  U64 min = V0.u;\n  U64 max = V1.u;\n  U64 blocks = V2.u;\n  U64 limit = V3.u;\n  U64 count = V4.u;\n\n  double min_l2 = log2(min), max_l2 = log2(max);\n  double range_l2 = max_l2 - min_l2;\n  U64 i, n, k, total = 0;\n  size_t b;\n  ETIMER tmr;\n\n  struct {\n    void * ptr;\n    size_t size;\n  } blk [ blocks ];\n\n  struct stat {\n    U64 count;\n    double atime;\n    double ftime;\n  } stat [ 1 + (int)log2(max) ];\n\n  // Set up\n  VERB1(\"heapx starting; min: %llu max: %llu blocks: %llu limit: %llu count: %llu\", min, max, blocks, limit, count);\n\n  for (n=0; n<blocks; ++n) {\n    blk[n].ptr = NULL;\n    blk[n].size = 0;\n  }\n\n  #ifdef __clang_analyzer__\n    memset(stat, 0, sizeof(stat));\n  #endif\n  for (b=0; b<sizeof(stat)/sizeof(struct stat); ++b) {\n    stat[b].count = 0;\n    stat[b].atime = 0.0;\n    stat[b].ftime = 0.0;\n  }\n\n  // Do allocations\n  for (i=0; i<count; ++i) {\n\n    n = random()%blocks;\n    if (blk[n].ptr) {\n      DBG4(\"heapx: total: %llu; free %td bytes\", total, blk[n].size);\n      b = (int) log2(blk[n].size);\n      ETIMER_START(&tmr);\n      free(blk[n].ptr);\n      stat[b].ftime += ETIMER_ELAPSED(&tmr);\n      total -= blk[n].size;\n      blk[n].size = 0;\n      blk[n].ptr = 0;\n    }\n\n    // blk[n].size = random()%(max - min + 1) + min;\n\n    blk[n].size = (size_t)exp2( ((double)random() / (double)RAND_MAX * range_l2 ) + min_l2 );\n\n    // Make sure limit will not be exceeded\n    while (blk[n].size + total > limit) {\n      k = random()%blocks;\n      if (blk[k].ptr) {\n        DBG4(\"heapx: total: %llu; free %td bytes\", total, blk[k].size);\n        b = (int) log2(blk[k].size);\n        ETIMER_START(&tmr);\n        free(blk[k].ptr);\n        stat[b].ftime += ETIMER_ELAPSED(&tmr);\n        total -= blk[k].size;\n        blk[k].size = 0;\n        blk[k].ptr = 0;\n      }\n    }\n\n    VERB2(\"heapx: total: %llu; malloc and touch %td bytes\", total, blk[n].size);\n    b = (int) log2(blk[n].size);\n    ETIMER_START(&tmr);\n    blk[n].ptr = malloc(blk[n].size);\n    stat[b].atime += ETIMER_ELAPSED(&tmr);\n    if (!blk[n].ptr) ERRX(\"%s: heapx: malloc %td bytes failed\", A.desc, blk[n].size);\n    total += blk[n].size;\n    stat[b].count++;\n    memset(blk[n].ptr, 0xA5, blk[n].size);\n  }\n\n   // Clean up remainder\n  for (n=0; n<blocks; ++n) {\n    if (blk[n].ptr) {\n      DBG4(\"heapx: total: %llu; free %td bytes\", total, blk[n].size);\n      b = (int) log2(blk[n].size);\n      ETIMER_START(&tmr);\n      free(blk[n].ptr);\n      stat[b].ftime += ETIMER_ELAPSED(&tmr);\n      total -= blk[n].size;\n      blk[n].size = 0;\n      blk[n].ptr = 0;\n    }\n  }\n\n  // Reporting\n  RANK_SERIALIZE_START\n  for (b=0; b<sizeof(stat)/sizeof(struct stat); ++b) {\n    if (stat[b].count > 0) {\n      VERB2(\"heapx: bucket start: %lld count: %lld alloc_time: %.3f uS free_time %.3f uS\", (long)exp2(b),\n      stat[b].count, stat[b].atime*1e6/(double)stat[b].count, stat[b].ftime*1e6/(double)stat[b].count);\n    }\n  }\n  RANK_SERIALIZE_END\n\n}\n\n//----------------------------------------------------------------------------\n// ni, nr, nf (floating point addition init, run, free) action handlers\n//----------------------------------------------------------------------------\nACTION_CHECK(ni_check) {\n  S.flap_size = V0.u;\n  S.fp_count = V1.u;\n  if (S.flap_size < 2) ERRX(\"%s; size must be at least 2\", A.desc);\n}\n\nACTION_CHECK(nr_check) {\n  U64 rep = V0.u;\n  U64 stride = V1.u;\n\n  if (!S.flap_size) ERRX(\"%s; nr without prior ni\", A.desc);\n  if ((S.fp_count-1)%stride != 0) ERRX(\"%s; S.fp_count-1 must equal a multiple of stride\", A.desc);\n  if (rep<1) ERRX(\"%s; rep must be at least 1\", A.desc);\n}\n\nACTION_CHECK(nf_check) {\n  if (!S.flap_size) ERRX(\"%s; nf without prior ni\", A.desc);\n  S.flap_size = 0;\n}\n\nACTION_RUN(ni_run) {\n  S.flap_size = V0.u;\n  S.fp_count = V1.u;\n  U64 N = S.flap_size * S.fp_count;\n\n  int rc = posix_memalign((void * *)&S.fp_nums, 4096, N * sizeof(double));\n  if (rc) ERRX(\"%s; posix_memalign %d doubles failed: %s\", A.desc, N, strerror(rc));\n\n  U64 iv = 0;\n  for (U64 i=0; i<N; ++i) {\n    if (i%S.flap_size != 0) {\n      S.fp_nums[i] = (double) ++iv;\n      DBG4(\"%s; S.fp_nums[%d] = %d\", A.desc, i, iv);\n    }\n  }\n}\n\nACTION_RUN(nr_run) {\n  double sum, delta_t, predicted;\n  U64 b, ba, r, d, fp_add_ct, max_val;\n  U64 N = S.flap_size * S.fp_count;\n  U64 rep = V0.u;\n  U64 stride = V1.u;\n  ETIMER tmr;\n\n  max_val = (S.flap_size-1) * S.fp_count;\n  predicted = (pow((double) max_val, 2.0) + (double) max_val ) / 2 * (double)rep;\n  DBG1(\"%s; v: %d predicted: %f\", A.desc, max_val, predicted);\n  fp_add_ct = (max_val * rep) + S.fp_count;\n\n  for (U64 i=0; i<N; i+=S.flap_size) {\n    S.fp_nums[i] = 0.0;\n      DBG3(\"%s; S.fp_nums[%d] = %d\", A.desc, i, 0);\n  }\n\n  DBG1(\"flapper starting; size: %llu S.fp_count: %llu rep: %llu stride: %llu\", S.flap_size, S.fp_count, rep, stride);\n  ETIMER_START(&tmr);\n\n  for (b=0; b<S.fp_count; ++b) {\n    ba = b * stride % S.fp_count;\n    U64 d_sum = ba*S.flap_size;\n    U64 d_first = d_sum + 1;\n    U64 d_lastp1 = (ba+1)*S.flap_size;\n    DBG3(\"b: %llu ba:%llu\", b, ba);\n    for (r=0; r<rep; ++r) {\n      sum = S.fp_nums[d_sum];\n      for (d=d_first; d<d_lastp1; ++d) {\n        sum += S.fp_nums[d];\n        DBG3(\"%s; val: %f sum: %f\", A.desc, S.fp_nums[d], sum)\n      }\n      S.fp_nums[d_sum] = sum;\n    }\n  }\n\n  sum = 0.0;\n  for (d=0; d<S.fp_count*S.flap_size; d+=S.flap_size) {\n    sum += S.fp_nums[d];\n  }\n\n  delta_t = ETIMER_ELAPSED(&tmr);\n\n  VERB2(\"flapper done; FP Adds %llu, predicted: %e sum: %e delta: %e\", fp_add_ct, predicted, sum, sum - predicted);\n  VERB2(\"FP Adds: %llu, time: %f Seconds, MFLAPS: %e\", fp_add_ct, delta_t, (double)fp_add_ct / delta_t / 1000000.0);\n  prt_mmmst(&G, delta_t, \" Add time\", \"S\");\n  prt_mmmst(&G, (double)fp_add_ct / delta_t, \"FLAP rate\", \"F/S\" );\n}\n\nACTION_RUN(nf_run) {\n  S.flap_size = 0;\n  FREEX(S.fp_nums);\n}\n\n//----------------------------------------------------------------------------\n// dlo, dls, dlc (dl open, sym, close) action handlers\n//----------------------------------------------------------------------------\n#ifdef DLFCN\nACTION_CHECK(dlo_check) {\n  if (++(S.dl_num) >= (int)DIM1(S.dl_handle)) ERRX(\"%s; too many dlo commands, limit is %d\", A.desc, DIM1(S.dl_handle));\n}\n\nACTION_CHECK(dls_check) {\n  if (S.dl_num < 0) ERRX(\"%s; o currently open dynamic library\", A.desc);\n}\n\nACTION_CHECK(dlc_check) {\n  if (S.dl_num-- < 0) ERRX(\"%s; no currently open dynamic library\", A.desc);\n}\n\nACTION_RUN(dlo_run) {\n  char * name = V0.s;\n  S.dl_handle[++S.dl_num] = dlopen(name, RTLD_NOW);\n  VERB3(\"%s; dlopen(%s) returns %p\", A.desc, name, S.dl_handle[S.dl_num]);\n  if (!S.dl_handle[S.dl_num]) {\n    VERB0(\"%s; dlopen failed: %s\", A.desc, dlerror());\n    S.dl_num--;\n  }\n}\n\nACTION_RUN(dls_run) {\n  char * symbol = V0.s;\n  char * error;\n  void * sym = dlsym(S.dl_handle[S.dl_num], symbol);\n  VERB3(\"%s; dlsym(%s) returns %p\", A.desc, symbol, sym);\n  error = dlerror();\n  if (error) VERB0(\"%s; dlsym error: %s\", A.desc, error);\n}\n\nACTION_RUN(dlc_run) {\n  int rc = dlclose(S.dl_handle[S.dl_num--]);\n  VERB3(\"%s; dlclose returns %d\", A.desc, rc);\n  if (rc) VERB0(\"%s; dlclose error: %s\", A.desc, dlerror());\n}\n#endif // DLFC\n\n//----------------------------------------------------------------------------\n// grep action handler\n//----------------------------------------------------------------------------\nextern char * * environ;\n\nACTION_RUN(grep_run) {\n  char * fname = V1.s;\n\n  if (0 == strcmp(fname, \"@ENV\")) {\n    for (char ** eptr = environ; *eptr; eptr++) {\n      if (!rx_run(&G, 0, actionp, *eptr)) {\n        VERB1(\"grep: %s\", *eptr);\n      }\n    }\n  } else {\n    char line[512];\n    FILE * f = fopen(fname, \"r\");\n    if (!f) ERRX(\"%s: error opening \\\"%s\\\" %s\", A.desc, fname, strerror(errno));\n    while (fgets(line, sizeof(line), f)) {\n      if (!rx_run(&G, 0, actionp, line)) {\n        char * last = line + strlen(line) - 1;\n        if ('\\n' == *last) *last = '\\0';\n        VERB1(\"grep: %s\", line);\n      }\n    }\n    fclose(f);\n  }\n}\n\n//----------------------------------------------------------------------------\n// dca action handlers\n//----------------------------------------------------------------------------\n#ifdef __linux__\nACTION_RUN(dca_run) {\n  I64 aff = GetCPUaffinity();\n  long np = sysconf(_SC_NPROCESSORS_CONF);\n  RANK_SERIALIZE_START\n  if (aff >= 0) {\n    VERB0(\"_SC_NPROCESSORS_CONF: %d  CPU Affinity: %ld\", np, aff);\n  } else if ( aff < -1 ) {\n    VERB0(\"_SC_NPROCESSORS_CONF: %d  CPU Affinity Mask: 0x%lX\", np, -aff);\n  } else {\n    VERB0(\"_SC_NPROCESSORS_CONF: %d  CPU Affinity: None\", np);\n  }\n  RANK_SERIALIZE_END\n}\n#endif // __linux__\n\n//----------------------------------------------------------------------------\n// k, x (signal, exit) action handlers\n//----------------------------------------------------------------------------\nACTION_RUN(raise_run) {\n  VERB0(\"Raising signal %d\", V0.u);\n  raise(V0.u);\n}\n\nACTION_RUN(exit_run) {\n  VERB0(\"Exiting with status %d\", V0.u);\n  exit(V0.u);\n}\n\nACTION_RUN(segv_run) {\n  VERB0(\"Forcing SIGSEGV\"); \n  #ifndef __clang_analyzer__\n    * (volatile char *) 0 = '\\0';\n  #endif\n}\n\n//----------------------------------------------------------------------------\n// xexec_base - init foundational commands\n//----------------------------------------------------------------------------\nMODULE_INSTALL(xexec_base_install) {\n  struct xexec_act_parse parse[] = {\n  // Command   V0    V1    V2    V3    V4     Check          Run\n    {\"v\",     {UINT, NONE, NONE, NONE, NONE}, verbose_check, verbose_run },\n    {\"d\",     {UINT, NONE, NONE, NONE, NONE}, debug_check,   debug_run   },\n    {\"o\",     {UINT, NONE, NONE, NONE, NONE}, NULL,          stdout_run  },\n    {\"e\",     {UINT, NONE, NONE, NONE, NONE}, NULL,          stderr_run  },\n    {\"s\",     {DOUB, NONE, NONE, NONE, NONE}, sleep_check,   sleep_run   },\n    {\"srr\",   {SINT, NONE, NONE, NONE, NONE}, NULL,          srr_run     },\n    {\"va\",    {UINT, NONE, NONE, NONE, NONE}, va_check,      va_run      },\n    {\"vt\",    {PINT, NONE, NONE, NONE, NONE}, vtwr_check,    vt_run      },\n    {\"vw\",    {NONE, NONE, NONE, NONE, NONE}, vtwr_check,    vw_run      },\n    {\"vr\",    {NONE, NONE, NONE, NONE, NONE}, vtwr_check,    vr_run      },\n    {\"vf\",    {NONE, NONE, NONE, NONE, NONE}, vf_check,      vf_run      },\n    {\"hx\",    {UINT, UINT, UINT, UINT, UINT}, hx_check,      hx_run      },\n    {\"ni\",    {UINT, PINT, NONE, NONE, NONE}, ni_check,      ni_run      },\n    {\"nr\",    {PINT, PINT, NONE, NONE, NONE}, nr_check,      nr_run      },\n    {\"nf\",    {NONE, NONE, NONE, NONE, NONE}, nf_check,      nf_run      },\n    #ifdef DLFCN\n    {\"dlo\",   {STR,  NONE, NONE, NONE, NONE}, dlo_check,     dlo_run     },\n    {\"dls\",   {STR,  NONE, NONE, NONE, NONE}, dls_check,     dls_run     },\n    {\"dlc\",   {NONE, NONE, NONE, NONE, NONE}, dlc_check,     dlc_run     },\n    #endif // DLFCN\n    {\"grep\",  {REGX, STR,  NONE, NONE, NONE}, NULL,          grep_run    },\n    #ifdef __linux__\n    {\"dca\",   {NONE, NONE, NONE, NONE, NONE}, NULL,          dca_run     },\n    #endif // __linux__\n    {\"k\",     {UINT, NONE, NONE, NONE, NONE}, NULL,          raise_run   },\n    {\"x\",     {UINT, NONE, NONE, NONE, NONE}, NULL,          exit_run    },\n    {\"segv\",  {NONE, NONE, NONE, NONE, NONE}, NULL,          segv_run    },\n  };\n\n  xexec_act_add(&G, parse, DIM1(parse), xexec_base_init, &base_state, xexec_base_help);\n\n  return 0;\n}\n\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-libhio-master-nrfvlowvo6m3roe76nnwdjzmnqna7vvk/spack-src/.git/objects/pack/pack-1282029af7958a9cbb5d271a21ddd8f576f079d0.idx",
        "/tmp/vanessa/spack-stage/spack-stage-libhio-master-nrfvlowvo6m3roe76nnwdjzmnqna7vvk/spack-src/.git/objects/pack/pack-1282029af7958a9cbb5d271a21ddd8f576f079d0.pack",
        "/tmp/vanessa/spack-stage/spack-stage-libhio-master-nrfvlowvo6m3roe76nnwdjzmnqna7vvk/spack-src/extra/bzip2-1.0.6-patched.tbz2",
        "/tmp/vanessa/spack-stage/spack-stage-libhio-master-nrfvlowvo6m3roe76nnwdjzmnqna7vvk/spack-src/extra/json-c-0.12-nodoc-patched.tar.gz"
    ],
    "total_files": 118
}