{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.6.0-iweh6uy7qfzcgjj77nhy45ucjhpm2ow6/spack-src/ChangeLogP520.txt": "2013-08-02  \n\n  * 6b62d586 man/man1/papi_avail.1 man/man1/papi_clockres.1\n  man/man1/papi_command_line.1...: Update the manpages for a pending 5.2\n  release.  New pages for PAPI[F]_epc and papi_version.\n\n  * 1ae08835 src/linux-common.c: try to properly detect number of sockets  Use\n  totalcpus rather than ncpu in the calculation.  This change fixes things on a\n  Sandybridge-EP machine.  We should maybe find a more robust way to detect\n  this.\n\n  * 79c37fbf .../perf_event_uncore/tests/perf_event_uncore.c\n  .../tests/perf_event_uncore_multiple.c: perf_event_uncore: have tests skip if\n  component disabled rather than fail\n\n  * 638ccf6b .../perf_event_uncore/perf_event_uncore.c: perf_event_uncore:\n  change order of uncore detection logic  This way it will report an error of\n  \"no uncore found\" before it reports \"not enough permissions\".  That way a\n  user won't waste time getting permissions only to find out they didn't have\n  an uncore anyway.\n\n  * 30582773 src/components/perf_event/pe_libpfm4_events.c: perf_event: fix\n  papi_native_avail output  A recent change of mine that added stricter error\n  checking for libpfm4 event lookup broke event enumeration on perf_event,\n  specifically papi_native_avail output.  libpfm4 will return an error on some\n  events if no UMASK or improper UMASK is supplied, but papi_native_avail\n  always wants to print the root event and umasks separately.  this temporary\n  fix just ignores libpfm4 umask errors; we might in the future want to\n  properly indicate which events are only valid when certain umasks are\n  present.\n\n  * c7612326 src/utils/native_avail.c: papi_native_avail: fix empty component\n  case  If a component had no events, papi_native_avail would ignore the error\n  returned by PAPI_enum_cmp_event( PAPI_ENUM_FIRST ); and try to print a first\n  event anyway.\n\n  * e1b064eb .../perf_event_uncore/perf_event_uncore.c: perf_event_uncore:\n  disable component if no events found  This can happen on older (pre 3.6)\n  kernels with the new libpfm4 that does proper uncore detection.\n\n2013-08-01  \n\n  * 9a54633a src/components/host_micpower/linux-host_micpower.c\n  src/components/infiniband/linux-infiniband.c\n  src/components/nvml/linux-nvml.c...: Components: Use the cuda dlopen fix all\n  cases.  See 4cb76a9b for details, the short version is if you call dlopen\n  when you have been statically linked to libc, it gets ugly.\n\n2013-07-31  \n\n  * dbc44ed1 src/components/perf_event/pe_libpfm4_events.c\n  .../perf_event_uncore/perf_event_uncore.c\n  .../perf_event_uncore/peu_libpfm4_events.c: perf_event libpfm4 events --\n  correctly handle invalid events  It was possible for event names to be\n  obtained from libpfm4 during enumeration that were not valid events.  This\n  usually happens with uncore events, where the uncore is listed as available\n  based on cpuid but when libpfm4 tries to get the uncore type from the kernel\n  finds out it is unsupported.  This change makes this properly fail, instead\n  of just returning \"0\" for all the event paramaters (which is a valid event on\n  x86).  Also make this change in the regular perf_event component, even though\n  it is less likely to happen in practice.\n\n  * 4720890a .../perf_event_uncore/perf_event_uncore.c: perf_event_uncore:\n  remove check_permissions() test  It was trying to see if an EventSet was\n  runnable by using the current permissions and adding the PERF_HW_INSTRUCTIONS\n  event. That doesn't really make sense on uncore.  The perf_event component\n  uses this test to try to give errors early, at set_opt() time rather than at\n  the first run time, although in practice now we can probably make intelligent\n  guesses based on the current permission levels.\n\n  * 113d35f7 .../perf_event_uncore/perf_event_uncore.c: perf_event_uncore:\n  remove unused kernel workarounds  uncore only works on Linux 3.6 or newer so\n  all of the pre-2.6.35 workarounds aren't necessary.  If someone has\n  backported the uncore support to kernels that old, hopefully they've also\n  backported all the other bugfixes too.\n\n2013-07-25  \n\n  * 4cb76a9b src/components/cuda/linux-cuda.c: Trial fix for the cuda component\n  static libc linking issue.  Weak link against _dl_non_dynamic_init, this\n  appears in my limited testing to be in gnu libc.a and not in the so.  For\n  background, it was reported by Steve Kaufmann that statically linking tools\n  with a PAPI library configured with the CUDA component segfaulted. It appears\n  that calling any of the dynamic linker functions from a static executable is\n  asking for pain.  See Trac bug 182\n  https://icl.cs.utk.edu/trac/papi/ticket/182\n\n2013-07-24  \n\n  * ad47cfb9 src/configure src/configure.in: Add linux-pfm-ia64 to configure \n  I'm not sure if this is enough to fix itanium support but it's a start.\n\n  * 098294c5 src/components/example/tests/example_basic.c\n  .../example/tests/example_multiple_components.c: Fixed tests for example\n  component. Both tests failed due to incorrect check of the components PAPI\n  has been configured with.\n\n2013-07-23  \n\n  * c0c4caf4 src/linux-memory.c src/papi_events.csv: Add initial support for\n  IBM POWER8 processor  Add initial support for IBM POWER8 processor  The IBM\n  POWER8 processor (to be publicly announced at some future date) has some\n  preliminary support in libpfm with a subset of native events.  These\n  POWER8-related libpfm changes were pulled into PAPI on July 3, so further\n  updates in PAPI were required to support this new processor.  This patch adds\n  that required support.  NOTE: Due to the fact that only a subset of native\n  events have been publicised at this point (and pushed into libpfm), not all\n  of the usual PAPI preset events have corresponding native events. The rest of\n  the POWER8 native events will be pushed upstream once they are verified, and\n  then we can flesh out the PAPI preset events.  With this initial POWER8\n  support patch, 5 of the ctests and ftests fail, compared to 3 when PAPI is\n  run on a POWER7. At least one of the failing testcases is due to testing\n  being done on an early POWER8 processor with some known hardware problems. We\n  presume the number of failing tests will decrease once we have GA-level\n  hardware to test on. \n\n2013-07-22  \n\n  * 6c231d1a src/configure: Rerun autoconf  for f4ec143e Correct versioning of\n  libpapi.so\n\n  * f4ec143e src/configure.in: Correct versioning of libpapi.so  The configure\n  for linux always set the soname to libpapi.so.  This causes problems when\n  /sbin/ldconfig tries to update the library information on linux.  The shared\n  library is installed as /lib{64}/libpapi.so.$VERSION, but the shared library\n  has the soname of libpapi.so.  ldconfig makes a symbolic link from\n  /lib/libpapi.so to the actual versioned shared library,\n  /lib/{64}/libpapi.so$VERSION. The configure should get the soname correct to\n  avoid creating this symbolic link.  This patch only addresses the issues for\n  some of the possible platforms and similar patches may be needed for other\n  platforms. \n\n2013-07-19  \n\n  * 92356bbd src/papi.c src/threads.c src/threads.h: Attempt to fix a memory\n  leak in fork2 test.  Fork2 does the following: PAPI_library_init() fork(); / \n    \\ parent   child wait()     PAPI_shutdown()\t->\n  _papi_hwi_shutdown_global_threads() -> foreach(threadinfo we allocated):\n  _papi_hwi_shutdown_thread() PAPI_library_init()  _papi_hwi_shutdown_thread\n  checks who allocated a ThreadInfo entry in the global list, and will only\n  free it if our thread did the allocation.  When threading is not initialized,\n  we fall back to getpid(), now in the child process, the one ThreadInfo item\n  on the list was allocated by our parent, so at shutdown time we don't free\n  this, and thus leak it.  Solution is to add a parameter to\n  _hwi_shutdown_thread to force shutdown even if we didn't allocate it. At\n  _papi_hwi_shutdown_global_threads() time, who cares, its closing time.\n\n  * c04d908e src/cpus.c: Fix a deadlock in _papi_hwi_lookup_cpu().  If cpu_num\n  is not found by _papi_hwi_lookup_cpu(), _papi_hwi_initialize_cpu() calls\n  insert_cpu(), which locks CPUS_LOCK, which was already held by\n  _papi_hwi_lookup_cpu().\n\n  * efac24c4 src/components/micpower/linux-micpower.c: micpower: fix return\n  value check  Also add a time check at stop time.\n\n2013-07-16  \n\n  * b9fd9dd1 src/configure src/configure.in: configure: Fix AIX build \n  perfctr_ppc was not the only system that relied on ppc64_events.h, power*.h,\n  and friends. First run at a fix is -Icomponents/perfctr_ppc for the C and F\n  flags...\n\n  * 46042e68 src/components/micpower/linux-micpower.c: micpower: update some\n  indexing code\n\n2013-07-15  \n\n  * 5220e7d2 INSTALL.txt: INSTALL.txt: typo  --with-arch=, not --arch=; Thanks\n  to Karl Schulz for catching this.\n\n  * 207e0ee0 src/papi_libpfm_events.h: papi_libpfm_events: needs include files\n  for types.  Include papi.h and papi_vector.h for papi_vector_t and\n  PAPI_component_info_t\n\n  * d96c01c7 src/components/perfctr/perfctr.c: perfctr: cleanup a warning \n  Include papi_libpfm_events.h for _papi_libpfm_init() decl.\n\n  * 367e1b38 src/components/perfctr/perfctr-x86.c\n  src/components/perfctr/perfctr.c: perfctr: refactor out setup_x86_presets \n  The setup_presets function served only to call _papi_libpfm_init, so we go\n  the rest of the way and completly remove the function, calling\n  _papi_libpfm_init directly from _perfctr_init_component.\n\n  * 1ba38ce5 src/components/perfctr/perfctr-x86.c: perfctr: cleanup unused\n  parameter warning.  The perfctr code was refactored to only call into the\n  table loading code one time. This had the side effect of removing most of\n  what setup_x86_presets does.\n\n  * 02710ced src/configure src/configure.in: configure: remove debugging\n  message  The compiler detection code had a stray AC_MSG_RESULT.\n\n2013-07-12  \n\n  * 028ce29d src/components/lustre/linux-lustre.c: lustre: use whole directory\n  name as event  Gary Mohr reported that on a trial system he was seeing many\n  events of the form fs3-* which were all chopped to fs3, not helpful.  I've\n  not actually been able to figure out exactly how lustre names things, I've\n  seen it described as  <fs>-<uid>  But have no clue what uid promisses.\n\n2013-07-15  \n\n  * 129d4587 src/papi.c: allow more than one EventSet attach to a CPU at a time\n   This is necessary for perf_event_uncore support, as multiple uncores will\n  want to attach to a CPU.  It looks like this change won't break anything, and\n  the tests pass on my test machines.  I am a bit concerned about\n  cpu->running_eventset, though no one seems to use that value...\n\n  * bcda5ddd src/components/perf_event_uncore/tests/Makefile\n  .../tests/perf_event_uncore_nogran.c: perf_event_uncore: remove\n  perf_event_uncore_nogran test  It is unnecessary after recent changes to the\n  uncore component.\n\n  * b1b9f654 src/components/perf_event_uncore/tests/Makefile\n  .../tests/perf_event_uncore_cbox.c: perf_event_uncore: add\n  perf_event_uncore_cbox test  This adds a non-trivial test of the CBOX\n  uncores. It turned up various bugs in the PAPI uncore implementation.\n\n  * df1b6453 src/linux-common.c: linux: properly set hwinfo->socket value  It\n  was being derived from hwinfo->ncpu but being calculated before hwinfo->ncpu\n  was set.\n\n2013-07-13  \n\n  * ee537448 .../perf_event_uncore/perf_event_uncore.c\n  .../perf_event_uncore/peu_libpfm4_events.c\n  .../perf_event_uncore/peu_libpfm4_events.h: perf_event_uncore: properly\n  report number of total counters available\n\n  * 7eb93917 src/components/perf_event/Rules.perf_event\n  src/components/perf_event/pe_libpfm4_events.c\n  src/components/perf_event/pe_libpfm4_events.h...:\n  perf_event/perf_event_uncore/libpfm4 -- rearrange files  Give perf_event and\n  perf_event_uncore copies of papi_libpfm4_events to work with, as they will\n  have different needs for the code.  Get rid of the perf_event_lib stuff.  It\n  was a hack to begin with and in the end not much code will be shared.  Maybe\n  we can re-share things once uncore support is complete.\n\n2013-07-12  \n\n  * 6810af2a src/components/perf_event/perf_event.c\n  .../perf_event_uncore/perf_event_uncore.c src/papi_libpfm4_events.c...:\n  papi_libpfm4: properly call pfm_terminate() in papi_libpfm4_shutdown\n\n  * 010497f4 src/components/perf_event/perf_event.c\n  .../perf_event_uncore/perf_event_uncore.c src/papi_libpfm4_events.c...: split\n  papi_libpfm4_init()  split this function because the perf_event_uncore()\n  component is going to want to initialize things differently than plain\n  perf_event\n\n  * d9023411 src/components/perf_event/perf_event.c: perf_event: on old kernels\n  if SW Multiplex enabled, then report proper number of MPX counters available \n  it may be different than the amount HW supports\n\n  * 7595a840 src/components/perf_event/perf_event_lib.c: perf_event: use\n  PERF_IOC_FLAG_GROUP when resetting events  This ioctl argument specifies to\n  reset all events in a group, so we don't have to iterate.  This argument\n  dates back to the introduction of perf_event and it makes the code a bit\n  cleaner.\n\n  * f220fd19 src/ctests/Makefile src/ctests/reset_multiplex.c: Add\n  reset_multiplex.c  PAPI_reset() potentially exercises different paths when\n  resetting normal and multiplexed eventsets, so make sure we test both.\n\n  * f784a489 src/components/lustre/linux-lustre.c: lustre: botched a conflict\n  resolution  properly do error checking on addCounter()\n\n  * c1350fc8 src/components/perf_event/perf_event.c\n  src/components/perf_event/perf_event_lib.c\n  src/components/perf_event/perf_event_lib.h: perf_event: move overflow and\n  profile code out of common lib  the perf_event_uncore component doesn't need\n  it\n\n  * 8dde03fc .../perf_event_uncore/perf_event_uncore.c: perf_event_uncore:\n  remove profiling and overflow code  perf_event doesn't support sampling or\n  overflow on uncore\n\n  * 30d23636 src/components/lustre/linux-lustre.c: lustre component: Several\n  fixes  1. create a dynamic native events table in pathalogical cases, lustre\n  can have lots of events.  2. resolve some warnings change signature of\n  init_component properly error check addCounter  3. Add a preprocessor flag to\n  fake interface Set LIBCFLAGS=\"-DFAKE_LUSTRE\"\n\n  * 7ef51566 .../perf_event_uncore/perf_event_uncore.c: perf_event_uncore:\n  remove dispatch timer call  perf_event  doesn't support sampling on uncore\n  events\n\n  * 667661c6 src/components/perf_event/perf_event.c\n  src/components/perf_event/perf_event_lib.c\n  src/components/perf_event/perf_event_lib.h: perf_event: move rdpmc detection\n  back into perf_event.c  It was in the perf_event_lib but uncore won't use the\n  feature.\n\n  * d46f01e1 .../perf_event_uncore/perf_event_uncore.c: perf_event_uncore:\n  check the paranoid file  Disable the component if paranoid isn't 0 or lower,\n  and we're not running as root.\n\n  * e4ec67d1 src/components/perf_event/perf_event.c: perf_event and paranoid\n  level 2  If paranoid level 2 (no kernel events) was set we were removing\n  PAPI_DOM_KERNEL from the allowable domains  We were doing this even if the\n  user was root.  This code checks for uid 0 and overrides the restriction.\n\n  * c5501081 src/components/perf_event/perf_event_lib.c\n  src/components/perf_event/perf_event_lib.h: rename sys_perf_event_open2()\n  call back to sys_perf_event_open()  This was changed when merging code to\n  avoid a conflict but wasn't renamed back whe the conflict was fixed.\n\n2013-07-11  \n\n  * e263ea60 src/configure src/configure.in: configure: libpfm selection logic\n  rework  If configure detected perfctr it would force libpfm3 to be used, even\n  with --with-perf_events, now force libpfm4 if perf_events is requested.\n\n2013-07-10  \n\n  * 7a3ce030 .../host_micpower/Makefile.host_micpower.in\n  src/components/host_micpower/Rules.host_micpower\n  src/components/host_micpower/configure...: Component: host_micpower  This is\n  a component that exports power information for Intel Xeon Phi cards (MIC).\n  The component makes use of the MicAccessAPI distributed with the Intel\n  Manycore Platform Software Stack.\n  \n  k-mpss)\n\n  * 9d9bd9c2 src/ctests/shlib.c: Fwd: Re: [Ptools-perfapi] ctests/shlib FAILED \n  Should have sent this to the papi devel list. -Will  -------- Original\n  Message -------- Subject: Re: [Ptools-perfapi] ctests/shlib FAILED Date: Tue,\n  09 Jul 2013 23:20:10 -0400 From: William Cohen <wcohen@redhat.com> To:\n  ptools-perfapi@eecs.utk.edu  On 03/09/2012 03:40 PM, William Cohen wrote: > I\n  was looking through the test results and found that ctests/shlib FAILED on\n  all the machines I tested on because libm shared library is already linked\n  in. There is no difference in the number of shared libraries before and after\n  the dlopen. The test ctests/shlib fails as a reult of this. > > -Will >\n  _______________________________________________ > Ptools-perfapi mailing list\n  > Ptools-perfapi@eecs.utk.edu >\n  http://lists.eecs.utk.edu/mailman/listinfo/ptools-perfapi >  I did some more\n  investigation of this problem today.  I found that the lmsensor component\n  implicitly pulls in the libm.  As an alternative, I wrote the attached patch\n  that uses setkey() and encrypt() in libcrypt.so instead.  It works on various\n  linux machines, but I do not know whether it is going to work on other OS. \n  -Will  >From c53c97e1de2d1c7dc0bca64d1906287ff73343c6 Mon Sep 17 00:00:00\n  2001 From: William Cohen <wcohen@redhat.com> Date: Tue, 9 Jul 2013 22:37:27\n  -0400 Subject: [PATCH] Avoid using libm.so for ctests/shlib because of\n  implicit use in some components  The lmsensors component can implicitly pull\n  in libm.so into the executable.  Unfortunately, the ctests/shlib test expects\n  that libm.so is not loaded and will fail because there is no change in the\n  count of shared libraries.  The patch uses libcrypt.so library setkey and\n  encrypt functions to test PAPI_get_shared_lib_info( ) instead of libm.so\n  library pow function. \n\n2013-07-09  \n\n  * bdc9b34b .../tests/perf_event_amd_northbridge.c:\n  Perf_event_amd_northbridge_test: Use buffer event_name instead of\n  uncore_event  The variable uncore_event is initialized to NULL and is never\n  changed during execution of the test. PAPI_add_named_event fails and the\n  event set cannot be started. The correct event name is stored in event_name,\n  replacing all occurrences of uncore_event with event_name therefore fixes the\n  problem metioned above.\n\n2013-07-08  \n\n  * a1678388 src/components/micpower/linux-micpower.c: micpower:  Fix output in\n  native_avail and component_avail. It uses cmp_info.name, not .short_name? \n  Native Events in Component: mic-power Name:   mic-power              \n  Component for reading power on Intel Xeon Phi (MIC)  Should both match what\n  is prepended to event names, so change .name from mic-power to micpower.\n\n  * e0582f2d src/components/micpower/linux-micpower.c: Micpower: fix a typo \n  subsystem, not sybsystem...\n\n  * c7b357ec INSTALL.txt: INSTALL.txt: update instructions for MIC.\n\n  * 34a1124e src/components/perf_event_uncore/tests/Makefile\n  .../tests/perf_event_amd_northbridge.c: Add perf_event_amd_northbridge test \n  The test should show how to write a program using AMD fam15h NB with a 3.9\n  kernel.  Once libpfm4 gets updated we can see if it's possible to also have\n  the test properly run on 3.10 kernels (in that case the regular\n  perf_event_uncore test should work w/o changes)\n\n  * 41b6507c .../perf_event_uncore/tests/perf_event_uncore.c\n  .../tests/perf_event_uncore_multiple.c: Make perf_event_uncore tests use\n  PAPI_get_component_index()  They were open-coding the component name search\n  for no good reason.\n\n2013-07-05  \n\n  * abf38945 src/papi_libpfm4_events.c: avoid having a \"default\" PMU for the\n  uncore component  on the main CPU component we have a \"default\" PMU where you\n  can leave out the PMU part of the event name.  This is unnecessary and\n  sometimes confusing on uncore, so always print the full event name if it's an\n  uncore PMU.\n\n  * b9fe5c3e .../perf_event_uncore/tests/perf_event_uncore.c\n  .../tests/perf_event_uncore_multiple.c: Update perf_event_uncore tests to\n  properly fail if they don't have enough permissions\n\n  * 32ae1686 .../perf_event_uncore/tests/perf_event_uncore.c:\n  perf_event_uncore_test : properly use uncore component  The sample code was\n  still hardcoding to component \"0\" which shouldn't have worked.  Thanks to\n  Claris Castillo for pointing out this problem.\n\n  * 59e73b51 src/papi_libpfm4_events.c: have _papi_libpfm4_ntv_name_to_code\n  properly check pmu_type  With the existing code, uncore events were being\n  found by the perf_event component even when that component has uncore events\n  distabled.\n\n2013-07-03  \n\n  * a01394eb .../tests/perf_event_uncore_lib.c: perf_event_uncore: fix ivb\n  event in uncore test  Now that libpfm4 officially supports plain ivb uncore,\n  make sure the test event we were using matches what libpfm4 supports.\n\n2013-07-01  \n\n  * f10342a8 src/utils/cost.c: Clean up option handling in papi_cost  The\n  papi_cost used strstr to seach for the substring that matched the option. \n  this is pretty inexact.  Made sure that the options matched exactly and the\n  option argments for -b and -t were greater than 0. Also make papi_cost print\n  out the help if there was an option that it didn't understand. \n\n  * b5adc561 src/utils/native_avail.c: Clean up option handling for\n  papi_native_avail  Corrected the help to reflect the name of the option\n  \"--noumasks\". Print error message if the \"-i\", \"-e\", and \"-x\" option\n  arguments are invalid. Avoid using strstr() for \"-h\", use strcmp instead.\n  Also check for \"--help\" option. \n\n  * 8933be9b src/utils/decode.c: Clean up option handling in papi_decode \n  papi_decode used strstr() to match options; this can lead to inexact matchs.\n  The code should used strcmp instead.  Make sure command name is not processed\n  as an option.  Also print help iformation is some argument is not understood.\n\n  * d94ac43a src/utils/component.c: Improve option matching in papi_component\n  and add \"--help\" option \n\n  * bb63fe5c src/utils/command_line.c: Add options to papi_command_line man\n  page and improve opt handling  Add options mention in the -h to the man page.\n   Also improve the matching of the options. \n\n  * 09059c82 doc/Makefile src/utils/version.c: Add information for papi_version\n  to be complete \n\n  * 4f2eee8c src/configure src/configure.in: add a --disable-perf-event-uncore\n  option to configure\n\n2013-06-29  \n\n  * 901c5cc2 src/components/perf_event/perf_event.c\n  src/components/perf_event/perf_event_lib.c\n  .../perf_event_uncore/perf_event_uncore.c...: remove syscalls.h  it's no\n  longer needed\n\n  * 4d7e3666 src/Rules.perfmon2 src/components/perfmon2/Rules.perfmon2\n  src/components/perfmon2/perfmon.c...: move perfmon modules to their own\n  component directory\n\n  * a7e9c5f1 src/Rules.perfctr src/Rules.perfctr-pfm\n  src/components/perfctr/Rules.perfctr...: move perfctr files to\n  components/perfctr directory  verified that perfctr-x86 still builds and\n  works  perfctr_ppc has all the files to build, but it doesn't work. It looks\n  like no one has tried to build perfctr-ppc for a very very long time.\n\n2013-06-27  \n\n  * e9dec1fd src/ctests/hl_rates.c src/papi.h src/papi_fwrappers.c...: debugged\n  versions of these files\n\n  * e282034e src/utils/native_avail.c: native_avail: Fix parse_unit_mask code \n  Reported by Steve Kaufmann -------------------------- I noticed while\n  developing a new component that the output from papi_native_avail was\n  incorrectly presented for the component. I believe this is because the \":::\"\n  prefix is not being taken into account, so the base event name is interpreted\n  as a unit mask and is prepend with a : before each legitimate unit mask\n  associated with the event. I think this is just now happening because mine is\n  the first component that has unit masks. I have include a fix below. The\n  output of the unit masks by papi_native_avail now appears correctly for my\n  component.  Thanks, Steve\n\n2013-06-26  \n\n  * ff096786 src/ctests/fork2.c: fork2: Return fork2 test to its old\n  functionality  Once upon a time fork2 did: PAPI_library_init() \u2026 if (\n  fork() == 0) PAPI_shutdown() PAPI_library_init() \u2026\n\n2013-06-25  \n\n  * 978d0d3d src/examples/PAPI_add_remove_event.c src/papi.c: Modify\n  PAPI_list_events functionality to match documentation. You can now pass in a\n  NULL event array and a zero count to get back the valid number of events.\n  This can then be used to allocate the array and retrieve the exact number of\n  events. Thanks to Nils Smeds and Alain Miniussi for pointing this out.\n\n  * 13c52402 src/examples/PAPI_add_remove_event.c src/papi.c: Modify\n  PAPI_list_events functionality to match documentation. You can now pass in a\n  NULL event array and a zero count to get back the valid number of events.\n  This can then be used to allocate the array and retrieve the exact number of\n  events. Thanks to Nils Smeds and Alain Miniussi for pointing this out.\n\n  * 656e703e src/ctests/zero_fork.c: zero_fork ctest : make documentation match\n  code\n\n  * 96aad0c7 src/ctests/forkexec.c: forkexec ctest : make comments match code\n\n  * b7c70953 src/ctests/forkexec4.c: forkexec4 ctest : make comments match the\n  code\n\n  * 7ffb0245 src/ctests/forkexec3.c: forkexec3 ctest : make documentation match\n  code\n\n  * 55ea846c src/ctests/forkexec2.c: forkexec2 ctest: have comments match what\n  source does\n\n  * 7a601e2a src/ctests/Makefile src/ctests/fork2.c: fork2 ctest: remove; was\n  an exact duplicate of fork\n\n  * 9deff49b src/ctests/fork.c: fork ctest: make comments match what file\n  actually does\n\n2013-06-24  \n\n  * 2770d2c5 src/components/perf_event/perf_event_lib.c: perf_event: fix\n  failure on ARM due to domain settings  forgot to git add the perf_event_lib.c\n  file :(\n\n  * bf7c4c50 src/components/perf_event/perf_event.c\n  src/components/perf_event/perf_event_lib.h: perf_event: fix failure on ARM\n  due to domain settings  On Cortex A8 and A9 it's not possible to set\n  exclude_kernel (hardware does not support it).  Make sure the rdpmc detection\n  code doesn't try to set exclude_kernel.\n\n2013-06-18  \n\n  * 2b1433d8 src/ctests/all_native_events.c src/ctests/get_event_component.c:\n  ctests: Skip calling into disabled components.  This patch fixes a problem\n  that was causing two test cases to abort when they were run on a system which\n  has disabled components.  Code was added to check if the component is\n  disabled and just go to the next component in the list when the check is\n  true.  This prevents calls to code in components which may abort because the\n  component was unable to initialize itself correctly.  Thanks to Gary Mohr and\n  Chuck LaCasse from Bull for reporting.\n\n2013-06-14  \n\n  * 1872453c src/testlib/do_loops.c: testlib: don't change the iter count  The\n  first argument to do_misses is an iteration count, for some reason the code\n  was dividing this in half before doing work. Most places that call do_misses\n  call it as do_misses ( 1, ...)  void do_misses( int n, int bytes ) { {...} n\n  = n / 2; for ( j = 0; j < n; j++ ) {  1/2 == 0; so our do_misses call was\n  usually not.  Thanks Nils Smeds for reporting.\n\n2013-06-12  \n\n  * c113e5b6 src/components/infiniband/Makefile.infiniband.in\n  src/components/infiniband/Rules.infiniband\n  src/components/infiniband/configure...: Infiniband component: switch over to\n  weak linking  Thnaks to Gary Mohr for the patch.\n  ---------------------------------- The infiniband component needs include\n  files and libraries from both the infiniband ibmad and ibumad packages.  When\n  these packages are installed on a system, both packages normally install\n  their files in the same place (includes in /usr/include/infiniband and\n  libraries in /usr/lib64).  The current component configure script allows you\n  to provide a single include path and a single library path which gets used to\n  access files from both packages.  If these two packages have different\n  install prefixes (or you are trying to build from install images of each\n  package which are not located under the same directory) then the configure\n  script fails because it can not find all the files it needs.  These changes\n  modify the configure script to replace the include and library dir's with an\n  ibmad_dir and ibumad_dir and then uses the correct packages directory when\n  looking for includes and libraries from that package.  This makes it work\n  like the cuda and nvml components with respect to configuring how to find\n  files from a package the component depends on.  There are also changes in\n  this patch file to remove an unneeded variable in the dlopen code to resolve\n  some defects reported by coverity.\n\n2013-06-11  \n\n  * d5be5643 src/components/rapl/tests/rapl_basic.c: rapl tests: make the error\n  messages a little more verbose\n\n  * 0c9f1a8c src/run_tests_exclude.txt src/run_tests_exclude_cuda.txt:\n  run_tests_exclude files: Exclude a template file \n  ------------------------------------------- It also adds the cpi.pbs file to\n  the list of files to excluded when the tests are run. This file is just a\n  template and attempts to run it hang the run_tests script on our systems.\n  -------------------------------------------\n\n  * 0a063619 src/run_tests.sh: run_tests.sh: fix exclude check.  The script\n  failed to remove .cu files, this patch fixes the check. Thanks Gary Mohr for\n  reporting/patching.\n\n2013-06-10  \n\n  * 87399477 src/components/cuda/linux-cuda.c: cuda component: Address a\n  coverity issue  The library linking code saved return values in a local var\n  but never used them. Thanks to Gary Mohr for submitting this patch.\n\n  * 99b5b685 src/components/coretemp/tests/coretemp_basic.c: coretemp_basic:\n  update test to properly enumerate events  The code was old and was searching\n  the entire native event list for ones that started with \"hwmon\".  This\n  updates the test to first find the coretemp component, then enumerate all\n  events contained within.\n\n  * b5c0795b src/components/rapl/tests/rapl_overflow.c: rapl component: address\n  potential looping issue in test.  A rapl component test has a do/while which\n  only exited when PAPI_add_named_event returned 0 ( and only 0; the PAPI_E*\n  error codes would not terminate a while( retval ) loop), this felt fragile,\n  minimal checks are now inplace.\n\n  * 4e9484a5 src/components/rapl/tests/rapl_overflow.c: rapl components:\n  coverity fixes  Reported/patched by Gary Mohr -----------------------------\n  The rapl component also has 1 defect in a test case.  The complaint is that\n  there is code that can never be executed.  But this one is not as clear, it\n  says that you can not exit the do/while loop that preceeds a test of retval\n  until retval=0 which means the test can never be true.  The patch I am\n  providing is to again remove the if test and its contents.  But I am\n  concerned that the do/while loop preceeding the test could result in a hard\n  loop that would hang the test case forever.  It seems to me like something\n  should also be done to insure the loop will exit at some point.  Here is a\n  patch that provides at least part of the fix: -----------------------------\n\n  * 0a533810 src/components/net/tests/net_values_by_name.c: net components:\n  coverity fixes  Reported/patched by Gary Mohr -----------------------------\n  The net component has one defect in one of the test cases.  The complaint is\n  that there is code that can never be executed.  There is a test to see if\n  event_count == 0 which can never be true at that place in the code.  So I\n  removed the if statement and its contents.  Here is the patch:\n  -----------------------------\n\n2013-06-07  \n\n  * b784b063 src/components/nvml/Rules.nvml src/components/nvml/configure\n  src/components/nvml/configure.in...: nvml: Apply Gary Mohr's dlopen patch. \n  Move the nvml component over to using the dlopen and weak linking\n  infrastructure of the cuda component. Thanks, Gary.\n\n  * d6505b76 src/components/rapl/utils/rapl_plot.c: rapl: update the rapl_plot\n  utility  Get the event names by enumerating the ones available with the RAPL\n  component rather than having a hard-coded list.\n\n  * 2094c5b1 src/components/rapl/linux-rapl.c: rapl: add better error messages\n  on component init failure\n\n  * d0e668fb src/ctests/Makefile src/ctests/high-level.c\n  src/ctests/hl_rates.c...: First round of changes to implement a PAPI high\n  level event per cycle call. Untested.\n\n2013-06-05  \n\n  * 63074f82 src/components/rapl/linux-rapl.c: rapl: Add Ivb-EP support  The\n  Intel docs are spotty on what is actually supported. They state: 14.7.2 RAPL\n  Domains and Platform Specificity The specific RAPL domains available in a\n  platform varies across product segments. Platforms targeting client segment\n  support the following RAPL domain hierarchy: * Package * Two power planes:\n  PP0 and PP1 (PP1 may reflect to uncore devices) Platforms targeting server\n  segment support the following RAPL domain hierarchy: * Package * Power plane:\n  PP0 * DRAM\n\n2013-05-31  \n\n  * 31b4702d src/cpus.c: cpus.c: Don't run init_thread/shutdown_thread for\n  disabled components.\n\n2013-05-29  \n\n  * c48087d2 ChangeLogP511.txt RELEASENOTES.txt: Grab the updated ChangeLog\n  from 5.1.1  Create a ChangeLog and update RELEASENOTES for a 5.1.1 release.\n\n2013-05-24  \n\n  * d1c8769e src/components/perf_event/tests/Makefile\n  src/components/perf_event/tests/event_name_lib.c\n  .../perf_event/tests/perf_event_user_kernel.c: Add perf_event user/kernel\n  domain test  This will be useful if/when we start handling domains properly.\n\n  * 89e1aeba src/components/perf_event/tests/Makefile\n  src/components/perf_event/tests/event_name_lib.c\n  src/components/perf_event/tests/event_name_lib.h...: Add perf_event offcore\n  response test  Does a quick check to see if offcore response events are\n  working.\n\n  * bda86616 .../perf_event_uncore/perf_event_uncore.c\n  src/ctests/get_event_component.c src/papi_internal.c: Some more ctest fixes\n  involving disabled components.  We enforce disabled components sometime in\n  the PAPI routines and sometimes in the components themselves.  A bit\n  confusing.  It is tough with perf_event and perf_event_uncore because we\n  share libpfm4 by both, so the naming library for perf_event_uncore will be\n  active even if the component is disabled, which can cause some confusing\n  results if your test code ignores PAPI_ENOCMP error messages and accesses a\n  disabled component anyway.  This at least fixes our test cases, we might have\n  to revisit this later.\n\n  * b596621e doc/Doxyfile-common papi.spec src/Makefile.in...: Bump version\n  numbers  Call this 5.2.0.0 simple because its greater than (and some\n  components are completely incompatible with) 5.1.1\n\n  * eb77a91e .../perf_event_uncore/perf_event_uncore.c src/papi.c: Disallow\n  enumerating events on disabled components.  This was causing segfaults on\n  tests where enumeration was trying to enumerate uncore events on machines w/o\n  uncores.\n\n  * 4e991a8a .../perf_event/tests/perf_event_system_wide.c:\n  perf_event_system_wide: SKIP instead of FAIL if we don't have proper\n  permissions\n\n  * 7654bb1f src/Makefile.inc src/components/perf_event/tests/Makefile\n  .../perf_event/tests/perf_event_system_wide.c...: move the perf_event\n  specific tests to be with their component  This means the perf_event tests\n  will only be run if perf_event is enabled\n\n  * d82e343f src/ctests/perf_event_uncore_multiple.c:\n  ctests/perf_event_uncore_multiple: Improve this test a bit\n\n  * b1a594bf src/perf_events.c src/sys_perf_event_open.c: Remove the no-longer\n  needed perf_events files  Now we use the versions in the\n  components/perf_event directory\n\n  * a9a277f3 src/Makefile.in src/Makefile.inc src/configure...: Split up\n  CPUCOMPONENT configure variable  Now it is CPUCOMPONENT_NAME CPUCOMPONENT_C\n  CPUCOMPONENT_OBJ This allows having setups with no CPUCOMPONENT set\n  (perf_event used as a component) while keeping backward compatible with\n  non-component CPU components.  This has been tested on perf_event and\n  perfctr.  It might break other architectures, so test if you can.\n\n  * 69e29526 src/configure src/configure.in: configure: have --with-components\n  append comonents to existing value  This allows configure to earlier set the\n  components value to include \"perf_event\" if detected and then later append\n  the values passed in with --with-components\n\n  * 9d28df4c src/components/perf_event/Rules.perf_event\n  src/components/perf_event/perf_event.c\n  src/components/perf_event/perf_event_lib.c...: add perf_event and\n  perf_event_uncore components  This adds perf_event as a standalone component.\n  Currently it is not compiled or built, some changes need to be made to the\n  build system before this will work.\n\n2013-05-21  \n\n  * ea996661 src/components/cuda/linux-cuda.c: eliminate warnings of unused\n  vars\n\n  * 691bf114 src/components/cuda/linux-cuda.c: eliminate warnings of unused\n  vars\n\n  * 221bfdab src/components/cuda/linux-cuda.c\n  src/components/cuda/tests/HelloWorld.cu: Problem with cleanup_eventset():\n  after destroying the CUDA eventset, update_control_state() is called again\n  which operates on the already destroyed eventset.\n\n2013-05-17  \n\n  * 84925f50 src/components/cuda/linux-cuda.c: When adding multiple CUDA events\n  to an event set, PAPI_add_event() error 14 (CUPTI_ERROR_NOT_COMPATIBLE) is\n  being raised from the CUPTI library.  Turns out that the CUDA update control\n  state wasn't cleaning the event set up properly before adding new events.\n  It's fixed now.\n\n  * 2337aa3a src/perf_events.c: perf_event: allow running with\n  perf_event_paranoid is 2  perf_event_paranoid set to 2 means allow user\n  monitoring only (no kernel domain).  The code before this mistakenly disabled\n  all events in this case. Also set the allowed domains to exclude\n  PAPI_DOM_KERNEL.\n\n2013-05-16  \n\n  * 617d9fbb src/papi_events.csv: papi_events.csv Revert a little mishap in\n  adding ivbep support  Somehow the contents of papi_hl.c ended up in the\n  events file.\n\n  * 2aff4596 src/papi_events.csv: Add identifier for ivb_ep\n\n  * 1810ddf9 src/papi_libpfm4_events.c src/papi_libpfm4_events.h\n  src/perf_events.c: papi_libpfm4_events: allow specifying\n  core/uncore/os_generic PMUs  This allows you to specify you only want your\n  perf_event/libpfm4 based component to only export the PMU types you want. \n  Now we can have an uncore-only component.\n\n  * 6554f3f0 src/papi_libpfm4_events.c: papi_libpfm4_events.c: only enable\n  presets for component 0  If we have multiple events using libpfm4, we only\n  want to load the presets if it is component 0.\n\n  * 6a4a4594 src/papi.c: PAPI_get_component_index() was matching names\n  improperly  For example, it was matching perf_event and perf_event_uncore as\n  the same component.\n\n  * 1b94e157 src/papi_hl.c: papi_hl.c : fix IPC calculation  I broke it a while\n  back while trying to clear out use of MHz.  The code was uncommented and very\n  confusing.  It is slightly better now.\n\n  * 92d4552e src/papi_libpfm4_events.c src/papi_libpfm4_events.h\n  src/perf_events.c: papi_libpfm4_events: code changes to allow multiple\n  component access  the PAPI libpfm4 code has been modified to allow multiple\n  users at once.  This will allow multiple components to use libpfm4, for\n  example a CPU component and an uncore component.\n\n  * 7902b30e src/cpus.c: cpus: fix debug compile  I always forget to compile\n  with --with-debug and miss changes in the DEBUG statements.\n\n2013-05-15  \n\n  * 7ddc05ff src/cpus.c src/cpus.h: cpus.c: Add reference count to cpu\n  structure  It is possible to have multiple eventsets all attached to the same\n  CPU, as long as only one eventset is running at a time.  At EventSet cleanup,\n  PAPI would free the CpuInfo_t structure even if other EventSets were still\n  using it.  This patch adds a reference count to the structure and only frees\n  it after the last user is cleaned up.  I also fixed a few locking bugs,\n  hopefully I didn't introduce any new ones.\n\n  * 6a61f9a2 src/cpus.c: more cleanup of the cpus.c file  mostly formatting and\n  added comments.\n\n  * 710d269f src/cpus.c src/cpus.h src/papi.c...: cleanup cpus.h  It had a lot\n  of extraneous stuff in it.  Also make sure it only gets included in files\n  that need it.\n\n  * 422226c9 src/papi.c: papi.c: add some extra debug messages\n\n  * b1297058 src/cpus.c: Clean up cpus.c a bit  Tracking down a segfault in the\n  cpu attach cleanup code.\n\n  * 7b6023cf src/ctests/perf_event_system_wide.c:\n  ctests/perf_event_system_wide: much improved output  It segfaults at the end\n  though, unclear if this is a bug in the test or a bug in PAPI.  Will\n  investigate.\n\n  * 38397aa3 src/components/cuda/configure src/components/cuda/configure.in\n  src/components/cuda/linux-cuda.c...: Cuda component: Update library search\n  path  From Gary Mohr: It turns out that with the changes I gave you the path\n  to the libcuda.so library is still hard coded to /usr/lib64.  This assumes\n  that the NVIDIA-Linux package is installed on the system where the build is\n  being done.  In Bull's case (and probably other users also) this is not\n  always the case.  To add the flexibility we need, I have added a new\n  configure argument to the cuda configure script.  The new argument is\n  \"--with-cudrv_dir\" and it allows the user to specify where the cuda driver\n  package (ie: NVIDIA-Linux) to be used for the build can be found.  This new\n  argument is optional and if not provided a value of \"/usr\" will be used. This\n  allows existing configure calls to continue to work like before.\n\n  * f8873d1c src/ctests/perf_event_system_wide.c:\n  ctests/perf_event_system_wide: clean up the output a lot  Still working on\n  understanding it.\n\n  * ebf20589 src/ctests/perf_event_system_wide.c: perf_event_system_wide:\n  testing various DOMAIN and GRANULARITY settings  pushing the limits of\n  PAPI/perf_event trying to see why system-wide measurement doesn't work.\n\n2013-05-14  \n\n  * 0c1ef3f5 src/components/cuda/linux-cuda.c: CUDA component: Update\n  description field  Also removes a strcpy in the init code, which overwrote\n  the name field. Thanks to Gary Mohr\n\n  * 474fc00e src/ctests/perf_event_uncore_lib.c: Add AMD fam15h northbridge\n  event to ctests/perf_event_uncore_lib.c\n\n2013-05-13  \n\n  * cf56cdac src/perf_events.c: perf_event component: update error returns \n  This passes more error return values back to PAPI. Before this change a lot\n  of places were hardcoded to PAPI_EPERM even if sys_perf_event_open() was\n  reporting a different error.\n\n  * c824471b src/ctests/Makefile src/ctests/perf_event_system_wide.c\n  src/ctests/perf_event_uncore.c...: Update the perf_event specific tests. \n  This adds a few more uncore tests, which are currently showing some bugs in\n  the implementation.  The tests all need root permissions to run, so should\n  default to \"SKIPPED\" for most users.\n\n2013-05-08  \n\n  * e0204914 src/configure src/configure.in: Force the use of pthread_mutexes\n  on ARM  This lets the system libraries worry about the best way to define\n  mutexes, rather than trying to hand-code in assembly around all of the\n  various issues there are with atomic instructions in the ARM architecture. \n  It might make sense to enable this for *all* Linux architectures, but for now\n  just do it for ARM.\n\n  * f21b1b27 src/linux-lock.h: Commit 59d3d7584b2925bd05b4b5d0f4fe89666eb8494a\n  removed the definition of mb().  mb() was defined as rmb().  This just\n  corrects it back.   (Note from VMW -- this fixes some things, but ARM still\n  won't build on a Cortex A9 pandaboard due to the use of the \"swp\"\n  instruction. Proper fix is probably to enforce posix-mutexes on ARM)\n\n2013-05-06  \n\n  * 913f0795 src/components/nvml/configure src/components/nvml/configure.in:\n  NVML: Update wording for configure options.  Thanks for pointing out the\n  ambigous wording, Heike.\n\n  * 81a86c2b src/components/infiniband/Rules.infiniband\n  src/components/infiniband/linux-infiniband.c\n  src/components/infiniband/tests/Makefile: Infiniband component: use\n  dlopen/dlsym for symbols  Apply Gary Mohr's patch to switch the infiniband\n  component over to dl* with the same motivations as the cuda component.\n\n2013-05-02  \n\n  * 2e6bcb2a src/utils/native_avail.c: Add two command line switches: -i\n  EVENTSTR includes only events whose names contain EVENTSTR; -x EVENTSTR\n  excludes all events whose names contain EVENTSTR.  These two switches can be\n  combined, but only one string per switch can be used. This allows you to, for\n  example, filter events by component name, or eliminate all uncore events on\n  Sandy Bridge\u2026\n\n2013-05-01  \n\n  * 3163cc83 src/ctests/perf_event_uncore.c: ctests/perf_event_uncore: add\n  IvyBridge support  this needs an updated libpfm4 to work\n\n2013-04-30  \n\n  * 55c89673 src/examples/add_event/Papi_add_env_event.c\n  src/examples/overflow_pthreads.c: Examples: Missed two instances of %x printf\n  formating.\n\n2013-04-29  \n\n  * b3c5bd47 src/components/appio/tests/appio_list_events.c\n  src/components/appio/tests/appio_values_by_code.c\n  src/components/appio/tests/appio_values_by_name.c...: Address TRAC 174: Let\n  printf do the formatting  https://icl.cs.utk.edu/trac/papi/ticket/174 174:\n  PAPI's debuggin/info output should use %# conversions for octal and hex\n  ------------------------+-------------------- Reporter:  sbk@\u2026        |    \n   Owner: Type:  enhancement  |     Status:  new Priority:  normal       | \n  Component:  All Version:  HEAD         |   Severity:  normal Keywords:       \n         | ------------------------+-------------------- Email sent to James\n  Ralph:  Seeing your latest change reminded me: Anytime there is a value\n  issued in hex or octal the \"%#\" conversion should be used so the value is\n  always preceded with a \"0\" for octal or a \"0x\" for hex. Otherwise when a\n  value is printed one can not tell the base it is in (one shouldn't have to\n  rely on internal knowledge of the code or the context to tell). For variables\n  that are pointers the \"%p\" conversion can be used (this will always use an\n  hex syntax).  It would be nice to apply this to all PAPI print statements in\n  their entirety.\n\n2013-04-25  \n\n  * 87ec9286 src/components/vmware/Rules.vmware: Rules.vmware: Use $(LDL) no\n  -ldl  Minor cleanup, but configure sets it, so why not use it.\n\n2013-04-26  \n\n  * 8dddd587 src/papi_hl.c: papi_hl: Use PAPI_get_virt_usec() for process time \n  The code was using cycles / MHz which is not guaranteed to work on modern\n  machines.  It also was sometimes using (instructions / estimated IPC) / MHz\n  which hopefully isn't necessary for any machine PAPI currently supports. \n  Instead use PAPI_get_virt_usec() which should give the right value.\n\n2013-04-25  \n\n  * 9dd36088 src/ctests/perf_event_uncore.c: ctests/perf_event_uncore: make\n  more modular  Cleans up the code to make it easier to add tests for\n  architectures other than SandyBridge-EP.  I was doing this so I could add\n  support for IvyBridge but it turns out neither Linux nor libpfm4 supports\n  uncore on IvyBridge yet.  hmmm.\n\n  * 52ff0293 src/components/cuda/Rules.cuda: Rules.cuda:  The cuda component\n  now depend on the dynamic linking loader and on some systems one has to\n  explicitly link to it.  Add $(LDL) to LD_FLAGS, configure sets it if we need\n  it.\n\n  * 97a4a5ea src/components/cuda/Rules.cuda src/components/cuda/linux-cuda.c\n  src/components/cuda/tests/Makefile: Cuda component enhancement. \n  ---------------- From Gary's submission--------------------------------- The\n  current packaging of the cuda component in PAPI has a fairly unfriendly side\n  effect.  When PAPI is built with the cuda component, then that copy of PAPI\n  can only be used on systems where the cuda libraries are installed. If it is\n  installed on a system without these libraries then all PAPI services fail\n  because they have references to libraries which can not be found.  Even\n  papi_avail which you would think has nothing to do with cuda reports the\n  error.  This issue significantly complicates the delivery and install of the\n  PAPI package on large clusters where some of the nodes have NVIDIA GPU's (and\n  the cuda libraries to talk to them) and other nodes do not have GPU's (and\n  therefore no software to access them).  I have been working with the help of\n  Phil Mucci to eliminate this dependency so that a copy of PAPI built with a\n  cuda component could be installed on all nodes in the cluster and if the node\n  had NVIDIA GPU's (and libraries available) then the cuda component would get\n  enabled and could be used.  If the node did not have the hardware or the\n  access libraries were not available, then the cuda component would just\n  disable itself at component initialization so it could not be used (but all\n  other PAPI services would still work).  Phil has provided some gentle\n  prodding and lots of valuable suggestions to assist this effort.  I now think\n  that I have a working version of this capability and am ready to share it\n  with the community.\n  -----------------------------------------------------------------------  Many\n  thanks to Gary Mohr and Phil Mucci for this much needed functionality.\n\n2013-04-23  \n\n  * 99c8e352 src/papi_internal.c: papi_internal.c: Print an eventcode in hex vs\n  decimal.  Thanks, Gary Mohr.\n\n2013-04-22  \n\n  * 1fc5dae2 src/run_tests.sh: The test for determining whether to run valgrind\n  was backwards. Correcting that allow the run_test.sh script to stay the same\n  and one just needs to define \"VALGRIND=yes\" (or any non-null string) to make\n  run_test.sh use valgrind.  --- src/run_tests.sh | 6 ++---- 1 file changed, 2\n  insertions(+), 4 deletions(-)  diff --git a/src/run_tests.sh\n  b/src/run_tests.sh index d1ce205..9337ff2 100755 --- a/src/run_tests.sh +++\n  b/src/run_tests.sh @@ -19,10 +19,8 @@ else export TESTS_QUIET fi  -if [\n  \"x$VALGRIND\" = \"x\" ]; then -# Uncomment the following line to run tests using\n  Valgrind -# VALGRIND=\"valgrind --leak-check=full\"; -    VALGRIND=\"\"; +if [\n  \"x$VALGRIND\" != \"x\" ]; then +    VALGRIND=\"valgrind --leak-check=full\"; fi \n  #CTESTS=`find ctests -maxdepth 1 -perm -u+x -type f`; --\n\n2013-04-19  \n\n  * 4cf16234 src/components/README src/components/bgpm/README\n  src/components/coretemp_freebsd/README...: Restructure README files for\n  components so that the file in the components directory doesn't document\n  individual component details. Add README files to each component directory\n  that requires further installation detail. Update RAPL instructions to\n  capture how to enable reading the MSRs. These files are supposedly configured\n  with Doxygen markup, but I don't think the master README ever got built. It\n  probably should.\n\n2013-04-17  \n\n  * bf75d226 src/components/cuda/tests/HelloWorld.cu: cuda/tests/HelloWorld.cu:\n  workaround a segfault.  Report from Gary Hohr\n  \n   I was running the Cuda test case on a system which did not actually have any\n  NVIDIA GPU's installed on it (but the cuda software was installed and papi\n  was built with the cuda component).  I modified the test case to put an real\n  cuda event in the source (as suggested in the source).  When I run the test\n  case the cuda component gets disabled in PAPI_library_init (because\n  detectDevice function can not find any GPU's) which is the correct behavior.\n  The test case then calls PAPI_event_name_to_code which failed because the\n  cuda component was disabled.  The test case then created an event set and\n  called PAPI_add_events with an empty list of events to be added.  This led to\n  a segfault somewhere inside libpfm4.  The attached patch makes some minor\n  changes to protect against this problem.  I noticed this test case does not\n  use the PAPI test framework utilities (test_xxxx functions) so I did not\n  modify the test to use them.\n\n2013-04-15  \n\n  * 457bfd74 src/components/cuda/linux-cuda.c: When creating two event sets -\n  one for the CUDA and one for the CPU component  - the order of event set\n  creation appears crucial. When the CPU event set has been created before the\n  CUDA event set then PAPI_start() for the CUDA event set works fine. However,\n  if the CUDA event set has been created before the CPU event set, then\n  PAPI_start(CUDA_event_set) forces the CUDA control state to be updated one\n  more time, even if the CUDA event set has not been modified. The CUDA control\n  state function did not properly handle this case and hence cause PAPI_start()\n  to fail. This has been fixed.\n\n  * 807120b6 src/components/cuda/linux-cuda.h: linux-cuda.c\n\n2013-03-28  \n\n  * 7b0eec7a src/run_tests.sh: run_tests.sh: further refine component test find\n   Exclude *.cu when looking for component tests.\n\n2013-03-25  \n\n  * 6a40c8ba src/run_tests.sh: run_tests.sh: File mode changes.  run_tests.sh\n  is now expected to run from the install location in addition to src. The\n  script tried to remove execute from *.[c|h], now it just excludes *.[c|h]\n  from the find commands.\n\n2013-03-18  \n\n  * 2ba9f473 src/perfctr-x86.c: perfctr: don't read in event table multiple\n  times  papi_libpfm3_events.c now reads in the predefined events, we don't\n  also need to do this in perfctr setup_x86_presets()\n\n  * 326401b1 src/perfctr.c: Fix segfault in perfctr.c  The preset lookup uses\n  the cidx index, but in perfctr.c we weren't passing a cidx value (it was\n  being left off).  The old perfctr code plays games with defining extern\n  functions so the compiler wasn't giving us a warning.\n\n2013-03-14  \n\n  * 50130c6f src/components/bgpm/L2unit/linux-L2unit.c src/linux-bgq.c: If a\n  counter is not set to overflow (threshold==0; happens when PAPI_shutdown is\n  called) then we do not want to rebuild the BGPM event set, even if the event\n  set has been used previously and hence \"applied or attached\". Usually if an\n  event set has been applied or attached prior to setting overflow, the BGPM\n  event set needs to be deleted and recreated (which implies malloc() from\n  within BGPM). Not so, though, if threshold is 0 which is the case when\n  PAPI_shutdown is called.  Note, this only applies to Punit and L2unit, not\n  IOunit since an IOunit event set in not applied or attached.\n\n2013-03-13  \n\n  * 1a143003 src/components/bgpm/IOunit/linux-IOunit.c\n  src/components/bgpm/IOunit/linux-IOunit.h\n  src/components/bgpm/L2unit/linux-L2unit.c...: Overflow issue on BG/Q\n  resolved. Overflow with multiple components worked; overflow with multiple\n  components and multiple events did not work as supposed to.\n\n  * 42741a40 src/components/cuda/Rules.cuda: Added one more library to linker\n  command.\n\n2013-03-12  \n\n  * 1431eb3f src/components/nvml/Makefile.nvml.in\n  src/components/nvml/Rules.nvml src/components/nvml/configure...: NVML\n  component: build system work  Adopt the cuda component's method for\n  specifying library location.\n\n2013-03-11  \n\n  * ce66feac src/components/mx/linux-mx.c: mx component: Modernize init\n  routine.  Add component index to _mx_component_init()s signarure and set the\n  bit in component info.\n\n  * 1c1bc177 src/components/cuda/Makefile.cuda.in\n  src/components/cuda/Rules.cuda src/components/cuda/configure...: Resolve\n  configure issues for CUDA component.\n\n2013-03-07  \n\n  * f3572537 src/linux-common.c src/linux-memory.c: Fix the build on\n  Linux-SPARC  I dug out an old SPARC machine and fixed the PAPI build on it.\n\n  * 2c7f102c src/perf_events.c: More comprehensive sys_perf_open to PAPI error\n  mappings  This tries to cover more of the errors returned by sys_perf_open\n  and map them to better results.  EINVAL is a problem because it can mean\n  Conflict as well as Event not found and many other things, so it's unclear\n  what to do with it.\n\n  * 299070ef src/perf_events.c src/sys_perf_event_open.c: Return proper error\n  codes for sys_perf_event_open  For some reason on x86 and x86_64 we were\n  trying to set errno manually and thus over-writing the proper errno value,\n  causing all errors to look like PAPI_EPERM  This removes that code, as well\n  as adds code to report ENOENT as PAPI_ENOEVENT.  With this change, on IVY\n  this happens which looks more correct.  ./utils/papi_command_line\n  perf::L1-ICACHE-PREFETCHES Failed adding: perf::L1-ICACHE-PREFETCHES because:\n  Event does not exist command_line.c                       PASSED\n\n2013-03-06  \n\n  * baa557ca src/papi_libpfm4_events.c src/papi_user_events.c: Coverity fixes: \n  Coverity pointed out that there was a case where load_user_eent_table() could\n  leak memory.  The change in the location of the papi_free(foo) ensures that\n  the allocated memory is freed.  Coverity pointed out one path through the\n  code in _papi_libpfm4_ntv_code_to_descr() that did not free up memory\n  allocated in the function.  Added a free on the path in free up that memory. \n  Thanks Will Cohen.\n\n2013-02-14  \n\n  * 395b7bc7 src/Makefile.inc src/components/README\n  src/components/appio/tests/Makefile...: Add component tests' to the\n  install-[all|tests] target.  Thanks to Gary Mohr. ------------------- This\n  makes a fairly small change to src/Makefile.inc to add logic that adds a new\n  install-comp_tests target which calls the install target for each component\n  being built. This new target is listed as a dependency on the install-tests\n  target so it will happen when the 'install-all', 'install-tests', or\n  'install-comp_tests' targets are used. A note about this change, I am not\n  real familiar with the auto make and auto conf tools. This change was enough\n  to make it work for me but if there is another file that should also be\n  changed for this modification, please help me out here.  The patch also adds\n  install targets to the Makefiles for all of the components which have 'tests'\n  directories and updates the README file which talks about how to create\n  component tests.  Another note, I only compile with a couple of components\n  (ours, rapl, and example) so if I fat fingered something in one of the other\n  components Makefiles I would not have noticed. Please keep me honest and make\n  sure you compile with them all enabled.  Thanks for adding this capability\n  for us. Gary ---------------------------  Makefile.inc: Add run_tests and\n  friends to install-tests target.  Component test Makefiles' get their install\n  location to mirror what runtests expects.\n\n2013-03-04  \n\n  * 448d21ab src/components/rapl/linux-rapl.c: Remove a stray debug statement.\n  Thanks to Harald Servat for catching this.\n\n2013-03-01  \n\n  * df1a75cc src/utils/command_line.c: Wrestled some horribly convoluted\n  indexing into shape. The -u and -x options now print as expected (I think).\n\n2013-01-31  \n\n  * b0f5f4d6 src/components/nvml/linux-nvml.c: linux-nvml.c: Fix type warning. \n  CUDA and NVML have an signed vs unsigned thing going on in their returned\n  device counts, cast away the warning.\n\n2013-01-29  \n\n  * 8490b4ee src/papi.c: General doxygen cleanup: remove all \"No known bugs\"\n  messages; correct and cleanup examples for PAPI_code_to_name and\n  PAPI_name_to_code\n\n2013-01-23  \n\n  * 89e45a9b src/linux-memory.c src/linux-timer.c: ia64 fixes.  Thanks to Tony\n  Jones <tonyj@suse.de> for patches.\n\n2013-01-16  \n\n  * 23e0ba2d src/components/nvml/linux-nvml.c: nvml component: cleanup a memory\n  leak  We did not free a buffer at shutdown time.\n\n2013-01-15  \n\n  * f3db85fc src/papi.h: papi.h bump version number.\n\n  * dfa80287 src/buildbot_configure_with_components.sh: Buildbot configure\n  script.  Add cuda and nvml components, if configured, to the buildbot\n  coverage test. Note: Script now checks for existance of Makefile.cuda and\n  then Makefile.nvml so see if it can build the cuda component and then if it\n  can build the nvml component.\n\n  * cf416e27 src/threads.c: Cleaned up compiler warning (gcc version 4.4.6)\n\n  * 59cbc8fc src/components/bgpm/CNKunit/linux-CNKunit.c\n  src/components/bgpm/IOunit/linux-IOunit.c\n  src/components/bgpm/L2unit/linux-L2unit.c...: Cleaned up compiler warnings on\n  BG/Q (gcc version 4.4.6 (BGQ-V1R1M2-120920))\n\n2013-01-14  \n\n  * 3af71658 .../build/lib.linux-x86_64-2.7/perfmon/__init__.py\n  .../lib.linux-x86_64-2.7/perfmon/perfmon_int.py\n  .../build/lib.linux-x86_64-2.7/perfmon/pmu.py...: libpfm4: remove extraneous\n  build artifacts.  Steve Kaufmann reported differences between the libpfm4 I\n  imported into PAPI and the libpfm4 that can be attained with a git clone\n  git://perfmon2.git.sourceforge.net/gitroot/perfmon2/libpfm4  Self: Do libpfm4\n  imports from a fresh clone of libpfm4.\n",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.6.0-iweh6uy7qfzcgjj77nhy45ucjhpm2ow6/spack-src/ChangeLogP560.txt": "Tue Dec 5 20:10:50 2017 -0800  William Cohen <wcohen@redhat.com>\n\n\t* src/libpfm4/lib/events/power9_events.h,\n\t  src/libpfm4/tests/validate_power.c: Update libpfm4 Current with\n\t  commit 206dea666e7c259c7ca53b16f934660344293475  Ensure unique\n\t  names for IBM Power 9 events  Older versions of PAPI use the event\n\t  name to look up the libpfm event number when doing the enumeration\n\t  of the available events.  If there were multiple events with the\n\t  same name in libpfm, the earliest one would be selected.  This\n\t  selection would cause the enumeration of events in\n\t  papi_native_avail to get stuck looping on the first duplicated\n\t  named event in a pmu.  In the case of IBM Power 9 the enumeration\n\t  would get stuck on PM_CO0_BUSY. Gave each event a unique name to\n\t  avoid this unfortunate behavior.\n\n2017-11-16  Will Schmidt <will_schmidt@vnet.ibm.com>\n\n\t* src/papi_events.csv: revised papi_derived patch.  [PATCH, papi]\n\t  Updated derived entries for power9.  This is a re-implementation of\n\t  the patch that Will Cohen posted earlier, which uses the (newly\n\t  defined) PM_LD_MISS_ALT entry instead of the PM_LD_MISS_FIN .\n\t  Thanks, -Will\n\n2017-12-05  Heike Jagode (jagode@icl.utk.edu) <jagode@saturn.icl.utk.edu>\n\n\t* release_procedure.txt: Updated notes for release procedure.\n\n2017-12-05  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/extras.c: extras.c: add string.h include to make the ffsll\n\t  warning go away\n\n2017-12-04  Heike Jagode (jagode@icl.utk.edu) <jagode@saturn.icl.utk.edu>\n\n\t* src/configure, src/configure.in: Fixed configure bug:  Once ffsll\n\t  support is detected, set HAVE_FFSLL to 1 in config.h.  Tested\n\t  without configure flag --with-ffsll, with --with-ffsll=yes, --with-\n\t  ffsll=no.\n\n2017-12-04  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/ctests/Makefile.recipies, src/ctests/locks_pthreads.c: ctests:\n\t  locks_pthreads: adjust run count again  linear slowdown makes\n\t  things run really quickly. This patch scales it down by the square\n\t  root of the number of cores which is maybe a better compromise.\n\t* src/ctests/locks_pthreads.c: ctests: locks_pthreads, minor cleanups\n\n2017-11-20  William Cohen <wcohen@redhat.com>\n\n\t* src/ctests/locks_pthreads.c: Keep locks_pthreads test's amount of\n\t  work reasonable on many core machines  The runtime of\n\t  locks_pthreads test scaled by the number of processors on the\n\t  machine because of the serialized increment operation in the test.\n\t  As more machines are available with 100+ processors the runtime of\n\t  locks_pthreads is becoming execessive.  Revised the test to specify\n\t  the approximate total number of iterations and split the work the\n\t  threads.\n\nFri Dec 4 11:31:46 2015 -0500  sangamesh <sragate@vols.utk.edu>\n\n\t* src/extras.c, src/papi.h: Revert change that added ffsll to papi.h\n\t  This reverts commit 2f1ec33a9e585df1b6343a0ea735f79974c080df.\n\t  commit 2f1ec33a9e585df1b6343a0ea735f79974c080df  changed #if\n\t  (!defined(HAVE_FFSLL) || defined(__bgp__)) int ffsll( long long lli\n\t  ); #endif --- to --- extern int ffsll( long long lli  in extras.c\n\t  to avoid warning when --with-ffsll is used as config option\n\nThu Apr 20 11:31:38 2017 -0400  Stephen Wood <swood@icl.utk.edu>\n\n\t* src/extras.c, src/papi.h: revert part of patch that added extra\n\t  attributes to ffsll  This manually reverts part of:  commit\n\t  9e199a8aee48f5a2c62d891f0b2c1701b496a9ca  cast pointers\n\t  appropriately to avoid warnings and errors\n\nSun Dec 3 09:42:44 2017 -0800  Will Schmidt <will_schmidt@vnet.ibm.com>\n\n\t* src/libpfm4/lib/events/power9_events.h,\n\t  src/libpfm4/tests/validate_power.c: Updated libpfm4  Current with:\n\t  ---------------- commit ed3f51c4690685675cf2766edb90acbc0c1cdb67\n\t  (HEAD -> master, origin/master, origin/HEAD)  Add alternate event\n\t  numbers for power9.  I had previously missed adding the _ALT\n\t  entries, which allow some events to be specified on different\n\t  counters. This patch fills those in.  This patch also adds a few\n\t  validation tests for the ALT events.  ----------------\n\n2017-11-28  Heike Jagode (jagode@icl.utk.edu) <jagode@saturn.icl.utk.edu>\n\n\t* src/utils/papi_avail.c, src/utils/papi_native_avail.c: Fixed\n\t  utility option inconsistencies between papi_avail and\n\t  papi_native_avail. There are more inconsistencies with other PAPI\n\t  utilities, which will be addressed eventually.\n\n2017-11-28  Heike Jagode <jagode@icl.utk.edu>\n\n\t* README.md: README.md edited online with Bitbucket\n\t* README.md: README.md edited online with Bitbucket\n\t* README.md: README.md edited online with Bitbucket\n\t* README.md: README.md edited online with Bitbucket\n\n2017-11-27  Heike Jagode <jagode@icl.utk.edu>\n\n\t* src/components/powercap/linux-powercap.c: More clean-ups and\n\t  checking of return values.\n\nMon Nov 13 23:15:53 2017 -0800  Thomas Richter <tmricht@linux.vnet.ibm.com>\n\n\t* src/libpfm4/lib/pfmlib_common.c: Update libpfm4\u201d > /tmp/commit-\n\t  libpfm4-header.txt echo \u201cCurrent with commit\n\t  f5331b7cbc96d9f9441df6a54a6f3b6e0fab3fb9  better fix for\n\t  pfmlib_getl()  The following commit:  commit\n\t  9c69edf67f6899d9c6870e9cb54dcd0990974f81  better param check in\n\t  pfmlib_getl()  Fixed paramter checking of pfmlib_getl() but missed\n\t  one condition on the buffer argument. It is char **buffer.\n\t  Therefore we need to check if *buffer is not NULL before we can\n\t  check *len.\n\n2017-11-19  Asim YarKhan <yarkhan@icl.utk.edu>\n\n\t* src/components/cuda/linux-cuda.c: CUDA component: Bug fix for\n\t  releasing and resetting event list  When an event addition failed\n\t  because the event (or metric) requires multiple-runs the eventlist\n\t  and event-context structure was not being cleaned up properly.\n\t  This fixes the event cleanup process.\n\n2017-11-17  Asim YarKhan <yarkhan@icl.utk.edu>\n\n\t* src/components/powercap/tests/powercap_basic.c,\n\t  src/components/powercap/tests/powercap_limit.c: Powercap component:\n\t  Updated tests to handle no-event-counters (num_cntrs==0) and skip\n\t  some compiler warnings (argv, argc unused)\n\n2017-11-16  William Cohen <wcohen@redhat.com>\n\n\t* src/components/lmsensors/linux-lmsensors.c: Make more of lmsensors\n\t  component internal state hidden  There are a number of functions\n\t  pointers stored in variable that are only used within the lmsensors\n\t  component.  Making those static ensures they are not visible\n\t  outside the lmsensors component.\n\t* src/components/lmsensors/linux-lmsensors.c: Make internal\n\t  cached_counts variable static  Want to make as little information\n\t  about the internals of the PAPI lmsensors component visible to the\n\t  outside.  Thus, making cached_counts variable static.\n\n2017-11-15  William Cohen <wcohen@redhat.com>\n\n\t* src/components/lmsensors/linux-lmsensors.c: Avoid statically\n\t  limiting the number of lmsensor events allowed  Some high-end\n\t  server machines provide more events than the 512 entries limit\n\t  imposed by the LM_SENSORS_MAX_COUNTERS define in the lmsensor\n\t  component (observed 577 entries on one machine).  When this limit\n\t  was exceeded the lmsensor component would write beyond the array\n\t  bounds causing ctests/all_native_events to crash.  Modified the\n\t  lmsensor code to dynamically allocate the required space for all\n\t  the available lmsensor entries on the machine. This allows\n\t  ctests/all_native_events to run to completion.\n\t* src/components/appio/appio.c, src/components/coretemp/linux-\n\t  coretemp.c, src/components/example/example.c,\n\t  src/components/infiniband/linux-infiniband.c, src/components/lustre\n\t  /linux-lustre.c, src/components/rapl/linux-rapl.c: Use correct\n\t  argument order for calloc function calls  Some calls to calloc in\n\t  PAPI have the order of the arguments reversed. According to the\n\t  calloc man page the number of elements is the first argument and\n\t  the size of each element is the second argument.  Due to alignment\n\t  constraints the second argument might be rounded up.  Thus, it is\n\t  best not to not to swap the arguments to calloc.\n\n2017-11-15  Philip Vaccaro <pvaccaro@vols.utk.edu>\n\n\t* src/components/powercap/linux-powercap.c,\n\t  src/components/powercap/tests/powercap_basic.c: Updates and changes\n\t  to the powercap component to address a few areas.. Various things\n\t  were changed but mainly things were simplified and made more\n\t  streamlined.  Main focus was on simpifying managing the sytem\n\t  files.\n\nMon Nov 13 23:15:53 2017 -0800  Thomas Richter <tmricht@linux.vnet.ibm.com>\n\n\t* src/libpfm4/docs/man3/pfm_get_event_encoding.3,\n\t  src/libpfm4/docs/man3/pfm_get_os_event_encoding.3,\n\t  src/libpfm4/lib/events/amd64_events_fam11h.h,\n\t  src/libpfm4/lib/events/amd64_events_fam12h.h,\n\t  src/libpfm4/lib/pfmlib_common.c, src/libpfm4/lib/pfmlib_priv.h,\n\t  src/libpfm4/tests/validate_x86.c: Update libpfm4  Current with\n\t  commit 9c69edf67f6899d9c6870e9cb54dcd0990974f81  better param check\n\t  in pfmlib_getl()  This patch ensures tha len >= 2 because we do: m\n\t  = l - 2;  Reviewed-by: Hendrik Brueckner\n\t  <brueckner@linux.vnet.ibm.com>\n\n2017-11-13  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/components/perf_event/pe_libpfm4_events.c: pe_libpfm4_events:\n\t  properly notice if trying to add invalid umask  this passes the\n\t  broken-event test case and all of the unit tests, but it would be\n\t  good to test this on codes that do a lot of native event tests.\n\t  the pe_libpfm4_events code *really* needs a once-over, it is\n\t  currently a confusing mess.\n\t* src/components/perf_event/tests/Makefile,\n\t  src/components/perf_event/tests/broken_events.c,\n\t  src/components/perf_event/tests/event_name_lib.c,\n\t  src/components/perf_event/tests/event_name_lib.h: perf_event/tsts:\n\t  add broken event name test  we were wrongly accepting event names\n\t  with invalid umasks\n\n2017-11-13  Philip Mucci <mucci@icl.utk.edu>\n\n\t* src/utils/print_header.c: Removed extraneous colon in VM vendor\n\t  output\n\n2017-11-10  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/validation_tests/papi_l1_dcm.c,\n\t  src/validation_tests/papi_l2_dcm.c,\n\t  src/validation_tests/papi_l2_dcr.c,\n\t  src/validation_tests/papi_l2_dcw.c: validation_tests: fix compiler\n\t  warnings on arm32  On Raspberry Pi we were getting warnings where\n\t  we were printing sizeof() valus with %ld.  Convert to %zu instead.\n\n2017-11-09  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/validation_tests/papi_l2_dca.c: validation_tests: papi_l2_dca\n\t  fix crash on ARM32  On raspberry pi it's not possible to detect L2\n\t  cache size so the test was dividing by zero.\n\t* src/linux-common.c: linux-common: remove warning on not finding mhz\n\t  in cpuinfo  This was added recently and is not needed. Most ARM32\n\t  devices don't have MHz in the cpuinfo file and it's not really a\n\t  bug.\n\t* src/components/perf_event/perf_event.c: perf_event: disable the old\n\t  pre-Linux-2.6.34 workarounds by default  There were a number of\n\t  bugs in perf_event that PAPI had to work around, but most of these\n\t  were fixed by 2.6.34  In order to hit these bugs you would need to\n\t  be running a kernel from before 2010 which wouldn't support any\n\t  recent hardware.  Unfortunately these bugs are hard to test for.\n\t  We were enabling things based on kernel versions, but this caught\n\t  vendors (such as Redhat) shipping 2.6.32 kernels that had\n\t  backported fixes.  This fix just #ifdefs things out, if no one\n\t  complains then we can fully remove the code.\n\t* src/components/perf_event/perf_event.c: perf_event: decrement the\n\t  available counter count if NMI_WATCHDOG is stealing one\n\t* src/components/perf_event/perf_event.c: perf_event: move the\n\t  paranoid handling code to its own function\n\t* src/components/perf_event/perf_event.c: perf_event: centralize\n\t  fast_counter_read flag  just use the component version of the flag,\n\t  rather than having a shadow global version.\n\n2017-11-09  William Cohen <wcohen@redhat.com>\n\n\t* src/linux-memory.c: Make the fallback generic_get_memory_info\n\t  function more robust  On the aarch64 processor linux 4.11.0 kernels\n\t  /sys/devices/system/cpu/cpu0/cache is available, but the index[0-9]\n\t  subdirectories are not fully populated with information about cache\n\t  and line size, associativity, or number of sets.  These missing\n\t  files would cause the generic_get_memory_info function to attempt\n\t  to read data using a NULL file descriptor causing the program to\n\t  crash.  Added checks to see if every fopen was and fscan was\n\t  successful and just say there is no cache if there is any failure.\n\n2017-11-09  Asim YarKhan <yarkhan@icl.utk.edu>\n\n\t* src/components/cuda/linux-cuda.c,\n\t  src/components/cuda/tests/Makefile,\n\t  src/components/nvml/tests/Makefile, src/configure,\n\t  src/configure.in: Enable icc and nvcc to work together in cuda and\n\t  nvml components.  For nvcc to work with Intel icc to compile cuda\n\t  and nvml components and tests , it needs to use nvcc -ccbin=<$CC-\n\t  compilerbin> . The compiler name in CC also needs to be clean, so\n\t  CC=<compilerbin> and any other flags are pushed to CFLAGS (changed\n\t  in src/configure.in script).\n\t* src/ctests/mpifirst.c: Minor correction to mpifirst.c test\n\n2017-11-09  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/utils/print_header.c: utils: print fast_counter_read (rdpmc)\n\t  status in the utils header\n\n2017-11-08  William Cohen <wcohen@redhat.com>\n\n\t* src/validation_tests/cache_helper.c: Ensure access to array within\n\t  bounds  Coverity reported the following issues.  Need the test to\n\t  be \"type>=MAX_CACHE\" rather than \"type>MAX_CACHE\".  Error: OVERRUN\n\t  (CWE-119): papi-5.5.2/src/validation_tests/cache_helper.c:85:\n\t  cond_at_most: Checking \"type > 4\" implies that \"type\" may be up to\n\t  4 on the false branch.\n\t  papi-5.5.2/src/validation_tests/cache_helper.c:90: overrun-local:\n\t  Overrunning array \"cache_info\" of 4 24-byte elements at element\n\t  index 4 (byte offset 96) using index \"type\" (which evaluates to 4).\n\t  Error: OVERRUN (CWE-119):\n\t  papi-5.5.2/src/validation_tests/cache_helper.c:101: cond_at_most:\n\t  Checking \"type > 4\" implies that \"type\" may be up to 4 on the false\n\t  branch. papi-5.5.2/src/validation_tests/cache_helper.c:106:\n\t  overrun-local: Overrunning array \"cache_info\" of 4 24-byte elements\n\t  at element index 4 (byte offset 96) using index \"type\" (which\n\t  evaluates to 4).  Error: OVERRUN (CWE-119):\n\t  papi-5.5.2/src/validation_tests/cache_helper.c:117: cond_at_most:\n\t  Checking \"type > 4\" implies that \"type\" may be up to 4 on the false\n\t  branch. papi-5.5.2/src/validation_tests/cache_helper.c:122:\n\t  overrun-local: Overrunning array \"cache_info\" of 4 24-byte elements\n\t  at element index 4 (byte offset 96) using index \"type\" (which\n\t  evaluates to 4).\n\t* src/ctests/overflow_pthreads.c: Eliminate coverity overflow warning\n\t  about expression\n\t* src/components/perf_event_uncore/tests/perf_event_uncore_lib.c:\n\t  Remove dead code from perf_event_uncore_lib.c\n\n2017-11-09  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/components/perf_event/perf_event.c: perf_event: don't\n\t  initialize globals statically  from the mucci-5.5.2 tree\n\n2017-11-08  phil@minimalmetrics.com <phil@minimalmetrics.com>\n\n\t* src/linux-common.c: linux-common: clean up the /proc/cpuinfo\n\t  parsing code  From the mucci-cleanup branch\n\t* src/components/perf_event/perf_event.c,\n\t  .../perf_event_uncore/perf_event_uncore.c,\n\t  src/papi_libpfm4_events.c, src/papi_libpfm4_events.h: perf_event:\n\t  clean up _papi_libpfm4_shutdown()  From the mucci-cleanup branch\n\t* src/utils/print_header.c: utils: clean up the cpuinfo header  From\n\t  the mucci-cleanup branch\n\t* src/papi_internal.c, src/papi_internal.h: papi_internal: add\n\t  PAPI_WARN() function  From the mucci-cleanup branch\n\t* src/components/perf_event/pe_libpfm4_events.c: perf_event: clean up\n\t  pe_libpfm4_events  From the mucci-cleanup branch  --\n\n2017-11-08  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/utils/papi_avail.c: utils/papi_avail: update the manpage info\n\t  based on changes by Phil Mucci\n\t* .../perf_event/tests/perf_event_system_wide.c: perf_event tests:\n\t  perf_event_system_wide: don't fail if permissions restrict system-\n\t  wide events  right now we just skip if we get EPERM, we should also\n\t  maybe check the perf_event_paranoid setting and print a more\n\t  meaningful report\n\t* src/ctests/locks_pthreads.c: ctests/locks_pthreads: avoid printing\n\t  values when in quiet mode\n\n2017-08-31  phil@minimalmetrics.com <phil@minimalmetrics.com>\n\n\t* src/Makefile.inc: Better symlink creation for shared library in\n\t  make phase\n\n2017-08-28  phil@minimalmetrics.com <phil@minimalmetrics.com>\n\n\t* doc/Makefile, src/.gitignore, src/Makefile.inc,\n\t  src/components/.gitignore, src/components/Makefile_comp_tests,\n\t  src/ctests/.gitignore, src/ctests/Makefile.recipies,\n\t  src/ftests/.gitignore, src/ftests/Makefile.recipies,\n\t  src/testlib/.gitignore, src/utils/.gitignore, src/utils/Makefile,\n\t  src/validation_tests/.gitignore,\n\t  src/validation_tests/Makefile.recipies: Full cleanup, including\n\t  removal of .gitignore files that prevented us from realizing we\n\t  were really cleaning/clobbering properly\n\t* src/validation_tests/.gitignore: .gitignore Makefile.target\n\t* src/papi.c: Remove PAPI_VERB_ECONT setting by default from\n\t  initialization path. This prints all kinds of needless errors on\n\t  virtual platforms.\n\t* src/x86_cpuid_info.c: Remove leftover printf\n\n2017-08-21  phil@minimalmetrics.com <phil@minimalmetrics.com>\n\n\t* src/ctests/locks_pthreads.c: Test now performs a fixed number of\n\t  iterations, and reports lock/unlock timings per thread.\n\t* src/components/perf_event/perf_event.c: Added more descriptive\n\t  error message to exclude_guest check\n\t* src/papi_internal.c: Removed leading newline and trailing . from\n\t  error messages\n\t* src/papi_preset.c: Updated message for derived event failures\n\n2017-11-07  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/Makefile.inc, src/ctests/Makefile,\n\t  src/ctests/Makefile.target.in, src/ftests/Makefile,\n\t  src/ftests/Makefile.target.in, src/testlib/Makefile.target.in,\n\t  src/utils/Makefile.target.in, src/validation_tests/Makefile,\n\t  src/validation_tests/Makefile.target.in: tests: make sure DESTDIR\n\t  and DATADIR are passed in when doing an install\n\t* src/ctests/Makefile, src/ctests/Makefile.target.in,\n\t  src/ftests/Makefile, src/ftests/Makefile.target.in,\n\t  src/utils/Makefile, src/utils/Makefile.target.in,\n\t  src/validation_tests/Makefile,\n\t  src/validation_tests/Makefile.target.in:\n\t  ctests/ftests/utils/validation_tests: get shared library linking\n\t  working again  This should let the various tests and utils be\n\t  linked as shared libraries again.\n\t* src/validation_tests/Makefile: validation_tests: add an\n\t  installation target  this makes the validation tests have an\n\t  install target, like the ctests and ftests\n\t* src/ctests/Makefile, src/ftests/Makefile: ctests/ftests: fix\n\t  \"install\" target  at some point DATADIR was renamed datadir and the\n\t  install targets were not updated.\n\n2017-11-07  Asim YarKhan <yarkhan@icl.utk.edu>\n\n\t* bitbucket-pipelines.yml: Bitbucket pipeline testing: Inspired by\n\t  Phil Mucci's branch; copied the functionalty tests run in that\n\t  branch.\n\t* src/components/lmsensors/linux-lmsensors.c: lmsensors component:\n\t  Changed event names to use lm_sensors (only once) instead of\n\t  LM_SENSORS (twice) to be consistent with other events\n\n2017-11-02  William Cohen <wcohen@redhat.com>\n\n\t* src/components/appio/tests/iozone/gnu3d.dem: gnu3d.dem should not\n\t  be executed by the test framework  This file is a gnuplot file and\n\t  should not be executed as part of the tests. Removing the\n\t  executable perms will signal to the testing framework that it\n\t  shouldn't be executed.\n\t* src/components/appio/tests/iozone/Gnuplot.txt: Gnuplot.txt should\n\t  not be executed by the test framework  This file is a readme file\n\t  and should not be executed as part of the tests. Removing the\n\t  executable perms will signal to the testing framework that it\n\t  shouldn't be executed.\n\t* .../appio/tests/iozone/iozone_visualizer.pl,\n\t  src/components/appio/tests/iozone/report.pl: Fix perl scripts so\n\t  they run on Linux machines  The DOS style newlines were preventing\n\t  Linux from selecting the appropriate interpreter for these scripts\n\t  and causing these tests to fail.\n\n2017-11-07  Asim YarKhan <yarkhan@icl.utk.edu>\n\n\t* src/components/lmsensors/configure: lmsensors component: Regenerate\n\t  the configure file for the component\n\n2017-11-02  William Cohen <wcohen@redhat.com>\n\n\t* src/components/lmsensors/Makefile.lmsensors.in,\n\t  src/components/lmsensors/configure.in, src/components/lmsensors\n\t  /linux-lmsensors.c: Make the lmsensors dynamically load the needed\n\t  shared library  When attempting to build the current git repo of\n\t  papi the build of the files in the utils subdirectory failed\n\t  because the lmsensors libraries were not being linked in.  Rather\n\t  than forcing the papi to link in the lmsensor library during the\n\t  build the lmsensors component has been modified to dynamically load\n\t  the needed libraries and enable the lmsensors events when\n\t  available.  This allows machines missing the lmsensor libraries\n\t  installed to still use papi.\n\n2017-11-06  Asim YarKhan <yarkhan@icl.utk.edu>\n\n\t* src/components/cuda/linux-cuda.c: CUDA component: On architectures\n\t  without CUDA Metrics (e.g. Tesla C2050), skip metric registration\n\t  rather than returning errors\n\n2017-11-06  Vince Weaver <vince@deater.net>\n\n\t* src/validation_tests/papi_l2_dca.c,\n\t  src/validation_tests/papi_l2_dcm.c,\n\t  src/validation_tests/papi_l2_dcr.c,\n\t  src/validation_tests/papi_l2_dcw.c: validation_tests: make the\n\t  papi_l2 tests fail with warnings  On Haswell/Broadwell and newer\n\t  these tests fail for unknown reasons.  This isn't new behavior,\n\t  it's just that the tests are new.  It's unlikely we will have time\n\t  to completely sort this out before the upcoming release, so change\n\t  the FAIL to WARN so testers won't be unnecessarily alarmed.\n\n2017-11-05  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/components/perf_event/perf_event.c, src/configure,\n\t  src/configure.in: perf_event: enable rdpmc support by default  It\n\t  can still be disabled at configure time with --enable-perfevent-\n\t  rdpmc=no  This speeds up PAPI_read() by at least a factor of 5x\n\t  (see the ESPT'17 workshop presentation)  It is only enabled on\n\t  Linux 4.13 and newer due to bugs in previous versions.\n\n2017-11-03  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/ctests/sdsc-mpx.c: ctests: sdsc: fix issue where the error\n\t  message is not printed correctly\n\n2017-11-01  Heike Jagode <jagode@icl.utk.edu>\n\n\t* src/components/powercap/linux-powercap.c: Intermediate check-in:\n\t  Fixed a whole bunch of careless file handling (missing closing of\n\t  open files, missing setting of open/close flag, etc). Still more\n\t  rigorous checks needed.\n\nMon Oct 30 17:16:32 2017 -0700  Stephane Eranian <eranian@gmail.com>\n\n\t* src/libpfm4/lib/events/intel_skl_events.h: Update\n\t  libpfm4\\n\\nCurrent with\\n commit\n\t  21405fb3c247a0d16861483daf0696cf4fa0cc43  update SW_PREFETCH event\n\t  for Intel Skylake  Event was renamed SW_PREFETCH_ACCESS, but we\n\t  keep SW_PREFETCH as an alias.  Added PREFETCHW umask.  Enabled\n\t  suport for both Skylake client and server as per official event\n\t  table from 10/27/2017. See download.01.org/perfmon/\n\n2017-10-30  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/validation_tests/Makefile.recipies,\n\t  src/validation_tests/cycles.c,\n\t  src/validation_tests/cycles_validation.c: validation_tests: add\n\t  cycles_validation test  this is the old zero test, which does a\n\t  number of cycles tests  It should be extended to add more.\n\n2017-10-30  Vince Weaver <vince@deater.net>\n\n\t* src/ctests/attach2.c, src/ctests/attach3.c, src/ctests/calibrate.c,\n\t  src/ctests/child_overflow.c, src/ctests/code2name.c,\n\t  src/ctests/earprofile.c, src/ctests/exec_overflow.c,\n\t  src/ctests/fork_overflow.c, src/ctests/hwinfo.c, src/ctests/mendes-\n\t  alt.c, src/ctests/prof_utils.c, src/ctests/prof_utils.h,\n\t  src/ctests/profile.c, src/ctests/remove_events.c,\n\t  src/ctests/shlib.c, src/ctests/system_child_overflow.c,\n\t  src/ctests/system_overflow.c, src/ctests/zero_named.c,\n\t  src/testlib/papi_test.h, src/testlib/test_utils.c: papi: c++11\n\t  fixes: fix various ctests that c++ complains on  mostly just const\n\t  warnings, some K+R function declarations, and possibly an actual\n\t  char/char* bug.\n\t* src/papi.c, src/papi.h: papi: c++11 conversion:\n\t  PAPI_get_component_index()\n\t* src/papi.c, src/papi.h: papi: c++11 conversion: convert\n\t  PAPI_perror()\n\t* src/aix.c, src/components/appio/appio.c,\n\t  src/components/bgpm/CNKunit/linux-CNKunit.c,\n\t  src/components/bgpm/IOunit/linux-IOunit.c,\n\t  src/components/bgpm/L2unit/linux-L2unit.c,\n\t  src/components/bgpm/NWunit/linux-NWunit.c, src/components/emon\n\t  /linux-emon.c, src/components/net/linux-net.c,\n\t  src/components/perf_event/pe_libpfm4_events.c,\n\t  src/components/perf_event/pe_libpfm4_events.h,\n\t  src/components/perf_event/perf_event.c,\n\t  .../perf_event_uncore/perf_event_uncore.c,\n\t  src/components/perfmon_ia64/perfmon-ia64.c, src/freebsd.c, src\n\t  /linux-bgq.c, src/papi.c, src/papi.h, src/papi_internal.c,\n\t  src/papi_internal.h, src/papi_libpfm3_events.c,\n\t  src/papi_libpfm_events.h, src/papi_vector.c, src/papi_vector.h:\n\t  papi: start converting papi.h to be C++11 clean  Most of the issues\n\t  have to do with string to char * conversion.  This first patch\n\t  converts PAPI_event_name_to_code()  The issue was first reported by\n\t  Brian Van Straalen\n\t* src/validation_tests/papi_l2_dca.c: validation_tests/papi_l2_dca:\n\t  update some comments\n\t* src/ctests/zero.c, src/validation_tests/cycles.c: ctests/zero: make\n\t  test pass on recent intel machines  The test was failing due to the\n\t  PAPI_get_real_cycles() validation on recent Intel chips.  This is\n\t  probably something that should be tested in a separate test and not\n\t  in zero which is supposed to be a bare-bones are-things-working\n\t  test.\n\n2017-10-27  Philip Vaccaro <pvaccaro@vols.utk.edu>\n\n\t* src/components/powercap/README: updated powercap README to be more\n\t  concise. includes more details on interacting with energy counters\n\t  and power limits.\n\n2017-10-27  Asim YarKhan <yarkhan@icl.utk.edu>\n\n\t* src/components/cuda/linux-cuda.c, src/components/nvml/linux-nvml.c:\n\t  CUDA/NVML components: Handled segfault which can occur when\n\t  dlclosing libcudart from both components by adding an additional\n\t  flag to dlopen\n\n2017-10-24  Asim YarKhan <yarkhan@icl.utk.edu>\n\n\t* src/components/cuda/linux-cuda.c,\n\t  src/components/cuda/tests/simpleMultiGPU.cu: CUDA component: Clean\n\t  up fulltest by moving some output from stdout to SUBDBG, removed\n\t  some commented out lines\n\t* src/components/nvml/linux-nvml.c: nvml component: To support V100\n\t  (Volta) updated to get nvmlDevice handle ordered by index rather\n\t  than pci busid.\n\n2017-10-23  Asim YarKhan <yarkhan@icl.utk.edu>\n\n\t* src/components/cuda/linux-cuda.c: CUDA component: Minor fix to\n\t  remove some unneeded stdout which shows up during fulltest\n\n2017-10-20  Asim YarKhan <yarkhan@icl.utk.edu>\n\n\t* src/components/cuda/linux-cuda.c,\n\t  src/components/cuda/tests/Makefile,\n\t  src/components/cuda/tests/simpleMultiGPU.cu: CUDA component test\n\t  update: Remove some debug output.  Do not build cupti_only test\n\t  binary.\n\nThu Oct 19 11:23:44 2017 -0700  Stephane Eranian <eranian@gmail.com>\n\n\t* src/libpfm4/examples/showevtinfo.c,\n\t  src/libpfm4/lib/events/intel_skl_events.h: Update\n\t  libpfm4\\n\\nCurrent with\\n commit\n\t  2e98642dd331b15382256caa380834d01b63bef8  Fix Intel Skylake\n\t  EXE_ACTIVITY.1_PORTS_UTIL event  Was missing a umask name.\n\n2017-10-17  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/ctests/version.c: ctests: version, add INCREMENT field  at the\n\t  request of Steve Kaufmann\n\t* src/ctests/Makefile.recipies, src/ctests/version.c: ctests: re-\n\t  enable version test  not sure why it was disabled\n\t* src/ctests/Makefile.recipies: ctests: alphabetize SERIAL tests in\n\t  Makefile.recipes\n\n2017-10-13  Philip Vaccaro <pvaccaro@vols.utk.edu>\n\n\t* src/components/powercap/tests/Makefile,\n\t  src/components/powercap/tests/powercap_limit.c: added simple limit\n\t  test for the powercap component.\n\n2017-10-09  Asim YarKhan <yarkhan@icl.utk.edu>\n\n\t* src/components/nvml/linux-nvml.c: Big Fix NVML component: Fix\n\t  problem with names when there are multiple identical GPUs  If\n\t  multiple identical GPUs were available, the names were not mapped\n\t  correctly.  Fixed event names to be\n\t  \"nvml:::Tesla_K40c:device_0:myevent\" rather than\n\t  \"nvml:::Tesla_K40c_0:myevent\".\n\nFri Sep 29 00:25:09 2017 -0700  Stephane Eranian <eranian@gmail.com>\n\n\t* src/libpfm4/include/perfmon/perf_event.h,\n\t  src/libpfm4/lib/events/intel_skl_events.h,\n\t  src/libpfm4/lib/events/s390x_cpumf_events.h,\n\t  src/libpfm4/lib/pfmlib_s390x_cpumf.c,\n\t  src/libpfm4/perf_examples/Makefile,\n\t  src/libpfm4/perf_examples/branch_smpl.c,\n\t  src/libpfm4/perf_examples/perf_util.c: Update libpfm4\\n\\nCurrent\n\t  with\\n commit d1e7c96df60a00a371fdaa3b635ad4a38cee4c2f  add new\n\t  branch_smpl.c perf_events example  This patch adds a new example to\n\t  demo how to sample and parse the PERF_SAMPLE_BRANCH_STACK record\n\t  format of perf_events. It will dump branches taken from the sampled\n\t  command.\n\n2017-10-05  Asim YarKhan <yarkhan@icl.utk.edu>\n\n\t* src/components/nvml/README, src/components/nvml/linux-nvml.c,\n\t  src/components/nvml/linux-nvml.h,\n\t  src/components/nvml/tests/HelloWorld.cu,\n\t  src/components/nvml/tests/Makefile,\n\t  .../nvml/tests/nvml_power_limiting_test.cu: Update NVML component:\n\t  Support for power limiting using NVML  PAPI has added support for\n\t  power limiting using NVML (on supported devices from the Kepler\n\t  family or later).  The executable needs to have root permissions to\n\t  change the power limits on the device.  We have added new events to\n\t  the NVML component to support power management limits.  The\n\t  nvml:::DEVICE:power_management_limit can be written (as well as\n\t  read), but requires higher permissions (root level).  The limit is\n\t  constrainted between a min and a max value, which can be read.\n\t  When the component is unloaded, the power_management_limit should\n\t  be reset to the initial value.\n\t  nvml:::DEVICE:power_management_limit\n\t  nvml:::DEVICE:power_management_limit_constraint_min\n\t  nvml:::DEVICE:power_management_limit_constraint_max  A new test\n\t  (nvml/tests/nvml_power_limiting_test.cu)/ was written to check if\n\t  the writing functionality works (with the proper hardware and\n\t  permissions).\n\n2017-10-04  Asim YarKhan <yarkhan@icl.utk.edu>\n\n\t* src/components/nvml/linux-nvml.c, src/components/nvml/linux-nvml.h,\n\t  src/components/nvml/tests/HelloWorld.cu: Style consistency and\n\t  refactoring via astyle command.  No changes to the actual code were\n\t  made here.\n\n2017-10-04  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/components/rapl/linux-rapl.c: rapl: add support for some Intel\n\t  Atom models Goldmont / Gemini_Lake / Denverton\n\t* src/components/rapl/linux-rapl.c: rapl: fix skylake SoC measurement\n\t  support\n\t* src/components/rapl/linux-rapl.c: rapl: add support for skylake SoC\n\t  energy measurements\n\t* src/components/rapl/linux-rapl.c: rapl: add Skylake-X / Kabylake\n\t  support\n\t* src/components/rapl/linux-rapl.c: rapl: centralize the \"different\n\t  DRAM units\" code\n\t* src/components/rapl/linux-rapl.c: rapl: merge like processors\n\t* src/components/rapl/linux-rapl.c: rapl: convert chip detection to a\n\t  switch statement\n\t* src/components/rapl/linux-rapl.c: rapl: update the whitespace a bit\n\n2017-09-12  Heike Jagode (jagode@icl.utk.edu) <jagode@saturn.icl.utk.edu>\n\n\t* .../infiniband_umad/linux-infiniband_umad.c, .../infiniband_umad\n\t  /linux-infiniband_umad.h: Fixed papi_vector for infiniband_umad\n\t  component.  The array of function pointers that the component\n\t  defines must use the naming convention papi_vector_t _x_vector\n\t  where x is the name of the component directory.  In this case, the\n\t  name of the component directory is infiniband_umad and not\n\t  infiniband.  This change has not been tested yet due to OFED lib\n\t  issues on our local machines. There may be more changes required in\n\t  order to get the infiniband_umad component to work properly.\n\n2017-09-11  Hanumanth <fhanuman@vols.utk.edu>\n\n\t* man/man1/papi_avail.1, man/man1/papi_native_avail.1,\n\t  src/utils/papi_avail.c, src/utils/papi_native_avail.c: Updating man\n\t  and help pages for papi_avail and papi_native_avail\n\n2017-09-07  Asim YarKhan <yarkhan@icl.utk.edu>\n\n\t* src/components/cuda/tests/nvlink_bandwidth.cu,\n\t  .../cuda/tests/nvlink_bandwidth_cupti_only.cu: Update to CUDA\n\t  component to support NVLink.  The CUDA component has been cleaned\n\t  up and updated to support NVLink. NVLink metrics can not be\n\t  measured properly in KERNEL event collection mode, so the CUPTI\n\t  EventCollectionMode is transparently set to\n\t  CUPTI_EVENT_COLLECTION_MODE_CONTINUOUS when a NVLink metric is\n\t  being measured in an eventset.  For all other events and metrics,\n\t  the CUDA component uses the KERNEL event collection mode.  A bug in\n\t  the earlier version was that repeated calls to add CUDA events were\n\t  failing because some structures were not cleaned up.  This should\n\t  now be fixed.  A new nvlink test was added to the CUDA component\n\t  tests.\n\n2017-08-31  Phil Mucci <phil@minimalmetrics.com>\n\n\t* man/man1/papi_avail.1, man/man1/papi_clockres.1,\n\t  man/man1/papi_command_line.1, man/man1/papi_component_avail.1,\n\t  man/man1/papi_cost.1, man/man1/papi_decode.1,\n\t  man/man1/papi_error_codes.1, man/man1/papi_event_chooser.1,\n\t  man/man1/papi_hybrid_native_avail.1, man/man1/papi_mem_info.1,\n\t  man/man1/papi_multiplex_cost.1, man/man1/papi_native_avail.1,\n\t  man/man1/papi_version.1, man/man1/papi_xml_event_info.1,\n\t  man/man3/PAPI_cleanup_eventset.3, man/man3/PAPI_destroy_eventset.3:\n\t  Updating options for papi_avail/native_avail as well as all\n\t  references to old mailing list\n\n2017-08-31  Asim YarKhan <yarkhan@icl.utk.edu>\n\n\t* src/components/nvml/linux-nvml.c,\n\t  src/components/nvml/tests/HelloWorld.cu,\n\t  src/components/nvml/tests/Makefile: Minor updates to NVML component\n\t  to enable it to compile and run without complaints\n\n2017-08-30  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/validation_tests/papi_br_prc.c,\n\t  src/validation_tests/papi_br_tkn.c: validation: update papi_br_prc\n\t  and papi_br_tkn for amd fam15h  amd fam15h doesn't have a\n\t  conditional branch event so the measures have to be against total.\n\t  for now print warning, maybe we should let it go w/o a warning.\n\t* src/papi_events.csv: papi_events: add PAPI_BR_PRC event to amd\n\t  fam15h\n\t* src/papi_events.csv: papi_events: update PAPI_BR_PRC and\n\t  PAPI_BR_TKN on sandybridge/ivybridge  They were using TOTAL\n\t  branches for the derived branch events rather than CONDITIONAL like\n\t  the other modern x86 processors were using.\n\t* src/validation_tests/papi_br_tkn.c: validation_tests: papi_br_tkn:\n\t  update to only count conditional branches\n\t* src/validation_tests/papi_br_prc.c: validation_tests: papi_br_prc:\n\t  make sure it is comparing conditional branches  was doing total\n\t  branches, which made the test fail on skylake\n\nMon Aug 21 23:55:46 2017 -0700  Stephane Eranian <eranian@gmail.com>\n\n\t* src/libpfm4/lib/pfmlib_intel_x86.c: Update libpfm4\\n\\nCurrent\n\t  with\\n commit a290dead7c1f351f8269a265c0d4a5f38a60ba29  fix usage\n\t  of is_model_event() for Intel X86  This patch fixes a couple of\n\t  problems introduced by commit: 77a5ac9d43b1 add model field to\n\t  intel_x86_entry_t  The code in pfm_intel_x86_get_event_first() was\n\t  incorrect. It was calling is_model_event() before checking if the\n\t  index was within bounds. It should have been the opposite. Same\n\t  issue in pfm_intel_x86_get_next_event(). This could cause SEGFAULT\n\t  as report by Phil Mucci.  The patch also fixes the return value of\n\t  pfm_intel_x86_get_event_first(). It was not calculated correctly.\n\t  Reported-by: Phil Mucci <mucci@icl.utk.edu>\n\n2017-08-20  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/ctests/Makefile.recipies, src/ctests/failed_events.c: ctests:\n\t  add failed_events test  it tries to create invalid events to make\n\t  sure the event parser properly handles invalid events.\n\n2017-08-19  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/components/perf_event_uncore/tests/Makefile,\n\t  .../perf_event_uncore/tests/perf_event_uncore.c,\n\t  .../tests/perf_event_uncore_attach.c: perf_event_uncore: tests:\n\t  update perf_event_uncore to use :cpu=0  This is the more common way\n\t  of specifying uncore events. Rename the old test that uses\n\t  PAPI_set_opt() to perf_event_uncore_attach\n\t* .../tests/perf_event_uncore_cbox.c,\n\t  .../tests/perf_event_uncore_lib.c,\n\t  .../tests/perf_event_uncore_lib.h: perf_event_uncore: tests: update\n\t  uncore events for recent processors\n\t* src/ctests/zero_pthreads.c: ctests: zero_pthreads: remove\n\t  extraneous printf when in quiet mode\n\t* .../tests/perf_event_uncore_lib.c: perf_event_uncore: event list,\n\t  add recent processors  libpfm4 still doesn't support regular\n\t  Haswell, Broadwell, or Skylake machines\n\t* .../perf_event_uncore/tests/perf_event_uncore.c,\n\t  .../tests/perf_event_uncore_cbox.c,\n\t  .../tests/perf_event_uncore_multiple.c: perf_event_uncore: tests:\n\t  print a message indicating the problem on skip  also some\n\t  whitespace cleanups\n\t* src/components/perf_event/tests/event_name_lib.c: perf_event:\n\t  tests: update event_name_lib for recent Intel processors\n\t* src/components/perf_event/tests/event_name_lib.c: perf_event:\n\t  tests: event_name_lib, clean up whitespace\n\t* .../perf_event/tests/perf_event_offcore_response.c: perf_event:\n\t  tests: update perf_event_offcore_response test  print an indicator\n\t  of why we are skipping the test also some gratuitous whitespace\n\t  cleanups\n\t* src/ctests/zero_shmem.c: ctests: zero_shmem: document the code a\n\t  little better\n\t* src/ctests/zero_smp.c: ctests: zero_smp: make it actually do\n\t  something on Linux  Linux can use the pthread code just like AIX\n\t  although we don't validate the results, so this test could be\n\t  another candidate for not being necessary anymore.\n\t* src/ctests/zero_shmem.c: ctests: zero_shmem: minor cleanups  we\n\t  pretty much always skip this test.  Is it needed anymore? What was\n\t  it testing in the first place?  The code it calls (start_pes() )\n\t  doesn't seem to exist anymore\n\t* src/ctests/zero_omp.c, src/ctests/zero_pthreads.c: ctests: zero_omp\n\t  and zero_pthread were skipping due to a typo  when updating the\n\t  code I had left a stray ! before PAPI_query_event()\n\n2017-08-19  Vince Weaver <vince@deater.net>\n\n\t* src/papi_events.csv: papi_events: the skylake fixes broke hsw/bdw\n\t  this skylake-x change is way more trouble than it was worth.\n\n2017-08-19  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/papi_events.csv: papi_events: on skylake the SNP_FWD umask was\n\t  renamed to SNP_HIT_WITH_FWD  This broke presets on skylake,\n\t  skylake-x\n\t* src/components/perf_event/pe_libpfm4_events.c: perf_event: fix\n\t  uninitialized descr issue reported by valgrind  I don't think this\n\t  is the skylake-x bug though\n\n2017-08-18  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/components/perf_event/pe_libpfm4_events.c: perf_event: clean up\n\t  some whitespace in pe_libpfm4_events.c\n\t* src/linux-memory.c: linux-memory: various errors when compiling\n\t  with debug enabled  the new proc memory code had some mistakes in\n\t  the debug messages that only appeared when compiled with --with-\n\t  debug  Reported-by: Steve Kaufmann <sbk@cray.com>\n\n2017-08-17  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/papi_events.csv: papi_events: missed one of the skx event\n\t  locations\n\n2017-08-16  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/papi_events.csv: papi_events: enable Skylake X support\n\nSun Aug 6 00:22:52 2017 -0700  Stephane Eranian <eranian@gmail.com>\n\n\t* src/libpfm4/include/perfmon/pfmlib.h,\n\t  src/libpfm4/lib/events/intel_skl_events.h,\n\t  src/libpfm4/lib/pfmlib_common.c,\n\t  src/libpfm4/lib/pfmlib_intel_skl.c,\n\t  src/libpfm4/lib/pfmlib_intel_snbep_unc.c,\n\t  src/libpfm4/lib/pfmlib_intel_x86.c,\n\t  src/libpfm4/lib/pfmlib_intel_x86_priv.h,\n\t  src/libpfm4/lib/pfmlib_priv.h, src/libpfm4/tests/validate_x86.c:\n\t  Update libpfm4\\n\\nCurrent with\\n commit\n\t  efd16920194999fdf1146e9dab3f7435608a9479  add support for Intel\n\t  Skylake X  This patch adds support for Intel Skylake X core PMU\n\t  events. Based on\n\t  download.01.org/perfmon/SKX/skylakex_core_v25.json.  New PMU is\n\t  called skx.\n\n2017-08-07  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/papi_events.csv: papi_events: add initial AMD fam17h support\n\t  not tested on actual hardware yet\n\t* src/papi_events.csv: papi_events: fix the amd_fam16h PMU name  The\n\t  way libpfm4 reports fam16h was modified a bit from my initial\n\t  patches.  fam16h seems to be working now.\n\nThu Jul 27 23:30:20 2017 -0700  Stephane Eranian <eranian@gmail.com>\n\n\t* src/libpfm4/README, src/libpfm4/docs/Makefile,\n\t  src/libpfm4/docs/man3/libpfm_amd64_fam16h.3,\n\t  src/libpfm4/docs/man3/libpfm_amd64_fam17h.3,\n\t  src/libpfm4/docs/man3/libpfm_intel_bdx_unc_cbo.3,\n\t  src/libpfm4/docs/man3/libpfm_intel_bdx_unc_ha.3,\n\t  src/libpfm4/docs/man3/libpfm_intel_bdx_unc_imc.3,\n\t  src/libpfm4/docs/man3/libpfm_intel_bdx_unc_irp.3,\n\t  src/libpfm4/docs/man3/libpfm_intel_bdx_unc_pcu.3,\n\t  src/libpfm4/docs/man3/libpfm_intel_bdx_unc_qpi.3,\n\t  .../docs/man3/libpfm_intel_bdx_unc_r2pcie.3,\n\t  src/libpfm4/docs/man3/libpfm_intel_bdx_unc_r3qpi.3,\n\t  src/libpfm4/docs/man3/libpfm_intel_bdx_unc_sbo.3,\n\t  src/libpfm4/docs/man3/libpfm_intel_bdx_unc_ubo.3,\n\t  src/libpfm4/examples/showevtinfo.c,\n\t  src/libpfm4/include/perfmon/pfmlib.h, src/libpfm4/lib/Makefile,\n\t  src/libpfm4/lib/events/amd64_events_fam16h.h,\n\t  src/libpfm4/lib/events/amd64_events_fam17h.h,\n\t  src/libpfm4/lib/events/intel_bdx_unc_cbo_events.h,\n\t  src/libpfm4/lib/events/intel_bdx_unc_ha_events.h,\n\t  src/libpfm4/lib/events/intel_bdx_unc_imc_events.h,\n\t  src/libpfm4/lib/events/intel_bdx_unc_irp_events.h,\n\t  src/libpfm4/lib/events/intel_bdx_unc_pcu_events.h,\n\t  src/libpfm4/lib/events/intel_bdx_unc_qpi_events.h,\n\t  .../lib/events/intel_bdx_unc_r2pcie_events.h,\n\t  .../lib/events/intel_bdx_unc_r3qpi_events.h,\n\t  src/libpfm4/lib/events/intel_bdx_unc_sbo_events.h,\n\t  src/libpfm4/lib/events/intel_bdx_unc_ubo_events.h,\n\t  src/libpfm4/lib/pfmlib_amd64.c,\n\t  src/libpfm4/lib/pfmlib_amd64_fam16h.c,\n\t  src/libpfm4/lib/pfmlib_amd64_fam17h.c,\n\t  src/libpfm4/lib/pfmlib_amd64_priv.h,\n\t  src/libpfm4/lib/pfmlib_common.c,\n\t  src/libpfm4/lib/pfmlib_intel_bdx_unc_cbo.c,\n\t  src/libpfm4/lib/pfmlib_intel_bdx_unc_ha.c,\n\t  src/libpfm4/lib/pfmlib_intel_bdx_unc_imc.c,\n\t  src/libpfm4/lib/pfmlib_intel_bdx_unc_irp.c,\n\t  src/libpfm4/lib/pfmlib_intel_bdx_unc_pcu.c,\n\t  src/libpfm4/lib/pfmlib_intel_bdx_unc_qpi.c,\n\t  src/libpfm4/lib/pfmlib_intel_bdx_unc_r2pcie.c,\n\t  src/libpfm4/lib/pfmlib_intel_bdx_unc_r3qpi.c,\n\t  src/libpfm4/lib/pfmlib_intel_bdx_unc_sbo.c,\n\t  src/libpfm4/lib/pfmlib_intel_bdx_unc_ubo.c,\n\t  src/libpfm4/lib/pfmlib_intel_snbep_unc.c,\n\t  src/libpfm4/lib/pfmlib_intel_snbep_unc_priv.h,\n\t  src/libpfm4/lib/pfmlib_priv.h,\n\t  src/libpfm4/perf_examples/self_count.c,\n\t  src/libpfm4/tests/validate_x86.c: Update libpfm4  Current with\n\t  commit 72474c59d88512e49d9be7c4baa4355e8d8ad10a  fix typo in AMd\n\t  Fam17h man page  PMU name was mistyped.\n\n2017-08-04  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/validation_tests/papi_l1_dcm.c,\n\t  src/validation_tests/papi_l2_dcm.c: validation_tests: for the DCM\n\t  tests up the allowed error to 5%  We don't want to fail too easily,\n\t  and 5% seems reasonable. This lets the test pass on ARM64\n\t  Dragonboard 401c\n\t* src/linux-memory.c: linux-memory: add fallback generic Linux /sys\n\t  cache size detection  This will allow getting cache sizes on\n\t  architectures we don't have custom code for.  Currently this mostly\n\t  means ARM64.\n\t* src/validation_tests/papi_l1_dcm.c,\n\t  src/validation_tests/papi_l2_dcm.c: validation_tests: don't crash\n\t  if cachesize reported as zero\n\t* src/validation_tests/branches_testcode.c: branches_testcode: add\n\t  arm64 support\n\n2017-07-27  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/papi_events.csv, src/validation_tests/papi_l2_dca.c:\n\t  validation_tests: trying to find out why PAPI_L2_DCA fails on\n\t  Haswell  it's a mystery still.  One alternative is to switch the\n\t  event to be the same as PAPI_L1_DCM but that seems like it would be\n\t  cheating.\n\t* src/validation_tests/papi_l2_dcw.c: validation_tests: papi_l2_dcw:\n\t  shorten a warning message\n\t* src/papi_events.csv: papi_events: note that libpfm4 Kaby Lake\n\t  support is treated as part of Skylake\n\t* src/validation_tests/Makefile.recipies,\n\t  src/validation_tests/papi_l2_dcw.c: validation_tests: add\n\t  PAPI_L2_DCW test\n\t* src/validation_tests/Makefile.recipies,\n\t  src/validation_tests/papi_l2_dcr.c: validation_tests: add\n\t  PAPI_L2_DCR test\n\t* src/validation_tests/papi_l2_dcm.c: validation_tests: PAPI_L2_DCM\n\t  figured out a test that made sense\n\t* src/validation_tests/Makefile.recipies,\n\t  src/validation_tests/papi_l1_dcm.c: validation_tests: add\n\t  PAPI_L1_DCM test\n\t* src/validation_tests/Makefile.recipies,\n\t  src/validation_tests/cache_testcode.c,\n\t  src/validation_tests/papi_l2_dcm.c,\n\t  src/validation_tests/testcode.h: validation_tests: first attempt at\n\t  papi_l2_dcm test  disabled for now, as it's really hard to make a\n\t  workable cache miss test on modern hardware.\n\n2017-07-26  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/ctests/Makefile, src/ctests/Makefile.recipies,\n\t  src/ctests/child_overflow.c, src/ctests/exec_overflow.c,\n\t  src/validation_tests/Makefile.recipies,\n\t  src/validation_tests/busy_work.c, src/validation_tests/testcode.h:\n\t  ctests: clean up the exec/child overflow tests  The exec_overflow\n\t  test segfaults when using rdpmc  This is a bug in Linux.  I'm\n\t  working on getting it fixed.\n\n2017-07-21  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/validation_tests/Makefile.recipies,\n\t  src/validation_tests/cache_helper.c,\n\t  src/validation_tests/cache_helper.h,\n\t  src/validation_tests/cache_testcode.c,\n\t  src/validation_tests/papi_l1_dca.c,\n\t  src/validation_tests/papi_l2_dca.c,\n\t  src/validation_tests/testcode.h: validation_tests: add PAPI_L2_DCA\n\t  test  also adds some generic cache testing infrastructure\n\t* src/validation_tests/papi_l1_dca.c: validation_tests: PAPI_L1_DCA\n\t  fixes  had to find a machine that actually supported the event.  On\n\t  AMD Fam15h the write count is 3x expected?  Need to investigate\n\t  further.\n\t* src/validation_tests/papi_br_prc.c: validation_tests: papi_br_prc,\n\t  properly skip if event not found\n\t* src/validation_tests/Makefile.recipies,\n\t  src/validation_tests/papi_l1_dca.c: validation_tests: add\n\t  PAPI_L1_DCA test\n\n2017-07-20  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/validation_tests/Makefile.recipies,\n\t  src/validation_tests/papi_br_msp.c,\n\t  src/validation_tests/papi_br_prc.c: validation_tests: add\n\t  PAPI_BR_PRC test\n\t* src/validation_tests/Makefile.recipies,\n\t  src/validation_tests/papi_br_tkn.c: validation_tests: add\n\t  PAPI_BR_TKN test\n\t* src/validation_tests/Makefile.recipies,\n\t  src/validation_tests/papi_br_ntk.c: validation_tests: add\n\t  PAPI_BR_NTK test\n\n2017-07-07  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/papi_events.csv: papi_events: move haswell, skylake, and\n\t  broadwell to traditional PAPI_REF_CYC  there's a slight chance this\n\t  might break things for people, if so we can revert it.\n\t* src/linux-timer.c: linux-timer: fix build warning on non-power\n\t  build\n\t* src/ctests/flops.c, src/validation_tests/flops_testcode.c,\n\t  src/validation_tests/papi_dp_ops.c,\n\t  src/validation_tests/papi_fp_ops.c,\n\t  src/validation_tests/papi_sp_ops.c: validation: make the flops\n\t  tests handle that POWER has fused multiply-add  PAPI_DP_OPS and\n\t  PAPI_SP_OPS still fail, need to audit what the event is doing\n\t* src/papi_events.csv: POWER8: add a few branch preset events  they\n\t  pass the validation tests, not sure why they weren't enabled\n\t  originally\n\t* src/validation_tests/branches_testcode.c: validation: add POWER\n\t  branches testcode  not sure I got the clobbers right\n\t* src/components/perf_event/perf_helpers.h,\n\t  src/validation_tests/papi_tot_ins.c: POWER: fix some compiler\n\t  warnings\n\n2016-10-18  Phil Mucci <phil@minimalmetrics.com>\n\n\t* src/linux-timer.c: Ensure stdint gets included for all Linuxen.\n\t* src/linux-timer.c: Some Linuxen need stdint to get the uint64_t\n\t  type.\n\n2016-10-14  Phil Mucci <phil@minimalmetrics.com>\n\n\t* src/linux-lock.h: Restructured unlock code to avoid warnings.\n\t  Tested against 80 threads on Power8\n\n2016-10-12  Phil Mucci <phil@minimalmetrics.com>\n\n\t* src/linux-timer.c: PPC64/PPC fast timer fixup.\n\n2017-07-07  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/linux-timer.c: linux-timer: allow using fast timer for\n\t  get_real_cycles() on POWER\n\n2016-07-12  Phil Mucci <phil@minimalmetrics.com>\n\n\t* src/linux-timer.c, src/linux-timer.h: First pass at good rdtsc for\n\t  Power7/8\n\n2017-07-03  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/ctests/flops.c, src/ctests/hl_rates.c,\n\t  src/validation_tests/Makefile.recipies,\n\t  src/validation_tests/flops.c,\n\t  src/validation_tests/flops_testcode.c,\n\t  src/validation_tests/flops_validation.c,\n\t  src/validation_tests/papi_dp_ops.c,\n\t  src/validation_tests/papi_fp_ops.c,\n\t  src/validation_tests/papi_sp_ops.c,\n\t  src/validation_tests/testcode.h: validation_tests: add tests for\n\t  PAPI_SP_OPS and PAPI_DP_OPS  extend the flops_testcode as well, to\n\t  have both float and double versions.\n\t* src/validation_tests/papi_ref_cyc.c: validation_tests:\n\t  papi_ref_cyc: update test to work on older systems  it's actually\n\t  the newer (haswell/broadwell/skylake) that are using a different\n\t  event than the older systems.  Make the test check for the old\n\t  behavior.\n\n2017-07-02  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/ctests/Makefile.recipies, src/ctests/cycle_ratio.c,\n\t  src/validation_tests/Makefile.recipies,\n\t  src/validation_tests/flops_testcode.c,\n\t  src/validation_tests/papi_ref_cyc.c,\n\t  src/validation_tests/testcode.h: validation_tests: move cycle_ratio\n\t  test to be papi_ref_cyc test\n\t* src/ctests/cycle_ratio.c: ctests: rewrite cycle_ratio test  on\n\t  Intel platforms PAPI_REF_CYC is a fixed 100MHz cycle count  the\n\t  test was making the assumption that PAPI_REF_CYC was equal to the\n\t  max design freq (not turboboost) and thus as far as I can tell it\n\t  never would return the right answer.  This test should probably be\n\t  moved to validation_tests.\n\n2017-07-01  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/ctests/Makefile.recipies, src/ctests/branches.c, src/ctests\n\t  /sdsc-mpx.c, src/ctests/sdsc2.c: ctests: migrate all other users of\n\t  dummy3() workload\n\t* src/ctests/Makefile.recipies, src/ctests/sdsc4-mpx.c,\n\t  src/validation_tests/flops_testcode.c,\n\t  src/validation_tests/testcode.h: ctests: move the \"dummy3\" workload\n\t  to the common workload library\n\t* src/ctests/sdsc4-mpx.c: ctests: sdsc4-mpx: fix failing on recent\n\t  Intel machines  the multiplexing of an event with small results\n\t  (PAPI_SR_INS in this case) has high variance, so don't use it for\n\t  validation.  There was code trying to do this but it wasn't\n\t  working.\n\n2017-06-30  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/ctests/first.c, src/ctests/matrix-hl.c, src/ctests/zero_omp.c,\n\t  src/ctests/zero_pthreads.c: ctests: catch lack of CPU component\n\t  earlier  gets rid of extreaneous SKIPPED in the output of\n\t  run_tests.sh\n\t* src/components/cuda/tests/HelloWorld.cu,\n\t  src/components/cuda/tests/Makefile: tests:cuda: make the HelloWorld\n\t  test more like a standard PAPI test\n\t* src/validation_tests/Makefile.recipies: validation_tests: fix\n\t  linking against a CUDA enabled PAPI  Fix suggested by Steve\n\t  Kaufmann <sbk@cray.com>\n\t* src/testlib/papi_test.h, src/testlib/test_utils.c: testlib: make it\n\t  so it can compile with c++  this lets us link against it from the\n\t  CUDA tests\n\t* src/components/cuda/sampling/gpu_activity.c: tests: cuda: fix\n\t  sampling/gpu_activity to compile without warnings\n\t* src/Makefile.inc: tests: make the component tests build command be\n\t  the same as ctests/ftests\n\t* src/ctests/calibrate.c: ctests: calibrate: turn off printf if\n\t  TEST_QUIET  missed this one when testing because test machine\n\t  skipped it due to lack of floating point events\n\n2017-06-29  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* .../tests/perf_event_amd_northbridge.c,\n\t  src/ctests/Makefile.recipies, src/ctests/cycle_ratio.c,\n\t  src/ctests/derived.c, src/ctests/multiplex1_pthreads.c,\n\t  src/ctests/multiplex3_pthreads.c, src/ctests/overflow.c,\n\t  src/ctests/overflow_allcounters.c, src/ctests/overflow_index.c,\n\t  src/ctests/overflow_pthreads.c, src/ctests/overflow_twoevents.c,\n\t  src/ctests/prof_utils.c, src/ctests/prof_utils.h,\n\t  src/ctests/profile.c, src/ctests/profile_twoevents.c,\n\t  src/ctests/realtime.c, src/ctests/reset.c,\n\t  src/ctests/reset_multiplex.c, src/ctests/sdsc-mpx.c,\n\t  src/ctests/sdsc.c, src/ctests/sdsc4-mpx.c, src/ctests/sdsc4.c,\n\t  src/ctests/shlib.c, src/ctests/tenth.c, src/ctests/thrspecific.c,\n\t  src/testlib/papi_test.h: testlib: remove the hack where all\n\t  printf's are #defined to something else  Explicitly check\n\t  everywhere for TESTS_QUIET or equivelent, rather than using c-pre-\n\t  processor macros to redefine printf\n\t* src/papi.c, src/testlib/test_utils.c: tests: set the ctest debug\n\t  mode to VERBOSE by default for tests  the TESTS_QUIET mode was\n\t  turning *off* verbose debugging, which meant that PAPIERROR() calls\n\t  wouldn't show up during a ./run_tests.sh\n\t* src/components/perf_event/perf_event.c: perf_event: properly\n\t  initialize the mmap_addr structure  It wasn't always being set to\n\t  NULL, and so on some tests the code would try to munmap() it even\n\t  though it wasn't mapped.\n\t* src/testlib/test_utils.c: tests: enable color in test status\n\t  messages  this has been an optional feature for a long time, if you\n\t  enabled the environment variable TESTS_COLOR=y  this change makes\n\t  it default to being on (you can disable with export TESTS_COLOR=n\n\t  also it should automatically detect if you are piping to a file and\n\t  disable colors in the case too\n\t* src/validation_tests/Makefile,\n\t  src/validation_tests/Makefile.recipies: validation_tests: always\n\t  include -lrt on the tests  Should be harmless, and I don't always\n\t  test on an old enough machine to trigger the problem.\n\t* src/ctests/forkexec.c, src/ctests/forkexec2.c,\n\t  src/ctests/forkexec3.c, src/ctests/forkexec4.c,\n\t  src/ctests/multiplex3_pthreads.c,\n\t  src/ctests/system_child_overflow.c: ctests: make the fork/exec\n\t  tests only print \"PASSED\" once  this makes the run_test.sh input\n\t  look a lot nicer\n\t* src/run_tests.sh, src/testlib/test_utils.c: tests: make the output\n\t  from run_tests.sh more compact\n\n2017-06-28  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* .../perf_event/tests/perf_event_system_wide.c: perf_event: tests,\n\t  make perf_event_system_wide use INS rather than CYC  cycles varied\n\t  too much, making the validation fail\n\t* src/validation_tests/Makefile.recipies,\n\t  src/validation_tests/papi_br_cn.c,\n\t  src/validation_tests/papi_br_ucn.c: validation_tests: add tests for\n\t  PAPI_BR_CN and PAPI_BR_UCN\n\t* src/validation_tests/flops.c: validation_tests: flops: wasn't\n\t  falling back properly if no FLOPS event\n\t* src/utils/Makefile, src/validation_tests/Makefile.recipies: tests:\n\t  clean up the Makefiles\n\t* src/utils/print_header.c: utils: print_header: print the operating\n\t  system version in the header\n\t* .../tests/perf_event_amd_northbridge.c: perf_event_uncore: the\n\t  perf_event_amd_northbridge test wasn't working  it maybe never\n\t  worked at all?  It was hardcoded to thinking it was running on a\n\t  3.9 kernel always.\n\t* src/ctests/Makefile, src/ctests/Makefile.recipies,\n\t  src/ctests/zero.c: ctests: zero: complete transition from FLOPS to\n\t  INS as metric  this will make it more likely to be runnable on\n\t  modern machines.\n\t* src/ctests/vector.c, src/validation_tests/vector_testcode.c:\n\t  validation_tests: move the unused vector.c code  maybe we should\n\t  remove it.  It was never built as far as I can tell.\n\t* src/validation_tests/Makefile.recipies,\n\t  src/validation_tests/flops.c: validation_tests: add a generic flops\n\t  test based on hl_rates  we do a lot of testing of the high-level\n\t  interface but not as much of the regular PAPI interface.\n\t* src/ctests/Makefile.recipies, src/ctests/hl_rates.c,\n\t  src/validation_tests/flops_testcode.c,\n\t  src/validation_tests/testcode.h: ctests: hl_rates: clean up and fix\n\t  extraneous error message  the error message was due to the way\n\t  TESTS_QUIET is passed as a command line argument.  also made it use\n\t  the same matrix-multiply code that the flops test uses.  also added\n\t  some validation to the results.\n\t* src/ctests/all_events.c: ctests: all_events: issue warning if\n\t  preset cannot be created  specifically this came up on an AMD\n\t  fam15h system where the PAPI_L1_ICH event cannot be created due to\n\t  Linux stealing a counter for the NMI watchdog\n\t* src/validation_tests/papi_hw_int.c: validation_tests: papi_hw_int\n\t  explicitly mark large constant as ULL  compiler was warning on\n\t  32-bit machine\n\t* src/validation_tests/papi_ld_ins.c,\n\t  src/validation_tests/papi_sr_ins.c,\n\t  src/validation_tests/papi_tot_cyc.c: validation_tests:  a few tests\n\t  had the !quiet check inverted\n\t* src/validation_tests/papi_hw_int.c: validation_tests: fix\n\t  papi_hw_int looping forever  somehow the loop exit line got lost\n\t* src/validation_tests/Makefile.recipies,\n\t  src/validation_tests/matrix_multiply.c,\n\t  src/validation_tests/matrix_multiply.h,\n\t  src/validation_tests/papi_ld_ins.c,\n\t  src/validation_tests/papi_sr_ins.c: validation_tests: add\n\t  PAPI_SR_INS test\n\t* src/validation_tests/Makefile.recipies,\n\t  src/validation_tests/matrix_multiply.c,\n\t  src/validation_tests/matrix_multiply.h,\n\t  src/validation_tests/papi_hw_int.c,\n\t  src/validation_tests/papi_ld_ins.c: validation_tests: add\n\t  PAPI_LD_INS test\n\t* src/run_tests.sh, src/validation_tests/Makefile.recipies,\n\t  src/validation_tests/papi_hw_int.c: validation_tests: add\n\t  PAPI_HW_INT test\n\n2017-06-27  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/run_tests_exclude.txt: run_tests_exclude: add attach_target\n\t  not really a test so we shouldn't run it\n\t* src/ctests/byte_profile.c, src/ctests/earprofile.c,\n\t  src/ctests/prof_utils.c, src/ctests/prof_utils.h:\n\t  ctests/prof_utils: remove prof_init() helper  It didn't do much\n\t  more than a papi_init, probably better to have each file do that in\n\t  the open.\n\t* src/ctests/inherit.c, src/ctests/ipc.c, src/ctests/johnmay2.c,\n\t  src/ctests/krentel_pthreads.c, src/ctests/kufrin.c, src/ctests/low-\n\t  level.c, src/ctests/mendes-alt.c, src/ctests/multiplex1.c,\n\t  src/ctests/multiplex1_pthreads.c, src/ctests/multiplex2.c,\n\t  src/ctests/multiplex3_pthreads.c, src/ctests/overflow.c,\n\t  src/ctests/overflow2.c, src/ctests/overflow3_pthreads.c,\n\t  src/ctests/overflow_allcounters.c, src/ctests/overflow_index.c,\n\t  src/ctests/overflow_one_and_read.c,\n\t  src/ctests/overflow_single_event.c,\n\t  src/ctests/overflow_twoevents.c, src/ctests/prof_utils.c,\n\t  src/ctests/profile.c, src/ctests/profile_pthreads.c,\n\t  src/ctests/profile_twoevents.c, src/ctests/remove_events.c,\n\t  src/ctests/sprofile.c, src/ctests/zero.c, src/ctests/zero_flip.c,\n\t  src/ctests/zero_named.c, src/testlib/test_utils.c: ctests: skip\n\t  rather than fail if no events available\n\n2017-06-26  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/ctests/first.c, src/ctests/mpifirst.c,\n\t  src/ctests/multiattach.c, src/ctests/multiattach2.c,\n\t  src/testlib/test_utils.c: testlib: fix add_two_events()  was not\n\t  setting some values, causing many tests to fail\n\t* src/ctests/attach2.c, src/ctests/system_overflow.c: ctests:\n\t  compiler warning caught two lack-of-braces mistakes\n\t* src/ctests/byte_profile.c, src/ctests/code2name.c,\n\t  src/ctests/describe.c, src/testlib/test_utils.c: tests: more\n\t  changes to skip instead of fail if no events available\n\t* src/ctests/Makefile.recipies, src/ctests/child_overflow.c,\n\t  src/ctests/exec_overflow.c, src/ctests/fork_exec_overflow.c,\n\t  src/ctests/fork_overflow.c, src/ctests/system_child_overflow.c,\n\t  src/ctests/system_overflow.c: ctests: break up the\n\t  for_exec_overflow test  it was really four benchmarks with some\n\t  ifdefs  the proper way to do that would be to have a common C file\n\t  and link against it for the shared routines, rather than using the\n\t  pre-processor\n\t* src/ctests/attach2.c, src/ctests/attach3.c,\n\t  src/ctests/attach_cpu.c: ctests: have attach tests cleanly skip if\n\t  no events available\n\t* src/testlib/test_utils.c: testlib: update add_two_events to skip()\n\t  if not events found\n\t* src/ctests/mendes-alt.c, src/ctests/multiplex2.c,\n\t  src/ctests/multiplex3_pthreads.c, src/ctests/sdsc.c,\n\t  src/ctests/sdsc2.c, src/ctests/sdsc4.c, src/testlib/papi_test.h,\n\t  src/testlib/test_utils.c: testutils: remove init_multiplex() test\n\t  helper  the only benefit it had over calling PAPI_multiplex_init()\n\t  was a domain workaround for perfctr+power6 systems.  Ideally not\n\t  many of those systems are around anymore, an in any case a proper\n\t  fix would have the perfctr component handle that, not the testing\n\t  library.\n\t* .../perf_event/tests/perf_event_system_wide.c,\n\t  .../perf_event/tests/perf_event_user_kernel.c, src/ctests/api.c,\n\t  src/ctests/byte_profile.c, src/ctests/high-level.c,\n\t  src/ctests/hl_rates.c, src/validation_tests/papi_br_ins.c,\n\t  src/validation_tests/papi_br_msp.c,\n\t  src/validation_tests/papi_tot_cyc.c,\n\t  src/validation_tests/papi_tot_ins.c: tests: try to \"skip\" rather\n\t  than \"fail\" if no events available\n\t* src/ctests/derived.c: ctests: derived: fix warning found on older\n\t  gcc\n\t* src/ctests/high-level2.c: ctests: clean up high-level2 test  skip\n\t  on machine without flops/flips event\n\t* src/components/Makefile_comp_tests.target.in: components test: fix\n\t  another build issue  be sure to use local copy of papi.h\n\t* src/components/Makefile_comp_tests.target.in: component tests: fix\n\t  build issue  was trying to use the system version of libpapi.a\n\t  instead of local version\n\t* src/components/appio/tests/Makefile,\n\t  src/components/appio/tests/appio_list_events.c,\n\t  src/components/appio/tests/appio_values_by_code.c,\n\t  src/components/coretemp/tests/Makefile,\n\t  src/components/example/tests/Makefile,\n\t  src/components/host_micpower/tests/Makefile,\n\t  src/components/infiniband/tests/Makefile,\n\t  .../infiniband/tests/infiniband_values_by_code.c,\n\t  src/components/infiniband_umad/tests/Makefile,\n\t  .../tests/infiniband_umad_values_by_code.c,\n\t  src/components/lustre/tests/Makefile,\n\t  src/components/micpower/tests/Makefile,\n\t  src/components/mx/tests/Makefile,\n\t  src/components/net/tests/Makefile,\n\t  src/components/perf_event/tests/Makefile,\n\t  src/components/perf_event_uncore/tests/Makefile,\n\t  src/components/powercap/tests/Makefile,\n\t  src/components/rapl/tests/Makefile,\n\t  src/components/stealtime/tests/Makefile: components: update\n\t  component test Makefiles to include Makefile_comp_test.target\n\t* src/components/Makefile_comp_tests.target.in: components: update\n\t  Makefile_comp_test.target.in  should now be usable by the\n\t  components without many Makefile changes\n\t* src/components/perf_event/tests/Makefile,\n\t  src/components/perf_event/tests/nmi_watchdog.c,\n\t  src/ctests/Makefile.recipies, src/ctests/nmi_watchdog.c: ctests:\n\t  nmi_watchdog is a perf_event specific test, move it there\n\t* src/components/Makefile_comp_tests.target.in,\n\t  src/components/README, src/components/perf_event/tests/Makefile:\n\t  components: update the autoconfigure to generate more useful\n\t  Makefile.target.in  although I don't think most components are\n\t  using it at all\n\n2017-06-26  Asim YarKhan <yarkhan@icl.utk.edu>\n\n\t* src/components/cuda/Makefile.cuda.in, src/components/cuda/README,\n\t  src/components/cuda/Rules.cuda, src/components/cuda/configure,\n\t  src/components/cuda/configure.in, src/components/cuda/linux-cuda.c,\n\t  src/components/cuda/sampling/Makefile,\n\t  src/components/cuda/tests/HelloWorld.cu,\n\t  src/components/cuda/tests/Makefile,\n\t  src/components/cuda/tests/simpleMultiGPU.cu: CUDA component update:\n\t  Support for CUPTI metrics (early release)  This commit adds support\n\t  for CUPTI metrics, which are higher level measures that may be\n\t  decompsed into multiple lower level CUPTI events.  Known problems\n\t  and limitations in early release of metric support * Only sets of\n\t  metrics and events that can be gathered in a single pass are\n\t  supported.  Transparent multi-pass support is expected * All\n\t  metrics are returned as long long integers, which means that CUPTI\n\t  double precision values will be truncated, possibly severely. * The\n\t  NVLink metrics have been disabled for this alpha release.\n\n2017-06-23  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/validation_tests/papi_fp_ops.c: validation: papi_fp_ops, skip\n\t  (not fail) if PAPI_FP_OPS unavailable\n\t* src/ctests/Makefile, src/ctests/Makefile.recipies,\n\t  src/ctests/Makefile.target.in, src/ctests/flops.c: ctests: flops,\n\t  update to use some of the validate_tests infrastructure\n\t* src/validation_tests/Makefile.recipies,\n\t  src/validation_tests/flops_testcode.c,\n\t  src/validation_tests/papi_fp_ops.c,\n\t  src/validation_tests/testcode.h: validation_tests: add papi_fp_ops\n\t  test  tested on an AMD fam15h machine\n\t* src/components/powercap/tests/powercap_basic.c: powercap: fix\n\t  compiler warnings in the powercap_basic test\n\t* src/ctests/flops.c: ctests: update flops test\n\t* src/ctests/api.c: ctests: update api test  only seems to test the\n\t  high-level API\n\t* src/ctests/all_native_events.c: ctests: update all_native_events\n\t  removed some ancient warnings about uncore/offcore events. Should\n\t  not be a problem on libpfm4/perf_event\n\t* src/ctests/all_events.c: ctests: clean up all_events test\n\t* src/components/appio/tests/appio_list_events.c,\n\t  src/components/appio/tests/appio_test_blocking.c,\n\t  .../appio/tests/appio_test_fread_fwrite.c,\n\t  src/components/appio/tests/appio_test_pthreads.c,\n\t  src/components/appio/tests/appio_test_read_write.c,\n\t  src/components/appio/tests/appio_test_recv.c,\n\t  src/components/appio/tests/appio_test_seek.c,\n\t  src/components/appio/tests/appio_test_select.c,\n\t  src/components/appio/tests/appio_test_socket.c,\n\t  src/components/appio/tests/appio_values_by_code.c,\n\t  src/components/appio/tests/appio_values_by_name.c,\n\t  src/components/coretemp/tests/coretemp_basic.c,\n\t  src/components/coretemp/tests/coretemp_pretty.c,\n\t  src/components/example/tests/example_basic.c,\n\t  .../example/tests/example_multiple_components.c,\n\t  .../host_micpower/tests/host_micpower_basic.c,\n\t  .../infiniband/tests/infiniband_list_events.c,\n\t  .../infiniband/tests/infiniband_values_by_code.c,\n\t  .../tests/infiniband_umad_list_events.c,\n\t  src/components/libmsr/tests/libmsr_basic.c,\n\t  src/components/lustre/tests/lustre_basic.c,\n\t  src/components/micpower/tests/micpower_basic.c,\n\t  src/components/mx/tests/mx_basic.c,\n\t  src/components/mx/tests/mx_elapsed.c,\n\t  src/components/net/tests/net_list_events.c,\n\t  src/components/net/tests/net_values_by_code.c,\n\t  src/components/net/tests/net_values_by_name.c,\n\t  .../perf_event/tests/perf_event_offcore_response.c,\n\t  .../perf_event/tests/perf_event_system_wide.c,\n\t  .../perf_event/tests/perf_event_user_kernel.c,\n\t  .../tests/perf_event_amd_northbridge.c,\n\t  .../perf_event_uncore/tests/perf_event_uncore.c,\n\t  .../tests/perf_event_uncore_cbox.c,\n\t  .../tests/perf_event_uncore_multiple.c,\n\t  src/components/powercap/tests/powercap_basic.c,\n\t  src/components/rapl/tests/rapl_basic.c,\n\t  src/components/rapl/tests/rapl_overflow.c,\n\t  src/components/stealtime/tests/stealtime_basic.c,\n\t  src/components/vmware/tests/vmware_basic.c,\n\t  src/ctests/all_events.c, src/ctests/all_native_events.c,\n\t  src/ctests/api.c, src/ctests/attach2.c, src/ctests/attach3.c,\n\t  src/ctests/attach_cpu.c, src/ctests/branches.c,\n\t  src/ctests/byte_profile.c, src/ctests/calibrate.c,\n\t  src/ctests/case1.c, src/ctests/case2.c,\n\t  src/ctests/clockres_pthreads.c, src/ctests/cmpinfo.c,\n\t  src/ctests/code2name.c, src/ctests/cycle_ratio.c,\n\t  src/ctests/data_range.c, src/ctests/derived.c,\n\t  src/ctests/describe.c, src/ctests/disable_component.c,\n\t  src/ctests/dmem_info.c, src/ctests/earprofile.c,\n\t  src/ctests/eventname.c, src/ctests/exec.c, src/ctests/exec2.c,\n\t  src/ctests/exeinfo.c, src/ctests/first.c, src/ctests/flops.c,\n\t  src/ctests/fork.c, src/ctests/fork2.c,\n\t  src/ctests/fork_exec_overflow.c, src/ctests/forkexec.c,\n\t  src/ctests/forkexec2.c, src/ctests/forkexec3.c,\n\t  src/ctests/forkexec4.c, src/ctests/get_event_component.c,\n\t  src/ctests/high-level.c, src/ctests/high-level2.c,\n\t  src/ctests/hl_rates.c, src/ctests/hwinfo.c, src/ctests/inherit.c,\n\t  src/ctests/ipc.c, src/ctests/johnmay2.c,\n\t  src/ctests/krentel_pthreads.c, src/ctests/kufrin.c,\n\t  src/ctests/locks_pthreads.c, src/ctests/low-level.c, src/ctests\n\t  /matrix-hl.c, src/ctests/max_multiplex.c, src/ctests/memory.c,\n\t  src/ctests/mendes-alt.c, src/ctests/multiattach.c,\n\t  src/ctests/multiattach2.c, src/ctests/multiplex1.c,\n\t  src/ctests/multiplex1_pthreads.c, src/ctests/multiplex2.c,\n\t  src/ctests/multiplex3_pthreads.c, src/ctests/nmi_watchdog.c,\n\t  src/ctests/omptough.c, src/ctests/overflow.c,\n\t  src/ctests/overflow2.c, src/ctests/overflow3_pthreads.c,\n\t  src/ctests/overflow_allcounters.c,\n\t  src/ctests/overflow_force_software.c, src/ctests/overflow_index.c,\n\t  src/ctests/overflow_one_and_read.c, src/ctests/overflow_pthreads.c,\n\t  src/ctests/overflow_single_event.c,\n\t  src/ctests/overflow_twoevents.c, src/ctests/p4_lst_ins.c,\n\t  src/ctests/profile.c, src/ctests/profile_pthreads.c,\n\t  src/ctests/profile_twoevents.c, src/ctests/pthrtough.c,\n\t  src/ctests/pthrtough2.c, src/ctests/realtime.c,\n\t  src/ctests/remove_events.c, src/ctests/reset.c,\n\t  src/ctests/reset_multiplex.c, src/ctests/sdsc.c,\n\t  src/ctests/sdsc2.c, src/ctests/sdsc4.c, src/ctests/second.c,\n\t  src/ctests/shlib.c, src/ctests/sprofile.c, src/ctests/tenth.c,\n\t  src/ctests/thrspecific.c, src/ctests/timer_overflow.c,\n\t  src/ctests/virttime.c, src/ctests/zero.c, src/ctests/zero_attach.c,\n\t  src/ctests/zero_flip.c, src/ctests/zero_fork.c,\n\t  src/ctests/zero_named.c, src/ctests/zero_omp.c,\n\t  src/ctests/zero_pthreads.c, src/ctests/zero_smp.c,\n\t  src/testlib/papi_test.h, src/testlib/test_utils.c,\n\t  src/validation_tests/papi_br_ins.c,\n\t  src/validation_tests/papi_br_msp.c,\n\t  src/validation_tests/papi_tot_cyc.c,\n\t  src/validation_tests/papi_tot_ins.c: testlib: remove the \"free\n\t  variables\" option from test_pass()  It was only used by a small\n\t  handfull of tests, and wasn't really strictly necessary anyway.\n\t  test_pass() should pass the test and that's all.\n\t* src/ctests/zero.c: ctests: zero: start cleaning up this test\n\t* src/validation_tests/Makefile.recipies: validation_tests:\n\t  clock_gettime() requires -lrt on older versions of glibc\n\n2017-06-22  Will Schmidt <will_schmidt@vnet.ibm.com>\n\n\t* src/linux-memory.c, src/papi_events.csv: PAPI power9 event list\n\t  presets  Here is an initial set of events and changes to help\n\t  support Power9.  This is based on similar changes that were made\n\t  for power8 when initial support was added there.  I've updated the\n\t  event names to match what we expect to have in power9, and have\n\t  done compile/build/ sniff tests.\n\n2017-06-22  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/ftests/Makefile.target.in: ftests: fortran tests weren't\n\t  getting the TOPTFLAGS var set\n\t* src/testlib/test_utils.c: testlib: fix colors not turning off in\n\t  pass/fail indicator\n\t* src/ctests/api.c, src/ctests/attach2.c, src/ctests/attach3.c,\n\t  src/ctests/attach_cpu.c, src/ctests/inherit.c,\n\t  src/ctests/multiattach.c, src/ctests/multiattach2.c,\n\t  src/ctests/zero_attach.c, src/testlib/papi_test.h,\n\t  src/testlib/test_utils.c: testlib: update the way pass/fail is\n\t  printed  It's been bugging me for years that they don't line up\n\t* src/run_tests.sh: run_tests.sh: run the validation tests too\n\t* src/Makefile.inc: Makefile.inc: make it compile the\n\t  validation_tests\n\t* src/validation_tests/Makefile.recipies,\n\t  src/validation_tests/papi_br_msp.c: validation-tests: add\n\t  papi_br_msp test\n\t* src/validation_tests/Makefile.recipies,\n\t  src/validation_tests/branches_testcode.c,\n\t  src/validation_tests/matrix_multiply.c,\n\t  src/validation_tests/matrix_multiply.h,\n\t  src/validation_tests/papi_br_ins.c,\n\t  src/validation_tests/testcode.h: validation_tests: add papi_br_ins\n\t  test\n\t* src/validation_tests/Makefile.recipies,\n\t  src/validation_tests/papi_tot_cyc.c: validation_tests: add\n\t  papi_tot_cyc test\n\t* src/Makefile.inc: fix \"make install-all\"  had some extraneous \"..\"\n\t  after some previous changes\n\t* src/configure, src/configure.in,\n\t  src/validation_tests/Makefile.target.in,\n\t  src/validation_tests/papi_tot_ins.c: validation_tests: update\n\t  configure so it sets up the Makefile\n\t* src/testlib/papi_test.h, src/testlib/test_utils.c: testlib:\n\t  papi_print_header() lives with the utils code now\n\t* src/testlib/papi_test.h, src/testlib/test_utils.c: testlib: make\n\t  tests_quiet() return an integer  This way we don't have to depend\n\t  on the global var TESTS_QUIET if we don't want to.\n\t* src/validation_tests/Makefile,\n\t  src/validation_tests/Makefile.recipies,\n\t  src/validation_tests/Makefile.target.in,\n\t  src/validation_tests/display_error.c,\n\t  src/validation_tests/display_error.h,\n\t  src/validation_tests/instructions_testcode.c,\n\t  src/validation_tests/papi_tot_ins.c,\n\t  src/validation_tests/testcode.h: validation_tests: add initial\n\t  papi_tot_ins test  it is not hooked up to the build system yet\n\t* src/ctests/multiplex1.c, src/ctests/multiplex2.c,\n\t  src/ctests/second.c, src/ctests/sprofile.c, src/ctests/virttime.c,\n\t  src/ctests/zero_attach.c, src/ctests/zero_flip.c,\n\t  src/ctests/zero_fork.c, src/ctests/zero_omp.c,\n\t  src/ctests/zero_pthreads.c: ctests: more printf/TESTS_QUIET\n\t  conversions\n\t* src/testlib/fpapi_test.h: ftests: missing define was making\n\t  second.F fail\n\t* src/ctests/johnmay2.c, src/ctests/krentel_pthreads.c,\n\t  src/ctests/kufrin.c, src/ctests/locks_pthreads.c,\n\t  src/ctests/memory.c, src/ctests/multiattach.c,\n\t  src/ctests/multiattach2.c, src/ctests/multiplex1.c: ctests: more\n\t  printf/TESTS_QUIET fixes\n\n2017-06-21  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/ctests/all_events.c, src/ctests/all_native_events.c,\n\t  src/ctests/attach2.c, src/ctests/attach3.c,\n\t  src/ctests/attach_cpu.c, src/ctests/byte_profile.c,\n\t  src/ctests/calibrate.c, src/ctests/cmpinfo.c,\n\t  src/ctests/code2name.c, src/ctests/cycle_ratio.c,\n\t  src/ctests/exeinfo.c, src/ctests/fork_exec_overflow.c,\n\t  src/ctests/hl_rates.c, src/ctests/hwinfo.c: ctests: explicitly\n\t  block printfs with TESTS_QUIET  There was some hackery with the\n\t  preprocessor to avoid this but that wasn't a good solution.\n\t* src/testlib/do_loops.h, src/testlib/papi_test.h,\n\t  src/testlib/test_utils.c: testlib: minor papi_test.h cleanups\n\t* .../perf_event/tests/perf_event_offcore_response.c,\n\t  .../perf_event/tests/perf_event_system_wide.c,\n\t  .../perf_event/tests/perf_event_user_kernel.c,\n\t  .../tests/perf_event_amd_northbridge.c,\n\t  .../perf_event_uncore/tests/perf_event_uncore.c,\n\t  .../perf_event_uncore/tests/perf_event_uncore_cbox.c,\n\t  .../tests/perf_event_uncore_multiple.c, src/ctests/attach2.c,\n\t  src/ctests/attach3.c, src/ctests/attach_cpu.c,\n\t  src/ctests/attach_target.c, src/ctests/branches.c,\n\t  src/ctests/burn.c, src/ctests/byte_profile.c,\n\t  src/ctests/cycle_ratio.c, src/ctests/derived.c,\n\t  src/ctests/dmem_info.c, src/ctests/earprofile.c,\n\t  src/ctests/first.c, src/ctests/high-level.c, src/ctests/inherit.c,\n\t  src/ctests/johnmay2.c, src/ctests/krentel_pthreads.c,\n\t  src/ctests/kufrin.c, src/ctests/locks_pthreads.c, src/ctests/low-\n\t  level.c, src/ctests/matrix-hl.c, src/ctests/memory.c,\n\t  src/ctests/multiattach.c, src/ctests/multiattach2.c,\n\t  src/ctests/multiplex1.c, src/ctests/multiplex1_pthreads.c,\n\t  src/ctests/multiplex2.c, src/ctests/multiplex3_pthreads.c,\n\t  src/ctests/overflow.c, src/ctests/overflow2.c,\n\t  src/ctests/overflow3_pthreads.c, src/ctests/overflow_allcounters.c,\n\t  src/ctests/overflow_force_software.c, src/ctests/overflow_index.c,\n\t  src/ctests/overflow_one_and_read.c,\n\t  src/ctests/overflow_single_event.c,\n\t  src/ctests/overflow_twoevents.c, src/ctests/p4_lst_ins.c,\n\t  src/ctests/prof_utils.c, src/ctests/profile.c,\n\t  src/ctests/profile_twoevents.c, src/ctests/remove_events.c,\n\t  src/ctests/reset.c, src/ctests/reset_multiplex.c,\n\t  src/ctests/sdsc.c, src/ctests/sdsc2.c, src/ctests/sdsc4.c,\n\t  src/ctests/second.c, src/ctests/sprofile.c, src/ctests/tenth.c,\n\t  src/ctests/zero.c, src/ctests/zero_attach.c,\n\t  src/ctests/zero_flip.c, src/ctests/zero_fork.c,\n\t  src/ctests/zero_named.c, src/ctests/zero_omp.c,\n\t  src/ctests/zero_pthreads.c, src/ctests/zero_shmem.c,\n\t  src/ctests/zero_smp.c, src/testlib/Makefile,\n\t  src/testlib/fpapi_test.h, src/testlib/papi_test.h,\n\t  src/testlib/test_utils.h: testlib: more papi_test.h reduction\n\t* src/testlib/Makefile: testlib: turn off optimization on the\n\t  validation loops  it's making tests fail, need to go back and be\n\t  sure we are properly tricking the compiler.\n\t* src/Makefile.inc, src/components/Makefile_comp_tests,\n\t  src/components/perf_event/tests/Makefile,\n\t  src/components/perf_event_uncore/tests/Makefile,\n\t  src/components/rapl/tests/Makefile,\n\t  src/components/rapl/tests/rapl_overflow.c, src/ctests/Makefile,\n\t  src/ctests/Makefile.recipies, src/ctests/overflow_pthreads.c,\n\t  src/ctests/profile_pthreads.c, src/ftests/Makefile,\n\t  src/ftests/Makefile.recipies, src/ftests/Makefile.target.in,\n\t  src/testlib/Makefile, src/testlib/do_loops.c,\n\t  src/testlib/do_loops.h, src/testlib/papi_test.h: testlib: start\n\t  splitting the validation code off from the pass/fail code\n\t* src/components/perf_event/tests/perf_event_offcore_response.c,\n\t  src/components/perf_event/tests/perf_event_system_wide.c,\n\t  src/components/perf_event/tests/perf_event_user_kernel.c, src/compo\n\t  nents/perf_event_uncore/tests/perf_event_amd_northbridge.c,\n\t  src/components/perf_event_uncore/tests/perf_event_uncore.c,\n\t  src/components/perf_event_uncore/tests/perf_event_uncore_cbox.c, sr\n\t  c/components/perf_event_uncore/tests/perf_event_uncore_multiple.c,\n\t  src/components/rapl/tests/rapl_basic.c,\n\t  src/components/rapl/tests/rapl_overflow.c,\n\t  src/ctests/all_native_events.c, src/ctests/attach2.c,\n\t  src/ctests/attach3.c, src/ctests/attach_cpu.c,\n\t  src/ctests/attach_target.c, src/ctests/branches.c,\n\t  src/ctests/burn.c, src/ctests/byte_profile.c,\n\t  src/ctests/calibrate.c, src/ctests/case1.c, src/ctests/case2.c,\n\t  src/ctests/clockres_pthreads.c, src/ctests/cmpinfo.c,\n\t  src/ctests/code2name.c, src/ctests/cycle_ratio.c,\n\t  src/ctests/data_range.c, src/ctests/derived.c,\n\t  src/ctests/describe.c, src/ctests/disable_component.c,\n\t  src/ctests/dmem_info.c, src/ctests/earprofile.c,\n\t  src/ctests/eventname.c, src/ctests/exec.c, src/ctests/exec2.c,\n\t  src/ctests/exeinfo.c, src/ctests/first.c, src/ctests/flops.c,\n\t  src/ctests/fork.c, src/ctests/fork2.c, src/ctests/forkexec.c,\n\t  src/ctests/forkexec2.c, src/ctests/forkexec3.c,\n\t  src/ctests/forkexec4.c, src/ctests/get_event_component.c,\n\t  src/ctests/high-level.c, src/ctests/high-level2.c,\n\t  src/ctests/hl_rates.c, src/ctests/hwinfo.c, src/ctests/inherit.c,\n\t  src/ctests/ipc.c, src/ctests/johnmay2.c,\n\t  src/ctests/krentel_pthreads.c, src/ctests/kufrin.c,\n\t  src/ctests/locks_pthreads.c, src/ctests/low-level.c, src/ctests\n\t  /matrix-hl.c, src/ctests/memory.c, src/ctests/mendes-alt.c,\n\t  src/ctests/multiattach.c, src/ctests/multiattach2.c,\n\t  src/ctests/multiplex1.c, src/ctests/multiplex1_pthreads.c,\n\t  src/ctests/multiplex2.c, src/ctests/multiplex3_pthreads.c,\n\t  src/ctests/nmi_watchdog.c, src/ctests/omptough.c,\n\t  src/ctests/overflow.c, src/ctests/overflow2.c,\n\t  src/ctests/overflow3_pthreads.c, src/ctests/overflow_allcounters.c,\n\t  src/ctests/overflow_force_software.c, src/ctests/overflow_index.c,\n\t  src/ctests/overflow_one_and_read.c, src/ctests/overflow_pthreads.c,\n\t  src/ctests/overflow_single_event.c,\n\t  src/ctests/overflow_twoevents.c, src/ctests/p4_lst_ins.c,\n\t  src/ctests/prof_utils.c, src/ctests/profile.c,\n\t  src/ctests/profile_pthreads.c, src/ctests/profile_twoevents.c,\n\t  src/ctests/pthrtough.c, src/ctests/pthrtough2.c,\n\t  src/ctests/realtime.c, src/ctests/remove_events.c,\n\t  src/ctests/reset.c, src/ctests/reset_multiplex.c,\n\t  src/ctests/sdsc.c, src/ctests/sdsc2.c, src/ctests/sdsc4.c,\n\t  src/ctests/second.c, src/ctests/shlib.c, src/ctests/sprofile.c,\n\t  src/ctests/tenth.c, src/ctests/thrspecific.c,\n\t  src/ctests/timer_overflow.c, src/ctests/virttime.c,\n\t  src/ctests/zero.c, src/ctests/zero_attach.c,\n\t  src/ctests/zero_flip.c, src/ctests/zero_fork.c,\n\t  src/ctests/zero_named.c, src/ctests/zero_omp.c,\n\t  src/ctests/zero_pthreads.c, src/ctests/zero_shmem.c,\n\t  src/ctests/zero_smp.c, src/testlib/do_loops.c,\n\t  src/testlib/papi_test.h, src/testlib/test_utils.c: testlib: remove\n\t  include of papi.h  Need to explicitly include it in your test if\n\t  you need it.\n\t* src/testlib/Makefile, src/testlib/do_loops.c,\n\t  src/testlib/do_loops.h, src/testlib/dummy.c, src/utils/Makefile,\n\t  src/utils/papi_command_line.c, src/utils/papi_cost.c: utils: remove\n\t  last uses of testlib\n\t* src/utils/Makefile, src/utils/papi_hybrid_native_avail.c: utils:\n\t  update papi_hybrid_native_avail to not depend on testlib\n\t* src/utils/papi_multiplex_cost.c: utils: clean up\n\t  papi_multiplex_cost  remove dependeicnes on papi_test.h  print\n\t  message warning that it can take a long time to run\n\t* .../perf_event/tests/perf_event_offcore_response.c,\n\t  .../perf_event/tests/perf_event_system_wide.c,\n\t  .../perf_event/tests/perf_event_user_kernel.c,\n\t  .../perf_event_uncore/perf_event_uncore.c,\n\t  .../tests/perf_event_amd_northbridge.c,\n\t  .../perf_event_uncore/tests/perf_event_uncore.c,\n\t  .../tests/perf_event_uncore_cbox.c,\n\t  .../tests/perf_event_uncore_multiple.c,\n\t  src/components/rapl/tests/rapl_basic.c,\n\t  src/components/rapl/tests/rapl_overflow.c,\n\t  src/ctests/all_native_events.c, src/ctests/attach2.c,\n\t  src/ctests/attach3.c, src/ctests/branches.c,\n\t  src/ctests/byte_profile.c, src/ctests/calibrate.c,\n\t  src/ctests/data_range.c, src/ctests/describe.c,\n\t  src/ctests/disable_component.c, src/ctests/earprofile.c,\n\t  src/ctests/exec.c, src/ctests/exec2.c, src/ctests/exeinfo.c,\n\t  src/ctests/first.c, src/ctests/forkexec.c, src/ctests/forkexec2.c,\n\t  src/ctests/forkexec3.c, src/ctests/forkexec4.c,\n\t  src/ctests/get_event_component.c, src/ctests/inherit.c,\n\t  src/ctests/krentel_pthreads.c, src/ctests/kufrin.c, src/ctests\n\t  /matrix-hl.c, src/ctests/multiplex1.c,\n\t  src/ctests/multiplex1_pthreads.c, src/ctests/multiplex2.c,\n\t  src/ctests/nmi_watchdog.c, src/ctests/overflow_allcounters.c,\n\t  src/ctests/overflow_force_software.c,\n\t  src/ctests/overflow_pthreads.c, src/ctests/overflow_single_event.c,\n\t  src/ctests/overflow_twoevents.c, src/ctests/prof_utils.c,\n\t  src/ctests/profile_pthreads.c, src/ctests/remove_events.c,\n\t  src/ctests/reset.c, src/ctests/reset_multiplex.c,\n\t  src/ctests/sdsc.c, src/ctests/sdsc2.c, src/ctests/sdsc4.c,\n\t  src/ctests/second.c, src/ctests/shlib.c,\n\t  src/ctests/timer_overflow.c, src/ctests/zero_named.c,\n\t  src/testlib/do_loops.c, src/testlib/papi_test.h,\n\t  src/testlib/test_utils.c, src/utils/Makefile,\n\t  src/utils/cost_utils.c, src/utils/papi_command_line.c,\n\t  src/utils/papi_cost.c, src/utils/papi_event_chooser.c: testlib:\n\t  more header removal from papi_test.h\n\t* src/components/perf_event/tests/perf_event_system_wide.c,\n\t  src/ctests/attach2.c, src/ctests/attach3.c,\n\t  src/ctests/multiattach.c, src/ctests/multiattach2.c,\n\t  src/ctests/zero_attach.c, src/testlib/papi_test.h,\n\t  src/utils/cost_utils.c: testlib: remove a few more includes from\n\t  papi_test.h\n\t* src/components/rapl/tests/rapl_basic.c, src/ctests/all_events.c,\n\t  src/ctests/all_native_events.c, src/ctests/api.c,\n\t  src/ctests/attach2.c, src/ctests/attach3.c,\n\t  src/ctests/attach_cpu.c, src/ctests/attach_target.c,\n\t  src/ctests/branches.c, src/ctests/burn.c, src/ctests/calibrate.c,\n\t  src/ctests/case1.c, src/ctests/case2.c,\n\t  src/ctests/clockres_pthreads.c, src/ctests/code2name.c,\n\t  src/ctests/cycle_ratio.c, src/ctests/data_range.c,\n\t  src/ctests/derived.c, src/ctests/describe.c,\n\t  src/ctests/dmem_info.c, src/ctests/earprofile.c,\n\t  src/ctests/eventname.c, src/ctests/exec.c, src/ctests/exec2.c,\n\t  src/ctests/exeinfo.c, src/ctests/flops.c, src/ctests/fork.c,\n\t  src/ctests/fork2.c, src/ctests/forkexec.c, src/ctests/forkexec2.c,\n\t  src/ctests/forkexec3.c, src/ctests/forkexec4.c, src/ctests/high-\n\t  level.c, src/ctests/high-level2.c, src/ctests/hl_rates.c,\n\t  src/ctests/hwinfo.c, src/ctests/inherit.c, src/ctests/ipc.c,\n\t  src/ctests/johnmay2.c, src/ctests/kufrin.c,\n\t  src/ctests/locks_pthreads.c, src/ctests/low-level.c,\n\t  src/ctests/max_multiplex.c, src/ctests/memory.c,\n\t  src/ctests/multiattach.c, src/ctests/multiattach2.c,\n\t  src/ctests/multiplex1.c, src/ctests/multiplex1_pthreads.c,\n\t  src/ctests/multiplex2.c, src/ctests/multiplex3_pthreads.c,\n\t  src/ctests/overflow.c, src/ctests/overflow2.c,\n\t  src/ctests/overflow3_pthreads.c, src/ctests/overflow_allcounters.c,\n\t  src/ctests/overflow_force_software.c, src/ctests/overflow_index.c,\n\t  src/ctests/overflow_one_and_read.c, src/ctests/overflow_pthreads.c,\n\t  src/ctests/overflow_single_event.c,\n\t  src/ctests/overflow_twoevents.c, src/ctests/p4_lst_ins.c,\n\t  src/ctests/prof_utils.c, src/ctests/profile.c,\n\t  src/ctests/profile_pthreads.c, src/ctests/profile_twoevents.c,\n\t  src/ctests/pthrtough.c, src/ctests/pthrtough2.c,\n\t  src/ctests/realtime.c, src/ctests/sdsc.c, src/ctests/sdsc2.c,\n\t  src/ctests/sdsc4.c, src/ctests/second.c, src/ctests/shlib.c,\n\t  src/ctests/sprofile.c, src/ctests/tenth.c,\n\t  src/ctests/thrspecific.c, src/ctests/timer_overflow.c,\n\t  src/ctests/virttime.c, src/ctests/zero.c, src/ctests/zero_attach.c,\n\t  src/ctests/zero_flip.c, src/ctests/zero_fork.c,\n\t  src/ctests/zero_omp.c, src/ctests/zero_pthreads.c,\n\t  src/ctests/zero_shmem.c, src/ctests/zero_smp.c,\n\t  src/testlib/do_loops.c, src/testlib/dummy.c,\n\t  src/testlib/papi_test.h, src/testlib/test_utils.c,\n\t  src/utils/papi_command_line.c, src/utils/papi_cost.c: testlib:\n\t  split some headers out of papi_test.h  Too much is going on in that\n\t  header, no need to have every include in the world in it.  Trying\n\t  to make the testcode more standalone so it is easier to follow.\n\t* src/testlib/Makefile, src/testlib/Makefile.target.in: testlib: let\n\t  testlib build properly from within the testlib directory\n\t* src/testlib/clockcore.c: testlib: clockcore wasn't protecting all\n\t  the output with !quiet\n\t* src/ctests/Makefile: ctests: make sure tests link against the right\n\t  papi.h file\n\t* src/Makefile.inc, src/ctests/Makefile,\n\t  src/ctests/Makefile.target.in: ctests: allow running \"make\" in the\n\t  ctests directory to work\n\n2017-06-20  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/Matlab/PAPI_Matlab.readme, src/papi.c, src/utils/papi_avail.c,\n\t  src/utils/papi_clockres.c, src/utils/papi_command_line.c,\n\t  src/utils/papi_component_avail.c, src/utils/papi_cost.c,\n\t  src/utils/papi_decode.c, src/utils/papi_error_codes.c,\n\t  src/utils/papi_event_chooser.c,\n\t  src/utils/papi_hybrid_native_avail.c, src/utils/papi_mem_info.c,\n\t  src/utils/papi_multiplex_cost.c, src/utils/papi_native_avail.c,\n\t  src/utils/papi_version.c, src/utils/papi_xml_event_info.c: update\n\t  the ptools-perfapi e-mail address  in the auto-generated manpages\n\t  it was still using the old ptools.org address.\n\t* doc/Makefile: docs: fix the manpage build after renaming the utils\n\t  Thanks to Steve Kaufmann for catching this.\n\t* src/utils/Makefile, src/utils/papi_native_avail.c: utils:\n\t  papi_native_avail: remove extraneous testing code\n\t* src/utils/Makefile, src/utils/papi_mem_info.c: utils:\n\t  papi_mem_info: remove extraneous test code\n\t* src/utils/Makefile, src/utils/papi_xml_event_info.c: utils:\n\t  papi_xml_event_info: remove extraneous test code\n\t* src/utils/Makefile, src/utils/papi_decode.c: utils: papi_decode:\n\t  remove extraneous test code\n\t* src/utils/Makefile, src/utils/papi_error_codes.c: utils:\n\t  papi_error_codes: remove extraneous test code\n\t* src/utils/Makefile, src/utils/papi_component_avail.c: utils:\n\t  papi_component_avail: remove extraneous test code\n\t* src/ctests/clockres_pthreads.c, src/testlib/clockcore.c,\n\t  src/testlib/clockcore.h, src/testlib/papi_test.h,\n\t  src/utils/Makefile, src/utils/papi_clockres.c: utils:\n\t  papi_clockres, remove extraneous test code\n\t* src/utils/Makefile, src/utils/papi_avail.c,\n\t  src/utils/print_header.c, src/utils/print_header.h: utils: update\n\t  papi_avail to not depend on testlibs  It's not a test.\n\t* src/utils/Makefile: utils: add target for papi_hybrid_native_avail\n\t  do not build it by default though?  Should only be built if\n\t  compiling for MIC?\n\t* src/utils/Makefile, src/utils/avail.c, src/utils/clockres.c,\n\t  src/utils/command_line.c, src/utils/component.c, src/utils/cost.c,\n\t  src/utils/decode.c, src/utils/error_codes.c,\n\t  src/utils/event_chooser.c, src/utils/event_info.c,\n\t  src/utils/hybrid_native_avail.c, src/utils/mem_info.c,\n\t  src/utils/multiplex_cost.c, src/utils/native_avail.c,\n\t  src/utils/papi_avail.c, src/utils/papi_clockres.c,\n\t  src/utils/papi_command_line.c, src/utils/papi_component_avail.c,\n\t  src/utils/papi_cost.c, src/utils/papi_decode.c,\n\t  src/utils/papi_error_codes.c, src/utils/papi_event_chooser.c,\n\t  src/utils/papi_hybrid_native_avail.c, src/utils/papi_mem_info.c,\n\t  src/utils/papi_multiplex_cost.c, src/utils/papi_native_avail.c,\n\t  src/utils/papi_xml_event_info.c: utils: rename the utils so the\n\t  executable matches the filename  This has bothered me for years,\n\t  you want to fix \"papi_native_avail\" but there is no file in the\n\t  tree called \"papi_native_avail.c\"\n\t* src/utils/Makefile, src/utils/papi_version.c, src/utils/version.c:\n\t  utils: rename version.c to papi_version.c  Also minor cleanups to\n\t  the utility.\n\t* src/Makefile.inc, src/configure, src/configure.in,\n\t  src/utils/Makefile, src/utils/Makefile.target.in: utils: clean up\n\t  Makefile and build process of utils  Now should be able to run\n\t  \"make\" in the utils subdir and have it build.  Also move the list\n\t  of util files to build out of configure as I don't think there's\n\t  any reason for having them there.\n\t* src/components/perf_event/pe_libpfm4_events.c: perf: fall back to\n\t  operating system default events if libpfm4 lacks support  This will\n\t  allow use of PAPI on machines that Linux has support for, but\n\t  libpfm4 has not added events yet.  Still some limitations, for\n\t  example the PAPI preset events won't work.\n\t* src/components/perf_event/pe_libpfm4_events.c,\n\t  src/components/perf_event/perf_event.c: perf: report better errors\n\t  if libpfm4 initialization fails\n\t* src/components/perf_event/pe_libpfm4_events.c: perf:\n\t  pe_libpfm4_events: minor whitespace fixup\n\t* src/components/perf_event/pe_libpfm4_events.c: perf:\n\t  pe_libpfm4_events: whitespace changes to make code easier to follow\n\n2017-06-19  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/ctests/code2name.c: ctests/code2name: fix uninitialized\n\t  variable warning\n\t* src/ctests/calibrate.c: ctests/calibrate: fix uninitialized\n\t  variable warning\n\t* src/ctests/thrspecific.c: ctests: thrspecific fix so it finishes\n\t  It's actually really unclear what this code is trying to test, but\n\t  with optimization enabled it hung forever.  Marking the variable\n\t  being spun on as volatile fixes things but I think there is more\n\t  wrong with the test than just that.\n\t* src/ctests/branches.c, src/ctests/sdsc.c, src/ctests/sdsc4.c:\n\t  ctests: fix tests using \"dummy3()\" as a workload  Now that we\n\t  enable optimization on the ctests this breaks some of the\n\t  benchmarks.  dummy3() was being optimized away which caused\n\t  segfaults and other problems.  The tests don't crash now, but they\n\t  still fail.  Still investigating.\n\n2016-10-12  Phil Mucci <phil@minimalmetrics.com>\n\n\t* src/configure: Regenerated configure with recent autoconf\n\t* src/configure.in: By default, we want -O1 on tests (TOPTFLAGS). -O0\n\t  is too literal and causes a number of tests who depend on peephole\n\t  optimization to run.\n\t* src/utils/Makefile: Utils are installed therefore they should be\n\t  built with production flags not test/debug flags\n\t* src/Makefile.inc: Make clean should not clean up libpfm. Thats for\n\t  make distclean. We're not developing libpfm!\n\n2016-07-04  Phil Mucci <phil@minimalmetrics.com>\n\n\t* src/ctests/mendes-alt.c, src/ctests/zero.c: Moved functions\n\t  definitions to top of file to eliminate non-ANSI-C prototypes\n\t  inside main. Modified message in zero to not turbo boost will also\n\t  cause errors (cycles > real-time-cycle\n\t* src/Makefile.in, src/Makefile.inc, src/configure, src/configure.in:\n\t  Remove EXTRA_CFLAGS, now CFLAGS. Added FTOPTS so compiling Fortran\n\t  tests have same flags as ctests. Fix proper testing at configure\n\t  time of libpfm for proper combinations of libpfm options\n\t* src/ftests/Makefile: Homogenize include flags\n\t* src/ctests/Makefile: Homogenize include flags\n\t* src/testlib/Makefile: Removed unnecessary defs and options\n\t* src/utils/Makefile: Removed unnecessary definitions and compiler\n\t  options\n\n2016-07-01  Phil Mucci <phil@minimalmetrics.com>\n\n\t* src/Makefile.in, src/Makefile.inc, src/Rules.perfctr-pfm,\n\t  src/Rules.perfmon2, src/Rules.pfm4_pe,\n\t  src/components/Makefile_comp_tests.target.in,\n\t  src/components/perf_event/pe_libpfm4_events.c, src/configure,\n\t  src/configure.in, src/ctests/Makefile,\n\t  src/ctests/Makefile.target.in, src/ftests/Makefile,\n\t  src/ftests/Makefile.target.in: Makefile.in: - Removed DEBUGFLAGS,\n\t  NOTLS, PAPI_EVENTS_TABLE from being generated. These were not\n\t  properly used. - Added LIBCFLAGS generated from configure for\n\t  CFLAGS that ONLY apply to the library and the library code. NOT\n\t  tests nor utilities. Previously we were propagating all kinds of\n\t  bogus flags to the tests and utils. - CFLAGS is now properly set\n\t  for compiler flags not defines etc.  Makefile.inc: - Put\n\t  papi_events_table.h in the right place. This is always the same\n\t  name. Previous attempts at parameterizing this were broken and/or\n\t  unnecessary. - Added dependency for the above in the right place\n\t  and ALWAYS generate it, regardless of whether we actually include\n\t  it in the library (vs load the CSV at runtime).  Rules.perfctr-pfm\n\t  - Removed conditional removal of events table during clean.\n\t  Rules.perfmon2 - Removed conditional removal of events table during\n\t  clean.  Rules.pfm4_pe - Stopped mussing with CFLAGS which would\n\t  pollute child builds but refer to LIBCFLAGS. CFLAGS is for\n\t  everything! - Removed conditional removal of events table during\n\t  clean. - Removed duplicate reference to papi_events_table.h\n\t  components/perf_event/pe_libpfm4_events.c: - Removed HARDCODED\n\t  include of a libpfm4 private header file. Wrong path and\n\t  unnecessary include. This would break if you linked against another\n\t  libpfm using any of the config options.\n\t  components/perf_event/peu_libpfm4_events.c: - Removed HARDCODED\n\t  include of a libpfm4 private header file. Wrong path and\n\t  unnecessary include. This would break if you linked against another\n\t  libpfm using any of the config options.\n\t  components/Makefile_comp_tests.target.in: - Refer to datarootdir to\n\t  make autoconf happy  configure/configure.in: Regenerated using\n\t  autoconf 2.69 and many modifications to serious brokennesss. Lots\n\t  of fixes: - Sanitize options for static inclusion of user and papi\n\t  presets - Fix options that do not print out a result - Fix\n\t  debug=yes to not include PAPI_MEMORY_MANAGEMENT. That's only\n\t  enabled with debug=memory. This will reduce false positives when we\n\t  debug. We don't want our own malloc/free changing behavior when we\n\t  are trying to debug! - Fix CFLAGS/LIBCFLAGS/DEBUGFLAGS. configure\n\t  now exports a variable called PAPICFLAGS which gets stuffed into\n\t  LIBCFLAGS in Makefile.in. This variable IS ONLY for compiler flags\n\t  relevant to the library. Previously we were exporting all sorts of\n\t  stuff that would make our passes behave differently that user code.\n\t  _GNU_SOURCE and -D_REENTRANT. That stuff is for the library and\n\t  components. Not user code. - Update compile tests to use\n\t  AC_LANG_SOURCE as required. - Fix clock timer checking output to\n\t  now say what timer we picked instead of just skipping an answer -\n\t  Same for virtual clock timer - Remove broken --with-papi-events\n\t  option. - Fixed --with-static-tools option - Fixed/added --with-\n\t  static-papi-events option (default) and --with-static-user-events\n\t  option. - Fixed modalities of configuring whether to build a\n\t  static/shared or both. - Fixed link of tests with shared libraries\n\t  when above options don't support it. Modality again. Remove\n\t  SETPATH/LIBPATH define, which won't work for ANY combination of\n\t  --with-pfm-prefix/root/libdir except our included library. Woefully\n\t  broken and would result in many false positive failures. If you are\n\t  going to run the tests on the shared library it is now the users\n\t  responsibility to set LD_LIBRARY_PATH/LIBPATH correctly. I suspect\n\t  this may irritate some, but broken 90% of the time is no excuse for\n\t  correct 10% of the time especially when it could generate bug\n\t  reports falsely. - Fixed with-static-tools, with-shlib-tools\n\t  options to correct modalities. - Fixed all modalities with --with-\n\t  pfm-prefix/root/libdir/incdir. Previously the build, configure and\n\t  source files were still referring to pieces of code INSIDE our\n\t  libpfm4 resulting in version skew and breakage. The way to test\n\t  this stuff is to use --root or --prefix after removing the internal\n\t  libpfm4 library. - Removed unnecessary and confusing\n\t  force_pfm_incdir - Fixed with-pe-incdir option which, like before\n\t  was most of the time referring to the libpfm4 included header file.\n\t  Not good if one has a custom kernel! PECFLAGS now only appended to\n\t  PAPICFLAGS(LIBCFLAGS). - Removal of DEBUGFLAGS. aix.c needs\n\t  testing. Anyone have one? - Fixed CFLAGS for BSD - Add message for\n\t  papi_events.csv  ctests/Makefile ftests/Makefile - Don't redefine\n\t  CC/CC_R/CFLAGS/FFLAGS. - Make these files consistent\n\t  ctests/Makefile.target.in ftests/Makefile.target.in - refer to\n\t  datarootdir as required\n\n2016-06-27  Phil Mucci <phil@minimalmetrics.com>\n\n\t* src/testlib/Makefile, src/testlib/Makefile.target.in: Added\n\t  explicit target for libtestlib.a. The all target should have been\n\t  markted as .PHONY as to avoid constant rebuilding.  Also, we really\n\t  should merge these two files into a master and an include.\n\t  Maintaining two makefiles stinks!\n\n2017-06-16  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/papi_fwrappers.c: fwrappers: papif_unregister_thread was\n\t  misspelled as papif_unregster_thread  This was noticed by Vedran\n\t  Novakovic  For an extremely long time (10+ years?) the fortran\n\t  wrapper was misspelled as papif_unregster_thread()  It's probably\n\t  too late to fix this without potentially breaking things, so just\n\t  add a duplicate function with the proper spelling and leave the old\n\t  one too.\n\t* src/papi_preset.c: papi_preset: fix compiler warning  This really\n\t  confusing warning has been around for a while.  gcc-6.3 reports it\n\t  in a really odd way:  papi_preset.c: In function\n\t  \u2018check_derived_events\u2019: papi_preset.c:513:19: warning:\n\t  \u2018__s\u2019 may be used uninitialized in this function$ int val =\n\t  atoi(&subtoken[1]); ^~~~~~~~~~~~ papi_preset.c:464:1: note:\n\t  \u2018__s\u2019 was declared here ops_string_merge(char **original, char\n\t  *insertion, int replaces, int start_ind$ ^~~~~~~~~~~~~~~~  But\n\t  there is no __s variable, or anything to do with where the arrows\n\t  are pointing.  gcc-5 gives a better warning:  papi_preset.c: In\n\t  function \u2018check_derived_events\u2019: papi_preset.c:513:14: warning:\n\t  \u2018tok_save_ptr\u2019 may be used uninitialized in this$ int val =\n\t  atoi(&subtoken[1]); ^ papi_preset.c:472:8: note: \u2018tok_save_ptr\u2019\n\t  was declared here char *tok_save_ptr;  So the thing it seems to be\n\t  complaining about is that the *saveptr paramater to strtok_r() is\n\t  not set to NULL.  According to the manpage I don't think this\n\t  should be needed? But I think it should be safe to initialize it\n\t  anyway.\n\nTue Jun 6 11:09:17 2017 -0500  Will Schmidt <will_schmidt@vnet.ibm.com>\n\n\t* src/libpfm4/lib/events/power9_events.h,\n\t  src/libpfm4/perf_examples/self_count.c,\n\t  src/libpfm4/tests/validate_power.c: Update libpfm4  Current with\n\t  commit ce5b320031f75f9a9881333c13902d5541f91cc8  add power9 entries\n\t  to validate_power.c  Hi,  Update the validate_power test to include\n\t  power9 entries.  sniff-test run output: $ ./validate Libpfm\n\t  structure tests: libpfm ABI version : 0 pfm_pmu_info_t : Passed\n\t  pfm_event_info_t : Passed pfm_event_attr_info_t : Passed\n\t  pfm_pmu_encode_arg_t : Passed pfm_perf_encode_arg_t : Passed Libpfm\n\t  internal table tests: <snip...> checking power9 (946 events):\n\t  Passed Architecture specific tests: 20 PowerPC events: 0 errors All\n\t  tests passed\n\n2017-06-15  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/components/perf_event/pe_libpfm4_events.c,\n\t  src/components/perf_event/pe_libpfm4_events.h,\n\t  .../perf_event_uncore/Rules.perf_event_uncore,\n\t  .../perf_event_uncore/perf_event_uncore.c,\n\t  .../perf_event_uncore/peu_libpfm4_events.c,\n\t  .../perf_event_uncore/peu_libpfm4_events.h: perf_event: merge the\n\t  libpfm4 helper libraries  perf_event and perf_event_uncore had\n\t  their own almost exactly the same libpfm4 helper libraries.\n\t  Maintaining both was a chore, and it looks like it is possible to\n\t  just share one copy.  This does mean that it is now not possible to\n\t  configure the perf_event_uncore component without perf_event being\n\t  enabled, but I am not sure if that was even possible to begin with.\n\t* src/components/perf_event/pe_libpfm4_events.c,\n\t  .../perf_event_uncore/perf_event_uncore.c,\n\t  .../perf_event_uncore/peu_libpfm4_events.c,\n\t  .../perf_event_uncore/peu_libpfm4_events.h: perf_event_uncore: make\n\t  the libpfm4 routines match even more\n\t* src/components/perf_event/pe_libpfm4_events.c,\n\t  .../perf_event_uncore/peu_libpfm4_events.c: perf_event: make\n\t  perf_event and perf_event uncore libpfm4 more similar  it's a bad\n\t  idea to have more or less two copies of the same code\n\t* src/components/perf_event/pe_libpfm4_events.c,\n\t  .../perf_event_uncore/peu_libpfm4_events.c: perf_event: Avoid\n\t  unintended libpfm build dependency due to PFM_PMU_MAX enum  This\n\t  patch is based on one sent by William Cohen <wcohen@redhat.com>\n\t  The libpfm pfmlib.h file enumerates the each of performance\n\t  monitoring units (PMUs) it can program in pfm_pmu_t type.  The last\n\t  enum in this type is PFM_PMU_MAX.  Depending on which specific\n\t  version of libpfm being used this specific value could vary.  The\n\t  problem is that PFM_PMU_MAX is statically defined in the pfmlib.h\n\t  file and this was being used as a loop bounds when iterating to\n\t  determine which PMUs are potentially available.  If PAPI was built\n\t  with an older version of libpfm and then run with a newer libpfm\n\t  shared library on a machine with a larger PFM_PMU_MAX value, none\n\t  of the PMUs past the smaller PFM_PMU_MAX used for the the build\n\t  would be examined or enabled.\n\n2017-06-15  Heike Jagode (jagode@icl.utk.edu) <jagode@d00.descartes>\n\n\t* src/components/infiniband/linux-infiniband.c: Updated infiniband\n\t  component so that it works for mofed driver version 4.0, where\n\t  directory counters_ext in sysfs fs has changed to hw_counters.\n\t  This update to the component makes it work for both directory\n\t  names: - counters_ext for mofed driver version <4.0, and -\n\t  hw_counters for mofed driver version =>4.0  This change has not\n\t  been fully tested yet due to missing access to machine with updated\n\t  version of mofed driver. (CORAL machines will have an updated\n\t  version of this driver.)\n\n2017-05-04  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/components/rapl/linux-rapl.c: rapl: broadwell-ep DRAM units are\n\t  special (like Haswell-EP)  The Linux kernel perf interface had this\n\t  wrong too.  I noticed this in my cluster computing classs, the\n\t  Broadwell-EP DRAM results were unrealistically high values.\n\nFri Apr 21 17:33:15 2017 -0700  William Cohen <wcohen@redhat.com>\n\n\t* src/libpfm4/README, src/libpfm4/include/perfmon/pfmlib.h,\n\t  src/libpfm4/lib/Makefile, src/libpfm4/lib/events/power9_events.h,\n\t  src/libpfm4/lib/pfmlib_common.c, src/libpfm4/lib/pfmlib_power9.c,\n\t  src/libpfm4/lib/pfmlib_power_priv.h, src/libpfm4/lib/pfmlib_priv.h,\n\t  src/libpfm4/lib/pfmlib_s390x_cpumf.c: Update libpfm4\\n\\nCurrent\n\t  with\\n commit 8385268c98553cb5dec9ca86bbad3e5c44a2ab16  fix\n\t  internal pfm_event_attr_info_t use for S390X  Commit 321133e\n\t  converted most of the architectures to use the internal\n\t  perflib_event_attr_info_t type.  However, the s390 was missed in\n\t  that previous commit.  This patch corrects the issue so libpfm\n\t  compiles on s390.\n\n2017-04-20  Stephen Wood <swood@icl.utk.edu>\n\n\t* src/extras.c, src/papi.h, src/papi_fwrappers.c, src/papi_hl.c,\n\t  src/papi_internal.c: cast pointers appropriately to avoid warnings\n\t  and errors\n\n2017-04-19  Sangamesh Ragate <sragate@minotaur.nic.uoregon.edu>\n\n\t* src/papi_events.csv: Mapped PAPI_L2_ICM preset event to\n\t  PM_INST_FROM_L2MISS native event for Power8\n\n2017-04-06  Asim YarKhan <yarkhan@icl.utk.edu>\n\n\t* src/ftests/fmatrixlowpapi.F: Fixed: This fortran test exceeded 72\n\t  columns and made the default Intel ifort compilation unhappy\n\nWed Apr 5 23:35:44 2017 -0700  Andreas Beckmann <a.beckmann@fz-juelich.de>\n\n\t* src/libpfm4/docs/man3/libpfm_arm_ac53.3,\n\t  src/libpfm4/docs/man3/libpfm_arm_ac57.3,\n\t  src/libpfm4/docs/man3/libpfm_arm_xgene.3, src/libpfm4/lib/Makefile,\n\t  src/libpfm4/lib/events/arm_cortex_a53_events.h,\n\t  src/libpfm4/lib/events/intel_glm_events.h,\n\t  src/libpfm4/lib/events/intel_hswep_unc_imc_events.h,\n\t  src/libpfm4/lib/events/intel_ivbep_unc_imc_events.h,\n\t  src/libpfm4/lib/events/intel_knl_events.h,\n\t  src/libpfm4/lib/events/intel_knl_unc_cha_events.h,\n\t  src/libpfm4/lib/events/power4_events.h,\n\t  src/libpfm4/lib/events/ppc970_events.h,\n\t  src/libpfm4/lib/events/ppc970mp_events.h,\n\t  src/libpfm4/perf_examples/self_smpl_multi.c: Update\n\t  libpfm4\\n\\nCurrent with\\n commit\n\t  71a960d9c17b663137a2023ce63edd2f3ca115f5  fix various event\n\t  description typos  This patch fixes the typos in several event\n\t  description for Intel, Arm, and Power event tables.\n\n2017-03-30  William Cohen <wcohen@redhat.com>\n\n\t* src/ftests/cost.F, src/ftests/first.F, src/ftests/fmatrixlowpapi.F,\n\t  src/ftests/second.F: Eliminate warnings about implicit type\n\t  conversions in Fortran tests  The gfortran compiler on Fedora 25\n\t  was giving warnings indicating that a few of the tests were doing\n\t  implicit type convertion between reals and ints.  Those implicit\n\t  conversions have been made explicit to elminate the fortran\n\t  compiler warning messages.\n\nTue Apr 4 09:42:25 2017 -0700  Stephane Eranian <eranian@gmail.com>\n\n\t* src/libpfm4/include/perfmon/pfmlib.h,\n\t  src/libpfm4/lib/pfmlib_amd64.c,\n\t  src/libpfm4/lib/pfmlib_amd64_priv.h, src/libpfm4/lib/pfmlib_arm.c,\n\t  src/libpfm4/lib/pfmlib_arm_priv.h, src/libpfm4/lib/pfmlib_common.c,\n\t  src/libpfm4/lib/pfmlib_intel_netburst.c,\n\t  src/libpfm4/lib/pfmlib_intel_nhm_unc.c,\n\t  src/libpfm4/lib/pfmlib_intel_snbep_unc.c,\n\t  src/libpfm4/lib/pfmlib_intel_snbep_unc_priv.h,\n\t  src/libpfm4/lib/pfmlib_intel_x86.c,\n\t  src/libpfm4/lib/pfmlib_intel_x86_perf_event.c,\n\t  src/libpfm4/lib/pfmlib_intel_x86_priv.h,\n\t  src/libpfm4/lib/pfmlib_mips.c, src/libpfm4/lib/pfmlib_mips_priv.h,\n\t  src/libpfm4/lib/pfmlib_perf_event.c,\n\t  src/libpfm4/lib/pfmlib_perf_event_pmu.c,\n\t  src/libpfm4/lib/pfmlib_perf_event_raw.c,\n\t  src/libpfm4/lib/pfmlib_power_priv.h,\n\t  src/libpfm4/lib/pfmlib_powerpc.c, src/libpfm4/lib/pfmlib_priv.h,\n\t  src/libpfm4/lib/pfmlib_sparc.c,\n\t  src/libpfm4/lib/pfmlib_sparc_priv.h,\n\t  src/libpfm4/lib/pfmlib_torrent.c, src/libpfm4/tests/validate.c,\n\t  src/libpfm4/tests/validate_x86.c: Update libpfm4\\n\\nCurrent with\\n\n\t  commit 5e311841e5d70efb93d11826109cb5acab6e051c  enable 38-bit raw\n\t  umasks for Intel offcore_response events  This patch enables\n\t  support for passing and encoding of 38-bit offcore_response matrix\n\t  umask. Without the patch, the raw umask was limited to 32-bit which\n\t  is not enough to cover all the possible bits of the\n\t  offcore_response event available since Intel SandyBridge.  $\n\t  examples/check_events offcore_response_0:0xffffff Requested Event:\n\t  offcore_response_0:0xffffff Actual    Event:\n\t  ivb::OFFCORE_RESPONSE_0:0xffffff:k=1:u=1:e=0:i=0:c=0:t=0 PMU\n\t  : Intel Ivy Bridge IDX            : 155189325 Codes          :\n\t  0x5301b7 0xffffff  The patch also adds tests to the validation\n\t  code.\n\n2017-03-29  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/components/perfctr/perfctr-x86.c: perfctr: fix perfctr\n\t  component to actually work  Simple one-line typo means perfctr was\n\t  not working, probably for years.  I've tested on a 2.6.32-perfctr\n\t  kernel and it works again.\n\n2017-03-28  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/papi_events.csv: papi_events: add AMD fam16h jaguar events\n\t  These will become useful if/when the contributed libpfm4 jaguar\n\t  patches get applied.\n\n2017-03-27  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/papi_events.csv: events: p4: change the PAPI_TOT_CYC event\n\t  PAPI_TOT_CYC wasn't working on Pentium4 because the\n\t  GLOBAL_POWER_EVENT:RUNNING event was being grabbed by the hardware\n\t  watchdog.  perf cycles:u was still working, that's because the\n\t  kernel transparently remaps the cycles event to an alias when\n\t  global_power_event's slot is taken.  The aliased event is the\n\t  unwieldly: execution_event:nbogus0:nbogus1:nbogus2:nbogus3:bogus0:b\n\t  ogus1:bogus2:bogus3:cmpl:thr=15 which does seem to give the right\n\t  results.  Use this event instead by default on Pentium 4\n\t* src/components/perf_event/perf_event.c: perf_event: fix warning\n\t  when compiling with debug enabled  the flags field is an unsigned\n\t  long, not an int\n\n2017-03-22  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/components/perf_event/perf_event.c: perf_event: don't allocate\n\t  a mmap page if not rdpmc or sampling\n\t* src/components/perf_event/perf_event.c: perf_event: only allocate 1\n\t  mmap page (rather than 3) if not sampling  Next step is to allocate\n\t  0 mmap pages unless rdpmc is enabled\n\t* src/components/perf_event/perf_event.c,\n\t  src/components/perf_event/perf_event_lib.h: perf_event: update the\n\t  _pe_set_overflow() call  Working on making it more obvious which\n\t  events are sampling (and thus need mmap buffers) or not.  Also\n\t  there were some bugs in the handling of having multiple overflow\n\t  sources per eventset, though I'm not sure if PAPI actually handles\n\t  that.\n\t* src/components/perf_event/perf_event.c: perf_event: turn off\n\t  fast_counter_read if mmaps fail  By default on Linux perf_event\n\t  can't use more than 516kB of mmap space.  So perf_event-rdpmc would\n\t  fail after you added a large number (>32) of events.  This shows up\n\t  on the kufrin benchmark on some machines.  This fix makes PAPI fall\n\t  back to non-rdpmc if an mmap error happens. I'm also going to try\n\t  to tune the mmap usage a bit to make the limits a bit higher.\n\n2017-03-21  Asim YarKhan <yarkhan@icl.utk.edu>\n\n\t* src/configure: configure script updated using autoconf-2.59\n\n2017-03-20  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/components/perf_event/perf_event.c, src/configure.in:\n\t  configure: enable rdpmc with --enable-perfevent-rdpmc=yes  Make\n\t  this an option to configure.  Defaults to no.  Need to find a\n\t  machine with autoconf 2.59 on and I'll regenerate configure as\n\t  well.\n\n2017-03-16  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/components/perf_event/perf_event.c: perf_event: try to work\n\t  around exclude_guest issue  run a test at startup to see if events\n\t  with exclude_guest fail.  libpfm4 sets this by default, but older\n\t  kernels will fail because this was previously a reserved (must be\n\t  zero) field.\n\n2017-03-14  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/ctests/multiattach.c: tests: multiattach:\n\t  whitespace/comments/clarifications  digging through the code trying\n\t  to figure out why it fails with rdpmc enabled.  it turns out it is\n\t  seeing wrong running/enabled multiplexing results even though we\n\t  aren't multiplexing  tracking this down is a pain because we can't\n\t  strace/ltrace due to the code using ptrace to start/stop processes.\n\n2017-03-09  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/components/perf_event/perf_event.c: perf_event: can't mmap() an\n\t  inherited event  this is why the inherit test was failing\n\t* src/components/perf_event/perf_event.c,\n\t  src/components/perf_event/perf_helpers.h: perf_event: add rdpmc\n\t  support (but disabled)  finally add the rdpmc code, but it still\n\t  fails on a few tests so it is disabled by default.\n\t* src/components/perf_event/perf_event.c,\n\t  src/components/perf_event/perf_event_lib.h: perf_event: make all\n\t  events come with a mmap buffer  This wastes some address space, but\n\t  having separate codepaths for rdpmc/regular/sampling/profiling\n\t  would be hard to maintain.  Had to remove some assumptions from the\n\t  profiling/sampling code that mmap_buf means sampling is happening.\n\t* src/components/perf_event/perf_event.c: perf_event: add check for\n\t  paranoid==3  Recent distributions are *completely* disablng\n\t  perf_event by default with their vendor kernels (this is not\n\t  upstream yet).  Have PAPI detect and disable the perf_event\n\t  component if this is detected.\n\t* src/components/perf_event/perf_event.c: perf_event: split\n\t  close_pe_events() into two functions\n\t* src/components/perf_event/perf_event.c,\n\t  src/components/perf_event/perf_helpers.h: perf_event: more\n\t  whitespace / rearrangement  should not be any changes to actual\n\t  code, is just whitespace/comment/function movement  I know changes\n\t  like this make the git history harder to follow, but it really\n\t  helps when trying to follow the code when working on major changes.\n\n2017-03-08  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/components/perf_event/perf_event.c: perf_event: more\n\t  whitespace/comment cleanups  digging through the code, still\n\t  prepping for rdpmc\n\n2017-03-07  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/components/perf_event/perf_helpers.h: perf_event: rdpmc: need\n\t  to sign extend offset too  Otherwise things stop working after a\n\t  PAPI_reset()\n\t* src/components/perf_event/perf_event.c: perf_event: split up\n\t  _pe_read()  makes the code a bit easier to follow.  also prep for\n\t  rdpmc()\n\t* src/components/perf_event/perf_event.c: perf_event: clean up\n\t  whitespace in _pe_read\n\n2017-03-08  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/ctests/first.c: ctests: first: white space cleanups  minor\n\t  things noticed when trying to figure out why it was failing with\n\t  rdpmc (the answer was rdpmc code not handling PAPI_reset())\n\n2017-03-07  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/components/perf_event/perf_helpers.h: perf_event: recent\n\t  changes broke build on non-x86  an ifdef was in the wrong location.\n\t* src/components/perf_event/perf_event.c,\n\t  src/components/perf_event/perf_helpers.h: perf_event: update rdpmc\n\t  detection\n\t* src/utils/component.c: utils: component_avail: clean up -d\n\t  (detailed) results  print rdpmc status, as well as line things up.\n\t  Also don't print redundant info, now that a lot more fields are\n\t  printed by default.\n\t* src/utils/component.c: utils: component_avail: whitespace/grammar\n\t  fixes\n\t* src/components/perf_event/Rules.perf_event,\n\t  src/components/perf_event/perf_helpers.h: perf_event: add\n\t  mmap/rdpmc routine  we don't use it yet\n\n2017-03-06  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/components/perf_event/perf_helpers.h: perf_event: add rdtsc()\n\t  and rdpmc() inline-assembly\n\t* src/components/perf_event/perf_event.c,\n\t  src/components/perf_event/perf_helpers.h: perf_event: move\n\t  perf_event_open() code to a helper file  We'll be adding some other\n\t  helpers to this file too.\n\n2017-03-03  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/components/perf_event/perf_event.c: perf_event: move\n\t  bug_sync_read() check out of line  we should eventually just phase\n\t  out a lot of these checks for older kernels, but it gets tricky as\n\t  long as RHEL is shipping 2.6.32.  With this change on my IVB\n\t  machine PAPI_read() cost went from mean cycles  : 932.158549\n\t  std deviation: 358.752461 to mean cycles  : 896.642644       std\n\t  deviation:    305.568268\n\t* src/components/perf_event/pe_libpfm4_events.c,\n\t  src/components/perf_event/pe_libpfm4_events.h,\n\t  src/components/perf_event/perf_event.c: perf_event: remove\n\t  _pe_libpfm4_get_cidx() helper function  easier to explicitly pass\n\t  it to the libpfm4 event code\n\t* src/components/perf_event/perf_event_lib.h: perf_event: wakeup_mode\n\t  field is no longer used\n\t* src/components/perf_event/perf_event.c: perf_event: remove\n\t  WAKEUP_MODE_ defines  These date back to initial perf_event\n\t  support, but were never used.  Probably were meant in case advanced\n\t  sampling/profiling was ever implemented, but it wasn't.\n\t* src/components/perf_event/perf_event.c: perf_event.c: split\n\t  setup_mmap() to its own function  non-sampling events will need to\n\t  have mmap buffers when we move to rdpmc()\n\t* src/components/perf_event/perf_event.c: perf_event: rename\n\t  tune_up_fd to configure_fd_for_sampling  makes it a bit more clear\n\t  what is going on\n\t* src/components/perf_event/perf_event.c: perf_event: remove\n\t  extraneous whitespace\n\n2017-02-24  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/utils/cost.c: papi_cost: wasn't properly resetting the event\n\t  search after POSTFIX  This means some architectures could have\n\t  skipped the ADD/SUB test even though such events were available.\n\nWed Feb 22 01:16:42 2017 -0800  Stephane Eranian <eranian@gmail.com>\n\n\t* src/libpfm4/lib/events/intel_bdw_events.h,\n\t  src/libpfm4/lib/events/intel_skl_events.h,\n\t  src/libpfm4/lib/pfmlib_intel_rapl.c,\n\t  src/libpfm4/tests/validate_x86.c: Update libpfm4\\n\\nCurrent with\\n\n\t  commit 1bd352eef242f53e130c3b025bbf7881a5fb5d1e  update Intel RAPL\n\t  processor support  Added Kabylake, Skylake X  Added PSYS RAPL event\n\t  for Skylake client.\n\n2017-02-17  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/utils/cost.c: papi_cost: clear eventset before derived add test\n\t  we weren't clearing the eventset after the derived postfix test to\n\t  the add test was actually measuring two derived events.  This was\n\t  noticed on broadwell-ep where papi_cost would fail due to the lack\n\t  of enough counters to have both the postfix and add events at the\n\t  same time.\n\n2017-01-23  Asim YarKhan <yarkhan@icl.utk.edu>\n\n\t* RELEASENOTES.txt: Fixing the date in the RELEASENOTES file.\n",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.6.0-iweh6uy7qfzcgjj77nhy45ucjhpm2ow6/spack-src/src/threads.c": "/****************************/\n/* THIS IS OPEN SOURCE CODE */\n/****************************/\n\n/*\n* File:    threads.c\n* Author:  Philip Mucci\n*          mucci@cs.utk.edu\n* Mods:    Kevin London\n*          london@cs.utk.edu\n*/\n\n/* This file contains thread allocation and bookkeeping functions */\n\n#include \"papi.h\"\n#include \"papi_internal.h\"\n#include \"papi_vector.h\"\n#include \"papi_memory.h\"\n#include <string.h>\n#include <unistd.h>\n\n/*****************/\n/* BEGIN GLOBALS */\n/*****************/\n\n/* The following globals get initialized and cleared by:\n   extern int _papi_hwi_init_global_threads(void);\n   extern int _papi_hwi_shutdown_thread(ThreadInfo_t *thread); */\n\n/* list of threads, gets initialized to master process with TID of getpid() */\n\nvolatile ThreadInfo_t *_papi_hwi_thread_head;\n\n/* If we have TLS, this variable ALWAYS points to our thread descriptor. It's like magic! */\n\n#if defined(HAVE_THREAD_LOCAL_STORAGE)\nTHREAD_LOCAL_STORAGE_KEYWORD ThreadInfo_t *_papi_hwi_my_thread;\n#endif\n\n/* Function that returns and unsigned long thread identifier */\n\nunsigned long ( *_papi_hwi_thread_id_fn ) ( void );\n\n/* Function that sends a signal to other threads */\n\n#ifdef ANY_THREAD_GETS_SIGNAL\nint ( *_papi_hwi_thread_kill_fn ) ( int, int );\n#endif\n\n/*****************/\n/*  END  GLOBALS */\n/*****************/\n\nstatic int\nlookup_and_set_thread_symbols( void )\n{\n#if defined(ANY_THREAD_GETS_SIGNAL)\n\tint retval;\n\tchar *error_ptc = NULL, *error_ptk = NULL;\n\tvoid *symbol_ptc = NULL, *symbol_ptk = NULL, *handle = NULL;\n\n\thandle = dlopen( NULL, RTLD_LAZY );\n\tif ( handle == NULL ) {\n\t\tPAPIERROR( \"Error from dlopen(NULL, RTLD_LAZY): %d %s\", errno,\n\t\t\t\t   dlerror(  ) );\n\t\treturn ( PAPI_ESYS );\n\t}\n\n\tsymbol_ptc = dlsym( handle, \"pthread_self\" );\n\tif ( symbol_ptc == NULL ) {\n\t\terror_ptc = dlerror(  );\n\t\tTHRDBG( \"dlsym(%p,pthread_self) returned NULL: %s\\n\",\n\t\t\t\t( error_ptc ? error_ptc : \"No error, NULL symbol!\" ) );\n\t}\n\n\tsymbol_ptk = dlsym( handle, \"pthread_kill\" );\n\tif ( symbol_ptk == NULL ) {\n\t\terror_ptk = dlerror(  );\n\t\tTHRDBG( \"dlsym(%p,pthread_kill) returned NULL: %s\\n\",\n\t\t\t\t( error_ptk ? error_ptk : \"No error, NULL symbol!\" ) );\n\t}\n\n\tdlclose( handle );\n\n\tif ( !( ( _papi_hwi_thread_kill_fn && _papi_hwi_thread_id_fn ) ||\n\t\t\t( !_papi_hwi_thread_kill_fn && !_papi_hwi_thread_id_fn ) ) )\n\t\treturn ( PAPI_EMISC );\n\n\t_papi_hwi_thread_kill_fn = ( int ( * )( int, int ) ) symbol_ptk;\n\t_papi_hwi_thread_id_fn = ( unsigned long ( * )( void ) ) symbol_ptc;\n#endif\n\treturn ( PAPI_OK );\n}\n\nstatic ThreadInfo_t *\nallocate_thread( int tid )\n{\n\tThreadInfo_t *thread;\n\tint i;\n\n\t/* The Thread EventSet is special. It is not in the EventSet list, but is pointed\n\t   to by each EventSet of that particular thread. */\n\n\tthread = ( ThreadInfo_t * ) papi_malloc( sizeof ( ThreadInfo_t ) );\n\tif ( thread == NULL )\n\t\treturn ( NULL );\n\tmemset( thread, 0x00, sizeof ( ThreadInfo_t ) );\n\n\tthread->context =\n\t\t( hwd_context_t ** ) papi_malloc( sizeof ( hwd_context_t * ) *\n\t\t\t\t\t\t\t\t\t\t  ( size_t ) papi_num_components );\n\tif ( !thread->context ) {\n\t\tpapi_free( thread );\n\t\treturn ( NULL );\n\t}\n\n\tthread->running_eventset =\n\t\t( EventSetInfo_t ** ) papi_malloc( sizeof ( EventSetInfo_t * ) *\n\t\t\t\t\t\t\t\t\t\t   ( size_t ) papi_num_components );\n\tif ( !thread->running_eventset ) {\n\t\tpapi_free( thread->context );\n\t\tpapi_free( thread );\n\t\treturn ( NULL );\n\t}\n\n\tfor ( i = 0; i < papi_num_components; i++ ) {\n\t\tthread->context[i] =\n\t\t\t( void * ) papi_malloc( ( size_t ) _papi_hwd[i]->size.context );\n\t\tthread->running_eventset[i] = NULL;\n\t\tif ( thread->context[i] == NULL ) {\n\t\t\tfor ( i--; i >= 0; i-- )\n\t\t\t\tpapi_free( thread->context[i] );\n\t\t\tpapi_free( thread->context );\n\t\t\tpapi_free( thread );\n\t\t\treturn ( NULL );\n\t\t}\n\t\tmemset( thread->context[i], 0x00,\n\t\t\t\t( size_t ) _papi_hwd[i]->size.context );\n\t}\n\n\tif ( _papi_hwi_thread_id_fn ) {\n           thread->tid = ( *_papi_hwi_thread_id_fn ) (  );\n\t}\n\telse {\n\t   thread->tid = ( unsigned long ) getpid(  );\n\t}\n\n\tthread->allocator_tid=thread->tid;\n\n\tif (tid == 0 ) {\n\t}\n\telse {\n\t  thread->tid=tid;\n\t}\n\n\tTHRDBG( \"Allocated thread %ld at %p, allocator: %ld\\n\", thread->tid, \n\t\tthread,\n\t\tthread->allocator_tid );\n\n\treturn thread;\n}\n\nstatic void\nfree_thread( ThreadInfo_t ** thread )\n{\n\tint i;\n\tTHRDBG( \"Freeing thread %ld at %p\\n\", ( *thread )->tid, *thread );\n\n\tfor ( i = 0; i < papi_num_components; i++ ) {\n\t\tif ( ( *thread )->context[i] )\n\t\t\tpapi_free( ( *thread )->context[i] );\n\t}\n\n\tif ( ( *thread )->context )\n\t\tpapi_free( ( *thread )->context );\n\n\tif ( ( *thread )->running_eventset )\n\t\tpapi_free( ( *thread )->running_eventset );\n\n\tmemset( *thread, 0x00, sizeof ( ThreadInfo_t ) );\n\tpapi_free( *thread );\n\t*thread = NULL;\n}\n\nstatic void\ninsert_thread( ThreadInfo_t * entry, int tid )\n{\n\t_papi_hwi_lock( THREADS_LOCK );\n\n\tif ( _papi_hwi_thread_head == NULL ) {\t/* 0 elements */\n\t\tTHRDBG( \"_papi_hwi_thread_head is NULL\\n\" );\n\t\tentry->next = entry;\n\t} else if ( _papi_hwi_thread_head->next == _papi_hwi_thread_head ) {\t/* 1 elements */\n\t\tTHRDBG( \"_papi_hwi_thread_head was thread %ld at %p\\n\",\n\t\t\t\t_papi_hwi_thread_head->tid, _papi_hwi_thread_head );\n\t\t_papi_hwi_thread_head->next = entry;\n\t\tentry->next = ( ThreadInfo_t * ) _papi_hwi_thread_head;\n\t} else {\t\t\t\t /* 2+ elements */\n\n\t\tTHRDBG( \"_papi_hwi_thread_head was thread %ld at %p\\n\",\n\t\t\t\t_papi_hwi_thread_head->tid, _papi_hwi_thread_head );\n\t\tentry->next = _papi_hwi_thread_head->next;\n\t\t_papi_hwi_thread_head->next = entry;\n\t}\n\n\t_papi_hwi_thread_head = entry;\n\n\tTHRDBG( \"_papi_hwi_thread_head now thread %ld at %p\\n\",\n\t\t\t_papi_hwi_thread_head->tid, _papi_hwi_thread_head );\n\n\t_papi_hwi_unlock( THREADS_LOCK );\n\n#if defined(HAVE_THREAD_LOCAL_STORAGE)\n\t/* Don't set the current local thread if we are a fake attach thread */\n        if (tid==0) {\n\t   _papi_hwi_my_thread = entry;\n\t   THRDBG( \"TLS for thread %ld is now %p\\n\", entry->tid,\n\t\t\t_papi_hwi_my_thread );\n\t}\n#else\n\t( void ) tid;\n#endif\n}\n\nstatic int\nremove_thread( ThreadInfo_t * entry )\n{\n\tThreadInfo_t *tmp = NULL, *prev = NULL;\n\n\t_papi_hwi_lock( THREADS_LOCK );\n\n\tTHRDBG( \"_papi_hwi_thread_head was thread %ld at %p\\n\",\n\t\t\t_papi_hwi_thread_head->tid, _papi_hwi_thread_head );\n\n\t/* Find the preceding element and the matched element,\n\t   short circuit if we've seen the head twice */\n\n\tfor ( tmp = ( ThreadInfo_t * ) _papi_hwi_thread_head;\n\t\t  ( entry != tmp ) || ( prev == NULL ); tmp = tmp->next ) {\n\t\tprev = tmp;\n\t}\n\n\tif ( tmp != entry ) {\n\t\tTHRDBG( \"Thread %ld at %p was not found in the thread list!\\n\",\n\t\t\t\tentry->tid, entry );\n\t\treturn ( PAPI_EBUG );\n\t}\n\n\t/* Only 1 element in list */\n\n\tif ( prev == tmp ) {\n\t\t_papi_hwi_thread_head = NULL;\n\t\ttmp->next = NULL;\n\t\tTHRDBG( \"_papi_hwi_thread_head now NULL\\n\" );\n\t} else {\n\t\tprev->next = tmp->next;\n\t\t/* If we're removing the head, better advance it! */\n\t\tif ( _papi_hwi_thread_head == tmp ) {\n\t\t\t_papi_hwi_thread_head = tmp->next;\n\t\t\tTHRDBG( \"_papi_hwi_thread_head now thread %ld at %p\\n\",\n\t\t\t\t\t_papi_hwi_thread_head->tid, _papi_hwi_thread_head );\n\t\t}\n\t\tTHRDBG( \"Removed thread %p from list\\n\", tmp );\n\t}\n\n\t_papi_hwi_unlock( THREADS_LOCK );\n\n#if defined(HAVE_THREAD_LOCAL_STORAGE)\n\t_papi_hwi_my_thread = NULL;\n\tTHRDBG( \"TLS for thread %ld is now %p\\n\", entry->tid,\n\t\t\t_papi_hwi_my_thread );\n#endif\n\n\treturn PAPI_OK;\n}\n\nint\n_papi_hwi_initialize_thread( ThreadInfo_t ** dest, int tid )\n{\n\tint retval;\n\tThreadInfo_t *thread;\n\tint i;\n\n\tif ( ( thread = allocate_thread( tid  ) ) == NULL ) {\n\t\t*dest = NULL;\n\t\treturn PAPI_ENOMEM;\n\t}\n\n\t/* Call the component to fill in anything special. */\n\n\tfor ( i = 0; i < papi_num_components; i++ ) {\n\t    if (_papi_hwd[i]->cmp_info.disabled) continue;\n\t    retval = _papi_hwd[i]->init_thread( thread->context[i] );\n\t    if ( retval ) {\n\t       free_thread( &thread );\n\t       *dest = NULL;\n\t       return retval;\n\t    }\n\t}\n\n\tinsert_thread( thread, tid );\n\n\t*dest = thread;\n\treturn PAPI_OK;\n}\n\n#if defined(ANY_THREAD_GETS_SIGNAL)\n\n/* This is ONLY defined for systems that enable ANY_THREAD_GETS_SIGNAL\n   since we must forward signals sent to non-PAPI threads.\n\n   This is NOT compatible with thread local storage, since to broadcast\n   the signal, we need a list of threads. */\n\nint\n_papi_hwi_broadcast_signal( unsigned int mytid )\n{\n\tint i, retval, didsomething = 0;\n\tvolatile ThreadInfo_t *foo = NULL;\n\n\t_papi_hwi_lock( THREADS_LOCK );\n\n\tfor ( foo = _papi_hwi_thread_head; foo != NULL; foo = foo->next ) {\n\t\t/* xxxx Should this be hardcoded to index 0 or walk the list or what? */\n\t\tfor ( i = 0; i < papi_num_components; i++ ) {\n\t\t\tif ( ( foo->tid != mytid ) && ( foo->running_eventset[i] ) &&\n\t\t\t\t ( foo->running_eventset[i]->\n\t\t\t\t   state & ( PAPI_OVERFLOWING | PAPI_MULTIPLEXING ) ) ) {\n\t\t\t\t/* xxxx mpx_info inside _papi_mdi_t _papi_hwi_system_info is commented out.\n\t\t\t\t   See papi_internal.h for details. The multiplex_timer_sig value is now part of that structure */\n\t\t\t  THRDBG(\"Thread %ld sending signal %d to thread %ld\\n\",mytid,foo->tid,\n\t\t\t\t  (foo->running_eventset[i]->state & PAPI_OVERFLOWING ? _papi_hwd[i]->cmp_info.hardware_intr_sig : _papi_os_info.itimer_sig));\n\t\t\t  retval = (*_papi_hwi_thread_kill_fn)(foo->tid, \n\t\t\t\t  (foo->running_eventset[i]->state & PAPI_OVERFLOWING ? _papi_hwd[i]->cmp_info.hardware_intr_sig : _papi_os_info.itimer_sig));\n\t\t\t  if (retval != 0)\n\t\t\t\treturn(PAPI_EMISC);\n\t\t\t}\n\t\t}\n\t\tif ( foo->next == _papi_hwi_thread_head )\n\t\t  break;\n\t}\n\t_papi_hwi_unlock( THREADS_LOCK );\n\n\treturn ( PAPI_OK );\n}\n#endif\n\n/* This is undefined for systems that enable ANY_THREAD_GETS_SIGNAL\n   since we always must enable threads for safety. */\n\nint\n_papi_hwi_set_thread_id_fn( unsigned long ( *id_fn ) ( void ) )\n{\n#if !defined(ANY_THREAD_GETS_SIGNAL)\n\t/* Check for multiple threads still in the list, if so, we can't change it */\n\n\tif ( _papi_hwi_thread_head->next != _papi_hwi_thread_head )\n\t\treturn ( PAPI_EINVAL );\n\n\t/* We can't change the thread id function from one to another, \n\t   only NULL to non-NULL and vice versa. */\n\n\tif ( ( id_fn != NULL ) && ( _papi_hwi_thread_id_fn != NULL ) )\n\t\treturn ( PAPI_EINVAL );\n\n\t_papi_hwi_thread_id_fn = id_fn;\n\n\tTHRDBG( \"Set new thread id function to %p\\n\", id_fn );\n\n\tif ( id_fn )\n\t\t_papi_hwi_thread_head->tid = ( *_papi_hwi_thread_id_fn ) (  );\n\telse\n\t\t_papi_hwi_thread_head->tid = ( unsigned long ) getpid(  );\n\n\tTHRDBG( \"New master tid is %ld\\n\", _papi_hwi_thread_head->tid );\n#else\n\tTHRDBG( \"Skipping set of thread id function\\n\" );\n#endif\n\n\treturn PAPI_OK;\n}\n\n\nstatic int _papi_hwi_thread_free_eventsets(long tid) {\n\n   EventSetInfo_t *ESI;\n   ThreadInfo_t *master;\n   DynamicArray_t *map = &_papi_hwi_system_info.global_eventset_map;\n   int i;\n\n   master = _papi_hwi_lookup_thread( tid );\n\n   _papi_hwi_lock( INTERNAL_LOCK );\n\n   for( i = 0; i < map->totalSlots; i++ ) {\n      ESI = map->dataSlotArray[i];\n      if ( ( ESI ) && (ESI->master!=NULL) ) {\n\n\t if ( ESI->master == master ) {\n\t    THRDBG(\"Attempting to remove %d from tid %ld\\n\",ESI->EventSetIndex,tid);\n\n\t    /* Code copied from _papi_hwi_remove_EventSet(ESI);      */\n\t    _papi_hwi_free_EventSet( ESI );\n\t    map->dataSlotArray[i] = NULL;\n\t    map->availSlots++;\n\t    map->fullSlots--;\n\t }\n      }\n   }\n\n   _papi_hwi_unlock( INTERNAL_LOCK );\n\n   return PAPI_OK;\n}\n\n\nint\n_papi_hwi_shutdown_thread( ThreadInfo_t * thread, int force_shutdown )\n{\n\tint retval = PAPI_OK;\n\tunsigned long tid;\n\tint i, failure = 0;\n\n\tif ( _papi_hwi_thread_id_fn )\n\t\ttid = ( *_papi_hwi_thread_id_fn ) (  );\n\telse\n\t\ttid = ( unsigned long ) getpid(  );\n\n        THRDBG(\"Want to shutdown thread %ld, alloc %ld, our_tid: %ld\\n\",\n\t       thread->tid,\n\t       thread->allocator_tid,\n\t       tid);\n\n\tif ((thread->tid==tid) || ( thread->allocator_tid == tid ) || force_shutdown) {\n\n                _papi_hwi_thread_free_eventsets(tid);\n\n\t\tremove_thread( thread );\n\t\tTHRDBG( \"Shutting down thread %ld at %p\\n\", thread->tid, thread );\n\t\tfor( i = 0; i < papi_num_components; i++ ) {\n\t\t   if (_papi_hwd[i]->cmp_info.disabled) continue;\n\t\t   retval = _papi_hwd[i]->shutdown_thread( thread->context[i]);\n\t\t   if ( retval != PAPI_OK ) failure = retval;\n\t\t}\n\t\tfree_thread( &thread );\n\t\treturn ( failure );\n\t}\n\n\tTHRDBG( \"Skipping shutdown thread %ld at %p, thread %ld not allocator!\\n\",\n\t\t\tthread->tid, thread, tid );\n\treturn PAPI_EBUG;\n}\n\n/* THESE MUST BE CALLED WITH A GLOBAL LOCK */\n\nint\n_papi_hwi_shutdown_global_threads( void )\n{\n        int err,num_threads,i;\n\tThreadInfo_t *tmp,*next;\n\tunsigned long our_tid;\n\n\ttmp = _papi_hwi_lookup_thread( 0 );\n\n\tif ( tmp == NULL ) {\n\t   THRDBG( \"Did not find my thread for shutdown!\\n\" );\n\t   err = PAPI_EBUG;\n\t}\n\telse {\n\t   our_tid=tmp->tid;\n\t   (void)our_tid;\n\n\t   THRDBG(\"Shutting down %ld\\n\",our_tid);\n\n\t   err = _papi_hwi_shutdown_thread( tmp, 1 );\n\n\t   /* count threads */\n\t   tmp = ( ThreadInfo_t * ) _papi_hwi_thread_head;\n\t   num_threads=0;\n\t   while(tmp!=NULL) {\n\t      num_threads++;\n\t      if (tmp->next==_papi_hwi_thread_head) break;\n\t      tmp=tmp->next;\n\t   }\n\n\t   /* Shut down all threads allocated by this thread */\n\t   /* Urgh it's a circular list where we removed in the loop  */\n\t   /* so the only sane way to do it is get a count in advance */\n\t   tmp = ( ThreadInfo_t * ) _papi_hwi_thread_head;\n\n\t   for(i=0;i<num_threads;i++) {\n\n\t      next=tmp->next;\n\n\t      THRDBG(\"looking at #%d %ld our_tid: %ld alloc_tid: %ld\\n\",\n\t\t     i,tmp->tid,our_tid,tmp->allocator_tid);\n\n\t\t THRDBG(\"Also removing thread %ld\\n\",tmp->tid);\n\t         err = _papi_hwi_shutdown_thread( tmp, 1 );\n\n\t      tmp=next;\n\n\t   }\n\t}\n\n\n#ifdef DEBUG\n\tif ( ISLEVEL( DEBUG_THREADS ) ) {\n\t\tif ( _papi_hwi_thread_head ) {\n\t\t\tTHRDBG( \"Thread head %p still exists!\\n\", _papi_hwi_thread_head );\n\t\t}\n\t}\n#endif\n\n#if defined(HAVE_THREAD_LOCAL_STORAGE)\n\t_papi_hwi_my_thread = NULL;\n#endif\n\t_papi_hwi_thread_head = NULL;\n\t_papi_hwi_thread_id_fn = NULL;\n#if defined(ANY_THREAD_GETS_SIGNAL)\n\t_papi_hwi_thread_kill_fn = NULL;\n#endif\n\n\treturn err;\n}\n\nint\n_papi_hwi_init_global_threads( void )\n{\n\tint retval;\n\tThreadInfo_t *tmp;\n\n\t_papi_hwi_lock( GLOBAL_LOCK );\n\n#if defined(HAVE_THREAD_LOCAL_STORAGE)\n\t_papi_hwi_my_thread = NULL;\n#endif\n\t_papi_hwi_thread_head = NULL;\n\t_papi_hwi_thread_id_fn = NULL;\n#if defined(ANY_THREAD_GETS_SIGNAL)\n\t_papi_hwi_thread_kill_fn = NULL;\n#endif\n\n\tretval = _papi_hwi_initialize_thread( &tmp , 0);\n\tif ( retval == PAPI_OK ) {\n\t   retval = lookup_and_set_thread_symbols(  );\n\t}\n\n\t_papi_hwi_unlock( GLOBAL_LOCK );\n\n\treturn ( retval );\n}\n\nint\n_papi_hwi_gather_all_thrspec_data( int tag, PAPI_all_thr_spec_t * where )\n{\n\tint didsomething = 0;\n\tThreadInfo_t *foo = NULL;\n\n\t_papi_hwi_lock( THREADS_LOCK );\n\n\tfor ( foo = ( ThreadInfo_t * ) _papi_hwi_thread_head; foo != NULL;\n\t\t  foo = foo->next ) {\n\t\t/* If we want thread ID's */\n\t\tif ( where->id )\n\t\t\tmemcpy( &where->id[didsomething], &foo->tid,\n\t\t\t\t\tsizeof ( where->id[didsomething] ) );\n\n\t\t/* If we want data pointers */\n\t\tif ( where->data )\n\t\t\twhere->data[didsomething] = foo->thread_storage[tag];\n\n\t\tdidsomething++;\n\n\t\tif ( ( where->id ) || ( where->data ) ) {\n\t\t\tif ( didsomething >= where->num )\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif ( foo->next == _papi_hwi_thread_head )\n\t\t\tbreak;\n\t}\n\n\twhere->num = didsomething;\n\t_papi_hwi_unlock( THREADS_LOCK );\n\n\treturn ( PAPI_OK );\n\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.6.0-iweh6uy7qfzcgjj77nhy45ucjhpm2ow6/spack-src/src/configure.in": "# Process this file with autoconf to produce a configure script.\n# File: configure.in\n\n# cross compile sample\n# ARCH=mips CC=scgcc ./configure --with-arch=mips --host=mips64el-gentoo-linux-gnu- --with-ffsll --with-libpfm4 --with-perf-events --with-virtualtimer=times --with-walltimer=gettimeofday --with-tls=__thread --with-CPU=mips\n# cross compiling should work differently...\n\nAC_PREREQ(2.59)\nAC_INIT(PAPI, 5.6.0.0, ptools-perfapi@icl.utk.edu)\nAC_CONFIG_SRCDIR([papi.c])\nAC_CONFIG_HEADER([config.h])\n\nAC_DEFUN([AS_AC_EXPAND],\n         [EXP_VAR=[$1]\n          FROM_VAR=[$2]\n          prefix_save=$prefix\n          exec_prefix_save=$exec_prefix\n          if test \"x$prefix\" = \"xNONE\"; then\n            prefix=\"$ac_default_prefix\"\n          fi\n          if test \"x$exec_prefix\" = \"xNONE\"; then\n            exec_prefix=$prefix\n          fi\n          full_var=\"$FROM_VAR\"\n          while true; \n            do\n              new_full_var=\"`eval echo $full_var`\"\n              if test \"x$new_full_var\" = \"x$full_var\"; then \n                break; \n              fi\n              full_var=$new_full_var\n            done\n          full_var=$new_full_var\n          AC_DEFINE_UNQUOTED([$1], \"$full_var\")\n          prefix=$prefix_save\n          exec_prefix=$exec_prefix_save ])\n\nAC_MSG_CHECKING(for architecture)\nAC_ARG_WITH(arch,\n\t       [  --with-arch=<arch>\t\tSpecify architecture (uname -m)],\n\t       [arch=$withval],\n\t       [arch=`uname -m`])\nAC_MSG_RESULT($arch)\n\nAC_ARG_WITH(bitmode,\n            [  --with-bitmode=<32,64>\t\tSpecify bit mode of library],\n            [bitmode=$withval])\n\nAC_MSG_CHECKING(for OS)\nAC_ARG_WITH(OS,\n           [  --with-OS=<os>       \t\tSpecify operating system],\n           [OS=$withval],\n\t       [OS=\"`uname | tr '[A-Z]' '[a-z]'`\"\n            if (test \"$OS\" = \"SunOS\" || test \"$OS\" = \"sunos\"); then\n              OS=solaris\n            fi ])\nAC_MSG_RESULT($OS)\n\nAC_MSG_CHECKING(for OS version)\nAC_ARG_WITH(OSVER,\n           [  --with-OSVER=<ver>\t\tSpecify operating system version],\n           [OSVER=$withval],\n\t       [if test \"$OS\" != \"bgp\" -o \"$OS\" != \"bgq\"; then\n              OSVER=\"`uname -r`\"\n            fi ])\nAC_MSG_RESULT($OSVER)\n\nAC_MSG_CHECKING(for perf_event workaround level)\nAC_ARG_WITH(assumed_kernel,\n\t\t[  --with-assumed-kernel=<ver>\tAssume kernel version is <ver> for purposes of workarounds],\n\t\t[assumed_kernel=$withval; CFLAGS=\"$CFLAGS -DASSUME_KERNEL=\\\\\\\"$with_assumed_kernel\\\\\\\"\"],\n                [assumed_kernel=\"autodetect\"]\n\t\t)\t\t\nAC_MSG_RESULT($assumed_kernel)\n\nAC_MSG_CHECKING([for if MIC should be used])\n\t\tAC_ARG_WITH(mic,\n\t\t\t\t\t\t[ --with-mic To compile for Intel MIC ],\n\t\t\t\t\t\t[MIC=yes\n\t\t\t\t\t\ttls=__thread\n\t\t\t\t\t\tvirtualtimer=cputime_id\n\t\t\t\t\t\tperf_events=yes\n\t\t\t\t\t\twalltimer=clock_realtime_hr\n\t\t\t\t\t\tffsll=no\n\t\t\t\t\t\tcross_compiling=yes\n\t\t\t\t\t\tarch=k1om],\n\t\t\t\t\t\t[MIC=no])\nAC_MSG_RESULT($MIC)\nAC_SUBST(MIC)\n\nCFLAGS=\"$CFLAGS -g\"\n#If not set, set FFLAGS to null to prevent AC_PROG_F77 from defaulting it to -g -O2\nif test \"x$FFLAGS\" = \"x\"; then\n  FFLAGS=\"\"\nfi\nOPTFLAGS=\"-O2\" \nTOPTFLAGS=\"-O1\" \nAC_PROG_CC([xlc icc gcc cc])\nAC_PROG_F77([xlf ifort gfortran f95 f90 f77])\nif test \"x$F77\" = \"x\"; then\n   F77=\nfi\nAC_CHECK_PROG( [MPICC], mpicc, [mpicc], [])\n\n# Lets figure out what CC actually is...\n# Used in later checks to set compiler specific options\nif `$CC -V 2>&1 | grep '^Intel(R) C' >/dev/null 2>&1` ; then\n\tCC_COMMON_NAME=\"icc\"\nelif `$CC -v 2>&1 | grep 'gcc version' >/dev/null 2>&1` ; then\n\tCC_COMMON_NAME=\"gcc\"  \nelif `$CC -qversion 2>&1 | grep 'IBM XL C' >/dev/null 2>&1`; then\n\tCC_COMMON_NAME=\"xlc\"\nelse\n\tCC_COMMON_NAME=\"unknown\"\nfi\n\n#prevent icc warnings about overriding optimization settings set by AC_PROG_CC\n# remark #869: parameter was never referenced \n# remark #271: trailing comma is nonstandard\nif test \"$CC_COMMON_NAME\" = \"icc\"; then\n  CFLAGS=\"$CFLAGS -diag-disable 188,869,271\"\n  if test \"$MIC\" = \"yes\"; then\n     CC=\"$CC -mmic -fPIC\"\n  fi\nfi\n\nif test \"$F77\" = \"ifort\" -a \"$MIC\" = \"yes\"; then\n  F77=\"$F77 -mmic -fPIC\"\nfi\n\nAC_PROG_AWK\nAC_PROG_CPP\nAC_PROG_LN_S\nAC_PROG_MAKE_SET\nAC_PROG_RANLIB   \nAC_GNU_SOURCE\nAC_HEADER_STDC\nAC_C_INLINE\nAC_HEADER_TIME\nAC_CHECK_HEADERS([sys/time.h c_asm.h intrinsics.h mach/mach_time.h sched.h])\nAC_CHECK_FUNCS([gethrtime read_real_time time_base_to_time clock_gettime mach_absolute_time sched_getcpu])\n\n#\n# Check if the system provides dl* symbols without -ldl, and if not,\n# check for -ldl existance.\n#\n\nAC_MSG_CHECKING([for dlopen and dlerror symbols in base system])\nAC_TRY_LINK([#include <dlfcn.h>],\n\t[void *p = dlopen (\"\", 0); char *c = dlerror();],\n\t[dlsymbols_in_base=\"yes\"], [dlsymbols_in_base=\"no\"])\nif test \"${dlsymbols_in_base}\" = \"yes\"; then\n\tAC_MSG_RESULT([found])\n\tLDL=\"\"\nelse\n\tAC_MSG_RESULT([not found])\n\tAC_MSG_CHECKING([for dlopen and dlerror symbols in -ldl])\n\tSAVED_LIBS=${LIBS}\n\tLIBS=\"${LIBS} -ldl\"\n\tAC_TRY_LINK([#include <dlfcn.h>],\n\t\t[void *p = dlopen (\"\", 0); char *c = dlerror();],\n\t\t[has_ldl=\"yes\"], [has_ldl=\"no\"])\n\tLIBS=${SAVED_LIBS}\n\tif test \"${has_ldl}\" = \"yes\" ; then\n\t\tAC_MSG_RESULT([found])\n  \tLDL=\"-ldl\"\n\telse\n\t\tAC_MSG_ERROR([cannot find dlopen and dlerror symbols neither in the base system libraries nor in -ldl])\n\tfi\nfi\nAC_SUBST(LDL)\n        \n    \nif test \"$OS\" = \"CLE\"; then\n  virtualtimer=times\n  tls=__thread\n  walltimer=cycle\n  ffsll=yes\n  cross_compiling=yes\n  STATIC=\"-static\"\n  # _rtc is only defined when using the Cray compiler\n  AC_MSG_CHECKING([for _rtc intrinsic])\n  rtc_ok=yes\n  AC_TRY_LINK([#ifdef HAVE_INTRINSICS_H\n               #include <intrinsics.h>\n               #endif], [_rtc()], [AC_DEFINE(HAVE__RTC,1,[Define for _rtc() intrinsic.])], \n              [rtc_ok=no\n               AC_DEFINE(NO_RTC_INTRINSIC,1,[Define if _rtc() is not found.])])\n  AC_MSG_RESULT($rtc_ok)\nelif test \"$OS\" = \"bgp\"; then\n  CC=powerpc-bgp-linux-gcc \n  F77=powerpc-bgp-linux-gfortran\n  walltimer=cycle\n  virtualtimer=perfctr\n  tls=no\n  ffsll=yes\n  cross_compiling=yes\nelif test \"$OS\" = \"bgq\"; then\n  AC_ARG_WITH(bgpm_installdir,\n              [  --with-bgpm_installdir=<path> Specify the installation path of BGPM],\n              [BGPM_INSTALL_DIR=$withval\n              CFLAGS=\"$CFLAGS -I$withval\"],\n              [AC_MSG_ERROR([BGQ CPU component requires installation path of BGPM (see --with-bgpm_installdir)])])\n  bitmode=64\n  tls=no\nelif test \"$OS\" = \"linux\"; then\n  if test \"$arch\" = \"ppc64\" -o \"$arch\" = \"x86_64\"; then\n    if test \"$bitmode\" = \"64\" -a \"$libdir\" = '${exec_prefix}/lib'; then\n      libdir='${exec_prefix}/lib64'\n    fi\n  fi\nelif test \"$OS\" = \"solaris\"; then\n  AC_CHECK_TYPE([hrtime_t],\n                [AC_DEFINE(HAVE_HRTIME_T, 1, [Define if hrtime_t is defined in <sys/time.h>])],[],\n                [#if HAVE_SYS_TIME_H\n                 #include <sys/time.h>\n                 #endif])\n  if test \"x$AR\" = \"x\"; then\n    AR=/usr/ccs/bin/ar\n  fi\n\nfi\n\nif test \"x$AR\" = \"x\"; then\n  AR=ar\nfi\n\nif test \"$cross_compiling\" = \"yes\" ; then\n  AC_MSG_CHECKING(for native compiler for header generation)\n  AC_ARG_WITH(nativecc,\n\t         [  --with-nativecc=<path>\t\tSpecify native C compiler for header generation ],\n\t         [nativecc=$withval],\n\t         [nativecc=gcc])\n  AC_MSG_RESULT($nativecc)\nfi\n\nAC_ARG_WITH(tests,\n        \t[  --with-tests=<ctests,ftests,\"ctests ftests\">\t\tSpecify which tests to run on install ],\n        \t[tests=$withval],\n        \t[tests=\"ctests ftests\"]) \n\nAC_MSG_CHECKING(for debug build)\nAC_ARG_WITH(debug,\n            [  --with-debug=<yes,memory,no>\t\tBuild a debug version, debug version plus memory tracker or none ],\n            [debug=$withval])\nif test \"$debug\" = \"yes\"; then\n  if test \"$CC_COMMON_NAME\" = \"gcc\"; then\n    CFLAGS=\"$CFLAGS -g3\"\n  fi\n  OPTFLAGS=\"-O0\"\n  PAPICFLAGS+=\" -DDEBUG -DPAPI_NO_MEMORY_MANAGEMENT\" \nelif test \"$debug\" = \"memory\"; then\n  if test \"$CC_COMMON_NAME\" = \"gcc\"; then\n    CFLAGS=\"$CFLAGS -g3\"\n  fi\n  OPTFLAGS=\"-O0\"\n  PAPICFLAGS+=\" -DDEBUG\" \nelse\n  PAPICFLAGS+=\"-DPAPI_NO_MEMORY_MANAGEMENT\" \t\t\t\nfi\nAC_MSG_RESULT($debug)\n\nif test \"$CC_COMMON_NAME\" = \"gcc\"; then\n  gcc_version=`gcc -v 2>&1 | tail -n 1 | awk '{printf $3}'`\n  major=`echo $gcc_version | sed 's/\\([[^.]][[^.]]*\\).*/\\1/'`\n  minor=`echo $gcc_version | sed 's/[[^.]][[^.]]*.\\([[^.]][[^.]]*\\).*/\\1/'`\n  if (test \"$major\" -ge 4 || test \"$major\" = 3 -a \"$minor\" -ge 4); then\n    CFLAGS+=\" -Wextra\"\n  else\n    CFLAGS+=\" -W\"\n  fi\n# -Wextra => -Woverride-init on gcc >= 4.2\n# This issues a warning (error under -Werror) for some libpfm4 code. \n\tAC_MSG_CHECKING( for -Wno-override-init)\n\t\toldcflags=\"$CFLAGS\"\n\t\tCFLAGS+=\" -Wall -Wextra -Werror -Wno-override-init\"\n\t\tAC_COMPILE_IFELSE([AC_LANG_SOURCE( \n\t\t\t\t\t\t[ struct A { int x; int y; };\n\t\t\t\t\t\tint main(void) { struct A a = {.x = 0, .y = 0, .y = 5 }; return a.x; }\n\t\t\t\t\t\t])], \n\t\t\t\t\t\t[HAVE_NO_OVERRIDE_INIT=1],\n\t\t\t\t\t\t[HAVE_NO_OVERRIDE_INIT=0] )\n\t\tCFLAGS=\"$oldcflags\"\nAC_MSG_RESULT($HAVE_NO_OVERRIDE_INIT)\n\nfi\nAC_MSG_CHECKING(for CPU type)\nAC_ARG_WITH(CPU,\n            [  --with-CPU=<cpu>\t\tSpecify CPU type],\n            [CPU=$withval\n             case \"$CPU\" in\n               core|core2|i7|atom|p4|p3|opteron|athlon)\n                   MISCSRCS=\"$MISCSRCS x86_cpuid_info.c\" \n             esac],\n\t        [case \"$OS\" in\n               aix)\n                 CPU=\"`/usr/sbin/lsattr -E -l proc0 | grep type | cut -d '_' -f 2 | cut -d ' ' -f 1 | tr '[A-Z]' '[a-z]'`\"\n                 if test \"$CPU\" = \"\"; then\n                   CPU=\"`/usr/sbin/lsattr -E -l proc1 | grep type | cut -d '_' -f 2 | cut -d ' ' -f 1 | tr '[A-Z]' '[a-z]'`\"\n                 fi ;;\n\t       freebsd)\n                   family=`uname -m`\n\n\t\t   if test \"$family\" = \"amd64\"; then\n                      MISCSRCS=\"$MISCSRCS x86_cpuid_info.c\" \n\n\t\t   elif test \"$family\" = \"i386\"; then\n                      MISCSRCS=\"$MISCSRCS x86_cpuid_info.c\" \n\t\t   fi ;;\n\n\t       darwin)\n                   family=`uname -m`\n\n                   MISCSRCS=\"$MISCSRCS x86_cpuid_info.c\" \n\n\t\t   ;;\n\n               linux)\n                   family=`uname -m`\n\n\t\t   if test \"$family\" = \"x86_64\"; then\n                      MISCSRCS=\"$MISCSRCS x86_cpuid_info.c\" \n\t\t      CPU=\"x86\"\n\n\t\t   elif test \"$family\" = \"i686\"; then\n                      MISCSRCS=\"$MISCSRCS x86_cpuid_info.c\" \n\t\t      CPU=\"x86\"\n\n                   elif test \"$family\" = \"ppc64\"; then\n                     CPU_info=\"`cat /proc/cpuinfo | grep cpu | cut -d: -f2 | cut -d' ' -f2 | sed '2,$d'`\"\n                     case \"$CPU_info\" in\n                       PPC970*) CPU=\"PPC970\";;\n                       POWER5)  CPU=\"POWER5\";;\n                       POWER5+) CPU=\"POWER5+\";;\n                       POWER6)  CPU=\"POWER6\";;\n                       POWER7)  CPU=\"POWER7\";;\n                     esac\n\t           fi ;;\n               solaris)\n                 AC_CHECK_HEADER([libcpc.h],\n                                 [CFLAGS=\"$CFLAGS -lcpc\"\n                                  AC_TRY_RUN([#include <stdlib.h>\n                                              #include <libcpc.h> \n                                              int main() {\n                                              // Check for libcpc 2\n                                              if(CPC_VER_CURRENT == 2) \n                                                exit(0);\n                                              exit(1);\n                                              } ], \n                                             [cpc_version=2], \n                                             [cpc_version=0])],\n                                 [AC_MSG_ERROR([libcpc is needed for running PAPI on Solaris]) ])\n                 processor=`uname -p`\n                 machinetype=`uname -m`\n                 if test \"$processor\" = \"sparc\"; then\n                   if test \"$machinetype\" = \"sun4u\"; then\n                     CPU=ultra\n                     AC_CHECK_LIB([cpc], [cpc_take_sample], [], \n                                  [AC_MSG_ERROR([libcpc.a is needed on Solaris, install SUNWcpc]) ])\n                   elif test \"$machinetype\" = \"sun4v\"; then\n                     CPU=niagara2\n                     if test \"$cpc_version\" != \"2\"; then\n                       AC_MSG_ERROR([libcpc2 needed for Niagara 2])\n                     fi\n                   else\n                     AC_MSG_ERROR([$machinetype not supported])\n                   fi\n                 else\n                   AC_MSG_ERROR([Only SPARC processors are supported on Solaris])\n                 fi ;;\n               bgp)\n\t             CPU=bgp ;;\n\t\t\t   bgq)\n\t             CPU=bgq ;;\n               esac ])\nAC_MSG_RESULT($CPU)\nAC_DEFINE_UNQUOTED(CPU,$CPU,[cpu type])\n\n# First set pthread-mutexes based on arch                                       \ncase $arch in\n  aarch64|arm*)\n    pthread_mutexes=yes\n    CFLAGS=\"$CFLAGS -DUSE_PTHREAD_MUTEXES\"\n    echo \"forcing use of pthread mutexes... \" >&6\n  ;;\nesac\n\n\nAC_ARG_WITH(pthread-mutexes,\n              [  --with-pthread-mutexes\t\tSpecify use of pthread mutexes rather than custom PAPI locks],\n              [pthread_mutexes=yes\n\t      CFLAGS=\"$CFLAGS -DUSE_PTHREAD_MUTEXES\"\n\t      ])\n\n  AC_ARG_WITH(ffsll,\n\t          [  --with-ffsll\t\tSpecify use of the ffsll() function ],\n\t          [ffsll=$withval],\n\t          [if test \"$cross_compiling\" = \"yes\" ; then\n                 AC_MSG_ERROR([ffsll must be specified for cross compile])\n\t\t       fi\n               didcheck=1\n               AC_CHECK_FUNC(ffsll,[ffsll=yes],[ffsll=no]) ])\n               if test \"$ffsll\" = \"yes\" ; then\n                 AC_DEFINE(HAVE_FFSLL, 1, This platform has the ffsll() function)\n               fi\nif test \"$didcheck\" != \"1\"; then\n  AC_MSG_CHECKING(for ffsll)\n  if test \"$ffsll\" = \"yes\" ; then\n    AC_DEFINE(HAVE_FFSLL, 1, This platform has the ffsll() function)\n  fi\n  AC_MSG_RESULT($ffsll)\nfi\n\nAC_MSG_CHECKING(for working gettid)\nAC_LINK_IFELSE([AC_LANG_SOURCE([#include <sys/types.h>\n                main() { pid_t a = gettid(); }])],\n               [AC_MSG_RESULT(yes)\n                AC_DEFINE(HAVE_GETTID, 1, [Full gettid function])],\n               [AC_MSG_RESULT(no)\n                AC_MSG_CHECKING(for working syscall(SYS_gettid))\n                AC_LINK_IFELSE([AC_LANG_SOURCE([#include <sys/types.h>\n                                #include <sys/syscall.h>\n                                main() { pid_t a = syscall(SYS_gettid); }])],\n                               [AC_MSG_RESULT(yes)\n                                AC_DEFINE(HAVE_SYSCALL_GETTID, 1, [gettid syscall function])],\n                               [AC_MSG_RESULT(no)]) ])\n\nAC_ARG_WITH(walltimer,\n            [  --with-walltimer=<gettimeofday,mmtimer,clock_realtime_hr,clock_realtime,cycle>\t\tSpecify realtime timer ],\n            [walltimer=$withval],\n            [if test \"$cross_compiling\" = \"yes\" ; then\n               AC_MSG_ERROR([walltimer must be specified for cross compile])\n             fi\n             AC_MSG_CHECKING(for working MMTIMER)\n             AC_TRY_RUN([#include <unistd.h>\n                         #include <fcntl.h>\n                         #include <errno.h>\n                         #include <stdlib.h>\n                         #include <sys/ioctl.h>\n                         #include <linux/mmtimer.h>\n                         #ifndef MMTIMER_FULLNAME\n                         #define MMTIMER_FULLNAME \"/dev/mmtimer\"\n                         #endif\n                         int main() {\n                           int offset;\n                           int fd;\n                           if((fd = open(MMTIMER_FULLNAME, O_RDONLY)) == -1) \n                             exit(1);\n                           if ((offset = ioctl(fd, MMTIMER_GETOFFSET, 0)) < 0) \n                             exit(1);\n                           close(fd);\n                           exit(0);\n                         } ],\n                        [walltimer=\"mmtimer\"\n\t                     AC_MSG_RESULT(yes)],\n                        [AC_MSG_RESULT(no)\n                         AC_MSG_CHECKING(for working CLOCK_REALTIME_HR POSIX 1b timer)\n                         AC_TRY_RUN([#include <unistd.h>\n                                     #include <stdlib.h>\n                                     #include <stdio.h>\n                                     #include <time.h>\n                                     #include <syscall.h>\n                                     main() {\n                                       struct timespec t1, t2;\n                                       double seconds;\n                                       if (syscall(__NR_clock_gettime,CLOCK_REALTIME_HR,&t1) == -1) exit(1);\n                                         sleep(1);\n                                       if (syscall(__NR_clock_gettime,CLOCK_REALTIME_HR,&t2) == -1) exit(1);\n                                         seconds = ((double)t2.tv_sec + (double)t2.tv_nsec/1000000000.0) - ((double)t1.tv_sec + (double)t1.tv_nsec/1000000000.0);\n                                       if (seconds > 1.0)\n                                         exit(0);\n                                       else\n                                         exit(1);\n                                     } ],\n                                    [walltimer=\"clock_realtime_hr\"\n\t                                 AC_MSG_RESULT(yes)],\n                                    [AC_MSG_RESULT(no)\n                                     AC_MSG_CHECKING(for working CLOCK_REALTIME POSIX 1b timer)\n                                     AC_TRY_RUN([#include <unistd.h>\n                                                 #include <stdlib.h>\n                                                 #include <stdio.h>\n                                                 #include <time.h>\n                                                 #include <syscall.h>\n                                                 main() {\n                                                   struct timespec t1, t2;\n                                                   double seconds;\n                                                   if (syscall(__NR_clock_gettime,CLOCK_REALTIME,&t1) == -1) exit(1);\n                                                     sleep(1);\n                                                   if (syscall(__NR_clock_gettime,CLOCK_REALTIME,&t2) == -1) exit(1);\n                                                     seconds = ((double)t2.tv_sec + (double)t2.tv_nsec/1000000000.0) - ((double)t1.tv_sec + (double)t1.tv_nsec/1000000000.0);\n                                                   if (seconds > 1.0)\n                                                     exit(0);\n                                                   else\n                                                     exit(1);\n                                                 } ],\n                                                [walltimer=\"clock_realtime\"\n\t                                             AC_MSG_RESULT(yes)\t],\n                                                [walltimer=\"cycle\"\n\t                                             AC_MSG_RESULT(no)]) ]) ])  ])\nAC_MSG_CHECKING(for which real time clock to use)\nif test \"$walltimer\" = \"gettimeofday\"; then\n  AC_DEFINE(HAVE_GETTIMEOFDAY, 1, [Normal gettimeofday timer])\nelif test \"$walltimer\" = \"mmtimer\"; then\n  AC_DEFINE(HAVE_MMTIMER, 1, [Altix memory mapped global cycle counter])\n  altix=\"-DALTIX\"\nelif test \"$walltimer\" = \"clock_realtime_hr\"; then\n  AC_DEFINE(HAVE_CLOCK_GETTIME, 1, [POSIX 1b clock])\n  AC_DEFINE(HAVE_CLOCK_GETTIME_REALTIME_HR, 1, [POSIX 1b realtime HR clock])\nelif test \"$walltimer\" = \"clock_realtime\"; then\n  AC_DEFINE(HAVE_CLOCK_GETTIME, 1, [POSIX 1b clock])\n  AC_DEFINE(HAVE_CLOCK_GETTIME_REALTIME, 1, [POSIX 1b realtime clock])\nelif test \"$walltimer\" = \"cycle\"; then\n  AC_DEFINE(HAVE_CYCLE, 1, [Native access to a hardware cycle counter])\nelse\n  AC_MSG_ERROR([Unknown value for walltimer])\nfi\nAC_MSG_RESULT($walltimer)\n\nSAVED_LIBS=$LIBS\nSAVED_LDFLAGS=$LDFLAGS\nSAVED_CFLAGS=$CFLAGS\nLIBS=\"\"\nLDFLAGS=\"\"\nCFLAGS=\"-pthread\"\n\nAC_ARG_WITH(tls,\n              [  --with-tls=<keyword>\t\tThis platform supports thread local storage with a keyword ],\n              [tls=$withval],\n              [if test \"$cross_compiling\" = \"yes\" ; then\n                 AC_MSG_ERROR([tls must be specified for cross compile])\n               fi\n               AC_MSG_CHECKING(for working __thread)\n               AC_TRY_RUN([#include <pthread.h>\n                           #include <unistd.h>\n                           extern __thread int i;\n                           static int res1, res2;\n                           void thread_main (void *arg) {\n                             i = (int)arg;\n                             sleep (1);\n                             if ((int)arg == 1)\n\t\t                       res1 = (i == (int)arg);\n                             else\n\t\t                       res2 = (i == (int)arg);\n                           }\n\t                       __thread int i;\n                           int main () {\n                             pthread_t t1, t2;\n                             i = 5;\n                             pthread_create (&t1, NULL, thread_main, (void *)1);\n                             pthread_create (&t2, NULL, thread_main, (void *)2);\n                             pthread_join (t1, NULL);\n                             pthread_join (t2, NULL);\n                             return !(res1 + res2 == 2);\n                           } ], \n                          [AC_MSG_RESULT(yes)\n\t                       tls=\"__thread\"], \n                          [AC_MSG_RESULT(no)\n                           tls=\"no\" ])\n               if test \"$OS\" = \"linux\"; then\n                 if test \"x$tls\" = \"x__thread\"; then\n                   # On some linux distributions, TLS works in executables, but linking against\n                   # a shared library containing TLS fails with: undefined reference to `__tls_get_addr'\n                   rm -f conftest.c conftest.so conftest\n                   echo \"static __thread int foo; void main () { foo = 5; }\" > conftest.c\n                   gcc -fPIC --shared -o conftest.so conftest.c > /dev/null 2>&1\n                   gcc -o conftest conftest.so > /dev/null 2>&1\n                     if test ! -f conftest; then\n                       AC_MSG_WARN([Disabling usage of __thread.]);\n                       tls=\"no\"\n                     fi\n                   rm -f conftest.c conftest.so conftest\n                 fi\n               fi])\nAC_MSG_CHECKING(for high performance thread local storage)\nif test \"$tls\" = \"no\"; then\n  NOTLS=\"-DNO_TLS\"\nelif test \"x$tls\" != \"x\"; then\n  if test \"$tls\" = \"yes\"; then\n    tls=\"__thread\"\n  fi\n  NOTLS=\"-DUSE_COMPILER_TLS\"\n  AC_DEFINE_UNQUOTED(HAVE_THREAD_LOCAL_STORAGE,$tls,[Keyword for per-thread variables])\nfi\nAC_MSG_RESULT($tls)\n\nAC_ARG_WITH(virtualtimer,\n              [  --with-virtualtimer=<clock_thread_cputime_id,times,proc,getrusage,perfctr>\t\tSpecify per-thread virtual timer ],\n              [virtualtimer=$withval],\n              [if test \"$cross_compiling\" = \"yes\" ; then\n                 AC_MSG_ERROR([virtualtimer must be specified for cross compile])\n               fi\n               AC_MSG_CHECKING(for working CLOCK_THREAD_CPUTIME_ID POSIX 1b timer)\n               AC_TRY_RUN([#include <pthread.h>\n                           #include <sys/signal.h>\n                           #include <sys/times.h>\n                           #include <assert.h>\n                           #include <stdio.h>\n                           #include <sys/types.h>\n                           #include <unistd.h>\n                           #include <sys/unistd.h>\n                           #include <syscall.h>\n                           #include <stdlib.h>\n                           #if !defined( SYS_gettid )\n                           #define SYS_gettid 1105\n                           #endif\n                           struct timespec threadone = { 0, 0 };\n                           struct timespec threadtwo = { 0, 0 };\n                           pthread_t threadOne, threadTwo;\n                           volatile int done = 0;\n  \n                           int gettid() {\n                             return syscall( SYS_gettid );\n                           }\n  \n                           void *doThreadOne( void * v ) {\n                             while (!done)\n\t                           sleep(1);\n                             if (syscall(__NR_clock_gettime,CLOCK_THREAD_CPUTIME_ID,&threadone) == -1) {\n                               perror(\"clock_gettime(CLOCK_THREAD_CPUTIME_ID)\");\n                               exit(1);\n                             }\n                             return 0;\n                           } \n  \n                           void *doThreadTwo( void * v ) {\n                             long i, j = 0xdeadbeef;     \n                             for( i = 0; i < 0xFFFFFFF; ++i ) { j = j ^ i; }\n  \n                             if (syscall(__NR_clock_gettime,CLOCK_THREAD_CPUTIME_ID,&threadtwo) == -1) {\n                               perror(\"clock_gettime(CLOCK_THREAD_CPUTIME_ID)\");\n                               exit(1);\n                             }        \n                             done = 1;\n\t                         return j;\n                           } \n  \n                           int main( int argc, char ** argv ) {\n                             int status = pthread_create( & threadOne, NULL, doThreadOne, NULL );\n                             assert( status == 0 );\n                             status = pthread_create( & threadTwo, NULL, doThreadTwo, NULL );\n                             assert( status == 0 );  \n                             status = pthread_join( threadTwo, NULL );\n                             assert( status == 0 );\n                             status = pthread_join( threadOne, NULL );\n                             assert( status == 0 );\n                             if ((threadone.tv_sec != threadtwo.tv_sec) || (threadone.tv_nsec != threadtwo.tv_nsec))\n                               exit(0);\n                             else {\t\n                               fprintf(stderr,\"T1 %ld %ld T2 %ld %ld\\n\",threadone.tv_sec,threadone.tv_nsec,threadtwo.tv_sec,threadtwo.tv_nsec);\n\t                           exit(1); \n                             }\n                           } ], \n                          [AC_MSG_RESULT(yes)\n                           virtualtimer=\"clock_thread_cputime_id\"], \n                          [AC_MSG_RESULT(no)\n                           # *** Checks for working per thread timer***\n                           AC_MSG_CHECKING(for working per-thread times() timer)\n                           AC_TRY_RUN([#include <pthread.h>\n                                       #include <sys/signal.h>\n                                       #include <sys/times.h>\n                                       #include <assert.h>\n                                       #include <stdio.h>\n                                       #include <sys/types.h>\n                                       #include <unistd.h>\n                                       #include <sys/unistd.h>\n                                       #include <syscall.h>\n                                       #include <stdlib.h>\n                                       #if !defined( SYS_gettid )\n                                       #define SYS_gettid 1105\n                                       #endif\n                                       long threadone = 0, threadtwo = 0;\n                                       pthread_t threadOne, threadTwo;\n                                       volatile int done = 0;\n  \n                                       int gettid() {\n                                         return syscall( SYS_gettid );\n                                       } \n                                       int doThreadOne( void * v ) {\n                                         struct tms tm;\n                                         int status;\n                                         while (!done)\n\t                                       sleep(1);\n                                         status = times( & tm );\n                                         assert( status != -1 );\n                                         threadone = tm.tms_utime;\n                                         return 0;\n                                       }   \n                                       int doThreadTwo( void * v ) {\n                                         struct tms tm;\n                                         long i, j = 0xdeadbeef;\n                                         int status;\n                                         for( i = 0; i < 0xFFFFFFF; ++i ) { j = j ^ i; }\n                                         status = times( & tm );\n                                         assert( status != -1 );\n                                         threadtwo = tm.tms_utime;\n                                         done = 1;\n\t                                     return j;\n                                       } \n                                       int main( int argc, char ** argv ) {\n                                         int status = pthread_create( & threadOne, NULL, doThreadOne, NULL );\n                                         assert( status == 0 );\n                                         status = pthread_create( & threadTwo, NULL, doThreadTwo, NULL );\n                                         assert( status == 0 );  \n                                         status = pthread_join( threadTwo, NULL );\n                                         assert( status == 0 );\n                                         status = pthread_join( threadOne, NULL );\n                                         assert( status == 0 );\n\t                                     return (threadone == threadtwo);\n                                       } ],\n                                      [AC_MSG_RESULT(yes)\n\t                                   virtualtimer=\"times\"],\n                                      [AC_MSG_RESULT(no)\n\t                                   virtualtimer=\"default\"]) ]) ])\nLDFLAGS=$SAVED_LDFLAGS\nCFLAGS=$SAVED_CFLAGS\nLIBS=$SAVED_LIBS\n\nAC_MSG_CHECKING(for which virtual timer to use)\ncase \"$virtualtimer\" in\n  times)\n    AC_DEFINE(HAVE_PER_THREAD_TIMES, 1, [Working per thread timer]) ;;\n  getrusage)\n    AC_DEFINE(HAVE_PER_THREAD_GETRUSAGE, 1, [Working per thread getrusage]) ;;\n  clock_thread_cputime_id)\n    AC_DEFINE(HAVE_CLOCK_GETTIME_THREAD, CLOCK_THREAD_CPUTIME_ID, [POSIX 1b per-thread clock]) ;;\n  proc|default|perfctr)\n    AC_DEFINE(USE_PROC_PTTIMER, 1, [Use /proc for per-thread times])\n    AC_DEFINE(USE_PERFCTR_PTTIMER, 1, [Use the perfctr virtual TSC for per-thread times]) ;;\nesac\nAC_MSG_RESULT($virtualtimer)\n\nif test \"$OS\" = \"aix\"; then\n  AC_ARG_WITH(pmapi,\n              [  --with-pmapi=<path>\t\tSpecify path of pmapi on aix system ],\n              [PMAPI=$withval],\n              [PMAPI=\"/usr/pmapi\"])\n  LIBS=\"-L$PMAPI/lib -lpmapi\"\n  CPPFLAGS=\"$CPPFLAGS -I$PMAPI/include\"\n  AC_CHECK_LIB([pmapi], [pm_initialize], \n               [PMINIT=\"-DPM_INITIALIZE\"], \n               [AC_CHECK_LIB([pmapi], [pm_init], \n                             [PMINIT=\"-DPM_INIT\"], \n                             [AC_MSG_ERROR([libpmapi.a not found, rerun configure with different flags]) ]) ])\nfi\n\nAC_MSG_CHECKING(for static user preset events)\nAC_ARG_WITH(static_user_events,\n\t\t  [ --with-static-user-events             Build with a static user events file.],\n\t\t  [STATIC_USER_EVENTS=$withval],\n\t\t  [STATIC_USER_EVENTS=no])\nif test \"$STATIC_USER_EVENTS\" = \"yes\"; then\n\tPAPICFLAGS+=\" -DSTATIC_USER_EVENTS\"\nfi\nAC_MSG_RESULT($STATIC_USER_EVENTS)\n\nAC_MSG_CHECKING(for static PAPI preset events)\nAC_ARG_WITH(static_papi_events,\n\t\t  [ --with-static-papi-events             Build with a static papi events file.],\n\t\t  [STATIC_PAPI_EVENTS=$withval],\n\t\t  [STATIC_PAPI_EVENTS=yes])\nif test \"$STATIC_PAPI_EVENTS\" = \"yes\"; then\n\tPAPICFLAGS+=\" -DSTATIC_PAPI_EVENTS_TABLE\"\nfi\nAC_MSG_RESULT($STATIC_PAPI_EVENTS)\n\nAC_MSG_CHECKING(for whether to build static library)\nAC_ARG_WITH(static_lib,\n            [  --with-static-lib=<yes,no>\t\tBuild a static library],\n            [static_lib=$withval],\n            [static_lib=yes])\nAC_MSG_RESULT($static_lib)\n\nAC_MSG_CHECKING(for whether to build shared library)\nAC_ARG_WITH(shared_lib,\n            [  --with-shared-lib=<yes,no>\t\tBuild a shared library],\n            [shared_lib=$withval],\n            [shared_lib=yes])\nAC_MSG_RESULT($shared_lib)\n\nif test \"$shared_lib\" = \"no\" -a \"$static_lib\" = \"no\"; then\n  AC_MSG_ERROR(Both shared and static libs are disabled)\nfi\n\nif test \"$shared_lib\" = \"yes\"; then\n  papiLIBS=\"shared\"\nfi\nif test \"$static_lib\" = \"yes\"; then\n  papiLIBS=\"$papiLIBS static\"\nfi\n\nAC_MSG_CHECKING(for static compile of tests and utilities)\nAC_ARG_WITH(static_tools,\n            [  --with-static-tools\t\tSpecify static compile of tests and utilities],\n            [STATIC=\"-static\"\n\t    AC_MSG_RESULT(yes)],\n\t    [AC_MSG_RESULT(no)])\n\nif test \"$static_lib\" = \"no\"; then\n   AC_MSG_ERROR(Building tests and utilities static but no static papi library to be built)\nfi\n\nAC_MSG_CHECKING(for linking with papi shared library of tests and utilities)\nAC_ARG_WITH(shlib_tools,\n\t        [  --with-shlib-tools\t\tSpecify linking with papi library of tests and utilities],\n \t        [shlib_tools=yes\n\t\tAC_MSG_RESULT(yes)],\n\t\t[shlib_tools=no\n\t\tAC_MSG_RESULT(no)])\n\nif test \"$shlib_tools\" = \"yes\"; then\n   if test \"$shared_lib\" != \"yes\"; then\t\n      AC_MSG_ERROR(Building static but specified shared linking for tests and utilities)\n   fi\n   if test \"$STATIC\" = \"-static\"; then\n      AC_MSG_ERROR([Building shared but specified static linking])\n   fi\n   LINKLIB='$(SHLIB)'\nelif test \"$shlib_tools\" = \"no\"; then\n   if test \"$static_lib\" != \"yes\"; then\n      AC_MSG_ERROR([Building shared but specified static linking for tests and utilities])\n   fi\n   LINKLIB='$(LIBRARY)'\t\nfi\n\n##################################################\n#          perfctr\n##################################################\nperfctr=0\nforce_perfctr=no\n\nAC_ARG_WITH(perfctr,\n            [  --with-perfctr\t\tSpecify perfctr as the performance interface ],\n\t    force_perfctr=yes\n            [user_specified_interface=perfctr\n\t     if test \"$arch\" != \"ppc64\"; then\n\t     perfctr=6\n\t     else\n\t     perfctr=7\n\t     fi],\n            [perfctr=0])\n\nif test \"$cross_compiling\" = \"no\" ; then\n  AC_CHECK_FILE(/sys/class/perfctr,[perfctr=7],[AC_CHECK_FILE(/dev/perfctr,[perfctr=6])])\nfi \n\nif test \"$perfctr\" != 0; then \n  pfm_incdir=\"libpfm-3.y/include/\"\n  AC_MSG_CHECKING(for perfctr version)\n  if test \"$perfctr\" = 7 -a \"$arch\" != \"ppc64\"; then\n    AC_MSG_ERROR([Perfctr 2.7.x only works on PPC64 machines. Patch kernel with 2.6.x.])\n  fi\n  AC_MSG_RESULT(2.$perfctr)\nfi\n\nAC_ARG_WITH(perfctr_root,\n            [  --with-perfctr-root=<path>\t\tSpecify path to source tree (for use by developers only) ],\n            [perfctr_root=$withval\n             user_specified_interface=perfctr])\nAC_ARG_WITH(perfctr_prefix,\n            [  --with-perfctr-prefix=<path>\t\tSpecify prefix to installed perfctr distribution ],\n            [perfctr_prefix=$withval\n             user_specified_interface=perfctr])\nAC_ARG_WITH(perfctr_incdir,\n           [  --with-perfctr-incdir=<path>\t\tSpecify directory of perfctr header files in non-standard location ],\n           [perfctr_incdir=$withval\n            user_specified_interface=perfctr])\nAC_ARG_WITH(perfctr_libdir,\n           [  --with-perfctr-libdir=<path>\t\tSpecify directory of perfctr library in non-standard location ],\n           [perfctr_libdir=$withval\n            user_specified_interface=perfctr])\n\nif test \"$perfctr\" != 0; then\n\n  dotest=0\n  if test \"x$perfctr_root\" != \"x\"; then\n    LIBS=\"-L$perfctr_root/usr.lib -lperfctr\"\n    CPPFLAGS=\"$CPPFLAGS -I$perfctr_root/usr.lib -I$perfctr_root/linux/include\"\n    dotest=1\n  elif test \"x$perfctr_prefix\" != \"x\"; then\n    LIBS=\"-L$perfctr_prefix/lib -lperfctr\"\n    CPPFLAGS=\"$CPPFLAGS -I$perfctr_prefix/include\"\n    perfctr_libdir=\"$perfctr_prefix/lib\"\n    perfctr_incdir=\"$perfctr_prefix/include\"\n    dotest=1\n  else\n    if test \"x$perfctr_libdir\" != \"x\"; then\n      LIBS=\"-L$perfctr_libdir -lperfctr\"\n      dotest=1\n    fi\n    if test \"x$perfctr_incdir\" != \"x\"; then\n      CPPFLAGS=\"-I$perfctr_incdir\"\n      dotest=1\n    fi\n  fi\n\n  if test \"$dotest\" = 1; then\n    AC_CHECK_LIB([perfctr], [vperfctr_open], \n                 [AC_CHECK_HEADERS([libperfctr.h], \n                                   [oCFLAGS=$CFLAGS\n\t                                CFLAGS=\"$CFLAGS -static\"\n\t                                AC_TRY_RUN([#include <stdlib.h>\n\t                                            #include \"libperfctr.h\"\n\t                                            int main() {\n\t\t                                          if ((PERFCTR_ABI_VERSION >> 24) != 5) \n                                                    exit(1); \n                                                  exit(0);\n\t                                            } ],\n                                                [perfctr=6],\n                                                [perfctr=7])\n\t                                CFLAGS=$oCFLAGS], \n                                    [AC_MSG_ERROR([libperfctr.h not found, rerun configure with different flags])])],\n                 [AC_MSG_ERROR([libperfctr.a not found, rerun configure with different flags]) ])\n  else\n    AC_DEFINE(HAVE_LIBPERFCTR_H,1,[perfctr header file])\n  fi\nfi\n\nuser_specified_interface=no\n##################################################\n#          perfmon\n##################################################\nold_pfmv2=n\nperfmon=0\nperfmon2=no\nforce_perfmon2=no\n\nAC_ARG_WITH(perfmon,\n            [  --with-perfmon=<x.y>\t\tSpecify perfmon as the performance interface and specify version],\n            [perfmon=$withval \n             user_specified_interface=perfmon\n\t     force_perfmon2=yes\n\t     pfm_incdir=\"libpfm-3.y/include\"\n             perfmon=`echo ${perfmon} | sed 's/^[ \\t]*//;s/[ \\t]*$//'`\n             perfmon=`echo ${perfmon} | grep -e '[[1-9]]\\.[[0-9]][[0-9]]*'`\n             if test \"x$perfmon\" = \"x\"; then\n               AC_MSG_ERROR(\"Badly formed perfmon version string\")\n             fi\n             perfmon=`echo ${perfmon} | sed 's/\\.//'`\n             if test $perfmon -gt 20; then\n               perfmon2=yes\n             fi\n             if test $perfmon -lt 25; then\n               old_pfmv2=y\n\t       PFMCFLAGS=\"-DPFMLIB_OLD_PFMV2\"\n             fi],\n            [perfmon=0\n\t         if test \"$cross_compiling\" = \"no\" ; then\n\t           AC_CHECK_FILE(/sys/kernel/perfmon/version,\n                             [perfmon=`cat /sys/kernel/perfmon/version`],\n                             [AC_CHECK_FILE(/proc/perfmon,\n                                            [perfmon=`cat /proc/perfmon | grep version | cut -d: -f2`],\n                                            [perfmon=0])])\n               if test \"$perfmon\" != 0; then\n\t         pfm_incdir=\"libpfm-3.y/include\"\n                 perfmon=`echo ${perfmon} | sed 's/^[ \\t]*//;s/[ \\t]*$//'`\n                 perfmon=`echo ${perfmon} | grep -e '[[1-9]]\\.[[0-9]][[0-9]]*'`\n                 perfmon=`echo ${perfmon} | sed 's/\\.//'`\n                 if test $perfmon -gt 20; then\n                   perfmon2=yes\n                 fi\n                 if test $perfmon -lt 25; then\n# must be y, not yes, or libpfm breaks\n                   old_pfmv2=\"y\"           \n                   PFMCFLAGS=\"-DPFMLIB_OLD_PFMV2\"\n                 fi\n               fi\n\t         fi])\n\n\nforce_pfm_incdir=no\n# default\n\nAC_ARG_WITH(pfm_root,\n           [  --with-pfm-root=<path>\t\tSpecify path to source tree (for use by developers only) ],\n           [pfm_root=$withval\n\t    pfm_incdir=$withval/include\n\t    pfm_libdir=$withval/lib])\nAC_ARG_WITH(pfm_prefix,\n           [  --with-pfm-prefix=<path>\t\tSpecify prefix to installed pfm distribution ],\n           [pfm_prefix=$withval\n\t    pfm_incdir=$pfm_prefix/include\n\t    pfm_libdir=$pfm_prefix/lib])\nAC_ARG_WITH(pfm_incdir,\n           [  --with-pfm-incdir=<path>\t\tSpecify directory of pfm header files in non-standard location ],\n           [pfm_incdir=$withval])\nAC_ARG_WITH(pfm_libdir,\n           [  --with-pfm-libdir=<path>\t\tSpecify directory of pfm library in non-standard location ],\n           [pfm_libdir=$withval])\n\n# if these are both empty, it means we haven't set either pfm_prefix or pfm_root\n# which would have set them. Thus it means that we set this to our included\n# libpfm4 library. Shame on the person that sets one but not the other.\n\nif test \"x$pfm_incdir\" = \"x\" -a \"x$pfm_libdir\" = \"x\"; then\n   pfm_root=\"libpfm4\"\n   pfm_incdir=\"libpfm4/include\"\n   pfm_libdir=\"libpfm4/lib\"\nfi\n\n##################################################\n#          Linux perf_event/perf_counter\n##################################################\n\nif test \"x$mic\" = \"xno\"; then\n       perf_events=no\nfi\n\nforce_perf_events=no\ndisable_uncore=yes\n\nAC_ARG_WITH(perf_events,\n              [  --with-perf-events\t\tSpecify use of Linux Performance Event (requires kernel 2.6.32 or greater)],\n              [force_perf_events=yes\n\t       user_specified_interface=pe])\n\n# RDPMC support\n\nAC_ARG_ENABLE(perfevent_rdpmc,\nAS_HELP_STRING([--enable-perfevent-rdpmc],\n\t\t[Enable userspace rdpmc instruction on perf_event, default: yes]),\n[case \"${enableval}\" in\n             yes) enable_perfevent_rdpmc=true ;;\n             no)  enable_perfevent_rpdmc=false ;;\n             *)   AC_MSG_ERROR([bad value ${enableval} for --enable-perfevent-rdpmc]) ;;\nesac],\n[enable_perfevent_rdpmc=true])\n\nif test \"$enable_perfevent_rdpmc\" = \"true\"; then\n\tPECFLAGS=\"$PECFLAGS -DUSE_PERFEVENT_RDPMC=1\"\nfi\n\n# Uncore support\nAC_ARG_WITH(pe_incdir,\n\t      [  --with-pe-incdir=<path>\t\tSpecify path to the correct perf header file],\n              [pe_incdir=$withval \n               force_perf_events=yes\n\t       user_specified_interface=pe],\n\t      [pe_incdir=$pfm_incdir/perfmon])\n\nAC_ARG_ENABLE(perf_event_uncore,\n\t\t[  --disable-perf-event-uncore\t\tDisable perf_event uncore component])\n\nAS_IF([test \"x$enable_perf_event_uncore\" != \"xno\"],[\n\tdisable_uncore=no\n])\n\n# Check for perf_event.h\n  if test \"$force_perf_events\" = \"yes\"; then\n\tperf_events=\"yes\"\n  fi\n  if test \"$cross_compiling\" = \"no\"; then \n\tAC_CHECK_FILE(/proc/sys/kernel/perf_event_paranoid,[\n\tAC_CHECK_FILE($pe_incdir/perf_event.h,perf_events=\"yes\")])\n  fi\n  if test \"$perf_events\" = \"yes\"; then\n      PECFLAGS=\"$PECFLAGS -DPEINCLUDE=\\\\\\\"$pe_incdir/perf_event.h\\\\\\\"\"\n  fi\n\n#\n# Sort out the choice of the user vs. what we detected\n#\n# MESSING WITH CFLAGS IS STUPID!\n#\nif test \"$user_specified_interface\" != \"no\"; then\n   if test \"$user_specified_interface\" = \"perfctr\"; then\n      perfmon=0\n      perf_events=\"no\"\n   else\n\tif test \"$user_specified_interface\" = \"perfmon\"; then\n\t   perfctr=0\n\t   perf_events=\"no\"\n\t   PAPICFLAGS+=\" $PFMCFLAGS\"\n\telse\n\t\tif test \"$user_specified_interface\" = \"pe\"; then\n\t\t\t   perfctr=0\n\t\t\t   perfmon=0\n\t\t\t   PAPICFLAGS+=\" $PECFLAGS\"\n\t\telse\n\t\t\tAC_MSG_ERROR(\"Unknown user_specified_interface=$user_specified_interface perfctr=$perfctr perfmon=$perfmon perfmon2=$perfmon2 perf-events=$perf_events\")\n\t\tfi\t\t\t\t\t\t\t\t \n\tfi\n   fi\nelse\n\tif test \"$perfmon\" != 0; then\n\t   PAPICFLAGS+=\" $PFMCFLAGS\"\n\tfi\n\tif test \"$perf_events\" = \"yes\"; then\n\t   PAPICFLAGS+=\" $PECFLAGS\"\n\tfi\nfi\n\n\n#\n# User has made no choice, so we default to the ordering below in the platform section, if\n# we detect more than one.\n#\n\n#\n# What does this next section do? It determines whether or not to run the tests for libpfm\n# based on the settings of pfm_root, pfm_prefix, pfm_incdir, pfm_libdir\n#\n\nif test \"$perfmon\" != 0 -o \"$perf_events\" = \"yes\"; then\n   # if prefix set, then yes\n   if test \"x$pfm_prefix\" != \"x\"; then\n      dotest=1\n   # if root not set and libdir set, then yes\n   elif test \"x$pfm_root\" = \"x\" -a \"x$pfm_libdir\" != \"x\"; then\n      dotest=1\n   else\n      dotest=0\n   fi\n  if test \"$dotest\" = 1; then\n    LIBS=\"-L$pfm_libdir -lpfm\"\n    CPPFLAGS=\"$CPPFLAGS -I$pfm_incdir\"\n    AC_CHECK_LIB([pfm], [pfm_initialize], \n                 [AC_CHECK_HEADERS([perfmon/pfmlib.h],\n                                   [if test \"$arch\" = \"ia64\"; then\n   \t\t                              AC_CHECK_HEADERS([perfmon/pfmlib_montecito.h])\n                                    fi\n   \t                                AC_CHECK_FUNC(pfm_get_event_description, \n                                                  [AC_DEFINE(HAVE_PFM_GET_EVENT_DESCRIPTION,1,[event description function])],[])\n   \t                                AC_CHECK_MEMBER(pfmlib_reg_t.reg_evt_idx, \n                                                    [AC_DEFINE(HAVE_PFM_REG_EVT_IDX,1,[old reg_evt_idx])],[],[#include \"perfmon/pfmlib.h\"])\n   \t                                AC_CHECK_MEMBER(pfmlib_output_param_t.pfp_pmd_count, \n                                                    [AC_DEFINE(HAVE_PFMLIB_OUTPUT_PFP_PMD_COUNT,1,[new pfmlib_output_param_t])],[],[#include \"perfmon/pfmlib.h\"])\n   \t                                AC_CHECK_MEMBER(pfm_msg_t.type, \n                                                    [AC_DEFINE(HAVE_PFM_MSG_TYPE,1,[new pfm_msg_t])],[],[#include \"perfmon/perfmon.h\"]) ], \n                                   [AC_MSG_ERROR([perfmon/pfmlib.h not found, rerun configure with different flags]) ]) ], \n                 [AC_MSG_ERROR([libpfm.a not found, rerun configure with different flags]) ])\n  else\n    AC_DEFINE(HAVE_PERFMON_PFMLIB_MONTECITO_H,1,[Montecito headers])\n    AC_DEFINE(HAVE_PFM_GET_EVENT_DESCRIPTION,1,[event description function])\n    AC_DEFINE(HAVE_PFMLIB_OUTPUT_PFP_PMD_COUNT,1,[new pfmlib_output_param_t])\n  fi\nfi\n\n##################################################\n#          Checking platform\n##################################################\nAC_MSG_CHECKING(platform)\ncase \"$OS\" in\n  aix)\n    MAKEVER=\"$OS\"-\"$CPU\" ;;\n  bgp)\n    MAKEVER=bgp ;;\n  bgq)\n    MAKEVER=bgq ;;\n  CLE)\n    if test \"$perfmon2\" = \"yes\"; then\n#  major_version=`echo $OSVER | sed 's/\\([[^.]][[^.]]*\\).*/\\1/'`\n#  minor_version=`echo $OSVER | sed 's/[[^.]][[^.]]*.\\([[^.]][[^.]]*\\).*/\\1/'`\n#  point_version=`echo $OSVER | sed -e 's/[[^.]][[^.]]*.[[^.]][[^.]]*.\\(.*\\)/\\1/' -e 's/[[^0-9]].*//'`\n#    if (test \"$major_version\" = 2 -a \"$minor_version\" = 6 -a \"$point_version\" -lt 31 -a \"$perfmon2\" != \"yes\" ); then\n       MAKEVER=\"$OS\"-perfmon2\n    else\n       MAKEVER=\"$OS\"-pe\n    fi ;;\n  freebsd)\n    MAKEVER=\"freebsd\"\n    LDFLAGS=\"-lpmc\"\n    # HWPMC driver is available for FreeBSD >= 6\n    FREEBSD_VERSION=`uname -r | cut -d'.' -f1`\n    if test \"${FREEBSD_VERSION}\" -lt 6 ; then\n      AC_MSG_ERROR([PAPI requires FreeBSD 6 or greater])\n    fi\n    # Determine if HWPMC module is on the kernel\n    dmesg | grep hwpmc 2> /dev/null > /dev/null\n    if test \"$?\" != \"0\" ; then\n      AC_MSG_ERROR([HWPMC module not found. (see INSTALL.TXT)])\n    fi\n    # Determine the number of counters\n    echo \"/* Automatically generated file by configure */\" > freebsd-config.h\n    echo \"#ifndef _FREEBSD_CONFIG_H_\" >> freebsd-config.h\n    echo \"#define _FREEBSD_CONFIG_H_\" >> freebsd-config.h\n    echo \"\" >> freebsd-config.h\n    AC_TRY_LINK([#include <unistd.h>\n                 #include <pmc.h>],\n                [int i = pmc_init();],\n                [pmc_pmc_init_linked=\"yes\"], [pmc_pmc_init_linked=\"no\"])\n    if test \"${pmc_init_linked}\" = \"no\" ; then\n      AC_MSG_ERROR([Failed to link hwpmc example])\n    fi\n    AC_TRY_RUN([#include <unistd.h>\n                #include <pmc.h>\n                int main() { \n                  const struct pmc_cpuinfo *info;\n                  if (pmc_init() < 0) return 0;\n                  if (pmc_cpuinfo (&info) < 0) return 0;\n                  return info->pm_npmc-1;\n                } ],\n               [ num_counters=\"0\" ], \n               [ num_counters=\"$?\"])\n    if test \"${num_counters}\" = \"0\" ; then\n      AC_MSG_ERROR([pmc_npmc info returned 0. Determine if the HWPMC module is loaded (see hwpmc(4))])\n    fi\n    echo \"#define HWPMC_NUM_COUNTERS ${num_counters}\" >> freebsd-config.h\n    echo \"\" >> freebsd-config.h\n    echo \"#endif\" >> freebsd-config.h ;;\n  linux)\n    if test \"$force_perf_events\" = \"yes\" ; then\n      MAKEVER=\"$OS\"-pe\n    elif test \"$force_perfmon2\" = \"yes\" ; then\n      MAKEVER=\"$OS\"-perfmon2\n    elif test \"$force_perfctr\" = \"yes\" ; then\n      MAKEVER=\"$OS\"-perfctr-x86\n      case \"$CPU\" in\n        itanium2|montecito)\n          if test \"$bitmode\" = \"32\"; then\n            AC_MSG_ERROR([The bitmode you specified is not supported])\n          fi\n\t  MAKEVER=\"$OS\"-pfm-\"$CPU\"\n\t  ;;\n        POWER5|POWER5+|POWER6|POWER7|PPC970)\n          MAKEVER=\"$OS\"-perfctr-\"$CPU\" ;;\n     esac\n    elif test \"$perf_events\" = \"yes\" ; then\n      MAKEVER=\"$OS\"-pe\n    elif test \"$perfmon2\" = \"yes\" ; then\n      MAKEVER=\"$OS\"-perfmon2\n    elif test \"$old_pfmv2\" = \"y\" ; then\n      MAKEVER=\"$OS\"-pfm-\"$CPU\"\n    elif test \"$perfctr\" != 0 ; then\n      case \"$CPU\" in\n        itanium2|montecito)\n          if test \"$bitmode\" = \"32\"; then\n            AC_MSG_ERROR([The bitmode you specified is not supported])\n          fi\n\t  MAKEVER=\"$OS\"-pfm-\"$CPU\"\n\t  ;;\n        x86)\n\t        MAKEVER=\"$OS\"-perfctr-x86 ;;\n        POWER5|POWER5+|POWER6|POWER7|PPC970)\n          MAKEVER=\"$OS\"-perfctr-\"$CPU\" ;;\n        *)\n          MAKEVER=\"$OS\"-generic ;;\n     esac\n    else\n      MAKEVER=\"$OS\"-generic\n    fi ;;\t   \n  solaris)\n    if test \"$bitmode\" = \"64\" -a \"`isainfo -v | grep \"64\"`\" = \"\"; then\n      AC_MSG_ERROR([The bitmode you specified is not supported])\n    fi\n    MAKEVER=\"$OS\"-\"$CPU\" ;;\n  darwin)\n    MAKEVER=\"$OS\" ;;\nesac\n\nAC_MSG_RESULT($MAKEVER)\nif test \"x$MAKEVER\" = \"x\"; then\n  AC_MSG_NOTICE(This platform is not supported so a generic build without CPU counters will be used)\n  MAKEVER=\"generic_platform\"\nfi \n\n##################################################\n#          Set build macros \n##################################################\nFILENAME=Makefile.inc\nSHOW_CONF=showconf\nCTEST_TARGETS=\"all\"\nFTEST_TARGETS=\"all\"\nLIBRARY=libpapi.a\nSHLIB='libpapi.so.AC_PACKAGE_VERSION'\nVLIB='libpapi.so.$(PAPIVER)'\nOMPCFLGS=-fopenmp\nCC_R='$(CC) -pthread'\nCC_SHR='$(CC) -fPIC -DPIC -shared -Wl,-soname -Wl,$(VLIB) -Xlinker \"-rpath\" -Xlinker \"$(LIBDIR)\"'\nif test \"$CC_COMMON_NAME\" = \"gcc\"; then\n\tif test \"$bitmode\" = \"32\"; then\n\t\tBITFLAGS=-m32\n\telif test \"$bitmode\" = \"64\"; then\n\t\tBITFLAGS=-m64\n\tfi\nfi\n\nOPTFLAGS=\"$OPTFLAGS\"\nPAPICFLAGS+=\" -D_REENTRANT -D_GNU_SOURCE $NOTLS\"\nCFLAGS=\"$CFLAGS $BITFLAGS\"\nif test \"$CC_COMMON_NAME\" = \"gcc\"; then\n\tCFLAGS=\"$CFLAGS -Wall\"\nfi\nFFLAGS=\"$CFLAGS $BITFLAGS $FFLAGS -Dlinux\"\n\n# OS Support\n\nif (test \"$OS\" = \"aix\"); then\n    OSFILESSRC=aix-memory.c\n    OSLOCK=aix-lock.h\n    OSCONTEXT=aix-context.h\nelif (test \"$OS\" = \"bgp\"); then\n    OSFILESSRC=linux-bgp-memory.c\n    OSLOCK=linux-bgp-lock.h\n    OSCONTEXT=linux-bgp-context.h\nelif (test \"$OS\" = \"bgq\"); then\n    OSFILESSRC=linux-bgq-memory.c\n    OSLOCK=linux-bgq-lock.h\n    OSCONTEXT=linux-context.h\nelif (test \"$OS\" = \"freebsd\"); then\n    OSFILESSRC=freebsd-memory.c\n    OSLOCK=\"freebsd-lock.h\"\n    OSCONTEXT=\"freebsd-context.h\"\nelif (test \"$OS\" = \"linux\"); then\n    OSFILESSRC=\"linux-memory.c linux-timer.c linux-common.c\"\n    OSFILESHDR=\"linux-memory.h linux-timer.h linux-common.h\"\n    OSLOCK=\"linux-lock.h\"\n    OSCONTEXT=\"linux-context.h\"\nelif (test \"$OS\" = \"solaris\"); then\n    OSFILESSRC=\"solaris-memory.c solaris-common.c\"\n    OSFILESHDR=\"solaris-memory.h solaris-common.h\"\n    OSLOCK=\"solaris-lock.h\"\n    OSCONTEXT=\"solaris-context.h\"\nelif (test \"$OS\" = \"darwin\"); then\n    OSFILESSRC=\"darwin-memory.c darwin-common.c\"\n    OSFILESHDR=\"darwin-memory.h darwin-common.h\"\n    OSLOCK=\"darwin-lock.h\"\n    OSCONTEXT=\"darwin-context.h\"\nfi\n\nOSFILESOBJ='$(OSFILESSRC:.c=.o)'\n\n\nif (test \"$MAKEVER\" = \"aix-power5\" || test \"$MAKEVER\" = \"aix-power6\" || test \"$MAKEVER\" = \"aix-power7\"); then\n  if test \"$bitmode\" = \"64\"; then\n    LIBRARY=libpapi64.a\n    SHLIB=libpapi64.so\n# By default AIX enforces a limit on heap space \n#( limiting the heap to share the same 256MB memory segment as stack )\n# changing the max data paramater moves the heap off the stack's memory segment\n    BITFLAGS='-q64 -bmaxdata:0x07000000000000'\n    ARG64=-X64\n  else\n# If the issue ever comes up, /dsa requires AIX v5.1 or higher\n# and the Large address-space model (-bmaxdata) requires v4.3 or later\n# see http://publib.boulder.ibm.com/infocenter/pseries/v5r3/topic/com.ibm.aix.genprogc/doc/genprogc/lrg_prg_support.htm#a179c11c5d\n    SHLIB=libpapi.so\n    BITFLAGS=\"-bmaxdata:0x80000000/dsa\"\n  fi\n\n  CPUCOMPONENT_NAME=aix\n  CPUCOMPONENT_C=aix.c\n  CPUCOMPONENT_OBJ=aix.o\n  VECTOR=_aix_vector\n  PAPI_EVENTS_CSV=\"papi_events.csv\"\n  MISCHDRS=\"aix.h components/perfctr_ppc/ppc64_events.h papi_events_table.h\"\n  MISCSRCS=\"aix.c\"\n  CFLAGS+='-qenum=4 -Icomponents/perfctr_ppc -DNO_VARARG_MACRO -D_AIX -D_$(CPU_MODEL) -DNEED_FFSLL -DARCH_EVTS=\\\"$(ARCH_EVENTS).h\\\" -DCOMP_VECTOR=_ppc64_vectors -DSTATIC_PAPI_EVENTS_TABLE'\n  FFLAGS+='-WF,-D_$(CPU_MODEL) -WF,-DARCH_EVTS=\\\"$(ARCH_EVENTS).h\\\"'\n  CFLAGS+='-I$(PMAPI)/include -Icomponents/perfctr_ppc -qmaxmem=-1 -qarch=$(cpu_option) -qtune=$(cpu_option) -qlanglvl=extended $(BITFLAGS)'\n  if test $debug != \"yes\"; then\n\tOPTFLAGS='-O3 -qstrict $(PMINIT)'\n  else\n\tOPTFLAGS='$(PMINIT)'\n  fi\n  SMPCFLGS=-qsmp\n  OMPCFLGS='-qsmp=omp'\n  LDFLAGS='-L$(PMAPI)/lib -lpmapi'\n  CC_R=xlc_r\n  CC=xlc\n  CC_SHR=\"xlc -G -bnoentry\"\n  AC_CHECK_PROGS( [MPICC], [mpicc mpcc], [])\n  F77=xlf\n  CPP='xlc -E $(CPPFLAGS)'\n  if test \"$MAKEVER\" = \"aix-power5\"; then\n    ARCH_EVENTS=power5_events\n    CPU_MODEL=POWER5\n    cpu_option=pwr5\n    DESCR=\"AIX 5.1.0 or greater with POWER5\"\n    if test \"$bitmode\" = \"64\"; then\n      DESCR=\"$DESCR 64 bit build\"\n    fi\n  elif test \"$MAKEVER\" = \"aix-power6\"; then\n    ARCH_EVENTS=power6_events\n    CPU_MODEL=POWER6\n    cpu_option=pwr6\n    DESCR=\"AIX 5.1.0 or greater with POWER6\"\n    CPPFLAGS=\"-qlanglvl=extended\"\n    if test \"$bitmode\" = \"64\"; then\n      DESCR=\"$DESCR 64 bit build\"\n    fi\n  elif test \"$MAKEVER\" = \"aix-power7\"; then\n    ARCH_EVENTS=power7_events\n    CPU_MODEL=POWER7\n    cpu_option=pwr7\n    DESCR=\"AIX 5.1.0 or greater with POWER7\"\n    CPPFLAGS=\"-qlanglvl=extended\"\n    if test \"$bitmode\" = \"64\"; then\n      DESCR=\"$DESCR 64 bit build\"\n    fi\n  fi\nelif test \"$MAKEVER\" = \"bgp\"; then\n  CPP=\"$CC -E\"\n    CPUCOMPONENT_NAME=linux-bgp\n    CPUCOMPONENT_C=linux-bgp.c\n    CPUCOMPONENT_OBJ=linux-bgp.o\n    VECTOR=_bgp_vectors\n    PAPI_EVENTS_CSV=\"papi_events.csv\"\n    MISCSRCS=\n    CFLAGS='-g -gdwarf-2 -O2 -Wall -I. -I$(BGP_SYSDIR)/arch/include -DCOMP_VECTOR=_bgp_vectors'\n    tests=\"$tests bgp_tests\"\n  SHOW_CONF=show_bgp_conf\n  BGP_SYSDIR=/bgsys/drivers/ppcfloor\n  BGP_GNU_LINUX_PATH='${BGP_SYSDIR}/gnu-linux'\n  LDFLAGS='-L$(BGP_SYSDIR)/runtime/SPI -lSPI.cna'\n  FFLAGS='-g -gdwarf-2 -O2 -Wall -I. -Dlinux'\n  OPTFLAGS=\"-g -Wall -O3\"\n  TOPTFLAGS=\"-g -Wall -O0\"\n  SHLIB=libpapi.so\n  DESCR=\"Linux for BlueGene/P\"\n  LIBS=static\n  CC_SHR='$(CC) -shared -Xlinker \"-soname\" -Xlinker \"$(SHLIB)\" -Xlinker \"-rpath\" -Xlinker \"$(LIBDIR)\"'\n  OMPCFLGS=\"\"\n\nelif test \"$MAKEVER\" = \"bgq\"; then\n  FILENAME=Rules.bgpm\n  VECTOR=_bgq_vectors\n  CPUCOMPONENT_NAME=linux-bgq\n  CPUCOMPONENT_C=linux-bgq.c\n  CPUCOMPONENT_OBJ=linux-bgq.o\n  PAPI_EVENTS_CSV=\"papi_events.csv\"\n  MISCSRCS=\"linux-bgq-common.c\"\n  OPTFLAGS=\"-g -Wall -O3\"\n  TOPTFLAGS=\"-g -Wall -O0\"\n  SHLIB=libpapi.so\n  DESCR=\"Linux for Blue Gene/Q\"\n  CC_SHR='$(CC) -fPIC -DPIC -shared -Wl,-soname -Wl,$(SHLIB) -Xlinker \"-rpath\" -Xlinker \"$(LIBDIR)\"'\n  OMPCFLGS=\"\"\n\nelif test \"$MAKEVER\" = \"CLE-perfmon2\"; then \n    FILENAME=Rules.perfmon2\n    CPUCOMPONENT_NAME=perfmon\n    CPUCOMPONENT_C=perfmon.c\n    CPUCOMPONENT_OBJ=perfmon.o\n    VECTOR=_papi_pfm_vector\n    PAPI_EVENTS_CSV=\"papi_events.csv\"\n  F77=gfortran\n  CFLAGS=\"$CFLAGS -D__crayxt\"\n  FFLAGS=\"\"\n\nelif test \"$MAKEVER\" = \"freebsd\"; then\n    CPUCOMPONENT_NAME=freebsd\n    CPUCOMPONENT_C=freebsd.c\n    CPUCOMPONENT_OBJ=freebsd.o\n    VECTOR=_papi_freebsd_vector\n    PAPI_EVENTS_CSV=\"freebsd_events.csv\"\n    MISCHDRS=\"freebsd/map-unknown.h freebsd/map.h freebsd/map-p6.h freebsd/map-p6-m.h freebsd/map-p6-3.h freebsd/map-p6-2.h freebsd/map-p6-c.h freebsd/map-k7.h freebsd/map-k8.h freebsd/map-p4.h freebsd/map-atom.h freebsd/map-core.h freebsd/map-core2.h freebsd/map-core2-extreme.h freebsd/map-i7.h freebsd/map-westme\\\nre.h\"\n    MISCSRCS=\"$MISCSRCS freebsd/map-unknown.c freebsd/map.c freebsd/map-p6.c freebsd/map-p6-m.c freebsd/map-p6-3.c freebsd/map-p6-2.c freebsd/map-p6-c.c freebsd/map-k7.c freebsd/map-k8.c freebsd/map-p4.c freebsd/map-atom.c freebsd/map-core.c freebsd/map-core2.c freebsd/map-core2-extreme.c freebsd/map-i7.c freebsd/map-westme\\\nre.c\"\n  DESCR=\"FreeBSD -over libpmc- \"\n  CFLAGS+=\" -I. -Ifreebsd -DPIC -fPIC\"\n  CC_SHR='$(CC) -shared -Xlinker \"-soname\" -Xlinker \"libpapi.so\" -Xlinker \"-rpath\" -Xlinker \"$(LIBDIR)\" -DPIC -fPIC -I. -Ifreebsd'\n\nelif test \"$MAKEVER\" = \"linux-generic\"; then\n    CPUCOMPONENT_NAME=linux-generic\n    CPUCOMPONENT_C=linux-generic.c\n    CPUCOMPONENT_OBJ=linux-generic.o\n    PAPI_EVENTS_CSV=\"papi_events.csv\"\n    VECTOR=_papi_dummy_vector\n\nelif test \"$MAKEVER\" = \"linux-pe\"; then\n    FILENAME=Rules.pfm4_pe\n    CPUCOMPONENT_NAME=perf_event \n    components=\"perf_event\"\n    if test \"$disable_uncore\" = \"no\"; then\n       components=\"$components perf_event_uncore\"\n    fi\n\nelif test \"$MAKEVER\" = \"linux-perfctr-x86\"; then\n    FILENAME=Rules.perfctr-pfm\n    CPUCOMPONENT_NAME=perfctr-x86\n    VERSION=2.6.x  \n    components=\"perfctr\"\n\nelif (test \"$MAKEVER\" = \"linux-perfctr-POWER5\" || test \"$MAKEVER\" = \"linux-perfctr-POWER5+\" || test \"$MAKEVER\" = \"linux-perfctr-POWER6\" || test \"$MAKEVER\" = \"linux-perfctr-POWER7\" || test \"$MAKEVER\" = \"linux-perfctr-PPC970\"); then\n    FILENAME=Rules.perfctr\n    CPUCOMPONENT_NAME=perfctr-ppc\n    VERSION=2.7.x\n    components=\"perfctr_ppc\"\n    CPU=ppc64\n    if test \"$MAKEVER\" = \"linux-perfctr-POWER5\"; then\n      CPU_MODEL=POWER5\n      ARCH_EVENTS=power5_events\n      ARCH_SPEC_EVTS=power5_events_map.c\n    elif test \"$MAKEVER\" = \"linux-perfctr-POWER5+\"; then\n      CPU_MODEL=POWER5p\n      ARCH_EVENTS=power5+_events\n      ARCH_SPEC_EVTS=power5+_events_map.c\n    elif test \"$MAKEVER\" = \"linux-perfctr-POWER6\"; then\n      CPU_MODEL=POWER6\n      ARCH_EVENTS=power6_events\n      ARCH_SPEC_EVTS=power6_events_map.c\n    elif test \"$MAKEVER\" = \"linux-perfctr-POWER7\"; then\n      CPU_MODEL=POWER7\n      ARCH_EVENTS=power7_events\n      ARCH_SPEC_EVTS=power7_events_map.c\n    elif test \"$MAKEVER\" = \"linux-perfctr-PPC970\"; then\n      CPU_MODEL=PPC970\n      ARCH_EVENTS=ppc970_events\n      ARCH_SPEC_EVTS=ppc970_events_map.c\n    fi\n    CFLAGS=\"$CFLAGS -DPPC64 -D_$(CPU_MODEL) -D__perfctr__ -DARCH_EVTS=\\\"$(ARCH_EVENTS).h\\\" -DCOMP_VECTOR=_ppc64_vectors\"\n    FFLAGS='-D_$(CPU_MODEL)'\n\nelif test \"$MAKEVER\" = \"linux-perfmon2\"; then\n    FILENAME=Rules.perfmon2\n    CPUCOMPONENT_NAME=perfmon2\n    components=\"perfmon2\"\n\nelif (test \"$MAKEVER\" = \"linux-pfm-ia64\" || test \"$MAKEVER\" = \"linux-pfm-itanium2\" || test \"$MAKEVER\" = \"linux-pfm-montecito\"); then\n    FILENAME=Rules.pfm\n    CPUCOMPONENT_NAME=perfmon-ia64\n    components=\"perfmon_ia64\"\n    VERSION=3.y\n    if test \"$MAKEVER\" = \"linux-pfm-itanium2\"; then\n      CPU=2\n    else\n      CPU=3\n    fi\n    CFLAGS=\"$CFLAGS -DITANIUM$CPU\"\n    FFLAGS=\"$FFLAGS -DITANIUM$CPU\"\n\n  CC_SHR='$(CC) -fPIC -DPIC -shared -Wl,-soname -Wl,$(SHLIB) -Xlinker \"-rpath\" -Xlinker \"$(LIBDIR)\"'\n\nelif test \"$MAKEVER\" = \"solaris-ultra\"; then\n    CPUCOMPONENT_NAME=solaris-ultra\n    CPUCOMPONENT_C=solaris-ultra.c\n    CPUCOMPONENT_OBJ=solaris-ultra.obj\n    VECTOR=_solaris_vector\n    PAPI_EVENTS_CSV=\"papi_events.csv\"\n  DESCR=\"Solaris 5.8 or greater with UltraSPARC I, II or III\"\n  if test \"$CC\" = \"gcc\"; then\n    F77=g77\n    CPP=\"$CC -E\"\n    CC_R=\"$CC\" \n    CC_SHR=\"$CC -shared -fpic\"\n    OPTFLAGS=-O3\n    CFLAGS=\"$CFLAGS -DNEED_FFSLL\"\n    FFLAGS=$CFLAGS\n  else \n    # Sun Workshop compilers: V5.0 and V6.0 R2\n    CPP=\"$CC -E\"\n    CC_R=\"$CC -mt\"\n    CC_SHR=\"$CC -ztext -G -Kpic\" \n      CFLAGS=\"-xtarget=ultra3 -xarch=v8plusa -DNO_VARARG_MACRO -D__EXTENSIONS__ -DPAPI_NO_MEMORY_MANAGEMENT -DCOMP_VECTOR=_solaris_vectors\"\n    SMPCFLGS=-xexplicitpar\n    OMPCFLGS=-xopenmp\n    F77=f90\n    FFLAGS=$CFLAGS\n    NOOPT=-xO0 \n    OPTFLAGS=\"-g -fast -xtarget=ultra3 -xarch=v8plusa\" \n  fi\n  LDFLAGS=\"$LDFLAGS -lcpc\" \n  if test \"$bitmode\" = \"64\"; then\n    LIBRARY=libpapi64.a\n    SHLIB=libpapi64.so\n      CFLAGS=\"-xtarget=ultra3 -xarch=v9a -DNO_VARARG_MACRO -D__EXTENSIONS__ -DPAPI_NO_MEMORY_MANAGEMENT  -DCOMP_VECTOR=_solaris_vectors\"\n    OPTFLAGS=\"-g -fast -xtarget=ultra3 -xarch=v9a\"\n  fi\n\nelif test \"$MAKEVER\" = \"solaris-niagara2\"; then\n    CPUCOMPONENT_NAME=solaris-niagara2\n    CPUCOMPONENT_C=solaris-niagara2.c\n    CPUCOMPONENT_OBJ=solaris-niagara2.obj\n    VECTOR=_niagara2_vector\n    PAPI_EVENTS_CSV=\"papi_events.csv\"\n    CFLAGS=\"-xtarget=native -xarch=native -DNO_VARARG_MACRO -D__EXTENSIONS__ -DCOMP_VECTOR=_niagara2_vector\"\n    ORY_MANAGEMENT=\"-DCOMP_VECTOR=_solaris_vector\"\n  DESCR=\"Solaris 10 with libcpc2 and UltraSPARC T2 (Niagara 2)\"\n  CPP=\"$CC -E\"\n  CC_R=\"$CC -mt\"\n  CC_SHR=\"$CC -ztext -G -Kpic\"  \n  SMPCFLGS=-xexplicitpar\n  OMPCFLGS=-xopenmp\n  F77=f90\n  FFLAGS=$CFLAGS\n  NOOPT=-xO0 \n  OPTFLAGS=\"-fast\" \n  FOPTFLAGS=$OPTFLAGS\n  LDFLAGS=\"$LDFLAGS -lcpc\" \n  if test \"$bitmode\" = \"64\";  then\n    LIBRARY=libpapi64.a\n    SHLIB=libpapi64.so\n    CFLAGS=\"$CFLAGS -m64\"\n    FFLAGS=\"$FFLAGS -m64\"\n  fi\nelif test \"$MAKEVER\" = \"darwin\"; then\n  DESCR=\"Darwin\"\n  CPUCOMPONENT_NAME=darwin\n  CPUCOMPONENT=linux-generic.c\n  CPUCOMPONENT=linux-generic.obj\n  CFLAGS=\"-DNEED_FFSLL\"\n  CC_SHR='$(CC) -fPIC -DPIC -shared -Wl,-dylib -Xlinker \"-rpath\" -Xlinker \"$(LIBDIR)\"'\n  SHLIB=libpapi.dylib\nelif test \"$MAKEVER\" = \"generic_platform\"; then\n  DESCR=\"Generic platform\"\nfi\n\nMISCOBJS='$(MISCSRCS:.c=.o)'\n\n\n\nif test \"$F77\" = \"pgf77\"; then\n  FFLAGS=\"$FFLAGS -Wall -Mextend\"\nelif test \"$F77\" = \"ifort\"; then\n  FFLAGS=\"$FFLAGS -warn all\"\nelif test \"$F77\" != \"xlf\"; then\n  FFLAGS=\"$FFLAGS -ffixed-line-length-132\"\nfi\n\nif test \"$CC_COMMON_NAME\" = \"icc\"; then\n    OMPCFLGS=-openmp\nfi\n\nAC_MSG_CHECKING(for components to build)\nCOMPONENT_RULES=components/Rules.components\necho \"/* Automatically generated by configure */\" > components_config.h\necho \"#ifndef COMPONENTS_CONFIG_H\" >> components_config.h\necho \"#define COMPONENTS_CONFIG_H\" >> components_config.h\necho \"\" >> components_config.h\n\nAC_ARG_WITH(components,\n        \t[  --with-components=<\"component1 component2\">\t\tSpecify which components to build ],\n        \t[components=\"$components $withval\"]) \n\n# This is an ugly hack to keep building on configurations covered by any-null in the past.\nif test \"$VECTOR\" = \"_papi_dummy_vector\"; then\n\tif test \"x$components\" = \"x\"; then \n\t\techo \"papi_vector_t ${VECTOR} = {\" >> components_config.h \n \t\techo \"\t.size = {\n\t\t.context = sizeof ( int ),\n\t\t.control_state = sizeof ( int ),\n\t\t.reg_value = sizeof ( int ),\n\t\t.reg_alloc = sizeof ( int ),\n\t}, \n\t.cmp_info = { \n\t\t.num_native_events = 0, \n\t\t.num_preset_events = 0, \n\t\t.num_cntrs = 0,\n\t\t.name = \\\"Your system is unsupported! \\\",\n\t\t.short_name = \\\"UNSUPPORTED!\\\" \n\t},\n\t.dispatch_timer = NULL,\n    .get_overflow_address = NULL,\n    .start = NULL,\n    .stop = NULL,\n    .read = NULL,\n    .reset = NULL,\n    .write = NULL,\n\t.cleanup_eventset = NULL,\n    .stop_profiling = NULL,\n    .init_component = NULL,\n    .init_thread = NULL,\n    .init_control_state = NULL,\n    .update_control_state = NULL,\n    .ctl = NULL,\n    .set_overflow = NULL,\n    .set_profile\t = NULL,\n    .set_domain = NULL,\n    .ntv_enum_events = NULL,\n    .ntv_name_to_code = NULL,\n    .ntv_code_to_name = NULL,\n    .ntv_code_to_descr = NULL,\n    .ntv_code_to_bits = NULL,\n    .ntv_code_to_info = NULL,\n    .allocate_registers = NULL,\n    .shutdown_thread = NULL,\n    .shutdown_component = NULL,\n    .user = NULL,\n};\" >> components_config.h\n\t# but in the face of actual components, we don't have to do hacky size games\n\telse\n\t\tVECTOR=\"\"\n\tfi\nelif test \"x$VECTOR\" != \"x\"; then\n   echo \"extern papi_vector_t ${VECTOR};\" >> components_config.h\nfi\n    \n\n\nfor comp in $components; do\n  idx=`echo \"$comp\" | sed -n \"s/\\/.*//p\" | wc -c`\n  if test \"$idx\" = 0; then\n\tsubcomp=$comp\n  else\n      subcomp=`echo $comp | sed -E \"s/^.{${idx}}//\"`\n  fi\n  COMPONENT_RULES=\"$COMPONENT_RULES components/$comp/Rules.$subcomp\"\n  echo \"extern papi_vector_t _${subcomp}_vector;\" >> components_config.h\ndone\necho \"\" >> components_config.h\necho \"struct papi_vectors *_papi_hwd[[]] = {\" >> components_config.h\n\nif test \"x$VECTOR\" != \"x\"; then\n   echo \"   &${VECTOR},\" >> components_config.h\nfi\n\nfor comp in $components; do\n  idx=`echo \"$comp\" | sed -n \"s/\\/.*//p\" | wc -c` \n  if test \"$idx\" = 0; then\n\tsubcomp=$comp\n  else\n      subcomp=`echo $comp | sed -E \"s/^.{${idx}}//\"`\n  fi\n  echo \"   &_${subcomp}_vector,\" >> components_config.h\ndone\necho \"   NULL\" >> components_config.h\necho \"};\" >> components_config.h\necho \"\" >> components_config.h\necho \"#endif\" >> components_config.h \n\n# check for component tests\nfor comp in $components; do\n  if test \"`find components/$comp -name \"tests\"`\" != \"\" ; then\n\tCOMPONENTS=\"$COMPONENTS $comp\"\n  fi\ndone\ntests=\"$tests comp_tests\"\n\nAC_MSG_RESULT($components)\n\nAC_MSG_CHECKING(for PAPI event CSV filename to use)\nif test \"x$PAPI_EVENTS_CSV\" == \"x\"; then\n   PAPI_EVENTS_CSV=\"papi_events.csv\"\nfi\nAC_MSG_RESULT($PAPI_EVENTS_CSV)\n\nAC_SUBST(prefix)\nAC_SUBST(exec_prefix)\nAC_SUBST(libdir)\nAC_SUBST(includedir)\nAC_SUBST(mandir)\nAC_SUBST(bindir)\nAC_SUBST(datadir)\nAC_SUBST(datarootdir)\nAC_SUBST(docdir)\nAC_SUBST(PACKAGE_TARNAME)\nAC_SUBST(arch)\nAC_SUBST(MAKEVER)\nAC_SUBST(PMAPI)\nAC_SUBST(PMINIT)\nAC_SUBST(F77)\nAC_SUBST(CPP)\nAC_SUBST(CC)\nAC_SUBST(AR)\nAC_SUBST(papiLIBS)\nAC_SUBST(STATIC)\nAC_SUBST(LDFLAGS)\nAC_SUBST(altix)\nAC_SUBST(perfctr_root)\nAC_SUBST(perfctr_prefix)\nAC_SUBST(perfctr_incdir)\nAC_SUBST(perfctr_libdir)\nAC_SUBST(pfm_root)\nAC_SUBST(old_pfmv2)\nAC_SUBST(pfm_prefix)\nAC_SUBST(pfm_incdir)\nAC_SUBST(pfm_libdir)\nAC_SUBST(OS)\nAC_SUBST(CFLAGS)\nAC_SUBST(FFLAGS)\nAC_SUBST(CPPFLAGS)\nAC_SUBST(PAPI_EVENTS)\nAC_SUBST(PAPI_EVENTS_CSV)\nAC_SUBST(SETPATH)\nAC_SUBST(LINKLIB)\nAC_SUBST(VERSION)\nAC_SUBST(CPU)\nAC_SUBST(FILENAME)\nAC_SUBST(LIBRARY)\nAC_SUBST(SHLIB)\nAC_SUBST(VLIB)\nAC_SUBST(PAPICFLAGS)\nAC_SUBST(OPTFLAGS)\nAC_SUBST(CPUCOMPONENT_NAME)\nAC_SUBST(CPUCOMPONENT_C)\nAC_SUBST(CPUCOMPONENT_OBJ)\nAC_SUBST(OSFILESSRC)\nAC_SUBST(OSFILESOBJ)\nAC_SUBST(OSFILESHDR)\nAC_SUBST(OSLOCK)\nAC_SUBST(OSCONTEXT)\nAC_SUBST(DESCR)\nAC_SUBST(LIBS)\nAC_SUBST(CTEST_TARGETS)\nAC_SUBST(CC_R)\nAC_SUBST(CC_SHR)\nAC_SUBST(SMPCFLGS)\nAC_SUBST(OMPCFLGS)\nAC_SUBST(NOOPT)\nAC_SUBST(MISCSRCS)\nAC_SUBST(MISCOBJS)\nAC_SUBST(POST_BUILD)\nAC_SUBST(ARCH_EVENTS)\nAC_SUBST(CPU_MODEL)\nAC_SUBST(cpu_option)\nAC_SUBST(ARG64)\nAC_SUBST(FLAGS)\nAC_SUBST(MPICC)\nAC_SUBST(MISCHDRS)\nAC_SUBST(SHLIBDEPS)\nAC_SUBST(TOPTFLAGS)\nAC_SUBST(TESTS)\nAC_SUBST(tests)\nAC_SUBST(SHOW_CONF)\nAC_SUBST(BGP_SYSDIR)\nAC_SUBST(BITFLAGS)\nAC_SUBST(COMPONENT_RULES)\nAC_SUBST(COMPONENTS)\nAC_SUBST(FTEST_TARGETS)\nAC_SUBST(HAVE_NO_OVERRIDE_INIT)\nAC_SUBST(BGPM_INSTALL_DIR)\nAC_SUBST(CC_COMMON_NAME)\n\nif test \"$cross_compiling\" = \"yes\" ; then\n  AC_MSG_NOTICE(Compiling genpapifdef with $nativecc because cross compiling)\n  $nativecc -I. genpapifdef.c -o genpapifdef\nelse\n  AC_MSG_NOTICE(Compiling genpapifdef with $CC)\n  $CC -I. genpapifdef.c -o genpapifdef\nfi\n\nAC_MSG_NOTICE(Generating fpapi.h)\n./genpapifdef -c > fpapi.h\nAC_MSG_NOTICE(Generating f77papi.h)\n./genpapifdef -f77 > f77papi.h\nAC_MSG_NOTICE(Generating f90papi.h)\n./genpapifdef -f90 > f90papi.h\n\nAC_MSG_NOTICE($FILENAME will be included in the generated Makefile)\nAC_CONFIG_FILES([Makefile papi.pc])\nAC_CONFIG_FILES([components/Makefile_comp_tests.target testlib/Makefile.target utils/Makefile.target ctests/Makefile.target ftests/Makefile.target validation_tests/Makefile.target])\nAC_OUTPUT\n",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.6.0-iweh6uy7qfzcgjj77nhy45ucjhpm2ow6/spack-src/src/ctests/shlib.c": "/*\n* File:    profile.c\n* Author:  Philip Mucci\n*          mucci@cs.utk.edu\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#if (!defined(NO_DLFCN) && !defined(_BGL) && !defined(_BGP))\n#include <dlfcn.h>\n#endif\n\n#include \"papi.h\"\n#include \"papi_test.h\"\n\nvoid print_shlib_info_map(const PAPI_shlib_info_t *shinfo, int quiet)\n{\n\tPAPI_address_map_t *map = shinfo->map;\n\tint i;\n\tif (NULL == map) {\n\t\ttest_fail(__FILE__, __LINE__, \"PAPI_get_shared_lib_info\", 1);\n\t}\n\n\tif (!quiet) for ( i = 0; i < shinfo->count; i++ ) {\n\t\tprintf( \"Library: %s\\n\", map->name );\n\t\tprintf( \"Text start: %p, Text end: %p\\n\", map->text_start,\n\t\t\t\tmap->text_end );\n\t\tprintf( \"Data start: %p, Data end: %p\\n\", map->data_start,\n\t\t\t\tmap->data_end );\n\t\tprintf( \"Bss start: %p, Bss end: %p\\n\", map->bss_start, map->bss_end );\n\n\t\tif ( strlen( &(map->name[0]) ) == 0 )\n\t\t\ttest_fail( __FILE__, __LINE__, \"PAPI_get_shared_lib_info\", 1 );\n\t\tif ( ( map->text_start == 0x0 ) || ( map->text_end == 0x0 ) ||\n\t\t\t ( map->text_start >= map->text_end ) )\n\t\t\ttest_fail( __FILE__, __LINE__, \"PAPI_get_shared_lib_info\", 1 );\n/*\n       if ((map->data_start == 0x0) || (map->data_end == 0x0) ||\n\t   (map->data_start >= map->data_end))\n\t test_fail(__FILE__, __LINE__, \"PAPI_get_shared_lib_info\",1);\n       if (((map->bss_start) && (!map->bss_end)) ||\n\t   ((!map->bss_start) && (map->bss_end)) ||\n\t   (map->bss_start > map->bss_end))\n\t test_fail(__FILE__, __LINE__, \"PAPI_get_shared_lib_info\",1);\n*/\n\n\t\tmap++;\n\t}\n}\n\nvoid display( char *msg )\n{\n\tint i;\n\tfor (i=0; i<64; i++)\n\t{\n\t\tprintf( \"%1d\", (msg[i] ? 1 : 0) );\n\t}\n\tprintf(\"\\n\");\n}\n\nint\nmain( int argc, char **argv )\n{\n\tint retval,quiet;\n\n\tconst PAPI_shlib_info_t *shinfo;\n\n\t/* Set TESTS_QUIET variable */\n\tquiet = tests_quiet( argc, argv );\n\n\tretval = PAPI_library_init( PAPI_VER_CURRENT );\n\tif (retval != PAPI_VER_CURRENT ) {\n\t\ttest_fail( __FILE__, __LINE__, \"PAPI_library_init\", retval );\n\t}\n\n\tif ( ( shinfo = PAPI_get_shared_lib_info(  ) ) == NULL ) {\n\t\ttest_skip( __FILE__, __LINE__, \"PAPI_get_shared_lib_info\", 1 );\n\t}\n\n\tif ( ( shinfo->count == 0 ) && ( shinfo->map ) ) {\n\t\ttest_fail( __FILE__, __LINE__, \"PAPI_get_shared_lib_info\", 1 );\n\t}\n\n\tprint_shlib_info_map(shinfo, quiet);\n\n\t/* Needed for debugging, so you can ^Z and stop the process, */\n\t/* inspect /proc to see if it's right */\n\tsleep( 1 );\n\n#ifndef NO_DLFCN\n\t{\n\n\tconst char *_libname = \"libcrypt.so\";\n\tvoid *handle;\n\tvoid ( *setkey) (const char *key);\n\tvoid ( *encrypt) (char block[64], int edflag);\n\tchar key[64]={\n\t\t1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,\n\t\t1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,\n\t\t1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,\n\t\t1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,\n\t}; /* bit pattern for key */\n\tchar orig[64];      /* bit pattern for messages */\n\tchar txt[64];      \t    /* bit pattern for messages */\n\n\tint oldcount;\n\n\thandle = dlopen( _libname, RTLD_NOW );\n\tif ( !handle ) {\n\t\tprintf( \"dlopen: %s\\n\", dlerror(  ) );\n\t\tif (!quiet) printf( \"Did you forget to set the environmental \"\n\t\t\t\"variable LIBPATH (in AIX) or \"\n\t\t\t\"LD_LIBRARY_PATH (in linux) ?\\n\" );\n\t\t\ttest_fail( __FILE__, __LINE__, \"dlopen\", 1 );\n\t}\n\n\tsetkey = dlsym( handle, \"setkey\" );\n\tencrypt = dlsym( handle, \"encrypt\" );\n\tif ( setkey == NULL || encrypt == NULL) {\n\t\tif (!quiet) printf( \"dlsym: %s\\n\", dlerror(  ) );\n\t\ttest_fail( __FILE__, __LINE__, \"dlsym\", 1 );\n\t}\n\n\tmemset(orig,0,64);\n\tmemcpy(txt,orig,64);\n\tsetkey(key);\n\n\tif (!quiet) {\n\t\tprintf(\"original  \");\n\t\tdisplay(txt);\n\t}\n\n\tencrypt(txt, 0);   /* encode */\n\n\tif (!quiet) {\n\t\tprintf(\"encrypted \");\n\t\tdisplay(txt);\n\t}\n\n\tif (!memcmp(txt,orig,64)) {\n\t\ttest_fail( __FILE__, __LINE__, \"encode\", 1 );\n\t}\n\n\tencrypt(txt, 1);   /* decode */\n\n\tif (!quiet) {\n\t\tprintf(\"decrypted \");\n\t\tdisplay(txt);\n\t}\n\n\tif (memcmp(txt,orig,64)) {\n\t\ttest_fail( __FILE__, __LINE__, \"decode\", 1 );\n\t}\n\n\toldcount = shinfo->count;\n\n\tif ( ( shinfo = PAPI_get_shared_lib_info(  ) ) == NULL ) {\n\t\ttest_fail( __FILE__, __LINE__, \"PAPI_get_shared_lib_info\", 1 );\n\t}\n\n\t/* Needed for debugging, so you can ^Z and stop the process, */\n\t/* inspect /proc to see if it's right */\n\tsleep( 1 );\n\n\tif ( ( shinfo->count == 0 ) && ( shinfo->map ) ) {\n\t\ttest_fail( __FILE__, __LINE__, \"PAPI_get_shared_lib_info\", 1 );\n\t}\n\n\tif ( shinfo->count <= oldcount ) {\n\t\ttest_fail( __FILE__, __LINE__, \"PAPI_get_shared_lib_info\", 1 );\n\t}\n\n\tprint_shlib_info_map(shinfo, quiet);\n\n\t/* Needed for debugging, so you can ^Z and stop the process, */\n\t/* inspect /proc to see if it's right */\n\tsleep( 1 );\n\n\tdlclose( handle );\n\n\t}\n#endif\n\n\ttest_pass( __FILE__ );\n\n\treturn 0;\n\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.6.0-iweh6uy7qfzcgjj77nhy45ucjhpm2ow6/spack-src/src/components/vmware/vmware.c": "/****************************/\n/* THIS IS OPEN SOURCE CODE */\n/****************************/\n\n/**\n * @file    mware.c\n * @author  Matt Johnson\n *          mrj@eecs.utk.edu\n * @author  John Nelson\n *          jnelso37@eecs.utk.edu\n * @author  Vince Weaver\n *          vweaver1@eecs.utk.edu\n *\n * @ingroup papi_components\n *\n * VMware component\n *\n * @brief\n *\tThis is the VMware component for PAPI-V. It will allow user access to\n *\thardware information available from a VMware virtual machine.\n */\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n\n#include <unistd.h>\n#include <dlfcn.h>\n\n/* Headers required by PAPI */\n#include \"papi.h\"\n#include \"papi_internal.h\"\n#include \"papi_vector.h\"\n#include \"papi_memory.h\"\n\n#define VMWARE_MAX_COUNTERS 256\n\n#define VMWARE_CPU_LIMIT_MHZ            0\n#define VMWARE_CPU_RESERVATION_MHZ      1\n#define VMWARE_CPU_SHARES               2\n#define VMWARE_CPU_STOLEN_MS            3\n#define VMWARE_CPU_USED_MS              4\n#define VMWARE_ELAPSED_MS               5\n\n#define VMWARE_MEM_ACTIVE_MB            6\n#define VMWARE_MEM_BALLOONED_MB         7\n#define VMWARE_MEM_LIMIT_MB             8\n#define VMWARE_MEM_MAPPED_MB            9\n#define VMWARE_MEM_OVERHEAD_MB          10\n#define VMWARE_MEM_RESERVATION_MB       11\n#define VMWARE_MEM_SHARED_MB            12\n#define VMWARE_MEM_SHARES               13\n#define VMWARE_MEM_SWAPPED_MB           14\n#define VMWARE_MEM_TARGET_SIZE_MB       15\n#define VMWARE_MEM_USED_MB              16\n\n#define VMWARE_HOST_CPU_MHZ             17\n\n/* The following 3 require VMWARE_PSEUDO_PERFORMANCE env_var to be set. */\n\n#define VMWARE_HOST_TSC\t\t\t18\n#define VMWARE_ELAPSED_TIME             19\n#define VMWARE_ELAPSED_APPARENT         20\n\n/* Begin PAPI definitions */\npapi_vector_t _vmware_vector;\n\n\nvoid (*_dl_non_dynamic_init)(void) __attribute__((weak));\n\n/** Structure that stores private information for each event */\nstruct _vmware_register {\n    unsigned int selector;\n    /**< Signifies which counter slot is being used */\n    /**< Indexed from 1 as 0 has a special meaning  */\n};\n\n/** This structure is used to build the table of events */\nstruct _vmware_native_event_entry {\n\tchar name[PAPI_MAX_STR_LEN];        /**< Name of the counter         */\n\tchar description[PAPI_HUGE_STR_LEN]; /**< Description of counter     */\n        char units[PAPI_MIN_STR_LEN];\n        int which_counter;\n        int report_difference;\n};\n\nstruct _vmware_reg_alloc {\n\tstruct _vmware_register ra_bits;\n};\n\n\ninline uint64_t rdpmc(int c)\n{\n  uint32_t low, high;\n  __asm__ __volatile__(\"rdpmc\" : \"=a\" (low), \"=d\" (high) : \"c\" (c));\n  return (uint64_t)high << 32 | (uint64_t)low;\n}\n\n\n\n#ifdef VMGUESTLIB\n/* Headers required by VMware */\n#include \"vmGuestLib.h\"\n\n/* Functions to dynamically load from the GuestLib library. */\nchar const * (*GuestLib_GetErrorText)(VMGuestLibError);\nVMGuestLibError (*GuestLib_OpenHandle)(VMGuestLibHandle*);\nVMGuestLibError (*GuestLib_CloseHandle)(VMGuestLibHandle);\nVMGuestLibError (*GuestLib_UpdateInfo)(VMGuestLibHandle handle);\nVMGuestLibError (*GuestLib_GetSessionId)(VMGuestLibHandle handle, VMSessionId *id);\nVMGuestLibError (*GuestLib_GetCpuReservationMHz)(VMGuestLibHandle handle, uint32 *cpuReservationMHz);\nVMGuestLibError (*GuestLib_GetCpuLimitMHz)(VMGuestLibHandle handle, uint32 *cpuLimitMHz);\nVMGuestLibError (*GuestLib_GetCpuShares)(VMGuestLibHandle handle, uint32 *cpuShares);\nVMGuestLibError (*GuestLib_GetCpuUsedMs)(VMGuestLibHandle handle, uint64 *cpuUsedMs);\nVMGuestLibError (*GuestLib_GetHostProcessorSpeed)(VMGuestLibHandle handle, uint32 *mhz);\nVMGuestLibError (*GuestLib_GetMemReservationMB)(VMGuestLibHandle handle, uint32 *memReservationMB);\nVMGuestLibError (*GuestLib_GetMemLimitMB)(VMGuestLibHandle handle, uint32 *memLimitMB);\nVMGuestLibError (*GuestLib_GetMemShares)(VMGuestLibHandle handle, uint32 *memShares);\nVMGuestLibError (*GuestLib_GetMemMappedMB)(VMGuestLibHandle handle, uint32 *memMappedMB);\nVMGuestLibError (*GuestLib_GetMemActiveMB)(VMGuestLibHandle handle, uint32 *memActiveMB);\nVMGuestLibError (*GuestLib_GetMemOverheadMB)(VMGuestLibHandle handle, uint32 *memOverheadMB);\nVMGuestLibError (*GuestLib_GetMemBalloonedMB)(VMGuestLibHandle handle, uint32 *memBalloonedMB);\nVMGuestLibError (*GuestLib_GetMemSwappedMB)(VMGuestLibHandle handle, uint32 *memSwappedMB);\nVMGuestLibError (*GuestLib_GetMemSharedMB)(VMGuestLibHandle handle, uint32 *memSharedMB);\nVMGuestLibError (*GuestLib_GetMemSharedSavedMB)(VMGuestLibHandle handle, uint32 *memSharedSavedMB);\nVMGuestLibError (*GuestLib_GetMemUsedMB)(VMGuestLibHandle handle, uint32 *memUsedMB);\nVMGuestLibError (*GuestLib_GetElapsedMs)(VMGuestLibHandle handle, uint64 *elapsedMs);\nVMGuestLibError (*GuestLib_GetResourcePoolPath)(VMGuestLibHandle handle, size_t *bufferSize, char *pathBuffer);\nVMGuestLibError (*GuestLib_GetCpuStolenMs)(VMGuestLibHandle handle, uint64 *cpuStolenMs);\nVMGuestLibError (*GuestLib_GetMemTargetSizeMB)(VMGuestLibHandle handle, uint64 *memTargetSizeMB);\nVMGuestLibError (*GuestLib_GetHostNumCpuCores)(VMGuestLibHandle handle, uint32 *hostNumCpuCores);\nVMGuestLibError (*GuestLib_GetHostCpuUsedMs)(VMGuestLibHandle handle, uint64 *hostCpuUsedMs);\nVMGuestLibError (*GuestLib_GetHostMemSwappedMB)(VMGuestLibHandle handle, uint64 *hostMemSwappedMB);\nVMGuestLibError (*GuestLib_GetHostMemSharedMB)(VMGuestLibHandle handle, uint64 *hostMemSharedMB);\nVMGuestLibError (*GuestLib_GetHostMemUsedMB)(VMGuestLibHandle handle, uint64 *hostMemUsedMB);\nVMGuestLibError (*GuestLib_GetHostMemPhysMB)(VMGuestLibHandle handle, uint64 *hostMemPhysMB);\nVMGuestLibError (*GuestLib_GetHostMemPhysFreeMB)(VMGuestLibHandle handle, uint64 *hostMemPhysFreeMB);\nVMGuestLibError (*GuestLib_GetHostMemKernOvhdMB)(VMGuestLibHandle handle, uint64 *hostMemKernOvhdMB);\nVMGuestLibError (*GuestLib_GetHostMemMappedMB)(VMGuestLibHandle handle, uint64 *hostMemMappedMB);\nVMGuestLibError (*GuestLib_GetHostMemUnmappedMB)(VMGuestLibHandle handle, uint64 *hostMemUnmappedMB);\n\n\nstatic void *dlHandle = NULL;\n\n\n/*\n * Macro to load a single GuestLib function from the shared library.\n */\n\n#define LOAD_ONE_FUNC(funcname)                                 \\\ndo {                                                            \\\nfuncname = dlsym(dlHandle, \"VM\" #funcname);                     \\\nif ((dlErrStr = dlerror()) != NULL) {                           \\\nfprintf(stderr, \"Failed to load \\'%s\\': \\'%s\\'\\n\",              \\\n#funcname, dlErrStr);                                           \\\nreturn FALSE;                                                   \\\n}                                                               \\\n} while (0)\n\n#endif\n\n/** Holds control flags, usually out-of band configuration of the hardware */\nstruct _vmware_control_state {\n   long long value[VMWARE_MAX_COUNTERS];\n   int which_counter[VMWARE_MAX_COUNTERS];\n   int num_events;\n};\n\n/** Holds per-thread information */\nstruct _vmware_context {\n  long long values[VMWARE_MAX_COUNTERS];\n  long long start_values[VMWARE_MAX_COUNTERS];\n#ifdef VMGUESTLIB\n  VMGuestLibHandle glHandle;\n#endif\n};\n\n\n\n\n\n\n/*\n *-----------------------------------------------------------------------------\n *\n * LoadFunctions --\n *\n *      Load the functions from the shared library.\n *\n * Results:\n *      TRUE on success\n *      FALSE on failure\n *\n * Side effects:\n *      None\n *\n * Credit: VMware\n *-----------------------------------------------------------------------------\n */\n\nstatic int\nLoadFunctions(void)\n{\n\n#ifdef VMGUESTLIB\n\t/*\n\t * First, try to load the shared library.\n\t */\n\n\t/* Attempt to guess if we were statically linked to libc, if so bail */\n\tif ( _dl_non_dynamic_init != NULL ) {\n\t\tstrncpy(_vmware_vector.cmp_info.disabled_reason, \"The VMware component does not support statically linking of libc.\", PAPI_MAX_STR_LEN);\n\t\treturn PAPI_ENOSUPP;\n\t}\n\n\tchar const *dlErrStr;\n\tchar filename[BUFSIZ];\n\n\tsprintf(filename,\"%s\",\"libvmGuestLib.so\");\n\tdlHandle = dlopen(filename, RTLD_NOW);\n\tif (!dlHandle) {\n\t   dlErrStr = dlerror();\n\t   fprintf(stderr, \"dlopen of %s failed: \\'%s\\'\\n\", filename, \n\t\t   dlErrStr);\n\n\t   sprintf(filename,\"%s/lib/lib64/libvmGuestLib.so\",VMWARE_INCDIR);\n\t   dlHandle = dlopen(filename, RTLD_NOW);\n\t   if (!dlHandle) {\n\t      dlErrStr = dlerror();\n\t      fprintf(stderr, \"dlopen of %s failed: \\'%s\\'\\n\", filename, \n\t\t   dlErrStr);\n\n\t      sprintf(filename,\"%s/lib/lib32/libvmGuestLib.so\",VMWARE_INCDIR);\n\t      dlHandle = dlopen(filename, RTLD_NOW);\n\t      if (!dlHandle) {\n\t         dlErrStr = dlerror();\n\t         fprintf(stderr, \"dlopen of %s failed: \\'%s\\'\\n\", filename, \n\t\t      dlErrStr);\n\t\t return PAPI_ECMP;\n\t      }\n\t   }\n\t}\n\n\t/* Load all the individual library functions. */\n\tLOAD_ONE_FUNC(GuestLib_GetErrorText);\n\tLOAD_ONE_FUNC(GuestLib_OpenHandle);\n\tLOAD_ONE_FUNC(GuestLib_CloseHandle);\n\tLOAD_ONE_FUNC(GuestLib_UpdateInfo);\n\tLOAD_ONE_FUNC(GuestLib_GetSessionId);\n\tLOAD_ONE_FUNC(GuestLib_GetCpuReservationMHz);\n\tLOAD_ONE_FUNC(GuestLib_GetCpuLimitMHz);\n\tLOAD_ONE_FUNC(GuestLib_GetCpuShares);\n\tLOAD_ONE_FUNC(GuestLib_GetCpuUsedMs);\n\tLOAD_ONE_FUNC(GuestLib_GetHostProcessorSpeed);\n\tLOAD_ONE_FUNC(GuestLib_GetMemReservationMB);\n\tLOAD_ONE_FUNC(GuestLib_GetMemLimitMB);\n\tLOAD_ONE_FUNC(GuestLib_GetMemShares);\n\tLOAD_ONE_FUNC(GuestLib_GetMemMappedMB);\n\tLOAD_ONE_FUNC(GuestLib_GetMemActiveMB);\n\tLOAD_ONE_FUNC(GuestLib_GetMemOverheadMB);\n\tLOAD_ONE_FUNC(GuestLib_GetMemBalloonedMB);\n\tLOAD_ONE_FUNC(GuestLib_GetMemSwappedMB);\n\tLOAD_ONE_FUNC(GuestLib_GetMemSharedMB);\n\tLOAD_ONE_FUNC(GuestLib_GetMemSharedSavedMB);\n\tLOAD_ONE_FUNC(GuestLib_GetMemUsedMB);\n\tLOAD_ONE_FUNC(GuestLib_GetElapsedMs);\n\tLOAD_ONE_FUNC(GuestLib_GetResourcePoolPath);\n\tLOAD_ONE_FUNC(GuestLib_GetCpuStolenMs);\n\tLOAD_ONE_FUNC(GuestLib_GetMemTargetSizeMB);\n\tLOAD_ONE_FUNC(GuestLib_GetHostNumCpuCores);\n\tLOAD_ONE_FUNC(GuestLib_GetHostCpuUsedMs);\n\tLOAD_ONE_FUNC(GuestLib_GetHostMemSwappedMB);\n\tLOAD_ONE_FUNC(GuestLib_GetHostMemSharedMB);\n\tLOAD_ONE_FUNC(GuestLib_GetHostMemUsedMB);\n\tLOAD_ONE_FUNC(GuestLib_GetHostMemPhysMB);\n\tLOAD_ONE_FUNC(GuestLib_GetHostMemPhysFreeMB);\n\tLOAD_ONE_FUNC(GuestLib_GetHostMemKernOvhdMB);\n\tLOAD_ONE_FUNC(GuestLib_GetHostMemMappedMB);\n\tLOAD_ONE_FUNC(GuestLib_GetHostMemUnmappedMB);\n#endif\n\treturn PAPI_OK;\n}\n\n\n\n/** This table contains the native events */\nstatic struct _vmware_native_event_entry *_vmware_native_table;\n/** number of events in the table*/\nstatic int num_events = 0;\nstatic int use_pseudo=0;\nstatic int use_guestlib=0;\n\n/************************************************************************/\n/* Below is the actual \"hardware implementation\" of our VMWARE counters */\n/************************************************************************/\n\n/** Code that reads event values.\n You might replace this with code that accesses\n hardware or reads values from the operatings system. */\nstatic long long\n_vmware_hardware_read( struct _vmware_context *context, int starting)\n{\n\n  int i;\n\n\tif (use_pseudo) {\n           context->values[VMWARE_HOST_TSC]=rdpmc(0x10000);\n           context->values[VMWARE_ELAPSED_TIME]=rdpmc(0x10001);\n           context->values[VMWARE_ELAPSED_APPARENT]=rdpmc(0x10002);\n\t}\n\n\n#ifdef VMGUESTLIB\n\tstatic VMSessionId sessionId = 0;\n\tVMSessionId tmpSession;\n\tuint32_t temp32;\n\tuint64_t temp64;\n\tVMGuestLibError glError;\n\n\tif (use_guestlib) {\n\n\tglError = GuestLib_UpdateInfo(context->glHandle);\n\tif (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t   fprintf(stderr,\"UpdateInfo failed: %s\\n\", \n\t\t   GuestLib_GetErrorText(glError));\n\t   \t   return PAPI_ECMP;\n\t}\n\n\t/* Retrieve and check the session ID */\n\tglError = GuestLib_GetSessionId(context->glHandle, &tmpSession);\n\tif (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t   fprintf(stderr, \"Failed to get session ID: %s\\n\", \n\t\t   GuestLib_GetErrorText(glError));\n\t   return PAPI_ECMP;\n\t}\n\n\tif (tmpSession == 0) {\n\t   fprintf(stderr, \"Error: Got zero sessionId from GuestLib\\n\");\n\t   return PAPI_ECMP;\n\t}\n\n\tif (sessionId == 0) {\n\t   sessionId = tmpSession;\n\t} else if (tmpSession != sessionId) {\n\t   sessionId = tmpSession;\n\t}\n\n\tglError = GuestLib_GetCpuLimitMHz(context->glHandle,&temp32);\n\tcontext->values[VMWARE_CPU_LIMIT_MHZ]=temp32;\n\tif (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t   fprintf(stderr,\"Failed to get CPU limit: %s\\n\", \n\t\t   GuestLib_GetErrorText(glError));\n\t   return PAPI_ECMP;\n\t}\n\n\tglError = GuestLib_GetCpuReservationMHz(context->glHandle,&temp32); \n\tcontext->values[VMWARE_CPU_RESERVATION_MHZ]=temp32;\n        if (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t   fprintf(stderr,\"Failed to get CPU reservation: %s\\n\", \n\t\t   GuestLib_GetErrorText(glError));\n\t   return PAPI_ECMP;\n\t}\n\t\n\tglError = GuestLib_GetCpuShares(context->glHandle,&temp32);\n\tcontext->values[VMWARE_CPU_SHARES]=temp32;\n\tif (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t   fprintf(stderr,\"Failed to get cpu shares: %s\\n\", \n\t\t   GuestLib_GetErrorText(glError));\n\t   return PAPI_ECMP;\n\t}\n\n\tglError = GuestLib_GetCpuStolenMs(context->glHandle,&temp64);\n\tcontext->values[VMWARE_CPU_STOLEN_MS]=temp64;\n\tif (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t   if (glError == VMGUESTLIB_ERROR_UNSUPPORTED_VERSION) {\n\t      context->values[VMWARE_CPU_STOLEN_MS]=0;\n\t      fprintf(stderr, \"Skipping CPU stolen, not supported...\\n\");\n\t   } else {\n\t      fprintf(stderr, \"Failed to get CPU stolen: %s\\n\", \n\t\t      GuestLib_GetErrorText(glError));\n\t      return PAPI_ECMP;\n\t   }\n\t}\n\n\tglError = GuestLib_GetCpuUsedMs(context->glHandle,&temp64);\n\tcontext->values[VMWARE_CPU_USED_MS]=temp64;\n\tif (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t   fprintf(stderr, \"Failed to get used ms: %s\\n\", \n\t\t   GuestLib_GetErrorText(glError));\n\t   return PAPI_ECMP;\n\t}\n\t\n\tglError = GuestLib_GetElapsedMs(context->glHandle, &temp64);\n\tcontext->values[VMWARE_ELAPSED_MS]=temp64;\n\tif (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t   fprintf(stderr, \"Failed to get elapsed ms: %s\\n\",\n\t\t   GuestLib_GetErrorText(glError));\n\t   return PAPI_ECMP;\n\t}\n\n\tglError = GuestLib_GetMemActiveMB(context->glHandle, &temp32);\n\tcontext->values[VMWARE_MEM_ACTIVE_MB]=temp32;\n\tif (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t   fprintf(stderr, \"Failed to get active mem: %s\\n\", \n\t\t   GuestLib_GetErrorText(glError));\n\t   return PAPI_ECMP;\n\t}\n\t\n\tglError = GuestLib_GetMemBalloonedMB(context->glHandle, &temp32);\n\tcontext->values[VMWARE_MEM_BALLOONED_MB]=temp32;\n\tif (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t   fprintf(stderr, \"Failed to get ballooned mem: %s\\n\", \n\t\t   GuestLib_GetErrorText(glError));\n\t   return PAPI_ECMP;\n\t}\n\t\n\tglError = GuestLib_GetMemLimitMB(context->glHandle, &temp32);\n\tcontext->values[VMWARE_MEM_LIMIT_MB]=temp32;\n\tif (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t   fprintf(stderr,\"Failed to get mem limit: %s\\n\", \n\t\t   GuestLib_GetErrorText(glError));\n\t   return PAPI_ECMP;\n\t}\n\n        glError = GuestLib_GetMemMappedMB(context->glHandle, &temp32);\n\tcontext->values[VMWARE_MEM_MAPPED_MB]=temp32;\n\tif (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t   fprintf(stderr, \"Failed to get mapped mem: %s\\n\", \n\t\t   GuestLib_GetErrorText(glError));\n\t   return PAPI_ECMP;\n\t}\n\n\tglError = GuestLib_GetMemOverheadMB(context->glHandle, &temp32);\n\tcontext->values[VMWARE_MEM_OVERHEAD_MB]=temp32;\n\tif (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t   fprintf(stderr, \"Failed to get overhead mem: %s\\n\", \n\t\t   GuestLib_GetErrorText(glError));\n\t   return PAPI_ECMP;\n\t}\n\n\tglError = GuestLib_GetMemReservationMB(context->glHandle, &temp32);\n\tcontext->values[VMWARE_MEM_RESERVATION_MB]=temp32;\n\tif (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t   fprintf(stderr, \"Failed to get mem reservation: %s\\n\", \n\t\t   GuestLib_GetErrorText(glError));\n\t   return PAPI_ECMP;\n\t}\n\n        glError = GuestLib_GetMemSharedMB(context->glHandle, &temp32);\n\tcontext->values[VMWARE_MEM_SHARED_MB]=temp32;\n\tif (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t   fprintf(stderr, \"Failed to get swapped mem: %s\\n\", \n\t\t   GuestLib_GetErrorText(glError));\n\t   return PAPI_ECMP;\n\t}\n\n\tglError = GuestLib_GetMemShares(context->glHandle, &temp32);\n\tcontext->values[VMWARE_MEM_SHARES]=temp32;\n\tif (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t   if (glError == VMGUESTLIB_ERROR_NOT_AVAILABLE) {\n\t      context->values[VMWARE_MEM_SHARES]=0;\n\t      fprintf(stderr, \"Skipping mem shares, not supported...\\n\");\n\t   } else {\n\t      fprintf(stderr, \"Failed to get mem shares: %s\\n\", \n\t\t      GuestLib_GetErrorText(glError));\n\t      return PAPI_ECMP;\n\t   }\n\t}\n\n\tglError = GuestLib_GetMemSwappedMB(context->glHandle, &temp32);\n\tcontext->values[VMWARE_MEM_SWAPPED_MB]=temp32;\n\tif (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t   fprintf(stderr, \"Failed to get swapped mem: %s\\n\",\n\t\t   GuestLib_GetErrorText(glError));\n\t   return PAPI_ECMP;\n\t}\n\t\n\tglError = GuestLib_GetMemTargetSizeMB(context->glHandle, &temp64);\n\tcontext->values[VMWARE_MEM_TARGET_SIZE_MB]=temp64;\n        if (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t   if (glError == VMGUESTLIB_ERROR_UNSUPPORTED_VERSION) {\n\t      context->values[VMWARE_MEM_TARGET_SIZE_MB]=0;\n\t      fprintf(stderr, \"Skipping target mem size, not supported...\\n\");\n\t   } else {\n\t      fprintf(stderr, \"Failed to get target mem size: %s\\n\", \n\t\t      GuestLib_GetErrorText(glError));\n\t      return PAPI_ECMP;\n\t   }\n\t}\n\n        glError = GuestLib_GetMemUsedMB(context->glHandle, &temp32);\n\tcontext->values[VMWARE_MEM_USED_MB]=temp32;\n\tif (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t   fprintf(stderr, \"Failed to get swapped mem: %s\\n\",\n\t\t   GuestLib_GetErrorText(glError));\n\t   return PAPI_ECMP;\n\t}\n\n        glError = GuestLib_GetHostProcessorSpeed(context->glHandle, &temp32); \n\tcontext->values[VMWARE_HOST_CPU_MHZ]=temp32;\n\tif (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t   fprintf(stderr, \"Failed to get host proc speed: %s\\n\", \n\t\t   GuestLib_GetErrorText(glError));\n\t   return PAPI_ECMP;\n\t}\n\t}\n\n#endif\n\n\tif (starting) {\n\n\t  for(i=0;i<VMWARE_MAX_COUNTERS;i++) {\n\t    context->start_values[i]=context->values[i];\n\t  }\n\n\t}\n\n\treturn PAPI_OK;\n}\n\n/********************************************************************/\n/* Below are the functions required by the PAPI component interface */\n/********************************************************************/\n\n/** This is called whenever a thread is initialized */\nint\n_vmware_init_thread( hwd_context_t *ctx )\n{\n\t(void) ctx;\n\n\n#ifdef VMGUESTLIB\n\n\tstruct _vmware_context *context;\n\tVMGuestLibError glError;\n\n\tcontext=(struct _vmware_context *)ctx;\n\n\tif (use_guestlib) {\n\t   glError = GuestLib_OpenHandle(&(context->glHandle));\n\t   if (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t      fprintf(stderr,\"OpenHandle failed: %s\\n\", \n\t\t   GuestLib_GetErrorText(glError));\n\t      return PAPI_ECMP;\n\t   }\n\t}\n\n#endif\n\n\treturn PAPI_OK;\n}\n\n\n/** Initialize hardware counters, setup the function vector table\n * and get hardware information, this routine is called when the\n * PAPI process is initialized (IE PAPI_library_init)\n */\nint\n_vmware_init_component( int cidx )\n{\n\n  (void) cidx;\n\n  int result;\n\n\tSUBDBG( \"_vmware_init_component...\" );\n\n\t/* Initialize and try to load the VMware library */\n\t/* Try to load the library. */\n\tresult=LoadFunctions();\n\n\tif (result!=PAPI_OK) {\n\t   strncpy(_vmware_vector.cmp_info.disabled_reason,\n\t\t  \"GuestLibTest: Failed to load shared library\",\n\t\t   PAPI_MAX_STR_LEN);\n\t   return PAPI_ECMP;\n\t}\n\n\t/* we know in advance how many events we want                       */\n\t/* for actual hardware this might have to be determined dynamically */\n\n\t/* Allocate memory for the our event table */\n\t_vmware_native_table = ( struct _vmware_native_event_entry * )\n\t  calloc( VMWARE_MAX_COUNTERS, sizeof ( struct _vmware_native_event_entry ));\n\tif ( _vmware_native_table == NULL ) {\n\t   return PAPI_ENOMEM;\n\t}\n\n\n#ifdef VMGUESTLIB\n\n\t/* Detect if GuestLib works */\n\t{\n\n        VMGuestLibError glError;\n        VMGuestLibHandle glHandle;\n\n\tuse_guestlib=0;\n\n\t/* try to open */\n\tglError = GuestLib_OpenHandle(&glHandle);\n\tif (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t   fprintf(stderr,\"OpenHandle failed: %s\\n\", \n\t\t   GuestLib_GetErrorText(glError));\n\t}\n\telse {\n\t   /* open worked, try to update */\n\t   glError = GuestLib_UpdateInfo(glHandle);\n\t   if (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t      fprintf(stderr,\"UpdateInfo failed: %s\\n\", \n\t\t      GuestLib_GetErrorText(glError));\n\t   }\n\t   else {\n\t      /* update worked, things work! */\n\t      use_guestlib=1;\n\t   }\n\t   /* shut things down */\n\t   glError = GuestLib_CloseHandle(glHandle);\n\t}\n\n        }\n\n\n\n\tif (use_guestlib) {\n\n\t/* fill in the event table parameters */\n\tstrcpy( _vmware_native_table[num_events].name,\n\t\t\"CPU_LIMIT\" );\n\tstrncpy( _vmware_native_table[num_events].description,\n\t\t\"Retrieves the upper limit of processor use in MHz \"\n\t\t\"available to the virtual machine.\",\n\t\tPAPI_HUGE_STR_LEN);\n\tstrcpy( _vmware_native_table[num_events].units,\"MHz\");\n\t_vmware_native_table[num_events].which_counter=\n\t        VMWARE_CPU_LIMIT_MHZ;\n\t_vmware_native_table[num_events].report_difference=0;\n\tnum_events++;\n\n\tstrcpy( _vmware_native_table[num_events].name,\n\t\t\"CPU_RESERVATION\" );\n\tstrncpy( _vmware_native_table[num_events].description,\n\t\t\"Retrieves the minimum processing power in MHz \"\n\t\t\"reserved for the virtual machine.\",\n\t\tPAPI_HUGE_STR_LEN);\n\tstrcpy( _vmware_native_table[num_events].units,\"MHz\");\n\t_vmware_native_table[num_events].which_counter=\n\t        VMWARE_CPU_RESERVATION_MHZ;\n\t_vmware_native_table[num_events].report_difference=0;\n\tnum_events++;\n\n\tstrcpy( _vmware_native_table[num_events].name,\n\t\t\"CPU_SHARES\" );\n\tstrncpy( _vmware_native_table[num_events].description,\n\t\t\"Retrieves the number of CPU shares allocated \"\n\t\t\"to the virtual machine.\",\n\t\tPAPI_HUGE_STR_LEN);\n\tstrcpy( _vmware_native_table[num_events].units,\"shares\");\n\t_vmware_native_table[num_events].which_counter=\n\t        VMWARE_CPU_SHARES;\n\t_vmware_native_table[num_events].report_difference=0;\n\tnum_events++;\n\n\tstrcpy( _vmware_native_table[num_events].name,\n\t\t\"CPU_STOLEN\" );\n\tstrncpy( _vmware_native_table[num_events].description,\n\t\t\"Retrieves the number of milliseconds that the \"\n\t\t\"virtual machine was in a ready state (able to \"\n\t\t\"transition to a run state), but was not scheduled to run.\",\n\t\tPAPI_HUGE_STR_LEN);\n\tstrcpy( _vmware_native_table[num_events].units,\"ms\");\n\t_vmware_native_table[num_events].which_counter=\n\t        VMWARE_CPU_STOLEN_MS;\n\t_vmware_native_table[num_events].report_difference=0;\n\tnum_events++;\n\n\tstrcpy( _vmware_native_table[num_events].name,\n\t\t\"CPU_USED\" );\n\tstrncpy( _vmware_native_table[num_events].description,\n\t\t\"Retrieves the number of milliseconds during which \"\n\t\t\"the virtual machine has used the CPU. This value \"\n\t\t\"includes the time used by the guest operating system \"\n\t\t\"and the time used by virtualization code for tasks for \"\n\t\t\"this virtual machine. You can combine this value with \"\n\t\t\"the elapsed time (VMWARE_ELAPSED) to estimate the \"\n\t\t\"effective virtual machine CPU speed. This value is a \"\n\t\t\"subset of elapsedMs.\",\n\t\tPAPI_HUGE_STR_LEN );\n\tstrcpy( _vmware_native_table[num_events].units,\"ms\");\n\t_vmware_native_table[num_events].which_counter=\n\t        VMWARE_CPU_USED_MS;\n\t_vmware_native_table[num_events].report_difference=1;\n\tnum_events++;\n\n\tstrcpy( _vmware_native_table[num_events].name,\n\t\t\"ELAPSED\" );\n\tstrncpy( _vmware_native_table[num_events].description,\n\t\t\"Retrieves the number of milliseconds that have passed \"\n\t\t\"in the virtual machine since it last started running on \"\n\t\t\"the server. The count of elapsed time restarts each time \"\n\t\t\"the virtual machine is powered on, resumed, or migrated \"\n\t\t\"using VMotion. This value counts milliseconds, regardless \"\n\t\t\"of whether the virtual machine is using processing power \"\n\t\t\"during that time. You can combine this value with the CPU \"\n\t\t\"time used by the virtual machine (VMWARE_CPU_USED) to \"\n\t\t\"estimate the effective virtual machine xCPU speed. \"\n\t\t\"cpuUsedMS is a subset of this value.\",\n\t\tPAPI_HUGE_STR_LEN );\n\tstrcpy( _vmware_native_table[num_events].units,\"ms\");\n\t_vmware_native_table[num_events].which_counter=\n\t        VMWARE_ELAPSED_MS;\n\t_vmware_native_table[num_events].report_difference=1;\n\tnum_events++;\n\n\tstrcpy( _vmware_native_table[num_events].name,\n\t\t\"MEM_ACTIVE\" );\n\tstrncpy( _vmware_native_table[num_events].description,\n\t\t \"Retrieves the amount of memory the virtual machine is \"\n\t\t \"actively using in MB - Its estimated working set size.\",\n\t\t PAPI_HUGE_STR_LEN );\n\tstrcpy( _vmware_native_table[num_events].units,\"MB\");\n\t_vmware_native_table[num_events].which_counter=\n                 VMWARE_MEM_ACTIVE_MB;\n\t_vmware_native_table[num_events].report_difference=0;\n\tnum_events++;\n\n\tstrcpy( _vmware_native_table[num_events].name,\n\t\t\"MEM_BALLOONED\" );\n\tstrncpy( _vmware_native_table[num_events].description,\n\t\t\"Retrieves the amount of memory that has been reclaimed \"\n\t\t\"from this virtual machine by the vSphere memory balloon \"\n\t\t\"driver (also referred to as the 'vmemctl' driver) in MB.\",\n\t\tPAPI_HUGE_STR_LEN );\n\tstrcpy( _vmware_native_table[num_events].units,\"MB\");\n\t_vmware_native_table[num_events].which_counter=\n\t        VMWARE_MEM_BALLOONED_MB;\n\t_vmware_native_table[num_events].report_difference=0;\n\tnum_events++;\n\n\tstrcpy( _vmware_native_table[num_events].name,\n\t\t\"MEM_LIMIT\" );\n\tstrncpy( _vmware_native_table[num_events].description,\n\t\t\"Retrieves the upper limit of memory that is available \"\n\t\t\"to the virtual machine in MB.\",\n\t\tPAPI_HUGE_STR_LEN );\n\tstrcpy( _vmware_native_table[num_events].units,\"MB\");\n\t_vmware_native_table[num_events].which_counter=\n\t        VMWARE_MEM_LIMIT_MB;\n\t_vmware_native_table[num_events].report_difference=0;\n\tnum_events++;\n\n\tstrcpy( _vmware_native_table[num_events].name,\n\t\t\"MEM_MAPPED\" );\n\tstrncpy( _vmware_native_table[num_events].description,\n\t\t\"Retrieves the amount of memory that is allocated to \"\n\t\t\"the virtual machine in MB. Memory that is ballooned, \"\n\t\t\"swapped, or has never been accessed is excluded.\",\n\t\tPAPI_HUGE_STR_LEN );\n\tstrcpy( _vmware_native_table[num_events].units,\"MB\");\n\t_vmware_native_table[num_events].which_counter=\n\t        VMWARE_MEM_MAPPED_MB;\n\t_vmware_native_table[num_events].report_difference=0;\n\tnum_events++;\n\n\tstrcpy( _vmware_native_table[num_events].name,\n\t\t\"MEM_OVERHEAD\" );\n\tstrncpy( _vmware_native_table[num_events].description,\n\t\t\"Retrieves the amount of 'overhead' memory associated \"\n\t\t\"with this virtual machine that is currently consumed \"\n\t\t\"on the host system in MB. Overhead memory is additional \"\n\t\t\"memory that is reserved for data structures required by \"\n\t\t\"the virtualization layer.\",\n\t\tPAPI_HUGE_STR_LEN );\n\tstrcpy( _vmware_native_table[num_events].units,\"MB\");\n\t_vmware_native_table[num_events].which_counter=\n\t        VMWARE_MEM_OVERHEAD_MB;\n\t_vmware_native_table[num_events].report_difference=0;\n\tnum_events++;\n\n\tstrcpy( _vmware_native_table[num_events].name,\n\t\t\"MEM_RESERVATION\" );\n\tstrncpy( _vmware_native_table[num_events].description,\n\t\t\"Retrieves the minimum amount of memory that is \"\n\t\t\"reserved for the virtual machine in MB.\",\n\t\tPAPI_HUGE_STR_LEN );\n\tstrcpy( _vmware_native_table[num_events].units,\"MB\");\n\t_vmware_native_table[num_events].which_counter=\n\t        VMWARE_MEM_RESERVATION_MB;\n\t_vmware_native_table[num_events].report_difference=0;\n\tnum_events++;\n\n\tstrcpy( _vmware_native_table[num_events].name,\n\t\t\"MEM_SHARED\" );\n\tstrncpy( _vmware_native_table[num_events].description,\n\t\t\"Retrieves the amount of physical memory associated \"\n\t\t\"with this virtual machine that is copy-on-write (COW) \"\n\t\t\"shared on the host in MB.\",\n\t\tPAPI_HUGE_STR_LEN );\n\tstrcpy( _vmware_native_table[num_events].units,\"MB\");\n\t_vmware_native_table[num_events].which_counter=\n\t        VMWARE_MEM_SHARED_MB;\n\t_vmware_native_table[num_events].report_difference=0;\n\tnum_events++;\n\n\tstrcpy( _vmware_native_table[num_events].name,\n\t\t\"MEM_SHARES\" );\n\tstrncpy( _vmware_native_table[num_events].description,\n\t\t\"Retrieves the number of memory shares allocated to \"\n\t\t\"the virtual machine.\",\n\t\tPAPI_HUGE_STR_LEN );\n\tstrcpy( _vmware_native_table[num_events].units,\"shares\");\n\t_vmware_native_table[num_events].which_counter=\n\t        VMWARE_MEM_SHARES;\n\t_vmware_native_table[num_events].report_difference=0;\n\tnum_events++;\n\n\tstrcpy( _vmware_native_table[num_events].name,\n\t\t\"MEM_SWAPPED\" );\n\tstrncpy( _vmware_native_table[num_events].description,\n\t\t\"Retrieves the amount of memory that has been reclaimed \"\n\t\t\"from this virtual machine by transparently swapping \"\n\t\t\"guest memory to disk in MB.\",\n\t\tPAPI_HUGE_STR_LEN );\n\tstrcpy( _vmware_native_table[num_events].units,\"MB\");\n\t_vmware_native_table[num_events].which_counter=\n\t        VMWARE_MEM_SWAPPED_MB;\n\t_vmware_native_table[num_events].report_difference=0;\n\tnum_events++;\n\n\tstrcpy( _vmware_native_table[num_events].name,\n\t\t\"MEM_TARGET_SIZE\" );\n\tstrncpy( _vmware_native_table[num_events].description,\n\t\t\"Retrieves the size of the target memory allocation \"\n\t\t\"for this virtual machine in MB.\",\n\t\tPAPI_HUGE_STR_LEN );\n\tstrcpy( _vmware_native_table[num_events].units,\"MB\");\n\t_vmware_native_table[num_events].which_counter=\n\t        VMWARE_MEM_TARGET_SIZE_MB;\n\t_vmware_native_table[num_events].report_difference=0;\n\tnum_events++;\n\n\tstrcpy( _vmware_native_table[num_events].name,\n\t\t\"MEM_USED\" );\n\tstrncpy( _vmware_native_table[num_events].description,\n\t\t\"Retrieves the estimated amount of physical host memory \"\n\t\t\"currently consumed for this virtual machine's \"\n\t\t\"physical memory.\",\n\t\tPAPI_HUGE_STR_LEN );\n\tstrcpy( _vmware_native_table[num_events].units,\"MB\");\n\t_vmware_native_table[num_events].which_counter=\n\t        VMWARE_MEM_USED_MB;\n\t_vmware_native_table[num_events].report_difference=0;\n\tnum_events++;\n\n\tstrcpy( _vmware_native_table[num_events].name,\n\t\t\"HOST_CPU\" );\n\tstrncpy( _vmware_native_table[num_events].description,\n\t\t\"Retrieves the speed of the ESX system's physical \"\n\t\t\"CPU in MHz.\",\n\t\tPAPI_HUGE_STR_LEN );\n\tstrcpy( _vmware_native_table[num_events].units,\"MHz\");\n\t_vmware_native_table[num_events].which_counter=\n\t        VMWARE_HOST_CPU_MHZ;\n\t_vmware_native_table[num_events].report_difference=0;\n\tnum_events++;\n\t}\n\n#endif\n\n\t/* For VMWare Pseudo Performance Counters */\n\tif ( getenv( \"PAPI_VMWARE_PSEUDOPERFORMANCE\" ) ) {\n\n\t        use_pseudo=1;\n\n\t\tstrcpy( _vmware_native_table[num_events].name,\n\t\t\t\"HOST_TSC\" );\n\t\tstrncpy( _vmware_native_table[num_events].description,\n\t\t\t\"Physical host TSC\",\n\t\t\tPAPI_HUGE_STR_LEN );\n\t\tstrcpy( _vmware_native_table[num_events].units,\"cycles\");\n\t\t_vmware_native_table[num_events].which_counter=\n\t\t        VMWARE_HOST_TSC;\n\t        _vmware_native_table[num_events].report_difference=1;\n\t\tnum_events++;\n\n\t\tstrcpy( _vmware_native_table[num_events].name,\n\t\t\t\"ELAPSED_TIME\" );\n\t\tstrncpy( _vmware_native_table[num_events].description,\n\t\t\t\"Elapsed real time in ns.\",\n\t\t\tPAPI_HUGE_STR_LEN );\n\t        strcpy( _vmware_native_table[num_events].units,\"ns\");\n\t\t_vmware_native_table[num_events].which_counter=\n\t\t        VMWARE_ELAPSED_TIME;\n\t        _vmware_native_table[num_events].report_difference=1;\n\t\tnum_events++;\n\n\t\tstrcpy( _vmware_native_table[num_events].name,\n\t\t\t\"ELAPSED_APPARENT\" );\n\t\tstrncpy( _vmware_native_table[num_events].description,\n\t\t\t\"Elapsed apparent time in ns.\",\n\t\t\tPAPI_HUGE_STR_LEN );\n\t        strcpy( _vmware_native_table[num_events].units,\"ns\");\n\t\t_vmware_native_table[num_events].which_counter=\n\t\t        VMWARE_ELAPSED_APPARENT;\n\t        _vmware_native_table[num_events].report_difference=1;\n\t\tnum_events++;\n\t}\n\n\tif (num_events==0) {\n\t   strncpy(_vmware_vector.cmp_info.disabled_reason,\n\t\t  \"VMware SDK not installed, and PAPI_VMWARE_PSEUDOPERFORMANCE not set\",\n\t\t   PAPI_MAX_STR_LEN);\n\t  return PAPI_ECMP;\n\t}\n\n\t_vmware_vector.cmp_info.num_native_events = num_events;\n\n\treturn PAPI_OK;\n}\n\n/** Setup the counter control structure */\nint\n_vmware_init_control_state( hwd_control_state_t *ctl )\n{\n  (void) ctl;\n\n\treturn PAPI_OK;\n}\n\n/** Enumerate Native Events \n @param EventCode is the event of interest\n @param modifier is one of PAPI_ENUM_FIRST, PAPI_ENUM_EVENTS\n */\nint\n_vmware_ntv_enum_events( unsigned int *EventCode, int modifier )\n{\n\n\tswitch ( modifier ) {\n\t\t\t/* return EventCode of first event */\n\t\tcase PAPI_ENUM_FIRST:\n\t\t     if (num_events==0) return PAPI_ENOEVNT;\n\t\t     *EventCode = 0;\n\t\t     return PAPI_OK;\n\t\t     break;\n\t\t\t/* return EventCode of passed-in Event */\n\t\tcase PAPI_ENUM_EVENTS:{\n\t\t     int index = *EventCode;\n\n\t\t     if ( index < num_events - 1 ) {\n\t\t\t*EventCode = *EventCode + 1;\n\t\t\treturn PAPI_OK;\n\t\t     } else {\n\t\t\treturn PAPI_ENOEVNT;\n\t\t     }\n\t\t     break;\n\t\t}\n\t\tdefault:\n\t\t     return PAPI_EINVAL;\n\t}\n\treturn PAPI_EINVAL;\n}\n\nint\n_vmware_ntv_code_to_info(unsigned int EventCode, PAPI_event_info_t *info) \n{\n\n  int index = EventCode;\n\n  if ( ( index < 0) || (index >= num_events )) return PAPI_ENOEVNT;\n\n  strncpy( info->symbol, _vmware_native_table[index].name, \n           sizeof(info->symbol));\n\n  strncpy( info->long_descr, _vmware_native_table[index].description, \n           sizeof(info->symbol));\n\n  strncpy( info->units, _vmware_native_table[index].units, \n           sizeof(info->units));\n\n  return PAPI_OK;\n}\n\n\n/** Takes a native event code and passes back the name \n @param EventCode is the native event code\n @param name is a pointer for the name to be copied to\n @param len is the size of the string\n */\nint\n_vmware_ntv_code_to_name( unsigned int EventCode, char *name, int len )\n{\n\tint index = EventCode;\n\n\tif ( index >= 0 && index < num_events ) {\n\t   strncpy( name, _vmware_native_table[index].name, len );\n\t}\n\treturn PAPI_OK;\n}\n\n/** Takes a native event code and passes back the event description\n @param EventCode is the native event code\n @param name is a pointer for the description to be copied to\n @param len is the size of the string\n */\nint\n_vmware_ntv_code_to_descr( unsigned int EventCode, char *name, int len )\n{\n  int index = EventCode;\n\n\tif ( index >= 0 && index < num_events ) {\n\t   strncpy( name, _vmware_native_table[index].description, len );\n\t}\n\treturn PAPI_OK;\n}\n\n/** Triggered by eventset operations like add or remove */\nint\n_vmware_update_control_state( hwd_control_state_t *ctl, \n\t\t\t      NativeInfo_t *native, \n\t\t\t      int count, \n\t\t\t      hwd_context_t *ctx )\n{\n\t(void) ctx;\n\n\tstruct _vmware_control_state *control;\n\n\tint i, index;\n\n\tcontrol=(struct _vmware_control_state *)ctl;\n\n\tfor ( i = 0; i < count; i++ ) {\n\t    index = native[i].ni_event;\n\t    control->which_counter[i]=_vmware_native_table[index].which_counter;\n\t    native[i].ni_position = i;\n\t}\n\tcontrol->num_events=count;\n\n\treturn PAPI_OK;\n}\n\n/** Triggered by PAPI_start() */\nint\n_vmware_start( hwd_context_t *ctx, hwd_control_state_t *ctl )\n{\n\tstruct _vmware_context *context;\n\t(void) ctl;\n\n\tcontext=(struct _vmware_context *)ctx;\n\n\t_vmware_hardware_read( context, 1 );\n\n\treturn PAPI_OK;\n}\n\n/** Triggered by PAPI_stop() */\nint\n_vmware_stop( hwd_context_t *ctx, hwd_control_state_t *ctl )\n{\n\n\tstruct _vmware_context *context;\n\t(void) ctl;\n\n\tcontext=(struct _vmware_context *)ctx;\n\n\t_vmware_hardware_read( context, 0 );\t\n\n\treturn PAPI_OK;\n}\n\n/** Triggered by PAPI_read() */\nint\n_vmware_read( hwd_context_t *ctx, \n\t      hwd_control_state_t *ctl,\n\t      long_long **events, int flags )\n{\n\n\tstruct _vmware_context *context;\n\tstruct _vmware_control_state *control;\n\n\t(void) flags;\n\tint i;\n\n\tcontext=(struct _vmware_context *)ctx;\n\tcontrol=(struct _vmware_control_state *)ctl;\n\n\t_vmware_hardware_read( context, 0 );\n\n\tfor (i=0; i<control->num_events; i++) {\n\t  \n\t  if (_vmware_native_table[\n              _vmware_native_table[control->which_counter[i]].which_counter].\n             report_difference) {\n\t     control->value[i]=context->values[control->which_counter[i]]-\n\t                       context->start_values[control->which_counter[i]];\n\t  } else {\n\t     control->value[i]=context->values[control->which_counter[i]];\n\t  }\n\t  //\t  printf(\"%d %d %lld-%lld=%lld\\n\",i,control->which_counter[i],\n\t  // context->values[control->which_counter[i]],\n\t  //\t context->start_values[control->which_counter[i]],\n\t  //\t control->value[i]);\n\n\t}\n\n\t*events = control->value;\n\n\treturn PAPI_OK;\n}\n\n/** Triggered by PAPI_write(), but only if the counters are running */\n/*    otherwise, the updated state is written to ESI->hw_start      */\nint\n_vmware_write( hwd_context_t * ctx, hwd_control_state_t * ctrl, long_long events[] )\n{\n\t(void) ctx;\n\t(void) ctrl;\n\t(void) events;\n\tSUBDBG( \"_vmware_write... %p %p\", ctx, ctrl );\n\t/* FIXME... this should actually carry out the write, though     */\n\t/*  this is non-trivial as which counter being written has to be */\n\t/*  determined somehow.                                          */\n\treturn PAPI_OK;\n}\n\n/** Triggered by PAPI_reset */\nint\n_vmware_reset( hwd_context_t *ctx, hwd_control_state_t *ctl )\n{\n\t(void) ctx;\n\t(void) ctl;\n\n\treturn PAPI_OK;\n}\n\n/** Shutting down a context */\nint\n_vmware_shutdown_thread( hwd_context_t *ctx )\n{\n\t(void) ctx;\n\n#ifdef VMGUESTLIB\n        VMGuestLibError glError;\n\tstruct _vmware_context *context;\n\n\tcontext=(struct _vmware_context *)ctx;\n\n\tif (use_guestlib) {\n           glError = GuestLib_CloseHandle(context->glHandle);\n           if (glError != VMGUESTLIB_ERROR_SUCCESS) {\n               fprintf(stderr, \"Failed to CloseHandle: %s\\n\", \n\t\t       GuestLib_GetErrorText(glError));\n               return PAPI_ECMP;\n\t   }\n\t}\n#endif\n\n\treturn PAPI_OK;\n}\n\n/** Triggered by PAPI_shutdown() */\nint\n_vmware_shutdown_component( void )\n{\n\n#ifdef VMGUESTLIB\n\tif (dlclose(dlHandle)) {\n\t\tfprintf(stderr, \"dlclose failed\\n\");\n\t\treturn EXIT_FAILURE;\n\t}\n#endif\n\n\treturn PAPI_OK;\n}\n\n\n/** This function sets various options in the component\n @param ctx\n @param code valid are PAPI_SET_DEFDOM, PAPI_SET_DOMAIN, PAPI_SETDEFGRN, PAPI_SET_GRANUL and PAPI_SET_INHERIT\n @param option\n */\nint\n_vmware_ctl( hwd_context_t *ctx, int code, _papi_int_option_t *option )\n{\n\n\t(void) ctx;\n\t(void) code;\n\t(void) option;\n\n\tSUBDBG( \"_vmware_ctl...\" );\n\n\treturn PAPI_OK;\n}\n\n/** This function has to set the bits needed to count different domains\n In particular: PAPI_DOM_USER, PAPI_DOM_KERNEL PAPI_DOM_OTHER\n By default return PAPI_EINVAL if none of those are specified\n and PAPI_OK with success\n PAPI_DOM_USER is only user context is counted\n PAPI_DOM_KERNEL is only the Kernel/OS context is counted\n PAPI_DOM_OTHER  is Exception/transient mode (like user TLB misses)\n PAPI_DOM_ALL   is all of the domains\n */\nint\n_vmware_set_domain( hwd_control_state_t *ctl, int domain )\n{\n\t(void) ctl;\n\n\tint found = 0;\n\tSUBDBG( \"_vmware_set_domain...\" );\n\tif ( PAPI_DOM_USER & domain ) {\n\t\tSUBDBG( \" PAPI_DOM_USER \" );\n\t\tfound = 1;\n\t}\n\tif ( PAPI_DOM_KERNEL & domain ) {\n\t\tSUBDBG( \" PAPI_DOM_KERNEL \" );\n\t\tfound = 1;\n\t}\n\tif ( PAPI_DOM_OTHER & domain ) {\n\t\tSUBDBG( \" PAPI_DOM_OTHER \" );\n\t\tfound = 1;\n\t}\n\tif ( PAPI_DOM_ALL & domain ) {\n\t\tSUBDBG( \" PAPI_DOM_ALL \" );\n\t\tfound = 1;\n\t}\n\tif ( !found ) {\n\t\treturn ( PAPI_EINVAL );\n\t}\n\treturn PAPI_OK;\n}\n\n/** Vector that points to entry points for our component */\npapi_vector_t _vmware_vector = {\n\t.cmp_info = {\n\t\t/* default component information (unspecified values are initialized to 0) */\n\t\t.name = \"vmware\",\n\t\t.short_name = \"vmware\",\n\t\t.description = \"Provide support for VMware vmguest and pseudo counters\",\n\t\t.version = \"5.0\",\n\t\t.num_mpx_cntrs = VMWARE_MAX_COUNTERS,\n\t\t.num_cntrs = VMWARE_MAX_COUNTERS,\n\t\t.default_domain = PAPI_DOM_USER,\n\t\t.available_domains = PAPI_DOM_USER,\n\t\t.default_granularity = PAPI_GRN_THR,\n\t\t.available_granularities = PAPI_GRN_THR,\n\t\t.hardware_intr_sig = PAPI_INT_SIGNAL,\n\n\t\t/* component specific cmp_info initializations */\n\t\t.fast_real_timer = 0,\n\t\t.fast_virtual_timer = 0,\n\t\t.attach = 0,\n\t\t.attach_must_ptrace = 0,\n\t},\n\t/* sizes of framework-opaque component-private structures */\n\t.size = {\n\t\t.context = sizeof ( struct _vmware_context ),\n\t\t.control_state = sizeof ( struct _vmware_control_state ),\n\t\t.reg_value = sizeof ( struct _vmware_register ),\n\t\t.reg_alloc = sizeof ( struct _vmware_reg_alloc ),\n\t}\n\t,\n\t/* function pointers in this component */\n\t.init_thread =        _vmware_init_thread,\n\t.init_component =     _vmware_init_component,\n\t.init_control_state = _vmware_init_control_state,\n\t.start =              _vmware_start,\n\t.stop =               _vmware_stop,\n\t.read =               _vmware_read,\n\t.write =              _vmware_write,\n\t.shutdown_thread =    _vmware_shutdown_thread,\n\t.shutdown_component = _vmware_shutdown_component,\n\t.ctl =                _vmware_ctl,\n\n\t.update_control_state = _vmware_update_control_state,\n\t.set_domain = _vmware_set_domain,\n\t.reset = _vmware_reset,\n\n\t.ntv_enum_events = _vmware_ntv_enum_events,\n\t.ntv_code_to_name = _vmware_ntv_code_to_name,\n\t.ntv_code_to_descr = _vmware_ntv_code_to_descr,\n\t.ntv_code_to_info = _vmware_ntv_code_to_info,\n\n};\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.6.0-iweh6uy7qfzcgjj77nhy45ucjhpm2ow6/spack-src/src/components/nvml/linux-nvml.c": "/****************************\nTHIS IS OPEN SOURCE CODE\n\nPart of the PAPI software library. Copyright (c) 2005 - 2017,\nInnovative Computing Laboratory, Dept of Electrical Engineering &\nComputer Science University of Tennessee, Knoxville, TN.\n\nThe open source software license conforms to the 2-clause BSD License\ntemplate.\n\n****************************/\n\n/**\n * @file    linux-nvml.c\n * @author  Kiran Kumar Kasichayanula\n *          kkasicha@utk.edu\n * @author  James Ralph\n *          ralph@eecs.utk.edu\n * @ingroup papi_components\n *\n * @brief This is an NVML component, it demos the component interface\n *  and implements a number of counters from the Nvidia Management\n *  Library. Please refer to NVML documentation for details about\n *  nvmlDeviceGetPowerUsage, nvmlDeviceGetTemperature. Power is\n *  reported in mW and temperature in Celcius.  The counter\n *  descriptions should contain the units that the measurement\n *  returns.\n */\n#include <dlfcn.h>\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <inttypes.h>\n#include <string.h>\n/* Headers required by PAPI */\n#include \"papi.h\"\n#include \"papi_internal.h\"\n#include \"papi_vector.h\"\n#include \"papi_memory.h\"\n\n#include \"linux-nvml.h\"\n\n#include \"nvml.h\"\n#include \"cuda.h\"\n#include \"cuda_runtime_api.h\"\n\nvoid (*_dl_non_dynamic_init)(void) __attribute__((weak));\n\n/*****  CHANGE PROTOTYPES TO DECLARE CUDA AND NVML LIBRARY SYMBOLS AS WEAK  *****\n *  This is done so that a version of PAPI built with the nvml component can    *\n *  be installed on a system which does not have the cuda libraries installed.  *\n *                                                                              *\n *  If this is done without these prototypes, then all papi services on the     *\n *  system without the cuda libraries installed will fail.  The PAPI libraries  *\n *  contain references to the cuda libraries which are not installed.  The      *\n *  load of PAPI commands fails because the cuda library references can not be  *\n *  resolved.                                                                   *\n *                                                                              *\n *  This also defines pointers to the cuda library functions that we call.      *\n *  These function pointers will be resolved with dlopen/dlsym calls at         *\n *  component initialization time.  The component then calls the cuda library   *\n *  functions through these function pointers.                                  *\n ********************************************************************************/\n#undef CUDAAPI\n#define CUDAAPI __attribute__((weak))\nCUresult CUDAAPI cuInit(unsigned int);\n\nCUresult(*cuInitPtr)(unsigned int);\n\n#undef CUDARTAPI\n#define CUDARTAPI __attribute__((weak))\ncudaError_t CUDARTAPI cudaGetDevice(int *);\ncudaError_t CUDARTAPI cudaGetDeviceCount(int *);\ncudaError_t CUDARTAPI cudaDeviceGetPCIBusId(char *, int, int);\n\ncudaError_t (*cudaGetDevicePtr)(int *);\ncudaError_t (*cudaGetDeviceCountPtr)(int *);\ncudaError_t (*cudaDeviceGetPCIBusIdPtr)(char *, int, int);\n\n#undef DECLDIR\n#define DECLDIR __attribute__((weak))\nnvmlReturn_t DECLDIR nvmlDeviceGetClockInfo(nvmlDevice_t, nvmlClockType_t, unsigned int *);\nconst char*  DECLDIR nvmlErrorString(nvmlReturn_t);\nnvmlReturn_t DECLDIR nvmlDeviceGetDetailedEccErrors(nvmlDevice_t, nvmlEccBitType_t, nvmlEccCounterType_t, nvmlEccErrorCounts_t *);\nnvmlReturn_t DECLDIR nvmlDeviceGetFanSpeed(nvmlDevice_t, unsigned int *);\nnvmlReturn_t DECLDIR nvmlDeviceGetMemoryInfo(nvmlDevice_t, nvmlMemory_t *);\nnvmlReturn_t DECLDIR nvmlDeviceGetPerformanceState(nvmlDevice_t, nvmlPstates_t *);\nnvmlReturn_t DECLDIR nvmlDeviceGetPowerUsage(nvmlDevice_t, unsigned int *);\nnvmlReturn_t DECLDIR nvmlDeviceGetTemperature(nvmlDevice_t, nvmlTemperatureSensors_t, unsigned int *);\nnvmlReturn_t DECLDIR nvmlDeviceGetTotalEccErrors(nvmlDevice_t, nvmlEccBitType_t, nvmlEccCounterType_t, unsigned long long *);\nnvmlReturn_t DECLDIR nvmlDeviceGetUtilizationRates(nvmlDevice_t, nvmlUtilization_t *);\nnvmlReturn_t DECLDIR nvmlDeviceGetHandleByIndex(unsigned int, nvmlDevice_t *);\nnvmlReturn_t DECLDIR nvmlDeviceGetPciInfo(nvmlDevice_t, nvmlPciInfo_t *);\nnvmlReturn_t DECLDIR nvmlDeviceGetName(nvmlDevice_t, char *, unsigned int);\nnvmlReturn_t DECLDIR nvmlDeviceGetInforomVersion(nvmlDevice_t, nvmlInforomObject_t, char *, unsigned int);\nnvmlReturn_t DECLDIR nvmlDeviceGetEccMode(nvmlDevice_t, nvmlEnableState_t *, nvmlEnableState_t *);\nnvmlReturn_t DECLDIR nvmlInit(void);\nnvmlReturn_t DECLDIR nvmlDeviceGetCount(unsigned int *);\nnvmlReturn_t DECLDIR nvmlShutdown(void);\nnvmlReturn_t DECLDIR nvmlDeviceGetPowerManagementLimit(nvmlDevice_t device, unsigned int* limit);\nnvmlReturn_t DECLDIR nvmlDeviceSetPowerManagementLimit(nvmlDevice_t device, unsigned int  limit);\nnvmlReturn_t DECLDIR nvmlDeviceGetPowerManagementLimitConstraints(nvmlDevice_t device, unsigned int* minLimit, unsigned int* maxLimit);\n\nnvmlReturn_t (*nvmlDeviceGetClockInfoPtr)(nvmlDevice_t, nvmlClockType_t, unsigned int *);\nchar* (*nvmlErrorStringPtr)(nvmlReturn_t);\nnvmlReturn_t (*nvmlDeviceGetDetailedEccErrorsPtr)(nvmlDevice_t, nvmlEccBitType_t, nvmlEccCounterType_t, nvmlEccErrorCounts_t *);\nnvmlReturn_t (*nvmlDeviceGetFanSpeedPtr)(nvmlDevice_t, unsigned int *);\nnvmlReturn_t (*nvmlDeviceGetMemoryInfoPtr)(nvmlDevice_t, nvmlMemory_t *);\nnvmlReturn_t (*nvmlDeviceGetPerformanceStatePtr)(nvmlDevice_t, nvmlPstates_t *);\nnvmlReturn_t (*nvmlDeviceGetPowerUsagePtr)(nvmlDevice_t, unsigned int *);\nnvmlReturn_t (*nvmlDeviceGetTemperaturePtr)(nvmlDevice_t, nvmlTemperatureSensors_t, unsigned int *);\nnvmlReturn_t (*nvmlDeviceGetTotalEccErrorsPtr)(nvmlDevice_t, nvmlEccBitType_t, nvmlEccCounterType_t, unsigned long long *);\nnvmlReturn_t (*nvmlDeviceGetUtilizationRatesPtr)(nvmlDevice_t, nvmlUtilization_t *);\nnvmlReturn_t (*nvmlDeviceGetHandleByIndexPtr)(unsigned int, nvmlDevice_t *);\nnvmlReturn_t (*nvmlDeviceGetPciInfoPtr)(nvmlDevice_t, nvmlPciInfo_t *);\nnvmlReturn_t (*nvmlDeviceGetNamePtr)(nvmlDevice_t, char *, unsigned int);\nnvmlReturn_t (*nvmlDeviceGetInforomVersionPtr)(nvmlDevice_t, nvmlInforomObject_t, char *, unsigned int);\nnvmlReturn_t (*nvmlDeviceGetEccModePtr)(nvmlDevice_t, nvmlEnableState_t *, nvmlEnableState_t *);\nnvmlReturn_t (*nvmlInitPtr)(void);\nnvmlReturn_t (*nvmlDeviceGetCountPtr)(unsigned int *);\nnvmlReturn_t (*nvmlShutdownPtr)(void);\nnvmlReturn_t (*nvmlDeviceGetPowerManagementLimitPtr)(nvmlDevice_t device, unsigned int* limit);\nnvmlReturn_t (*nvmlDeviceSetPowerManagementLimitPtr)(nvmlDevice_t device, unsigned int  limit);\nnvmlReturn_t (*nvmlDeviceGetPowerManagementLimitConstraintsPtr)(nvmlDevice_t device, unsigned int* minLimit, unsigned int* maxLimit);\n\n// file handles used to access cuda libraries with dlopen\nstatic void* dl1 = NULL;\nstatic void* dl2 = NULL;\nstatic void* dl3 = NULL;\n\nstatic int linkCudaLibraries();\n\n/* Declare our vector in advance */\npapi_vector_t _nvml_vector;\n\n/* upto 25 events per card how many cards per system should we allow for?! */\n#define NVML_MAX_COUNTERS 100\n\n/** Holds control flags.  Usually there's one of these per event-set.\n *    Usually this is out-of band configuration of the hardware\n */\ntypedef struct nvml_control_state {\n    int num_events;\n    int which_counter[NVML_MAX_COUNTERS];\n    long long counter[NVML_MAX_COUNTERS];   /**< Copy of counts, holds results when stopped */\n} nvml_control_state_t;\n\n/** Holds per-thread information */\ntypedef struct nvml_context {\n    nvml_control_state_t state;\n} nvml_context_t;\n\n/** This table contains the native events */\nstatic nvml_native_event_entry_t *nvml_native_table = NULL;\n\n/** Number of devices detected at component_init time */\nstatic int device_count = 0;\n\n/** number of events in the table*/\nstatic int num_events = 0;\n\nstatic nvmlDevice_t* devices = NULL;\nstatic int* features = NULL;\nstatic unsigned int *power_management_initial_limit = NULL;\nstatic unsigned int *power_management_limit_constraint_min = NULL;\nstatic unsigned int *power_management_limit_constraint_max = NULL;\n\nunsigned long long\ngetClockSpeed(nvmlDevice_t dev, nvmlClockType_t which_one)\n{\n    unsigned int ret = 0;\n    nvmlReturn_t bad;\n    bad = (*nvmlDeviceGetClockInfoPtr)(dev, which_one, &ret);\n\n    if (NVML_SUCCESS != bad) {\n        SUBDBG(\"something went wrong %s\\n\", (*nvmlErrorStringPtr)(bad));\n    }\n\n    return (unsigned long long)ret;\n}\n\nunsigned long long\ngetEccLocalErrors(nvmlDevice_t dev, nvmlEccBitType_t bits, int which_one)\n{\n    nvmlEccErrorCounts_t counts;\n\n    nvmlReturn_t bad;\n    bad = (*nvmlDeviceGetDetailedEccErrorsPtr)(dev, bits, NVML_VOLATILE_ECC , &counts);\n\n    if (NVML_SUCCESS != bad) {\n        SUBDBG(\"something went wrong %s\\n\", (*nvmlErrorStringPtr)(bad));\n    }\n    switch (which_one) {\n    case LOCAL_ECC_REGFILE:\n        return counts.registerFile;\n    case LOCAL_ECC_L1:\n        return counts.l1Cache;\n    case LOCAL_ECC_L2:\n        return counts.l2Cache;\n    case LOCAL_ECC_MEM:\n        return counts.deviceMemory;\n    default:\n        ;\n    }\n    return (unsigned long long) - 1;\n}\n\nunsigned long long\ngetFanSpeed(nvmlDevice_t dev)\n{\n    unsigned int ret = 0;\n    nvmlReturn_t bad;\n    bad = (*nvmlDeviceGetFanSpeedPtr)(dev, &ret);\n\n    if (NVML_SUCCESS != bad) {\n        SUBDBG(\"something went wrong %s\\n\", (*nvmlErrorStringPtr)(bad));\n    }\n    return (unsigned long long)ret;\n}\n\nunsigned long long\ngetMaxClockSpeed(nvmlDevice_t dev, nvmlClockType_t which_one)\n{\n    unsigned int ret = 0;\n    nvmlReturn_t bad;\n    bad = (*nvmlDeviceGetClockInfoPtr)(dev, which_one, &ret);\n\n    if (NVML_SUCCESS != bad) {\n        SUBDBG(\"something went wrong %s\\n\", (*nvmlErrorStringPtr)(bad));\n    }\n    return (unsigned long long) ret;\n}\n\nunsigned long long\ngetMemoryInfo(nvmlDevice_t dev, int which_one)\n{\n    nvmlMemory_t meminfo;\n    nvmlReturn_t bad;\n    bad = (*nvmlDeviceGetMemoryInfoPtr)(dev, &meminfo);\n\n    if (NVML_SUCCESS != bad) {\n        SUBDBG(\"something went wrong %s\\n\", (*nvmlErrorStringPtr)(bad));\n    }\n\n    switch (which_one) {\n    case MEMINFO_TOTAL_MEMORY:\n        return meminfo.total;\n    case MEMINFO_UNALLOCED:\n        return meminfo.free;\n    case MEMINFO_ALLOCED:\n        return meminfo.used;\n    default:\n        ;\n    }\n    return (unsigned long long) - 1;\n}\n\nunsigned long long\ngetPState(nvmlDevice_t dev)\n{\n    unsigned int ret = 0;\n    nvmlPstates_t state = NVML_PSTATE_15;\n    nvmlReturn_t bad;\n    bad = (*nvmlDeviceGetPerformanceStatePtr)(dev, &state);\n\n    if (NVML_SUCCESS != bad) {\n        SUBDBG(\"something went wrong %s\\n\", (*nvmlErrorStringPtr)(bad));\n    }\n    switch (state) {\n    case NVML_PSTATE_15:\n        ret++;\n    case NVML_PSTATE_14:\n        ret++;\n    case NVML_PSTATE_13:\n        ret++;\n    case NVML_PSTATE_12:\n        ret++;\n    case NVML_PSTATE_11:\n        ret++;\n    case NVML_PSTATE_10:\n        ret++;\n    case NVML_PSTATE_9:\n        ret++;\n    case NVML_PSTATE_8:\n        ret++;\n    case NVML_PSTATE_7:\n        ret++;\n    case NVML_PSTATE_6:\n        ret++;\n    case NVML_PSTATE_5:\n        ret++;\n    case NVML_PSTATE_4:\n        ret++;\n    case NVML_PSTATE_3:\n        ret++;\n    case NVML_PSTATE_2:\n        ret++;\n    case NVML_PSTATE_1:\n        ret++;\n    case NVML_PSTATE_0:\n        break;\n    case NVML_PSTATE_UNKNOWN:\n    default:\n        /* This should never happen?\n         * The API docs just state Unknown performance state... */\n        return (unsigned long long) - 1;\n    }\n    return (unsigned long long)ret;\n}\n\nunsigned long long\ngetPowerUsage(nvmlDevice_t dev)\n{\n    unsigned int power;\n    nvmlReturn_t bad;\n    bad = (*nvmlDeviceGetPowerUsagePtr)(dev, &power);\n\n    if (NVML_SUCCESS != bad) {\n        SUBDBG(\"something went wrong %s\\n\", (*nvmlErrorStringPtr)(bad));\n    }\n    return (unsigned long long) power;\n}\n\nunsigned long long\ngetTemperature(nvmlDevice_t dev)\n{\n    unsigned int ret = 0;\n    nvmlReturn_t bad;\n    bad = (*nvmlDeviceGetTemperaturePtr)(dev, NVML_TEMPERATURE_GPU, &ret);\n\n    if (NVML_SUCCESS != bad) {\n        SUBDBG(\"something went wrong %s\\n\", (*nvmlErrorStringPtr)(bad));\n    }\n    return (unsigned long long)ret;\n}\n\nunsigned long long\ngetTotalEccErrors(nvmlDevice_t dev, nvmlEccBitType_t bits)\n{\n    unsigned long long counts = 0;\n    nvmlReturn_t bad;\n    bad = (*nvmlDeviceGetTotalEccErrorsPtr)(dev, bits, NVML_VOLATILE_ECC , &counts);\n\n    if (NVML_SUCCESS != bad) {\n        SUBDBG(\"something went wrong %s\\n\", (*nvmlErrorStringPtr)(bad));\n    }\n    return counts;\n}\n\n/*  0 => gpu util\n    1 => memory util\n */\nunsigned long long\ngetUtilization(nvmlDevice_t dev, int which_one)\n{\n    nvmlUtilization_t util;\n    nvmlReturn_t bad;\n    bad = (*nvmlDeviceGetUtilizationRatesPtr)(dev, &util);\n\n    if (NVML_SUCCESS != bad) {\n        SUBDBG(\"something went wrong %s\\n\", (*nvmlErrorStringPtr)(bad));\n    }\n\n    switch (which_one) {\n    case GPU_UTILIZATION:\n        return (unsigned long long) util.gpu;\n    case MEMORY_UTILIZATION:\n        return (unsigned long long) util.memory;\n    default:\n        ;\n    }\n\n    return (unsigned long long) - 1;\n}\n\nunsigned long long getPowerManagementLimit(nvmlDevice_t dev)\n{\n    unsigned int limit;\n    nvmlReturn_t rv;\n    rv = (*nvmlDeviceGetPowerManagementLimitPtr)(dev, &limit);\n    if (NVML_SUCCESS != rv) {\n        SUBDBG(\"something went wrong %s\\n\", (*nvmlErrorStringPtr)(rv));\n        return (unsigned long long) 0;\n    }\n    return (unsigned long long) limit;\n}\n\nstatic void\nnvml_hardware_reset()\n{\n    /* nvmlDeviceSet* and nvmlDeviceClear* calls require root/admin access, so while\n     * possible to implement a reset on the ECC counters, we pass */\n    /*\n       for ( i=0; i < device_count; i++ )\n       nvmlDeviceClearEccErrorCounts( device[i], NVML_VOLATILE_ECC );\n    */\n    int i;\n    nvmlReturn_t ret;\n    unsigned int templimit = 0;\n    for (i = 0; i < device_count; i++) {\n        if (HAS_FEATURE(features[i], FEATURE_POWER_MANAGEMENT)) {\n            // if power management is available\n            if (power_management_initial_limit[i] != 0) {\n                ret = (*nvmlDeviceGetPowerManagementLimitPtr)(devices[i], &templimit);\n                if ((ret == NVML_SUCCESS) && (templimit != power_management_initial_limit[i])) {\n                    SUBDBG(\"Reset power_management_limit on device %d to initial value of %d \\n\", i, power_management_initial_limit[i]);\n                    // if power is not at its initial value\n                    // reset to initial value\n                    ret = (*nvmlDeviceSetPowerManagementLimitPtr)(devices[i], power_management_initial_limit[i]);\n                    if (ret != NVML_SUCCESS)\n                        SUBDBG(\"Unable to reset the NVML power management limit on device %i to %ull (return code %d) \\n\", i, power_management_initial_limit[i] , ret);\n                }\n            }\n        }\n    }\n}\n\n/** Code that reads event values.                         */\n/*   You might replace this with code that accesses       */\n/*   hardware or reads values from the operatings system. */\nstatic int\nnvml_hardware_read(long long *value, int which_one)\n//, nvml_context_t *ctx)\n{\n    nvml_native_event_entry_t *entry;\n    nvmlDevice_t handle;\n    int cudaIdx = -1;\n\n    entry = &nvml_native_table[which_one];\n    *value = (long long) - 1;\n    /* replace entry->resources with the current cuda_device->nvml device */\n    (*cudaGetDevicePtr)(&cudaIdx);\n\n    if (cudaIdx < 0 || cudaIdx > device_count)\n        return PAPI_EINVAL;\n\n    /* Make sure the device we are running on has the requested event */\n    if (!HAS_FEATURE(features[cudaIdx] , entry->type))\n        return PAPI_EINVAL;\n\n    handle = devices[cudaIdx];\n\n    switch (entry->type) {\n    case FEATURE_CLOCK_INFO:\n        *value =  getClockSpeed(handle, (nvmlClockType_t)entry->options.clock);\n        break;\n    case FEATURE_ECC_LOCAL_ERRORS:\n        *value = getEccLocalErrors(handle,\n                                   (nvmlEccBitType_t)entry->options.ecc_opts.bits,\n                                   (int)entry->options.ecc_opts.which_one);\n        break;\n    case FEATURE_FAN_SPEED:\n        *value = getFanSpeed(handle);\n        break;\n    case FEATURE_MAX_CLOCK:\n        *value = getMaxClockSpeed(handle,\n                                  (nvmlClockType_t)entry->options.clock);\n        break;\n    case FEATURE_MEMORY_INFO:\n        *value = getMemoryInfo(handle,\n                               (int)entry->options.which_one);\n        break;\n    case FEATURE_PERF_STATES:\n        *value = getPState(handle);\n        break;\n    case FEATURE_POWER:\n        *value = getPowerUsage(handle);\n        break;\n    case FEATURE_TEMP:\n        *value = getTemperature(handle);\n        break;\n    case FEATURE_ECC_TOTAL_ERRORS:\n        *value = getTotalEccErrors(handle,\n                                   (nvmlEccBitType_t)entry->options.ecc_opts.bits);\n        break;\n    case FEATURE_UTILIZATION:\n        *value = getUtilization(handle,\n                                (int)entry->options.which_one);\n        break;\n    case FEATURE_POWER_MANAGEMENT:\n        *value = getPowerManagementLimit(handle);\n        break;\n\n    case FEATURE_NVML_POWER_MANAGEMENT_LIMIT_CONSTRAINT_MIN:\n        *value = power_management_limit_constraint_min[cudaIdx];\n        break;\n\n    case FEATURE_NVML_POWER_MANAGEMENT_LIMIT_CONSTRAINT_MAX:\n        *value = power_management_limit_constraint_max[cudaIdx];\n        break;\n\n    default:\n        return PAPI_EINVAL;\n    }\n\n    return PAPI_OK;\n}\n\n/** Code that reads event values.                         */\n/*   You might replace this with code that accesses       */\n/*   hardware or reads values from the operatings system. */\nstatic int nvml_hardware_write(long long *value, int which_one)\n{\n    nvml_native_event_entry_t *entry;\n    nvmlDevice_t handle;\n    int cudaIdx = -1;\n    nvmlReturn_t nvret;\n\n    entry = &nvml_native_table[which_one];\n    /* replace entry->resources with the current cuda_device->nvml device */\n    (*cudaGetDevicePtr)(&cudaIdx);\n\n    if (cudaIdx < 0 || cudaIdx > device_count)\n        return PAPI_EINVAL;\n\n    /* Make sure the device we are running on has the requested event */\n    if (!HAS_FEATURE(features[cudaIdx] , entry->type))\n        return PAPI_EINVAL;\n\n    handle = devices[cudaIdx];\n\n    switch (entry->type) {\n    case FEATURE_POWER_MANAGEMENT: {\n        unsigned int setToPower = (unsigned int) * value;\n        if (setToPower < power_management_limit_constraint_min[cudaIdx]) {\n            SUBDBG(\"Error: Desired power %u mW < minimum %u mW on device %d\\n\", setToPower, power_management_limit_constraint_min[cudaIdx], cudaIdx);\n            return PAPI_EINVAL;\n        }\n        if (setToPower > power_management_limit_constraint_max[cudaIdx]) {\n            SUBDBG(\"Error: Desired power %u mW > maximum %u mW on device %d\\n\", setToPower, power_management_limit_constraint_max[cudaIdx], cudaIdx);\n            return PAPI_EINVAL;\n        }\n        if ((nvret = (*nvmlDeviceSetPowerManagementLimitPtr)(handle, setToPower)) != NVML_SUCCESS) {\n            SUBDBG(\"Error: %s\\n\", (*nvmlErrorStringPtr)(nvret));\n            return PAPI_EINVAL;\n        }\n    }\n    break;\n\n    default:\n        return PAPI_EINVAL;\n    }\n\n    return PAPI_OK;\n}\n\n/********************************************************************/\n/* Below are the functions required by the PAPI component interface */\n/********************************************************************/\n\n/** This is called whenever a thread is initialized */\nint\n_papi_nvml_init_thread(hwd_context_t * ctx)\n{\n    (void) ctx;\n\n    SUBDBG(\"Enter: ctx: %p\\n\", ctx);\n\n    return PAPI_OK;\n}\n\nstatic int\ndetectDevices()\n{\n    nvmlReturn_t ret;\n    nvmlEnableState_t mode = NVML_FEATURE_DISABLED;\n\n    char name[64];\n    char inforomECC[16];\n    char inforomPower[16];\n    char names[device_count][64];\n\n    float ecc_version = 0.0;\n    float power_version = 0.0;\n\n    int i = 0;\n    int isTesla = 0;\n    int isFermi = 0;\n\n    unsigned int temp = 0;\n\n    memset(names, 0x0, device_count * 64);\n\n    /* So for each card, check whats querable */\n    for (i = 0; i < device_count; i++) {\n        isTesla = 0;\n        isFermi = 1;\n        features[i] = 0;\n        \n        ret = (*nvmlDeviceGetHandleByIndexPtr)(i, &devices[i]);\n        if (NVML_SUCCESS != ret) {\n            SUBDBG(\"nvmlDeviceGetHandleByIndex(%d, &devices[%d]) failed.\\n\", i, i);\n            return PAPI_ESYS;\n        }\n\n        ret = (*nvmlDeviceGetNamePtr)(devices[i], name, sizeof(name) - 1);\n        if (NVML_SUCCESS != ret) {\n            SUBDBG(\"nvmlDeviceGetName failed \\n\");\n            strncpy(name, \"deviceNameUnknown\", 17);\n        }\n\n        name[sizeof(name) - 1] = '\\0';   // to safely use strstr operation below, the variable 'name' must be null terminated\n\n        ret = (*nvmlDeviceGetInforomVersionPtr)(devices[i], NVML_INFOROM_ECC, inforomECC, 16);\n        if (NVML_SUCCESS != ret) {\n            SUBDBG(\"nvmlGetInforomVersion fails %s\\n\", (*nvmlErrorStringPtr)(ret));\n            isFermi = 0;\n        }\n        ret = (*nvmlDeviceGetInforomVersionPtr)(devices[i], NVML_INFOROM_POWER, inforomPower, 16);\n        if (NVML_SUCCESS != ret) {\n            /* This implies the card is older then Fermi */\n            SUBDBG(\"nvmlGetInforomVersion fails %s\\n\", (*nvmlErrorStringPtr)(ret));\n            SUBDBG(\"Based upon the return to nvmlGetInforomVersion, we conclude this card is older then Fermi.\\n\");\n            isFermi = 0;\n        }\n\n        ecc_version = strtof(inforomECC, NULL);\n        power_version = strtof(inforomPower, NULL);\n\n        isTesla = (NULL == strstr(name, \"Tesla\")) ? 0 : 1;\n\n        /* For Tesla and Quadro products from Fermi and Kepler families. */\n        if (isFermi) {\n            features[i] |= FEATURE_CLOCK_INFO;\n            num_events += 3;\n        }\n\n        /*  For Tesla and Quadro products from Fermi and Kepler families.\n            requires NVML_INFOROM_ECC 2.0 or higher for location-based counts\n            requires NVML_INFOROM_ECC 1.0 or higher for all other ECC counts\n            requires ECC mode to be enabled. */\n        ret = (*nvmlDeviceGetEccModePtr)(devices[i], &mode, NULL);\n        if (NVML_SUCCESS == ret) {\n            if (NVML_FEATURE_ENABLED == mode) {\n                if (ecc_version >= 2.0) {\n                    features[i] |= FEATURE_ECC_LOCAL_ERRORS;\n                    num_events += 8; /* {single bit, two bit errors} x { reg, l1, l2, memory } */\n                }\n                if (ecc_version >= 1.0) {\n                    features[i] |= FEATURE_ECC_TOTAL_ERRORS;\n                    num_events += 2; /* single bit errors, double bit errors */\n                }\n            }\n        } else {\n            SUBDBG(\"nvmlDeviceGetEccMode does not appear to be supported. (nvml return code %d)\\n\", ret);\n        }\n\n        /* For all discrete products with dedicated fans */\n        features[i] |= FEATURE_FAN_SPEED;\n        num_events++;\n\n        /* For Tesla and Quadro products from Fermi and Kepler families. */\n        if (isFermi) {\n            features[i] |= FEATURE_MAX_CLOCK;\n            num_events += 3;\n        }\n\n        /* For all products */\n        features[i] |= FEATURE_MEMORY_INFO;\n        num_events += 3; /* total, free, used */\n\n        /* For Tesla and Quadro products from the Fermi and Kepler families. */\n        if (isFermi) {\n            features[i] |= FEATURE_PERF_STATES;\n            num_events++;\n        }\n\n        /*  For \"GF11x\" Tesla and Quadro products from the Fermi family\n                requires NVML_INFOROM_POWER 3.0 or higher\n                For Tesla and Quadro products from the Kepler family\n                does not require NVML_INFOROM_POWER */\n        /* Just try reading power, if it works, enable it*/\n        ret = (*nvmlDeviceGetPowerUsagePtr)(devices[i], &temp);\n        if (NVML_SUCCESS == ret) {\n            features[i] |= FEATURE_POWER;\n            num_events++;\n        } else {\n            SUBDBG(\"nvmlDeviceGetPowerUsage does not appear to be supported on this card. (nvml return code %d)\\n\", ret);\n        }\n\n        /* For all discrete and S-class products. */\n        features[i] |= FEATURE_TEMP;\n        num_events++;\n\n        // For power_management_limit\n        {\n            // Just try the call to see if it works\n            unsigned int templimit = 0;\n            ret = (*nvmlDeviceGetPowerManagementLimitPtr)(devices[i], &templimit);\n            if (ret == NVML_SUCCESS && templimit > 0) {\n                power_management_initial_limit[i] = templimit;\n                features[i] |= FEATURE_POWER_MANAGEMENT;\n                num_events += 1;\n            } else {\n                power_management_initial_limit[i] = 0;\n                SUBDBG(\"nvmlDeviceGetPowerManagementLimit not appear to be supported on this card. (NVML code %d)\\n\", ret);\n            }\n        }\n\n        // For power_management_limit_constraints, minimum and maximum\n        {\n            unsigned int minLimit = 0, maxLimit = 0;\n            ret = (*nvmlDeviceGetPowerManagementLimitConstraintsPtr)(devices[i], &minLimit, &maxLimit);\n            if (ret == NVML_SUCCESS) {\n                power_management_limit_constraint_min[i] = minLimit;\n                features[i] |= FEATURE_NVML_POWER_MANAGEMENT_LIMIT_CONSTRAINT_MIN;\n                num_events += 1;\n                power_management_limit_constraint_max[i] = maxLimit;\n                features[i] |= FEATURE_NVML_POWER_MANAGEMENT_LIMIT_CONSTRAINT_MAX;\n                num_events += 1;\n            } else {\n                power_management_limit_constraint_min[i] = 0;\n                power_management_limit_constraint_max[i] = INT_MAX;\n            }\n            SUBDBG(\"Done nvmlDeviceGetPowerManagementLimitConstraintsPtr\\n\");\n        }\n\n        /* For Tesla and Quadro products from the Fermi and Kepler families */\n        if (isFermi) {\n            features[i] |= FEATURE_UTILIZATION;\n            num_events += 2;\n        }\n\n        int retval = snprintf(names[i], sizeof(name), \"%s:device:%d\", name, i);\n        if (retval > (int)sizeof(name)) {\n            SUBDBG(\"Device name is too long %s:device%d\", name, i);\n            return (PAPI_EINVAL);\n        }\n        names[i][sizeof(name) - 1] = '\\0';\n    }\n    return PAPI_OK;\n}\n\nstatic void\ncreateNativeEvents()\n{\n    char name[64];\n    char sanitized_name[PAPI_MAX_STR_LEN];\n    char names[device_count][64];\n\n    int i, nameLen = 0, j;\n\n    nvml_native_event_entry_t* entry;\n    nvmlReturn_t ret;\n\n    nvml_native_table = (nvml_native_event_entry_t*) papi_malloc(\n                            sizeof(nvml_native_event_entry_t) * num_events);\n    memset(nvml_native_table, 0x0, sizeof(nvml_native_event_entry_t) * num_events);\n    entry = &nvml_native_table[0];\n\n    for (i = 0; i < device_count; i++) {\n        memset(names[i], 0x0, 64);\n        ret = (*nvmlDeviceGetNamePtr)(devices[i], name, sizeof(name) - 1);\n        if (NVML_SUCCESS != ret) {\n            SUBDBG(\"nvmlDeviceGetName failed \\n\");\n            strncpy(name, \"deviceNameUnknown\", 17);\n        }\n        name[sizeof(name) - 1] = '\\0';   // to safely use strlen operation below, the variable 'name' must be null terminated\n\n        nameLen = strlen(name);\n        strncpy(sanitized_name, name, PAPI_MAX_STR_LEN);\n\n        int retval = snprintf(sanitized_name, sizeof(name), \"%s:device_%d\", name, i);\n        if (retval > (int)sizeof(name)) {\n            SUBDBG(\"Device name is too long %s:device%d\", name, i);\n            return;\n        }\n        sanitized_name[sizeof(name) - 1] = '\\0';\n\n        for (j = 0; j < nameLen; j++)\n            if (' ' == sanitized_name[j])\n                sanitized_name[j] = '_';\n\n        if (HAS_FEATURE(features[i], FEATURE_CLOCK_INFO)) {\n            sprintf(entry->name, \"%s:graphics_clock\", sanitized_name);\n            strncpy(entry->description, \"Graphics clock domain (MHz).\", PAPI_MAX_STR_LEN);\n            entry->options.clock = NVML_CLOCK_GRAPHICS;\n            entry->type = FEATURE_CLOCK_INFO;\n            entry++;\n\n            sprintf(entry->name, \"%s:sm_clock\", sanitized_name);\n            strncpy(entry->description, \"SM clock domain (MHz).\", PAPI_MAX_STR_LEN);\n            entry->options.clock = NVML_CLOCK_SM;\n            entry->type = FEATURE_CLOCK_INFO;\n            entry++;\n\n            sprintf(entry->name, \"%s:memory_clock\", sanitized_name);\n            strncpy(entry->description, \"Memory clock domain (MHz).\", PAPI_MAX_STR_LEN);\n            entry->options.clock = NVML_CLOCK_MEM;\n            entry->type = FEATURE_CLOCK_INFO;\n            entry++;\n        }\n\n        if (HAS_FEATURE(features[i], FEATURE_ECC_LOCAL_ERRORS)) {\n            sprintf(entry->name, \"%s:l1_single_ecc_errors\", sanitized_name);\n            strncpy(entry->description, \"L1 cache single bit ECC\", PAPI_MAX_STR_LEN);\n            entry->options.ecc_opts = (struct local_ecc) {\n                .bits = NVML_SINGLE_BIT_ECC,\n                 .which_one = LOCAL_ECC_L1,\n            };\n            entry->type = FEATURE_ECC_LOCAL_ERRORS;\n            entry++;\n\n            sprintf(entry->name, \"%s:l2_single_ecc_errors\", sanitized_name);\n            strncpy(entry->description, \"L2 cache single bit ECC\", PAPI_MAX_STR_LEN);\n            entry->options.ecc_opts = (struct local_ecc) {\n                .bits = NVML_SINGLE_BIT_ECC,\n                 .which_one = LOCAL_ECC_L2,\n            };\n            entry->type = FEATURE_ECC_LOCAL_ERRORS;\n            entry++;\n\n            sprintf(entry->name, \"%s:memory_single_ecc_errors\", sanitized_name);\n            strncpy(entry->description, \"Device memory single bit ECC\", PAPI_MAX_STR_LEN);\n            entry->options.ecc_opts = (struct local_ecc) {\n                .bits = NVML_SINGLE_BIT_ECC,\n                 .which_one = LOCAL_ECC_MEM,\n            };\n            entry->type = FEATURE_ECC_LOCAL_ERRORS;\n            entry++;\n\n            sprintf(entry->name, \"%s:regfile_single_ecc_errors\", sanitized_name);\n            strncpy(entry->description, \"Register file single bit ECC\", PAPI_MAX_STR_LEN);\n            entry->options.ecc_opts = (struct local_ecc) {\n                .bits = NVML_SINGLE_BIT_ECC,\n                 .which_one = LOCAL_ECC_REGFILE,\n            };\n            entry->type = FEATURE_ECC_LOCAL_ERRORS;\n            entry++;\n\n            sprintf(entry->name, \"%s:1l_double_ecc_errors\", sanitized_name);\n            strncpy(entry->description, \"L1 cache double bit ECC\", PAPI_MAX_STR_LEN);\n            entry->options.ecc_opts = (struct local_ecc) {\n                .bits = NVML_DOUBLE_BIT_ECC,\n                 .which_one = LOCAL_ECC_L1,\n            };\n            entry->type = FEATURE_ECC_LOCAL_ERRORS;\n            entry++;\n\n            sprintf(entry->name, \"%s:l2_double_ecc_errors\", sanitized_name);\n            strncpy(entry->description, \"L2 cache double bit ECC\", PAPI_MAX_STR_LEN);\n            entry->options.ecc_opts = (struct local_ecc) {\n                .bits = NVML_DOUBLE_BIT_ECC,\n                 .which_one = LOCAL_ECC_L2,\n            };\n            entry->type = FEATURE_ECC_LOCAL_ERRORS;\n            entry++;\n\n            sprintf(entry->name, \"%s:memory_double_ecc_errors\", sanitized_name);\n            strncpy(entry->description, \"Device memory double bit ECC\", PAPI_MAX_STR_LEN);\n            entry->options.ecc_opts = (struct local_ecc) {\n                .bits = NVML_DOUBLE_BIT_ECC,\n                 .which_one = LOCAL_ECC_MEM,\n            };\n            entry->type = FEATURE_ECC_LOCAL_ERRORS;\n            entry++;\n\n            sprintf(entry->name, \"%s:regfile_double_ecc_errors\", sanitized_name);\n            strncpy(entry->description, \"Register file double bit ECC\", PAPI_MAX_STR_LEN);\n            entry->options.ecc_opts = (struct local_ecc) {\n                .bits = NVML_DOUBLE_BIT_ECC,\n                 .which_one = LOCAL_ECC_REGFILE,\n            };\n            entry->type = FEATURE_ECC_LOCAL_ERRORS;\n            entry++;\n        }\n\n        if (HAS_FEATURE(features[i], FEATURE_FAN_SPEED)) {\n            sprintf(entry->name, \"%s:fan_speed\", sanitized_name);\n            strncpy(entry->description, \"The fan speed expressed as a percent of the maximum, i.e. full speed is 100%\", PAPI_MAX_STR_LEN);\n            entry->type = FEATURE_FAN_SPEED;\n            entry++;\n        }\n\n        if (HAS_FEATURE(features[i], FEATURE_MAX_CLOCK)) {\n            sprintf(entry->name, \"%s:graphics_max_clock\", sanitized_name);\n            strncpy(entry->description, \"Maximal Graphics clock domain (MHz).\", PAPI_MAX_STR_LEN);\n            entry->options.clock = NVML_CLOCK_GRAPHICS;\n            entry->type = FEATURE_MAX_CLOCK;\n            entry++;\n\n            sprintf(entry->name, \"%s:sm_max_clock\", sanitized_name);\n            strncpy(entry->description, \"Maximal SM clock domain (MHz).\", PAPI_MAX_STR_LEN);\n            entry->options.clock = NVML_CLOCK_SM;\n            entry->type = FEATURE_MAX_CLOCK;\n            entry++;\n\n            sprintf(entry->name, \"%s:memory_max_clock\", sanitized_name);\n            strncpy(entry->description, \"Maximal Memory clock domain (MHz).\", PAPI_MAX_STR_LEN);\n            entry->options.clock = NVML_CLOCK_MEM;\n            entry->type = FEATURE_MAX_CLOCK;\n            entry++;\n        }\n\n        if (HAS_FEATURE(features[i], FEATURE_MEMORY_INFO)) {\n            sprintf(entry->name, \"%s:total_memory\", sanitized_name);\n            strncpy(entry->description, \"Total installed FB memory (in bytes).\", PAPI_MAX_STR_LEN);\n            entry->options.which_one = MEMINFO_TOTAL_MEMORY;\n            entry->type = FEATURE_MEMORY_INFO;\n            entry++;\n\n            sprintf(entry->name, \"%s:unallocated_memory\", sanitized_name);\n            strncpy(entry->description, \"Uncallocated FB memory (in bytes).\", PAPI_MAX_STR_LEN);\n            entry->options.which_one = MEMINFO_UNALLOCED;\n            entry->type = FEATURE_MEMORY_INFO;\n            entry++;\n\n            sprintf(entry->name, \"%s:allocated_memory\", sanitized_name);\n            strncpy(entry->description, \"Allocated FB memory (in bytes). Note that the driver/GPU always sets aside a small amount of memory for bookkeeping.\", PAPI_MAX_STR_LEN);\n            entry->options.which_one = MEMINFO_ALLOCED;\n            entry->type = FEATURE_MEMORY_INFO;\n            entry++;\n        }\n\n        if (HAS_FEATURE(features[i], FEATURE_PERF_STATES)) {\n            sprintf(entry->name, \"%s:pstate\", sanitized_name);\n            strncpy(entry->description, \"The performance state of the device.\", PAPI_MAX_STR_LEN);\n            entry->type = FEATURE_PERF_STATES;\n            entry++;\n        }\n\n        if (HAS_FEATURE(features[i], FEATURE_POWER)) {\n            sprintf(entry->name, \"%s:power\", sanitized_name);\n            // set the power event units value to \"mW\" for miliwatts\n            strncpy(entry->units, \"mW\", PAPI_MIN_STR_LEN);\n            strncpy(entry->description, \"Power usage reading for the device, in miliwatts. This is the power draw (+/-5 watts) for the entire board: GPU, memory, etc.\", PAPI_MAX_STR_LEN);\n            entry->type = FEATURE_POWER;\n            entry++;\n        }\n\n        if (HAS_FEATURE(features[i], FEATURE_TEMP)) {\n            sprintf(entry->name, \"%s:temperature\", sanitized_name);\n            strncpy(entry->description, \"Current temperature readings for the device, in degrees C.\", PAPI_MAX_STR_LEN);\n            entry->type = FEATURE_TEMP;\n            entry++;\n        }\n\n        if (HAS_FEATURE(features[i], FEATURE_ECC_TOTAL_ERRORS)) {\n            sprintf(entry->name, \"%s:total_ecc_errors\", sanitized_name);\n            strncpy(entry->description, \"Total single bit errors.\", PAPI_MAX_STR_LEN);\n            entry->options.ecc_opts = (struct local_ecc) {\n                .bits = NVML_SINGLE_BIT_ECC,\n            };\n            entry->type = FEATURE_ECC_TOTAL_ERRORS;\n            entry++;\n\n            sprintf(entry->name, \"%s:total_ecc_errors\", sanitized_name);\n            strncpy(entry->description, \"Total double bit errors.\", PAPI_MAX_STR_LEN);\n            entry->options.ecc_opts = (struct local_ecc) {\n                .bits = NVML_DOUBLE_BIT_ECC,\n            };\n            entry->type = FEATURE_ECC_TOTAL_ERRORS;\n            entry++;\n        }\n\n        if (HAS_FEATURE(features[i], FEATURE_UTILIZATION)) {\n            sprintf(entry->name, \"%s:gpu_utilization\", sanitized_name);\n            strncpy(entry->description, \"Percent of time over the past second during which one or more kernels was executing on the GPU.\", PAPI_MAX_STR_LEN);\n            entry->options.which_one = GPU_UTILIZATION;\n            entry->type = FEATURE_UTILIZATION;\n            entry++;\n\n            sprintf(entry->name, \"%s:memory_utilization\", sanitized_name);\n            strncpy(entry->description, \"Percent of time over the past second during which global (device) memory was being read or written.\", PAPI_MAX_STR_LEN);\n            entry->options.which_one = MEMORY_UTILIZATION;\n            entry->type = FEATURE_UTILIZATION;\n            entry++;\n        }\n\n        if (HAS_FEATURE(features[i], FEATURE_POWER_MANAGEMENT)) {\n            sprintf(entry->name, \"%s:power_management_limit\", sanitized_name);\n            // set the power event units value to \"mW\" for milliwatts\n            strncpy(entry->units, \"mW\", PAPI_MIN_STR_LEN);\n            strncpy(entry->description, \"Power management limit in milliwatts associated with the device.  The power limit defines the upper boundary for the cards power draw. If the cards total power draw reaches this limit the power management algorithm kicks in. This should be writable (with appropriate privileges) on supported Kepler or later (unit milliWatts). \", PAPI_MAX_STR_LEN);\n            entry->type = FEATURE_POWER_MANAGEMENT;\n            entry++;\n        }\n        if (HAS_FEATURE(features[i], FEATURE_NVML_POWER_MANAGEMENT_LIMIT_CONSTRAINT_MIN)) {\n            sprintf(entry->name, \"%s:power_management_limit_constraint_min\", sanitized_name);\n            strncpy(entry->units, \"mW\", PAPI_MIN_STR_LEN);\n            strncpy(entry->description, \"The minimum power management limit in milliwatts.\", PAPI_MAX_STR_LEN);\n            entry->type = FEATURE_NVML_POWER_MANAGEMENT_LIMIT_CONSTRAINT_MIN;\n            entry++;\n        }\n\n        if (HAS_FEATURE(features[i], FEATURE_NVML_POWER_MANAGEMENT_LIMIT_CONSTRAINT_MAX)) {\n            sprintf(entry->name, \"%s:power_management_limit_constraint_max\", sanitized_name);\n            strncpy(entry->units, \"mW\", PAPI_MIN_STR_LEN);\n            strncpy(entry->description, \"The maximum power management limit in milliwatts.\", PAPI_MAX_STR_LEN);\n            entry->type = FEATURE_NVML_POWER_MANAGEMENT_LIMIT_CONSTRAINT_MAX;\n            entry++;\n        }\n\n        strncpy(names[i], name, sizeof(names[0]) - 1);\n        names[i][sizeof(names[0]) - 1] = '\\0';\n    }\n}\n\n/** Initialize hardware counters, setup the function vector table\n * and get hardware information, this routine is called when the\n * PAPI process is initialized (IE PAPI_library_init)\n */\nint\n_papi_nvml_init_component(int cidx)\n{\n    SUBDBG(\"Entry: cidx: %d\\n\", cidx);\n    nvmlReturn_t ret;\n    cudaError_t cuerr;\n    int papi_errorcode;\n\n    int cuda_count = 0;\n    unsigned int nvml_count = 0;\n\n    /* link in the cuda and nvml libraries and resolve the symbols we need to use */\n    if (linkCudaLibraries() != PAPI_OK) {\n        SUBDBG(\"Dynamic link of CUDA libraries failed, component will be disabled.\\n\");\n        SUBDBG(\"See disable reason in papi_component_avail output for more details.\\n\");\n        return (PAPI_ENOSUPP);\n    }\n\n    ret = (*nvmlInitPtr)();\n    if (NVML_SUCCESS != ret) {\n        strcpy(_nvml_vector.cmp_info.disabled_reason, \"The NVIDIA managament library failed to initialize.\");\n        return PAPI_ENOSUPP;\n    }\n\n    cuerr = (*cuInitPtr)(0);\n    if (cudaSuccess != cuerr) {\n        strcpy(_nvml_vector.cmp_info.disabled_reason, \"The CUDA library failed to initialize.\");\n        return PAPI_ENOSUPP;\n    }\n\n    /* Figure out the number of CUDA devices in the system */\n    ret = (*nvmlDeviceGetCountPtr)(&nvml_count);\n    if (NVML_SUCCESS != ret) {\n        strcpy(_nvml_vector.cmp_info.disabled_reason, \"Unable to get a count of devices from the NVIDIA managament library.\");\n        return PAPI_ENOSUPP;\n    }\n\n    cuerr = (*cudaGetDeviceCountPtr)(&cuda_count);\n    if (cudaSuccess != cuerr) {\n        strcpy(_nvml_vector.cmp_info.disabled_reason, \"Unable to get a device count from CUDA.\");\n        return PAPI_ENOSUPP;\n    }\n\n    /* We can probably recover from this, when we're clever */\n    if ((cuda_count > 0) && (nvml_count != (unsigned int)cuda_count)) {\n        strcpy(_nvml_vector.cmp_info.disabled_reason, \"CUDA and the NVIDIA managament library have different device counts.\");\n        return PAPI_ENOSUPP;\n    }\n\n    device_count = cuda_count;\n    SUBDBG(\"Need to setup NVML with %d devices\\n\", device_count);\n\n    /* A per device representation of what events are present */\n    features = (int*)papi_malloc(sizeof(int) * device_count);\n\n    /* Handles to each device */\n    devices = (nvmlDevice_t*)papi_malloc(sizeof(nvmlDevice_t) * device_count);\n\n    /* For each device, store the intial power value to enable reset if power is altered */\n    power_management_initial_limit = (unsigned int*)papi_malloc(sizeof(unsigned int) * device_count);\n    power_management_limit_constraint_min = (unsigned int*)papi_malloc(sizeof(unsigned int) * device_count);\n    power_management_limit_constraint_max = (unsigned int*)papi_malloc(sizeof(unsigned int) * device_count);\n\n    /* Figure out what events are supported on each card. */\n    if ((papi_errorcode = detectDevices()) != PAPI_OK) {\n        papi_free(features);\n        papi_free(devices);\n        sprintf(_nvml_vector.cmp_info.disabled_reason, \"An error occured in device feature detection, please check your NVIDIA Management Library and CUDA install.\");\n        return PAPI_ENOSUPP;\n    }\n\n    /* The assumption is that if everything went swimmingly in detectDevices,\n        all nvml calls here should be fine. */\n    createNativeEvents();\n\n    /* Export the total number of events available */\n    _nvml_vector.cmp_info.num_native_events = num_events;\n\n    /* Export the component id */\n    _nvml_vector.cmp_info.CmpIdx = cidx;\n\n    /* Export the number of 'counters' */\n    _nvml_vector.cmp_info.num_cntrs = num_events;\n    _nvml_vector.cmp_info.num_mpx_cntrs = num_events;\n\n    return PAPI_OK;\n}\n\n/*\n * Link the necessary CUDA libraries to use the cuda component.  If any of them can not be found, then\n * the CUDA component will just be disabled.  This is done at runtime so that a version of PAPI built\n * with the CUDA component can be installed and used on systems which have the CUDA libraries installed\n * and on systems where these libraries are not installed.\n */\nstatic int\nlinkCudaLibraries()\n{\n    /* Attempt to guess if we were statically linked to libc, if so bail */\n    if (_dl_non_dynamic_init != NULL) {\n        strncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML component does not support statically linking of libc.\", PAPI_MAX_STR_LEN);\n        return PAPI_ENOSUPP;\n    }\n\n    /* Need to link in the cuda libraries, if not found disable the component */\n    dl1 = dlopen(\"libcuda.so\", RTLD_NOW | RTLD_GLOBAL);\n    if (!dl1) {\n        strncpy(_nvml_vector.cmp_info.disabled_reason, \"CUDA library libcuda.so not found.\", PAPI_MAX_STR_LEN);\n        return (PAPI_ENOSUPP);\n    }\n    cuInitPtr = dlsym(dl1, \"cuInit\");\n    if (dlerror() != NULL) {\n        strncpy(_nvml_vector.cmp_info.disabled_reason, \"CUDA function cuInit not found.\", PAPI_MAX_STR_LEN);\n        return (PAPI_ENOSUPP);\n    }\n\n    dl2 = dlopen(\"libcudart.so\", RTLD_NOW | RTLD_GLOBAL | RTLD_NODELETE);\n    if (!dl2) {\n        strncpy(_nvml_vector.cmp_info.disabled_reason, \"CUDA runtime library libcudart.so not found.\", PAPI_MAX_STR_LEN);\n        return (PAPI_ENOSUPP);\n    }\n    cudaGetDevicePtr = dlsym(dl2, \"cudaGetDevice\");\n    if (dlerror() != NULL) {\n        strncpy(_nvml_vector.cmp_info.disabled_reason, \"CUDART function cudaGetDevice not found.\", PAPI_MAX_STR_LEN);\n        return (PAPI_ENOSUPP);\n    }\n    cudaGetDeviceCountPtr = dlsym(dl2, \"cudaGetDeviceCount\");\n    if (dlerror() != NULL) {\n        strncpy(_nvml_vector.cmp_info.disabled_reason, \"CUDART function cudaGetDeviceCount not found.\", PAPI_MAX_STR_LEN);\n        return (PAPI_ENOSUPP);\n    }\n    cudaDeviceGetPCIBusIdPtr = dlsym(dl2, \"cudaDeviceGetPCIBusId\");\n    if (dlerror() != NULL) {\n        strncpy(_nvml_vector.cmp_info.disabled_reason, \"CUDART function cudaDeviceGetPCIBusId not found.\", PAPI_MAX_STR_LEN);\n        return (PAPI_ENOSUPP);\n    }\n\n    dl3 = dlopen(\"libnvidia-ml.so\", RTLD_NOW | RTLD_GLOBAL);\n    if (!dl3) {\n        strncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML runtime library libnvidia-ml.so not found.\", PAPI_MAX_STR_LEN);\n        return (PAPI_ENOSUPP);\n    }\n    nvmlDeviceGetClockInfoPtr = dlsym(dl3, \"nvmlDeviceGetClockInfo\");\n    if (dlerror() != NULL) {\n        strncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML function nvmlDeviceGetClockInfo not found.\", PAPI_MAX_STR_LEN);\n        return (PAPI_ENOSUPP);\n    }\n    nvmlErrorStringPtr = dlsym(dl3, \"nvmlErrorString\");\n    if (dlerror() != NULL) {\n        strncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML function nvmlErrorString not found.\", PAPI_MAX_STR_LEN);\n        return (PAPI_ENOSUPP);\n    }\n    nvmlDeviceGetDetailedEccErrorsPtr = dlsym(dl3, \"nvmlDeviceGetDetailedEccErrors\");\n    if (dlerror() != NULL) {\n        strncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML function nvmlDeviceGetDetailedEccErrors not found.\", PAPI_MAX_STR_LEN);\n        return (PAPI_ENOSUPP);\n    }\n    nvmlDeviceGetFanSpeedPtr = dlsym(dl3, \"nvmlDeviceGetFanSpeed\");\n    if (dlerror() != NULL) {\n        strncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML function nvmlDeviceGetFanSpeed not found.\", PAPI_MAX_STR_LEN);\n        return (PAPI_ENOSUPP);\n    }\n    nvmlDeviceGetMemoryInfoPtr = dlsym(dl3, \"nvmlDeviceGetMemoryInfo\");\n    if (dlerror() != NULL) {\n        strncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML function nvmlDeviceGetMemoryInfo not found.\", PAPI_MAX_STR_LEN);\n        return (PAPI_ENOSUPP);\n    }\n    nvmlDeviceGetPerformanceStatePtr = dlsym(dl3, \"nvmlDeviceGetPerformanceState\");\n    if (dlerror() != NULL) {\n        strncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML function nvmlDeviceGetPerformanceState not found.\", PAPI_MAX_STR_LEN);\n        return (PAPI_ENOSUPP);\n    }\n    nvmlDeviceGetPowerUsagePtr = dlsym(dl3, \"nvmlDeviceGetPowerUsage\");\n    if (dlerror() != NULL) {\n        strncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML function nvmlDeviceGetPowerUsage not found.\", PAPI_MAX_STR_LEN);\n        return (PAPI_ENOSUPP);\n    }\n    nvmlDeviceGetTemperaturePtr = dlsym(dl3, \"nvmlDeviceGetTemperature\");\n    if (dlerror() != NULL) {\n        strncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML function nvmlDeviceGetTemperature not found.\", PAPI_MAX_STR_LEN);\n        return (PAPI_ENOSUPP);\n    }\n    nvmlDeviceGetTotalEccErrorsPtr = dlsym(dl3, \"nvmlDeviceGetTotalEccErrors\");\n    if (dlerror() != NULL) {\n        strncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML function nvmlDeviceGetTotalEccErrors not found.\", PAPI_MAX_STR_LEN);\n        return (PAPI_ENOSUPP);\n    }\n    nvmlDeviceGetUtilizationRatesPtr = dlsym(dl3, \"nvmlDeviceGetUtilizationRates\");\n    if (dlerror() != NULL) {\n        strncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML function nvmlDeviceGetUtilizationRates not found.\", PAPI_MAX_STR_LEN);\n        return (PAPI_ENOSUPP);\n    }\n    nvmlDeviceGetHandleByIndexPtr = dlsym(dl3, \"nvmlDeviceGetHandleByIndex\");\n    if (dlerror() != NULL) {\n        strncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML function nvmlDeviceGetHandleByIndex not found.\", PAPI_MAX_STR_LEN);\n        return (PAPI_ENOSUPP);\n    }\n    nvmlDeviceGetPciInfoPtr = dlsym(dl3, \"nvmlDeviceGetPciInfo\");\n    if (dlerror() != NULL) {\n        strncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML function nvmlDeviceGetPciInfo not found.\", PAPI_MAX_STR_LEN);\n        return (PAPI_ENOSUPP);\n    }\n    nvmlDeviceGetNamePtr = dlsym(dl3, \"nvmlDeviceGetName\");\n    if (dlerror() != NULL) {\n        strncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML function nvmlDeviceGetName not found.\", PAPI_MAX_STR_LEN);\n        return (PAPI_ENOSUPP);\n    }\n    nvmlDeviceGetInforomVersionPtr = dlsym(dl3, \"nvmlDeviceGetInforomVersion\");\n    if (dlerror() != NULL) {\n        strncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML function nvmlDeviceGetInforomVersion not found.\", PAPI_MAX_STR_LEN);\n        return (PAPI_ENOSUPP);\n    }\n    nvmlDeviceGetEccModePtr = dlsym(dl3, \"nvmlDeviceGetEccMode\");\n    if (dlerror() != NULL) {\n        strncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML function nvmlDeviceGetEccMode not found.\", PAPI_MAX_STR_LEN);\n        return (PAPI_ENOSUPP);\n    }\n    nvmlInitPtr = dlsym(dl3, \"nvmlInit\");\n    if (dlerror() != NULL) {\n        strncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML function nvmlInit not found.\", PAPI_MAX_STR_LEN);\n        return (PAPI_ENOSUPP);\n    }\n    nvmlDeviceGetCountPtr = dlsym(dl3, \"nvmlDeviceGetCount\");\n    if (dlerror() != NULL) {\n        strncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML function nvmlDeviceGetCount not found.\", PAPI_MAX_STR_LEN);\n        return (PAPI_ENOSUPP);\n    }\n    nvmlShutdownPtr = dlsym(dl3, \"nvmlShutdown\");\n    if (dlerror() != NULL) {\n        strncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML function nvmlShutdown not found.\", PAPI_MAX_STR_LEN);\n        return (PAPI_ENOSUPP);\n    }\n    nvmlDeviceGetPowerManagementLimitPtr = dlsym(dl3, \"nvmlDeviceGetPowerManagementLimit\");\n    if (dlerror() != NULL) {\n        strncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML function nvmlDeviceGetPowerManagementLimit not found.\", PAPI_MAX_STR_LEN);\n        return (PAPI_ENOSUPP);\n    }\n    nvmlDeviceSetPowerManagementLimitPtr = dlsym(dl3, \"nvmlDeviceSetPowerManagementLimit\");\n    if (dlerror() != NULL) {\n        strncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML function nvmlDeviceSetPowerManagementLimit not found.\", PAPI_MAX_STR_LEN);\n        return (PAPI_ENOSUPP);\n    }\n    nvmlDeviceGetPowerManagementLimitConstraintsPtr = dlsym(dl3, \"nvmlDeviceGetPowerManagementLimitConstraints\");\n    if (dlerror() != NULL) {\n        strncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML function nvmlDeviceGetPowerManagementLimitConstraints not found.\", PAPI_MAX_STR_LEN);\n        return (PAPI_ENOSUPP);\n    }\n    return (PAPI_OK);\n}\n\n/** Setup a counter control state.\n *   In general a control state holds the hardware info for an\n *   EventSet.\n */\n\nint\n_papi_nvml_init_control_state(hwd_control_state_t * ctl)\n{\n    SUBDBG(\"nvml_init_control_state... %p\\n\", ctl);\n    nvml_control_state_t *nvml_ctl = (nvml_control_state_t *) ctl;\n    memset(nvml_ctl, 0, sizeof(nvml_control_state_t));\n\n    return PAPI_OK;\n}\n\n/** Triggered by eventset operations like add or remove */\nint\n_papi_nvml_update_control_state(hwd_control_state_t *ctl,\n                                NativeInfo_t *native,\n                                int count,\n                                hwd_context_t *ctx)\n{\n    SUBDBG(\"Enter: ctl: %p, ctx: %p\\n\", ctl, ctx);\n    int i, index;\n\n    nvml_control_state_t *nvml_ctl = (nvml_control_state_t *) ctl;\n    (void) ctx;\n\n    /* if no events, return */\n    if (count == 0) return PAPI_OK;\n\n    for (i = 0; i < count; i++) {\n        index = native[i].ni_event;\n        nvml_ctl->which_counter[i] = index;\n        /* We have no constraints on event position, so any event */\n        /* can be in any slot.                                    */\n        native[i].ni_position = i;\n    }\n    nvml_ctl->num_events = count;\n    return PAPI_OK;\n}\n/** Triggered by PAPI_start() */\nint\n_papi_nvml_start(hwd_context_t *ctx, hwd_control_state_t *ctl)\n{\n    SUBDBG(\"Enter: ctx: %p, ctl: %p\\n\", ctx, ctl);\n\n    (void) ctx;\n    (void) ctl;\n\n    /* anything that would need to be set at counter start time */\n\n    /* reset */\n    /* start the counting */\n\n    return PAPI_OK;\n}\n\n/** Triggered by PAPI_stop() */\nint\n_papi_nvml_stop(hwd_context_t *ctx, hwd_control_state_t *ctl)\n{\n    SUBDBG(\"Enter: ctx: %p, ctl: %p\\n\", ctx, ctl);\n\n    int i;\n    (void) ctx;\n    (void) ctl;\n    int ret;\n\n    nvml_control_state_t* nvml_ctl = (nvml_control_state_t*) ctl;\n\n    for (i = 0; i < nvml_ctl->num_events; i++) {\n        if (PAPI_OK !=\n                (ret = nvml_hardware_read(&nvml_ctl->counter[i],\n                                          nvml_ctl->which_counter[i])))\n            return ret;\n\n    }\n\n    return PAPI_OK;\n}\n\n/** Triggered by PAPI_read() */\nint\n_papi_nvml_read(hwd_context_t *ctx, hwd_control_state_t *ctl,\n                long long **events, int flags)\n{\n    SUBDBG(\"Enter: ctx: %p, flags: %d\\n\", ctx, flags);\n\n    (void) ctx;\n    (void) flags;\n    int i;\n    int ret;\n    nvml_control_state_t* nvml_ctl = (nvml_control_state_t*) ctl;\n\n    for (i = 0; i < nvml_ctl->num_events; i++) {\n        if (PAPI_OK !=\n                (ret = nvml_hardware_read(&nvml_ctl->counter[i],\n                                          nvml_ctl->which_counter[i])))\n            return ret;\n\n    }\n    /* return pointer to the values we read */\n    *events = nvml_ctl->counter;\n    return PAPI_OK;\n}\n\n/** Triggered by PAPI_write(), but only if the counters are running */\n/*    otherwise, the updated state is written to ESI->hw_start      */\nint\n_papi_nvml_write(hwd_context_t *ctx, hwd_control_state_t *ctl, long long *events)\n{\n    SUBDBG(\"Enter: ctx: %p, ctl: %p\\n\", ctx, ctl);\n    (void) ctx;\n    nvml_control_state_t* nvml_ctl = (nvml_control_state_t*) ctl;\n    int i;\n    int ret;\n\n    /* You can change ECC mode and compute exclusivity modes on the cards */\n    /* But I don't see this as a function of a PAPI component at this time */\n    /* All implementation issues aside. */\n\n    // Currently POWER_MANAGEMENT can be written\n    for (i = 0; i < nvml_ctl->num_events; i++) {\n        if (PAPI_OK != (ret = nvml_hardware_write(&events[i], nvml_ctl->which_counter[i])))\n            return ret;\n    }\n\n    /* return pointer to the values we read */\n    return PAPI_OK;\n}\n\n/** Triggered by PAPI_reset() but only if the EventSet is currently running */\n/*  If the eventset is not currently running, then the saved value in the   */\n/*  EventSet is set to zero without calling this routine.                   */\nint\n_papi_nvml_reset(hwd_context_t * ctx, hwd_control_state_t * ctl)\n{\n    SUBDBG(\"Enter: ctx: %p, ctl: %p\\n\", ctx, ctl);\n\n    (void) ctx;\n    (void) ctl;\n\n    /* Reset the hardware */\n    nvml_hardware_reset();\n\n    return PAPI_OK;\n}\n\n/** Triggered by PAPI_shutdown() */\nint\n_papi_nvml_shutdown_component()\n{\n    SUBDBG(\"Enter:\\n\");\n    nvml_hardware_reset();\n    if (nvml_native_table != NULL) papi_free(nvml_native_table);\n    if (devices != NULL) papi_free(devices);\n    if (features != NULL) papi_free(features);\n    if (power_management_initial_limit) papi_free(power_management_initial_limit);\n    if (power_management_limit_constraint_min) papi_free(power_management_limit_constraint_min);\n    if (power_management_limit_constraint_max) papi_free(power_management_limit_constraint_max);\n   (*nvmlShutdownPtr)();\n\n    device_count = 0;\n    num_events = 0;\n\n    // close the dynamic libraries needed by this component (opened in the init component call)\n    if (dl3) dlclose(dl3); dl3=NULL;\n    if (dl2) dlclose(dl2); dl2=NULL;\n    if (dl1) dlclose(dl1); dl1=NULL;\n\n    return PAPI_OK;\n}\n\n/** Called at thread shutdown */\nint\n_papi_nvml_shutdown_thread(hwd_context_t *ctx)\n{\n    SUBDBG(\"Enter: ctx: %p\\n\", ctx);\n\n    (void) ctx;\n\n    /* Last chance to clean up thread */\n\n    return PAPI_OK;\n}\n\n/** This function sets various options in the component\n  @param code valid are PAPI_SET_DEFDOM, PAPI_SET_DOMAIN, PAPI_SETDEFGRN, PAPI_SET_GRANUL and PAPI_SET_INHERIT\n */\nint\n_papi_nvml_ctl(hwd_context_t * ctx, int code, _papi_int_option_t * option)\n{\n    SUBDBG(\"Enter: ctx: %p, code: %d\\n\", ctx, code);\n\n    (void) ctx;\n    (void) code;\n    (void) option;\n\n    /* FIXME.  This should maybe set up more state, such as which counters are active and */\n    /*         counter mappings. */\n\n    return PAPI_OK;\n}\n\n/** This function has to set the bits needed to count different domains\n  In particular: PAPI_DOM_USER, PAPI_DOM_KERNEL PAPI_DOM_OTHER\n  By default return PAPI_EINVAL if none of those are specified\n  and PAPI_OK with success\n  PAPI_DOM_USER is only user context is counted\n  PAPI_DOM_KERNEL is only the Kernel/OS context is counted\n  PAPI_DOM_OTHER  is Exception/transient mode (like user TLB misses)\n  PAPI_DOM_ALL   is all of the domains\n */\nint\n_papi_nvml_set_domain(hwd_control_state_t * cntrl, int domain)\n{\n    SUBDBG(\"Enter: cntrl: %p, domain: %d\\n\", cntrl, domain);\n\n    (void) cntrl;\n\n    int found = 0;\n\n    if (PAPI_DOM_USER & domain) {\n        SUBDBG(\" PAPI_DOM_USER \\n\");\n        found = 1;\n    }\n    if (PAPI_DOM_KERNEL & domain) {\n        SUBDBG(\" PAPI_DOM_KERNEL \\n\");\n        found = 1;\n    }\n    if (PAPI_DOM_OTHER & domain) {\n        SUBDBG(\" PAPI_DOM_OTHER \\n\");\n        found = 1;\n    }\n    if (PAPI_DOM_ALL & domain) {\n        SUBDBG(\" PAPI_DOM_ALL \\n\");\n        found = 1;\n    }\n    if (!found)\n        return (PAPI_EINVAL);\n\n    return PAPI_OK;\n}\n\n/**************************************************************/\n/* Naming functions, used to translate event numbers to names */\n/**************************************************************/\n\n/** Enumerate Native Events\n *   @param EventCode is the event of interest\n *   @param modifier is one of PAPI_ENUM_FIRST, PAPI_ENUM_EVENTS\n *  If your component has attribute masks then these need to\n *   be handled here as well.\n */\nint\n_papi_nvml_ntv_enum_events(unsigned int *EventCode, int modifier)\n{\n    int index;\n\n    switch (modifier) {\n\n    /* return EventCode of first event */\n    case PAPI_ENUM_FIRST:\n        /* return the first event that we support */\n\n        *EventCode = 0;\n        return PAPI_OK;\n\n    /* return EventCode of next available event */\n    case PAPI_ENUM_EVENTS:\n        index = *EventCode;\n\n        /* Make sure we are in range */\n        if (index < num_events - 1) {\n\n            /* This assumes a non-sparse mapping of the events */\n            *EventCode = *EventCode + 1;\n            return PAPI_OK;\n        } else {\n            return PAPI_ENOEVNT;\n        }\n        break;\n\n    default:\n        return PAPI_EINVAL;\n    }\n\n    return PAPI_EINVAL;\n}\n\n/** Takes a native event code and passes back the name\n * @param EventCode is the native event code\n * @param name is a pointer for the name to be copied to\n * @param len is the size of the name string\n */\nint\n_papi_nvml_ntv_code_to_name(unsigned int EventCode, char *name, int len)\n{\n    SUBDBG(\"Entry: EventCode: %#x, name: %s, len: %d\\n\", EventCode, name, len);\n    int index;\n\n    index = EventCode;\n\n    /* Make sure we are in range */\n    if (index >= num_events) return PAPI_ENOEVNT;\n\n    strncpy(name, nvml_native_table[index].name, len);\n\n    return PAPI_OK;\n}\n\n/** Takes a native event code and passes back the event description\n * @param EventCode is the native event code\n * @param descr is a pointer for the description to be copied to\n * @param len is the size of the descr string\n */\nint\n_papi_nvml_ntv_code_to_descr(unsigned int EventCode, char *descr, int len)\n{\n    int index;\n    index = EventCode;\n\n    if (index >= num_events) return PAPI_ENOEVNT;\n\n    strncpy(descr, nvml_native_table[index].description, len);\n\n    return PAPI_OK;\n}\n\n/** Takes a native event code and passes back the event info\n * @param EventCode is the native event code\n * @param info is a pointer for the info to be copied to\n */\nint\n_papi_nvml_ntv_code_to_info(unsigned int EventCode, PAPI_event_info_t *info)\n{\n\n    int index = EventCode;\n\n    if ((index < 0) || (index >= num_events)) return PAPI_ENOEVNT;\n\n    strncpy(info->symbol, nvml_native_table[index].name, sizeof(info->symbol) - 1);\n    info->symbol[sizeof(info->symbol) - 1] = '\\0';\n\n    strncpy(info->units, nvml_native_table[index].units, sizeof(info->units) - 1);\n    info->units[sizeof(info->units) - 1] = '\\0';\n\n    strncpy(info->long_descr, nvml_native_table[index].description, sizeof(info->long_descr) - 1);\n    info->long_descr[sizeof(info->long_descr) - 1] = '\\0';\n\n//  info->data_type = nvml_native_table[index].return_type;\n\n    return PAPI_OK;\n}\n\n/** Vector that points to entry points for our component */\npapi_vector_t _nvml_vector = {\n    .cmp_info = {\n        /* default component information */\n        /* (unspecified values are initialized to 0) */\n\n        .name = \"nvml\",\n        .short_name = \"nvml\",\n        .version = \"1.0\",\n        .description = \"NVML provides the API for monitoring NVIDIA hardware (power usage, temperature, fan speed, etc)\",\n        .support_version = \"n/a\",\n        .kernel_version = \"n/a\",\n\n        .num_preset_events = 0,\n        .num_native_events = 0, /* set by init_component */\n        .default_domain = PAPI_DOM_USER,\n        .available_domains = PAPI_DOM_USER,\n        .default_granularity = PAPI_GRN_THR,\n        .available_granularities = PAPI_GRN_THR,\n        .hardware_intr_sig = PAPI_INT_SIGNAL,\n\n        /* component specific cmp_info initializations */\n        .hardware_intr = 0,\n        .precise_intr = 0,\n        .posix1b_timers = 0,\n        .kernel_profile = 0,\n        .kernel_multiplex = 0,\n        .fast_counter_read = 0,\n        .fast_real_timer = 0,\n        .fast_virtual_timer = 0,\n        .attach = 0,\n        .attach_must_ptrace = 0,\n        .cntr_umasks = 0,\n        .cpu = 0,\n        .inherit = 0,\n    },\n\n    /* sizes of framework-opaque component-private structures */\n    .size = {\n        .context = sizeof(nvml_context_t),\n        .control_state = sizeof(nvml_control_state_t),\n        .reg_value = sizeof(nvml_register_t),\n        // .reg_alloc = sizeof ( nvml_reg_alloc_t ),\n    },\n\n    /* function pointers */\n\n    /* Used for general PAPI interactions */\n    .start =                _papi_nvml_start,\n    .stop =                 _papi_nvml_stop,\n    .read =                 _papi_nvml_read,\n    .reset =                _papi_nvml_reset,\n    .write =                _papi_nvml_write,\n    .init_component =       _papi_nvml_init_component,\n    .init_thread =          _papi_nvml_init_thread,\n    .init_control_state =   _papi_nvml_init_control_state,\n    .update_control_state = _papi_nvml_update_control_state,\n    .ctl =                  _papi_nvml_ctl,\n    .shutdown_thread =      _papi_nvml_shutdown_thread,\n    .shutdown_component =   _papi_nvml_shutdown_component,\n    .set_domain =           _papi_nvml_set_domain,\n    .cleanup_eventset =     NULL,\n    /* called in add_native_events() */\n    .allocate_registers =   NULL,\n\n    /* Used for overflow/profiling */\n    .dispatch_timer =       NULL,\n    .get_overflow_address = NULL,\n    .stop_profiling =       NULL,\n    .set_overflow =         NULL,\n    .set_profile =          NULL,\n\n    /* Name Mapping Functions */\n    .ntv_enum_events =   _papi_nvml_ntv_enum_events,\n    .ntv_name_to_code  = NULL,\n    .ntv_code_to_name =  _papi_nvml_ntv_code_to_name,\n    .ntv_code_to_descr = _papi_nvml_ntv_code_to_descr,\n    .ntv_code_to_info = _papi_nvml_ntv_code_to_info,\n\n};\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.6.0-iweh6uy7qfzcgjj77nhy45ucjhpm2ow6/spack-src/src/components/lmsensors/linux-lmsensors.c": "/** \n * @file    linux-lmsensors.c\n * @author  Daniel Lucio\n * @author  Joachim Protze\n * @author  Heike Jagode\n *          jagode@eecs.utk.edu\n *\n * @ingroup papi_components\n *\n *\n * LM_SENSORS component \n * \n * Tested version of lm_sensors: 3.1.1\n *\n * @brief \n *  This file has the source code for a component that enables PAPI-C to access\n *  hardware monitoring sensors through the libsensors library. This code will\n *  dynamically create a native events table for all the sensors that can be \n *  accesed by the libsensors library.\n *  In order to learn more about libsensors, visit: (http://www.lm-sensors.org) \n *\n * Notes: \n *  - I used the ACPI and MX components to write this component. A lot of the\n *    code in this file mimics what other components already do. \n *  - The return values are scaled by 1000 because PAPI can not return decimals.\n *  - A call of PAPI_read can take up to 2 seconds while using lm_sensors!\n *  - Please remember that libsensors uses the GPL license. \n */\n\n\n/* Headers required by libsensors */\n#include <sensors.h>\n#include <error.h>\n#include <time.h>\n#include <string.h>\n#include <dlfcn.h>\n\n/* Headers required by PAPI */\n#include \"papi.h\"\n#include \"papi_internal.h\"\n#include \"papi_vector.h\"\n#include \"papi_memory.h\"\n\n/*************************  DEFINES SECTION  ***********************************\n *******************************************************************************/\n// time in usecs\n#define LM_SENSORS_REFRESHTIME 200000\n\n/** Structure that stores private information of each event */\ntypedef struct _lmsensors_register\n{\n\t/* This is used by the framework.It likes it to be !=0 to do somehting */\n\tunsigned int selector;\n\t/* These are the only information needed to locate a libsensors event */\n\tconst sensors_chip_name *name;\n\tint subfeat_nr;\n} _lmsensors_register_t;\n\n/*\n * The following structures mimic the ones used by other components. It is more\n * convenient to use them like that as programming with PAPI makes specific\n * assumptions for them.\n */\n\n/** This structure is used to build the table of events */\ntypedef struct _lmsensors_native_event_entry\n{\n\t_lmsensors_register_t resources;\n\tchar name[PAPI_MAX_STR_LEN];\n\tchar description[PAPI_MAX_STR_LEN];\n\tunsigned int count;\n} _lmsensors_native_event_entry_t;\n\n\ntypedef struct _lmsensors_reg_alloc\n{\n\t_lmsensors_register_t ra_bits;\n} _lmsensors_reg_alloc_t;\n\n\ntypedef struct _lmsensors_control_state\n{\n\tlong_long lastupdate;\n} _lmsensors_control_state_t;\n\n\ntypedef struct _lmsensors_context\n{\n\t_lmsensors_control_state_t state;\n} _lmsensors_context_t;\n\n\n\n/*************************  GLOBALS SECTION  ***********************************\n *******************************************************************************/\n/* This table contains the LM_SENSORS native events */\nstatic _lmsensors_native_event_entry_t *lm_sensors_native_table;\n/* number of events in the table*/\nstatic int num_events = 0;\nstatic long_long *cached_counts = NULL;\t// used for caching readings\n\n\nstatic int (*sensors_initPtr)(FILE *input);\nstatic void (*sensors_cleanupPtr)(void);\nstatic int (*sensors_snprintf_chip_namePtr)(char *str, size_t size,\n\t\t\t\t  const sensors_chip_name *chip);\nstatic char *(*sensors_get_labelPtr)(const sensors_chip_name *name, const sensors_feature *feature);\nstatic int (*sensors_get_valuePtr)(const sensors_chip_name *name, int subfeat_nr,\n\t\t      double *value);\nstatic const sensors_chip_name *(*sensors_get_detected_chipsPtr)(const sensors_chip_name\n\t\t\t\t\t\t       *match, int *nr);\nstatic const sensors_feature *(*sensors_get_featuresPtr)(const sensors_chip_name *name, int *nr);\nstatic const sensors_subfeature *(*sensors_get_all_subfeaturesPtr)(const sensors_chip_name *name,\n\t\t\t    const sensors_feature *feature, int *nr);\n\n// file handles used to access lmsensors libraries with dlopen\nstatic void* dl1 = NULL;\n\nstatic int link_lmsensors_libraries ();\n\npapi_vector_t _lmsensors_vector;\n\n/******************************************************************************\n ********  BEGIN FUNCTIONS  USED INTERNALLY SPECIFIC TO THIS COMPONENT ********\n *****************************************************************************/\n/*\n * Counts number of events available in this system\n */\nstatic unsigned\ndetectSensors( void )\n{\n\tunsigned id = 0;\n\tint chip_nr = 0;\n\tconst sensors_chip_name *chip_name;\n\n\t/* Loop through all the chips, features, subfeatures found */\n\twhile ( ( chip_name =\n\t\t\t  sensors_get_detected_chipsPtr( NULL, &chip_nr ) ) != NULL ) {\n\t\tint a = 0, b;\n\t\tconst sensors_feature *feature;\n\n\t\twhile ( ( feature = sensors_get_featuresPtr( chip_name, &a ) ) ) {\n\t\t\tb = 0;\n\t\t\twhile ( ( sensors_get_all_subfeaturesPtr( chip_name, feature,\n\t\t\t\t\t\t\t\t\t\t\t\t   &b ) ) ) {\n\t\t\t\tid++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn id;\n}\n\n\n/*\n * Create the native events for particulare component (!= 0)\n */\nstatic unsigned\ncreateNativeEvents( void )\n{\n\tunsigned id = 0;\n        unsigned int count;\n\n\tint chip_nr = 0;\n\tconst sensors_chip_name *chip_name;\n\n\t/* component name and description */\n\tstrcpy( _lmsensors_vector.cmp_info.short_name, \"lm_sensors\" );\n\tstrcpy( _lmsensors_vector.cmp_info.description,\n\t\t\t\"lm-sensors provides tools for monitoring the hardware health\" );\n\n\n\t/* Loop through all the chips found */\n\twhile ( ( chip_name =\n\t\t\t  sensors_get_detected_chipsPtr( NULL, &chip_nr ) ) != NULL ) {\n\t   int a, b;\n\t   const sensors_feature *feature;\n\t   const sensors_subfeature *sub;\n\t   char chipnamestring[PAPI_MIN_STR_LEN];\n\n\t   //\t   lm_sensors_native_table[id].count = 0;\n\n\t\t/* get chip name from its internal representation */\n\t   sensors_snprintf_chip_namePtr( chipnamestring,\n\t\t\t\t\t    PAPI_MIN_STR_LEN, chip_name );\n\n\t   a = 0;\n\n\t   /* Loop through all the features found */\n\t   while ( ( feature = sensors_get_featuresPtr( chip_name, &a ) ) ) {\n\t      char *featurelabel;\n\n\t      if ( !( featurelabel = sensors_get_labelPtr( chip_name, feature ))) {\n\t\t fprintf( stderr, \"ERROR: Can't get label of feature %s!\\n\",\n\t\t\t\t\t\t feature->name );\n\t\t continue;\n\t      }\n\n\t      b = 0;\n\n\t      /* Loop through all the subfeatures found */\n\t      while ((sub=sensors_get_all_subfeaturesPtr(chip_name,feature,&b))) {\n\n\t         count = 0;\n\n\t\t /* Save native event data */\n\t\t sprintf( lm_sensors_native_table[id].name, \"%s.%s.%s\",\n\t\t\t  chipnamestring, featurelabel, sub->name );\n\n\t\t strncpy( lm_sensors_native_table[id].description,\n\t\t\t  lm_sensors_native_table[id].name, PAPI_MAX_STR_LEN );\n                 lm_sensors_native_table[id].description[PAPI_MAX_STR_LEN-1] = '\\0';\n\n\t\t /* The selector has to be !=0 . Starts with 1 */\n\t\t lm_sensors_native_table[id].resources.selector = id + 1;\n\n\t\t /* Save the actual references to this event */\n\t\t lm_sensors_native_table[id].resources.name = chip_name;\n\t\t lm_sensors_native_table[id].resources.subfeat_nr = sub->number;\n\n\t\t count = sub->number;\n\n\t\t /* increment the table index counter */\n\t\t id++;\t\t \n\t      }\n\n\t      //   lm_sensors_native_table[id].count = count + 1;\n\t      free( featurelabel );\n\t   }\n\t}\n\n\t/* Return the number of events created */\n\treturn id;\n}\n\n/*\n * Returns the value of the event with index 'i' in lm_sensors_native_table\n * This value is scaled by 1000 to cope with the lack to return decimal numbers\n * with PAPI\n */\n\nstatic long_long\ngetEventValue( unsigned event_id )\n{\n\tdouble value;\n\tint res;\n\n\tres = sensors_get_valuePtr( lm_sensors_native_table[event_id].resources.name,\n\t\t\t\t\t\t\t lm_sensors_native_table[event_id].resources.\n\t\t\t\t\t\t\t subfeat_nr, &value );\n\n\tif ( res < 0 ) {\n\t\tfprintf( stderr, \"libsensors(): Could not read event #%d!\\n\",\n\t\t\t\t event_id );\n\t\treturn -1;\n\t}\n\n\treturn ( ( long_long ) ( value * 1000 ) );\n}\n\n\n/*****************************************************************************\n *******************  BEGIN PAPI's COMPONENT REQUIRED FUNCTIONS  *************\n *****************************************************************************/\n\n/*\n * This is called whenever a thread is initialized\n */\nstatic int\n_lmsensors_init_thread( hwd_context_t *ctx )\n{\n    ( void ) ctx;\n    return PAPI_OK;\n}\n\n\n/* Initialize hardware counters, setup the function vector table\n * and get hardware information, this routine is called when the \n * PAPI process is initialized (IE PAPI_library_init)\n */\nstatic int\n_lmsensors_init_component( int cidx )\n{\n    int res;\n    (void) cidx;\n\n    /* link in all the lmsensor libraries and resolve the symbols we need to use */\n    if (link_lmsensors_libraries() != PAPI_OK) {\n\t    SUBDBG (\"Dynamic link of lmsensors libraries failed, component will be disabled.\\n\");\n\t    SUBDBG (\"See disable reason in papi_component_avail output for more details.\\n\");\n\t    return (PAPI_ENOSUPP);\n    }\n\n    /* Initialize libsensors library */\n    if ( ( res = sensors_initPtr( NULL ) ) != 0 ) {\n       strncpy(_lmsensors_vector.cmp_info.disabled_reason,\n\t      \"Cannot enable libsensors\",PAPI_MAX_STR_LEN);\n       return res;\n    }\n\n    /* Create dyanmic events table */\n    num_events = detectSensors(  );\n    SUBDBG(\"Found %d sensors\\n\",num_events);\n\n    _lmsensors_vector.cmp_info.num_mpx_cntrs = num_events;\n    _lmsensors_vector.cmp_info.num_cntrs = num_events;\n\n    if ( ( lm_sensors_native_table =\n\t   calloc( num_events, sizeof ( _lmsensors_native_event_entry_t )))\n\t\t\t\t   == NULL ) {\n       strncpy(_lmsensors_vector.cmp_info.disabled_reason,\n\t      \"Could not malloc room\",PAPI_MAX_STR_LEN);\n       return PAPI_ENOMEM;\n    }\n\n    cached_counts = (long long*) calloc(num_events, sizeof(long long));\n\n    if (cached_counts == NULL) {\n        strncpy(_lmsensors_vector.cmp_info.disabled_reason,\n               \"Could not malloc room\",PAPI_MAX_STR_LEN);\n\treturn PAPI_ENOMEM;\n    }\n\n    if ( ( unsigned ) num_events != createNativeEvents(  ) ) {\n       strncpy(_lmsensors_vector.cmp_info.disabled_reason,\n\t      \"LM_SENSOR number mismatch\",PAPI_MAX_STR_LEN);\n       return PAPI_ECMP;\n    }\n\n    _lmsensors_vector.cmp_info.num_native_events=num_events;\n    _lmsensors_vector.cmp_info.num_cntrs=num_events;\n\n    return PAPI_OK;\n}\n\n/*\n * Link the necessary lmsensors libraries to use the lmsensors\n * component.  If any of them can not be found, then the lmsensors\n * component will just be disabled.  This is done at runtime so that a\n * version of PAPI built with the Infiniband component can be\n * installed and used on systems which have the lmsensors libraries\n * installed and on systems where these libraries are not installed.\n */\nstatic int\nlink_lmsensors_libraries ()\n{\n\t/* Need to link in the lmsensors libraries, if not found disable the component */\n\tdl1 = dlopen(\"libsensors.so\", RTLD_NOW | RTLD_GLOBAL);\n\tif (!dl1)\n\t{\n\t\tstrncpy(_lmsensors_vector.cmp_info.disabled_reason,\n\t\t\t\"lmsensors library libsensors.so not found.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tsensors_initPtr = dlsym(dl1, \"sensors_init\");\n\tif (dlerror() != NULL)\n\t{\n\t\tstrncpy(_lmsensors_vector.cmp_info.disabled_reason,\n\t\t\t\"lmsensor function sensors_init.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tsensors_cleanupPtr = dlsym(dl1, \"sensors_cleanup\");\n\tif (dlerror() != NULL)\n\t{\n\t\tstrncpy(_lmsensors_vector.cmp_info.disabled_reason,\n\t\t\t\"lmsensor function sensors_cleanup.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tsensors_snprintf_chip_namePtr = dlsym(dl1, \"sensors_snprintf_chip_name\");\n\tif (dlerror() != NULL)\n\t{\n\t\tstrncpy(_lmsensors_vector.cmp_info.disabled_reason,\n\t\t\t\"lmsensor function sensors_snprintf_chip_name.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tsensors_get_labelPtr = dlsym(dl1, \"sensors_get_label\");\n\tif (dlerror() != NULL)\n\t{\n\t\tstrncpy(_lmsensors_vector.cmp_info.disabled_reason,\n\t\t\t\"lmsensor function sensors_get_label.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tsensors_get_valuePtr = dlsym(dl1, \"sensors_get_value\");\n\tif (dlerror() != NULL)\n\t{\n\t\tstrncpy(_lmsensors_vector.cmp_info.disabled_reason,\n\t\t\t\"lmsensor function sensors_get_value.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tsensors_get_detected_chipsPtr = dlsym(dl1, \"sensors_get_detected_chips\");\n\tif (dlerror() != NULL)\n\t{\n\t\tstrncpy(_lmsensors_vector.cmp_info.disabled_reason,\n\t\t\t\"lmsensor function sensors_get_detected_chips.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tsensors_get_featuresPtr = dlsym(dl1, \"sensors_get_features\");\n\tif (dlerror() != NULL)\n\t{\n\t\tstrncpy(_lmsensors_vector.cmp_info.disabled_reason,\n\t\t\t\"lmsensor function sensors_get_features.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tsensors_get_all_subfeaturesPtr = dlsym(dl1, \"sensors_get_all_subfeatures\");\n\tif (dlerror() != NULL)\n\t{\n\t\tstrncpy(_lmsensors_vector.cmp_info.disabled_reason,\n\t\t\t\"lmsensor function sensors_get_all_subfeatures.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\n\treturn ( PAPI_OK );\n}\n\n/*\n * Control of counters (Reading/Writing/Starting/Stopping/Setup)\n * functions\n */\nstatic int\n_lmsensors_init_control_state( hwd_control_state_t *ctl )\n{\n\tint i;\n\n\tfor ( i = 0; i < num_events; i++ )\n\t\tcached_counts[i] = getEventValue( i );\n\n\t( ( _lmsensors_control_state_t * ) ctl )->lastupdate =\n\t\tPAPI_get_real_usec(  );\n\treturn PAPI_OK;\n}\n\n\n/*\n *\n */\nstatic int\n_lmsensors_start( hwd_context_t *ctx, hwd_control_state_t *ctl )\n{\n\t( void ) ctx;\n\t( void ) ctl;\n\n\treturn PAPI_OK;\n}\n\n\n/*\n *\n */\nstatic int\n_lmsensors_stop( hwd_context_t *ctx, hwd_control_state_t *ctl )\n{\n    ( void ) ctx;\n    ( void ) ctl;\n\n    return PAPI_OK;\n}\n\n\n/*\n *\n */\nstatic int\n_lmsensors_read( hwd_context_t *ctx, hwd_control_state_t *ctl,\n\t\t long_long ** events, int flags )\n{\n    ( void ) ctx;\n    ( void ) flags;\n    long long start = PAPI_get_real_usec(  );\n    int i;\n \n    _lmsensors_control_state_t *control=(_lmsensors_control_state_t *)ctl;\n\n    if ( start - control->lastupdate > 200000 ) {\t// cache refresh\n       \n       for ( i = 0; i < num_events; i++ ) {\n\t   cached_counts[i] = getEventValue( i );\n       }\n       control->lastupdate = PAPI_get_real_usec(  );\n    }\n\n    *events = cached_counts;\n    return PAPI_OK;\n}\n\n\nstatic int\n_lmsensors_shutdown_component( void )\n{\n\tif (cached_counts)\n\t\tfree(cached_counts);\n\n\t/* Call the libsensors cleaning function before leaving */\n\tsensors_cleanupPtr(  );\n\n\treturn PAPI_OK;\n}\n\nstatic int\n_lmsensors_shutdown_thread( hwd_context_t *ctx )\n{\n    ( void ) ctx;\n\n    return PAPI_OK;\n}\n\n\n\n/* This function sets various options in the component\n * The valid codes being passed in are PAPI_SET_DEFDOM,\n * PAPI_SET_DOMAIN, PAPI_SETDEFGRN, PAPI_SET_GRANUL * and PAPI_SET_INHERIT\n */\nstatic int\n_lmsensors_ctl( hwd_context_t *ctx, int code, _papi_int_option_t *option )\n{\n    ( void ) ctx;\n    ( void ) code;\n    ( void ) option;\n    return PAPI_OK;\n}\n\n\nstatic int\n_lmsensors_update_control_state( hwd_control_state_t *ctl,\n\t\t\t\t NativeInfo_t * native, \n\t\t\t\t int count,\n\t\t\t\t hwd_context_t *ctx )\n{\n    int i, index;\n    ( void ) ctx;\n    ( void ) ctl;\n\n    for ( i = 0; i < count; i++ ) {\n\tindex = native[i].ni_event;\n\tnative[i].ni_position =\n\t\t\tlm_sensors_native_table[index].resources.selector - 1;\n    }\n    return PAPI_OK;\n}\n\n\n/*\n * As I understand it, all data reported by these interfaces will be system wide\n */\nstatic int\n_lmsensors_set_domain( hwd_control_state_t *ctl, int domain )\n{\n\t(void) ctl;\n\tif ( PAPI_DOM_ALL != domain )\n\t\treturn ( PAPI_EINVAL );\n\n\treturn ( PAPI_OK );\n}\n\n\n/*\n *\n */\nstatic int\n_lmsensors_reset( hwd_context_t *ctx, hwd_control_state_t *ctl )\n{\n    ( void ) ctx;\n    ( void ) ctl;\n    return PAPI_OK;\n}\n\n\n/*\n * Native Event functions\n */\nstatic int\n_lmsensors_ntv_enum_events( unsigned int *EventCode, int modifier )\n{\n\n\tswitch ( modifier ) {\n\tcase PAPI_ENUM_FIRST:\n\t\t*EventCode = 0;\n\n\t\treturn PAPI_OK;\n\t\tbreak;\n\n\tcase PAPI_ENUM_EVENTS:\n\t{\n\t\tint index = *EventCode;\n\n\t\tif ( index < num_events - 1 ) {\n\t\t\t*EventCode = *EventCode + 1;\n\t\t\treturn PAPI_OK;\n\t\t} else\n\t\t\treturn PAPI_ENOEVNT;\n\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn PAPI_EINVAL;\n\t}\n\treturn PAPI_EINVAL;\n}\n\n/*\n *\n */\nstatic int\n_lmsensors_ntv_code_to_name( unsigned int EventCode, char *name, int len )\n{\n\tint index = EventCode;\n\n\tif (index>=0 && index<num_events) {\n\t   strncpy( name, lm_sensors_native_table[index].name, len );\n\t}\n\n\treturn PAPI_OK;\n}\n\n/*\n *\n */\nstatic int\n_lmsensors_ntv_code_to_descr( unsigned int EventCode, char *name, int len )\n{\n\tint index = EventCode;\n\n\tif (index>=0 && index<num_events) {\n\t   strncpy( name, lm_sensors_native_table[index].description, len );\n\t}\n\treturn PAPI_OK;\n}\n\n\n\n/*\n *\n */\npapi_vector_t _lmsensors_vector = {\n   .cmp_info = {\n        /* component information (unspecified values are initialized to 0) */\n\t.name = \"lmsensors\",\n\t.short_name = \"lmsensors\",\n\t.version = \"5.0\",\n\t.description = \"Linux LMsensor statistics\",\n\t.num_mpx_cntrs = 0,\n\t.num_cntrs = 0,\n\t.default_domain = PAPI_DOM_ALL,\n\t.default_granularity = PAPI_GRN_SYS,\n\t.available_granularities = PAPI_GRN_SYS,\n\t.hardware_intr_sig = PAPI_INT_SIGNAL,\n\n\t/* component specific cmp_info initializations */\n\t.fast_real_timer = 0,\n\t.fast_virtual_timer = 0,\n\t.attach = 0,\n\t.attach_must_ptrace = 0,\n\t.available_domains = PAPI_DOM_USER | PAPI_DOM_KERNEL,\n  },\n\n        /* sizes of framework-opaque component-private structures */\n\t.size = {\n\t   .context = sizeof ( _lmsensors_context_t ),\n\t   .control_state = sizeof ( _lmsensors_control_state_t ),\n\t   .reg_value = sizeof ( _lmsensors_register_t ),\n\t   .reg_alloc = sizeof ( _lmsensors_reg_alloc_t ),\n  },\n\t/* function pointers in this component */\n     .init_thread =          _lmsensors_init_thread,\n     .init_component =       _lmsensors_init_component,\n     .init_control_state =   _lmsensors_init_control_state,\n     .start =                _lmsensors_start,\n     .stop =                 _lmsensors_stop,\n     .read =                 _lmsensors_read,\n     .shutdown_thread =      _lmsensors_shutdown_thread,\n     .shutdown_component =   _lmsensors_shutdown_component,\n     .ctl =                  _lmsensors_ctl,\n     .update_control_state = _lmsensors_update_control_state,\n     .set_domain =           _lmsensors_set_domain,\n     .reset =                _lmsensors_reset,\n\t\n     .ntv_enum_events =      _lmsensors_ntv_enum_events,\n     .ntv_code_to_name =     _lmsensors_ntv_code_to_name,\n     .ntv_code_to_descr =    _lmsensors_ntv_code_to_descr,\n};\n",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.6.0-iweh6uy7qfzcgjj77nhy45ucjhpm2ow6/spack-src/src/components/libmsr/linux-libmsr.c": "/**\n * @file    linux-libmsr.c\n * @author  Asim YarKhan\n *\n * @ingroup papi_components\n *\n * @brief libmsr component\n *\n * This PAPI component provides access to libmsr from LLNL\n * (https://github.com/scalability-llnl/libmsr), specifically the RAPL\n * (Running Average Power Level) access in libmsr, which provides\n * energy measurements on modern Intel CPUs.\n *\n * To work, either msr_safe kernel module from LLNL\n * (https://github.com/scalability-llnl/msr-safe), or the x86 generic\n * MSR driver must be installed (CONFIG_X86_MSR) and the\n * /dev/cpu/?/<msr_safe | msr> files must have read permissions\n *\n * If /dev/cpu/?/{msr_safe,msr} have appropriate write permissions,\n * you can write to the events PACKAGE_POWER_LIMIT_{1,2} to change the\n * average power (in watts) consumed by the packages/sockets over a\n * certain time window specified by events\n * PKG_TIME_WINDOW_POWER_LIMIT_{1,2} respectively.\n */\n/* Based on the rapl component by Vince Weaver */\n\n#include <stdio.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <string.h>\n#include <stdint.h>\n#include <errno.h>\n\n/* Headers required by PAPI */\n#include \"papi.h\"\n#include \"papi_internal.h\"\n#include \"papi_vector.h\"\n#include \"papi_memory.h\"\n\n#include <msr/msr_core.h>\n#include <msr/msr_rapl.h>\n#include <msr/msr_counters.h>\n\ntypedef enum {\n    PKG_ENERGY=0,\n    PKG_ELAPSED,\n    PKG_DELTA_ENERGY,\n    PKG_WATTS,\n    PKG_POWER_LIMIT_1,\n    PKG_TIME_WINDOW_POWER_LIMIT_1,\n    PKG_POWER_LIMIT_2,\n    PKG_TIME_WINDOW_POWER_LIMIT_2,\n    NUM_OF_EVENTTYPES\n} eventtype_enum;\n\ntypedef struct _libmsr_register {\n    unsigned int selector;\n} _libmsr_register_t;\n\ntypedef struct _libmsr_native_event_entry {\n    char name[PAPI_MAX_STR_LEN];\n    char units[PAPI_MIN_STR_LEN];\n    char description[PAPI_MAX_STR_LEN];\n    int package_num;            /* which package/socket for this event */\n    eventtype_enum eventtype;\n    int return_type;\n    _libmsr_register_t resources;\n} _libmsr_native_event_entry_t;\n\ntypedef struct _libmsr_reg_alloc {\n    _libmsr_register_t ra_bits;\n} _libmsr_reg_alloc_t;\n\n/* actually 32? But setting this to be safe? */\n#define LIBMSR_MAX_COUNTERS 64\n#define LIBMSR_MAX_PACKAGES 64\n\ntypedef struct _libmsr_control_state {\n    /* The following are one per event being measured */\n    int num_events_measured;\n    /* int domain; */\n    /* int multiplexed; */\n    /* int overflow; */\n    /* int inherit; */\n    int being_measured[LIBMSR_MAX_COUNTERS];\n    int which_counter[LIBMSR_MAX_COUNTERS];\n    long long count[LIBMSR_MAX_COUNTERS];\n    /* The following is boolean: Is package NN active in for event */\n    int package_being_measured[LIBMSR_MAX_PACKAGES];\n} _libmsr_control_state_t;\n\ntypedef struct _libmsr_context {\n    _libmsr_control_state_t state;\n} _libmsr_context_t;\n\npapi_vector_t _libmsr_vector;\n\nstatic _libmsr_native_event_entry_t *libmsr_native_events = NULL;\nstatic int num_events_global = 0;\nstatic int already_called_libmsr_rapl_initialized_global = 0;\n\n/***************************************************************************/\n\n/* For dynamic linking to libmsr */\n/* Using weak symbols allows PAPI to be built with the component, but\n * installed in a system without the required library */\n#include <dlfcn.h>\nstatic void* dllib1 = NULL;\nvoid (*_dl_non_dynamic_init)(void) __attribute__((weak));\n\n/* Functions pointers */\nstatic int (*init_msr_ptr)();\nstatic int (*finalize_msr_ptr)();\nstatic int (*rapl_init_ptr)(struct rapl_data ** rapl, uint64_t ** rapl_flags);\nstatic int (*poll_rapl_data_ptr) ( );\nstatic void (*set_pkg_rapl_limit_ptr) ( const int socket, struct rapl_limit* limit1, struct rapl_limit* limit2 );\nstatic void (*get_pkg_rapl_limit_ptr) ( const int socket, struct rapl_limit* limit1, struct rapl_limit* limit2 );\nstatic int (*core_config_ptr) (uint64_t * coresPerSocket, uint64_t * threadsPerCore, uint64_t * sysSockets, int * HTenabled);\nstatic int (*rapl_storage_ptr) (struct rapl_data ** data, uint64_t ** flags);\nstatic int (*get_rapl_power_info_ptr) ( const unsigned socket, struct rapl_power_info *info);\n\n/* Local wrappers for function pointers */\nstatic int libmsr_init_msr () { return ((*init_msr_ptr)()); }\nstatic int libmsr_finalize_msr () { return ((*finalize_msr_ptr)()); }\nstatic int libmsr_rapl_init (struct rapl_data ** rapl_data, uint64_t ** rapl_flags) { return (*rapl_init_ptr)( rapl_data, rapl_flags ); }\nstatic int libmsr_poll_rapl_data ( ) { return (*poll_rapl_data_ptr) (); }\nstatic void libmsr_set_pkg_rapl_limit ( const int socket, struct rapl_limit* limit1, struct rapl_limit* limit2 ) { return (*set_pkg_rapl_limit_ptr) ( socket, limit1, limit2 ); }\nstatic void libmsr_get_pkg_rapl_limit ( const int socket, struct rapl_limit* limit1, struct rapl_limit* limit2 ) { return (*get_pkg_rapl_limit_ptr) ( socket, limit1, limit2 ); }\nstatic int libmsr_core_config(uint64_t * coresPerSocket, uint64_t * threadsPerCore, uint64_t * sysSockets, int * HTenabled) { return (*core_config_ptr) ( coresPerSocket, threadsPerCore, sysSockets, HTenabled ); }\nstatic int libmsr_rapl_storage(struct rapl_data ** data, uint64_t ** flags) { return (*rapl_storage_ptr) (data, flags); }\nstatic int libmsr_get_rapl_power_info( const unsigned socket, struct rapl_power_info *info) { return (*get_rapl_power_info_ptr) ( socket, info); }\n\n\n#define CHECK_DL_STATUS( err, str ) if( err ) { strncpy( _libmsr_vector.cmp_info.disabled_reason, str, PAPI_MAX_STR_LEN ); return ( PAPI_ENOSUPP ); }\nstatic int _local_linkDynamicLibraries()\n{\n    if ( _dl_non_dynamic_init != NULL ) {\n        strncpy( _libmsr_vector.cmp_info.disabled_reason, \"The libmsr component REQUIRES dynamic linking capabilities.\", PAPI_MAX_STR_LEN);\n        return PAPI_ENOSUPP;\n    }\n    dllib1 = dlopen(\"libmsr.so\", RTLD_NOW | RTLD_GLOBAL);\n    CHECK_DL_STATUS( !dllib1 , \"Component library libmsr.so not found.\" );\n    init_msr_ptr = dlsym( dllib1, \"init_msr\" );\n    CHECK_DL_STATUS( dlerror()!=NULL , \"libmsr function init_msr not found.\" );\n    finalize_msr_ptr = dlsym( dllib1, \"finalize_msr\" );\n    CHECK_DL_STATUS( dlerror()!=NULL, \"libmsr function finalize_msr not found.\" );\n    rapl_init_ptr = dlsym( dllib1, \"rapl_init\" );\n    CHECK_DL_STATUS( dlerror()!=NULL, \"libmsr function rapl_init not found.\" );\n    poll_rapl_data_ptr = dlsym( dllib1, \"poll_rapl_data\" );\n    CHECK_DL_STATUS( dlerror()!=NULL, \"libmsr function poll_rapl_data not found.\" );\n    set_pkg_rapl_limit_ptr = dlsym( dllib1, \"set_pkg_rapl_limit\" );\n    CHECK_DL_STATUS( dlerror()!=NULL, \"libmsr function set_pkg_rapl_limit not found.\" );\n    get_pkg_rapl_limit_ptr = dlsym( dllib1, \"get_pkg_rapl_limit\" );\n    CHECK_DL_STATUS( dlerror()!=NULL, \"libmsr function get_pkg_rapl_limit not found.\" );\n    core_config_ptr = dlsym( dllib1, \"core_config\" );\n    CHECK_DL_STATUS( dlerror()!=NULL, \"libmsr function core_config not found.\" );\n    rapl_storage_ptr = dlsym( dllib1, \"rapl_storage\" );\n    CHECK_DL_STATUS( dlerror()!=NULL, \"libmsr function rapl_storage not found.\" );\n    get_rapl_power_info_ptr = dlsym( dllib1, \"get_rapl_power_info\" );\n    CHECK_DL_STATUS( dlerror()!=NULL, \"libmsr function get_rapl_power_info not found.\" );\n    return( PAPI_OK);\n}\n\n/***************************************************************************/\n/******  BEGIN FUNCTIONS  USED INTERNALLY SPECIFIC TO THIS COMPONENT *******/\n/***************************************************************************/\n\n/* Null terminated version of strncpy */\nstatic char * _local_strlcpy( char *dst, const char *src, size_t size )\n{\n    char *retval = strncpy( dst, src, size );\n    if ( size>0 ) dst[size-1] = '\\0';\n    return( retval );\n}\n\n\nvoid _local_set_to_defaults()\n{\n    uint64_t socket, numSockets;\n    struct rapl_power_info raplinfo;\n    struct rapl_limit socketlim, socketlim2;\n\n    SUBDBG(\"Enter: Resetting the sockets to defaults\\n\");\n    libmsr_core_config( NULL, NULL, &numSockets, NULL);\n    for (socket = 0; socket < numSockets; socket++)  {\n        libmsr_get_rapl_power_info(socket, &raplinfo);\n        socketlim.bits = 0;\n        socketlim.watts = raplinfo.pkg_therm_power;\n        socketlim.seconds = 1;\n        socketlim2.bits = 0;\n        socketlim2.watts = raplinfo.pkg_therm_power * 1.2;\n        socketlim2.seconds = 3;\n        SUBDBG(\"Resetting socket %ld to defaults (%f,%f) (%f,%f)\\n\", socket, socketlim.watts, socketlim.seconds, socketlim2.watts, socketlim2.seconds);\n        libmsr_set_pkg_rapl_limit(socket, &socketlim, &socketlim2);\n    }\n}\n\n\n/************************* PAPI Functions **********************************/\n\n/*\n * This is called whenever a thread is initialized\n */\nint _libmsr_init_thread( hwd_context_t * ctx )\n{\n    ( void ) ctx;\n    return PAPI_OK;\n}\n\n\n/*\n * Called when PAPI process is initialized (i.e. PAPI_library_init)\n */\nint _libmsr_init_component( int cidx )\n{\n    SUBDBG( \"Enter: cidx: %d\\n\", cidx );\n    int i, j;\n    /* int package; */\n    /* FILE *fff; */\n    /* char filename[BUFSIZ]; */\n    int num_packages;\n    /* int num_cpus; */\n    const PAPI_hw_info_t *hw_info;\n    int retval;\n    struct rapl_data * libmsr_rapl_data;\n    uint64_t * libmsr_rapl_flags;\n    uint64_t coresPerSocket, threadsPerCore, numSockets;\n    int HTenabled;\n\n    /* check if Intel processor */\n    hw_info = &( _papi_hwi_system_info.hw_info );\n    /* Can't use PAPI_get_hardware_info() if PAPI library not done initializing yet */\n    if( hw_info->vendor != PAPI_VENDOR_INTEL ) {\n        strncpy( _libmsr_vector.cmp_info.disabled_reason, \"Not an Intel processor\", PAPI_MAX_STR_LEN );\n        return PAPI_ENOSUPP;\n    }\n\n    /* Dynamically load libmsr API and libraries  */\n    retval = _local_linkDynamicLibraries();\n    if ( retval!=PAPI_OK ) {\n        SUBDBG (\"Dynamic link of libmsr.so libraries failed, component will be disabled.\\n\");\n        SUBDBG (\"See disable reason in papi_component_avail output for more details.\\n\");\n        return (PAPI_ENOSUPP);\n    }\n\n    /* initialize libmsr */\n    if ( libmsr_init_msr() != 0 ) {\n        strncpy( _libmsr_vector.cmp_info.disabled_reason, \"Library libmsr could not initialize (libmsr/init_msr failed)\", PAPI_MAX_STR_LEN );\n        SUBDBG( \"init_msr (libmsr) returned error.  Possible problems accessing /dev/cpu/<n>/msr_safe or /dev/cpu/<n>/msr\"); \n        return PAPI_ENOSUPP; \n    }\n\n    /* Initialize libmsr RAPL */\n    if ( already_called_libmsr_rapl_initialized_global==0 ) {\n        if ( libmsr_rapl_init( &libmsr_rapl_data, &libmsr_rapl_flags ) < 0 ) {\n            strncpy( _libmsr_vector.cmp_info.disabled_reason, \"Library libmsr could not initialize RAPL (libmsr/rapl_init failed)\", PAPI_MAX_STR_LEN );\n            SUBDBG( \"Library libmsr could not initialize RAPL (libmsr/rapl_init failed)\"); \n            return PAPI_ENOSUPP;\n        }\n        already_called_libmsr_rapl_initialized_global = 1;\n    }\n\n    /* Get the numbers of cores, threads, sockets, ht */\n    libmsr_core_config(&coresPerSocket, &threadsPerCore, &numSockets, &HTenabled);\n\n    /* Fill packages and cpus with sentinel values */\n    /* int packages[numSockets]; */\n    /* for( i = 0; i < numSockets; ++i ) packages[i] = -1; */\n    /* num_cpus = numSockets*coresPerSocket; */\n    num_packages = numSockets;\n\n    /* /\\* Detect how many packages and count num_cpus *\\/ */\n    /* num_cpus = 0; */\n    /* while( 1 ) { */\n    /*     int num_read; */\n    /*     sprintf( filename, \"/sys/devices/system/cpu/cpu%d/topology/physical_package_id\", num_cpus ); */\n    /*     fff = fopen( filename, \"r\" ); */\n    /*     if( fff == NULL ) break; */\n    /*     num_read = fscanf( fff, \"%d\", &package ); */\n    /*     fclose( fff ); */\n    /*     if( num_read != 1 ) { */\n    /*         strcpy( _libmsr_vector.cmp_info.disabled_reason, \"Error reading file: \" ); */\n    /*         strncat( _libmsr_vector.cmp_info.disabled_reason, filename, PAPI_MAX_STR_LEN - strlen( _libmsr_vector.cmp_info.disabled_reason ) - 1 ); */\n    /*         _libmsr_vector.cmp_info.disabled_reason[PAPI_MAX_STR_LEN - 1] = '\\0'; */\n    /*         return PAPI_ESYS; */\n    /*     } */\n    /*     /\\* Check if a new package *\\/ */\n    /*     if( ( package >= 0 ) && ( package < nr_cpus ) ) { */\n    /*         if( packages[package] == -1 ) { */\n    /*             SUBDBG( \"Found package %d out of total %d\\n\", package, num_packages ); */\n    /*             packages[package] = package; */\n    /*             num_packages++; */\n    /*         } */\n    /*     } else { */\n    /*         SUBDBG( \"Package outside of allowed range\\n\" ); */\n    /*         strncpy( _libmsr_vector.cmp_info.disabled_reason, \"Package outside of allowed range\", PAPI_MAX_STR_LEN ); */\n    /*         return PAPI_ESYS; */\n    /*     } */\n    /*     num_cpus++; */\n    /* } */\n\n    /* /\\* Error if no accessible packages *\\/ */\n    /* if( num_packages == 0 ) { */\n    /*     SUBDBG( \"Can't access any physical packages\\n\" ); */\n    /*     strncpy( _libmsr_vector.cmp_info.disabled_reason, \"Can't access /sys/devices/system/cpu/cpu<d>/topology/physical_package_id\", PAPI_MAX_STR_LEN ); */\n    /*     return PAPI_ESYS; */\n    /* } */\n    /* SUBDBG( \"Found %d packages with %d cpus\\n\", num_packages, num_cpus ); */\n\n    int max_num_events = ( NUM_OF_EVENTTYPES * num_packages );\n    /* Allocate space for events */\n    libmsr_native_events = ( _libmsr_native_event_entry_t * ) calloc( sizeof( _libmsr_native_event_entry_t ), max_num_events );\n    if ( !libmsr_native_events ) SUBDBG(\"Could not allocate memory\\n\" );\n\n    /* Create events for package power info */\n    num_events_global = 0;\n    i = 0;\n    for( j = 0; j < num_packages; j++ ) {\n\n        sprintf( libmsr_native_events[i].name, \"PKG_ENERGY:PACKAGE%d\", j );\n        strncpy( libmsr_native_events[i].units, \"J\", PAPI_MIN_STR_LEN );\n        sprintf(libmsr_native_events[i].description,\"Number of Joules consumed by all cores and last level cache on package.  Unit is Joules (double precision).\");\n        libmsr_native_events[i].package_num = j;\n        libmsr_native_events[i].resources.selector = i + 1;\n        libmsr_native_events[i].eventtype = PKG_ENERGY;\n        libmsr_native_events[i].return_type = PAPI_DATATYPE_FP64;\n        i++;\n\n        sprintf( libmsr_native_events[i].name, \"PKG_WATTS:PACKAGE%d\", j );\n        strncpy( libmsr_native_events[i].units, \"W\", PAPI_MIN_STR_LEN );\n        sprintf( libmsr_native_events[i].description, \"Watts consumed by package. Unit is Watts (double precision).\");\n        libmsr_native_events[i].package_num = j;\n        libmsr_native_events[i].resources.selector = i + 1;\n        libmsr_native_events[i].eventtype = PKG_WATTS;\n        libmsr_native_events[i].return_type = PAPI_DATATYPE_FP64;\n        i++;\n\n        sprintf( libmsr_native_events[i].name, \"PKG_ELAPSED:PACKAGE%d\", j );\n        strncpy( libmsr_native_events[i].units, \"S\", PAPI_MIN_STR_LEN );\n        sprintf( libmsr_native_events[i].description, \"Time elapsed since last LIBMSR data reading from package. Unit is seconds (double precision).\");\n        libmsr_native_events[i].package_num = j;\n        libmsr_native_events[i].resources.selector = i + 1;\n        libmsr_native_events[i].eventtype = PKG_ELAPSED;\n        libmsr_native_events[i].return_type = PAPI_DATATYPE_FP64;\n        i++;\n\n        sprintf( libmsr_native_events[i].name, \"PKG_DELTA_ENERGY:PACKAGE%d\", j );\n        strncpy( libmsr_native_events[i].units, \"J\", PAPI_MIN_STR_LEN );\n        sprintf( libmsr_native_events[i].description, \"Number of Joules consumed by package since last LIBMSR data reading.  Unit is Joules (double precision).\");\n        libmsr_native_events[i].package_num = j;\n        libmsr_native_events[i].resources.selector = i + 1;\n        libmsr_native_events[i].eventtype = PKG_DELTA_ENERGY;\n        libmsr_native_events[i].return_type = PAPI_DATATYPE_FP64;\n        i++;\n\n        sprintf( libmsr_native_events[i].name, \"PKG_POWER_LIMIT_1:PACKAGE%d\", j );\n        strncpy( libmsr_native_events[i].units, \"W\", PAPI_MIN_STR_LEN );\n        sprintf( libmsr_native_events[i].description, \"Average power limit over PKG_TIME_WINDOW_POWER_LIMIT_1 for package. Read/Write. Unit is Watts (double precision).\");\n        libmsr_native_events[i].package_num = j;\n        libmsr_native_events[i].resources.selector = i + 1;\n        libmsr_native_events[i].eventtype = PKG_POWER_LIMIT_1;\n        libmsr_native_events[i].return_type = PAPI_DATATYPE_FP64;\n        i++;\n\n        sprintf( libmsr_native_events[i].name, \"PKG_TIME_WINDOW_POWER_LIMIT_1:PACKAGE%d\", j );\n        strncpy( libmsr_native_events[i].units, \"S\", PAPI_MIN_STR_LEN );\n        sprintf( libmsr_native_events[i].description, \"Time window used for averaging PACKAGE_POWER_LIMIT_1 for package.  Read/Write.  Unit is seconds (double precision).\");\n        libmsr_native_events[i].package_num = j;\n        libmsr_native_events[i].resources.selector = i + 1;\n        libmsr_native_events[i].eventtype = PKG_TIME_WINDOW_POWER_LIMIT_1;\n        libmsr_native_events[i].return_type = PAPI_DATATYPE_FP64;\n        i++;\n\n        sprintf( libmsr_native_events[i].name, \"PKG_POWER_LIMIT_2:PACKAGE%d\", j );\n        strncpy( libmsr_native_events[i].units, \"W\", PAPI_MIN_STR_LEN );\n        sprintf( libmsr_native_events[i].description, \"Average power limit over PKG_TIME_WINDOW_POWER_LIMIT_2 for package. Read/Write. Unit is Watts (double precision).\");\n        libmsr_native_events[i].package_num = j;\n        libmsr_native_events[i].resources.selector = i + 1;\n        libmsr_native_events[i].eventtype = PKG_POWER_LIMIT_2;\n        libmsr_native_events[i].return_type = PAPI_DATATYPE_FP64;\n        i++;\n\n        sprintf( libmsr_native_events[i].name, \"PKG_TIME_WINDOW_POWER_LIMIT_2:PACKAGE%d\", j );\n        strncpy( libmsr_native_events[i].units, \"S\", PAPI_MIN_STR_LEN );\n        sprintf( libmsr_native_events[i].description, \"Time window used for averaging PACKAGE_POWER_LIMIT_2 for package.  Read/Write.  Unit is seconds (double precision).\");\n        libmsr_native_events[i].package_num = j;\n        libmsr_native_events[i].resources.selector = i + 1;\n        libmsr_native_events[i].eventtype = PKG_TIME_WINDOW_POWER_LIMIT_2;\n        libmsr_native_events[i].return_type = PAPI_DATATYPE_FP64;\n        i++;\n\n        // TODO Add DRAM values\n        // DRAM_ENERGY\n        // DRAM_DELTA_ENERGY\n        // DRAM_WATTS\n        // TODO Add PP0, PP1 events\n    }\n    num_events_global = i;\n\n    /* Export the total number of events available */\n    _libmsr_vector.cmp_info.num_native_events = num_events_global;\n    _libmsr_vector.cmp_info.num_cntrs = _libmsr_vector.cmp_info.num_native_events;\n    _libmsr_vector.cmp_info.num_mpx_cntrs = _libmsr_vector.cmp_info.num_native_events;\n\n    /* Export the component id */\n    _libmsr_vector.cmp_info.CmpIdx = cidx;\n\n    return PAPI_OK;\n}\n\n\n/*\n * Control of counters (Reading/Writing/Starting/Stopping/Setup)\n */\nint _libmsr_init_control_state( hwd_control_state_t * ctl )\n{\n    SUBDBG( \"Enter: ctl: %p\\n\", ctl );\n    _libmsr_control_state_t *control = ( _libmsr_control_state_t * ) ctl;\n    int i;\n\n    for( i = 0; i < LIBMSR_MAX_COUNTERS; i++ )\n        control->which_counter[i] = 0;\n    for( i = 0; i < LIBMSR_MAX_PACKAGES; i++ )\n        control->package_being_measured[i] = 0;\n    control->num_events_measured = 0;\n\n    return PAPI_OK;\n}\n\n\nint _libmsr_update_control_state( hwd_control_state_t * ctl, NativeInfo_t * native, int count, hwd_context_t * ctx )\n{\n    SUBDBG( \"Enter: ctl: %p, ctx: %p\\n\", ctl, ctx );\n    int nn, index;\n    ( void ) ctx;\n    _libmsr_control_state_t *control = ( _libmsr_control_state_t * ) ctl;\n\n    control->num_events_measured = 0;\n    /* Track which events need to be measured */\n    for( nn = 0; nn < count; nn++ ) {\n        index = native[nn].ni_event & PAPI_NATIVE_AND_MASK;\n        native[nn].ni_position = nn;\n        control->which_counter[nn] = index;\n        control->count[nn] = 0;\n        /* Track (on/off vector) which packages/sockets need to be measured for these events */\n        control->package_being_measured[libmsr_native_events[index].package_num] = 1;\n        control->num_events_measured++;\n    }\n    return PAPI_OK;\n}\n\n\nint _libmsr_start( hwd_context_t * ctx, hwd_control_state_t * ctl )\n{\n    SUBDBG( \"Enter: ctl: %p, ctx: %p\\n\", ctl, ctx );\n    ( void ) ctx;\n    ( void ) ctl;\n\n    /* Read once to get initial data */\n    if ( libmsr_poll_rapl_data() < 0 ) {\n        strncpy( _libmsr_vector.cmp_info.disabled_reason, \"Function libmsr.so:poll_rapl_data failed. \", PAPI_MAX_STR_LEN );\n        return PAPI_ESYS;\n    }\n    return PAPI_OK;\n}\n\n\nint _libmsr_read( hwd_context_t * ctx, hwd_control_state_t * ctl, long long **events, int flags )\n{\n    SUBDBG( \"Enter: ctl: %p, ctx: %p\\n\", ctl, ctx );\n    ( void ) flags;\n    ( void ) ctx;\n    _libmsr_control_state_t *control = ( _libmsr_control_state_t * ) ctl;\n    int nn, pp, ee;                 /* native, package, event indices */\n    union { long long ll; double dbl; } event_value_union;\n    struct rapl_limit limit1, limit2;\n    eventtype_enum eventtype;\n    struct rapl_data * libmsr_rapl_data;\n    uint64_t * libmsr_rapl_flags;\n\n    /* Get a pointer to the rapl_data data storage  */\n    if ( libmsr_rapl_storage( &libmsr_rapl_data, &libmsr_rapl_flags)!=0 )  {\n        strncpy( _libmsr_vector.cmp_info.disabled_reason, \"Function libmsr.so:rapl_storage failed. \", PAPI_MAX_STR_LEN );\n        return PAPI_ESYS;\n    }\n\n    /* If any socket/package needs to be read, call the poll once to read all packages */\n    for ( pp = 0; pp < LIBMSR_MAX_PACKAGES; pp++ ) {\n        if ( control->package_being_measured[pp] ) {\n            SUBDBG(\"Calling poll_rapl_data to read state from all sockets\\n\");\n            if ( libmsr_poll_rapl_data()!= 0 ) {\n                strncpy( _libmsr_vector.cmp_info.disabled_reason, \"Function libmsr.so:poll_rapl_data failed. \", PAPI_MAX_STR_LEN );\n                return PAPI_ESYS;\n            }\n            break;\n        }\n    }\n\n    /* Go thru events, assign package data to events as needed */\n    SUBDBG(\"Go thru events, assign package data to events as needed\\n\");\n    for( nn = 0; nn < control->num_events_measured; nn++ ) {\n        ee = control->which_counter[nn];\n        pp = libmsr_native_events[ee].package_num;\n        event_value_union.ll = 0LL;\n        eventtype = libmsr_native_events[ee].eventtype;\n        SUBDBG(\"nn %d ee %d pp %d eventtype %d\\n\", nn, ee, pp, eventtype);\n        switch (eventtype) {\n        case PKG_ENERGY:\n            event_value_union.dbl = libmsr_rapl_data->pkg_joules[pp];\n            break;\n        case PKG_ELAPSED:\n            event_value_union.dbl = libmsr_rapl_data->elapsed;\n            break;\n        case PKG_DELTA_ENERGY:\n            event_value_union.dbl = libmsr_rapl_data->pkg_delta_joules[pp];\n            break;\n        case PKG_WATTS:\n            event_value_union.dbl = libmsr_rapl_data->pkg_watts[pp];\n            break;\n        case PKG_POWER_LIMIT_1:\n            limit1.bits = 0;  limit1.watts = 0; limit1.seconds = 0;\n            libmsr_get_pkg_rapl_limit( pp, &limit1, NULL );\n            event_value_union.dbl = limit1.watts;\n            break;\n        case PKG_TIME_WINDOW_POWER_LIMIT_1:\n            limit1.bits = 0;  limit1.watts = 0; limit1.seconds = 0;\n            libmsr_get_pkg_rapl_limit( pp, &limit1, NULL );\n            event_value_union.dbl = limit1.seconds;\n            break;\n        case PKG_POWER_LIMIT_2:\n            limit2.bits = 0;  limit2.watts = 0; limit2.seconds = 0;\n            libmsr_get_pkg_rapl_limit( pp, NULL, &limit2 );\n            event_value_union.dbl = limit2.watts;\n            break;\n        case PKG_TIME_WINDOW_POWER_LIMIT_2:\n            limit2.bits = 0;  limit2.watts = 0; limit2.seconds = 0;\n            libmsr_get_pkg_rapl_limit( pp, NULL, &limit2 );\n            event_value_union.dbl = limit2.seconds;\n            break;\n        default:\n            SUBDBG(\"This LIBMSR event is unknown\\n\");\n            /* error here */\n        }\n        control->count[nn] = event_value_union.ll;\n    }\n    /* Pass back a pointer to our results */\n    if ( events!=NULL ) *events = ( ( _libmsr_control_state_t * ) ctl )->count;\n    return PAPI_OK;\n}\n\n\nstatic long long _local_get_eventval_from_values( _libmsr_control_state_t *control, long long *invalues, int package_num, eventtype_enum eventtype, long long defaultval )\n{\n    int nn, pp, ee;                 /* native, package, event indices */\n    /* Loop thru all the events, if package and repltype match, return the value  */\n    for( nn = 0; nn < control->num_events_measured; nn++ ) {\n        ee = control->which_counter[nn];\n        pp = libmsr_native_events[ee].package_num;\n        if ( pp == package_num && libmsr_native_events[ee].eventtype == eventtype )\n            return invalues[ee];\n    }\n    return defaultval;\n}\n\n\nint _libmsr_write( hwd_context_t * ctx, hwd_control_state_t * ctl, long long *values )\n{\n    SUBDBG( \"Enter: ctl: %p, ctx: %p\\n\", ctl, ctx );\n    /* write values */\n    ( void ) ctx;\n    _libmsr_control_state_t *control = ( _libmsr_control_state_t * ) ctl;\n    //long long now = PAPI_get_real_usec();\n    int nn, pp, ee;                 /* native, package, event indices */\n    union { long long ll; double dbl; } event_value_union;\n    union { long long ll; double dbl; } timewin_union;\n    struct rapl_limit limit1, limit2;\n    eventtype_enum eventtype;\n\n    /* Go thru events, assign package data to events as needed */\n    for( nn = 0; nn < control->num_events_measured; nn++ ) {\n        ee = control->which_counter[nn];\n        pp = libmsr_native_events[ee].package_num;\n        /* grab value and put into the union structure */\n        event_value_union.ll = values[nn];\n        /* If this is a NULL value, it means that the user does not want to write this value */\n        if ( event_value_union.ll == PAPI_NULL ) continue;\n        eventtype = libmsr_native_events[ee].eventtype;\n        SUBDBG(\"nn %d ee %d pp %d eventtype %d\\n\", nn, ee, pp, eventtype);\n        switch (eventtype) {\n        case PKG_ENERGY:\n        case PKG_ELAPSED:\n        case PKG_WATTS:\n        case PKG_DELTA_ENERGY:\n            /* Read only so do nothing */\n            break;\n        case PKG_POWER_LIMIT_1:\n            timewin_union.ll = _local_get_eventval_from_values( control, values, pp, PKG_TIME_WINDOW_POWER_LIMIT_1, -1 );\n            if ( timewin_union.ll > 0 ) {\n                limit1.watts = event_value_union.dbl;\n                limit1.seconds = timewin_union.dbl;\n                limit1.bits = 0;\n                //printf(\"set_libmsr_limit package %d limit1 %lf %lf\\n\", pp, limit1.watts, limit1.seconds);\n                libmsr_set_pkg_rapl_limit( pp, &limit1, NULL  );\n            } else {\n                // Note error - power limit1 is not updated\n                SUBDBG(\"PACKAGE_POWER_LIMIT_1 needs PKG_TIME_WINDOW_POWER_LIMIT_1: Power cap not updated. \");\n            }\n            break;\n        case PKG_POWER_LIMIT_2:\n            timewin_union.ll = _local_get_eventval_from_values( control, values, pp, PKG_TIME_WINDOW_POWER_LIMIT_2, -1 );\n            if ( timewin_union.ll > 0 ) {\n                limit2.watts = event_value_union.dbl;\n                limit2.seconds = timewin_union.dbl;\n                limit2.bits = 0;\n                //printf(\"set_libmsr_limit package %d limit2 %lf %lf \\n\", pp, limit2.watts, limit2.seconds);\n                libmsr_set_pkg_rapl_limit( pp, NULL, &limit2 );\n            } else {\n                // Write error\n                PAPIERROR(\"PACKAGE_POWER_LIMIT_1 needs PKG_TIME_WINDOW_POWER_LIMIT_1: Powercap not updated.\");\n            }\n            break;\n        case PKG_TIME_WINDOW_POWER_LIMIT_1:\n        case PKG_TIME_WINDOW_POWER_LIMIT_2:\n            /* These are only meaningful (and looked up) if the power limits are set */\n            break;\n        default:\n            SUBDBG(\"This LIBMSR information type is unknown\\n\");\n            /* error here */\n        }\n    }\n    return PAPI_OK;\n}\n\n\nint _libmsr_stop( hwd_context_t * ctx, hwd_control_state_t * ctl )\n{\n    SUBDBG( \"Enter: ctl: %p, ctx: %p\\n\", ctl, ctx );\n    ( void ) ctx;\n    ( void ) ctl;\n    _local_set_to_defaults();\n    return PAPI_OK;\n}\n\n\n/* Shutdown a thread */\nint _libmsr_shutdown_thread( hwd_context_t * ctx )\n{\n    SUBDBG( \"Enter: ctl: %p\\n\", ctx );\n    ( void ) ctx;\n    return PAPI_OK;\n}\n\n\n/*\n * Clean up what was setup in  libmsr_init_component().\n */\nint _libmsr_shutdown_component( void )\n{\n    SUBDBG( \"Enter\\n\" );\n\n    _local_set_to_defaults();\n\n    if ( libmsr_finalize_msr()!=0 ) {\n        strncpy( _libmsr_vector.cmp_info.disabled_reason, \"Function libmsr.so:finalize_msr failed. \", PAPI_MAX_STR_LEN );\n        return PAPI_ESYS;\n    }\n    if( libmsr_native_events ) {\n        free( libmsr_native_events );\n        libmsr_native_events = NULL;\n    }\n    dlclose( dllib1 );\n    return PAPI_OK;\n}\n\n\n/* This function sets various options in the component The valid codes\n * being passed in are PAPI_SET_DEFDOM, PAPI_SET_DOMAIN,\n * PAPI_SETDEFGRN, PAPI_SET_GRANUL * and PAPI_SET_INHERIT */\nint _libmsr_ctl( hwd_context_t * ctx, int code, _papi_int_option_t * option )\n{\n    SUBDBG( \"Enter: ctx: %p\\n\", ctx );\n    ( void ) ctx;\n    ( void ) code;\n    ( void ) option;\n\n    return PAPI_OK;\n}\n\n\n/*\n * This function has to set the bits needed to count different domains\n * In particular: PAPI_DOM_USER, PAPI_DOM_KERNEL PAPI_DOM_OTHER\n * By default return PAPI_EINVAL if none of those are specified\n * and PAPI_OK with success\n * PAPI_DOM_USER is only user context is counted\n * PAPI_DOM_KERNEL is only the Kernel/OS context is counted\n * PAPI_DOM_OTHER  is Exception/transient mode (like user TLB misses)\n * PAPI_DOM_ALL   is all of the domains\n */\nint _libmsr_set_domain( hwd_control_state_t * ctl, int domain )\n{\n    SUBDBG( \"Enter: ctl: %p\\n\", ctl );\n    ( void ) ctl;\n    /* In theory we only support system-wide mode */\n    /* How to best handle that? */\n    if( domain != PAPI_DOM_ALL )\n        return PAPI_EINVAL;\n    return PAPI_OK;\n}\n\n\nint _libmsr_reset( hwd_context_t * ctx, hwd_control_state_t * ctl )\n{\n    SUBDBG( \"Enter: ctl: %p, ctx: %p\\n\", ctl, ctx );\n    ( void ) ctx;\n    ( void ) ctl;\n\n    return PAPI_OK;\n}\n\n\n/*\n * Native Event functions\n */\nint _libmsr_ntv_enum_events( unsigned int *EventCode, int modifier )\n{\n    SUBDBG( \"Enter: EventCode: %d\\n\", *EventCode );\n    int index;\n    if ( num_events_global == 0 )\n        return PAPI_ENOEVNT;\n\n    switch ( modifier ) {\n    case PAPI_ENUM_FIRST:\n        *EventCode = 0;\n        return PAPI_OK;\n        break;\n    case PAPI_ENUM_EVENTS:\n        index = *EventCode & PAPI_NATIVE_AND_MASK;\n        if ( index < num_events_global - 1 ) {\n            *EventCode = *EventCode + 1;\n            return PAPI_OK;\n        } else {\n            return PAPI_ENOEVNT;\n        }\n        break;\n        // case PAPI_NTV_ENUM_UMASKS:\n    default:\n        return PAPI_EINVAL;\n    }\n\n    return PAPI_EINVAL;\n}\n\n\n/*\n *\n */\nint _libmsr_ntv_code_to_name( unsigned int EventCode, char *name, int len )\n{\n    SUBDBG( \"Enter: EventCode: %d\\n\", EventCode );\n    int index = EventCode & PAPI_NATIVE_AND_MASK;\n\n    if( index >= 0 && index < num_events_global ) {\n        _local_strlcpy( name, libmsr_native_events[index].name, len );\n        return PAPI_OK;\n    }\n    return PAPI_ENOEVNT;\n}\n\n\nint _libmsr_ntv_code_to_descr( unsigned int EventCode, char *name, int len )\n{\n    SUBDBG( \"Enter: EventCode: %d\\n\", EventCode );\n    int index = EventCode;\n\n    if( ( index < 0 ) || ( index >= num_events_global ) )\n        return PAPI_ENOEVNT;\n\n    _local_strlcpy( name, libmsr_native_events[index].description, len );\n    return PAPI_OK;\n}\n\n\nint _libmsr_ntv_code_to_info( unsigned int EventCode, PAPI_event_info_t * info )\n{\n    SUBDBG( \"Enter: EventCode: %d\\n\", EventCode );\n    int index = EventCode;\n\n    if( ( index < 0 ) || ( index >= num_events_global ) )\n        return PAPI_ENOEVNT;\n\n    _local_strlcpy( info->symbol, libmsr_native_events[index].name, sizeof( info->symbol ) );\n    _local_strlcpy( info->long_descr, libmsr_native_events[index].description, sizeof( info->long_descr ) );\n    _local_strlcpy( info->units, libmsr_native_events[index].units, sizeof( info->units ) );\n    info->data_type = libmsr_native_events[index].return_type;\n    return PAPI_OK;\n}\n\n\npapi_vector_t _libmsr_vector = {\n    .cmp_info = {               /* (unspecified values are initialized to 0) */\n        .name = \"libmsr\",\n        .short_name = \"libmsr\",\n        .description = \"PAPI component for libmsr from LANL for power (RAPL) read/write\",\n        .version = \"5.3.0\",\n        .default_domain = PAPI_DOM_ALL,\n        .default_granularity = PAPI_GRN_SYS,\n        .available_granularities = PAPI_GRN_SYS,\n        .hardware_intr_sig = PAPI_INT_SIGNAL,\n        .available_domains = PAPI_DOM_ALL,\n    },\n    /* sizes of framework-opaque component-private structures */\n    .size = {\n        .context = sizeof( _libmsr_context_t ),\n        .control_state = sizeof( _libmsr_control_state_t ),\n        .reg_value = sizeof( _libmsr_register_t ),\n        .reg_alloc = sizeof( _libmsr_reg_alloc_t ),\n    },\n    /* function pointers in this component */\n    .start = _libmsr_start,\n    .stop = _libmsr_stop,\n    .read = _libmsr_read,\n    .reset = _libmsr_reset,\n    .write = _libmsr_write,\n    .init_component = _libmsr_init_component,\n    .init_thread = _libmsr_init_thread,\n    .init_control_state = _libmsr_init_control_state,\n    .update_control_state = _libmsr_update_control_state,\n    .ctl = _libmsr_ctl,\n    .set_domain = _libmsr_set_domain,\n    .ntv_enum_events = _libmsr_ntv_enum_events,\n    .ntv_code_to_name = _libmsr_ntv_code_to_name,\n    .ntv_code_to_descr = _libmsr_ntv_code_to_descr,\n    .ntv_code_to_info = _libmsr_ntv_code_to_info,\n    .shutdown_thread = _libmsr_shutdown_thread,\n    .shutdown_component = _libmsr_shutdown_component,\n};\n",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.6.0-iweh6uy7qfzcgjj77nhy45ucjhpm2ow6/spack-src/src/components/host_micpower/linux-host_micpower.c": "/** linux-host_micpower.c\n *\t@author James Ralph\n *\tralph@icl.utk.edu\n *\n *\t@ingroup papi_components\n *\n *\t@brief\n *\t\tThis component wraps the MicAccessAPI to provide hostside \n *\t\tpower information for attached Intel Xeon Phi (MIC) cards.\n*/ \n\n/* From intel examples, see $(mic_dir)/sysmgt/sdk/Examples/Usage */\n#define MAX_DEVICES (32)\n#define EVENTS_PER_DEVICE 10\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <dlfcn.h> \n\n#include \"MicAccessTypes.h\"\n#include \"MicBasicTypes.h\"\n#include \"MicAccessErrorTypes.h\"\n#include \"MicAccessApi.h\"\n#include \"MicPowerManagerAPI.h\"\n\n#include \"papi.h\"\n#include \"papi_internal.h\"\n#include \"papi_vector.h\"\n#include \"papi_memory.h\"\n\nvoid (*_dl_non_dynamic_init)(void) __attribute__((weak));\n\n/* This is a guess, refine this later */\n#define UPDATEFREQ 500000\n\npapi_vector_t _host_micpower_vector;\n\ntypedef struct host_micpower_register {\n\t/** Corresponds to counter slot, indexed from 1, 0 has a special meaning */\n\tunsigned int selector;\n} host_micpower_register_t;\n\ntypedef struct host_micpower_reg_alloc {\n\thost_micpower_register_t ra_bits;\n} host_micpower_reg_alloc_t;\n\n/** Internal structure used to build the table of events */\ntypedef struct host_micpower_native_event_entry {\n\thost_micpower_register_t resources; \n\tchar name[PAPI_MAX_STR_LEN];\n\tchar description[PAPI_MAX_STR_LEN];\n\tchar units[3];\n} host_micpower_native_event_entry_t;\n\n/** Per-eventset structure used to hold control flags. */\ntypedef struct host_micpower_control_state {\n\tint num_events;\n\tint resident[MAX_DEVICES*EVENTS_PER_DEVICE];\n\tlong long counts[MAX_DEVICES*EVENTS_PER_DEVICE];\n\tlong long lastupdate[MAX_DEVICES];\n} host_micpower_control_state_t;\n\n/** Per-thread data */\ntypedef struct host_micpower_context {\n\thost_micpower_control_state_t state;\n} host_micpower_context_t; \n\n/* Global state info */\nstatic MicDeviceOnSystem adapters[MAX_DEVICES];\nstatic HANDLE handles[MAX_DEVICES];\nstatic long long lastupdate[MAX_DEVICES];\nstatic HANDLE accessHandle = NULL;\nstatic U32 nAdapters = MAX_DEVICES;\n\nstatic void* mic_access \t= \tNULL;\nstatic void* scif_access\t=\tNULL;\n\n#undef MICACCESS_API\n#define MICACCESS_API __attribute__((weak))\nconst char *MicGetErrorString(U32);\nU32 MICACCESS_API MicCloseAdapter(HANDLE);\nU32 MICACCESS_API MicInitAPI(HANDLE *, ETarget, MicDeviceOnSystem *, U32 *);\nU32 MICACCESS_API MicCloseAPI(HANDLE *);\nU32 MICACCESS_API MicInitAdapter(HANDLE *, MicDeviceOnSystem *);\nU32 MICACCESS_API MicGetPowerUsage(HANDLE, MicPwrUsage *);\n\nconst char *(*MicGetErrorStringPtr)(U32);\nU32 (*MicCloseAdapterPtr)(HANDLE);\nU32 (*MicInitAPIPtr)(HANDLE *, ETarget, MicDeviceOnSystem *, U32 *);\nU32 (*MicCloseAPIPtr)(HANDLE *);\nU32 (*MicInitAdapterPtr)(HANDLE *, MicDeviceOnSystem *);\nU32 (*MicGetPowerUsagePtr)(HANDLE, MicPwrUsage *);\nstatic host_micpower_native_event_entry_t *native_events_table = NULL;\n\nstruct powers {\n\t\tint total0;\n\t\tint total1;\n\t\tint\tinst;\n\t\tint imax;\n\t\tint pcie;\n\t\tint c2x3;\n\t\tint c2x4;\n\t\tint vccp;\n\t\tint vddg;\n\t\tint vddq;\n};\n\ntypedef union {\n\t\tstruct powers power;\n\t\tint array[EVENTS_PER_DEVICE]; \n} power_t;\n\nstatic power_t cached_values[MAX_DEVICES];\n\nstatic int \nloadFunctionPtrs()\n{\n\t/* Attempt to guess if we were statically linked to libc, if so bail */\n\tif ( _dl_non_dynamic_init != NULL ) {\n\t\tstrncpy(_host_micpower_vector.cmp_info.disabled_reason, \"The host_micpower component does not support statically linking of libc.\", PAPI_MAX_STR_LEN);\n\t\treturn PAPI_ENOSUPP;\n\t}\n\n\t  /* Need to link in the cuda libraries, if not found disable the component */\n\tscif_access = dlopen(\"libscif.so\", RTLD_NOW | RTLD_GLOBAL);\n    if (NULL == scif_access)\n    {\n        snprintf(_host_micpower_vector.cmp_info.disabled_reason, PAPI_MAX_STR_LEN, \"Problem loading the SCIF library: %s\\n\", dlerror());\n\t\t\t_host_micpower_vector.cmp_info.disabled = 1;\n        return ( PAPI_ENOSUPP );\n    }\n\n    mic_access = dlopen(\"libMicAccessSDK.so\", RTLD_NOW | RTLD_GLOBAL);\n    if (NULL == mic_access)\n    {\n        snprintf(_host_micpower_vector.cmp_info.disabled_reason, PAPI_MAX_STR_LEN, \"Problem loading libMicAccessSDK.so: %s\\n\", dlerror());\n\t\t\t_host_micpower_vector.cmp_info.disabled = 1;\n        return ( PAPI_ENOSUPP );\n    }\n\n\tMicGetErrorStringPtr = dlsym(mic_access, \"MicGetErrorString\");\n\tif (dlerror() != NULL)\n\t{\n\t\t\tstrncpy(_host_micpower_vector.cmp_info.disabled_reason, \"MicAccessSDK function MicGetErrorString not found.\",PAPI_MAX_STR_LEN);\n\t\t\t_host_micpower_vector.cmp_info.disabled = 1;\n\t\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tMicCloseAdapterPtr = dlsym(mic_access, \"MicCloseAdapter\");\n\tif (dlerror() != NULL)\n\t{\n\t\t\tstrncpy(_host_micpower_vector.cmp_info.disabled_reason, \"MicAccessSDK function MicCloseAdapter not found.\",PAPI_MAX_STR_LEN);\n\t\t\t_host_micpower_vector.cmp_info.disabled = 1;\n\t\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tMicInitAPIPtr = dlsym(mic_access, \"MicInitAPI\");\n\tif (dlerror() != NULL)\n\t{\n\t\t\tstrncpy(_host_micpower_vector.cmp_info.disabled_reason, \"MicAccessSDK function MicInitAPI not found.\",PAPI_MAX_STR_LEN);\n\t\t\t_host_micpower_vector.cmp_info.disabled = 1;\n\t\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tMicCloseAPIPtr = dlsym(mic_access, \"MicCloseAPI\");\n\tif (dlerror() != NULL)\n\t{\n\t\t\tstrncpy(_host_micpower_vector.cmp_info.disabled_reason, \"MicAccessSDK function MicCloseAPI not found.\",PAPI_MAX_STR_LEN);\n\t\t\t_host_micpower_vector.cmp_info.disabled = 1;\n\t\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tMicInitAdapterPtr = dlsym(mic_access, \"MicInitAdapter\");\n\tif (dlerror() != NULL)\n\t{\n\t\t\tstrncpy(_host_micpower_vector.cmp_info.disabled_reason, \"MicAccessSDK function MicInitAdapter not found.\",PAPI_MAX_STR_LEN);\n\t\t\t_host_micpower_vector.cmp_info.disabled = 1;\n\t\t\treturn ( PAPI_ENOSUPP );\n\t}\n\n\tMicGetPowerUsagePtr = dlsym(mic_access, \"MicGetPowerUsage\");\n\tif (dlerror() != NULL)\n\t{\n\t\t\tstrncpy(_host_micpower_vector.cmp_info.disabled_reason, \"MicAccessSDK function MicGetPowerUsage not found.\",PAPI_MAX_STR_LEN);\n\t\t\t_host_micpower_vector.cmp_info.disabled = 1;\n\t\t\treturn ( PAPI_ENOSUPP );\n\t}\n\n\treturn 0;\n}\n\n\n/* ###############################################\n * \t\t\tComponent Interface code \n * ############################################### */\n\n\nint \n_host_micpower_init_component( int cidx ) \n{\n\tU32 ret = MIC_ACCESS_API_ERROR_UNKNOWN;\n\tU32 adapterNum = 0;\n\tU32 throwaway = 1;\n\n\t_host_micpower_vector.cmp_info.CmpIdx = cidx;\n\n\tif ( loadFunctionPtrs() ) {\n\t\tgoto disable_me;\n\t}\n\n\tmemset( lastupdate, 0x0, sizeof(lastupdate));\n\tmemset( cached_values, 0x0, sizeof(struct powers)*MAX_DEVICES );\n\tret = MicInitAPIPtr( &accessHandle, eTARGET_SCIF_DRIVER, adapters, &nAdapters );\n\tif ( MIC_ACCESS_API_SUCCESS != ret ) {\n\t\tsnprintf( _host_micpower_vector.cmp_info.disabled_reason, PAPI_MAX_STR_LEN, \"Failed to init: %s\", MicGetErrorStringPtr(ret));\n\t\tMicCloseAPIPtr(&accessHandle);\n\t\tgoto disable_me;\n\t}\n\t/* Sanity check on array size */\n\tif ( nAdapters >= MAX_DEVICES ) {\n\t\tsnprintf(_host_micpower_vector.cmp_info.disabled_reason, PAPI_MAX_STR_LEN, \"Too many MIC cards [%d] found, bailing.\", nAdapters);\n\t\tMicCloseAPIPtr(&accessHandle);\n\t\tgoto disable_me;\n\t}\n\n/* XXX: This code initializes a token for each adapter, in testing this appeared to be required/\n *\tOne has to call MicInitAdapter() before calling into that adapter's entries */\n\tfor (adapterNum=0; adapterNum < nAdapters; adapterNum++) {\n\t\t\tret = MicInitAPIPtr( &handles[adapterNum], eTARGET_SCIF_DRIVER, adapters, &throwaway );\n\t\t\tthrowaway = 1;\n\t\t\tif (MIC_ACCESS_API_SUCCESS != ret) {\n\t\t\t\t\tfprintf(stderr, \"%d:MicInitAPI carps: %s\\n\", __LINE__, MicGetErrorStringPtr(ret));\n\t\t\t\t\tnAdapters = adapterNum;\n\t\t\t\t\tfor (adapterNum=0; adapterNum < nAdapters; adapterNum++)\n\t\t\t\t\t\t\tMicCloseAdapterPtr( handles[adapterNum] );\n\t\t\t\t\tMicCloseAPIPtr( &accessHandle );\n\t\t\t\t\tsnprintf(_host_micpower_vector.cmp_info.disabled_reason, PAPI_MAX_STR_LEN,\n\t\t\t\t\t\t\"Failed to initialize card %d's interface.\", nAdapters);\n\t\t\t\t\tgoto disable_me;\n\t\t\t}\n\t\t\tret = MicInitAdapterPtr(&handles[adapterNum], &adapters[adapterNum]);\n\t\t\tif (MIC_ACCESS_API_SUCCESS != ret) {\n\t\t\t\t\tfprintf(stderr, \"%d:MicInitAdapter carps: %s\\n\", __LINE__, MicGetErrorStringPtr(ret));\n\t\t\t\t\tnAdapters = adapterNum;\n\t\t\t\t\tfor (adapterNum=0; adapterNum < nAdapters; adapterNum++)\n\t\t\t\t\t\t\tMicCloseAdapterPtr( handles[adapterNum] );\n\t\t\t\t\tMicCloseAPIPtr( &accessHandle );\n\t\t\t\t\tsnprintf(_host_micpower_vector.cmp_info.disabled_reason, PAPI_MAX_STR_LEN,\n\t\t\t\t\t\t\"Failed to initialize card %d's interface.\", nAdapters);\n\t\t\t\t\tgoto disable_me;\n\t\t\t}\n\t}\n\n\tnative_events_table = ( host_micpower_native_event_entry_t*)papi_malloc( nAdapters * EVENTS_PER_DEVICE * sizeof(host_micpower_native_event_entry_t));\n\tif ( NULL == native_events_table ) {\n\t\treturn PAPI_ENOMEM;\n\t}\n\tfor (adapterNum=0; adapterNum < nAdapters; adapterNum++) {\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE].name, PAPI_MAX_STR_LEN, \"mic%d:tot0\", adapterNum);\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE].description, PAPI_MAX_STR_LEN, \"Total power utilization, Averaged over Time Window 0 (uWatts)\");\n\t\tnative_events_table[adapterNum*EVENTS_PER_DEVICE].resources.selector = adapterNum*EVENTS_PER_DEVICE + 1;\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE].units, PAPI_MIN_STR_LEN, \"uW\");\n\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 1].name, PAPI_MAX_STR_LEN, \"mic%d:tot1\", adapterNum);\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 1].description, PAPI_MAX_STR_LEN, \"Total power utilization, Averaged over Time Window 1 (uWatts)\");\n\t\tnative_events_table[adapterNum*EVENTS_PER_DEVICE + 1].resources.selector = adapterNum*EVENTS_PER_DEVICE + 2;\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 1].units, PAPI_MIN_STR_LEN, \"uW\");\n\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 2].name, PAPI_MAX_STR_LEN, \"mic%d:pcie\", adapterNum);\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 2].description, PAPI_MAX_STR_LEN, \"PCI-E connector power (uWatts)\");\n\t\tnative_events_table[adapterNum*EVENTS_PER_DEVICE + 2].resources.selector = adapterNum*EVENTS_PER_DEVICE + 3;\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 2].units, PAPI_MIN_STR_LEN, \"uW\");\n\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 3].name, PAPI_MAX_STR_LEN, \"mic%d:inst\", adapterNum);\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 3].description, PAPI_MAX_STR_LEN, \"Instantaneous power (uWatts)\");\n\t\tnative_events_table[adapterNum*EVENTS_PER_DEVICE + 3].resources.selector = adapterNum*EVENTS_PER_DEVICE + 4;\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 3].units, PAPI_MIN_STR_LEN, \"uW\");\n\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 4].name, PAPI_MAX_STR_LEN, \"mic%d:imax\", adapterNum);\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 4].description, PAPI_MAX_STR_LEN, \"Max instantaneous power (uWatts)\");\n\t\tnative_events_table[adapterNum*EVENTS_PER_DEVICE + 4].resources.selector = adapterNum*EVENTS_PER_DEVICE + 5;\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 4].units, PAPI_MIN_STR_LEN, \"uW\");\n\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 5].name, PAPI_MAX_STR_LEN, \"mic%d:c2x3\", adapterNum);\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 5].description, PAPI_MAX_STR_LEN, \"2x3 connector power (uWatts)\");\n\t\tnative_events_table[adapterNum*EVENTS_PER_DEVICE + 5].resources.selector = adapterNum*EVENTS_PER_DEVICE + 6;\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 5].units, PAPI_MIN_STR_LEN, \"uW\");\n\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 6].name, PAPI_MAX_STR_LEN, \"mic%d:c2x4\", adapterNum);\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 6].description, PAPI_MAX_STR_LEN, \"2x4 connector power (uWatts)\");\n\t\tnative_events_table[adapterNum*EVENTS_PER_DEVICE + 6].resources.selector = adapterNum*EVENTS_PER_DEVICE + 7;\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 6].units, PAPI_MIN_STR_LEN, \"uW\");\n\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 7].name, PAPI_MAX_STR_LEN, \"mic%d:vccp\", adapterNum);\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 7].description, PAPI_MAX_STR_LEN, \"Core rail (uVolts)\");\n\t\tnative_events_table[adapterNum*EVENTS_PER_DEVICE + 7].resources.selector = adapterNum*EVENTS_PER_DEVICE + 8;\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 7].units, PAPI_MIN_STR_LEN, \"uV\");\n\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 8].name, PAPI_MAX_STR_LEN, \"mic%d:vddg\", adapterNum);\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 8].description, PAPI_MAX_STR_LEN, \"Uncore rail (uVolts)\");\n\t\tnative_events_table[adapterNum*EVENTS_PER_DEVICE + 8].resources.selector = adapterNum*EVENTS_PER_DEVICE + 9;\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 8].units, PAPI_MIN_STR_LEN, \"uV\");\n\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 9].name, PAPI_MAX_STR_LEN, \"mic%d:vddq\", adapterNum);\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 9].description, PAPI_MAX_STR_LEN, \"Memory subsystem rail (uVolts)\");\n\t\tnative_events_table[adapterNum*EVENTS_PER_DEVICE + 9].resources.selector = adapterNum*EVENTS_PER_DEVICE + 10;\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 9].units, PAPI_MIN_STR_LEN, \"uV\");\n\t}\n\n\t_host_micpower_vector.cmp_info.num_cntrs = EVENTS_PER_DEVICE*nAdapters;\n\t_host_micpower_vector.cmp_info.num_mpx_cntrs = EVENTS_PER_DEVICE*nAdapters;\n\n\t_host_micpower_vector.cmp_info.num_native_events = EVENTS_PER_DEVICE*nAdapters;\n\n\treturn PAPI_OK;\n\ndisable_me:\n\t_host_micpower_vector.cmp_info.num_cntrs = 0;\n\t_host_micpower_vector.cmp_info.num_mpx_cntrs = 0;\n\t_host_micpower_vector.cmp_info.num_native_events = 0;\n\t_host_micpower_vector.cmp_info.disabled = 1;\n\n\tnAdapters = 0;\n\treturn PAPI_ENOSUPP;\n}\n\nint _host_micpower_init_thread( hwd_context_t *ctx) {\n\t(void)ctx;\n\treturn PAPI_OK;\n}\n\nint\n_host_micpower_shutdown_component( void ) {\n\tU32 i = 0;\n\tfor( i=0; i<nAdapters; i++) {\n\t\tMicCloseAdapterPtr( handles[i] );\n\t}\n\n\tpapi_free(native_events_table);\n\treturn PAPI_OK;\n}\n\t\nint\n_host_micpower_shutdown_thread( hwd_context_t *ctx ) {\n    (void) ctx;\n\treturn PAPI_OK;\n}\n\nint _host_micpower_init_control_state ( hwd_control_state_t *ctl ) {\n\thost_micpower_control_state_t *state = (host_micpower_control_state_t*) ctl;\n\tmemset( state, 0, sizeof(host_micpower_control_state_t));\n\n\treturn PAPI_OK;\n}\n\nint _host_micpower_update_control_state(hwd_control_state_t *ctl, \n\t\t\t\t\t\t\t\t\t\tNativeInfo_t *info, \n\t\t\t\t\t\t\t\t\t\tint count,\n\t\t\t\t\t\t\t\t\t\thwd_context_t* ctx ) {\n\n\t(void) ctx;\n\tint i, index;\n\t\n\thost_micpower_control_state_t *state = (host_micpower_control_state_t*)ctl;\n\n\tfor (i=0; i<MAX_DEVICES*EVENTS_PER_DEVICE; i++)\n\t\tstate->resident[i] = 0;\n\n\tfor (i=0; i < count; i++) {\n\t\tindex = info[i].ni_event&PAPI_NATIVE_AND_MASK;\n\t\tinfo[i].ni_position=native_events_table[index].resources.selector-1;\n\t\tstate->resident[index] = 1;\n\t}\n\tstate->num_events = count;\n\n\treturn PAPI_OK;\n}\n\nint\n_host_micpower_start( hwd_context_t *ctx, hwd_control_state_t *ctl )\n{\n\t(void) ctx;\n\t(void) ctl;\n\treturn PAPI_OK;\n}\n\nstatic int \nread_power( struct powers *pwr, int which_one ) \n{\n\tMicPwrUsage power;\n\tU32 ret = MIC_ACCESS_API_ERROR_UNKNOWN;\n\n\tif ( which_one < 0 || which_one > (int)nAdapters )\n\t\treturn PAPI_ENOEVNT;\n\t\n\n\tret = MicGetPowerUsagePtr(handles[which_one], &power);\n\tif (MIC_ACCESS_API_SUCCESS != ret) {\n\t\t\tfprintf(stderr,\"Oops MicGetPowerUsage failed: %s\\n\", \n\t\t\t\t\t\t\tMicGetErrorStringPtr(ret));\n\t\t\treturn PAPI_ECMP;\n\t}\n\n\tpwr->total0 = power.total0.prr;\n\tpwr->total1 = power.total1.prr;\n\tpwr->inst = power.inst.prr;\n\tpwr->imax = power.imax.prr;\n\tpwr->pcie = power.pcie.prr;\n\tpwr->c2x3 = power.c2x3.prr;\n\tpwr->c2x4 = power.c2x4.prr;\n\tpwr->vccp = power.vccp.pwr;\n\tpwr->vddg = power.vddg.pwr;\n\tpwr->vddq = power.vddq.pwr;\n\n\treturn PAPI_OK;\n}\n\nint\n_host_micpower_read( hwd_context_t *ctx, hwd_control_state_t *ctl, \n\t\t\t\t\t long long **events, int flags) \n{\n\t(void)flags;\n\t(void)events;\n\t(void)ctx;\n\tunsigned int i,j;\n\tint needs_update = 0;\n\thost_micpower_control_state_t* control = (host_micpower_control_state_t*)ctl;\n\tlong long now = PAPI_get_real_usec();\n\n\tfor( i=0; i<nAdapters; i++) {\n\t\t\tneeds_update = 0;\n\t\t\tfor (j=0; j<EVENTS_PER_DEVICE; j++) {\n\t\t\t\tif ( control->resident[EVENTS_PER_DEVICE*i+j]) {\n\t\t\t\t\t\tneeds_update = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( needs_update ) {\n\t\t\t\t\t/* Do the global update */\n\t\t\t\t\tif ( now >= lastupdate[i] + UPDATEFREQ) {\n\t\t\t\t\t\t\tread_power( &cached_values[i].power, i );\n\t\t\t\t\t\t\tlastupdate[i] = now;\n\t\t\t\t\t}\n\t\t\t\t\t/* update from cached values */\n\t\t\t\t\tif ( control->lastupdate[i] < lastupdate[i]) {\n\t\t\t\t\t\t\tcontrol->lastupdate[i] = lastupdate[i];\n\t\t\t\t\t}\n\t\t\t\t\tfor (j=0; j<EVENTS_PER_DEVICE; j++) {\n\t\t\t\t\t\tif ( control->resident[EVENTS_PER_DEVICE*i+j] ) {\n\t\t\t\t\t\t\tcontrol->counts[EVENTS_PER_DEVICE*i+j] = (long long)cached_values[i].array[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\t}\n\n\t*events = control->counts;\n\treturn PAPI_OK;\n}\n\nint\n_host_micpower_stop( hwd_context_t *ctx, hwd_control_state_t *ctl )\n{\n\t(void)ctx;\n\tint needs_update = 0;\n\tunsigned int i,j;\n\thost_micpower_control_state_t* control = (host_micpower_control_state_t*)ctl;\n\tlong long now = PAPI_get_real_usec();\n\n\tfor( i=0; i<nAdapters; i++) {\n\t\t\tneeds_update = 0;\n\t\t\tfor (j=0; j<EVENTS_PER_DEVICE; j++) {\n\t\t\t\tif ( control->resident[EVENTS_PER_DEVICE*i+j]) {\n\t\t\t\t\t\tneeds_update = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( needs_update ) {\n\t\t\t\t\t/* Do the global update */\n\t\t\t\t\tif ( now >= lastupdate[i] + UPDATEFREQ) {\n\t\t\t\t\t\t\tread_power( &cached_values[i].power, i );\n\t\t\t\t\t\t\tlastupdate[i] = now;\n\t\t\t\t\t}\n\t\t\t\t\t/* update from cached values */\n\t\t\t\t\tif ( control->lastupdate[i] < lastupdate[i]) {\n\t\t\t\t\t\t\tcontrol->lastupdate[i] = lastupdate[i];\n\t\t\t\t\t}\n\t\t\t\t\tfor (j=0; j<EVENTS_PER_DEVICE; j++) {\n\t\t\t\t\t\tif ( control->resident[EVENTS_PER_DEVICE*i+j] ) {\n\t\t\t\t\t\t\tcontrol->counts[EVENTS_PER_DEVICE*i+j] = (long long)cached_values[i].array[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\t}\n\treturn PAPI_OK;\n\n}\n\nint _host_micpower_ntv_enum_events( unsigned int *EventCode, int modifier )\n{\n\tint index;\n\tswitch (modifier) {\n\t\tcase PAPI_ENUM_FIRST:\n\t\t\tif (0 == _host_micpower_vector.cmp_info.num_cntrs)\n\t\t\t\treturn PAPI_ENOEVNT;\n\t\t\t*EventCode = 0;\n\t\t\treturn PAPI_OK;\n\t\tcase PAPI_ENUM_EVENTS:\n\t\t\tindex = *EventCode;\n\t\t\tif ( index < _host_micpower_vector.cmp_info.num_cntrs - 1) {\n\t\t\t\t*EventCode = *EventCode + 1;\n\t\t\t\treturn PAPI_OK;\n\t\t\t} else {\n\t\t\t\treturn PAPI_ENOEVNT;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn PAPI_EINVAL;\n\t}\n\treturn PAPI_EINVAL;\n}\n\nint\n_host_micpower_ntv_code_to_name( unsigned int EventCode, char *name, int len )\n{\n\tunsigned int code = EventCode & PAPI_NATIVE_AND_MASK;\n\tif ( code < _host_micpower_vector.cmp_info.num_cntrs ) {\n\t\tstrncpy( name, native_events_table[code].name, len);\n\t\treturn PAPI_OK;\n\t}\n\n\treturn PAPI_ENOEVNT;\n}\n\nint\n_host_micpower_ntv_code_to_descr( unsigned int EventCode, char *name, int len )\n{\n\tunsigned int code = EventCode & PAPI_NATIVE_AND_MASK;\n\tif ( code < _host_micpower_vector.cmp_info.num_cntrs ) {\n\t\tstrncpy( name, native_events_table[code].description, len );\n\t\treturn PAPI_OK;\n\t}\n\n\treturn PAPI_ENOEVNT;\n}\n\nint\n_host_micpower_ntv_code_to_info( unsigned int EventCode, PAPI_event_info_t *info)\n{\n\tunsigned int code = EventCode & PAPI_NATIVE_AND_MASK;\n\tif ( code >= _host_micpower_vector.cmp_info.num_cntrs)\n\t\treturn PAPI_ENOEVNT;\n\tstrncpy( info->symbol, native_events_table[code].name, sizeof(info->symbol) );\n\tstrncpy( info->long_descr, native_events_table[code].description, sizeof(info->long_descr) );\n\tstrncpy( info->units, native_events_table[code].units, sizeof(info->units) );\n\treturn PAPI_OK;\n}\n\nint\n_host_micpower_ctl( hwd_context_t* ctx, int code, _papi_int_option_t *option)\n{\n\t(void)ctx;\n\t(void)code;\n\t(void)option;\n\treturn PAPI_OK;\n}\n\nint\n_host_micpower_set_domain( hwd_control_state_t* ctl, int domain)\n{\n\t(void)ctl;\n\tif ( PAPI_DOM_ALL != domain )\n\t    return PAPI_EINVAL;\n\treturn PAPI_OK;\n}\n\npapi_vector_t _host_micpower_vector = {\n\t.cmp_info = {\n\t\t.name = \"host_micpower\", \n\t\t.short_name = \"host_micpower\", \n\t\t.description = \"A host-side component to read power usage on MIC guest cards.\",\n\t\t.version = \"0.1\",\n\t\t.support_version = \"n/a\",\n\t\t.kernel_version = \"n/a\",\n\t\t.num_cntrs = 0,\n\t\t.num_mpx_cntrs = 0,\n\t\t.default_domain \t\t\t= PAPI_DOM_ALL,\n\t\t.available_domains \t\t\t= PAPI_DOM_ALL,\n\t\t.default_granularity \t\t= PAPI_GRN_SYS,\n\t\t.available_granularities \t= PAPI_GRN_SYS,\n\t\t.hardware_intr_sig \t\t\t= PAPI_INT_SIGNAL,\n\t}, \n\n\t.size  = {\n\t\t.context \t\t= sizeof(host_micpower_context_t), \n\t\t.control_state\t= sizeof(host_micpower_control_state_t),\n\t\t.reg_value\t\t= sizeof(host_micpower_register_t),\n\t\t.reg_alloc\t\t= sizeof(host_micpower_reg_alloc_t),\n\t},\n\n\t.start\t\t\t\t\t= _host_micpower_start,\n\t.stop\t\t\t\t\t= _host_micpower_start,\n\t.read\t\t\t\t\t= _host_micpower_read, \n\t.reset\t\t\t\t\t= NULL,\n\t.write\t\t\t\t\t= NULL,\n\t.init_component\t\t\t= _host_micpower_init_component,\n\t.init_thread\t\t\t= _host_micpower_init_thread,\n\t.init_control_state\t\t= _host_micpower_init_control_state,\n\t.update_control_state\t= _host_micpower_update_control_state,\n\t.ctl\t\t\t\t\t= _host_micpower_ctl, \n\t.shutdown_thread\t\t= _host_micpower_shutdown_thread,\n\t.shutdown_component\t\t= _host_micpower_shutdown_component,\n\t.set_domain\t\t\t\t= _host_micpower_set_domain,\n\n\t.ntv_enum_events\t\t= _host_micpower_ntv_enum_events, \n\t.ntv_code_to_name\t\t= _host_micpower_ntv_code_to_name,\n\t.ntv_code_to_descr\t\t= _host_micpower_ntv_code_to_descr,\n\t.ntv_code_to_info\t\t= _host_micpower_ntv_code_to_info,\n\n};\n",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.6.0-iweh6uy7qfzcgjj77nhy45ucjhpm2ow6/spack-src/src/components/cuda/linux-cuda.c": "/**\n * @file    linux-cuda.c\n * @author  Asim YarKhan yarkhan@icl.utk.edu (updated in 2017 to support CUDA metrics)\n * @author  Asim YarKhan yarkhan@icl.utk.edu (updated in 2015 for multiple CUDA contexts/devices)\n * @author  Heike Jagode (First version, in collaboration with Robert Dietrich, TU Dresden) jagode@icl.utk.edu\n *\n * @ingroup papi_components\n *\n * @brief This implements a PAPI component that enables PAPI-C to\n *  access hardware monitoring counters for NVIDIA CUDA GPU devices\n *  through the CUPTI library.\n *\n * The open source software license for PAPI conforms to the BSD\n * License template.\n */\n\n#include <dlfcn.h>\n#include <cupti.h>\n#include <cuda_runtime_api.h>\n\n#include \"papi.h\"\n#include \"papi_memory.h\"\n#include \"papi_internal.h\"\n#include \"papi_vector.h\"\n\n/* this number assumes that there will never be more events than indicated */\n#define PAPICUDA_MAX_COUNTERS 512\n\n// #define PAPICUDA_KERNEL_REPLAY_MODE\n\n/* Contains device list, pointer to device desciption, and the list of available events */\ntypedef struct papicuda_context {\n    int deviceCount;\n    struct papicuda_device_desc *deviceArray;\n    uint32_t availEventSize;\n    CUpti_ActivityKind *availEventKind;\n    int *availEventDeviceNum;\n    uint32_t *availEventIDArray;\n    uint32_t *availEventIsBeingMeasuredInEventset;\n    struct papicuda_name_desc *availEventDesc;\n} papicuda_context_t;\n\n/* Store the name and description for an event */\ntypedef struct papicuda_name_desc {\n    char name[PAPI_MAX_STR_LEN];\n    char description[PAPI_2MAX_STR_LEN];\n} papicuda_name_desc_t;\n\n/* For a device, store device description */\ntypedef struct papicuda_device_desc {\n    CUdevice cuDev;\n    int deviceNum;\n    char deviceName[PAPI_MIN_STR_LEN];\n    uint32_t maxDomains;        /* number of domains per device */\n    CUpti_EventDomainID *domainIDArray; /* Array[maxDomains] of domain IDs */\n    uint32_t *domainIDNumEvents;        /* Array[maxDomains] of num of events in that domain */\n} papicuda_device_desc_t;\n\n/* Control structure tracks array of active contexts, records active events and their values */\ntypedef struct papicuda_control {\n    uint32_t countOfActiveCUContexts;\n    struct papicuda_active_cucontext_s *arrayOfActiveCUContexts[PAPICUDA_MAX_COUNTERS];\n    uint32_t activeEventCount;\n    int activeEventIndex[PAPICUDA_MAX_COUNTERS];\n    long long activeEventValues[PAPICUDA_MAX_COUNTERS];\n    uint64_t cuptiStartTimestampNs;\n    uint64_t cuptiReadTimestampNs;\n} papicuda_control_t;\n\n/* For each active context, which CUDA events are being measured, context eventgroups containing events */\ntypedef struct papicuda_active_cucontext_s {\n    CUcontext cuCtx;\n    int deviceNum;\n    uint32_t conMetricsCount;\n    CUpti_EventID conMetrics[PAPICUDA_MAX_COUNTERS];\n    CUpti_MetricValue conMetricValues[PAPICUDA_MAX_COUNTERS];\n    uint32_t conEventsCount;\n    CUpti_EventID conEvents[PAPICUDA_MAX_COUNTERS];\n    uint64_t conEventValues[PAPICUDA_MAX_COUNTERS];\n    CUpti_EventGroupSets *eventGroupPasses;\n} papicuda_active_cucontext_t;\n\n// file handles used to access cuda libraries with dlopen\nstatic void *dl1 = NULL;\nstatic void *dl2 = NULL;\nstatic void *dl3 = NULL;\n\n/* The PAPI side (external) variable as a global */\npapi_vector_t _cuda_vector;\n\n/* Global variable for hardware description, event and metric lists */\nstatic papicuda_context_t *global_papicuda_context = NULL;\n\n/* This global variable points to the head of the control state list */\nstatic papicuda_control_t *global_papicuda_control = NULL;\n\n/* Macros for error checking... each arg is only referenced/evaluated once */\n#define CHECK_PRINT_EVAL( checkcond, str, evalthis )                    \\\n    do {                                                                \\\n        int _cond = (checkcond);                                        \\\n        if (_cond) {                                                    \\\n            SUBDBG(\"error: condition %s failed: %s.\\n\", #checkcond, str); \\\n            evalthis;                                                   \\\n        }                                                               \\\n    } while (0)\n\n#define CUDA_CALL( call, handleerror )                                \\\n    do {                                                                \\\n        cudaError_t _status = (call);                                   \\\n        if (_status != cudaSuccess) {                                   \\\n            SUBDBG(\"error: function %s failed with error %d.\\n\", #call, _status); \\\n            handleerror;                                                \\\n        }                                                               \\\n    } while (0)\n\n#define CU_CALL( call, handleerror )                                    \\\n    do {                                                                \\\n        CUresult _status = (call);                                      \\\n        if (_status != CUDA_SUCCESS) {                                  \\\n            SUBDBG(\"error: function %s failed with error %d.\\n\", #call, _status); \\\n            handleerror;                                                \\\n        }                                                               \\\n    } while (0)\n\n\n#define CUPTI_CALL(call, handleerror)                                 \\\n    do {                                                                \\\n        CUptiResult _status = (call);                                   \\\n        if (_status != CUPTI_SUCCESS) {                                 \\\n            const char *errstr;                                         \\\n            (*cuptiGetResultStringPtr)(_status, &errstr);               \\\n            SUBDBG(\"error: function %s failed with error %s.\\n\", #call, errstr); \\\n            handleerror;                                                \\\n        }                                                               \\\n    } while (0)\n\n#define BUF_SIZE (32 * 1024)\n#define ALIGN_SIZE (8)\n#define ALIGN_BUFFER(buffer, align)                                     \\\n  (((uintptr_t) (buffer) & ((align)-1)) ? ((buffer) + (align) - ((uintptr_t) (buffer) & ((align)-1))) : (buffer))\n\n/* Function prototypes */\nstatic int papicuda_cleanup_eventset(hwd_control_state_t * ctrl);\n\n/* ******  CHANGE PROTOTYPES TO DECLARE CUDA LIBRARY SYMBOLS AS WEAK  **********\n *  This is done so that a version of PAPI built with the cuda component can   *\n *  be installed on a system which does not have the cuda libraries installed. *\n *                                                                             *\n *  If this is done without these prototypes, then all papi services on the    *\n *  system without the cuda libraries installed will fail.  The PAPI libraries *\n *  contain references to the cuda libraries which are not installed.  The     *\n *  load of PAPI commands fails because the cuda library references can not be *\n *  resolved.                                                                  *\n *                                                                             *\n *  This also defines pointers to the cuda library functions that we call.     *\n *  These function pointers will be resolved with dlopen/dlsym calls at        *\n *  component initialization time.  The component then calls the cuda library  *\n *  functions through these function pointers.                                 *\n *******************************************************************************/\nvoid (*_dl_non_dynamic_init) (void) __attribute__ ((weak));\n\n#define CUAPIWEAK __attribute__( ( weak ) )\n#define DECLARECUFUNC(funcname, funcsig) CUresult CUAPIWEAK funcname funcsig;  CUresult( *funcname##Ptr ) funcsig;\nDECLARECUFUNC(cuCtxGetCurrent, (CUcontext *));\nDECLARECUFUNC(cuCtxSetCurrent, (CUcontext));\nDECLARECUFUNC(cuDeviceGet, (CUdevice *, int));\nDECLARECUFUNC(cuDeviceGetCount, (int *));\nDECLARECUFUNC(cuDeviceGetName, (char *, int, CUdevice));\nDECLARECUFUNC(cuInit, (unsigned int));\nDECLARECUFUNC(cuCtxPopCurrent, (CUcontext * pctx));\nDECLARECUFUNC(cuCtxPushCurrent, (CUcontext pctx));\nDECLARECUFUNC(cuCtxSynchronize, ());\n\n#define CUDAAPIWEAK __attribute__( ( weak ) )\n#define DECLARECUDAFUNC(funcname, funcsig) cudaError_t CUDAAPIWEAK funcname funcsig;  cudaError_t( *funcname##Ptr ) funcsig;\nDECLARECUDAFUNC(cudaGetDevice, (int *));\nDECLARECUDAFUNC(cudaSetDevice, (int));\nDECLARECUDAFUNC(cudaFree, (void *));\n\n#define CUPTIAPIWEAK __attribute__( ( weak ) )\n#define DECLARECUPTIFUNC(funcname, funcsig) CUptiResult CUPTIAPIWEAK funcname funcsig;  CUptiResult( *funcname##Ptr ) funcsig;\n/* CUptiResult CUPTIAPIWEAK cuptiDeviceEnumEventDomains( CUdevice, size_t *, CUpti_EventDomainID * ); */\n/* CUptiResult( *cuptiDeviceEnumEventDomainsPtr )( CUdevice, size_t *, CUpti_EventDomainID * ); */\nDECLARECUPTIFUNC(cuptiDeviceEnumMetrics, (CUdevice device, size_t * arraySizeBytes, CUpti_MetricID * metricArray));\nDECLARECUPTIFUNC(cuptiDeviceGetEventDomainAttribute, (CUdevice device, CUpti_EventDomainID eventDomain, CUpti_EventDomainAttribute attrib, size_t * valueSize, void *value));\nDECLARECUPTIFUNC(cuptiDeviceGetNumMetrics, (CUdevice device, uint32_t * numMetrics));\nDECLARECUPTIFUNC(cuptiEventGroupGetAttribute, (CUpti_EventGroup eventGroup, CUpti_EventGroupAttribute attrib, size_t * valueSize, void *value));\nDECLARECUPTIFUNC(cuptiEventGroupReadEvent, (CUpti_EventGroup eventGroup, CUpti_ReadEventFlags flags, CUpti_EventID event, size_t * eventValueBufferSizeBytes, uint64_t * eventValueBuffer));\nDECLARECUPTIFUNC(cuptiEventGroupSetAttribute, (CUpti_EventGroup eventGroup, CUpti_EventGroupAttribute attrib, size_t valueSize, void *value));\nDECLARECUPTIFUNC(cuptiEventGroupSetDisable, (CUpti_EventGroupSet * eventGroupSet));\nDECLARECUPTIFUNC(cuptiEventGroupSetEnable, (CUpti_EventGroupSet * eventGroupSet));\nDECLARECUPTIFUNC(cuptiEventGroupSetsCreate, (CUcontext context, size_t eventIdArraySizeBytes, CUpti_EventID * eventIdArray, CUpti_EventGroupSets ** eventGroupPasses));\nDECLARECUPTIFUNC(cuptiEventGroupSetsDestroy, (CUpti_EventGroupSets * eventGroupSets));\nDECLARECUPTIFUNC(cuptiGetTimestamp, (uint64_t * timestamp));\nDECLARECUPTIFUNC(cuptiMetricEnumEvents, (CUpti_MetricID metric, size_t * eventIdArraySizeBytes, CUpti_EventID * eventIdArray));\nDECLARECUPTIFUNC(cuptiMetricGetAttribute, (CUpti_MetricID metric, CUpti_MetricAttribute attrib, size_t * valueSize, void *value));\nDECLARECUPTIFUNC(cuptiMetricGetNumEvents, (CUpti_MetricID metric, uint32_t * numEvents));\nDECLARECUPTIFUNC(cuptiMetricGetValue, (CUdevice device, CUpti_MetricID metric, size_t eventIdArraySizeBytes, CUpti_EventID * eventIdArray, size_t eventValueArraySizeBytes, uint64_t * eventValueArray, uint64_t timeDuration, CUpti_MetricValue * metricValue));\nDECLARECUPTIFUNC(cuptiSetEventCollectionMode, (CUcontext context, CUpti_EventCollectionMode mode));\nDECLARECUPTIFUNC(cuptiDeviceEnumEventDomains, (CUdevice, size_t *, CUpti_EventDomainID *));\nDECLARECUPTIFUNC(cuptiDeviceGetNumEventDomains, (CUdevice, uint32_t *));\nDECLARECUPTIFUNC(cuptiEventDomainEnumEvents, (CUpti_EventDomainID, size_t *, CUpti_EventID *));\nDECLARECUPTIFUNC(cuptiEventDomainGetAttribute, (CUpti_EventDomainID eventDomain, CUpti_EventDomainAttribute attrib, size_t * valueSize, void *value));\nDECLARECUPTIFUNC(cuptiEventDomainGetNumEvents, (CUpti_EventDomainID, uint32_t *));\nDECLARECUPTIFUNC(cuptiEventGetAttribute, (CUpti_EventID, CUpti_EventAttribute, size_t *, void *));\nDECLARECUPTIFUNC(cuptiEventGroupAddEvent, (CUpti_EventGroup, CUpti_EventID));\nDECLARECUPTIFUNC(cuptiEventGroupCreate, (CUcontext, CUpti_EventGroup *, uint32_t));\nDECLARECUPTIFUNC(cuptiEventGroupDestroy, (CUpti_EventGroup));\nDECLARECUPTIFUNC(cuptiEventGroupDisable, (CUpti_EventGroup));\nDECLARECUPTIFUNC(cuptiEventGroupEnable, (CUpti_EventGroup));\nDECLARECUPTIFUNC(cuptiEventGroupReadAllEvents, (CUpti_EventGroup, CUpti_ReadEventFlags, size_t *, uint64_t *, size_t *, CUpti_EventID *, size_t *));\nDECLARECUPTIFUNC(cuptiEventGroupResetAllEvents, (CUpti_EventGroup));\nDECLARECUPTIFUNC(cuptiGetResultString, (CUptiResult result, const char **str));\nDECLARECUPTIFUNC(cuptiEnableKernelReplayMode, ( CUcontext context ));\nDECLARECUPTIFUNC(cuptiDisableKernelReplayMode, ( CUcontext context ));\n\n\n/*****************************************************************************\n ********  BEGIN FUNCTIONS USED INTERNALLY SPECIFIC TO THIS COMPONENT *********\n *****************************************************************************/\n\n/* \n * Link the necessary CUDA libraries to use the cuda component.  If any of them can not be found, then\n * the CUDA component will just be disabled.  This is done at runtime so that a version of PAPI built\n * with the CUDA component can be installed and used on systems which have the CUDA libraries installed\n * and on systems where these libraries are not installed.\n */\nstatic int papicuda_linkCudaLibraries()\n{\n#define DLSYM_AND_CHECK( dllib, name ) dlsym( dllib, name ); if ( dlerror()!=NULL ) { strncpy( _cuda_vector.cmp_info.disabled_reason, \"A CUDA required function was not found in dynamic libs\", PAPI_MAX_STR_LEN ); return ( PAPI_ENOSUPP ); }\n\n    /* Attempt to guess if we were statically linked to libc, if so bail */\n    if(_dl_non_dynamic_init != NULL) {\n        strncpy(_cuda_vector.cmp_info.disabled_reason, \"The CUDA component does not support statically linking to libc.\", PAPI_MAX_STR_LEN);\n        return PAPI_ENOSUPP;\n    }\n    /* Need to link in the cuda libraries, if not found disable the component */\n    dl1 = dlopen(\"libcuda.so\", RTLD_NOW | RTLD_GLOBAL);\n    CHECK_PRINT_EVAL(!dl1, \"CUDA library libcuda.so not found.\", return (PAPI_ENOSUPP));\n    cuCtxGetCurrentPtr = DLSYM_AND_CHECK(dl1, \"cuCtxGetCurrent\");\n    cuCtxSetCurrentPtr = DLSYM_AND_CHECK(dl1, \"cuCtxSetCurrent\");\n    cuDeviceGetPtr = DLSYM_AND_CHECK(dl1, \"cuDeviceGet\");\n    cuDeviceGetCountPtr = DLSYM_AND_CHECK(dl1, \"cuDeviceGetCount\");\n    cuDeviceGetNamePtr = DLSYM_AND_CHECK(dl1, \"cuDeviceGetName\");\n    cuInitPtr = DLSYM_AND_CHECK(dl1, \"cuInit\");\n    cuCtxPopCurrentPtr = DLSYM_AND_CHECK(dl1, \"cuCtxPopCurrent\");\n    cuCtxPushCurrentPtr = DLSYM_AND_CHECK(dl1, \"cuCtxPushCurrent\");\n    cuCtxSynchronizePtr = DLSYM_AND_CHECK(dl1, \"cuCtxSynchronize\");\n\n    dl2 = dlopen(\"libcudart.so\", RTLD_NOW | RTLD_GLOBAL | RTLD_NODELETE);\n    CHECK_PRINT_EVAL(!dl2, \"CUDA runtime library libcudart.so not found.\", return (PAPI_ENOSUPP));\n    cudaGetDevicePtr = DLSYM_AND_CHECK(dl2, \"cudaGetDevice\");\n    cudaSetDevicePtr = DLSYM_AND_CHECK(dl2, \"cudaSetDevice\");\n    cudaFreePtr = DLSYM_AND_CHECK(dl2, \"cudaFree\");\n\n    dl3 = dlopen(\"libcupti.so\", RTLD_NOW | RTLD_GLOBAL);\n    CHECK_PRINT_EVAL(!dl3, \"CUDA runtime library libcudart.so not found.\", return (PAPI_ENOSUPP));\n    /* The macro DLSYM_AND_CHECK results in the expansion example below */\n    /* cuptiDeviceEnumEventDomainsPtr = dlsym( dl3, \"cuptiDeviceEnumEventDomains\" ); */\n    /* if ( dlerror()!=NULL ) { strncpy( _cuda_vector.cmp_info.disabled_reason, \"A CUDA required function was not found in dynamic libs\", PAPI_MAX_STR_LEN ); return ( PAPI_ENOSUPP ); } */\n    cuptiDeviceEnumMetricsPtr = DLSYM_AND_CHECK(dl3, \"cuptiDeviceEnumMetrics\");\n    cuptiDeviceGetEventDomainAttributePtr = DLSYM_AND_CHECK(dl3, \"cuptiDeviceGetEventDomainAttribute\");\n    cuptiDeviceGetNumMetricsPtr = DLSYM_AND_CHECK(dl3, \"cuptiDeviceGetNumMetrics\");\n    cuptiEventGroupGetAttributePtr = DLSYM_AND_CHECK(dl3, \"cuptiEventGroupGetAttribute\");\n    cuptiEventGroupReadEventPtr = DLSYM_AND_CHECK(dl3, \"cuptiEventGroupReadEvent\");\n    cuptiEventGroupSetAttributePtr = DLSYM_AND_CHECK(dl3, \"cuptiEventGroupSetAttribute\");\n    cuptiEventGroupSetDisablePtr = DLSYM_AND_CHECK(dl3, \"cuptiEventGroupSetDisable\");\n    cuptiEventGroupSetEnablePtr = DLSYM_AND_CHECK(dl3, \"cuptiEventGroupSetEnable\");\n    cuptiEventGroupSetsCreatePtr = DLSYM_AND_CHECK(dl3, \"cuptiEventGroupSetsCreate\");\n    cuptiEventGroupSetsDestroyPtr = DLSYM_AND_CHECK(dl3, \"cuptiEventGroupSetsDestroy\");\n    cuptiGetTimestampPtr = DLSYM_AND_CHECK(dl3, \"cuptiGetTimestamp\");\n    cuptiMetricEnumEventsPtr = DLSYM_AND_CHECK(dl3, \"cuptiMetricEnumEvents\");\n    cuptiMetricGetAttributePtr = DLSYM_AND_CHECK(dl3, \"cuptiMetricGetAttribute\");\n    cuptiMetricGetNumEventsPtr = DLSYM_AND_CHECK(dl3, \"cuptiMetricGetNumEvents\");\n    cuptiMetricGetValuePtr = DLSYM_AND_CHECK(dl3, \"cuptiMetricGetValue\");\n    cuptiSetEventCollectionModePtr = DLSYM_AND_CHECK(dl3, \"cuptiSetEventCollectionMode\");\n    cuptiDeviceEnumEventDomainsPtr = DLSYM_AND_CHECK(dl3, \"cuptiDeviceEnumEventDomains\");\n    cuptiDeviceGetNumEventDomainsPtr = DLSYM_AND_CHECK(dl3, \"cuptiDeviceGetNumEventDomains\");\n    cuptiEventDomainEnumEventsPtr = DLSYM_AND_CHECK(dl3, \"cuptiEventDomainEnumEvents\");\n    cuptiEventDomainGetAttributePtr = DLSYM_AND_CHECK(dl3, \"cuptiEventDomainGetAttribute\");\n    cuptiEventDomainGetNumEventsPtr = DLSYM_AND_CHECK(dl3, \"cuptiEventDomainGetNumEvents\");\n    cuptiEventGetAttributePtr = DLSYM_AND_CHECK(dl3, \"cuptiEventGetAttribute\");\n    cuptiEventGroupAddEventPtr = DLSYM_AND_CHECK(dl3, \"cuptiEventGroupAddEvent\");\n    cuptiEventGroupCreatePtr = DLSYM_AND_CHECK(dl3, \"cuptiEventGroupCreate\");\n    cuptiEventGroupDestroyPtr = DLSYM_AND_CHECK(dl3, \"cuptiEventGroupDestroy\");\n    cuptiEventGroupDisablePtr = DLSYM_AND_CHECK(dl3, \"cuptiEventGroupDisable\");\n    cuptiEventGroupEnablePtr = DLSYM_AND_CHECK(dl3, \"cuptiEventGroupEnable\");\n    cuptiEventGroupReadAllEventsPtr = DLSYM_AND_CHECK(dl3, \"cuptiEventGroupReadAllEvents\");\n    cuptiEventGroupResetAllEventsPtr = DLSYM_AND_CHECK(dl3, \"cuptiEventGroupResetAllEvents\");\n    cuptiGetResultStringPtr = DLSYM_AND_CHECK(dl3, \"cuptiGetResultString\");\n    cuptiEnableKernelReplayModePtr = DLSYM_AND_CHECK(dl3, \"cuptiEnableKernelReplayMode\");\n    cuptiDisableKernelReplayModePtr = DLSYM_AND_CHECK(dl3, \"cuptiEnableKernelReplayMode\");\n    return (PAPI_OK);\n}\n\n\nstatic int papicuda_add_native_events(papicuda_context_t * gctxt)\n{\n    SUBDBG(\"Entering\\n\");\n    CUresult cuErr;\n    int deviceNum;\n    uint32_t domainNum, eventNum;\n    papicuda_device_desc_t *mydevice;\n    char tmpStr[PAPI_MIN_STR_LEN];\n    tmpStr[PAPI_MIN_STR_LEN - 1] = '\\0';\n    size_t tmpSizeBytes;\n    int ii;\n    uint32_t maxEventSize;\n\n    /* How many CUDA devices do we have? */\n    cuErr = (*cuDeviceGetCountPtr) (&gctxt->deviceCount);\n    if(cuErr == CUDA_ERROR_NOT_INITIALIZED) {\n        /* If CUDA not initilaized, initialized CUDA and retry the device list */\n        /* This is required for some of the PAPI tools, that do not call the init functions */\n        if(((*cuInitPtr) (0)) != CUDA_SUCCESS) {\n            strncpy(_cuda_vector.cmp_info.disabled_reason, \"CUDA cannot be found and initialized (cuInit failed).\", PAPI_MAX_STR_LEN);\n            return PAPI_ENOSUPP;\n        }\n        CU_CALL((*cuDeviceGetCountPtr) (&gctxt->deviceCount), return (PAPI_EMISC));\n    }\n\n    if(gctxt->deviceCount == 0) {\n        strncpy(_cuda_vector.cmp_info.disabled_reason, \"CUDA initialized but no CUDA devices found.\", PAPI_MAX_STR_LEN);\n        return PAPI_ENOSUPP;\n    }\n    SUBDBG(\"Found %d devices\\n\", gctxt->deviceCount);\n\n    /* allocate memory for device information */\n    gctxt->deviceArray = (papicuda_device_desc_t *) papi_calloc(gctxt->deviceCount, sizeof(papicuda_device_desc_t));\n    CHECK_PRINT_EVAL(!gctxt->deviceArray, \"ERROR CUDA: Could not allocate memory for CUDA device structure\", return (PAPI_ENOMEM));\n\n    /* For each device, get domains and domain-events counts */\n    maxEventSize = 0;\n    for(deviceNum = 0; deviceNum < gctxt->deviceCount; deviceNum++) {\n        mydevice = &gctxt->deviceArray[deviceNum];\n        /* Get device id, name, numeventdomains for each device */\n        CU_CALL((*cuDeviceGetPtr) (&mydevice->cuDev, deviceNum), return (PAPI_EMISC));\n        CU_CALL((*cuDeviceGetNamePtr) (mydevice->deviceName, PAPI_MIN_STR_LEN - 1, mydevice->cuDev), return (PAPI_EMISC));\n        mydevice->deviceName[PAPI_MIN_STR_LEN - 1] = '\\0';\n        CUPTI_CALL((*cuptiDeviceGetNumEventDomainsPtr) (mydevice->cuDev, &mydevice->maxDomains), return (PAPI_EMISC));\n        /* Allocate space to hold domain IDs */\n        mydevice->domainIDArray = (CUpti_EventDomainID *) papi_calloc(mydevice->maxDomains, sizeof(CUpti_EventDomainID));\n        CHECK_PRINT_EVAL(!mydevice->domainIDArray, \"ERROR CUDA: Could not allocate memory for CUDA device domains\", return (PAPI_ENOMEM));\n        /* Put domain ids into allocated space */\n        size_t domainarraysize = mydevice->maxDomains * sizeof(CUpti_EventDomainID);\n        CUPTI_CALL((*cuptiDeviceEnumEventDomainsPtr) (mydevice->cuDev, &domainarraysize, mydevice->domainIDArray), return (PAPI_EMISC));\n        /* Allocate space to hold domain event counts */\n        mydevice->domainIDNumEvents = (uint32_t *) papi_calloc(mydevice->maxDomains, sizeof(uint32_t));\n        CHECK_PRINT_EVAL(!mydevice->domainIDNumEvents, \"ERROR CUDA: Could not allocate memory for domain event counts\", return (PAPI_ENOMEM));\n        /* For each domain, get event counts in domainNumEvents[] */\n        for(domainNum = 0; domainNum < mydevice->maxDomains; domainNum++) {\n            CUpti_EventDomainID domainID = mydevice->domainIDArray[domainNum];\n            /* Get num events in domain */\n            // SUBDBG( \"Device %d:%d calling cuptiEventDomainGetNumEventsPtr with domainID %d \\n\", deviceNum, mydevice->cuDev, domainID );\n            CUPTI_CALL((*cuptiEventDomainGetNumEventsPtr) (domainID, &mydevice->domainIDNumEvents[domainNum]), return (PAPI_EMISC));\n            /* Keep track of overall number of events */\n            maxEventSize += mydevice->domainIDNumEvents[domainNum];\n        }\n    }\n\n    /* Create space for metrics */\n    for(deviceNum = 0; deviceNum < gctxt->deviceCount; deviceNum++) {\n        uint32_t maxMetrics;\n        mydevice = &gctxt->deviceArray[deviceNum];\n        // CUPTI_CALL((*cuptiDeviceGetNumMetricsPtr) (mydevice->cuDev, &maxMetrics), return (PAPI_EMISC));\n        if ( (*cuptiDeviceGetNumMetricsPtr) (mydevice->cuDev, &maxMetrics) != CUPTI_SUCCESS )\n            maxMetrics = 0;\n        maxEventSize += maxMetrics;\n    }\n\n    /* Allocate space for all events and descriptors */\n    gctxt->availEventKind = (CUpti_ActivityKind *) papi_calloc(maxEventSize, sizeof(CUpti_ActivityKind));\n    CHECK_PRINT_EVAL(!gctxt->availEventKind, \"ERROR CUDA: Could not allocate memory\", return (PAPI_ENOMEM));\n    gctxt->availEventDeviceNum = (int *) papi_calloc(maxEventSize, sizeof(int));\n    CHECK_PRINT_EVAL(!gctxt->availEventDeviceNum, \"ERROR CUDA: Could not allocate memory\", return (PAPI_ENOMEM));\n    gctxt->availEventIDArray = (CUpti_EventID *) papi_calloc(maxEventSize, sizeof(CUpti_EventID));\n    CHECK_PRINT_EVAL(!gctxt->availEventIDArray, \"ERROR CUDA: Could not allocate memory\", return (PAPI_ENOMEM));\n    gctxt->availEventIsBeingMeasuredInEventset = (uint32_t *) papi_calloc(maxEventSize, sizeof(uint32_t));\n    CHECK_PRINT_EVAL(!gctxt->availEventIsBeingMeasuredInEventset, \"ERROR CUDA: Could not allocate memory\", return (PAPI_ENOMEM));\n    gctxt->availEventDesc = (papicuda_name_desc_t *) papi_calloc(maxEventSize, sizeof(papicuda_name_desc_t));\n    CHECK_PRINT_EVAL(!gctxt->availEventDesc, \"ERROR CUDA: Could not allocate memory\", return (PAPI_ENOMEM));\n\n    /* Record the events and descriptions */\n    uint32_t idxEventArray = 0;\n    for(deviceNum = 0; deviceNum < gctxt->deviceCount; deviceNum++) {\n        mydevice = &gctxt->deviceArray[deviceNum];\n        // SUBDBG( \"For device %d %d maxdomains %d \\n\", deviceNum, mydevice->cuDev, mydevice->maxDomains );\n        /* Get and store event IDs, names, descriptions into the large arrays allocated */\n        for(domainNum = 0; domainNum < mydevice->maxDomains; domainNum++) {\n            /* Get domain id */\n            CUpti_EventDomainID domainID = mydevice->domainIDArray[domainNum];\n            uint32_t domainNumEvents = mydevice->domainIDNumEvents[domainNum];\n            // SUBDBG( \"For device %d domain %d domainID %d numEvents %d\\n\", mydevice->cuDev, domainNum, domainID, domainNumEvents );\n            /* Allocate temp space for eventIDs for this domain */\n            CUpti_EventID *domainEventIDArray = (CUpti_EventID *) papi_calloc(domainNumEvents, sizeof(CUpti_EventID));\n            CHECK_PRINT_EVAL(!domainEventIDArray, \"ERROR CUDA: Could not allocate memory for events\", return (PAPI_ENOMEM));\n            /* Load the domain eventIDs in temp space */\n            size_t domainEventArraySize = domainNumEvents * sizeof(CUpti_EventID);\n            CUPTI_CALL((*cuptiEventDomainEnumEventsPtr) (domainID, &domainEventArraySize, domainEventIDArray), return (PAPI_EMISC));\n            /* For each event, get and store name and description */\n            for(eventNum = 0; eventNum < domainNumEvents; eventNum++) {\n                /* Record the event IDs in native event array */\n                CUpti_EventID myeventCuptiEventId = domainEventIDArray[eventNum];\n                gctxt->availEventKind[idxEventArray] = CUPTI_ACTIVITY_KIND_EVENT;\n                gctxt->availEventIDArray[idxEventArray] = myeventCuptiEventId;\n                gctxt->availEventDeviceNum[idxEventArray] = deviceNum;\n                /* Get event name */\n                tmpSizeBytes = PAPI_MIN_STR_LEN - 1 * sizeof(char);\n                CUPTI_CALL((*cuptiEventGetAttributePtr) (myeventCuptiEventId, CUPTI_EVENT_ATTR_NAME, &tmpSizeBytes, tmpStr), return (PAPI_EMISC));\n                /* Save a full path for the event, filling spaces with underscores */\n                // snprintf( gctxt->availEventDesc[idxEventArray].name, PAPI_MIN_STR_LEN, \"%s:%d:%s\", mydevice->deviceName, deviceNum, tmpStr );\n                snprintf(gctxt->availEventDesc[idxEventArray].name, PAPI_MIN_STR_LEN, \"event:%s:device=%d\", tmpStr, deviceNum);\n                gctxt->availEventDesc[idxEventArray].name[PAPI_MIN_STR_LEN - 1] = '\\0';\n                char *nameTmpPtr = gctxt->availEventDesc[idxEventArray].name;\n                for(ii = 0; ii < (int) strlen(nameTmpPtr); ii++)\n                    if(nameTmpPtr[ii] == ' ')\n                        nameTmpPtr[ii] = '_';\n                /* Save description in the native event array */\n                tmpSizeBytes = PAPI_2MAX_STR_LEN - 1 * sizeof(char);\n                CUPTI_CALL((*cuptiEventGetAttributePtr) (myeventCuptiEventId, CUPTI_EVENT_ATTR_SHORT_DESCRIPTION, &tmpSizeBytes, gctxt->availEventDesc[idxEventArray].description), return (PAPI_EMISC));\n                gctxt->availEventDesc[idxEventArray].description[PAPI_2MAX_STR_LEN - 1] = '\\0';\n                // SUBDBG( \"Event ID:%d Name:%s Desc:%s\\n\", gctxt->availEventIDArray[idxEventArray], gctxt->availEventDesc[idxEventArray].name, gctxt->availEventDesc[idxEventArray].description );\n                /* Increment index past events in this domain to start of next domain */\n                idxEventArray++;\n            }\n            papi_free(domainEventIDArray);\n        }\n    }\n\n    /* Retrieve and store metric information for each device */\n    SUBDBG(\"Checking for metrics\\n\");\n    for(deviceNum = 0; deviceNum < gctxt->deviceCount; deviceNum++) {\n        uint32_t maxMetrics, i;\n        CUpti_MetricID *metricIdList = NULL;\n        mydevice = &gctxt->deviceArray[deviceNum];\n        // CUPTI_CALL((*cuptiDeviceGetNumMetricsPtr) (mydevice->cuDev, &maxMetrics), return (PAPI_EMISC));\n        if ( (*cuptiDeviceGetNumMetricsPtr) (mydevice->cuDev, &maxMetrics) != CUPTI_SUCCESS ) {\n            maxMetrics = 0;\n            continue;\n        }\n        SUBDBG(\"Device %d: Checking each of the (maxMetrics) %d metrics\\n\", deviceNum, maxMetrics);\n        size_t size = maxMetrics * sizeof(CUpti_EventID);\n        metricIdList = (CUpti_MetricID *) papi_calloc(maxMetrics, sizeof(CUpti_EventID));\n        CHECK_PRINT_EVAL(metricIdList == NULL, \"Out of memory\", return (PAPI_ENOMEM));\n        CUPTI_CALL((*cuptiDeviceEnumMetricsPtr) (mydevice->cuDev, &size, metricIdList), return (PAPI_EMISC));\n        for(i = 0; i < maxMetrics; i++) {\n            gctxt->availEventIDArray[idxEventArray] = metricIdList[i];\n            gctxt->availEventKind[idxEventArray] = CUPTI_ACTIVITY_KIND_METRIC;\n            gctxt->availEventDeviceNum[idxEventArray] = deviceNum;\n            size = PAPI_MIN_STR_LEN;\n            CUPTI_CALL((*cuptiMetricGetAttributePtr) (metricIdList[i], CUPTI_METRIC_ATTR_NAME, &size, (uint8_t *) tmpStr), return (PAPI_EMISC));\n            // FIXME SOMEDAY: For this release the nvlink metrics are not functioning so skip them\n            if(strstr(tmpStr, \"nvlink\")!=NULL)  continue;\n            // FIXME SOMEDAY: For this release the nvlink metrics are not functioning so skip them\n            if(size >= PAPI_MIN_STR_LEN)\n                gctxt->availEventDesc[idxEventArray].name[PAPI_MIN_STR_LEN - 1] = '\\0';\n            snprintf(gctxt->availEventDesc[idxEventArray].name, PAPI_MIN_STR_LEN, \"metric:%s:device=%d\", tmpStr, deviceNum);\n            size = PAPI_2MAX_STR_LEN;\n            CUPTI_CALL((*cuptiMetricGetAttributePtr) (metricIdList[i], CUPTI_METRIC_ATTR_LONG_DESCRIPTION, &size, (uint8_t *) gctxt->availEventDesc[idxEventArray].description), return (PAPI_EMISC));\n            if(size >= PAPI_2MAX_STR_LEN)\n                gctxt->availEventDesc[idxEventArray].description[PAPI_2MAX_STR_LEN - 1] = '\\0';\n            // SUBDBG( \"For device %d availEvent[%d] %s\\n\", mydevice->cuDev, idxEventArray, gctxt->availEventDesc[idxEventArray].name);\n            idxEventArray++;\n        }\n        papi_free(metricIdList);\n    }\n    gctxt->availEventSize = idxEventArray;\n\n    /* return 0 if everything went OK */\n    return 0;\n}\n\n\n/*\n  This routine tries to convert all CUPTI values to long long values.\n  If the CUPTI value is an integer type, it is cast to long long.  If\n  the CUPTI value is a percent, it is multiplied by 100 to return the\n  integer percentage.  If the CUPTI value is a double, the value\n  is cast to long long... this can be a severe truncation.\n */\nstatic int papicuda_convert_metric_value_to_long_long(CUpti_MetricValue metricValue, CUpti_MetricValueKind valueKind, long long int *papiValue)\n{\n    union {\n        long long ll;\n        double fp;\n    } tmpValue;\n\n    SUBDBG(\"Try to convert the CUPTI metric value kind (index %d) to PAPI value (long long or double)\\n\", valueKind);\n    switch (valueKind) {\n    case CUPTI_METRIC_VALUE_KIND_DOUBLE:\n        SUBDBG(\"Metric double %f\\n\", metricValue.metricValueDouble);\n        tmpValue.ll = (long long)(metricValue.metricValueDouble);\n        //CHECK_PRINT_EVAL(tmpValue.fp - metricValue.metricValueDouble > 1e-6, \"Error converting metric\\n\", return (PAPI_EMISC));\n        break;\n    case CUPTI_METRIC_VALUE_KIND_UINT64:\n        SUBDBG(\"Metric uint64 = %llu\\n\", (unsigned long long) metricValue.metricValueUint64);\n        tmpValue.ll = (long long) (metricValue.metricValueUint64);\n        CHECK_PRINT_EVAL(tmpValue.ll - metricValue.metricValueUint64 > 1e-6, \"Error converting metric\\n\", return (PAPI_EMISC));\n        break;\n    case CUPTI_METRIC_VALUE_KIND_INT64:\n        SUBDBG(\"Metric int64 = %lld\\n\", (long long) metricValue.metricValueInt64);\n        tmpValue.ll = (long long) (metricValue.metricValueInt64);\n        CHECK_PRINT_EVAL(tmpValue.ll - metricValue.metricValueInt64 > 1e-6, \"Error converting metric\\n\", return (PAPI_EMISC));\n        break;\n    case CUPTI_METRIC_VALUE_KIND_PERCENT:\n        SUBDBG(\"Metric percent = %f%%\\n\", metricValue.metricValuePercent);\n        tmpValue.ll = (long long)(metricValue.metricValuePercent*100);\n        //CHECK_PRINT_EVAL(tmpValue.ll - metricValue.metricValuePercent > 1e-6, \"Error converting metric\\n\", return (PAPI_EMISC));\n        break;\n    case CUPTI_METRIC_VALUE_KIND_THROUGHPUT:\n        SUBDBG(\"Metric throughput %llu bytes/sec\\n\", (unsigned long long) metricValue.metricValueThroughput);\n        tmpValue.ll = (long long) (metricValue.metricValueThroughput);\n        CHECK_PRINT_EVAL(tmpValue.ll - metricValue.metricValueThroughput > 1e-6, \"Error converting metric\\n\", return (PAPI_EMISC));\n        break;\n    case CUPTI_METRIC_VALUE_KIND_UTILIZATION_LEVEL:\n        SUBDBG(\"Metric utilization level %u\\n\", (unsigned int) metricValue.metricValueUtilizationLevel);\n        tmpValue.ll = (long long) (metricValue.metricValueUtilizationLevel);\n        CHECK_PRINT_EVAL(tmpValue.ll - metricValue.metricValueUtilizationLevel > 1e-6, \"Error converting metric\\n\", return (PAPI_EMISC));\n        break;\n    default:\n        CHECK_PRINT_EVAL(1, \"ERROR: unsupported metric value kind\", return (PAPI_EINVAL));\n        exit(-1);\n    }\n    *papiValue = tmpValue.ll;\n    return (PAPI_OK);\n}\n\n\n/* ****************************************************************************\n *******************  BEGIN PAPI's COMPONENT REQUIRED FUNCTIONS  *************\n **************************************************************************** */\n\n/* \n * This is called whenever a thread is initialized.\n */\nstatic int papicuda_init_thread(hwd_context_t * ctx)\n{\n    (void) ctx;\n    SUBDBG(\"Entering\\n\");\n    return PAPI_OK;\n}\n\n\n/* Initialize hardware counters, setup the function vector table\n * and get hardware information, this routine is called when the\n * PAPI process is initialized (IE PAPI_library_init)\n */\n/* NOTE: only called by main thread (not by every thread) !!! Starting\n   in CUDA 4.0, multiple CPU threads can access the same CUDA\n   context. This is a much easier programming model then pre-4.0 as\n   threads - using the same context - can share memory, data,\n   etc. It's possible to create a different context for each\n   thread. That's why CUDA context creation is done in\n   CUDA_init_component() (called only by main thread) rather than\n   CUDA_init() or CUDA_init_control_state() (both called by each\n   thread). */\nstatic int papicuda_init_component(int cidx)\n{\n    SUBDBG(\"Entering with cidx: %d\\n\", cidx);\n    int rv;\n\n    /* link in all the cuda libraries and resolve the symbols we need to use */\n    if(papicuda_linkCudaLibraries() != PAPI_OK) {\n        SUBDBG(\"Dynamic link of CUDA libraries failed, component will be disabled.\\n\");\n        SUBDBG(\"See disable reason in papi_component_avail output for more details.\\n\");\n        return (PAPI_ENOSUPP);\n    }\n\n    /* Create the structure */\n    if(!global_papicuda_context)\n        global_papicuda_context = (papicuda_context_t *) papi_calloc(1, sizeof(papicuda_context_t));\n\n    /* Get list of all native CUDA events supported */\n    rv = papicuda_add_native_events(global_papicuda_context);\n    if(rv != 0)\n        return (rv);\n\n    /* Export some information */\n    _cuda_vector.cmp_info.CmpIdx = cidx;\n    _cuda_vector.cmp_info.num_native_events = global_papicuda_context->availEventSize;\n    _cuda_vector.cmp_info.num_cntrs = _cuda_vector.cmp_info.num_native_events;\n    _cuda_vector.cmp_info.num_mpx_cntrs = _cuda_vector.cmp_info.num_native_events;\n\n    return (PAPI_OK);\n}\n\n\n/* Setup a counter control state.\n *   In general a control state holds the hardware info for an\n *   EventSet.\n */\nstatic int papicuda_init_control_state(hwd_control_state_t * ctrl)\n{\n    SUBDBG(\"Entering\\n\");\n    (void) ctrl;\n    papicuda_context_t *gctxt = global_papicuda_context;\n\n    CHECK_PRINT_EVAL(!gctxt, \"Error: The PAPI CUDA component needs to be initialized first\", return (PAPI_ENOINIT));\n    /* If no events were found during the initial component initialization, return error */\n    if(global_papicuda_context->availEventSize <= 0) {\n        strncpy(_cuda_vector.cmp_info.disabled_reason, \"ERROR CUDA: No events exist\", PAPI_MAX_STR_LEN);\n        return (PAPI_EMISC);\n    }\n    /* If it does not exist, create the global structure to hold CUDA contexts and active events */\n    if(!global_papicuda_control) {\n        global_papicuda_control = (papicuda_control_t *) papi_calloc(1, sizeof(papicuda_control_t));\n        global_papicuda_control->countOfActiveCUContexts = 0;\n        global_papicuda_control->activeEventCount = 0;\n    }\n    return PAPI_OK;\n}\n\n/* Triggered by eventset operations like add or remove.  For CUDA,\n * needs to be called multiple times from each seperate CUDA context\n * with the events to be measured from that context.  For each\n * context, create eventgroups for the events.\n */\n/* Note: NativeInfo_t is defined in papi_internal.h */\nstatic int papicuda_update_control_state(hwd_control_state_t * ctrl, NativeInfo_t * nativeInfo, int nativeCount, hwd_context_t * ctx)\n{\n    SUBDBG(\"Entering with nativeCount %d\\n\", nativeCount);\n    (void) ctx;\n    // (void) ctrl;\n    papicuda_control_t *gctrl = global_papicuda_control;\n    papicuda_context_t *gctxt = global_papicuda_context;\n    int currDeviceNum;\n    CUcontext currCuCtx;\n    int eventContextIdx;\n    CUcontext eventCuCtx;\n    int index, ii;\n    uint32_t numEvents, ee, cc;\n\n    /* Return if no events */\n    if(nativeCount == 0)\n        return (PAPI_OK);\n\n    /* Get deviceNum, initialize context if needed via free, get context */\n    // CU_CALL( (*cuCtxGetCurrentPtr)(&currCuCtx), return(PAPI_EMISC));\n    CUDA_CALL((*cudaGetDevicePtr) (&currDeviceNum), return (PAPI_EMISC));\n    SUBDBG(\"currDeviceNum %d \\n\", currDeviceNum);\n    CUDA_CALL((*cudaFreePtr) (NULL), return (PAPI_EMISC));\n    CU_CALL((*cuCtxGetCurrentPtr) (&currCuCtx), return (PAPI_EMISC));\n    SUBDBG(\"currDeviceNum %d cuCtx %p \\n\", currDeviceNum, currCuCtx);\n\n    /* Handle user request of events to be monitored */\n    for(ii = 0; ii < nativeCount; ii++) {\n        /* Get the PAPI event index from the user */\n        index = nativeInfo[ii].ni_event;\n#ifdef DEBUG\n        char *eventName = gctxt->availEventDesc[index].name;\n#endif\n        int eventDeviceNum = gctxt->availEventDeviceNum[index];\n\n        /* if this event is already added continue to next ii, if not, mark it as being added */\n        if(gctxt->availEventIsBeingMeasuredInEventset[index] == 1) {\n            SUBDBG(\"Skipping event %s which is already added\\n\", eventName);\n            continue;\n        } else\n            gctxt->availEventIsBeingMeasuredInEventset[index] = 1;\n\n        /* Find context/control in papicuda, creating it if does not exist */\n        for(cc = 0; cc < gctrl->countOfActiveCUContexts; cc++) {\n            CHECK_PRINT_EVAL(cc >= PAPICUDA_MAX_COUNTERS, \"Exceeded hardcoded maximum number of contexts (PAPICUDA_MAX_COUNTERS)\", return (PAPI_EMISC));\n            if(gctrl->arrayOfActiveCUContexts[cc]->deviceNum == eventDeviceNum) {\n                eventCuCtx = gctrl->arrayOfActiveCUContexts[cc]->cuCtx;\n                SUBDBG(\"Event %s device %d already has a cuCtx %p registered\\n\", eventName, eventDeviceNum, eventCuCtx);\n                if(eventCuCtx != currCuCtx)\n                    CU_CALL((*cuCtxPushCurrentPtr) (eventCuCtx), return (PAPI_EMISC));\n                break;\n            }\n        }\n        // Create context if it does not exit\n        if(cc == gctrl->countOfActiveCUContexts) {\n            SUBDBG(\"Event %s device %d does not have a cuCtx registered yet...\\n\", eventName, eventDeviceNum);\n            if(currDeviceNum != eventDeviceNum) {\n                CUDA_CALL((*cudaSetDevicePtr) (eventDeviceNum), return (PAPI_EMISC));\n                CUDA_CALL((*cudaFreePtr) (NULL), return (PAPI_EMISC));\n                CU_CALL((*cuCtxGetCurrentPtr) (&eventCuCtx), return (PAPI_EMISC));\n            } else {\n                eventCuCtx = currCuCtx;\n            }\n            gctrl->arrayOfActiveCUContexts[cc] = papi_calloc(1, sizeof(papicuda_active_cucontext_t));\n            CHECK_PRINT_EVAL(gctrl->arrayOfActiveCUContexts[cc] == NULL, \"Memory allocation for new active context failed\", return (PAPI_ENOMEM));\n            gctrl->arrayOfActiveCUContexts[cc]->deviceNum = eventDeviceNum;\n            gctrl->arrayOfActiveCUContexts[cc]->cuCtx = eventCuCtx;\n            gctrl->arrayOfActiveCUContexts[cc]->eventGroupPasses = NULL;\n            gctrl->arrayOfActiveCUContexts[cc]->conMetricsCount = 0;\n            gctrl->arrayOfActiveCUContexts[cc]->conEventsCount = 0;\n            gctrl->countOfActiveCUContexts++;\n            SUBDBG(\"Added a new context deviceNum %d cuCtx %p ... now countOfActiveCUContexts is %d\\n\", eventDeviceNum, eventCuCtx, gctrl->countOfActiveCUContexts);\n        }\n        eventContextIdx = cc;\n\n        papicuda_active_cucontext_t *eventctrl = gctrl->arrayOfActiveCUContexts[eventContextIdx];\n        switch (gctxt->availEventKind[index]) {\n        case CUPTI_ACTIVITY_KIND_METRIC:\n            SUBDBG(\"Need to add metric %d %s \\n\", index, eventName);\n            /* For the metric, find list of events required */\n            CUpti_MetricID metricId = gctxt->availEventIDArray[index];\n            CUPTI_CALL((*cuptiMetricGetNumEventsPtr) (metricId, &numEvents), return (PAPI_EINVAL));\n            size_t sizeBytes = numEvents * sizeof(CUpti_EventID);\n            CUpti_EventID *eventIdArray = papi_malloc(sizeBytes);\n            CHECK_PRINT_EVAL(eventIdArray == NULL, \"Malloc failed\", return (PAPI_ENOMEM));\n            CUPTI_CALL((*cuptiMetricEnumEventsPtr) (metricId, &sizeBytes, eventIdArray), return (PAPI_EINVAL));\n            SUBDBG(\"For metric %s, append the list of %d required events\\n\", eventName, numEvents);\n            for(ee = 0; ee < numEvents; ee++) {\n                eventctrl->conEvents[eventctrl->conEventsCount] = eventIdArray[ee];\n                eventctrl->conEventsCount++;\n                SUBDBG(\"For metric %s, appended event %d - %d %d to this context (conEventsCount %d)\\n\", eventName, ee, eventIdArray[ee], eventctrl->conEvents[eventctrl->conEventsCount], eventctrl->conEventsCount);\n                if (eventctrl->conEventsCount >= PAPICUDA_MAX_COUNTERS) {\n                    SUBDBG(\"Num events (generated by metric) exceeded PAPICUDA_MAX_COUNTERS\\n\");\n                    return(PAPI_EINVAL);\n                }\n            }\n            eventctrl->conMetrics[eventctrl->conMetricsCount] = metricId;\n            eventctrl->conMetricsCount++;\n            if (eventctrl->conMetricsCount >= PAPICUDA_MAX_COUNTERS) {\n                SUBDBG(\"Num metrics exceeded PAPICUDA_MAX_COUNTERS\\n\");\n                return(PAPI_EINVAL);\n            }\n            break;\n\n        case CUPTI_ACTIVITY_KIND_EVENT:\n            SUBDBG(\"Need to add event %d %s to the context\\n\", index, eventName);\n            /* lookup cuptieventid for this event index */\n            CUpti_EventID eventId = gctxt->availEventIDArray[index];\n            eventctrl->conEvents[eventctrl->conEventsCount] = eventId;\n            eventctrl->conEventsCount++;\n            break;\n\n        default:\n            CHECK_PRINT_EVAL(1, \"Unknown CUPTI measure\", return (PAPI_EMISC));\n            break;\n        }\n        \n        if (eventctrl->conEventsCount >= PAPICUDA_MAX_COUNTERS) {\n            SUBDBG(\"Num events exceeded PAPICUDA_MAX_COUNTERS\\n\");\n            return(PAPI_EINVAL);\n        }\n        \n        /* Record index of this active event back into the nativeInfo structure */\n        nativeInfo[ii].ni_position = gctrl->activeEventCount;\n        /* record added event at the higher level */\n        CHECK_PRINT_EVAL(gctrl->activeEventCount == PAPICUDA_MAX_COUNTERS - 1, \"Exceeded maximum num of events (PAPI_MAX_COUNTERS)\", return (PAPI_EMISC));\n        gctrl->activeEventIndex[gctrl->activeEventCount] = index;\n        // gctrl->activeEventContextIdx[gctrl->activeEventCount] = eventContextIdx;\n        gctrl->activeEventValues[gctrl->activeEventCount] = 0;\n        gctrl->activeEventCount++;\n\n        /* Create/recreate eventgrouppass structures for the added event and context */\n        SUBDBG(\"Create eventGroupPasses for context (destroy pre-existing) (nativeCount %d, conEventsCount %d) \\n\", gctrl->activeEventCount, eventctrl->conEventsCount);\n        if(eventctrl->conEventsCount > 0) {\n            // SUBDBG(\"Destroy prevous eventGroupPasses for the context \\n\");\n            if(eventctrl->eventGroupPasses != NULL)\n                CUPTI_CALL((*cuptiEventGroupSetsDestroyPtr) (eventctrl->eventGroupPasses), return (PAPI_EMISC));\n            eventctrl->eventGroupPasses = NULL;\n            size_t sizeBytes = (eventctrl->conEventsCount) * sizeof(CUpti_EventID);\n            // SUBDBG(\"About to create eventGroupPasses for the context (sizeBytes %zu) \\n\", sizeBytes);\n#ifdef PAPICUDA_KERNEL_REPLAY_MODE\n            CUPTI_CALL((*cuptiEnableKernelReplayModePtr) (eventCuCtx), return (PAPI_ECMP));\n            CUPTI_CALL((*cuptiEventGroupSetsCreatePtr) (eventCuCtx, sizeBytes, eventctrl->conEvents, &eventctrl->eventGroupPasses), return (PAPI_ECMP));\n#else\n            CUPTI_CALL((*cuptiSetEventCollectionModePtr)(eventCuCtx,CUPTI_EVENT_COLLECTION_MODE_KERNEL), return(PAPI_ECMP));\n            CUPTI_CALL((*cuptiEventGroupSetsCreatePtr) (eventCuCtx, sizeBytes, eventctrl->conEvents, &eventctrl->eventGroupPasses), return (PAPI_EMISC));\n            if (eventctrl->eventGroupPasses->numSets > 1) {\n                SUBDBG(\"Error occured: The combined CUPTI events require more than 1 pass... try different events\\n\");\n                papicuda_cleanup_eventset(ctrl);\n                return(PAPI_ECOMBO);\n            } else  {\n                SUBDBG(\"Created eventGroupPasses for context total-events %d in-this-context %d passes-requied %d) \\n\", gctrl->activeEventCount, eventctrl->conEventsCount, eventctrl->eventGroupPasses->numSets);\n            }\n\n#endif\n        }\n        \n        if(eventCuCtx != currCuCtx) \n            CU_CALL((*cuCtxPopCurrentPtr) (&eventCuCtx), return (PAPI_EMISC));\n\n    }\n    return (PAPI_OK);\n}\n\n/* Triggered by PAPI_start().\n * For CUDA component, switch to each context and start all eventgroups.\n*/\nstatic int papicuda_start(hwd_context_t * ctx, hwd_control_state_t * ctrl)\n{\n    SUBDBG(\"Entering\\n\");\n    (void) ctx;\n    (void) ctrl;\n    papicuda_control_t *gctrl = global_papicuda_control;\n    // papicuda_context_t *gctxt = global_papicuda_context;\n    uint32_t ii, gg, cc, ss;\n    int saveDeviceNum = -1;\n\n    SUBDBG(\"Reset all active event values\\n\");\n    for(ii = 0; ii < gctrl->activeEventCount; ii++)\n        gctrl->activeEventValues[ii] = 0;\n\n    SUBDBG(\"Save current context, then switch to each active device/context and enable eventgroups\\n\");\n    CUDA_CALL((*cudaGetDevicePtr) (&saveDeviceNum), return (PAPI_EMISC));\n    CUPTI_CALL((*cuptiGetTimestampPtr) (&gctrl->cuptiStartTimestampNs), return (PAPI_EMISC));\n    for(cc = 0; cc < gctrl->countOfActiveCUContexts; cc++) {\n        int eventDeviceNum = gctrl->arrayOfActiveCUContexts[cc]->deviceNum;\n        CUcontext eventCuCtx = gctrl->arrayOfActiveCUContexts[cc]->cuCtx;\n        SUBDBG(\"Set to device %d cuCtx %p \\n\", eventDeviceNum, eventCuCtx);\n        // CUDA_CALL( (*cudaSetDevicePtr)(eventDeviceNum), return(PAPI_EMISC));\n        if(eventDeviceNum != saveDeviceNum)\n            CU_CALL((*cuCtxPushCurrentPtr) (eventCuCtx), return (PAPI_EMISC));\n        CUpti_EventGroupSets *eventEventGroupPasses = gctrl->arrayOfActiveCUContexts[cc]->eventGroupPasses;\n        for (ss=0; ss<eventEventGroupPasses->numSets; ss++) {\n            CUpti_EventGroupSet groupset = eventEventGroupPasses->sets[ss];\n            for(gg = 0; gg < groupset.numEventGroups; gg++) {\n                CUpti_EventGroup group = groupset.eventGroups[gg];\n                uint32_t one = 1;\n                CUPTI_CALL((*cuptiEventGroupSetAttributePtr) (group, CUPTI_EVENT_GROUP_ATTR_PROFILE_ALL_DOMAIN_INSTANCES, sizeof(uint32_t), &one), return (PAPI_EMISC));\n            }\n            CUPTI_CALL((*cuptiEventGroupSetEnablePtr) (&groupset), return (PAPI_EMISC));\n        }\n        if(eventDeviceNum != saveDeviceNum)\n            CU_CALL((*cuCtxPopCurrentPtr) (&eventCuCtx), return (PAPI_EMISC));\n    }\n\n    return (PAPI_OK);\n}\n\n\n/* Triggered by PAPI_read().  For CUDA component, switch to each\n * context, read all the eventgroups, and put the values in the\n * correct places. */\nstatic int papicuda_read(hwd_context_t * ctx, hwd_control_state_t * ctrl, long long **values, int flags)\n{\n    SUBDBG(\"Entering\\n\");\n    (void) ctx;\n    (void) ctrl;\n    (void) flags;\n    papicuda_control_t *gctrl = global_papicuda_control;\n    papicuda_context_t *gctxt = global_papicuda_context;\n    uint32_t gg, ii, jj, ee, instanceK, cc, rr, ss;\n    int saveDeviceNum;\n    size_t eventIdsSize = PAPICUDA_MAX_COUNTERS * sizeof(CUpti_EventID);\n    uint64_t readEventValueBuffer[PAPICUDA_MAX_COUNTERS];\n    CUpti_EventID readEventIDArray[PAPICUDA_MAX_COUNTERS];\n\n    // Get read time stamp\n    CUPTI_CALL((*cuptiGetTimestampPtr) (&gctrl->cuptiReadTimestampNs), return (PAPI_EMISC));\n    uint64_t durationNs = gctrl->cuptiReadTimestampNs - gctrl->cuptiStartTimestampNs;\n    gctrl->cuptiStartTimestampNs = gctrl->cuptiReadTimestampNs;\n    \n    SUBDBG(\"Save current context, then switch to each active device/context and enable eventgroups\\n\");\n    CUDA_CALL((*cudaGetDevicePtr) (&saveDeviceNum), return (PAPI_EMISC));\n    for(cc = 0; cc < gctrl->countOfActiveCUContexts; cc++) {\n        int currDeviceNum = gctrl->arrayOfActiveCUContexts[cc]->deviceNum;\n        CUcontext currCuCtx = gctrl->arrayOfActiveCUContexts[cc]->cuCtx;\n        SUBDBG(\"Set to device %d cuCtx %p \\n\", currDeviceNum, currCuCtx);\n        if(currDeviceNum != saveDeviceNum)\n            CU_CALL((*cuCtxPushCurrentPtr) (currCuCtx), return (PAPI_EMISC));\n        else\n            CU_CALL((*cuCtxSetCurrentPtr) (currCuCtx), return (PAPI_EMISC));\n\n        size_t numEventIDsRead = 0;\n        CU_CALL((*cuCtxSynchronizePtr) (), return (PAPI_EMISC));\n        CUpti_EventGroupSets *currEventGroupPasses = gctrl->arrayOfActiveCUContexts[cc]->eventGroupPasses;\n        uint32_t numEvents, numInstances, numTotalInstances;\n        size_t sizeofuint32num = sizeof(uint32_t);\n        CUpti_EventDomainID groupDomainID;\n        size_t groupDomainIDSize = sizeof(groupDomainID);\n        CUdevice cudevice = gctxt->deviceArray[currDeviceNum].cuDev;\n\n        /* Since we accumulate the eventValues in a buffer, it needs to be cleared for each context */\n        for(ee = 0; ee < PAPICUDA_MAX_COUNTERS; ee++)\n            readEventValueBuffer[ee] = 0;\n\n        for (ss=0; ss<currEventGroupPasses->numSets; ss++) {\n            CUpti_EventGroupSet groupset = currEventGroupPasses->sets[ss]; \n            SUBDBG(\"Read events in this context\\n\");\n            for(gg = 0; gg < groupset.numEventGroups; gg++) {\n                CUpti_EventGroup group = groupset.eventGroups[gg];\n                CUPTI_CALL((*cuptiEventGroupGetAttributePtr) (group, CUPTI_EVENT_GROUP_ATTR_EVENT_DOMAIN_ID, &groupDomainIDSize, &groupDomainID), return (PAPI_EMISC));\n                CUPTI_CALL((*cuptiDeviceGetEventDomainAttributePtr) (cudevice, groupDomainID, CUPTI_EVENT_DOMAIN_ATTR_TOTAL_INSTANCE_COUNT, &sizeofuint32num, &numTotalInstances), return (PAPI_EMISC));\n                CUPTI_CALL((*cuptiEventGroupGetAttributePtr) (group, CUPTI_EVENT_GROUP_ATTR_INSTANCE_COUNT, &sizeofuint32num, &numInstances), return (PAPI_EMISC));\n                CUPTI_CALL((*cuptiEventGroupGetAttributePtr) (group, CUPTI_EVENT_GROUP_ATTR_NUM_EVENTS, &sizeofuint32num, &numEvents), return (PAPI_EMISC));\n                eventIdsSize = PAPICUDA_MAX_COUNTERS * sizeof(CUpti_EventID);\n                CUpti_EventID eventIds[PAPICUDA_MAX_COUNTERS];\n                CUPTI_CALL((*cuptiEventGroupGetAttributePtr) (group, CUPTI_EVENT_GROUP_ATTR_EVENTS, &eventIdsSize, eventIds), return (PAPI_EMISC));\n                SUBDBG(\"Context %d eventgroup %d domain numTotalInstaces %u numInstances %u numEvents %u\\n\", cc, gg, numTotalInstances, numInstances, numEvents);\n                size_t valuesSize = sizeof(uint64_t) * numInstances;\n                uint64_t *values = (uint64_t *) papi_malloc(valuesSize);\n                CHECK_PRINT_EVAL(values == NULL, \"Out of memory\", return (PAPI_ENOMEM));\n                /* For each event, read all values and normalize */\n                for(ee = 0; ee < numEvents; ee++) {\n                    CUPTI_CALL((*cuptiEventGroupReadEventPtr) (group, CUPTI_EVENT_READ_FLAG_NONE, eventIds[ee], &valuesSize, values), return (PAPI_EMISC));\n                    // sum collect event values from all instances\n                    uint64_t valuesum = 0;\n                    for(instanceK = 0; instanceK < numInstances; instanceK++)\n                        valuesum += values[instanceK];\n                    // It seems that the same event can occur multiple times in eventIds, so we need to accumulate values in older valueBuffers if needed \n                    // Scan thru readEvents looking for a match, break if found, if not found, increment numEventIDsRead\n                    for(rr = 0; rr < numEventIDsRead; rr++)\n                        if(readEventIDArray[rr] == eventIds[ee])\n                            break;\n                    /* If the event was not found, increment the numEventIDsRead */\n                    if(rr == numEventIDsRead)\n                    numEventIDsRead++;\n                    readEventIDArray[rr] = eventIds[ee];\n                    readEventValueBuffer[rr] += valuesum;\n                    size_t tmpStrSize = PAPI_MIN_STR_LEN - 1 * sizeof(char);\n                    char tmpStr[PAPI_MIN_STR_LEN];\n                    CUPTI_CALL((*cuptiEventGetAttributePtr) (eventIds[ee], CUPTI_EVENT_ATTR_NAME, &tmpStrSize, tmpStr), return (PAPI_EMISC));\n                    SUBDBG(\"Read context %d eventgroup %d numEventIDsRead %lu device %d event %d/%d %d name %s value %lu (rr %d id %d val %lu) \\n\", cc, gg, numEventIDsRead, currDeviceNum, ee, numEvents, eventIds[ee], tmpStr, valuesum, rr,\n                           eventIds[rr], readEventValueBuffer[rr]);\n                }\n                papi_free(values);\n            }\n        }\n\n        // normalize the event values to represent the total number of domain instances on the device\n        for(ii = 0; ii < numEventIDsRead; ii++) \n            readEventValueBuffer[numEventIDsRead] = (readEventValueBuffer[numEventIDsRead] * numTotalInstances) / numInstances;\n\n        /* For this pushed device and context, figure out the event and metric values and record them into the arrays */\n        SUBDBG(\"For this device and context, match read values against active events by scanning activeEvents array and matching associated availEventIDs\\n\");\n        for(jj = 0; jj < gctrl->activeEventCount; jj++) {\n            int index = gctrl->activeEventIndex[jj];\n            /* If the device/context does not match the current context, move to next */\n            if(gctxt->availEventDeviceNum[index] != currDeviceNum)\n                continue;\n            uint32_t eventId = gctxt->availEventIDArray[index];\n            switch (gctxt->availEventKind[index]) {\n            case CUPTI_ACTIVITY_KIND_EVENT:\n                SUBDBG(\"Searching for activeEvent %s eventId %u\\n\", gctxt->availEventDesc[index].name, eventId);\n                for(ii = 0; ii < numEventIDsRead; ii++) {\n                    SUBDBG(\"Look at readEventIDArray[%u/%zu] with id %u\\n\", ii, numEventIDsRead, readEventIDArray[ii]);\n                    if(readEventIDArray[ii] == eventId) {\n                        gctrl->activeEventValues[jj] += (long long) readEventValueBuffer[ii];\n                        SUBDBG(\"Matched read-eventID %d:%d eventName %s value %ld activeEvent %d value %lld \\n\", jj, (int) eventId, gctxt->availEventDesc[index].name, readEventValueBuffer[ii], index, gctrl->activeEventValues[jj]);\n                        break;\n                    }\n                }\n                break;\n\n            case CUPTI_ACTIVITY_KIND_METRIC:\n                SUBDBG(\"For the metric, find list of events required to calculate this metric value\\n\");\n                CUpti_MetricID metricId = gctxt->availEventIDArray[index];\n                int metricDeviceNum = gctxt->availEventDeviceNum[index];\n                CUdevice cudevice = gctxt->deviceArray[metricDeviceNum].cuDev;\n                uint32_t numEvents, ee;\n                CUPTI_CALL((*cuptiMetricGetNumEventsPtr) (metricId, &numEvents), return (PAPI_EINVAL));\n                SUBDBG(\"Metric %s needs %d events\\n\", gctxt->availEventDesc[index].name, numEvents);\n                size_t eventIdArraySizeBytes = numEvents * sizeof(CUpti_EventID);\n                CUpti_EventID *eventIdArray = papi_malloc(eventIdArraySizeBytes);\n                CHECK_PRINT_EVAL(eventIdArray == NULL, \"Malloc failed\", return (PAPI_ENOMEM));\n                size_t eventValueArraySizeBytes = numEvents * sizeof(uint64_t);\n                uint64_t *eventValueArray = papi_malloc(eventValueArraySizeBytes);\n                CHECK_PRINT_EVAL(eventValueArray == NULL, \"Malloc failed\", return (PAPI_ENOMEM));\n                CUPTI_CALL((*cuptiMetricEnumEventsPtr) (metricId, &eventIdArraySizeBytes, eventIdArray), return (PAPI_EINVAL));\n                // Match metrics for the users events\n                for(ee = 0; ee < numEvents; ee++) {\n                    for(ii = 0; ii < numEventIDsRead; ii++) {\n                        if(eventIdArray[ee] == readEventIDArray[ii]) {\n                            SUBDBG(\"Matched metric %s, found %d/%d events with eventId %d\\n\", gctxt->availEventDesc[index].name, ee, numEvents, readEventIDArray[ii]);\n                            eventValueArray[ee] = readEventValueBuffer[ii];\n                            break;\n                        }\n                    }\n                    CHECK_PRINT_EVAL(ii == numEventIDsRead, \"Could not find required event for metric\", return (PAPI_EINVAL));\n                }\n\n                // Use CUPTI to calculate a metric.  Return all metric values mapped into long long values.\n                CUpti_MetricValue metricValue;\n                CUpti_MetricValueKind valueKind;\n                size_t valueKindSize = sizeof(valueKind);\n                CUPTI_CALL((*cuptiMetricGetAttributePtr) (metricId, CUPTI_METRIC_ATTR_VALUE_KIND, &valueKindSize, &valueKind), return (PAPI_EMISC));\n                CUPTI_CALL((*cuptiMetricGetValuePtr) (cudevice, metricId, eventIdArraySizeBytes, eventIdArray, eventValueArraySizeBytes, eventValueArray, durationNs, &metricValue), return (PAPI_EMISC));\n                int retval = papicuda_convert_metric_value_to_long_long(metricValue, valueKind, &(gctrl->activeEventValues[jj]));\n                if(retval != PAPI_OK)\n                    return (retval);\n                papi_free(eventIdArray);\n                papi_free(eventValueArray);\n                break;\n\n            default:\n                SUBDBG(\"Not handled\");\n                break;\n            }\n        }\n\n        /* Pop the pushed context */\n        if(currDeviceNum != saveDeviceNum)\n            CU_CALL((*cuCtxPopCurrentPtr) (&currCuCtx), return (PAPI_EMISC));\n    }\n    *values = gctrl->activeEventValues;\n    return (PAPI_OK);\n}\n\n/* Triggered by PAPI_stop() */\nstatic int papicuda_stop(hwd_context_t * ctx, hwd_control_state_t * ctrl)\n{\n    SUBDBG(\"Entering\\n\");\n    (void) ctx;\n    (void) ctrl;\n    papicuda_control_t *gctrl = global_papicuda_control;\n    uint32_t cc, ss;\n    int saveDeviceNum;\n\n    SUBDBG(\"Save current context, then switch to each active device/context and enable eventgroups\\n\");\n    CUDA_CALL((*cudaGetDevicePtr) (&saveDeviceNum), return (PAPI_EMISC));\n    for(cc = 0; cc < gctrl->countOfActiveCUContexts; cc++) {\n        int currDeviceNum = gctrl->arrayOfActiveCUContexts[cc]->deviceNum;\n        CUcontext currCuCtx = gctrl->arrayOfActiveCUContexts[cc]->cuCtx;\n        SUBDBG(\"Set to device %d cuCtx %p \\n\", currDeviceNum, currCuCtx);\n        if(currDeviceNum != saveDeviceNum)\n            CU_CALL((*cuCtxPushCurrentPtr) (currCuCtx), return (PAPI_EMISC));\n        else\n            CU_CALL((*cuCtxSetCurrentPtr) (currCuCtx), return (PAPI_EMISC));\n        CUpti_EventGroupSets *currEventGroupPasses = gctrl->arrayOfActiveCUContexts[cc]->eventGroupPasses;\n        for (ss=0; ss<currEventGroupPasses->numSets; ss++) {\n            CUpti_EventGroupSet groupset = currEventGroupPasses->sets[ss]; \n            CUPTI_CALL((*cuptiEventGroupSetDisablePtr) (&groupset), return (PAPI_EMISC));\n        }\n        /* Pop the pushed context */\n        if(currDeviceNum != saveDeviceNum)\n            CU_CALL((*cuCtxPopCurrentPtr) (&currCuCtx), return (PAPI_EMISC));\n\n    }\n    return (PAPI_OK);\n}\n\n\n/* \n * Disable and destroy the CUDA eventGroup\n */\nstatic int papicuda_cleanup_eventset(hwd_control_state_t * ctrl)\n{\n    SUBDBG(\"Entering\\n\");\n    (void) ctrl;\n    papicuda_control_t *gctrl = global_papicuda_control;\n    // papicuda_active_cucontext_t *currctrl;\n    uint32_t cc;\n    int saveDeviceNum;\n\n    SUBDBG(\"Save current context, then switch to each active device/context and enable eventgroups\\n\");\n    CUDA_CALL((*cudaGetDevicePtr) (&saveDeviceNum), return (PAPI_EMISC));\n    for(cc = 0; cc < gctrl->countOfActiveCUContexts; cc++) {\n        CUcontext currCuCtx = gctrl->arrayOfActiveCUContexts[cc]->cuCtx;\n        int currDeviceNum = gctrl->arrayOfActiveCUContexts[cc]->deviceNum;\n        CUpti_EventGroupSets *currEventGroupPasses = gctrl->arrayOfActiveCUContexts[cc]->eventGroupPasses;\n        if(currDeviceNum != saveDeviceNum)\n            CU_CALL((*cuCtxPushCurrentPtr) (currCuCtx), return (PAPI_EMISC));\n        else\n            CU_CALL((*cuCtxSetCurrentPtr) (currCuCtx), return (PAPI_EMISC));\n        //CUPTI_CALL((*cuptiEventGroupSetsDestroyPtr) (currEventGroupPasses), return (PAPI_EMISC));\n        (*cuptiEventGroupSetsDestroyPtr) (currEventGroupPasses);\n        gctrl->arrayOfActiveCUContexts[cc]->eventGroupPasses = NULL;\n        papi_free( gctrl->arrayOfActiveCUContexts[cc] );\n        /* Pop the pushed context */\n        if(currDeviceNum != saveDeviceNum)\n            CU_CALL((*cuCtxPopCurrentPtr) (&currCuCtx), return (PAPI_EMISC));\n    }\n    /* Record that there are no active contexts or events */\n    gctrl->countOfActiveCUContexts = 0;\n    gctrl->activeEventCount = 0;\n    return (PAPI_OK);\n}\n\n\n/* Called at thread shutdown. Does nothing in the CUDA component. */\nint papicuda_shutdown_thread(hwd_context_t * ctx)\n{\n    SUBDBG(\"Entering\\n\");\n    (void) ctx;\n\n    return (PAPI_OK);\n}\n\n/* Triggered by PAPI_shutdown() and frees memory allocated in the CUDA component. */\nstatic int papicuda_shutdown_component(void)\n{\n    SUBDBG(\"Entering\\n\");\n    papicuda_control_t *gctrl = global_papicuda_control;\n    papicuda_context_t *gctxt = global_papicuda_context;\n    int deviceNum;\n    uint32_t cc;\n    /* Free context */\n    if(gctxt) {\n        for(deviceNum = 0; deviceNum < gctxt->deviceCount; deviceNum++) {\n            papicuda_device_desc_t *mydevice = &gctxt->deviceArray[deviceNum];\n            papi_free(mydevice->domainIDArray);\n            papi_free(mydevice->domainIDNumEvents);\n        }\n        papi_free(gctxt->availEventIDArray);\n        papi_free(gctxt->availEventDeviceNum);\n        papi_free(gctxt->availEventKind);\n        papi_free(gctxt->availEventIsBeingMeasuredInEventset);\n        papi_free(gctxt->availEventDesc);\n        papi_free(gctxt->deviceArray);\n        papi_free(gctxt);\n        global_papicuda_context = gctxt = NULL;\n    }\n    /* Free control */\n    if(gctrl) {\n        for(cc = 0; cc < gctrl->countOfActiveCUContexts; cc++) {\n#ifdef PAPICUDA_KERNEL_REPLAY_MODE\n            CUcontext currCuCtx = gctrl->arrayOfActiveCUContexts[cc]->cuCtx;\n            CUPTI_CALL((*cuptiDisableKernelReplayModePtr) (currCuCtx), return (PAPI_EMISC));\n#endif\n            if(gctrl->arrayOfActiveCUContexts[cc] != NULL)\n                papi_free(gctrl->arrayOfActiveCUContexts[cc]);\n        }\n        papi_free(gctrl);\n        global_papicuda_control = gctrl = NULL;\n    }\n    // close the dynamic libraries needed by this component (opened in the init substrate call)\n    dlclose(dl1);\n    dlclose(dl2);\n    dlclose(dl3);\n    return (PAPI_OK);\n}\n\n\n/* Triggered by PAPI_reset() but only if the EventSet is currently\n *  running. If the eventset is not currently running, then the saved\n *  value in the EventSet is set to zero without calling this\n *  routine.  */\nstatic int papicuda_reset(hwd_context_t * ctx, hwd_control_state_t * ctrl)\n{\n    (void) ctx;\n    (void) ctrl;\n    papicuda_control_t *gctrl = global_papicuda_control;\n    uint32_t gg, ii, cc, ss;\n    int saveDeviceNum;\n\n    SUBDBG(\"Reset all active event values\\n\");\n    for(ii = 0; ii < gctrl->activeEventCount; ii++)\n        gctrl->activeEventValues[ii] = 0;\n\n    SUBDBG(\"Save current context, then switch to each active device/context and reset\\n\");\n    CUDA_CALL((*cudaGetDevicePtr) (&saveDeviceNum), return (PAPI_EMISC));\n    for(cc = 0; cc < gctrl->countOfActiveCUContexts; cc++) {\n        CUcontext currCuCtx = gctrl->arrayOfActiveCUContexts[cc]->cuCtx;\n        int currDeviceNum = gctrl->arrayOfActiveCUContexts[cc]->deviceNum;\n        if(currDeviceNum != saveDeviceNum)\n            CU_CALL((*cuCtxPushCurrentPtr) (currCuCtx), return (PAPI_EMISC));\n        else\n            CU_CALL((*cuCtxSetCurrentPtr) (currCuCtx), return (PAPI_EMISC));\n        CUpti_EventGroupSets *currEventGroupPasses = gctrl->arrayOfActiveCUContexts[cc]->eventGroupPasses;\n        for (ss=0; ss<currEventGroupPasses->numSets; ss++) {\n            CUpti_EventGroupSet groupset = currEventGroupPasses->sets[ss]; \n            for(gg = 0; gg < groupset.numEventGroups; gg++) {\n                CUpti_EventGroup group = groupset.eventGroups[gg];\n                CUPTI_CALL((*cuptiEventGroupResetAllEventsPtr) (group), return (PAPI_EMISC));\n            }\n            CUPTI_CALL((*cuptiEventGroupSetEnablePtr) (&groupset), return (PAPI_EMISC));\n        }\n        if(currDeviceNum != saveDeviceNum)\n            CU_CALL((*cuCtxPopCurrentPtr) (&currCuCtx), return (PAPI_EMISC));\n    }\n    return (PAPI_OK);\n}\n\n\n/* This function sets various options in the component - Does nothing in the CUDA component.\n    @param[in] ctx -- hardware context\n    @param[in] code valid are PAPI_SET_DEFDOM, PAPI_SET_DOMAIN, PAPI_SETDEFGRN, PAPI_SET_GRANUL and PAPI_SET_INHERIT\n    @param[in] option -- options to be set\n*/\nstatic int papicuda_ctrl(hwd_context_t * ctx, int code, _papi_int_option_t * option)\n{\n    SUBDBG(\"Entering\\n\");\n    (void) ctx;\n    (void) code;\n    (void) option;\n    return (PAPI_OK);\n}\n\n/* \n * This function has to set the bits needed to count different domains\n * In particular: PAPI_DOM_USER, PAPI_DOM_KERNEL PAPI_DOM_OTHER\n * By default return PAPI_EINVAL if none of those are specified\n * and PAPI_OK with success\n * PAPI_DOM_USER is only user context is counted\n * PAPI_DOM_KERNEL is only the Kernel/OS context is counted\n * PAPI_DOM_OTHER  is Exception/transient mode (like user TLB misses)\n * PAPI_DOM_ALL   is all of the domains\n */\nstatic int papicuda_set_domain(hwd_control_state_t * ctrl, int domain)\n{\n    SUBDBG(\"Entering\\n\");\n    (void) ctrl;\n    if((PAPI_DOM_USER & domain) || (PAPI_DOM_KERNEL & domain) || (PAPI_DOM_OTHER & domain) || (PAPI_DOM_ALL & domain))\n        return (PAPI_OK);\n    else\n        return (PAPI_EINVAL);\n    return (PAPI_OK);\n}\n\n\n/* Enumerate Native Events.\n *   @param EventCode is the event of interest\n *   @param modifier is one of PAPI_ENUM_FIRST, PAPI_ENUM_EVENTS\n */\nstatic int papicuda_ntv_enum_events(unsigned int *EventCode, int modifier)\n{\n    // SUBDBG( \"Entering (get next event after %u)\\n\", *EventCode );\n    switch (modifier) {\n    case PAPI_ENUM_FIRST:\n        *EventCode = 0;\n        return (PAPI_OK);\n        break;\n    case PAPI_ENUM_EVENTS:\n        if(*EventCode < global_papicuda_context->availEventSize - 1) {\n            *EventCode = *EventCode + 1;\n            return (PAPI_OK);\n        } else\n            return (PAPI_ENOEVNT);\n        break;\n    default:\n        return (PAPI_EINVAL);\n    }\n    return (PAPI_OK);\n}\n\n\n/* Takes a native event code and passes back the name\n * @param EventCode is the native event code\n * @param name is a pointer for the name to be copied to\n * @param len is the size of the name string\n */\nstatic int papicuda_ntv_code_to_name(unsigned int EventCode, char *name, int len)\n{\n    // SUBDBG( \"Entering EventCode %d\\n\", EventCode );\n    unsigned int index = EventCode;\n    papicuda_context_t *gctxt = global_papicuda_context;\n    if(index < gctxt->availEventSize) {\n        strncpy(name, gctxt->availEventDesc[index].name, len);\n    } else {\n        return (PAPI_EINVAL);\n    }\n    // SUBDBG( \"Exit: EventCode %d: Name %s\\n\", EventCode, name );\n    return (PAPI_OK);\n}\n\n\n/* Takes a native event code and passes back the event description\n * @param EventCode is the native event code\n * @param descr is a pointer for the description to be copied to\n * @param len is the size of the descr string\n */\nstatic int papicuda_ntv_code_to_descr(unsigned int EventCode, char *name, int len)\n{\n    // SUBDBG( \"Entering\\n\" );\n    unsigned int index = EventCode;\n    papicuda_context_t *gctxt = global_papicuda_context;\n    if(index < gctxt->availEventSize) {\n        strncpy(name, gctxt->availEventDesc[index].description, len);\n    } else {\n        return (PAPI_EINVAL);\n    }\n    return (PAPI_OK);\n}\n\n\n/* Vector that points to entry points for the component */\npapi_vector_t _cuda_vector = {\n    .cmp_info = {\n                 /* default component information (unspecified values are initialized to 0) */\n                 .name = \"cuda\",\n                 .short_name = \"cuda\",\n                 .version = \"5.1\",\n                 .description = \"CUDA events and metrics via NVIDIA CuPTI interfaces\",\n                 .num_mpx_cntrs = PAPICUDA_MAX_COUNTERS,\n                 .num_cntrs = PAPICUDA_MAX_COUNTERS,\n                 .default_domain = PAPI_DOM_USER,\n                 .default_granularity = PAPI_GRN_THR,\n                 .available_granularities = PAPI_GRN_THR,\n                 .hardware_intr_sig = PAPI_INT_SIGNAL,\n                 /* component specific cmp_info initializations */\n                 .fast_real_timer = 0,\n                 .fast_virtual_timer = 0,\n                 .attach = 0,\n                 .attach_must_ptrace = 0,\n                 .available_domains = PAPI_DOM_USER | PAPI_DOM_KERNEL,\n                 }\n    ,\n    /* sizes of framework-opaque component-private structures... these are all unused in this component */\n    .size = {\n             .context = 1,      /* sizeof( papicuda_context_t ), */\n             .control_state = 1,        /* sizeof( papicuda_control_t ), */\n             .reg_value = 1,    /* sizeof( papicuda_register_t ), */\n             .reg_alloc = 1,    /* sizeof( papicuda_reg_alloc_t ), */\n             }\n    ,\n    /* function pointers in this component */\n    .start = papicuda_start,    /* ( hwd_context_t * ctx, hwd_control_state_t * ctrl ) */\n    .stop = papicuda_stop,      /* ( hwd_context_t * ctx, hwd_control_state_t * ctrl ) */\n    .read = papicuda_read,      /* ( hwd_context_t * ctx, hwd_control_state_t * ctrl, long_long ** events, int flags ) */\n    .reset = papicuda_reset,    /* ( hwd_context_t * ctx, hwd_control_state_t * ctrl ) */\n    .cleanup_eventset = papicuda_cleanup_eventset,      /* ( hwd_control_state_t * ctrl ) */\n\n    .init_component = papicuda_init_component,  /* ( int cidx ) */\n    .init_thread = papicuda_init_thread,        /* ( hwd_context_t * ctx ) */\n    .init_control_state = papicuda_init_control_state,  /* ( hwd_control_state_t * ctrl ) */\n    .update_control_state = papicuda_update_control_state,      /* ( hwd_control_state_t * ptr, NativeInfo_t * native, int count, hwd_context_t * ctx ) */\n\n    .ctl = papicuda_ctrl,       /* ( hwd_context_t * ctx, int code, _papi_int_option_t * option ) */\n    .set_domain = papicuda_set_domain,  /* ( hwd_control_state_t * cntrl, int domain ) */\n    .ntv_enum_events = papicuda_ntv_enum_events,        /* ( unsigned int *EventCode, int modifier ) */\n    .ntv_code_to_name = papicuda_ntv_code_to_name,      /* ( unsigned int EventCode, char *name, int len ) */\n    .ntv_code_to_descr = papicuda_ntv_code_to_descr,    /* ( unsigned int EventCode, char *name, int len ) */\n    .shutdown_thread = papicuda_shutdown_thread,        /* ( hwd_context_t * ctx ) */\n    .shutdown_component = papicuda_shutdown_component,  /* ( void ) */\n};\n",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.6.0-iweh6uy7qfzcgjj77nhy45ucjhpm2ow6/spack-src/src/components/cuda/tests/cuda_ld_preload_example.c": "/*\n  Example of using LD_PRELOAD with the CUDA component.  \n  Asim YarKhan\n\n  This is designed to work with the simpleMultiGPU_no_counters binary\n  in the PAPI CUDA component tests directory.  First trace the library\n  calls in simpleMultiGPU_no_counters binary using ltrace.  Note in\n  the ltrace output that the CUDA C APIs are different from the CUDA\n  calls visible to nvcc. Then figure out appropriate place to attach\n  the PAPI calls.  The initialization is attached to the first entry\n  to cudaSetDevice.  Each cudaSetDevice is also used to setup the PAPI\n  events for that device.  It was harder to figure out where to attach\n  the PAPI_start.  After running some tests, I attached it to the 18th\n  invocation of gettimeofday (kind of arbitrary! Sorry!).  The\n  PAPI_stop was attached to the first invocation of cudaFreeHost.\n\n*/\n\n#define _GNU_SOURCE\n\n#include <stdio.h>\n#include <dlfcn.h>\n\n#include \"papi.h\"\n\n#define MAXDEVICES 5\nint EventSet = PAPI_NULL;\nint devseen[MAXDEVICES] = {0};\n\nstatic void *dl1;\nint (*PAPI_library_init_ptr)(int version); /**< initialize the PAPI library */\nint (*PAPI_create_eventset_ptr)(int *EventSet); /**< create a new empty PAPI event set */\nint (*PAPI_add_named_event_ptr)(int EventSet, char *EventName); /**< add an event by name to a PAPI event set */\nint (*PAPI_start_ptr)(int EventSet); /**< start counting hardware events in an event set */\nint (*PAPI_stop_ptr)(int EventSet, long long * values); /**< stop counting hardware events in an event set and return current events */\n\n\nint cudaSetDevice(int devnum, int n1, int n2, int n3, void *ptr1) \n{\n    static int onetime = 0;\n    int retval, retval_cudaSetDevice;\n    //printf(\"cudaSetDevice wrapper %d\\n\", devnum);\n    if ( onetime==0 ) {\n        onetime=1;\n        // Load the papi library dynamically and read the relevant functions\n        dl1 = dlopen( \"libpapi.so\", RTLD_NOW | RTLD_GLOBAL );\n        if ( dl1==NULL ) printf(\"Intercept cudaSetDevice: Cannot load libpapi.so\\n\");\n        PAPI_library_init_ptr = dlsym( dl1, \"PAPI_library_init\" );\n        PAPI_create_eventset_ptr = dlsym( dl1, \"PAPI_create_eventset\" );\n        PAPI_add_named_event_ptr = dlsym( dl1, \"PAPI_add_named_event\" );\n        PAPI_start_ptr = dlsym( dl1, \"PAPI_start\" );\n        PAPI_stop_ptr = dlsym( dl1, \"PAPI_stop\" );\n        // Start using PAPI\n        printf(\"Intercept cudaSetDevice: Initializing PAPI on device %d\\n\", devnum);\n        retval = (PAPI_library_init_ptr)( PAPI_VER_CURRENT );\n        if( retval != PAPI_VER_CURRENT ) fprintf( stdout, \"PAPI_library_init failed\\n\" );\n        printf( \"PAPI version: %d.%d.%d\\n\", PAPI_VERSION_MAJOR( PAPI_VERSION ), PAPI_VERSION_MINOR( PAPI_VERSION ), PAPI_VERSION_REVISION( PAPI_VERSION ) );\n        retval = (PAPI_create_eventset_ptr)( &EventSet );\n        if( retval != PAPI_OK ) fprintf( stdout, \"PAPI_create_eventset failed\\n\" );\n    }\n    int (*original_function)(int devnum, int n1, int n2, int n3, void *ptr1);\n    original_function = dlsym(RTLD_NEXT, \"cudaSetDevice\");\n    retval_cudaSetDevice = (*original_function)( devnum, n1, n2, n3, ptr1 );\n    if ( devseen[devnum]==0 ) {\n        devseen[devnum]=1;\n        char tmpEventName[120];\n        printf(\"Intercept cudaSetDevice: Attaching events for device on device %d\\n\", devnum);\n        snprintf( tmpEventName, 110, \"cuda:::device:%d:%s\", devnum, \"inst_executed\" );\n        retval = (PAPI_add_named_event_ptr)( EventSet, tmpEventName );\n        if (retval!=PAPI_OK) printf( \"Could not add event %s\\n\", tmpEventName );\n    }\n    return retval_cudaSetDevice;\n}\n\n\nint gettimeofday(void *ptr1, void *ptr2)\n{\n    static int onetime = 0;\n    onetime++;\n    // printf(\"gettimeofday onetime %d\\n\", onetime);\n    // Use above print statement to determine that the N-th gettime of day works\n    if ( onetime==17 ) {\n        printf(\"Intercept gettimeofday: Attaching PAPI_start to the %d th call to gettimeofday (this may need to be adjusted)\\n\", onetime);\n        int retval = (PAPI_start_ptr)( EventSet );\n        printf(\"Starting PAPI\\n\");\n        if( retval!=PAPI_OK ) fprintf( stdout, \"PAPI_start failed\\n\" );\n    }\n    int (*original_function)(void *ptr1, void *ptr2);\n    original_function = dlsym(RTLD_NEXT, \"gettimeofday\");\n    return (*original_function)(ptr1, ptr2);\n}\n\nint cudaFreeHost(void *ptr1, void *ptr2, int n1, int n2, void *ptr3) \n{\n    static int onetime = 0;\n    long long values[10];\n    int retval, devnum;\n    onetime++;\n    if ( onetime==1 ) {\n        printf(\"Intercept cudaFreeHost: Used to get PAPI results\\n\" );\n        retval = (PAPI_stop_ptr)( EventSet, values );\n        if( retval != PAPI_OK )  fprintf( stderr, \"PAPI_stop failed\\n\" );\n        for( devnum = 0; devnum < MAXDEVICES && devseen[devnum]==1  ; devnum++ )\n            printf( \"PAPI counterValue: cuda::device:%d:%s: %12lld \\n\", devnum, \"inst_executed\", values[devnum] );\n    }\n    int (*original_function)(void *ptr1, void *ptr2, int n1, int n2, void *ptr3);\n    original_function = dlsym(RTLD_NEXT, \"cudaFreeHost\");\n    return (*original_function)(ptr1, ptr2, n1, n2, ptr3);\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.6.0-iweh6uy7qfzcgjj77nhy45ucjhpm2ow6/spack-src/src/components/infiniband_umad/linux-infiniband_umad.c": "/****************************/\n/* THIS IS OPEN SOURCE CODE */\n/****************************/\n\n/** \n * @file    linux-infiniband_umad.c\n * @author  Heike Jagode (in collaboration with Michael Kluge, TU Dresden)\n *          jagode@eecs.utk.edu\n *\n * @ingroup papi_components \t\t\n * \n * InfiniBand component \n * \n * Tested version of OFED: 1.4\n *\n * @brief\n *  This file has the source code for a component that enables PAPI-C to \n *  access hardware monitoring counters for InfiniBand devices through the  \n *  OFED library. Since a new interface was introduced with OFED version 1.4 \n *  (released Dec 2008), the current InfiniBand component does not support \n *  OFED versions < 1.4.\n */\n#include <dlfcn.h>\n\n#include \"papi.h\"\n#include \"papi_internal.h\"\n#include \"papi_vector.h\"\n#include \"papi_memory.h\"\n\n#include \"linux-infiniband_umad.h\"\n\nvoid (*_dl_non_dynamic_init)(void) __attribute__((weak));\n\n/********  CHANGE PROTOTYPES TO DECLARE Infiniband LIBRARY SYMBOLS AS WEAK  **********\n *  This is done so that a version of PAPI built with the infiniband component can   *\n *  be installed on a system which does not have the infiniband libraries installed. *\n *                                                                                   *\n *  If this is done without these prototypes, then all papi services on the system   *\n *  without the infiniband libraries installed will fail.  The PAPI libraries        *\n *  contain references to the infiniband libraries which are not installed.  The     *\n *  load of PAPI commands fails because the infiniband library references can not    *\n *  be resolved.                                                                     *\n *                                                                                   *\n *  This also defines pointers to the infiniband library functions that we call.     *\n *  These function pointers will be resolved with dlopen/dlsym calls at component    *\n *  initialization time.  The component then calls the infiniband library functions  *\n *  through these function pointers.                                                 *\n *************************************************************************************/\nint                 __attribute__((weak)) umad_init              ( void );\nint                 __attribute__((weak)) umad_get_cas_names     ( char [][UMAD_CA_NAME_LEN], int  );\nint                 __attribute__((weak)) umad_get_ca            ( char *, umad_ca_t * );\nvoid                __attribute__((weak)) mad_decode_field       ( unsigned char *, enum MAD_FIELDS, void *);\nstruct ibmad_port * __attribute__((weak)) mad_rpc_open_port      ( char *, int, int *, int );\nint                 __attribute__((weak)) ib_resolve_self_via    ( ib_portid_t *, int *, ibmad_gid_t *, const struct ibmad_port * );\nuint8_t *           __attribute__((weak)) performance_reset_via  ( void *, ib_portid_t *, int, unsigned, unsigned, unsigned, const struct ibmad_port * );\nuint8_t *           __attribute__((weak)) pma_query_via          ( void *, ib_portid_t *, int, unsigned, unsigned, const struct ibmad_port * );\n\nint                  (*umad_initPtr)             ( void );\nint                  (*umad_get_cas_namesPtr)    ( char [][UMAD_CA_NAME_LEN], int );\nint                  (*umad_get_caPtr)           ( char *, umad_ca_t * );\nvoid                 (*mad_decode_fieldPtr)      ( unsigned char *, enum MAD_FIELDS, void * );\nstruct ibmad_port *  (*mad_rpc_open_portPtr)     ( char *, int, int *, int );\nint                  (*ib_resolve_self_viaPtr)   (ib_portid_t *, int *, ibmad_gid_t *, const struct ibmad_port * );\nuint8_t *            (*performance_reset_viaPtr) (void *, ib_portid_t *, int, unsigned, unsigned, unsigned, const struct ibmad_port * );\nuint8_t *            (*pma_query_viaPtr)         (void *, ib_portid_t *, int, unsigned, unsigned, const struct ibmad_port * );\n\n// file handles used to access Infiniband libraries with dlopen\nstatic void* dl1 = NULL;\nstatic void* dl2 = NULL;\n\nstatic int linkInfinibandLibraries ();\n\npapi_vector_t _infiniband_umad_vector;\n\n\n\nstruct ibmad_port *srcport;\nstatic ib_portid_t portid;\nstatic int ib_timeout = 0;\nstatic int ibportnum = 0;\n\nstatic counter_info *subscriptions[INFINIBAND_MAX_COUNTERS];\nstatic int is_initialized = 0;\nstatic int num_counters = 0;\nstatic int is_finalized = 0;\n\n/* counters are kept in a list */\nstatic counter_info *root_counter = NULL;\n/* IB ports found are kept in a list */\nstatic ib_port *root_ib_port = NULL;\nstatic ib_port *active_ib_port = NULL;\n\n#define infiniband_native_table subscriptions\n/* macro to initialize entire structs to 0 */\n#define InitStruct(var, type) type var; memset(&var, 0, sizeof(type))\n\nlong long _papi_hwd_infiniband_register_start[INFINIBAND_MAX_COUNTERS];\nlong long _papi_hwd_infiniband_register[INFINIBAND_MAX_COUNTERS];\n\n\n/*******************************************************************************\n ********  BEGIN FUNCTIONS  USED INTERNALLY SPECIFIC TO THIS COMPONENT *********\n ******************************************************************************/\n\n/**\n * use libumad to discover IB ports\n */\nstatic void\ninit_ib_counter(  )\n{\n\tchar names[20][UMAD_CA_NAME_LEN];\n\tint n, i;\n\tchar *ca_name;\n\tumad_ca_t ca;\n\tint r;\n\tint portnum;\n\n//\tif ( umad_init(  ) < 0 ) {\n//\t\tfprintf( stderr, \"can't init UMAD library\\n\" );\n//\t\texit( 1 );\n//\t}\n\n\tif ( ( n = (*umad_get_cas_namesPtr)( ( void * ) names, UMAD_CA_NAME_LEN ) ) < 0 ) {\n\t\tfprintf( stderr, \"can't list IB device names\\n\" );\n\t\texit( 1 );\n\t}\n\n\tfor ( i = 0; i < n; i++ ) {\n\t\tca_name = names[i];\n\n\t\tif ( ( r = (*umad_get_caPtr)( ca_name, &ca ) ) < 0 ) {\n\t\t\tfprintf( stderr, \"can't read ca from IB device\\n\" );\n\t\t\texit( 1 );\n\t\t}\n\n\t\tif ( !ca.node_type )\n\t\t\tcontinue;\n\n\t\t/* port numbers are '1' based in OFED */\n\t\tfor ( portnum = 1; portnum <= ca.numports; portnum++ )\n\t\t\taddIBPort( ca.ca_name, ca.ports[portnum] );\n\t}\n}\n\n\n/**\n * add a counter to the list of available counters\n * @param name the short name of the counter\n * @param desc a longer description\n * @param unit the unit for this counter\n */\nstatic counter_info *\naddCounter( const char *name, const char *desc, const char *unit )\n{\n\tcounter_info *cntr, *last;\n\n\tcntr = ( counter_info * ) malloc( sizeof ( counter_info ) );\n\tif ( cntr == NULL ) {\n\t\tfprintf( stderr, \"can not allocate memory for new counter\\n\" );\n\t\texit( 1 );\n\t}\n\tcntr->name = strdup( name );\n\tcntr->description = strdup( desc );\n\tcntr->unit = strdup( unit );\n\tcntr->value = 0;\n\tcntr->next = NULL;\n\n\tif ( root_counter == NULL ) {\n\t\troot_counter = cntr;\n\t} else {\n\t\tlast = root_counter;\n\t\twhile ( last->next != NULL )\n\t\t\tlast = last->next;\n\t\tlast->next = cntr;\n\t}\n\n\treturn cntr;\n}\n\n\n/**\n * add one IB port to the list of available ports and add the\n * counters related to this port to the global counter list\n */\nstatic void\naddIBPort( const char *ca_name, umad_port_t * port )\n{\n\tib_port *nwif, *last;\n\tchar counter_name[512];\n\n\tnwif = ( ib_port * ) malloc( sizeof ( ib_port ) );\n\n\tif ( nwif == NULL ) {\n\t\tfprintf( stderr, \"can not allocate memory for IB port description\\n\" );\n\t\texit( 1 );\n\t}\n\n\tsprintf( counter_name, \"%s_%d\", ca_name, port->portnum );\n\tnwif->name = strdup( counter_name );\n\n\tsprintf( counter_name, \"%s_%d_recv\", ca_name, port->portnum );\n\tnwif->recv_cntr =\n\t\taddCounter( counter_name, \"bytes received on this IB port\", \"bytes\" );\n\n\tsprintf( counter_name, \"%s_%d_send\", ca_name, port->portnum );\n\tnwif->send_cntr =\n\t\taddCounter( counter_name, \"bytes written to this IB port\", \"bytes\" );\n\n\tnwif->port_rate = port->rate;\n\tnwif->is_initialized = 0;\n\tnwif->port_number = port->portnum;\n\tnwif->next = NULL;\n\n\tnum_counters += 2;\n\n\tif ( root_ib_port == NULL ) {\n\t\troot_ib_port = nwif;\n\t} else {\n\t\tlast = root_ib_port;\n\t\twhile ( last->next != NULL )\n\t\t\tlast = last->next;\n\t\tlast->next = nwif;\n\t}\n}\n\n\n/**\n * initialize one IB port so that we are able to read values from it\n */\nstatic int\ninit_ib_port( ib_port * portdata )\n{\n\tint mgmt_classes[4] = { IB_SMI_CLASS, IB_SMI_DIRECT_CLASS, IB_SA_CLASS,\n\t\tIB_PERFORMANCE_CLASS\n\t};\n\tchar *ca = 0;\n\tstatic uint8_t pc[1024];\n\tint mask = 0xFFFF;\n\n\tsrcport = (*mad_rpc_open_portPtr)( ca, portdata->port_number, mgmt_classes, 4 );\n\tif ( !srcport ) {\n\t\tfprintf( stderr, \"Failed to open '%s' port '%d'\\n\", ca,\n\t\t\t\t portdata->port_number );\n\t\texit( 1 );\n\t}\n\n\tif ( (*ib_resolve_self_viaPtr)( &portid, &ibportnum, 0, srcport ) < 0 ) {\n\t\tfprintf( stderr, \"can't resolve self port\\n\" );\n\t\texit( 1 );\n\t}\n\n\t/* PerfMgt ClassPortInfo is a required attribute */\n\t/* might be redundant, could be left out for fast implementation */\n\tif ( !(*pma_query_viaPtr) ( pc, &portid, ibportnum, ib_timeout, CLASS_PORT_INFO, srcport ) ) {\n\t\tfprintf( stderr, \"classportinfo query\\n\" );\n\t\texit( 1 );\n\t}\n\n\tif ( !(*performance_reset_viaPtr) ( pc, &portid, ibportnum, mask, ib_timeout, IB_GSI_PORT_COUNTERS, srcport ) ) {\n\t\tfprintf( stderr, \"perf reset\\n\" );\n\t\texit( 1 );\n\t}\n\n\t/* read the initial values */\n\t(*mad_decode_fieldPtr)( pc, IB_PC_XMT_BYTES_F, &portdata->last_send_val );\n\tportdata->sum_send_val = 0;\n\t(*mad_decode_fieldPtr)( pc, IB_PC_RCV_BYTES_F, &portdata->last_recv_val );\n\tportdata->sum_recv_val = 0;\n\n\tportdata->is_initialized = 1;\n\n\treturn 0;\n}\n\n\n/**\n * read and reset IB counters (reset on demand)\n */\nstatic int\nread_ib_counter(  )\n{\n\tuint32_t send_val;\n\tuint32_t recv_val;\n\tuint8_t pc[1024];\n\t/* 32 bit counter FFFFFFFF */\n\tuint32_t max_val = 4294967295;\n\t/* if it is bigger than this -> reset */\n\tuint32_t reset_limit = max_val * 0.7;\n\tint mask = 0xFFFF;\n\n\tif ( active_ib_port == NULL )\n\t\treturn 0;\n\n\t/* reading cost ~70 mirco secs */\n\tif ( !(*pma_query_viaPtr) ( pc, &portid, ibportnum, ib_timeout, IB_GSI_PORT_COUNTERS, srcport ) ) {\n\t\tfprintf( stderr, \"perfquery\\n\" );\n\t\texit( 1 );\n\t}\n\n\t(*mad_decode_fieldPtr)( pc, IB_PC_XMT_BYTES_F, &send_val );\n\t(*mad_decode_fieldPtr)( pc, IB_PC_RCV_BYTES_F, &recv_val );\n\n\t/* multiply the numbers read by 4 as the IB port counters are not\n\t   counting bytes. they always count 32dwords. see man page of\n\t   perfquery for details\n\t   internally a uint64_t ia used to sum up the values */\n\tactive_ib_port->sum_send_val +=\n\t\t( send_val - active_ib_port->last_send_val ) * 4;\n\tactive_ib_port->sum_recv_val +=\n\t\t( recv_val - active_ib_port->last_recv_val ) * 4;\n\n\tactive_ib_port->send_cntr->value = active_ib_port->sum_send_val;\n\tactive_ib_port->recv_cntr->value = active_ib_port->sum_recv_val;\n\n\tif ( send_val > reset_limit || recv_val > reset_limit ) {\n\t\t/* reset cost ~70 mirco secs */\n\t\tif ( !(*performance_reset_viaPtr) ( pc, &portid, ibportnum, mask, ib_timeout, IB_GSI_PORT_COUNTERS, srcport ) ) {\n\t\t\tfprintf( stderr, \"perf reset\\n\" );\n\t\t\texit( 1 );\n\t\t}\n\n\t\t(*mad_decode_fieldPtr)( pc, IB_PC_XMT_BYTES_F, &active_ib_port->last_send_val );\n\t\t(*mad_decode_fieldPtr)( pc, IB_PC_RCV_BYTES_F, &active_ib_port->last_recv_val );\n\t} else {\n\t\tactive_ib_port->last_send_val = send_val;\n\t\tactive_ib_port->last_recv_val = recv_val;\n\t}\n\n\treturn 0;\n}\n\n\nvoid\nhost_read_values( long long *data )\n{\n\tint loop;\n\n\tread_ib_counter(  );\n\n\tfor ( loop = 0; loop < INFINIBAND_MAX_COUNTERS; loop++ ) {\n\t\tif ( subscriptions[loop] == NULL )\n\t\t\tbreak;\n\n\t\tdata[loop] = subscriptions[loop]->value;\n\t}\n}\n\n\n/**\n * find the pointer for a counter_info structure based on the counter name\n */\nstatic counter_info *\ncounterFromName( const char *cntr )\n{\n\tint loop = 0;\n\tchar tmp[512];\n\tcounter_info *local_cntr = root_counter;\n\n\twhile ( local_cntr != NULL ) {\n\t\tif ( strcmp( cntr, local_cntr->name ) == 0 )\n\t\t\treturn local_cntr;\n\n\t\tlocal_cntr = local_cntr->next;\n\t\tloop++;\n\t}\n\n\tgethostname( tmp, 512 );\n\tfprintf( stderr, \"can not find host counter: %s on %s\\n\", cntr, tmp );\n\tfprintf( stderr, \"we only have: \" );\n\tlocal_cntr = root_counter;\n\n\twhile ( local_cntr != NULL ) {\n\t\tfprintf( stderr, \"'%s' \", local_cntr->name );\n\t\tlocal_cntr = local_cntr->next;\n\t\tloop++;\n\t}\n\n\tfprintf( stderr, \"\\n\" );\n\texit( 1 );\n\t/* never reached */\n\treturn 0;\n}\n\n\n/**\n * allow external code to subscribe to a counter based on the counter name\n */\nstatic uint64_t\nhost_subscribe( const char *cntr )\n{\n\tint loop;\n\tint len;\n\tchar tmp_name[512];\n\tib_port *aktp;\n\n\tcounter_info *counter = counterFromName( cntr );\n\n\tfor ( loop = 0; loop < INFINIBAND_MAX_COUNTERS; loop++ ) {\n\t\tif ( subscriptions[loop] == NULL ) {\n\t\t\tsubscriptions[loop] = counter;\n\t\t\tcounter->idx = loop;\n\n\t\t\t/* we have an IB counter if the name ends with _send or _recv and\n\t\t\t   the prefix before that is in the ib_port list */\n\t\t\tif ( ( len = strlen( cntr ) ) > 5 ) {\n\t\t\t\tif ( strcmp( &cntr[len - 5], \"_recv\" ) == 0 ||\n\t\t\t\t\t strcmp( &cntr[len - 5], \"_send\" ) == 0 ) {\n\t\t\t\t\t/* look through all IB_counters */\n\t\t\t\t\tstrncpy( tmp_name, cntr, len - 5 );\n\t\t\t\t\ttmp_name[len - 5] = 0;\n\t\t\t\t\taktp = root_ib_port;\n\t\t\t\t\t// printf(\"looking for IB port '%s'\\n\", tmp_name);\n\t\t\t\t\twhile ( aktp != NULL ) {\n\t\t\t\t\t\tif ( strcmp( aktp->name, tmp_name ) == 0 ) {\n\t\t\t\t\t\t\tif ( !aktp->is_initialized ) {\n\t\t\t\t\t\t\t\tinit_ib_port( aktp );\n\t\t\t\t\t\t\t\tactive_ib_port = aktp;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn loop + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* name does not match, if this counter is\n\t\t\t\t\t\t   initialized, we can't have two active IB ports */\n\t\t\t\t\t\tif ( aktp->is_initialized ) {\n#if 0\t/* not necessary with OFED version >= 1.4 */\n\t\t\t\t\t\t\tfprintf( stderr,\n\t\t\t\t\t\t\t\t\t \"unable to activate IB port monitoring for more than one port\\n\" );\n\t\t\t\t\t\t\texit( 1 );\n#endif\n\t\t\t\t\t\t}\n\t\t\t\t\t\taktp = aktp->next;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn loop + 1;\n\t\t}\n\t}\n\tfprintf( stderr, \"please subscribe only once to each counter\\n\" );\n\texit( 1 );\n\t/* never reached */\n\treturn 0;\n}\n\n\n/**\n * return a newly allocated list of strings containing all counter names\n */\nstatic string_list *\nhost_listCounter( int num_counters1 )\n{\n\tstring_list *list;\n\tcounter_info *cntr = root_counter;\n\n\tlist = malloc( sizeof ( string_list ) );\n\tif ( list == NULL ) {\n\t\tfprintf( stderr, \"unable to allocate memory for new string_list\" );\n\t\texit( 1 );\n\t}\n\tlist->count = 0;\n\tlist->data = ( char ** ) malloc( num_counters1 * sizeof ( char * ) );\n\n\tif ( list->data == NULL ) {\n\t\tfprintf( stderr,\n\t\t\t\t \"unable to allocate memory for %d pointers in a new string_list\\n\",\n\t\t\t\t num_counters1 );\n\t\texit( 1 );\n\t}\n\n\twhile ( cntr != NULL ) {\n\t\tlist->data[list->count++] = strdup( cntr->name );\n\t\tcntr = cntr->next;\n\t}\n\n\treturn list;\n}\n\n\n/**\n * finalizes the library\n */\nstatic void\nhost_finalize(  )\n{\n\tcounter_info *cntr, *next;\n\n\tif ( is_finalized )\n\t\treturn;\n\n\tcntr = root_counter;\n\n\twhile ( cntr != NULL ) {\n\t\tnext = cntr->next;\n\t\tfree( cntr->name );\n\t\tfree( cntr->description );\n\t\tfree( cntr->unit );\n\t\tfree( cntr );\n\t\tcntr = next;\n\t}\n\n\troot_counter = NULL;\n\n\tis_finalized = 1;\n}\n\n\n/**\n * delete a list of strings\n */\nstatic void\nhost_deleteStringList( string_list * to_delete )\n{\n\tint loop;\n\n\tif ( to_delete->data != NULL ) {\n\t\tfor ( loop = 0; loop < to_delete->count; loop++ )\n\t\t\tfree( to_delete->data[loop] );\n\n\t\tfree( to_delete->data );\n\t}\n\n\tfree( to_delete );\n}\n\n\n/*****************************************************************************\n *******************  BEGIN PAPI's COMPONENT REQUIRED FUNCTIONS  *************\n *****************************************************************************/\n\n/*\n * This is called whenever a thread is initialized\n */\nint\nINFINIBAND_init_thread( hwd_context_t * ctx )\n{\n\tstring_list *counter_list = NULL;\n\tint i;\n\tint loop;\n\n\t/* initialize portid struct of type ib_portid_t to 0 */\n\tInitStruct( portid, ib_portid_t );\n\n\tif ( is_initialized )\n\t\treturn PAPI_OK;\n\n\tis_initialized = 1;\n\n\tinit_ib_counter(  );\n\n\tfor ( loop = 0; loop < INFINIBAND_MAX_COUNTERS; loop++ )\n\t\tsubscriptions[loop] = NULL;\n\n\tcounter_list = host_listCounter( num_counters );\n\n\tfor ( i = 0; i < counter_list->count; i++ )\n\t\thost_subscribe( counter_list->data[i] );\n\n\t( ( INFINIBAND_context_t * ) ctx )->state.ncounter = counter_list->count;\n\n\thost_deleteStringList( counter_list );\n\n\treturn PAPI_OK;\n}\n\n\n/* Initialize hardware counters, setup the function vector table\n * and get hardware information, this routine is called when the \n * PAPI process is initialized (IE PAPI_library_init)\n */\nint\nINFINIBAND_init_component( int cidx )\n{\n\tSUBDBG (\"Entry: cidx: %d\\n\", cidx);\n\tint i;\n\n\t/* link in all the infiniband libraries and resolve the symbols we need to use */\n\tif (linkInfinibandLibraries() != PAPI_OK) {\n\t\tSUBDBG (\"Dynamic link of Infiniband libraries failed, component will be disabled.\\n\");\n\t\tSUBDBG (\"See disable reason in papi_component_avail output for more details.\\n\");\n\t\treturn (PAPI_ENOSUPP);\n\t}\n\n\t/* make sure that the infiniband library finds the kernel module loaded. */\n\tif ( (*umad_initPtr)(  ) < 0 ) {\n\t\tstrncpy(_infiniband_umad_vector.cmp_info.disabled_reason, \"Call to initialize umad library failed.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\n\tfor ( i = 0; i < INFINIBAND_MAX_COUNTERS; i++ ) {\n\t\t_papi_hwd_infiniband_register_start[i] = -1;\n\t\t_papi_hwd_infiniband_register[i] = -1;\n\t}\n\n\t/* Export the component id */\n\t_infiniband_umad_vector.cmp_info.CmpIdx = cidx;\n\n\treturn ( PAPI_OK );\n}\n\n\n/*\n * Link the necessary Infiniband libraries to use the Infiniband component.  If any of them can not be found, then\n * the Infiniband component will just be disabled.  This is done at runtime so that a version of PAPI built\n * with the Infiniband component can be installed and used on systems which have the Infiniband libraries installed\n * and on systems where these libraries are not installed.\n */\nstatic int\nlinkInfinibandLibraries ()\n{\n\t/* Attempt to guess if we were statically linked to libc, if so bail */\n\tif ( _dl_non_dynamic_init != NULL ) {\n\t\tstrncpy(_infiniband_umad_vector.cmp_info.disabled_reason, \"The Infiniband component does not support statically linking of libc.\", PAPI_MAX_STR_LEN);\n\t\treturn PAPI_ENOSUPP;\n\t}\n\n\t/* Need to link in the Infiniband libraries, if not found disable the component */\n\tdl1 = dlopen(\"libibumad.so\", RTLD_NOW | RTLD_GLOBAL);\n\tif (!dl1)\n\t{\n\t\tstrncpy(_infiniband_umad_vector.cmp_info.disabled_reason, \"Infiniband library libibumad.so not found.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tumad_initPtr = dlsym(dl1, \"umad_init\");\n\tif (dlerror() != NULL)\n\t{\n\t\tstrncpy(_infiniband_umad_vector.cmp_info.disabled_reason, \"Infiniband function umad_init not found.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tumad_get_cas_namesPtr = dlsym(dl1, \"umad_get_cas_names\");\n\tif (dlerror() != NULL)\n\t{\n\t\tstrncpy(_infiniband_umad_vector.cmp_info.disabled_reason, \"Infiniband function umad_get_cas_names not found.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tumad_get_caPtr = dlsym(dl1, \"umad_get_ca\");\n\tif (dlerror() != NULL)\n\t{\n\t\tstrncpy(_infiniband_umad_vector.cmp_info.disabled_reason, \"Infiniband function umad_get_ca not found.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\n\t/* Need to link in the Infiniband libraries, if not found disable the component */\n\tdl2 = dlopen(\"libibmad.so\", RTLD_NOW | RTLD_GLOBAL);\n\tif (!dl2)\n\t{\n\t\tstrncpy(_infiniband_umad_vector.cmp_info.disabled_reason, \"Infiniband library libibmad.so not found.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tmad_decode_fieldPtr = dlsym(dl2, \"mad_decode_field\");\n\tif (dlerror() != NULL)\n\t{\n\t\tstrncpy(_infiniband_umad_vector.cmp_info.disabled_reason, \"Infiniband function mad_decode_field not found.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tmad_rpc_open_portPtr = dlsym(dl2, \"mad_rpc_open_port\");\n\tif (dlerror() != NULL)\n\t{\n\t\tstrncpy(_infiniband_umad_vector.cmp_info.disabled_reason, \"Infiniband function mad_rpc_open_port not found.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tib_resolve_self_viaPtr = dlsym(dl2, \"ib_resolve_self_via\");\n\tif (dlerror() != NULL)\n\t{\n\t\tstrncpy(_infiniband_umad_vector.cmp_info.disabled_reason, \"Infiniband function ib_resolve_self_via not found.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tperformance_reset_viaPtr = dlsym(dl2, \"performance_reset_via\");\n\tif (dlerror() != NULL)\n\t{\n\t\tstrncpy(_infiniband_umad_vector.cmp_info.disabled_reason, \"Infiniband function performance_reset_via not found.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tpma_query_viaPtr = dlsym(dl2, \"pma_query_via\");\n\tif (dlerror() != NULL)\n\t{\n\t\tstrncpy(_infiniband_umad_vector.cmp_info.disabled_reason, \"Infiniband function pma_query_via not found.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\n\treturn ( PAPI_OK );\n}\n\n\n/*\n * Control of counters (Reading/Writing/Starting/Stopping/Setup)\n * functions\n */\nint\nINFINIBAND_init_control_state( hwd_control_state_t * ctrl )\n{\n\t( void ) ctrl;\n\treturn PAPI_OK;\n}\n\n\n/*\n *\n */\nint\nINFINIBAND_start( hwd_context_t * ctx, hwd_control_state_t * ctrl )\n{\n\t( void ) ctx;\n\t( void ) ctrl;\n\n\thost_read_values( _papi_hwd_infiniband_register_start );\n\n\tmemcpy( _papi_hwd_infiniband_register, _papi_hwd_infiniband_register_start,\n\t\t\tINFINIBAND_MAX_COUNTERS * sizeof ( long long ) );\n\n\treturn ( PAPI_OK );\n}\n\n\n/*\n *\n */\nint\nINFINIBAND_stop( hwd_context_t * ctx, hwd_control_state_t * ctrl )\n{\n\tint i;\n\t( void ) ctx;\n\n\thost_read_values( _papi_hwd_infiniband_register );\n\n\tfor ( i = 0; i < ( ( INFINIBAND_context_t * ) ctx )->state.ncounter; i++ ) {\n\t\t( ( INFINIBAND_control_state_t * ) ctrl )->counts[i] =\n\t\t\t_papi_hwd_infiniband_register[i] -\n\t\t\t_papi_hwd_infiniband_register_start[i];\n\t}\n\n\treturn ( PAPI_OK );\n}\n\n\n/*\n *\n */\nint\nINFINIBAND_read( hwd_context_t * ctx, hwd_control_state_t * ctrl,\n\t\t\t\t long_long ** events, int flags )\n{\n\tint i;\n\t( void ) flags;\n\n\thost_read_values( _papi_hwd_infiniband_register );\n\n\tfor ( i = 0; i < ( ( INFINIBAND_context_t * ) ctx )->state.ncounter; i++ ) {\n\t\t( ( INFINIBAND_control_state_t * ) ctrl )->counts[i] =\n\t\t\t_papi_hwd_infiniband_register[i] -\n\t\t\t_papi_hwd_infiniband_register_start[i];\n\t}\n\n\t*events = ( ( INFINIBAND_control_state_t * ) ctrl )->counts;\n\treturn ( PAPI_OK );\n}\n\n\n/*\n *\n */\nint\nINFINIBAND_shutdown_thread( hwd_context_t * ctx )\n{\n\t( void ) ctx;\n\thost_finalize(  );\n\treturn ( PAPI_OK );\n}\n\n\n/*\n *\n */\nint\nINFINIBAND_shutdown_component( void )\n{\n\t// close the dynamic libraries needed by this component (opened in the init substrate call)\n\tdlclose(dl1);\n\tdlclose(dl2);\n\n\treturn ( PAPI_OK );\n}\n\n\n/* This function sets various options in the component\n * The valid codes being passed in are PAPI_SET_DEFDOM,\n * PAPI_SET_DOMAIN, PAPI_SETDEFGRN, PAPI_SET_GRANUL * and PAPI_SET_INHERIT\n */\nint\nINFINIBAND_ctl( hwd_context_t * ctx, int code, _papi_int_option_t * option )\n{\n\t( void ) ctx;\n\t( void ) code;\n\t( void ) option;\n\treturn ( PAPI_OK );\n}\n\n\n//int INFINIBAND_ntv_code_to_bits ( unsigned int EventCode, hwd_register_t * bits );\n\n\n/*\n *\n */\nint\nINFINIBAND_update_control_state( hwd_control_state_t * ptr,\n\t\t\t\t\t\t\t\t NativeInfo_t * native, int count,\n\t\t\t\t\t\t\t\t hwd_context_t * ctx )\n{\n\t( void ) ptr;\n\t( void ) ctx;\n\tint i, index;\n\n\tfor ( i = 0; i < count; i++ ) {\n\t\tindex = native[i].ni_event;\n\t\tnative[i].ni_position = index;\n\t}\n\n\treturn ( PAPI_OK );\n}\n\n\n/*\n * Infiniband counts are system wide, so this is the only domain we will respond to\n */\nint\nINFINIBAND_set_domain( hwd_control_state_t * cntrl, int domain )\n{\n\t(void) cntrl;\n\tif ( PAPI_DOM_ALL != domain )\n\t\treturn ( PAPI_EINVAL );\n\n\treturn ( PAPI_OK );\n}\n\n\n/*\n *\n */\nint\nINFINIBAND_reset( hwd_context_t * ctx, hwd_control_state_t * ctrl )\n{\n\tINFINIBAND_start( ctx, ctrl );\n\treturn ( PAPI_OK );\n}\n\n\n/*\n * Native Event functions\n */\nint\nINFINIBAND_ntv_enum_events( unsigned int *EventCode, int modifier )\n{\n\tif ( modifier == PAPI_ENUM_FIRST ) {\n\t\t*EventCode = 0;\n\t\treturn PAPI_OK;\n\t}\n\n\tif ( modifier == PAPI_ENUM_EVENTS ) {\n\t\tint index = *EventCode;\n\n\t\tif ( infiniband_native_table[index + 1] ) {\n\t\t\t*EventCode = *EventCode + 1;\n\t\t\treturn ( PAPI_OK );\n\t\t} else\n\t\t\treturn ( PAPI_ENOEVNT );\n\t} else\n\t\treturn ( PAPI_EINVAL );\n}\n\n\n/*\n *\n */\nint\nINFINIBAND_ntv_code_to_name( unsigned int EventCode, char *name, int len )\n{\n\tstrncpy( name, infiniband_native_table[EventCode]->name, len );\n\n\treturn PAPI_OK;\n}\n\n\n/*\n *\n */\nint\nINFINIBAND_ntv_code_to_descr( unsigned int EventCode, char *name, int len )\n{\n\tstrncpy( name, infiniband_native_table[EventCode]->description, len );\n\n\treturn PAPI_OK;\n}\n\n\n/*\n *\n */\nint\nINFINIBAND_ntv_code_to_bits( unsigned int EventCode, hwd_register_t * bits )\n{\n\tmemcpy( ( INFINIBAND_register_t * ) bits,\n\t\t\tinfiniband_native_table[EventCode],\n\t\t\tsizeof ( INFINIBAND_register_t ) );\n\n\treturn PAPI_OK;\n}\n\n\n/*\n *\n */\npapi_vector_t _infiniband_umad_vector = {\n\t.cmp_info = {\n\t\t\t\t /* default component information (unspecified values are initialized to 0) */\n\t\t\t\t .name =\"infiniband\",\n\t\t\t\t .short_name=\"infiniband\",\n\t\t\t\t .version = \"4.2.1\",\n\t\t\t\t .description = \"Infiniband statistics\",\n\t\t\t\t .num_mpx_cntrs = INFINIBAND_MAX_COUNTERS,\n\t\t\t\t .num_cntrs = INFINIBAND_MAX_COUNTERS,\n\t\t\t\t .default_domain = PAPI_DOM_ALL,\n\t\t\t\t .available_domains = PAPI_DOM_ALL,\n\t\t\t\t .default_granularity = PAPI_GRN_SYS,\n\t\t\t\t .available_granularities = PAPI_GRN_SYS,\n\t\t\t\t .hardware_intr_sig = PAPI_INT_SIGNAL,\n\n\t\t\t\t /* component specific cmp_info initializations */\n\t\t\t\t .fast_real_timer = 0,\n\t\t\t\t .fast_virtual_timer = 0,\n\t\t\t\t .attach = 0,\n\t\t\t\t .attach_must_ptrace = 0,\n\t\t\t\t }\n\t,\n\n\t/* sizes of framework-opaque component-private structures */\n\t.size = {\n\t\t\t .context = sizeof ( INFINIBAND_context_t ),\n\t\t\t .control_state = sizeof ( INFINIBAND_control_state_t ),\n\t\t\t .reg_value = sizeof ( INFINIBAND_register_t ),\n\t\t\t .reg_alloc = sizeof ( INFINIBAND_reg_alloc_t ),\n\t\t\t }\n\t,\n\t/* function pointers in this component */\n\t.init_thread = INFINIBAND_init_thread,\n\t.init_component = INFINIBAND_init_component,\n\t.init_control_state = INFINIBAND_init_control_state,\n\t.start = INFINIBAND_start,\n\t.stop = INFINIBAND_stop,\n\t.read = INFINIBAND_read,\n\t.shutdown_component = INFINIBAND_shutdown_component,\n\t.shutdown_thread = INFINIBAND_shutdown_thread,\n\t.ctl = INFINIBAND_ctl,\n\n\t.update_control_state = INFINIBAND_update_control_state,\n\t.set_domain = INFINIBAND_set_domain,\n\t.reset = INFINIBAND_reset,\n\n\t.ntv_enum_events = INFINIBAND_ntv_enum_events,\n\t.ntv_code_to_name = INFINIBAND_ntv_code_to_name,\n\t.ntv_code_to_descr = INFINIBAND_ntv_code_to_descr,\n\t.ntv_code_to_bits = INFINIBAND_ntv_code_to_bits,\n};\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.6.0-iweh6uy7qfzcgjj77nhy45ucjhpm2ow6/spack-src/ChangeLogP421.txt",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.6.0-iweh6uy7qfzcgjj77nhy45ucjhpm2ow6/spack-src/src/x86_cpuid_info.c",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.6.0-iweh6uy7qfzcgjj77nhy45ucjhpm2ow6/spack-src/src/sw_multiplex.c",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.6.0-iweh6uy7qfzcgjj77nhy45ucjhpm2ow6/spack-src/src/libpfm-3.y/lib/intel_corei7_events.h",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.6.0-iweh6uy7qfzcgjj77nhy45ucjhpm2ow6/spack-src/src/ctests/bgp/papi_1.c",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.6.0-iweh6uy7qfzcgjj77nhy45ucjhpm2ow6/spack-src/src/perfctr-2.7.x/linux/drivers/perfctr/virtual.c",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.6.0-iweh6uy7qfzcgjj77nhy45ucjhpm2ow6/spack-src/src/perfctr-2.7.x/patches/patch-kernel-2.6.11",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.6.0-iweh6uy7qfzcgjj77nhy45ucjhpm2ow6/spack-src/src/perfctr-2.7.x/patches/patch-kernel-2.6.14-rc5-mm1",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.6.0-iweh6uy7qfzcgjj77nhy45ucjhpm2ow6/spack-src/src/perfctr-2.7.x/patches/patch-kernel-2.6.16.21-SLES10",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.6.0-iweh6uy7qfzcgjj77nhy45ucjhpm2ow6/spack-src/src/perfctr-2.7.x/patches/patch-kernel-2.6.12-rc1",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.6.0-iweh6uy7qfzcgjj77nhy45ucjhpm2ow6/spack-src/src/perfctr-2.7.x/patches/patch-kernel-2.6.14",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.6.0-iweh6uy7qfzcgjj77nhy45ucjhpm2ow6/spack-src/src/perfctr-2.7.x/patches/patch-kernel-2.6.14-mm1",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.6.0-iweh6uy7qfzcgjj77nhy45ucjhpm2ow6/spack-src/src/perfctr-2.7.x/patches/patch-kernel-2.6.12-rc2",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.6.0-iweh6uy7qfzcgjj77nhy45ucjhpm2ow6/spack-src/src/perfctr-2.7.x/patches/patch-kernel-2.6.16",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.6.0-iweh6uy7qfzcgjj77nhy45ucjhpm2ow6/spack-src/src/perfctr-2.7.x/patches/patch-kernel-2.6.12-rc5",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.6.0-iweh6uy7qfzcgjj77nhy45ucjhpm2ow6/spack-src/src/components/vmware/PAPI-VMwareComponentDocument.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.6.0-iweh6uy7qfzcgjj77nhy45ucjhpm2ow6/spack-src/src/components/cuda/sampling/test/sass_source_map.cubin",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.6.0-iweh6uy7qfzcgjj77nhy45ucjhpm2ow6/spack-src/src/perfctr-2.6.x/linux/drivers/perfctr/virtual.c",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.6.0-iweh6uy7qfzcgjj77nhy45ucjhpm2ow6/spack-src/src/perfctr-2.6.x/patches/patch-kernel-2.6.11",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.6.0-iweh6uy7qfzcgjj77nhy45ucjhpm2ow6/spack-src/src/perfctr-2.6.x/patches/patch-kernel-2.6.15",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.6.0-iweh6uy7qfzcgjj77nhy45ucjhpm2ow6/spack-src/src/perfctr-2.6.x/patches/patch-kernel-2.6.13",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.6.0-iweh6uy7qfzcgjj77nhy45ucjhpm2ow6/spack-src/src/perfctr-2.6.x/patches/patch-kernel-2.6.12",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.6.0-iweh6uy7qfzcgjj77nhy45ucjhpm2ow6/spack-src/src/perfctr-2.6.x/patches/patch-kernel-2.6.14",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.6.0-iweh6uy7qfzcgjj77nhy45ucjhpm2ow6/spack-src/src/perfctr-2.6.x/patches/patch-kernel-2.6.10",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.6.0-iweh6uy7qfzcgjj77nhy45ucjhpm2ow6/spack-src/src/perfctr-2.6.x/patches/patch-kernel-2.6.16",
        "/tmp/vanessa/spack-stage/spack-stage-papi-5.6.0-iweh6uy7qfzcgjj77nhy45ucjhpm2ow6/spack-src/src/perfctr-2.6.x/patches/patch-kernel-2.6.16.46-0.12-suse"
    ],
    "total_files": 1788
}