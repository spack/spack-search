{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-papi-6.0.0.1-gmm3tef6bggycxgzrtmq2ejaggc2ozfb/spack-src/ChangeLogP520.txt": "2013-08-02  \n\n  * 6b62d586 man/man1/papi_avail.1 man/man1/papi_clockres.1\n  man/man1/papi_command_line.1...: Update the manpages for a pending 5.2\n  release.  New pages for PAPI[F]_epc and papi_version.\n\n  * 1ae08835 src/linux-common.c: try to properly detect number of sockets  Use\n  totalcpus rather than ncpu in the calculation.  This change fixes things on a\n  Sandybridge-EP machine.  We should maybe find a more robust way to detect\n  this.\n\n  * 79c37fbf .../perf_event_uncore/tests/perf_event_uncore.c\n  .../tests/perf_event_uncore_multiple.c: perf_event_uncore: have tests skip if\n  component disabled rather than fail\n\n  * 638ccf6b .../perf_event_uncore/perf_event_uncore.c: perf_event_uncore:\n  change order of uncore detection logic  This way it will report an error of\n  \"no uncore found\" before it reports \"not enough permissions\".  That way a\n  user won't waste time getting permissions only to find out they didn't have\n  an uncore anyway.\n\n  * 30582773 src/components/perf_event/pe_libpfm4_events.c: perf_event: fix\n  papi_native_avail output  A recent change of mine that added stricter error\n  checking for libpfm4 event lookup broke event enumeration on perf_event,\n  specifically papi_native_avail output.  libpfm4 will return an error on some\n  events if no UMASK or improper UMASK is supplied, but papi_native_avail\n  always wants to print the root event and umasks separately.  this temporary\n  fix just ignores libpfm4 umask errors; we might in the future want to\n  properly indicate which events are only valid when certain umasks are\n  present.\n\n  * c7612326 src/utils/native_avail.c: papi_native_avail: fix empty component\n  case  If a component had no events, papi_native_avail would ignore the error\n  returned by PAPI_enum_cmp_event( PAPI_ENUM_FIRST ); and try to print a first\n  event anyway.\n\n  * e1b064eb .../perf_event_uncore/perf_event_uncore.c: perf_event_uncore:\n  disable component if no events found  This can happen on older (pre 3.6)\n  kernels with the new libpfm4 that does proper uncore detection.\n\n2013-08-01  \n\n  * 9a54633a src/components/host_micpower/linux-host_micpower.c\n  src/components/infiniband/linux-infiniband.c\n  src/components/nvml/linux-nvml.c...: Components: Use the cuda dlopen fix all\n  cases.  See 4cb76a9b for details, the short version is if you call dlopen\n  when you have been statically linked to libc, it gets ugly.\n\n2013-07-31  \n\n  * dbc44ed1 src/components/perf_event/pe_libpfm4_events.c\n  .../perf_event_uncore/perf_event_uncore.c\n  .../perf_event_uncore/peu_libpfm4_events.c: perf_event libpfm4 events --\n  correctly handle invalid events  It was possible for event names to be\n  obtained from libpfm4 during enumeration that were not valid events.  This\n  usually happens with uncore events, where the uncore is listed as available\n  based on cpuid but when libpfm4 tries to get the uncore type from the kernel\n  finds out it is unsupported.  This change makes this properly fail, instead\n  of just returning \"0\" for all the event paramaters (which is a valid event on\n  x86).  Also make this change in the regular perf_event component, even though\n  it is less likely to happen in practice.\n\n  * 4720890a .../perf_event_uncore/perf_event_uncore.c: perf_event_uncore:\n  remove check_permissions() test  It was trying to see if an EventSet was\n  runnable by using the current permissions and adding the PERF_HW_INSTRUCTIONS\n  event. That doesn't really make sense on uncore.  The perf_event component\n  uses this test to try to give errors early, at set_opt() time rather than at\n  the first run time, although in practice now we can probably make intelligent\n  guesses based on the current permission levels.\n\n  * 113d35f7 .../perf_event_uncore/perf_event_uncore.c: perf_event_uncore:\n  remove unused kernel workarounds  uncore only works on Linux 3.6 or newer so\n  all of the pre-2.6.35 workarounds aren't necessary.  If someone has\n  backported the uncore support to kernels that old, hopefully they've also\n  backported all the other bugfixes too.\n\n2013-07-25  \n\n  * 4cb76a9b src/components/cuda/linux-cuda.c: Trial fix for the cuda component\n  static libc linking issue.  Weak link against _dl_non_dynamic_init, this\n  appears in my limited testing to be in gnu libc.a and not in the so.  For\n  background, it was reported by Steve Kaufmann that statically linking tools\n  with a PAPI library configured with the CUDA component segfaulted. It appears\n  that calling any of the dynamic linker functions from a static executable is\n  asking for pain.  See Trac bug 182\n  https://icl.cs.utk.edu/trac/papi/ticket/182\n\n2013-07-24  \n\n  * ad47cfb9 src/configure src/configure.in: Add linux-pfm-ia64 to configure \n  I'm not sure if this is enough to fix itanium support but it's a start.\n\n  * 098294c5 src/components/example/tests/example_basic.c\n  .../example/tests/example_multiple_components.c: Fixed tests for example\n  component. Both tests failed due to incorrect check of the components PAPI\n  has been configured with.\n\n2013-07-23  \n\n  * c0c4caf4 src/linux-memory.c src/papi_events.csv: Add initial support for\n  IBM POWER8 processor  Add initial support for IBM POWER8 processor  The IBM\n  POWER8 processor (to be publicly announced at some future date) has some\n  preliminary support in libpfm with a subset of native events.  These\n  POWER8-related libpfm changes were pulled into PAPI on July 3, so further\n  updates in PAPI were required to support this new processor.  This patch adds\n  that required support.  NOTE: Due to the fact that only a subset of native\n  events have been publicised at this point (and pushed into libpfm), not all\n  of the usual PAPI preset events have corresponding native events. The rest of\n  the POWER8 native events will be pushed upstream once they are verified, and\n  then we can flesh out the PAPI preset events.  With this initial POWER8\n  support patch, 5 of the ctests and ftests fail, compared to 3 when PAPI is\n  run on a POWER7. At least one of the failing testcases is due to testing\n  being done on an early POWER8 processor with some known hardware problems. We\n  presume the number of failing tests will decrease once we have GA-level\n  hardware to test on. \n\n2013-07-22  \n\n  * 6c231d1a src/configure: Rerun autoconf  for f4ec143e Correct versioning of\n  libpapi.so\n\n  * f4ec143e src/configure.in: Correct versioning of libpapi.so  The configure\n  for linux always set the soname to libpapi.so.  This causes problems when\n  /sbin/ldconfig tries to update the library information on linux.  The shared\n  library is installed as /lib{64}/libpapi.so.$VERSION, but the shared library\n  has the soname of libpapi.so.  ldconfig makes a symbolic link from\n  /lib/libpapi.so to the actual versioned shared library,\n  /lib/{64}/libpapi.so$VERSION. The configure should get the soname correct to\n  avoid creating this symbolic link.  This patch only addresses the issues for\n  some of the possible platforms and similar patches may be needed for other\n  platforms. \n\n2013-07-19  \n\n  * 92356bbd src/papi.c src/threads.c src/threads.h: Attempt to fix a memory\n  leak in fork2 test.  Fork2 does the following: PAPI_library_init() fork(); / \n    \\ parent   child wait()     PAPI_shutdown()\t->\n  _papi_hwi_shutdown_global_threads() -> foreach(threadinfo we allocated):\n  _papi_hwi_shutdown_thread() PAPI_library_init()  _papi_hwi_shutdown_thread\n  checks who allocated a ThreadInfo entry in the global list, and will only\n  free it if our thread did the allocation.  When threading is not initialized,\n  we fall back to getpid(), now in the child process, the one ThreadInfo item\n  on the list was allocated by our parent, so at shutdown time we don't free\n  this, and thus leak it.  Solution is to add a parameter to\n  _hwi_shutdown_thread to force shutdown even if we didn't allocate it. At\n  _papi_hwi_shutdown_global_threads() time, who cares, its closing time.\n\n  * c04d908e src/cpus.c: Fix a deadlock in _papi_hwi_lookup_cpu().  If cpu_num\n  is not found by _papi_hwi_lookup_cpu(), _papi_hwi_initialize_cpu() calls\n  insert_cpu(), which locks CPUS_LOCK, which was already held by\n  _papi_hwi_lookup_cpu().\n\n  * efac24c4 src/components/micpower/linux-micpower.c: micpower: fix return\n  value check  Also add a time check at stop time.\n\n2013-07-16  \n\n  * b9fd9dd1 src/configure src/configure.in: configure: Fix AIX build \n  perfctr_ppc was not the only system that relied on ppc64_events.h, power*.h,\n  and friends. First run at a fix is -Icomponents/perfctr_ppc for the C and F\n  flags...\n\n  * 46042e68 src/components/micpower/linux-micpower.c: micpower: update some\n  indexing code\n\n2013-07-15  \n\n  * 5220e7d2 INSTALL.txt: INSTALL.txt: typo  --with-arch=, not --arch=; Thanks\n  to Karl Schulz for catching this.\n\n  * 207e0ee0 src/papi_libpfm_events.h: papi_libpfm_events: needs include files\n  for types.  Include papi.h and papi_vector.h for papi_vector_t and\n  PAPI_component_info_t\n\n  * d96c01c7 src/components/perfctr/perfctr.c: perfctr: cleanup a warning \n  Include papi_libpfm_events.h for _papi_libpfm_init() decl.\n\n  * 367e1b38 src/components/perfctr/perfctr-x86.c\n  src/components/perfctr/perfctr.c: perfctr: refactor out setup_x86_presets \n  The setup_presets function served only to call _papi_libpfm_init, so we go\n  the rest of the way and completly remove the function, calling\n  _papi_libpfm_init directly from _perfctr_init_component.\n\n  * 1ba38ce5 src/components/perfctr/perfctr-x86.c: perfctr: cleanup unused\n  parameter warning.  The perfctr code was refactored to only call into the\n  table loading code one time. This had the side effect of removing most of\n  what setup_x86_presets does.\n\n  * 02710ced src/configure src/configure.in: configure: remove debugging\n  message  The compiler detection code had a stray AC_MSG_RESULT.\n\n2013-07-12  \n\n  * 028ce29d src/components/lustre/linux-lustre.c: lustre: use whole directory\n  name as event  Gary Mohr reported that on a trial system he was seeing many\n  events of the form fs3-* which were all chopped to fs3, not helpful.  I've\n  not actually been able to figure out exactly how lustre names things, I've\n  seen it described as  <fs>-<uid>  But have no clue what uid promisses.\n\n2013-07-15  \n\n  * 129d4587 src/papi.c: allow more than one EventSet attach to a CPU at a time\n   This is necessary for perf_event_uncore support, as multiple uncores will\n  want to attach to a CPU.  It looks like this change won't break anything, and\n  the tests pass on my test machines.  I am a bit concerned about\n  cpu->running_eventset, though no one seems to use that value...\n\n  * bcda5ddd src/components/perf_event_uncore/tests/Makefile\n  .../tests/perf_event_uncore_nogran.c: perf_event_uncore: remove\n  perf_event_uncore_nogran test  It is unnecessary after recent changes to the\n  uncore component.\n\n  * b1b9f654 src/components/perf_event_uncore/tests/Makefile\n  .../tests/perf_event_uncore_cbox.c: perf_event_uncore: add\n  perf_event_uncore_cbox test  This adds a non-trivial test of the CBOX\n  uncores. It turned up various bugs in the PAPI uncore implementation.\n\n  * df1b6453 src/linux-common.c: linux: properly set hwinfo->socket value  It\n  was being derived from hwinfo->ncpu but being calculated before hwinfo->ncpu\n  was set.\n\n2013-07-13  \n\n  * ee537448 .../perf_event_uncore/perf_event_uncore.c\n  .../perf_event_uncore/peu_libpfm4_events.c\n  .../perf_event_uncore/peu_libpfm4_events.h: perf_event_uncore: properly\n  report number of total counters available\n\n  * 7eb93917 src/components/perf_event/Rules.perf_event\n  src/components/perf_event/pe_libpfm4_events.c\n  src/components/perf_event/pe_libpfm4_events.h...:\n  perf_event/perf_event_uncore/libpfm4 -- rearrange files  Give perf_event and\n  perf_event_uncore copies of papi_libpfm4_events to work with, as they will\n  have different needs for the code.  Get rid of the perf_event_lib stuff.  It\n  was a hack to begin with and in the end not much code will be shared.  Maybe\n  we can re-share things once uncore support is complete.\n\n2013-07-12  \n\n  * 6810af2a src/components/perf_event/perf_event.c\n  .../perf_event_uncore/perf_event_uncore.c src/papi_libpfm4_events.c...:\n  papi_libpfm4: properly call pfm_terminate() in papi_libpfm4_shutdown\n\n  * 010497f4 src/components/perf_event/perf_event.c\n  .../perf_event_uncore/perf_event_uncore.c src/papi_libpfm4_events.c...: split\n  papi_libpfm4_init()  split this function because the perf_event_uncore()\n  component is going to want to initialize things differently than plain\n  perf_event\n\n  * d9023411 src/components/perf_event/perf_event.c: perf_event: on old kernels\n  if SW Multiplex enabled, then report proper number of MPX counters available \n  it may be different than the amount HW supports\n\n  * 7595a840 src/components/perf_event/perf_event_lib.c: perf_event: use\n  PERF_IOC_FLAG_GROUP when resetting events  This ioctl argument specifies to\n  reset all events in a group, so we don't have to iterate.  This argument\n  dates back to the introduction of perf_event and it makes the code a bit\n  cleaner.\n\n  * f220fd19 src/ctests/Makefile src/ctests/reset_multiplex.c: Add\n  reset_multiplex.c  PAPI_reset() potentially exercises different paths when\n  resetting normal and multiplexed eventsets, so make sure we test both.\n\n  * f784a489 src/components/lustre/linux-lustre.c: lustre: botched a conflict\n  resolution  properly do error checking on addCounter()\n\n  * c1350fc8 src/components/perf_event/perf_event.c\n  src/components/perf_event/perf_event_lib.c\n  src/components/perf_event/perf_event_lib.h: perf_event: move overflow and\n  profile code out of common lib  the perf_event_uncore component doesn't need\n  it\n\n  * 8dde03fc .../perf_event_uncore/perf_event_uncore.c: perf_event_uncore:\n  remove profiling and overflow code  perf_event doesn't support sampling or\n  overflow on uncore\n\n  * 30d23636 src/components/lustre/linux-lustre.c: lustre component: Several\n  fixes  1. create a dynamic native events table in pathalogical cases, lustre\n  can have lots of events.  2. resolve some warnings change signature of\n  init_component properly error check addCounter  3. Add a preprocessor flag to\n  fake interface Set LIBCFLAGS=\"-DFAKE_LUSTRE\"\n\n  * 7ef51566 .../perf_event_uncore/perf_event_uncore.c: perf_event_uncore:\n  remove dispatch timer call  perf_event  doesn't support sampling on uncore\n  events\n\n  * 667661c6 src/components/perf_event/perf_event.c\n  src/components/perf_event/perf_event_lib.c\n  src/components/perf_event/perf_event_lib.h: perf_event: move rdpmc detection\n  back into perf_event.c  It was in the perf_event_lib but uncore won't use the\n  feature.\n\n  * d46f01e1 .../perf_event_uncore/perf_event_uncore.c: perf_event_uncore:\n  check the paranoid file  Disable the component if paranoid isn't 0 or lower,\n  and we're not running as root.\n\n  * e4ec67d1 src/components/perf_event/perf_event.c: perf_event and paranoid\n  level 2  If paranoid level 2 (no kernel events) was set we were removing\n  PAPI_DOM_KERNEL from the allowable domains  We were doing this even if the\n  user was root.  This code checks for uid 0 and overrides the restriction.\n\n  * c5501081 src/components/perf_event/perf_event_lib.c\n  src/components/perf_event/perf_event_lib.h: rename sys_perf_event_open2()\n  call back to sys_perf_event_open()  This was changed when merging code to\n  avoid a conflict but wasn't renamed back whe the conflict was fixed.\n\n2013-07-11  \n\n  * e263ea60 src/configure src/configure.in: configure: libpfm selection logic\n  rework  If configure detected perfctr it would force libpfm3 to be used, even\n  with --with-perf_events, now force libpfm4 if perf_events is requested.\n\n2013-07-10  \n\n  * 7a3ce030 .../host_micpower/Makefile.host_micpower.in\n  src/components/host_micpower/Rules.host_micpower\n  src/components/host_micpower/configure...: Component: host_micpower  This is\n  a component that exports power information for Intel Xeon Phi cards (MIC).\n  The component makes use of the MicAccessAPI distributed with the Intel\n  Manycore Platform Software Stack.\n  \n  k-mpss)\n\n  * 9d9bd9c2 src/ctests/shlib.c: Fwd: Re: [Ptools-perfapi] ctests/shlib FAILED \n  Should have sent this to the papi devel list. -Will  -------- Original\n  Message -------- Subject: Re: [Ptools-perfapi] ctests/shlib FAILED Date: Tue,\n  09 Jul 2013 23:20:10 -0400 From: William Cohen <wcohen@redhat.com> To:\n  ptools-perfapi@eecs.utk.edu  On 03/09/2012 03:40 PM, William Cohen wrote: > I\n  was looking through the test results and found that ctests/shlib FAILED on\n  all the machines I tested on because libm shared library is already linked\n  in. There is no difference in the number of shared libraries before and after\n  the dlopen. The test ctests/shlib fails as a reult of this. > > -Will >\n  _______________________________________________ > Ptools-perfapi mailing list\n  > Ptools-perfapi@eecs.utk.edu >\n  http://lists.eecs.utk.edu/mailman/listinfo/ptools-perfapi >  I did some more\n  investigation of this problem today.  I found that the lmsensor component\n  implicitly pulls in the libm.  As an alternative, I wrote the attached patch\n  that uses setkey() and encrypt() in libcrypt.so instead.  It works on various\n  linux machines, but I do not know whether it is going to work on other OS. \n  -Will  >From c53c97e1de2d1c7dc0bca64d1906287ff73343c6 Mon Sep 17 00:00:00\n  2001 From: William Cohen <wcohen@redhat.com> Date: Tue, 9 Jul 2013 22:37:27\n  -0400 Subject: [PATCH] Avoid using libm.so for ctests/shlib because of\n  implicit use in some components  The lmsensors component can implicitly pull\n  in libm.so into the executable.  Unfortunately, the ctests/shlib test expects\n  that libm.so is not loaded and will fail because there is no change in the\n  count of shared libraries.  The patch uses libcrypt.so library setkey and\n  encrypt functions to test PAPI_get_shared_lib_info( ) instead of libm.so\n  library pow function. \n\n2013-07-09  \n\n  * bdc9b34b .../tests/perf_event_amd_northbridge.c:\n  Perf_event_amd_northbridge_test: Use buffer event_name instead of\n  uncore_event  The variable uncore_event is initialized to NULL and is never\n  changed during execution of the test. PAPI_add_named_event fails and the\n  event set cannot be started. The correct event name is stored in event_name,\n  replacing all occurrences of uncore_event with event_name therefore fixes the\n  problem metioned above.\n\n2013-07-08  \n\n  * a1678388 src/components/micpower/linux-micpower.c: micpower:  Fix output in\n  native_avail and component_avail. It uses cmp_info.name, not .short_name? \n  Native Events in Component: mic-power Name:   mic-power              \n  Component for reading power on Intel Xeon Phi (MIC)  Should both match what\n  is prepended to event names, so change .name from mic-power to micpower.\n\n  * e0582f2d src/components/micpower/linux-micpower.c: Micpower: fix a typo \n  subsystem, not sybsystem...\n\n  * c7b357ec INSTALL.txt: INSTALL.txt: update instructions for MIC.\n\n  * 34a1124e src/components/perf_event_uncore/tests/Makefile\n  .../tests/perf_event_amd_northbridge.c: Add perf_event_amd_northbridge test \n  The test should show how to write a program using AMD fam15h NB with a 3.9\n  kernel.  Once libpfm4 gets updated we can see if it's possible to also have\n  the test properly run on 3.10 kernels (in that case the regular\n  perf_event_uncore test should work w/o changes)\n\n  * 41b6507c .../perf_event_uncore/tests/perf_event_uncore.c\n  .../tests/perf_event_uncore_multiple.c: Make perf_event_uncore tests use\n  PAPI_get_component_index()  They were open-coding the component name search\n  for no good reason.\n\n2013-07-05  \n\n  * abf38945 src/papi_libpfm4_events.c: avoid having a \"default\" PMU for the\n  uncore component  on the main CPU component we have a \"default\" PMU where you\n  can leave out the PMU part of the event name.  This is unnecessary and\n  sometimes confusing on uncore, so always print the full event name if it's an\n  uncore PMU.\n\n  * b9fe5c3e .../perf_event_uncore/tests/perf_event_uncore.c\n  .../tests/perf_event_uncore_multiple.c: Update perf_event_uncore tests to\n  properly fail if they don't have enough permissions\n\n  * 32ae1686 .../perf_event_uncore/tests/perf_event_uncore.c:\n  perf_event_uncore_test : properly use uncore component  The sample code was\n  still hardcoding to component \"0\" which shouldn't have worked.  Thanks to\n  Claris Castillo for pointing out this problem.\n\n  * 59e73b51 src/papi_libpfm4_events.c: have _papi_libpfm4_ntv_name_to_code\n  properly check pmu_type  With the existing code, uncore events were being\n  found by the perf_event component even when that component has uncore events\n  distabled.\n\n2013-07-03  \n\n  * a01394eb .../tests/perf_event_uncore_lib.c: perf_event_uncore: fix ivb\n  event in uncore test  Now that libpfm4 officially supports plain ivb uncore,\n  make sure the test event we were using matches what libpfm4 supports.\n\n2013-07-01  \n\n  * f10342a8 src/utils/cost.c: Clean up option handling in papi_cost  The\n  papi_cost used strstr to seach for the substring that matched the option. \n  this is pretty inexact.  Made sure that the options matched exactly and the\n  option argments for -b and -t were greater than 0. Also make papi_cost print\n  out the help if there was an option that it didn't understand. \n\n  * b5adc561 src/utils/native_avail.c: Clean up option handling for\n  papi_native_avail  Corrected the help to reflect the name of the option\n  \"--noumasks\". Print error message if the \"-i\", \"-e\", and \"-x\" option\n  arguments are invalid. Avoid using strstr() for \"-h\", use strcmp instead.\n  Also check for \"--help\" option. \n\n  * 8933be9b src/utils/decode.c: Clean up option handling in papi_decode \n  papi_decode used strstr() to match options; this can lead to inexact matchs.\n  The code should used strcmp instead.  Make sure command name is not processed\n  as an option.  Also print help iformation is some argument is not understood.\n\n  * d94ac43a src/utils/component.c: Improve option matching in papi_component\n  and add \"--help\" option \n\n  * bb63fe5c src/utils/command_line.c: Add options to papi_command_line man\n  page and improve opt handling  Add options mention in the -h to the man page.\n   Also improve the matching of the options. \n\n  * 09059c82 doc/Makefile src/utils/version.c: Add information for papi_version\n  to be complete \n\n  * 4f2eee8c src/configure src/configure.in: add a --disable-perf-event-uncore\n  option to configure\n\n2013-06-29  \n\n  * 901c5cc2 src/components/perf_event/perf_event.c\n  src/components/perf_event/perf_event_lib.c\n  .../perf_event_uncore/perf_event_uncore.c...: remove syscalls.h  it's no\n  longer needed\n\n  * 4d7e3666 src/Rules.perfmon2 src/components/perfmon2/Rules.perfmon2\n  src/components/perfmon2/perfmon.c...: move perfmon modules to their own\n  component directory\n\n  * a7e9c5f1 src/Rules.perfctr src/Rules.perfctr-pfm\n  src/components/perfctr/Rules.perfctr...: move perfctr files to\n  components/perfctr directory  verified that perfctr-x86 still builds and\n  works  perfctr_ppc has all the files to build, but it doesn't work. It looks\n  like no one has tried to build perfctr-ppc for a very very long time.\n\n2013-06-27  \n\n  * e9dec1fd src/ctests/hl_rates.c src/papi.h src/papi_fwrappers.c...: debugged\n  versions of these files\n\n  * e282034e src/utils/native_avail.c: native_avail: Fix parse_unit_mask code \n  Reported by Steve Kaufmann -------------------------- I noticed while\n  developing a new component that the output from papi_native_avail was\n  incorrectly presented for the component. I believe this is because the \":::\"\n  prefix is not being taken into account, so the base event name is interpreted\n  as a unit mask and is prepend with a : before each legitimate unit mask\n  associated with the event. I think this is just now happening because mine is\n  the first component that has unit masks. I have include a fix below. The\n  output of the unit masks by papi_native_avail now appears correctly for my\n  component.  Thanks, Steve\n\n2013-06-26  \n\n  * ff096786 src/ctests/fork2.c: fork2: Return fork2 test to its old\n  functionality  Once upon a time fork2 did: PAPI_library_init() \u2026 if (\n  fork() == 0) PAPI_shutdown() PAPI_library_init() \u2026\n\n2013-06-25  \n\n  * 978d0d3d src/examples/PAPI_add_remove_event.c src/papi.c: Modify\n  PAPI_list_events functionality to match documentation. You can now pass in a\n  NULL event array and a zero count to get back the valid number of events.\n  This can then be used to allocate the array and retrieve the exact number of\n  events. Thanks to Nils Smeds and Alain Miniussi for pointing this out.\n\n  * 13c52402 src/examples/PAPI_add_remove_event.c src/papi.c: Modify\n  PAPI_list_events functionality to match documentation. You can now pass in a\n  NULL event array and a zero count to get back the valid number of events.\n  This can then be used to allocate the array and retrieve the exact number of\n  events. Thanks to Nils Smeds and Alain Miniussi for pointing this out.\n\n  * 656e703e src/ctests/zero_fork.c: zero_fork ctest : make documentation match\n  code\n\n  * 96aad0c7 src/ctests/forkexec.c: forkexec ctest : make comments match code\n\n  * b7c70953 src/ctests/forkexec4.c: forkexec4 ctest : make comments match the\n  code\n\n  * 7ffb0245 src/ctests/forkexec3.c: forkexec3 ctest : make documentation match\n  code\n\n  * 55ea846c src/ctests/forkexec2.c: forkexec2 ctest: have comments match what\n  source does\n\n  * 7a601e2a src/ctests/Makefile src/ctests/fork2.c: fork2 ctest: remove; was\n  an exact duplicate of fork\n\n  * 9deff49b src/ctests/fork.c: fork ctest: make comments match what file\n  actually does\n\n2013-06-24  \n\n  * 2770d2c5 src/components/perf_event/perf_event_lib.c: perf_event: fix\n  failure on ARM due to domain settings  forgot to git add the perf_event_lib.c\n  file :(\n\n  * bf7c4c50 src/components/perf_event/perf_event.c\n  src/components/perf_event/perf_event_lib.h: perf_event: fix failure on ARM\n  due to domain settings  On Cortex A8 and A9 it's not possible to set\n  exclude_kernel (hardware does not support it).  Make sure the rdpmc detection\n  code doesn't try to set exclude_kernel.\n\n2013-06-18  \n\n  * 2b1433d8 src/ctests/all_native_events.c src/ctests/get_event_component.c:\n  ctests: Skip calling into disabled components.  This patch fixes a problem\n  that was causing two test cases to abort when they were run on a system which\n  has disabled components.  Code was added to check if the component is\n  disabled and just go to the next component in the list when the check is\n  true.  This prevents calls to code in components which may abort because the\n  component was unable to initialize itself correctly.  Thanks to Gary Mohr and\n  Chuck LaCasse from Bull for reporting.\n\n2013-06-14  \n\n  * 1872453c src/testlib/do_loops.c: testlib: don't change the iter count  The\n  first argument to do_misses is an iteration count, for some reason the code\n  was dividing this in half before doing work. Most places that call do_misses\n  call it as do_misses ( 1, ...)  void do_misses( int n, int bytes ) { {...} n\n  = n / 2; for ( j = 0; j < n; j++ ) {  1/2 == 0; so our do_misses call was\n  usually not.  Thanks Nils Smeds for reporting.\n\n2013-06-12  \n\n  * c113e5b6 src/components/infiniband/Makefile.infiniband.in\n  src/components/infiniband/Rules.infiniband\n  src/components/infiniband/configure...: Infiniband component: switch over to\n  weak linking  Thnaks to Gary Mohr for the patch.\n  ---------------------------------- The infiniband component needs include\n  files and libraries from both the infiniband ibmad and ibumad packages.  When\n  these packages are installed on a system, both packages normally install\n  their files in the same place (includes in /usr/include/infiniband and\n  libraries in /usr/lib64).  The current component configure script allows you\n  to provide a single include path and a single library path which gets used to\n  access files from both packages.  If these two packages have different\n  install prefixes (or you are trying to build from install images of each\n  package which are not located under the same directory) then the configure\n  script fails because it can not find all the files it needs.  These changes\n  modify the configure script to replace the include and library dir's with an\n  ibmad_dir and ibumad_dir and then uses the correct packages directory when\n  looking for includes and libraries from that package.  This makes it work\n  like the cuda and nvml components with respect to configuring how to find\n  files from a package the component depends on.  There are also changes in\n  this patch file to remove an unneeded variable in the dlopen code to resolve\n  some defects reported by coverity.\n\n2013-06-11  \n\n  * d5be5643 src/components/rapl/tests/rapl_basic.c: rapl tests: make the error\n  messages a little more verbose\n\n  * 0c9f1a8c src/run_tests_exclude.txt src/run_tests_exclude_cuda.txt:\n  run_tests_exclude files: Exclude a template file \n  ------------------------------------------- It also adds the cpi.pbs file to\n  the list of files to excluded when the tests are run. This file is just a\n  template and attempts to run it hang the run_tests script on our systems.\n  -------------------------------------------\n\n  * 0a063619 src/run_tests.sh: run_tests.sh: fix exclude check.  The script\n  failed to remove .cu files, this patch fixes the check. Thanks Gary Mohr for\n  reporting/patching.\n\n2013-06-10  \n\n  * 87399477 src/components/cuda/linux-cuda.c: cuda component: Address a\n  coverity issue  The library linking code saved return values in a local var\n  but never used them. Thanks to Gary Mohr for submitting this patch.\n\n  * 99b5b685 src/components/coretemp/tests/coretemp_basic.c: coretemp_basic:\n  update test to properly enumerate events  The code was old and was searching\n  the entire native event list for ones that started with \"hwmon\".  This\n  updates the test to first find the coretemp component, then enumerate all\n  events contained within.\n\n  * b5c0795b src/components/rapl/tests/rapl_overflow.c: rapl component: address\n  potential looping issue in test.  A rapl component test has a do/while which\n  only exited when PAPI_add_named_event returned 0 ( and only 0; the PAPI_E*\n  error codes would not terminate a while( retval ) loop), this felt fragile,\n  minimal checks are now inplace.\n\n  * 4e9484a5 src/components/rapl/tests/rapl_overflow.c: rapl components:\n  coverity fixes  Reported/patched by Gary Mohr -----------------------------\n  The rapl component also has 1 defect in a test case.  The complaint is that\n  there is code that can never be executed.  But this one is not as clear, it\n  says that you can not exit the do/while loop that preceeds a test of retval\n  until retval=0 which means the test can never be true.  The patch I am\n  providing is to again remove the if test and its contents.  But I am\n  concerned that the do/while loop preceeding the test could result in a hard\n  loop that would hang the test case forever.  It seems to me like something\n  should also be done to insure the loop will exit at some point.  Here is a\n  patch that provides at least part of the fix: -----------------------------\n\n  * 0a533810 src/components/net/tests/net_values_by_name.c: net components:\n  coverity fixes  Reported/patched by Gary Mohr -----------------------------\n  The net component has one defect in one of the test cases.  The complaint is\n  that there is code that can never be executed.  There is a test to see if\n  event_count == 0 which can never be true at that place in the code.  So I\n  removed the if statement and its contents.  Here is the patch:\n  -----------------------------\n\n2013-06-07  \n\n  * b784b063 src/components/nvml/Rules.nvml src/components/nvml/configure\n  src/components/nvml/configure.in...: nvml: Apply Gary Mohr's dlopen patch. \n  Move the nvml component over to using the dlopen and weak linking\n  infrastructure of the cuda component. Thanks, Gary.\n\n  * d6505b76 src/components/rapl/utils/rapl_plot.c: rapl: update the rapl_plot\n  utility  Get the event names by enumerating the ones available with the RAPL\n  component rather than having a hard-coded list.\n\n  * 2094c5b1 src/components/rapl/linux-rapl.c: rapl: add better error messages\n  on component init failure\n\n  * d0e668fb src/ctests/Makefile src/ctests/high-level.c\n  src/ctests/hl_rates.c...: First round of changes to implement a PAPI high\n  level event per cycle call. Untested.\n\n2013-06-05  \n\n  * 63074f82 src/components/rapl/linux-rapl.c: rapl: Add Ivb-EP support  The\n  Intel docs are spotty on what is actually supported. They state: 14.7.2 RAPL\n  Domains and Platform Specificity The specific RAPL domains available in a\n  platform varies across product segments. Platforms targeting client segment\n  support the following RAPL domain hierarchy: * Package * Two power planes:\n  PP0 and PP1 (PP1 may reflect to uncore devices) Platforms targeting server\n  segment support the following RAPL domain hierarchy: * Package * Power plane:\n  PP0 * DRAM\n\n2013-05-31  \n\n  * 31b4702d src/cpus.c: cpus.c: Don't run init_thread/shutdown_thread for\n  disabled components.\n\n2013-05-29  \n\n  * c48087d2 ChangeLogP511.txt RELEASENOTES.txt: Grab the updated ChangeLog\n  from 5.1.1  Create a ChangeLog and update RELEASENOTES for a 5.1.1 release.\n\n2013-05-24  \n\n  * d1c8769e src/components/perf_event/tests/Makefile\n  src/components/perf_event/tests/event_name_lib.c\n  .../perf_event/tests/perf_event_user_kernel.c: Add perf_event user/kernel\n  domain test  This will be useful if/when we start handling domains properly.\n\n  * 89e1aeba src/components/perf_event/tests/Makefile\n  src/components/perf_event/tests/event_name_lib.c\n  src/components/perf_event/tests/event_name_lib.h...: Add perf_event offcore\n  response test  Does a quick check to see if offcore response events are\n  working.\n\n  * bda86616 .../perf_event_uncore/perf_event_uncore.c\n  src/ctests/get_event_component.c src/papi_internal.c: Some more ctest fixes\n  involving disabled components.  We enforce disabled components sometime in\n  the PAPI routines and sometimes in the components themselves.  A bit\n  confusing.  It is tough with perf_event and perf_event_uncore because we\n  share libpfm4 by both, so the naming library for perf_event_uncore will be\n  active even if the component is disabled, which can cause some confusing\n  results if your test code ignores PAPI_ENOCMP error messages and accesses a\n  disabled component anyway.  This at least fixes our test cases, we might have\n  to revisit this later.\n\n  * b596621e doc/Doxyfile-common papi.spec src/Makefile.in...: Bump version\n  numbers  Call this 5.2.0.0 simple because its greater than (and some\n  components are completely incompatible with) 5.1.1\n\n  * eb77a91e .../perf_event_uncore/perf_event_uncore.c src/papi.c: Disallow\n  enumerating events on disabled components.  This was causing segfaults on\n  tests where enumeration was trying to enumerate uncore events on machines w/o\n  uncores.\n\n  * 4e991a8a .../perf_event/tests/perf_event_system_wide.c:\n  perf_event_system_wide: SKIP instead of FAIL if we don't have proper\n  permissions\n\n  * 7654bb1f src/Makefile.inc src/components/perf_event/tests/Makefile\n  .../perf_event/tests/perf_event_system_wide.c...: move the perf_event\n  specific tests to be with their component  This means the perf_event tests\n  will only be run if perf_event is enabled\n\n  * d82e343f src/ctests/perf_event_uncore_multiple.c:\n  ctests/perf_event_uncore_multiple: Improve this test a bit\n\n  * b1a594bf src/perf_events.c src/sys_perf_event_open.c: Remove the no-longer\n  needed perf_events files  Now we use the versions in the\n  components/perf_event directory\n\n  * a9a277f3 src/Makefile.in src/Makefile.inc src/configure...: Split up\n  CPUCOMPONENT configure variable  Now it is CPUCOMPONENT_NAME CPUCOMPONENT_C\n  CPUCOMPONENT_OBJ This allows having setups with no CPUCOMPONENT set\n  (perf_event used as a component) while keeping backward compatible with\n  non-component CPU components.  This has been tested on perf_event and\n  perfctr.  It might break other architectures, so test if you can.\n\n  * 69e29526 src/configure src/configure.in: configure: have --with-components\n  append comonents to existing value  This allows configure to earlier set the\n  components value to include \"perf_event\" if detected and then later append\n  the values passed in with --with-components\n\n  * 9d28df4c src/components/perf_event/Rules.perf_event\n  src/components/perf_event/perf_event.c\n  src/components/perf_event/perf_event_lib.c...: add perf_event and\n  perf_event_uncore components  This adds perf_event as a standalone component.\n  Currently it is not compiled or built, some changes need to be made to the\n  build system before this will work.\n\n2013-05-21  \n\n  * ea996661 src/components/cuda/linux-cuda.c: eliminate warnings of unused\n  vars\n\n  * 691bf114 src/components/cuda/linux-cuda.c: eliminate warnings of unused\n  vars\n\n  * 221bfdab src/components/cuda/linux-cuda.c\n  src/components/cuda/tests/HelloWorld.cu: Problem with cleanup_eventset():\n  after destroying the CUDA eventset, update_control_state() is called again\n  which operates on the already destroyed eventset.\n\n2013-05-17  \n\n  * 84925f50 src/components/cuda/linux-cuda.c: When adding multiple CUDA events\n  to an event set, PAPI_add_event() error 14 (CUPTI_ERROR_NOT_COMPATIBLE) is\n  being raised from the CUPTI library.  Turns out that the CUDA update control\n  state wasn't cleaning the event set up properly before adding new events.\n  It's fixed now.\n\n  * 2337aa3a src/perf_events.c: perf_event: allow running with\n  perf_event_paranoid is 2  perf_event_paranoid set to 2 means allow user\n  monitoring only (no kernel domain).  The code before this mistakenly disabled\n  all events in this case. Also set the allowed domains to exclude\n  PAPI_DOM_KERNEL.\n\n2013-05-16  \n\n  * 617d9fbb src/papi_events.csv: papi_events.csv Revert a little mishap in\n  adding ivbep support  Somehow the contents of papi_hl.c ended up in the\n  events file.\n\n  * 2aff4596 src/papi_events.csv: Add identifier for ivb_ep\n\n  * 1810ddf9 src/papi_libpfm4_events.c src/papi_libpfm4_events.h\n  src/perf_events.c: papi_libpfm4_events: allow specifying\n  core/uncore/os_generic PMUs  This allows you to specify you only want your\n  perf_event/libpfm4 based component to only export the PMU types you want. \n  Now we can have an uncore-only component.\n\n  * 6554f3f0 src/papi_libpfm4_events.c: papi_libpfm4_events.c: only enable\n  presets for component 0  If we have multiple events using libpfm4, we only\n  want to load the presets if it is component 0.\n\n  * 6a4a4594 src/papi.c: PAPI_get_component_index() was matching names\n  improperly  For example, it was matching perf_event and perf_event_uncore as\n  the same component.\n\n  * 1b94e157 src/papi_hl.c: papi_hl.c : fix IPC calculation  I broke it a while\n  back while trying to clear out use of MHz.  The code was uncommented and very\n  confusing.  It is slightly better now.\n\n  * 92d4552e src/papi_libpfm4_events.c src/papi_libpfm4_events.h\n  src/perf_events.c: papi_libpfm4_events: code changes to allow multiple\n  component access  the PAPI libpfm4 code has been modified to allow multiple\n  users at once.  This will allow multiple components to use libpfm4, for\n  example a CPU component and an uncore component.\n\n  * 7902b30e src/cpus.c: cpus: fix debug compile  I always forget to compile\n  with --with-debug and miss changes in the DEBUG statements.\n\n2013-05-15  \n\n  * 7ddc05ff src/cpus.c src/cpus.h: cpus.c: Add reference count to cpu\n  structure  It is possible to have multiple eventsets all attached to the same\n  CPU, as long as only one eventset is running at a time.  At EventSet cleanup,\n  PAPI would free the CpuInfo_t structure even if other EventSets were still\n  using it.  This patch adds a reference count to the structure and only frees\n  it after the last user is cleaned up.  I also fixed a few locking bugs,\n  hopefully I didn't introduce any new ones.\n\n  * 6a61f9a2 src/cpus.c: more cleanup of the cpus.c file  mostly formatting and\n  added comments.\n\n  * 710d269f src/cpus.c src/cpus.h src/papi.c...: cleanup cpus.h  It had a lot\n  of extraneous stuff in it.  Also make sure it only gets included in files\n  that need it.\n\n  * 422226c9 src/papi.c: papi.c: add some extra debug messages\n\n  * b1297058 src/cpus.c: Clean up cpus.c a bit  Tracking down a segfault in the\n  cpu attach cleanup code.\n\n  * 7b6023cf src/ctests/perf_event_system_wide.c:\n  ctests/perf_event_system_wide: much improved output  It segfaults at the end\n  though, unclear if this is a bug in the test or a bug in PAPI.  Will\n  investigate.\n\n  * 38397aa3 src/components/cuda/configure src/components/cuda/configure.in\n  src/components/cuda/linux-cuda.c...: Cuda component: Update library search\n  path  From Gary Mohr: It turns out that with the changes I gave you the path\n  to the libcuda.so library is still hard coded to /usr/lib64.  This assumes\n  that the NVIDIA-Linux package is installed on the system where the build is\n  being done.  In Bull's case (and probably other users also) this is not\n  always the case.  To add the flexibility we need, I have added a new\n  configure argument to the cuda configure script.  The new argument is\n  \"--with-cudrv_dir\" and it allows the user to specify where the cuda driver\n  package (ie: NVIDIA-Linux) to be used for the build can be found.  This new\n  argument is optional and if not provided a value of \"/usr\" will be used. This\n  allows existing configure calls to continue to work like before.\n\n  * f8873d1c src/ctests/perf_event_system_wide.c:\n  ctests/perf_event_system_wide: clean up the output a lot  Still working on\n  understanding it.\n\n  * ebf20589 src/ctests/perf_event_system_wide.c: perf_event_system_wide:\n  testing various DOMAIN and GRANULARITY settings  pushing the limits of\n  PAPI/perf_event trying to see why system-wide measurement doesn't work.\n\n2013-05-14  \n\n  * 0c1ef3f5 src/components/cuda/linux-cuda.c: CUDA component: Update\n  description field  Also removes a strcpy in the init code, which overwrote\n  the name field. Thanks to Gary Mohr\n\n  * 474fc00e src/ctests/perf_event_uncore_lib.c: Add AMD fam15h northbridge\n  event to ctests/perf_event_uncore_lib.c\n\n2013-05-13  \n\n  * cf56cdac src/perf_events.c: perf_event component: update error returns \n  This passes more error return values back to PAPI. Before this change a lot\n  of places were hardcoded to PAPI_EPERM even if sys_perf_event_open() was\n  reporting a different error.\n\n  * c824471b src/ctests/Makefile src/ctests/perf_event_system_wide.c\n  src/ctests/perf_event_uncore.c...: Update the perf_event specific tests. \n  This adds a few more uncore tests, which are currently showing some bugs in\n  the implementation.  The tests all need root permissions to run, so should\n  default to \"SKIPPED\" for most users.\n\n2013-05-08  \n\n  * e0204914 src/configure src/configure.in: Force the use of pthread_mutexes\n  on ARM  This lets the system libraries worry about the best way to define\n  mutexes, rather than trying to hand-code in assembly around all of the\n  various issues there are with atomic instructions in the ARM architecture. \n  It might make sense to enable this for *all* Linux architectures, but for now\n  just do it for ARM.\n\n  * f21b1b27 src/linux-lock.h: Commit 59d3d7584b2925bd05b4b5d0f4fe89666eb8494a\n  removed the definition of mb().  mb() was defined as rmb().  This just\n  corrects it back.   (Note from VMW -- this fixes some things, but ARM still\n  won't build on a Cortex A9 pandaboard due to the use of the \"swp\"\n  instruction. Proper fix is probably to enforce posix-mutexes on ARM)\n\n2013-05-06  \n\n  * 913f0795 src/components/nvml/configure src/components/nvml/configure.in:\n  NVML: Update wording for configure options.  Thanks for pointing out the\n  ambigous wording, Heike.\n\n  * 81a86c2b src/components/infiniband/Rules.infiniband\n  src/components/infiniband/linux-infiniband.c\n  src/components/infiniband/tests/Makefile: Infiniband component: use\n  dlopen/dlsym for symbols  Apply Gary Mohr's patch to switch the infiniband\n  component over to dl* with the same motivations as the cuda component.\n\n2013-05-02  \n\n  * 2e6bcb2a src/utils/native_avail.c: Add two command line switches: -i\n  EVENTSTR includes only events whose names contain EVENTSTR; -x EVENTSTR\n  excludes all events whose names contain EVENTSTR.  These two switches can be\n  combined, but only one string per switch can be used. This allows you to, for\n  example, filter events by component name, or eliminate all uncore events on\n  Sandy Bridge\u2026\n\n2013-05-01  \n\n  * 3163cc83 src/ctests/perf_event_uncore.c: ctests/perf_event_uncore: add\n  IvyBridge support  this needs an updated libpfm4 to work\n\n2013-04-30  \n\n  * 55c89673 src/examples/add_event/Papi_add_env_event.c\n  src/examples/overflow_pthreads.c: Examples: Missed two instances of %x printf\n  formating.\n\n2013-04-29  \n\n  * b3c5bd47 src/components/appio/tests/appio_list_events.c\n  src/components/appio/tests/appio_values_by_code.c\n  src/components/appio/tests/appio_values_by_name.c...: Address TRAC 174: Let\n  printf do the formatting  https://icl.cs.utk.edu/trac/papi/ticket/174 174:\n  PAPI's debuggin/info output should use %# conversions for octal and hex\n  ------------------------+-------------------- Reporter:  sbk@\u2026        |    \n   Owner: Type:  enhancement  |     Status:  new Priority:  normal       | \n  Component:  All Version:  HEAD         |   Severity:  normal Keywords:       \n         | ------------------------+-------------------- Email sent to James\n  Ralph:  Seeing your latest change reminded me: Anytime there is a value\n  issued in hex or octal the \"%#\" conversion should be used so the value is\n  always preceded with a \"0\" for octal or a \"0x\" for hex. Otherwise when a\n  value is printed one can not tell the base it is in (one shouldn't have to\n  rely on internal knowledge of the code or the context to tell). For variables\n  that are pointers the \"%p\" conversion can be used (this will always use an\n  hex syntax).  It would be nice to apply this to all PAPI print statements in\n  their entirety.\n\n2013-04-25  \n\n  * 87ec9286 src/components/vmware/Rules.vmware: Rules.vmware: Use $(LDL) no\n  -ldl  Minor cleanup, but configure sets it, so why not use it.\n\n2013-04-26  \n\n  * 8dddd587 src/papi_hl.c: papi_hl: Use PAPI_get_virt_usec() for process time \n  The code was using cycles / MHz which is not guaranteed to work on modern\n  machines.  It also was sometimes using (instructions / estimated IPC) / MHz\n  which hopefully isn't necessary for any machine PAPI currently supports. \n  Instead use PAPI_get_virt_usec() which should give the right value.\n\n2013-04-25  \n\n  * 9dd36088 src/ctests/perf_event_uncore.c: ctests/perf_event_uncore: make\n  more modular  Cleans up the code to make it easier to add tests for\n  architectures other than SandyBridge-EP.  I was doing this so I could add\n  support for IvyBridge but it turns out neither Linux nor libpfm4 supports\n  uncore on IvyBridge yet.  hmmm.\n\n  * 52ff0293 src/components/cuda/Rules.cuda: Rules.cuda:  The cuda component\n  now depend on the dynamic linking loader and on some systems one has to\n  explicitly link to it.  Add $(LDL) to LD_FLAGS, configure sets it if we need\n  it.\n\n  * 97a4a5ea src/components/cuda/Rules.cuda src/components/cuda/linux-cuda.c\n  src/components/cuda/tests/Makefile: Cuda component enhancement. \n  ---------------- From Gary's submission--------------------------------- The\n  current packaging of the cuda component in PAPI has a fairly unfriendly side\n  effect.  When PAPI is built with the cuda component, then that copy of PAPI\n  can only be used on systems where the cuda libraries are installed. If it is\n  installed on a system without these libraries then all PAPI services fail\n  because they have references to libraries which can not be found.  Even\n  papi_avail which you would think has nothing to do with cuda reports the\n  error.  This issue significantly complicates the delivery and install of the\n  PAPI package on large clusters where some of the nodes have NVIDIA GPU's (and\n  the cuda libraries to talk to them) and other nodes do not have GPU's (and\n  therefore no software to access them).  I have been working with the help of\n  Phil Mucci to eliminate this dependency so that a copy of PAPI built with a\n  cuda component could be installed on all nodes in the cluster and if the node\n  had NVIDIA GPU's (and libraries available) then the cuda component would get\n  enabled and could be used.  If the node did not have the hardware or the\n  access libraries were not available, then the cuda component would just\n  disable itself at component initialization so it could not be used (but all\n  other PAPI services would still work).  Phil has provided some gentle\n  prodding and lots of valuable suggestions to assist this effort.  I now think\n  that I have a working version of this capability and am ready to share it\n  with the community.\n  -----------------------------------------------------------------------  Many\n  thanks to Gary Mohr and Phil Mucci for this much needed functionality.\n\n2013-04-23  \n\n  * 99c8e352 src/papi_internal.c: papi_internal.c: Print an eventcode in hex vs\n  decimal.  Thanks, Gary Mohr.\n\n2013-04-22  \n\n  * 1fc5dae2 src/run_tests.sh: The test for determining whether to run valgrind\n  was backwards. Correcting that allow the run_test.sh script to stay the same\n  and one just needs to define \"VALGRIND=yes\" (or any non-null string) to make\n  run_test.sh use valgrind.  --- src/run_tests.sh | 6 ++---- 1 file changed, 2\n  insertions(+), 4 deletions(-)  diff --git a/src/run_tests.sh\n  b/src/run_tests.sh index d1ce205..9337ff2 100755 --- a/src/run_tests.sh +++\n  b/src/run_tests.sh @@ -19,10 +19,8 @@ else export TESTS_QUIET fi  -if [\n  \"x$VALGRIND\" = \"x\" ]; then -# Uncomment the following line to run tests using\n  Valgrind -# VALGRIND=\"valgrind --leak-check=full\"; -    VALGRIND=\"\"; +if [\n  \"x$VALGRIND\" != \"x\" ]; then +    VALGRIND=\"valgrind --leak-check=full\"; fi \n  #CTESTS=`find ctests -maxdepth 1 -perm -u+x -type f`; --\n\n2013-04-19  \n\n  * 4cf16234 src/components/README src/components/bgpm/README\n  src/components/coretemp_freebsd/README...: Restructure README files for\n  components so that the file in the components directory doesn't document\n  individual component details. Add README files to each component directory\n  that requires further installation detail. Update RAPL instructions to\n  capture how to enable reading the MSRs. These files are supposedly configured\n  with Doxygen markup, but I don't think the master README ever got built. It\n  probably should.\n\n2013-04-17  \n\n  * bf75d226 src/components/cuda/tests/HelloWorld.cu: cuda/tests/HelloWorld.cu:\n  workaround a segfault.  Report from Gary Hohr\n  \n   I was running the Cuda test case on a system which did not actually have any\n  NVIDIA GPU's installed on it (but the cuda software was installed and papi\n  was built with the cuda component).  I modified the test case to put an real\n  cuda event in the source (as suggested in the source).  When I run the test\n  case the cuda component gets disabled in PAPI_library_init (because\n  detectDevice function can not find any GPU's) which is the correct behavior.\n  The test case then calls PAPI_event_name_to_code which failed because the\n  cuda component was disabled.  The test case then created an event set and\n  called PAPI_add_events with an empty list of events to be added.  This led to\n  a segfault somewhere inside libpfm4.  The attached patch makes some minor\n  changes to protect against this problem.  I noticed this test case does not\n  use the PAPI test framework utilities (test_xxxx functions) so I did not\n  modify the test to use them.\n\n2013-04-15  \n\n  * 457bfd74 src/components/cuda/linux-cuda.c: When creating two event sets -\n  one for the CUDA and one for the CPU component  - the order of event set\n  creation appears crucial. When the CPU event set has been created before the\n  CUDA event set then PAPI_start() for the CUDA event set works fine. However,\n  if the CUDA event set has been created before the CPU event set, then\n  PAPI_start(CUDA_event_set) forces the CUDA control state to be updated one\n  more time, even if the CUDA event set has not been modified. The CUDA control\n  state function did not properly handle this case and hence cause PAPI_start()\n  to fail. This has been fixed.\n\n  * 807120b6 src/components/cuda/linux-cuda.h: linux-cuda.c\n\n2013-03-28  \n\n  * 7b0eec7a src/run_tests.sh: run_tests.sh: further refine component test find\n   Exclude *.cu when looking for component tests.\n\n2013-03-25  \n\n  * 6a40c8ba src/run_tests.sh: run_tests.sh: File mode changes.  run_tests.sh\n  is now expected to run from the install location in addition to src. The\n  script tried to remove execute from *.[c|h], now it just excludes *.[c|h]\n  from the find commands.\n\n2013-03-18  \n\n  * 2ba9f473 src/perfctr-x86.c: perfctr: don't read in event table multiple\n  times  papi_libpfm3_events.c now reads in the predefined events, we don't\n  also need to do this in perfctr setup_x86_presets()\n\n  * 326401b1 src/perfctr.c: Fix segfault in perfctr.c  The preset lookup uses\n  the cidx index, but in perfctr.c we weren't passing a cidx value (it was\n  being left off).  The old perfctr code plays games with defining extern\n  functions so the compiler wasn't giving us a warning.\n\n2013-03-14  \n\n  * 50130c6f src/components/bgpm/L2unit/linux-L2unit.c src/linux-bgq.c: If a\n  counter is not set to overflow (threshold==0; happens when PAPI_shutdown is\n  called) then we do not want to rebuild the BGPM event set, even if the event\n  set has been used previously and hence \"applied or attached\". Usually if an\n  event set has been applied or attached prior to setting overflow, the BGPM\n  event set needs to be deleted and recreated (which implies malloc() from\n  within BGPM). Not so, though, if threshold is 0 which is the case when\n  PAPI_shutdown is called.  Note, this only applies to Punit and L2unit, not\n  IOunit since an IOunit event set in not applied or attached.\n\n2013-03-13  \n\n  * 1a143003 src/components/bgpm/IOunit/linux-IOunit.c\n  src/components/bgpm/IOunit/linux-IOunit.h\n  src/components/bgpm/L2unit/linux-L2unit.c...: Overflow issue on BG/Q\n  resolved. Overflow with multiple components worked; overflow with multiple\n  components and multiple events did not work as supposed to.\n\n  * 42741a40 src/components/cuda/Rules.cuda: Added one more library to linker\n  command.\n\n2013-03-12  \n\n  * 1431eb3f src/components/nvml/Makefile.nvml.in\n  src/components/nvml/Rules.nvml src/components/nvml/configure...: NVML\n  component: build system work  Adopt the cuda component's method for\n  specifying library location.\n\n2013-03-11  \n\n  * ce66feac src/components/mx/linux-mx.c: mx component: Modernize init\n  routine.  Add component index to _mx_component_init()s signarure and set the\n  bit in component info.\n\n  * 1c1bc177 src/components/cuda/Makefile.cuda.in\n  src/components/cuda/Rules.cuda src/components/cuda/configure...: Resolve\n  configure issues for CUDA component.\n\n2013-03-07  \n\n  * f3572537 src/linux-common.c src/linux-memory.c: Fix the build on\n  Linux-SPARC  I dug out an old SPARC machine and fixed the PAPI build on it.\n\n  * 2c7f102c src/perf_events.c: More comprehensive sys_perf_open to PAPI error\n  mappings  This tries to cover more of the errors returned by sys_perf_open\n  and map them to better results.  EINVAL is a problem because it can mean\n  Conflict as well as Event not found and many other things, so it's unclear\n  what to do with it.\n\n  * 299070ef src/perf_events.c src/sys_perf_event_open.c: Return proper error\n  codes for sys_perf_event_open  For some reason on x86 and x86_64 we were\n  trying to set errno manually and thus over-writing the proper errno value,\n  causing all errors to look like PAPI_EPERM  This removes that code, as well\n  as adds code to report ENOENT as PAPI_ENOEVENT.  With this change, on IVY\n  this happens which looks more correct.  ./utils/papi_command_line\n  perf::L1-ICACHE-PREFETCHES Failed adding: perf::L1-ICACHE-PREFETCHES because:\n  Event does not exist command_line.c                       PASSED\n\n2013-03-06  \n\n  * baa557ca src/papi_libpfm4_events.c src/papi_user_events.c: Coverity fixes: \n  Coverity pointed out that there was a case where load_user_eent_table() could\n  leak memory.  The change in the location of the papi_free(foo) ensures that\n  the allocated memory is freed.  Coverity pointed out one path through the\n  code in _papi_libpfm4_ntv_code_to_descr() that did not free up memory\n  allocated in the function.  Added a free on the path in free up that memory. \n  Thanks Will Cohen.\n\n2013-02-14  \n\n  * 395b7bc7 src/Makefile.inc src/components/README\n  src/components/appio/tests/Makefile...: Add component tests' to the\n  install-[all|tests] target.  Thanks to Gary Mohr. ------------------- This\n  makes a fairly small change to src/Makefile.inc to add logic that adds a new\n  install-comp_tests target which calls the install target for each component\n  being built. This new target is listed as a dependency on the install-tests\n  target so it will happen when the 'install-all', 'install-tests', or\n  'install-comp_tests' targets are used. A note about this change, I am not\n  real familiar with the auto make and auto conf tools. This change was enough\n  to make it work for me but if there is another file that should also be\n  changed for this modification, please help me out here.  The patch also adds\n  install targets to the Makefiles for all of the components which have 'tests'\n  directories and updates the README file which talks about how to create\n  component tests.  Another note, I only compile with a couple of components\n  (ours, rapl, and example) so if I fat fingered something in one of the other\n  components Makefiles I would not have noticed. Please keep me honest and make\n  sure you compile with them all enabled.  Thanks for adding this capability\n  for us. Gary ---------------------------  Makefile.inc: Add run_tests and\n  friends to install-tests target.  Component test Makefiles' get their install\n  location to mirror what runtests expects.\n\n2013-03-04  \n\n  * 448d21ab src/components/rapl/linux-rapl.c: Remove a stray debug statement.\n  Thanks to Harald Servat for catching this.\n\n2013-03-01  \n\n  * df1a75cc src/utils/command_line.c: Wrestled some horribly convoluted\n  indexing into shape. The -u and -x options now print as expected (I think).\n\n2013-01-31  \n\n  * b0f5f4d6 src/components/nvml/linux-nvml.c: linux-nvml.c: Fix type warning. \n  CUDA and NVML have an signed vs unsigned thing going on in their returned\n  device counts, cast away the warning.\n\n2013-01-29  \n\n  * 8490b4ee src/papi.c: General doxygen cleanup: remove all \"No known bugs\"\n  messages; correct and cleanup examples for PAPI_code_to_name and\n  PAPI_name_to_code\n\n2013-01-23  \n\n  * 89e45a9b src/linux-memory.c src/linux-timer.c: ia64 fixes.  Thanks to Tony\n  Jones <tonyj@suse.de> for patches.\n\n2013-01-16  \n\n  * 23e0ba2d src/components/nvml/linux-nvml.c: nvml component: cleanup a memory\n  leak  We did not free a buffer at shutdown time.\n\n2013-01-15  \n\n  * f3db85fc src/papi.h: papi.h bump version number.\n\n  * dfa80287 src/buildbot_configure_with_components.sh: Buildbot configure\n  script.  Add cuda and nvml components, if configured, to the buildbot\n  coverage test. Note: Script now checks for existance of Makefile.cuda and\n  then Makefile.nvml so see if it can build the cuda component and then if it\n  can build the nvml component.\n\n  * cf416e27 src/threads.c: Cleaned up compiler warning (gcc version 4.4.6)\n\n  * 59cbc8fc src/components/bgpm/CNKunit/linux-CNKunit.c\n  src/components/bgpm/IOunit/linux-IOunit.c\n  src/components/bgpm/L2unit/linux-L2unit.c...: Cleaned up compiler warnings on\n  BG/Q (gcc version 4.4.6 (BGQ-V1R1M2-120920))\n\n2013-01-14  \n\n  * 3af71658 .../build/lib.linux-x86_64-2.7/perfmon/__init__.py\n  .../lib.linux-x86_64-2.7/perfmon/perfmon_int.py\n  .../build/lib.linux-x86_64-2.7/perfmon/pmu.py...: libpfm4: remove extraneous\n  build artifacts.  Steve Kaufmann reported differences between the libpfm4 I\n  imported into PAPI and the libpfm4 that can be attained with a git clone\n  git://perfmon2.git.sourceforge.net/gitroot/perfmon2/libpfm4  Self: Do libpfm4\n  imports from a fresh clone of libpfm4.\n",
        "/tmp/vanessa/spack-stage/spack-stage-papi-6.0.0.1-gmm3tef6bggycxgzrtmq2ejaggc2ozfb/spack-src/ChangeLogP600.txt": "2020-02-27  Steven Kaufmann <steven.kaufmann@hpe.com>\n\n\t* src/components/infiniband/tests/Makefile: Making MPI tester\n\t  optional\n\n2020-02-22  Frank Winkler <frankbook@Franks-MacBook-Air.local>\n\n\t* src/papi_fwrappers.c: Added fortran wrappers for PAPI_rate_stop and\n\t  PAPI_hl_stop. Also fixed doxygen documentation for PAPI_flops_rate.\n\n2020-02-21  Anthony Castaldo <TonyCastaldo@icl.utk.edu>\n\n\t* src/components/rocm/tests/square.cpp,\n\t  src/components/rocm/tests/square.cu,\n\t  src/components/rocm/tests/square.hipref.cpp,\n\t  src/components/rocm_smi/linux-rocm-smi.c: Deleted test files from\n\t  the repository, and commented-out debug lines from rocm_smi.\n\t* src/components/rocm/linux-rocm.c,\n\t  src/components/rocm/tests/Makefile,\n\t  src/components/rocm/tests/rocm_all.cpp: Added patches provided by\n\t  Evgeny Shcherbakov (AMD), and corrected bugs in rocm_all.cpp.\n\t  Tested and now functions as expected.\n\n2020-02-20  Anthony <adanalis@icl.utk.edu>\n\n\t* src/components/sde/tests/Makefile, src/configure, src/configure.in:\n\t  Added -lrt to LIBS (if needed) so that it propagates into the pkg-\n\t  config file papi.pc. Also, removed the explicit flag from the SDE\n\t  tests Makefile.\n\n2020-02-19  Anthony <adanalis@icl.utk.edu>\n\n\t* src/components/sde/sde_internal.h, src/configure, src/configure.in:\n\t  Enabled overflow by default in SDE and added -lrt detection in the\n\t  configure script.\n\n2020-02-19  Anthony Castaldo <TonyCastaldo@icl.utk.edu>\n\n\t* src/components/rocm/tests/rocm_all.cpp: Reconciling this version of\n\t  rocm_all.cpp with another pull request.\n\n2020-02-18  Anthony Castaldo <TonyCastaldo@icl.utk.edu>\n\n\t* src/components/cuda/linux-cuda.c: ---Correct cuda push/pop context\n\t  consistency---  In _cuda_cleanup_eventset we attempt to push a\n\t  current cuda context, set a new cuda context to do some cleanup,\n\t  then restore the original context with a pop. (cuCtxPushCurrent,\n\t  cuCtxPopCurrent). This was failing. We corrected it by doing a\n\t  Save+Restore instead of a Push+Pop using cuCtxGetCurrent,\n\t  cuCtxSetCurrent, different routines that do not require the cuda\n\t  Context Stack, and have fewer restrictions on their use.\n\n2020-02-16  Daniel Barry <dbarry@vols.utk.edu>\n\n\t* src/counter_analysis_toolkit/main.c: Added check for whether or not\n\t  the user provided a benchmark category.  When using the Counter\n\t  Analysis Toolkit, if the user did not supply a benchmark category,\n\t  then it will run the 'branch' benchmark by default and inform the\n\t  user of such. The 'branch' benchmark executes the most quickly of\n\t  all the categories, making it a suitable default.  These changes\n\t  were tested on the Intel Haswell architecture.\n\n2020-02-13  Frank Winkler <frankbook@m016.zih.tu-dresden.de>\n\n\t* src/run_tests.sh: Little change in test script based on commit\n\t  14cebbc.  We have changed the high-level environment variable\n\t  PAPI_NO_WARNING to PAPI_HL_VERBOSE. Also, verbose output is off by\n\t  default, that's why this variable is not needed in the test script\n\t  anymore.\n\n2020-02-13  Anthony Castaldo <TonyCastaldo@icl.utk.edu>\n\n\t* src/components/cuda/linux-cuda.c: Modifications for more thorough\n\t  error-checking in routines before using pointers (ensuring they are\n\t  non-NULL). Suggested by Steve Kaufmann.\n\n2020-02-11  Anthony Castaldo <TonyCastaldo@icl.utk.edu>\n\n\t* src/components/rocm_smi/linux-rocm-smi.c: Removed a debug message.\n\n2020-02-10  Anthony Castaldo <TonyCastaldo@icl.utk.edu>\n\n\t* src/components/rocm_smi/linux-rocm-smi.c: Corrects a problem\n\t  producing a segfault. The function MakeRoomAllEvents() can\n\t  realloc() a table, but this can make the use of a pointer into the\n\t  former area produce a segfault.\n\n2020-01-31  Anthony Castaldo <TonyCastaldo@icl.utk.edu>\n\n\t* src/components/rocm_smi/linux-rocm-smi.c,\n\t  src/components/rocm_smi/tests/ROCM_SMI_Makefile,\n\t  src/components/rocm_smi/tests/rocmcap_plot.cpp: A new utility added\n\t  to tests, and debug lines (commented out) in component code until\n\t  SMI library problem with power events is sorted out.\n\t* src/components/io/linux-io.c: We have to fopen/fclose the system\n\t  file for every read; otherwise Linux caches the file and reports\n\t  the same values every time.\n\n2020-01-30  Anthony <adanalis@icl.utk.edu>\n\n\t* src/high-level/papi_hl.c: Turned verbosity of HL API off by\n\t  default.\n\n2020-01-30  Anthony Castaldo <TonyCastaldo@icl.utk.edu>\n\n\t* src/components/io/linux-io.c: Rewrite to use ctx and ctl structures\n\t  for thread safety.\n\n2020-01-29  Anthony Castaldo <TonyCastaldo@icl.utk.edu>\n\n\t* src/components/rocm/Rules.rocm,\n\t  src/components/rocm/tests/rocm_all.cpp: Corrected a typo in\n\t  Rules.rocm, and cleaned up a test program rocm_all.cpp.\n\t* src/components/io/linux-io.c: Provided some insurance that io\n\t  component initialization occurs only once.\n\n2020-01-29  Daniel Barry <dbarry@vols.utk.edu>\n\n\t* src/counter_analysis_toolkit/branch.c,\n\t  src/counter_analysis_toolkit/dcache.c,\n\t  src/counter_analysis_toolkit/flops.c,\n\t  src/counter_analysis_toolkit/gen_seq_dlopen.sh: Removed unnecessary\n\t  error reporting.  Some error messages from the CAT benchmarks were\n\t  removed so as not to cause extraneous output.  These changes were\n\t  tested on the Intel Broadwell architecture.\n\n2020-01-28  Anthony <adanalis@icl.utk.edu>\n\n\t* src/counter_analysis_toolkit/main.c: Avoid computing the latencies\n\t  twice.\n\t* src/components/sde/sde.c: Updated the info that is reported by the\n\t  component about itself.\n\n2020-01-28  Daniel Barry <dbarry@vols.utk.edu>\n\n\t* src/counter_analysis_toolkit/flops.c: Fixed bug in FLOPS benchmark.\n\t  The FLOPS benchmarks ensure that the compiler does not discard the\n\t  results of the numerical kernels. A double-precision benchmark was\n\t  ensuring that the single-precision result was not discarded,\n\t  instead of the double-precision result. This has now been\n\t  corrected.  This was tested on the Intel Broadwell architecture.\n\n2020-01-28  Anthony <adanalis@icl.utk.edu>\n\n\t* src/counter_analysis_toolkit/dcache.c,\n\t  src/counter_analysis_toolkit/dcache.h,\n\t  src/counter_analysis_toolkit/driver.h,\n\t  src/counter_analysis_toolkit/gen_seq_dlopen.sh,\n\t  src/counter_analysis_toolkit/icache.c,\n\t  src/counter_analysis_toolkit/icache.h,\n\t  src/counter_analysis_toolkit/main.c: Added code to show progress if\n\t  the user asks for it (-verbose flag), and removed confusing error\n\t  messages and dead code.\n\n2020-01-28  Daniel Barry <dbarry@vols.utk.edu>\n\n\t* src/counter_analysis_toolkit/main.c: Per the sscanf man page, it is\n\t  unnecessary to call free() in this block since memory for the\n\t  string would not be allocated.  This was tested on the AMD EPYC\n\t  architecture.\n\n2020-01-27  Daniel Barry <dbarry@vols.utk.edu>\n\n\t* src/counter_analysis_toolkit/driver.h,\n\t  src/counter_analysis_toolkit/main.c: Added checks for negative\n\t  amounts of qualifers provided by the user.  Previously, there was a\n\t  bug caused by a user providing a negative number of qualifiers.\n\t  Now, if a user does provide a negative number of qualifiers, this\n\t  number is set to zero.  This fix was tested on the AMD EPYC\n\t  architecture.\n\n2020-01-27  Anthony <adanalis@icl.utk.edu>\n\n\t* src/components/perf_event/pe_libpfm4_events.c: Fixed problems with\n\t  debug macro.\n\n2020-01-24  Damien Genet <dgenet@icl.utk.edu>\n\n\t* src/components/infiniband/tests/Makefile: Adds missing rule for\n\t  compilation of MPI test\n\n2020-01-24  Anthony Castaldo <TonyCastaldo@icl.utk.edu>\n\n\t* src/components/perf_event/pe_libpfm4_events.c: New libpfm4 contains\n\t  \"aliased\" pmus for backward compatibility, amd64_fam17h ==\n\t  amd64_fam17h_zen1; this causes us to put BOTH pmus into the PMUs\n\t  supported string and double the events in native_avail. This update\n\t  recognizes when aliases exist (the names must be hard-coded) and\n\t  uses only one of the most recent name.\n\n2020-01-23  Heike Jagode <jagode@icl.utk.edu>\n\n\t* src/components/infiniband_umad/README.md,\n\t  .../infiniband_umad/Rules.infiniband_umad, .../infiniband_umad\n\t  /linux-infiniband_umad.c, .../infiniband_umad/linux-\n\t  infiniband_umad.h, src/components/infiniband_umad/tests/Makefile,\n\t  .../tests/infiniband_umad_list_events.c,\n\t  .../tests/infiniband_umad_values_by_code.c: Retirement of\n\t  infiniband_umad component.  With the latest advancements of the\n\t  infiniband component, infiniband_umad has become redundant.\n\n2020-01-22  Damien Genet <dgenet@icl.utk.edu>\n\n\t* src/components/Makefile_comp_tests.target.in: Propagating MPICC to\n\t  components tests\n\t* src/components/infiniband/linux-infiniband.c,\n\t  .../infiniband/tests/MPI_test_infiniband_events.c: snprintf return\n\t  value, a classic now. And the 3-space indentation.\n\n2019-09-04  Rizwan-ICL <rizwan@icl.utk.edu>\n\n\t* src/components/infiniband/linux-infiniband.c,\n\t  .../infiniband/tests/MPI_test_infiniband_events.c,\n\t  src/components/infiniband/tests/Makefile: Added descriptions for\n\t  events of infiniband component using documentation provided by\n\t  Mellanox; Added test code to test the various events in infiniband\n\t  component and modified Makefile to compile the test code;\n\n2020-01-22  Damien Genet <dgenet@icl.utk.edu>\n\n\t* src/components/powercap_ppc/README,\n\t  src/components/powercap_ppc/Rules.powercap_ppc,\n\t  src/components/powercap_ppc/linux-powercap-ppc.c,\n\t  src/components/powercap_ppc/linux-powercap-ppc.h,\n\t  src/components/powercap_ppc/tests/Makefile,\n\t  src/components/powercap_ppc/tests/powercap_basic.c,\n\t  src/components/powercap_ppc/tests/powercap_limit.c: Merged in\n\t  feature/powercap_ppc (pull request #34)  Feature/powercap ppc  *\n\t  Powercapping for IBM PowerPC architecture, Power9 processors  *\n\t  Adding 2 tests for powercap component on PPC architecture Power9\n\t  Approved-by: adanalis Approved-by: Anthony Castaldo\n\n2020-01-22  Frank Winkler <frankbook@m016.zih.tu-dresden.de>\n\n\t* src/high-level/scripts/papi_hl_output_writer.py: Fixed bug for\n\t  python3.  - dict.iteritems() was removed in python3 --> Instead:\n\t  use dict.items() The output script works for both python2 and\n\t  python3.\n\t* src/papi.c: Bug fix that was caused by commit db01193.\n\t* src/examples/PAPI_flops.c: Improved some comments.\n\n2020-01-21  Damien Genet <dgenet@icl.utk.edu>\n\n\t* src/components/sensors_ppc/linux-sensors-ppc.c: Adds missing checks\n\t  for snprintf. A return value larger than the buffer is not really\n\t  an error, just a poor design, but whatever.\n\n2020-01-20  Frank Winkler <frankbook@m016.zih.tu-dresden.de>\n\n\t* src/examples/PAPI_mix_hl_ll.c, src/examples/PAPI_mix_hl_rate.c,\n\t  src/examples/PAPI_mix_ll_rate.c, src/papi.c, src/papi.h: Renamed\n\t  papi_rate_stop to papi_stop_events.\n\t* src/high-level/papi_hl.c: Fixed bug. Check for empty string in\n\t  PAPI_EVENTS.\n\t* src/high-level/papi_hl.c, src/papi.c, src/papi_internal.c,\n\t  src/papi_internal.h: Fixed typo.\n\t* src/high-level/papi_hl.c: Improved cleanup function.\n\n2020-01-18  Frank Winkler <frankbook@franks-air.localdomain>\n\n\t* src/examples/Makefile, src/examples/PAPI_mix_hl_ll.c,\n\t  src/examples/PAPI_mix_hl_rate.c, src/examples/PAPI_mix_ll_rate.c,\n\t  src/papi.c: Added examples that show how to mix hl, ll, and rate\n\t  functions.\n\n2020-01-17  Frank Winkler <frankbook@franks-air.localdomain>\n\n\t* src/high-level/papi_hl.c, src/papi.c, src/papi.h,\n\t  src/papi_internal.c, src/papi_internal.h: Added feature that allows\n\t  mixing of rate functions and hl functions.\n\n2020-01-16  Anthony Castaldo <TonyCastaldo@icl.utk.edu>\n\n\t* src/papi_events.csv: Added two machine types to papi_events.csv to\n\t  be in line with libpfm4 update to support amd64_fam17h_zen1 and\n\t  zen2.\n\n2020-01-16  Anthony <adanalis@icl.utk.edu>\n\n\t* src/components/sde/tests/Makefile: Fixed dependency in Makefile.\n\n2020-01-16  Frank Winkler <frankbook@m016.zih.tu-dresden.de>\n\n\t* src/papi.c, src/papi.h: Added PAPI_rate_stop() that stops any rate\n\t  function.\n\n2020-01-16  Damien Genet <dgenet@icl.utk.edu>\n\n\t* src/components/sensors_ppc/README,\n\t  src/components/sensors_ppc/Rules.sensors_ppc,\n\t  src/components/sensors_ppc/linux-sensors-ppc.c,\n\t  src/components/sensors_ppc/linux-sensors-ppc.h,\n\t  src/components/sensors_ppc/tests/Makefile,\n\t  .../sensors_ppc/tests/sensors_ppc_basic.c: Add new component for\n\t  sensors reading on PowerPC 9 Enable with ./configure --with-\n\t  components=\"sensors_ppc\"\n\n2020-01-16  Frank Winkler <frankbook@m016.zih.tu-dresden.de>\n\n\t* src/run_tests.sh: Fixed little bug in test script.  The output\n\t  directory of the high-level API has been renamed from papi to\n\t  papi_hl_output.\n\n2020-01-16  Anthony Castaldo <TonyCastaldo@icl.utk.edu>\n\n\t* src/components/rocm_smi/Rules.rocm_smi, src/components/rocm_smi\n\t  /linux-rocm-smi.c: Changed Rules file to look in multiple places\n\t  for rocm_smi.h, it moved between rocm releases. Rewrote a routine\n\t  to be more efficient and eliminate a string-size warning. Made some\n\t  diagnostic outputs that were left active in previous commit\n\t  dependent on #ifdef macros.\n\n2020-01-15  Frank Winkler <frankbook@m016.zih.tu-dresden.de>\n\n\t* src/high-level/papi_hl.c: Fixed memory leak in high-level API.\n\t  Based on commit ef20e24 that fixed a bug by deleting a \"free\" call,\n\t  the \"free\" call is now done in the last function of the high-level\n\t  API which is called during the \"atexit()\" call.\n\n2020-01-14  Anthony <adanalis@icl.utk.edu>\n\n\t* .../sde/tests/Advanced_C+FORTRAN/Gamum.c,\n\t  .../sde/tests/Advanced_C+FORTRAN/Xandria.F90,\n\t  .../sde/tests/Advanced_C+FORTRAN/sde_test_f08.F90,\n\t  src/components/sde/tests/Gamum.c,\n\t  src/components/sde/tests/Makefile,\n\t  src/components/sde/tests/Minimal/Minimal_Test.c,\n\t  src/components/sde/tests/Minimal_Test.c,\n\t  src/components/sde/tests/Recorder.c,\n\t  .../sde/tests/Recorder/Lib_With_Recorder.c,\n\t  .../sde/tests/Recorder/Recorder_Driver.c,\n\t  src/components/sde/tests/Simple/Simple_Driver.c,\n\t  src/components/sde/tests/Simple/Simple_Lib.c,\n\t  src/components/sde/tests/Simple2/Simple2_Driver.c,\n\t  src/components/sde/tests/Simple2/Simple2_Lib.c,\n\t  src/components/sde/tests/Xandria.F90,\n\t  src/components/sde/tests/sde_test_f08.F90: Added new tests/examples\n\t  under the SDE component and organized them based on complexity.\n\t* src/components/sde/sde.c: Improved and corrected the checks that\n\t  relate to counter groups and recorders.\n\n2020-01-13  Anthony <adanalis@icl.utk.edu>\n\n\t* src/utils/Makefile, src/utils/papi_sde_interface.c: Added the weak\n\t  symbols for SDE to papi_native_avail, so the utility works when\n\t  PAPI is not configured with the SDE component.\n\t* src/utils/papi_avail.c, src/utils/papi_native_avail.c: Improved the\n\t  code that checks the command-line arguments.\n\n2020-01-06  Anthony <adanalis@icl.utk.edu>\n\n\t* src/components/sde/sde.c, src/components/sde/sde_internal.h,\n\t  src/utils/papi_native_avail.c: Moved the responsibility of listing\n\t  SDEs of a library/executable to papi_native_avail instead of the\n\t  SDE component.\n\t* src/papi_internal.c: Updated the variables that are used in the\n\t  debug messages in accordance to a previous commit that made these\n\t  variables thread safe.\n\n2020-01-03  Frank Winkler <frankbook@v0020.dip.tu-dresden.de>\n\n\t* src/high-level/scripts/papi_hl_output_writer.py: Changed name of\n\t  some derived metrics.\n\t* src/high-level/papi_hl.c, src/high-\n\t  level/scripts/papi_hl_output_writer.py: Added new derived metrics.\n\n2020-01-03  Frank Winkler <frankbook@franks-air.localdomain>\n\n\t* src/high-level/papi_hl.c: Little format changes.\n\t* src/high-level/papi_hl.c: Fixed bug in high-level API caused by\n\t  commit ff8ff65.  The creation of the measurement directory failed\n\t  since Coverity freed memory of a string that was used later to\n\t  create the measurement directory.\n\n2020-01-02  Frank Winkler <frankbook@Franks-MacBook-Air.local>\n\n\t* src/high-level/papi_hl.c, src/validation_tests/Makefile.recipies,\n\t  src/validation_tests/flops_validation_hl.c,\n\t  src/validation_tests/fp_validation_hl.c: Revised default events for\n\t  flops and flips.\n\n2019-12-20  Frank Winkler <frank.winkler@tu-dresden.de>\n\n\t* src/papi.c: papi.c edited online with Bitbucket\n\t* src/examples/high_level.c: high_level.c edited online with\n\t  Bitbucket\n\t* src/examples/PAPI_ipc.c: PAPI_ipc.c edited online with Bitbucket\n\t* src/examples/PAPI_flops.c: PAPI_flops.c edited online with\n\t  Bitbucket\n\t* src/examples/PAPI_flips.c: PAPI_flips.c edited online with\n\t  Bitbucket\n\t* src/examples/PAPI_epc.c: PAPI_epc.c edited online with Bitbucket\n\n2019-12-19  Anthony <adanalis@icl.utk.edu>\n\n\t* src/components/sde/sde.c, src/components/sde/sde_internal.h: Fixed\n\t  issues in the SDE component unveiled by Coverity.\n\n2019-12-19  Daniel Barry <dbarry@methane.icl.utk.edu>\n\n\t* src/counter_analysis_toolkit/main.c: Fixed typo in comment for\n\t  argument parsing.\n\n2019-12-19  Frank Winkler <frankbook@m016.zih.tu-dresden.de>\n\n\t* src/libpapi.exp: Fixed typo.\n\t* src/ctests/bgp/Makefile, src/ctests/bgp/papi_1.c, src/libpapi.exp:\n\t  Further clean-up.\n\n2019-12-19  Daniel Barry <dbarry@methane.icl.utk.edu>\n\n\t* src/counter_analysis_toolkit/Makefile,\n\t  src/counter_analysis_toolkit/caches.h,\n\t  src/counter_analysis_toolkit/dcache.c,\n\t  src/counter_analysis_toolkit/dcache.h,\n\t  src/counter_analysis_toolkit/driver.h,\n\t  src/counter_analysis_toolkit/main.c,\n\t  src/counter_analysis_toolkit/timing_kernels.c,\n\t  src/counter_analysis_toolkit/timing_kernels.h: Removed unnecessary\n\t  variables and checks. Refactored code blocks. Added comments in the\n\t  main driver file.\n\n2019-12-19  Frank Winkler <frankbook@m016.zih.tu-dresden.de>\n\n\t* src/ctests/bgp/papi_1.c, src/libpapi.exp: Clean-up of old high-\n\t  level functions.\n\n2019-12-18  Frank Winkler <frankbook@m016.zih.tu-dresden.de>\n\n\t* man/man1/papi_component_avail.1: Fixed typo in\n\t  papi_component_avail.1. See pull request #2.\n\n2019-12-16  Anthony <adanalis@icl.utk.edu>\n\n\t* src/counter_analysis_toolkit/Makefile: Renamed cit_collect to\n\t  cat_collect.\n\t* src/counter_analysis_toolkit/eventstock.c: Clarified comment.\n\t* src/counter_analysis_toolkit/branch.c,\n\t  src/counter_analysis_toolkit/driver.h,\n\t  src/counter_analysis_toolkit/eventstock.c,\n\t  src/counter_analysis_toolkit/eventstock.h,\n\t  src/counter_analysis_toolkit/flops.c,\n\t  src/counter_analysis_toolkit/gen_seq_dlopen.sh,\n\t  src/counter_analysis_toolkit/main.c: Removed unnecessary work when\n\t  setting up the list of events, and minor cosmetic changes.\n\n2019-12-16  Daniel Barry <dbarry@methane.icl.utk.edu>\n\n\t* src/counter_analysis_toolkit/flops.c: Cleaned up comments.\n\n2019-12-16  Anthony Castaldo <TonyCastaldo@icl.utk.edu>\n\n\t* src/components/rapl/tests/rapl_overflow.c: Corrected a working but\n\t  convoluted line of code.\n\n2019-12-13  Frank Winkler <frankbook@m016.zih.tu-dresden.de>\n\n\t* src/examples/PAPI_flips.c, src/examples/PAPI_flops.c, src/papi.c:\n\t  Minor documentation corrections.\n\t* src/papi.h: Fixed some thread definitions.\n\t* src/high-level/papi_hl.c, src/papi.h: Revised documentation of\n\t  high-level API.\n\t* src/high-level/papi_hl.c, src/high-\n\t  level/scripts/papi_hl_output_writer.py: Renamed the output\n\t  directory of the high-level API from 'papi' to 'papi_hl_output'.\n\t* src/papi.c: Revised documentation.\n\t* src/examples/PAPI_epc.c, src/examples/PAPI_flips.c,\n\t  src/examples/PAPI_flops.c, src/examples/PAPI_ipc.c, src/papi.c:\n\t  Adjusted doxygen documentation.\n\n2019-12-12  Frank Winkler <frankbook@m016.zih.tu-dresden.de>\n\n\t* src/examples/Makefile, src/examples/PAPI_flips.c,\n\t  src/examples/PAPI_flops.c, src/examples/PAPI_ipc.c,\n\t  src/examples/high_level.c, src/papi.c, src/papi.h,\n\t  src/papi_fwrappers.c: Reimplemented rate functions and adjusted\n\t  examples.\n\n2019-12-11  Daniel Barry <dbarry@methane.icl.utk.edu>\n\n\t* src/counter_analysis_toolkit/branch.c,\n\t  src/counter_analysis_toolkit/dcache.c,\n\t  src/counter_analysis_toolkit/flops.c,\n\t  src/counter_analysis_toolkit/gen_seq_dlopen.sh: Added\n\t  PAPI_cleanup_eventset() call to each of the benchmarks. This\n\t  removes events from the event set.  By including these calls, the\n\t  benchmarks do not encounter the PAPI_ECOUNT error code, which\n\t  occurs if there are too many events added to the same event set.\n\t  These changes were tested on the Intel Skylake architecture.\n\n2019-12-10  Anthony Castaldo <TonyCastaldo@icl.utk.edu>\n\n\t* src/components/rocm_smi/README,\n\t  src/components/rocm_smi/Rules.rocm_smi,\n\t  src/components/rocm_smi/tests/rocm_smi_all.txt: Minor changes to\n\t  text and a setting that was for development only.\n\n2019-12-10  Frank Winkler <frankbook@m016.zih.tu-dresden.de>\n\n\t* src/papi.c: Made rate functions thread safe.\n\n2019-12-09  Anthony <adanalis@icl.utk.edu>\n\n\t* src/utils/Makefile: Changed the order of the linker flags so that\n\t  -ldl is at the end since libpapi.a needs libdl.so but not the other\n\t  way around.\n\n2019-12-06  Heike Jagode <jagode@icl.utk.edu>\n\n\t* README.md: README.md edited online with Bitbucket\n\n2019-12-06  Steve Kaufmann <sbk@cray.com>\n\n\t* src/components/rocm/linux-rocm.c, src/papi_events.csv: The changes\n\t  here are based on a patch provided by Steve Kaufmann; to correct a\n\t  misnamed event in papi_events.csv, and prevent a segfault in rocm\n\t  when a context pointer is null. Additional changes by Tony Castaldo\n\t  check to see if the necessary rocprofiler environment variables\n\t  have been set; and disable the component if they are not, with an\n\t  informative reason to be reported by papi_component_avail. (The\n\t  component will not work without them).\n\n2019-12-05  Frank Winkler <frankbook@m016.zih.tu-dresden.de>\n\n\t* src/papi.c: Replaced HighLevelInfo with RateInfo.\n\n2019-12-03  Anthony Castaldo <TonyCastaldo@icl.utk.edu>\n\n\t* src/extras.c: extra '#' in \"%#p\" print formats, using just '%p'.\n\n2019-12-03  William Cohen <wcohen@redhat.com>\n\n\t* src/testlib/papi_test.h, src/testlib/test_utils.c: Use the noreturn\n\t  attribute only when the compiler support GNU C extensions.\n\t* src/testlib/papi_test.h, src/testlib/test_utils.c: Properly mark\n\t  some test_utils.c functions with noreturn attributes  Clang makes\n\t  use of the information whether a function returns in flow analysis\n\t  to determine whether there are uses of null values and other\n\t  possible problematic issues.  Marking the test_pass, test_hl_pass,\n\t  test_fail, and test_skip functions properly with noreturn attribute\n\t  allows Clang to more accurately analyze the code and eliminates 87\n\t  false positive warnings in the PAPI testsuite code.\n\n2019-12-02  Anthony Castaldo <TonyCastaldo@icl.utk.edu>\n\n\t* src/components/coretemp/linux-coretemp.c, src/components/infiniband\n\t  /linux-infiniband.c, src/components/lmsensors/linux-lmsensors.c,\n\t  src/components/lustre/linux-lustre.c, src/components/pcp/linux-\n\t  pcp.c, src/components/pcp/tests/testPCP.c,\n\t  src/components/perf_event/perf_event.c,\n\t  .../perf_event_uncore/perf_event_uncore.c, src/components/rapl\n\t  /linux-rapl.c, src/ctests/failed_events.c, src/ctests/kufrin.c,\n\t  src/ctests/pthrtough.c, src/ctests/pthrtough2.c, src/extras.c, src\n\t  /high-level/papi_hl.c, src/linux-common.c, src/linux-memory.c,\n\t  src/testlib/clockcore.c, src/utils/cost_utils.c,\n\t  src/utils/papi_command_line.c, src/utils/papi_multiplex_cost.c: The\n\t  code in this commit all failed a Coverity scan (a code consistency\n\t  tool) that correctly identified memory leaks, potential buffer\n\t  overflows, and failures to close a file or directory that had been\n\t  opened.\n\n2019-12-02  Frank Winkler <frankbook@m016.zih.tu-dresden.de>\n\n\t* src/papi.c, src/papi.h, src/papi_fwrappers.c: Reimplemented rate\n\t  calls such as PAPI_flips, PAPI_flops, etc.  - These calls are now\n\t  part of the low-level API - PAPI_stop_rates() stop the counters\n\n2019-11-20  William Cohen <wcohen@redhat.com>\n\n\t* src/components/sde/Rules.sde: Limit Fortran 90 compilers options to\n\t  SDE component Fortran 90 code  The Rules.sde added Fortran 90\n\t  options to FFLAGS that would end up being applied to other Fortran\n\t  code being built in papi. Unfortunately, the other code is F77 code\n\t  and the options would cause the build to fail.\n\n2019-11-21  Heike Jagode <jagode@icl.utk.edu>\n\n\t* README.md: README.md edited online with Bitbucket\n\n2019-11-14  Daniel Barry <dbarry@vols.utk.edu>\n\n\t* src/counter_analysis_toolkit/main.c: Swapped lines 268 and 269 of\n\t  main.c so that the appropriate memory allocation is freed, and the\n\t  pointer is then set to NULL.\n\n2019-11-13  Anthony Castaldo <TonyCastaldo@icl.utk.edu>\n\n\t* src/components/nvml/tests/Makefile,\n\t  src/components/nvml/tests/nvmlcap_plot.cu,\n\t  src/components/nvml/utils/Makefile,\n\t  src/components/nvml/utils/README,\n\t  src/components/nvml/utils/nvmlcap_plot.cu: For consistency with\n\t  powercap and rapl components, moved nvmlcap_plot.cu to a new\n\t  nvml/utils/ directory. New Makefile in nvml/utils/ and adjusted\n\t  Makefile in nvml/tests/. Created a new README for nvmlcap_plot. No\n\t  code changes; but tested configure and make of PAPI and\n\t  nvmlcap_plot.\n\n2019-11-08  Anthony Castaldo <TonyCastaldo@icl.utk.edu>\n\n\t* src/components/rapl/linux-rapl.c: Fixed an inaccurate comment.\n\t* src/components/rapl/README,\n\t  src/components/rapl/tests/rapl_overflow.c: Added a paragraph of\n\t  usage info to README; also reformatted existing comments to comply\n\t  with 80 char line limit; without changing their content.\n\t  rapl_overflow.c was confusing, it was not using the\n\t  PACKAGE_ENERGY_CNT event to test for overflow, and the scaled value\n\t  seemed to wrap in 85ms. This seemed to conflict with the results of\n\t  rapl_wraparound; which computes a wraparound time in 85 minutes.\n\t  rapl_overflow.c is now in line with an 80-90 minute wraparound\n\t  vaue.\n\n2019-11-07  Anthony Castaldo <TonyCastaldo@icl.utk.edu>\n\n\t* src/components/rapl/linux-rapl.c: Changes to properly mask energy\n\t  values to uint32, and accumulate them to return a 64-bit\n\t  accumulator. Verified wraparound time at approx 85 minutes (for a\n\t  32 bit read). That is the maximum allowed time between reads; the\n\t  64-bit value returned should never wrap. (Some tabs converted to\n\t  spaces in changed code.)\n\n2019-11-01  Frank Winkler <frankbook@m016.zih.tu-dresden.de>\n\n\t* src/high-level/papi_hl.c: Removed Doxygen documentation for\n\t  internal functions and moved code block for multiplex\n\t  initialization.  PAPI_multiplex_init is only called after a\n\t  successful PAPI_thread_init.\n\n2019-10-31  Anthony Castaldo <TonyCastaldo@icl.utk.edu>\n\n\t* src/components/perf_event/pe_libpfm4_events.c: Fixed a typo in the\n\t  error message.\n\t* src/ctests/Makefile.recipies, src/ctests/filter_helgrind.c,\n\t  src/papi.c, src/papi_internal.c, src/threads.c, src/threads.h: The\n\t  changes to papi.c, papi_internal.c, threads.h and threads.c correct\n\t  a race condition that was the result of all threads using the same\n\t  two static variables (papi_event_code and papi_event_code_changed)\n\t  to temporarily record a state of operation. The solution was to\n\t  make these variables unique per thread, using the ThreadInfo_t\n\t  structure already provided in PAPI for such purposes. The file\n\t  krentel_pthread_race.c is a stress test to produce race conditions.\n\t  filter_helgrind.c reduces the volume of --tool-helgrind output to a\n\t  more manageable summary. Both are added to Makefile.recipies.\n\n2019-10-31  William Cohen <wcohen@redhat.com>\n\n\t* src/ctests/krentel_pthreads_race.c: This code is a modification of\n\t  krentel_pthreads.c, to better test some race conditions. It is not\n\t  included in the standard tests; it is a diagnostic that should be\n\t  run with \"valgrind --tool=helgrind\".\n\n2019-10-31  Anthony Castaldo <TonyCastaldo@icl.utk.edu>\n\n\t* src/components/perf_event/pe_libpfm4_events.c: Changed SUBDBG error\n\t  reporting in new code to a single message instead of two, before\n\t  the unlock code (so no race condition on variables in report).\n\t  Cosmetics.\n\n\n2019-10-28  Daniel Barry <dbarry@vols.utk.edu>\n\n\t* src/counter_analysis_toolkit/main.c: Added checks for improperly\n\t  formatted lines in the user-provided event list.  If a line is\n\t  missing a qualifier count, then it is discarded.  If a provided\n\t  event name is either not available in the architecture or contains\n\t  qualifiers, then the qualifier count is set to zero to prevent\n\t  appending extraneous qualifiers, and the user is notified.  Also\n\t  cleaned up string manipulation.  These changes were tested on the\n\t  Intel Haswell architecture.\n\n2019-10-25  Anthony Castaldo <TonyCastaldo@icl.utk.edu>\n\n\t* src/components/perf_event/pe_libpfm4_events.c: In two places, we\n\t  exited the routine allocate_native_event() because we could not\n\t  find a mask or attribute in an event name (because the event was\n\t  supported but the given mask was not), and failed without unlocking\n\t  the NAMELIB_LOCK, or cleaning up allocated memory.  +\n\t  free (msk_ptr); +               free(pmu_name); +\n\t  _papi_hwi_unlock( NAMELIB_LOCK );\n\n2019-10-24  Anthony Castaldo <TonyCastaldo@icl.utk.edu>\n\n\t* src/components/rocm_smi/linux-rocm-smi.c,\n\t  src/components/rocm_smi/tests/ROCM_SMI_Makefile,\n\t  src/components/rocm_smi/tests/rocm_smi_all.cpp,\n\t  src/components/rocm_smi/tests/rocm_smi_all.txt: New events added,\n\t  some bugs corrected. ROCM_SMI_Makefile is modified to use env\n\t  variable $PAPI_ROCM_ROOT to make it easier to compile with a local\n\t  version of the rocm_smi library. rocm_smi_all.txt is the output of\n\t  a run of rocm_smi_all.cpp, which has been modified to handle\n\t  strings, and skip testing of events that bomb (unhandled exceptions\n\t  in library code). NOTE this code may still contain debug printing\n\t  to stderr, to be removed in the final version after all issues are\n\t  corrected. -Tony\n\n2019-10-24  Frank Winkler <frankbook@m016.zih.tu-dresden.de>\n\n\t* src/papi.h: Removed TLS definitions.\n\t* src/high-level/papi_hl.c, src/papi.h: Replaced PAPI_TLS_KEYWORD\n\t  with THREAD_LOCAL_STORAGE_KEYWORD due to ABI conflicts.\n\n2019-10-18  Anthony Castaldo <TonyCastaldo@icl.utk.edu>\n\n\t* src/components/rocm_smi/Rules.rocm_smi, src/components/rocm_smi\n\t  /linux-rocm-smi.c, src/components/rocm_smi/rocm_smi.h: This is a\n\t  first installment of the rewrite of the rocm_smi component. It\n\t  currently requires a private install of the updated library (with\n\t  iterators), and a special Rules.file, PAPI_ROCM_ROOT, and\n\t  PAPI_ROCM_SMI_MAIN. It works as far as executing\n\t  utils/papi_native_avail; but none of the events have been tested\n\t  yet by reading with PAPI code. -TC\n\n2019-10-15  Damien Genet <dgenet@icl.utk.edu>\n\n\t* src/components/nvml/linux-nvml.c: Merged in dgenet/papi/fix/nvml-\n\t  rules (pull request #14)  Fixes error messages while detecting\n\t  Rules.nvml  Patch from Vince Weaver   Approved-by: Heike Jagode\n\t  <jagode@icl.utk.edu> Approved-by: Damien Genet <dgenet@icl.utk.edu>\n\t  Approved-by: Anthony Castaldo <tonycastaldo@icl.utk.edu>\n\n2019-10-09  Heike Jagode <jagode@icl.utk.edu>\n\n\t* README.md: Cleaning up README file.\n\t* README.md: README.md edited online with Bitbucket\n\t* README: README edited online with Bitbucket\n\t* README.md: README.md edited online with Bitbucket\n\n2019-10-08  Steve Kaufmann <sbk@cray.com>\n\n\t* src/components/cuda/linux-cuda.c: Corrected several cosmetic issues\n\t  and typos, standardized naming, used PATH_MAX instead of literal,\n\t  and PAPI_MAX_STR_LEN instead of PAPI_MIN_STR_LEN.\n\n2019-10-08  Frank Winkler <frankbook@m016.zih.tu-dresden.de>\n\n\t* src/components/lmsensors/linux-lmsensors.c: Removed blank line.\n\t* src/components/lmsensors/linux-lmsensors.c: Replaced spaces with\n\t  underscores in event name.\n\n2019-10-06  Frank Winkler <frankbook@franks-air.localdomain>\n\n\t* src/papi_fwrappers.c: Corrected Doxygen documentation.\n\t* src/ctests/Makefile.recipies, src/ctests/mpi_hl.c,\n\t  src/ctests/mpi_omp_hl.c, src/ctests/omp_hl.c,\n\t  src/ctests/pthread_hl.c, src/ctests/serial_hl.c,\n\t  src/ctests/serial_hl_advanced.c, src/ctests/serial_hl_ll_comb.c,\n\t  src/ctests/serial_hl_ll_comb2.c, src/ftests/Makefile.recipies,\n\t  src/ftests/serial_hl.F, src/ftests/serial_hl_advanced.F, src/high-\n\t  level/papi_hl.c, src/papi.h, src/papi_fwrappers.c,\n\t  src/testlib/ftests_util.F, src/testlib/papi_test.h,\n\t  src/testlib/test_utils.c,\n\t  src/validation_tests/flops_validation_hl.c: Removed advanced\n\t  functions from the new high-level API.  The new high-level API\n\t  consists of three functions: - PAPI_hl_region_begin - PAPI_hl_read\n\t  - PAPI_hl_region_end  Validation test in C: -\n\t  src/validation_tests/flops_validation_hl.c  Test examples in C: -\n\t  src/ctests/serial_hl.c - src/ctests/omp_hl.c -\n\t  src/ctests/pthread_hl.c - src/ctests/mpi_hl.c -\n\t  src/ctests/mpi_omp_hl.c - src/ctests/serial_hl_ll_comb.c  Test\n\t  example in Fortran: - src/ftests/serial_hl.F\n\n2019-10-03  Damien Genet <dgenet@icl.utk.edu>\n\n\t* src/counter_analysis_toolkit/branch.c,\n\t  src/counter_analysis_toolkit/branch.h,\n\t  src/counter_analysis_toolkit/dcache.c,\n\t  src/counter_analysis_toolkit/dcache.h,\n\t  src/counter_analysis_toolkit/eventstock.c,\n\t  src/counter_analysis_toolkit/eventstock.h,\n\t  src/counter_analysis_toolkit/flops.c,\n\t  src/counter_analysis_toolkit/gen_seq_dlopen.sh,\n\t  src/counter_analysis_toolkit/icache.c,\n\t  src/counter_analysis_toolkit/icache.h,\n\t  src/counter_analysis_toolkit/main.c,\n\t  src/counter_analysis_toolkit/prepareArray.c,\n\t  src/counter_analysis_toolkit/prepareArray.h,\n\t  src/counter_analysis_toolkit/timing_kernels.c,\n\t  src/counter_analysis_toolkit/timing_kernels.h: Adding Checks\n\n2019-10-04  Anthony Danalis <adanalis@tellico-master0.local>\n\n\t* src/components/lmsensors/linux-lmsensors.c: Fixed inconsistency in\n\t  component name.\n\n2019-09-30  Anthony Danalis <adanalis@eecs.utk.edu>\n\n\t* src/components/sde/README, src/components/sde/Rules.sde,\n\t  src/components/sde/interface/papi_sde_interface.c,\n\t  src/components/sde/interface/papi_sde_interface.h,\n\t  src/components/sde/sde.c, src/components/sde/sde_F.F90,\n\t  src/components/sde/sde_internal.h,\n\t  src/components/sde/tests/Gamum.c,\n\t  src/components/sde/tests/Makefile,\n\t  src/components/sde/tests/Minimal_Test.c,\n\t  src/components/sde/tests/Recorder.c,\n\t  src/components/sde/tests/Xandria.F90,\n\t  src/components/sde/tests/sde_test_f08.F90: Software Defined Events\n\t  (SDE) component.\n\t* src/counter_analysis_toolkit/Makefile,\n\t  src/counter_analysis_toolkit/README,\n\t  src/counter_analysis_toolkit/branch.c,\n\t  src/counter_analysis_toolkit/branch.h,\n\t  src/counter_analysis_toolkit/caches.h,\n\t  src/counter_analysis_toolkit/compar.c,\n\t  src/counter_analysis_toolkit/dcache.c,\n\t  src/counter_analysis_toolkit/dcache.h,\n\t  src/counter_analysis_toolkit/driver.h,\n\t  src/counter_analysis_toolkit/event_list.txt,\n\t  src/counter_analysis_toolkit/eventstock.c,\n\t  src/counter_analysis_toolkit/eventstock.h,\n\t  src/counter_analysis_toolkit/flops.c,\n\t  src/counter_analysis_toolkit/flops.h,\n\t  src/counter_analysis_toolkit/flops_aux.c,\n\t  src/counter_analysis_toolkit/flops_aux.h,\n\t  src/counter_analysis_toolkit/gen_seq_dlopen.sh,\n\t  src/counter_analysis_toolkit/icache.c,\n\t  src/counter_analysis_toolkit/icache.h,\n\t  src/counter_analysis_toolkit/main.c,\n\t  src/counter_analysis_toolkit/prepareArray.c,\n\t  src/counter_analysis_toolkit/prepareArray.h,\n\t  src/counter_analysis_toolkit/replicate.sh,\n\t  src/counter_analysis_toolkit/timing_kernels.c,\n\t  src/counter_analysis_toolkit/timing_kernels.h: Counter Analysis\n\t  Toolkit.\n\n2019-09-30  Anthony Castaldo <TonyCastaldo@icl.utk.edu>\n\n\t* src/components/cuda/Rules.cuda, src/components/nvml/Rules.nvml,\n\t  src/components/pcp/Rules.pcp: Corrected typos, replacing \"optimal\"\n\t  with \"optional.\"\n\n2019-09-18  Anthony Castaldo <TonyCastaldo@icl.utk.edu>\n\n\t* src/components/cuda/linux-cuda.c: We no longer check the error on\n\t  setting CUPTI_EVENT_COLLECTION_MODE_CONTINUOUS, it only works on\n\t  Tesla devices (and is preferred there) but fails on other models,\n\t  they don't support the feature. We do not fail if they reject it.\n\n2019-09-17  Kevin Huck <khuck@cs.uoregon.edu>\n\n\t* src/components/io/CHANGES, src/components/io/README,\n\t  src/components/io/Rules.io, src/components/io/linux-io.c,\n\t  src/components/io/linux-io.h, src/components/io/tests/Makefile,\n\t  src/components/io/tests/io_basic.c,\n\t  src/components/io/tests/io_multiple_components.c: Adding I/O\n\t  component to read from /proc/self/io.\n\n2019-09-13  Steve Kaufmann <sbk@cray.com>\n\n\t* src/components/rocm/linux-rocm.c, src/components/rocm_smi/linux-\n\t  rocm-smi.c: Changes to make these components (ROCM, ROCM_SMI) have\n\t  naming consistency with others; fixed numerous minor formatting\n\t  issues and comments. Compiled and checked on ICL Caffeine.\n\n2019-09-13  Anthony Castaldo <TonyCastaldo@icl.utk.edu>\n\n\t* src/components/rocm/linux-rocm.c, src/components/rocm_smi/linux-\n\t  rocm-smi.c: Revert changes, used wrong author (Should be Steve\n\t  Kaufmann).  This reverts commit\n\t  9a60e91d539b8eb079dd81adc1d91c17620cfaed.\n\n2019-09-12  Anthony Castaldo <TonyCastaldo@icl.utk.edu>\n\n\t* src/components/rocm/linux-rocm.c, src/components/rocm_smi/linux-\n\t  rocm-smi.c: Changes suggested by Steve Kaufmann (Cray) to make\n\t  these components have naming consistency with others; fixed\n\t  numerous minor formatting issues. Reviewed, accepted, compiled,\n\t  checked.\n\n2019-09-09  Frank Winkler <frankbook@m016.zih.tu-dresden.de>\n\n\t* src/components/infiniband_umad/README.md,\n\t  src/components/lmsensors/README.md: Little format changes for\n\t  markdown documentation files.\n\t* src/components/libmsr/Makefile.libmsr.in,\n\t  src/components/libmsr/README, src/components/libmsr/README.md,\n\t  src/components/libmsr/Rules.libmsr,\n\t  src/components/libmsr/configure,\n\t  src/components/libmsr/configure.in, src/components/libmsr/linux-\n\t  libmsr.c, src/components/libmsr/utils/libmsr_write_test.c: Updated\n\t  code and documentation for component libmsr to get compliance with\n\t  the new component setup standard.\n\t* src/components/infiniband_umad/README,\n\t  src/components/infiniband_umad/README.md,\n\t  .../infiniband_umad/Rules.infiniband_umad, .../infiniband_umad\n\t  /linux-infiniband_umad.c: Updated code and documentation for\n\t  component infiniband_umad to get compliance with the new component\n\t  setup standard.\n\n2019-09-08  Frank Winkler <frankbook@Franks-MacBook-Air.local>\n\n\t* src/components/lmsensors/README,\n\t  src/components/lmsensors/README.md,\n\t  src/components/lmsensors/Rules.lmsensors, src/components/lmsensors\n\t  /linux-lmsensors.c: Updated code and documentation for component\n\t  lmsensors to get compliance with the new component setup standard.\n\n2019-09-05  Anthony Castaldo <TonyCastaldo@icl.utk.edu>\n\n\t* src/components/pcp/Rules.pcp: Corrected an issue with Rules,\n\t  changing the name of macro that conflicted with other potential\n\t  macros.\n\n2019-09-04  Anthony Castaldo <TonyCastaldo@icl.utk.edu>\n\n\t* src/components/cuda/Rules.cuda, src/components/nvml/Rules.nvml:\n\t  Corrected an incompatibility in multiple Rules files when multiple\n\t  components are included. Rules files cannot all use the same\n\t  \"MACRODEF\" variable for different purposes; each needs a unique ID,\n\t  like CUDA_MACS, NVML_MACS, etc.\n\t* src/components/rocm/README, src/components/rocm/Rules.rocm,\n\t  src/components/rocm/linux-rocm.c, src/components/rocm_smi/README,\n\t  src/components/rocm_smi/Rules.rocm_smi, src/components/rocm_smi\n\t  /linux-rocm-smi.c: Changes to make rocm_smi component compliant\n\t  with new component setup standard; changes to rocm component to\n\t  correct bugs in compatibility and comments.\n\t* src/components/rocm/README, src/components/rocm/Rules.rocm,\n\t  src/components/rocm/linux-rocm.c: Modified documentation, Rules and\n\t  code for ROCM component to comply with new setup standards. It now\n\t  requires PAPI_ROCM_ROOT as an environment variable.\n\t* src/components/pcp/README, src/components/pcp/Rules.pcp,\n\t  src/components/pcp/linux-pcp.c: Code and documentation to get\n\t  component PCP into compliance with the new component setup\n\t  standard; PAPI_PCP_ROOT is only environmental variable required.\n\n2019-09-03  Anthony Castaldo <TonyCastaldo@icl.utk.edu>\n\n\t* src/components/cuda/Rules.cuda, src/components/nvml/README,\n\t  src/components/nvml/Rules.nvml, src/components/nvml/linux-nvml.c:\n\t  NVML component README, Rules and code updated to reflect new setup\n\t  policy, relies on PAPI_CUDA_ROOT only. Adds a new override,\n\t  PAPI_NVML_MAIN. Instructions improved in Rules.cuda, Rules.nvml.\n\n2019-08-29  Anthony Castaldo <TonyCastaldo@icl.utk.edu>\n\n\t* src/components/cuda/linux-cuda.c: Corrected comments.\n\t* src/components/cuda/README, src/components/cuda/Rules.cuda,\n\t  src/components/cuda/linux-cuda.c: The changes make the cuda\n\t  component reliant on a single environment variable, PAPI_CUDA_ROOT,\n\t  allowing overrides specified in Rules.cuda if the necessary\n\t  libraries are not in their expected locations. Detailed\n\t  instructions are in README, and for overrides in Rules.cuda.\n\n2019-08-28  Anthony Castaldo <TonyCastaldo@icl.utk.edu>\n\n\t* src/components/rocm/linux-rocm.c: Bug fixes, for missing eventName\n\t  in debug mode; also for failure to clear internal 'usage' flags\n\t  when destroying an event set.\n\n2019-08-14  Carl Love <cel@us.ibm.com>\n\n\t* src/papi_events.csv: Per Carl Love, \"The POWER9 event\n\t  PM_BR_TAKEN_CMPL includes conditional and unconditional branches.\n\t  The equation for event PAPI_BR_NTK should not include the event\n\t  PM_BR_UNCOND as PM_BR_TAKEN_CMPL already counts unconditional\n\t  branches. The POWER9 event PM_LD_REF_L1 includes hits and misses to\n\t  the L1. Thus we should not be adding PM_LS_MISS_L1_ALT when\n\t  calculating PAPI_LD_INS on POWER9.\"  The definitions for these\n\t  preset events were changed accordingly, and their patterns of\n\t  behavior were measured during the execution of performance\n\t  benchmarks on the IBM POWER9 processors on Summit. The patterns of\n\t  behavior for the corresponding events on the Intel Skylake and\n\t  Broadwell processors were measured during the execution of the same\n\t  performance benchmarks. The respective events from each\n\t  architecture behave similarly. In addition, the new definitions\n\t  pass the PAPI validation tests.\n\n2019-08-12  Anthony Castaldo <TonyCastaldo@icl.utk.edu>\n\n\t* src/components/pcp/Rules.pcp, src/components/rocm/Rules.rocm:\n\t  Adding $(LDL) to LDFLAGS in Rules.x files when it was missing, on\n\t  PCP and ROCM components.\n\n2019-08-09  Anthony Castaldo <TonyCastaldo@icl.utk.edu>\n\n\t* src/components/pcp/README, src/components/pcp/Rules.pcp,\n\t  src/components/pcp/linux-pcp.c: The PCP component changed to use\n\t  the new standard for PAPI environment variables; there are now no\n\t  necessary environment variables, and no need to change\n\t  LD_LIBRARY_PATH. The rules file was streamlined.  The code was\n\t  tested on Peak and Summit. We do allow overrides for non-standard\n\t  installations of PCP, the variables PAPI_PCP_ROOT, PAPI_PCP_LIBS,\n\t  PAPI_PCP_INC and PAPI_PCP_LIBNAME can be set by users to specify\n\t  non-standard locations or library names. The README file in\n\t  components/pcp/ contains detailed instructions on their use.\n\n2019-08-08  Anthony Castaldo <TonyCastaldo@icl.utk.edu>\n\n\t* src/components/rocm/README, src/components/rocm/Rules.rocm,\n\t  src/components/rocm/linux-rocm.c,\n\t  src/components/rocm/tests/run_papi.sh,\n\t  src/components/rocm_smi/README,\n\t  src/components/rocm_smi/Rules.rocm_smi, src/components/rocm_smi\n\t  /linux-rocm-smi.c: Components ROCM and ROCM_SMI have been changed\n\t  to adhere to our recent standardization of using environment\n\t  variables. README files are updated with detailed information, and\n\t  we have both simplified and extended the capabilities with new env\n\t  vars. It is simplified because for a standard install of the rocm\n\t  or rocm_smi software puts it in the default directories, PAPI will\n\t  find the libraries and include files without any configure step.\n\t  But it is more powerful because we allow overrides to the defaults,\n\t  including overrides to the necessary library names. We also no\n\t  longer require the LD_LIBRARY_PATH environment variable be\n\t  modified, or exist at all. If it is there and we don't find a\n\t  library in a path given by the user, we will still search it, and\n\t  the default search directories. The Rules.rocm and Rules.rocm_smi\n\t  are changed to use defaults, and their linker commands changed to\n\t  allow the specification of a non-standard library name; e.g. a\n\t  versioned library that does not end in \".so\". These changes were\n\t  tested and verified on the ICL machine Caffeine.\n\n2019-08-04  Frank Winkler <frankbook@Franks-MacBook-Air.local>\n\n\t* src/components/infiniband_umad/Rules.infiniband_umad,\n\t  src/components/lmsensors/Rules.lmsensors: Added \"$(LDL)\" to LDFLAGS\n\t  of components lmsensors and infiniband_umad.  \"libdl\" was missing\n\t  in a previous commit (0f0b74f).\n\t* src/high-level/papi_hl.c: Fixed bug in high-level API.  Function\n\t  PAPI_hl_print_output () caused a segmentation fault when no events\n\t  were recorded.\n\n2019-08-01  Frank Winkler <frankbook@m016.zih.tu-dresden.de>\n\n\t* .../infiniband_umad/Makefile.infiniband_umad.in,\n\t  src/components/infiniband_umad/README,\n\t  .../infiniband_umad/Rules.infiniband_umad,\n\t  src/components/infiniband_umad/configure,\n\t  src/components/infiniband_umad/configure.in, .../infiniband_umad\n\t  /linux-infiniband_umad.c,\n\t  src/components/infiniband_umad/tests/Makefile,\n\t  src/components/lmsensors/Makefile.lmsensors.in,\n\t  src/components/lmsensors/README,\n\t  src/components/lmsensors/Rules.lmsensors,\n\t  src/components/lmsensors/configure,\n\t  src/components/lmsensors/configure.in, src/components/lmsensors\n\t  /linux-lmsensors.c: Changed configuration mechanism for components\n\t  lmsensors and infiband_umad.  We do not use configure scripts\n\t  anymore. Each component is configured via environment variables.\n\t  For compilation: PAPI_[component]_ROOT PAPI_[component]_INCLUDE\n\t  PAPI_[component]_LIB  For runtime: PAPI_[component]_LIBNAME\n\t  Detailed information can be found in the README file of each\n\t  component.\n\n2019-07-25  Anthony Castaldo <TonyCastaldo@icl.utk.edu>\n\n\t* src/components/cuda/README, src/components/cuda/Rules.cuda,\n\t  src/components/cuda/linux-cuda.c,\n\t  src/components/cuda/sampling/Makefile,\n\t  src/components/cuda/tests/Makefile, src/components/nvml/README,\n\t  src/components/nvml/Rules.nvml, src/components/nvml/linux-nvml.c,\n\t  src/components/nvml/tests/Makefile: A continuation of a previous\n\t  commit prematurely pushed. Same commentary:  The CUDA and NVML\n\t  components have a revamped Environment Variable processing; we have\n\t  simplified this for users, made it more flexible, and standardized\n\t  on environment variables beginning with \"PAPI_\".  The NVML\n\t  component used to require a separate configure step, this has been\n\t  eliminated.  Simplification: The only required environment variable\n\t  is now PAPI_CUDA_ROOT, set to the path corresponding to CUDA. Users\n\t  no longer need to update LD_LIBRARY_PATH.  There are several other\n\t  environment variables that can be set to override the defaults we\n\t  would automatically use if only PAPI_CUDA_ROOT is given.  The\n\t  general protocol we now use for naming environment variables is\n\t  PAPI_[component]_[setting]. Examples are:  PAPI_CUDA_STUBS\n\t  (default = ${PAPI_CUDA_ROOT}/lib64/stubs PAPI_CUPTI_LIBS   (default\n\t  = ${PAPI_CUDA_ROOT}/extras/CUPTI/lib64) PAPI_NVML_LIBNAME (default\n\t  = \"libnvidia-ml.so\")  Some possible overrides are processed at\n\t  compile time, the Rules.[component] files now set defaults (For\n\t  cuda and nvml based on PAPI_CUDA_ROOT) for the path to include\n\t  files, or to library files.  Other possible overrides are handled\n\t  at runtime; using environment variables the user can specify\n\t  specific paths to attempt first for each library. If the necessary\n\t  libraries are not found on those paths, the system will still\n\t  attempt to use the LD_LIBRARY_PATH and the default directories\n\t  (/lib64, /usr/lib64).  The \"disabled_reason\" field for components\n\t  has been updated to provide more information when libraries are not\n\t  found.  The README files have been rewritten to reflect this\n\t  protocol, to detail the new possible overrides, and to show the\n\t  order in which they are searched when more than one environment\n\t  variable applies.\n\n2019-07-24  Anthony Castaldo <TonyCastaldo@icl.utk.edu>\n\n\t* src/components/nvml/Makefile.nvml.in,\n\t  src/components/nvml/configure, src/components/nvml/configure.in:\n\t  The CUDA and NVML components have a revamped Environment Variable\n\t  processing; we have simplified this for users, made it more\n\t  flexible, and standardized on environment variables beginning with\n\t  \"PAPI_\".  The NVML component used to require a separate configure\n\t  step, this has been eliminated.  Simplification: The only required\n\t  environment variable is now PAPI_CUDA_ROOT, set to the path\n\t  corresponding to CUDA. Users no longer need to update\n\t  LD_LIBRARY_PATH.  There are several other environment variables\n\t  that can be set to override the defaults we would automatically use\n\t  if only PAPI_CUDA_ROOT is given.  The general protocol we now use\n\t  for naming environment variables is PAPI_[component]_[setting].\n\t  Examples are:  PAPI_CUDA_STUBS   (default =\n\t  ${PAPI_CUDA_ROOT}/lib64/stubs PAPI_CUPTI_LIBS   (default =\n\t  ${PAPI_CUDA_ROOT}/extras/CUPTI/lib64) PAPI_NVML_LIBNAME (default =\n\t  \"libnvidia-ml.so\")  Some possible overrides are processed at\n\t  compile time, the Rules.[component] files now set defaults (For\n\t  cuda and nvml based on PAPI_CUDA_ROOT) for the path to include\n\t  files, or to library files.  Other possible overrides are handled\n\t  at runtime; using environment variables the user can specify\n\t  specific paths to attempt first for each library. If the necessary\n\t  libraries are not found on those paths, the system will still\n\t  attempt to use the LD_LIBRARY_PATH and the default directories\n\t  (/lib64, /usr/lib64).  The \"disabled_reason\" field for components\n\t  has been updated to provide more information when libraries are not\n\t  found.  The README files have been rewritten to reflect this\n\t  protocol, to detail the new possible overrides, and to show the\n\t  order in which they are searched when more than one environment\n\t  variable applies.\n\n2019-07-19  Frank Winkler <frankbook@m016.zih.tu-dresden.de>\n\n\t* src/high-level/papi_hl.c: Removed function \"error_at_line\"\n\t  (declared in error.h), since it is not portable.  Fixed warning\n\t  \"implicit declaration of function error_at_line\".\n\n2019-07-17  Anthony Castaldo <TonyCastaldo@icl.utk.edu>\n\n\t* src/components/nvml/README: Changes explaining the issues with\n\t  libnvidia-ml.so in detail; and the new facility for changing the\n\t  default name using the environment variable PAPI_NVML_LIBNAME.\n\t* src/components/nvml/Rules.nvml, src/components/nvml/linux-nvml.c,\n\t  src/utils/papi_component_avail.c: linux-nvml.c is changed to allow\n\t  the nvml library name to be set by an environment variable,\n\t  PAPI_NVML_LIBNAME. If this is not present, the default 'libnvidia-\n\t  ml.so' is used. Also, misspellings in error messages were\n\t  corrected.  Rules.nvml: A previous method used a -D #define during\n\t  the compile of linux-nvml.c to change the default name. This method\n\t  was eliminated.  utils/papi_component_avail.c a typographic error\n\t  in an error message was corrected.\n\n2019-07-15  Anthony Castaldo <TonyCastaldo@icl.utk.edu>\n\n\t* src/utils/papi_component_avail.c: To avoid confusion, we no longer\n\t  print an empty \"PMUs supported:\" line for components for which\n\t  Performance Monitoring Units do not apply (or are not exposed\n\t  through its device interfaces). We also corrected minor bugs in\n\t  computing the display length to limit output lines to 130\n\t  characters (when listing PMUs); this was most evident on the\n\t  perf_event_uncore component.\n\n2019-07-12  Anthony Castaldo <TonyCastaldo@icl.utk.edu>\n\n\t* src/components/rocm_smi/README, src/components/rocm_smi/linux-rocm-\n\t  smi.c, .../rocm_smi/tests/rocm_command_line.cpp,\n\t  src/components/rocm_smi/tests/rocm_smi_all.cpp: linux-rocm-smi.c\n\t  (for the rocm_smi component) was fixed to not expose globals other\n\t  than the _rocm_smi_vector.  The src/components/rocm_smi/README file\n\t  was updated to provide more information on the LD_LIBRARY_PATH\n\t  required, and the utilities rocm_command_line.cpp and\n\t  rocm_smi_all.cpp in the tests/ directory were updated to report\n\t  more information.\n\n2019-06-27  Frank Winkler <frankbook@m016.zih.tu-dresden.de>\n\n\t* src/high-level/papi_hl.c: Added multiplexing support for high-level\n\t  API.  Mutliplexing of cpu core components can be enabled via the\n\t  environment variable PAPI_MULTIPLEX.\n\n2019-06-26  Daniel Barry <dbarry@vols.utk.edu>\n\n\t* src/ctests/zero_omp.c, src/papi_vector.c: Changed the dummy\n\t  function call in papi_vector.c and created a function to wrap the\n\t  call to omp_get_thread_num() in ctests/zero_omp.c. These allow the\n\t  function castings in the respective files to operate properly\n\t  without warnings from GCC 8.3.0. These changes were tested on the\n\t  Intel Haswell architecture.\n\n2019-06-25  Anthony Castaldo <TonyCastaldo@icl.utk.edu>\n\n\t* src/components/nvml/PeakConfigure.sh, src/components/nvml/README,\n\t  src/components/nvml/Rules.nvml, src/components/nvml/linux-nvml.c:\n\t  linux-nvml.c is modified to accept an alternate name for the nvml\n\t  library, which will default to the standard 'libnvidia-ml.so'. This\n\t  is necessary on a system (Summit in particular) that doesn't have\n\t  the standard link file to the current versioned lib. It will also\n\t  provide flexibility for testing previous versions or new versions\n\t  of the library. The library file name can be specified in\n\t  Rules.nvml, as a compiler-line Define of NVML_LIBNAME.  Rules.nvml\n\t  has comments added, one of which is an example of how to specify\n\t  NVML_LIBNAME. Otherwise it is unchanged; and the library name used\n\t  will default to 'libnvidia-ml.so'.  README has been updated to\n\t  describe this new capability, and for ICL staff contains examples\n\t  of what works on Summit.  PeakConfigure.sh had a typo that was\n\t  corrected.\n\n2019-06-18  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/components/rapl/tests/rapl_basic.c: rapl: quiet a strncpy()\n\t  warning in the rapl_basic test\n\t* src/linux-common.c, src/linux-memory.c, src/papi_internal.c,\n\t  src/papi_libpfm4_events.c: papi: fix some strncpy() related\n\t  warnings reported by gcc 8.3\n\n2019-06-10  Daniel Barry <dbarry@vols.utk.edu>\n\n\t* src/components/perf_event_uncore/tests/perf_event_uncore_cbox.c:\n\t  Changed the sprintf() call to snprintf() and added an if-statement\n\t  to check whether the number of characters intended to be written to\n\t  the destination buffer exceed the size of the buffer. This prevents\n\t  GCC 8.3.0 from warning that the destination buffer may not be large\n\t  enough to store the contents of the source buffers. These changes\n\t  were tested on the Intel Haswell architecture.\n\n2019-06-05  Daniel Barry <dbarry@vols.utk.edu>\n\n\t* src/components/perf_event_uncore/tests/perf_event_uncore.c: Added a\n\t  second buffer in the perf_event_uncore test. This prevents GCC 8\n\t  from complaining about the source and destination buffers\n\t  overlapping. Per the sprintf man-page (release 3.53 of the Linux\n\t  man-pages project), \"the standards explicitly note that the results\n\t  are undefined if source and destination buffers overlap when\n\t  calling sprintf().\"  Since the second buffer is only present in a\n\t  test program, this change will not create memory overhead to user\n\t  programs which use PAPI. These changes were tested on the Intel\n\t  Haswell architecture.\n\n2019-06-05  Anthony Castaldo <TonyCastaldo@icl.utk.edu>\n\n\t* src/components/rocm_smi/linux-rocm-smi.c: Added a direct file\n\t  system search for AMD GPU peripherals; vendor ID 0x1002. We search\n\t  up to 64 /sys/class/drm/card?/device/vendor files; (card0, card1,\n\t  ... card 63). Also corrected a typo in an event name. Tested and\n\t  worked on ICL Caffeine system; correctly excluded card0 (display\n\t  card) and found two AMD GPUs on card1, card2.\n\n2019-05-25  Yunqiang Su <wzssyqa@gmail.com>\n\n\t* src/linux-lock.h: [mips] replace beqzl with beqzc for r6\n\n2019-05-20  Daniel Barry <dbarry@vols.utk.edu>\n\n\t* src/papi_events.csv: I have added PAPI POWER9 event definitions for\n\t  PAPI_L2_DCR, PAPI_L2_DCW, PAPI_BR_CN, PAPI_BR_NTK, PAPI_BR_UCN, and\n\t  PAPI_BR_TKN. These events have been tested. Their patterns of\n\t  behavior were measured during the execution of performance\n\t  benchmarks on Summit's POWER9 processors. The patterns of behavior\n\t  for the corresponding events on Intel Haswell processors were\n\t  measured during the execution of the same performance benchmarks.\n\t  The respective events from each architecture behave similarly.\n\n2019-05-17  Anthony Castaldo <TonyCastaldo@icl.utk.edu>\n\n\t* src/components/rocm_smi/linux-rocm-smi.c: Added missing\n\t  \"rsmi_init(0)\" call to component_init() function.\n\t* src/components/rocm/README, src/components/rocm/Rules.rocm,\n\t  src/components/rocm/linux-rocm.c: Modifications to support indexed\n\t  variables; requires different names be used for PAPI users and the\n\t  request to the RocProfiler (it interprets the index within the\n\t  name). Updated notes in README, and additional potential -I include\n\t  paths in Rules.rocm.\n\n2019-05-14  Anthony Castaldo <tonycastaldo@saturn.icl.utk.edu>\n\n\t* src/components/cuda/linux-cuda.c: Improved error reporting when\n\t  libraries are not found, or the cuda initialization function fails.\n\t  No changes to function.\n\n2019-05-07  Heike Jagode <jagode@icl.utk.edu>\n\n\t* src/components/appio/tests/iozone/Gnuplot.txt,\n\t  src/components/appio/tests/iozone/gnu3d.dem,\n\t  src/components/powercap/tests/powercap_limit.c,\n\t  src/components/vmware/VMwareComponentDocument.txt: More clean up of\n\t  carriage return character (^M) throughout the code base.  Thanks to\n\t  Steve Kaufmann!\n\n2019-05-07  Anthony Castaldo <TonyCastaldo@icl.utk.edu>\n\n\t* src/components/rocm_smi/linux-rocm-smi.c,\n\t  src/components/rocm_smi/rocm_smi.h,\n\t  src/components/rocm_smi/tests/Makefile,\n\t  src/components/rocm_smi/tests/ROCM_SMI_Makefile: I fixed linux-\n\t  rocm-smi.c to include an event per device called\n\t  rocm_smi:::device=?:busy_percent; I overlooked this event in the\n\t  first draft of the component.  I added a note to rocm_smi.h; we\n\t  cannot use the distributed version of this file; we have a compile\n\t  error on one of the include files <stdinit.h> that is not\n\t  necessary; so we comment it out.  I created a Makefile for the\n\t  rocm_smi/tests/ directory, it is just a placeholder until we\n\t  develop some standardized tests of the rocm_smi component; but\n\t  necessary to prevent an error during system 'make'.  I added\n\t  rocm_command_line.out to the ROCM_SMI_Makefile. This is to make\n\t  non-standardized tests; and can be used as  make -f\n\t  ROCM_SMI_Makefile <targetname>\n\n2019-05-07  Heike Jagode <jagode@icl.utk.edu>\n\n\t* src/Makefile.in, src/Makefile.inc, src/Rules.perfmon2,\n\t  src/configure.in: Clean up of carriage return character (^M) from\n\t  previous patch (commit 5434010).  Thanks to Steve Kaufmann from\n\t  Cray!\n\n2019-05-06  Andreas Beckmann <a.beckmann@fz-juelich.de>\n\n\t* src/Makefile.in, src/Makefile.inc, src/Rules.perfmon2,\n\t  src/configure, src/configure.in: [PATCH] set SONAME to\n\t  libpapi.so.$(PAPIVER).$(PAPIREV)  The version check in\n\t  PAPI_library_init() requires matching PAPI_VER_CURRENT, therefore\n\t  libpapi.so.5 from papi-5.6.x and papi-5.7.x are not\n\t  interchangeable, but require applications to be recompiled.  Change\n\t  the SONAME to contain the two version components that define\n\t  PAPI_VER_CURRENT, thereafter upgrading the shared library to a new\n\t  version does no longer break existing applications (which will pick\n\t  up the new SONAME upon recompilation).  Introduce a new variable\n\t  PAPISOVER and use it in all places where the SONAME is being used.\n\t  drop unused symlinks with three version components:\n\t  $(PAPIVER).$(PAPIREV).$(PAPIAGE)\n\n2019-05-03  Daniel Barry <dbarry@saturn.icl.utk.edu>\n\n\t* src/ctests/profile_twoevents.c: Prevented another warning about\n\t  buffer size potentially being to small.\n\n2019-04-25  Frank Winkler <frankbook@m016.zih.tu-dresden.de>\n\n\t* src/high-level/papi_hl.c: Fixed \"format-overflow\" warning detected\n\t  by gcc/8.1.0.\n\n2019-04-24  Anthony Castaldo <TonyCastaldo@icl.utk.edu>\n\n\t* src/components/rocm/Rules.rocm, src/components/rocm/linux-rocm.c,\n\t  src/components/rocm_smi/README,\n\t  src/components/rocm_smi/Rules.rocm_smi, src/components/rocm_smi\n\t  /linux-rocm-smi.c, src/components/rocm_smi/rocm_smi.h,\n\t  src/components/rocm_smi/tests/ROCM_SMI_Makefile,\n\t  .../rocm_smi/tests/rocm_command_line.cpp,\n\t  src/components/rocm_smi/tests/rocm_smi_all.cpp,\n\t  .../rocm_smi/tests/rocm_smi_writeTests.cpp: Major addition: a\n\t  component to access the rocm_smi library; this is the System\n\t  Management Interface for AMD GPU devices. It allows monitoring of\n\t  hardware elements; like power consumption, memory usage, PCIe\n\t  throughput, fan speed, etc. It allows control for some hardware\n\t  functions as well, via PAPI_write(), although these are untested\n\t  (write requires root privileges to test). Included here are the\n\t  component code, a tester for all readable events, and an incomplete\n\t  tester for writing control values.  The tests are cpp; this is\n\t  required for the AMD 'HIPP' compiler to process an AMD Kernel that\n\t  can exercise the GPU itself. The rules and exports are bit\n\t  complicated; for development the rocm_smi_lib was installed and\n\t  built in my user directory; in production it would be in a system\n\t  directory.\n\n2019-04-24  Frank Winkler <frankbook@m016.zih.tu-dresden.de>\n\n\t* src/high-level/papi_hl.c: Fixed warnings detected by gcc/8.3.0 when\n\t  using \"-Wrestrict\" or \"-Wall\".\n\t* src/high-level/papi_hl.c: Replaced \"get_current_dir_name()\" with\n\t  \"getcwd(NULL,0)\".  \"get_current_dir_name()\" is only GNU specific.\n\t* src/run_tests.sh: Replaced bash statements with shell statements.\n\t  Some systems do not have a bash.\n\n2019-04-22  Frank Winkler <frankbook@franks-air.localdomain>\n\n\t* src/high-level/papi_hl.c: Corrected data type declaration according\n\t  to the return value of C library function fgetc.\n\n2019-04-18  Daniel Barry <dbarry@saturn.icl.utk.edu>\n\n\t* src/ctests/derived.c, src/ctests/multiattach.c,\n\t  src/ctests/multiattach2.c, src/ctests/reset.c,\n\t  src/ctests/reset_multiplex.c, src/ctests/zero_attach.c,\n\t  src/ctests/zero_flip.c: Prevented warnings about buffer sizes of\n\t  length PAPI_MAX_STR_LEN potentially being too small.\n\n2019-04-18  Frank Winkler <frankbook@m016.zih.tu-dresden.de>\n\n\t* doc/Doxyfile-man3, doc/Makefile, src/Makefile.inc,\n\t  src/components/appio/tests/appio_test_blocking.c,\n\t  .../appio/tests/appio_test_fread_fwrite.c,\n\t  src/components/appio/tests/appio_test_pthreads.c,\n\t  src/components/appio/tests/appio_test_read_write.c,\n\t  src/components/appio/tests/appio_test_recv.c,\n\t  src/components/appio/tests/appio_test_seek.c,\n\t  src/components/appio/tests/appio_test_select.c,\n\t  src/components/appio/tests/appio_test_socket.c,\n\t  src/components/appio/tests/init_fini.c,\n\t  src/ctests/Makefile.recipies, src/ctests/api.c, src/ctests/flops.c,\n\t  src/ctests/high-level.c, src/ctests/high-level2.c,\n\t  src/ctests/hl_rates.c, src/ctests/ipc.c, src/ctests/matrix-hl.c,\n\t  src/ctests/mpi_hl.c, src/ctests/mpi_omp_hl.c, src/ctests/omp_hl.c,\n\t  src/ctests/pthread_hl.c, src/ctests/serial_hl.c,\n\t  src/ctests/serial_hl_advanced.c, src/ctests/serial_hl_ll_comb.c,\n\t  src/ctests/serial_hl_ll_comb2.c, src/ftests/Makefile.recipies,\n\t  src/ftests/flops.F, src/ftests/fmatrixpapi.F,\n\t  src/ftests/fmatrixpapi2.F, src/ftests/highlevel.F,\n\t  src/ftests/serial_hl.F, src/ftests/serial_hl_advanced.F, src/high-\n\t  level/papi_hl.c, src/high-level/scripts/papi_hl_output_writer.py,\n\t  src/papi.c, src/papi.h, src/papi_debug.h, src/papi_fwrappers.c,\n\t  src/papi_hl.c, src/papi_hl.h, src/run_tests.sh,\n\t  src/run_tests_exclude.txt, src/validation_tests/Makefile.recipies,\n\t  src/validation_tests/flops_validation_hl.c: Replaced old high-level\n\t  API with a new high-level API.  The new high-level API provides the\n\t  ability to record performance events within instrumented code\n\t  sections, called regions, of serial, multi-processing (MPI, SHMEM)\n\t  and thread (OpenMP, Pthreads) parallel applications. Events to be\n\t  recorded are determined via an environment variable that lists both\n\t  preset and native events separated by commas. This enables the\n\t  programmer to perform different measurements without recompiling.\n\t  In addition, the programmer does not need to take care of printing\n\t  performance events since a JSON output is generated at the end of\n\t  each measurement.  Main changes: - Removed old high-level API\n\t  including all test files. - Added new high-level API including a\n\t  python script that merges results from several MPI ranks. - Added\n\t  Doxygen documentation for new high-level API. - Added high-level\n\t  tests for c and fortran. - Added high-level flops validation test.\n\t  - Replaced old high-level tests with new high-level tests in appio\n\t  component.\n\n2019-04-02  Anthony Castaldo <tonycastaldo@caffeine.icl.utk.edu>\n\n\t* src/components/rocm/linux-rocm.c,\n\t  src/components/rocm/tests/rocm_all.cpp: NOTE: This component is\n\t  still not functional! Added missing code to prevent hsa_shut_down()\n\t  call from segfaulting. Changed skip table for testing code\n\t  rocm_all.cpp.\n\n2019-04-01  Al Grant <algrant109@gmail.com>\n\n\t* src/linux-memory.c: The logic in linux-memory.c\n\t  generic_get_memory_info() isn't correct.  It looks at the\n\t  cpu0/cache node and iterates through the caches. The intention is\n\t  to collect information about caches at each level. There may be\n\t  multiple caches at a given level (typically at L1 there will be I\n\t  and D). PAPI's data structure allows for this. There is a 'level\n\t  count' that is incremented so that multiple caches can be collected\n\t  per level.  The bug is in the lines  if (level != last_level) {\n\t  level_count = 0; last_level=level; } else { level_count++; }  This\n\t  assumes that for a given level, you see all the caches at that\n\t  level, then you go to the next level. But in fact sysfs may return\n\t  the caches in random order.  An actual example: index2: level 2,\n\t  unified cache index0: level 1, data cache index3: level 3, unified\n\t  cache index1: level 1, instruction cache  Because index1 is at a\n\t  different level from index3, level_count will be reset to 0. So in\n\t  PAPI's structures, the L1I information will overwrite the L1D\n\t  information. The knowledge about L1D will be lost.\n\n2019-03-28  Anthony Castaldo <TonyCastaldo@instinct.nic.uoregon.edu>\n\n\t* src/components/rocm/README, src/components/rocm/linux-rocm.c,\n\t  src/components/rocm/tests/Makefile,\n\t  src/components/rocm/tests/ROCM_Makefile,\n\t  src/components/rocm/tests/rocm_all.cpp,\n\t  src/components/rocm/tests/rocm_command_line.c,\n\t  src/components/rocm/tests/run_papi.sh,\n\t  src/components/rocm/tests/square.cpp,\n\t  src/components/rocm/tests/square.cu,\n\t  src/components/rocm/tests/square.hipref.cpp: linux-rocm.c updated\n\t  with PAPI standard component function names, beginning '_rocm', and\n\t  events named '..:device=n:...' instead of 'device:n'. New files and\n\t  utilities are added in the test/ directory. The ROCM_Makefile is\n\t  used to compile cpp code using the AMD HIPCC compiler; e.g. 'make\n\t  -f ROCM_Makefile rocm_all.out', in order to compile code that uses\n\t  the AMD GPUs.\n\n2019-03-18  Anthony Castaldo <TonyCastaldo@instinct.nic.uoregon.edu>\n\n\t* src/components/rocm/linux-rocm.c: This is the ROCM component\n\t  (linux_rocm.c) with the minimal changes needed to compile with the\n\t  PAPI standard GCC flags and settings. This version is functional;\n\t  it shows up on papi_components_avail, and papi_native_avail shows\n\t  rocm::: events. However, the compile still produces warnings for\n\t  unused variables (they are used in debug mode but the code using\n\t  them is suppressed in production mode). These are corrected in the\n\t  next commit; and a '/tests' directory will be added.\n\n2019-03-18  Evgeny Shcherbakov <Evgeny.Shcherbakov@amd.com>\n\n\t* src/components/rocm/README, src/components/rocm/Rules.rocm,\n\t  src/components/rocm/linux-rocm.c: These are the original files\n\t  produced by Evgeny Shcherbakov for the ROCM PAPI component; this\n\t  component allows PAPI to access to AMD GPU events. Note that linux-\n\t  rocm.c will not compile using the PAPI default settings for GCC; it\n\t  has 3 lines of code that require a C99 flag (e.g. -std=gnu99). We\n\t  do not wish to mix standards, so the next commit will revise these\n\t  lines to standard C that will compile clean with our standard\n\t  settings.\n\n2019-03-07  Heike Jagode <jagode@icl.utk.edu>\n\n\t* doc/Doxyfile-common, papi.spec, src/Makefile.in, src/configure,\n\t  src/configure.in, src/papi.h: Updated version to 5.7.1 after the\n\t  release.\n\n2019-03-04  Heike Jagode <jagode@icl.utk.edu>\n\n\t* RELEASENOTES.txt, release_procedure.txt: Minor updates to release\n\t  procedure text.\n\t* RELEASENOTES.txt: Updated release notes for 5.7.0 release.\n\n2019-02-22  Anthony Castaldo <tonycastaldo@harry.icl.utk.edu>\n\n\t* doc/Doxyfile-common, man/man1/PAPI_derived_event_files.1,\n\t  man/man1/papi_avail.1, man/man1/papi_clockres.1,\n\t  man/man1/papi_command_line.1, man/man1/papi_component_avail.1,\n\t  man/man1/papi_cost.1, man/man1/papi_decode.1,\n\t  man/man1/papi_error_codes.1, man/man1/papi_event_chooser.1,\n\t  man/man1/papi_hybrid_native_avail.1, man/man1/papi_mem_info.1,\n\t  man/man1/papi_multiplex_cost.1, man/man1/papi_native_avail.1,\n\t  man/man1/papi_version.1, man/man1/papi_xml_event_info.1,\n\t  man/man3/PAPIF_accum.3, man/man3/PAPIF_accum_counters.3,\n\t  man/man3/PAPIF_add_event.3, man/man3/PAPIF_add_events.3,\n\t  man/man3/PAPIF_add_named_event.3,\n\t  man/man3/PAPIF_assign_eventset_component.3,\n\t  man/man3/PAPIF_cleanup_eventset.3,\n\t  man/man3/PAPIF_create_eventset.3,\n\t  man/man3/PAPIF_destroy_eventset.3, man/man3/PAPIF_enum_event.3,\n\t  man/man3/PAPIF_epc.3, man/man3/PAPIF_event_code_to_name.3,\n\t  man/man3/PAPIF_event_name_to_code.3, man/man3/PAPIF_flips.3,\n\t  man/man3/PAPIF_flops.3, man/man3/PAPIF_get_clockrate.3,\n\t  man/man3/PAPIF_get_dmem_info.3, man/man3/PAPIF_get_domain.3,\n\t  man/man3/PAPIF_get_event_info.3, man/man3/PAPIF_get_exe_info.3,\n\t  man/man3/PAPIF_get_granularity.3,\n\t  man/man3/PAPIF_get_hardware_info.3, man/man3/PAPIF_get_multiplex.3,\n\t  man/man3/PAPIF_get_preload.3, man/man3/PAPIF_get_real_cyc.3,\n\t  man/man3/PAPIF_get_real_nsec.3, man/man3/PAPIF_get_real_usec.3,\n\t  man/man3/PAPIF_get_virt_cyc.3, man/man3/PAPIF_get_virt_usec.3,\n\t  man/man3/PAPIF_ipc.3, man/man3/PAPIF_is_initialized.3,\n\t  man/man3/PAPIF_library_init.3, man/man3/PAPIF_lock.3,\n\t  man/man3/PAPIF_multiplex_init.3, man/man3/PAPIF_num_cmp_hwctrs.3,\n\t  man/man3/PAPIF_num_counters.3, man/man3/PAPIF_num_events.3,\n\t  man/man3/PAPIF_num_hwctrs.3, man/man3/PAPIF_perror.3,\n\t  man/man3/PAPIF_query_event.3, man/man3/PAPIF_query_named_event.3,\n\t  man/man3/PAPIF_read.3, man/man3/PAPIF_read_ts.3,\n\t  man/man3/PAPIF_register_thread.3, man/man3/PAPIF_remove_event.3,\n\t  man/man3/PAPIF_remove_events.3,\n\t  man/man3/PAPIF_remove_named_event.3, man/man3/PAPIF_reset.3,\n\t  man/man3/PAPIF_set_cmp_domain.3,\n\t  man/man3/PAPIF_set_cmp_granularity.3, man/man3/PAPIF_set_debug.3,\n\t  man/man3/PAPIF_set_domain.3, man/man3/PAPIF_set_event_domain.3,\n\t  man/man3/PAPIF_set_granularity.3, man/man3/PAPIF_set_inherit.3,\n\t  man/man3/PAPIF_set_multiplex.3, man/man3/PAPIF_shutdown.3,\n\t  man/man3/PAPIF_start.3, man/man3/PAPIF_start_counters.3,\n\t  man/man3/PAPIF_state.3, man/man3/PAPIF_stop.3,\n\t  man/man3/PAPIF_stop_counters.3, man/man3/PAPIF_thread_id.3,\n\t  man/man3/PAPIF_thread_init.3, man/man3/PAPIF_unlock.3,\n\t  man/man3/PAPIF_unregister_thread.3, man/man3/PAPIF_write.3,\n\t  man/man3/PAPI_accum.3, man/man3/PAPI_accum_counters.3,\n\t  man/man3/PAPI_add_event.3, man/man3/PAPI_add_events.3,\n\t  man/man3/PAPI_add_named_event.3,\n\t  man/man3/PAPI_addr_range_option_t.3, man/man3/PAPI_address_map_t.3,\n\t  man/man3/PAPI_all_thr_spec_t.3,\n\t  man/man3/PAPI_assign_eventset_component.3, man/man3/PAPI_attach.3,\n\t  man/man3/PAPI_attach_option_t.3, man/man3/PAPI_cleanup_eventset.3,\n\t  man/man3/PAPI_component_info_t.3, man/man3/PAPI_cpu_option_t.3,\n\t  man/man3/PAPI_create_eventset.3, man/man3/PAPI_debug_option_t.3,\n\t  man/man3/PAPI_destroy_eventset.3, man/man3/PAPI_detach.3,\n\t  man/man3/PAPI_disable_component.3,\n\t  man/man3/PAPI_disable_component_by_name.3,\n\t  man/man3/PAPI_dmem_info_t.3, man/man3/PAPI_domain_option_t.3,\n\t  man/man3/PAPI_enum_cmp_event.3, man/man3/PAPI_enum_event.3,\n\t  man/man3/PAPI_epc.3, man/man3/PAPI_event_code_to_name.3,\n\t  man/man3/PAPI_event_info_t.3, man/man3/PAPI_event_name_to_code.3,\n\t  man/man3/PAPI_exe_info_t.3, man/man3/PAPI_flips.3,\n\t  man/man3/PAPI_flops.3, man/man3/PAPI_get_cmp_opt.3,\n\t  man/man3/PAPI_get_component_index.3,\n\t  man/man3/PAPI_get_component_info.3, man/man3/PAPI_get_dmem_info.3,\n\t  man/man3/PAPI_get_event_component.3,\n\t  man/man3/PAPI_get_event_info.3,\n\t  man/man3/PAPI_get_eventset_component.3,\n\t  man/man3/PAPI_get_executable_info.3,\n\t  man/man3/PAPI_get_hardware_info.3, man/man3/PAPI_get_multiplex.3,\n\t  man/man3/PAPI_get_opt.3, man/man3/PAPI_get_overflow_event_index.3,\n\t  man/man3/PAPI_get_real_cyc.3, man/man3/PAPI_get_real_nsec.3,\n\t  man/man3/PAPI_get_real_usec.3, man/man3/PAPI_get_shared_lib_info.3,\n\t  man/man3/PAPI_get_thr_specific.3, man/man3/PAPI_get_virt_cyc.3,\n\t  man/man3/PAPI_get_virt_nsec.3, man/man3/PAPI_get_virt_usec.3,\n\t  man/man3/PAPI_granularity_option_t.3, man/man3/PAPI_hw_info_t.3,\n\t  man/man3/PAPI_inherit_option_t.3, man/man3/PAPI_ipc.3,\n\t  man/man3/PAPI_is_initialized.3, man/man3/PAPI_itimer_option_t.3,\n\t  man/man3/PAPI_library_init.3, man/man3/PAPI_list_events.3,\n\t  man/man3/PAPI_list_threads.3, man/man3/PAPI_lock.3,\n\t  man/man3/PAPI_mh_cache_info_t.3, man/man3/PAPI_mh_info_t.3,\n\t  man/man3/PAPI_mh_level_t.3, man/man3/PAPI_mh_tlb_info_t.3,\n\t  man/man3/PAPI_mpx_info_t.3, man/man3/PAPI_multiplex_init.3,\n\t  man/man3/PAPI_multiplex_option_t.3, man/man3/PAPI_num_cmp_hwctrs.3,\n\t  man/man3/PAPI_num_components.3, man/man3/PAPI_num_counters.3,\n\t  man/man3/PAPI_num_events.3, man/man3/PAPI_num_hwctrs.3,\n\t  man/man3/PAPI_option_t.3, man/man3/PAPI_overflow.3,\n\t  man/man3/PAPI_perror.3, man/man3/PAPI_preload_info_t.3,\n\t  man/man3/PAPI_profil.3, man/man3/PAPI_query_event.3,\n\t  man/man3/PAPI_query_named_event.3, man/man3/PAPI_read.3,\n\t  man/man3/PAPI_read_counters.3, man/man3/PAPI_read_ts.3,\n\t  man/man3/PAPI_register_thread.3, man/man3/PAPI_remove_event.3,\n\t  man/man3/PAPI_remove_events.3, man/man3/PAPI_remove_named_event.3,\n\t  man/man3/PAPI_reset.3, man/man3/PAPI_set_cmp_domain.3,\n\t  man/man3/PAPI_set_cmp_granularity.3, man/man3/PAPI_set_debug.3,\n\t  man/man3/PAPI_set_domain.3, man/man3/PAPI_set_granularity.3,\n\t  man/man3/PAPI_set_multiplex.3, man/man3/PAPI_set_opt.3,\n\t  man/man3/PAPI_set_thr_specific.3, man/man3/PAPI_shlib_info_t.3,\n\t  man/man3/PAPI_shutdown.3, man/man3/PAPI_sprofil.3,\n\t  man/man3/PAPI_sprofil_t.3, man/man3/PAPI_start.3,\n\t  man/man3/PAPI_start_counters.3, man/man3/PAPI_state.3,\n\t  man/man3/PAPI_stop.3, man/man3/PAPI_stop_counters.3,\n\t  man/man3/PAPI_strerror.3, man/man3/PAPI_thread_id.3,\n\t  man/man3/PAPI_thread_init.3, man/man3/PAPI_unlock.3,\n\t  man/man3/PAPI_unregister_thread.3, man/man3/PAPI_write.3,\n\t  papi.spec, release_procedure.txt, src/Makefile.in,\n\t  src/configure.in, src/papi.h: Fixing updates to manual; incorrectly\n\t  done for release 5.7.0.0.\n\n2019-02-21  Anthony Castaldo <tonycastaldo@harry.icl.utk.edu>\n\n\t* release_procedure.txt: Updated release procedure with additional\n\t  instructions on final steps.\n\n2019-02-18  Anthony Castaldo <tonycastaldo@harry.icl.utk.edu>\n\n\t* doc/Doxyfile-common, papi.spec, src/Makefile.in, src/configure.in,\n\t  src/papi.h: Changed version to 5.7.1 after release.\n\t* release_procedure.txt: Corrected directory entry typo.\n\t* ChangeLogP570.txt, RELEASENOTES.txt: New ChangeLogP570.txt for new\n\t  release, updated RELEASENOTES.txt\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-papi-6.0.0.1-gmm3tef6bggycxgzrtmq2ejaggc2ozfb/spack-src/ChangeLogP560.txt": "Tue Dec 5 20:10:50 2017 -0800  William Cohen <wcohen@redhat.com>\n\n\t* src/libpfm4/lib/events/power9_events.h,\n\t  src/libpfm4/tests/validate_power.c: Update libpfm4 Current with\n\t  commit 206dea666e7c259c7ca53b16f934660344293475  Ensure unique\n\t  names for IBM Power 9 events  Older versions of PAPI use the event\n\t  name to look up the libpfm event number when doing the enumeration\n\t  of the available events.  If there were multiple events with the\n\t  same name in libpfm, the earliest one would be selected.  This\n\t  selection would cause the enumeration of events in\n\t  papi_native_avail to get stuck looping on the first duplicated\n\t  named event in a pmu.  In the case of IBM Power 9 the enumeration\n\t  would get stuck on PM_CO0_BUSY. Gave each event a unique name to\n\t  avoid this unfortunate behavior.\n\n2017-11-16  Will Schmidt <will_schmidt@vnet.ibm.com>\n\n\t* src/papi_events.csv: revised papi_derived patch.  [PATCH, papi]\n\t  Updated derived entries for power9.  This is a re-implementation of\n\t  the patch that Will Cohen posted earlier, which uses the (newly\n\t  defined) PM_LD_MISS_ALT entry instead of the PM_LD_MISS_FIN .\n\t  Thanks, -Will\n\n2017-12-05  Heike Jagode (jagode@icl.utk.edu) <jagode@saturn.icl.utk.edu>\n\n\t* release_procedure.txt: Updated notes for release procedure.\n\n2017-12-05  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/extras.c: extras.c: add string.h include to make the ffsll\n\t  warning go away\n\n2017-12-04  Heike Jagode (jagode@icl.utk.edu) <jagode@saturn.icl.utk.edu>\n\n\t* src/configure, src/configure.in: Fixed configure bug:  Once ffsll\n\t  support is detected, set HAVE_FFSLL to 1 in config.h.  Tested\n\t  without configure flag --with-ffsll, with --with-ffsll=yes, --with-\n\t  ffsll=no.\n\n2017-12-04  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/ctests/Makefile.recipies, src/ctests/locks_pthreads.c: ctests:\n\t  locks_pthreads: adjust run count again  linear slowdown makes\n\t  things run really quickly. This patch scales it down by the square\n\t  root of the number of cores which is maybe a better compromise.\n\t* src/ctests/locks_pthreads.c: ctests: locks_pthreads, minor cleanups\n\n2017-11-20  William Cohen <wcohen@redhat.com>\n\n\t* src/ctests/locks_pthreads.c: Keep locks_pthreads test's amount of\n\t  work reasonable on many core machines  The runtime of\n\t  locks_pthreads test scaled by the number of processors on the\n\t  machine because of the serialized increment operation in the test.\n\t  As more machines are available with 100+ processors the runtime of\n\t  locks_pthreads is becoming execessive.  Revised the test to specify\n\t  the approximate total number of iterations and split the work the\n\t  threads.\n\nFri Dec 4 11:31:46 2015 -0500  sangamesh <sragate@vols.utk.edu>\n\n\t* src/extras.c, src/papi.h: Revert change that added ffsll to papi.h\n\t  This reverts commit 2f1ec33a9e585df1b6343a0ea735f79974c080df.\n\t  commit 2f1ec33a9e585df1b6343a0ea735f79974c080df  changed #if\n\t  (!defined(HAVE_FFSLL) || defined(__bgp__)) int ffsll( long long lli\n\t  ); #endif --- to --- extern int ffsll( long long lli  in extras.c\n\t  to avoid warning when --with-ffsll is used as config option\n\nThu Apr 20 11:31:38 2017 -0400  Stephen Wood <swood@icl.utk.edu>\n\n\t* src/extras.c, src/papi.h: revert part of patch that added extra\n\t  attributes to ffsll  This manually reverts part of:  commit\n\t  9e199a8aee48f5a2c62d891f0b2c1701b496a9ca  cast pointers\n\t  appropriately to avoid warnings and errors\n\nSun Dec 3 09:42:44 2017 -0800  Will Schmidt <will_schmidt@vnet.ibm.com>\n\n\t* src/libpfm4/lib/events/power9_events.h,\n\t  src/libpfm4/tests/validate_power.c: Updated libpfm4  Current with:\n\t  ---------------- commit ed3f51c4690685675cf2766edb90acbc0c1cdb67\n\t  (HEAD -> master, origin/master, origin/HEAD)  Add alternate event\n\t  numbers for power9.  I had previously missed adding the _ALT\n\t  entries, which allow some events to be specified on different\n\t  counters. This patch fills those in.  This patch also adds a few\n\t  validation tests for the ALT events.  ----------------\n\n2017-11-28  Heike Jagode (jagode@icl.utk.edu) <jagode@saturn.icl.utk.edu>\n\n\t* src/utils/papi_avail.c, src/utils/papi_native_avail.c: Fixed\n\t  utility option inconsistencies between papi_avail and\n\t  papi_native_avail. There are more inconsistencies with other PAPI\n\t  utilities, which will be addressed eventually.\n\n2017-11-28  Heike Jagode <jagode@icl.utk.edu>\n\n\t* README.md: README.md edited online with Bitbucket\n\t* README.md: README.md edited online with Bitbucket\n\t* README.md: README.md edited online with Bitbucket\n\t* README.md: README.md edited online with Bitbucket\n\n2017-11-27  Heike Jagode <jagode@icl.utk.edu>\n\n\t* src/components/powercap/linux-powercap.c: More clean-ups and\n\t  checking of return values.\n\nMon Nov 13 23:15:53 2017 -0800  Thomas Richter <tmricht@linux.vnet.ibm.com>\n\n\t* src/libpfm4/lib/pfmlib_common.c: Update libpfm4\u201d > /tmp/commit-\n\t  libpfm4-header.txt echo \u201cCurrent with commit\n\t  f5331b7cbc96d9f9441df6a54a6f3b6e0fab3fb9  better fix for\n\t  pfmlib_getl()  The following commit:  commit\n\t  9c69edf67f6899d9c6870e9cb54dcd0990974f81  better param check in\n\t  pfmlib_getl()  Fixed paramter checking of pfmlib_getl() but missed\n\t  one condition on the buffer argument. It is char **buffer.\n\t  Therefore we need to check if *buffer is not NULL before we can\n\t  check *len.\n\n2017-11-19  Asim YarKhan <yarkhan@icl.utk.edu>\n\n\t* src/components/cuda/linux-cuda.c: CUDA component: Bug fix for\n\t  releasing and resetting event list  When an event addition failed\n\t  because the event (or metric) requires multiple-runs the eventlist\n\t  and event-context structure was not being cleaned up properly.\n\t  This fixes the event cleanup process.\n\n2017-11-17  Asim YarKhan <yarkhan@icl.utk.edu>\n\n\t* src/components/powercap/tests/powercap_basic.c,\n\t  src/components/powercap/tests/powercap_limit.c: Powercap component:\n\t  Updated tests to handle no-event-counters (num_cntrs==0) and skip\n\t  some compiler warnings (argv, argc unused)\n\n2017-11-16  William Cohen <wcohen@redhat.com>\n\n\t* src/components/lmsensors/linux-lmsensors.c: Make more of lmsensors\n\t  component internal state hidden  There are a number of functions\n\t  pointers stored in variable that are only used within the lmsensors\n\t  component.  Making those static ensures they are not visible\n\t  outside the lmsensors component.\n\t* src/components/lmsensors/linux-lmsensors.c: Make internal\n\t  cached_counts variable static  Want to make as little information\n\t  about the internals of the PAPI lmsensors component visible to the\n\t  outside.  Thus, making cached_counts variable static.\n\n2017-11-15  William Cohen <wcohen@redhat.com>\n\n\t* src/components/lmsensors/linux-lmsensors.c: Avoid statically\n\t  limiting the number of lmsensor events allowed  Some high-end\n\t  server machines provide more events than the 512 entries limit\n\t  imposed by the LM_SENSORS_MAX_COUNTERS define in the lmsensor\n\t  component (observed 577 entries on one machine).  When this limit\n\t  was exceeded the lmsensor component would write beyond the array\n\t  bounds causing ctests/all_native_events to crash.  Modified the\n\t  lmsensor code to dynamically allocate the required space for all\n\t  the available lmsensor entries on the machine. This allows\n\t  ctests/all_native_events to run to completion.\n\t* src/components/appio/appio.c, src/components/coretemp/linux-\n\t  coretemp.c, src/components/example/example.c,\n\t  src/components/infiniband/linux-infiniband.c, src/components/lustre\n\t  /linux-lustre.c, src/components/rapl/linux-rapl.c: Use correct\n\t  argument order for calloc function calls  Some calls to calloc in\n\t  PAPI have the order of the arguments reversed. According to the\n\t  calloc man page the number of elements is the first argument and\n\t  the size of each element is the second argument.  Due to alignment\n\t  constraints the second argument might be rounded up.  Thus, it is\n\t  best not to not to swap the arguments to calloc.\n\n2017-11-15  Philip Vaccaro <pvaccaro@vols.utk.edu>\n\n\t* src/components/powercap/linux-powercap.c,\n\t  src/components/powercap/tests/powercap_basic.c: Updates and changes\n\t  to the powercap component to address a few areas.. Various things\n\t  were changed but mainly things were simplified and made more\n\t  streamlined.  Main focus was on simpifying managing the sytem\n\t  files.\n\nMon Nov 13 23:15:53 2017 -0800  Thomas Richter <tmricht@linux.vnet.ibm.com>\n\n\t* src/libpfm4/docs/man3/pfm_get_event_encoding.3,\n\t  src/libpfm4/docs/man3/pfm_get_os_event_encoding.3,\n\t  src/libpfm4/lib/events/amd64_events_fam11h.h,\n\t  src/libpfm4/lib/events/amd64_events_fam12h.h,\n\t  src/libpfm4/lib/pfmlib_common.c, src/libpfm4/lib/pfmlib_priv.h,\n\t  src/libpfm4/tests/validate_x86.c: Update libpfm4  Current with\n\t  commit 9c69edf67f6899d9c6870e9cb54dcd0990974f81  better param check\n\t  in pfmlib_getl()  This patch ensures tha len >= 2 because we do: m\n\t  = l - 2;  Reviewed-by: Hendrik Brueckner\n\t  <brueckner@linux.vnet.ibm.com>\n\n2017-11-13  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/components/perf_event/pe_libpfm4_events.c: pe_libpfm4_events:\n\t  properly notice if trying to add invalid umask  this passes the\n\t  broken-event test case and all of the unit tests, but it would be\n\t  good to test this on codes that do a lot of native event tests.\n\t  the pe_libpfm4_events code *really* needs a once-over, it is\n\t  currently a confusing mess.\n\t* src/components/perf_event/tests/Makefile,\n\t  src/components/perf_event/tests/broken_events.c,\n\t  src/components/perf_event/tests/event_name_lib.c,\n\t  src/components/perf_event/tests/event_name_lib.h: perf_event/tsts:\n\t  add broken event name test  we were wrongly accepting event names\n\t  with invalid umasks\n\n2017-11-13  Philip Mucci <mucci@icl.utk.edu>\n\n\t* src/utils/print_header.c: Removed extraneous colon in VM vendor\n\t  output\n\n2017-11-10  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/validation_tests/papi_l1_dcm.c,\n\t  src/validation_tests/papi_l2_dcm.c,\n\t  src/validation_tests/papi_l2_dcr.c,\n\t  src/validation_tests/papi_l2_dcw.c: validation_tests: fix compiler\n\t  warnings on arm32  On Raspberry Pi we were getting warnings where\n\t  we were printing sizeof() valus with %ld.  Convert to %zu instead.\n\n2017-11-09  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/validation_tests/papi_l2_dca.c: validation_tests: papi_l2_dca\n\t  fix crash on ARM32  On raspberry pi it's not possible to detect L2\n\t  cache size so the test was dividing by zero.\n\t* src/linux-common.c: linux-common: remove warning on not finding mhz\n\t  in cpuinfo  This was added recently and is not needed. Most ARM32\n\t  devices don't have MHz in the cpuinfo file and it's not really a\n\t  bug.\n\t* src/components/perf_event/perf_event.c: perf_event: disable the old\n\t  pre-Linux-2.6.34 workarounds by default  There were a number of\n\t  bugs in perf_event that PAPI had to work around, but most of these\n\t  were fixed by 2.6.34  In order to hit these bugs you would need to\n\t  be running a kernel from before 2010 which wouldn't support any\n\t  recent hardware.  Unfortunately these bugs are hard to test for.\n\t  We were enabling things based on kernel versions, but this caught\n\t  vendors (such as Redhat) shipping 2.6.32 kernels that had\n\t  backported fixes.  This fix just #ifdefs things out, if no one\n\t  complains then we can fully remove the code.\n\t* src/components/perf_event/perf_event.c: perf_event: decrement the\n\t  available counter count if NMI_WATCHDOG is stealing one\n\t* src/components/perf_event/perf_event.c: perf_event: move the\n\t  paranoid handling code to its own function\n\t* src/components/perf_event/perf_event.c: perf_event: centralize\n\t  fast_counter_read flag  just use the component version of the flag,\n\t  rather than having a shadow global version.\n\n2017-11-09  William Cohen <wcohen@redhat.com>\n\n\t* src/linux-memory.c: Make the fallback generic_get_memory_info\n\t  function more robust  On the aarch64 processor linux 4.11.0 kernels\n\t  /sys/devices/system/cpu/cpu0/cache is available, but the index[0-9]\n\t  subdirectories are not fully populated with information about cache\n\t  and line size, associativity, or number of sets.  These missing\n\t  files would cause the generic_get_memory_info function to attempt\n\t  to read data using a NULL file descriptor causing the program to\n\t  crash.  Added checks to see if every fopen was and fscan was\n\t  successful and just say there is no cache if there is any failure.\n\n2017-11-09  Asim YarKhan <yarkhan@icl.utk.edu>\n\n\t* src/components/cuda/linux-cuda.c,\n\t  src/components/cuda/tests/Makefile,\n\t  src/components/nvml/tests/Makefile, src/configure,\n\t  src/configure.in: Enable icc and nvcc to work together in cuda and\n\t  nvml components.  For nvcc to work with Intel icc to compile cuda\n\t  and nvml components and tests , it needs to use nvcc -ccbin=<$CC-\n\t  compilerbin> . The compiler name in CC also needs to be clean, so\n\t  CC=<compilerbin> and any other flags are pushed to CFLAGS (changed\n\t  in src/configure.in script).\n\t* src/ctests/mpifirst.c: Minor correction to mpifirst.c test\n\n2017-11-09  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/utils/print_header.c: utils: print fast_counter_read (rdpmc)\n\t  status in the utils header\n\n2017-11-08  William Cohen <wcohen@redhat.com>\n\n\t* src/validation_tests/cache_helper.c: Ensure access to array within\n\t  bounds  Coverity reported the following issues.  Need the test to\n\t  be \"type>=MAX_CACHE\" rather than \"type>MAX_CACHE\".  Error: OVERRUN\n\t  (CWE-119): papi-5.5.2/src/validation_tests/cache_helper.c:85:\n\t  cond_at_most: Checking \"type > 4\" implies that \"type\" may be up to\n\t  4 on the false branch.\n\t  papi-5.5.2/src/validation_tests/cache_helper.c:90: overrun-local:\n\t  Overrunning array \"cache_info\" of 4 24-byte elements at element\n\t  index 4 (byte offset 96) using index \"type\" (which evaluates to 4).\n\t  Error: OVERRUN (CWE-119):\n\t  papi-5.5.2/src/validation_tests/cache_helper.c:101: cond_at_most:\n\t  Checking \"type > 4\" implies that \"type\" may be up to 4 on the false\n\t  branch. papi-5.5.2/src/validation_tests/cache_helper.c:106:\n\t  overrun-local: Overrunning array \"cache_info\" of 4 24-byte elements\n\t  at element index 4 (byte offset 96) using index \"type\" (which\n\t  evaluates to 4).  Error: OVERRUN (CWE-119):\n\t  papi-5.5.2/src/validation_tests/cache_helper.c:117: cond_at_most:\n\t  Checking \"type > 4\" implies that \"type\" may be up to 4 on the false\n\t  branch. papi-5.5.2/src/validation_tests/cache_helper.c:122:\n\t  overrun-local: Overrunning array \"cache_info\" of 4 24-byte elements\n\t  at element index 4 (byte offset 96) using index \"type\" (which\n\t  evaluates to 4).\n\t* src/ctests/overflow_pthreads.c: Eliminate coverity overflow warning\n\t  about expression\n\t* src/components/perf_event_uncore/tests/perf_event_uncore_lib.c:\n\t  Remove dead code from perf_event_uncore_lib.c\n\n2017-11-09  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/components/perf_event/perf_event.c: perf_event: don't\n\t  initialize globals statically  from the mucci-5.5.2 tree\n\n2017-11-08  phil@minimalmetrics.com <phil@minimalmetrics.com>\n\n\t* src/linux-common.c: linux-common: clean up the /proc/cpuinfo\n\t  parsing code  From the mucci-cleanup branch\n\t* src/components/perf_event/perf_event.c,\n\t  .../perf_event_uncore/perf_event_uncore.c,\n\t  src/papi_libpfm4_events.c, src/papi_libpfm4_events.h: perf_event:\n\t  clean up _papi_libpfm4_shutdown()  From the mucci-cleanup branch\n\t* src/utils/print_header.c: utils: clean up the cpuinfo header  From\n\t  the mucci-cleanup branch\n\t* src/papi_internal.c, src/papi_internal.h: papi_internal: add\n\t  PAPI_WARN() function  From the mucci-cleanup branch\n\t* src/components/perf_event/pe_libpfm4_events.c: perf_event: clean up\n\t  pe_libpfm4_events  From the mucci-cleanup branch  --\n\n2017-11-08  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/utils/papi_avail.c: utils/papi_avail: update the manpage info\n\t  based on changes by Phil Mucci\n\t* .../perf_event/tests/perf_event_system_wide.c: perf_event tests:\n\t  perf_event_system_wide: don't fail if permissions restrict system-\n\t  wide events  right now we just skip if we get EPERM, we should also\n\t  maybe check the perf_event_paranoid setting and print a more\n\t  meaningful report\n\t* src/ctests/locks_pthreads.c: ctests/locks_pthreads: avoid printing\n\t  values when in quiet mode\n\n2017-08-31  phil@minimalmetrics.com <phil@minimalmetrics.com>\n\n\t* src/Makefile.inc: Better symlink creation for shared library in\n\t  make phase\n\n2017-08-28  phil@minimalmetrics.com <phil@minimalmetrics.com>\n\n\t* doc/Makefile, src/.gitignore, src/Makefile.inc,\n\t  src/components/.gitignore, src/components/Makefile_comp_tests,\n\t  src/ctests/.gitignore, src/ctests/Makefile.recipies,\n\t  src/ftests/.gitignore, src/ftests/Makefile.recipies,\n\t  src/testlib/.gitignore, src/utils/.gitignore, src/utils/Makefile,\n\t  src/validation_tests/.gitignore,\n\t  src/validation_tests/Makefile.recipies: Full cleanup, including\n\t  removal of .gitignore files that prevented us from realizing we\n\t  were really cleaning/clobbering properly\n\t* src/validation_tests/.gitignore: .gitignore Makefile.target\n\t* src/papi.c: Remove PAPI_VERB_ECONT setting by default from\n\t  initialization path. This prints all kinds of needless errors on\n\t  virtual platforms.\n\t* src/x86_cpuid_info.c: Remove leftover printf\n\n2017-08-21  phil@minimalmetrics.com <phil@minimalmetrics.com>\n\n\t* src/ctests/locks_pthreads.c: Test now performs a fixed number of\n\t  iterations, and reports lock/unlock timings per thread.\n\t* src/components/perf_event/perf_event.c: Added more descriptive\n\t  error message to exclude_guest check\n\t* src/papi_internal.c: Removed leading newline and trailing . from\n\t  error messages\n\t* src/papi_preset.c: Updated message for derived event failures\n\n2017-11-07  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/Makefile.inc, src/ctests/Makefile,\n\t  src/ctests/Makefile.target.in, src/ftests/Makefile,\n\t  src/ftests/Makefile.target.in, src/testlib/Makefile.target.in,\n\t  src/utils/Makefile.target.in, src/validation_tests/Makefile,\n\t  src/validation_tests/Makefile.target.in: tests: make sure DESTDIR\n\t  and DATADIR are passed in when doing an install\n\t* src/ctests/Makefile, src/ctests/Makefile.target.in,\n\t  src/ftests/Makefile, src/ftests/Makefile.target.in,\n\t  src/utils/Makefile, src/utils/Makefile.target.in,\n\t  src/validation_tests/Makefile,\n\t  src/validation_tests/Makefile.target.in:\n\t  ctests/ftests/utils/validation_tests: get shared library linking\n\t  working again  This should let the various tests and utils be\n\t  linked as shared libraries again.\n\t* src/validation_tests/Makefile: validation_tests: add an\n\t  installation target  this makes the validation tests have an\n\t  install target, like the ctests and ftests\n\t* src/ctests/Makefile, src/ftests/Makefile: ctests/ftests: fix\n\t  \"install\" target  at some point DATADIR was renamed datadir and the\n\t  install targets were not updated.\n\n2017-11-07  Asim YarKhan <yarkhan@icl.utk.edu>\n\n\t* bitbucket-pipelines.yml: Bitbucket pipeline testing: Inspired by\n\t  Phil Mucci's branch; copied the functionalty tests run in that\n\t  branch.\n\t* src/components/lmsensors/linux-lmsensors.c: lmsensors component:\n\t  Changed event names to use lm_sensors (only once) instead of\n\t  LM_SENSORS (twice) to be consistent with other events\n\n2017-11-02  William Cohen <wcohen@redhat.com>\n\n\t* src/components/appio/tests/iozone/gnu3d.dem: gnu3d.dem should not\n\t  be executed by the test framework  This file is a gnuplot file and\n\t  should not be executed as part of the tests. Removing the\n\t  executable perms will signal to the testing framework that it\n\t  shouldn't be executed.\n\t* src/components/appio/tests/iozone/Gnuplot.txt: Gnuplot.txt should\n\t  not be executed by the test framework  This file is a readme file\n\t  and should not be executed as part of the tests. Removing the\n\t  executable perms will signal to the testing framework that it\n\t  shouldn't be executed.\n\t* .../appio/tests/iozone/iozone_visualizer.pl,\n\t  src/components/appio/tests/iozone/report.pl: Fix perl scripts so\n\t  they run on Linux machines  The DOS style newlines were preventing\n\t  Linux from selecting the appropriate interpreter for these scripts\n\t  and causing these tests to fail.\n\n2017-11-07  Asim YarKhan <yarkhan@icl.utk.edu>\n\n\t* src/components/lmsensors/configure: lmsensors component: Regenerate\n\t  the configure file for the component\n\n2017-11-02  William Cohen <wcohen@redhat.com>\n\n\t* src/components/lmsensors/Makefile.lmsensors.in,\n\t  src/components/lmsensors/configure.in, src/components/lmsensors\n\t  /linux-lmsensors.c: Make the lmsensors dynamically load the needed\n\t  shared library  When attempting to build the current git repo of\n\t  papi the build of the files in the utils subdirectory failed\n\t  because the lmsensors libraries were not being linked in.  Rather\n\t  than forcing the papi to link in the lmsensor library during the\n\t  build the lmsensors component has been modified to dynamically load\n\t  the needed libraries and enable the lmsensors events when\n\t  available.  This allows machines missing the lmsensor libraries\n\t  installed to still use papi.\n\n2017-11-06  Asim YarKhan <yarkhan@icl.utk.edu>\n\n\t* src/components/cuda/linux-cuda.c: CUDA component: On architectures\n\t  without CUDA Metrics (e.g. Tesla C2050), skip metric registration\n\t  rather than returning errors\n\n2017-11-06  Vince Weaver <vince@deater.net>\n\n\t* src/validation_tests/papi_l2_dca.c,\n\t  src/validation_tests/papi_l2_dcm.c,\n\t  src/validation_tests/papi_l2_dcr.c,\n\t  src/validation_tests/papi_l2_dcw.c: validation_tests: make the\n\t  papi_l2 tests fail with warnings  On Haswell/Broadwell and newer\n\t  these tests fail for unknown reasons.  This isn't new behavior,\n\t  it's just that the tests are new.  It's unlikely we will have time\n\t  to completely sort this out before the upcoming release, so change\n\t  the FAIL to WARN so testers won't be unnecessarily alarmed.\n\n2017-11-05  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/components/perf_event/perf_event.c, src/configure,\n\t  src/configure.in: perf_event: enable rdpmc support by default  It\n\t  can still be disabled at configure time with --enable-perfevent-\n\t  rdpmc=no  This speeds up PAPI_read() by at least a factor of 5x\n\t  (see the ESPT'17 workshop presentation)  It is only enabled on\n\t  Linux 4.13 and newer due to bugs in previous versions.\n\n2017-11-03  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/ctests/sdsc-mpx.c: ctests: sdsc: fix issue where the error\n\t  message is not printed correctly\n\n2017-11-01  Heike Jagode <jagode@icl.utk.edu>\n\n\t* src/components/powercap/linux-powercap.c: Intermediate check-in:\n\t  Fixed a whole bunch of careless file handling (missing closing of\n\t  open files, missing setting of open/close flag, etc). Still more\n\t  rigorous checks needed.\n\nMon Oct 30 17:16:32 2017 -0700  Stephane Eranian <eranian@gmail.com>\n\n\t* src/libpfm4/lib/events/intel_skl_events.h: Update\n\t  libpfm4\\n\\nCurrent with\\n commit\n\t  21405fb3c247a0d16861483daf0696cf4fa0cc43  update SW_PREFETCH event\n\t  for Intel Skylake  Event was renamed SW_PREFETCH_ACCESS, but we\n\t  keep SW_PREFETCH as an alias.  Added PREFETCHW umask.  Enabled\n\t  suport for both Skylake client and server as per official event\n\t  table from 10/27/2017. See download.01.org/perfmon/\n\n2017-10-30  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/validation_tests/Makefile.recipies,\n\t  src/validation_tests/cycles.c,\n\t  src/validation_tests/cycles_validation.c: validation_tests: add\n\t  cycles_validation test  this is the old zero test, which does a\n\t  number of cycles tests  It should be extended to add more.\n\n2017-10-30  Vince Weaver <vince@deater.net>\n\n\t* src/ctests/attach2.c, src/ctests/attach3.c, src/ctests/calibrate.c,\n\t  src/ctests/child_overflow.c, src/ctests/code2name.c,\n\t  src/ctests/earprofile.c, src/ctests/exec_overflow.c,\n\t  src/ctests/fork_overflow.c, src/ctests/hwinfo.c, src/ctests/mendes-\n\t  alt.c, src/ctests/prof_utils.c, src/ctests/prof_utils.h,\n\t  src/ctests/profile.c, src/ctests/remove_events.c,\n\t  src/ctests/shlib.c, src/ctests/system_child_overflow.c,\n\t  src/ctests/system_overflow.c, src/ctests/zero_named.c,\n\t  src/testlib/papi_test.h, src/testlib/test_utils.c: papi: c++11\n\t  fixes: fix various ctests that c++ complains on  mostly just const\n\t  warnings, some K+R function declarations, and possibly an actual\n\t  char/char* bug.\n\t* src/papi.c, src/papi.h: papi: c++11 conversion:\n\t  PAPI_get_component_index()\n\t* src/papi.c, src/papi.h: papi: c++11 conversion: convert\n\t  PAPI_perror()\n\t* src/aix.c, src/components/appio/appio.c,\n\t  src/components/bgpm/CNKunit/linux-CNKunit.c,\n\t  src/components/bgpm/IOunit/linux-IOunit.c,\n\t  src/components/bgpm/L2unit/linux-L2unit.c,\n\t  src/components/bgpm/NWunit/linux-NWunit.c, src/components/emon\n\t  /linux-emon.c, src/components/net/linux-net.c,\n\t  src/components/perf_event/pe_libpfm4_events.c,\n\t  src/components/perf_event/pe_libpfm4_events.h,\n\t  src/components/perf_event/perf_event.c,\n\t  .../perf_event_uncore/perf_event_uncore.c,\n\t  src/components/perfmon_ia64/perfmon-ia64.c, src/freebsd.c, src\n\t  /linux-bgq.c, src/papi.c, src/papi.h, src/papi_internal.c,\n\t  src/papi_internal.h, src/papi_libpfm3_events.c,\n\t  src/papi_libpfm_events.h, src/papi_vector.c, src/papi_vector.h:\n\t  papi: start converting papi.h to be C++11 clean  Most of the issues\n\t  have to do with string to char * conversion.  This first patch\n\t  converts PAPI_event_name_to_code()  The issue was first reported by\n\t  Brian Van Straalen\n\t* src/validation_tests/papi_l2_dca.c: validation_tests/papi_l2_dca:\n\t  update some comments\n\t* src/ctests/zero.c, src/validation_tests/cycles.c: ctests/zero: make\n\t  test pass on recent intel machines  The test was failing due to the\n\t  PAPI_get_real_cycles() validation on recent Intel chips.  This is\n\t  probably something that should be tested in a separate test and not\n\t  in zero which is supposed to be a bare-bones are-things-working\n\t  test.\n\n2017-10-27  Philip Vaccaro <pvaccaro@vols.utk.edu>\n\n\t* src/components/powercap/README: updated powercap README to be more\n\t  concise. includes more details on interacting with energy counters\n\t  and power limits.\n\n2017-10-27  Asim YarKhan <yarkhan@icl.utk.edu>\n\n\t* src/components/cuda/linux-cuda.c, src/components/nvml/linux-nvml.c:\n\t  CUDA/NVML components: Handled segfault which can occur when\n\t  dlclosing libcudart from both components by adding an additional\n\t  flag to dlopen\n\n2017-10-24  Asim YarKhan <yarkhan@icl.utk.edu>\n\n\t* src/components/cuda/linux-cuda.c,\n\t  src/components/cuda/tests/simpleMultiGPU.cu: CUDA component: Clean\n\t  up fulltest by moving some output from stdout to SUBDBG, removed\n\t  some commented out lines\n\t* src/components/nvml/linux-nvml.c: nvml component: To support V100\n\t  (Volta) updated to get nvmlDevice handle ordered by index rather\n\t  than pci busid.\n\n2017-10-23  Asim YarKhan <yarkhan@icl.utk.edu>\n\n\t* src/components/cuda/linux-cuda.c: CUDA component: Minor fix to\n\t  remove some unneeded stdout which shows up during fulltest\n\n2017-10-20  Asim YarKhan <yarkhan@icl.utk.edu>\n\n\t* src/components/cuda/linux-cuda.c,\n\t  src/components/cuda/tests/Makefile,\n\t  src/components/cuda/tests/simpleMultiGPU.cu: CUDA component test\n\t  update: Remove some debug output.  Do not build cupti_only test\n\t  binary.\n\nThu Oct 19 11:23:44 2017 -0700  Stephane Eranian <eranian@gmail.com>\n\n\t* src/libpfm4/examples/showevtinfo.c,\n\t  src/libpfm4/lib/events/intel_skl_events.h: Update\n\t  libpfm4\\n\\nCurrent with\\n commit\n\t  2e98642dd331b15382256caa380834d01b63bef8  Fix Intel Skylake\n\t  EXE_ACTIVITY.1_PORTS_UTIL event  Was missing a umask name.\n\n2017-10-17  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/ctests/version.c: ctests: version, add INCREMENT field  at the\n\t  request of Steve Kaufmann\n\t* src/ctests/Makefile.recipies, src/ctests/version.c: ctests: re-\n\t  enable version test  not sure why it was disabled\n\t* src/ctests/Makefile.recipies: ctests: alphabetize SERIAL tests in\n\t  Makefile.recipes\n\n2017-10-13  Philip Vaccaro <pvaccaro@vols.utk.edu>\n\n\t* src/components/powercap/tests/Makefile,\n\t  src/components/powercap/tests/powercap_limit.c: added simple limit\n\t  test for the powercap component.\n\n2017-10-09  Asim YarKhan <yarkhan@icl.utk.edu>\n\n\t* src/components/nvml/linux-nvml.c: Big Fix NVML component: Fix\n\t  problem with names when there are multiple identical GPUs  If\n\t  multiple identical GPUs were available, the names were not mapped\n\t  correctly.  Fixed event names to be\n\t  \"nvml:::Tesla_K40c:device_0:myevent\" rather than\n\t  \"nvml:::Tesla_K40c_0:myevent\".\n\nFri Sep 29 00:25:09 2017 -0700  Stephane Eranian <eranian@gmail.com>\n\n\t* src/libpfm4/include/perfmon/perf_event.h,\n\t  src/libpfm4/lib/events/intel_skl_events.h,\n\t  src/libpfm4/lib/events/s390x_cpumf_events.h,\n\t  src/libpfm4/lib/pfmlib_s390x_cpumf.c,\n\t  src/libpfm4/perf_examples/Makefile,\n\t  src/libpfm4/perf_examples/branch_smpl.c,\n\t  src/libpfm4/perf_examples/perf_util.c: Update libpfm4\\n\\nCurrent\n\t  with\\n commit d1e7c96df60a00a371fdaa3b635ad4a38cee4c2f  add new\n\t  branch_smpl.c perf_events example  This patch adds a new example to\n\t  demo how to sample and parse the PERF_SAMPLE_BRANCH_STACK record\n\t  format of perf_events. It will dump branches taken from the sampled\n\t  command.\n\n2017-10-05  Asim YarKhan <yarkhan@icl.utk.edu>\n\n\t* src/components/nvml/README, src/components/nvml/linux-nvml.c,\n\t  src/components/nvml/linux-nvml.h,\n\t  src/components/nvml/tests/HelloWorld.cu,\n\t  src/components/nvml/tests/Makefile,\n\t  .../nvml/tests/nvml_power_limiting_test.cu: Update NVML component:\n\t  Support for power limiting using NVML  PAPI has added support for\n\t  power limiting using NVML (on supported devices from the Kepler\n\t  family or later).  The executable needs to have root permissions to\n\t  change the power limits on the device.  We have added new events to\n\t  the NVML component to support power management limits.  The\n\t  nvml:::DEVICE:power_management_limit can be written (as well as\n\t  read), but requires higher permissions (root level).  The limit is\n\t  constrainted between a min and a max value, which can be read.\n\t  When the component is unloaded, the power_management_limit should\n\t  be reset to the initial value.\n\t  nvml:::DEVICE:power_management_limit\n\t  nvml:::DEVICE:power_management_limit_constraint_min\n\t  nvml:::DEVICE:power_management_limit_constraint_max  A new test\n\t  (nvml/tests/nvml_power_limiting_test.cu)/ was written to check if\n\t  the writing functionality works (with the proper hardware and\n\t  permissions).\n\n2017-10-04  Asim YarKhan <yarkhan@icl.utk.edu>\n\n\t* src/components/nvml/linux-nvml.c, src/components/nvml/linux-nvml.h,\n\t  src/components/nvml/tests/HelloWorld.cu: Style consistency and\n\t  refactoring via astyle command.  No changes to the actual code were\n\t  made here.\n\n2017-10-04  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/components/rapl/linux-rapl.c: rapl: add support for some Intel\n\t  Atom models Goldmont / Gemini_Lake / Denverton\n\t* src/components/rapl/linux-rapl.c: rapl: fix skylake SoC measurement\n\t  support\n\t* src/components/rapl/linux-rapl.c: rapl: add support for skylake SoC\n\t  energy measurements\n\t* src/components/rapl/linux-rapl.c: rapl: add Skylake-X / Kabylake\n\t  support\n\t* src/components/rapl/linux-rapl.c: rapl: centralize the \"different\n\t  DRAM units\" code\n\t* src/components/rapl/linux-rapl.c: rapl: merge like processors\n\t* src/components/rapl/linux-rapl.c: rapl: convert chip detection to a\n\t  switch statement\n\t* src/components/rapl/linux-rapl.c: rapl: update the whitespace a bit\n\n2017-09-12  Heike Jagode (jagode@icl.utk.edu) <jagode@saturn.icl.utk.edu>\n\n\t* .../infiniband_umad/linux-infiniband_umad.c, .../infiniband_umad\n\t  /linux-infiniband_umad.h: Fixed papi_vector for infiniband_umad\n\t  component.  The array of function pointers that the component\n\t  defines must use the naming convention papi_vector_t _x_vector\n\t  where x is the name of the component directory.  In this case, the\n\t  name of the component directory is infiniband_umad and not\n\t  infiniband.  This change has not been tested yet due to OFED lib\n\t  issues on our local machines. There may be more changes required in\n\t  order to get the infiniband_umad component to work properly.\n\n2017-09-11  Hanumanth <fhanuman@vols.utk.edu>\n\n\t* man/man1/papi_avail.1, man/man1/papi_native_avail.1,\n\t  src/utils/papi_avail.c, src/utils/papi_native_avail.c: Updating man\n\t  and help pages for papi_avail and papi_native_avail\n\n2017-09-07  Asim YarKhan <yarkhan@icl.utk.edu>\n\n\t* src/components/cuda/tests/nvlink_bandwidth.cu,\n\t  .../cuda/tests/nvlink_bandwidth_cupti_only.cu: Update to CUDA\n\t  component to support NVLink.  The CUDA component has been cleaned\n\t  up and updated to support NVLink. NVLink metrics can not be\n\t  measured properly in KERNEL event collection mode, so the CUPTI\n\t  EventCollectionMode is transparently set to\n\t  CUPTI_EVENT_COLLECTION_MODE_CONTINUOUS when a NVLink metric is\n\t  being measured in an eventset.  For all other events and metrics,\n\t  the CUDA component uses the KERNEL event collection mode.  A bug in\n\t  the earlier version was that repeated calls to add CUDA events were\n\t  failing because some structures were not cleaned up.  This should\n\t  now be fixed.  A new nvlink test was added to the CUDA component\n\t  tests.\n\n2017-08-31  Phil Mucci <phil@minimalmetrics.com>\n\n\t* man/man1/papi_avail.1, man/man1/papi_clockres.1,\n\t  man/man1/papi_command_line.1, man/man1/papi_component_avail.1,\n\t  man/man1/papi_cost.1, man/man1/papi_decode.1,\n\t  man/man1/papi_error_codes.1, man/man1/papi_event_chooser.1,\n\t  man/man1/papi_hybrid_native_avail.1, man/man1/papi_mem_info.1,\n\t  man/man1/papi_multiplex_cost.1, man/man1/papi_native_avail.1,\n\t  man/man1/papi_version.1, man/man1/papi_xml_event_info.1,\n\t  man/man3/PAPI_cleanup_eventset.3, man/man3/PAPI_destroy_eventset.3:\n\t  Updating options for papi_avail/native_avail as well as all\n\t  references to old mailing list\n\n2017-08-31  Asim YarKhan <yarkhan@icl.utk.edu>\n\n\t* src/components/nvml/linux-nvml.c,\n\t  src/components/nvml/tests/HelloWorld.cu,\n\t  src/components/nvml/tests/Makefile: Minor updates to NVML component\n\t  to enable it to compile and run without complaints\n\n2017-08-30  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/validation_tests/papi_br_prc.c,\n\t  src/validation_tests/papi_br_tkn.c: validation: update papi_br_prc\n\t  and papi_br_tkn for amd fam15h  amd fam15h doesn't have a\n\t  conditional branch event so the measures have to be against total.\n\t  for now print warning, maybe we should let it go w/o a warning.\n\t* src/papi_events.csv: papi_events: add PAPI_BR_PRC event to amd\n\t  fam15h\n\t* src/papi_events.csv: papi_events: update PAPI_BR_PRC and\n\t  PAPI_BR_TKN on sandybridge/ivybridge  They were using TOTAL\n\t  branches for the derived branch events rather than CONDITIONAL like\n\t  the other modern x86 processors were using.\n\t* src/validation_tests/papi_br_tkn.c: validation_tests: papi_br_tkn:\n\t  update to only count conditional branches\n\t* src/validation_tests/papi_br_prc.c: validation_tests: papi_br_prc:\n\t  make sure it is comparing conditional branches  was doing total\n\t  branches, which made the test fail on skylake\n\nMon Aug 21 23:55:46 2017 -0700  Stephane Eranian <eranian@gmail.com>\n\n\t* src/libpfm4/lib/pfmlib_intel_x86.c: Update libpfm4\\n\\nCurrent\n\t  with\\n commit a290dead7c1f351f8269a265c0d4a5f38a60ba29  fix usage\n\t  of is_model_event() for Intel X86  This patch fixes a couple of\n\t  problems introduced by commit: 77a5ac9d43b1 add model field to\n\t  intel_x86_entry_t  The code in pfm_intel_x86_get_event_first() was\n\t  incorrect. It was calling is_model_event() before checking if the\n\t  index was within bounds. It should have been the opposite. Same\n\t  issue in pfm_intel_x86_get_next_event(). This could cause SEGFAULT\n\t  as report by Phil Mucci.  The patch also fixes the return value of\n\t  pfm_intel_x86_get_event_first(). It was not calculated correctly.\n\t  Reported-by: Phil Mucci <mucci@icl.utk.edu>\n\n2017-08-20  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/ctests/Makefile.recipies, src/ctests/failed_events.c: ctests:\n\t  add failed_events test  it tries to create invalid events to make\n\t  sure the event parser properly handles invalid events.\n\n2017-08-19  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/components/perf_event_uncore/tests/Makefile,\n\t  .../perf_event_uncore/tests/perf_event_uncore.c,\n\t  .../tests/perf_event_uncore_attach.c: perf_event_uncore: tests:\n\t  update perf_event_uncore to use :cpu=0  This is the more common way\n\t  of specifying uncore events. Rename the old test that uses\n\t  PAPI_set_opt() to perf_event_uncore_attach\n\t* .../tests/perf_event_uncore_cbox.c,\n\t  .../tests/perf_event_uncore_lib.c,\n\t  .../tests/perf_event_uncore_lib.h: perf_event_uncore: tests: update\n\t  uncore events for recent processors\n\t* src/ctests/zero_pthreads.c: ctests: zero_pthreads: remove\n\t  extraneous printf when in quiet mode\n\t* .../tests/perf_event_uncore_lib.c: perf_event_uncore: event list,\n\t  add recent processors  libpfm4 still doesn't support regular\n\t  Haswell, Broadwell, or Skylake machines\n\t* .../perf_event_uncore/tests/perf_event_uncore.c,\n\t  .../tests/perf_event_uncore_cbox.c,\n\t  .../tests/perf_event_uncore_multiple.c: perf_event_uncore: tests:\n\t  print a message indicating the problem on skip  also some\n\t  whitespace cleanups\n\t* src/components/perf_event/tests/event_name_lib.c: perf_event:\n\t  tests: update event_name_lib for recent Intel processors\n\t* src/components/perf_event/tests/event_name_lib.c: perf_event:\n\t  tests: event_name_lib, clean up whitespace\n\t* .../perf_event/tests/perf_event_offcore_response.c: perf_event:\n\t  tests: update perf_event_offcore_response test  print an indicator\n\t  of why we are skipping the test also some gratuitous whitespace\n\t  cleanups\n\t* src/ctests/zero_shmem.c: ctests: zero_shmem: document the code a\n\t  little better\n\t* src/ctests/zero_smp.c: ctests: zero_smp: make it actually do\n\t  something on Linux  Linux can use the pthread code just like AIX\n\t  although we don't validate the results, so this test could be\n\t  another candidate for not being necessary anymore.\n\t* src/ctests/zero_shmem.c: ctests: zero_shmem: minor cleanups  we\n\t  pretty much always skip this test.  Is it needed anymore? What was\n\t  it testing in the first place?  The code it calls (start_pes() )\n\t  doesn't seem to exist anymore\n\t* src/ctests/zero_omp.c, src/ctests/zero_pthreads.c: ctests: zero_omp\n\t  and zero_pthread were skipping due to a typo  when updating the\n\t  code I had left a stray ! before PAPI_query_event()\n\n2017-08-19  Vince Weaver <vince@deater.net>\n\n\t* src/papi_events.csv: papi_events: the skylake fixes broke hsw/bdw\n\t  this skylake-x change is way more trouble than it was worth.\n\n2017-08-19  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/papi_events.csv: papi_events: on skylake the SNP_FWD umask was\n\t  renamed to SNP_HIT_WITH_FWD  This broke presets on skylake,\n\t  skylake-x\n\t* src/components/perf_event/pe_libpfm4_events.c: perf_event: fix\n\t  uninitialized descr issue reported by valgrind  I don't think this\n\t  is the skylake-x bug though\n\n2017-08-18  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/components/perf_event/pe_libpfm4_events.c: perf_event: clean up\n\t  some whitespace in pe_libpfm4_events.c\n\t* src/linux-memory.c: linux-memory: various errors when compiling\n\t  with debug enabled  the new proc memory code had some mistakes in\n\t  the debug messages that only appeared when compiled with --with-\n\t  debug  Reported-by: Steve Kaufmann <sbk@cray.com>\n\n2017-08-17  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/papi_events.csv: papi_events: missed one of the skx event\n\t  locations\n\n2017-08-16  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/papi_events.csv: papi_events: enable Skylake X support\n\nSun Aug 6 00:22:52 2017 -0700  Stephane Eranian <eranian@gmail.com>\n\n\t* src/libpfm4/include/perfmon/pfmlib.h,\n\t  src/libpfm4/lib/events/intel_skl_events.h,\n\t  src/libpfm4/lib/pfmlib_common.c,\n\t  src/libpfm4/lib/pfmlib_intel_skl.c,\n\t  src/libpfm4/lib/pfmlib_intel_snbep_unc.c,\n\t  src/libpfm4/lib/pfmlib_intel_x86.c,\n\t  src/libpfm4/lib/pfmlib_intel_x86_priv.h,\n\t  src/libpfm4/lib/pfmlib_priv.h, src/libpfm4/tests/validate_x86.c:\n\t  Update libpfm4\\n\\nCurrent with\\n commit\n\t  efd16920194999fdf1146e9dab3f7435608a9479  add support for Intel\n\t  Skylake X  This patch adds support for Intel Skylake X core PMU\n\t  events. Based on\n\t  download.01.org/perfmon/SKX/skylakex_core_v25.json.  New PMU is\n\t  called skx.\n\n2017-08-07  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/papi_events.csv: papi_events: add initial AMD fam17h support\n\t  not tested on actual hardware yet\n\t* src/papi_events.csv: papi_events: fix the amd_fam16h PMU name  The\n\t  way libpfm4 reports fam16h was modified a bit from my initial\n\t  patches.  fam16h seems to be working now.\n\nThu Jul 27 23:30:20 2017 -0700  Stephane Eranian <eranian@gmail.com>\n\n\t* src/libpfm4/README, src/libpfm4/docs/Makefile,\n\t  src/libpfm4/docs/man3/libpfm_amd64_fam16h.3,\n\t  src/libpfm4/docs/man3/libpfm_amd64_fam17h.3,\n\t  src/libpfm4/docs/man3/libpfm_intel_bdx_unc_cbo.3,\n\t  src/libpfm4/docs/man3/libpfm_intel_bdx_unc_ha.3,\n\t  src/libpfm4/docs/man3/libpfm_intel_bdx_unc_imc.3,\n\t  src/libpfm4/docs/man3/libpfm_intel_bdx_unc_irp.3,\n\t  src/libpfm4/docs/man3/libpfm_intel_bdx_unc_pcu.3,\n\t  src/libpfm4/docs/man3/libpfm_intel_bdx_unc_qpi.3,\n\t  .../docs/man3/libpfm_intel_bdx_unc_r2pcie.3,\n\t  src/libpfm4/docs/man3/libpfm_intel_bdx_unc_r3qpi.3,\n\t  src/libpfm4/docs/man3/libpfm_intel_bdx_unc_sbo.3,\n\t  src/libpfm4/docs/man3/libpfm_intel_bdx_unc_ubo.3,\n\t  src/libpfm4/examples/showevtinfo.c,\n\t  src/libpfm4/include/perfmon/pfmlib.h, src/libpfm4/lib/Makefile,\n\t  src/libpfm4/lib/events/amd64_events_fam16h.h,\n\t  src/libpfm4/lib/events/amd64_events_fam17h.h,\n\t  src/libpfm4/lib/events/intel_bdx_unc_cbo_events.h,\n\t  src/libpfm4/lib/events/intel_bdx_unc_ha_events.h,\n\t  src/libpfm4/lib/events/intel_bdx_unc_imc_events.h,\n\t  src/libpfm4/lib/events/intel_bdx_unc_irp_events.h,\n\t  src/libpfm4/lib/events/intel_bdx_unc_pcu_events.h,\n\t  src/libpfm4/lib/events/intel_bdx_unc_qpi_events.h,\n\t  .../lib/events/intel_bdx_unc_r2pcie_events.h,\n\t  .../lib/events/intel_bdx_unc_r3qpi_events.h,\n\t  src/libpfm4/lib/events/intel_bdx_unc_sbo_events.h,\n\t  src/libpfm4/lib/events/intel_bdx_unc_ubo_events.h,\n\t  src/libpfm4/lib/pfmlib_amd64.c,\n\t  src/libpfm4/lib/pfmlib_amd64_fam16h.c,\n\t  src/libpfm4/lib/pfmlib_amd64_fam17h.c,\n\t  src/libpfm4/lib/pfmlib_amd64_priv.h,\n\t  src/libpfm4/lib/pfmlib_common.c,\n\t  src/libpfm4/lib/pfmlib_intel_bdx_unc_cbo.c,\n\t  src/libpfm4/lib/pfmlib_intel_bdx_unc_ha.c,\n\t  src/libpfm4/lib/pfmlib_intel_bdx_unc_imc.c,\n\t  src/libpfm4/lib/pfmlib_intel_bdx_unc_irp.c,\n\t  src/libpfm4/lib/pfmlib_intel_bdx_unc_pcu.c,\n\t  src/libpfm4/lib/pfmlib_intel_bdx_unc_qpi.c,\n\t  src/libpfm4/lib/pfmlib_intel_bdx_unc_r2pcie.c,\n\t  src/libpfm4/lib/pfmlib_intel_bdx_unc_r3qpi.c,\n\t  src/libpfm4/lib/pfmlib_intel_bdx_unc_sbo.c,\n\t  src/libpfm4/lib/pfmlib_intel_bdx_unc_ubo.c,\n\t  src/libpfm4/lib/pfmlib_intel_snbep_unc.c,\n\t  src/libpfm4/lib/pfmlib_intel_snbep_unc_priv.h,\n\t  src/libpfm4/lib/pfmlib_priv.h,\n\t  src/libpfm4/perf_examples/self_count.c,\n\t  src/libpfm4/tests/validate_x86.c: Update libpfm4  Current with\n\t  commit 72474c59d88512e49d9be7c4baa4355e8d8ad10a  fix typo in AMd\n\t  Fam17h man page  PMU name was mistyped.\n\n2017-08-04  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/validation_tests/papi_l1_dcm.c,\n\t  src/validation_tests/papi_l2_dcm.c: validation_tests: for the DCM\n\t  tests up the allowed error to 5%  We don't want to fail too easily,\n\t  and 5% seems reasonable. This lets the test pass on ARM64\n\t  Dragonboard 401c\n\t* src/linux-memory.c: linux-memory: add fallback generic Linux /sys\n\t  cache size detection  This will allow getting cache sizes on\n\t  architectures we don't have custom code for.  Currently this mostly\n\t  means ARM64.\n\t* src/validation_tests/papi_l1_dcm.c,\n\t  src/validation_tests/papi_l2_dcm.c: validation_tests: don't crash\n\t  if cachesize reported as zero\n\t* src/validation_tests/branches_testcode.c: branches_testcode: add\n\t  arm64 support\n\n2017-07-27  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/papi_events.csv, src/validation_tests/papi_l2_dca.c:\n\t  validation_tests: trying to find out why PAPI_L2_DCA fails on\n\t  Haswell  it's a mystery still.  One alternative is to switch the\n\t  event to be the same as PAPI_L1_DCM but that seems like it would be\n\t  cheating.\n\t* src/validation_tests/papi_l2_dcw.c: validation_tests: papi_l2_dcw:\n\t  shorten a warning message\n\t* src/papi_events.csv: papi_events: note that libpfm4 Kaby Lake\n\t  support is treated as part of Skylake\n\t* src/validation_tests/Makefile.recipies,\n\t  src/validation_tests/papi_l2_dcw.c: validation_tests: add\n\t  PAPI_L2_DCW test\n\t* src/validation_tests/Makefile.recipies,\n\t  src/validation_tests/papi_l2_dcr.c: validation_tests: add\n\t  PAPI_L2_DCR test\n\t* src/validation_tests/papi_l2_dcm.c: validation_tests: PAPI_L2_DCM\n\t  figured out a test that made sense\n\t* src/validation_tests/Makefile.recipies,\n\t  src/validation_tests/papi_l1_dcm.c: validation_tests: add\n\t  PAPI_L1_DCM test\n\t* src/validation_tests/Makefile.recipies,\n\t  src/validation_tests/cache_testcode.c,\n\t  src/validation_tests/papi_l2_dcm.c,\n\t  src/validation_tests/testcode.h: validation_tests: first attempt at\n\t  papi_l2_dcm test  disabled for now, as it's really hard to make a\n\t  workable cache miss test on modern hardware.\n\n2017-07-26  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/ctests/Makefile, src/ctests/Makefile.recipies,\n\t  src/ctests/child_overflow.c, src/ctests/exec_overflow.c,\n\t  src/validation_tests/Makefile.recipies,\n\t  src/validation_tests/busy_work.c, src/validation_tests/testcode.h:\n\t  ctests: clean up the exec/child overflow tests  The exec_overflow\n\t  test segfaults when using rdpmc  This is a bug in Linux.  I'm\n\t  working on getting it fixed.\n\n2017-07-21  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/validation_tests/Makefile.recipies,\n\t  src/validation_tests/cache_helper.c,\n\t  src/validation_tests/cache_helper.h,\n\t  src/validation_tests/cache_testcode.c,\n\t  src/validation_tests/papi_l1_dca.c,\n\t  src/validation_tests/papi_l2_dca.c,\n\t  src/validation_tests/testcode.h: validation_tests: add PAPI_L2_DCA\n\t  test  also adds some generic cache testing infrastructure\n\t* src/validation_tests/papi_l1_dca.c: validation_tests: PAPI_L1_DCA\n\t  fixes  had to find a machine that actually supported the event.  On\n\t  AMD Fam15h the write count is 3x expected?  Need to investigate\n\t  further.\n\t* src/validation_tests/papi_br_prc.c: validation_tests: papi_br_prc,\n\t  properly skip if event not found\n\t* src/validation_tests/Makefile.recipies,\n\t  src/validation_tests/papi_l1_dca.c: validation_tests: add\n\t  PAPI_L1_DCA test\n\n2017-07-20  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/validation_tests/Makefile.recipies,\n\t  src/validation_tests/papi_br_msp.c,\n\t  src/validation_tests/papi_br_prc.c: validation_tests: add\n\t  PAPI_BR_PRC test\n\t* src/validation_tests/Makefile.recipies,\n\t  src/validation_tests/papi_br_tkn.c: validation_tests: add\n\t  PAPI_BR_TKN test\n\t* src/validation_tests/Makefile.recipies,\n\t  src/validation_tests/papi_br_ntk.c: validation_tests: add\n\t  PAPI_BR_NTK test\n\n2017-07-07  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/papi_events.csv: papi_events: move haswell, skylake, and\n\t  broadwell to traditional PAPI_REF_CYC  there's a slight chance this\n\t  might break things for people, if so we can revert it.\n\t* src/linux-timer.c: linux-timer: fix build warning on non-power\n\t  build\n\t* src/ctests/flops.c, src/validation_tests/flops_testcode.c,\n\t  src/validation_tests/papi_dp_ops.c,\n\t  src/validation_tests/papi_fp_ops.c,\n\t  src/validation_tests/papi_sp_ops.c: validation: make the flops\n\t  tests handle that POWER has fused multiply-add  PAPI_DP_OPS and\n\t  PAPI_SP_OPS still fail, need to audit what the event is doing\n\t* src/papi_events.csv: POWER8: add a few branch preset events  they\n\t  pass the validation tests, not sure why they weren't enabled\n\t  originally\n\t* src/validation_tests/branches_testcode.c: validation: add POWER\n\t  branches testcode  not sure I got the clobbers right\n\t* src/components/perf_event/perf_helpers.h,\n\t  src/validation_tests/papi_tot_ins.c: POWER: fix some compiler\n\t  warnings\n\n2016-10-18  Phil Mucci <phil@minimalmetrics.com>\n\n\t* src/linux-timer.c: Ensure stdint gets included for all Linuxen.\n\t* src/linux-timer.c: Some Linuxen need stdint to get the uint64_t\n\t  type.\n\n2016-10-14  Phil Mucci <phil@minimalmetrics.com>\n\n\t* src/linux-lock.h: Restructured unlock code to avoid warnings.\n\t  Tested against 80 threads on Power8\n\n2016-10-12  Phil Mucci <phil@minimalmetrics.com>\n\n\t* src/linux-timer.c: PPC64/PPC fast timer fixup.\n\n2017-07-07  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/linux-timer.c: linux-timer: allow using fast timer for\n\t  get_real_cycles() on POWER\n\n2016-07-12  Phil Mucci <phil@minimalmetrics.com>\n\n\t* src/linux-timer.c, src/linux-timer.h: First pass at good rdtsc for\n\t  Power7/8\n\n2017-07-03  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/ctests/flops.c, src/ctests/hl_rates.c,\n\t  src/validation_tests/Makefile.recipies,\n\t  src/validation_tests/flops.c,\n\t  src/validation_tests/flops_testcode.c,\n\t  src/validation_tests/flops_validation.c,\n\t  src/validation_tests/papi_dp_ops.c,\n\t  src/validation_tests/papi_fp_ops.c,\n\t  src/validation_tests/papi_sp_ops.c,\n\t  src/validation_tests/testcode.h: validation_tests: add tests for\n\t  PAPI_SP_OPS and PAPI_DP_OPS  extend the flops_testcode as well, to\n\t  have both float and double versions.\n\t* src/validation_tests/papi_ref_cyc.c: validation_tests:\n\t  papi_ref_cyc: update test to work on older systems  it's actually\n\t  the newer (haswell/broadwell/skylake) that are using a different\n\t  event than the older systems.  Make the test check for the old\n\t  behavior.\n\n2017-07-02  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/ctests/Makefile.recipies, src/ctests/cycle_ratio.c,\n\t  src/validation_tests/Makefile.recipies,\n\t  src/validation_tests/flops_testcode.c,\n\t  src/validation_tests/papi_ref_cyc.c,\n\t  src/validation_tests/testcode.h: validation_tests: move cycle_ratio\n\t  test to be papi_ref_cyc test\n\t* src/ctests/cycle_ratio.c: ctests: rewrite cycle_ratio test  on\n\t  Intel platforms PAPI_REF_CYC is a fixed 100MHz cycle count  the\n\t  test was making the assumption that PAPI_REF_CYC was equal to the\n\t  max design freq (not turboboost) and thus as far as I can tell it\n\t  never would return the right answer.  This test should probably be\n\t  moved to validation_tests.\n\n2017-07-01  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/ctests/Makefile.recipies, src/ctests/branches.c, src/ctests\n\t  /sdsc-mpx.c, src/ctests/sdsc2.c: ctests: migrate all other users of\n\t  dummy3() workload\n\t* src/ctests/Makefile.recipies, src/ctests/sdsc4-mpx.c,\n\t  src/validation_tests/flops_testcode.c,\n\t  src/validation_tests/testcode.h: ctests: move the \"dummy3\" workload\n\t  to the common workload library\n\t* src/ctests/sdsc4-mpx.c: ctests: sdsc4-mpx: fix failing on recent\n\t  Intel machines  the multiplexing of an event with small results\n\t  (PAPI_SR_INS in this case) has high variance, so don't use it for\n\t  validation.  There was code trying to do this but it wasn't\n\t  working.\n\n2017-06-30  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/ctests/first.c, src/ctests/matrix-hl.c, src/ctests/zero_omp.c,\n\t  src/ctests/zero_pthreads.c: ctests: catch lack of CPU component\n\t  earlier  gets rid of extreaneous SKIPPED in the output of\n\t  run_tests.sh\n\t* src/components/cuda/tests/HelloWorld.cu,\n\t  src/components/cuda/tests/Makefile: tests:cuda: make the HelloWorld\n\t  test more like a standard PAPI test\n\t* src/validation_tests/Makefile.recipies: validation_tests: fix\n\t  linking against a CUDA enabled PAPI  Fix suggested by Steve\n\t  Kaufmann <sbk@cray.com>\n\t* src/testlib/papi_test.h, src/testlib/test_utils.c: testlib: make it\n\t  so it can compile with c++  this lets us link against it from the\n\t  CUDA tests\n\t* src/components/cuda/sampling/gpu_activity.c: tests: cuda: fix\n\t  sampling/gpu_activity to compile without warnings\n\t* src/Makefile.inc: tests: make the component tests build command be\n\t  the same as ctests/ftests\n\t* src/ctests/calibrate.c: ctests: calibrate: turn off printf if\n\t  TEST_QUIET  missed this one when testing because test machine\n\t  skipped it due to lack of floating point events\n\n2017-06-29  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* .../tests/perf_event_amd_northbridge.c,\n\t  src/ctests/Makefile.recipies, src/ctests/cycle_ratio.c,\n\t  src/ctests/derived.c, src/ctests/multiplex1_pthreads.c,\n\t  src/ctests/multiplex3_pthreads.c, src/ctests/overflow.c,\n\t  src/ctests/overflow_allcounters.c, src/ctests/overflow_index.c,\n\t  src/ctests/overflow_pthreads.c, src/ctests/overflow_twoevents.c,\n\t  src/ctests/prof_utils.c, src/ctests/prof_utils.h,\n\t  src/ctests/profile.c, src/ctests/profile_twoevents.c,\n\t  src/ctests/realtime.c, src/ctests/reset.c,\n\t  src/ctests/reset_multiplex.c, src/ctests/sdsc-mpx.c,\n\t  src/ctests/sdsc.c, src/ctests/sdsc4-mpx.c, src/ctests/sdsc4.c,\n\t  src/ctests/shlib.c, src/ctests/tenth.c, src/ctests/thrspecific.c,\n\t  src/testlib/papi_test.h: testlib: remove the hack where all\n\t  printf's are #defined to something else  Explicitly check\n\t  everywhere for TESTS_QUIET or equivelent, rather than using c-pre-\n\t  processor macros to redefine printf\n\t* src/papi.c, src/testlib/test_utils.c: tests: set the ctest debug\n\t  mode to VERBOSE by default for tests  the TESTS_QUIET mode was\n\t  turning *off* verbose debugging, which meant that PAPIERROR() calls\n\t  wouldn't show up during a ./run_tests.sh\n\t* src/components/perf_event/perf_event.c: perf_event: properly\n\t  initialize the mmap_addr structure  It wasn't always being set to\n\t  NULL, and so on some tests the code would try to munmap() it even\n\t  though it wasn't mapped.\n\t* src/testlib/test_utils.c: tests: enable color in test status\n\t  messages  this has been an optional feature for a long time, if you\n\t  enabled the environment variable TESTS_COLOR=y  this change makes\n\t  it default to being on (you can disable with export TESTS_COLOR=n\n\t  also it should automatically detect if you are piping to a file and\n\t  disable colors in the case too\n\t* src/validation_tests/Makefile,\n\t  src/validation_tests/Makefile.recipies: validation_tests: always\n\t  include -lrt on the tests  Should be harmless, and I don't always\n\t  test on an old enough machine to trigger the problem.\n\t* src/ctests/forkexec.c, src/ctests/forkexec2.c,\n\t  src/ctests/forkexec3.c, src/ctests/forkexec4.c,\n\t  src/ctests/multiplex3_pthreads.c,\n\t  src/ctests/system_child_overflow.c: ctests: make the fork/exec\n\t  tests only print \"PASSED\" once  this makes the run_test.sh input\n\t  look a lot nicer\n\t* src/run_tests.sh, src/testlib/test_utils.c: tests: make the output\n\t  from run_tests.sh more compact\n\n2017-06-28  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* .../perf_event/tests/perf_event_system_wide.c: perf_event: tests,\n\t  make perf_event_system_wide use INS rather than CYC  cycles varied\n\t  too much, making the validation fail\n\t* src/validation_tests/Makefile.recipies,\n\t  src/validation_tests/papi_br_cn.c,\n\t  src/validation_tests/papi_br_ucn.c: validation_tests: add tests for\n\t  PAPI_BR_CN and PAPI_BR_UCN\n\t* src/validation_tests/flops.c: validation_tests: flops: wasn't\n\t  falling back properly if no FLOPS event\n\t* src/utils/Makefile, src/validation_tests/Makefile.recipies: tests:\n\t  clean up the Makefiles\n\t* src/utils/print_header.c: utils: print_header: print the operating\n\t  system version in the header\n\t* .../tests/perf_event_amd_northbridge.c: perf_event_uncore: the\n\t  perf_event_amd_northbridge test wasn't working  it maybe never\n\t  worked at all?  It was hardcoded to thinking it was running on a\n\t  3.9 kernel always.\n\t* src/ctests/Makefile, src/ctests/Makefile.recipies,\n\t  src/ctests/zero.c: ctests: zero: complete transition from FLOPS to\n\t  INS as metric  this will make it more likely to be runnable on\n\t  modern machines.\n\t* src/ctests/vector.c, src/validation_tests/vector_testcode.c:\n\t  validation_tests: move the unused vector.c code  maybe we should\n\t  remove it.  It was never built as far as I can tell.\n\t* src/validation_tests/Makefile.recipies,\n\t  src/validation_tests/flops.c: validation_tests: add a generic flops\n\t  test based on hl_rates  we do a lot of testing of the high-level\n\t  interface but not as much of the regular PAPI interface.\n\t* src/ctests/Makefile.recipies, src/ctests/hl_rates.c,\n\t  src/validation_tests/flops_testcode.c,\n\t  src/validation_tests/testcode.h: ctests: hl_rates: clean up and fix\n\t  extraneous error message  the error message was due to the way\n\t  TESTS_QUIET is passed as a command line argument.  also made it use\n\t  the same matrix-multiply code that the flops test uses.  also added\n\t  some validation to the results.\n\t* src/ctests/all_events.c: ctests: all_events: issue warning if\n\t  preset cannot be created  specifically this came up on an AMD\n\t  fam15h system where the PAPI_L1_ICH event cannot be created due to\n\t  Linux stealing a counter for the NMI watchdog\n\t* src/validation_tests/papi_hw_int.c: validation_tests: papi_hw_int\n\t  explicitly mark large constant as ULL  compiler was warning on\n\t  32-bit machine\n\t* src/validation_tests/papi_ld_ins.c,\n\t  src/validation_tests/papi_sr_ins.c,\n\t  src/validation_tests/papi_tot_cyc.c: validation_tests:  a few tests\n\t  had the !quiet check inverted\n\t* src/validation_tests/papi_hw_int.c: validation_tests: fix\n\t  papi_hw_int looping forever  somehow the loop exit line got lost\n\t* src/validation_tests/Makefile.recipies,\n\t  src/validation_tests/matrix_multiply.c,\n\t  src/validation_tests/matrix_multiply.h,\n\t  src/validation_tests/papi_ld_ins.c,\n\t  src/validation_tests/papi_sr_ins.c: validation_tests: add\n\t  PAPI_SR_INS test\n\t* src/validation_tests/Makefile.recipies,\n\t  src/validation_tests/matrix_multiply.c,\n\t  src/validation_tests/matrix_multiply.h,\n\t  src/validation_tests/papi_hw_int.c,\n\t  src/validation_tests/papi_ld_ins.c: validation_tests: add\n\t  PAPI_LD_INS test\n\t* src/run_tests.sh, src/validation_tests/Makefile.recipies,\n\t  src/validation_tests/papi_hw_int.c: validation_tests: add\n\t  PAPI_HW_INT test\n\n2017-06-27  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/run_tests_exclude.txt: run_tests_exclude: add attach_target\n\t  not really a test so we shouldn't run it\n\t* src/ctests/byte_profile.c, src/ctests/earprofile.c,\n\t  src/ctests/prof_utils.c, src/ctests/prof_utils.h:\n\t  ctests/prof_utils: remove prof_init() helper  It didn't do much\n\t  more than a papi_init, probably better to have each file do that in\n\t  the open.\n\t* src/ctests/inherit.c, src/ctests/ipc.c, src/ctests/johnmay2.c,\n\t  src/ctests/krentel_pthreads.c, src/ctests/kufrin.c, src/ctests/low-\n\t  level.c, src/ctests/mendes-alt.c, src/ctests/multiplex1.c,\n\t  src/ctests/multiplex1_pthreads.c, src/ctests/multiplex2.c,\n\t  src/ctests/multiplex3_pthreads.c, src/ctests/overflow.c,\n\t  src/ctests/overflow2.c, src/ctests/overflow3_pthreads.c,\n\t  src/ctests/overflow_allcounters.c, src/ctests/overflow_index.c,\n\t  src/ctests/overflow_one_and_read.c,\n\t  src/ctests/overflow_single_event.c,\n\t  src/ctests/overflow_twoevents.c, src/ctests/prof_utils.c,\n\t  src/ctests/profile.c, src/ctests/profile_pthreads.c,\n\t  src/ctests/profile_twoevents.c, src/ctests/remove_events.c,\n\t  src/ctests/sprofile.c, src/ctests/zero.c, src/ctests/zero_flip.c,\n\t  src/ctests/zero_named.c, src/testlib/test_utils.c: ctests: skip\n\t  rather than fail if no events available\n\n2017-06-26  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/ctests/first.c, src/ctests/mpifirst.c,\n\t  src/ctests/multiattach.c, src/ctests/multiattach2.c,\n\t  src/testlib/test_utils.c: testlib: fix add_two_events()  was not\n\t  setting some values, causing many tests to fail\n\t* src/ctests/attach2.c, src/ctests/system_overflow.c: ctests:\n\t  compiler warning caught two lack-of-braces mistakes\n\t* src/ctests/byte_profile.c, src/ctests/code2name.c,\n\t  src/ctests/describe.c, src/testlib/test_utils.c: tests: more\n\t  changes to skip instead of fail if no events available\n\t* src/ctests/Makefile.recipies, src/ctests/child_overflow.c,\n\t  src/ctests/exec_overflow.c, src/ctests/fork_exec_overflow.c,\n\t  src/ctests/fork_overflow.c, src/ctests/system_child_overflow.c,\n\t  src/ctests/system_overflow.c: ctests: break up the\n\t  for_exec_overflow test  it was really four benchmarks with some\n\t  ifdefs  the proper way to do that would be to have a common C file\n\t  and link against it for the shared routines, rather than using the\n\t  pre-processor\n\t* src/ctests/attach2.c, src/ctests/attach3.c,\n\t  src/ctests/attach_cpu.c: ctests: have attach tests cleanly skip if\n\t  no events available\n\t* src/testlib/test_utils.c: testlib: update add_two_events to skip()\n\t  if not events found\n\t* src/ctests/mendes-alt.c, src/ctests/multiplex2.c,\n\t  src/ctests/multiplex3_pthreads.c, src/ctests/sdsc.c,\n\t  src/ctests/sdsc2.c, src/ctests/sdsc4.c, src/testlib/papi_test.h,\n\t  src/testlib/test_utils.c: testutils: remove init_multiplex() test\n\t  helper  the only benefit it had over calling PAPI_multiplex_init()\n\t  was a domain workaround for perfctr+power6 systems.  Ideally not\n\t  many of those systems are around anymore, an in any case a proper\n\t  fix would have the perfctr component handle that, not the testing\n\t  library.\n\t* .../perf_event/tests/perf_event_system_wide.c,\n\t  .../perf_event/tests/perf_event_user_kernel.c, src/ctests/api.c,\n\t  src/ctests/byte_profile.c, src/ctests/high-level.c,\n\t  src/ctests/hl_rates.c, src/validation_tests/papi_br_ins.c,\n\t  src/validation_tests/papi_br_msp.c,\n\t  src/validation_tests/papi_tot_cyc.c,\n\t  src/validation_tests/papi_tot_ins.c: tests: try to \"skip\" rather\n\t  than \"fail\" if no events available\n\t* src/ctests/derived.c: ctests: derived: fix warning found on older\n\t  gcc\n\t* src/ctests/high-level2.c: ctests: clean up high-level2 test  skip\n\t  on machine without flops/flips event\n\t* src/components/Makefile_comp_tests.target.in: components test: fix\n\t  another build issue  be sure to use local copy of papi.h\n\t* src/components/Makefile_comp_tests.target.in: component tests: fix\n\t  build issue  was trying to use the system version of libpapi.a\n\t  instead of local version\n\t* src/components/appio/tests/Makefile,\n\t  src/components/appio/tests/appio_list_events.c,\n\t  src/components/appio/tests/appio_values_by_code.c,\n\t  src/components/coretemp/tests/Makefile,\n\t  src/components/example/tests/Makefile,\n\t  src/components/host_micpower/tests/Makefile,\n\t  src/components/infiniband/tests/Makefile,\n\t  .../infiniband/tests/infiniband_values_by_code.c,\n\t  src/components/infiniband_umad/tests/Makefile,\n\t  .../tests/infiniband_umad_values_by_code.c,\n\t  src/components/lustre/tests/Makefile,\n\t  src/components/micpower/tests/Makefile,\n\t  src/components/mx/tests/Makefile,\n\t  src/components/net/tests/Makefile,\n\t  src/components/perf_event/tests/Makefile,\n\t  src/components/perf_event_uncore/tests/Makefile,\n\t  src/components/powercap/tests/Makefile,\n\t  src/components/rapl/tests/Makefile,\n\t  src/components/stealtime/tests/Makefile: components: update\n\t  component test Makefiles to include Makefile_comp_test.target\n\t* src/components/Makefile_comp_tests.target.in: components: update\n\t  Makefile_comp_test.target.in  should now be usable by the\n\t  components without many Makefile changes\n\t* src/components/perf_event/tests/Makefile,\n\t  src/components/perf_event/tests/nmi_watchdog.c,\n\t  src/ctests/Makefile.recipies, src/ctests/nmi_watchdog.c: ctests:\n\t  nmi_watchdog is a perf_event specific test, move it there\n\t* src/components/Makefile_comp_tests.target.in,\n\t  src/components/README, src/components/perf_event/tests/Makefile:\n\t  components: update the autoconfigure to generate more useful\n\t  Makefile.target.in  although I don't think most components are\n\t  using it at all\n\n2017-06-26  Asim YarKhan <yarkhan@icl.utk.edu>\n\n\t* src/components/cuda/Makefile.cuda.in, src/components/cuda/README,\n\t  src/components/cuda/Rules.cuda, src/components/cuda/configure,\n\t  src/components/cuda/configure.in, src/components/cuda/linux-cuda.c,\n\t  src/components/cuda/sampling/Makefile,\n\t  src/components/cuda/tests/HelloWorld.cu,\n\t  src/components/cuda/tests/Makefile,\n\t  src/components/cuda/tests/simpleMultiGPU.cu: CUDA component update:\n\t  Support for CUPTI metrics (early release)  This commit adds support\n\t  for CUPTI metrics, which are higher level measures that may be\n\t  decompsed into multiple lower level CUPTI events.  Known problems\n\t  and limitations in early release of metric support * Only sets of\n\t  metrics and events that can be gathered in a single pass are\n\t  supported.  Transparent multi-pass support is expected * All\n\t  metrics are returned as long long integers, which means that CUPTI\n\t  double precision values will be truncated, possibly severely. * The\n\t  NVLink metrics have been disabled for this alpha release.\n\n2017-06-23  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/validation_tests/papi_fp_ops.c: validation: papi_fp_ops, skip\n\t  (not fail) if PAPI_FP_OPS unavailable\n\t* src/ctests/Makefile, src/ctests/Makefile.recipies,\n\t  src/ctests/Makefile.target.in, src/ctests/flops.c: ctests: flops,\n\t  update to use some of the validate_tests infrastructure\n\t* src/validation_tests/Makefile.recipies,\n\t  src/validation_tests/flops_testcode.c,\n\t  src/validation_tests/papi_fp_ops.c,\n\t  src/validation_tests/testcode.h: validation_tests: add papi_fp_ops\n\t  test  tested on an AMD fam15h machine\n\t* src/components/powercap/tests/powercap_basic.c: powercap: fix\n\t  compiler warnings in the powercap_basic test\n\t* src/ctests/flops.c: ctests: update flops test\n\t* src/ctests/api.c: ctests: update api test  only seems to test the\n\t  high-level API\n\t* src/ctests/all_native_events.c: ctests: update all_native_events\n\t  removed some ancient warnings about uncore/offcore events. Should\n\t  not be a problem on libpfm4/perf_event\n\t* src/ctests/all_events.c: ctests: clean up all_events test\n\t* src/components/appio/tests/appio_list_events.c,\n\t  src/components/appio/tests/appio_test_blocking.c,\n\t  .../appio/tests/appio_test_fread_fwrite.c,\n\t  src/components/appio/tests/appio_test_pthreads.c,\n\t  src/components/appio/tests/appio_test_read_write.c,\n\t  src/components/appio/tests/appio_test_recv.c,\n\t  src/components/appio/tests/appio_test_seek.c,\n\t  src/components/appio/tests/appio_test_select.c,\n\t  src/components/appio/tests/appio_test_socket.c,\n\t  src/components/appio/tests/appio_values_by_code.c,\n\t  src/components/appio/tests/appio_values_by_name.c,\n\t  src/components/coretemp/tests/coretemp_basic.c,\n\t  src/components/coretemp/tests/coretemp_pretty.c,\n\t  src/components/example/tests/example_basic.c,\n\t  .../example/tests/example_multiple_components.c,\n\t  .../host_micpower/tests/host_micpower_basic.c,\n\t  .../infiniband/tests/infiniband_list_events.c,\n\t  .../infiniband/tests/infiniband_values_by_code.c,\n\t  .../tests/infiniband_umad_list_events.c,\n\t  src/components/libmsr/tests/libmsr_basic.c,\n\t  src/components/lustre/tests/lustre_basic.c,\n\t  src/components/micpower/tests/micpower_basic.c,\n\t  src/components/mx/tests/mx_basic.c,\n\t  src/components/mx/tests/mx_elapsed.c,\n\t  src/components/net/tests/net_list_events.c,\n\t  src/components/net/tests/net_values_by_code.c,\n\t  src/components/net/tests/net_values_by_name.c,\n\t  .../perf_event/tests/perf_event_offcore_response.c,\n\t  .../perf_event/tests/perf_event_system_wide.c,\n\t  .../perf_event/tests/perf_event_user_kernel.c,\n\t  .../tests/perf_event_amd_northbridge.c,\n\t  .../perf_event_uncore/tests/perf_event_uncore.c,\n\t  .../tests/perf_event_uncore_cbox.c,\n\t  .../tests/perf_event_uncore_multiple.c,\n\t  src/components/powercap/tests/powercap_basic.c,\n\t  src/components/rapl/tests/rapl_basic.c,\n\t  src/components/rapl/tests/rapl_overflow.c,\n\t  src/components/stealtime/tests/stealtime_basic.c,\n\t  src/components/vmware/tests/vmware_basic.c,\n\t  src/ctests/all_events.c, src/ctests/all_native_events.c,\n\t  src/ctests/api.c, src/ctests/attach2.c, src/ctests/attach3.c,\n\t  src/ctests/attach_cpu.c, src/ctests/branches.c,\n\t  src/ctests/byte_profile.c, src/ctests/calibrate.c,\n\t  src/ctests/case1.c, src/ctests/case2.c,\n\t  src/ctests/clockres_pthreads.c, src/ctests/cmpinfo.c,\n\t  src/ctests/code2name.c, src/ctests/cycle_ratio.c,\n\t  src/ctests/data_range.c, src/ctests/derived.c,\n\t  src/ctests/describe.c, src/ctests/disable_component.c,\n\t  src/ctests/dmem_info.c, src/ctests/earprofile.c,\n\t  src/ctests/eventname.c, src/ctests/exec.c, src/ctests/exec2.c,\n\t  src/ctests/exeinfo.c, src/ctests/first.c, src/ctests/flops.c,\n\t  src/ctests/fork.c, src/ctests/fork2.c,\n\t  src/ctests/fork_exec_overflow.c, src/ctests/forkexec.c,\n\t  src/ctests/forkexec2.c, src/ctests/forkexec3.c,\n\t  src/ctests/forkexec4.c, src/ctests/get_event_component.c,\n\t  src/ctests/high-level.c, src/ctests/high-level2.c,\n\t  src/ctests/hl_rates.c, src/ctests/hwinfo.c, src/ctests/inherit.c,\n\t  src/ctests/ipc.c, src/ctests/johnmay2.c,\n\t  src/ctests/krentel_pthreads.c, src/ctests/kufrin.c,\n\t  src/ctests/locks_pthreads.c, src/ctests/low-level.c, src/ctests\n\t  /matrix-hl.c, src/ctests/max_multiplex.c, src/ctests/memory.c,\n\t  src/ctests/mendes-alt.c, src/ctests/multiattach.c,\n\t  src/ctests/multiattach2.c, src/ctests/multiplex1.c,\n\t  src/ctests/multiplex1_pthreads.c, src/ctests/multiplex2.c,\n\t  src/ctests/multiplex3_pthreads.c, src/ctests/nmi_watchdog.c,\n\t  src/ctests/omptough.c, src/ctests/overflow.c,\n\t  src/ctests/overflow2.c, src/ctests/overflow3_pthreads.c,\n\t  src/ctests/overflow_allcounters.c,\n\t  src/ctests/overflow_force_software.c, src/ctests/overflow_index.c,\n\t  src/ctests/overflow_one_and_read.c, src/ctests/overflow_pthreads.c,\n\t  src/ctests/overflow_single_event.c,\n\t  src/ctests/overflow_twoevents.c, src/ctests/p4_lst_ins.c,\n\t  src/ctests/profile.c, src/ctests/profile_pthreads.c,\n\t  src/ctests/profile_twoevents.c, src/ctests/pthrtough.c,\n\t  src/ctests/pthrtough2.c, src/ctests/realtime.c,\n\t  src/ctests/remove_events.c, src/ctests/reset.c,\n\t  src/ctests/reset_multiplex.c, src/ctests/sdsc.c,\n\t  src/ctests/sdsc2.c, src/ctests/sdsc4.c, src/ctests/second.c,\n\t  src/ctests/shlib.c, src/ctests/sprofile.c, src/ctests/tenth.c,\n\t  src/ctests/thrspecific.c, src/ctests/timer_overflow.c,\n\t  src/ctests/virttime.c, src/ctests/zero.c, src/ctests/zero_attach.c,\n\t  src/ctests/zero_flip.c, src/ctests/zero_fork.c,\n\t  src/ctests/zero_named.c, src/ctests/zero_omp.c,\n\t  src/ctests/zero_pthreads.c, src/ctests/zero_smp.c,\n\t  src/testlib/papi_test.h, src/testlib/test_utils.c,\n\t  src/validation_tests/papi_br_ins.c,\n\t  src/validation_tests/papi_br_msp.c,\n\t  src/validation_tests/papi_tot_cyc.c,\n\t  src/validation_tests/papi_tot_ins.c: testlib: remove the \"free\n\t  variables\" option from test_pass()  It was only used by a small\n\t  handfull of tests, and wasn't really strictly necessary anyway.\n\t  test_pass() should pass the test and that's all.\n\t* src/ctests/zero.c: ctests: zero: start cleaning up this test\n\t* src/validation_tests/Makefile.recipies: validation_tests:\n\t  clock_gettime() requires -lrt on older versions of glibc\n\n2017-06-22  Will Schmidt <will_schmidt@vnet.ibm.com>\n\n\t* src/linux-memory.c, src/papi_events.csv: PAPI power9 event list\n\t  presets  Here is an initial set of events and changes to help\n\t  support Power9.  This is based on similar changes that were made\n\t  for power8 when initial support was added there.  I've updated the\n\t  event names to match what we expect to have in power9, and have\n\t  done compile/build/ sniff tests.\n\n2017-06-22  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/ftests/Makefile.target.in: ftests: fortran tests weren't\n\t  getting the TOPTFLAGS var set\n\t* src/testlib/test_utils.c: testlib: fix colors not turning off in\n\t  pass/fail indicator\n\t* src/ctests/api.c, src/ctests/attach2.c, src/ctests/attach3.c,\n\t  src/ctests/attach_cpu.c, src/ctests/inherit.c,\n\t  src/ctests/multiattach.c, src/ctests/multiattach2.c,\n\t  src/ctests/zero_attach.c, src/testlib/papi_test.h,\n\t  src/testlib/test_utils.c: testlib: update the way pass/fail is\n\t  printed  It's been bugging me for years that they don't line up\n\t* src/run_tests.sh: run_tests.sh: run the validation tests too\n\t* src/Makefile.inc: Makefile.inc: make it compile the\n\t  validation_tests\n\t* src/validation_tests/Makefile.recipies,\n\t  src/validation_tests/papi_br_msp.c: validation-tests: add\n\t  papi_br_msp test\n\t* src/validation_tests/Makefile.recipies,\n\t  src/validation_tests/branches_testcode.c,\n\t  src/validation_tests/matrix_multiply.c,\n\t  src/validation_tests/matrix_multiply.h,\n\t  src/validation_tests/papi_br_ins.c,\n\t  src/validation_tests/testcode.h: validation_tests: add papi_br_ins\n\t  test\n\t* src/validation_tests/Makefile.recipies,\n\t  src/validation_tests/papi_tot_cyc.c: validation_tests: add\n\t  papi_tot_cyc test\n\t* src/Makefile.inc: fix \"make install-all\"  had some extraneous \"..\"\n\t  after some previous changes\n\t* src/configure, src/configure.in,\n\t  src/validation_tests/Makefile.target.in,\n\t  src/validation_tests/papi_tot_ins.c: validation_tests: update\n\t  configure so it sets up the Makefile\n\t* src/testlib/papi_test.h, src/testlib/test_utils.c: testlib:\n\t  papi_print_header() lives with the utils code now\n\t* src/testlib/papi_test.h, src/testlib/test_utils.c: testlib: make\n\t  tests_quiet() return an integer  This way we don't have to depend\n\t  on the global var TESTS_QUIET if we don't want to.\n\t* src/validation_tests/Makefile,\n\t  src/validation_tests/Makefile.recipies,\n\t  src/validation_tests/Makefile.target.in,\n\t  src/validation_tests/display_error.c,\n\t  src/validation_tests/display_error.h,\n\t  src/validation_tests/instructions_testcode.c,\n\t  src/validation_tests/papi_tot_ins.c,\n\t  src/validation_tests/testcode.h: validation_tests: add initial\n\t  papi_tot_ins test  it is not hooked up to the build system yet\n\t* src/ctests/multiplex1.c, src/ctests/multiplex2.c,\n\t  src/ctests/second.c, src/ctests/sprofile.c, src/ctests/virttime.c,\n\t  src/ctests/zero_attach.c, src/ctests/zero_flip.c,\n\t  src/ctests/zero_fork.c, src/ctests/zero_omp.c,\n\t  src/ctests/zero_pthreads.c: ctests: more printf/TESTS_QUIET\n\t  conversions\n\t* src/testlib/fpapi_test.h: ftests: missing define was making\n\t  second.F fail\n\t* src/ctests/johnmay2.c, src/ctests/krentel_pthreads.c,\n\t  src/ctests/kufrin.c, src/ctests/locks_pthreads.c,\n\t  src/ctests/memory.c, src/ctests/multiattach.c,\n\t  src/ctests/multiattach2.c, src/ctests/multiplex1.c: ctests: more\n\t  printf/TESTS_QUIET fixes\n\n2017-06-21  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/ctests/all_events.c, src/ctests/all_native_events.c,\n\t  src/ctests/attach2.c, src/ctests/attach3.c,\n\t  src/ctests/attach_cpu.c, src/ctests/byte_profile.c,\n\t  src/ctests/calibrate.c, src/ctests/cmpinfo.c,\n\t  src/ctests/code2name.c, src/ctests/cycle_ratio.c,\n\t  src/ctests/exeinfo.c, src/ctests/fork_exec_overflow.c,\n\t  src/ctests/hl_rates.c, src/ctests/hwinfo.c: ctests: explicitly\n\t  block printfs with TESTS_QUIET  There was some hackery with the\n\t  preprocessor to avoid this but that wasn't a good solution.\n\t* src/testlib/do_loops.h, src/testlib/papi_test.h,\n\t  src/testlib/test_utils.c: testlib: minor papi_test.h cleanups\n\t* .../perf_event/tests/perf_event_offcore_response.c,\n\t  .../perf_event/tests/perf_event_system_wide.c,\n\t  .../perf_event/tests/perf_event_user_kernel.c,\n\t  .../tests/perf_event_amd_northbridge.c,\n\t  .../perf_event_uncore/tests/perf_event_uncore.c,\n\t  .../perf_event_uncore/tests/perf_event_uncore_cbox.c,\n\t  .../tests/perf_event_uncore_multiple.c, src/ctests/attach2.c,\n\t  src/ctests/attach3.c, src/ctests/attach_cpu.c,\n\t  src/ctests/attach_target.c, src/ctests/branches.c,\n\t  src/ctests/burn.c, src/ctests/byte_profile.c,\n\t  src/ctests/cycle_ratio.c, src/ctests/derived.c,\n\t  src/ctests/dmem_info.c, src/ctests/earprofile.c,\n\t  src/ctests/first.c, src/ctests/high-level.c, src/ctests/inherit.c,\n\t  src/ctests/johnmay2.c, src/ctests/krentel_pthreads.c,\n\t  src/ctests/kufrin.c, src/ctests/locks_pthreads.c, src/ctests/low-\n\t  level.c, src/ctests/matrix-hl.c, src/ctests/memory.c,\n\t  src/ctests/multiattach.c, src/ctests/multiattach2.c,\n\t  src/ctests/multiplex1.c, src/ctests/multiplex1_pthreads.c,\n\t  src/ctests/multiplex2.c, src/ctests/multiplex3_pthreads.c,\n\t  src/ctests/overflow.c, src/ctests/overflow2.c,\n\t  src/ctests/overflow3_pthreads.c, src/ctests/overflow_allcounters.c,\n\t  src/ctests/overflow_force_software.c, src/ctests/overflow_index.c,\n\t  src/ctests/overflow_one_and_read.c,\n\t  src/ctests/overflow_single_event.c,\n\t  src/ctests/overflow_twoevents.c, src/ctests/p4_lst_ins.c,\n\t  src/ctests/prof_utils.c, src/ctests/profile.c,\n\t  src/ctests/profile_twoevents.c, src/ctests/remove_events.c,\n\t  src/ctests/reset.c, src/ctests/reset_multiplex.c,\n\t  src/ctests/sdsc.c, src/ctests/sdsc2.c, src/ctests/sdsc4.c,\n\t  src/ctests/second.c, src/ctests/sprofile.c, src/ctests/tenth.c,\n\t  src/ctests/zero.c, src/ctests/zero_attach.c,\n\t  src/ctests/zero_flip.c, src/ctests/zero_fork.c,\n\t  src/ctests/zero_named.c, src/ctests/zero_omp.c,\n\t  src/ctests/zero_pthreads.c, src/ctests/zero_shmem.c,\n\t  src/ctests/zero_smp.c, src/testlib/Makefile,\n\t  src/testlib/fpapi_test.h, src/testlib/papi_test.h,\n\t  src/testlib/test_utils.h: testlib: more papi_test.h reduction\n\t* src/testlib/Makefile: testlib: turn off optimization on the\n\t  validation loops  it's making tests fail, need to go back and be\n\t  sure we are properly tricking the compiler.\n\t* src/Makefile.inc, src/components/Makefile_comp_tests,\n\t  src/components/perf_event/tests/Makefile,\n\t  src/components/perf_event_uncore/tests/Makefile,\n\t  src/components/rapl/tests/Makefile,\n\t  src/components/rapl/tests/rapl_overflow.c, src/ctests/Makefile,\n\t  src/ctests/Makefile.recipies, src/ctests/overflow_pthreads.c,\n\t  src/ctests/profile_pthreads.c, src/ftests/Makefile,\n\t  src/ftests/Makefile.recipies, src/ftests/Makefile.target.in,\n\t  src/testlib/Makefile, src/testlib/do_loops.c,\n\t  src/testlib/do_loops.h, src/testlib/papi_test.h: testlib: start\n\t  splitting the validation code off from the pass/fail code\n\t* src/components/perf_event/tests/perf_event_offcore_response.c,\n\t  src/components/perf_event/tests/perf_event_system_wide.c,\n\t  src/components/perf_event/tests/perf_event_user_kernel.c, src/compo\n\t  nents/perf_event_uncore/tests/perf_event_amd_northbridge.c,\n\t  src/components/perf_event_uncore/tests/perf_event_uncore.c,\n\t  src/components/perf_event_uncore/tests/perf_event_uncore_cbox.c, sr\n\t  c/components/perf_event_uncore/tests/perf_event_uncore_multiple.c,\n\t  src/components/rapl/tests/rapl_basic.c,\n\t  src/components/rapl/tests/rapl_overflow.c,\n\t  src/ctests/all_native_events.c, src/ctests/attach2.c,\n\t  src/ctests/attach3.c, src/ctests/attach_cpu.c,\n\t  src/ctests/attach_target.c, src/ctests/branches.c,\n\t  src/ctests/burn.c, src/ctests/byte_profile.c,\n\t  src/ctests/calibrate.c, src/ctests/case1.c, src/ctests/case2.c,\n\t  src/ctests/clockres_pthreads.c, src/ctests/cmpinfo.c,\n\t  src/ctests/code2name.c, src/ctests/cycle_ratio.c,\n\t  src/ctests/data_range.c, src/ctests/derived.c,\n\t  src/ctests/describe.c, src/ctests/disable_component.c,\n\t  src/ctests/dmem_info.c, src/ctests/earprofile.c,\n\t  src/ctests/eventname.c, src/ctests/exec.c, src/ctests/exec2.c,\n\t  src/ctests/exeinfo.c, src/ctests/first.c, src/ctests/flops.c,\n\t  src/ctests/fork.c, src/ctests/fork2.c, src/ctests/forkexec.c,\n\t  src/ctests/forkexec2.c, src/ctests/forkexec3.c,\n\t  src/ctests/forkexec4.c, src/ctests/get_event_component.c,\n\t  src/ctests/high-level.c, src/ctests/high-level2.c,\n\t  src/ctests/hl_rates.c, src/ctests/hwinfo.c, src/ctests/inherit.c,\n\t  src/ctests/ipc.c, src/ctests/johnmay2.c,\n\t  src/ctests/krentel_pthreads.c, src/ctests/kufrin.c,\n\t  src/ctests/locks_pthreads.c, src/ctests/low-level.c, src/ctests\n\t  /matrix-hl.c, src/ctests/memory.c, src/ctests/mendes-alt.c,\n\t  src/ctests/multiattach.c, src/ctests/multiattach2.c,\n\t  src/ctests/multiplex1.c, src/ctests/multiplex1_pthreads.c,\n\t  src/ctests/multiplex2.c, src/ctests/multiplex3_pthreads.c,\n\t  src/ctests/nmi_watchdog.c, src/ctests/omptough.c,\n\t  src/ctests/overflow.c, src/ctests/overflow2.c,\n\t  src/ctests/overflow3_pthreads.c, src/ctests/overflow_allcounters.c,\n\t  src/ctests/overflow_force_software.c, src/ctests/overflow_index.c,\n\t  src/ctests/overflow_one_and_read.c, src/ctests/overflow_pthreads.c,\n\t  src/ctests/overflow_single_event.c,\n\t  src/ctests/overflow_twoevents.c, src/ctests/p4_lst_ins.c,\n\t  src/ctests/prof_utils.c, src/ctests/profile.c,\n\t  src/ctests/profile_pthreads.c, src/ctests/profile_twoevents.c,\n\t  src/ctests/pthrtough.c, src/ctests/pthrtough2.c,\n\t  src/ctests/realtime.c, src/ctests/remove_events.c,\n\t  src/ctests/reset.c, src/ctests/reset_multiplex.c,\n\t  src/ctests/sdsc.c, src/ctests/sdsc2.c, src/ctests/sdsc4.c,\n\t  src/ctests/second.c, src/ctests/shlib.c, src/ctests/sprofile.c,\n\t  src/ctests/tenth.c, src/ctests/thrspecific.c,\n\t  src/ctests/timer_overflow.c, src/ctests/virttime.c,\n\t  src/ctests/zero.c, src/ctests/zero_attach.c,\n\t  src/ctests/zero_flip.c, src/ctests/zero_fork.c,\n\t  src/ctests/zero_named.c, src/ctests/zero_omp.c,\n\t  src/ctests/zero_pthreads.c, src/ctests/zero_shmem.c,\n\t  src/ctests/zero_smp.c, src/testlib/do_loops.c,\n\t  src/testlib/papi_test.h, src/testlib/test_utils.c: testlib: remove\n\t  include of papi.h  Need to explicitly include it in your test if\n\t  you need it.\n\t* src/testlib/Makefile, src/testlib/do_loops.c,\n\t  src/testlib/do_loops.h, src/testlib/dummy.c, src/utils/Makefile,\n\t  src/utils/papi_command_line.c, src/utils/papi_cost.c: utils: remove\n\t  last uses of testlib\n\t* src/utils/Makefile, src/utils/papi_hybrid_native_avail.c: utils:\n\t  update papi_hybrid_native_avail to not depend on testlib\n\t* src/utils/papi_multiplex_cost.c: utils: clean up\n\t  papi_multiplex_cost  remove dependeicnes on papi_test.h  print\n\t  message warning that it can take a long time to run\n\t* .../perf_event/tests/perf_event_offcore_response.c,\n\t  .../perf_event/tests/perf_event_system_wide.c,\n\t  .../perf_event/tests/perf_event_user_kernel.c,\n\t  .../perf_event_uncore/perf_event_uncore.c,\n\t  .../tests/perf_event_amd_northbridge.c,\n\t  .../perf_event_uncore/tests/perf_event_uncore.c,\n\t  .../tests/perf_event_uncore_cbox.c,\n\t  .../tests/perf_event_uncore_multiple.c,\n\t  src/components/rapl/tests/rapl_basic.c,\n\t  src/components/rapl/tests/rapl_overflow.c,\n\t  src/ctests/all_native_events.c, src/ctests/attach2.c,\n\t  src/ctests/attach3.c, src/ctests/branches.c,\n\t  src/ctests/byte_profile.c, src/ctests/calibrate.c,\n\t  src/ctests/data_range.c, src/ctests/describe.c,\n\t  src/ctests/disable_component.c, src/ctests/earprofile.c,\n\t  src/ctests/exec.c, src/ctests/exec2.c, src/ctests/exeinfo.c,\n\t  src/ctests/first.c, src/ctests/forkexec.c, src/ctests/forkexec2.c,\n\t  src/ctests/forkexec3.c, src/ctests/forkexec4.c,\n\t  src/ctests/get_event_component.c, src/ctests/inherit.c,\n\t  src/ctests/krentel_pthreads.c, src/ctests/kufrin.c, src/ctests\n\t  /matrix-hl.c, src/ctests/multiplex1.c,\n\t  src/ctests/multiplex1_pthreads.c, src/ctests/multiplex2.c,\n\t  src/ctests/nmi_watchdog.c, src/ctests/overflow_allcounters.c,\n\t  src/ctests/overflow_force_software.c,\n\t  src/ctests/overflow_pthreads.c, src/ctests/overflow_single_event.c,\n\t  src/ctests/overflow_twoevents.c, src/ctests/prof_utils.c,\n\t  src/ctests/profile_pthreads.c, src/ctests/remove_events.c,\n\t  src/ctests/reset.c, src/ctests/reset_multiplex.c,\n\t  src/ctests/sdsc.c, src/ctests/sdsc2.c, src/ctests/sdsc4.c,\n\t  src/ctests/second.c, src/ctests/shlib.c,\n\t  src/ctests/timer_overflow.c, src/ctests/zero_named.c,\n\t  src/testlib/do_loops.c, src/testlib/papi_test.h,\n\t  src/testlib/test_utils.c, src/utils/Makefile,\n\t  src/utils/cost_utils.c, src/utils/papi_command_line.c,\n\t  src/utils/papi_cost.c, src/utils/papi_event_chooser.c: testlib:\n\t  more header removal from papi_test.h\n\t* src/components/perf_event/tests/perf_event_system_wide.c,\n\t  src/ctests/attach2.c, src/ctests/attach3.c,\n\t  src/ctests/multiattach.c, src/ctests/multiattach2.c,\n\t  src/ctests/zero_attach.c, src/testlib/papi_test.h,\n\t  src/utils/cost_utils.c: testlib: remove a few more includes from\n\t  papi_test.h\n\t* src/components/rapl/tests/rapl_basic.c, src/ctests/all_events.c,\n\t  src/ctests/all_native_events.c, src/ctests/api.c,\n\t  src/ctests/attach2.c, src/ctests/attach3.c,\n\t  src/ctests/attach_cpu.c, src/ctests/attach_target.c,\n\t  src/ctests/branches.c, src/ctests/burn.c, src/ctests/calibrate.c,\n\t  src/ctests/case1.c, src/ctests/case2.c,\n\t  src/ctests/clockres_pthreads.c, src/ctests/code2name.c,\n\t  src/ctests/cycle_ratio.c, src/ctests/data_range.c,\n\t  src/ctests/derived.c, src/ctests/describe.c,\n\t  src/ctests/dmem_info.c, src/ctests/earprofile.c,\n\t  src/ctests/eventname.c, src/ctests/exec.c, src/ctests/exec2.c,\n\t  src/ctests/exeinfo.c, src/ctests/flops.c, src/ctests/fork.c,\n\t  src/ctests/fork2.c, src/ctests/forkexec.c, src/ctests/forkexec2.c,\n\t  src/ctests/forkexec3.c, src/ctests/forkexec4.c, src/ctests/high-\n\t  level.c, src/ctests/high-level2.c, src/ctests/hl_rates.c,\n\t  src/ctests/hwinfo.c, src/ctests/inherit.c, src/ctests/ipc.c,\n\t  src/ctests/johnmay2.c, src/ctests/kufrin.c,\n\t  src/ctests/locks_pthreads.c, src/ctests/low-level.c,\n\t  src/ctests/max_multiplex.c, src/ctests/memory.c,\n\t  src/ctests/multiattach.c, src/ctests/multiattach2.c,\n\t  src/ctests/multiplex1.c, src/ctests/multiplex1_pthreads.c,\n\t  src/ctests/multiplex2.c, src/ctests/multiplex3_pthreads.c,\n\t  src/ctests/overflow.c, src/ctests/overflow2.c,\n\t  src/ctests/overflow3_pthreads.c, src/ctests/overflow_allcounters.c,\n\t  src/ctests/overflow_force_software.c, src/ctests/overflow_index.c,\n\t  src/ctests/overflow_one_and_read.c, src/ctests/overflow_pthreads.c,\n\t  src/ctests/overflow_single_event.c,\n\t  src/ctests/overflow_twoevents.c, src/ctests/p4_lst_ins.c,\n\t  src/ctests/prof_utils.c, src/ctests/profile.c,\n\t  src/ctests/profile_pthreads.c, src/ctests/profile_twoevents.c,\n\t  src/ctests/pthrtough.c, src/ctests/pthrtough2.c,\n\t  src/ctests/realtime.c, src/ctests/sdsc.c, src/ctests/sdsc2.c,\n\t  src/ctests/sdsc4.c, src/ctests/second.c, src/ctests/shlib.c,\n\t  src/ctests/sprofile.c, src/ctests/tenth.c,\n\t  src/ctests/thrspecific.c, src/ctests/timer_overflow.c,\n\t  src/ctests/virttime.c, src/ctests/zero.c, src/ctests/zero_attach.c,\n\t  src/ctests/zero_flip.c, src/ctests/zero_fork.c,\n\t  src/ctests/zero_omp.c, src/ctests/zero_pthreads.c,\n\t  src/ctests/zero_shmem.c, src/ctests/zero_smp.c,\n\t  src/testlib/do_loops.c, src/testlib/dummy.c,\n\t  src/testlib/papi_test.h, src/testlib/test_utils.c,\n\t  src/utils/papi_command_line.c, src/utils/papi_cost.c: testlib:\n\t  split some headers out of papi_test.h  Too much is going on in that\n\t  header, no need to have every include in the world in it.  Trying\n\t  to make the testcode more standalone so it is easier to follow.\n\t* src/testlib/Makefile, src/testlib/Makefile.target.in: testlib: let\n\t  testlib build properly from within the testlib directory\n\t* src/testlib/clockcore.c: testlib: clockcore wasn't protecting all\n\t  the output with !quiet\n\t* src/ctests/Makefile: ctests: make sure tests link against the right\n\t  papi.h file\n\t* src/Makefile.inc, src/ctests/Makefile,\n\t  src/ctests/Makefile.target.in: ctests: allow running \"make\" in the\n\t  ctests directory to work\n\n2017-06-20  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/Matlab/PAPI_Matlab.readme, src/papi.c, src/utils/papi_avail.c,\n\t  src/utils/papi_clockres.c, src/utils/papi_command_line.c,\n\t  src/utils/papi_component_avail.c, src/utils/papi_cost.c,\n\t  src/utils/papi_decode.c, src/utils/papi_error_codes.c,\n\t  src/utils/papi_event_chooser.c,\n\t  src/utils/papi_hybrid_native_avail.c, src/utils/papi_mem_info.c,\n\t  src/utils/papi_multiplex_cost.c, src/utils/papi_native_avail.c,\n\t  src/utils/papi_version.c, src/utils/papi_xml_event_info.c: update\n\t  the ptools-perfapi e-mail address  in the auto-generated manpages\n\t  it was still using the old ptools.org address.\n\t* doc/Makefile: docs: fix the manpage build after renaming the utils\n\t  Thanks to Steve Kaufmann for catching this.\n\t* src/utils/Makefile, src/utils/papi_native_avail.c: utils:\n\t  papi_native_avail: remove extraneous testing code\n\t* src/utils/Makefile, src/utils/papi_mem_info.c: utils:\n\t  papi_mem_info: remove extraneous test code\n\t* src/utils/Makefile, src/utils/papi_xml_event_info.c: utils:\n\t  papi_xml_event_info: remove extraneous test code\n\t* src/utils/Makefile, src/utils/papi_decode.c: utils: papi_decode:\n\t  remove extraneous test code\n\t* src/utils/Makefile, src/utils/papi_error_codes.c: utils:\n\t  papi_error_codes: remove extraneous test code\n\t* src/utils/Makefile, src/utils/papi_component_avail.c: utils:\n\t  papi_component_avail: remove extraneous test code\n\t* src/ctests/clockres_pthreads.c, src/testlib/clockcore.c,\n\t  src/testlib/clockcore.h, src/testlib/papi_test.h,\n\t  src/utils/Makefile, src/utils/papi_clockres.c: utils:\n\t  papi_clockres, remove extraneous test code\n\t* src/utils/Makefile, src/utils/papi_avail.c,\n\t  src/utils/print_header.c, src/utils/print_header.h: utils: update\n\t  papi_avail to not depend on testlibs  It's not a test.\n\t* src/utils/Makefile: utils: add target for papi_hybrid_native_avail\n\t  do not build it by default though?  Should only be built if\n\t  compiling for MIC?\n\t* src/utils/Makefile, src/utils/avail.c, src/utils/clockres.c,\n\t  src/utils/command_line.c, src/utils/component.c, src/utils/cost.c,\n\t  src/utils/decode.c, src/utils/error_codes.c,\n\t  src/utils/event_chooser.c, src/utils/event_info.c,\n\t  src/utils/hybrid_native_avail.c, src/utils/mem_info.c,\n\t  src/utils/multiplex_cost.c, src/utils/native_avail.c,\n\t  src/utils/papi_avail.c, src/utils/papi_clockres.c,\n\t  src/utils/papi_command_line.c, src/utils/papi_component_avail.c,\n\t  src/utils/papi_cost.c, src/utils/papi_decode.c,\n\t  src/utils/papi_error_codes.c, src/utils/papi_event_chooser.c,\n\t  src/utils/papi_hybrid_native_avail.c, src/utils/papi_mem_info.c,\n\t  src/utils/papi_multiplex_cost.c, src/utils/papi_native_avail.c,\n\t  src/utils/papi_xml_event_info.c: utils: rename the utils so the\n\t  executable matches the filename  This has bothered me for years,\n\t  you want to fix \"papi_native_avail\" but there is no file in the\n\t  tree called \"papi_native_avail.c\"\n\t* src/utils/Makefile, src/utils/papi_version.c, src/utils/version.c:\n\t  utils: rename version.c to papi_version.c  Also minor cleanups to\n\t  the utility.\n\t* src/Makefile.inc, src/configure, src/configure.in,\n\t  src/utils/Makefile, src/utils/Makefile.target.in: utils: clean up\n\t  Makefile and build process of utils  Now should be able to run\n\t  \"make\" in the utils subdir and have it build.  Also move the list\n\t  of util files to build out of configure as I don't think there's\n\t  any reason for having them there.\n\t* src/components/perf_event/pe_libpfm4_events.c: perf: fall back to\n\t  operating system default events if libpfm4 lacks support  This will\n\t  allow use of PAPI on machines that Linux has support for, but\n\t  libpfm4 has not added events yet.  Still some limitations, for\n\t  example the PAPI preset events won't work.\n\t* src/components/perf_event/pe_libpfm4_events.c,\n\t  src/components/perf_event/perf_event.c: perf: report better errors\n\t  if libpfm4 initialization fails\n\t* src/components/perf_event/pe_libpfm4_events.c: perf:\n\t  pe_libpfm4_events: minor whitespace fixup\n\t* src/components/perf_event/pe_libpfm4_events.c: perf:\n\t  pe_libpfm4_events: whitespace changes to make code easier to follow\n\n2017-06-19  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/ctests/code2name.c: ctests/code2name: fix uninitialized\n\t  variable warning\n\t* src/ctests/calibrate.c: ctests/calibrate: fix uninitialized\n\t  variable warning\n\t* src/ctests/thrspecific.c: ctests: thrspecific fix so it finishes\n\t  It's actually really unclear what this code is trying to test, but\n\t  with optimization enabled it hung forever.  Marking the variable\n\t  being spun on as volatile fixes things but I think there is more\n\t  wrong with the test than just that.\n\t* src/ctests/branches.c, src/ctests/sdsc.c, src/ctests/sdsc4.c:\n\t  ctests: fix tests using \"dummy3()\" as a workload  Now that we\n\t  enable optimization on the ctests this breaks some of the\n\t  benchmarks.  dummy3() was being optimized away which caused\n\t  segfaults and other problems.  The tests don't crash now, but they\n\t  still fail.  Still investigating.\n\n2016-10-12  Phil Mucci <phil@minimalmetrics.com>\n\n\t* src/configure: Regenerated configure with recent autoconf\n\t* src/configure.in: By default, we want -O1 on tests (TOPTFLAGS). -O0\n\t  is too literal and causes a number of tests who depend on peephole\n\t  optimization to run.\n\t* src/utils/Makefile: Utils are installed therefore they should be\n\t  built with production flags not test/debug flags\n\t* src/Makefile.inc: Make clean should not clean up libpfm. Thats for\n\t  make distclean. We're not developing libpfm!\n\n2016-07-04  Phil Mucci <phil@minimalmetrics.com>\n\n\t* src/ctests/mendes-alt.c, src/ctests/zero.c: Moved functions\n\t  definitions to top of file to eliminate non-ANSI-C prototypes\n\t  inside main. Modified message in zero to not turbo boost will also\n\t  cause errors (cycles > real-time-cycle\n\t* src/Makefile.in, src/Makefile.inc, src/configure, src/configure.in:\n\t  Remove EXTRA_CFLAGS, now CFLAGS. Added FTOPTS so compiling Fortran\n\t  tests have same flags as ctests. Fix proper testing at configure\n\t  time of libpfm for proper combinations of libpfm options\n\t* src/ftests/Makefile: Homogenize include flags\n\t* src/ctests/Makefile: Homogenize include flags\n\t* src/testlib/Makefile: Removed unnecessary defs and options\n\t* src/utils/Makefile: Removed unnecessary definitions and compiler\n\t  options\n\n2016-07-01  Phil Mucci <phil@minimalmetrics.com>\n\n\t* src/Makefile.in, src/Makefile.inc, src/Rules.perfctr-pfm,\n\t  src/Rules.perfmon2, src/Rules.pfm4_pe,\n\t  src/components/Makefile_comp_tests.target.in,\n\t  src/components/perf_event/pe_libpfm4_events.c, src/configure,\n\t  src/configure.in, src/ctests/Makefile,\n\t  src/ctests/Makefile.target.in, src/ftests/Makefile,\n\t  src/ftests/Makefile.target.in: Makefile.in: - Removed DEBUGFLAGS,\n\t  NOTLS, PAPI_EVENTS_TABLE from being generated. These were not\n\t  properly used. - Added LIBCFLAGS generated from configure for\n\t  CFLAGS that ONLY apply to the library and the library code. NOT\n\t  tests nor utilities. Previously we were propagating all kinds of\n\t  bogus flags to the tests and utils. - CFLAGS is now properly set\n\t  for compiler flags not defines etc.  Makefile.inc: - Put\n\t  papi_events_table.h in the right place. This is always the same\n\t  name. Previous attempts at parameterizing this were broken and/or\n\t  unnecessary. - Added dependency for the above in the right place\n\t  and ALWAYS generate it, regardless of whether we actually include\n\t  it in the library (vs load the CSV at runtime).  Rules.perfctr-pfm\n\t  - Removed conditional removal of events table during clean.\n\t  Rules.perfmon2 - Removed conditional removal of events table during\n\t  clean.  Rules.pfm4_pe - Stopped mussing with CFLAGS which would\n\t  pollute child builds but refer to LIBCFLAGS. CFLAGS is for\n\t  everything! - Removed conditional removal of events table during\n\t  clean. - Removed duplicate reference to papi_events_table.h\n\t  components/perf_event/pe_libpfm4_events.c: - Removed HARDCODED\n\t  include of a libpfm4 private header file. Wrong path and\n\t  unnecessary include. This would break if you linked against another\n\t  libpfm using any of the config options.\n\t  components/perf_event/peu_libpfm4_events.c: - Removed HARDCODED\n\t  include of a libpfm4 private header file. Wrong path and\n\t  unnecessary include. This would break if you linked against another\n\t  libpfm using any of the config options.\n\t  components/Makefile_comp_tests.target.in: - Refer to datarootdir to\n\t  make autoconf happy  configure/configure.in: Regenerated using\n\t  autoconf 2.69 and many modifications to serious brokennesss. Lots\n\t  of fixes: - Sanitize options for static inclusion of user and papi\n\t  presets - Fix options that do not print out a result - Fix\n\t  debug=yes to not include PAPI_MEMORY_MANAGEMENT. That's only\n\t  enabled with debug=memory. This will reduce false positives when we\n\t  debug. We don't want our own malloc/free changing behavior when we\n\t  are trying to debug! - Fix CFLAGS/LIBCFLAGS/DEBUGFLAGS. configure\n\t  now exports a variable called PAPICFLAGS which gets stuffed into\n\t  LIBCFLAGS in Makefile.in. This variable IS ONLY for compiler flags\n\t  relevant to the library. Previously we were exporting all sorts of\n\t  stuff that would make our passes behave differently that user code.\n\t  _GNU_SOURCE and -D_REENTRANT. That stuff is for the library and\n\t  components. Not user code. - Update compile tests to use\n\t  AC_LANG_SOURCE as required. - Fix clock timer checking output to\n\t  now say what timer we picked instead of just skipping an answer -\n\t  Same for virtual clock timer - Remove broken --with-papi-events\n\t  option. - Fixed --with-static-tools option - Fixed/added --with-\n\t  static-papi-events option (default) and --with-static-user-events\n\t  option. - Fixed modalities of configuring whether to build a\n\t  static/shared or both. - Fixed link of tests with shared libraries\n\t  when above options don't support it. Modality again. Remove\n\t  SETPATH/LIBPATH define, which won't work for ANY combination of\n\t  --with-pfm-prefix/root/libdir except our included library. Woefully\n\t  broken and would result in many false positive failures. If you are\n\t  going to run the tests on the shared library it is now the users\n\t  responsibility to set LD_LIBRARY_PATH/LIBPATH correctly. I suspect\n\t  this may irritate some, but broken 90% of the time is no excuse for\n\t  correct 10% of the time especially when it could generate bug\n\t  reports falsely. - Fixed with-static-tools, with-shlib-tools\n\t  options to correct modalities. - Fixed all modalities with --with-\n\t  pfm-prefix/root/libdir/incdir. Previously the build, configure and\n\t  source files were still referring to pieces of code INSIDE our\n\t  libpfm4 resulting in version skew and breakage. The way to test\n\t  this stuff is to use --root or --prefix after removing the internal\n\t  libpfm4 library. - Removed unnecessary and confusing\n\t  force_pfm_incdir - Fixed with-pe-incdir option which, like before\n\t  was most of the time referring to the libpfm4 included header file.\n\t  Not good if one has a custom kernel! PECFLAGS now only appended to\n\t  PAPICFLAGS(LIBCFLAGS). - Removal of DEBUGFLAGS. aix.c needs\n\t  testing. Anyone have one? - Fixed CFLAGS for BSD - Add message for\n\t  papi_events.csv  ctests/Makefile ftests/Makefile - Don't redefine\n\t  CC/CC_R/CFLAGS/FFLAGS. - Make these files consistent\n\t  ctests/Makefile.target.in ftests/Makefile.target.in - refer to\n\t  datarootdir as required\n\n2016-06-27  Phil Mucci <phil@minimalmetrics.com>\n\n\t* src/testlib/Makefile, src/testlib/Makefile.target.in: Added\n\t  explicit target for libtestlib.a. The all target should have been\n\t  markted as .PHONY as to avoid constant rebuilding.  Also, we really\n\t  should merge these two files into a master and an include.\n\t  Maintaining two makefiles stinks!\n\n2017-06-16  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/papi_fwrappers.c: fwrappers: papif_unregister_thread was\n\t  misspelled as papif_unregster_thread  This was noticed by Vedran\n\t  Novakovic  For an extremely long time (10+ years?) the fortran\n\t  wrapper was misspelled as papif_unregster_thread()  It's probably\n\t  too late to fix this without potentially breaking things, so just\n\t  add a duplicate function with the proper spelling and leave the old\n\t  one too.\n\t* src/papi_preset.c: papi_preset: fix compiler warning  This really\n\t  confusing warning has been around for a while.  gcc-6.3 reports it\n\t  in a really odd way:  papi_preset.c: In function\n\t  \u2018check_derived_events\u2019: papi_preset.c:513:19: warning:\n\t  \u2018__s\u2019 may be used uninitialized in this function$ int val =\n\t  atoi(&subtoken[1]); ^~~~~~~~~~~~ papi_preset.c:464:1: note:\n\t  \u2018__s\u2019 was declared here ops_string_merge(char **original, char\n\t  *insertion, int replaces, int start_ind$ ^~~~~~~~~~~~~~~~  But\n\t  there is no __s variable, or anything to do with where the arrows\n\t  are pointing.  gcc-5 gives a better warning:  papi_preset.c: In\n\t  function \u2018check_derived_events\u2019: papi_preset.c:513:14: warning:\n\t  \u2018tok_save_ptr\u2019 may be used uninitialized in this$ int val =\n\t  atoi(&subtoken[1]); ^ papi_preset.c:472:8: note: \u2018tok_save_ptr\u2019\n\t  was declared here char *tok_save_ptr;  So the thing it seems to be\n\t  complaining about is that the *saveptr paramater to strtok_r() is\n\t  not set to NULL.  According to the manpage I don't think this\n\t  should be needed? But I think it should be safe to initialize it\n\t  anyway.\n\nTue Jun 6 11:09:17 2017 -0500  Will Schmidt <will_schmidt@vnet.ibm.com>\n\n\t* src/libpfm4/lib/events/power9_events.h,\n\t  src/libpfm4/perf_examples/self_count.c,\n\t  src/libpfm4/tests/validate_power.c: Update libpfm4  Current with\n\t  commit ce5b320031f75f9a9881333c13902d5541f91cc8  add power9 entries\n\t  to validate_power.c  Hi,  Update the validate_power test to include\n\t  power9 entries.  sniff-test run output: $ ./validate Libpfm\n\t  structure tests: libpfm ABI version : 0 pfm_pmu_info_t : Passed\n\t  pfm_event_info_t : Passed pfm_event_attr_info_t : Passed\n\t  pfm_pmu_encode_arg_t : Passed pfm_perf_encode_arg_t : Passed Libpfm\n\t  internal table tests: <snip...> checking power9 (946 events):\n\t  Passed Architecture specific tests: 20 PowerPC events: 0 errors All\n\t  tests passed\n\n2017-06-15  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/components/perf_event/pe_libpfm4_events.c,\n\t  src/components/perf_event/pe_libpfm4_events.h,\n\t  .../perf_event_uncore/Rules.perf_event_uncore,\n\t  .../perf_event_uncore/perf_event_uncore.c,\n\t  .../perf_event_uncore/peu_libpfm4_events.c,\n\t  .../perf_event_uncore/peu_libpfm4_events.h: perf_event: merge the\n\t  libpfm4 helper libraries  perf_event and perf_event_uncore had\n\t  their own almost exactly the same libpfm4 helper libraries.\n\t  Maintaining both was a chore, and it looks like it is possible to\n\t  just share one copy.  This does mean that it is now not possible to\n\t  configure the perf_event_uncore component without perf_event being\n\t  enabled, but I am not sure if that was even possible to begin with.\n\t* src/components/perf_event/pe_libpfm4_events.c,\n\t  .../perf_event_uncore/perf_event_uncore.c,\n\t  .../perf_event_uncore/peu_libpfm4_events.c,\n\t  .../perf_event_uncore/peu_libpfm4_events.h: perf_event_uncore: make\n\t  the libpfm4 routines match even more\n\t* src/components/perf_event/pe_libpfm4_events.c,\n\t  .../perf_event_uncore/peu_libpfm4_events.c: perf_event: make\n\t  perf_event and perf_event uncore libpfm4 more similar  it's a bad\n\t  idea to have more or less two copies of the same code\n\t* src/components/perf_event/pe_libpfm4_events.c,\n\t  .../perf_event_uncore/peu_libpfm4_events.c: perf_event: Avoid\n\t  unintended libpfm build dependency due to PFM_PMU_MAX enum  This\n\t  patch is based on one sent by William Cohen <wcohen@redhat.com>\n\t  The libpfm pfmlib.h file enumerates the each of performance\n\t  monitoring units (PMUs) it can program in pfm_pmu_t type.  The last\n\t  enum in this type is PFM_PMU_MAX.  Depending on which specific\n\t  version of libpfm being used this specific value could vary.  The\n\t  problem is that PFM_PMU_MAX is statically defined in the pfmlib.h\n\t  file and this was being used as a loop bounds when iterating to\n\t  determine which PMUs are potentially available.  If PAPI was built\n\t  with an older version of libpfm and then run with a newer libpfm\n\t  shared library on a machine with a larger PFM_PMU_MAX value, none\n\t  of the PMUs past the smaller PFM_PMU_MAX used for the the build\n\t  would be examined or enabled.\n\n2017-06-15  Heike Jagode (jagode@icl.utk.edu) <jagode@d00.descartes>\n\n\t* src/components/infiniband/linux-infiniband.c: Updated infiniband\n\t  component so that it works for mofed driver version 4.0, where\n\t  directory counters_ext in sysfs fs has changed to hw_counters.\n\t  This update to the component makes it work for both directory\n\t  names: - counters_ext for mofed driver version <4.0, and -\n\t  hw_counters for mofed driver version =>4.0  This change has not\n\t  been fully tested yet due to missing access to machine with updated\n\t  version of mofed driver. (CORAL machines will have an updated\n\t  version of this driver.)\n\n2017-05-04  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/components/rapl/linux-rapl.c: rapl: broadwell-ep DRAM units are\n\t  special (like Haswell-EP)  The Linux kernel perf interface had this\n\t  wrong too.  I noticed this in my cluster computing classs, the\n\t  Broadwell-EP DRAM results were unrealistically high values.\n\nFri Apr 21 17:33:15 2017 -0700  William Cohen <wcohen@redhat.com>\n\n\t* src/libpfm4/README, src/libpfm4/include/perfmon/pfmlib.h,\n\t  src/libpfm4/lib/Makefile, src/libpfm4/lib/events/power9_events.h,\n\t  src/libpfm4/lib/pfmlib_common.c, src/libpfm4/lib/pfmlib_power9.c,\n\t  src/libpfm4/lib/pfmlib_power_priv.h, src/libpfm4/lib/pfmlib_priv.h,\n\t  src/libpfm4/lib/pfmlib_s390x_cpumf.c: Update libpfm4\\n\\nCurrent\n\t  with\\n commit 8385268c98553cb5dec9ca86bbad3e5c44a2ab16  fix\n\t  internal pfm_event_attr_info_t use for S390X  Commit 321133e\n\t  converted most of the architectures to use the internal\n\t  perflib_event_attr_info_t type.  However, the s390 was missed in\n\t  that previous commit.  This patch corrects the issue so libpfm\n\t  compiles on s390.\n\n2017-04-20  Stephen Wood <swood@icl.utk.edu>\n\n\t* src/extras.c, src/papi.h, src/papi_fwrappers.c, src/papi_hl.c,\n\t  src/papi_internal.c: cast pointers appropriately to avoid warnings\n\t  and errors\n\n2017-04-19  Sangamesh Ragate <sragate@minotaur.nic.uoregon.edu>\n\n\t* src/papi_events.csv: Mapped PAPI_L2_ICM preset event to\n\t  PM_INST_FROM_L2MISS native event for Power8\n\n2017-04-06  Asim YarKhan <yarkhan@icl.utk.edu>\n\n\t* src/ftests/fmatrixlowpapi.F: Fixed: This fortran test exceeded 72\n\t  columns and made the default Intel ifort compilation unhappy\n\nWed Apr 5 23:35:44 2017 -0700  Andreas Beckmann <a.beckmann@fz-juelich.de>\n\n\t* src/libpfm4/docs/man3/libpfm_arm_ac53.3,\n\t  src/libpfm4/docs/man3/libpfm_arm_ac57.3,\n\t  src/libpfm4/docs/man3/libpfm_arm_xgene.3, src/libpfm4/lib/Makefile,\n\t  src/libpfm4/lib/events/arm_cortex_a53_events.h,\n\t  src/libpfm4/lib/events/intel_glm_events.h,\n\t  src/libpfm4/lib/events/intel_hswep_unc_imc_events.h,\n\t  src/libpfm4/lib/events/intel_ivbep_unc_imc_events.h,\n\t  src/libpfm4/lib/events/intel_knl_events.h,\n\t  src/libpfm4/lib/events/intel_knl_unc_cha_events.h,\n\t  src/libpfm4/lib/events/power4_events.h,\n\t  src/libpfm4/lib/events/ppc970_events.h,\n\t  src/libpfm4/lib/events/ppc970mp_events.h,\n\t  src/libpfm4/perf_examples/self_smpl_multi.c: Update\n\t  libpfm4\\n\\nCurrent with\\n commit\n\t  71a960d9c17b663137a2023ce63edd2f3ca115f5  fix various event\n\t  description typos  This patch fixes the typos in several event\n\t  description for Intel, Arm, and Power event tables.\n\n2017-03-30  William Cohen <wcohen@redhat.com>\n\n\t* src/ftests/cost.F, src/ftests/first.F, src/ftests/fmatrixlowpapi.F,\n\t  src/ftests/second.F: Eliminate warnings about implicit type\n\t  conversions in Fortran tests  The gfortran compiler on Fedora 25\n\t  was giving warnings indicating that a few of the tests were doing\n\t  implicit type convertion between reals and ints.  Those implicit\n\t  conversions have been made explicit to elminate the fortran\n\t  compiler warning messages.\n\nTue Apr 4 09:42:25 2017 -0700  Stephane Eranian <eranian@gmail.com>\n\n\t* src/libpfm4/include/perfmon/pfmlib.h,\n\t  src/libpfm4/lib/pfmlib_amd64.c,\n\t  src/libpfm4/lib/pfmlib_amd64_priv.h, src/libpfm4/lib/pfmlib_arm.c,\n\t  src/libpfm4/lib/pfmlib_arm_priv.h, src/libpfm4/lib/pfmlib_common.c,\n\t  src/libpfm4/lib/pfmlib_intel_netburst.c,\n\t  src/libpfm4/lib/pfmlib_intel_nhm_unc.c,\n\t  src/libpfm4/lib/pfmlib_intel_snbep_unc.c,\n\t  src/libpfm4/lib/pfmlib_intel_snbep_unc_priv.h,\n\t  src/libpfm4/lib/pfmlib_intel_x86.c,\n\t  src/libpfm4/lib/pfmlib_intel_x86_perf_event.c,\n\t  src/libpfm4/lib/pfmlib_intel_x86_priv.h,\n\t  src/libpfm4/lib/pfmlib_mips.c, src/libpfm4/lib/pfmlib_mips_priv.h,\n\t  src/libpfm4/lib/pfmlib_perf_event.c,\n\t  src/libpfm4/lib/pfmlib_perf_event_pmu.c,\n\t  src/libpfm4/lib/pfmlib_perf_event_raw.c,\n\t  src/libpfm4/lib/pfmlib_power_priv.h,\n\t  src/libpfm4/lib/pfmlib_powerpc.c, src/libpfm4/lib/pfmlib_priv.h,\n\t  src/libpfm4/lib/pfmlib_sparc.c,\n\t  src/libpfm4/lib/pfmlib_sparc_priv.h,\n\t  src/libpfm4/lib/pfmlib_torrent.c, src/libpfm4/tests/validate.c,\n\t  src/libpfm4/tests/validate_x86.c: Update libpfm4\\n\\nCurrent with\\n\n\t  commit 5e311841e5d70efb93d11826109cb5acab6e051c  enable 38-bit raw\n\t  umasks for Intel offcore_response events  This patch enables\n\t  support for passing and encoding of 38-bit offcore_response matrix\n\t  umask. Without the patch, the raw umask was limited to 32-bit which\n\t  is not enough to cover all the possible bits of the\n\t  offcore_response event available since Intel SandyBridge.  $\n\t  examples/check_events offcore_response_0:0xffffff Requested Event:\n\t  offcore_response_0:0xffffff Actual    Event:\n\t  ivb::OFFCORE_RESPONSE_0:0xffffff:k=1:u=1:e=0:i=0:c=0:t=0 PMU\n\t  : Intel Ivy Bridge IDX            : 155189325 Codes          :\n\t  0x5301b7 0xffffff  The patch also adds tests to the validation\n\t  code.\n\n2017-03-29  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/components/perfctr/perfctr-x86.c: perfctr: fix perfctr\n\t  component to actually work  Simple one-line typo means perfctr was\n\t  not working, probably for years.  I've tested on a 2.6.32-perfctr\n\t  kernel and it works again.\n\n2017-03-28  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/papi_events.csv: papi_events: add AMD fam16h jaguar events\n\t  These will become useful if/when the contributed libpfm4 jaguar\n\t  patches get applied.\n\n2017-03-27  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/papi_events.csv: events: p4: change the PAPI_TOT_CYC event\n\t  PAPI_TOT_CYC wasn't working on Pentium4 because the\n\t  GLOBAL_POWER_EVENT:RUNNING event was being grabbed by the hardware\n\t  watchdog.  perf cycles:u was still working, that's because the\n\t  kernel transparently remaps the cycles event to an alias when\n\t  global_power_event's slot is taken.  The aliased event is the\n\t  unwieldly: execution_event:nbogus0:nbogus1:nbogus2:nbogus3:bogus0:b\n\t  ogus1:bogus2:bogus3:cmpl:thr=15 which does seem to give the right\n\t  results.  Use this event instead by default on Pentium 4\n\t* src/components/perf_event/perf_event.c: perf_event: fix warning\n\t  when compiling with debug enabled  the flags field is an unsigned\n\t  long, not an int\n\n2017-03-22  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/components/perf_event/perf_event.c: perf_event: don't allocate\n\t  a mmap page if not rdpmc or sampling\n\t* src/components/perf_event/perf_event.c: perf_event: only allocate 1\n\t  mmap page (rather than 3) if not sampling  Next step is to allocate\n\t  0 mmap pages unless rdpmc is enabled\n\t* src/components/perf_event/perf_event.c,\n\t  src/components/perf_event/perf_event_lib.h: perf_event: update the\n\t  _pe_set_overflow() call  Working on making it more obvious which\n\t  events are sampling (and thus need mmap buffers) or not.  Also\n\t  there were some bugs in the handling of having multiple overflow\n\t  sources per eventset, though I'm not sure if PAPI actually handles\n\t  that.\n\t* src/components/perf_event/perf_event.c: perf_event: turn off\n\t  fast_counter_read if mmaps fail  By default on Linux perf_event\n\t  can't use more than 516kB of mmap space.  So perf_event-rdpmc would\n\t  fail after you added a large number (>32) of events.  This shows up\n\t  on the kufrin benchmark on some machines.  This fix makes PAPI fall\n\t  back to non-rdpmc if an mmap error happens. I'm also going to try\n\t  to tune the mmap usage a bit to make the limits a bit higher.\n\n2017-03-21  Asim YarKhan <yarkhan@icl.utk.edu>\n\n\t* src/configure: configure script updated using autoconf-2.59\n\n2017-03-20  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/components/perf_event/perf_event.c, src/configure.in:\n\t  configure: enable rdpmc with --enable-perfevent-rdpmc=yes  Make\n\t  this an option to configure.  Defaults to no.  Need to find a\n\t  machine with autoconf 2.59 on and I'll regenerate configure as\n\t  well.\n\n2017-03-16  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/components/perf_event/perf_event.c: perf_event: try to work\n\t  around exclude_guest issue  run a test at startup to see if events\n\t  with exclude_guest fail.  libpfm4 sets this by default, but older\n\t  kernels will fail because this was previously a reserved (must be\n\t  zero) field.\n\n2017-03-14  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/ctests/multiattach.c: tests: multiattach:\n\t  whitespace/comments/clarifications  digging through the code trying\n\t  to figure out why it fails with rdpmc enabled.  it turns out it is\n\t  seeing wrong running/enabled multiplexing results even though we\n\t  aren't multiplexing  tracking this down is a pain because we can't\n\t  strace/ltrace due to the code using ptrace to start/stop processes.\n\n2017-03-09  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/components/perf_event/perf_event.c: perf_event: can't mmap() an\n\t  inherited event  this is why the inherit test was failing\n\t* src/components/perf_event/perf_event.c,\n\t  src/components/perf_event/perf_helpers.h: perf_event: add rdpmc\n\t  support (but disabled)  finally add the rdpmc code, but it still\n\t  fails on a few tests so it is disabled by default.\n\t* src/components/perf_event/perf_event.c,\n\t  src/components/perf_event/perf_event_lib.h: perf_event: make all\n\t  events come with a mmap buffer  This wastes some address space, but\n\t  having separate codepaths for rdpmc/regular/sampling/profiling\n\t  would be hard to maintain.  Had to remove some assumptions from the\n\t  profiling/sampling code that mmap_buf means sampling is happening.\n\t* src/components/perf_event/perf_event.c: perf_event: add check for\n\t  paranoid==3  Recent distributions are *completely* disablng\n\t  perf_event by default with their vendor kernels (this is not\n\t  upstream yet).  Have PAPI detect and disable the perf_event\n\t  component if this is detected.\n\t* src/components/perf_event/perf_event.c: perf_event: split\n\t  close_pe_events() into two functions\n\t* src/components/perf_event/perf_event.c,\n\t  src/components/perf_event/perf_helpers.h: perf_event: more\n\t  whitespace / rearrangement  should not be any changes to actual\n\t  code, is just whitespace/comment/function movement  I know changes\n\t  like this make the git history harder to follow, but it really\n\t  helps when trying to follow the code when working on major changes.\n\n2017-03-08  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/components/perf_event/perf_event.c: perf_event: more\n\t  whitespace/comment cleanups  digging through the code, still\n\t  prepping for rdpmc\n\n2017-03-07  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/components/perf_event/perf_helpers.h: perf_event: rdpmc: need\n\t  to sign extend offset too  Otherwise things stop working after a\n\t  PAPI_reset()\n\t* src/components/perf_event/perf_event.c: perf_event: split up\n\t  _pe_read()  makes the code a bit easier to follow.  also prep for\n\t  rdpmc()\n\t* src/components/perf_event/perf_event.c: perf_event: clean up\n\t  whitespace in _pe_read\n\n2017-03-08  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/ctests/first.c: ctests: first: white space cleanups  minor\n\t  things noticed when trying to figure out why it was failing with\n\t  rdpmc (the answer was rdpmc code not handling PAPI_reset())\n\n2017-03-07  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/components/perf_event/perf_helpers.h: perf_event: recent\n\t  changes broke build on non-x86  an ifdef was in the wrong location.\n\t* src/components/perf_event/perf_event.c,\n\t  src/components/perf_event/perf_helpers.h: perf_event: update rdpmc\n\t  detection\n\t* src/utils/component.c: utils: component_avail: clean up -d\n\t  (detailed) results  print rdpmc status, as well as line things up.\n\t  Also don't print redundant info, now that a lot more fields are\n\t  printed by default.\n\t* src/utils/component.c: utils: component_avail: whitespace/grammar\n\t  fixes\n\t* src/components/perf_event/Rules.perf_event,\n\t  src/components/perf_event/perf_helpers.h: perf_event: add\n\t  mmap/rdpmc routine  we don't use it yet\n\n2017-03-06  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/components/perf_event/perf_helpers.h: perf_event: add rdtsc()\n\t  and rdpmc() inline-assembly\n\t* src/components/perf_event/perf_event.c,\n\t  src/components/perf_event/perf_helpers.h: perf_event: move\n\t  perf_event_open() code to a helper file  We'll be adding some other\n\t  helpers to this file too.\n\n2017-03-03  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/components/perf_event/perf_event.c: perf_event: move\n\t  bug_sync_read() check out of line  we should eventually just phase\n\t  out a lot of these checks for older kernels, but it gets tricky as\n\t  long as RHEL is shipping 2.6.32.  With this change on my IVB\n\t  machine PAPI_read() cost went from mean cycles  : 932.158549\n\t  std deviation: 358.752461 to mean cycles  : 896.642644       std\n\t  deviation:    305.568268\n\t* src/components/perf_event/pe_libpfm4_events.c,\n\t  src/components/perf_event/pe_libpfm4_events.h,\n\t  src/components/perf_event/perf_event.c: perf_event: remove\n\t  _pe_libpfm4_get_cidx() helper function  easier to explicitly pass\n\t  it to the libpfm4 event code\n\t* src/components/perf_event/perf_event_lib.h: perf_event: wakeup_mode\n\t  field is no longer used\n\t* src/components/perf_event/perf_event.c: perf_event: remove\n\t  WAKEUP_MODE_ defines  These date back to initial perf_event\n\t  support, but were never used.  Probably were meant in case advanced\n\t  sampling/profiling was ever implemented, but it wasn't.\n\t* src/components/perf_event/perf_event.c: perf_event.c: split\n\t  setup_mmap() to its own function  non-sampling events will need to\n\t  have mmap buffers when we move to rdpmc()\n\t* src/components/perf_event/perf_event.c: perf_event: rename\n\t  tune_up_fd to configure_fd_for_sampling  makes it a bit more clear\n\t  what is going on\n\t* src/components/perf_event/perf_event.c: perf_event: remove\n\t  extraneous whitespace\n\n2017-02-24  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/utils/cost.c: papi_cost: wasn't properly resetting the event\n\t  search after POSTFIX  This means some architectures could have\n\t  skipped the ADD/SUB test even though such events were available.\n\nWed Feb 22 01:16:42 2017 -0800  Stephane Eranian <eranian@gmail.com>\n\n\t* src/libpfm4/lib/events/intel_bdw_events.h,\n\t  src/libpfm4/lib/events/intel_skl_events.h,\n\t  src/libpfm4/lib/pfmlib_intel_rapl.c,\n\t  src/libpfm4/tests/validate_x86.c: Update libpfm4\\n\\nCurrent with\\n\n\t  commit 1bd352eef242f53e130c3b025bbf7881a5fb5d1e  update Intel RAPL\n\t  processor support  Added Kabylake, Skylake X  Added PSYS RAPL event\n\t  for Skylake client.\n\n2017-02-17  Vince Weaver <vincent.weaver@maine.edu>\n\n\t* src/utils/cost.c: papi_cost: clear eventset before derived add test\n\t  we weren't clearing the eventset after the derived postfix test to\n\t  the add test was actually measuring two derived events.  This was\n\t  noticed on broadwell-ep where papi_cost would fail due to the lack\n\t  of enough counters to have both the postfix and add events at the\n\t  same time.\n\n2017-01-23  Asim YarKhan <yarkhan@icl.utk.edu>\n\n\t* RELEASENOTES.txt: Fixing the date in the RELEASENOTES file.\n",
        "/tmp/vanessa/spack-stage/spack-stage-papi-6.0.0.1-gmm3tef6bggycxgzrtmq2ejaggc2ozfb/spack-src/src/threads.c": "/****************************/\n/* THIS IS OPEN SOURCE CODE */\n/****************************/\n\n/*\n* File:    threads.c\n* Author:  Philip Mucci\n*          mucci@cs.utk.edu\n* Mods:    Kevin London\n*          london@cs.utk.edu\n*/\n\n/* This file contains thread allocation and bookkeeping functions */\n\n#include \"papi.h\"\n#include \"papi_internal.h\"\n#include \"papi_vector.h\"\n#include \"papi_memory.h\"\n#include <string.h>\n#include <unistd.h>\n\n/*****************/\n/* BEGIN GLOBALS */\n/*****************/\n\n/* The following globals get initialized and cleared by:\n   extern int _papi_hwi_init_global_threads(void);\n   extern int _papi_hwi_shutdown_thread(ThreadInfo_t *thread); */\n\n/* list of threads, gets initialized to master process with TID of getpid() */\n\nvolatile ThreadInfo_t *_papi_hwi_thread_head;\n\n/* If we have TLS, this variable ALWAYS points to our thread descriptor. It's like magic! */\n\n#if defined(HAVE_THREAD_LOCAL_STORAGE)\nTHREAD_LOCAL_STORAGE_KEYWORD ThreadInfo_t *_papi_hwi_my_thread;\n#endif\n\n/* Function that returns and unsigned long thread identifier */\n\nunsigned long ( *_papi_hwi_thread_id_fn ) ( void );\n\n/* Function that sends a signal to other threads */\n\n#ifdef ANY_THREAD_GETS_SIGNAL\nint ( *_papi_hwi_thread_kill_fn ) ( int, int );\n#endif\n\n/*****************/\n/*  END  GLOBALS */\n/*****************/\n\nstatic int\nlookup_and_set_thread_symbols( void )\n{\n#if defined(ANY_THREAD_GETS_SIGNAL)\n\tint retval;\n\tchar *error_ptc = NULL, *error_ptk = NULL;\n\tvoid *symbol_ptc = NULL, *symbol_ptk = NULL, *handle = NULL;\n\n\thandle = dlopen( NULL, RTLD_LAZY );\n\tif ( handle == NULL ) {\n\t\tPAPIERROR( \"Error from dlopen(NULL, RTLD_LAZY): %d %s\", errno,\n\t\t\t\t   dlerror(  ) );\n\t\treturn ( PAPI_ESYS );\n\t}\n\n\tsymbol_ptc = dlsym( handle, \"pthread_self\" );\n\tif ( symbol_ptc == NULL ) {\n\t\terror_ptc = dlerror(  );\n\t\tTHRDBG( \"dlsym(%p,pthread_self) returned NULL: %s\\n\",\n\t\t\t\t( error_ptc ? error_ptc : \"No error, NULL symbol!\" ) );\n\t}\n\n\tsymbol_ptk = dlsym( handle, \"pthread_kill\" );\n\tif ( symbol_ptk == NULL ) {\n\t\terror_ptk = dlerror(  );\n\t\tTHRDBG( \"dlsym(%p,pthread_kill) returned NULL: %s\\n\",\n\t\t\t\t( error_ptk ? error_ptk : \"No error, NULL symbol!\" ) );\n\t}\n\n\tdlclose( handle );\n\n\tif ( !( ( _papi_hwi_thread_kill_fn && _papi_hwi_thread_id_fn ) ||\n\t\t\t( !_papi_hwi_thread_kill_fn && !_papi_hwi_thread_id_fn ) ) )\n\t\treturn ( PAPI_EMISC );\n\n\t_papi_hwi_thread_kill_fn = ( int ( * )( int, int ) ) symbol_ptk;\n\t_papi_hwi_thread_id_fn = ( unsigned long ( * )( void ) ) symbol_ptc;\n#endif\n\treturn ( PAPI_OK );\n}\n\nstatic ThreadInfo_t *\nallocate_thread( int tid )\n{\n\tThreadInfo_t *thread;\n\tint i;\n\n\t/* The Thread EventSet is special. It is not in the EventSet list, but is pointed\n\t   to by each EventSet of that particular thread. */\n\n\tthread = ( ThreadInfo_t * ) papi_malloc( sizeof ( ThreadInfo_t ) );\n\tif ( thread == NULL )\n\t\treturn ( NULL );\n\tmemset( thread, 0x00, sizeof ( ThreadInfo_t ) );\n\n\tthread->context =\n\t\t( hwd_context_t ** ) papi_malloc( sizeof ( hwd_context_t * ) *\n\t\t\t\t\t\t\t\t\t\t  ( size_t ) papi_num_components );\n\tif ( !thread->context ) {\n\t\tpapi_free( thread );\n\t\treturn ( NULL );\n\t}\n\n\tthread->running_eventset =\n\t\t( EventSetInfo_t ** ) papi_malloc( sizeof ( EventSetInfo_t * ) *\n\t\t\t\t\t\t\t\t\t\t   ( size_t ) papi_num_components );\n\tif ( !thread->running_eventset ) {\n\t\tpapi_free( thread->context );\n\t\tpapi_free( thread );\n\t\treturn ( NULL );\n\t}\n\n\tfor ( i = 0; i < papi_num_components; i++ ) {\n\t\tthread->context[i] =\n\t\t\t( void * ) papi_malloc( ( size_t ) _papi_hwd[i]->size.context );\n\t\tthread->running_eventset[i] = NULL;\n\t\tif ( thread->context[i] == NULL ) {\n\t\t\tfor ( i--; i >= 0; i-- )\n\t\t\t\tpapi_free( thread->context[i] );\n\t\t\tpapi_free( thread->context );\n\t\t\tpapi_free( thread );\n\t\t\treturn ( NULL );\n\t\t}\n\t\tmemset( thread->context[i], 0x00,\n\t\t\t\t( size_t ) _papi_hwd[i]->size.context );\n\t}\n\n\tif ( _papi_hwi_thread_id_fn ) {\n           thread->tid = ( *_papi_hwi_thread_id_fn ) (  );\n\t}\n\telse {\n\t   thread->tid = ( unsigned long ) getpid(  );\n\t}\n\n\tthread->allocator_tid=thread->tid;\n\n\tif (tid == 0 ) {\n\t}\n\telse {\n\t  thread->tid=tid;\n\t}\n\n\tTHRDBG( \"Allocated thread %ld at %p, allocator: %ld\\n\", thread->tid, \n\t\tthread,\n\t\tthread->allocator_tid );\n\n\treturn thread;\n}\n\nstatic void\nfree_thread( ThreadInfo_t ** thread )\n{\n\tint i;\n\tTHRDBG( \"Freeing thread %ld at %p\\n\", ( *thread )->tid, *thread );\n\n\tfor ( i = 0; i < papi_num_components; i++ ) {\n\t\tif ( ( *thread )->context[i] )\n\t\t\tpapi_free( ( *thread )->context[i] );\n\t}\n\n\tif ( ( *thread )->context )\n\t\tpapi_free( ( *thread )->context );\n\n\tif ( ( *thread )->running_eventset )\n\t\tpapi_free( ( *thread )->running_eventset );\n\n\tmemset( *thread, 0x00, sizeof ( ThreadInfo_t ) );\n\tpapi_free( *thread );\n\t*thread = NULL;\n}\n\nstatic void\ninsert_thread( ThreadInfo_t * entry, int tid )\n{\n\t_papi_hwi_lock( THREADS_LOCK );\n\n\tif ( _papi_hwi_thread_head == NULL ) {\t/* 0 elements */\n\t\tTHRDBG( \"_papi_hwi_thread_head is NULL\\n\" );\n\t\tentry->next = entry;\n\t} else if ( _papi_hwi_thread_head->next == _papi_hwi_thread_head ) {\t/* 1 elements */\n\t\tTHRDBG( \"_papi_hwi_thread_head was thread %ld at %p\\n\",\n\t\t\t\t_papi_hwi_thread_head->tid, _papi_hwi_thread_head );\n\t\t_papi_hwi_thread_head->next = entry;\n\t\tentry->next = ( ThreadInfo_t * ) _papi_hwi_thread_head;\n\t} else {\t\t\t\t /* 2+ elements */\n\n\t\tTHRDBG( \"_papi_hwi_thread_head was thread %ld at %p\\n\",\n\t\t\t\t_papi_hwi_thread_head->tid, _papi_hwi_thread_head );\n\t\tentry->next = _papi_hwi_thread_head->next;\n\t\t_papi_hwi_thread_head->next = entry;\n\t}\n\n\t_papi_hwi_thread_head = entry;\n\n\tTHRDBG( \"_papi_hwi_thread_head now thread %ld at %p\\n\",\n\t\t\t_papi_hwi_thread_head->tid, _papi_hwi_thread_head );\n\n\t_papi_hwi_unlock( THREADS_LOCK );\n\n#if defined(HAVE_THREAD_LOCAL_STORAGE)\n\t/* Don't set the current local thread if we are a fake attach thread */\n        if (tid==0) {\n\t   _papi_hwi_my_thread = entry;\n\t   THRDBG( \"TLS for thread %ld is now %p\\n\", entry->tid,\n\t\t\t_papi_hwi_my_thread );\n\t}\n#else\n\t( void ) tid;\n#endif\n}\n\nstatic int\nremove_thread( ThreadInfo_t * entry )\n{\n\tThreadInfo_t *tmp = NULL, *prev = NULL;\n\n\t_papi_hwi_lock( THREADS_LOCK );\n\n\tTHRDBG( \"_papi_hwi_thread_head was thread %ld at %p\\n\",\n\t\t\t_papi_hwi_thread_head->tid, _papi_hwi_thread_head );\n\n\t/* Find the preceding element and the matched element,\n\t   short circuit if we've seen the head twice */\n\n\tfor ( tmp = ( ThreadInfo_t * ) _papi_hwi_thread_head;\n\t\t  ( entry != tmp ) || ( prev == NULL ); tmp = tmp->next ) {\n\t\tprev = tmp;\n\t}\n\n\tif ( tmp != entry ) {\n\t\tTHRDBG( \"Thread %ld at %p was not found in the thread list!\\n\",\n\t\t\t\tentry->tid, entry );\n\t\treturn ( PAPI_EBUG );\n\t}\n\n\t/* Only 1 element in list */\n\n\tif ( prev == tmp ) {\n\t\t_papi_hwi_thread_head = NULL;\n\t\ttmp->next = NULL;\n\t\tTHRDBG( \"_papi_hwi_thread_head now NULL\\n\" );\n\t} else {\n\t\tprev->next = tmp->next;\n\t\t/* If we're removing the head, better advance it! */\n\t\tif ( _papi_hwi_thread_head == tmp ) {\n\t\t\t_papi_hwi_thread_head = tmp->next;\n\t\t\tTHRDBG( \"_papi_hwi_thread_head now thread %ld at %p\\n\",\n\t\t\t\t\t_papi_hwi_thread_head->tid, _papi_hwi_thread_head );\n\t\t}\n\t\tTHRDBG( \"Removed thread %p from list\\n\", tmp );\n\t}\n\n\t_papi_hwi_unlock( THREADS_LOCK );\n\n#if defined(HAVE_THREAD_LOCAL_STORAGE)\n\t_papi_hwi_my_thread = NULL;\n\tTHRDBG( \"TLS for thread %ld is now %p\\n\", entry->tid,\n\t\t\t_papi_hwi_my_thread );\n#endif\n\n\treturn PAPI_OK;\n}\n\nint\n_papi_hwi_initialize_thread( ThreadInfo_t ** dest, int tid )\n{\n\tint retval;\n\tThreadInfo_t *thread;\n\tint i;\n\n\tif ( ( thread = allocate_thread( tid  ) ) == NULL ) {\n\t\t*dest = NULL;\n\t\treturn PAPI_ENOMEM;\n\t}\n\n   /* init event memory variables, used by papi_internal.c  */\n   thread->tls_papi_event_code = -1;\n   thread->tls_papi_event_code_changed = -1;\n\n\t/* Call the component to fill in anything special. */\n\n\tfor ( i = 0; i < papi_num_components; i++ ) {\n\t    if (_papi_hwd[i]->cmp_info.disabled) continue;\n\t    retval = _papi_hwd[i]->init_thread( thread->context[i] );\n\t    if ( retval ) {\n\t       free_thread( &thread );\n\t       *dest = NULL;\n\t       return retval;\n\t    }\n\t}\n\n\tinsert_thread( thread, tid );\n\n\t*dest = thread;\n\treturn PAPI_OK;\n}\n\n#if defined(ANY_THREAD_GETS_SIGNAL)\n\n/* This is ONLY defined for systems that enable ANY_THREAD_GETS_SIGNAL\n   since we must forward signals sent to non-PAPI threads.\n\n   This is NOT compatible with thread local storage, since to broadcast\n   the signal, we need a list of threads. */\n\nint\n_papi_hwi_broadcast_signal( unsigned int mytid )\n{\n\tint i, retval, didsomething = 0;\n\tvolatile ThreadInfo_t *foo = NULL;\n\n\t_papi_hwi_lock( THREADS_LOCK );\n\n\tfor ( foo = _papi_hwi_thread_head; foo != NULL; foo = foo->next ) {\n\t\t/* xxxx Should this be hardcoded to index 0 or walk the list or what? */\n\t\tfor ( i = 0; i < papi_num_components; i++ ) {\n\t\t\tif ( ( foo->tid != mytid ) && ( foo->running_eventset[i] ) &&\n\t\t\t\t ( foo->running_eventset[i]->\n\t\t\t\t   state & ( PAPI_OVERFLOWING | PAPI_MULTIPLEXING ) ) ) {\n\t\t\t\t/* xxxx mpx_info inside _papi_mdi_t _papi_hwi_system_info is commented out.\n\t\t\t\t   See papi_internal.h for details. The multiplex_timer_sig value is now part of that structure */\n\t\t\t  THRDBG(\"Thread %ld sending signal %d to thread %ld\\n\",mytid,foo->tid,\n\t\t\t\t  (foo->running_eventset[i]->state & PAPI_OVERFLOWING ? _papi_hwd[i]->cmp_info.hardware_intr_sig : _papi_os_info.itimer_sig));\n\t\t\t  retval = (*_papi_hwi_thread_kill_fn)(foo->tid, \n\t\t\t\t  (foo->running_eventset[i]->state & PAPI_OVERFLOWING ? _papi_hwd[i]->cmp_info.hardware_intr_sig : _papi_os_info.itimer_sig));\n\t\t\t  if (retval != 0)\n\t\t\t\treturn(PAPI_EMISC);\n\t\t\t}\n\t\t}\n\t\tif ( foo->next == _papi_hwi_thread_head )\n\t\t  break;\n\t}\n\t_papi_hwi_unlock( THREADS_LOCK );\n\n\treturn ( PAPI_OK );\n}\n#endif\n\n/* This is undefined for systems that enable ANY_THREAD_GETS_SIGNAL\n   since we always must enable threads for safety. */\n\nint\n_papi_hwi_set_thread_id_fn( unsigned long ( *id_fn ) ( void ) )\n{\n#if !defined(ANY_THREAD_GETS_SIGNAL)\n\t/* Check for multiple threads still in the list, if so, we can't change it */\n\n\tif ( _papi_hwi_thread_head->next != _papi_hwi_thread_head )\n\t\treturn ( PAPI_EINVAL );\n\n\t/* We can't change the thread id function from one to another, \n\t   only NULL to non-NULL and vice versa. */\n\n\tif ( ( id_fn != NULL ) && ( _papi_hwi_thread_id_fn != NULL ) )\n\t\treturn ( PAPI_EINVAL );\n\n\t_papi_hwi_thread_id_fn = id_fn;\n\n\tTHRDBG( \"Set new thread id function to %p\\n\", id_fn );\n\n\tif ( id_fn )\n\t\t_papi_hwi_thread_head->tid = ( *_papi_hwi_thread_id_fn ) (  );\n\telse\n\t\t_papi_hwi_thread_head->tid = ( unsigned long ) getpid(  );\n\n\tTHRDBG( \"New master tid is %ld\\n\", _papi_hwi_thread_head->tid );\n#else\n\tTHRDBG( \"Skipping set of thread id function\\n\" );\n#endif\n\n\treturn PAPI_OK;\n}\n\n\nstatic int _papi_hwi_thread_free_eventsets(long tid) {\n\n   EventSetInfo_t *ESI;\n   ThreadInfo_t *master;\n   DynamicArray_t *map = &_papi_hwi_system_info.global_eventset_map;\n   int i;\n\n   master = _papi_hwi_lookup_thread( tid );\n\n   _papi_hwi_lock( INTERNAL_LOCK );\n\n   for( i = 0; i < map->totalSlots; i++ ) {\n      ESI = map->dataSlotArray[i];\n      if ( ( ESI ) && (ESI->master!=NULL) ) {\n\n\t if ( ESI->master == master ) {\n\t    THRDBG(\"Attempting to remove %d from tid %ld\\n\",ESI->EventSetIndex,tid);\n\n\t    /* Code copied from _papi_hwi_remove_EventSet(ESI);      */\n\t    _papi_hwi_free_EventSet( ESI );\n\t    map->dataSlotArray[i] = NULL;\n\t    map->availSlots++;\n\t    map->fullSlots--;\n\t }\n      }\n   }\n\n   _papi_hwi_unlock( INTERNAL_LOCK );\n\n   return PAPI_OK;\n}\n\n\nint\n_papi_hwi_shutdown_thread( ThreadInfo_t * thread, int force_shutdown )\n{\n\tint retval = PAPI_OK;\n\tunsigned long tid;\n\tint i, failure = 0;\n\n   /* Clear event memory variables */\n   thread->tls_papi_event_code = -1;\n   thread->tls_papi_event_code_changed = -1;\n\n   /* Get thread id */\n\tif ( _papi_hwi_thread_id_fn )\n\t\ttid = ( *_papi_hwi_thread_id_fn ) (  );\n\telse\n\t\ttid = ( unsigned long ) getpid(  );\n\n        THRDBG(\"Want to shutdown thread %ld, alloc %ld, our_tid: %ld\\n\",\n\t       thread->tid,\n\t       thread->allocator_tid,\n\t       tid);\n\n\tif ((thread->tid==tid) || ( thread->allocator_tid == tid ) || force_shutdown) {\n\n                _papi_hwi_thread_free_eventsets(tid);\n\n\t\tremove_thread( thread );\n\t\tTHRDBG( \"Shutting down thread %ld at %p\\n\", thread->tid, thread );\n\t\tfor( i = 0; i < papi_num_components; i++ ) {\n\t\t   if (_papi_hwd[i]->cmp_info.disabled) continue;\n\t\t   retval = _papi_hwd[i]->shutdown_thread( thread->context[i]);\n\t\t   if ( retval != PAPI_OK ) failure = retval;\n\t\t}\n\t\tfree_thread( &thread );\n\t\treturn ( failure );\n\t}\n\n\tTHRDBG( \"Skipping shutdown thread %ld at %p, thread %ld not allocator!\\n\",\n\t\t\tthread->tid, thread, tid );\n\treturn PAPI_EBUG;\n}\n\n/* THESE MUST BE CALLED WITH A GLOBAL LOCK */\n\nint\n_papi_hwi_shutdown_global_threads( void )\n{\n        int err,num_threads,i;\n\tThreadInfo_t *tmp,*next;\n\tunsigned long our_tid;\n\n\ttmp = _papi_hwi_lookup_thread( 0 );\n\n\tif ( tmp == NULL ) {\n\t   THRDBG( \"Did not find my thread for shutdown!\\n\" );\n\t   err = PAPI_EBUG;\n\t}\n\telse {\n\t   our_tid=tmp->tid;\n\t   (void)our_tid;\n\n\t   THRDBG(\"Shutting down %ld\\n\",our_tid);\n\n\t   err = _papi_hwi_shutdown_thread( tmp, 1 );\n\n\t   /* count threads */\n\t   tmp = ( ThreadInfo_t * ) _papi_hwi_thread_head;\n\t   num_threads=0;\n\t   while(tmp!=NULL) {\n\t      num_threads++;\n\t      if (tmp->next==_papi_hwi_thread_head) break;\n\t      tmp=tmp->next;\n\t   }\n\n\t   /* Shut down all threads allocated by this thread */\n\t   /* Urgh it's a circular list where we removed in the loop  */\n\t   /* so the only sane way to do it is get a count in advance */\n\t   tmp = ( ThreadInfo_t * ) _papi_hwi_thread_head;\n\n\t   for(i=0;i<num_threads;i++) {\n\n\t      next=tmp->next;\n\n\t      THRDBG(\"looking at #%d %ld our_tid: %ld alloc_tid: %ld\\n\",\n\t\t     i,tmp->tid,our_tid,tmp->allocator_tid);\n\n\t\t THRDBG(\"Also removing thread %ld\\n\",tmp->tid);\n\t         err = _papi_hwi_shutdown_thread( tmp, 1 );\n\n\t      tmp=next;\n\n\t   }\n\t}\n\n\n#ifdef DEBUG\n\tif ( ISLEVEL( DEBUG_THREADS ) ) {\n\t\tif ( _papi_hwi_thread_head ) {\n\t\t\tTHRDBG( \"Thread head %p still exists!\\n\", _papi_hwi_thread_head );\n\t\t}\n\t}\n#endif\n\n#if defined(HAVE_THREAD_LOCAL_STORAGE)\n\t_papi_hwi_my_thread = NULL;\n#endif\n\t_papi_hwi_thread_head = NULL;\n\t_papi_hwi_thread_id_fn = NULL;\n#if defined(ANY_THREAD_GETS_SIGNAL)\n\t_papi_hwi_thread_kill_fn = NULL;\n#endif\n\n\treturn err;\n}\n\nint\n_papi_hwi_init_global_threads( void )\n{\n\tint retval;\n\tThreadInfo_t *tmp;\n\n\t_papi_hwi_lock( GLOBAL_LOCK );\n\n#if defined(HAVE_THREAD_LOCAL_STORAGE)\n\t_papi_hwi_my_thread = NULL;\n#endif\n\t_papi_hwi_thread_head = NULL;\n\t_papi_hwi_thread_id_fn = NULL;\n#if defined(ANY_THREAD_GETS_SIGNAL)\n\t_papi_hwi_thread_kill_fn = NULL;\n#endif\n\n\tretval = _papi_hwi_initialize_thread( &tmp , 0);\n\tif ( retval == PAPI_OK ) {\n\t   retval = lookup_and_set_thread_symbols(  );\n\t}\n\n\t_papi_hwi_unlock( GLOBAL_LOCK );\n\n\treturn ( retval );\n}\n\nint\n_papi_hwi_gather_all_thrspec_data( int tag, PAPI_all_thr_spec_t * where )\n{\n\tint didsomething = 0;\n\tThreadInfo_t *foo = NULL;\n\n\t_papi_hwi_lock( THREADS_LOCK );\n\n\tfor ( foo = ( ThreadInfo_t * ) _papi_hwi_thread_head; foo != NULL;\n\t\t  foo = foo->next ) {\n\t\t/* If we want thread ID's */\n\t\tif ( where->id )\n\t\t\tmemcpy( &where->id[didsomething], &foo->tid,\n\t\t\t\t\tsizeof ( where->id[didsomething] ) );\n\n\t\t/* If we want data pointers */\n\t\tif ( where->data )\n\t\t\twhere->data[didsomething] = foo->thread_storage[tag];\n\n\t\tdidsomething++;\n\n\t\tif ( ( where->id ) || ( where->data ) ) {\n\t\t\tif ( didsomething >= where->num )\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif ( foo->next == _papi_hwi_thread_head )\n\t\t\tbreak;\n\t}\n\n\twhere->num = didsomething;\n\t_papi_hwi_unlock( THREADS_LOCK );\n\n\treturn ( PAPI_OK );\n\n}\n\n#if defined(__NR_gettid) && !defined(HAVE_GETTID)\n  #include <syscall.h>\n  #include <unistd.h>\n  unsigned long _papi_gettid(void)\n  {\n    return (unsigned long)(syscall(__NR_gettid));\n  } \n#elif defined(HAVE_GETTID)\n  #include <sys/types.h>\n  unsigned long _papi_gettid(void)\n  {\n    return (unsigned long)(gettid());\n  }\n#elif defined(HAVE_SYSCALL_GETTID)\n  #include <syscall.h>\n  #include <sys/types.h>\n  unsigned long _papi_gettid(void)\n  {\n    return (unsigned long)(syscall(SYS_gettid));\n  }\n#else\n  #include <sys/types.h>\n  #include <unistd.h>\n  /* Fall-back on getpid for tid if not available. */\n  unsigned long _papi_gettid(void)\n  {\n    return (unsigned long)(getpid());\n  }\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-papi-6.0.0.1-gmm3tef6bggycxgzrtmq2ejaggc2ozfb/spack-src/src/configure.in": "# Process this file with autoconf to produce a configure script.\n# File: configure.in\n\n# cross compile sample\n# ARCH=mips CC=scgcc ./configure --with-arch=mips --host=mips64el-gentoo-linux-gnu- --with-ffsll --with-libpfm4 --with-perf-events --with-virtualtimer=times --with-walltimer=gettimeofday --with-tls=__thread --with-CPU=mips\n# cross compiling should work differently...\n\nAC_PREREQ(2.59)\nAC_INIT(PAPI, 6.0.0.1, ptools-perfapi@icl.utk.edu)\nAC_CONFIG_SRCDIR([papi.c])\nAC_CONFIG_HEADER([config.h])\n\nAC_DEFUN([AS_AC_EXPAND],\n         [EXP_VAR=[$1]\n          FROM_VAR=[$2]\n          prefix_save=$prefix\n          exec_prefix_save=$exec_prefix\n          if test \"x$prefix\" = \"xNONE\"; then\n            prefix=\"$ac_default_prefix\"\n          fi\n          if test \"x$exec_prefix\" = \"xNONE\"; then\n            exec_prefix=$prefix\n          fi\n          full_var=\"$FROM_VAR\"\n          while true; \n            do\n              new_full_var=\"`eval echo $full_var`\"\n              if test \"x$new_full_var\" = \"x$full_var\"; then \n                break; \n              fi\n              full_var=$new_full_var\n            done\n          full_var=$new_full_var\n          AC_DEFINE_UNQUOTED([$1], \"$full_var\")\n          prefix=$prefix_save\n          exec_prefix=$exec_prefix_save ])\n\nAC_MSG_CHECKING(for architecture)\nAC_ARG_WITH(arch,\n\t       [  --with-arch=<arch>\t\tSpecify architecture (uname -m)],\n\t       [arch=$withval],\n\t       [arch=`uname -m`])\nAC_MSG_RESULT($arch)\n\nAC_ARG_WITH(bitmode,\n            [  --with-bitmode=<32,64>\t\tSpecify bit mode of library],\n            [bitmode=$withval])\n\nAC_MSG_CHECKING(for OS)\nAC_ARG_WITH(OS,\n           [  --with-OS=<os>       \t\tSpecify operating system],\n           [OS=$withval],\n\t       [OS=\"`uname | tr '[A-Z]' '[a-z]'`\"\n            if (test \"$OS\" = \"SunOS\" || test \"$OS\" = \"sunos\"); then\n              OS=solaris\n            fi ])\nAC_MSG_RESULT($OS)\n\nAC_MSG_CHECKING(for OS version)\nAC_ARG_WITH(OSVER,\n           [  --with-OSVER=<ver>\t\tSpecify operating system version],\n           [OSVER=$withval],\n\t       [if test \"$OS\" != \"bgp\" -o \"$OS\" != \"bgq\"; then\n              OSVER=\"`uname -r`\"\n            fi ])\nAC_MSG_RESULT($OSVER)\n\nAC_MSG_CHECKING(for perf_event workaround level)\nAC_ARG_WITH(assumed_kernel,\n\t\t[  --with-assumed-kernel=<ver>\tAssume kernel version is <ver> for purposes of workarounds],\n\t\t[assumed_kernel=$withval; CFLAGS=\"$CFLAGS -DASSUME_KERNEL=\\\\\\\"$with_assumed_kernel\\\\\\\"\"],\n                [assumed_kernel=\"autodetect\"]\n\t\t)\t\t\nAC_MSG_RESULT($assumed_kernel)\n\nAC_MSG_CHECKING([for if MIC should be used])\n\t\tAC_ARG_WITH(mic,\n\t\t\t\t\t\t[ --with-mic To compile for Intel MIC ],\n\t\t\t\t\t\t[MIC=yes\n\t\t\t\t\t\ttls=__thread\n\t\t\t\t\t\tvirtualtimer=cputime_id\n\t\t\t\t\t\tperf_events=yes\n\t\t\t\t\t\twalltimer=clock_realtime_hr\n\t\t\t\t\t\tffsll=no\n\t\t\t\t\t\tcross_compiling=yes\n\t\t\t\t\t\tarch=k1om],\n\t\t\t\t\t\t[MIC=no])\nAC_MSG_RESULT($MIC)\nAC_SUBST(MIC)\n\nCFLAGS=\"$CFLAGS -g\"\n#If not set, set FFLAGS to null to prevent AC_PROG_F77 from defaulting it to -g -O2\nif test \"x$FFLAGS\" = \"x\"; then\n  FFLAGS=\"\"\nfi\nOPTFLAGS=\"-O2\" \nTOPTFLAGS=\"-O1\" \nAC_PROG_CC([xlc icc gcc cc])\nAC_PROG_F77([xlf ifort gfortran f95 f90 f77])\nif test \"x$F77\" = \"x\"; then\n   F77=\nfi\nAC_CHECK_PROG( [MPICC], mpicc, [mpicc], [])\n\n# Lets figure out what CC actually is...\n# Used in later checks to set compiler specific options\nif `$CC -V 2>&1 | grep '^Intel(R) C' >/dev/null 2>&1` ; then\n\tCC_COMMON_NAME=\"icc\"\nelif `$CC -v 2>&1 | grep 'gcc version' >/dev/null 2>&1` ; then\n\tCC_COMMON_NAME=\"gcc\"  \nelif `$CC -qversion 2>&1 | grep 'IBM XL C' >/dev/null 2>&1`; then\n\tCC_COMMON_NAME=\"xlc\"\nelse\n\tCC_COMMON_NAME=\"unknown\"\nfi\n\n#prevent icc warnings about overriding optimization settings set by AC_PROG_CC\n# remark #869: parameter was never referenced \n# remark #271: trailing comma is nonstandard\nif test \"$CC_COMMON_NAME\" = \"icc\"; then\n  CFLAGS=\"$CFLAGS -diag-disable 188,869,271\"\n  if test \"$MIC\" = \"yes\"; then\n     CC=\"$CC -mmic -fPIC\"\n  fi\nfi\n\nif test \"$F77\" = \"ifort\" -a \"$MIC\" = \"yes\"; then\n  F77=\"$F77 -mmic -fPIC\"\nfi\n\nAC_PROG_AWK\nAC_PROG_CPP\nAC_PROG_LN_S\nAC_PROG_MAKE_SET\nAC_PROG_RANLIB   \nAC_GNU_SOURCE\nAC_HEADER_STDC\nAC_C_INLINE\nAC_HEADER_TIME\nAC_CHECK_HEADERS([sys/time.h c_asm.h intrinsics.h mach/mach_time.h sched.h])\nAC_CHECK_FUNCS([gethrtime read_real_time time_base_to_time clock_gettime mach_absolute_time sched_getcpu])\n\n#\n# Check if the system provides time_* symbols without -lrt, and if not,\n# check for -lrt existance.\n#\n\nAC_MSG_CHECKING([for timer_create and timer_*ettime symbols in base system])\nAC_TRY_LINK([#include <signal.h>\n             #include <time.h>],\n    [timer_t timerid; timer_create(CLOCK_REALTIME, NULL, &timerid);],\n\t[rtsymbols_in_base=\"yes\"], [rtsymbols_in_base=\"no\"])\nif test \"${rtsymbols_in_base}\" = \"yes\"; then\n\tAC_MSG_RESULT([found])\n\tLRT=\"\"\nelse\n\tAC_MSG_RESULT([not found])\n\tAC_MSG_CHECKING([for timer_create and timer_*ettime symbols in -lrt])\n\tSAVED_LIBS=${LIBS}\n\tLIBS=\"${LIBS} -lrt\"\n\tAC_TRY_LINK([#include <signal.h>\n                 #include <time.h>],\n        [timer_t timerid; timer_create(CLOCK_REALTIME, NULL, &timerid);],\n\t\t[has_lrt=\"yes\"], [has_lrt=\"no\"])\n\tLIBS=${SAVED_LIBS}\n\tif test \"${has_lrt}\" = \"yes\" ; then\n\t\tAC_MSG_RESULT([found])\n\tLRT=\"-lrt\"\n\telse\n\t\tAC_MSG_ERROR([cannot find timer_create and timer_*ettime symbols neither in the base system libraries nor in -lrt])\n\tfi\nfi\nAC_SUBST(LRT)\n\n#\n# Check if the system provides dl* symbols without -ldl, and if not,\n# check for -ldl existance.\n#\n\nAC_MSG_CHECKING([for dlopen and dlerror symbols in base system])\nAC_TRY_LINK([#include <dlfcn.h>],\n\t[void *p = dlopen (\"\", 0); char *c = dlerror();],\n\t[dlsymbols_in_base=\"yes\"], [dlsymbols_in_base=\"no\"])\nif test \"${dlsymbols_in_base}\" = \"yes\"; then\n\tAC_MSG_RESULT([found])\n\tLDL=\"\"\nelse\n\tAC_MSG_RESULT([not found])\n\tAC_MSG_CHECKING([for dlopen and dlerror symbols in -ldl])\n\tSAVED_LIBS=${LIBS}\n\tLIBS=\"${LIBS} -ldl\"\n\tAC_TRY_LINK([#include <dlfcn.h>],\n\t\t[void *p = dlopen (\"\", 0); char *c = dlerror();],\n\t\t[has_ldl=\"yes\"], [has_ldl=\"no\"])\n\tLIBS=${SAVED_LIBS}\n\tif test \"${has_ldl}\" = \"yes\" ; then\n\t\tAC_MSG_RESULT([found])\n  \tLDL=\"-ldl\"\n\telse\n\t\tAC_MSG_ERROR([cannot find dlopen and dlerror symbols neither in the base system libraries nor in -ldl])\n\tfi\nfi\nAC_SUBST(LDL)\n        \n    \nif test \"$OS\" = \"CLE\"; then\n  virtualtimer=times\n  tls=__thread\n  walltimer=cycle\n  ffsll=yes\n  cross_compiling=yes\n  STATIC=\"-static\"\n  # _rtc is only defined when using the Cray compiler\n  AC_MSG_CHECKING([for _rtc intrinsic])\n  rtc_ok=yes\n  AC_TRY_LINK([#ifdef HAVE_INTRINSICS_H\n               #include <intrinsics.h>\n               #endif], [_rtc()], [AC_DEFINE(HAVE__RTC,1,[Define for _rtc() intrinsic.])], \n              [rtc_ok=no\n               AC_DEFINE(NO_RTC_INTRINSIC,1,[Define if _rtc() is not found.])])\n  AC_MSG_RESULT($rtc_ok)\nelif test \"$OS\" = \"bgp\"; then\n  CC=powerpc-bgp-linux-gcc \n  F77=powerpc-bgp-linux-gfortran\n  walltimer=cycle\n  virtualtimer=perfctr\n  tls=no\n  ffsll=yes\n  cross_compiling=yes\nelif test \"$OS\" = \"bgq\"; then\n  AC_ARG_WITH(bgpm_installdir,\n              [  --with-bgpm_installdir=<path> Specify the installation path of BGPM],\n              [BGPM_INSTALL_DIR=$withval\n              CFLAGS=\"$CFLAGS -I$withval\"],\n              [AC_MSG_ERROR([BGQ CPU component requires installation path of BGPM (see --with-bgpm_installdir)])])\n  bitmode=64\n  tls=no\nelif test \"$OS\" = \"linux\"; then\n  if test \"$arch\" = \"ppc64\" -o \"$arch\" = \"x86_64\"; then\n    if test \"$bitmode\" = \"64\" -a \"$libdir\" = '${exec_prefix}/lib'; then\n      libdir='${exec_prefix}/lib64'\n    fi\n  fi\nelif test \"$OS\" = \"solaris\"; then\n  AC_CHECK_TYPE([hrtime_t],\n                [AC_DEFINE(HAVE_HRTIME_T, 1, [Define if hrtime_t is defined in <sys/time.h>])],[],\n                [#if HAVE_SYS_TIME_H\n                 #include <sys/time.h>\n                 #endif])\n  if test \"x$AR\" = \"x\"; then\n    AR=/usr/ccs/bin/ar\n  fi\n\nfi\n\nif test \"x$AR\" = \"x\"; then\n  AR=ar\nfi\n\nif test \"$cross_compiling\" = \"yes\" ; then\n  AC_MSG_CHECKING(for native compiler for header generation)\n  AC_ARG_WITH(nativecc,\n\t         [  --with-nativecc=<path>\t\tSpecify native C compiler for header generation ],\n\t         [nativecc=$withval],\n\t         [nativecc=gcc])\n  AC_MSG_RESULT($nativecc)\nfi\n\nAC_ARG_WITH(tests,\n        \t[  --with-tests=<ctests,ftests,\"ctests ftests\">\t\tSpecify which tests to run on install ],\n        \t[tests=$withval],\n        \t[tests=\"ctests ftests\"]) \n\nAC_MSG_CHECKING(for debug build)\nAC_ARG_WITH(debug,\n            [  --with-debug=<yes,memory,no>\t\tBuild a debug version, debug version plus memory tracker or none ],\n            [debug=$withval])\nif test \"$debug\" = \"yes\"; then\n  if test \"$CC_COMMON_NAME\" = \"gcc\"; then\n    CFLAGS=\"$CFLAGS -g3\"\n  fi\n  OPTFLAGS=\"-O0\"\n  PAPICFLAGS+=\" -DDEBUG -DPAPI_NO_MEMORY_MANAGEMENT\" \nelif test \"$debug\" = \"memory\"; then\n  if test \"$CC_COMMON_NAME\" = \"gcc\"; then\n    CFLAGS=\"$CFLAGS -g3\"\n  fi\n  OPTFLAGS=\"-O0\"\n  PAPICFLAGS+=\" -DDEBUG\" \nelse\n  PAPICFLAGS+=\"-DPAPI_NO_MEMORY_MANAGEMENT\" \t\t\t\nfi\nAC_MSG_RESULT($debug)\n\nif test \"$CC_COMMON_NAME\" = \"gcc\"; then\n  gcc_version=`gcc -v 2>&1 | tail -n 1 | awk '{printf $3}'`\n  major=`echo $gcc_version | sed 's/\\([[^.]][[^.]]*\\).*/\\1/'`\n  minor=`echo $gcc_version | sed 's/[[^.]][[^.]]*.\\([[^.]][[^.]]*\\).*/\\1/'`\n  if (test \"$major\" -ge 4 || test \"$major\" = 3 -a \"$minor\" -ge 4); then\n    CFLAGS+=\" -Wextra\"\n  else\n    CFLAGS+=\" -W\"\n  fi\n# -Wextra => -Woverride-init on gcc >= 4.2\n# This issues a warning (error under -Werror) for some libpfm4 code. \n\tAC_MSG_CHECKING( for -Wno-override-init)\n\t\toldcflags=\"$CFLAGS\"\n\t\tCFLAGS+=\" -Wall -Wextra -Werror -Wno-override-init\"\n\t\tAC_COMPILE_IFELSE([AC_LANG_SOURCE( \n\t\t\t\t\t\t[ struct A { int x; int y; };\n\t\t\t\t\t\tint main(void) { struct A a = {.x = 0, .y = 0, .y = 5 }; return a.x; }\n\t\t\t\t\t\t])], \n\t\t\t\t\t\t[HAVE_NO_OVERRIDE_INIT=1],\n\t\t\t\t\t\t[HAVE_NO_OVERRIDE_INIT=0] )\n\t\tCFLAGS=\"$oldcflags\"\nAC_MSG_RESULT($HAVE_NO_OVERRIDE_INIT)\n\nfi\nAC_MSG_CHECKING(for CPU type)\nAC_ARG_WITH(CPU,\n            [  --with-CPU=<cpu>\t\tSpecify CPU type],\n            [CPU=$withval\n             case \"$CPU\" in\n               core|core2|i7|atom|p4|p3|opteron|athlon)\n                   MISCSRCS=\"$MISCSRCS x86_cpuid_info.c\" \n             esac],\n\t        [case \"$OS\" in\n               aix)\n                 CPU=\"`/usr/sbin/lsattr -E -l proc0 | grep type | cut -d '_' -f 2 | cut -d ' ' -f 1 | tr '[A-Z]' '[a-z]'`\"\n                 if test \"$CPU\" = \"\"; then\n                   CPU=\"`/usr/sbin/lsattr -E -l proc1 | grep type | cut -d '_' -f 2 | cut -d ' ' -f 1 | tr '[A-Z]' '[a-z]'`\"\n                 fi ;;\n\t       freebsd)\n                   family=`uname -m`\n\n\t\t   if test \"$family\" = \"amd64\"; then\n                      MISCSRCS=\"$MISCSRCS x86_cpuid_info.c\" \n\n\t\t   elif test \"$family\" = \"i386\"; then\n                      MISCSRCS=\"$MISCSRCS x86_cpuid_info.c\" \n\t\t   fi ;;\n\n\t       darwin)\n                   family=`uname -m`\n\n                   MISCSRCS=\"$MISCSRCS x86_cpuid_info.c\" \n\n\t\t   ;;\n\n               linux)\n                   family=`uname -m`\n\n\t\t   if test \"$family\" = \"x86_64\"; then\n                      MISCSRCS=\"$MISCSRCS x86_cpuid_info.c\" \n\t\t      CPU=\"x86\"\n\n\t\t   elif test \"$family\" = \"i686\"; then\n                      MISCSRCS=\"$MISCSRCS x86_cpuid_info.c\" \n\t\t      CPU=\"x86\"\n\n                   elif test \"$family\" = \"ppc64\"; then\n                     CPU_info=\"`cat /proc/cpuinfo | grep cpu | cut -d: -f2 | cut -d' ' -f2 | sed '2,$d'`\"\n                     case \"$CPU_info\" in\n                       PPC970*) CPU=\"PPC970\";;\n                       POWER5)  CPU=\"POWER5\";;\n                       POWER5+) CPU=\"POWER5+\";;\n                       POWER6)  CPU=\"POWER6\";;\n                       POWER7)  CPU=\"POWER7\";;\n                     esac\n\t           fi ;;\n               solaris)\n                 AC_CHECK_HEADER([libcpc.h],\n                                 [CFLAGS=\"$CFLAGS -lcpc\"\n                                  AC_TRY_RUN([#include <stdlib.h>\n                                              #include <libcpc.h> \n                                              int main() {\n                                              // Check for libcpc 2\n                                              if(CPC_VER_CURRENT == 2) \n                                                exit(0);\n                                              exit(1);\n                                              } ], \n                                             [cpc_version=2], \n                                             [cpc_version=0])],\n                                 [AC_MSG_ERROR([libcpc is needed for running PAPI on Solaris]) ])\n                 processor=`uname -p`\n                 machinetype=`uname -m`\n                 if test \"$processor\" = \"sparc\"; then\n                   if test \"$machinetype\" = \"sun4u\"; then\n                     CPU=ultra\n                     AC_CHECK_LIB([cpc], [cpc_take_sample], [], \n                                  [AC_MSG_ERROR([libcpc.a is needed on Solaris, install SUNWcpc]) ])\n                   elif test \"$machinetype\" = \"sun4v\"; then\n                     CPU=niagara2\n                     if test \"$cpc_version\" != \"2\"; then\n                       AC_MSG_ERROR([libcpc2 needed for Niagara 2])\n                     fi\n                   else\n                     AC_MSG_ERROR([$machinetype not supported])\n                   fi\n                 else\n                   AC_MSG_ERROR([Only SPARC processors are supported on Solaris])\n                 fi ;;\n               bgp)\n\t             CPU=bgp ;;\n\t\t\t   bgq)\n\t             CPU=bgq ;;\n               esac ])\nAC_MSG_RESULT($CPU)\nAC_DEFINE_UNQUOTED(CPU,$CPU,[cpu type])\n\n# First set pthread-mutexes based on arch                                       \ncase $arch in\n  aarch64|arm*|parisc*)\n    pthread_mutexes=yes\n    CFLAGS=\"$CFLAGS -DUSE_PTHREAD_MUTEXES\"\n    echo \"forcing use of pthread mutexes... \" >&6\n  ;;\nesac\n\n\nAC_ARG_WITH(pthread-mutexes,\n              [  --with-pthread-mutexes\t\tSpecify use of pthread mutexes rather than custom PAPI locks],\n              [pthread_mutexes=yes\n\t      CFLAGS=\"$CFLAGS -DUSE_PTHREAD_MUTEXES\"\n\t      ])\n\n  AC_ARG_WITH(ffsll,\n\t          [  --with-ffsll\t\tSpecify use of the ffsll() function ],\n\t          [ffsll=$withval],\n\t          [if test \"$cross_compiling\" = \"yes\" ; then\n                 AC_MSG_ERROR([ffsll must be specified for cross compile])\n\t\t       fi\n               didcheck=1\n               AC_CHECK_FUNC(ffsll,[ffsll=yes],[ffsll=no]) ])\n               if test \"$ffsll\" = \"yes\" ; then\n                 AC_DEFINE(HAVE_FFSLL, 1, This platform has the ffsll() function)\n               fi\nif test \"$didcheck\" != \"1\"; then\n  AC_MSG_CHECKING(for ffsll)\n  if test \"$ffsll\" = \"yes\" ; then\n    AC_DEFINE(HAVE_FFSLL, 1, This platform has the ffsll() function)\n  fi\n  AC_MSG_RESULT($ffsll)\nfi\n\nAC_MSG_CHECKING(for working gettid)\nAC_LINK_IFELSE([AC_LANG_SOURCE([#include <sys/types.h>\n                main() { pid_t a = gettid(); }])],\n               [AC_MSG_RESULT(yes)\n                AC_DEFINE(HAVE_GETTID, 1, [Full gettid function])],\n               [AC_MSG_RESULT(no)\n                AC_MSG_CHECKING(for working syscall(SYS_gettid))\n                AC_LINK_IFELSE([AC_LANG_SOURCE([#include <sys/types.h>\n                                #include <sys/syscall.h>\n                                main() { pid_t a = syscall(SYS_gettid); }])],\n                               [AC_MSG_RESULT(yes)\n                                AC_DEFINE(HAVE_SYSCALL_GETTID, 1, [gettid syscall function])],\n                               [AC_MSG_RESULT(no)]) ])\n\nAC_ARG_WITH(walltimer,\n            [  --with-walltimer=<gettimeofday,mmtimer,clock_realtime_hr,clock_realtime,cycle>\t\tSpecify realtime timer ],\n            [walltimer=$withval],\n            [if test \"$cross_compiling\" = \"yes\" ; then\n               AC_MSG_ERROR([walltimer must be specified for cross compile])\n             fi\n             AC_MSG_CHECKING(for working MMTIMER)\n             AC_TRY_RUN([#include <unistd.h>\n                         #include <fcntl.h>\n                         #include <errno.h>\n                         #include <stdlib.h>\n                         #include <sys/ioctl.h>\n                         #include <linux/mmtimer.h>\n                         #ifndef MMTIMER_FULLNAME\n                         #define MMTIMER_FULLNAME \"/dev/mmtimer\"\n                         #endif\n                         int main() {\n                           int offset;\n                           int fd;\n                           if((fd = open(MMTIMER_FULLNAME, O_RDONLY)) == -1) \n                             exit(1);\n                           if ((offset = ioctl(fd, MMTIMER_GETOFFSET, 0)) < 0) \n                             exit(1);\n                           close(fd);\n                           exit(0);\n                         } ],\n                        [walltimer=\"mmtimer\"\n\t                     AC_MSG_RESULT(yes)],\n                        [AC_MSG_RESULT(no)\n                         AC_MSG_CHECKING(for working CLOCK_REALTIME_HR POSIX 1b timer)\n                         AC_TRY_RUN([#include <unistd.h>\n                                     #include <stdlib.h>\n                                     #include <stdio.h>\n                                     #include <time.h>\n                                     #include <syscall.h>\n                                     main() {\n                                       struct timespec t1, t2;\n                                       double seconds;\n                                       if (syscall(__NR_clock_gettime,CLOCK_REALTIME_HR,&t1) == -1) exit(1);\n                                         sleep(1);\n                                       if (syscall(__NR_clock_gettime,CLOCK_REALTIME_HR,&t2) == -1) exit(1);\n                                         seconds = ((double)t2.tv_sec + (double)t2.tv_nsec/1000000000.0) - ((double)t1.tv_sec + (double)t1.tv_nsec/1000000000.0);\n                                       if (seconds > 1.0)\n                                         exit(0);\n                                       else\n                                         exit(1);\n                                     } ],\n                                    [walltimer=\"clock_realtime_hr\"\n\t                                 AC_MSG_RESULT(yes)],\n                                    [AC_MSG_RESULT(no)\n                                     AC_MSG_CHECKING(for working CLOCK_REALTIME POSIX 1b timer)\n                                     AC_TRY_RUN([#include <unistd.h>\n                                                 #include <stdlib.h>\n                                                 #include <stdio.h>\n                                                 #include <time.h>\n                                                 #include <syscall.h>\n                                                 main() {\n                                                   struct timespec t1, t2;\n                                                   double seconds;\n                                                   if (syscall(__NR_clock_gettime,CLOCK_REALTIME,&t1) == -1) exit(1);\n                                                     sleep(1);\n                                                   if (syscall(__NR_clock_gettime,CLOCK_REALTIME,&t2) == -1) exit(1);\n                                                     seconds = ((double)t2.tv_sec + (double)t2.tv_nsec/1000000000.0) - ((double)t1.tv_sec + (double)t1.tv_nsec/1000000000.0);\n                                                   if (seconds > 1.0)\n                                                     exit(0);\n                                                   else\n                                                     exit(1);\n                                                 } ],\n                                                [walltimer=\"clock_realtime\"\n\t                                             AC_MSG_RESULT(yes)\t],\n                                                [walltimer=\"cycle\"\n\t                                             AC_MSG_RESULT(no)]) ]) ])  ])\nAC_MSG_CHECKING(for which real time clock to use)\nif test \"$walltimer\" = \"gettimeofday\"; then\n  AC_DEFINE(HAVE_GETTIMEOFDAY, 1, [Normal gettimeofday timer])\nelif test \"$walltimer\" = \"mmtimer\"; then\n  AC_DEFINE(HAVE_MMTIMER, 1, [Altix memory mapped global cycle counter])\n  altix=\"-DALTIX\"\nelif test \"$walltimer\" = \"clock_realtime_hr\"; then\n  AC_DEFINE(HAVE_CLOCK_GETTIME, 1, [POSIX 1b clock])\n  AC_DEFINE(HAVE_CLOCK_GETTIME_REALTIME_HR, 1, [POSIX 1b realtime HR clock])\nelif test \"$walltimer\" = \"clock_realtime\"; then\n  AC_DEFINE(HAVE_CLOCK_GETTIME, 1, [POSIX 1b clock])\n  AC_DEFINE(HAVE_CLOCK_GETTIME_REALTIME, 1, [POSIX 1b realtime clock])\nelif test \"$walltimer\" = \"cycle\"; then\n  AC_DEFINE(HAVE_CYCLE, 1, [Native access to a hardware cycle counter])\nelse\n  AC_MSG_ERROR([Unknown value for walltimer])\nfi\nAC_MSG_RESULT($walltimer)\n\nSAVED_LIBS=$LIBS\nSAVED_LDFLAGS=$LDFLAGS\nSAVED_CFLAGS=$CFLAGS\nLIBS=\"\"\nLDFLAGS=\"\"\nCFLAGS=\"-pthread\"\n\nAC_ARG_WITH(tls,\n              [  --with-tls=<keyword>\t\tThis platform supports thread local storage with a keyword ],\n              [tls=$withval],\n              [if test \"$cross_compiling\" = \"yes\" ; then\n                 AC_MSG_ERROR([tls must be specified for cross compile])\n               fi\n               AC_MSG_CHECKING(for working __thread)\n               AC_TRY_RUN([#include <pthread.h>\n                           #include <unistd.h>\n                           extern __thread int i;\n                           static int res1, res2;\n                           void thread_main (void *arg) {\n                             i = (int)arg;\n                             sleep (1);\n                             if ((int)arg == 1)\n\t\t                       res1 = (i == (int)arg);\n                             else\n\t\t                       res2 = (i == (int)arg);\n                           }\n\t                       __thread int i;\n                           int main () {\n                             pthread_t t1, t2;\n                             i = 5;\n                             pthread_create (&t1, NULL, thread_main, (void *)1);\n                             pthread_create (&t2, NULL, thread_main, (void *)2);\n                             pthread_join (t1, NULL);\n                             pthread_join (t2, NULL);\n                             return !(res1 + res2 == 2);\n                           } ], \n                          [AC_MSG_RESULT(yes)\n\t                       tls=\"__thread\"], \n                          [AC_MSG_RESULT(no)\n                           tls=\"no\" ])\n               if test \"$OS\" = \"linux\"; then\n                 if test \"x$tls\" = \"x__thread\"; then\n                   # On some linux distributions, TLS works in executables, but linking against\n                   # a shared library containing TLS fails with: undefined reference to `__tls_get_addr'\n                   rm -f conftest.c conftest.so conftest\n                   echo \"static __thread int foo; void main () { foo = 5; }\" > conftest.c\n                   gcc -fPIC --shared -o conftest.so conftest.c > /dev/null 2>&1\n                   gcc -o conftest conftest.so > /dev/null 2>&1\n                     if test ! -f conftest; then\n                       AC_MSG_WARN([Disabling usage of __thread.]);\n                       tls=\"no\"\n                     fi\n                   rm -f conftest.c conftest.so conftest\n                 fi\n               fi])\nAC_MSG_CHECKING(for high performance thread local storage)\nif test \"$tls\" = \"no\"; then\n  NOTLS=\"-DNO_TLS\"\nelif test \"x$tls\" != \"x\"; then\n  if test \"$tls\" = \"yes\"; then\n    tls=\"__thread\"\n  fi\n  NOTLS=\"-DUSE_COMPILER_TLS\"\n  AC_DEFINE_UNQUOTED(HAVE_THREAD_LOCAL_STORAGE,$tls,[Keyword for per-thread variables])\nfi\nAC_MSG_RESULT($tls)\n\nAC_ARG_WITH(virtualtimer,\n              [  --with-virtualtimer=<clock_thread_cputime_id,times,proc,getrusage,perfctr>\t\tSpecify per-thread virtual timer ],\n              [virtualtimer=$withval],\n              [if test \"$cross_compiling\" = \"yes\" ; then\n                 AC_MSG_ERROR([virtualtimer must be specified for cross compile])\n               fi\n               AC_MSG_CHECKING(for working CLOCK_THREAD_CPUTIME_ID POSIX 1b timer)\n               AC_TRY_RUN([#include <pthread.h>\n                           #include <sys/signal.h>\n                           #include <sys/times.h>\n                           #include <assert.h>\n                           #include <stdio.h>\n                           #include <sys/types.h>\n                           #include <unistd.h>\n                           #include <sys/unistd.h>\n                           #include <syscall.h>\n                           #include <stdlib.h>\n                           #if !defined( SYS_gettid )\n                           #define SYS_gettid 1105\n                           #endif\n                           struct timespec threadone = { 0, 0 };\n                           struct timespec threadtwo = { 0, 0 };\n                           pthread_t threadOne, threadTwo;\n                           volatile int done = 0;\n  \n                           int gettid() {\n                             return syscall( SYS_gettid );\n                           }\n  \n                           void *doThreadOne( void * v ) {\n                             while (!done)\n\t                           sleep(1);\n                             if (syscall(__NR_clock_gettime,CLOCK_THREAD_CPUTIME_ID,&threadone) == -1) {\n                               perror(\"clock_gettime(CLOCK_THREAD_CPUTIME_ID)\");\n                               exit(1);\n                             }\n                             return 0;\n                           } \n  \n                           void *doThreadTwo( void * v ) {\n                             long i, j = 0xdeadbeef;     \n                             for( i = 0; i < 0xFFFFFFF; ++i ) { j = j ^ i; }\n  \n                             if (syscall(__NR_clock_gettime,CLOCK_THREAD_CPUTIME_ID,&threadtwo) == -1) {\n                               perror(\"clock_gettime(CLOCK_THREAD_CPUTIME_ID)\");\n                               exit(1);\n                             }        \n                             done = 1;\n\t                         return j;\n                           } \n  \n                           int main( int argc, char ** argv ) {\n                             int status = pthread_create( & threadOne, NULL, doThreadOne, NULL );\n                             assert( status == 0 );\n                             status = pthread_create( & threadTwo, NULL, doThreadTwo, NULL );\n                             assert( status == 0 );  \n                             status = pthread_join( threadTwo, NULL );\n                             assert( status == 0 );\n                             status = pthread_join( threadOne, NULL );\n                             assert( status == 0 );\n                             if ((threadone.tv_sec != threadtwo.tv_sec) || (threadone.tv_nsec != threadtwo.tv_nsec))\n                               exit(0);\n                             else {\t\n                               fprintf(stderr,\"T1 %ld %ld T2 %ld %ld\\n\",threadone.tv_sec,threadone.tv_nsec,threadtwo.tv_sec,threadtwo.tv_nsec);\n\t                           exit(1); \n                             }\n                           } ], \n                          [AC_MSG_RESULT(yes)\n                           virtualtimer=\"clock_thread_cputime_id\"], \n                          [AC_MSG_RESULT(no)\n                           # *** Checks for working per thread timer***\n                           AC_MSG_CHECKING(for working per-thread times() timer)\n                           AC_TRY_RUN([#include <pthread.h>\n                                       #include <sys/signal.h>\n                                       #include <sys/times.h>\n                                       #include <assert.h>\n                                       #include <stdio.h>\n                                       #include <sys/types.h>\n                                       #include <unistd.h>\n                                       #include <sys/unistd.h>\n                                       #include <syscall.h>\n                                       #include <stdlib.h>\n                                       #if !defined( SYS_gettid )\n                                       #define SYS_gettid 1105\n                                       #endif\n                                       long threadone = 0, threadtwo = 0;\n                                       pthread_t threadOne, threadTwo;\n                                       volatile int done = 0;\n  \n                                       int gettid() {\n                                         return syscall( SYS_gettid );\n                                       } \n                                       int doThreadOne( void * v ) {\n                                         struct tms tm;\n                                         int status;\n                                         while (!done)\n\t                                       sleep(1);\n                                         status = times( & tm );\n                                         assert( status != -1 );\n                                         threadone = tm.tms_utime;\n                                         return 0;\n                                       }   \n                                       int doThreadTwo( void * v ) {\n                                         struct tms tm;\n                                         long i, j = 0xdeadbeef;\n                                         int status;\n                                         for( i = 0; i < 0xFFFFFFF; ++i ) { j = j ^ i; }\n                                         status = times( & tm );\n                                         assert( status != -1 );\n                                         threadtwo = tm.tms_utime;\n                                         done = 1;\n\t                                     return j;\n                                       } \n                                       int main( int argc, char ** argv ) {\n                                         int status = pthread_create( & threadOne, NULL, doThreadOne, NULL );\n                                         assert( status == 0 );\n                                         status = pthread_create( & threadTwo, NULL, doThreadTwo, NULL );\n                                         assert( status == 0 );  \n                                         status = pthread_join( threadTwo, NULL );\n                                         assert( status == 0 );\n                                         status = pthread_join( threadOne, NULL );\n                                         assert( status == 0 );\n\t                                     return (threadone == threadtwo);\n                                       } ],\n                                      [AC_MSG_RESULT(yes)\n\t                                   virtualtimer=\"times\"],\n                                      [AC_MSG_RESULT(no)\n\t                                   virtualtimer=\"default\"]) ]) ])\nLDFLAGS=$SAVED_LDFLAGS\nCFLAGS=$SAVED_CFLAGS\nLIBS=$SAVED_LIBS\n\nAC_MSG_CHECKING(for which virtual timer to use)\ncase \"$virtualtimer\" in\n  times)\n    AC_DEFINE(HAVE_PER_THREAD_TIMES, 1, [Working per thread timer]) ;;\n  getrusage)\n    AC_DEFINE(HAVE_PER_THREAD_GETRUSAGE, 1, [Working per thread getrusage]) ;;\n  clock_thread_cputime_id)\n    AC_DEFINE(HAVE_CLOCK_GETTIME_THREAD, CLOCK_THREAD_CPUTIME_ID, [POSIX 1b per-thread clock]) ;;\n  proc|default|perfctr)\n    AC_DEFINE(USE_PROC_PTTIMER, 1, [Use /proc for per-thread times])\n    AC_DEFINE(USE_PERFCTR_PTTIMER, 1, [Use the perfctr virtual TSC for per-thread times]) ;;\nesac\nAC_MSG_RESULT($virtualtimer)\n\nif test \"$OS\" = \"aix\"; then\n  AC_ARG_WITH(pmapi,\n              [  --with-pmapi=<path>\t\tSpecify path of pmapi on aix system ],\n              [PMAPI=$withval],\n              [PMAPI=\"/usr/pmapi\"])\n  LIBS=\"-L$PMAPI/lib -lpmapi\"\n  CPPFLAGS=\"$CPPFLAGS -I$PMAPI/include\"\n  AC_CHECK_LIB([pmapi], [pm_initialize], \n               [PMINIT=\"-DPM_INITIALIZE\"], \n               [AC_CHECK_LIB([pmapi], [pm_init], \n                             [PMINIT=\"-DPM_INIT\"], \n                             [AC_MSG_ERROR([libpmapi.a not found, rerun configure with different flags]) ]) ])\nfi\n\nAC_MSG_CHECKING(for static user preset events)\nAC_ARG_WITH(static_user_events,\n\t\t  [ --with-static-user-events             Build with a static user events file.],\n\t\t  [STATIC_USER_EVENTS=$withval],\n\t\t  [STATIC_USER_EVENTS=no])\nif test \"$STATIC_USER_EVENTS\" = \"yes\"; then\n\tPAPICFLAGS+=\" -DSTATIC_USER_EVENTS\"\nfi\nAC_MSG_RESULT($STATIC_USER_EVENTS)\n\nAC_MSG_CHECKING(for static PAPI preset events)\nAC_ARG_WITH(static_papi_events,\n\t\t  [ --with-static-papi-events             Build with a static papi events file.],\n\t\t  [STATIC_PAPI_EVENTS=$withval],\n\t\t  [STATIC_PAPI_EVENTS=yes])\nif test \"$STATIC_PAPI_EVENTS\" = \"yes\"; then\n\tPAPICFLAGS+=\" -DSTATIC_PAPI_EVENTS_TABLE\"\nfi\nAC_MSG_RESULT($STATIC_PAPI_EVENTS)\n\nAC_MSG_CHECKING(for whether to build static library)\nAC_ARG_WITH(static_lib,\n            [  --with-static-lib=<yes,no>\t\tBuild a static library],\n            [static_lib=$withval],\n            [static_lib=yes])\nAC_MSG_RESULT($static_lib)\n\nAC_MSG_CHECKING(for whether to build shared library)\nAC_ARG_WITH(shared_lib,\n            [  --with-shared-lib=<yes,no>\t\tBuild a shared library],\n            [shared_lib=$withval],\n            [shared_lib=yes])\nAC_MSG_RESULT($shared_lib)\n\nif test \"$shared_lib\" = \"no\" -a \"$static_lib\" = \"no\"; then\n  AC_MSG_ERROR(Both shared and static libs are disabled)\nfi\n\nif test \"$shared_lib\" = \"yes\"; then\n  papiLIBS=\"shared\"\nfi\nif test \"$static_lib\" = \"yes\"; then\n  papiLIBS=\"$papiLIBS static\"\nfi\n\nAC_MSG_CHECKING(for static compile of tests and utilities)\nAC_ARG_WITH(static_tools,\n            [  --with-static-tools\t\tSpecify static compile of tests and utilities],\n            [STATIC=\"-static\"\n\t    AC_MSG_RESULT(yes)],\n\t    [AC_MSG_RESULT(no)])\n\nif test \"$static_lib\" = \"no\"; then\n   AC_MSG_ERROR(Building tests and utilities static but no static papi library to be built)\nfi\n\nAC_MSG_CHECKING(for linking with papi shared library of tests and utilities)\nAC_ARG_WITH(shlib_tools,\n\t        [  --with-shlib-tools\t\tSpecify linking with papi library of tests and utilities],\n \t        [shlib_tools=yes\n\t\tAC_MSG_RESULT(yes)],\n\t\t[shlib_tools=no\n\t\tAC_MSG_RESULT(no)])\n\nif test \"$shlib_tools\" = \"yes\"; then\n   if test \"$shared_lib\" != \"yes\"; then\t\n      AC_MSG_ERROR(Building static but specified shared linking for tests and utilities)\n   fi\n   if test \"$STATIC\" = \"-static\"; then\n      AC_MSG_ERROR([Building shared but specified static linking])\n   fi\n   LINKLIB='$(SHLIB)'\nelif test \"$shlib_tools\" = \"no\"; then\n   if test \"$static_lib\" != \"yes\"; then\n      AC_MSG_ERROR([Building shared but specified static linking for tests and utilities])\n   fi\n   LINKLIB='$(LIBRARY)'\t\nfi\n\n##################################################\n#          perfctr\n##################################################\nperfctr=0\nforce_perfctr=no\n\nAC_ARG_WITH(perfctr,\n            [  --with-perfctr\t\tSpecify perfctr as the performance interface ],\n\t    force_perfctr=yes\n            [user_specified_interface=perfctr\n\t     if test \"$arch\" != \"ppc64\"; then\n\t     perfctr=6\n\t     else\n\t     perfctr=7\n\t     fi],\n            [perfctr=0])\n\nif test \"$cross_compiling\" = \"no\" ; then\n  AC_CHECK_FILE(/sys/class/perfctr,[perfctr=7],[AC_CHECK_FILE(/dev/perfctr,[perfctr=6])])\nfi \n\nif test \"$perfctr\" != 0; then \n  pfm_incdir=\"libpfm-3.y/include/\"\n  AC_MSG_CHECKING(for perfctr version)\n  if test \"$perfctr\" = 7 -a \"$arch\" != \"ppc64\"; then\n    AC_MSG_ERROR([Perfctr 2.7.x only works on PPC64 machines. Patch kernel with 2.6.x.])\n  fi\n  AC_MSG_RESULT(2.$perfctr)\nfi\n\nAC_ARG_WITH(perfctr_root,\n            [  --with-perfctr-root=<path>\t\tSpecify path to source tree (for use by developers only) ],\n            [perfctr_root=$withval\n             user_specified_interface=perfctr])\nAC_ARG_WITH(perfctr_prefix,\n            [  --with-perfctr-prefix=<path>\t\tSpecify prefix to installed perfctr distribution ],\n            [perfctr_prefix=$withval\n             user_specified_interface=perfctr])\nAC_ARG_WITH(perfctr_incdir,\n           [  --with-perfctr-incdir=<path>\t\tSpecify directory of perfctr header files in non-standard location ],\n           [perfctr_incdir=$withval\n            user_specified_interface=perfctr])\nAC_ARG_WITH(perfctr_libdir,\n           [  --with-perfctr-libdir=<path>\t\tSpecify directory of perfctr library in non-standard location ],\n           [perfctr_libdir=$withval\n            user_specified_interface=perfctr])\n\nif test \"$perfctr\" != 0; then\n\n  dotest=0\n  if test \"x$perfctr_root\" != \"x\"; then\n    LIBS=\"-L$perfctr_root/usr.lib -lperfctr\"\n    CPPFLAGS=\"$CPPFLAGS -I$perfctr_root/usr.lib -I$perfctr_root/linux/include\"\n    dotest=1\n  elif test \"x$perfctr_prefix\" != \"x\"; then\n    LIBS=\"-L$perfctr_prefix/lib -lperfctr\"\n    CPPFLAGS=\"$CPPFLAGS -I$perfctr_prefix/include\"\n    perfctr_libdir=\"$perfctr_prefix/lib\"\n    perfctr_incdir=\"$perfctr_prefix/include\"\n    dotest=1\n  else\n    if test \"x$perfctr_libdir\" != \"x\"; then\n      LIBS=\"-L$perfctr_libdir -lperfctr\"\n      dotest=1\n    fi\n    if test \"x$perfctr_incdir\" != \"x\"; then\n      CPPFLAGS=\"-I$perfctr_incdir\"\n      dotest=1\n    fi\n  fi\n\n  if test \"$dotest\" = 1; then\n    AC_CHECK_LIB([perfctr], [vperfctr_open], \n                 [AC_CHECK_HEADERS([libperfctr.h], \n                                   [oCFLAGS=$CFLAGS\n\t                                CFLAGS=\"$CFLAGS -static\"\n\t                                AC_TRY_RUN([#include <stdlib.h>\n\t                                            #include \"libperfctr.h\"\n\t                                            int main() {\n\t\t                                          if ((PERFCTR_ABI_VERSION >> 24) != 5) \n                                                    exit(1); \n                                                  exit(0);\n\t                                            } ],\n                                                [perfctr=6],\n                                                [perfctr=7])\n\t                                CFLAGS=$oCFLAGS], \n                                    [AC_MSG_ERROR([libperfctr.h not found, rerun configure with different flags])])],\n                 [AC_MSG_ERROR([libperfctr.a not found, rerun configure with different flags]) ])\n  else\n    AC_DEFINE(HAVE_LIBPERFCTR_H,1,[perfctr header file])\n  fi\nfi\n\nuser_specified_interface=no\n##################################################\n#          perfmon\n##################################################\nold_pfmv2=n\nperfmon=0\nperfmon2=no\nforce_perfmon2=no\n\nAC_ARG_WITH(perfmon,\n            [  --with-perfmon=<x.y>\t\tSpecify perfmon as the performance interface and specify version],\n            [perfmon=$withval \n             user_specified_interface=perfmon\n\t     force_perfmon2=yes\n\t     pfm_incdir=\"libpfm-3.y/include\"\n             perfmon=`echo ${perfmon} | sed 's/^[ \\t]*//;s/[ \\t]*$//'`\n             perfmon=`echo ${perfmon} | grep -e '[[1-9]]\\.[[0-9]][[0-9]]*'`\n             if test \"x$perfmon\" = \"x\"; then\n               AC_MSG_ERROR(\"Badly formed perfmon version string\")\n             fi\n             perfmon=`echo ${perfmon} | sed 's/\\.//'`\n             if test $perfmon -gt 20; then\n               perfmon2=yes\n             fi\n             if test $perfmon -lt 25; then\n               old_pfmv2=y\n\t       PFMCFLAGS=\"-DPFMLIB_OLD_PFMV2\"\n             fi],\n            [perfmon=0\n\t         if test \"$cross_compiling\" = \"no\" ; then\n\t           AC_CHECK_FILE(/sys/kernel/perfmon/version,\n                             [perfmon=`cat /sys/kernel/perfmon/version`],\n                             [AC_CHECK_FILE(/proc/perfmon,\n                                            [perfmon=`cat /proc/perfmon | grep version | cut -d: -f2`],\n                                            [perfmon=0])])\n               if test \"$perfmon\" != 0; then\n\t         pfm_incdir=\"libpfm-3.y/include\"\n                 perfmon=`echo ${perfmon} | sed 's/^[ \\t]*//;s/[ \\t]*$//'`\n                 perfmon=`echo ${perfmon} | grep -e '[[1-9]]\\.[[0-9]][[0-9]]*'`\n                 perfmon=`echo ${perfmon} | sed 's/\\.//'`\n                 if test $perfmon -gt 20; then\n                   perfmon2=yes\n                 fi\n                 if test $perfmon -lt 25; then\n# must be y, not yes, or libpfm breaks\n                   old_pfmv2=\"y\"           \n                   PFMCFLAGS=\"-DPFMLIB_OLD_PFMV2\"\n                 fi\n               fi\n\t         fi])\n\n\nforce_pfm_incdir=no\n# default\n\nAC_ARG_WITH(pfm_root,\n           [  --with-pfm-root=<path>\t\tSpecify path to source tree (for use by developers only) ],\n           [pfm_root=$withval\n\t    pfm_incdir=$withval/include\n\t    pfm_libdir=$withval/lib])\nAC_ARG_WITH(pfm_prefix,\n           [  --with-pfm-prefix=<path>\t\tSpecify prefix to installed pfm distribution ],\n           [pfm_prefix=$withval\n\t    pfm_incdir=$pfm_prefix/include\n\t    pfm_libdir=$pfm_prefix/lib])\nAC_ARG_WITH(pfm_incdir,\n           [  --with-pfm-incdir=<path>\t\tSpecify directory of pfm header files in non-standard location ],\n           [pfm_incdir=$withval])\nAC_ARG_WITH(pfm_libdir,\n           [  --with-pfm-libdir=<path>\t\tSpecify directory of pfm library in non-standard location ],\n           [pfm_libdir=$withval])\n\n# if these are both empty, it means we haven't set either pfm_prefix or pfm_root\n# which would have set them. Thus it means that we set this to our included\n# libpfm4 library. Shame on the person that sets one but not the other.\n\nif test \"x$pfm_incdir\" = \"x\" -a \"x$pfm_libdir\" = \"x\"; then\n   pfm_root=\"libpfm4\"\n   pfm_incdir=\"libpfm4/include\"\n   pfm_libdir=\"libpfm4/lib\"\nfi\n\n##################################################\n#          Linux perf_event/perf_counter\n##################################################\n\nif test \"x$mic\" = \"xno\"; then\n       perf_events=no\nfi\n\nforce_perf_events=no\ndisable_uncore=yes\n\nAC_ARG_WITH(perf_events,\n              [  --with-perf-events\t\tSpecify use of Linux Performance Event (requires kernel 2.6.32 or greater)],\n              [force_perf_events=yes\n\t       user_specified_interface=pe])\n\n# RDPMC support\n\nAC_ARG_ENABLE(perfevent_rdpmc,\nAS_HELP_STRING([--enable-perfevent-rdpmc],\n\t\t[Enable userspace rdpmc instruction on perf_event, default: yes]),\n[case \"${enableval}\" in\n             yes) enable_perfevent_rdpmc=true ;;\n             no)  enable_perfevent_rpdmc=false ;;\n             *)   AC_MSG_ERROR([bad value ${enableval} for --enable-perfevent-rdpmc]) ;;\nesac],\n[enable_perfevent_rdpmc=true])\n\nif test \"$enable_perfevent_rdpmc\" = \"true\"; then\n\tPECFLAGS=\"$PECFLAGS -DUSE_PERFEVENT_RDPMC=1\"\nfi\n\n# Uncore support\nAC_ARG_WITH(pe_incdir,\n\t      [  --with-pe-incdir=<path>\t\tSpecify path to the correct perf header file],\n              [pe_incdir=$withval \n               force_perf_events=yes\n\t       user_specified_interface=pe],\n\t      [pe_incdir=$pfm_incdir/perfmon])\n\nAC_ARG_ENABLE(perf_event_uncore,\n\t\t[  --disable-perf-event-uncore\t\tDisable perf_event uncore component])\n\nAS_IF([test \"x$enable_perf_event_uncore\" != \"xno\"],[\n\tdisable_uncore=no\n])\n\n# Check for perf_event.h\n  if test \"$force_perf_events\" = \"yes\"; then\n\tperf_events=\"yes\"\n  fi\n  if test \"$cross_compiling\" = \"no\"; then \n\tAC_CHECK_FILE(/proc/sys/kernel/perf_event_paranoid,[\n\t  have_paranoid=yes\n\t  AC_CHECK_FILE($pe_incdir/perf_event.h,perf_events=\"yes\")\n    ])\n  fi\n  if test \"$perf_events\" = \"yes\"; then\n      PECFLAGS=\"$PECFLAGS -DPEINCLUDE=\\\\\\\"$pe_incdir/perf_event.h\\\\\\\"\"\n  fi\n\n#\n# Sort out the choice of the user vs. what we detected\n#\n# MESSING WITH CFLAGS IS STUPID!\n#\nif test \"$user_specified_interface\" != \"no\"; then\n   if test \"$user_specified_interface\" = \"perfctr\"; then\n      perfmon=0\n      perf_events=\"no\"\n   else\n\tif test \"$user_specified_interface\" = \"perfmon\"; then\n\t   perfctr=0\n\t   perf_events=\"no\"\n\t   PAPICFLAGS+=\" $PFMCFLAGS\"\n\telse\n\t\tif test \"$user_specified_interface\" = \"pe\"; then\n\t\t\t   perfctr=0\n\t\t\t   perfmon=0\n\t\t\t   PAPICFLAGS+=\" $PECFLAGS\"\n\t\telse\n\t\t\tAC_MSG_ERROR(\"Unknown user_specified_interface=$user_specified_interface perfctr=$perfctr perfmon=$perfmon perfmon2=$perfmon2 perf-events=$perf_events\")\n\t\tfi\t\t\t\t\t\t\t\t \n\tfi\n   fi\nelse\n\tif test \"$perfmon\" != 0; then\n\t   PAPICFLAGS+=\" $PFMCFLAGS\"\n\tfi\n\tif test \"$perf_events\" = \"yes\"; then\n\t   PAPICFLAGS+=\" $PECFLAGS\"\n\tfi\nfi\n\n\n#\n# User has made no choice, so we default to the ordering below in the platform section, if\n# we detect more than one.\n#\n\n#\n# What does this next section do? It determines whether or not to run the tests for libpfm\n# based on the settings of pfm_root, pfm_prefix, pfm_incdir, pfm_libdir\n#\n\nif test \"$perfmon\" != 0 -o \"$perf_events\" = \"yes\"; then\n   # if prefix set, then yes\n   if test \"x$pfm_prefix\" != \"x\"; then\n      dotest=1\n   # if root not set and libdir set, then yes\n   elif test \"x$pfm_root\" = \"x\" -a \"x$pfm_libdir\" != \"x\"; then\n      dotest=1\n   else\n      dotest=0\n   fi\n  if test \"$dotest\" = 1; then\n    LIBS=\"-L$pfm_libdir -lpfm\"\n    CPPFLAGS=\"$CPPFLAGS -I$pfm_incdir\"\n    AC_CHECK_LIB([pfm], [pfm_initialize], \n                 [AC_CHECK_HEADERS([perfmon/pfmlib.h],\n                                   [if test \"$arch\" = \"ia64\"; then\n   \t\t                              AC_CHECK_HEADERS([perfmon/pfmlib_montecito.h])\n                                    fi\n   \t                                AC_CHECK_FUNC(pfm_get_event_description, \n                                                  [AC_DEFINE(HAVE_PFM_GET_EVENT_DESCRIPTION,1,[event description function])],[])\n   \t                                AC_CHECK_MEMBER(pfmlib_reg_t.reg_evt_idx, \n                                                    [AC_DEFINE(HAVE_PFM_REG_EVT_IDX,1,[old reg_evt_idx])],[],[#include \"perfmon/pfmlib.h\"])\n   \t                                AC_CHECK_MEMBER(pfmlib_output_param_t.pfp_pmd_count, \n                                                    [AC_DEFINE(HAVE_PFMLIB_OUTPUT_PFP_PMD_COUNT,1,[new pfmlib_output_param_t])],[],[#include \"perfmon/pfmlib.h\"])\n   \t                                AC_CHECK_MEMBER(pfm_msg_t.type, \n                                                    [AC_DEFINE(HAVE_PFM_MSG_TYPE,1,[new pfm_msg_t])],[],[#include \"perfmon/perfmon.h\"]) ], \n                                   [AC_MSG_ERROR([perfmon/pfmlib.h not found, rerun configure with different flags]) ]) ], \n                 [AC_MSG_ERROR([libpfm.a not found, rerun configure with different flags]) ])\n  else\n    AC_DEFINE(HAVE_PERFMON_PFMLIB_MONTECITO_H,1,[Montecito headers])\n    AC_DEFINE(HAVE_PFM_GET_EVENT_DESCRIPTION,1,[event description function])\n    AC_DEFINE(HAVE_PFMLIB_OUTPUT_PFP_PMD_COUNT,1,[new pfmlib_output_param_t])\n  fi\nfi\n\n##################################################\n#          Checking platform\n##################################################\nAC_MSG_CHECKING(platform)\ncase \"$OS\" in\n  aix)\n    MAKEVER=\"$OS\"-\"$CPU\" ;;\n  bgp)\n    MAKEVER=bgp ;;\n  bgq)\n    MAKEVER=bgq ;;\n  CLE)\n    if test \"$perfmon2\" = \"yes\"; then\n#  major_version=`echo $OSVER | sed 's/\\([[^.]][[^.]]*\\).*/\\1/'`\n#  minor_version=`echo $OSVER | sed 's/[[^.]][[^.]]*.\\([[^.]][[^.]]*\\).*/\\1/'`\n#  point_version=`echo $OSVER | sed -e 's/[[^.]][[^.]]*.[[^.]][[^.]]*.\\(.*\\)/\\1/' -e 's/[[^0-9]].*//'`\n#    if (test \"$major_version\" = 2 -a \"$minor_version\" = 6 -a \"$point_version\" -lt 31 -a \"$perfmon2\" != \"yes\" ); then\n       MAKEVER=\"$OS\"-perfmon2\n    else\n       MAKEVER=\"$OS\"-pe\n    fi ;;\n  freebsd)\n    MAKEVER=\"freebsd\"\n    LDFLAGS=\"-lpmc\"\n    # HWPMC driver is available for FreeBSD >= 6\n    FREEBSD_VERSION=`uname -r | cut -d'.' -f1`\n    if test \"${FREEBSD_VERSION}\" -lt 6 ; then\n      AC_MSG_ERROR([PAPI requires FreeBSD 6 or greater])\n    fi\n    # Determine if HWPMC module is on the kernel\n    dmesg | grep hwpmc 2> /dev/null > /dev/null\n    if test \"$?\" != \"0\" ; then\n      AC_MSG_ERROR([HWPMC module not found. (see INSTALL.TXT)])\n    fi\n    # Determine the number of counters\n    echo \"/* Automatically generated file by configure */\" > freebsd-config.h\n    echo \"#ifndef _FREEBSD_CONFIG_H_\" >> freebsd-config.h\n    echo \"#define _FREEBSD_CONFIG_H_\" >> freebsd-config.h\n    echo \"\" >> freebsd-config.h\n    AC_TRY_LINK([#include <unistd.h>\n                 #include <pmc.h>],\n                [int i = pmc_init();],\n                [pmc_pmc_init_linked=\"yes\"], [pmc_pmc_init_linked=\"no\"])\n    if test \"${pmc_init_linked}\" = \"no\" ; then\n      AC_MSG_ERROR([Failed to link hwpmc example])\n    fi\n    AC_TRY_RUN([#include <unistd.h>\n                #include <pmc.h>\n                int main() { \n                  const struct pmc_cpuinfo *info;\n                  if (pmc_init() < 0) return 0;\n                  if (pmc_cpuinfo (&info) < 0) return 0;\n                  return info->pm_npmc-1;\n                } ],\n               [ num_counters=\"0\" ], \n               [ num_counters=\"$?\"])\n    if test \"${num_counters}\" = \"0\" ; then\n      AC_MSG_ERROR([pmc_npmc info returned 0. Determine if the HWPMC module is loaded (see hwpmc(4))])\n    fi\n    echo \"#define HWPMC_NUM_COUNTERS ${num_counters}\" >> freebsd-config.h\n    echo \"\" >> freebsd-config.h\n    echo \"#endif\" >> freebsd-config.h ;;\n  linux)\n    if test \"$force_perf_events\" = \"yes\" ; then\n      MAKEVER=\"$OS\"-pe\n    elif test \"$force_perfmon2\" = \"yes\" ; then\n      MAKEVER=\"$OS\"-perfmon2\n    elif test \"$force_perfctr\" = \"yes\" ; then\n      MAKEVER=\"$OS\"-perfctr-x86\n      case \"$CPU\" in\n        itanium2|montecito)\n          if test \"$bitmode\" = \"32\"; then\n            AC_MSG_ERROR([The bitmode you specified is not supported])\n          fi\n\t  MAKEVER=\"$OS\"-pfm-\"$CPU\"\n\t  ;;\n        POWER5|POWER5+|POWER6|POWER7|PPC970)\n          MAKEVER=\"$OS\"-perfctr-\"$CPU\" ;;\n     esac\n    elif test \"$perf_events\" = \"yes\" ; then\n      MAKEVER=\"$OS\"-pe\n    elif test \"$perfmon2\" = \"yes\" ; then\n      MAKEVER=\"$OS\"-perfmon2\n    elif test \"$old_pfmv2\" = \"y\" ; then\n      MAKEVER=\"$OS\"-pfm-\"$CPU\"\n    elif test \"$perfctr\" != 0 ; then\n      case \"$CPU\" in\n        itanium2|montecito)\n          if test \"$bitmode\" = \"32\"; then\n            AC_MSG_ERROR([The bitmode you specified is not supported])\n          fi\n\t  MAKEVER=\"$OS\"-pfm-\"$CPU\"\n\t  ;;\n        x86)\n\t        MAKEVER=\"$OS\"-perfctr-x86 ;;\n        POWER5|POWER5+|POWER6|POWER7|PPC970)\n          MAKEVER=\"$OS\"-perfctr-\"$CPU\" ;;\n        *)\n          MAKEVER=\"$OS\"-generic ;;\n     esac\n    else\n      MAKEVER=\"$OS\"-generic\n    fi ;;\t   \n  solaris)\n    if test \"$bitmode\" = \"64\" -a \"`isainfo -v | grep \"64\"`\" = \"\"; then\n      AC_MSG_ERROR([The bitmode you specified is not supported])\n    fi\n    MAKEVER=\"$OS\"-\"$CPU\" ;;\n  darwin)\n    MAKEVER=\"$OS\" ;;\nesac\n\nAC_MSG_RESULT($MAKEVER)\nif test \"x$MAKEVER\" = \"x\"; then\n  AC_MSG_NOTICE(This platform is not supported so a generic build without CPU counters will be used)\n  MAKEVER=\"generic_platform\"\nfi \n\n##################################################\n#          Set build macros \n##################################################\nFILENAME=Makefile.inc\nSHOW_CONF=showconf\nCTEST_TARGETS=\"all\"\nFTEST_TARGETS=\"all\"\nLIBRARY=libpapi.a\nSHLIB='libpapi.so.AC_PACKAGE_VERSION'\nPAPISOVER='$(PAPIVER).$(PAPIREV)'\nVLIB='libpapi.so.$(PAPISOVER)'\nOMPCFLGS=-fopenmp\nCC_R='$(CC) -pthread'\nCC_SHR='$(CC) -fPIC -DPIC -shared -Wl,-soname -Wl,$(VLIB) -Xlinker \"-rpath\" -Xlinker \"$(LIBDIR)\"'\nif test \"$CC_COMMON_NAME\" = \"gcc\"; then\n\tif test \"$bitmode\" = \"32\"; then\n\t\tBITFLAGS=-m32\n\telif test \"$bitmode\" = \"64\"; then\n\t\tBITFLAGS=-m64\n\tfi\nfi\n\nOPTFLAGS=\"$OPTFLAGS\"\nPAPICFLAGS+=\" -D_REENTRANT -D_GNU_SOURCE $NOTLS\"\nCFLAGS=\"$CFLAGS $BITFLAGS\"\nif test \"$CC_COMMON_NAME\" = \"gcc\"; then\n\tCFLAGS=\"$CFLAGS -Wall\"\nfi\nFFLAGS=\"$CFLAGS $BITFLAGS $FFLAGS -Dlinux\"\n\n# OS Support\n\nif (test \"$OS\" = \"aix\"); then\n    OSFILESSRC=aix-memory.c\n    OSLOCK=aix-lock.h\n    OSCONTEXT=aix-context.h\nelif (test \"$OS\" = \"bgp\"); then\n    OSFILESSRC=linux-bgp-memory.c\n    OSLOCK=linux-bgp-lock.h\n    OSCONTEXT=linux-bgp-context.h\nelif (test \"$OS\" = \"bgq\"); then\n    OSFILESSRC=linux-bgq-memory.c\n    OSLOCK=linux-bgq-lock.h\n    OSCONTEXT=linux-context.h\nelif (test \"$OS\" = \"freebsd\"); then\n    OSFILESSRC=freebsd-memory.c\n    OSLOCK=\"freebsd-lock.h\"\n    OSCONTEXT=\"freebsd-context.h\"\nelif (test \"$OS\" = \"linux\"); then\n    OSFILESSRC=\"linux-memory.c linux-timer.c linux-common.c\"\n    OSFILESHDR=\"linux-memory.h linux-timer.h linux-common.h\"\n    OSLOCK=\"linux-lock.h\"\n    OSCONTEXT=\"linux-context.h\"\nelif (test \"$OS\" = \"solaris\"); then\n    OSFILESSRC=\"solaris-memory.c solaris-common.c\"\n    OSFILESHDR=\"solaris-memory.h solaris-common.h\"\n    OSLOCK=\"solaris-lock.h\"\n    OSCONTEXT=\"solaris-context.h\"\nelif (test \"$OS\" = \"darwin\"); then\n    OSFILESSRC=\"darwin-memory.c darwin-common.c\"\n    OSFILESHDR=\"darwin-memory.h darwin-common.h\"\n    OSLOCK=\"darwin-lock.h\"\n    OSCONTEXT=\"darwin-context.h\"\nfi\n\nOSFILESOBJ='$(OSFILESSRC:.c=.o)'\n\n\nif (test \"$MAKEVER\" = \"aix-power5\" || test \"$MAKEVER\" = \"aix-power6\" || test \"$MAKEVER\" = \"aix-power7\"); then\n  if test \"$bitmode\" = \"64\"; then\n    LIBRARY=libpapi64.a\n    SHLIB=libpapi64.so\n# By default AIX enforces a limit on heap space \n#( limiting the heap to share the same 256MB memory segment as stack )\n# changing the max data paramater moves the heap off the stack's memory segment\n    BITFLAGS='-q64 -bmaxdata:0x07000000000000'\n    ARG64=-X64\n  else\n# If the issue ever comes up, /dsa requires AIX v5.1 or higher\n# and the Large address-space model (-bmaxdata) requires v4.3 or later\n# see http://publib.boulder.ibm.com/infocenter/pseries/v5r3/topic/com.ibm.aix.genprogc/doc/genprogc/lrg_prg_support.htm#a179c11c5d\n    SHLIB=libpapi.so\n    BITFLAGS=\"-bmaxdata:0x80000000/dsa\"\n  fi\n\n  CPUCOMPONENT_NAME=aix\n  CPUCOMPONENT_C=aix.c\n  CPUCOMPONENT_OBJ=aix.o\n  VECTOR=_aix_vector\n  PAPI_EVENTS_CSV=\"papi_events.csv\"\n  MISCHDRS=\"aix.h components/perfctr_ppc/ppc64_events.h papi_events_table.h\"\n  MISCSRCS=\"aix.c\"\n  CFLAGS+='-qenum=4 -Icomponents/perfctr_ppc -DNO_VARARG_MACRO -D_AIX -D_$(CPU_MODEL) -DNEED_FFSLL -DARCH_EVTS=\\\"$(ARCH_EVENTS).h\\\" -DCOMP_VECTOR=_ppc64_vectors -DSTATIC_PAPI_EVENTS_TABLE'\n  FFLAGS+='-WF,-D_$(CPU_MODEL) -WF,-DARCH_EVTS=\\\"$(ARCH_EVENTS).h\\\"'\n  CFLAGS+='-I$(PMAPI)/include -Icomponents/perfctr_ppc -qmaxmem=-1 -qarch=$(cpu_option) -qtune=$(cpu_option) -qlanglvl=extended $(BITFLAGS)'\n  if test $debug != \"yes\"; then\n\tOPTFLAGS='-O3 -qstrict $(PMINIT)'\n  else\n\tOPTFLAGS='$(PMINIT)'\n  fi\n  SMPCFLGS=-qsmp\n  OMPCFLGS='-qsmp=omp'\n  LDFLAGS='-L$(PMAPI)/lib -lpmapi'\n  CC_R=xlc_r\n  CC=xlc\n  CC_SHR=\"xlc -G -bnoentry\"\n  AC_CHECK_PROGS( [MPICC], [mpicc mpcc], [])\n  F77=xlf\n  CPP='xlc -E $(CPPFLAGS)'\n  if test \"$MAKEVER\" = \"aix-power5\"; then\n    ARCH_EVENTS=power5_events\n    CPU_MODEL=POWER5\n    cpu_option=pwr5\n    DESCR=\"AIX 5.1.0 or greater with POWER5\"\n    if test \"$bitmode\" = \"64\"; then\n      DESCR=\"$DESCR 64 bit build\"\n    fi\n  elif test \"$MAKEVER\" = \"aix-power6\"; then\n    ARCH_EVENTS=power6_events\n    CPU_MODEL=POWER6\n    cpu_option=pwr6\n    DESCR=\"AIX 5.1.0 or greater with POWER6\"\n    CPPFLAGS=\"-qlanglvl=extended\"\n    if test \"$bitmode\" = \"64\"; then\n      DESCR=\"$DESCR 64 bit build\"\n    fi\n  elif test \"$MAKEVER\" = \"aix-power7\"; then\n    ARCH_EVENTS=power7_events\n    CPU_MODEL=POWER7\n    cpu_option=pwr7\n    DESCR=\"AIX 5.1.0 or greater with POWER7\"\n    CPPFLAGS=\"-qlanglvl=extended\"\n    if test \"$bitmode\" = \"64\"; then\n      DESCR=\"$DESCR 64 bit build\"\n    fi\n  fi\nelif test \"$MAKEVER\" = \"bgp\"; then\n  CPP=\"$CC -E\"\n    CPUCOMPONENT_NAME=linux-bgp\n    CPUCOMPONENT_C=linux-bgp.c\n    CPUCOMPONENT_OBJ=linux-bgp.o\n    VECTOR=_bgp_vectors\n    PAPI_EVENTS_CSV=\"papi_events.csv\"\n    MISCSRCS=\n    CFLAGS='-g -gdwarf-2 -O2 -Wall -I. -I$(BGP_SYSDIR)/arch/include -DCOMP_VECTOR=_bgp_vectors'\n    tests=\"$tests bgp_tests\"\n  SHOW_CONF=show_bgp_conf\n  BGP_SYSDIR=/bgsys/drivers/ppcfloor\n  BGP_GNU_LINUX_PATH='${BGP_SYSDIR}/gnu-linux'\n  LDFLAGS='-L$(BGP_SYSDIR)/runtime/SPI -lSPI.cna'\n  FFLAGS='-g -gdwarf-2 -O2 -Wall -I. -Dlinux'\n  OPTFLAGS=\"-g -Wall -O3\"\n  TOPTFLAGS=\"-g -Wall -O0\"\n  SHLIB=libpapi.so\n  DESCR=\"Linux for BlueGene/P\"\n  LIBS=static\n  CC_SHR='$(CC) -shared -Xlinker \"-soname\" -Xlinker \"$(SHLIB)\" -Xlinker \"-rpath\" -Xlinker \"$(LIBDIR)\"'\n  OMPCFLGS=\"\"\n\nelif test \"$MAKEVER\" = \"bgq\"; then\n  FILENAME=Rules.bgpm\n  VECTOR=_bgq_vectors\n  CPUCOMPONENT_NAME=linux-bgq\n  CPUCOMPONENT_C=linux-bgq.c\n  CPUCOMPONENT_OBJ=linux-bgq.o\n  PAPI_EVENTS_CSV=\"papi_events.csv\"\n  MISCSRCS=\"linux-bgq-common.c\"\n  OPTFLAGS=\"-g -Wall -O3\"\n  TOPTFLAGS=\"-g -Wall -O0\"\n  SHLIB=libpapi.so\n  DESCR=\"Linux for Blue Gene/Q\"\n  CC_SHR='$(CC) -fPIC -DPIC -shared -Wl,-soname -Wl,$(SHLIB) -Xlinker \"-rpath\" -Xlinker \"$(LIBDIR)\"'\n  OMPCFLGS=\"\"\n\nelif test \"$MAKEVER\" = \"CLE-perfmon2\"; then \n    FILENAME=Rules.perfmon2\n    CPUCOMPONENT_NAME=perfmon\n    CPUCOMPONENT_C=perfmon.c\n    CPUCOMPONENT_OBJ=perfmon.o\n    VECTOR=_papi_pfm_vector\n    PAPI_EVENTS_CSV=\"papi_events.csv\"\n  F77=gfortran\n  CFLAGS=\"$CFLAGS -D__crayxt\"\n  FFLAGS=\"\"\n\nelif test \"$MAKEVER\" = \"freebsd\"; then\n    CPUCOMPONENT_NAME=freebsd\n    CPUCOMPONENT_C=freebsd.c\n    CPUCOMPONENT_OBJ=freebsd.o\n    VECTOR=_papi_freebsd_vector\n    PAPI_EVENTS_CSV=\"freebsd_events.csv\"\n    MISCHDRS=\"freebsd/map-unknown.h freebsd/map.h freebsd/map-p6.h freebsd/map-p6-m.h freebsd/map-p6-3.h freebsd/map-p6-2.h freebsd/map-p6-c.h freebsd/map-k7.h freebsd/map-k8.h freebsd/map-p4.h freebsd/map-atom.h freebsd/map-core.h freebsd/map-core2.h freebsd/map-core2-extreme.h freebsd/map-i7.h freebsd/map-westme\\\nre.h\"\n    MISCSRCS=\"$MISCSRCS freebsd/map-unknown.c freebsd/map.c freebsd/map-p6.c freebsd/map-p6-m.c freebsd/map-p6-3.c freebsd/map-p6-2.c freebsd/map-p6-c.c freebsd/map-k7.c freebsd/map-k8.c freebsd/map-p4.c freebsd/map-atom.c freebsd/map-core.c freebsd/map-core2.c freebsd/map-core2-extreme.c freebsd/map-i7.c freebsd/map-westme\\\nre.c\"\n  DESCR=\"FreeBSD -over libpmc- \"\n  CFLAGS+=\" -I. -Ifreebsd -DPIC -fPIC\"\n  CC_SHR='$(CC) -shared -Xlinker \"-soname\" -Xlinker \"libpapi.so\" -Xlinker \"-rpath\" -Xlinker \"$(LIBDIR)\" -DPIC -fPIC -I. -Ifreebsd'\n\nelif test \"$MAKEVER\" = \"linux-generic\"; then\n    CPUCOMPONENT_NAME=linux-generic\n    CPUCOMPONENT_C=linux-generic.c\n    CPUCOMPONENT_OBJ=linux-generic.o\n    PAPI_EVENTS_CSV=\"papi_events.csv\"\n    VECTOR=_papi_dummy_vector\n\nelif test \"$MAKEVER\" = \"linux-pe\"; then\n    FILENAME=Rules.pfm4_pe\n    CPUCOMPONENT_NAME=perf_event \n    components=\"perf_event\"\n    if test \"$disable_uncore\" = \"no\"; then\n       components=\"$components perf_event_uncore\"\n    fi\n\nelif test \"$MAKEVER\" = \"linux-perfctr-x86\"; then\n    FILENAME=Rules.perfctr-pfm\n    CPUCOMPONENT_NAME=perfctr-x86\n    VERSION=2.6.x  \n    components=\"perfctr\"\n\nelif (test \"$MAKEVER\" = \"linux-perfctr-POWER5\" || test \"$MAKEVER\" = \"linux-perfctr-POWER5+\" || test \"$MAKEVER\" = \"linux-perfctr-POWER6\" || test \"$MAKEVER\" = \"linux-perfctr-POWER7\" || test \"$MAKEVER\" = \"linux-perfctr-PPC970\"); then\n    FILENAME=Rules.perfctr\n    CPUCOMPONENT_NAME=perfctr-ppc\n    VERSION=2.7.x\n    components=\"perfctr_ppc\"\n    CPU=ppc64\n    if test \"$MAKEVER\" = \"linux-perfctr-POWER5\"; then\n      CPU_MODEL=POWER5\n      ARCH_EVENTS=power5_events\n      ARCH_SPEC_EVTS=power5_events_map.c\n    elif test \"$MAKEVER\" = \"linux-perfctr-POWER5+\"; then\n      CPU_MODEL=POWER5p\n      ARCH_EVENTS=power5+_events\n      ARCH_SPEC_EVTS=power5+_events_map.c\n    elif test \"$MAKEVER\" = \"linux-perfctr-POWER6\"; then\n      CPU_MODEL=POWER6\n      ARCH_EVENTS=power6_events\n      ARCH_SPEC_EVTS=power6_events_map.c\n    elif test \"$MAKEVER\" = \"linux-perfctr-POWER7\"; then\n      CPU_MODEL=POWER7\n      ARCH_EVENTS=power7_events\n      ARCH_SPEC_EVTS=power7_events_map.c\n    elif test \"$MAKEVER\" = \"linux-perfctr-PPC970\"; then\n      CPU_MODEL=PPC970\n      ARCH_EVENTS=ppc970_events\n      ARCH_SPEC_EVTS=ppc970_events_map.c\n    fi\n    CFLAGS=\"$CFLAGS -DPPC64 -D_$(CPU_MODEL) -D__perfctr__ -DARCH_EVTS=\\\"$(ARCH_EVENTS).h\\\" -DCOMP_VECTOR=_ppc64_vectors\"\n    FFLAGS='-D_$(CPU_MODEL)'\n\nelif test \"$MAKEVER\" = \"linux-perfmon2\"; then\n    FILENAME=Rules.perfmon2\n    CPUCOMPONENT_NAME=perfmon2\n    components=\"perfmon2\"\n\nelif (test \"$MAKEVER\" = \"linux-pfm-ia64\" || test \"$MAKEVER\" = \"linux-pfm-itanium2\" || test \"$MAKEVER\" = \"linux-pfm-montecito\"); then\n    FILENAME=Rules.pfm\n    CPUCOMPONENT_NAME=perfmon-ia64\n    components=\"perfmon_ia64\"\n    VERSION=3.y\n    if test \"$MAKEVER\" = \"linux-pfm-itanium2\"; then\n      CPU=2\n    else\n      CPU=3\n    fi\n    CFLAGS=\"$CFLAGS -DITANIUM$CPU\"\n    FFLAGS=\"$FFLAGS -DITANIUM$CPU\"\n\n  CC_SHR='$(CC) -fPIC -DPIC -shared -Wl,-soname -Wl,$(SHLIB) -Xlinker \"-rpath\" -Xlinker \"$(LIBDIR)\"'\n\nelif test \"$MAKEVER\" = \"solaris-ultra\"; then\n    CPUCOMPONENT_NAME=solaris-ultra\n    CPUCOMPONENT_C=solaris-ultra.c\n    CPUCOMPONENT_OBJ=solaris-ultra.obj\n    VECTOR=_solaris_vector\n    PAPI_EVENTS_CSV=\"papi_events.csv\"\n  DESCR=\"Solaris 5.8 or greater with UltraSPARC I, II or III\"\n  if test \"$CC\" = \"gcc\"; then\n    F77=g77\n    CPP=\"$CC -E\"\n    CC_R=\"$CC\" \n    CC_SHR=\"$CC -shared -fpic\"\n    OPTFLAGS=-O3\n    CFLAGS=\"$CFLAGS -DNEED_FFSLL\"\n    FFLAGS=$CFLAGS\n  else \n    # Sun Workshop compilers: V5.0 and V6.0 R2\n    CPP=\"$CC -E\"\n    CC_R=\"$CC -mt\"\n    CC_SHR=\"$CC -ztext -G -Kpic\" \n      CFLAGS=\"-xtarget=ultra3 -xarch=v8plusa -DNO_VARARG_MACRO -D__EXTENSIONS__ -DPAPI_NO_MEMORY_MANAGEMENT -DCOMP_VECTOR=_solaris_vectors\"\n    SMPCFLGS=-xexplicitpar\n    OMPCFLGS=-xopenmp\n    F77=f90\n    FFLAGS=$CFLAGS\n    NOOPT=-xO0 \n    OPTFLAGS=\"-g -fast -xtarget=ultra3 -xarch=v8plusa\" \n  fi\n  LDFLAGS=\"$LDFLAGS -lcpc\" \n  if test \"$bitmode\" = \"64\"; then\n    LIBRARY=libpapi64.a\n    SHLIB=libpapi64.so\n      CFLAGS=\"-xtarget=ultra3 -xarch=v9a -DNO_VARARG_MACRO -D__EXTENSIONS__ -DPAPI_NO_MEMORY_MANAGEMENT  -DCOMP_VECTOR=_solaris_vectors\"\n    OPTFLAGS=\"-g -fast -xtarget=ultra3 -xarch=v9a\"\n  fi\n\nelif test \"$MAKEVER\" = \"solaris-niagara2\"; then\n    CPUCOMPONENT_NAME=solaris-niagara2\n    CPUCOMPONENT_C=solaris-niagara2.c\n    CPUCOMPONENT_OBJ=solaris-niagara2.obj\n    VECTOR=_niagara2_vector\n    PAPI_EVENTS_CSV=\"papi_events.csv\"\n    CFLAGS=\"-xtarget=native -xarch=native -DNO_VARARG_MACRO -D__EXTENSIONS__ -DCOMP_VECTOR=_niagara2_vector\"\n    ORY_MANAGEMENT=\"-DCOMP_VECTOR=_solaris_vector\"\n  DESCR=\"Solaris 10 with libcpc2 and UltraSPARC T2 (Niagara 2)\"\n  CPP=\"$CC -E\"\n  CC_R=\"$CC -mt\"\n  CC_SHR=\"$CC -ztext -G -Kpic\"  \n  SMPCFLGS=-xexplicitpar\n  OMPCFLGS=-xopenmp\n  F77=f90\n  FFLAGS=$CFLAGS\n  NOOPT=-xO0 \n  OPTFLAGS=\"-fast\" \n  FOPTFLAGS=$OPTFLAGS\n  LDFLAGS=\"$LDFLAGS -lcpc\" \n  if test \"$bitmode\" = \"64\";  then\n    LIBRARY=libpapi64.a\n    SHLIB=libpapi64.so\n    CFLAGS=\"$CFLAGS -m64\"\n    FFLAGS=\"$FFLAGS -m64\"\n  fi\nelif test \"$MAKEVER\" = \"darwin\"; then\n  DESCR=\"Darwin\"\n  CPUCOMPONENT_NAME=darwin\n  CPUCOMPONENT=linux-generic.c\n  CPUCOMPONENT=linux-generic.obj\n  CFLAGS=\"-DNEED_FFSLL\"\n  CC_SHR='$(CC) -fPIC -DPIC -shared -Wl,-dylib -Xlinker \"-rpath\" -Xlinker \"$(LIBDIR)\"'\n  SHLIB=libpapi.dylib\nelif test \"$MAKEVER\" = \"generic_platform\"; then\n  DESCR=\"Generic platform\"\nfi\n\nMISCOBJS='$(MISCSRCS:.c=.o)'\n\n\n\nif test \"$F77\" = \"pgf77\"; then\n  FFLAGS=\"$FFLAGS -Wall -Mextend\"\nelif test \"$F77\" = \"ifort\"; then\n  FFLAGS=\"$FFLAGS -warn all\"\nelif test \"$F77\" != \"xlf\"; then\n  FFLAGS=\"$FFLAGS -ffixed-line-length-132\"\nfi\n\nif test \"$CC_COMMON_NAME\" = \"icc\"; then\n    OMPCFLGS=-qopenmp\nfi\n\nAC_MSG_CHECKING(for components to build)\nCOMPONENT_RULES=components/Rules.components\necho \"/* Automatically generated by configure */\" > components_config.h\necho \"#ifndef COMPONENTS_CONFIG_H\" >> components_config.h\necho \"#define COMPONENTS_CONFIG_H\" >> components_config.h\necho \"\" >> components_config.h\n\nAC_ARG_WITH(components,\n        \t[  --with-components=<\"component1 component2\">\t\tSpecify which components to build ],\n        \t[components=\"$components $withval\"]) \n\n# This is an ugly hack to keep building on configurations covered by any-null in the past.\nif test \"$VECTOR\" = \"_papi_dummy_vector\"; then\n\tif test \"x$components\" = \"x\"; then \n\t\techo \"papi_vector_t ${VECTOR} = {\" >> components_config.h \n \t\techo \"\t.size = {\n\t\t.context = sizeof ( int ),\n\t\t.control_state = sizeof ( int ),\n\t\t.reg_value = sizeof ( int ),\n\t\t.reg_alloc = sizeof ( int ),\n\t}, \n\t.cmp_info = { \n\t\t.num_native_events = 0, \n\t\t.num_preset_events = 0, \n\t\t.num_cntrs = 0,\n\t\t.name = \\\"Your system is unsupported! \\\",\n\t\t.short_name = \\\"UNSUPPORTED!\\\" \n\t},\n\t.dispatch_timer = NULL,\n    .get_overflow_address = NULL,\n    .start = NULL,\n    .stop = NULL,\n    .read = NULL,\n    .reset = NULL,\n    .write = NULL,\n\t.cleanup_eventset = NULL,\n    .stop_profiling = NULL,\n    .init_component = NULL,\n    .init_thread = NULL,\n    .init_control_state = NULL,\n    .update_control_state = NULL,\n    .ctl = NULL,\n    .set_overflow = NULL,\n    .set_profile\t = NULL,\n    .set_domain = NULL,\n    .ntv_enum_events = NULL,\n    .ntv_name_to_code = NULL,\n    .ntv_code_to_name = NULL,\n    .ntv_code_to_descr = NULL,\n    .ntv_code_to_bits = NULL,\n    .ntv_code_to_info = NULL,\n    .allocate_registers = NULL,\n    .shutdown_thread = NULL,\n    .shutdown_component = NULL,\n    .user = NULL,\n};\" >> components_config.h\n\t# but in the face of actual components, we don't have to do hacky size games\n\telse\n\t\tVECTOR=\"\"\n\tfi\nelif test \"x$VECTOR\" != \"x\"; then\n   echo \"extern papi_vector_t ${VECTOR};\" >> components_config.h\nfi\n    \n\n\nfor comp in $components; do\n  idx=`echo \"$comp\" | sed -n \"s/\\/.*//p\" | wc -c`\n  if test \"$idx\" = 0; then\n\tsubcomp=$comp\n  else\n      subcomp=`echo $comp | sed -E \"s/^.{${idx}}//\"`\n  fi\n  COMPONENT_RULES=\"$COMPONENT_RULES components/$comp/Rules.$subcomp\"\n  echo \"extern papi_vector_t _${subcomp}_vector;\" >> components_config.h\ndone\necho \"\" >> components_config.h\necho \"struct papi_vectors *_papi_hwd[[]] = {\" >> components_config.h\n\nif test \"x$VECTOR\" != \"x\"; then\n   echo \"   &${VECTOR},\" >> components_config.h\nfi\n\nfor comp in $components; do\n  idx=`echo \"$comp\" | sed -n \"s/\\/.*//p\" | wc -c` \n  if test \"$idx\" = 0; then\n\tsubcomp=$comp\n  else\n      subcomp=`echo $comp | sed -E \"s/^.{${idx}}//\"`\n  fi\n  echo \"   &_${subcomp}_vector,\" >> components_config.h\ndone\necho \"   NULL\" >> components_config.h\necho \"};\" >> components_config.h\necho \"\" >> components_config.h\necho \"#endif\" >> components_config.h \n\n# check for component tests\nfor comp in $components; do\n  if test \"`find components/$comp -name \"tests\"`\" != \"\" ; then\n\tCOMPONENTS=\"$COMPONENTS $comp\"\n  fi\ndone\ntests=\"$tests comp_tests\"\n\n# check for SDE component to determine if we need -lrt in LDFLAGS\nfor comp in $components; do\n  if test \"x$comp\" = \"xsde\" ; then\n    LDFLAGS=\"$LDFLAGS $LRT\"\n    LIBS=\"$LIBS $LRT\"\n  fi\ndone\n\nAC_MSG_RESULT($components)\n\nAC_MSG_CHECKING(for PAPI event CSV filename to use)\nif test \"x$PAPI_EVENTS_CSV\" == \"x\"; then\n   PAPI_EVENTS_CSV=\"papi_events.csv\"\nfi\nAC_MSG_RESULT($PAPI_EVENTS_CSV)\n\nAC_SUBST(prefix)\nAC_SUBST(exec_prefix)\nAC_SUBST(libdir)\nAC_SUBST(includedir)\nAC_SUBST(mandir)\nAC_SUBST(bindir)\nAC_SUBST(datadir)\nAC_SUBST(datarootdir)\nAC_SUBST(docdir)\nAC_SUBST(PACKAGE_TARNAME)\nAC_SUBST(arch)\nAC_SUBST(MAKEVER)\nAC_SUBST(PMAPI)\nAC_SUBST(PMINIT)\nAC_SUBST(F77)\nAC_SUBST(CPP)\nAC_SUBST(CC)\nAC_SUBST(AR)\nAC_SUBST(papiLIBS)\nAC_SUBST(STATIC)\nAC_SUBST(LDFLAGS)\nAC_SUBST(altix)\nAC_SUBST(perfctr_root)\nAC_SUBST(perfctr_prefix)\nAC_SUBST(perfctr_incdir)\nAC_SUBST(perfctr_libdir)\nAC_SUBST(pfm_root)\nAC_SUBST(old_pfmv2)\nAC_SUBST(pfm_prefix)\nAC_SUBST(pfm_incdir)\nAC_SUBST(pfm_libdir)\nAC_SUBST(OS)\nAC_SUBST(CFLAGS)\nAC_SUBST(FFLAGS)\nAC_SUBST(CPPFLAGS)\nAC_SUBST(PAPI_EVENTS)\nAC_SUBST(PAPI_EVENTS_CSV)\nAC_SUBST(SETPATH)\nAC_SUBST(LINKLIB)\nAC_SUBST(VERSION)\nAC_SUBST(CPU)\nAC_SUBST(FILENAME)\nAC_SUBST(LIBRARY)\nAC_SUBST(SHLIB)\nAC_SUBST(PAPISOVER)\nAC_SUBST(VLIB)\nAC_SUBST(PAPICFLAGS)\nAC_SUBST(OPTFLAGS)\nAC_SUBST(CPUCOMPONENT_NAME)\nAC_SUBST(CPUCOMPONENT_C)\nAC_SUBST(CPUCOMPONENT_OBJ)\nAC_SUBST(OSFILESSRC)\nAC_SUBST(OSFILESOBJ)\nAC_SUBST(OSFILESHDR)\nAC_SUBST(OSLOCK)\nAC_SUBST(OSCONTEXT)\nAC_SUBST(DESCR)\nAC_SUBST(LIBS)\nAC_SUBST(CTEST_TARGETS)\nAC_SUBST(CC_R)\nAC_SUBST(CC_SHR)\nAC_SUBST(SMPCFLGS)\nAC_SUBST(OMPCFLGS)\nAC_SUBST(NOOPT)\nAC_SUBST(MISCSRCS)\nAC_SUBST(MISCOBJS)\nAC_SUBST(POST_BUILD)\nAC_SUBST(ARCH_EVENTS)\nAC_SUBST(CPU_MODEL)\nAC_SUBST(cpu_option)\nAC_SUBST(ARG64)\nAC_SUBST(FLAGS)\nAC_SUBST(MPICC)\nAC_SUBST(MISCHDRS)\nAC_SUBST(SHLIBDEPS)\nAC_SUBST(TOPTFLAGS)\nAC_SUBST(TESTS)\nAC_SUBST(tests)\nAC_SUBST(SHOW_CONF)\nAC_SUBST(BGP_SYSDIR)\nAC_SUBST(BITFLAGS)\nAC_SUBST(COMPONENT_RULES)\nAC_SUBST(COMPONENTS)\nAC_SUBST(FTEST_TARGETS)\nAC_SUBST(HAVE_NO_OVERRIDE_INIT)\nAC_SUBST(BGPM_INSTALL_DIR)\nAC_SUBST(CC_COMMON_NAME)\n\nif test \"$cross_compiling\" = \"yes\" ; then\n  AC_MSG_NOTICE(Compiling genpapifdef with $nativecc because cross compiling)\n  $nativecc -I. genpapifdef.c -o genpapifdef\nelse\n  AC_MSG_NOTICE(Compiling genpapifdef with $CC)\n  $CC -I. genpapifdef.c -o genpapifdef\nfi\n\nAC_MSG_NOTICE(Generating fpapi.h)\n./genpapifdef -c > fpapi.h\nAC_MSG_NOTICE(Generating f77papi.h)\n./genpapifdef -f77 > f77papi.h\nAC_MSG_NOTICE(Generating f90papi.h)\n./genpapifdef -f90 > f90papi.h\n\nAC_MSG_NOTICE($FILENAME will be included in the generated Makefile)\nAC_CONFIG_FILES([Makefile papi.pc])\nAC_CONFIG_FILES([components/Makefile_comp_tests.target testlib/Makefile.target utils/Makefile.target ctests/Makefile.target ftests/Makefile.target validation_tests/Makefile.target])\nAC_OUTPUT\n\nif test \"$have_paranoid\" = \"yes\"; then\n  paranoid_level=`cat /proc/sys/kernel/perf_event_paranoid`\n  if test $paranoid_level -gt 2; then\n    warning_text=`echo -e \"\\n\n***************************************************************************\n* Insufficient permissions for accessing any hardware counters.           *\n* Your current paranoid level is $paranoid_level.                                       *\n* Set /proc/sys/kernel/perf_event_paranoid to 2 (or less) or run as root. *\n*                                                                         *\n* Example:                                                                *\n* sudo sh -c \\\"echo 2 > /proc/sys/kernel/perf_event_paranoid\\\"              *\n***************************************************************************\n\"\\ `\n    AC_MSG_WARN($warning_text)\n  fi\nfi\n",
        "/tmp/vanessa/spack-stage/spack-stage-papi-6.0.0.1-gmm3tef6bggycxgzrtmq2ejaggc2ozfb/spack-src/src/utils/papi_native_avail.c": "/* This file utility reports hardware info and native event availability */\n/** file papi_native_avail.c\n *\t@page papi_native_avail\n * @brief papi_native_avail utility.\n *\t@section  NAME\n *\t\tpapi_native_avail - provides detailed information for PAPI native events. \n *\n *\t@section Synopsis\n *\n *\t@section Description\n *\t\tpapi_native_avail is a PAPI utility program that reports information \n *\t\tabout the native events available on the current platform.\n *\t\tA native event is an event specific to a specific hardware platform. \n *\t\tOn many platforms, a specific native event may have a number of optional settings. \n *\t\tIn such cases, the native event and the valid settings are presented, \n *\t\trather than every possible combination of those settings.\n *\t\tFor each native event, a name, a description, and specific bit patterns are provided.\n *\n *\t@section Options\n * <ul>\n * <li>--help, -h    print this help message\n * <li>--check, -c    print this help message\n * <li>-e EVENTNAME  display detailed information about named native event\n * <li>-i EVENTSTR   include only event names that contain EVENTSTR\n * <li>-x EVENTSTR   exclude any event names that contain EVENTSTR\n * <li>--noqual      suppress display of event qualifiers (mask and flag) information\\n\n * </ul>\n *\n * Processor-specific options\n * <ul>\n * <li>--darr        display events supporting Data Address Range Restriction\n * <li>--dear        display Data Event Address Register events only\n * <li>--iarr        display events supporting Instruction Address Range Restriction\n * <li>--iear        display Instruction Event Address Register events only\n * <li>--opcm        display events supporting OpCode Matching\n * <li>--nogroups    suppress display of Event grouping information\n * </ul>\n *\n *\t@section Bugs\n *\t\tThere are no known bugs in this utility.\n *\t\tIf you find a bug, it should be reported to the\n *\t\tPAPI Mailing List at <ptools-perfapi@icl.utk.edu>.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <unistd.h>\n#include <dlfcn.h>\n\n#include \"papi.h\"\n#include \"print_header.h\"\n#include \"components/sde/interface/papi_sde_interface.h\"\n\n#define EVT_LINE 80\n#define EVT_LINE_BUF_SIZE 4096\n\ntypedef struct command_flags\n{\n\tint help;\n\tint named;\n\tint include;\n\tint xclude;\n\tint check;\n\tint list_sdes;\n\tchar *path, *name, *istr, *xstr;\n\tint darr;\n\tint dear;\n\tint iarr;\n\tint iear;\n\tint opcm;\n\tint qualifiers;\n\tint groups;\n} command_flags_t;\n\nstatic void\nprint_help( char **argv )\n{\n\tprintf( \"This is the PAPI native avail program.\\n\" );\n\tprintf( \"It provides availability and details about PAPI Native Events.\\n\" );\n\tprintf( \"Usage: %s [options]\\n\", argv[0] );\n        printf( \"Options:\\n\\n\" );\n\tprintf( \"\\nGeneral command options:\\n\" );\n\tprintf( \"\\t-h, --help       print this help message\\n\" );\n\tprintf( \"\\t-c, --check      attempts to add each event\\n\");\n\tprintf( \"\\t-sde FILE        lists SDEs that are registered by the library or executable in FILE\\n\" );\n\tprintf( \"\\t-e EVENTNAME     display detailed information about named native event\\n\" );\n\tprintf( \"\\t-i EVENTSTR      include only event names that contain EVENTSTR\\n\" );\n\tprintf( \"\\t-x EVENTSTR      exclude any event names that contain EVENTSTR\\n\" );\n\tprintf( \"\\t--noqual         suppress display of event qualifiers (mask and flag) information\\n\" );\n\tprintf( \"\\nProcessor-specific options:\\n\");\n\tprintf( \"\\t--darr           display events supporting Data Address Range Restriction\\n\" );\n\tprintf( \"\\t--dear           display Data Event Address Register events only\\n\" );\n\tprintf( \"\\t--iarr           display events supporting Instruction Address Range Restriction\\n\" );\n\tprintf( \"\\t--iear           display Instruction Event Address Register events only\\n\" );\n\tprintf( \"\\t--opcm           display events supporting OpCode Matching\\n\" );\n\tprintf( \"\\t--nogroups       suppress display of Event grouping information\\n\" );\n\tprintf( \"\\n\" );\n}\n\nstatic int\nno_str_arg( char *arg )\n{\n\treturn ( ( arg == NULL ) || ( strlen( arg ) == 0 ) || ( arg[0] == '-' ) );\n}\n\nstatic void\nparse_args( int argc, char **argv, command_flags_t * f )\n{\n\tint i;\n\n\t/* Look for all currently defined commands */\n\tmemset( f, 0, sizeof ( command_flags_t ) );\n\tf->qualifiers = 1;\n\tf->groups = 1;\n\n\tfor ( i = 1; i < argc; i++ ) {\n\t\tif ( !strcmp( argv[i], \"--darr\" ) )\n\t\t\tf->darr = 1;\n\t\telse if ( !strcmp( argv[i], \"--dear\" ) )\n\t\t\tf->dear = 1;\n\t\telse if ( !strcmp( argv[i], \"--iarr\" ) )\n\t\t\tf->iarr = 1;\n\t\telse if ( !strcmp( argv[i], \"--iear\" ) )\n\t\t\tf->iear = 1;\n\t\telse if ( !strcmp( argv[i], \"--opcm\" ) )\n\t\t\tf->opcm = 1;\n\t\telse if ( !strcmp( argv[i], \"--noqual\" ) )\n\t\t\tf->qualifiers = 0;\n\t\telse if ( !strcmp( argv[i], \"--nogroups\" ) )\n\t\t\tf->groups = 0;\n\t\telse if ( !strcmp( argv[i], \"-e\" ) ) {\n\t\t\tf->named = 1;\n\t\t\ti++;\n\t\t\tif ( i < argc )\n\t\t\t    f->name = argv[i];\n\t\t\tif ( no_str_arg( f->name ) ) {\n\t\t\t\tprintf( \"Invalid argument for -e\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t} else if ( !strcmp( argv[i], \"-sde\" ) ) {\n\t\t\tf->list_sdes = 1;\n\t\t\ti++;\n\t\t\tif ( i < argc )\n\t\t\t    f->path = argv[i];\n\t\t\tif ( no_str_arg( f->path ) ) {\n\t\t\t\tprintf( \"Invalid argument for -sde\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t} else if ( !strcmp( argv[i], \"-i\" ) ) {\n\t\t\tf->include = 1;\n\t\t\ti++;\n\t\t\tif ( i < argc )\n\t\t\t    f->istr = argv[i];\n\t\t\tif ( no_str_arg( f->istr ) ) {\n\t\t\t\tprintf( \"Invalid argument for -i\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t} else if ( !strcmp( argv[i], \"-x\" ) ) {\n\t\t\tf->xclude = 1;\n\t\t\ti++;\n\t\t\tif ( i < argc )\n\t\t\t    f->xstr = argv[i];\n\t\t\tif ( no_str_arg( f->xstr ) ) {\n\t\t\t\tprintf( \"Invalid argument for -x\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t} else if ( strstr( argv[i], \"-h\" ) ) {\n\t\t\tf->help = 1;\n\t\t} else if ( !strcmp( argv[i], \"-c\" ) || !strcmp( argv[i], \"--check\" ) ) {\n\t\t\tf->check = 1;\n\t\t} else {\n\t\t\tprintf( \"%s is not supported\\n\", argv[i] );\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t/* if help requested, print and bail */\n\tif ( f->help ) {\n\t\tprint_help( argv);\n\t\texit( 1 );\n\t}\n}\n\nstatic void\nspace_pad( char *str, int spaces )\n{\n\twhile ( spaces-- > 0 )\n\t\tstrcat( str, \" \" );\n}\n\nunsigned int event_available = 0;\nunsigned int event_output_buffer_size = 0;\nchar *event_output_buffer = NULL;\n\nstatic void\ncheck_event( PAPI_event_info_t * info )\n{\n\tint EventSet = PAPI_NULL;\n\n\t// if this event has already passed the check test, no need to try this one again\n\tif (event_available) {\n\t\treturn;\n\t}\n\n\tif (PAPI_create_eventset (&EventSet) == PAPI_OK) {\n\t\tif (PAPI_add_named_event (EventSet, info->symbol) == PAPI_OK) {\n\t\t\tPAPI_remove_named_event (EventSet, info->symbol);\n\t\t\tevent_available = 1;\n\t\t} // else printf(\"********** PAPI_add_named_event( %s ) failed: event could not be added \\n\", info->symbol);\n\t\tif ( PAPI_destroy_eventset( &EventSet ) != PAPI_OK ) {\n\t\t\tprintf(\"**********  Call to destroy eventset failed when trying to check event '%s'  **********\\n\", info->symbol);\n\t\t}\n\t}\n\n\treturn;\n}\n\nstatic int\nformat_event_output( PAPI_event_info_t * info, int offset)\n{\n\tunsigned int i, j = 0;\n\tchar event_line_buffer[EVT_LINE_BUF_SIZE];\n\tchar event_line_units[100];\n\n\t/* indent by offset */\n\tif ( offset ) {\n\t\t// this one is used for event qualifiers\n\t\tsprintf(event_line_buffer, \"|     %-73s|\\n\", info->symbol);\n\t}\n\telse {\n\t\t// this one is used for new events\n\t\tsprintf(event_line_buffer, \"| %-73s%4s|\\n\", info->symbol, \"<-->\");\n\t}\n\n\twhile ( j <= strlen( info->long_descr ) ) {\n\t\t// The event_line_buffer is used to collect an event or mask name and its description.\n\t\t// The description will be folded to keep the length of output lines reasonable.  So this\n\t\t// buffer may contain multiple lines of print output.  Check to make sure there is room\n\t\t// for another line of print output.  If there is not enough room for another output line\n\t\t// just exit the loop and truncate the description field (the buffer is big enough this\n\t\t// should not happen).\n\t\tif ((EVT_LINE_BUF_SIZE - strlen(event_line_buffer)) < EVT_LINE) {\n\t\t\tprintf (\"Event or mask description has been truncated.\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\t// get amount of description that will fit in an output line\n\t\ti = EVT_LINE - 12 - 2;\n\t\t// start of a description line\n\t\tstrcat(event_line_buffer,\"|            \" );\n\t\t// if we need to copy less than what fits in this line, move it and exit loop\n\t\tif (i > strlen(&info->long_descr[j])) {\n\t\t\tstrcat( event_line_buffer, &info->long_descr[j]);\n\t\t\tspace_pad( event_line_buffer, i - strlen(&info->long_descr[j]));\n\t\t\tstrcat( event_line_buffer, \"|\\n\" );\n\t\t\tbreak;\n\t\t}\n\n\t\t// move what will fit into the line then loop back to do the rest in a new line\n\t\tint k = strlen(event_line_buffer);\n\t\tstrncat( event_line_buffer, &info->long_descr[j], i );\n\t\tevent_line_buffer[k+i] = '\\0';\n\t\tstrcat( event_line_buffer, \"|\\n\" );\n\n\t\t// bump index past what we copied\n\t\tj += i;\n\t}\n\n\t// also show the units for this event if a unit name has been set\n\tevent_line_units[0] = '\\0';\n\tif (info->units[0] != 0) {\n\t\tsprintf(event_line_units, \"|     Units: %-66s|\\n\", info->units );\n\t}\n\n\t// get the amount of used space in the output buffer\n\tint out_buf_used = 0;\n\tif ((event_output_buffer_size > 0) && (event_output_buffer != NULL)) {\n\t\tout_buf_used = strlen(event_output_buffer);\n\t}\n\n\t// if this will not fit in output buffer, make it bigger\n\tif (event_output_buffer_size < out_buf_used + strlen(event_line_buffer) + strlen(event_line_units) + 1) {\n\t\tif (event_output_buffer_size == 0) {\n\t\t\tevent_output_buffer_size = 1024;\n\t\t\tevent_output_buffer = calloc(1, event_output_buffer_size);\n\t\t} else {\n\t\t\tevent_output_buffer_size += 1024;\n\t\t\tevent_output_buffer = realloc(event_output_buffer, event_output_buffer_size);\n\t\t}\n\t}\n\n\t// make sure we got the memory we asked for\n\tif (event_output_buffer == NULL) {\n\t\tfprintf(stderr,\"Error!  Allocation of output buffer memory failed.\\n\");\n\t\treturn errno;\n\t}\n\n\tstrcat(event_output_buffer, event_line_buffer);\n\tstrcat(event_output_buffer, event_line_units);\n\n\treturn 0;\n}\n\nstatic void\nprint_event_output(int val_flag)\n{\n\t// first we need to update the available flag at the beginning of the buffer\n\t// this needs to reflect if this event name by itself or the event name with one of the qualifiers worked\n\t// if none of the combinations worked then we will show the event as not available\n\tchar *val_flag_ptr = strstr(event_output_buffer, \"<-->\");\n\tif (val_flag_ptr != NULL) {\n\t\tif ((val_flag) && (event_available == 0)) {\n\t\t\t// event is not available, update the place holder (replace the <--> with <NA>)\n\t\t\t*(val_flag_ptr+1) = 'N';\n\t\t\t*(val_flag_ptr+2) = 'A';\n\t\t} else {\n\t\t\tevent_available = 0;       // reset this flag for next event\n\t\t\t// event is available, just remove the place holder (replace the <--> with spaces)\n\t\t\t*val_flag_ptr = ' ';\n\t\t\t*(val_flag_ptr+1) = ' ';\n\t\t\t*(val_flag_ptr+2) = ' ';\n\t\t\t*(val_flag_ptr+3) = ' ';\n\t\t}\n\t}\n\n\t// now we can finally send this events output to the user\n\tprintf( \"%s\", event_output_buffer);\n//\tprintf( \"--------------------------------------------------------------------------------\\n\" );\n\n\tevent_output_buffer[0] = '\\0';          // start the next event with an empty buffer\n\treturn;\n}\n\nstatic int\nparse_event_qualifiers( PAPI_event_info_t * info )\n{\n\tchar *pmask,*ptr;\n\n\t/* handle the PAPI component-style events which have a component:::event type */\n\tif ((ptr=strstr(info->symbol, \":::\"))) {\n\t\tptr+=3;\n\t\t/* handle libpfm4-style events which have a pmu::event type event name */\n\t} else if ((ptr=strstr(info->symbol, \"::\"))) {\n\t\tptr+=2;\n\t}\n\telse {\n\t\tptr=info->symbol;\n\t}\n\n\tif ( ( pmask = strchr( ptr, ':' ) ) == NULL ) {\n\t\treturn ( 0 );\n\t}\n\tmemmove( info->symbol, pmask, ( strlen(pmask) + 1 ) * sizeof(char) );\n\n\t//  The description field contains the event description followed by a tag 'masks:'\n\t//  and then the mask description (if there was a mask with this event).  The following\n\t//  code isolates the mask description part of this information.\n\n\tpmask = strstr( info->long_descr, \"masks:\" );\n\tif ( pmask == NULL ) {\n\t\tinfo->long_descr[0] = 0;\n\t} else {\n\t\tpmask += 6;        // bump pointer past 'masks:' identifier in description\n\t\tmemmove( info->long_descr, pmask, (strlen(pmask) + 1) * sizeof(char) );\n\t}\n\treturn ( 1 );\n}\n\nvoid\ninvoke_hook_fptr( char *lib_path )\n{\n    void *dl_handle;\n    typedef void *(* hook_fptr_t)(papi_sde_fptr_struct_t *);\n    hook_fptr_t hook_func_ptr;\n\n    /* Clear any old error conditions */\n    (void)dlerror();\n\n    dl_handle = dlopen(lib_path, RTLD_LOCAL | RTLD_LAZY);\n    if ( NULL == dl_handle ) {\n        return;\n    }\n\n    hook_func_ptr = (hook_fptr_t)dlsym(dl_handle, \"papi_sde_hook_list_events\");\n    if ( (NULL != hook_func_ptr) && ( NULL == dlerror()) ) {\n        papi_sde_fptr_struct_t fptr_struct;\n\n        POPULATE_SDE_FPTR_STRUCT( fptr_struct );\n        (void)hook_func_ptr( &fptr_struct );\n    }\n\n    dlclose(dl_handle);\n    return;\n}\n\nint\nmain( int argc, char **argv )\n{\n\tint i, k;\n\tint num_events;\n\tint num_cmp_events = 0;\n\tint retval;\n\tPAPI_event_info_t info;\n\tconst PAPI_hw_info_t *hwinfo = NULL;\n\tcommand_flags_t flags;\n\tint enum_modifier;\n\tint numcmp, cid;\n\n\t/* Initialize before parsing the input arguments */\n\tretval = PAPI_library_init( PAPI_VER_CURRENT );\n\tif ( retval != PAPI_VER_CURRENT ) {\n\t\tfprintf(stderr, \"Error! PAPI_library_init\\n\");\n\t\treturn retval;\n\t}\n\n\t/* Parse the command-line arguments */\n\tparse_args( argc, argv, &flags );\n\n\t/* Set enum modifier mask */\n\tif ( flags.dear )\n\t\tenum_modifier = PAPI_NTV_ENUM_DEAR;\n\telse if ( flags.darr )\n\t\tenum_modifier = PAPI_NTV_ENUM_DARR;\n\telse if ( flags.iear )\n\t\tenum_modifier = PAPI_NTV_ENUM_IEAR;\n\telse if ( flags.iarr )\n\t\tenum_modifier = PAPI_NTV_ENUM_IARR;\n\telse if ( flags.opcm )\n\t\tenum_modifier = PAPI_NTV_ENUM_OPCM;\n\telse\n\t\tenum_modifier = PAPI_ENUM_EVENTS;\n\n\tretval = PAPI_set_debug( PAPI_VERB_ECONT );\n\tif ( retval != PAPI_OK ) {\n\t\tfprintf(stderr,\"Error!  PAPI_set_debug\\n\");\n\t\treturn retval;\n\t}\n\n\tretval = papi_print_header( \"Available native events and hardware information.\\n\", &hwinfo );\n\tif ( retval != PAPI_OK ) {\n\t\tfprintf(stderr,\"Error!  PAPI_get_hardware_info\\n\");\n\t\treturn 2;\n\t}\n\n    /*\n       The following code will execute if the user wants to list the SDEs in the\n       library (or executable) stored in flags.path. This code will not list the\n       SDEs per se, it will only give an opportunity to the library to register\n       their SDEs, so they can be listed further down.\n    */\n    if ( flags.list_sdes ){\n        char *cmd;\n        FILE *pipe;\n\n        if ( access(flags.path, R_OK) == -1 ){\n            fprintf(stderr,\"Error!  Unable to read file '%s'.\\n\",flags.path);\n            goto no_sdes;\n        }\n\n        int len = 5+strlen(flags.path);\n        cmd = (char *)calloc(len, sizeof(char));\n        if( NULL == cmd ) goto no_sdes;\n\n        int l = snprintf(cmd, len, \"ldd %s\",flags.path);\n        if(l<len-1){\n            free(cmd);\n            goto no_sdes;\n        }\n\n        /* First open all the dependencies of the file we were given */\n        pipe = popen(cmd, \"r\");\n        if( NULL != pipe ){\n            while( !feof(pipe) ){\n                char *lineptr, *lib_name, *lib_path;\n                size_t n=0;\n                lineptr = lib_name = lib_path = NULL;\n\n                if( getline(&lineptr, &n, pipe) == -1 ){\n                    if(lineptr) free(lineptr);\n                    break;\n                }\n\n                /* If this line does not give us a path to a library, ignore it. */\n                if( (NULL != strstr(lineptr,\"not found\")) || (NULL == strstr(lineptr,\" => \")) ) {\n                    goto skip_lib;\n                }\n\n                int status = sscanf(lineptr, \"%ms => %ms (%*x)\", &lib_name, &lib_path);\n                /* If this line is malformed, ignore it. */\n                if(2 != status){\n                    /* According to the man page: \"it is necessary to call free()\n                       only if the scanf() call successfully read a string.\" */\n                    goto skip_lib;\n                }\n\n                /* Invoke the hook for the dependency we just discovered */\n                invoke_hook_fptr(lib_path);\n\n                if( lib_name ) free(lib_name);\n                if( lib_path ) free(lib_path);\nskip_lib:\n                if(lineptr) free(lineptr);\n                lineptr = NULL;\n                n=0;\n            }\n            pclose(pipe);\n        }\n\n        /* Finally, invoke the hook for the file the user gave us */\n        invoke_hook_fptr(flags.path);\n\n        if( NULL != cmd ) free(cmd);\n    }\nno_sdes:\n\n\t/* Do this code if the event name option was specified on the commandline */\n\tif ( flags.named ) {\n\t\tif ( PAPI_event_name_to_code( flags.name, &i ) == PAPI_OK ) {\n\t\t\tif ( PAPI_get_event_info( i, &info ) == PAPI_OK ) {\n\t\t\t\tprintf( \"Event name:     %s\\n\",\tinfo.symbol);\n\t\t\t\tprintf( \"Description:    %s\\n\", info.long_descr );\n\n\t\t\t\t/* handle the PAPI component-style events which have a component:::event type */\n\t\t\t\tchar *ptr;\n\t\t\t\tif ((ptr=strstr(flags.name, \":::\"))) {\n\t\t\t\t\tptr+=3;\n\t\t\t\t\t/* handle libpfm4-style events which have a pmu::event type event name */\n\t\t\t\t} else if ((ptr=strstr(flags.name, \"::\"))) {\n\t\t\t\t\tptr+=2;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tptr=flags.name;\n\t\t\t\t}\n\n\t\t\t\t/* if event qualifiers exist but none specified, process all */\n\t\t\t\tif ( !strchr( ptr, ':' ) ) {\n\t\t\t\t\tif ( PAPI_enum_event( &i, PAPI_NTV_ENUM_UMASKS ) == PAPI_OK ) {\n\t\t\t\t\t\tprintf( \"\\nQualifiers:         Name -- Description\\n\" );\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tretval = PAPI_get_event_info( i, &info );\n\t\t\t\t\t\t\tif ( retval == PAPI_OK ) {\n\t\t\t\t\t\t\t\tif ( parse_event_qualifiers( &info ) ) {\n\t\t\t\t\t\t\t\t\tprintf( \"      Info:   %10s -- %s\\n\", info.symbol, info.long_descr );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} while ( PAPI_enum_event( &i, PAPI_NTV_ENUM_UMASKS ) == PAPI_OK );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tprintf(\"Sorry, an event by the name '%s' could not be found.\\n\",\n\t\t\t\t\tflags.name);\n\t\t\tprintf(\"Is it typed correctly?\\n\\n\");\n\t\t\texit( 1 );\n\t\t}\n\t\treturn 0;\n\t}\n\n\t// Look at all the events and qualifiers and print the information the user has asked for */\n\n\tnumcmp = PAPI_num_components(  );\n\n\tnum_events = 0;\n\n\tfor ( cid = 0; cid < numcmp; cid++ ) {\n\t\tconst PAPI_component_info_t *component;\n\t\tcomponent=PAPI_get_component_info(cid);\n\n\t\t/* Skip disabled components */\n\t\tif (component->disabled) continue;\n\n\t\tprintf( \"===============================================================================\\n\" );\n\t\tprintf( \" Native Events in Component: %s\\n\",component->name);\n\t\tprintf( \"===============================================================================\\n\" );\n\n\t\t// show this component has not found any events yet\n\t\tnum_cmp_events = 0;\n\n\t\t/* Always ASK FOR the first event */\n\t\t/* Don't just assume it'll be the first numeric value */\n\t\ti = 0 | PAPI_NATIVE_MASK;\n\n\t\tretval=PAPI_enum_cmp_event( &i, PAPI_ENUM_FIRST, cid );\n\n\t\tif (retval==PAPI_OK) {\n\t\t\tdo {\n\t\t\t\tmemset( &info, 0, sizeof ( info ) );\n\t\t\t\tretval = PAPI_get_event_info( i, &info );\n\n\t\t\t\t/* This event may not exist */\n\t\t\t\tif ( retval != PAPI_OK ) continue;\n\n\t\t\t\t/* Bail if event name doesn't contain include string */\n\t\t\t\tif ( flags.include && !strstr( info.symbol, flags.istr ) ) continue;\n\n\t\t\t\t/* Bail if event name does contain exclude string */\n\t\t\t\tif ( flags.xclude && strstr( info.symbol, flags.xstr ) ) continue;\n\n\t\t\t\t// if not the first event in this component, put out a divider\n\t\t\t\tif (num_cmp_events) {\n\t\t\t\t\tprintf( \"--------------------------------------------------------------------------------\\n\" );\n\t\t\t\t}\n\n\t\t\t\t/* count only events that are actually processed */\n\t\t\t\tnum_events++;\n\t\t\t\tnum_cmp_events++;\n\n\t\t\t\tif (flags.check){\n\t\t\t\t\tcheck_event(&info);\n\t\t\t\t}\n\n\t\t\t\tformat_event_output( &info, 0);\n\n\t\t\t\t/*\t\tmodifier = PAPI_NTV_ENUM_GROUPS returns event codes with a\n\t\t\t\t\t\tgroups id for each group in which this\n\t\t\t\t\t\tnative event lives, in bits 16 - 23 of event code\n\t\t\t\t\t\tterminating with PAPI_ENOEVNT at the end of the list.\n\t\t\t\t\t\t*/\n\n\t\t\t\t/* This is an IBM Power issue */\n\t\t\t\tif ( flags.groups ) {\n\t\t\t\t\tk = i;\n\t\t\t\t\tif ( PAPI_enum_cmp_event( &k, PAPI_NTV_ENUM_GROUPS, cid ) == PAPI_OK ) {\n\t\t\t\t\t\tprintf( \"Groups: \" );\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tprintf( \"%4d\", ( ( k & PAPI_NTV_GROUP_AND_MASK ) >>\n\t\t\t\t\t\t\t\t\t\tPAPI_NTV_GROUP_SHIFT ) - 1 );\n\t\t\t\t\t\t} while ( PAPI_enum_cmp_event( &k, PAPI_NTV_ENUM_GROUPS, cid ) ==PAPI_OK );\n\t\t\t\t\t\tprintf( \"\\n\" );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// If the user has asked us to check the events then we need to\n\t\t\t\t// walk the list of qualifiers and try to check the event with each one.\n\t\t\t\t// Even if the user does not want to display the qualifiers this is necessary\n\t\t\t\t// to be able to correctly report which events can be used on this system.\n\t\t\t\t//\n\t\t\t\t// We also need to walk the list if the user wants to see the qualifiers.\n\n\t\t\t\tif (flags.qualifiers || flags.check){\n\t\t\t\t\tk = i;\n\t\t\t\t\tif ( PAPI_enum_cmp_event( &k, PAPI_NTV_ENUM_UMASKS, cid ) == PAPI_OK ) {\n\t\t\t\t\t\t// clear event string using first mask\n\t\t\t\t\t\tchar first_event_mask_string[PAPI_HUGE_STR_LEN] = \"\";\n\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tretval = PAPI_get_event_info( k, &info );\n\t\t\t\t\t\t\tif ( retval == PAPI_OK ) {\n\t\t\t\t\t\t\t\t// if first event mask string not set yet, set it now\n\t\t\t\t\t\t\t\tif (strlen(first_event_mask_string) == 0) {\n\t\t\t\t\t\t\t\t\tstrcpy (first_event_mask_string, info.symbol);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif ( flags.check ) {\n\t\t\t\t\t\t\t\t\tcheck_event(&info);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// now test if the event qualifiers should be displayed to the user\n\t\t\t\t\t\t\t\tif ( flags.qualifiers ) {\n\t\t\t\t\t\t\t\t\tif ( parse_event_qualifiers( &info ) )\n\t\t\t\t\t\t\t\t\t\tformat_event_output( &info, 2);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} while ( PAPI_enum_cmp_event( &k, PAPI_NTV_ENUM_UMASKS, cid ) == PAPI_OK );\n\t\t\t\t\t\t// if we are validating events and the event_available flag is not set yet, try a few more combinations\n\t\t\t\t\t\tif (flags.check  && (event_available == 0)) {\n\t\t\t\t\t\t\t// try using the event with the first mask defined for the event and the cpu mask\n\t\t\t\t\t\t\t// this is a kludge but many of the uncore events require an event specific mask (usually\n\t\t\t\t\t\t\t// the first one defined will do) and they all require the cpu mask\n\t\t\t\t\t\t\tstrcpy (info.symbol, first_event_mask_string);\n\t\t\t\t\t\t\tstrcat (info.symbol, \":cpu=1\");\n\t\t\t\t\t\t\tcheck_event(&info);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (flags.check  && (event_available == 0)) {\n\t\t\t\t\t\t\t// an even bigger kludge is that there are 4 snpep_unc_pcu events which require the 'ff' and 'cpu' qualifiers to work correctly.\n\t\t\t\t\t\t\t// if nothing else has worked, this code will try those two qualifiers with the current event name to see if it works\n\t\t\t\t\t\t\tstrcpy (info.symbol, first_event_mask_string);\n\t\t\t\t\t\t\tchar *wptr = strrchr (info.symbol, ':');\n\t\t\t\t\t\t\tif (wptr != NULL) {\n\t\t\t\t\t\t\t\t*wptr = '\\0';\n\t\t\t\t\t\t\t\tstrcat (info.symbol, \":ff=64:cpu=1\");\n\t\t\t\t\t\t\t\tcheck_event(&info);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tprint_event_output(flags.check);\n\t\t\t} while (PAPI_enum_cmp_event( &i, enum_modifier, cid ) == PAPI_OK );\n\t\t}\n\t}\n\n\tif (num_cmp_events != 0) {\n\t\tprintf( \"--------------------------------------------------------------------------------\\n\" );\n\t}\n\tprintf( \"\\nTotal events reported: %d\\n\", num_events );\n\n\tif (num_events==0) {\n\t\tprintf(\"\\nNo events detected!  Check papi_component_avail to find out why.\\n\");\n\t\tprintf(\"\\n\");\n\t}\n\n\n\treturn 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-papi-6.0.0.1-gmm3tef6bggycxgzrtmq2ejaggc2ozfb/spack-src/src/ctests/shlib.c": "/*\n* File:    profile.c\n* Author:  Philip Mucci\n*          mucci@cs.utk.edu\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#if (!defined(NO_DLFCN) && !defined(_BGL) && !defined(_BGP))\n#include <dlfcn.h>\n#endif\n\n#include \"papi.h\"\n#include \"papi_test.h\"\n\nvoid print_shlib_info_map(const PAPI_shlib_info_t *shinfo, int quiet)\n{\n\tPAPI_address_map_t *map = shinfo->map;\n\tint i;\n\tif (NULL == map) {\n\t\ttest_fail(__FILE__, __LINE__, \"PAPI_get_shared_lib_info\", 1);\n\t}\n\n\tif (!quiet) for ( i = 0; i < shinfo->count; i++ ) {\n\t\tprintf( \"Library: %s\\n\", map->name );\n\t\tprintf( \"Text start: %p, Text end: %p\\n\", map->text_start,\n\t\t\t\tmap->text_end );\n\t\tprintf( \"Data start: %p, Data end: %p\\n\", map->data_start,\n\t\t\t\tmap->data_end );\n\t\tprintf( \"Bss start: %p, Bss end: %p\\n\", map->bss_start, map->bss_end );\n\n\t\tif ( strlen( &(map->name[0]) ) == 0 )\n\t\t\ttest_fail( __FILE__, __LINE__, \"PAPI_get_shared_lib_info\", 1 );\n\t\tif ( ( map->text_start == 0x0 ) || ( map->text_end == 0x0 ) ||\n\t\t\t ( map->text_start >= map->text_end ) )\n\t\t\ttest_fail( __FILE__, __LINE__, \"PAPI_get_shared_lib_info\", 1 );\n/*\n       if ((map->data_start == 0x0) || (map->data_end == 0x0) ||\n\t   (map->data_start >= map->data_end))\n\t test_fail(__FILE__, __LINE__, \"PAPI_get_shared_lib_info\",1);\n       if (((map->bss_start) && (!map->bss_end)) ||\n\t   ((!map->bss_start) && (map->bss_end)) ||\n\t   (map->bss_start > map->bss_end))\n\t test_fail(__FILE__, __LINE__, \"PAPI_get_shared_lib_info\",1);\n*/\n\n\t\tmap++;\n\t}\n}\n\nvoid display( char *msg )\n{\n\tint i;\n\tfor (i=0; i<64; i++)\n\t{\n\t\tprintf( \"%1d\", (msg[i] ? 1 : 0) );\n\t}\n\tprintf(\"\\n\");\n}\n\nint\nmain( int argc, char **argv )\n{\n\tint retval,quiet;\n\n\tconst PAPI_shlib_info_t *shinfo;\n\n\t/* Set TESTS_QUIET variable */\n\tquiet = tests_quiet( argc, argv );\n\n\tretval = PAPI_library_init( PAPI_VER_CURRENT );\n\tif (retval != PAPI_VER_CURRENT ) {\n\t\ttest_fail( __FILE__, __LINE__, \"PAPI_library_init\", retval );\n\t}\n\n\tif ( ( shinfo = PAPI_get_shared_lib_info(  ) ) == NULL ) {\n\t\ttest_skip( __FILE__, __LINE__, \"PAPI_get_shared_lib_info\", 1 );\n\t}\n\n\tif ( ( shinfo->count == 0 ) && ( shinfo->map ) ) {\n\t\ttest_fail( __FILE__, __LINE__, \"PAPI_get_shared_lib_info\", 1 );\n\t}\n\n\tprint_shlib_info_map(shinfo, quiet);\n\n\t/* Needed for debugging, so you can ^Z and stop the process, */\n\t/* inspect /proc to see if it's right */\n\tsleep( 1 );\n\n#ifndef NO_DLFCN\n\t{\n\n\tconst char *_libname = \"libcrypt.so\";\n\tvoid *handle;\n\tvoid ( *setkey) (const char *key);\n\tvoid ( *encrypt) (char block[64], int edflag);\n\tchar key[64]={\n\t\t1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,\n\t\t1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,\n\t\t1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,\n\t\t1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,\n\t}; /* bit pattern for key */\n\tchar orig[64];      /* bit pattern for messages */\n\tchar txt[64];      \t    /* bit pattern for messages */\n\n\tint oldcount;\n\n\thandle = dlopen( _libname, RTLD_NOW );\n\tif ( !handle ) {\n\t\tprintf( \"dlopen: %s\\n\", dlerror(  ) );\n\t\tif (!quiet) printf( \"Did you forget to set the environmental \"\n\t\t\t\"variable LIBPATH (in AIX) or \"\n\t\t\t\"LD_LIBRARY_PATH (in linux) ?\\n\" );\n\t\t\ttest_fail( __FILE__, __LINE__, \"dlopen\", 1 );\n\t}\n\n\tsetkey = dlsym( handle, \"setkey\" );\n\tencrypt = dlsym( handle, \"encrypt\" );\n\tif ( setkey == NULL || encrypt == NULL) {\n\t\tif (!quiet) printf( \"dlsym: %s\\n\", dlerror(  ) );\n\t\ttest_fail( __FILE__, __LINE__, \"dlsym\", 1 );\n\t}\n\n\tmemset(orig,0,64);\n\tmemcpy(txt,orig,64);\n\tsetkey(key);\n\n\tif (!quiet) {\n\t\tprintf(\"original  \");\n\t\tdisplay(txt);\n\t}\n\n\tencrypt(txt, 0);   /* encode */\n\n\tif (!quiet) {\n\t\tprintf(\"encrypted \");\n\t\tdisplay(txt);\n\t}\n\n\tif (!memcmp(txt,orig,64)) {\n\t\ttest_fail( __FILE__, __LINE__, \"encode\", 1 );\n\t}\n\n\tencrypt(txt, 1);   /* decode */\n\n\tif (!quiet) {\n\t\tprintf(\"decrypted \");\n\t\tdisplay(txt);\n\t}\n\n\tif (memcmp(txt,orig,64)) {\n\t\ttest_fail( __FILE__, __LINE__, \"decode\", 1 );\n\t}\n\n\toldcount = shinfo->count;\n\n\tif ( ( shinfo = PAPI_get_shared_lib_info(  ) ) == NULL ) {\n\t\ttest_fail( __FILE__, __LINE__, \"PAPI_get_shared_lib_info\", 1 );\n\t}\n\n\t/* Needed for debugging, so you can ^Z and stop the process, */\n\t/* inspect /proc to see if it's right */\n\tsleep( 1 );\n\n\tif ( ( shinfo->count == 0 ) && ( shinfo->map ) ) {\n\t\ttest_fail( __FILE__, __LINE__, \"PAPI_get_shared_lib_info\", 1 );\n\t}\n\n\tif ( shinfo->count <= oldcount ) {\n\t\ttest_fail( __FILE__, __LINE__, \"PAPI_get_shared_lib_info\", 1 );\n\t}\n\n\tprint_shlib_info_map(shinfo, quiet);\n\n\t/* Needed for debugging, so you can ^Z and stop the process, */\n\t/* inspect /proc to see if it's right */\n\tsleep( 1 );\n\n\tdlclose( handle );\n\n\t}\n#endif\n\n\ttest_pass( __FILE__ );\n\n\treturn 0;\n\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-papi-6.0.0.1-gmm3tef6bggycxgzrtmq2ejaggc2ozfb/spack-src/src/components/vmware/vmware.c": "/****************************/\n/* THIS IS OPEN SOURCE CODE */\n/****************************/\n\n/**\n * @file    mware.c\n * @author  Matt Johnson\n *          mrj@eecs.utk.edu\n * @author  John Nelson\n *          jnelso37@eecs.utk.edu\n * @author  Vince Weaver\n *          vweaver1@eecs.utk.edu\n *\n * @ingroup papi_components\n *\n * VMware component\n *\n * @brief\n *\tThis is the VMware component for PAPI-V. It will allow user access to\n *\thardware information available from a VMware virtual machine.\n */\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n\n#include <unistd.h>\n#include <dlfcn.h>\n\n/* Headers required by PAPI */\n#include \"papi.h\"\n#include \"papi_internal.h\"\n#include \"papi_vector.h\"\n#include \"papi_memory.h\"\n\n#define VMWARE_MAX_COUNTERS 256\n\n#define VMWARE_CPU_LIMIT_MHZ            0\n#define VMWARE_CPU_RESERVATION_MHZ      1\n#define VMWARE_CPU_SHARES               2\n#define VMWARE_CPU_STOLEN_MS            3\n#define VMWARE_CPU_USED_MS              4\n#define VMWARE_ELAPSED_MS               5\n\n#define VMWARE_MEM_ACTIVE_MB            6\n#define VMWARE_MEM_BALLOONED_MB         7\n#define VMWARE_MEM_LIMIT_MB             8\n#define VMWARE_MEM_MAPPED_MB            9\n#define VMWARE_MEM_OVERHEAD_MB          10\n#define VMWARE_MEM_RESERVATION_MB       11\n#define VMWARE_MEM_SHARED_MB            12\n#define VMWARE_MEM_SHARES               13\n#define VMWARE_MEM_SWAPPED_MB           14\n#define VMWARE_MEM_TARGET_SIZE_MB       15\n#define VMWARE_MEM_USED_MB              16\n\n#define VMWARE_HOST_CPU_MHZ             17\n\n/* The following 3 require VMWARE_PSEUDO_PERFORMANCE env_var to be set. */\n\n#define VMWARE_HOST_TSC\t\t\t18\n#define VMWARE_ELAPSED_TIME             19\n#define VMWARE_ELAPSED_APPARENT         20\n\n/* Begin PAPI definitions */\npapi_vector_t _vmware_vector;\n\n\nvoid (*_dl_non_dynamic_init)(void) __attribute__((weak));\n\n/** Structure that stores private information for each event */\nstruct _vmware_register {\n    unsigned int selector;\n    /**< Signifies which counter slot is being used */\n    /**< Indexed from 1 as 0 has a special meaning  */\n};\n\n/** This structure is used to build the table of events */\nstruct _vmware_native_event_entry {\n\tchar name[PAPI_MAX_STR_LEN];        /**< Name of the counter         */\n\tchar description[PAPI_HUGE_STR_LEN]; /**< Description of counter     */\n        char units[PAPI_MIN_STR_LEN];\n        int which_counter;\n        int report_difference;\n};\n\nstruct _vmware_reg_alloc {\n\tstruct _vmware_register ra_bits;\n};\n\n\ninline uint64_t rdpmc(int c)\n{\n  uint32_t low, high;\n  __asm__ __volatile__(\"rdpmc\" : \"=a\" (low), \"=d\" (high) : \"c\" (c));\n  return (uint64_t)high << 32 | (uint64_t)low;\n}\n\n\n\n#ifdef VMGUESTLIB\n/* Headers required by VMware */\n#include \"vmGuestLib.h\"\n\n/* Functions to dynamically load from the GuestLib library. */\nchar const * (*GuestLib_GetErrorText)(VMGuestLibError);\nVMGuestLibError (*GuestLib_OpenHandle)(VMGuestLibHandle*);\nVMGuestLibError (*GuestLib_CloseHandle)(VMGuestLibHandle);\nVMGuestLibError (*GuestLib_UpdateInfo)(VMGuestLibHandle handle);\nVMGuestLibError (*GuestLib_GetSessionId)(VMGuestLibHandle handle, VMSessionId *id);\nVMGuestLibError (*GuestLib_GetCpuReservationMHz)(VMGuestLibHandle handle, uint32 *cpuReservationMHz);\nVMGuestLibError (*GuestLib_GetCpuLimitMHz)(VMGuestLibHandle handle, uint32 *cpuLimitMHz);\nVMGuestLibError (*GuestLib_GetCpuShares)(VMGuestLibHandle handle, uint32 *cpuShares);\nVMGuestLibError (*GuestLib_GetCpuUsedMs)(VMGuestLibHandle handle, uint64 *cpuUsedMs);\nVMGuestLibError (*GuestLib_GetHostProcessorSpeed)(VMGuestLibHandle handle, uint32 *mhz);\nVMGuestLibError (*GuestLib_GetMemReservationMB)(VMGuestLibHandle handle, uint32 *memReservationMB);\nVMGuestLibError (*GuestLib_GetMemLimitMB)(VMGuestLibHandle handle, uint32 *memLimitMB);\nVMGuestLibError (*GuestLib_GetMemShares)(VMGuestLibHandle handle, uint32 *memShares);\nVMGuestLibError (*GuestLib_GetMemMappedMB)(VMGuestLibHandle handle, uint32 *memMappedMB);\nVMGuestLibError (*GuestLib_GetMemActiveMB)(VMGuestLibHandle handle, uint32 *memActiveMB);\nVMGuestLibError (*GuestLib_GetMemOverheadMB)(VMGuestLibHandle handle, uint32 *memOverheadMB);\nVMGuestLibError (*GuestLib_GetMemBalloonedMB)(VMGuestLibHandle handle, uint32 *memBalloonedMB);\nVMGuestLibError (*GuestLib_GetMemSwappedMB)(VMGuestLibHandle handle, uint32 *memSwappedMB);\nVMGuestLibError (*GuestLib_GetMemSharedMB)(VMGuestLibHandle handle, uint32 *memSharedMB);\nVMGuestLibError (*GuestLib_GetMemSharedSavedMB)(VMGuestLibHandle handle, uint32 *memSharedSavedMB);\nVMGuestLibError (*GuestLib_GetMemUsedMB)(VMGuestLibHandle handle, uint32 *memUsedMB);\nVMGuestLibError (*GuestLib_GetElapsedMs)(VMGuestLibHandle handle, uint64 *elapsedMs);\nVMGuestLibError (*GuestLib_GetResourcePoolPath)(VMGuestLibHandle handle, size_t *bufferSize, char *pathBuffer);\nVMGuestLibError (*GuestLib_GetCpuStolenMs)(VMGuestLibHandle handle, uint64 *cpuStolenMs);\nVMGuestLibError (*GuestLib_GetMemTargetSizeMB)(VMGuestLibHandle handle, uint64 *memTargetSizeMB);\nVMGuestLibError (*GuestLib_GetHostNumCpuCores)(VMGuestLibHandle handle, uint32 *hostNumCpuCores);\nVMGuestLibError (*GuestLib_GetHostCpuUsedMs)(VMGuestLibHandle handle, uint64 *hostCpuUsedMs);\nVMGuestLibError (*GuestLib_GetHostMemSwappedMB)(VMGuestLibHandle handle, uint64 *hostMemSwappedMB);\nVMGuestLibError (*GuestLib_GetHostMemSharedMB)(VMGuestLibHandle handle, uint64 *hostMemSharedMB);\nVMGuestLibError (*GuestLib_GetHostMemUsedMB)(VMGuestLibHandle handle, uint64 *hostMemUsedMB);\nVMGuestLibError (*GuestLib_GetHostMemPhysMB)(VMGuestLibHandle handle, uint64 *hostMemPhysMB);\nVMGuestLibError (*GuestLib_GetHostMemPhysFreeMB)(VMGuestLibHandle handle, uint64 *hostMemPhysFreeMB);\nVMGuestLibError (*GuestLib_GetHostMemKernOvhdMB)(VMGuestLibHandle handle, uint64 *hostMemKernOvhdMB);\nVMGuestLibError (*GuestLib_GetHostMemMappedMB)(VMGuestLibHandle handle, uint64 *hostMemMappedMB);\nVMGuestLibError (*GuestLib_GetHostMemUnmappedMB)(VMGuestLibHandle handle, uint64 *hostMemUnmappedMB);\n\n\nstatic void *dlHandle = NULL;\n\n\n/*\n * Macro to load a single GuestLib function from the shared library.\n */\n\n#define LOAD_ONE_FUNC(funcname)                                 \\\ndo {                                                            \\\nfuncname = dlsym(dlHandle, \"VM\" #funcname);                     \\\nif ((dlErrStr = dlerror()) != NULL) {                           \\\nfprintf(stderr, \"Failed to load \\'%s\\': \\'%s\\'\\n\",              \\\n#funcname, dlErrStr);                                           \\\nreturn FALSE;                                                   \\\n}                                                               \\\n} while (0)\n\n#endif\n\n/** Holds control flags, usually out-of band configuration of the hardware */\nstruct _vmware_control_state {\n   long long value[VMWARE_MAX_COUNTERS];\n   int which_counter[VMWARE_MAX_COUNTERS];\n   int num_events;\n};\n\n/** Holds per-thread information */\nstruct _vmware_context {\n  long long values[VMWARE_MAX_COUNTERS];\n  long long start_values[VMWARE_MAX_COUNTERS];\n#ifdef VMGUESTLIB\n  VMGuestLibHandle glHandle;\n#endif\n};\n\n\n\n\n\n\n/*\n *-----------------------------------------------------------------------------\n *\n * LoadFunctions --\n *\n *      Load the functions from the shared library.\n *\n * Results:\n *      TRUE on success\n *      FALSE on failure\n *\n * Side effects:\n *      None\n *\n * Credit: VMware\n *-----------------------------------------------------------------------------\n */\n\nstatic int\nLoadFunctions(void)\n{\n\n#ifdef VMGUESTLIB\n\t/*\n\t * First, try to load the shared library.\n\t */\n\n\t/* Attempt to guess if we were statically linked to libc, if so bail */\n\tif ( _dl_non_dynamic_init != NULL ) {\n\t\tstrncpy(_vmware_vector.cmp_info.disabled_reason, \"The VMware component does not support statically linking of libc.\", PAPI_MAX_STR_LEN);\n\t\treturn PAPI_ENOSUPP;\n\t}\n\n\tchar const *dlErrStr;\n\tchar filename[BUFSIZ];\n\n\tsprintf(filename,\"%s\",\"libvmGuestLib.so\");\n\tdlHandle = dlopen(filename, RTLD_NOW);\n\tif (!dlHandle) {\n\t   dlErrStr = dlerror();\n\t   fprintf(stderr, \"dlopen of %s failed: \\'%s\\'\\n\", filename, \n\t\t   dlErrStr);\n\n\t   sprintf(filename,\"%s/lib/lib64/libvmGuestLib.so\",VMWARE_INCDIR);\n\t   dlHandle = dlopen(filename, RTLD_NOW);\n\t   if (!dlHandle) {\n\t      dlErrStr = dlerror();\n\t      fprintf(stderr, \"dlopen of %s failed: \\'%s\\'\\n\", filename, \n\t\t   dlErrStr);\n\n\t      sprintf(filename,\"%s/lib/lib32/libvmGuestLib.so\",VMWARE_INCDIR);\n\t      dlHandle = dlopen(filename, RTLD_NOW);\n\t      if (!dlHandle) {\n\t         dlErrStr = dlerror();\n\t         fprintf(stderr, \"dlopen of %s failed: \\'%s\\'\\n\", filename, \n\t\t      dlErrStr);\n\t\t return PAPI_ECMP;\n\t      }\n\t   }\n\t}\n\n\t/* Load all the individual library functions. */\n\tLOAD_ONE_FUNC(GuestLib_GetErrorText);\n\tLOAD_ONE_FUNC(GuestLib_OpenHandle);\n\tLOAD_ONE_FUNC(GuestLib_CloseHandle);\n\tLOAD_ONE_FUNC(GuestLib_UpdateInfo);\n\tLOAD_ONE_FUNC(GuestLib_GetSessionId);\n\tLOAD_ONE_FUNC(GuestLib_GetCpuReservationMHz);\n\tLOAD_ONE_FUNC(GuestLib_GetCpuLimitMHz);\n\tLOAD_ONE_FUNC(GuestLib_GetCpuShares);\n\tLOAD_ONE_FUNC(GuestLib_GetCpuUsedMs);\n\tLOAD_ONE_FUNC(GuestLib_GetHostProcessorSpeed);\n\tLOAD_ONE_FUNC(GuestLib_GetMemReservationMB);\n\tLOAD_ONE_FUNC(GuestLib_GetMemLimitMB);\n\tLOAD_ONE_FUNC(GuestLib_GetMemShares);\n\tLOAD_ONE_FUNC(GuestLib_GetMemMappedMB);\n\tLOAD_ONE_FUNC(GuestLib_GetMemActiveMB);\n\tLOAD_ONE_FUNC(GuestLib_GetMemOverheadMB);\n\tLOAD_ONE_FUNC(GuestLib_GetMemBalloonedMB);\n\tLOAD_ONE_FUNC(GuestLib_GetMemSwappedMB);\n\tLOAD_ONE_FUNC(GuestLib_GetMemSharedMB);\n\tLOAD_ONE_FUNC(GuestLib_GetMemSharedSavedMB);\n\tLOAD_ONE_FUNC(GuestLib_GetMemUsedMB);\n\tLOAD_ONE_FUNC(GuestLib_GetElapsedMs);\n\tLOAD_ONE_FUNC(GuestLib_GetResourcePoolPath);\n\tLOAD_ONE_FUNC(GuestLib_GetCpuStolenMs);\n\tLOAD_ONE_FUNC(GuestLib_GetMemTargetSizeMB);\n\tLOAD_ONE_FUNC(GuestLib_GetHostNumCpuCores);\n\tLOAD_ONE_FUNC(GuestLib_GetHostCpuUsedMs);\n\tLOAD_ONE_FUNC(GuestLib_GetHostMemSwappedMB);\n\tLOAD_ONE_FUNC(GuestLib_GetHostMemSharedMB);\n\tLOAD_ONE_FUNC(GuestLib_GetHostMemUsedMB);\n\tLOAD_ONE_FUNC(GuestLib_GetHostMemPhysMB);\n\tLOAD_ONE_FUNC(GuestLib_GetHostMemPhysFreeMB);\n\tLOAD_ONE_FUNC(GuestLib_GetHostMemKernOvhdMB);\n\tLOAD_ONE_FUNC(GuestLib_GetHostMemMappedMB);\n\tLOAD_ONE_FUNC(GuestLib_GetHostMemUnmappedMB);\n#endif\n\treturn PAPI_OK;\n}\n\n\n\n/** This table contains the native events */\nstatic struct _vmware_native_event_entry *_vmware_native_table;\n/** number of events in the table*/\nstatic int num_events = 0;\nstatic int use_pseudo=0;\nstatic int use_guestlib=0;\n\n/************************************************************************/\n/* Below is the actual \"hardware implementation\" of our VMWARE counters */\n/************************************************************************/\n\n/** Code that reads event values.\n You might replace this with code that accesses\n hardware or reads values from the operatings system. */\nstatic long long\n_vmware_hardware_read( struct _vmware_context *context, int starting)\n{\n\n  int i;\n\n\tif (use_pseudo) {\n           context->values[VMWARE_HOST_TSC]=rdpmc(0x10000);\n           context->values[VMWARE_ELAPSED_TIME]=rdpmc(0x10001);\n           context->values[VMWARE_ELAPSED_APPARENT]=rdpmc(0x10002);\n\t}\n\n\n#ifdef VMGUESTLIB\n\tstatic VMSessionId sessionId = 0;\n\tVMSessionId tmpSession;\n\tuint32_t temp32;\n\tuint64_t temp64;\n\tVMGuestLibError glError;\n\n\tif (use_guestlib) {\n\n\tglError = GuestLib_UpdateInfo(context->glHandle);\n\tif (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t   fprintf(stderr,\"UpdateInfo failed: %s\\n\", \n\t\t   GuestLib_GetErrorText(glError));\n\t   \t   return PAPI_ECMP;\n\t}\n\n\t/* Retrieve and check the session ID */\n\tglError = GuestLib_GetSessionId(context->glHandle, &tmpSession);\n\tif (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t   fprintf(stderr, \"Failed to get session ID: %s\\n\", \n\t\t   GuestLib_GetErrorText(glError));\n\t   return PAPI_ECMP;\n\t}\n\n\tif (tmpSession == 0) {\n\t   fprintf(stderr, \"Error: Got zero sessionId from GuestLib\\n\");\n\t   return PAPI_ECMP;\n\t}\n\n\tif (sessionId == 0) {\n\t   sessionId = tmpSession;\n\t} else if (tmpSession != sessionId) {\n\t   sessionId = tmpSession;\n\t}\n\n\tglError = GuestLib_GetCpuLimitMHz(context->glHandle,&temp32);\n\tcontext->values[VMWARE_CPU_LIMIT_MHZ]=temp32;\n\tif (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t   fprintf(stderr,\"Failed to get CPU limit: %s\\n\", \n\t\t   GuestLib_GetErrorText(glError));\n\t   return PAPI_ECMP;\n\t}\n\n\tglError = GuestLib_GetCpuReservationMHz(context->glHandle,&temp32); \n\tcontext->values[VMWARE_CPU_RESERVATION_MHZ]=temp32;\n        if (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t   fprintf(stderr,\"Failed to get CPU reservation: %s\\n\", \n\t\t   GuestLib_GetErrorText(glError));\n\t   return PAPI_ECMP;\n\t}\n\t\n\tglError = GuestLib_GetCpuShares(context->glHandle,&temp32);\n\tcontext->values[VMWARE_CPU_SHARES]=temp32;\n\tif (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t   fprintf(stderr,\"Failed to get cpu shares: %s\\n\", \n\t\t   GuestLib_GetErrorText(glError));\n\t   return PAPI_ECMP;\n\t}\n\n\tglError = GuestLib_GetCpuStolenMs(context->glHandle,&temp64);\n\tcontext->values[VMWARE_CPU_STOLEN_MS]=temp64;\n\tif (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t   if (glError == VMGUESTLIB_ERROR_UNSUPPORTED_VERSION) {\n\t      context->values[VMWARE_CPU_STOLEN_MS]=0;\n\t      fprintf(stderr, \"Skipping CPU stolen, not supported...\\n\");\n\t   } else {\n\t      fprintf(stderr, \"Failed to get CPU stolen: %s\\n\", \n\t\t      GuestLib_GetErrorText(glError));\n\t      return PAPI_ECMP;\n\t   }\n\t}\n\n\tglError = GuestLib_GetCpuUsedMs(context->glHandle,&temp64);\n\tcontext->values[VMWARE_CPU_USED_MS]=temp64;\n\tif (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t   fprintf(stderr, \"Failed to get used ms: %s\\n\", \n\t\t   GuestLib_GetErrorText(glError));\n\t   return PAPI_ECMP;\n\t}\n\t\n\tglError = GuestLib_GetElapsedMs(context->glHandle, &temp64);\n\tcontext->values[VMWARE_ELAPSED_MS]=temp64;\n\tif (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t   fprintf(stderr, \"Failed to get elapsed ms: %s\\n\",\n\t\t   GuestLib_GetErrorText(glError));\n\t   return PAPI_ECMP;\n\t}\n\n\tglError = GuestLib_GetMemActiveMB(context->glHandle, &temp32);\n\tcontext->values[VMWARE_MEM_ACTIVE_MB]=temp32;\n\tif (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t   fprintf(stderr, \"Failed to get active mem: %s\\n\", \n\t\t   GuestLib_GetErrorText(glError));\n\t   return PAPI_ECMP;\n\t}\n\t\n\tglError = GuestLib_GetMemBalloonedMB(context->glHandle, &temp32);\n\tcontext->values[VMWARE_MEM_BALLOONED_MB]=temp32;\n\tif (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t   fprintf(stderr, \"Failed to get ballooned mem: %s\\n\", \n\t\t   GuestLib_GetErrorText(glError));\n\t   return PAPI_ECMP;\n\t}\n\t\n\tglError = GuestLib_GetMemLimitMB(context->glHandle, &temp32);\n\tcontext->values[VMWARE_MEM_LIMIT_MB]=temp32;\n\tif (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t   fprintf(stderr,\"Failed to get mem limit: %s\\n\", \n\t\t   GuestLib_GetErrorText(glError));\n\t   return PAPI_ECMP;\n\t}\n\n        glError = GuestLib_GetMemMappedMB(context->glHandle, &temp32);\n\tcontext->values[VMWARE_MEM_MAPPED_MB]=temp32;\n\tif (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t   fprintf(stderr, \"Failed to get mapped mem: %s\\n\", \n\t\t   GuestLib_GetErrorText(glError));\n\t   return PAPI_ECMP;\n\t}\n\n\tglError = GuestLib_GetMemOverheadMB(context->glHandle, &temp32);\n\tcontext->values[VMWARE_MEM_OVERHEAD_MB]=temp32;\n\tif (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t   fprintf(stderr, \"Failed to get overhead mem: %s\\n\", \n\t\t   GuestLib_GetErrorText(glError));\n\t   return PAPI_ECMP;\n\t}\n\n\tglError = GuestLib_GetMemReservationMB(context->glHandle, &temp32);\n\tcontext->values[VMWARE_MEM_RESERVATION_MB]=temp32;\n\tif (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t   fprintf(stderr, \"Failed to get mem reservation: %s\\n\", \n\t\t   GuestLib_GetErrorText(glError));\n\t   return PAPI_ECMP;\n\t}\n\n        glError = GuestLib_GetMemSharedMB(context->glHandle, &temp32);\n\tcontext->values[VMWARE_MEM_SHARED_MB]=temp32;\n\tif (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t   fprintf(stderr, \"Failed to get swapped mem: %s\\n\", \n\t\t   GuestLib_GetErrorText(glError));\n\t   return PAPI_ECMP;\n\t}\n\n\tglError = GuestLib_GetMemShares(context->glHandle, &temp32);\n\tcontext->values[VMWARE_MEM_SHARES]=temp32;\n\tif (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t   if (glError == VMGUESTLIB_ERROR_NOT_AVAILABLE) {\n\t      context->values[VMWARE_MEM_SHARES]=0;\n\t      fprintf(stderr, \"Skipping mem shares, not supported...\\n\");\n\t   } else {\n\t      fprintf(stderr, \"Failed to get mem shares: %s\\n\", \n\t\t      GuestLib_GetErrorText(glError));\n\t      return PAPI_ECMP;\n\t   }\n\t}\n\n\tglError = GuestLib_GetMemSwappedMB(context->glHandle, &temp32);\n\tcontext->values[VMWARE_MEM_SWAPPED_MB]=temp32;\n\tif (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t   fprintf(stderr, \"Failed to get swapped mem: %s\\n\",\n\t\t   GuestLib_GetErrorText(glError));\n\t   return PAPI_ECMP;\n\t}\n\t\n\tglError = GuestLib_GetMemTargetSizeMB(context->glHandle, &temp64);\n\tcontext->values[VMWARE_MEM_TARGET_SIZE_MB]=temp64;\n        if (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t   if (glError == VMGUESTLIB_ERROR_UNSUPPORTED_VERSION) {\n\t      context->values[VMWARE_MEM_TARGET_SIZE_MB]=0;\n\t      fprintf(stderr, \"Skipping target mem size, not supported...\\n\");\n\t   } else {\n\t      fprintf(stderr, \"Failed to get target mem size: %s\\n\", \n\t\t      GuestLib_GetErrorText(glError));\n\t      return PAPI_ECMP;\n\t   }\n\t}\n\n        glError = GuestLib_GetMemUsedMB(context->glHandle, &temp32);\n\tcontext->values[VMWARE_MEM_USED_MB]=temp32;\n\tif (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t   fprintf(stderr, \"Failed to get swapped mem: %s\\n\",\n\t\t   GuestLib_GetErrorText(glError));\n\t   return PAPI_ECMP;\n\t}\n\n        glError = GuestLib_GetHostProcessorSpeed(context->glHandle, &temp32); \n\tcontext->values[VMWARE_HOST_CPU_MHZ]=temp32;\n\tif (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t   fprintf(stderr, \"Failed to get host proc speed: %s\\n\", \n\t\t   GuestLib_GetErrorText(glError));\n\t   return PAPI_ECMP;\n\t}\n\t}\n\n#endif\n\n\tif (starting) {\n\n\t  for(i=0;i<VMWARE_MAX_COUNTERS;i++) {\n\t    context->start_values[i]=context->values[i];\n\t  }\n\n\t}\n\n\treturn PAPI_OK;\n}\n\n/********************************************************************/\n/* Below are the functions required by the PAPI component interface */\n/********************************************************************/\n\n/** This is called whenever a thread is initialized */\nint\n_vmware_init_thread( hwd_context_t *ctx )\n{\n\t(void) ctx;\n\n\n#ifdef VMGUESTLIB\n\n\tstruct _vmware_context *context;\n\tVMGuestLibError glError;\n\n\tcontext=(struct _vmware_context *)ctx;\n\n\tif (use_guestlib) {\n\t   glError = GuestLib_OpenHandle(&(context->glHandle));\n\t   if (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t      fprintf(stderr,\"OpenHandle failed: %s\\n\", \n\t\t   GuestLib_GetErrorText(glError));\n\t      return PAPI_ECMP;\n\t   }\n\t}\n\n#endif\n\n\treturn PAPI_OK;\n}\n\n\n/** Initialize hardware counters, setup the function vector table\n * and get hardware information, this routine is called when the\n * PAPI process is initialized (IE PAPI_library_init)\n */\nint\n_vmware_init_component( int cidx )\n{\n\n  (void) cidx;\n\n  int result;\n\n\tSUBDBG( \"_vmware_init_component...\" );\n\n\t/* Initialize and try to load the VMware library */\n\t/* Try to load the library. */\n\tresult=LoadFunctions();\n\n\tif (result!=PAPI_OK) {\n\t   strncpy(_vmware_vector.cmp_info.disabled_reason,\n\t\t  \"GuestLibTest: Failed to load shared library\",\n\t\t   PAPI_MAX_STR_LEN);\n\t   return PAPI_ECMP;\n\t}\n\n\t/* we know in advance how many events we want                       */\n\t/* for actual hardware this might have to be determined dynamically */\n\n\t/* Allocate memory for the our event table */\n\t_vmware_native_table = ( struct _vmware_native_event_entry * )\n\t  calloc( VMWARE_MAX_COUNTERS, sizeof ( struct _vmware_native_event_entry ));\n\tif ( _vmware_native_table == NULL ) {\n\t   return PAPI_ENOMEM;\n\t}\n\n\n#ifdef VMGUESTLIB\n\n\t/* Detect if GuestLib works */\n\t{\n\n        VMGuestLibError glError;\n        VMGuestLibHandle glHandle;\n\n\tuse_guestlib=0;\n\n\t/* try to open */\n\tglError = GuestLib_OpenHandle(&glHandle);\n\tif (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t   fprintf(stderr,\"OpenHandle failed: %s\\n\", \n\t\t   GuestLib_GetErrorText(glError));\n\t}\n\telse {\n\t   /* open worked, try to update */\n\t   glError = GuestLib_UpdateInfo(glHandle);\n\t   if (glError != VMGUESTLIB_ERROR_SUCCESS) {\n\t      fprintf(stderr,\"UpdateInfo failed: %s\\n\", \n\t\t      GuestLib_GetErrorText(glError));\n\t   }\n\t   else {\n\t      /* update worked, things work! */\n\t      use_guestlib=1;\n\t   }\n\t   /* shut things down */\n\t   glError = GuestLib_CloseHandle(glHandle);\n\t}\n\n        }\n\n\n\n\tif (use_guestlib) {\n\n\t/* fill in the event table parameters */\n\tstrcpy( _vmware_native_table[num_events].name,\n\t\t\"CPU_LIMIT\" );\n\tstrncpy( _vmware_native_table[num_events].description,\n\t\t\"Retrieves the upper limit of processor use in MHz \"\n\t\t\"available to the virtual machine.\",\n\t\tPAPI_HUGE_STR_LEN);\n\tstrcpy( _vmware_native_table[num_events].units,\"MHz\");\n\t_vmware_native_table[num_events].which_counter=\n\t        VMWARE_CPU_LIMIT_MHZ;\n\t_vmware_native_table[num_events].report_difference=0;\n\tnum_events++;\n\n\tstrcpy( _vmware_native_table[num_events].name,\n\t\t\"CPU_RESERVATION\" );\n\tstrncpy( _vmware_native_table[num_events].description,\n\t\t\"Retrieves the minimum processing power in MHz \"\n\t\t\"reserved for the virtual machine.\",\n\t\tPAPI_HUGE_STR_LEN);\n\tstrcpy( _vmware_native_table[num_events].units,\"MHz\");\n\t_vmware_native_table[num_events].which_counter=\n\t        VMWARE_CPU_RESERVATION_MHZ;\n\t_vmware_native_table[num_events].report_difference=0;\n\tnum_events++;\n\n\tstrcpy( _vmware_native_table[num_events].name,\n\t\t\"CPU_SHARES\" );\n\tstrncpy( _vmware_native_table[num_events].description,\n\t\t\"Retrieves the number of CPU shares allocated \"\n\t\t\"to the virtual machine.\",\n\t\tPAPI_HUGE_STR_LEN);\n\tstrcpy( _vmware_native_table[num_events].units,\"shares\");\n\t_vmware_native_table[num_events].which_counter=\n\t        VMWARE_CPU_SHARES;\n\t_vmware_native_table[num_events].report_difference=0;\n\tnum_events++;\n\n\tstrcpy( _vmware_native_table[num_events].name,\n\t\t\"CPU_STOLEN\" );\n\tstrncpy( _vmware_native_table[num_events].description,\n\t\t\"Retrieves the number of milliseconds that the \"\n\t\t\"virtual machine was in a ready state (able to \"\n\t\t\"transition to a run state), but was not scheduled to run.\",\n\t\tPAPI_HUGE_STR_LEN);\n\tstrcpy( _vmware_native_table[num_events].units,\"ms\");\n\t_vmware_native_table[num_events].which_counter=\n\t        VMWARE_CPU_STOLEN_MS;\n\t_vmware_native_table[num_events].report_difference=0;\n\tnum_events++;\n\n\tstrcpy( _vmware_native_table[num_events].name,\n\t\t\"CPU_USED\" );\n\tstrncpy( _vmware_native_table[num_events].description,\n\t\t\"Retrieves the number of milliseconds during which \"\n\t\t\"the virtual machine has used the CPU. This value \"\n\t\t\"includes the time used by the guest operating system \"\n\t\t\"and the time used by virtualization code for tasks for \"\n\t\t\"this virtual machine. You can combine this value with \"\n\t\t\"the elapsed time (VMWARE_ELAPSED) to estimate the \"\n\t\t\"effective virtual machine CPU speed. This value is a \"\n\t\t\"subset of elapsedMs.\",\n\t\tPAPI_HUGE_STR_LEN );\n\tstrcpy( _vmware_native_table[num_events].units,\"ms\");\n\t_vmware_native_table[num_events].which_counter=\n\t        VMWARE_CPU_USED_MS;\n\t_vmware_native_table[num_events].report_difference=1;\n\tnum_events++;\n\n\tstrcpy( _vmware_native_table[num_events].name,\n\t\t\"ELAPSED\" );\n\tstrncpy( _vmware_native_table[num_events].description,\n\t\t\"Retrieves the number of milliseconds that have passed \"\n\t\t\"in the virtual machine since it last started running on \"\n\t\t\"the server. The count of elapsed time restarts each time \"\n\t\t\"the virtual machine is powered on, resumed, or migrated \"\n\t\t\"using VMotion. This value counts milliseconds, regardless \"\n\t\t\"of whether the virtual machine is using processing power \"\n\t\t\"during that time. You can combine this value with the CPU \"\n\t\t\"time used by the virtual machine (VMWARE_CPU_USED) to \"\n\t\t\"estimate the effective virtual machine xCPU speed. \"\n\t\t\"cpuUsedMS is a subset of this value.\",\n\t\tPAPI_HUGE_STR_LEN );\n\tstrcpy( _vmware_native_table[num_events].units,\"ms\");\n\t_vmware_native_table[num_events].which_counter=\n\t        VMWARE_ELAPSED_MS;\n\t_vmware_native_table[num_events].report_difference=1;\n\tnum_events++;\n\n\tstrcpy( _vmware_native_table[num_events].name,\n\t\t\"MEM_ACTIVE\" );\n\tstrncpy( _vmware_native_table[num_events].description,\n\t\t \"Retrieves the amount of memory the virtual machine is \"\n\t\t \"actively using in MB - Its estimated working set size.\",\n\t\t PAPI_HUGE_STR_LEN );\n\tstrcpy( _vmware_native_table[num_events].units,\"MB\");\n\t_vmware_native_table[num_events].which_counter=\n                 VMWARE_MEM_ACTIVE_MB;\n\t_vmware_native_table[num_events].report_difference=0;\n\tnum_events++;\n\n\tstrcpy( _vmware_native_table[num_events].name,\n\t\t\"MEM_BALLOONED\" );\n\tstrncpy( _vmware_native_table[num_events].description,\n\t\t\"Retrieves the amount of memory that has been reclaimed \"\n\t\t\"from this virtual machine by the vSphere memory balloon \"\n\t\t\"driver (also referred to as the 'vmemctl' driver) in MB.\",\n\t\tPAPI_HUGE_STR_LEN );\n\tstrcpy( _vmware_native_table[num_events].units,\"MB\");\n\t_vmware_native_table[num_events].which_counter=\n\t        VMWARE_MEM_BALLOONED_MB;\n\t_vmware_native_table[num_events].report_difference=0;\n\tnum_events++;\n\n\tstrcpy( _vmware_native_table[num_events].name,\n\t\t\"MEM_LIMIT\" );\n\tstrncpy( _vmware_native_table[num_events].description,\n\t\t\"Retrieves the upper limit of memory that is available \"\n\t\t\"to the virtual machine in MB.\",\n\t\tPAPI_HUGE_STR_LEN );\n\tstrcpy( _vmware_native_table[num_events].units,\"MB\");\n\t_vmware_native_table[num_events].which_counter=\n\t        VMWARE_MEM_LIMIT_MB;\n\t_vmware_native_table[num_events].report_difference=0;\n\tnum_events++;\n\n\tstrcpy( _vmware_native_table[num_events].name,\n\t\t\"MEM_MAPPED\" );\n\tstrncpy( _vmware_native_table[num_events].description,\n\t\t\"Retrieves the amount of memory that is allocated to \"\n\t\t\"the virtual machine in MB. Memory that is ballooned, \"\n\t\t\"swapped, or has never been accessed is excluded.\",\n\t\tPAPI_HUGE_STR_LEN );\n\tstrcpy( _vmware_native_table[num_events].units,\"MB\");\n\t_vmware_native_table[num_events].which_counter=\n\t        VMWARE_MEM_MAPPED_MB;\n\t_vmware_native_table[num_events].report_difference=0;\n\tnum_events++;\n\n\tstrcpy( _vmware_native_table[num_events].name,\n\t\t\"MEM_OVERHEAD\" );\n\tstrncpy( _vmware_native_table[num_events].description,\n\t\t\"Retrieves the amount of 'overhead' memory associated \"\n\t\t\"with this virtual machine that is currently consumed \"\n\t\t\"on the host system in MB. Overhead memory is additional \"\n\t\t\"memory that is reserved for data structures required by \"\n\t\t\"the virtualization layer.\",\n\t\tPAPI_HUGE_STR_LEN );\n\tstrcpy( _vmware_native_table[num_events].units,\"MB\");\n\t_vmware_native_table[num_events].which_counter=\n\t        VMWARE_MEM_OVERHEAD_MB;\n\t_vmware_native_table[num_events].report_difference=0;\n\tnum_events++;\n\n\tstrcpy( _vmware_native_table[num_events].name,\n\t\t\"MEM_RESERVATION\" );\n\tstrncpy( _vmware_native_table[num_events].description,\n\t\t\"Retrieves the minimum amount of memory that is \"\n\t\t\"reserved for the virtual machine in MB.\",\n\t\tPAPI_HUGE_STR_LEN );\n\tstrcpy( _vmware_native_table[num_events].units,\"MB\");\n\t_vmware_native_table[num_events].which_counter=\n\t        VMWARE_MEM_RESERVATION_MB;\n\t_vmware_native_table[num_events].report_difference=0;\n\tnum_events++;\n\n\tstrcpy( _vmware_native_table[num_events].name,\n\t\t\"MEM_SHARED\" );\n\tstrncpy( _vmware_native_table[num_events].description,\n\t\t\"Retrieves the amount of physical memory associated \"\n\t\t\"with this virtual machine that is copy-on-write (COW) \"\n\t\t\"shared on the host in MB.\",\n\t\tPAPI_HUGE_STR_LEN );\n\tstrcpy( _vmware_native_table[num_events].units,\"MB\");\n\t_vmware_native_table[num_events].which_counter=\n\t        VMWARE_MEM_SHARED_MB;\n\t_vmware_native_table[num_events].report_difference=0;\n\tnum_events++;\n\n\tstrcpy( _vmware_native_table[num_events].name,\n\t\t\"MEM_SHARES\" );\n\tstrncpy( _vmware_native_table[num_events].description,\n\t\t\"Retrieves the number of memory shares allocated to \"\n\t\t\"the virtual machine.\",\n\t\tPAPI_HUGE_STR_LEN );\n\tstrcpy( _vmware_native_table[num_events].units,\"shares\");\n\t_vmware_native_table[num_events].which_counter=\n\t        VMWARE_MEM_SHARES;\n\t_vmware_native_table[num_events].report_difference=0;\n\tnum_events++;\n\n\tstrcpy( _vmware_native_table[num_events].name,\n\t\t\"MEM_SWAPPED\" );\n\tstrncpy( _vmware_native_table[num_events].description,\n\t\t\"Retrieves the amount of memory that has been reclaimed \"\n\t\t\"from this virtual machine by transparently swapping \"\n\t\t\"guest memory to disk in MB.\",\n\t\tPAPI_HUGE_STR_LEN );\n\tstrcpy( _vmware_native_table[num_events].units,\"MB\");\n\t_vmware_native_table[num_events].which_counter=\n\t        VMWARE_MEM_SWAPPED_MB;\n\t_vmware_native_table[num_events].report_difference=0;\n\tnum_events++;\n\n\tstrcpy( _vmware_native_table[num_events].name,\n\t\t\"MEM_TARGET_SIZE\" );\n\tstrncpy( _vmware_native_table[num_events].description,\n\t\t\"Retrieves the size of the target memory allocation \"\n\t\t\"for this virtual machine in MB.\",\n\t\tPAPI_HUGE_STR_LEN );\n\tstrcpy( _vmware_native_table[num_events].units,\"MB\");\n\t_vmware_native_table[num_events].which_counter=\n\t        VMWARE_MEM_TARGET_SIZE_MB;\n\t_vmware_native_table[num_events].report_difference=0;\n\tnum_events++;\n\n\tstrcpy( _vmware_native_table[num_events].name,\n\t\t\"MEM_USED\" );\n\tstrncpy( _vmware_native_table[num_events].description,\n\t\t\"Retrieves the estimated amount of physical host memory \"\n\t\t\"currently consumed for this virtual machine's \"\n\t\t\"physical memory.\",\n\t\tPAPI_HUGE_STR_LEN );\n\tstrcpy( _vmware_native_table[num_events].units,\"MB\");\n\t_vmware_native_table[num_events].which_counter=\n\t        VMWARE_MEM_USED_MB;\n\t_vmware_native_table[num_events].report_difference=0;\n\tnum_events++;\n\n\tstrcpy( _vmware_native_table[num_events].name,\n\t\t\"HOST_CPU\" );\n\tstrncpy( _vmware_native_table[num_events].description,\n\t\t\"Retrieves the speed of the ESX system's physical \"\n\t\t\"CPU in MHz.\",\n\t\tPAPI_HUGE_STR_LEN );\n\tstrcpy( _vmware_native_table[num_events].units,\"MHz\");\n\t_vmware_native_table[num_events].which_counter=\n\t        VMWARE_HOST_CPU_MHZ;\n\t_vmware_native_table[num_events].report_difference=0;\n\tnum_events++;\n\t}\n\n#endif\n\n\t/* For VMWare Pseudo Performance Counters */\n\tif ( getenv( \"PAPI_VMWARE_PSEUDOPERFORMANCE\" ) ) {\n\n\t        use_pseudo=1;\n\n\t\tstrcpy( _vmware_native_table[num_events].name,\n\t\t\t\"HOST_TSC\" );\n\t\tstrncpy( _vmware_native_table[num_events].description,\n\t\t\t\"Physical host TSC\",\n\t\t\tPAPI_HUGE_STR_LEN );\n\t\tstrcpy( _vmware_native_table[num_events].units,\"cycles\");\n\t\t_vmware_native_table[num_events].which_counter=\n\t\t        VMWARE_HOST_TSC;\n\t        _vmware_native_table[num_events].report_difference=1;\n\t\tnum_events++;\n\n\t\tstrcpy( _vmware_native_table[num_events].name,\n\t\t\t\"ELAPSED_TIME\" );\n\t\tstrncpy( _vmware_native_table[num_events].description,\n\t\t\t\"Elapsed real time in ns.\",\n\t\t\tPAPI_HUGE_STR_LEN );\n\t        strcpy( _vmware_native_table[num_events].units,\"ns\");\n\t\t_vmware_native_table[num_events].which_counter=\n\t\t        VMWARE_ELAPSED_TIME;\n\t        _vmware_native_table[num_events].report_difference=1;\n\t\tnum_events++;\n\n\t\tstrcpy( _vmware_native_table[num_events].name,\n\t\t\t\"ELAPSED_APPARENT\" );\n\t\tstrncpy( _vmware_native_table[num_events].description,\n\t\t\t\"Elapsed apparent time in ns.\",\n\t\t\tPAPI_HUGE_STR_LEN );\n\t        strcpy( _vmware_native_table[num_events].units,\"ns\");\n\t\t_vmware_native_table[num_events].which_counter=\n\t\t        VMWARE_ELAPSED_APPARENT;\n\t        _vmware_native_table[num_events].report_difference=1;\n\t\tnum_events++;\n\t}\n\n\tif (num_events==0) {\n\t   strncpy(_vmware_vector.cmp_info.disabled_reason,\n\t\t  \"VMware SDK not installed, and PAPI_VMWARE_PSEUDOPERFORMANCE not set\",\n\t\t   PAPI_MAX_STR_LEN);\n\t  return PAPI_ECMP;\n\t}\n\n\t_vmware_vector.cmp_info.num_native_events = num_events;\n\n\treturn PAPI_OK;\n}\n\n/** Setup the counter control structure */\nint\n_vmware_init_control_state( hwd_control_state_t *ctl )\n{\n  (void) ctl;\n\n\treturn PAPI_OK;\n}\n\n/** Enumerate Native Events \n @param EventCode is the event of interest\n @param modifier is one of PAPI_ENUM_FIRST, PAPI_ENUM_EVENTS\n */\nint\n_vmware_ntv_enum_events( unsigned int *EventCode, int modifier )\n{\n\n\tswitch ( modifier ) {\n\t\t\t/* return EventCode of first event */\n\t\tcase PAPI_ENUM_FIRST:\n\t\t     if (num_events==0) return PAPI_ENOEVNT;\n\t\t     *EventCode = 0;\n\t\t     return PAPI_OK;\n\t\t     break;\n\t\t\t/* return EventCode of passed-in Event */\n\t\tcase PAPI_ENUM_EVENTS:{\n\t\t     int index = *EventCode;\n\n\t\t     if ( index < num_events - 1 ) {\n\t\t\t*EventCode = *EventCode + 1;\n\t\t\treturn PAPI_OK;\n\t\t     } else {\n\t\t\treturn PAPI_ENOEVNT;\n\t\t     }\n\t\t     break;\n\t\t}\n\t\tdefault:\n\t\t     return PAPI_EINVAL;\n\t}\n\treturn PAPI_EINVAL;\n}\n\nint\n_vmware_ntv_code_to_info(unsigned int EventCode, PAPI_event_info_t *info) \n{\n\n  int index = EventCode;\n\n  if ( ( index < 0) || (index >= num_events )) return PAPI_ENOEVNT;\n\n  strncpy( info->symbol, _vmware_native_table[index].name, \n           sizeof(info->symbol));\n\n  strncpy( info->long_descr, _vmware_native_table[index].description, \n           sizeof(info->symbol));\n\n  strncpy( info->units, _vmware_native_table[index].units, \n           sizeof(info->units));\n\n  return PAPI_OK;\n}\n\n\n/** Takes a native event code and passes back the name \n @param EventCode is the native event code\n @param name is a pointer for the name to be copied to\n @param len is the size of the string\n */\nint\n_vmware_ntv_code_to_name( unsigned int EventCode, char *name, int len )\n{\n\tint index = EventCode;\n\n\tif ( index >= 0 && index < num_events ) {\n\t   strncpy( name, _vmware_native_table[index].name, len );\n\t}\n\treturn PAPI_OK;\n}\n\n/** Takes a native event code and passes back the event description\n @param EventCode is the native event code\n @param name is a pointer for the description to be copied to\n @param len is the size of the string\n */\nint\n_vmware_ntv_code_to_descr( unsigned int EventCode, char *name, int len )\n{\n  int index = EventCode;\n\n\tif ( index >= 0 && index < num_events ) {\n\t   strncpy( name, _vmware_native_table[index].description, len );\n\t}\n\treturn PAPI_OK;\n}\n\n/** Triggered by eventset operations like add or remove */\nint\n_vmware_update_control_state( hwd_control_state_t *ctl, \n\t\t\t      NativeInfo_t *native, \n\t\t\t      int count, \n\t\t\t      hwd_context_t *ctx )\n{\n\t(void) ctx;\n\n\tstruct _vmware_control_state *control;\n\n\tint i, index;\n\n\tcontrol=(struct _vmware_control_state *)ctl;\n\n\tfor ( i = 0; i < count; i++ ) {\n\t    index = native[i].ni_event;\n\t    control->which_counter[i]=_vmware_native_table[index].which_counter;\n\t    native[i].ni_position = i;\n\t}\n\tcontrol->num_events=count;\n\n\treturn PAPI_OK;\n}\n\n/** Triggered by PAPI_start() */\nint\n_vmware_start( hwd_context_t *ctx, hwd_control_state_t *ctl )\n{\n\tstruct _vmware_context *context;\n\t(void) ctl;\n\n\tcontext=(struct _vmware_context *)ctx;\n\n\t_vmware_hardware_read( context, 1 );\n\n\treturn PAPI_OK;\n}\n\n/** Triggered by PAPI_stop() */\nint\n_vmware_stop( hwd_context_t *ctx, hwd_control_state_t *ctl )\n{\n\n\tstruct _vmware_context *context;\n\t(void) ctl;\n\n\tcontext=(struct _vmware_context *)ctx;\n\n\t_vmware_hardware_read( context, 0 );\t\n\n\treturn PAPI_OK;\n}\n\n/** Triggered by PAPI_read() */\nint\n_vmware_read( hwd_context_t *ctx, \n\t      hwd_control_state_t *ctl,\n\t      long_long **events, int flags )\n{\n\n\tstruct _vmware_context *context;\n\tstruct _vmware_control_state *control;\n\n\t(void) flags;\n\tint i;\n\n\tcontext=(struct _vmware_context *)ctx;\n\tcontrol=(struct _vmware_control_state *)ctl;\n\n\t_vmware_hardware_read( context, 0 );\n\n\tfor (i=0; i<control->num_events; i++) {\n\t  \n\t  if (_vmware_native_table[\n              _vmware_native_table[control->which_counter[i]].which_counter].\n             report_difference) {\n\t     control->value[i]=context->values[control->which_counter[i]]-\n\t                       context->start_values[control->which_counter[i]];\n\t  } else {\n\t     control->value[i]=context->values[control->which_counter[i]];\n\t  }\n\t  //\t  printf(\"%d %d %lld-%lld=%lld\\n\",i,control->which_counter[i],\n\t  // context->values[control->which_counter[i]],\n\t  //\t context->start_values[control->which_counter[i]],\n\t  //\t control->value[i]);\n\n\t}\n\n\t*events = control->value;\n\n\treturn PAPI_OK;\n}\n\n/** Triggered by PAPI_write(), but only if the counters are running */\n/*    otherwise, the updated state is written to ESI->hw_start      */\nint\n_vmware_write( hwd_context_t * ctx, hwd_control_state_t * ctrl, long_long events[] )\n{\n\t(void) ctx;\n\t(void) ctrl;\n\t(void) events;\n\tSUBDBG( \"_vmware_write... %p %p\", ctx, ctrl );\n\t/* FIXME... this should actually carry out the write, though     */\n\t/*  this is non-trivial as which counter being written has to be */\n\t/*  determined somehow.                                          */\n\treturn PAPI_OK;\n}\n\n/** Triggered by PAPI_reset */\nint\n_vmware_reset( hwd_context_t *ctx, hwd_control_state_t *ctl )\n{\n\t(void) ctx;\n\t(void) ctl;\n\n\treturn PAPI_OK;\n}\n\n/** Shutting down a context */\nint\n_vmware_shutdown_thread( hwd_context_t *ctx )\n{\n\t(void) ctx;\n\n#ifdef VMGUESTLIB\n        VMGuestLibError glError;\n\tstruct _vmware_context *context;\n\n\tcontext=(struct _vmware_context *)ctx;\n\n\tif (use_guestlib) {\n           glError = GuestLib_CloseHandle(context->glHandle);\n           if (glError != VMGUESTLIB_ERROR_SUCCESS) {\n               fprintf(stderr, \"Failed to CloseHandle: %s\\n\", \n\t\t       GuestLib_GetErrorText(glError));\n               return PAPI_ECMP;\n\t   }\n\t}\n#endif\n\n\treturn PAPI_OK;\n}\n\n/** Triggered by PAPI_shutdown() */\nint\n_vmware_shutdown_component( void )\n{\n\n#ifdef VMGUESTLIB\n\tif (dlclose(dlHandle)) {\n\t\tfprintf(stderr, \"dlclose failed\\n\");\n\t\treturn EXIT_FAILURE;\n\t}\n#endif\n\n\treturn PAPI_OK;\n}\n\n\n/** This function sets various options in the component\n @param ctx\n @param code valid are PAPI_SET_DEFDOM, PAPI_SET_DOMAIN, PAPI_SETDEFGRN, PAPI_SET_GRANUL and PAPI_SET_INHERIT\n @param option\n */\nint\n_vmware_ctl( hwd_context_t *ctx, int code, _papi_int_option_t *option )\n{\n\n\t(void) ctx;\n\t(void) code;\n\t(void) option;\n\n\tSUBDBG( \"_vmware_ctl...\" );\n\n\treturn PAPI_OK;\n}\n\n/** This function has to set the bits needed to count different domains\n In particular: PAPI_DOM_USER, PAPI_DOM_KERNEL PAPI_DOM_OTHER\n By default return PAPI_EINVAL if none of those are specified\n and PAPI_OK with success\n PAPI_DOM_USER is only user context is counted\n PAPI_DOM_KERNEL is only the Kernel/OS context is counted\n PAPI_DOM_OTHER  is Exception/transient mode (like user TLB misses)\n PAPI_DOM_ALL   is all of the domains\n */\nint\n_vmware_set_domain( hwd_control_state_t *ctl, int domain )\n{\n\t(void) ctl;\n\n\tint found = 0;\n\tSUBDBG( \"_vmware_set_domain...\" );\n\tif ( PAPI_DOM_USER & domain ) {\n\t\tSUBDBG( \" PAPI_DOM_USER \" );\n\t\tfound = 1;\n\t}\n\tif ( PAPI_DOM_KERNEL & domain ) {\n\t\tSUBDBG( \" PAPI_DOM_KERNEL \" );\n\t\tfound = 1;\n\t}\n\tif ( PAPI_DOM_OTHER & domain ) {\n\t\tSUBDBG( \" PAPI_DOM_OTHER \" );\n\t\tfound = 1;\n\t}\n\tif ( PAPI_DOM_ALL & domain ) {\n\t\tSUBDBG( \" PAPI_DOM_ALL \" );\n\t\tfound = 1;\n\t}\n\tif ( !found ) {\n\t\treturn ( PAPI_EINVAL );\n\t}\n\treturn PAPI_OK;\n}\n\n/** Vector that points to entry points for our component */\npapi_vector_t _vmware_vector = {\n\t.cmp_info = {\n\t\t/* default component information (unspecified values are initialized to 0) */\n\t\t.name = \"vmware\",\n\t\t.short_name = \"vmware\",\n\t\t.description = \"Provide support for VMware vmguest and pseudo counters\",\n\t\t.version = \"5.0\",\n\t\t.num_mpx_cntrs = VMWARE_MAX_COUNTERS,\n\t\t.num_cntrs = VMWARE_MAX_COUNTERS,\n\t\t.default_domain = PAPI_DOM_USER,\n\t\t.available_domains = PAPI_DOM_USER,\n\t\t.default_granularity = PAPI_GRN_THR,\n\t\t.available_granularities = PAPI_GRN_THR,\n\t\t.hardware_intr_sig = PAPI_INT_SIGNAL,\n\n\t\t/* component specific cmp_info initializations */\n\t\t.fast_real_timer = 0,\n\t\t.fast_virtual_timer = 0,\n\t\t.attach = 0,\n\t\t.attach_must_ptrace = 0,\n\t},\n\t/* sizes of framework-opaque component-private structures */\n\t.size = {\n\t\t.context = sizeof ( struct _vmware_context ),\n\t\t.control_state = sizeof ( struct _vmware_control_state ),\n\t\t.reg_value = sizeof ( struct _vmware_register ),\n\t\t.reg_alloc = sizeof ( struct _vmware_reg_alloc ),\n\t}\n\t,\n\t/* function pointers in this component */\n\t.init_thread =        _vmware_init_thread,\n\t.init_component =     _vmware_init_component,\n\t.init_control_state = _vmware_init_control_state,\n\t.start =              _vmware_start,\n\t.stop =               _vmware_stop,\n\t.read =               _vmware_read,\n\t.write =              _vmware_write,\n\t.shutdown_thread =    _vmware_shutdown_thread,\n\t.shutdown_component = _vmware_shutdown_component,\n\t.ctl =                _vmware_ctl,\n\n\t.update_control_state = _vmware_update_control_state,\n\t.set_domain = _vmware_set_domain,\n\t.reset = _vmware_reset,\n\n\t.ntv_enum_events = _vmware_ntv_enum_events,\n\t.ntv_code_to_name = _vmware_ntv_code_to_name,\n\t.ntv_code_to_descr = _vmware_ntv_code_to_descr,\n\t.ntv_code_to_info = _vmware_ntv_code_to_info,\n\n};\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-papi-6.0.0.1-gmm3tef6bggycxgzrtmq2ejaggc2ozfb/spack-src/src/components/sde/tests/Created_Counter/Lib_With_Created_Counter.c": "#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include \"papi_sde_interface.h\"\n\n#define MY_EPSILON 0.0001\n\nstatic const char *event_names[1] = {\n    \"epsilon_count\"\n};\n\nvoid *cntr_handle;\n\n// API functions.\nvoid cclib_init(void);\nvoid cclib_do_work(void);\nvoid cclib_do_more_work(void);\n\nvoid cclib_init(void){\n    papi_handle_t sde_handle;\n\n    sde_handle = papi_sde_init(\"Lib_With_CC\");\n    papi_sde_create_counter(sde_handle, event_names[0], PAPI_SDE_DELTA, &cntr_handle);\n\n    return;\n}\n\nvoid cclib_do_work(void){\n    int i;\n\n    for(i=0; i<100*1000; i++){\n        double r = (double)random() / (double)RAND_MAX;\n        if( r < MY_EPSILON ){\n            papi_sde_inc_counter(cntr_handle, 1);\n        }\n        // Do some usefull work here\n        if( !(i%100) )\n            (void)usleep(1);\n    }\n\n    return;\n}\n\nvoid cclib_do_more_work(void){\n    int i;\n\n    for(i=0; i<500*1000; i++){\n        double r = (double)random() / (double)RAND_MAX;\n        if( r < MY_EPSILON ){\n            papi_sde_inc_counter(cntr_handle, 1);\n        }\n        // Do some usefull work here\n        if( !(i%20) )\n            (void)usleep(1);\n    }\n\n    return;\n}\n\n// Hook for papi_native_avail utility. No user code which links against this library should call\n// this function because it has the same name in all SDE-enabled libraries. papi_native_avail\n// uses dlopen and dlclose on each library so it only has one version of this symbol at a time.\npapi_handle_t papi_sde_hook_list_events( papi_sde_fptr_struct_t *fptr_struct){\n    papi_handle_t sde_handle;\n    sde_handle = fptr_struct->init(\"Lib_With_CC\");\n    fptr_struct->create_counter(sde_handle, event_names[0], PAPI_SDE_DELTA, &cntr_handle);\n    fptr_struct->describe_counter(sde_handle, event_names[0], \"Number of times the random value was less than 0.0001\");\n    return sde_handle;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-papi-6.0.0.1-gmm3tef6bggycxgzrtmq2ejaggc2ozfb/spack-src/src/components/sde/tests/Recorder/Lib_With_Recorder.c": "#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include \"papi_sde_interface.h\"\n\nstatic const char *event_names[1] = {\n    \"simple_recording\"\n};\n\nvoid *rcrd_handle;\n\n// API functions.\nvoid recorder_init_(void);\nvoid recorder_do_work_(void);\n\nvoid recorder_init_(void){\n    papi_handle_t tmp_handle;\n\n    tmp_handle = papi_sde_init(\"Lib_With_Recorder\");\n    papi_sde_create_recorder(tmp_handle, event_names[0], sizeof(long long), papi_sde_compare_long_long, &rcrd_handle);\n\n    return;\n}\n\nvoid recorder_do_work_(void){\n    long long r = random()%123456;\n    papi_sde_record(rcrd_handle, sizeof(r), &r);\n    return;\n}\n\n// Hook for papi_native_avail utility. No user code which links against this library should call\n// this function because it has the same name in all SDE-enabled libraries. papi_native_avail\n// uses dlopen and dlclose on each library so it only has one version of this symbol at a time.\npapi_handle_t papi_sde_hook_list_events( papi_sde_fptr_struct_t *fptr_struct){\n    papi_handle_t tmp_handle;\n    tmp_handle = fptr_struct->init(\"Lib_With_Recorder\");\n    fptr_struct->create_recorder(tmp_handle, event_names[0], sizeof(long long), papi_sde_compare_long_long, &rcrd_handle);\n    return tmp_handle;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-papi-6.0.0.1-gmm3tef6bggycxgzrtmq2ejaggc2ozfb/spack-src/src/components/nvml/linux-nvml.c": "/****************************\nTHIS IS OPEN SOURCE CODE\n\nPart of the PAPI software library. Copyright (c) 2005 - 2017,\nInnovative Computing Laboratory, Dept of Electrical Engineering &\nComputer Science University of Tennessee, Knoxville, TN.\n\nThe open source software license conforms to the 2-clause BSD License\ntemplate.\n\n****************************/\n\n/**\n * @file    linux-nvml.c\n * @author  Kiran Kumar Kasichayanula\n *          kkasicha@utk.edu\n * @author  James Ralph\n *          ralph@eecs.utk.edu\n * @ingroup papi_components\n *\n * @brief This is an NVML component, it demos the component interface\n *  and implements a number of counters from the Nvidia Management\n *  Library. Please refer to NVML documentation for details about\n *  nvmlDeviceGetPowerUsage, nvmlDeviceGetTemperature. Power is\n *  reported in mW and temperature in Celcius.  The counter\n *  descriptions should contain the units that the measurement\n *  returns.\n */\n#include <dlfcn.h>\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <inttypes.h>\n#include <string.h>\n/* Headers required by PAPI */\n#include \"papi.h\"\n#include \"papi_internal.h\"\n#include \"papi_vector.h\"\n#include \"papi_memory.h\"\n\n#include \"linux-nvml.h\"\n\n#include \"nvml.h\"\n#include \"cuda.h\"\n#include \"cuda_runtime_api.h\"\n\nvoid (*_dl_non_dynamic_init)(void) __attribute__((weak));\n\n/*****  CHANGE PROTOTYPES TO DECLARE CUDA AND NVML LIBRARY SYMBOLS AS WEAK  *****\n *  This is done so that a version of PAPI built with the nvml component can    *\n *  be installed on a system which does not have the cuda libraries installed.  *\n *                                                                              *\n *  If this is done without these prototypes, then all papi services on the     *\n *  system without the cuda libraries installed will fail.  The PAPI libraries  *\n *  contain references to the cuda libraries which are not installed.  The      *\n *  load of PAPI commands fails because the cuda library references can not be  *\n *  resolved.                                                                   *\n *                                                                              *\n *  This also defines pointers to the cuda library functions that we call.      *\n *  These function pointers will be resolved with dlopen/dlsym calls at         *\n *  component initialization time.  The component then calls the cuda library   *\n *  functions through these function pointers.                                  *\n ********************************************************************************/\n#undef CUDAAPI\n#define CUDAAPI __attribute__((weak))\nCUresult CUDAAPI cuInit(unsigned int);\n\nCUresult(*cuInitPtr)(unsigned int);\n\n#undef CUDARTAPI\n#define CUDARTAPI __attribute__((weak))\ncudaError_t CUDARTAPI cudaGetDevice(int *);\ncudaError_t CUDARTAPI cudaGetDeviceCount(int *);\ncudaError_t CUDARTAPI cudaDeviceGetPCIBusId(char *, int, int);\n\ncudaError_t (*cudaGetDevicePtr)(int *);\ncudaError_t (*cudaGetDeviceCountPtr)(int *);\ncudaError_t (*cudaDeviceGetPCIBusIdPtr)(char *, int, int);\n\n#undef DECLDIR\n#define DECLDIR __attribute__((weak))\nnvmlReturn_t DECLDIR nvmlDeviceGetClockInfo(nvmlDevice_t, nvmlClockType_t, unsigned int *);\nconst char*  DECLDIR nvmlErrorString(nvmlReturn_t);\nnvmlReturn_t DECLDIR nvmlDeviceGetDetailedEccErrors(nvmlDevice_t, nvmlEccBitType_t, nvmlEccCounterType_t, nvmlEccErrorCounts_t *);\nnvmlReturn_t DECLDIR nvmlDeviceGetFanSpeed(nvmlDevice_t, unsigned int *);\nnvmlReturn_t DECLDIR nvmlDeviceGetMemoryInfo(nvmlDevice_t, nvmlMemory_t *);\nnvmlReturn_t DECLDIR nvmlDeviceGetPerformanceState(nvmlDevice_t, nvmlPstates_t *);\nnvmlReturn_t DECLDIR nvmlDeviceGetPowerUsage(nvmlDevice_t, unsigned int *);\nnvmlReturn_t DECLDIR nvmlDeviceGetTemperature(nvmlDevice_t, nvmlTemperatureSensors_t, unsigned int *);\nnvmlReturn_t DECLDIR nvmlDeviceGetTotalEccErrors(nvmlDevice_t, nvmlEccBitType_t, nvmlEccCounterType_t, unsigned long long *);\nnvmlReturn_t DECLDIR nvmlDeviceGetUtilizationRates(nvmlDevice_t, nvmlUtilization_t *);\nnvmlReturn_t DECLDIR nvmlDeviceGetHandleByIndex(unsigned int, nvmlDevice_t *);\nnvmlReturn_t DECLDIR nvmlDeviceGetPciInfo(nvmlDevice_t, nvmlPciInfo_t *);\nnvmlReturn_t DECLDIR nvmlDeviceGetName(nvmlDevice_t, char *, unsigned int);\nnvmlReturn_t DECLDIR nvmlDeviceGetInforomVersion(nvmlDevice_t, nvmlInforomObject_t, char *, unsigned int);\nnvmlReturn_t DECLDIR nvmlDeviceGetEccMode(nvmlDevice_t, nvmlEnableState_t *, nvmlEnableState_t *);\nnvmlReturn_t DECLDIR nvmlInit(void);\nnvmlReturn_t DECLDIR nvmlDeviceGetCount(unsigned int *);\nnvmlReturn_t DECLDIR nvmlShutdown(void);\nnvmlReturn_t DECLDIR nvmlDeviceGetPowerManagementLimit(nvmlDevice_t device, unsigned int* limit);\nnvmlReturn_t DECLDIR nvmlDeviceSetPowerManagementLimit(nvmlDevice_t device, unsigned int  limit);\nnvmlReturn_t DECLDIR nvmlDeviceGetPowerManagementLimitConstraints(nvmlDevice_t device, unsigned int* minLimit, unsigned int* maxLimit);\n\nnvmlReturn_t (*nvmlDeviceGetClockInfoPtr)(nvmlDevice_t, nvmlClockType_t, unsigned int *);\nchar* (*nvmlErrorStringPtr)(nvmlReturn_t);\nnvmlReturn_t (*nvmlDeviceGetDetailedEccErrorsPtr)(nvmlDevice_t, nvmlEccBitType_t, nvmlEccCounterType_t, nvmlEccErrorCounts_t *);\nnvmlReturn_t (*nvmlDeviceGetFanSpeedPtr)(nvmlDevice_t, unsigned int *);\nnvmlReturn_t (*nvmlDeviceGetMemoryInfoPtr)(nvmlDevice_t, nvmlMemory_t *);\nnvmlReturn_t (*nvmlDeviceGetPerformanceStatePtr)(nvmlDevice_t, nvmlPstates_t *);\nnvmlReturn_t (*nvmlDeviceGetPowerUsagePtr)(nvmlDevice_t, unsigned int *);\nnvmlReturn_t (*nvmlDeviceGetTemperaturePtr)(nvmlDevice_t, nvmlTemperatureSensors_t, unsigned int *);\nnvmlReturn_t (*nvmlDeviceGetTotalEccErrorsPtr)(nvmlDevice_t, nvmlEccBitType_t, nvmlEccCounterType_t, unsigned long long *);\nnvmlReturn_t (*nvmlDeviceGetUtilizationRatesPtr)(nvmlDevice_t, nvmlUtilization_t *);\nnvmlReturn_t (*nvmlDeviceGetHandleByIndexPtr)(unsigned int, nvmlDevice_t *);\nnvmlReturn_t (*nvmlDeviceGetPciInfoPtr)(nvmlDevice_t, nvmlPciInfo_t *);\nnvmlReturn_t (*nvmlDeviceGetNamePtr)(nvmlDevice_t, char *, unsigned int);\nnvmlReturn_t (*nvmlDeviceGetInforomVersionPtr)(nvmlDevice_t, nvmlInforomObject_t, char *, unsigned int);\nnvmlReturn_t (*nvmlDeviceGetEccModePtr)(nvmlDevice_t, nvmlEnableState_t *, nvmlEnableState_t *);\nnvmlReturn_t (*nvmlInitPtr)(void);\nnvmlReturn_t (*nvmlDeviceGetCountPtr)(unsigned int *);\nnvmlReturn_t (*nvmlShutdownPtr)(void);\nnvmlReturn_t (*nvmlDeviceGetPowerManagementLimitPtr)(nvmlDevice_t device, unsigned int* limit);\nnvmlReturn_t (*nvmlDeviceSetPowerManagementLimitPtr)(nvmlDevice_t device, unsigned int  limit);\nnvmlReturn_t (*nvmlDeviceGetPowerManagementLimitConstraintsPtr)(nvmlDevice_t device, unsigned int* minLimit, unsigned int* maxLimit);\n\n// file handles used to access cuda libraries with dlopen\nstatic void* dl1 = NULL;\nstatic void* dl2 = NULL;\nstatic void* dl3 = NULL;\n\nstatic char cuda_main[]=PAPI_CUDA_MAIN;\nstatic char cuda_runtime[]=PAPI_CUDA_RUNTIME;\nstatic char nvml_main[]=PAPI_NVML_MAIN;\n\nstatic int linkCudaLibraries();\n\n/* Declare our vector in advance */\npapi_vector_t _nvml_vector;\n\n/* upto 25 events per card how many cards per system should we allow for?! */\n#define NVML_MAX_COUNTERS 100\n\n/** Holds control flags.  Usually there's one of these per event-set.\n *    Usually this is out-of band configuration of the hardware\n */\ntypedef struct nvml_control_state {\n    int num_events;\n    int which_counter[NVML_MAX_COUNTERS];\n    long long counter[NVML_MAX_COUNTERS];   /**< Copy of counts, holds results when stopped */\n} nvml_control_state_t;\n\n/** Holds per-thread information */\ntypedef struct nvml_context {\n    nvml_control_state_t state;\n} nvml_context_t;\n\n/** This table contains the native events */\nstatic nvml_native_event_entry_t *nvml_native_table = NULL;\n\n/** Number of devices detected at component_init time */\nstatic int device_count = 0;\n\n/** number of events in the table*/\nstatic int num_events = 0;\n\nstatic nvmlDevice_t* devices = NULL;\nstatic int* features = NULL;\nstatic unsigned int *power_management_initial_limit = NULL;\nstatic unsigned int *power_management_limit_constraint_min = NULL;\nstatic unsigned int *power_management_limit_constraint_max = NULL;\n\nunsigned long long\ngetClockSpeed(nvmlDevice_t dev, nvmlClockType_t which_one)\n{\n    unsigned int ret = 0;\n    nvmlReturn_t bad;\n    bad = (*nvmlDeviceGetClockInfoPtr)(dev, which_one, &ret);\n\n    if (NVML_SUCCESS != bad) {\n        SUBDBG(\"something went wrong %s\\n\", (*nvmlErrorStringPtr)(bad));\n        return (unsigned long long) - 1;\n    }\n\n    return (unsigned long long)ret;\n}\n\nunsigned long long\ngetEccLocalErrors(nvmlDevice_t dev, nvmlEccBitType_t bits, int which_one)\n{\n    nvmlEccErrorCounts_t counts;\n\n    nvmlReturn_t bad;\n    bad = (*nvmlDeviceGetDetailedEccErrorsPtr)(dev, bits, NVML_VOLATILE_ECC , &counts);\n\n    if (NVML_SUCCESS != bad) {\n        SUBDBG(\"something went wrong %s\\n\", (*nvmlErrorStringPtr)(bad));\n        return (unsigned long long) - 1;\n    }\n    switch (which_one) {\n    case LOCAL_ECC_REGFILE:\n        return counts.registerFile;\n    case LOCAL_ECC_L1:\n        return counts.l1Cache;\n    case LOCAL_ECC_L2:\n        return counts.l2Cache;\n    case LOCAL_ECC_MEM:\n        return counts.deviceMemory;\n    default:\n        ;\n    }\n    return (unsigned long long) - 1;\n}\n\nunsigned long long\ngetFanSpeed(nvmlDevice_t dev)\n{\n    unsigned int ret = 0;\n    nvmlReturn_t bad;\n    bad = (*nvmlDeviceGetFanSpeedPtr)(dev, &ret);\n\n    if (NVML_SUCCESS != bad) {\n        SUBDBG(\"something went wrong %s\\n\", (*nvmlErrorStringPtr)(bad));\n        return (unsigned long long) - 1;\n    }\n    return (unsigned long long)ret;\n}\n\nunsigned long long\ngetMaxClockSpeed(nvmlDevice_t dev, nvmlClockType_t which_one)\n{\n    unsigned int ret = 0;\n    nvmlReturn_t bad;\n    bad = (*nvmlDeviceGetClockInfoPtr)(dev, which_one, &ret);\n\n    if (NVML_SUCCESS != bad) {\n        SUBDBG(\"something went wrong %s\\n\", (*nvmlErrorStringPtr)(bad));\n        return (unsigned long long) - 1;\n    }\n    return (unsigned long long) ret;\n}\n\nunsigned long long\ngetMemoryInfo(nvmlDevice_t dev, int which_one)\n{\n    nvmlMemory_t meminfo;\n    nvmlReturn_t bad;\n    bad = (*nvmlDeviceGetMemoryInfoPtr)(dev, &meminfo);\n\n    if (NVML_SUCCESS != bad) {\n        SUBDBG(\"something went wrong %s\\n\", (*nvmlErrorStringPtr)(bad));\n        return (unsigned long long) - 1;\n    }\n\n    switch (which_one) {\n    case MEMINFO_TOTAL_MEMORY:\n        return meminfo.total;\n    case MEMINFO_UNALLOCED:\n        return meminfo.free;\n    case MEMINFO_ALLOCED:\n        return meminfo.used;\n    default:\n        ;\n    }\n    return (unsigned long long) - 1;\n}\n\nunsigned long long\ngetPState(nvmlDevice_t dev)\n{\n    unsigned int ret = 0;\n    nvmlPstates_t state = NVML_PSTATE_15;\n    nvmlReturn_t bad;\n    bad = (*nvmlDeviceGetPerformanceStatePtr)(dev, &state);\n\n    if (NVML_SUCCESS != bad) {\n        SUBDBG(\"something went wrong %s\\n\", (*nvmlErrorStringPtr)(bad));\n        return (unsigned long long) - 1;\n    }\n    switch (state) {\n    case NVML_PSTATE_15:\n        ret++;\n        // fall through\n    case NVML_PSTATE_14:\n        ret++;\n        // fall through\n    case NVML_PSTATE_13:\n        ret++;\n        // fall through\n    case NVML_PSTATE_12:\n        ret++;\n        // fall through\n    case NVML_PSTATE_11:\n        ret++;\n        // fall through\n    case NVML_PSTATE_10:\n        ret++;\n        // fall through\n    case NVML_PSTATE_9:\n        ret++;\n        // fall through\n    case NVML_PSTATE_8:\n        ret++;\n        // fall through\n    case NVML_PSTATE_7:\n        ret++;\n        // fall through\n    case NVML_PSTATE_6:\n        ret++;\n        // fall through\n    case NVML_PSTATE_5:\n        ret++;\n        // fall through\n    case NVML_PSTATE_4:\n        ret++;\n        // fall through\n    case NVML_PSTATE_3:\n        ret++;\n        // fall through\n    case NVML_PSTATE_2:\n        ret++;\n        // fall through\n    case NVML_PSTATE_1:\n        ret++;\n        // fall through\n    case NVML_PSTATE_0:\n        break;\n        // fall through\n    case NVML_PSTATE_UNKNOWN:\n    default:\n        /* This should never happen?\n         * The API docs just state Unknown performance state... */\n        return (unsigned long long) - 1;\n    }\n    return (unsigned long long)ret;\n}\n\nunsigned long long\ngetPowerUsage(nvmlDevice_t dev)\n{\n    unsigned int power;\n    nvmlReturn_t bad;\n    bad = (*nvmlDeviceGetPowerUsagePtr)(dev, &power);\n\n    if (NVML_SUCCESS != bad) {\n        SUBDBG(\"something went wrong %s\\n\", (*nvmlErrorStringPtr)(bad));\n        return (unsigned long long) - 1;\n    }\n    return (unsigned long long) power;\n}\n\nunsigned long long\ngetTemperature(nvmlDevice_t dev)\n{\n    unsigned int ret = 0;\n    nvmlReturn_t bad;\n    bad = (*nvmlDeviceGetTemperaturePtr)(dev, NVML_TEMPERATURE_GPU, &ret);\n\n    if (NVML_SUCCESS != bad) {\n        SUBDBG(\"something went wrong %s\\n\", (*nvmlErrorStringPtr)(bad));\n        return (unsigned long long) - 1;\n    }\n    return (unsigned long long)ret;\n}\n\nunsigned long long\ngetTotalEccErrors(nvmlDevice_t dev, nvmlEccBitType_t bits)\n{\n    unsigned long long counts = 0;\n    nvmlReturn_t bad;\n    bad = (*nvmlDeviceGetTotalEccErrorsPtr)(dev, bits, NVML_VOLATILE_ECC , &counts);\n\n    if (NVML_SUCCESS != bad) {\n        SUBDBG(\"something went wrong %s\\n\", (*nvmlErrorStringPtr)(bad));\n        return (unsigned long long) - 1;\n    }\n    return counts;\n}\n\n/*  0 => gpu util\n    1 => memory util\n */\nunsigned long long\ngetUtilization(nvmlDevice_t dev, int which_one)\n{\n    nvmlUtilization_t util;\n    nvmlReturn_t bad;\n    bad = (*nvmlDeviceGetUtilizationRatesPtr)(dev, &util);\n\n    if (NVML_SUCCESS != bad) {\n        SUBDBG(\"something went wrong %s\\n\", (*nvmlErrorStringPtr)(bad));\n        return (unsigned long long) - 1;\n    }\n\n    switch (which_one) {\n    case GPU_UTILIZATION:\n        return (unsigned long long) util.gpu;\n    case MEMORY_UTILIZATION:\n        return (unsigned long long) util.memory;\n    default:\n        ;\n    }\n\n    return (unsigned long long) - 1;\n}\n\nunsigned long long getPowerManagementLimit(nvmlDevice_t dev)\n{\n    unsigned int limit;\n    nvmlReturn_t rv;\n    rv = (*nvmlDeviceGetPowerManagementLimitPtr)(dev, &limit);\n    if (NVML_SUCCESS != rv) {\n        SUBDBG(\"something went wrong %s\\n\", (*nvmlErrorStringPtr)(rv));\n        return (unsigned long long) 0;\n    }\n    return (unsigned long long) limit;\n}\n\nstatic void\nnvml_hardware_reset()\n{\n    /* nvmlDeviceSet* and nvmlDeviceClear* calls require root/admin access, so while\n     * possible to implement a reset on the ECC counters, we pass */\n    /*\n       for ( i=0; i < device_count; i++ )\n       nvmlDeviceClearEccErrorCounts( device[i], NVML_VOLATILE_ECC );\n    */\n    int i;\n    nvmlReturn_t ret;\n    unsigned int templimit = 0;\n    for (i = 0; i < device_count; i++) {\n        if (HAS_FEATURE(features[i], FEATURE_POWER_MANAGEMENT)) {\n            // if power management is available\n            if (power_management_initial_limit[i] != 0) {\n                ret = (*nvmlDeviceGetPowerManagementLimitPtr)(devices[i], &templimit);\n                if ((ret == NVML_SUCCESS) && (templimit != power_management_initial_limit[i])) {\n                    SUBDBG(\"Reset power_management_limit on device %d to initial value of %d \\n\", i, power_management_initial_limit[i]);\n                    // if power is not at its initial value\n                    // reset to initial value\n                    ret = (*nvmlDeviceSetPowerManagementLimitPtr)(devices[i], power_management_initial_limit[i]);\n                    if (ret != NVML_SUCCESS)\n                        SUBDBG(\"Unable to reset the NVML power management limit on device %i to %ull (return code %d) \\n\", i, power_management_initial_limit[i] , ret);\n                }\n            }\n        }\n    }\n}\n\n/** Code that reads event values.                         */\n/*   You might replace this with code that accesses       */\n/*   hardware or reads values from the operatings system. */\nstatic int\nnvml_hardware_read(long long *value, int which_one)\n//, nvml_context_t *ctx)\n{\n    nvml_native_event_entry_t *entry;\n    nvmlDevice_t handle;\n    int cudaIdx = -1;\n\n    entry = &nvml_native_table[which_one];\n    *value = (long long) - 1;\n    /* replace entry->resources with the current cuda_device->nvml device */\n    (*cudaGetDevicePtr)(&cudaIdx);\n\n    if (cudaIdx < 0 || cudaIdx > device_count)\n        return PAPI_EINVAL;\n\n    /* Make sure the device we are running on has the requested event */\n    if (!HAS_FEATURE(features[cudaIdx] , entry->type))\n        return PAPI_EINVAL;\n\n    handle = devices[cudaIdx];\n\n    switch (entry->type) {\n    case FEATURE_CLOCK_INFO:\n        *value =  getClockSpeed(handle, (nvmlClockType_t)entry->options.clock);\n        break;\n    case FEATURE_ECC_LOCAL_ERRORS:\n        *value = getEccLocalErrors(handle,\n                                   (nvmlEccBitType_t)entry->options.ecc_opts.bits,\n                                   (int)entry->options.ecc_opts.which_one);\n        break;\n    case FEATURE_FAN_SPEED:\n        *value = getFanSpeed(handle);\n        break;\n    case FEATURE_MAX_CLOCK:\n        *value = getMaxClockSpeed(handle,\n                                  (nvmlClockType_t)entry->options.clock);\n        break;\n    case FEATURE_MEMORY_INFO:\n        *value = getMemoryInfo(handle,\n                               (int)entry->options.which_one);\n        break;\n    case FEATURE_PERF_STATES:\n        *value = getPState(handle);\n        break;\n    case FEATURE_POWER:\n        *value = getPowerUsage(handle);\n        break;\n    case FEATURE_TEMP:\n        *value = getTemperature(handle);\n        break;\n    case FEATURE_ECC_TOTAL_ERRORS:\n        *value = getTotalEccErrors(handle,\n                                   (nvmlEccBitType_t)entry->options.ecc_opts.bits);\n        break;\n    case FEATURE_UTILIZATION:\n        *value = getUtilization(handle,\n                                (int)entry->options.which_one);\n        break;\n    case FEATURE_POWER_MANAGEMENT:\n        *value = getPowerManagementLimit(handle);\n        break;\n\n    case FEATURE_NVML_POWER_MANAGEMENT_LIMIT_CONSTRAINT_MIN:\n        *value = power_management_limit_constraint_min[cudaIdx];\n        break;\n\n    case FEATURE_NVML_POWER_MANAGEMENT_LIMIT_CONSTRAINT_MAX:\n        *value = power_management_limit_constraint_max[cudaIdx];\n        break;\n\n    default:\n        return PAPI_EINVAL;\n    }\n    if (*value == (long long)(unsigned long long) - 1)\n        return PAPI_EINVAL;\n\n    return PAPI_OK;\n}\n\n/** Code that reads event values.                         */\n/*   You might replace this with code that accesses       */\n/*   hardware or reads values from the operatings system. */\nstatic int nvml_hardware_write(long long *value, int which_one)\n{\n    nvml_native_event_entry_t *entry;\n    nvmlDevice_t handle;\n    int cudaIdx = -1;\n    nvmlReturn_t nvret;\n\n    entry = &nvml_native_table[which_one];\n    /* replace entry->resources with the current cuda_device->nvml device */\n    (*cudaGetDevicePtr)(&cudaIdx);\n\n    if (cudaIdx < 0 || cudaIdx > device_count)\n        return PAPI_EINVAL;\n\n    /* Make sure the device we are running on has the requested event */\n    if (!HAS_FEATURE(features[cudaIdx] , entry->type))\n        return PAPI_EINVAL;\n\n    handle = devices[cudaIdx];\n\n    switch (entry->type) {\n    case FEATURE_POWER_MANAGEMENT: {\n        unsigned int setToPower = (unsigned int) * value;\n        if (setToPower < power_management_limit_constraint_min[cudaIdx]) {\n            SUBDBG(\"Error: Desired power %u mW < minimum %u mW on device %d\\n\", setToPower, power_management_limit_constraint_min[cudaIdx], cudaIdx);\n            return PAPI_EINVAL;\n        }\n        if (setToPower > power_management_limit_constraint_max[cudaIdx]) {\n            SUBDBG(\"Error: Desired power %u mW > maximum %u mW on device %d\\n\", setToPower, power_management_limit_constraint_max[cudaIdx], cudaIdx);\n            return PAPI_EINVAL;\n        }\n        if ((nvret = (*nvmlDeviceSetPowerManagementLimitPtr)(handle, setToPower)) != NVML_SUCCESS) {\n            SUBDBG(\"Error: %s\\n\", (*nvmlErrorStringPtr)(nvret));\n            return PAPI_EINVAL;\n        }\n    }\n    break;\n\n    default:\n        return PAPI_EINVAL;\n    }\n\n    return PAPI_OK;\n}\n\n/********************************************************************/\n/* Below are the functions required by the PAPI component interface */\n/********************************************************************/\n\n/** This is called whenever a thread is initialized */\nint\n_papi_nvml_init_thread(hwd_context_t * ctx)\n{\n    (void) ctx;\n\n    SUBDBG(\"Enter: ctx: %p\\n\", ctx);\n\n    return PAPI_OK;\n}\n\nstatic int\ndetectDevices()\n{\n    nvmlReturn_t ret;\n    nvmlEnableState_t mode        = NVML_FEATURE_DISABLED;\n    nvmlEnableState_t pendingmode = NVML_FEATURE_DISABLED;\n\n    char name[64];\n    char inforomECC[16];\n    char names[device_count][64];\n\n    float ecc_version = 0.0;\n\n    int i = 0;\n\n    unsigned int temp = 0;\n\n    memset(names, 0x0, device_count * 64);\n\n    /* So for each card, check whats querable */\n    for (i = 0; i < device_count; i++) {\n        features[i] = 0;\n        \n        ret = (*nvmlDeviceGetHandleByIndexPtr)(i, &devices[i]);\n        if (NVML_SUCCESS != ret) {\n            SUBDBG(\"nvmlDeviceGetHandleByIndex(%d, &devices[%d]) failed.\\n\", i, i);\n            return PAPI_ESYS;\n        }\n\n        ret = (*nvmlDeviceGetNamePtr)(devices[i], name, sizeof(name) - 1);\n        if (NVML_SUCCESS != ret) {\n            SUBDBG(\"nvmlDeviceGetName failed \\n\");\n            strncpy(name, \"deviceNameUnknown\", 17);\n        }\n\n        name[sizeof(name) - 1] = '\\0';   // to safely use strstr operation below, the variable 'name' must be null terminated\n\n        ret = (*nvmlDeviceGetInforomVersionPtr)(devices[i], NVML_INFOROM_ECC, inforomECC, 16);\n        if (NVML_SUCCESS != ret) {\n            SUBDBG(\"nvmlGetInforomVersion fails %s\\n\", (*nvmlErrorStringPtr)(ret));\n        } else {\n            ecc_version = strtof(inforomECC, NULL);\n        }\n\n        if (getClockSpeed(devices[i], NVML_CLOCK_GRAPHICS) != (unsigned long long) - 1) {\n            features[i] |= FEATURE_CLOCK_INFO;\n            num_events += 3;\n        }\n\n        /*  For Tesla and Quadro products from Fermi and Kepler families.\n            requires NVML_INFOROM_ECC 2.0 or higher for location-based counts\n            requires NVML_INFOROM_ECC 1.0 or higher for all other ECC counts\n            requires ECC mode to be enabled. */\n        ret = (*nvmlDeviceGetEccModePtr)(devices[i], &mode, &pendingmode);\n        if (NVML_SUCCESS == ret) {\n            if (NVML_FEATURE_ENABLED == mode) {\n                if (ecc_version >= 2.0) {\n                    features[i] |= FEATURE_ECC_LOCAL_ERRORS;\n                    num_events += 8; /* {single bit, two bit errors} x { reg, l1, l2, memory } */\n                }\n                if (ecc_version >= 1.0) {\n                    features[i] |= FEATURE_ECC_TOTAL_ERRORS;\n                    num_events += 2; /* single bit errors, double bit errors */\n                }\n            }\n        } else {\n            SUBDBG(\"nvmlDeviceGetEccMode does not appear to be supported. (nvml return code %d)\\n\", ret);\n        }\n\n        /* Check if fan speed is available */\n        if (getFanSpeed(devices[i]) != (unsigned long long) - 1) {\n            features[i] |= FEATURE_FAN_SPEED;\n            num_events++;\n        }\n\n        /* Check if clock data are available */\n        if (getMaxClockSpeed(devices[i], NVML_CLOCK_GRAPHICS) != (unsigned long long) - 1) {\n            features[i] |= FEATURE_MAX_CLOCK;\n            num_events += 3;\n        }\n\n        /* For all products */\n        features[i] |= FEATURE_MEMORY_INFO;\n        num_events += 3; /* total, free, used */\n\n        /* Check if performance state is available */\n        if (getPState(devices[i]) != (unsigned long long) - 1) {\n            features[i] |= FEATURE_PERF_STATES;\n            num_events++;\n        }\n\n        /*  For \"GF11x\" Tesla and Quadro products from the Fermi family\n                requires NVML_INFOROM_POWER 3.0 or higher\n                For Tesla and Quadro products from the Kepler family\n                does not require NVML_INFOROM_POWER */\n        /* Just try reading power, if it works, enable it*/\n        ret = (*nvmlDeviceGetPowerUsagePtr)(devices[i], &temp);\n        if (NVML_SUCCESS == ret) {\n            features[i] |= FEATURE_POWER;\n            num_events++;\n        } else {\n            SUBDBG(\"nvmlDeviceGetPowerUsage does not appear to be supported on this card. (nvml return code %d)\\n\", ret);\n        }\n\n        /* Check if temperature data are available */\n        if (getTemperature(devices[i]) != (unsigned long long) - 1) {\n            features[i] |= FEATURE_TEMP;\n            num_events++;\n        }\n\n        // For power_management_limit\n        {\n            // Just try the call to see if it works\n            unsigned int templimit = 0;\n            ret = (*nvmlDeviceGetPowerManagementLimitPtr)(devices[i], &templimit);\n            if (ret == NVML_SUCCESS && templimit > 0) {\n                power_management_initial_limit[i] = templimit;\n                features[i] |= FEATURE_POWER_MANAGEMENT;\n                num_events += 1;\n            } else {\n                power_management_initial_limit[i] = 0;\n                SUBDBG(\"nvmlDeviceGetPowerManagementLimit not appear to be supported on this card. (NVML code %d)\\n\", ret);\n            }\n        }\n\n        // For power_management_limit_constraints, minimum and maximum\n        {\n            unsigned int minLimit = 0, maxLimit = 0;\n            ret = (*nvmlDeviceGetPowerManagementLimitConstraintsPtr)(devices[i], &minLimit, &maxLimit);\n            if (ret == NVML_SUCCESS) {\n                power_management_limit_constraint_min[i] = minLimit;\n                features[i] |= FEATURE_NVML_POWER_MANAGEMENT_LIMIT_CONSTRAINT_MIN;\n                num_events += 1;\n                power_management_limit_constraint_max[i] = maxLimit;\n                features[i] |= FEATURE_NVML_POWER_MANAGEMENT_LIMIT_CONSTRAINT_MAX;\n                num_events += 1;\n            } else {\n                power_management_limit_constraint_min[i] = 0;\n                power_management_limit_constraint_max[i] = INT_MAX;\n            }\n            SUBDBG(\"Done nvmlDeviceGetPowerManagementLimitConstraintsPtr\\n\");\n        }\n\n        /* Check if temperature data are available */\n        if (getUtilization(devices[i], GPU_UTILIZATION) != (unsigned long long) - 1) {\n            features[i] |= FEATURE_UTILIZATION;\n            num_events += 2;\n        }\n\n        int retval = snprintf(names[i], sizeof(name), \"%s:device:%d\", name, i);\n        if (retval > (int)sizeof(name)) {\n            SUBDBG(\"Device name is too long %s:device%d\", name, i);\n            return (PAPI_EINVAL);\n        }\n        names[i][sizeof(name) - 1] = '\\0';\n    }\n    return PAPI_OK;\n}\n\nstatic void\ncreateNativeEvents()\n{\n    char name[64];\n    char sanitized_name[PAPI_MAX_STR_LEN];\n    char names[device_count][64];\n\n    int i, nameLen = 0, j;\n\n    nvml_native_event_entry_t* entry;\n    nvmlReturn_t ret;\n\n    nvml_native_table = (nvml_native_event_entry_t*) papi_malloc(\n                            sizeof(nvml_native_event_entry_t) * num_events);\n    memset(nvml_native_table, 0x0, sizeof(nvml_native_event_entry_t) * num_events);\n    entry = &nvml_native_table[0];\n\n    for (i = 0; i < device_count; i++) {\n        memset(names[i], 0x0, 64);\n        ret = (*nvmlDeviceGetNamePtr)(devices[i], name, sizeof(name) - 1);\n        if (NVML_SUCCESS != ret) {\n            SUBDBG(\"nvmlDeviceGetName failed \\n\");\n            strncpy(name, \"deviceNameUnknown\", 17);\n        }\n        name[sizeof(name) - 1] = '\\0';   // to safely use strlen operation below, the variable 'name' must be null terminated\n\n        nameLen = strlen(name);\n        strncpy(sanitized_name, name, PAPI_MAX_STR_LEN);\n\n        int retval = snprintf(sanitized_name, sizeof(name), \"%s:device_%d\", name, i);\n        if (retval > (int)sizeof(name)) {\n            SUBDBG(\"Device name is too long %s:device%d\", name, i);\n            return;\n        }\n        sanitized_name[sizeof(name) - 1] = '\\0';\n\n        for (j = 0; j < nameLen; j++)\n            if (' ' == sanitized_name[j])\n                sanitized_name[j] = '_';\n\n        if (HAS_FEATURE(features[i], FEATURE_CLOCK_INFO)) {\n            sprintf(entry->name, \"%s:graphics_clock\", sanitized_name);\n            strncpy(entry->description, \"Graphics clock domain (MHz).\", PAPI_MAX_STR_LEN);\n            entry->options.clock = NVML_CLOCK_GRAPHICS;\n            entry->type = FEATURE_CLOCK_INFO;\n            entry++;\n\n            sprintf(entry->name, \"%s:sm_clock\", sanitized_name);\n            strncpy(entry->description, \"SM clock domain (MHz).\", PAPI_MAX_STR_LEN);\n            entry->options.clock = NVML_CLOCK_SM;\n            entry->type = FEATURE_CLOCK_INFO;\n            entry++;\n\n            sprintf(entry->name, \"%s:memory_clock\", sanitized_name);\n            strncpy(entry->description, \"Memory clock domain (MHz).\", PAPI_MAX_STR_LEN);\n            entry->options.clock = NVML_CLOCK_MEM;\n            entry->type = FEATURE_CLOCK_INFO;\n            entry++;\n        }\n\n        if (HAS_FEATURE(features[i], FEATURE_ECC_LOCAL_ERRORS)) {\n            sprintf(entry->name, \"%s:l1_single_ecc_errors\", sanitized_name);\n            strncpy(entry->description, \"L1 cache single bit ECC\", PAPI_MAX_STR_LEN);\n            entry->options.ecc_opts = (struct local_ecc) {\n                .bits = NVML_SINGLE_BIT_ECC,\n                 .which_one = LOCAL_ECC_L1,\n            };\n            entry->type = FEATURE_ECC_LOCAL_ERRORS;\n            entry++;\n\n            sprintf(entry->name, \"%s:l2_single_ecc_errors\", sanitized_name);\n            strncpy(entry->description, \"L2 cache single bit ECC\", PAPI_MAX_STR_LEN);\n            entry->options.ecc_opts = (struct local_ecc) {\n                .bits = NVML_SINGLE_BIT_ECC,\n                 .which_one = LOCAL_ECC_L2,\n            };\n            entry->type = FEATURE_ECC_LOCAL_ERRORS;\n            entry++;\n\n            sprintf(entry->name, \"%s:memory_single_ecc_errors\", sanitized_name);\n            strncpy(entry->description, \"Device memory single bit ECC\", PAPI_MAX_STR_LEN);\n            entry->options.ecc_opts = (struct local_ecc) {\n                .bits = NVML_SINGLE_BIT_ECC,\n                 .which_one = LOCAL_ECC_MEM,\n            };\n            entry->type = FEATURE_ECC_LOCAL_ERRORS;\n            entry++;\n\n            sprintf(entry->name, \"%s:regfile_single_ecc_errors\", sanitized_name);\n            strncpy(entry->description, \"Register file single bit ECC\", PAPI_MAX_STR_LEN);\n            entry->options.ecc_opts = (struct local_ecc) {\n                .bits = NVML_SINGLE_BIT_ECC,\n                 .which_one = LOCAL_ECC_REGFILE,\n            };\n            entry->type = FEATURE_ECC_LOCAL_ERRORS;\n            entry++;\n\n            sprintf(entry->name, \"%s:1l_double_ecc_errors\", sanitized_name);\n            strncpy(entry->description, \"L1 cache double bit ECC\", PAPI_MAX_STR_LEN);\n            entry->options.ecc_opts = (struct local_ecc) {\n                .bits = NVML_DOUBLE_BIT_ECC,\n                 .which_one = LOCAL_ECC_L1,\n            };\n            entry->type = FEATURE_ECC_LOCAL_ERRORS;\n            entry++;\n\n            sprintf(entry->name, \"%s:l2_double_ecc_errors\", sanitized_name);\n            strncpy(entry->description, \"L2 cache double bit ECC\", PAPI_MAX_STR_LEN);\n            entry->options.ecc_opts = (struct local_ecc) {\n                .bits = NVML_DOUBLE_BIT_ECC,\n                 .which_one = LOCAL_ECC_L2,\n            };\n            entry->type = FEATURE_ECC_LOCAL_ERRORS;\n            entry++;\n\n            sprintf(entry->name, \"%s:memory_double_ecc_errors\", sanitized_name);\n            strncpy(entry->description, \"Device memory double bit ECC\", PAPI_MAX_STR_LEN);\n            entry->options.ecc_opts = (struct local_ecc) {\n                .bits = NVML_DOUBLE_BIT_ECC,\n                 .which_one = LOCAL_ECC_MEM,\n            };\n            entry->type = FEATURE_ECC_LOCAL_ERRORS;\n            entry++;\n\n            sprintf(entry->name, \"%s:regfile_double_ecc_errors\", sanitized_name);\n            strncpy(entry->description, \"Register file double bit ECC\", PAPI_MAX_STR_LEN);\n            entry->options.ecc_opts = (struct local_ecc) {\n                .bits = NVML_DOUBLE_BIT_ECC,\n                 .which_one = LOCAL_ECC_REGFILE,\n            };\n            entry->type = FEATURE_ECC_LOCAL_ERRORS;\n            entry++;\n        }\n\n        if (HAS_FEATURE(features[i], FEATURE_FAN_SPEED)) {\n            sprintf(entry->name, \"%s:fan_speed\", sanitized_name);\n            strncpy(entry->description, \"The fan speed expressed as a percent of the maximum, i.e. full speed is 100%\", PAPI_MAX_STR_LEN);\n            entry->type = FEATURE_FAN_SPEED;\n            entry++;\n        }\n\n        if (HAS_FEATURE(features[i], FEATURE_MAX_CLOCK)) {\n            sprintf(entry->name, \"%s:graphics_max_clock\", sanitized_name);\n            strncpy(entry->description, \"Maximal Graphics clock domain (MHz).\", PAPI_MAX_STR_LEN);\n            entry->options.clock = NVML_CLOCK_GRAPHICS;\n            entry->type = FEATURE_MAX_CLOCK;\n            entry++;\n\n            sprintf(entry->name, \"%s:sm_max_clock\", sanitized_name);\n            strncpy(entry->description, \"Maximal SM clock domain (MHz).\", PAPI_MAX_STR_LEN);\n            entry->options.clock = NVML_CLOCK_SM;\n            entry->type = FEATURE_MAX_CLOCK;\n            entry++;\n\n            sprintf(entry->name, \"%s:memory_max_clock\", sanitized_name);\n            strncpy(entry->description, \"Maximal Memory clock domain (MHz).\", PAPI_MAX_STR_LEN);\n            entry->options.clock = NVML_CLOCK_MEM;\n            entry->type = FEATURE_MAX_CLOCK;\n            entry++;\n        }\n\n        if (HAS_FEATURE(features[i], FEATURE_MEMORY_INFO)) {\n            sprintf(entry->name, \"%s:total_memory\", sanitized_name);\n            strncpy(entry->description, \"Total installed FB memory (in bytes).\", PAPI_MAX_STR_LEN);\n            entry->options.which_one = MEMINFO_TOTAL_MEMORY;\n            entry->type = FEATURE_MEMORY_INFO;\n            entry++;\n\n            sprintf(entry->name, \"%s:unallocated_memory\", sanitized_name);\n            strncpy(entry->description, \"Uncallocated FB memory (in bytes).\", PAPI_MAX_STR_LEN);\n            entry->options.which_one = MEMINFO_UNALLOCED;\n            entry->type = FEATURE_MEMORY_INFO;\n            entry++;\n\n            sprintf(entry->name, \"%s:allocated_memory\", sanitized_name);\n            strncpy(entry->description, \"Allocated FB memory (in bytes). Note that the driver/GPU always sets aside a small amount of memory for bookkeeping.\", PAPI_MAX_STR_LEN);\n            entry->options.which_one = MEMINFO_ALLOCED;\n            entry->type = FEATURE_MEMORY_INFO;\n            entry++;\n        }\n\n        if (HAS_FEATURE(features[i], FEATURE_PERF_STATES)) {\n            sprintf(entry->name, \"%s:pstate\", sanitized_name);\n            strncpy(entry->description, \"The performance state of the device.\", PAPI_MAX_STR_LEN);\n            entry->type = FEATURE_PERF_STATES;\n            entry++;\n        }\n\n        if (HAS_FEATURE(features[i], FEATURE_POWER)) {\n            sprintf(entry->name, \"%s:power\", sanitized_name);\n            // set the power event units value to \"mW\" for miliwatts\n            strncpy(entry->units, \"mW\", PAPI_MIN_STR_LEN);\n            strncpy(entry->description, \"Power usage reading for the device, in miliwatts. This is the power draw (+/-5 watts) for the entire board: GPU, memory, etc.\", PAPI_MAX_STR_LEN);\n            entry->type = FEATURE_POWER;\n            entry++;\n        }\n\n        if (HAS_FEATURE(features[i], FEATURE_TEMP)) {\n            sprintf(entry->name, \"%s:temperature\", sanitized_name);\n            strncpy(entry->description, \"Current temperature readings for the device, in degrees C.\", PAPI_MAX_STR_LEN);\n            entry->type = FEATURE_TEMP;\n            entry++;\n        }\n\n        if (HAS_FEATURE(features[i], FEATURE_ECC_TOTAL_ERRORS)) {\n            sprintf(entry->name, \"%s:total_ecc_errors\", sanitized_name);\n            strncpy(entry->description, \"Total single bit errors.\", PAPI_MAX_STR_LEN);\n            entry->options.ecc_opts = (struct local_ecc) {\n                .bits = NVML_SINGLE_BIT_ECC,\n            };\n            entry->type = FEATURE_ECC_TOTAL_ERRORS;\n            entry++;\n\n            sprintf(entry->name, \"%s:total_ecc_errors\", sanitized_name);\n            strncpy(entry->description, \"Total double bit errors.\", PAPI_MAX_STR_LEN);\n            entry->options.ecc_opts = (struct local_ecc) {\n                .bits = NVML_DOUBLE_BIT_ECC,\n            };\n            entry->type = FEATURE_ECC_TOTAL_ERRORS;\n            entry++;\n        }\n\n        if (HAS_FEATURE(features[i], FEATURE_UTILIZATION)) {\n            sprintf(entry->name, \"%s:gpu_utilization\", sanitized_name);\n            strncpy(entry->description, \"Percent of time over the past second during which one or more kernels was executing on the GPU.\", PAPI_MAX_STR_LEN);\n            entry->options.which_one = GPU_UTILIZATION;\n            entry->type = FEATURE_UTILIZATION;\n            entry++;\n\n            sprintf(entry->name, \"%s:memory_utilization\", sanitized_name);\n            strncpy(entry->description, \"Percent of time over the past second during which global (device) memory was being read or written.\", PAPI_MAX_STR_LEN);\n            entry->options.which_one = MEMORY_UTILIZATION;\n            entry->type = FEATURE_UTILIZATION;\n            entry++;\n        }\n\n        if (HAS_FEATURE(features[i], FEATURE_POWER_MANAGEMENT)) {\n            sprintf(entry->name, \"%s:power_management_limit\", sanitized_name);\n            // set the power event units value to \"mW\" for milliwatts\n            strncpy(entry->units, \"mW\", PAPI_MIN_STR_LEN);\n            strncpy(entry->description, \"Power management limit in milliwatts associated with the device.  The power limit defines the upper boundary for the cards power draw. If the cards total power draw reaches this limit the power management algorithm kicks in. This should be writable (with appropriate privileges) on supported Kepler or later (unit milliWatts). \", PAPI_MAX_STR_LEN);\n            entry->type = FEATURE_POWER_MANAGEMENT;\n            entry++;\n        }\n        if (HAS_FEATURE(features[i], FEATURE_NVML_POWER_MANAGEMENT_LIMIT_CONSTRAINT_MIN)) {\n            sprintf(entry->name, \"%s:power_management_limit_constraint_min\", sanitized_name);\n            strncpy(entry->units, \"mW\", PAPI_MIN_STR_LEN);\n            strncpy(entry->description, \"The minimum power management limit in milliwatts.\", PAPI_MAX_STR_LEN);\n            entry->type = FEATURE_NVML_POWER_MANAGEMENT_LIMIT_CONSTRAINT_MIN;\n            entry++;\n        }\n\n        if (HAS_FEATURE(features[i], FEATURE_NVML_POWER_MANAGEMENT_LIMIT_CONSTRAINT_MAX)) {\n            sprintf(entry->name, \"%s:power_management_limit_constraint_max\", sanitized_name);\n            strncpy(entry->units, \"mW\", PAPI_MIN_STR_LEN);\n            strncpy(entry->description, \"The maximum power management limit in milliwatts.\", PAPI_MAX_STR_LEN);\n            entry->type = FEATURE_NVML_POWER_MANAGEMENT_LIMIT_CONSTRAINT_MAX;\n            entry++;\n        }\n\n        strncpy(names[i], name, sizeof(names[0]) - 1);\n        names[i][sizeof(names[0]) - 1] = '\\0';\n    }\n} // create native events.\n\n\n// Triggered by PAPI_shutdown(), but also if init fails to complete; for example due\n// to a missing library. We still need to clean up. The dynamic libs (dlxxx routines)\n// may have open mallocs that need to be free()d.\n \nint _papi_nvml_shutdown_component()\n{\n    SUBDBG(\"Enter:\\n\");\n    nvml_hardware_reset();\n    if (nvml_native_table != NULL) papi_free(nvml_native_table);\n    if (devices != NULL) papi_free(devices);\n    if (features != NULL) papi_free(features);\n    if (power_management_initial_limit) papi_free(power_management_initial_limit);\n    if (power_management_limit_constraint_min) papi_free(power_management_limit_constraint_min);\n    if (power_management_limit_constraint_max) papi_free(power_management_limit_constraint_max);\n    if (nvmlShutdownPtr) (*nvmlShutdownPtr)();        // Call nvml shutdown if we got that far.\n\n    device_count = 0;\n    num_events = 0;\n\n    // close the dynamic libraries needed by this component (opened in the init component call)\n    if (dl3) {dlclose(dl3); dl3=NULL;}\n    if (dl2) {dlclose(dl2); dl2=NULL;}\n    if (dl1) {dlclose(dl1); dl1=NULL;}\n\n    return PAPI_OK;\n}\n\n\n\n/** Initialize hardware counters, setup the function vector table\n * and get hardware information, this routine is called when the\n * PAPI process is initialized (IE PAPI_library_init)\n */\n\nint _papi_nvml_init_component(int cidx)\n{\n    SUBDBG(\"Entry: cidx: %d\\n\", cidx);\n    nvmlReturn_t ret;\n    cudaError_t cuerr;\n    int papi_errorcode;\n\n    int cuda_count = 0;\n    unsigned int nvml_count = 0;\n\n    /* link in the cuda and nvml libraries and resolve the symbols we need to use */\n    if (linkCudaLibraries() != PAPI_OK) {\n        SUBDBG(\"Dynamic link of CUDA libraries failed, component will be disabled.\\n\");\n        SUBDBG(\"See disable reason in papi_component_avail output for more details.\\n\");\n        _papi_nvml_shutdown_component();                          // clean up any open dynLibs, mallocs, etc.\n        return (PAPI_ENOSUPP);\n    }\n\n    ret = (*nvmlInitPtr)();\n    if (NVML_SUCCESS != ret) {\n        strcpy(_nvml_vector.cmp_info.disabled_reason, \"The NVIDIA management library failed to initialize.\");\n        _papi_nvml_shutdown_component();                          // clean up any open dynLibs, mallocs, etc.\n        return PAPI_ENOSUPP;\n    }\n\n    cuerr = (*cuInitPtr)(0);\n    if (cudaSuccess != cuerr) {\n        strcpy(_nvml_vector.cmp_info.disabled_reason, \"The CUDA library failed to initialize.\");\n        _papi_nvml_shutdown_component();                          // clean up any open dynLibs, mallocs, etc.\n        return PAPI_ENOSUPP;\n    }\n\n    /* Figure out the number of CUDA devices in the system */\n    ret = (*nvmlDeviceGetCountPtr)(&nvml_count);\n    if (NVML_SUCCESS != ret) {\n        strcpy(_nvml_vector.cmp_info.disabled_reason, \"Unable to get a count of devices from the NVIDIA management library.\");\n        _papi_nvml_shutdown_component();                          // clean up any open dynLibs, mallocs, etc.\n        return PAPI_ENOSUPP;\n    }\n\n    cuerr = (*cudaGetDeviceCountPtr)(&cuda_count);\n    if (cudaSuccess != cuerr) {\n        strcpy(_nvml_vector.cmp_info.disabled_reason, \"Unable to get a device count from CUDA.\");\n        _papi_nvml_shutdown_component();                          // clean up any open dynLibs, mallocs, etc.\n        return PAPI_ENOSUPP;\n    }\n\n    /* We can probably recover from this, when we're clever */\n    if ((cuda_count > 0) && (nvml_count != (unsigned int)cuda_count)) {\n        strcpy(_nvml_vector.cmp_info.disabled_reason, \"CUDA and the NVIDIA management library have different device counts.\");\n        _papi_nvml_shutdown_component();                          // clean up any open dynLibs, mallocs, etc.\n        return PAPI_ENOSUPP;\n    }\n\n    device_count = cuda_count;\n    SUBDBG(\"Need to setup NVML with %d devices\\n\", device_count);\n\n    /* A per device representation of what events are present */\n    features = (int*)papi_malloc(sizeof(int) * device_count);\n\n    /* Handles to each device */\n    devices = (nvmlDevice_t*)papi_malloc(sizeof(nvmlDevice_t) * device_count);\n\n    /* For each device, store the intial power value to enable reset if power is altered */\n    power_management_initial_limit = (unsigned int*)papi_malloc(sizeof(unsigned int) * device_count);\n    power_management_limit_constraint_min = (unsigned int*)papi_malloc(sizeof(unsigned int) * device_count);\n    power_management_limit_constraint_max = (unsigned int*)papi_malloc(sizeof(unsigned int) * device_count);\n\n    /* Figure out what events are supported on each card. */\n    if ((papi_errorcode = detectDevices()) != PAPI_OK) {\n        papi_free(features);\n        papi_free(devices);\n        sprintf(_nvml_vector.cmp_info.disabled_reason, \"An error occured in device feature detection, please check your NVIDIA Management Library and CUDA install.\");\n        _papi_nvml_shutdown_component();                        // clean up any open dynLibs, mallocs, etc.\n        return PAPI_ENOSUPP;\n    }\n\n    /* The assumption is that if everything went swimmingly in detectDevices,\n        all nvml calls here should be fine. */\n    createNativeEvents();\n\n    /* Export the total number of events available */\n    _nvml_vector.cmp_info.num_native_events = num_events;\n\n    /* Export the component id */\n    _nvml_vector.cmp_info.CmpIdx = cidx;\n\n    /* Export the number of 'counters' */\n    _nvml_vector.cmp_info.num_cntrs = num_events;\n    _nvml_vector.cmp_info.num_mpx_cntrs = num_events;\n\n    return PAPI_OK;\n}\n\n/*\n * Link the necessary CUDA libraries to use the cuda component.  If any of them can not be found, then\n * the CUDA component will just be disabled.  This is done at runtime so that a version of PAPI built\n * with the CUDA component can be installed and used on systems which have the CUDA libraries installed\n * and on systems where these libraries are not installed.\n */\nstatic int\nlinkCudaLibraries()\n{\n    char path_lib[1024];\n    /* Attempt to guess if we were statically linked to libc, if so bail */\n    if (_dl_non_dynamic_init != NULL) {\n        strncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML component does not support statically linking of libc.\", PAPI_MAX_STR_LEN);\n        return PAPI_ENOSUPP;\n    }\n\n    // Need to link in the cuda libraries, if any not found disable the component.\n    // getenv returns NULL if environment variable is not found.\n    char *cuda_root = getenv(\"PAPI_CUDA_ROOT\");\n    dl1 = NULL;                                                 // Ensure reset to NULL.\n\n    // Step 1: Process override if given.   \n    if (strlen(cuda_main) > 0) {                                // If override given, it has to work.\n        dl1 = dlopen(cuda_main, RTLD_NOW | RTLD_GLOBAL);        // Try to open that path.\n        if (dl1 == NULL) {\n            snprintf(_nvml_vector.cmp_info.disabled_reason, PAPI_MAX_STR_LEN, \"PAPI_CUDA_MAIN override '%s' given in Rules.nvml not found.\", cuda_main);\n            return(PAPI_ENOSUPP);   // Override given but not found.\n        }\n    }\n\n    // Step 2: Try system paths, will work with Spack, LD_LIBRARY_PATH, default paths.\n    if (dl1 == NULL) {                                          // No override,\n        dl1 = dlopen(\"libcuda.so\", RTLD_NOW | RTLD_GLOBAL);     // Try system paths.\n    }\n\n    // Step 3: Try the explicit install default. \n    if (dl1 == NULL && cuda_root != NULL) {                          // if root given, try it.\n        snprintf(path_lib, 1024, \"%s/lib64/libcuda.so\", cuda_root);  // PAPI Root check.\n        dl1 = dlopen(path_lib, RTLD_NOW | RTLD_GLOBAL);              // Try to open that path.\n    }\n\n    // Check for failure.\n    if (dl1 == NULL) {\n        snprintf(_nvml_vector.cmp_info.disabled_reason, PAPI_MAX_STR_LEN, \"libcuda.so not found.\");\n        return(PAPI_ENOSUPP);\n    }\n\n    // We have a dl1. (libcuda.so).\n\n    cuInitPtr = dlsym(dl1, \"cuInit\");\n    if (dlerror() != NULL) {\n        strncpy(_nvml_vector.cmp_info.disabled_reason, \"CUDA function cuInit not found.\", PAPI_MAX_STR_LEN);\n        return (PAPI_ENOSUPP);\n    }\n\n    /* Need to link in the cuda runtime library, if not found disable the component */\n    dl2 = NULL;                                 // Ensure reset to NULL.\n\n    // Step 1: Process override if given.   \n    if (strlen(cuda_runtime) > 0) {                                // If override given, it has to work.\n        dl2 = dlopen(cuda_runtime, RTLD_NOW | RTLD_GLOBAL);        // Try to open that path.\n        if (dl2 == NULL) {\n            snprintf(_nvml_vector.cmp_info.disabled_reason, PAPI_MAX_STR_LEN, \"PAPI_CUDA_RUNTIME override '%s' given in Rules.nvml not found.\", cuda_runtime);\n            return(PAPI_ENOSUPP);   // Override given but not found.\n        }\n    }\n\n    // Step 2: Try system paths, will work with Spack, LD_LIBRARY_PATH, default paths.\n    if (dl2 == NULL) {                                          // No override,\n        dl2 = dlopen(\"libcudart.so\", RTLD_NOW | RTLD_GLOBAL);   // Try system paths.\n    }\n\n    // Step 3: Try the explicit install default. \n    if (dl2 == NULL && cuda_root != NULL) {                             // if root given, try it.\n        snprintf(path_lib, 1024, \"%s/lib64/libcudart.so\", cuda_root);   // PAPI Root check.\n        dl2 = dlopen(path_lib, RTLD_NOW | RTLD_GLOBAL);                 // Try to open that path.\n    }\n\n    // Check for failure.\n    if (dl2 == NULL) {\n        snprintf(_nvml_vector.cmp_info.disabled_reason, PAPI_MAX_STR_LEN, \"libcudart.so not found.\");\n        return(PAPI_ENOSUPP);\n    }\n\n    // We have a dl2. (libcudart.so).\n    \n   cudaGetDevicePtr = dlsym(dl2, \"cudaGetDevice\");\n    if (dlerror() != NULL) {\n        strncpy(_nvml_vector.cmp_info.disabled_reason, \"CUDART function cudaGetDevice not found.\", PAPI_MAX_STR_LEN);\n        return (PAPI_ENOSUPP);\n    }\n    cudaGetDeviceCountPtr = dlsym(dl2, \"cudaGetDeviceCount\");\n    if (dlerror() != NULL) {\n        strncpy(_nvml_vector.cmp_info.disabled_reason, \"CUDART function cudaGetDeviceCount not found.\", PAPI_MAX_STR_LEN);\n        return (PAPI_ENOSUPP);\n    }\n    cudaDeviceGetPCIBusIdPtr = dlsym(dl2, \"cudaDeviceGetPCIBusId\");\n    if (dlerror() != NULL) {\n        strncpy(_nvml_vector.cmp_info.disabled_reason, \"CUDART function cudaDeviceGetPCIBusId not found.\", PAPI_MAX_STR_LEN);\n        return (PAPI_ENOSUPP);\n    }\n\n    // We need the NVML main library, normally libnvidia-ml.so. \n    dl3 = NULL;                                                 // Ensure reset to NULL.\n\n    // Step 1: Process override if given.   \n    if (strlen(nvml_main) > 0) {                                        // If override given, it MUST work.\n        dl3 = dlopen(nvml_main, RTLD_NOW | RTLD_GLOBAL);                // Try to open that path.\n        if (dl3 == NULL) {\n            snprintf(_nvml_vector.cmp_info.disabled_reason, PAPI_MAX_STR_LEN, \"PAPI_NVML_MAIN override '%s' given in Rules.nvml not found.\", nvml_main);\n            return(PAPI_ENOSUPP);   // Override given but not found.\n        }\n    }\n\n    // Step 2: Try system paths, will work with Spack, LD_LIBRARY_PATH, default paths.\n    if (dl3 == NULL) {                                              // If no override,\n        dl3 = dlopen(\"libnvidia-ml.so\", RTLD_NOW | RTLD_GLOBAL);    // Try system paths.\n    }\n\n    // Step 3: Try the explicit install default. \n    if (dl3 == NULL && cuda_root != NULL) {                                         // If ROOT given, it doesn't HAVE to work.\n        snprintf(path_lib, 1024, \"%s/lib64/libnvidia-ml.so\", cuda_root);            // PAPI Root check.\n        dl3 = dlopen(path_lib, RTLD_NOW | RTLD_GLOBAL);                             // Try to open that path.\n    }\n\n    // Check for failure.\n    if (dl3 == NULL) {\n        snprintf(_nvml_vector.cmp_info.disabled_reason, PAPI_MAX_STR_LEN, \"libnvidia-ml.so not found.\");\n        return(PAPI_ENOSUPP);   // Not found on default paths.\n    }\n\n    // We have a dl3. (libnvidia-ml.so).\n\n    nvmlDeviceGetClockInfoPtr = dlsym(dl3, \"nvmlDeviceGetClockInfo\");\n    if (dlerror() != NULL) {\n        strncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML function nvmlDeviceGetClockInfo not found.\", PAPI_MAX_STR_LEN);\n        return (PAPI_ENOSUPP);\n    }\n    nvmlErrorStringPtr = dlsym(dl3, \"nvmlErrorString\");\n    if (dlerror() != NULL) {\n        strncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML function nvmlErrorString not found.\", PAPI_MAX_STR_LEN);\n        return (PAPI_ENOSUPP);\n    }\n    nvmlDeviceGetDetailedEccErrorsPtr = dlsym(dl3, \"nvmlDeviceGetDetailedEccErrors\");\n    if (dlerror() != NULL) {\n        strncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML function nvmlDeviceGetDetailedEccErrors not found.\", PAPI_MAX_STR_LEN);\n        return (PAPI_ENOSUPP);\n    }\n    nvmlDeviceGetFanSpeedPtr = dlsym(dl3, \"nvmlDeviceGetFanSpeed\");\n    if (dlerror() != NULL) {\n        strncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML function nvmlDeviceGetFanSpeed not found.\", PAPI_MAX_STR_LEN);\n        return (PAPI_ENOSUPP);\n    }\n    nvmlDeviceGetMemoryInfoPtr = dlsym(dl3, \"nvmlDeviceGetMemoryInfo\");\n    if (dlerror() != NULL) {\n        strncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML function nvmlDeviceGetMemoryInfo not found.\", PAPI_MAX_STR_LEN);\n        return (PAPI_ENOSUPP);\n    }\n    nvmlDeviceGetPerformanceStatePtr = dlsym(dl3, \"nvmlDeviceGetPerformanceState\");\n    if (dlerror() != NULL) {\n        strncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML function nvmlDeviceGetPerformanceState not found.\", PAPI_MAX_STR_LEN);\n        return (PAPI_ENOSUPP);\n    }\n    nvmlDeviceGetPowerUsagePtr = dlsym(dl3, \"nvmlDeviceGetPowerUsage\");\n    if (dlerror() != NULL) {\n        strncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML function nvmlDeviceGetPowerUsage not found.\", PAPI_MAX_STR_LEN);\n        return (PAPI_ENOSUPP);\n    }\n    nvmlDeviceGetTemperaturePtr = dlsym(dl3, \"nvmlDeviceGetTemperature\");\n    if (dlerror() != NULL) {\n        strncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML function nvmlDeviceGetTemperature not found.\", PAPI_MAX_STR_LEN);\n        return (PAPI_ENOSUPP);\n    }\n    nvmlDeviceGetTotalEccErrorsPtr = dlsym(dl3, \"nvmlDeviceGetTotalEccErrors\");\n    if (dlerror() != NULL) {\n        strncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML function nvmlDeviceGetTotalEccErrors not found.\", PAPI_MAX_STR_LEN);\n        return (PAPI_ENOSUPP);\n    }\n    nvmlDeviceGetUtilizationRatesPtr = dlsym(dl3, \"nvmlDeviceGetUtilizationRates\");\n    if (dlerror() != NULL) {\n        strncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML function nvmlDeviceGetUtilizationRates not found.\", PAPI_MAX_STR_LEN);\n        return (PAPI_ENOSUPP);\n    }\n    nvmlDeviceGetHandleByIndexPtr = dlsym(dl3, \"nvmlDeviceGetHandleByIndex\");\n    if (dlerror() != NULL) {\n        strncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML function nvmlDeviceGetHandleByIndex not found.\", PAPI_MAX_STR_LEN);\n        return (PAPI_ENOSUPP);\n    }\n    nvmlDeviceGetPciInfoPtr = dlsym(dl3, \"nvmlDeviceGetPciInfo\");\n    if (dlerror() != NULL) {\n        strncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML function nvmlDeviceGetPciInfo not found.\", PAPI_MAX_STR_LEN);\n        return (PAPI_ENOSUPP);\n    }\n    nvmlDeviceGetNamePtr = dlsym(dl3, \"nvmlDeviceGetName\");\n    if (dlerror() != NULL) {\n        strncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML function nvmlDeviceGetName not found.\", PAPI_MAX_STR_LEN);\n        return (PAPI_ENOSUPP);\n    }\n    nvmlDeviceGetInforomVersionPtr = dlsym(dl3, \"nvmlDeviceGetInforomVersion\");\n    if (dlerror() != NULL) {\n        strncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML function nvmlDeviceGetInforomVersion not found.\", PAPI_MAX_STR_LEN);\n        return (PAPI_ENOSUPP);\n    }\n    nvmlDeviceGetEccModePtr = dlsym(dl3, \"nvmlDeviceGetEccMode\");\n    if (dlerror() != NULL) {\n        strncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML function nvmlDeviceGetEccMode not found.\", PAPI_MAX_STR_LEN);\n        return (PAPI_ENOSUPP);\n    }\n    nvmlInitPtr = dlsym(dl3, \"nvmlInit\");\n    if (dlerror() != NULL) {\n        strncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML function nvmlInit not found.\", PAPI_MAX_STR_LEN);\n        return (PAPI_ENOSUPP);\n    }\n    nvmlDeviceGetCountPtr = dlsym(dl3, \"nvmlDeviceGetCount\");\n    if (dlerror() != NULL) {\n        strncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML function nvmlDeviceGetCount not found.\", PAPI_MAX_STR_LEN);\n        return (PAPI_ENOSUPP);\n    }\n    nvmlShutdownPtr = dlsym(dl3, \"nvmlShutdown\");\n    if (dlerror() != NULL) {\n        strncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML function nvmlShutdown not found.\", PAPI_MAX_STR_LEN);\n        return (PAPI_ENOSUPP);\n    }\n    nvmlDeviceGetPowerManagementLimitPtr = dlsym(dl3, \"nvmlDeviceGetPowerManagementLimit\");\n    if (dlerror() != NULL) {\n        strncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML function nvmlDeviceGetPowerManagementLimit not found.\", PAPI_MAX_STR_LEN);\n        return (PAPI_ENOSUPP);\n    }\n    nvmlDeviceSetPowerManagementLimitPtr = dlsym(dl3, \"nvmlDeviceSetPowerManagementLimit\");\n    if (dlerror() != NULL) {\n        strncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML function nvmlDeviceSetPowerManagementLimit not found.\", PAPI_MAX_STR_LEN);\n        return (PAPI_ENOSUPP);\n    }\n    nvmlDeviceGetPowerManagementLimitConstraintsPtr = dlsym(dl3, \"nvmlDeviceGetPowerManagementLimitConstraints\");\n    if (dlerror() != NULL) {\n        strncpy(_nvml_vector.cmp_info.disabled_reason, \"NVML function nvmlDeviceGetPowerManagementLimitConstraints not found.\", PAPI_MAX_STR_LEN);\n        return (PAPI_ENOSUPP);\n    }\n    return (PAPI_OK);\n}\n\n/** Setup a counter control state.\n *   In general a control state holds the hardware info for an\n *   EventSet.\n */\n\nint\n_papi_nvml_init_control_state(hwd_control_state_t * ctl)\n{\n    SUBDBG(\"nvml_init_control_state... %p\\n\", ctl);\n    nvml_control_state_t *nvml_ctl = (nvml_control_state_t *) ctl;\n    memset(nvml_ctl, 0, sizeof(nvml_control_state_t));\n\n    return PAPI_OK;\n}\n\n/** Triggered by eventset operations like add or remove */\nint\n_papi_nvml_update_control_state(hwd_control_state_t *ctl,\n                                NativeInfo_t *native,\n                                int count,\n                                hwd_context_t *ctx)\n{\n    SUBDBG(\"Enter: ctl: %p, ctx: %p\\n\", ctl, ctx);\n    int i, index;\n\n    nvml_control_state_t *nvml_ctl = (nvml_control_state_t *) ctl;\n    (void) ctx;\n\n    /* if no events, return */\n    if (count == 0) return PAPI_OK;\n\n    for (i = 0; i < count; i++) {\n        index = native[i].ni_event;\n        nvml_ctl->which_counter[i] = index;\n        /* We have no constraints on event position, so any event */\n        /* can be in any slot.                                    */\n        native[i].ni_position = i;\n    }\n    nvml_ctl->num_events = count;\n    return PAPI_OK;\n}\n/** Triggered by PAPI_start() */\nint\n_papi_nvml_start(hwd_context_t *ctx, hwd_control_state_t *ctl)\n{\n    SUBDBG(\"Enter: ctx: %p, ctl: %p\\n\", ctx, ctl);\n\n    (void) ctx;\n    (void) ctl;\n\n    /* anything that would need to be set at counter start time */\n\n    /* reset */\n    /* start the counting */\n\n    return PAPI_OK;\n}\n\n/** Triggered by PAPI_stop() */\nint\n_papi_nvml_stop(hwd_context_t *ctx, hwd_control_state_t *ctl)\n{\n    SUBDBG(\"Enter: ctx: %p, ctl: %p\\n\", ctx, ctl);\n\n    int i;\n    (void) ctx;\n    (void) ctl;\n    int ret;\n\n    nvml_control_state_t* nvml_ctl = (nvml_control_state_t*) ctl;\n\n    for (i = 0; i < nvml_ctl->num_events; i++) {\n        if (PAPI_OK !=\n                (ret = nvml_hardware_read(&nvml_ctl->counter[i],\n                                          nvml_ctl->which_counter[i])))\n            return ret;\n\n    }\n\n    return PAPI_OK;\n}\n\n/** Triggered by PAPI_read() */\nint\n_papi_nvml_read(hwd_context_t *ctx, hwd_control_state_t *ctl,\n                long long **events, int flags)\n{\n    SUBDBG(\"Enter: ctx: %p, flags: %d\\n\", ctx, flags);\n\n    (void) ctx;\n    (void) flags;\n    int i;\n    int ret;\n    nvml_control_state_t* nvml_ctl = (nvml_control_state_t*) ctl;\n\n    for (i = 0; i < nvml_ctl->num_events; i++) {\n        if (PAPI_OK !=\n                (ret = nvml_hardware_read(&nvml_ctl->counter[i],\n                                          nvml_ctl->which_counter[i])))\n            return ret;\n\n    }\n    /* return pointer to the values we read */\n    *events = nvml_ctl->counter;\n    return PAPI_OK;\n}\n\n/** Triggered by PAPI_write(), but only if the counters are running */\n/*    otherwise, the updated state is written to ESI->hw_start      */\nint\n_papi_nvml_write(hwd_context_t *ctx, hwd_control_state_t *ctl, long long *events)\n{\n    SUBDBG(\"Enter: ctx: %p, ctl: %p\\n\", ctx, ctl);\n    (void) ctx;\n    nvml_control_state_t* nvml_ctl = (nvml_control_state_t*) ctl;\n    int i;\n    int ret;\n\n    /* You can change ECC mode and compute exclusivity modes on the cards */\n    /* But I don't see this as a function of a PAPI component at this time */\n    /* All implementation issues aside. */\n\n    // Currently POWER_MANAGEMENT can be written\n    for (i = 0; i < nvml_ctl->num_events; i++) {\n        if (PAPI_OK != (ret = nvml_hardware_write(&events[i], nvml_ctl->which_counter[i])))\n            return ret;\n    }\n\n    /* return pointer to the values we read */\n    return PAPI_OK;\n}\n\n/** Triggered by PAPI_reset() but only if the EventSet is currently running */\n/*  If the eventset is not currently running, then the saved value in the   */\n/*  EventSet is set to zero without calling this routine.                   */\nint\n_papi_nvml_reset(hwd_context_t * ctx, hwd_control_state_t * ctl)\n{\n    SUBDBG(\"Enter: ctx: %p, ctl: %p\\n\", ctx, ctl);\n\n    (void) ctx;\n    (void) ctl;\n\n    /* Reset the hardware */\n    nvml_hardware_reset();\n\n    return PAPI_OK;\n}\n\n/** Called at thread shutdown */\nint\n_papi_nvml_shutdown_thread(hwd_context_t *ctx)\n{\n    SUBDBG(\"Enter: ctx: %p\\n\", ctx);\n\n    (void) ctx;\n\n    /* Last chance to clean up thread */\n\n    return PAPI_OK;\n}\n\n/** This function sets various options in the component\n  @param code valid are PAPI_SET_DEFDOM, PAPI_SET_DOMAIN, PAPI_SETDEFGRN, PAPI_SET_GRANUL and PAPI_SET_INHERIT\n */\nint\n_papi_nvml_ctl(hwd_context_t * ctx, int code, _papi_int_option_t * option)\n{\n    SUBDBG(\"Enter: ctx: %p, code: %d\\n\", ctx, code);\n\n    (void) ctx;\n    (void) code;\n    (void) option;\n\n    /* FIXME.  This should maybe set up more state, such as which counters are active and */\n    /*         counter mappings. */\n\n    return PAPI_OK;\n}\n\n/** This function has to set the bits needed to count different domains\n  In particular: PAPI_DOM_USER, PAPI_DOM_KERNEL PAPI_DOM_OTHER\n  By default return PAPI_EINVAL if none of those are specified\n  and PAPI_OK with success\n  PAPI_DOM_USER is only user context is counted\n  PAPI_DOM_KERNEL is only the Kernel/OS context is counted\n  PAPI_DOM_OTHER  is Exception/transient mode (like user TLB misses)\n  PAPI_DOM_ALL   is all of the domains\n */\nint\n_papi_nvml_set_domain(hwd_control_state_t * cntrl, int domain)\n{\n    SUBDBG(\"Enter: cntrl: %p, domain: %d\\n\", cntrl, domain);\n\n    (void) cntrl;\n\n    int found = 0;\n\n    if (PAPI_DOM_USER & domain) {\n        SUBDBG(\" PAPI_DOM_USER \\n\");\n        found = 1;\n    }\n    if (PAPI_DOM_KERNEL & domain) {\n        SUBDBG(\" PAPI_DOM_KERNEL \\n\");\n        found = 1;\n    }\n    if (PAPI_DOM_OTHER & domain) {\n        SUBDBG(\" PAPI_DOM_OTHER \\n\");\n        found = 1;\n    }\n    if (PAPI_DOM_ALL & domain) {\n        SUBDBG(\" PAPI_DOM_ALL \\n\");\n        found = 1;\n    }\n    if (!found)\n        return (PAPI_EINVAL);\n\n    return PAPI_OK;\n}\n\n/**************************************************************/\n/* Naming functions, used to translate event numbers to names */\n/**************************************************************/\n\n/** Enumerate Native Events\n *   @param EventCode is the event of interest\n *   @param modifier is one of PAPI_ENUM_FIRST, PAPI_ENUM_EVENTS\n *  If your component has attribute masks then these need to\n *   be handled here as well.\n */\nint\n_papi_nvml_ntv_enum_events(unsigned int *EventCode, int modifier)\n{\n    int index;\n\n    switch (modifier) {\n\n    /* return EventCode of first event */\n    case PAPI_ENUM_FIRST:\n        /* return the first event that we support */\n\n        *EventCode = 0;\n        return PAPI_OK;\n\n    /* return EventCode of next available event */\n    case PAPI_ENUM_EVENTS:\n        index = *EventCode;\n\n        /* Make sure we are in range */\n        if (index < num_events - 1) {\n\n            /* This assumes a non-sparse mapping of the events */\n            *EventCode = *EventCode + 1;\n            return PAPI_OK;\n        } else {\n            return PAPI_ENOEVNT;\n        }\n        break;\n\n    default:\n        return PAPI_EINVAL;\n    }\n\n    return PAPI_EINVAL;\n}\n\n/** Takes a native event code and passes back the name\n * @param EventCode is the native event code\n * @param name is a pointer for the name to be copied to\n * @param len is the size of the name string\n */\nint\n_papi_nvml_ntv_code_to_name(unsigned int EventCode, char *name, int len)\n{\n    SUBDBG(\"Entry: EventCode: %#x, name: %s, len: %d\\n\", EventCode, name, len);\n    int index;\n\n    index = EventCode;\n\n    /* Make sure we are in range */\n    if (index >= num_events) return PAPI_ENOEVNT;\n\n    strncpy(name, nvml_native_table[index].name, len);\n\n    return PAPI_OK;\n}\n\n/** Takes a native event code and passes back the event description\n * @param EventCode is the native event code\n * @param descr is a pointer for the description to be copied to\n * @param len is the size of the descr string\n */\nint\n_papi_nvml_ntv_code_to_descr(unsigned int EventCode, char *descr, int len)\n{\n    int index;\n    index = EventCode;\n\n    if (index >= num_events) return PAPI_ENOEVNT;\n\n    strncpy(descr, nvml_native_table[index].description, len);\n\n    return PAPI_OK;\n}\n\n/** Takes a native event code and passes back the event info\n * @param EventCode is the native event code\n * @param info is a pointer for the info to be copied to\n */\nint\n_papi_nvml_ntv_code_to_info(unsigned int EventCode, PAPI_event_info_t *info)\n{\n\n    int index = EventCode;\n\n    if ((index < 0) || (index >= num_events)) return PAPI_ENOEVNT;\n\n    strncpy(info->symbol, nvml_native_table[index].name, sizeof(info->symbol) - 1);\n    info->symbol[sizeof(info->symbol) - 1] = '\\0';\n\n    strncpy(info->units, nvml_native_table[index].units, sizeof(info->units) - 1);\n    info->units[sizeof(info->units) - 1] = '\\0';\n\n    strncpy(info->long_descr, nvml_native_table[index].description, sizeof(info->long_descr) - 1);\n    info->long_descr[sizeof(info->long_descr) - 1] = '\\0';\n\n//  info->data_type = nvml_native_table[index].return_type;\n\n    return PAPI_OK;\n}\n\n/** Vector that points to entry points for our component */\npapi_vector_t _nvml_vector = {\n    .cmp_info = {\n        /* default component information */\n        /* (unspecified values are initialized to 0) */\n\n        .name = \"nvml\",\n        .short_name = \"nvml\",\n        .version = \"1.0\",\n        .description = \"NVML provides the API for monitoring NVIDIA hardware (power usage, temperature, fan speed, etc)\",\n        .support_version = \"n/a\",\n        .kernel_version = \"n/a\",\n\n        .num_preset_events = 0,\n        .num_native_events = 0, /* set by init_component */\n        .default_domain = PAPI_DOM_USER,\n        .available_domains = PAPI_DOM_USER,\n        .default_granularity = PAPI_GRN_THR,\n        .available_granularities = PAPI_GRN_THR,\n        .hardware_intr_sig = PAPI_INT_SIGNAL,\n\n        /* component specific cmp_info initializations */\n        .hardware_intr = 0,\n        .precise_intr = 0,\n        .posix1b_timers = 0,\n        .kernel_profile = 0,\n        .kernel_multiplex = 0,\n        .fast_counter_read = 0,\n        .fast_real_timer = 0,\n        .fast_virtual_timer = 0,\n        .attach = 0,\n        .attach_must_ptrace = 0,\n        .cntr_umasks = 0,\n        .cpu = 0,\n        .inherit = 0,\n    },\n\n    /* sizes of framework-opaque component-private structures */\n    .size = {\n        .context = sizeof(nvml_context_t),\n        .control_state = sizeof(nvml_control_state_t),\n        .reg_value = sizeof(nvml_register_t),\n        // .reg_alloc = sizeof ( nvml_reg_alloc_t ),\n    },\n\n    /* function pointers */\n\n    /* Used for general PAPI interactions */\n    .start =                _papi_nvml_start,\n    .stop =                 _papi_nvml_stop,\n    .read =                 _papi_nvml_read,\n    .reset =                _papi_nvml_reset,\n    .write =                _papi_nvml_write,\n    .init_component =       _papi_nvml_init_component,\n    .init_thread =          _papi_nvml_init_thread,\n    .init_control_state =   _papi_nvml_init_control_state,\n    .update_control_state = _papi_nvml_update_control_state,\n    .ctl =                  _papi_nvml_ctl,\n    .shutdown_thread =      _papi_nvml_shutdown_thread,\n    .shutdown_component =   _papi_nvml_shutdown_component,\n    .set_domain =           _papi_nvml_set_domain,\n    .cleanup_eventset =     NULL,\n    /* called in add_native_events() */\n    .allocate_registers =   NULL,\n\n    /* Used for overflow/profiling */\n    .dispatch_timer =       NULL,\n    .get_overflow_address = NULL,\n    .stop_profiling =       NULL,\n    .set_overflow =         NULL,\n    .set_profile =          NULL,\n\n    /* Name Mapping Functions */\n    .ntv_enum_events =   _papi_nvml_ntv_enum_events,\n    .ntv_name_to_code  = NULL,\n    .ntv_code_to_name =  _papi_nvml_ntv_code_to_name,\n    .ntv_code_to_descr = _papi_nvml_ntv_code_to_descr,\n    .ntv_code_to_info = _papi_nvml_ntv_code_to_info,\n\n};\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-papi-6.0.0.1-gmm3tef6bggycxgzrtmq2ejaggc2ozfb/spack-src/src/components/nvml/tests/benchSANVML.c": "//-----------------------------------------------------------------------------\n//-----------------------------------------------------------------------------\n// This bench interacts directly with NVML from a main(). The objective here is\n// to test reading and setting of a power limit without PAPI, to determine if \n// errors are PAPI related or not. It can be modified to test other NVML\n// events.\n//\n// Much of this code is scavenged from linux-nvml.c. \n// Author: Tony Castaldo (tonycastaldo@icl.utk.edu).\n//-----------------------------------------------------------------------------\n//-----------------------------------------------------------------------------\n\n#include <unistd.h>\n#include <errno.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <ctype.h>\n#include <math.h>\n#include <sys/time.h>\n#include <dlfcn.h>      // Dynamic lib routines; especially dlsym to get func ptrs.\n\n#include \"nvml.h\"\n#include \"cuda.h\"\n#include \"cuda_runtime_api.h\"\n\n/*****  CHANGE PROTOTYPES TO DECLARE CUDA AND NVML LIBRARY SYMBOLS AS WEAK  *****\n *  This is done so that a version of PAPI built with the nvml component can    *\n *  be installed on a system which does not have the cuda libraries installed.  *\n *                                                                              *\n *  If this is done without these prototypes, then all papi services on the     *\n *  system without the cuda libraries installed will fail.  The PAPI libraries  *\n *  contain references to the cuda libraries which are not installed.  The      *\n *  load of PAPI commands fails because the cuda library references can not be  *\n *  resolved.                                                                   *\n *                                                                              *\n *  This also defines pointers to the cuda library functions that we call.      *\n *  These function pointers will be resolved with dlopen/dlsym calls at         *\n *  component initialization time.  The component then calls the cuda library   *\n *  functions through these function pointers.                                  *\n ********************************************************************************/\n#undef CUDAAPI\n#define CUDAAPI __attribute__((weak))\nCUresult CUDAAPI (*cuInitPtr)(unsigned int);\nCUresult CUDAAPI cuInit(unsigned int myInt) {return (*cuInitPtr)(myInt);}\n\n#undef CUDARTAPI\n#define CUDARTAPI __attribute__((weak))\n\ncudaError_t (*cudaGetDevicePtr)(int *);\ncudaError_t (*cudaGetDeviceCountPtr)(int *);\ncudaError_t (*cudaDeviceGetPCIBusIdPtr)(char *, int, int);\n\ncudaError_t CUDARTAPI cudaGetDevice(int *dest) {return (*cudaGetDevicePtr)(dest); };\ncudaError_t CUDARTAPI cudaGetDeviceCount(int *dest) {return (*cudaGetDeviceCountPtr)(dest);}\ncudaError_t CUDARTAPI cudaDeviceGetPCIBusId(char *, int, int);\n\n#undef DECLDIR\n#define DECLDIR __attribute__((weak))\n\nchar* (*nvmlErrorStringPtr)(nvmlReturn_t);\nnvmlReturn_t (*nvmlDeviceGetClockInfoPtr)(nvmlDevice_t, nvmlClockType_t, unsigned int *);\nnvmlReturn_t (*nvmlDeviceGetCountPtr)(unsigned int *dest);\nnvmlReturn_t (*nvmlDeviceGetDetailedEccErrorsPtr)(nvmlDevice_t, nvmlEccBitType_t, nvmlEccCounterType_t, nvmlEccErrorCounts_t *);\nnvmlReturn_t (*nvmlDeviceGetEccModePtr)(nvmlDevice_t, nvmlEnableState_t *, nvmlEnableState_t *);\nnvmlReturn_t (*nvmlDeviceGetFanSpeedPtr)(nvmlDevice_t, unsigned int *);\nnvmlReturn_t (*nvmlDeviceGetHandleByIndexPtr)(unsigned int, nvmlDevice_t *);\nnvmlReturn_t (*nvmlDeviceGetInforomVersionPtr)(nvmlDevice_t, nvmlInforomObject_t, char *, unsigned int);\nnvmlReturn_t (*nvmlDeviceGetMemoryInfoPtr)(nvmlDevice_t, nvmlMemory_t *);\nnvmlReturn_t (*nvmlDeviceGetNamePtr)(nvmlDevice_t, char *, unsigned int);\nnvmlReturn_t (*nvmlDeviceGetPciInfoPtr)(nvmlDevice_t, nvmlPciInfo_t *);\nnvmlReturn_t (*nvmlDeviceGetPerformanceStatePtr)(nvmlDevice_t, nvmlPstates_t *);\nnvmlReturn_t (*nvmlDeviceGetPowerManagementLimitConstraintsPtr)(nvmlDevice_t device, unsigned int* minLimit, unsigned int* maxLimit);\nnvmlReturn_t (*nvmlDeviceGetPowerManagementLimitPtr)(nvmlDevice_t device, unsigned int* limit);\nnvmlReturn_t (*nvmlDeviceGetPowerUsagePtr)(nvmlDevice_t, unsigned int *);\nnvmlReturn_t (*nvmlDeviceGetTemperaturePtr)(nvmlDevice_t, nvmlTemperatureSensors_t, unsigned int *);\nnvmlReturn_t (*nvmlDeviceGetTotalEccErrorsPtr)(nvmlDevice_t, nvmlEccBitType_t, nvmlEccCounterType_t, unsigned long long *);\nnvmlReturn_t (*nvmlDeviceGetUtilizationRatesPtr)(nvmlDevice_t, nvmlUtilization_t *);\nnvmlReturn_t (*nvmlDeviceSetPowerManagementLimitPtr)(nvmlDevice_t device, unsigned int  limit);\nnvmlReturn_t (*nvmlInitPtr)(void);\nnvmlReturn_t (*nvmlShutdownPtr)(void);\n\nconst char*  DECLDIR nvmlErrorString(nvmlReturn_t);\nnvmlReturn_t DECLDIR nvmlDeviceGetClockInfo(nvmlDevice_t, nvmlClockType_t, unsigned int *);\nnvmlReturn_t DECLDIR nvmlDeviceGetCount(unsigned int *dest){return (*nvmlDeviceGetCountPtr)(dest);}\nnvmlReturn_t DECLDIR nvmlDeviceGetDetailedEccErrors(nvmlDevice_t, nvmlEccBitType_t, nvmlEccCounterType_t, nvmlEccErrorCounts_t *);\nnvmlReturn_t DECLDIR nvmlDeviceGetEccMode(nvmlDevice_t, nvmlEnableState_t *, nvmlEnableState_t *);\nnvmlReturn_t DECLDIR nvmlDeviceGetFanSpeed(nvmlDevice_t, unsigned int *);\nnvmlReturn_t DECLDIR nvmlDeviceGetHandleByIndex(unsigned int idx, nvmlDevice_t *dest) {return (*nvmlDeviceGetHandleByIndexPtr)(idx, dest); }\nnvmlReturn_t DECLDIR nvmlDeviceGetInforomVersion(nvmlDevice_t, nvmlInforomObject_t, char *, unsigned int);\nnvmlReturn_t DECLDIR nvmlDeviceGetMemoryInfo(nvmlDevice_t, nvmlMemory_t *);\nnvmlReturn_t DECLDIR nvmlDeviceGetName(nvmlDevice_t device, char *name, unsigned int len) {(*nvmlDeviceGetNamePtr)(device, name, len); }\nnvmlReturn_t DECLDIR nvmlDeviceGetPciInfo(nvmlDevice_t, nvmlPciInfo_t *);\nnvmlReturn_t DECLDIR nvmlDeviceGetPerformanceState(nvmlDevice_t, nvmlPstates_t *);\nnvmlReturn_t DECLDIR nvmlDeviceGetPowerManagementLimit(nvmlDevice_t device, unsigned int* limit) {\n                     (*nvmlDeviceGetPowerManagementLimitPtr)(device, limit); }\nnvmlReturn_t DECLDIR nvmlDeviceGetPowerManagementLimitConstraints(nvmlDevice_t device, unsigned int* minLimit, unsigned int* maxLimit) {\n                     (*nvmlDeviceGetPowerManagementLimitConstraintsPtr)(device, minLimit, maxLimit); }\nnvmlReturn_t DECLDIR nvmlDeviceGetPowerUsage(nvmlDevice_t device, unsigned int *dest) {\n                     (*nvmlDeviceGetPowerUsagePtr)(device, dest); }\nnvmlReturn_t DECLDIR nvmlDeviceGetTemperature(nvmlDevice_t, nvmlTemperatureSensors_t, unsigned int *);\nnvmlReturn_t DECLDIR nvmlDeviceGetTotalEccErrors(nvmlDevice_t, nvmlEccBitType_t, nvmlEccCounterType_t, unsigned long long *);\nnvmlReturn_t DECLDIR nvmlDeviceGetUtilizationRates(nvmlDevice_t, nvmlUtilization_t *);\nnvmlReturn_t DECLDIR nvmlDeviceSetPowerManagementLimit(nvmlDevice_t device, unsigned int  limit) {\n                     (*nvmlDeviceSetPowerManagementLimitPtr)(device, limit); }\nnvmlReturn_t DECLDIR nvmlInit(void){return (*nvmlInitPtr)();}\nnvmlReturn_t DECLDIR nvmlShutdown(void);\n\n// file handles used to access cuda libraries with dlopen\nstatic void* dl1 = NULL;\nstatic void* dl2 = NULL;\nstatic void* dl3 = NULL;\n\nstatic struct timeval t1, t2;                                        // used in timing routines to measure performance.\n\n//-----------------------------------------------------------------------------\n// Union to convert pointers and avoid warnings. Plug in one, pull out the other.\n//-----------------------------------------------------------------------------\ntypedef union  \n{\n   void                 *vPtr;\n   int                  *iPtr;\n   unsigned int         *uiPtr;\n   long                 *lPtr;\n   long long            *llPtr;\n   unsigned long long   *ullPtr;\n   float                *fPtr;\n   double               *dPtr;\n   char                 *cPtr;\n} uPointer_t;\n\ntypedef union\n{\n   long long ll;\n   unsigned long long ull;\n   double    d;\n   void *vp;\n   unsigned char ch[8];\n} convert_64_t;\n\n\n// -------------------------- GLOBAL SECTION ---------------------------------\n\n//--------------------------------------------------------------------\n// Timing of routines and blocks. Typical usage;\n// gettimeofday(&t1, NULL);                  // starting point.\n// ... some code to execute ...\n// gettimeofday(&t2, NULL);                  // finished timing.\n// fprintf(stderr, \"routine took %li uS.\\n\", // report time.\n//                       (mConvertUsec(t2)-mConvertUsec(t1)));\n#define _prog_fprintf if (1) fprintf                                    /* change to 1 to enable printing of progress debug messages. TURN OFF if benchmark timing.    */\n#define _time_fprintf if (1) fprintf                                    /* change to 1 to enable printing of performance timings.     TURN OFF if benchmark timing.    */\n\n//-----------------------------------------------------------------------------\n// Using weak symbols (global declared without a value, so it defers to any\n// other global declared in another file WITH a value) allows PAPI to be built\n// with the component, but PAPI can still be installed in a system without the\n// required library.\n//-----------------------------------------------------------------------------\n\nvoid (*_dl_non_dynamic_init)(void) __attribute__((weak));               // declare a weak dynamic-library init routine pointer.\n\n/** Number of devices detected at component_init time */\nstatic int device_count = 0;\n\nstatic nvmlDevice_t* devices = NULL;\nstatic int* features = NULL;\nstatic unsigned int *power_management_initial_limit = NULL;\nstatic unsigned int *power_management_limit_constraint_min = NULL;\nstatic unsigned int *power_management_limit_constraint_max = NULL;\n\n//-----------------------------------------------------------------------------\n// Get all needed function pointers from the Dynamic Link Library. \n//-----------------------------------------------------------------------------\n\n// MACRO checks for Dynamic Lib failure, reports, returns Not Supported.\n#define mCheck_DL_Status( err, str )                                          \\\n   if( err )                                                                  \\\n   {                                                                          \\\n      fprintf(stderr, str);                                                   \\\n      return(-1);                                                             \\\n   }\n\n// keys for above: Init, InitThrd, InitCtlSt, Stop, ShutdownThrd, ShutdownCmp, Start,\n// UpdateCtl, Read, Ctl, SetDom, Reset, Enum, EnumFirst, EnumNext, EnumUmasks, \n// NameToCode, CodeToName, CodeToDesc, CodeToInfo.\n\n// Simplify routine below; relies on ptr names being same as func tags.\n#define STRINGIFY(x) #x \n#define TOSTRING(x) STRINGIFY(x)\n#define mGet_DL_FPtr(libPtr, Name)                                         \\\n   Name##Ptr = dlsym(libPtr, TOSTRING(Name));                              \\\n   mCheck_DL_Status(dlerror()!=NULL, TOSTRING(libPtr) \" Library function \" \\\n                  TOSTRING(Name) \" not found.\");\n\nint _local_linkDynamicLibraries(void) \n{\n   if (_dl_non_dynamic_init != NULL) {    // If weak var is present, we are statically linked instead of dynamically.\n      fprintf(stderr, \"NVML component does not support statically linked libc.\");\n      return (-1);\n   }\n\n   // Exit if we cannot link the cuda or NVML libs.\n   dl1 = dlopen(\"libcuda.so\", RTLD_NOW | RTLD_GLOBAL);\n   if (!dl1) {\n      fprintf(stderr, \"CUDA library libcuda.so not found.\");\n      return (-1);\n   }\n\n   dl2 = dlopen(\"libcudart.so\", RTLD_NOW | RTLD_GLOBAL | RTLD_NODELETE);\n   if (!dl2) {\n      fprintf(stderr, \"CUDA runtime library libcudart.so not found.\");\n      return (-1);\n   }\n\n   dl3 = dlopen(\"libnvidia-ml.so\", RTLD_NOW | RTLD_GLOBAL);\n   if (!dl3) {\n      fprintf(stderr, \"NVML runtime library libnvidia-ml.so not found.\");\n       return (-1);\n   }\n\n//-----------------------------------------------------------------------------\n// Collect pointers for routines in shared library.  All below will abort this\n// routine with -1, the routine is not found in the dynamic library.\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n// Collect pointers for routines in shared library.  All below will abort this\n// routine with -1, the routine is not found in the dynamic library.\n//-----------------------------------------------------------------------------\n\n   mGet_DL_FPtr(dl1, cuInit);\n\n   mGet_DL_FPtr(dl2, cudaGetDevice);\n   mGet_DL_FPtr(dl2, cudaGetDeviceCount);\n   mGet_DL_FPtr(dl2, cudaDeviceGetPCIBusId);\n\n   mGet_DL_FPtr(dl3, nvmlDeviceGetClockInfo);\n   mGet_DL_FPtr(dl3, nvmlErrorString);\n   mGet_DL_FPtr(dl3, nvmlDeviceGetDetailedEccErrors);\n   mGet_DL_FPtr(dl3, nvmlDeviceGetFanSpeed);\n   mGet_DL_FPtr(dl3, nvmlDeviceGetMemoryInfo);\n   mGet_DL_FPtr(dl3, nvmlDeviceGetPerformanceState);\n   mGet_DL_FPtr(dl3, nvmlDeviceGetPowerUsage);\n   mGet_DL_FPtr(dl3, nvmlDeviceGetTemperature);\n   mGet_DL_FPtr(dl3, nvmlDeviceGetTotalEccErrors);\n   mGet_DL_FPtr(dl3, nvmlDeviceGetUtilizationRates);\n   mGet_DL_FPtr(dl3, nvmlDeviceGetHandleByIndex);\n   mGet_DL_FPtr(dl3, nvmlDeviceGetPciInfo);\n   mGet_DL_FPtr(dl3, nvmlDeviceGetName);\n   mGet_DL_FPtr(dl3, nvmlDeviceGetInforomVersion);\n   mGet_DL_FPtr(dl3, nvmlDeviceGetEccMode);\n   mGet_DL_FPtr(dl3, nvmlInit);\n   mGet_DL_FPtr(dl3, nvmlDeviceGetCount);\n   mGet_DL_FPtr(dl3, nvmlShutdown);\n   mGet_DL_FPtr(dl3, nvmlDeviceGetPowerManagementLimit);\n   mGet_DL_FPtr(dl3, nvmlDeviceSetPowerManagementLimit);\n   mGet_DL_FPtr(dl3, nvmlDeviceGetPowerManagementLimitConstraints);\n\n   return 0;         // If we get here, all above succeeded. \n} // end routine.\n\n//----------------------------------------------------------------------------\n// main(). intialize the lib, then work on reading the value. \n//---------------------------------------------------------------------------\nint main (int argc, char **argv) \n{\n   (void) argc; (void) argv;                                            // Prevent not used warning.\n   #define hostnameLen 512 /* constant used multiple times. */\n   char hostname[hostnameLen];                                          // host name.\n   int  i, j, ret;\n   int cuda_count, nvml_count;\n    nvmlReturn_t nvret;\n    cudaError_t cuerr;\n\n   //-------------------------------------------------------------------\n   // Begin initialization timing.\n   //-------------------------------------------------------------------\n\n   gettimeofday(&t1, NULL);\n   ret = _local_linkDynamicLibraries();\n   if ( ret != 0) {                                                     // Failure to get lib.\n      fprintf(stderr, \"Failed attempt to link to CUDA and NVML libraries.\");\n      exit(-1); \n   }\n\n   _prog_fprintf(stderr, \"Linked to CUDA and NVML libraries\\n\");        // debug only; turn off if timing.\n   \n   nvret = nvmlInit();                                                  // Initialize the library.\n   if (nvret != NVML_SUCCESS) {\n      fprintf(stderr, \"Failed nvmlInit(), ret=%i [%s].\\n\", nvret, nvmlErrorString(nvret));\n      exit(-1);\n   }\n\n   nvret = cuInit(0);                                                   // Initialize the CUDA library.\n   if (nvret != cudaSuccess) {\n      fprintf(stderr, \"Failed cuInit(0).\\n\");\n      exit(-1);\n   }\n\n   nvret = nvmlDeviceGetCount(&nvml_count);                             // Get the device count.\n   if (nvret != NVML_SUCCESS) {\n      fprintf(stderr, \"nvmlDeviceGetCount failed; ret=%i.\\n\", nvret);   // Report an error.\n      exit(-1);\n   }\n\n   nvret = cudaGetDeviceCount(&cuda_count);                             // Get the device count.\n   if (nvret != cudaSuccess) {\n      fprintf(stderr, \"cudaGetDeviceCount failed; ret=%i.\\n\", nvret);   // Report an error.\n      exit(-1);\n   }\n\n\n   ret = gethostname(hostname, hostnameLen);                            // Try to get the host hame.\n   if( gethostname(hostname, hostnameLen) != 0) {                       // If we can't get the hostname, \n      fprintf(stderr, \"Failed system call, gethostname() \"\n            \"returned %i.\", ret);\n   exit(-1);\n   }\n   #undef hostnameLen /* done with it. */\n\n   fprintf(stderr, \"hostname: %s\\n\"\n                   \"nvml_count=%i\\n\"\n                   \"cuda_count=%i\\n\", hostname, nvml_count, cuda_count);\n\n   nvmlDevice_t *handle = malloc(nvml_count * sizeof(nvmlDevice_t));    // for all device handles.\n   char name[128];                                                      // space for device name.\n   unsigned int powerUsage, powerLimit, powerLimit2;                    // for the power usage and limit.\n   unsigned int minPower, maxPower;                                     // Minimum and Maximum power.\n\n   // scan all the devices.\n   for (i=0; i<nvml_count; i++) {                                       // Get all the handles; print as we go.\n      nvret = nvmlDeviceGetHandleByIndex(i, &handle[i]);                // Read the handle.\n      if (nvret != NVML_SUCCESS) {\n         fprintf(stderr, \"nvmlDeviceGetHandleByIndex %i failed; nvret=%i [%s].\\n\", i, nvret, nvmlErrorString(nvret));\n         handle[i]=NULL;                                                // Set to bad value. \n         continue;                                                      // skip trying this one.\n      }\n \n      fprintf(stderr, \"Handle %i: %016lX\\n\", i, handle[i]);             // Show the handles.\n\n      nvret = nvmlDeviceGetName(handle[i], name, sizeof(name)-1);       // Get the name.\n      name[sizeof(name)-1]='\\0';                                        // Ensure z-termination.\n      fprintf(stderr, \"Name='%s'.\\n\", name);                            // Show the name.\n\n      nvret = nvmlDeviceGetPowerUsage(handle[i], &powerUsage);          // Attempt to get power usage.\n      if (nvret != NVML_SUCCESS) {                                      // If it failed,\n         fprintf(stderr, \"nvmlDeviceGetPowerUsage failed; nvret=%i [%s]\\n\", nvret, nvmlErrorString(nvret));\n      } else {\n         fprintf(stderr, \"nvmlDeviceGetPowerUsage succeeded, value returned=%u mw.\\n\", powerUsage);\n      }\n\n      nvret = nvmlDeviceGetPowerManagementLimit(handle[i], &powerLimit);// Attempt to get power limit.\n      if (nvret != NVML_SUCCESS) {                                      // If it failed,\n         fprintf(stderr, \"nvmlDeviceGetPowerManagementLimit failed; nvret=%i [%s]\\n\", nvret, nvmlErrorString(nvret));\n      } else {\n         fprintf(stderr, \"nvmlDeviceGetPowerManagementLimit succeeded, value returned=%u mw.\\n\", powerLimit);\n      }\n\n      nvret = nvmlDeviceGetPowerManagementLimitConstraints(handle[i], &minPower, &maxPower);// Attempt to get min and max of power limit.\n      if (nvret != NVML_SUCCESS) {                                      // If it failed,\n         fprintf(stderr, \"nvmlDeviceGetPowerManagementLimitConstraints failed; nvret=%i [%s]\\n\", nvret, nvmlErrorString(nvret));\n      } else {\n         fprintf(stderr, \"nvmlDeviceGetPowerManagementLimitConstraints succeeded, values min=%u mw, max=%u mw.\\n\", minPower, maxPower);\n      }\n\n      // Test setting the power, to top-100.\n      unsigned int newPower=maxPower-100;                                     // compute a new power setting.\n      nvret = nvmlDeviceSetPowerManagementLimit(handle[i], newPower);         // Attempt to set it.\n      if (nvret != NVML_SUCCESS) {                                            // If it failed,\n         fprintf(stderr, \"nvmlDeviceSetPowerManagementLimit to %i failed; nvret=%i [%s]\\n\", newPower, nvret, nvmlErrorString(nvret));\n      } else {\n         fprintf(stderr, \"nvmlDeviceSetPowerManagementLimit to %i succeeded. (Routine call did not return error).\\n\", newPower);\n      }\n\n      nvret = nvmlDeviceGetPowerManagementLimit(handle[i], &powerLimit2);     // Attempt to get new power limit.\n      if (nvret != NVML_SUCCESS) {                                            // If it failed,\n         fprintf(stderr, \"nvmlDeviceGetPowerManagementLimit failed; nvret=%i [%s]\\n\", nvret, nvmlErrorString(nvret));\n      } else {\n         fprintf(stderr, \"nvmlDeviceGetPowerManagementLimit call to check setting succeeded, value returned=%u mw.\\n\", powerLimit2);\n         if (powerLimit2 != newPower) {\n            fprintf(stderr, \"Note the check failed, the limit read is not the limit we tried to set.\\n\");\n         } else {\n            fprintf(stderr, \"Note the check is a success, the power limit was changed.\\n\");\n         }\n      }\n\n      nvret = nvmlDeviceSetPowerManagementLimit(handle[i], powerLimit);       // In case it works, set it back to where we found it.\n      if (nvret != NVML_SUCCESS) {                                            // If it failed,\n         fprintf(stderr, \"nvmlDeviceSetPowerManagementLimit to restore %i failed; nvret=%i [%s]\\n\", powerLimit, nvret, nvmlErrorString(nvret));\n      } else {\n         fprintf(stderr, \"nvmlDeviceSetPowerManagementLimit to restore %i succeeded.\\n\", powerLimit);\n      }\n\n\n\n\n\n\n   } // end of loop through devices.\n \n   \n   \n   \n   //-------------------------------------------------------------------\n   // Cleanup, and shutdown.\n   //-------------------------------------------------------------------\n\n   return 0;\n} // end MAIN routine.\n\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-papi-6.0.0.1-gmm3tef6bggycxgzrtmq2ejaggc2ozfb/spack-src/src/components/lmsensors/linux-lmsensors.c": "/** \n * @file    linux-lmsensors.c\n * @author  Daniel Lucio\n * @author  Joachim Protze\n * @author  Heike Jagode\n *          jagode@eecs.utk.edu\n *\n * @ingroup papi_components\n *\n *\n * LM_SENSORS component \n * \n * Tested version of lm_sensors: 3.1.1\n *\n * @brief \n *  This file has the source code for a component that enables PAPI-C to access\n *  hardware monitoring sensors through the libsensors library. This code will\n *  dynamically create a native events table for all the sensors that can be \n *  accesed by the libsensors library.\n *  In order to learn more about libsensors, visit: (http://www.lm-sensors.org) \n *\n * Notes: \n *  - I used the ACPI and MX components to write this component. A lot of the\n *    code in this file mimics what other components already do. \n *  - The return values are scaled by 1000 because PAPI can not return decimals.\n *  - A call of PAPI_read can take up to 2 seconds while using lm_sensors!\n *  - Please remember that libsensors uses the GPL license. \n */\n\n\n/* Headers required by libsensors */\n#include <sensors.h>\n#include <error.h>\n#include <time.h>\n#include <string.h>\n#include <dlfcn.h>\n\n/* Headers required by PAPI */\n#include \"papi.h\"\n#include \"papi_internal.h\"\n#include \"papi_vector.h\"\n#include \"papi_memory.h\"\n\n/*************************  DEFINES SECTION  ***********************************\n *******************************************************************************/\n// time in usecs\n#define LM_SENSORS_REFRESHTIME 200000\n\n/** Structure that stores private information of each event */\ntypedef struct _lmsensors_register\n{\n\t/* This is used by the framework.It likes it to be !=0 to do somehting */\n\tunsigned int selector;\n\t/* These are the only information needed to locate a libsensors event */\n\tconst sensors_chip_name *name;\n\tint subfeat_nr;\n} _lmsensors_register_t;\n\n/*\n * The following structures mimic the ones used by other components. It is more\n * convenient to use them like that as programming with PAPI makes specific\n * assumptions for them.\n */\n\n/** This structure is used to build the table of events */\ntypedef struct _lmsensors_native_event_entry\n{\n\t_lmsensors_register_t resources;\n\tchar name[PAPI_MAX_STR_LEN];\n\tchar description[PAPI_MAX_STR_LEN];\n\tunsigned int count;\n} _lmsensors_native_event_entry_t;\n\n\ntypedef struct _lmsensors_reg_alloc\n{\n\t_lmsensors_register_t ra_bits;\n} _lmsensors_reg_alloc_t;\n\n\ntypedef struct _lmsensors_control_state\n{\n\tlong_long lastupdate;\n} _lmsensors_control_state_t;\n\n\ntypedef struct _lmsensors_context\n{\n\t_lmsensors_control_state_t state;\n} _lmsensors_context_t;\n\n\n\n/*************************  GLOBALS SECTION  ***********************************\n *******************************************************************************/\n/* This table contains the LM_SENSORS native events */\nstatic _lmsensors_native_event_entry_t *lm_sensors_native_table;\n/* number of events in the table*/\nstatic int num_events = 0;\nstatic long_long *cached_counts = NULL;\t// used for caching readings\n\n\nstatic int (*sensors_initPtr)(FILE *input);\nstatic void (*sensors_cleanupPtr)(void);\nstatic int (*sensors_snprintf_chip_namePtr)(char *str, size_t size,\n\t\t\t\t  const sensors_chip_name *chip);\nstatic char *(*sensors_get_labelPtr)(const sensors_chip_name *name, const sensors_feature *feature);\nstatic int (*sensors_get_valuePtr)(const sensors_chip_name *name, int subfeat_nr,\n\t\t      double *value);\nstatic const sensors_chip_name *(*sensors_get_detected_chipsPtr)(const sensors_chip_name\n\t\t\t\t\t\t       *match, int *nr);\nstatic const sensors_feature *(*sensors_get_featuresPtr)(const sensors_chip_name *name, int *nr);\nstatic const sensors_subfeature *(*sensors_get_all_subfeaturesPtr)(const sensors_chip_name *name,\n\t\t\t    const sensors_feature *feature, int *nr);\n\n// file handles used to access lmsensors libraries with dlopen\nstatic void* dl1 = NULL;\n\n// string macro defined within Rules.lmsensors\nstatic char lmsensors_main[]=PAPI_LMSENSORS_MAIN;\n\n//-----------------------------------------------------------------------------\n// Using weak symbols (global declared without a value, so it defers to any\n// other global declared in another file WITH a value) allows PAPI to be built\n// with the component, but PAPI can still be installed in a system without the\n// required library.\n//-----------------------------------------------------------------------------\n\nvoid (*_dl_non_dynamic_init)(void) __attribute__((weak));               // declare a weak dynamic-library init routine pointer.\n\nstatic int link_lmsensors_libraries ();\n\npapi_vector_t _lmsensors_vector;\n\n/******************************************************************************\n ********  BEGIN FUNCTIONS  USED INTERNALLY SPECIFIC TO THIS COMPONENT ********\n *****************************************************************************/\n/*\n * Counts number of events available in this system\n */\nstatic unsigned\ndetectSensors( void )\n{\n\tunsigned id = 0;\n\tint chip_nr = 0;\n\tconst sensors_chip_name *chip_name;\n\n\t/* Loop through all the chips, features, subfeatures found */\n\twhile ( ( chip_name =\n\t\t\t  sensors_get_detected_chipsPtr( NULL, &chip_nr ) ) != NULL ) {\n\t\tint a = 0, b;\n\t\tconst sensors_feature *feature;\n\n\t\twhile ( ( feature = sensors_get_featuresPtr( chip_name, &a ) ) ) {\n\t\t\tb = 0;\n\t\t\twhile ( ( sensors_get_all_subfeaturesPtr( chip_name, feature,\n\t\t\t\t\t\t\t\t\t\t\t\t   &b ) ) ) {\n\t\t\t\tid++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn id;\n}\n\n\n/*\n * Create the native events for particulare component (!= 0)\n */\nstatic unsigned\ncreateNativeEvents( void )\n{\n\tunsigned id = 0;\n\tint chip_nr = 0;\n\tconst sensors_chip_name *chip_name;\n\n\t/* component name and description */\n\tstrcpy( _lmsensors_vector.cmp_info.short_name, \"lmsensors\" );\n\tstrcpy( _lmsensors_vector.cmp_info.description,\n\t\t\t\"lm-sensors provides tools for monitoring the hardware health\" );\n\n\n\t/* Loop through all the chips found */\n\twhile ( ( chip_name =\n\t\t\t  sensors_get_detected_chipsPtr( NULL, &chip_nr ) ) != NULL ) {\n\t   int a, b;\n\t   const sensors_feature *feature;\n\t   const sensors_subfeature *sub;\n\t   char chipnamestring[PAPI_MIN_STR_LEN];\n\n\t   //\t   lm_sensors_native_table[id].count = 0;\n\n\t\t/* get chip name from its internal representation */\n\t   sensors_snprintf_chip_namePtr( chipnamestring,\n\t\t\t\t\t    PAPI_MIN_STR_LEN, chip_name );\n\n\t   a = 0;\n\n\t   /* Loop through all the features found */\n\t   while ( ( feature = sensors_get_featuresPtr( chip_name, &a ) ) ) {\n\t      char *featurelabel;\n\n\t      if ( !( featurelabel = sensors_get_labelPtr( chip_name, feature ))) {\n\t\t fprintf( stderr, \"ERROR: Can't get label of feature %s!\\n\",\n\t\t\t\t\t\t feature->name );\n\t\t continue;\n\t      }\n\n\t      b = 0;\n\n\t      /* Loop through all the subfeatures found */\n\t      while ((sub=sensors_get_all_subfeaturesPtr(chip_name,feature,&b))) {\n\n\t\t /* replace spaces with underscores */\n\t\t char *ptr;\n\t\t while( (ptr = strchr(featurelabel, ' ')) != NULL ){ *ptr = '_'; }\n\n\t\t /* Save native event data */\n\t\t sprintf( lm_sensors_native_table[id].name, \"%s.%s.%s\",\n\t\t\t  chipnamestring, featurelabel, sub->name );\n\n\t\t strncpy( lm_sensors_native_table[id].description,\n\t\t\t  lm_sensors_native_table[id].name, PAPI_MAX_STR_LEN );\n                 lm_sensors_native_table[id].description[PAPI_MAX_STR_LEN-1] = '\\0';\n\n\t\t /* The selector has to be !=0 . Starts with 1 */\n\t\t lm_sensors_native_table[id].resources.selector = id + 1;\n\n\t\t /* Save the actual references to this event */\n\t\t lm_sensors_native_table[id].resources.name = chip_name;\n\t\t lm_sensors_native_table[id].resources.subfeat_nr = sub->number;\n\n\t\t /* increment the table index counter */\n\t\t id++;\t\t \n\t      }\n\n\t      //   lm_sensors_native_table[id].count = count + 1;\n\t      free( featurelabel );\n\t   }\n\t}\n\n\t/* Return the number of events created */\n\treturn id;\n}\n\n/*\n * Returns the value of the event with index 'i' in lm_sensors_native_table\n * This value is scaled by 1000 to cope with the lack to return decimal numbers\n * with PAPI\n */\n\nstatic long_long\ngetEventValue( unsigned event_id )\n{\n\tdouble value;\n\tint res;\n\n\tres = sensors_get_valuePtr( lm_sensors_native_table[event_id].resources.name,\n\t\t\t\t\t\t\t lm_sensors_native_table[event_id].resources.\n\t\t\t\t\t\t\t subfeat_nr, &value );\n\n\tif ( res < 0 ) {\n\t\tfprintf( stderr, \"libsensors(): Could not read event #%d!\\n\",\n\t\t\t\t event_id );\n\t\treturn -1;\n\t}\n\n\treturn ( ( long_long ) ( value * 1000 ) );\n}\n\n\n/*****************************************************************************\n *******************  BEGIN PAPI's COMPONENT REQUIRED FUNCTIONS  *************\n *****************************************************************************/\n\n/*\n * This is called whenever a thread is initialized\n */\nstatic int\n_lmsensors_init_thread( hwd_context_t *ctx )\n{\n    ( void ) ctx;\n    return PAPI_OK;\n}\n\n\n/* Initialize hardware counters, setup the function vector table\n * and get hardware information, this routine is called when the \n * PAPI process is initialized (IE PAPI_library_init)\n */\nstatic int\n_lmsensors_init_component( int cidx )\n{\n    int res;\n    (void) cidx;\n\n    /* link in all the lmsensor libraries and resolve the symbols we need to use */\n    if (link_lmsensors_libraries() != PAPI_OK) {\n\t    SUBDBG (\"Dynamic link of lmsensors libraries failed, component will be disabled.\\n\");\n\t    SUBDBG (\"See disable reason in papi_component_avail output for more details.\\n\");\n\t    return (PAPI_ENOSUPP);\n    }\n\n    /* Initialize libsensors library */\n    if ( ( res = sensors_initPtr( NULL ) ) != 0 ) {\n       strncpy(_lmsensors_vector.cmp_info.disabled_reason,\n\t      \"Cannot enable libsensors\",PAPI_MAX_STR_LEN);\n       return res;\n    }\n\n    /* Create dyanmic events table */\n    num_events = detectSensors(  );\n    SUBDBG(\"Found %d sensors\\n\",num_events);\n\n    _lmsensors_vector.cmp_info.num_mpx_cntrs = num_events;\n    _lmsensors_vector.cmp_info.num_cntrs = num_events;\n\n    if ( ( lm_sensors_native_table =\n\t   calloc( num_events, sizeof ( _lmsensors_native_event_entry_t )))\n\t\t\t\t   == NULL ) {\n       strncpy(_lmsensors_vector.cmp_info.disabled_reason,\n\t      \"Could not malloc room\",PAPI_MAX_STR_LEN);\n       return PAPI_ENOMEM;\n    }\n\n    cached_counts = (long long*) calloc(num_events, sizeof(long long));\n\n    if (cached_counts == NULL) {\n        strncpy(_lmsensors_vector.cmp_info.disabled_reason,\n               \"Could not malloc room\",PAPI_MAX_STR_LEN);\n      free(lm_sensors_native_table);\n      lm_sensors_native_table = NULL;\n\t   return PAPI_ENOMEM;\n    }\n\n    if ( ( unsigned ) num_events != createNativeEvents(  ) ) {\n       strncpy(_lmsensors_vector.cmp_info.disabled_reason,\n\t      \"LM_SENSOR number mismatch\",PAPI_MAX_STR_LEN);\n      free(cached_counts);\n      cached_counts = NULL;\n      free(lm_sensors_native_table);\n      lm_sensors_native_table = NULL;\n       return PAPI_ECMP;\n    }\n\n    _lmsensors_vector.cmp_info.num_native_events=num_events;\n    _lmsensors_vector.cmp_info.num_cntrs=num_events;\n\n    return PAPI_OK;\n}\n\n/*\n * Link the necessary lmsensors libraries to use the lmsensors\n * component.  If any of them can not be found, then the lmsensors\n * component will just be disabled.  This is done at runtime so that a\n * version of PAPI built with the Infiniband component can be\n * installed and used on systems which have the lmsensors libraries\n * installed and on systems where these libraries are not installed.\n */\nstatic int\nlink_lmsensors_libraries ()\n{\n   if ( _dl_non_dynamic_init != NULL ) {\n      // If weak var present, statically linked insted of dynamic.\n      strncpy( _lmsensors_vector.cmp_info.disabled_reason, \"The lmsensors component REQUIRES dynamic linking capabilities.\", PAPI_MAX_STR_LEN-1);\n      // EXIT not supported.\n      return PAPI_ENOSUPP;\n   }\n\n   char path_name[1024];\n   char *lmsensors_root = getenv(\"PAPI_LMSENSORS_ROOT\"); \n   \n   dl1 = NULL;\n   // Step 1: Process override if given.   \n   if (strlen(lmsensors_main) > 0) {                                  // If override given, it has to work.\n      dl1 = dlopen(lmsensors_main, RTLD_NOW | RTLD_GLOBAL);           // Try to open that path.\n      if (dl1 == NULL) {\n         snprintf(_lmsensors_vector.cmp_info.disabled_reason, PAPI_MAX_STR_LEN, \"PAPI_LMSENSORS_MAIN override '%s' given in Rules.lmsensors not found.\", lmsensors_main);\n         return(PAPI_ENOSUPP);   // Override given but not found.\n      }\n   }\n\n   // Step 2: Try system paths, will work with Spack, LD_LIBRARY_PATH, default paths.\n   if (dl1 == NULL) {                                           // No override,\n      dl1 = dlopen(\"libsensors.so\", RTLD_NOW | RTLD_GLOBAL);        // Try system paths.\n   }\n\n   // Step 3: Try the explicit install default. \n   if (dl1 == NULL && lmsensors_root != NULL) {                          // if root given, try it.\n      snprintf(path_name, 1024, \"%s/lib64/libsensors.so\", lmsensors_root);   // PAPI Root check.\n      dl1 = dlopen(path_name, RTLD_NOW | RTLD_GLOBAL);             // Try to open that path.\n   }\n\n   // Check for failure.\n   if (dl1 == NULL) {\n      snprintf(_lmsensors_vector.cmp_info.disabled_reason, PAPI_MAX_STR_LEN, \"libsensors.so not found.\");\n      return(PAPI_ENOSUPP);\n   }\n\n   // We have dl1. \n\n\tsensors_initPtr = dlsym(dl1, \"sensors_init\");\n\tif (dlerror() != NULL)\n\t{\n\t\tstrncpy(_lmsensors_vector.cmp_info.disabled_reason,\n\t\t\t\"lmsensor function sensors_init.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tsensors_cleanupPtr = dlsym(dl1, \"sensors_cleanup\");\n\tif (dlerror() != NULL)\n\t{\n\t\tstrncpy(_lmsensors_vector.cmp_info.disabled_reason,\n\t\t\t\"lmsensor function sensors_cleanup.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tsensors_snprintf_chip_namePtr = dlsym(dl1, \"sensors_snprintf_chip_name\");\n\tif (dlerror() != NULL)\n\t{\n\t\tstrncpy(_lmsensors_vector.cmp_info.disabled_reason,\n\t\t\t\"lmsensor function sensors_snprintf_chip_name.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tsensors_get_labelPtr = dlsym(dl1, \"sensors_get_label\");\n\tif (dlerror() != NULL)\n\t{\n\t\tstrncpy(_lmsensors_vector.cmp_info.disabled_reason,\n\t\t\t\"lmsensor function sensors_get_label.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tsensors_get_valuePtr = dlsym(dl1, \"sensors_get_value\");\n\tif (dlerror() != NULL)\n\t{\n\t\tstrncpy(_lmsensors_vector.cmp_info.disabled_reason,\n\t\t\t\"lmsensor function sensors_get_value.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tsensors_get_detected_chipsPtr = dlsym(dl1, \"sensors_get_detected_chips\");\n\tif (dlerror() != NULL)\n\t{\n\t\tstrncpy(_lmsensors_vector.cmp_info.disabled_reason,\n\t\t\t\"lmsensor function sensors_get_detected_chips.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tsensors_get_featuresPtr = dlsym(dl1, \"sensors_get_features\");\n\tif (dlerror() != NULL)\n\t{\n\t\tstrncpy(_lmsensors_vector.cmp_info.disabled_reason,\n\t\t\t\"lmsensor function sensors_get_features.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tsensors_get_all_subfeaturesPtr = dlsym(dl1, \"sensors_get_all_subfeatures\");\n\tif (dlerror() != NULL)\n\t{\n\t\tstrncpy(_lmsensors_vector.cmp_info.disabled_reason,\n\t\t\t\"lmsensor function sensors_get_all_subfeatures.\",PAPI_MAX_STR_LEN);\n\t\treturn ( PAPI_ENOSUPP );\n\t}\n\n\treturn ( PAPI_OK );\n}\n\n/*\n * Control of counters (Reading/Writing/Starting/Stopping/Setup)\n * functions\n */\nstatic int\n_lmsensors_init_control_state( hwd_control_state_t *ctl )\n{\n\tint i;\n\n\tfor ( i = 0; i < num_events; i++ )\n\t\tcached_counts[i] = getEventValue( i );\n\n\t( ( _lmsensors_control_state_t * ) ctl )->lastupdate =\n\t\tPAPI_get_real_usec(  );\n\treturn PAPI_OK;\n}\n\n\n/*\n *\n */\nstatic int\n_lmsensors_start( hwd_context_t *ctx, hwd_control_state_t *ctl )\n{\n\t( void ) ctx;\n\t( void ) ctl;\n\n\treturn PAPI_OK;\n}\n\n\n/*\n *\n */\nstatic int\n_lmsensors_stop( hwd_context_t *ctx, hwd_control_state_t *ctl )\n{\n    ( void ) ctx;\n    ( void ) ctl;\n\n    return PAPI_OK;\n}\n\n\n/*\n *\n */\nstatic int\n_lmsensors_read( hwd_context_t *ctx, hwd_control_state_t *ctl,\n\t\t long_long ** events, int flags )\n{\n    ( void ) ctx;\n    ( void ) flags;\n    long long start = PAPI_get_real_usec(  );\n    int i;\n \n    _lmsensors_control_state_t *control=(_lmsensors_control_state_t *)ctl;\n\n    if ( start - control->lastupdate > 200000 ) {\t// cache refresh\n       \n       for ( i = 0; i < num_events; i++ ) {\n\t   cached_counts[i] = getEventValue( i );\n       }\n       control->lastupdate = PAPI_get_real_usec(  );\n    }\n\n    *events = cached_counts;\n    return PAPI_OK;\n}\n\n\nstatic int\n_lmsensors_shutdown_component( void )\n{\n\tif (cached_counts)   {\n\t\tfree(cached_counts);\n      cached_counts = NULL;\n   }\n\n\t/* Call the libsensors cleaning function before leaving */\n\tsensors_cleanupPtr(  );\n\n   if (lm_sensors_native_table) {\n      free(lm_sensors_native_table);\n      lm_sensors_native_table = NULL;\n   }\n\n\treturn PAPI_OK;\n}\n\nstatic int\n_lmsensors_shutdown_thread( hwd_context_t *ctx )\n{\n    ( void ) ctx;\n\n    return PAPI_OK;\n}\n\n\n\n/* This function sets various options in the component\n * The valid codes being passed in are PAPI_SET_DEFDOM,\n * PAPI_SET_DOMAIN, PAPI_SETDEFGRN, PAPI_SET_GRANUL * and PAPI_SET_INHERIT\n */\nstatic int\n_lmsensors_ctl( hwd_context_t *ctx, int code, _papi_int_option_t *option )\n{\n    ( void ) ctx;\n    ( void ) code;\n    ( void ) option;\n    return PAPI_OK;\n}\n\n\nstatic int\n_lmsensors_update_control_state( hwd_control_state_t *ctl,\n\t\t\t\t NativeInfo_t * native, \n\t\t\t\t int count,\n\t\t\t\t hwd_context_t *ctx )\n{\n    int i, index;\n    ( void ) ctx;\n    ( void ) ctl;\n\n    for ( i = 0; i < count; i++ ) {\n\tindex = native[i].ni_event;\n\tnative[i].ni_position =\n\t\t\tlm_sensors_native_table[index].resources.selector - 1;\n    }\n    return PAPI_OK;\n}\n\n\n/*\n * As I understand it, all data reported by these interfaces will be system wide\n */\nstatic int\n_lmsensors_set_domain( hwd_control_state_t *ctl, int domain )\n{\n\t(void) ctl;\n\tif ( PAPI_DOM_ALL != domain )\n\t\treturn ( PAPI_EINVAL );\n\n\treturn ( PAPI_OK );\n}\n\n\n/*\n *\n */\nstatic int\n_lmsensors_reset( hwd_context_t *ctx, hwd_control_state_t *ctl )\n{\n    ( void ) ctx;\n    ( void ) ctl;\n    return PAPI_OK;\n}\n\n\n/*\n * Native Event functions\n */\nstatic int\n_lmsensors_ntv_enum_events( unsigned int *EventCode, int modifier )\n{\n\n\tswitch ( modifier ) {\n\tcase PAPI_ENUM_FIRST:\n\t\t*EventCode = 0;\n\n\t\treturn PAPI_OK;\n\t\tbreak;\n\n\tcase PAPI_ENUM_EVENTS:\n\t{\n\t\tint index = *EventCode;\n\n\t\tif ( index < num_events - 1 ) {\n\t\t\t*EventCode = *EventCode + 1;\n\t\t\treturn PAPI_OK;\n\t\t} else\n\t\t\treturn PAPI_ENOEVNT;\n\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn PAPI_EINVAL;\n\t}\n\treturn PAPI_EINVAL;\n}\n\n/*\n *\n */\nstatic int\n_lmsensors_ntv_code_to_name( unsigned int EventCode, char *name, int len )\n{\n\tint index = EventCode;\n\n\tif (index>=0 && index<num_events) {\n\t   strncpy( name, lm_sensors_native_table[index].name, len );\n\t}\n\n\treturn PAPI_OK;\n}\n\n/*\n *\n */\nstatic int\n_lmsensors_ntv_code_to_descr( unsigned int EventCode, char *name, int len )\n{\n\tint index = EventCode;\n\n\tif (index>=0 && index<num_events) {\n\t   strncpy( name, lm_sensors_native_table[index].description, len );\n\t}\n\treturn PAPI_OK;\n}\n\n\n\n/*\n *\n */\npapi_vector_t _lmsensors_vector = {\n   .cmp_info = {\n        /* component information (unspecified values are initialized to 0) */\n\t.name = \"lmsensors\",\n\t.short_name = \"lmsensors\",\n\t.version = \"5.0\",\n\t.description = \"Linux LMsensor statistics\",\n\t.num_mpx_cntrs = 0,\n\t.num_cntrs = 0,\n\t.default_domain = PAPI_DOM_ALL,\n\t.default_granularity = PAPI_GRN_SYS,\n\t.available_granularities = PAPI_GRN_SYS,\n\t.hardware_intr_sig = PAPI_INT_SIGNAL,\n\n\t/* component specific cmp_info initializations */\n\t.fast_real_timer = 0,\n\t.fast_virtual_timer = 0,\n\t.attach = 0,\n\t.attach_must_ptrace = 0,\n\t.available_domains = PAPI_DOM_USER | PAPI_DOM_KERNEL,\n  },\n\n        /* sizes of framework-opaque component-private structures */\n\t.size = {\n\t   .context = sizeof ( _lmsensors_context_t ),\n\t   .control_state = sizeof ( _lmsensors_control_state_t ),\n\t   .reg_value = sizeof ( _lmsensors_register_t ),\n\t   .reg_alloc = sizeof ( _lmsensors_reg_alloc_t ),\n  },\n\t/* function pointers in this component */\n     .init_thread =          _lmsensors_init_thread,\n     .init_component =       _lmsensors_init_component,\n     .init_control_state =   _lmsensors_init_control_state,\n     .start =                _lmsensors_start,\n     .stop =                 _lmsensors_stop,\n     .read =                 _lmsensors_read,\n     .shutdown_thread =      _lmsensors_shutdown_thread,\n     .shutdown_component =   _lmsensors_shutdown_component,\n     .ctl =                  _lmsensors_ctl,\n     .update_control_state = _lmsensors_update_control_state,\n     .set_domain =           _lmsensors_set_domain,\n     .reset =                _lmsensors_reset,\n\t\n     .ntv_enum_events =      _lmsensors_ntv_enum_events,\n     .ntv_code_to_name =     _lmsensors_ntv_code_to_name,\n     .ntv_code_to_descr =    _lmsensors_ntv_code_to_descr,\n};\n",
        "/tmp/vanessa/spack-stage/spack-stage-papi-6.0.0.1-gmm3tef6bggycxgzrtmq2ejaggc2ozfb/spack-src/src/components/rocm_smi/linux-rocm-smi.c": "//-----------------------------------------------------------------------------\n// @file    linux-rocm-smi.c\n//\n// @ingroup rocm_components\n//\n// @brief This implements a PAPI component that enables PAPI-C to access\n// hardware system management controls for AMD ROCM GPU devices through the\n// rocm_smi library.\n//\n// The open source software license for PAPI conforms to the BSD License\n// template.\n//-----------------------------------------------------------------------------\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdint.h>\n#include <dlfcn.h>\n\n#include \"rocm_smi.h\"\n#include \"papi.h\"\n#include \"papi_memory.h\"\n#include \"papi_internal.h\"\n#include \"papi_vector.h\"\n\n// The following macros, if defined, will help with diagnosing problems with new devices.\n// output will be to stderr during any PAPI_INIT, e.g. execute utils/papi_component_avail.\n// #define  REPORT_KNOWN_EVENTS_NOT_SUPPORTED_BY_DEVICE\n// #define  REPORT_DEVICE_FUNCTION_NOT_SUPPORTED_BY_THIS_SOFTWARE\n\nstatic char *RSMI_ERROR_STRINGS[]={\n  \"RSMI_STATUS_SUCCESS\",\n  \"RSMI_STATUS_INVALID_ARGS\",\n  \"RSMI_STATUS_NOT_SUPPORTED\",\n  \"RSMI_STATUS_FILE_ERROR\",\n  \"RSMI_STATUS_PERMISSION\",\n  \"RSMI_STATUS_OUT_OF_RESOURCES\",\n  \"RSMI_STATUS_INTERNAL_EXCEPTION\",\n  \"RSMI_STATUS_INPUT_OUT_OF_BOUNDS\",\n  \"RSMI_STATUS_INIT_ERROR\",\n  \"RSMI_STATUS_NOT_YET_IMPLEMENTED\",\n  \"RSMI_STATUS_NOT_FOUND\",\n  \"RSMI_STATUS_INSUFFICIENT_SIZE\",\n  \"RSMI_STATUS_INTERRUPT\",\n  \"RSMI_STATUS_UNEXPECTED_SIZE\",\n  \"RSMI_STATUS_NO_DATA\",\n  \"RSMI_STATUS_UNKNOWN_ERROR\"};\n\n\n// Macros for error checking... each arg is only referenced/evaluated once\n#define CHECK_PRINT_EVAL(checkcond, str, evalthis)                      \\\n    do {                                                                \\\n        int _cond = (checkcond);                                        \\\n        if (_cond) {                                                    \\\n            fprintf(stderr, \"%s:%i error: condition %s failed: %s.\\n\",  \\\n                __FILE__, __LINE__, #checkcond, str);                   \\\n            evalthis;                                                   \\\n        }                                                               \\\n    } while (0)\n\n// This macro declares a function pointer. It used to make\n// the function name a weak link, but we never use the name\n// directly as something the linker must resolve, so weak\n// link names are not necessary. \n#define DECLARE_RSMI(funcname, funcsig)                                 \\\n/*  rsmi_status_t __attribute__((weak)) funcname funcsig;  */           \\\n    static rsmi_status_t(*funcname##Ptr) funcsig;\n\n// This macro gets the function pointer from the dynamic\n// library, and sets the function pointer declared above.\n#define DLSYM_SMI(name)                                                 \\\n    do {                                                                \\\n        name##Ptr = dlsym(dl1, #name);                                  \\\n        if (dlerror()!=NULL) {                                          \\\n            snprintf(_rocm_smi_vector.cmp_info.disabled_reason,         \\\n                PAPI_MAX_STR_LEN,                                       \\\n                \"The function '%s' was not found in SMI library.\",      \\\n                #name);                                                 \\\n            fprintf(stderr, \"%s\\n\",                                     \\\n                _rocm_smi_vector.cmp_info.disabled_reason);             \\\n            name##Ptr = NULL;                                           \\\n            return(PAPI_ENOSUPP);                                       \\\n        }                                                               \\\n    } while (0)\n\n// The following will call and check the return on an SMI function;\n// note it appends 'Ptr' to the name for the caller.\n#define RSMI(name, args, handleerror)                                   \\\n    do {                                                                \\\n        if (name##Ptr == NULL) {                                        \\\n            fprintf(stderr, \"%s function pointer is NULL.\\n\", #name);   \\\n            return(-1);                                                 \\\n        }                                                               \\\n        rsmi_status_t _status = (*name##Ptr)args;                       \\\n        if (_status != RSMI_STATUS_SUCCESS) {                           \\\n            if (printRSMIerr) {                                         \\\n                fprintf(stderr, \"%s:%i error: RSMI function %s failed \" \\\n                   \"with error %d='%s'.\\n\",                             \\\n                   __FILE__, __LINE__, #name, _status,                  \\\n                   RSMI_ERROR_STR(_status));                            \\\n            }                                                           \\\n            handleerror;                                                \\\n        }                                                               \\\n    } while (0)\n\n//-----------------------------------------------------------------------------\n// How it all works! \n//\n// INTRO to ROCM_SMI: Unlike other event libraries we use, the ROCM_SMI\n// library does not have a way to parse a string-name event and return values.\n// Instead, their library has individual routines that must be called, and\n// they don't have a uniform argument list: Some take 2 args, some 3 or 4.\n//\n// ROCM_SMI does have an iterator that returns the text names of whatever\n// functions it has that are valid; along with 'variant' and 'subvariant'\n// codes that are valid. You can see this in the routine scanEvents(). We load\n// all these into an array ScanEvents[], which we sort by name, variant, and\n// subvariant. \n//\n// We have (in this file) seperate functions for each event that call the\n// library function to return a value for that event; these are the er_XXX\n// routines and ew_XXX routines (for \"event read\" and, when applicable, \"event\n// write\").\n//\n// In the function _rocm_smi_add_native_events(), we go through every event we\n// know about; see if we can find it in the ScanEvents[] array, if we can\n// create a new event for PAPI users in the array AllEvents[]. This will have\n// an explicit name (different than the routine name), and the table entry\n// contains a pointer to read and/or write routines, the variant and\n// subvariant necessary, the space to read the value, etc. \n//\n// The structure following these comments is one element in AllEvents[].\n//\n// On PAPI_read(), we search the AllEvents[] array, and for any active entries\n// we call the reader routine. It can return one value or whole structures.\n// Each read routine is specific to the event, it must extract from\n// multi-valued returns its single value. But if it does return multiple\n// values, then there is only ONE event (the first) that has the array to read\n// into, and all the others will have 'baseIdx' set to the event. Note that\n// each event still gets its own reader (to handle indexing). Our protocol is\n// that if 'baseIdx != myIdx' the baseIdx reader is called; it will populate\n// its value and mark itself read. Then others can call their reader to\n// populate their value, from the array in the baseIdx.\n//\n// For efficiency, when we construct AllEvents[] we ensure all events with the\n// same device:sensor:baseIdx are contiguous.\n//\n// Whenever we enable an event, we check subsequent events in the table to see\n// if they have the same baseIdx, and enable them as well.\n//\n// Each reader populates the single 'value' it will return. At the end of a\n// PAPI_read(), we must return these values in the order they requested them;\n// but we have an array of AllEvents[] indices; so we just look them up and\n// copy this value.\n//\n// Note 'device' and 'sensor' are signed; so we do not reset anything if they\n// are less than zero.\n//\n// If you need it, add 'int cumulative' indicator here and set it during the\n// event setup in  _rocm_smi_add_native_events. Then add to _rocm_smi_start()\n// code to read a zero value for any active events. You would need to add a\n// 'uint64_t zero' field, also. But because different routines treat this as\n// int or unsigned, it is a little tricky to set the zero. I think the reader\n// routine would always subtract it from a read value, recasting as needed.\n// Then to set a new zero, set ->zero=0x0, read, set ->zero = ->value.\n//-----------------------------------------------------------------------------\n\ntypedef struct {\n    int         read;                       // 0 for not read yet, 1 for read.\n    char        name[PAPI_MAX_STR_LEN];\n    char        desc[PAPI_2MAX_STR_LEN];\n    int32_t     variant;                    // Corresponding variant, to match that returned by iterator.\n    int32_t     subvariant;                 // Corresponding subvariant, to match that returned by iterator.\n    int(*reader)(int myIdx);                // event-specific read function; baseIdx=(-1) for call required; otherwise skip call, AllEvents[baseIdx] has the data recorded in vptr[].\n    int(*writer)(int myIdx);                // event-specific write function (may be null if unwriteable).\n    int32_t     device;                     // Device idx for event; -1 for calls without a device argument.\n    uint32_t    baseIdx;                    // In case multivalued read; where the master data structure is.\n    size_t      vptrSize;                   // malloc for whatever vptr needs when multiple values returned.\n    void*       vptr;                       // NULL or a structure or vector of values that were read.\n    uint64_t    value;                      // single value to return; always set on read, or value to write.\n} event_info_t;\n\n#define scanEventFuncNameLen 64\ntypedef struct {\n    char        funcname[scanEventFuncNameLen];\n    int32_t     device;                     // Note: -1 == END OF LIST marker.\n    int32_t     variant;\n    int32_t     subvariant;\n    int32_t     used;                       // diagnostic: Marked if found by nextEvent().\n} scanEvent_info_t;\n\n\n// Function prototypes\nstatic int _rocm_smi_cleanup_eventset(hwd_control_state_t * ctrl);\npapi_vector_t _rocm_smi_vector;             // Declare in advance, so it is present for error codes.\n\n//=================================== GLOBALS ==================================\n//\n// ******  CHANGE PROTOTYPES TO DECLARE ROCM LIBRARY SYMBOLS AS WEAK  **********\n// This is done so that a version of PAPI built with the rocm component can    *\n// be installed on a system which does not have the rocm libraries installed.  *\n//                                                                             *\n// If this is done without these prototypes, then all papi services on the     *\n// system without the rocm libraries installed will fail.  The PAPI libraries  *\n// contain references to the rocm libraries which are not installed.  The      *\n// load of PAPI commands fails because the rocm library references can not be  *\n// resolved.                                                                   *\n//                                                                             *\n// This also defines pointers to the rocm library functions that we call.      *\n// These function pointers will be resolved with dlopen/dlsym calls at         *\n// component initialization time.  The component then calls the rocm library   *\n// functions through these function pointers.                                  *\n// *****************************************************************************\nvoid (*_dl_non_dynamic_init) (void) __attribute__ ((weak));\n\n// RSMI API declaration, in utility order. All return rsmi_status_t.  The ones\n// simple to implement that just read or write a value are first. We group them\n// for creating various event creation routines, depending on whether multiple\n// events must be created or special events must be created.  These are copied\n// in the same order to produce the corresponding function pointers and then\n// event names.\n\nDECLARE_RSMI(rsmi_num_monitor_devices, (uint32_t *num_devices));\nDECLARE_RSMI(rsmi_dev_supported_func_iterator_open, (uint32_t dv_ind, rsmi_func_id_iter_handle_t *handle));\nDECLARE_RSMI(rsmi_dev_supported_variant_iterator_open, (rsmi_func_id_iter_handle_t obj_h,rsmi_func_id_iter_handle_t *var_iter));\nDECLARE_RSMI(rsmi_dev_supported_variant_iterator_open, (rsmi_func_id_iter_handle_t obj_h,rsmi_func_id_iter_handle_t *var_iter));\nDECLARE_RSMI(rsmi_dev_supported_func_iterator_close, (rsmi_func_id_iter_handle_t *handle));\nDECLARE_RSMI(rsmi_func_iter_value_get, (rsmi_func_id_iter_handle_t handle,rsmi_func_id_value_t *value));\nDECLARE_RSMI(rsmi_func_iter_next, (rsmi_func_id_iter_handle_t handle));\n\n// All by device id.\nDECLARE_RSMI(rsmi_dev_id_get, (uint32_t dv_ind, uint16_t *id));\nDECLARE_RSMI(rsmi_dev_subsystem_vendor_id_get, (uint32_t dv_ind, uint16_t *id));\nDECLARE_RSMI(rsmi_dev_vendor_id_get, (uint32_t dv_ind, uint16_t *id));\nDECLARE_RSMI(rsmi_dev_subsystem_id_get, (uint32_t dv_ind, uint16_t *id));\n\nDECLARE_RSMI(rsmi_dev_drm_render_minor_get, (uint32_t dv_ind, uint32_t *minor));\nDECLARE_RSMI(rsmi_dev_overdrive_level_get, (uint32_t dv_ind, uint32_t *od));\nDECLARE_RSMI(rsmi_dev_overdrive_level_set, (int32_t dv_ind, uint32_t od));\nDECLARE_RSMI(rsmi_dev_memory_busy_percent_get, (uint32_t dv_ind, uint32_t *busy_percent));\nDECLARE_RSMI(rsmi_dev_memory_reserved_pages_get, (uint32_t dv_ind, uint32_t *num_pages, rsmi_retired_page_record_t *records));\n\n// rsmi_dev_perf_level_t is just an enum; this can be returned as uint32.\nDECLARE_RSMI(rsmi_dev_perf_level_get, (uint32_t dv_ind, rsmi_dev_perf_level_t *perf));\nDECLARE_RSMI(rsmi_dev_perf_level_set, ( int32_t dv_ind, rsmi_dev_perf_level_t perf_lvl));\n\n// Iterate by memory type; an enum:\n// RSMI_MEM_TYPE_VRAM; RSMI_MEM_TYPE_VIS_VRAM; RSMI_MEM_TYPE_GTT. (VIS=visible).\nDECLARE_RSMI(rsmi_dev_memory_total_get, (uint32_t dv_ind, rsmi_memory_type_t mem_type, uint64_t *total));\nDECLARE_RSMI(rsmi_dev_memory_usage_get, (uint32_t dv_ind, rsmi_memory_type_t mem_type, uint64_t *used));\n\nDECLARE_RSMI(rsmi_dev_busy_percent_get, (uint32_t dv_ind, uint32_t *busy_percent));\nDECLARE_RSMI(rsmi_dev_firmware_version_get, (uint32_t dv_ind, rsmi_fw_block_t block, uint64_t *fw_version));\nDECLARE_RSMI(rsmi_dev_ecc_count_get, (uint32_t dv_ind, rsmi_gpu_block_t block, rsmi_error_count_t *ec));\nDECLARE_RSMI(rsmi_dev_ecc_enabled_get, (uint32_t dv_ind, uint64_t *enabled_blocks));\nDECLARE_RSMI(rsmi_dev_ecc_status_get, (uint32_t dv_ind, rsmi_gpu_block_t block, rsmi_ras_err_state_t *state));\n\n// clock frequency tables.\nDECLARE_RSMI(rsmi_dev_gpu_clk_freq_get, (uint32_t dv_ind, rsmi_clk_type_t type, rsmi_frequencies_t *frequencies));\n\n// Need sensor-id (0...n) in name. All zero for starters.\nDECLARE_RSMI(rsmi_dev_fan_reset, (uint32_t dv_ind, uint32_t sensor_ind));\nDECLARE_RSMI(rsmi_dev_fan_rpms_get, (uint32_t dv_ind, uint32_t sensor_ind, int64_t *speed));\nDECLARE_RSMI(rsmi_dev_fan_speed_get, (uint32_t dv_ind, uint32_t sensor_ind, int64_t *speed));\nDECLARE_RSMI(rsmi_dev_fan_speed_max_get, (uint32_t dv_ind, uint32_t sensor_ind, uint64_t *max_speed));\nDECLARE_RSMI(rsmi_dev_fan_speed_set, (uint32_t dv_ind, uint32_t sensor_ind, uint64_t speed));\nDECLARE_RSMI(rsmi_dev_power_ave_get, (uint32_t dv_ind, uint32_t sensor_ind, uint64_t *power));\nDECLARE_RSMI(rsmi_dev_power_cap_get, (uint32_t dv_ind, uint32_t sensor_ind, uint64_t *cap));\nDECLARE_RSMI(rsmi_dev_power_profile_presets_get, (uint32_t dv_ind, uint32_t sensor_ind, rsmi_power_profile_status_t *status));\nDECLARE_RSMI(rsmi_dev_power_profile_set, (uint32_t dv_ind, uint32_t reserved, rsmi_power_profile_preset_masks_t profile_mask));\n\nDECLARE_RSMI(rsmi_dev_pci_id_get, (uint32_t dv_ind, uint64_t *bdfid));\n\n// rsmi_temperature_metric_t is an enum with 14 settings; each would need to be an event.\nDECLARE_RSMI(rsmi_dev_temp_metric_get, (uint32_t dv_ind, uint32_t sensor_ind, rsmi_temperature_metric_t metric, int64_t *temperature));\n\n// rsmi_version_t contains uint32 for major; minor; patch. but could return 16-bit packed version as uint64_t.\nDECLARE_RSMI(rsmi_version_get, (rsmi_version_t *version));\n\n// rsmi_range_t contains two uint64's; lower_bound; upper_bound.\n// This function has a prototype in the header file, but does not exist in the library. (circa Apr 5 2019).\n// DECLARE_RSMI(rsmi_dev_od_freq_range_set, (uint32_t dv_ind, rsmi_clk_type_t clk, rsmi_range_t *range));\n\n// Needs to be two events; sent and received.\nDECLARE_RSMI(rsmi_dev_pci_throughput_get, (uint32_t dv_ind, uint64_t *sent, uint64_t *received, uint64_t *max_pkt_sz));\nDECLARE_RSMI(rsmi_dev_pci_replay_counter_get, (uint32_t dv_ind, uint64_t *counter));\n\n// Needs to be two events; max and min.\nDECLARE_RSMI(rsmi_dev_power_cap_range_get, (uint32_t dv_ind, uint32_t sensor_ind, uint64_t *max, uint64_t *min));\nDECLARE_RSMI(rsmi_dev_power_cap_set, (uint32_t dv_ind, uint32_t sensor_ind, uint64_t cap));\n\n// rsmi_frequencies_t contains uint32 num_supported; uint32 current; uint64[] frequency.\nDECLARE_RSMI(rsmi_dev_gpu_clk_freq_get, (uint32_t dv_ind, rsmi_clk_type_t clk_type, rsmi_frequencies_t *f));\nDECLARE_RSMI(rsmi_dev_gpu_clk_freq_set, (uint32_t dv_ind, rsmi_clk_type_t clk_type, uint64_t freq_bitmask));\n\n// rsmi_freq_volt_region_t contains two rsmi_range_t; each has two uint64's lower_bound; upper_bound.\n// Not implemented; data does not seem like useful performance data for PAPI users.\nDECLARE_RSMI(rsmi_dev_od_volt_curve_regions_get, (uint32_t dv_ind, uint32_t *num_regions, rsmi_freq_volt_region_t *buffer));\n\n// rsmi_od_volt_freq_data_t Complex structure with 4 rsmi_range_t and a 2D array of voltage curve points.\n// Not implemented; data does not seem like useful performance data for PAPI users.\nDECLARE_RSMI(rsmi_dev_od_volt_info_get, (uint32_t dv_ind, rsmi_od_volt_freq_data_t *odv));\n\n// rsmi_pcie_bandwidth_t is a structure containing two arrays; for transfer_rates and lanes.\nDECLARE_RSMI(rsmi_dev_pci_bandwidth_get, (uint32_t dv_ind, rsmi_pcie_bandwidth_t *bandwidth));\nDECLARE_RSMI(rsmi_dev_pci_bandwidth_set, (uint32_t dv_ind, uint64_t bw_bitmask));\nDECLARE_RSMI(rsmi_dev_unique_id_get, (uint32_t dv_ind, uint64_t *unique_id));\n\n// The following functions return strings. \nDECLARE_RSMI(rsmi_dev_brand_get, (uint32_t dv_ind, char *brand, uint32_t len));\nDECLARE_RSMI(rsmi_dev_name_get, (uint32_t dv_ind, char *name, size_t len));\nDECLARE_RSMI(rsmi_dev_serial_number_get, (uint32_t dv_ind, char *serial_number, uint32_t len));\nDECLARE_RSMI(rsmi_dev_subsystem_name_get, (uint32_t dv_ind, char *name, size_t len));\nDECLARE_RSMI(rsmi_dev_vbios_version_get, (uint32_t dv_ind, char *vbios, uint32_t len));\nDECLARE_RSMI(rsmi_dev_vendor_name_get, (uint32_t id, char *name, size_t len));\nDECLARE_RSMI(rsmi_version_str_get, (rsmi_sw_component_t id, char *name, size_t len));\n\n// Non-Events.\nDECLARE_RSMI(rsmi_init, (uint64_t init_flags));\nDECLARE_RSMI(rsmi_shut_down, (void));\nDECLARE_RSMI(rsmi_status_string, (rsmi_status_t status, const char **status_string));\n\n// Globals.\nstatic void     *dl1 = NULL;\nstatic char     rocm_smi_main[]=PAPI_ROCM_SMI_MAIN;\nstatic int      TotalScanEvents = 0;    // From the iterator scan, number we have.\nstatic int      SizeScanEvents  = 0;    // Size of dynamically growing array.\nstatic int      TotalEvents    = 0;     // Total Events we added.\nstatic int      ActiveEvents   = 0;     // Active events (number added by update_control_state).\nstatic int      SizeAllEvents  = 0;     // Size of the array.\nstatic uint32_t TotalDevices   = 0;     // Number of devices we found.\nstatic uint32_t DeviceCards[64];        // The cards we found them on; up to 64 of them. Currently populated but unused.\nstatic event_info_t *AllEvents = NULL;  // All events in the system.\nstatic scanEvent_info_t *ScanEvents = NULL;  // All scanned events in the system.\nstatic int      *CurrentIdx    = NULL;  // indices of events added by PAPI_add(), in order.\nstatic long long *CurrentValue  = NULL; // Value of events, in order, to return to user on PAPI_read().\nstatic int      printRSMIerr = 0;       // Suppresses RSMI errors during validation.\n\nstatic rsmi_frequencies_t *FreqTable = NULL;            // For rsmi_dev_gpu_clk_freq_get (per device).\n#define freqTablePerDevice (RSMI_CLK_TYPE_MEM+1)        /* The only ones we know about */\n\nstatic rsmi_pcie_bandwidth_t *PCITable = NULL;          // For rsmi_dev_pci_bandwidth_get (no variants, just one per device).\n\n//****************************************************************************\n//*******  BEGIN FUNCTIONS USED INTERNALLY SPECIFIC TO THIS COMPONENT ********\n//****************************************************************************\n\nstatic char *RSMI_ERROR_STR(int err)\n{\n    int modErr=err;\n    if (modErr < 0 || modErr>11) modErr=12;\n    return(RSMI_ERROR_STRINGS[modErr]);\n} // END ROUTINE.\n\n//----------------------------------------------------------------------------\n// Ensures there is room in all Events for one more entry.\n// Note we always zero added space as the default if any elements are not set.\n//----------------------------------------------------------------------------\nstatic void MakeRoomAllEvents(void)\n{\n    if (TotalEvents < SizeAllEvents) return;    // One more will fit.\n    if (AllEvents == NULL) {         // Never alloced;\n        SizeAllEvents = 16;          // Begin with 16 entries,\n        AllEvents = calloc(SizeAllEvents, sizeof(event_info_t));\n        return;\n    }\n\n    // Must add 16 table entries.\n    SizeAllEvents += 16;            // Add 16 entries.\n    AllEvents = realloc(AllEvents, SizeAllEvents*sizeof(event_info_t)); // make more room.\n    memset(&AllEvents[SizeAllEvents-16], 0, 16*sizeof(event_info_t));   // clear the added room.\n} // END ROUTINE.\n\n\n//----------------------------------------------------------------------------\n// Ensures there is room in scanEvents for one more entry.\n// Note we always zero added space as the default if any elements are not set.\n//----------------------------------------------------------------------------\nstatic void MakeRoomScanEvents(void)\n{\n    if (TotalScanEvents < SizeScanEvents) return;       // One more will fit.\n    if (ScanEvents == NULL) {                           // Never alloced;\n        SizeScanEvents = 16;                            // Begin with 16 entries,\n        ScanEvents = calloc(SizeScanEvents, sizeof(scanEvent_info_t));\n        return;\n    }\n\n    // Must add 16 table entries.\n    SizeScanEvents += 16;                                                       // Add 16 entries.\n    ScanEvents = realloc(ScanEvents, SizeScanEvents*sizeof(scanEvent_info_t));  // make more room.\n    memset(&ScanEvents[SizeScanEvents-16], 0, 16*sizeof(scanEvent_info_t));     // clear the added room.\n} // END ROUTINE.\n\n\n//----------------------------------------------------------------------------\n// addScanEvent: Called from rocm_iterator, adds to list in ScanEvents.\n//----------------------------------------------------------------------------\nvoid addScanEvent(const char* routine, int32_t device, uint64_t variant, uint64_t subvariant)\n{\n    MakeRoomScanEvents();                                                           // Make room if needed.\n    strncpy(ScanEvents[TotalScanEvents].funcname, routine, scanEventFuncNameLen);   // Copy name.\n    ScanEvents[TotalScanEvents].device=device;                                      // Device ID.\n    ScanEvents[TotalScanEvents].variant=variant;                                    // variant is typically enum, may be a type.\n    ScanEvents[TotalScanEvents].subvariant=subvariant;                              // subvariant is typically a sensor-ID.\n    TotalScanEvents++;                                                              // Count this one.\n} // END routine.\n\n\nstatic int sortScanEvents(const void *p1, const void *p2)\n{\n    scanEvent_info_t* e1 = (scanEvent_info_t*) p1;\n    scanEvent_info_t* e2 = (scanEvent_info_t*) p2;\n\n    if (e1->device < e2->device) return(-1);\n    if (e1->device > e2->device) return( 1);\n\n    // Same device.\n    int c=strcmp(e1->funcname, e2->funcname);\n    if (c != 0) return(c);\n    \n    // Same function name.\n    if (e1->variant < e2->variant) return(-1);\n    if (e1->variant > e2->variant) return( 1);\n    \n    // Same variant.\n    if (e1->subvariant < e2->subvariant) return(-1);\n    if (e1->subvariant > e2->subvariant) return( 1);\n    return(0);\n} // END routine.\n\n\n//-------------------------------------------------------------------------\n// We use the ROCM iterator to list all the available functions on each \n// device.\n// This code is derived from the C++ example code in the rsmi manual, Ch5.\n//-------------------------------------------------------------------------\nstatic void scanEvents(void) {\n    rsmi_func_id_iter_handle_t iter_handle, var_iter, sub_var_iter;\n    rsmi_func_id_value_t v_name, v_enum, v_sensor;\n    rsmi_status_t err;\n    unsigned int ui;\n    for (ui=0; ui<TotalDevices; ++ui) {                                         // For each device,\n        err = (*rsmi_dev_supported_func_iterator_openPtr)(ui, &iter_handle);    // begin iterator.\n        while (1) {                                                             // until we break out,\n            err = (*rsmi_func_iter_value_getPtr)(iter_handle, &v_name);         // get the next handle.\n            err = (*rsmi_dev_supported_variant_iterator_openPtr)(               // Iterate through variants.\n                  iter_handle, &var_iter);\n            if (err == RSMI_STATUS_NO_DATA) {                                   // If we have NO variance pointer,\n                addScanEvent(v_name.name, ui, -1, -1);\n            } else {                                                            // If we have a variance pointer,\n                while (err != RSMI_STATUS_NO_DATA) {                            // Iterate through them.\n                    err = (*rsmi_func_iter_value_getPtr)(var_iter, &v_enum);    // Get a value.\n                    err = (*rsmi_dev_supported_variant_iterator_openPtr)(       // Now look for sub-variants.\n                          var_iter, &sub_var_iter);\n\n                    if (err == RSMI_STATUS_NO_DATA) {\n                        addScanEvent(v_name.name, ui, v_enum.id, -1);\n                    } else {\n                        while (err != RSMI_STATUS_NO_DATA) {                // If any, and read until empty.\n                            err = (*rsmi_func_iter_value_getPtr)(           // Read one.\n                                  sub_var_iter, &v_sensor);                  \n                            addScanEvent(v_name.name, ui, v_enum.id, v_sensor.id); \n                            err = (*rsmi_func_iter_nextPtr)(sub_var_iter);  // Get next from iterator.\n                        }\n\n                        err = (*rsmi_dev_supported_func_iterator_closePtr)  // close variant iterator.\n                              (&sub_var_iter);                            \n                    } // end if there were any sub-variants (sensors) \n     \n                    err = (*rsmi_func_iter_nextPtr)(var_iter);              // Get the next variant.\n                } // end while var_iter loop.   \n\n                err = (*rsmi_dev_supported_func_iterator_closePtr)(&var_iter);\n            } // end if we had any var_iter to do.\n\n            err = (*rsmi_func_iter_nextPtr)(iter_handle);               // loop to next function.\n            if (err == RSMI_STATUS_NO_DATA) {\n                break;\n            }\n        } // end function iterator loop.\n\n        err = (*rsmi_dev_supported_func_iterator_closePtr) (&iter_handle);\n    } // end for each device.\n\n    // sort by device, name, variant, sub-variant.\n    qsort(ScanEvents, TotalScanEvents, sizeof(scanEvent_info_t), sortScanEvents);\n\n    // Create an end of list marker; for scanning without an index.\n    MakeRoomScanEvents();                                                           // Make room if needed.\n    ScanEvents[TotalScanEvents].device=-1;                                          // Mark end of list.\n    ScanEvents[TotalScanEvents].funcname[0]=0;                                      // name.\n    ScanEvents[TotalScanEvents].variant=-1;                                         // variant is typically enum, may be a type.\n    ScanEvents[TotalScanEvents].subvariant=-1;                                      // subvariant is typically a sensor-ID.\n} // END ROUTINE.\n\n\n//------------------------------------------------------------------------------\n// This is our iterator for the sorted list we built in scanEvents.  If\n// 'currentEvent' is NULL, it will find the first event matching the text with\n// the same device number. If not, it will find the first event after the\n// currentEvent that matches the text.  If no event matches the text and\n// device, it will return NULL. Note the list is in ascending order, by device,\n// text, variant, and subvariant. \n//------------------------------------------------------------------------------\n\nscanEvent_info_t* nextEvent(scanEvent_info_t* currentEvent, int device, char* funcname)\n{\n    int i;\n    if (currentEvent==NULL) {                                       // If starting from scratch do a brute force search.\n        for (i=0; i<TotalScanEvents; i++) {\n            if (ScanEvents[i].device == device &&                   // matched on device,\n                strcmp(ScanEvents[i].funcname, funcname) == 0) {    // matched on function name,\n                ScanEvents[i].used = 1;                             // Mark as one to be used.\n                return(&ScanEvents[i]);                             // Exit with pointer to first found.\n            }\n        } // end loop through events.\n\n#ifdef REPORT_KNOWN_EVENTS_NOT_SUPPORTED_BY_DEVICE\n        fprintf(stderr, \"Known Event not supported by hardware: '%s'\\n\", funcname);\n#endif \n        return(NULL);                                           // Never found.\n    }\n\n    // Here, we already have a current event.\n    // Remember, they are in sorted order.\n    currentEvent++;                                                     // Point at the next one, don't want to return same as last time.\n    if (currentEvent->device < 0) return(NULL);                         // Got to end of list.\n    if (strcmp(currentEvent->funcname, funcname) != 0) return(NULL);    // Got to end of this funcname.\n    currentEvent->used = 1;                                             // else found it, mark it used.\n    return(currentEvent);                                               // Return with next one.\n} // END nextEvent.\n\n\n//----------------------------------------------------------------------------\n// Link the necessary ROCM libraries to use the rocm component.  If any of\n// them cannot be found, then the ROCM component will just be disabled.  This\n// is done at runtime so that a version of PAPI built with the ROCM component\n// can be installed and used on systems which have the ROCM libraries\n// installed and on systems where these libraries are not installed.\nstatic int _rocm_smi_linkRocmLibraries(void)\n{\n    char path_name[1024];\n    // Attempt to guess if we were statically linked to libc, if so, get out.\n    if(_dl_non_dynamic_init != NULL) {\n        strncpy(_rocm_smi_vector.cmp_info.disabled_reason, \"The ROCM component does not support statically linking to libc.\", PAPI_MAX_STR_LEN);\n        return PAPI_ENOSUPP;\n    }\n\n    // collect any defined environment variables, or \"NULL\" if not present.\n    char *rocm_root =       getenv(\"PAPI_ROCM_ROOT\");\n    dl1 = NULL;                                                 // Ensure reset to NULL.\n\n    // Step 1: Process override if given.\n    if (strlen(rocm_smi_main) > 0) {                            // If override given, it has to work.\n        dl1 = dlopen(rocm_smi_main, RTLD_NOW | RTLD_GLOBAL);    // Try to open that path.\n        if (dl1 == NULL) {\n            snprintf(_rocm_smi_vector.cmp_info.disabled_reason, PAPI_MAX_STR_LEN, \"PAPI_ROCM_SMI_MAIN override '%s' given in Rules.rocm_smi not found.\", rocm_smi_main);\n            return(PAPI_ENOSUPP);   // Override given but not found.\n        }\n    }\n\n    // Step 2: Try system paths, will work with Spack, LD_LIBRARY_PATH, default paths.\n    if (dl1 == NULL) {                                              // No override,\n        dl1 = dlopen(\"librocm_smi64.so\", RTLD_NOW | RTLD_GLOBAL);   // Try system paths.\n    }\n\n    // Step 3: Try the explicit install default.\n    if (dl1 == NULL && rocm_root != NULL) {                          // if root given, try it.\n        snprintf(path_name, 1024, \"%s/rocm_smi/lib/librocm_smi64.so\", rocm_root);  // PAPI Root check.\n        dl1 = dlopen(path_name, RTLD_NOW | RTLD_GLOBAL);             // Try to open that path.\n    }\n\n    // Check for failure.\n    if (dl1 == NULL) {\n        snprintf(_rocm_smi_vector.cmp_info.disabled_reason, PAPI_MAX_STR_LEN, \"librocm_smi64.so not found.\");\n        return(PAPI_ENOSUPP);\n    }\n\n    // We have a dl1. (librocm_smi64.so).\n\n// SMI Library routines.\n    DLSYM_SMI(rsmi_num_monitor_devices);\n    DLSYM_SMI(rsmi_dev_supported_func_iterator_open);\n    DLSYM_SMI(rsmi_dev_supported_variant_iterator_open);\n    DLSYM_SMI(rsmi_dev_supported_variant_iterator_open);\n    DLSYM_SMI(rsmi_dev_supported_func_iterator_close);\n    DLSYM_SMI(rsmi_func_iter_value_get);\n    DLSYM_SMI(rsmi_func_iter_next);\n\n// All by device id.\n    DLSYM_SMI(rsmi_dev_id_get);\n    DLSYM_SMI(rsmi_dev_unique_id_get);\n    DLSYM_SMI(rsmi_dev_subsystem_vendor_id_get);\n    DLSYM_SMI(rsmi_dev_vendor_id_get);\n    DLSYM_SMI(rsmi_dev_subsystem_id_get);\n    DLSYM_SMI(rsmi_dev_drm_render_minor_get);\n    DLSYM_SMI(rsmi_dev_overdrive_level_get);\n    DLSYM_SMI(rsmi_dev_overdrive_level_set);\n    DLSYM_SMI(rsmi_dev_pci_id_get);\n    DLSYM_SMI(rsmi_dev_memory_busy_percent_get);\n\n    // Not implemented; data does not seem like useful performance data for PAPI users.\n    DLSYM_SMI(rsmi_dev_memory_reserved_pages_get);  // retrieves an array. \n\n\n\n// rsmi_dev_perf_level_t is just an enum; this can be returned as uint32.\n    DLSYM_SMI(rsmi_dev_perf_level_get);\n    DLSYM_SMI(rsmi_dev_perf_level_set);\n    DLSYM_SMI(rsmi_dev_gpu_clk_freq_get);\n\n// Iterate by memory type; an enum:\n// RSMI_MEM_TYPE_VRAM; RSMI_MEM_TYPE_VIS_VRAM; RSMI_MEM_TYPE_GTT. (VIS=visible).\n    DLSYM_SMI(rsmi_dev_memory_total_get);\n    DLSYM_SMI(rsmi_dev_memory_usage_get);\n    DLSYM_SMI(rsmi_dev_busy_percent_get);\n    DLSYM_SMI(rsmi_dev_firmware_version_get);\n\n// Iterate by GPU_BLOCK enum.\n    DLSYM_SMI(rsmi_dev_ecc_count_get);\n    DLSYM_SMI(rsmi_dev_ecc_enabled_get);\n    DLSYM_SMI(rsmi_dev_ecc_status_get);\n    \n// Need sensor-id (0...n) in name. All zero for starters.\n    DLSYM_SMI(rsmi_dev_fan_reset);\n    DLSYM_SMI(rsmi_dev_fan_rpms_get);\n    DLSYM_SMI(rsmi_dev_fan_speed_get);\n    DLSYM_SMI(rsmi_dev_fan_speed_max_get);\n    DLSYM_SMI(rsmi_dev_fan_speed_set);\n    DLSYM_SMI(rsmi_dev_power_ave_get);\n    DLSYM_SMI(rsmi_dev_power_cap_get);\n    DLSYM_SMI(rsmi_dev_power_profile_presets_get);\n    DLSYM_SMI(rsmi_dev_power_profile_set);\n\n// rsmi_temperature_metric_t is an enum with 14 settings; each would need to be an event.\n    DLSYM_SMI(rsmi_dev_temp_metric_get);\n\n// rsmi_version_t contains uint32 for major; minor; patch. but could return 16-bit packed version as uint64_t.\n    DLSYM_SMI(rsmi_version_get);\n\n// rsmi_range_t contains two uint64's; lower_bound; upper_bound.\n// This function has a prototype in the header file, but does not exist in the library. (circa Apr 5 2019).\n//  DLSYM_SMI(rsmi_dev_od_freq_range_set);\n\n// Needs to be two events; sent and received.\n    DLSYM_SMI(rsmi_dev_pci_throughput_get);\n\n    DLSYM_SMI(rsmi_dev_pci_replay_counter_get);\n\n// Needs to be two events; max and min.\n    DLSYM_SMI(rsmi_dev_power_cap_range_get);\n    DLSYM_SMI(rsmi_dev_power_cap_set);\n\n// rsmi_frequencies_t contains uint32 num_supported; uint32 current; uint64[] frequency.\n    DLSYM_SMI(rsmi_dev_gpu_clk_freq_get);\n    DLSYM_SMI(rsmi_dev_gpu_clk_freq_set);\n\n// rsmi_freq_volt_region_t contains two rsmi_range_t; each has two uint64's lower_bound; upper_bound.\n    DLSYM_SMI(rsmi_dev_od_volt_curve_regions_get);\n\n// rsmi_od_volt_freq_data_t Complex structure with 4 rsmi_range_t and a 2D array of voltage curve points.\n    DLSYM_SMI(rsmi_dev_od_volt_info_get);\n\n// rsmi_pcie_bandwidth_t is a structure containing two arrays; for transfer_rates and lanes.\n    DLSYM_SMI(rsmi_dev_pci_bandwidth_get);\n    DLSYM_SMI(rsmi_dev_pci_bandwidth_set);\n\n//  These functions return strings.\n    DLSYM_SMI(rsmi_dev_brand_get);\n    DLSYM_SMI(rsmi_dev_name_get);\n    DLSYM_SMI(rsmi_dev_serial_number_get);\n    DLSYM_SMI(rsmi_dev_subsystem_name_get);\n    DLSYM_SMI(rsmi_dev_vbios_version_get);\n    DLSYM_SMI(rsmi_dev_vendor_name_get);\n    DLSYM_SMI(rsmi_version_str_get);\n\n// Non-Events.\n    DLSYM_SMI(rsmi_init);\n    DLSYM_SMI(rsmi_shut_down);\n    DLSYM_SMI(rsmi_status_string);\n\n    return (PAPI_OK);\n}\n\n//-----------------------------------------------------------------------------\n// Find devices: We search the file system for\n// /sys/class/drm/card?/device/vendor. These must be sequential by card#; if \n// they can be opened and return a line, it will be 0xhhhh as a hex vendor ID.\n// 0x1002  is the vendor ID for AMD.\n// This constructs the global value TotalDevices, and fills in the DeviceCards\n// array with card-ids.\n//-----------------------------------------------------------------------------\nstatic int _rocm_smi_find_devices(void)\n{\n    char cardname[64]=\"/sys/class/drm/card?/device/vendor\";     // card filename.\n    uint32_t myVendor = 0x1002;                                 // The AMD GPU vendor ID.\n    char line[7];\n    size_t bytes;\n    int card;\n    long int devID;\n\n    TotalDevices=0;                                                     // Reset, in case called more than once.\n    line[6]=0;                                                          // ensure null terminator.\n\n    for (card=0; card<64; card++) {\n        sprintf(cardname, \"/sys/class/drm/card%i/device/vendor\", card); // make a name for myself.\n        FILE *fcard = fopen(cardname, \"r\");                             // Open for reading.\n        if (fcard == NULL) {                                            // Failed to open,\n            break;\n        }\n\n        bytes=fread(line, 1, 6, fcard);                                 // read six bytes.\n        fclose(fcard);                                                  // Always close it (avoid mem leak).\n        if (bytes != 6) {                                               // If we did not read 6,\n            break;                                                      // .. get out.\n        }\n\n        devID = strtol(line, NULL, 16);                                 // convert base 16 to long int. Handles '0xhhhh'. NULL=Don't need 'endPtr'.\n        if (devID != myVendor) continue;                                // Not the droid I am looking for.\n\n        // Found one.\n        DeviceCards[TotalDevices]=card;                                 // Remember this.\n        TotalDevices++;                                                 // count it.\n    } // end loop through possible cards.\n\n    if (TotalDevices == 0) {                                            // No AMD devices found.\n        char errstr[]=\"No AMD GPU devices found (vendor ID 0x1002).\";\n        strncpy(_rocm_smi_vector.cmp_info.disabled_reason, errstr, PAPI_MAX_STR_LEN);\n        return(PAPI_ENOSUPP);\n    }\n\n    return(PAPI_OK);\n} // end _rocm_smi_find_devices\n\n\n//-----------------------------------------------------------------------------\n// Read/Write Routines for each event. Prefixes 'er_', 'ew_' for event read,\n// event write, 'ed_' for event data structure if not implicit.\n// int(*reader)(int myIdx);   // event-specific read function (null if unreadable).\n// int(*writer)(int myIdx);   // event-specific write function (null if unwriteable).\n//-----------------------------------------------------------------------------\n\n// (rsmi_dev_id_get, (uint32_t dv_ind, uint16_t *id));\nstatic int er_device_id(int myIdx)\n{\n    uint16_t* data = (uint16_t*) AllEvents[myIdx].vptr;     // get a shortcut.\n    AllEvents[myIdx].value = 0;                             // Default if error.\n    RSMI(rsmi_dev_id_get,                                   // Routine name.\n        (AllEvents[myIdx].device, data),                    // device, and pointer for storage of read.\n        return(PAPI_EMISC));                                // Error handler.\n    AllEvents[myIdx].value = data[0];                       // Copy/convert the returned value.\n    return(PAPI_OK);                                        // Done.\n} // end reader.\n\n// (rsmi_dev_subsystem_vendor_id_get, (uint32_t dv_ind, uint16_t *id));\nstatic int er_subsystem_vendor_id(int myIdx)\n{\n    uint16_t* data = (uint16_t*) AllEvents[myIdx].vptr;     // get a shortcut.\n    AllEvents[myIdx].value = 0;                             // Default if error.\n    RSMI(rsmi_dev_subsystem_vendor_id_get,                  // Routine name.\n        (AllEvents[myIdx].device, data),                    // device, and pointer for storage of read.\n        return(PAPI_EMISC));                                // Error handler.\n    AllEvents[myIdx].value = data[0];                       // Copy/convert the returned value.\n    return(PAPI_OK);                                        // Done.\n} // end reader.\n\n// (rsmi_dev_vendor_id_get, (uint32_t dv_ind, uint16_t *id));\nstatic int er_vendor_id(int myIdx)\n{\n    uint16_t* data = (uint16_t*) AllEvents[myIdx].vptr;     // get a shortcut.\n    AllEvents[myIdx].value = 0;                             // Default if error.\n    RSMI(rsmi_dev_vendor_id_get,                            // Routine name.\n        (AllEvents[myIdx].device, data),                    // device, and pointer for storage of read.\n        return(PAPI_EMISC));                                // Error handler.\n    AllEvents[myIdx].value = data[0];                       // Copy/convert the returned value.\n    return(PAPI_OK);                                        // Done.\n} // end reader.\n\n// (rsmi_dev_unique_id_get, (uint32_t dv_ind, uint64_t *unique_id));\nstatic int er_unique_id(int myIdx)\n{\n    uint64_t* data = (uint64_t*) AllEvents[myIdx].vptr;     // get a shortcut.\n    AllEvents[myIdx].value = 0;                             // Default if error.\n    RSMI(rsmi_dev_unique_id_get,                            // Routine name.\n        (AllEvents[myIdx].device, data),                    // device, and pointer for storage of read.\n        return(PAPI_EMISC));                                // Error handler.\n    AllEvents[myIdx].value = data[0];                       // Copy/convert the returned value.\n    return(PAPI_OK);                                        // Done.\n} // end reader.\n\n// (rsmi_dev_subsystem_id_get, (uint32_t dv_ind, uint16_t *id));\nstatic int er_subsystem_id(int myIdx)\n{\n    uint16_t* data = (uint16_t*) AllEvents[myIdx].vptr;     // get a shortcut.\n    AllEvents[myIdx].value = 0;                             // Default if error.\n    RSMI(rsmi_dev_subsystem_id_get,                         // Routine name.\n        (AllEvents[myIdx].device, data),                    // device, and pointer for storage of read.\n        return(PAPI_EMISC));                                // Error handler.\n    AllEvents[myIdx].value = data[0];                       // Copy/convert the returned value.\n    return(PAPI_OK);                                        // Done.\n} // end reader.\n\n// (rsmi_dev_drm_render_minor_get, (uint32_t dv_ind, uint32_t *id));\nstatic int er_render_minor(int myIdx)\n{\n    uint32_t* data = (uint32_t*) AllEvents[myIdx].vptr;     // get a shortcut.\n    AllEvents[myIdx].value = 0;                             // Default if error.\n    RSMI(rsmi_dev_drm_render_minor_get,                     // Routine name.\n        (AllEvents[myIdx].device, data),                    // device, and pointer for storage of read.\n        return(PAPI_EMISC));                                // Error handler.\n    AllEvents[myIdx].value = data[0];                       // Copy/convert the returned value.\n    return(PAPI_OK);                                        // Done.\n} // end reader.\n\n// (rsmi_dev_overdrive_level_get, (uint32_t dv_ind, uint32_t *od));\nstatic int er_overdrive_level(int myIdx)\n{\n    uint32_t* data = (uint32_t*) AllEvents[myIdx].vptr;     // get a shortcut.\n    AllEvents[myIdx].value = 0;                             // Default if error.\n    RSMI(rsmi_dev_overdrive_level_get,                      // Routine name.\n        (AllEvents[myIdx].device, data),                    // device, and pointer for storage of read.\n        return(PAPI_EMISC));                                // Error handler.\n    AllEvents[myIdx].value = data[0];                       // Copy/convert the returned value.\n    return(PAPI_OK);                                        // Done.\n} // end reader.\n\n// (rsmi_dev_overdrive_level_set, (int32_t dv_ind, uint32_t od));\n// The data to write must be given in AllEvents[myIdx].value.\nstatic int ew_overdrive_level(int myIdx)\n{\n    uint32_t data = AllEvents[myIdx].value;                 // get a short cut to data.\n    RSMI(rsmi_dev_overdrive_level_set,                      // Routine name.\n        (AllEvents[myIdx].device, data),                    // device, and pointer for storage of read.\n        return(PAPI_EMISC));                                // Error handler.\n    return(PAPI_OK);                                        // Done.\n} // end writer.\n\n// (rsmi_dev_perf_level_get, (uint32_t dv_ind, rsmi_dev_perf_level_t *perf));\nstatic int er_perf_level(int myIdx)\n{\n    uint32_t* data = (uint32_t*) AllEvents[myIdx].vptr;     // get a shortcut.\n    AllEvents[myIdx].value = 0;                             // Default if error.\n    RSMI(rsmi_dev_perf_level_get,                           // Routine name.\n        (AllEvents[myIdx].device, data),                    // device, and pointer for storage of read.\n        return(PAPI_EMISC));                                // Error handler.\n    AllEvents[myIdx].value = data[0];                       // Copy/convert the returned value.\n    return(PAPI_OK);                                        // Done.\n} // end reader.\n\n// (rsmi_dev_perf_level_set, ( int32_t dv_ind, rsmi_dev_perf_level_t perf_lvl));\n// The data to write must be given in AllEvents[myIdx].value.\n// TONY: Should error-check value here, limited to enum values of rsmi_dev_perf_level_t.\nstatic int ew_perf_level(int myIdx)\n{\n    uint32_t data = AllEvents[myIdx].value;                 // get a short cut to data.\n    if (data > RSMI_DEV_PERF_LEVEL_LAST) return(PAPI_EINVAL);   // Error in value.\n    RSMI(rsmi_dev_perf_level_set,                           // Routine name.\n        (AllEvents[myIdx].device, data),                    // device, and pointer for storage of read.\n        return(PAPI_EMISC));                                // Error handler.\n    return(PAPI_OK);                                        // Done.\n} // end writer.\n\n// (rsmi_dev_memory_total_get, (uint32_t dv_ind, RSMI_MEM_TYPE_VRAM, uint64_t *total));\n// (rsmi_dev_memory_total_get, (uint32_t dv_ind, RSMI_MEM_TYPE_VIS_VRAM, uint64_t *total));\n// (rsmi_dev_memory_total_get, (uint32_t dv_ind, RSMI_MEM_TYPE_GTT, uint64_t *total));\nstatic int er_mem_total(int myIdx)\n{\n    uint64_t* data = (uint64_t*) AllEvents[myIdx].vptr;     // get a shortcut.\n    AllEvents[myIdx].value = 0;                             // Default if error.\n    RSMI(rsmi_dev_memory_total_get,                         // Routine name.\n        (AllEvents[myIdx].device,                           // device,\n         AllEvents[myIdx].variant, data),                   // memory type, and pointer for storage of read.\n        return(PAPI_EMISC));                                // Error handler.\n    AllEvents[myIdx].value = data[0];                       // Copy/convert the returned value.\n    return(PAPI_OK);                                        // Done.\n} // end reader.\n\n// (rsmi_dev_memory_usage_get, (uint32_t dv_ind, RSMI_MEM_TYPE_VRAM, uint64_t *usage));\n// (rsmi_dev_memory_usage_get, (uint32_t dv_ind, RSMI_MEM_TYPE_VIS_VRAM, uint64_t *usage));\n// (rsmi_dev_memory_usage_get, (uint32_t dv_ind, RSMI_MEM_TYPE_GTT, uint64_t *usage));\nstatic int er_mem_usage(int myIdx)\n{\n    uint64_t* data = (uint64_t*) AllEvents[myIdx].vptr;     // get a shortcut.\n    AllEvents[myIdx].value = 0;                             // Default if error.\n    RSMI(rsmi_dev_memory_usage_get,                         // Routine name.\n        (AllEvents[myIdx].device,                           // device,\n         AllEvents[myIdx].variant, data),                   // memory type, and pointer for storage of read.\n        return(PAPI_EMISC));                                // Error handler.\n    AllEvents[myIdx].value = data[0];                       // Copy/convert the returned value.\n    return(PAPI_OK);                                        // Done.\n} // end reader.\n\n// (rsmi_dev_busy_percent_get, (uint32_t dv_ind, uint32_t *busy_percent));\nstatic int er_busy_percent(int myIdx)\n{\n    uint32_t* data = (uint32_t*) AllEvents[myIdx].vptr;     // get a shortcut.\n    AllEvents[myIdx].value = 0;                             // Default if error.\n    RSMI(rsmi_dev_busy_percent_get,                         // Routine name.\n        (AllEvents[myIdx].device, data),                    // device, and pointer for storage of read.\n        return(PAPI_EMISC));                                // Error handler.\n    AllEvents[myIdx].value = data[0];                       // Copy/convert the returned value.\n    return(PAPI_OK);                                        // Done.\n} // end reader.\n\n// (rsmi_dev_memory_busy_percent_get, (uint32_t dv_ind, uint32_t *busy_percent));\n// NOTE UNTESTED EVENT: This is given in the manual, but our test driver/equipment did not support it.\nstatic int er_memory_busy_percent(int myIdx)\n{\n    uint32_t* data = (uint32_t*) AllEvents[myIdx].vptr;     // get a shortcut.\n    AllEvents[myIdx].value = 0;                             // Default if error.\n    RSMI(rsmi_dev_memory_busy_percent_get,                  // Routine name.\n        (AllEvents[myIdx].device, data),                    // device, and pointer for storage of read.\n        return(PAPI_EMISC));                                // Error handler.\n    AllEvents[myIdx].value = data[0];                       // Copy/convert the returned value.\n    return(PAPI_OK);                                        // Done.\n} // end reader.\n\n// (rsmi_dev_pci_id_get, (uint32_t dv_ind, uint64_t *bdfid));\nstatic int er_pci_id(int myIdx)\n{\n    uint64_t* data = (uint64_t*) AllEvents[myIdx].vptr;     // get a shortcut.\n    AllEvents[myIdx].value = 0;                             // Default if error.\n    RSMI(rsmi_dev_pci_id_get,                               // Routine name.\n        (AllEvents[myIdx].device, data),                    // device, and pointer for storage of read.\n        return(PAPI_EMISC));                                // Error handler.\n    AllEvents[myIdx].value = data[0];                       // Copy/convert the returned value.\n    return(PAPI_OK);                                        // Done.\n} // end reader.\n\n// (rsmi_dev_pci_replay_counter_get, (uint32_t dv_ind, uint64_t *counter));\nstatic int er_pci_replay_counter(int myIdx)\n{\n    uint64_t* data = (uint64_t*) AllEvents[myIdx].vptr;     // get a shortcut.\n    AllEvents[myIdx].value = 0;                             // Default if error.\n    RSMI(rsmi_dev_pci_replay_counter_get,                   // Routine name.\n        (AllEvents[myIdx].device, data),                    // device, and pointer for storage of read.\n        return(PAPI_EMISC));                                // Error handler.\n    AllEvents[myIdx].value = data[0];                       // Copy/convert the returned value.\n    return(PAPI_OK);                                        // Done.\n} // end reader.\n\n// (rsmi_version_get, (rsmi_version_t *version));\n// structure contains uint32_t for major, minor, patch (and pointer to 'build' string we don't use).\nstatic int er_rsmi_version(int myIdx)\n{\n    rsmi_version_t* data = (rsmi_version_t*) AllEvents[myIdx].vptr; // get a shortcut.\n    AllEvents[myIdx].value = 0;                             // Default if error.\n    RSMI(rsmi_version_get,                                  // Routine name.\n        (data),                                             // pointer for storage of read.\n        return(PAPI_EMISC));                                // Error handler.\n    uint64_t pack = 0;\n    pack = (data->major & 0x0000FFFF);                       // pack elements into a uint64.\n    pack = (pack << 16) | (data->minor & 0x0000FFFF);\n    pack = (pack << 16) | (data->patch & 0x0000FFFF);\n    AllEvents[myIdx].value = pack;                          // Copy/convert the returned value.\n    return(PAPI_OK);                                        // Done.\n} // end reader.\n\n// (rsmi_dev_pci_throughput_get, (uint32_t dv_ind, uint64_t *sent, uint64_t *received, uint64_t *max_pkt_sz));\nstatic int er_pci_throughput_sent(int myIdx)                // BASE EVENT. reads all three values.\n{\n    uint64_t* data = (uint64_t*) AllEvents[myIdx].vptr;     // get a shortcut.\n    AllEvents[myIdx].value = 0;                             // Default if error.\n    if (AllEvents[myIdx].read == 0) {                       // If I haven't read yet,\n        RSMI(rsmi_dev_pci_throughput_get,                   // .. Routine name.\n            (AllEvents[myIdx].device, &data[0], &data[1], &data[2]), // .. device and ptrs for storage of read.\n            return(PAPI_EMISC));                            // .. Error handler.\n        AllEvents[myIdx].read = 1;                          // .. Mark as read.\n    }\n\n    AllEvents[myIdx].value = data[0];                       // Copy/convert the returned value.\n    return(PAPI_OK);                                        // Done.\n} // end reader.\n\n// (rsmi_dev_pci_throughput_get, (uint32_t dv_ind, uint64_t *sent, uint64_t *received, uint64_t *max_pkt_sz));\nstatic int er_pci_throughput_received(int myIdx)            // NOT THE BASE EVENT; Base event already called.\n{\n    int idx = AllEvents[myIdx].baseIdx;                     // Get location of storage.\n    uint64_t* data = (uint64_t*) AllEvents[idx].vptr;       // get a shortcut.\n    AllEvents[myIdx].value = data[1];                       // Copy/convert the returned value.\n    return(PAPI_OK);                                        // Done.\n} // end reader.\n\n// (rsmi_dev_pci_throughput_get, (uint32_t dv_ind, uint64_t *sent, uint64_t *received, uint64_t *max_pkt_sz));\nstatic int er_pci_throughput_max_packet(int myIdx)          // NOT THE BASE EVENT; Base event already called.\n{\n    int idx = AllEvents[myIdx].baseIdx;                     // Get location of storage.\n    uint64_t* data = (uint64_t*) AllEvents[idx].vptr;       // get a shortcut.\n    AllEvents[myIdx].value = data[2];                       // Copy/convert the returned value.\n    return(PAPI_OK);                                        // Done.\n} // end reader.\n\n// (rsmi_dev_fan_reset, (uint32_t dv_ind, uint32_t sensor_ind));\nstatic int ew_fan_reset(int myIdx)\n{\n    (void) myIdx;                                           // Not needed. Only present for consistent function pointer.\n    RSMI(rsmi_dev_fan_reset,                                // Routine name.\n        (AllEvents[myIdx].device, AllEvents[myIdx].subvariant), // device, sensor. No data to write.\n        return(PAPI_EMISC));                                // Error handler.\n    return(PAPI_OK);                                        // Done.\n} // end reader.\n\n// (rsmi_dev_fan_rpms_get, (uint32_t dv_ind, uint32_t sensor_ind, int64_t *speed));\nstatic int er_fan_rpms(int myIdx)\n{\n    int64_t* data = (int64_t*) AllEvents[myIdx].vptr;       // get a shortcut.\n    AllEvents[myIdx].value = 0;                             // Default if error.\n    RSMI(rsmi_dev_fan_rpms_get,                             // Routine name.\n        (AllEvents[myIdx].device, AllEvents[myIdx].subvariant, data), // device, sensor, and pointer for storage of read.\n        return(PAPI_EMISC));                                // Error handler.\n    AllEvents[myIdx].value = data[0];                       // Copy/convert the returned value.\n    return(PAPI_OK);                                        // Done.\n} // end reader.\n\n// (rsmi_dev_fan_speed_max_get, (uint32_t dv_ind, uint32_t sensor_ind, uint64_t *max_speed));\nstatic int er_fan_speed_max(int myIdx)\n{\n    uint64_t* data = (uint64_t*) AllEvents[myIdx].vptr;     // get a shortcut.\n    AllEvents[myIdx].value = 0;                             // Default if error.\n    RSMI(rsmi_dev_fan_speed_max_get,                        // Routine name.\n        (AllEvents[myIdx].device, AllEvents[myIdx].subvariant, data), // device, sensor, and pointer for storage of read.\n        return(PAPI_EMISC));                                // Error handler.\n    AllEvents[myIdx].value = data[0];                       // Copy/convert the returned value.\n    return(PAPI_OK);                                        // Done.\n} // end reader.\n\n// (rsmi_dev_fan_speed_get, (uint32_t dv_ind, uint32_t sensor_ind, int64_t *speed));\nstatic int er_fan_speed(int myIdx)\n{\n    int64_t* data = (int64_t*) AllEvents[myIdx].vptr;       // get a shortcut.\n    AllEvents[myIdx].value = 0;                             // Default if error.\n    RSMI(rsmi_dev_fan_speed_get,                            // Routine name.\n        (AllEvents[myIdx].device, AllEvents[myIdx].subvariant, data), // device, sensor, and pointer for storage of read.\n        return(PAPI_EMISC));                                // Error handler.\n    AllEvents[myIdx].value = data[0];                       // Copy/convert the returned value.\n    return(PAPI_OK);                                        // Done.\n} // end reader.\n\n// (rsmi_dev_fan_speed_set, (uint32_t dv_ind, uint32_t sensor_ind, uint64_t speed));\nstatic int ew_fan_speed(int myIdx)\n{\n    uint64_t data = AllEvents[myIdx].value;                 // get a short cut to data.\n    if (data > 255) return(PAPI_EINVAL);                    // Invalid value.\n    RSMI(rsmi_dev_fan_speed_set,                            // Routine name.\n        (AllEvents[myIdx].device, AllEvents[myIdx].subvariant, data),                         // device, sensor. Data to write.\n        return(PAPI_EMISC));                                // Error handler.\n    return(PAPI_OK);                                        // Done.\n} // end writer.\n\n// (rsmi_dev_power_ave_get, (uint32_t dv_ind, uint32_t sensor_ind, uint64_t *power));\nstatic int er_power_ave(int myIdx)\n{\n    uint64_t* data = (uint64_t*) AllEvents[myIdx].vptr;     // get a shortcut.\n    AllEvents[myIdx].value = 0;                             // Default if error.\n    RSMI(rsmi_dev_power_ave_get,                            // Routine name.\n        (AllEvents[myIdx].device, AllEvents[myIdx].subvariant, data), // device, sensor, and pointer for storage of read.\n        return(PAPI_EMISC));                                // Error handler.\n    AllEvents[myIdx].value = data[0];                       // Copy/convert the returned value.\n    return(PAPI_OK);                                        // Done.\n} // end reader.\n\n// (rsmi_dev_power_cap_get, (uint32_t dv_ind, uint32_t sensor_ind, uint64_t *cap));\nstatic int er_power_cap(int myIdx)\n{\n    uint64_t* data = (uint64_t*) AllEvents[myIdx].vptr;     // get a shortcut.\n    AllEvents[myIdx].value = 0;                             // Default if error.\n    RSMI(rsmi_dev_power_cap_get,                            // Routine name.\n        (AllEvents[myIdx].device, AllEvents[myIdx].subvariant, data), // device, sensor, and pointer for storage of read.\n        return(PAPI_EMISC));                                // Error handler.\n    AllEvents[myIdx].value = data[0];                       // Copy/convert the returned value.\n    return(PAPI_OK);                                        // Done.\n} // end reader.\n\n// (rsmi_dev_power_cap_set, (uint32_t dv_ind, uint32_t sensor_ind, uint64_t cap));\nstatic int ew_power_cap(int myIdx)\n{\n    uint64_t data = AllEvents[myIdx].value;                 // get a short cut to data.\n    RSMI(rsmi_dev_power_cap_set,                            // Routine name.\n        (AllEvents[myIdx].device, AllEvents[myIdx].subvariant, data), // device, sensor. Data to write.\n        return(PAPI_EMISC));                                // Error handler.\n    return(PAPI_OK);                                        // Done.\n} // end writer.\n\n// (rsmi_dev_power_cap_range_get, (uint32_t dv_ind, uint32_t sensor_ind, uint64_t *max, uint64_t *min));\nstatic int er_power_cap_range_min(int myIdx)                // THIS IS THE BASE EVENT.\n{\n    uint64_t* data = (uint64_t*) AllEvents[myIdx].vptr;     // get a shortcut.\n    AllEvents[myIdx].value = 0;                             // Default if error.\n    if (AllEvents[myIdx].read == 0) {                       // If I haven't read yet,\n        RSMI(rsmi_dev_power_cap_range_get,                  // .. Routine name.\n            (AllEvents[myIdx].device, AllEvents[myIdx].subvariant, &data[1], &data[0]), // .. device, sensor, ptr->max, ptr->min.\n            return(PAPI_EMISC));                            // .. Error handler.\n        AllEvents[myIdx].read = 1;                          // .. Mark as read.\n    }\n\n    AllEvents[myIdx].value = data[0];                       // Copy/convert the returned value for min.\n    return(PAPI_OK);                                        // Done.\n} // end reader.\n\n// (rsmi_dev_power_cap_range_get, (uint32_t dv_ind, uint32_t sensor_ind, uint64_t *max, uint64_t *min));\nstatic int er_power_cap_range_max(int myIdx)                // NOT THE BASE EVENT; Base event already called.\n{\n    int idx = AllEvents[myIdx].baseIdx;\n    uint64_t* data = (uint64_t*) AllEvents[idx].vptr;       // get a shortcut to min/max.\n    AllEvents[myIdx].value = data[1];                       // Copy/convert the returned value for max.\n    return(PAPI_OK);                                        // Done.\n} // end reader.\n\n// (rsmi_dev_temp_metric_get, (uint32_t dv_ind, uint32_t sensor_ind, rsmi_temperature_metric_t metric, int64_t *temperature));\nstatic int er_temp(int myIdx)\n{\n    int64_t* data = (int64_t*) AllEvents[myIdx].vptr;       // get a shortcut.\n    AllEvents[myIdx].value = 0;                             // Default if error.\n    RSMI(rsmi_dev_temp_metric_get,                          // Routine name.\n        (AllEvents[myIdx].device,                           // Device,\n         AllEvents[myIdx].subvariant,                       // Sensor,\n         AllEvents[myIdx].variant, data),                   // temp type, and pointer for storage of read.\n        return(PAPI_EMISC));                                // Error handler.\n    AllEvents[myIdx].value = data[0];                       // Copy/convert the returned value.\n    return(PAPI_OK);                                        // Done.\n} // end reader.\n\n// rsmi_dev_firmware_version_get is an enum with 21 settings; each will be a separate event.\nstatic int er_firmware_version(int myIdx)\n{\n    uint64_t* data = (uint64_t*) AllEvents[myIdx].vptr;     // get a shortcut.\n    AllEvents[myIdx].value = 0;                             // Default if error.\n    RSMI(rsmi_dev_firmware_version_get,                     // Routine name.\n        (AllEvents[myIdx].device,                           // Device,\n         AllEvents[myIdx].variant, data),                   // firmware block ID, and pointer for storage of read.\n        return(PAPI_EMISC));                                // Error handler.\n    AllEvents[myIdx].value = data[0];                       // Copy/convert the returned value.\n    return(PAPI_OK);                                        // Done.\n} // end reader.\n\n// rsmi_dev_ecc_count_get is an enum with 14 settings; each will be a separate event.\n// NOTE UNTESTED EVENT: This is given in the manual, but our test driver/equipment did not support it.\nstatic int er_ecc_count_correctable(int myIdx)              // THIS IS A BASE EVENT.\n{\n    rsmi_error_count_t* data = (rsmi_error_count_t*) AllEvents[myIdx].vptr; // get a shortcut. \n    AllEvents[myIdx].value = 0;                             // Default if error.\n    if (AllEvents[myIdx].read == 0) {\n        RSMI(rsmi_dev_ecc_count_get,                        // ..Routine name.\n            (AllEvents[myIdx].device,                       // ..Device,\n             AllEvents[myIdx].variant, data),               // ..gpu block ID, and pointer for storage of read.\n            return(PAPI_EMISC));                            // ..Error handler.\n        AllEvents[myIdx].read = 1;                          // ..mark as read.\n    }\n\n    AllEvents[myIdx].value = data->correctable_err;         // Copy/convert the returned value.\n\n    return(PAPI_OK);                                        // Done.\n} // end reader.\n\n// rsmi_dev_ecc_count_get is an enum with 14 settings; each will be a separate event.\nstatic int er_ecc_count_uncorrectable(int myIdx)            // NOT THE BASE EVENT; Base event already called.\n{\n    int idx = AllEvents[myIdx].baseIdx;\n    rsmi_error_count_t* data = (rsmi_error_count_t*) AllEvents[idx].vptr; // get a shortcut. \n    AllEvents[myIdx].value = data->uncorrectable_err;       // Copy/convert the returned value for uncorrectable.\n    return(PAPI_OK);                                        // Done.\n} // end reader.\n\n// (rsmi_dev_ecc_enabled_get, (uint32_t dv_ind, uint64_t *mask));\n// NOTE UNTESTED EVENT: This is given in the manual, but our test driver/equipment did not support it.\nstatic int er_ecc_enabled(int myIdx)\n{\n    uint64_t* data = (uint64_t*) AllEvents[myIdx].vptr;     // get a shortcut.\n    AllEvents[myIdx].value = 0;                             // Default if error.\n    RSMI(rsmi_dev_ecc_enabled_get,                          // Routine name.\n        (AllEvents[myIdx].device, data),                    // device, data pointer.\n        return(PAPI_EMISC));                                // Error handler.\n    AllEvents[myIdx].value = data[0];                       // Copy/convert the returned value.\n    return(PAPI_OK);                                        // Done.\n} // end reader.\n\n// (rsmi_dev_ecc_status_get(uint32_t dv_ind, rsmi_gpu_block_t block, rsmi_ras_err_state_t \u2217 state)\n// NOTE UNTESTED EVENT: This is given in the manual, but our test driver/equipment did not support it.\nstatic int er_ecc_status(int myIdx)\n{\n    rsmi_ras_err_state_t* data = (rsmi_ras_err_state_t*) AllEvents[myIdx].vptr;  // get a shortcut.\n    AllEvents[myIdx].value = 0;                             // Default if error.\n    RSMI(rsmi_dev_ecc_status_get,                           // Routine name.\n        (AllEvents[myIdx].device,                           // Device,\n         AllEvents[myIdx].variant, data),                   // gpu block ID, and pointer for storage of read.\n        return(PAPI_EMISC));                                // Error handler.\n    AllEvents[myIdx].value = data[0];                       // Copy/convert the returned value.\n    return(PAPI_OK);                                        // Done.\n} // end reader.\n\n// rsmi_dev_gpu_clk_freq_get(device, clock_type, *rsmi_frequencies_t frequencies):\nstatic int er_gpu_clk_freq_current(int myIdx)\n{\n    AllEvents[myIdx].value = 0;\n    int idx = AllEvents[myIdx].device*freqTablePerDevice +\n              AllEvents[myIdx].variant;                     // Index into frequency table.\n    RSMI(rsmi_dev_gpu_clk_freq_get, \n         (AllEvents[myIdx].device, AllEvents[myIdx].variant, &FreqTable[idx]),\n         return(PAPI_EMISC));\n    int current = FreqTable[idx].current;\n    AllEvents[myIdx].value = FreqTable[idx].frequency[current];\n    return(PAPI_OK);    \n} // end reader\n\n// rsmi_dev_gpu_clk_freq_get(device, clock_type, *rsmi_frequencies_t frequencies):\nstatic int er_gpu_clk_freq_table(int myIdx)\n{\n    AllEvents[myIdx].value = 0;\n    int idx = AllEvents[myIdx].device*freqTablePerDevice +\n              AllEvents[myIdx].variant;                     // Index into frequency table.\n    uint32_t tblIdx = AllEvents[myIdx].subvariant;\n    RSMI(rsmi_dev_gpu_clk_freq_get, \n         (AllEvents[myIdx].device, AllEvents[myIdx].variant, &FreqTable[idx]),\n         return(PAPI_EMISC));\n    if (tblIdx >= FreqTable[idx].num_supported) {           // If this has changed,\n        return(PAPI_EMISC);                                 // Exit with error.\n    }\n\n    AllEvents[myIdx].value = FreqTable[idx].frequency[tblIdx];  // All okay, read newly loaded table.\n    return(PAPI_OK);    \n} // end reader\n\n// rsmi_dev_gpu_clk_freq_set ( uint32_t dv_ind, rsmi_clk_type_t clk_type, uint64_t freq_bitmask )\n// The data to write must be given in AllEvents[myIdx].value.\n// Note need to build a mask of num_supported bits, and insure data is not zero when masked with it.\n// e.g. for four bits, (1<<4)-1 = 2^4-1=15.\nstatic int ew_gpu_clk_freq_mask(int myIdx)\n{\n    uint64_t data = AllEvents[myIdx].value;                 // get a short cut to data.\n    uint64_t mask;\n    int idx = AllEvents[myIdx].device*freqTablePerDevice +\n              AllEvents[myIdx].variant;                     // Index into frequency table.\n    mask = (1<<FreqTable[idx].num_supported) - 1;           // build the mask.\n    if ((data & mask) == 0) {                               // If nothing is set,\n        return(PAPI_EINVAL);                                // invalid argument.\n    }\n\n    RSMI(rsmi_dev_gpu_clk_freq_set,                         // Routine name.\n        (AllEvents[myIdx].device,                           // device,\n         AllEvents[myIdx].variant,                          // Type of clock,\n         (data&mask)),                                      // Mask data before sending it.\n         return(PAPI_EMISC));                               // Error handler.\n\n    return(PAPI_OK);                                        // Done.\n} // end writer.\n\n// rsmi_dev_pci_bandwidth_get(device, *rsmi_pcie_bandwidth_t bandwidth):\nstatic int er_pci_bandwidth_rate_current(int myIdx)\n{\n    AllEvents[myIdx].value = 0;\n    int idx = AllEvents[myIdx].device;\n    RSMI(rsmi_dev_pci_bandwidth_get, \n         (AllEvents[myIdx].device, &PCITable[idx]),\n         return(PAPI_EMISC));\n    int current = PCITable[idx].transfer_rate.current;\n    AllEvents[myIdx].value = PCITable[idx].transfer_rate.frequency[current];\n    return(PAPI_OK);    \n} // end reader\n\n// rsmi_dev_pci_bandwidth_get(device, *rsmi_pcie_bandwidth_t bandwidth):\n// Returns PCI bandwidth rate value from supported_table[subvariant]\nstatic int er_pci_bandwidth_rate_table(int myIdx)\n{\n    AllEvents[myIdx].value = 0;\n    int idx = AllEvents[myIdx].device;\n    RSMI(rsmi_dev_pci_bandwidth_get, \n         (AllEvents[myIdx].device, &PCITable[idx]),\n         return(PAPI_EMISC));\n    int subIdx = AllEvents[myIdx].subvariant;                   // Get the subvariant for index into table.\n    AllEvents[myIdx].value = PCITable[idx].transfer_rate.frequency[subIdx];\n    return(PAPI_OK);    \n} // end reader\n\n// rsmi_dev_pci_bandwidth_get(device, *rsmi_pcie_bandwidth_t bandwidth):\n// Returns PCI bandwidth rate value from supported_table[subvariant]\n// Returns PCI bandwidth rate corresponding lane count from supported_table[subvariant]\nstatic int er_pci_bandwidth_lane_table(int myIdx)\n{\n    AllEvents[myIdx].value = 0;\n    int idx = AllEvents[myIdx].device;\n    RSMI(rsmi_dev_pci_bandwidth_get, \n         (AllEvents[myIdx].device, &PCITable[idx]),\n         return(PAPI_EMISC));\n    int subIdx = AllEvents[myIdx].subvariant;                   // Get the subvariant for index into table.\n    AllEvents[myIdx].value = PCITable[idx].lanes[subIdx];\n    return(PAPI_OK);    \n} // end reader\n\n// rsmi_dev_pci_bandwidth_set ( uint32_t dv_ind, uint64_t freq_bitmask )\n// The data to write must be given in AllEvents[myIdx].value.\n// Note need to build a mask of num_supported bits, and insure data is not zero when masked with it.\n// e.g. for four bits, (1<<4)-1 = 2^4-1=15.\nstatic int ew_pci_bandwidth_mask(int myIdx)\n{\n    uint64_t data = AllEvents[myIdx].value;                     // get a short cut to data.\n    uint64_t mask;\n    int idx = AllEvents[myIdx].device;                          // Index into frequency table.\n    mask = (1<<PCITable[idx].transfer_rate.num_supported) - 1;  // build the mask.\n    if ((data & mask) == 0) {                                   // If nothing is set,\n        return(PAPI_EINVAL);                                    // invalid argument.\n    }\n\n    RSMI(rsmi_dev_pci_bandwidth_set,                        // Routine name.\n        (AllEvents[myIdx].device,                           // device,\n         (data&mask)),                                      // Mask data before sending it.\n         return(PAPI_EMISC));                               // Error handler.\n\n    return(PAPI_OK);                                        // Done.\n} // end writer.\n\n// (rsmi_dev_power_profile_presets_get, (uint32_t dv_ind, uint32_t sensor, rsmi_power_profile_status_t *status);\nstatic int er_power_profile_presets_count(int myIdx)        // THIS IS THE BASE EVENT.\n{\n    rsmi_power_profile_status_t* status = (rsmi_power_profile_status_t*) AllEvents[myIdx].vptr; // get a shortcut.\n    AllEvents[myIdx].value = 0;                             // Default if error.\n    if (AllEvents[myIdx].read == 0) {                       // If I haven't read yet,\n        RSMI(rsmi_dev_power_profile_presets_get,            // .. Routine name.\n            (AllEvents[myIdx].device, AllEvents[myIdx].subvariant, status), // .. device, sensor, status pointer. \n            return(PAPI_EMISC));                            // .. Error handler.\n        AllEvents[myIdx].read = 1;                          // .. Mark as read.\n    }\n\n    AllEvents[myIdx].value = status->num_profiles;          // Copy/convert the returned value for number of profiles.\n    return(PAPI_OK);                                        // Done.\n} // end reader.\n\n// (rsmi_dev_power_profile_presets_get, (uint32_t dv_ind, uint32_t sensor, rsmi_power_profile_status_t *status);\nstatic int er_power_profile_presets_avail_profiles(int myIdx)   // NOT THE BASE EVENT; Base event already called.\n{\n    int idx = AllEvents[myIdx].baseIdx;\n    rsmi_power_profile_status_t* status = (rsmi_power_profile_status_t*) AllEvents[idx].vptr; // get a shortcut.\n    AllEvents[myIdx].value = status->available_profiles;    // Copy/convert the returned value for available profiles.\n    return(PAPI_OK);                                        // Done.\n} // end reader.\n\n// (rsmi_dev_power_profile_presets_get, (uint32_t dv_ind, uint32_t sensor, rsmi_power_profile_status_t *status);\nstatic int er_power_profile_presets_current(int myIdx)      // NOT THE BASE EVENT; Base event already called.\n{\n    int idx = AllEvents[myIdx].baseIdx;\n    rsmi_power_profile_status_t* status = (rsmi_power_profile_status_t*) AllEvents[idx].vptr; // get a shortcut.\n    AllEvents[myIdx].value = status->current;               // Copy/convert the returned value for current profile.\n    return(PAPI_OK);                                        // Done.\n} // end reader.\n\n// rsmi_dev_power_profile_set ( uint32_t dv_ind, uint32_t reserved, rsmi_power_profile_preset_masks_t profile_mask )\n// The data to write must be given in AllEvents[myIdx].value. It must be a power of 2, and <= RSMI_PWR_PROF_PRST_LAST.\nstatic int ew_power_profile_mask(int myIdx)\n{\n    uint64_t data = AllEvents[myIdx].value;                     // get a short cut to data.\n    if ((data & (data-1)) != 0) {                               // Not a power of two,\n        return(PAPI_EINVAL);                                    // .. so invalid argument.\n    }\n\n    if (data > RSMI_PWR_PROF_PRST_LAST) {                       // If not a VALID power of two,\n        return(PAPI_EINVAL);                                    // invalid argument.\n    }\n\n    RSMI(rsmi_dev_power_profile_set,                        // Routine name.\n        (AllEvents[myIdx].device,                           // device,\n         AllEvents[myIdx].subvariant,                       // sub variant for 'reserved'.\n         data),                                             // data to set.\n         return(PAPI_EMISC));                               // Error handler.\n\n    return(PAPI_OK);                                        // Done.\n} // end writer.\n\n\n// (rsmi_dev_brand_get(uint32_t dv_ind, char *brand, uint32_t len);\nstatic int er_brand(int myIdx)\n{\n    char *data = (char*) AllEvents[myIdx].vptr;             // get a shortcut.\n    AllEvents[myIdx].value = 0;                             // Default if error.\n    RSMI(rsmi_dev_brand_get,                                // Routine name.\n        (AllEvents[myIdx].device,                           // Device,\n         data,                                              // string location,\n         PAPI_MAX_STR_LEN-1),                               // max length of string.\n        return(PAPI_EMISC));                                // Error handler.\n    data[PAPI_MAX_STR_LEN-1] = 0;                           // Guarantee a zero terminator.\n    AllEvents[myIdx].value = (uint64_t) data;               // Copy/convert the returned value.\n    return(PAPI_OK);                                        // Done.\n} // end reader.\n\n// (rsmi_dev_name_get(uint32_t dv_ind, char *name, size_t len);\nstatic int er_name(int myIdx)\n{\n    char *data = (char*) AllEvents[myIdx].vptr;             // get a shortcut.\n    AllEvents[myIdx].value = 0;                             // Default if error.\n    RSMI(rsmi_dev_name_get,                                 // Routine name.\n        (AllEvents[myIdx].device,                           // Device,\n         data,                                              // string location,\n         PAPI_MAX_STR_LEN-1),                               // max length of string.\n        return(PAPI_EMISC));                                // Error handler.\n    data[PAPI_MAX_STR_LEN-1] = 0;                           // Guarantee a zero terminator.\n    AllEvents[myIdx].value = (uint64_t) data;               // Copy/convert the returned value.\n    return(PAPI_OK);                                        // Done.\n} // end reader.\n\n// (rsmi_dev_serial_number_get(uint32_t dv_ind, char *serial_number, uint32_t len);\n// NOTE UNTESTED EVENT: This is given in the manual, but our test driver/equipment did not support it.\nstatic int er_serial_number(int myIdx)\n{\n    char *data = (char*) AllEvents[myIdx].vptr;             // get a shortcut.\n    AllEvents[myIdx].value = 0;                             // Default if error.\n    RSMI(rsmi_dev_serial_number_get,                        // Routine name.\n        (AllEvents[myIdx].device,                           // Device,\n         data,                                              // string location,\n         PAPI_MAX_STR_LEN-1),                               // max length of string.\n        return(PAPI_EMISC));                                // Error handler.\n    data[PAPI_MAX_STR_LEN-1] = 0;                           // Guarantee a zero terminator.\n    AllEvents[myIdx].value = (uint64_t) data;               // Copy/convert the returned value.\n    return(PAPI_OK);                                        // Done.\n} // end reader.\n\n// (rsmi_dev_subsystem_name_get(uint32_t dv_ind, char *name, size_t len);\nstatic int er_subsystem_name(int myIdx)\n{\n    char *data = (char*) AllEvents[myIdx].vptr;             // get a shortcut.\n    AllEvents[myIdx].value = 0;                             // Default if error.\n    RSMI(rsmi_dev_subsystem_name_get,                       // Routine name.\n        (AllEvents[myIdx].device,                           // Device,\n         data,                                              // string location,\n         PAPI_MAX_STR_LEN-1),                               // max length of string.\n        return(PAPI_EMISC));                                // Error handler.\n    data[PAPI_MAX_STR_LEN-1] = 0;                           // Guarantee a zero terminator.\n    AllEvents[myIdx].value = (uint64_t) data;               // Copy/convert the returned value.\n    return(PAPI_OK);                                        // Done.\n} // end reader.\n\n// (rsmi_dev_vbios_version_get(uint32_t dv_ind, char *vbios, uint32_t len);\nstatic int er_vbios_version(int myIdx)\n{\n    char *data = (char*) AllEvents[myIdx].vptr;             // get a shortcut.\n    AllEvents[myIdx].value = 0;                             // Default if error.\n    RSMI(rsmi_dev_vbios_version_get,                        // Routine name.\n        (AllEvents[myIdx].device,                           // Device,\n         data,                                              // string location,\n         PAPI_MAX_STR_LEN-1),                               // max length of string.\n        return(PAPI_EMISC));                                // Error handler.\n    data[PAPI_MAX_STR_LEN-1] = 0;                           // Guarantee a zero terminator.\n    AllEvents[myIdx].value = (uint64_t) data;               // Copy/convert the returned value.\n    return(PAPI_OK);                                        // Done.\n} // end reader.\n\n// (rsmi_dev_vendor_name_get(uint32_t id, char *name, size_t len);\nstatic int er_vendor_name(int myIdx)\n{\n    char *data = (char*) AllEvents[myIdx].vptr;             // get a shortcut.\n    AllEvents[myIdx].value = 0;                             // Default if error.\n    RSMI(rsmi_dev_vendor_name_get,                          // Routine name.\n        (AllEvents[myIdx].device,                           // Device,\n         data,                                              // string location,\n         PAPI_MAX_STR_LEN-1),                               // max length of string.\n        return(PAPI_EMISC));                                // Error handler.\n    data[PAPI_MAX_STR_LEN-1] = 0;                           // Guarantee a zero terminator.\n    AllEvents[myIdx].value = (uint64_t) data;               // Copy/convert the returned value.\n    return(PAPI_OK);                                        // Done.\n} // end reader.\n\n// (rsmi_version_str_get(rsmi_sw_component_t id, char *name, size_t len);\nstatic int er_driver_version(int myIdx)\n{\n    char *data = (char*) AllEvents[myIdx].vptr;             // get a shortcut.\n    AllEvents[myIdx].value = 0;                             // Default if error.\n    RSMI(rsmi_version_str_get,                              // Routine name.\n        (RSMI_SW_COMP_DRIVER,                               // Only enumerated element. \n         data,                                              // string location,\n         PAPI_MAX_STR_LEN-1),                               // max length of string.\n        return(PAPI_EMISC));                                // Error handler.\n    data[PAPI_MAX_STR_LEN-1] = 0;                           // Guarantee a zero terminator.\n    AllEvents[myIdx].value = (uint64_t) data;               // Copy/convert the returned value.\n    return(PAPI_OK);                                        // Done.\n} // end reader.\n\n\n//=============================================================================\n// END OF RW ROUTINES.\n//=============================================================================\n\n//-----------------------------------------------------------------------------\n// All values get returned by calling routines that may vary in parameters.\n// Since we have no automatic list of events (or descriptions) we add them by\n// hand; along with pointers to the routines that must be called.\n//-----------------------------------------------------------------------------\nstatic int _rocm_smi_add_native_events(void)\n{\n    uint32_t device;\n    event_info_t* thisEvent=NULL;                       // an event pointer.\n    scanEvent_info_t* scan=NULL;                        // a scan event pointer.\n    TotalEvents = 0;\n    int BaseEvent = 0;\n    int subvariants;\n    int i;\n    uint32_t ui;\n    char *gpuClkVariantName[] = {\"System\", \"DataFabric\", \"DisplayEngine\", \"SOC\", \"Memory\"};\n    int enumList[64];                                   // List of enums found for variants.\n    #define enumSize (sizeof(enumList)/sizeof(enumList[0]))\n\n//  This call is no longer used, we do our own search in _rocm_smi_find_devices to set TotalDevices.\n//  RSMI(rsmi_num_monitor_devices, (&TotalDevices), return(PAPI_ENOSUPP));     // call for number of devices.\n\n//(rsmi_num_monitor_devices, (uint32_t *num_devices)); // ONLY ONE OF THESE.\n    MakeRoomAllEvents();\n    thisEvent = &AllEvents[TotalEvents];\n    snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"NUMDevices\");\n    strcpy(thisEvent->desc, \"Number of Devices which have monitors, accessible by rocm_smi.\");\n    thisEvent->reader = NULL;                           // No need to read anything, we have TotalDevices.\n    thisEvent->writer = NULL;                           // Not possible to change by writing.\n    thisEvent->device=-1;                               // There is no device to set in order to read.\n    thisEvent->baseIdx = TotalEvents;                   // Self.\n    thisEvent->vptrSize=0;                              // Not needed, reader returns TotalDevices.\n    thisEvent->vptr=NULL;                               // Not needed, reader returns TotalDevices.\n    thisEvent->value=TotalDevices;                      // A static event; always returns this.\n    thisEvent->variant=-1;                              // Not applicable.\n    thisEvent->subvariant=-1;                           // Not applicable.\n    TotalEvents++;                                      // Count it.\n    MakeRoomAllEvents();                                // Make room for another.\n\n    // rsmi_version_t contains uint32 for major; minor; patch. but could return 16-bit packed versions as uint64_t.\n    //(rsmi_version_get, (rsmi_version_t *version));\n    thisEvent = &AllEvents[TotalEvents];\n    snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"rsmi_version\");\n    strcpy(thisEvent->desc, \"Version of RSMI lib; 0x0000MMMMmmmmpppp Major, Minor, Patch.\");\n    thisEvent->reader = &er_rsmi_version;\n    thisEvent->writer = NULL;                           // Can't be written.\n    thisEvent->device=-1;\n    thisEvent->baseIdx = TotalEvents;                   // Self.\n    thisEvent->vptrSize=sizeof(rsmi_version_t);         // Memory for read.\n    thisEvent->vptr=calloc(1, thisEvent->vptrSize);\n    thisEvent->variant=-1;                              // Not applicable.\n    thisEvent->subvariant=-1;                           // Not applicable.\n    TotalEvents++;                                      // Count it.\n    MakeRoomAllEvents();                                // Make room for another.\n\n    thisEvent = &AllEvents[TotalEvents];\n    snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"driver_version_str\");\n    strcpy(thisEvent->desc, \"Returns char* to  z-terminated driver version string; do not free().\");\n    thisEvent->reader = &er_driver_version;\n    thisEvent->writer = NULL;                           // Can't be written.\n    thisEvent->device=-1;            \n    thisEvent->baseIdx = TotalEvents;                   // Self.\n    thisEvent->vptrSize=(PAPI_MAX_STR_LEN);             // Memory for read.\n    thisEvent->vptr=calloc(thisEvent->vptrSize, sizeof(char));  \n    thisEvent->variant=-1;                              // Not applicable.\n    thisEvent->subvariant=-1;                           // Not applicable.\n    TotalEvents++;                                      // Count it.\n    MakeRoomAllEvents();                                // Make room for another.\n\n// The following require a device ID.\n\n    for (device=0; device < TotalDevices; device++) {   // For every event requiring a device argument,\n        //(rsmi_dev_id_get, (uint32_t dv_ind, uint16_t *id));\n        thisEvent = &AllEvents[TotalEvents];\n        scan = NULL;\n        scan = nextEvent(scan, device, \"rsmi_dev_id_get\");\n        if (scan != NULL) {                             // If we found it,\n            snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"device_id:device=%i\", device);\n            strcpy(thisEvent->desc, \"Vendor supplied device id number. May be shared by same model devices; see pci_id for a unique identifier.\");\n            thisEvent->reader = &er_device_id;\n            thisEvent->writer = NULL;\n            thisEvent->device=device;\n            thisEvent->baseIdx = TotalEvents;                   // Self.\n            thisEvent->vptrSize=sizeof(uint16_t);\n            thisEvent->vptr=calloc(1, thisEvent->vptrSize);\n            thisEvent->variant=scan->variant;                   // Copy the variant.\n            thisEvent->subvariant=scan->subvariant;             // Copy the subvariant.\n            TotalEvents++;                                      // Count it.\n            MakeRoomAllEvents();                                // Make room for another.\n        } // end if found.\n\n        //(rsmi_dev_subsystem_vendor_id_get, (uint32_t dv_ind, uint16_t *id));\n        thisEvent = &AllEvents[TotalEvents];\n        scan = NULL;\n        scan = nextEvent(scan, device, \"rsmi_dev_subsystem_vendor_id_get\");\n        if (scan != NULL) {\n            snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"subsystem_vendor_id:device=%i\", device);\n            strcpy(thisEvent->desc, \"Subsystem vendor id number.\");\n            thisEvent->reader = &er_subsystem_vendor_id;\n            thisEvent->writer = NULL;\n            thisEvent->device=device;\n            thisEvent->baseIdx = TotalEvents;                   // Self.\n            thisEvent->vptrSize=sizeof(uint16_t);\n            thisEvent->vptr=calloc(1, thisEvent->vptrSize);\n            thisEvent->variant=scan->variant;                   // Copy the variant.\n            thisEvent->subvariant=scan->subvariant;             // Copy the subvariant.\n            TotalEvents++;                                      // Count it.\n            MakeRoomAllEvents();                                // Make room for another.\n        }\n\n        //(rsmi_dev_vendor_id_get, (uint32_t dv_ind, uint16_t *id));\n        scan = NULL;\n        scan = nextEvent(scan, device, \"rsmi_dev_vendor_id_get\");\n        if (scan != NULL) {\n            thisEvent = &AllEvents[TotalEvents];\n            snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"vendor_id:device=%i\", device);\n            strcpy(thisEvent->desc, \"Vendor id number.\");\n            thisEvent->reader = &er_vendor_id;\n            thisEvent->writer = NULL;\n            thisEvent->device=device;\n            thisEvent->baseIdx = TotalEvents;                   // Self.\n            thisEvent->vptrSize=sizeof(uint16_t);\n            thisEvent->vptr=calloc(1, thisEvent->vptrSize);\n            thisEvent->variant=-1;                              // Not applicable.\n            thisEvent->subvariant=-1;                           // Not applicable.\n            TotalEvents++;                                      // Count it.\n            MakeRoomAllEvents();                                // Make room for another.\n        }\n\n        //(rsmi_dev_unique_id_get, (uint32_t dv_ind, uint64_t *id));\n        scan = NULL;\n        scan = nextEvent(scan, device, \"rsmi_dev_unique_id_get\");\n        if (scan != NULL) {\n            thisEvent = &AllEvents[TotalEvents];\n            snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"unique_id:device=%i\", device);\n            strcpy(thisEvent->desc, \"unique Id for device.\");\n            thisEvent->reader = &er_unique_id;\n            thisEvent->writer = NULL;\n            thisEvent->device=device;\n            thisEvent->baseIdx = TotalEvents;                   // Self.\n            thisEvent->vptrSize=sizeof(uint64_t);\n            thisEvent->vptr=calloc(1, thisEvent->vptrSize);\n            thisEvent->variant=-1;                              // Not applicable.\n            thisEvent->subvariant=-1;                           // Not applicable.\n            TotalEvents++;                                      // Count it.\n            MakeRoomAllEvents();                                // Make room for another.\n        }\n\n        //(rsmi_dev_subsystem_id_get, (uint32_t dv_ind, uint16_t *id));\n        scan = NULL;\n        scan = nextEvent(scan, device, \"rsmi_dev_subsystem_id_get\");\n        if (scan != NULL) {\n            thisEvent = &AllEvents[TotalEvents];\n            snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"subsystem_id:device=%i\", device);\n            strcpy(thisEvent->desc, \"Subsystem id number.\");\n            thisEvent->reader = &er_subsystem_id;\n            thisEvent->writer = NULL;\n            thisEvent->device=device;\n            thisEvent->baseIdx = TotalEvents;                   // Self.\n            thisEvent->vptrSize=sizeof(uint16_t);\n            thisEvent->vptr=calloc(1, thisEvent->vptrSize);\n            thisEvent->variant=-1;                              // Not applicable.\n            thisEvent->subvariant=-1;                           // Not applicable.\n            TotalEvents++;                                      // Count it.\n            MakeRoomAllEvents();                                // Make room for another.\n        }\n\n        //(rsmi_dev_drm_render_minor_get, (uint32_t dv_ind, uint32_t *minor));\n        scan = NULL;\n        scan = nextEvent(scan, device, \"rsmi_dev_drm_render_minor_get\");\n        if (scan != NULL) {\n            thisEvent = &AllEvents[TotalEvents];\n            snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"drm_render_minor:device=%i\", device);\n            strcpy(thisEvent->desc, \"DRM Minor Number associated with this device.\");\n            thisEvent->reader = &er_render_minor;\n            thisEvent->writer = NULL;\n            thisEvent->device=device;\n            thisEvent->baseIdx = TotalEvents;                   // Self.\n            thisEvent->vptrSize=sizeof(uint16_t);\n            thisEvent->vptr=calloc(1, thisEvent->vptrSize);\n            thisEvent->variant=-1;                              // Not applicable.\n            thisEvent->subvariant=-1;                           // Not applicable.\n            TotalEvents++;                                      // Count it.\n            MakeRoomAllEvents();                                // Make room for another.\n        }\n\n        //(rsmi_dev_overdrive_level_get, (uint32_t dv_ind, uint32_t *od));\n        //(rsmi_dev_overdrive_level_set, (int32_t dv_ind, uint32_t od));\n        scan = NULL;\n        scan = nextEvent(scan, device, \"rsmi_dev_overdrive_level_get\");\n        if (scan != NULL) {\n            thisEvent = &AllEvents[TotalEvents];\n            snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"overdrive_level:device=%i\", device);\n            strcpy(thisEvent->desc, \"Overdrive Level % for device, 0 to 20, max overclocking permitted. Read Only.\");\n            thisEvent->reader = &er_overdrive_level;\n            thisEvent->writer = NULL;\n            thisEvent->device=device;\n            thisEvent->baseIdx = TotalEvents;                   // Self.\n            thisEvent->vptrSize=sizeof(uint32_t);\n            thisEvent->vptr=calloc(1, thisEvent->vptrSize);\n            thisEvent->variant=-1;                              // Not applicable.\n            thisEvent->subvariant=-1;                           // Not applicable.\n            scan = NULL;\n            scan = nextEvent(scan, device, \"rsmi_dev_overdrive_level_set\");\n            if (scan != NULL) {\n                thisEvent->writer = &ew_overdrive_level;            // Can be written.\n                strcpy(thisEvent->desc, \"Overdrive Level % for device, 0 to 20, max overclocking permitted. Read/Write. WRITE MAY CAUSE DAMAGE NOT COVERED BY ANY WARRANTY.\");\n            }\n\n            TotalEvents++;                                      // Count it.\n            MakeRoomAllEvents();                                // Make room for another.\n        }\n\n        // rsmi_dev_perf_level_t is just an enum; this can be returned as uint32.\n        //(rsmi_dev_perf_level_get, (uint32_t dv_ind, rsmi_dev_perf_level_t *perf));\n        //(rsmi_dev_perf_level_set, ( int32_t dv_ind, rsmi_dev_perf_level_t perf_lvl));\n        scan = NULL;\n        scan = nextEvent(scan, device, \"rsmi_dev_perf_level_get\");\n        if (scan != NULL) {\n            thisEvent = &AllEvents[TotalEvents];\n            snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"perf_level:device=%i\", device);\n            snprintf(thisEvent->desc, PAPI_MAX_STR_LEN-1, \"PowerPlay Performance Level; Read Only, enum 'rsmi_dev_perf_level_t' [0-%i], see ROCm_SMI_Manual for details.\", RSMI_DEV_PERF_LEVEL_LAST);\n            thisEvent->reader = &er_perf_level;\n            thisEvent->writer = &ew_perf_level;                 // Can be written.\n            thisEvent->device=device;\n            thisEvent->baseIdx = TotalEvents;                   // Self.\n            thisEvent->vptrSize=sizeof(uint32_t);\n            thisEvent->vptr=calloc(1, thisEvent->vptrSize);\n            thisEvent->variant=-1;                              // Not applicable.\n            thisEvent->subvariant=-1;                           // Not applicable.\n            scan = NULL;\n            scan = nextEvent(scan, device, \"rsmi_dev_perf_level_set\");\n            if (scan != NULL) {\n                thisEvent->writer = &ew_perf_level;                 // Can be written.\n                snprintf(thisEvent->desc, PAPI_MAX_STR_LEN-1, \"PowerPlay Performance Level; Read/Write, enum 'rsmi_dev_perf_level_t' [0-%i], see ROCm_SMI_Manual for details.\", RSMI_DEV_PERF_LEVEL_LAST);\n            }\n\n            TotalEvents++;                                      // Count it.\n            MakeRoomAllEvents();                                // Make room for another.\n        }\n\n        // Iterate by memory type; an enum:\n        // RSMI_MEM_TYPE_VRAM; RSMI_MEM_TYPE_VIS_VRAM; RSMI_MEM_TYPE_GTT. (VIS=visible). In ascending\n        // order, to be found in rocm_smi.h, as an enum. However, we show these as three separate events. \n\n        //(rsmi_dev_memory_total_get, (uint32_t dv_ind, rsmi_memory_type_t mem_type, uint64_t *total));\n        for (i=0; i<3; i++) enumList[i]=0;                      // init to false.\n        scan = NULL;\n        scan = nextEvent(scan, device, \"rsmi_dev_memory_total_get\");\n        while (scan != NULL && scan->variant < RSMI_MEM_TYPE_GTT) {\n            enumList[scan->variant] = 1;                                    // show the variant as found.\n            scan = nextEvent(scan, device, \"rsmi_dev_memory_total_get\");    // Get the next, if any.\n        }\n            \n        if (enumList[0]) {                                      // If we found TOTAL VRAM,\n            thisEvent = &AllEvents[TotalEvents];\n            snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"mem_total_VRAM:device=%i\", device);\n            strcpy(thisEvent->desc, \"Total VRAM memory.\");\n            thisEvent->reader = &er_mem_total;\n            thisEvent->writer = NULL;                           // Can't be written.\n            thisEvent->device=device;\n            thisEvent->baseIdx = TotalEvents;                   // Self.\n            thisEvent->vptrSize=sizeof(uint64_t);               // Memory for read.\n            thisEvent->vptr=calloc(1, thisEvent->vptrSize);\n            thisEvent->variant=RSMI_MEM_TYPE_VRAM;              // The enum for it\n            thisEvent->subvariant=-1;                           // Not applicable.\n            TotalEvents++;                                      // Count it.\n            MakeRoomAllEvents();                                // Make room for another.\n        }\n\n        if (enumList[1]) {                                      // If we found VISIBLE VRAM,\n            thisEvent = &AllEvents[TotalEvents];\n            snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"mem_total_VIS_VRAM:device=%i\", device);\n            strcpy(thisEvent->desc, \"Total Visible VRAM memory.\");\n            thisEvent->reader = &er_mem_total;\n            thisEvent->writer = NULL;                           // Can't be written.\n            thisEvent->device=device;\n            thisEvent->baseIdx = TotalEvents;                   // Self.\n            thisEvent->vptrSize=sizeof(uint64_t);               // Memory for read.\n            thisEvent->vptr=calloc(1, thisEvent->vptrSize);\n            thisEvent->variant=RSMI_MEM_TYPE_VIS_VRAM;          // The enum for it.\n            thisEvent->subvariant=-1;                           // Not applicable.\n            TotalEvents++;                                      // Count it.\n            MakeRoomAllEvents();                                // Make room for another.\n        }\n\n        if (enumList[2]) {                                      // If we found TOTAL GTT, \n            thisEvent = &AllEvents[TotalEvents];\n            snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"mem_total_GTT:device=%i\", device);\n            strcpy(thisEvent->desc, \"Total GTT (Graphics Translation Table) memory, aka GART memory.\");\n            thisEvent->reader = &er_mem_total;\n            thisEvent->writer = NULL;                           // Can't be written.\n            thisEvent->device=device;\n            thisEvent->baseIdx = TotalEvents;                   // Self.\n            thisEvent->vptrSize=sizeof(uint64_t);               // Memory for read.\n            thisEvent->vptr=calloc(1, thisEvent->vptrSize);\n            thisEvent->variant=RSMI_MEM_TYPE_GTT;               // The enum for it.\n            thisEvent->subvariant=-1;                           // Not applicable.\n            TotalEvents++;                                      // Count it.\n            MakeRoomAllEvents();                                // Make room for another.\n        }\n\n        for (i=0; i<3; i++) enumList[i]=0;                      // init to false.\n        scan = NULL;\n        scan = nextEvent(scan, device, \"rsmi_dev_memory_usage_get\");\n        while (scan != NULL && scan->variant < RSMI_MEM_TYPE_GTT) {\n            enumList[scan->variant] = 1;                                    // show the variant as found.\n            scan = nextEvent(scan, device, \"rsmi_dev_memory_usage_get\");    // Get the next, if any.\n        }\n            \n        //(rsmi_dev_memory_usage_get, (uint32_t dv_ind, rsmi_memory_type_t mem_type, uint64_t *used));\n        if (enumList[0]) {                                      // If we found USAGE VRAM,\n            thisEvent = &AllEvents[TotalEvents];\n            snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"mem_usage_VRAM:device=%i\", device);\n            strcpy(thisEvent->desc, \"VRAM memory in use.\");\n            thisEvent->reader = &er_mem_usage;\n            thisEvent->writer = NULL;                           // Can't be written.\n            thisEvent->device=device;\n            thisEvent->baseIdx = TotalEvents;                   // Self.\n            thisEvent->vptrSize=sizeof(uint64_t);               // Memory for read.\n            thisEvent->vptr=calloc(1, thisEvent->vptrSize);\n            thisEvent->variant=RSMI_MEM_TYPE_VRAM;              // The enum for it\n            thisEvent->subvariant=-1;                           // Not applicable.\n            TotalEvents++;                                      // Count it.\n            MakeRoomAllEvents();                                // Make room for another.\n        }\n\n        if (enumList[1]) {                                      // If we found USAGE VIS VRAM,\n            thisEvent = &AllEvents[TotalEvents];\n            snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"mem_usage_VIS_VRAM:device=%i\", device);\n            strcpy(thisEvent->desc, \"Visible VRAM memory in use.\");\n            thisEvent->reader = &er_mem_usage;\n            thisEvent->writer = NULL;                           // Can't be written.\n            thisEvent->device=device;\n            thisEvent->baseIdx = TotalEvents;                   // Self.\n            thisEvent->vptrSize=sizeof(uint64_t);               // Memory for read.\n            thisEvent->vptr=calloc(1, thisEvent->vptrSize);\n            thisEvent->variant=RSMI_MEM_TYPE_VIS_VRAM;          // The enum for it.\n            thisEvent->subvariant=-1;                           // Not applicable.\n            TotalEvents++;                                      // Count it.\n            MakeRoomAllEvents();                                // Make room for another.\n        }\n\n        if (enumList[2]) {                                      // If we found USAGE GTT,\n            thisEvent = &AllEvents[TotalEvents];\n            snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"mem_usage_GTT:device=%i\", device);\n            strcpy(thisEvent->desc, \"(Graphics Translation Table) memory in use (aka GART memory).\");\n            thisEvent->reader = &er_mem_usage;\n            thisEvent->writer = NULL;                           // Can't be written.\n            thisEvent->device=device;\n            thisEvent->baseIdx = TotalEvents;                   // Self.\n            thisEvent->vptrSize=sizeof(uint64_t);               // Memory for read.\n            thisEvent->vptr=calloc(1, thisEvent->vptrSize);\n            thisEvent->variant=RSMI_MEM_TYPE_GTT;               // The enum for it.\n            thisEvent->subvariant=-1;                           // Not applicable.\n            TotalEvents++;                                      // Count it.\n            MakeRoomAllEvents();                                // Make room for another.\n        }\n\n        //(rsmi_dev_busy_percent_get, (uint32_t dv_ind, uint32_t *bdfid));\n        scan = NULL;\n        scan = nextEvent(scan, device, \"rsmi_dev_busy_percent_get\");\n        if (scan != NULL) {\n            thisEvent = &AllEvents[TotalEvents];\n            snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"busy_percent:device=%i\", device);\n            strcpy(thisEvent->desc, \"Percentage of time the device was busy doing any processing.\");\n            thisEvent->reader = &er_busy_percent;\n            thisEvent->writer = NULL;                           // Can't be written.\n            thisEvent->device=device;\n            thisEvent->baseIdx = TotalEvents;                   // Self.\n            thisEvent->vptrSize=sizeof(uint32_t);               // Memory for read.\n            thisEvent->vptr=calloc(1, thisEvent->vptrSize);\n            thisEvent->variant=-1;                              // Not applicable.\n            thisEvent->subvariant=-1;                           // Not applicable.\n            TotalEvents++;                                      // Count it.\n            MakeRoomAllEvents();                                // Make room for another.\n        }\n\n        //(rsmi_dev_memory_busy_percent_get, (uint32_t dv_ind, uint32_t *bdfid));\n        scan = NULL;\n        scan = nextEvent(scan, device, \"rsmi_dev_memory_busy_percent_get\");\n        if (scan != NULL) {\n            thisEvent = &AllEvents[TotalEvents];\n            snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"memory_busy_percent:device=%i\", device);\n            strcpy(thisEvent->desc, \"Percentage of time any device memory is being used.\");\n            thisEvent->reader = &er_memory_busy_percent;\n            thisEvent->writer = NULL;                           // Can't be written.\n            thisEvent->device=device;\n            thisEvent->baseIdx = TotalEvents;                   // Self.\n            thisEvent->vptrSize=sizeof(uint32_t);               // Memory for read.\n            thisEvent->vptr=calloc(1, thisEvent->vptrSize);\n            thisEvent->variant=-1;                              // Not applicable.\n            thisEvent->subvariant=-1;                           // Not applicable.\n            TotalEvents++;                                      // Count it.\n            MakeRoomAllEvents();                                // Make room for another.\n        }\n\n        //(rsmi_dev_pci_id_get, (uint32_t dv_ind, uint64_t *bdfid));\n        scan = NULL;\n        scan = nextEvent(scan, device, \"rsmi_dev_pci_id_get\");\n        if (scan != NULL) {\n            thisEvent = &AllEvents[TotalEvents];\n            snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"pci_id:device=%i\", device);\n            strcpy(thisEvent->desc, \"BDF (Bus/Device/Function) ID, unique per device.\");\n            thisEvent->reader = &er_pci_id;\n            thisEvent->writer = NULL;                           // Can't be written.\n            thisEvent->device=device;\n            thisEvent->baseIdx = TotalEvents;                   // Self.\n            thisEvent->vptrSize=sizeof(uint64_t);               // Memory for read.\n            thisEvent->vptr=calloc(1, thisEvent->vptrSize);\n            thisEvent->variant=-1;                              // Not applicable.\n            thisEvent->subvariant=-1;                           // Not applicable.\n            TotalEvents++;                                      // Count it.\n            MakeRoomAllEvents();                                // Make room for another.\n        }\n\n        //(rsmi_dev_pci_replay_counter_get, (uint32_t dv_ind, uint64_t *counter));\n        scan = NULL;\n        scan = nextEvent(scan, device, \"rsmi_dev_pci_replay_counter_get\");\n        if (scan != NULL) {\n            thisEvent = &AllEvents[TotalEvents];\n            snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"pci_replay_counter:device=%i\", device);\n            strcpy(thisEvent->desc, \"Sum of the number of NAK's received by the GPU and the NAK's generated by the GPU.\");\n            thisEvent->reader = &er_pci_replay_counter;\n            thisEvent->writer = NULL;                           // Can't be written.\n            thisEvent->device=device;\n            thisEvent->baseIdx = TotalEvents;                   // Self.\n            thisEvent->vptrSize=sizeof(uint64_t);               // Memory for read.\n            thisEvent->vptr=calloc(1, thisEvent->vptrSize);\n            thisEvent->variant=-1;                              // Not applicable.\n            thisEvent->subvariant=-1;                           // Not applicable.\n            TotalEvents++;                                      // Count it.\n            MakeRoomAllEvents();                                // Make room for another.\n        }\n\n        // rsmi_range_t contains two uint64's; lower_bound; upper_bound.\n        // This function has a prototype in the header file, but does not exist in the library. (circa Apr 5 2019).\n        // //(rsmi_dev_od_freq_range_set, (uint32_t dv_ind, rsmi_clk_type_t clk, rsmi_range_t *range));\n\n        // -------------- BEGIN BASE EVENT -----------------\n        // Needs to be three events; sent; received; max_pkt_size.\n        //(rsmi_dev_pci_throughput_get, (uint32_t dv_ind, uint64_t *sent, uint64_t *received, uint64_t *max_pkt_sz));\n        scan = NULL;\n        scan = nextEvent(scan, device, \"rsmi_dev_pci_throughput_get\");\n        if (scan != NULL) {\n            thisEvent = &AllEvents[TotalEvents];\n            snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"pci_throughput_sent:device=%i\", device);\n            strcpy(thisEvent->desc, \"Throughput on PCIe traffic, bytes/second sent.\");\n            thisEvent->reader = &er_pci_throughput_sent;\n            thisEvent->writer = NULL;                           // Can't be written.\n            thisEvent->device=device;\n            thisEvent->baseIdx = TotalEvents;                   // Self.\n            thisEvent->vptrSize=sizeof(uint64_t);               // Memory for read.\n            thisEvent->vptr=calloc(3, thisEvent->vptrSize);     // Space for three variables.\n            thisEvent->variant=-1;                              // Not applicable.\n            thisEvent->subvariant=-1;                           // Not applicable.\n            BaseEvent = TotalEvents;                            // Begin base event.\n            TotalEvents++;                                      // Count it.\n            MakeRoomAllEvents();                                // Make room for another.\n\n            if (TotalEvents > BaseEvent) {                      // If the base did not succeed, do not add dependents.\n                thisEvent = &AllEvents[TotalEvents];\n                snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"pci_throughput_received:device=%i\", device);\n                strcpy(thisEvent->desc, \"Throughput on PCIe traffic, bytes/second received.\");\n                thisEvent->reader = &er_pci_throughput_received;\n                thisEvent->writer = NULL;                           // Can't be written.\n                thisEvent->device=device;\n                thisEvent->baseIdx = BaseEvent;                     // NOT SELF, part of a group read.\n                thisEvent->vptrSize=0;                              // Nothing to read, uses BaseEvent memory.\n                thisEvent->vptr=NULL;                               // ..\n                thisEvent->variant=-1;                              // Not applicable.\n                thisEvent->subvariant=-1;                           // Not applicable.\n                TotalEvents++;                                      // Count it.\n                MakeRoomAllEvents();                                // Make room for another.\n\n                thisEvent = &AllEvents[TotalEvents];\n                snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"pci_max_packet_size:device=%i\", device);\n                strcpy(thisEvent->desc, \"Maximum PCIe packet size.\");\n                thisEvent->reader = &er_pci_throughput_max_packet;\n                thisEvent->writer = NULL;                           // Can't be written.\n                thisEvent->device=device;\n                thisEvent->baseIdx = BaseEvent;                     // NOT SELF, part of a group read.\n                thisEvent->vptrSize=0;                              // Nothing to read, uses BaseEvent memory.\n                thisEvent->vptr=NULL;                               // ..\n                thisEvent->variant=-1;                              // Not applicable.\n                thisEvent->subvariant=-1;                           // Not applicable.\n                TotalEvents++;                                      // Count it.\n                MakeRoomAllEvents();                                // Make room for another.\n            // -------------- END BASE EVENT -----------------\n            }\n        }\n\n        // -------------- BEGIN BASE EVENT -----------------\n        // Needs to be four events; count, current, mask (r/w).\n        //(rsmi_dev_power_profile_presets_get, (uint32_t dv_ind, uint32_t sensor, rsmi_power_profile_status_t *status);\n        scan = NULL;\n        scan = nextEvent(scan, device, \"rsmi_dev_power_profile_presets_get\");\n        if (scan != NULL) {\n            thisEvent = &AllEvents[TotalEvents];\n            snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"power_profile_presets:device=%i:count\", device);\n            strcpy(thisEvent->desc, \"Number of power profile presets available. See ROCM_SMI manual for details.\");\n            thisEvent->reader = &er_power_profile_presets_count;\n            thisEvent->writer = NULL;                           // Can't be written.\n            thisEvent->device=device;\n            thisEvent->baseIdx = TotalEvents;                   // Self.\n            thisEvent->vptrSize=sizeof(rsmi_power_profile_status_t);    // re-read for each call, may change.\n            thisEvent->vptr=calloc(1, thisEvent->vptrSize);     // Make space for read.\n            thisEvent->variant=-1;                              // Not applicable.\n            thisEvent->subvariant=scan->subvariant;             // used in routine, but may be -1.\n            BaseEvent = TotalEvents;                            // Begin base event.\n            TotalEvents++;                                      // Count it.\n            MakeRoomAllEvents();                                // Make room for another.\n\n            if (TotalEvents > BaseEvent) {                      // If the base did not succeed, do not add dependents.\n                thisEvent = &AllEvents[TotalEvents];\n                snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"power_profile_presets:device=%i:avail_profiles\", device);\n                strcpy(thisEvent->desc, \"Bit mask for allowable power profile presets. See ROCM_SMI manual for details.\");\n                thisEvent->reader = &er_power_profile_presets_avail_profiles;\n                thisEvent->writer = NULL;                           // Can't be written.\n                thisEvent->device=device;\n                thisEvent->baseIdx = BaseEvent;                     // NOT SELF, part of a group read.\n                thisEvent->vptrSize=0;                              // Nothing to read, uses BaseEvent memory.\n                thisEvent->vptr=NULL;                               // ..\n                thisEvent->variant=-1;                              // Not applicable.\n                thisEvent->subvariant=-1;                           // Not applicable.\n                TotalEvents++;                                      // Count it.\n                MakeRoomAllEvents();                                // Make room for another.\n\n                thisEvent = &AllEvents[TotalEvents];\n                snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"power_profile_presets:device=%i:current\", device);\n                strcpy(thisEvent->desc, \"Bit mask for current power profile preset. Read/Write. See ROCM_SMI manual for details.\");\n                thisEvent->reader = &er_power_profile_presets_current;\n                thisEvent->writer = NULL;  \n                thisEvent->device=device;\n                thisEvent->baseIdx = BaseEvent;                     // NOT SELF, part of a group read.\n                thisEvent->vptrSize=0;                              // Nothing to read, uses BaseEvent memory.\n                thisEvent->vptr=NULL;                               // ..\n                thisEvent->variant=-1;                              // Not applicable.\n                thisEvent->subvariant=-1;                           // Not applicable.\n                TotalEvents++;                                      // Count it.\n                MakeRoomAllEvents();                                // Make room for another.\n\n            // -------------- END BASE EVENT -----------------\n            }\n        }\n\n        // rsmi_dev_power_profile_set ( uint32_t dv_ind, uint32_t reserved, rsmi_power_profile_preset_masks_t profile_mask )\n        scan = NULL;\n        scan = nextEvent(scan, device, \"rsmi_dev_power_profile_set\");\n        if (scan != NULL) {\n            thisEvent = &AllEvents[TotalEvents];\n            snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"power_profile_set:device=%i\", device);\n            strcpy(thisEvent->desc, \"Write Only, sets the power profile to one of the available masks. See ROCM_SMI manual for details.\");\n            thisEvent->reader = NULL;\n            thisEvent->writer = &ew_power_profile_mask;         // Write only.\n            thisEvent->device=device;\n            thisEvent->baseIdx = TotalEvents;                   // Self.\n            thisEvent->vptrSize=0;\n            thisEvent->vptr=NULL;\n            thisEvent->variant=-1;                              // Not applicable.\n            thisEvent->subvariant=scan->subvariant;             // used in routine, but may be -1.\n            BaseEvent = TotalEvents;                            // Begin base event.\n            TotalEvents++;                                      // Count it.\n            MakeRoomAllEvents();                                // Make room for another.\n        }\n\n        //---------------------------------------------------------------------\n        // The following events require sensor IDs (in the subvariant).\n        //---------------------------------------------------------------------\n\n        //(rsmi_dev_fan_reset, (uint32_t dv_ind, uint32_t sensor_ind)); // Note NO VARIANTS.\n        scan = NULL;\n        while (1) {                                                 // No variants, just subvariants.\n            scan = nextEvent(scan, device, \"rsmi_dev_fan_reset\");   // Get the next, if any.\n            if (scan == NULL) break;                                // Exit if done.\n            thisEvent = &AllEvents[TotalEvents];\n            snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"fan_reset:device=%i:sensor=%i\", device, scan->subvariant);\n            strcpy(thisEvent->desc, \"Fan Reset. Write Only, data value is ignored.\");\n            thisEvent->reader = NULL;                           // can't be read!\n            thisEvent->writer = &ew_fan_reset;                  // Can be written.\n            thisEvent->device=device;\n            thisEvent->baseIdx = TotalEvents;                   // Self.\n            thisEvent->vptrSize=0;                              // We don't actually read/write a value.\n            thisEvent->vptr=NULL;                               // ...\n            thisEvent->variant=-1;                              // Not applicable (DUMMY)\n            thisEvent->subvariant=scan->subvariant;             // subvariant is sensor.\n            TotalEvents++;                                      // Count it.\n            MakeRoomAllEvents();                                // Make room for another.\n        }\n\n        //(rsmi_dev_fan_rpms_get, (uint32_t dv_ind, uint32_t sensor_ind, int64_t *speed));\n        scan = NULL;\n        while (1) {                                                 // No variants, just subvariants.\n            scan = nextEvent(scan, device, \"rsmi_dev_fan_rpms_get\");   // Get the next, if any.\n            if (scan == NULL) break;                                // Exit if done.\n            thisEvent = &AllEvents[TotalEvents];\n            snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"fan_rpms:device=%i:sensor=%i\", device, scan->subvariant);\n            strcpy(thisEvent->desc, \"Current Fan Speed in RPM (Rotations Per Minute).\");\n            thisEvent->reader = &er_fan_rpms;\n            thisEvent->writer = NULL;                           // can't be written.\n            thisEvent->device=device;\n            thisEvent->baseIdx = TotalEvents;                   // Self.\n            thisEvent->vptrSize=sizeof(uint64_t);               // Size of data to read.\n            thisEvent->vptr=calloc(1, thisEvent->vptrSize);     // Space to read it.\n            thisEvent->variant=-1;                              // Not applicable (DUMMY)\n            thisEvent->subvariant=scan->subvariant;             // subvariant is sensor.\n            TotalEvents++;                                      // Count it.\n            MakeRoomAllEvents();                                // Make room for another.\n        }\n\n        //(rsmi_dev_fan_speed_max_get, (uint32_t dv_ind, uint32_t sensor_ind, uint64_t *max_speed));\n        scan = NULL;\n        while (1) {                                                 // No variants, just subvariants.\n            scan = nextEvent(scan, device, \"rsmi_dev_fan_speed_max_get\");   // Get the next, if any.\n            if (scan == NULL) break;                                // Exit if done.\n            thisEvent = &AllEvents[TotalEvents];\n            snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"fan_speed_max:device=%i:sensor=%i\", device, scan->subvariant);\n            strcpy(thisEvent->desc, \"Maximum possible fan speed in RPM (Rotations Per Minute).\");\n            thisEvent->reader = &er_fan_speed_max;\n            thisEvent->writer = NULL;                           // can't be written.\n            thisEvent->device=device;\n            thisEvent->baseIdx = TotalEvents;                   // Self.\n            thisEvent->vptrSize=sizeof(uint64_t);               // Size of data to read.\n            thisEvent->vptr=calloc(1, thisEvent->vptrSize);     // Space to read it.\n            thisEvent->variant=-1;                              // Not applicable (DUMMY)\n            thisEvent->subvariant=scan->subvariant;             // subvariant is sensor.\n            TotalEvents++;                                      // Count it.\n            MakeRoomAllEvents();                                // Make room for another.\n        }\n\n        //(rsmi_dev_fan_speed_get, (uint32_t dv_ind, uint32_t sensor_ind, int64_t *speed));\n        //(rsmi_dev_fan_speed_set, (uint32_t dv_ind, uint32_t sensor_ind, uint64_t speed));\n        // We worry about the gets first and count the ones set. Then if search for \n        // the sets, and back-fill thisEvent->writer; for matching subvariants. We ignore\n        // any 'sets' without matching 'gets', but allow 'gets' without 'sets'. Note we also\n        // fix up the description.\n        scan = NULL;\n        subvariants=0;\n        while (1) {                                                 // No variants, just subvariants.\n            scan = nextEvent(scan, device, \"rsmi_dev_fan_speed_get\");   // Get the next, if any.\n            if (scan == NULL) break;                                // Exit if done.\n            subvariants++;                                          // count the number found.\n            thisEvent = &AllEvents[TotalEvents];\n            snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"fan_speed:device=%i:sensor=%i\", device, scan->subvariant);\n            strcpy(thisEvent->desc, \"Current Fan Speed in RPM (Rotations Per Minute), Read Only, result [0-255].\");\n            thisEvent->reader = &er_fan_speed;\n            thisEvent->writer = NULL;                           // Presume not written.\n            thisEvent->device=device;\n            thisEvent->baseIdx = TotalEvents;                   // Self.\n            thisEvent->vptrSize=sizeof(uint64_t);               // Size of data to read.\n            thisEvent->vptr=calloc(1, thisEvent->vptrSize);     // Space to read it.\n            thisEvent->variant=-1;                              // Not applicable (DUMMY)\n            thisEvent->subvariant=scan->subvariant;             // subvariant is sensor.\n            TotalEvents++;                                      // Count it.\n            MakeRoomAllEvents();                                // Make room for another.\n        }\n\n        // This must immediately follow rsmi_dev_fan_speed_get.        \n        // Deal with (rsmi_dev_fan_speed_set, (uint32_t dv_ind, uint32_t sensor_ind, uint64_t speed));\n        scan = NULL;\n        while (1) {                                                 // No variants, just subvariants.\n            scan = nextEvent(scan, device, \"rsmi_dev_fan_speed_set\");   // Get the next, if any.\n            if (scan == NULL) break;                                // Exit if done.\n            for (i=0; i<subvariants; i++) {\n                if (AllEvents[TotalEvents-1-i].subvariant == \n                    scan->subvariant) {                                 // If we found the matching read,\n                    AllEvents[TotalEvents-1-i].writer = &ew_fan_speed;  // Allow writing.\n                    strcpy(AllEvents[TotalEvents-1-i].desc, \"Current Fan Speed in RPM (Rotations Per Minute), Read/Write, Write must be <=MAX (see fan_speed_max event), arg int [0-255].\");\n                }\n            }\n        }\n\n        //(rsmi_dev_power_ave_get, (uint32_t dv_ind, uint32_t sensor_ind, uint64_t *power));\n        scan = NULL;\n        while (1) {                                                 // No variants, just subvariants.\n            scan = nextEvent(scan, device, \"rsmi_dev_power_ave_get\");   // Get the next, if any.\n            if (scan == NULL) break;                                // Exit if done.\n            thisEvent = &AllEvents[TotalEvents];\n            snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"power_average:device=%i:sensor=%i\", device, scan->subvariant);\n            strcpy(thisEvent->desc, \"Current Average Power consumption in microwatts. Requires root privilege.\");\n            thisEvent->reader = &er_power_ave;\n            thisEvent->writer = NULL;                           // can't be written.\n            thisEvent->device=device;\n            thisEvent->baseIdx = TotalEvents;                   // Self.\n            thisEvent->vptrSize=sizeof(uint64_t);               // Size of data to read.\n            thisEvent->vptr=calloc(1, thisEvent->vptrSize);     // Space to read it.\n            thisEvent->variant=-1;                              // Not applicable (DUMMY)\n            thisEvent->subvariant=scan->subvariant;             // subvariant is sensor.\n            TotalEvents++;                                      // Count it.\n            MakeRoomAllEvents();                                // Make room for another.\n        }\n\n        //(rsmi_dev_power_cap_get, (uint32_t dv_ind, uint32_t sensor_ind, uint64_t *cap));\n        //(rsmi_dev_power_cap_set, (uint32_t dv_ind, uint32_t sensor_ind, uint64_t cap));\n        // We worry about the gets first and count the ones set. Then if search for \n        // the sets, and back-fill thisEvent->writer; for matching subvariants. We ignore\n        // any 'sets' without matching 'gets', but allow 'gets' without 'sets'. Note we also\n        // fix up the description.\n        scan = NULL;\n        subvariants=0;\n        while (1) {                                                 // No variants, just subvariants.\n            scan = nextEvent(scan, device, \"rsmi_dev_power_cap_get\");   // Get the next, if any.\n            if (scan == NULL) break;                                // Exit if done.\n            subvariants++;                                          // count the number found.\n            thisEvent = &AllEvents[TotalEvents];\n            snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"power_cap:device=%i:sensor=%i\", device, scan->subvariant);\n            strcpy(thisEvent->desc, \"Power cap in microwatts. Read Only. Between min/max (see power_cap_range_min/max). May require root privilege.\");\n            thisEvent->reader = &er_power_cap;\n            thisEvent->writer = NULL;                           // Presume read only.\n            thisEvent->device=device;\n            thisEvent->baseIdx = TotalEvents;                   // Self.\n            thisEvent->vptrSize=sizeof(uint64_t);               // Size of data to read.\n            thisEvent->vptr=calloc(1, thisEvent->vptrSize);     // Space to read it.\n            thisEvent->variant=-1;                              // Not applicable (DUMMY)\n            thisEvent->subvariant=scan->subvariant;             // subvariant is sensor.\n            TotalEvents++;                                      // Count it.\n            MakeRoomAllEvents();                                // Make room for another.\n        }\n\n        // This must immediately follow rsmi_dev_power_cap_get.        \n        // Deal with (rsmi_dev_power_cap_set, (uint32_t dv_ind, uint32_t sensor_ind, uint64_t cap));\n        scan = NULL;\n        while (1) {                                                 // No variants, just subvariants.\n            scan = nextEvent(scan, device, \"rsmi_dev_power_cap_set\");   // Get the next, if any.\n            if (scan == NULL) break;                                // Exit if done.\n            for (i=0; i<subvariants; i++) {\n                if (AllEvents[TotalEvents-1-i].subvariant == \n                    scan->subvariant) {                                 // If we found the matching read,\n                    AllEvents[TotalEvents-1-i].writer = &ew_power_cap;  // Allow writing.\n                    strcpy(AllEvents[TotalEvents-1-i].desc, \"Power cap in microwatts. Read/Write. Between min/max (see power_cap_range_min/max). May require root privilege.\");\n                }\n            }\n        }\n\n\n        // -------------- BEGIN BASE EVENT -----------------\n        // Needs to be two events; max and min.\n        //(rsmi_dev_power_cap_range_get, (uint32_t dv_ind, uint32_t sensor_ind, uint64_t *max, uint64_t *min));\n        scan = NULL;\n        scan = nextEvent(scan, device, \"rsmi_dev_power_cap_range_get\");\n        if (scan != NULL) {\n            thisEvent = &AllEvents[TotalEvents];\n            snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"power_cap_range_min:device=%i:sensor=%i\", device, scan->subvariant);\n            strcpy(thisEvent->desc, \"Power cap Minimum settable value, in microwatts.\");\n            thisEvent->reader = &er_power_cap_range_min;\n            thisEvent->writer = NULL;                           // Can't be written.\n            thisEvent->device=device;\n            thisEvent->baseIdx = TotalEvents;                   // Self.\n            thisEvent->vptrSize=sizeof(uint64_t);               // Size of data to read.\n            thisEvent->vptr=calloc(2, thisEvent->vptrSize);     // Space to read both [min,max] (we reverse the order vs arguments in this array).\n            thisEvent->variant=-1;                              // Not applicable (DUMMY)\n            thisEvent->subvariant=scan->subvariant;             // subvariant is sensor.\n            BaseEvent = TotalEvents;                            // Remember this as the base event.\n            TotalEvents++;                                      // Count it.\n            MakeRoomAllEvents();                                // Make room for another.\n\n            if (TotalEvents > BaseEvent) {                      // If the base did not succeed, do not add the dependent.\n                thisEvent = &AllEvents[TotalEvents];\n                snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"power_cap_range_max:device=%i:sensor=%i\", device, scan->subvariant);\n                strcpy(thisEvent->desc, \"Power cap Maximum settable value, in microwatts.\");\n                thisEvent->reader = &er_power_cap_range_max;        // Will call previous, this routine just copies it.\n                thisEvent->writer = NULL;                           // Can't be written.\n                thisEvent->device=device;\n                thisEvent->baseIdx = BaseEvent;                     // NOT SELF, combined read with previous event(s).\n                thisEvent->vptrSize=0;                              // Shares data with base event.\n                thisEvent->vptr=NULL;                               // No space here.\n                thisEvent->variant=-1;                              // Not applicable (DUMMY)\n                thisEvent->subvariant=scan->subvariant;             // subvariant is sensor.\n                TotalEvents++;                                      // Count it.\n                MakeRoomAllEvents();                                // Make room for another.\n            // -------------- END BASE EVENT -----------------\n            }\n        }\n\n        // rsmi_temperature_metric_t is an enum with 14 settings; each will be a separate event.\n        //(rsmi_dev_temp_metric_get, (uint32_t dv_ind, uint32_t sensor_ind, rsmi_temperature_metric_t metric, int64_t *temperature));\n        // This involves both variants and subvariants. \n        // We will have a single loop with a switch to pick the variants,\n        // and the subvariants (being different) will take care of themselves.\n        // We sorted the list, it should be in order by variant:subvariant.\n        scan = NULL;\n        while (1) {                                                 // No variants, just subvariants.\n            scan = nextEvent(scan, device, \"rsmi_dev_temp_metric_get\");   // Get the next, if any.\n            if (scan == NULL) break;                                // Exit if done.\n\n            // Common elements.\n            int found=1;                                        // Presume variant will be found.\n            thisEvent = &AllEvents[TotalEvents];\n            thisEvent->writer = NULL;                           // can't be written.\n            thisEvent->reader = &er_temp;                       // read routine.     \n            thisEvent->device=device;\n            thisEvent->baseIdx = TotalEvents;                   // Self.\n            thisEvent->vptrSize=sizeof(int64_t);                // Size of data to read.\n            thisEvent->vptr=calloc(1, thisEvent->vptrSize);     // Space to read it.\n            thisEvent->variant=scan->variant;                   // Same as case we are in.\n            thisEvent->subvariant=scan->subvariant;             // subvariant is sensor.\n\n            switch(scan->variant) {         \n                case RSMI_TEMP_CURRENT:\n                    snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"temp_current:device=%i:sensor=%i\", device, scan->subvariant);\n                    strcpy(thisEvent->desc, \"Temperature current value, millidegrees Celsius.\");\n                    break;                                              // END CASE.\n\n                case RSMI_TEMP_MAX:\n                    snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"temp_max:device=%i:sensor=%i\", device, scan->subvariant);\n                    strcpy(thisEvent->desc, \"Temperature maximum value, millidegrees Celsius.\");\n                    break;                                              // END CASE.\n\n                case RSMI_TEMP_MIN:\n                    snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"temp_min:device=%i:sensor=%i\", device, scan->subvariant);\n                    strcpy(thisEvent->desc, \"Temperature minimum value, millidegrees Celsius.\");\n                    break;                                              // END CASE.\n\n                case RSMI_TEMP_MAX_HYST:\n                    snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"temp_max_hyst:device=%i:sensor=%i\", device, scan->subvariant);\n                    strcpy(thisEvent->desc, \"Temperature hysteresis value for max limit, millidegrees Celsius.\");\n                    break;                                              // END CASE.\n\n                case RSMI_TEMP_MIN_HYST:\n                    snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"temp_min_hyst:device=%i:sensor=%i\", device, scan->subvariant);\n                    strcpy(thisEvent->desc, \"Temperature hysteresis value for min limit, millidegrees Celsius.\");\n                    break;                                              // END CASE.\n\n                case RSMI_TEMP_CRITICAL:\n                    snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"temp_critical:device=%i:sensor=%i\", device, scan->subvariant);\n                    strcpy(thisEvent->desc, \"Temperature critical max value, typically > temp_max, millidegrees Celsius.\");\n                    break;                                              // END CASE.\n\n                case RSMI_TEMP_CRITICAL_HYST:\n                    snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"temp_critical_hyst:device=%i:sensor=%i\", device, scan->subvariant);\n                    strcpy(thisEvent->desc, \"Temperature hysteresis value for critical limit, millidegrees Celsius.\");\n                    break;                                              // END CASE.\n\n                case RSMI_TEMP_EMERGENCY:\n                    snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"temp_emergency:device=%i:sensor=%i\", device, scan->subvariant);\n                    strcpy(thisEvent->desc, \"Temperature emergency max for chips supporting more than two upper temp limits, millidegrees Celsius.\");\n                    break;                                              // END CASE.\n\n                case RSMI_TEMP_EMERGENCY_HYST:\n                    snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"temp_emergency_hyst:device=%i:sensor=%i\", device, scan->subvariant);\n                    strcpy(thisEvent->desc, \"Temperature hysteresis value for emergency limit, millidegrees Celsius.\");\n                    break;                                              // END CASE.\n\n                case RSMI_TEMP_CRIT_MIN:\n                    snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"temp_crit_min:device=%i:sensor=%i\", device, scan->subvariant);\n                    strcpy(thisEvent->desc, \"Temperature critical min value; typical < temp_min, millidegrees Celsius.\");\n                    break;                                              // END CASE.\n\n                case RSMI_TEMP_CRIT_MIN_HYST:\n                    snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"temp_crit_min_hyst:device=%i:sensor=%i\", device, scan->subvariant);\n                    strcpy(thisEvent->desc, \"Temperature hysteresis value for critical min limit, millidegrees Celsius.\");\n                    break;                                              // END CASE.\n\n                case RSMI_TEMP_OFFSET:\n                    snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"temp_offset:device=%i:sensor=%i\", device, scan->subvariant);\n                    strcpy(thisEvent->desc, \"Temperature offset added to temp reading by the chip, millidegrees Celsius.\");\n                    break;                                              // END CASE.\n\n                case RSMI_TEMP_LOWEST:\n                    snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"temp_lowest:device=%i:sensor=%i\", device, scan->subvariant);\n                    strcpy(thisEvent->desc, \"Temperature historical minimum, millidegrees Celsius.\");\n                    break;                                              // END CASE.\n\n                case RSMI_TEMP_HIGHEST:\n                    snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"temp_highest:device=%i:sensor=%i\", device, scan->subvariant);\n                    strcpy(thisEvent->desc, \"Temperature historical maximum, millidegrees Celsius.\");\n                    break;                                              // END CASE.\n\n                default:                                   // If we did not recognize it, kill stuff.\n                    thisEvent->device= 0;       \n                    thisEvent->reader = NULL;\n                    thisEvent->baseIdx = 0;\n                    thisEvent->vptrSize = 0;\n                    free(thisEvent->vptr);\n                    thisEvent->vptr = NULL;\n                    thisEvent->variant = 0;\n                    thisEvent->subvariant = 0;\n                    found = 0;                                  // indicate not found.\n                    break;\n            } // END switch on variant.\n\n            if (found) {\n                TotalEvents++;                                      // Count it.\n                MakeRoomAllEvents();                                // Make room for another.\n            }\n        } // END while for rsmi_dev_temp_metric_get.\n\n        // rsmi_dev_firmware_version_get is an enum with 21 settings; each will be a separate event.\n        //(rsmi_dev_temp_metric_get, (uint32_t dv_ind, uint32_t block_Id, uint64_t *version));\n        // This involves only variants.\n        // We will have a single loop with a switch to pick the variants.\n        // We sorted the list, it should be in order by variant.\n        scan = NULL;\n        while (1) {                                                 // No variants, just subvariants.\n            scan = nextEvent(scan, device, \"rsmi_dev_firmware_version_get\");   // Get the next, if any.\n            if (scan == NULL) break;                                // Exit if done.\n\n            // Common elements.\n            int found=1;                                        // Presume variant will be found.\n            thisEvent = &AllEvents[TotalEvents];\n            thisEvent->writer = NULL;                           // can't be written.\n            thisEvent->reader = &er_firmware_version;           // read routine.     \n            thisEvent->device=device;\n            thisEvent->baseIdx = TotalEvents;                   // Self.\n            thisEvent->vptrSize=sizeof(int64_t);                // Size of data to read.\n            thisEvent->vptr=calloc(1, thisEvent->vptrSize);     // Space to read it.\n            thisEvent->variant=scan->variant;                   // Same as case we are in.\n            thisEvent->subvariant=scan->subvariant;             // subvariant is sensor.\n\n            switch(scan->variant) {         \n                case RSMI_FW_BLOCK_ASD: \n                    snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"firmware_version:device=%i:block=ASD\", device);\n                    strcpy(thisEvent->desc, \"Firmware Version Block ASD.\");\n                    break;                                              // END CASE.\n\n                case RSMI_FW_BLOCK_CE: \n                    snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"firmware_version:device=%i:block=CE\", device);\n                    strcpy(thisEvent->desc, \"Firmware Version Block CE.\");\n                    break;                                              // END CASE.\n\n                case RSMI_FW_BLOCK_DMCU:\n                    snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"firmware_version:device=%i:block=DMCU\", device);\n                    strcpy(thisEvent->desc, \"Firmware Version Block DMCU.\");\n                    break;                                              // END CASE.\n\n                case RSMI_FW_BLOCK_MC: \n                    snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"firmware_version:device=%i:block=MC\", device);\n                    strcpy(thisEvent->desc, \"Firmware Version Block MC.\");\n                    break;                                              // END CASE.\n\n                case RSMI_FW_BLOCK_ME: \n                    snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"firmware_version:device=%i:block=ME\", device);\n                    strcpy(thisEvent->desc, \"Firmware Version Block ME.\");\n                    break;                                              // END CASE.\n\n                case RSMI_FW_BLOCK_MEC: \n                    snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"firmware_version:device=%i:block=MEC\", device);\n                    strcpy(thisEvent->desc, \"Firmware Version Block MEC.\");\n                    break;                                              // END CASE.\n\n                case RSMI_FW_BLOCK_MEC2:\n                    snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"firmware_version:device=%i:block=MEC2\", device);\n                    strcpy(thisEvent->desc, \"Firmware Version Block MEC2.\");\n                    break;                                              // END CASE.\n\n                case RSMI_FW_BLOCK_PFP: \n                    snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"firmware_version:device=%i:block=PFP\", device);\n                    strcpy(thisEvent->desc, \"Firmware Version Block PFP.\");\n                    break;                                              // END CASE.\n\n                case RSMI_FW_BLOCK_RLC: \n                    snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"firmware_version:device=%i:block=RLC\", device);\n                    strcpy(thisEvent->desc, \"Firmware Version Block RLC.\");\n                    break;                                              // END CASE.\n\n                case RSMI_FW_BLOCK_RLC_SRLC: \n                    snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"firmware_version:device=%i:block=SRLC\", device);\n                    strcpy(thisEvent->desc, \"Firmware Version Block SRLC.\");\n                    break;                                              // END CASE.\n\n                case RSMI_FW_BLOCK_RLC_SRLG:\n                    snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"firmware_version:device=%i:block=SRLG\", device);\n                    strcpy(thisEvent->desc, \"Firmware Version Block SRLG.\");\n                    break;                                              // END CASE.\n\n                case RSMI_FW_BLOCK_RLC_SRLS: \n                    snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"firmware_version:device=%i:block=SRLS\", device);\n                    strcpy(thisEvent->desc, \"Firmware Version Block SRLS.\");\n                    break;                                              // END CASE.\n\n                case RSMI_FW_BLOCK_SDMA: \n                    snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"firmware_version:device=%i:block=SDMA\", device);\n                    strcpy(thisEvent->desc, \"Firmware Version Block SDMA.\");\n                    break;                                              // END CASE.\n\n                case RSMI_FW_BLOCK_SDMA2: \n                    snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"firmware_version:device=%i:block=SDMA2\", device);\n                    strcpy(thisEvent->desc, \"Firmware Version Block SDMA2.\");\n                    break;                                              // END CASE.\n\n                case RSMI_FW_BLOCK_SMC:\n                    snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"firmware_version:device=%i:block=SMC\", device);\n                    strcpy(thisEvent->desc, \"Firmware Version Block SMC.\");\n                    break;                                              // END CASE.\n\n                case RSMI_FW_BLOCK_SOS: \n                    snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"firmware_version:device=%i:block=SOS\", device);\n                    strcpy(thisEvent->desc, \"Firmware Version Block SOS.\");\n                    break;                                              // END CASE.\n\n                case RSMI_FW_BLOCK_TA_RAS: \n                    snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"firmware_version:device=%i:block=RAS\", device);\n                    strcpy(thisEvent->desc, \"Firmware Version Block RAS.\");\n                    break;                                              // END CASE.\n\n                case RSMI_FW_BLOCK_TA_XGMI: \n                    snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"firmware_version:device=%i:block=XGMI\", device);\n                    strcpy(thisEvent->desc, \"Firmware Version Block XGMI.\");\n                    break;                                              // END CASE.\n\n                case RSMI_FW_BLOCK_UVD:\n                    snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"firmware_version:device=%i:block=UVD\", device);\n                    strcpy(thisEvent->desc, \"Firmware Version Block UVD.\");\n                    break;                                              // END CASE.\n\n                case RSMI_FW_BLOCK_VCE: \n                    snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"firmware_version:device=%i:block=VCE\", device);\n                    strcpy(thisEvent->desc, \"Firmware Version Block VCE.\");\n                    break;                                              // END CASE.\n\n                case RSMI_FW_BLOCK_VCN:\n                    snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"firmware_version:device=%i:block=VCN\", device);\n                    strcpy(thisEvent->desc, \"Firmware Version Block VCN.\");\n                    break;                                              // END CASE.\n\n                default:                                   // If we did not recognize it, kill stuff.\n                    thisEvent->device= 0;       \n                    thisEvent->reader = NULL;\n                    thisEvent->baseIdx = 0;\n                    thisEvent->vptrSize = 0;\n                    free(thisEvent->vptr);\n                    thisEvent->vptr = NULL;\n                    thisEvent->variant = 0;\n                    thisEvent->subvariant = 0;\n                    found = 0;                                  // indicate not found.\n                    break;\n            } // end switch\n\n            if (found) {\n                TotalEvents++;                                      // Count it.\n                MakeRoomAllEvents();                                // Make room for another.\n            }\n        } // end while.\n\n        // rsmi_dev_ecc_count_get uses an enum with 14 settings; then each is a base event for\n        // correctable and uncorrectable errors.\n        // We will have a single loop with a switch to pick the variants.\n        // We sorted the list, it should be in order by variant.\n        scan = NULL;\n        while (1) {                                                 // No variants, just subvariants.\n            scan = nextEvent(scan, device, \"rsmi_dev_ecc_count_get\");   // Get the next, if any.\n            if (scan == NULL) break;                                // Exit if done.\n\n            // Common elements.\n            int found=1;                                        // Presume variant will be found.\n            char blockName[16] = \"\";                            // Block name found.\n            thisEvent = &AllEvents[TotalEvents];\n            thisEvent->writer = NULL;                           // can't be written.\n            thisEvent->reader = &er_ecc_count_correctable;      // read routine.     \n            thisEvent->device=device;\n            thisEvent->baseIdx = TotalEvents;                   // Self.\n            thisEvent->vptrSize=sizeof(rsmi_error_count_t);     // Size of data to read.\n            thisEvent->vptr=calloc(1, thisEvent->vptrSize);     // Space to read it.\n            thisEvent->variant=scan->variant;                   // Same as case we are in.\n            thisEvent->subvariant=scan->subvariant;             // subvariant is gpu block type (bit mask).\n            BaseEvent = TotalEvents;                            // Make the first a base event.\n\n            switch(scan->variant) {         \n                case RSMI_GPU_BLOCK_UMC:\n                    strncpy(blockName, \"UMC\", 15);\n                    break;\n\n                case RSMI_GPU_BLOCK_SDMA:\n                    strncpy(blockName, \"SDMA\", 15);\n                    break;\n\n                case RSMI_GPU_BLOCK_GFX:\n                    strncpy(blockName, \"GFX\", 15);\n                    break;\n\n                case RSMI_GPU_BLOCK_MMHUB:\n                    strncpy(blockName, \"MMUB\", 15);\n                    break;\n\n                case RSMI_GPU_BLOCK_ATHUB:\n                    strncpy(blockName, \"ATHUB\", 15);\n                    break;\n\n                case RSMI_GPU_BLOCK_PCIE_BIF:\n                    strncpy(blockName, \"PCIE_BIF\", 15);\n                    break;\n\n                case RSMI_GPU_BLOCK_HDP:\n                    strncpy(blockName, \"HDP\", 15);\n                    break;\n\n                case RSMI_GPU_BLOCK_XGMI_WAFL:\n                    strncpy(blockName, \"XGMI_WAFL\", 15);\n                    break;\n\n                case RSMI_GPU_BLOCK_DF:\n                    strncpy(blockName, \"DF\", 15);\n                    break;\n\n                case RSMI_GPU_BLOCK_SMN:\n                    strncpy(blockName, \"SMN\", 15);\n                    break;\n\n                case RSMI_GPU_BLOCK_SEM:\n                    strncpy(blockName, \"SEM\", 15);\n                    break;\n\n                case RSMI_GPU_BLOCK_MP0:\n                    strncpy(blockName, \"MP0\", 15);\n                    break;\n\n                case RSMI_GPU_BLOCK_MP1:\n                    strncpy(blockName, \"MP1\", 15);\n                    break;\n\n                case RSMI_GPU_BLOCK_FUSE:\n                    strncpy(blockName, \"FUSE\", 15);\n                    break;\n\n\n                default:                                   // If we did not recognize it, kill stuff.\n                    thisEvent->device= 0;       \n                    thisEvent->reader = NULL;\n                    thisEvent->baseIdx = 0;\n                    thisEvent->vptrSize = 0;\n                    free(thisEvent->vptr);\n                    thisEvent->vptr = NULL;\n                    thisEvent->variant = 0;\n                    thisEvent->subvariant = 0;\n                    found = 0;                                  // indicate not found.\n                    break;\n            } // end switch\n\n            if (found) {\n                snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"ecc_count_correctable:device=%i:block=%s\", device, blockName);\n                snprintf(thisEvent->desc, PAPI_MAX_STR_LEN-1, \"Correctable error count for the GPU Block %s.\", blockName);\n                TotalEvents++;                                      // Count it.\n                MakeRoomAllEvents();                                // Make room for another.\n                thisEvent = &AllEvents[TotalEvents];\n                snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"ecc_count_uncorrectable:device=%i:block=%s\", device, blockName);\n                snprintf(thisEvent->desc, PAPI_MAX_STR_LEN-1, \"Uncorrectable error count for the GPU Block %s.\", blockName);\n                thisEvent->reader = &er_ecc_count_uncorrectable;    // Will call previous, this routine just copies it.\n                thisEvent->writer = NULL;                           // Can't be written.\n                thisEvent->device=device;\n                thisEvent->baseIdx = BaseEvent;                     // NOT SELF, combined read with previous event(s).\n                thisEvent->vptrSize=0;                              // Shares data with base event.\n                thisEvent->vptr=NULL;                               // No space here.\n                thisEvent->variant=-1;                              // Not applicable (DUMMY)\n                thisEvent->subvariant=scan->subvariant;             // subvariant is sensor.\n                TotalEvents++;                                      // Count it.\n                MakeRoomAllEvents();                                // Make room for another.\n            }\n        } // end while.\n\n        //(rsmi_dev_ecc_enabled_get, (uint32_t dv_ind, uint64_t *enabled_blocks));\n        scan = NULL;\n        scan = nextEvent(scan, device, \"rsmi_dev_ecc_enabled_get\");\n        if (scan != NULL) {\n            thisEvent = &AllEvents[TotalEvents];\n            snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"ecc_enabled_get:device=%i\", device);\n            strcpy(thisEvent->desc, \"Bit mask of gpu blocks with ecc error counting enabled.\");\n            thisEvent->reader = &er_ecc_enabled;\n            thisEvent->writer = NULL;                           // Can't be written.\n            thisEvent->device=device;\n            thisEvent->baseIdx = TotalEvents;                   // Self.\n            thisEvent->vptrSize=sizeof(uint64_t);               // Memory for read.\n            thisEvent->vptr=calloc(1, thisEvent->vptrSize);\n            thisEvent->variant=-1;                              // Not applicable.\n            thisEvent->subvariant=-1;                           // Not applicable.\n            TotalEvents++;                                      // Count it.\n            MakeRoomAllEvents();                                // Make room for another.\n        }\n\n        // rsmi_dev_ecc_status_get uses an enum with 14 settings; each will be a separate event.\n        // (rsmi_dev_ecc_status_get(uint32_t dv_ind, rsmi_gpu_block_t block, rsmi_ras_err_state_t \u2217 state)\n        // We will have a single loop with a switch to pick the variants.\n        // We sorted the list, it should be in order by variant.\n        scan = NULL;\n        while (1) {                                                 // No variants, just subvariants.\n            scan = nextEvent(scan, device, \"rsmi_dev_ecc_status_get\");   // Get the next, if any.\n            if (scan == NULL) break;                                // Exit if done.\n\n            // Common elements.\n            int found=1;                                        // Presume variant will be found.\n            thisEvent = &AllEvents[TotalEvents];\n            thisEvent->writer = NULL;                           // can't be written.\n            thisEvent->reader = &er_ecc_status;                 // read routine.     \n            thisEvent->device=device;\n            thisEvent->baseIdx = TotalEvents;                   // Self.\n            thisEvent->vptrSize=sizeof(rsmi_ras_err_state_t);   // Size of data to read.\n            thisEvent->vptr=calloc(1, thisEvent->vptrSize);     // Space to read it.\n            thisEvent->variant=scan->variant;                   // Same as case we are in.\n            thisEvent->subvariant=scan->subvariant;             // subvariant is gpu block type (bit mask).\n\n            switch(scan->variant) {         \n                case RSMI_GPU_BLOCK_UMC:\n                    snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"ecc_status:device=%i:block=UMC\", device);\n                    strcpy(thisEvent->desc, \"ECC Error Status for the GPU Block UMC.\");\n                    break;                                              // END CASE.\n\n                case RSMI_GPU_BLOCK_SDMA:\n                    snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"ecc_status:device=%i:block=SDMA\", device);\n                    strcpy(thisEvent->desc, \"ECC Error Status for the GPU Block SDMA.\");\n                    break;                                              // END CASE.\n\n                case RSMI_GPU_BLOCK_GFX:\n                    snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"ecc_status:device=%i:block=GFX\", device);\n                    strcpy(thisEvent->desc, \"ECC Error Status for the GPU Block GFX.\");\n                    break;                                              // END CASE.\n\n                case RSMI_GPU_BLOCK_MMHUB:\n                    snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"ecc_status:device=%i:block=MMHUB\", device);\n                    strcpy(thisEvent->desc, \"ECC Error Status for the GPU Block MMHUB.\");\n                    break;                                              // END CASE.\n\n                case RSMI_GPU_BLOCK_ATHUB:\n                    snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"ecc_status:device=%i:block=ATHUB\", device);\n                    strcpy(thisEvent->desc, \"ECC Error Status for the GPU Block ATHUB.\");\n                    break;                                              // END CASE.\n\n                case RSMI_GPU_BLOCK_PCIE_BIF:\n                    snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"ecc_status:device=%i:block=PCIE_BIF\", device);\n                    strcpy(thisEvent->desc, \"ECC Error Status for the GPU Block PCIE_BIF.\");\n                    break;                                              // END CASE.\n\n                case RSMI_GPU_BLOCK_HDP:\n                    snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"ecc_status:device=%i:block=HDP\", device);\n                    strcpy(thisEvent->desc, \"ECC Error Status for the GPU Block HDP.\");\n                    break;                                              // END CASE.\n\n                case RSMI_GPU_BLOCK_XGMI_WAFL:\n                    snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"ecc_status:device=%i:block=XGMI_WAFL\", device);\n                    strcpy(thisEvent->desc, \"ECC Error Status for the GPU Block XGMI_WAFL.\");\n                    break;                                              // END CASE.\n\n                case RSMI_GPU_BLOCK_DF:\n                    snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"ecc_status:device=%i:block=DF\", device);\n                    strcpy(thisEvent->desc, \"ECC Error Status for the GPU Block DF.\");\n                    break;                                              // END CASE.\n\n                case RSMI_GPU_BLOCK_SMN:\n                    snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"ecc_status:device=%i:block=SMN\", device);\n                    strcpy(thisEvent->desc, \"ECC Error Status for the GPU Block SMN.\");\n                    break;                                              // END CASE.\n\n                case RSMI_GPU_BLOCK_SEM:\n                    snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"ecc_status:device=%i:block=SEM\", device);\n                    strcpy(thisEvent->desc, \"ECC Error Status for the GPU Block SEM.\");\n                    break;                                              // END CASE.\n\n                case RSMI_GPU_BLOCK_MP0:\n                    snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"ecc_status:device=%i:block=MP0\", device);\n                    strcpy(thisEvent->desc, \"ECC Error Status for the GPU Block MP0.\");\n                    break;                                              // END CASE.\n\n                case RSMI_GPU_BLOCK_MP1:\n                    snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"ecc_status:device=%i:block=MP1\", device);\n                    strcpy(thisEvent->desc, \"ECC Error Status for the GPU Block MP1.\");\n                    break;                                              // END CASE.\n\n                case RSMI_GPU_BLOCK_FUSE:\n                    snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"ecc_status:device=%i:block=FUSE\", device);\n                    strcpy(thisEvent->desc, \"ECC Error Status for the GPU Block FUSE.\");\n                    break;                                              // END CASE.\n\n\n                default:                                   // If we did not recognize it, kill stuff.\n                    thisEvent->device= 0;       \n                    thisEvent->reader = NULL;\n                    thisEvent->baseIdx = 0;\n                    thisEvent->vptrSize = 0;\n                    free(thisEvent->vptr);\n                    thisEvent->vptr = NULL;\n                    thisEvent->variant = 0;\n                    thisEvent->subvariant = 0;\n                    found = 0;                                  // indicate not found.\n                    break;\n            } // end switch\n\n            if (found) {\n                TotalEvents++;                                      // Count it.\n                MakeRoomAllEvents();                                // Make room for another.\n            }\n        } // end while.\n\n        // rsmi_dev_gpu_clk_freq_get, has five variants.\n        // rsmi_dev_gpu_clk_freq_get(device, rsmi_clk_type_t type, *rsmi_frequencies_t frequencies):\n        // We will have a single loop with a switch to pick the variants.\n        // Note each one of these may turn into several events.\n        scan = NULL;\n        while (1) {                                                 // No variants, just subvariants.\n            scan = nextEvent(scan, device, \"rsmi_dev_gpu_clk_freq_get\");   // Get the next, if any.\n            if (scan == NULL) break;                                // Exit if done.\n            if (scan->variant < 0 || scan->variant>=freqTablePerDevice) continue;   // skip if variant illegal.\n            int idx = device*freqTablePerDevice+scan->variant;                      // Index into frequency table.\n            \n            // The Count of frequencies for this variant.\n            thisEvent = &AllEvents[TotalEvents];\n            snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"gpu_clk_freq_%s:device=%i:count\", gpuClkVariantName[scan->variant], device);\n            strcpy(thisEvent->desc, \"Number of frequencies available.\");\n            thisEvent->reader = NULL;                           // No reader is needed. \n            thisEvent->writer = NULL;                           // Can't be written.\n            thisEvent->device=device;\n            thisEvent->baseIdx = TotalEvents;                   // Self.\n            thisEvent->vptrSize=0;                              // Not needed, tables are read.\n            thisEvent->vptr=NULL;                               // Not needed. \n            thisEvent->value=FreqTable[idx].num_supported;      // Value it will always be.  \n            thisEvent->variant=scan->variant;                   // The type of frequency.\n            thisEvent->subvariant=-1;                           // subvariant doesn't matter.\n            BaseEvent = TotalEvents;                            // Remember this as the base event.\n            TotalEvents++;                                      // Count it.\n            MakeRoomAllEvents();                                // Make room for another.\n\n            // The Current frequency for this variant.\n            thisEvent = &AllEvents[TotalEvents];\n            snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"gpu_clk_freq_%s:device=%i:current\", gpuClkVariantName[scan->variant], device);\n            strcpy(thisEvent->desc, \"Current operating frequency.\");\n            thisEvent->reader = &er_gpu_clk_freq_current;\n            thisEvent->writer = NULL;                           // Can't be written.\n            thisEvent->device=device;\n            thisEvent->baseIdx = TotalEvents;                   // Self.\n            thisEvent->vptrSize=0;                              // Not needed, tables are read.\n            thisEvent->vptr=NULL;                               // Not needed. \n            thisEvent->value=0;                                 // Read at time of event.  \n            thisEvent->variant=scan->variant;                   // The type of frequency.\n            thisEvent->subvariant=-1;                           // subvariant doesn't matter.\n            BaseEvent = TotalEvents;                            // Remember this as the base event.\n            TotalEvents++;                                      // Count it.\n            MakeRoomAllEvents();                                // Make room for another.\n\n            // An event per frequency.\n            for (ui=0; ui<FreqTable[idx].num_supported; ui++) { // For each frequency supported,\n                thisEvent = &AllEvents[TotalEvents];\n                snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"gpu_clk_freq_%s:device=%i:idx=%u\", gpuClkVariantName[scan->variant], device, ui);\n                snprintf(thisEvent->desc, PAPI_MAX_STR_LEN-1, \"Returns %s frequency value from supported_table[%u].\", gpuClkVariantName[scan->variant], ui);\n                thisEvent->reader = &er_gpu_clk_freq_table;\n                thisEvent->writer = NULL;                           // Can't be written.\n                thisEvent->device=device;\n                thisEvent->baseIdx = TotalEvents;                   // Self.\n                thisEvent->vptrSize=0;                              // Not needed, tables are read.\n                thisEvent->vptr=NULL;                               // Not needed. \n                thisEvent->value=0;                                 // Read at time of event.  \n                thisEvent->variant=scan->variant;                   // The type of frequency.\n                thisEvent->subvariant=ui;                           // subvariant stores the index value.\n                BaseEvent = TotalEvents;                            // Remember this as the base event.\n                TotalEvents++;                                      // Count it.\n                MakeRoomAllEvents();                                // Make room for another.\n            } \n\n        } // end while.\n\n        // rsmi_dev_gpu_clk_freq_set, has five variants.\n        // rsmi_dev_gpu_clk_freq_set(device, rsmi_clk_type_t type, uint64_t bitmask):\n        // We will have a single loop with a switch to pick the variants.\n        scan = NULL;\n        while (1) {                                                 // No variants, just subvariants.\n            scan = nextEvent(scan, device, \"rsmi_dev_gpu_clk_freq_set\");   // Get the next, if any.\n            if (scan == NULL) break;                                // Exit if done.\n            if (scan->variant < 0 || scan->variant>=freqTablePerDevice) continue;   // skip if variant illegal.\n            int idx = device*freqTablePerDevice+scan->variant;                      // Index into frequency table.\n            \n            // The Count of frequencies for this variant.\n            thisEvent = &AllEvents[TotalEvents];\n            snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"gpu_clk_freq_%s:device=%i:mask\", gpuClkVariantName[scan->variant], device);\n            snprintf(thisEvent->desc, PAPI_MAX_STR_LEN-1, \"Write Only. Sets bitmask, 1's for %s frequency values in support table permitted. All 0 mask prohibited.\", gpuClkVariantName[scan->variant]);\n            thisEvent->reader = NULL;                           // No reader is needed. \n            thisEvent->writer = &ew_gpu_clk_freq_mask;          // Write the mask.\n            thisEvent->device=device;\n            thisEvent->baseIdx = TotalEvents;                   // Self.\n            thisEvent->vptrSize=0;                              // Not needed, tables are read.\n            thisEvent->vptr=NULL;                               // Not needed. \n            thisEvent->value=FreqTable[idx].num_supported;      // Value it will always be.  \n            thisEvent->variant=scan->variant;                   // The type of frequency.\n            thisEvent->subvariant=-1;                           // subvariant doesn't matter.\n            BaseEvent = TotalEvents;                            // Remember this as the base event.\n            TotalEvents++;                                      // Count it.\n            MakeRoomAllEvents();                                // Make room for another.\n        } // END while variants.\n\n        // rsmi_dev_pci_bandwidth_get, has no variants.\n        // rsmi_dev_pci_bandwidth_get ( uint32_t dv_ind, rsmi_pcie_bandwidth_t \u2217 bandwidth )\n        // The rsmi_pcie_bandwidth_t is smi_frequencies_t transfer_rate + Lanes[] array):\n        // We will have a single loop with a switch to pick the variants.\n        // Note this turns into many events.\n        scan = NULL;\n        scan = nextEvent(scan, device, \"rsmi_dev_pci_bandwidth_get\");   // Get the next, if any.\n        if (scan != NULL) {\n            \n            // The Count of frequencies for this variant.\n            thisEvent = &AllEvents[TotalEvents];\n            snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"pci_bandwidth_rate:device=%i:count\", device);\n            strcpy(thisEvent->desc, \"Number of PCI transfer rates available.\");\n            thisEvent->reader = NULL;                           // No reader is needed. \n            thisEvent->writer = NULL;                           // Can't be written.\n            thisEvent->device=device;\n            thisEvent->baseIdx = TotalEvents;                   // Self.\n            thisEvent->vptrSize=0;                              // Not needed, tables are read.\n            thisEvent->vptr=NULL;                               // Not needed. \n            thisEvent->value=PCITable[device].transfer_rate.num_supported; // Value it will always be.  \n            thisEvent->variant=-1;                              // Not used.\n            thisEvent->subvariant=-1;                           // Not used.\n            BaseEvent = TotalEvents;                            // Remember this as the base event.\n            TotalEvents++;                                      // Count it.\n            MakeRoomAllEvents();                                // Make room for another.\n\n            // The Current frequency for this variant.\n            thisEvent = &AllEvents[TotalEvents];\n            snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"pci_bandwidth_rate:device=%i:current\", device);\n            strcpy(thisEvent->desc, \"Current PCI transfer rate.\");\n            thisEvent->reader = &er_pci_bandwidth_rate_current;\n            thisEvent->writer = NULL;                           // Can't be written.\n            thisEvent->device=device;\n            thisEvent->baseIdx = TotalEvents;                   // Self.\n            thisEvent->vptrSize=0;                              // Not needed, tables are read.\n            thisEvent->vptr=NULL;                               // Not needed. \n            thisEvent->value=0;                                 // Read at time of event.  \n            thisEvent->variant=-1;                              // Not used.\n            thisEvent->subvariant=-1;                           // Not used.\n            BaseEvent = TotalEvents;                            // Remember this as the base event.\n            TotalEvents++;                                      // Count it.\n            MakeRoomAllEvents();                                // Make room for another.\n\n            // Two events per rate, the rate, and the lanes.\n            for (ui=0; ui<FreqTable[device].num_supported; ui++) { // For each frequency supported on this device,\n                thisEvent = &AllEvents[TotalEvents];\n                snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"pci_bandwidth_rate:device=%i:rate_idx=%u\", device, ui);\n                snprintf(thisEvent->desc, PAPI_MAX_STR_LEN-1, \"Returns PCI bandwidth rate value from supported_table[%u].\", ui);\n                thisEvent->reader = &er_pci_bandwidth_rate_table;\n                thisEvent->writer = NULL;                           // Can't be written.\n                thisEvent->device=device;\n                thisEvent->baseIdx = TotalEvents;                   // Self.\n                thisEvent->vptrSize=0;                              // Not needed, tables are read.\n                thisEvent->vptr=NULL;                               // Not needed. \n                thisEvent->value=0;                                 // Read at time of event.  \n                thisEvent->variant=-1;                              // Not used.\n                thisEvent->subvariant=ui;                           // subvariant stores the index value.\n                BaseEvent = TotalEvents;                            // Remember this as the base event.\n                TotalEvents++;                                      // Count it.\n                MakeRoomAllEvents();                                // Make room for another.\n\n                thisEvent = &AllEvents[TotalEvents];\n                snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"pci_bandwidth_rate:device=%i:lane_idx=%u\", device, ui);\n                snprintf(thisEvent->desc, PAPI_MAX_STR_LEN-1, \"Returns PCI bandwidth rate corresponding lane count from supported_table[%u].\", ui);\n                thisEvent->reader = &er_pci_bandwidth_lane_table;\n                thisEvent->writer = NULL;                           // Can't be written.\n                thisEvent->device=device;\n                thisEvent->baseIdx = TotalEvents;                   // Self.\n                thisEvent->vptrSize=0;                              // Not needed, tables are read.\n                thisEvent->vptr=NULL;                               // Not needed. \n                thisEvent->value=0;                                 // Read at time of event.  \n                thisEvent->variant=-1;                              // Not used.\n                thisEvent->subvariant=ui;                           // subvariant stores the index value.\n                BaseEvent = TotalEvents;                            // Remember this as the base event.\n                TotalEvents++;                                      // Count it.\n                MakeRoomAllEvents();                                // Make room for another.\n            } \n        } // end if we had pci_bandwidth.\n\n        // rsmi_dev_pci_bandwidth_set, has no variants.\n        // rsmi_dev_pci_bandwidth_set ( uint32_t dv_ind, uint64_t bitmask )\n        scan = NULL;\n        scan = nextEvent(scan, device, \"rsmi_dev_pci_bandwidth_set\");   // Get the next, if any.\n        if (scan != NULL) {\n            \n            // The Count of frequencies for this variant.\n            thisEvent = &AllEvents[TotalEvents];\n            snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"pci_bandwidth_rate:device=%i:count\", device);\n            strcpy(thisEvent->desc, \"Number of PCI transfer rates available.\");\n            snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"pci_bandwidth_rate:device=%i:mask\", device);\n            snprintf(thisEvent->desc, PAPI_MAX_STR_LEN-1, \"Write Only. Sets bitmask, 1's for pci transfer rates in support table permitted. All 0 mask prohibited.\");\n            thisEvent->reader = NULL;                           // No reader is needed. \n            thisEvent->writer = &ew_pci_bandwidth_mask;         // Write Only.\n            thisEvent->device=device;\n            thisEvent->baseIdx = TotalEvents;                   // Self.\n            thisEvent->vptrSize=0;                              // Not needed, tables are read.\n            thisEvent->vptr=NULL;                               // Not needed. \n            thisEvent->value=-1;                                // Value to write.\n            thisEvent->variant=-1;                              // Not used.\n            thisEvent->subvariant=-1;                           // Not used.\n            BaseEvent = TotalEvents;                            // Remember this as the base event.\n            TotalEvents++;                                      // Count it.\n            MakeRoomAllEvents();                                // Make room for another.\n        } // end write pci bandwidth mask.\n\n    //-------------------------------------------------------------------------\n    // The following are string routines, returning a character pointer.\n    //-------------------------------------------------------------------------        \n        scan = NULL;\n        scan = nextEvent(scan, device, \"rsmi_dev_brand_get\");\n        if (scan != NULL) {\n            thisEvent = &AllEvents[TotalEvents];\n            snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"device_brand:device=%i\", device);\n            strcpy(thisEvent->desc, \"Returns char* to  z-terminated brand string; do not free().\");\n            thisEvent->reader = &er_brand;\n            thisEvent->writer = NULL;                           // Can't be written.\n            thisEvent->device=device;\n            thisEvent->baseIdx = TotalEvents;                   // Self.\n            thisEvent->vptrSize=(PAPI_MAX_STR_LEN);             // Memory for read.\n            thisEvent->vptr=calloc(thisEvent->vptrSize, sizeof(char));  \n            thisEvent->variant=-1;                              // Not applicable.\n            thisEvent->subvariant=-1;                           // Not applicable.\n            TotalEvents++;                                      // Count it.\n            MakeRoomAllEvents();                                // Make room for another.\n        }\n\n        scan = NULL;\n        scan = nextEvent(scan, device, \"rsmi_dev_name_get\");\n        if (scan != NULL) {\n            thisEvent = &AllEvents[TotalEvents];\n            snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"device_name:device=%i\", device);\n            strcpy(thisEvent->desc, \"Returns char* to  z-terminated name string; do not free().\");\n            thisEvent->reader = &er_name;\n            thisEvent->writer = NULL;                           // Can't be written.\n            thisEvent->device=device;\n            thisEvent->baseIdx = TotalEvents;                   // Self.\n            thisEvent->vptrSize=(PAPI_MAX_STR_LEN);             // Memory for read.\n            thisEvent->vptr=calloc(thisEvent->vptrSize, sizeof(char));  \n            thisEvent->variant=-1;                              // Not applicable.\n            thisEvent->subvariant=-1;                           // Not applicable.\n            TotalEvents++;                                      // Count it.\n            MakeRoomAllEvents();                                // Make room for another.\n        }\n\n        scan = NULL;\n        scan = nextEvent(scan, device, \"rsmi_dev_serial_number_get\");\n        if (scan != NULL) {\n            thisEvent = &AllEvents[TotalEvents];\n            snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"device_serial_number:device=%i\", device);\n            strcpy(thisEvent->desc, \"Returns char* to  z-terminated serial number string; do not free().\");\n            thisEvent->reader = &er_serial_number;\n            thisEvent->writer = NULL;                           // Can't be written.\n            thisEvent->device=device;\n            thisEvent->baseIdx = TotalEvents;                   // Self.\n            thisEvent->vptrSize=(PAPI_MAX_STR_LEN);             // Memory for read.\n            thisEvent->vptr=calloc(thisEvent->vptrSize, sizeof(char));  \n            thisEvent->variant=-1;                              // Not applicable.\n            thisEvent->subvariant=-1;                           // Not applicable.\n            TotalEvents++;                                      // Count it.\n            MakeRoomAllEvents();                                // Make room for another.\n        }\n\n        scan = NULL;\n        scan = nextEvent(scan, device, \"rsmi_dev_subsystem_name_get\");\n        if (scan != NULL) {\n            thisEvent = &AllEvents[TotalEvents];\n            snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"device_subsystem_name:device=%i\", device);\n            strcpy(thisEvent->desc, \"Returns char* to  z-terminated subsystem name string; do not free().\");\n            thisEvent->reader = &er_subsystem_name;\n            thisEvent->writer = NULL;                           // Can't be written.\n            thisEvent->device=device;\n            thisEvent->baseIdx = TotalEvents;                   // Self.\n            thisEvent->vptrSize=(PAPI_MAX_STR_LEN);             // Memory for read.\n            thisEvent->vptr=calloc(thisEvent->vptrSize, sizeof(char));  \n            thisEvent->variant=-1;                              // Not applicable.\n            thisEvent->subvariant=-1;                           // Not applicable.\n            TotalEvents++;                                      // Count it.\n            MakeRoomAllEvents();                                // Make room for another.\n        }\n\n        scan = NULL;\n        scan = nextEvent(scan, device, \"rsmi_dev_vbios_version_get\");\n        if (scan != NULL) {\n            thisEvent = &AllEvents[TotalEvents];\n            snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"vbios_version:device=%i\", device);\n            strcpy(thisEvent->desc, \"Returns char* to  z-terminated vbios version string; do not free().\");\n            thisEvent->reader = &er_vbios_version;\n            thisEvent->writer = NULL;                           // Can't be written.\n            thisEvent->device=device;\n            thisEvent->baseIdx = TotalEvents;                   // Self.\n            thisEvent->vptrSize=(PAPI_MAX_STR_LEN);             // Memory for read.\n            thisEvent->vptr=calloc(thisEvent->vptrSize, sizeof(char));  \n            thisEvent->variant=-1;                              // Not applicable.\n            thisEvent->subvariant=-1;                           // Not applicable.\n            TotalEvents++;                                      // Count it.\n            MakeRoomAllEvents();                                // Make room for another.\n        }\n\n        scan = NULL;\n        scan = nextEvent(scan, device, \"rsmi_dev_vendor_name_get\");\n        if (scan != NULL) {\n            thisEvent = &AllEvents[TotalEvents];\n            snprintf(thisEvent->name, PAPI_MAX_STR_LEN-1, \"vendor_name:device=%i\", device);\n            strcpy(thisEvent->desc, \"Returns char* to  z-terminated vendor name string; do not free().\");\n            thisEvent->reader = &er_vendor_name;\n            thisEvent->writer = NULL;                           // Can't be written.\n            thisEvent->device=device;\n            thisEvent->baseIdx = TotalEvents;                   // Self.\n            thisEvent->vptrSize=(PAPI_MAX_STR_LEN);             // Memory for read.\n            thisEvent->vptr=calloc(thisEvent->vptrSize, sizeof(char));  \n            thisEvent->variant=-1;                              // Not applicable.\n            thisEvent->subvariant=-1;                           // Not applicable.\n            TotalEvents++;                                      // Count it.\n            MakeRoomAllEvents();                                // Make room for another.\n        }\n    } // end for each device.\n\n    // Build arrays for current indices and values.\n    CurrentIdx = calloc(TotalEvents, sizeof(int));\n    CurrentValue = calloc(TotalEvents, sizeof(long long));\n\n    /* return 0 if everything went OK */\n    return 0;\n} // END ROUTINE _rocm_smi_add_native_events.\n\n\n/*****************************************************************************\n *******************  BEGIN PAPI's COMPONENT REQUIRED FUNCTIONS  *************\n *****************************************************************************/\n\n/*\n * This is called whenever a thread is initialized.\n */\nstatic int _rocm_smi_init_thread(hwd_context_t * ctx)\n{\n    SUBDBG(\"Entering _rocm_smi_init_thread\\n\");\n\n    (void) ctx;\n    return PAPI_OK;\n} // END ROUTINE.\n\n\n// Link the library, set up event tables and function tables.  This routine is\n// called when the PAPI process is initialized (IE PAPI_library_init)\n\nstatic int _rocm_smi_init_component(int cidx)\n{\n    int i, ret;\n    (void) i;\n    uint32_t dev;\n    scanEvent_info_t* scan=NULL;                        // a scan event pointer.\n    SUBDBG(\"Entering _rocm_smi_init_component\\n\");\n\n    /* link in all the rocm libraries and resolve the symbols we need to use */\n    if(_rocm_smi_linkRocmLibraries() != PAPI_OK) {\n        SUBDBG(\"Dynamic link of ROCM libraries failed, component will be disabled.\\n\");\n        SUBDBG(\"See disable reason in papi_component_avail output for more details.\\n\");\n        return (PAPI_ENOSUPP);\n    }\n\n    RSMI(rsmi_init, (0),return(PAPI_ENOSUPP));\n\n    ret = _rocm_smi_find_devices();             // Find AMD devices. Must find at least 1.\n    if (ret != PAPI_OK) return(ret);            // check for failure.\n\n    // Before we can build the list of all potential events,\n    // we have to scan the events available to determine \n    // how many variants & sensors we need to process when\n    // we get to the build for each type of event. There is\n    // no other way to query this information.\n    // Note that some events (like the temperatures) have a\n    // fixed number of variants. \n\n    // Note that scanEvents will sort the events by device, name, variant, subvariant.\n    scanEvents();                               // Collect supportedEvents[].\n\n    // DEALING WITH rsmi_dev_gpu_clk_freq_get/set. \n    // There are five types of clock, and each has a set of frequencies we can retrieve.\n    // rsmi_dev_gpu_clk_freq_get(device, clock_type, *rsmi_frequencies_t frequencies):\n    // clock_types:\n    //   RSMI_CLK_TYPE_SYS  System clock.\n    //   RSMI_CLK_TYPE_DF   Data Fabric clock (for ASICs running on a separate clock)\n    //   RSMI_CLK_TYPE_DCEF Display Controller Engine clock.\n    //   RSMI_CLK_TYPE_SOC  SOC clock.\n    //   RSMI_CLK_TYPE_MEM  Memory clock.\n    // The rsmi_frequencies_t structure contains:\n    //   uint32_t num_supported                         // The count of valid entries in array.\n    //   uint32_t current                               // the INDICE of the current frequency.\n    //   uint64_t frequency [RSMI_MAX_NUM_FREQUENCIES]  // ==32 at this writing.\n    // In order to support these functions, we need to know up front the num_supported.\n    // So we read these structures here, if each type is scanned. Note if one is missing,\n    // the num_supported will remain zero, from the calloc below.\n    \n    FreqTable = calloc(TotalDevices*freqTablePerDevice, sizeof(rsmi_frequencies));\n    for (dev=0; dev<TotalDevices; dev++) {\n        scan = NULL;\n        while (1) {                                                     // variants, no subvariants.\n            scan = nextEvent(scan, dev, \"rsmi_dev_gpu_clk_freq_get\");   // Get the next, if any.\n            if (scan == NULL) break;                                    // Exit if done.\n            if (scan->variant<0 || scan->variant>=freqTablePerDevice)   // Out of range?\n                continue;                                               // Y. Skip if variant unrecognized.\n            int idx = dev*freqTablePerDevice+scan->variant;             // idx into FreqTable.\n            RSMI(rsmi_dev_gpu_clk_freq_get, (dev, scan->variant, &FreqTable[idx]),); \n        } \n    }\n\n    // Getting data needed to detail rsmi_dev_pci_bandwidth_get.\n    PCITable = calloc(TotalDevices, sizeof(rsmi_pcie_bandwidth_t));\n    for (dev=0; dev<TotalDevices; dev++) {\n        scan = NULL;\n        scan = nextEvent(scan, dev, \"rsmi_dev_pci_bandwidth_get\");\n        if (scan == NULL) continue;                                     // Skip if not avail on this device.\n        RSMI(rsmi_dev_pci_bandwidth_get, (dev, &PCITable[dev]),);\n    }\n\n    // Build the list of all possible native ROCM events.\n    // This routine will only add elements we have code to support,\n    // and only if they appear in the ScanEvents[] array. It will\n    // produce TotalEvents.\n\n    ret = _rocm_smi_add_native_events();\n    if (ret != 0) return (ret);                 // check for failure.\n\n    // This is for diagnostic/debug purposes, it shows which\n    // routines were enumerated as available, but we do not\n    // attempt to make an event to access.  There is a\n    // corresponding diagnostic in nextEvent() to show what\n    // we tried to incorporate but did not find.\n\n#ifdef  REPORT_DEVICE_FUNCTION_NOT_SUPPORTED_BY_THIS_SOFTWARE\n    for (i=0; i<TotalScanEvents; i++) {\n        if (ScanEvents[i].used == 0) \n            fprintf(stderr, \"Device function not supported by this software: '%s:dev=%i:var=%i:sv=%i'\\n\", \n                ScanEvents[i].funcname, ScanEvents[i].device, ScanEvents[i].variant, ScanEvents[i].subvariant);\n    }\n#endif\n \n    // Export info to PAPI.\n    _rocm_smi_vector.cmp_info.CmpIdx = cidx;\n    _rocm_smi_vector.cmp_info.num_native_events = TotalEvents;\n    _rocm_smi_vector.cmp_info.num_cntrs = TotalEvents;\n    _rocm_smi_vector.cmp_info.num_mpx_cntrs = TotalEvents;\n\n    return (PAPI_OK);\n} // END ROUTINE.\n\n\n// Setup a counter control state.\n// In general a control state holds the hardware info for an EventSet.\n\nstatic int _rocm_smi_init_control_state(hwd_control_state_t * ctrl)\n{\n    SUBDBG(\"Entering _rocm_smi_init_control_state\\n\");\n    (void) ctrl;                    // avoid 'unused' warning.\n    return PAPI_OK;\n} // END ROUTINE.\n\n\n// Triggered by eventset operations like add or remove.\n// Note: NativeInfo_t is defined in papi_internal.h\n// We parse the list of events given; find the corresponding\n// AllEvents[] entries, and set up flags.\nstatic int _rocm_smi_update_control_state(hwd_control_state_t * ctrl, NativeInfo_t * nativeInfo, int nativeCount, hwd_context_t * ctx)\n{\n    SUBDBG(\"Entering _rocm_smi_update_control_state with nativeCount %d\\n\", nativeCount);\n    (void) ctrl;\n    (void) ctx;\n    int i, idx;\n\n    if(nativeCount == 0) return (PAPI_OK);      // If no events provided, success!\n\n    for (i=0; i<TotalEvents; i++) {             // Clear the event list.\n        AllEvents[i].read=0;                    // Not read yet.\n    }\n\n\n    for (i=0; i<nativeCount; i++) {             // For each user event provided;\n        idx = nativeInfo[i].ni_event;           // Get the event index,\n        CurrentIdx[i] = idx;                    // Remember events, in order, for reporting later.\n        nativeInfo[i].ni_position = i;          // Which event it was.\n    }\n\n    ActiveEvents=nativeCount;                   // Remember how many we have.\n    return (PAPI_OK);\n} // END ROUTINE.\n\n\n// Triggered by PAPI_start().\nstatic int _rocm_smi_start(hwd_context_t * ctx, hwd_control_state_t * ctrl)\n{\n    int i;\n    SUBDBG(\"Entering _rocm_smi_start\\n\");\n\n    (void) ctx;\n    (void) ctrl;\n\n    SUBDBG(\"Reset all active event values\\n\");\n    // We don't have any cumulative events; if we did we should read zero values\n    // for them now.\n\n    for (i=0; i<TotalEvents; i++) {\n        CurrentValue[i]=0;\n    }\n\n    return (PAPI_OK);\n} // END ROUTINE.\n\n\n// Triggered by PAPI_read(). Call the read routine for each\n// event requested; and compose the response vector.\nstatic int _rocm_smi_read(hwd_context_t * ctx, hwd_control_state_t * ctrl, long long **values, int flags)\n{\n    SUBDBG(\"Entering _rocm_smi_read\\n\");\n\n    (void) ctx;\n    (void) ctrl;\n    (void) flags;\n    int i, idx, bidx;\n\n    if (ActiveEvents == 0) {\n        *values = NULL;\n        return(PAPI_OK);\n    }\n\n    // We need to do this first and separately because we don't\n    // know what order the user's list is in; so we cannot be\n    // reading the values (and changing the 'read' flags) as we\n    // go to get a complete reset, when base events are used.\n    for (i=0; i<ActiveEvents; i++) {\n        idx=CurrentIdx[i];                                      // Get index of event in AllEvents[].\n        AllEvents[idx].read=0;                                  // Event is unread.\n        bidx=AllEvents[idx].baseIdx;                            // Get its base event.\n        if (bidx != idx) {                                      // if it is different,\n            AllEvents[bidx].read=0;                             // .. Mark it as unread, too.\n        }\n    }\n\n    // Now we can just read them.\n    for (i=0; i<ActiveEvents; i++) {                            // Examine all our events.\n        idx = CurrentIdx[i];                                    // Get index.\n        if (AllEvents[idx].reader == NULL) continue;            // No reader provided, may be static value or write-only value.\n        bidx=AllEvents[idx].baseIdx;                            // ... for base event.\n        if (bidx != idx && AllEvents[bidx].read == 0) {         // If baseIdx is for some other event and it hasn't been read,\n            (AllEvents[bidx].reader)(bidx);                     // .. call the base reader to populate the whole array.\n        }\n\n        (AllEvents[idx].reader)(idx);                           // Always have to do this whether I had a base read or not.\n    }\n\n    // Now collect all the values, in user order.\n    for (i=0; i<ActiveEvents; i++) {\n        int idx = CurrentIdx[i];                            // get index of event.\n        CurrentValue[i] = AllEvents[idx].value;             // Collect the value we read.\n    }\n\n    *values = CurrentValue;                                 // Return address of list to caller.\n\n    return (PAPI_OK);\n} // END ROUTINE.\n\n\n// Triggered by PAPI_write(). Call the write routine for each\n// event specified, with the value given. .\nstatic int _rocm_smi_write(hwd_context_t * ctx, hwd_control_state_t * ctrl, long long *values)\n{\n    SUBDBG(\"Entering _rocm_smi_write\\n\");\n\n    (void) ctx;\n    (void) ctrl;\n    int i, ret;\n\n    if (ActiveEvents < 1) return(PAPI_OK);                      // nothing to do.\n    for (i=0; i<ActiveEvents; i++) {                            // Examine all our events.\n        int idx = CurrentIdx[i];                                // Get idx into AllEvents[].\n        if (AllEvents[idx].writer == NULL) continue;            // Skip if no write routine.\n        AllEvents[idx].value = (uint64_t) values[i];            // copy the value to write out.\n        ret = (AllEvents[idx].writer)(idx);                     // write the value.\n        if (ret != PAPI_OK) return(ret);                        // Exit early, had a write failure.\n    }\n\n    return(PAPI_OK);\n} // END ROUTINE.\n\n\n// Triggered by PAPI_stop().\nstatic int _rocm_smi_stop(hwd_context_t * ctx, hwd_control_state_t * ctrl)\n{\n    SUBDBG(\"Entering _rocm_smi_stop\\n\");\n\n    (void) ctx;\n    (void) ctrl;\n\n    // Don't need to do anything; can't stop the SMI counters.\n\n    return (PAPI_OK);\n} // END routine.\n\n// get rid of everything in the event set.\nstatic int _rocm_smi_cleanup_eventset(hwd_control_state_t * ctrl)\n{\n    SUBDBG(\"Entering _rocm_smi_cleanup_eventset\\n\");\n\n    (void) ctrl;\n    int i;\n\n    for (i=0; i<TotalEvents; i++) {         // Reset all events.\n        AllEvents[i].read=0;\n    }\n\n    ActiveEvents = 0;                       // No active events.\n    return (PAPI_OK);\n} // END routine.\n\n\n// Called at thread shutdown. Does nothing.\nstatic int _rocm_smi_shutdown_thread(hwd_context_t * ctx)\n{\n    SUBDBG(\"Entering _rocm_smi_shutdown_thread\\n\");\n\n    (void) ctx;\n    return (PAPI_OK);\n} // END routine.\n\n\n// Triggered by PAPI_shutdown() and frees memory.\nstatic int _rocm_smi_shutdown_component(void)\n{\n    int i;\n    SUBDBG(\"Entering _rocm_smi_shutdown_component\\n\");\n\n    // Free memories.\n    for (i=0; i<TotalEvents; i++) {\n        if (AllEvents[i].vptr != NULL) free(AllEvents[i].vptr); // Free event memory.\n    }\n\n    free(AllEvents);    AllEvents    = NULL;\n    free(CurrentIdx);   CurrentIdx   = NULL;\n    free(CurrentValue); CurrentValue = NULL;\n    free(ScanEvents);   ScanEvents   = NULL;\n    free(FreqTable);    FreqTable    = NULL;\n    free(PCITable);     PCITable     = NULL;\n\n    // close the dynamic libraries needed by this component.\n    dlclose(dl1);\n    return (PAPI_OK);\n} // END routine.\n\n\n// Triggered by PAPI_reset() but only if the EventSet is currently\n// running. If the eventset is not currently running, then the saved\n// value in the EventSet is set to zero without calling this  routine.\nstatic int _rocm_smi_reset(hwd_context_t * ctx, hwd_control_state_t * ctrl)\n{\n    SUBDBG(\"Entering _rocm_smi_reset\\n\");\n\n    (void) ctx;\n    (void) ctrl;\n\n    return (PAPI_OK);\n} // END routine.\n\n\n//  This function sets various options in the component.\n//  @param[in] ctx -- hardware context\n//  @param[in] code valid are PAPI_SET_DEFDOM, PAPI_SET_DOMAIN,\n//  PAPI_SETDEFGRN, PAPI_SET_GRANUL and PAPI_SET_INHERIT\n//  @param[in] option -- options to be set\nstatic int _rocm_smi_ctrl(hwd_context_t * ctx, int code, _papi_int_option_t * option)\n{\n    SUBDBG(\"Entering _rocm_smi_ctrl\\n\");\n\n    (void) ctx;\n    (void) code;\n    (void) option;\n    return (PAPI_OK);\n} // END routine.\n\n\n// This function has to set the bits needed to count different domains In\n// particular: PAPI_DOM_USER, PAPI_DOM_KERNEL PAPI_DOM_OTHER By default return\n// PAPI_EINVAL if none of those are specified and PAPI_OK with success\n// PAPI_DOM_USER is only user context is counted PAPI_DOM_KERNEL is only the\n// Kernel/OS context is counted PAPI_DOM_OTHER  is Exception/transient mode\n// (like user TLB misses) PAPI_DOM_ALL   is all of the domains\n\nstatic int _rocm_smi_set_domain(hwd_control_state_t * ctrl, int domain)\n{\n    SUBDBG(\"Entering _rocm_smi_set_domain\\n\");\n\n    (void) ctrl;\n    if((PAPI_DOM_USER & domain) || (PAPI_DOM_KERNEL & domain) ||\n       (PAPI_DOM_OTHER & domain) || (PAPI_DOM_ALL & domain)) {\n        return (PAPI_OK);\n    } else {\n        return (PAPI_EINVAL);\n    }\n\n    return (PAPI_OK);\n} // END routine.\n\n\n// Enumerate Native Events.\n// 'EventCode' is the event of interest\n// 'modifier' is either PAPI_ENUM_FIRST or PAPI_ENUM_EVENTS\nstatic int _rocm_smi_ntv_enum_events(unsigned int *EventCode, int modifier)\n{\n    if (modifier == PAPI_ENUM_FIRST) {\n        *EventCode = 0;                         // Our first index.\n        return(PAPI_OK);                        // Exit.\n    }\n\n    if (modifier == PAPI_ENUM_EVENTS) {                             // Enumerating...\n        if (EventCode[0] < ((unsigned int) (TotalEvents-1))) {      // If +1 would still be valid,\n            EventCode[0]++;                                         // .. Go ahead to next event.\n            return(PAPI_OK);                                        // .. And exit.\n        }\n\n        return(PAPI_ENOEVNT);                                       // .. Otherwise, next is not a valid event.\n    }\n\n    return(PAPI_EINVAL);                                            // invalid argument, modifier not known.\n} // END ROUTINE.\n\n\n// Takes a native event code and passes back the name.\nstatic int _rocm_smi_ntv_code_to_name(unsigned int EventCode, char *name, int len)\n{\n    if (EventCode >= ((unsigned int) TotalEvents)) return(PAPI_ENOEVNT);    // Bad event code.\n    if (name == NULL || len < 2) return(PAPI_EINVAL);                       // Invalid arguments.\n\n    strncpy(name, AllEvents[EventCode].name, len);\n    return (PAPI_OK);\n} // END ROUTINE.\n\n\n// Takes a native event code and passes back the event description\nstatic int _rocm_smi_ntv_code_to_descr(unsigned int EventCode, char *desc, int len)\n{\n    if (EventCode >=((unsigned int) TotalEvents)) return(PAPI_EINVAL);\n    if (desc == NULL || len < 2) return(PAPI_EINVAL);\n\n    strncpy(desc, AllEvents[EventCode].desc, len);\n    return (PAPI_OK);\n} // END ROUTINE.\n\n\n// Vector that points to entry points for the component\npapi_vector_t _rocm_smi_vector = {\n    .cmp_info = {\n                 // default component information (unspecified values are initialized to 0),\n                 // see _rocm_smi_init_component for additional settings.\n                 .name = \"rocm_smi\",\n                 .short_name = \"rocm_smi\",\n                 .version = \"1.0\",\n                 .description = \"AMD GPU System Management Interface via rocm_smi_lib\",\n                 .default_domain = PAPI_DOM_USER,\n                 .default_granularity = PAPI_GRN_THR,\n                 .available_granularities = PAPI_GRN_THR,\n                 .hardware_intr_sig = PAPI_INT_SIGNAL,\n                 // component specific cmp_info initializations\n                 .fast_real_timer = 0,\n                 .fast_virtual_timer = 0,\n                 .attach = 0,\n                 .attach_must_ptrace = 0,\n                 .available_domains = PAPI_DOM_USER | PAPI_DOM_KERNEL,\n                 }\n    ,\n    // sizes of framework-opaque component-private structures...\n    // these are all unused in this component.\n    .size = {\n             .context = 1,              // sizeof( _rocm_smi_context_t )\n             .control_state = 1,        // sizeof( _rocm_smi_control_t )\n             .reg_value = 1,            // sizeof( _rocm_smi_register_t )\n             .reg_alloc = 1,            // sizeof( _rocm_smi_reg_alloc_t )\n             }\n    ,\n    // function pointers in this component\n    .start = _rocm_smi_start,           // ( hwd_context_t * ctx, hwd_control_state_t * ctrl )\n    .stop  = _rocm_smi_stop,            // ( hwd_context_t * ctx, hwd_control_state_t * ctrl )\n    .read  = _rocm_smi_read,            // ( hwd_context_t * ctx, hwd_control_state_t * ctrl, long_long ** events, int flags )\n    .write = _rocm_smi_write,           // ( hwd_context_t * ctx, hwd_control_state_t * ctrl, long_long ** events )\n    .reset = _rocm_smi_reset,           // ( hwd_context_t * ctx, hwd_control_state_t * ctrl )\n    .cleanup_eventset = _rocm_smi_cleanup_eventset, // ( hwd_control_state_t * ctrl )\n\n    .init_component = _rocm_smi_init_component,     // ( int cidx )\n    .init_thread = _rocm_smi_init_thread,           // ( hwd_context_t * ctx )\n    .init_control_state = _rocm_smi_init_control_state,     // ( hwd_control_state_t * ctrl )\n    .update_control_state = _rocm_smi_update_control_state, // ( hwd_control_state_t * ptr, NativeInfo_t * native, int count, hwd_context_t * ctx )\n\n    .ctl = _rocm_smi_ctrl,                                  // ( hwd_context_t * ctx, int code, _papi_int_option_t * option )\n    .set_domain = _rocm_smi_set_domain,                     // ( hwd_control_state_t * cntrl, int domain )\n    .ntv_enum_events = _rocm_smi_ntv_enum_events,           // ( unsigned int *EventCode, int modifier )\n    .ntv_code_to_name = _rocm_smi_ntv_code_to_name,         // ( unsigned int EventCode, char *name, int len )\n    .ntv_code_to_descr = _rocm_smi_ntv_code_to_descr,       // ( unsigned int EventCode, char *name, int len )\n    .shutdown_thread = _rocm_smi_shutdown_thread,           // ( hwd_context_t * ctx )\n    .shutdown_component = _rocm_smi_shutdown_component,     // ( void )\n};\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-papi-6.0.0.1-gmm3tef6bggycxgzrtmq2ejaggc2ozfb/spack-src/src/components/pcp/linux-pcp.c": "//-----------------------------------------------------------------------------\n//-----------------------------------------------------------------------------\n// This file contains the functions needed to interface PAPI with PCP, the \n// Performance Co-Pilot package. A manual for pmXXX commands is online at \n// https://pcp.io/man/\n// Performance: As tested on the ICL Saturn system, round-trip communications \n// with the PCP Daemon cost us 8-10ms, so every pm___ call is a stall. We have\n// to create our event list when initialized, but we can do that with some \n// 'batch' reads to minimize overhead. \n//-----------------------------------------------------------------------------\n//-----------------------------------------------------------------------------\n// #define DEBUG /* To enable SUBDBG messages */\n// see also _papi_hwi_debug = DEBUG_SUBSTRATE; below, to enable xxxDBG macros.\n\n#include <unistd.h>\n#include <errno.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <ctype.h>\n#include <math.h>\n#include <sys/time.h>\n\n// Headers required by PAPI.\n#include \"papi.h\"\n#include \"papi_internal.h\"\n#include \"papi_vector.h\"\n#include \"papi_memory.h\"\n#include \"papi_debug.h\" // for FUNC macro in error messages, keep even if we have no xxxDBG messages.\n#include <dlfcn.h>      // Dynamic lib routines; especially dlsym to get func ptrs.\n\n#ifndef FUNC            /* Not defined if not DEBUG... */\n#define  FUNC __func__  /* force it. */ \n#endif \n\n// Event Name filters, used in init_component for the routine pmTraversePMNS(). Differs by system.\n//#define AGENT_NAME \"xfs\"          /* Saturn PCP. */\n//#define AGENT_NAME \"mem\"          /* Saturn PCP. */\n  #define AGENT_NAME \"perfevent\"    /* Power9 PCP. */\n//#define AGENT_NAME \"\"             /* Get it all! */\n\n/* To remove redefined warnings */\n#undef PACKAGE_BUGREPORT\n#undef PACKAGE_TARNAME\n#undef PACKAGE_NAME\n#undef PACKAGE_STRING\n#undef PACKAGE_VERSION\n\n// PCP include directory (defaults to /usr/include/pcp; see README for PAPI_PCP_INC.)\n#include <pmapi.h> // See https://pcp.io/man/man3/pmapi.3.html for routines.\n#include <impl.h>  // also a PCP file.  \n\n#define   PM_OPTFLAG_EXIT     (1<<5)\n#define   PM_CONTEXT_UNDEF    -1\n#define   PM_CONTEXT_HOST     1\n#define   PM_CONTEXT_ARCHIVE  2\n#define   PM_CONTEXT_LOCAL    3\n\n//-----------------------------------------------------------------------------\n// Union to convert pointers and avoid warnings. Plug in one, pull out the other.\n//-----------------------------------------------------------------------------\ntypedef union  \n{\n   void                 *vPtr;\n   int                  *iPtr;\n   unsigned int         *uiPtr;\n   long                 *lPtr;\n   long long            *llPtr;\n   unsigned long long   *ullPtr;\n   float                *fPtr;\n   double               *dPtr;\n   char                 *cPtr;\n} uPointer_t;\n\ntypedef union\n{\n   long long ll;\n   unsigned long long ull;\n   double    d;\n   void *vp;\n   unsigned char ch[8];\n} convert_64_t;\n\n//-----------------------------------------------------------------------------\n// Structure to store private information on each Event. \n//-----------------------------------------------------------------------------\ntypedef struct _pcp_register  \n{\n   unsigned int selector;                    // indexed from 1, index of counter slot, but 0 means none.\n} _pcp_register_t;\n\n\n//-----------------------------------------------------------------------------\n// WARNING: Do NOT expect pointers into the pcp_event_info[] array to remain\n// valid during processing; the list is realloc() to make room and this can\n// i_nvalidate the pointer. (Hard won knowledge). \n//-----------------------------------------------------------------------------\ntypedef struct _pcp_event_info               // an array of these is populated by our pcp create event routine.\n{\n   char      name[PAPI_MAX_STR_LEN];         // name (we never copy more than PAPI_MAX_STR_LEN-1, so always z-terminated).\n   pmID      pmid;                           // PCP's unique id (gets only base name).\n   pmDesc    desc;                           // Description (not text, just var type etc). desc.pmid = PM_ID_NULL if not read yet.\n   int       valfmt;                         // Value format from Fetch (PM_VAL_INSITU, PM_VAL_DPTR [dynamic], PM_VAL_SPTR [static]\n   int       valType;                        // Type of value (PM_TYPE_[32,U32,64,U64,FLOAT,DOUBLE,STRING).\n   char      domainDesc[PAPI_MAX_STR_LEN];   // Domain description if not null.\n   int       numVal;                         // number of values in array.\n   int       idx;                            // idx into vlist array.\n   unsigned long long zeroValue;             // Value that counts as zero.\n} _pcp_event_info_t;\n\n\n//-----------------------------------------------------------------------------\n// This structure is used when doing register allocation it possibly is not\n// necessary when there are no register constraints.\n//-----------------------------------------------------------------------------\ntypedef struct _pcp_reg_alloc  \n{\n   _pcp_register_t ra_bits;\n} _pcp_reg_alloc_t;\n\n\n//-----------------------------------------------------------------------------\n// Holds control flags. There's one of these per event-set. Use this to hold\n// data specific to the EventSet. We hold for each event the index into the\n// pcp_event_info[] array, and a corresponding value; they must grow in\n// lockstep; to be NULL together or [maxAllocated] together. We cannot create a\n// structure to make that automatic; we need to point to an array of long long\n// values alone after a read.\n//-----------------------------------------------------------------------------\n\ntypedef struct _pcp_control_state  \n{\n   int numEvents;                                  // The number of events we have.\n   int maxAllocated;                               // The most ever allocated.\n   int *pcpIndex;                                  // array of indices into pcp_event_info[].\n   unsigned long long *pcpValue;                   // corresponding value read.\n} _pcp_control_state_t;\n\n\n//-----------------------------------------------------------------------------\n// Holds per-thread information. We don't have any.\n//-----------------------------------------------------------------------------\ntypedef struct _pcp_context  \n{\n   int initDone;                                   // does nothing.\n} _pcp_context_t;\n\n//-----------------------------------------------------------------------------\n// Our hash table entry. We use a hash table to help lookup event names. Each\n// entry contains an index into the pcp_event_info table, and a chain pointer\n// to the next hash entry if the same hash results for several event names.\n// See the routines addNameHash(), freeNameHash(), findNameHash().  \n//-----------------------------------------------------------------------------\ntypedef struct _pcp_hash                           // hash table entry.'\n{\n   int idx;                                        // The entry that matches this hash.\n   void *next;                                     // next entry that matches this hash, or NULL.\n}_pcp_hash_t;\n\n//-----------------------------------------------------------------------------\n// We cache our domains to save costly reads from the daemon, using a table of\n// this structure per entry. The domain id is not a counter, but there haven't\n// been many of them, so we do a sequential search of the table.\n//-----------------------------------------------------------------------------\ntypedef struct \n{\n   pmInDom domainId;                               // The id.\n   int     numInstances;                           // size of the arrays below.\n   int     *instances;                             // the instances. cleanup must free(instances).\n   char    **names;                                // The names. cleanup (must free(names).\n} _pcp_domain_cache_t;\n\n\npapi_vector_t _pcp_vector;                         // What we expose to PAPI, routine ptrs and other values.\n\n\n// -------------------------- GLOBAL SECTION ---------------------------------\n\n       int  _papi_hwi_debug = DEBUG_SUBSTRATE;                          // Bit flags to enable xxxDBG; SUBDBG for Substrate. Overrides weak global in papi.c.\nstatic int  sEventInfoSize=0;                                           // total size of pcp_event_info.\nstatic int  sEventInfoBlock = ((8*1024) / sizeof(_pcp_event_info_t));   // add about 8K at a time.\nstatic      _pcp_event_info_t * pcp_event_info = NULL;                  // our array of created pcp events.\nstatic int  sEventCount = 0;                                            // count of events seen by pmTraversePMNS().\nstatic int  ctxHandle = -1;                                             // context handle. (-1 is invalid).\nstatic char *cachedGetInDom(pmInDom indom, int inst);                   // cache all reads of pcp_pmGetInDom, to save time.\n#define     HASH_SIZE 512                                               /* very roughly in the range of total events. full Saturn test, had ~ 11,000 events.*/\nstatic      _pcp_hash_t sNameHash[HASH_SIZE];                           // hash table into pcp_event_info by event name.\n\n#define COUNT_ROUTINES 1                                                /* Change to zero to stop counting. */\n#if (COUNT_ROUTINES == 1)\nenum {\nctr_pcp_init_thread,                               // counter 0\nctr_pcp_init_component,                            // counter 1\nctr_pcp_init_control_state,                        // counter 2\nctr_pcp_start,                                     // counter 3\nctr_pcp_stop,                                      // counter 4\nctr_pcp_read,                                      // counter 5\nctr_pcp_shutdown_thread,                           // counter 6\nctr_pcp_shutdown_component,                        // counter 7\nctr_pcp_ctl,                                       // counter 8\nctr_pcp_update_control_state,                      // counter 9\nctr_pcp_set_domain,                                // counter 10\nctr_pcp_reset,                                     // counter 11\nctr_pcp_ntv_enum_events,                           // counter 12\nctr_pcp_ntv_name_to_code,                          // counter 13\nctr_pcp_ntv_code_to_name,                          // counter 14\nctr_pcp_ntv_code_to_descr,                         // counter 15\nctr_pcp_ntv_code_to_info};                         // counter 16\n\nstatic int cnt[ctr_pcp_ntv_code_to_info+1] = {0};  // counters for the following macro.\n\n#define mRtnCnt(funcname) \\\n   if (COUNT_ROUTINES) {            /* Note if (0) optimized out completely even if -O0. */  \\\n      cnt[ctr##funcname]++;         /* Increment counter. */                                 \\\n      if (cnt[ctr##funcname] == 1)  /* If first time entering a new function, report it. */  \\\n         _prog_fprintf(stderr, \"Entered \" TOSTRING(funcname) \"\\n\");                          \\\n   }\n#else                                                                   /* If COUNT_ROUTINES != 1, */\n#define mRtnCnt(funcname)                                               /* .. make macro do nothing. */\n#endif /* if/else for COUNT_ROUTINES handled. */\n\n//--------------------------------------------------------------------\n// Timing of routines and blocks. Typical usage;\n// _time_gettimeofday(&t1, NULL);                  // starting point.\n// ... some code to execute ...\n// _time_gettimeofday(&t2, NULL);                  // finished timing.\n// _time_fprintf(stderr, \"routine took %li uS.\\n\", // report time.\n//                       (mConvertUsec(t2)-mConvertUsec(t1)));\n//--------------------------------------------------------------------\nstatic struct timeval t1, t2;                                           // used in timing routines to measure performance.\n#define mConvertUsec(timeval_) \\\n        (timeval_.tv_sec*1000000+timeval_.tv_usec)                      /* avoid typos. */\n\n#define _prog_fprintf if (0) fprintf                                    /* change to 1 to enable printing of progress debug messages.     */\n#define _time_fprintf if (0) fprintf                                    /* change to 1 to enable printing of performance timings.         */\n#define _time_gettimeofday if (0) gettimeofday                          /* change to 1 to enable gettimeofday for performance timings.    */\n\n\n// file handle used to access pcp library with dlopen\nstatic void *dl1 = NULL;\n\n// string macro defined within Rules.pcp\nstatic char pcp_main[]=PAPI_PCP_MAIN;\n\n//-----------------------------------------------------------------------------\n// Using weak symbols (global declared without a value, so it defers to any\n// other global declared in another file WITH a value) allows PAPI to be built\n// with the component, but PAPI can still be installed in a system without the\n// required library.\n//-----------------------------------------------------------------------------\n\nvoid (*_dl_non_dynamic_init)(void) __attribute__((weak));               // declare a weak dynamic-library init routine pointer.\n\n// ------------------------ LINK DYNAMIC LIBRARIES ---------------------------\n// Function pointers for the PCP lib; begin with pm (performance monitor).\n// Commented out functions are ones we do not use; so we don't waste space.\nstatic int     (*pmLookupName_ptr)     (int numpid, char **namelist,pmID *pmidlist);\nstatic char*   (*pmErrStr_ptr)         (int code);\nstatic int     (*pmTraversePMNS_ptr)   (const char *name, void(*func)(const char *));\nstatic void    (*pmFreeResult_ptr)     (pmResult *result);\nstatic int     (*pmNewContext_ptr)     (int type, const char *name);\nstatic int     (*pmDestroyContext_ptr) (int handle);\nstatic int     (*pmFetch_ptr)          (int numpid, pmID *pmidlist, pmResult **result);\nstatic int     (*pmLookupDesc_ptr)     (pmID pmid, pmDesc *desc);\nstatic int     (*pmGetInDom_ptr)       (pmInDom indom, int **instlist, char ***namelist);\nstatic int     (*pmLookupText_ptr)     (pmID pmid, int level, char **buffer);\nstatic char *  (*pmUnitsStr_r_ptr)     (const pmUnits *pu, char *buf, int buflen); \n\n// -------------------- LOCAL WRAPPERS FOR LIB FUNCTIONS ---------------------\nstatic int     pcp_pmLookupName (int numpid, char **namelist, pmID *pmidlist) \n                  { return ((*pmLookupName_ptr) (numpid, namelist, pmidlist)); }\n\nstatic char*   pcp_pmErrStr (int code) \n                  { return ((*pmErrStr_ptr) (code)); }\n\nstatic int     pcp_pmTraversePMNS (const char *name, void(*func)(const char *)) \n                  { return ((*pmTraversePMNS_ptr) (name, func)); }\n\nstatic void    pcp_pmFreeResult (pmResult *result) \n                  { return ((*pmFreeResult_ptr) (result)); }\n\nstatic int     pcp_pmNewContext (int type, const char *name) \n                  { return ((*pmNewContext_ptr) (type,name)); }\n\nstatic int     pcp_pmDestroyContext(int handle) \n                  { return ((*pmDestroyContext_ptr) (handle));}\n\nstatic int     pcp_pmFetch (int numpid, pmID *pmidlist, pmResult **result) \n                  { return ((*pmFetch_ptr) (numpid,pmidlist,result)); }\n\nstatic int     pcp_pmLookupDesc (pmID pmid, pmDesc *desc) \n                  { return ((*pmLookupDesc_ptr) (pmid,desc)); }\n\nstatic int     pcp_pmGetInDom (pmInDom indom, int **instlist, char ***namelist) \n                  { return ((*pmGetInDom_ptr) (indom,instlist,namelist)); }\n\nstatic int     pcp_pmLookupText(pmID pmid, int level, char **buffer) \n                  { return ((*pmLookupText_ptr) (pmid, level, buffer)); }\n\nstatic char*   pcp_pmUnitsStr_r (const pmUnits *pu, char *buf, int buflen) \n                  {return ((*pmUnitsStr_r_ptr) (pu, buf, buflen)); }\n\n\n//-----------------------------------------------------------------------------\n// stringHash: returns unsigned long value for hashed string.  See djb2, Dan\n// Bernstein, http://www.cse.yorku.ca/~oz/hash.html Empirically a fast well\n// distributed hash, not theoretically explained.  On a test system with 1857\n// events, this gets about a 65% density in a 2000 element table; 35% of slots\n// have dups; max dups was 4.\n//-----------------------------------------------------------------------------\n\nstatic unsigned int stringHash(char *str, unsigned int tableSize) \n{\n  unsigned long hash = 5381;                             // seed value.\n  int c;\n  while ((c = (*str++))) {                               // ends when c == 0.\n     hash = ((hash << 5) + hash) + c;                    // hash * 33 + c.\n  }\n\n  return (hash % tableSize);                             // compute index and exit.\n} // end function.\n\n\n//-----------------------------------------------------------------------------\n// addNameHash: Given a string, hash it, and add to sNameHash[]. \n//-----------------------------------------------------------------------------\n\nstatic unsigned int addNameHash(char *key, int idx) \n{\n   unsigned int slot = stringHash(key, HASH_SIZE);       // compute hash code.\n   if (sNameHash[slot].idx < 0) {                        // If not occupied,\n      sNameHash[slot].idx = idx;                         // ..Now it is.\n      return(slot);                                      // and we are done.\n   }\n\n   // slot was occupied (collision).\n   _pcp_hash_t *newGuy = calloc(1, sizeof(_pcp_hash_t));                // make a new entry.\n   newGuy->idx = sNameHash[slot].idx;                                   // copy the idx sitting in table.\n   newGuy->next = sNameHash[slot].next;                                 // copy the chain pointer.\n   sNameHash[slot].idx = idx;                                           // this one goes into table.\n   sNameHash[slot].next = (void*) newGuy;                               // and chains to that new guy.\n   return(slot);                                                        // and we are done.\n} // end routine.\n\n\n//-----------------------------------------------------------------------------\n// freeNameHash: delete any allocated for collisions.\n//-----------------------------------------------------------------------------\n\nstatic void freeNameHash(void) \n{\n   int i;\n   for (i=0; i<HASH_SIZE; i++) {                                         // loop through table.\n      void *next = sNameHash[i].next;                                    // Get any pointer.\n      while (next != NULL) {                                             // follow the chain.\n         void *tofree = next;                                            // remember what we have to free.\n         next = ((_pcp_hash_t*) next)->next;                             // follow the chain.\n         free(tofree);                                                   // free the one we are standing on.\n      } \n   }\n} // end routine.\n\n\n//-----------------------------------------------------------------------------\n// findNameHash: Returns the idx into pcp_event_info, or -1 if not found.\n// avg over 1857 lookups, Saturn [Intel XEON 2.0GHz) was 120ns per lookup.\n//-----------------------------------------------------------------------------\n\nstatic int findNameHash(char *key) \n{\n   int idx;\n   unsigned int slot = stringHash(key, HASH_SIZE);                      // compute hash code.\n   idx = sNameHash[slot].idx;                                           // get the index.\n   if (idx < 0) return(-1);                                             // No good slot for it.\n   if (strcmp(key, pcp_event_info[idx].name) == 0) {                    // If we found it straight away,\n      return(idx);                                                      // .. quick return.\n   }\n\n   _pcp_hash_t *next = (_pcp_hash_t*) sNameHash[slot].next;             // get the next guy.\n\n   while (next != NULL) {                                               // follow the chain.\n      idx = next->idx;                                                  // .. get the idx.\n      if (strcmp(key, pcp_event_info[idx].name) == 0) {                 // If we found a match,\n         return(idx);                                                   // .. return with answer.\n      }\n      \n      next = next->next;                                                // get the next guy in the link.\n   } // end chain follow for collisions.\n\n   return(-1);                                                          // did not find it.\n} // end routine.\n\n\n//-----------------------------------------------------------------------------\n// Get all needed function pointers from the Dynamic Link Library. \n//-----------------------------------------------------------------------------\n\n// Simplify routine below; relies on ptr names being same as func tags.\n#define STRINGIFY(x) #x \n#define TOSTRING(x) STRINGIFY(x)\n#define mGet_DL_FPtr(Name)                                                 \\\n   Name##_ptr = dlsym(dl1, TOSTRING(Name));                                \\\n   if (dlerror() != NULL) {  /* If we had an error, */                     \\\n      snprintf(_pcp_vector.cmp_info.disabled_reason, PAPI_MAX_STR_LEN,     \\\n         \"PCP library function %s not found in lib.\", TOSTRING(Name));     \\\n      return(PAPI_ENOSUPP);                                                \\\n   } /* end of macro. */\n\nstatic int _local_linkDynamicLibraries(void) \n{\n   if ( _dl_non_dynamic_init != NULL ) {  // If weak var present, statically linked insted of dynamic.\n       strncpy( _pcp_vector.cmp_info.disabled_reason, \"The pcp component REQUIRES dynamic linking capabilities.\", PAPI_MAX_STR_LEN-1);\n       return PAPI_ENOSUPP;               // EXIT not supported.\n   }\n\n   char path_name[1024];\n   char *pcp_root = getenv(\"PAPI_PCP_ROOT\"); \n   \n   dl1 = NULL;\n   // Step 1: Process override if given.   \n   if (strlen(pcp_main) > 0) {                                  // If override given, it has to work.\n      dl1 = dlopen(pcp_main, RTLD_NOW | RTLD_GLOBAL);           // Try to open that path.\n      if (dl1 == NULL) {\n         snprintf(_pcp_vector.cmp_info.disabled_reason, PAPI_MAX_STR_LEN, \"PAPI_PCP_MAIN override '%s' given in Rules.pcp not found.\", pcp_main);\n         return(PAPI_ENOSUPP);   // Override given but not found.\n      }\n   }\n\n   // Step 2: Try system paths, will work with Spack, LD_LIBRARY_PATH, default paths.\n   if (dl1 == NULL) {                                           // No override,\n      dl1 = dlopen(\"libpcp.so\", RTLD_NOW | RTLD_GLOBAL);        // Try system paths.\n   }\n\n   // Step 3: Try the explicit install default. \n   if (dl1 == NULL && pcp_root != NULL) {                          // if root given, try it.\n      snprintf(path_name, 1024, \"%s/lib64/libpcp.so\", pcp_root);   // PAPI Root check.\n      dl1 = dlopen(path_name, RTLD_NOW | RTLD_GLOBAL);             // Try to open that path.\n   }\n\n   // Check for failure.\n   if (dl1 == NULL) {\n      snprintf(_pcp_vector.cmp_info.disabled_reason, PAPI_MAX_STR_LEN, \"libpcp.so not found.\");\n      return(PAPI_ENOSUPP);\n   }\n\n   // We have dl1. \n\n//-----------------------------------------------------------------------------\n// Collect pointers for routines in shared library.  All below will abort this\n// routine with PAPI_ENOSUPP, if the routine is not found in the dynamic\n// library.\n//-----------------------------------------------------------------------------\n\n   mGet_DL_FPtr(pmLookupName);\n   mGet_DL_FPtr(pmErrStr);\n   mGet_DL_FPtr(pmTraversePMNS);\n   mGet_DL_FPtr(pmFreeResult);\n   mGet_DL_FPtr(pmNewContext);\n   mGet_DL_FPtr(pmDestroyContext);\n   mGet_DL_FPtr(pmFetch);\n   mGet_DL_FPtr(pmLookupDesc);\n   mGet_DL_FPtr(pmGetInDom);\n   mGet_DL_FPtr(pmLookupText);\n   mGet_DL_FPtr(pmUnitsStr_r);\n   return PAPI_OK;   // If we get here, all above succeeded. \n} // end routine.\n\n\n//-----------------------------------------------------------------------------\n// qsort comparison routine, for pcp_event_info.\n//-----------------------------------------------------------------------------\nstatic int qsPMID(const void *arg1, const void* arg2) \n{\n   _pcp_event_info_t *p1 = (_pcp_event_info_t*) arg1;\n   _pcp_event_info_t *p2 = (_pcp_event_info_t*) arg2;\n\n   if (p1->pmid < p2->pmid) return (-1);                                // 1 comes before 2.\n   if (p1->pmid > p2->pmid) return ( 1);                                // 1 comes after 2.\n   if (p1->idx  < p2->idx ) return (-1);                                // same pmid, try idx into vlist.\n   if (p1->idx  > p2->idx ) return ( 1);                                // 1 comes after 2. \n   return (strcmp(p1->name, p2->name));                                 // sort by name if same PMID and idx.\n} // end routine.\n\n\n//-----------------------------------------------------------------------------\n// cbPopulateNameOnly: This is a callback routine, called by pmTraversePMNS.  That\n// routine iterates through the PM name space and calls this routine once per\n// name. We increment sEventCount as we go, this will be the final count of valid\n// array entries. sEventInfoSize will be >= sEventCount.\n// WARNING: May realloc() pcp_event_info[], invalidating pointers into it.\n//-----------------------------------------------------------------------------\n\nstatic void cbPopulateNameOnly(const char *name) \n{\n   if (sEventCount >= sEventInfoSize) {                                 // If we must realloc, \n      sEventInfoSize += sEventInfoBlock;                                // .. Add another page.\n      pcp_event_info = realloc(pcp_event_info,                          // .. do realloc.\n                        sEventInfoSize*sizeof(_pcp_event_info_t));      // ..\n      memset(&pcp_event_info[sEventCount], 0,                           // .. clear to zeros.\n             sEventInfoBlock*sizeof(_pcp_event_info_t));                // .. \n   }\n\n   strncpy(pcp_event_info[sEventCount].name, name, PAPI_MAX_STR_LEN-1); // copy name.\n   sEventCount++;                                                       // increment our count of events.\n} // end routine.\n\n\n//-----------------------------------------------------------------------------\n// makeQualifiedEvent: Create a new event as a copy of the old, plus a tag at\n// the end.  This appends to the pcp_event_info[] array, which may be realloced\n// (which CAN invalidate any pointers into it).\n//-----------------------------------------------------------------------------\n\nstatic void makeQualifiedEvent(int baseEvent, int idx, char *qualifier) \n{\n   int prevSize;\n   if (sEventCount >= sEventInfoSize) {                                 // If we must realloc, \n      prevSize = sEventInfoSize;\n      sEventInfoSize += sEventInfoBlock;                                // .. Add another block.\n      pcp_event_info = realloc(pcp_event_info,                          // .. attempt reallocation.\n                       sEventInfoSize*sizeof(_pcp_event_info_t));       // .. ..\n      if (pcp_event_info == NULL) {                                     // If realloc failed, report it.\n         fprintf(stderr, \"%s:%i:%s realloc denied; \"\n                 \"pcp_event_info=%p at size=%i.\\n\",\n                 __FILE__, __LINE__, __func__, \n                pcp_event_info, sEventInfoSize);\n         exit(-1);\n      } // end if realloc failed.\n\n      memset(&pcp_event_info[prevSize], 0,                              // .. clear the new block to zeros..\n             sEventInfoBlock*sizeof(_pcp_event_info_t));                // .. \n   } // end if realloc needed.\n\n   pcp_event_info[sEventCount] = pcp_event_info[baseEvent];             // copy the structure.\n   pcp_event_info[sEventCount].numVal = 1;                              // Just one value.\n   pcp_event_info[sEventCount].idx = idx;                               // Set the right index.\n   pcp_event_info[sEventCount].zeroValue = 0;                           // Set the base value.  \n   int slen = strlen(pcp_event_info[sEventCount].name);                 // get length of user name.\n   char *c = qualifier;                                                 // point at qualifier.\n   pcp_event_info[sEventCount].name[slen++] = ':';                      // place a colon.\n\n   while ( (*c) != 0 && slen < PAPI_MAX_STR_LEN-1) {                    // .. appending qualifier,\n      char v=*c++;                                                      // .. what we intend to append, point at next.\n      // your chance to invalidate any chars, right here!\n      pcp_event_info[sEventCount].name[slen++] = v;                     // .. add to name, inc slen.\n   }\n   \n   pcp_event_info[sEventCount].name[slen] = 0;                          // ensure z-terminator. \n   sEventCount++;                                                       // increment our count of events.\n} // end routine.\n\n\n//-----------------------------------------------------------------------------\n// Helper; reads the description if it has not already been read for a given\n// index. Presumes pmid is already present.\n//-----------------------------------------------------------------------------\n\nstatic void getPMDesc(int pcpIdx) {                                     // Reads the variable descriptor.\n   int ret;\n   if (pcp_event_info[pcpIdx].pmid == PM_ID_NULL) return;               // Already have it.\n   ret = pcp_pmLookupDesc(pcp_event_info[pcpIdx].pmid,                  // Get the event descriptor.\n         &pcp_event_info[pcpIdx].desc);                                 // .. into the table; will set desc.pmid to not null.\n   if (ret == PM_ERR_PMID) {                                            // If we failed for PMID,\n      fprintf(stderr, \"%s:%i:%s Invalid PMID.\\n\",\n              __FILE__, __LINE__, __func__); \n      exit(-1);\n   } // end if realloc failed.\n      \n   if (ret == PM_ERR_NOAGENT) {                                         // If we failed for agent,\n      fprintf(stderr, \"%s:%i:%s PMDA Agent not available to respond..\\n\",\n              __FILE__, __LINE__, __func__); \n      exit(-1);\n   } // end if realloc failed.\n\n   if (ret != 0) {                                                      // Unknown error, \n      fprintf(stderr, \"%s:%i:%s Unknown error code ret=%i.\\n\",\n              __FILE__, __LINE__, __func__, ret); \n      exit(-1);\n   } // end if realloc failed.\n\n   pcp_event_info[pcpIdx].valType = pcp_event_info[pcpIdx].desc.type;   // Always copy type over.\n   return;                                                              // No error. \n} // END code.\n\n\n//-----------------------------------------------------------------------------\n// We cache all domains we read; to save the round-trip cost to the daemon;\n// on Saturn Test 8ms (too much delay invoked over thousands of events). \n// Use inst = -1 to free all malloced memory. \n// WARNING: realloc() cachedDomains[] can relocate the entire cache in memory,\n// INVALIDATING ALL POINTERS into it, causing segfaults or anomolous results.\n//-----------------------------------------------------------------------------\n\nstatic char *cachedGetInDom(pmInDom indom, int inst) \n{\n   static int domains=0;                                                // None cached to begin.\n   static _pcp_domain_cache_t* cachedDomains = NULL;                    // Empty pointer.\n   int i, domIdx;\n\n   if (inst == -1) {                                                    // If we are shutting down,\n      if (cachedDomains == NULL) return(NULL);                          // exit if we never built an array.\n      for (i=0; i<domains; i++) {                                       // for every one cached,\n         free(cachedDomains[i].instances);                              // .. free malloced memory.\n         free(cachedDomains[i].names);                                  // .. free malloced memory.\n      }\n      \n      free(cachedDomains);                                              // discard our table.\n      domains = 0;                                                      // reset.\n      cachedDomains = NULL;                                             // never free twice.\n      return(NULL);                                                     // exit.\n   } // end if shutting down.\n\n   // Check if we have it already.\n   for (i=0; i<domains; i++) {\n      if (indom == cachedDomains[i].domainId) break;                    // Exit loop if found.\n   } \n\n   domIdx = i;                                                          // The domain index.\n   if (i == domains) {                                                  // If not found; make a new one and read it.\n      domains++;                                                        // .. add one to count.\n\n      if (domains == 1) {                                               // for first domain,\n         cachedDomains = malloc(sizeof(_pcp_domain_cache_t));           // ..malloc.\n      } else {                                                          // for subsequent domains,\n         cachedDomains = realloc(cachedDomains, \n                        domains*sizeof(_pcp_domain_cache_t));           // realloc, retain first.\n      }\n\n      if (cachedDomains == NULL) {                                      // If we failed malloc/realloc, \n         fprintf(stderr, \"%s:%i:%s malloc/realloc denied for \"\n                 \"cachedDomains; size=%i.\\n\", \n                 __FILE__, __LINE__, __func__, domains);\n         exit(-1);\n      } // end if realloc failed.\n         \n      cachedDomains[domIdx].domainId = indom;                           // .. The domain we are getting.\n      cachedDomains[domIdx].numInstances = pcp_pmGetInDom(indom, \n         &cachedDomains[domIdx].instances,                              // .. store pointer lists in struct too.\n         &cachedDomains[domIdx].names);                                 // .. \n      for (i=0; i<cachedDomains[domIdx].numInstances; i++) {            // DEBUG, vet the strings.\n         if (cachedDomains[domIdx].names[i] == NULL || \n             strlen(cachedDomains[domIdx].names[i]) == 0 || \n             strlen(cachedDomains[domIdx].names[i]) >= PAPI_MAX_STR_LEN) {\n            fprintf(stderr, \"%s:%i:%s ERROR: cachedGetInDom: domain=%u, domIdx=%i, name idx %i invalid string.\\n\",\n               __FILE__, __LINE__, FUNC, indom, domIdx, i);\n            exit(-1);\n         } // end if domain string is nonsense.\n      }           \n   } // end if we need to cache a new domain.\n      \n   // We got the domain index, Now we can try to look up the \n   // instance name.\n\n   for (i=0; i < cachedDomains[domIdx].numInstances; i++) {             // look through all instances. \n      if (cachedDomains[domIdx].instances[i] == inst)                   // .. If found,\n        return cachedDomains[domIdx].names[i];                          // .. .. return matching name.\n   } // end search for inst.\n\n   fprintf(stderr, \"%s:%i:%s ERROR: cachedGetInDom: domain=%u, domIdx=%i, numInstances=%i, failed to find inst=%i.\\n\",\n      __FILE__, __LINE__, FUNC, indom, domIdx, cachedDomains[domIdx].numInstances, inst);\n   exit(-1);                                                            // Cannot continue; should not have happened.\n\n   return NULL;                                                         // Code cannot be reached. Couldn't find it.\n} // end routine.\n\n\n//-----------------------------------------------------------------------------\n// Helper routine, returns a ull value from a value set pointer. Automatically\n// does conversions from 32 bit to 64 bit (int32, uint32, fp32).  \n//-----------------------------------------------------------------------------\nstatic unsigned long long getULLValue(pmValueSet *vset, int value_index) \n{\n   unsigned long long value;                                         // our return value.\n   convert_64_t convert;                                             // union for conversion.\n   uPointer_t myPtr;                                                 // a union helper to avoid warnings.\n\n   if (vset->valfmt == PM_VAL_INSITU) {                              // If the value format is in situ; a 32 bit value.\n      convert.ll = vset->vlist[value_index].value.lval;              // .. we can just collect the value immediately.\n      value = convert.ull;                                           // .. \n   } else {                                                          // If it is either static or dynamic alloc table,\n      pmValueBlock *pmvb = vset->vlist[value_index].value.pval;      // .. value given is a pointer to value block.\n      myPtr.cPtr = pmvb->vbuf;                                       // .. use cPtr because vbuf defined as char[1] in pmValueBlock.\n      switch (pmvb->vtype) {                                         // Note we restricted the types in init; these cases should agree.\n         case  PM_TYPE_32:       // 32-bit signed integer\n            convert.ll = myPtr.iPtr[0];\n            value = convert.ull;\n            break;\n\n         case  PM_TYPE_U32:      // 32-bit unsigned integer\n            value =  myPtr.uiPtr[0];\n            break;\n\n         case  PM_TYPE_64:       // 64-bit signed integer\n            convert.ll = myPtr.llPtr[0];\n            value = convert.ull;\n            break;\n\n         case  PM_TYPE_U64:      // 64-bit unsigned integer\n            value = myPtr.ullPtr[0];\n            break;\n\n         case  PM_TYPE_FLOAT:    // 32-bit floating point\n            convert.d = myPtr.fPtr[0];  // convert first.\n            value = convert.ull;\n            break;\n\n         case  PM_TYPE_DOUBLE:   // 64-bit floating point\n            convert.d = myPtr.dPtr[0];\n            value = convert.ull;\n            break;\n\n         case  PM_TYPE_STRING:   // array of char \n            convert.vp = myPtr.cPtr;\n            value = convert.ull;            \n            break;\n\n         default:\n            fprintf(stderr, \"%s:%i pmValueBlock (from PCP) contains an unrecognized value type=%i.\\n\",\n               __FILE__, __LINE__,  pmvb->vtype);\n            convert.ll = -1;                                            // A flag besides zero\n            value = convert.ull;\n      } // end switch on type. \n   } // if pmValueBlock value.\n\n   return(value);                                                       // exit with result.\n} // end routine. \n\n\n//----------------------------------------------------------------------------\n// Helper routine to subtract zero value from an event value. Although we\n// store an unsigned long long value for both our zero value and a read-in\n// value, it can be recast to signed or double. So zeroing on those must be\n// done in the type intended, and we have to recast to do it. Note that 32\n// bit signed int or float were saved and cast as 64 bit int or double,\n// respectively.\n//\n// There are three types of 'semantics' in a description; only one is a \n// counter; the other two are instantaneous values. We do not subtract a\n// zero reference value from instantaneous values. \n// PM_SEM_COUNTER    // cumulative counter (monotonic increasing)\n// PM_SEM_INSTANT    // instantaneous value, continuous domain\n// PM_SEM_DISCRETE   // instantaneous value, discrete domain\n//----------------------------------------------------------------------------\n\nstatic void subZero(_pcp_control_state_t *myCtl, int event)\n{\n   int k = myCtl->pcpIndex[event];                                      // get pcp_event_info[] index.\n   if (pcp_event_info[k].desc.sem != PM_SEM_COUNTER) return;            // Don't subtract from instantaneous values.\n\n   convert_64_t zero, rawval;\n   rawval.ull = myCtl->pcpValue[event];                                 // collect the raw value.\n   zero.ull = pcp_event_info[k].zeroValue;                              // collect the zero (base) value.\n   switch (pcp_event_info[k].valType) {                                 // Note we restricted the types in init; these cases should agree.\n      case  PM_TYPE_32:                                                 // 32 bit was converted to long long.\n      case  PM_TYPE_64:                                                 // long long.\n         rawval.ll -= zero.ll;                                          // converted.\n         break;\n\n      case  PM_TYPE_U32:                                                // 32-bit was converted to 64 bit.\n      case  PM_TYPE_U64:                                                // 64-bit unsigned integer\n         rawval.ull -= zero.ull;                                        // converted.\n         break;\n\n      case  PM_TYPE_FLOAT:                                              // 32-bit was converted to double.\n      case  PM_TYPE_DOUBLE:                                             // 64-bit floating point\n         rawval.d -= zero.d;                                            // converted.\n         break;\n\n      case  PM_TYPE_STRING:                                             // array of char, do nothing for pointer.\n         break;\n\n      default:\n         fprintf(stderr, \"%s:%i pcp_event_info[%s] contains an unrecognized value type=%i.\\n\",\n            __FILE__, __LINE__,  pcp_event_info[k].name, pcp_event_info[k].valType);\n         exit(-1);                                                      // Quit, this shouldn't happen; something needs updating.\n         break;\n   } // end switch on type. \n   \n   myCtl->pcpValue[event] = rawval.ull;                                 // The adjusted value.\n} // end routine.\n\n\n//-----------------------------------------------------------------------------\n// Helper routine for _pcp_ntv_code_to_descr to retrieve pm event text (a\n// description of the event) given a pcp_event_info[] index.\n// There are two options, a PM_TEXT_ONELINE is a single line description and\n// PM_TEXT_HELP is a longer help description. The PAPI code that calls this \n// stores the description in PAPI_event_info_t->long_descr[PAPI_HUGE_STR_LEN];\n// currently 1024 characters. So we use the PM_TEXT_HELP version.\n//\n// pcpIdx MUST BE pre-validated as in range [0, sEventCount-1].\n// *helpText may be allocated; caller must free(helpText).\n// RETURNS PAPI_OK or PAPI error.\n// NOTE: There is also a pmLookupInDomText() that returns a description of a\n// domain; if you want that, you need a pmInDom and a very similar routine. \n//-----------------------------------------------------------------------------\nstatic int getHelpText(unsigned int pcpIdx, char **helpText) \n{\n   char    *p;\n   int     ret;\n   char    errMsg[]=\"Help Text is not available for this event.\";       // for an error we have seen.\n\n   pmID myPMID = pcp_event_info[pcpIdx].pmid;                           // collect the pmid.\n   ret = pcp_pmLookupText(myPMID, PM_TEXT_HELP, helpText);              // collect a line of text, routine mallocs helpText.\n   if (ret != 0) {                                                      // If larger help is not available, Try oneline.\n      if (*helpText != NULL) free(*helpText);                           // .. Free anything allocated. \n      *helpText = NULL;                                                 // .. start it as null.\n      ret = pcp_pmLookupText(myPMID, PM_TEXT_ONELINE, helpText);        // .. collect a line of text, routine mallocs helpText.\n   } \n\n   if (ret == PM_ERR_TEXT) {                                            // If not available, \n      *helpText = strdup(errMsg);                                       // duplicate this error message.\n   } else if (ret != 0) {                                               // If PCP has any other error, report and exit.\n      fprintf(stderr, \"%s:%i:%s pmLookupText failed; return=%s.\\n\", \n         __FILE__, __LINE__, FUNC, pcp_pmErrStr(ret));\n      return PAPI_EATTR;                                                // .. invalid or missing event attribute.\n   }\n\n   // Replace all /n with '|'.\n   for (p=(*helpText); p[0] != 0; p++) {                                // loop through string routine allocated,\n      if (p[0] == '\\n') p[0] = '|';                                     // .. If we found a \\n, replace with '|'.\n   } // end scan for \\n.\n\n   return PAPI_OK;                                                      // Presumably all went well.    \n} // end routine.\n\n\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\n// PAPI FUNCTIONS. \n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\n\n//----------------------------------------------------------------------------\n// _pcp_init_component is called when PAPI is initialized (during \n// PAPI_library_init). The argument is the component index. \n//---------------------------------------------------------------------------\nstatic int _pcp_init_component(int cidx) \n{\n\n   char *reason = _papi_hwd[cidx]->cmp_info.disabled_reason;            // For error messages.\n   int rLen = PAPI_MAX_STR_LEN-1;                                       // Most I will print.\n   reason[rLen]=0;                                                      // last resort terminator.\n\n   mRtnCnt(_pcp_init_component);                                        // count the routine.\n   #define hostnameLen 512 /* constant used multiple times. */\n   char hostname[hostnameLen];                                          // host name.\n   int  ret;\n\n   ret = _local_linkDynamicLibraries();\n   if ( ret != PAPI_OK ) {                                              // Failure to get lib.\n      return PAPI_ESYS;\n   }\n\n   ret = gethostname(hostname, hostnameLen);                            // Try to get the host hame.\n   if( gethostname(hostname, hostnameLen) != 0) {                       // If we can't get the hostname, \n      snprintf(reason, rLen, \"Failed system call, gethostname() \"\n            \"returned %i.\", ret);\n      return PAPI_ESYS;\n   }\n   #undef hostnameLen /* done with it. */\n\n   _prog_fprintf(stderr, \"%s:%i retrieved hostname='%s'\\n\", __FILE__, __LINE__, hostname); // show progress.\n\n   ctxHandle = pcp_pmNewContext(PM_CONTEXT_HOST, hostname);             // Set the new context to hostname retrieved.\n   if (ctxHandle < 0) {\n      snprintf(reason, rLen, \"Cannot connect to PM Daemon on host \\\"%s\\\".\\n \"\n         \"(Ensure this machine has Performance Co-Pilot installed.)\\n\", hostname);\n      return(ctxHandle);                                                // contains PAPI error code, not handle.\n   }\n\n   _prog_fprintf(stderr, \"%s:%i Found ctxHandle=%i\\n\", __FILE__, __LINE__, ctxHandle); // show progress.\n\n   sEventInfoSize = sEventInfoBlock;                                    // first allocation.   \n   pcp_event_info = (_pcp_event_info_t*) \n      calloc(sEventInfoSize, sizeof(_pcp_event_info_t));                // Make room for all events.\n\n   sEventCount = 0;                                                     // begin at zero.\n   _time_gettimeofday(&t1, NULL);\n   ret = pcp_pmTraversePMNS(AGENT_NAME, cbPopulateNameOnly);            // Timed on Saturn [Intel Xeon 2.0GHz]; typical 9ms, range 8.5-10.5ms.\n   if (ret < 0) {                                                       // Failure...\n      snprintf(reason, rLen, \"pmTraversePMNS failed; ret=%i [%s]\\n\", \n         ret, pcp_pmErrStr(ret));\n      if (ret == PM_ERR_NAME) {                                         // We know what this one is,\n         snprintf(reason, rLen, \"pmTraversePMNS ret=PM_ERR_NAME: \"\n            \"Occurs if event filter '%s' unknown to PCP Daemon.\\n\", AGENT_NAME);\n      }\n\n      return PAPI_ENOIMPL;                                              // Not implemented.\n   }      \n      \n   _time_gettimeofday(&t2, NULL);\n   _time_fprintf(stderr, \"pmTraversePMNS PopulateNameOnly took %li uS.\\n\", \n      (mConvertUsec(t2)-mConvertUsec(t1)));\n   _time_fprintf(stderr, \"Final sEventCount=%i, sEventInfoSize=%i, \"\n               \"sEventInfoBlock=%i.\\n\", \n      sEventCount, sEventInfoSize, sEventInfoBlock);\n  \n   if (sEventCount < 1) {                                               // Failure...\n      snprintf(reason, rLen, \"pmTraversePMNS returned zero events \"\n         \"for AGENT=\\\"%s\\\".\\n\", AGENT_NAME);\n      return PAPI_ENOIMPL;                                              // Can't work with no names!\n   }\n\n   int i,j,k;\n   char **allNames=calloc(sEventCount, sizeof(char*));                  // Make an array for all names. \n   for (i=0; i<sEventCount; i++) {                                      // .. \n      allNames[i] = pcp_event_info[i].name;                             // copy pointer into array. \n   } // end for each event.\n\n   pmID *allPMID=calloc(sEventCount, sizeof(pmID));                     // Make an array for results.\n   if (allPMID == NULL) {                                               // If we failed,\n      snprintf(reason, rLen, \"memory alloc denied for allPMID; \"\n            \"size=%i.\\n\", sEventCount);\n      free(allNames);\n      return(PAPI_ENOMEM);                                              // memory failure.\n   } // end if calloc failed.\n\n   //----------------------------------------------------------------\n   // Unlike Saturn, on the Power9 we get an 'IPC protocol failure' \n   // if we try to read more than 946 names at a time. This is some\n   // limitation on a communication packet size. On our test system\n   // Power9; the maximum number we can read is 946. To allow leeway\n   // for other possible values; we read in blocks of 256.\n   //----------------------------------------------------------------\n   #define LNBLOCK 256                                                  /* Power9 gets IPC errors if read block is too large. */\n   k = (__LINE__)-1;                                                    // where LNBLOCK is defined.   \n\n   _time_gettimeofday(&t1, NULL);\n\n   i=0;                                                                 // Starting index for allPMID.\n   while (i<sEventCount) {                                              // read in blocks of LNBLOCK.\n      j = sEventCount-i;                                                // .. presume we can read the rest.\n      if (j > LNBLOCK) j=LNBLOCK;                                       // .. reduce if we cannot.\n      ret = pcp_pmLookupName(j, allNames+i, allPMID+i);                 // .. Get a block of PMIDs for a block of names.\n      if (ret < 0) {                                                    // .. Failure...\n         snprintf(reason, rLen, \"pmLookupName for %i names failed; ret=%i [%s].\\n\", \n            sEventCount, ret, pcp_pmErrStr(ret));\n         if (ret == PM_ERR_IPC) {                                       // .. If we know it, rewrite.\n            snprintf(reason, rLen, \"pmLookupName ret=PM_ERR_IPC: one known cause is a readblock too large; reduce LNBLOCK (%s:%i).\\n\",\n                  __FILE__,k);\n            return PAPI_EBUF;                                           // Give buffer exceeded.\n         }\n\n         return PAPI_ESYS;                                              // .. .. Can't work with no names!\n      }\n\n      i+=j;                                                             // .. Adjust the pointer forward by what we read.\n   } // end while to read names in chunks, and avoid IPC error. \n   #undef LNBLOCK                                                       /* Discard constant; no further use. */  \n\n   _time_gettimeofday(&t2, NULL);\n   _time_fprintf(stderr, \"pmLookupName for all took %li uS, ret=%i.\\n\", \n      (mConvertUsec(t2)-mConvertUsec(t1)), ret );\n\n   for (i=0; i<sEventCount; i++) pcp_event_info[i].pmid = allPMID[i];   // copy all the pmid over to array.\n\n   pmResult *allFetch = NULL;                                           // result of pmFetch. \n   _time_gettimeofday(&t1, NULL);\n   ret = pcp_pmFetch(sEventCount, allPMID, &allFetch);                  // Fetch (read) all the events.\n   _time_gettimeofday(&t2, NULL);\n   _time_fprintf(stderr, \"pmFetch for all took %li uS, for %i events; ret=%i.\\n\", \n      (mConvertUsec(t2)-mConvertUsec(t1)), sEventCount, ret);\n\n   //-------------------------------------------------------------------\n   // In processing fetches, if we find a multi-valued event, we need\n   // to force an event for every value (PAPI only returns 1 value per\n   // event; not an array). In experiments thus far, all multi-valued\n   // events have had domain descriptor names; so we just concat with\n   // the name and make a new Event. We use a helper for that,\n   // afterward we set the number of values in the original 'base name'\n   // to zero; so it will be deleted by the cleanup routine.                                        \n   //-------------------------------------------------------------------\n\n   _time_gettimeofday(&t1, NULL);                                       // time this index explosion.\n   int origEventCount = sEventCount;                                    // sEventCount may change in below routine.\n\n   for (i=0; i<origEventCount; i++) {                                   // process all the fetch results.\n      pcp_event_info[i].desc.pmid = PM_ID_NULL;                         // This indicates the description is NOT loaded yet.\n      pmValueSet *vset = allFetch->vset[i];                             // get the result for event[i].\n\n      // On Saturn test system, never saw this happen.\n      if (vset == NULL) {                                               // .. should not happen. leave numVal=0 for deletion.\n         fprintf(stderr, \"%s:%i vset=NULL for name='%s'\\n\", \n            __FILE__, __LINE__, pcp_event_info[i].name);\n         continue;                                                      // .. next in loop.\n      }\n     \n      pcp_event_info[i].numVal = vset->numval;                          // Show we have a value.\n      if (vset->numval == 0) {                                          // If the value is zero, \n//       _prog_fprintf(stderr, \"%s:%i Discarding, no values for event  '%s'.\\n\", __FILE__, __LINE__, pcp_event_info[i].name);\n         continue;                                  // If no values, leave numVal = 0 for deletion. (We do see this in tests). \n      }\n\n      pcp_event_info[i].valfmt = vset->valfmt;                          // Get the value format. (INSITU or not).\n      getPMDesc(i);                                                     // Get the value descriptor.\n      unsigned long long ullval= (long long) -1;   // debug stuff.\n      convert_64_t convert;\n\n      if (vset->valfmt != PM_VAL_INSITU) {                              // If not in situ, must get the type.\n         pmValue *pmval = &vset->vlist[0];                              // .. Get the first value.\n         pmValueBlock *pB = pmval->value.pval;                          // .. get it.\n         if (pcp_event_info[i].valType != pB->vtype) {\n            snprintf(reason, rLen, \"Unexpected value type fetched for %s. %i vs %i. Possible version incompatibiity.\\n\", \n               pcp_event_info[i].name, pcp_event_info[i].valType, pB->vtype);\n            return PAPI_ENOSUPP;                                          // .. in\n         }\n\n//       pcp_event_info[i].valType = pB->vtype;                         // .. get the type.\n         ullval = getULLValue(vset, 0);                                 // .. get the first value.\n\n         switch(pB->vtype) {                                            // PCP's variable type; an int flag.\n            case  PM_TYPE_32:                                           // 32-bit signed integer\n               _prog_fprintf(stderr, \"type I32, desc.sem=%i, event '%s'=\", pcp_event_info[i].desc.sem, pcp_event_info[i].name); \n               break;\n            case  PM_TYPE_U32:                                          // 32-bit unsigned integer\n               _prog_fprintf(stderr, \"type U32, desc.sem=%i, event '%s'=\", pcp_event_info[i].desc.sem, pcp_event_info[i].name); \n               break;\n            case  PM_TYPE_FLOAT:                                        // 32-bit floating point\n               _prog_fprintf(stderr, \"type F32, desc.sem=%i, event '%s'=\", pcp_event_info[i].desc.sem, pcp_event_info[i].name); \n               break;                                                   // END CASE.\n\n            case  PM_TYPE_64:                                           // 64-bit signed integer\n               convert.ull = ullval;\n               _prog_fprintf(stderr, \"type I64, desc.sem=%i, event '%s'= (ll) %lli =\", pcp_event_info[i].desc.sem, pcp_event_info[i].name, convert.ll); \n               break;\n            case  PM_TYPE_U64:                                          // 64-bit unsigned integer\n               _prog_fprintf(stderr, \"type U64, desc.sem=%i, event '%s'= (ull) %llu =\", pcp_event_info[i].desc.sem, pcp_event_info[i].name, convert.ull); \n               break;\n            case  PM_TYPE_DOUBLE:                                       // 64-bit floating point\n               convert.ull = ullval;\n               _prog_fprintf(stderr, \"type U64, desc.sem=%i, event '%s'= (double) %f =\", pcp_event_info[i].desc.sem, pcp_event_info[i].name, convert.d); \n               break;                                                   // END CASE.\n\n            // IF YOU want to return string values, this is a place\n            // to change; currently all string-valued events are\n            // rejected. But, pB->vbuf is the string value. I would\n            // copy it into a new pcp_event_info[] field; it would\n            // need to be malloc'd here and free'd at component\n            // shutdown. Also PAPI would need a new way to accept a\n            // char* or void*. \n\n            case  PM_TYPE_STRING:                                       // pB->vbuf is char* to string value.\n               _prog_fprintf(stderr, \"%s:%i Discarding PM_TYPE_STRING event, desc.sem=%i, event '%s'=\", __FILE__, __LINE__, pcp_event_info[i].desc.sem, pcp_event_info[i].name); \n               pcp_event_info[i].numVal = 0;                            // .. .. set numVal = 0 for deletion.\n               break;\n\n            default:                                                    // If we don't recognize the type,\n               _prog_fprintf(stderr, \"%s:%i Dsicarding PM_UNKNOWN_TYPE event, desc.sem=%i, event '%s'=\", __FILE__, __LINE__, pcp_event_info[i].desc.sem, pcp_event_info[i].name); \n               pcp_event_info[i].numVal = 0;                            // .. set numVal = 0 for deletion.\n               break;\n         } // end switch.\n      } // If not In Situ.\n      else {\n         _prog_fprintf(stderr, \"type IST, desc.sem=%i, event '%s'=\", pcp_event_info[i].desc.sem, pcp_event_info[i].name); \n      }\n\n      convert.ull = ullval; \n      _prog_fprintf(stderr, \"%02X%02X%02X%02X %02X%02X%02X%02X\\n\", convert.ch[0], convert.ch[1],  convert.ch[2], convert.ch[3],  convert.ch[4], convert.ch[5],  convert.ch[6], convert.ch[7]);\n      // Lookup description takes time; so we only do it for\n      // multi-valued events here. For other events, we will do it\n      // as needed for EventInfo filling.\n\n      if (pcp_event_info[i].numVal > 1) {                               // If a domain qualifier is possible;\n         getPMDesc(i);                                                  // .. Get the event descriptor.\n         _prog_fprintf(stderr, \"Event %s has %i values, indom=%i.\\n\", pcp_event_info[i].name, pcp_event_info[i].numVal, pcp_event_info[i].desc.indom); \n         if (pcp_event_info[i].desc.indom != PM_INDOM_NULL) {           // .. If we have a non-null domain,\n            for (j=0; j<vset->numval; j++) {                            // .. for every value present,\n               pmValue *pmval = &vset->vlist[j];                        // .. .. get that guy.\n\n               char *dname = cachedGetInDom(                            // .. .. read from cached domains (and populate it when needed).\n                                 pcp_event_info[i].desc.indom,\n                                 pmval->inst);                          // .. .. get the name. Not malloced so don't free dName.\n\n               makeQualifiedEvent(i, j, dname);                         // .. .. helper routine; may realloc pcp_event_info[], change sEventCount.\n            } // end value list.\n            \n            pcp_event_info[i].numVal = 0;                               // .. let the base event be discarded.\n         } // end if we have a domain.                                  \n      } // end if multiple valued.                                      \n   } // end for each event.\n\n   // Trim the fat! We get rid of everything with numVal == 0.\n   // We do that by compaction; moving valid entries to backfill\n   // invalid ones.\n\n   j=0;                                                                 // first destination.                                                  \n   for (i=0; i<sEventCount; i++) {                                      // loop thorugh all old and new.\n      if (pcp_event_info[i].numVal > 0) {                               // If we have a valid entry,\n         if (i != j) pcp_event_info[j] = pcp_event_info[i];             // move if it isn't already there.\n         j++;                                                           // count one moved; new count of valid ones.\n      }\n   } \n            \n   sEventCount = j;                                                     // this is our new count.\n   pcp_event_info = realloc(pcp_event_info,                             // release any extra memory. \n                        sEventCount*sizeof(_pcp_event_info_t));         // .. \n   if (pcp_event_info == NULL) {                                        // If we failed,\n      snprintf(reason, rLen, \"memory realloc denied for \"\n            \"pcp_event_info; size=%i.\\n\", sEventCount);\n      return PAPI_ENOMEM;                                               // no memory.\n   } // end if realloc failed.\n\n   qsort(pcp_event_info, sEventCount,                                   // sort by PMID, idx, name.\n         sizeof(_pcp_event_info_t), qsPMID);                            // ..\n\n   _time_gettimeofday(&t2, NULL);                                       // done with index explosion.\n   _time_fprintf(stderr, \"indexedExplosion for all took %li uS.\\n\", \n               (mConvertUsec(t2)-mConvertUsec(t1)) );\n\n   for (i=0; i<HASH_SIZE; i++) {                                        // init hash table.\n      sNameHash[i].idx = -1;                                            // unused entry. \n      sNameHash[i].next = NULL;                                         // ..\n   }                                                                  \n                                                                   \n   unsigned int myHash;                              \n   for (i=0; i<sEventCount; i++) {                                    \n      myHash = addNameHash(pcp_event_info[i].name, i);                  // Point this hash to this entry.   \n   }                                                                  \n\n   //-----------------------------------------------------------------------------------------------------------------------\n   // *************************************** DEBUG REPORT OF INFORMATION DISCOVERED ***************************************\n   //-----------------------------------------------------------------------------------------------------------------------\n   // We use -O2, but even in -O0, if(0){...} is completely removed from code. It costs us nothing to leave this code in.\n   if (0) {                                                             // change to 1 to enable debug report. \n      unsigned int current, prev=0;                              \n      printf(\"count, hash, name, pmid, value[idx]\\n\");\n      for (i=0; i<sEventCount; i++) {\n         myHash = stringHash(pcp_event_info[i].name, HASH_SIZE);        // Get the hash value.\n         current = pcp_event_info[i].pmid;\n         if (prev > 0 && current != (prev+1) && current != prev)        // print separators.\n            printf(\"----,----,----,----\\n\");     \n         printf(\"%i, %u, \\\"%s\\\", 0x%08X, %i\\n\", i, myHash,              // quote name, may contain \\,/,comma, etc.\n                pcp_event_info[i].name, \n                pcp_event_info[i].pmid, \n                pcp_event_info[i].idx);\n         prev=current;                                                  // for finding pmid skips.\n      } \n\n      // Test hashing.\n      int hashErr = 0;\n      _time_gettimeofday(&t1, NULL);\n      for (i=0; i<sEventCount; i++) {\n         int f = findNameHash(pcp_event_info[i].name);                  // Try to find this name. \n         if (f != i) hashErr++;\n      }\n\n      _time_gettimeofday(&t2, NULL);\n      \n      _time_fprintf(stderr, \"HashLookup avg uS: %3.6f\\n\", ((double) (mConvertUsec(t2)-mConvertUsec(t1)) )/((double) sEventCount) );\n      _time_fprintf(stderr, \"Hash Errors: %i of %i.\\n\", hashErr, sEventCount);\n\n   } // END DEBUG REPORT.\n   //-----------------------------------------------------------------------------------------------------------------------\n   // *************************************** END DEBUG REPORT INFORMATION DISCOVERED **************************************\n   //-----------------------------------------------------------------------------------------------------------------------\n\n   free(allNames);                                                      // Locals allocations not needed anymore.\n   free(allPMID);                                                       // .. the pmIDs we read.\n   pcp_pmFreeResult(allFetch);                                          // .. release the results we fetched.\n\n//  For PCP, we can read any number of events at once\n//  in a single event set. Set vector elements for PAPI.\n\n   _pcp_vector.cmp_info.num_native_events = sEventCount;                // Setup our pcp vector.\n   _pcp_vector.cmp_info.num_cntrs = sEventCount;                  \n   _pcp_vector.cmp_info.num_mpx_cntrs = sEventCount;\n   _pcp_vector.cmp_info.CmpIdx = cidx;                                  // export the component ID.\n\n   return PAPI_OK;\n} // end routine.\n\n\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\n// Control of counters (Reading/Writing/Starting/Stopping/Setup) functions.\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\n\n//----------------------------------------------------------------------------\n// Init vars in pcp_context.\n// This is called immediately after _pcp_init_component.  \n//----------------------------------------------------------------------------\nstatic int _pcp_init_thread(hwd_context_t * ctx) \n{\n   mRtnCnt(_pcp_init_thread);                                           // count this function.\n   _pcp_context_t* myCtx = (_pcp_context_t*) ctx;                       // recast.\n   myCtx->initDone = 1;                                                 // Nothing else to do for init.\n   return PAPI_OK;\n}  // end routine.\n\n\n//----------------------------------------------------------------------------\n// The control_state is our internal description of an event set. \n//----------------------------------------------------------------------------\nstatic int _pcp_init_control_state( hwd_control_state_t *ctl)\n{\n   mRtnCnt(_pcp_init_control_state);                                    // count this function.\n    _pcp_control_state_t* control = ( _pcp_control_state_t* ) ctl;\n   // contents: _pcp_control_state state at this writing: \n   // contents of state: \n   // int numEvents;                                                    // The number of events we have.\n   // int maxAllocated;                                                 // the current entries in pcpIndex.\n   // int *pcpIndex;                                                    // array of indices into pcp_event_info[].\n   // long long *values;                                                // Values read from our PCP events.\n\n    memset(control, 0, sizeof(_pcp_control_state_t));                   // zero it.\n\n    return PAPI_OK;\n} // end routine.\n\n\n//---------------------------------------------------------------------------------------------\n// update_control_state: PAPI calls this when it adds or removes events\n// from its EventState; so we can do our component-specific things. The\n// hwd_control_state_t* is a void pointer, we recast to\n// _pcp_control_state_t* to get whatever is CURRENTLY in there. We only\n// need to update that, for now we just re-init it. HOWEVER, we may be\n// discarding counters we set to counting. \n// This is called.  \n\n// NOTE: This code allocates pcpIndex[] in the control and never frees\n// it.  However, the PAPI code in destroying the eventSet calls this\n// with a zero count; so we free() it then, without reallocating. Also,\n// the values[] array\n\n// NOTE: Also, PAPI *may* call more than once with a zero count on the\n// control. If you free pcpIndex, set it to NULL, so you don't try to\n// free it again.\n\n// Content of NativeInfo_t:\n// int ni_event;                // native (libpfm4) event code; always non-zero unless empty\n// int ni_papi_code;            // papi event code value returned to papi applications\n// int ni_position;             // counter array position where this native event lives\n// int ni_owners;               // specifies how many owners share this native event\n// hwd_register_t *ni_bits;     // Component defined resources used by this native event\n//---------------------------------------------------------------------------------------------\n\nstatic int _pcp_update_control_state( \n        hwd_control_state_t *ctl,                                       // Our internal info about events in an event set.\n        NativeInfo_t *native,                                           // NativeInfoArray in papi. \n        int count,                                                      // NativeCount in papi.\n        hwd_context_t *ctx)                                             // context, we don't use it.\n{\n   mRtnCnt(_pcp_update_control_state);                                  // count this function.\n   int i, index = 0;\n   ( void ) ctx;\n\n   _pcp_control_state_t* MyCtl = ( _pcp_control_state_t* ) ctl;         // Recast ctl.\n\n   MyCtl->numEvents = count;                                            // remember how many there are.\n   if (count == 0) {                                                    // If we are deleting a set,\n      if (MyCtl->pcpIndex != NULL) {                                    // If we have space allocated,\n         free(MyCtl->pcpIndex);                                         // .. discard it,\n         free(MyCtl->pcpValue);                                         // .. and values.\n         MyCtl->pcpIndex = NULL;                                        // .. never free it again.\n         MyCtl->pcpValue = NULL;                                        // .. never free it again.\n      }\n\n      MyCtl->maxAllocated = 0;                                          // .. no longer tracking max.\n      return PAPI_OK;                                                   // .. get out.\n   }\n\n   // henceforth, count != 0.\n   #define BlockSize 64 /* constant used multiple times. */\n   int newalloc = ((count/BlockSize)*BlockSize+BlockSize);              // .. pick next up multiple of BlockSize.\n   #undef  BlockSize    /*prevent bugs if same name used elsewhere.*/\n\n   if (MyCtl->pcpIndex != NULL) {                                       // If I have a previous list of variables,\n      if (count > MyCtl->maxAllocated) {                                // .. If I will need more room,\n         MyCtl->pcpIndex = realloc(MyCtl->pcpIndex,                     // .. .. reallocate to make more room.\n                                   newalloc*sizeof(int));               // .. .. ..\n         MyCtl->pcpValue = realloc(MyCtl->pcpValue,                     // .. .. reallocate to make more room.\n                                   newalloc*sizeof(unsigned long long));// .. .. ..\n         MyCtl->maxAllocated = newalloc;                                // .. .. remember what we've got.\n      }\n   } else {                                                             // If NULL then I have no previous set,\n      MyCtl->maxAllocated = newalloc;                                   // .. pick next up multiple of BlockSize.\n      MyCtl->pcpIndex =                                                 // .. make room for 'count' indices,\n         calloc(MyCtl->maxAllocated, sizeof(int));                      // .. \n      MyCtl->pcpValue =                                                 // .. make room for 'count' values.\n         calloc(MyCtl->maxAllocated, sizeof(unsigned long long));       // .. \n   }\n\n   if (MyCtl->pcpIndex == NULL) {                                       // If malloc failed,\n      return PAPI_ENOMEM;                                               // .. out of memory.\n   } // end if malloc failed.\n\n   //------------------------------------------------------------------\n   // pcpIndex alloc managed, now process all events passed in.\n   // pcpIndex[i] holds the event pcp_event_info[] index for \n   // EventSet[i], and we populate the caller's ni_position for \n   // EventSet[i] with the index into pcpIndex[].\n   //------------------------------------------------------------------\n\n   for (i=0; i<count; i++) {                                            // for each event passed in,\n      index = native[i].ni_event & PAPI_NATIVE_AND_MASK;                // get index.\n      if (index < 0 || index >= sEventCount) {                          // if something is wrong, \n         return PAPI_ENOEVNT;                                           // no such event.\n      } // end if index invalid.\n\n      MyCtl->pcpIndex[i]=index;                                         // remember the index.\n      MyCtl->pcpValue[i]=0;                                             // clear the value.   \n      native[i].ni_position = i;                                        // Tell PAPI about its location (doesn't matter to us), we have no restrictions on position.\n      getPMDesc(index);                                                 // Any time an event is added, ensure we have its variable descriptor.\n   } // end for each event listed.\n\n   return PAPI_OK;\n} // end routine.\n\n\n//---------------------------------------------------------------------\n// Helper routine, for reset and read, does the work of reading all\n// current raw values in an EventSet (hwd_control_state). \n//\n// 1) Does not subtract zeroValue; returns raw read in ULL format.\n// 2) Does not change pcp_event_info[] in any way.\n// 3) stores values in _pcp_control_state.pcpValue[] for each event.\n// 4) Returns with 'results' malloc'd by PCP, nest mallocs, SO: \n// 5) if (results != NULL) pcp_pmFreeResults(results);\n// 6) must check on 5 EVEN IF THERE WAS AN ERROR. \n//\n// RETURNS PAPI error code, or PAPI_OK.\n//---------------------------------------------------------------------\n\nstatic int PCP_ReadList(hwd_control_state_t *ctl,                       // the event set.\n    pmResult **results)                                                 // results from pmFetch, caller must pmFreeResult(results).\n{\n   int i, j, ret;\n    _pcp_control_state_t* myCtl = ( _pcp_control_state_t* ) ctl;\n   *results = NULL;                                                     // Nothing allocated.\n   if (myCtl->numEvents < 1) return PAPI_ENOEVNT;                       // No events to start.\n   int nPMID = 0;                                                       // To count number of **unique** PMIDs.\n\n   pmID *allPMID=malloc((myCtl->numEvents)*sizeof(pmID));               // Make maximum possible room.\n\n   // We build a list of all *unique* PMIDs. Because PMID can return\n   // an array of N values for a single event (e.g. one per CPU), we\n   // 'explode' such events into N events for PAPI, which can only\n   // return 1 value per event. Thus PAPI could add several to an\n   // EventSet that all have the same PMID (PCP's ID). We only need\n   // to read those once, our pcp_event_info[] contains the index\n   // for each exploded event into the array returned for that PMID.\n\n   allPMID[nPMID++] = pcp_event_info[myCtl->pcpIndex[0]].pmid;          // Move the first, increment total so far. \n\n   for (i=1; i<myCtl->numEvents; i++) {                                 // For every event in the event set,\n      int myIdx = myCtl->pcpIndex[i];                                   // .. Get pcp_event_info[] index of the event,\n      pmID myPMID = pcp_event_info[myIdx].pmid;                         // .. get the PMID for that event,\n      for (j=0; j<nPMID; j++) {                                         // .. Search the unique PMID list for a match. \n         if (myPMID == allPMID[j]) break;                               // .. .. found it. break out.\n      } \n\n      if (j == nPMID) {                                                 // full loop ==> myPMID was not found in list,\n         allPMID[nPMID++] = myPMID;                                     // .. store the unique pmid in list, inc count.\n      }\n   }                                                                    // done building list of unique pmid.\n   \n   // nPMID is # of unique PMID, now ready to read all the pmid needed.\n   pmResult *allFetch = NULL;                                           // result of pmFetch. \n   ret = pcp_pmFetch(nPMID, allPMID, &allFetch);                        // Fetch them all.\n   *results = allFetch;                                                 // For either success or failure.\n   \n   if( ret != PAPI_OK) {                                                // If fetch failed .. \n      fprintf(stderr, \"%s:%i:%s pcp_pmFetch failed, return=%s.\\n\", \n         __FILE__, __LINE__, FUNC, PAPI_strerror(ret));                 // .. report error.\n         if (allPMID != NULL)  free(allPMID);                           // .. no memory leak.\n         allPMID = NULL;                                                // .. prevent future use.\n      return(ret);                                                      // .. exit with that error.\n   }\n\n   // For each unique PMID we just read, we must map it to the event\n   // sets, which may contain multiple entries with that same PMID.\n   // This is because PCP returns arrays, and PAPI does not, so each\n   // of our names translates to a PMID + an index.\n\n   for (i=0; i<nPMID; i++) {                                            // process all the fetch results.\n      pmValueSet *vset = allFetch->vset[i];                             // get the result for event[i].\n      pmID myPMID = allPMID[i];                                         // get the pmid from this read.\n       \n      // Now we must search for any events with this pmid, and get\n      // the corresponding value (may be more than one, since we\n      // treat each idx as its own value).         \n\n      for (j=0; j<myCtl->numEvents; j++) {                              // for each event,\n         int myPCPIdx = myCtl->pcpIndex[j];                             // .. get my pcp_event_info[] index.\n         pmID thisPMID = pcp_event_info[myPCPIdx].pmid;                 // .. collect its pmid.\n         if (thisPMID == myPMID) {                                      // .. If this result services that event, \n            int myArrayIdx = pcp_event_info[myPCPIdx].idx;              // .. .. get array index within result array, for result value list.\n            myCtl->pcpValue[j] = getULLValue(vset, myArrayIdx);         // .. .. translate as needed, put back into pcpValue array.\n         } // end if counter was found for this PMID.\n      } // end loop through all events in this event set.\n   } // end for each pmID read.\n\n   if (allPMID != NULL)  free(allPMID);                                 // Done with this work area; no memory leak.\n   return PAPI_OK;                                                      // All done.\n} // end routine.\n\n\n//----------------------------------------------------------------------------\n// Reset counters.\n//---------------------------------------------------------------------------\nstatic int _pcp_reset(hwd_context_t *ctx, hwd_control_state_t *ctl) \n{\n   mRtnCnt(_pcp_reset);                                                 // count this function.\n   ( void ) ctx;                                                        // avoid unused var warning.\n   int i, k, ret;\n   unsigned long long aValue;\n\n   pmResult *allFetch;                                                  // vars to be allocated by call.\n   _pcp_control_state_t* myCtl = ( _pcp_control_state_t* ) ctl;         // make a shortcut.\n\n   ret = PCP_ReadList(ctl, &allFetch);                                  // Read the list of events we were given.\n   if (ret != PAPI_OK) {                                                // If that failed, \n      fprintf(stderr, \"%s:%i:%s PCP_ReadList failed, return=%s.\\n\", \n         __FILE__, __LINE__, FUNC, PAPI_strerror(ret));                 // report error.\n      if (allFetch != NULL) pcp_pmFreeResult(allFetch);                 // free if it was allocated.\n      return(ret);                                                      // exit with that error.\n   }\n\n   // We have all the results; the values read have been extracted\n   // and stored the control state.  Now set them as the zeroValue\n   // in each pcp_event_info[].\n\n   for (i=0; i<myCtl->numEvents; i++) {                                 // for each event, \n      k = myCtl->pcpIndex[i];                                           // .. get pcp_event_info[] index.\n      aValue = myCtl->pcpValue[i];                                      // .. get the value for that event.\n      pcp_event_info[k].zeroValue = aValue;                             // .. reset the counter. \n   } // end loop through all events in this event set.\n\n   // That is all we do; reset the zeroValue to the current value.\n   // For efficiency we do not check if it is a counter, instantaneous\n   // or discrete value; that is done in subZero.\n   pcp_pmFreeResult(allFetch);                                          // .. Clean up.\n   return PAPI_OK;\n} // end routine. \n\n\n//---------------------------------------------------------------------\n// Start counters. We just reset the counters; read them and set\n// zeroValue on each.\n//---------------------------------------------------------------------\n\nstatic int _pcp_start( hwd_context_t *ctx, hwd_control_state_t *ctl) \n{\n   mRtnCnt(_pcp_start);                                                 // count this function.\n   _pcp_reset(ctx, ctl);                                                // Just reset counters.\n   return PAPI_OK;\n} // end routine.\n\n\n//---------------------------------------------------------------------\n// read several pcp values. \n// This is triggered by PAPI_read( int EventSet, long long *values).\n// However, the **events that we see is NOT the *values which is an\n// array done by the application (or caller of PAPI_read). Instead,\n// we must give *event the address of an array of our values. \n// The eventSet is represented by ctx and ctl, for us ctx is empty.\n// The flags are a copy of PAPI's EventSetInfo_t.state, including\n// PAPI_RUNNING, PAPI_STOPPED and other flags. We ignore that here.\n//---------------------------------------------------------------------\n\nstatic int _pcp_read(hwd_context_t *ctx,                                // unused.\n         hwd_control_state_t *ctl,                                      // contains pmIDs in event set.\n         long long **events,                                            // for our returns.\n         int flags)                                                     // unused; EventSetInfo_t.state.\n{\n   mRtnCnt(_pcp_read);                                                  // count this function.\n   (void) ctx;                                                          // avoid unused var warning.\n   (void) flags;                                                        // ..\n\n   _pcp_control_state_t* myCtl = ( _pcp_control_state_t* ) ctl;         // make a shortcut.\n   int i, ret;\n   pmResult *allFetch;                                                  // vars to be allocated by call.\n   if (events == NULL) {\n      fprintf(stderr, \"%s:%i:%s 'events' is null.\\n\", \n         __FILE__, __LINE__, FUNC);                                     // report error.\n      return(PAPI_EINVAL);                                              // invalid argument.\n   }\n\n   ret = PCP_ReadList(ctl, &allFetch);                                  // Read the list of events we were given.\n   if (ret != PAPI_OK) {                                                // If that failed, \n      fprintf(stderr, \"%s:%i:%s PCP_ReadList failed, return=%s.\\n\", \n         __FILE__, __LINE__, FUNC, PAPI_strerror(ret));                 // report error.\n      return(ret);                                                      // exit with that error.\n   }\n\n   // We have all the results and values extracted from them.\n   // Now subtract zero value from them.\n      \n   for (i=0; i<myCtl->numEvents; i++) {                                 // for each event, \n      subZero(myCtl, i);                                                // .. subtract zero value in proper type. [TONY DON\"T COMMENT OUT, JUST DEBUG]\n   } // end loop through all events in this event set.\n\n   // Done, point the caller to our results list.\n   *events = (long long *) myCtl->pcpValue;                             // pointer the caller needs. \n   pcp_pmFreeResult(allFetch);                                          // Clean up.\n   return PAPI_OK;                                                      // exit, all okay.\n} // end routine.\n\n\n//---------------------------------------------------------------------\n// stop counters. (does nothing). \n//---------------------------------------------------------------------\nstatic int _pcp_stop(hwd_context_t *ctx, hwd_control_state_t *ctl) \n{\n   mRtnCnt(_pcp_stop);                                                  // count this function.\n    (void) ctx;                                                         // avoid var unused warning.\n    (void) ctl;                                                         // avoid var unused warning.\n    return PAPI_OK;\n} // end routine.\n\n\n//---------------------------------------------------------------------\n// shutdown thread. (does nothing). \n//---------------------------------------------------------------------\nstatic int _pcp_shutdown_thread(hwd_context_t * ctx) \n{\n   mRtnCnt(_pcp_shutdown_thread);                                       // count this function.\n    ( void ) ctx;                                                       // avoid var unused warning.\n\n    return PAPI_OK;\n} // end routine.\n\n\n//---------------------------------------------------------------------\n// shutdown PCP component. (frees allocs).\n//---------------------------------------------------------------------\nstatic int _pcp_shutdown_component(void) \n{\n   int i;\n   mRtnCnt(_pcp_shutdown_component);                                    // count this function.\n   pcp_pmDestroyContext(ctxHandle);                                     // context handle; fails to free malloced memory, says valgrind.\n   ctxHandle = -1;                                                      // reset to prevent reuse.\n   free(pcp_event_info); pcp_event_info=NULL;                           // then pcp_event_info, reset.\n   freeNameHash();                                                      // free sNameHash. resets itself.\n   cachedGetInDom(PM_INDOM_NULL, -1);                                   // -1 for inst == free its local static mallocs.\n   sEventCount = 0;                                                     // clear number of events. \n\n   for (i=0; i<=ctr_pcp_ntv_code_to_info; i++) \n      _prog_fprintf(stderr, \"routine counter %i = %i.\\n\", i, cnt[i]);\n\n   return PAPI_OK;\n} // end routine.\n\n\n//---------------------------------------------------------------------\n// This function sets options in the component. \n// The valid codes being passed in are PAPI_DEFDOM, PAPI_DOMAIN,\n// PAPI_DEFGRN, PAPI_GRANUL and PAPI_INHERIT.\n\n// _papi_int_option_t: \n// _papi_int_overflow_t overflow;\n// _papi_int_profile_t profile;\n// _papi_int_domain_t domain;             // PAPI_SET_DEFDOM, PAPI_SET_DOMAIN\n// _papi_int_attach_t attach;\n// _papi_int_cpu_t cpu;\n// _papi_int_multiplex_t multiplex;\n// _papi_int_itimer_t itimer;\n// _papi_int_inherit_t inherit;           // PAPI_SET_INHERIT\n// _papi_int_granularity_t granularity;   // PAPI_SET_DEFGRN, PAPI_SET_GRANUL\n// _papi_int_addr_range_t address_range;\n//---------------------------------------------------------------------\n\nstatic int _pcp_ctl (hwd_context_t *ctx, int code, _papi_int_option_t *option) \n{\n   mRtnCnt(_pcp_ctl);                                                   // count this function.\n   ( void ) ctx;                                                        // avoid var unused warning.\n   ( void ) code;                                                       // avoid var unused warning.\n   ( void ) option;                                                     // avoid var unused warning.\n\n   switch (code) {\n      case PAPI_DEFDOM:\n         SUBDBG(\"PAPI_DEFDOM, option.domain=0x%08X\\n\", (unsigned int) option->domain.domain);\n         break;\n\n      case PAPI_DOMAIN:\n         SUBDBG(\"PAPI_DOMAIN, option.domain=0x%08X\\n\", (unsigned int) option->domain.domain);\n         break;\n\n      case PAPI_DEFGRN:\n         SUBDBG(\"PAPI_DEFGRN, option.granularity=0x%08X\\n\", (unsigned int) option->granularity.granularity);\n         break;\n\n      case PAPI_GRANUL:\n         SUBDBG(\"PAPI_GRANUL, option.granularity=0x%08X\\n\", (unsigned int) option->granularity.granularity);\n         break;\n\n      case PAPI_INHERIT:\n         SUBDBG(\"PAPI_INHERIT, option.inherit=0x%08X\\n\", (unsigned int) option->inherit.inherit);\n         break;\n\n      default:\n         fprintf(stderr, \"%s:%i:%s CODE 0x%08x IS INVALID \"\n            \"OR UNRECOGNIZED.\\n\", __FILE__, __LINE__, FUNC, code);\n         return PAPI_EINVAL;                                            // Invalid code.\n         break;\n   } // end switch by code.\n \n   return PAPI_OK;                             \n} // end routine.\n\n\n//----------------------------------------------------------------------------\n// This function has to set the bits needed to count different domains.\n// PAPI_DOM_USER     : only user context is counted \n// PAPI_DOM_KERNEL   : only the Kernel/OS context is counted \n// PAPI_DOM_OTHER    : Exception/transient mode (like user TLB misses) \n// PAPI_DOM_ALL      : all of the domains, THE ONLY ONE WE ACCEPT!\n// All other domains result in an invalid value.\n//----------------------------------------------------------------------------\nstatic int _pcp_set_domain(hwd_control_state_t *ctl, int domain) \n{\n   mRtnCnt(_pcp_set_domain);                                            // count this function.\n    (void) ctl;                                                         // avoid var unused warning.\n    if ( PAPI_DOM_ALL != domain ) return PAPI_EINVAL;                   // Reject if not this one.\n    return PAPI_OK;                                                     // Otherwise, OK, nothing to do.\n} // end routine.\n\n\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\n// NATIVE EVENT ROUTINES.\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\n\n//----------------------------------------------------------------------------\n// Enumerate events. PAPI_NTV_ENUM_UMASKS has nothing to do; we don't have \n// qualifying masks or options on any of our events.\n//----------------------------------------------------------------------------\n\nstatic int _pcp_ntv_enum_events(unsigned int *EventCode, int modifier) \n{\n   mRtnCnt(_pcp_ntv_enum_events);                                       // count this function.\n   int idx;\n\n   switch (modifier) {                                                  // modifier is type of enum operation desired.\n       case PAPI_ENUM_FIRST:                                            // Returns event code of first event created.\n           EventCode[0] = 0;                                            // Return 0 as event code after a start.\n           return PAPI_OK;                                              // EXIT.\n           break;                                                       // END CASE.\n                                                                        \n       // return EventCode of next available event.                     \n       case PAPI_ENUM_EVENTS:                                           // enum base events (which is all events).\n           idx = EventCode[0] & PAPI_NATIVE_AND_MASK;                   // Take off any hi order flag bits.\n           if ((++idx) >= sEventCount) return PAPI_ENOEVNT;             // If we reach an invalid idx for pcp_event_info[], exit. Does nothing to EventCode.\n           EventCode[0] = idx | PAPI_NATIVE_MASK;                       // If index was valid, we return it.\n           return PAPI_OK;                                              // And exit.\n           break;                                                       // END CASE.\n                                                                        \n       case PAPI_NTV_ENUM_UMASKS:                                       // Note we HAVE no qualifiers or masks.\n           return PAPI_ENOEVNT;                                         // There are no qualifiers to list.\n                                                                        \n       default:                                                         // If we don't understand the modifier,\n           return PAPI_ENOEVNT;                                         // .. Presets or other stuff, just say we have none.\n           break;                                                       // END CASE.\n   } // end switch(modifier).                                           \n                                                                        \n   return PAPI_EBUG;                                                    // Dummy return; should have exited from inside switch.\n} // end routine.\n\n\n//----------------------------------------------------------------------------\n// Given a string, find the name in the pcp_event_info[] array.  \n//---------------------------------------------------------------------------\nstatic int _pcp_ntv_name_to_code(const char *name, unsigned int *event_code) \n{\n   mRtnCnt(_pcp_ntv_name_to_code);                                      // count this function.\n\n   if (name == NULL || strlen(name)<1) {                                // Invalid name argument.\n      fprintf(stderr, \"%s:%i:%s Invalid name.\\n\",                       // .. report it.\n         __FILE__, __LINE__, FUNC);                            \n         return PAPI_EINVAL;                                            // .. Invalid argument.\n   }\n\n   if (event_code == NULL) {                                            // Invalid event_code pointer.\n      fprintf(stderr, \"%s:%i:%s event_code is not a valid pointer.\\n\",  // .. report it.\n         __FILE__, __LINE__, FUNC);                            \n         return PAPI_EINVAL;                                            // .. Invalid argument.\n   }\n\n   int idx = findNameHash((char*) name);                                // Use our hash to find it.\n   if (idx < 0) {                                                       // If we failed, \n      fprintf(stderr, \"%s:%i:%s Failed to find name='%s', hash=%i.\\n\",  // .. report it.\n         __FILE__, __LINE__, FUNC, name, \n         stringHash((char*) name, HASH_SIZE));                          // .. \n         return PAPI_EINVAL;                                            // .. Invalid argument.\n   }\n\n   *event_code = idx;                                                   // return with the index we found.\n   return PAPI_OK;\n} // end routine.\n\n\n//----------------------------------------------------------------------------\n// Collect the name of the event from the EventCode, given here as our index\n// into pcp_event_info[]. We must fit it into name[len].\n//----------------------------------------------------------------------------\nstatic int _pcp_ntv_code_to_name(unsigned int pcpIdx, char *name, int len)\n{\n   mRtnCnt(_pcp_ntv_code_to_name);                                      // count this function.\n\n   pcpIdx &= PAPI_NATIVE_AND_MASK;                                      // We can be called with the NATIVE bit set.\n   if (pcpIdx >= (unsigned int) sEventCount) {                          // out of range?\n      fprintf(stderr, \"%s:%i:%s called with out-of-range pcpIdx=%u.\\n\", \n         __FILE__, __LINE__, FUNC, pcpIdx);\n      return PAPI_EINVAL;                                               // exit with error.\n   }\n\n   if (len < 1)  {                                                      // If length is ridiculous,\n      fprintf(stderr, \"%s:%i:%s called with out-of-range descr len=%i.\\n\", \n         __FILE__, __LINE__, FUNC, len);\n      return PAPI_EINVAL;                                               // exit with error.\n   }\n\n   strncpy(name, pcp_event_info[pcpIdx].name, len);                     // just copy the name.\n   name[len-1]=0;                                                       // force z-termination.\n\n   return PAPI_OK;\n} // end routine.\n\n\n//----------------------------------------------------------------------------\n// Collect the text description of the EventCode; which is our index into our\n// pcp_event_info[] array. We must fit it into descr[len].  \n//---------------------------------------------------------------------------\n\nstatic int _pcp_ntv_code_to_descr(unsigned int pcpIdx, char *descr, int len) \n{\n   mRtnCnt(_pcp_ntv_code_to_descr);                                     // count this function.\n\n   pcpIdx &= PAPI_NATIVE_AND_MASK;                                      // We might be called with the NATIVE bit set.\n   if (pcpIdx >= (unsigned int) sEventCount) {                          // out of range?\n      fprintf(stderr, \"%s:%i:%s called with out-of-range pcpIdx=%u.\\n\", \n         __FILE__, __LINE__, FUNC, pcpIdx);\n      return PAPI_EINVAL;                                               // exit with error.\n   }\n\n   if (len < 1)  {                                                      // If length is ridiculous,\n      fprintf(stderr, \"%s:%i:%s called with out-of-range descr len=%i.\\n\", \n         __FILE__, __LINE__, FUNC, len);\n      return PAPI_EINVAL;                                               // exit with error.\n   }\n\n   char *helpText = NULL;                                               // pointer to receive the result.\n   int ret = getHelpText(pcpIdx, &helpText);                            // get it. \n   if (ret != PAPI_OK) {                                                // If there is any error,\n      if (helpText != NULL) free(helpText);                             // .. no memory leak.\n      fprintf(stderr, \"%s:%i:%s failed getHelpText; it returned %s.\\n\", \n         __FILE__, __LINE__, FUNC, PAPI_strerror(ret));\n      return ret;                                                       // exit with whatever PAPI error routine had.\n   }\n\n   strncpy(descr, helpText, len);                                       // copy it over.\n   descr[len-1] = 0;                                                    // force a z-terminator.\n   free(helpText);                                                      // release text alloc by pm routine.\n   return PAPI_OK;                                                      // EXIT, all good.\n} // end routine.\n\n\n//---------------------------------------------------------------------\n// Fill in the PAPI_event_info_t vars. This is not a required\n// function for a component, not all fields require filling in.\n// Components that implement this feature generally complete the\n// following fields:\n\n// char symbol[PAPI_HUGE_STR_LEN];     // (1024 char, name of the event),\n// char long_descr[PAPI_HUGE_STR_LEN]; // (1024 char, can be a paragraph);\n// char units[PAPI_MIN_STR_LEN];       // (64 chars, unit of measurement);\n// int  data_type;                     // data type returned by PAPI.       \n// \n// data_type is PAPI_DATATYPE_INT64, PAPI_DATATYPE_UINT64,\n// PAPI_DATATYPE_FP64, PAPI_DATATYPE_BIT64.\n// We translate all values into INT64, UINT64, or FP64.\n//\n// timescope;                          // Counter or instantaneous.\n// PAPI_TIMESCOPE_SINCE_START          // Data is cumulative from start.\n// PAPI_TIMESCOPE_POINT                // Data is an instantaneous value.\n//---------------------------------------------------------------------\n\nstatic int _pcp_ntv_code_to_info(unsigned int pcpIdx, PAPI_event_info_t *info) \n{\n   mRtnCnt(_pcp_ntv_code_to_info);                                      // count this function.\n   int len, ret;   \n\n   pcpIdx &= PAPI_NATIVE_AND_MASK;                                      // remove any high order bits.\n   if (pcpIdx >= (unsigned int) sEventCount) {                          // out of range?\n      fprintf(stderr, \"%s:%i:%s called with out-of-range pcpIdx=%u.\\n\", \n         __FILE__, __LINE__, FUNC, pcpIdx);\n      return PAPI_EINVAL;                                               // exit with error.\n   }\n\n   len=sizeof(info->symbol);                                            // get length.\n   strncpy(info->symbol, pcp_event_info[pcpIdx].name, len);             // Copy. \n   info->symbol[len-1] = 0;                                             // force z-terminator.\n\n   len=sizeof(info->long_descr);                                        // get length.\n   ret = _pcp_ntv_code_to_descr(pcpIdx, info->long_descr, len);         // copy to info.\n   if (ret != PAPI_OK) return(ret);                                     // return on failure. _pcp_ntv_code_to_descr already printed error.\n\n   // Units resides in pmDesc; we need to get it if we don't already\n   // have it (multi-valued events got it during init).\n\n   getPMDesc(pcpIdx);                                                   // get the description.\n\n   char unitStr[64];\n   // This routine has been timed over 19600 trials on Saturn;\n   // it requires an average of 2 uS. No daemon comm needed.\n\n   pcp_pmUnitsStr_r(&pcp_event_info[pcpIdx].desc.units, unitStr, 64);   // Construct the unit string; needs at least 60 char.\n   if ( strlen(unitStr) == 0) {\n      sprintf(unitStr, \"fraction\");                                     // Only ever seen for 'dutycycle' events.\n\n      // Following is for debug purposes. \n      if (0) {                                                          // Alternatively, show the details of the PCP units descriptor.\n         sprintf(unitStr, \"[%u, %i, %u, %u, %i, %i, %i]\", \n            pcp_event_info[pcpIdx].desc.units.pad,\n            pcp_event_info[pcpIdx].desc.units.scaleCount,\n            pcp_event_info[pcpIdx].desc.units.scaleTime,\n            pcp_event_info[pcpIdx].desc.units.scaleSpace,\n            pcp_event_info[pcpIdx].desc.units.dimCount,\n            pcp_event_info[pcpIdx].desc.units.dimTime,\n            pcp_event_info[pcpIdx].desc.units.dimSpace\n         );\n      } \n   }\n\n   len = sizeof(info->units);                                           // length of destination.\n   strncpy( info->units, unitStr, len);                                 // copy it over.\n   info->units[len-1] = 0;                                              // ensure a z-terminator.\n\n   switch (pcp_event_info[pcpIdx].valType) {                            // Translate this to a papi value.\n\n      case  PM_TYPE_32:                                                 // 32 bit was converted to long long.\n      case  PM_TYPE_64:                                                 // long long.\n         info->data_type = PAPI_DATATYPE_INT64;                         // What papi needs.\n         break;                                                         // END CASE.\n\n      case  PM_TYPE_U32:                                                // 32-bit was converted to 64 bit.\n      case  PM_TYPE_U64:                                                // 64-bit unsigned integer\n      case  PM_TYPE_STRING:                                             // array of char pointer.\n         info->data_type = PAPI_DATATYPE_UINT64;                        // What papi needs.\n         break;                                                         // END CASE.\n\n      case  PM_TYPE_FLOAT:                                              // 32-bit was converted to double.\n      case  PM_TYPE_DOUBLE:                                             // 64-bit floating point\n         info->data_type = PAPI_DATATYPE_FP64;                          // What papi needs.\n         break;                                                         // END CASE.\n   };\n\n   if (pcp_event_info[pcpIdx].desc.sem == PM_SEM_COUNTER) {             // If we have a counter,\n      info->timescope = PAPI_TIMESCOPE_SINCE_START;                     // .. normal stuff.\n   } else {                                                             // An instantaneous value. \n      info->timescope = PAPI_TIMESCOPE_POINT;                           // .. What PAPI calls that.\n   }\n\n   return PAPI_OK;                                                      // exit.\n} // end routine.\n\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\n// PCP Vector definition. \n//---------------------------------------------------------------------------\n//----------------------------------------------------------------------------\n\npapi_vector_t _pcp_vector = {\n   .cmp_info = { /* (unspecified values are initialized to 0) */\n      .name = \"pcp\",\n      .short_name = \"pcp\",\n      .description = \"Performance Co-Pilot\",\n      .version = \"5.6.1\",\n      .default_domain = PAPI_DOM_ALL,\n      .default_granularity = PAPI_GRN_SYS,\n      .available_granularities = PAPI_GRN_SYS,\n      .hardware_intr_sig = PAPI_INT_SIGNAL,\n      .available_domains = PAPI_DOM_ALL,\n   },\n\n   /* sizes of framework-opaque component-private structures */\n   .size = {\n      .context          = sizeof ( _pcp_context_t ),\n      .control_state    = sizeof ( _pcp_control_state_t ),\n      .reg_value        = sizeof ( _pcp_register_t ),\n      .reg_alloc        = sizeof ( _pcp_reg_alloc_t ),\n   },\n\n   /* function pointers in this component */\n   .init_thread         = _pcp_init_thread,\n   .init_component      = _pcp_init_component,\n   .init_control_state  = _pcp_init_control_state,\n   .start               = _pcp_start,\n   .stop                = _pcp_stop,\n   .read                = _pcp_read,\n   .shutdown_thread     = _pcp_shutdown_thread,\n   .shutdown_component  = _pcp_shutdown_component,\n   .ctl                 = _pcp_ctl,\n\n   .update_control_state= _pcp_update_control_state,\n   .set_domain          = _pcp_set_domain,\n   .reset               = _pcp_reset,\n\n   .ntv_enum_events     = _pcp_ntv_enum_events,\n   .ntv_name_to_code    = _pcp_ntv_name_to_code,\n   .ntv_code_to_name    = _pcp_ntv_code_to_name,\n   .ntv_code_to_descr   = _pcp_ntv_code_to_descr,\n   .ntv_code_to_info    = _pcp_ntv_code_to_info,\n}; // end pcp_vector.\n",
        "/tmp/vanessa/spack-stage/spack-stage-papi-6.0.0.1-gmm3tef6bggycxgzrtmq2ejaggc2ozfb/spack-src/src/components/libmsr/linux-libmsr.c": "/**\n * @file    linux-libmsr.c\n * @author  Asim YarKhan\n *\n * @ingroup papi_components\n *\n * @brief libmsr component\n *\n * This PAPI component provides access to libmsr from LLNL\n * (https://github.com/scalability-llnl/libmsr), specifically the RAPL\n * (Running Average Power Level) access in libmsr, which provides\n * energy measurements on modern Intel CPUs.\n *\n * To work, either msr_safe kernel module from LLNL\n * (https://github.com/scalability-llnl/msr-safe), or the x86 generic\n * MSR driver must be installed (CONFIG_X86_MSR) and the\n * /dev/cpu/?/<msr_safe | msr> files must have read permissions\n *\n * If /dev/cpu/?/{msr_safe,msr} have appropriate write permissions,\n * you can write to the events PACKAGE_POWER_LIMIT_{1,2} to change the\n * average power (in watts) consumed by the packages/sockets over a\n * certain time window specified by events\n * PKG_TIME_WINDOW_POWER_LIMIT_{1,2} respectively.\n */\n/* Based on the rapl component by Vince Weaver */\n\n#include <stdio.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <string.h>\n#include <stdint.h>\n#include <errno.h>\n\n/* Headers required by PAPI */\n#include \"papi.h\"\n#include \"papi_internal.h\"\n#include \"papi_vector.h\"\n#include \"papi_memory.h\"\n\n#include <msr_core.h>\n#include <msr_rapl.h>\n#include <msr_counters.h>\n\ntypedef enum {\n    PKG_ENERGY=0,\n    PKG_ELAPSED,\n    PKG_DELTA_ENERGY,\n    PKG_WATTS,\n    PKG_POWER_LIMIT_1,\n    PKG_TIME_WINDOW_POWER_LIMIT_1,\n    PKG_POWER_LIMIT_2,\n    PKG_TIME_WINDOW_POWER_LIMIT_2,\n    NUM_OF_EVENTTYPES\n} eventtype_enum;\n\ntypedef struct _libmsr_register {\n    unsigned int selector;\n} _libmsr_register_t;\n\ntypedef struct _libmsr_native_event_entry {\n    char name[PAPI_MAX_STR_LEN];\n    char units[PAPI_MIN_STR_LEN];\n    char description[PAPI_MAX_STR_LEN];\n    int package_num;            /* which package/socket for this event */\n    eventtype_enum eventtype;\n    int return_type;\n    _libmsr_register_t resources;\n} _libmsr_native_event_entry_t;\n\ntypedef struct _libmsr_reg_alloc {\n    _libmsr_register_t ra_bits;\n} _libmsr_reg_alloc_t;\n\n/* actually 32? But setting this to be safe? */\n#define LIBMSR_MAX_COUNTERS 64\n#define LIBMSR_MAX_PACKAGES 64\n\ntypedef struct _libmsr_control_state {\n    /* The following are one per event being measured */\n    int num_events_measured;\n    /* int domain; */\n    /* int multiplexed; */\n    /* int overflow; */\n    /* int inherit; */\n    int being_measured[LIBMSR_MAX_COUNTERS];\n    int which_counter[LIBMSR_MAX_COUNTERS];\n    long long count[LIBMSR_MAX_COUNTERS];\n    /* The following is boolean: Is package NN active in for event */\n    int package_being_measured[LIBMSR_MAX_PACKAGES];\n} _libmsr_control_state_t;\n\ntypedef struct _libmsr_context {\n    _libmsr_control_state_t state;\n} _libmsr_context_t;\n\npapi_vector_t _libmsr_vector;\n\nstatic _libmsr_native_event_entry_t *libmsr_native_events = NULL;\nstatic int num_events_global = 0;\nstatic int already_called_libmsr_rapl_initialized_global = 0;\n\n/***************************************************************************/\n\n/* For dynamic linking to libmsr */\n/* Using weak symbols allows PAPI to be built with the component, but\n * installed in a system without the required library */\n#include <dlfcn.h>\nstatic void* dl1 = NULL;\n\n// string macro defined within Rules.libmsr\nstatic char libmsr_main[]=PAPI_LIBMSR_MAIN;\n\n//-----------------------------------------------------------------------------\n// Using weak symbols (global declared without a value, so it defers to any\n// other global declared in another file WITH a value) allows PAPI to be built\n// with the component, but PAPI can still be installed in a system without the\n// required library.\n//-----------------------------------------------------------------------------\n\nvoid (*_dl_non_dynamic_init)(void) __attribute__((weak));               // declare a weak dynamic-library init routine pointer.\n\n/* Functions pointers */\nstatic int (*init_msr_ptr)();\nstatic int (*finalize_msr_ptr)();\nstatic int (*rapl_init_ptr)(struct rapl_data ** rapl, uint64_t ** rapl_flags);\nstatic int (*poll_rapl_data_ptr) ( );\nstatic void (*set_pkg_rapl_limit_ptr) ( const int socket, struct rapl_limit* limit1, struct rapl_limit* limit2 );\nstatic void (*get_pkg_rapl_limit_ptr) ( const int socket, struct rapl_limit* limit1, struct rapl_limit* limit2 );\nstatic int (*core_config_ptr) (uint64_t * coresPerSocket, uint64_t * threadsPerCore, uint64_t * sysSockets, int * HTenabled);\nstatic int (*rapl_storage_ptr) (struct rapl_data ** data, uint64_t ** flags);\nstatic int (*get_rapl_power_info_ptr) ( const unsigned socket, struct rapl_power_info *info);\n\n/* Local wrappers for function pointers */\nstatic int libmsr_init_msr () { return ((*init_msr_ptr)()); }\nstatic int libmsr_finalize_msr () { return ((*finalize_msr_ptr)()); }\nstatic int libmsr_rapl_init (struct rapl_data ** rapl_data, uint64_t ** rapl_flags) { return (*rapl_init_ptr)( rapl_data, rapl_flags ); }\nstatic int libmsr_poll_rapl_data ( ) { return (*poll_rapl_data_ptr) (); }\nstatic void libmsr_set_pkg_rapl_limit ( const int socket, struct rapl_limit* limit1, struct rapl_limit* limit2 ) { return (*set_pkg_rapl_limit_ptr) ( socket, limit1, limit2 ); }\nstatic void libmsr_get_pkg_rapl_limit ( const int socket, struct rapl_limit* limit1, struct rapl_limit* limit2 ) { return (*get_pkg_rapl_limit_ptr) ( socket, limit1, limit2 ); }\nstatic int libmsr_core_config(uint64_t * coresPerSocket, uint64_t * threadsPerCore, uint64_t * sysSockets, int * HTenabled) { return (*core_config_ptr) ( coresPerSocket, threadsPerCore, sysSockets, HTenabled ); }\nstatic int libmsr_rapl_storage(struct rapl_data ** data, uint64_t ** flags) { return (*rapl_storage_ptr) (data, flags); }\nstatic int libmsr_get_rapl_power_info( const unsigned socket, struct rapl_power_info *info) { return (*get_rapl_power_info_ptr) ( socket, info); }\n\n\n#define CHECK_DL_STATUS( err, str ) if( err ) { strncpy( _libmsr_vector.cmp_info.disabled_reason, str, PAPI_MAX_STR_LEN ); return ( PAPI_ENOSUPP ); }\nstatic int _local_linkDynamicLibraries()\n{\n    if ( _dl_non_dynamic_init != NULL ) {\n        // If weak var present, statically linked insted of dynamic.\n        strncpy( _libmsr_vector.cmp_info.disabled_reason, \"The libmsr component REQUIRES dynamic linking capabilities.\", PAPI_MAX_STR_LEN-1);\n        // EXIT not supported.\n        return PAPI_ENOSUPP;\n    }\n\n    char path_name[1024];\n    char *libmsr_root = getenv(\"PAPI_LIBMSR_ROOT\"); \n\n    dl1 = NULL;\n    // Step 1: Process override if given.   \n    if (strlen(libmsr_main) > 0) {                                  // If override given, it has to work.\n        dl1 = dlopen(libmsr_main, RTLD_NOW | RTLD_GLOBAL);           // Try to open that path.\n        if (dl1 == NULL) {\n            snprintf(_libmsr_vector.cmp_info.disabled_reason, PAPI_MAX_STR_LEN, \"PAPI_LIBMSR_MAIN override '%s' given in Rules.libmsr not found.\", libmsr_main);\n            return(PAPI_ENOSUPP);   // Override given but not found.\n        }\n    }\n\n    // Step 2: Try system paths, will work with Spack, LD_LIBRARY_PATH, default paths.\n    if (dl1 == NULL) {                                           // No override,\n        dl1 = dlopen(\"libmsr.so\", RTLD_NOW | RTLD_GLOBAL);        // Try system paths.\n    }\n\n    // Step 3: Try the explicit install default. \n    if (dl1 == NULL && libmsr_root != NULL) {                          // if root given, try it.\n        snprintf(path_name, 1024, \"%s/lib/libmsr.so\", libmsr_root);   // PAPI Root check.\n        dl1 = dlopen(path_name, RTLD_NOW | RTLD_GLOBAL);             // Try to open that path.\n    }\n\n    // Check for failure.\n    if (dl1 == NULL) {\n        snprintf(_libmsr_vector.cmp_info.disabled_reason, PAPI_MAX_STR_LEN, \"libmsr.so not found.\");\n        return(PAPI_ENOSUPP);\n    }\n\n    // We have dl1.\n\n    CHECK_DL_STATUS( !dl1 , \"Component library libmsr.so not found.\" );\n    init_msr_ptr = dlsym( dl1, \"init_msr\" );\n    CHECK_DL_STATUS( dlerror()!=NULL , \"libmsr function init_msr not found.\" );\n    finalize_msr_ptr = dlsym( dl1, \"finalize_msr\" );\n    CHECK_DL_STATUS( dlerror()!=NULL, \"libmsr function finalize_msr not found.\" );\n    rapl_init_ptr = dlsym( dl1, \"rapl_init\" );\n    CHECK_DL_STATUS( dlerror()!=NULL, \"libmsr function rapl_init not found.\" );\n    poll_rapl_data_ptr = dlsym( dl1, \"poll_rapl_data\" );\n    CHECK_DL_STATUS( dlerror()!=NULL, \"libmsr function poll_rapl_data not found.\" );\n    set_pkg_rapl_limit_ptr = dlsym( dl1, \"set_pkg_rapl_limit\" );\n    CHECK_DL_STATUS( dlerror()!=NULL, \"libmsr function set_pkg_rapl_limit not found.\" );\n    get_pkg_rapl_limit_ptr = dlsym( dl1, \"get_pkg_rapl_limit\" );\n    CHECK_DL_STATUS( dlerror()!=NULL, \"libmsr function get_pkg_rapl_limit not found.\" );\n    core_config_ptr = dlsym( dl1, \"core_config\" );\n    CHECK_DL_STATUS( dlerror()!=NULL, \"libmsr function core_config not found.\" );\n    rapl_storage_ptr = dlsym( dl1, \"rapl_storage\" );\n    CHECK_DL_STATUS( dlerror()!=NULL, \"libmsr function rapl_storage not found.\" );\n    get_rapl_power_info_ptr = dlsym( dl1, \"get_rapl_power_info\" );\n    CHECK_DL_STATUS( dlerror()!=NULL, \"libmsr function get_rapl_power_info not found.\" );\n    return( PAPI_OK);\n}\n\n/***************************************************************************/\n/******  BEGIN FUNCTIONS  USED INTERNALLY SPECIFIC TO THIS COMPONENT *******/\n/***************************************************************************/\n\n/* Null terminated version of strncpy */\nstatic char * _local_strlcpy( char *dst, const char *src, size_t size )\n{\n    char *retval = strncpy( dst, src, size );\n    if ( size>0 ) dst[size-1] = '\\0';\n    return( retval );\n}\n\n\nvoid _local_set_to_defaults()\n{\n    uint64_t socket, numSockets;\n    struct rapl_power_info raplinfo;\n    struct rapl_limit socketlim, socketlim2;\n\n    SUBDBG(\"Enter: Resetting the sockets to defaults\\n\");\n    libmsr_core_config( NULL, NULL, &numSockets, NULL);\n    for (socket = 0; socket < numSockets; socket++)  {\n        libmsr_get_rapl_power_info(socket, &raplinfo);\n        socketlim.bits = 0;\n        socketlim.watts = raplinfo.pkg_therm_power;\n        socketlim.seconds = 1;\n        socketlim2.bits = 0;\n        socketlim2.watts = raplinfo.pkg_therm_power * 1.2;\n        socketlim2.seconds = 3;\n        SUBDBG(\"Resetting socket %ld to defaults (%f,%f) (%f,%f)\\n\", socket, socketlim.watts, socketlim.seconds, socketlim2.watts, socketlim2.seconds);\n        libmsr_set_pkg_rapl_limit(socket, &socketlim, &socketlim2);\n    }\n}\n\n\n/************************* PAPI Functions **********************************/\n\n/*\n * This is called whenever a thread is initialized\n */\nint _libmsr_init_thread( hwd_context_t * ctx )\n{\n    ( void ) ctx;\n    return PAPI_OK;\n}\n\n\n/*\n * Called when PAPI process is initialized (i.e. PAPI_library_init)\n */\nint _libmsr_init_component( int cidx )\n{\n    SUBDBG( \"Enter: cidx: %d\\n\", cidx );\n    int i, j;\n    /* int package; */\n    /* FILE *fff; */\n    /* char filename[BUFSIZ]; */\n    int num_packages;\n    /* int num_cpus; */\n    const PAPI_hw_info_t *hw_info;\n    int retval;\n    struct rapl_data * libmsr_rapl_data;\n    uint64_t * libmsr_rapl_flags;\n    uint64_t coresPerSocket, threadsPerCore, numSockets;\n    int HTenabled;\n\n    /* check if Intel processor */\n    hw_info = &( _papi_hwi_system_info.hw_info );\n    /* Can't use PAPI_get_hardware_info() if PAPI library not done initializing yet */\n    if( hw_info->vendor != PAPI_VENDOR_INTEL ) {\n        strncpy( _libmsr_vector.cmp_info.disabled_reason, \"Not an Intel processor\", PAPI_MAX_STR_LEN );\n        return PAPI_ENOSUPP;\n    }\n\n    /* Dynamically load libmsr API and libraries  */\n    retval = _local_linkDynamicLibraries();\n    if ( retval!=PAPI_OK ) {\n        SUBDBG (\"Dynamic link of libmsr.so libraries failed, component will be disabled.\\n\");\n        SUBDBG (\"See disable reason in papi_component_avail output for more details.\\n\");\n        return (PAPI_ENOSUPP);\n    }\n\n    /* initialize libmsr */\n    if ( libmsr_init_msr() != 0 ) {\n        strncpy( _libmsr_vector.cmp_info.disabled_reason, \"Library libmsr could not initialize (libmsr/init_msr failed)\", PAPI_MAX_STR_LEN );\n        SUBDBG( \"init_msr (libmsr) returned error.  Possible problems accessing /dev/cpu/<n>/msr_safe or /dev/cpu/<n>/msr\"); \n        return PAPI_ENOSUPP; \n    }\n\n    /* Initialize libmsr RAPL */\n    if ( already_called_libmsr_rapl_initialized_global==0 ) {\n        if ( libmsr_rapl_init( &libmsr_rapl_data, &libmsr_rapl_flags ) < 0 ) {\n            strncpy( _libmsr_vector.cmp_info.disabled_reason, \"Library libmsr could not initialize RAPL (libmsr/rapl_init failed)\", PAPI_MAX_STR_LEN );\n            SUBDBG( \"Library libmsr could not initialize RAPL (libmsr/rapl_init failed)\"); \n            return PAPI_ENOSUPP;\n        }\n        already_called_libmsr_rapl_initialized_global = 1;\n    }\n\n    /* Get the numbers of cores, threads, sockets, ht */\n    libmsr_core_config(&coresPerSocket, &threadsPerCore, &numSockets, &HTenabled);\n\n    /* Fill packages and cpus with sentinel values */\n    /* int packages[numSockets]; */\n    /* for( i = 0; i < numSockets; ++i ) packages[i] = -1; */\n    /* num_cpus = numSockets*coresPerSocket; */\n    num_packages = numSockets;\n\n    /* /\\* Detect how many packages and count num_cpus *\\/ */\n    /* num_cpus = 0; */\n    /* while( 1 ) { */\n    /*     int num_read; */\n    /*     sprintf( filename, \"/sys/devices/system/cpu/cpu%d/topology/physical_package_id\", num_cpus ); */\n    /*     fff = fopen( filename, \"r\" ); */\n    /*     if( fff == NULL ) break; */\n    /*     num_read = fscanf( fff, \"%d\", &package ); */\n    /*     fclose( fff ); */\n    /*     if( num_read != 1 ) { */\n    /*         strcpy( _libmsr_vector.cmp_info.disabled_reason, \"Error reading file: \" ); */\n    /*         strncat( _libmsr_vector.cmp_info.disabled_reason, filename, PAPI_MAX_STR_LEN - strlen( _libmsr_vector.cmp_info.disabled_reason ) - 1 ); */\n    /*         _libmsr_vector.cmp_info.disabled_reason[PAPI_MAX_STR_LEN - 1] = '\\0'; */\n    /*         return PAPI_ESYS; */\n    /*     } */\n    /*     /\\* Check if a new package *\\/ */\n    /*     if( ( package >= 0 ) && ( package < nr_cpus ) ) { */\n    /*         if( packages[package] == -1 ) { */\n    /*             SUBDBG( \"Found package %d out of total %d\\n\", package, num_packages ); */\n    /*             packages[package] = package; */\n    /*             num_packages++; */\n    /*         } */\n    /*     } else { */\n    /*         SUBDBG( \"Package outside of allowed range\\n\" ); */\n    /*         strncpy( _libmsr_vector.cmp_info.disabled_reason, \"Package outside of allowed range\", PAPI_MAX_STR_LEN ); */\n    /*         return PAPI_ESYS; */\n    /*     } */\n    /*     num_cpus++; */\n    /* } */\n\n    /* /\\* Error if no accessible packages *\\/ */\n    /* if( num_packages == 0 ) { */\n    /*     SUBDBG( \"Can't access any physical packages\\n\" ); */\n    /*     strncpy( _libmsr_vector.cmp_info.disabled_reason, \"Can't access /sys/devices/system/cpu/cpu<d>/topology/physical_package_id\", PAPI_MAX_STR_LEN ); */\n    /*     return PAPI_ESYS; */\n    /* } */\n    /* SUBDBG( \"Found %d packages with %d cpus\\n\", num_packages, num_cpus ); */\n\n    int max_num_events = ( NUM_OF_EVENTTYPES * num_packages );\n    /* Allocate space for events */\n    libmsr_native_events = ( _libmsr_native_event_entry_t * ) calloc( sizeof( _libmsr_native_event_entry_t ), max_num_events );\n    if ( !libmsr_native_events ) SUBDBG(\"Could not allocate memory\\n\" );\n\n    /* Create events for package power info */\n    num_events_global = 0;\n    i = 0;\n    for( j = 0; j < num_packages; j++ ) {\n\n        sprintf( libmsr_native_events[i].name, \"PKG_ENERGY:PACKAGE%d\", j );\n        strncpy( libmsr_native_events[i].units, \"J\", PAPI_MIN_STR_LEN );\n        sprintf(libmsr_native_events[i].description,\"Number of Joules consumed by all cores and last level cache on package.  Unit is Joules (double precision).\");\n        libmsr_native_events[i].package_num = j;\n        libmsr_native_events[i].resources.selector = i + 1;\n        libmsr_native_events[i].eventtype = PKG_ENERGY;\n        libmsr_native_events[i].return_type = PAPI_DATATYPE_FP64;\n        i++;\n\n        sprintf( libmsr_native_events[i].name, \"PKG_WATTS:PACKAGE%d\", j );\n        strncpy( libmsr_native_events[i].units, \"W\", PAPI_MIN_STR_LEN );\n        sprintf( libmsr_native_events[i].description, \"Watts consumed by package. Unit is Watts (double precision).\");\n        libmsr_native_events[i].package_num = j;\n        libmsr_native_events[i].resources.selector = i + 1;\n        libmsr_native_events[i].eventtype = PKG_WATTS;\n        libmsr_native_events[i].return_type = PAPI_DATATYPE_FP64;\n        i++;\n\n        sprintf( libmsr_native_events[i].name, \"PKG_ELAPSED:PACKAGE%d\", j );\n        strncpy( libmsr_native_events[i].units, \"S\", PAPI_MIN_STR_LEN );\n        sprintf( libmsr_native_events[i].description, \"Time elapsed since last LIBMSR data reading from package. Unit is seconds (double precision).\");\n        libmsr_native_events[i].package_num = j;\n        libmsr_native_events[i].resources.selector = i + 1;\n        libmsr_native_events[i].eventtype = PKG_ELAPSED;\n        libmsr_native_events[i].return_type = PAPI_DATATYPE_FP64;\n        i++;\n\n        sprintf( libmsr_native_events[i].name, \"PKG_DELTA_ENERGY:PACKAGE%d\", j );\n        strncpy( libmsr_native_events[i].units, \"J\", PAPI_MIN_STR_LEN );\n        sprintf( libmsr_native_events[i].description, \"Number of Joules consumed by package since last LIBMSR data reading.  Unit is Joules (double precision).\");\n        libmsr_native_events[i].package_num = j;\n        libmsr_native_events[i].resources.selector = i + 1;\n        libmsr_native_events[i].eventtype = PKG_DELTA_ENERGY;\n        libmsr_native_events[i].return_type = PAPI_DATATYPE_FP64;\n        i++;\n\n        sprintf( libmsr_native_events[i].name, \"PKG_POWER_LIMIT_1:PACKAGE%d\", j );\n        strncpy( libmsr_native_events[i].units, \"W\", PAPI_MIN_STR_LEN );\n        sprintf( libmsr_native_events[i].description, \"Average power limit over PKG_TIME_WINDOW_POWER_LIMIT_1 for package. Read/Write. Unit is Watts (double precision).\");\n        libmsr_native_events[i].package_num = j;\n        libmsr_native_events[i].resources.selector = i + 1;\n        libmsr_native_events[i].eventtype = PKG_POWER_LIMIT_1;\n        libmsr_native_events[i].return_type = PAPI_DATATYPE_FP64;\n        i++;\n\n        sprintf( libmsr_native_events[i].name, \"PKG_TIME_WINDOW_POWER_LIMIT_1:PACKAGE%d\", j );\n        strncpy( libmsr_native_events[i].units, \"S\", PAPI_MIN_STR_LEN );\n        sprintf( libmsr_native_events[i].description, \"Time window used for averaging PACKAGE_POWER_LIMIT_1 for package.  Read/Write.  Unit is seconds (double precision).\");\n        libmsr_native_events[i].package_num = j;\n        libmsr_native_events[i].resources.selector = i + 1;\n        libmsr_native_events[i].eventtype = PKG_TIME_WINDOW_POWER_LIMIT_1;\n        libmsr_native_events[i].return_type = PAPI_DATATYPE_FP64;\n        i++;\n\n        sprintf( libmsr_native_events[i].name, \"PKG_POWER_LIMIT_2:PACKAGE%d\", j );\n        strncpy( libmsr_native_events[i].units, \"W\", PAPI_MIN_STR_LEN );\n        sprintf( libmsr_native_events[i].description, \"Average power limit over PKG_TIME_WINDOW_POWER_LIMIT_2 for package. Read/Write. Unit is Watts (double precision).\");\n        libmsr_native_events[i].package_num = j;\n        libmsr_native_events[i].resources.selector = i + 1;\n        libmsr_native_events[i].eventtype = PKG_POWER_LIMIT_2;\n        libmsr_native_events[i].return_type = PAPI_DATATYPE_FP64;\n        i++;\n\n        sprintf( libmsr_native_events[i].name, \"PKG_TIME_WINDOW_POWER_LIMIT_2:PACKAGE%d\", j );\n        strncpy( libmsr_native_events[i].units, \"S\", PAPI_MIN_STR_LEN );\n        sprintf( libmsr_native_events[i].description, \"Time window used for averaging PACKAGE_POWER_LIMIT_2 for package.  Read/Write.  Unit is seconds (double precision).\");\n        libmsr_native_events[i].package_num = j;\n        libmsr_native_events[i].resources.selector = i + 1;\n        libmsr_native_events[i].eventtype = PKG_TIME_WINDOW_POWER_LIMIT_2;\n        libmsr_native_events[i].return_type = PAPI_DATATYPE_FP64;\n        i++;\n\n        // TODO Add DRAM values\n        // DRAM_ENERGY\n        // DRAM_DELTA_ENERGY\n        // DRAM_WATTS\n        // TODO Add PP0, PP1 events\n    }\n    num_events_global = i;\n\n    /* Export the total number of events available */\n    _libmsr_vector.cmp_info.num_native_events = num_events_global;\n    _libmsr_vector.cmp_info.num_cntrs = _libmsr_vector.cmp_info.num_native_events;\n    _libmsr_vector.cmp_info.num_mpx_cntrs = _libmsr_vector.cmp_info.num_native_events;\n\n    /* Export the component id */\n    _libmsr_vector.cmp_info.CmpIdx = cidx;\n\n    return PAPI_OK;\n}\n\n\n/*\n * Control of counters (Reading/Writing/Starting/Stopping/Setup)\n */\nint _libmsr_init_control_state( hwd_control_state_t * ctl )\n{\n    SUBDBG( \"Enter: ctl: %p\\n\", ctl );\n    _libmsr_control_state_t *control = ( _libmsr_control_state_t * ) ctl;\n    int i;\n\n    for( i = 0; i < LIBMSR_MAX_COUNTERS; i++ )\n        control->which_counter[i] = 0;\n    for( i = 0; i < LIBMSR_MAX_PACKAGES; i++ )\n        control->package_being_measured[i] = 0;\n    control->num_events_measured = 0;\n\n    return PAPI_OK;\n}\n\n\nint _libmsr_update_control_state( hwd_control_state_t * ctl, NativeInfo_t * native, int count, hwd_context_t * ctx )\n{\n    SUBDBG( \"Enter: ctl: %p, ctx: %p\\n\", ctl, ctx );\n    int nn, index;\n    ( void ) ctx;\n    _libmsr_control_state_t *control = ( _libmsr_control_state_t * ) ctl;\n\n    control->num_events_measured = 0;\n    /* Track which events need to be measured */\n    for( nn = 0; nn < count; nn++ ) {\n        index = native[nn].ni_event & PAPI_NATIVE_AND_MASK;\n        native[nn].ni_position = nn;\n        control->which_counter[nn] = index;\n        control->count[nn] = 0;\n        /* Track (on/off vector) which packages/sockets need to be measured for these events */\n        control->package_being_measured[libmsr_native_events[index].package_num] = 1;\n        control->num_events_measured++;\n    }\n    return PAPI_OK;\n}\n\n\nint _libmsr_start( hwd_context_t * ctx, hwd_control_state_t * ctl )\n{\n    SUBDBG( \"Enter: ctl: %p, ctx: %p\\n\", ctl, ctx );\n    ( void ) ctx;\n    ( void ) ctl;\n\n    /* Read once to get initial data */\n    if ( libmsr_poll_rapl_data() < 0 ) {\n        strncpy( _libmsr_vector.cmp_info.disabled_reason, \"Function libmsr.so:poll_rapl_data failed. \", PAPI_MAX_STR_LEN );\n        return PAPI_ESYS;\n    }\n    return PAPI_OK;\n}\n\n\nint _libmsr_read( hwd_context_t * ctx, hwd_control_state_t * ctl, long long **events, int flags )\n{\n    SUBDBG( \"Enter: ctl: %p, ctx: %p\\n\", ctl, ctx );\n    ( void ) flags;\n    ( void ) ctx;\n    _libmsr_control_state_t *control = ( _libmsr_control_state_t * ) ctl;\n    int nn, pp, ee;                 /* native, package, event indices */\n    union { long long ll; double dbl; } event_value_union;\n    struct rapl_limit limit1, limit2;\n    eventtype_enum eventtype;\n    struct rapl_data * libmsr_rapl_data;\n    uint64_t * libmsr_rapl_flags;\n\n    /* Get a pointer to the rapl_data data storage  */\n    if ( libmsr_rapl_storage( &libmsr_rapl_data, &libmsr_rapl_flags)!=0 )  {\n        strncpy( _libmsr_vector.cmp_info.disabled_reason, \"Function libmsr.so:rapl_storage failed. \", PAPI_MAX_STR_LEN );\n        return PAPI_ESYS;\n    }\n\n    /* If any socket/package needs to be read, call the poll once to read all packages */\n    for ( pp = 0; pp < LIBMSR_MAX_PACKAGES; pp++ ) {\n        if ( control->package_being_measured[pp] ) {\n            SUBDBG(\"Calling poll_rapl_data to read state from all sockets\\n\");\n            if ( libmsr_poll_rapl_data()!= 0 ) {\n                strncpy( _libmsr_vector.cmp_info.disabled_reason, \"Function libmsr.so:poll_rapl_data failed. \", PAPI_MAX_STR_LEN );\n                return PAPI_ESYS;\n            }\n            break;\n        }\n    }\n\n    /* Go thru events, assign package data to events as needed */\n    SUBDBG(\"Go thru events, assign package data to events as needed\\n\");\n    for( nn = 0; nn < control->num_events_measured; nn++ ) {\n        ee = control->which_counter[nn];\n        pp = libmsr_native_events[ee].package_num;\n        event_value_union.ll = 0LL;\n        eventtype = libmsr_native_events[ee].eventtype;\n        SUBDBG(\"nn %d ee %d pp %d eventtype %d\\n\", nn, ee, pp, eventtype);\n        switch (eventtype) {\n        case PKG_ENERGY:\n            event_value_union.dbl = libmsr_rapl_data->pkg_joules[pp];\n            break;\n        case PKG_ELAPSED:\n            event_value_union.dbl = libmsr_rapl_data->elapsed;\n            break;\n        case PKG_DELTA_ENERGY:\n            event_value_union.dbl = libmsr_rapl_data->pkg_delta_joules[pp];\n            break;\n        case PKG_WATTS:\n            event_value_union.dbl = libmsr_rapl_data->pkg_watts[pp];\n            break;\n        case PKG_POWER_LIMIT_1:\n            limit1.bits = 0;  limit1.watts = 0; limit1.seconds = 0;\n            libmsr_get_pkg_rapl_limit( pp, &limit1, NULL );\n            event_value_union.dbl = limit1.watts;\n            break;\n        case PKG_TIME_WINDOW_POWER_LIMIT_1:\n            limit1.bits = 0;  limit1.watts = 0; limit1.seconds = 0;\n            libmsr_get_pkg_rapl_limit( pp, &limit1, NULL );\n            event_value_union.dbl = limit1.seconds;\n            break;\n        case PKG_POWER_LIMIT_2:\n            limit2.bits = 0;  limit2.watts = 0; limit2.seconds = 0;\n            libmsr_get_pkg_rapl_limit( pp, NULL, &limit2 );\n            event_value_union.dbl = limit2.watts;\n            break;\n        case PKG_TIME_WINDOW_POWER_LIMIT_2:\n            limit2.bits = 0;  limit2.watts = 0; limit2.seconds = 0;\n            libmsr_get_pkg_rapl_limit( pp, NULL, &limit2 );\n            event_value_union.dbl = limit2.seconds;\n            break;\n        default:\n            SUBDBG(\"This LIBMSR event is unknown\\n\");\n            /* error here */\n        }\n        control->count[nn] = event_value_union.ll;\n    }\n    /* Pass back a pointer to our results */\n    if ( events!=NULL ) *events = ( ( _libmsr_control_state_t * ) ctl )->count;\n    return PAPI_OK;\n}\n\n\nstatic long long _local_get_eventval_from_values( _libmsr_control_state_t *control, long long *invalues, int package_num, eventtype_enum eventtype, long long defaultval )\n{\n    int nn, pp, ee;                 /* native, package, event indices */\n    /* Loop thru all the events, if package and repltype match, return the value  */\n    for( nn = 0; nn < control->num_events_measured; nn++ ) {\n        ee = control->which_counter[nn];\n        pp = libmsr_native_events[ee].package_num;\n        if ( pp == package_num && libmsr_native_events[ee].eventtype == eventtype )\n            return invalues[ee];\n    }\n    return defaultval;\n}\n\n\nint _libmsr_write( hwd_context_t * ctx, hwd_control_state_t * ctl, long long *values )\n{\n    SUBDBG( \"Enter: ctl: %p, ctx: %p\\n\", ctl, ctx );\n    /* write values */\n    ( void ) ctx;\n    _libmsr_control_state_t *control = ( _libmsr_control_state_t * ) ctl;\n    //long long now = PAPI_get_real_usec();\n    int nn, pp, ee;                 /* native, package, event indices */\n    union { long long ll; double dbl; } event_value_union;\n    union { long long ll; double dbl; } timewin_union;\n    struct rapl_limit limit1, limit2;\n    eventtype_enum eventtype;\n\n    /* Go thru events, assign package data to events as needed */\n    for( nn = 0; nn < control->num_events_measured; nn++ ) {\n        ee = control->which_counter[nn];\n        pp = libmsr_native_events[ee].package_num;\n        /* grab value and put into the union structure */\n        event_value_union.ll = values[nn];\n        /* If this is a NULL value, it means that the user does not want to write this value */\n        if ( event_value_union.ll == PAPI_NULL ) continue;\n        eventtype = libmsr_native_events[ee].eventtype;\n        SUBDBG(\"nn %d ee %d pp %d eventtype %d\\n\", nn, ee, pp, eventtype);\n        switch (eventtype) {\n        case PKG_ENERGY:\n        case PKG_ELAPSED:\n        case PKG_WATTS:\n        case PKG_DELTA_ENERGY:\n            /* Read only so do nothing */\n            break;\n        case PKG_POWER_LIMIT_1:\n            timewin_union.ll = _local_get_eventval_from_values( control, values, pp, PKG_TIME_WINDOW_POWER_LIMIT_1, -1 );\n            if ( timewin_union.ll > 0 ) {\n                limit1.watts = event_value_union.dbl;\n                limit1.seconds = timewin_union.dbl;\n                limit1.bits = 0;\n                //printf(\"set_libmsr_limit package %d limit1 %lf %lf\\n\", pp, limit1.watts, limit1.seconds);\n                libmsr_set_pkg_rapl_limit( pp, &limit1, NULL  );\n            } else {\n                // Note error - power limit1 is not updated\n                SUBDBG(\"PACKAGE_POWER_LIMIT_1 needs PKG_TIME_WINDOW_POWER_LIMIT_1: Power cap not updated. \");\n            }\n            break;\n        case PKG_POWER_LIMIT_2:\n            timewin_union.ll = _local_get_eventval_from_values( control, values, pp, PKG_TIME_WINDOW_POWER_LIMIT_2, -1 );\n            if ( timewin_union.ll > 0 ) {\n                limit2.watts = event_value_union.dbl;\n                limit2.seconds = timewin_union.dbl;\n                limit2.bits = 0;\n                //printf(\"set_libmsr_limit package %d limit2 %lf %lf \\n\", pp, limit2.watts, limit2.seconds);\n                libmsr_set_pkg_rapl_limit( pp, NULL, &limit2 );\n            } else {\n                // Write error\n                PAPIERROR(\"PACKAGE_POWER_LIMIT_1 needs PKG_TIME_WINDOW_POWER_LIMIT_1: Powercap not updated.\");\n            }\n            break;\n        case PKG_TIME_WINDOW_POWER_LIMIT_1:\n        case PKG_TIME_WINDOW_POWER_LIMIT_2:\n            /* These are only meaningful (and looked up) if the power limits are set */\n            break;\n        default:\n            SUBDBG(\"This LIBMSR information type is unknown\\n\");\n            /* error here */\n        }\n    }\n    return PAPI_OK;\n}\n\n\nint _libmsr_stop( hwd_context_t * ctx, hwd_control_state_t * ctl )\n{\n    SUBDBG( \"Enter: ctl: %p, ctx: %p\\n\", ctl, ctx );\n    ( void ) ctx;\n    ( void ) ctl;\n    _local_set_to_defaults();\n    return PAPI_OK;\n}\n\n\n/* Shutdown a thread */\nint _libmsr_shutdown_thread( hwd_context_t * ctx )\n{\n    SUBDBG( \"Enter: ctl: %p\\n\", ctx );\n    ( void ) ctx;\n    return PAPI_OK;\n}\n\n\n/*\n * Clean up what was setup in  libmsr_init_component().\n */\nint _libmsr_shutdown_component( void )\n{\n    SUBDBG( \"Enter\\n\" );\n\n    _local_set_to_defaults();\n\n    if ( libmsr_finalize_msr()!=0 ) {\n        strncpy( _libmsr_vector.cmp_info.disabled_reason, \"Function libmsr.so:finalize_msr failed. \", PAPI_MAX_STR_LEN );\n        return PAPI_ESYS;\n    }\n    if( libmsr_native_events ) {\n        free( libmsr_native_events );\n        libmsr_native_events = NULL;\n    }\n    dlclose( dl1 );\n    return PAPI_OK;\n}\n\n\n/* This function sets various options in the component The valid codes\n * being passed in are PAPI_SET_DEFDOM, PAPI_SET_DOMAIN,\n * PAPI_SETDEFGRN, PAPI_SET_GRANUL * and PAPI_SET_INHERIT */\nint _libmsr_ctl( hwd_context_t * ctx, int code, _papi_int_option_t * option )\n{\n    SUBDBG( \"Enter: ctx: %p\\n\", ctx );\n    ( void ) ctx;\n    ( void ) code;\n    ( void ) option;\n\n    return PAPI_OK;\n}\n\n\n/*\n * This function has to set the bits needed to count different domains\n * In particular: PAPI_DOM_USER, PAPI_DOM_KERNEL PAPI_DOM_OTHER\n * By default return PAPI_EINVAL if none of those are specified\n * and PAPI_OK with success\n * PAPI_DOM_USER is only user context is counted\n * PAPI_DOM_KERNEL is only the Kernel/OS context is counted\n * PAPI_DOM_OTHER  is Exception/transient mode (like user TLB misses)\n * PAPI_DOM_ALL   is all of the domains\n */\nint _libmsr_set_domain( hwd_control_state_t * ctl, int domain )\n{\n    SUBDBG( \"Enter: ctl: %p\\n\", ctl );\n    ( void ) ctl;\n    /* In theory we only support system-wide mode */\n    /* How to best handle that? */\n    if( domain != PAPI_DOM_ALL )\n        return PAPI_EINVAL;\n    return PAPI_OK;\n}\n\n\nint _libmsr_reset( hwd_context_t * ctx, hwd_control_state_t * ctl )\n{\n    SUBDBG( \"Enter: ctl: %p, ctx: %p\\n\", ctl, ctx );\n    ( void ) ctx;\n    ( void ) ctl;\n\n    return PAPI_OK;\n}\n\n\n/*\n * Native Event functions\n */\nint _libmsr_ntv_enum_events( unsigned int *EventCode, int modifier )\n{\n    SUBDBG( \"Enter: EventCode: %d\\n\", *EventCode );\n    int index;\n    if ( num_events_global == 0 )\n        return PAPI_ENOEVNT;\n\n    switch ( modifier ) {\n    case PAPI_ENUM_FIRST:\n        *EventCode = 0;\n        return PAPI_OK;\n        break;\n    case PAPI_ENUM_EVENTS:\n        index = *EventCode & PAPI_NATIVE_AND_MASK;\n        if ( index < num_events_global - 1 ) {\n            *EventCode = *EventCode + 1;\n            return PAPI_OK;\n        } else {\n            return PAPI_ENOEVNT;\n        }\n        break;\n        // case PAPI_NTV_ENUM_UMASKS:\n    default:\n        return PAPI_EINVAL;\n    }\n\n    return PAPI_EINVAL;\n}\n\n\n/*\n *\n */\nint _libmsr_ntv_code_to_name( unsigned int EventCode, char *name, int len )\n{\n    SUBDBG( \"Enter: EventCode: %d\\n\", EventCode );\n    int index = EventCode & PAPI_NATIVE_AND_MASK;\n\n    if( index >= 0 && index < num_events_global ) {\n        _local_strlcpy( name, libmsr_native_events[index].name, len );\n        return PAPI_OK;\n    }\n    return PAPI_ENOEVNT;\n}\n\n\nint _libmsr_ntv_code_to_descr( unsigned int EventCode, char *name, int len )\n{\n    SUBDBG( \"Enter: EventCode: %d\\n\", EventCode );\n    int index = EventCode;\n\n    if( ( index < 0 ) || ( index >= num_events_global ) )\n        return PAPI_ENOEVNT;\n\n    _local_strlcpy( name, libmsr_native_events[index].description, len );\n    return PAPI_OK;\n}\n\n\nint _libmsr_ntv_code_to_info( unsigned int EventCode, PAPI_event_info_t * info )\n{\n    SUBDBG( \"Enter: EventCode: %d\\n\", EventCode );\n    int index = EventCode;\n\n    if( ( index < 0 ) || ( index >= num_events_global ) )\n        return PAPI_ENOEVNT;\n\n    _local_strlcpy( info->symbol, libmsr_native_events[index].name, sizeof( info->symbol ) );\n    _local_strlcpy( info->long_descr, libmsr_native_events[index].description, sizeof( info->long_descr ) );\n    _local_strlcpy( info->units, libmsr_native_events[index].units, sizeof( info->units ) );\n    info->data_type = libmsr_native_events[index].return_type;\n    return PAPI_OK;\n}\n\n\npapi_vector_t _libmsr_vector = {\n    .cmp_info = {               /* (unspecified values are initialized to 0) */\n        .name = \"libmsr\",\n        .short_name = \"libmsr\",\n        .description = \"PAPI component for libmsr from LANL for power (RAPL) read/write\",\n        .version = \"5.3.0\",\n        .default_domain = PAPI_DOM_ALL,\n        .default_granularity = PAPI_GRN_SYS,\n        .available_granularities = PAPI_GRN_SYS,\n        .hardware_intr_sig = PAPI_INT_SIGNAL,\n        .available_domains = PAPI_DOM_ALL,\n    },\n    /* sizes of framework-opaque component-private structures */\n    .size = {\n        .context = sizeof( _libmsr_context_t ),\n        .control_state = sizeof( _libmsr_control_state_t ),\n        .reg_value = sizeof( _libmsr_register_t ),\n        .reg_alloc = sizeof( _libmsr_reg_alloc_t ),\n    },\n    /* function pointers in this component */\n    .start = _libmsr_start,\n    .stop = _libmsr_stop,\n    .read = _libmsr_read,\n    .reset = _libmsr_reset,\n    .write = _libmsr_write,\n    .init_component = _libmsr_init_component,\n    .init_thread = _libmsr_init_thread,\n    .init_control_state = _libmsr_init_control_state,\n    .update_control_state = _libmsr_update_control_state,\n    .ctl = _libmsr_ctl,\n    .set_domain = _libmsr_set_domain,\n    .ntv_enum_events = _libmsr_ntv_enum_events,\n    .ntv_code_to_name = _libmsr_ntv_code_to_name,\n    .ntv_code_to_descr = _libmsr_ntv_code_to_descr,\n    .ntv_code_to_info = _libmsr_ntv_code_to_info,\n    .shutdown_thread = _libmsr_shutdown_thread,\n    .shutdown_component = _libmsr_shutdown_component,\n};\n",
        "/tmp/vanessa/spack-stage/spack-stage-papi-6.0.0.1-gmm3tef6bggycxgzrtmq2ejaggc2ozfb/spack-src/src/components/host_micpower/linux-host_micpower.c": "/** linux-host_micpower.c\n *\t@author James Ralph\n *\tralph@icl.utk.edu\n *\n *\t@ingroup papi_components\n *\n *\t@brief\n *\t\tThis component wraps the MicAccessAPI to provide hostside \n *\t\tpower information for attached Intel Xeon Phi (MIC) cards.\n*/ \n\n/* From intel examples, see $(mic_dir)/sysmgt/sdk/Examples/Usage */\n#define MAX_DEVICES (32)\n#define EVENTS_PER_DEVICE 10\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <dlfcn.h> \n\n#include \"MicAccessTypes.h\"\n#include \"MicBasicTypes.h\"\n#include \"MicAccessErrorTypes.h\"\n#include \"MicAccessApi.h\"\n#include \"MicPowerManagerAPI.h\"\n\n#include \"papi.h\"\n#include \"papi_internal.h\"\n#include \"papi_vector.h\"\n#include \"papi_memory.h\"\n\nvoid (*_dl_non_dynamic_init)(void) __attribute__((weak));\n\n/* This is a guess, refine this later */\n#define UPDATEFREQ 500000\n\npapi_vector_t _host_micpower_vector;\n\ntypedef struct host_micpower_register {\n\t/** Corresponds to counter slot, indexed from 1, 0 has a special meaning */\n\tunsigned int selector;\n} host_micpower_register_t;\n\ntypedef struct host_micpower_reg_alloc {\n\thost_micpower_register_t ra_bits;\n} host_micpower_reg_alloc_t;\n\n/** Internal structure used to build the table of events */\ntypedef struct host_micpower_native_event_entry {\n\thost_micpower_register_t resources; \n\tchar name[PAPI_MAX_STR_LEN];\n\tchar description[PAPI_MAX_STR_LEN];\n\tchar units[3];\n} host_micpower_native_event_entry_t;\n\n/** Per-eventset structure used to hold control flags. */\ntypedef struct host_micpower_control_state {\n\tint num_events;\n\tint resident[MAX_DEVICES*EVENTS_PER_DEVICE];\n\tlong long counts[MAX_DEVICES*EVENTS_PER_DEVICE];\n\tlong long lastupdate[MAX_DEVICES];\n} host_micpower_control_state_t;\n\n/** Per-thread data */\ntypedef struct host_micpower_context {\n\thost_micpower_control_state_t state;\n} host_micpower_context_t; \n\n/* Global state info */\nstatic MicDeviceOnSystem adapters[MAX_DEVICES];\nstatic HANDLE handles[MAX_DEVICES];\nstatic long long lastupdate[MAX_DEVICES];\nstatic HANDLE accessHandle = NULL;\nstatic U32 nAdapters = MAX_DEVICES;\n\nstatic void* mic_access \t= \tNULL;\nstatic void* scif_access\t=\tNULL;\n\n#undef MICACCESS_API\n#define MICACCESS_API __attribute__((weak))\nconst char *MicGetErrorString(U32);\nU32 MICACCESS_API MicCloseAdapter(HANDLE);\nU32 MICACCESS_API MicInitAPI(HANDLE *, ETarget, MicDeviceOnSystem *, U32 *);\nU32 MICACCESS_API MicCloseAPI(HANDLE *);\nU32 MICACCESS_API MicInitAdapter(HANDLE *, MicDeviceOnSystem *);\nU32 MICACCESS_API MicGetPowerUsage(HANDLE, MicPwrUsage *);\n\nconst char *(*MicGetErrorStringPtr)(U32);\nU32 (*MicCloseAdapterPtr)(HANDLE);\nU32 (*MicInitAPIPtr)(HANDLE *, ETarget, MicDeviceOnSystem *, U32 *);\nU32 (*MicCloseAPIPtr)(HANDLE *);\nU32 (*MicInitAdapterPtr)(HANDLE *, MicDeviceOnSystem *);\nU32 (*MicGetPowerUsagePtr)(HANDLE, MicPwrUsage *);\nstatic host_micpower_native_event_entry_t *native_events_table = NULL;\n\nstruct powers {\n\t\tint total0;\n\t\tint total1;\n\t\tint\tinst;\n\t\tint imax;\n\t\tint pcie;\n\t\tint c2x3;\n\t\tint c2x4;\n\t\tint vccp;\n\t\tint vddg;\n\t\tint vddq;\n};\n\ntypedef union {\n\t\tstruct powers power;\n\t\tint array[EVENTS_PER_DEVICE]; \n} power_t;\n\nstatic power_t cached_values[MAX_DEVICES];\n\nstatic int \nloadFunctionPtrs()\n{\n\t/* Attempt to guess if we were statically linked to libc, if so bail */\n\tif ( _dl_non_dynamic_init != NULL ) {\n\t\tstrncpy(_host_micpower_vector.cmp_info.disabled_reason, \"The host_micpower component does not support statically linking of libc.\", PAPI_MAX_STR_LEN);\n\t\treturn PAPI_ENOSUPP;\n\t}\n\n\t  /* Need to link in the cuda libraries, if not found disable the component */\n\tscif_access = dlopen(\"libscif.so\", RTLD_NOW | RTLD_GLOBAL);\n    if (NULL == scif_access)\n    {\n        snprintf(_host_micpower_vector.cmp_info.disabled_reason, PAPI_MAX_STR_LEN, \"Problem loading the SCIF library: %s\\n\", dlerror());\n\t\t\t_host_micpower_vector.cmp_info.disabled = 1;\n        return ( PAPI_ENOSUPP );\n    }\n\n    mic_access = dlopen(\"libMicAccessSDK.so\", RTLD_NOW | RTLD_GLOBAL);\n    if (NULL == mic_access)\n    {\n        snprintf(_host_micpower_vector.cmp_info.disabled_reason, PAPI_MAX_STR_LEN, \"Problem loading libMicAccessSDK.so: %s\\n\", dlerror());\n\t\t\t_host_micpower_vector.cmp_info.disabled = 1;\n        return ( PAPI_ENOSUPP );\n    }\n\n\tMicGetErrorStringPtr = dlsym(mic_access, \"MicGetErrorString\");\n\tif (dlerror() != NULL)\n\t{\n\t\t\tstrncpy(_host_micpower_vector.cmp_info.disabled_reason, \"MicAccessSDK function MicGetErrorString not found.\",PAPI_MAX_STR_LEN);\n\t\t\t_host_micpower_vector.cmp_info.disabled = 1;\n\t\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tMicCloseAdapterPtr = dlsym(mic_access, \"MicCloseAdapter\");\n\tif (dlerror() != NULL)\n\t{\n\t\t\tstrncpy(_host_micpower_vector.cmp_info.disabled_reason, \"MicAccessSDK function MicCloseAdapter not found.\",PAPI_MAX_STR_LEN);\n\t\t\t_host_micpower_vector.cmp_info.disabled = 1;\n\t\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tMicInitAPIPtr = dlsym(mic_access, \"MicInitAPI\");\n\tif (dlerror() != NULL)\n\t{\n\t\t\tstrncpy(_host_micpower_vector.cmp_info.disabled_reason, \"MicAccessSDK function MicInitAPI not found.\",PAPI_MAX_STR_LEN);\n\t\t\t_host_micpower_vector.cmp_info.disabled = 1;\n\t\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tMicCloseAPIPtr = dlsym(mic_access, \"MicCloseAPI\");\n\tif (dlerror() != NULL)\n\t{\n\t\t\tstrncpy(_host_micpower_vector.cmp_info.disabled_reason, \"MicAccessSDK function MicCloseAPI not found.\",PAPI_MAX_STR_LEN);\n\t\t\t_host_micpower_vector.cmp_info.disabled = 1;\n\t\t\treturn ( PAPI_ENOSUPP );\n\t}\n\tMicInitAdapterPtr = dlsym(mic_access, \"MicInitAdapter\");\n\tif (dlerror() != NULL)\n\t{\n\t\t\tstrncpy(_host_micpower_vector.cmp_info.disabled_reason, \"MicAccessSDK function MicInitAdapter not found.\",PAPI_MAX_STR_LEN);\n\t\t\t_host_micpower_vector.cmp_info.disabled = 1;\n\t\t\treturn ( PAPI_ENOSUPP );\n\t}\n\n\tMicGetPowerUsagePtr = dlsym(mic_access, \"MicGetPowerUsage\");\n\tif (dlerror() != NULL)\n\t{\n\t\t\tstrncpy(_host_micpower_vector.cmp_info.disabled_reason, \"MicAccessSDK function MicGetPowerUsage not found.\",PAPI_MAX_STR_LEN);\n\t\t\t_host_micpower_vector.cmp_info.disabled = 1;\n\t\t\treturn ( PAPI_ENOSUPP );\n\t}\n\n\treturn 0;\n}\n\n\n/* ###############################################\n * \t\t\tComponent Interface code \n * ############################################### */\n\n\nint \n_host_micpower_init_component( int cidx ) \n{\n\tU32 ret = MIC_ACCESS_API_ERROR_UNKNOWN;\n\tU32 adapterNum = 0;\n\tU32 throwaway = 1;\n\n\t_host_micpower_vector.cmp_info.CmpIdx = cidx;\n\n\tif ( loadFunctionPtrs() ) {\n\t\tgoto disable_me;\n\t}\n\n\tmemset( lastupdate, 0x0, sizeof(lastupdate));\n\tmemset( cached_values, 0x0, sizeof(struct powers)*MAX_DEVICES );\n\tret = MicInitAPIPtr( &accessHandle, eTARGET_SCIF_DRIVER, adapters, &nAdapters );\n\tif ( MIC_ACCESS_API_SUCCESS != ret ) {\n\t\tsnprintf( _host_micpower_vector.cmp_info.disabled_reason, PAPI_MAX_STR_LEN, \"Failed to init: %s\", MicGetErrorStringPtr(ret));\n\t\tMicCloseAPIPtr(&accessHandle);\n\t\tgoto disable_me;\n\t}\n\t/* Sanity check on array size */\n\tif ( nAdapters >= MAX_DEVICES ) {\n\t\tsnprintf(_host_micpower_vector.cmp_info.disabled_reason, PAPI_MAX_STR_LEN, \"Too many MIC cards [%d] found, bailing.\", nAdapters);\n\t\tMicCloseAPIPtr(&accessHandle);\n\t\tgoto disable_me;\n\t}\n\n/* XXX: This code initializes a token for each adapter, in testing this appeared to be required/\n *\tOne has to call MicInitAdapter() before calling into that adapter's entries */\n\tfor (adapterNum=0; adapterNum < nAdapters; adapterNum++) {\n\t\t\tret = MicInitAPIPtr( &handles[adapterNum], eTARGET_SCIF_DRIVER, adapters, &throwaway );\n\t\t\tthrowaway = 1;\n\t\t\tif (MIC_ACCESS_API_SUCCESS != ret) {\n\t\t\t\t\tfprintf(stderr, \"%d:MicInitAPI carps: %s\\n\", __LINE__, MicGetErrorStringPtr(ret));\n\t\t\t\t\tnAdapters = adapterNum;\n\t\t\t\t\tfor (adapterNum=0; adapterNum < nAdapters; adapterNum++)\n\t\t\t\t\t\t\tMicCloseAdapterPtr( handles[adapterNum] );\n\t\t\t\t\tMicCloseAPIPtr( &accessHandle );\n\t\t\t\t\tsnprintf(_host_micpower_vector.cmp_info.disabled_reason, PAPI_MAX_STR_LEN,\n\t\t\t\t\t\t\"Failed to initialize card %d's interface.\", nAdapters);\n\t\t\t\t\tgoto disable_me;\n\t\t\t}\n\t\t\tret = MicInitAdapterPtr(&handles[adapterNum], &adapters[adapterNum]);\n\t\t\tif (MIC_ACCESS_API_SUCCESS != ret) {\n\t\t\t\t\tfprintf(stderr, \"%d:MicInitAdapter carps: %s\\n\", __LINE__, MicGetErrorStringPtr(ret));\n\t\t\t\t\tnAdapters = adapterNum;\n\t\t\t\t\tfor (adapterNum=0; adapterNum < nAdapters; adapterNum++)\n\t\t\t\t\t\t\tMicCloseAdapterPtr( handles[adapterNum] );\n\t\t\t\t\tMicCloseAPIPtr( &accessHandle );\n\t\t\t\t\tsnprintf(_host_micpower_vector.cmp_info.disabled_reason, PAPI_MAX_STR_LEN,\n\t\t\t\t\t\t\"Failed to initialize card %d's interface.\", nAdapters);\n\t\t\t\t\tgoto disable_me;\n\t\t\t}\n\t}\n\n\tnative_events_table = ( host_micpower_native_event_entry_t*)papi_malloc( nAdapters * EVENTS_PER_DEVICE * sizeof(host_micpower_native_event_entry_t));\n\tif ( NULL == native_events_table ) {\n\t\treturn PAPI_ENOMEM;\n\t}\n\tfor (adapterNum=0; adapterNum < nAdapters; adapterNum++) {\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE].name, PAPI_MAX_STR_LEN, \"mic%d:tot0\", adapterNum);\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE].description, PAPI_MAX_STR_LEN, \"Total power utilization, Averaged over Time Window 0 (uWatts)\");\n\t\tnative_events_table[adapterNum*EVENTS_PER_DEVICE].resources.selector = adapterNum*EVENTS_PER_DEVICE + 1;\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE].units, PAPI_MIN_STR_LEN, \"uW\");\n\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 1].name, PAPI_MAX_STR_LEN, \"mic%d:tot1\", adapterNum);\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 1].description, PAPI_MAX_STR_LEN, \"Total power utilization, Averaged over Time Window 1 (uWatts)\");\n\t\tnative_events_table[adapterNum*EVENTS_PER_DEVICE + 1].resources.selector = adapterNum*EVENTS_PER_DEVICE + 2;\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 1].units, PAPI_MIN_STR_LEN, \"uW\");\n\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 2].name, PAPI_MAX_STR_LEN, \"mic%d:pcie\", adapterNum);\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 2].description, PAPI_MAX_STR_LEN, \"PCI-E connector power (uWatts)\");\n\t\tnative_events_table[adapterNum*EVENTS_PER_DEVICE + 2].resources.selector = adapterNum*EVENTS_PER_DEVICE + 3;\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 2].units, PAPI_MIN_STR_LEN, \"uW\");\n\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 3].name, PAPI_MAX_STR_LEN, \"mic%d:inst\", adapterNum);\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 3].description, PAPI_MAX_STR_LEN, \"Instantaneous power (uWatts)\");\n\t\tnative_events_table[adapterNum*EVENTS_PER_DEVICE + 3].resources.selector = adapterNum*EVENTS_PER_DEVICE + 4;\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 3].units, PAPI_MIN_STR_LEN, \"uW\");\n\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 4].name, PAPI_MAX_STR_LEN, \"mic%d:imax\", adapterNum);\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 4].description, PAPI_MAX_STR_LEN, \"Max instantaneous power (uWatts)\");\n\t\tnative_events_table[adapterNum*EVENTS_PER_DEVICE + 4].resources.selector = adapterNum*EVENTS_PER_DEVICE + 5;\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 4].units, PAPI_MIN_STR_LEN, \"uW\");\n\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 5].name, PAPI_MAX_STR_LEN, \"mic%d:c2x3\", adapterNum);\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 5].description, PAPI_MAX_STR_LEN, \"2x3 connector power (uWatts)\");\n\t\tnative_events_table[adapterNum*EVENTS_PER_DEVICE + 5].resources.selector = adapterNum*EVENTS_PER_DEVICE + 6;\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 5].units, PAPI_MIN_STR_LEN, \"uW\");\n\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 6].name, PAPI_MAX_STR_LEN, \"mic%d:c2x4\", adapterNum);\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 6].description, PAPI_MAX_STR_LEN, \"2x4 connector power (uWatts)\");\n\t\tnative_events_table[adapterNum*EVENTS_PER_DEVICE + 6].resources.selector = adapterNum*EVENTS_PER_DEVICE + 7;\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 6].units, PAPI_MIN_STR_LEN, \"uW\");\n\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 7].name, PAPI_MAX_STR_LEN, \"mic%d:vccp\", adapterNum);\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 7].description, PAPI_MAX_STR_LEN, \"Core rail (uVolts)\");\n\t\tnative_events_table[adapterNum*EVENTS_PER_DEVICE + 7].resources.selector = adapterNum*EVENTS_PER_DEVICE + 8;\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 7].units, PAPI_MIN_STR_LEN, \"uV\");\n\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 8].name, PAPI_MAX_STR_LEN, \"mic%d:vddg\", adapterNum);\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 8].description, PAPI_MAX_STR_LEN, \"Uncore rail (uVolts)\");\n\t\tnative_events_table[adapterNum*EVENTS_PER_DEVICE + 8].resources.selector = adapterNum*EVENTS_PER_DEVICE + 9;\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 8].units, PAPI_MIN_STR_LEN, \"uV\");\n\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 9].name, PAPI_MAX_STR_LEN, \"mic%d:vddq\", adapterNum);\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 9].description, PAPI_MAX_STR_LEN, \"Memory subsystem rail (uVolts)\");\n\t\tnative_events_table[adapterNum*EVENTS_PER_DEVICE + 9].resources.selector = adapterNum*EVENTS_PER_DEVICE + 10;\n        snprintf(native_events_table[adapterNum*EVENTS_PER_DEVICE + 9].units, PAPI_MIN_STR_LEN, \"uV\");\n\t}\n\n\t_host_micpower_vector.cmp_info.num_cntrs = EVENTS_PER_DEVICE*nAdapters;\n\t_host_micpower_vector.cmp_info.num_mpx_cntrs = EVENTS_PER_DEVICE*nAdapters;\n\n\t_host_micpower_vector.cmp_info.num_native_events = EVENTS_PER_DEVICE*nAdapters;\n\n\treturn PAPI_OK;\n\ndisable_me:\n\t_host_micpower_vector.cmp_info.num_cntrs = 0;\n\t_host_micpower_vector.cmp_info.num_mpx_cntrs = 0;\n\t_host_micpower_vector.cmp_info.num_native_events = 0;\n\t_host_micpower_vector.cmp_info.disabled = 1;\n\n\tnAdapters = 0;\n\treturn PAPI_ENOSUPP;\n}\n\nint _host_micpower_init_thread( hwd_context_t *ctx) {\n\t(void)ctx;\n\treturn PAPI_OK;\n}\n\nint\n_host_micpower_shutdown_component( void ) {\n\tU32 i = 0;\n\tfor( i=0; i<nAdapters; i++) {\n\t\tMicCloseAdapterPtr( handles[i] );\n\t}\n\n\tpapi_free(native_events_table);\n\treturn PAPI_OK;\n}\n\t\nint\n_host_micpower_shutdown_thread( hwd_context_t *ctx ) {\n    (void) ctx;\n\treturn PAPI_OK;\n}\n\nint _host_micpower_init_control_state ( hwd_control_state_t *ctl ) {\n\thost_micpower_control_state_t *state = (host_micpower_control_state_t*) ctl;\n\tmemset( state, 0, sizeof(host_micpower_control_state_t));\n\n\treturn PAPI_OK;\n}\n\nint _host_micpower_update_control_state(hwd_control_state_t *ctl, \n\t\t\t\t\t\t\t\t\t\tNativeInfo_t *info, \n\t\t\t\t\t\t\t\t\t\tint count,\n\t\t\t\t\t\t\t\t\t\thwd_context_t* ctx ) {\n\n\t(void) ctx;\n\tint i, index;\n\t\n\thost_micpower_control_state_t *state = (host_micpower_control_state_t*)ctl;\n\n\tfor (i=0; i<MAX_DEVICES*EVENTS_PER_DEVICE; i++)\n\t\tstate->resident[i] = 0;\n\n\tfor (i=0; i < count; i++) {\n\t\tindex = info[i].ni_event&PAPI_NATIVE_AND_MASK;\n\t\tinfo[i].ni_position=native_events_table[index].resources.selector-1;\n\t\tstate->resident[index] = 1;\n\t}\n\tstate->num_events = count;\n\n\treturn PAPI_OK;\n}\n\nint\n_host_micpower_start( hwd_context_t *ctx, hwd_control_state_t *ctl )\n{\n\t(void) ctx;\n\t(void) ctl;\n\treturn PAPI_OK;\n}\n\nstatic int \nread_power( struct powers *pwr, int which_one ) \n{\n\tMicPwrUsage power;\n\tU32 ret = MIC_ACCESS_API_ERROR_UNKNOWN;\n\n\tif ( which_one < 0 || which_one > (int)nAdapters )\n\t\treturn PAPI_ENOEVNT;\n\t\n\n\tret = MicGetPowerUsagePtr(handles[which_one], &power);\n\tif (MIC_ACCESS_API_SUCCESS != ret) {\n\t\t\tfprintf(stderr,\"Oops MicGetPowerUsage failed: %s\\n\", \n\t\t\t\t\t\t\tMicGetErrorStringPtr(ret));\n\t\t\treturn PAPI_ECMP;\n\t}\n\n\tpwr->total0 = power.total0.prr;\n\tpwr->total1 = power.total1.prr;\n\tpwr->inst = power.inst.prr;\n\tpwr->imax = power.imax.prr;\n\tpwr->pcie = power.pcie.prr;\n\tpwr->c2x3 = power.c2x3.prr;\n\tpwr->c2x4 = power.c2x4.prr;\n\tpwr->vccp = power.vccp.pwr;\n\tpwr->vddg = power.vddg.pwr;\n\tpwr->vddq = power.vddq.pwr;\n\n\treturn PAPI_OK;\n}\n\nint\n_host_micpower_read( hwd_context_t *ctx, hwd_control_state_t *ctl, \n\t\t\t\t\t long long **events, int flags) \n{\n\t(void)flags;\n\t(void)events;\n\t(void)ctx;\n\tunsigned int i,j;\n\tint needs_update = 0;\n\thost_micpower_control_state_t* control = (host_micpower_control_state_t*)ctl;\n\tlong long now = PAPI_get_real_usec();\n\n\tfor( i=0; i<nAdapters; i++) {\n\t\t\tneeds_update = 0;\n\t\t\tfor (j=0; j<EVENTS_PER_DEVICE; j++) {\n\t\t\t\tif ( control->resident[EVENTS_PER_DEVICE*i+j]) {\n\t\t\t\t\t\tneeds_update = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( needs_update ) {\n\t\t\t\t\t/* Do the global update */\n\t\t\t\t\tif ( now >= lastupdate[i] + UPDATEFREQ) {\n\t\t\t\t\t\t\tread_power( &cached_values[i].power, i );\n\t\t\t\t\t\t\tlastupdate[i] = now;\n\t\t\t\t\t}\n\t\t\t\t\t/* update from cached values */\n\t\t\t\t\tif ( control->lastupdate[i] < lastupdate[i]) {\n\t\t\t\t\t\t\tcontrol->lastupdate[i] = lastupdate[i];\n\t\t\t\t\t}\n\t\t\t\t\tfor (j=0; j<EVENTS_PER_DEVICE; j++) {\n\t\t\t\t\t\tif ( control->resident[EVENTS_PER_DEVICE*i+j] ) {\n\t\t\t\t\t\t\tcontrol->counts[EVENTS_PER_DEVICE*i+j] = (long long)cached_values[i].array[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\t}\n\n\t*events = control->counts;\n\treturn PAPI_OK;\n}\n\nint\n_host_micpower_stop( hwd_context_t *ctx, hwd_control_state_t *ctl )\n{\n\t(void)ctx;\n\tint needs_update = 0;\n\tunsigned int i,j;\n\thost_micpower_control_state_t* control = (host_micpower_control_state_t*)ctl;\n\tlong long now = PAPI_get_real_usec();\n\n\tfor( i=0; i<nAdapters; i++) {\n\t\t\tneeds_update = 0;\n\t\t\tfor (j=0; j<EVENTS_PER_DEVICE; j++) {\n\t\t\t\tif ( control->resident[EVENTS_PER_DEVICE*i+j]) {\n\t\t\t\t\t\tneeds_update = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( needs_update ) {\n\t\t\t\t\t/* Do the global update */\n\t\t\t\t\tif ( now >= lastupdate[i] + UPDATEFREQ) {\n\t\t\t\t\t\t\tread_power( &cached_values[i].power, i );\n\t\t\t\t\t\t\tlastupdate[i] = now;\n\t\t\t\t\t}\n\t\t\t\t\t/* update from cached values */\n\t\t\t\t\tif ( control->lastupdate[i] < lastupdate[i]) {\n\t\t\t\t\t\t\tcontrol->lastupdate[i] = lastupdate[i];\n\t\t\t\t\t}\n\t\t\t\t\tfor (j=0; j<EVENTS_PER_DEVICE; j++) {\n\t\t\t\t\t\tif ( control->resident[EVENTS_PER_DEVICE*i+j] ) {\n\t\t\t\t\t\t\tcontrol->counts[EVENTS_PER_DEVICE*i+j] = (long long)cached_values[i].array[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\t}\n\treturn PAPI_OK;\n\n}\n\nint _host_micpower_ntv_enum_events( unsigned int *EventCode, int modifier )\n{\n\tint index;\n\tswitch (modifier) {\n\t\tcase PAPI_ENUM_FIRST:\n\t\t\tif (0 == _host_micpower_vector.cmp_info.num_cntrs)\n\t\t\t\treturn PAPI_ENOEVNT;\n\t\t\t*EventCode = 0;\n\t\t\treturn PAPI_OK;\n\t\tcase PAPI_ENUM_EVENTS:\n\t\t\tindex = *EventCode;\n\t\t\tif ( index < _host_micpower_vector.cmp_info.num_cntrs - 1) {\n\t\t\t\t*EventCode = *EventCode + 1;\n\t\t\t\treturn PAPI_OK;\n\t\t\t} else {\n\t\t\t\treturn PAPI_ENOEVNT;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn PAPI_EINVAL;\n\t}\n\treturn PAPI_EINVAL;\n}\n\nint\n_host_micpower_ntv_code_to_name( unsigned int EventCode, char *name, int len )\n{\n\tunsigned int code = EventCode & PAPI_NATIVE_AND_MASK;\n\tif ( code < _host_micpower_vector.cmp_info.num_cntrs ) {\n\t\tstrncpy( name, native_events_table[code].name, len);\n\t\treturn PAPI_OK;\n\t}\n\n\treturn PAPI_ENOEVNT;\n}\n\nint\n_host_micpower_ntv_code_to_descr( unsigned int EventCode, char *name, int len )\n{\n\tunsigned int code = EventCode & PAPI_NATIVE_AND_MASK;\n\tif ( code < _host_micpower_vector.cmp_info.num_cntrs ) {\n\t\tstrncpy( name, native_events_table[code].description, len );\n\t\treturn PAPI_OK;\n\t}\n\n\treturn PAPI_ENOEVNT;\n}\n\nint\n_host_micpower_ntv_code_to_info( unsigned int EventCode, PAPI_event_info_t *info)\n{\n\tunsigned int code = EventCode & PAPI_NATIVE_AND_MASK;\n\tif ( code >= _host_micpower_vector.cmp_info.num_cntrs)\n\t\treturn PAPI_ENOEVNT;\n\tstrncpy( info->symbol, native_events_table[code].name, sizeof(info->symbol) );\n\tstrncpy( info->long_descr, native_events_table[code].description, sizeof(info->long_descr) );\n\tstrncpy( info->units, native_events_table[code].units, sizeof(info->units) );\n\treturn PAPI_OK;\n}\n\nint\n_host_micpower_ctl( hwd_context_t* ctx, int code, _papi_int_option_t *option)\n{\n\t(void)ctx;\n\t(void)code;\n\t(void)option;\n\treturn PAPI_OK;\n}\n\nint\n_host_micpower_set_domain( hwd_control_state_t* ctl, int domain)\n{\n\t(void)ctl;\n\tif ( PAPI_DOM_ALL != domain )\n\t    return PAPI_EINVAL;\n\treturn PAPI_OK;\n}\n\npapi_vector_t _host_micpower_vector = {\n\t.cmp_info = {\n\t\t.name = \"host_micpower\", \n\t\t.short_name = \"host_micpower\", \n\t\t.description = \"A host-side component to read power usage on MIC guest cards.\",\n\t\t.version = \"0.1\",\n\t\t.support_version = \"n/a\",\n\t\t.kernel_version = \"n/a\",\n\t\t.num_cntrs = 0,\n\t\t.num_mpx_cntrs = 0,\n\t\t.default_domain \t\t\t= PAPI_DOM_ALL,\n\t\t.available_domains \t\t\t= PAPI_DOM_ALL,\n\t\t.default_granularity \t\t= PAPI_GRN_SYS,\n\t\t.available_granularities \t= PAPI_GRN_SYS,\n\t\t.hardware_intr_sig \t\t\t= PAPI_INT_SIGNAL,\n\t}, \n\n\t.size  = {\n\t\t.context \t\t= sizeof(host_micpower_context_t), \n\t\t.control_state\t= sizeof(host_micpower_control_state_t),\n\t\t.reg_value\t\t= sizeof(host_micpower_register_t),\n\t\t.reg_alloc\t\t= sizeof(host_micpower_reg_alloc_t),\n\t},\n\n\t.start\t\t\t\t\t= _host_micpower_start,\n\t.stop\t\t\t\t\t= _host_micpower_start,\n\t.read\t\t\t\t\t= _host_micpower_read, \n\t.reset\t\t\t\t\t= NULL,\n\t.write\t\t\t\t\t= NULL,\n\t.init_component\t\t\t= _host_micpower_init_component,\n\t.init_thread\t\t\t= _host_micpower_init_thread,\n\t.init_control_state\t\t= _host_micpower_init_control_state,\n\t.update_control_state\t= _host_micpower_update_control_state,\n\t.ctl\t\t\t\t\t= _host_micpower_ctl, \n\t.shutdown_thread\t\t= _host_micpower_shutdown_thread,\n\t.shutdown_component\t\t= _host_micpower_shutdown_component,\n\t.set_domain\t\t\t\t= _host_micpower_set_domain,\n\n\t.ntv_enum_events\t\t= _host_micpower_ntv_enum_events, \n\t.ntv_code_to_name\t\t= _host_micpower_ntv_code_to_name,\n\t.ntv_code_to_descr\t\t= _host_micpower_ntv_code_to_descr,\n\t.ntv_code_to_info\t\t= _host_micpower_ntv_code_to_info,\n\n};\n",
        "/tmp/vanessa/spack-stage/spack-stage-papi-6.0.0.1-gmm3tef6bggycxgzrtmq2ejaggc2ozfb/spack-src/src/components/cuda/linux-cuda.c": "/**\n * @file    linux-cuda.c\n * @author  Tony Castaldo tonycastaldo@icl.utk.edu (updated in 2018, to use batch reads and support nvlink metrics.\n * @author  Asim YarKhan yarkhan@icl.utk.edu (updated in 2017 to support CUDA metrics)\n * @author  Asim YarKhan yarkhan@icl.utk.edu (updated in 2015 for multiple CUDA contexts/devices)\n * @author  Heike Jagode (First version, in collaboration with Robert Dietrich, TU Dresden) jagode@icl.utk.edu\n *\n * @ingroup papi_components\n *\n * @brief This implements a PAPI component that enables PAPI-C to\n *  access hardware monitoring counters for NVIDIA CUDA GPU devices\n *  through the CUPTI library.\n *\n * The open source software license for PAPI conforms to the BSD\n * License template.\n */\n\n//-----------------------------------------------------------------------------\n// A basic assumption here (and in other components) is that we put as much of\n// the computational load of this component into the initialization stage and\n// the \"adding\" stage for events (update_control), because users are likely not\n// measuring performance at those times, but may well be reading these events\n// when performance matters. So we want the read operation lightweight, but we\n// can remember tables and such at startup and when servicing a PAPI_add().\n//-----------------------------------------------------------------------------\n\n#include <dlfcn.h>\n#include <limits.h>\n\n// NOTE: We can't use extended directories; these include files have includes.\n#include <cupti.h>\n#include <cuda_runtime_api.h>\n\n#include \"papi.h\"\n#include \"papi_memory.h\"\n#include \"papi_internal.h\"\n#include \"papi_vector.h\"\n\n// We use a define so we can use it as a static array dimension. Increase as needed.\n#define PAPICUDA_MAX_COUNTERS 512\n\n// #define PAPICUDA_KERNEL_REPLAY_MODE\n// w to punctuate an embedded quoted question within a declarative sentence? [duplicate]\n\n// Contains device list, pointer to device description, and the list of all available events.\ntypedef struct cuda_context {\n    int         deviceCount;\n    struct cuda_device_desc *deviceArray;\n    uint32_t    availEventSize;\n    CUpti_ActivityKind *availEventKind;\n    int         *availEventDeviceNum;\n    uint32_t    *availEventIDArray;\n    uint32_t    *availEventIsBeingMeasuredInEventset;\n    struct cuda_name_desc *availEventDesc;\n} cuda_context_t;\n\n/* Store the name and description for an event */\ntypedef struct cuda_name_desc {\n    char        name[PAPI_MAX_STR_LEN];\n    char        description[PAPI_2MAX_STR_LEN];\n    uint16_t        numMetricEvents;        // 0=event, if a metric, size of metricEvents array below.\n    CUpti_EventID   *metricEvents;          // NULL for cuda events, an array of member events if a metric.\n    CUpti_MetricValueKind MV_Kind;          // eg. % or counter or rate, etc. Needed to compute metric from individual events.\n} cuda_name_desc_t;\n\n/* For a device, store device description */\ntypedef struct cuda_device_desc {\n    CUdevice    cuDev;\n    int         deviceNum;\n    char        deviceName[PAPI_MIN_STR_LEN];\n    uint32_t    maxDomains;                 /* number of domains per device */\n    CUpti_EventDomainID *domainIDArray;     /* Array[maxDomains] of domain IDs */\n    uint32_t    *domainIDNumEvents;         /* Array[maxDomains] of num of events in that domain */\n} cuda_device_desc_t;\n\n// For each active cuda context (one measuring something) we also track the\n// cuda device number it is on. We track in separate arrays for each reading\n// method.  cuda metrics and nvlink metrics require multiple events to be read,\n// these are then arithmetically combined to produce the metric value. The\n// allEvents array stores all the actual events; i.e. metrics are deconstructed\n// to their individual events and stored there, as well as regular events, so\n// we can perform an analysis of how to read with cuptiEventGroupSetsCreate().\n\ntypedef struct cuda_active_cucontext_s {\n    CUcontext cuCtx;\n    int deviceNum;\n\n    uint32_t      ctxActiveCount;                               // Count of entries in ctxActiveEvents.\n    uint32_t      ctxActiveEvents    [PAPICUDA_MAX_COUNTERS];   // index into gctrl->activeEventXXXX arrays, so we can store values.\n\n    uint32_t      allEventsCount;                               // entries in allEvents array.\n    CUpti_EventID allEvents          [PAPICUDA_MAX_COUNTERS];   // allEvents, including sub-events of metrics. (no metric Ids in here).\n    uint64_t      allEventValues     [PAPICUDA_MAX_COUNTERS];   // aggregated event values.\n\n    CUpti_EventGroupSets *eventGroupSets;                       // Built during add, to save time not doing it at read.\n} cuda_active_cucontext_t;\n\n// Control structure tracks array of active contexts and active events\n// in the order the user requested them; along with associated values\n// values and types (to save lookup time).\ntypedef struct cuda_control {\n    uint32_t    countOfActiveCUContexts;\n    cuda_active_cucontext_t *arrayOfActiveCUContexts[PAPICUDA_MAX_COUNTERS];\n    uint32_t    activeEventCount;\n    int         activeEventIndex            [PAPICUDA_MAX_COUNTERS];    // index into gctxt->availEventXXXXX arrays.\n    long long   activeEventValues           [PAPICUDA_MAX_COUNTERS];    // values we will return.\n    CUpti_MetricValueKind activeEventKind   [PAPICUDA_MAX_COUNTERS];    // For metrics: double, uint64, % or throughput. Needed to compute metric from individual events.\n    uint64_t    cuptiStartTimestampNs;                                  // needed to compute duration for some metrics.\n    uint64_t    cuptiReadTimestampNs;                                   // ..\n} cuda_control_t;\n\n// file handles used to access cuda libraries with dlopen\nstatic void *dl1 = NULL;\nstatic void *dl2 = NULL;\nstatic void *dl3 = NULL;\n\nstatic char cuda_main[]=PAPI_CUDA_MAIN;\nstatic char cuda_runtime[]=PAPI_CUDA_RUNTIME;\nstatic char cuda_cupti[]=PAPI_CUDA_CUPTI;\n\n/* The PAPI side (external) variable as a global */\npapi_vector_t _cuda_vector;\n\n/* Global variable for hardware description, event and metric lists */\nstatic cuda_context_t *global_cuda_context = NULL;\n\n/* This global variable points to the head of the control state list */\nstatic cuda_control_t *global_cuda_control = NULL;\n\n/* Macros for error checking... each arg is only referenced/evaluated once */\n#define CHECK_PRINT_EVAL( checkcond, str, evalthis )                        \\\n    do {                                                                    \\\n        int _cond = (checkcond);                                            \\\n        if (_cond) {                                                        \\\n            SUBDBG(\"error: condition %s failed: %s.\\n\", #checkcond, str);   \\\n            evalthis;                                                       \\\n        }                                                                   \\\n    } while (0)\n\n#define CUDA_CALL( call, handleerror )                                              \\\n    do {                                                                            \\\n        cudaError_t _status = (call);                                               \\\n        if (_status != cudaSuccess) {                                               \\\n            SUBDBG(\"error: function %s failed with error %d.\\n\", #call, _status);   \\\n            handleerror;                                                            \\\n        }                                                                           \\\n    } while (0)\n\n#define CU_CALL( call, handleerror )                                                \\\n    do {                                                                            \\\n        CUresult _status = (call);                                                  \\\n        if (_status != CUDA_SUCCESS) {                                              \\\n            SUBDBG(\"error: function %s failed with error %d.\\n\", #call, _status);   \\\n            /* fprintf(stderr,\"Line %i CU_CALL error function %s failed with error %08X.\\n\", __LINE__, #call, _status); */ \\\n            handleerror;                                                            \\\n        }                                                                           \\\n    } while (0)\n\n\n#define CUPTI_CALL(call, handleerror)                                                                       \\\n    do {                                                                                                    \\\n        CUptiResult _status = (call);                                                                       \\\n        if (_status != CUPTI_SUCCESS) {                                                                     \\\n            const char *errstr;                                                                             \\\n            (*cuptiGetResultStringPtr)(_status, &errstr);                                                   \\\n            SUBDBG(\"error: function %s failed with error %s.\\n\", #call, errstr);                            \\\n            /* fprintf(stderr, \"Line %i CUPTI_CALL macro '%s' failed with error #%08X='%s'.\\n\", __LINE__, #call, _status, errstr); */  \\\n            handleerror;                                                                                    \\\n        }                                                                                                   \\\n    } while (0)\n\n#define BUF_SIZE (32 * PATH_MAX)\n#define ALIGN_SIZE (8)\n#define ALIGN_BUFFER(buffer, align)                                                                                 \\\n  (((uintptr_t) (buffer) & ((align)-1)) ? ((buffer) + (align) - ((uintptr_t) (buffer) & ((align)-1))) : (buffer))\n\n/* Function prototypes */\nstatic int _cuda_cleanup_eventset(hwd_control_state_t * ctrl);\n\n/* ******  CHANGE PROTOTYPES TO DECLARE CUDA LIBRARY SYMBOLS AS WEAK  **********\n *  This is done so that a version of PAPI built with the cuda component can   *\n *  be installed on a system which does not have the cuda libraries installed. *\n *                                                                             *\n *  If this is done without these prototypes, then all papi services on the    *\n *  system without the cuda libraries installed will fail.  The PAPI libraries *\n *  contain references to the cuda libraries which are not installed.  The     *\n *  load of PAPI commands fails because the cuda library references can not be *\n *  resolved.                                                                  *\n *                                                                             *\n *  This also defines pointers to the cuda library functions that we call.     *\n *  These function pointers will be resolved with dlopen/dlsym calls at        *\n *  component initialization time.  The component then calls the cuda library  *\n *  functions through these function pointers.                                 *\n *******************************************************************************/\nvoid (*_dl_non_dynamic_init) (void) __attribute__ ((weak));\n\n#define CUAPIWEAK __attribute__( ( weak ) )\n#define DECLARECUFUNC(funcname, funcsig) CUresult CUAPIWEAK funcname funcsig;  CUresult( *funcname##Ptr ) funcsig;\nDECLARECUFUNC(cuCtxGetCurrent, (CUcontext *));\nDECLARECUFUNC(cuCtxSetCurrent, (CUcontext));\nDECLARECUFUNC(cuCtxDestroy, (CUcontext));\nDECLARECUFUNC(cuCtxCreate, (CUcontext *pctx, unsigned int flags, CUdevice dev));\nDECLARECUFUNC(cuDeviceGet, (CUdevice *, int));\nDECLARECUFUNC(cuDeviceGetCount, (int *));\nDECLARECUFUNC(cuDeviceGetName, (char *, int, CUdevice));\nDECLARECUFUNC(cuInit, (unsigned int));\nDECLARECUFUNC(cuGetErrorString, (CUresult error, const char** pStr));\nDECLARECUFUNC(cuCtxPopCurrent, (CUcontext * pctx));\nDECLARECUFUNC(cuCtxPushCurrent, (CUcontext pctx));\nDECLARECUFUNC(cuCtxSynchronize, ());\n\n#define CUDAAPIWEAK __attribute__( ( weak ) )\n#define DECLARECUDAFUNC(funcname, funcsig) cudaError_t CUDAAPIWEAK funcname funcsig;  cudaError_t( *funcname##Ptr ) funcsig;\nDECLARECUDAFUNC(cudaGetDevice, (int *));\nDECLARECUDAFUNC(cudaSetDevice, (int));\nDECLARECUDAFUNC(cudaFree, (void *));\n\n#define CUPTIAPIWEAK __attribute__( ( weak ) )\n#define DECLARECUPTIFUNC(funcname, funcsig) CUptiResult CUPTIAPIWEAK funcname funcsig;  CUptiResult( *funcname##Ptr ) funcsig;\n/* CUptiResult CUPTIAPIWEAK cuptiDeviceEnumEventDomains( CUdevice, size_t *, CUpti_EventDomainID * ); */\n/* CUptiResult( *cuptiDeviceEnumEventDomainsPtr )( CUdevice, size_t *, CUpti_EventDomainID * ); */\nDECLARECUPTIFUNC(cuptiDeviceEnumMetrics, (CUdevice device, size_t * arraySizeBytes, CUpti_MetricID * metricArray));\nDECLARECUPTIFUNC(cuptiDeviceGetEventDomainAttribute, (CUdevice device, CUpti_EventDomainID eventDomain, CUpti_EventDomainAttribute attrib, size_t * valueSize, void *value));\nDECLARECUPTIFUNC(cuptiDeviceGetNumMetrics, (CUdevice device, uint32_t * numMetrics));\nDECLARECUPTIFUNC(cuptiEventGroupGetAttribute, (CUpti_EventGroup eventGroup, CUpti_EventGroupAttribute attrib, size_t * valueSize, void *value));\nDECLARECUPTIFUNC(cuptiEventGroupReadEvent, (CUpti_EventGroup eventGroup, CUpti_ReadEventFlags flags, CUpti_EventID event, size_t * eventValueBufferSizeBytes, uint64_t * eventValueBuffer));\nDECLARECUPTIFUNC(cuptiEventGroupSetAttribute, (CUpti_EventGroup eventGroup, CUpti_EventGroupAttribute attrib, size_t valueSize, void *value));\nDECLARECUPTIFUNC(cuptiEventGroupSetDisable, (CUpti_EventGroupSet * eventGroupSet));\nDECLARECUPTIFUNC(cuptiEventGroupSetEnable, (CUpti_EventGroupSet * eventGroupSet));\nDECLARECUPTIFUNC(cuptiEventGroupSetsCreate, (CUcontext context, size_t eventIdArraySizeBytes, CUpti_EventID * eventIdArray, CUpti_EventGroupSets ** eventGroupPasses));\nDECLARECUPTIFUNC(cuptiMetricCreateEventGroupSets, (CUcontext context, size_t metricIdArraySizeBytes, CUpti_MetricID * metricIdArray, CUpti_EventGroupSets ** eventGroupPasses));\nDECLARECUPTIFUNC(cuptiEventGroupSetsDestroy, (CUpti_EventGroupSets * eventGroupSets));\nDECLARECUPTIFUNC(cuptiMetricGetRequiredEventGroupSets, (CUcontext ctx, CUpti_MetricID metricId, CUpti_EventGroupSets **thisEventGroupSet));\nDECLARECUPTIFUNC(cuptiGetTimestamp, (uint64_t * timestamp));\nDECLARECUPTIFUNC(cuptiMetricEnumEvents, (CUpti_MetricID metric, size_t * eventIdArraySizeBytes, CUpti_EventID * eventIdArray));\nDECLARECUPTIFUNC(cuptiMetricGetAttribute, (CUpti_MetricID metric, CUpti_MetricAttribute attrib, size_t * valueSize, void *value));\nDECLARECUPTIFUNC(cuptiMetricGetNumEvents, (CUpti_MetricID metric, uint32_t * numEvents));\nDECLARECUPTIFUNC(cuptiMetricGetValue, (CUdevice device, CUpti_MetricID metric, size_t eventIdArraySizeBytes, CUpti_EventID * eventIdArray, size_t eventValueArraySizeBytes, uint64_t * eventValueArray, uint64_t timeDuration, CUpti_MetricValue * metricValue));\nDECLARECUPTIFUNC(cuptiSetEventCollectionMode, (CUcontext context, CUpti_EventCollectionMode mode));\nDECLARECUPTIFUNC(cuptiDeviceEnumEventDomains, (CUdevice, size_t *, CUpti_EventDomainID *));\nDECLARECUPTIFUNC(cuptiDeviceGetNumEventDomains, (CUdevice, uint32_t *));\nDECLARECUPTIFUNC(cuptiEventDomainEnumEvents, (CUpti_EventDomainID, size_t *, CUpti_EventID *));\nDECLARECUPTIFUNC(cuptiEventDomainGetAttribute, (CUpti_EventDomainID eventDomain, CUpti_EventDomainAttribute attrib, size_t * valueSize, void *value));\nDECLARECUPTIFUNC(cuptiEventDomainGetNumEvents, (CUpti_EventDomainID, uint32_t *));\nDECLARECUPTIFUNC(cuptiEventGetAttribute, (CUpti_EventID, CUpti_EventAttribute, size_t *, void *));\nDECLARECUPTIFUNC(cuptiEventGroupAddEvent, (CUpti_EventGroup, CUpti_EventID));\nDECLARECUPTIFUNC(cuptiEventGroupCreate, (CUcontext, CUpti_EventGroup *, uint32_t));\nDECLARECUPTIFUNC(cuptiEventGroupDestroy, (CUpti_EventGroup));\nDECLARECUPTIFUNC(cuptiEventGroupDisable, (CUpti_EventGroup));\nDECLARECUPTIFUNC(cuptiEventGroupEnable, (CUpti_EventGroup));\nDECLARECUPTIFUNC(cuptiEventGroupReadAllEvents, (CUpti_EventGroup, CUpti_ReadEventFlags, size_t *, uint64_t *, size_t *, CUpti_EventID *, size_t *));\nDECLARECUPTIFUNC(cuptiEventGroupResetAllEvents, (CUpti_EventGroup));\nDECLARECUPTIFUNC(cuptiGetResultString, (CUptiResult result, const char **str));\nDECLARECUPTIFUNC(cuptiEnableKernelReplayMode, ( CUcontext context ));\nDECLARECUPTIFUNC(cuptiDisableKernelReplayMode, ( CUcontext context ));\n\n\n/*****************************************************************************\n ********  BEGIN FUNCTIONS USED INTERNALLY SPECIFIC TO THIS COMPONENT *********\n *****************************************************************************/\n\n/*\n * Link the necessary CUDA libraries to use the cuda component.  If any of them can not be found, then\n * the CUDA component will just be disabled.  This is done at runtime so that a version of PAPI built\n * with the CUDA component can be installed and used on systems which have the CUDA libraries installed\n * and on systems where these libraries are not installed.\n */\nstatic int _cuda_linkCudaLibraries(void)\n{\n    char path_lib[PATH_MAX];\n#define DLSYM_AND_CHECK( dllib, name ) dlsym( dllib, name );                \\\n    if ( dlerror()!=NULL ) {                                                \\\n        snprintf(_cuda_vector.cmp_info.disabled_reason, PAPI_MAX_STR_LEN,   \\\n        \"A CUDA required function '%s' was not found in lib '%s'.\",         \\\n        name, #dllib);                                                      \\\n        return ( PAPI_ENOSUPP );                                            \\\n    }\n\n    /* Attempt to guess if we were statically linked to libc, if so bail */\n    if(_dl_non_dynamic_init != NULL) {\n        strncpy(_cuda_vector.cmp_info.disabled_reason, \"The CUDA component does not support statically linking to libc.\", PAPI_MAX_STR_LEN);\n        return PAPI_ENOSUPP;\n    }\n    // Need to link in the cuda libraries, if any not found disable the component\n    // getenv returns NULL if environment variable is not found.\n    char *cuda_root = getenv(\"PAPI_CUDA_ROOT\");\n\n    dl1 = NULL;                                                 // Ensure reset to NULL.\n\n    // Step 1: Process override if given.\n    if (strlen(cuda_main) > 0) {                                // If override given, it has to work.\n        dl1 = dlopen(cuda_main, RTLD_NOW | RTLD_GLOBAL);        // Try to open that path.\n        if (dl1 == NULL) {\n            snprintf(_cuda_vector.cmp_info.disabled_reason, PAPI_MAX_STR_LEN, \"PAPI_CUDA_MAIN override '%s' given in Rules.cuda not found.\", cuda_main);\n            return(PAPI_ENOSUPP);   // Override given but not found.\n        }\n    }\n\n    // Step 2: Try system paths, will work with Spack, LD_LIBRARY_PATH, default paths.\n    if (dl1 == NULL) {                                          // No override,\n        dl1 = dlopen(\"libcuda.so\", RTLD_NOW | RTLD_GLOBAL);     // Try system paths.\n    }\n\n    // Step 3: Try the explicit install default.\n    if (dl1 == NULL && cuda_root != NULL) {                          // if root given, try it.\n        snprintf(path_lib, sizeof(path_lib), \"%s/lib64/libcuda.so\", cuda_root);  // PAPI Root check.\n        dl1 = dlopen(path_lib, RTLD_NOW | RTLD_GLOBAL);              // Try to open that path.\n    }\n\n    // Check for failure.\n    if (dl1 == NULL) {\n        snprintf(_cuda_vector.cmp_info.disabled_reason, PAPI_MAX_STR_LEN, \"libcuda.so not found.\");\n        return(PAPI_ENOSUPP);\n    }\n\n    // We have a dl1. (libcuda.so).\n\n    cuCtxGetCurrentPtr = DLSYM_AND_CHECK(dl1, \"cuCtxGetCurrent\");\n    cuCtxSetCurrentPtr = DLSYM_AND_CHECK(dl1, \"cuCtxSetCurrent\");\n    cuDeviceGetPtr = DLSYM_AND_CHECK(dl1, \"cuDeviceGet\");\n    cuDeviceGetCountPtr = DLSYM_AND_CHECK(dl1, \"cuDeviceGetCount\");\n    cuDeviceGetNamePtr = DLSYM_AND_CHECK(dl1, \"cuDeviceGetName\");\n    cuInitPtr = DLSYM_AND_CHECK(dl1, \"cuInit\");\n    cuGetErrorStringPtr = DLSYM_AND_CHECK(dl1, \"cuGetErrorString\");\n    cuCtxPopCurrentPtr = DLSYM_AND_CHECK(dl1, \"cuCtxPopCurrent\");\n    cuCtxPushCurrentPtr = DLSYM_AND_CHECK(dl1, \"cuCtxPushCurrent\");\n    cuCtxDestroyPtr = DLSYM_AND_CHECK(dl1, \"cuCtxDestroy\");\n    cuCtxCreatePtr  = DLSYM_AND_CHECK(dl1, \"cuCtxCreate\");\n    cuCtxSynchronizePtr = DLSYM_AND_CHECK(dl1, \"cuCtxSynchronize\");\n\n    /* Need to link in the cuda runtime library, if not found disable the component */\n    dl2 = NULL;                                 // Ensure reset to NULL.\n\n    // Step 1: Process override if given.\n    if (strlen(cuda_runtime) > 0) {                                // If override given, it has to work.\n        dl2 = dlopen(cuda_runtime, RTLD_NOW | RTLD_GLOBAL);        // Try to open that path.\n        if (dl2 == NULL) {\n            snprintf(_cuda_vector.cmp_info.disabled_reason, PAPI_MAX_STR_LEN, \"PAPI_CUDA_RUNTIME override '%s' given in Rules.cuda not found.\", cuda_runtime);\n            return(PAPI_ENOSUPP);   // Override given but not found.\n        }\n    }\n\n    // Step 2: Try system paths, will work with Spack, LD_LIBRARY_PATH, default paths.\n    if (dl2 == NULL) {                                          // No override,\n        dl2 = dlopen(\"libcudart.so\", RTLD_NOW | RTLD_GLOBAL);   // Try system paths.\n    }\n\n    // Step 3: Try the explicit install default.\n    if (dl2 == NULL && cuda_root != NULL) {                             // if root given, try it.\n        snprintf(path_lib, sizeof(path_lib), \"%s/lib64/libcudart.so\", cuda_root);   // PAPI Root check.\n        dl2 = dlopen(path_lib, RTLD_NOW | RTLD_GLOBAL);                 // Try to open that path.\n    }\n\n    // Check for failure.\n    if (dl2 == NULL) {\n        snprintf(_cuda_vector.cmp_info.disabled_reason, PAPI_MAX_STR_LEN, \"libcudart.so not found.\");\n        return(PAPI_ENOSUPP);\n    }\n\n    // We have a dl2. (libcudart.so).\n\n    cudaGetDevicePtr = DLSYM_AND_CHECK(dl2, \"cudaGetDevice\");\n    cudaSetDevicePtr = DLSYM_AND_CHECK(dl2, \"cudaSetDevice\");\n    cudaFreePtr = DLSYM_AND_CHECK(dl2, \"cudaFree\");\n\n    dl3 = NULL;                                                 // Ensure reset to NULL.\n\n    // Step 1: Process override if given.\n    if (strlen(cuda_cupti) > 0) {                                       // If override given, it MUST work.\n        dl3 = dlopen(cuda_cupti, RTLD_NOW | RTLD_GLOBAL);               // Try to open that path.\n        if (dl3 == NULL) {\n            snprintf(_cuda_vector.cmp_info.disabled_reason, PAPI_MAX_STR_LEN, \"PAPI_CUDA_CUPTI override '%s' given in Rules.cuda not found.\", cuda_cupti);\n            return(PAPI_ENOSUPP);   // Override given but not found.\n        }\n    }\n\n    // Step 2: Try system paths, will work with Spack, LD_LIBRARY_PATH, default paths.\n    if (dl3 == NULL) {                                          // If no override,\n        dl3 = dlopen(\"libcupti.so\", RTLD_NOW | RTLD_GLOBAL);    // Try system paths.\n    }\n\n    // Step 3: Try the explicit install default.\n    if (dl3 == NULL && cuda_root != NULL) {                                         // If ROOT given, it doesn't HAVE to work.\n        snprintf(path_lib, sizeof(path_lib), \"%s/extras/CUPTI/lib64/libcupti.so\", cuda_root);   // PAPI Root check.\n        dl3 = dlopen(path_lib, RTLD_NOW | RTLD_GLOBAL);                             // Try to open that path.\n    }\n\n    // Check for failure.\n    if (dl3 == NULL) {\n        snprintf(_cuda_vector.cmp_info.disabled_reason, PAPI_MAX_STR_LEN, \"libcupti.so not found.\");\n        return(PAPI_ENOSUPP);   // Not found on default paths.\n    }\n\n    // We have a dl3. (libcupti.so)\n\n    /* The macro DLSYM_AND_CHECK results in the expansion example below */\n    /* cuptiDeviceEnumEventDomainsPtr = dlsym( dl3, \"cuptiDeviceEnumEventDomains\" ); */\n    /* if ( dlerror()!=NULL ) { strncpy( _cuda_vector.cmp_info.disabled_reason, \"A CUDA required function was not found in dynamic libs\", PAPI_MAX_STR_LEN ); return ( PAPI_ENOSUPP ); } */\n    cuptiDeviceEnumMetricsPtr = DLSYM_AND_CHECK(dl3, \"cuptiDeviceEnumMetrics\");\n    cuptiDeviceGetEventDomainAttributePtr = DLSYM_AND_CHECK(dl3, \"cuptiDeviceGetEventDomainAttribute\");\n    cuptiDeviceGetNumMetricsPtr = DLSYM_AND_CHECK(dl3, \"cuptiDeviceGetNumMetrics\");\n    cuptiEventGroupGetAttributePtr = DLSYM_AND_CHECK(dl3, \"cuptiEventGroupGetAttribute\");\n    cuptiEventGroupReadEventPtr = DLSYM_AND_CHECK(dl3, \"cuptiEventGroupReadEvent\");\n    cuptiEventGroupSetAttributePtr = DLSYM_AND_CHECK(dl3, \"cuptiEventGroupSetAttribute\");\n    cuptiMetricGetRequiredEventGroupSetsPtr = DLSYM_AND_CHECK(dl3, \"cuptiMetricGetRequiredEventGroupSets\");\n    cuptiEventGroupSetDisablePtr = DLSYM_AND_CHECK(dl3, \"cuptiEventGroupSetDisable\");\n    cuptiEventGroupSetEnablePtr = DLSYM_AND_CHECK(dl3, \"cuptiEventGroupSetEnable\");\n    cuptiEventGroupSetsCreatePtr = DLSYM_AND_CHECK(dl3, \"cuptiEventGroupSetsCreate\");\n    cuptiEventGroupSetsDestroyPtr = DLSYM_AND_CHECK(dl3, \"cuptiEventGroupSetsDestroy\");\n    cuptiGetTimestampPtr = DLSYM_AND_CHECK(dl3, \"cuptiGetTimestamp\");\n    cuptiMetricEnumEventsPtr = DLSYM_AND_CHECK(dl3, \"cuptiMetricEnumEvents\");\n    cuptiMetricGetAttributePtr = DLSYM_AND_CHECK(dl3, \"cuptiMetricGetAttribute\");\n    cuptiMetricGetNumEventsPtr = DLSYM_AND_CHECK(dl3, \"cuptiMetricGetNumEvents\");\n    cuptiMetricGetValuePtr = DLSYM_AND_CHECK(dl3, \"cuptiMetricGetValue\");\n    cuptiMetricCreateEventGroupSetsPtr = DLSYM_AND_CHECK(dl3, \"cuptiMetricCreateEventGroupSets\");\n    cuptiSetEventCollectionModePtr = DLSYM_AND_CHECK(dl3, \"cuptiSetEventCollectionMode\");\n    cuptiDeviceEnumEventDomainsPtr = DLSYM_AND_CHECK(dl3, \"cuptiDeviceEnumEventDomains\");\n    cuptiDeviceGetNumEventDomainsPtr = DLSYM_AND_CHECK(dl3, \"cuptiDeviceGetNumEventDomains\");\n    cuptiEventDomainEnumEventsPtr = DLSYM_AND_CHECK(dl3, \"cuptiEventDomainEnumEvents\");\n    cuptiEventDomainGetAttributePtr = DLSYM_AND_CHECK(dl3, \"cuptiEventDomainGetAttribute\");\n    cuptiEventDomainGetNumEventsPtr = DLSYM_AND_CHECK(dl3, \"cuptiEventDomainGetNumEvents\");\n    cuptiEventGetAttributePtr = DLSYM_AND_CHECK(dl3, \"cuptiEventGetAttribute\");\n    cuptiEventGroupAddEventPtr = DLSYM_AND_CHECK(dl3, \"cuptiEventGroupAddEvent\");\n    cuptiEventGroupCreatePtr = DLSYM_AND_CHECK(dl3, \"cuptiEventGroupCreate\");\n    cuptiEventGroupDestroyPtr = DLSYM_AND_CHECK(dl3, \"cuptiEventGroupDestroy\");\n    cuptiEventGroupDisablePtr = DLSYM_AND_CHECK(dl3, \"cuptiEventGroupDisable\");\n    cuptiEventGroupEnablePtr = DLSYM_AND_CHECK(dl3, \"cuptiEventGroupEnable\");\n    cuptiEventGroupReadAllEventsPtr = DLSYM_AND_CHECK(dl3, \"cuptiEventGroupReadAllEvents\");\n    cuptiEventGroupResetAllEventsPtr = DLSYM_AND_CHECK(dl3, \"cuptiEventGroupResetAllEvents\");\n    cuptiGetResultStringPtr = DLSYM_AND_CHECK(dl3, \"cuptiGetResultString\");\n    cuptiEnableKernelReplayModePtr = DLSYM_AND_CHECK(dl3, \"cuptiEnableKernelReplayMode\");\n    cuptiDisableKernelReplayModePtr = DLSYM_AND_CHECK(dl3, \"cuptiEnableKernelReplayMode\");\n    return (PAPI_OK);\n}\n\n\nstatic int _cuda_add_native_events(cuda_context_t * gctxt)\n{\n    SUBDBG(\"Entering\\n\");\n    CUresult cuErr;\n    int deviceNum;\n    uint32_t domainNum, eventNum;\n    cuda_device_desc_t *mydevice;\n    char tmpStr[PAPI_MIN_STR_LEN];\n    tmpStr[PAPI_MIN_STR_LEN - 1] = '\\0';\n    size_t tmpSizeBytes;\n    int ii;\n    uint32_t maxEventSize;\n\n    /* How many CUDA devices do we have? */\n    cuErr = (*cuDeviceGetCountPtr) (&gctxt->deviceCount);\n    if(cuErr == CUDA_ERROR_NOT_INITIALIZED) {\n        /* If CUDA not initialized, initialize CUDA and retry the device list */\n        /* This is required for some of the PAPI tools, that do not call the init functions */\n        cuErr = (cuInitPtr) (0); // Try the init.\n        if(cuErr != CUDA_SUCCESS) {     // If that failed, we are bailing.\n            const char *errString=NULL;\n            (*cuGetErrorStringPtr) (cuErr, &errString); // Read the string.\n            if (errString != NULL) {\n                    snprintf(_cuda_vector.cmp_info.disabled_reason, PAPI_MAX_STR_LEN-2,\n                    \"CUDA initialization (cuInit) failed: %s\", errString);\n                    _cuda_vector.cmp_info.disabled_reason[PAPI_MAX_STR_LEN-1]=0;    // force null termination.\n            } else {\n                    snprintf(_cuda_vector.cmp_info.disabled_reason, PAPI_MAX_STR_LEN-2,\n                    \"CUDA initialization (cuInit) failed: Unrecognized Error Code=%d.\", cuErr);\n                    _cuda_vector.cmp_info.disabled_reason[PAPI_MAX_STR_LEN-1]=0;    // force null termination.\n            } // end dealing with error on cuInit(0).\n            return PAPI_ENOSUPP;\n        } // end if cuInit(0) failed.\n\n        CU_CALL((*cuDeviceGetCountPtr) (&gctxt->deviceCount), return (PAPI_EMISC)); // repeat call for device count.\n    } // end if CUDA was not initialized; try to init.\n\n    // cuInit(0) was successful.\n    if(gctxt->deviceCount == 0) {\n        strncpy(_cuda_vector.cmp_info.disabled_reason, \"CUDA initialized but no CUDA devices found.\", PAPI_MAX_STR_LEN);\n        return PAPI_ENOSUPP;\n    }\n    SUBDBG(\"Found %d devices\\n\", gctxt->deviceCount);\n\n    /* allocate memory for device information */\n    gctxt->deviceArray = (cuda_device_desc_t *) papi_calloc(gctxt->deviceCount, sizeof(cuda_device_desc_t));\n    CHECK_PRINT_EVAL(!gctxt->deviceArray, \"ERROR CUDA: Could not allocate memory for CUDA device structure\", return (PAPI_ENOMEM));\n\n    /* For each device, get domains and domain-events counts */\n    maxEventSize = 0;\n    for(deviceNum = 0; deviceNum < gctxt->deviceCount; deviceNum++) {\n        mydevice = &gctxt->deviceArray[deviceNum];\n        /* Get device id, name, numeventdomains for each device */\n        CU_CALL((*cuDeviceGetPtr) (&mydevice->cuDev, deviceNum),                // get CUdevice.\n            return (PAPI_EMISC));                                               // .. on failure.\n\n        CU_CALL((*cuDeviceGetNamePtr) (mydevice->deviceName,                    // get device name,\n            PAPI_MIN_STR_LEN - 1, mydevice->cuDev),                             // .. max length,\n            return (PAPI_EMISC));                                               // .. on failure.\n\n        mydevice->deviceName[PAPI_MIN_STR_LEN - 1] = '\\0';                      // z-terminate it.\n\n        CUPTI_CALL((*cuptiDeviceGetNumEventDomainsPtr)                          // get number of domains,\n            (mydevice->cuDev, &mydevice->maxDomains),\n            return (PAPI_EMISC));                                               // .. on failure.\n\n        /* Allocate space to hold domain IDs */\n        mydevice->domainIDArray = (CUpti_EventDomainID *) papi_calloc(\n            mydevice->maxDomains, sizeof(CUpti_EventDomainID));\n\n        CHECK_PRINT_EVAL(!mydevice->domainIDArray, \"ERROR CUDA: Could not allocate memory for CUDA device domains\", return (PAPI_ENOMEM));\n\n        /* Put domain ids into allocated space */\n        size_t domainarraysize = mydevice->maxDomains * sizeof(CUpti_EventDomainID);\n        CUPTI_CALL((*cuptiDeviceEnumEventDomainsPtr)                            // enumerate domain ids into space.\n            (mydevice->cuDev, &domainarraysize, mydevice->domainIDArray),\n            return (PAPI_EMISC));                                               // .. on failure.\n\n        /* Allocate space to hold domain event counts */\n        mydevice->domainIDNumEvents = (uint32_t *) papi_calloc(mydevice->maxDomains, sizeof(uint32_t));\n        CHECK_PRINT_EVAL(!mydevice->domainIDNumEvents, \"ERROR CUDA: Could not allocate memory for domain event counts\", return (PAPI_ENOMEM));\n\n        /* For each domain, get event counts in domainNumEvents[] */\n        for(domainNum = 0; domainNum < mydevice->maxDomains; domainNum++) {     // For each domain,\n            CUpti_EventDomainID domainID = mydevice->domainIDArray[domainNum];  // .. make a copy of the domain ID.\n            /* Get num events in domain */\n            CUPTI_CALL((*cuptiEventDomainGetNumEventsPtr)                       // Get number of events in this domain,\n                (domainID, &mydevice->domainIDNumEvents[domainNum]),            // .. store in array.\n                return (PAPI_EMISC));                                           // .. on failure.\n\n            maxEventSize += mydevice->domainIDNumEvents[domainNum];             // keep track of overall number of events.\n        } // end for each domain.\n    } // end of for each device.\n\n    // Increase maxEventSize for metrics on this device.\n    for(deviceNum = 0; deviceNum < gctxt->deviceCount; deviceNum++) {               // for each device,\n        uint32_t maxMetrics = 0;\n        CUptiResult cuptiRet;\n        mydevice = &gctxt->deviceArray[deviceNum];                                  // Get cuda_device_desc pointer.\n        cuptiRet = (*cuptiDeviceGetNumMetricsPtr) (mydevice->cuDev, &maxMetrics);   // Read the # metrics on this device.\n        if (cuptiRet != CUPTI_SUCCESS || maxMetrics < 1) continue;                  // If no metrics, skip to next device.\n        maxEventSize += maxMetrics;                                                 // make room for metrics we discover later.\n    } // end for each device.\n\n    /* Allocate space for all events and descriptors */\n    gctxt->availEventKind = (CUpti_ActivityKind *) papi_calloc(maxEventSize, sizeof(CUpti_ActivityKind));\n    CHECK_PRINT_EVAL(!gctxt->availEventKind, \"ERROR CUDA: Could not allocate memory\", return (PAPI_ENOMEM));\n    gctxt->availEventDeviceNum = (int *) papi_calloc(maxEventSize, sizeof(int));\n    CHECK_PRINT_EVAL(!gctxt->availEventDeviceNum, \"ERROR CUDA: Could not allocate memory\", return (PAPI_ENOMEM));\n    gctxt->availEventIDArray = (CUpti_EventID *) papi_calloc(maxEventSize, sizeof(CUpti_EventID));\n    CHECK_PRINT_EVAL(!gctxt->availEventIDArray, \"ERROR CUDA: Could not allocate memory\", return (PAPI_ENOMEM));\n    gctxt->availEventIsBeingMeasuredInEventset = (uint32_t *) papi_calloc(maxEventSize, sizeof(uint32_t));\n    CHECK_PRINT_EVAL(!gctxt->availEventIsBeingMeasuredInEventset, \"ERROR CUDA: Could not allocate memory\", return (PAPI_ENOMEM));\n    gctxt->availEventDesc = (cuda_name_desc_t *) papi_calloc(maxEventSize, sizeof(cuda_name_desc_t));\n    CHECK_PRINT_EVAL(!gctxt->availEventDesc, \"ERROR CUDA: Could not allocate memory\", return (PAPI_ENOMEM));\n\n    // Record all events on each device, and their descriptions.\n    uint32_t idxEventArray = 0;\n    for(deviceNum = 0; deviceNum < gctxt->deviceCount; deviceNum++) {           // loop through each device.\n        mydevice = &gctxt->deviceArray[deviceNum];                              // get a pointer to the cuda_device_desc struct.\n\n        // For each domain, get and store event IDs, names, descriptions.\n        for(domainNum = 0; domainNum < mydevice->maxDomains; domainNum++) {         // loop through the domains in this device.\n\n            /* Get domain id */\n            CUpti_EventDomainID domainID = mydevice->domainIDArray[domainNum];      // get the domain id,\n            uint32_t domainNumEvents = mydevice->domainIDNumEvents[domainNum];      // get the number of events in it.\n\n            // SUBDBG( \"For device %d domain %d domainID %d numEvents %d\\n\", mydevice->cuDev, domainNum, domainID, domainNumEvents );\n\n            CUpti_EventID *domainEventIDArray =                                         // Make space for the events in this domain.\n                (CUpti_EventID *) papi_calloc(domainNumEvents, sizeof(CUpti_EventID));  // ..\n            CHECK_PRINT_EVAL(!domainEventIDArray, \"ERROR CUDA: Could not allocate memory for events\", return (PAPI_ENOMEM));\n\n            size_t domainEventArraySize = domainNumEvents * sizeof(CUpti_EventID);      // compute size of array we allocated.\n            CUPTI_CALL((*cuptiEventDomainEnumEventsPtr)                                 // Enumerate the events in the domain,\n                (domainID, &domainEventArraySize, domainEventIDArray),                  // ..\n                return (PAPI_EMISC));                                                   // .. on failure, exit.\n\n            for(eventNum = 0; eventNum < domainNumEvents; eventNum++) {                 // Loop through the events in this domain.\n                CUpti_EventID myeventCuptiEventId = domainEventIDArray[eventNum];       // .. get this event,\n                gctxt->availEventKind[idxEventArray] = CUPTI_ACTIVITY_KIND_EVENT;       // .. record the kind,\n                gctxt->availEventIDArray[idxEventArray] = myeventCuptiEventId;          // .. record the id,\n                gctxt->availEventDeviceNum[idxEventArray] = deviceNum;                  // .. record the device number,\n\n                tmpSizeBytes = PAPI_MAX_STR_LEN - 1 * sizeof(char);                     // .. compute size of name,\n                CUPTI_CALL((*cuptiEventGetAttributePtr) (myeventCuptiEventId,           // .. Get the event name seen by cupti,\n                    CUPTI_EVENT_ATTR_NAME, &tmpSizeBytes, tmpStr),                      // .. into tmpStr.\n                    return (PAPI_EMISC));                                               // .. on failure, exit routine.\n\n                snprintf(gctxt->availEventDesc[idxEventArray].name, PAPI_MAX_STR_LEN,   // record expanded name for papi user.\n                    \"event:%s:device=%d\", tmpStr, deviceNum);\n                gctxt->availEventDesc[idxEventArray].name[PAPI_MAX_STR_LEN - 1] = '\\0'; // ensure null termination.\n                char *nameTmpPtr = gctxt->availEventDesc[idxEventArray].name;           // For looping, get pointer to name.\n                for(ii = 0; ii < (int) strlen(nameTmpPtr); ii++) {                      // Replace spaces with underscores.\n                    if(nameTmpPtr[ii] == ' ') nameTmpPtr[ii] = '_';                     // ..\n                }\n\n                /* Save description in the native event array */\n                tmpSizeBytes = PAPI_2MAX_STR_LEN - 1 * sizeof(char);                    // Most space to use for description.\n                CUPTI_CALL((*cuptiEventGetAttributePtr) (myeventCuptiEventId,           // Get it,\n                    CUPTI_EVENT_ATTR_SHORT_DESCRIPTION, &tmpSizeBytes,                  // .. Set limit (and receive bytes written),\n                    gctxt->availEventDesc[idxEventArray].description),                  // .. in the description.\n                    return (PAPI_EMISC));                                               // .. on failure.\n                gctxt->availEventDesc[idxEventArray].description[PAPI_2MAX_STR_LEN - 1] = '\\0'; // Ensure null terminator.\n                gctxt->availEventDesc[idxEventArray].numMetricEvents = 0;                       // Not a metric.\n                gctxt->availEventDesc[idxEventArray].metricEvents = NULL;                       // No space allocated.\n                /* Increment index past events in this domain to start of next domain */\n                idxEventArray++;                                                        // Bump total number of events.\n            } // end of events in this domain.\n\n            papi_free(domainEventIDArray);                                              // done with temp space.\n        } // end of domain loop within device.\n    } // end of device loop, for events.\n\n    // Now we retrieve and store all METRIC info for each device; this includes\n    // both cuda metrics and nvlink metrics.\n    SUBDBG(\"Checking for metrics\\n\");\n    for (deviceNum = 0; deviceNum < gctxt->deviceCount; deviceNum++) {\n        uint32_t maxMetrics = 0, i, j;\n        CUpti_MetricID *metricIdList = NULL;\n        CUptiResult cuptiRet;\n        mydevice = &gctxt->deviceArray[deviceNum];                                  // Get cuda_device_desc pointer.\n        cuptiRet = (*cuptiDeviceGetNumMetricsPtr) (mydevice->cuDev, &maxMetrics);   // Read the # metrics on this device.\n        if (cuptiRet != CUPTI_SUCCESS || maxMetrics < 1) continue;                  // If no metrics, skip to next device.\n\n        SUBDBG(\"Device %d: Checking each of the (maxMetrics) %d metrics\\n\", deviceNum, maxMetrics);\n\n        // Make a temporary list of the metric Ids to add to the available named collectables.\n        size_t size = maxMetrics * sizeof(CUpti_EventID);\n        metricIdList = (CUpti_MetricID *) papi_calloc(maxMetrics, sizeof(CUpti_EventID));\n        CHECK_PRINT_EVAL(metricIdList == NULL, \"Out of memory\", return (PAPI_ENOMEM));\n\n        CUPTI_CALL((*cuptiDeviceEnumMetricsPtr)                                     // Enumerate the metric Ids for this device,\n            (mydevice->cuDev, &size, metricIdList),                                 // .. into metricIdList.\n            return (PAPI_EMISC));                                                   // .. On failure, but should work, we have metrics!\n\n        // Elimination loop for metrics we cannot support.\n        int saveDeviceNum = 0;\n        CUDA_CALL((*cudaGetDevicePtr) (&saveDeviceNum), return (PAPI_EMISC));       // save caller's device num.\n\n        for (i=0, j=0; i<maxMetrics; i++) {                                         // process each metric Id.\n            size = PAPI_MIN_STR_LEN-1;                                              // Most bytes allowed to be written.\n            CUPTI_CALL((*cuptiMetricGetAttributePtr) (metricIdList[i],              // Get the name.\n                CUPTI_METRIC_ATTR_NAME, &size, (uint8_t *) tmpStr),\n                return (PAPI_EMISC));\n\n            // Note that 'size' also returned total bytes written.\n            tmpStr[size] = '\\0';\n\n            if (strcmp(\"branch_efficiency\", tmpStr) == 0) continue;                 // If it is branch efficiency, skip it.\n\n            // We'd like to reject anything requiring more than 1\n            // set, but there is a problem I cannot find; I have\n            // been unable to create a CUcontext here so I can\n            // execute the CreateEventGroups. I've tried both\n            // ways, it returns an error saying no cuda devices\n            // available.  There does not seem to be a way to get\n            // the number of \"sets\" (passes) for a metric without\n            // having a context.\n\n            // CUpti_EventGroupSets *thisEventGroupSets = NULL;\n            //CUPTI_CALL ((*cuptiMetricCreateEventGroupSetsPtr) (\n            //    tempContext,\n            //    sizeof(CUpti_MetricID),\n            //    &metricIdList[i],\n            //    &thisEventGroupSets),\n            //    return (PAPI_EMISC));\n            //\n            //int numSets = 0;                                                        // # of sets (passes) required.\n            //if (thisEventGroupSets != NULL) {\n            //    numSets=thisEventGroupSets->numSets;                                // Get sets if a grouping is necessary.\n            //    CUPTI_CALL((*cuptiEventGroupSetsDestroyPtr) (thisEventGroupSets),   // Done with this.\n            //        return (PAPI_EMISC));\n            //}\n            //\n            //if (numSets > 1) continue;                                              // skip this metric too many passes.\n\n            metricIdList[j++] = metricIdList[i];                                    // we are compressing if we skipped any.\n        } // end elimination loop.\n\n        // Done with eliminations, the rest are valid.\n        maxMetrics = j;                                                             // Change the number to process.\n\n        // Eliminations accomplished, now add the valid metric Ids to the list.\n        for(i = 0; i < maxMetrics; i++) {                                           // for each id,\n            gctxt->availEventIDArray[idxEventArray] = metricIdList[i];              // add to the list of collectables.\n            gctxt->availEventKind[idxEventArray] = CUPTI_ACTIVITY_KIND_METRIC;      // Indicate it is a metric.\n            gctxt->availEventDeviceNum[idxEventArray] = deviceNum;                  // remember the device number.\n            size = PAPI_MAX_STR_LEN;\n            CUPTI_CALL((*cuptiMetricGetAttributePtr) (metricIdList[i],              // Get the name, fail if we cannot.\n                CUPTI_METRIC_ATTR_NAME, &size, (uint8_t *) tmpStr),\n                return (PAPI_EMISC));\n\n            if (size >= PAPI_MAX_STR_LEN) {                                         // Truncate if we don't have room for the name.\n                gctxt->availEventDesc[idxEventArray].name[PAPI_MAX_STR_LEN - 1] = '\\0';\n            }\n\n            size_t MV_KindSize = sizeof(CUpti_MetricValueKind);\n            CUPTI_CALL((*cuptiMetricGetAttributePtr)                                // Collect the metric kind.\n                (metricIdList[i], CUPTI_METRIC_ATTR_VALUE_KIND, &MV_KindSize,       // .. for this metric,\n                &gctxt->availEventDesc[idxEventArray].MV_Kind),                     // .. store in the event description,\n                return (PAPI_EMISC));                                               // .. on failure, but should always work.\n\n            snprintf(gctxt->availEventDesc[idxEventArray].name, PAPI_MAX_STR_LEN,   // .. develop name for papi user in tmpStr.\n                \"metric:%s:device=%d\", tmpStr, deviceNum);\n\n            size = PAPI_2MAX_STR_LEN-1;                                             // Most bytes to return.\n            CUPTI_CALL((*cuptiMetricGetAttributePtr)                                // Collect the long description.\n                (metricIdList[i], CUPTI_METRIC_ATTR_LONG_DESCRIPTION, &size,        // .. for this metric, no more than size.\n                (uint8_t *) gctxt->availEventDesc[idxEventArray].description),      // .. and store in event description.\n                return (PAPI_EMISC));                                               // .. on failure, but should always work.\n\n            // Note that 'size' also returned total bytes written.\n            gctxt->availEventDesc[idxEventArray].description[size] = '\\0';          // Always z-terminate.\n\n            // Now we get all the sub-events of this metric.\n            uint32_t numSubs;\n            CUpti_MetricID itemId = metricIdList[i];                                //.. shortcut to metric id.\n            CUPTI_CALL((*cuptiMetricGetNumEventsPtr) (itemId, &numSubs),            // .. Get number of sub-events in metric.\n                return (PAPI_EINVAL));                                              // .. on failure of call.\n\n            size_t sizeBytes = numSubs * sizeof(CUpti_EventID);                     // .. compute size of array we need.\n            CUpti_EventID *subEventIds = papi_malloc(sizeBytes);                    // .. Make the space.\n            CHECK_PRINT_EVAL(subEventIds == NULL, \"Malloc failed\",                  // .. If malloc fails,\n                return (PAPI_ENOMEM));\n\n            CUPTI_CALL((*cuptiMetricEnumEventsPtr)                                  // .. Enumrate events in the metric.\n                (itemId, &sizeBytes, subEventIds),                                  // .. store in array.\n                return (PAPI_EINVAL));                                              // .. If cupti call fails.\n\n            gctxt->availEventDesc[idxEventArray].metricEvents = subEventIds;        // .. Copy the array pointer for IDs.\n            gctxt->availEventDesc[idxEventArray].numMetricEvents = numSubs;         // .. Copy number of elements in it.\n\n            idxEventArray++;                                                        // count another collectable found.\n        } // end maxMetrics loop.\n\n        papi_free(metricIdList);                                                    // Done with this enumeration of metrics.\n        // Part of problem above, cannot create tempContext for unknown reason.\n        // CU_CALL((*cuCtxDestroyPtr) (tempContext),     return (PAPI_EMISC));         // destroy the temporary context.\n        CUDA_CALL((*cudaSetDevicePtr) (saveDeviceNum),  return (PAPI_EMISC));       // set the device pointer back to caller.\n    } // end 'for each device'.\n\n    gctxt->availEventSize = idxEventArray;\n\n    /* return 0 if everything went OK */\n    return 0;\n} // end _cuda_add_native_events\n\n\n/*\n  This routine tries to convert all CUPTI values to long long values.\n  If the CUPTI value is an integer type, it is cast to long long.  If\n  the CUPTI value is a percent, it is multiplied by 100 to return the\n  integer percentage.  If the CUPTI value is a double, the value\n  is cast to long long... this can be a severe truncation.\n */\nstatic int _cuda_convert_metric_value_to_long_long(CUpti_MetricValue metricValue, CUpti_MetricValueKind valueKind, long long int *papiValue)\n{\n    union {\n        long long ll;\n        double fp;\n    } tmpValue;\n\n    SUBDBG(\"Try to convert the CUPTI metric value kind (index %d) to PAPI value (long long or double)\\n\", valueKind);\n    switch (valueKind) {\n    case CUPTI_METRIC_VALUE_KIND_DOUBLE:\n        SUBDBG(\"Metric double %f\\n\", metricValue.metricValueDouble);\n        tmpValue.ll = (long long)(metricValue.metricValueDouble);\n        //CHECK_PRINT_EVAL(tmpValue.fp - metricValue.metricValueDouble > 1e-6, \"Error converting metric\\n\", return (PAPI_EMISC));\n        break;\n    case CUPTI_METRIC_VALUE_KIND_UINT64:\n        SUBDBG(\"Metric uint64 = %llu\\n\", (unsigned long long) metricValue.metricValueUint64);\n        tmpValue.ll = (long long) (metricValue.metricValueUint64);\n        CHECK_PRINT_EVAL(tmpValue.ll - metricValue.metricValueUint64 > 1e-6, \"Error converting metric\\n\", return (PAPI_EMISC));\n        break;\n    case CUPTI_METRIC_VALUE_KIND_INT64:\n        SUBDBG(\"Metric int64 = %lld\\n\", (long long) metricValue.metricValueInt64);\n        tmpValue.ll = (long long) (metricValue.metricValueInt64);\n        CHECK_PRINT_EVAL(tmpValue.ll - metricValue.metricValueInt64 > 1e-6, \"Error converting metric\\n\", return (PAPI_EMISC));\n        break;\n    case CUPTI_METRIC_VALUE_KIND_PERCENT:\n        SUBDBG(\"Metric percent = %f%%\\n\", metricValue.metricValuePercent);\n        tmpValue.ll = (long long)(metricValue.metricValuePercent*100);\n        //CHECK_PRINT_EVAL(tmpValue.ll - metricValue.metricValuePercent > 1e-6, \"Error converting metric\\n\", return (PAPI_EMISC));\n        break;\n    case CUPTI_METRIC_VALUE_KIND_THROUGHPUT:\n        SUBDBG(\"Metric throughput %llu bytes/sec\\n\", (unsigned long long) metricValue.metricValueThroughput);\n        tmpValue.ll = (long long) (metricValue.metricValueThroughput);\n        CHECK_PRINT_EVAL(tmpValue.ll - metricValue.metricValueThroughput > 1e-6, \"Error converting metric\\n\", return (PAPI_EMISC));\n        break;\n    case CUPTI_METRIC_VALUE_KIND_UTILIZATION_LEVEL:\n        SUBDBG(\"Metric utilization level %u\\n\", (unsigned int) metricValue.metricValueUtilizationLevel);\n        tmpValue.ll = (long long) (metricValue.metricValueUtilizationLevel);\n        CHECK_PRINT_EVAL(tmpValue.ll - metricValue.metricValueUtilizationLevel > 1e-6, \"Error converting metric\\n\", return (PAPI_EMISC));\n        break;\n    default:\n        CHECK_PRINT_EVAL(1, \"ERROR: unsupported metric value kind\", return (PAPI_EINVAL));\n        exit(-1);\n    }\n\n    *papiValue = tmpValue.ll;\n    return (PAPI_OK);\n} // end routine\n\n\n/* ****************************************************************************\n *******************  BEGIN PAPI's COMPONENT REQUIRED FUNCTIONS  *************\n **************************************************************************** */\n\n/*\n * This is called whenever a thread is initialized.\n */\nstatic int _cuda_init_thread(hwd_context_t * ctx)\n{\n    (void) ctx;\n    SUBDBG(\"Entering\\n\");\n\n    return PAPI_OK;\n}\n\n\n/* Initialize hardware counters, setup the function vector table\n * and get hardware information, this routine is called when the\n * PAPI process is initialized (IE PAPI_library_init)\n */\n/* NOTE: only called by main thread (not by every thread) !!! Starting\n   in CUDA 4.0, multiple CPU threads can access the same CUDA\n   context. This is a much easier programming model then pre-4.0 as\n   threads - using the same context - can share memory, data,\n   etc. It's possible to create a different context for each\n   thread. That's why CUDA context creation is done in\n   CUDA_init_component() (called only by main thread) rather than\n   CUDA_init() or CUDA_init_control_state() (both called by each\n   thread). */\nstatic int _cuda_init_component(int cidx)\n{\n    SUBDBG(\"Entering with component idx: %d\\n\", cidx);\n    int rv;\n\n    /* link in all the cuda libraries and resolve the symbols we need to use */\n    if(_cuda_linkCudaLibraries() != PAPI_OK) {\n        SUBDBG(\"Dynamic link of CUDA libraries failed, component will be disabled.\\n\");\n        SUBDBG(\"See disable reason in papi_component_avail output for more details.\\n\");\n        return (PAPI_ENOSUPP);\n    }\n\n    /* Create the structure */\n    if(!global_cuda_context)\n        global_cuda_context = (cuda_context_t *) papi_calloc(1, sizeof(cuda_context_t));\n\n    /* Get list of all native CUDA events supported */\n    rv = _cuda_add_native_events(global_cuda_context);\n    if(rv != 0)\n        return (rv);\n\n    /* Export some information */\n    _cuda_vector.cmp_info.CmpIdx = cidx;\n    _cuda_vector.cmp_info.num_native_events = global_cuda_context->availEventSize;\n    _cuda_vector.cmp_info.num_cntrs = _cuda_vector.cmp_info.num_native_events;\n    _cuda_vector.cmp_info.num_mpx_cntrs = _cuda_vector.cmp_info.num_native_events;\n\n    return (PAPI_OK);\n} // end init_component\n\n\n/* Setup a counter control state.\n *   In general a control state holds the hardware info for an\n *   EventSet.\n */\nstatic int _cuda_init_control_state(hwd_control_state_t * ctrl)\n{\n    SUBDBG(\"Entering\\n\");\n    (void) ctrl;\n    cuda_context_t *gctxt = global_cuda_context;\n\n    CHECK_PRINT_EVAL(!gctxt, \"Error: The PAPI CUDA component needs to be initialized first\", return (PAPI_ENOINIT));\n    /* If no events were found during the initial component initialization, return error */\n    if(global_cuda_context->availEventSize <= 0) {\n        strncpy(_cuda_vector.cmp_info.disabled_reason, \"ERROR CUDA: No events exist\", PAPI_MAX_STR_LEN);\n        return (PAPI_EMISC);\n    }\n    /* If it does not exist, create the global structure to hold CUDA contexts and active events */\n    if(!global_cuda_control) {\n        global_cuda_control = (cuda_control_t *) papi_calloc(1, sizeof(cuda_control_t));\n        global_cuda_control->countOfActiveCUContexts = 0;\n        global_cuda_control->activeEventCount = 0;\n    }\n\n    return PAPI_OK;\n} // end cuda_init_control_state\n\n/* Triggered by eventset operations like add or remove.  For CUDA, needs to be\n * called multiple times from each separate CUDA context with the events to be\n * measured from that context.  For each context, create eventgroups for the\n * events.\n */\n\n/* Note: NativeInfo_t is defined in papi_internal.h */\nstatic int _cuda_update_control_state(hwd_control_state_t * ctrl,\n    NativeInfo_t * nativeInfo, int nativeCount, hwd_context_t * ctx)\n{\n    SUBDBG(\"Entering with nativeCount %d\\n\", nativeCount);\n    (void) ctx;\n    cuda_control_t *gctrl = global_cuda_control;    // We don't use the passed-in parameter, we use a global.\n    cuda_context_t *gctxt = global_cuda_context;    // We don't use the passed-in parameter, we use a global.\n    int currDeviceNum;\n    CUcontext currCuCtx;\n    int eventContextIdx;\n    CUcontext eventCuCtx;\n    int index, ii, ee, cc;\n\n    /* Return if no events */\n    if(nativeCount == 0)\n        return (PAPI_OK);\n\n    /* Get deviceNum, initialize context if needed via free, get context */\n    CUDA_CALL((*cudaGetDevicePtr) (&currDeviceNum), return (PAPI_EMISC));\n    SUBDBG(\"currDeviceNum %d \\n\", currDeviceNum);\n\n    CUDA_CALL((*cudaFreePtr) (NULL), return (PAPI_EMISC));\n    CU_CALL((*cuCtxGetCurrentPtr) (&currCuCtx), return (PAPI_EMISC));\n    SUBDBG(\"currDeviceNum %d cuCtx %p \\n\", currDeviceNum, currCuCtx);\n\n    /* Handle user request of events to be monitored */\n    for (ii = 0; ii < nativeCount; ii++) {                                  // For each event provided by caller,\n        index              = nativeInfo[ii].ni_event;                       // Get the index of the event (in the global context).\n        char *eventName    = gctxt->availEventDesc[index].name;             // Shortcut to name.\n        int numMetricEvents= gctxt->availEventDesc[index].numMetricEvents;  // Get if this is an event (=0) or metric (>0).\n        int eventDeviceNum = gctxt->availEventDeviceNum[index];             // Device number for this event.\n        (void) eventName;                                                   // Useful in checkpoint and debug, don't warn if not used.\n\n        /* if this event is already added continue to next ii, if not, mark it as being added */\n        if (gctxt->availEventIsBeingMeasuredInEventset[index] == 1) {       // If already being collected, skip it.\n            SUBDBG(\"Skipping event %s which is already added\\n\", eventName);\n            continue;\n        } else {\n            gctxt->availEventIsBeingMeasuredInEventset[index] = 1;          // If not being collected yet, flag it as being collected now.\n        }\n\n        /* Find context/control in papicuda, creating it if does not exist */\n        for(cc = 0; cc < (int) gctrl->countOfActiveCUContexts; cc++) {              // Scan all active contexts.\n            CHECK_PRINT_EVAL(cc >= PAPICUDA_MAX_COUNTERS, \"Exceeded hardcoded maximum number of contexts (PAPICUDA_MAX_COUNTERS)\", return (PAPI_EMISC));\n\n            if(gctrl->arrayOfActiveCUContexts[cc]->deviceNum == eventDeviceNum) {   // If this cuda context is for the device for this event,\n                eventCuCtx = gctrl->arrayOfActiveCUContexts[cc]->cuCtx;             // Remember that context.\n                SUBDBG(\"Event %s device %d already has a cuCtx %p registered\\n\", eventName, eventDeviceNum, eventCuCtx);\n\n                if(eventCuCtx != currCuCtx)                                         // If that is not our CURRENT context, push and make it so.\n                    CU_CALL((*cuCtxPushCurrentPtr) (eventCuCtx),                    // .. Stack the current counter, replace with this one.\n                        return (PAPI_EMISC));                                       // .. .. on failure.\n                break;                                                              // .. exit the loop.\n            } // end if found.\n        } // end loop through active contexts.\n\n        if(cc == (int) gctrl->countOfActiveCUContexts) {                            // If we never found the context, create one.\n            SUBDBG(\"Event %s device %d does not have a cuCtx registered yet...\\n\", eventName, eventDeviceNum);\n            if(currDeviceNum != eventDeviceNum) {                           // .. If we need to switch to another device,\n                CUDA_CALL((*cudaSetDevicePtr) (eventDeviceNum),             // .. .. set the device pointer to the event's device.\n                    return (PAPI_EMISC));                                   // .. .. .. (on failure).\n                CUDA_CALL((*cudaFreePtr) (NULL), return (PAPI_EMISC));      // .. .. This is a no-op, but used to force init of a context.\n                CU_CALL((*cuCtxGetCurrentPtr) (&eventCuCtx),                // .. .. So we can get a pointer to it.\n                    return (PAPI_EMISC));                                   // .. .. .. On failure.\n            } else {                                                        // .. If we are already on the right device,\n                eventCuCtx = currCuCtx;                                     // .. .. just get the current context.\n            }\n\n            gctrl->arrayOfActiveCUContexts[cc] = papi_calloc(1, sizeof(cuda_active_cucontext_t));   // allocate a structure.\n            CHECK_PRINT_EVAL(gctrl->arrayOfActiveCUContexts[cc] == NULL, \"Memory allocation for new active context failed\", return (PAPI_ENOMEM));\n            gctrl->arrayOfActiveCUContexts[cc]->deviceNum = eventDeviceNum; // Fill in everything.\n            gctrl->arrayOfActiveCUContexts[cc]->cuCtx = eventCuCtx;\n            gctrl->arrayOfActiveCUContexts[cc]->allEventsCount = 0;         // All events read by this context on this device.\n            gctrl->arrayOfActiveCUContexts[cc]->ctxActiveCount = 0;         // active events being read by this context on this device.\n            gctrl->countOfActiveCUContexts++;\n            SUBDBG(\"Added a new context deviceNum %d cuCtx %p ... now countOfActiveCUContexts is %d\\n\", eventDeviceNum, eventCuCtx, gctrl->countOfActiveCUContexts);\n        } // end if we needed to create a new context.\n\n        //---------------------------------------------------------------------\n        // We found the context, or created it, and the index is in cc.\n        //---------------------------------------------------------------------\n        eventContextIdx = cc;\n        cuda_active_cucontext_t *eventctrl = gctrl->arrayOfActiveCUContexts[eventContextIdx];   // get the context for this event.\n\n        // We need to get all the events (or sub-events of a metric) and add\n        // them to our list of all events. Note we only check if we exceed the\n        // bounds of the allEvents[] array; everything added to any other array\n        // results in at least ONE add to allEvents[], so it will fail before\n        // or coincident with any other array. TC\n\n        CUpti_EventID itemId = gctxt->availEventIDArray[index];                 // event (or metric) ID.\n\n        if (numMetricEvents == 0) {                                             // Dealing with a simple event.\n            eventctrl->allEvents[eventctrl->allEventsCount++] = itemId;         // add to aggregate list, count it.\n            if (eventctrl->allEventsCount >= PAPICUDA_MAX_COUNTERS) {           // .. Fail if we exceed size of array.\n                SUBDBG(\"Num events (generated by metric) exceeded PAPICUDA_MAX_COUNTERS\\n\");\n                return(PAPI_EINVAL);\n            }\n        } else {                                                                // dealing with a metric.\n            // cuda events and metrics have already been skipped if duplicates,\n            // but we can't say the same for sub-events of a metric. We need to\n            // check we don't duplicate them in allEvents.\n\n            for(ee = 0; ee < numMetricEvents; ee++) {                           // For each event retrieved,\n                int aeIdx;\n                CUpti_EventID myId = gctxt->availEventDesc[index].metricEvents[ee]; // collect the sub-event ID.\n\n                for (aeIdx=0; aeIdx<(int) eventctrl->allEventsCount; aeIdx++) {     // loop through existing events.\n                    if (eventctrl->allEvents[aeIdx] == myId) break;                 // break out if duplicate found.\n                }\n\n                if (aeIdx < (int) eventctrl->allEventsCount) continue;              // Don't add if already present.\n                eventctrl->allEvents[eventctrl->allEventsCount++] = myId;           // add event to the all array.\n\n                if (eventctrl->allEventsCount >= PAPICUDA_MAX_COUNTERS) {       // Fail if we exceed size of array.\n                    SUBDBG(\"Num events (generated by metric) exceeded PAPICUDA_MAX_COUNTERS\\n\");\n                    return(PAPI_EINVAL);\n                }\n            } // end for each event in metric.\n        } // end if we must process all sub-events of a metric.\n\n        // Record index of this active event back into the nativeInfo\n        // structure.\n\n        nativeInfo[ii].ni_position = gctrl->activeEventCount;\n\n        // Record index of this active event within this context. We need this\n        // so after we read this context, we can move values (or compute\n        // metrics and move values) into their proper position within the\n        // activeValues[] array.\n\n        eventctrl->ctxActiveEvents[eventctrl->ctxActiveCount++] =       // within this active_cucontext.\n            gctrl->activeEventCount;                                    // ..\n\n        // Record in internal gctrl arrays.\n        // so we have a succinct list of active events and metrics; this will\n        // be useful for performance especially on metrics, where we must\n        // compose values.\n\n        CHECK_PRINT_EVAL(gctrl->activeEventCount == PAPICUDA_MAX_COUNTERS - 1, \"Exceeded maximum num of events (PAPI_MAX_COUNTERS)\", return (PAPI_EMISC));\n        gctrl->activeEventIndex[gctrl->activeEventCount] = index;\n        gctrl->activeEventValues[gctrl->activeEventCount] = 0;\n        gctrl->activeEventCount++;\n\n        // EventGroupSets does an analysis to creates 'sets' of events that\n        // can be collected simultaneously, i.e. the application must be\n        // run once per set. CUpti calls these 'passes'. We don't allow\n        // such combinations, there is no way to tell a PAPI user to run\n        // their application multiple times.  WITHIN a single set are\n        // EventGroups which are collected simultaneously but must be read\n        // separately because each group applies to a separate domain.  So\n        // we don't mind that; but we must exit with an invalid combination\n        // if numsets > 1, indicating the most recent event requested\n        // cannot be collected simultaneously with the others.\n\n        // We destroy any existing eventGroupSets, and then create one for the\n        // new set of events.\n\n        SUBDBG(\"Create eventGroupSets for context (destroy pre-existing) (nativeCount %d, allEventsCount %d) \\n\", gctrl->activeEventCount, eventctrl->allEventsCount);\n        if(eventctrl->allEventsCount > 0) {                                         // If we have events...\n            // SUBDBG(\"Destroy previous eventGroupPasses for the context \\n\");\n            if(eventctrl->eventGroupSets != NULL) {                                 // if we have a previous analysis;\n                CUPTI_CALL((*cuptiEventGroupSetsDestroyPtr)                         // .. Destroy it.\n                    (eventctrl->eventGroupSets), return (PAPI_EMISC));              // .. If we can't, return error.\n                eventctrl->eventGroupSets = NULL;                                   // .. Reset pointer.\n            }\n\n            size_t sizeBytes = (eventctrl->allEventsCount) * sizeof(CUpti_EventID); // compute bytes in the array.\n\n            // SUBDBG(\"About to create eventGroupPasses for the context (sizeBytes %zu) \\n\", sizeBytes);\n#ifdef PAPICUDA_KERNEL_REPLAY_MODE\n            CUPTI_CALL((*cuptiEnableKernelReplayModePtr) (eventCuCtx),\n                return (PAPI_ECMP));\n            CUPTI_CALL((*cuptiEventGroupSetsCreatePtr)\n                (eventCuCtx, sizeBytes, eventctrl->allEvents,\n                &eventctrl->eventGroupSets),\n                return (PAPI_ECMP));\n\n#else // Normal operation.\n            // Note: We no longer fail if this collection mode does not work. It will only work\n            // on TESLA devices, and is desirable there (not restricted to the kernel). But it\n            // is not available on other models (including GTX) and we shouldn't fail without it.\n            CUPTI_CALL((*cuptiSetEventCollectionModePtr)\n                (eventCuCtx,CUPTI_EVENT_COLLECTION_MODE_CONTINUOUS), );\n\n// CUPTI provides two routines to create EventGroupSets, one is used\n// here cuptiEventGroupSetsCreate(), the other is for metrics, it will\n// automatically collect the events needed for a metric. It is called\n// cuptiMetricCreateEventGroupSets(). We have checked and these two routines\n// produce groups of the same size with the same event IDs, and work equally.\n\n            CUPTI_CALL((*cuptiEventGroupSetsCreatePtr)\n                (eventCuCtx, sizeBytes, eventctrl->allEvents,\n                &eventctrl->eventGroupSets),\n                return (PAPI_EMISC));\n\n            if (eventctrl->eventGroupSets->numSets > 1) {                       // If more than one pass is required,\n                SUBDBG(\"Error occurred: The combined CUPTI events cannot be collected simultaneously ... try different events\\n\");\n                _cuda_cleanup_eventset(ctrl);                                // Will do cuptiEventGroupSetsDestroy() to clean up memory.\n                return(PAPI_ECOMBO);\n            } else  {\n                SUBDBG(\"Created eventGroupSets. nativeCount %d, allEventsCount %d. Sets (passes-required) = %d) \\n\", gctrl->activeEventCount, eventctrl->allEventsCount, eventctrl->eventGroupSets->numSets);\n            }\n\n#endif // #if/#else/#endif on PAPICUDA_KERNEL_REPLAY_MODE\n\n        } // end if we had any events.\n\n        if(eventCuCtx != currCuCtx)                                                 // restore original context for caller, if we changed it.\n            CU_CALL((*cuCtxPopCurrentPtr) (&eventCuCtx), return (PAPI_EMISC));\n\n    }\n    return (PAPI_OK);\n} // end PAPI_update_control_state.\n\n\n/* Triggered by PAPI_start().\n * For CUDA component, switch to each context and start all eventgroups.\n*/\nstatic int _cuda_start(hwd_context_t * ctx, hwd_control_state_t * ctrl)\n{\n    SUBDBG(\"Entering\\n\");\n    (void) ctx;\n    (void) ctrl;\n    cuda_control_t *gctrl = global_cuda_control;\n    // cuda_context_t *gctxt = global_cuda_context;\n    uint32_t ii, gg, cc;\n    int saveDeviceNum = -1;\n\n    SUBDBG(\"Reset all active event values\\n\");\n    for(ii = 0; ii < gctrl->activeEventCount; ii++)                             // These are the values we will return.\n        gctrl->activeEventValues[ii] = 0;\n\n    SUBDBG(\"Save current context, then switch to each active device/context and enable eventgroups\\n\");\n    CUDA_CALL((*cudaGetDevicePtr) (&saveDeviceNum), return (PAPI_EMISC));\n    CUPTI_CALL((*cuptiGetTimestampPtr) (&gctrl->cuptiStartTimestampNs), return (PAPI_EMISC));\n\n    for(cc = 0; cc < gctrl->countOfActiveCUContexts; cc++) {                    // For each context,\n        int eventDeviceNum = gctrl->arrayOfActiveCUContexts[cc]->deviceNum;     // .. get device number.\n        CUcontext eventCuCtx = gctrl->arrayOfActiveCUContexts[cc]->cuCtx;       // .. get this context,\n        SUBDBG(\"Set to device %d cuCtx %p \\n\", eventDeviceNum, eventCuCtx);\n        if(eventDeviceNum != saveDeviceNum) {                                   // .. If we need to switch,\n            CU_CALL((*cuCtxPushCurrentPtr) (eventCuCtx), return (PAPI_EMISC));  // .. .. push current on stack, use this one.\n        }\n\n        CUpti_EventGroupSets *eventGroupSets =                                  // .. Shortcut to eventGroupSets for this context.\n            gctrl->arrayOfActiveCUContexts[cc]->eventGroupSets;                 // ..\n            CUpti_EventGroupSet *groupset = &eventGroupSets->sets[0];           // .. There can be only one set of groups.\n            for(gg = 0; gg < groupset->numEventGroups; gg++) {                  // .. For each group within this groupset,\n                uint32_t one = 1;\n                CUPTI_CALL((*cuptiEventGroupSetAttributePtr) (                  // .. .. Say we want to profile all domains.\n                    groupset->eventGroups[gg],\n                    CUPTI_EVENT_GROUP_ATTR_PROFILE_ALL_DOMAIN_INSTANCES,\n                    sizeof(uint32_t), &one),\n                    return (PAPI_EMISC));                                       // .. .. on failure of call.\n            } // end for each group.\n\n            CUPTI_CALL((*cuptiEventGroupSetEnablePtr) (groupset),               // .. Enable all groups in set (start collecting).\n                return (PAPI_EMISC));                                           // .. on failure of call.\n\n        if(eventDeviceNum != saveDeviceNum) {                                   // .. If we pushed a context,\n            CU_CALL((*cuCtxPopCurrentPtr) (&eventCuCtx), return (PAPI_EMISC));  // .. Pop it.\n        }\n    } // end of loop on all contexts.\n\n    return (PAPI_OK);                                                           // We started all groups.\n} // end routine.\n\n// Triggered by PAPI_read().  For CUDA component, switch to each context, read\n// all the eventgroups, and put the values in the correct places. Note that\n// parameters (ctx, ctrl, flags) are all ignored. The design of this components\n// doesn't pay attention to PAPI EventSets, because ONLY ONE is ever allowed\n// for a component.  So instead of maintaining ctx and ctrl, we use global\n// variables to keep track of the one and only eventset.  Note that **values is\n// where we have to give PAPI the address of an array of the values we read (or\n// composed).\n\nstatic int _cuda_read(hwd_context_t * ctx, hwd_control_state_t * ctrl, long long **values, int flags)\n{\n    SUBDBG(\"Entering\\n\");\n    (void) ctx;\n    (void) ctrl;\n    (void) flags;\n    cuda_control_t *gctrl = global_cuda_control;\n    cuda_context_t *gctxt = global_cuda_context;\n    uint32_t gg, i, j, cc;\n    int saveDeviceNum;\n\n    // Get read time stamp\n    CUPTI_CALL((*cuptiGetTimestampPtr)                                          // Read current timestamp.\n        (&gctrl->cuptiReadTimestampNs),\n        return (PAPI_EMISC));\n    uint64_t durationNs = gctrl->cuptiReadTimestampNs -\n                          gctrl->cuptiStartTimestampNs;                         // compute duration from start.\n    gctrl->cuptiStartTimestampNs = gctrl->cuptiReadTimestampNs;                 // Change start to value just read.\n\n    SUBDBG(\"Save current context, then switch to each active device/context and enable context-specific eventgroups\\n\");\n    CUDA_CALL((*cudaGetDevicePtr) (&saveDeviceNum), return (PAPI_EMISC));       // Save Caller's current device number on entry.\n\n    for(cc = 0; cc < gctrl->countOfActiveCUContexts; cc++) {                    // For each active context,\n        cuda_active_cucontext_t *activeCuCtxt =\n            gctrl->arrayOfActiveCUContexts[cc];                                 // A shortcut.\n        int currDeviceNum = activeCuCtxt->deviceNum;                            // Get the device number.\n        CUcontext currCuCtx = activeCuCtxt->cuCtx;                              // Get the actual CUcontext.\n\n        SUBDBG(\"Set to device %d cuCtx %p \\n\", currDeviceNum, currCuCtx);\n        if(currDeviceNum != saveDeviceNum) {                                    // If my current is not the same as callers,\n            CU_CALL((*cuCtxPushCurrentPtr) (currCuCtx), return (PAPI_EMISC));   // .. Push the current, and replace with mine.\n            // Note, cuCtxPushCurrent()  implicitly includes a cudaSetDevice().\n        } else {                                                                // If my current IS the same as callers,\n            CU_CALL((*cuCtxSetCurrentPtr) (currCuCtx), return (PAPI_EMISC));    // .. No push. Just set the current.\n        }\n\n        CU_CALL((*cuCtxSynchronizePtr) (), return (PAPI_EMISC));                // Block until device finishes all prior tasks.\n        CUpti_EventGroupSets *myEventGroupSets =  activeCuCtxt->eventGroupSets; // Make a copy of pointer to EventGroupSets.\n\n        uint32_t numEvents, numInstances, numTotalInstances;\n        size_t sizeofuint32num = sizeof(uint32_t);\n        CUpti_EventDomainID groupDomainID;\n        size_t groupDomainIDSize = sizeof(groupDomainID);\n        CUdevice cudevice = gctxt->deviceArray[currDeviceNum].cuDev;            // Make a copy of the current device.\n\n        // For each pass, we get the event groups that can be read together.\n        // But since elsewhere, we don't allow events to be added that would\n        // REQUIRE more than one pass, this will always be just ONE pass. So we\n        // only need to loop over the groups.\n\n        CUpti_EventGroupSet *groupset = &myEventGroupSets->sets[0];             // The one and only set.\n        SUBDBG(\"Read events in this context\\n\");\n        int AEIdx = 0;                                                          // we will be over-writing the allEvents array.\n\n        for (gg = 0; gg < groupset->numEventGroups; gg++) {                     // process each eventgroup within the groupset.\n            CUpti_EventGroup group = groupset->eventGroups[gg];                 // Shortcut to the group.\n\n            CUPTI_CALL((*cuptiEventGroupGetAttributePtr)                        // Get 'groupDomainID' for this group.\n                (group, CUPTI_EVENT_GROUP_ATTR_EVENT_DOMAIN_ID,\n                &groupDomainIDSize, &groupDomainID),\n                return (PAPI_EMISC));\n\n            // 'numTotalInstances' and 'numInstances are needed for scaling\n            // the values retrieved. (Nvidia instructions and samples).\n            CUPTI_CALL((*cuptiDeviceGetEventDomainAttributePtr)                 // Get 'numTotalInstances' for this domain.\n                (cudevice,\n                groupDomainID,\n                CUPTI_EVENT_DOMAIN_ATTR_TOTAL_INSTANCE_COUNT,\n                &sizeofuint32num,\n                &numTotalInstances),\n                return (PAPI_EMISC));\n\n            CUPTI_CALL((*cuptiEventGroupGetAttributePtr)                        // Get 'numInstances' for this domain.\n                (group,\n                CUPTI_EVENT_GROUP_ATTR_INSTANCE_COUNT,\n                &sizeofuint32num,\n                &numInstances),\n                return (PAPI_EMISC));\n\n            CUPTI_CALL((*cuptiEventGroupGetAttributePtr)                        // Get 'numEvents' in this group.\n                (group,\n                CUPTI_EVENT_GROUP_ATTR_NUM_EVENTS,\n                &sizeofuint32num,\n                &numEvents),\n                return (PAPI_EMISC));\n\n            // Now we will read all events in this group; aggregate the values\n            // and then distribute them.  We do not calculate metrics here;\n            // wait until all groups are read and all values are available.\n\n            size_t resultArrayBytes        = sizeof(uint64_t) * numEvents * numTotalInstances;\n            size_t eventIdArrayBytes       = sizeof(CUpti_EventID) * numEvents;\n            size_t numCountersRead         = 2;\n\n            CUpti_EventID *eventIdArray = (CUpti_EventID *) papi_malloc(eventIdArrayBytes);\n            uint64_t *resultArray       = (uint64_t *)      papi_malloc(resultArrayBytes);\n            uint64_t *aggrResultArray   = (uint64_t *)      papi_calloc(numEvents, sizeof(uint64_t));\n\n            for (i=0; i<(resultArrayBytes/sizeof(uint64_t)); i++) resultArray[i]=0;\n\n            if (eventIdArray == NULL || resultArray == NULL || aggrResultArray == NULL) {\n                fprintf(stderr, \"%s:%i failed to allocate memory.\\n\", __FILE__, __LINE__);\n                return(PAPI_EMISC);\n            }\n\n            CUPTI_CALL( (*cuptiEventGroupReadAllEventsPtr)                      // Read all events.\n                (group, CUPTI_EVENT_READ_FLAG_NONE,                             // This flag is the only allowed flag.\n                &resultArrayBytes, resultArray,\n                &eventIdArrayBytes, eventIdArray,\n                &numCountersRead),\n                return (PAPI_EMISC));\n\n            // Now (per Nvidia) we must sum up all domains for each event.\n            // Arrangement of 2-d Array returned in resultArray:\n            //    domain instance 0: event0 event1 ... eventN\n            //    domain instance 1: event0 event1 ... eventN\n            //    ...\n            //    domain instance M: event0 event1 ... eventN\n            // But we accumulate by column, event[0], event[1], etc.\n\n            for (i = 0; i < numEvents; i++) {                                   // outer loop is column (event) we are on.\n                for (j = 0; j < numTotalInstances; j++) {                       // inner loop is row (instance) we are on.\n                    aggrResultArray[i] += resultArray[i + numEvents * j];       // accumulate the column.\n                }\n            }\n\n            // We received an eventIdArray; note this is not necessarily in the\n            // same order as we added them; CUpti can reorder them when sorting\n            // them into groups.  However, the total number of events must be\n            // the same, so now as we read each group, we just overwrite the\n            // allEvents[] and allEventValues[] arrays. It doesn't make a\n            // difference to cuptiGetMetricValue what order the events appear\n            // in.\n\n            // After all these groups are read, allEvents will be complete, and\n            // we can use it to compute the metrics and move metric and event\n            // values back into user order.\n\n            for (i=0; i<numEvents; i++) {                                               // For each event in eventIdArray (just this group),\n                CUpti_EventID myId = eventIdArray[i];                                   // shortcut for the event id within this group.\n                activeCuCtxt->allEvents[AEIdx] = myId;                                  // Overwrite All Events id.\n                activeCuCtxt->allEventValues[AEIdx++] = aggrResultArray[i];             // Overwrite all events value; increment position.\n            } // end loop for each event.\n\n            papi_free(eventIdArray);\n            papi_free(resultArray);\n            papi_free(aggrResultArray);\n        } // end of an event group.\n\n        // We have finished all event groups within this context; allEvents[]\n        // and allEventValues[] are populated. Now we compute metrics and move\n        // event values. We do that by looping through the events assigned to\n        // this context, and we must back track to the activeEventIdx[] and\n        // activeEventValues[] array in gctrl. We have kept our indexes into\n        // that array, in ctxActive[].\n\n        uint32_t ctxActiveCount =  activeCuCtxt->ctxActiveCount;                // Number of (papi user) events in this context.\n        uint32_t *ctxActive =  activeCuCtxt->ctxActiveEvents;                   // index of each event in gctrl->activeEventXXXX.\n\n        for (j=0; j<ctxActiveCount; j++) {                                      // Search for matching active event.\n            uint32_t activeIdx, availIdx;\n\n            activeIdx=ctxActive[j];                                             // get index into activeEventIdx.\n            availIdx = gctrl->activeEventIndex[activeIdx];                      // Get the availEventIdx.\n            CUpti_EventID thisEventId = gctxt->availEventIDArray[availIdx];     // Get the event ID (or metric ID).\n            struct cuda_name_desc *myDesc=&(gctxt->availEventDesc[availIdx]);  // get pointer to the description.\n\n            if (myDesc->numMetricEvents == 0) {                                 // If this is a simple cuda event (not a metric),\n                int k;\n                for (k=0; k<AEIdx; k++) {                                       // search the array for this event id.\n                    if (activeCuCtxt->allEvents[k] == thisEventId) {            // If I found the event,\n                        gctrl->activeEventValues[activeIdx] =                   // Record the value,\n                            activeCuCtxt->allEventValues[k];\n                        break;                                                  // break out of the search loop.\n                    } // end if I found it.\n                } // end search loop.\n\n                continue;                                                       // Jump to next in ctxActiveCount.\n            } else {                                                            // If I found a metric, I must compute it.\n                CUpti_MetricValue myValue;                                      // Space for a return.\n                CUPTI_CALL( (*cuptiMetricGetValuePtr)                           // Get the value,\n                    (cudevice, thisEventId,                                     // device and metric Id,\n                    AEIdx * sizeof(CUpti_EventID),                              // size of event list,\n                    activeCuCtxt->allEvents,                                    // the event list.\n                    AEIdx * sizeof(uint64_t),                                   // size of corresponding event values,\n                    activeCuCtxt->allEventValues,                               // the event values.\n                    durationNs, &myValue),                                      // duration (for rates), and where to return the value.\n                    return(PAPI_EMISC));                                        // In case of error.\n\n                _cuda_convert_metric_value_to_long_long(                     // convert the value computed to long long and store it.\n                    myValue, myDesc->MV_Kind,\n                    &gctrl->activeEventValues[activeIdx]);\n            }\n        } // end loop on active events in this context.\n\n        if(currDeviceNum != saveDeviceNum) {                                    // If we had to change the context from user's,\n            CUDA_CALL((*cudaSetDevicePtr) (saveDeviceNum),                      // set the device pointer to the user's original.\n                return (PAPI_EMISC));                                           // .. .. (on failure).\n            CU_CALL((*cuCtxPopCurrentPtr) (&currCuCtx), return (PAPI_EMISC));   // .. pop the pushed context back to user's.\n        }\n    } // end of loop for each active context.\n\n    *values = gctrl->activeEventValues;                                         // Return ptr to the list of computed values to user.\n    return (PAPI_OK);\n} // end of cuda_read().\n\n/* Triggered by PAPI_stop() */\nstatic int _cuda_stop(hwd_context_t * ctx, hwd_control_state_t * ctrl)\n{\n    SUBDBG(\"Entering\\n\");\n    (void) ctx;\n    (void) ctrl;\n    cuda_control_t *gctrl = global_cuda_control;\n    uint32_t cc, ss;\n    int saveDeviceNum;\n\n    SUBDBG(\"Save current context, then switch to each active device/context and enable eventgroups\\n\");\n    CUDA_CALL((*cudaGetDevicePtr) (&saveDeviceNum), return (PAPI_EMISC));\n    for(cc = 0; cc < gctrl->countOfActiveCUContexts; cc++) {\n        int currDeviceNum = gctrl->arrayOfActiveCUContexts[cc]->deviceNum;\n        CUcontext currCuCtx = gctrl->arrayOfActiveCUContexts[cc]->cuCtx;\n        SUBDBG(\"Set to device %d cuCtx %p \\n\", currDeviceNum, currCuCtx);\n        if(currDeviceNum != saveDeviceNum)\n            CU_CALL((*cuCtxPushCurrentPtr) (currCuCtx), return (PAPI_EMISC));\n        else\n            CU_CALL((*cuCtxSetCurrentPtr) (currCuCtx), return (PAPI_EMISC));\n        CUpti_EventGroupSets *currEventGroupSets = gctrl->arrayOfActiveCUContexts[cc]->eventGroupSets;\n        for (ss=0; ss<currEventGroupSets->numSets; ss++) {                      // For each group in the set,\n            CUpti_EventGroupSet groupset = currEventGroupSets->sets[ss];        // get the set,\n            CUPTI_CALL((*cuptiEventGroupSetDisablePtr) (&groupset),             // disable the whole set.\n                return (PAPI_EMISC));                                           // .. on failure.\n        }\n        /* Pop the pushed context */\n        if(currDeviceNum != saveDeviceNum)\n            CU_CALL((*cuCtxPopCurrentPtr) (&currCuCtx), return (PAPI_EMISC));\n\n    }\n    return (PAPI_OK);\n} // end of cuda_stop.\n\n\n/*\n * Disable and destroy the CUDA eventGroup\n */\nstatic int _cuda_cleanup_eventset(hwd_control_state_t * ctrl)\n{\n    SUBDBG(\"Entering\\n\");\n    (void) ctrl;                                                    // Don't need this parameter.\n    cuda_control_t *gctrl = global_cuda_control;\n    cuda_context_t *gctxt = global_cuda_context;\n    // cuda_active_cucontext_t *currctrl;\n    uint32_t cc;\n    int saveDeviceNum;\n    unsigned int ui;\n    CUcontext saveCtx;  \n\n    SUBDBG(\"Save current device/context, then switch to each active device/context and enable eventgroups\\n\");\n    CUDA_CALL((*cudaGetDevicePtr) (&saveDeviceNum), return (PAPI_EMISC));\n    CU_CALL((*cuCtxGetCurrentPtr) (&saveCtx), return (PAPI_EMISC));\n\n    for(cc = 0; cc < gctrl->countOfActiveCUContexts; cc++) {\n        int currDeviceNum = gctrl->arrayOfActiveCUContexts[cc]->deviceNum;\n        CUcontext currCuCtx = gctrl->arrayOfActiveCUContexts[cc]->cuCtx;\n        CUDA_CALL((*cudaSetDevicePtr) (currDeviceNum), return(PAPI_EMISC));\n        CU_CALL((*cuCtxSetCurrentPtr) (currCuCtx), return (PAPI_EMISC));\n        CUpti_EventGroupSets *currEventGroupSets = gctrl->arrayOfActiveCUContexts[cc]->eventGroupSets;\n\n        //CUPTI_CALL((*cuptiEventGroupSetsDestroyPtr) (currEventGroupPasses), return (PAPI_EMISC));\n        (*cuptiEventGroupSetsDestroyPtr) (currEventGroupSets);\n        gctrl->arrayOfActiveCUContexts[cc]->eventGroupSets = NULL;\n        papi_free( gctrl->arrayOfActiveCUContexts[cc] );\n    }\n    /* Restore saved context, device pointer */\n    CU_CALL((*cuCtxSetCurrentPtr) (saveCtx), return (PAPI_EMISC));\n    CUDA_CALL((*cudaSetDevicePtr) (saveDeviceNum), return(PAPI_EMISC));\n\n    /* Record that there are no active contexts or events */\n    for (ui=0; ui<gctrl->activeEventCount; ui++) {              // For each active event,\n        int idx = gctrl->activeEventIndex[ui];                  // .. Get its index...\n        gctxt->availEventIsBeingMeasuredInEventset[idx] = 0;    // .. No longer being measured.\n    }\n\n    gctrl->countOfActiveCUContexts = 0;\n    gctrl->activeEventCount = 0;\n    return (PAPI_OK);\n} // end cuda_cleanup_eventset\n\n\n/* Called at thread shutdown. Does nothing in the CUDA component. */\nstatic int _cuda_shutdown_thread(hwd_context_t * ctx)\n{\n    SUBDBG(\"Entering\\n\");\n    (void) ctx;\n\n    return (PAPI_OK);\n}\n\n/* Triggered by PAPI_shutdown() and frees memory allocated in the CUDA component. */\nstatic int _cuda_shutdown_component(void)\n{\n    SUBDBG(\"Entering\\n\");\n    cuda_control_t *gctrl = global_cuda_control;\n    cuda_context_t *gctxt = global_cuda_context;\n    int deviceNum;\n    uint32_t i, cc;\n    /* Free context */\n    if(gctxt) {\n        for(deviceNum = 0; deviceNum < gctxt->deviceCount; deviceNum++) {\n            cuda_device_desc_t *mydevice = &gctxt->deviceArray[deviceNum];\n            papi_free(mydevice->domainIDArray);\n            papi_free(mydevice->domainIDNumEvents);\n        }\n\n        for (i=0; i<gctxt->availEventSize; i++) {                               // For every event in this context,\n            struct cuda_name_desc *desc = &(gctxt->availEventDesc[i]);      // get a name description.\n            if (desc->numMetricEvents > 0) {                                    // If we have any sub-events,\n                papi_free(desc->metricEvents);                                  // .. Free the list of sub-events.\n            }\n        } // end for every available event.\n\n        papi_free(gctxt->availEventIDArray);\n        papi_free(gctxt->availEventDeviceNum);\n        papi_free(gctxt->availEventKind);\n        papi_free(gctxt->availEventIsBeingMeasuredInEventset);\n        papi_free(gctxt->availEventDesc);\n        papi_free(gctxt->deviceArray);\n        papi_free(gctxt);\n        global_cuda_context = gctxt = NULL;\n    }\n    /* Free control */\n    if(gctrl) {\n        for(cc = 0; cc < gctrl->countOfActiveCUContexts; cc++) {\n#ifdef PAPICUDA_KERNEL_REPLAY_MODE\n            CUcontext currCuCtx = gctrl->arrayOfActiveCUContexts[cc]->cuCtx;\n            CUPTI_CALL((*cuptiDisableKernelReplayModePtr) (currCuCtx), return (PAPI_EMISC));\n#endif\n            if(gctrl->arrayOfActiveCUContexts[cc] != NULL)\n                papi_free(gctrl->arrayOfActiveCUContexts[cc]);\n        }\n        papi_free(gctrl);\n        global_cuda_control = gctrl = NULL;\n    }\n    // close the dynamic libraries needed by this component (opened in the init substrate call)\n    dlclose(dl1);\n    dlclose(dl2);\n    dlclose(dl3);\n    return (PAPI_OK);\n} // end cuda_shutdown_component().\n\n\n/* Triggered by PAPI_reset() but only if the EventSet is currently\n *  running. If the eventset is not currently running, then the saved\n *  value in the EventSet is set to zero without calling this\n *  routine.  */\nstatic int _cuda_reset(hwd_context_t * ctx, hwd_control_state_t * ctrl)\n{\n    (void) ctx;\n    (void) ctrl;\n    cuda_control_t *gctrl = global_cuda_control;\n    uint32_t gg, ii, cc, ss;\n    int saveDeviceNum;\n\n    SUBDBG(\"Reset all active event values\\n\");\n    for(ii = 0; ii < gctrl->activeEventCount; ii++)\n        gctrl->activeEventValues[ii] = 0;\n\n    SUBDBG(\"Save current context, then switch to each active device/context and reset\\n\");\n    CUDA_CALL((*cudaGetDevicePtr) (&saveDeviceNum), return (PAPI_EMISC));\n    for(cc = 0; cc < gctrl->countOfActiveCUContexts; cc++) {\n        CUcontext currCuCtx = gctrl->arrayOfActiveCUContexts[cc]->cuCtx;\n        int currDeviceNum = gctrl->arrayOfActiveCUContexts[cc]->deviceNum;\n        if(currDeviceNum != saveDeviceNum)\n            CU_CALL((*cuCtxPushCurrentPtr) (currCuCtx), return (PAPI_EMISC));\n        else\n            CU_CALL((*cuCtxSetCurrentPtr) (currCuCtx), return (PAPI_EMISC));\n        CUpti_EventGroupSets *currEventGroupSets = gctrl->arrayOfActiveCUContexts[cc]->eventGroupSets;\n        for (ss=0; ss<currEventGroupSets->numSets; ss++) {\n            CUpti_EventGroupSet groupset = currEventGroupSets->sets[ss];\n            for(gg = 0; gg < groupset.numEventGroups; gg++) {\n                CUpti_EventGroup group = groupset.eventGroups[gg];\n                CUPTI_CALL((*cuptiEventGroupResetAllEventsPtr) (group), return (PAPI_EMISC));\n            }\n            CUPTI_CALL((*cuptiEventGroupSetEnablePtr) (&groupset), return (PAPI_EMISC));\n        }\n        if(currDeviceNum != saveDeviceNum)\n            CU_CALL((*cuCtxPopCurrentPtr) (&currCuCtx), return (PAPI_EMISC));\n    }\n    return (PAPI_OK);\n} // end cuda_reset().\n\n\n/* This function sets various options in the component - Does nothing in the CUDA component.\n    @param[in] ctx -- hardware context\n    @param[in] code valid are PAPI_SET_DEFDOM, PAPI_SET_DOMAIN, PAPI_SETDEFGRN, PAPI_SET_GRANUL and PAPI_SET_INHERIT\n    @param[in] option -- options to be set\n*/\nstatic int _cuda_ctrl(hwd_context_t * ctx, int code, _papi_int_option_t * option)\n{\n    SUBDBG(\"Entering\\n\");\n    (void) ctx;\n    (void) code;\n    (void) option;\n    return (PAPI_OK);\n}\n\n/*\n * This function has to set the bits needed to count different domains\n * In particular: PAPI_DOM_USER, PAPI_DOM_KERNEL PAPI_DOM_OTHER\n * By default return PAPI_EINVAL if none of those are specified\n * and PAPI_OK with success\n * PAPI_DOM_USER is only user context is counted\n * PAPI_DOM_KERNEL is only the Kernel/OS context is counted\n * PAPI_DOM_OTHER  is Exception/transient mode (like user TLB misses)\n * PAPI_DOM_ALL   is all of the domains\n */\nstatic int _cuda_set_domain(hwd_control_state_t * ctrl, int domain)\n{\n    SUBDBG(\"Entering\\n\");\n    (void) ctrl;\n    if((PAPI_DOM_USER & domain) || (PAPI_DOM_KERNEL & domain) || (PAPI_DOM_OTHER & domain) || (PAPI_DOM_ALL & domain))\n        return (PAPI_OK);\n    else\n        return (PAPI_EINVAL);\n    return (PAPI_OK);\n}\n\n\n/* Enumerate Native Events.\n *   @param EventCode is the event of interest\n *   @param modifier is one of PAPI_ENUM_FIRST, PAPI_ENUM_EVENTS\n */\nstatic int _cuda_ntv_enum_events(unsigned int *EventCode, int modifier)\n{\n    // SUBDBG( \"Entering (get next event after %u)\\n\", *EventCode );\n    switch (modifier) {\n    case PAPI_ENUM_FIRST:\n        *EventCode = 0;\n        return (PAPI_OK);\n        break;\n    case PAPI_ENUM_EVENTS:\n        if (global_cuda_context == NULL) {\n            return (PAPI_ENOEVNT);\n        } else if (*EventCode < global_cuda_context->availEventSize - 1) {\n            *EventCode = *EventCode + 1;\n            return (PAPI_OK);\n        } else {\n            return (PAPI_ENOEVNT);\n        }\n        break;\n    default:\n        return (PAPI_EINVAL);\n    }\n    return (PAPI_OK);\n}\n\n\n/* Takes a native event code and passes back the name\n * @param EventCode is the native event code\n * @param name is a pointer for the name to be copied to\n * @param len is the size of the name string\n */\nstatic int _cuda_ntv_code_to_name(unsigned int EventCode, char *name, int len)\n{\n    // SUBDBG( \"Entering EventCode %d\\n\", EventCode );\n    unsigned int index = EventCode;\n    cuda_context_t *gctxt = global_cuda_context;\n    if(gctxt != NULL && index < gctxt->availEventSize) {\n        strncpy(name, gctxt->availEventDesc[index].name, len);\n    } else {\n        return (PAPI_EINVAL);\n    }\n    // SUBDBG( \"Exit: EventCode %d: Name %s\\n\", EventCode, name );\n    return (PAPI_OK);\n}\n\n\n/* Takes a native event code and passes back the event description\n * @param EventCode is the native event code\n * @param descr is a pointer for the description to be copied to\n * @param len is the size of the descr string\n */\nstatic int _cuda_ntv_code_to_descr(unsigned int EventCode, char *name, int len)\n{\n    // SUBDBG( \"Entering\\n\" );\n    unsigned int index = EventCode;\n    cuda_context_t *gctxt = global_cuda_context;\n    if(gctxt != NULL && index < gctxt->availEventSize) {\n        strncpy(name, gctxt->availEventDesc[index].description, len);\n    } else {\n        return (PAPI_EINVAL);\n    }\n    return (PAPI_OK);\n}\n\n\n/* Vector that points to entry points for the component */\npapi_vector_t _cuda_vector = {\n    .cmp_info = {\n                 /* default component information (unspecified values are initialized to 0) */\n                 .name = \"cuda\",\n                 .short_name = \"cuda\",\n                 .version = \"5.1\",\n                 .description = \"CUDA events and metrics via NVIDIA CuPTI interfaces\",\n                 .num_mpx_cntrs = PAPICUDA_MAX_COUNTERS,\n                 .num_cntrs = PAPICUDA_MAX_COUNTERS,\n                 .default_domain = PAPI_DOM_USER,\n                 .default_granularity = PAPI_GRN_THR,\n                 .available_granularities = PAPI_GRN_THR,\n                 .hardware_intr_sig = PAPI_INT_SIGNAL,\n                 /* component specific cmp_info initializations */\n                 .fast_real_timer = 0,\n                 .fast_virtual_timer = 0,\n                 .attach = 0,\n                 .attach_must_ptrace = 0,\n                 .available_domains = PAPI_DOM_USER | PAPI_DOM_KERNEL,\n                 }\n    ,\n    /* sizes of framework-opaque component-private structures... these are all unused in this component */\n    .size = {\n             .context = 1,      /* sizeof( cuda_context_t ), */\n             .control_state = 1,        /* sizeof( cuda_control_t ), */\n             .reg_value = 1,    /* sizeof( cuda_register_t ), */\n             .reg_alloc = 1,    /* sizeof( cuda_reg_alloc_t ), */\n             }\n    ,\n    /* function pointers in this component */\n    .start = _cuda_start,    /* ( hwd_context_t * ctx, hwd_control_state_t * ctrl ) */\n    .stop = _cuda_stop,      /* ( hwd_context_t * ctx, hwd_control_state_t * ctrl ) */\n    .read = _cuda_read,      /* ( hwd_context_t * ctx, hwd_control_state_t * ctrl, long_long ** events, int flags ) */\n    .reset = _cuda_reset,    /* ( hwd_context_t * ctx, hwd_control_state_t * ctrl ) */\n    .cleanup_eventset = _cuda_cleanup_eventset,      /* ( hwd_control_state_t * ctrl ) */\n\n    .init_component = _cuda_init_component,  /* ( int cidx ) */\n    .init_thread = _cuda_init_thread,        /* ( hwd_context_t * ctx ) */\n    .init_control_state = _cuda_init_control_state,  /* ( hwd_control_state_t * ctrl ) */\n    .update_control_state = _cuda_update_control_state,      /* ( hwd_control_state_t * ptr, NativeInfo_t * native, int count, hwd_context_t * ctx ) */\n\n    .ctl = _cuda_ctrl,       /* ( hwd_context_t * ctx, int code, _papi_int_option_t * option ) */\n    .set_domain = _cuda_set_domain,  /* ( hwd_control_state_t * cntrl, int domain ) */\n    .ntv_enum_events = _cuda_ntv_enum_events,        /* ( unsigned int *EventCode, int modifier ) */\n    .ntv_code_to_name = _cuda_ntv_code_to_name,      /* ( unsigned int EventCode, char *name, int len ) */\n    .ntv_code_to_descr = _cuda_ntv_code_to_descr,    /* ( unsigned int EventCode, char *name, int len ) */\n    .shutdown_thread = _cuda_shutdown_thread,        /* ( hwd_context_t * ctx ) */\n    .shutdown_component = _cuda_shutdown_component,  /* ( void ) */\n};\n\n//-------------------------------------------------------------------------------------------------\n// This routine is an adaptation from 'readMetricValue' in nvlink_bandwidth_cupti_only.cu; where\n// it is shown to work. Note that a metric can consist of more than one event, so the number of\n// events and the number of metrics does not have to match.\n// 'eventGroup' should contain the events needed to read the\n// 'numEvents' is the number of events needed to read to compute the metrics.\n// 'metricId' is the array of METRICS, and\n// 'numMetrics\" is the number of them, and also applies to the arrays 'values' and 'myKinds'.\n// 'dev is the CUDevice needed to compute the metric. We don't need to switch the context, that is\n// already done by the caller so we are pointing at the correct context.\n//-------------------------------------------------------------------------------------------------\nvoid readMetricValue(CUpti_EventGroup eventGroup,\n                    uint32_t numEvents,                         // array COLS in results,\n                    uint64_t numTotalInstances,                 // array ROWS in results,\n                    CUdevice dev,                               // current Device structure.\n                    uint32_t numMetrics,\n                    CUpti_MetricID *metricId,\n                    CUpti_MetricValueKind *myKinds,\n                    long long int *values,\n                    uint64_t timeDuration)\n{\n    size_t bufferSizeBytes, numCountersRead;\n    uint64_t *eventValueArray = NULL;\n    CUpti_EventID *eventIdArray;\n    size_t arraySizeBytes = 0;\n    uint64_t *aggrEventValueArray = NULL;\n    size_t aggrEventValueArraySize;\n    uint32_t i = 0, j = 0;\n\n    arraySizeBytes = sizeof(CUpti_EventID) * numEvents;\n    bufferSizeBytes = sizeof(uint64_t) * numEvents * numTotalInstances;\n\n    eventValueArray = (uint64_t *) malloc(bufferSizeBytes);\n\n    eventIdArray = (CUpti_EventID *) malloc(arraySizeBytes);\n\n    aggrEventValueArray = (uint64_t *) calloc(numEvents, sizeof(uint64_t));\n\n    aggrEventValueArraySize = sizeof(uint64_t) * numEvents;\n\n    CUPTI_CALL( (*cuptiEventGroupReadAllEventsPtr)\n                (eventGroup, CUPTI_EVENT_READ_FLAG_NONE, &bufferSizeBytes,\n                 eventValueArray, &arraySizeBytes, eventIdArray, &numCountersRead),\n                return);\n\n    // Arrangement of 2-d Array returned in eventValueArray:\n    //    domain instance 0: event0 event1 ... eventN\n    //    domain instance 1: event0 event1 ... eventN\n    //    ...\n    //    domain instance M: event0 event1 ... eventN\n    // But we accumulate by column, event[0], event[1], etc.\n\n    for (i = 0; i < numEvents; i++) {                   // outer loop is column (event) we are on.\n        for (j = 0; j < numTotalInstances; j++) {       // inner loop is row (instance) we are on.\n            aggrEventValueArray[i] += eventValueArray[i + numEvents * j];\n        }\n    }\n\n    // After aggregation, we use the data to compose the metrics.\n    for (i = 0; i < numMetrics; i++) {\n        CUpti_MetricValue metricValue;\n        CUPTI_CALL( (*cuptiMetricGetValuePtr)\n                    (dev, metricId[i], arraySizeBytes, eventIdArray,\n                     aggrEventValueArraySize, aggrEventValueArray,\n                     timeDuration, &metricValue),\n                    return);\n\n        _cuda_convert_metric_value_to_long_long(metricValue, myKinds[i], &values[i]);\n    }\n\n    free(eventValueArray);\n    free(eventIdArray);\n} // end readMetricValue.\n\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-papi-6.0.0.1-gmm3tef6bggycxgzrtmq2ejaggc2ozfb/spack-src/src/components/cuda/tests/cuda_ld_preload_example.c": "/*\n  Example of using LD_PRELOAD with the CUDA component.  \n  Asim YarKhan\n\n  This is designed to work with the simpleMultiGPU_no_counters binary\n  in the PAPI CUDA component tests directory.  First trace the library\n  calls in simpleMultiGPU_no_counters binary using ltrace.  Note in\n  the ltrace output that the CUDA C APIs are different from the CUDA\n  calls visible to nvcc. Then figure out appropriate place to attach\n  the PAPI calls.  The initialization is attached to the first entry\n  to cudaSetDevice.  Each cudaSetDevice is also used to setup the PAPI\n  events for that device.  It was harder to figure out where to attach\n  the PAPI_start.  After running some tests, I attached it to the 18th\n  invocation of gettimeofday (kind of arbitrary! Sorry!).  The\n  PAPI_stop was attached to the first invocation of cudaFreeHost.\n\n*/\n\n#define _GNU_SOURCE\n\n#include <stdio.h>\n#include <dlfcn.h>\n\n#include \"papi.h\"\n\n#define MAXDEVICES 5\nint EventSet = PAPI_NULL;\nint devseen[MAXDEVICES] = {0};\n\nstatic void *dl1;\nint (*PAPI_library_init_ptr)(int version); /**< initialize the PAPI library */\nint (*PAPI_create_eventset_ptr)(int *EventSet); /**< create a new empty PAPI event set */\nint (*PAPI_add_named_event_ptr)(int EventSet, char *EventName); /**< add an event by name to a PAPI event set */\nint (*PAPI_start_ptr)(int EventSet); /**< start counting hardware events in an event set */\nint (*PAPI_stop_ptr)(int EventSet, long long * values); /**< stop counting hardware events in an event set and return current events */\n\n\nint cudaSetDevice(int devnum, int n1, int n2, int n3, void *ptr1) \n{\n    static int onetime = 0;\n    int retval, retval_cudaSetDevice;\n    //printf(\"cudaSetDevice wrapper %d\\n\", devnum);\n    if ( onetime==0 ) {\n        onetime=1;\n        // Load the papi library dynamically and read the relevant functions\n        dl1 = dlopen( \"libpapi.so\", RTLD_NOW | RTLD_GLOBAL );\n        if ( dl1==NULL ) printf(\"Intercept cudaSetDevice: Cannot load libpapi.so\\n\");\n        PAPI_library_init_ptr = dlsym( dl1, \"PAPI_library_init\" );\n        PAPI_create_eventset_ptr = dlsym( dl1, \"PAPI_create_eventset\" );\n        PAPI_add_named_event_ptr = dlsym( dl1, \"PAPI_add_named_event\" );\n        PAPI_start_ptr = dlsym( dl1, \"PAPI_start\" );\n        PAPI_stop_ptr = dlsym( dl1, \"PAPI_stop\" );\n        // Start using PAPI\n        printf(\"Intercept cudaSetDevice: Initializing PAPI on device %d\\n\", devnum);\n        retval = (PAPI_library_init_ptr)( PAPI_VER_CURRENT );\n        if( retval != PAPI_VER_CURRENT ) fprintf( stdout, \"PAPI_library_init failed\\n\" );\n        printf( \"PAPI version: %d.%d.%d\\n\", PAPI_VERSION_MAJOR( PAPI_VERSION ), PAPI_VERSION_MINOR( PAPI_VERSION ), PAPI_VERSION_REVISION( PAPI_VERSION ) );\n        retval = (PAPI_create_eventset_ptr)( &EventSet );\n        if( retval != PAPI_OK ) fprintf( stdout, \"PAPI_create_eventset failed\\n\" );\n    }\n    int (*original_function)(int devnum, int n1, int n2, int n3, void *ptr1);\n    original_function = dlsym(RTLD_NEXT, \"cudaSetDevice\");\n    retval_cudaSetDevice = (*original_function)( devnum, n1, n2, n3, ptr1 );\n    if ( devseen[devnum]==0 ) {\n        devseen[devnum]=1;\n        char tmpEventName[120];\n        printf(\"Intercept cudaSetDevice: Attaching events for device on device %d\\n\", devnum);\n        snprintf( tmpEventName, 110, \"cuda:::device:%d:%s\", devnum, \"inst_executed\" );\n        retval = (PAPI_add_named_event_ptr)( EventSet, tmpEventName );\n        if (retval!=PAPI_OK) printf( \"Could not add event %s\\n\", tmpEventName );\n    }\n    return retval_cudaSetDevice;\n}\n\n\nint gettimeofday(void *ptr1, void *ptr2)\n{\n    static int onetime = 0;\n    onetime++;\n    // printf(\"gettimeofday onetime %d\\n\", onetime);\n    // Use above print statement to determine that the N-th gettime of day works\n    if ( onetime==17 ) {\n        printf(\"Intercept gettimeofday: Attaching PAPI_start to the %d th call to gettimeofday (this may need to be adjusted)\\n\", onetime);\n        int retval = (PAPI_start_ptr)( EventSet );\n        printf(\"Starting PAPI\\n\");\n        if( retval!=PAPI_OK ) fprintf( stdout, \"PAPI_start failed\\n\" );\n    }\n    int (*original_function)(void *ptr1, void *ptr2);\n    original_function = dlsym(RTLD_NEXT, \"gettimeofday\");\n    return (*original_function)(ptr1, ptr2);\n}\n\nint cudaFreeHost(void *ptr1, void *ptr2, int n1, int n2, void *ptr3) \n{\n    static int onetime = 0;\n    long long values[10];\n    int retval, devnum;\n    onetime++;\n    if ( onetime==1 ) {\n        printf(\"Intercept cudaFreeHost: Used to get PAPI results\\n\" );\n        retval = (PAPI_stop_ptr)( EventSet, values );\n        if( retval != PAPI_OK )  fprintf( stderr, \"PAPI_stop failed\\n\" );\n        for( devnum = 0; devnum < MAXDEVICES && devseen[devnum]==1  ; devnum++ )\n            printf( \"PAPI counterValue: cuda::device:%d:%s: %12lld \\n\", devnum, \"inst_executed\", values[devnum] );\n    }\n    int (*original_function)(void *ptr1, void *ptr2, int n1, int n2, void *ptr3);\n    original_function = dlsym(RTLD_NEXT, \"cudaFreeHost\");\n    return (*original_function)(ptr1, ptr2, n1, n2, ptr3);\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-papi-6.0.0.1-gmm3tef6bggycxgzrtmq2ejaggc2ozfb/spack-src/src/components/rocm/linux-rocm.c": "/*/\n * @file    linux-rocm.c\n *\n * @ingroup rocm_components\n *\n * @brief This implements a PAPI component that enables PAPI-C to\n *  access hardware monitoring counters for AMD ROCM GPU devices\n *  through the ROC-profiler library.\n *\n * The open source software license for PAPI conforms to the BSD\n * License template.\n */\n\n#include <dlfcn.h>\n#include <hsa.h>\n#include <rocprofiler.h>\n#include <string.h>\n\n#include \"papi.h\"\n#include \"papi_memory.h\"\n#include \"papi_internal.h\"\n#include \"papi_vector.h\"\n\n/* this number assumes that there will never be more events than indicated */\n#define PAPIROCM_MAX_COUNTERS 512\n\n#define BUF_SIZE (32 * 1024)\n#define ALIGN_SIZE (8)\n#define ALIGN_BUFFER(buffer, align)                                     \\\n  (((uintptr_t) (buffer) & ((align)-1)) ? ((buffer) + (align) - ((uintptr_t) (buffer) & ((align)-1))) : (buffer))\n\n#if 0\n#define ROCMDBG(format, args...) fprintf(stderr, format, ## args)\n#else\n//#define ROCMDBG(format, args...) do {} while(0)\n#define ROCMDBG SUBDBG\n#endif\n\n/* Macros for error checking... each arg is only referenced/evaluated once */\n#define CHECK_PRINT_EVAL(checkcond, str, evalthis)                      \\\n    do {                                                                \\\n        int _cond = (checkcond);                                        \\\n        if (_cond) {                                                    \\\n            fprintf(stderr, \"%s:%i error: condition %s failed: %s.\\n\", __FILE__, __LINE__, #checkcond, str); \\\n            evalthis;                                                   \\\n        }                                                               \\\n    } while (0)\n\n#define ROCM_CALL_CK(call, args, handleerror)                           \\\n    do {                                                                \\\n        hsa_status_t _status = (*call##Ptr)args;                        \\\n        if (_status != HSA_STATUS_SUCCESS && _status != HSA_STATUS_INFO_BREAK) {    \\\n            fprintf(stderr, \"%s:%i error: function %s failed with error %d.\\n\",     \\\n            __FILE__, __LINE__, #call, _status);                                    \\\n            handleerror;                                                \\\n        }                                                               \\\n    } while (0)\n\n// Roc Profiler call.\n#define ROCP_CALL_CK(call, args, handleerror)                           \\\n    do {                                                                \\\n        hsa_status_t _status = (*call##Ptr)args;                        \\\n        if (_status != HSA_STATUS_SUCCESS && _status != HSA_STATUS_INFO_BREAK) {     \\\n            const char *profErr;                                                     \\\n            (*rocprofiler_error_stringPtr)(&profErr);                              \\\n            fprintf(stderr, \"%s:%i error: function %s failed with error %d [%s].\\n\", \\\n            __FILE__, __LINE__, #call, _status, profErr);               \\\n            handleerror;                                                \\\n        }                                                               \\\n    } while (0)\n\n#define DLSYM_AND_CHECK(dllib, name)                                    \\\n    do {                                                                \\\n        name##Ptr = dlsym(dllib, #name);                                \\\n        if (dlerror()!=NULL) {                                          \\\n            snprintf(_rocm_vector.cmp_info.disabled_reason,             \\\n                PAPI_MAX_STR_LEN,                                                   \\\n                \"The ROCM required function '%s' was not found in dynamic libs\",    \\\n                #name);                                                             \\\n            fprintf(stderr, \"%s:%i ROCM component disabled: %s\\n\",                  \\\n                __FILE__, __LINE__, _rocm_vector.cmp_info.disabled_reason);         \\\n          return ( PAPI_ENOSUPP );                                      \\\n        }                                                               \\\n    } while (0)\n\ntypedef rocprofiler_t* Context;\ntypedef rocprofiler_feature_t EventID;\n\n// Contains device list, pointer to device description, and the list of available events.\n// Note that \"indexed variables\" in ROCM are read with eventname[%d], where %d is\n// 0 to #instances. This is what we store in the EventID.name element. But the PAPI name\n// doesn't use brackets; so in the ev_name_desc.name we store the user-visible name,\n// something like \"eventname:device=%d:instance=%d\".\ntypedef struct _rocm_context {\n    uint32_t availAgentSize;\n    hsa_agent_t* availAgentArray;\n    uint32_t availEventSize;\n    int *availEventDeviceNum;\n    EventID *availEventIDArray;                         // Note: The EventID struct has its own .name element for ROCM internal operation.\n    uint32_t *availEventIsBeingMeasuredInEventset;\n    struct ev_name_desc *availEventDesc;                // Note: This is where the PAPI name is stored; for user consumption.\n} _rocm_context_t;\n\n/* Store the name and description for an event */\ntypedef struct ev_name_desc {\n    char name[PAPI_MAX_STR_LEN];\n    char description[PAPI_2MAX_STR_LEN];\n} ev_name_desc_t;\n\n/* Control structure tracks array of active contexts, records active events and their values */\ntypedef struct _rocm_control {\n    uint32_t countOfActiveContexts;\n    struct _rocm_active_context_s *arrayOfActiveContexts[PAPIROCM_MAX_COUNTERS];\n    uint32_t activeEventCount;\n    int activeEventIndex[PAPIROCM_MAX_COUNTERS];\n    long long activeEventValues[PAPIROCM_MAX_COUNTERS];\n    uint64_t startTimestampNs;\n    uint64_t readTimestampNs;\n} _rocm_control_t;\n\n/* For each active context, which ROCM events are being measured, context eventgroups containing events */\ntypedef struct _rocm_active_context_s {\n    Context ctx;\n    int deviceNum;\n    uint32_t conEventsCount;\n    EventID conEvents[PAPIROCM_MAX_COUNTERS];\n    int conEventIndex[PAPIROCM_MAX_COUNTERS];\n} _rocm_active_context_t;\n\n/* Function prototypes */\nstatic int _rocm_cleanup_eventset(hwd_control_state_t * ctrl);\n\n// GLOBALS\nstatic void     *dl1 = NULL;\nstatic void     *dl2 = NULL;\nstatic char     rocm_hsa[]=PAPI_ROCM_HSA;\nstatic char     rocm_prof[]=PAPI_ROCM_PROF;\n\n/* ******  CHANGE PROTOTYPES TO DECLARE ROCM LIBRARY SYMBOLS AS WEAK  **********\n *  This is done so that a version of PAPI built with the rocm component can   *\n *  be installed on a system which does not have the rocm libraries installed. *\n *                                                                             *\n *  If this is done without these prototypes, then all papi services on the    *\n *  system without the rocm libraries installed will fail.  The PAPI libraries *\n *  contain references to the rocm libraries which are not installed.  The     *\n *  load of PAPI commands fails because the rocm library references can not be *\n *  resolved.                                                                  *\n *                                                                             *\n *  This also defines pointers to the rocm library functions that we call.     *\n *  These function pointers will be resolved with dlopen/dlsym calls at        *\n *  component initialization time.  The component then calls the rocm library  *\n *  functions through these function pointers.                                 *\n *******************************************************************************/\nvoid (*_dl_non_dynamic_init) (void) __attribute__ ((weak));\n\n#define DECLAREROCMFUNC(funcname, funcsig) \\\n    hsa_status_t __attribute__((weak)) funcname funcsig; \\\n    hsa_status_t(*funcname##Ptr) funcsig;\n\n// ROCR API declaration\nDECLAREROCMFUNC(hsa_init, ());\nDECLAREROCMFUNC(hsa_shut_down, ());\nDECLAREROCMFUNC(hsa_iterate_agents, (hsa_status_t (*)(hsa_agent_t, void*),\n                                     void*));\nDECLAREROCMFUNC(hsa_system_get_info, (hsa_system_info_t, void*));\nDECLAREROCMFUNC(hsa_agent_get_info, (hsa_agent_t agent, hsa_agent_info_t attribute, void* value));\nDECLAREROCMFUNC(hsa_queue_destroy, (hsa_queue_t* queue));\n\n// ROC-profiler API declaration\nDECLAREROCMFUNC(rocprofiler_get_info, (const hsa_agent_t*, rocprofiler_info_kind_t, void *));\nDECLAREROCMFUNC(rocprofiler_iterate_info, (const hsa_agent_t*,\n                                          rocprofiler_info_kind_t,\n                                          hsa_status_t (*)(const rocprofiler_info_data_t, void *), void *));\nDECLAREROCMFUNC(rocprofiler_open, (hsa_agent_t agent,                       // GPU handle\n                                   rocprofiler_feature_t* features,         // [in] profiling features array\n                                   uint32_t feature_count,                  // profiling info count\n                                   rocprofiler_t** context,                 // [out] context object\n                                   uint32_t mode,                           // profiling mode mask\n                                   rocprofiler_properties_t* properties));  // profiling properties\nDECLAREROCMFUNC(rocprofiler_close, (rocprofiler_t*));\nDECLAREROCMFUNC(rocprofiler_group_count, (const rocprofiler_t*, uint32_t*));\nDECLAREROCMFUNC(rocprofiler_start, (rocprofiler_t*, uint32_t));\nDECLAREROCMFUNC(rocprofiler_read, (rocprofiler_t*, uint32_t));\nDECLAREROCMFUNC(rocprofiler_stop, (rocprofiler_t*, uint32_t));\nDECLAREROCMFUNC(rocprofiler_get_data, (rocprofiler_t*, uint32_t));\nDECLAREROCMFUNC(rocprofiler_get_metrics, (const rocprofiler_t*));\nDECLAREROCMFUNC(rocprofiler_reset, (rocprofiler_t*, uint32_t));\nDECLAREROCMFUNC(rocprofiler_error_string, (const char**));\n\n/* The PAPI side (external) variable as a global */\npapi_vector_t _rocm_vector;\n\n/* Global variable for hardware description, event and metric lists */\nstatic _rocm_context_t *global__rocm_context = NULL;\nstatic uint32_t maxEventSize=0;                 // We accumulate all agent counts into this.\nstatic rocprofiler_properties_t global__ctx_properties = {\n  NULL, // queue\n  128, // queue depth\n  NULL, // handler on completion\n  NULL // handler_arg\n};\n\n/* This global variable points to the head of the control state list */\nstatic _rocm_control_t *global__rocm_control = NULL;\n\n\n/*****************************************************************************\n ********  BEGIN FUNCTIONS USED INTERNALLY SPECIFIC TO THIS COMPONENT ********\n *****************************************************************************/\n\n/*\n * Link the necessary ROCM libraries to use the rocm component.  If any of them can not be found, then\n * the ROCM component will just be disabled.  This is done at runtime so that a version of PAPI built\n * with the ROCM component can be installed and used on systems which have the ROCM libraries installed\n * and on systems where these libraries are not installed.\n */\nstatic int _rocm_linkRocmLibraries(void)\n{\n    ROCMDBG(\"Entering _rocm_linkRocmLibraries\\n\");\n\n    char path_name[1024];\n    /* Attempt to guess if we were statically linked to libc, if so bail */\n    if(_dl_non_dynamic_init != NULL) {\n        strncpy(_rocm_vector.cmp_info.disabled_reason, \"The ROCM component does not support statically linking to libc.\", PAPI_MAX_STR_LEN);\n        return PAPI_ENOSUPP;\n    }\n\n    // collect any defined environment variables, or \"NULL\" if not present.\n    char *rocm_root = getenv(\"PAPI_ROCM_ROOT\");\n    dl1 = NULL;                                                 // Ensure reset to NULL.\n\n    // Step 1: Process override if given.\n    if (strlen(rocm_hsa) > 0) {                             // If override given, it has to work.\n        dl1 = dlopen(rocm_hsa, RTLD_NOW | RTLD_GLOBAL);     // Try to open that path.\n        if (dl1 == NULL) {\n            snprintf(_rocm_vector.cmp_info.disabled_reason, PAPI_MAX_STR_LEN, \"PAPI_ROCM_HSA override '%s' given in Rules.rocm not found.\", rocm_hsa);\n            return(PAPI_ENOSUPP);   // Override given but not found.\n        }\n    }\n\n    // Step 2: Try system paths, will work with Spack, LD_LIBRARY_PATH, default paths.\n    if (dl1 == NULL) {                                                  // No override,\n        dl1 = dlopen(\"libhsa-runtime64.so\", RTLD_NOW | RTLD_GLOBAL);    // Try system paths.\n    }\n\n    // Step 3: Try the explicit install default.\n    if (dl1 == NULL && rocm_root != NULL) {                          // if root given, try it.\n        snprintf(path_name, 1024, \"%s/lib/libhsa-runtime64.so\", rocm_root);  // PAPI Root check.\n        dl1 = dlopen(path_name, RTLD_NOW | RTLD_GLOBAL);             // Try to open that path.\n    }\n\n    // Check for failure.\n    if (dl1 == NULL) {\n        snprintf(_rocm_vector.cmp_info.disabled_reason, PAPI_MAX_STR_LEN, \"libhsa-runtime64.so not found.\");\n        return(PAPI_ENOSUPP);\n    }\n\n    // We have a dl1. (libhsa-runtime64.so).\n\n    DLSYM_AND_CHECK(dl1, hsa_init);\n    DLSYM_AND_CHECK(dl1, hsa_iterate_agents);\n    DLSYM_AND_CHECK(dl1, hsa_system_get_info);\n    DLSYM_AND_CHECK(dl1, hsa_agent_get_info);\n    DLSYM_AND_CHECK(dl1, hsa_shut_down);\n    DLSYM_AND_CHECK(dl1, hsa_queue_destroy);\n\n    //-------------------------------------------------------------------------\n\n    dl2 = NULL;                                                 // Ensure reset to NULL.\n\n    // Step 1: Process override if given.\n    if (strlen(rocm_prof) > 0) {                             // If override given, it has to work.\n        dl2 = dlopen(rocm_prof, RTLD_NOW | RTLD_GLOBAL);     // Try to open that path.\n        if (dl1 == NULL) {\n            snprintf(_rocm_vector.cmp_info.disabled_reason, PAPI_MAX_STR_LEN, \"PAPI_ROCM_PROF override '%s' given in Rules.rocm not found.\", rocm_prof);\n            return(PAPI_ENOSUPP);   // Override given but not found.\n        }\n    }\n\n    // Step 2: Try system paths, will work with Spack, LD_LIBRARY_PATH, default paths.\n    if (dl2 == NULL) {                                                  // No override,\n        dl2 = dlopen(\"librocprofiler64.so\", RTLD_NOW | RTLD_GLOBAL);    // Try system paths.\n    }\n\n    // Step 3: Try the explicit install default.\n    if (dl2 == NULL && rocm_root != NULL) {                          // if root given, try it.\n        snprintf(path_name, 1024, \"%s/lib/librocprofiler64.so\", rocm_root);  // PAPI Root check.\n        dl2 = dlopen(path_name, RTLD_NOW | RTLD_GLOBAL);             // Try to open that path.\n    }\n\n    // Check for failure.\n    if (dl2 == NULL) {\n        snprintf(_rocm_vector.cmp_info.disabled_reason, PAPI_MAX_STR_LEN, \"librocprofiler64.so not found.\");\n        return(PAPI_ENOSUPP);\n    }\n\n    // We have a dl2. (librocprofiler64.so).\n\n    DLSYM_AND_CHECK(dl2, rocprofiler_get_info);\n    DLSYM_AND_CHECK(dl2, rocprofiler_iterate_info);\n    DLSYM_AND_CHECK(dl2, rocprofiler_open);\n    DLSYM_AND_CHECK(dl2, rocprofiler_close);\n    DLSYM_AND_CHECK(dl2, rocprofiler_group_count);\n    DLSYM_AND_CHECK(dl2, rocprofiler_start);\n    DLSYM_AND_CHECK(dl2, rocprofiler_read);\n    DLSYM_AND_CHECK(dl2, rocprofiler_stop);\n    DLSYM_AND_CHECK(dl2, rocprofiler_get_data);\n    DLSYM_AND_CHECK(dl2, rocprofiler_get_metrics);\n    DLSYM_AND_CHECK(dl2, rocprofiler_reset);\n    DLSYM_AND_CHECK(dl2, rocprofiler_error_string);\n\n    // Disable if ROCPROFILER env vars not present.\n    if (getenv(\"ROCP_METRICS\") == NULL) {\n        snprintf(_rocm_vector.cmp_info.disabled_reason, PAPI_MAX_STR_LEN, \"Env. Var. ROCP_METRICS not set; rocprofiler is not configured.\");\n        return(PAPI_ENOSUPP);   // Wouldn't have any events.\n    }\n\n    if (getenv(\"ROCPROFILER_LOG\") == NULL) {\n        snprintf(_rocm_vector.cmp_info.disabled_reason, PAPI_MAX_STR_LEN, \"Env. Var. ROCPROFILER_LOG not set; rocprofiler is not configured.\");\n        return(PAPI_ENOSUPP);   // Wouldn't have any events.\n    }\n\n    if (getenv(\"HSA_VEN_AMD_AQLPROFILE_LOG\") == NULL) {\n        snprintf(_rocm_vector.cmp_info.disabled_reason, PAPI_MAX_STR_LEN, \"Env. Var. HSA_VEN_AMD_AQLPROFILE_LOG not set; rocprofiler is not configured.\");\n        return(PAPI_ENOSUPP);   // Wouldn't have any events.\n    }\n\n    if (getenv(\"AQLPROFILE_READ_API\") == NULL) {\n        snprintf(_rocm_vector.cmp_info.disabled_reason, PAPI_MAX_STR_LEN, \"Env. Var.AQLPROFILE_READ_API not set; rocprofiler is not configured.\");\n        return(PAPI_ENOSUPP);   // Wouldn't have any events.\n    }\n\n    return (PAPI_OK);\n}\n\n\n// ----------------------------------------------------------------------------\n// Callback function to get the number of agents\nstatic hsa_status_t _rocm_get_gpu_handle(hsa_agent_t agent, void* arg)\n{\n  _rocm_context_t * gctxt = (_rocm_context_t*) arg;\n\n  hsa_device_type_t type;\n  ROCM_CALL_CK(hsa_agent_get_info,(agent, HSA_AGENT_INFO_DEVICE, &type), return (PAPI_EMISC));\n\n  // Device is a GPU agent\n  if (type == HSA_DEVICE_TYPE_GPU) {\n    gctxt->availAgentSize += 1;\n    gctxt->availAgentArray = (hsa_agent_t*) papi_realloc(gctxt->availAgentArray, (gctxt->availAgentSize*sizeof(hsa_agent_t)));\n    gctxt->availAgentArray[gctxt->availAgentSize - 1] = agent;\n  }\n\n  return HSA_STATUS_SUCCESS;\n}\n\ntypedef struct {\n    int device_num;\n    int count;\n    _rocm_context_t * ctx;\n} events_callback_arg_t;\n\n// ----------------------------------------------------------------------------\n// Callback function to get the number of events we will see;\n// Each element of instanced metrics must be created as a separate event\nstatic hsa_status_t _rocm_count_native_events_callback(const rocprofiler_info_data_t info, void * arg)\n{\n    const uint32_t instances = info.metric.instances;\n    uint32_t* count = (uint32_t*) arg;\n    (*count) += instances;\n    return HSA_STATUS_SUCCESS;\n} // END CALLBACK.\n\n\n// ----------------------------------------------------------------------------\n// Callback function that adds individual events.\nstatic hsa_status_t _rocm_add_native_events_callback(const rocprofiler_info_data_t info, void * arg)\n{\n    uint32_t ui;\n    events_callback_arg_t * callback_arg = (events_callback_arg_t*) arg;\n    _rocm_context_t * ctx = callback_arg->ctx;\n    const uint32_t eventDeviceNum = callback_arg->device_num;\n    const uint32_t count = callback_arg->count;\n          uint32_t index = ctx->availEventSize;\n    const uint32_t instances = info.metric.instances;   // short cut to instances.\n\n\n//  information about AMD Event.\n//   fprintf(stderr, \"%s:%i name=%s block_name=%s, instances=%i block_counters=%i.\\n\",\n//      __FILE__, __LINE__, info.metric.name, info.metric.block_name, info.metric.instances,\n//      info.metric.block_counters);\n    if (index + instances > count) return HSA_STATUS_ERROR; // Should have enough space.\n\n    for (ui=0; ui<instances; ui++) {\n      char ROCMname[PAPI_MAX_STR_LEN];\n\n        if (instances > 1) {\n            snprintf(ctx->availEventDesc[index].name,\n                PAPI_MAX_STR_LEN, \"%s:device=%d:instance=%d\",       // What PAPI user sees.\n                info.metric.name, eventDeviceNum, ui);\n            snprintf(ROCMname, PAPI_MAX_STR_LEN, \"%s[%d]\",\n                info.metric.name, ui);                               // use indexed version.\n        } else {\n            snprintf(ctx->availEventDesc[index].name,\n                PAPI_MAX_STR_LEN, \"%s:device=%d\",                   // What PAPI user sees.\n                info.metric.name, eventDeviceNum);\n            snprintf(ROCMname, PAPI_MAX_STR_LEN, \"%s\",\n                info.metric.name);                                  // use non-indexed version.\n        }\n\n        ROCMname[PAPI_MAX_STR_LEN - 1] = '\\0';                      // ensure z-terminated.\n        strncpy(ctx->availEventDesc[index].description, info.metric.description, PAPI_2MAX_STR_LEN);\n        ctx->availEventDesc[index].description[PAPI_2MAX_STR_LEN - 1] = '\\0';   // ensure z-terminated.\n\n        EventID eventId;                                            // Removed declaration init.\n        eventId.kind = ROCPROFILER_FEATURE_KIND_METRIC;\n        eventId.name = strdup(ROCMname);                            // what ROCM needs to see.\n        eventId.parameters = NULL;                                  // Not currently used, but init for safety.\n        eventId.parameter_count=0;                                  // Not currently used, but init for safety.\n\n        ctx->availEventDeviceNum[index] = eventDeviceNum;\n        ctx->availEventIDArray[index] = eventId;\n        index++;                                                    // increment index.\n        ctx->availEventSize = index;                                // Always set availEventSize.\n    } // end for each instance.\n\n    return HSA_STATUS_SUCCESS;\n} // end CALLBACK, _rocm_add_native_events_callback\n\n// ----------------------------------------------------------------------------\n// function called during initialization.\nstatic int _rocm_add_native_events(_rocm_context_t * ctx)\n{\n    ROCMDBG(\"Entering _rocm_add_native_events\\n\");\n\n    uint32_t i;\n\n    // Count all events in all agents; Each element of 'indexed' metrics is considered a separate event.\n    // NOTE: The environment variable ROCP_METRICS should point at a path and file like metrics.xml.\n    //       If that file doesn't exist, this iterate info fails with a general error (0x1000).\n    // NOTE: We are *accumulating* into maxEventSize.\n    for (i = 0; i < ctx->availAgentSize; i++) {\n        ROCP_CALL_CK(rocprofiler_iterate_info, (&(ctx->availAgentArray[i]), ROCPROFILER_INFO_KIND_METRIC,\n            _rocm_count_native_events_callback, (void*)(&maxEventSize)), return (PAPI_EMISC));\n    }\n\n    /* Allocate space for all events and descriptors, includes space for instances. */\n    ctx->availEventDeviceNum = (int *) papi_calloc(maxEventSize, sizeof(int));\n    CHECK_PRINT_EVAL((ctx->availEventDeviceNum == NULL), \"ERROR ROCM: Could not allocate memory\", return (PAPI_ENOMEM));\n    ctx->availEventIDArray = (EventID *) papi_calloc(maxEventSize, sizeof(EventID));\n    CHECK_PRINT_EVAL((ctx->availEventIDArray == NULL), \"ERROR ROCM: Could not allocate memory\", return (PAPI_ENOMEM));\n    ctx->availEventIsBeingMeasuredInEventset = (uint32_t *) papi_calloc(maxEventSize, sizeof(uint32_t));\n    CHECK_PRINT_EVAL((ctx->availEventIsBeingMeasuredInEventset == NULL), \"ERROR ROCM: Could not allocate memory\", return (PAPI_ENOMEM));\n    ctx->availEventDesc = (ev_name_desc_t *) papi_calloc(maxEventSize, sizeof(ev_name_desc_t));\n    CHECK_PRINT_EVAL((ctx->availEventDesc == NULL), \"ERROR ROCM: Could not allocate memory\", return (PAPI_ENOMEM));\n\n    for (i = 0; i < ctx->availAgentSize; ++i) {\n        events_callback_arg_t arg;\n        arg.device_num = i;\n        arg.count = maxEventSize;\n        arg.ctx = ctx;\n        ROCP_CALL_CK(rocprofiler_iterate_info, (&(ctx->availAgentArray[i]), ROCPROFILER_INFO_KIND_METRIC,\n            _rocm_add_native_events_callback, (void*)(&arg)), return (PAPI_EMISC));\n    }\n\n    /* return 0 if everything went OK */\n    return 0;\n}\n\n\n/*****************************************************************************\n *******************  BEGIN PAPI's COMPONENT REQUIRED FUNCTIONS  *************\n *****************************************************************************/\n\n/*\n * This is called whenever a thread is initialized.\n */\nstatic int _rocm_init_thread(hwd_context_t * ctx)\n{\n    ROCMDBG(\"Entering _rocm_init_thread\\n\");\n\n    (void) ctx;\n    return PAPI_OK;\n}\n\n\n/* Initialize hardware counters, setup the function vector table\n * and get hardware information, this routine is called when the\n * PAPI process is initialized (IE PAPI_library_init)\n */\nstatic int _rocm_init_component(int cidx)\n{\n    ROCMDBG(\"Entering _rocm_init_component\\n\");\n\n    /* link in all the rocm libraries and resolve the symbols we need to use */\n    if(_rocm_linkRocmLibraries() != PAPI_OK) {\n        SUBDBG(\"Dynamic link of ROCM libraries failed, component will be disabled.\\n\");\n        SUBDBG(\"See disable reason in papi_component_avail output for more details.\\n\");\n        return (PAPI_ENOSUPP);\n    }\n\n    ROCM_CALL_CK(hsa_init, (), return (PAPI_EMISC));\n\n    /* Create the structure */\n    if(global__rocm_context == NULL)\n        global__rocm_context = (_rocm_context_t *) papi_calloc(1, sizeof(_rocm_context_t));\n\n    /* Get GPU agent */\n    ROCM_CALL_CK(hsa_iterate_agents, (_rocm_get_gpu_handle, global__rocm_context), return (PAPI_EMISC));\n\n    int rv;\n\n    /* Get list of all native ROCM events supported */\n    rv = _rocm_add_native_events(global__rocm_context);\n    if(rv != 0)\n        return (rv);\n\n    /* Export some information */\n    _rocm_vector.cmp_info.CmpIdx = cidx;\n    _rocm_vector.cmp_info.num_native_events = global__rocm_context->availEventSize;\n    _rocm_vector.cmp_info.num_cntrs = _rocm_vector.cmp_info.num_native_events;\n    _rocm_vector.cmp_info.num_mpx_cntrs = _rocm_vector.cmp_info.num_native_events;\n\n    ROCMDBG(\"Exiting _rocm_init_component cidx %d num_native_events %d num_cntrs %d num_mpx_cntrs %d\\n\",\n        cidx,\n        _rocm_vector.cmp_info.num_native_events,\n        _rocm_vector.cmp_info.num_cntrs,\n        _rocm_vector.cmp_info.num_mpx_cntrs);\n\n    if (_rocm_vector.cmp_info.num_native_events == 0) {\n        char *metrics = getenv(\"ROCP_METRICS\");\n        if (metrics == NULL) {\n            strncpy(_rocm_vector.cmp_info.disabled_reason, \"Environment Variable ROCP_METRICS is not defined, should point to a valid metrics.xml.\", PAPI_MAX_STR_LEN);\n            return (PAPI_EMISC);\n        }\n\n        snprintf(_rocm_vector.cmp_info.disabled_reason, PAPI_MAX_STR_LEN, \"No events.  Ensure ROCP_METRICS=%s is correct.\", metrics);\n        return (PAPI_EMISC);\n    }\n\n    return (PAPI_OK);\n}\n\n\n/* Setup a counter control state.\n *   In general a control state holds the hardware info for an\n *   EventSet.\n */\nstatic int _rocm_init_control_state(hwd_control_state_t * ctrl)\n{\n    ROCMDBG(\"Entering _rocm_init_control_state\\n\");\n\n    (void) ctrl;\n    _rocm_context_t *gctxt = global__rocm_context;\n\n    CHECK_PRINT_EVAL((gctxt == NULL), \"Error: The PAPI ROCM component needs to be initialized first\", return (PAPI_ENOINIT));\n    /* If no events were found during the initial component initialization, return error */\n    if(global__rocm_context->availEventSize <= 0) {\n        strncpy(_rocm_vector.cmp_info.disabled_reason, \"ERROR ROCM: No events exist\", PAPI_MAX_STR_LEN);\n        return (PAPI_EMISC);\n    }\n    /* If it does not exist, create the global structure to hold ROCM contexts and active events */\n    if(global__rocm_control == NULL) {\n        global__rocm_control = (_rocm_control_t *) papi_calloc(1, sizeof(_rocm_control_t));\n        global__rocm_control->countOfActiveContexts = 0;\n        global__rocm_control->activeEventCount = 0;\n    }\n    return PAPI_OK;\n}\n\n\n/* Triggered by eventset operations like add or remove.  For ROCM,\n * needs to be called multiple times from each seperate ROCM context\n * with the events to be measured from that context.  For each\n * context, create eventgroups for the events.\n */\n/* Note: NativeInfo_t is defined in papi_internal.h */\nstatic int _rocm_update_control_state(hwd_control_state_t * ctrl, NativeInfo_t * nativeInfo, int nativeCount, hwd_context_t * ctx)\n{\n    ROCMDBG(\"Entering _rocm_update_control_state with nativeCount %d\\n\", nativeCount);\n\n    (void) ctx;\n    _rocm_control_t *gctrl = global__rocm_control;\n    _rocm_context_t *gctxt = global__rocm_context;\n    int eventContextIdx = 0;\n    int index, ii;\n    uint32_t cc;\n    uint32_t numPasses = 1;\n\n    /* Return if no events */\n    if(nativeCount == 0)\n        return (PAPI_OK);\n\n    /* Handle user request of events to be monitored */\n    for(ii = 0; ii < nativeCount; ii++) {\n        /* Get the PAPI event index from the user */\n        index = nativeInfo[ii].ni_event;\n        char *eventName = gctxt->availEventDesc[index].name;\n        (void) eventName;\n        int eventDeviceNum = gctxt->availEventDeviceNum[index];\n\n        /* if this event is already added continue to next ii, if not, mark it as being added */\n        if(gctxt->availEventIsBeingMeasuredInEventset[index] == 1) {\n            ROCMDBG(\"Skipping event %s (%i of %i) which is already added\\n\", eventName, ii, nativeCount);\n            continue;\n        } else {\n            gctxt->availEventIsBeingMeasuredInEventset[index] = 1;\n        }\n\n        /* Find context/control in papirocm, creating it if does not exist */\n        for(cc = 0; cc < gctrl->countOfActiveContexts; cc++) {\n            CHECK_PRINT_EVAL(cc >= PAPIROCM_MAX_COUNTERS, \"Exceeded hardcoded maximum number of contexts (PAPIROCM_MAX_COUNTERS)\", return (PAPI_EMISC));\n            if(gctrl->arrayOfActiveContexts[cc]->deviceNum == eventDeviceNum) {\n                break;\n            }\n        }\n        // Create context if it does not exist\n        if(cc == gctrl->countOfActiveContexts) {\n            ROCMDBG(\"Event %s device %d does not have a ctx registered yet...\\n\", eventName, eventDeviceNum);\n            gctrl->arrayOfActiveContexts[cc] = papi_calloc(1, sizeof(_rocm_active_context_t));\n            CHECK_PRINT_EVAL(gctrl->arrayOfActiveContexts[cc] == NULL, \"Memory allocation for new active context failed\", return (PAPI_ENOMEM));\n            gctrl->arrayOfActiveContexts[cc]->deviceNum = eventDeviceNum;\n            gctrl->arrayOfActiveContexts[cc]->ctx = NULL;\n            gctrl->arrayOfActiveContexts[cc]->conEventsCount = 0;\n            gctrl->countOfActiveContexts++;\n            ROCMDBG(\"Added a new context deviceNum %d ... now countOfActiveContexts is %d\\n\", eventDeviceNum, gctrl->countOfActiveContexts);\n        }\n        eventContextIdx = cc;\n\n        _rocm_active_context_t *eventctrl = gctrl->arrayOfActiveContexts[eventContextIdx];\n        ROCMDBG(\"Need to add event %d %s to the context\\n\", index, eventName);\n        // Now we have eventctrl, we can check on max event count.\n        if (eventctrl->conEventsCount >= PAPIROCM_MAX_COUNTERS) {\n            ROCMDBG(\"Num events exceeded PAPIROCM_MAX_COUNTERS\\n\");\n            return(PAPI_EINVAL);\n        }\n\n        /* lookup eventid for this event index */\n        EventID eventId = gctxt->availEventIDArray[index];\n        eventctrl->conEvents[eventctrl->conEventsCount] = eventId;\n        eventctrl->conEventIndex[eventctrl->conEventsCount] = index;\n        eventctrl->conEventsCount++;\n//      fprintf(stderr, \"%s:%d Added eventId.name='%s' as conEventsCount=%i with index=%i.\\n\", __FILE__, __LINE__, eventId.name, eventctrl->conEventsCount-1, index); // test indexed events.\n\n        /* Record index of this active event back into the nativeInfo structure */\n        nativeInfo[ii].ni_position = gctrl->activeEventCount;\n        /* record added event at the higher level */\n        CHECK_PRINT_EVAL(gctrl->activeEventCount == PAPIROCM_MAX_COUNTERS - 1, \"Exceeded maximum num of events (PAPI_MAX_COUNTERS)\", return (PAPI_EMISC));\n        gctrl->activeEventIndex[gctrl->activeEventCount] = index;\n        gctrl->activeEventValues[gctrl->activeEventCount] = 0;\n        gctrl->activeEventCount++;\n\n        /* Create/recreate eventgrouppass structures for the added event and context */\n        ROCMDBG(\"Create eventGroupPasses for context (destroy pre-existing) (nativeCount %d, conEventsCount %d) \\n\", gctrl->activeEventCount, eventctrl->conEventsCount);\n        if(eventctrl->conEventsCount > 0) {\n            if (eventctrl->ctx != NULL) {\n                ROCP_CALL_CK(rocprofiler_close, (eventctrl->ctx), return (PAPI_EMISC));\n            }\n            int openFailed=0;\n//          fprintf(stderr,\"%s:%i calling rocprofiler_open, ii=%i device=%i numEvents=%i name='%s'.\\n\", __FILE__, __LINE__, ii, eventDeviceNum, eventctrl->conEventsCount, eventId.name);\n            const uint32_t mode = (global__ctx_properties.queue != NULL) ? ROCPROFILER_MODE_STANDALONE : ROCPROFILER_MODE_STANDALONE | ROCPROFILER_MODE_CREATEQUEUE;\n            ROCP_CALL_CK(rocprofiler_open, (gctxt->availAgentArray[eventDeviceNum], eventctrl->conEvents, eventctrl->conEventsCount, &(eventctrl->ctx),\n                         mode, &global__ctx_properties), openFailed=1);\n            if (openFailed) {                       // If the open failed,\n                ROCMDBG(\"Error occurred: The ROCM event was not accepted by the ROCPROFILER.\\n\");\n//              fprintf(stderr, \"Error occurred: The ROCM event '%s' was not accepted by the ROCPROFILER.\\n\", eventId.name);\n                _rocm_cleanup_eventset(ctrl);       // Try to cleanup,\n//              fprintf(stderr, \"%s:%i Returning PAPI_ECOMBO.\\n\", __FILE__, __LINE__);\n                return(PAPI_ECOMBO);                // Say its a bad combo.\n            }\n\n            ROCP_CALL_CK(rocprofiler_group_count, (eventctrl->ctx, &numPasses), return (PAPI_EMISC));\n\n            if (numPasses > 1) {\n                ROCMDBG(\"Error occurred: The combined ROCM events require more than 1 pass... try different events\\n\");\n                _rocm_cleanup_eventset(ctrl);\n                return(PAPI_ECOMBO);\n            } else  {\n                ROCMDBG(\"Created eventGroupPasses for context total-events %d in-this-context %d passes-required %d) \\n\", gctrl->activeEventCount, eventctrl->conEventsCount, numPasses);\n            }\n        }\n    }\n    return (PAPI_OK);\n}\n\n\n/* Triggered by PAPI_start().\n * For ROCM component, switch to each context and start all eventgroups.\n */\nstatic int _rocm_start(hwd_context_t * ctx, hwd_control_state_t * ctrl)\n{\n    ROCMDBG(\"Entering _rocm_start\\n\");\n\n    (void) ctx;\n    (void) ctrl;\n    _rocm_control_t *gctrl = global__rocm_control;\n    uint32_t ii, cc;\n\n    ROCMDBG(\"Reset all active event values\\n\");\n    for(ii = 0; ii < gctrl->activeEventCount; ii++)\n        gctrl->activeEventValues[ii] = 0;\n\n    ROCM_CALL_CK(hsa_system_get_info, (HSA_SYSTEM_INFO_TIMESTAMP, &gctrl->startTimestampNs), return (PAPI_EMISC));\n    for(cc = 0; cc < gctrl->countOfActiveContexts; cc++) {\n        int eventDeviceNum = gctrl->arrayOfActiveContexts[cc]->deviceNum;\n        (void) eventDeviceNum;                                          // suppress \"not used\" error when not debug.\n        Context eventCtx = gctrl->arrayOfActiveContexts[cc]->ctx;\n        ROCMDBG(\"Start device %d ctx %p ts %lu\\n\", eventDeviceNum, eventCtx, gctrl->startTimestampNs);\n        if (eventCtx == NULL) abort();\n        ROCP_CALL_CK(rocprofiler_start, (eventCtx, 0), return (PAPI_EMISC));\n    }\n\n    return (PAPI_OK);\n}\n\n\n/* Triggered by PAPI_read().  For ROCM component, switch to each\n * context, read all the eventgroups, and put the values in the\n * correct places. */\nstatic int _rocm_read(hwd_context_t * ctx, hwd_control_state_t * ctrl, long long **values, int flags)\n{\n    ROCMDBG(\"Entering _rocm_read\\n\");\n\n    (void) ctx;\n    (void) ctrl;\n    (void) flags;\n    _rocm_control_t *gctrl = global__rocm_control;\n    _rocm_context_t *gctxt = global__rocm_context;\n    uint32_t cc, jj, ee;\n\n    // Get read time stamp\n    ROCM_CALL_CK(hsa_system_get_info, (HSA_SYSTEM_INFO_TIMESTAMP, &gctrl->readTimestampNs), return (PAPI_EMISC));\n    uint64_t durationNs = gctrl->readTimestampNs - gctrl->startTimestampNs;\n    (void) durationNs;                                                  // Suppress 'not used' warning when not debug.\n    gctrl->startTimestampNs = gctrl->readTimestampNs;\n\n\n    for(cc = 0; cc < gctrl->countOfActiveContexts; cc++) {\n        int eventDeviceNum = gctrl->arrayOfActiveContexts[cc]->deviceNum;\n        Context eventCtx = gctrl->arrayOfActiveContexts[cc]->ctx;\n        ROCMDBG(\"Read device %d ctx %p(%u) ts %lu\\n\", eventDeviceNum, eventCtx, cc, gctrl->readTimestampNs);\n        ROCP_CALL_CK(rocprofiler_read, (eventCtx, 0), return (PAPI_EMISC));\n        ROCMDBG(\"waiting for data\\n\");\n        ROCP_CALL_CK(rocprofiler_get_data, (eventCtx, 0), return (PAPI_EMISC));\n        ROCP_CALL_CK(rocprofiler_get_metrics, (eventCtx), return (PAPI_EMISC));\n        ROCMDBG(\"done\\n\");\n\n        for(jj = 0; jj < gctrl->activeEventCount; jj++) {\n            int index = gctrl->activeEventIndex[jj];\n            EventID eventId = gctxt->availEventIDArray[index];\n            ROCMDBG(\"jj=%i of %i, index=%i, device#=%i.\\n\", jj, gctrl->activeEventCount, index, gctxt->availEventDeviceNum[index]);\n            (void) eventId;                                             // Suppress 'not used' warning when not debug.\n\n            /* If the device/context does not match the current context, move to next */\n            if(gctxt->availEventDeviceNum[index] != eventDeviceNum)\n                continue;\n\n            for(ee = 0; ee < gctrl->arrayOfActiveContexts[cc]->conEventsCount; ee++) {\n                ROCMDBG(\"Searching for activeEvent %s in Activecontext %u eventIndex %d duration %lu\\n\", eventId.name, ee, index, durationNs);\n                if (gctrl->arrayOfActiveContexts[cc]->conEventIndex[ee] == index) {\n                  gctrl->activeEventValues[jj] = gctrl->arrayOfActiveContexts[cc]->conEvents[ee].data.result_int64;\n                  ROCMDBG(\"Matched event %d:%d eventName %s value %lld\\n\", jj, index, eventId.name, gctrl->activeEventValues[jj]);\n                  break;\n                }\n            }\n        }\n    }\n\n    *values = gctrl->activeEventValues;\n    return (PAPI_OK);\n}\n\n\n/* Triggered by PAPI_stop() */\nstatic int _rocm_stop(hwd_context_t * ctx, hwd_control_state_t * ctrl)\n{\n    ROCMDBG(\"Entering _rocm_stop\\n\");\n\n    (void) ctx;\n    (void) ctrl;\n    _rocm_control_t *gctrl = global__rocm_control;\n    uint32_t cc;\n\n    for(cc = 0; cc < gctrl->countOfActiveContexts; cc++) {\n        int eventDeviceNum = gctrl->arrayOfActiveContexts[cc]->deviceNum;\n        (void) eventDeviceNum;                                          // Suppress 'not used' warning when not debug.\n        Context eventCtx = gctrl->arrayOfActiveContexts[cc]->ctx;\n        ROCMDBG(\"Stop device %d ctx %p \\n\", eventDeviceNum, eventCtx);\n        ROCP_CALL_CK(rocprofiler_stop, (eventCtx, 0), return (PAPI_EMISC));\n    }\n\n    return (PAPI_OK);\n} // END ROUTINE.\n\n/*\n * Disable and destroy the ROCM eventGroup\n */\nstatic int _rocm_cleanup_eventset(hwd_control_state_t * ctrl)\n{\n    ROCMDBG(\"Entering _rocm_cleanup_eventset\\n\");\n//  fprintf(stderr, \"%s:%i _rocm_cleanup_eventset called.\\n\", __FILE__, __LINE__);\n\n    (void) ctrl;\n    _rocm_control_t *gctrl = global__rocm_control;\n    uint32_t i, cc;\n\n    for(cc = 0; cc < gctrl->countOfActiveContexts; cc++) {\n        int eventDeviceNum = gctrl->arrayOfActiveContexts[cc]->deviceNum;\n        (void) eventDeviceNum;                                          // Suppress 'not used' warning when not debug.\n        Context eventCtx = gctrl->arrayOfActiveContexts[cc]->ctx;\n        ROCMDBG(\"Destroy device %d ctx %p \\n\", eventDeviceNum, eventCtx);\n//      fprintf(stderr, \"%s:%i About to call rocprofiler_close.\\n\", __FILE__, __LINE__);\n        ROCP_CALL_CK(rocprofiler_close, (eventCtx), return (PAPI_EMISC));\n//      fprintf(stderr, \"%s:%i Returned from call to rocprofiler_close, papi_free ptr=%p.\\n\", __FILE__, __LINE__, gctrl->arrayOfActiveContexts[cc] );\n        papi_free( gctrl->arrayOfActiveContexts[cc] );\n//      fprintf(stderr, \"%s:%i Returned from call to papi_free.\\n\", __FILE__, __LINE__);\n    }\n    if (global__ctx_properties.queue != NULL) {\n      ROCM_CALL_CK(hsa_queue_destroy, (global__ctx_properties.queue), return (PAPI_EMISC));\n      global__ctx_properties.queue = NULL;\n    }\n    /* Record that there are no active contexts or events */\n//  fprintf(stderr, \"%s:%i Checkpoint, maxEventSize=%i.\\n\", __FILE__, __LINE__, maxEventSize);\n    gctrl->countOfActiveContexts = 0;\n    gctrl->activeEventCount = 0;\n\n    /* Clear all indicators of event being measured. */\n    _rocm_context_t *gctxt = global__rocm_context;\n    for (i=0; i<maxEventSize; i++) {\n            gctxt->availEventIsBeingMeasuredInEventset[i] = 0;\n    }\n\n//  fprintf(stderr, \"%s:%i Returning from _rocm_cleanup_eventset.\\n\", __FILE__, __LINE__);\n    return (PAPI_OK);\n}\n\n\n/* Called at thread shutdown. Does nothing in the ROCM component. */\nstatic int _rocm_shutdown_thread(hwd_context_t * ctx)\n{\n    ROCMDBG(\"Entering _rocm_shutdown_thread\\n\");\n\n    (void) ctx;\n    return (PAPI_OK);\n}\n\n\n/* Triggered by PAPI_shutdown() and frees memory allocated in the ROCM component. */\nstatic int _rocm_shutdown_component(void)\n{\n    ROCMDBG(\"Entering _rocm_shutdown_component\\n\");\n\n    _rocm_control_t *gctrl = global__rocm_control;\n    _rocm_context_t *gctxt = global__rocm_context;\n    uint32_t cc;\n\n    /* Free context */\n    if(gctxt != NULL) {\n        papi_free(gctxt->availEventIDArray);\n        papi_free(gctxt->availEventDeviceNum);\n        papi_free(gctxt->availEventIsBeingMeasuredInEventset);\n        papi_free(gctxt->availEventDesc);\n        papi_free(gctxt);\n        global__rocm_context = gctxt = NULL;\n    }\n\n    /* Free control */\n    if(gctrl != NULL) {\n        for(cc = 0; cc < gctrl->countOfActiveContexts; cc++) {\n            if(gctrl->arrayOfActiveContexts[cc] != NULL) {\n                papi_free(gctrl->arrayOfActiveContexts[cc]);\n            }\n        }\n\n        papi_free(gctrl);\n        global__rocm_control = gctrl = NULL;\n    }\n\n    // Shutdown ROC runtime\n    // DEBUG: This causes a segfault.\n    ROCM_CALL_CK(hsa_shut_down, (), return (PAPI_EMISC));\n\n    // close the dynamic libraries needed by this component (opened in the init substrate call)\n    dlclose(dl1);\n    dlclose(dl2);\n    return (PAPI_OK);\n}\n\n\n/* Triggered by PAPI_reset() but only if the EventSet is currently\n *  running. If the eventset is not currently running, then the saved\n *  value in the EventSet is set to zero without calling this\n *  routine.  */\nstatic int _rocm_reset(hwd_context_t * ctx, hwd_control_state_t * ctrl)\n{\n    ROCMDBG(\"Entering _rocm_reset\\n\");\n\n    (void) ctx;\n    (void) ctrl;\n    _rocm_control_t *gctrl = global__rocm_control;\n    uint32_t ii, cc;\n\n    ROCMDBG(\"Reset all active event values\\n\");\n    for(ii = 0; ii < gctrl->activeEventCount; ii++)\n        gctrl->activeEventValues[ii] = 0;\n\n    for(cc = 0; cc < gctrl->countOfActiveContexts; cc++) {\n        int eventDeviceNum = gctrl->arrayOfActiveContexts[cc]->deviceNum;\n        (void) eventDeviceNum;                                          // Suppress 'not used' error when not debug.\n        Context eventCtx = gctrl->arrayOfActiveContexts[cc]->ctx;\n        ROCMDBG(\"Reset device %d ctx %p \\n\", eventDeviceNum, eventCtx);\n        ROCP_CALL_CK(rocprofiler_reset, (eventCtx, 0), return (PAPI_EMISC));\n    }\n\n    return (PAPI_OK);\n}\n\n\n/* This function sets various options in the component - Does nothing in the ROCM component.\n    @param[in] ctx -- hardware context\n    @param[in] code valid are PAPI_SET_DEFDOM, PAPI_SET_DOMAIN, PAPI_SETDEFGRN, PAPI_SET_GRANUL and PAPI_SET_INHERIT\n    @param[in] option -- options to be set\n*/\nstatic int _rocm_ctrl(hwd_context_t * ctx, int code, _papi_int_option_t * option)\n{\n    ROCMDBG(\"Entering _rocm_ctrl\\n\");\n\n    (void) ctx;\n    (void) code;\n    (void) option;\n    return (PAPI_OK);\n}\n\n\n/*\n * This function has to set the bits needed to count different domains\n * In particular: PAPI_DOM_USER, PAPI_DOM_KERNEL PAPI_DOM_OTHER\n * By default return PAPI_EINVAL if none of those are specified\n * and PAPI_OK with success\n * PAPI_DOM_USER is only user context is counted\n * PAPI_DOM_KERNEL is only the Kernel/OS context is counted\n * PAPI_DOM_OTHER  is Exception/transient mode (like user TLB misses)\n * PAPI_DOM_ALL   is all of the domains\n */\nstatic int _rocm_set_domain(hwd_control_state_t * ctrl, int domain)\n{\n    ROCMDBG(\"Entering _rocm_set_domain\\n\");\n\n    (void) ctrl;\n    if((PAPI_DOM_USER & domain) || (PAPI_DOM_KERNEL & domain) || (PAPI_DOM_OTHER & domain) || (PAPI_DOM_ALL & domain))\n        return (PAPI_OK);\n    else\n        return (PAPI_EINVAL);\n    return (PAPI_OK);\n}\n\n\n/* Enumerate Native Events.\n *   @param EventCode is the event of interest\n *   @param modifier is one of PAPI_ENUM_FIRST, PAPI_ENUM_EVENTS\n */\nstatic int _rocm_ntv_enum_events(unsigned int *EventCode, int modifier)\n{\n    //ROCMDBG(\"Entering (get next event after %u)\\n\", *EventCode );\n\n    switch (modifier) {\n    case PAPI_ENUM_FIRST:\n        *EventCode = 0;\n        return (PAPI_OK);\n        break;\n    case PAPI_ENUM_EVENTS:\n        if(global__rocm_context == NULL) {\n            return (PAPI_ENOEVNT);\n        } else if(*EventCode < global__rocm_context->availEventSize - 1) {\n            *EventCode = *EventCode + 1;\n            return (PAPI_OK);\n        } else\n            return (PAPI_ENOEVNT);\n        break;\n    default:\n        return (PAPI_EINVAL);\n    }\n    return (PAPI_OK);\n}\n\n\n//----------------------------------------------------------------------------\n// Takes a native event code and passes back the name, but the PAPI version\n// of the name in availEventDesc[], not the ROCM internal name (in\n// availEventIDArray[].name).\n// @param EventCode is the native event code\n// @param name is a pointer for the name to be copied to\n// @param len is the size of the name string\n//----------------------------------------------------------------------------\nstatic int _rocm_ntv_code_to_name(unsigned int EventCode, char *name, int len)\n{\n    //ROCMDBG(\"Entering EventCode %d\\n\", EventCode );\n\n    unsigned int index = EventCode;\n    _rocm_context_t *gctxt = global__rocm_context;\n    if(gctxt != NULL && index < gctxt->availEventSize) {\n        strncpy(name, gctxt->availEventDesc[index].name, len);\n    } else {\n        return (PAPI_EINVAL);\n    }\n    //ROCMDBG( \"Exit: EventCode %d: Name %s\\n\", EventCode, name );\n    return (PAPI_OK);\n}\n\n\n/* Takes a native event code and passes back the event description\n * @param EventCode is the native event code\n * @param descr is a pointer for the description to be copied to\n * @param len is the size of the descr string\n */\nstatic int _rocm_ntv_code_to_descr(unsigned int EventCode, char *name, int len)\n{\n    //ROCMDBG(\"Entering _rocm_ntv_code_to_descr\\n\");\n\n    unsigned int index = EventCode;\n    _rocm_context_t *gctxt = global__rocm_context;\n    if(gctxt != NULL && index < gctxt->availEventSize) {\n        strncpy(name, gctxt->availEventDesc[index].description, len);\n    } else {\n        return (PAPI_EINVAL);\n    }\n    return (PAPI_OK);\n}\n\n\n/* Vector that points to entry points for the component */\npapi_vector_t _rocm_vector = {\n    .cmp_info = {\n                 /* default component information (unspecified values are initialized to 0) */\n                 .name = \"rocm\",\n                 .short_name = \"rocm\",\n                 .version = \"1.0\",\n                 .description = \"GPU events and metrics via AMD ROCm-PL API\",\n                 .num_mpx_cntrs = PAPIROCM_MAX_COUNTERS,\n                 .num_cntrs = PAPIROCM_MAX_COUNTERS,\n                 .default_domain = PAPI_DOM_USER,\n                 .default_granularity = PAPI_GRN_THR,\n                 .available_granularities = PAPI_GRN_THR,\n                 .hardware_intr_sig = PAPI_INT_SIGNAL,\n                 /* component specific cmp_info initializations */\n                 .fast_real_timer = 0,\n                 .fast_virtual_timer = 0,\n                 .attach = 0,\n                 .attach_must_ptrace = 0,\n                 .available_domains = PAPI_DOM_USER | PAPI_DOM_KERNEL,\n                 }\n    ,\n    /* sizes of framework-opaque component-private structures... these are all unused in this component */\n    .size = {\n             .context = 1,      /* sizeof( _rocm_context_t ), */\n             .control_state = 1,        /* sizeof( _rocm_control_t ), */\n             .reg_value = 1,    /* sizeof( _rocm_register_t ), */\n             .reg_alloc = 1,    /* sizeof( _rocm_reg_alloc_t ), */\n             }\n    ,\n    /* function pointers in this component */\n    .start = _rocm_start,    /* ( hwd_context_t * ctx, hwd_control_state_t * ctrl ) */\n    .stop = _rocm_stop,      /* ( hwd_context_t * ctx, hwd_control_state_t * ctrl ) */\n    .read = _rocm_read,      /* ( hwd_context_t * ctx, hwd_control_state_t * ctrl, long_long ** events, int flags ) */\n    .reset = _rocm_reset,    /* ( hwd_context_t * ctx, hwd_control_state_t * ctrl ) */\n    .cleanup_eventset = _rocm_cleanup_eventset,      /* ( hwd_control_state_t * ctrl ) */\n\n    .init_component = _rocm_init_component,  /* ( int cidx ) */\n    .init_thread = _rocm_init_thread,        /* ( hwd_context_t * ctx ) */\n    .init_control_state = _rocm_init_control_state,  /* ( hwd_control_state_t * ctrl ) */\n    .update_control_state = _rocm_update_control_state,      /* ( hwd_control_state_t * ptr, NativeInfo_t * native, int count, hwd_context_t * ctx ) */\n\n    .ctl = _rocm_ctrl,       /* ( hwd_context_t * ctx, int code, _papi_int_option_t * option ) */\n    .set_domain = _rocm_set_domain,  /* ( hwd_control_state_t * cntrl, int domain ) */\n    .ntv_enum_events = _rocm_ntv_enum_events,        /* ( unsigned int *EventCode, int modifier ) */\n    .ntv_code_to_name = _rocm_ntv_code_to_name,      /* ( unsigned int EventCode, char *name, int len ) */\n    .ntv_code_to_descr = _rocm_ntv_code_to_descr,    /* ( unsigned int EventCode, char *name, int len ) */\n    .shutdown_thread = _rocm_shutdown_thread,        /* ( hwd_context_t * ctx ) */\n    .shutdown_component = _rocm_shutdown_component,  /* ( void ) */\n};\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-papi-6.0.0.1-gmm3tef6bggycxgzrtmq2ejaggc2ozfb/spack-src/src/counter_analysis_toolkit/gen_seq_dlopen.sh": "#!/bin/bash\n\nDRV_F=icache_seq.c\nKRN_F=icache_seq_kernel.c\nHEAD_F=icache_seq.h\n\nTRUE_IF=1\nFALSE_IF=0\n\n\n################################################################################\ncreate_common_prefix(){\n  cat <<EOF\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <math.h>\n\n#include \"papi.h\"\n#include \"icache_seq.h\"\n\nEOF\n}\n\n\n################################################################################\ncreate_kernel(){\n\n    basic_block_copies=$1;\n    block_type=$2;\n\n\n    for((i=0; i<$((${basic_block_copies}-1)); i++)); do\n        deref[$i]=$(($i+1))\n    done\n\n    available=$((${basic_block_copies}-1));\n    indx=0;\n\n    for((i=1; i<${basic_block_copies}; i++)); do\n        rnd=$((RANDOM % ${available}))\n        next=${deref[${rnd}]};\n        # If the next jump is too close, try one more time.\n        if (( ${next} <= $((${indx}+2)) && ${next} > ${indx} )); then\n            rnd=$((RANDOM % ${available}))\n            next=${deref[${rnd}]};\n        fi\n        permutation[${indx}]=$next;\n        indx=${next};\n        deref[${rnd}]=${deref[$((${available}-1))]} # replace the element we used with the last one\n        ((available--)); # reduce the number of available elements (to ditch the last one).\n    done\n\n    permutation[${indx}]=-1;\n    last_link_in_chain=${indx};\n\n\n    if (( $block_type == $TRUE_IF )); then\n        echo \"long long seq_kernel_TRUE_IF_${basic_block_copies}(int epilogue){\"\n    else\n        echo \"long long seq_kernel_FALSE_IF_${basic_block_copies}(int epilogue){\"\n    fi\n    cat <<EOF\n    int jj, is_zero;\n    unsigned int z1 = 12345, z2 = 12345, z3 = 22745, z4 = 82395;\n    unsigned result = 0;\n    unsigned int b;\n    long long cntr_value;\n    cntr_value = 0;\n    is_zero = global_zero;\n\nEOF\n\n    for((i=0; i<${basic_block_copies}; i++)); do\n        echo \"\"\n        if (( $block_type == $TRUE_IF )); then\n            echo \"    if( is_zero < 3 ){\"\n            echo \"        RNG();\"\n            echo \"    }\"\n            echo \"    is_zero *= result;\"\n        else\n            echo \"    if( is_zero > 3 ){\"\n            echo \"        RNG();\"\n            echo \"    }\"\n            echo \"    result = z1 ^ z2 ^ z3 ^ z4;\"\n            echo \"    is_zero *= result;\"\n        fi\n    done\n\n    cat <<EOF\n\n    if( DO_COPY == epilogue ){\n        // Access enough elements to flush the shared caches.\n        for(jj=0; jj<BUF_ELEM_CNT; jj++){\n            is_zero += (int)buff[jj];\n        }\n    }\n\n    cntr_value += is_zero;\n\nEOF\n    echo \"\"\n    echo \"    return cntr_value;\"\n    echo \"}\"\n\n}\n\n\n################################################################################\ncreate_caller(){\n\n    basic_block_copies=$1;\n    dl_reps=$2;\n\n\n    cat <<EOF\nint seq_jumps_${basic_block_copies}x${dl_reps}(int iter_count, int eventset, int epilogue, int branch_type, int run_type, FILE* ofp_papi){\n    long long int cntr_value = 0;\n    int i, j, is_zero = 13;\n    int ret;\n    char fname[512];\nEOF\n    echo \"    void *obj[${dl_reps}];\"\n    echo \"    void *sym_true_if[${dl_reps}];\"\n    echo \"    void *sym_false_if[${dl_reps}];\"\n    echo \"\"\n    echo \"    for(j=0; j<${dl_reps}; j++){\"\n    echo \"\"\n    echo \"        snprintf(fname, 512, \\\"icache_seq_kernel_%d.so\\\", j);\"\n    echo \"        obj[j] = dlopen(fname, RTLD_NOW|RTLD_LOCAL);\"\n    echo \"        if( NULL == obj[j] ){\"\n    echo \"            fprintf(stderr,\\\"dlopen() %d failed on %s because: %s\\nIs the directory containing '%s' in your LD_LIBRARY_PATH?\\n\\\", j, fname, dlerror(), fname);\"\n    echo \"            return -1;\"\n    echo \"        }\"\n    echo \"        sym_true_if[j] = dlsym(obj[j], \\\"seq_kernel_TRUE_IF_${basic_block_copies}\\\");\"\n    echo \"        if( NULL == sym_true_if[j] ){\"\n    echo \"            fprintf(stderr,\\\"dlsym() %d failed because: %s\\n\\\", j, dlerror());\"\n    echo \"            return -1;\"\n    echo \"        }\"\n    echo \"        sym_false_if[j] = dlsym(obj[j], \\\"seq_kernel_FALSE_IF_${basic_block_copies}\\\");\"\n    echo \"        if( NULL == sym_true_if[j] ){\"\n    echo \"            fprintf(stderr,\\\"dlsym() %d failed because: %s\\n\\\", j, dlerror());\"\n    echo \"            return -1;\"\n    echo \"        }\"\n    echo \"    }\"\n    echo \"\"\n    echo \"    if((ret=PAPI_start(eventset)) != PAPI_OK){\"\n    echo \"        return -1;\"\n    echo \"    }\"\n    echo \"\"\n    echo \"    if( TRUE_IF == branch_type ){\"\n    echo \"        for(i=0; i<iter_count; i++){\"\n    echo \"            // cntr_value += seq_kernel_TRUE_IF_${basic_block_copies}(eventset, epilogue);\"\n    echo \"            for(j=0; j<${dl_reps}; j++){\"\n    echo \"                cntr_value += ((long long (*)(int))sym_true_if[j])(epilogue);\"\n    echo \"            }\"\n    echo \"        }\"\n    echo \"    }else{\"\n    echo \"        for(i=0; i<iter_count; i++){\"\n    echo \"            // cntr_value += seq_kernel_FALSE_IF_${basic_block_copies}(eventset, epilogue);\"\n    echo \"            for(j=0; j<${dl_reps}; j++){\"\n    echo \"                cntr_value += ((long long (*)(int))sym_false_if[j])(epilogue);\"\n    echo \"            }\"\n    echo \"        }\"\n    echo \"    }\"\n\n    cat <<EOF\n\n    if((ret=PAPI_stop(eventset, &cntr_value)) != PAPI_OK){\n        return -1;\n    }\n\nEOF\n\n    echo \"    for(j=0; j<${dl_reps}; j++){\"\n    echo \"        snprintf(fname, 512, \\\"seq_kernel_%d.so\\\", j);\"\n    echo \"        if( dlclose(obj[j]) ){\"\n    echo \"            fprintf(stderr,\\\"dlclose() %d failed on %s because: %s\\n\\\", j, fname, dlerror());\"\n    echo \"            return -1;\"\n    echo \"        }\"\n    echo \"    }\"\n\n    echo \"    if( COLD_RUN != run_type ){\"\n    echo \"        fprintf(ofp_papi, \\\"%lf\\\\n\\\", ((double)cntr_value)/(${basic_block_copies}*${dl_reps}*(double)iter_count) );\"\n    echo \"    }\"\n\n    cat <<EOF\n\n    is_zero = global_zero * (int)cntr_value;\n\n    return is_zero;\n}\nEOF\n}\n\n\n################################################################################\ncreate_functions(){\n    basic_block_copies=$1;\n\n    dl_reps=1;\n\n    if (( $basic_block_copies >= 10000 )); then\n        dl_reps=$(( ${basic_block_copies}/5000 ))\n        tmp=$(( ${basic_block_copies}/${dl_reps} ))\n        basic_block_copies=$tmp\n    else\n        create_kernel $basic_block_copies $j $TRUE_IF >> ${KRN_F}\n        create_kernel $basic_block_copies $j $FALSE_IF >> ${KRN_F}\n        echo \"\" >> ${KRN_F}\n        echo \"long long seq_kernel_TRUE_IF_${basic_block_copies}(int epilogue);\" >> ${HEAD_F}\n        echo \"long long seq_kernel_FALSE_IF_${basic_block_copies}(int epilogue);\" >> ${HEAD_F}\n    fi\n    echo \"int seq_jumps_${basic_block_copies}x${dl_reps}(int iter_count, int eventset, int epilogue, int branch_type, int run_type, FILE* ofp_papi);\" >> ${HEAD_F}\n\n    create_caller ${basic_block_copies} $dl_reps >> ${DRV_F}\n    echo \"\" >> ${DRV_F}\n\n}\n\n\n################################################################################\ncreate_main(){\n\n    cat <<EOF\nvoid seq_driver(FILE* ofp_papi, char* papi_event_name, int init, int show_progress){\n    int ret, exp_cnt=0, side_effect=0;\n    size_t i;\n    int eventset = PAPI_NULL;\n\n    // Fill up the buffer with some nonsense numbers that will round to zero.\n    for(i=0; i<BUF_ELEM_CNT; i++){\n        buff[i] = floor( ((float)i+0.71)/((float)i+8.0*(float)init) );\n        if( (int)buff[i] != 0 )\n            fprintf(stderr,\"WARNING: this element should have been zero: buff[%lu] = %d (%f). The branch benchmarks might not work properly.\\n\",i, (int)buff[i], buff[i]);\n    }\n\n    // Set the variable to zero in a way that the compiler cannot figure it out.\n    global_zero = (int)floor( (buff[3]+1) / (buff[9]+getpid()) );\n\n    //set up PAPI\n    if((ret=PAPI_create_eventset(&eventset)) != PAPI_OK){\n        for(i=0; i<strlen(\"Total:100%  Current test:\"); i++) putchar('\\b');\n        fflush(stdout);\n        return;\n    }\n    if((ret=PAPI_add_named_event(eventset, papi_event_name)) != PAPI_OK){\n        for(i=0; i<strlen(\"Total:100%  Current test:\"); i++) putchar('\\b');\n        fflush(stdout);\n        return;\n    }\n\n    side_effect = init;\nEOF\n\n    for copy_type in \"NO_COPY\" \"DO_COPY\"; do\n        for ((prm=1; prm<=$#; prm++)); do\n            basic_block_copies=${!prm}\n            dl_reps=1;\n            if (( $basic_block_copies >= 10000 )); then\n                dl_reps=$(( ${basic_block_copies}/5000 ))\n                tmp=$(( ${basic_block_copies}/${dl_reps} ))\n                basic_block_copies=$tmp\n            fi\n            echo \"    if( show_progress ){\"\n            echo \"        printf(\\\"%3d%%\\b\\b\\b\\b\\\",(100*exp_cnt)/(4*$#));\"\n            echo \"        exp_cnt++;\"\n            echo \"        fflush(stdout);\"\n            echo \"    }\"\n            echo \"    side_effect += seq_jumps_${basic_block_copies}x${dl_reps}(1, eventset, NO_COPY, TRUE_IF, COLD_RUN, NULL);\"\n            echo \"    if(side_effect < init){\"\n            echo \"        return;\"\n            echo \"    }\"\n            echo \"    side_effect += seq_jumps_${basic_block_copies}x${dl_reps}(150, eventset, ${copy_type}, TRUE_IF, NORMAL_RUN, ofp_papi);\"\n            echo \"    if(side_effect < init){\"\n            echo \"        return;\"\n            echo \"    }\"\n            echo \"\"\n        done\n    done\n\n    for copy_type in \"NO_COPY\" \"DO_COPY\"; do\n        for ((prm=1; prm<=$#; prm++)); do\n            basic_block_copies=${!prm}\n            dl_reps=1;\n            if (( $basic_block_copies >= 10000 )); then\n                dl_reps=$(( ${basic_block_copies}/5000 ))\n                tmp=$(( ${basic_block_copies}/${dl_reps} ))\n                basic_block_copies=$tmp\n            fi\n            echo \"    if( show_progress ){\"\n            echo \"        printf(\\\"%3d%%\\b\\b\\b\\b\\\",(100*exp_cnt)/(4*$#));\"\n            echo \"        exp_cnt++;\"\n            echo \"        fflush(stdout);\"\n            echo \"    }\"\n            echo \"    side_effect += seq_jumps_${basic_block_copies}x${dl_reps}(1, eventset, NO_COPY, FALSE_IF, COLD_RUN, NULL);\"\n            echo \"    if(side_effect < init){\"\n            echo \"        return;\"\n            echo \"    }\"\n            echo \"    side_effect += seq_jumps_${basic_block_copies}x${dl_reps}(150, eventset, ${copy_type}, FALSE_IF, NORMAL_RUN, ofp_papi);\"\n            echo \"    if(side_effect < init){\"\n            echo \"        return;\"\n            echo \"    }\"\n            echo \"\"\n        done\n    done\n    cat <<EOF\n\n    if( show_progress ){\n        size_t i;\n        printf(\"100%%\");\n        for(i=0; i<strlen(\"Total:100%  Current test:100%\"); i++) putchar('\\b');\n        fflush(stdout);\n    }\n\n    if( 174562 == side_effect ){\n        printf(\"Random side-effect\\n\");\n    }\n\n    ret = PAPI_cleanup_eventset( eventset );\n    if (ret != PAPI_OK ){\n        return;\n    }\n    ret = PAPI_destroy_eventset( &eventset );\n    if (ret != PAPI_OK ){\n        return;\n    }\n\n\n    return;\n}\nEOF\n}\n\necho \"#include \\\"icache.h\\\"\" > ${HEAD_F}\necho \"#include <dlfcn.h>\" >> ${HEAD_F}\n\necho \"\" >> ${HEAD_F}\necho \"float buff[BUF_ELEM_CNT];\" >> ${HEAD_F}\necho \"volatile int global_zero;\" >> ${HEAD_F}\necho \"\" >> ${HEAD_F}\n\ncreate_common_prefix > ${DRV_F}\ncreate_common_prefix > ${KRN_F}\nfor sz in 10 20 30 50 100 150 200 300 400 600 800 1200 1600 2400 3200 5000 10000 15000 20000 25000 35000 40000 50000 60000;  do\n    create_functions ${sz}\ndone\n\ncreate_main 10 20 30 50 100 150 200 300 400 600 800 1200 1600 2400 3200 5000 10000 15000 20000 25000 35000 40000 50000 60000 >> ${DRV_F}\n\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-papi-6.0.0.1-gmm3tef6bggycxgzrtmq2ejaggc2ozfb/spack-src/ChangeLogP421.txt",
        "/tmp/vanessa/spack-stage/spack-stage-papi-6.0.0.1-gmm3tef6bggycxgzrtmq2ejaggc2ozfb/spack-src/src/x86_cpuid_info.c",
        "/tmp/vanessa/spack-stage/spack-stage-papi-6.0.0.1-gmm3tef6bggycxgzrtmq2ejaggc2ozfb/spack-src/src/sw_multiplex.c",
        "/tmp/vanessa/spack-stage/spack-stage-papi-6.0.0.1-gmm3tef6bggycxgzrtmq2ejaggc2ozfb/spack-src/src/libpfm-3.y/lib/intel_corei7_events.h",
        "/tmp/vanessa/spack-stage/spack-stage-papi-6.0.0.1-gmm3tef6bggycxgzrtmq2ejaggc2ozfb/spack-src/src/perfctr-2.7.x/linux/drivers/perfctr/virtual.c",
        "/tmp/vanessa/spack-stage/spack-stage-papi-6.0.0.1-gmm3tef6bggycxgzrtmq2ejaggc2ozfb/spack-src/src/perfctr-2.7.x/patches/patch-kernel-2.6.11",
        "/tmp/vanessa/spack-stage/spack-stage-papi-6.0.0.1-gmm3tef6bggycxgzrtmq2ejaggc2ozfb/spack-src/src/perfctr-2.7.x/patches/patch-kernel-2.6.14-rc5-mm1",
        "/tmp/vanessa/spack-stage/spack-stage-papi-6.0.0.1-gmm3tef6bggycxgzrtmq2ejaggc2ozfb/spack-src/src/perfctr-2.7.x/patches/patch-kernel-2.6.16.21-SLES10",
        "/tmp/vanessa/spack-stage/spack-stage-papi-6.0.0.1-gmm3tef6bggycxgzrtmq2ejaggc2ozfb/spack-src/src/perfctr-2.7.x/patches/patch-kernel-2.6.12-rc1",
        "/tmp/vanessa/spack-stage/spack-stage-papi-6.0.0.1-gmm3tef6bggycxgzrtmq2ejaggc2ozfb/spack-src/src/perfctr-2.7.x/patches/patch-kernel-2.6.14",
        "/tmp/vanessa/spack-stage/spack-stage-papi-6.0.0.1-gmm3tef6bggycxgzrtmq2ejaggc2ozfb/spack-src/src/perfctr-2.7.x/patches/patch-kernel-2.6.14-mm1",
        "/tmp/vanessa/spack-stage/spack-stage-papi-6.0.0.1-gmm3tef6bggycxgzrtmq2ejaggc2ozfb/spack-src/src/perfctr-2.7.x/patches/patch-kernel-2.6.12-rc2",
        "/tmp/vanessa/spack-stage/spack-stage-papi-6.0.0.1-gmm3tef6bggycxgzrtmq2ejaggc2ozfb/spack-src/src/perfctr-2.7.x/patches/patch-kernel-2.6.16",
        "/tmp/vanessa/spack-stage/spack-stage-papi-6.0.0.1-gmm3tef6bggycxgzrtmq2ejaggc2ozfb/spack-src/src/perfctr-2.7.x/patches/patch-kernel-2.6.12-rc5",
        "/tmp/vanessa/spack-stage/spack-stage-papi-6.0.0.1-gmm3tef6bggycxgzrtmq2ejaggc2ozfb/spack-src/src/components/vmware/PAPI-VMwareComponentDocument.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-papi-6.0.0.1-gmm3tef6bggycxgzrtmq2ejaggc2ozfb/spack-src/src/components/cuda/sampling/test/sass_source_map.cubin",
        "/tmp/vanessa/spack-stage/spack-stage-papi-6.0.0.1-gmm3tef6bggycxgzrtmq2ejaggc2ozfb/spack-src/src/perfctr-2.6.x/linux/drivers/perfctr/virtual.c",
        "/tmp/vanessa/spack-stage/spack-stage-papi-6.0.0.1-gmm3tef6bggycxgzrtmq2ejaggc2ozfb/spack-src/src/perfctr-2.6.x/patches/patch-kernel-2.6.11",
        "/tmp/vanessa/spack-stage/spack-stage-papi-6.0.0.1-gmm3tef6bggycxgzrtmq2ejaggc2ozfb/spack-src/src/perfctr-2.6.x/patches/patch-kernel-2.6.15",
        "/tmp/vanessa/spack-stage/spack-stage-papi-6.0.0.1-gmm3tef6bggycxgzrtmq2ejaggc2ozfb/spack-src/src/perfctr-2.6.x/patches/patch-kernel-2.6.13",
        "/tmp/vanessa/spack-stage/spack-stage-papi-6.0.0.1-gmm3tef6bggycxgzrtmq2ejaggc2ozfb/spack-src/src/perfctr-2.6.x/patches/patch-kernel-2.6.12",
        "/tmp/vanessa/spack-stage/spack-stage-papi-6.0.0.1-gmm3tef6bggycxgzrtmq2ejaggc2ozfb/spack-src/src/perfctr-2.6.x/patches/patch-kernel-2.6.14",
        "/tmp/vanessa/spack-stage/spack-stage-papi-6.0.0.1-gmm3tef6bggycxgzrtmq2ejaggc2ozfb/spack-src/src/perfctr-2.6.x/patches/patch-kernel-2.6.10",
        "/tmp/vanessa/spack-stage/spack-stage-papi-6.0.0.1-gmm3tef6bggycxgzrtmq2ejaggc2ozfb/spack-src/src/perfctr-2.6.x/patches/patch-kernel-2.6.16",
        "/tmp/vanessa/spack-stage/spack-stage-papi-6.0.0.1-gmm3tef6bggycxgzrtmq2ejaggc2ozfb/spack-src/src/perfctr-2.6.x/patches/patch-kernel-2.6.16.46-0.12-suse"
    ],
    "total_files": 1914
}