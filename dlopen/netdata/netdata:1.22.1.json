{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/configure.ac": "#\n# Copyright (C) 2015 Alon Bar-Lev <alon.barlev@gmail.com>\n# SPDX-License-Identifier: GPL-3.0-or-later\n#\nAC_PREREQ(2.60)\n\n# We do not use m4_esyscmd_s to support older autoconf.\ndefine([VERSION_STRING], m4_esyscmd([git describe 2>/dev/null | tr -d '\\n']))\ndefine([VERSION_FROM_FILE], m4_esyscmd([cat packaging/version | tr -d '\\n']))\nm4_ifval(VERSION_STRING, [], [define([VERSION_STRING], VERSION_FROM_FILE)])\n\nAC_INIT([netdata], VERSION_STRING[])\n\nAM_MAINTAINER_MODE([disable])\nif test x\"$USE_MAINTAINER_MODE\" = xyes; then\nAC_MSG_NOTICE(***************** MAINTAINER MODE *****************)\nfi\n\nPACKAGE_RPM_VERSION=\"VERSION_STRING\"\nAC_SUBST([PACKAGE_RPM_VERSION])\n\n# -----------------------------------------------------------------------------\n# autoconf initialization\n\nAC_CONFIG_AUX_DIR([.])\nAC_CONFIG_HEADERS([config.h])\nAC_CONFIG_MACRO_DIR([build/m4])\nAC_CONFIG_SRCDIR([daemon/main.c])\ndefine([AUTOMATE_INIT_OPTIONS], [tar-pax subdir-objects])\nm4_ifdef([AM_SILENT_RULES], [\n    define([AUTOMATE_INIT_OPTIONS], [tar-pax silent-rules subdir-objects])\n    ])\nAM_INIT_AUTOMAKE(AUTOMATE_INIT_OPTIONS)\nm4_ifdef([AM_SILENT_RULES], [\n    AM_SILENT_RULES([yes])\n    ])\nAC_CANONICAL_HOST\nAC_PROG_CC\nAC_PROG_CC_C99\nAM_PROG_CC_C_O\nAC_PROG_CXX\nAC_PROG_INSTALL\nPKG_PROG_PKG_CONFIG\nAC_USE_SYSTEM_EXTENSIONS\n\n\n# -----------------------------------------------------------------------------\n# configurable options\n\nAC_ARG_ENABLE(\n    [plugin-nfacct],\n    [AS_HELP_STRING([--enable-plugin-nfacct], [enable nfacct plugin @<:@default autodetect@:>@])],\n    ,\n    [enable_plugin_nfacct=\"detect\"]\n)\nAC_ARG_ENABLE(\n    [plugin-freeipmi],\n    [AS_HELP_STRING([--enable-plugin-freeipmi], [enable freeipmi plugin @<:@default autodetect@:>@])],\n    ,\n    [enable_plugin_freeipmi=\"detect\"]\n)\nAC_ARG_ENABLE(\n    [plugin-cups],\n    [AS_HELP_STRING([--enable-plugin-cups], [enable cups plugin @<:@default autodetect@:>@])],\n    ,\n    [enable_plugin_cups=\"detect\"]\n)\nAC_ARG_ENABLE(\n    [plugin-xenstat],\n    [AS_HELP_STRING([--enable-plugin-xenstat], [enable xenstat plugin @<:@default autodetect@:>@])],\n    ,\n    [enable_plugin_xenstat=\"detect\"]\n)\nAC_ARG_ENABLE(\n    [backend-kinesis],\n    [AS_HELP_STRING([--enable-backend-kinesis], [enable kinesis backend @<:@default autodetect@:>@])],\n    ,\n    [enable_backend_kinesis=\"detect\"]\n)\nAC_ARG_ENABLE(\n    [backend-prometheus-remote-write],\n    [AS_HELP_STRING([--enable-backend-prometheus-remote-write], [enable prometheus remote write backend @<:@default autodetect@:>@])],\n    ,\n    [enable_backend_prometheus_remote_write=\"detect\"]\n)\nAC_ARG_ENABLE(\n    [backend-mongodb],\n    [AS_HELP_STRING([--enable-backend-mongodb], [enable mongodb backend @<:@default autodetect@:>@])],\n    ,\n    [enable_backend_mongodb=\"detect\"]\n)\nAC_ARG_ENABLE(\n    [pedantic],\n    [AS_HELP_STRING([--enable-pedantic], [enable pedantic compiler warnings @<:@default disabled@:>@])],\n    ,\n    [enable_pedantic=\"no\"]\n)\nAC_ARG_ENABLE(\n    [accept4],\n    [AS_HELP_STRING([--disable-accept4], [System does not have accept4 @<:@default autodetect@:>@])],\n    ,\n    [enable_accept4=\"detect\"]\n)\nAC_ARG_WITH(\n    [webdir],\n    [AS_HELP_STRING([--with-webdir], [location of webdir @<:@PKGDATADIR/web@:>@])],\n    [webdir=\"${withval}\"],\n    [webdir=\"\\$(pkgdatadir)/web\"]\n)\nAC_ARG_WITH(\n    [libcap],\n    [AS_HELP_STRING([--with-libcap], [build with libcap @<:@default autodetect@:>@])],\n    ,\n    [with_libcap=\"detect\"]\n)\nAC_ARG_WITH(\n    [zlib],\n    [AS_HELP_STRING([--without-zlib], [build without zlib @<:@default enabled@:>@])],\n    ,\n    [with_zlib=\"yes\"]\n)\nAC_ARG_WITH(\n    [math],\n    [AS_HELP_STRING([--without-math], [build without math @<:@default enabled@:>@])],\n    ,\n    [with_math=\"yes\"]\n)\nAC_ARG_WITH(\n    [user],\n    [AS_HELP_STRING([--with-user], [use this user to drop privilege @<:@default nobody@:>@])],\n    ,\n    [with_user=\"nobody\"]\n)\nAC_ARG_ENABLE(\n    [x86-sse],\n    [AS_HELP_STRING([--disable-x86-sse], [SSE/SS2 optimizations on x86 @<:@default enabled@:>@])],\n    ,\n    [enable_x86_sse=\"yes\"]\n)\nAC_ARG_ENABLE(\n    [lto],\n    [AS_HELP_STRING([--disable-lto], [Link Time Optimizations @<:@default autodetect@:>@])],\n    ,\n    [enable_lto=\"detect\"]\n)\nAC_ARG_ENABLE(\n    [https],\n    [AS_HELP_STRING([--enable-https], [Enable SSL support @<:@default autodetect@:>@])],\n    ,\n    [enable_https=\"detect\"]\n)\nAC_ARG_ENABLE(\n    [dbengine],\n    [AS_HELP_STRING([--disable-dbengine], [disable netdata dbengine @<:@default autodetect@:>@])],\n    ,\n    [enable_dbengine=\"detect\"]\n)\nAC_ARG_ENABLE(\n    [jsonc],\n    [AS_HELP_STRING([--enable-jsonc], [Enable JSON-C support @<:@default autodetect@:>@])],\n    ,\n    [enable_jsonc=\"detect\"]\n)\n\n# -----------------------------------------------------------------------------\n# Check if cloud is enabled and if the functionality is available\n\nAC_ARG_ENABLE(\n    [cloud],\n    [AS_HELP_STRING([--disable-cloud],\n                    [Disables all cloud functionality])],\n    [ enable_cloud=\"$enableval\" ],\n    [ enable_cloud=\"detect\" ]\n)\n\nif test \"${enable_cloud}\" = \"no\"; then\n    AC_DEFINE([DISABLE_CLOUD], [1], [disable netdata cloud functionality])\nfi\n\n# -----------------------------------------------------------------------------\n# netdata required checks\n\n# fails on centos6\n#AX_CHECK_ENABLE_DEBUG()\n\nAX_GCC_FUNC_ATTRIBUTE([returns_nonnull])\nAX_GCC_FUNC_ATTRIBUTE([malloc])\nAX_GCC_FUNC_ATTRIBUTE([noreturn])\nAX_GCC_FUNC_ATTRIBUTE([noinline])\nAX_GCC_FUNC_ATTRIBUTE([format])\nAX_GCC_FUNC_ATTRIBUTE([warn_unused_result])\n\nAC_CHECK_TYPES([struct timespec, clockid_t], [], [], [[#include <time.h>]])\nAC_SEARCH_LIBS([clock_gettime], [rt posix4])\nAC_CHECK_FUNCS([clock_gettime])\nAC_CHECK_FUNCS([sched_setscheduler sched_getscheduler sched_getparam sched_get_priority_min sched_get_priority_max getpriority setpriority nice])\nAC_CHECK_FUNCS([recvmmsg])\n\nAC_TYPE_INT8_T\nAC_TYPE_INT16_T\nAC_TYPE_INT32_T\nAC_TYPE_INT64_T\nAC_TYPE_UINT8_T\nAC_TYPE_UINT16_T\nAC_TYPE_UINT32_T\nAC_TYPE_UINT64_T\nAC_C_INLINE\nAC_FUNC_STRERROR_R\nAC_C__GENERIC\nAC_C___ATOMIC\n# AC_C_STMT_EXPR\nAC_CHECK_SIZEOF([void *])\nAC_CANONICAL_HOST\nAC_HEADER_MAJOR\nAC_HEADER_RESOLV\n\nAC_CHECK_HEADERS_ONCE([sys/prctl.h])\nAC_CHECK_HEADERS_ONCE([sys/vfs.h])\nAC_CHECK_HEADERS_ONCE([sys/statfs.h])\nAC_CHECK_HEADERS_ONCE([sys/statvfs.h])\nAC_CHECK_HEADERS_ONCE([sys/mount.h])\n\nif test \"${enable_accept4}\" != \"no\"; then\n    AC_CHECK_FUNCS_ONCE(accept4)\nfi\n\n# -----------------------------------------------------------------------------\n# operating system detection\n\nAC_MSG_CHECKING([operating system])\ncase \"$host_os\" in\nfreebsd*)\n    build_target=freebsd\n    build_target_id=2\n    CFLAGS=\"${CFLAGS} -I/usr/local/include -L/usr/local/lib\"\n    ;;\ndarwin*)\n    build_target=macos\n    build_target_id=3\n    LDFLAGS=\"${LDFLAGS} -framework CoreFoundation -framework IOKit\"\n    ;;\n*)\n    build_target=linux\n    build_target_id=1\n    ;;\nesac\n\nAM_CONDITIONAL([FREEBSD], [test \"${build_target}\" = \"freebsd\"])\nAM_CONDITIONAL([MACOS], [test \"${build_target}\" = \"macos\"])\nAM_CONDITIONAL([LINUX], [test \"${build_target}\" = \"linux\"])\nAC_MSG_RESULT([${build_target} with id ${build_target_id}])\n\n\n# -----------------------------------------------------------------------------\n# pthreads\n\nACX_PTHREAD(, [AC_MSG_ERROR([Cannot initialize pthread environment])])\nLIBS=\"${PTHREAD_LIBS} ${LIBS}\"\nCFLAGS=\"${CFLAGS} ${PTHREAD_CFLAGS}\"\nCC=\"${PTHREAD_CC}\"\n\n\n# -----------------------------------------------------------------------------\n# libm\n\nAC_ARG_VAR([MATH_CFLAGS], [C compiler flags for math])\nAC_ARG_VAR([MATH_LIBS], [linker flags for math])\nif test -z \"${MATH_LIBS}\"; then\n    AC_CHECK_LIB(\n        [m],\n        [sin],\n        [MATH_LIBS=\"-lm\"]\n    )\nfi\ntest \"${with_math}\" = \"yes\" -a -z \"${MATH_LIBS}\" && AC_MSG_ERROR([math required but not found])\n\nAC_MSG_CHECKING([if libm should be used])\nif test \"${with_math}\" != \"no\" -a ! -z \"${MATH_LIBS}\"; then\n    with_math=\"yes\"\n    AC_DEFINE([STORAGE_WITH_MATH], [1], [math usability])\n    OPTIONAL_MATH_CFLAGS=\"${MATH_CFLAGS}\"\n    OPTIONAL_MATH_LIBS=\"${MATH_LIBS}\"\nelse\n    with_math=\"no\"\nfi\nAC_MSG_RESULT([${with_math}])\n\n\n# -----------------------------------------------------------------------------\n# libuv multi-platform support library with a focus on asynchronous I/O\n# TODO: check version, uv_fs_scandir_next only available in version >= 1.0\n\nAC_CHECK_LIB(\n    [uv],\n    [uv_fs_scandir_next],\n    [UV_LIBS=\"-luv\"]\n)\ntest -z \"${UV_LIBS}\" && \\\n    AC_MSG_ERROR([libuv required but not found. Try installing 'libuv1-dev' or 'libuv-devel'.])\nOPTIONAL_UV_CFLAGS=\"${UV_CFLAGS}\"\nOPTIONAL_UV_LIBS=\"${UV_LIBS}\"\n\n\n# -----------------------------------------------------------------------------\n# lz4 Extremely Fast Compression algorithm\n\nAC_CHECK_LIB(\n    [lz4],\n    [LZ4_compress_default],\n    [LZ4_LIBS=\"-llz4\"]\n)\n\n# -----------------------------------------------------------------------------\n# Judy General purpose dynamic array\n\nAC_CHECK_LIB(\n    [Judy],\n    [JudyLIns],\n    [JUDY_LIBS=\"-lJudy\"]\n)\n\n\n# -----------------------------------------------------------------------------\n# zlib\n\nPKG_CHECK_MODULES(\n    [ZLIB],\n    [zlib],\n    [have_zlib=yes],\n    [have_zlib=no]\n)\ntest \"${with_zlib}\" = \"yes\" -a \"${have_zlib}\" != \"yes\" && AC_MSG_ERROR([zlib required but not found. Try installing 'zlib1g-dev' or 'zlib-devel'.])\n\nAC_MSG_CHECKING([if zlib should be used])\nif test \"${with_zlib}\" != \"no\" -a \"${have_zlib}\" = \"yes\"; then\n    with_zlib=\"yes\"\n    AC_DEFINE([NETDATA_WITH_ZLIB], [1], [zlib usability])\n    OPTIONAL_ZLIB_CFLAGS=\"${ZLIB_CFLAGS}\"\n    OPTIONAL_ZLIB_LIBS=\"${ZLIB_LIBS}\"\nelse\n    with_zlib=\"no\"\nfi\nAC_MSG_RESULT([${with_zlib}])\n\n\n# -----------------------------------------------------------------------------\n# libuuid\n\nPKG_CHECK_MODULES(\n    [UUID],\n    [uuid],\n    [have_uuid=yes],\n    [AC_MSG_ERROR([libuuid required but not found. Try installing 'uuid-dev' or 'libuuid-devel'.])]\n)\nAC_DEFINE([NETDATA_WITH_UUID], [1], [uuid usability])\nOPTIONAL_UUID_CFLAGS=\"${UUID_CFLAGS}\"\nOPTIONAL_UUID_LIBS=\"${UUID_LIBS}\"\n\n# -----------------------------------------------------------------------------\n# OpenSSL Cryptography and SSL/TLS Toolkit\n\nAC_CHECK_LIB(\n    [crypto],\n    [SHA256_Init],\n    [SSL_LIBS=\"-lcrypto -lssl\"]\n)\n\n# -----------------------------------------------------------------------------\n# JSON-C library\n\nPKG_CHECK_MODULES([JSON],[json-c],AC_CHECK_LIB(\n    [json-c],\n    [json_object_get_type],\n    [JSONC_LIBS=\"-ljson-c\"]),AC_CHECK_LIB(\n        [json],\n        [json_object_get_type],\n        [JSONC_LIBS=\"-ljson\"])\n    )\n\nOPTIONAL_JSONC_LIBS=\"${JSONC_LIBS}\"\n\n# -----------------------------------------------------------------------------\n# VFS plugin libs\n\nAC_CHECK_LIB(\n    [dl],\n    [dlopen],\n    [EBPF_LIBS=\"-ldl\"]\n)\n\nOPTIONAL_EBPF_LIBS=\"${EBPF_LIBS}\"\n\n# -----------------------------------------------------------------------------\n# DB engine and HTTPS\ntest \"${enable_dbengine}\" = \"yes\" -a -z \"${LZ4_LIBS}\" && \\\n    AC_MSG_ERROR([liblz4 required but not found. Try installing 'liblz4-dev' or 'lz4-devel'.])\n\ntest \"${enable_dbengine}\" = \"yes\" -a -z \"${JUDY_LIBS}\" && \\\n    AC_MSG_ERROR([libJudy required but not found. Try installing 'libjudy-dev' or 'Judy-devel'.])\n\ntest \"${enable_https}\" = \"yes\" -a -z \"${SSL_LIBS}\" && \\\n    AC_MSG_ERROR([OpenSSL required for HTTPS but not found. Try installing 'libssl-dev' or 'openssl-devel'.])\n\ntest \"${enable_dbengine}\" = \"yes\" -a -z \"${SSL_LIBS}\" && \\\n    AC_MSG_ERROR([OpenSSL required for DBENGINE but not found. Try installing 'libssl-dev' or 'openssl-devel'.])\n\nAC_MSG_CHECKING([if netdata dbengine should be used])\nif test \"${enable_dbengine}\" != \"no\" -a \"${UV_LIBS}\" -a \"${LZ4_LIBS}\" -a \"${JUDY_LIBS}\" -a \"${SSL_LIBS}\"; then\n    enable_dbengine=\"yes\"\n    AC_DEFINE([ENABLE_DBENGINE], [1], [netdata dbengine usability])\n    OPTIONAL_LZ4_CFLAGS=\"${LZ4_CFLAGS}\"\n    OPTIONAL_LZ4_LIBS=\"${LZ4_LIBS}\"\n    OPTIONAL_JUDY_CFLAGS=\"${JUDY_CFLAGS}\"\n    OPTIONAL_JUDY_LIBS=\"${JUDY_LIBS}\"\n    OPTIONAL_SSL_CFLAGS=\"${SSL_CFLAGS}\"\n    OPTIONAL_SSL_LIBS=\"${SSL_LIBS}\"\nelse\n    enable_dbengine=\"no\"\nfi\nAC_MSG_RESULT([${enable_dbengine}])\nAM_CONDITIONAL([ENABLE_DBENGINE], [test \"${enable_dbengine}\" = \"yes\"])\n\nAC_MSG_CHECKING([if netdata https should be used])\nif test \"${enable_https}\" != \"no\" -a \"${SSL_LIBS}\"; then\n    enable_https=\"yes\"\n    AC_DEFINE([ENABLE_HTTPS], [1], [netdata HTTPS usability])\n    OPTIONAL_SSL_CFLAGS=\"${SSL_CFLAGS}\"\n    OPTIONAL_SSL_LIBS=\"${SSL_LIBS}\"\nelse\n    enable_https=\"no\"\nfi\nAC_MSG_RESULT([${enable_https}])\nAM_CONDITIONAL([ENABLE_HTTPS], [test \"${enable_https}\" = \"yes\"])\n\n# -----------------------------------------------------------------------------\n# JSON-C\n\nif test \"${enable_jsonc}\" != \"no\" -a -z \"${JSONC_LIBS}\"; then\n\t# Try and detect manual static build presence (from netdata-installer.sh)\n\tAC_MSG_CHECKING([if statically built json-c is present])\n\tHAVE_libjson_c_a=\"no\"\n\tif test -f \"externaldeps/jsonc/libjson-c.a\"; then\n\t\tLIBS_BKP=\"${LIBS}\"\n\t\tLIBS=\"externaldeps/jsonc/libjson-c.a\"\n\t\tAC_LINK_IFELSE([AC_LANG_SOURCE([[#include \"externaldeps/jsonc/json-c/json.h\"\n\t\t\t\t\t\t\t\t\t\t int main (int argc, char **argv) {\n\t\t\t\t\t\t\t\t\t\t\t struct json_object *jobj;\n\t\t\t\t\t\t\t\t\t\t\t char *str = \"{ \\\"msg-type\\\": \\\"random\\\" }\";\n\t\t\t\t\t\t\t\t\t\t\t jobj = json_tokener_parse(str);\n\t\t\t\t\t\t\t\t\t\t\t json_object_get_type(jobj);\n\t\t\t\t\t\t\t\t\t\t }]])],\n\t\t\t\t\t\t\t\t\t\t[HAVE_libjson_c_a=\"yes\"],\n\t\t\t\t\t\t\t\t\t\t[HAVE_libjson_c_a=\"no\"])\n\t\tLIBS=\"${LIBS_BKP}\"\n\tfi\n\n\tif test \"${HAVE_libjson_c_a}\" = \"yes\"; then\n\t\tAC_DEFINE([LINK_STATIC_JSONC], [1], [static json-c should be used])\n\t\tJSONC_LIBS=\"static\"\n\t\tOPTIONAL_JSONC_STATIC_CFLAGS=\"-I externaldeps/jsonc\"\n\tfi\n\tAC_MSG_RESULT([${HAVE_libjson_c_a}])\nfi\nAM_CONDITIONAL([LINK_STATIC_JSONC], [test \"${JSONC_LIBS}\" = \"static\"])\n\ntest \"${enable_jsonc}\" = \"yes\" -a -z \"${JSONC_LIBS}\" && \\\n    AC_MSG_ERROR([JSON-C required but not found. Try installing 'libjson-c-dev' or 'json-c'.])\n\nAC_MSG_CHECKING([if json-c should be used])\nif test \"${enable_jsonc}\" != \"no\" -a \"${JSONC_LIBS}\"; then\n\tenable_jsonc=\"yes\"\n\tAC_DEFINE([ENABLE_JSONC], [1], [netdata json-c usability])\nelse\n\tenable_jsonc=\"no\"\nfi\nAC_MSG_RESULT([${enable_jsonc}])\nAM_CONDITIONAL([ENABLE_JSONC], [test \"${enable_jsonc}\" = \"yes\"])\n\n# -----------------------------------------------------------------------------\n# compiler options\n\nAC_ARG_VAR([SSE_CANDIDATE], [C compiler flags for SSE])\nAS_CASE([$host_cpu],\n    [i?86], [SSE_CANDIDATE=\"yes\"]\n)\nAC_SUBST([SSE_CANDIDATE])\nif test \"${SSE_CANDIDATE}\" = \"yes\" -a \"${enable_x86_sse}\" = \"yes\"; then\n    opt=\"-msse2 -mfpmath=sse\"\n    AX_CHECK_COMPILE_FLAG(${opt}, [CFLAGS=\"${CFLAGS} ${opt}\"], [])\nfi\n\nif test \"${GCC}\" = \"yes\"; then\n    AC_DEFINE_UNQUOTED([likely(x)], [__builtin_expect(!!(x), 1)], [gcc branch optimization])\n    AC_DEFINE_UNQUOTED([unlikely(x)], [__builtin_expect(!!(x), 0)], [gcc branch optimization])\nelse\n    AC_DEFINE_UNQUOTED([likely(x)], [(x)], [gcc branch optimization])\n    AC_DEFINE_UNQUOTED([unlikely(x)], [(x)], [gcc branch optimization])\nfi\n\nif test \"${GCC}\" = \"yes\"; then\n    AC_DEFINE([__always_unused], [__attribute__((unused))], [gcc unused attribute])\n    AC_DEFINE([__maybe_unused], [__attribute__((unused))], [gcc unused attribute])\nelse\n    AC_DEFINE([__always_unused], [], [dummy unused attribute])\n    AC_DEFINE([__maybe_unused], [], [dummy unused attribute])\nfi\n\nif test \"${enable_pedantic}\" = \"yes\"; then\n    enable_strict=\"yes\"\n    CFLAGS=\"${CFLAGS} -pedantic -Wall -Wextra -Wno-long-long\"\nfi\n\n\n# -----------------------------------------------------------------------------\n# memory allocation library\n\nAC_MSG_CHECKING([for memory allocator])\nTS_CHECK_JEMALLOC\nif test \"$has_jemalloc\" = \"1\"; then\n    AC_DEFINE([ENABLE_JEMALLOC], [1], [compile and link with jemalloc])\n    AC_MSG_RESULT([jemalloc])\nelse\n    TS_CHECK_TCMALLOC\n    if test \"$has_tcmalloc\" = \"1\"; then\n        AC_DEFINE([ENABLE_TCMALLOC], [1], [compile and link with tcmalloc])\n        AC_MSG_RESULT([tcmalloc])\n    else\n        AC_MSG_RESULT([system])\n        AC_C_MALLOPT\n        AC_C_MALLINFO\n    fi\nfi\n\n\n# -----------------------------------------------------------------------------\n# libcap\n\nPKG_CHECK_MODULES(\n    [LIBCAP],\n    [libcap],\n    [AC_CHECK_LIB([cap], [cap_get_proc, cap_set_proc],\n        [AC_CHECK_HEADER(\n            [sys/capability.h],\n            [have_libcap=yes],\n            [have_libcap=no]\n        )],\n        [have_libcap=no]\n    )],\n    [have_libcap=no]\n)\ntest \"${with_libcap}\" = \"yes\" -a \"${have_libcap}\" != \"yes\" && AC_MSG_ERROR([libcap required but not found.])\n\nAC_MSG_CHECKING([if libcap should be used])\nif test \"${with_libcap}\" != \"no\" -a \"${have_libcap}\" = \"yes\"; then\n    with_libcap=\"yes\"\n    AC_DEFINE([HAVE_CAPABILITY], [1], [libcap usability])\n    OPTIONAL_LIBCAP_CFLAGS=\"${LIBCAP_CFLAGS}\"\n    OPTIONAL_LIBCAP_LIBS=\"${LIBCAP_LIBS}\"\nelse\n    with_libcap=\"no\"\nfi\nAC_MSG_RESULT([${with_libcap}])\nAM_CONDITIONAL([ENABLE_CAPABILITY], [test \"${with_libcap}\" = \"yes\"])\n\n# -----------------------------------------------------------------------------\n# ACLK\n\nAC_MSG_CHECKING([if cloud functionality should be enabled])\nAC_MSG_RESULT([${enable_cloud}])\nif test \"$enable_cloud\" != \"no\"; then\n    # just to have all messages that can fail ACLK build in one place\n    # so it is easier to see why it can't be built\n    if test -n \"${SSL_LIBS}\"; then\n        OPTIONAL_SSL_CFLAGS=\"${SSL_CFLAGS}\"\n        OPTIONAL_SSL_LIBS=\"${SSL_LIBS}\"\n    else\n        AC_MSG_WARN([OpenSSL required for agent-cloud-link but not found. Try installing 'libssl-dev' or 'openssl-devel'.])\n    fi\n\n    AC_MSG_CHECKING([if libmosquitto static lib is present (and builds)])\n    if test -f \"externaldeps/mosquitto/libmosquitto.a\"; then\n        LIBS_BKP=\"${LIBS}\"\n        LIBS=\"externaldeps/mosquitto/libmosquitto.a ${OPTIONAL_SSL_LIBS}\"\n        AC_LINK_IFELSE([AC_LANG_SOURCE([[#include \"externaldeps/mosquitto/mosquitto.h\"\n                                         int main (int argc, char **argv) {\n                                             int m,mm,r;\n                                             mosquitto_lib_version(&m, &mm, &r);\n                                         }]])],\n                                        [HAVE_libmosquitto_a=\"yes\"],\n                                        [HAVE_libmosquitto_a=\"no\"])\n        LIBS=\"${LIBS_BKP}\"\n    else\n        HAVE_libmosquitto_a=\"no\"\n        AC_DEFINE([ACLK_NO_LIBMOSQ], [1], [Libmosquitto.a was not found during build.])\n    fi\n    AC_MSG_RESULT([${HAVE_libmosquitto_a}])\n\n    AC_MSG_CHECKING([if libwebsockets static lib is present])\n    if test -f \"externaldeps/libwebsockets/libwebsockets.a\"; then\n        LWS_CFLAGS=\"-I externaldeps/libwebsockets/include\"\n        HAVE_libwebsockets_a=\"yes\"\n    else\n        HAVE_libwebsockets_a=\"no\"\n        AC_DEFINE([ACLK_NO_LWS], [1], [libwebsockets.a was not found during build.])\n    fi\n    AC_MSG_RESULT([${HAVE_libwebsockets_a}])\n\n    if test \"${build_target}\" = \"linux\" -a \"${enable_cloud}\" != \"no\"; then\n        if test \"${have_libcap}\" = \"yes\" -a \"${with_libcap}\" = \"no\"; then\n            AC_MSG_ERROR([agent-cloud-link can't be built without libcap. Disable it by --disable-cloud or enable libcap])\n        fi\n        if test \"${with_libcap}\" = \"yes\"; then\n            LWS_CFLAGS+=\" ${LIBCAP_CFLAGS}\"\n        fi\n    fi\n\n    # next 2 lines are just to have info for ACLK dependencies in common place\n    AC_MSG_CHECKING([if json-c available for ACLK])\n    AC_MSG_RESULT([${enable_jsonc}])\n\n    test \"${enable_cloud}\" = \"yes\" -a \"${enable_jsonc}\" = \"no\" && \\\n        AC_MSG_ERROR([You have asked for ACLK to be built but no json-c available. ACLK requires json-c])\n\n    AC_MSG_CHECKING([if netdata agent-cloud-link can be enabled])\n    if test \"${HAVE_libmosquitto_a}\" = \"yes\" -a \"${HAVE_libwebsockets_a}\" = \"yes\" -a -n \"${SSL_LIBS}\" -a \"${enable_jsonc}\" = \"yes\"; then\n        can_enable_aclk=\"yes\"\n    else\n        can_enable_aclk=\"no\"\n    fi\n    AC_MSG_RESULT([${can_enable_aclk}])\n\n    test \"${enable_cloud}\" = \"yes\" -a \"${can_enable_aclk}\" = \"no\" && \\\n        AC_MSG_ERROR([User required agent-cloud-link but it can't be built!])\n\n    AC_MSG_CHECKING([if netdata agent-cloud-link should/will be enabled])\n    if test \"${enable_cloud}\" = \"detect\"; then\n        enable_aclk=$can_enable_aclk\n    else\n        enable_aclk=$enable_cloud\n    fi\n    AC_SUBST([can_enable_aclk])\n\n    if test \"${enable_aclk}\" = \"yes\"; then\n        AC_DEFINE([ENABLE_ACLK], [1], [netdata ACLK])\n    fi\n\n    AC_MSG_RESULT([${enable_aclk}])\nfi\nAC_SUBST([enable_cloud])\nAM_CONDITIONAL([ENABLE_ACLK], [test \"${enable_aclk}\" = \"yes\"])\n\n# -----------------------------------------------------------------------------\n# apps.plugin\n\nAC_MSG_CHECKING([if apps.plugin should be enabled])\nif test \"${build_target}\" != \"macos\"; then\n    enable_plugin_apps=\"yes\"\nelse\n    enable_plugin_apps=\"no\"\nfi\nAC_MSG_RESULT([${enable_plugin_apps}])\nAM_CONDITIONAL([ENABLE_PLUGIN_APPS], [test \"${enable_plugin_apps}\" = \"yes\"])\n\n\n# -----------------------------------------------------------------------------\n# freeipmi.plugin - libipmimonitoring\n\nPKG_CHECK_MODULES(\n    [IPMIMONITORING],\n    [libipmimonitoring],\n    [AC_CHECK_LIB([ipmimonitoring], [\n        ipmi_monitoring_sensor_readings_by_record_id,\n        ipmi_monitoring_sensor_readings_by_sensor_type,\n        ipmi_monitoring_sensor_read_sensor_number,\n        ipmi_monitoring_sensor_read_sensor_name,\n        ipmi_monitoring_sensor_read_sensor_state,\n        ipmi_monitoring_sensor_read_sensor_units,\n        ipmi_monitoring_sensor_iterator_next,\n        ipmi_monitoring_ctx_sensor_config_file,\n        ipmi_monitoring_ctx_sdr_cache_directory,\n        ipmi_monitoring_ctx_errormsg,\n        ipmi_monitoring_ctx_create\n    ],\n        [AC_CHECK_HEADER(\n            [ipmi_monitoring.h],\n            [AC_CHECK_HEADER(\n                [ipmi_monitoring_bitmasks.h],\n                [have_ipmimonitoring=yes],\n                [have_ipmimonitoring=no]\n            )],\n            [have_ipmimonitoring=no]\n        )],\n        [have_ipmimonitoring=no]\n    )],\n    [have_ipmimonitoring=no]\n)\ntest \"${enable_plugin_freeipmi}\" = \"yes\" -a \"${have_ipmimonitoring}\" != \"yes\" && \\\n    AC_MSG_ERROR([ipmimonitoring required but not found. Try installing 'libipmimonitoring-dev' or 'libipmimonitoring-devel'])\n\nAC_MSG_CHECKING([if freeipmi.plugin should be enabled])\nif test \"${enable_plugin_freeipmi}\" != \"no\" -a \"${have_ipmimonitoring}\" = \"yes\"; then\n    enable_plugin_freeipmi=\"yes\"\n    AC_DEFINE([HAVE_FREEIPMI], [1], [ipmimonitoring usability])\n    OPTIONAL_IPMIMONITORING_CFLAGS=\"${IPMIMONITORING_CFLAGS}\"\n    OPTIONAL_IPMIMONITORING_LIBS=\"${IPMIMONITORING_LIBS}\"\nelse\n    enable_plugin_freeipmi=\"no\"\nfi\nAC_MSG_RESULT([${enable_plugin_freeipmi}])\nAM_CONDITIONAL([ENABLE_PLUGIN_FREEIPMI], [test \"${enable_plugin_freeipmi}\" = \"yes\"])\n\n\n# -----------------------------------------------------------------------------\n# cups.plugin - libcups\n\n# Only check most recently added method of cups\nAC_CHECK_LIB([cups], [httpConnect2],\n    [AC_CHECK_HEADER(\n        [cups/cups.h],\n        [have_cups=yes],\n        [have_cups=no]\n    )],\n    [have_cups=no]\n)\n\ntest \"${enable_plugin_cups}\" = \"yes\" -a \"${have_cups}\" != \"yes\" && \\\n    AC_MSG_ERROR([cups required but not found. Try installing 'cups'])\n\nAC_ARG_WITH([cups-config],\n    [AS_HELP_STRING([--with-cups-config=path], [Specify path to cups-config executable.])],\n    [with_cups_config=\"$withval\"],\n    [with_cups_config=system]\n    )\n\nAS_IF([test \"x$with_cups_config\" != \"xsystem\"], [\n\tCUPSCONFIG=$with_cups_config\n], [\n\tAC_PATH_TOOL(CUPSCONFIG, [cups-config])\n\tAS_IF([test -z \"$CUPSCONFIG\"], [\n\t\thave_cups=no\n\t])\n])\n\nAC_MSG_CHECKING([if cups.plugin should be enabled])\nif test \"${enable_plugin_cups}\" != \"no\" -a \"${have_cups}\" = \"yes\"; then\n    enable_plugin_cups=\"yes\"\n    AC_DEFINE([HAVE_CUPS], [1], [cups usability])\n\n    CUPS_CFLAGS=\"${CUPS_CFLAGS} `$CUPSCONFIG --cflags`\"\n    CUPS_LIBS=\"${CUPS_LIBS} `$CUPSCONFIG --libs`\"\n\n    OPTIONAL_CUPS_CFLAGS=\"${CUPS_CFLAGS}\"\n    OPTIONAL_CUPS_LIBS=\"${CUPS_LIBS}\"\nelse\n    enable_plugin_cups=\"no\"\nfi\nAC_MSG_RESULT([${enable_plugin_cups}])\nAM_CONDITIONAL([ENABLE_PLUGIN_CUPS], [test \"${enable_plugin_cups}\" = \"yes\"])\n\n\n# -----------------------------------------------------------------------------\n# nfacct.plugin - libmnl, libnetfilter_acct\n\nAC_CHECK_HEADER(\n    [linux/netfilter/nfnetlink_conntrack.h],\n    [AC_CHECK_DECL(\n        [CTA_STATS_MAX],\n        [have_nfnetlink_conntrack=yes],\n        [have_nfnetlink_conntrack=no],\n        [#include <linux/netfilter/nfnetlink_conntrack.h>]\n    )],\n    [have_nfnetlink_conntrack=no]\n)\n\nPKG_CHECK_MODULES(\n    [NFACCT],\n    [libnetfilter_acct],\n    [AC_CHECK_LIB(\n        [netfilter_acct],\n        [nfacct_alloc],\n        [have_libnetfilter_acct=yes],\n        [have_libnetfilter_acct=no]\n    )],\n    [have_libnetfilter_acct=no]\n)\n\nPKG_CHECK_MODULES(\n    [LIBMNL],\n    [libmnl],\n    [AC_CHECK_LIB(\n        [mnl],\n        [mnl_socket_open],\n        [have_libmnl=yes],\n        [have_libmnl=no]\n    )],\n    [have_libmnl=no]\n)\n\ntest \"${enable_plugin_nfacct}\" = \"yes\" -a \"${have_nfnetlink_conntrack}\" != \"yes\" && \\\n    AC_MSG_ERROR([nfnetlink_conntrack.h required but not found or too old])\n\ntest \"${enable_plugin_nfacct}\" = \"yes\" -a \"${have_libnetfilter_acct}\" != \"yes\" && \\\n    AC_MSG_ERROR([netfilter_acct required but not found])\n\ntest \"${enable_plugin_nfacct}\" = \"yes\" -a \"${have_libmnl}\" != \"yes\" && \\\n    AC_MSG_ERROR([libmnl required but not found. Try installing 'libmnl-dev' or 'libmnl-devel'])\n\nAC_MSG_CHECKING([if nfacct.plugin should be enabled])\nif test \"${enable_plugin_nfacct}\" != \"no\" -a \"${have_libnetfilter_acct}\" = \"yes\" \\\n                                          -a \"${have_libmnl}\" = \"yes\" \\\n                                          -a \"${have_nfnetlink_conntrack}\" = \"yes\"; then\n    enable_plugin_nfacct=\"yes\"\n    AC_DEFINE([HAVE_LIBMNL], [1], [libmnl usability])\n    AC_DEFINE([HAVE_LIBNETFILTER_ACCT], [1], [libnetfilter_acct usability])\n    AC_DEFINE([HAVE_LINUX_NETFILTER_NFNETLINK_CONNTRACK_H], [1], [libnetfilter_nfnetlink_conntrack header usability])\n    OPTIONAL_NFACCT_CFLAGS=\"${NFACCT_CFLAGS} ${LIBMNL_CFLAGS}\"\n    OPTIONAL_NFACCT_LIBS=\"${NFACCT_LIBS} ${LIBMNL_LIBS}\"\nelse\n    enable_plugin_nfacct=\"no\"\nfi\nAC_MSG_RESULT([${enable_plugin_nfacct}])\nAM_CONDITIONAL([ENABLE_PLUGIN_NFACCT], [test \"${enable_plugin_nfacct}\" = \"yes\"])\n\n\n# -----------------------------------------------------------------------------\n# xenstat.plugin - libxenstat\n\nPKG_CHECK_MODULES(\n    [YAJL],\n    [yajl],\n    [AC_CHECK_LIB(\n        [yajl],\n        [yajl_tree_get],\n        [have_libyajl=yes],\n        [have_libyajl=no]\n    )],\n    [have_libyajl=no]\n)\n\nAC_CHECK_LIB(\n    [xenstat],\n    [xenstat_init],\n    [AC_CHECK_HEADER(\n        [xenstat.h],\n        [have_libxenstat=yes],\n        [have_libxenstat=no]\n    )],\n    [have_libxenstat=no],\n    [-lyajl]\n)\n\nPKG_CHECK_MODULES(\n    [XENLIGHT],\n    [xenlight],\n    [AC_CHECK_LIB(\n        [xenlight],\n        [libxl_domain_info],\n        [AC_CHECK_HEADER(\n            [libxl.h],\n            [have_libxenlight=yes],\n            [have_libxenlight=no]\n        )],\n        [have_libxenlight=no]\n    )],\n    [have_libxenlight=no]\n)\n\ntest \"${enable_plugin_xenstat}\" = \"yes\" -a \"${have_libxenstat}\" != \"yes\" && \\\n    AC_MSG_ERROR([libxenstat required but not found. try installing 'xen-dom0-libs-devel'])\n\ntest \"${enable_plugin_xenstat}\" = \"yes\" -a \"${have_libxenlight}\" != \"yes\" && \\\n    AC_MSG_ERROR([libxenlight required but not found. try installing 'xen-dom0-libs-devel'])\n\ntest \"${enable_plugin_xenstat}\" = \"yes\" -a \"${have_libyajl}\" != \"yes\" && \\\n    AC_MSG_ERROR([libyajl required but not found. Try installing 'yajl-devel'])\n\nAC_MSG_CHECKING([if xenstat.plugin should be enabled])\nif test \"${enable_plugin_xenstat}\" != \"no\" -a \"${have_libxenstat}\" = \"yes\" -a \"${have_libxenlight}\" = \"yes\" -a \"${have_libyajl}\" = \"yes\"; then\n    enable_plugin_xenstat=\"yes\"\n    AC_DEFINE([HAVE_LIBXENSTAT], [1], [libxenstat usability])\n    AC_DEFINE([HAVE_LIBXENLIGHT], [1], [libxenlight usability])\n    AC_DEFINE([HAVE_LIBYAJL], [1], [libyajl usability])\n    OPTIONAL_XENSTAT_CFLAGS=\"${XENLIGHT_CFLAGS} ${YAJL_CFLAGS}\"\n    OPTIONAL_XENSTAT_LIBS=\"-lxenstat ${XENLIGHT_LIBS} ${YAJL_LIBS}\"\nelse\n    enable_plugin_xenstat=\"no\"\nfi\nAC_MSG_RESULT([${enable_plugin_xenstat}])\nAM_CONDITIONAL([ENABLE_PLUGIN_XENSTAT], [test \"${enable_plugin_xenstat}\" = \"yes\"])\n\nif test \"${enable_plugin_xenstat}\" == \"yes\"; then\n    AC_MSG_CHECKING([for xenstat_vbd_error in -lxenstat])\n    AC_TRY_LINK(\n        [ #include <xenstat.h> ],\n        [\n            xenstat_vbd * vbd;\n            int out = xenstat_vbd_error(vbd);\n        ],\n        [\n            have_xenstat_vbd_error=yes\n            AC_DEFINE([HAVE_XENSTAT_VBD_ERROR], [1], [xenstat_vbd_error usability])\n        ],\n        [ have_xenstat_vbd_error=no ]\n    )\n    AC_MSG_RESULT([${have_xenstat_vbd_error}])\nfi\n\n# -----------------------------------------------------------------------------\n# perf.plugin\n\nAC_CHECK_HEADER(\n    [linux/perf_event.h],\n    [AC_CHECK_DECL(\n        [PERF_COUNT_HW_REF_CPU_CYCLES],\n        [have_perf_event=yes],\n        [have_perf_event=no],\n        [#include <linux/perf_event.h>]\n    )],\n    [have_perf_event=no]\n)\n\nAC_MSG_CHECKING([if perf.plugin should be enabled])\nif test \"${build_target}\" == \"linux\" -a \"${have_perf_event}\" = \"yes\"; then\n    enable_plugin_perf=\"yes\"\nelse\n    enable_plugin_perf=\"no\"\nfi\nAC_MSG_RESULT([${enable_plugin_perf}])\nAM_CONDITIONAL([ENABLE_PLUGIN_PERF], [test \"${enable_plugin_perf}\" = \"yes\"])\n\n# -----------------------------------------------------------------------------\n# ebpf_process.plugin\n\nAC_MSG_CHECKING([if ebpf_process.plugin should be enabled])\nif test \"${build_target}\" == \"linux\" -a \"${EBPF_LIBS}\"; then\n    enable_vfs=\"yes\"\nelse\n    enable_vfs=\"no\"\nfi\nAC_MSG_RESULT([${enable_vfs}])\nAM_CONDITIONAL([ENABLE_PLUGIN_EBPF], [test \"${enable_vfs}\" = \"yes\"])\n\n# -----------------------------------------------------------------------------\n# slabinfo.plugin\n\nAC_MSG_CHECKING([if slabinfo.plugin should be enabled])\nif test \"${build_target}\" == \"linux\"; then\n    enable_plugin_slabinfo=\"yes\"\nelse\n    enable_plugin_slabinfo=\"no\"\nfi\nAC_MSG_RESULT([${enable_plugin_slabinfo}])\nAM_CONDITIONAL([ENABLE_PLUGIN_SLABINFO], [test \"${enable_plugin_slabinfo}\" = \"yes\"])\n\n\n# -----------------------------------------------------------------------------\n# AWS Kinesis backend - libaws-cpp-sdk-kinesis, libaws-cpp-sdk-core, libssl, libcrypto, libcurl\n\nPKG_CHECK_MODULES(\n    [LIBCRYPTO],\n    [libcrypto],\n    [AC_CHECK_LIB(\n        [crypto],\n        [CRYPTO_new_ex_data],\n        [have_libcrypto=yes],\n        [have_libcrypto=no]\n    )],\n    [have_libcrypto=no]\n)\n\nPKG_CHECK_MODULES(\n    [LIBSSL],\n    [libssl],\n    [AC_CHECK_LIB(\n        [ssl],\n        [SSL_connect],\n        [have_libssl=yes],\n        [have_libssl=no]\n    )],\n    [have_libssl=no]\n)\n\nPKG_CHECK_MODULES(\n    [LIBCURL],\n    [libcurl],\n    [AC_CHECK_LIB(\n        [curl],\n        [curl_easy_init],\n        [have_libcurl=yes],\n        [have_libcurl=no]\n    )],\n    [have_libcurl=no]\n)\n\nAC_CHECK_LIB(\n    [aws-cpp-sdk-core],\n    [cJSON_free],\n    [have_libaws_cpp_sdk_core=yes],\n    [have_libaws_cpp_sdk_core=no],\n    [${LIBCRYPTO_LIBS} ${LIBSSL_LIBS} ${LIBCURL_LIBS}]\n)\n\nAC_MSG_CHECKING([for Aws::Kinesis::Model::PutRecordRequest in -laws-cpp-sdk-kinesis])\n\nif test \"${have_libaws_cpp_sdk_core}\" = \"yes\" -a \"${have_libcrypto}\" = \"yes\" -a \"${have_libssl}\" = \"yes\" -a \"${have_libcurl}\" = \"yes\"; then\n    AC_LANG_SAVE\n    AC_LANG_CPLUSPLUS\n    save_LIBS=\"${LIBS}\"\n    LIBS=\"-laws-cpp-sdk-kinesis -laws-cpp-sdk-core ${LIBCRYPTO_LIBS} ${LIBSSL_LIBS} ${LIBCURL_LIBS}\"\n    save_CXXFLAGS=\"${CXXFLAGS}\"\n    CXXFLAGS=\"${CXXFLAGS} -std=c++11\"\n\n    AC_TRY_LINK(\n        [\n            #include <aws/core/Aws.h>\n            #include <aws/core/client/ClientConfiguration.h>\n            #include <aws/core/auth/AWSCredentials.h>\n            #include <aws/core/utils/Outcome.h>\n            #include <aws/kinesis/KinesisClient.h>\n            #include <aws/kinesis/model/PutRecordRequest.h>\n        ],\n        [Aws::Kinesis::Model::PutRecordRequest request;],\n        [have_libaws_cpp_sdk_kinesis=yes],\n        [have_libaws_cpp_sdk_kinesis=no]\n    )\n\n    LIBS=\"${save_LIBS}\"\n    CXXFLAGS=\"${save_CXXFLAGS}\"\n    AC_LANG_RESTORE\nelse\n    have_libaws_cpp_sdk_kinesis=no\nfi\n\nAC_MSG_RESULT([${have_libaws_cpp_sdk_kinesis}])\n\ntest \"${enable_backend_kinesis}\" = \"yes\" -a \"${have_libaws_cpp_sdk_kinesis}\" != \"yes\" && \\\n    AC_MSG_ERROR([libaws-cpp-sdk-kinesis required but not found. try installing AWS C++ SDK])\n\ntest \"${enable_backend_kinesis}\" = \"yes\" -a \"${have_libaws_cpp_sdk_core}\" != \"yes\" && \\\n    AC_MSG_ERROR([libaws-cpp-sdk-core required but not found. try installing AWS C++ SDK])\n\ntest \"${enable_backend_kinesis}\" = \"yes\" -a \"${have_libcurl}\" != \"yes\" && \\\n    AC_MSG_ERROR([libcurl required but not found])\n\ntest \"${enable_backend_kinesis}\" = \"yes\" -a \"${have_libssl}\" != \"yes\" && \\\n    AC_MSG_ERROR([libssl required but not found])\n\ntest \"${enable_backend_kinesis}\" = \"yes\" -a \"${have_libcrypto}\" != \"yes\" && \\\n    AC_MSG_ERROR([libcrypto required but not found])\n\nAC_MSG_CHECKING([if kinesis backend should be enabled])\nif test \"${enable_backend_kinesis}\" != \"no\" -a \"${have_libaws_cpp_sdk_kinesis}\" = \"yes\" -a \"${have_libaws_cpp_sdk_core}\" = \"yes\" \\\n                                            -a \"${have_libcurl}\" = \"yes\" -a \"${have_libssl}\" = \"yes\" -a \"${have_libcrypto}\" = \"yes\"; then\n    enable_backend_kinesis=\"yes\"\n    AC_DEFINE([HAVE_KINESIS], [1], [libaws-cpp-sdk-kinesis usability])\n    OPTIONAL_KINESIS_CFLAGS=\"${LIBCRYPTO_CFLAGS} ${LIBSSL_CFLAGS} ${LIBCURL_CFLAGS}\"\n    CXX11FLAG=\"-std=c++11\"\n    OPTIONAL_KINESIS_LIBS=\"-laws-cpp-sdk-kinesis -laws-cpp-sdk-core ${LIBCRYPTO_LIBS} ${LIBSSL_LIBS} ${LIBCURL_LIBS}\"\nelse\n    enable_backend_kinesis=\"no\"\nfi\n\nAC_MSG_RESULT([${enable_backend_kinesis}])\nAM_CONDITIONAL([ENABLE_BACKEND_KINESIS], [test \"${enable_backend_kinesis}\" = \"yes\"])\n\n\n# -----------------------------------------------------------------------------\n# Prometheus remote write backend - libprotobuf, libsnappy, protoc\n\nPKG_CHECK_MODULES(\n    [PROTOBUF],\n    [protobuf >= 3],\n    [have_libprotobuf=yes],\n    [have_libprotobuf=no]\n)\n\nAC_MSG_CHECKING([for snappy::RawCompress in -lsnappy])\n\n    AC_LANG_SAVE\n    AC_LANG_CPLUSPLUS\n    save_LIBS=\"${LIBS}\"\n    LIBS=\"-lsnappy\"\n    save_CXXFLAGS=\"${CXXFLAGS}\"\n    CXXFLAGS=\"${CXXFLAGS} -std=c++11\"\n\n    AC_TRY_LINK(\n        [\n            #include <stdlib.h>\n            #include <snappy.h>\n        ],\n        [\n            const char *input = \"test\";\n            size_t compressed_length;\n            char *buffer = (char *)malloc(5 * sizeof(char));\n            snappy::RawCompress(input, 4, buffer, &compressed_length);\n            free(buffer);\n        ],\n        [\n            have_libsnappy=yes\n            SNAPPY_CFLAGS=\"\"\n            SNAPPY_LIBS=\"-lsnappy\"\n        ],\n        [have_libsnappy=no]\n    )\n\n    LIBS=\"${save_LIBS}\"\n    CXXFLAGS=\"${save_CXXFLAGS}\"\n    AC_LANG_RESTORE\n\nAC_MSG_RESULT([${have_libsnappy}])\n\nAC_PATH_PROG([PROTOC], [protoc], [no])\nAS_IF(\n    [test x\"${PROTOC}\" == x\"no\"],\n    [have_protoc=no],\n    [have_protoc=yes]\n)\n\nAC_PATH_PROG([CXX_BINARY], [${CXX}], [no])\nAS_IF(\n    [test x\"${CXX_BINARY}\" == x\"no\"],\n    [have_CXX_compiler=no],\n    [have_CXX_compiler=yes]\n)\n\ntest \"${enable_backend_prometheus_remote_write}\" = \"yes\" -a \"${have_libprotobuf}\" != \"yes\" && \\\n    AC_MSG_ERROR([libprotobuf required but not found. try installing protobuf])\n\ntest \"${enable_backend_prometheus_remote_write}\" = \"yes\" -a \"${have_libsnappy}\" != \"yes\" && \\\n    AC_MSG_ERROR([libsnappy required but not found. try installing snappy])\n\ntest \"${enable_backend_prometheus_remote_write}\" = \"yes\" -a \"${have_protoc}\" != \"yes\" && \\\n    AC_MSG_ERROR([protoc compiler required but not found. try installing protobuf])\n\ntest \"${enable_backend_prometheus_remote_write}\" = \"yes\" -a \"${have_CXX_compiler}\" != \"yes\" && \\\n    AC_MSG_ERROR([C++ compiler required but not found. try installing g++])\n\nAC_MSG_CHECKING([if prometheus remote write backend should be enabled])\nif test \"${enable_backend_prometheus_remote_write}\" != \"no\" -a \"${have_libprotobuf}\" = \"yes\" -a \"${have_libsnappy}\" = \"yes\" \\\n                                                           -a \"${have_protoc}\" = \"yes\" -a \"${have_CXX_compiler}\" = \"yes\"; then\n    enable_backend_prometheus_remote_write=\"yes\"\n    AC_DEFINE([ENABLE_PROMETHEUS_REMOTE_WRITE], [1], [Prometheus remote write API usability])\n    OPTIONAL_PROMETHEUS_REMOTE_WRITE_CFLAGS=\"${PROTOBUF_CFLAGS} ${SNAPPY_CFLAGS} -Iexporting/prometheus/remote_write\"\n    CXX11FLAG=\"-std=c++11\"\n    OPTIONAL_PROMETHEUS_REMOTE_WRITE_LIBS=\"${PROTOBUF_LIBS} ${SNAPPY_LIBS}\"\nelse\n    enable_backend_prometheus_remote_write=\"no\"\nfi\n\nAC_MSG_RESULT([${enable_backend_prometheus_remote_write}])\nAM_CONDITIONAL([ENABLE_BACKEND_PROMETHEUS_REMOTE_WRITE], [test \"${enable_backend_prometheus_remote_write}\" = \"yes\"])\n\n\n# -----------------------------------------------------------------------------\n# MongoDB backend - libmongoc\n\nPKG_CHECK_MODULES(\n    [LIBMONGOC],\n    [libmongoc-1.0 >= 1.7],\n    [have_libmongoc=yes],\n    [have_libmongoc=no]\n)\n\ntest \"${enable_backend_mongodb}\" = \"yes\" -a \"${have_libmongoc}\" != \"yes\" && \\\n    AC_MSG_ERROR([libmongoc required but not found. Try installing `mongoc`.])\n\nAC_MSG_CHECKING([if mongodb backend should be enabled])\nif test \"${enable_backend_mongodb}\" != \"no\" -a \"${have_libmongoc}\" = \"yes\"; then\n    enable_backend_mongodb=\"yes\"\n    AC_DEFINE([HAVE_MONGOC], [1], [libmongoc usability])\n    OPTIONAL_MONGOC_CFLAGS=\"${LIBMONGOC_CFLAGS}\"\n    OPTIONAL_MONGOC_LIBS=\"${LIBMONGOC_LIBS}\"\nelse\n    enable_backend_mongodb=\"no\"\nfi\n\nAC_MSG_RESULT([${enable_backend_mongodb}])\nAM_CONDITIONAL([ENABLE_BACKEND_MONGODB], [test \"${enable_backend_mongodb}\" = \"yes\"])\n\n\n# -----------------------------------------------------------------------------\n# check for setns() - cgroup-network\n\nAC_CHECK_FUNC([setns])\nAC_MSG_CHECKING([if cgroup-network can be enabled])\nif test \"$ac_cv_func_setns\" = \"yes\" ; then\n    have_setns=\"yes\"\n    AC_DEFINE([HAVE_SETNS], [1], [Define 1 if you have setns() function])\nelse\n    have_setns=\"no\"\nfi\nAC_MSG_RESULT([${have_setns}])\nAM_CONDITIONAL([ENABLE_PLUGIN_CGROUP_NETWORK], [test \"${have_setns}\" = \"yes\"])\n\n\n# -----------------------------------------------------------------------------\n# Link-Time-Optimization\n\nif test \"${enable_lto}\" != \"no\"; then\n    opt=\"-flto\"\n    AX_CHECK_COMPILE_FLAG(${opt}, [have_lto=yes], [have_lto=no])\nfi\nif test \"${have_lto}\" = \"yes\"; then\n    oCFLAGS=\"${CFLAGS}\"\n    CFLAGS=\"${CFLAGS} -flto\"\n    ac_cv_c_lto_cross_compile=\"${enable_lto}\"\n    test \"${ac_cv_c_lto_cross_compile}\" != \"yes\" && ac_cv_c_lto_cross_compile=\"no\"\n    AC_C_LTO\n    CFLAGS=\"${oCFLAGS}\"\n    test \"${ac_cv_c_lto}\" != \"yes\" && have_lto=\"no\"\nfi\ntest \"${enable_lto}\" = \"yes\" -a \"${have_lto}\" != \"yes\" && \\\n    AC_MSG_ERROR([LTO is required but is not available.])\nAC_MSG_CHECKING([if LTO should be enabled])\nif test \"${enable_lto}\" != \"no\" -a \"${have_lto}\" = \"yes\"; then\n    enable_lto=\"yes\"\n    CFLAGS=\"${CFLAGS} -flto\"\nelse\n    enable_lto=\"no\"\nfi\nAC_MSG_RESULT([${enable_lto}])\n\n\n# -----------------------------------------------------------------------------\n\nAM_CONDITIONAL([ENABLE_CXX_LINKER], [test \"${enable_backend_kinesis}\" = \"yes\" -o \"${enable_backend_prometheus_remote_write}\" = \"yes\"])\n\nAC_DEFINE_UNQUOTED([NETDATA_USER], [\"${with_user}\"], [use this user to drop privileged])\n\nvarlibdir=\"${localstatedir}/lib/netdata\"\nregistrydir=\"${localstatedir}/lib/netdata/registry\"\ncachedir=\"${localstatedir}/cache/netdata\"\nchartsdir=\"${libexecdir}/netdata/charts.d\"\nnodedir=\"${libexecdir}/netdata/node.d\"\npythondir=\"${libexecdir}/netdata/python.d\"\nconfigdir=\"${sysconfdir}/netdata\"\nlibconfigdir=\"${libdir}/netdata/conf.d\"\nlogdir=\"${localstatedir}/log/netdata\"\npluginsdir=\"${libexecdir}/netdata/plugins.d\"\n\nAC_SUBST([build_target])\nAC_SUBST([varlibdir])\nAC_SUBST([registrydir])\nAC_SUBST([cachedir])\nAC_SUBST([chartsdir])\nAC_SUBST([nodedir])\nAC_SUBST([pythondir])\nAC_SUBST([configdir])\nAC_SUBST([libconfigdir])\nAC_SUBST([logdir])\nAC_SUBST([pluginsdir])\nAC_SUBST([webdir])\n\nCFLAGS=\"${CFLAGS} ${OPTIONAL_MATH_CFLAGS} ${OPTIONAL_NFACCT_CFLAGS} ${OPTIONAL_ZLIB_CFLAGS} ${OPTIONAL_UUID_CFLAGS} \\\n    ${OPTIONAL_LIBCAP_CFLAGS} ${OPTIONAL_IPMIMONITORING_CFLAGS} ${OPTIONAL_CUPS_CFLAGS} ${OPTIONAL_XENSTAT_FLAGS} \\\n    ${OPTIONAL_KINESIS_CFLAGS} ${OPTIONAL_PROMETHEUS_REMOTE_WRITE_CFLAGS} ${OPTIONAL_MONGOC_CFLAGS} ${LWS_CFLAGS} \\\n\t${OPTIONAL_JSONC_STATIC_CFLAGS}\"\n\nCXXFLAGS=\"${CFLAGS} ${CXX11FLAG}\"\n\nCPPFLAGS=\"\\\n    -DTARGET_OS=${build_target_id} \\\n\t-DVARLIB_DIR=\\\"\\\\\\\"${varlibdir}\\\\\\\"\\\" \\\n\t-DCACHE_DIR=\\\"\\\\\\\"${cachedir}\\\\\\\"\\\" \\\n\t-DCONFIG_DIR=\\\"\\\\\\\"${configdir}\\\\\\\"\\\" \\\n\t-DLIBCONFIG_DIR=\\\"\\\\\\\"${libconfigdir}\\\\\\\"\\\" \\\n\t-DLOG_DIR=\\\"\\\\\\\"${logdir}\\\\\\\"\\\" \\\n\t-DPLUGINS_DIR=\\\"\\\\\\\"${pluginsdir}\\\\\\\"\\\" \\\n\t-DRUN_DIR=\\\"\\\\\\\"${localstatedir}/run/netdata\\\\\\\"\\\" \\\n\t-DWEB_DIR=\\\"\\\\\\\"${webdir}\\\\\\\"\\\" \\\n\"\n\nAC_SUBST([OPTIONAL_MATH_CFLAGS])\nAC_SUBST([OPTIONAL_MATH_LIBS])\nAC_SUBST([OPTIONAL_UV_LIBS])\nAC_SUBST([OPTIONAL_LZ4_LIBS])\nAC_SUBST([OPTIONAL_JUDY_LIBS])\nAC_SUBST([OPTIONAL_SSL_LIBS])\nAC_SUBST([OPTIONAL_EBPF_LIBS])\nAC_SUBST([OPTIONAL_JSONC_LIBS])\nAC_SUBST([OPTIONAL_NFACCT_CFLAGS])\nAC_SUBST([OPTIONAL_NFACCT_LIBS])\nAC_SUBST([OPTIONAL_ZLIB_CFLAGS])\nAC_SUBST([OPTIONAL_ZLIB_LIBS])\nAC_SUBST([OPTIONAL_UUID_CFLAGS])\nAC_SUBST([OPTIONAL_UUID_LIBS])\nAC_SUBST([OPTIONAL_MQTT_LIBS])\nAC_SUBST([OPTIONAL_LIBCAP_CFLAGS])\nAC_SUBST([OPTIONAL_LIBCAP_LIBS])\nAC_SUBST([OPTIONAL_IPMIMONITORING_CFLAGS])\nAC_SUBST([OPTIONAL_IPMIMONITORING_LIBS])\nAC_SUBST([OPTIONAL_CUPS_CFLAGS])\nAC_SUBST([OPTIONAL_CUPS_LIBS])\nAC_SUBST([OPTIONAL_XENSTAT_CFLAGS])\nAC_SUBST([OPTIONAL_XENSTAT_LIBS])\nAC_SUBST([OPTIONAL_KINESIS_CFLAGS])\nAC_SUBST([OPTIONAL_KINESIS_LIBS])\nAC_SUBST([OPTIONAL_PROMETHEUS_REMOTE_WRITE_CFLAGS])\nAC_SUBST([OPTIONAL_PROMETHEUS_REMOTE_WRITE_LIBS])\nAC_SUBST([OPTIONAL_MONGOC_CFLAGS])\nAC_SUBST([OPTIONAL_MONGOC_LIBS])\n\n# -----------------------------------------------------------------------------\n# Check if cmocka is available - needed for unit testing\n\nAC_ARG_ENABLE(\n     [unit-tests],\n     [AS_HELP_STRING([--disable-unit-tests],\n                     [Disables building and running the unit tests suite])],\n     [],\n     [enable_unit_tests=\"yes\"]\n)\n\n\nPKG_CHECK_MODULES(\n    [CMOCKA],\n    [cmocka],\n    [have_cmocka=\"yes\"],\n    [AC_MSG_NOTICE([CMocka not found on the system. Unit tests disabled])]\n)\nAM_CONDITIONAL([ENABLE_UNITTESTS], [test \"${enable_unit_tests}\" = \"yes\" -a \"${have_cmocka}\" = \"yes\" ])\nAC_SUBST([ENABLE_UNITTESTS])\n\nTEST_CFLAGS=\"${CFLAGS} ${CMOCKA_CFLAGS}\"\nTEST_LIBS=\"${CMOCKA_LIBS}\"\n\nAC_SUBST([TEST_CFLAGS])\nAC_SUBST([TEST_LIBS])\n\nAC_CONFIG_FILES([\n    Makefile\n    netdata.spec\n    backends/graphite/Makefile\n    backends/json/Makefile\n    backends/Makefile\n    backends/opentsdb/Makefile\n    backends/prometheus/Makefile\n    backends/prometheus/remote_write/Makefile\n    backends/aws_kinesis/Makefile\n    backends/mongodb/Makefile\n    collectors/Makefile\n    collectors/apps.plugin/Makefile\n    collectors/cgroups.plugin/Makefile\n    collectors/charts.d.plugin/Makefile\n    collectors/checks.plugin/Makefile\n    collectors/diskspace.plugin/Makefile\n    collectors/fping.plugin/Makefile\n    collectors/ioping.plugin/Makefile\n    collectors/freebsd.plugin/Makefile\n    collectors/freeipmi.plugin/Makefile\n    collectors/cups.plugin/Makefile\n    collectors/idlejitter.plugin/Makefile\n    collectors/macos.plugin/Makefile\n    collectors/nfacct.plugin/Makefile\n    collectors/node.d.plugin/Makefile\n    collectors/plugins.d/Makefile\n    collectors/proc.plugin/Makefile\n    collectors/python.d.plugin/Makefile\n    collectors/slabinfo.plugin/Makefile\n    collectors/statsd.plugin/Makefile\n    collectors/ebpf_process.plugin/Makefile\n    collectors/tc.plugin/Makefile\n    collectors/xenstat.plugin/Makefile\n    collectors/perf.plugin/Makefile\n    daemon/Makefile\n    database/Makefile\n    database/engine/Makefile\n    diagrams/Makefile\n    exporting/Makefile\n    exporting/graphite/Makefile\n    exporting/json/Makefile\n    exporting/opentsdb/Makefile\n    exporting/prometheus/Makefile\n    exporting/prometheus/remote_write/Makefile\n    exporting/aws_kinesis/Makefile\n    exporting/mongodb/Makefile\n    exporting/tests/Makefile\n    health/Makefile\n    health/notifications/Makefile\n    libnetdata/Makefile\n    libnetdata/tests/Makefile\n    libnetdata/adaptive_resortable_list/Makefile\n    libnetdata/avl/Makefile\n    libnetdata/buffer/Makefile\n    libnetdata/clocks/Makefile\n    libnetdata/config/Makefile\n    libnetdata/dictionary/Makefile\n    libnetdata/ebpf/Makefile\n    libnetdata/eval/Makefile\n    libnetdata/locks/Makefile\n    libnetdata/log/Makefile\n    libnetdata/popen/Makefile\n    libnetdata/procfile/Makefile\n    libnetdata/simple_pattern/Makefile\n    libnetdata/socket/Makefile\n    libnetdata/statistical/Makefile\n    libnetdata/storage_number/Makefile\n    libnetdata/storage_number/tests/Makefile\n    libnetdata/threads/Makefile\n    libnetdata/url/Makefile\n    libnetdata/json/Makefile\n    libnetdata/health/Makefile\n    registry/Makefile\n    streaming/Makefile\n    system/Makefile\n    tests/Makefile\n    web/Makefile\n    web/api/Makefile\n    web/api/badges/Makefile\n    web/api/exporters/Makefile\n    web/api/exporters/shell/Makefile\n    web/api/exporters/prometheus/Makefile\n    web/api/formatters/Makefile\n    web/api/formatters/csv/Makefile\n    web/api/formatters/json/Makefile\n    web/api/formatters/ssv/Makefile\n    web/api/formatters/value/Makefile\n    web/api/queries/Makefile\n    web/api/queries/average/Makefile\n    web/api/queries/des/Makefile\n    web/api/queries/incremental_sum/Makefile\n    web/api/queries/max/Makefile\n    web/api/queries/median/Makefile\n    web/api/queries/min/Makefile\n    web/api/queries/ses/Makefile\n    web/api/queries/stddev/Makefile\n    web/api/queries/sum/Makefile\n    web/api/health/Makefile\n    web/gui/Makefile\n    web/server/Makefile\n    web/server/static/Makefile\n    claim/Makefile\n    aclk/Makefile\n])\nAC_OUTPUT\n\ntest \"${with_math}\" != \"yes\" && AC_MSG_WARN([You are building without math. math allows accurate calculations. It should be enabled.]) || :\ntest \"${with_zlib}\" != \"yes\" && AC_MSG_WARN([You are building without zlib. zlib allows netdata to transfer a lot less data with web clients. It should be enabled.]) || :\n",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/collectors/ebpf_process.plugin/ebpf_process.c": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n#include <sys/time.h>\n#include <sys/resource.h>\n\n#include \"ebpf_process.h\"\n\n// callback required by eval()\nint health_variable_lookup(const char *variable, uint32_t hash, struct rrdcalc *rc, calculated_number *result) {\n    (void)variable;\n    (void)hash;\n    (void)rc;\n    (void)result;\n    return 0;\n};\n\nvoid send_statistics( const char *action, const char *action_result, const char *action_data) {\n    (void) action;\n    (void) action_result;\n    (void) action_data;\n    return;\n}\n\n// callbacks required by popen()\nvoid signals_block(void) {};\nvoid signals_unblock(void) {};\nvoid signals_reset(void) {};\n\n// required by get_system_cpus()\nchar *netdata_configured_host_prefix = \"\";\n\n// callback required by fatal()\nvoid netdata_cleanup_and_exit(int ret) {\n    exit(ret);\n}\n\n// ----------------------------------------------------------------------\n//Netdata eBPF library\nvoid *libnetdata = NULL;\nint (*load_bpf_file)(char *, int) = NULL;\nint (*set_bpf_perf_event)(int, int);\nint (*perf_event_unmap)(struct perf_event_mmap_page *, size_t);\nint (*perf_event_mmap_header)(int, struct perf_event_mmap_page **, int);\nvoid (*netdata_perf_loop_multi)(int *, struct perf_event_mmap_page **, int, int *, int (*nsb)(void *, int), int);\nint *map_fd = NULL;\n\n//Perf event variables\nstatic int pmu_fd[NETDATA_MAX_PROCESSOR];\nstatic struct perf_event_mmap_page *headers[NETDATA_MAX_PROCESSOR];\nint page_cnt = 8;\n\n//Libbpf (It is necessary to have at least kernel 4.10)\nint (*bpf_map_lookup_elem)(int, const void *, void *);\n\nstatic char *plugin_dir = PLUGINS_DIR;\nstatic char *user_config_dir = CONFIG_DIR;\nstatic char *stock_config_dir = LIBCONFIG_DIR;\nstatic char *netdata_configured_log_dir = LOG_DIR;\n\nFILE *developer_log = NULL;\n\n//Global vectors\nnetdata_syscall_stat_t *aggregated_data = NULL;\nnetdata_publish_syscall_t *publish_aggregated = NULL;\n\nstatic int update_every = 1;\nstatic int thread_finished = 0;\nstatic int close_plugin = 0;\nstatic int mode = 2;\nstatic int debug_log = 0;\nstatic int use_stdout = 0;\nstruct config collector_config;\nstatic int mykernel = 0;\nstatic int nprocs;\nstatic int isrh;\nnetdata_idx_t *hash_values;\n\npthread_mutex_t lock;\n\nstatic char *dimension_names[NETDATA_MAX_MONITOR_VECTOR] = { \"open\", \"close\", \"delete\", \"read\", \"write\", \"process\", \"task\", \"process\", \"thread\" };\nstatic char *id_names[NETDATA_MAX_MONITOR_VECTOR] = { \"do_sys_open\", \"__close_fd\", \"vfs_unlink\", \"vfs_read\", \"vfs_write\", \"do_exit\", \"release_task\", \"_do_fork\", \"sys_clone\" };\nstatic char *status[] = { \"process\", \"zombie\" };\n\nint event_pid = 0;\nnetdata_ebpf_events_t collector_events[] = {\n        { .type = 'r', .name = \"vfs_write\" },\n        { .type = 'r', .name = \"vfs_writev\" },\n        { .type = 'r', .name = \"vfs_read\" },\n        { .type = 'r', .name = \"vfs_readv\" },\n        { .type = 'r', .name = \"do_sys_open\" },\n        { .type = 'r', .name = \"vfs_unlink\" },\n        { .type = 'p', .name = \"do_exit\" },\n        { .type = 'p', .name = \"release_task\" },\n        { .type = 'r', .name = \"_do_fork\" },\n        { .type = 'r', .name = \"__close_fd\" },\n        { .type = 'r', .name = \"__x64_sys_clone\" },\n        { .type = 0, .name = NULL }\n};\n\nvoid open_developer_log() {\n    char filename[FILENAME_MAX+1];\n    int tot = sprintf(filename, \"%s/%s\",  netdata_configured_log_dir, NETDATA_DEVELOPER_LOG_FILE);\n\n    if(tot > 0)\n        developer_log = fopen(filename, \"a\");\n}\n\nstatic int unmap_memory() {\n    int i;\n    int size = (int)sysconf(_SC_PAGESIZE)*(page_cnt + 1);\n    for ( i = 0 ; i < nprocs ; i++ ) {\n        if (perf_event_unmap(headers[i], size) < 0) {\n            fprintf(stderr,\"[EBPF PROCESS] CANNOT unmap headers.\\n\");\n            return -1;\n        }\n\n        close(pmu_fd[i]);\n    }\n\n    return 0;\n}\n\nstatic void int_exit(int sig)\n{\n    close_plugin = 1;\n\n    //When both threads were not finished case I try to go in front this address, the collector will crash\n    if (!thread_finished) {\n        return;\n    }\n\n    if (aggregated_data) {\n        free(aggregated_data);\n        aggregated_data = NULL;\n    }\n\n    if (publish_aggregated) {\n        free(publish_aggregated);\n        publish_aggregated = NULL;\n    }\n\n    if(mode == 1 && debug_log) {\n        unmap_memory();\n    }\n\n    if (libnetdata) {\n        dlclose(libnetdata);\n        libnetdata = NULL;\n    }\n\n    if (developer_log) {\n        fclose(developer_log);\n        developer_log = NULL;\n    }\n\n    if (hash_values) {\n        freez(hash_values);\n    }\n\n    if (event_pid) {\n        int ret = fork();\n        if (ret < 0) //error\n            error(\"[EBPF PROCESS] Cannot fork(), so I won't be able to clean %skprobe_events\", NETDATA_DEBUGFS);\n        else if (!ret) { //child\n            int i;\n            for ( i=getdtablesize(); i>=0; --i)\n                close(i);\n\n            int fd = open(\"/dev/null\",O_RDWR, 0);\n            if (fd != -1) {\n                dup2 (fd, STDIN_FILENO);\n                dup2 (fd, STDOUT_FILENO);\n                dup2 (fd, STDERR_FILENO);\n            }\n\n            if (fd > 2)\n                close (fd);\n\n            int sid = setsid();\n            if(sid >= 0) {\n                sleep(1);\n                if(debug_log) {\n                    open_developer_log();\n                }\n                debug(D_EXIT, \"Wait for father %d die\", event_pid);\n                clean_kprobe_events(developer_log, event_pid, collector_events);\n            } else {\n                error(\"Cannot become session id leader, so I won't try to clean kprobe_events.\\n\");\n            }\n        } else { //parent\n            exit(0);\n        }\n\n        if (developer_log) {\n            fclose(developer_log);\n            developer_log = NULL;\n        }\n    }\n\n    exit(sig);\n}\n\nstatic inline void netdata_write_chart_cmd(char *type\n                                    , char *id\n                                    , char *axis\n                                    , char *web\n                                    , int order)\n{\n    printf(\"CHART %s.%s '' '' '%s' '%s' '' line %d 1 ''\\n\"\n            , type\n            , id\n            , axis\n            , web\n            , order);\n}\n\nstatic void netdata_write_global_dimension(char *d, char *n)\n{\n    printf(\"DIMENSION %s %s absolute 1 1\\n\", d, n);\n}\n\nstatic void netdata_create_global_dimension(void *ptr, int end)\n{\n    netdata_publish_syscall_t *move = ptr;\n\n    int i = 0;\n    while (move && i < end) {\n        netdata_write_global_dimension(move->name, move->dimension);\n\n        move = move->next;\n        i++;\n    }\n}\nstatic inline void netdata_create_chart(char *family\n                                , char *name\n                                , char *axis\n                                , char *web\n                                , int order\n                                , void (*ncd)(void *, int)\n                                , void *move\n                                , int end)\n{\n    netdata_write_chart_cmd(family, name, axis, web, order);\n\n    ncd(move, end);\n}\n\nstatic void netdata_create_io_chart(char *family, char *name, char *axis, char *web, int order) {\n    printf(\"CHART %s.%s '' '' '%s' '%s' '' line %d 1 ''\\n\"\n            , family\n            , name\n            , axis\n            , web\n            , order);\n\n    printf(\"DIMENSION %s %s absolute 1 1\\n\", id_names[3], NETDATA_VFS_DIM_OUT_FILE_BYTES);\n    printf(\"DIMENSION %s %s absolute 1 1\\n\", id_names[4], NETDATA_VFS_DIM_IN_FILE_BYTES);\n}\n\nstatic void netdata_process_status_chart(char *family, char *name, char *axis, char *web, int order) {\n    printf(\"CHART %s.%s '' '' '%s' '%s' '' line %d 1 ''\\n\"\n            , family\n            , name\n            , axis\n            , web\n            , order);\n\n    printf(\"DIMENSION %s '' absolute 1 1\\n\", status[0]);\n    printf(\"DIMENSION %s '' absolute 1 1\\n\", status[1]);\n}\n\nstatic void netdata_global_charts_create() {\n    netdata_create_chart(NETDATA_EBPF_FAMILY\n            , NETDATA_FILE_OPEN_CLOSE_COUNT\n            , \"Calls\"\n            , NETDATA_FILE_GROUP\n            , 970\n            , netdata_create_global_dimension\n            , publish_aggregated\n            , 2);\n\n    if(mode < 2) {\n        netdata_create_chart(NETDATA_EBPF_FAMILY\n                , NETDATA_FILE_OPEN_ERR_COUNT\n                , \"Calls\"\n                , NETDATA_FILE_GROUP\n                , 971\n                , netdata_create_global_dimension\n                , publish_aggregated\n                , 2);\n    }\n\n    netdata_create_chart(NETDATA_EBPF_FAMILY\n            , NETDATA_VFS_FILE_CLEAN_COUNT\n            , \"Calls\"\n            , NETDATA_VFS_GROUP\n            , 972\n            , netdata_create_global_dimension\n            , &publish_aggregated[NETDATA_DEL_START]\n            , 1);\n\n    netdata_create_chart(NETDATA_EBPF_FAMILY\n            , NETDATA_VFS_FILE_IO_COUNT\n            , \"Calls\"\n            , NETDATA_VFS_GROUP\n            , 973\n            , netdata_create_global_dimension\n            , &publish_aggregated[NETDATA_IN_START_BYTE]\n            , 2);\n\n    if(mode < 2) {\n        netdata_create_io_chart(NETDATA_EBPF_FAMILY\n                , NETDATA_VFS_IO_FILE_BYTES\n                , \"bytes/s\"\n                , NETDATA_VFS_GROUP\n                , 974);\n\n        netdata_create_chart(NETDATA_EBPF_FAMILY\n                , NETDATA_VFS_FILE_ERR_COUNT\n                , \"Calls\"\n                , NETDATA_VFS_GROUP\n                , 975\n                , netdata_create_global_dimension\n                , &publish_aggregated[2]\n                , NETDATA_VFS_ERRORS);\n\n    }\n\n    netdata_create_chart(NETDATA_EBPF_FAMILY\n            , NETDATA_PROCESS_SYSCALL\n            , \"Calls\"\n            , NETDATA_PROCESS_GROUP\n            , 976\n            , netdata_create_global_dimension\n            , &publish_aggregated[NETDATA_PROCESS_START]\n            , 2);\n\n    netdata_create_chart(NETDATA_EBPF_FAMILY\n            , NETDATA_EXIT_SYSCALL\n            , \"Calls\"\n            , NETDATA_PROCESS_GROUP\n            , 977\n            , netdata_create_global_dimension\n            , &publish_aggregated[NETDATA_EXIT_START]\n            , 2);\n\n    netdata_process_status_chart(NETDATA_EBPF_FAMILY\n            , NETDATA_PROCESS_STATUS_NAME\n            , \"Total\"\n            , NETDATA_PROCESS_GROUP\n            , 978);\n\n    if(mode < 2) {\n        netdata_create_chart(NETDATA_EBPF_FAMILY\n                , NETDATA_PROCESS_ERROR_NAME\n                , \"Calls\"\n                , NETDATA_PROCESS_GROUP\n                , 979\n                , netdata_create_global_dimension\n                , &publish_aggregated[NETDATA_PROCESS_START]\n                , 2);\n    }\n\n}\n\n\nstatic void netdata_create_charts() {\n    netdata_global_charts_create();\n}\n\nstatic void netdata_update_publish(netdata_publish_syscall_t *publish\n        , netdata_publish_vfs_common_t *pvc\n        , netdata_syscall_stat_t *input) {\n\n    netdata_publish_syscall_t *move = publish;\n    while(move) {\n        if(input->call != move->pcall) {\n            //This condition happens to avoid initial values with dimensions higher than normal values.\n            if(move->pcall) {\n                move->ncall = (input->call > move->pcall)?input->call - move->pcall: move->pcall - input->call;\n                move->nbyte = (input->bytes > move->pbyte)?input->bytes - move->pbyte: move->pbyte - input->bytes;\n                move->nerr = (input->ecall > move->nerr)?input->ecall - move->perr: move->perr - input->ecall;\n            } else {\n                move->ncall = 0;\n                move->nbyte = 0;\n                move->nerr = 0;\n            }\n\n            move->pcall = input->call;\n            move->pbyte = input->bytes;\n            move->perr = input->ecall;\n        } else {\n            move->ncall = 0;\n            move->nbyte = 0;\n            move->nerr = 0;\n        }\n\n        input = input->next;\n        move = move->next;\n    }\n\n    pvc->write = -((long)publish[2].nbyte);\n    pvc->read = (long)publish[3].nbyte;\n\n    pvc->running = (long)publish[7].ncall - (long)publish[8].ncall;\n    publish[6].ncall = -publish[6].ncall; // release\n    pvc->zombie = (long)publish[5].ncall + (long)publish[6].ncall;\n}\n\nstatic inline void write_begin_chart(char *family, char *name)\n{\n    int ret = printf( \"BEGIN %s.%s\\n\"\n            , family\n            , name);\n\n    (void)ret;\n}\n\nstatic inline void write_chart_dimension(char *dim, long long value)\n{\n    int ret = printf(\"SET %s = %lld\\n\", dim, value);\n    (void)ret;\n}\n\nstatic void write_global_count_chart(char *name, char *family, netdata_publish_syscall_t *move, int end) {\n    write_begin_chart(family, name);\n\n    int i = 0;\n    while (move && i < end) {\n        write_chart_dimension(move->name, move->ncall);\n\n        move = move->next;\n        i++;\n    }\n\n    printf(\"END\\n\");\n}\n\nstatic void write_global_err_chart(char *name, char *family, netdata_publish_syscall_t *move, int end) {\n    write_begin_chart(family, name);\n\n    int i = 0;\n    while (move && i < end) {\n        write_chart_dimension(move->name, move->nerr);\n\n        move = move->next;\n        i++;\n    }\n\n    printf(\"END\\n\");\n}\n\nstatic void write_io_chart(char *family, netdata_publish_vfs_common_t *pvc) {\n    write_begin_chart(family, NETDATA_VFS_IO_FILE_BYTES);\n\n    write_chart_dimension(id_names[3], (long long) pvc->write);\n    write_chart_dimension(id_names[4], (long long) pvc->read);\n\n    printf(\"END\\n\");\n}\n\nstatic void write_status_chart(char *family, netdata_publish_vfs_common_t *pvc) {\n    write_begin_chart(family, NETDATA_PROCESS_STATUS_NAME);\n\n    write_chart_dimension(status[0], (long long) pvc->running);\n    write_chart_dimension(status[1], (long long) pvc->zombie);\n\n    printf(\"END\\n\");\n}\n\nstatic void netdata_publish_data() {\n    netdata_publish_vfs_common_t pvc;\n    netdata_update_publish(publish_aggregated, &pvc, aggregated_data);\n\n    write_global_count_chart(NETDATA_FILE_OPEN_CLOSE_COUNT, NETDATA_EBPF_FAMILY, publish_aggregated, 2);\n    write_global_count_chart(NETDATA_VFS_FILE_CLEAN_COUNT, NETDATA_EBPF_FAMILY, &publish_aggregated[NETDATA_DEL_START], 1);\n    write_global_count_chart(NETDATA_VFS_FILE_IO_COUNT, NETDATA_EBPF_FAMILY, &publish_aggregated[NETDATA_IN_START_BYTE], 2);\n    write_global_count_chart(NETDATA_EXIT_SYSCALL, NETDATA_EBPF_FAMILY, &publish_aggregated[NETDATA_EXIT_START], 2);\n    write_global_count_chart(NETDATA_PROCESS_SYSCALL, NETDATA_EBPF_FAMILY, &publish_aggregated[NETDATA_PROCESS_START], 2);\n\n    write_status_chart(NETDATA_EBPF_FAMILY, &pvc);\n    if(mode < 2) {\n        write_global_err_chart(NETDATA_FILE_OPEN_ERR_COUNT, NETDATA_EBPF_FAMILY, publish_aggregated, 2);\n        write_global_err_chart(NETDATA_VFS_FILE_ERR_COUNT, NETDATA_EBPF_FAMILY, &publish_aggregated[2], NETDATA_VFS_ERRORS);\n        write_global_err_chart(NETDATA_PROCESS_ERROR_NAME, NETDATA_EBPF_FAMILY, &publish_aggregated[NETDATA_PROCESS_START], 2);\n\n        write_io_chart(NETDATA_EBPF_FAMILY, &pvc);\n    }\n}\n\nvoid *process_publisher(void *ptr)\n{\n    (void)ptr;\n    netdata_create_charts();\n\n    usec_t step = update_every * USEC_PER_SEC;\n    heartbeat_t hb;\n    heartbeat_init(&hb);\n    while(!close_plugin) {\n        usec_t dt = heartbeat_next(&hb, step);\n        (void)dt;\n\n        pthread_mutex_lock(&lock);\n        netdata_publish_data();\n        pthread_mutex_unlock(&lock);\n\n        fflush(stdout);\n    }\n\n    return NULL;\n}\n\nstatic void move_from_kernel2user_global() {\n    uint64_t idx;\n    netdata_idx_t res[NETDATA_GLOBAL_VECTOR];\n\n    netdata_idx_t *val = hash_values;\n    for (idx = 0; idx < NETDATA_GLOBAL_VECTOR; idx++) {\n        if(!bpf_map_lookup_elem(map_fd[1], &idx, val)) {\n            uint64_t total = 0;\n            int i;\n            int end = (mykernel < NETDATA_KERNEL_V4_15)?1:nprocs;\n            for (i = 0; i < end; i++)\n                total += val[i];\n\n            res[idx] = total;\n        } else {\n            res[idx] = 0;\n        }\n    }\n\n    aggregated_data[0].call = res[NETDATA_KEY_CALLS_DO_SYS_OPEN];\n    aggregated_data[1].call = res[NETDATA_KEY_CALLS_CLOSE_FD];\n    aggregated_data[2].call = res[NETDATA_KEY_CALLS_VFS_UNLINK];\n    aggregated_data[3].call = res[NETDATA_KEY_CALLS_VFS_READ] + res[NETDATA_KEY_CALLS_VFS_READV];\n    aggregated_data[4].call = res[NETDATA_KEY_CALLS_VFS_WRITE] + res[NETDATA_KEY_CALLS_VFS_WRITEV];\n    aggregated_data[5].call = res[NETDATA_KEY_CALLS_DO_EXIT];\n    aggregated_data[6].call = res[NETDATA_KEY_CALLS_RELEASE_TASK];\n    aggregated_data[7].call = res[NETDATA_KEY_CALLS_DO_FORK];\n    aggregated_data[8].call = res[NETDATA_KEY_CALLS_SYS_CLONE];\n\n    aggregated_data[0].ecall = res[NETDATA_KEY_ERROR_DO_SYS_OPEN];\n    aggregated_data[1].ecall = res[NETDATA_KEY_ERROR_CLOSE_FD];\n    aggregated_data[2].ecall = res[NETDATA_KEY_ERROR_VFS_UNLINK];\n    aggregated_data[3].ecall = res[NETDATA_KEY_ERROR_VFS_READ] + res[NETDATA_KEY_ERROR_VFS_READV];\n    aggregated_data[4].ecall = res[NETDATA_KEY_ERROR_VFS_WRITE] + res[NETDATA_KEY_ERROR_VFS_WRITEV];\n    aggregated_data[7].ecall = res[NETDATA_KEY_ERROR_DO_FORK];\n    aggregated_data[8].ecall = res[NETDATA_KEY_ERROR_SYS_CLONE];\n\n    aggregated_data[2].bytes = (uint64_t)res[NETDATA_KEY_BYTES_VFS_WRITE] + (uint64_t)res[NETDATA_KEY_BYTES_VFS_WRITEV];\n    aggregated_data[3].bytes = (uint64_t)res[NETDATA_KEY_BYTES_VFS_READ] + (uint64_t)res[NETDATA_KEY_BYTES_VFS_READV];\n}\n\nstatic void move_from_kernel2user()\n{\n    move_from_kernel2user_global();\n}\n\nvoid *process_collector(void *ptr)\n{\n    (void)ptr;\n\n    usec_t step = 778879ULL;\n    heartbeat_t hb;\n    heartbeat_init(&hb);\n    while(!close_plugin) {\n        usec_t dt = heartbeat_next(&hb, step);\n        (void)dt;\n\n        pthread_mutex_lock(&lock);\n        move_from_kernel2user();\n        pthread_mutex_unlock(&lock);\n    }\n\n    return NULL;\n}\n\nstatic int netdata_store_bpf(void *data, int size) {\n    (void)size;\n\n    if (close_plugin)\n        return 0;\n\n    if(!debug_log)\n        return -2; //LIBBPF_PERF_EVENT_CONT;\n\n    netdata_error_report_t *e = data;\n    fprintf(developer_log\n            ,\"%llu %s %u: %s, %d\\n\"\n            , now_realtime_usec() ,e->comm, e->pid, dimension_names[e->type], e->err);\n    fflush(developer_log);\n\n    return -2; //LIBBPF_PERF_EVENT_CONT;\n}\n\nvoid *process_log(void *ptr)\n{\n    (void) ptr;\n\n    if (mode == 1 && debug_log) {\n        netdata_perf_loop_multi(pmu_fd, headers, nprocs, &close_plugin, netdata_store_bpf, page_cnt);\n    }\n\n    return NULL;\n}\n\nvoid set_global_labels() {\n    int i;\n\n    netdata_syscall_stat_t *is = aggregated_data;\n    netdata_syscall_stat_t *prev = NULL;\n\n    netdata_publish_syscall_t *pio = publish_aggregated;\n    netdata_publish_syscall_t *publish_prev = NULL;\n    for (i = 0; i < NETDATA_MAX_MONITOR_VECTOR; i++) {\n        if(prev) {\n            prev->next = &is[i];\n        }\n        prev = &is[i];\n\n        pio[i].dimension = dimension_names[i];\n        pio[i].name = id_names[i];\n        if(publish_prev) {\n            publish_prev->next = &pio[i];\n        }\n        publish_prev = &pio[i];\n    }\n}\n\nint allocate_global_vectors() {\n    aggregated_data = callocz(NETDATA_MAX_MONITOR_VECTOR, sizeof(netdata_syscall_stat_t));\n    if(!aggregated_data) {\n        return -1;\n    }\n\n    publish_aggregated = callocz(NETDATA_MAX_MONITOR_VECTOR, sizeof(netdata_publish_syscall_t));\n    if(!publish_aggregated) {\n        return -1;\n    }\n\n    hash_values = callocz(nprocs, sizeof(netdata_idx_t));\n    if(!hash_values) {\n        return -1;\n    }\n\n    return 0;\n}\n\nstatic void build_complete_path(char *out, size_t length,char *path, char *filename) {\n    if(path){\n        snprintf(out, length, \"%s/%s\", path, filename);\n    } else {\n        snprintf(out, length, \"%s\", filename);\n    }\n}\n\nstatic int map_memory() {\n    int i;\n    for (i = 0; i < nprocs; i++) {\n        pmu_fd[i] = set_bpf_perf_event(i, 2);\n\n        if (perf_event_mmap_header(pmu_fd[i], &headers[i], page_cnt) < 0) {\n            return -1;\n        }\n    }\n    return 0;\n}\n\nstatic int ebpf_load_libraries()\n{\n    char *err = NULL;\n    char lpath[4096];\n\n    build_complete_path(lpath, 4096, plugin_dir, \"libnetdata_ebpf.so\");\n    libnetdata = dlopen(lpath, RTLD_LAZY);\n    if (!libnetdata) {\n        error(\"[EBPF_PROCESS] Cannot load %s.\", lpath);\n        return -1;\n    } else {\n        load_bpf_file = dlsym(libnetdata, \"load_bpf_file\");\n        if ((err = dlerror()) != NULL) {\n            error(\"[EBPF_PROCESS] Cannot find load_bpf_file: %s\", err);\n            return -1;\n        }\n\n        map_fd =  dlsym(libnetdata, \"map_fd\");\n        if ((err = dlerror()) != NULL) {\n            error(\"[EBPF_PROCESS] Cannot find map_fd: %s\", err);\n            return -1;\n        }\n\n        bpf_map_lookup_elem = dlsym(libnetdata, \"bpf_map_lookup_elem\");\n        if ((err = dlerror()) != NULL) {\n            error(\"[EBPF_PROCESS] Cannot find bpf_map_lookup_elem: %s\", err);\n            return -1;\n        }\n\n        if(mode == 1) {\n            set_bpf_perf_event = dlsym(libnetdata, \"set_bpf_perf_event\");\n            if ((err = dlerror()) != NULL) {\n                error(\"[EBPF_PROCESS] Cannot find set_bpf_perf_event: %s\", err);\n                return -1;\n            }\n\n            perf_event_unmap =  dlsym(libnetdata, \"perf_event_unmap\");\n            if ((err = dlerror()) != NULL) {\n                error(\"[EBPF_PROCESS] Cannot find perf_event_unmap: %s\", err);\n                return -1;\n            }\n\n            perf_event_mmap_header =  dlsym(libnetdata, \"perf_event_mmap_header\");\n            if ((err = dlerror()) != NULL) {\n                error(\"[EBPF_PROCESS] Cannot find perf_event_mmap_header: %s\", err);\n                return -1;\n            }\n\n            netdata_perf_loop_multi = dlsym(libnetdata, \"netdata_perf_loop_multi\");\n            if ((err = dlerror()) != NULL) {\n                error(\"[EBPF_PROCESS] Cannot find netdata_perf_loop_multi: %s\", err);\n                return -1;\n            }\n        }\n    }\n\n    return 0;\n}\n\nchar *select_file() {\n    if(!mode)\n        return \"rnetdata_ebpf_process.o\";\n    if(mode == 1)\n        return \"dnetdata_ebpf_process.o\";\n\n    return \"pnetdata_ebpf_process.o\";\n}\n\nint process_load_ebpf()\n{\n    char lpath[4096];\n\n    char *name = select_file();\n\n    build_complete_path(lpath, 4096, plugin_dir,  name);\n    event_pid = getpid();\n    if (load_bpf_file(lpath, event_pid) ) {\n        error(\"[EBPF_PROCESS] Cannot load program: %s\", lpath);\n        return -1;\n    } else {\n        info(\"[EBPF PROCESS]: The eBPF program %s was loaded with success.\", name);\n    }\n\n    return 0;\n}\n\nvoid set_global_variables() {\n    //Get environment variables\n    plugin_dir = getenv(\"NETDATA_PLUGINS_DIR\");\n    if(!plugin_dir)\n        plugin_dir = PLUGINS_DIR;\n\n    user_config_dir = getenv(\"NETDATA_USER_CONFIG_DIR\");\n    if(!user_config_dir)\n        user_config_dir = CONFIG_DIR;\n\n    stock_config_dir = getenv(\"NETDATA_STOCK_CONFIG_DIR\");\n    if(!stock_config_dir)\n        stock_config_dir = LIBCONFIG_DIR;\n\n    netdata_configured_log_dir = getenv(\"NETDATA_LOG_DIR\");\n    if(!netdata_configured_log_dir)\n        netdata_configured_log_dir = LOG_DIR;\n\n    page_cnt *= (int)sysconf(_SC_NPROCESSORS_ONLN);\n\n    nprocs = (int)sysconf(_SC_NPROCESSORS_ONLN);\n    if (nprocs > NETDATA_MAX_PROCESSOR) {\n        nprocs = NETDATA_MAX_PROCESSOR;\n    }\n\n    isrh = get_redhat_release();\n}\n\nstatic void change_collector_event() {\n    int i;\n    if (mykernel < NETDATA_KERNEL_V5_3)\n        collector_events[10].name = NULL;\n\n    for (i = 0; collector_events[i].name ; i++ ) {\n        collector_events[i].type = 'p';\n    }\n}\n\nstatic void change_syscalls() {\n    static char *lfork = { \"do_fork\" };\n    id_names[7] = lfork;\n    collector_events[8].name = lfork;\n}\n\nstatic inline void what_to_load(char *ptr) {\n    if (!strcasecmp(ptr, \"return\"))\n        mode = 0;\n    /*\n    else if (!strcasecmp(ptr, \"dev\"))\n        mode = 1;\n        */\n    else\n        change_collector_event();\n\n    if (isrh >= NETDATA_MINIMUM_RH_VERSION && isrh < NETDATA_RH_8)\n        change_syscalls();\n}\n\nstatic inline void enable_debug(char *ptr) {\n    if (!strcasecmp(ptr, \"yes\"))\n        debug_log = 1;\n}\n\nstatic inline void set_log_file(char *ptr) {\n    if (!strcasecmp(ptr, \"yes\"))\n        use_stdout = 1;\n}\n\nstatic void set_global_values() {\n    struct section *sec = collector_config.first_section;\n    while(sec) {\n        if(!strcasecmp(sec->name, \"global\")) {\n            struct config_option *values = sec->values;\n            while(values) {\n                if(!strcasecmp(values->name, \"load\"))\n                    what_to_load(values->value);\n                else if(!strcasecmp(values->name, \"debug log\"))\n                    enable_debug(values->value);\n                else if(!strcasecmp(values->name, \"use stdout\"))\n                    set_log_file(values->value);\n\n                values = values->next;\n            }\n        }\n        sec = sec->next;\n    }\n}\n\nstatic int load_collector_file(char *path) {\n    char lpath[4096];\n\n    build_complete_path(lpath, 4096, path, \"ebpf_process.conf\" );\n\n    if (!appconfig_load(&collector_config, lpath, 0, NULL))\n        return 1;\n\n    set_global_values();\n\n    return 0;\n}\n\nint main(int argc, char **argv)\n{\n    (void)argc;\n    (void)argv;\n\n    mykernel =  get_kernel_version();\n    if(!has_condition_to_run(mykernel)) {\n        error(\"[EBPF PROCESS] The current collector cannot run on this kernel.\");\n        return 1;\n    }\n\n    //set name\n    program_name = \"ebpf_process.plugin\";\n\n    //disable syslog\n    error_log_syslog = 0;\n\n    // set errors flood protection to 100 logs per hour\n    error_log_errors_per_period = 100;\n    error_log_throttle_period = 3600;\n\n    if (argc > 1) {\n        update_every = (int)strtol(argv[1], NULL, 10);\n    }\n\n    struct rlimit r = {RLIM_INFINITY, RLIM_INFINITY};\n    if (setrlimit(RLIMIT_MEMLOCK, &r)) {\n        error(\"[EBPF PROCESS] setrlimit(RLIMIT_MEMLOCK)\");\n        return 2;\n    }\n\n    set_global_variables();\n\n    if (load_collector_file(user_config_dir)) {\n        info(\"[EBPF PROCESS] does not have a configuration file. It is starting with default options.\");\n        change_collector_event();\n        if (isrh >= NETDATA_MINIMUM_RH_VERSION && isrh < NETDATA_RH_8)\n            change_syscalls();\n    }\n\n    if(ebpf_load_libraries()) {\n        error(\"[EBPF_PROCESS] Cannot load library.\");\n        thread_finished++;\n        int_exit(3);\n    }\n\n    signal(SIGINT, int_exit);\n    signal(SIGTERM, int_exit);\n\n    if (process_load_ebpf()) {\n        thread_finished++;\n        int_exit(4);\n    }\n\n    if(allocate_global_vectors()) {\n        thread_finished++;\n        error(\"[EBPF_PROCESS] Cannot allocate necessary vectors.\");\n        int_exit(5);\n    }\n\n    if(mode == 1 && debug_log) {\n        if(map_memory()) {\n            thread_finished++;\n            error(\"[EBPF_PROCESS] Cannot map memory used with perf events.\");\n            int_exit(6);\n        }\n    }\n\n    set_global_labels();\n\n    if(debug_log) {\n        open_developer_log();\n    }\n\n    if (pthread_mutex_init(&lock, NULL)) {\n        thread_finished++;\n        error(\"[EBPF PROCESS] Cannot start the mutex.\");\n        int_exit(7);\n    }\n\n    pthread_attr_t attr;\n    pthread_attr_init(&attr);\n    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);\n    pthread_t thread[NETDATA_EBPF_PROCESS_THREADS];\n\n    int i;\n    int end = NETDATA_EBPF_PROCESS_THREADS;\n\n    void * (*function_pointer[])(void *) = {process_publisher, process_collector, process_log };\n\n    for ( i = 0; i < end ; i++ ) {\n        if ( ( pthread_create(&thread[i], &attr, function_pointer[i], NULL) ) ) {\n            error(\"[EBPF_PROCESS] Cannot create threads.\");\n            thread_finished++;\n            int_exit(8);\n        }\n    }\n\n    for ( i = 0; i < end ; i++ ) {\n        if ( (pthread_join(thread[i], NULL) ) ) {\n            error(\"[EBPF_PROCESS] Cannot join threads.\");\n            thread_finished++;\n            int_exit(9);\n        }\n    }\n\n    thread_finished++;\n    int_exit(0);\n\n    return 0;\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/favicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/apple-icon-57x57.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/alert-128-red.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/alert-multi-size-red.ico",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/android-icon-72x72.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/ms-icon-310x150.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/favicon-128.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/check-mark-2-128-green.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/apple-icon.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/post.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/android-icon-144x144.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/apple-icon-72x72.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/ms-icon-310x310.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/android-icon-96x96.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/favicon-32x32.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/seo-performance-128.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/apple-icon-120x120.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/alert-128-orange.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/favicon-16x16.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/android-icon-36x36.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/apple-icon-180x180.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/banner-icon-144x144.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/android-icon-192x192.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/favicon-196x196.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/apple-icon-precomposed.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/apple-icon-60x60.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/favicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/ms-icon-150x150.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/apple-icon-114x114.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/apple-icon-144x144.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/apple-icon-152x152.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/ms-icon-70x70.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/ms-icon-36x36.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/android-icon-48x48.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/ms-icon-144x144.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/animated.gif",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/apple-icon-76x76.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/check-mark-2-multi-size-green.ico",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/favicon-96x96.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/alert-multi-size-orange.ico",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/fonts/glyphicons-halflings-regular.woff",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/fonts/glyphicons-halflings-regular.eot",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/fonts/glyphicons-halflings-regular.woff2",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/fonts/glyphicons-halflings-regular.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/.travis/gcs-credentials.json.enc",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/docs/generator/custom/img/geography-16.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/docs/generator/custom/img/netdata_docs.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/docs/generator/custom/img/favicon.ico"
    ],
    "total_files": 1590
}