{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/src/mpl/src/gpu/mpl_gpu_cuda.c": "/*\n *  Copyright (C) by Argonne National Laboratory.\n *      See COPYRIGHT in top-level directory.\n */\n\n#include <dlfcn.h>\n#include \"mpl.h\"\n#include <assert.h>\n\n#define CUDA_ERR_CHECK(ret) if (unlikely((ret) != cudaSuccess)) goto fn_fail\n#define CU_ERR_CHECK(ret) if (unlikely((ret) != CUDA_SUCCESS)) goto fn_fail\n\ntypedef struct gpu_free_hook {\n    void (*free_hook) (void *dptr);\n    struct gpu_free_hook *next;\n} gpu_free_hook_s;\n\nstatic gpu_free_hook_s *free_hook_chain = NULL;\n\nstatic CUresult CUDAAPI(*sys_cuMemFree) (CUdeviceptr dptr);\nstatic cudaError_t CUDARTAPI(*sys_cudaFree) (void *dptr);\n\nstatic int gpu_mem_hook_init();\n\nint MPL_gpu_query_pointer_attr(const void *ptr, MPL_pointer_attr_t * attr)\n{\n    cudaError_t ret;\n    struct cudaPointerAttributes ptr_attr;\n    ret = cudaPointerGetAttributes(&ptr_attr, ptr);\n    if (ret == cudaSuccess) {\n        switch (ptr_attr.type) {\n            case cudaMemoryTypeUnregistered:\n                attr->type = MPL_GPU_POINTER_UNREGISTERED_HOST;\n                attr->device = ptr_attr.device;\n                break;\n            case cudaMemoryTypeHost:\n                attr->type = MPL_GPU_POINTER_REGISTERED_HOST;\n                attr->device = ptr_attr.device;\n                break;\n            case cudaMemoryTypeDevice:\n                attr->type = MPL_GPU_POINTER_DEV;\n                attr->device = ptr_attr.device;\n                break;\n            case cudaMemoryTypeManaged:\n                attr->type = MPL_GPU_POINTER_MANAGED;\n                attr->device = ptr_attr.device;\n                break;\n        }\n    } else if (ret == cudaErrorInvalidValue) {\n        attr->type = MPL_GPU_POINTER_UNREGISTERED_HOST;\n        attr->device = -1;\n    } else {\n        goto fn_fail;\n    }\n\n  fn_exit:\n    return MPL_SUCCESS;\n  fn_fail:\n    return MPL_ERR_GPU_INTERNAL;\n}\n\nint MPL_gpu_ipc_handle_create(const void *ptr, MPL_gpu_ipc_mem_handle_t * ipc_handle)\n{\n    cudaError_t ret;\n\n    ret = cudaIpcGetMemHandle(ipc_handle, (void *) ptr);\n    CUDA_ERR_CHECK(ret);\n\n  fn_exit:\n    return MPL_SUCCESS;\n  fn_fail:\n    return MPL_ERR_GPU_INTERNAL;\n}\n\nint MPL_gpu_ipc_handle_map(MPL_gpu_ipc_mem_handle_t ipc_handle, MPL_gpu_device_handle_t dev_handle,\n                           void **ptr)\n{\n    cudaError_t ret;\n    int prev_devid;\n\n    cudaGetDevice(&prev_devid);\n    cudaSetDevice(dev_handle);\n    ret = cudaIpcOpenMemHandle(ptr, ipc_handle, cudaIpcMemLazyEnablePeerAccess);\n    CUDA_ERR_CHECK(ret);\n\n  fn_exit:\n    cudaSetDevice(prev_devid);\n    return MPL_SUCCESS;\n  fn_fail:\n    return MPL_ERR_GPU_INTERNAL;\n}\n\nint MPL_gpu_ipc_handle_unmap(void *ptr)\n{\n    cudaError_t ret;\n    ret = cudaIpcCloseMemHandle(ptr);\n    CUDA_ERR_CHECK(ret);\n\n  fn_exit:\n    return MPL_SUCCESS;\n  fn_fail:\n    return MPL_ERR_GPU_INTERNAL;\n}\n\nint MPL_gpu_malloc_host(void **ptr, size_t size)\n{\n    cudaError_t ret;\n    ret = cudaMallocHost(ptr, size);\n    CUDA_ERR_CHECK(ret);\n\n  fn_exit:\n    return MPL_SUCCESS;\n  fn_fail:\n    return MPL_ERR_GPU_INTERNAL;\n}\n\nint MPL_gpu_free_host(void *ptr)\n{\n    cudaError_t ret;\n    ret = cudaFreeHost(ptr);\n    CUDA_ERR_CHECK(ret);\n\n  fn_exit:\n    return MPL_SUCCESS;\n  fn_fail:\n    return MPL_ERR_GPU_INTERNAL;\n}\n\nint MPL_gpu_register_host(const void *ptr, size_t size)\n{\n    cudaError_t ret;\n    ret = cudaHostRegister((void *) ptr, size, cudaHostRegisterDefault);\n    CUDA_ERR_CHECK(ret);\n\n  fn_exit:\n    return MPL_SUCCESS;\n  fn_fail:\n    return MPL_ERR_GPU_INTERNAL;\n}\n\nint MPL_gpu_unregister_host(const void *ptr)\n{\n    cudaError_t ret;\n    ret = cudaHostUnregister((void *) ptr);\n    CUDA_ERR_CHECK(ret);\n\n  fn_exit:\n    return MPL_SUCCESS;\n  fn_fail:\n    return MPL_ERR_GPU_INTERNAL;\n}\n\nint MPL_gpu_malloc(void **ptr, size_t size, MPL_gpu_device_handle_t h_device)\n{\n    int mpl_errno = MPL_SUCCESS;\n    int prev_devid;\n    cudaError_t ret;\n    cudaGetDevice(&prev_devid);\n    cudaSetDevice(h_device);\n    ret = cudaMalloc(ptr, size);\n    CUDA_ERR_CHECK(ret);\n\n  fn_exit:\n    cudaSetDevice(prev_devid);\n    return mpl_errno;\n  fn_fail:\n    mpl_errno = MPL_ERR_GPU_INTERNAL;\n    goto fn_exit;\n}\n\nint MPL_gpu_free(void *ptr)\n{\n    cudaError_t ret;\n    ret = cudaFree(ptr);\n    CUDA_ERR_CHECK(ret);\n\n  fn_exit:\n    return MPL_SUCCESS;\n  fn_fail:\n    return MPL_ERR_GPU_INTERNAL;\n}\n\nint MPL_gpu_init(int *device_count, int *max_dev_id_ptr)\n{\n    int count, max_dev_id = -1;\n    cudaError_t ret = cudaGetDeviceCount(&count);\n    CUDA_ERR_CHECK(ret);\n\n    char *visible_devices = getenv(\"CUDA_VISIBLE_DEVICES\");\n    if (visible_devices) {\n        uintptr_t len = strlen(visible_devices);\n        char *devices = MPL_malloc(len + 1, MPL_MEM_OTHER);\n        char *free_ptr = devices;\n        memcpy(devices, visible_devices, len + 1);\n        for (int i = 0; i < count; i++) {\n            int global_dev_id;\n            char *tmp = strtok(devices, \",\");\n            assert(tmp);\n            global_dev_id = atoi(tmp);\n            if (global_dev_id > max_dev_id)\n                max_dev_id = global_dev_id;\n            devices = NULL;\n        }\n        MPL_free(free_ptr);\n    } else {\n        max_dev_id = count - 1;\n    }\n\n    *max_dev_id_ptr = max_dev_id;\n    *device_count = count;\n\n    gpu_mem_hook_init();\n\n  fn_exit:\n    return MPL_SUCCESS;\n  fn_fail:\n    return MPL_ERR_GPU_INTERNAL;\n}\n\nint MPL_gpu_finalize()\n{\n    gpu_free_hook_s *prev;\n    while (free_hook_chain) {\n        prev = free_hook_chain;\n        free_hook_chain = free_hook_chain->next;\n        MPL_free(prev);\n    }\n    return MPL_SUCCESS;\n}\n\nint MPL_gpu_get_dev_id(MPL_gpu_device_handle_t dev_handle, int *dev_id)\n{\n    *dev_id = dev_handle;\n    return MPL_SUCCESS;\n}\n\nint MPL_gpu_get_dev_handle(int dev_id, MPL_gpu_device_handle_t * dev_handle)\n{\n    *dev_handle = dev_id;\n    return MPL_SUCCESS;\n}\n\nint MPL_gpu_get_global_dev_ids(int *global_ids, int count)\n{\n    char *visible_devices = getenv(\"CUDA_VISIBLE_DEVICES\");\n\n    if (visible_devices) {\n        uintptr_t len = strlen(visible_devices);\n        char *devices = MPL_malloc(len + 1, MPL_MEM_OTHER);\n        char *free_ptr = devices;\n        memcpy(devices, visible_devices, len + 1);\n        for (int i = 0; i < count; i++) {\n            char *tmp = strtok(devices, \",\");\n            assert(tmp);\n            global_ids[i] = atoi(tmp);\n            devices = NULL;\n        }\n        MPL_free(free_ptr);\n    } else {\n        for (int i = 0; i < count; i++) {\n            global_ids[i] = i;\n        }\n    }\n\n  fn_exit:\n    return MPL_SUCCESS;\n  fn_fail:\n    return MPL_ERR_GPU_INTERNAL;\n}\n\nint MPL_gpu_get_buffer_bounds(const void *ptr, void **pbase, uintptr_t * len)\n{\n    CUresult curet;\n\n    curet = cuMemGetAddressRange((CUdeviceptr *) pbase, (size_t *) len, (CUdeviceptr) ptr);\n    CU_ERR_CHECK(curet);\n\n  fn_exit:\n    return MPL_SUCCESS;\n  fn_fail:\n    return MPL_ERR_GPU_INTERNAL;\n}\n\nstatic void gpu_free_hooks_cb(void *dptr)\n{\n    gpu_free_hook_s *current = free_hook_chain;\n    if (dptr != NULL) {\n        /* we call gpu hook only when dptr != NULL */\n        while (current) {\n            current->free_hook(dptr);\n            current = current->next;\n        }\n    }\n    return;\n}\n\nstatic int gpu_mem_hook_init()\n{\n    void *libcuda_handle;\n    void *libcudart_handle;\n\n    libcuda_handle = dlopen(\"libcuda.so\", RTLD_LAZY | RTLD_GLOBAL);\n    assert(libcuda_handle);\n    libcudart_handle = dlopen(\"libcudart.so\", RTLD_LAZY | RTLD_GLOBAL);\n    assert(libcudart_handle);\n\n    sys_cuMemFree = (void *) dlsym(libcuda_handle, \"cuMemFree\");\n    assert(sys_cuMemFree);\n    sys_cudaFree = (void *) dlsym(libcudart_handle, \"cudaFree\");\n    assert(sys_cudaFree);\n    return MPL_SUCCESS;\n}\n\nint MPL_gpu_free_hook_register(void (*free_hook) (void *dptr))\n{\n    gpu_free_hook_s *hook_obj = MPL_malloc(sizeof(gpu_free_hook_s), MPL_MEM_OTHER);\n    assert(hook_obj);\n    hook_obj->free_hook = free_hook;\n    hook_obj->next = NULL;\n    if (!free_hook_chain)\n        free_hook_chain = hook_obj;\n    else {\n        hook_obj->next = free_hook_chain;\n        free_hook_chain = hook_obj;\n    }\n\n    return MPL_SUCCESS;\n}\n\nCUresult CUDAAPI cuMemFree(CUdeviceptr dptr)\n{\n    CUresult result;\n    gpu_free_hooks_cb((void *) dptr);\n    result = sys_cuMemFree(dptr);\n    return (result);\n}\n\ncudaError_t CUDARTAPI cudaFree(void *dptr)\n{\n    cudaError_t result;\n    gpu_free_hooks_cb(dptr);\n    result = sys_cudaFree(dptr);\n    return result;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/libfabric/configure.ac": "dnl\ndnl Copyright (c) 2016 Cisco Systems, Inc.  All rights reserved.\ndnl Copyright (c) 2019 Intel, Inc.  All rights reserved.\ndnl Copyright (c) 2019-2020 Amazon.com, Inc. or its affiliates. All rights reserved.\ndnl\ndnl Process this file with autoconf to produce a configure script.\n\nAC_PREREQ([2.60])\nAC_INIT([libfabric], [1.10.1], [ofiwg@lists.openfabrics.org])\nAC_CONFIG_SRCDIR([src/fabric.c])\nAC_CONFIG_AUX_DIR(config)\nAC_CONFIG_MACRO_DIR(config)\nAC_CONFIG_HEADERS(config.h)\nAM_INIT_AUTOMAKE([1.11 dist-bzip2 foreign -Wall -Werror subdir-objects parallel-tests tar-pax])\nm4_ifdef([AM_SILENT_RULES], [AM_SILENT_RULES([yes])])\nm4_include(config/fi_check_package.m4)\n\nAC_CANONICAL_HOST\n\nmacos=0\nlinux=0\nfreebsd=0\n\ncase $host_os in\n*darwin*)\n\tmacos=1\n\t;;\n*linux*)\n\tlinux=1\n\t;;\n*freebsd*)\n\tfreebsd=1\n\t;;\n*)\n\tAC_MSG_ERROR([libfabric only builds on Linux, OS X, and FreeBSD])\n\t;;\nesac\n\nAM_CONDITIONAL([MACOS], [test \"x$macos\" = \"x1\"])\nAM_CONDITIONAL([LINUX], [test \"x$linux\" = \"x1\"])\nAM_CONDITIONAL([FREEBSD], [test \"x$freebsd\" = \"x1\"])\n\nbase_c_warn_flags=\"-Wall -Wundef -Wpointer-arith\"\ndebug_c_warn_flags=\"-Wextra -Wno-unused-parameter -Wno-sign-compare -Wno-missing-field-initializers\"\ndebug_c_other_flags=\"-fstack-protector-strong\"\npicky_c_warn_flags=\"-Wno-long-long -Wmissing-prototypes -Wstrict-prototypes -Wcomment -pedantic\"\n\nAC_ARG_WITH([build_id],\n\t    [AC_HELP_STRING([--with-build_id],\n\t\t\t    [Enable build_id annotation @<:@default=no@:>@])],\n\t    [], [with_build_id=no])\nAS_IF([test x\"$with_build_id\" = x\"no\"], [with_build_id=\"\"])\nAC_DEFINE_UNQUOTED([BUILD_ID],[\"$with_build_id\"],\n                   [adds build_id to version if it was defined])\n\n# Override autoconf default CFLAG settings (e.g. \"-g -O2\") while still\n# allowing the user to explicitly set CFLAGS=\"\"\n: ${CFLAGS=\"-fvisibility=hidden ${base_c_warn_flags}\"}\n\n# AM_PROG_AS would set CFLAGS=\"-g -O2\" by default if not set already so it\n# should not be called earlier\nAM_PROG_AS()\n\n# AM PROG_AR did not exist pre AM 1.11.x (where x is somewhere >0 and\n# <3), but it is necessary in AM 1.12.x.\nm4_ifdef([AM_PROG_AR], [AM_PROG_AR])\n\nAC_ARG_WITH([valgrind],\n    AC_HELP_STRING([--with-valgrind],\n\t\t   [Enable valgrind annotations @<:@default=no@:>@]))\n\nif test \"$with_valgrind\" != \"\" && test \"$with_valgrind\" != \"no\"; then\n\tAC_DEFINE([INCLUDE_VALGRIND], 1,\n\t\t  [Define to 1 to enable valgrind annotations])\n\tif test -d $with_valgrind; then\n\t\tCPPFLAGS=\"$CPPFLAGS -I$with_valgrind/include\"\n\tfi\nfi\n\nAC_ARG_ENABLE([direct],\n\t[AS_HELP_STRING([--enable-direct=@<:@provider@:>@],\n\t\t[Enable direct calls to a fabric provider @<:@default=no@:>@])\n\t],\n\t[],\n\t[enable_direct=no])\n\n\nAC_ARG_ENABLE([atomics],\n\t[AS_HELP_STRING([--enable-atomics],\n\t\t[Enable atomics support @<:@default=yes@:>@])\n\t],\n\t[],\n\t[enable_atomics=yes])\n\ndnl Checks for programs\nAC_PROG_CC_C99\nAS_IF([test \"$ac_cv_prog_cc_c99\" = \"no\"],\n      [AC_MSG_WARN([Libfabric requires a C99-compliant compiler])\n       AC_MSG_ERROR([Cannot continue])])\nAM_PROG_CC_C_O\nAC_PROG_CPP\n\nAC_ARG_ENABLE([debug],\n\t      [AS_HELP_STRING([--enable-debug],\n\t\t\t      [Enable debugging @<:@default=no@:>@])\n\t      ],\n\t      [],\n\t      [enable_debug=no])\n\nAS_IF([test x\"$enable_debug\" != x\"no\"],\n      [dbg=1\n       # See if all the flags in $debug_c_other_flags work\n       good_flags=\n       CFLAGS_save=\"$CFLAGS\"\n       for flag in $debug_c_other_flags; do\n           AC_MSG_CHECKING([to see if compiler supports $flag])\n           CFLAGS=\"$flag $CFLAGS_save\"\n           AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[]], [[int i = 3;]])],\n\t                     [AC_MSG_RESULT([yes])\n\t\t\t      good_flags=\"$flag $good_flags\"],\n\t\t\t     [AC_MSG_RESULT([no])])\n       done\n       debug_c_other_flags=$good_flags\n       unset good_flags\n\n       CFLAGS=\"-g -O0 ${base_c_warn_flags} ${debug_c_warn_flags} ${debug_c_other_flags} ${CFLAGS_save}\"\n       unset CFLAGS_save],\n      [dbg=0\n       CFLAGS=\"-O2 -DNDEBUG $CFLAGS\"])\n\nAC_DEFINE_UNQUOTED([ENABLE_DEBUG],[$dbg],\n                   [defined to 1 if libfabric was configured with --enable-debug, 0 otherwise])\n\ndnl Checks for header files.\nAC_HEADER_STDC\n\ndnl Check for compiler features\nAC_C_TYPEOF\n\nLT_INIT\nLT_OUTPUT\n\ndnl dlopen support is optional\nAC_ARG_WITH([dlopen],\n\tAC_HELP_STRING([--with-dlopen],\n\t\t       [dl-loadable provider support @<:@default=yes@:>@]),\n\t)\n\nif test \"$freebsd\" == \"0\"; then\nAS_IF([test x\"$with_dlopen\" != x\"no\"], [\nAC_CHECK_LIB(dl, dlopen, [],\n    AC_MSG_ERROR([dlopen not found.  libfabric requires libdl.]))\n])\nfi\n\ndnl handle picky option\nAC_ARG_ENABLE([picky],\n    [AC_HELP_STRING([--enable-picky],\n                    [Enable developer-level compiler pickyness when building @<:@default=no@:>@])])\nAS_IF([test x\"$enable_picky\" = x\"yes\" && test x\"$GCC\" = x\"yes\"],\n      [AS_IF([test x\"$enable_debug\" = x\"no\"],\n             [CFLAGS=\"${base_c_warn_flags} ${debug_c_warn_flags}\n\t\t      ${debug_c_other_flags} ${picky_c_warn_flags} $CFLAGS\"],\n             [CFLAGS=\"${picky_c_warn_flags} $CFLAGS\"])\n      ])\n\ndnl Checks for libraries\nAC_CHECK_LIB(pthread, pthread_mutex_init, [],\n    AC_MSG_ERROR([pthread_mutex_init() not found.  libfabric requires libpthread.]))\n\nAC_CHECK_FUNC([pthread_spin_init],\n\t[have_spinlock=1],\n\t[have_spinlock=0])\n\ndnl shm_open not used in the common code on os-x\n\nif test \"$macos\" -eq 0; then\nAC_CHECK_FUNC([shm_open],\n\t[],\n\t[AC_SEARCH_LIBS([shm_open],[rt],[],\n\t [AC_MSG_ERROR([shm_open() not found.  libfabric requires shm_open.])])])\nfi\n\nAC_DEFINE_UNQUOTED([PT_LOCK_SPIN], [$have_spinlock],\n\t[Define to 1 if pthread_spin_init is available.])\n\nAC_ARG_ENABLE([epoll],\n    [AS_HELP_STRING([--disable-epoll],\n        [Disable epoll if available@<:@default=no@:>@])],\n    [],\n    [enable_epoll=auto]\n)\n\nAS_IF([test x\"$enable_epoll\" != x\"no\"],\n    [AC_CHECK_FUNCS([epoll_create])\n     if test \"$ac_cv_func_epoll_create\" = yes; then\n        AC_DEFINE([HAVE_EPOLL], [1], [Define if you have epoll support.])\n     fi]\n)\n\nAC_CHECK_HEADER([linux/perf_event.h],\n    [AC_CHECK_DECL([__builtin_ia32_rdpmc],\n        [\n            AC_TRY_LINK([#include <linux/perf_event.h>],\n                [__builtin_ia32_rdpmc(0);],\n                [linux_perf_rdpmc=1],\n                [linux_perf_rdpmc=0])\n\t],\n        [linux_perf_rdpmc=0],\n        [#include <linux/perf_event.h>])],\n    [linux_perf_rdpmc=0])\nAC_DEFINE_UNQUOTED(HAVE_LINUX_PERF_RDPMC, [$linux_perf_rdpmc],\n    [Whether we have __builtin_ia32_rdpmc() and linux/perf_event.h file or not])\nAM_CONDITIONAL([HAVE_LINUX_PERF_RDPMC], [test \"x$linux_perf_rdpmc\" = \"x1\"])\n\ndnl Check for gcc atomic intrinsics\nAS_IF([test x\"$enable_atomics\" != x\"no\"],\n    AC_MSG_CHECKING(compiler support for c11 atomics)\n    AC_TRY_LINK([#include <stdatomic.h>],\n        [atomic_int a;\n         atomic_init(&a, 0);\n         #ifdef __STDC_NO_ATOMICS__\n           #error c11 atomics are not supported\n         #else\n           return 0;\n         #endif\n        ],\n        [\n        AC_MSG_RESULT(yes)\n            AC_DEFINE(HAVE_ATOMICS, 1, [Set to 1 to use c11 atomic functions])\n        ],\n        [AC_MSG_RESULT(no)])\n\n\n    AC_MSG_CHECKING(compiler support for c11 atomic `least` types)\n    AC_TRY_LINK([#include <stdatomic.h>],\n        [atomic_int_least32_t a;\n         atomic_int_least64_t b;\n        ],\n        [\n            AC_MSG_RESULT(yes)\n            AC_DEFINE(HAVE_ATOMICS_LEAST_TYPES, 1,\n                      [Set to 1 to use c11 atomic `least` types])\n        ],\n        [\n            AC_MSG_RESULT(no)\n        ]),\n[\n    AC_MSG_RESULT(configure: atomics support for c11 is disabled)\n])\n\ndnl Check for gcc built-in atomics\nAS_IF([test x\"$enable_atomics\" != x\"no\"],\n    AC_MSG_CHECKING(compiler support for built-in atomics)\n    AC_TRY_LINK([#include <stdint.h>],\n        [int32_t a;\n         __sync_add_and_fetch(&a, 0);\n         __sync_sub_and_fetch(&a, 0);\n         #if defined(__PPC__) && !defined(__PPC64__)\n           #error compiler built-in atomics are not supported on PowerPC 32-bit\n         #else\n           return 0;\n         #endif\n        ],\n        [\n        AC_MSG_RESULT(yes)\n            AC_DEFINE(HAVE_BUILTIN_ATOMICS, 1, [Set to 1 to use built-in intrincics atomics])\n        ],\n        [AC_MSG_RESULT(no)]),\n[\n    AC_MSG_RESULT(configure: atomics support built-in is disabled)\n])\n\ndnl Check for gcc memory model aware built-in atomics\ndnl If supported check to see if not internal to compiler\nLIBS_save=$LIBS\nAC_SEARCH_LIBS([__atomic_load_8], [atomic])\nAS_IF([test x\"$enable_atomics\" != x\"no\"],\n    AC_MSG_CHECKING(compiler support for built-in memory model aware atomics)\n    AC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <stdint.h>]],\n        [[uint64_t d;\n         uint64_t s;\n         uint64_t c;\n         uint64_t r;\n          r = __atomic_fetch_add(&d, s, __ATOMIC_SEQ_CST);\n          r = __atomic_load_8(&d, __ATOMIC_SEQ_CST);\n          __atomic_exchange(&d, &s, &r, __ATOMIC_SEQ_CST);\n          __atomic_compare_exchange(&d,&c,&s,0, __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST);\n         #if defined(__PPC__) && !defined(__PPC64__)\n           #error compiler built-in memory model aware atomics are not supported on PowerPC 32-bit\n         #else\n           return 0;\n         #endif\n        ]])],\n        [\n            AC_MSG_RESULT(yes)\n            AC_DEFINE(HAVE_BUILTIN_MM_ATOMICS, 1, [Set to 1 to use built-in intrinsics memory model aware atomics])\n        ],\n        [\n            AC_MSG_RESULT(no)\n            LIBS=$LIBS_save\n        ]),\n[\n    AC_MSG_RESULT(configure: -latomic key is disabled)\n    LIBS=$LIBS_save\n])\nunset LIBS_save\n\ndnl Check for gcc cpuid intrinsics\nAC_MSG_CHECKING(compiler support for cpuid)\nAC_TRY_LINK([\n     #include <stddef.h>\n     #include <cpuid.h>],\n    [\n     int a, b, c, d;\n     __cpuid_count(0, 0, a, b, c, d);\n    ],\n    [\n\tAC_MSG_RESULT(yes)\n        AC_DEFINE(HAVE_CPUID, 1, [Set to 1 to use cpuid])\n    ],\n    [AC_MSG_RESULT(no)])\n\nif test \"$with_valgrind\" != \"\" && test \"$with_valgrind\" != \"no\"; then\nAC_CHECK_HEADER(valgrind/memcheck.h, [],\n    AC_MSG_ERROR([valgrind requested but <valgrind/memcheck.h> not found.]))\nfi\n\nAC_CACHE_CHECK(whether ld accepts --version-script, ac_cv_version_script,\n    [if test -n \"`$LD --help < /dev/null 2>/dev/null | grep version-script`\"; then\n        ac_cv_version_script=yes\n    else\n        ac_cv_version_script=no\n    fi])\n\nAC_ARG_ENABLE([embedded],\n\t      [AS_HELP_STRING([--enable-embedded],\n\t\t\t      [Enable embedded support (turns off symbol versioning) @<:@default=no@:>@])\n\t      ],\n\t      [ac_asm_symver_support=0\n               icc_symver_hack=1],\n\t      [enable_embedded=no])\nAM_CONDITIONAL([EMBEDDED], [test x\"$enable_embedded\" = x\"yes\"])\n\nAM_CONDITIONAL(HAVE_LD_VERSION_SCRIPT, test \"$ac_cv_version_script\" = \"yes\")\n\ndnl Disable symbol versioning when -ipo is in CFLAGS or ipo is disabled by icc.\ndnl The gcc equivalent ipo (-fwhole-program) seems to work fine.\nAS_CASE([$CFLAGS],\n\t[*-ipo*],[\n\t\tAC_MSG_NOTICE([disabling symbol versioning support with -ipo CFLAG])\n\t\ticc_symver_hack=1\n\t\tac_asm_symver_support=0\n\t],\n\t[]\n)\n\ndnl Check for symbol versioning compiler + linker support.\ndnl If icc + ipo, then print disabled and skip check\nAC_MSG_CHECKING(for .symver assembler support)\nAS_IF([test \"$icc_symver_hack\"],\n\t[AC_MSG_RESULT(disabled)],\n[\n\nAC_TRY_LINK([],\n\t[__asm__(\".symver main_, main@ABIVER_1.0\");],\n\t[\n\t\tAC_MSG_RESULT(yes)\n\t\tac_asm_symver_support=1\n\t],\n\t[\n\t\tAC_MSG_RESULT(no)\n\t\tac_asm_symver_support=0\n\t])\n\n]) dnl AS_IF icc_symver_hack\n\nAC_DEFINE_UNQUOTED([HAVE_SYMVER_SUPPORT], [$ac_asm_symver_support],\n\t  \t   [Define to 1 if compiler/linker support symbol versioning.])\n\nAC_MSG_CHECKING(for __alias__ attribute support)\nAC_TRY_LINK(\n\t[\n\t\tint foo(int arg);\n\t\tint foo(int arg) { return arg + 3; };\n\t\tint foo2(int arg) __attribute__ (( __alias__(\"foo\")));\n\t],\n\t[ foo2(1); ],\n\t[\n\t\tAC_MSG_RESULT(yes)\n\t\tac_prog_cc_alias_symbols=1\n\t],\n\t[\n\t\tAC_MSG_RESULT(no)\n\t\tac_prog_cc_alias_symbols=0\n\t])\n\nAC_DEFINE_UNQUOTED([HAVE_ALIAS_ATTRIBUTE], [$ac_prog_cc_alias_symbols],\n\t  \t   [Define to 1 if the linker supports alias attribute.])\nAC_CHECK_FUNCS([getifaddrs])\n\ndnl Check for ethtool support\nAC_MSG_CHECKING(ethtool support)\nAC_TRY_LINK([\n    #include <net/if.h>\n    #include <sys/types.h>\n    #include <linux/ethtool.h>\n    #include <linux/sockios.h>\n    #include <sys/ioctl.h>],\n    [\n        unsigned long ioctl_req = SIOCETHTOOL;\n        struct ethtool_cmd cmd = {\n            .cmd = ETHTOOL_GSET,\n        };\n        long speed = cmd.speed;\n    ],\n    [\n\tAC_MSG_RESULT(yes)\n        AC_DEFINE(HAVE_ETHTOOL, 1, [Set to 1 to use ethtool])\n\n    ],\n    [AC_MSG_RESULT(no)])\n\ndnl Check for ethtool SPEED_UNKNOWN macro (suppoirted in the linux\ndnl kernel >= 3.2) and ethtool_cmd_speed function declarations\ndnl supported in the linux kernel >= 2.6.26\nAC_CHECK_DECLS([ethtool_cmd_speed, SPEED_UNKNOWN], [], [],\n               [#include <linux/ethtool.h>])\n\ndnl Check for userfault fd support\nhave_uffd=0\nAC_CHECK_HEADERS([linux/userfaultfd.h],\n\t[AC_CHECK_DECL([__NR_userfaultfd],\n\t\t[have_uffd=1],\n\t\t[],\n\t\t[[#include <sys/syscall.h>]])],\n\t[], [])\n\nAS_IF([test $have_uffd -eq 1],\n\t[AC_MSG_CHECKING([for userfaultfd unmap support])\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n\t\t\t#include <sys/types.h>\n\t\t\t#include <linux/userfaultfd.h>\n\t\t\t#include <unistd.h>\n\t\t\t#include <sys/syscall.h>\n\t\t\t#include <fcntl.h>\n\t\t\t#include <sys/ioctl.h>\n\t\t]],\n\t\t[[\n\t\t\tint fd;\n\t\t\tstruct uffdio_api api_obj;\n\t\t\tapi_obj.api = UFFD_API;\n\t\t\tapi_obj.features = UFFD_FEATURE_EVENT_UNMAP |\n\t\t\t\t\tUFFD_FEATURE_EVENT_REMOVE |\n\t\t\t\t\tUFFD_FEATURE_EVENT_REMAP;\n\t\t\tfd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);\n\t\t\treturn ioctl(fd, UFFDIO_API, &api_obj);\n\t\t]])\n\t],\n\t[AC_MSG_RESULT([yes])],\n\t[AC_MSG_RESULT([no])\n\t\thave_uffd=0])])\n\nAC_DEFINE_UNQUOTED([HAVE_UFFD_UNMAP], [$have_uffd],\n\t[Define to 1 if platform supports userfault fd unmap])\n\ndnl Check support to intercept syscalls\nAC_CHECK_HEADERS_ONCE(elf.h sys/auxv.h)\n\ndnl Check support to clock_gettime\nhave_clock_gettime=0\n\nAC_SEARCH_LIBS([clock_gettime],[rt],\n         [have_clock_gettime=1],\n         [])\n\nAC_DEFINE_UNQUOTED(HAVE_CLOCK_GETTIME, [$have_clock_gettime],\n       [Define to 1 if clock_gettime is available.])\nAM_CONDITIONAL(HAVE_CLOCK_GETTIME, [test $have_clock_gettime -eq 1])\n\ndnl Check for CUDA runtime libraries.\nAC_ARG_WITH([cuda],\n\t    [AC_HELP_STRING([--with-cuda=DIR],\n\t\t\t    [Provide path to where the CUDA development\n\t\t\t    and runtime libraries are installed.])],\n\t    [], [])\n\nFI_CHECK_PACKAGE([cuda],\n\t\t [cuda_runtime.h],\n\t\t [cudart],\n\t\t [cudaMemcpy],\n\t\t [-lcuda],\n\t\t [$with_cuda],\n\t\t [],\n\t\t [AC_DEFINE([HAVE_LIBCUDA], [1],[CUDA support])],\n\t\t [], [])\n\nCPPFLAGS=\"$CPPFLAGS $cuda_CPPFLAGS\"\nLDFLAGS=\"$LDFLAGS $cuda_LDFLAGS\"\nLIBS=\"$LIBS $cuda_LIBS\"\n\ndnl Provider-specific checks\nFI_PROVIDER_INIT\nFI_PROVIDER_SETUP([psm])\nFI_PROVIDER_SETUP([psm2])\nFI_PROVIDER_SETUP([sockets])\nFI_PROVIDER_SETUP([verbs])\nFI_PROVIDER_SETUP([efa])\ndnl The usnic provider must be setup after the verbs provider.  See\ndnl prov/usnic/configure.m4 for details.\nFI_PROVIDER_SETUP([usnic])\nFI_PROVIDER_SETUP([gni])\nFI_PROVIDER_SETUP([udp])\nFI_PROVIDER_SETUP([tcp])\nFI_PROVIDER_SETUP([rxm])\nFI_PROVIDER_SETUP([mrail])\nFI_PROVIDER_SETUP([rxd])\nFI_PROVIDER_SETUP([bgq])\nFI_PROVIDER_SETUP([shm])\nFI_PROVIDER_SETUP([rstream])\nFI_PROVIDER_SETUP([perf])\nFI_PROVIDER_SETUP([hook_debug])\nFI_PROVIDER_FINI\ndnl Configure the .pc file\nFI_PROVIDER_SETUP_PC\n\n# If the user requested to build in direct mode, but\n# we have more than one provider, error.\nPROVIDER_DIRECT=no\nFI_DIRECT_PROVIDER_API_10=/dev/null\nAS_IF([test x\"$enable_direct\" != x\"no\"],\n      [AS_IF([test \"$PROVIDERS_COUNT\" -gt 1],\n\t     [AC_MSG_WARN([Only one provider can be chosen when using --enable-direct])\n\t      AC_MSG_ERROR(Cannot continue)])\n\n       PROVIDER_DIRECT=$enable_direct\n       AC_DEFINE_UNQUOTED([FABRIC_DIRECT_ENABLED], [1], [define when building with FABRIC_DIRECT support])\n       FI_DIRECT_PROVIDER_API_10=\"$srcdir/prov/$enable_direct/provider_FABRIC_1.0.map\"\n       AS_IF([test ! -r \"$FI_DIRECT_PROVIDER_API_10\"],\n\t     [AC_MSG_WARN([--enable-direct=$enable_direct specified, but $FI_DIRECT_PROVIDER_API_10 does not exist])\n\t      AC_MSG_ERROR([Cannot continue])])])\n\nAC_SUBST(PROVIDER_DIRECT)\nAC_SUBST_FILE(FI_DIRECT_PROVIDER_API_10)\nAM_CONDITIONAL([HAVE_DIRECT], [test x\"$enable_direct\" != x\"no\"])\n\nAC_CONFIG_FILES([Makefile libfabric.spec libfabric.map])\nAC_OUTPUT\n\ndnl helpful output\nif test \"$PROVIDERS_TO_BUILD\" = \"\"; then\n\techo \"***\"\n\techo \"*** No providers were configured. This may not be what you wanted.\"\n\techo \"***\"\n\texit 1\nfi\n\nfor i in $PROVIDERS_TO_BUILD; do\n\tv=${i}_dl\n\tif test `eval echo \\\\$${v}` == \"1\"; then\n\t\tdso=\"$i ${dso}\"\n\telse\n\t\tbuiltin=\"$i ${builtin}\"\n\tfi\ndone\ncat <<EOF\n***\n*** Built-in providers:\t${builtin}\n*** DSO providers:\t${dso}\n***\nEOF\n",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/libfabric/src/fabric.c": "/*\n * Copyright (c) 2004, 2005 Topspin Communications.  All rights reserved.\n * Copyright (c) 2006-2016 Cisco Systems, Inc.  All rights reserved.\n * Copyright (c) 2013-2017 Intel Corp., Inc.  All rights reserved.\n *\n * This software is available to you under a choice of one of two\n * licenses.  You may choose to be licensed under the terms of the GNU\n * General Public License (GPL) Version 2, available from the file\n * COPYING in the main directory of this source tree, or the\n * BSD license below:\n *\n *     Redistribution and use in source and binary forms, with or\n *     without modification, are permitted provided that the following\n *     conditions are met:\n *\n *      - Redistributions of source code must retain the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer.\n *\n *      - Redistributions in binary form must reproduce the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer in the documentation and/or other materials\n *        provided with the distribution.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n#include \"config.h\"\n\n#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <dirent.h>\n\n#include <rdma/fi_errno.h>\n#include \"ofi_util.h\"\n#include \"ofi.h\"\n#include \"shared/ofi_str.h\"\n#include \"ofi_prov.h\"\n#include \"ofi_perf.h\"\n\n#ifdef HAVE_LIBDL\n#include <dlfcn.h>\n#endif\n\nstruct ofi_prov {\n\tstruct ofi_prov\t\t*next;\n\tchar\t\t\t*prov_name;\n\tstruct fi_provider\t*provider;\n\tvoid\t\t\t*dlhandle;\n\tbool\t\t\thidden;\n};\n\nstatic struct ofi_prov *prov_head, *prov_tail;\nint ofi_init = 0;\nextern struct ofi_common_locks common_locks;\n\nstatic struct fi_filter prov_filter;\n\nstatic int ofi_find_name(char **names, const char *name)\n{\n\tint i;\n\n\tfor (i = 0; names[i]; i++) {\n\t\tif (!strcasecmp(name, names[i]))\n\t\t\treturn i;\n\t}\n\treturn -1;\n}\n\n/* matches if names[i] == \"xxx;yyy\" and name == \"xxx\" */\nstatic int ofi_find_layered_name(char **names, const char *name)\n{\n\tint i, len;\n\n\tlen = strlen(name);\n\tfor (i = 0; names[i]; i++) {\n\t\tif (!strncasecmp(name, names[i], len) && names[i][len] == ';' )\n\t\t\treturn i;\n\t}\n\treturn -1;\n}\n\n/* matches if names[i] == \"xxx\" and name == \"xxx;yyy\" */\nstatic int ofi_find_core_name(char **names, const char *name)\n{\n\tint i, len;\n\n\tfor (i = 0; names[i]; i++) {\n\t\tlen = strlen(names[i]);\n\t\tif (!strncasecmp(name, names[i], len) && name[len] == ';' )\n\t\t\treturn i;\n\t}\n\treturn -1;\n}\n\nstatic void ofi_closest_prov_names(char *prov_name, char* miss_prov_name, int n)\n{\n\tif (strncasecmp( prov_name, miss_prov_name, n ) == 0 ) {\n\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\"Instead misspelled provider: %s, you may want: %s?\\n\",\n\t\t\tmiss_prov_name, prov_name);\n\t}\n}\n\nstatic void ofi_suggest_prov_names(char *name_to_match)\n{\n\tstruct ofi_prov *prov;\n\tfor (prov = prov_head; prov; prov = prov->next) {\n\t\tif (strlen(prov->prov_name) != strlen(name_to_match)\n\t\t    && !strncasecmp(prov->prov_name, name_to_match,\n\t\t\t\t    strlen(name_to_match))) {\n\t\t\tif (strlen(name_to_match) > 5)\n\t\t\t\tofi_closest_prov_names(prov->prov_name,\n\t\t\t\t\t\t       name_to_match, 5);\n\t\t\telse\n\t\t\t\tofi_closest_prov_names(prov->prov_name,\n\t\t\t\t\t\t       name_to_match, 2);\n\t\t}\n\t}\n}\n\nstatic enum ofi_prov_type ofi_prov_type(const struct fi_provider *provider)\n{\n\tconst struct fi_prov_context *ctx;\n\tctx = (const struct fi_prov_context *) &provider->context;\n\treturn ctx->type;\n}\n\nstatic int ofi_is_util_prov(const struct fi_provider *provider)\n{\n\treturn ofi_prov_type(provider) == OFI_PROV_UTIL;\n}\n\nstatic int ofi_is_core_prov(const struct fi_provider *provider)\n{\n\treturn ofi_prov_type(provider) == OFI_PROV_CORE;\n}\n\nstatic int ofi_is_hook_prov(const struct fi_provider *provider)\n{\n\treturn ofi_prov_type(provider) == OFI_PROV_HOOK;\n}\n\nint ofi_apply_filter(struct fi_filter *filter, const char *name)\n{\n\tif (!filter->names)\n\t\treturn 0;\n\n\tif (ofi_find_name(filter->names, name) >= 0)\n\t\treturn filter->negated ? 1 : 0;\n\n\treturn filter->negated ? 0 : 1;\n}\n\n/*\n * The provider init filter is used to filter out unnecessary core providers\n * at the initialization time. Utility providers are not concerned.\n *\n * Special handling is needed for layered provider names:\n *\n * If the filter is not negated, a name \"xxx;yyy\" in the filter should match\n * input \"xxx\" to ensure that the core provider \"xxx\" is included.\n *\n * If the filter is negated, a name \"xxx;yyy\" in the filter should not match\n * input \"xxx\" otherwise the core provider \"xxx\" may be incorrectly filtered\n * out.\n */\nint ofi_apply_prov_init_filter(struct fi_filter *filter, const char *name)\n{\n\tif (!filter->names)\n\t\treturn 0;\n\n\tif (ofi_find_name(filter->names, name) >= 0)\n\t\treturn filter->negated ? 1 : 0;\n\n\tif (filter->negated)\n\t\treturn 0;\n\n\tif (ofi_find_layered_name(filter->names, name) >= 0)\n\t\treturn 0;\n\n\treturn 1;\n}\n\n/*\n * The provider post filter is used to remove unwanted entries from the fi_info\n * list before returning from fi_getinfo().\n *\n * Layered provider names are handled in the same way as non-layered provider\n * names -- requiring full match.\n *\n * In addition, a name \"xxx\" in the filter should be able to match an input\n * \"xxx;yyy\" to allow extra layering on top of what is requested by the user.\n */\nint ofi_apply_prov_post_filter(struct fi_filter *filter, const char *name)\n{\n\tif (!filter->names)\n\t\treturn 0;\n\n\tif (ofi_find_name(filter->names, name) >= 0 ||\n\t    ofi_find_core_name(filter->names, name) >= 0)\n\t\treturn filter->negated ? 1 : 0;\n\n\treturn filter->negated ? 0 : 1;\n}\n\nstatic int ofi_getinfo_filter(const struct fi_provider *provider)\n{\n\t/* Positive filters only apply to core providers.  They must be\n\t * explicitly enabled by the filter.  Other providers (i.e. utility)\n\t * are automatically enabled in this case, so that they can work\n\t * over any enabled core filter.  Negative filters may be used\n\t * to disable any provider.\n\t */\n\tif (!prov_filter.negated && !ofi_is_core_prov(provider))\n\t\treturn 0;\n\n\treturn ofi_apply_prov_init_filter(&prov_filter, provider->name);\n}\n\nstatic void ofi_filter_info(struct fi_info **info)\n{\n\tstruct fi_info *cur, *prev, *tmp;\n\n\tif (!prov_filter.names)\n\t\treturn;\n\n\tprev = NULL;\n\tcur = *info;\n\twhile (cur) {\n\t\tassert(cur->fabric_attr && cur->fabric_attr->prov_name);\n\n\t\tif (ofi_apply_prov_post_filter(&prov_filter, cur->fabric_attr->prov_name)) {\n\t\t\ttmp = cur;\n\t\t\tcur = cur->next;\n\t\t\tif (prev)\n\t\t\t\tprev->next = cur;\n\t\t\telse\n\t\t\t\t*info = cur;\n\t\t\ttmp->next = NULL;\n\t\t\tfi_freeinfo(tmp);\n\t\t} else {\n\t\t\tprev = cur;\n\t\t\tcur = cur->next;\n\t\t}\n\t}\n}\n\nstatic struct ofi_prov *ofi_getprov(const char *prov_name, size_t len)\n{\n\tstruct ofi_prov *prov;\n\n\tfor (prov = prov_head; prov; prov = prov->next) {\n\t\tif ((strlen(prov->prov_name) == len) &&\n\t\t    !strncmp(prov->prov_name, prov_name, len))\n\t\t\treturn prov;\n\t}\n\n\treturn NULL;\n}\n\nstruct fi_provider *ofi_get_hook(const char *name)\n{\n\tstruct ofi_prov *prov;\n\tstruct fi_provider *provider = NULL;\n\tchar *try_name = NULL;\n\tint ret;\n\n\tprov = ofi_getprov(name, strlen(name));\n\tif (!prov) {\n\t\tret = asprintf(&try_name, \"ofi_hook_%s\", name);\n\t\tif (ret > 0)\n\t\t\tprov = ofi_getprov(try_name, ret);\n\t\telse\n\t\t\ttry_name = NULL;\n\t}\n\n\tif (prov) {\n\t\tif (prov->provider && ofi_is_hook_prov(prov->provider)) {\n\t\t\tprovider = prov->provider;\n\t\t} else {\n\t\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\t\"Specified provider is not a hook: %s\\n\", name);\n\t\t}\n\t} else {\n\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\"No hook found for: %s\\n\", name);\n\t}\n\n\tfree(try_name);\n\treturn provider;\n}\n\nstatic void cleanup_provider(struct fi_provider *provider, void *dlhandle)\n{\n\tOFI_UNUSED(dlhandle);\n\n\tif (provider) {\n\t\tfi_param_undefine(provider);\n\n\t\tif (provider->cleanup)\n\t\t\tprovider->cleanup();\n\t}\n\n#ifdef HAVE_LIBDL\n\tif (dlhandle)\n\t\tdlclose(dlhandle);\n#endif\n}\n\nstatic struct ofi_prov *ofi_create_prov_entry(const char *prov_name)\n{\n\tstruct ofi_prov *prov = NULL;\n\tprov = calloc(sizeof *prov, 1);\n\tif (!prov) {\n\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\"Not enough memory to allocate provider registry\\n\");\n\t\treturn NULL;\n\t}\n\n\tprov->prov_name = strdup(prov_name);\n\tif (!prov->prov_name) {\n\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\"Failed to init pre-registered provider name\\n\");\n\t\tfree(prov);\n\t\treturn NULL;\n\t}\n\tif (prov_tail)\n\t\tprov_tail->next = prov;\n\telse\n\t\tprov_head = prov;\n\tprov_tail = prov;\n\n\tprov->hidden = false;\n\n\treturn prov;\n}\n\n/* This is the default order that providers will be reported when a provider\n * is available.  Initialize the socket(s) provider last.  This will result in\n * it being the least preferred provider.\n */\nstatic void ofi_ordered_provs_init(void)\n{\n\tchar *ordered_prov_names[] = {\n\t\t\"psm2\", \"psm\", \"efa\", \"usnic\", \"gni\", \"bgq\", \"verbs\",\n\t\t\"netdir\", \"ofi_rxm\", \"ofi_rxd\", \"shm\",\n\t\t/* Initialize the socket based providers last of the\n\t\t * standard providers.  This will result in them being\n\t\t * the least preferred providers.\n\t\t */\n\n\t\t/* Before you add ANYTHING here, read the comment above!!! */\n\t\t\"UDP\", \"tcp\", \"sockets\", /* NOTHING GOES HERE! */\n\t\t/* Seriously, read it! */\n\n\t\t/* These are hooking providers only.  Their order\n\t\t * doesn't matter\n\t\t */\n\t\t\"ofi_hook_perf\", \"ofi_hook_debug\", \"ofi_hook_noop\",\n\t};\n\tint num_provs = sizeof(ordered_prov_names)/sizeof(ordered_prov_names[0]), i;\n\n\tfor (i = 0; i < num_provs; i++)\n\t\tofi_create_prov_entry(ordered_prov_names[i]);\n}\n\nstatic void ofi_set_prov_type(struct fi_prov_context *ctx,\n\t\t\t      struct fi_provider *provider)\n{\n\tif (!provider->getinfo)\n\t\tctx->type = OFI_PROV_HOOK;\n\telse if (ofi_has_util_prefix(provider->name))\n\t\tctx->type = OFI_PROV_UTIL;\n\telse\n\t\tctx->type = OFI_PROV_CORE;\n}\n\nstatic void ofi_register_provider(struct fi_provider *provider, void *dlhandle)\n{\n\tstruct fi_prov_context *ctx;\n\tstruct ofi_prov *prov = NULL;\n\tbool hidden = false;\n\n\tif (!provider || !provider->name) {\n\t\tFI_DBG(&core_prov, FI_LOG_CORE,\n\t\t       \"no provider structure or name\\n\");\n\t\tgoto cleanup;\n\t}\n\n\tFI_INFO(&core_prov, FI_LOG_CORE,\n\t       \"registering provider: %s (%d.%d)\\n\", provider->name,\n\t       FI_MAJOR(provider->version), FI_MINOR(provider->version));\n\n\tif (!provider->fabric) {\n\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\"provider missing mandatory entry points\\n\");\n\t\tgoto cleanup;\n\t}\n\n\t/* The current core implementation is not backward compatible\n\t * with providers that support a release earlier than v1.3.\n\t * See commit 0f4b6651.\n\t */\n\tif (provider->fi_version < FI_VERSION(1, 3)) {\n\t\tFI_INFO(&core_prov, FI_LOG_CORE,\n\t\t\t\"provider has unsupported FI version \"\n\t\t\t\"(provider %d.%d != libfabric %d.%d); ignoring\\n\",\n\t\t\tFI_MAJOR(provider->fi_version),\n\t\t\tFI_MINOR(provider->fi_version), FI_MAJOR_VERSION,\n\t\t\tFI_MINOR_VERSION);\n\t\tgoto cleanup;\n\t}\n\n\tctx = (struct fi_prov_context *) &provider->context;\n\tofi_set_prov_type(ctx, provider);\n\n\tif (ofi_getinfo_filter(provider)) {\n\t\tFI_INFO(&core_prov, FI_LOG_CORE,\n\t\t\t\"\\\"%s\\\" filtered by provider include/exclude \"\n\t\t\t\"list, skipping\\n\", provider->name);\n\t\thidden = true;\n\t}\n\n\tif (ofi_apply_filter(&prov_log_filter, provider->name))\n\t\tctx->disable_logging = 1;\n\n\tprov = ofi_getprov(provider->name, strlen(provider->name));\n\tif (prov) {\n\t\t/* If this provider has not been init yet, then we add the\n\t\t * provider and dlhandle to the struct and exit.\n\t\t */\n\t\tif (prov->provider == NULL)\n\t\t\tgoto update_prov_registry;\n\n\t\t/* If this provider is older than an already-loaded\n\t\t * provider of the same name, then discard this one.\n\t\t */\n\t\tif (FI_VERSION_GE(prov->provider->version, provider->version)) {\n\t\t\tFI_INFO(&core_prov, FI_LOG_CORE,\n\t\t\t\t\"a newer %s provider was already loaded; \"\n\t\t\t\t\"ignoring this one\\n\", provider->name);\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* This provider is newer than an already-loaded\n\t\t * provider of the same name, so discard the\n\t\t * already-loaded one.\n\t\t */\n\t\tFI_INFO(&core_prov, FI_LOG_CORE,\n\t\t\t\"an older %s provider was already loaded; \"\n\t\t\t\"keeping this one and ignoring the older one\\n\",\n\t\t\tprovider->name);\n\t\tcleanup_provider(prov->provider, prov->dlhandle);\n\t} else {\n\t\tprov = ofi_create_prov_entry(provider->name);\n\t\tif (!prov)\n\t\t\tgoto cleanup;\n\t}\n\n\tif (hidden)\n\t\tprov->hidden = true;\n\nupdate_prov_registry:\n\tprov->dlhandle = dlhandle;\n\tprov->provider = provider;\n\treturn;\n\ncleanup:\n\tcleanup_provider(provider, dlhandle);\n}\n\n#ifdef HAVE_LIBDL\nstatic int lib_filter(const struct dirent *entry)\n{\n\tsize_t l = strlen(entry->d_name);\n\tsize_t sfx = sizeof (FI_LIB_SUFFIX) - 1;\n\n\tif (l > sfx)\n\t\treturn !strcmp(&(entry->d_name[l-sfx]), FI_LIB_SUFFIX);\n\telse\n\t\treturn 0;\n}\n#endif\n\nstatic int verify_filter_names(char **names)\n{\n\tint i, j;\n\tchar** split_names;\n\tfor (i = 0; names[i]; i++) {\n\t\tsplit_names = ofi_split_and_alloc(names[i], \";\", NULL);\n\t\tif (!split_names) {\n\t\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\t\"unable to parse given filter string\\n\");\n\t\t\treturn -FI_ENODATA;\n\t\t}\n\n\t\tfor(j = 0; split_names[j]; j++) {\n\t\t\tif(!ofi_getprov(split_names[j], strlen(split_names[j]))) {\n\t\t\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\t\t\"provider %s is unknown, misspelled\"\n\t\t\t\t\t\" or DL provider?\\n\", split_names[j]);\n\t\t\t\tofi_suggest_prov_names(split_names[j]);\n\t\t\t}\n\t\t}\n\t\tofi_free_string_array(split_names);\n\t}\n\n\treturn FI_SUCCESS;\n}\n\nvoid ofi_free_filter(struct fi_filter *filter)\n{\n\tofi_free_string_array(filter->names);\n}\n\nvoid ofi_create_filter(struct fi_filter *filter, const char *raw_filter)\n{\n\tmemset(filter, 0, sizeof *filter);\n\tif (raw_filter == NULL)\n\t\treturn;\n\n\tif (*raw_filter == '^') {\n\t\tfilter->negated = 1;\n\t\t++raw_filter;\n\t}\n\n\tfilter->names = ofi_split_and_alloc(raw_filter, \",\", NULL);\n\tif (!filter->names)\n\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\"unable to parse filter from: %s\\n\", raw_filter);\n\n\tif(verify_filter_names(filter->names))\n\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t        \"unable to verify filter name\\n\");\n}\n\n#ifdef HAVE_LIBDL\nstatic void ofi_ini_dir(const char *dir)\n{\n\tint n = 0;\n\tchar *lib;\n\tvoid *dlhandle;\n\tstruct dirent **liblist = NULL;\n\tstruct fi_provider* (*inif)(void);\n\n\tn = scandir(dir, &liblist, lib_filter, NULL);\n\tif (n < 0)\n\t\tgoto libdl_done;\n\n\twhile (n--) {\n\t\tif (asprintf(&lib, \"%s/%s\", dir, liblist[n]->d_name) < 0) {\n\t\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t       \"asprintf failed to allocate memory\\n\");\n\t\t\tgoto libdl_done;\n\t\t}\n\t\tFI_DBG(&core_prov, FI_LOG_CORE, \"opening provider lib %s\\n\", lib);\n\n\t\tdlhandle = dlopen(lib, RTLD_NOW);\n\t\tfree(liblist[n]);\n\t\tif (dlhandle == NULL) {\n\t\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t       \"dlopen(%s): %s\\n\", lib, dlerror());\n\t\t\tfree(lib);\n\t\t\tcontinue;\n\t\t}\n\t\tfree(lib);\n\n\t\tinif = dlsym(dlhandle, \"fi_prov_ini\");\n\t\tif (inif == NULL) {\n\t\t\tFI_WARN(&core_prov, FI_LOG_CORE, \"dlsym: %s\\n\", dlerror());\n\t\t\tdlclose(dlhandle);\n\t\t} else {\n\t\t\tofi_register_provider((inif)(), dlhandle);\n\t\t}\n\t}\n\nlibdl_done:\n\twhile (n-- > 0)\n\t\tfree(liblist[n]);\n\tfree(liblist);\n}\n#endif\n\nvoid fi_ini(void)\n{\n\tchar *param_val = NULL;\n\n\tpthread_mutex_lock(&common_locks.ini_lock);\n\n\tif (ofi_init)\n\t\tgoto unlock;\n\n\tofi_ordered_provs_init();\n\tfi_param_init();\n\tfi_log_init();\n\tofi_osd_init();\n\tofi_mem_init();\n\tofi_pmem_init();\n\tofi_perf_init();\n\tofi_hook_init();\n\tofi_monitor_init();\n\n\tfi_param_define(NULL, \"provider\", FI_PARAM_STRING,\n\t\t\t\"Only use specified provider (default: all available)\");\n\tfi_param_define(NULL, \"fork_unsafe\", FI_PARAM_BOOL,\n\t\t\t\"Whether use of fork() may be unsafe for some providers\"\n\t\t\t\" (default: no). Setting this to yes could improve\"\n\t\t\t\" performance at the expense of making fork() potentially\"\n\t\t\t\" unsafe\");\n\tfi_param_define(NULL, \"universe_size\", FI_PARAM_SIZE_T,\n\t\t\t\"Defines the maximum number of processes that will be\"\n\t\t\t\" used by distribute OFI application. The provider uses\"\n\t\t\t\" this to optimize resource allocations\"\n\t\t\t\" (default: OFI service specific)\");\n\tfi_param_get_str(NULL, \"provider\", &param_val);\n\tofi_create_filter(&prov_filter, param_val);\n\n#ifdef HAVE_LIBDL\n\tint n = 0;\n\tchar **dirs;\n\tchar *provdir = NULL;\n\tvoid *dlhandle;\n\n\t/* If dlopen fails, assume static linking and just return\n\t   without error */\n\tdlhandle = dlopen(NULL, RTLD_NOW);\n\tif (dlhandle == NULL) {\n\t\tgoto libdl_done;\n\t}\n\tdlclose(dlhandle);\n\n\tfi_param_define(NULL, \"provider_path\", FI_PARAM_STRING,\n\t\t\t\"Search for providers in specific path (default: \"\n\t\t\tPROVDLDIR \")\");\n\tfi_param_get_str(NULL, \"provider_path\", &provdir);\n\tif (!provdir)\n\t\tprovdir = PROVDLDIR;\n\n\tdirs = ofi_split_and_alloc(provdir, \":\", NULL);\n\tif (dirs) {\n\t\tfor (n = 0; dirs[n]; ++n) {\n\t\t\tofi_ini_dir(dirs[n]);\n\t\t}\n\t\tofi_free_string_array(dirs);\n\t}\nlibdl_done:\n#endif\n\n\tofi_register_provider(PSM2_INIT, NULL);\n\tofi_register_provider(PSM_INIT, NULL);\n\tofi_register_provider(USNIC_INIT, NULL);\n\tofi_register_provider(GNI_INIT, NULL);\n\tofi_register_provider(BGQ_INIT, NULL);\n\tofi_register_provider(NETDIR_INIT, NULL);\n\tofi_register_provider(SHM_INIT, NULL);\n\tofi_register_provider(RXM_INIT, NULL);\n\tofi_register_provider(VERBS_INIT, NULL);\n\t/* ofi_register_provider(RSTREAM_INIT, NULL); - no support */\n\tofi_register_provider(MRAIL_INIT, NULL);\n\tofi_register_provider(RXD_INIT, NULL);\n\tofi_register_provider(EFA_INIT, NULL);\n\tofi_register_provider(UDP_INIT, NULL);\n\tofi_register_provider(SOCKETS_INIT, NULL);\n\tofi_register_provider(TCP_INIT, NULL);\n\n\tofi_register_provider(HOOK_PERF_INIT, NULL);\n\tofi_register_provider(HOOK_DEBUG_INIT, NULL);\n\tofi_register_provider(HOOK_NOOP_INIT, NULL);\n\n\tofi_init = 1;\n\nunlock:\n\tpthread_mutex_unlock(&common_locks.ini_lock);\n}\n\nFI_DESTRUCTOR(fi_fini(void))\n{\n\tstruct ofi_prov *prov;\n\n\tif (!ofi_init)\n\t\treturn;\n\n\twhile (prov_head) {\n\t\tprov = prov_head;\n\t\tprov_head = prov->next;\n\t\tcleanup_provider(prov->provider, prov->dlhandle);\n\t\tfree(prov->prov_name);\n\t\tfree(prov);\n\t}\n\n\tofi_free_filter(&prov_filter);\n\tofi_monitor_cleanup();\n\tofi_mem_fini();\n\tfi_log_fini();\n\tfi_param_fini();\n\tofi_osd_fini();\n}\n\n__attribute__((visibility (\"default\"),EXTERNALLY_VISIBLE))\nvoid DEFAULT_SYMVER_PRE(fi_freeinfo)(struct fi_info *info)\n{\n\tstruct fi_info *next;\n\n\tfor (; info; info = next) {\n\t\tnext = info->next;\n\n\t\tfree(info->src_addr);\n\t\tfree(info->dest_addr);\n\t\tfree(info->tx_attr);\n\t\tfree(info->rx_attr);\n\t\tif (info->ep_attr) {\n\t\t\tfree(info->ep_attr->auth_key);\n\t\t\tfree(info->ep_attr);\n\t\t}\n\t\tif (info->domain_attr) {\n\t\t\tfree(info->domain_attr->auth_key);\n\t\t\tfree(info->domain_attr->name);\n\t\t\tfree(info->domain_attr);\n\t\t}\n\t\tif (info->fabric_attr) {\n\t\t\tfree(info->fabric_attr->name);\n\t\t\tfree(info->fabric_attr->prov_name);\n\t\t\tfree(info->fabric_attr);\n\t\t}\n\t\tif (info->nic &&\n\t\t    FI_CHECK_OP(info->nic->fid.ops, struct fi_ops, close)) {\n\t\t\tfi_close(&info->nic->fid);\n\t\t}\n\t\tfree(info);\n\t}\n}\nCURRENT_SYMVER(fi_freeinfo_, fi_freeinfo);\n\n/*\n * Make a dummy info object for each provider, and copy in the\n * provider name and version.  We report utility providers directly\n * to export their version.\n */\nstatic int ofi_getprovinfo(struct fi_info **info)\n{\n\tstruct ofi_prov *prov;\n\tstruct fi_info *tail, *cur;\n\tint ret = -FI_ENODATA;\n\n\t*info = tail = NULL;\n\tfor (prov = prov_head; prov; prov = prov->next) {\n\t\tif (!prov->provider)\n\t\t\tcontinue;\n\n\t\tcur = fi_allocinfo();\n\t\tif (!cur) {\n\t\t\tret = -FI_ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\tcur->fabric_attr->prov_name = strdup(prov->provider->name);\n\t\tcur->fabric_attr->prov_version = prov->provider->version;\n\n\t\tif (!*info) {\n\t\t\t*info = tail = cur;\n\t\t} else {\n\t\t\ttail->next = cur;\n\t\t}\n\t\ttail = cur;\n\n\t\tret = 0;\n\t}\n\n\treturn ret;\n\nerr:\n\twhile (tail) {\n\t\tcur = tail->next;\n\t\tfi_freeinfo(tail);\n\t\ttail = cur;\n\t}\n\treturn ret;\n}\n\nstatic void ofi_set_prov_attr(struct fi_fabric_attr *attr,\n\t\t\t      struct fi_provider *prov)\n{\n\tchar *core_name;\n\n\tcore_name = attr->prov_name;\n\tif (core_name) {\n\t\tassert(ofi_is_util_prov(prov));\n\t\tattr->prov_name = ofi_strdup_append(core_name, prov->name);\n\t\tfree(core_name);\n\t} else {\n\t\tassert(ofi_is_core_prov(prov));\n\t\tattr->prov_name = strdup(prov->name);\n\t}\n\tattr->prov_version = prov->version;\n}\n\n/*\n * The layering of utility providers over core providers follows these rules.\n * 0. Provider names are delimited by \";\"\n * 1. Rules when # of providers <= 2:\n *    1a. If both are specified, then only return that layering\n *    1b. If a utility provider is specified, return it over any* core provider.\n *    1c. If a core provider is specified, return any utility provider that can\n *        layer over it, plus the core provider itself, if possible.\n *    1d. A utility provider will not layer over the sockets provider unless the\n *        user explicitly requests that combination.\n *    1e. OFI_CORE_PROV_ONLY flag prevents utility providers layering over other\n *        utility providers.\n * 2. If both the providers are utility providers or if more than two providers\n *    are specified, the rightmost provider would be compared.\n * 3. If any provider has a caret symbol \"^\" is prefixed before any provider\n *    name it would be excluded (internal use only). These excluded providers\n *    should be listed only at the end.\n */\nstatic int ofi_layering_ok(const struct fi_provider *provider,\n\t\t\t   char **prov_vec, size_t count,\n\t\t\t   uint64_t flags)\n{\n\tchar *prov_name;\n\tint i;\n\n\t/* Excluded providers must be at the end */\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tif (prov_vec[i][0] != '^')\n\t\t    break;\n\n\t\tif (!strcasecmp(&prov_vec[i][1], provider->name))\n\t\t\treturn 0;\n\t}\n\tcount = i + 1;\n\n\tif (flags & OFI_CORE_PROV_ONLY) {\n\t\tassert((count == 1) || (count == 0));\n\t\tif (!ofi_is_core_prov(provider)) {\n\t\t\tFI_INFO(&core_prov, FI_LOG_CORE,\n\t\t\t\t\"Need core provider, skipping %s\\n\",\n\t\t\t\tprovider->name);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif ((count == 0) && !strcasecmp(provider->name, \"sockets\")) {\n\t\t\tFI_INFO(&core_prov, FI_LOG_CORE,\n\t\t\t\t\"Skipping util;sockets layering\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (!count)\n\t\treturn 1;\n\n\t/* To maintain backward compatibility with the previous behavior of\n\t * ofi_layering_ok we need to check if the # of providers is two or\n\t * fewer. In such a case, we have to be agnostic to the ordering of\n\t * core and utility providers */\n\n\tif ((count == 1) && ofi_is_util_prov(provider) &&\n\t    !ofi_has_util_prefix(prov_vec[0])) {\n\t\tif (!strcasecmp(prov_vec[0], \"sockets\")) {\n\t\t\tFI_INFO(&core_prov, FI_LOG_CORE,\n\t\t\t\t\"Sockets requested, skipping util layering\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (!strcasecmp(prov_vec[0], \"shm\")) {\n\t\t\tFI_INFO(&core_prov, FI_LOG_CORE,\n\t\t\t\t\"Shm requested, skipping util layering\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}\n\n\tif ((count == 2) && ofi_has_util_prefix(prov_vec[0]) &&\n\t    !ofi_has_util_prefix(prov_vec[1]))\n\t\tprov_name = prov_vec[0];\n\telse\n\t\tprov_name = prov_vec[count - 1];\n\n\treturn !strcasecmp(provider->name, prov_name);\n}\n\n__attribute__((visibility (\"default\"),EXTERNALLY_VISIBLE))\nint DEFAULT_SYMVER_PRE(fi_getinfo)(uint32_t version, const char *node,\n\t\tconst char *service, uint64_t flags,\n\t\tconst struct fi_info *hints, struct fi_info **info)\n{\n\tstruct ofi_prov *prov;\n\tstruct fi_info *tail, *cur;\n\tchar **prov_vec = NULL;\n\tsize_t count = 0;\n\tenum fi_log_level level;\n\tint ret;\n\n\tif (!ofi_init)\n\t\tfi_ini();\n\n\tif (FI_VERSION_LT(fi_version(), version)) {\n\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\"Requested version is newer than library\\n\");\n\t\treturn -FI_ENOSYS;\n\t}\n\n\tif (flags == FI_PROV_ATTR_ONLY) {\n\t\treturn ofi_getprovinfo(info);\n\t}\n\n\tif (hints && hints->fabric_attr && hints->fabric_attr->prov_name) {\n\t\tprov_vec = ofi_split_and_alloc(hints->fabric_attr->prov_name,\n\t\t\t\t\t       \";\", &count);\n\t\tif (!prov_vec)\n\t\t\treturn -FI_ENOMEM;\n\t\tFI_DBG(&core_prov, FI_LOG_CORE, \"hints prov_name: %s\\n\",\n\t\t       hints->fabric_attr->prov_name);\n\t}\n\n\t*info = tail = NULL;\n\tfor (prov = prov_head; prov; prov = prov->next) {\n\t\tif (!prov->provider || !prov->provider->getinfo)\n\t\t\tcontinue;\n\n\t\tif (prov->hidden && !(flags & OFI_GETINFO_HIDDEN))\n\t\t\tcontinue;\n\n\t\tif (!ofi_layering_ok(prov->provider, prov_vec, count, flags))\n\t\t\tcontinue;\n\n\t\tif (FI_VERSION_LT(prov->provider->fi_version, version)) {\n\t\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\t\"Provider %s fi_version %d.%d < requested %d.%d\\n\",\n\t\t\t\tprov->provider->name,\n\t\t\t\tFI_MAJOR(prov->provider->fi_version),\n\t\t\t\tFI_MINOR(prov->provider->fi_version),\n\t\t\t\tFI_MAJOR(version), FI_MINOR(version));\n\t\t\tcontinue;\n\t\t}\n\n\t\tcur = NULL;\n\t\tret = prov->provider->getinfo(version, node, service, flags,\n\t\t\t\t\t      hints, &cur);\n\t\tif (ret) {\n\t\t\tlevel = ((hints && hints->fabric_attr &&\n\t\t\t\t  hints->fabric_attr->prov_name) ?\n\t\t\t\t FI_LOG_WARN : FI_LOG_INFO);\n\n\t\t\tFI_LOG(&core_prov, level, FI_LOG_CORE,\n\t\t\t       \"fi_getinfo: provider %s returned -%d (%s)\\n\",\n\t\t\t       prov->provider->name, -ret, fi_strerror(-ret));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!cur) {\n\t\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\t\"fi_getinfo: provider %s output empty list\\n\",\n\t\t\t\tprov->provider->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tFI_DBG(&core_prov, FI_LOG_CORE, \"fi_getinfo: provider %s \"\n\t\t       \"returned success\\n\", prov->provider->name);\n\n\t\tif (!*info)\n\t\t\t*info = cur;\n\t\telse\n\t\t\ttail->next = cur;\n\n\t\tfor (tail = cur; tail->next; tail = tail->next) {\n\t\t\tofi_set_prov_attr(tail->fabric_attr, prov->provider);\n\t\t\ttail->fabric_attr->api_version = version;\n\t\t}\n\t\tofi_set_prov_attr(tail->fabric_attr, prov->provider);\n\t\ttail->fabric_attr->api_version = version;\n\t}\n\tofi_free_string_array(prov_vec);\n\n\tif (!(flags & (OFI_CORE_PROV_ONLY | OFI_GETINFO_INTERNAL |\n\t               OFI_GETINFO_HIDDEN)))\n\t\tofi_filter_info(info);\n\n\treturn *info ? 0 : -FI_ENODATA;\n}\nCURRENT_SYMVER(fi_getinfo_, fi_getinfo);\n\nstruct fi_info *ofi_allocinfo_internal(void)\n{\n\tstruct fi_info *info;\n\n\tinfo = calloc(1, sizeof(*info));\n\tif (!info)\n\t\treturn NULL;\n\n\tinfo->tx_attr = calloc(1, sizeof(*info->tx_attr));\n\tinfo->rx_attr = calloc(1, sizeof(*info->rx_attr));\n\tinfo->ep_attr = calloc(1, sizeof(*info->ep_attr));\n\tinfo->domain_attr = calloc(1, sizeof(*info->domain_attr));\n\tinfo->fabric_attr = calloc(1, sizeof(*info->fabric_attr));\n\tif (!info->tx_attr|| !info->rx_attr || !info->ep_attr ||\n\t    !info->domain_attr || !info->fabric_attr)\n\t\tgoto err;\n\n\treturn info;\nerr:\n\tfi_freeinfo(info);\n\treturn NULL;\n}\n\n\n__attribute__((visibility (\"default\"),EXTERNALLY_VISIBLE))\nstruct fi_info *DEFAULT_SYMVER_PRE(fi_dupinfo)(const struct fi_info *info)\n{\n\tstruct fi_info *dup;\n\tint ret;\n\n\tif (!info)\n\t\treturn ofi_allocinfo_internal();\n\n\tdup = mem_dup(info, sizeof(*dup));\n\tif (dup == NULL) {\n\t\treturn NULL;\n\t}\n\tdup->src_addr = NULL;\n\tdup->dest_addr = NULL;\n\tdup->tx_attr = NULL;\n\tdup->rx_attr = NULL;\n\tdup->ep_attr = NULL;\n\tdup->domain_attr = NULL;\n\tdup->fabric_attr = NULL;\n\tdup->next = NULL;\n\n\tif (info->src_addr != NULL) {\n\t\tdup->src_addr = mem_dup(info->src_addr, info->src_addrlen);\n\t\tif (dup->src_addr == NULL)\n\t\t\tgoto fail;\n\t}\n\tif (info->dest_addr != NULL) {\n\t\tdup->dest_addr = mem_dup(info->dest_addr, info->dest_addrlen);\n\t\tif (dup->dest_addr == NULL)\n\t\t\tgoto fail;\n\t}\n\tif (info->tx_attr != NULL) {\n\t\tdup->tx_attr = mem_dup(info->tx_attr, sizeof(*info->tx_attr));\n\t\tif (dup->tx_attr == NULL)\n\t\t\tgoto fail;\n\t}\n\tif (info->rx_attr != NULL) {\n\t\tdup->rx_attr = mem_dup(info->rx_attr, sizeof(*info->rx_attr));\n\t\tif (dup->rx_attr == NULL)\n\t\t\tgoto fail;\n\t}\n\tif (info->ep_attr != NULL) {\n\t\tdup->ep_attr = mem_dup(info->ep_attr, sizeof(*info->ep_attr));\n\t\tif (dup->ep_attr == NULL)\n\t\t\tgoto fail;\n\t\tif (info->ep_attr->auth_key != NULL) {\n\t\t\tdup->ep_attr->auth_key =\n\t\t\t\tmem_dup(info->ep_attr->auth_key,\n\t\t\t\t\tinfo->ep_attr->auth_key_size);\n\t\t\tif (dup->ep_attr->auth_key == NULL)\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\tif (info->domain_attr) {\n\t\tdup->domain_attr = mem_dup(info->domain_attr,\n\t\t\t\t\t   sizeof(*info->domain_attr));\n\t\tif (dup->domain_attr == NULL)\n\t\t\tgoto fail;\n\t\tdup->domain_attr->name = NULL;\n\t\tdup->domain_attr->auth_key = NULL;\n\t\tif (info->domain_attr->name != NULL) {\n\t\t\tdup->domain_attr->name = strdup(info->domain_attr->name);\n\t\t\tif (dup->domain_attr->name == NULL)\n\t\t\t\tgoto fail;\n\t\t}\n\t\tif (info->domain_attr->auth_key != NULL) {\n\t\t\tdup->domain_attr->auth_key =\n\t\t\t\tmem_dup(info->domain_attr->auth_key,\n\t\t\t\t\tinfo->domain_attr->auth_key_size);\n\t\t\tif (dup->domain_attr->auth_key == NULL)\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\tif (info->fabric_attr) {\n\t\tdup->fabric_attr = mem_dup(info->fabric_attr,\n\t\t\t\t\t   sizeof(*info->fabric_attr));\n\t\tif (dup->fabric_attr == NULL)\n\t\t\tgoto fail;\n\t\tdup->fabric_attr->name = NULL;\n\t\tdup->fabric_attr->prov_name = NULL;\n\t\tif (info->fabric_attr->name != NULL) {\n\t\t\tdup->fabric_attr->name = strdup(info->fabric_attr->name);\n\t\t\tif (dup->fabric_attr->name == NULL)\n\t\t\t\tgoto fail;\n\t\t}\n\t\tif (info->fabric_attr->prov_name != NULL) {\n\t\t\tdup->fabric_attr->prov_name = strdup(info->fabric_attr->prov_name);\n\t\t\tif (dup->fabric_attr->prov_name == NULL)\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tif (info->nic) {\n\t\tret = fi_control(&info->nic->fid, FI_DUP, &dup->nic);\n\t\tif (ret && ret != -FI_ENOSYS)\n\t\t\tgoto fail;\n\t}\n\n\treturn dup;\n\nfail:\n\tfi_freeinfo(dup);\n\treturn NULL;\n}\nCURRENT_SYMVER(fi_dupinfo_, fi_dupinfo);\n\n__attribute__((visibility (\"default\"),EXTERNALLY_VISIBLE))\nint DEFAULT_SYMVER_PRE(fi_fabric)(struct fi_fabric_attr *attr,\n\t\tstruct fid_fabric **fabric, void *context)\n{\n\tstruct ofi_prov *prov;\n\tconst char *top_name;\n\tint ret;\n\n\tif (!attr || !attr->prov_name || !attr->name)\n\t\treturn -FI_EINVAL;\n\n\tif (!ofi_init)\n\t\tfi_ini();\n\n\ttop_name = strrchr(attr->prov_name, OFI_NAME_DELIM);\n\tif (top_name)\n\t\ttop_name++;\n\telse\n\t\ttop_name = attr->prov_name;\n\n\tif (!top_name)\n\t\treturn -FI_EINVAL;\n\n\tprov = ofi_getprov(top_name, strlen(top_name));\n\tif (!prov || !prov->provider || !prov->provider->fabric)\n\t\treturn -FI_ENODEV;\n\n\tret = prov->provider->fabric(attr, fabric, context);\n\tif (!ret) {\n\t\tif (FI_VERSION_GE(prov->provider->fi_version, FI_VERSION(1, 5)))\n\t\t\t(*fabric)->api_version = attr->api_version;\n\t\tFI_INFO(&core_prov, FI_LOG_CORE, \"Opened fabric: %s\\n\",\n\t\t\tattr->name);\n\n\t\tofi_hook_install(*fabric, fabric, prov->provider);\n\t}\n\n\treturn ret;\n}\nDEFAULT_SYMVER(fi_fabric_, fi_fabric, FABRIC_1.1);\n\n__attribute__((visibility (\"default\"),EXTERNALLY_VISIBLE))\nuint32_t DEFAULT_SYMVER_PRE(fi_version)(void)\n{\n\treturn FI_VERSION(FI_MAJOR_VERSION, FI_MINOR_VERSION);\n}\nDEFAULT_SYMVER(fi_version_, fi_version, FABRIC_1.0);\n\nstatic const char *const errstr[] = {\n\t[FI_EOTHER - FI_ERRNO_OFFSET] = \"Unspecified error\",\n\t[FI_ETOOSMALL - FI_ERRNO_OFFSET] = \"Provided buffer is too small\",\n\t[FI_EOPBADSTATE - FI_ERRNO_OFFSET] = \"Operation not permitted in current state\",\n\t[FI_EAVAIL - FI_ERRNO_OFFSET]  = \"Error available\",\n\t[FI_EBADFLAGS - FI_ERRNO_OFFSET] = \"Flags not supported\",\n\t[FI_ENOEQ - FI_ERRNO_OFFSET] = \"Missing or unavailable event queue\",\n\t[FI_EDOMAIN - FI_ERRNO_OFFSET] = \"Invalid resource domain\",\n\t[FI_ENOCQ - FI_ERRNO_OFFSET] = \"Missing or unavailable completion queue\",\n\t[FI_ECRC - FI_ERRNO_OFFSET] = \"CRC error\",\n\t[FI_ETRUNC - FI_ERRNO_OFFSET] = \"Truncation error\",\n\t[FI_ENOKEY - FI_ERRNO_OFFSET] = \"Required key not available\",\n\t[FI_ENOAV - FI_ERRNO_OFFSET] = \"Missing or unavailable address vector\",\n\t[FI_EOVERRUN - FI_ERRNO_OFFSET] = \"Queue has been overrun\",\n};\n\n__attribute__((visibility (\"default\"),EXTERNALLY_VISIBLE))\nconst char *DEFAULT_SYMVER_PRE(fi_strerror)(int errnum)\n{\n\tif (errnum < FI_ERRNO_OFFSET)\n\t\treturn strerror(errnum);\n\telse if (errnum < FI_ERRNO_MAX)\n\t\treturn errstr[errnum - FI_ERRNO_OFFSET];\n\telse\n\t\treturn errstr[FI_EOTHER - FI_ERRNO_OFFSET];\n}\nDEFAULT_SYMVER(fi_strerror_, fi_strerror, FABRIC_1.0);\n",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/libfabric/prov/util/src/util_mem_hooks.c": "/*\n * Copyright (c) 2016 Los Alamos National Security, LLC. All rights reserved.\n * Copyright (c) 2019 Intel Corporation, Inc.  All rights reserved.\n *\n * License text from Open-MPI (www.open-mpi.org/community/license.php)\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer listed\n * in this license in the documentation and/or other materials\n * provided with the distribution.\n *\n * - Neither the name of the copyright holders nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * The copyright holders provide no reassurances that the source code\n * provided does not infringe any patent, copyright, or any other\n * intellectual property rights of third parties.  The copyright holders\n * disclaim any liability to any recipient for claims brought against\n * recipient by any third party for infringement of that parties\n * intellectual property rights.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <ofi_mr.h>\n\nstruct ofi_memhooks memhooks;\nstruct ofi_mem_monitor *memhooks_monitor = &memhooks.monitor;\n\n\n#if defined(__linux__) && defined(HAVE_ELF_H) && defined(HAVE_SYS_AUXV_H)\n\n#include <elf.h>\n#include <sys/auxv.h>\n#include <sys/mman.h>\n#include <sys/syscall.h>\n#include <sys/types.h>\n#include <sys/shm.h>\n#include <unistd.h>\n#include <dlfcn.h>\n#include <fcntl.h>\n#include <link.h>\n\n\nstruct ofi_intercept {\n\tstruct dlist_entry \t\tentry;\n\tconst char\t\t\t*symbol;\n\tvoid\t\t\t\t*our_func;\n\tstruct dlist_entry\t\tdl_intercept_list;\n};\n\nstruct ofi_dl_intercept {\n\tstruct dlist_entry \t\tentry;\n\tvoid \t\t\t\t**dl_func_addr;\n\tvoid\t\t\t\t*dl_func;\n};\n\nenum {\n\tOFI_INTERCEPT_DLOPEN,\n\tOFI_INTERCEPT_MMAP,\n\tOFI_INTERCEPT_MUNMAP,\n\tOFI_INTERCEPT_MREMAP,\n\tOFI_INTERCEPT_MADVISE,\n\tOFI_INTERCEPT_SHMAT,\n\tOFI_INTERCEPT_SHMDT,\n\tOFI_INTERCEPT_BRK,\n\tOFI_INTERCEPT_MAX\n};\n\nstatic void *ofi_intercept_dlopen(const char *filename, int flag);\nstatic void *ofi_intercept_mmap(void *start, size_t length,\n\t\t\t\tint prot, int flags, int fd, off_t offset);\nstatic int ofi_intercept_munmap(void *start, size_t length);\nstatic void *ofi_intercept_mremap(void *old_address, size_t old_size,\n\t\tsize_t new_size, int flags, void *new_address);\nstatic int ofi_intercept_madvise(void *addr, size_t length, int advice);\nstatic void *ofi_intercept_shmat(int shmid, const void *shmaddr, int shmflg);\nstatic int ofi_intercept_shmdt(const void *shmaddr);\nstatic int ofi_intercept_brk(const void *brkaddr);\n\nstatic struct ofi_intercept intercepts[] = {\n\t[OFI_INTERCEPT_DLOPEN] = { .symbol = \"dlopen\",\n\t\t\t\t.our_func = ofi_intercept_dlopen},\n\t[OFI_INTERCEPT_MMAP] = { .symbol = \"mmap\",\n\t\t\t\t.our_func = ofi_intercept_mmap},\n\t[OFI_INTERCEPT_MUNMAP] = { .symbol = \"munmap\",\n\t\t\t\t.our_func = ofi_intercept_munmap},\n\t[OFI_INTERCEPT_MREMAP] = { .symbol = \"mremap\",\n\t\t\t\t.our_func = ofi_intercept_mremap},\n\t[OFI_INTERCEPT_MADVISE] = { .symbol = \"madvise\",\n\t\t\t\t.our_func = ofi_intercept_madvise},\n\t[OFI_INTERCEPT_SHMAT] = { .symbol = \"shmat\",\n\t\t\t\t.our_func = ofi_intercept_shmat},\n\t[OFI_INTERCEPT_SHMDT] = { .symbol = \"shmdt\",\n\t\t\t\t.our_func = ofi_intercept_shmdt},\n\t[OFI_INTERCEPT_BRK] = { .symbol = \"brk\",\n\t\t\t\t.our_func = ofi_intercept_brk},\n};\n\nstruct ofi_mem_calls {\n\tvoid *(*dlopen) (const char *, int);\n\tvoid *(*mmap)(void *, size_t, int, int, int, off_t);\n\tint (*munmap)(void *, size_t);\n\tvoid *(*mremap)(void *old_address, size_t old_size,\n\t\t\tsize_t new_size, int flags, ... /* void *new_address */ );\n\tint (*madvise)(void *addr, size_t length, int advice);\n\tvoid *(*shmat)(int shmid, const void *shmaddr, int shmflg);\n\tint (*shmdt)(const void *shmaddr);\n\tint (*brk)(const void *brkaddr);\n};\n\nstatic struct ofi_mem_calls real_calls;\n\n\nstatic const ElfW(Phdr) *\nofi_get_phdr_dynamic(const ElfW(Phdr) *phdr, uint16_t phnum, int phent)\n{\n\tuint16_t i;\n\n\tfor (i = 0 ; i < phnum; i++) {\n\t\tif (phdr->p_type == PT_DYNAMIC)\n\t\t\treturn phdr;\n\t\tphdr = (ElfW(Phdr)*) ((intptr_t) phdr + phent);\n\t}\n\n\treturn NULL;\n}\n\nstatic void *ofi_get_dynentry(ElfW(Addr) base, const ElfW(Phdr) *pdyn,\n\t\t\t      ElfW(Sxword) type)\n{\n\tElfW(Dyn) *dyn;\n\n\tfor (dyn = (ElfW(Dyn)*) (base + pdyn->p_vaddr); dyn->d_tag; ++dyn) {\n\t\tif (dyn->d_tag == type)\n\t\t\treturn (void *) (uintptr_t) dyn->d_un.d_val;\n\t}\n\n\treturn NULL;\n}\n\n#if SIZE_MAX > UINT_MAX\n#define OFI_ELF_R_SYM ELF64_R_SYM\n#else\n#define OFI_ELF_R_SYM ELF32_R_SYM\n#endif\n\nstatic void *ofi_dl_func_addr(ElfW(Addr) base, const ElfW(Phdr) *phdr,\n\t\t\t      int16_t phnum, int phent, const char *symbol)\n{\n\tconst ElfW(Phdr) *dphdr;\n\tElfW(Rela) *reloc;\n\tvoid *jmprel, *strtab;\n\tchar *elf_sym;\n\tuint32_t relsymidx;\n\tElfW(Sym) *symtab;\n\tsize_t pltrelsz;\n\n\tdphdr = ofi_get_phdr_dynamic(phdr, phnum, phent);\n\tjmprel = ofi_get_dynentry(base, dphdr, DT_JMPREL);\n\tsymtab = (ElfW(Sym) *) ofi_get_dynentry(base, dphdr, DT_SYMTAB);\n\tstrtab = ofi_get_dynentry (base, dphdr, DT_STRTAB);\n\tpltrelsz = (uintptr_t) ofi_get_dynentry(base, dphdr, DT_PLTRELSZ);\n\n\tfor (reloc = jmprel; (intptr_t) reloc < (intptr_t) jmprel + pltrelsz;\n\t     reloc++) {\n\t\trelsymidx = OFI_ELF_R_SYM(reloc->r_info);\n\t\telf_sym = (char *) strtab + symtab[relsymidx].st_name;\n\t\tif (!strcmp(symbol, elf_sym))\n\t\t\treturn (void *) (base + reloc->r_offset);\n        }\n\n        return NULL;\n}\n\nstatic int ofi_intercept_dl_calls(ElfW(Addr) base, const ElfW(Phdr) *phdr,\n\t\t\t\t  const char *phname, int16_t phnum, int phent,\n\t\t\t\t  struct ofi_intercept *intercept)\n{\n\tstruct ofi_dl_intercept *dl_entry;\n\tlong page_size = ofi_get_page_size();\n\tvoid **func_addr, *page;\n\tint ret;\n\n\tFI_DBG(&core_prov, FI_LOG_MR,\n\t       \"intercepting symbol %s from dl\\n\", intercept->symbol);\n\tfunc_addr = ofi_dl_func_addr(base, phdr, phnum, phent, intercept->symbol);\n\tif (!func_addr)\n\t\treturn FI_SUCCESS;\n\n\tpage = (void *) ((intptr_t) func_addr & ~(page_size - 1));\n\tret = mprotect(page, page_size, PROT_READ | PROT_WRITE);\n\tif (ret < 0)\n\t\treturn -FI_ENOSYS;\n\n\tif (*func_addr != intercept->our_func) {\n\t\tdl_entry = malloc(sizeof(*dl_entry));\n\t\tif (!dl_entry)\n\t\t\treturn -FI_ENOMEM;\n\n\t\tdl_entry->dl_func_addr = func_addr;\n\t\tdl_entry->dl_func = *func_addr;\n\t\t*func_addr = intercept->our_func;\n\t\tdlist_insert_tail(&dl_entry->entry, &intercept->dl_intercept_list);\n\t}\n\n\treturn FI_SUCCESS;\n}\n\nstatic int ofi_intercept_phdr_handler(struct dl_phdr_info *info,\n                                    size_t size, void *data)\n{\n\tstruct ofi_intercept *intercept = data;\n\tint phent, ret;\n\n\tphent = getauxval(AT_PHENT);\n\tif (phent <= 0) {\n\t\tFI_DBG(&core_prov, FI_LOG_MR, \"failed to read phent size\");\n\t\treturn -FI_EINVAL;\n\t}\n\n\tret = ofi_intercept_dl_calls(info->dlpi_addr, info->dlpi_phdr,\n\t\t\t\t     info->dlpi_name, info->dlpi_phnum,\n\t\t\t\t     phent, intercept);\n\treturn ret;\n}\n\nstatic void *ofi_intercept_dlopen(const char *filename, int flag)\n{\n\tstruct ofi_intercept  *intercept;\n\tvoid *handle;\n\n\thandle = real_calls.dlopen(filename, flag);\n\tif (!handle)\n\t\treturn NULL;\n\n\tpthread_mutex_lock(&memhooks_monitor->lock);\n\tdlist_foreach_container(&memhooks.intercept_list, struct ofi_intercept,\n\t\tintercept, entry) {\n\t\tdl_iterate_phdr(ofi_intercept_phdr_handler, intercept);\n\t}\n\tpthread_mutex_unlock(&memhooks_monitor->lock);\n\treturn handle;\n}\n\nstatic int ofi_restore_dl_calls(ElfW(Addr) base, const ElfW(Phdr) *phdr,\n\t\t\t\tconst char *phname, int16_t phnum, int phent,\n\t\t\t\tstruct ofi_intercept *intercept)\n{\n\tstruct ofi_dl_intercept *dl_entry;\n\tlong page_size = ofi_get_page_size();\n\tvoid **func_addr, *page;\n\tint ret;\n\n\tFI_DBG(&core_prov, FI_LOG_MR,\n\t       \"releasing symbol %s from dl\\n\", intercept->symbol);\n\tfunc_addr = ofi_dl_func_addr(base, phdr, phnum, phent, intercept->symbol);\n\tif (!func_addr)\n\t\treturn FI_SUCCESS;\n\n\tpage = (void *) ((intptr_t) func_addr & ~(page_size - 1));\n\tret = mprotect(page, page_size, PROT_READ | PROT_WRITE);\n\tif (ret < 0)\n\t\treturn -FI_ENOSYS;\n\n\tdlist_foreach_container_reverse(&intercept->dl_intercept_list,\n\t\tstruct ofi_dl_intercept, dl_entry, entry) {\n\n\t\tif (dl_entry->dl_func_addr != func_addr)\n\t\t\tcontinue;\n\n\t\tassert(*func_addr == intercept->our_func);\n\t\t*func_addr = dl_entry->dl_func;\n\t\tdlist_remove(&dl_entry->entry);\n\t\tfree(dl_entry);\n\t\tFI_DBG(&core_prov, FI_LOG_MR,\n\t\t       \"dl symbol %s restored\\n\", intercept->symbol);\n\t\tbreak;\n\t}\n\n\treturn FI_SUCCESS;\n}\n\nstatic int ofi_restore_phdr_handler(struct dl_phdr_info *info,\n                                    size_t size, void *data)\n{\n\tstruct ofi_intercept *intercept = data;\n\tint phent, ret;\n\n\tphent = getauxval(AT_PHENT);\n\tif (phent <= 0) {\n\t\tFI_DBG(&core_prov, FI_LOG_MR, \"failed to read phent size\");\n\t\treturn -FI_EINVAL;\n\t}\n\n\tret = ofi_restore_dl_calls(info->dlpi_addr, info->dlpi_phdr,\n\t\t\t\t   info->dlpi_name, info->dlpi_phnum,\n\t\t\t\t   phent, intercept);\n\treturn ret;\n}\n\nstatic void ofi_restore_intercepts(void)\n{\n\tstruct ofi_intercept *intercept;\n\n\tdlist_foreach_container(&memhooks.intercept_list, struct ofi_intercept,\n\t\tintercept, entry) {\n\t\tdl_iterate_phdr(ofi_restore_phdr_handler, intercept);\n\t}\n}\n\nstatic int ofi_intercept_symbol(struct ofi_intercept *intercept, void **real_func)\n{\n\tint ret;\n\n\tFI_DBG(&core_prov, FI_LOG_MR,\n\t       \"intercepting symbol %s\\n\", intercept->symbol);\n\tret = dl_iterate_phdr(ofi_intercept_phdr_handler, intercept);\n\tif (ret)\n\t\treturn ret;\n\n\t*real_func = dlsym(RTLD_DEFAULT, intercept->symbol);\n\tif (*real_func == intercept->our_func) {\n\t\t(void) dlerror();\n\t\t*real_func = dlsym(RTLD_NEXT, intercept->symbol);\n\t}\n\n\tif (!*real_func) {\n\t\tFI_DBG(&core_prov, FI_LOG_MR,\n\t\t       \"could not find symbol %s\\n\", intercept->symbol);\n\t\tret = -FI_ENOMEM;\n\t\treturn ret;\n\t}\n\tdlist_insert_tail(&intercept->entry, &memhooks.intercept_list);\n\n\treturn ret;\n}\n\nvoid ofi_intercept_handler(const void *addr, size_t len)\n{\n\tpthread_mutex_lock(&memhooks_monitor->lock);\n\tofi_monitor_notify(memhooks_monitor, addr, len);\n\tpthread_mutex_unlock(&memhooks_monitor->lock);\n}\n\nstatic void *ofi_intercept_mmap(void *start, size_t length,\n                            int prot, int flags, int fd, off_t offset)\n{\n\tFI_DBG(&core_prov, FI_LOG_MR,\n\t       \"intercepted mmap start %p len %zu\\n\", start, length);\n\tofi_intercept_handler(start, length);\n\n\treturn real_calls.mmap(start, length, prot, flags, fd, offset);\n}\n\nstatic int ofi_intercept_munmap(void *start, size_t length)\n{\n\tFI_DBG(&core_prov, FI_LOG_MR,\n\t       \"intercepted munmap start %p len %zu\\n\", start, length);\n\tofi_intercept_handler(start, length);\n\n\treturn real_calls.munmap(start, length);\n}\n\nstatic void *ofi_intercept_mremap(void *old_address, size_t old_size,\n\t\tsize_t new_size, int flags, void *new_address)\n{\n\tFI_DBG(&core_prov, FI_LOG_MR,\n\t       \"intercepted mremap old_addr %p old_size %zu\\n\",\n\t       old_address, old_size);\n\tofi_intercept_handler(old_address, old_size);\n\n\treturn real_calls.mremap(old_address, old_size, new_size, flags,\n\t\t\t\t new_address);\n}\n\nstatic int ofi_intercept_madvise(void *addr, size_t length, int advice)\n{\n\tFI_DBG(&core_prov, FI_LOG_MR,\n\t       \"intercepted madvise addr %p len %zu\\n\", addr, length);\n\tofi_intercept_handler(addr, length);\n\n\treturn real_calls.madvise(addr, length, advice);\n}\n\nstatic void *ofi_intercept_shmat(int shmid, const void *shmaddr, int shmflg)\n{\n\tstruct shmid_ds ds;\n\tconst void *start;\n\tsize_t len;\n\tint ret;\n\n\tFI_DBG(&core_prov, FI_LOG_MR,\n\t       \"intercepted shmat addr %p\\n\", shmaddr);\n\n\tif (shmflg & SHM_REMAP) {\n\t\tret = shmctl(shmid, IPC_STAT, &ds);\n\t\tlen = (ret < 0) ? 0 : ds.shm_segsz;\n\n\t\tif (shmflg & SHM_RND) {\n\t\t\tstart = (char *) shmaddr + ((uintptr_t) shmaddr) % SHMLBA;\n\t\t\tlen += ((uintptr_t) shmaddr) % SHMLBA;\n\t\t} else {\n\t\t\tstart = shmaddr;\n\t\t}\n\n\t\tofi_intercept_handler(start, len);\n\t}\n\n\treturn real_calls.shmat(shmid, shmaddr, shmflg);\n}\n\nstatic int ofi_intercept_shmdt(const void *shmaddr)\n{\n\tFI_DBG(&core_prov, FI_LOG_MR,\n\t       \"intercepted shmdt addr %p\\n\", shmaddr);\n\t/* Overly aggressive, but simple.  Invalidate everything after shmaddr */\n\tofi_intercept_handler(shmaddr, SIZE_MAX - (uintptr_t) shmaddr);\n\n\treturn real_calls.shmdt(shmaddr);\n}\n\nstatic int ofi_intercept_brk(const void *brkaddr)\n{\n\tvoid *old_addr;\n\n\tFI_DBG(&core_prov, FI_LOG_MR,\n\t      \"intercepted brk addr %p\\n\", brkaddr);\n\n\told_addr = sbrk (0);\n\n\tif(brkaddr > old_addr) {\n\t\tofi_intercept_handler(brkaddr, (intptr_t) brkaddr -\n\t\t\t\t\t\t\t  (intptr_t) old_addr);\n\t}\n\n\treturn real_calls.brk(brkaddr);\n}\n\nstatic int ofi_memhooks_subscribe(struct ofi_mem_monitor *monitor,\n\t\t\t\t const void *addr, size_t len)\n{\n\t/* no-op */\n\treturn FI_SUCCESS;\n}\n\nstatic void ofi_memhooks_unsubscribe(struct ofi_mem_monitor *monitor,\n\t\t\t\t    const void *addr, size_t len)\n{\n\t/* no-op */\n}\n\nint ofi_memhooks_init(void)\n{\n\tint i, ret;\n\n\tif (memhooks_monitor->subscribe == ofi_memhooks_subscribe)\n\t\treturn 0;\n\n\tmemhooks_monitor->subscribe = ofi_memhooks_subscribe;\n\tmemhooks_monitor->unsubscribe = ofi_memhooks_unsubscribe;\n\tdlist_init(&memhooks.intercept_list);\n\n\tfor (i = 0; i < OFI_INTERCEPT_MAX; ++i)\n\t\tdlist_init(&intercepts[i].dl_intercept_list);\n\n\tret = ofi_intercept_symbol(&intercepts[OFI_INTERCEPT_DLOPEN],\n\t\t\t\t   (void **) &real_calls.dlopen);\n\tif (ret) {\n\t\tFI_WARN(&core_prov, FI_LOG_MR,\n\t\t       \"intercept dlopen failed %d %s\\n\", ret, fi_strerror(ret));\n\t\treturn ret;\n\t}\n\n\tret = ofi_intercept_symbol(&intercepts[OFI_INTERCEPT_MMAP],\n\t\t\t\t   (void **) &real_calls.mmap);\n\tif (ret) {\n\t\tFI_WARN(&core_prov, FI_LOG_MR,\n\t\t       \"intercept mmap failed %d %s\\n\", ret, fi_strerror(ret));\n\t\treturn ret;\n\t}\n\n\tret = ofi_intercept_symbol(&intercepts[OFI_INTERCEPT_MUNMAP],\n\t\t\t\t   (void **) &real_calls.munmap);\n\tif (ret) {\n\t\tFI_WARN(&core_prov, FI_LOG_MR,\n\t\t       \"intercept munmap failed %d %s\\n\", ret, fi_strerror(ret));\n\t\treturn ret;\n\t}\n\n\tret = ofi_intercept_symbol(&intercepts[OFI_INTERCEPT_MREMAP],\n\t\t\t\t   (void **) &real_calls.mremap);\n\tif (ret) {\n\t\tFI_WARN(&core_prov, FI_LOG_MR,\n\t\t       \"intercept mremap failed %d %s\\n\", ret, fi_strerror(ret));\n\t\treturn ret;\n\t}\n\n\tret = ofi_intercept_symbol(&intercepts[OFI_INTERCEPT_MADVISE],\n\t\t\t\t   (void **) &real_calls.madvise);\n\tif (ret) {\n\t\tFI_WARN(&core_prov, FI_LOG_MR,\n\t\t       \"intercept madvise failed %d %s\\n\", ret, fi_strerror(ret));\n\t\treturn ret;\n\t}\n\n\tret = ofi_intercept_symbol(&intercepts[OFI_INTERCEPT_SHMAT],\n\t\t\t\t   (void **) &real_calls.shmat);\n\tif (ret) {\n\t\tFI_WARN(&core_prov, FI_LOG_MR,\n\t\t       \"intercept shmat failed %d %s\\n\", ret, fi_strerror(ret));\n\t\treturn ret;\n\t}\n\n\tret = ofi_intercept_symbol(&intercepts[OFI_INTERCEPT_SHMDT],\n\t\t\t\t   (void **) &real_calls.shmdt);\n\tif (ret) {\n\t\tFI_WARN(&core_prov, FI_LOG_MR,\n\t\t       \"intercept shmdt failed %d %s\\n\", ret, fi_strerror(ret));\n\t\treturn ret;\n\t}\n\n\tret = ofi_intercept_symbol(&intercepts[OFI_INTERCEPT_BRK],\n\t\t\t\t   (void **) &real_calls.brk);\n\tif (ret) {\n\t\tFI_WARN(&core_prov, FI_LOG_MR,\n\t\t       \"intercept brk failed %d %s\\n\", ret, fi_strerror(ret));\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nvoid ofi_memhooks_cleanup(void)\n{\n\tofi_restore_intercepts();\n\tmemhooks_monitor->subscribe = NULL;\n\tmemhooks_monitor->unsubscribe = NULL;\n}\n\n#else\n\nint ofi_memhooks_init(void)\n{\n\treturn -FI_ENOSYS;\n}\n\nvoid ofi_memhooks_cleanup(void)\n{\n}\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/configure.ac": "# -*- shell-script -*-\n#\n# Copyright \u00a9 2009      CNRS\n# Copyright \u00a9 2009-2018 Inria.  All rights reserved.\n# Copyright \u00a9 2009, 2011-2012      Universit\u00e9 Bordeaux\n# Copyright \u00a9 2009-2014 Cisco Systems, Inc.  All rights reserved.\n#\n# See COPYING in top-level directory.\n#\n# Additional copyrights may follow\n#\n# $HEADER$\n#\n\n####################################################################\n# Autoconf, Automake, and Libtool bootstrapping\n####################################################################\n\nAC_INIT([hwloc],\n        [m4_normalize(esyscmd([config/hwloc_get_version.sh VERSION --version]))],\n        [http://github.com/open-mpi/hwloc/issues], [hwloc])\nAC_PREREQ(2.63)\nAC_CONFIG_AUX_DIR(./config)\n# Note that this directory must *exactly* match what was specified via\n# -I in ACLOCAL_AMFLAGS in the top-level Makefile.am.\nAC_CONFIG_MACRO_DIR(./config)\n\ncat <<EOF\n\n###\n### Configuring hwloc distribution tarball\n### Startup tests\n###\nEOF\n\n# This must be before AM_INIT_AUTOMAKE\nAC_CANONICAL_TARGET\n\n# Init automake\nAM_INIT_AUTOMAKE([1.11 dist-bzip2 subdir-objects foreign tar-ustar parallel-tests -Wall -Werror])\nm4_ifdef([AM_SILENT_RULES], [AM_SILENT_RULES([yes])])\n\nAC_LANG([C])\nAC_USE_SYSTEM_EXTENSIONS\n\n####################################################################\n# Setup the configure-results header file\n####################################################################\n\nAH_TOP([/* -*- c -*-\n *\n * Copyright \u00a9 2009, 2011, 2012 CNRS, inria., Universit\u00e9 Bordeaux  All rights reserved.\n * Copyright \u00a9 2009-2014 Cisco Systems, Inc.  All rights reserved.\n * $COPYRIGHT$\n *\n * Additional copyrights may follow\n *\n * $HEADER$\n *\n * This file is automatically generated by configure.  Edits will be lost\n * the next time you run configure!\n */\n\n#ifndef HWLOC_CONFIGURE_H\n#define HWLOC_CONFIGURE_H\n])\nAH_BOTTOM([\n#endif /* HWLOC_CONFIGURE_H */\n])\n\n####################################################################\n# Setup Libtool\n####################################################################\n\n# We want new Libtool.  None of that old stuff.  Pfft.\nm4_ifdef([LT_PREREQ], [],\n         [m4_fatal([libtool version 2.2.6 or higher is required], [63])])\nLT_PREREQ([2.2.6])\n\n# Setup libtool, but disable F77, Java and Windows Resource\n# Compiler support -- we don't need that stuff.\nAM_ENABLE_SHARED\nAM_DISABLE_STATIC\n\n# This did not exist pre AM 1.11.x (where x is somewhere >0 and <3),\n# but it is necessary in AM 1.12.x.\nm4_ifdef([AM_PROG_AR], [AM_PROG_AR])\n\nLT_INIT([dlopen win32-dll])\nLT_LANG([C])\nLT_LANG([C++])\n\n####################################################################\n# Setup C, C++ compilers\n####################################################################\n\nCFLAGS_save=$CFLAGS\nAC_PROG_CC\nAM_PROG_CC_C_O\nAC_PROG_CC_C99\nCFLAGS=$CFLAGS_save\n\nAC_ARG_VAR(CC_FOR_BUILD,[build system C compiler])\nAS_IF([test -z \"$CC_FOR_BUILD\"],[\n    AC_SUBST([CC_FOR_BUILD], [$CC])\n])\n\n####################################################################\n# CLI arguments\n####################################################################\n\n# Define hwloc's configure arguments\nHWLOC_DEFINE_ARGS\n\n# If debug mode, add -g\nAS_IF([test \"$hwloc_debug\" = \"1\"],\n      [CFLAGS=\"$CFLAGS -g\"])\n\n# If the user didn't specifically ask for embedding mode, default to\n# standalone mode\nAS_IF([test \"$enable_embedded_mode\" != \"yes\"],\n      [AS_IF([test ! -d \"$srcdir/doc\"],\n             [AC_MSG_WARN([The hwloc source tree looks incomplete for a standalone])\n              AC_MSG_WARN([build.  Perhaps this hwloc tree is intended for an embedded])\n              AC_MSG_WARN([build?  Try using the --enable-embedded-mode switch.])\n              AC_MSG_ERROR([Cannot build standalone hwloc])],\n             [HWLOC_BUILD_STANDALONE])])\n\n####################################################################\n# Setup for the hwloc API\n####################################################################\n\nAC_SUBST([libhwloc_so_version])\n\n# Setup the hwloc core\nHWLOC_SETUP_CORE([], [], [AC_MSG_ERROR([Cannot build hwloc core])], [1])\n\n####################################################################\n# Setup the netloc API\n####################################################################\n\nAC_SUBST([libnetloc_so_version])\n\nAC_ARG_ENABLE([netloc],\n              [AC_HELP_STRING([--enable-netloc],\n                              [The Netloc functionality is disabled by default. Using --enable-netloc will cause configure to abort if Netloc cannot be build (e.g., not supported on your platform).])\n              ])\n\nAS_IF([test \"$enable_netloc\" = \"yes\" -a \"$hwloc_mode\" = \"standalone\"],\n      [NETLOC_SETUP_CORE([], [],\n           [AS_IF([test \"$enable_netloc\" = \"yes\"],\n                  [AC_MSG_ERROR([Cannot build netloc core])])\n           ],\n           [1])\n      ])\n\n####################################################################\n# Version information\n####################################################################\n\n# HWLOC_VERSION was setup by HWLOC_SETUP_CORE above.\n\n# Make configure depend on the VERSION file, since it's used in AC_INIT\nAC_SUBST([CONFIGURE_DEPENDENCIES], ['$(top_srcdir)/VERSION'])\n\n# Override/fixup the version numbers set by AC_INIT, since on\n# developer builds, there's no good way to know what the version is\n# before running configure :(.  We only use the base version number\n# for the version set in AC_INIT.  This will always match reality\n# because we add the VERSION file (the only way to change the\n# major.minor.release{greek}) into the configure dependencies.\nPACKAGE_VERSION=\"$HWLOC_VERSION\"\nPACKAGE_STRING=\"${PACKAGE_NAME} ${PACKAGE_VERSION}\"\nVERSION=\"${PACKAGE_VERSION}\"\n\n# For standalone configurations, we also include a .so version number.\n\n. $srcdir/VERSION\n\n####################################################################\n# Setup the rest of the infrastructure\n####################################################################\n\n# Setup hwloc's docs, utils, and tests\nAS_IF([test \"$hwloc_mode\" = \"standalone\"],\n      [HWLOC_SETUP_DOCS\n       HWLOC_SETUP_UTILS\n       HWLOC_SETUP_TESTS])\n\ncat <<EOF\n\n###\n### Performing final hwloc configuration\n###\nEOF\n\n# Run the AM_CONDITIONALs\nHWLOC_DO_AM_CONDITIONALS\nNETLOC_DO_AM_CONDITIONALS\n\n####################################################################\n# Final output\n####################################################################\n\n# Set the final flags\nCFLAGS=\"$HWLOC_EMBEDDED_CFLAGS $CFLAGS\"\nCPPFLAGS=\"$HWLOC_EMBEDDED_CPPFLAGS $CPPFLAGS\"\nLIBS=\"$HWLOC_EMBEDDED_LIBS $LIBS\"\n\n# Party on\nAC_OUTPUT\n\n# Warn if we didn't have pkg-config\nif test \"x$PKG_CONFIG\" = x; then\n  cat << EOF\n\n************************************************************************\nCould not detect/enable some features such as libxml2 and Cairo support\nbecause pkg-config isn't available.\n************************************************************************\nEOF\nfi\n\n# Show which optional support we'll be building\nhwloc_xml_status=basic\nAS_IF([test \"$hwloc_libxml2_happy\" = \"yes\"], [hwloc_xml_status=full])\nnetloc_status=no\nAS_IF([test \"$netloc_happy\" = \"yes\"], [\n  netlocscotch_status=without\n  AS_IF([test \"$scotch_found_headers\" = \"yes\"], [netlocscotch_status=with])\n  netloc_status=\"yes ($netlocscotch_status scotch)\"\n])\nhwloc_cairo_status=$hwloc_cairo_happy\nAS_IF([test \"$enable_embedded_mode\" = \"yes\"], [hwloc_cairo_status=\"no (disabled in embedded mode)\"])\n\n# Prepare the I/O summary\nhwloc_probeio_list=\nif test \"x$hwloc_pciaccess_happy\" = \"xyes\" -o \"x$hwloc_linuxpci_happy\" = \"xyes\"; then\n  test \"x$hwloc_pciaccess_happy\" = \"xyes\" && hwloc_probepci_list=pciaccess\n  test \"x$hwloc_pciaccess_happy$hwloc_linuxpci_happy\" = \"xyesyes\" && hwloc_probepci_list=\"${hwloc_probepci_list}+\"\n  test \"x$hwloc_linuxio_happy\" = \"xyes\" && hwloc_probepci_list=\"${hwloc_probepci_list}linux\"\n  hwloc_probeio_list=\"$hwloc_probeio_list PCI($hwloc_probepci_list)\"\nfi\ntest \"x$hwloc_linuxio_happy\" = \"xyes\" && hwloc_probeio_list=\"$hwloc_probeio_list LinuxIO\"\ntest \"x$hwloc_opencl_happy\" = \"xyes\" && hwloc_probeio_list=\"$hwloc_probeio_list OpenCL\"\ntest \"x$hwloc_have_cudart\" = \"xyes\" && hwloc_probeio_list=\"$hwloc_probeio_list CUDA\"\ntest \"x$hwloc_nvml_happy\" = \"xyes\" && hwloc_probeio_list=\"$hwloc_probeio_list NVML\"\ntest \"x$hwloc_gl_happy\" = \"xyes\" && hwloc_probeio_list=\"$hwloc_probeio_list GL\"\n# if nothing, say \"no\"\ntest \"x$hwloc_probeio_list\" = \"x\" && hwloc_probeio_list=\" no\"\n\n# Beginning of generic support\ncat <<EOF\n\n-----------------------------------------------------------------------------\nHwloc optional build support status (more details can be found above):\n\nProbe / display I/O devices:$hwloc_probeio_list\nGraphical output (Cairo):    $hwloc_cairo_status\nXML input / output:          $hwloc_xml_status\nNetloc functionality:        $netloc_status\nEOF\n\n# Plugin support\nhwloc_plugin_summary=$hwloc_have_plugins\ntest \"x$hwloc_plugin_components\" != \"x\" && hwloc_plugin_summary=\"yes (\"`echo $hwloc_plugin_components`\")\" # echo removes the starting space\ncat <<EOF\nPlugin support:              $hwloc_plugin_summary\nEOF\n\n# End of generic support\ncat <<EOF\n-----------------------------------------------------------------------------\n\nEOF\n",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/config/hwloc.m4": "dnl -*- Autoconf -*-\ndnl\ndnl Copyright \u00a9 2009-2020 Inria.  All rights reserved.\ndnl Copyright \u00a9 2009-2012, 2015-2017 Universit\u00e9 Bordeaux\ndnl Copyright \u00a9 2004-2005 The Trustees of Indiana University and Indiana\ndnl                         University Research and Technology\ndnl                         Corporation.  All rights reserved.\ndnl Copyright \u00a9 2004-2012 The Regents of the University of California.\ndnl                         All rights reserved.\ndnl Copyright \u00a9 2004-2008 High Performance Computing Center Stuttgart,\ndnl                         University of Stuttgart.  All rights reserved.\ndnl Copyright \u00a9 2006-2017 Cisco Systems, Inc.  All rights reserved.\ndnl Copyright \u00a9 2012  Blue Brain Project, BBP/EPFL. All rights reserved.\ndnl Copyright \u00a9 2012       Oracle and/or its affiliates.  All rights reserved.\ndnl Copyright \u00a9 2012  Los Alamos National Security, LLC. All rights reserved.\ndnl See COPYING in top-level directory.\n\n# Main hwloc m4 macro, to be invoked by the user\n#\n# Expects two or three paramters:\n# 1. Configuration prefix\n# 2. What to do upon success\n# 3. What to do upon failure\n# 4. If non-empty, print the announcement banner\n#\nAC_DEFUN([HWLOC_SETUP_CORE],[\n    AC_REQUIRE([AC_USE_SYSTEM_EXTENSIONS])\n    AC_REQUIRE([AC_CANONICAL_TARGET])\n    AC_REQUIRE([AC_PROG_CC])\n\n    AS_IF([test \"x$4\" != \"x\"],\n          [cat <<EOF\n\n###\n### Configuring hwloc core\n###\nEOF])\n\n    # If no prefix was defined, set a good value\n    m4_ifval([$1],\n             [m4_define([hwloc_config_prefix],[$1/])],\n             [m4_define([hwloc_config_prefix], [])])\n\n    # Unless previously set to \"standalone\" mode, default to embedded\n    # mode\n    AS_IF([test \"$hwloc_mode\" = \"\"], [hwloc_mode=embedded])\n    AC_MSG_CHECKING([hwloc building mode])\n    AC_MSG_RESULT([$hwloc_mode])\n\n    # Get hwloc's absolute top builddir (which may not be the same as\n    # the real $top_builddir, because we may be building in embedded\n    # mode).\n    HWLOC_startdir=`pwd`\n    if test x\"hwloc_config_prefix\" != \"x\" -a ! -d \"hwloc_config_prefix\"; then\n        mkdir -p \"hwloc_config_prefix\"\n    fi\n    if test x\"hwloc_config_prefix\" != \"x\"; then\n        cd \"hwloc_config_prefix\"\n    fi\n    HWLOC_top_builddir=`pwd`\n    AC_SUBST(HWLOC_top_builddir)\n\n    # Get hwloc's absolute top srcdir (which may not be the same as\n    # the real $top_srcdir, because we may be building in embedded\n    # mode).  First, go back to the startdir incase the $srcdir is\n    # relative.\n\n    cd \"$HWLOC_startdir\"\n    cd \"$srcdir\"/hwloc_config_prefix\n    HWLOC_top_srcdir=\"`pwd`\"\n    AC_SUBST(HWLOC_top_srcdir)\n\n    # Go back to where we started\n    cd \"$HWLOC_startdir\"\n\n    AC_MSG_NOTICE([hwloc builddir: $HWLOC_top_builddir])\n    AC_MSG_NOTICE([hwloc srcdir: $HWLOC_top_srcdir])\n    if test \"$HWLOC_top_builddir\" != \"$HWLOC_top_srcdir\"; then\n        AC_MSG_NOTICE([Detected VPATH build])\n    fi\n\n    # Get the version of hwloc that we are installing\n    AC_MSG_CHECKING([for hwloc version])\n    HWLOC_VERSION=\"`$HWLOC_top_srcdir/config/hwloc_get_version.sh $HWLOC_top_srcdir/VERSION`\"\n    if test \"$?\" != \"0\"; then\n        AC_MSG_ERROR([Cannot continue])\n    fi\n    AC_MSG_RESULT([$HWLOC_VERSION])\n    AC_SUBST(HWLOC_VERSION)\n    AC_DEFINE_UNQUOTED([HWLOC_VERSION], [\"$HWLOC_VERSION\"],\n                       [The library version, always available, even in embedded mode, contrary to VERSION])\n\n    HWLOC_VERSION_MAJOR=\"`$HWLOC_top_srcdir/config/hwloc_get_version.sh $HWLOC_top_srcdir/VERSION --major`\"\n    AC_DEFINE_UNQUOTED([HWLOC_VERSION_MAJOR], [$HWLOC_VERSION_MAJOR], [The library version major number])\n    HWLOC_VERSION_MINOR=\"`$HWLOC_top_srcdir/config/hwloc_get_version.sh $HWLOC_top_srcdir/VERSION --minor`\"\n    AC_DEFINE_UNQUOTED([HWLOC_VERSION_MINOR], [$HWLOC_VERSION_MINOR], [The library version minor number])\n    HWLOC_VERSION_RELEASE=\"`$HWLOC_top_srcdir/config/hwloc_get_version.sh $HWLOC_top_srcdir/VERSION --release`\"\n    AC_DEFINE_UNQUOTED([HWLOC_VERSION_RELEASE], [$HWLOC_VERSION_RELEASE], [The library version release number])\n    HWLOC_VERSION_GREEK=\"`$HWLOC_top_srcdir/config/hwloc_get_version.sh $HWLOC_top_srcdir/VERSION --greek`\"\n    AC_DEFINE_UNQUOTED([HWLOC_VERSION_GREEK], [\"$HWLOC_VERSION_GREEK\"], [The library version optional greek suffix string])\n\n    HWLOC_RELEASE_DATE=\"`$HWLOC_top_srcdir/config/hwloc_get_version.sh $HWLOC_top_srcdir/VERSION --release-date`\"\n    AC_SUBST(HWLOC_RELEASE_DATE)\n\n    # Debug mode?\n    AC_MSG_CHECKING([if want hwloc maintainer support])\n    hwloc_debug=\n\n    # Unconditionally disable debug mode in embedded mode; if someone\n    # asks, we can add a configure-time option for it.  Disable it\n    # now, however, because --enable-debug is not even added as an\n    # option when configuring in embedded mode, and we wouldn't want\n    # to hijack the enclosing application's --enable-debug configure\n    # switch.\n    AS_IF([test \"$hwloc_mode\" = \"embedded\"],\n          [hwloc_debug=0\n           hwloc_debug_msg=\"disabled (embedded mode)\"])\n    AS_IF([test \"$hwloc_debug\" = \"\" -a \"$enable_debug\" = \"yes\"],\n          [hwloc_debug=1\n           hwloc_debug_msg=\"enabled\"])\n    AS_IF([test \"$hwloc_debug\" = \"\"],\n          [hwloc_debug=0\n           hwloc_debug_msg=\"disabled\"])\n    # Grr; we use #ifndef for HWLOC_DEBUG!  :-(\n    AH_TEMPLATE(HWLOC_DEBUG, [Whether we are in debugging mode or not])\n    AS_IF([test \"$hwloc_debug\" = \"1\"], [AC_DEFINE([HWLOC_DEBUG])])\n    AC_MSG_RESULT([$hwloc_debug_msg])\n\n    # We need to set a path for header, etc files depending on whether\n    # we're standalone or embedded. this is taken care of by HWLOC_EMBEDDED.\n\n    AC_MSG_CHECKING([for hwloc directory prefix])\n    AC_MSG_RESULT(m4_ifval([$1], hwloc_config_prefix, [(none)]))\n\n    # Note that private/config.h *MUST* be listed first so that it\n    # becomes the \"main\" config header file.  Any AC-CONFIG-HEADERS\n    # after that (hwloc/config.h) will only have selective #defines\n    # replaced, not the entire file.\n    AC_CONFIG_HEADERS(hwloc_config_prefix[include/private/autogen/config.h])\n    AC_CONFIG_HEADERS(hwloc_config_prefix[include/hwloc/autogen/config.h])\n\n    # What prefix are we using?\n    AC_MSG_CHECKING([for hwloc symbol prefix])\n    AS_IF([test \"$hwloc_symbol_prefix_value\" = \"\"],\n          [AS_IF([test \"$with_hwloc_symbol_prefix\" = \"\"],\n                 [hwloc_symbol_prefix_value=hwloc_],\n                 [hwloc_symbol_prefix_value=$with_hwloc_symbol_prefix])])\n    AC_DEFINE_UNQUOTED(HWLOC_SYM_PREFIX, [$hwloc_symbol_prefix_value],\n                       [The hwloc symbol prefix])\n    # Ensure to [] escape the whole next line so that we can get the\n    # proper tr tokens\n    [hwloc_symbol_prefix_value_caps=\"`echo $hwloc_symbol_prefix_value | tr '[:lower:]' '[:upper:]'`\"]\n    AC_DEFINE_UNQUOTED(HWLOC_SYM_PREFIX_CAPS, [$hwloc_symbol_prefix_value_caps],\n                       [The hwloc symbol prefix in all caps])\n    AC_MSG_RESULT([$hwloc_symbol_prefix_value])\n\n    # Give an easy #define to know if we need to transform all the\n    # hwloc names\n    AH_TEMPLATE([HWLOC_SYM_TRANSFORM], [Whether we need to re-define all the hwloc public symbols or not])\n    AS_IF([test \"$hwloc_symbol_prefix_value\" = \"hwloc_\"],\n          [AC_DEFINE([HWLOC_SYM_TRANSFORM], [0])],\n          [AC_DEFINE([HWLOC_SYM_TRANSFORM], [1])])\n\n    # hwloc 2.0+ requires a C99 compliant compiler\n    AC_PROG_CC_C99\n    # The result of AC_PROG_CC_C99 is stored in ac_cv_prog_cc_c99\n    if test \"x$ac_cv_prog_cc_c99\" = xno ; then\n        AC_MSG_WARN([hwloc requires a C99 compiler])\n        AC_MSG_ERROR([Aborting.])\n    fi\n\n    # GCC specifics.\n    if test \"x$GCC\" = \"xyes\"; then\n        HWLOC_GCC_CFLAGS=\"-Wall -Wmissing-prototypes -Wundef\"\n        HWLOC_GCC_CFLAGS=\"$HWLOC_GCC_CFLAGS -Wpointer-arith -Wcast-align\"\n    fi\n\n    # Enample system extensions for O_DIRECTORY, fdopen, fssl, etc.\n    AH_VERBATIM([USE_HPUX_SYSTEM_EXTENSIONS],\n[/* Enable extensions on HP-UX. */\n#ifndef _HPUX_SOURCE\n# undef _HPUX_SOURCE\n#endif\n])\n    AC_DEFINE([_HPUX_SOURCE], [1], [Are we building for HP-UX?])\n\n    AC_LANG_PUSH([C])\n\n    # Check to see if we're producing a 32 or 64 bit executable by\n    # checking the sizeof void*.  Note that AC CHECK_SIZEOF even works\n    # when cross compiling (!), according to the AC 2.64 docs.  This\n    # check is needed because on some systems, you can instruct the\n    # compiler to specifically build 32 or 64 bit executables -- even\n    # though the $target may indicate something different.\n    AC_CHECK_SIZEOF([void *])\n\n    #\n    # List of components to be built, either statically or dynamically.\n    # To be enlarged below.\n    #\n    hwloc_components=\"noos xml synthetic xml_nolibxml\"\n\n    #\n    # Check OS support\n    #\n    AC_MSG_CHECKING([which OS support to include])\n    case ${target} in\n      powerpc64-bgq-linux*) # must be before Linux\n\tAC_DEFINE(HWLOC_BGQ_SYS, 1, [Define to 1 on BlueGene/Q])\n\thwloc_bgq=yes\n\tAC_MSG_RESULT([bgq])\n\thwloc_components=\"$hwloc_components bgq\"\n\t;;\n      *-*-linux*)\n        AC_DEFINE(HWLOC_LINUX_SYS, 1, [Define to 1 on Linux])\n        hwloc_linux=yes\n        AC_MSG_RESULT([Linux])\n        hwloc_components=\"$hwloc_components linux\"\n        if test \"x$enable_io\" != xno; then\n\t  hwloc_components=\"$hwloc_components linuxio\"\n\t  AC_DEFINE(HWLOC_HAVE_LINUXIO, 1, [Define to 1 if building the Linux I/O component])\n\t  hwloc_linuxio_happy=yes\n\t  if test x$enable_pci != xno; then\n\t    AC_DEFINE(HWLOC_HAVE_LINUXPCI, 1, [Define to 1 if enabling Linux-specific PCI discovery in the Linux I/O component])\n\t    hwloc_linuxpci_happy=yes\n\t  fi\n\tfi\n        ;;\n      *-*-irix*)\n        AC_DEFINE(HWLOC_IRIX_SYS, 1, [Define to 1 on Irix])\n        hwloc_irix=yes\n        AC_MSG_RESULT([IRIX])\n        # no irix component yet\n        ;;\n      *-*-darwin*)\n        AC_DEFINE(HWLOC_DARWIN_SYS, 1, [Define to 1 on Darwin])\n        hwloc_darwin=yes\n        AC_MSG_RESULT([Darwin])\n        hwloc_components=\"$hwloc_components darwin\"\n        ;;\n      *-*-solaris*)\n        AC_DEFINE(HWLOC_SOLARIS_SYS, 1, [Define to 1 on Solaris])\n        hwloc_solaris=yes\n        AC_MSG_RESULT([Solaris])\n        hwloc_components=\"$hwloc_components solaris\"\n        ;;\n      *-*-aix*)\n        AC_DEFINE(HWLOC_AIX_SYS, 1, [Define to 1 on AIX])\n        hwloc_aix=yes\n        AC_MSG_RESULT([AIX])\n        hwloc_components=\"$hwloc_components aix\"\n        ;;\n      *-*-hpux*)\n        AC_DEFINE(HWLOC_HPUX_SYS, 1, [Define to 1 on HP-UX])\n        hwloc_hpux=yes\n        AC_MSG_RESULT([HP-UX])\n        hwloc_components=\"$hwloc_components hpux\"\n        ;;\n      *-*-mingw*|*-*-cygwin*)\n        AC_DEFINE(HWLOC_WIN_SYS, 1, [Define to 1 on WINDOWS])\n        hwloc_windows=yes\n        AC_MSG_RESULT([Windows])\n        hwloc_components=\"$hwloc_components windows\"\n        ;;\n      *-*-*freebsd*)\n        AC_DEFINE(HWLOC_FREEBSD_SYS, 1, [Define to 1 on *FREEBSD])\n        hwloc_freebsd=yes\n        AC_MSG_RESULT([FreeBSD])\n        hwloc_components=\"$hwloc_components freebsd\"\n        ;;\n      *-*-*netbsd*)\n        AC_DEFINE(HWLOC_NETBSD_SYS, 1, [Define to 1 on *NETBSD])\n        hwloc_netbsd=yes\n        AC_MSG_RESULT([NetBSD])\n        hwloc_components=\"$hwloc_components netbsd\"\n        ;;\n      *)\n        AC_MSG_RESULT([Unsupported! ($target)])\n        AC_DEFINE(HWLOC_UNSUPPORTED_SYS, 1, [Define to 1 on unsupported systems])\n        AC_MSG_WARN([***********************************************************])\n        AC_MSG_WARN([*** hwloc does not support this system.])\n        AC_MSG_WARN([*** hwloc will *attempt* to build (but it may not work).])\n        AC_MSG_WARN([*** hwloc run-time results may be reduced to showing just one processor,])\n        AC_MSG_WARN([*** and binding will not be supported.])\n        AC_MSG_WARN([*** You have been warned.])\n        AC_MSG_WARN([*** Pausing to give you time to read this message...])\n        AC_MSG_WARN([***********************************************************])\n        sleep 10\n        ;;\n    esac\n\n    #\n    # Check CPU support\n    #\n    AC_MSG_CHECKING([which CPU support to include])\n    case ${target} in\n      i*86-*-*|x86_64-*-*|amd64-*-*)\n        case ${ac_cv_sizeof_void_p} in\n          4)\n            AC_DEFINE(HWLOC_X86_32_ARCH, 1, [Define to 1 on x86_32])\n            hwloc_x86_32=yes\n\t    HWLOC_MS_LIB_ARCH=X86\n            AC_MSG_RESULT([x86_32])\n            ;;\n          8)\n            AC_DEFINE(HWLOC_X86_64_ARCH, 1, [Define to 1 on x86_64])\n            hwloc_x86_64=yes\n\t    HWLOC_MS_LIB_ARCH=X64\n            AC_MSG_RESULT([x86_64])\n            ;;\n          *)\n            AC_DEFINE(HWLOC_X86_64_ARCH, 1, [Define to 1 on x86_64])\n            hwloc_x86_64=yes\n\t    HWLOC_MS_LIB_ARCH=X64\n            AC_MSG_RESULT([unknown -- assuming x86_64])\n            ;;\n        esac\n        ;;\n      *)\n        AC_MSG_RESULT([unknown])\n        ;;\n    esac\n    AC_SUBST(HWLOC_MS_LIB_ARCH)\n\n    AC_CHECK_SIZEOF([unsigned long])\n    AC_DEFINE_UNQUOTED([HWLOC_SIZEOF_UNSIGNED_LONG], $ac_cv_sizeof_unsigned_long, [The size of `unsigned long', as computed by sizeof])\n    AC_CHECK_SIZEOF([unsigned int])\n    AC_DEFINE_UNQUOTED([HWLOC_SIZEOF_UNSIGNED_INT], $ac_cv_sizeof_unsigned_int, [The size of `unsigned int', as computed by sizeof])\n\n    #\n    # Check for compiler attributes and visibility\n    #\n    _HWLOC_C_COMPILER_VENDOR([hwloc_c_vendor])\n    _HWLOC_CHECK_ATTRIBUTES\n    _HWLOC_CHECK_VISIBILITY\n    HWLOC_CFLAGS=\"$HWLOC_FLAGS $HWLOC_VISIBILITY_CFLAGS\"\n    AS_IF([test \"$HWLOC_VISIBILITY_CFLAGS\" != \"\"],\n          [AC_MSG_WARN([\"$HWLOC_VISIBILITY_CFLAGS\" has been added to the hwloc CFLAGS])])\n\n    # Make sure the compiler returns an error code when function arg\n    # count is wrong, otherwise sched_setaffinity checks may fail.\n    HWLOC_STRICT_ARGS_CFLAGS=\n    hwloc_args_check=0\n    AC_MSG_CHECKING([whether the C compiler rejects function calls with too many arguments])\n    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n        extern int one_arg(int x);\n        int foo(void) { return one_arg(1, 2); }\n      ]])],\n      [AC_MSG_RESULT([no])],\n      [hwloc_args_check=1\n       AC_MSG_RESULT([yes])])\n    AC_MSG_CHECKING([whether the C compiler rejects function calls with too few arguments])\n    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n        extern int two_arg(int x, int y);\n        int foo(void) { return two_arg(3); }\n      ]])],\n      [AC_MSG_RESULT([no])],\n      [hwloc_args_check=`expr $hwloc_args_check + 1`\n       AC_MSG_RESULT([yes])])\n    AS_IF([test \"$hwloc_args_check\" != \"2\"],[\n         AC_MSG_WARN([Your C compiler does not consider incorrect argument counts to be a fatal error.])\n        case \"$hwloc_c_vendor\" in\n        ibm)\n            HWLOC_STRICT_ARGS_CFLAGS=\"-qhalt=e\"\n            ;;\n        intel)\n            HWLOC_STRICT_ARGS_CFLAGS=\"-we140\"\n            ;;\n        *)\n            HWLOC_STRICT_ARGS_CFLAGS=FAIL\n            AC_MSG_WARN([Please report this warning and configure using a different C compiler if possible.])\n            ;;\n        esac\n        AS_IF([test \"$HWLOC_STRICT_ARGS_CFLAGS\" != \"FAIL\"],[\n            AC_MSG_WARN([Configure will append '$HWLOC_STRICT_ARGS_CFLAGS' to the value of CFLAGS when needed.])\n             AC_MSG_WARN([Alternatively you may configure with a different compiler.])\n        ])\n    ])\n\n    #\n    # Now detect support\n    #\n\n    AC_CHECK_HEADERS([unistd.h])\n    AC_CHECK_HEADERS([dirent.h])\n    AC_CHECK_HEADERS([strings.h])\n    AC_CHECK_HEADERS([ctype.h])\n\n    AC_CHECK_FUNCS([strcasecmp], [\n      _HWLOC_CHECK_DECL([strcasecmp], [\n\tAC_DEFINE([HWLOC_HAVE_DECL_STRCASECMP], [1], [Define to 1 if function `strcasecmp' is declared by system headers])\n      ])\n    ])\n    AC_CHECK_FUNCS([strncasecmp], [\n      _HWLOC_CHECK_DECL([strncasecmp], [\n\tAC_DEFINE([HWLOC_HAVE_DECL_STRNCASECMP], [1], [Define to 1 if function `strncasecmp' is declared by system headers])\n      ])\n    ])\n\n    AC_CHECK_FUNCS([strftime])\n    AC_CHECK_FUNCS([setlocale])\n\n    AC_CHECK_HEADER([stdint.h], [\n      AC_DEFINE([HWLOC_HAVE_STDINT_H], [1], [Define to 1 if you have the <stdint.h> header file.])\n    ])\n    AC_CHECK_HEADERS([sys/mman.h])\n\n    old_CPPFLAGS=\"$CPPFLAGS\"\n    CPPFLAGS=\"$CPPFLAGS -D_WIN32_WINNT=0x0601\"\n    AC_CHECK_TYPES([KAFFINITY,\n                    PROCESSOR_CACHE_TYPE,\n                    CACHE_DESCRIPTOR,\n                    LOGICAL_PROCESSOR_RELATIONSHIP,\n                    RelationProcessorPackage,\n                    SYSTEM_LOGICAL_PROCESSOR_INFORMATION,\n                    GROUP_AFFINITY,\n                    PROCESSOR_RELATIONSHIP,\n                    NUMA_NODE_RELATIONSHIP,\n                    CACHE_RELATIONSHIP,\n                    PROCESSOR_GROUP_INFO,\n                    GROUP_RELATIONSHIP,\n                    SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX,\n\t\t    PSAPI_WORKING_SET_EX_BLOCK,\n\t\t    PSAPI_WORKING_SET_EX_INFORMATION,\n\t\t    PROCESSOR_NUMBER],\n                    [],[],[[#include <windows.h>]])\n    CPPFLAGS=\"$old_CPPFLAGS\"\n    AC_CHECK_LIB([gdi32], [main],\n                 [HWLOC_LIBS=\"-lgdi32 $HWLOC_LIBS\"\n                  AC_DEFINE([HAVE_LIBGDI32], 1, [Define to 1 if we have -lgdi32])])\n    AC_CHECK_LIB([user32], [PostQuitMessage], [hwloc_have_user32=\"yes\"])\n\n    AC_CHECK_HEADER([windows.h], [\n      AC_DEFINE([HWLOC_HAVE_WINDOWS_H], [1], [Define to 1 if you have the `windows.h' header.])\n    ])\n\n    AC_CHECK_HEADERS([sys/lgrp_user.h], [\n      AC_CHECK_LIB([lgrp], [lgrp_init],\n                   [HWLOC_LIBS=\"-llgrp $HWLOC_LIBS\"\n                    AC_DEFINE([HAVE_LIBLGRP], 1, [Define to 1 if we have -llgrp])\n                    AC_CHECK_DECLS([lgrp_latency_cookie],,,[[#include <sys/lgrp_user.h>]])\n      ])\n    ])\n    AC_CHECK_HEADERS([kstat.h], [\n      AC_CHECK_LIB([kstat], [main],\n                   [HWLOC_LIBS=\"-lkstat $HWLOC_LIBS\"\n                    AC_DEFINE([HAVE_LIBKSTAT], 1, [Define to 1 if we have -lkstat])])\n    ])\n\n    AC_CHECK_DECLS([fabsf], [\n      AC_CHECK_LIB([m], [fabsf],\n                   [need_libm=yes])\n    ], [], [[#include <math.h>]])\n    AC_CHECK_DECLS([modff], [\n      AC_CHECK_LIB([m], [modff],\n                   [need_libm=yes])\n    ], [], [[#include <math.h>]])\n    if test x$need_libm = xyes; then\n      HWLOC_LIBS=\"-lm $HWLOC_LIBS\"\n    fi\n\n    AC_CHECK_HEADERS([picl.h], [\n      AC_CHECK_LIB([picl], [picl_initialize],\n                   [HWLOC_LIBS=\"-lpicl $HWLOC_LIBS\"])])\n\n    AC_CHECK_DECLS([_SC_NPROCESSORS_ONLN,\n    \t\t_SC_NPROCESSORS_CONF,\n    \t\t_SC_NPROC_ONLN,\n    \t\t_SC_NPROC_CONF,\n    \t\t_SC_PAGESIZE,\n    \t\t_SC_PAGE_SIZE,\n    \t\t_SC_LARGE_PAGESIZE],,[:],[[#include <unistd.h>]])\n\n    AC_HAVE_HEADERS([mach/mach_host.h])\n    AC_HAVE_HEADERS([mach/mach_init.h], [\n      AC_CHECK_FUNCS([host_info])\n    ])\n\n    AC_CHECK_DECLS([strtoull], [], [AC_CHECK_FUNCS([strtoull])], [AC_INCLUDES_DEFAULT])\n\n    # Needed for Windows in private/misc.h\n    AC_CHECK_TYPES([ssize_t])\n    AC_CHECK_DECLS([snprintf], [], [], [AC_INCLUDES_DEFAULT])\n    # strdup and putenv are declared in windows headers but marked deprecated\n    AC_CHECK_DECLS([_strdup], [], [], [AC_INCLUDES_DEFAULT])\n    AC_CHECK_DECLS([_putenv], [], [], [AC_INCLUDES_DEFAULT])\n    # Could add mkdir and access for hwloc-gather-cpuid.c on Windows\n\n    if test \"x$hwloc_linux\" != \"xyes\" ; then\n      # Don't look for sys/sysctl.h on Linux because it's deprecated and\n      # generates a warning in GCC10. Also it's unneeded.\n      AC_CHECK_HEADERS([sys/param.h])\n      AC_CHECK_HEADERS([sys/sysctl.h], [\n        AC_CHECK_DECLS([CTL_HW, HW_NCPU],,,[[\n        #if HAVE_SYS_PARAM_H\n        #include <sys/param.h>\n        #endif\n        #include <sys/sysctl.h>\n        ]])\n      ],,[\n        AC_INCLUDES_DEFAULT\n        #if HAVE_SYS_PARAM_H\n        #include <sys/param.h>\n        #endif\n      ])\n\n      # Don't detect sysctl* on Linux because its sysctl() syscall is\n      # long deprecated and unneeded. Some libc still expose the symbol\n      # and raise a big warning at link time.\n\n      # Do a full link test instead of just using AC_CHECK_FUNCS, which\n      # just checks to see if the symbol exists or not.  For example,\n      # the prototype of sysctl uses u_int, which on some platforms\n      # (such as FreeBSD) is only defined under __BSD_VISIBLE, __USE_BSD\n      # or other similar definitions.  So while the symbols \"sysctl\" and\n      # \"sysctlbyname\" might still be available in libc (which autoconf\n      # checks for), they might not be actually usable.\n      AC_MSG_CHECKING([for sysctl])\n      AC_TRY_LINK([\n                 #include <stdio.h>\n                 #include <sys/types.h>\n                 #include <sys/sysctl.h>\n                 ],\n                  [return sysctl(NULL,0,NULL,NULL,NULL,0);],\n                  [AC_DEFINE([HAVE_SYSCTL],[1],[Define to '1' if sysctl is present and usable])\n                   AC_MSG_RESULT(yes)],\n                  [AC_MSG_RESULT(no)])\n      AC_MSG_CHECKING([for sysctlbyname])\n      AC_TRY_LINK([\n                 #include <stdio.h>\n                 #include <sys/types.h>\n                 #include <sys/sysctl.h>\n                 ],\n                  [return sysctlbyname(NULL,NULL,NULL,NULL,0);],\n                  [AC_DEFINE([HAVE_SYSCTLBYNAME],[1],[Define to '1' if sysctlbyname is present and usable])\n                   AC_MSG_RESULT(yes)],\n                  [AC_MSG_RESULT(no)])\n    fi\n\n    AC_CHECK_DECLS([getprogname], [], [], [AC_INCLUDES_DEFAULT])\n    AC_CHECK_DECLS([getexecname], [], [], [AC_INCLUDES_DEFAULT])\n    AC_CHECK_DECLS([GetModuleFileName], [], [], [#include <windows.h>])\n    # program_invocation_name and __progname may be available but not exported in headers\n    AC_MSG_CHECKING([for program_invocation_name])\n    AC_TRY_LINK([\n\t\t#ifndef _GNU_SOURCE\n\t\t# define _GNU_SOURCE\n\t\t#endif\n\t\t#include <errno.h>\n\t\t#include <stdio.h>\n\t\textern char *program_invocation_name;\n\t\t],[\n\t\treturn printf(\"%s\\n\", program_invocation_name);\n\t\t],\n\t\t[AC_DEFINE([HAVE_PROGRAM_INVOCATION_NAME], [1], [Define to '1' if program_invocation_name is present and usable])\n\t\t AC_MSG_RESULT([yes])\n\t\t],[AC_MSG_RESULT([no])])\n    AC_MSG_CHECKING([for __progname])\n    AC_TRY_LINK([\n\t\t#include <stdio.h>\n\t\textern char *__progname;\n\t\t],[\n\t\treturn printf(\"%s\\n\", __progname);\n\t\t],\n\t\t[AC_DEFINE([HAVE___PROGNAME], [1], [Define to '1' if __progname is present and usable])\n\t\t AC_MSG_RESULT([yes])\n\t\t],[AC_MSG_RESULT([no])])\n\n    case ${target} in\n      *-*-mingw*|*-*-cygwin*)\n        hwloc_pid_t=HANDLE\n        hwloc_thread_t=HANDLE\n        ;;\n      *)\n        hwloc_pid_t=pid_t\n        AC_CHECK_TYPES([pthread_t], [hwloc_thread_t=pthread_t], [:], [[#include <pthread.h>]])\n        ;;\n    esac\n    AC_DEFINE_UNQUOTED(hwloc_pid_t, $hwloc_pid_t, [Define this to the process ID type])\n    if test \"x$hwloc_thread_t\" != \"x\" ; then\n      AC_DEFINE_UNQUOTED(hwloc_thread_t, $hwloc_thread_t, [Define this to the thread ID type])\n    fi\n\n    AC_CHECK_DECLS([sched_getcpu],,[:],[[\n      #ifndef _GNU_SOURCE\n      # define _GNU_SOURCE\n      #endif\n      #include <sched.h>\n    ]])\n\n    _HWLOC_CHECK_DECL([sched_setaffinity], [\n      AC_DEFINE([HWLOC_HAVE_SCHED_SETAFFINITY], [1], [Define to 1 if glibc provides a prototype of sched_setaffinity()])\n      AS_IF([test \"$HWLOC_STRICT_ARGS_CFLAGS\" = \"FAIL\"],[\n        AC_MSG_WARN([Support for sched_setaffinity() requires a C compiler which])\n        AC_MSG_WARN([considers incorrect argument counts to be a fatal error.])\n        AC_MSG_ERROR([Cannot continue.])\n      ])\n      AC_MSG_CHECKING([for old prototype of sched_setaffinity])\n      hwloc_save_CFLAGS=$CFLAGS\n      CFLAGS=\"$CFLAGS $HWLOC_STRICT_ARGS_CFLAGS\"\n      AC_COMPILE_IFELSE([\n          AC_LANG_PROGRAM([[\n              #ifndef _GNU_SOURCE\n              # define _GNU_SOURCE\n              #endif\n              #include <sched.h>\n              static unsigned long mask;\n              ]], [[ sched_setaffinity(0, (void*) &mask); ]])],\n          [AC_DEFINE([HWLOC_HAVE_OLD_SCHED_SETAFFINITY], [1], [Define to 1 if glibc provides the old prototype (without length) of sched_setaffinity()])\n           AC_MSG_RESULT([yes])],\n          [AC_MSG_RESULT([no])])\n      CFLAGS=$hwloc_save_CFLAGS\n    ], , [[\n#ifndef _GNU_SOURCE\n# define _GNU_SOURCE\n#endif\n#include <sched.h>\n]])\n\n    AC_MSG_CHECKING([for working CPU_SET])\n    AC_LINK_IFELSE([\n      AC_LANG_PROGRAM([[\n        #include <sched.h>\n        cpu_set_t set;\n        ]], [[ CPU_ZERO(&set); CPU_SET(0, &set);]])],\n\t[AC_DEFINE([HWLOC_HAVE_CPU_SET], [1], [Define to 1 if the CPU_SET macro works])\n         AC_MSG_RESULT([yes])],\n        [AC_MSG_RESULT([no])])\n\n    AC_MSG_CHECKING([for working CPU_SET_S])\n    AC_LINK_IFELSE([\n      AC_LANG_PROGRAM([[\n          #include <sched.h>\n          cpu_set_t *set;\n        ]], [[\n          set = CPU_ALLOC(1024);\n          CPU_ZERO_S(CPU_ALLOC_SIZE(1024), set);\n          CPU_SET_S(CPU_ALLOC_SIZE(1024), 0, set);\n          CPU_FREE(set);\n        ]])],\n        [AC_DEFINE([HWLOC_HAVE_CPU_SET_S], [1], [Define to 1 if the CPU_SET_S macro works])\n         AC_MSG_RESULT([yes])],\n        [AC_MSG_RESULT([no])])\n\n    AC_MSG_CHECKING([for working syscall with 6 parameters])\n    AC_LINK_IFELSE([\n      AC_LANG_PROGRAM([[\n          #include <unistd.h>\n          #include <sys/syscall.h>\n          ]], [[syscall(0, 1, 2, 3, 4, 5, 6);]])],\n        [AC_DEFINE([HWLOC_HAVE_SYSCALL], [1], [Define to 1 if function `syscall' is available with 6 parameters])\n         AC_MSG_RESULT([yes])],\n        [AC_MSG_RESULT([no])])\n\n    AC_PATH_PROGS([HWLOC_MS_LIB], [lib])\n    AC_ARG_VAR([HWLOC_MS_LIB], [Path to Microsoft's Visual Studio `lib' tool])\n\n    AC_PATH_PROG([BASH], [bash])\n\n    AC_CHECK_FUNCS([ffs], [\n      _HWLOC_CHECK_DECL([ffs],[\n        AC_DEFINE([HWLOC_HAVE_DECL_FFS], [1], [Define to 1 if function `ffs' is declared by system headers])\n      ])\n      AC_DEFINE([HWLOC_HAVE_FFS], [1], [Define to 1 if you have the `ffs' function.])\n      if ( $CC --version | grep gccfss ) >/dev/null 2>&1 ; then\n        dnl May be broken due to\n        dnl    https://forums.oracle.com/forums/thread.jspa?threadID=1997328\n        dnl TODO: a more selective test, since bug may be version dependent.\n        dnl We can't use AC_TRY_LINK because the failure does not appear until\n        dnl run/load time and there is currently no precedent for AC_TRY_RUN\n        dnl use in hwloc.  --PHH\n        dnl For now, we're going with \"all gccfss compilers are broken\".\n        dnl Better to be safe and correct; it's not like this is\n        dnl performance-critical code, after all.\n        AC_DEFINE([HWLOC_HAVE_BROKEN_FFS], [1],\n                  [Define to 1 if your `ffs' function is known to be broken.])\n      fi\n    ])\n    AC_CHECK_FUNCS([ffsl], [\n      _HWLOC_CHECK_DECL([ffsl],[\n        AC_DEFINE([HWLOC_HAVE_DECL_FFSL], [1], [Define to 1 if function `ffsl' is declared by system headers])\n      ])\n      AC_DEFINE([HWLOC_HAVE_FFSL], [1], [Define to 1 if you have the `ffsl' function.])\n    ])\n\n    AC_CHECK_FUNCS([fls], [\n      _HWLOC_CHECK_DECL([fls],[\n        AC_DEFINE([HWLOC_HAVE_DECL_FLS], [1], [Define to 1 if function `fls' is declared by system headers])\n      ])\n      AC_DEFINE([HWLOC_HAVE_FLS], [1], [Define to 1 if you have the `fls' function.])\n    ])\n    AC_CHECK_FUNCS([flsl], [\n      _HWLOC_CHECK_DECL([flsl],[\n        AC_DEFINE([HWLOC_HAVE_DECL_FLSL], [1], [Define to 1 if function `flsl' is declared by system headers])\n      ])\n      AC_DEFINE([HWLOC_HAVE_FLSL], [1], [Define to 1 if you have the `flsl' function.])\n    ])\n\n    AC_CHECK_FUNCS([clz], [\n      _HWLOC_CHECK_DECL([clz],[\n        AC_DEFINE([HWLOC_HAVE_DECL_CLZ], [1], [Define to 1 if function `clz' is declared by system headers])\n      ])\n      AC_DEFINE([HWLOC_HAVE_CLZ], [1], [Define to 1 if you have the `clz' function.])\n    ])\n    AC_CHECK_FUNCS([clzl], [\n      _HWLOC_CHECK_DECL([clzl],[\n        AC_DEFINE([HWLOC_HAVE_DECL_CLZL], [1], [Define to 1 if function `clzl' is declared by system headers])\n      ])\n      AC_DEFINE([HWLOC_HAVE_CLZL], [1], [Define to 1 if you have the `clzl' function.])\n    ])\n\n    AS_IF([test \"$hwloc_c_vendor\" != \"android\"], [AC_CHECK_FUNCS([openat], [hwloc_have_openat=yes])])\n\n\n    AC_CHECK_HEADERS([malloc.h])\n    AC_CHECK_FUNCS([getpagesize memalign posix_memalign])\n\n    AC_CHECK_HEADERS([sys/utsname.h])\n    AC_CHECK_FUNCS([uname])\n\n    dnl Don't check for valgrind in embedded mode because this may conflict\n    dnl with the embedder projects also checking for it.\n    dnl We only use Valgrind to nicely disable the x86 backend with a warning,\n    dnl but we can live without it in embedded mode (it auto-disables itself\n    dnl because of invalid CPUID outputs).\n    dnl Non-embedded checks usually go to hwloc_internal.m4 but this one is\n    dnl is really for the core library.\n    AS_IF([test \"$hwloc_mode\" != \"embedded\"],\n        [AC_CHECK_HEADERS([valgrind/valgrind.h])\n         AC_CHECK_DECLS([RUNNING_ON_VALGRIND],,[:],[[#include <valgrind/valgrind.h>]])\n\t],[\n\t AC_DEFINE([HAVE_DECL_RUNNING_ON_VALGRIND], [0], [Embedded mode; just assume we do not have Valgrind support])\n\t])\n\n    AC_CHECK_HEADERS([pthread_np.h])\n    AC_CHECK_DECLS([pthread_setaffinity_np],,[:],[[\n      #include <pthread.h>\n      #ifdef HAVE_PTHREAD_NP_H\n      #  include <pthread_np.h>\n      #endif\n    ]])\n    AC_CHECK_DECLS([pthread_getaffinity_np],,[:],[[\n      #include <pthread.h>\n      #ifdef HAVE_PTHREAD_NP_H\n      #  include <pthread_np.h>\n      #endif\n    ]])\n    AC_CHECK_FUNC([sched_setaffinity], [hwloc_have_sched_setaffinity=yes])\n    AC_CHECK_HEADERS([sys/cpuset.h],,,[[#include <sys/param.h>]])\n    AC_CHECK_FUNCS([cpuset_setaffinity])\n    AC_SEARCH_LIBS([pthread_getthrds_np], [pthread],\n      AC_DEFINE([HWLOC_HAVE_PTHREAD_GETTHRDS_NP], 1, `Define to 1 if you have pthread_getthrds_np')\n    )\n    AC_CHECK_FUNCS([cpuset_setid])\n\n    # Linux libudev support\n    if test \"x$enable_libudev\" != xno; then\n      AC_CHECK_HEADERS([libudev.h], [\n\tAC_CHECK_LIB([udev], [udev_device_new_from_subsystem_sysname], [\n\t  HWLOC_LIBS=\"$HWLOC_LIBS -ludev\"\n\t  AC_DEFINE([HWLOC_HAVE_LIBUDEV], [1], [Define to 1 if you have libudev.])\n\t])\n      ])\n    fi\n\n    # PCI support via libpciaccess.  NOTE: we do not support\n    # libpci/pciutils because that library is GPL and is incompatible\n    # with our BSD license.\n    hwloc_pciaccess_happy=no\n    if test \"x$enable_io\" != xno && test \"x$enable_pci\" != xno; then\n      hwloc_pciaccess_happy=yes\n      HWLOC_PKG_CHECK_MODULES([PCIACCESS], [pciaccess], [pci_slot_match_iterator_create], [pciaccess.h], [:], [hwloc_pciaccess_happy=no])\n\n      # Only add the REQUIRES if we got pciaccess through pkg-config.\n      # Otherwise we don't know if pciaccess.pc is installed\n      AS_IF([test \"$hwloc_pciaccess_happy\" = \"yes\"], [HWLOC_PCIACCESS_REQUIRES=pciaccess])\n\n      # Just for giggles, if we didn't find a pciaccess pkg-config,\n      # just try looking for its header file and library.\n      AS_IF([test \"$hwloc_pciaccess_happy\" != \"yes\"],\n         [AC_CHECK_HEADER([pciaccess.h],\n              [AC_CHECK_LIB([pciaccess], [pci_slot_match_iterator_create],\n                   [hwloc_pciaccess_happy=yes\n                    HWLOC_PCIACCESS_LIBS=\"-lpciaccess\"])\n              ])\n         ])\n\n      AS_IF([test \"$hwloc_pciaccess_happy\" = \"yes\"],\n         [hwloc_components=\"$hwloc_components pci\"\n          hwloc_pci_component_maybeplugin=1])\n    fi\n    # If we asked for pci support but couldn't deliver, fail\n    AS_IF([test \"$enable_pci\" = \"yes\" -a \"$hwloc_pciaccess_happy\" = \"no\"],\n          [AC_MSG_WARN([Specified --enable-pci switch, but could not])\n           AC_MSG_WARN([find appropriate support])\n           AC_MSG_ERROR([Cannot continue])])\n    # don't add LIBS/CFLAGS/REQUIRES yet, depends on plugins\n\n    # OpenCL support\n    hwloc_opencl_happy=no\n    if test \"x$enable_io\" != xno && test \"x$enable_opencl\" != \"xno\"; then\n      hwloc_opencl_happy=yes\n      case ${target} in\n      *-*-darwin*)\n        # On Darwin, only use the OpenCL framework\n        AC_CHECK_HEADERS([OpenCL/cl_ext.h], [\n\t  AC_MSG_CHECKING([for the OpenCL framework])\n          tmp_save_LDFLAGS=\"$LDFLAGS\"\n          LDFLAGS=\"$LDFLAGS -framework OpenCL\"\n\t  AC_LINK_IFELSE([\n            AC_LANG_PROGRAM([[\n#include <OpenCL/opencl.h>\n            ]], [[\nreturn clGetDeviceIDs(0, 0, 0, NULL, NULL);\n            ]])],\n          [AC_MSG_RESULT(yes)\n\t   HWLOC_OPENCL_LDFLAGS=\"-framework OpenCL\"],\n\t  [AC_MSG_RESULT(no)\n\t   hwloc_opencl_happy=no])\n          LDFLAGS=\"$tmp_save_LDFLAGS\"\n        ], [hwloc_opencl_happy=no])\n      ;;\n      *)\n        # On Others, look for OpenCL at normal locations\n        AC_CHECK_HEADERS([CL/cl_ext.h], [\n\t  AC_CHECK_LIB([OpenCL], [clGetDeviceIDs], [HWLOC_OPENCL_LIBS=\"-lOpenCL\"], [hwloc_opencl_happy=no])\n        ], [hwloc_opencl_happy=no])\n      ;;\n      esac\n    fi\n    AC_SUBST(HWLOC_OPENCL_CFLAGS)\n    AC_SUBST(HWLOC_OPENCL_LIBS)\n    AC_SUBST(HWLOC_OPENCL_LDFLAGS)\n    # If we asked for opencl support but couldn't deliver, fail\n    AS_IF([test \"$enable_opencl\" = \"yes\" -a \"$hwloc_opencl_happy\" = \"no\"],\n          [AC_MSG_WARN([Specified --enable-opencl switch, but could not])\n           AC_MSG_WARN([find appropriate support])\n           AC_MSG_ERROR([Cannot continue])])\n    if test \"x$hwloc_opencl_happy\" = \"xyes\"; then\n      AC_DEFINE([HWLOC_HAVE_OPENCL], [1], [Define to 1 if you have the `OpenCL' library.])\n      AC_SUBST([HWLOC_HAVE_OPENCL], [1])\n      hwloc_components=\"$hwloc_components opencl\"\n      hwloc_opencl_component_maybeplugin=1\n    else\n      AC_SUBST([HWLOC_HAVE_OPENCL], [0])\n    fi\n    # don't add LIBS/CFLAGS/REQUIRES yet, depends on plugins\n\n    # CUDA support\n    hwloc_have_cuda=no\n    hwloc_have_cudart=no\n    if test \"x$enable_io\" != xno && test \"x$enable_cuda\" != \"xno\"; then\n      AC_CHECK_HEADERS([cuda.h], [\n        AC_MSG_CHECKING(if CUDA_VERSION >= 3020)\n        AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#include <cuda.h>\n#ifndef CUDA_VERSION\n#error CUDA_VERSION undefined\n#elif CUDA_VERSION < 3020\n#error CUDA_VERSION too old\n#endif]], [[int i = 3;]])],\n         [AC_MSG_RESULT(yes)\n          AC_CHECK_LIB([cuda], [cuInit],\n                       [AC_DEFINE([HAVE_CUDA], 1, [Define to 1 if we have -lcuda])\n                        hwloc_have_cuda=yes])],\n         [AC_MSG_RESULT(no)])])\n\n      AC_CHECK_HEADERS([cuda_runtime_api.h], [\n        AC_MSG_CHECKING(if CUDART_VERSION >= 3020)\n        AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#include <cuda_runtime_api.h>\n#ifndef CUDART_VERSION\n#error CUDART_VERSION undefined\n#elif CUDART_VERSION < 3020\n#error CUDART_VERSION too old\n#endif]], [[int i = 3;]])],\n         [AC_MSG_RESULT(yes)\n          AC_CHECK_LIB([cudart], [cudaGetDeviceProperties], [\n            HWLOC_CUDA_LIBS=\"-lcudart\"\n            AC_SUBST(HWLOC_CUDA_LIBS)\n            hwloc_have_cudart=yes\n            AC_DEFINE([HWLOC_HAVE_CUDART], [1], [Define to 1 if you have the `cudart' SDK.])\n          ])\n        ])\n      ])\n\n      AS_IF([test \"$enable_cuda\" = \"yes\" -a \"$hwloc_have_cudart\" = \"no\"],\n            [AC_MSG_WARN([Specified --enable-cuda switch, but could not])\n             AC_MSG_WARN([find appropriate support])\n             AC_MSG_ERROR([Cannot continue])])\n\n      if test \"x$hwloc_have_cudart\" = \"xyes\"; then\n\thwloc_components=\"$hwloc_components cuda\"\n        hwloc_cuda_component_maybeplugin=1\n      fi\n    fi\n    # don't add LIBS/CFLAGS yet, depends on plugins\n\n    # NVML support\n    hwloc_nvml_happy=no\n    if test \"x$enable_io\" != xno && test \"x$enable_nvml\" != \"xno\"; then\n\thwloc_nvml_happy=yes\n\tAC_CHECK_HEADERS([nvml.h], [\n\t  AC_CHECK_LIB([nvidia-ml], [nvmlInit], [HWLOC_NVML_LIBS=\"-lnvidia-ml\"], [hwloc_nvml_happy=no])\n        ], [hwloc_nvml_happy=no])\n    fi\n    if test \"x$hwloc_nvml_happy\" = \"xyes\"; then\n      tmp_save_CFLAGS=\"$CFLAGS\"\n      CFLAGS=\"$CFLAGS $HWLOC_NVML_CFLAGS\"\n      tmp_save_LIBS=\"$LIBS\"\n      LIBS=\"$LIBS $HWLOC_NVML_LIBS\"\n      AC_CHECK_DECLS([nvmlDeviceGetMaxPcieLinkGeneration],,[:],[[#include <nvml.h>]])\n      CFLAGS=\"$tmp_save_CFLAGS\"\n      LIBS=\"$tmp_save_LIBS\"\n    fi\n    AC_SUBST(HWLOC_NVML_LIBS)\n    # If we asked for nvml support but couldn't deliver, fail\n    AS_IF([test \"$enable_nvml\" = \"yes\" -a \"$hwloc_nvml_happy\" = \"no\"],\n\t  [AC_MSG_WARN([Specified --enable-nvml switch, but could not])\n\t   AC_MSG_WARN([find appropriate support])\n\t   AC_MSG_ERROR([Cannot continue])])\n    if test \"x$hwloc_nvml_happy\" = \"xyes\"; then\n      AC_DEFINE([HWLOC_HAVE_NVML], [1], [Define to 1 if you have the `NVML' library.])\n      AC_SUBST([HWLOC_HAVE_NVML], [1])\n      hwloc_components=\"$hwloc_components nvml\"\n      hwloc_nvml_component_maybeplugin=1\n    else\n      AC_SUBST([HWLOC_HAVE_NVML], [0])\n    fi\n    # don't add LIBS/CFLAGS/REQUIRES yet, depends on plugins\n\n    # X11 support\n    AC_PATH_XTRA\n\n    CPPFLAGS_save=$CPPFLAGS\n    LIBS_save=$LIBS\n\n    CPPFLAGS=\"$CPPFLAGS $X_CFLAGS\"\n    LIBS=\"$LIBS $X_PRE_LIBS $X_LIBS $X_EXTRA_LIBS\"\n    AC_CHECK_HEADERS([X11/Xlib.h],\n        [AC_CHECK_LIB([X11], [XOpenDisplay],\n            [\n             # the GL backend just needs XOpenDisplay\n             hwloc_enable_X11=yes\n             # lstopo needs more\n             AC_CHECK_HEADERS([X11/Xutil.h],\n                [AC_CHECK_HEADERS([X11/keysym.h],\n                    [AC_DEFINE([HWLOC_HAVE_X11_KEYSYM], [1], [Define to 1 if X11 headers including Xutil.h and keysym.h are available.])\n                     HWLOC_X11_CPPFLAGS=\"$X_CFLAGS\"\n                     AC_SUBST([HWLOC_X11_CPPFLAGS])\n                     HWLOC_X11_LIBS=\"$X_PRE_LIBS $X_LIBS -lX11 $X_EXTRA_LIBS\"\n                     AC_SUBST([HWLOC_X11_LIBS])])\n                ], [], [#include <X11/Xlib.h>])\n            ])\n         ])\n    CPPFLAGS=$CPPFLAGS_save\n    LIBS=$LIBS_save\n\n    # GL Support\n    hwloc_gl_happy=no\n    if test \"x$enable_io\" != xno && test \"x$enable_gl\" != \"xno\"; then\n\thwloc_gl_happy=yes\n\n\tAS_IF([test \"$hwloc_enable_X11\" != \"yes\"],\n              [AC_MSG_WARN([X11 not found; GL disabled])\n               hwloc_gl_happy=no])\n\n        AC_CHECK_HEADERS([NVCtrl/NVCtrl.h], [\n          AC_CHECK_LIB([XNVCtrl], [XNVCTRLQueryTargetAttribute], [:], [hwloc_gl_happy=no], [-lXext])\n        ], [hwloc_gl_happy=no])\n\n        if test \"x$hwloc_gl_happy\" = \"xyes\"; then\n            AC_DEFINE([HWLOC_HAVE_GL], [1], [Define to 1 if you have the GL module components.])\n\t    HWLOC_GL_LIBS=\"-lXNVCtrl -lXext -lX11\"\n\t    AC_SUBST(HWLOC_GL_LIBS)\n\t    # FIXME we actually don't know if xext.pc and x11.pc are installed\n\t    # since we didn't look for Xext and X11 using pkg-config\n\t    HWLOC_GL_REQUIRES=\"xext x11\"\n            hwloc_have_gl=yes\n\t    hwloc_components=\"$hwloc_components gl\"\n\t    hwloc_gl_component_maybeplugin=1\n\telse\n            AS_IF([test \"$enable_gl\" = \"yes\"], [\n                AC_MSG_WARN([Specified --enable-gl switch, but could not])\n                AC_MSG_WARN([find appropriate support])\n                AC_MSG_ERROR([Cannot continue])\n            ])\n        fi\n    fi\n    # don't add LIBS/CFLAGS yet, depends on plugins\n\n    # libxml2 support\n    hwloc_libxml2_happy=\n    if test \"x$enable_libxml2\" != \"xno\"; then\n        HWLOC_PKG_CHECK_MODULES([LIBXML2], [libxml-2.0], [xmlNewDoc], [libxml/parser.h],\n                                [hwloc_libxml2_happy=yes],\n                                [hwloc_libxml2_happy=no])\n    fi\n    if test \"x$hwloc_libxml2_happy\" = \"xyes\"; then\n        HWLOC_LIBXML2_REQUIRES=\"libxml-2.0\"\n        AC_DEFINE([HWLOC_HAVE_LIBXML2], [1], [Define to 1 if you have the `libxml2' library.])\n        AC_SUBST([HWLOC_HAVE_LIBXML2], [1])\n\n        hwloc_components=\"$hwloc_components xml_libxml\"\n        hwloc_xml_libxml_component_maybeplugin=1\n    else\n        AC_SUBST([HWLOC_HAVE_LIBXML2], [0])\n\tAS_IF([test \"$enable_libxml2\" = \"yes\"],\n              [AC_MSG_WARN([--enable-libxml2 requested, but libxml2 was not found])\n               AC_MSG_ERROR([Cannot continue])])\n    fi\n    # don't add LIBS/CFLAGS/REQUIRES yet, depends on plugins\n\n    # Try to compile the x86 cpuid inlines\n    if test \"x$enable_cpuid\" != \"xno\"; then\n\tAC_MSG_CHECKING([for x86 cpuid])\n\told_CPPFLAGS=\"$CPPFLAGS\"\n\tCPPFLAGS=\"$CPPFLAGS -I$HWLOC_top_srcdir/include\"\n\t# We need hwloc_uint64_t but we can't use autogen/config.h before configure ends.\n\t# So pass #include/#define manually here for now.\n\tCPUID_CHECK_HEADERS=\n\tCPUID_CHECK_DEFINE=\n\tif test \"x$hwloc_windows\" = xyes; then\n\t    X86_CPUID_CHECK_HEADERS=\"#include <windows.h>\"\n\t    X86_CPUID_CHECK_DEFINE=\"#define hwloc_uint64_t DWORDLONG\"\n\telse\n\t    X86_CPUID_CHECK_DEFINE=\"#define hwloc_uint64_t uint64_t\"\n\t    if test \"x$ac_cv_header_stdint_h\" = xyes; then\n\t        X86_CPUID_CHECK_HEADERS=\"#include <stdint.h>\"\n\t    fi\n\tfi\n\tAC_LINK_IFELSE([AC_LANG_PROGRAM([[\n\t    #include <stdio.h>\n\t    $X86_CPUID_CHECK_HEADERS\n\t    $X86_CPUID_CHECK_DEFINE\n\t    #define __hwloc_inline\n\t    #include <private/cpuid-x86.h>\n\t]], [[\n\t    if (hwloc_have_x86_cpuid()) {\n\t\tunsigned eax = 0, ebx, ecx = 0, edx;\n\t\thwloc_x86_cpuid(&eax, &ebx, &ecx, &edx);\n\t\tprintf(\"highest x86 cpuid %x\\n\", eax);\n\t\treturn 0;\n\t    }\n\t]])],\n\t[AC_MSG_RESULT([yes])\n\t AC_DEFINE(HWLOC_HAVE_X86_CPUID, 1, [Define to 1 if you have x86 cpuid])\n\t hwloc_have_x86_cpuid=yes],\n\t[AC_MSG_RESULT([no])])\n\tif test \"x$hwloc_have_x86_cpuid\" = xyes; then\n\t    hwloc_components=\"$hwloc_components x86\"\n\tfi\n\tCPPFLAGS=\"$old_CPPFLAGS\"\n    fi\n\n    # Components require pthread_mutex, see if it needs -lpthread\n    hwloc_pthread_mutex_happy=no\n    # Try without explicit -lpthread first\n    AC_CHECK_FUNC([pthread_mutex_lock],\n      [hwloc_pthread_mutex_happy=yes\n       HWLOC_LIBS_PRIVATE=\"$HWLOC_LIBS_PRIVATE -lpthread\"\n      ],\n      [AC_MSG_CHECKING([for pthread_mutex_lock with -lpthread])\n       # Try again with explicit -lpthread, but don't use AC_CHECK_FUNC to avoid the cache\n       tmp_save_LIBS=$LIBS\n       LIBS=\"$LIBS -lpthread\"\n       AC_LINK_IFELSE([AC_LANG_CALL([], [pthread_mutex_lock])],\n         [hwloc_pthread_mutex_happy=yes\n          HWLOC_LIBS=\"$HWLOC_LIBS -lpthread\"\n         ])\n       AC_MSG_RESULT([$hwloc_pthread_mutex_happy])\n       LIBS=\"$tmp_save_LIBS\"\n      ])\n    AS_IF([test \"x$hwloc_pthread_mutex_happy\" = \"xyes\"],\n      [AC_DEFINE([HWLOC_HAVE_PTHREAD_MUTEX], 1, [Define to 1 if pthread mutexes are available])])\n\n    AS_IF([test \"x$hwloc_pthread_mutex_happy\" != xyes -a \"x$hwloc_windows\" != xyes],\n      [AC_MSG_WARN([pthread_mutex_lock not available, required for thread-safe initialization on non-Windows platforms.])\n       AC_MSG_WARN([Please report this to the hwloc-devel mailing list.])\n       AC_MSG_ERROR([Cannot continue])])\n\n    #\n    # Now enable registration of listed components\n    #\n\n    # Plugin support\n    AC_MSG_CHECKING([if plugin support is enabled])\n    # Plugins (even core support) are totally disabled by default\n    AS_IF([test \"x$enable_plugins\" = \"x\"], [enable_plugins=no])\n    AS_IF([test \"x$enable_plugins\" != \"xno\"], [hwloc_have_plugins=yes], [hwloc_have_plugins=no])\n    AC_MSG_RESULT([$hwloc_have_plugins])\n    AS_IF([test \"x$hwloc_have_plugins\" = \"xyes\"],\n          [AC_DEFINE([HWLOC_HAVE_PLUGINS], 1, [Define to 1 if the hwloc library should support dynamically-loaded plugins])])\n\n    # Some sanity checks about plugins\n    # libltdl doesn't work on AIX as of 2.4.2\n    AS_IF([test \"x$enable_plugins\" = \"xyes\" -a \"x$hwloc_aix\" = \"xyes\"],\n      [AC_MSG_WARN([libltdl does not work on AIX, plugins support cannot be enabled.])\n       AC_MSG_ERROR([Cannot continue])])\n    # posix linkers don't work well with plugins and windows dll constraints\n    AS_IF([test \"x$enable_plugins\" = \"xyes\" -a \"x$hwloc_windows\" = \"xyes\"],\n      [AC_MSG_WARN([Plugins not supported on non-native Windows build, plugins support cannot be enabled.])\n       AC_MSG_ERROR([Cannot continue])])\n\n    # If we want plugins, look for ltdl.h and libltdl\n    if test \"x$hwloc_have_plugins\" = xyes; then\n      AC_CHECK_HEADER([ltdl.h], [],\n\t[AC_MSG_WARN([Plugin support requested, but could not find ltdl.h])\n\t AC_MSG_ERROR([Cannot continue])])\n      AC_CHECK_LIB([ltdl], [lt_dlopenext],\n\t[HWLOC_LIBS=\"$HWLOC_LIBS -lltdl\"],\n\t[AC_MSG_WARN([Plugin support requested, but could not find libltdl])\n\t AC_MSG_ERROR([Cannot continue])])\n      # Add libltdl static-build dependencies to hwloc.pc\n      HWLOC_CHECK_LTDL_DEPS\n    fi\n\n    AC_ARG_WITH([hwloc-plugins-path],\n\t\tAC_HELP_STRING([--with-hwloc-plugins-path=dir:...],\n                               [Colon-separated list of plugin directories. Default: \"$prefix/lib/hwloc\". Plugins will be installed in the first directory. They will be loaded from all of them, in order.]),\n\t\t[HWLOC_PLUGINS_PATH=\"$with_hwloc_plugins_path\"],\n\t\t[HWLOC_PLUGINS_PATH=\"\\$(libdir)/hwloc\"])\n    AC_SUBST(HWLOC_PLUGINS_PATH)\n    HWLOC_PLUGINS_DIR=`echo \"$HWLOC_PLUGINS_PATH\" | cut -d: -f1`\n    AC_SUBST(HWLOC_PLUGINS_DIR)\n\n    # Static components output file\n    hwloc_static_components_dir=${HWLOC_top_builddir}/hwloc\n    mkdir -p ${hwloc_static_components_dir}\n    hwloc_static_components_file=${hwloc_static_components_dir}/static-components.h\n    rm -f ${hwloc_static_components_file}\n\n    # Make $enable_plugins easier to use (it contains either \"yes\" (all) or a list of <name>)\n    HWLOC_PREPARE_FILTER_COMPONENTS([$enable_plugins])\n    # Now we have some hwloc_<name>_component_wantplugin=1\n\n    # See which core components want plugin and support it\n    HWLOC_FILTER_COMPONENTS\n    # Now we have some hwloc_<name>_component=plugin/static\n    # and hwloc_static/plugin_components\n    AC_MSG_CHECKING([components to build statically])\n    AC_MSG_RESULT($hwloc_static_components)\n    HWLOC_LIST_STATIC_COMPONENTS([$hwloc_static_components_file], [$hwloc_static_components])\n    AC_MSG_CHECKING([components to build as plugins])\n    AC_MSG_RESULT([$hwloc_plugin_components])\n\n    AS_IF([test \"$hwloc_pci_component\" = \"static\"],\n          [HWLOC_LIBS=\"$HWLOC_LIBS $HWLOC_PCIACCESS_LIBS\"\n           HWLOC_CFLAGS=\"$HWLOC_CFLAGS $HWLOC_PCIACCESS_CFLAGS\"\n           HWLOC_REQUIRES=\"$HWLOC_PCIACCESS_REQUIRES $HWLOC_REQUIRES\"])\n    AS_IF([test \"$hwloc_opencl_component\" = \"static\"],\n          [HWLOC_LIBS=\"$HWLOC_LIBS $HWLOC_OPENCL_LIBS\"\n           HWLOC_LDFLAGS=\"$HWLOC_LDFLAGS $HWLOC_OPENCL_LDFLAGS\"\n           HWLOC_CFLAGS=\"$HWLOC_CFLAGS $HWLOC_OPENCL_CFLAGS\"\n           HWLOC_REQUIRES=\"$HWLOC_OPENCL_REQUIRES $HWLOC_REQUIRES\"])\n    AS_IF([test \"$hwloc_cuda_component\" = \"static\"],\n          [HWLOC_LIBS=\"$HWLOC_LIBS $HWLOC_CUDA_LIBS\"\n           HWLOC_CFLAGS=\"$HWLOC_CFLAGS $HWLOC_CUDA_CFLAGS\"\n           HWLOC_REQUIRES=\"$HWLOC_CUDA_REQUIRES $HWLOC_REQUIRES\"])\n    AS_IF([test \"$hwloc_nvml_component\" = \"static\"],\n          [HWLOC_LIBS=\"$HWLOC_LIBS $HWLOC_NVML_LIBS\"\n           HWLOC_CFLAGS=\"$HWLOC_CFLAGS $HWLOC_NVML_CFLAGS\"\n           HWLOC_REQUIRES=\"$HWLOC_NVML_REQUIRES $HWLOC_REQUIRES\"])\n    AS_IF([test \"$hwloc_gl_component\" = \"static\"],\n          [HWLOC_LIBS=\"$HWLOC_LIBS $HWLOC_GL_LIBS\"\n           HWLOC_CFLAGS=\"$HWLOC_CFLAGS $HWLOC_GL_CFLAGS\"\n           HWLOC_REQUIRES=\"$HWLOC_GL_REQUIRES $HWLOC_REQUIRES\"])\n    AS_IF([test \"$hwloc_xml_libxml_component\" = \"static\"],\n          [HWLOC_LIBS=\"$HWLOC_LIBS $HWLOC_LIBXML2_LIBS\"\n           HWLOC_CFLAGS=\"$HWLOC_CFLAGS $HWLOC_LIBXML2_CFLAGS\"\n           HWLOC_REQUIRES=\"$HWLOC_LIBXML2_REQUIRES $HWLOC_REQUIRES\"])\n\n    #\n    # Setup HWLOC's C, CPP, and LD flags, and LIBS\n    #\n    AC_SUBST(HWLOC_REQUIRES)\n    AC_SUBST(HWLOC_CFLAGS)\n    HWLOC_CPPFLAGS='-I$(HWLOC_top_builddir)/include -I$(HWLOC_top_srcdir)/include'\n    AC_SUBST(HWLOC_CPPFLAGS)\n    AC_SUBST(HWLOC_LDFLAGS)\n    AC_SUBST(HWLOC_LIBS)\n    AC_SUBST(HWLOC_LIBS_PRIVATE)\n\n    # Set these values explicitly for embedded builds.  Exporting\n    # these values through *_EMBEDDED_* values gives us the freedom to\n    # do something different someday if we ever need to.  There's no\n    # need to fill these values in unless we're in embedded mode.\n    # Indeed, if we're building in embedded mode, we want HWLOC_LIBS\n    # to be empty so that nothing is linked into libhwloc_embedded.la\n    # itself -- only the upper-layer will link in anything required.\n\n    AS_IF([test \"$hwloc_mode\" = \"embedded\"],\n          [HWLOC_EMBEDDED_CFLAGS=$HWLOC_CFLAGS\n           HWLOC_EMBEDDED_CPPFLAGS=$HWLOC_CPPFLAGS\n           HWLOC_EMBEDDED_LDFLAGS=$HWLOC_LDFLAGS\n           HWLOC_EMBEDDED_LDADD='$(HWLOC_top_builddir)/hwloc/libhwloc_embedded.la'\n           HWLOC_EMBEDDED_LIBS=$HWLOC_LIBS\n           HWLOC_LIBS=])\n    AC_SUBST(HWLOC_EMBEDDED_CFLAGS)\n    AC_SUBST(HWLOC_EMBEDDED_CPPFLAGS)\n    AC_SUBST(HWLOC_EMBEDDED_LDFLAGS)\n    AC_SUBST(HWLOC_EMBEDDED_LDADD)\n    AC_SUBST(HWLOC_EMBEDDED_LIBS)\n\n    # Always generate these files\n    AC_CONFIG_FILES(\n        hwloc_config_prefix[Makefile]\n        hwloc_config_prefix[include/Makefile]\n        hwloc_config_prefix[hwloc/Makefile]\n    )\n\n    # Cleanup\n    AC_LANG_POP\n\n    # Success\n    $2\n])dnl\n\n#-----------------------------------------------------------------------\n\n# Specify the symbol prefix\nAC_DEFUN([HWLOC_SET_SYMBOL_PREFIX],[\n    hwloc_symbol_prefix_value=$1\n])dnl\n\n#-----------------------------------------------------------------------\n\n# This must be a standalone routine so that it can be called both by\n# HWLOC_INIT and an external caller (if HWLOC_INIT is not invoked).\nAC_DEFUN([HWLOC_DO_AM_CONDITIONALS],[\n    AS_IF([test \"$hwloc_did_am_conditionals\" != \"yes\"],[\n        AM_CONDITIONAL([HWLOC_BUILD_STANDALONE], [test \"$hwloc_mode\" = \"standalone\"])\n\n        AM_CONDITIONAL([HWLOC_HAVE_GCC], [test \"x$GCC\" = \"xyes\"])\n        AM_CONDITIONAL([HWLOC_HAVE_MS_LIB], [test \"x$HWLOC_MS_LIB\" != \"x\"])\n        AM_CONDITIONAL([HWLOC_HAVE_OPENAT], [test \"x$hwloc_have_openat\" = \"xyes\"])\n        AM_CONDITIONAL([HWLOC_HAVE_SCHED_SETAFFINITY],\n                       [test \"x$hwloc_have_sched_setaffinity\" = \"xyes\"])\n        AM_CONDITIONAL([HWLOC_HAVE_PTHREAD],\n                       [test \"x$hwloc_have_pthread\" = \"xyes\"])\n        AM_CONDITIONAL([HWLOC_HAVE_LINUX_LIBNUMA],\n                       [test \"x$hwloc_have_linux_libnuma\" = \"xyes\"])\n        AM_CONDITIONAL([HWLOC_HAVE_LIBIBVERBS],\n                       [test \"x$hwloc_have_libibverbs\" = \"xyes\"])\n\tAM_CONDITIONAL([HWLOC_HAVE_CUDA],\n\t\t       [test \"x$hwloc_have_cuda\" = \"xyes\"])\n\tAM_CONDITIONAL([HWLOC_HAVE_GL],\n\t\t       [test \"x$hwloc_have_gl\" = \"xyes\"])\n\tAM_CONDITIONAL([HWLOC_HAVE_CUDART],\n\t\t       [test \"x$hwloc_have_cudart\" = \"xyes\"])\n        AM_CONDITIONAL([HWLOC_HAVE_LIBXML2], [test \"$hwloc_libxml2_happy\" = \"yes\"])\n        AM_CONDITIONAL([HWLOC_HAVE_CAIRO], [test \"$hwloc_cairo_happy\" = \"yes\"])\n        AM_CONDITIONAL([HWLOC_HAVE_PCIACCESS], [test \"$hwloc_pciaccess_happy\" = \"yes\"])\n        AM_CONDITIONAL([HWLOC_HAVE_OPENCL], [test \"$hwloc_opencl_happy\" = \"yes\"])\n        AM_CONDITIONAL([HWLOC_HAVE_NVML], [test \"$hwloc_nvml_happy\" = \"yes\"])\n        AM_CONDITIONAL([HWLOC_HAVE_BUNZIPP], [test \"x$BUNZIPP\" != \"xfalse\"])\n        AM_CONDITIONAL([HWLOC_HAVE_USER32], [test \"x$hwloc_have_user32\" = \"xyes\"])\n\n        AM_CONDITIONAL([HWLOC_BUILD_DOXYGEN],\n                       [test \"x$hwloc_generate_doxs\" = \"xyes\"])\n        AM_CONDITIONAL([HWLOC_BUILD_README],\n                       [test \"x$hwloc_generate_readme\" = \"xyes\" -a \\( \"x$hwloc_install_doxs\" = \"xyes\" -o \"x$hwloc_generate_doxs\" = \"xyes\" \\) ])\n        AM_CONDITIONAL([HWLOC_INSTALL_DOXYGEN],\n                       [test \"x$hwloc_install_doxs\" = \"xyes\"])\n\n        AM_CONDITIONAL([HWLOC_HAVE_LINUX], [test \"x$hwloc_linux\" = \"xyes\"])\n        AM_CONDITIONAL([HWLOC_HAVE_BGQ], [test \"x$hwloc_bgq\" = \"xyes\"])\n        AM_CONDITIONAL([HWLOC_HAVE_IRIX], [test \"x$hwloc_irix\" = \"xyes\"])\n        AM_CONDITIONAL([HWLOC_HAVE_DARWIN], [test \"x$hwloc_darwin\" = \"xyes\"])\n        AM_CONDITIONAL([HWLOC_HAVE_FREEBSD], [test \"x$hwloc_freebsd\" = \"xyes\"])\n        AM_CONDITIONAL([HWLOC_HAVE_NETBSD], [test \"x$hwloc_netbsd\" = \"xyes\"])\n        AM_CONDITIONAL([HWLOC_HAVE_SOLARIS], [test \"x$hwloc_solaris\" = \"xyes\"])\n        AM_CONDITIONAL([HWLOC_HAVE_AIX], [test \"x$hwloc_aix\" = \"xyes\"])\n        AM_CONDITIONAL([HWLOC_HAVE_HPUX], [test \"x$hwloc_hpux\" = \"xyes\"])\n        AM_CONDITIONAL([HWLOC_HAVE_WINDOWS], [test \"x$hwloc_windows\" = \"xyes\"])\n        AM_CONDITIONAL([HWLOC_HAVE_MINGW32], [test \"x$target_os\" = \"xmingw32\"])\n\n        AM_CONDITIONAL([HWLOC_HAVE_X86], [test \"x$hwloc_x86_32\" = \"xyes\" -o \"x$hwloc_x86_64\" = \"xyes\"])\n        AM_CONDITIONAL([HWLOC_HAVE_X86_32], [test \"x$hwloc_x86_32\" = \"xyes\"])\n        AM_CONDITIONAL([HWLOC_HAVE_X86_64], [test \"x$hwloc_x86_64\" = \"xyes\"])\n        AM_CONDITIONAL([HWLOC_HAVE_X86_CPUID], [test \"x$hwloc_have_x86_cpuid\" = \"xyes\"])\n\n        AM_CONDITIONAL([HWLOC_HAVE_PLUGINS], [test \"x$hwloc_have_plugins\" = \"xyes\"])\n        AM_CONDITIONAL([HWLOC_PCI_BUILD_STATIC], [test \"x$hwloc_pci_component\" = \"xstatic\"])\n        AM_CONDITIONAL([HWLOC_OPENCL_BUILD_STATIC], [test \"x$hwloc_opencl_component\" = \"xstatic\"])\n        AM_CONDITIONAL([HWLOC_CUDA_BUILD_STATIC], [test \"x$hwloc_cuda_component\" = \"xstatic\"])\n        AM_CONDITIONAL([HWLOC_NVML_BUILD_STATIC], [test \"x$hwloc_nvml_component\" = \"xstatic\"])\n        AM_CONDITIONAL([HWLOC_GL_BUILD_STATIC], [test \"x$hwloc_gl_component\" = \"xstatic\"])\n        AM_CONDITIONAL([HWLOC_XML_LIBXML_BUILD_STATIC], [test \"x$hwloc_xml_libxml_component\" = \"xstatic\"])\n\n        AM_CONDITIONAL([HWLOC_HAVE_CXX], [test \"x$hwloc_have_cxx\" = \"xyes\"])\n    ])\n    hwloc_did_am_conditionals=yes\n\n    # For backwards compatibility (i.e., packages that only call\n    # HWLOC_DO_AM_CONDITIONS, not NETLOC DO_AM_CONDITIONALS), we also have to\n    # do the netloc AM conditionals here\n    NETLOC_DO_AM_CONDITIONALS\n])dnl\n\n#-----------------------------------------------------------------------\n\ndnl HWLOC_CHECK_DECL\ndnl\ndnl Check that the declaration of the given function has a complete prototype\ndnl with argument list by trying to call it with an insane dnl number of\ndnl arguments (10). Success means the compiler couldn't really check.\nAC_DEFUN([_HWLOC_CHECK_DECL], [\n  AC_CHECK_DECL([$1], [\n    AC_MSG_CHECKING([whether function $1 has a complete prototype])\n    AC_REQUIRE([AC_PROG_CC])\n    AC_COMPILE_IFELSE([AC_LANG_PROGRAM(\n         [AC_INCLUDES_DEFAULT([$4])],\n         [$1(1,2,3,4,5,6,7,8,9,10);]\n      )],\n      [AC_MSG_RESULT([no])\n       $3],\n      [AC_MSG_RESULT([yes])\n       $2]\n    )], [$3], $4\n  )\n])\n\n#-----------------------------------------------------------------------\n\ndnl HWLOC_CHECK_DECLS\ndnl\ndnl Same as HWLOCK_CHECK_DECL, but defines HAVE_DECL_foo to 1 or 0 depending on\ndnl the result.\nAC_DEFUN([_HWLOC_CHECK_DECLS], [\n  HWLOC_CHECK_DECL([$1], [ac_have_decl=1], [ac_have_decl=0], [$4])\n  AC_DEFINE_UNQUOTED(AS_TR_CPP([HAVE_DECL_$1]), [$ac_have_decl],\n    [Define to 1 if you have the declaration of `$1', and to 0 if you don't])\n])\n\n#-----------------------------------------------------------------------\n\ndnl HWLOC_CHECK_LTDL_DEPS\ndnl\ndnl Add ltdl dependencies to HWLOC_LIBS_PRIVATE\nAC_DEFUN([HWLOC_CHECK_LTDL_DEPS], [\n  # save variables that we'll modify below\n  save_lt_cv_dlopen=\"$lt_cv_dlopen\"\n  save_lt_cv_dlopen_libs=\"$lt_cv_dlopen_libs\"\n  save_lt_cv_dlopen_self=\"$lt_cv_dlopen_self\"\n  ###########################################################\n  # code stolen from LT_SYS_DLOPEN_SELF in libtool.m4\n  case $host_os in\n  beos*)\n    lt_cv_dlopen=\"load_add_on\"\n    lt_cv_dlopen_libs=\n    lt_cv_dlopen_self=yes\n    ;;\n\n  mingw* | pw32* | cegcc*)\n    lt_cv_dlopen=\"LoadLibrary\"\n    lt_cv_dlopen_libs=\n    ;;\n\n  cygwin*)\n    lt_cv_dlopen=\"dlopen\"\n    lt_cv_dlopen_libs=\n    ;;\n\n  darwin*)\n  # if libdl is installed we need to link against it\n    AC_CHECK_LIB([dl], [dlopen],\n                [lt_cv_dlopen=\"dlopen\" lt_cv_dlopen_libs=\"-ldl\"],[\n    lt_cv_dlopen=\"dyld\"\n    lt_cv_dlopen_libs=\n    lt_cv_dlopen_self=yes\n    ])\n    ;;\n\n  *)\n    AC_CHECK_FUNC([shl_load],\n          [lt_cv_dlopen=\"shl_load\"],\n      [AC_CHECK_LIB([dld], [shl_load],\n            [lt_cv_dlopen=\"shl_load\" lt_cv_dlopen_libs=\"-ldld\"],\n        [AC_CHECK_FUNC([dlopen],\n              [lt_cv_dlopen=\"dlopen\"],\n          [AC_CHECK_LIB([dl], [dlopen],\n                [lt_cv_dlopen=\"dlopen\" lt_cv_dlopen_libs=\"-ldl\"],\n            [AC_CHECK_LIB([svld], [dlopen],\n                  [lt_cv_dlopen=\"dlopen\" lt_cv_dlopen_libs=\"-lsvld\"],\n              [AC_CHECK_LIB([dld], [dld_link],\n                    [lt_cv_dlopen=\"dld_link\" lt_cv_dlopen_libs=\"-ldld\"])\n              ])\n            ])\n          ])\n        ])\n      ])\n    ;;\n  esac\n  # end of code stolen from LT_SYS_DLOPEN_SELF in libtool.m4\n  ###########################################################\n\n  HWLOC_LIBS_PRIVATE=\"$HWLOC_LIBS_PRIVATE $lt_cv_dlopen_libs\"\n\n  # restore modified variable in case the actual libtool code uses them\n  lt_cv_dlopen=\"$save_lt_cv_dlopen\"\n  lt_cv_dlopen_libs=\"$save_lt_cv_dlopen_libs\"\n  lt_cv_dlopen_self=\"$save_lt_cv_dlopen_self\"\n])\n",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/include/hwloc/plugins.h": "/*\n * Copyright \u00a9 2013-2017 Inria.  All rights reserved.\n * Copyright \u00a9 2016 Cisco Systems, Inc.  All rights reserved.\n * See COPYING in top-level directory.\n */\n\n#ifndef HWLOC_PLUGINS_H\n#define HWLOC_PLUGINS_H\n\n/** \\file\n * \\brief Public interface for building hwloc plugins.\n */\n\nstruct hwloc_backend;\n\n#include <hwloc.h>\n#ifdef HWLOC_INSIDE_PLUGIN\n/* needed for hwloc_plugin_check_namespace() */\n#include <ltdl.h>\n#endif\n\n\n\n/** \\defgroup hwlocality_disc_components Components and Plugins: Discovery components\n * @{\n */\n\n/** \\brief Discovery component type */\ntypedef enum hwloc_disc_component_type_e {\n  /** \\brief CPU-only discovery through the OS, or generic no-OS support.\n   * \\hideinitializer */\n  HWLOC_DISC_COMPONENT_TYPE_CPU = (1<<0),\n\n  /** \\brief xml or synthetic,\n   * platform-specific components such as bgq.\n   * Anything the discovers CPU and everything else.\n   * No misc backend is expected to complement a global component.\n   * \\hideinitializer */\n  HWLOC_DISC_COMPONENT_TYPE_GLOBAL = (1<<1),\n\n  /** \\brief OpenCL, Cuda, etc.\n   * \\hideinitializer */\n  HWLOC_DISC_COMPONENT_TYPE_MISC = (1<<2)\n} hwloc_disc_component_type_t;\n\n/** \\brief Discovery component structure\n *\n * This is the major kind of components, taking care of the discovery.\n * They are registered by generic components, either statically-built or as plugins.\n */\nstruct hwloc_disc_component {\n  /** \\brief Discovery component type */\n  hwloc_disc_component_type_t type;\n\n  /** \\brief Name.\n   * If this component is built as a plugin, this name does not have to match the plugin filename.\n   */\n  const char *name;\n\n  /** \\brief Component types to exclude, as an OR'ed set of ::hwloc_disc_component_type_e.\n   *\n   * For a GLOBAL component, this usually includes all other types (~0).\n   *\n   * Other components only exclude types that may bring conflicting\n   * topology information. MISC components should likely not be excluded\n   * since they usually bring non-primary additional information.\n   */\n  unsigned excludes;\n\n  /** \\brief Instantiate callback to create a backend from the component.\n   * Parameters data1, data2, data3 are NULL except for components\n   * that have special enabling routines such as hwloc_topology_set_xml(). */\n  struct hwloc_backend * (*instantiate)(struct hwloc_disc_component *component, const void *data1, const void *data2, const void *data3);\n\n  /** \\brief Component priority.\n   * Used to sort topology->components, higher priority first.\n   * Also used to decide between two components with the same name.\n   *\n   * Usual values are\n   * 50 for native OS (or platform) components,\n   * 45 for x86,\n   * 40 for no-OS fallback,\n   * 30 for global components (xml, synthetic),\n   * 20 for pci,\n   * 10 for other misc components (opencl etc.).\n   */\n  unsigned priority;\n\n  /** \\brief Enabled by default.\n   * If unset, if will be disabled unless explicitly requested.\n   */\n  unsigned enabled_by_default;\n\n  /** \\private Used internally to list components by priority on topology->components\n   * (the component structure is usually read-only,\n   *  the core copies it before using this field for queueing)\n   */\n  struct hwloc_disc_component * next;\n};\n\n/** @} */\n\n\n\n\n/** \\defgroup hwlocality_disc_backends Components and Plugins: Discovery backends\n * @{\n */\n\n/** \\brief Discovery backend structure\n *\n * A backend is the instantiation of a discovery component.\n * When a component gets enabled for a topology,\n * its instantiate() callback creates a backend.\n *\n * hwloc_backend_alloc() initializes all fields to default values\n * that the component may change (except \"component\" and \"next\")\n * before enabling the backend with hwloc_backend_enable().\n */\nstruct hwloc_backend {\n  /** \\private Reserved for the core, set by hwloc_backend_alloc() */\n  struct hwloc_disc_component * component;\n  /** \\private Reserved for the core, set by hwloc_backend_enable() */\n  struct hwloc_topology * topology;\n  /** \\private Reserved for the core. Set to 1 if forced through envvar, 0 otherwise. */\n  int envvar_forced;\n  /** \\private Reserved for the core. Used internally to list backends topology->backends. */\n  struct hwloc_backend * next;\n\n  /** \\brief Backend flags, currently always 0. */\n  unsigned long flags;\n\n  /** \\brief Backend-specific 'is_thissystem' property.\n   * Set to 0 or 1 if the backend should enforce the thissystem flag when it gets enabled.\n   * Set to -1 if the backend doesn't care (default). */\n  int is_thissystem;\n\n  /** \\brief Backend private data, or NULL if none. */\n  void * private_data;\n  /** \\brief Callback for freeing the private_data.\n   * May be NULL.\n   */\n  void (*disable)(struct hwloc_backend *backend);\n\n  /** \\brief Main discovery callback.\n   * returns -1 on error, either because it couldn't add its objects ot the existing topology,\n   * or because of an actual discovery/gathering failure.\n   * May be NULL.\n   */\n  int (*discover)(struct hwloc_backend *backend);\n\n  /** \\brief Callback used by the PCI backend to retrieve the locality of a PCI object from the OS/cpu backend.\n   * May be NULL. */\n  int (*get_pci_busid_cpuset)(struct hwloc_backend *backend, struct hwloc_pcidev_attr_s *busid, hwloc_bitmap_t cpuset);\n};\n\n/** \\brief Allocate a backend structure, set good default values, initialize backend->component and topology, etc.\n * The caller will then modify whatever needed, and call hwloc_backend_enable().\n */\nHWLOC_DECLSPEC struct hwloc_backend * hwloc_backend_alloc(struct hwloc_disc_component *component);\n\n/** \\brief Enable a previously allocated and setup backend. */\nHWLOC_DECLSPEC int hwloc_backend_enable(struct hwloc_topology *topology, struct hwloc_backend *backend);\n\n/** @} */\n\n\n\n\n/** \\defgroup hwlocality_generic_components Components and Plugins: Generic components\n * @{\n */\n\n/** \\brief Generic component type */\ntypedef enum hwloc_component_type_e {\n  /** \\brief The data field must point to a struct hwloc_disc_component. */\n  HWLOC_COMPONENT_TYPE_DISC,\n\n  /** \\brief The data field must point to a struct hwloc_xml_component. */\n  HWLOC_COMPONENT_TYPE_XML\n} hwloc_component_type_t;\n\n/** \\brief Generic component structure\n *\n * Generic components structure, either statically listed by configure in static-components.h\n * or dynamically loaded as a plugin.\n */\nstruct hwloc_component {\n  /** \\brief Component ABI version, set to ::HWLOC_COMPONENT_ABI */\n  unsigned abi;\n\n  /** \\brief Process-wide component initialization callback.\n   *\n   * This optional callback is called when the component is registered\n   * to the hwloc core (after loading the plugin).\n   *\n   * When the component is built as a plugin, this callback\n   * should call hwloc_check_plugin_namespace()\n   * and return an negative error code on error.\n   *\n   * \\p flags is always 0 for now.\n   *\n   * \\return 0 on success, or a negative code on error.\n   *\n   * \\note If the component uses ltdl for loading its own plugins,\n   * it should load/unload them only in init() and finalize(),\n   * to avoid race conditions with hwloc's use of ltdl.\n   */\n  int (*init)(unsigned long flags);\n\n  /** \\brief Process-wide component termination callback.\n   *\n   * This optional callback is called after unregistering the component\n   * from the hwloc core (before unloading the plugin).\n   *\n   * \\p flags is always 0 for now.\n   *\n   * \\note If the component uses ltdl for loading its own plugins,\n   * it should load/unload them only in init() and finalize(),\n   * to avoid race conditions with hwloc's use of ltdl.\n   */\n  void (*finalize)(unsigned long flags);\n\n  /** \\brief Component type */\n  hwloc_component_type_t type;\n\n  /** \\brief Component flags, unused for now */\n  unsigned long flags;\n\n  /** \\brief Component data, pointing to a struct hwloc_disc_component or struct hwloc_xml_component. */\n  void * data;\n};\n\n/** @} */\n\n\n\n\n/** \\defgroup hwlocality_components_core_funcs Components and Plugins: Core functions to be used by components\n * @{\n */\n\n/** \\brief Add an object to the topology.\n *\n * It is sorted along the tree of other objects according to the inclusion of\n * cpusets, to eventually be added as a child of the smallest object including\n * this object.\n *\n * If the cpuset is empty, the type of the object (and maybe some attributes)\n * must be enough to find where to insert the object. This is especially true\n * for NUMA nodes with memory and no CPUs.\n *\n * The given object should not have children.\n *\n * This shall only be called before levels are built.\n *\n * In case of error, hwloc_report_os_error() is called.\n *\n * The caller should check whether the object type is filtered-out before calling this function.\n *\n * The topology cpuset/nodesets will be enlarged to include the object sets.\n *\n * Returns the object on success.\n * Returns NULL and frees obj on error.\n * Returns another object and frees obj if it was merged with an identical pre-existing object.\n */\nHWLOC_DECLSPEC struct hwloc_obj *hwloc_insert_object_by_cpuset(struct hwloc_topology *topology, hwloc_obj_t obj);\n\n/** \\brief Type of error callbacks during object insertion */\ntypedef void (*hwloc_report_error_t)(const char * msg, int line);\n/** \\brief Report an insertion error from a backend */\nHWLOC_DECLSPEC void hwloc_report_os_error(const char * msg, int line);\n/** \\brief Check whether insertion errors are hidden */\nHWLOC_DECLSPEC int hwloc_hide_errors(void);\n\n/** \\brief Add an object to the topology and specify which error callback to use.\n *\n * This function is similar to hwloc_insert_object_by_cpuset() but it allows specifying\n * where to start insertion from (if \\p root is NULL, the topology root object is used),\n * and specifying the error callback.\n */\nHWLOC_DECLSPEC struct hwloc_obj *hwloc__insert_object_by_cpuset(struct hwloc_topology *topology, hwloc_obj_t root, hwloc_obj_t obj, hwloc_report_error_t report_error);\n\n/** \\brief Insert an object somewhere in the topology.\n *\n * It is added as the last child of the given parent.\n * The cpuset is completely ignored, so strange objects such as I/O devices should\n * preferably be inserted with this.\n *\n * When used for \"normal\" children with cpusets (when importing from XML\n * when duplicating a topology), the caller should make sure that:\n * - children are inserted in order,\n * - children cpusets do not intersect.\n *\n * The given object may have normal, I/O or Misc children, as long as they are in order as well.\n * These children must have valid parent and next_sibling pointers.\n *\n * The caller should check whether the object type is filtered-out before calling this function.\n */\nHWLOC_DECLSPEC void hwloc_insert_object_by_parent(struct hwloc_topology *topology, hwloc_obj_t parent, hwloc_obj_t obj);\n\n/** \\brief Allocate and initialize an object of the given type and physical index.\n *\n * If \\p os_index is unknown or irrelevant, use \\c HWLOC_UNKNOWN_INDEX.\n */\nHWLOC_DECLSPEC hwloc_obj_t hwloc_alloc_setup_object(hwloc_topology_t topology, hwloc_obj_type_t type, unsigned os_index);\n\n/** \\brief Setup object cpusets/nodesets by OR'ing its children.\n *\n * Used when adding an object late in the topology.\n * Will update the new object by OR'ing all its new children sets.\n *\n * Used when PCI backend adds a hostbridge parent, when distances\n * add a new Group, etc.\n */\nHWLOC_DECLSPEC int hwloc_obj_add_children_sets(hwloc_obj_t obj);\n\n/** \\brief Request a reconnection of children and levels in the topology.\n *\n * May be used by backends during discovery if they need arrays or lists\n * of object within levels or children to be fully connected.\n *\n * \\p flags is currently unused, must 0.\n */\nHWLOC_DECLSPEC int hwloc_topology_reconnect(hwloc_topology_t topology, unsigned long flags __hwloc_attribute_unused);\n\n/** \\brief Make sure that plugins can lookup core symbols.\n *\n * This is a sanity check to avoid lazy-lookup failures when libhwloc\n * is loaded within a plugin, and later tries to load its own plugins.\n * This may fail (and abort the program) if libhwloc symbols are in a\n * private namespace.\n *\n * \\return 0 on success.\n * \\return -1 if the plugin cannot be successfully loaded. The caller\n * plugin init() callback should return a negative error code as well.\n *\n * Plugins should call this function in their init() callback to avoid\n * later crashes if lazy symbol resolution is used by the upper layer that\n * loaded hwloc (e.g. OpenCL implementations using dlopen with RTLD_LAZY).\n *\n * \\note The build system must define HWLOC_INSIDE_PLUGIN if and only if\n * building the caller as a plugin.\n *\n * \\note This function should remain inline so plugins can call it even\n * when they cannot find libhwloc symbols.\n */\nstatic __hwloc_inline int\nhwloc_plugin_check_namespace(const char *pluginname __hwloc_attribute_unused, const char *symbol __hwloc_attribute_unused)\n{\n#ifdef HWLOC_INSIDE_PLUGIN\n  lt_dlhandle handle;\n  void *sym;\n  handle = lt_dlopen(NULL);\n  if (!handle)\n    /* cannot check, assume things will work */\n    return 0;\n  sym = lt_dlsym(handle, symbol);\n  lt_dlclose(handle);\n  if (!sym) {\n    static int verboseenv_checked = 0;\n    static int verboseenv_value = 0;\n    if (!verboseenv_checked) {\n      const char *verboseenv = getenv(\"HWLOC_PLUGINS_VERBOSE\");\n      verboseenv_value = verboseenv ? atoi(verboseenv) : 0;\n      verboseenv_checked = 1;\n    }\n    if (verboseenv_value)\n      fprintf(stderr, \"Plugin `%s' disabling itself because it cannot find the `%s' core symbol.\\n\",\n\t      pluginname, symbol);\n    return -1;\n  }\n#endif /* HWLOC_INSIDE_PLUGIN */\n  return 0;\n}\n\n/** @} */\n\n\n\n\n/** \\defgroup hwlocality_components_filtering Components and Plugins: Filtering objects\n * @{\n */\n\n/** \\brief Check whether the given PCI device classid is important.\n *\n * \\return 1 if important, 0 otherwise.\n */\nstatic __hwloc_inline int\nhwloc_filter_check_pcidev_subtype_important(unsigned classid)\n{\n  unsigned baseclass = classid >> 8;\n  return (baseclass == 0x03 /* PCI_BASE_CLASS_DISPLAY */\n\t  || baseclass == 0x02 /* PCI_BASE_CLASS_NETWORK */\n\t  || baseclass == 0x01 /* PCI_BASE_CLASS_STORAGE */\n\t  || baseclass == 0x0b /* PCI_BASE_CLASS_PROCESSOR */\n\t  || classid == 0x0c04 /* PCI_CLASS_SERIAL_FIBER */\n\t  || classid == 0x0c06 /* PCI_CLASS_SERIAL_INFINIBAND */\n\t  || baseclass == 0x12 /* Processing Accelerators */);\n}\n\n/** \\brief Check whether the given OS device subtype is important.\n *\n * \\return 1 if important, 0 otherwise.\n */\nstatic __hwloc_inline int\nhwloc_filter_check_osdev_subtype_important(hwloc_obj_osdev_type_t subtype)\n{\n  return (subtype != HWLOC_OBJ_OSDEV_DMA);\n}\n\n/** \\brief Check whether a non-I/O object type should be filtered-out.\n *\n * Cannot be used for I/O objects.\n *\n * \\return 1 if the object type should be kept, 0 otherwise.\n */\nstatic __hwloc_inline int\nhwloc_filter_check_keep_object_type(hwloc_topology_t topology, hwloc_obj_type_t type)\n{\n  enum hwloc_type_filter_e filter = HWLOC_TYPE_FILTER_KEEP_NONE;\n  hwloc_topology_get_type_filter(topology, type, &filter);\n  assert(filter != HWLOC_TYPE_FILTER_KEEP_IMPORTANT); /* IMPORTANT only used for I/O */\n  return filter == HWLOC_TYPE_FILTER_KEEP_NONE ? 0 : 1;\n}\n\n/** \\brief Check whether the given object should be filtered-out.\n *\n * \\return 1 if the object type should be kept, 0 otherwise.\n */\nstatic __hwloc_inline int\nhwloc_filter_check_keep_object(hwloc_topology_t topology, hwloc_obj_t obj)\n{\n  hwloc_obj_type_t type = obj->type;\n  enum hwloc_type_filter_e filter = HWLOC_TYPE_FILTER_KEEP_NONE;\n  hwloc_topology_get_type_filter(topology, type, &filter);\n  if (filter == HWLOC_TYPE_FILTER_KEEP_NONE)\n    return 0;\n  if (filter == HWLOC_TYPE_FILTER_KEEP_IMPORTANT) {\n    if (type == HWLOC_OBJ_PCI_DEVICE)\n      return hwloc_filter_check_pcidev_subtype_important(obj->attr->pcidev.class_id);\n    if (type == HWLOC_OBJ_OS_DEVICE)\n      return hwloc_filter_check_osdev_subtype_important(obj->attr->osdev.type);\n  }\n  return 1;\n}\n\n/** @} */\n\n\n\n\n/** \\defgroup hwlocality_components_pcidisc Components and Plugins: helpers for PCI discovery\n * @{\n */\n\n/** \\brief Return the offset of the given capability in the PCI config space buffer\n *\n * This function requires a 256-bytes config space. Unknown/unavailable bytes should be set to 0xff.\n */\nHWLOC_DECLSPEC unsigned hwloc_pcidisc_find_cap(const unsigned char *config, unsigned cap);\n\n/** \\brief Fill linkspeed by reading the PCI config space where PCI_CAP_ID_EXP is at position offset.\n *\n * Needs 20 bytes of EXP capability block starting at offset in the config space\n * for registers up to link status.\n */\nHWLOC_DECLSPEC int hwloc_pcidisc_find_linkspeed(const unsigned char *config, unsigned offset, float *linkspeed);\n\n/** \\brief Return the hwloc object type (PCI device or Bridge) for the given class and configuration space.\n *\n * This function requires 16 bytes of common configuration header at the beginning of config.\n */\nHWLOC_DECLSPEC hwloc_obj_type_t hwloc_pcidisc_check_bridge_type(unsigned device_class, const unsigned char *config);\n\n/** \\brief Fills the attributes of the given PCI bridge using the given PCI config space.\n *\n * This function requires 32 bytes of common configuration header at the beginning of config.\n *\n * Returns -1 and destroys /p obj if bridge fields are invalid.\n */\nHWLOC_DECLSPEC int hwloc_pcidisc_setup_bridge_attr(hwloc_obj_t obj, const unsigned char *config);\n\n/** \\brief Insert a PCI object in the given PCI tree by looking at PCI bus IDs.\n *\n * If \\p treep points to \\c NULL, the new object is inserted there.\n */\nHWLOC_DECLSPEC void hwloc_pcidisc_tree_insert_by_busid(struct hwloc_obj **treep, struct hwloc_obj *obj);\n\n/** \\brief Add some hostbridges on top of the given tree of PCI objects and attach them to the topology.\n *\n * For now, they will be attached to the root object. The core will move them to their actual PCI\n * locality using hwloc_pci_belowroot_apply_locality() at the end of the discovery.\n *\n * In the meantime, other backends lookup PCI objects or localities (for instance to attach OS devices)\n * by using hwloc_pcidisc_find_by_busid() or hwloc_pcidisc_find_busid_parent().\n */\nHWLOC_DECLSPEC int hwloc_pcidisc_tree_attach(struct hwloc_topology *topology, struct hwloc_obj *tree);\n\n/** @} */\n\n\n\n\n/** \\defgroup hwlocality_components_pcifind Components and Plugins: finding PCI objects during other discoveries\n * @{\n */\n\n/** \\brief Find the PCI object that matches the bus ID.\n *\n * To be used after a PCI backend added PCI devices with hwloc_pcidisc_tree_attach()\n * and before the core moves them to their actual location with hwloc_pci_belowroot_apply_locality().\n *\n * If no exactly matching object is found, return the container bridge if any, or NULL.\n *\n * On failure, it may be possible to find the PCI locality (instead of the PCI device)\n * by calling hwloc_pcidisc_find_busid_parent().\n *\n * \\note This is semantically identical to hwloc_get_pcidev_by_busid() which only works\n * after the topology is fully loaded.\n */\nHWLOC_DECLSPEC struct hwloc_obj * hwloc_pcidisc_find_by_busid(struct hwloc_topology *topology, unsigned domain, unsigned bus, unsigned dev, unsigned func);\n\n/** \\brief Find the normal parent of a PCI bus ID.\n *\n * Look at PCI affinity to find out where the given PCI bus ID should be attached.\n *\n * This function should be used to attach an I/O device directly under a normal\n * (non-I/O) object, instead of below a PCI object.\n * It is usually used by backends when hwloc_pcidisc_find_by_busid() failed\n * to find the hwloc object corresponding to this bus ID, for instance because\n * PCI discovery is not supported on this platform.\n */\nHWLOC_DECLSPEC struct hwloc_obj * hwloc_pcidisc_find_busid_parent(struct hwloc_topology *topology, unsigned domain, unsigned bus, unsigned dev, unsigned func);\n\n/** @} */\n\n\n\n\n#endif /* HWLOC_PLUGINS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/hwloc/components.c": "/*\n * Copyright \u00a9 2009-2017 Inria.  All rights reserved.\n * Copyright \u00a9 2012 Universit\u00e9 Bordeaux\n * See COPYING in top-level directory.\n */\n\n#include <private/autogen/config.h>\n#include <hwloc.h>\n#include <private/private.h>\n#include <private/xml.h>\n#include <private/misc.h>\n\n#define HWLOC_COMPONENT_STOP_NAME \"stop\"\n#define HWLOC_COMPONENT_EXCLUDE_CHAR '-'\n#define HWLOC_COMPONENT_SEPS \",\"\n\n/* list of all registered discovery components, sorted by priority, higher priority first.\n * noos is last because its priority is 0.\n * others' priority is 10.\n */\nstatic struct hwloc_disc_component * hwloc_disc_components = NULL;\n\nstatic unsigned hwloc_components_users = 0; /* first one initializes, last ones destroys */\n\nstatic int hwloc_components_verbose = 0;\n#ifdef HWLOC_HAVE_PLUGINS\nstatic int hwloc_plugins_verbose = 0;\nstatic const char * hwloc_plugins_blacklist = NULL;\n#endif\n\n/* hwloc_components_mutex serializes:\n * - loading/unloading plugins, and modifications of the hwloc_plugins list\n * - calls to ltdl, including in hwloc_check_plugin_namespace()\n * - registration of components with hwloc_disc_component_register()\n *   and hwloc_xml_callbacks_register()\n */\n#ifdef HWLOC_WIN_SYS\n/* Basic mutex on top of InterlockedCompareExchange() on windows,\n * Far from perfect, but easy to maintain, and way enough given that this code will never be needed for real. */\n#include <windows.h>\nstatic LONG hwloc_components_mutex = 0;\n#define HWLOC_COMPONENTS_LOCK() do {\t\t\t\t\t\t\\\n  while (InterlockedCompareExchange(&hwloc_components_mutex, 1, 0) != 0)\t\\\n    SwitchToThread();\t\t\t\t\t\t\t\t\\\n} while (0)\n#define HWLOC_COMPONENTS_UNLOCK() do {\t\t\t\t\t\t\\\n  assert(hwloc_components_mutex == 1);\t\t\t\t\t\t\\\n  hwloc_components_mutex = 0;\t\t\t\t\t\t\t\\\n} while (0)\n\n#elif defined HWLOC_HAVE_PTHREAD_MUTEX\n/* pthread mutex if available (except on windows) */\n#include <pthread.h>\nstatic pthread_mutex_t hwloc_components_mutex = PTHREAD_MUTEX_INITIALIZER;\n#define HWLOC_COMPONENTS_LOCK() pthread_mutex_lock(&hwloc_components_mutex)\n#define HWLOC_COMPONENTS_UNLOCK() pthread_mutex_unlock(&hwloc_components_mutex)\n\n#else /* HWLOC_WIN_SYS || HWLOC_HAVE_PTHREAD_MUTEX */\n#error No mutex implementation available\n#endif\n\n\n#ifdef HWLOC_HAVE_PLUGINS\n\n#include <ltdl.h>\n\n/* array of pointers to dynamically loaded plugins */\nstatic struct hwloc__plugin_desc {\n  char *name;\n  struct hwloc_component *component;\n  char *filename;\n  lt_dlhandle handle;\n  struct hwloc__plugin_desc *next;\n} *hwloc_plugins = NULL;\n\nstatic int\nhwloc__dlforeach_cb(const char *filename, void *_data __hwloc_attribute_unused)\n{\n  const char *basename;\n  lt_dlhandle handle;\n  struct hwloc_component *component;\n  struct hwloc__plugin_desc *desc, **prevdesc;\n\n  if (hwloc_plugins_verbose)\n    fprintf(stderr, \"Plugin dlforeach found `%s'\\n\", filename);\n\n  basename = strrchr(filename, '/');\n  if (!basename)\n    basename = filename;\n  else\n    basename++;\n\n  if (hwloc_plugins_blacklist && strstr(hwloc_plugins_blacklist, basename)) {\n    if (hwloc_plugins_verbose)\n      fprintf(stderr, \"Plugin `%s' is blacklisted in the environment\\n\", basename);\n    goto out;\n  }\n\n  /* dlopen and get the component structure */\n  handle = lt_dlopenext(filename);\n  if (!handle) {\n    if (hwloc_plugins_verbose)\n      fprintf(stderr, \"Failed to load plugin: %s\\n\", lt_dlerror());\n    goto out;\n  }\n\n{\n  char componentsymbolname[strlen(basename)+10+1];\n  sprintf(componentsymbolname, \"%s_component\", basename);\n  component = lt_dlsym(handle, componentsymbolname);\n  if (!component) {\n    if (hwloc_plugins_verbose)\n      fprintf(stderr, \"Failed to find component symbol `%s'\\n\",\n\t      componentsymbolname);\n    goto out_with_handle;\n  }\n  if (component->abi != HWLOC_COMPONENT_ABI) {\n    if (hwloc_plugins_verbose)\n      fprintf(stderr, \"Plugin symbol ABI %u instead of %d\\n\",\n\t      component->abi, HWLOC_COMPONENT_ABI);\n    goto out_with_handle;\n  }\n  if (hwloc_plugins_verbose)\n    fprintf(stderr, \"Plugin contains expected symbol `%s'\\n\",\n\t    componentsymbolname);\n}\n\n  if (HWLOC_COMPONENT_TYPE_DISC == component->type) {\n    if (strncmp(basename, \"hwloc_\", 6)) {\n      if (hwloc_plugins_verbose)\n\tfprintf(stderr, \"Plugin name `%s' doesn't match its type DISCOVERY\\n\", basename);\n      goto out_with_handle;\n    }\n  } else if (HWLOC_COMPONENT_TYPE_XML == component->type) {\n    if (strncmp(basename, \"hwloc_xml_\", 10)) {\n      if (hwloc_plugins_verbose)\n\tfprintf(stderr, \"Plugin name `%s' doesn't match its type XML\\n\", basename);\n      goto out_with_handle;\n    }\n  } else {\n    if (hwloc_plugins_verbose)\n      fprintf(stderr, \"Plugin name `%s' has invalid type %u\\n\",\n\t      basename, (unsigned) component->type);\n    goto out_with_handle;\n  }\n\n  /* allocate a plugin_desc and queue it */\n  desc = malloc(sizeof(*desc));\n  if (!desc)\n    goto out_with_handle;\n  desc->name = strdup(basename);\n  desc->filename = strdup(filename);\n  desc->component = component;\n  desc->handle = handle;\n  desc->next = NULL;\n  if (hwloc_plugins_verbose)\n    fprintf(stderr, \"Plugin descriptor `%s' ready\\n\", basename);\n\n  /* append to the list */\n  prevdesc = &hwloc_plugins;\n  while (*prevdesc)\n    prevdesc = &((*prevdesc)->next);\n  *prevdesc = desc;\n  if (hwloc_plugins_verbose)\n    fprintf(stderr, \"Plugin descriptor `%s' queued\\n\", basename);\n  return 0;\n\n out_with_handle:\n  lt_dlclose(handle);\n out:\n  return 0;\n}\n\nstatic void\nhwloc_plugins_exit(void)\n{\n  struct hwloc__plugin_desc *desc, *next;\n\n  if (hwloc_plugins_verbose)\n    fprintf(stderr, \"Closing all plugins\\n\");\n\n  desc = hwloc_plugins;\n  while (desc) {\n    next = desc->next;\n    lt_dlclose(desc->handle);\n    free(desc->name);\n    free(desc->filename);\n    free(desc);\n    desc = next;\n  }\n  hwloc_plugins = NULL;\n\n  lt_dlexit();\n}\n\nstatic int\nhwloc_plugins_init(void)\n{\n  const char *verboseenv;\n  const char *path = HWLOC_PLUGINS_PATH;\n  const char *env;\n  int err;\n\n  verboseenv = getenv(\"HWLOC_PLUGINS_VERBOSE\");\n  hwloc_plugins_verbose = verboseenv ? atoi(verboseenv) : 0;\n\n  hwloc_plugins_blacklist = getenv(\"HWLOC_PLUGINS_BLACKLIST\");\n\n  err = lt_dlinit();\n  if (err)\n    goto out;\n\n  env = getenv(\"HWLOC_PLUGINS_PATH\");\n  if (env)\n    path = env;\n\n  hwloc_plugins = NULL;\n\n  if (hwloc_plugins_verbose)\n    fprintf(stderr, \"Starting plugin dlforeach in %s\\n\", path);\n  err = lt_dlforeachfile(path, hwloc__dlforeach_cb, NULL);\n  if (err)\n    goto out_with_init;\n\n  return 0;\n\n out_with_init:\n  hwloc_plugins_exit();\n out:\n  return -1;\n}\n\n#endif /* HWLOC_HAVE_PLUGINS */\n\nstatic const char *\nhwloc_disc_component_type_string(hwloc_disc_component_type_t type)\n{\n  switch (type) {\n  case HWLOC_DISC_COMPONENT_TYPE_CPU: return \"cpu\";\n  case HWLOC_DISC_COMPONENT_TYPE_GLOBAL: return \"global\";\n  case HWLOC_DISC_COMPONENT_TYPE_MISC: return \"misc\";\n  default: return \"**unknown**\";\n  }\n}\n\nstatic int\nhwloc_disc_component_register(struct hwloc_disc_component *component,\n\t\t\t      const char *filename)\n{\n  struct hwloc_disc_component **prev;\n\n  /* check that the component name is valid */\n  if (!strcmp(component->name, HWLOC_COMPONENT_STOP_NAME)) {\n    if (hwloc_components_verbose)\n      fprintf(stderr, \"Cannot register discovery component with reserved name `\" HWLOC_COMPONENT_STOP_NAME \"'\\n\");\n    return -1;\n  }\n  if (strchr(component->name, HWLOC_COMPONENT_EXCLUDE_CHAR)\n      || strcspn(component->name, HWLOC_COMPONENT_SEPS) != strlen(component->name)) {\n    if (hwloc_components_verbose)\n      fprintf(stderr, \"Cannot register discovery component with name `%s' containing reserved characters `%c\" HWLOC_COMPONENT_SEPS \"'\\n\",\n\t      component->name, HWLOC_COMPONENT_EXCLUDE_CHAR);\n    return -1;\n  }\n  /* check that the component type is valid */\n  switch ((unsigned) component->type) {\n  case HWLOC_DISC_COMPONENT_TYPE_CPU:\n  case HWLOC_DISC_COMPONENT_TYPE_GLOBAL:\n  case HWLOC_DISC_COMPONENT_TYPE_MISC:\n    break;\n  default:\n    fprintf(stderr, \"Cannot register discovery component `%s' with unknown type %u\\n\",\n\t    component->name, (unsigned) component->type);\n    return -1;\n  }\n\n  prev = &hwloc_disc_components;\n  while (NULL != *prev) {\n    if (!strcmp((*prev)->name, component->name)) {\n      /* if two components have the same name, only keep the highest priority one */\n      if ((*prev)->priority < component->priority) {\n\t/* drop the existing component */\n\tif (hwloc_components_verbose)\n\t  fprintf(stderr, \"Dropping previously registered discovery component `%s', priority %u lower than new one %u\\n\",\n\t\t  (*prev)->name, (*prev)->priority, component->priority);\n\t*prev = (*prev)->next;\n      } else {\n\t/* drop the new one */\n\tif (hwloc_components_verbose)\n\t  fprintf(stderr, \"Ignoring new discovery component `%s', priority %u lower than previously registered one %u\\n\",\n\t\t  component->name, component->priority, (*prev)->priority);\n\treturn -1;\n      }\n    }\n    prev = &((*prev)->next);\n  }\n  if (hwloc_components_verbose)\n    fprintf(stderr, \"Registered %s discovery component `%s' with priority %u (%s%s)\\n\",\n\t    hwloc_disc_component_type_string(component->type), component->name, component->priority,\n\t    filename ? \"from plugin \" : \"statically build\", filename ? filename : \"\");\n\n  prev = &hwloc_disc_components;\n  while (NULL != *prev) {\n    if ((*prev)->priority < component->priority)\n      break;\n    prev = &((*prev)->next);\n  }\n  component->next = *prev;\n  *prev = component;\n  return 0;\n}\n\n#include <static-components.h>\n\nstatic void (**hwloc_component_finalize_cbs)(unsigned long);\nstatic unsigned hwloc_component_finalize_cb_count;\n\nvoid\nhwloc_components_init(void)\n{\n#ifdef HWLOC_HAVE_PLUGINS\n  struct hwloc__plugin_desc *desc;\n#endif\n  const char *verboseenv;\n  unsigned i;\n\n  HWLOC_COMPONENTS_LOCK();\n  assert((unsigned) -1 != hwloc_components_users);\n  if (0 != hwloc_components_users++) {\n    HWLOC_COMPONENTS_UNLOCK();\n    return;\n  }\n\n  verboseenv = getenv(\"HWLOC_COMPONENTS_VERBOSE\");\n  hwloc_components_verbose = verboseenv ? atoi(verboseenv) : 0;\n\n#ifdef HWLOC_HAVE_PLUGINS\n  hwloc_plugins_init();\n#endif\n\n  hwloc_component_finalize_cbs = NULL;\n  hwloc_component_finalize_cb_count = 0;\n  /* count the max number of finalize callbacks */\n  for(i=0; NULL != hwloc_static_components[i]; i++)\n    hwloc_component_finalize_cb_count++;\n#ifdef HWLOC_HAVE_PLUGINS\n  for(desc = hwloc_plugins; NULL != desc; desc = desc->next)\n    hwloc_component_finalize_cb_count++;\n#endif\n  if (hwloc_component_finalize_cb_count) {\n    hwloc_component_finalize_cbs = calloc(hwloc_component_finalize_cb_count,\n\t\t\t\t\t  sizeof(*hwloc_component_finalize_cbs));\n    assert(hwloc_component_finalize_cbs);\n    /* forget that max number and recompute the real one below */\n    hwloc_component_finalize_cb_count = 0;\n  }\n\n  /* hwloc_static_components is created by configure in static-components.h */\n  for(i=0; NULL != hwloc_static_components[i]; i++) {\n    if (hwloc_static_components[i]->flags) {\n      fprintf(stderr, \"Ignoring static component with invalid flags %lx\\n\",\n\t      hwloc_static_components[i]->flags);\n      continue;\n    }\n\n    /* initialize the component */\n    if (hwloc_static_components[i]->init && hwloc_static_components[i]->init(0) < 0) {\n      if (hwloc_components_verbose)\n\tfprintf(stderr, \"Ignoring static component, failed to initialize\\n\");\n      continue;\n    }\n    /* queue ->finalize() callback if any */\n    if (hwloc_static_components[i]->finalize)\n      hwloc_component_finalize_cbs[hwloc_component_finalize_cb_count++] = hwloc_static_components[i]->finalize;\n\n    /* register for real now */\n    if (HWLOC_COMPONENT_TYPE_DISC == hwloc_static_components[i]->type)\n      hwloc_disc_component_register(hwloc_static_components[i]->data, NULL);\n    else if (HWLOC_COMPONENT_TYPE_XML == hwloc_static_components[i]->type)\n      hwloc_xml_callbacks_register(hwloc_static_components[i]->data);\n    else\n      assert(0);\n  }\n\n  /* dynamic plugins */\n#ifdef HWLOC_HAVE_PLUGINS\n  for(desc = hwloc_plugins; NULL != desc; desc = desc->next) {\n    if (desc->component->flags) {\n      fprintf(stderr, \"Ignoring plugin `%s' component with invalid flags %lx\\n\",\n\t      desc->name, desc->component->flags);\n      continue;\n    }\n\n    /* initialize the component */\n    if (desc->component->init && desc->component->init(0) < 0) {\n      if (hwloc_components_verbose)\n\tfprintf(stderr, \"Ignoring plugin `%s', failed to initialize\\n\", desc->name);\n      continue;\n    }\n    /* queue ->finalize() callback if any */\n    if (desc->component->finalize)\n      hwloc_component_finalize_cbs[hwloc_component_finalize_cb_count++] = desc->component->finalize;\n\n    /* register for real now */\n    if (HWLOC_COMPONENT_TYPE_DISC == desc->component->type)\n      hwloc_disc_component_register(desc->component->data, desc->filename);\n    else if (HWLOC_COMPONENT_TYPE_XML == desc->component->type)\n      hwloc_xml_callbacks_register(desc->component->data);\n    else\n      assert(0);\n  }\n#endif\n\n  HWLOC_COMPONENTS_UNLOCK();\n}\n\nvoid\nhwloc_backends_init(struct hwloc_topology *topology)\n{\n  topology->backends = NULL;\n  topology->backend_excludes = 0;\n}\n\nstatic struct hwloc_disc_component *\nhwloc_disc_component_find(int type /* hwloc_disc_component_type_t or -1 if any */,\n\t\t\t       const char *name /* name of NULL if any */)\n{\n  struct hwloc_disc_component *comp = hwloc_disc_components;\n  while (NULL != comp) {\n    if ((-1 == type || type == (int) comp->type)\n       && (NULL == name || !strcmp(name, comp->name)))\n      return comp;\n    comp = comp->next;\n  }\n  return NULL;\n}\n\n/* used by set_xml(), set_synthetic(), ... environment variables, ... to force the first backend */\nint\nhwloc_disc_component_force_enable(struct hwloc_topology *topology,\n\t\t\t\t  int envvar_forced,\n\t\t\t\t  int type, const char *name,\n\t\t\t\t  const void *data1, const void *data2, const void *data3)\n{\n  struct hwloc_disc_component *comp;\n  struct hwloc_backend *backend;\n\n  if (topology->is_loaded) {\n    errno = EBUSY;\n    return -1;\n  }\n\n  comp = hwloc_disc_component_find(type, name);\n  if (!comp) {\n    errno = ENOSYS;\n    return -1;\n  }\n\n  backend = comp->instantiate(comp, data1, data2, data3);\n  if (backend) {\n    backend->envvar_forced = envvar_forced;\n    if (topology->backends)\n      hwloc_backends_disable_all(topology);\n    return hwloc_backend_enable(topology, backend);\n  } else\n    return -1;\n}\n\nstatic int\nhwloc_disc_component_try_enable(struct hwloc_topology *topology,\n\t\t\t\tstruct hwloc_disc_component *comp,\n\t\t\t\tconst char *comparg,\n\t\t\t\tint envvar_forced)\n{\n  struct hwloc_backend *backend;\n\n  if (topology->backend_excludes & comp->type) {\n    if (hwloc_components_verbose)\n      /* do not warn if envvar_forced since system-wide HWLOC_COMPONENTS must be silently ignored after set_xml() etc.\n       */\n      fprintf(stderr, \"Excluding %s discovery component `%s', conflicts with excludes 0x%x\\n\",\n\t      hwloc_disc_component_type_string(comp->type), comp->name, topology->backend_excludes);\n    return -1;\n  }\n\n  backend = comp->instantiate(comp, comparg, NULL, NULL);\n  if (!backend) {\n    if (hwloc_components_verbose || envvar_forced)\n      fprintf(stderr, \"Failed to instantiate discovery component `%s'\\n\", comp->name);\n    return -1;\n  }\n\n  backend->envvar_forced = envvar_forced;\n  return hwloc_backend_enable(topology, backend);\n}\n\nvoid\nhwloc_disc_components_enable_others(struct hwloc_topology *topology)\n{\n  struct hwloc_disc_component *comp;\n  struct hwloc_backend *backend;\n  int tryall = 1;\n  const char *_env;\n  char *env; /* we'll to modify the env value, so duplicate it */\n\n  _env = getenv(\"HWLOC_COMPONENTS\");\n  env = _env ? strdup(_env) : NULL;\n\n  /* enable explicitly listed components */\n  if (env) {\n    char *curenv = env;\n    size_t s;\n\n    while (*curenv) {\n      s = strcspn(curenv, HWLOC_COMPONENT_SEPS);\n      if (s) {\n\tchar c;\n\n\t/* replace linuxpci with linuxio for backward compatibility with pre-v2.0 */\n\tif (!strncmp(curenv, \"linuxpci\", 8) && s == 8) {\n\t  curenv[5] = 'i';\n\t  curenv[6] = 'o';\n\t  curenv[7] = *HWLOC_COMPONENT_SEPS;\n\t} else if (curenv[0] == HWLOC_COMPONENT_EXCLUDE_CHAR && !strncmp(curenv+1, \"linuxpci\", 8) && s == 9) {\n\t  curenv[6] = 'i';\n\t  curenv[7] = 'o';\n\t  curenv[8] = *HWLOC_COMPONENT_SEPS;\n\t  /* skip this name, it's a negated one */\n\t  goto nextname;\n\t}\n\n\tif (curenv[0] == HWLOC_COMPONENT_EXCLUDE_CHAR)\n\t  goto nextname;\n\n\tif (!strncmp(curenv, HWLOC_COMPONENT_STOP_NAME, s)) {\n\t  tryall = 0;\n\t  break;\n\t}\n\n\t/* save the last char and replace with \\0 */\n\tc = curenv[s];\n\tcurenv[s] = '\\0';\n\n\tcomp = hwloc_disc_component_find(-1, curenv);\n\tif (comp) {\n\t  hwloc_disc_component_try_enable(topology, comp, NULL, 1 /* envvar forced */);\n\t} else {\n\t  fprintf(stderr, \"Cannot find discovery component `%s'\\n\", curenv);\n\t}\n\n\t/* restore chars (the second loop below needs env to be unmodified) */\n\tcurenv[s] = c;\n      }\n\nnextname:\n      curenv += s;\n      if (*curenv)\n\t/* Skip comma */\n\tcurenv++;\n    }\n  }\n\n  /* env is still the same, the above loop didn't modify it */\n\n  /* now enable remaining components (except the explicitly '-'-listed ones) */\n  if (tryall) {\n    comp = hwloc_disc_components;\n    while (NULL != comp) {\n      if (!comp->enabled_by_default)\n\tgoto nextcomp;\n      /* check if this component was explicitly excluded in env */\n      if (env) {\n\tchar *curenv = env;\n\twhile (*curenv) {\n\t  size_t s = strcspn(curenv, HWLOC_COMPONENT_SEPS);\n\t  if (curenv[0] == HWLOC_COMPONENT_EXCLUDE_CHAR && !strncmp(curenv+1, comp->name, s-1) && strlen(comp->name) == s-1) {\n\t    if (hwloc_components_verbose)\n\t      fprintf(stderr, \"Excluding %s discovery component `%s' because of HWLOC_COMPONENTS environment variable\\n\",\n\t    hwloc_disc_component_type_string(comp->type), comp->name);\n\t    goto nextcomp;\n\t  }\n\t  curenv += s;\n\t  if (*curenv)\n\t    /* Skip comma */\n\t    curenv++;\n\t}\n      }\n      hwloc_disc_component_try_enable(topology, comp, NULL, 0 /* defaults, not envvar forced */);\nnextcomp:\n      comp = comp->next;\n    }\n  }\n\n  if (hwloc_components_verbose) {\n    /* print a summary */\n    int first = 1;\n    backend = topology->backends;\n    fprintf(stderr, \"Final list of enabled discovery components: \");\n    while (backend != NULL) {\n      fprintf(stderr, \"%s%s\", first ? \"\" : \",\", backend->component->name);\n      backend = backend->next;\n      first = 0;\n    }\n    fprintf(stderr, \"\\n\");\n  }\n\n  free(env);\n}\n\nvoid\nhwloc_components_fini(void)\n{\n  unsigned i;\n\n  HWLOC_COMPONENTS_LOCK();\n  assert(0 != hwloc_components_users);\n  if (0 != --hwloc_components_users) {\n    HWLOC_COMPONENTS_UNLOCK();\n    return;\n  }\n\n  for(i=0; i<hwloc_component_finalize_cb_count; i++)\n    hwloc_component_finalize_cbs[hwloc_component_finalize_cb_count-i-1](0);\n  free(hwloc_component_finalize_cbs);\n  hwloc_component_finalize_cbs = NULL;\n  hwloc_component_finalize_cb_count = 0;\n\n  /* no need to unlink/free the list of components, they'll be unloaded below */\n\n  hwloc_disc_components = NULL;\n  hwloc_xml_callbacks_reset();\n\n#ifdef HWLOC_HAVE_PLUGINS\n  hwloc_plugins_exit();\n#endif\n\n  HWLOC_COMPONENTS_UNLOCK();\n}\n\nstruct hwloc_backend *\nhwloc_backend_alloc(struct hwloc_disc_component *component)\n{\n  struct hwloc_backend * backend = malloc(sizeof(*backend));\n  if (!backend) {\n    errno = ENOMEM;\n    return NULL;\n  }\n  backend->component = component;\n  backend->flags = 0;\n  backend->discover = NULL;\n  backend->get_pci_busid_cpuset = NULL;\n  backend->disable = NULL;\n  backend->is_thissystem = -1;\n  backend->next = NULL;\n  backend->envvar_forced = 0;\n  return backend;\n}\n\nstatic void\nhwloc_backend_disable(struct hwloc_backend *backend)\n{\n  if (backend->disable)\n    backend->disable(backend);\n  free(backend);\n}\n\nint\nhwloc_backend_enable(struct hwloc_topology *topology, struct hwloc_backend *backend)\n{\n  struct hwloc_backend **pprev;\n\n  /* check backend flags */\n  if (backend->flags) {\n    fprintf(stderr, \"Cannot enable %s discovery component `%s' with unknown flags %lx\\n\",\n\t    hwloc_disc_component_type_string(backend->component->type), backend->component->name, backend->flags);\n    return -1;\n  }\n\n  /* make sure we didn't already enable this backend, we don't want duplicates */\n  pprev = &topology->backends;\n  while (NULL != *pprev) {\n    if ((*pprev)->component == backend->component) {\n      if (hwloc_components_verbose)\n\tfprintf(stderr, \"Cannot enable %s discovery component `%s' twice\\n\",\n\t\thwloc_disc_component_type_string(backend->component->type), backend->component->name);\n      hwloc_backend_disable(backend);\n      errno = EBUSY;\n      return -1;\n    }\n    pprev = &((*pprev)->next);\n  }\n\n  if (hwloc_components_verbose)\n    fprintf(stderr, \"Enabling %s discovery component `%s'\\n\",\n\t    hwloc_disc_component_type_string(backend->component->type), backend->component->name);\n\n  /* enqueue at the end */\n  pprev = &topology->backends;\n  while (NULL != *pprev)\n    pprev = &((*pprev)->next);\n  backend->next = *pprev;\n  *pprev = backend;\n\n  backend->topology = topology;\n  topology->backend_excludes |= backend->component->excludes;\n  return 0;\n}\n\nvoid\nhwloc_backends_is_thissystem(struct hwloc_topology *topology)\n{\n  struct hwloc_backend *backend;\n  const char *local_env;\n\n  /* Apply is_thissystem topology flag before we enforce envvar backends.\n   * If the application changed the backend with set_foo(),\n   * it may use set_flags() update the is_thissystem flag here.\n   * If it changes the backend with environment variables below,\n   * it may use HWLOC_THISSYSTEM envvar below as well.\n   */\n\n  topology->is_thissystem = 1;\n\n  /* apply thissystem from normally-given backends (envvar_forced=0, either set_foo() or defaults) */\n  backend = topology->backends;\n  while (backend != NULL) {\n    if (backend->envvar_forced == 0 && backend->is_thissystem != -1) {\n      assert(backend->is_thissystem == 0);\n      topology->is_thissystem = 0;\n    }\n    backend = backend->next;\n  }\n\n  /* override set_foo() with flags */\n  if (topology->flags & HWLOC_TOPOLOGY_FLAG_IS_THISSYSTEM)\n    topology->is_thissystem = 1;\n\n  /* now apply envvar-forced backend (envvar_forced=1) */\n  backend = topology->backends;\n  while (backend != NULL) {\n    if (backend->envvar_forced == 1 && backend->is_thissystem != -1) {\n      assert(backend->is_thissystem == 0);\n      topology->is_thissystem = 0;\n    }\n    backend = backend->next;\n  }\n\n  /* override with envvar-given flag */\n  local_env = getenv(\"HWLOC_THISSYSTEM\");\n  if (local_env)\n    topology->is_thissystem = atoi(local_env);\n}\n\nvoid\nhwloc_backends_find_callbacks(struct hwloc_topology *topology)\n{\n  struct hwloc_backend *backend = topology->backends;\n  /* use the first backend's get_pci_busid_cpuset callback */\n  topology->get_pci_busid_cpuset_backend = NULL;\n  while (backend != NULL) {\n    if (backend->get_pci_busid_cpuset) {\n      topology->get_pci_busid_cpuset_backend = backend;\n      return;\n    }\n    backend = backend->next;\n  }\n  return;\n}\n\nvoid\nhwloc_backends_disable_all(struct hwloc_topology *topology)\n{\n  struct hwloc_backend *backend;\n\n  while (NULL != (backend = topology->backends)) {\n    struct hwloc_backend *next = backend->next;\n    if (hwloc_components_verbose)\n      fprintf(stderr, \"Disabling %s discovery component `%s'\\n\",\n\t      hwloc_disc_component_type_string(backend->component->type), backend->component->name);\n    hwloc_backend_disable(backend);\n    topology->backends = next;\n  }\n  topology->backends = NULL;\n  topology->backend_excludes = 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/contrib/hwloc-valgrind.supp": "# Copyright \u00a9 2012-2018 Inria.  All rights reserved.\n# See COPYING in top-level directory.\n\n# suppressions file to be passed to valgrind with\n#   --suppressions=/path/to/hwloc-valgrind.supp\n\n# zlib (brought by libpci or libxml2) doesn't cleanup its global state\n{\n   inflate_init\n   Memcheck:Cond\n   fun:inflateReset2\n   fun:inflateInit2_\n}\n\n# hwloc cannot free the global parser (with xmlCleanupParser()) because other threads may be using it\n{\n   xml_init_parser\n   Memcheck:Leak\n   ...\n   fun:xmlInitParser\n}\n\n# hwloc cannot free the global xml dict RMutex because it cannot call xmlCleanupParser() as explained above\n{\n   xml_dict_create_new_rmutex\n   Memcheck:Leak\n   fun:malloc\n   fun:xmlNewRMutex\n   ...\n   fun:xmlDictCreate\n}\n\n# ltdl dlopen global state?\n{\n   ltdl_dlopen_doit_leak\n   Memcheck:Leak\n   ...\n   fun:dl_open_worker\n   fun:_dl_catch_error\n   fun:_dl_open\n   fun:dlopen_doit\n}\n\n# ltdl_dlclose_leak\n{\n   ltdl_dlclose_leak\n   Memcheck:Leak\n   ...\n   fun:_dl_close_worker\n   fun:_dl_close\n   ...\n   fun:dlclose\n}\n\n# lt_dlforeachfile abusing paths\n{\n   lt_dlforeachfile_addr8\n   Memcheck:Addr8\n   fun:_wordcopy_fwd_dest_aligned\n   fun:__GI_memmove\n   fun:argz_insert\n   ...\n   fun:lt_dlforeachfile\n}\n\n# cuda\n{\n   cuda_leak\n   Memcheck:Leak\n   ...\n   obj:*libcuda*\n}\n\n# nvml\n{\n   nvmlInit_cond\n   Memcheck:Cond\n   ...\n   obj:*nvidia-ml*\n   ...\n   fun:nvmlInit\n}\n\n# amd opencl\n{\n   atical_leak\n   Memcheck:Leak\n   ...\n   obj:*libatical*\n}\n{\n   atical_cond\n   Memcheck:Cond\n   ...\n   obj:*libatical*\n}\n{\n   amdocl_leak\n   Memcheck:Leak\n   ...\n   obj:*libamdocl*\n}\n{\n   amdocl_param\n   Memcheck:Param\n   write(buf)\n   fun:*write*\n   obj:*libamdocl*\n}\n{\n   opencl_leak\n   Memcheck:Leak\n   ...\n   obj:*libOpenCL*\n   ...\n   fun:clGetPlatformIDs\n}\n{\n   libatiadl_xcb_leak\n   Memcheck:Leak\n   ...\n   obj:*libxcb*\n   ...\n   fun:XOpenDisplay\n   ...\n   obj:*libatiadl*\n}\n\n#  libpciaccess global state leak\n{\n   libpciaccess_device_name_leak\n   Memcheck:Leak\n   ...\n   fun:pci_device_get_device_name\n   fun:hwloc_look_pci\n}\n{\n   libpciaccess_leak\n   Memcheck:Leak\n   ...\n   obj:*libpciaccess*\n   ...\n   fun:hwloc_look_pci\n}\n\n# libudev global hashes\n{\n   libudev_hashmap_property\n   Memcheck:Leak\n   fun:malloc\n   ...\n   fun:udev_device_get_property_value\n}\n{\n   libudev_hashmap_sysname\n   Memcheck:Leak\n   fun:malloc\n   ...\n   fun:udev_device_new_from_subsystem_sysname\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/ucx/.gitignore": ".gitignore\n.project\n.cproject\n.settings\nTAGS\ntest/test\nMakefile\nMakefile.in\naclocal.m4\ncompile\nconfig.guess\nconfig.h.in\nconfig.h.in~\nconfig.sub\nconfig/m4/libtool.m4\nconfig/m4/ltoptions.m4\nconfig/m4/ltsugar.m4\nconfig/m4/ltversion.m4\nconfig/m4/lt~obsolete.m4\nconfig/aux\nconfigure\ninstall-sh\nltmain.sh\nmissing\nconfig.h\nconfig.log\nconfig.status\nlibtool\nstamp-h1\nsrc/uct/api/version.h\nautom4te.cache\ndepcomp\n.libs\n*.la\n.deps\n.dirstamp\n*.lo\n*.o\ncontrib/rpmdef.sh\nbindings/java/pom.xml\nsrc/ucs/ucs_stats_parser\ntest/gtest/gtest\ntest/perf/ucx_perftest\nbuild-*\nucx*tar.gz\nsrc/tools/info/build_config.h\nsrc/tools/info/ucx_info\nsrc/tools/perf/ucx_perftest\nsrc/tools/profile/ucx_read_profile\ntest/apps/test_dlopen_cfg_print\ntest/apps/test_link_map\ntest/apps/test_ucp_dlopen\ntest/apps/test_ucs_dlopen\ntest/apps/sockaddr/sa\ntest/examples/ucp_client_server\ntest/examples/ucp_hello_world\ntest/examples/uct_hello_world\ntest/examples/ucx_profiling\nrpm-dist\ncov_build*\ndebian/changelog\ndebian/control\ndebian/rules\ndebian/ucx.postinst\nucx.spec\nucx.pc\ndoc/doxygen-doc\ndoc/uml/uct.pdf\ndoc/doxygen/header.tex\ntest-driver\nsrc/ucp/api/ucp_version.h\nsrc/ucp/core/ucp_version.c\ntest/mpi/run_mpi.sh\n*.tap\nvalgrind.xml\ntags\n.pydevproject\n/ucx-*.*.*\n/v*.*.*\norg_openucx_jucx_*.h\nGPATH\nGRTAGS\nGTAGS\n/modules\n*.swp\ncompile_commands.json\ndocs/_build\n",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/ucx/config/m4/ucs.m4": "#\n# Copyright (C) Mellanox Technologies Ltd. 2001-2014.  ALL RIGHTS RESERVED.\n# Copyright (C) UT-Battelle, LLC. 2015. ALL RIGHTS RESERVED.\n# Copyright (C) ARM, Ltd. 2016. ALL RIGHTS RESERVED.\n# See file LICENSE for terms.\n#\n\n\n#\n# Internal profiling support.\n# This option may affect perofrmance so it is off by default.\n#\nAC_ARG_ENABLE([profiling],\n\tAS_HELP_STRING([--enable-profiling], [Enable profiling support, default: NO]),\n\t[],\n\t[enable_profiling=no])\n\nAS_IF([test \"x$enable_profiling\" = xyes],\n\t[AS_MESSAGE([enabling profiling])\n\t AC_DEFINE([HAVE_PROFILING], [1], [Enable profiling])\n\t HAVE_PROFILING=yes]\n\t[:]\n)\nAM_CONDITIONAL([HAVE_PROFILING],[test \"x$HAVE_PROFILING\" = \"xyes\"])\n\n\n#\n# Detailed backtrace with debug information.\n# This option requires binutils-devel package.\n#\nAC_ARG_ENABLE([backtrace-detail],\n\tAS_HELP_STRING([--disable-backtrace-detail], [Disable detailed backtrace support, default: NO]),\n\t[],\n\t[enable_backtrace_detail=yes])\n\t\nAS_IF([test \"x$enable_backtrace_detail\" = xyes],\n\t[\n\tBT=1\n\tAC_CHECK_HEADER([bfd.h], [], [AC_MSG_WARN([binutils headers not found])]; BT=0)\n\tAC_CHECK_LIB(bfd, bfd_openr,  LIBS=\"$LIBS -lbfd\", [AC_MSG_WARN([bfd library not found])];BT=0)\n\tAC_CHECK_LIB(dl, dlopen, LIBS=\"$LIBS -ldl\", [AC_MSG_WARN([dl library not found])];BT=0)\n\tAC_CHECK_LIB(intl, main, LIBS=\"$LIBS -lintl\", [AC_MSG_WARN([intl library not found])])\n\tAC_CHECK_TYPES([struct dl_phdr_info], [], [AC_MSG_WARN([struct dl_phdr_info not defined])];BT=0,\n\t\t\t\t\t[#define _GNU_SOURCE 1\n\t\t\t\t\t #include <link.h>]) \n\tAC_CHECK_DECLS([bfd_get_section_flags, bfd_section_flags, bfd_get_section_vma, bfd_section_vma],\n\t\t       [], [], [#include <bfd.h>])\n\n\tAC_MSG_CHECKING([bfd_section_size API version])\n\tAC_LANG_PUSH([C])\n\tSAVE_CFLAGS=\"$CFLAGS\"\n\tAC_COMPILE_IFELSE([AC_LANG_SOURCE([[\n\t\t#include <bfd.h>\n\t\tint main(int argc, char** argv) {\n\t\t\tasection *sec = malloc(sizeof(*sec));\n\t\t\tbfd_section_size(sec);\n\t\t\tfree(sec);\n\t\t\treturn 0;\n\t\t} ]])],\n\t\t[AC_MSG_RESULT([1-arg API])\n\t\t AC_DEFINE([HAVE_1_ARG_BFD_SECTION_SIZE], [1],\n\t\t\t   [bfd_section_size 1-arg version])],\n\t\t[AC_MSG_RESULT([2-args API])\n\t\t AC_DEFINE([HAVE_1_ARG_BFD_SECTION_SIZE], [0],\n\t\t\t   [bfd_section_size 2-args version])])\n\tCFLAGS=\"$SAVE_CFLAGS\"\n\tAC_LANG_POP([C])\n\n\tif test \"x$BT\" = \"x1\"; then\n\t\tAC_CHECK_FUNCS([cplus_demangle])\n\t\tAC_DEFINE([HAVE_DETAILED_BACKTRACE], 1, [Enable detailed backtrace])\n        case ${host} in\n            aarch64*) CFLAGS=\"$CFLAGS -funwind-tables\" ;;\n        esac\n\telse\n\t\tAC_MSG_WARN([detailed backtrace is not supported])\n\tfi\n\t]\n)\n\n\n#\n# Enable statistics and counters\n#\nAC_ARG_ENABLE([stats],\n\tAS_HELP_STRING([--enable-stats], \n\t               [Enable statistics, useful for profiling, default: NO]),\n\t[],\n\t[enable_stats=no])\n\t\nAS_IF([test \"x$enable_stats\" = xyes],\n\t  [AS_MESSAGE([enabling statistics])\n\t   AC_DEFINE([ENABLE_STATS], [1], [Enable statistics])\n\t   HAVE_STATS=yes],\n\t  [:]\n  )\nAM_CONDITIONAL([HAVE_STATS],[test \"x$HAVE_STATS\" = \"xyes\"])\n\n\n#\n# Enable tuning params at runtime\n#\nAC_ARG_ENABLE([tuning],\n\tAS_HELP_STRING([--enable-tuning], \n\t               [Enable parameter tuning in run-time, default: NO]),\n\t[],\n\t[enable_tuning=no])\n\t\nAS_IF([test \"x$enable_tuning\" = xyes],\n\t  [AS_MESSAGE([enabling tuning])\n\t   AC_DEFINE([ENABLE_TUNING], [1], [Enable tuning])\n\t   HAVE_TUNING=yes],\n\t  [:]\n  )\nAM_CONDITIONAL([HAVE_TUNING],[test \"x$HAVE_TUNING\" = \"xyes\"])\n\n\n#\n# Enable memory tracking\n#\nAC_ARG_ENABLE([memtrack],\n\tAS_HELP_STRING([--enable-memtrack], \n\t               [Enable memory tracking, useful for profiling, default: NO]),\n\t[],\n\t[enable_memtrack=no])\n\t\nAS_IF([test \"x$enable_memtrack\" = xyes],\n\t  [AS_MESSAGE([enabling memory tracking])\n\t   AC_DEFINE([ENABLE_MEMTRACK], [1], [Enable memory tracking])\n\t   HAVE_MEMTRACK=yes],\n\t  [:]\n  )\nAM_CONDITIONAL([HAVE_MEMTRACK],[test \"x$HAVE_MEMTRACK\" = \"xyes\"])\n\n\n#\n# Disable logging levels below INFO\n#\nAC_ARG_ENABLE([logging],\n\tAS_HELP_STRING([--enable-logging],\n\t               [Enable debug logging, default: YES])\n\t)\n\nAS_IF([test \"x$enable_logging\" != xno],\n        [AC_DEFINE([UCS_MAX_LOG_LEVEL], [UCS_LOG_LEVEL_TRACE_POLL], [Highest log level])],\n        [AC_DEFINE([UCS_MAX_LOG_LEVEL], [UCS_LOG_LEVEL_INFO], [Highest log level])]\n    )\n\n#\n# Disable assertions\n#\nAC_ARG_ENABLE([assertions],\n\tAS_HELP_STRING([--disable-assertions], \n\t               [Disable code assertions, default: NO])\n\t)\n\nAS_IF([test \"x$enable_assertions\" != xno],\n\t\tAC_DEFINE([ENABLE_ASSERT], [1], [Enable assertions])\n\t)\n\n#\n# Check if __attribute__((constructor)) works\n#\nAC_MSG_CHECKING([__attribute__((constructor))])\nCHECK_CROSS_COMP([AC_LANG_SOURCE([static int rc = 1;\n                  static void constructor_test() __attribute__((constructor));\n                  static void constructor_test() { rc = 0; }\n                  int main(int argc, char** argv) { return rc; }])],\n                [AC_MSG_RESULT([yes])],\n                [AC_MSG_ERROR([Cannot continue. Please use compiler that\n                             supports __attribute__((constructor))])]\n                )\n\n\n#\n# Manual configuration of cacheline size\n#\nAC_ARG_WITH([cache-line-size],\n        [AC_HELP_STRING([--with-cache-line-size=SIZE],\n            [Build UCX with cache line size defined by user. This parameter\n             overwrites default cache line sizes defines in\n             UCX (x86-64: 64, Power: 128, ARMv8: 64/128). The supported values are: 64, 128])],\n        [],\n        [with_cache_line_size=no])\n\nAS_IF([test \"x$with_cache_line_size\" != xno],[\n\t     case ${with_cache_line_size} in\n                 64)\n\t\t     AC_MSG_RESULT(The cache line size is set to 64B)\n\t\t     AC_DEFINE([HAVE_CACHE_LINE_SIZE], 64, [user defined cache line size])\n\t\t     ;;\n\t\t 128)\n\t\t     AC_MSG_RESULT(The cache line size is set to 128B)\n\t\t     AC_DEFINE([HAVE_CACHE_LINE_SIZE], 128, [user defined cache line size])\n\t\t     ;;\n\t\t @<:@0-9@:>@*)\n\t\t     AC_MSG_WARN(Unusual cache cache line size was specified: [$with_cache_line_size])\n\t\t     AC_DEFINE_UNQUOTED([HAVE_CACHE_LINE_SIZE], [$with_cache_line_size], [user defined cache line size])\n\t\t     ;;\n\t\t *)\n\t\t     AC_MSG_ERROR(Cannot continue. Unsupported cache line size [$with_cache_line_size].)\n\t\t     ;;\n             esac],\n\t     [])\n\n\n#\n# Architecture specific checks\n#\ncase ${host} in\n    aarch64*)\n    AC_MSG_CHECKING([support for CNTVCT_EL0 on aarch64])\n    AC_RUN_IFELSE([AC_LANG_PROGRAM(\n                  [[#include <stdint.h>]],\n                  [[uint64_t tmp; asm volatile(\"mrs %0, cntvct_el0\" : \"=r\" (tmp));]])],\n                  [AC_MSG_RESULT([yes])]\n\t\t  [AC_DEFINE([HAVE_HW_TIMER], [1], [high-resolution hardware timer enabled])],\n\t\t  [AC_MSG_RESULT([no])]\n\t\t  [AC_DEFINE([HAVE_HW_TIMER], [0], [high-resolution hardware timer disabled])]\n                 );;\n    *)\n    # HW timer is supported for all other architectures\n    AC_DEFINE([HAVE_HW_TIMER], [1], [high-resolution hardware timer disabled])\nesac\n\n#\n# Enable built-in memcpy\n#\nAC_ARG_ENABLE([builtin-memcpy],\n\tAS_HELP_STRING([--enable-builtin-memcpy],\n\t               [Enable builtin memcpy routine, default: YES]),\n\t[],\n\t[enable_builtin_memcpy=yes])\n\nAS_IF([test \"x$enable_builtin_memcpy\" != xno],\n\t  [AS_MESSAGE([enabling builtin memcpy])\n\t   AC_DEFINE([ENABLE_BUILTIN_MEMCPY], [1], [Enable builtin memcpy])],\n\t  [AC_DEFINE([ENABLE_BUILTIN_MEMCPY], [0], [Enable builtin memcpy])]\n  )\n\nAC_CHECK_FUNCS([__clear_cache], [], [])\nAC_CHECK_FUNCS([__aarch64_sync_cache_range], [], [])\n",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/ucx/src/ucm/util/sys.c": "/**\n * Copyright (C) Mellanox Technologies Ltd. 2001-2016.  ALL RIGHTS RESERVED.\n *\n * See file LICENSE for terms.\n */\n\n#ifndef _GNU_SOURCE\n#  define _GNU_SOURCE /* for dladdr */\n#endif\n\n#include \"sys.h\"\n\n#ifdef HAVE_CONFIG_H\n#  include \"config.h\"\n#endif\n\n#include <ucm/api/ucm.h>\n#include <ucm/util/log.h>\n#include <ucm/event/event.h>\n#include <ucm/mmap/mmap.h>\n#include <ucs/sys/math.h>\n#include <ucs/sys/topo.h>\n#include <linux/mman.h>\n#include <sys/mman.h>\n#include <pthread.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dlfcn.h>\n\n\n#define UCM_PROC_SELF_MAPS \"/proc/self/maps\"\n\nucm_global_config_t ucm_global_opts = {\n    .log_level                  = UCS_LOG_LEVEL_WARN,\n    .enable_events              = 1,\n    .mmap_hook_mode             = UCM_DEFAULT_HOOK_MODE,\n    .enable_malloc_hooks        = 1,\n    .enable_malloc_reloc        = 0,\n    .enable_cuda_reloc          = 1,\n    .enable_dynamic_mmap_thresh = 1,\n    .alloc_alignment            = 16,\n    .dlopen_process_rpath       = 1\n};\n\nsize_t ucm_get_page_size()\n{\n    static long page_size = -1;\n    long value;\n\n    if (page_size == -1) {\n        value = sysconf(_SC_PAGESIZE);\n        if (value < 0) {\n            page_size = 4096;\n        } else {\n            page_size = value;\n        }\n    }\n    return page_size;\n}\n\nstatic void *ucm_sys_complete_alloc(void *ptr, size_t size)\n{\n    *(size_t*)ptr = size;\n    return UCS_PTR_BYTE_OFFSET(ptr, sizeof(size_t));\n}\n\nvoid *ucm_sys_malloc(size_t size)\n{\n    size_t sys_size;\n    void *ptr;\n\n    sys_size = ucs_align_up_pow2(size + sizeof(size_t), ucm_get_page_size());\n    ptr = ucm_orig_mmap(NULL, sys_size, PROT_READ|PROT_WRITE,\n                        MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n    if (ptr == MAP_FAILED) {\n        ucm_error(\"mmap(size=%zu) failed: %m\", sys_size);\n        return NULL;\n    }\n\n    return ucm_sys_complete_alloc(ptr, sys_size);\n}\n\nvoid *ucm_sys_calloc(size_t nmemb, size_t size)\n{\n    size_t total_size = size * nmemb;\n    void *ptr;\n\n    ptr = ucm_sys_malloc(total_size);\n    if (ptr == NULL) {\n        return NULL;\n    }\n\n    memset(ptr, 0, total_size);\n    return ptr;\n}\n\nvoid ucm_sys_free(void *ptr)\n{\n    size_t size;\n\n    if (ptr == NULL) {\n        return;\n    }\n\n    /* Do not use UCS_PTR_BYTE_OFFSET macro here due to coverity\n     * false positive.\n     * TODO: check for false positive on newer coverity. */\n    ptr  = (char*)ptr - sizeof(size_t);\n    size = *(size_t*)ptr;\n    munmap(ptr, size);\n}\n\nvoid *ucm_sys_realloc(void *ptr, size_t size)\n{\n    size_t oldsize, sys_size;\n    void *oldptr, *newptr;\n\n    if (ptr == NULL) {\n        return ucm_sys_malloc(size);\n    }\n\n    oldptr   = UCS_PTR_BYTE_OFFSET(ptr, -sizeof(size_t));\n    oldsize  = *(size_t*)oldptr;\n    sys_size = ucs_align_up_pow2(size + sizeof(size_t), ucm_get_page_size());\n\n    if (sys_size == oldsize) {\n        return ptr;\n    }\n\n    newptr = ucm_orig_mremap(oldptr, oldsize, sys_size, MREMAP_MAYMOVE);\n    if (newptr == MAP_FAILED) {\n        ucm_error(\"mremap(oldptr=%p oldsize=%zu, newsize=%zu) failed: %m\",\n                  oldptr, oldsize, sys_size);\n        return NULL;\n    }\n\n    return ucm_sys_complete_alloc(newptr, sys_size);\n}\n\nvoid ucm_parse_proc_self_maps(ucm_proc_maps_cb_t cb, void *arg)\n{\n    static char  *buffer         = MAP_FAILED;\n    static size_t buffer_size    = 32768;\n    static pthread_rwlock_t lock = PTHREAD_RWLOCK_INITIALIZER;\n    ssize_t read_size, offset;\n    unsigned long start, end;\n    char prot_c[4];\n    int line_num;\n    int prot;\n    char *ptr, *newline;\n    int maps_fd;\n    int ret;\n    int n;\n\n    maps_fd = open(UCM_PROC_SELF_MAPS, O_RDONLY);\n    if (maps_fd < 0) {\n        ucm_fatal(\"cannot open %s for reading: %m\", UCM_PROC_SELF_MAPS);\n    }\n\n    /* read /proc/self/maps fully into the buffer */\n    pthread_rwlock_wrlock(&lock);\n\n    if (buffer == MAP_FAILED) {\n        buffer = ucm_orig_mmap(NULL, buffer_size, PROT_READ|PROT_WRITE,\n                               MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n        if (buffer == MAP_FAILED) {\n            ucm_fatal(\"failed to allocate maps buffer(size=%zu): %m\", buffer_size);\n        }\n    }\n\n    offset = 0;\n    for (;;) {\n        read_size = read(maps_fd, buffer + offset, buffer_size - offset);\n        if (read_size < 0) {\n            /* error */\n            if (errno != EINTR) {\n                ucm_fatal(\"failed to read from %s: %m\", UCM_PROC_SELF_MAPS);\n            }\n        } else if (read_size == buffer_size - offset) {\n            /* enlarge buffer */\n            buffer = ucm_orig_mremap(buffer, buffer_size, buffer_size * 2,\n                                     MREMAP_MAYMOVE);\n            if (buffer == MAP_FAILED) {\n                ucm_fatal(\"failed to allocate maps buffer(size=%zu)\", buffer_size);\n            }\n            buffer_size *= 2;\n\n            /* read again from the beginning of the file */\n            ret = lseek(maps_fd, 0, SEEK_SET);\n            if (ret < 0) {\n               ucm_fatal(\"failed to lseek(0): %m\");\n            }\n            offset = 0;\n        } else if (read_size == 0) {\n            /* finished reading */\n            buffer[offset] = '\\0';\n            break;\n        } else {\n            /* more data could be available even if the buffer is not full */\n            offset += read_size;\n        }\n    }\n    pthread_rwlock_unlock(&lock);\n\n    close(maps_fd);\n\n    pthread_rwlock_rdlock(&lock);\n\n    ptr      = buffer;\n    line_num = 1;\n    while ( (newline = strchr(ptr, '\\n')) != NULL ) {\n        /* address           perms offset   dev   inode   pathname\n         * 00400000-0040b000 r-xp  00001a00 0a:0b 12345   /dev/mydev\n         */\n        *newline = '\\0';\n        ret = sscanf(ptr, \"%lx-%lx %4c %*x %*x:%*x %*d %n\",\n                     &start, &end, prot_c,\n                     /* ignore offset, dev, inode */\n                     &n /* save number of chars before path begins */);\n        if (ret < 3) {\n            ucm_warn(\"failed to parse %s line %d: '%s'\",\n                     UCM_PROC_SELF_MAPS, line_num, ptr);\n        } else {\n            prot = 0;\n            if (prot_c[0] == 'r') {\n                prot |= PROT_READ;\n            }\n            if (prot_c[1] == 'w') {\n                prot |= PROT_WRITE;\n            }\n            if (prot_c[2] == 'x') {\n                prot |= PROT_EXEC;\n            }\n\n            if (cb(arg, (void*)start, end - start, prot, ptr + n)) {\n                goto out;\n            }\n        }\n\n        ptr = newline + 1;\n        ++line_num;\n    }\n\nout:\n    pthread_rwlock_unlock(&lock);\n}\n\ntypedef struct {\n    const void   *shmaddr;\n    size_t       seg_size;\n} ucm_get_shm_seg_size_ctx_t;\n\nstatic int ucm_get_shm_seg_size_cb(void *arg, void *addr, size_t length,\n                                   int prot, const char *path)\n{\n    ucm_get_shm_seg_size_ctx_t *ctx = arg;\n    if (addr == ctx->shmaddr) {\n        ctx->seg_size = length;\n        return 1;\n    }\n    return 0;\n}\n\nsize_t ucm_get_shm_seg_size(const void *shmaddr)\n{\n    ucm_get_shm_seg_size_ctx_t ctx = { shmaddr, 0 };\n    ucm_parse_proc_self_maps(ucm_get_shm_seg_size_cb, &ctx);\n    return ctx.seg_size;\n}\n\nvoid ucm_strerror(int eno, char *buf, size_t max)\n{\n#if STRERROR_R_CHAR_P\n    char *ret = strerror_r(eno, buf, max);\n    if (ret != buf) {\n        strncpy(buf, ret, max);\n    }\n#else\n    (void)strerror_r(eno, buf, max);\n#endif\n}\n\nvoid ucm_prevent_dl_unload()\n{\n    Dl_info info;\n    void *dl;\n    int ret;\n\n    /* Get the path to current library by current function pointer */\n    (void)dlerror();\n    ret = dladdr(ucm_prevent_dl_unload, &info);\n    if (ret == 0) {\n        ucm_warn(\"could not find address of current library: %s\", dlerror());\n        return;\n    }\n\n    /* Load the current library with NODELETE flag, to prevent it from being\n     * unloaded. This will create extra reference to the library, but also add\n     * NODELETE flag to the dynamic link map.\n     */\n    (void)dlerror();\n    dl = dlopen(info.dli_fname, RTLD_LOCAL|RTLD_LAZY|RTLD_NODELETE);\n    if (dl == NULL) {\n        ucm_warn(\"failed to load '%s': %s\", info.dli_fname, dlerror());\n        return;\n    }\n\n    ucm_debug(\"reloaded '%s' at %p with NODELETE flag\", info.dli_fname, dl);\n\n    /* Now we drop our reference to the lib, and it won't be unloaded anymore */\n    dlclose(dl);\n}\n\nchar *ucm_concat_path(char *buffer, size_t max, const char *dir, const char *file)\n{\n    size_t len;\n\n    len = strlen(dir);\n    while (len && (dir[len - 1] == '/')) {\n        len--; /* trim closing '/' */\n    }\n\n    len = ucs_min(len, max);\n    memcpy(buffer, dir, len);\n    max -= len;\n    if (max < 2) { /* buffer is shorter than dir - copy dir only */\n        buffer[len - 1] = '\\0';\n        return buffer;\n    }\n\n    buffer[len] = '/';\n    max--;\n\n    while (file[0] == '/') {\n        file++; /* trim beginning '/' */\n    }\n\n    strncpy(buffer + len + 1, file, max);\n    buffer[max + len] = '\\0'; /* force close string */\n\n    return buffer;\n}\n\nucs_status_t ucm_get_mem_type_current_device_info(ucs_memory_type_t memtype, ucs_sys_bus_id_t *bus_id)\n{\n    ucs_status_t status = UCS_ERR_UNSUPPORTED;\n    ucm_event_installer_t *event_installer;\n\n    ucs_list_for_each(event_installer, &ucm_event_installer_list, list) {\n        if (NULL == event_installer->get_mem_type_current_device_info) {\n            continue;\n        }\n\n        status = event_installer->get_mem_type_current_device_info(bus_id, memtype);\n        if (UCS_OK == status) {\n            break;\n        }\n    }\n\n    return status; \n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/ucx/src/ucm/util/reloc.c": "/**\n * Copyright (C) Mellanox Technologies Ltd. 2001-2015.  ALL RIGHTS RESERVED.\n *\n * See file LICENSE for terms.\n */\n\n#ifdef HAVE_CONFIG_H\n#  include \"config.h\"\n#endif\n\n#ifndef NVALGRIND\n#  include <valgrind/memcheck.h>\n#else\n#  define RUNNING_ON_VALGRIND 0\n#endif\n\n#include \"reloc.h\"\n\n#include <ucs/datastruct/khash.h>\n#include <ucs/sys/compiler.h>\n#include <ucs/sys/string.h>\n#include <ucs/sys/sys.h>\n#include <ucm/util/sys.h>\n\n#include <sys/fcntl.h>\n#include <sys/mman.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <link.h>\n#include <limits.h>\n\ntypedef void * (*ucm_reloc_dlopen_func_t)(const char *, int);\ntypedef int    (*ucm_reloc_dlclose_func_t)(void *);\n\ntypedef struct ucm_auxv {\n    long               type;\n    long               value;\n} UCS_S_PACKED ucm_auxv_t;\n\n\ntypedef struct ucm_reloc_dl_iter_context {\n    ucm_reloc_patch_t  *patch;\n    ucs_status_t       status;\n    ElfW(Addr)         libucm_base_addr;  /* Base address to store previous value */\n} ucm_reloc_dl_iter_context_t;\n\n\n/* Hash of symbols in a dynamic object */\nKHASH_MAP_INIT_STR(ucm_dl_symbol_hash, void*);\n\n/* Hash of loaded dynamic objects */\ntypedef struct {\n    khash_t(ucm_dl_symbol_hash) symbols;\n} ucm_dl_info_t;\n\nKHASH_MAP_INIT_INT64(ucm_dl_info_hash, ucm_dl_info_t)\n\n/* List of patches to be applied to additional libraries */\nstatic UCS_LIST_HEAD(ucm_reloc_patch_list);\nstatic pthread_mutex_t ucm_reloc_patch_list_lock = PTHREAD_MUTEX_INITIALIZER;\n\nstatic khash_t(ucm_dl_info_hash) ucm_dl_info_hash;\nstatic ucm_reloc_dlopen_func_t  ucm_reloc_orig_dlopen  = NULL;\nstatic ucm_reloc_dlclose_func_t ucm_reloc_orig_dlclose = NULL;\n\n/* forward declaration */\nstatic void ucm_reloc_get_orig_dl_funcs();\n\nstatic uintptr_t\nucm_reloc_get_entry(ElfW(Addr) base, const ElfW(Phdr) *dphdr, ElfW(Sxword) tag)\n{\n    ElfW(Dyn) *entry;\n    for (entry = (void*)(base + dphdr->p_vaddr); entry->d_tag != 0; ++entry) {\n        if (entry->d_tag == tag) {\n            return entry->d_un.d_val;\n        }\n    }\n    return 0;\n}\n\nstatic void ucm_reloc_file_lock(int fd, int l_type)\n{\n    struct flock fl = { l_type, SEEK_SET, 0, 0};\n    int ret;\n\n    ret = fcntl(fd, F_SETLKW, &fl);\n    if (ret < 0) {\n        ucm_warn(\"fcntl(fd=%d, F_SETLKW, l_type=%d) failed: %m\", fd, l_type);\n    }\n}\n\nstatic ucs_status_t ucm_reloc_get_aux_phsize(int *phsize_p)\n{\n#define UCM_RELOC_AUXV_BUF_LEN 16\n    static const char *proc_auxv_filename = \"/proc/self/auxv\";\n    static int phsize = 0;\n    ucm_auxv_t buffer[UCM_RELOC_AUXV_BUF_LEN];\n    ucm_auxv_t *auxv;\n    unsigned count;\n    ssize_t nread;\n    int found;\n    int fd;\n\n    /* Can avoid lock here - worst case we'll read the file more than once */\n    if (phsize != 0) {\n        *phsize_p = phsize;\n        return UCS_OK;\n    }\n\n    fd = open(proc_auxv_filename, O_RDONLY);\n    if (fd < 0) {\n        ucm_error(\"failed to open '%s' for reading: %m\", proc_auxv_filename);\n        return UCS_ERR_IO_ERROR;\n    }\n\n    if (RUNNING_ON_VALGRIND) {\n        /* Work around a bug caused by valgrind's fake /proc/self/auxv -\n         * every time this file is opened when running with valgrind, a\n         * a duplicate of the same fd is returned, so all share the same\n         * file offset.\n         */\n        ucm_reloc_file_lock(fd, F_WRLCK);\n        lseek(fd, 0, SEEK_SET);\n    }\n\n    /* Use small buffer on the stack, avoid using malloc() */\n    found = 0;\n    do {\n        nread = read(fd, buffer, sizeof(buffer));\n        if (nread < 0) {\n            ucm_error(\"failed to read %lu bytes from %s (ret=%ld): %m\",\n                      sizeof(buffer), proc_auxv_filename, nread);\n            break;\n        }\n\n        count = nread / sizeof(buffer[0]);\n        for (auxv = buffer; (auxv < (buffer + count)) && (auxv->type != AT_NULL);\n             ++auxv)\n        {\n            if ((auxv->type == AT_PHENT) && (auxv->value > 0)) {\n                found  = 1;\n                phsize = auxv->value;\n                ucm_debug(\"read phent from %s: %d\", proc_auxv_filename, phsize);\n                if (phsize == 0) {\n                    ucm_error(\"phsize is 0\");\n                }\n                break;\n            }\n        }\n    } while ((count > 0) && !found);\n\n    if (RUNNING_ON_VALGRIND) {\n        ucm_reloc_file_lock(fd, F_UNLCK);\n    }\n    close(fd);\n\n    if (!found) {\n        ucm_error(\"AT_PHENT entry not found in %s\", proc_auxv_filename);\n        return UCS_ERR_NO_ELEM;\n    }\n\n    *phsize_p = phsize;\n    return UCS_OK;\n}\n\nElfW(Rela) *ucm_reloc_find_sym(void *table, size_t table_size, const char *symbol,\n                               void *strtab, ElfW(Sym) *symtab)\n{\n    ElfW(Rela) *reloc;\n    char *elf_sym;\n\n    for (reloc = table;\n         (void*)reloc < UCS_PTR_BYTE_OFFSET(table, table_size);\n         ++reloc) {\n        elf_sym = (char*)strtab + symtab[ELF64_R_SYM(reloc->r_info)].st_name;\n        if (!strcmp(symbol, elf_sym)) {\n            return reloc;\n        }\n    }\n    return NULL;\n}\n\nstatic ucs_status_t\nucm_reloc_dl_apply_patch(const ucm_dl_info_t *dl_info, const char *dl_basename,\n                         int store_prev, ucm_reloc_patch_t *patch)\n{\n    void *prev_value;\n    khiter_t khiter;\n    long page_size;\n    void **entry;\n    void *page;\n    int ret;\n\n    /* find symbol in our hash table */\n    khiter = kh_get(ucm_dl_symbol_hash, &dl_info->symbols, patch->symbol);\n    if (khiter == kh_end(&dl_info->symbols)) {\n        ucm_trace(\"symbol '%s' not found in %s\", patch->symbol, dl_basename);\n        return UCS_OK;\n    }\n\n    /* get entry address from hash table */\n    entry      = kh_val(&dl_info->symbols, khiter);\n    prev_value = *entry;\n\n    if (prev_value == patch->value) {\n        ucm_trace(\"symbol '%s' in %s at [%p] up-to-date\", patch->symbol,\n                  dl_basename, entry);\n        return UCS_OK;\n    }\n\n    /* enable writing to the page */\n    page_size = ucm_get_page_size();\n    page      = ucs_align_down_pow2_ptr(entry, page_size);\n    ret       = mprotect(page, page_size, PROT_READ|PROT_WRITE);\n    if (ret < 0) {\n        ucm_error(\"failed to modify %s page %p to rw: %m\", dl_basename, page);\n        return UCS_ERR_UNSUPPORTED;\n    }\n\n    /* modify the relocation to the new value */\n    *entry = patch->value;\n    ucm_debug(\"symbol '%s' in %s at [%p] modified from %p to %p\",\n              patch->symbol, dl_basename, entry, prev_value, patch->value);\n\n    /* store default entry to prev_value to guarantee valid pointers\n     * throughout life time of the process */\n    if (store_prev) {\n        patch->prev_value = prev_value;\n        ucm_debug(\"'%s' prev_value is %p\", patch->symbol, prev_value);\n    }\n\n    return UCS_OK;\n}\n\nstatic unsigned\nucm_dl_populate_symbols(ucm_dl_info_t *dl_info, uintptr_t dlpi_addr, void *table,\n                        size_t table_size, void *strtab, ElfW(Sym) *symtab,\n                        const char *dl_name)\n{\n    ElfW(Rela) *reloc;\n    khiter_t khiter;\n    unsigned count;\n    char *elf_sym;\n    int ret;\n\n    count = 0;\n    for (reloc = table; (void*)reloc < UCS_PTR_BYTE_OFFSET(table, table_size);\n         ++reloc) {\n        elf_sym = (char*)strtab + symtab[ELF64_R_SYM(reloc->r_info)].st_name;\n        if (*elf_sym == '\\0') {\n            /* skip empty symbols */\n            continue;\n        }\n\n        khiter = kh_put(ucm_dl_symbol_hash, &dl_info->symbols, elf_sym, &ret);\n        if ((ret == UCS_KH_PUT_BUCKET_EMPTY) ||\n            (ret == UCS_KH_PUT_BUCKET_CLEAR)) {\n            /* do not override previous values */\n            kh_val(&dl_info->symbols, khiter) = (void*)(dlpi_addr +\n                                                        reloc->r_offset);\n            ++count;\n        } else if (ret == UCS_KH_PUT_KEY_PRESENT) {\n            ucm_trace(\"ignoring duplicate symbol '%s' in %s\", elf_sym, dl_name);\n        } else {\n            ucm_debug(\"failed to add symbol '%s' in %s\", elf_sym, dl_name);\n        }\n    }\n\n    return count;\n}\n\nstatic ucs_status_t ucm_reloc_dl_info_get(const struct dl_phdr_info *phdr_info,\n                                          const char *dl_name,\n                                          const ucm_dl_info_t **dl_info_p)\n{\n    uintptr_t dlpi_addr = phdr_info->dlpi_addr;\n    unsigned UCS_V_UNUSED num_symbols;\n    void *jmprel, *rela, *strtab;\n    size_t pltrelsz, relasz;\n    ucm_dl_info_t *dl_info;\n    ucs_status_t status;\n    ElfW(Phdr) *dphdr;\n    ElfW(Sym) *symtab;\n    khiter_t khiter;\n    int i, ret;\n    int phsize;\n\n    status = ucm_reloc_get_aux_phsize(&phsize);\n    if (status != UCS_OK) {\n        return status;\n    }\n\n    khiter = kh_put(ucm_dl_info_hash, &ucm_dl_info_hash, dlpi_addr, &ret);\n    if (ret == UCS_KH_PUT_FAILED) {\n        ucm_error(\"failed to add dl info hash entry\");\n        return UCS_ERR_NO_MEMORY;\n    }\n\n    dl_info = &kh_val(&ucm_dl_info_hash, khiter);\n    if (ret == UCS_KH_PUT_KEY_PRESENT) {\n        /* exists */\n        goto out;\n    }\n\n    kh_init_inplace(ucm_dl_symbol_hash, &dl_info->symbols);\n\n    /* find PT_DYNAMIC */\n    dphdr = NULL;\n    for (i = 0; i < phdr_info->dlpi_phnum; ++i) {\n        dphdr = UCS_PTR_BYTE_OFFSET(phdr_info->dlpi_phdr, phsize * i);\n        if (dphdr->p_type == PT_DYNAMIC) {\n            break;\n        }\n    }\n    if (dphdr == NULL) {\n        /* No dynamic section */\n        ucm_debug(\"%s has no dynamic section - skipping\", dl_name)\n        goto out;\n    }\n\n    /* Get ELF tables pointers */\n    symtab = (void*)ucm_reloc_get_entry(dlpi_addr, dphdr, DT_SYMTAB);\n    strtab = (void*)ucm_reloc_get_entry(dlpi_addr, dphdr, DT_STRTAB);\n    if ((symtab == NULL) || (strtab == NULL)) {\n        /* no DT_SYMTAB or DT_STRTAB sections are defined */\n        ucm_debug(\"%s has no dynamic symbols - skipping\", dl_name)\n        goto out;\n    }\n\n    num_symbols = 0;\n\n    /* populate .got.plt */\n    jmprel = (void*)ucm_reloc_get_entry(dlpi_addr, dphdr, DT_JMPREL);\n    if (jmprel != NULL) {\n        pltrelsz     = ucm_reloc_get_entry(dlpi_addr, dphdr, DT_PLTRELSZ);\n        num_symbols += ucm_dl_populate_symbols(dl_info, dlpi_addr, jmprel,\n                                               pltrelsz, strtab, symtab, dl_name);\n    }\n\n    /* populate .got */\n    rela = (void*)ucm_reloc_get_entry(dlpi_addr, dphdr, DT_RELA);\n    if (rela != NULL) {\n        relasz       = ucm_reloc_get_entry(dlpi_addr, dphdr, DT_RELASZ);\n        num_symbols += ucm_dl_populate_symbols(dl_info, dlpi_addr, rela, relasz,\n                                               strtab, symtab, dl_name);\n    }\n\n    ucm_debug(\"added dl_info %p for %s with %u symbols\", dl_info,\n              ucs_basename(dl_name), num_symbols);\n\nout:\n    *dl_info_p = dl_info;\n    return UCS_OK;\n}\n\nstatic void ucm_reloc_dl_info_cleanup(ElfW(Addr) dlpi_addr, const char *dl_name)\n{\n    ucm_dl_info_t *dl_info;\n    khiter_t khiter;\n\n    khiter = kh_get(ucm_dl_info_hash, &ucm_dl_info_hash, dlpi_addr);\n    if (khiter == kh_end(&ucm_dl_info_hash)) {\n        ucm_debug(\"no dl_info entry for address 0x%lx\", dlpi_addr);\n        return;\n    }\n\n    /* destroy symbols hash table */\n    dl_info = &kh_val(&ucm_dl_info_hash, khiter);\n    kh_destroy_inplace(ucm_dl_symbol_hash, &dl_info->symbols);\n\n    /* delete entry in dl_info hash */\n    kh_del(ucm_dl_info_hash, &ucm_dl_info_hash, khiter);\n\n    ucm_debug(\"removed dl_info %p for %s\", dl_info, ucs_basename(dl_name));\n}\n\nstatic int\nucm_reloc_patch_is_dl_blacklisted(const char *dlpi_name,\n                                  const ucm_reloc_patch_t *patch)\n{\n    unsigned i;\n\n    if (patch->blacklist == NULL) {\n        return 0;\n    }\n\n    for (i = 0; patch->blacklist[i] != NULL; i++) {\n        if (strstr(dlpi_name, patch->blacklist[i])) {\n            return 1;\n        }\n    }\n\n    return 0;\n}\n\nstatic const char*\nucm_reloc_get_dl_name(const char *dlpi_name, ElfW(Addr) dlpi_addr, char *buf,\n                      size_t max)\n{\n    if (strcmp(dlpi_name, \"\")) {\n        return dlpi_name;\n    } else {\n        snprintf(buf, max, \"(anonymous dl @ 0x%lx)\", dlpi_addr);\n        return buf;\n    }\n}\n\nstatic int ucm_reloc_phdr_iterator(struct dl_phdr_info *phdr_info, size_t size,\n                                   void *data)\n{\n    ucm_reloc_dl_iter_context_t *ctx = data;\n    const ucm_dl_info_t *dl_info;\n    char dl_name_buffer[256];\n    const char *dl_name;\n    int store_prev;\n\n    /* check if shared object is black-listed for this patch */\n    if (ucm_reloc_patch_is_dl_blacklisted(phdr_info->dlpi_name, ctx->patch)) {\n        return 0;\n    }\n\n    dl_name = ucm_reloc_get_dl_name(phdr_info->dlpi_name, phdr_info->dlpi_addr,\n                                    dl_name_buffer, sizeof(dl_name_buffer));\n\n    ctx->status = ucm_reloc_dl_info_get(phdr_info, dl_name, &dl_info);\n    if (ctx->status != UCS_OK) {\n        return -1; /* stop iteration if got a real error */\n    }\n\n    store_prev  = phdr_info->dlpi_addr == ctx->libucm_base_addr;\n    ctx->status = ucm_reloc_dl_apply_patch(dl_info, ucs_basename(dl_name),\n                                           store_prev, ctx->patch);\n    if (ctx->status != UCS_OK) {\n        return -1; /* stop iteration if got a real error */\n    }\n\n    /* Continue iteration and patch all remaining objects. */\n    return 0;\n}\n\n/* called with lock held */\nstatic ucs_status_t ucm_reloc_apply_patch(ucm_reloc_patch_t *patch,\n                                          ElfW(Addr) libucm_base_addr)\n{\n    ucm_reloc_dl_iter_context_t ctx;\n\n    ctx.patch              = patch;\n    ctx.status             = UCS_OK;\n    ctx.libucm_base_addr   = libucm_base_addr;\n\n    /* Avoid locks here because we don't modify ELF data structures.\n     * Worst case the same symbol will be written more than once.\n     */\n    ucm_trace(\"patch symbol '%s'\", patch->symbol);\n    (void)dl_iterate_phdr(ucm_reloc_phdr_iterator, &ctx);\n    return ctx.status;\n}\n\n/* read serinfo from 'module_path', result buffer must be destroyed\n * by free() call */\nstatic Dl_serinfo *ucm_dlopen_load_serinfo(const char *module_path)\n{\n    Dl_serinfo *serinfo = NULL;\n    Dl_serinfo serinfo_size;\n    void *module;\n    int res;\n\n    module = ucm_reloc_orig_dlopen(module_path, RTLD_LAZY);\n    if (module == NULL) { /* requested module can't be loaded */\n        ucm_debug(\"failed to open %s: %s\", module_path, dlerror());\n        return NULL;\n    }\n\n    /* try to get search info from requested module */\n    res = dlinfo(module, RTLD_DI_SERINFOSIZE, &serinfo_size);\n    if (res) {\n        ucm_debug(\"dlinfo(RTLD_DI_SERINFOSIZE) failed\");\n        goto close_module;\n    }\n\n    serinfo = malloc(serinfo_size.dls_size);\n    if (serinfo == NULL) {\n        ucm_error(\"failed to allocate %zu bytes for Dl_serinfo\",\n                  serinfo_size.dls_size);\n        goto close_module;\n    }\n\n    *serinfo = serinfo_size;\n    res      = dlinfo(module, RTLD_DI_SERINFO, serinfo);\n    if (res) {\n        ucm_debug(\"dlinfo(RTLD_DI_SERINFO) failed\");\n        free(serinfo);\n        serinfo = NULL;\n    }\n\nclose_module:\n    ucm_reloc_orig_dlclose(module);\n    return serinfo;\n}\n\nvoid *ucm_dlopen(const char *filename, int flag)\n{\n    void *handle;\n    ucm_reloc_patch_t *patch;\n    Dl_serinfo *serinfo;\n    Dl_info dl_info;\n    int res;\n    int i;\n    char file_path[PATH_MAX];\n    struct stat file_stat;\n\n    ucm_debug(\"open module: %s, flag: %x\", filename, flag);\n\n    ucm_reloc_get_orig_dl_funcs();\n\n    if (!ucm_global_opts.dlopen_process_rpath) {\n        goto fallback_load_lib;\n    }\n\n    if (filename == NULL) {\n        /* return handle to main program */\n        goto fallback_load_lib;\n    }\n\n    /* failed to open module directly, try to use RPATH from from caller\n     * to locate requested module */\n    if (filename[0] == '/') { /* absolute path - fallback to legacy mode */\n        goto fallback_load_lib;\n    }\n\n    /* try to get module info */\n    res = dladdr(__builtin_return_address(0), &dl_info);\n    if (!res) {\n        ucm_debug(\"dladdr failed\");\n        goto fallback_load_lib;\n    }\n\n    serinfo = ucm_dlopen_load_serinfo(dl_info.dli_fname);\n    if (serinfo == NULL) {\n        /* failed to load serinfo, try just dlopen */\n        goto fallback_load_lib;\n    }\n\n    for (i = 0; i < serinfo->dls_cnt; i++) {\n        ucm_concat_path(file_path, sizeof(file_path),\n                        serinfo->dls_serpath[i].dls_name, filename);\n        ucm_debug(\"check for %s\", file_path);\n\n        res = stat(file_path, &file_stat);\n        if (res) {\n            continue;\n        }\n\n        free(serinfo);\n        /* ok, file exists, let's try to load it */\n        handle = ucm_reloc_orig_dlopen(file_path, flag);\n        if (handle == NULL) {\n            return NULL;\n        }\n\n        goto out_apply_patches;\n    }\n\n    free(serinfo);\n    /* ok, we can't lookup module in dirs listed in caller module,\n     * let's fallback to legacy mode */\nfallback_load_lib:\n    handle = ucm_reloc_orig_dlopen(filename, flag);\n    if (handle == NULL) {\n        return NULL;\n    }\n\nout_apply_patches:\n    /*\n     * Every time a new shared object is loaded, we must update its relocations\n     * with our list of patches (including dlopen itself). We have to go over\n     * the entire list of shared objects, since there more objects could be\n     * loaded due to dependencies.\n     */\n\n    ucm_trace(\"dlopen(%s) = %p\", filename, handle);\n\n    pthread_mutex_lock(&ucm_reloc_patch_list_lock);\n    ucs_list_for_each(patch, &ucm_reloc_patch_list, list) {\n        ucm_debug(\"in dlopen(%s), re-applying '%s' to %p\", filename,\n                  patch->symbol, patch->value);\n        ucm_reloc_apply_patch(patch, 0);\n    }\n    pthread_mutex_unlock(&ucm_reloc_patch_list_lock);\n\n    return handle;\n}\n\nstatic int ucm_dlclose(void *handle)\n{\n    struct link_map *lm_entry;\n    char dl_name_buffer[256];\n    const char *dl_name;\n    int ret;\n\n    ucm_trace(\"dlclose(%p)\", handle);\n\n    ret = dlinfo(handle, RTLD_DI_LINKMAP, &lm_entry);\n    if (ret != 0) {\n        ucm_warn(\"dlinfo(handle=%p) failed during dlclose() hook, symbol\"\n                 \"table may become unreliable\", handle);\n    } else {\n        /*\n         * Cleanup the cached information about the library.\n         * NOTE: The library may not actually be unloaded (if its reference\n         * count is > 1). Since we have no safe way to know it, we remove the\n         * cached information anyway, and it may be re-added on the next call to\n         * ucm_reloc_apply_patch().\n         */\n        dl_name = ucm_reloc_get_dl_name(lm_entry->l_name, lm_entry->l_addr,\n                                        dl_name_buffer, sizeof(dl_name_buffer));\n        pthread_mutex_lock(&ucm_reloc_patch_list_lock);\n        ucm_reloc_dl_info_cleanup(lm_entry->l_addr, dl_name);\n        pthread_mutex_unlock(&ucm_reloc_patch_list_lock);\n    }\n\n    ucm_reloc_get_orig_dl_funcs();\n\n    return ucm_reloc_orig_dlclose(handle);\n}\n\nstatic ucm_reloc_patch_t ucm_dlopen_reloc_patches[] = {\n    { .symbol = \"dlopen\",  .value  = ucm_dlopen  },\n    { .symbol = \"dlclose\", .value  = ucm_dlclose }\n};\n\nstatic void ucm_reloc_get_orig_dl_funcs()\n{\n    ucm_reloc_patch_t *patch;\n\n    /* pointer to original dlopen() */\n    if (ucm_reloc_orig_dlopen == NULL) {\n        patch                 = &ucm_dlopen_reloc_patches[0];\n        ucm_reloc_orig_dlopen = (ucm_reloc_dlopen_func_t)\n                                ucm_reloc_get_orig(patch->symbol, patch->value);\n        if (ucm_reloc_orig_dlopen == NULL) {\n            ucm_fatal(\"ucm_reloc_orig_dlopen is NULL\");\n        }\n    }\n\n    /* pointer to original dlclose() */\n    if (ucm_reloc_orig_dlclose == NULL) {\n        patch                  = &ucm_dlopen_reloc_patches[1];\n        ucm_reloc_orig_dlclose = (ucm_reloc_dlclose_func_t)\n                                 ucm_reloc_get_orig(patch->symbol, patch->value);\n        if (ucm_reloc_orig_dlclose == NULL) {\n            ucm_fatal(\"ucm_reloc_orig_dlclose is NULL\");\n        }\n    }\n}\n\n/* called with lock held */\nstatic ucs_status_t ucm_reloc_install_dl_hooks()\n{\n    static int installed = 0;\n    ucs_status_t status;\n    size_t i;\n\n    if (installed) {\n        return UCS_OK;\n    }\n\n    for (i = 0; i < ucs_array_size(ucm_dlopen_reloc_patches); ++i) {\n        status = ucm_reloc_apply_patch(&ucm_dlopen_reloc_patches[i], 0);\n        if (status != UCS_OK) {\n            return status;\n        }\n\n        ucs_list_add_tail(&ucm_reloc_patch_list, &ucm_dlopen_reloc_patches[i].list);\n    }\n\n    installed = 1;\n    return UCS_OK;\n}\n\nucs_status_t ucm_reloc_modify(ucm_reloc_patch_t *patch)\n{\n    ucs_status_t status;\n    Dl_info dl_info;\n    int ret;\n\n    ucm_reloc_get_orig_dl_funcs();\n\n    /* Take default symbol value from the current library */\n    ret = dladdr(ucm_reloc_modify, &dl_info);\n    if (!ret) {\n        ucm_error(\"dladdr() failed to query current library\");\n        return UCS_ERR_UNSUPPORTED;\n    }\n\n    /* Take lock first to handle a possible race where dlopen() is called\n     * from another thread and we may end up not patching it.\n     */\n    pthread_mutex_lock(&ucm_reloc_patch_list_lock);\n\n    status = ucm_reloc_install_dl_hooks();\n    if (status != UCS_OK) {\n        goto out_unlock;\n    }\n\n    status = ucm_reloc_apply_patch(patch, (uintptr_t)dl_info.dli_fbase);\n    if (status != UCS_OK) {\n        goto out_unlock;\n    }\n\n    ucs_list_add_tail(&ucm_reloc_patch_list, &patch->list);\n\nout_unlock:\n    pthread_mutex_unlock(&ucm_reloc_patch_list_lock);\n    return status;\n}\n\nUCS_STATIC_INIT {\n    kh_init_inplace(ucm_dl_info_hash, &ucm_dl_info_hash);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/ucx/src/ucm/api/ucm.h": "/**\n * Copyright (C) Mellanox Technologies Ltd. 2001-2015.  ALL RIGHTS RESERVED.\n * Copyright (C) Advanced Micro Devices, Inc. 2019. ALL RIGHTS RESERVED.\n *\n * See file LICENSE for terms.\n */\n\n\n#ifndef UCM_H_\n#define UCM_H_\n\n#include <ucs/sys/compiler_def.h>\n\nBEGIN_C_DECLS\n\n#include <ucs/config/types.h>\n#include <ucs/memory/memory_type.h>\n#include <ucs/type/status.h>\n\n#include <sys/types.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdint.h>\n\n\n/**\n * @brief Memory event types\n */\ntypedef enum ucm_event_type {\n    /* Default initialization value */\n    UCM_EVENT_NONE            = 0,\n    /* Native events */\n    UCM_EVENT_MMAP            = UCS_BIT(0),\n    UCM_EVENT_MUNMAP          = UCS_BIT(1),\n    UCM_EVENT_MREMAP          = UCS_BIT(2),\n    UCM_EVENT_SHMAT           = UCS_BIT(3),\n    UCM_EVENT_SHMDT           = UCS_BIT(4),\n    UCM_EVENT_SBRK            = UCS_BIT(5),\n    UCM_EVENT_MADVISE         = UCS_BIT(6),\n\n    /* Aggregate events */\n    UCM_EVENT_VM_MAPPED       = UCS_BIT(16),\n    UCM_EVENT_VM_UNMAPPED     = UCS_BIT(17),\n\n    /* Non-accessible memory alloc/free events */\n    UCM_EVENT_MEM_TYPE_ALLOC  = UCS_BIT(20),\n    UCM_EVENT_MEM_TYPE_FREE   = UCS_BIT(21),\n\n    /* Add event handler, but don't install new hooks */\n    UCM_EVENT_FLAG_NO_INSTALL = UCS_BIT(24),\n\n    /* When the event handler is added, generate approximated events for\n     * existing memory allocations.\n     * Currently implemented only for @ref UCM_EVENT_MEM_TYPE_ALLOC.\n     */\n    UCM_EVENT_FLAG_EXISTING_ALLOC = UCS_BIT(25)\n\n} ucm_event_type_t;\n\n\n/**\n * @brief MMAP hook modes\n */\ntypedef enum ucm_mmap_hook_mode {\n    UCM_MMAP_HOOK_NONE,\n    UCM_MMAP_HOOK_RELOC,\n    UCM_MMAP_HOOK_BISTRO,\n    UCM_MMAP_HOOK_LAST\n} ucm_mmap_hook_mode_t;\n\n/**\n * @brief Memory event parameters and result.\n */\ntypedef union ucm_event {\n    /*\n     * UCM_EVENT_MMAP\n     * mmap() is called.\n     * callbacks: pre, post\n     */\n    struct {\n        void               *result;\n        void               *address;\n        size_t             size;\n        int                prot;\n        int                flags;\n        int                fd;\n        off_t              offset;\n    } mmap;\n\n    /*\n     * UCM_EVENT_MUNMAP\n     * munmap() is called.\n     */\n    struct {\n        int                result;\n        void               *address;\n        size_t             size;\n    } munmap;\n\n    /*\n     * UCM_EVENT_MREMAP\n     * mremap() is called.\n     */\n    struct {\n        void               *result;\n        void               *address;\n        size_t             old_size;\n        size_t             new_size;\n        int                flags;\n    } mremap;\n\n    /*\n     * UCM_EVENT_SHMAT\n     * shmat() is called.\n     */\n    struct {\n        void               *result;\n        int                shmid;\n        const void         *shmaddr;\n        int                shmflg;\n    } shmat;\n\n    /*\n     * UCM_EVENT_SHMDT\n     * shmdt() is called.\n     */\n    struct {\n        int                result;\n        const void         *shmaddr;\n    } shmdt;\n\n    /*\n     * UCM_EVENT_SBRK\n     * sbrk() is called.\n     */\n    struct {\n        void               *result;\n        intptr_t           increment;\n    } sbrk;\n\n    /*\n     * UCM_EVENT_MADVISE\n     * madvise() is called.\n     */\n    struct {\n        int                result;\n        void               *addr;\n        size_t             length;\n        int                advice;\n    } madvise;\n\n    /*\n     * UCM_EVENT_VM_MAPPED, UCM_EVENT_VM_UNMAPPED\n     *\n     * This is a \"read-only\" event which is called whenever memory is mapped\n     * or unmapped from process address space, in addition to the other events.\n     * It can return only UCM_EVENT_STATUS_NEXT.\n     *\n     * For UCM_EVENT_VM_MAPPED, callbacks are post\n     * For UCM_EVENT_VM_UNMAPPED, callbacks are pre\n     */\n    struct {\n        void               *address;\n        size_t             size;\n    } vm_mapped, vm_unmapped;\n\n    /*\n     * UCM_EVENT_MEM_TYPE_ALLOC, UCM_EVENT_MEM_TYPE_FREE\n     *\n     * Memory type allocation and deallocation event.\n     * If mem_type is @ref UCS_MEMORY_TYPE_LAST, the memory type is unknown, and\n     * further memory type detection is required.\n     */\n    struct {\n        void               *address;\n        size_t             size;\n        ucs_memory_type_t  mem_type;\n    } mem_type;\n\n} ucm_event_t;\n\n\n/**\n * @brief Global UCM configuration.\n *\n * Can be safely modified before using UCM functions.\n */\ntypedef struct ucm_global_config {\n    ucs_log_level_t      log_level;                   /* Logging level */\n    int                  enable_events;               /* Enable memory events */\n    ucm_mmap_hook_mode_t mmap_hook_mode;              /* MMAP hook mode */\n    int                  enable_malloc_hooks;         /* Enable installing malloc hooks */\n    int                  enable_malloc_reloc;         /* Enable installing malloc relocations */\n    int                  enable_cuda_reloc;           /* Enable installing CUDA relocations */\n    int                  enable_dynamic_mmap_thresh;  /* Enable adaptive mmap threshold */\n    size_t               alloc_alignment;             /* Alignment for memory allocations */\n    int                  dlopen_process_rpath;        /* Process RPATH section in dlopen hook */\n} ucm_global_config_t;\n\n\n/* Global UCM configuration */\nextern ucm_global_config_t ucm_global_opts;\n\n\n/**\n * @brief Memory event callback.\n *\n *  This type describes a callback which handles memory events in the current process.\n *\n * @param [in]     event_type  Type of the event being fired. see @ref ucm_event_type_t.\n * @param [inout]  event       Event information. This structure can be updated by\n *                               this callback, as described below.\n * @param [in]     arg         User-defined argument as passed to @ref ucm_set_event_handler.\n *\n *\n *  Events are dispatched in order of callback priority (low to high).\n *\n * The fields of the relevant part of the union are initialized as follows:\n *  - \"result\" - to an invalid erroneous return value (depends on the specific event).\n *  - the rest - to the input parameters of the event.\n *\n *  The callback is allowed to modify the fields, and those modifications will\n * be passed to the next callback. Also, the callback is allowed to modify the\n * result, but **only if it's currently invalid**. A valid result indicates that\n * a previous callback already performed the requested memory operation, so a\n * callback should **refrain from actions with side-effects** in this case.\n *\n *  If the result is still invalid after all callbacks are called, the parameters,\n * possibly modified by the callbacks, will be passed to the original handler.\n *\n *\n * Important Note: The callback must not call any memory allocation routines, or\n *       anything which may trigger or wait for memory allocation, because it\n *       may lead to deadlock or infinite recursion.\n *\n * @todo describe use cases\n *\n */\ntypedef void (*ucm_event_callback_t)(ucm_event_type_t event_type,\n                                     ucm_event_t *event, void *arg);\n\n\n/**\n * @brief Install a handler for memory events.\n *\n * @param [in]  events     Bit-mask of events to handle.\n * @param [in]  priority   Priority value which defines the order in which event\n *                          callbacks are called.\n *                           <  0 - called before the original implementation,\n *                           >= 0 - called after the original implementation.\n * @param [in]  cb         Event-handling callback.\n * @param [in]  arg        User-defined argument for the callback.\n *\n * @note If UCM_EVENT_FLAG_NO_INSTALL flag is passed in @a events argument,\n *       only @cb handler will be registered for @a events. No memory\n *       events/hooks will be installed.\n *\n * @return Status code.\n */\nucs_status_t ucm_set_event_handler(int events, int priority,\n                                   ucm_event_callback_t cb, void *arg);\n\n\n/**\n * @brief Remove a handler for memory events.\n *\n * @param [in]  events     Which events to remove. The handler is removed\n *                          completely when all its events are removed.\n * @param [in]  cb         Event-handling callback.\n * @param [in]  arg        User-defined argument for the callback.\n */\nvoid ucm_unset_event_handler(int events, ucm_event_callback_t cb, void *arg);\n\n\n/**\n * @brief Add memory events to the external events list.\n *\n * When the event is set to be external, it means that user is responsible for\n * handling it. So, setting a handler for external event will not trigger\n * installing of UCM memory hooks (if they were not installed before). In this\n * case the corresponding UCM function needs to be invoked to trigger event\n * handlers.\n * Usage example is when the user disables UCM memory hooks (he may have its\n * own hooks, like Open MPI), but it wants to use some UCM based functionality,\n * e.g. IB registration cache. IB registration cache needs to be notified about\n * UCM_EVENT_VM_UNMAPPED events, therefore it adds specific handler for it.\n * In this case user needs to declare UCM_EVENT_VM_UNMAPPED event as external\n * and explicitly call ucm_vm_munmap() when some memory release operation\n * occurs.\n *\n * @param [in]  events    Bit-mask of events which are supposed to be handled\n *                        externally.\n *\n * @note To take an effect, the event should be set external prior to adding\n *       event handlers for it.\n */\nvoid ucm_set_external_event(int events);\n\n\n/**\n * @brief Remove memory events from the external events list.\n *\n * When the event is removed from the external events list, any subsequent call\n * to ucm_set_event_handler() for that event will trigger installing of UCM\n * memory hooks (if they are enabled and were not installed before).\n *\n * @param [in]  events     Which events to remove from the external events list.\n */\nvoid ucm_unset_external_event(int events);\n\n\n/**\n * @brief Test event handlers\n *\n * This routine checks if event handlers are called when corresponding system API\n * is invoked.\n *\n * @param [in]  events    Bit-mask of events which are supposed to be handled\n *                        externally.\n *\n * @return Status code.\n */\nucs_status_t ucm_test_events(int events);\n\n\n/**\n * @brief Test event external handlers\n *\n * This routine checks if external events, as set by @ref ucm_set_external_event,\n * are actually being reported (by calling APIs such as @ref ucm_vm_munmap).\n *\n * @param [in]  events    Bit-mask of events which are supposed to be handled\n *                        externally.\n *\n * @return Status code.\n */\nucs_status_t ucm_test_external_events(int events);\n\n\n/**\n * @brief Call the original implementation of @ref mmap without triggering events.\n */\nvoid *ucm_orig_mmap(void *addr, size_t length, int prot, int flags, int fd,\n                    off_t offset);\n\n\n/**\n * @brief Call the original implementation of @ref munmap without triggering events.\n */\nint ucm_orig_munmap(void *addr, size_t length);\n\n\n/**\n * @brief Call the original implementation of @ref mremap without triggering events.\n */\nvoid *ucm_orig_mremap(void *old_address, size_t old_size, size_t new_size,\n                      int flags);\n\n\n/**\n * @brief Call the original implementation of @ref shmat without triggering events.\n */\nvoid *ucm_orig_shmat(int shmid, const void *shmaddr, int shmflg);\n\n\n/**\n * @brief Call the original implementation of @ref shmdt without triggering events.\n */\nint ucm_orig_shmdt(const void *shmaddr);\n\n\n/**\n * @brief Call the original implementation of @ref sbrk without triggering events.\n */\nvoid *ucm_orig_sbrk(intptr_t increment);\n\n\n/**\n * @brief Call the original implementation of @ref brk without triggering events.\n */\nint ucm_orig_brk(void *addr);\n\n\n/**\n * @brief Call the original implementation of @ref madvise without triggering events.\n */\nint ucm_orig_madvise(void *addr, size_t length, int advice);\n\n\n/**\n * @brief Call the original implementation of @ref mmap and all handlers\n * associated with it.\n */\nvoid *ucm_mmap(void *addr, size_t length, int prot, int flags, int fd,\n               off_t offset);\n\n\n/**\n * @brief Call the original implementation of @ref munmap and all handlers\n * associated with it.\n */\nint ucm_munmap(void *addr, size_t length);\n\n\n/**\n * @brief Call the handlers registered for aggregated VM_MMAP event.\n */\nvoid ucm_vm_mmap(void *addr, size_t length);\n\n\n/**\n * @brief Call the handlers registered for aggregated VM_MUNMAP event.\n */\nvoid ucm_vm_munmap(void *addr, size_t length);\n\n\n/**\n * @brief Call the original implementation of @ref mremap and all handlers\n * associated with it.\n */\nvoid *ucm_mremap(void *old_address, size_t old_size, size_t new_size, int flags);\n\n\n/**\n * @brief Call the original implementation of @ref shmat and all handlers\n * associated with it.\n */\nvoid *ucm_shmat(int shmid, const void *shmaddr, int shmflg);\n\n\n/**\n * @brief Call the original implementation of @ref shmdt and all handlers\n * associated with it.\n */\nint ucm_shmdt(const void *shmaddr);\n\n\n/**\n * @brief Call the original implementation of @ref sbrk and all handlers\n * associated with it.\n */\nvoid *ucm_sbrk(intptr_t increment);\n\n\n/**\n * @brief Call the original implementation of @ref brk and all handlers\n * associated with it.\n */\nint ucm_brk(void *addr);\n\n\n/**\n * @brief Call the original implementation of @ref madvise and all handlers\n * associated with it.\n */\nint ucm_madvise(void *addr, size_t length, int advice);\n\n\n/**\n * @brief Call the original implementation of @ref dlopen and all handlers\n * associated with it.\n */\nvoid *ucm_dlopen(const char *filename, int flag);\n\n\nEND_C_DECLS\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/ucx/src/ucs/config/ucm_opts.c": "/**\n * Copyright (C) Mellanox Technologies Ltd. 2001-2018.  ALL RIGHTS RESERVED.\n *\n * See file LICENSE for terms.\n */\n\n#ifdef HAVE_CONFIG_H\n#  include \"config.h\"\n#endif\n\n#include \"parser.h\"\n\n#include <ucm/api/ucm.h>\n#include <ucm/util/log.h>\n#include <ucm/mmap/mmap.h>\n#include <ucs/sys/compiler.h>\n\n\n#define UCM_CONFIG_PREFIX   \"MEM_\"\n\nstatic const char *ucm_mmap_hook_modes[] = {\n    [UCM_MMAP_HOOK_NONE]   = \"none\",\n    [UCM_MMAP_HOOK_RELOC]  = UCM_MMAP_HOOK_RELOC_STR,\n#if UCM_BISTRO_HOOKS\n    [UCM_MMAP_HOOK_BISTRO] = UCM_MMAP_HOOK_BISTRO_STR,\n#endif\n    [UCM_MMAP_HOOK_LAST]   = NULL\n};\n\nstatic ucs_config_field_t ucm_global_config_table[] = {\n  {\"LOG_LEVEL\", \"warn\",\n   \"Logging level for memory events\", ucs_offsetof(ucm_global_config_t, log_level),\n   UCS_CONFIG_TYPE_ENUM(ucm_log_level_names)},\n\n  {\"ALLOC_ALIGN\", \"16\",\n   \"Minimal alignment of allocated blocks\",\n   ucs_offsetof(ucm_global_config_t, alloc_alignment), UCS_CONFIG_TYPE_MEMUNITS},\n\n  {\"EVENTS\", \"yes\",\n   \"Enable memory events\",\n   ucs_offsetof(ucm_global_config_t, enable_events), UCS_CONFIG_TYPE_BOOL},\n\n  {\"MMAP_HOOK_MODE\", UCM_DEFAULT_HOOK_MODE_STR,\n   \"MMAP hook mode\\n\"\n   \" none   - don't set mmap hooks.\\n\"\n   \" reloc  - use ELF relocation table to set hooks.\\n\"\n#if UCM_BISTRO_HOOKS\n   \" bistro - use binary instrumentation to set hooks.\\n\"\n#endif\n   ,ucs_offsetof(ucm_global_config_t, mmap_hook_mode), UCS_CONFIG_TYPE_ENUM(ucm_mmap_hook_modes)},\n\n  {\"MALLOC_HOOKS\", \"yes\",\n   \"Enable using glibc malloc hooks\",\n   ucs_offsetof(ucm_global_config_t, enable_malloc_hooks),\n   UCS_CONFIG_TYPE_BOOL},\n\n  {\"MALLOC_RELOC\", \"yes\",\n   \"Enable installing malloc symbols in the relocation table.\\n\"\n   \"This is unsafe and off by default, because sometimes glibc\\n\"\n   \"calls malloc/free without going through the relocation table,\\n\"\n   \"which would use the original implementation and not ours.\",\n   ucs_offsetof(ucm_global_config_t, enable_malloc_reloc), UCS_CONFIG_TYPE_BOOL},\n\n  {\"CUDA_RELOC\", \"yes\",\n   \"Enable installing CUDA symbols in the relocation table\",\n   ucs_offsetof(ucm_global_config_t, enable_cuda_reloc),\n   UCS_CONFIG_TYPE_BOOL},\n\n  {\"DYNAMIC_MMAP_THRESH\", \"yes\",\n   \"Enable dynamic mmap threshold: for every released block, the\\n\"\n   \"mmap threshold is adjusted upward to the size of the size of\\n\"\n   \"the block, and trim threshold is adjust to twice the size of\\n\"\n   \"the dynamic mmap threshold.\\n\"\n   \"Note: dynamic mmap threshold is disabled when running on valgrind.\",\n   ucs_offsetof(ucm_global_config_t, enable_dynamic_mmap_thresh),\n   UCS_CONFIG_TYPE_BOOL},\n\n  {\"DLOPEN_PROCESS_RPATH\", \"yes\",\n   \"Process RPATH section of caller module during dynamic libraries opening.\",\n   ucs_offsetof(ucm_global_config_t, dlopen_process_rpath),\n   UCS_CONFIG_TYPE_BOOL},\n\n  {NULL}\n};\n\nUCS_CONFIG_REGISTER_TABLE(ucm_global_config_table, \"UCM\", UCM_CONFIG_PREFIX,\n                          ucm_global_config_t)\n\nUCS_STATIC_INIT {\n    (void)ucs_config_parser_fill_opts(&ucm_global_opts, ucm_global_config_table,\n                                      UCS_DEFAULT_ENV_PREFIX, UCM_CONFIG_PREFIX, 0);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/ucx/src/ucs/sys/module.c": "/**\n * Copyright (C) Mellanox Technologies Ltd. 2001-2019.  ALL RIGHTS RESERVED.\n *\n * See file LICENSE for terms.\n */\n\n#ifdef HAVE_CONFIG_H\n#  include \"config.h\"\n#endif\n\n#ifndef _GNU_SOURCE\n#  define _GNU_SOURCE /* for dladdr(3) */\n#endif\n\n#include \"module.h\"\n\n#include <ucs/sys/preprocessor.h>\n#include <ucs/debug/memtrack.h>\n#include <ucs/debug/assert.h>\n#include <ucs/debug/log.h>\n#include <ucs/sys/string.h>\n#include <ucs/sys/math.h>\n#include <string.h>\n#include <limits.h>\n#include <dlfcn.h>\n#include <link.h>\n#include <libgen.h>\n\n\n#define UCS_MODULE_PATH_MEMTRACK_NAME   \"module_path\"\n#define UCS_MODULE_SRCH_PATH_MAX        2\n\n#define ucs_module_debug(_fmt, ...) \\\n    ucs_log(ucs_min(UCS_LOG_LEVEL_DEBUG, ucs_global_opts.module_log_level), \\\n            _fmt, ##  __VA_ARGS__)\n#define ucs_module_trace(_fmt, ...) \\\n    ucs_log(ucs_min(UCS_LOG_LEVEL_TRACE, ucs_global_opts.module_log_level), \\\n            _fmt, ##  __VA_ARGS__)\n\nstatic struct {\n    ucs_init_once_t  init;\n    char             module_ext[NAME_MAX];\n    unsigned         srchpath_cnt;\n    char             *srch_path[UCS_MODULE_SRCH_PATH_MAX];\n} ucs_module_loader_state = {\n    .init         = UCS_INIT_ONCE_INITIALIZER,\n    .module_ext   = \".so\", /* default extension */\n    .srchpath_cnt = 0,\n    .srch_path    = { NULL, NULL}\n};\n\n/* Should be called with lock held */\nstatic void ucs_module_loader_add_dl_dir()\n{\n    char *dlpath_dup = NULL;\n    size_t max_length;\n    Dl_info dl_info;\n    char *p, *path;\n    int ret;\n\n    (void)dlerror();\n    ret = dladdr((void*)&ucs_module_loader_state, &dl_info);\n    if (ret == 0) {\n        ucs_error(\"dladdr failed: %s\", dlerror());\n        return;\n    }\n\n    ucs_module_debug(\"ucs library path: %s\", dl_info.dli_fname);\n\n    /* copy extension */\n    dlpath_dup = ucs_strdup(dl_info.dli_fname,\n                            UCS_MODULE_PATH_MEMTRACK_NAME);\n    if (dlpath_dup == NULL) {\n        return;\n    }\n\n    p = basename(dlpath_dup);\n    p = strchr(p, '.');\n    if (p != NULL) {\n        strncpy(ucs_module_loader_state.module_ext, p,\n                sizeof(ucs_module_loader_state.module_ext) - 1);\n    }\n    ucs_free(dlpath_dup);\n\n    /* copy directory component */\n    dlpath_dup = ucs_strdup(dl_info.dli_fname,\n                            UCS_MODULE_PATH_MEMTRACK_NAME);\n    if (dlpath_dup == NULL) {\n        return;\n    }\n\n    /* construct module directory path */\n    max_length = strlen(dlpath_dup) +         /* directory */\n                 1 +                          /* '/' */\n                 strlen(UCX_MODULE_SUBDIR) +  /* sub-directory */\n                 1;                           /* '\\0' */\n    path = ucs_malloc(max_length, UCS_MODULE_PATH_MEMTRACK_NAME);\n    if (path == NULL) {\n        goto out;\n    }\n\n    snprintf(path, max_length, \"%s/%s\", dirname(dlpath_dup), UCX_MODULE_SUBDIR);\n    ucs_module_loader_state.srch_path[ucs_module_loader_state.srchpath_cnt++] = path;\n\nout:\n    ucs_free(dlpath_dup);\n}\n\n/* Should be called with lock held */\nstatic void ucs_module_loader_add_install_dir()\n{\n    ucs_module_loader_state.srch_path[ucs_module_loader_state.srchpath_cnt++] =\n                    ucs_global_opts.module_dir;\n}\n\nstatic void ucs_module_loader_init_paths()\n{\n    UCS_INIT_ONCE(&ucs_module_loader_state.init) {\n        ucs_assert(ucs_module_loader_state.srchpath_cnt == 0);\n        ucs_module_loader_add_dl_dir();\n        ucs_module_loader_add_install_dir();\n        ucs_assert(ucs_module_loader_state.srchpath_cnt <= UCS_MODULE_SRCH_PATH_MAX);\n    }\n}\n\n/* Perform shallow search for a symbol */\nstatic void *ucs_module_dlsym_shallow(const char *module_path, void *dl,\n                                      const char *symbol)\n{\n    struct link_map *lm_entry;\n    Dl_info dl_info;\n    void *addr;\n    int ret;\n\n    addr = dlsym(dl, symbol);\n    if (addr == NULL) {\n        return NULL;\n    }\n\n    (void)dlerror();\n    ret = dladdr(addr, &dl_info);\n    if (ret == 0) {\n        ucs_module_debug(\"dladdr(%p) [%s] failed: %s\", addr, symbol, dlerror());\n        return NULL;\n    }\n\n    (void)dlerror();\n    ret = dlinfo(dl, RTLD_DI_LINKMAP, &lm_entry);\n    if (ret) {\n        ucs_module_debug(\"dlinfo(%p) [%s] failed: %s\", dl, module_path, dlerror());\n        return NULL;\n    }\n\n    /* return the symbol only if it was found in the requested library, and not,\n     * for example, in one of its dependencies.\n     */\n    if (lm_entry->l_addr != (uintptr_t)dl_info.dli_fbase) {\n        ucs_module_debug(\"ignoring '%s' (%p) from %s (%p), expected in %s (%lx)\",\n                         symbol, addr, ucs_basename(dl_info.dli_fname),\n                         dl_info.dli_fbase, ucs_basename(module_path),\n                         lm_entry->l_addr);\n        return NULL;\n    }\n\n    return addr;\n}\n\nstatic void ucs_module_init(const char *module_path, void *dl)\n{\n    typedef ucs_status_t (*init_func_t)();\n\n    const char *module_init_name =\n                    UCS_PP_MAKE_STRING(UCS_MODULE_CONSTRUCTOR_NAME);\n    char *fullpath, buffer[PATH_MAX];\n    init_func_t init_func;\n    ucs_status_t status;\n\n    fullpath = realpath(module_path, buffer);\n    ucs_module_trace(\"loaded %s [%p]\", fullpath, dl);\n\n    init_func = (init_func_t)ucs_module_dlsym_shallow(module_path, dl,\n                                                      module_init_name);\n    if (init_func == NULL) {\n        ucs_module_trace(\"not calling constructor '%s' in %s\", module_init_name,\n                         module_path);\n        return;\n    }\n\n    ucs_module_trace(\"calling '%s' in '%s': [%p]\", module_init_name, fullpath,\n                     init_func);\n    status = init_func();\n    if (status != UCS_OK) {\n        ucs_module_debug(\"initializing '%s' failed: %s, unloading\", fullpath,\n                         ucs_status_string(status));\n        dlclose(dl);\n    }\n}\n\nstatic void ucs_module_load_one(const char *framework, const char *module_name,\n                                unsigned flags)\n{\n    char module_path[PATH_MAX] = {0};\n    const char *error;\n    unsigned i;\n    void *dl;\n    int mode;\n\n    mode = RTLD_LAZY;\n    if (flags & UCS_MODULE_LOAD_FLAG_NODELETE) {\n        mode |= RTLD_NODELETE;\n    }\n    if (flags & UCS_MODULE_LOAD_FLAG_GLOBAL) {\n        mode |= RTLD_GLOBAL;\n    } else {\n        mode |= RTLD_LOCAL;\n    }\n\n    for (i = 0; i < ucs_module_loader_state.srchpath_cnt; ++i) {\n        snprintf(module_path, sizeof(module_path) - 1, \"%s/lib%s_%s%s\",\n                 ucs_module_loader_state.srch_path[i], framework, module_name,\n                 ucs_module_loader_state.module_ext);\n\n        /* Clear error state */\n        (void)dlerror();\n        dl = dlopen(module_path, mode);\n        if (dl != NULL) {\n            ucs_module_init(module_path, dl);\n            break;\n        } else {\n            /* If a module fails to load, silently give up */\n            error = dlerror();\n            ucs_module_debug(\"dlopen('%s', mode=0x%x) failed: %s\", module_path,\n                             mode, error ? error : \"Unknown error\");\n        }\n    }\n\n    /* coverity[leaked_storage] : a loaded module is never unloaded */\n}\n\nvoid ucs_load_modules(const char *framework, const char *modules,\n                      ucs_init_once_t *init_once, unsigned flags)\n{\n    char *modules_str;\n    char *saveptr;\n    char *module_name;\n\n    ucs_module_loader_init_paths();\n\n    UCS_INIT_ONCE(init_once) {\n        ucs_module_debug(\"loading modules for %s\", framework);\n        modules_str = ucs_strdup(modules, \"modules_list\");\n        if (modules_str != NULL) {\n            saveptr     = NULL;\n            module_name = strtok_r(modules_str, \":\", &saveptr);\n            while (module_name != NULL) {\n                ucs_module_load_one(framework, module_name, flags);\n                module_name = strtok_r(NULL, \":\", &saveptr);\n            }\n            ucs_free(modules_str);\n        } else {\n            ucs_error(\"failed to allocate module names list\");\n        }\n    }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/ucx/src/ucs/sys/module.h": "/**\n * Copyright (C) Mellanox Technologies Ltd. 2001-2019.  ALL RIGHTS RESERVED.\n *\n * See file LICENSE for terms.\n */\n\n\n#ifndef UCS_MODULE_H_\n#define UCS_MODULE_H_\n\n#include <ucs/type/init_once.h>\n#include <ucs/sys/compiler_def.h>\n\n\n/**\n * Flags for @ref UCS_MODULE_FRAMEWORK_LOAD\n */\ntypedef enum {\n    UCS_MODULE_LOAD_FLAG_NODELETE = UCS_BIT(0), /**< Never unload */\n    UCS_MODULE_LOAD_FLAG_GLOBAL   = UCS_BIT(1)  /**< Load to global scope */\n} ucs_module_load_flags_t;\n\n\n/**\n * Declare a \"framework\", which is a context for a specific collection of\n * loadable modules. Usually the modules in a particular framework provide\n * alternative implementations of the same internal interface.\n *\n * @param [in] _name  Framework name (as a token)\n */\n#define UCS_MODULE_FRAMEWORK_DECLARE(_name) \\\n    static ucs_init_once_t ucs_framework_init_once_##_name = \\\n        UCS_INIT_ONCE_INITIALIZER\n\n\n/**\n * Load all modules in a particular framework.\n *\n * @param [in]  _name   Framework name, same as passed to\n *                      @ref UCS_MODULE_FRAMEWORK_DECLARE\n * @param [in]  _flags  Modules load flags, see @ref ucs_module_load_flags_t\n *\n * The modules in the framework are loaded by dlopen(). The shared library name\n * of a module is: \"lib<framework>_<module>.so.<version>\", where:\n * - <framework> is the framework name\n * - <module> is the module name. The list of all modules in a framework is\n *   defined by the preprocessor macro <framework>_MODULES in the auto-generated\n *   config.h file, for example: #define foo_MODULES \":bar1:bar2\".\n * - <version> is the shared library version of the module, as generated by\n *   libtool. It's extracted from the full path of the current library (libucs).\n *\n * Module shared libraries are searched in the following locations (in order of\n * priority):\n *  1. 'ucx' sub-directory inside the directory of the current shared library (libucs)\n *  2. ${libdir}/ucx, where ${libdir} is the directory where libraries are installed\n * Note that if libucs is loaded from its installation path, (1) and (2) are the\n * same location. Only if libucs is moved or ran from build directory, the paths\n * will be different, in which case we prefer the 'local' library rather than the\n * 'installed' one.\n *\n * @param [in] _name  Framework name (as a token)\n */\n#define UCS_MODULE_FRAMEWORK_LOAD(_name, _flags) \\\n    ucs_load_modules(#_name, _name##_MODULES, &ucs_framework_init_once_##_name, \\\n                     _flags)\n\n\n/**\n * Define a function to be called when a module is loaded.\n * Some things can't be done in shared library constructor, and need to be done\n * only after dlopen() completes. For example, loading another shared library\n * which uses symbols from the current module.\n *\n * Usage:\n *    UCS_MODULE_INIT() { ... code ... }\n */\n#define UCS_MODULE_INIT() \\\n    ucs_status_t __attribute__((visibility(\"protected\"))) \\\n    UCS_MODULE_CONSTRUCTOR_NAME(void)\n\n\n/**\n * Define the name of a loadable module global constructor\n */\n#define UCS_MODULE_CONSTRUCTOR_NAME \\\n    ucs_module_global_init\n\n\n/**\n * Internal function. Please use @ref UCS_MODULE_FRAMEWORK_LOAD macro instead.\n */\nvoid ucs_load_modules(const char *framework, const char *modules,\n                      ucs_init_once_t *init_once, unsigned flags);\n\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/ucx/test/mpi/test_memhooks.c": "/**\n * Copyright (C) Mellanox Technologies Ltd. 2001-2015.  ALL RIGHTS RESERVED.\n *\n * See file LICENSE for terms.\n */\n#define _GNU_SOURCE /* For basename */\n#include <mpi.h>\n\n#include <ucs/sys/preprocessor.h>\n#include <ucm/api/ucm.h>\n#include <sys/mman.h>\n#include <sys/shm.h>\n#include <malloc.h>\n#include <dlfcn.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define CHKERR_JUMP(cond, msg, label) \\\n    do { \\\n        if (cond) { \\\n            printf(\"%s:%d: %s\\n\", basename(__FILE__), __LINE__, msg); \\\n            goto label; \\\n        } \\\n    } while (0)\n\n#define DL_FIND_FUNC(dl, func_name, func, err_action) \\\n    do { \\\n        char *error; \\\n        dlerror(); /* clear existing errors */ \\\n        func = dlsym(dl, func_name); \\\n        if (((error = dlerror()) != NULL) || (func == NULL)) { \\\n            error = error ? error : \"not found\"; \\\n            fprintf(stderr, \"Failed to resolve symbol '%s': %s\\n\", \\\n                    func_name, error); \\\n            err_action; \\\n        } \\\n    } while (0);\n\n#define SHMAT_FAILED ((void*)-1)\n\nvoid* open_dyn_lib(const char *lib_path);\nvoid* flag_no_install_init(const char *path);\nint malloc_hooks_run_all(void *dl);\nint malloc_hooks_run_unmapped(void *dl);\nint ext_event_run(void *dl);\nvoid *ext_event_init(const char *path);\n\ntypedef struct memtest_type {\n    const char *name;\n    void*      (*init)(const char *path);\n    int        (*run) (void *arg);\n} memtest_type_t;\n\nmemtest_type_t tests[] = {\n    {\"malloc_hooks\",          open_dyn_lib,         malloc_hooks_run_all},\n    {\"malloc_hooks_unmapped\", open_dyn_lib,         malloc_hooks_run_unmapped},\n    {\"external_events\",       ext_event_init,       ext_event_run},\n    {\"flag_no_install\",       flag_no_install_init, ext_event_run},\n    {NULL}\n};\n\nstatic volatile size_t total_mapped = 0;\nstatic volatile size_t total_unmapped = 0;\n\nstatic void usage() {\n    printf(\"Usage: test_memhooks [options]\\n\");\n    printf(\"Options are:\\n\");\n    printf(\"  -h         Print this info.\\n\");\n    printf(\"  -t <name>  Test name to execute (malloc_hooks)\\n\");\n    printf(\"                 malloc_hooks          : General UCM test for VM_MAPPED and VM_UNMAPPED\\n\");\n    printf(\"                 malloc_hooks_unmapped : Test VM_UNMAPPED event only\\n\");\n    printf(\"                 external_events       : Test of ucm_set_external_event() API\\n\");\n    printf(\"                 flag_no_install       : Test of UCM_EVENT_FLAG_NO_INSTALL flag\\n\");\n    printf(\"\\n\");\n}\n\nstatic void event_callback(ucm_event_type_t event_type, ucm_event_t *event,\n                           void *arg)\n{\n    if (event_type == UCM_EVENT_VM_MAPPED) {\n        total_mapped += event->vm_mapped.size;\n    } else if (event_type == UCM_EVENT_VM_UNMAPPED) {\n        total_unmapped += event->vm_unmapped.size;\n    }\n}\n\nstatic ucs_status_t set_event_handler(void *dl, int events)\n{\n    ucs_status_t (*set_handler)(int events, int priority,\n                                ucm_event_callback_t cb, void *arg);\n\n    DL_FIND_FUNC(dl, \"ucm_set_event_handler\", set_handler,\n                 return UCS_ERR_UNSUPPORTED);\n\n    return set_handler(events, 0, event_callback, NULL);\n}\n\nstatic ucs_status_t disable_memory_hooks(void *dl)\n{\n    setenv(\"UCX_MEM_MALLOC_HOOKS\", \"n\", 1);\n    setenv(\"UCX_MEM_MMAP_RELOC\",   \"n\", 1);\n    return UCS_OK;\n}\n\nvoid* open_dyn_lib(const char *lib_path)\n{\n    void *dl = dlopen(lib_path, RTLD_LAZY);\n    char *error;\n\n    if (dl == NULL) {\n        error = dlerror();\n        error = error ? error : \"unknown error\";\n        fprintf(stderr, \"Failed to load '%s': %s\\n\", lib_path, error);\n    }\n    return dl;\n}\n\n\nvoid *ext_event_init(const char *path)\n{\n    void (*set_ext_event)(int events);\n    ucs_status_t status;\n    void *dl_ucm;\n\n    dl_ucm = open_dyn_lib(path);\n    if (dl_ucm == NULL) {\n        return NULL;\n    }\n\n    status = disable_memory_hooks(dl_ucm);\n    CHKERR_JUMP(status != UCS_OK, \"Failed to disable memory hooks\", fail);\n\n    DL_FIND_FUNC(dl_ucm, \"ucm_set_external_event\", set_ext_event, goto fail);\n    set_ext_event(UCM_EVENT_VM_MAPPED | UCM_EVENT_VM_UNMAPPED);\n\n    status = set_event_handler(dl_ucm, UCM_EVENT_VM_MAPPED |\n                                       UCM_EVENT_VM_UNMAPPED);\n    CHKERR_JUMP(status != UCS_OK, \"Failed to set event handler\", fail);\n\n    return dl_ucm;\n\nfail:\n    dlclose(dl_ucm);\n    return NULL;\n}\n\nvoid* flag_no_install_init(const char *path)\n{\n    void *dl_ucm;\n    ucs_status_t status;\n\n    dl_ucm = open_dyn_lib(path);\n    if (dl_ucm == NULL) {\n        return NULL;\n    }\n\n    status = disable_memory_hooks(dl_ucm);\n    CHKERR_JUMP(status != UCS_OK, \"Failed to disable memory hooks\", fail);\n\n    status = set_event_handler(dl_ucm, UCM_EVENT_VM_MAPPED   |\n                                       UCM_EVENT_VM_UNMAPPED |\n                                       UCM_EVENT_FLAG_NO_INSTALL);\n    CHKERR_JUMP(status != UCS_OK, \"Failed to set event handler\", fail);\n    return dl_ucm;\n\nfail:\n    dlclose(dl_ucm);\n    return NULL;\n}\n\nint malloc_hooks_run_flags(void *dl, ucm_event_type_t events)\n{\n    ucs_status_t status;\n    void *ptr_malloc_core = NULL;\n    void *ptr_malloc_mmap = NULL;\n    void *ptr_direct_mmap = MAP_FAILED;\n    int  shmid            = -1;\n    void *ptr_shmat       = SHMAT_FAILED;\n    void *dl_test;\n    const size_t size = 1024 * 1024;\n    const char *lib_path = UCS_PP_MAKE_STRING(TEST_LIB_DIR) \"/\" \"libtest_memhooks.so\";\n    const char *cust_mmap_name  = \"memhook_test_lib_call_mmap\";\n    void * (*cust_mmap)(size_t size);\n\n    status = set_event_handler(dl, events);\n    CHKERR_JUMP(status != UCS_OK, \"Failed to set event handler\", fail_close_ucm);\n\n    printf(\"Allocating memory\\n\");\n\n    /* Create SysV segment */\n    shmid = shmget(IPC_PRIVATE, size, IPC_CREAT|SHM_R|SHM_W);\n    CHKERR_JUMP(shmid == -1, \"Failed to create shared memory segment: %m\",\n                fail_close_ucm);\n\n    /*\n     * Test shmat/shmdt before malloc() because shmat() add entires to an internal\n     * hash of pointers->size, which makes previous pointers un-releasable\n     */\n\n    /* Attach SysV segment */\n    total_mapped = 0;\n    ptr_shmat = shmat(shmid, NULL, 0);\n    CHKERR_JUMP(ptr_shmat == SHMAT_FAILED, \"Failed to attach shared memory segment\",\n                fail_close_ucm);\n    if (events & UCM_EVENT_VM_MAPPED) {\n        CHKERR_JUMP(total_mapped < size, \"No callback for shmat\", fail_close_ucm);\n    }\n    printf(\"After shmat: reported mapped=%zu\\n\", total_mapped);\n\n    /* Detach SysV segment */\n    total_unmapped = 0;\n    shmdt(ptr_shmat);\n    ptr_shmat = SHMAT_FAILED;\n    if (events & UCM_EVENT_VM_UNMAPPED) {\n        CHKERR_JUMP(total_unmapped < size, \"No callback for shmdt\", fail_close_ucm);\n    }\n    printf(\"After shmdt: reported unmapped=%zu\\n\", total_unmapped);\n\n    /* Attach SysV segment at fixed address */\n    total_mapped = 0;\n    total_unmapped = 0;\n    ptr_shmat = shmat(shmid, (void*)0xff000000, SHM_REMAP);\n    CHKERR_JUMP(ptr_shmat == SHMAT_FAILED, \"Failed to attach shared memory segment\",\n                fail_close_ucm);\n    if (events & UCM_EVENT_VM_MAPPED) {\n        CHKERR_JUMP(total_mapped < size, \"No map callback for shmat(REMAP)\", fail_close_ucm);\n    }\n    if (events & UCM_EVENT_VM_UNMAPPED) {\n        CHKERR_JUMP(total_unmapped < size, \"No unmap callback for shmat(REMAP)\",\n                    fail_close_ucm);\n    }\n    printf(\"After shmat(REMAP): reported mapped=%zu unmapped=%zu\\n\", total_mapped,\n           total_unmapped);\n\n    /* Detach SysV segment */\n    total_unmapped = 0;\n    shmdt(ptr_shmat);\n    ptr_shmat = SHMAT_FAILED;\n    if (events & UCM_EVENT_VM_UNMAPPED) {\n        CHKERR_JUMP(total_unmapped < size, \"No callback for shmdt\", fail_close_ucm);\n    }\n    printf(\"After shmdt: reported unmapped=%zu\\n\", total_unmapped);\n\n    /* Destroy SysV segment */\n    shmctl(shmid, IPC_RMID, NULL);\n    shmid = -1;\n\n    /* Allocate using morecore */\n    mallopt(M_MMAP_THRESHOLD, size * 2);\n    mallopt(M_TRIM_THRESHOLD, size / 2);\n    total_mapped = 0;\n    ptr_malloc_core = malloc(1024 * 1024);\n    if (events & UCM_EVENT_VM_MAPPED) {\n        CHKERR_JUMP(total_mapped == 0, \"No callback for core malloc\",\n                    fail_close_ucm);\n    }\n    printf(\"After core malloc: reported mapped=%zu\\n\", total_mapped);\n\n    /* Allocate using mmap */\n    mallopt(M_MMAP_THRESHOLD, size / 2);\n    total_mapped = 0;\n    ptr_malloc_mmap = malloc(2 * 1024 * 1024);\n    if (events & UCM_EVENT_VM_MAPPED) {\n        CHKERR_JUMP(total_mapped == 0, \"No callback for mmap malloc\",\n                    fail_close_ucm);\n    }\n    printf(\"After mmap malloc: reported mapped=%zu\\n\", total_mapped);\n\n    /* Allocate directly with mmap */\n    total_mapped = 0;\n    ptr_direct_mmap = mmap(NULL, size, PROT_READ|PROT_WRITE,\n                           MAP_PRIVATE|MAP_ANON, -1, 0);\n    if (events & UCM_EVENT_VM_MAPPED) {\n        CHKERR_JUMP(total_mapped < size, \"No callback for mmap\", fail_close_ucm);\n    }\n    printf(\"After mmap: reported mapped=%zu\\n\", total_mapped);\n\n    /* Remap */\n    total_unmapped = 0;\n    ptr_direct_mmap = mmap(ptr_direct_mmap, size, PROT_READ|PROT_WRITE,\n                           MAP_PRIVATE|MAP_ANON|MAP_FIXED, -1, 0);\n    if (events & UCM_EVENT_VM_UNMAPPED) {\n        CHKERR_JUMP(total_unmapped < size, \"No unmap callback for mmap(FIXED)\",\n                    fail_close_ucm);\n    }\n    printf(\"After mmap(FIXED): reported unmapped=%zu\\n\", total_unmapped);\n\n    /* Call munmap directly */\n    total_unmapped = 0;\n    munmap(ptr_direct_mmap, size);\n    if (events & UCM_EVENT_VM_UNMAPPED) {\n        CHKERR_JUMP(total_unmapped == 0, \"No callback for munmap\", fail_close_ucm);\n    }\n    printf(\"After munmap: reported unmapped=%zu\\n\", total_unmapped);\n\n    /* Release indirectly */\n    total_unmapped = 0;\n    free(ptr_malloc_mmap);\n    ptr_malloc_mmap = NULL;\n    malloc_trim(0);\n    if (events & UCM_EVENT_VM_UNMAPPED) {\n        CHKERR_JUMP(total_unmapped == 0, \"No callback for munmap from free\",\n                    fail_close_ucm);\n    }\n    printf(\"After mmap free + trim: reported unmapped=%zu\\n\", total_unmapped);\n\n    /* Call mmap from a library we load after hooks are installed */\n    dl_test = open_dyn_lib(lib_path);\n    CHKERR_JUMP(dl_test == NULL, \"Failed to load test lib\", fail_close_ucm);\n\n    DL_FIND_FUNC(dl_test, cust_mmap_name, cust_mmap, goto fail_close_all);\n    total_mapped = 0;\n    ptr_direct_mmap = cust_mmap(size);\n    CHKERR_JUMP(ptr_direct_mmap == MAP_FAILED, \"Failed to mmap from dynamic lib\",\n                fail_close_all);\n    if (events & UCM_EVENT_VM_MAPPED) {\n        CHKERR_JUMP(total_mapped == 0,\"No callback for mmap from dynamic lib\",\n                    fail_close_all);\n    }\n    printf(\"After another mmap from dynamic lib: reported mapped=%zu\\n\", total_mapped);\n    munmap(ptr_direct_mmap, size);\n    ptr_direct_mmap = MAP_FAILED;\n\n    /*\n     * Test closing UCM.\n     * The library should not really be unloaded, because the memory hooks still\n     * point to functions inside it.\n     */\n    total_unmapped = 0;\n    dlclose(dl);\n    dlclose(dl_test);\n    free(ptr_malloc_core); /* This should still work */\n    ptr_malloc_core = NULL;\n    malloc_trim(0);\n    if (events & UCM_EVENT_VM_UNMAPPED) {\n        CHKERR_JUMP(total_unmapped == 0, \"No callback for munmap from malloc\", fail);\n    }\n    printf(\"After core malloc free: reported unmapped=%zu\\n\", total_unmapped);\n\n    return 0;\n\nfail_close_all:\n    dlclose(dl_test);\nfail_close_ucm:\n    dlclose(dl);\nfail:\n    if (ptr_shmat != SHMAT_FAILED) {\n        shmdt(ptr_shmat);\n    }\n    if (shmid != -1) {\n        shmctl(shmid, IPC_RMID, NULL);\n    }\n    free(ptr_malloc_mmap);\n    free(ptr_malloc_core);\n    if (ptr_direct_mmap != MAP_FAILED) {\n        munmap(ptr_direct_mmap, size);\n    }\n\n    return  -1;\n}\n\nint malloc_hooks_run_all(void *dl)\n{\n    return malloc_hooks_run_flags(dl, UCM_EVENT_VM_MAPPED | UCM_EVENT_VM_UNMAPPED);\n}\n\nint malloc_hooks_run_unmapped(void *dl)\n{\n    return malloc_hooks_run_flags(dl, UCM_EVENT_VM_UNMAPPED);\n}\n\nint ext_event_run(void *dl)\n{\n    void *ptr_direct_mmap;\n    void (*ucm_event)(void *addr, size_t length);\n    const size_t size = 1024 * 1024;\n    int ret = -1;\n\n    /* Allocate directly with mmap */\n    total_mapped = 0;\n    ptr_direct_mmap = mmap(NULL, size, PROT_READ|PROT_WRITE,\n                           MAP_PRIVATE|MAP_ANON, -1, 0);\n    printf(\"totmapped %lu\\n\", total_mapped);\n    /* No callback should be called as we registered events to be external */\n    CHKERR_JUMP(total_mapped != 0,\n                \"Callback for mmap invoked, while hooks were not set\", fail);\n    DL_FIND_FUNC(dl, \"ucm_vm_mmap\", ucm_event, goto fail);\n    ucm_event(ptr_direct_mmap, size);\n    CHKERR_JUMP(total_mapped == 0, \"Callback for mmap is not called\", fail);\n    printf(\"After ucm_vm_mmap called: mapped=%zu\\n\", total_mapped);\n\n    /* Call munmap directly */\n    total_unmapped = 0;\n    munmap(ptr_direct_mmap, size);\n    CHKERR_JUMP(total_unmapped != 0,\n                \"Callback for munmap invoked, while hooks were not set\\n\", fail);\n\n    DL_FIND_FUNC(dl, \"ucm_vm_munmap\", ucm_event, goto fail);\n    ucm_event(ptr_direct_mmap, size);\n    CHKERR_JUMP(total_unmapped == 0, \"Callback for mmap is not called\", fail);\n    printf(\"After ucm_vm_munmap: unmapped=%zu\\n\", total_unmapped);\n\n    ret = 0;\n\nfail:\n    dlclose(dl);\n    return ret;\n}\n\nint main(int argc, char **argv)\n{\n    const char *ucm_path = UCS_PP_MAKE_STRING(UCM_LIB_DIR) \"/\" \"libucm.so\";\n    memtest_type_t *test = tests;\n    void *dl;\n    int ret;\n    int c;\n\n    while ((c = getopt(argc, argv, \"t:h\")) != -1) {\n        switch (c) {\n        case 't':\n            for (test = tests; test->name != NULL; ++test) {\n                if (!strcmp(test->name, optarg)){\n                    break;\n                }\n            }\n            if (test->name == NULL) {\n                fprintf(stderr, \"Wrong test name %s\\n\", optarg);\n                return -1;\n            }\n            break;\n        case 'h':\n        default:\n            usage();\n            return -1;\n        }\n    }\n\n    /* Some tests need to modify UCM config before to call ucp_init,\n     * which may be called by MPI_Init */\n    dl = test->init(ucm_path);\n    if (dl == NULL) {\n        return -1;\n    }\n\n    printf(\"%s: initialized\\n\", test->name);\n\n    MPI_Init(&argc, &argv);\n\n    ret = test->run(dl);\n\n    printf(\"%s: %s\\n\", test->name, ret == 0 ? \"PASS\" : \"FAIL\");\n\n    MPI_Finalize();\n    return ret;\n}\n\n\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/ucx/test/gtest/configure.m4": "#\n# Copyright (C) Mellanox Technologies Ltd. 2001-2019.  ALL RIGHTS RESERVED.\n#\n# See file LICENSE for terms.\n#\n\nAC_LANG_PUSH([C++])\n\nCHECK_COMPILER_FLAG([-fno-tree-vectorize], [-fno-tree-vectorize],\n                    [AC_LANG_SOURCE([[int main(int argc, char** argv){return 0;}]])],\n                    [GTEST_CXXFLAGS=\"$GTEST_CXXFLAGS -fno-tree-vectorize\"],\n                    [])\n\n# error #236: controlling expression is constant\nCHECK_COMPILER_FLAG([--diag_suppress 236], [--diag_suppress 236],\n                    [AC_LANG_SOURCE([[int main(int argc, char** argv){return 0;}]])],\n                    [GTEST_CXXFLAGS=\"$GTEST_CXXFLAGS --diag_suppress 236\"],\n                    [])\n\nAC_LANG_POP([C++])\n\nAC_SUBST([GTEST_CXXFLAGS], [$GTEST_CXXFLAGS])\n\ntest_modules=\"\"\nm4_include([test/gtest/ucm/test_dlopen/configure.m4])\nm4_include([test/gtest/ucm/test_dlopen/rpath-subdir/configure.m4])\nm4_include([test/gtest/ucs/test_module/configure.m4])\nAC_DEFINE_UNQUOTED([test_MODULES], [\"${test_modules}\"], [Test loadable modules])\nAC_CONFIG_FILES([test/gtest/Makefile])\n",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/ucx/test/gtest/Makefile.am": "#\n# Copyright (C) Mellanox Technologies Ltd. 2001-2014.  ALL RIGHTS RESERVED.\n# Copyright (C) UT-Battelle, LLC. 2015. ALL RIGHTS RESERVED.\n# Copyright (C) The University of Tennessee and the University of Tennessee Research Foundation. 2016. ALL RIGHTS RESERVED.\n# Copyright (C) Los Alamos National Security, LLC. 2018 ALL RIGHTS RESERVED.\n# Copyright (C) Advanced Micro Devices, Inc. 2019. ALL RIGHTS RESERVED.\n#\n# See file LICENSE for terms.\n#\n\nif HAVE_GTEST\n\n# Set default configuration for running tests\nUCX_HANDLE_ERRORS        ?= freeze\nUCX_LOG_LEVEL            ?= warn\nUCX_LOG_PRINT_ENABLE     ?= y\nGTEST_FILTER             ?= *\nGTEST_EXTRA_ARGS         ?=\nLAUNCHER                 ?=\nVALGRIND_EXTRA_ARGS      ?=\n\nSUBDIRS = ucs/test_module ucm/test_dlopen\n\nexport UCX_HANDLE_ERRORS\nexport UCX_LOG_LEVEL\nexport UCX_LOG_PRINT_ENABLE\n\nGTEST_ARGS = \\\n\t--gtest_filter=$(GTEST_FILTER) \\\n\t$(GTEST_EXTRA_ARGS)\n\nVALGRIND_ARGS = \\\n\t--tool=memcheck \\\n\t--leak-check=full \\\n\t--track-origins=yes \\\n\t--fair-sched=try \\\n\t--num-callers=25 \\\n\t--error-exitcode=1 \\\n\t--child-silent-after-fork=yes \\\n\t--suppressions=$(top_srcdir)/contrib/valgrind.supp \\\n\t$(VALGRIND_EXTRA_ARGS)\n\nnoinst_PROGRAMS = gtest\n\ngtestdir  = $(includedir)\ngtest_LDADD = \\\n\t$(top_builddir)/src/ucs/libucs.la \\\n\t$(top_builddir)/src/uct/libuct.la \\\n\t$(top_builddir)/src/ucm/libucm.la \\\n\t$(top_builddir)/src/ucp/libucp.la \\\n\t$(top_builddir)/src/tools/perf/lib/libucxperf.la \\\n\t$(OPENMP_CFLAGS) \\\n\t$(GTEST_LIBS)\n\n\ngtest_CPPFLAGS = \\\n\t$(BASE_CPPFLAGS) \\\n\t-I$(top_srcdir)/src \\\n\t-I$(top_srcdir)/test \\\n\t-I$(top_builddir)/src \\\n\t-I$(top_srcdir)/test/gtest \\\n\t$(GTEST_CPPFLAGS) \\\n\t$(OPENMP_CFLAGS)\n\ngtest_LDFLAGS  = $(GTEST_LDFLAGS) -no-install -Wl,-dynamic-list-data\ngtest_CFLAGS   = $(BASE_CFLAGS)\ngtest_CXXFLAGS = \\\n\t$(BASE_CXXFLAGS) $(GTEST_CXXFLAGS) \\\n\t-DGTEST_UCM_HOOK_LIB_DIR=\"\\\"${abs_builddir}/ucm/test_dlopen/.libs\\\"\"\n\ngtest_SOURCES = \\\n\tcommon/gtest-all.cc \\\n\tcommon/main.cc \\\n\tcommon/test_gtest_cmn.cc \\\n\tcommon/mem_buffer.cc \\\n\tcommon/test_helpers.cc \\\n\tcommon/test_obj_size.cc \\\n\tcommon/test_watchdog.cc \\\n\tcommon/test_perf.cc \\\n\tcommon/test.cc \\\n\t\\\n\tucm/malloc_hook.cc \\\n\t\\\n\tuct/test_amo.cc \\\n\tuct/test_amo_add_xor.cc \\\n\tuct/test_amo_and_or.cc \\\n\tuct/test_amo_cswap.cc \\\n\tuct/test_amo_fadd_fxor.cc \\\n\tuct/test_amo_fand_for.cc \\\n\tuct/test_amo_swap.cc \\\n\tuct/test_event.cc \\\n\tuct/test_fence.cc \\\n\tuct/test_flush.cc \\\n\tuct/test_many2one_am.cc \\\n\tuct/test_md.cc \\\n\tuct/test_mm.cc \\\n\tuct/test_mem.cc \\\n\tuct/test_p2p_am.cc \\\n\tuct/test_p2p_err.cc \\\n\tuct/test_p2p_mix.cc \\\n\tuct/test_p2p_rma.cc \\\n\tuct/test_pending.cc \\\n\tuct/test_progress.cc \\\n\tuct/test_uct_ep.cc \\\n\tuct/test_uct_perf.cc \\\n\tuct/test_zcopy_comp.cc \\\n\tuct/uct_p2p_test.cc \\\n\tuct/uct_test.cc \\\n\tuct/test_stats.cc \\\n\tucs/test_event_set.cc \\\n\tucs/test_stats_filter.cc \\\n\tuct/test_peer_failure.cc \\\n\tuct/test_tag.cc \\\n\tuct/tcp/test_tcp.cc \\\n\t\\\n\tucp/test_ucp_am.cc \\\n\tucp/test_ucp_stream.cc \\\n\tucp/test_ucp_peer_failure.cc \\\n\tucp/test_ucp_atomic.cc \\\n\tucp/test_ucp_dt.cc \\\n\tucp/test_ucp_memheap.cc \\\n\tucp/test_ucp_mmap.cc \\\n\tucp/test_ucp_mem_type.cc \\\n\tucp/test_ucp_perf.cc \\\n\tucp/test_ucp_proto.cc \\\n\tucp/test_ucp_rma.cc \\\n\tucp/test_ucp_rma_mt.cc \\\n\tucp/test_ucp_tag_cancel.cc \\\n\tucp/test_ucp_tag_match.cc \\\n\tucp/test_ucp_tag_offload.cc \\\n\tucp/test_ucp_tag_mt.cc \\\n\tucp/test_ucp_tag_perf.cc \\\n\tucp/test_ucp_tag_probe.cc \\\n\tucp/test_ucp_tag_xfer.cc \\\n\tucp/test_ucp_tag_mem_type.cc \\\n\tucp/test_ucp_tag.cc \\\n\tucp/test_ucp_context.cc \\\n\tucp/test_ucp_wireup.cc \\\n\tucp/test_ucp_wakeup.cc \\\n\tucp/test_ucp_fence.cc \\\n\tucp/test_ucp_sockaddr.cc \\\n\tucp/ucp_test.cc \\\n\tucp/ucp_datatype.cc \\\n\t\\\n\tucs/test_algorithm.cc \\\n\tucs/test_arbiter.cc \\\n\tucs/test_async.cc \\\n\tucs/test_callbackq.cc \\\n\tucs/test_class.cc \\\n\tucs/test_config.cc \\\n\tucs/test_datatype.cc \\\n\tucs/test_debug.cc \\\n\tucs/test_memtrack.cc \\\n\tucs/test_math.cc \\\n\tucs/test_mpmc.cc \\\n\tucs/test_mpool.cc \\\n\tucs/test_pgtable.cc \\\n\tucs/test_profile.cc \\\n\tucs/test_rcache.cc \\\n\tucs/test_memtype_cache.cc \\\n\tucs/test_stats.cc \\\n\tucs/test_strided_alloc.cc \\\n\tucs/test_string.cc \\\n\tucs/test_sys.cc \\\n\tucs/test_topo.cc \\\n\tucs/test_sock.cc \\\n\tucs/test_time.cc \\\n\tucs/test_twheel.cc \\\n\tucs/test_frag_list.cc \\\n\tucs/test_type.cc \\\n\tucs/test_log.cc \\\n\tucs/test_iov.cc \\\n\tucs/arch/test_x86_64.cc\n\nif HAVE_IB\ngtest_SOURCES += \\\n\tuct/ib/test_ib.cc \\\n\tuct/ib/test_ib_md.cc \\\n\tuct/ib/test_cq_moderation.cc \\\n\tuct/ib/test_ib_xfer.cc \\\n\tuct/ib/test_ib_pkey.cc \\\n\tuct/ib/test_ib_event.cc\ngtest_CPPFLAGS += \\\n\t$(IBVERBS_CPPFLAGS)\ngtest_LDADD += \\\n\t$(IBVERBS_LDFLAGS) \\\n\t$(top_builddir)/src/uct/ib/libuct_ib.la\nif HAVE_DEVX\ngtest_SOURCES += \\\n\tuct/ib/test_devx.cc\nendif\nif HAVE_TL_UD\ngtest_SOURCES += \\\n\tuct/ib/ud_base.cc \\\n\tuct/ib/test_ud.cc \\\n\tuct/ib/test_ud_timer.cc \\\n\tuct/ib/test_ud_pending.cc \\\n\tuct/ib/test_ud_ds.cc\nendif\nif HAVE_TL_RC\ngtest_SOURCES += \\\n\tuct/ib/test_rc.cc\nendif\t\nif HAVE_TL_DC\ngtest_SOURCES += \\\n\tuct/ib/test_dc.cc\nendif\nif HAVE_RDMACM\ngtest_SOURCES += \\\n\tuct/ib/test_sockaddr.cc\nendif\nendif # HAVE_IB\n\nif HAVE_CUDA\ngtest_SOURCES += \\\n\tucm/cuda_hooks.cc\ngtest_CPPFLAGS += \\\n\t$(CUDA_CPPFLAGS)\ngtest_LDADD += \\\n\t$(CUDA_LDFLAGS) \\\n\t$(top_builddir)/src/uct/cuda/libuct_cuda.la\nendif\n\nif HAVE_HIP\nif HAVE_GNUXX11\ngtest_SOURCES += \\\n\tucm/rocm_hooks.cc\ngtest_CPPFLAGS += \\\n\t$(HIP_CPPFLAGS)\ngtest_CXXFLAGS += \\\n\t$(HIP_CXXFLAGS)\ngtest_LDADD += \\\n\t$(HIP_LDFLAGS) \\\n\t$(HIP_LIBS) \\\n\t$(top_builddir)/src/uct/rocm/libuct_rocm.la\nendif\nendif\n\nnoinst_HEADERS = \\\n\tcommon/gtest.h \\\n\tcommon/mem_buffer.h \\\n\tcommon/test.h \\\n\tcommon/test_helpers.h \\\n\tcommon/test_perf.h \\\n\tcommon/tap.h \\\n\t\\\n\tuct/ib/test_rc.h \\\n\tuct/ib/ud_base.h \\\n\tuct/ib/test_ib.h \\\n\tuct/test_amo.h \\\n\tuct/test_p2p_mix.h \\\n\tuct/test_p2p_rma.h \\\n\tuct/uct_p2p_test.h \\\n\tuct/uct_test.h \\\n\tuct/test_md.h \\\n\t\\\n\tucp/test_ucp_atomic.h \\\n\tucp/test_ucp_memheap.h \\\n\tucp/test_ucp_tag.h \\\n\tucp/ucp_test.h \\\n\tucp/ucp_datatype.h\n\n.PHONY: test test gdb valgrind fix_rpath ucx\n\n\nall-local: gtest\n\nucx:\n\t$(MAKE) -C $(top_builddir)\n\n\nhelp:\n\t@echo\n\t@echo \"Targets:\"\n\t@echo \"  list          : List unit tests.\"\n\t@echo \"  test          : Run unit tests.\"\n\t@echo \"  test_gdb      : Run unit tests with GDB.\"\n\t@echo \"  test_valgrind : Run unit tests with Valgrind.\"\n\t@echo\n\t@echo \"Environment variables:\"\n\t@echo \"  GTEST_FILTER        : Unit tests filter (\\\"$(GTEST_FILTER)\\\")\"\n\t@echo \"  GTEST_EXTRA_ARGS    : Additional arguments for gtest (\\\"$(GTEST_EXTRA_ARGS)\\\")\"\n\t@echo \"  LAUNCHER            : Custom launcher for gtest executable (\\\"$(LAUNCHER)\\\")\"\n\t@echo \"  VALGRIND_EXTRA_ARGS : Additional arguments for Valgrind (\\\"$(VALGRIND_EXTRA_ARGS)\\\")\"\n\t@echo\n\n#\n# List unit tests\n#\nlist: gtest\n\t$(abs_builddir)/gtest --gtest_list_tests $(GTEST_ARGS)\n\n#\n# Run unit tests\n#\ntest: ucx gtest\n\t@rm -f core.*\n\t$(LAUNCHER) stdbuf -e0 -o0 $(abs_builddir)/gtest $(GTEST_ARGS)\n\n#\n# Run unit tests with GDB\n#\ntest_gdb: ucx gtest\n\techo -e 'r\\ninit-if-undefined $$_exitcode=-1\\nif $$_exitcode>=0\\n\\tq\\nend' > .gdbcommands\n\t$(LAUNCHER) env UCX_HANDLE_ERRORS=none \\\n\t\tgdb -x .gdbcommands --args $(GDB_ARGS) \\\n\t\t\t$(abs_builddir)/gtest $(GTEST_ARGS)\n\n#\n# Run unit tests with valgrind\n#\ntest_valgrind: ucx gtest\n\t$(LAUNCHER) env LD_LIBRARY_PATH=\"$(VALGRIND_LIBPATH):${LD_LIBRARY_PATH}\" \\\n\tstdbuf -e0 -o0 valgrind $(VALGRIND_ARGS) $(abs_builddir)/gtest $(GTEST_ARGS)\nendif\n",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/ucx/test/gtest/ucm/malloc_hook.cc": "/**\n * Copyright (C) Mellanox Technologies Ltd. 2001-2018.  ALL RIGHTS RESERVED.\n *\n * See file LICENSE for terms.\n */\n\n#define __STDC_LIMIT_MACROS\n\n#include <ucm/api/ucm.h>\n\n#include <ucs/arch/atomic.h>\n#include <ucs/type/status.h>\n#include <common/test.h>\n#include <common/test_helpers.h>\n#include <pthread.h>\n#include <sstream>\n#include <stdint.h>\n#include <dlfcn.h>\n#include <libgen.h>\n\nextern \"C\" {\n#include <ucs/time/time.h>\n#include <ucm/malloc/malloc_hook.h>\n#include <ucm/bistro/bistro.h>\n#include <ucs/sys/sys.h>\n#include <malloc.h>\n}\n\n#if HAVE_MALLOC_SET_STATE && HAVE_MALLOC_GET_STATE\n#  define HAVE_MALLOC_STATES 1\n#endif /* HAVE_MALLOC_SET_STATE && HAVE_MALLOC_GET_STATE */\n\n#define EXPECT_INCREASED(_value, _prev, _size, _name)  \\\n    {                                                  \\\n        EXPECT_GE(_value, (_prev) + (_size)) << _name; \\\n        _prev = _value;                                \\\n    }\n\n\nclass malloc_hook_test_no_events : public ucs::test {\nprotected:\n    virtual ~malloc_hook_test_no_events()\n    {\n    }\n\n    static void empty_event_callback(ucm_event_type_t event_type,\n                                     ucm_event_t *event, void *arg)\n    {\n    }\n\n    virtual void init()\n    {\n        ucs::test::init();\n        m_enable_events = ucm_global_opts.enable_events;\n        ucm_global_opts.enable_events = 0;\n    }\n\n    virtual void cleanup()\n    {\n        ucm_global_opts.enable_events = m_enable_events;\n        ucs::test::cleanup();\n    }\n\n    int m_enable_events;\n};\n\nUCS_TEST_F(malloc_hook_test_no_events, empty_event) {\n    ucs_status_t status;\n    status = ucm_set_event_handler(0, 0, empty_event_callback, NULL);\n    ASSERT_UCS_OK(status);\n    ucm_unset_event_handler(0, empty_event_callback, NULL);\n}\n\n\ntemplate <class T>\nclass mhook_thread {\npublic:\n    mhook_thread(T *test): m_test(test)\n    {\n        pthread_create(&m_thread, NULL, thread_func, reinterpret_cast<void*>(m_test));\n    }\n\n    ~mhook_thread() {\n        join();\n        delete m_test;\n    }\n\n    void join() {\n        void *retval;\n        pthread_join(m_thread, &retval);\n    }\n\nprotected:\n    T         *m_test;\n    pthread_t m_thread;\n\n    static void *thread_func(void *arg) {\n        T *test = reinterpret_cast<T*>(arg);\n        test->test();\n        return NULL;\n    }\n};\n\ntemplate <class T>\nclass mmap_event {\npublic:\n    mmap_event(T *test): m_test(test), m_events(0), m_external_events(0)\n    {\n    }\n\n    ~mmap_event()\n    {\n        unset();\n        unset_external();\n    }\n\n    ucs_status_t set(int events)\n    {\n        ucs_status_t status;\n\n        status = ucm_set_event_handler(events, 0, mem_event_callback,\n                                       reinterpret_cast<void*>(m_test));\n        ASSERT_UCS_OK(status);\n        m_events |= events;\n        return status;\n    }\n\n    ucs_status_t set_external(int events)\n    {\n        ucm_set_external_event(events);\n        m_external_events |= events;\n        return UCS_OK;\n    }\n\n    void unset()\n    {\n        if (m_events) {\n            ucm_unset_event_handler(m_events, mem_event_callback,\n                                    reinterpret_cast<void*>(m_test));\n            m_events = 0;\n        }\n    }\n\n    void unset_external()\n    {\n        if (m_external_events) {\n            ucm_unset_external_event(m_external_events);\n            m_external_events = 0;\n        }\n    }\n\nprotected:\n    T   *m_test;\n    int m_events;\n    int m_external_events;\n\n    static void mem_event_callback(ucm_event_type_t event_type,\n                                   ucm_event_t *event,\n                                   void *arg)\n    {\n        T *test = reinterpret_cast<T*>(arg);\n        test->mem_event(event_type, event);\n    }\n};\n\n\nclass malloc_hook : public ucs::test {\n    friend class mmap_event<malloc_hook>;\nprotected:\n    /* use template argument to call/not call vm_unmap handler */\n    /* GCC 4.4.7 doesn't allow to define template static function\n     * with integer template argument. using template inner class\n     * to define static function */\n    template <int C> class bistro_hook {\n    public:\n        static int munmap(void *addr, size_t length)\n        {\n            UCM_BISTRO_PROLOGUE;\n            malloc_hook::bistro_call_counter++;\n            if (C) {\n                /* notify aggregate vm_munmap event only */\n                ucm_vm_munmap(addr, length);\n            }\n            int res = (intptr_t)syscall(SYS_munmap, addr, length);\n            UCM_BISTRO_EPILOGUE;\n            return res;\n        }\n\n        static int madvise(void *addr, size_t length, int advise)\n        {\n            UCM_BISTRO_PROLOGUE;\n            malloc_hook::bistro_call_counter++;\n            if (C) {\n                /* notify aggregate vm_munmap event only */\n                ucm_vm_munmap(addr, length);\n            }\n            int res = (intptr_t)syscall(SYS_madvise, addr, length, advise);\n            UCM_BISTRO_EPILOGUE;\n            return res;\n        }\n    };\n\n    class bistro_patch {\n    public:\n        bistro_patch(const char* symbol, void *hook)\n        {\n            ucs_status_t status;\n\n            status = ucm_bistro_patch(symbol, hook, &m_rp);\n            ASSERT_UCS_OK(status);\n            EXPECT_NE((intptr_t)m_rp, 0);\n        }\n\n        ~bistro_patch()\n        {\n            ucm_bistro_restore(m_rp);\n        }\n\n    protected:\n        ucm_bistro_restore_point_t *m_rp;\n    };\n\n    void mem_event(ucm_event_type_t event_type, ucm_event_t *event)\n    {\n        m_got_event = 1;\n    }\n\n    virtual void init() {\n        ucs_status_t status;\n        mmap_event<malloc_hook> event(this);\n\n        ucs::skip_on_address_sanitizer();\n\n        m_got_event = 0;\n        ucm_malloc_state_reset(128 * 1024, 128 * 1024);\n        malloc_trim(0);\n        status = event.set(UCM_EVENT_VM_MAPPED);\n        ASSERT_UCS_OK(status);\n\n        for (;;) {\n            void *ptr = malloc(small_alloc_size);\n            if (m_got_event) {\n                /* If the heap grew, the minimal size is the previous one */\n                free(ptr);\n                break;\n            } else {\n                m_pts.push_back(ptr);\n            }\n        }\n        event.unset();\n    }\n\npublic:\n    static int            small_alloc_count;\n    static const size_t   small_alloc_size = 10000;\n    ucs::ptr_vector<void> m_pts;\n    int                   m_got_event;\n    static volatile int   bistro_call_counter;\n};\n\nstatic bool skip_on_bistro() {\n    return (ucm_global_opts.mmap_hook_mode == UCM_MMAP_HOOK_BISTRO);\n}\n\nstatic bool skip_on_bistro_without_valgrind() {\n    /* BISTRO is disabled under valgrind, we may run tests */\n    return (skip_on_bistro() && !RUNNING_ON_VALGRIND);\n}\n\nint malloc_hook::small_alloc_count            = 1000 / ucs::test_time_multiplier();\nvolatile int malloc_hook::bistro_call_counter = 0;\n\nclass test_thread {\npublic:\n    test_thread(const std::string& name, int num_threads, pthread_barrier_t *barrier,\n                malloc_hook *test, void (test_thread::*test_func)() = &test_thread::test) :\n        m_name(name), m_num_threads(num_threads), m_barrier(barrier),\n        m_map_size(0), m_unmap_size(0), m_test(test), m_event(this)\n    {\n        pthread_mutex_init(&m_stats_lock, NULL);\n    }\n\n    ~test_thread() {\n        pthread_mutex_destroy(&m_stats_lock);\n    }\n\n    void test();\n    void mem_event(ucm_event_type_t event_type, ucm_event_t *event);\n\nprivate:\n    typedef std::pair<void*, void*> range;\n\n    bool is_ptr_in_range(void *ptr, size_t size, const std::vector<range> &ranges) {\n        for (std::vector<range>::const_iterator iter = ranges.begin(); iter != ranges.end(); ++iter) {\n            if ((ptr >= iter->first) && ((char*)ptr < iter->second)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    static pthread_mutex_t   lock;\n    static pthread_barrier_t barrier;\n\n    std::string        m_name;\n    int                m_num_threads;\n    pthread_barrier_t  *m_barrier;\n\n    pthread_mutex_t    m_stats_lock;\n    size_t             m_map_size;\n    size_t             m_unmap_size;\n    std::vector<range> m_map_ranges;\n    std::vector<range> m_unmap_ranges;\n\n    malloc_hook        *m_test;\n    mmap_event<test_thread> m_event;\n};\n\npthread_mutex_t test_thread::lock = PTHREAD_MUTEX_INITIALIZER;\n\nvoid test_thread::mem_event(ucm_event_type_t event_type, ucm_event_t *event)\n{\n    pthread_mutex_lock(&m_stats_lock);\n    switch (event_type) {\n    case UCM_EVENT_VM_MAPPED:\n        m_map_ranges.push_back(range(event->vm_mapped.address,\n                                     (char*)event->vm_mapped.address + event->vm_mapped.size));\n        m_map_size += event->vm_mapped.size;\n        break;\n    case UCM_EVENT_VM_UNMAPPED:\n        m_unmap_ranges.push_back(range(event->vm_unmapped.address,\n                                       (char*)event->vm_unmapped.address + event->vm_unmapped.size));\n        m_unmap_size += event->vm_unmapped.size;\n        break;\n    default:\n        break;\n    }\n    pthread_mutex_unlock(&m_stats_lock);\n}\n\nvoid test_thread::test() {\n    static const size_t large_alloc_size = 40 * 1024 * 1024;\n    ucs_status_t result;\n    ucs::ptr_vector<void> old_ptrs;\n    ucs::ptr_vector<void> new_ptrs;\n    void *ptr_r;\n    size_t small_map_size;\n    const size_t small_alloc_size = malloc_hook::small_alloc_size;\n    int num_ptrs_in_range;\n    static volatile uint32_t total_ptrs_in_range = 0;\n    char *test_str;\n\n    /* Allocate some pointers with old heap manager */\n    for (unsigned i = 0; i < 10; ++i) {\n        old_ptrs.push_back(malloc(small_alloc_size));\n    }\n\n    ptr_r = malloc(small_alloc_size);\n\n    m_map_ranges.reserve  ((m_test->small_alloc_count * 8 + 10) * m_num_threads);\n    m_unmap_ranges.reserve((m_test->small_alloc_count * 8 + 10) * m_num_threads);\n\n    total_ptrs_in_range = 0;\n\n    pthread_barrier_wait(m_barrier);\n\n    /* Install memory hooks */\n    result = m_event.set(UCM_EVENT_VM_MAPPED|UCM_EVENT_VM_UNMAPPED);\n    ASSERT_UCS_OK(result);\n\n    /* Allocate small pointers with new heap manager */\n    for (int i = 0; i < m_test->small_alloc_count; ++i) {\n        new_ptrs.push_back(malloc(small_alloc_size));\n    }\n    small_map_size = m_map_size;\n\n    /* If this test runs more than once, then sbrk may not really allocate new\n     * memory\n     */\n    EXPECT_GT(m_map_size, 0lu) << m_name;\n\n    num_ptrs_in_range = 0;\n    for (ucs::ptr_vector<void>::const_iterator iter = new_ptrs.begin();\n                    iter != new_ptrs.end(); ++iter)\n    {\n        if (is_ptr_in_range(*iter, small_alloc_size, m_map_ranges)) {\n            ++num_ptrs_in_range;\n        }\n    }\n\n    /* Need at least one ptr in the mapped ranges in one the threads */\n    ucs_atomic_add32(&total_ptrs_in_range, num_ptrs_in_range);\n    pthread_barrier_wait(m_barrier);\n\n    EXPECT_GT(total_ptrs_in_range, 0u);\n\n    /* Allocate large chunk */\n    void *ptr = malloc(large_alloc_size);\n    EXPECT_GE(m_map_size, large_alloc_size + small_map_size) << m_name;\n    EXPECT_TRUE(is_ptr_in_range(ptr, large_alloc_size, m_map_ranges)) << m_name;\n    EXPECT_GE(malloc_usable_size(ptr), large_alloc_size);\n\n    free(ptr);\n    EXPECT_GE(m_unmap_size, large_alloc_size) << m_name;\n    /* coverity[pass_freed_arg] */\n    EXPECT_TRUE(is_ptr_in_range(ptr, large_alloc_size, m_unmap_ranges)) << m_name;\n\n    /* Test strdup */\n    void *s = strdup(\"test\");\n    free(s);\n\n    /* Test setenv */\n    pthread_mutex_lock(&lock);\n    setenv(\"TEST\", \"VALUE\", 1);\n    test_str = getenv(\"TEST\");\n    if (test_str != NULL) {\n        EXPECT_EQ(std::string(\"VALUE\"), test_str);\n    } else {\n        UCS_TEST_ABORT(\"getenv(\\\"TEST\\\") returned NULL\");\n    }\n    pthread_mutex_unlock(&lock);\n\n    /* Test username */\n    ucs_get_user_name();\n\n    /* Test usable size */\n    EXPECT_GE(malloc_usable_size(ptr_r), small_alloc_size);\n\n    /* Test realloc */\n    ptr_r = realloc(ptr_r, small_alloc_size / 2);\n    free(ptr_r);\n\n    /* Test C++ allocations */\n    {\n        std::vector<char> vec(large_alloc_size, 0);\n        ptr = &vec[0];\n        EXPECT_TRUE(is_ptr_in_range(ptr, large_alloc_size, m_map_ranges)) << m_name;\n    }\n\n    /* coverity[use_after_free] - we don't dereference ptr, just search it*/\n    EXPECT_TRUE(is_ptr_in_range(ptr, large_alloc_size, m_unmap_ranges)) << m_name;\n\n    /* Release old pointers (should not crash) */\n    old_ptrs.clear();\n\n    m_map_ranges.clear();\n    m_unmap_ranges.clear();\n\n    /* Don't release pointers before other threads exit, so they will map new memory\n     * and not reuse memory from other threads.\n     */\n    pthread_barrier_wait(m_barrier);\n\n    /* This must be done when all other threads are inactive, otherwise we may leak */\n#if HAVE_MALLOC_STATES\n    if (!RUNNING_ON_VALGRIND) {\n        pthread_mutex_lock(&lock);\n        void *state = malloc_get_state();\n        malloc_set_state(state);\n        free(state);\n        pthread_mutex_unlock(&lock);\n    }\n#endif /* HAVE_MALLOC_STATES */\n\n    pthread_barrier_wait(m_barrier);\n\n    /* Release new pointers  */\n    new_ptrs.clear();\n\n    /* Call several malloc routines */\n    malloc_trim(0);\n\n    ptr = malloc(large_alloc_size);\n\n    free(ptr);\n\n    /* shmat/shmdt */\n    size_t shm_seg_size = ucs_get_page_size() * 2;\n    int shmid = shmget(IPC_PRIVATE, shm_seg_size, IPC_CREAT | SHM_R | SHM_W);\n    EXPECT_NE(-1, shmid) << strerror(errno);\n\n    ptr = shmat(shmid, NULL, 0);\n    EXPECT_NE(MAP_FAILED, ptr) << strerror(errno);\n\n    shmdt(ptr);\n    shmctl(shmid, IPC_RMID, NULL);\n\n    EXPECT_TRUE(is_ptr_in_range(ptr, shm_seg_size, m_unmap_ranges));\n\n    ptr = mmap(NULL, shm_seg_size, PROT_READ|PROT_WRITE,\n               MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n    ASSERT_NE(MAP_FAILED, ptr) << strerror(errno);\n    madvise(ptr, shm_seg_size, MADV_DONTNEED);\n\n    EXPECT_TRUE(is_ptr_in_range(ptr, shm_seg_size, m_unmap_ranges));\n    munmap(ptr, shm_seg_size);\n\n    /* Print results */\n    pthread_mutex_lock(&lock);\n    UCS_TEST_MESSAGE << m_name\n                     << \": small mapped: \" << small_map_size\n                     <<  \", total mapped: \" << m_map_size\n                     <<  \", total unmapped: \" << m_unmap_size;\n    std::cout.flush();\n    pthread_mutex_unlock(&lock);\n\n    m_event.unset();\n}\n\nUCS_TEST_SKIP_COND_F(malloc_hook, single_thread,\n                     skip_on_bistro_without_valgrind()) {\n    pthread_barrier_t barrier;\n    pthread_barrier_init(&barrier, NULL, 1);\n    {\n        mhook_thread<test_thread>(new test_thread(\"single-thread\", 1, &barrier, this));\n    }\n    pthread_barrier_destroy(&barrier);\n}\n\nUCS_TEST_SKIP_COND_F(malloc_hook, multi_threads,\n                     skip_on_bistro_without_valgrind()) {\n    typedef mhook_thread<test_thread> thread_t;\n\n    static const int num_threads = 8;\n    ucs::ptr_vector<thread_t> threads;\n    pthread_barrier_t barrier;\n\n    malloc_trim(0);\n\n    pthread_barrier_init(&barrier, NULL, num_threads);\n    for (int i = 0; i < num_threads; ++i) {\n        std::stringstream ss;\n        ss << \"thread \" << i << \"/\" << num_threads;\n        threads.push_back(new thread_t(new test_thread(ss.str(), num_threads, &barrier, this)));\n    }\n\n    threads.clear();\n    pthread_barrier_destroy(&barrier);\n}\n\nUCS_TEST_F(malloc_hook, asprintf) {\n    /* Install memory hooks */\n    (void)dlerror();\n}\n\nUCS_TEST_SKIP_COND_F(malloc_hook, fork, \"broken\") {\n    static const int num_processes = 4;\n    pthread_barrier_t barrier;\n    std::vector<pid_t> pids;\n    pid_t pid;\n\n    for (int i = 0; i < num_processes; ++i) {\n        pid = fork();\n        if (pid == 0) {\n            pthread_barrier_init(&barrier, NULL, 1);\n            {\n                std::stringstream ss;\n                ss << \"process \" << i << \"/\" << num_processes;\n                test_thread thread(ss.str(), 1, &barrier, this);\n            }\n            pthread_barrier_destroy(&barrier);\n            throw ucs::exit_exception(HasFailure());\n        }\n        pids.push_back(pid);\n    }\n\n    for (int i = 0; i < num_processes; ++i) {\n        int status;\n        waitpid(pids[i], &status, 0);\n        EXPECT_EQ(0, WEXITSTATUS(status)) << \"Process \" << i << \" failed\";\n    }\n}\n\nclass malloc_hook_cplusplus : public malloc_hook {\npublic:\n\n    malloc_hook_cplusplus() :\n        m_mapped_size(0), m_unmapped_size(0),\n        m_dynamic_mmap_config(ucm_global_opts.enable_dynamic_mmap_thresh),\n        m_event(this) {\n    }\n\n    ~malloc_hook_cplusplus() {\n        ucm_global_opts.enable_dynamic_mmap_thresh = m_dynamic_mmap_config;\n    }\n\n    void set() {\n        ucs_status_t status;\n        status = m_event.set(UCM_EVENT_VM_MAPPED|UCM_EVENT_VM_UNMAPPED);\n        ASSERT_UCS_OK(status);\n    }\n\n    void unset() {\n        m_event.unset();\n    }\n\n    void mem_event(ucm_event_type_t event_type, ucm_event_t *event)\n    {\n        switch (event_type) {\n        case UCM_EVENT_VM_MAPPED:\n            m_mapped_size   += event->vm_mapped.size;\n            break;\n        case UCM_EVENT_VM_UNMAPPED:\n            m_unmapped_size += event->vm_unmapped.size;\n            break;\n        default:\n            break;\n        }\n    }\n\nprotected:\n    double measure_alloc_time(size_t size, unsigned iters)\n    {\n        ucs_time_t start_time = ucs_get_time();\n        for (unsigned i = 0; i < iters; ++i) {\n            void *ptr = malloc(size);\n            /* prevent the compiler from optimizing-out the memory allocation */\n            *(volatile char*)ptr = '5';\n            free(ptr);\n        }\n        return ucs_time_to_sec(ucs_get_time() - start_time);\n    }\n\n    void test_dynamic_mmap_thresh()\n    {\n        const size_t size = 8 * UCS_MBYTE;\n\n        set();\n\n        std::vector<std::string> strs;\n\n        m_mapped_size = 0;\n        while (m_mapped_size < size) {\n            strs.push_back(std::string(size, 't'));\n        }\n\n        m_unmapped_size = 0;\n        strs.clear();\n        EXPECT_GE(m_unmapped_size, size);\n\n        m_mapped_size = 0;\n        while (m_mapped_size < size) {\n            strs.push_back(std::string());\n            strs.back().resize(size);\n        }\n\n        m_unmapped_size = 0;\n        strs.clear();\n        if (ucm_global_opts.enable_dynamic_mmap_thresh) {\n            EXPECT_EQ(0ul, m_unmapped_size);\n        } else {\n            EXPECT_GE(m_unmapped_size, size);\n        }\n\n        unset();\n    }\n\n    size_t m_mapped_size;\n    size_t m_unmapped_size;\n    int    m_dynamic_mmap_config;\n    mmap_event<malloc_hook_cplusplus> m_event;\n};\n\n\nclass mmap_hooks {\npublic:\n    mmap_hooks(const std::string& name, int num_threads, pthread_barrier_t *barrier):\n        m_num_threads(num_threads), m_mapped_size(0), m_unmapped_size(0),\n        m_search_ptr(NULL), m_is_ptr_found(false), m_name(name),\n        m_barrier(barrier), m_event(this)\n    {\n        pthread_spin_init(&m_lock,0);\n    }\n\n    void mem_event(ucm_event_type_t event_type, ucm_event_t *event)\n    {\n        pthread_spin_lock(&m_lock);\n        switch (event_type) {\n        case UCM_EVENT_VM_MAPPED:\n            m_mapped_size += event->vm_mapped.size;\n            break;\n        case UCM_EVENT_VM_UNMAPPED:\n            m_unmapped_size += event->vm_unmapped.size;\n            if (m_search_ptr == event->vm_unmapped.address) {\n                m_is_ptr_found = true;\n            }\n            break;\n        default:\n            break;\n        }\n        pthread_spin_unlock(&m_lock);\n    }\n\n    void test()\n    {\n        /*\n         * Test memory mapping functions which override an existing mapping\n         */\n        size_t size          = ucs_get_page_size() * 800;\n        size_t mapped_size   = 0;\n        size_t unmapped_size = 0;\n        void *buffer;\n        int shmid;\n        ucs_status_t status;\n        int num_threads;\n\n        EXPECT_EQ(0u, m_mapped_size) << m_name;\n        EXPECT_EQ(0u, m_unmapped_size) << m_name;\n\n        status = m_event.set(UCM_EVENT_VM_MAPPED|UCM_EVENT_VM_UNMAPPED);\n        ASSERT_UCS_OK(status);\n\n        pthread_barrier_wait(m_barrier);\n\n        /* 1. Map a large buffer */\n        {\n            buffer = mmap(NULL, size, PROT_READ|PROT_WRITE,\n                                MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n            ASSERT_NE(MAP_FAILED, buffer) << strerror(errno);\n\n            EXPECT_INCREASED(m_mapped_size, mapped_size, size, m_name);\n            EXPECT_INCREASED(m_unmapped_size, unmapped_size, 0, m_name);\n        }\n\n        /*\n         * 2. Map another buffer in the same place.\n         *    Expected behavior: unmap event on the old buffer\n         */\n        {\n            void *remap = mmap(buffer, size, PROT_READ|PROT_WRITE,\n                               MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED, -1, 0);\n            ASSERT_EQ(buffer, remap);\n\n            EXPECT_INCREASED(m_mapped_size, mapped_size, size, m_name);\n            EXPECT_INCREASED(m_unmapped_size, unmapped_size, size, m_name);\n        }\n\n        /* 3. Create a shared memory segment */\n        {\n            shmid = shmget(IPC_PRIVATE, size, IPC_CREAT | SHM_R | SHM_W);\n            ASSERT_NE(-1, shmid) << strerror(errno) << m_name;\n        }\n\n        /*\n         * 4. Attach the segment at the same buffer address.\n         *    Expected behavior: unmap event on the old buffer\n         */\n        {\n            m_is_ptr_found = false;\n            m_search_ptr   = buffer;\n\n            /* Make sure every thread will have a unique value of 'buffer' - no\n             * thread will release its buffer before all others already\n             * allocated theirs */\n            pthread_barrier_wait(m_barrier);\n\n            /* adding 0x1 to 'buffer' with SHM_RND flag should still send event\n             * for 'buffer', because it aligns to SHMLBA\n             */\n            void *shmaddr = shmat(shmid, (char*)buffer + 0x1, SHM_REMAP | SHM_RND);\n            ASSERT_EQ(buffer, shmaddr) << m_name;\n\n            if (SHMLBA > 0x1) {\n                EXPECT_TRUE(m_is_ptr_found);\n            }\n            EXPECT_INCREASED(m_mapped_size, mapped_size, size, m_name);\n            EXPECT_INCREASED(m_unmapped_size, unmapped_size, size, m_name);\n        }\n\n        /* 5. Detach the sysv segment */\n        {\n            shmdt(buffer);\n\n            EXPECT_INCREASED(m_unmapped_size, unmapped_size, size, m_name);\n        }\n\n        /* 6. Remove the shared memory segment */\n        {\n            int ret = shmctl(shmid, IPC_RMID, NULL);\n            ASSERT_NE(-1, ret) << strerror(errno);\n        }\n\n        /* 7. Unmap the buffer */\n        {\n            munmap(buffer, size);\n\n            EXPECT_INCREASED(m_unmapped_size, unmapped_size, size, m_name);\n        }\n\n        /* 8. sbrk call - single thread only */\n        if (!RUNNING_ON_VALGRIND && (m_num_threads < 2)) {\n            num_threads = 0;\n            ucs_sys_enum_threads(enum_threads_cb, &num_threads);\n            // use sbrk() only if there are 3 threads in the system:\n            //   1. main thread\n            //   2. watchdog thread\n            //   3. test thread\n            // otherwise, another thread can call use malloc/free in same time,\n            // leading to heap corruption\n\n            if (num_threads <= 3) {\n                /* valgrind failed when sbrk is called directly,\n                 * also sbrk is not thread safe */\n\n                /* sbrk call is used to extend/cut memory heap,\n                 * don't add any evaluations between calls sbrk+/sbrk- - it\n                 * may break heap */\n                sbrk(size);\n                sbrk(-size);\n\n                EXPECT_INCREASED(m_mapped_size, mapped_size, size, m_name);\n                EXPECT_INCREASED(m_unmapped_size, unmapped_size, size, m_name);\n            }\n        }\n        pthread_barrier_wait(m_barrier);\n    }\n\nprotected:\n    int                     m_num_threads;\n    size_t                  m_mapped_size;\n    size_t                  m_unmapped_size;\n    void                    *m_search_ptr;\n    bool                    m_is_ptr_found;\n    pthread_spinlock_t      m_lock;\n    std::string             m_name;\n    pthread_barrier_t       *m_barrier;\n    mmap_event<mmap_hooks>  m_event;\n\n    static ucs_status_t enum_threads_cb(pid_t tid, void *ctx)\n    {\n        (*(int*)ctx)++;\n        return UCS_OK;\n    }\n};\n\n\nUCS_TEST_F(malloc_hook_cplusplus, new_delete) {\n    const size_t size = 8 * 1000 * 1000;\n\n    set();\n\n    {\n        std::vector<char> vec1(size, 0);\n        std::vector<char> vec2(size, 0);\n        std::vector<char> vec3(size, 0);\n    }\n\n    {\n        std::vector<char> vec1(size, 0);\n        std::vector<char> vec2(size, 0);\n        std::vector<char> vec3(size, 0);\n    }\n\n    malloc_trim(0);\n\n    EXPECT_GE(m_unmapped_size, size);\n\n    unset();\n}\n\nUCS_TEST_SKIP_COND_F(malloc_hook_cplusplus, dynamic_mmap_enable,\n                     RUNNING_ON_VALGRIND || skip_on_bistro()) {\n    EXPECT_TRUE(ucm_global_opts.enable_dynamic_mmap_thresh);\n    test_dynamic_mmap_thresh();\n}\n\nUCS_TEST_SKIP_COND_F(malloc_hook_cplusplus, dynamic_mmap_disable,\n                     skip_on_bistro_without_valgrind()) {\n    ucm_global_opts.enable_dynamic_mmap_thresh = 0;\n\n    test_dynamic_mmap_thresh();\n}\n\nextern \"C\" {\n    int ucm_dlmallopt_get(int);\n};\n\nUCS_TEST_SKIP_COND_F(malloc_hook_cplusplus, mallopt,\n                     skip_on_bistro_without_valgrind()) {\n\n    int v;\n    int trim_thresh, mmap_thresh;\n    char *p;\n    size_t size;\n\n    /* This test can not be run with the other\n     * tests because it assumes that malloc hooks\n     * are not initialized\n     */\n    p = getenv(\"MALLOC_TRIM_THRESHOLD_\");\n    if (p == NULL) {\n        UCS_TEST_SKIP_R(\"MALLOC_TRIM_THRESHOLD_ is not set\");\n    }\n    trim_thresh = atoi(p);\n\n    p = getenv(\"MALLOC_MMAP_THRESHOLD_\");\n    if (p == NULL) {\n        UCS_TEST_SKIP_R(\"MALLOC_MMAP_THRESHOLD_ is not set\");\n    }\n    mmap_thresh = atoi(p);\n\n    /* make sure that rcache is explicitly disabled so\n     * that the malloc hooks are installed after the setenv()\n     */\n    p = getenv(\"UCX_IB_RCACHE\");\n    if ((p == NULL) || (p[0] != 'n')) {\n        UCS_TEST_SKIP_R(\"rcache must be disabled\");\n    }\n\n    set();\n\n    v = ucm_dlmallopt_get(M_TRIM_THRESHOLD);\n    EXPECT_EQ(trim_thresh, v);\n\n    v = ucm_dlmallopt_get(M_MMAP_THRESHOLD);\n    EXPECT_EQ(mmap_thresh, v);\n\n    /* give a lot of extra space since the same block\n     * can be also used by other allocations\n     */\n    if (trim_thresh > 0) {\n        size = trim_thresh/2;\n    } else if (mmap_thresh > 0) {\n        size = mmap_thresh/2;\n    } else {\n        size = 10 * 1024 * 1024;\n    }\n\n    UCS_TEST_MESSAGE << \"trim_thresh=\" << trim_thresh << \" mmap_thresh=\" << mmap_thresh <<\n                        \" allocating=\" << size;\n    p = new char [size];\n    ASSERT_TRUE(p != NULL);\n    delete [] p;\n\n    EXPECT_EQ(m_unmapped_size, size_t(0));\n\n    unset();\n}\n\nUCS_TEST_SKIP_COND_F(malloc_hook_cplusplus, mmap_ptrs, RUNNING_ON_VALGRIND) {\n    ucm_global_opts.enable_dynamic_mmap_thresh = 0;\n    set();\n\n    const size_t   size    = ucm_dlmallopt_get(M_MMAP_THRESHOLD) * 2;\n    const size_t   max_mem = ucs_min(ucs_get_phys_mem_size() / 4, 4 * UCS_GBYTE);\n    const unsigned count   = ucs_min(400000ul, max_mem / size);\n    const unsigned iters   = 100000;\n\n    std::vector< std::vector<char> > ptrs;\n\n    size_t large_blocks = 0;\n\n    /* Allocate until we get MMAP event\n     * Lock memory to avoid going to swap and ensure consistet test results.\n     */\n    while (m_mapped_size == 0) {\n        std::vector<char> str(size, 'r');\n        ptrs.push_back(str);\n        ++large_blocks;\n    }\n\n    /* Remove memory off the heap top, to ensure the following large allocations\n     * will use mmap()\n     */\n    malloc_trim(0);\n\n    /* Measure allocation time with \"clear\" heap state */\n    double alloc_time = measure_alloc_time(size, iters);\n    UCS_TEST_MESSAGE << \"With \" << large_blocks << \" large blocks:\"\n                     << \" allocated \" << iters << \" buffers of \" << size\n                     << \" bytes in \" << alloc_time << \" sec\";\n\n    /* Allocate many large strings to trigger mmap() based allocation. */\n    ptrs.resize(count);\n    for (unsigned i = 0; i < count; ++i) {\n        ptrs[i].resize(size, 't');\n        ++large_blocks;\n    }\n\n    /* Measure allocation time with many large blocks on the heap */\n    bool success = false;\n    unsigned attempt = 0;\n    while (!success && (attempt < 5)) {\n        double alloc_time_with_ptrs = measure_alloc_time(size, iters);\n        UCS_TEST_MESSAGE << \"With \" << large_blocks << \" large blocks:\"\n                         << \" allocated \" << iters << \" buffers of \" << size\n                         << \" bytes in \" << alloc_time_with_ptrs << \" sec\";\n\n        /* Allow up to 75% difference */\n        success = (alloc_time < 0.25) || (alloc_time_with_ptrs < (1.75 * alloc_time));\n        ++attempt;\n    }\n\n    if (!success) {\n        ADD_FAILURE() << \"Failed after \" << attempt << \" attempts\";\n    }\n\n    ptrs.clear();\n\n    unset();\n\n}\n\nUCS_TEST_F(malloc_hook_cplusplus, remap_override_single_thread) {\n    pthread_barrier_t barrier;\n    pthread_barrier_init(&barrier, NULL, 1);\n    {\n        mhook_thread<mmap_hooks>(new mmap_hooks(\"single-thread\", 1, &barrier));\n    }\n    pthread_barrier_destroy(&barrier);\n}\n\nUCS_TEST_F(malloc_hook_cplusplus, remap_override_multi_threads) {\n    typedef mhook_thread<mmap_hooks> thread_t;\n\n    static const int num_threads = 8;\n    ucs::ptr_vector<thread_t> threads;\n    pthread_barrier_t barrier;\n\n    pthread_barrier_init(&barrier, NULL, num_threads);\n    for (int i = 0; i < num_threads; ++i) {\n        std::stringstream ss;\n        ss << \"thread \" << i << \"/\" << num_threads;\n        threads.push_back(new thread_t(new mmap_hooks(ss.str(), num_threads, &barrier)));\n    }\n\n    threads.clear();\n    pthread_barrier_destroy(&barrier);\n}\n\ntypedef int (munmap_f_t)(void *addr, size_t len);\n\nUCS_TEST_SKIP_COND_F(malloc_hook, bistro_patch, RUNNING_ON_VALGRIND) {\n    const char *symbol = \"munmap\";\n    ucm_bistro_restore_point_t *rp = NULL;\n    ucs_status_t status;\n    munmap_f_t *munmap_f;\n    void *ptr;\n    int res;\n    uint64_t UCS_V_UNUSED patched;\n    uint64_t UCS_V_UNUSED origin;\n\n    /* set hook to mmap call */\n    status = ucm_bistro_patch(symbol, (void*)bistro_hook<0>::munmap, &rp);\n    ASSERT_UCS_OK(status);\n    EXPECT_NE((intptr_t)rp, 0);\n\n    munmap_f = (munmap_f_t*)ucm_bistro_restore_addr(rp);\n    EXPECT_NE((intptr_t)munmap_f, 0);\n\n    /* save partial body of patched function */\n    patched = *(uint64_t*)munmap_f;\n\n    bistro_call_counter = 0;\n    ptr = mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, 0, 0);\n    EXPECT_NE(ptr, MAP_FAILED);\n\n    /* try to call munmap, we should jump into munmap_hook instead */\n    res = munmap_f(ptr, 4096);\n    EXPECT_EQ(res, 0);\n    /* due to cache coherency issues on ARM systems could be executed\n     * original function body, so, skip counter evaluation */\n    EXPECT_GT(bistro_call_counter, 0);\n\n    /* restore original mmap body */\n    status = ucm_bistro_restore(rp);\n    ASSERT_UCS_OK(status);\n\n    bistro_call_counter = 0;\n    /* now try to call mmap, we should NOT jump into mmap_hook */\n    ptr = mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, 0, 0);\n    EXPECT_NE(ptr, MAP_FAILED);\n    res = munmap_f(ptr, 4096);\n    EXPECT_EQ(res, 0);\n    EXPECT_EQ(bistro_call_counter, 0);  /* hook is not called */\n    /* save partial body of restored function */\n    origin = *(uint64_t*)munmap_f;\n\n#if !defined (__powerpc64__)\n    EXPECT_NE(patched, origin);\n#endif\n}\n\nUCS_TEST_SKIP_COND_F(malloc_hook, test_event, RUNNING_ON_VALGRIND) {\n    mmap_event<malloc_hook> event(this);\n    ucs_status_t status;\n\n    status = event.set(UCM_EVENT_VM_MAPPED | UCM_EVENT_VM_UNMAPPED);\n    ASSERT_UCS_OK(status);\n\n    status = ucm_test_events(UCM_EVENT_VM_MAPPED | UCM_EVENT_VM_UNMAPPED);\n    ASSERT_UCS_OK(status);\n}\n\nUCS_TEST_SKIP_COND_F(malloc_hook, test_event_failed,\n                     RUNNING_ON_VALGRIND || !skip_on_bistro()) {\n    mmap_event<malloc_hook> event(this);\n    ucs_status_t status;\n    const char *symbol_munmap  = \"munmap\";\n    const char *symbol_madvise = \"madvise\";\n\n    status = event.set(UCM_EVENT_MUNMAP | UCM_EVENT_VM_UNMAPPED);\n    ASSERT_UCS_OK(status);\n\n    /* set hook to munmap call */\n    {\n        bistro_patch patch(symbol_munmap, (void*)bistro_hook<0>::munmap);\n        EXPECT_TRUE(ucm_test_events(UCM_EVENT_MUNMAP)      == UCS_ERR_UNSUPPORTED);\n        EXPECT_TRUE(ucm_test_events(UCM_EVENT_VM_UNMAPPED) == UCS_ERR_UNSUPPORTED);\n        EXPECT_TRUE(ucm_test_events(UCM_EVENT_MUNMAP | UCM_EVENT_VM_UNMAPPED) ==\n                    UCS_ERR_UNSUPPORTED);\n    }\n    /* set hook to madvise call */\n    {\n        bistro_patch patch(symbol_madvise, (void*)bistro_hook<0>::madvise);\n        EXPECT_TRUE(ucm_test_events(UCM_EVENT_MADVISE)     == UCS_ERR_UNSUPPORTED);\n        EXPECT_TRUE(ucm_test_events(UCM_EVENT_VM_UNMAPPED) == UCS_ERR_UNSUPPORTED);\n    }\n}\n\nUCS_TEST_SKIP_COND_F(malloc_hook, test_external_event,\n                     RUNNING_ON_VALGRIND || !skip_on_bistro()) {\n    mmap_event<malloc_hook> event(this);\n    ucs_status_t status;\n    const char *symbol_munmap  = \"munmap\";\n    const char *symbol_madvise = \"madvise\";\n\n    status = event.set_external(UCM_EVENT_VM_UNMAPPED);\n    ASSERT_UCS_OK(status);\n\n    /* set hook to munmap call */\n    {\n        bistro_patch patch(symbol_munmap, (void*)bistro_hook<0>::munmap);\n        /* OK due to UCM_EVENT_MUNMAP is not external */\n        EXPECT_TRUE(ucm_test_external_events(UCM_EVENT_MUNMAP)      == UCS_OK);\n        /* should fail */\n        EXPECT_TRUE(ucm_test_external_events(UCM_EVENT_VM_UNMAPPED) == UCS_ERR_UNSUPPORTED);\n        /* should fail */\n        EXPECT_TRUE(ucm_test_external_events(UCM_EVENT_MUNMAP | UCM_EVENT_VM_UNMAPPED) ==\n                    UCS_ERR_UNSUPPORTED);\n    }\n    /* set hook to madvise call */\n    {\n        bistro_patch patch(symbol_madvise, (void*)bistro_hook<0>::madvise);\n        /* OK due to UCM_EVENT_MADVISE is not external */\n        EXPECT_TRUE(ucm_test_external_events(UCM_EVENT_MADVISE)     == UCS_OK);\n        EXPECT_TRUE(ucm_test_external_events(UCM_EVENT_VM_UNMAPPED) == UCS_ERR_UNSUPPORTED);\n    }\n    /* set hook to munmap/madvise call which notify vm_unmap */\n    {\n        bistro_patch patch_unmap(symbol_munmap, (void*)bistro_hook<1>::munmap);\n        bistro_patch patch_advise(symbol_madvise, (void*)bistro_hook<1>::madvise);\n        /* OK due to UCM_EVENT_MUNMAP is not external */\n        EXPECT_TRUE(ucm_test_external_events(UCM_EVENT_MUNMAP)      == UCS_OK);\n        /* OK due to UCM_EVENT_MADVISE is not external */\n        EXPECT_TRUE(ucm_test_external_events(UCM_EVENT_MADVISE)     == UCS_OK);\n        /* should be OK */\n        EXPECT_TRUE(ucm_test_external_events(UCM_EVENT_VM_UNMAPPED) == UCS_OK);\n        EXPECT_TRUE(ucm_test_external_events(UCM_EVENT_MUNMAP | UCM_EVENT_VM_UNMAPPED) ==\n                    UCS_OK);\n    }\n    /* set hook to munmap & madvise call, but madvise does NOT notify vm_unmap */\n    {\n        bistro_patch patch_unmap(symbol_munmap, (void*)bistro_hook<1>::munmap);\n        bistro_patch patch_advise(symbol_madvise, (void*)bistro_hook<0>::madvise);\n        /* OK due to UCM_EVENT_MUNMAP is not external */\n        EXPECT_TRUE(ucm_test_external_events(UCM_EVENT_MUNMAP)      == UCS_OK);\n        /* OK due to UCM_EVENT_MADVISE is not external */\n        EXPECT_TRUE(ucm_test_external_events(UCM_EVENT_MADVISE)     == UCS_OK);\n        /* should fail */\n        EXPECT_TRUE(ucm_test_external_events(UCM_EVENT_VM_UNMAPPED) == UCS_ERR_UNSUPPORTED);\n        EXPECT_TRUE(ucm_test_external_events(UCM_EVENT_MUNMAP | UCM_EVENT_VM_UNMAPPED) ==\n                    UCS_ERR_UNSUPPORTED);\n    }\n}\n\nUCS_TEST_SKIP_COND_F(malloc_hook, test_event_unmap,\n                     RUNNING_ON_VALGRIND || !skip_on_bistro()) {\n    mmap_event<malloc_hook> event(this);\n    ucs_status_t status;\n    const char *symbol = \"munmap\";\n\n    status = event.set(UCM_EVENT_MMAP | UCM_EVENT_MUNMAP | UCM_EVENT_VM_UNMAPPED);\n    ASSERT_UCS_OK(status);\n\n    /* set hook to mmap call */\n    bistro_patch patch(symbol, (void*)bistro_hook<1>::munmap);\n\n    /* munmap should be broken */\n    status = ucm_test_events(UCM_EVENT_MUNMAP);\n    EXPECT_TRUE(status == UCS_ERR_UNSUPPORTED);\n\n    /* vm_unmap should be broken as well, because munmap is broken */\n    status = ucm_test_events(UCM_EVENT_MUNMAP);\n    EXPECT_TRUE(status == UCS_ERR_UNSUPPORTED);\n\n    /* mmap should still work */\n    status = ucm_test_events(UCM_EVENT_MMAP);\n    EXPECT_TRUE(status == UCS_OK);\n}\n\nclass malloc_hook_dlopen : public malloc_hook {\nprotected:\n    class library {\n    public:\n        typedef void* (*loader_t)(const char*, int);\n\n        library(loader_t loader, const std::string &name = \"\"):\n            m_loader(loader), m_name(name), m_lib(NULL)\n        {\n        }\n\n        ~library()\n        {\n            close();\n        }\n\n        void *open(const std::string name = \"\")\n        {\n            if (!name.empty()) {\n                m_name = name;\n            }\n\n            close();\n\n            return (m_lib = m_loader(m_name.empty() ? NULL : m_name.c_str(), RTLD_NOW));\n        }\n\n        void attach(void *lib)\n        {\n            close();\n            m_lib = lib;\n        }\n\n        void close()\n        {\n            if (m_lib != NULL) {\n                dlclose(m_lib);\n                m_lib = NULL;\n            }\n        }\n\n        operator bool()\n        {\n            return m_lib != NULL;\n        }\n\n        void* sym(const char *name)\n        {\n            return dlsym(m_lib, name);\n        }\n\n    protected:\n        loader_t    m_loader;\n        std::string m_name;\n        void       *m_lib;\n    };\n\npublic:\n    typedef library::loader_t loader_t;\n\n    static std::string get_lib_dir() {\n#ifndef GTEST_UCM_HOOK_LIB_DIR\n#  error \"Missing build configuration\"\n#else\n        return GTEST_UCM_HOOK_LIB_DIR;\n#endif\n    }\n\n    static std::string get_lib_path_do_load() {\n        return get_lib_dir() + \"/libdlopen_test_do_load.so\";\n    }\n\n    static std::string get_lib_path_do_mmap() {\n        return get_lib_dir() + \"/libdlopen_test_do_mmap.so\";\n    }\n\n    static std::string get_lib_path_do_load_rpath() {\n        return get_lib_dir() + \"/libdlopen_test_do_load_rpath.so\";\n    }\n\n    static std::string get_lib_path_do_load_sub_rpath() {\n        return \"libdlopen_test_rpath.so\"; // library should be located using rpath\n    }\n\n    /* test for mmap events are fired from non-direct load modules\n     * we are trying to load lib1, from lib1 load lib2, and\n     * fire mmap event from lib2 */\n    void test_indirect_dlopen(loader_t loader)\n    {\n        typedef void (*fire_mmap_f)(void);\n        typedef void* (*load_lib_f)(const char *path, void* (*func)(const char*, int));\n\n        const char *load_lib  = \"load_lib\";\n        const char *fire_mmap = \"fire_mmap\";\n\n        library lib(loader, get_lib_path_do_load());\n        library lib2(NULL); // lib2 is used for attach only\n        load_lib_f load;\n        fire_mmap_f fire;\n        ucs_status_t status;\n        mmap_event<malloc_hook> event(this);\n\n        status = event.set(UCM_EVENT_VM_MAPPED);\n        ASSERT_UCS_OK(status);\n\n        lib.open();\n        ASSERT_TRUE(lib);\n\n        load = (load_lib_f)lib.sym(load_lib);\n        ASSERT_TRUE(load != NULL);\n\n        lib2.attach(load(get_lib_path_do_mmap().c_str(), loader));\n        ASSERT_TRUE(lib2);\n\n        fire = (fire_mmap_f)lib2.sym(fire_mmap);\n        ASSERT_TRUE(fire != NULL);\n\n        m_got_event = 0;\n        fire();\n        EXPECT_GT(m_got_event, 0);\n    }\n\n    /* Test for rpath section of caller module is processes */\n    void test_rpath_dlopen(loader_t loader)\n    {\n        typedef void* (*load_lib_f)(const char *path, void* (*func)(const char*, int));\n\n        const char *load_lib = \"load_lib\";\n\n        library lib(loader);\n        library lib2(NULL); // lib2 is used for attach only\n        load_lib_f load;\n        ucs_status_t status;\n        mmap_event<malloc_hook> event(this);\n\n        /* in case if reloc mode is used - it force hook dlopen */\n        status = event.set(UCM_EVENT_VM_MAPPED);\n        ASSERT_UCS_OK(status);\n\n        /* first check that without rpath library located in subdirectory could not be loaded */\n        lib.open(get_lib_path_do_load());\n        ASSERT_TRUE(lib);\n        if (!lib) {\n            return;\n        }\n\n        load = (load_lib_f)lib.sym(load_lib);\n        ASSERT_TRUE(load != NULL);\n\n        lib2.attach(load(get_lib_path_do_load_sub_rpath().c_str(), loader));\n        ASSERT_FALSE(lib2);\n\n        /* next check that rpath helps to load library located in subdirectory */\n        /* don't care about opened libs - it will be closed automatically */\n        lib.open(get_lib_path_do_load_rpath());\n        ASSERT_TRUE(lib);\n        if (!lib) {\n            return;\n        }\n\n        load = (load_lib_f)lib.sym(load_lib);\n        ASSERT_TRUE(load != NULL);\n\n        lib2.attach(load(get_lib_path_do_load_sub_rpath().c_str(), loader));\n        ASSERT_TRUE(lib2);\n    }\n\n    void test_dlopen_null(loader_t loader)\n    {\n        library lib(loader);\n\n        lib.open();\n        ASSERT_TRUE(lib);\n    }\n};\n\nUCS_TEST_F(malloc_hook_dlopen, indirect_dlopen) {\n    test_indirect_dlopen(dlopen);\n}\n\nUCS_TEST_F(malloc_hook_dlopen, indirect_ucm_dlopen) {\n    test_indirect_dlopen(ucm_dlopen);\n}\n\nUCS_TEST_F(malloc_hook_dlopen, rpath_dlopen) {\n    test_rpath_dlopen(dlopen);\n}\n\nUCS_TEST_F(malloc_hook_dlopen, rpath_ucm_dlopen) {\n    test_rpath_dlopen(ucm_dlopen);\n}\n\nUCS_TEST_F(malloc_hook_dlopen, ucm_dlopen_null_dlopen) {\n    test_dlopen_null(dlopen);\n}\n\nUCS_TEST_F(malloc_hook_dlopen, ucm_dlopen_null_ucm_dlopen) {\n    test_dlopen_null(ucm_dlopen);\n}\n\nUCS_MT_TEST_F(malloc_hook_dlopen, dlopen_mt_with_memtype, 2) {\n#ifndef GTEST_UCM_HOOK_LIB_DIR\n#  error \"Missing build configuration\"\n#endif\n    mmap_event<malloc_hook> event(this);\n\n    ucs_status_t status = event.set(UCM_EVENT_VM_MAPPED |\n                                    UCM_EVENT_MEM_TYPE_ALLOC |\n                                    UCM_EVENT_MEM_TYPE_FREE);\n    ASSERT_UCS_OK(status);\n\n    const std::string path = get_lib_path_do_mmap();\n    static uint32_t count = 0;\n\n    for (int i = 0; i < 100 / ucs::test_time_multiplier(); ++i) {\n        /* Tests that calling dlopen() from 2 threads does not deadlock, if for\n         * example we install memtype relocation patches and call dladdr() while\n         * iterating over loaded libraries.\n         */\n        if (ucs_atomic_fadd32(&count, 1) % 2) {\n            void *lib1 = dlopen(get_lib_path_do_mmap().c_str(), RTLD_LAZY);\n            ASSERT_TRUE(lib1 != NULL);\n            dlclose(lib1);\n        } else {\n            void *lib2 = dlopen(get_lib_path_do_load().c_str(), RTLD_LAZY);\n            ASSERT_TRUE(lib2 != NULL);\n            dlclose(lib2);\n        }\n\n        barrier();\n    }\n\n    event.unset();\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/ucx/test/gtest/ucm/test_dlopen/configure.m4": "#\n# Copyright (C) Mellanox Technologies Ltd. 2001-2019.  ALL RIGHTS RESERVED.\n#\n# See file LICENSE for terms.\n#\n\nAC_CONFIG_FILES([test/gtest/ucm/test_dlopen/Makefile])\n",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/ucx/test/gtest/ucm/test_dlopen/dlopen_test_do_load.c": "/**\n * Copyright (C) Mellanox Technologies Ltd.      2018.  ALL RIGHTS RESERVED.\n *\n * See file LICENSE for terms.\n */\n\n#include <ucs/sys/compiler.h>\n\n#include <dlfcn.h>\n\nUCS_F_NOOPTIMIZE /* prevent using tail recursion unwind */\nvoid* load_lib(const char *path, void* (*load_func)(const char*, int))\n{\n    return (load_func ? load_func : dlopen)(path, RTLD_NOW);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/ucx/test/gtest/ucm/test_dlopen/Makefile.am": "#\n# Copyright (C) Mellanox Technologies Ltd. 2001-2018.  ALL RIGHTS RESERVED.\n#\n# See file LICENSE for terms.\n#\n\n\nnoinst_lib_LTLIBRARIES = \\\n\tlibdlopen_test_do_mmap.la \\\n\tlibdlopen_test_do_load.la \\\n\tlibdlopen_test_do_load_rpath.la\n\nlibdlopen_test_do_mmap_la_SOURCES       = dlopen_test_do_mmap.c\nlibdlopen_test_do_load_la_SOURCES       = dlopen_test_do_load.c\nlibdlopen_test_do_load_rpath_la_SOURCES = dlopen_test_do_load.c\nnoinst_libdir = ${PWD}/.noinst\n\nlibdlopen_test_do_load_rpath_la_CPPFLAGS = -I$(top_srcdir)/src\nlibdlopen_test_do_load_la_CPPFLAGS       = -I$(top_srcdir)/src\nlibdlopen_test_do_load_rpath_la_LDFLAGS  = -R=${PWD}/rpath-subdir/.libs\n\nSUBDIRS = rpath-subdir\n",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/ucx/test/gtest/ucm/test_dlopen/rpath-subdir/configure.m4": "#\n# Copyright (C) Mellanox Technologies Ltd. 2019. ALL RIGHTS RESERVED.\n#\n# See file LICENSE for terms.\n#\n\nAC_CONFIG_FILES([test/gtest/ucm/test_dlopen/rpath-subdir/Makefile])\n",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/ucx/test/gtest/ucm/test_dlopen/rpath-subdir/Makefile.am": "#\n# Copyright (C) Mellanox Technologies Ltd. 2019. ALL RIGHTS RESERVED.\n#\n# See file LICENSE for terms.\n#\n\n\nnoinst_lib_LTLIBRARIES = \\\n\tlibdlopen_test_rpath.la\n\nlibdlopen_test_rpath_la_SOURCES = dlopen_test_rpath.c\nnoinst_libdir = ${PWD}/.noinst\n\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/ucx/test/apps/test_link_map.c": "/**\n * Copyright (C) Mellanox Technologies Ltd. 2019.  ALL RIGHTS RESERVED.\n *\n * See file LICENSE for terms.\n */\n\n#ifdef HAVE_CONFIG_H\n#  include \"config.h\"\n#endif\n\n#include <ucp/api/ucp.h>\n#include <dlfcn.h>\n#include <stdio.h>\n\n\nint main(int argc, char **argv)\n{\n    ucp_params_t params;\n    ucs_status_t status;\n    ucp_context_h context;\n\n    params.field_mask = UCP_PARAM_FIELD_FEATURES;\n    params.features   = UCP_FEATURE_TAG;\n\n    status = ucp_init(&params, NULL, &context);\n    if (status != UCS_OK) {\n        return -1;\n    }\n\n    /* This could segfault if libucm_cuda.so is marked as linker nodelete but\n     * could not be loaded due to libcuda dependency, because of a corrupted\n     * link_map in the program.\n     */\n    dlopen(\"libgcc_s.so.1\", RTLD_LAZY);\n\n    ucp_cleanup(context);\n\n    printf(\"SUCCESS\\n\");\n    return 0;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/ucx/test/apps/test_tcmalloc.c": "/**\n * Copyright (C) Mellanox Technologies Ltd. 2001-2018.  ALL RIGHTS RESERVED.\n *\n * See file LICENSE for terms.\n */\n\n#include <ucp/api/ucp.h>\n#include <dlfcn.h>\n#include <stdio.h>\n\n\nint main(int argc, char **argv)\n{\n    ucp_params_t params;\n    ucs_status_t status;\n    ucp_context_h context;\n\n    params.field_mask = UCP_PARAM_FIELD_FEATURES;\n    params.features   = UCP_FEATURE_TAG;\n\n    status = ucp_init(&params, NULL, &context);\n    if (status != UCS_OK) {\n        return -1;\n    }\n\n    dlopen(\"libselinux.so\", RTLD_LAZY);\n\n    ucp_cleanup(context);\n\n    printf(\"SUCCESS\\n\");\n    return 0;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/ucx/test/apps/test_dlopen_cfg_print.c": "/**\n * Copyright (C) Mellanox Technologies Ltd. 2019.  ALL RIGHTS RESERVED.\n *\n * See file LICENSE for terms.\n */\n\n#include <stdlib.h>\n#include <dlfcn.h>\n#include <stdio.h>\n\n#define _QUOTE(x) #x\n#define QUOTE(x) _QUOTE(x)\n\n\nstatic void* do_dlopen_or_exit(const char *filename)\n{\n    void *handle;\n\n    (void)dlerror();\n    printf(\"opening '%s'\\n\", filename);\n    handle = dlopen(filename, RTLD_LAZY);\n    if (handle == NULL) {\n        fprintf(stderr, \"failed to open %s: %s\\n\", filename,\n                dlerror());\n        exit(1);\n    }\n\n    return handle;\n}\n\nint main(int argc, char **argv)\n{\n    typedef void (*print_all_opts_func_t)(FILE*, const char *, int);\n\n    const char *ucs_filename = QUOTE(UCS_LIB_PATH);\n    const char *uct_filename = QUOTE(UCT_LIB_PATH);\n    void *ucs_handle, *uct_handle;\n    int i;\n\n    /* unload and reload uct while ucs is loaded\n     * would fail if uct global vars are kept on global lists in ucs */\n    ucs_handle = do_dlopen_or_exit(ucs_filename);\n    for (i = 0; i < 2; ++i) {\n        uct_handle = do_dlopen_or_exit(uct_filename);\n        dlclose(uct_handle);\n    }\n\n    /* print all config table, to force going over the global list in ucs */\n    print_all_opts_func_t print_all_opts =\n        (print_all_opts_func_t)dlsym(ucs_handle, \"ucs_config_parser_print_all_opts\");\n    print_all_opts(stdout, \"TEST_\", 0);\n    dlclose(ucs_handle);\n\n    printf(\"done\\n\");\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/ucx/test/apps/test_ucs_dlopen.c": "/**\n * Copyright (C) Mellanox Technologies Ltd. 2019.  ALL RIGHTS RESERVED.\n *\n * See file LICENSE for terms.\n */\n\n#ifdef HAVE_CONFIG_H\n#  include \"config.h\"\n#endif\n\n#include <sys/mman.h>\n#include <dlfcn.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n\n#include <ucm/api/ucm.h>\n\n#define _QUOTE(x) #x\n#define QUOTE(x) _QUOTE(x)\n\n\nstatic void vm_unmap_cb(ucm_event_type_t event_type, ucm_event_t *event,\n                        void *arg)\n{\n}\n\nint test_ucm_set_event_handler(void *handle)\n{\n    typedef ucs_status_t (*ucm_set_event_handler_func_t)(int events,\n                                                         int priority,\n                                                         ucm_event_callback_t cb,\n                                                         void *arg);\n\n    ucm_set_event_handler_func_t ucm_set_event_handler_f;\n    ucs_status_t status;\n\n    dlerror();\n    ucm_set_event_handler_f = (ucm_set_event_handler_func_t)dlsym(handle,\n                                                                  \"ucm_set_event_handler\");\n    if (ucm_set_event_handler_f == NULL) {\n        fprintf(stderr, \"failed to resolve ucm_set_event_handler(): %s\\n\",\n                dlerror());\n        return -1;\n    }\n\n    status = ucm_set_event_handler_f(UCM_EVENT_VM_UNMAPPED, 0, vm_unmap_cb,\n                                     NULL);\n    if (status != UCS_OK) {\n        fprintf(stderr, \"ucm_set_event_handler() failed\\n\");\n        return -1;\n    }\n\n    return 0;\n}\n\nint main(int argc, char **argv)\n{\n    const char *filename = QUOTE(LIB_PATH);\n    void *handle;\n    void *ptr1, *ptr2;\n    size_t alloc_size;\n    long ret;\n\n    /* get page size */\n    ret = sysconf(_SC_PAGESIZE);\n    if (ret < 0) {\n        fprintf(stderr, \"sysconf(_SC_PAGESIZE) failed: %m\\n\");\n        return -1;\n    }\n    alloc_size = ret;\n\n    /* allocate some memory */\n    ptr1 = malloc(alloc_size);\n    if (!ptr1) {\n        fprintf(stderr, \"malloc() failed\\n\");\n        return -1;\n    }\n\n    ptr2 = mmap(NULL, alloc_size, PROT_READ|PROT_WRITE,\n                MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n    if (ptr2 == MAP_FAILED) {\n        fprintf(stderr, \"mmmap() failed: %m\\n\");\n        ret = -1;\n        goto failed_mmap;\n    }\n\n    /* load ucm */\n    printf(\"opening '%s'\\n\", filename);\n    dlerror();\n    handle = dlopen(filename, RTLD_NOW);\n    if (handle == NULL) {\n        fprintf(stderr, \"failed to open %s: %s\\n\", filename, dlerror());\n        ret = -1;\n        goto failed_dlopen;\n    }\n\n    /* init ucm */\n    ret = test_ucm_set_event_handler(handle);\n\n    /* unload ucp */\n    dlclose(handle);\n\nfailed_dlopen:\n    /* release the memory - could break if UCM is unloaded */\n    munmap(ptr2, alloc_size);\nfailed_mmap:\n    free(ptr1);\n\n    printf(\"done\\n\");\n    return ret;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/ucx/test/apps/Makefile.am": "#\n# Copyright (C) Mellanox Technologies Ltd. 2001-2014.  ALL RIGHTS RESERVED.\n# Copyright (C) UT-Battelle, LLC. 2015. ALL RIGHTS RESERVED.\n# Copyright (C) ARM Ltd. 2017.  ALL RIGHTS RESERVED.\n#\n# See file LICENSE for terms.\n#\n\nSUBDIRS = profiling\n\nif HAVE_GLIBCXX_NOTHROW\nSUBDIRS += iodemo\nendif\n\nif HAVE_CXX11\nSUBDIRS += sockaddr\nendif\n\nnoinst_PROGRAMS = \\\n\ttest_ucp_dlopen \\\n\ttest_ucs_dlopen \\\n\ttest_link_map \\\n\ttest_dlopen_cfg_print\n\nobjdir = $(shell sed -n -e 's/^objdir=\\(.*\\)$$/\\1/p' $(LIBTOOL))\n\ntest_ucs_dlopen_SOURCES  = test_ucs_dlopen.c\ntest_ucs_dlopen_CPPFLAGS = $(BASE_CPPFLAGS) \\\n                           -DLIB_PATH=$(abs_top_builddir)/src/ucs/$(objdir)/libucs.so\ntest_ucs_dlopen_CFLAGS   = $(BASE_CFLAGS)\ntest_ucs_dlopen_LDADD    = -ldl\n\ntest_ucp_dlopen_SOURCES  = test_ucp_dlopen.c\ntest_ucp_dlopen_CPPFLAGS = $(BASE_CPPFLAGS) \\\n                           -DLIB_PATH=$(abs_top_builddir)/src/ucp/$(objdir)/libucp.so\ntest_ucp_dlopen_CFLAGS   = $(BASE_CFLAGS)\ntest_ucp_dlopen_LDADD    = -ldl\n\ntest_link_map_SOURCES  = test_link_map.c\ntest_link_map_CPPFLAGS = $(BASE_CPPFLAGS)\ntest_link_map_CFLAGS   = $(BASE_CFLAGS)\ntest_link_map_LDADD    = -ldl $(top_builddir)/src/ucp/libucp.la\n\ntest_dlopen_cfg_print_SOURCES  = test_dlopen_cfg_print.c\ntest_dlopen_cfg_print_CPPFLAGS = $(BASE_CPPFLAGS) -g \\\n\t-DUCS_LIB_PATH=$(abs_top_builddir)/src/ucs/$(objdir)/libucs.so \\\n\t-DUCT_LIB_PATH=$(abs_top_builddir)/src/uct/$(objdir)/libuct.so\ntest_dlopen_cfg_print_CFLAGS   = $(BASE_CFLAGS)\ntest_dlopen_cfg_print_LDADD    = -ldl\n\nif HAVE_TCMALLOC\nnoinst_PROGRAMS       += test_tcmalloc\ntest_tcmalloc_SOURCES  = test_tcmalloc.c\ntest_tcmalloc_CPPFLAGS = $(BASE_CPPFLAGS)\ntest_tcmalloc_CFLAGS   = $(BASE_CFLAGS)\ntest_tcmalloc_LDADD    = -ldl $(TCMALLOC_LIB) \\\n                          $(top_builddir)/src/ucp/libucp.la\nendif\n",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/ucx/test/apps/test_ucp_dlopen.c": "/**\n * Copyright (C) Mellanox Technologies Ltd. 2019.  ALL RIGHTS RESERVED.\n *\n * See file LICENSE for terms.\n */\n\n#ifdef HAVE_CONFIG_H\n#  include \"config.h\"\n#endif\n\n#include <sys/mman.h>\n#include <dlfcn.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n\n#include <ucp/api/ucp.h>\n\n#define _QUOTE(x) #x\n#define QUOTE(x) _QUOTE(x)\n\n\nint test_ucp_init(void *handle)\n{\n    typedef ucs_status_t (*ucp_init_version_func_t)(unsigned, unsigned,\n                                                    const ucp_params_t *,\n                                                    const ucp_config_t *,\n                                                    ucp_context_h *);\n    typedef void (*ucp_context_print_info_func_t)(const ucp_context_h, FILE*);\n    typedef void (*ucp_cleanup_func_t)(ucp_context_h);\n\n    ucp_init_version_func_t ucp_init_version_f;\n    ucp_context_print_info_func_t ucp_context_print_info_f;\n    ucp_cleanup_func_t ucp_cleanup_f;\n    ucp_params_t ucp_params;\n    ucs_status_t status;\n    ucp_context_h ucph;\n\n    ucp_init_version_f       = (ucp_init_version_func_t)dlsym(handle,\n                                                              \"ucp_init_version\");\n    ucp_cleanup_f            = (ucp_cleanup_func_t)dlsym(handle, \"ucp_cleanup\");\n    ucp_context_print_info_f = (ucp_context_print_info_func_t)dlsym(handle,\n                                                                    \"ucp_context_print_info\");\n\n    if (!ucp_init_version_f || !ucp_cleanup_f || !ucp_context_print_info_f) {\n        fprintf(stderr, \"failed to get UCP function pointers\\n\");\n        return -1;\n    }\n\n    ucp_params.field_mask = UCP_PARAM_FIELD_FEATURES;\n    ucp_params.features   = UCP_FEATURE_RMA;\n    status = ucp_init_version_f(UCP_API_MAJOR, UCP_API_MINOR, &ucp_params,\n                                NULL, &ucph);\n    if (status != UCS_OK) {\n        fprintf(stderr, \"ucp_init_version() failed\\n\");\n        return -1;\n    }\n\n    ucp_context_print_info_f(ucph, stdout);\n    ucp_cleanup_f(ucph);\n\n    return 0;\n}\n\nint main(int argc, char **argv)\n{\n    const char *filename = QUOTE(LIB_PATH);\n    void *handle;\n    void *ptr1, *ptr2;\n    size_t alloc_size;\n    long ret;\n\n    /* get page size */\n    ret = sysconf(_SC_PAGESIZE);\n    if (ret < 0) {\n        fprintf(stderr, \"sysconf(_SC_PAGESIZE) failed: %m\\n\");\n        return -1;\n    }\n    alloc_size = ret;\n\n    /* allocate some memory */\n    ptr1 = malloc(alloc_size);\n    if (!ptr1) {\n        fprintf(stderr, \"malloc() failed\\n\");\n        return -1;\n    }\n\n    ptr2 = mmap(NULL, alloc_size, PROT_READ|PROT_WRITE,\n                MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n    if (ptr2 == MAP_FAILED) {\n        fprintf(stderr, \"mmmap() failed: %m\\n\");\n        ret = -1;\n        goto failed_mmap;\n    }\n\n    /* load ucp */\n    printf(\"opening '%s'\\n\", filename);\n    handle = dlopen(filename, RTLD_NOW | RTLD_LOCAL);\n    if (handle == NULL) {\n        fprintf(stderr, \"failed to open %s: %m\\n\", filename);\n        ret = -1;\n        goto failed_dlopen;\n    }\n\n    /* init ucp */\n    ret = test_ucp_init(handle);\n\n    /* unload ucp */\n    dlclose(handle);\n\nfailed_dlopen:\n    /* relase the memory - could break if UCM is unloaded */\n    munmap(ptr2, alloc_size);\nfailed_mmap:\n    free(ptr1);\n\n    printf(\"done\\n\");\n    return ret;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/ucx/contrib/test_jenkins.sh": "#!/bin/bash -eExl\n#\n# Testing script for OpenUCX, to run from Jenkins CI\n#\n# Copyright (C) Mellanox Technologies Ltd. 2001-2017.  ALL RIGHTS RESERVED.\n# Copyright (C) ARM Ltd. 2016-2018.  ALL RIGHTS RESERVED.\n#\n# See file LICENSE for terms.\n#\n#\n# Environment variables set by Jenkins CI:\n#  - WORKSPACE           : path to work dir\n#  - BUILD_NUMBER        : jenkins build number\n#  - JOB_URL             : jenkins job url\n#  - EXECUTOR_NUMBER     : number of executor within the test machine\n#  - JENKINS_RUN_TESTS   : whether to run unit tests\n#  - RUN_TESTS           : same as JENKINS_RUN_TESTS, but for Azure\n#  - JENKINS_TEST_PERF   : whether to validate performance\n#  - JENKINS_NO_VALGRIND : set this to disable valgrind tests\n#\n# Optional environment variables (could be set by job configuration):\n#  - nworkers : number of parallel executors\n#  - worker   : number of current parallel executor\n#  - COV_OPT  : command line options for Coverity static checker\n#\n\nWORKSPACE=${WORKSPACE:=$PWD}\nucx_inst=${WORKSPACE}/install\nCUDA_MODULE=\"dev/cuda11.0\"\nGDRCOPY_MODULE=\"dev/gdrcopy2.0_cuda11.0\"\n\nif [ -z \"$BUILD_NUMBER\" ]; then\n\techo \"Running interactive\"\n\tBUILD_NUMBER=1\n\tWS_URL=file://$WORKSPACE\n\tJENKINS_RUN_TESTS=yes\n\tJENKINS_TEST_PERF=1\n\tTIMEOUT=\"\"\n\tTIMEOUT_VALGRIND=\"\"\nelse\n\techo \"Running under jenkins\"\n\tWS_URL=$JOB_URL/ws\n\tTIMEOUT=\"timeout 160m\"\n\tTIMEOUT_VALGRIND=\"timeout 200m\"\nfi\n\n\n#\n# Set affinity to 2 cores according to Jenkins executor number.\n# Affinity is inherited from agent in Azure CI.\n# TODO: remove or rename after CI migration.\n#\nif [ -n \"$EXECUTOR_NUMBER\" ] && [ -n \"$JENKINS_RUN_TESTS\" ]\nthen\n\tAFFINITY=\"taskset -c $(( 2 * EXECUTOR_NUMBER ))\",\"$(( 2 * EXECUTOR_NUMBER + 1))\"\nelse\n\tAFFINITY=\"\"\nfi\n\n#\n# Parallel build command runs with 4 tasks, or number of cores on the system,\n# whichever is lowest\n#\nnum_cpus=$(lscpu -p | grep -v '^#' | wc -l)\n[ -z $num_cpus ] && num_cpus=1\nparallel_jobs=4\n[ $parallel_jobs -gt $num_cpus ] && parallel_jobs=$num_cpus\nnum_pinned_threads=$(nproc)\n[ $parallel_jobs -gt $num_pinned_threads ] && parallel_jobs=$num_pinned_threads\n\nMAKE=\"make\"\nMAKEP=\"make -j${parallel_jobs}\"\nexport AUTOMAKE_JOBS=$parallel_jobs\n\n\n#\n# Set up parallel test execution - \"worker\" and \"nworkers\" should be set by jenkins\n#\nif [ -z \"$worker\" ] || [ -z \"$nworkers\" ]\nthen\n\tworker=0\n\tnworkers=1\nfi\necho \"==== Running on $(hostname), worker $worker / $nworkers ====\"\n\n#\n# cleanup ucx\n#\nmake_clean() {\n        rm -rf ${ucx_inst}\n        $MAKEP ${1:-clean}\n}\n\n#\n# Test if an environment module exists and load it if yes.\n# Otherwise, return error code.\n#\nmodule_load() {\n\tset +x\n\tmodule=$1\n\tm_avail=\"$(module avail $module 2>&1)\" || true\n\n\tif module avail -t 2>&1 | grep -q \"^$module\\$\"\n\tthen\n\t\tmodule load $module\n\t\tset -x\n\t\treturn 0\n\telse\n\t\tset -x\n\t\treturn 1\n\tfi\n}\n\n#\n# Safe unload for env modules (even if it doesn't exist)\n#\nmodule_unload() {\n\tmodule=$1\n\tmodule unload \"${module}\" || true\n}\n\n#\n# try load cuda modules if nvidia driver is installed\n#\ntry_load_cuda_env() {\n\tnum_gpus=0\n\thave_cuda=no\n\thave_gdrcopy=no\n\tif [ -f \"/proc/driver/nvidia/version\" ]; then\n\t\thave_cuda=yes\n\t\thave_gdrcopy=yes\n\t\tmodule_load $CUDA_MODULE    || have_cuda=no\n\t\tmodule_load $GDRCOPY_MODULE || have_gdrcopy=no\n\t\tnum_gpus=$(nvidia-smi -L | wc -l)\n\tfi\n}\n\nunload_cuda_env() {\n\tmodule_unload $CUDA_MODULE\n\tmodule_unload $GDRCOPY_MODULE\n}\n\n#\n# Check whether this test should do a task with given index,\n# according to the parallel test execution parameters.\n#\nshould_do_task() {\n\tset +x\n\ttask=$1\n\tntasks=$2\n\ttasks_per_worker=$(( (ntasks + nworkers - 1) / nworkers ))\n\tmy_tasks_begin=$((tasks_per_worker * worker))\n\tmy_tasks_end=$((my_tasks_begin + tasks_per_worker))\n\n\t# set return value to 0 (success) iff ($my_tasks_begin <= $task < $my_tasks_end)\n\t[ $task -ge $my_tasks_begin ] && [ $task -lt $my_tasks_end ]\n\trc=$?\n\tset -x\n\treturn $rc\n}\n\n#\n# Do a given task only if the current worker is supposed to do it.\n#\ndo_distributed_task() {\n\tset +x\n\ttask=$1\n\tntasks=$2\n\tshift 2\n\tif should_do_task $task $ntasks\n\tthen\n\t\techo \"==== Running '$@' (task $task/$ntasks) ====\"\n\t\tset -x\n\t\t$@\n\telse\n\t\techo \"==== Skipping '$@' (task $task/$ntasks) ====\"\n\t\tset -x\n\tfi\n}\n\n#\n# Take a list of tasks, and return only the ones this worker should do\n#\nget_my_tasks() {\n\ttask_list=$@\n\tntasks=$(echo $task_list|wc -w)\n\ttask=0\n\tmy_task_list=\"\"\n\tfor item in $task_list\n\tdo\n\t\tshould_do_task $task $ntasks && my_task_list=\"$my_task_list $item\"\n\t\ttask=$((task + 1))\n\tdone\n\techo $my_task_list\n}\n\n#\n# Get list of active IB devices\n#\nget_active_ib_devices() {\n\tdevice_list=$(ibv_devinfo -l | tail -n +2 | sed -e 's/^[ \\t]*//' | head -n -1)\n\tfor ibdev in $device_list\n\tdo\n\t\tport=1\n\t\t(ibv_devinfo -d $ibdev -i $port | grep -q PORT_ACTIVE) && echo \"$ibdev:$port\" || true\n\tdone\n}\n\n#\n# Get list of active IP interfaces\n#\nget_active_ip_ifaces() {\n\tdevice_list=$(ip addr | awk '/state UP/ {print $2}' | sed s/://)\n\tfor netdev in ${device_list}\n\tdo\n\t\t(ip addr show ${netdev} | grep -q 'inet ') && echo ${netdev} || true\n\tdone\n}\n\n#\n# Get IP addr for a given IP iface\n# Argument is the IP iface\n#\nget_ifaddr() {\n\tiface=$1\n\techo $(ip addr show ${iface} | awk '/inet /{print $2}' | awk -F '/' '{print $1}')\n}\n\nget_rdma_device_ip_addr() {\n\tif [ ! -r /dev/infiniband/rdma_cm  ]\n\tthen\n\t\treturn\n\tfi\n\n\tif ! which ibdev2netdev >&/dev/null\n\tthen\n\t\treturn\n\tfi\n\n\tiface=`ibdev2netdev | grep Up | awk '{print $5}' | head -1`\n\tif [ -n \"$iface\" ]\n\tthen\n\t\tipaddr=$(get_ifaddr ${iface})\n\tfi\n\n\tif [ -z \"$ipaddr\" ]\n\tthen\n\t\t# if there is no inet (IPv4) address, escape\n\t\treturn\n\tfi\n\n\tibdev=`ibdev2netdev | grep $iface | awk '{print $1}'`\n\tnode_guid=`cat /sys/class/infiniband/$ibdev/node_guid`\n\tif [ $node_guid == \"0000:0000:0000:0000\" ]\n\tthen\n\t\treturn\n\tfi\n\n\techo $ipaddr\n}\n\n#\n# Prepare build environment\n#\nprepare() {\n\techo \" ==== Prepare ====\"\n\tenv\n\tcd ${WORKSPACE}\n\tif [ -d build-test ]\n\tthen\n\t\tchmod u+rwx build-test -R\n\t\trm -rf build-test\n\tfi\n\t./autogen.sh\n\tmkdir -p build-test\n\tcd build-test\n}\n\n#\n# Build documentation\n#\nbuild_docs() {\n\tdoxy_ready=0\n\tdoxy_target_version=\"1.8.11\"\n\tdoxy_version=\"$(doxygen --version)\" || true\n\n\t# Try load newer doxygen if native is older than 1.8.11\n\tif ! (echo $doxy_target_version; echo $doxy_version) | sort -CV\n\tthen\n\t\tif module_load tools/doxygen-1.8.11\n\t\tthen\n\t\t\tdoxy_ready=1\n\t\telse\n\t\t\techo \" doxygen was not found\"\n\t\tfi\n\telse\n\t\tdoxy_ready=1\n\tfi\n\n\tif [ $doxy_ready -eq 1 ]\n\tthen\n\t\techo \" ==== Build docs only ====\"\n\t\t../configure --prefix=$ucx_inst --with-docs-only\n\t\tmake_clean\n\t\t$MAKE  docs\n\t\tmake_clean # FIXME distclean does not work with docs-only\n\tfi\n}\n\n#\n# Building java docs\n#\nbuild_java_docs() {\n\techo \" ==== Building java docs ====\"\n\tif module_load dev/jdk && module_load dev/mvn\n\tthen\n\t\t../configure --prefix=$ucx_inst --with-java\n\t\t$MAKE -C ../build-test/bindings/java/src/main/native docs\n\t\tmodule unload dev/jdk\n\t\tmodule unload dev/mvn\n\telse\n\t\techo \"No jdk and mvn module, failed to build docs\".\n\tfi\n}\n\n#\n# Build without verbs\n#\nbuild_no_verbs() {\n\techo \"==== Build without IB verbs ====\"\n\t../contrib/configure-release --prefix=$ucx_inst --without-verbs\n\tmake_clean\n\t$MAKEP\n\tmake_clean distclean\n}\n\n#\n# Build without numa support check\n#\nbuild_disable_numa() {\n\techo \"==== Check --disable-numa compilation option ====\"\n\t../contrib/configure-release --prefix=$ucx_inst --disable-numa\n\tmake_clean\n\t$MAKEP\n\tmake_clean distclean\n}\n\n#\n# Build a package in release mode\n#\nbuild_release_pkg() {\n\techo \"==== Build release ====\"\n\t../contrib/configure-release\n\tmake_clean\n\t$MAKEP\n\t$MAKEP distcheck\n\n\t# Show UCX info\n\t./src/tools/info/ucx_info -s -f -c -v -y -d -b -p -w -e -uart -m 20M\n\n\tif [ -f /etc/redhat-release -o -f /etc/fedora-release ]; then\n\t\trpm_based=yes\n\telif [ `cat /etc/os-release | grep -i \"ubuntu\\|mint\"|wc -l` -gt 0 ]; then\n\t\trpm_based=no\n\telse\n\t\t# try rpm tool to detect distro\n\t\tset +e\n\t\tout=$(rpm -q rpm 2>/dev/null)\n\t\trc=$?\n\t\tset -e\n\t\trpm_based=yes\n\t\tif [[ $rc != 0 || \"$out\" == *\"not installed\"* ]]; then\n\t\t\trpm_based=no\n\t\tfi\n\tfi\n\n\tif [[ \"$rpm_based\" == \"no\" && -x /usr/bin/dpkg-buildpackage ]]; then\n\t\techo \"==== Build debian package ====\"\n\t\tdpkg-buildpackage -us -uc\n\telse\n\t\techo \"==== Build RPM ====\"\n\t\t../contrib/buildrpm.sh -s -b --nodeps --define \"_topdir $PWD\"\n\tfi\n\n\t# check that UCX version is present in spec file\n\tcd ${WORKSPACE}\n\t# extract version from configure.ac and convert to MAJOR.MINOR.PATCH representation\n\tversion=$(grep -P \"define\\S+ucx_ver\" configure.ac | awk '{print $2}' | sed 's,),,' | xargs echo | tr ' ' '.')\n\tif ! grep -q \"$version\" ucx.spec.in; then\n\t\techo \"Current UCX version ($version) is not present in ucx.spec.in changelog\"\n\t\texit 1\n\tfi\n\tcd -\n\n\tmake_clean distclean\n}\n\n#\n# Build with Intel compiler\n#\nbuild_icc() {\n\techo 1..1 > build_icc.tap\n\tif module_load intel/ics && icc -v\n\tthen\n\t\techo \"==== Build with Intel compiler ====\"\n\t\t../contrib/configure-devel --prefix=$ucx_inst CC=icc CXX=icpc\n\t\tmake_clean\n\t\t$MAKEP\n\t\tmake_clean distclean\n\t\techo \"==== Build with Intel compiler (clang) ====\"\n\t\t../contrib/configure-devel --prefix=$ucx_inst CC=clang CXX=clang++\n\t\tmake_clean\n\t\t$MAKEP\n\t\tmake_clean distclean\n\t\techo \"ok 1 - build successful \" >> build_icc.tap\n\telse\n\t\techo \"==== Not building with Intel compiler ====\"\n\t\techo \"ok 1 - # SKIP because Intel compiler not installed\" >> build_icc.tap\n\tfi\n\tmodule_unload intel/ics\n}\n\n#\n# Build with PGI compiler\n#\nbuild_pgi() {\n\techo 1..1 > build_pgi.tap\n\tpgi_test_file=$(mktemp ./XXXXXX).c\n\techo \"int main() {return 0;}\" > ${pgi_test_file}\n\n\tif module_load pgi/latest && pgcc18 --version && pgcc18 ${pgi_test_file} -o ${pgi_test_file}.out\n\tthen\n\t\techo \"==== Build with PGI compiler ====\"\n\t\t# PGI failed to build valgrind headers, disable it for now\n\t\t# TODO: Using non-default PGI compiler - pgcc18 which is going to be default\n\t\t#       in next versions.\n\t\t#       Switch to default CC compiler after pgcc18 is default for pgi module\n\t\t../contrib/configure-devel --prefix=$ucx_inst CC=pgcc18 --without-valgrind\n\t\tmake_clean\n\t\t$MAKEP\n\t\tmake_clean distclean\n\t\techo \"ok 1 - build successful \" >> build_pgi.tap\n\telse\n\t\techo \"==== Not building with PGI compiler ====\"\n\t\techo \"ok 1 - # SKIP because PGI compiler not installed\" >> build_pgi.tap\n\tfi\n\n\trm -rf ${pgi_test_file} ${pgi_test_file}.out\n\tmodule_unload pgi/latest\n}\n\n#\n# Build debug version\n#\nbuild_debug() {\n\techo \"==== Build with --enable-debug option ====\"\n\t../contrib/configure-devel --prefix=$ucx_inst --enable-debug --enable-examples\n\tmake_clean\n\t$MAKEP\n\tmake_clean distclean\n}\n\n#\n# Build prof\n#\nbuild_prof() {\n\techo \"==== Build configure-prof ====\"\n\t../contrib/configure-prof --prefix=$ucx_inst\n\tmake_clean\n\t$MAKEP\n\tmake_clean distclean\n}\n\n#\n# Build UGNI\n#\nbuild_ugni() {\n\techo 1..1 > build_ugni.tap\n\n\techo \"==== Build with cray-ugni ====\"\n\t#\n\t# Point pkg-config to contrib/cray-ugni-mock, and replace\n\t# PKG_CONFIG_TOP_BUILD_DIR with source dir, since the mock .pc files contain\n\t# relative paths.\n\t#\n\t../contrib/configure-devel --prefix=$ucx_inst --with-ugni \\\n\t\tPKG_CONFIG_PATH=$PKG_CONFIG_PATH:$PWD/../contrib/cray-ugni-mock \\\n\t\tPKG_CONFIG_TOP_BUILD_DIR=$PWD/..\n\tmake_clean\n\t$MAKEP\n\n\t# make sure UGNI transport is enabled\n\tgrep '#define HAVE_TL_UGNI 1' config.h\n\n\t$MAKE  distcheck\n\tmake_clean distclean\n\n\tmodule_unload dev/cray-ugni\n\techo \"ok 1 - build successful \" >> build_ugni.tap\n}\n\n#\n# Build CUDA\n#\nbuild_cuda() {\n\techo 1..1 > build_cuda.tap\n\tif module_load $CUDA_MODULE\n\tthen\n\t\tif module_load $GDRCOPY_MODULE\n\t\tthen\n\t\t\techo \"==== Build with enable cuda, gdr_copy ====\"\n\t\t\t../contrib/configure-devel --prefix=$ucx_inst --with-cuda --with-gdrcopy\n\t\t\tmake_clean\n\t\t\t$MAKEP\n\t\t\tmake_clean distclean\n\n\t\t\t../contrib/configure-release --prefix=$ucx_inst --with-cuda --with-gdrcopy\n\t\t\tmake_clean\n\t\t\t$MAKEP\n\t\t\tmake_clean distclean\n\t\t\tmodule unload $GDRCOPY_MODULE\n\t\tfi\n\n\t\techo \"==== Build with enable cuda, w/o gdr_copy ====\"\n\t\t../contrib/configure-devel --prefix=$ucx_inst --with-cuda --without-gdrcopy\n\t\tmake_clean\n\t\t$MAKEP\n\n\t\tmodule unload $CUDA_MODULE\n\n\t\techo \"==== Running test_link_map with cuda build but no cuda module ====\"\n\t\tenv UCX_HANDLE_ERRORS=bt ./test/apps/test_link_map\n\n\t\tmake_clean distclean\n\t\techo \"ok 1 - build successful \" >> build_cuda.tap\n\telse\n\t\techo \"==== Not building with cuda flags ====\"\n\t\techo \"ok 1 - # SKIP because cuda not installed\" >> build_cuda.tap\n\tfi\n\tunload_cuda_env\n}\n\n#\n# Build with clang compiler\n#\nbuild_clang() {\n\techo 1..1 > build_clang.tap\n\tif which clang > /dev/null 2>&1\n\tthen\n\t\techo \"==== Build with clang compiler ====\"\n\t\t../contrib/configure-devel --prefix=$ucx_inst CC=clang CXX=clang++\n\t\tmake_clean\n\t\t$MAKEP\n\t\t$MAKEP install\n\t\tUCX_HANDLE_ERRORS=bt,freeze UCX_LOG_LEVEL_TRIGGER=ERROR $ucx_inst/bin/ucx_info -d\n\t\tmake_clean distclean\n\t\techo \"ok 1 - build successful \" >> build_clang.tap\n\telse\n\t\techo \"==== Not building with clang compiler ====\"\n\t\techo \"ok 1 - # SKIP because clang not installed\" >> build_clang.tap\n\tfi\n}\n\n#\n# Build with gcc-latest module\n#\nbuild_gcc_latest() {\n\techo 1..1 > build_gcc_latest.tap\n\t#If the glibc version on the host is older than 2.14, don't run\n\t#check the glibc version with the ldd version since it comes with glibc\n\t#see https://www.linuxquestions.org/questions/linux-software-2/how-to-check-glibc-version-263103/\n\t#see https://benohead.com/linux-check-glibc-version/\n\t#see https://stackoverflow.com/questions/9705660/check-glibc-version-for-a-particular-gcc-compiler\n\tldd_ver=\"$(ldd --version | awk '/ldd/{print $NF}')\"\n\tif (echo \"2.14\"; echo $ldd_ver) | sort -CV\n\tthen\n\t\tif module_load dev/gcc-latest\n\t\tthen\n\t\t\techo \"==== Build with GCC compiler ($(gcc --version|head -1)) ====\"\n\t\t\t../contrib/configure-devel --prefix=$ucx_inst\n\t\t\tmake_clean\n\t\t\t$MAKEP\n\t\t\t$MAKEP install\n\t\t\tUCX_HANDLE_ERRORS=bt,freeze UCX_LOG_LEVEL_TRIGGER=ERROR $ucx_inst/bin/ucx_info -d\n\t\t\tmake_clean distclean\n\t\t\techo \"ok 1 - build successful \" >> build_gcc_latest.tap\n\t\t\tmodule unload dev/gcc-latest\n\t\telse\n\t\t\techo \"==== Not building with latest gcc compiler ====\"\n\t\t\techo \"ok 1 - # SKIP because dev/gcc-latest module is not available\" >> build_gcc_latest.tap\n\t\tfi\n\telse\n\t\techo \"==== Not building with gcc compiler ====\"\n\t\techo \"Required glibc version is too old ($ldd_ver)\"\n\t\techo \"ok 1 - # SKIP because glibc version is older than 2.14\" >> build_gcc_latest.tap\n\tfi\n}\n\n#\n# Install and check experimental headers\n#\nbuild_experimental_api() {\n\t# Experimental header file should not be installed by regular build\n\techo \"==== Install WITHOUT experimental API ====\"\n\t../contrib/configure-release --prefix=$ucx_inst\n\tmake_clean\n\t$MAKEP install\n\t! test -e $ucx_inst/include/ucp/api/ucpx.h\n\n\t# Experimental header file should be installed by --enable-experimental-api\n\techo \"==== Install WITH experimental API ====\"\n\t../contrib/configure-release --prefix=$ucx_inst --enable-experimental-api\n\tmake_clean\n\t$MAKEP install\n\ttest -e $ucx_inst/include/ucp/api/ucpx.h\n}\n\n#\n# Builds jucx\n#\nbuild_jucx() {\n\techo 1..1 > build_jucx.tap\n\tif module_load dev/jdk && module_load dev/mvn\n\tthen\n\t\techo \"==== Building JUCX bindings (java api for ucx) ====\"\n\t\t../contrib/configure-release --prefix=$ucx_inst --with-java\n\t\tmake_clean\n\t\t$MAKEP\n\t\t$MAKEP install\n\t\tmake_clean distclean\n\t\techo \"ok 1 - build successful \" >> build_jucx.tap\n\t\tmodule unload dev/jdk\n\t\tmodule unload dev/mvn\n\telse\n\t\techo \"==== No jdk and mvn modules ==== \"\n\t\techo \"ok 1 - # SKIP because dev/jdk and dev/mvn modules are not available\" >> build_jucx.tap\n\tfi\n}\n\n#\n# Build with armclang compiler\n#\nbuild_armclang() {\n\techo 1..1 > build_armclang.tap\n\tarmclang_test_file=$(mktemp ./XXXXXX).c\n\techo \"int main() {return 0;}\" > ${armclang_test_file}\n\tif module_load arm-compiler/latest && armclang --version && armclang ${armclang_test_file} -o ${armclang_test_file}.out\n\tthen\n\t\techo \"==== Build with armclang compiler ====\"\n\t\t../contrib/configure-devel --prefix=$ucx_inst CC=armclang CXX=armclang++\n\t\tmake_clean\n\t\t$MAKEP\n\t\t$MAKEP install\n\t\tUCX_HANDLE_ERRORS=bt,freeze UCX_LOG_LEVEL_TRIGGER=ERROR $ucx_inst/bin/ucx_info -d\n\t\tmake_clean distclean\n\t\techo \"ok 1 - build successful \" >> build_armclang.tap\n\telse\n\t\techo \"==== Not building with armclang compiler ====\"\n\t\techo \"ok 1 - # SKIP because armclang not installed\" >> build_armclang.tap\n\tfi\n\n\trm -rf ${armclang_test_file} ${armclang_test_file}.out\n\tmodule_unload arm-compiler/latest\n}\n\ncheck_inst_headers() {\n\techo 1..1 > inst_headers.tap\n\techo \"==== Testing installed headers ====\"\n\n\t../contrib/configure-release --prefix=$PWD/install\n\tmake_clean\n\t$MAKEP install\n\t../contrib/check_inst_headers.sh $PWD/install/include\n\tmake_clean distclean\n\n\techo \"ok 1 - build successful \" >> inst_headers.tap\n}\n\ncheck_make_distcheck() {\n\techo 1..1 > make_distcheck.tap\n\n\t# If the gcc version on the host is older than 4.8.5, don't run\n\t# due to a compiler bug that reproduces when building with gtest\n\t# https://gcc.gnu.org/bugzilla/show_bug.cgi?id=61886\n\tif (echo \"4.8.5\"; gcc --version | head -1 | awk '{print $3}') | sort -CV\n\tthen\n\t\techo \"==== Testing make distcheck ====\"\n\t\tmake_clean && make_clean distclean\n\t\t../contrib/configure-release --prefix=$PWD/install\n\t\t$MAKEP DISTCHECK_CONFIGURE_FLAGS=\"--enable-gtest\" distcheck\n\telse\n\t\techo \"Not testing make distcheck: GCC version is too old ($(gcc --version|head -1))\"\n\tfi\n}\n\ncheck_config_h() {\n\techo 1..1 > check_config_h.tap\n\n\tsrcdir=$PWD/../src\n\n\t# Check if all .c files include config.h\n\techo \"==== Checking for config.h files in directory $srcdir ====\"\n\n\tmissing=`find $srcdir -name \\*.c -o -name \\*.cc | xargs grep -LP '\\#\\s*include\\s+\"config.h\"'`\n\n\tif [ `echo $missing | wc -w` -eq 0 ]\n\tthen\n\t\techo \"ok 1 - check successful \" >> check_config_h.tap\n\telse\n\t\techo \"Error: missing include config.h in files: $missing\"\n\t\texit 1\n\tfi\n}\n\n#\n# Expands a CPU list such as \"0-3,17\" to \"0 1 2 3 17\" (each cpu in a new line)\n#\nexpand_cpulist() {\n\tcpulist=$1\n\ttokens=$(echo ${cpulist} | tr ',' ' ')\n\tfor token in ${tokens}\n\tdo\n\t\t# if there is no '-', first and last would be equal\n\t\tfirst=$(echo ${token} | cut -d'-' -f1)\n\t\tlast=$( echo ${token} | cut -d'-' -f2)\n\n\t\tfor ((cpu=${first};cpu<=${last};++cpu))\n\t\tdo\n\t\t\techo ${cpu}\n\t\tdone\n\tdone\n}\n\n#\n# Get the N'th CPU that the current process can run on\n#\nslice_affinity() {\n\tn=$1\n\n\t# get affinity mask of the current process\n\tcompact_cpulist=$($AFFINITY bash -c 'taskset -cp $$' | cut -d: -f2)\n\tcpulist=$(expand_cpulist ${compact_cpulist})\n\n\techo \"${cpulist}\" | head -n $((n + 1)) | tail -1\n}\n\n#\n# `rename` has a binary and Perl flavors. Ubuntu comes with Perl one and\n# requires different usage.\n#\nrename_files() {\n\texpr=$1; shift\n\treplacement=$1; shift\n\tfiles=$*\n\tif rename --version | grep 'util-linux'; then\n\t\trename \"${expr}\" \"${replacement}\" $files\n\t\treturn\n\tfi\n\n\trename \"s/\\\\${expr}\\$/${replacement}/\" \"${files}\"\n}\n\nrun_client_server_app() {\n\ttest_name=$1\n\ttest_args=$2\n\tserver_addr_arg=$3\n\tkill_server=$4\n\terror_emulation=$5\n\n\tserver_port=$((10000 + EXECUTOR_NUMBER))\n\tserver_port_arg=\"-p $server_port\"\n\n\taffinity_server=$(slice_affinity 0)\n\taffinity_client=$(slice_affinity 1)\n\n\ttaskset -c $affinity_server ${test_name} ${test_args} ${server_port_arg} &\n\tserver_pid=$!\n\n\tsleep 15\n\n\tif [ $error_emulation -eq 1 ]\n\tthen\n\t\tset +Ee\n\tfi\n\n\ttaskset -c $affinity_client ${test_name} ${test_args} ${server_addr_arg} ${server_port_arg} &\n\tclient_pid=$!\n\n\twait ${client_pid}\n\n\tif [ $error_emulation -eq 1 ]\n\tthen\n\t\tset -eE\n\tfi\n\n\tif [ $kill_server -eq 1 ]\n\tthen\n\t\tkill -9 ${server_pid}\n\telse\n\t\twait ${server_pid}\n\tfi\n}\n\nrun_hello() {\n\tapi=$1\n\tshift\n\ttest_args=\"$@\"\n\ttest_name=${api}_hello_world\n\n\tif [ ! -x ${test_name} ]\n\tthen\n\t\t$MAKEP -C examples ${test_name}\n\tfi\n\n\t# set smaller timeouts so the test will complete faster\n\tif [[ ${test_args} == *\"-e\"* ]]\n\tthen\n\t\texport UCX_UD_TIMEOUT=15s\n\t\texport UCX_RC_TIMEOUT=1ms\n\t\texport UCX_RC_RETRY_COUNT=4\n\tfi\n\n\tif [[ ${test_args} == *\"-e\"* ]]\n\tthen\n\t\terror_emulation=1\n\telse\n\t\terror_emulation=0\n\tfi\n\n\trun_client_server_app \"./examples/${test_name}\" \"${test_args}\" \"-n $(hostname)\" 0 $error_emulation\n\n\tif [[ ${test_args} == *\"-e\"* ]]\n\tthen\n\t\tunset UCX_UD_TIMEOUT\n\t\tunset UCX_RC_TIMEOUT\n\t\tunset UCX_RC_RETRY_COUNT\n\tfi\n}\n\n#\n# Compile and run UCP hello world example\n#\nrun_ucp_hello() {\n\tif ./src/tools/info/ucx_info -e -u twe|grep ERROR\n\tthen\n\t\treturn # skip if cannot create ucp ep\n\tfi\n\n\tmem_types_list=\"host \"\n\n\tif [ \"X$have_cuda\" == \"Xyes\" ]\n\tthen\n\t\tmem_types_list+=\"cuda cuda-managed \"\n\tfi\n\n\tfor test_mode in -w -f -b -e\n\tdo\n\t\tfor mem_type in $mem_types_list\n\t\tdo\n\t\t\techo \"==== Running UCP hello world with mode ${test_mode} and \\\"${mem_type}\\\" memory type ====\"\n\t\t\trun_hello ucp ${test_mode} -m ${mem_type}\n\t\tdone\n\tdone\n\trm -f ./ucp_hello_world\n}\n\n#\n# Compile and run UCT hello world example\n#\nrun_uct_hello() {\n\tmem_types_list=\"host \"\n\n\tif [ \"X$have_cuda\" == \"Xyes\" ] && [ -f \"/sys/kernel/mm/memory_peers/nv_mem/version\" ]\n\tthen\n\t\tmem_types_list+=\"cuda-managed \"\n\t\tif [ -f \"/sys/kernel/mm/memory_peers/nv_mem/version\" ]\n\t\tthen\n\t\t\t# test RDMA GPUDirect\n\t\t\tmem_types_list+=\"cuda \"\n\t\tfi\n\tfi\n\n\tfor send_func in -i -b -z\n\tdo\n\t\tfor ucx_dev in $(get_active_ib_devices)\n\t\tdo\n\t\t\tfor mem_type in $mem_types_list\n\t\t\tdo\n\t\t\t\techo \"==== Running UCT hello world server on rc/${ucx_dev} with sending ${send_func} and \\\"${mem_type}\\\" memory type ====\"\n\t\t\t\trun_hello uct -d ${ucx_dev} -t \"rc_verbs\" ${send_func} -m ${mem_type}\n\t\t\tdone\n\t\tdone\n\t\tfor ucx_dev in $(get_active_ip_iface)\n\t\tdo\n\t\t\techo \"==== Running UCT hello world server on tcp/${ucx_dev} with sending ${send_func} ====\"\n\t\t\trun_hello uct -d ${ucx_dev} -t \"tcp\" ${send_func}\n\t\tdone\n\tdone\n\trm -f ./uct_hello_world\n}\n\nrun_client_server() {\n\ttest_name=ucp_client_server\n\n\tif [ ! -x ${test_name} ]\n\tthen\n\t\tgcc -o ${test_name} ${ucx_inst}/share/ucx/examples/${test_name}.c \\\n\t\t\t-lucp -lucs -I${ucx_inst}/include -L${ucx_inst}/lib \\\n\t\t\t-Wl,-rpath=${ucx_inst}/lib\n\tfi\n\n\tserver_ip=$(get_rdma_device_ip_addr)\n\tif [ \"$server_ip\" == \"\" ]\n\tthen\n\t\treturn\n\tfi\n\n\trun_client_server_app \"./${test_name}\" \"\" \"-a ${server_ip}\" 1 0\n}\n\nrun_ucp_client_server() {\n\techo \"==== Running UCP client-server  ====\"\n\trun_client_server\n\n\trm -f ./ucp_client_server\n}\n\nrun_io_demo() {\n\tserver_ip=$(get_rdma_device_ip_addr)\n\tif [ \"$server_ip\" == \"\" ]\n\tthen\n\t\treturn\n\tfi\n\n\techo \"==== Running UCP IO demo  ====\"\n\n\ttest_args=\"$@ -o write,read -d 128:4194304 -i 10000 -w 10\"\n\ttest_name=io_demo\n\n\tif [ ! -x ${test_name} ]\n\tthen\n\t\t$MAKEP -C test/apps/iodemo ${test_name}\n\tfi\n\n\texport UCX_SOCKADDR_CM_ENABLE=y\n\trun_client_server_app \"./test/apps/iodemo/${test_name}\" \"${test_args}\" \"${server_ip}\" 1 0\n\n\tunset UCX_SOCKADDR_CM_ENABLE\n\tmake_clean\n}\n\n#\n# Run UCX performance test\n# Note: If requested running with MPI, MPI has to be initialized before\n# The function accepts 0 (default value) or 1 that means launching w/ or w/o MPI\n#\nrun_ucx_perftest() {\n\tif [ $# -eq 0 ]\n\tthen\n\t\twith_mpi=0\n\telse\n\t\twith_mpi=$1\n\tfi\n\tucx_inst_ptest=$ucx_inst/share/ucx/perftest\n\n\t# hack for perftest, no way to override params used in batch\n\t# todo: fix in perftest\n\tsed -s 's,-n [0-9]*,-n 100,g' $ucx_inst_ptest/msg_pow2 | sort -R > $ucx_inst_ptest/msg_pow2_short\n\tcat $ucx_inst_ptest/test_types_uct |                sort -R > $ucx_inst_ptest/test_types_short_uct\n\tcat $ucx_inst_ptest/test_types_ucp | grep -v cuda | sort -R > $ucx_inst_ptest/test_types_short_ucp\n\n\tucx_perftest=\"$ucx_inst/bin/ucx_perftest\"\n\tuct_test_args=\"-b $ucx_inst_ptest/test_types_short_uct \\\n\t\t\t\t-b $ucx_inst_ptest/msg_pow2_short -w 1\"\n\n\tucp_test_args=\"-b $ucx_inst_ptest/test_types_short_ucp \\\n\t\t\t\t-b $ucx_inst_ptest/msg_pow2_short -w 1\"\n\n\t# IP ifaces\n\tip_ifaces=$(get_active_ip_ifaces)\n\n\t# shared memory, IB devices, IP ifaces\n\tdevices=\"memory $(get_active_ib_devices) ${ip_ifaces}\"\n\n\t# Run on all devices\n\tmy_devices=$(get_my_tasks $devices)\n\tfor ucx_dev in $my_devices\n\tdo\n\t\tif [[ $ucx_dev =~ .*mlx5.* ]]; then\n\t\t\topt_transports=\"-b $ucx_inst_ptest/transports\"\n\t\t\ttls=`awk '{print $3 }' $ucx_inst_ptest/transports | tr '\\n' ',' | sed -r 's/,$//; s/mlx5/x/g'`\n\t\t\tdev=$ucx_dev\n\t\telif [[ $ucx_dev =~ memory ]]; then\n\t\t\topt_transports=\"-x posix\"\n\t\t\ttls=\"shm\"\n\t\t\tdev=\"all\"\n\t\telif [[ \" ${ip_ifaces[*]} \" == *\" ${ucx_dev} \"* ]]; then\n\t\t\topt_transports=\"-x tcp\"\n\t\t\ttls=\"tcp\"\n\t\t\tdev=$ucx_dev\n\t\telse\n\t\t\topt_transports=\"-x rc_verbs\"\n\t\t\ttls=\"rc_v\"\n\t\t\tdev=$ucx_dev\n\t\tfi\n\n\t\techo \"==== Running ucx_perf kit on $ucx_dev ====\"\n\t\tif [ $with_mpi -eq 1 ]\n\t\tthen\n\t\t\t# Run UCT performance test\n\t\t\t$MPIRUN -np 2 $AFFINITY $ucx_perftest $uct_test_args -d $ucx_dev $opt_transports\n\n\t\t\t# Run UCP performance test\n\t\t\t$MPIRUN -np 2 -x UCX_NET_DEVICES=$dev -x UCX_TLS=$tls $AFFINITY $ucx_perftest $ucp_test_args\n\n\t\t\t# Run UCP performance test with 2 threads\n\t\t\t$MPIRUN -np 2 -x UCX_NET_DEVICES=$dev -x UCX_TLS=$tls $AFFINITY $ucx_perftest $ucp_test_args -T 2\n\t\telse\n\t\t\texport UCX_NET_DEVICES=$dev\n\t\t\texport UCX_TLS=$tls\n\n\t\t\t# Run UCT performance test\n\t\t\trun_client_server_app \"$ucx_perftest\" \"$uct_test_args -d ${ucx_dev} ${opt_transports}\" \\\n\t\t\t\t\t\t\t\t\"$(hostname)\" 0 0\n\n\t\t\t# Run UCP performance test\n\t\t\trun_client_server_app \"$ucx_perftest\" \"$ucp_test_args\" \"$(hostname)\" 0 0\n\n\t\t\t# Run UCP performance test with 2 threads\n\t\t\trun_client_server_app \"$ucx_perftest\" \"$ucp_test_args -T 2\" \"$(hostname)\" 0 0\n\n\t\t\tunset UCX_NET_DEVICES\n\t\t\tunset UCX_TLS\n\t\tfi\n\tdone\n\n\t# run cuda tests if cuda module was loaded and GPU is found\n\tif [ \"X$have_cuda\" == \"Xyes\" ]\n\tthen\n\t\ttls_list=\"all \"\n\t\tgdr_options=\"n \"\n\t\tif (lsmod | grep -q \"nv_peer_mem\")\n\t\tthen\n\t\t\techo \"GPUDirectRDMA module (nv_peer_mem) is present..\"\n\t\t\ttls_list+=\"rc,cuda_copy \"\n\t\t\tgdr_options+=\"y \"\n\t\tfi\n\n\t\tif  [ \"X$have_gdrcopy\" == \"Xyes\" ] && (lsmod | grep -q \"gdrdrv\")\n\t\tthen\n\t\t\techo \"GDRCopy module (gdrdrv) is present...\"\n\t\t\ttls_list+=\"rc,cuda_copy,gdr_copy \"\n\t\tfi\n\n\t\tif [ $num_gpus -gt 1 ]; then\n\t\t\texport CUDA_VISIBLE_DEVICES=$(($worker%$num_gpus)),$(($(($worker+1))%$num_gpus))\n\t\tfi\n\n\t\tcat $ucx_inst_ptest/test_types_ucp | grep cuda | sort -R > $ucx_inst_ptest/test_types_short_ucp\n\t\tsed -s 's,-n [0-9]*,-n 10 -w 1,g' $ucx_inst_ptest/msg_pow2 | sort -R > $ucx_inst_ptest/msg_pow2_short\n\n\t\techo \"==== Running ucx_perf with cuda memory====\"\n\n\t\tfor tls in $tls_list\n\t\tdo\n\t\t\tfor memtype_cache in y n\n\t\t\tdo\n\t\t\t\tfor gdr in $gdr_options\n\t\t\t\tdo\n\t\t\t\t\tif [ $with_mpi -eq 1 ]\n\t\t\t\t\tthen\n\t\t\t\t\t\t$MPIRUN -np 2 -x UCX_TLS=$tls -x UCX_MEMTYPE_CACHE=$memtype_cache \\\n\t\t\t\t\t\t\t\t\t -x UCX_IB_GPU_DIRECT_RDMA=$gdr $AFFINITY $ucx_perftest $ucp_test_args\n\t\t\t\t\telse\n\t\t\t\t\t\texport UCX_TLS=$tls\n\t\t\t\t\t\texport UCX_MEMTYPE_CACHE=$memtype_cache\n\t\t\t\t\t\texport UCX_IB_GPU_DIRECT_RDMA=$gdr\n\t\t\t\t\t\trun_client_server_app \"$ucx_perftest\" \"$ucp_test_args\" \"$(hostname)\" 0 0\n\t\t\t\t\t\tunset UCX_TLS\n\t\t\t\t\t\tunset UCX_MEMTYPE_CACHE\n\t\t\t\t\t\tunset UCX_IB_GPU_DIRECT_RDMA\n\t\t\t\t\tfi\n\t\t\t\tdone\n\t\t\tdone\n\t\tdone\n\n\t\tif [ $with_mpi -eq 1 ]\n\t\tthen\n\t\t\t$MPIRUN -np 2 -x UCX_TLS=self,shm,cma,cuda_copy $AFFINITY $ucx_perftest $ucp_test_args\n\t\t\t$MPIRUN -np 2 -x UCX_TLS=self,sm,cuda_ipc,cuda_copy $AFFINITY $ucx_perftest $ucp_test_args\n\t\t\t$MPIRUN -np 2 $AFFINITY $ucx_perftest $ucp_test_args\n\t\telse\n\t\t\texport UCX_TLS=self,shm,cma,cuda_copy\n\t\t\trun_client_server_app \"$ucx_perftest\" \"$ucp_test_args\" \"$(hostname)\" 0 0\n\t\t\tunset UCX_TLS\n\n\t\t\trun_client_server_app \"$ucx_perftest\" \"$ucp_test_args\" \"$(hostname)\" 0 0\n\t\tfi\n\n\t\t# Specifically test cuda_ipc for large message sizes\n\t        cat $ucx_inst_ptest/test_types_ucp | grep -v cuda | sort -R > $ucx_inst_ptest/test_types_cuda_ucp\n\t\tucp_test_args_large=\"-b $ucx_inst_ptest/test_types_cuda_ucp \\\n\t\t\t             -b $ucx_inst_ptest/msg_pow2_large -w 1\"\n\t\tif [ $with_mpi -eq 1 ]\n\t\tthen\n\t\t\tfor ipc_cache in y n\n\t\t\tdo\n\t\t\t\t$MPIRUN -np 2 -x UCX_TLS=self,sm,cuda_copy,cuda_ipc \\\n\t\t\t\t\t-x UCX_CUDA_IPC_CACHE=$ipc_cache $AFFINITY $ucx_perftest $ucp_test_args_large\n\t\t\tdone\n\t\telse\n\t\t\tfor ipc_cache in y n\n\t\t\tdo\n\t\t\t\texport UCX_TLS=self,sm,cuda_copy,cuda_ipc\n\t\t\t\texport UCX_CUDA_IPC_CACHE=$ipc_cache\n\t\t\t\trun_client_server_app \"$ucx_perftest\" \"$ucp_test_args_large\" \"$(hostname)\" 0 0\n\t\t\t\tunset UCX_TLS\n\t\t\t\tunset UCX_CUDA_IPC_CACHE\n\t\t\tdone\n\t\tfi\n\n\t\tunset CUDA_VISIBLE_DEVICES\n\tfi\n}\n\n#\n# Test malloc hooks with mpi\n#\ntest_malloc_hooks_mpi() {\n\tfor tname in malloc_hooks malloc_hooks_unmapped external_events flag_no_install\n\tdo\n\t\techo \"==== Running memory hook (${tname}) on MPI ====\"\n\t\t$MPIRUN -np 1 $AFFINITY ./test/mpi/test_memhooks -t $tname\n\tdone\n\n\techo \"==== Running memory hook (malloc_hooks) on MPI with LD_PRELOAD ====\"\n\tucm_lib=$PWD/src/ucm/.libs/libucm.so\n\tls -l $ucm_lib\n\t$MPIRUN -np 1 -x LD_PRELOAD=$ucm_lib $AFFINITY ./test/mpi/test_memhooks -t malloc_hooks\n}\n\n#\n# Run tests with MPI library\n#\nrun_mpi_tests() {\n\techo \"1..2\" > mpi_tests.tap\n\tif module_load hpcx-gcc && mpirun --version\n\tthen\n\t\t# Prevent our tests from using UCX libraries from hpcx module by prepending\n\t\t# our local library path first\n\t\texport LD_LIBRARY_PATH=${ucx_inst}/lib:$LD_LIBRARY_PATH\n\n\t\t../contrib/configure-release --prefix=$ucx_inst --with-mpi # TODO check in -devel mode as well\n\t\tmake_clean\n\t\t$MAKEP install\n\t\t$MAKEP installcheck # check whether installation is valid (it compiles examples at least)\n\n\t\tMPIRUN=\"mpirun \\\n\t\t\t\t--bind-to none \\\n\t\t\t\t-x UCX_ERROR_SIGNALS \\\n\t\t\t\t-x UCX_HANDLE_ERRORS \\\n\t\t\t\t-mca pml ob1 \\\n\t\t\t\t-mca btl tcp,self \\\n\t\t\t\t-mca btl_tcp_if_include lo \\\n\t\t\t\t-mca orte_allowed_exit_without_sync 1 \\\n\t\t\t\t-mca coll ^hcoll,ml\"\n\n\t\trun_ucx_perftest 1\n\t\techo \"ok 1 - ucx perftest\" >> mpi_tests.tap\n\n\t\ttest_malloc_hooks_mpi\n\t\techo \"ok 2 - malloc hooks\" >> mpi_tests.tap\n\n\t\tmake_clean distclean\n\n\t\tmodule unload hpcx-gcc\n\telse\n\t\techo \"==== Not running MPI tests ====\"\n\t\techo \"ok 1 - # SKIP because MPI not installed\" >> mpi_tests.tap\n\t\techo \"ok 2 - # SKIP because MPI not installed\" >> mpi_tests.tap\n\tfi\n}\n\nbuild_ucx_profiling() {\n\t# compile the profiling example code\n\tgcc -o ucx_profiling ../test/apps/profiling/ucx_profiling.c \\\n\t\t-lm -lucs -I${ucx_inst}/include -L${ucx_inst}/lib -Wl,-rpath=${ucx_inst}/lib\n}\n\n#\n# Test profiling infrastructure\n#\ntest_profiling() {\n\techo \"==== Running profiling example  ====\"\n\n\t# configure release mode, application profiling should work\n\t../contrib/configure-release --prefix=$ucx_inst\n\tmake_clean\n\t$MAKEP\n\t$MAKEP install\n\n\tbuild_ucx_profiling\n\n\tUCX_PROFILE_MODE=log UCX_PROFILE_FILE=ucx_jenkins.prof ./ucx_profiling\n\n\tUCX_READ_PROFILE=${ucx_inst}/bin/ucx_read_profile\n\t$UCX_READ_PROFILE -r ucx_jenkins.prof | grep \"printf\" -C 20\n\t$UCX_READ_PROFILE -r ucx_jenkins.prof | grep -q \"calc_pi\"\n\t$UCX_READ_PROFILE -r ucx_jenkins.prof | grep -q \"print_pi\"\n}\n\ntest_ucs_load() {\n\t../contrib/configure-release --prefix=$ucx_inst\n\tmake_clean\n\t$MAKEP\n\t$MAKEP install\n\n\tbuild_ucx_profiling\n\n\t# Make sure UCS library constructor does not call socket()\n\techo \"==== Running UCS library loading test ====\"\n\tstrace ./ucx_profiling &> strace.log\n\t! grep '^socket' strace.log\n}\n\ntest_ucs_dlopen() {\n\t$MAKEP\n\n\t# Make sure UCM is not unloaded\n\techo \"==== Running UCS dlopen test with memhooks ====\"\n\t./test/apps/test_ucs_dlopen\n\n\t# Test global config list integrity after loading/unloading of UCT\n\techo \"==== Running test_dlopen_cfg_print ====\"\n\t./test/apps/test_dlopen_cfg_print\n}\n\ntest_ucp_dlopen() {\n\t../contrib/configure-release --prefix=$ucx_inst\n\tmake_clean\n\t$MAKEP\n        $MAKEP install\n\n\t# Make sure UCP library, when opened with dlopen(), loads CMA module\n\tLIB_CMA=`find ${ucx_inst} -name libuct_cma.so.0`\n\tif [ -n \"$LIB_CMA\" ]\n\tthen\n\t\techo \"==== Running UCP library loading test ====\"\n\t\t./test/apps/test_ucp_dlopen # just to save output to log\n\t\t./test/apps/test_ucp_dlopen | grep 'cma/memory'\n\telse\n\t\techo \"==== Not running UCP library loading test ====\"\n\tfi\n}\n\ntest_memtrack() {\n\t../contrib/configure-devel --prefix=$ucx_inst\n\tmake_clean\n\t$MAKEP\n\n\techo \"==== Running memtrack test ====\"\n\tUCX_MEMTRACK_DEST=stdout ./test/gtest/gtest --gtest_filter=test_memtrack.sanity\n}\n\ntest_unused_env_var() {\n\t# We must create a UCP worker to get the warning about unused variables\n\techo \"==== Running ucx_info env vars test ====\"\n\tUCX_IB_PORTS=mlx5_0:1 ./src/tools/info/ucx_info -epw -u t | grep \"unused\" | grep -q \"UCX_IB_PORTS\"\n}\n\ntest_env_var_aliases() {\n\techo \"==== Running MLX5 env var aliases test ====\"\n\tif [[ `./src/tools/info/ucx_info -b | grep -P 'HW_TM *1$'` ]]\n\tthen\n\t\tvars=( \"TM_ENABLE\" \"TM_LIST_SIZE\" \"TX_MAX_BB\" )\n\t\tfor var in \"${vars[@]}\"\n\t\tdo\n\t\t\tfor tl in \"RC_MLX5\" \"DC_MLX5\"\n\t\t\tdo\n\t\t\t\tval=$(./src/tools/info/ucx_info -c | grep \"${tl}_${var}\" | cut -d'=' -f2)\n\t\t\t\tif [ -z $val ]\n\t\t\t\tthen\n\t\t\t\t\techo \"UCX_${tl}_${var} does not exist in UCX config\"\n\t\t\t\t\texit 1\n\t\t\t\tfi\n\t\t\t\t# To check that changing env var takes an effect,\n\t\t\t\t# create some value, which is different from the default.\n\t\t\t\tmagic_val=`echo $val | sed -e ' s/inf\\|auto/15/; s/n/swap/; s/y/n/; s/swap/y/; s/\\([0-9]\\)/\\11/'`\n\n\t\t\t\t# Check that both (tl name and common RC) aliases work\n\t\t\t\tfor var_alias in \"RC\" $tl\n\t\t\t\tdo\n\t\t\t\t\tvar_name=UCX_${var_alias}_${var}\n\t\t\t\t\tval_set=$(export $var_name=$magic_val; ./src/tools/info/ucx_info -c | grep \"${tl}_${var}\" | cut -d'=' -f2)\n\t\t\t\t\tif [ \"$val_set\" != \"$magic_val\" ]\n\t\t\t\t\tthen\n\t\t\t\t\t\techo \"Can't set $var_name\"\n\t\t\t\t\t\texit 1\n\t\t\t\t\tfi\n\t\t\t\tdone\n\t\t\tdone\n\t\tdone\n\telse\n\t\techo \"HW TM is not compiled in UCX\"\n\tfi\n}\n\ntest_malloc_hook() {\n\techo \"==== Running malloc hooks test ====\"\n\tif [ -x ./test/apps/test_tcmalloc ]\n\tthen\n\t\t./test/apps/test_tcmalloc\n\tfi\n}\n\ntest_jucx() {\n\techo \"==== Running jucx test ====\"\n\techo \"1..2\" > jucx_tests.tap\n\tiface=`ibdev2netdev | grep Up | awk '{print $5}' | head -1`\n\tif [ -z \"$iface\" ]\n        then\n\t\techo \"Failed to find active ib devices.\" >> jucx_tests.tap\n\t\treturn\n\telif module_load dev/jdk && module_load dev/mvn\n\tthen\n\t\tjucx_port=$((20000 + EXECUTOR_NUMBER))\n\t\texport JUCX_TEST_PORT=$jucx_port\n\t\texport UCX_MEM_EVENTS=no\n\t\t$MAKE -C bindings/java/src/main/native test\n\t        ifaces=`ibdev2netdev | grep Up | awk '{print $5}'`\n\t\tif [ -n \"$ifaces\" ]\n\t\tthen\n                        $MAKE -C bindings/java/src/main/native package\n\t\tfi\n\t\tfor iface in $ifaces\n\t\tdo\n\t\t\tif [ -n \"$iface\" ]\n                \tthen\n                   \t\tserver_ip=$(get_ifaddr ${iface})\n                \tfi\n\n                \tif [ -z \"$server_ip\" ]\n                \tthen\n\t\t   \t   \techo \"Interface $iface has no IPv4\"\n                   \t   \tcontinue\n                        fi\n                        echo \"Running standalone benchamrk on $iface\"\n\n                        java -XX:ErrorFile=$WORKSPACE/hs_err_${BUILD_NUMBER}_%p.log  \\\n                                -XX:OnError=\"cat $WORKSPACE/hs_err_${BUILD_NUMBER}_%p.log\" \\\n\t\t\t         -cp \"bindings/java/resources/:bindings/java/src/main/native/build-java/*\" \\\n\t\t\t\t org.openucx.jucx.examples.UcxReadBWBenchmarkReceiver \\\n\t\t\t\t s=$server_ip p=$JUCX_TEST_PORT &\n                        java_pid=$!\n\t\t\t sleep 10\n                        java -XX:ErrorFile=$WORKSPACE/hs_err_${BUILD_NUMBER}_%p.log \\\n\t\t\t\t -XX:OnError=\"cat $WORKSPACE/hs_err_${BUILD_NUMBER}_%p.log\" \\\n\t\t\t         -cp \"bindings/java/resources/:bindings/java/src/main/native/build-java/*\"  \\\n\t\t\t\t org.openucx.jucx.examples.UcxReadBWBenchmarkSender \\\n\t\t\t\t s=$server_ip p=$JUCX_TEST_PORT t=10000000\n\t\t\t wait $java_pid\n\t\tdone\n\n\t\tunset JUCX_TEST_PORT\n\t\tunset UCX_MEM_EVENTS\n\t\tmodule unload dev/jdk\n\t\tmodule unload dev/mvn\n\t\techo \"ok 1 - jucx test\" >> jucx_tests.tap\n\telse\n\t\techo \"Failed to load dev/jdk and dev/mvn modules.\" >> jucx_tests.tap\n\tfi\n}\n\n#\n# Run Coverity and report errors\n# The argument is a UCX build type: devel or release\n#\nrun_coverity() {\n\techo 1..1 > coverity.tap\n\tif module_load tools/cov\n\tthen\n\t\tucx_build_type=$1\n\n\t\techo \"==== Running coverity ====\"\n\t\t../contrib/configure-$ucx_build_type --prefix=$ucx_inst\n\t\tmake_clean\n\t\tcov_build_id=\"cov_build_${ucx_build_type}_${BUILD_NUMBER}\"\n\t\tcov_build=\"$WORKSPACE/$cov_build_id\"\n\t\trm -rf $cov_build\n\t\tcov-build --dir $cov_build $MAKEP all\n\t\tcov-analyze --jobs $parallel_jobs $COV_OPT --security --concurrency --dir $cov_build\n\t\tnerrors=$(cov-format-errors --dir $cov_build | awk '/Processing [0-9]+ errors?/ { print $2 }')\n\t\trc=$(($rc+$nerrors))\n\n\t\tindex_html=$(cd $cov_build && find . -name index.html | cut -c 3-)\n\t\tif [ -z \"$BUILD_URL\" ]; then\n\t\t\tcov_url=\"${WS_URL}/${cov_build_id}/${index_html}\"\n\t\telse\n\t\t\tcov_url=\"${BUILD_URL}/artifact/${cov_build_id}/${index_html}\"\n\t\tfi\n\t\trm -f jenkins_sidelinks.txt\n\t\tif [ $nerrors -gt 0 ]; then\n\t\t\tcov-format-errors --dir $cov_build --emacs-style\n\t\t\techo \"not ok 1 Coverity Detected $nerrors failures # $cov_url\" >> coverity.tap\n\t\telse\n\t\t\techo \"ok 1 Coverity found no issues\" >> coverity.tap\n\t\t\trm -rf $cov_build\n\t\tfi\n\n\t\techo Coverity report: $cov_url\n\t\tprintf \"%s\\t%s\\n\" Coverity $cov_url >> jenkins_sidelinks.txt\n\t\tmodule unload tools/cov\n\n\t\treturn $rc\n\telse\n\t\techo \"==== Not running Coverity ====\"\n\t\techo \"ok 1 - # SKIP because Coverity not installed\" >> coverity.tap\n\tfi\n}\n\nrun_gtest_watchdog_test() {\n\twatchdog_timeout=$1\n\tsleep_time=$2\n\texpected_runtime=$3\n\texpected_err_str=\"Connection timed out - abort testing\"\n\n\tmake -C test/gtest\n\n\tstart_time=`date +%s`\n\n\tenv WATCHDOG_GTEST_TIMEOUT_=$watchdog_timeout \\\n\t\tWATCHDOG_GTEST_SLEEP_TIME_=$sleep_time \\\n\t\tGTEST_FILTER=test_watchdog.watchdog_timeout \\\n\t\t./test/gtest/gtest 2>&1 | tee watchdog_timeout_test &\n\tpid=$!\n\twait $pid\n\n\tend_time=`date +%s`\n\n\tres=\"$(grep -x \"$expected_err_str\" watchdog_timeout_test)\" || true\n\n\trm -f watchdog_timeout_test\n\n\tif [ \"$res\" != \"$expected_err_str\" ]\n\tthen\n\t\techo \"didn't find [$expected_err_str] string in the test output\"\n\t\texit 1\n\tfi\n\n\truntime=$(($end_time-$start_time))\n\n\tif [ $runtime -gt $expected_runtime ]\n\tthen\n\t\techo \"Watchdog timeout test takes $runtime seconds that\" \\\n\t\t\t\"is greater than expected $expected_runtime seconds\"\n\t\texit 1\n\tfi\n}\n\n#\n# Run the test suite (gtest)\n# Arguments: <compiler-name> [configure-flags]\n#\nrun_gtest() {\n\tcompiler_name=$1\n\tshift\n\t../contrib/configure-devel --prefix=$ucx_inst $@\n\tmake_clean\n\t$MAKEP\n\n\techo \"==== Running watchdog timeout test, $compiler_name compiler ====\"\n\trun_gtest_watchdog_test 5 60 300\n\n\texport GTEST_SHARD_INDEX=$worker\n\texport GTEST_TOTAL_SHARDS=$nworkers\n\texport GTEST_RANDOM_SEED=0\n\texport GTEST_SHUFFLE=1\n\texport GTEST_TAP=2\n\texport GTEST_REPORT_DIR=$WORKSPACE/reports/tap\n\t# Run UCT tests for TCP over fastest device only\n\texport GTEST_UCT_TCP_FASTEST_DEV=1\n\t# Report TOP-20 longest test at the end of testing\n\texport GTEST_REPORT_LONGEST_TESTS=20\n\texport OMP_NUM_THREADS=4\n\n\tif [ $num_gpus -gt 0 ]; then\n\t\texport CUDA_VISIBLE_DEVICES=$(($worker%$num_gpus))\n\tfi\n\n\tGTEST_EXTRA_ARGS=\"\"\n\tif [ \"$JENKINS_TEST_PERF\" == 1 ]\n\tthen\n\t\t# Check performance with 10 retries and 2 seconds interval\n\t\tGTEST_EXTRA_ARGS=\"$GTEST_EXTRA_ARGS -p 10 -i 2.0\"\n\tfi\n\texport GTEST_EXTRA_ARGS\n\n\tmkdir -p $GTEST_REPORT_DIR\n\n\techo \"==== Running unit tests, $compiler_name compiler ====\"\n\t$AFFINITY $TIMEOUT make -C test/gtest test\n\t(cd test/gtest && rename_files .tap _gtest.tap *.tap && mv *.tap $GTEST_REPORT_DIR)\n\n\techo \"==== Running malloc hooks mallopt() test, $compiler_name compiler ====\"\n\t# gtest returns with non zero exit code if there were no\n\t# tests to run. As a workaround run a single test on every\n\t# shard.\n\t$AFFINITY $TIMEOUT \\\n\t\tenv UCX_IB_RCACHE=n \\\n\t\tMALLOC_TRIM_THRESHOLD_=-1 \\\n\t\tMALLOC_MMAP_THRESHOLD_=-1 \\\n\t\tGTEST_SHARD_INDEX=0 \\\n\t\tGTEST_TOTAL_SHARDS=1 \\\n\t\tGTEST_FILTER=malloc_hook_cplusplus.mallopt \\\n\t\tmake -C test/gtest test\n\t(cd test/gtest && rename_files .tap _mallopt_gtest.tap malloc_hook_cplusplus.tap && mv *.tap $GTEST_REPORT_DIR)\n\n\techo \"==== Running malloc hooks mmap_ptrs test with MMAP_THRESHOLD=16384, $compiler_name compiler ====\"\n\t$AFFINITY $TIMEOUT \\\n\t\tenv MALLOC_MMAP_THRESHOLD_=16384 \\\n\t\tGTEST_SHARD_INDEX=0 \\\n\t\tGTEST_TOTAL_SHARDS=1 \\\n\t\tGTEST_FILTER=malloc_hook_cplusplus.mmap_ptrs \\\n\t\tmake -C test/gtest test\n\t(cd test/gtest && rename_files .tap _mmap_ptrs_gtest.tap malloc_hook_cplusplus.tap && mv *.tap $GTEST_REPORT_DIR)\n\n\tif ! [[ $(uname -m) =~ \"aarch\" ]] && ! [[ $(uname -m) =~ \"ppc\" ]] && \\\n\t   ! [[ -n \"${JENKINS_NO_VALGRIND}\" ]]\n\tthen\n\t\techo \"==== Running valgrind tests, $compiler_name compiler ====\"\n\n\t\t# Load newer valgrind if naative is older than 3.10\n\t\tif ! (echo \"valgrind-3.10.0\"; valgrind --version) | sort -CV\n\t\tthen\n\t\t\tmodule load tools/valgrind-latest\n\t\tfi\n\n\t\t$AFFINITY $TIMEOUT_VALGRIND make -C test/gtest test_valgrind\n\t\t(cd test/gtest && rename_files .tap _vg.tap *.tap && mv *.tap $GTEST_REPORT_DIR)\n\t\tmodule unload tools/valgrind-latest\n\telse\n\t\techo \"==== Not running valgrind tests with $compiler_name compiler ====\"\n\t\techo \"1..1\"                                          > vg_skipped.tap\n\t\techo \"ok 1 - # SKIP because running on $(uname -m)\" >> vg_skipped.tap\n\tfi\n\n\tunset OMP_NUM_THREADS\n\tunset GTEST_UCT_TCP_FASTEST_DEV\n\tunset GTEST_SHARD_INDEX\n\tunset GTEST_TOTAL_SHARDS\n\tunset GTEST_RANDOM_SEED\n\tunset GTEST_SHUFFLE\n\tunset GTEST_TAP\n\tunset GTEST_REPORT_DIR\n\tunset GTEST_EXTRA_ARGS\n\tunset CUDA_VISIBLE_DEVICES\n}\n\nrun_gtest_default() {\n\trun_gtest \"default\"\n}\n\nrun_gtest_armclang() {\n\tif module_load arm-compiler/arm-hpc-compiler && armclang -v\n\tthen\n\t\trun_gtest \"armclang\" CC=armclang CXX=armclang++\n\telse\n\t\techo \"==== Not running with armclang compiler ====\"\n\t\techo \"1..1\"                                          > armclang_skipped.tap\n\t\techo \"ok 1 - # SKIP because armclang not found\"     >> armclang_skipped.tap\n\tfi\n\tmodule unload arm-compiler/arm-hpc-compiler\n}\n\n\n#\n# Run the test suite (gtest) in release configuration\n#\nrun_gtest_release() {\n\n\techo \"1..1\" > gtest_release.tap\n\n\t../contrib/configure-release --prefix=$ucx_inst --enable-gtest\n\tmake_clean\n\t$MAKEP\n\n\texport GTEST_SHARD_INDEX=0\n\texport GTEST_TOTAL_SHARDS=1\n\texport GTEST_RANDOM_SEED=0\n\texport GTEST_SHUFFLE=1\n\texport GTEST_TAP=2\n\texport GTEST_REPORT_DIR=$WORKSPACE/reports/tap\n\texport OMP_NUM_THREADS=4\n\n\techo \"==== Running unit tests (release configuration) ====\"\n\t# Check:\n\t# - Important object sizes\n\t# - Unexpected RNDV test, to cover rkey handling in tag offload flow\n\t#   (see GH #3827 for details)\n\tenv GTEST_FILTER=\\*test_obj_size\\*:\\*test_ucp_tag_match.rndv_rts_unexp\\* \\\n\t\t$AFFINITY $TIMEOUT make -C test/gtest test\n\techo \"ok 1\" >> gtest_release.tap\n\n\tunset OMP_NUM_THREADS\n\tunset GTEST_SHARD_INDEX\n\tunset GTEST_TOTAL_SHARDS\n\tunset GTEST_RANDOM_SEED\n\tunset GTEST_SHUFFLE\n\tunset GTEST_TAP\n\tunset GTEST_REPORT_DIR\n}\n\nrun_ucx_tl_check() {\n\n\techo \"1..1\" > ucx_tl_check.tap\n\n\t../test/apps/test_ucx_tls.py -p $ucx_inst\n\n\tif [ $? -ne 0 ]; then\n\t\techo \"not ok 1\" >> ucx_tl_check.tap\n\telse\n\t\techo \"ok 1\" >> ucx_tl_check.tap\n\tfi\n}\n\n#\n# Run all tests\n#\nrun_tests() {\n\texport UCX_HANDLE_ERRORS=freeze,bt\n\texport UCX_ERROR_SIGNALS=SIGILL,SIGSEGV,SIGBUS,SIGFPE,SIGPIPE,SIGABRT\n\texport UCX_ERROR_MAIL_TO=$ghprbActualCommitAuthorEmail\n\texport UCX_ERROR_MAIL_FOOTER=$JOB_URL/$BUILD_NUMBER/console\n\n\t# test cuda build if cuda modules available\n\tdo_distributed_task 2 4 build_cuda\n\n\t# load cuda env only if GPU available for remaining tests\n\ttry_load_cuda_env\n\n\tdo_distributed_task 0 4 build_icc\n\tdo_distributed_task 0 4 build_pgi\n\tdo_distributed_task 1 4 build_debug\n\tdo_distributed_task 1 4 build_prof\n\tdo_distributed_task 1 4 build_ugni\n\tdo_distributed_task 3 4 build_clang\n\tdo_distributed_task 0 4 build_armclang\n\tdo_distributed_task 1 4 build_gcc_latest\n\tdo_distributed_task 2 4 build_experimental_api\n\tdo_distributed_task 0 4 build_jucx\n\n\t# all are running mpi tests\n\trun_mpi_tests\n\n\tif module_load dev/jdk && module_load dev/mvn\n\tthen\n\t\t../contrib/configure-devel --prefix=$ucx_inst --with-java\n\telse\n\t\t../contrib/configure-devel --prefix=$ucx_inst\n\tfi\n\t$MAKEP\n\t$MAKEP install\n\n\trun_ucx_tl_check\n\n\tdo_distributed_task 1 4 run_ucp_hello\n\tdo_distributed_task 2 4 run_uct_hello\n\tdo_distributed_task 1 4 run_ucp_client_server\n\tdo_distributed_task 2 4 run_ucx_perftest\n\tdo_distributed_task 1 4 run_io_demo\n\tdo_distributed_task 3 4 test_profiling\n\tdo_distributed_task 0 3 test_jucx\n\tdo_distributed_task 1 4 test_ucs_dlopen\n\tdo_distributed_task 3 4 test_ucs_load\n\tdo_distributed_task 3 4 test_memtrack\n\tdo_distributed_task 0 4 test_unused_env_var\n\tdo_distributed_task 2 4 test_env_var_aliases\n\tdo_distributed_task 1 3 test_malloc_hook\n\tdo_distributed_task 0 4 test_ucp_dlopen\n\n\t# all are running gtest\n\trun_gtest_default\n\trun_gtest_armclang\n\n\tdo_distributed_task 3 4 run_coverity release\n\tdo_distributed_task 0 4 run_coverity devel\n\tdo_distributed_task 1 4 run_gtest_release\n}\n\nprepare\ntry_load_cuda_env\ndo_distributed_task 0 4 build_docs\ndo_distributed_task 0 4 build_java_docs\ndo_distributed_task 0 4 build_disable_numa\ndo_distributed_task 1 4 build_no_verbs\ndo_distributed_task 2 4 build_release_pkg\ndo_distributed_task 3 4 check_inst_headers\ndo_distributed_task 1 4 check_make_distcheck\ndo_distributed_task 2 4 check_config_h\nif [ -n \"$JENKINS_RUN_TESTS\" ] || [ -n \"$RUN_TESTS\" ]\nthen\n\trun_tests\nfi\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/src/mpi/romio/adio/common/ad_iwrite_coll.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/src/mpi/romio/adio/common/ad_iread_coll.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/src/mpi/romio/doc/source-guide.tex",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/src/util/logging/rlog/rimshot/res/Toolbar.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/src/util/logging/rlog/rimshot/res/rimshotDoc.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/src/util/logging/rlog/rimshot/res/rimshot.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/maint/setup.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/maint/local_perl/YAML-Tiny-1.41.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/.git/objects/pack/pack-e02c89064aa44c7b7ca59c624a0a445bcd082245.idx",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/.git/objects/pack/pack-e02c89064aa44c7b7ca59c624a0a445bcd082245.pack",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/.git/modules/modules/libfabric/objects/pack/pack-2583a12c1db3d68e8d69d14a9badf82d9ebe79ee.pack",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/.git/modules/modules/libfabric/objects/pack/pack-2583a12c1db3d68e8d69d14a9badf82d9ebe79ee.idx",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/.git/modules/modules/izem/objects/pack/pack-18b8833261a4900246da8fca2ae12c88ba783b41.pack",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/.git/modules/modules/izem/objects/pack/pack-18b8833261a4900246da8fca2ae12c88ba783b41.idx",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/.git/modules/modules/json-c/objects/pack/pack-2acf87c8bf8b98ca89091b37e34db3b02b5cb88e.pack",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/.git/modules/modules/json-c/objects/pack/pack-2acf87c8bf8b98ca89091b37e34db3b02b5cb88e.idx",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/.git/modules/modules/hwloc/objects/pack/pack-ca6493ee64b565c921cf52852575356bdf7fc4f0.pack",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/.git/modules/modules/hwloc/objects/pack/pack-ca6493ee64b565c921cf52852575356bdf7fc4f0.idx",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/.git/modules/modules/ucx/objects/pack/pack-5f78e4a3be370835c58e6b34bedd24d483cdc4b1.pack",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/.git/modules/modules/ucx/objects/pack/pack-5f78e4a3be370835c58e6b34bedd24d483cdc4b1.idx",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/.git/modules/modules/ucx/modules/ucg/objects/pack/pack-779e8206ab9ade40bb3c4c94dabe19c9cd039010.idx",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/.git/modules/modules/ucx/modules/ucg/objects/pack/pack-779e8206ab9ade40bb3c4c94dabe19c9cd039010.pack",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/.git/modules/modules/yaksa/objects/pack/pack-75c93a884716ca4d00959fe1c8e8a52140cbe500.idx",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/.git/modules/modules/yaksa/objects/pack/pack-75c93a884716ca4d00959fe1c8e8a52140cbe500.pack",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/json-c/tests/test_parse.expected",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/utils/hwloc/test-hwloc-compress-dir.input.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/utils/hwloc/test-hwloc-compress-dir.output.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/utils/hwloc/test-hwloc-dump-hwdata/knl-snc4h50.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/netloc/data/plafrim2.txz",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/netloc/data/avakas.txz",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/netloc/data/plafrim.txz",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/netloc/data/scotch.txz",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/linux/1alpha.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/linux/8ia64-2n2s2c.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/linux/4ia64-4s.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/linux/16em64t-4s2c2t.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/linux/8amd64-4n2c.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/linux/256ppc-8n8s4t.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/linux/8em64t-2s2ca2c-buggynuma.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/linux/96em64t-4n4d3ca2co.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/linux/28em64t-2s2n7c-buggycoresiblings.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/linux/2arm-2c.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/linux/32em64t-2n8c+1mic.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/linux/16ia64-8n2s.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/linux/20s390-2g6s4c.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/linux/48amd64-4d2n6c-sparse.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/linux/8em64t-2s2ca2c.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/linux/2i386-2c-nohugepage.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/linux/4em64t-2c2t-ignore-reorder.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/linux/16em64t-4s2c2t-offlines.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/linux/2ps3-2t.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/linux/40intel64-2g2n4c+pci.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/linux/64intel64-fakeKNL-A2A-cache.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/linux/8ia64-2s2c2t.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/linux/8em64t-4c2t.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/linux/40intel64-4n10c+pci-conflicts.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/linux/16amd64-8n2c.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/linux/256ia64-64n2s2c.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/linux/64fake-4n2s2ca2c2t.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/linux/32ppc-4n4c2c.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/linux/32amd64-4s2n4c-cgroup.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/linux/64intel64-fakeKNL-SNC4-hybrid.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/linux/8ia64-4s2c.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/linux/4fake-4gr1nu1pu.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/linux/4ppc-4c.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/linux/4qs22-2s2t.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/linux/2amd64-2n.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/linux/16amd64-8n2c-cpusets.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/linux/2i386-2t-hugepagesizecount.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/linux/16amd64-4n4c-cgroup-distance-merge.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/linux/8em64t-2s4c-heterogeneous.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/linux/2s390-2c.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/linux/64amd64-4s2n4ca2co.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/linux/128ia64-17n4s2c.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/linux/16em64t-4s2ca2c-cpusetreorder.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/linux/allowed/test1.fsroot.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/x86/Intel-SandyBridge-2xXeon-E5-2650.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/x86/AMD-17h-Zen-2xEpyc-7451.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/x86/AMD-15h-Bulldozer-4xOpteron-6272.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/x86/AMD-15h-Piledriver-4xOpteron-6348.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/x86/AMD-K8-SantaRosa-2xOpteron-2218.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/x86/Intel-KnightsLanding-XeonPhi-7210.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/x86/Intel-Westmere-2xXeon-X5650.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/x86/Intel-Skylake-2xXeon6140.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/x86/AMD-K10-MagnyCours-2xOpteron-6164HE.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/x86/Intel-Haswell-2xXeon-E5-2680v3.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/x86/Intel-Nehalem-2xXeon-X5550.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/x86/AMD-K10-Istanbul-8xOpteron-8439SE.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/x86/AMD-K8-SledgeHammer-2xOpteron-250.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/x86/Intel-KnightsCorner-XeonPhi-SE10P.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/x86/Zhaoxin-Shanghai-KaiSheng-ZXC+-FC1081.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/x86/Intel-Penryn-4xXeon-X7460.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/x86/Zhaoxin-CentaurHauls-ZXD-4600.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/x86/Intel-IvyBridge-12xXeon-E5-4620v2.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/x86/Intel-Core-2xXeon-E5345.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/tests/hwloc/x86/Intel-Broadwell-2xXeon-E5-2650Lv4.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/doc/images/ppc64-with-smt.png",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/doc/images/emmett.png",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/doc/images/hagrid.png",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/doc/images/ppc64-full-with-smt.png",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/doc/images/dudley.png",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/doc/images/devel09-pci.png",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/doc/images/netloc_design.png",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/doc/images/netloc_draw.png",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/hwloc/doc/images/ppc64-without-smt.png",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/ucx/docs/source/_static/ucxlogo.png",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/ucx/docs/source/_static/UCX_Layers.png",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/ucx/docs/doxygen/Architecture.png",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/ucx/docs/doxygen/Architecture.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/ucx/docs/doxygen/UCX_Logo_930x933.png",
        "/tmp/vanessa/spack-stage/spack-stage-mpich-develop-723musosxdgndkfjflu46x76hhv5ladb/spack-src/modules/ucx/docs/doxygen/UCX_Logo_80x80.png"
    ],
    "total_files": 7727
}