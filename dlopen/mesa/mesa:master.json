{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-mesa-master-nrat2nfszfps3qrvs2kywr374rcjkgv2/spack-src/meson.build": "# Copyright \u00a9 2017-2020 Intel Corporation\n\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n\n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n# SOFTWARE.\n\nproject(\n  'mesa',\n  ['c', 'cpp'],\n  version : run_command(\n    [find_program('python', 'python3'), 'bin/meson_get_version.py']\n  ).stdout(),\n  license : 'MIT',\n  meson_version : '>= 0.52',\n  default_options : ['buildtype=debugoptimized', 'b_ndebug=if-release', 'c_std=c99', 'cpp_std=c++14']\n)\n\ncc = meson.get_compiler('c')\ncpp = meson.get_compiler('cpp')\n\nnull_dep = dependency('', required : false)\n\nif get_option('layout') != 'mirror'\n  error('`mirror` is the only build directory layout supported')\nendif\n\n# Arguments for the preprocessor, put these in a separate array from the C and\n# C++ (cpp in meson terminology) arguments since they need to be added to the\n# default arguments for both C and C++.\npre_args = [\n  '-D__STDC_CONSTANT_MACROS',\n  '-D__STDC_FORMAT_MACROS',\n  '-D__STDC_LIMIT_MACROS',\n  '-DPACKAGE_VERSION=\"@0@\"'.format(meson.project_version()),\n  '-DPACKAGE_BUGREPORT=\"https://gitlab.freedesktop.org/mesa/mesa/-/issues\"',\n]\n\nwith_vulkan_icd_dir = get_option('vulkan-icd-dir')\nwith_tests = get_option('build-tests')\nwith_glcpp_tests = get_option('enable-glcpp-tests')\nwith_aco_tests = get_option('build-aco-tests')\nwith_glx_read_only_text = get_option('glx-read-only-text')\nwith_glx_direct = get_option('glx-direct')\nwith_osmesa = get_option('osmesa')\nwith_swr_arches = get_option('swr-arches')\nwith_vulkan_overlay_layer = get_option('vulkan-overlay-layer')\nwith_tools = get_option('tools')\nif with_tools.contains('all')\n  with_tools = [\n    'drm-shim',\n    'etnaviv',\n    'freedreno',\n    'glsl',\n    'intel',\n    'intel-ui',\n    'lima',\n    'nir',\n    'nouveau',\n    'xvmc',\n  ]\nendif\nwith_clc = false\n\nwith_intel_tools = with_tools.contains('intel') or with_tools.contains('intel-ui')\nwith_imgui = with_intel_tools or with_vulkan_overlay_layer\n\ndri_drivers_path = get_option('dri-drivers-path')\nif dri_drivers_path == ''\n  dri_drivers_path = join_paths(get_option('prefix'), get_option('libdir'), 'dri')\nendif\ndri_search_path = get_option('dri-search-path')\nif dri_search_path == ''\n  dri_search_path = dri_drivers_path\nendif\n\nwith_gles1 = get_option('gles1')\nif with_gles1 == 'true'\n  with_gles1 = 'enabled'\n  warning('gles1 option \"true\" deprecated, please use \"enabled\" instead.')\nelif with_gles1 == 'false'\n  with_gles1 = 'disabled'\n  warning('gles1 option \"false\" deprecated, please use \"disabled\" instead.')\nendif\nwith_gles2 = get_option('gles2')\nif with_gles2 == 'true'\n  with_gles2 = 'enabled'\n  warning('gles2 option \"true\" deprecated, please use \"enabled\" instead.')\nelif with_gles2 == 'false'\n  with_gles2 = 'disabled'\n  warning('gles2 option \"false\" deprecated, please use \"disabled\" instead.')\nendif\nif host_machine.system() == 'windows'\n  if with_gles1 == 'auto'\n    with_gles1 = 'disabled'\n  endif\n  if with_gles2 == 'auto'\n    with_gles2 = 'disabled'\n  endif\nendif\nwith_opengl = get_option('opengl')\n\n# Default shared glapi off for windows, on elsewhere.\n_sg = get_option('shared-glapi')\nif _sg == 'true'\n  _sg = 'enabled'\n  warning('shared-glapi option \"true\" deprecated, please use \"enabled\" instead.')\nelif _sg == 'false'\n  _sg = 'disabled'\n  warning('shared-glapi option \"false\" deprecated, please use \"disabled\" instead.')\nendif\nif _sg == 'auto'\n  with_shared_glapi = host_machine.system() != 'windows'\nelse\n  with_shared_glapi = _sg == 'enabled'\nendif\n\n# shared-glapi is required if at least two OpenGL APIs are being built\nif not with_shared_glapi\n  if ((with_gles1 == 'enabled' and with_gles2 == 'enabled') or\n      (with_gles1 == 'enabled' and with_opengl) or\n      (with_gles2 == 'enabled' and with_opengl))\n    error('shared-glapi required for building two or more of OpenGL, OpenGL ES 1.x, OpenGL ES 2.x')\n  endif\n  with_gles1 = 'disabled'\n  with_gles2 = 'disabled'\nendif\n\n# We require OpenGL for OpenGL ES\nif not with_opengl\n  if (with_gles1 == 'enabled' or with_gles2 == 'enabled') and not with_opengl\n    error('building OpenGL ES without OpenGL is not supported.')\n  endif\n  with_gles1 = 'disabled'\n  with_gles2 = 'disabled'\nendif\n\nwith_gles1 = with_gles1 != 'disabled'\nwith_gles2 = with_gles2 != 'disabled'\nwith_any_opengl = with_opengl or with_gles1 or with_gles2\n# Only build shared_glapi if at least one OpenGL API is enabled\nwith_shared_glapi = with_shared_glapi and with_any_opengl\n\nsystem_has_kms_drm = ['openbsd', 'netbsd', 'freebsd', 'gnu/kfreebsd', 'dragonfly', 'linux', 'sunos'].contains(host_machine.system())\n\ndri_drivers = get_option('dri-drivers')\nif dri_drivers.contains('auto')\n  if system_has_kms_drm\n    # TODO: PPC, Sparc\n    if ['x86', 'x86_64'].contains(host_machine.cpu_family())\n      dri_drivers = ['i915', 'i965', 'r100', 'r200', 'nouveau']\n    elif ['arm', 'aarch64'].contains(host_machine.cpu_family())\n      dri_drivers = []\n    elif ['mips', 'mips64'].contains(host_machine.cpu_family())\n      dri_drivers = ['r100', 'r200', 'nouveau']\n    else\n      error('Unknown architecture @0@. Please pass -Ddri-drivers to set driver options. Patches gladly accepted to fix this.'.format(\n            host_machine.cpu_family()))\n    endif\n  elif ['darwin', 'windows', 'cygwin', 'haiku'].contains(host_machine.system())\n    # only swrast would make sense here, but gallium swrast is a much better default\n    dri_drivers = []\n  else\n    error('Unknown OS @0@. Please pass -Ddri-drivers to set driver options. Patches gladly accepted to fix this.'.format(\n          host_machine.system()))\n  endif\nendif\n\nwith_dri_i915 = dri_drivers.contains('i915')\nwith_dri_i965 = dri_drivers.contains('i965')\nwith_dri_r100 = dri_drivers.contains('r100')\nwith_dri_r200 = dri_drivers.contains('r200')\nwith_dri_nouveau = dri_drivers.contains('nouveau')\n\nwith_dri = dri_drivers.length() != 0\n\ngallium_drivers = get_option('gallium-drivers')\nif gallium_drivers.contains('auto')\n  if system_has_kms_drm\n    # TODO: PPC, Sparc\n    if ['x86', 'x86_64'].contains(host_machine.cpu_family())\n      gallium_drivers = [\n        'r300', 'r600', 'radeonsi', 'nouveau', 'virgl', 'svga', 'swrast',\n        'iris'\n      ]\n    elif ['arm', 'aarch64'].contains(host_machine.cpu_family())\n      gallium_drivers = [\n        'kmsro', 'v3d', 'vc4', 'freedreno', 'etnaviv', 'nouveau',\n        'tegra', 'virgl', 'lima', 'panfrost', 'swrast'\n      ]\n    elif ['mips', 'mips64'].contains(host_machine.cpu_family())\n      gallium_drivers = [\n        'r300', 'r600', 'radeonsi', 'nouveau', 'virgl', 'swrast'\n      ]\n    else\n      error('Unknown architecture @0@. Please pass -Dgallium-drivers to set driver options. Patches gladly accepted to fix this.'.format(\n            host_machine.cpu_family()))\n    endif\n  elif ['darwin', 'windows', 'cygwin', 'haiku'].contains(host_machine.system())\n    gallium_drivers = ['swrast']\n  else\n    error('Unknown OS @0@. Please pass -Dgallium-drivers to set driver options. Patches gladly accepted to fix this.'.format(\n          host_machine.system()))\n  endif\nendif\nwith_gallium_kmsro = gallium_drivers.contains('kmsro')\nwith_gallium_radeonsi = gallium_drivers.contains('radeonsi')\nwith_gallium_r300 = gallium_drivers.contains('r300')\nwith_gallium_r600 = gallium_drivers.contains('r600')\nwith_gallium_nouveau = gallium_drivers.contains('nouveau')\nwith_gallium_freedreno = gallium_drivers.contains('freedreno')\nwith_gallium_softpipe = gallium_drivers.contains('swrast')\nwith_gallium_vc4 = gallium_drivers.contains('vc4')\nwith_gallium_v3d = gallium_drivers.contains('v3d')\nwith_gallium_panfrost = gallium_drivers.contains('panfrost')\nwith_gallium_etnaviv = gallium_drivers.contains('etnaviv')\nwith_gallium_tegra = gallium_drivers.contains('tegra')\nwith_gallium_iris = gallium_drivers.contains('iris')\nwith_gallium_i915 = gallium_drivers.contains('i915')\nwith_gallium_svga = gallium_drivers.contains('svga')\nwith_gallium_virgl = gallium_drivers.contains('virgl')\nwith_gallium_swr = gallium_drivers.contains('swr')\nwith_gallium_lima = gallium_drivers.contains('lima')\nwith_gallium_zink = gallium_drivers.contains('zink')\nwith_gallium_d3d12 = gallium_drivers.contains('d3d12')\n\nwith_gallium = gallium_drivers.length() != 0\n\nif with_gallium and system_has_kms_drm\n  _glx = get_option('glx')\n  _egl = get_option('egl')\n  if _glx == 'dri' or _egl == 'enabled' or (_glx == 'disabled' and _egl != 'disabled')\n    with_dri = true\n  endif\nendif\n\n_vulkan_drivers = get_option('vulkan-drivers')\nif _vulkan_drivers.contains('auto')\n  if system_has_kms_drm\n    if host_machine.cpu_family().startswith('x86')\n      _vulkan_drivers = ['amd', 'intel', 'swrast']\n    elif ['arm', 'aarch64'].contains(host_machine.cpu_family())\n      _vulkan_drivers = ['swrast']\n    elif ['mips', 'mips64'].contains(host_machine.cpu_family())\n      _vulkan_drivers = ['amd', 'swrast']\n    else\n      error('Unknown architecture @0@. Please pass -Dvulkan-drivers to set driver options. Patches gladly accepted to fix this.'.format(\n            host_machine.cpu_family()))\n    endif\n  elif ['darwin', 'windows', 'cygwin', 'haiku'].contains(host_machine.system())\n    # No vulkan driver supports windows or macOS currently\n    _vulkan_drivers = []\n  else\n    error('Unknown OS @0@. Please pass -Dvulkan-drivers to set driver options. Patches gladly accepted to fix this.'.format(\n          host_machine.system()))\n  endif\nendif\n\nwith_intel_vk = _vulkan_drivers.contains('intel')\nwith_amd_vk = _vulkan_drivers.contains('amd')\nwith_freedreno_vk = _vulkan_drivers.contains('freedreno')\nwith_swrast_vk = _vulkan_drivers.contains('swrast')\nwith_freedreno_kgsl = get_option('freedreno-kgsl')\nwith_broadcom_vk = _vulkan_drivers.contains('broadcom')\nwith_any_vk = _vulkan_drivers.length() != 0\n\nwith_any_broadcom = with_gallium_vc4 or with_gallium_v3d or with_broadcom_vk\nwith_any_intel = with_dri_i965 or with_intel_vk or with_gallium_iris\n\nif with_swrast_vk and not with_gallium_softpipe\n  error('swrast vulkan requires gallium swrast')\nendif\nif with_dri_i915 and with_gallium_i915\n  error('Only one i915 provider can be built')\nendif\nif with_gallium_kmsro and not (with_gallium_v3d or with_gallium_vc4 or with_gallium_etnaviv or with_gallium_freedreno or with_gallium_panfrost or with_gallium_lima)\n  error('kmsro driver requires one or more renderonly drivers (vc4, etnaviv, freedreno, panfrost, lima)')\nendif\nif with_gallium_tegra and not with_gallium_nouveau\n  error('tegra driver requires nouveau driver')\nendif\nif with_aco_tests and not with_amd_vk\n  error('ACO tests require Radv')\nendif\n\ndep_clang = dependency(\n  'clang',\n  method : 'cmake',\n  static : true,\n  modules : [\n    'clangBasic', 'clangCodeGen', 'clangDriver', 'clangFrontend', 'clangFrontendTool',\n    'clangHandleCXX', 'clangHandleLLVM',\n  ],\n  required : get_option('microsoft-clc'),\n)\nwith_microsoft_clc = dep_clang.found()\nwith_clc = dep_clang.found()\n\nwith_spirv_to_dxil = get_option('spirv-to-dxil')\n\nif host_machine.system() == 'darwin'\n  with_dri_platform = 'apple'\n  pre_args += '-DBUILDING_MESA'\nelif ['windows', 'cygwin'].contains(host_machine.system())\n  with_dri_platform = 'windows'\nelif system_has_kms_drm\n  with_dri_platform = 'drm'\nelse\n  # FIXME: haiku doesn't use dri, and xlib doesn't use dri, probably should\n  # assert here that one of those cases has been met.\n  # FIXME: illumos ends up here as well\n  with_dri_platform = 'none'\nendif\n\n_platforms = get_option('platforms')\nif _platforms.contains('auto')\n  if system_has_kms_drm\n    _platforms = ['x11', 'wayland']\n  elif ['darwin', 'cygwin'].contains(host_machine.system())\n    _platforms = ['x11']\n  elif ['haiku'].contains(host_machine.system())\n    _platforms = ['haiku']\n  elif host_machine.system() == 'windows'\n    _platforms = ['windows']\n  else\n    error('Unknown OS @0@. Please pass -Dplatforms to set platforms. Patches gladly accepted to fix this.'.format(\n          host_machine.system()))\n  endif\nendif\n\nwith_platform_android = _platforms.contains('android')\nwith_platform_x11 = _platforms.contains('x11')\nwith_platform_wayland = _platforms.contains('wayland')\nwith_platform_haiku = _platforms.contains('haiku')\nwith_platform_windows = _platforms.contains('windows')\n\nif _platforms.length() != 0\n  egl_native_platform = _platforms[0]\nelse\n  egl_native_platform = 'surfaceless'\nendif\n\nwith_glx = get_option('glx')\nif with_glx == 'auto'\n  if with_platform_android\n    with_glx = 'disabled'\n  elif with_dri\n    with_glx = 'dri'\n  elif with_platform_haiku\n    with_glx = 'disabled'\n  elif host_machine.system() == 'windows'\n    with_glx = 'disabled'\n  elif with_gallium\n    # Even when building just gallium drivers the user probably wants dri\n    with_glx = 'dri'\n  elif with_platform_x11 and with_any_opengl and not with_any_vk\n    # The automatic behavior should not be to turn on xlib based glx when\n    # building only vulkan drivers\n    with_glx = 'xlib'\n  else\n    with_glx = 'disabled'\n  endif\nendif\nif with_glx == 'dri'\n   if with_gallium\n      with_dri = true\n   endif\nendif\n\nif not (with_dri or with_gallium or with_glx != 'disabled')\n  with_gles1 = false\n  with_gles2 = false\n  with_opengl = false\n  with_any_opengl = false\n  with_shared_glapi = false\nendif\n\n_gbm = get_option('gbm')\nif _gbm == 'true'\n  _gbm = 'enabled'\n  warning('gbm option \"true\" deprecated, please use \"enabled\" instead.')\nelif _gbm == 'false'\n  _gbm = 'disabled'\n  warning('gbm option \"false\" deprecated, please use \"disabled\" instead.')\nendif\nif _gbm == 'auto'\n  with_gbm = system_has_kms_drm and with_dri\nelse\n  with_gbm = _gbm == 'enabled'\nendif\nif with_gbm and not system_has_kms_drm\n  error('GBM only supports DRM/KMS platforms')\nendif\n\n_xlib_lease = get_option('xlib-lease')\nif _xlib_lease == 'true'\n  _xlib_lease = 'enabled'\n  warning('xlib_lease option \"true\" deprecated, please use \"enabled\" instead.')\nelif _xlib_lease == 'false'\n  _xlib_lease = 'disabled'\n  warning('xlib_lease option \"false\" deprecated, please use \"disabled\" instead.')\nendif\nif _xlib_lease == 'auto'\n  with_xlib_lease = with_platform_x11 and system_has_kms_drm\nelse\n  with_xlib_lease = _xlib_lease == 'enabled'\nendif\n\n_egl = get_option('egl')\nif _egl == 'true'\n  _egl = 'enabled'\n  warning('egl option \"true\" deprecated, please use \"enabled\" instead.')\nelif _egl == 'false'\n  _egl = 'disabled'\n  warning('egl option \"false\" deprecated, please use \"disabled\" instead.')\nendif\nif _egl == 'auto'\n  with_egl = (\n    not ['darwin', 'windows'].contains(host_machine.system()) and\n    with_dri and with_shared_glapi\n  )\nelif _egl == 'enabled'\n  if not with_dri and not with_platform_haiku\n    error('EGL requires dri')\n  elif not with_shared_glapi\n    error('EGL requires shared-glapi')\n  elif not ['disabled', 'dri'].contains(with_glx)\n    error('EGL requires dri, but a GLX is being built without dri')\n  elif ['darwin', 'windows'].contains(host_machine.system())\n    error('EGL is not available on Windows or MacOS')\n  endif\n  with_egl = true\nelse\n  with_egl = false\nendif\n\n# Android uses emutls for versions <= P/28. For USE_ELF_TLS we need ELF TLS.\nuse_elf_tls = false\nif not ['windows', 'freebsd', 'openbsd', 'haiku'].contains(host_machine.system()) and (not with_platform_android or get_option('platform-sdk-version') >= 29)\n  pre_args += '-DUSE_ELF_TLS'\n  use_elf_tls = true\nendif\n\nif with_glx != 'disabled'\n  if not (with_platform_x11 and with_any_opengl)\n    error('Cannot build GLX support without X11 platform support and at least one OpenGL API')\n  elif with_glx == 'gallium-xlib'\n    if not with_gallium\n      error('Gallium-xlib based GLX requires at least one gallium driver')\n    elif not with_gallium_softpipe\n      error('Gallium-xlib based GLX requires softpipe or llvmpipe.')\n    elif with_dri\n      error('gallium-xlib conflicts with any dri driver')\n    endif\n  elif with_glx == 'xlib'\n    if with_dri\n      error('xlib conflicts with any dri driver')\n    endif\n  elif with_glx == 'dri'\n    if not with_shared_glapi\n      error('dri based GLX requires shared-glapi')\n    endif\n  endif\nendif\n\nwith_glvnd = get_option('glvnd')\nglvnd_vendor_name = get_option('glvnd-vendor-name')\nif with_glvnd\n  if with_platform_windows\n    error('glvnd cannot be used on Windows')\n  elif with_glx == 'xlib' or with_glx == 'gallium-xlib'\n    error('Cannot build glvnd support for GLX that is not DRI based.')\n  elif with_glx == 'disabled' and not with_egl\n    error('glvnd requires DRI based GLX and/or EGL')\n  endif\n  if get_option('egl-lib-suffix') != ''\n    error('''EGL lib suffix can't be used with libglvnd''')\n  endif\nendif\n\nif with_vulkan_icd_dir == ''\n  with_vulkan_icd_dir = join_paths(get_option('datadir'), 'vulkan/icd.d')\nendif\n\n# GNU/Hurd includes egl_dri2, without drm.\nwith_dri2 = (with_dri or with_any_vk) and (with_dri_platform == 'drm' or\n  host_machine.system() == 'gnu')\n_dri3 = get_option('dri3')\nif _dri3 == 'true'\n  _dri3 = 'enabled'\n  warning('dri3 option \"true\" deprecated, please use \"enabled\" instead.')\nelif _dri3 == 'false'\n  _dri3 = 'disabled'\n  warning('dri3 option \"false\" deprecated, please use \"disabled\" instead.')\nendif\nif _dri3 == 'auto'\n  with_dri3 = system_has_kms_drm and with_dri2\nelse\n  with_dri3 = _dri3 == 'enabled'\nendif\n\nif with_any_vk and (with_platform_x11 and not with_dri3)\n  error('Vulkan drivers require dri3 for X11 support')\nendif\nif with_dri\n  if with_glx == 'disabled' and not with_egl and not with_gbm\n    error('building dri drivers require at least one windowing system')\n  endif\nendif\n\n_vdpau = get_option('gallium-vdpau')\nif _vdpau == 'true'\n  _vdpau = 'enabled'\n  warning('gallium-vdpau option \"true\" deprecated, please use \"enabled\" instead.')\nelif _vdpau == 'false'\n  _vdpau = 'disabled'\n  warning('gallium-vdpau option \"false\" deprecated, please use \"disabled\" instead.')\nendif\nif not system_has_kms_drm\n  if _vdpau == 'enabled'\n    error('VDPAU state tracker can only be build on unix-like OSes.')\n  else\n    _vdpau = 'disabled'\n  endif\nelif not with_platform_x11\n  if _vdpau == 'enabled'\n    error('VDPAU state tracker requires X11 support.')\n  else\n    _vdpau = 'disabled'\n  endif\nelif not (with_gallium_r300 or with_gallium_r600 or with_gallium_radeonsi or\n          with_gallium_nouveau)\n  if _vdpau == 'enabled'\n    error('VDPAU state tracker requires at least one of the following gallium drivers: r300, r600, radeonsi, nouveau.')\n  else\n    _vdpau = 'disabled'\n  endif\nendif\ndep_vdpau = null_dep\nwith_gallium_vdpau = false\nif _vdpau != 'disabled'\n  dep_vdpau = dependency('vdpau', version : '>= 1.1', required : _vdpau == 'enabled')\n  if dep_vdpau.found()\n    dep_vdpau = dep_vdpau.partial_dependency(compile_args : true)\n    with_gallium_vdpau = true\n  endif\nendif\n\nif with_gallium_vdpau\n  pre_args += '-DHAVE_ST_VDPAU'\nendif\nvdpau_drivers_path = get_option('vdpau-libs-path')\nif vdpau_drivers_path == ''\n  vdpau_drivers_path = join_paths(get_option('libdir'), 'vdpau')\nendif\n\nif with_gallium_zink\n  dep_vulkan = dependency('vulkan')\nendif\n\nif with_gallium_d3d12 or with_microsoft_clc\n  dep_dxheaders = dependency('DirectX-Headers', fallback : ['DirectX-Headers', 'dep_dxheaders'],\n    required : with_gallium_d3d12\n  ) \nendif\n\nif with_vulkan_overlay_layer or with_aco_tests\n  prog_glslang = find_program('glslangValidator')\nendif\n\n_xvmc = get_option('gallium-xvmc')\nif _xvmc == 'true'\n  _xvmc = 'enabled'\n  warning('gallium-xvmc option \"true\" deprecated, please use \"enabled\" instead.')\nelif _xvmc == 'false'\n  _xvmc = 'disabled'\n  warning('gallium-xvmc option \"false\" deprecated, please use \"disabled\" instead.')\nendif\nif not system_has_kms_drm\n  if _xvmc == 'enabled'\n    error('XVMC state tracker can only be build on unix-like OSes.')\n  else\n    _xvmc = 'disabled'\n  endif\nelif not with_platform_x11\n  if _xvmc == 'enabled'\n    error('XVMC state tracker requires X11 support.')\n  else\n    _xvmc = 'disabled'\n  endif\nelif not (with_gallium_r600 or with_gallium_nouveau)\n  if _xvmc == 'enabled'\n    error('XVMC state tracker requires at least one of the following gallium drivers: r600, nouveau.')\n  else\n    _xvmc = 'disabled'\n  endif\nendif\ndep_xvmc = null_dep\ndep_xv = null_dep\nwith_gallium_xvmc = false\nif _xvmc != 'disabled'\n  dep_xvmc = dependency('xvmc', version : '>= 1.0.6', required : _xvmc == 'enabled')\n  dep_xv = dependency('xv', required : _xvmc == 'enabled')\n  with_gallium_xvmc = dep_xvmc.found() and dep_xv.found()\nendif\n\nxvmc_drivers_path = get_option('xvmc-libs-path')\nif xvmc_drivers_path == ''\n  xvmc_drivers_path = get_option('libdir')\nendif\n\n_omx = get_option('gallium-omx')\nif not system_has_kms_drm\n  if ['auto', 'disabled'].contains(_omx)\n    _omx = 'disabled'\n  else\n    error('OMX state tracker can only be built on unix-like OSes.')\n  endif\nelif not (with_gallium_r600 or with_gallium_radeonsi or with_gallium_nouveau)\n  if ['auto', 'disabled'].contains(_omx)\n    _omx = 'disabled'\n  else\n    error('OMX state tracker requires at least one of the following gallium drivers: r600, radeonsi, nouveau.')\n  endif\nendif\nwith_gallium_omx = _omx\ndep_omx = null_dep\ndep_omx_other = []\nif ['auto', 'bellagio'].contains(_omx)\n  dep_omx = dependency(\n    'libomxil-bellagio', required : _omx == 'bellagio'\n  )\n  if dep_omx.found()\n    with_gallium_omx = 'bellagio'\n  endif\nendif\nif ['auto', 'tizonia'].contains(_omx)\n  if with_dri and with_egl\n    dep_omx = dependency(\n      'libtizonia', version : '>= 0.10.0',\n      required : _omx == 'tizonia',\n    )\n    dep_omx_other = [\n      dependency('libtizplatform', required : _omx == 'tizonia'),\n      dependency('tizilheaders', required : _omx == 'tizonia'),\n    ]\n    if dep_omx.found() and dep_omx_other[0].found() and dep_omx_other[1].found()\n      with_gallium_omx = 'tizonia'\n    endif\n  elif _omx == 'tizonia'\n    error('OMX-Tizonia state tracker requires dri and egl')\n  endif\nendif\nif _omx == 'auto'\n  with_gallium_omx = 'disabled'\nelse\n  with_gallium_omx = _omx\nendif\n\npre_args += [\n  '-DENABLE_ST_OMX_BELLAGIO=' + (with_gallium_omx == 'bellagio' ? '1' : '0'),\n  '-DENABLE_ST_OMX_TIZONIA=' + (with_gallium_omx == 'tizonia' ? '1' : '0'),\n]\n\n\nomx_drivers_path = get_option('omx-libs-path')\n\nif with_gallium_omx != 'disabled'\n  # Figure out where to put the omx driver.\n  # FIXME: this could all be vastly simplified by adding a 'defined_variable'\n  # argument to meson's get_pkgconfig_variable method.\n  if omx_drivers_path == ''\n    _omx_libdir = dep_omx.get_pkgconfig_variable('libdir')\n    _omx_drivers_dir = dep_omx.get_pkgconfig_variable('pluginsdir')\n    if _omx_libdir == get_option('libdir')\n      omx_drivers_path = _omx_drivers_dir\n    else\n      _omx_base_dir = []\n      # This will fail on windows. Does OMX run on windows?\n      _omx_libdir = _omx_libdir.split('/')\n      _omx_drivers_dir = _omx_drivers_dir.split('/')\n      foreach o : _omx_drivers_dir\n        if not _omx_libdir.contains(o)\n          _omx_base_dir += o\n        endif\n      endforeach\n      omx_drivers_path = join_paths(get_option('libdir'), _omx_base_dir)\n    endif\n  endif\nendif\n\n_va = get_option('gallium-va')\nif _va == 'true'\n  _va = 'enabled'\n  warning('gallium-va option \"true\" deprecated, please use \"enabled\" instead.')\nelif _va == 'false'\n  _va = 'disabled'\n  warning('gallium-va option \"false\" deprecated, please use \"disabled\" instead.')\nendif\nif not system_has_kms_drm\n  if _va == 'enabled'\n    error('VA state tracker can only be built on unix-like OSes.')\n  else\n    _va = 'disabled'\n  endif\nelif not (with_gallium_r600 or with_gallium_radeonsi or with_gallium_nouveau)\n  if _va == 'enabled'\n    error('VA state tracker requires at least one of the following gallium drivers: r600, radeonsi, nouveau.')\n  else\n    _va = 'disabled'\n  endif\nendif\nwith_gallium_va = false\ndep_va = null_dep\nif _va != 'disabled'\n  dep_va = dependency('libva', version : '>= 0.38.0', required : _va == 'enabled')\n  if dep_va.found()\n    dep_va_headers = dep_va.partial_dependency(compile_args : true)\n    with_gallium_va = true\n  endif\nendif\n\nva_drivers_path = get_option('va-libs-path')\nif va_drivers_path == ''\n  va_drivers_path = join_paths(get_option('libdir'), 'dri')\nendif\n\n_xa = get_option('gallium-xa')\nif _xa == 'true'\n  _xa = 'enabled'\n  warning('gallium-xa option \"true\" deprecated, please use \"enabled\" instead.')\nelif _xa == 'false'\n  _xa = 'disabled'\n  warning('gallium-xa option \"false\" deprecated, please use \"disabled\" instead.')\nendif\nif not system_has_kms_drm\n  if _xa == 'enabled'\n    error('XA state tracker can only be built on unix-like OSes.')\n  else\n    _xa = 'disabled'\n  endif\nelif not (with_gallium_nouveau or with_gallium_freedreno or with_gallium_i915\n          or with_gallium_svga)\n  if _xa == 'enabled'\n    error('XA state tracker requires at least one of the following gallium drivers: nouveau, freedreno, i915, svga.')\n  else\n    _xa = 'disabled'\n  endif\nendif\nwith_gallium_xa = _xa != 'disabled'\n\nd3d_drivers_path = get_option('d3d-drivers-path')\nif d3d_drivers_path == ''\n  d3d_drivers_path = join_paths(get_option('prefix'), get_option('libdir'), 'd3d')\nendif\n\nwith_gallium_st_nine =  get_option('gallium-nine')\nif with_gallium_st_nine\n  if not with_gallium_softpipe\n    error('The nine state tracker requires gallium softpipe/llvmpipe.')\n  elif not (with_gallium_radeonsi or with_gallium_nouveau or with_gallium_r600\n            or with_gallium_r300 or with_gallium_svga or with_gallium_i915\n            or with_gallium_iris)\n    error('The nine state tracker requires at least one non-swrast gallium driver.')\n  endif\n  if not with_dri3\n    error('Using nine with wine requires dri3')\n  endif\nendif\n_power8 = get_option('power8')\nif _power8 == 'true'\n  _power8 = 'enabled'\n  warning('power8 option \"true\" deprecated, please use \"enabled\" instead.')\nelif _power8 == 'false'\n  _power8 = 'disabled'\n  warning('power8 option \"false\" deprecated, please use \"disabled\" instead.')\nendif\nif _power8 != 'disabled'\n  # on old versions of meson the cpu family would return as ppc64le on little\n  # endian power8, this was changed in 0.48 such that the family would always\n  # be ppc64 regardless of endianness, and then the machine.endian() value\n  # should be checked. Since we support versions < 0.48 we need to use\n  # startswith.\n  if host_machine.cpu_family().startswith('ppc64') and host_machine.endian() == 'little'\n    if cc.get_id() == 'gcc' and cc.version().version_compare('< 4.8')\n      error('Altivec is not supported with gcc version < 4.8.')\n    endif\n    if cc.compiles('''\n        #include <altivec.h>\n        int main() {\n          vector unsigned char r;\n          vector unsigned int v = vec_splat_u32 (1);\n          r = __builtin_vec_vgbbd ((vector unsigned char) v);\n          return 0;\n        }''',\n        args : '-mpower8-vector',\n        name : 'POWER8 intrinsics')\n      pre_args += ['-D_ARCH_PWR8', '-mpower8-vector']\n    elif get_option('power8') == 'enabled'\n      error('POWER8 intrinsic support required but not found.')\n    endif\n  endif\nendif\n\n_opencl = get_option('gallium-opencl')\nif _opencl != 'disabled'\n  if not with_gallium\n    error('OpenCL Clover implementation requires at least one gallium driver.')\n  endif\n\n  with_clc = true\n  with_gallium_opencl = true\n  with_opencl_icd = _opencl == 'icd'\nelse\n  with_gallium_opencl = false\n  with_opencl_icd = false\nendif\n\ndep_clc = null_dep\nif with_clc\n  dep_clc = dependency('libclc')\nendif\n\ngl_pkgconfig_c_flags = []\nif with_platform_x11\n  if with_any_vk or with_egl or (with_glx == 'dri' and with_dri_platform == 'drm')\n    pre_args += '-DHAVE_X11_PLATFORM'\n    pre_args += '-DHAVE_XCB_PLATFORM'\n  endif\n  if with_glx == 'xlib' or with_glx == 'gallium-xlib'\n    pre_args += '-DUSE_XSHM'\n  else\n    pre_args += '-DGLX_INDIRECT_RENDERING'\n    if with_glx_direct\n      pre_args += '-DGLX_DIRECT_RENDERING'\n    endif\n    if with_dri_platform == 'drm'\n      pre_args += '-DGLX_USE_DRM'\n    elif with_dri_platform == 'apple'\n      pre_args += '-DGLX_USE_APPLEGL'\n    elif with_dri_platform == 'windows'\n      pre_args += '-DGLX_USE_WINDOWSGL'\n    endif\n  endif\nelse\n  pre_args += '-DEGL_NO_X11'\n  gl_pkgconfig_c_flags += '-DEGL_NO_X11'\nendif\nif with_gbm\n  pre_args += '-DHAVE_DRM_PLATFORM'\nendif\n\nwith_android_stub = get_option('android-stub')\nif with_android_stub and not with_platform_android\n  error('`-D android-stub=true` makes no sense without `-D platforms=android`')\nendif\n\nif with_platform_android\n  if not with_android_stub\n    dep_android = [\n      dependency('cutils'),\n      dependency('hardware'),\n      dependency('sync'),\n      dependency('backtrace')\n    ]\n    if get_option('platform-sdk-version') >= 26\n      dep_android += dependency('nativewindow')\n    endif\n  endif\n  pre_args += [\n    '-DHAVE_ANDROID_PLATFORM',\n    '-DANDROID',\n    '-DANDROID_API_LEVEL=' + get_option('platform-sdk-version').to_string()\n  ]\nendif\nif with_platform_haiku\n  pre_args += '-DHAVE_HAIKU_PLATFORM'\nendif\n\nprog_python = import('python').find_installation('python3')\nhas_mako = run_command(\n  prog_python, '-c',\n  '''\nfrom distutils.version import StrictVersion\nimport mako\nassert StrictVersion(mako.__version__) > StrictVersion(\"0.8.0\")\n  ''')\nif has_mako.returncode() != 0\n  error('Python (3.x) mako module >= 0.8.0 required to build mesa.')\nendif\n\nif cc.get_id() == 'gcc' and cc.version().version_compare('< 4.4.6')\n  error('When using GCC, version 4.4.6 or later is required.')\nendif\n\n# Support systems without ETIME (e.g. FreeBSD)\nif cc.get_define('ETIME', prefix : '#include <errno.h>') == ''\n  pre_args += '-DETIME=ETIMEDOUT'\nendif\n\n# Define DEBUG for debug builds only (debugoptimized is not included on this one)\nif get_option('buildtype') == 'debug'\n  pre_args += '-DDEBUG'\nendif\n\nwith_shader_cache = false\n_shader_cache = get_option('shader-cache')\nif _shader_cache == 'true'\n  _shader_cache = 'enabled'\n  warning('shader_cache option \"true\" deprecated, please use \"enabled\" instead.')\nelif _shader_cache == 'false'\n  _shader_cache = 'disabled'\n  warning('shader_cache option \"false\" deprecated, please use \"disabled\" instead.')\nendif\nif _shader_cache != 'disabled'\n  if host_machine.system() == 'windows'\n    if _shader_cache == 'enabled'\n      error('Shader Cache does not currently work on Windows')\n    endif\n  else\n    pre_args += '-DENABLE_SHADER_CACHE'\n    if not get_option('shader-cache-default')\n      pre_args += '-DSHADER_CACHE_DISABLE_BY_DEFAULT'\n    endif\n    with_shader_cache = true\n  endif\nendif\n\nif with_shader_cache \n  shader_cache_max_size = get_option('shader-cache-max-size')\n  if shader_cache_max_size != ''\n    pre_args += '-DMESA_GLSL_CACHE_MAX_SIZE=\"@0@\"'.format(shader_cache_max_size)\n  endif\nendif\n\n# Check for GCC style builtins\nforeach b : ['bswap32', 'bswap64', 'clz', 'clzll', 'ctz', 'expect', 'ffs',\n             'ffsll', 'popcount', 'popcountll', 'unreachable', 'types_compatible_p']\n  if cc.has_function(b)\n    pre_args += '-DHAVE___BUILTIN_@0@'.format(b.to_upper())\n  endif\nendforeach\n\n# check for GCC __attribute__\n_attributes = [\n  'const', 'flatten', 'malloc', 'pure', 'unused', 'warn_unused_result',\n  'weak', 'format', 'packed', 'returns_nonnull', 'alias', 'noreturn',\n]\nforeach a : cc.get_supported_function_attributes(_attributes)\n  pre_args += '-DHAVE_FUNC_ATTRIBUTE_@0@'.format(a.to_upper())\nendforeach\nif cc.has_function_attribute('visibility:hidden')\n  pre_args += '-DHAVE_FUNC_ATTRIBUTE_VISIBILITY'\nendif\nif cc.compiles('__uint128_t foo(void) { return 0; }',\n               name : '__uint128_t')\n  pre_args += '-DHAVE_UINT128'\nendif\n\n# TODO: this is very incomplete\nif ['linux', 'cygwin', 'gnu', 'freebsd', 'gnu/kfreebsd', 'haiku'].contains(host_machine.system())\n  pre_args += '-D_GNU_SOURCE'\nelif host_machine.system() == 'sunos'\n  pre_args += '-D__EXTENSIONS__'\nelif host_machine.system() == 'windows'\n  pre_args += [\n    '-D_WINDOWS', '-D_WIN32_WINNT=0x0A00', '-DWINVER=0x0A00',\n    '-DPIPE_SUBSYSTEM_WINDOWS_USER',\n    '-D_USE_MATH_DEFINES',  # XXX: scons doesn't use this for mingw\n  ]\n  if cc.get_id() == 'msvc'\n    pre_args += [\n      '-DVC_EXTRALEAN',\n      '-D_CRT_SECURE_NO_WARNINGS',\n      '-D_CRT_SECURE_NO_DEPRECATE',\n      '-D_SCL_SECURE_NO_WARNINGS',\n      '-D_SCL_SECURE_NO_DEPRECATE',\n      '-D_ALLOW_KEYWORD_MACROS',\n      '-D_HAS_EXCEPTIONS=0', # Tell C++ STL to not use exceptions\n      '-DNOMINMAX',\n    ]\n  else\n    pre_args += ['-D__MSVCRT_VERSION__=0x0700']\n  endif\nelif host_machine.system() == 'openbsd'\n  pre_args += '-D_ISOC11_SOURCE'\nendif\n\n# Check for generic C arguments\nc_args = []\nc_msvc_compat_args = []\nno_override_init_args = []\ncpp_args = []\ncpp_msvc_compat_args = []\nif cc.get_id() == 'msvc'\n  foreach a : ['/wd4018',  # signed/unsigned mismatch\n               '/wd4056',  # overflow in floating-point constant arithmetic\n               '/wd4244',  # conversion from 'type1' to 'type2', possible loss of data\n               '/wd4267',  # 'var' : conversion from 'size_t' to 'type', possible loss of data\n               '/wd4305',  # trancation from 'type1' to 'type2'\n               '/wd4351',  # new behavior: elements of array 'array' will be default initialized\n               '/wd4756',  # overflow in constant arithmetic\n               '/wd4800',  # forcing value to bool 'true' or 'false' (performance warning)\n               '/wd4996',  # disabled deprecated POSIX name warnings\n               '/wd4291',  # no matching operator delete found\n               '/wd4146',  # unary minus operator applied to unsigned type, result still unsigned\n               '/wd4200',  # nonstandard extension used: zero-sized array in struct/union\n               '/wd4624',  # destructor was implicitly defined as deleted [from LLVM]\n               '/wd4309',  # 'initializing': truncation of constant value\n               '/wd4838',  # conversion from 'int' to 'const char' requires a narrowing conversion\n               '/we4020',  # Error when passing the wrong number of parameters\n               '/we4024',  # Error when passing different type of parameter\n              ]\n    if cc.has_argument(a)\n      c_args += a\n    endif\n    if cpp.has_argument(a)\n      cpp_args += a\n    endif\n  endforeach\nelse\n  _trial = [\n    '-Werror=implicit-function-declaration',\n    '-Werror=missing-prototypes',\n    '-Werror=return-type',\n    '-Werror=empty-body',\n    '-Werror=incompatible-pointer-types',\n    '-Werror=int-conversion',\n    '-Wimplicit-fallthrough',\n    '-Wno-missing-field-initializers',\n    '-Wno-format-truncation',\n    '-fno-math-errno',\n    '-fno-trapping-math',\n    '-Qunused-arguments',\n    '-fno-common',\n  ]\n  # MinGW chokes on format specifiers and I can't get it all working\n  if not (cc.get_id() == 'gcc' and host_machine.system() == 'windows')\n    _trial += ['-Werror=format', '-Wformat-security']\n  endif\n  foreach a : _trial\n    if cc.has_argument(a)\n      c_args += a\n    endif\n  endforeach\n\n  _trial = [\n    '-Werror=return-type',\n    '-Werror=empty-body',\n    '-Wno-non-virtual-dtor',\n    '-Wno-missing-field-initializers',\n    '-Wno-format-truncation',\n    '-fno-math-errno',\n    '-fno-trapping-math',\n    '-Qunused-arguments',\n    # Some classes use custom new operator which zeroes memory, however\n    # gcc does aggressive dead-store elimination which threats all writes\n    # to the memory before the constructor as \"dead stores\".\n    # For now we disable this optimization.\n    '-flifetime-dse=1',\n  ]\n  # MinGW chokes on format specifiers and I can't get it all working\n  if not (cc.get_id() == 'gcc' and host_machine.system() == 'windows')\n    _trial += ['-Werror=format', '-Wformat-security']\n  endif\n  foreach a : _trial\n    if cpp.has_argument(a)\n      cpp_args += a\n    endif\n  endforeach\n\n  foreach a : ['-Wno-override-init', '-Wno-initializer-overrides']\n    if cc.has_argument(a)\n      no_override_init_args += a\n    endif\n  endforeach\n\n  # Check for C and C++ arguments for MSVC compatibility. These are only used\n  # in parts of the mesa code base that need to compile with MSVC, mainly\n  # common code\n  foreach a : ['-Werror=pointer-arith', '-Werror=gnu-empty-initializer']\n    if cc.has_argument(a)\n      c_msvc_compat_args += a\n    endif\n    if cpp.has_argument(a)\n      cpp_msvc_compat_args += a\n    endif\n  endforeach\n\n  if cc.has_argument('-Wmicrosoft-enum-value')  # Clang\n    c_args += '-Wno-microsoft-enum-value'\n    cpp_args += '-Wno-microsoft-enum-value'\n  endif\nendif\n\n# set linker arguments\nif host_machine.system() == 'windows'\n  if cc.get_id() == 'msvc'\n    add_project_link_arguments(\n      '/fixed:no',\n      '/dynamicbase',\n      '/nxcompat',\n      language : ['c', 'cpp'],\n    )\n    if get_option('buildtype') != 'debug'\n      add_project_link_arguments(\n        '/incremental:no',\n        language : ['c', 'cpp'],\n      )\n    endif\n  else\n    add_project_link_arguments(\n      '-Wl,--nxcompat',\n      '-Wl,--dynamicbase',\n      '-static-libgcc',\n      '-static-libstdc++',\n      language : ['c', 'cpp'],\n    )\n  endif\nendif\n\nif get_option('sse2') and host_machine.system() == 'windows' and host_machine.cpu_family() == 'x86' and cc.get_id() == 'gcc'\n  # These settings make generated MinGW code match MSVC and follow\n  # GCC advice on https://gcc.gnu.org/wiki/FloatingPointMath#x86note\n  #\n  # NOTE: We need to ensure stack is realigned given that we\n  # produce shared objects, and have no control over the stack\n  # alignment policy of the application. Therefore we need\n  # -mstackrealign or -mincoming-stack-boundary=2.\n  #\n  # XXX: We could have SSE without -mstackrealign if we always used\n  # __attribute__((force_align_arg_pointer)), but that's not\n  # always the case.\n  c_args += ['-msse', '-msse2', '-mfpmath=sse', '-mstackrealign']\nendif\n\nif host_machine.cpu_family().startswith('x86') and cc.get_id() != 'msvc'\n  pre_args += '-DUSE_SSE41'\n  with_sse41 = true\n  sse41_args = ['-msse4.1']\n\n  # GCC on x86 (not x86_64) with -msse* assumes a 16 byte aligned stack, but\n  # that's not guaranteed\n  if host_machine.cpu_family() == 'x86'\n    sse41_args += '-mstackrealign'\n  endif\nelse\n  with_sse41 = false\n  sse41_args = []\nendif\n\n# Check for GCC style atomics\ndep_atomic = null_dep\n\nif cc.compiles('''#include <stdint.h>\n                  int main() {\n                    struct {\n                      uint64_t *v;\n                    } x;\n                    return (int)__atomic_load_n(x.v, __ATOMIC_ACQUIRE) &\n                           (int)__atomic_add_fetch(x.v, (uint64_t)1, __ATOMIC_ACQ_REL);\n\n                  }''',\n               name : 'GCC atomic builtins')\n  pre_args += '-DUSE_GCC_ATOMIC_BUILTINS'\n\n  # Not all atomic calls can be turned into lock-free instructions, in which\n  # GCC will make calls into the libatomic library. Check whether we need to\n  # link with -latomic.\n  #\n  # This can happen for 64-bit atomic operations on 32-bit architectures such\n  # as ARM.\n  if not cc.links('''#include <stdint.h>\n                     int main() {\n                       struct {\n                         uint64_t *v;\n                       } x;\n                       return (int)__atomic_load_n(x.v, __ATOMIC_ACQUIRE) &\n                              (int)__atomic_add_fetch(x.v, (uint64_t)1, __ATOMIC_ACQ_REL);\n                     }''',\n                  name : 'GCC atomic builtins required -latomic')\n    dep_atomic = cc.find_library('atomic')\n  endif\nendif\nif not cc.links('''#include <stdint.h>\n                   uint64_t v;\n                   int main() {\n                     return __sync_add_and_fetch(&v, (uint64_t)1);\n                   }''',\n                dependencies : dep_atomic,\n                name : 'GCC 64bit atomics')\n  pre_args += '-DMISSING_64BIT_ATOMICS'\nendif\n\ndep_ws2_32 = cc.find_library('ws2_32', required : with_platform_windows)\n\n# TODO: shared/static? Is this even worth doing?\n\nwith_asm_arch = ''\nif host_machine.cpu_family() == 'x86'\n  if system_has_kms_drm or host_machine.system() == 'gnu'\n    with_asm_arch = 'x86'\n    pre_args += ['-DUSE_X86_ASM', '-DUSE_MMX_ASM', '-DUSE_3DNOW_ASM',\n                 '-DUSE_SSE_ASM']\n\n    if with_glx_read_only_text\n      pre_args += ['-DGLX_X86_READONLY_TEXT']\n    endif\n  endif\nelif host_machine.cpu_family() == 'x86_64'\n  if system_has_kms_drm\n    with_asm_arch = 'x86_64'\n    pre_args += ['-DUSE_X86_64_ASM']\n  endif\nelif host_machine.cpu_family() == 'arm'\n  if system_has_kms_drm\n    with_asm_arch = 'arm'\n    pre_args += ['-DUSE_ARM_ASM']\n  endif\nelif host_machine.cpu_family() == 'aarch64'\n  if system_has_kms_drm\n    with_asm_arch = 'aarch64'\n    pre_args += ['-DUSE_AARCH64_ASM']\n  endif\nelif host_machine.cpu_family() == 'sparc64'\n  if system_has_kms_drm\n    with_asm_arch = 'sparc'\n    pre_args += ['-DUSE_SPARC_ASM']\n  endif\nelif host_machine.cpu_family().startswith('ppc64') and host_machine.endian() == 'little'\n  if system_has_kms_drm\n    with_asm_arch = 'ppc64le'\n    pre_args += ['-DUSE_PPC64LE_ASM']\n  endif\nendif\n\n# Check for standard headers and functions\nif (cc.has_header_symbol('sys/sysmacros.h', 'major') and\n  cc.has_header_symbol('sys/sysmacros.h', 'minor') and\n  cc.has_header_symbol('sys/sysmacros.h', 'makedev'))\n  pre_args += '-DMAJOR_IN_SYSMACROS'\nendif\nif (cc.has_header_symbol('sys/mkdev.h', 'major') and\n  cc.has_header_symbol('sys/mkdev.h', 'minor') and\n  cc.has_header_symbol('sys/mkdev.h', 'makedev'))\n  pre_args += '-DMAJOR_IN_MKDEV'\nendif\n\nif not ['linux'].contains(host_machine.system())\n  # Deprecated on Linux and requires <sys/types.h> on FreeBSD and OpenBSD\n  if cc.check_header('sys/sysctl.h', prefix : '#include <sys/types.h>')\n    pre_args += '-DHAVE_SYS_SYSCTL_H'\n  endif\nendif\n\nforeach h : ['xlocale.h', 'linux/futex.h', 'endian.h', 'dlfcn.h', 'execinfo.h', 'sys/shm.h', 'cet.h', 'pthread_np.h']\n  if cc.check_header(h)\n    pre_args += '-DHAVE_@0@'.format(h.to_upper().underscorify())\n  endif\nendforeach\n\nforeach f : ['strtof', 'mkostemp', 'timespec_get', 'memfd_create', 'random_r', 'flock', 'strtok_r', 'getrandom']\n  if cc.has_function(f)\n    pre_args += '-DHAVE_@0@'.format(f.to_upper())\n  endif\nendforeach\n\nif cc.has_header_symbol('errno.h', 'program_invocation_name',\n                        args : '-D_GNU_SOURCE')\n   pre_args += '-DHAVE_PROGRAM_INVOCATION_NAME'\nelif with_tools.contains('intel')\n  error('Intel tools require the program_invocation_name variable')\nendif\n\n# MinGW provides a __builtin_posix_memalign function, but not a posix_memalign.\n# This means that this check will succeed, but then compilation will later\n# fail. MSVC doesn't have this function at all, so only check for it on\n# non-windows platforms.\nif host_machine.system() != 'windows'\n  if cc.has_function('posix_memalign')\n    pre_args += '-DHAVE_POSIX_MEMALIGN'\n  endif\nendif\n\nif cc.has_member('struct dirent', 'd_type', prefix: '''#include <sys/types.h>\n   #include <dirent.h>''')\n   pre_args += '-DHAVE_DIRENT_D_TYPE'\nendif\n\n# strtod locale support\nif cc.links('''\n    #define _GNU_SOURCE\n    #include <stdlib.h>\n    #include <locale.h>\n    #ifdef HAVE_XLOCALE_H\n    #include <xlocale.h>\n    #endif\n    int main() {\n      locale_t loc = newlocale(LC_CTYPE_MASK, \"C\", NULL);\n      const char *s = \"1.0\";\n      char *end;\n      double d = strtod_l(s, end, loc);\n      float f = strtof_l(s, end, loc);\n      freelocale(loc);\n      return 0;\n    }''',\n    args : pre_args,\n    name : 'strtod has locale support')\n  pre_args += '-DHAVE_STRTOD_L'\nendif\n\n# Check for some linker flags\nld_args_bsymbolic = []\nif cc.links('int main() { return 0; }', args : '-Wl,-Bsymbolic', name : 'Bsymbolic')\n  ld_args_bsymbolic += '-Wl,-Bsymbolic'\nendif\nld_args_gc_sections = []\nif cc.links('static char unused() { return 5; } int main() { return 0; }',\n            args : '-Wl,--gc-sections', name : 'gc-sections')\n  ld_args_gc_sections += '-Wl,--gc-sections'\nendif\nwith_ld_version_script = false\nif cc.links('int main() { return 0; }',\n            args : '-Wl,--version-script=@0@'.format(\n              join_paths(meson.source_root(), 'build-support/conftest.map')),\n            name : 'version-script')\n  with_ld_version_script = true\nendif\nwith_ld_dynamic_list = false\nif cc.links('int main() { return 0; }',\n            args : '-Wl,--dynamic-list=@0@'.format(\n              join_paths(meson.source_root(), 'build-support/conftest.dyn')),\n            name : 'dynamic-list')\n  with_ld_dynamic_list = true\nendif\n\nld_args_build_id = cc.get_supported_link_arguments('-Wl,--build-id=sha1')\n\n# check for dl support\ndep_dl = null_dep\nif not cc.has_function('dlopen')\n  dep_dl = cc.find_library('dl', required : host_machine.system() != 'windows')\nendif\nif cc.has_function('dladdr', dependencies : dep_dl)\n  # This is really only required for megadrivers\n  pre_args += '-DHAVE_DLADDR'\nendif\n\nif cc.has_function('dl_iterate_phdr')\n  pre_args += '-DHAVE_DL_ITERATE_PHDR'\nelif with_intel_vk\n  error('Intel \"Anvil\" Vulkan driver requires the dl_iterate_phdr function')\nelif with_dri_i965 and with_shader_cache\n  error('Intel i965 GL driver requires dl_iterate_phdr when built with shader caching.')\nendif\n\n# Determine whether or not the rt library is needed for time functions\nif host_machine.system() == 'windows' or cc.has_function('clock_gettime')\n  dep_clock = null_dep\nelse\n  dep_clock = cc.find_library('rt')\nendif\n\ndep_zlib = dependency('zlib', version : '>= 1.2.3',\n                      fallback : ['zlib', 'zlib_dep'],\n                      required : get_option('zlib'))\nif dep_zlib.found()\n  pre_args += '-DHAVE_ZLIB'\nendif\n\n_zstd = get_option('zstd')\nif _zstd == 'true'\n  _zstd = 'enabled'\n  warning('zstd option \"true\" deprecated, please use \"enabled\" instead.')\nelif _zstd == 'false'\n  _zstd = 'disabled'\n  warning('zstd option \"false\" deprecated, please use \"disabled\" instead.')\nendif\nif _zstd != 'disabled'\n  dep_zstd = dependency('libzstd', required : _zstd == 'enabled')\n  if dep_zstd.found()\n    pre_args += '-DHAVE_ZSTD'\n  endif\nelse\n  dep_zstd = null_dep\nendif\n\ndep_thread = dependency('threads')\nif dep_thread.found() and host_machine.system() != 'windows'\n  pre_args += '-DHAVE_PTHREAD'\n  if host_machine.system() != 'netbsd' and cc.has_function(\n      'pthread_setaffinity_np',\n      dependencies : dep_thread,\n      prefix : '#include <pthread.h>',\n      args : '-D_GNU_SOURCE')\n    pre_args += '-DHAVE_PTHREAD_SETAFFINITY'\n  endif\nendif\nif host_machine.system() == 'darwin'\n  dep_expat = meson.get_compiler('c').find_library('expat')\nelif host_machine.system() != 'windows'\n  dep_expat = dependency('expat', fallback : ['expat', 'expat_dep'],\n                         required: not with_platform_android or with_any_broadcom or with_any_intel)\nelse\n  dep_expat = null_dep\nendif\n# this only exists on linux so either this is linux and it will be found, or\n# it's not linux and wont\ndep_m = cc.find_library('m', required : false)\n\nif with_platform_haiku\n  dep_network = cc.find_library('network')\nendif\n\n# Check for libdrm. Various drivers have different libdrm version requirements,\n# but we always want to use the same version for all libdrm modules. That means\n# even if driver foo requires 2.4.0 and driver bar requires 2.4.3, if foo and\n# bar are both on use 2.4.3 for both of them\ndep_libdrm_amdgpu = null_dep\ndep_libdrm_radeon = null_dep\ndep_libdrm_nouveau = null_dep\ndep_libdrm_intel = null_dep\n\n_drm_amdgpu_ver = '2.4.100'\n_drm_radeon_ver = '2.4.71'\n_drm_nouveau_ver = '2.4.102'\n_drm_intel_ver = '2.4.75'\n_drm_ver = '2.4.81'\n\n_libdrm_checks = [\n  ['intel', with_dri_i915 or with_gallium_i915],\n  ['amdgpu', with_amd_vk or with_gallium_radeonsi],\n  ['radeon', (with_gallium_radeonsi or with_dri_r100 or with_dri_r200 or\n              with_gallium_r300 or with_gallium_r600)],\n  ['nouveau', (with_gallium_nouveau or with_dri_nouveau)],\n]\n\n# VC4 only needs core libdrm support of this version, not a libdrm_vc4\n# library.\nif with_gallium_vc4\n  _drm_ver = '2.4.89'\nendif\n\n# etnaviv only needs core libdrm\nif with_gallium_etnaviv\n  _drm_ver = '2.4.89'\nendif\n\n# Loop over the enables versions and get the highest libdrm requirement for all\n# active drivers.\n_drm_blame = ''\nforeach d : _libdrm_checks\n  ver = get_variable('_drm_@0@_ver'.format(d[0]))\n  if d[1] and ver.version_compare('>' + _drm_ver)\n    _drm_ver = ver\n    _drm_blame = d[0]\n  endif\nendforeach\nif _drm_blame != ''\n  message('libdrm @0@ needed because @1@ has the highest requirement'.format(_drm_ver, _drm_blame))\nendif\n\n# Then get each libdrm module\nforeach d : _libdrm_checks\n  if d[1]\n    set_variable(\n      'dep_libdrm_' + d[0],\n      dependency('libdrm_' + d[0], version : '>=' + _drm_ver)\n    )\n  endif\nendforeach\n\nwith_gallium_drisw_kms = false\ndep_libdrm = dependency(\n  'libdrm', version : '>=' + _drm_ver,\n  # GNU/Hurd includes egl_dri2, without drm.\n  required : (with_dri2 and host_machine.system() != 'gnu') or with_dri3\n)\nif dep_libdrm.found()\n  pre_args += '-DHAVE_LIBDRM'\n  if with_dri_platform == 'drm' and with_dri\n    with_gallium_drisw_kms = true\n  endif\nendif\n\nllvm_modules = ['bitwriter', 'engine', 'mcdisassembler', 'mcjit', 'core', 'executionengine', 'scalaropts', 'transformutils', 'instcombine']\nllvm_optional_modules = ['coroutines']\nif with_amd_vk or with_gallium_radeonsi or with_gallium_r600\n  llvm_modules += ['amdgpu', 'native', 'bitreader', 'ipo']\n  if with_gallium_r600\n    llvm_modules += 'asmparser'\n  endif\nendif\nif with_gallium_opencl\n  llvm_modules += [\n    'linker', 'coverage', 'instrumentation', 'ipo', 'irreader',\n    'lto', 'option', 'objcarcopts', 'profiledata'\n  ]\n  llvm_optional_modules += ['frontendopenmp']\nendif\nif with_microsoft_clc\n  llvm_modules += ['target', 'linker', 'irreader', 'option', 'libdriver']\nendif\nif with_tests\n  llvm_modules += 'native'\nendif\n\nif with_microsoft_clc\n  _llvm_version = '>= 10.0.0'\nelif with_amd_vk or with_gallium_radeonsi or with_gallium_opencl\n  _llvm_version = '>= 8.0.0'\nelif with_gallium_swr\n  _llvm_version = '>= 6.0.0'\nelse\n  _llvm_version = '>= 3.9.0'\nendif\n\n_shared_llvm = get_option('shared-llvm')\nif _shared_llvm == 'true'\n  _shared_llvm = 'enabled'\n  warning('shared_llvm option \"true\" deprecated, please use \"enabled\" instead.')\nelif _shared_llvm == 'false'\n  _shared_llvm = 'disabled'\n  warning('shared_llvm option \"false\" deprecated, please use \"disabled\" instead.')\nendif\nif _shared_llvm == 'auto'\n  _shared_llvm = (host_machine.system() != 'windows')\nelse\n  _shared_llvm = (_shared_llvm == 'enabled')\nendif\n_llvm = get_option('llvm')\nif _llvm == 'true'\n  _llvm = 'enabled'\n  warning('llvm option \"true\" deprecated, please use \"enabled\" instead.')\nelif _llvm == 'false'\n  _llvm = 'disabled'\n  warning('llvm option \"false\" deprecated, please use \"disabled\" instead.')\nendif\n\n# the cmake method can only link statically, so don't attempt to use it if we\n# want to link dynamically. Before 0.54.0 meson will try cmake even when shared\n# linking is requested, so we need to force the config-tool method to be used\n# in that case, but in 0.54.0 meson won't try the cmake method if shared\n# linking is requested.\n_llvm_method = 'auto'\nif meson.version().version_compare('< 0.54.0') and _shared_llvm\n  _llvm_method = 'config-tool'\nendif\n\ndep_llvm = null_dep\nwith_llvm = false\nif _llvm != 'disabled'\n  dep_llvm = dependency(\n    'llvm',\n    version : _llvm_version,\n    modules : llvm_modules,\n    optional_modules : llvm_optional_modules,\n    required : (\n      with_amd_vk or with_gallium_radeonsi or with_gallium_swr or\n      with_gallium_opencl or with_microsoft_clc or _llvm == 'enabled'\n    ),\n    static : not _shared_llvm,\n    method : _llvm_method,\n    fallback : ['llvm', 'dep_llvm'],\n    include_type : 'system',\n  )\n  with_llvm = dep_llvm.found()\nendif\nif with_llvm\n  pre_args += '-DLLVM_AVAILABLE'\n  pre_args += '-DMESA_LLVM_VERSION_STRING=\"@0@\"'.format(dep_llvm.version())\n  pre_args += '-DLLVM_IS_SHARED=@0@'.format(_shared_llvm.to_int())\n\n  # LLVM can be built without rtti, turning off rtti changes the ABI of C++\n  # programs, so we need to build all C++ code in mesa without rtti as well to\n  # ensure that linking works.\n  #\n  # In meson 0.51.0 we can use cmake to find LLVM in addittion to meson's\n  # builtin llvm-config based finder. A new generic variable getter method\n  # has also been added, so we'll use that if we can, to cover the cmake case.\n  if dep_llvm.type_name() == 'internal'\n    _rtti = subproject('llvm').get_variable('has_rtti', true)\n  else\n    # The CMake finder will return 'ON', the llvm-config will return 'YES'\n    _rtti = ['ON', 'YES'].contains(dep_llvm.get_variable(cmake : 'LLVM_ENABLE_RTTI', configtool: 'has-rtti'))\n  endif\n  if not _rtti\n    if with_gallium_nouveau\n      error('The Nouveau driver requires rtti. You either need to turn off nouveau or use an LLVM built with LLVM_ENABLE_RTTI.')\n    elif with_gallium_opencl\n      error('The Clover OpenCL state tracker requires rtti, you need to turn off clover or use an LLVM built with LLVM_ENABLE_RTTI.')\n    endif\n    if cc.get_id() == 'msvc'\n      cpp_args += '/GR-'\n    else\n      cpp_args += '-fno-rtti'\n    endif\n  endif\nelif with_amd_vk or with_gallium_radeonsi or with_gallium_swr\n  error('The following drivers require LLVM: Radv, RadeonSI, SWR. One of these is enabled, but LLVM is disabled.')\nelif with_gallium_opencl\n  error('The OpenCL \"Clover\" state tracker requires LLVM, but LLVM is disabled.')\nelif with_microsoft_clc\n  error('The Microsoft CLC compiler requires LLVM, but LLVM is disabled.')\nendif\n\nwith_opencl_spirv = (_opencl != 'disabled' and get_option('opencl-spirv')) or with_microsoft_clc\nif with_opencl_spirv\n  chosen_llvm_version_array = dep_llvm.version().split('.')\n  chosen_llvm_version_major = chosen_llvm_version_array[0].to_int()\n  chosen_llvm_version_minor = chosen_llvm_version_array[1].to_int()\n\n  # Require an SPIRV-LLVM-Translator version compatible with the chosen LLVM\n  # one.\n  _llvmspirvlib_version = [\n    # This first version check is still needed as maybe LLVM 8.0 was picked but\n    # we do not want to accept SPIRV-LLVM-Translator 8.0.0.1 as that version does\n    # not have the required API and those are only available starting from\n    # 8.0.1.3.\n    '>= 8.0.1.3',\n    '>= @0@.@1@'.format(chosen_llvm_version_major, chosen_llvm_version_minor),\n    '< @0@.@1@'.format(chosen_llvm_version_major, chosen_llvm_version_minor + 1) ]\n\n  dep_spirv_tools = dependency('SPIRV-Tools', required : true, version : '>= 2018.0')\n  # LLVMSPIRVLib is available at https://github.com/KhronosGroup/SPIRV-LLVM-Translator\n  dep_llvmspirvlib = dependency('LLVMSPIRVLib', required : true, version : _llvmspirvlib_version)\nelse\n  dep_spirv_tools = null_dep\n  dep_llvmspirvlib = null_dep\nendif\n\nwith_opencl_native = _opencl != 'disabled' and get_option('opencl-native')\n\nif (with_amd_vk or with_gallium_radeonsi or\n    (with_gallium_opencl and with_opencl_native) or\n    (with_gallium_r600 and with_llvm))\n  dep_elf = dependency('libelf', required : false)\n  if not dep_elf.found()\n    dep_elf = cc.find_library('elf')\n  endif\nelse\n  dep_elf = null_dep\nendif\n\ndep_glvnd = null_dep\nif with_glvnd\n  dep_glvnd = dependency('libglvnd', version : '>= 1.3.2')\n  pre_args += '-DUSE_LIBGLVND=1'\nendif\n\n_valgrind = get_option('valgrind')\nif _valgrind == 'true'\n  _valgrind = 'enabled'\n  warning('valgrind option \"true\" deprecated, please use \"enabled\" instead.')\nelif _valgrind == 'false'\n  _valgrind = 'disabled'\n  warning('valgrind option \"false\" deprecated, please use \"disabled\" instead.')\nendif\nif _valgrind != 'disabled'\n  dep_valgrind = dependency('valgrind', required : _valgrind == 'enabled')\n  if dep_valgrind.found()\n    pre_args += '-DHAVE_VALGRIND'\n  endif\nelse\n  dep_valgrind = null_dep\nendif\n\n# AddressSanitizer's leak reports need all the symbols to be present at exit to\n# decode well, which runs afoul of our dlopen()/dlclose()ing of the DRI drivers.\n# Set a flag so we can skip the dlclose for asan builds.\nif ['address', 'address,undefined'].contains(get_option('b_sanitize'))\n  asan_c_args = ['-DBUILT_WITH_ASAN=1']\nelse\n  asan_c_args = ['-DBUILT_WITH_ASAN=0']\nendif\n\nif host_machine.system() == 'windows'\n  # Prefer the winflexbison versions, they're much easier to install and have\n  # better windows support.\n\n  prog_flex = find_program('win_flex', required : false)\n  if prog_flex.found()\n    # windows compatibility (uses <io.h> instead of <unistd.h> and _isatty,\n    # _fileno functions)\n    prog_flex = [prog_flex, '--wincompat', '-D__STDC_VERSION__=199901']\n  else\n    prog_flex = [find_program('flex', 'lex', required : with_any_opengl)]\n  endif\n  # Force flex to use const keyword in prototypes, as relies on __cplusplus or\n  # __STDC__ macro to determine whether it's safe to use const keyword, but\n  # MSVC never defines __STDC__ unless we disable all MSVC extensions.\n  prog_flex += '-DYY_USE_CONST='\n\n  prog_bison = find_program('win_bison', required : false)\n  if not prog_bison.found()\n    prog_bison = find_program('bison', 'yacc', required : with_any_opengl)\n  endif\nelse\n  prog_bison = find_program('bison', required : with_any_opengl)\n\n  # Disable deprecated keyword warnings, since we have to use them for\n  # old-bison compat.  See discussion in\n  # https://gitlab.freedesktop.org/mesa/mesa/merge_requests/2161\n  if find_program('bison', required : false, version : '> 2.3').found()\n    prog_bison = [prog_bison, '-Wno-deprecated']\n  endif\n\n  prog_flex = find_program('flex', required : with_any_opengl)\nendif\n\ndep_selinux = null_dep\nif get_option('selinux')\n  dep_selinux = dependency('libselinux')\n  pre_args += '-DMESA_SELINUX'\nendif\n\n_libunwind = get_option('libunwind')\nif _libunwind == 'true'\n  _libunwind = 'enabled'\n  warning('libunwind option \"true\" deprecated, please use \"enabled\" instead.')\nelif _libunwind == 'false'\n  _libunwind = 'disabled'\n  warning('libunwind option \"false\" deprecated, please use \"disabled\" instead.')\nendif\nif _libunwind != 'disabled' and not with_platform_android\n  if host_machine.system() == 'darwin'\n    dep_unwind = meson.get_compiler('c').find_library('System')\n  else\n    dep_unwind = dependency('libunwind', required : _libunwind == 'enabled')\n  endif\n  if dep_unwind.found()\n    pre_args += '-DHAVE_LIBUNWIND'\n  endif\nelse\n  dep_unwind = null_dep\nendif\n\nif with_osmesa\n  if not with_gallium_softpipe\n    error('OSMesa gallium requires gallium softpipe or llvmpipe.')\n  endif\n  if host_machine.system() == 'windows'\n    osmesa_lib_name = 'osmesa'\n  else\n    osmesa_lib_name = 'OSMesa'\n  endif\n  osmesa_bits = get_option('osmesa-bits')\n  if osmesa_bits != '8'\n    if with_dri or with_glx != 'disabled'\n      error('OSMesa bits must be 8 if building glx or dri based drivers')\n    endif\n    osmesa_lib_name = osmesa_lib_name + osmesa_bits\n    pre_args += [\n      '-DCHAN_BITS=@0@'.format(osmesa_bits), '-DDEFAULT_SOFTWARE_DEPTH_BITS=31'\n    ]\n  endif\nendif\n\n# TODO: symbol mangling\n\nif with_platform_wayland\n  dep_wl_scanner = dependency('wayland-scanner', native: true)\n  prog_wl_scanner = find_program(dep_wl_scanner.get_pkgconfig_variable('wayland_scanner'))\n  if dep_wl_scanner.version().version_compare('>= 1.15')\n    wl_scanner_arg = 'private-code'\n  else\n    wl_scanner_arg = 'code'\n  endif\n  dep_wl_protocols = dependency('wayland-protocols', version : '>= 1.8')\n  dep_wayland_client = dependency('wayland-client', version : '>=1.18')\n  dep_wayland_server = dependency('wayland-server', version : '>=1.18')\n  if with_egl\n    dep_wayland_egl = dependency('wayland-egl-backend', version : '>= 3')\n    dep_wayland_egl_headers = dep_wayland_egl.partial_dependency(compile_args : true)\n  endif\n  wayland_dmabuf_xml = join_paths(\n    dep_wl_protocols.get_pkgconfig_variable('pkgdatadir'), 'unstable',\n    'linux-dmabuf', 'linux-dmabuf-unstable-v1.xml'\n  )\n  pre_args += ['-DHAVE_WAYLAND_PLATFORM', '-DWL_HIDE_DEPRECATED']\nendif\n\ndep_x11 = null_dep\ndep_xext = null_dep\ndep_xfixes = null_dep\ndep_x11_xcb = null_dep\ndep_xcb = null_dep\ndep_xcb_glx = null_dep\ndep_xcb_dri2 = null_dep\ndep_xcb_dri3 = null_dep\ndep_dri2proto = null_dep\ndep_glproto = null_dep\ndep_xxf86vm = null_dep\ndep_xcb_dri3 = null_dep\ndep_xcb_present = null_dep\ndep_xcb_sync = null_dep\ndep_xcb_xfixes = null_dep\ndep_xshmfence = null_dep\ndep_xcb_xrandr = null_dep\ndep_xcb_shm = null_dep\ndep_xlib_xrandr = null_dep\nif with_platform_x11\n  if with_glx == 'xlib' or with_glx == 'gallium-xlib'\n    dep_x11 = dependency('x11')\n    dep_xext = dependency('xext')\n    dep_xcb = dependency('xcb')\n  elif with_glx == 'dri'\n    dep_x11 = dependency('x11')\n    dep_xext = dependency('xext')\n    dep_xfixes = dependency('xfixes', version : '>= 2.0')\n    dep_xcb_glx = dependency('xcb-glx', version : '>= 1.8.1')\n    dep_xcb_shm = dependency('xcb-shm')\n  endif\n  if (with_any_vk or with_glx == 'dri' or with_egl or\n       (with_gallium_vdpau or with_gallium_xvmc or with_gallium_va or\n        with_gallium_omx != 'disabled'))\n    dep_xcb = dependency('xcb')\n    dep_x11_xcb = dependency('x11-xcb')\n    if with_dri_platform == 'drm' and not dep_libdrm.found()\n      error('libdrm required for gallium video statetrackers when using x11')\n    endif\n  endif\n  if with_any_vk or with_egl or (with_glx == 'dri' and with_dri_platform == 'drm')\n    dep_xcb_dri2 = dependency('xcb-dri2', version : '>= 1.8')\n\n    if with_dri3\n      pre_args += '-DHAVE_DRI3'\n      dep_xcb_dri3 = dependency('xcb-dri3')\n      dep_xcb_present = dependency('xcb-present')\n      # until xcb-dri3 has been around long enough to make a hard-dependency:\n      if (dep_xcb_dri3.version().version_compare('>= 1.13') and\n          dep_xcb_present.version().version_compare('>= 1.13'))\n        pre_args += '-DHAVE_DRI3_MODIFIERS'\n      endif\n      dep_xcb_sync = dependency('xcb-sync')\n      dep_xshmfence = dependency('xshmfence', version : '>= 1.1')\n    endif\n  endif\n  if with_glx == 'dri' or with_glx == 'gallium-xlib'\n    dep_glproto = dependency('glproto', version : '>= 1.4.14')\n  endif\n  if with_glx == 'dri'\n    if with_dri_platform == 'drm'\n      dep_dri2proto = dependency('dri2proto', version : '>= 2.8')\n      if with_glx_direct\n        dep_xxf86vm = dependency('xxf86vm')\n      endif\n    endif\n  endif\n  if (with_egl or\n      with_dri3 or (\n      with_gallium_vdpau or with_gallium_xvmc or with_gallium_xa or\n      with_gallium_omx != 'disabled'))\n    dep_xcb_xfixes = dependency('xcb-xfixes')\n  endif\n  if with_xlib_lease\n    dep_xcb_xrandr = dependency('xcb-randr')\n    dep_xlib_xrandr = dependency('xrandr', version : '>= 1.3')\n  endif\nendif\n\nif get_option('gallium-extra-hud')\n  pre_args += '-DHAVE_GALLIUM_EXTRA_HUD=1'\nendif\n\n_sensors = get_option('lmsensors')\nif _sensors == 'true'\n  _sensors = 'enabled'\n  warning('lmsensors option \"true\" deprecated, please use \"enabled\" instead.')\nelif _sensors == 'false'\n  _sensors = 'disabled'\n  warning('lmsensors option \"false\" deprecated, please use \"disabled\" instead.')\nendif\nif _sensors != 'disabled'\n  dep_lmsensors = cc.find_library('sensors', required : _sensors == 'enabled')\n  if dep_lmsensors.found()\n    pre_args += '-DHAVE_LIBSENSORS=1'\n  endif\nelse\n  dep_lmsensors = null_dep\nendif\n\n# If the compiler supports it, put function and data symbols in their\n# own sections and GC the sections after linking.  This lets drivers\n# drop shared code unused by that specific driver (particularly\n# relevant for Vulkan drivers).\nif cc.has_link_argument('-Wl,--gc-sections')\n  foreach a: ['-ffunction-sections', '-fdata-sections']\n    if cc.has_argument(a)\n      add_project_arguments(a, language : ['c', 'cpp'])\n    endif\n  endforeach\nendif\n\nforeach a : pre_args\n  add_project_arguments(a, language : ['c', 'cpp'])\nendforeach\nforeach a : c_args\n  add_project_arguments(a, language : ['c'])\nendforeach\nforeach a : cpp_args\n  add_project_arguments(a, language : ['cpp'])\nendforeach\n\ngl_priv_reqs = []\n\nif with_glx == 'xlib' or with_glx == 'gallium-xlib'\n  gl_priv_reqs += ['x11', 'xext', 'xcb']\nelif with_glx == 'dri'\n  gl_priv_reqs += [\n    'x11', 'xext', 'xfixes', 'x11-xcb', 'xcb',\n    'xcb-glx >= 1.8.1']\n  if with_dri_platform == 'drm'\n    gl_priv_reqs += 'xcb-dri2 >= 1.8'\n    if with_glx_direct\n      gl_priv_reqs += 'xxf86vm'\n    endif\n  endif\nendif\nif dep_libdrm.found()\n  gl_priv_reqs += 'libdrm >= 2.4.75'\nendif\n\ngl_priv_libs = []\nif dep_thread.found()\n  gl_priv_libs += ['-lpthread', '-pthread']\nendif\nif dep_m.found()\n  gl_priv_libs += '-lm'\nendif\nif dep_dl.found()\n  gl_priv_libs += '-ldl'\nendif\n\n# FIXME: autotools lists this as incomplete\ngbm_priv_libs = []\nif dep_dl.found()\n  gbm_priv_libs += '-ldl'\nendif\n\npkg = import('pkgconfig')\n\nif host_machine.system() == 'windows'\n  prog_dumpbin = find_program('dumpbin', required : false)\n  with_symbols_check = prog_dumpbin.found() and with_tests\n  symbols_check_args = ['--dumpbin', prog_dumpbin.path()]\nelse\n  prog_nm = find_program('nm')\n  with_symbols_check = with_tests\n  symbols_check_args = ['--nm', prog_nm.path()]\nendif\n\n# This quirk needs to be applied to sources with functions defined in assembly\n# as GCC LTO drops them. See: https://bugs.freedesktop.org/show_bug.cgi?id=109391\ngcc_lto_quirk = (cc.get_id() == 'gcc') ? ['-fno-lto'] : []\n\nsubdir('include')\nsubdir('bin')\nsubdir('src')\n\n# Meson 0.49 and earlier seems to have a bug that fails to evaluate the string-\n# formatting below unless the first argument is passed as a variable. This has\n# been fixed in Meson 0.50 and beyond, but we need to keep it like this for now\n# for backwards compatibility.\n_with_opengl_string = with_opengl ? 'yes' : 'no'\n\nlines = ['',\n  'prefix:          ' + get_option('prefix'),\n  'libdir:          ' + get_option('libdir'),\n  'includedir:      ' + get_option('includedir'),\n  '',\n  'OpenGL:          @0@ (ES1: @1@ ES2: @2@)'.format(_with_opengl_string,\n                                                    with_gles1 ? 'yes' : 'no',\n                                                    with_gles2 ? 'yes' : 'no'),\n]\n\nif with_osmesa\n  lines += ''\n  lines += 'OSMesa:          lib' + osmesa_lib_name\nelse\n  lines += 'OSMesa:          no'\nendif\n\nif with_dri\n  lines += ''\n  lines += 'DRI platform:    ' + with_dri_platform\n  if dri_drivers.length() != 0 and dri_drivers != ['']\n    lines += 'DRI drivers:     ' + ' '.join(dri_drivers)\n  else\n    lines += 'DRI drivers:     no'\n  endif\n  lines += 'DRI driver dir:  ' + dri_drivers_path\nendif\n\nif with_glx != 'disabled'\n  lines += ''\n  if with_glx == 'dri'\n    lines += 'GLX:             DRI-based'\n  elif with_glx == 'xlib'\n    lines += 'GLX:             Xlib-based'\n  elif with_glx == 'gallium-xlib'\n    lines += 'GLX:             Xlib-based (Gallium)'\n  else\n    lines += 'GLX:             ' + with_glx\n  endif\nendif\n\nlines += ''\nlines += 'EGL:             ' + (with_egl ? 'yes' : 'no')\nif with_egl\n  egl_drivers = []\n  if with_dri\n    egl_drivers += 'builtin:egl_dri2'\n  endif\n  if with_dri3\n    egl_drivers += 'builtin:egl_dri3'\n  endif\n  lines += 'EGL drivers:     ' + ' '.join(egl_drivers)\nendif\nlines += 'GBM:             ' + (with_gbm ? 'yes' : 'no')\nif with_egl or with_any_vk\n  _platforms += 'surfaceless'\n  if with_gbm\n    _platforms += 'drm'\n  endif\n  lines += 'EGL/Vulkan/VL platforms:   ' + ' '.join(_platforms)\nendif\n\nlines += ''\nif with_any_vk\n  lines += 'Vulkan drivers:  ' + ' '.join(_vulkan_drivers)\n  lines += 'Vulkan ICD dir:  ' + with_vulkan_icd_dir\nelse\n  lines += 'Vulkan drivers:  no'\nendif\n\nlines += ''\nif with_llvm\n  lines += 'llvm:            yes'\n  lines += 'llvm-version:    ' + dep_llvm.version()\nelse\n  lines += 'llvm:            no'\nendif\n\nlines += ''\nif with_gallium\n  lines += 'Gallium drivers: ' + ' '.join(gallium_drivers)\n  gallium_st = ['mesa']\n  if with_gallium_xa\n    gallium_st += 'xa'\n  endif\n  if with_gallium_xvmc\n    gallium_st += 'xvmc'\n  endif\n  if with_gallium_xvmc\n    gallium_st += 'xvmc'\n  endif\n  if with_gallium_vdpau\n    gallium_st += 'vdpau'\n  endif\n  if with_gallium_omx != 'disabled'\n    gallium_st += 'omx' + with_gallium_omx\n  endif\n  if with_gallium_va\n    gallium_st += 'va'\n  endif\n  if with_gallium_st_nine\n    gallium_st += 'nine'\n  endif\n  if with_gallium_opencl\n    gallium_st += 'clover'\n  endif\n  lines += 'Gallium st:      ' + ' '.join(gallium_st)\nelse\n  lines += 'Gallium:         no'\nendif\n\nlines += 'HUD lmsensors:   ' + (dep_lmsensors.found() ? 'yes' : 'no')\n\nlines += ''\nlines += 'Shared-glapi:    ' + (with_shared_glapi ? 'yes' : 'no')\n\n\nindent = '        '\nsummary = indent + ('\\n' + indent).join(lines)\nmessage('Configuration summary:\\n@0@\\n'.format(summary))\n",
        "/tmp/vanessa/spack-stage/spack-stage-mesa-master-nrat2nfszfps3qrvs2kywr374rcjkgv2/spack-src/src/loader/loader.c": "/*\n * Copyright (C) 2013 Rob Clark <robclark@freedesktop.org>\n * Copyright (C) 2014-2016 Emil Velikov <emil.l.velikov@gmail.com>\n * Copyright (C) 2016 Intel Corporation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice (including the next\n * paragraph) shall be included in all copies or substantial portions of the\n * Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n * Authors:\n *    Rob Clark <robclark@freedesktop.org>\n */\n\n#include <dlfcn.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <sys/param.h>\n#ifdef MAJOR_IN_MKDEV\n#include <sys/mkdev.h>\n#endif\n#ifdef MAJOR_IN_SYSMACROS\n#include <sys/sysmacros.h>\n#endif\n#include <GL/gl.h>\n#include <GL/internal/dri_interface.h>\n#include \"loader.h\"\n\n#ifdef HAVE_LIBDRM\n#include <xf86drm.h>\n#define MAX_DRM_DEVICES 64\n#ifdef USE_DRICONF\n#include \"util/xmlconfig.h\"\n#include \"util/driconf.h\"\n#endif\n#endif\n\n#include \"util/macros.h\"\n\n#define __IS_LOADER\n#include \"pci_id_driver_map.h\"\n\n/* For systems like Hurd */\n#ifndef PATH_MAX\n#define PATH_MAX 4096\n#endif\n\nstatic void default_logger(int level, const char *fmt, ...)\n{\n   if (level <= _LOADER_WARNING) {\n      va_list args;\n      va_start(args, fmt);\n      vfprintf(stderr, fmt, args);\n      va_end(args);\n   }\n}\n\nstatic loader_logger *log_ = default_logger;\n\nint\nloader_open_device(const char *device_name)\n{\n   int fd;\n#ifdef O_CLOEXEC\n   fd = open(device_name, O_RDWR | O_CLOEXEC);\n   if (fd == -1 && errno == EINVAL)\n#endif\n   {\n      fd = open(device_name, O_RDWR);\n      if (fd != -1)\n         fcntl(fd, F_SETFD, fcntl(fd, F_GETFD) | FD_CLOEXEC);\n   }\n   if (fd == -1 && errno == EACCES) {\n      log_(_LOADER_WARNING, \"failed to open %s: %s\\n\",\n           device_name, strerror(errno));\n   }\n   return fd;\n}\n\nstatic char *loader_get_kernel_driver_name(int fd)\n{\n#if HAVE_LIBDRM\n   char *driver;\n   drmVersionPtr version = drmGetVersion(fd);\n\n   if (!version) {\n      log_(_LOADER_WARNING, \"failed to get driver name for fd %d\\n\", fd);\n      return NULL;\n   }\n\n   driver = strndup(version->name, version->name_len);\n   log_(driver ? _LOADER_DEBUG : _LOADER_WARNING, \"using driver %s for %d\\n\",\n        driver, fd);\n\n   drmFreeVersion(version);\n   return driver;\n#else\n   return NULL;\n#endif\n}\n\nbool\nis_kernel_i915(int fd)\n{\n   char *kernel_driver = loader_get_kernel_driver_name(fd);\n   bool is_i915 = kernel_driver && strcmp(kernel_driver, \"i915\") == 0;\n\n   free(kernel_driver);\n   return is_i915;\n}\n\n#if defined(HAVE_LIBDRM)\nint\nloader_open_render_node(const char *name)\n{\n   drmDevicePtr devices[MAX_DRM_DEVICES], device;\n   int i, num_devices, fd = -1;\n\n   num_devices = drmGetDevices2(0, devices, MAX_DRM_DEVICES);\n   if (num_devices <= 0)\n      return -ENOENT;\n\n   for (i = 0; i < num_devices; i++) {\n      device = devices[i];\n\n      if ((device->available_nodes & (1 << DRM_NODE_RENDER)) &&\n          (device->bustype == DRM_BUS_PLATFORM)) {\n         drmVersionPtr version;\n\n         fd = loader_open_device(device->nodes[DRM_NODE_RENDER]);\n         if (fd < 0)\n            continue;\n\n         version = drmGetVersion(fd);\n         if (!version) {\n            close(fd);\n            continue;\n         }\n\n         if (strcmp(version->name, name) != 0) {\n            drmFreeVersion(version);\n            close(fd);\n            continue;\n         }\n\n         drmFreeVersion(version);\n         break;\n      }\n   }\n   drmFreeDevices(devices, num_devices);\n\n   if (i == num_devices)\n      return -ENOENT;\n\n   return fd;\n}\n\n#ifdef USE_DRICONF\nstatic const driOptionDescription __driConfigOptionsLoader[] = {\n    DRI_CONF_SECTION_INITIALIZATION\n        DRI_CONF_DEVICE_ID_PATH_TAG()\n        DRI_CONF_DRI_DRIVER()\n    DRI_CONF_SECTION_END\n};\n\nstatic char *loader_get_dri_config_driver(int fd)\n{\n   driOptionCache defaultInitOptions;\n   driOptionCache userInitOptions;\n   char *dri_driver = NULL;\n   char *kernel_driver = loader_get_kernel_driver_name(fd);\n\n   driParseOptionInfo(&defaultInitOptions, __driConfigOptionsLoader,\n                      ARRAY_SIZE(__driConfigOptionsLoader));\n   driParseConfigFiles(&userInitOptions, &defaultInitOptions, 0,\n                       \"loader\", kernel_driver, NULL, 0, NULL, 0);\n   if (driCheckOption(&userInitOptions, \"dri_driver\", DRI_STRING)) {\n      char *opt = driQueryOptionstr(&userInitOptions, \"dri_driver\");\n      /* not an empty string */\n      if (*opt)\n         dri_driver = strdup(opt);\n   }\n   driDestroyOptionCache(&userInitOptions);\n   driDestroyOptionInfo(&defaultInitOptions);\n\n   free(kernel_driver);\n   return dri_driver;\n}\n\nstatic char *loader_get_dri_config_device_id(void)\n{\n   driOptionCache defaultInitOptions;\n   driOptionCache userInitOptions;\n   char *prime = NULL;\n\n   driParseOptionInfo(&defaultInitOptions, __driConfigOptionsLoader,\n                      ARRAY_SIZE(__driConfigOptionsLoader));\n   driParseConfigFiles(&userInitOptions, &defaultInitOptions, 0,\n                       \"loader\", NULL, NULL, 0, NULL, 0);\n   if (driCheckOption(&userInitOptions, \"device_id\", DRI_STRING))\n      prime = strdup(driQueryOptionstr(&userInitOptions, \"device_id\"));\n   driDestroyOptionCache(&userInitOptions);\n   driDestroyOptionInfo(&defaultInitOptions);\n\n   return prime;\n}\n#endif\n\nstatic char *drm_construct_id_path_tag(drmDevicePtr device)\n{\n   char *tag = NULL;\n\n   if (device->bustype == DRM_BUS_PCI) {\n      if (asprintf(&tag, \"pci-%04x_%02x_%02x_%1u\",\n                   device->businfo.pci->domain,\n                   device->businfo.pci->bus,\n                   device->businfo.pci->dev,\n                   device->businfo.pci->func) < 0) {\n         return NULL;\n      }\n   } else if (device->bustype == DRM_BUS_PLATFORM ||\n              device->bustype == DRM_BUS_HOST1X) {\n      char *fullname, *name, *address;\n\n      if (device->bustype == DRM_BUS_PLATFORM)\n         fullname = device->businfo.platform->fullname;\n      else\n         fullname = device->businfo.host1x->fullname;\n\n      name = strrchr(fullname, '/');\n      if (!name)\n         name = strdup(fullname);\n      else\n         name = strdup(name + 1);\n\n      address = strchr(name, '@');\n      if (address) {\n         *address++ = '\\0';\n\n         if (asprintf(&tag, \"platform-%s_%s\", address, name) < 0)\n            tag = NULL;\n      } else {\n         if (asprintf(&tag, \"platform-%s\", name) < 0)\n            tag = NULL;\n      }\n\n      free(name);\n   }\n   return tag;\n}\n\nstatic bool drm_device_matches_tag(drmDevicePtr device, const char *prime_tag)\n{\n   char *tag = drm_construct_id_path_tag(device);\n   int ret;\n\n   if (tag == NULL)\n      return false;\n\n   ret = strcmp(tag, prime_tag);\n\n   free(tag);\n   return ret == 0;\n}\n\nstatic char *drm_get_id_path_tag_for_fd(int fd)\n{\n   drmDevicePtr device;\n   char *tag;\n\n   if (drmGetDevice2(fd, 0, &device) != 0)\n       return NULL;\n\n   tag = drm_construct_id_path_tag(device);\n   drmFreeDevice(&device);\n   return tag;\n}\n\nint loader_get_user_preferred_fd(int default_fd, bool *different_device)\n{\n   const char *dri_prime = getenv(\"DRI_PRIME\");\n   char *default_tag, *prime = NULL;\n   drmDevicePtr devices[MAX_DRM_DEVICES];\n   int i, num_devices, fd = -1;\n\n   if (dri_prime)\n      prime = strdup(dri_prime);\n#ifdef USE_DRICONF\n   else\n      prime = loader_get_dri_config_device_id();\n#endif\n\n   if (prime == NULL) {\n      *different_device = false;\n      return default_fd;\n   }\n\n   default_tag = drm_get_id_path_tag_for_fd(default_fd);\n   if (default_tag == NULL)\n      goto err;\n\n   num_devices = drmGetDevices2(0, devices, MAX_DRM_DEVICES);\n   if (num_devices <= 0)\n      goto err;\n\n   for (i = 0; i < num_devices; i++) {\n      if (!(devices[i]->available_nodes & 1 << DRM_NODE_RENDER))\n         continue;\n\n      /* two formats of DRI_PRIME are supported:\n       * \"1\": choose any other card than the card used by default.\n       * id_path_tag: (for example \"pci-0000_02_00_0\") choose the card\n       * with this id_path_tag.\n       */\n      if (!strcmp(prime,\"1\")) {\n         if (drm_device_matches_tag(devices[i], default_tag))\n            continue;\n      } else {\n         if (!drm_device_matches_tag(devices[i], prime))\n            continue;\n      }\n\n      fd = loader_open_device(devices[i]->nodes[DRM_NODE_RENDER]);\n      break;\n   }\n   drmFreeDevices(devices, num_devices);\n\n   if (i == num_devices)\n      goto err;\n\n   if (fd < 0)\n      goto err;\n\n   close(default_fd);\n\n   *different_device = !!strcmp(default_tag, prime);\n\n   free(default_tag);\n   free(prime);\n   return fd;\n\n err:\n   *different_device = false;\n\n   free(default_tag);\n   free(prime);\n   return default_fd;\n}\n#else\nint\nloader_open_render_node(const char *name)\n{\n   return -1;\n}\n\nint loader_get_user_preferred_fd(int default_fd, bool *different_device)\n{\n   *different_device = false;\n   return default_fd;\n}\n#endif\n\n#if defined(HAVE_LIBDRM)\n\nstatic bool\ndrm_get_pci_id_for_fd(int fd, int *vendor_id, int *chip_id)\n{\n   drmDevicePtr device;\n\n   if (drmGetDevice2(fd, 0, &device) != 0) {\n      log_(_LOADER_WARNING, \"MESA-LOADER: failed to retrieve device information\\n\");\n      return false;\n   }\n\n   if (device->bustype != DRM_BUS_PCI) {\n      drmFreeDevice(&device);\n      log_(_LOADER_DEBUG, \"MESA-LOADER: device is not located on the PCI bus\\n\");\n      return false;\n   }\n\n   *vendor_id = device->deviceinfo.pci->vendor_id;\n   *chip_id = device->deviceinfo.pci->device_id;\n   drmFreeDevice(&device);\n   return true;\n}\n#endif\n\n\nbool\nloader_get_pci_id_for_fd(int fd, int *vendor_id, int *chip_id)\n{\n#if HAVE_LIBDRM\n   return drm_get_pci_id_for_fd(fd, vendor_id, chip_id);\n#endif\n   return false;\n}\n\nchar *\nloader_get_device_name_for_fd(int fd)\n{\n   char *result = NULL;\n\n#if HAVE_LIBDRM\n   result = drmGetDeviceNameFromFd2(fd);\n#endif\n\n   return result;\n}\n\nstatic char *\nloader_get_pci_driver(int fd)\n{\n   int vendor_id, chip_id, i, j;\n   char *driver = NULL;\n\n   if (!loader_get_pci_id_for_fd(fd, &vendor_id, &chip_id))\n      return NULL;\n\n   for (i = 0; i < ARRAY_SIZE(driver_map); i++) {\n      if (vendor_id != driver_map[i].vendor_id)\n         continue;\n\n      if (driver_map[i].predicate && !driver_map[i].predicate(fd))\n         continue;\n\n      if (driver_map[i].num_chips_ids == -1) {\n         driver = strdup(driver_map[i].driver);\n         goto out;\n      }\n\n      for (j = 0; j < driver_map[i].num_chips_ids; j++)\n         if (driver_map[i].chip_ids[j] == chip_id) {\n            driver = strdup(driver_map[i].driver);\n            goto out;\n         }\n   }\n\nout:\n   log_(driver ? _LOADER_DEBUG : _LOADER_WARNING,\n         \"pci id for fd %d: %04x:%04x, driver %s\\n\",\n         fd, vendor_id, chip_id, driver);\n   return driver;\n}\n\nchar *\nloader_get_driver_for_fd(int fd)\n{\n   char *driver;\n\n   /* Allow an environment variable to force choosing a different driver\n    * binary.  If that driver binary can't survive on this FD, that's the\n    * user's problem, but this allows vc4 simulator to run on an i965 host,\n    * and may be useful for some touch testing of i915 on an i965 host.\n    */\n   if (geteuid() == getuid()) {\n      driver = getenv(\"MESA_LOADER_DRIVER_OVERRIDE\");\n      if (driver)\n         return strdup(driver);\n   }\n\n#if defined(HAVE_LIBDRM) && defined(USE_DRICONF)\n   driver = loader_get_dri_config_driver(fd);\n   if (driver)\n      return driver;\n#endif\n\n   driver = loader_get_pci_driver(fd);\n   if (!driver)\n      driver = loader_get_kernel_driver_name(fd);\n\n   return driver;\n}\n\nvoid\nloader_set_logger(loader_logger *logger)\n{\n   log_ = logger;\n}\n\nchar *\nloader_get_extensions_name(const char *driver_name)\n{\n   char *name = NULL;\n\n   if (asprintf(&name, \"%s_%s\", __DRI_DRIVER_GET_EXTENSIONS, driver_name) < 0)\n      return NULL;\n\n   const size_t len = strlen(name);\n   for (size_t i = 0; i < len; i++) {\n      if (name[i] == '-')\n         name[i] = '_';\n   }\n\n   return name;\n}\n\n/**\n * Opens a DRI driver using its driver name, returning the __DRIextension\n * entrypoints.\n *\n * \\param driverName - a name like \"i965\", \"radeon\", \"nouveau\", etc.\n * \\param out_driver - Address where the dlopen() return value will be stored.\n * \\param search_path_vars - NULL-terminated list of env vars that can be used\n * to override the DEFAULT_DRIVER_DIR search path.\n */\nconst struct __DRIextensionRec **\nloader_open_driver(const char *driver_name,\n                   void **out_driver_handle,\n                   const char **search_path_vars)\n{\n   char path[PATH_MAX], *search_paths, *next, *end;\n   char *get_extensions_name;\n   const struct __DRIextensionRec **extensions = NULL;\n   const struct __DRIextensionRec **(*get_extensions)(void);\n\n   search_paths = NULL;\n   if (geteuid() == getuid() && search_path_vars) {\n      for (int i = 0; search_path_vars[i] != NULL; i++) {\n         search_paths = getenv(search_path_vars[i]);\n         if (search_paths)\n            break;\n      }\n   }\n   if (search_paths == NULL)\n      search_paths = DEFAULT_DRIVER_DIR;\n\n   void *driver = NULL;\n   char *dl_error = NULL;\n   end = search_paths + strlen(search_paths);\n   for (char *p = search_paths; p < end; p = next + 1) {\n      int len;\n      next = strchr(p, ':');\n      if (next == NULL)\n         next = end;\n\n      len = next - p;\n#if USE_ELF_TLS\n      snprintf(path, sizeof(path), \"%.*s/tls/%s_dri.so\", len, p, driver_name);\n      driver = dlopen(path, RTLD_NOW | RTLD_GLOBAL);\n#endif\n      if (driver == NULL) {\n         snprintf(path, sizeof(path), \"%.*s/%s_dri.so\", len, p, driver_name);\n         driver = dlopen(path, RTLD_NOW | RTLD_GLOBAL);\n         if (driver == NULL) {\n            dl_error = dlerror();\n            log_(_LOADER_DEBUG, \"MESA-LOADER: failed to open %s: %s\\n\",\n                 path, dl_error);\n         }\n      }\n      /* not need continue to loop all paths once the driver is found */\n      if (driver != NULL)\n         break;\n   }\n\n   if (driver == NULL) {\n      log_(_LOADER_WARNING, \"MESA-LOADER: failed to open %s: %s (search paths %s)\\n\",\n           driver_name, dl_error, search_paths);\n      *out_driver_handle = NULL;\n      return NULL;\n   }\n\n   log_(_LOADER_DEBUG, \"MESA-LOADER: dlopen(%s)\\n\", path);\n\n   get_extensions_name = loader_get_extensions_name(driver_name);\n   if (get_extensions_name) {\n      get_extensions = dlsym(driver, get_extensions_name);\n      if (get_extensions) {\n         extensions = get_extensions();\n      } else {\n         log_(_LOADER_DEBUG, \"MESA-LOADER: driver does not expose %s(): %s\\n\",\n              get_extensions_name, dlerror());\n      }\n      free(get_extensions_name);\n   }\n\n   if (!extensions)\n      extensions = dlsym(driver, __DRI_DRIVER_EXTENSIONS);\n   if (extensions == NULL) {\n      log_(_LOADER_WARNING,\n           \"MESA-LOADER: driver exports no extensions (%s)\\n\", dlerror());\n      dlclose(driver);\n   }\n\n   *out_driver_handle = driver;\n   return extensions;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mesa-master-nrat2nfszfps3qrvs2kywr374rcjkgv2/spack-src/src/gallium/auxiliary/util/u_dl.c": "/**************************************************************************\n *\n * Copyright 2009 VMware, Inc.\n * Copyright 1999-2008  Brian Paul\n * All Rights Reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sub license, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL\n * THE COPYRIGHT HOLDERS, AUTHORS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n * USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * The above copyright notice and this permission notice (including the\n * next paragraph) shall be included in all copies or substantial portions\n * of the Software.\n *\n **************************************************************************/\n\n\n#include \"pipe/p_config.h\"\n#include \"pipe/p_compiler.h\"\n\n#if defined(PIPE_OS_UNIX)\n#include <dlfcn.h>\n#endif\n#if defined(PIPE_OS_WINDOWS)\n#include <windows.h>\n#endif\n\n#include \"u_dl.h\"\n#include \"u_pointer.h\"\n\n\nstruct util_dl_library *\nutil_dl_open(const char *filename)\n{\n#if defined(PIPE_OS_UNIX)\n   return (struct util_dl_library *)dlopen(filename, RTLD_LAZY | RTLD_LOCAL);\n#elif defined(PIPE_OS_WINDOWS)\n   return (struct util_dl_library *)LoadLibraryA(filename);\n#else\n   return NULL;\n#endif\n}\n\n\nutil_dl_proc\nutil_dl_get_proc_address(struct util_dl_library *library,\n                         const char *procname)\n{\n#if defined(PIPE_OS_UNIX)\n   return (util_dl_proc) pointer_to_func(dlsym((void *)library, procname));\n#elif defined(PIPE_OS_WINDOWS)\n   return (util_dl_proc)GetProcAddress((HMODULE)library, procname);\n#else\n   return (util_dl_proc)NULL;\n#endif\n}\n\n\nvoid\nutil_dl_close(struct util_dl_library *library)\n{\n#if defined(PIPE_OS_UNIX)\n   dlclose((void *)library);\n#elif defined(PIPE_OS_WINDOWS)\n   FreeLibrary((HMODULE)library);\n#else\n   (void)library;\n#endif\n}\n\n\nconst char *\nutil_dl_error(void)\n{\n#if defined(PIPE_OS_UNIX)\n   return dlerror();\n#elif defined(PIPE_OS_WINDOWS)\n   return \"unknown error\";\n#else\n   return \"unknown error\";\n#endif\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mesa-master-nrat2nfszfps3qrvs2kywr374rcjkgv2/spack-src/src/mesa/drivers/dri/common/megadriver_stub.c": "/*\n * Copyright \u00a9 2013 Intel Corporation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice (including the next\n * paragraph) shall be included in all copies or substantial portions of the\n * Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\n#include <stdio.h>\n#include \"dri_util.h\"\n#include <dlfcn.h>\n#include \"main/macros.h\"\n\n/* We need GNU extensions to dlfcn.h in order to provide backward\n * compatibility for the older DRI driver loader mechanism. (dladdr,\n * Dl_info, and RTLD_DEFAULT)\n */\n#if defined(RTLD_DEFAULT) && defined(HAVE_DLADDR)\n\n#define MEGADRIVER_STUB_MAX_EXTENSIONS 10\n#define LIB_PATH_SUFFIX \"_dri.so\"\n#define LIB_PATH_SUFFIX_LENGTH (sizeof(LIB_PATH_SUFFIX)-1)\n\n/* This is the table of extensions that the loader will dlsym() for.\n *\n * Initially it is empty for the megadriver stub, but the library\n * constructor may initialize it based on the name of the library that\n * is being loaded.\n */\nPUBLIC const __DRIextension *\n__driDriverExtensions[MEGADRIVER_STUB_MAX_EXTENSIONS] = {\n   NULL\n};\n\n/**\n * This is a constructor function for the megadriver dynamic library.\n *\n * When the driver is dlopen'ed, this function will run. It will\n * search for the name of the foo_dri.so file that was opened using\n * the dladdr function.\n *\n * After finding foo's name, it will call __driDriverGetExtensions_foo\n * and use the return to update __driDriverExtensions to enable\n * compatibility with older DRI driver loaders.\n */\n__attribute__((constructor)) static void\nmegadriver_stub_init(void)\n{\n   Dl_info info;\n   char *driver_name;\n   size_t name_len;\n   char *get_extensions_name;\n   const __DRIextension **(*get_extensions)(void);\n   const __DRIextension **extensions;\n   int i;\n\n   /* Call dladdr on __driDriverExtensions. We are really\n    * interested in the returned info.dli_fname so we can\n    * figure out the path name of the library being loaded.\n    */\n   i = dladdr((void*) __driDriverExtensions, &info);\n   if (i == 0)\n      return;\n\n   /* Search for the last '/' character in the path. */\n   driver_name = strrchr(info.dli_fname, '/');\n   if (driver_name != NULL) {\n      /* Skip '/' character */\n      driver_name++;\n   } else {\n      /* Try using the start of the path */\n      driver_name = (char*) info.dli_fname;\n   }\n\n   /* Make sure the path ends with _dri.so */\n   name_len = strlen(driver_name);\n   i = name_len - LIB_PATH_SUFFIX_LENGTH;\n   if (i < 0 || strcmp(driver_name + i, LIB_PATH_SUFFIX) != 0)\n      return;\n\n   /* Duplicate the string so we can modify it.\n    * So far we've been using info.dli_fname.\n    */\n   driver_name = strdup(driver_name);\n   if (!driver_name)\n      return;\n\n   /* The path ends with _dri.so. Chop this part of the\n    * string off. Then we'll have the driver's final name.\n    */\n   driver_name[i] = '\\0';\n\n   i = asprintf(&get_extensions_name, \"%s_%s\",\n                __DRI_DRIVER_GET_EXTENSIONS, driver_name);\n   free(driver_name);\n   if (i == -1)\n      return;\n\n   /* dlsym to get the driver's get extensions function. We\n    * don't have the dlopen handle, so we have to use\n    * RTLD_DEFAULT. It seems unlikely that the symbol will\n    * be found in another library, but this isn't optimal.\n    */\n   get_extensions = dlsym(RTLD_DEFAULT, get_extensions_name);\n   free(get_extensions_name);\n   if (!get_extensions)\n      return;\n\n   /* Use the newer DRI loader entrypoint to find extensions.\n    * We will then expose these extensions via the older\n    * __driDriverExtensions symbol.\n    */\n   extensions = get_extensions();\n\n   /* Copy the extensions into the __driDriverExtensions array\n    * we declared.\n    */\n   for (i = 0; i < ARRAY_SIZE(__driDriverExtensions); i++) {\n      __driDriverExtensions[i] = extensions[i];\n      if (extensions[i] == NULL)\n         break;\n   }\n\n   /* If the driver had more extensions than we reserved, then\n    * bail out.\n    */\n   if (i == ARRAY_SIZE(__driDriverExtensions)) {\n      __driDriverExtensions[0] = NULL;\n      fprintf(stderr, \"Megadriver stub did not reserve enough extension \"\n              \"slots.\\n\");\n      return;\n   }\n}\n\n#endif /* RTLD_DEFAULT && HAVE_DLADDR */\n\nstatic const\n__DRIconfig **stub_error_init_screen(__DRIscreen *psp)\n{\n   fprintf(stderr, \"An updated DRI driver loader (libGL.so or X Server) is \"\n           \"required for this Mesa driver.\\n\");\n   return NULL;\n}\n\n/**\n * This is a stub driDriverAPI that is referenced by dri_util.c but should\n * never be used.\n */\nconst struct __DriverAPIRec driDriverAPI = {\n   .InitScreen = stub_error_init_screen,\n};\n",
        "/tmp/vanessa/spack-stage/spack-stage-mesa-master-nrat2nfszfps3qrvs2kywr374rcjkgv2/spack-src/src/mesa/drivers/dri/common/dri_util.c": "/*\n * (C) Copyright IBM Corporation 2002, 2004\n * All Rights Reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * on the rights to use, copy, modify, merge, publish, distribute, sub\n * license, and/or sell copies of the Software, and to permit persons to whom\n * the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice (including the next\n * paragraph) shall be included in all copies or substantial portions of the\n * Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n * USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * \\file dri_util.c\n * DRI utility functions.\n *\n * This module acts as glue between GLX and the actual hardware driver.  A DRI\n * driver doesn't really \\e have to use any of this - it's optional.  But, some\n * useful stuff is done here that otherwise would have to be duplicated in most\n * drivers.\n * \n * Basically, these utility functions take care of some of the dirty details of\n * screen initialization, context creation, context binding, DRM setup, etc.\n *\n * These functions are compiled into each DRI driver so libGL.so knows nothing\n * about them.\n */\n\n\n#include <stdbool.h>\n#include \"dri_util.h\"\n#include \"utils.h\"\n#include \"util/u_endian.h\"\n#include \"util/driconf.h\"\n#include \"main/mtypes.h\"\n#include \"main/framebuffer.h\"\n#include \"main/version.h\"\n#include \"main/debug_output.h\"\n#include \"main/errors.h\"\n#include \"main/macros.h\"\n\ndriOptionDescription __dri2ConfigOptions[] = {\n      DRI_CONF_SECTION_DEBUG\n         DRI_CONF_GLX_EXTENSION_OVERRIDE()\n         DRI_CONF_INDIRECT_GL_EXTENSION_OVERRIDE()\n      DRI_CONF_SECTION_END\n\n      DRI_CONF_SECTION_PERFORMANCE\n         DRI_CONF_VBLANK_MODE(DRI_CONF_VBLANK_DEF_INTERVAL_1)\n      DRI_CONF_SECTION_END\n};\n\n/*****************************************************************/\n/** \\name Screen handling functions                              */\n/*****************************************************************/\n/*@{*/\n\nstatic void\nsetupLoaderExtensions(__DRIscreen *psp,\n\t\t      const __DRIextension **extensions)\n{\n    int i;\n\n    for (i = 0; extensions[i]; i++) {\n\tif (strcmp(extensions[i]->name, __DRI_DRI2_LOADER) == 0)\n\t    psp->dri2.loader = (__DRIdri2LoaderExtension *) extensions[i];\n\tif (strcmp(extensions[i]->name, __DRI_IMAGE_LOOKUP) == 0)\n\t    psp->dri2.image = (__DRIimageLookupExtension *) extensions[i];\n\tif (strcmp(extensions[i]->name, __DRI_USE_INVALIDATE) == 0)\n\t    psp->dri2.useInvalidate = (__DRIuseInvalidateExtension *) extensions[i];\n        if (strcmp(extensions[i]->name, __DRI_BACKGROUND_CALLABLE) == 0)\n            psp->dri2.backgroundCallable = (__DRIbackgroundCallableExtension *) extensions[i];\n\tif (strcmp(extensions[i]->name, __DRI_SWRAST_LOADER) == 0)\n\t    psp->swrast_loader = (__DRIswrastLoaderExtension *) extensions[i];\n        if (strcmp(extensions[i]->name, __DRI_IMAGE_LOADER) == 0)\n           psp->image.loader = (__DRIimageLoaderExtension *) extensions[i];\n        if (strcmp(extensions[i]->name, __DRI_MUTABLE_RENDER_BUFFER_LOADER) == 0)\n           psp->mutableRenderBuffer.loader = (__DRImutableRenderBufferLoaderExtension *) extensions[i];\n    }\n}\n\n/**\n * This pointer determines which driver API we'll use in the case of the\n * loader not passing us an explicit driver extensions list (that would,\n * itself, contain a pointer to a driver API.)\n *\n * A driver's driDriverGetExtensions_drivername() can update this pointer to\n * what it's returning, and a loader that is ignorant of createNewScreen2()\n * will get the correct driver screen created, as long as no other\n * driDriverGetExtensions() happened in between the first one and the\n * createNewScreen().\n *\n * This allows the X Server to not require the significant dri_interface.h\n * updates for doing createNewScreen2(), which would discourage backporting of\n * the X Server patches to support the new loader interface.\n */\nconst struct __DriverAPIRec *globalDriverAPI = &driDriverAPI;\n\n/**\n * This is the first entrypoint in the driver called by the DRI driver loader\n * after dlopen()ing it.\n *\n * It's used to create global state for the driver across contexts on the same\n * Display.\n */\nstatic __DRIscreen *\ndriCreateNewScreen2(int scrn, int fd,\n                    const __DRIextension **extensions,\n                    const __DRIextension **driver_extensions,\n                    const __DRIconfig ***driver_configs, void *data)\n{\n    static const __DRIextension *emptyExtensionList[] = { NULL };\n    __DRIscreen *psp;\n\n    psp = calloc(1, sizeof(*psp));\n    if (!psp)\n\treturn NULL;\n\n    /* By default, use the global driDriverAPI symbol (non-megadrivers). */\n    psp->driver = globalDriverAPI;\n\n    /* If the driver exposes its vtable through its extensions list\n     * (megadrivers), use that instead.\n     */\n    if (driver_extensions) {\n       for (int i = 0; driver_extensions[i]; i++) {\n          if (strcmp(driver_extensions[i]->name, __DRI_DRIVER_VTABLE) == 0) {\n             psp->driver =\n                ((__DRIDriverVtableExtension *)driver_extensions[i])->vtable;\n          }\n       }\n    }\n\n    setupLoaderExtensions(psp, extensions);\n\n    psp->loaderPrivate = data;\n\n    psp->extensions = emptyExtensionList;\n    psp->fd = fd;\n    psp->myNum = scrn;\n\n    /* Option parsing before ->InitScreen(), as some options apply there. */\n    driParseOptionInfo(&psp->optionInfo,\n                       __dri2ConfigOptions, ARRAY_SIZE(__dri2ConfigOptions));\n    driParseConfigFiles(&psp->optionCache, &psp->optionInfo, psp->myNum,\n                        \"dri2\", NULL, NULL, 0, NULL, 0);\n\n    *driver_configs = psp->driver->InitScreen(psp);\n    if (*driver_configs == NULL) {\n\tfree(psp);\n\treturn NULL;\n    }\n\n    struct gl_constants consts = { 0 };\n    gl_api api;\n    unsigned version;\n\n    api = API_OPENGLES2;\n    if (_mesa_override_gl_version_contextless(&consts, &api, &version))\n       psp->max_gl_es2_version = version;\n\n    api = API_OPENGL_COMPAT;\n    if (_mesa_override_gl_version_contextless(&consts, &api, &version)) {\n       psp->max_gl_core_version = version;\n       if (api == API_OPENGL_COMPAT)\n          psp->max_gl_compat_version = version;\n    }\n\n    psp->api_mask = 0;\n    if (psp->max_gl_compat_version > 0)\n       psp->api_mask |= (1 << __DRI_API_OPENGL);\n    if (psp->max_gl_core_version > 0)\n       psp->api_mask |= (1 << __DRI_API_OPENGL_CORE);\n    if (psp->max_gl_es1_version > 0)\n       psp->api_mask |= (1 << __DRI_API_GLES);\n    if (psp->max_gl_es2_version > 0)\n       psp->api_mask |= (1 << __DRI_API_GLES2);\n    if (psp->max_gl_es2_version >= 30)\n       psp->api_mask |= (1 << __DRI_API_GLES3);\n\n    return psp;\n}\n\nstatic __DRIscreen *\ndri2CreateNewScreen(int scrn, int fd,\n\t\t    const __DRIextension **extensions,\n\t\t    const __DRIconfig ***driver_configs, void *data)\n{\n   return driCreateNewScreen2(scrn, fd, extensions, NULL,\n                               driver_configs, data);\n}\n\n/** swrast driver createNewScreen entrypoint. */\nstatic __DRIscreen *\ndriSWRastCreateNewScreen(int scrn, const __DRIextension **extensions,\n                         const __DRIconfig ***driver_configs, void *data)\n{\n   return driCreateNewScreen2(scrn, -1, extensions, NULL,\n                               driver_configs, data);\n}\n\nstatic __DRIscreen *\ndriSWRastCreateNewScreen2(int scrn, const __DRIextension **extensions,\n                          const __DRIextension **driver_extensions,\n                          const __DRIconfig ***driver_configs, void *data)\n{\n   return driCreateNewScreen2(scrn, -1, extensions, driver_extensions,\n                               driver_configs, data);\n}\n\n/**\n * Destroy the per-screen private information.\n * \n * \\internal\n * This function calls __DriverAPIRec::DestroyScreen on \\p screenPrivate, calls\n * drmClose(), and finally frees \\p screenPrivate.\n */\nstatic void driDestroyScreen(__DRIscreen *psp)\n{\n    if (psp) {\n\t/* No interaction with the X-server is possible at this point.  This\n\t * routine is called after XCloseDisplay, so there is no protocol\n\t * stream open to the X-server anymore.\n\t */\n\n\tpsp->driver->DestroyScreen(psp);\n\n\tdriDestroyOptionCache(&psp->optionCache);\n\tdriDestroyOptionInfo(&psp->optionInfo);\n\n\tfree(psp);\n    }\n}\n\nstatic const __DRIextension **driGetExtensions(__DRIscreen *psp)\n{\n    return psp->extensions;\n}\n\n/*@}*/\n\n\nstatic bool\nvalidate_context_version(__DRIscreen *screen,\n                         int mesa_api,\n                         unsigned major_version,\n                         unsigned minor_version,\n                         unsigned *dri_ctx_error)\n{\n   unsigned req_version = 10 * major_version + minor_version;\n   unsigned max_version = 0;\n\n   switch (mesa_api) {\n   case API_OPENGL_COMPAT:\n      max_version = screen->max_gl_compat_version;\n      break;\n   case API_OPENGL_CORE:\n      max_version = screen->max_gl_core_version;\n      break;\n   case API_OPENGLES:\n      max_version = screen->max_gl_es1_version;\n      break;\n   case API_OPENGLES2:\n      max_version = screen->max_gl_es2_version;\n      break;\n   default:\n      max_version = 0;\n      break;\n   }\n\n   if (max_version == 0) {\n      *dri_ctx_error = __DRI_CTX_ERROR_BAD_API;\n      return false;\n   } else if (req_version > max_version) {\n      *dri_ctx_error = __DRI_CTX_ERROR_BAD_VERSION;\n      return false;\n   }\n\n   return true;\n}\n\n/*****************************************************************/\n/** \\name Context handling functions                             */\n/*****************************************************************/\n/*@{*/\n\nstatic __DRIcontext *\ndriCreateContextAttribs(__DRIscreen *screen, int api,\n                        const __DRIconfig *config,\n                        __DRIcontext *shared,\n                        unsigned num_attribs,\n                        const uint32_t *attribs,\n                        unsigned *error,\n                        void *data)\n{\n    __DRIcontext *context;\n    const struct gl_config *modes = (config != NULL) ? &config->modes : NULL;\n    void *shareCtx = (shared != NULL) ? shared->driverPrivate : NULL;\n    gl_api mesa_api;\n    struct __DriverContextConfig ctx_config;\n\n    ctx_config.major_version = 1;\n    ctx_config.minor_version = 0;\n    ctx_config.flags = 0;\n    ctx_config.attribute_mask = 0;\n    ctx_config.priority = __DRI_CTX_PRIORITY_MEDIUM;\n\n    assert((num_attribs == 0) || (attribs != NULL));\n\n    if (!(screen->api_mask & (1 << api))) {\n\t*error = __DRI_CTX_ERROR_BAD_API;\n\treturn NULL;\n    }\n\n    switch (api) {\n    case __DRI_API_OPENGL:\n\tmesa_api = API_OPENGL_COMPAT;\n\tbreak;\n    case __DRI_API_GLES:\n\tmesa_api = API_OPENGLES;\n\tbreak;\n    case __DRI_API_GLES2:\n    case __DRI_API_GLES3:\n\tmesa_api = API_OPENGLES2;\n\tbreak;\n    case __DRI_API_OPENGL_CORE:\n        mesa_api = API_OPENGL_CORE;\n        break;\n    default:\n\t*error = __DRI_CTX_ERROR_BAD_API;\n\treturn NULL;\n    }\n\n    for (unsigned i = 0; i < num_attribs; i++) {\n\tswitch (attribs[i * 2]) {\n\tcase __DRI_CTX_ATTRIB_MAJOR_VERSION:\n            ctx_config.major_version = attribs[i * 2 + 1];\n\t    break;\n\tcase __DRI_CTX_ATTRIB_MINOR_VERSION:\n\t    ctx_config.minor_version = attribs[i * 2 + 1];\n\t    break;\n\tcase __DRI_CTX_ATTRIB_FLAGS:\n\t    ctx_config.flags = attribs[i * 2 + 1];\n\t    break;\n        case __DRI_CTX_ATTRIB_RESET_STRATEGY:\n            if (attribs[i * 2 + 1] != __DRI_CTX_RESET_NO_NOTIFICATION) {\n                ctx_config.attribute_mask |=\n                    __DRIVER_CONTEXT_ATTRIB_RESET_STRATEGY;\n                ctx_config.reset_strategy = attribs[i * 2 + 1];\n            } else {\n                ctx_config.attribute_mask &=\n                    ~__DRIVER_CONTEXT_ATTRIB_RESET_STRATEGY;\n            }\n            break;\n\tcase __DRI_CTX_ATTRIB_PRIORITY:\n            ctx_config.attribute_mask |= __DRIVER_CONTEXT_ATTRIB_PRIORITY;\n\t    ctx_config.priority = attribs[i * 2 + 1];\n\t    break;\n        case __DRI_CTX_ATTRIB_RELEASE_BEHAVIOR:\n            if (attribs[i * 2 + 1] != __DRI_CTX_RELEASE_BEHAVIOR_FLUSH) {\n                ctx_config.attribute_mask |=\n                    __DRIVER_CONTEXT_ATTRIB_RELEASE_BEHAVIOR;\n                ctx_config.release_behavior = attribs[i * 2 + 1];\n            } else {\n                ctx_config.attribute_mask &=\n                    ~__DRIVER_CONTEXT_ATTRIB_RELEASE_BEHAVIOR;\n            }\n            break;\n\tdefault:\n\t    /* We can't create a context that satisfies the requirements of an\n\t     * attribute that we don't understand.  Return failure.\n\t     */\n\t    assert(!\"Should not get here.\");\n\t    *error = __DRI_CTX_ERROR_UNKNOWN_ATTRIBUTE;\n\t    return NULL;\n\t}\n    }\n\n    /* The specific Mesa driver may not support the GL_ARB_compatibilty\n     * extension or the compatibility profile.  In that case, we treat an\n     * API_OPENGL_COMPAT 3.1 as API_OPENGL_CORE. We reject API_OPENGL_COMPAT\n     * 3.2+ in any case.\n     */\n    if (mesa_api == API_OPENGL_COMPAT &&\n        ctx_config.major_version == 3 && ctx_config.minor_version == 1 &&\n        screen->max_gl_compat_version < 31)\n       mesa_api = API_OPENGL_CORE;\n\n    /* The latest version of EGL_KHR_create_context spec says:\n     *\n     *     \"If the EGL_CONTEXT_OPENGL_DEBUG_BIT_KHR flag bit is set in\n     *     EGL_CONTEXT_FLAGS_KHR, then a <debug context> will be created.\n     *     [...] This bit is supported for OpenGL and OpenGL ES contexts.\n     *\n     * No other EGL_CONTEXT_OPENGL_*_BIT is legal for an ES context.\n     *\n     * However, Mesa's EGL layer translates the context attribute\n     * EGL_CONTEXT_OPENGL_ROBUST_ACCESS into the context flag\n     * __DRI_CTX_FLAG_ROBUST_BUFFER_ACCESS.  That attribute is legal for ES\n     * (with EGL 1.5 or EGL_EXT_create_context_robustness) and GL (only with\n     * EGL 1.5).\n     *\n     * From the EGL_EXT_create_context_robustness spec:\n     *\n     *     This extension is written against the OpenGL ES 2.0 Specification\n     *     but can apply to OpenGL ES 1.1 and up.\n     *\n     * From the EGL 1.5 (2014.08.27) spec, p55:\n     *\n     *     If the EGL_CONTEXT_OPENGL_ROBUST_ACCESS attribute is set to\n     *     EGL_TRUE, a context supporting robust buffer access will be created.\n     *     OpenGL contexts must support the GL_ARB_robustness extension, or\n     *     equivalent core API functional- ity. OpenGL ES contexts must support\n     *     the GL_EXT_robustness extension, or equivalent core API\n     *     functionality.\n     */\n    if (mesa_api != API_OPENGL_COMPAT\n        && mesa_api != API_OPENGL_CORE\n        && (ctx_config.flags & ~(__DRI_CTX_FLAG_DEBUG |\n                                 __DRI_CTX_FLAG_ROBUST_BUFFER_ACCESS |\n                                 __DRI_CTX_FLAG_NO_ERROR))) {\n\t*error = __DRI_CTX_ERROR_BAD_FLAG;\n\treturn NULL;\n    }\n\n    /* There are no forward-compatible contexts before OpenGL 3.0.  The\n     * GLX_ARB_create_context spec says:\n     *\n     *     \"Forward-compatible contexts are defined only for OpenGL versions\n     *     3.0 and later.\"\n     *\n     * Forward-looking contexts are supported by silently converting the\n     * requested API to API_OPENGL_CORE.\n     *\n     * In Mesa, a debug context is the same as a regular context.\n     */\n    if ((ctx_config.flags & __DRI_CTX_FLAG_FORWARD_COMPATIBLE) != 0) {\n       mesa_api = API_OPENGL_CORE;\n    }\n\n    const uint32_t allowed_flags = (__DRI_CTX_FLAG_DEBUG\n                                    | __DRI_CTX_FLAG_FORWARD_COMPATIBLE\n                                    | __DRI_CTX_FLAG_ROBUST_BUFFER_ACCESS\n                                    | __DRI_CTX_FLAG_NO_ERROR);\n    if (ctx_config.flags & ~allowed_flags) {\n\t*error = __DRI_CTX_ERROR_UNKNOWN_FLAG;\n\treturn NULL;\n    }\n\n    if (!validate_context_version(screen, mesa_api,\n                                  ctx_config.major_version,\n                                  ctx_config.minor_version,\n                                  error))\n       return NULL;\n\n    context = calloc(1, sizeof *context);\n    if (!context) {\n\t*error = __DRI_CTX_ERROR_NO_MEMORY;\n\treturn NULL;\n    }\n\n    context->loaderPrivate = data;\n\n    context->driScreenPriv = screen;\n    context->driDrawablePriv = NULL;\n    context->driReadablePriv = NULL;\n\n    if (!screen->driver->CreateContext(mesa_api, modes, context,\n                                       &ctx_config, error, shareCtx)) {\n        free(context);\n        return NULL;\n    }\n\n    *error = __DRI_CTX_ERROR_SUCCESS;\n    return context;\n}\n\nvoid\ndriContextSetFlags(struct gl_context *ctx, uint32_t flags)\n{\n    if ((flags & __DRI_CTX_FLAG_FORWARD_COMPATIBLE) != 0)\n        ctx->Const.ContextFlags |= GL_CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT;\n    if ((flags & __DRI_CTX_FLAG_DEBUG) != 0) {\n       _mesa_set_debug_state_int(ctx, GL_DEBUG_OUTPUT, GL_TRUE);\n        ctx->Const.ContextFlags |= GL_CONTEXT_FLAG_DEBUG_BIT;\n    }\n    if ((flags & __DRI_CTX_FLAG_NO_ERROR) != 0)\n        ctx->Const.ContextFlags |= GL_CONTEXT_FLAG_NO_ERROR_BIT_KHR;\n}\n\nstatic __DRIcontext *\ndriCreateNewContextForAPI(__DRIscreen *screen, int api,\n                          const __DRIconfig *config,\n                          __DRIcontext *shared, void *data)\n{\n    unsigned error;\n\n    return driCreateContextAttribs(screen, api, config, shared, 0, NULL,\n                                   &error, data);\n}\n\nstatic __DRIcontext *\ndriCreateNewContext(__DRIscreen *screen, const __DRIconfig *config,\n                    __DRIcontext *shared, void *data)\n{\n    return driCreateNewContextForAPI(screen, __DRI_API_OPENGL,\n                                     config, shared, data);\n}\n\n/**\n * Destroy the per-context private information.\n * \n * \\internal\n * This function calls __DriverAPIRec::DestroyContext on \\p contextPrivate, calls\n * drmDestroyContext(), and finally frees \\p contextPrivate.\n */\nstatic void\ndriDestroyContext(__DRIcontext *pcp)\n{\n    if (pcp) {\n\tpcp->driScreenPriv->driver->DestroyContext(pcp);\n\tfree(pcp);\n    }\n}\n\nstatic int\ndriCopyContext(__DRIcontext *dest, __DRIcontext *src, unsigned long mask)\n{\n    (void) dest;\n    (void) src;\n    (void) mask;\n    return GL_FALSE;\n}\n\n/*@}*/\n\n\n/*****************************************************************/\n/** \\name Context (un)binding functions                          */\n/*****************************************************************/\n/*@{*/\n\nstatic void dri_get_drawable(__DRIdrawable *pdp);\nstatic void dri_put_drawable(__DRIdrawable *pdp);\n\n/**\n * This function takes both a read buffer and a draw buffer.  This is needed\n * for \\c glXMakeCurrentReadSGI or GLX 1.3's \\c glXMakeContextCurrent\n * function.\n */\nstatic int driBindContext(__DRIcontext *pcp,\n\t\t\t  __DRIdrawable *pdp,\n\t\t\t  __DRIdrawable *prp)\n{\n    /*\n    ** Assume error checking is done properly in glXMakeCurrent before\n    ** calling driUnbindContext.\n    */\n\n    if (!pcp)\n\treturn GL_FALSE;\n\n    /* Bind the drawable to the context */\n    pcp->driDrawablePriv = pdp;\n    pcp->driReadablePriv = prp;\n    if (pdp) {\n\tpdp->driContextPriv = pcp;\n\tdri_get_drawable(pdp);\n    }\n    if (prp && pdp != prp) {\n\tdri_get_drawable(prp);\n    }\n\n    return pcp->driScreenPriv->driver->MakeCurrent(pcp, pdp, prp);\n}\n\n/**\n * Unbind context.\n * \n * \\param scrn the screen.\n * \\param gc context.\n *\n * \\return \\c GL_TRUE on success, or \\c GL_FALSE on failure.\n * \n * \\internal\n * This function calls __DriverAPIRec::UnbindContext, and then decrements\n * __DRIdrawableRec::refcount which must be non-zero for a successful\n * return.\n * \n * While casting the opaque private pointers associated with the parameters\n * into their respective real types it also assures they are not \\c NULL. \n */\nstatic int driUnbindContext(__DRIcontext *pcp)\n{\n    __DRIdrawable *pdp;\n    __DRIdrawable *prp;\n\n    /*\n    ** Assume error checking is done properly in glXMakeCurrent before\n    ** calling driUnbindContext.\n    */\n\n    if (pcp == NULL)\n\treturn GL_FALSE;\n\n    /*\n    ** Call driUnbindContext before checking for valid drawables\n    ** to handle surfaceless contexts properly.\n    */\n    pcp->driScreenPriv->driver->UnbindContext(pcp);\n\n    pdp = pcp->driDrawablePriv;\n    prp = pcp->driReadablePriv;\n\n    /* already unbound */\n    if (!pdp && !prp)\n\treturn GL_TRUE;\n\n    assert(pdp);\n    if (pdp->refcount == 0) {\n\t/* ERROR!!! */\n\treturn GL_FALSE;\n    }\n\n    dri_put_drawable(pdp);\n\n    if (prp != pdp) {\n\tif (prp->refcount == 0) {\n\t    /* ERROR!!! */\n\t    return GL_FALSE;\n\t}\n\n\tdri_put_drawable(prp);\n    }\n\n    pcp->driDrawablePriv = NULL;\n    pcp->driReadablePriv = NULL;\n\n    return GL_TRUE;\n}\n\n/*@}*/\n\n\nstatic void dri_get_drawable(__DRIdrawable *pdp)\n{\n    pdp->refcount++;\n}\n\nstatic void dri_put_drawable(__DRIdrawable *pdp)\n{\n    if (pdp) {\n\tpdp->refcount--;\n\tif (pdp->refcount)\n\t    return;\n\n\tpdp->driScreenPriv->driver->DestroyBuffer(pdp);\n\tfree(pdp);\n    }\n}\n\nstatic __DRIdrawable *\ndriCreateNewDrawable(__DRIscreen *screen,\n                     const __DRIconfig *config,\n                     void *data)\n{\n    __DRIdrawable *pdraw;\n\n    assert(data != NULL);\n\n    pdraw = malloc(sizeof *pdraw);\n    if (!pdraw)\n\treturn NULL;\n\n    pdraw->loaderPrivate = data;\n\n    pdraw->driScreenPriv = screen;\n    pdraw->driContextPriv = NULL;\n    pdraw->refcount = 0;\n    pdraw->lastStamp = 0;\n    pdraw->w = 0;\n    pdraw->h = 0;\n\n    dri_get_drawable(pdraw);\n\n    if (!screen->driver->CreateBuffer(screen, pdraw, &config->modes,\n                                      GL_FALSE)) {\n       free(pdraw);\n       return NULL;\n    }\n\n    pdraw->dri2.stamp = pdraw->lastStamp + 1;\n\n    return pdraw;\n}\n\nstatic void\ndriDestroyDrawable(__DRIdrawable *pdp)\n{\n    /*\n     * The loader's data structures are going away, even if pdp itself stays\n     * around for the time being because it is currently bound. This happens\n     * when a currently bound GLX pixmap is destroyed.\n     *\n     * Clear out the pointer back into the loader's data structures to avoid\n     * accessing an outdated pointer.\n     */\n    pdp->loaderPrivate = NULL;\n\n    dri_put_drawable(pdp);\n}\n\nstatic __DRIbuffer *\ndri2AllocateBuffer(__DRIscreen *screen,\n\t\t   unsigned int attachment, unsigned int format,\n\t\t   int width, int height)\n{\n    return screen->driver->AllocateBuffer(screen, attachment, format,\n                                          width, height);\n}\n\nstatic void\ndri2ReleaseBuffer(__DRIscreen *screen, __DRIbuffer *buffer)\n{\n    screen->driver->ReleaseBuffer(screen, buffer);\n}\n\n\nstatic int\ndri2ConfigQueryb(__DRIscreen *screen, const char *var, unsigned char *val)\n{\n   if (!driCheckOption(&screen->optionCache, var, DRI_BOOL))\n      return -1;\n\n   *val = driQueryOptionb(&screen->optionCache, var);\n\n   return 0;\n}\n\nstatic int\ndri2ConfigQueryi(__DRIscreen *screen, const char *var, int *val)\n{\n   if (!driCheckOption(&screen->optionCache, var, DRI_INT) &&\n       !driCheckOption(&screen->optionCache, var, DRI_ENUM))\n      return -1;\n\n    *val = driQueryOptioni(&screen->optionCache, var);\n\n    return 0;\n}\n\nstatic int\ndri2ConfigQueryf(__DRIscreen *screen, const char *var, float *val)\n{\n   if (!driCheckOption(&screen->optionCache, var, DRI_FLOAT))\n      return -1;\n\n    *val = driQueryOptionf(&screen->optionCache, var);\n\n    return 0;\n}\n\nstatic int\ndri2ConfigQuerys(__DRIscreen *screen, const char *var, char **val)\n{\n   if (!driCheckOption(&screen->optionCache, var, DRI_STRING))\n      return -1;\n\n    *val = driQueryOptionstr(&screen->optionCache, var);\n\n    return 0;\n}\n\nstatic unsigned int\ndriGetAPIMask(__DRIscreen *screen)\n{\n    return screen->api_mask;\n}\n\n/**\n * swrast swapbuffers entrypoint.\n *\n * DRI2 implements this inside the loader with only flushes handled by the\n * driver.\n */\nstatic void\ndriSwapBuffers(__DRIdrawable *pdp)\n{\n    assert(pdp->driScreenPriv->swrast_loader);\n\n    pdp->driScreenPriv->driver->SwapBuffers(pdp);\n}\n\n/** Core interface */\nconst __DRIcoreExtension driCoreExtension = {\n    .base = { __DRI_CORE, 2 },\n\n    .createNewScreen            = NULL,\n    .destroyScreen              = driDestroyScreen,\n    .getExtensions              = driGetExtensions,\n    .getConfigAttrib            = driGetConfigAttrib,\n    .indexConfigAttrib          = driIndexConfigAttrib,\n    .createNewDrawable          = NULL,\n    .destroyDrawable            = driDestroyDrawable,\n    .swapBuffers                = driSwapBuffers, /* swrast */\n    .createNewContext           = driCreateNewContext, /* swrast */\n    .copyContext                = driCopyContext,\n    .destroyContext             = driDestroyContext,\n    .bindContext                = driBindContext,\n    .unbindContext              = driUnbindContext\n};\n\n/** DRI2 interface */\nconst __DRIdri2Extension driDRI2Extension = {\n    .base = { __DRI_DRI2, 4 },\n\n    .createNewScreen            = dri2CreateNewScreen,\n    .createNewDrawable          = driCreateNewDrawable,\n    .createNewContext           = driCreateNewContext,\n    .getAPIMask                 = driGetAPIMask,\n    .createNewContextForAPI     = driCreateNewContextForAPI,\n    .allocateBuffer             = dri2AllocateBuffer,\n    .releaseBuffer              = dri2ReleaseBuffer,\n    .createContextAttribs       = driCreateContextAttribs,\n    .createNewScreen2           = driCreateNewScreen2,\n};\n\nconst __DRIswrastExtension driSWRastExtension = {\n    .base = { __DRI_SWRAST, 4 },\n\n    .createNewScreen            = driSWRastCreateNewScreen,\n    .createNewDrawable          = driCreateNewDrawable,\n    .createNewContextForAPI     = driCreateNewContextForAPI,\n    .createContextAttribs       = driCreateContextAttribs,\n    .createNewScreen2           = driSWRastCreateNewScreen2,\n};\n\nconst __DRI2configQueryExtension dri2ConfigQueryExtension = {\n   .base = { __DRI2_CONFIG_QUERY, 2 },\n\n   .configQueryb        = dri2ConfigQueryb,\n   .configQueryi        = dri2ConfigQueryi,\n   .configQueryf        = dri2ConfigQueryf,\n   .configQuerys        = dri2ConfigQuerys,\n};\n\nconst __DRI2flushControlExtension dri2FlushControlExtension = {\n   .base = { __DRI2_FLUSH_CONTROL, 1 }\n};\n\nvoid\ndri2InvalidateDrawable(__DRIdrawable *drawable)\n{\n    drawable->dri2.stamp++;\n}\n\n/**\n * Check that the gl_framebuffer associated with dPriv is the right size.\n * Resize the gl_framebuffer if needed.\n * It's expected that the dPriv->driverPrivate member points to a\n * gl_framebuffer object.\n */\nvoid\ndriUpdateFramebufferSize(struct gl_context *ctx, const __DRIdrawable *dPriv)\n{\n   struct gl_framebuffer *fb = (struct gl_framebuffer *) dPriv->driverPrivate;\n   if (fb && (dPriv->w != fb->Width || dPriv->h != fb->Height)) {\n      _mesa_resize_framebuffer(ctx, fb, dPriv->w, dPriv->h);\n      /* if the driver needs the hw lock for ResizeBuffers, the drawable\n         might have changed again by now */\n      assert(fb->Width == dPriv->w);\n      assert(fb->Height == dPriv->h);\n   }\n}\n\n/*\n * Note: the first match is returned, which is important for formats like\n * __DRI_IMAGE_FORMAT_R8 which maps to both MESA_FORMAT_{R,L}_UNORM8\n */\nstatic const struct {\n   uint32_t    image_format;\n   mesa_format mesa_format;\n   GLenum internal_format;\n} format_mapping[] = {\n   {\n      .image_format    = __DRI_IMAGE_FORMAT_RGB565,\n      .mesa_format     =        MESA_FORMAT_B5G6R5_UNORM,\n      .internal_format =        GL_RGB565,\n   },\n   {\n      .image_format    = __DRI_IMAGE_FORMAT_ARGB1555,\n      .mesa_format     =        MESA_FORMAT_B5G5R5A1_UNORM,\n      .internal_format =        GL_RGB5_A1,\n   },\n   {\n      .image_format    = __DRI_IMAGE_FORMAT_XRGB8888,\n      .mesa_format     =        MESA_FORMAT_B8G8R8X8_UNORM,\n      .internal_format =        GL_RGB8,\n   },\n   {\n      .image_format    = __DRI_IMAGE_FORMAT_ABGR16161616F,\n      .mesa_format     =        MESA_FORMAT_RGBA_FLOAT16,\n      .internal_format =        GL_RGBA16F,\n   },\n   {\n      .image_format    = __DRI_IMAGE_FORMAT_XBGR16161616F,\n      .mesa_format     =        MESA_FORMAT_RGBX_FLOAT16,\n      .internal_format =        GL_RGBA16F,\n   },\n   {\n      .image_format    = __DRI_IMAGE_FORMAT_ARGB2101010,\n      .mesa_format     =        MESA_FORMAT_B10G10R10A2_UNORM,\n      .internal_format =        GL_RGB10_A2,\n   },\n   {\n      .image_format    = __DRI_IMAGE_FORMAT_XRGB2101010,\n      .mesa_format     =        MESA_FORMAT_B10G10R10X2_UNORM,\n      .internal_format =        GL_RGB10_A2,\n   },\n   {\n      .image_format    = __DRI_IMAGE_FORMAT_ABGR2101010,\n      .mesa_format     =        MESA_FORMAT_R10G10B10A2_UNORM,\n      .internal_format =        GL_RGB10_A2,\n   },\n   {\n      .image_format    = __DRI_IMAGE_FORMAT_XBGR2101010,\n      .mesa_format     =        MESA_FORMAT_R10G10B10X2_UNORM,\n      .internal_format =        GL_RGB10_A2,\n   },\n   {\n      .image_format    = __DRI_IMAGE_FORMAT_ARGB8888,\n      .mesa_format     =        MESA_FORMAT_B8G8R8A8_UNORM,\n      .internal_format =        GL_RGBA8,\n   },\n   {\n      .image_format    = __DRI_IMAGE_FORMAT_ABGR8888,\n      .mesa_format     =        MESA_FORMAT_R8G8B8A8_UNORM,\n      .internal_format =        GL_RGBA8,\n   },\n   {\n      .image_format    = __DRI_IMAGE_FORMAT_XBGR8888,\n      .mesa_format     =        MESA_FORMAT_R8G8B8X8_UNORM,\n      .internal_format =        GL_RGB8,\n   },\n   {\n      .image_format    = __DRI_IMAGE_FORMAT_R8,\n      .mesa_format     =        MESA_FORMAT_R_UNORM8,\n      .internal_format =        GL_R8,\n   },\n   {\n      .image_format    = __DRI_IMAGE_FORMAT_R8,\n      .mesa_format     =        MESA_FORMAT_L_UNORM8,\n      .internal_format =        GL_R8,\n   },\n#if UTIL_ARCH_LITTLE_ENDIAN\n   {\n      .image_format    = __DRI_IMAGE_FORMAT_GR88,\n      .mesa_format     =        MESA_FORMAT_RG_UNORM8,\n      .internal_format =        GL_RG8,\n   },\n   {\n      .image_format    = __DRI_IMAGE_FORMAT_GR88,\n      .mesa_format     =        MESA_FORMAT_LA_UNORM8,\n      .internal_format =        GL_RG8,\n   },\n#endif\n   {\n      .image_format    = __DRI_IMAGE_FORMAT_SABGR8,\n      .mesa_format     =        MESA_FORMAT_R8G8B8A8_SRGB,\n      .internal_format =        GL_SRGB8_ALPHA8,\n   },\n   {\n      .image_format    = __DRI_IMAGE_FORMAT_SARGB8,\n      .mesa_format     =        MESA_FORMAT_B8G8R8A8_SRGB,\n      .internal_format =        GL_SRGB8_ALPHA8,\n   },\n   {\n      .image_format = __DRI_IMAGE_FORMAT_SXRGB8,\n      .mesa_format  =           MESA_FORMAT_B8G8R8X8_SRGB,\n      .internal_format =        GL_SRGB8_ALPHA8,\n   },\n   {\n      .image_format    = __DRI_IMAGE_FORMAT_R16,\n      .mesa_format     =        MESA_FORMAT_R_UNORM16,\n      .internal_format =        GL_R16,\n   },\n   {\n      .image_format    = __DRI_IMAGE_FORMAT_R16,\n      .mesa_format     =        MESA_FORMAT_L_UNORM16,\n      .internal_format =        GL_R16,\n   },\n#if UTIL_ARCH_LITTLE_ENDIAN\n   {\n      .image_format    = __DRI_IMAGE_FORMAT_GR1616,\n      .mesa_format     =        MESA_FORMAT_RG_UNORM16,\n      .internal_format =        GL_RG16,\n   },\n   {\n      .image_format    = __DRI_IMAGE_FORMAT_GR1616,\n      .mesa_format     =        MESA_FORMAT_LA_UNORM16,\n      .internal_format =        GL_RG16,\n   },\n#endif\n};\n\nuint32_t\ndriGLFormatToImageFormat(mesa_format format)\n{\n   for (size_t i = 0; i < ARRAY_SIZE(format_mapping); i++)\n      if (format_mapping[i].mesa_format == format)\n         return format_mapping[i].image_format;\n\n   return __DRI_IMAGE_FORMAT_NONE;\n}\n\nuint32_t\ndriGLFormatToSizedInternalGLFormat(mesa_format format)\n{\n   for (size_t i = 0; i < ARRAY_SIZE(format_mapping); i++)\n      if (format_mapping[i].mesa_format == format)\n         return format_mapping[i].internal_format;\n\n   return GL_NONE;\n}\n\nmesa_format\ndriImageFormatToGLFormat(uint32_t image_format)\n{\n   for (size_t i = 0; i < ARRAY_SIZE(format_mapping); i++)\n      if (format_mapping[i].image_format == image_format)\n         return format_mapping[i].mesa_format;\n\n   return MESA_FORMAT_NONE;\n}\n\n/** Image driver interface */\nconst __DRIimageDriverExtension driImageDriverExtension = {\n    .base = { __DRI_IMAGE_DRIVER, 1 },\n\n    .createNewScreen2           = driCreateNewScreen2,\n    .createNewDrawable          = driCreateNewDrawable,\n    .getAPIMask                 = driGetAPIMask,\n    .createContextAttribs       = driCreateContextAttribs,\n};\n\n/* swrast copy sub buffer entrypoint. */\nstatic void driCopySubBuffer(__DRIdrawable *pdp, int x, int y,\n                             int w, int h)\n{\n    assert(pdp->driScreenPriv->swrast_loader);\n\n    pdp->driScreenPriv->driver->CopySubBuffer(pdp, x, y, w, h);\n}\n\n/* for swrast only */\nconst __DRIcopySubBufferExtension driCopySubBufferExtension = {\n   .base = { __DRI_COPY_SUB_BUFFER, 1 },\n\n   .copySubBuffer               = driCopySubBuffer,\n};\n\nconst __DRInoErrorExtension dri2NoErrorExtension = {\n   .base = { __DRI2_NO_ERROR, 1 },\n};\n",
        "/tmp/vanessa/spack-stage/spack-stage-mesa-master-nrat2nfszfps3qrvs2kywr374rcjkgv2/spack-src/src/gbm/backends/dri/gbm_dri.c": "/*\n * Copyright \u00a9 2011 Intel Corporation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice (including the next\n * paragraph) shall be included in all copies or substantial portions of the\n * Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n *\n * Authors:\n *    Benjamin Franzke <benjaminfranzke@googlemail.com>\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n#include <errno.h>\n#include <limits.h>\n#include <assert.h>\n\n#include <sys/types.h>\n#include <unistd.h>\n#include <dlfcn.h>\n#include <xf86drm.h>\n#include \"drm-uapi/drm_fourcc.h\"\n\n#include <GL/gl.h> /* dri_interface needs GL types */\n#include <GL/internal/dri_interface.h>\n\n#include \"gbm_driint.h\"\n\n#include \"gbmint.h\"\n#include \"loader.h\"\n#include \"util/debug.h\"\n#include \"util/macros.h\"\n\n/* For importing wl_buffer */\n#if HAVE_WAYLAND_PLATFORM\n#include \"wayland-drm.h\"\n#endif\n\nstatic __DRIimage *\ndri_lookup_egl_image(__DRIscreen *screen, void *image, void *data)\n{\n   struct gbm_dri_device *dri = data;\n\n   if (dri->lookup_image == NULL)\n      return NULL;\n\n   return dri->lookup_image(screen, image, dri->lookup_user_data);\n}\n\nstatic __DRIbuffer *\ndri_get_buffers(__DRIdrawable * driDrawable,\n\t\t int *width, int *height,\n\t\t unsigned int *attachments, int count,\n\t\t int *out_count, void *data)\n{\n   struct gbm_dri_surface *surf = data;\n   struct gbm_dri_device *dri = gbm_dri_device(surf->base.gbm);\n\n   if (dri->get_buffers == NULL)\n      return NULL;\n\n   return dri->get_buffers(driDrawable, width, height, attachments,\n                           count, out_count, surf->dri_private);\n}\n\nstatic void\ndri_flush_front_buffer(__DRIdrawable * driDrawable, void *data)\n{\n   struct gbm_dri_surface *surf = data;\n   struct gbm_dri_device *dri = gbm_dri_device(surf->base.gbm);\n\n   if (dri->flush_front_buffer != NULL)\n      dri->flush_front_buffer(driDrawable, surf->dri_private);\n}\n\nstatic __DRIbuffer *\ndri_get_buffers_with_format(__DRIdrawable * driDrawable,\n                            int *width, int *height,\n                            unsigned int *attachments, int count,\n                            int *out_count, void *data)\n{\n   struct gbm_dri_surface *surf = data;\n   struct gbm_dri_device *dri = gbm_dri_device(surf->base.gbm);\n\n   if (dri->get_buffers_with_format == NULL)\n      return NULL;\n\n   return\n      dri->get_buffers_with_format(driDrawable, width, height, attachments,\n                                   count, out_count, surf->dri_private);\n}\n\nstatic unsigned\ndri_get_capability(void *loaderPrivate, enum dri_loader_cap cap)\n{\n   /* Note: loaderPrivate is _EGLDisplay* */\n   switch (cap) {\n   case DRI_LOADER_CAP_FP16:\n      return 1;\n   default:\n      return 0;\n   }\n}\n\nstatic int\nimage_get_buffers(__DRIdrawable *driDrawable,\n                  unsigned int format,\n                  uint32_t *stamp,\n                  void *loaderPrivate,\n                  uint32_t buffer_mask,\n                  struct __DRIimageList *buffers)\n{\n   struct gbm_dri_surface *surf = loaderPrivate;\n   struct gbm_dri_device *dri = gbm_dri_device(surf->base.gbm);\n\n   if (dri->image_get_buffers == NULL)\n      return 0;\n\n   return dri->image_get_buffers(driDrawable, format, stamp,\n                                 surf->dri_private, buffer_mask, buffers);\n}\n\nstatic void\nswrast_get_drawable_info(__DRIdrawable *driDrawable,\n                         int           *x,\n                         int           *y,\n                         int           *width,\n                         int           *height,\n                         void          *loaderPrivate)\n{\n   struct gbm_dri_surface *surf = loaderPrivate;\n\n   *x = 0;\n   *y = 0;\n   *width = surf->base.width;\n   *height = surf->base.height;\n}\n\nstatic void\nswrast_put_image2(__DRIdrawable *driDrawable,\n                  int            op,\n                  int            x,\n                  int            y,\n                  int            width,\n                  int            height,\n                  int            stride,\n                  char          *data,\n                  void          *loaderPrivate)\n{\n   struct gbm_dri_surface *surf = loaderPrivate;\n   struct gbm_dri_device *dri = gbm_dri_device(surf->base.gbm);\n\n   dri->swrast_put_image2(driDrawable,\n                          op, x, y,\n                          width, height, stride,\n                          data, surf->dri_private);\n}\n\nstatic void\nswrast_put_image(__DRIdrawable *driDrawable,\n                 int            op,\n                 int            x,\n                 int            y,\n                 int            width,\n                 int            height,\n                 char          *data,\n                 void          *loaderPrivate)\n{\n   swrast_put_image2(driDrawable, op, x, y, width, height,\n                            width * 4, data, loaderPrivate);\n}\n\nstatic void\nswrast_get_image(__DRIdrawable *driDrawable,\n                 int            x,\n                 int            y,\n                 int            width,\n                 int            height,\n                 char          *data,\n                 void          *loaderPrivate)\n{\n   struct gbm_dri_surface *surf = loaderPrivate;\n   struct gbm_dri_device *dri = gbm_dri_device(surf->base.gbm);\n\n   dri->swrast_get_image(driDrawable,\n                         x, y,\n                         width, height,\n                         data, surf->dri_private);\n}\n\nstatic const __DRIuseInvalidateExtension use_invalidate = {\n   .base = { __DRI_USE_INVALIDATE, 1 }\n};\n\nstatic const __DRIimageLookupExtension image_lookup_extension = {\n   .base = { __DRI_IMAGE_LOOKUP, 1 },\n\n   .lookupEGLImage          = dri_lookup_egl_image\n};\n\nstatic const __DRIdri2LoaderExtension dri2_loader_extension = {\n   .base = { __DRI_DRI2_LOADER, 4 },\n\n   .getBuffers              = dri_get_buffers,\n   .flushFrontBuffer        = dri_flush_front_buffer,\n   .getBuffersWithFormat    = dri_get_buffers_with_format,\n   .getCapability           = dri_get_capability,\n};\n\nstatic const __DRIimageLoaderExtension image_loader_extension = {\n   .base = { __DRI_IMAGE_LOADER, 2 },\n\n   .getBuffers          = image_get_buffers,\n   .flushFrontBuffer    = dri_flush_front_buffer,\n   .getCapability       = dri_get_capability,\n};\n\nstatic const __DRIswrastLoaderExtension swrast_loader_extension = {\n   .base = { __DRI_SWRAST_LOADER, 2 },\n\n   .getDrawableInfo = swrast_get_drawable_info,\n   .putImage        = swrast_put_image,\n   .getImage        = swrast_get_image,\n   .putImage2       = swrast_put_image2\n};\n\nstatic const __DRIextension *gbm_dri_screen_extensions[] = {\n   &image_lookup_extension.base,\n   &use_invalidate.base,\n   &dri2_loader_extension.base,\n   &image_loader_extension.base,\n   &swrast_loader_extension.base,\n   NULL,\n};\n\nstruct dri_extension_match {\n   const char *name;\n   int version;\n   int offset;\n   bool optional;\n};\n\nstatic struct dri_extension_match dri_core_extensions[] = {\n   { __DRI2_FLUSH, 1, offsetof(struct gbm_dri_device, flush), false },\n   { __DRI_IMAGE, 1, offsetof(struct gbm_dri_device, image), false },\n   { __DRI2_FENCE, 1, offsetof(struct gbm_dri_device, fence), true },\n};\n\nstatic struct dri_extension_match gbm_dri_device_extensions[] = {\n   { __DRI_CORE, 1, offsetof(struct gbm_dri_device, core), false },\n   { __DRI_DRI2, 1, offsetof(struct gbm_dri_device, dri2), false },\n};\n\nstatic struct dri_extension_match gbm_swrast_device_extensions[] = {\n   { __DRI_CORE, 1, offsetof(struct gbm_dri_device, core), false },\n   { __DRI_SWRAST, 1, offsetof(struct gbm_dri_device, swrast), false },\n};\n\nstatic bool\ndri_bind_extensions(struct gbm_dri_device *dri,\n                    struct dri_extension_match *matches, size_t num_matches,\n                    const __DRIextension **extensions)\n{\n   bool ret = true;\n   void *field;\n\n   for (size_t i = 0; extensions[i]; i++) {\n      for (size_t j = 0; j < num_matches; j++) {\n         if (strcmp(extensions[i]->name, matches[j].name) == 0 &&\n             extensions[i]->version >= matches[j].version) {\n            field = ((char *) dri + matches[j].offset);\n            *(const __DRIextension **) field = extensions[i];\n         }\n      }\n   }\n\n   for (size_t j = 0; j < num_matches; j++) {\n      field = ((char *) dri + matches[j].offset);\n      if ((*(const __DRIextension **) field == NULL) && !matches[j].optional) {\n         ret = false;\n      }\n   }\n\n   return ret;\n}\n\nstatic const __DRIextension **\ndri_open_driver(struct gbm_dri_device *dri)\n{\n   /* Temporarily work around dri driver libs that need symbols in libglapi\n    * but don't automatically link it in.\n    */\n   /* XXX: Library name differs on per platforms basis. Update this as\n    * osx/cygwin/windows/bsd gets support for GBM..\n    */\n   dlopen(\"libglapi.so.0\", RTLD_LAZY | RTLD_GLOBAL);\n\n   static const char *search_path_vars[] = {\n      /* Read GBM_DRIVERS_PATH first for compatibility, but LIBGL_DRIVERS_PATH\n       * is recommended over GBM_DRIVERS_PATH.\n       */\n      \"GBM_DRIVERS_PATH\",\n      /* Read LIBGL_DRIVERS_PATH if GBM_DRIVERS_PATH was not set.\n       * LIBGL_DRIVERS_PATH is recommended over GBM_DRIVERS_PATH.\n       */\n      \"LIBGL_DRIVERS_PATH\",\n      NULL\n   };\n   return loader_open_driver(dri->driver_name, &dri->driver, search_path_vars);\n}\n\nstatic int\ndri_load_driver(struct gbm_dri_device *dri)\n{\n   const __DRIextension **extensions;\n\n   extensions = dri_open_driver(dri);\n   if (!extensions)\n      return -1;\n\n   if (!dri_bind_extensions(dri, gbm_dri_device_extensions,\n                            ARRAY_SIZE(gbm_dri_device_extensions),\n                            extensions)) {\n      dlclose(dri->driver);\n      fprintf(stderr, \"failed to bind extensions\\n\");\n      return -1;\n   }\n\n   dri->driver_extensions = extensions;\n\n   return 0;\n}\n\nstatic int\ndri_load_driver_swrast(struct gbm_dri_device *dri)\n{\n   const __DRIextension **extensions;\n\n   extensions = dri_open_driver(dri);\n   if (!extensions)\n      return -1;\n\n   if (!dri_bind_extensions(dri, gbm_swrast_device_extensions,\n                            ARRAY_SIZE(gbm_swrast_device_extensions),\n                            extensions)) {\n      dlclose(dri->driver);\n      fprintf(stderr, \"failed to bind extensions\\n\");\n      return -1;\n   }\n\n   dri->driver_extensions = extensions;\n\n   return 0;\n}\n\nstatic int\ndri_screen_create_dri2(struct gbm_dri_device *dri, char *driver_name)\n{\n   const __DRIextension **extensions;\n   int ret = 0;\n\n   dri->driver_name = driver_name;\n   if (dri->driver_name == NULL)\n      return -1;\n\n   ret = dri_load_driver(dri);\n   if (ret) {\n      fprintf(stderr, \"failed to load driver: %s\\n\", dri->driver_name);\n      return ret;\n   }\n\n   dri->loader_extensions = gbm_dri_screen_extensions;\n\n   if (dri->dri2 == NULL)\n      return -1;\n\n   if (dri->dri2->base.version >= 4) {\n      dri->screen = dri->dri2->createNewScreen2(0, dri->base.fd,\n                                                dri->loader_extensions,\n                                                dri->driver_extensions,\n                                                &dri->driver_configs, dri);\n   } else {\n      dri->screen = dri->dri2->createNewScreen(0, dri->base.fd,\n                                               dri->loader_extensions,\n                                               &dri->driver_configs, dri);\n   }\n   if (dri->screen == NULL)\n      return -1;\n\n   extensions = dri->core->getExtensions(dri->screen);\n   if (!dri_bind_extensions(dri, dri_core_extensions,\n                            ARRAY_SIZE(dri_core_extensions),\n                            extensions)) {\n      ret = -1;\n      goto free_screen;\n   }\n\n   dri->lookup_image = NULL;\n   dri->lookup_user_data = NULL;\n\n   return 0;\n\nfree_screen:\n   dri->core->destroyScreen(dri->screen);\n\n   return ret;\n}\n\nstatic int\ndri_screen_create_swrast(struct gbm_dri_device *dri)\n{\n   int ret;\n\n   dri->driver_name = strdup(\"swrast\");\n   if (dri->driver_name == NULL)\n      return -1;\n\n   ret = dri_load_driver_swrast(dri);\n   if (ret) {\n      fprintf(stderr, \"failed to load swrast driver\\n\");\n      return ret;\n   }\n\n   dri->loader_extensions = gbm_dri_screen_extensions;\n\n   if (dri->swrast == NULL)\n      return -1;\n\n   if (dri->swrast->base.version >= 4) {\n      dri->screen = dri->swrast->createNewScreen2(0, dri->loader_extensions,\n                                                  dri->driver_extensions,\n                                                  &dri->driver_configs, dri);\n   } else {\n      dri->screen = dri->swrast->createNewScreen(0, dri->loader_extensions,\n                                                 &dri->driver_configs, dri);\n   }\n   if (dri->screen == NULL)\n      return -1;\n\n   dri->lookup_image = NULL;\n   dri->lookup_user_data = NULL;\n\n   return 0;\n}\n\nstatic int\ndri_screen_create(struct gbm_dri_device *dri)\n{\n   char *driver_name;\n\n   driver_name = loader_get_driver_for_fd(dri->base.fd);\n   if (!driver_name)\n      return -1;\n\n   return dri_screen_create_dri2(dri, driver_name);\n}\n\nstatic int\ndri_screen_create_sw(struct gbm_dri_device *dri)\n{\n   char *driver_name;\n   int ret;\n\n   driver_name = strdup(\"kms_swrast\");\n   if (!driver_name)\n      return -errno;\n\n   ret = dri_screen_create_dri2(dri, driver_name);\n   if (ret == 0)\n      return ret;\n\n   return dri_screen_create_swrast(dri);\n}\n\nstatic const struct gbm_dri_visual gbm_dri_visuals_table[] = {\n   {\n     GBM_FORMAT_R8, __DRI_IMAGE_FORMAT_R8,\n     { 0, -1, -1, -1 },\n     { 8, 0, 0, 0 },\n   },\n   {\n     GBM_FORMAT_GR88, __DRI_IMAGE_FORMAT_GR88,\n     { 0, 8, -1, -1 },\n     { 8, 8, 0, 0 },\n   },\n   {\n     GBM_FORMAT_ARGB1555, __DRI_IMAGE_FORMAT_ARGB1555,\n     { 10, 5, 0, 11 },\n     { 5, 5, 5, 1 },\n   },\n   {\n     GBM_FORMAT_RGB565, __DRI_IMAGE_FORMAT_RGB565,\n     { 11, 5, 0, -1 },\n     { 5, 6, 5, 0 },\n   },\n   {\n     GBM_FORMAT_XRGB8888, __DRI_IMAGE_FORMAT_XRGB8888,\n     { 16, 8, 0, -1 },\n     { 8, 8, 8, 0 },\n   },\n   {\n     GBM_FORMAT_ARGB8888, __DRI_IMAGE_FORMAT_ARGB8888,\n     { 16, 8, 0, 24 },\n     { 8, 8, 8, 8 },\n   },\n   {\n     GBM_FORMAT_XBGR8888, __DRI_IMAGE_FORMAT_XBGR8888,\n     { 0, 8, 16, -1 },\n     { 8, 8, 8, 0 },\n   },\n   {\n     GBM_FORMAT_ABGR8888, __DRI_IMAGE_FORMAT_ABGR8888,\n     { 0, 8, 16, 24 },\n     { 8, 8, 8, 8 },\n   },\n   {\n     GBM_FORMAT_XRGB2101010, __DRI_IMAGE_FORMAT_XRGB2101010,\n     { 20, 10, 0, -1 },\n     { 10, 10, 10, 0 },\n   },\n   {\n     GBM_FORMAT_ARGB2101010, __DRI_IMAGE_FORMAT_ARGB2101010,\n     { 20, 10, 0, 30 },\n     { 10, 10, 10, 2 },\n   },\n   {\n     GBM_FORMAT_XBGR2101010, __DRI_IMAGE_FORMAT_XBGR2101010,\n     { 0, 10, 20, -1 },\n     { 10, 10, 10, 0 },\n   },\n   {\n     GBM_FORMAT_ABGR2101010, __DRI_IMAGE_FORMAT_ABGR2101010,\n     { 0, 10, 20, 30 },\n     { 10, 10, 10, 2 },\n   },\n   {\n     GBM_FORMAT_XBGR16161616F, __DRI_IMAGE_FORMAT_XBGR16161616F,\n     { 0, 16, 32, -1 },\n     { 16, 16, 16, 0 },\n     true,\n   },\n   {\n     GBM_FORMAT_ABGR16161616F, __DRI_IMAGE_FORMAT_ABGR16161616F,\n     { 0, 16, 32, 48 },\n     { 16, 16, 16, 16 },\n     true,\n   },\n};\n\nstatic int\ngbm_format_to_dri_format(uint32_t gbm_format)\n{\n   gbm_format = gbm_format_canonicalize(gbm_format);\n   for (size_t i = 0; i < ARRAY_SIZE(gbm_dri_visuals_table); i++) {\n      if (gbm_dri_visuals_table[i].gbm_format == gbm_format)\n         return gbm_dri_visuals_table[i].dri_image_format;\n   }\n\n   return 0;\n}\n\nstatic uint32_t\ngbm_dri_to_gbm_format(int dri_format)\n{\n   for (size_t i = 0; i < ARRAY_SIZE(gbm_dri_visuals_table); i++) {\n      if (gbm_dri_visuals_table[i].dri_image_format == dri_format)\n         return gbm_dri_visuals_table[i].gbm_format;\n   }\n\n   return 0;\n}\n\nstatic int\ngbm_dri_is_format_supported(struct gbm_device *gbm,\n                            uint32_t format,\n                            uint32_t usage)\n{\n   struct gbm_dri_device *dri = gbm_dri_device(gbm);\n   int count;\n\n   if ((usage & GBM_BO_USE_CURSOR) && (usage & GBM_BO_USE_RENDERING))\n      return 0;\n\n   format = gbm_format_canonicalize(format);\n   if (gbm_format_to_dri_format(format) == 0)\n      return 0;\n\n   /* If there is no query, fall back to the small table which was originally\n    * here. */\n   if (dri->image->base.version <= 15 || !dri->image->queryDmaBufModifiers) {\n      switch (format) {\n      case GBM_FORMAT_XRGB8888:\n      case GBM_FORMAT_ARGB8888:\n      case GBM_FORMAT_XBGR8888:\n         return 1;\n      default:\n         return 0;\n      }\n   }\n\n   /* This returns false if the format isn't supported */\n   if (!dri->image->queryDmaBufModifiers(dri->screen, format, 0, NULL, NULL,\n                                         &count))\n      return 0;\n\n   return 1;\n}\n\nstatic int\ngbm_dri_get_format_modifier_plane_count(struct gbm_device *gbm,\n                                        uint32_t format,\n                                        uint64_t modifier)\n{\n   struct gbm_dri_device *dri = gbm_dri_device(gbm);\n   uint64_t plane_count;\n\n   if (dri->image->base.version < 16 ||\n       !dri->image->queryDmaBufFormatModifierAttribs)\n      return -1;\n\n   format = gbm_format_canonicalize(format);\n   if (gbm_format_to_dri_format(format) == 0)\n      return -1;\n\n   if (!dri->image->queryDmaBufFormatModifierAttribs(\n         dri->screen, format, modifier,\n         __DRI_IMAGE_FORMAT_MODIFIER_ATTRIB_PLANE_COUNT, &plane_count))\n      return -1;\n\n   return plane_count;\n}\n\nstatic int\ngbm_dri_bo_write(struct gbm_bo *_bo, const void *buf, size_t count)\n{\n   struct gbm_dri_bo *bo = gbm_dri_bo(_bo);\n\n   if (bo->image != NULL) {\n      errno = EINVAL;\n      return -1;\n   }\n\n   memcpy(bo->map, buf, count);\n\n   return 0;\n}\n\nstatic int\ngbm_dri_bo_get_fd(struct gbm_bo *_bo)\n{\n   struct gbm_dri_device *dri = gbm_dri_device(_bo->gbm);\n   struct gbm_dri_bo *bo = gbm_dri_bo(_bo);\n   int fd;\n\n   if (bo->image == NULL)\n      return -1;\n\n   if (!dri->image->queryImage(bo->image, __DRI_IMAGE_ATTRIB_FD, &fd))\n      return -1;\n\n   return fd;\n}\n\nstatic int\nget_number_planes(struct gbm_dri_device *dri, __DRIimage *image)\n{\n   int num_planes = 0;\n\n   /* Dumb buffers are single-plane only. */\n   if (!image)\n      return 1;\n\n   dri->image->queryImage(image, __DRI_IMAGE_ATTRIB_NUM_PLANES, &num_planes);\n\n   if (num_planes <= 0)\n      num_planes = 1;\n\n   return num_planes;\n}\n\nstatic int\ngbm_dri_bo_get_planes(struct gbm_bo *_bo)\n{\n   struct gbm_dri_device *dri = gbm_dri_device(_bo->gbm);\n   struct gbm_dri_bo *bo = gbm_dri_bo(_bo);\n\n   return get_number_planes(dri, bo->image);\n}\n\nstatic union gbm_bo_handle\ngbm_dri_bo_get_handle_for_plane(struct gbm_bo *_bo, int plane)\n{\n   struct gbm_dri_device *dri = gbm_dri_device(_bo->gbm);\n   struct gbm_dri_bo *bo = gbm_dri_bo(_bo);\n   union gbm_bo_handle ret;\n   ret.s32 = -1;\n\n   if (!dri->image || dri->image->base.version < 13 || !dri->image->fromPlanar) {\n      /* Preserve legacy behavior if plane is 0 */\n      if (plane == 0) {\n         /* NOTE: return _bo->handle, *NOT* bo->handle which is invalid at this point */\n         return _bo->handle;\n      }\n\n      errno = ENOSYS;\n      return ret;\n   }\n\n   if (plane >= get_number_planes(dri, bo->image)) {\n      errno = EINVAL;\n      return ret;\n   }\n\n   /* dumb BOs can only utilize non-planar formats */\n   if (!bo->image) {\n      assert(plane == 0);\n      ret.s32 = bo->handle;\n      return ret;\n   }\n\n   __DRIimage *image = dri->image->fromPlanar(bo->image, plane, NULL);\n   if (image) {\n      dri->image->queryImage(image, __DRI_IMAGE_ATTRIB_HANDLE, &ret.s32);\n      dri->image->destroyImage(image);\n   } else {\n      assert(plane == 0);\n      dri->image->queryImage(bo->image, __DRI_IMAGE_ATTRIB_HANDLE, &ret.s32);\n   }\n\n   return ret;\n}\n\nstatic uint32_t\ngbm_dri_bo_get_stride(struct gbm_bo *_bo, int plane)\n{\n   struct gbm_dri_device *dri = gbm_dri_device(_bo->gbm);\n   struct gbm_dri_bo *bo = gbm_dri_bo(_bo);\n   __DRIimage *image;\n   int stride = 0;\n\n   if (!dri->image || dri->image->base.version < 11 || !dri->image->fromPlanar) {\n      /* Preserve legacy behavior if plane is 0 */\n      if (plane == 0)\n         return _bo->stride;\n\n      errno = ENOSYS;\n      return 0;\n   }\n\n   if (plane >= get_number_planes(dri, bo->image)) {\n      errno = EINVAL;\n      return 0;\n   }\n\n   if (bo->image == NULL) {\n      assert(plane == 0);\n      return _bo->stride;\n   }\n\n   image = dri->image->fromPlanar(bo->image, plane, NULL);\n   if (image) {\n      dri->image->queryImage(image, __DRI_IMAGE_ATTRIB_STRIDE, &stride);\n      dri->image->destroyImage(image);\n   } else {\n      assert(plane == 0);\n      dri->image->queryImage(bo->image, __DRI_IMAGE_ATTRIB_STRIDE, &stride);\n   }\n\n   return (uint32_t)stride;\n}\n\nstatic uint32_t\ngbm_dri_bo_get_offset(struct gbm_bo *_bo, int plane)\n{\n   struct gbm_dri_device *dri = gbm_dri_device(_bo->gbm);\n   struct gbm_dri_bo *bo = gbm_dri_bo(_bo);\n   int offset = 0;\n\n   /* These error cases do not actually return an error code, as the user\n    * will also fail to obtain the handle/FD from the BO. In that case, the\n    * offset is irrelevant, as they have no buffer to offset into, so\n    * returning 0 is harmless.\n    */\n   if (!dri->image || dri->image->base.version < 13 || !dri->image->fromPlanar)\n      return 0;\n\n   if (plane >= get_number_planes(dri, bo->image))\n      return 0;\n\n    /* Dumb images have no offset */\n   if (bo->image == NULL) {\n      assert(plane == 0);\n      return 0;\n   }\n\n   __DRIimage *image = dri->image->fromPlanar(bo->image, plane, NULL);\n   if (image) {\n      dri->image->queryImage(image, __DRI_IMAGE_ATTRIB_OFFSET, &offset);\n      dri->image->destroyImage(image);\n   } else {\n      assert(plane == 0);\n      dri->image->queryImage(bo->image, __DRI_IMAGE_ATTRIB_OFFSET, &offset);\n   }\n\n   return (uint32_t)offset;\n}\n\nstatic uint64_t\ngbm_dri_bo_get_modifier(struct gbm_bo *_bo)\n{\n   struct gbm_dri_device *dri = gbm_dri_device(_bo->gbm);\n   struct gbm_dri_bo *bo = gbm_dri_bo(_bo);\n\n   if (!dri->image || dri->image->base.version < 14) {\n      errno = ENOSYS;\n      return DRM_FORMAT_MOD_INVALID;\n   }\n\n   /* Dumb buffers have no modifiers */\n   if (!bo->image)\n      return DRM_FORMAT_MOD_LINEAR;\n\n   uint64_t ret = 0;\n   int mod;\n   if (!dri->image->queryImage(bo->image, __DRI_IMAGE_ATTRIB_MODIFIER_UPPER,\n                               &mod))\n      return DRM_FORMAT_MOD_INVALID;\n\n   ret = (uint64_t)mod << 32;\n\n   if (!dri->image->queryImage(bo->image, __DRI_IMAGE_ATTRIB_MODIFIER_LOWER,\n                               &mod))\n      return DRM_FORMAT_MOD_INVALID;\n\n   ret |= (uint64_t)(mod & 0xffffffff);\n\n   return ret;\n}\n\nstatic void\ngbm_dri_bo_destroy(struct gbm_bo *_bo)\n{\n   struct gbm_dri_device *dri = gbm_dri_device(_bo->gbm);\n   struct gbm_dri_bo *bo = gbm_dri_bo(_bo);\n   struct drm_mode_destroy_dumb arg;\n\n   if (bo->image != NULL) {\n      dri->image->destroyImage(bo->image);\n   } else {\n      gbm_dri_bo_unmap_dumb(bo);\n      memset(&arg, 0, sizeof(arg));\n      arg.handle = bo->handle;\n      drmIoctl(dri->base.fd, DRM_IOCTL_MODE_DESTROY_DUMB, &arg);\n   }\n\n   free(bo);\n}\n\nstatic struct gbm_bo *\ngbm_dri_bo_import(struct gbm_device *gbm,\n                  uint32_t type, void *buffer, uint32_t usage)\n{\n   struct gbm_dri_device *dri = gbm_dri_device(gbm);\n   struct gbm_dri_bo *bo;\n   __DRIimage *image;\n   unsigned dri_use = 0;\n   int gbm_format;\n\n   /* Required for query image WIDTH & HEIGHT */\n   if (dri->image == NULL || dri->image->base.version < 4) {\n      errno = ENOSYS;\n      return NULL;\n   }\n\n   switch (type) {\n#if HAVE_WAYLAND_PLATFORM\n   case GBM_BO_IMPORT_WL_BUFFER:\n   {\n      struct wl_drm_buffer *wb;\n\n      if (!dri->wl_drm) {\n         errno = EINVAL;\n         return NULL;\n      }\n\n      wb = wayland_drm_buffer_get(dri->wl_drm, (struct wl_resource *) buffer);\n      if (!wb) {\n         errno = EINVAL;\n         return NULL;\n      }\n\n      image = dri->image->dupImage(wb->driver_buffer, NULL);\n\n      /* GBM_FORMAT_* is identical to WL_DRM_FORMAT_*, so no conversion\n       * required. */\n      gbm_format = wb->format;\n      break;\n   }\n#endif\n\n   case GBM_BO_IMPORT_EGL_IMAGE:\n   {\n      int dri_format;\n      if (dri->lookup_image == NULL) {\n         errno = EINVAL;\n         return NULL;\n      }\n\n      image = dri->lookup_image(dri->screen, buffer, dri->lookup_user_data);\n      image = dri->image->dupImage(image, NULL);\n      dri->image->queryImage(image, __DRI_IMAGE_ATTRIB_FORMAT, &dri_format);\n      gbm_format = gbm_dri_to_gbm_format(dri_format);\n      if (gbm_format == 0) {\n         errno = EINVAL;\n         dri->image->destroyImage(image);\n         return NULL;\n      }\n      break;\n   }\n\n   case GBM_BO_IMPORT_FD:\n   {\n      struct gbm_import_fd_data *fd_data = buffer;\n      int stride = fd_data->stride, offset = 0;\n      int fourcc;\n\n      /* GBM's GBM_FORMAT_* tokens are a strict superset of the DRI FourCC\n       * tokens accepted by createImageFromFds, except for not supporting\n       * the sARGB format. */\n      fourcc = gbm_format_canonicalize(fd_data->format);\n\n      image = dri->image->createImageFromFds(dri->screen,\n                                             fd_data->width,\n                                             fd_data->height,\n                                             fourcc,\n                                             &fd_data->fd, 1,\n                                             &stride, &offset,\n                                             NULL);\n      if (image == NULL) {\n         errno = EINVAL;\n         return NULL;\n      }\n      gbm_format = fd_data->format;\n      break;\n   }\n\n   case GBM_BO_IMPORT_FD_MODIFIER:\n   {\n      struct gbm_import_fd_modifier_data *fd_data = buffer;\n      unsigned int error;\n      int fourcc;\n\n      /* Import with modifier requires createImageFromDmaBufs2 */\n      if (dri->image == NULL || dri->image->base.version < 15 ||\n          dri->image->createImageFromDmaBufs2 == NULL) {\n         errno = ENOSYS;\n         return NULL;\n      }\n\n      /* GBM's GBM_FORMAT_* tokens are a strict superset of the DRI FourCC\n       * tokens accepted by createImageFromDmaBufs2, except for not supporting\n       * the sARGB format. */\n      fourcc = gbm_format_canonicalize(fd_data->format);\n\n      image = dri->image->createImageFromDmaBufs2(dri->screen, fd_data->width,\n                                                  fd_data->height, fourcc,\n                                                  fd_data->modifier,\n                                                  fd_data->fds,\n                                                  fd_data->num_fds,\n                                                  fd_data->strides,\n                                                  fd_data->offsets,\n                                                  0, 0, 0, 0,\n                                                  &error, NULL);\n      if (image == NULL) {\n         errno = ENOSYS;\n         return NULL;\n      }\n\n      gbm_format = fourcc;\n      break;\n   }\n\n   default:\n      errno = ENOSYS;\n      return NULL;\n   }\n\n\n   bo = calloc(1, sizeof *bo);\n   if (bo == NULL) {\n      dri->image->destroyImage(image);\n      return NULL;\n   }\n\n   bo->image = image;\n\n   if (usage & GBM_BO_USE_SCANOUT)\n      dri_use |= __DRI_IMAGE_USE_SCANOUT;\n   if (usage & GBM_BO_USE_CURSOR)\n      dri_use |= __DRI_IMAGE_USE_CURSOR;\n   if (dri->image->base.version >= 2 &&\n       !dri->image->validateUsage(bo->image, dri_use)) {\n      errno = EINVAL;\n      dri->image->destroyImage(bo->image);\n      free(bo);\n      return NULL;\n   }\n\n   bo->base.gbm = gbm;\n   bo->base.format = gbm_format;\n\n   dri->image->queryImage(bo->image, __DRI_IMAGE_ATTRIB_WIDTH,\n                          (int*)&bo->base.width);\n   dri->image->queryImage(bo->image, __DRI_IMAGE_ATTRIB_HEIGHT,\n                          (int*)&bo->base.height);\n   dri->image->queryImage(bo->image, __DRI_IMAGE_ATTRIB_STRIDE,\n                          (int*)&bo->base.stride);\n   dri->image->queryImage(bo->image, __DRI_IMAGE_ATTRIB_HANDLE,\n                          &bo->base.handle.s32);\n\n   return &bo->base;\n}\n\nstatic struct gbm_bo *\ncreate_dumb(struct gbm_device *gbm,\n                  uint32_t width, uint32_t height,\n                  uint32_t format, uint32_t usage)\n{\n   struct gbm_dri_device *dri = gbm_dri_device(gbm);\n   struct drm_mode_create_dumb create_arg;\n   struct gbm_dri_bo *bo;\n   struct drm_mode_destroy_dumb destroy_arg;\n   int ret;\n   int is_cursor, is_scanout;\n\n   is_cursor = (usage & GBM_BO_USE_CURSOR) != 0 &&\n      format == GBM_FORMAT_ARGB8888;\n   is_scanout = (usage & GBM_BO_USE_SCANOUT) != 0 &&\n      (format == GBM_FORMAT_XRGB8888 || format == GBM_FORMAT_XBGR8888);\n   if (!is_cursor && !is_scanout) {\n      errno = EINVAL;\n      return NULL;\n   }\n\n   bo = calloc(1, sizeof *bo);\n   if (bo == NULL)\n      return NULL;\n\n   memset(&create_arg, 0, sizeof(create_arg));\n   create_arg.bpp = 32;\n   create_arg.width = width;\n   create_arg.height = height;\n\n   ret = drmIoctl(dri->base.fd, DRM_IOCTL_MODE_CREATE_DUMB, &create_arg);\n   if (ret)\n      goto free_bo;\n\n   bo->base.gbm = gbm;\n   bo->base.width = width;\n   bo->base.height = height;\n   bo->base.stride = create_arg.pitch;\n   bo->base.format = format;\n   bo->base.handle.u32 = create_arg.handle;\n   bo->handle = create_arg.handle;\n   bo->size = create_arg.size;\n\n   if (gbm_dri_bo_map_dumb(bo) == NULL)\n      goto destroy_dumb;\n\n   return &bo->base;\n\ndestroy_dumb:\n   memset(&destroy_arg, 0, sizeof destroy_arg);\n   destroy_arg.handle = create_arg.handle;\n   drmIoctl(dri->base.fd, DRM_IOCTL_MODE_DESTROY_DUMB, &destroy_arg);\nfree_bo:\n   free(bo);\n\n   return NULL;\n}\n\nstatic struct gbm_bo *\ngbm_dri_bo_create(struct gbm_device *gbm,\n                  uint32_t width, uint32_t height,\n                  uint32_t format, uint32_t usage,\n                  const uint64_t *modifiers,\n                  const unsigned int count)\n{\n   struct gbm_dri_device *dri = gbm_dri_device(gbm);\n   struct gbm_dri_bo *bo;\n   int dri_format;\n   unsigned dri_use = 0;\n\n   /* Callers of this may specify a modifier, or a dri usage, but not both. The\n    * newer modifier interface deprecates the older usage flags.\n    */\n   assert(!(usage && count));\n\n   format = gbm_format_canonicalize(format);\n\n   if (usage & GBM_BO_USE_WRITE || dri->image == NULL)\n      return create_dumb(gbm, width, height, format, usage);\n\n   bo = calloc(1, sizeof *bo);\n   if (bo == NULL)\n      return NULL;\n\n   bo->base.gbm = gbm;\n   bo->base.width = width;\n   bo->base.height = height;\n   bo->base.format = format;\n\n   dri_format = gbm_format_to_dri_format(format);\n   if (dri_format == 0) {\n      errno = EINVAL;\n      goto failed;\n   }\n\n   if (usage & GBM_BO_USE_SCANOUT)\n      dri_use |= __DRI_IMAGE_USE_SCANOUT;\n   if (usage & GBM_BO_USE_CURSOR)\n      dri_use |= __DRI_IMAGE_USE_CURSOR;\n   if (usage & GBM_BO_USE_LINEAR)\n      dri_use |= __DRI_IMAGE_USE_LINEAR;\n   if (usage & GBM_BO_USE_PROTECTED)\n      dri_use |= __DRI_IMAGE_USE_PROTECTED;\n\n   /* Gallium drivers requires shared in order to get the handle/stride */\n   dri_use |= __DRI_IMAGE_USE_SHARE;\n\n   if (modifiers) {\n      if (!dri->image || dri->image->base.version < 14 ||\n          !dri->image->createImageWithModifiers) {\n         fprintf(stderr, \"Modifiers specified, but DRI is too old\\n\");\n         errno = ENOSYS;\n         goto failed;\n      }\n\n      /* It's acceptable to create an image with INVALID modifier in the list,\n       * but it cannot be on the only modifier (since it will certainly fail\n       * later). While we could easily catch this after modifier creation, doing\n       * the check here is a convenient debug check likely pointing at whatever\n       * interface the client is using to build its modifier list.\n       */\n      if (count == 1 && modifiers[0] == DRM_FORMAT_MOD_INVALID) {\n         fprintf(stderr, \"Only invalid modifier specified\\n\");\n         errno = EINVAL;\n         goto failed;\n      }\n\n      bo->image =\n         dri->image->createImageWithModifiers(dri->screen,\n                                              width, height,\n                                              dri_format,\n                                              modifiers, count,\n                                              bo);\n\n      if (bo->image) {\n         /* The client passed in a list of invalid modifiers */\n         assert(gbm_dri_bo_get_modifier(&bo->base) != DRM_FORMAT_MOD_INVALID);\n      }\n   } else {\n      bo->image = dri->image->createImage(dri->screen, width, height,\n                                          dri_format, dri_use, bo);\n   }\n\n   if (bo->image == NULL)\n      goto failed;\n\n   dri->image->queryImage(bo->image, __DRI_IMAGE_ATTRIB_HANDLE,\n                          &bo->base.handle.s32);\n   dri->image->queryImage(bo->image, __DRI_IMAGE_ATTRIB_STRIDE,\n                          (int *) &bo->base.stride);\n\n   return &bo->base;\n\nfailed:\n   free(bo);\n   return NULL;\n}\n\nstatic void *\ngbm_dri_bo_map(struct gbm_bo *_bo,\n              uint32_t x, uint32_t y,\n              uint32_t width, uint32_t height,\n              uint32_t flags, uint32_t *stride, void **map_data)\n{\n   struct gbm_dri_device *dri = gbm_dri_device(_bo->gbm);\n   struct gbm_dri_bo *bo = gbm_dri_bo(_bo);\n\n   /* If it's a dumb buffer, we already have a mapping */\n   if (bo->map) {\n      *map_data = (char *)bo->map + (bo->base.stride * y) + (x * 4);\n      *stride = bo->base.stride;\n      return *map_data;\n   }\n\n   if (!dri->image || dri->image->base.version < 12 || !dri->image->mapImage) {\n      errno = ENOSYS;\n      return NULL;\n   }\n\n   mtx_lock(&dri->mutex);\n   if (!dri->context)\n      dri->context = dri->dri2->createNewContext(dri->screen, NULL,\n                                                 NULL, NULL);\n   assert(dri->context);\n   mtx_unlock(&dri->mutex);\n\n   /* GBM flags and DRI flags are the same, so just pass them on */\n   return dri->image->mapImage(dri->context, bo->image, x, y,\n                               width, height, flags, (int *)stride,\n                               map_data);\n}\n\nstatic void\ngbm_dri_bo_unmap(struct gbm_bo *_bo, void *map_data)\n{\n   struct gbm_dri_device *dri = gbm_dri_device(_bo->gbm);\n   struct gbm_dri_bo *bo = gbm_dri_bo(_bo);\n\n   /* Check if it's a dumb buffer and check the pointer is in range */\n   if (bo->map) {\n      assert(map_data >= bo->map);\n      assert(map_data < (bo->map + bo->size));\n      return;\n   }\n\n   if (!dri->context || !dri->image ||\n       dri->image->base.version < 12 || !dri->image->unmapImage)\n      return;\n\n   dri->image->unmapImage(dri->context, bo->image, map_data);\n\n   /*\n    * Not all DRI drivers use direct maps. They may queue up DMA operations\n    * on the mapping context. Since there is no explicit gbm flush\n    * mechanism, we need to flush here.\n    */\n   if (dri->flush->base.version >= 4)\n      dri->flush->flush_with_flags(dri->context, NULL, __DRI2_FLUSH_CONTEXT, 0);\n}\n\n\nstatic struct gbm_surface *\ngbm_dri_surface_create(struct gbm_device *gbm,\n                       uint32_t width, uint32_t height,\n\t\t       uint32_t format, uint32_t flags,\n                       const uint64_t *modifiers, const unsigned count)\n{\n   struct gbm_dri_device *dri = gbm_dri_device(gbm);\n   struct gbm_dri_surface *surf;\n\n   if (modifiers &&\n       (!dri->image || dri->image->base.version < 14 ||\n        !dri->image->createImageWithModifiers)) {\n      errno = ENOSYS;\n      return NULL;\n   }\n\n   if (count)\n      assert(modifiers);\n\n   /* It's acceptable to create an image with INVALID modifier in the list,\n    * but it cannot be on the only modifier (since it will certainly fail\n    * later). While we could easily catch this after modifier creation, doing\n    * the check here is a convenient debug check likely pointing at whatever\n    * interface the client is using to build its modifier list.\n    */\n   if (count == 1 && modifiers[0] == DRM_FORMAT_MOD_INVALID) {\n      fprintf(stderr, \"Only invalid modifier specified\\n\");\n      errno = EINVAL;\n   }\n\n   surf = calloc(1, sizeof *surf);\n   if (surf == NULL) {\n      errno = ENOMEM;\n      return NULL;\n   }\n\n   surf->base.gbm = gbm;\n   surf->base.width = width;\n   surf->base.height = height;\n   surf->base.format = gbm_format_canonicalize(format);\n   surf->base.flags = flags;\n   if (!modifiers) {\n      assert(!count);\n      return &surf->base;\n   }\n\n   surf->base.modifiers = calloc(count, sizeof(*modifiers));\n   if (count && !surf->base.modifiers) {\n      errno = ENOMEM;\n      free(surf);\n      return NULL;\n   }\n\n   /* TODO: We are deferring validation of modifiers until the image is actually\n    * created. This deferred creation can fail due to a modifier-format\n    * mismatch. The result is the client has a surface but no object to back it.\n    */\n   surf->base.count = count;\n   memcpy(surf->base.modifiers, modifiers, count * sizeof(*modifiers));\n\n   return &surf->base;\n}\n\nstatic void\ngbm_dri_surface_destroy(struct gbm_surface *_surf)\n{\n   struct gbm_dri_surface *surf = gbm_dri_surface(_surf);\n\n   free(surf->base.modifiers);\n   free(surf);\n}\n\nstatic void\ndri_destroy(struct gbm_device *gbm)\n{\n   struct gbm_dri_device *dri = gbm_dri_device(gbm);\n   unsigned i;\n\n   if (dri->context)\n      dri->core->destroyContext(dri->context);\n\n   dri->core->destroyScreen(dri->screen);\n   for (i = 0; dri->driver_configs[i]; i++)\n      free((__DRIconfig *) dri->driver_configs[i]);\n   free(dri->driver_configs);\n   dlclose(dri->driver);\n   free(dri->driver_name);\n\n   free(dri);\n}\n\nstatic struct gbm_device *\ndri_device_create(int fd)\n{\n   struct gbm_dri_device *dri;\n   int ret;\n   bool force_sw;\n\n   dri = calloc(1, sizeof *dri);\n   if (!dri)\n      return NULL;\n\n   dri->base.fd = fd;\n   dri->base.bo_create = gbm_dri_bo_create;\n   dri->base.bo_import = gbm_dri_bo_import;\n   dri->base.bo_map = gbm_dri_bo_map;\n   dri->base.bo_unmap = gbm_dri_bo_unmap;\n   dri->base.is_format_supported = gbm_dri_is_format_supported;\n   dri->base.get_format_modifier_plane_count =\n      gbm_dri_get_format_modifier_plane_count;\n   dri->base.bo_write = gbm_dri_bo_write;\n   dri->base.bo_get_fd = gbm_dri_bo_get_fd;\n   dri->base.bo_get_planes = gbm_dri_bo_get_planes;\n   dri->base.bo_get_handle = gbm_dri_bo_get_handle_for_plane;\n   dri->base.bo_get_stride = gbm_dri_bo_get_stride;\n   dri->base.bo_get_offset = gbm_dri_bo_get_offset;\n   dri->base.bo_get_modifier = gbm_dri_bo_get_modifier;\n   dri->base.bo_destroy = gbm_dri_bo_destroy;\n   dri->base.destroy = dri_destroy;\n   dri->base.surface_create = gbm_dri_surface_create;\n   dri->base.surface_destroy = gbm_dri_surface_destroy;\n\n   dri->base.name = \"drm\";\n\n   dri->visual_table = gbm_dri_visuals_table;\n   dri->num_visuals = ARRAY_SIZE(gbm_dri_visuals_table);\n\n   mtx_init(&dri->mutex, mtx_plain);\n\n   force_sw = env_var_as_boolean(\"GBM_ALWAYS_SOFTWARE\", false);\n   if (!force_sw) {\n      ret = dri_screen_create(dri);\n      if (ret)\n         ret = dri_screen_create_sw(dri);\n   } else {\n      ret = dri_screen_create_sw(dri);\n   }\n\n   if (ret)\n      goto err_dri;\n\n   return &dri->base;\n\nerr_dri:\n   free(dri);\n\n   return NULL;\n}\n\nstruct gbm_backend gbm_dri_backend = {\n   .backend_name = \"dri\",\n   .create_device = dri_device_create,\n};\n",
        "/tmp/vanessa/spack-stage/spack-stage-mesa-master-nrat2nfszfps3qrvs2kywr374rcjkgv2/spack-src/src/glx/dri_common.c": "/*\n * Copyright 1998-1999 Precision Insight, Inc., Cedar Park, Texas.\n * Copyright \u00a9 2008 Red Hat, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Soft-\n * ware\"), to deal in the Software without restriction, including without\n * limitation the rights to use, copy, modify, merge, publish, distribute,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, provided that the above copyright\n * notice(s) and this permission notice appear in all copies of the Soft-\n * ware and that both the above copyright notice(s) and this permission\n * notice appear in supporting documentation.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABIL-\n * ITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY\n * RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN\n * THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSE-\n * QUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,\n * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER\n * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFOR-\n * MANCE OF THIS SOFTWARE.\n *\n * Except as contained in this notice, the name of a copyright holder shall\n * not be used in advertising or otherwise to promote the sale, use or\n * other dealings in this Software without prior written authorization of\n * the copyright holder.\n *\n * Authors:\n *   Kevin E. Martin <kevin@precisioninsight.com>\n *   Brian Paul <brian@precisioninsight.com>\n *   Kristian H\u00f8gsberg (krh@redhat.com)\n */\n\n#if defined(GLX_DIRECT_RENDERING) && !defined(GLX_USE_APPLEGL)\n\n#include <unistd.h>\n#include <dlfcn.h>\n#include <stdarg.h>\n#include \"glxclient.h\"\n#include \"dri_common.h\"\n#include \"loader.h\"\n\n#ifndef RTLD_NOW\n#define RTLD_NOW 0\n#endif\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL 0\n#endif\n\n_X_HIDDEN void\ndri_message(int level, const char *f, ...)\n{\n   va_list args;\n   int threshold = _LOADER_WARNING;\n   const char *libgl_debug;\n\n   libgl_debug = getenv(\"LIBGL_DEBUG\");\n   if (libgl_debug) {\n      if (strstr(libgl_debug, \"quiet\"))\n         threshold = _LOADER_FATAL;\n      else if (strstr(libgl_debug, \"verbose\"))\n         threshold = _LOADER_DEBUG;\n   }\n\n   /* Note that the _LOADER_* levels are lower numbers for more severe. */\n   if (level <= threshold) {\n      fprintf(stderr, \"libGL%s: \", level <= _LOADER_WARNING ? \" error\" : \"\");\n      va_start(args, f);\n      vfprintf(stderr, f, args);\n      va_end(args);\n   }\n}\n\n#ifndef GL_LIB_NAME\n#define GL_LIB_NAME \"libGL.so.1\"\n#endif\n\n/**\n * Try to \\c dlopen the named driver.\n *\n * This function adds the \"_dri.so\" suffix to the driver name and searches the\n * directories specified by the \\c LIBGL_DRIVERS_PATH environment variable in\n * order to find the driver.\n *\n * \\param driverName - a name like \"i965\", \"radeon\", \"nouveau\", etc.\n * \\param out_driver_handle - Address to return the resulting dlopen() handle.\n *\n * \\returns\n * The __DRIextension entrypoint table for the driver, or \\c NULL if driver\n * file not found.\n */\n_X_HIDDEN const __DRIextension **\ndriOpenDriver(const char *driverName, void **out_driver_handle)\n{\n   void *glhandle;\n\n   /* Attempt to make sure libGL symbols will be visible to the driver */\n   glhandle = dlopen(GL_LIB_NAME, RTLD_NOW | RTLD_GLOBAL);\n\n   static const char *search_path_vars[] = {\n      \"LIBGL_DRIVERS_PATH\",\n      \"LIBGL_DRIVERS_DIR\", /* deprecated */\n      NULL\n   };\n\n   const __DRIextension **extensions =\n      loader_open_driver(driverName, out_driver_handle, search_path_vars);\n\n   if (glhandle)\n      dlclose(glhandle);\n\n   return extensions;\n}\n\n#define __ATTRIB(attrib, field) \\\n    { attrib, offsetof(struct glx_config, field) }\n\nstatic const struct\n{\n   unsigned int attrib, offset;\n} attribMap[] = {\n   __ATTRIB(__DRI_ATTRIB_BUFFER_SIZE, rgbBits),\n      __ATTRIB(__DRI_ATTRIB_LEVEL, level),\n      __ATTRIB(__DRI_ATTRIB_RED_SIZE, redBits),\n      __ATTRIB(__DRI_ATTRIB_GREEN_SIZE, greenBits),\n      __ATTRIB(__DRI_ATTRIB_BLUE_SIZE, blueBits),\n      __ATTRIB(__DRI_ATTRIB_ALPHA_SIZE, alphaBits),\n      __ATTRIB(__DRI_ATTRIB_DEPTH_SIZE, depthBits),\n      __ATTRIB(__DRI_ATTRIB_STENCIL_SIZE, stencilBits),\n      __ATTRIB(__DRI_ATTRIB_ACCUM_RED_SIZE, accumRedBits),\n      __ATTRIB(__DRI_ATTRIB_ACCUM_GREEN_SIZE, accumGreenBits),\n      __ATTRIB(__DRI_ATTRIB_ACCUM_BLUE_SIZE, accumBlueBits),\n      __ATTRIB(__DRI_ATTRIB_ACCUM_ALPHA_SIZE, accumAlphaBits),\n      __ATTRIB(__DRI_ATTRIB_SAMPLE_BUFFERS, sampleBuffers),\n      __ATTRIB(__DRI_ATTRIB_SAMPLES, samples),\n      __ATTRIB(__DRI_ATTRIB_DOUBLE_BUFFER, doubleBufferMode),\n      __ATTRIB(__DRI_ATTRIB_STEREO, stereoMode),\n      __ATTRIB(__DRI_ATTRIB_AUX_BUFFERS, numAuxBuffers),\n#if 0\n      __ATTRIB(__DRI_ATTRIB_TRANSPARENT_TYPE, transparentPixel),\n      __ATTRIB(__DRI_ATTRIB_TRANSPARENT_INDEX_VALUE, transparentIndex),\n      __ATTRIB(__DRI_ATTRIB_TRANSPARENT_RED_VALUE, transparentRed),\n      __ATTRIB(__DRI_ATTRIB_TRANSPARENT_GREEN_VALUE, transparentGreen),\n      __ATTRIB(__DRI_ATTRIB_TRANSPARENT_BLUE_VALUE, transparentBlue),\n      __ATTRIB(__DRI_ATTRIB_TRANSPARENT_ALPHA_VALUE, transparentAlpha),\n      __ATTRIB(__DRI_ATTRIB_RED_MASK, redMask),\n      __ATTRIB(__DRI_ATTRIB_GREEN_MASK, greenMask),\n      __ATTRIB(__DRI_ATTRIB_BLUE_MASK, blueMask),\n      __ATTRIB(__DRI_ATTRIB_ALPHA_MASK, alphaMask),\n      __ATTRIB(__DRI_ATTRIB_RED_SHIFT, redShift),\n      __ATTRIB(__DRI_ATTRIB_GREEN_SHIFT, greenShift),\n      __ATTRIB(__DRI_ATTRIB_BLUE_SHIFT, blueShift),\n      __ATTRIB(__DRI_ATTRIB_ALPHA_SHIFT, alphaShift),\n#endif\n      __ATTRIB(__DRI_ATTRIB_MAX_PBUFFER_WIDTH, maxPbufferWidth),\n      __ATTRIB(__DRI_ATTRIB_MAX_PBUFFER_HEIGHT, maxPbufferHeight),\n      __ATTRIB(__DRI_ATTRIB_MAX_PBUFFER_PIXELS, maxPbufferPixels),\n      __ATTRIB(__DRI_ATTRIB_OPTIMAL_PBUFFER_WIDTH, optimalPbufferWidth),\n      __ATTRIB(__DRI_ATTRIB_OPTIMAL_PBUFFER_HEIGHT, optimalPbufferHeight),\n      __ATTRIB(__DRI_ATTRIB_SWAP_METHOD, swapMethod),\n      __ATTRIB(__DRI_ATTRIB_BIND_TO_TEXTURE_RGB, bindToTextureRgb),\n      __ATTRIB(__DRI_ATTRIB_BIND_TO_TEXTURE_RGBA, bindToTextureRgba),\n      __ATTRIB(__DRI_ATTRIB_BIND_TO_MIPMAP_TEXTURE,\n                     bindToMipmapTexture),\n      __ATTRIB(__DRI_ATTRIB_YINVERTED, yInverted),\n      __ATTRIB(__DRI_ATTRIB_FRAMEBUFFER_SRGB_CAPABLE, sRGBCapable)\n};\n\nstatic int\nscalarEqual(struct glx_config *mode, unsigned int attrib, unsigned int value)\n{\n   unsigned glxValue, i;\n\n   for (i = 0; i < ARRAY_SIZE(attribMap); i++)\n      if (attribMap[i].attrib == attrib) {\n         glxValue = *(unsigned int *) ((char *) mode + attribMap[i].offset);\n         return glxValue == GLX_DONT_CARE || glxValue == value;\n      }\n\n   return GL_TRUE;              /* Is a non-existing attribute equal to value? */\n}\n\nstatic int\ndriConfigEqual(const __DRIcoreExtension *core,\n               struct glx_config *config, const __DRIconfig *driConfig)\n{\n   unsigned int attrib, value, glxValue;\n   int i;\n\n   i = 0;\n   while (core->indexConfigAttrib(driConfig, i++, &attrib, &value)) {\n      switch (attrib) {\n      case __DRI_ATTRIB_RENDER_TYPE:\n         glxValue = 0;\n         if (value & __DRI_ATTRIB_RGBA_BIT) {\n            glxValue |= GLX_RGBA_BIT;\n         }\n         if (value & __DRI_ATTRIB_COLOR_INDEX_BIT) {\n            glxValue |= GLX_COLOR_INDEX_BIT;\n         }\n         if (value & __DRI_ATTRIB_FLOAT_BIT) {\n            glxValue |= GLX_RGBA_FLOAT_BIT_ARB;\n         }\n         if (value & __DRI_ATTRIB_UNSIGNED_FLOAT_BIT) {\n            glxValue |= GLX_RGBA_UNSIGNED_FLOAT_BIT_EXT;\n         }\n         if (glxValue != config->renderType)\n            return GL_FALSE;\n         break;\n\n      case __DRI_ATTRIB_CONFIG_CAVEAT:\n         if (value & __DRI_ATTRIB_NON_CONFORMANT_CONFIG)\n            glxValue = GLX_NON_CONFORMANT_CONFIG;\n         else if (value & __DRI_ATTRIB_SLOW_BIT)\n            glxValue = GLX_SLOW_CONFIG;\n         else\n            glxValue = GLX_NONE;\n         if (glxValue != config->visualRating)\n            return GL_FALSE;\n         break;\n\n      case __DRI_ATTRIB_BIND_TO_TEXTURE_TARGETS:\n         glxValue = 0;\n         if (value & __DRI_ATTRIB_TEXTURE_1D_BIT)\n            glxValue |= GLX_TEXTURE_1D_BIT_EXT;\n         if (value & __DRI_ATTRIB_TEXTURE_2D_BIT)\n            glxValue |= GLX_TEXTURE_2D_BIT_EXT;\n         if (value & __DRI_ATTRIB_TEXTURE_RECTANGLE_BIT)\n            glxValue |= GLX_TEXTURE_RECTANGLE_BIT_EXT;\n         if (config->bindToTextureTargets != GLX_DONT_CARE &&\n             glxValue != config->bindToTextureTargets)\n            return GL_FALSE;\n         break;\n\n      case __DRI_ATTRIB_SWAP_METHOD:\n         if (value == __DRI_ATTRIB_SWAP_EXCHANGE)\n            glxValue = GLX_SWAP_EXCHANGE_OML;\n         else if (value == __DRI_ATTRIB_SWAP_COPY)\n            glxValue = GLX_SWAP_COPY_OML;\n         else\n            glxValue = GLX_SWAP_UNDEFINED_OML;\n\n         if (!scalarEqual(config, attrib, glxValue))\n            return GL_FALSE;\n\n         break;\n\n      default:\n         if (!scalarEqual(config, attrib, value))\n            return GL_FALSE;\n      }\n   }\n\n   return GL_TRUE;\n}\n\nstatic struct glx_config *\ncreateDriMode(const __DRIcoreExtension * core,\n\t      struct glx_config *config, const __DRIconfig **driConfigs)\n{\n   __GLXDRIconfigPrivate *driConfig;\n   int i;\n\n   for (i = 0; driConfigs[i]; i++) {\n      if (driConfigEqual(core, config, driConfigs[i]))\n         break;\n   }\n\n   if (driConfigs[i] == NULL)\n      return NULL;\n\n   driConfig = malloc(sizeof *driConfig);\n   if (driConfig == NULL)\n      return NULL;\n\n   driConfig->base = *config;\n   driConfig->driConfig = driConfigs[i];\n\n   return &driConfig->base;\n}\n\n_X_HIDDEN struct glx_config *\ndriConvertConfigs(const __DRIcoreExtension * core,\n                  struct glx_config *configs, const __DRIconfig **driConfigs)\n{\n   struct glx_config head, *tail, *m;\n\n   tail = &head;\n   head.next = NULL;\n   for (m = configs; m; m = m->next) {\n      tail->next = createDriMode(core, m, driConfigs);\n      if (tail->next == NULL) {\n         /* no matching dri config for m */\n         continue;\n      }\n\n\n      tail = tail->next;\n   }\n\n   return head.next;\n}\n\n_X_HIDDEN void\ndriDestroyConfigs(const __DRIconfig **configs)\n{\n   int i;\n\n   for (i = 0; configs[i]; i++)\n      free((__DRIconfig *) configs[i]);\n   free(configs);\n}\n\nstatic struct glx_config *\ndriInferDrawableConfig(struct glx_screen *psc, GLXDrawable draw)\n{\n   unsigned int fbconfig = 0;\n\n   if (__glXGetDrawableAttribute(psc->dpy, draw, GLX_FBCONFIG_ID, &fbconfig)) {\n      return glx_config_find_fbconfig(psc->configs, fbconfig);\n   }\n\n   return NULL;\n}\n\n_X_HIDDEN __GLXDRIdrawable *\ndriFetchDrawable(struct glx_context *gc, GLXDrawable glxDrawable)\n{\n   struct glx_display *const priv = __glXInitialize(gc->psc->dpy);\n   __GLXDRIdrawable *pdraw;\n   struct glx_screen *psc;\n   struct glx_config *config = gc->config;\n\n   if (priv == NULL)\n      return NULL;\n\n   if (glxDrawable == None)\n      return NULL;\n\n   psc = priv->screens[gc->screen];\n   if (priv->drawHash == NULL)\n      return NULL;\n\n   if (__glxHashLookup(priv->drawHash, glxDrawable, (void *) &pdraw) == 0) {\n      pdraw->refcount ++;\n      return pdraw;\n   }\n\n   if (config == NULL)\n      config = driInferDrawableConfig(gc->psc, glxDrawable);\n   if (config == NULL)\n      return NULL;\n\n   pdraw = psc->driScreen->createDrawable(psc, glxDrawable, glxDrawable,\n                                          config);\n\n   if (pdraw == NULL) {\n      ErrorMessageF(\"failed to create drawable\\n\");\n      return NULL;\n   }\n\n   if (__glxHashInsert(priv->drawHash, glxDrawable, pdraw)) {\n      (*pdraw->destroyDrawable) (pdraw);\n      return NULL;\n   }\n   pdraw->refcount = 1;\n\n   return pdraw;\n}\n\n_X_HIDDEN void\ndriReleaseDrawables(struct glx_context *gc)\n{\n   const struct glx_display *priv = gc->psc->display;\n   __GLXDRIdrawable *pdraw;\n\n   if (priv == NULL)\n      return;\n\n   if (__glxHashLookup(priv->drawHash,\n\t\t       gc->currentDrawable, (void *) &pdraw) == 0) {\n      if (pdraw->drawable == pdraw->xDrawable) {\n\t pdraw->refcount --;\n\t if (pdraw->refcount == 0) {\n\t    pdraw->destroyDrawable(pdraw);\n\t    __glxHashDelete(priv->drawHash, gc->currentDrawable);\n\t }\n      }\n   }\n\n   if (__glxHashLookup(priv->drawHash,\n\t\t       gc->currentReadable, (void *) &pdraw) == 0) {\n      if (pdraw->drawable == pdraw->xDrawable) {\n\t pdraw->refcount --;\n\t if (pdraw->refcount == 0) {\n\t    pdraw->destroyDrawable(pdraw);\n\t    __glxHashDelete(priv->drawHash, gc->currentReadable);\n\t }\n      }\n   }\n\n   gc->currentDrawable = None;\n   gc->currentReadable = None;\n\n}\n\n_X_HIDDEN bool\ndri2_convert_glx_attribs(unsigned num_attribs, const uint32_t *attribs,\n                         unsigned *major_ver, unsigned *minor_ver,\n                         uint32_t *render_type, uint32_t *flags, unsigned *api,\n                         int *reset, int *release, unsigned *error)\n{\n   unsigned i;\n   bool got_profile = false;\n   int no_error = 0;\n   uint32_t profile;\n\n   *major_ver = 1;\n   *minor_ver = 0;\n   *render_type = GLX_RGBA_TYPE;\n   *reset = __DRI_CTX_RESET_NO_NOTIFICATION;\n   *release = __DRI_CTX_RELEASE_BEHAVIOR_FLUSH;\n   *flags = 0;\n   *api = __DRI_API_OPENGL;\n\n   if (num_attribs == 0) {\n      return true;\n   }\n\n   /* This is actually an internal error, but what the heck.\n    */\n   if (attribs == NULL) {\n      *error = __DRI_CTX_ERROR_UNKNOWN_ATTRIBUTE;\n      return false;\n   }\n\n   for (i = 0; i < num_attribs; i++) {\n      switch (attribs[i * 2]) {\n      case GLX_CONTEXT_MAJOR_VERSION_ARB:\n\t *major_ver = attribs[i * 2 + 1];\n\t break;\n      case GLX_CONTEXT_MINOR_VERSION_ARB:\n\t *minor_ver = attribs[i * 2 + 1];\n\t break;\n      case GLX_CONTEXT_FLAGS_ARB:\n\t *flags = attribs[i * 2 + 1];\n\t break;\n      case GLX_CONTEXT_OPENGL_NO_ERROR_ARB:\n\t no_error = attribs[i * 2 + 1];\n\t break;\n      case GLX_CONTEXT_PROFILE_MASK_ARB:\n\t profile = attribs[i * 2 + 1];\n\t got_profile = true;\n\t break;\n      case GLX_RENDER_TYPE:\n         *render_type = attribs[i * 2 + 1];\n\t break;\n      case GLX_CONTEXT_RESET_NOTIFICATION_STRATEGY_ARB:\n         switch (attribs[i * 2 + 1]) {\n         case GLX_NO_RESET_NOTIFICATION_ARB:\n            *reset = __DRI_CTX_RESET_NO_NOTIFICATION;\n            break;\n         case GLX_LOSE_CONTEXT_ON_RESET_ARB:\n            *reset = __DRI_CTX_RESET_LOSE_CONTEXT;\n            break;\n         default:\n            *error = __DRI_CTX_ERROR_UNKNOWN_ATTRIBUTE;\n            return false;\n         }\n         break;\n      case GLX_CONTEXT_RELEASE_BEHAVIOR_ARB:\n         switch (attribs[i * 2 + 1]) {\n         case GLX_CONTEXT_RELEASE_BEHAVIOR_NONE_ARB:\n            *release = __DRI_CTX_RELEASE_BEHAVIOR_NONE;\n            break;\n         case GLX_CONTEXT_RELEASE_BEHAVIOR_FLUSH_ARB:\n            *release = __DRI_CTX_RELEASE_BEHAVIOR_FLUSH;\n            break;\n         default:\n            *error = __DRI_CTX_ERROR_UNKNOWN_ATTRIBUTE;\n            return false;\n         }\n         break;\n      default:\n\t /* If an unknown attribute is received, fail.\n\t  */\n\t *error = __DRI_CTX_ERROR_UNKNOWN_ATTRIBUTE;\n\t return false;\n      }\n   }\n\n   if (no_error) {\n      *flags |= __DRI_CTX_FLAG_NO_ERROR;\n   }\n\n   if (!got_profile) {\n      if (*major_ver > 3 || (*major_ver == 3 && *minor_ver >= 2))\n\t *api = __DRI_API_OPENGL_CORE;\n   } else {\n      switch (profile) {\n      case GLX_CONTEXT_CORE_PROFILE_BIT_ARB:\n\t /* There are no profiles before OpenGL 3.2.  The\n\t  * GLX_ARB_create_context_profile spec says:\n\t  *\n\t  *     \"If the requested OpenGL version is less than 3.2,\n\t  *     GLX_CONTEXT_PROFILE_MASK_ARB is ignored and the functionality\n\t  *     of the context is determined solely by the requested version.\"\n\t  */\n\t *api = (*major_ver > 3 || (*major_ver == 3 && *minor_ver >= 2))\n\t    ? __DRI_API_OPENGL_CORE : __DRI_API_OPENGL;\n\t break;\n      case GLX_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB:\n\t *api = __DRI_API_OPENGL;\n\t break;\n      case GLX_CONTEXT_ES_PROFILE_BIT_EXT:\n         if (*major_ver >= 3)\n            *api = __DRI_API_GLES3;\n         else if (*major_ver == 2 && *minor_ver == 0)\n            *api = __DRI_API_GLES2;\n         else if (*major_ver == 1 && *minor_ver < 2)\n            *api = __DRI_API_GLES;\n         else {\n            *error = __DRI_CTX_ERROR_BAD_API;\n            return false;\n         }\n         break;\n      default:\n\t *error = __DRI_CTX_ERROR_BAD_API;\n\t return false;\n      }\n   }\n\n   /* Unknown flag value.\n    */\n   if (*flags & ~(__DRI_CTX_FLAG_DEBUG | __DRI_CTX_FLAG_FORWARD_COMPATIBLE\n                  | __DRI_CTX_FLAG_ROBUST_BUFFER_ACCESS\n                  | __DRI_CTX_FLAG_NO_ERROR)) {\n      *error = __DRI_CTX_ERROR_UNKNOWN_FLAG;\n      return false;\n   }\n\n   /* There are no forward-compatible contexts before OpenGL 3.0.  The\n    * GLX_ARB_create_context spec says:\n    *\n    *     \"Forward-compatible contexts are defined only for OpenGL versions\n    *     3.0 and later.\"\n    */\n   if (*major_ver < 3 && (*flags & __DRI_CTX_FLAG_FORWARD_COMPATIBLE) != 0) {\n      *error = __DRI_CTX_ERROR_BAD_FLAG;\n      return false;\n   }\n\n   if (*major_ver >= 3 && *render_type == GLX_COLOR_INDEX_TYPE) {\n      *error = __DRI_CTX_ERROR_BAD_FLAG;\n      return false;\n   }\n\n   *error = __DRI_CTX_ERROR_SUCCESS;\n   return true;\n}\n\n_X_HIDDEN bool\ndri2_check_no_error(uint32_t flags, struct glx_context *share_context,\n                    int major, unsigned *error)\n{\n   Bool noError = flags & __DRI_CTX_FLAG_NO_ERROR;\n\n   /* The KHR_no_error specs say:\n    *\n    *    Requires OpenGL ES 2.0 or OpenGL 2.0.\n    */\n   if (noError && major < 2) {\n      *error = __DRI_CTX_ERROR_UNKNOWN_ATTRIBUTE;\n      return false;\n   }\n\n   /* The GLX_ARB_create_context_no_error specs say:\n    *\n    *    BadMatch is generated if the value of GLX_CONTEXT_OPENGL_NO_ERROR_ARB\n    *    used to create <share_context> does not match the value of\n    *    GLX_CONTEXT_OPENGL_NO_ERROR_ARB for the context being created.\n    */\n   if (share_context && !!share_context->noError != !!noError) {\n      *error = __DRI_CTX_ERROR_BAD_FLAG;\n      return false;\n   }\n\n   /* The GLX_ARB_create_context_no_error specs say:\n    *\n    *    BadMatch is generated if the GLX_CONTEXT_OPENGL_NO_ERROR_ARB is TRUE at\n    *    the same time as a debug or robustness context is specified.\n    *\n    */\n   if (noError && ((flags & __DRI_CTX_FLAG_DEBUG) ||\n                   (flags & __DRI_CTX_FLAG_ROBUST_BUFFER_ACCESS))) {\n      *error = __DRI_CTX_ERROR_BAD_FLAG;\n      return false;\n   }\n\n   return true;\n}\n\nstruct glx_context *\ndri_common_create_context(struct glx_screen *base,\n                          struct glx_config *config_base,\n                          struct glx_context *shareList,\n                          int renderType)\n{\n   unsigned int error;\n   uint32_t attribs[2] = { GLX_RENDER_TYPE, renderType };\n\n   return base->vtable->create_context_attribs(base, config_base, shareList,\n                                               1, attribs, &error);\n}\n\n\n/*\n * Given a display pointer and screen number, determine the name of\n * the DRI driver for the screen (i.e., \"i965\", \"radeon\", \"nouveau\", etc).\n * Return True for success, False for failure.\n */\nstatic Bool\ndriGetDriverName(Display * dpy, int scrNum, char **driverName)\n{\n   struct glx_screen *glx_screen = GetGLXScreenConfigs(dpy, scrNum);\n\n   if (!glx_screen || !glx_screen->vtable->get_driver_name)\n      return False;\n\n   *driverName = glx_screen->vtable->get_driver_name(glx_screen);\n   return True;\n}\n\n/*\n * Exported function for querying the DRI driver for a given screen.\n *\n * The returned char pointer points to a static array that will be\n * overwritten by subsequent calls.\n */\n_GLX_PUBLIC const char *\nglXGetScreenDriver(Display * dpy, int scrNum)\n{\n   static char ret[32];\n   char *driverName;\n\n   if (driGetDriverName(dpy, scrNum, &driverName)) {\n      int len;\n      if (!driverName)\n         return NULL;\n      len = strlen(driverName);\n      if (len >= 31)\n         return NULL;\n      memcpy(ret, driverName, len + 1);\n      free(driverName);\n      return ret;\n   }\n   return NULL;\n}\n\n/* glXGetDriverConfig must return a pointer with a static lifetime. To avoid\n * keeping drivers loaded and other leaks, we keep a cache of results here that\n * is cleared by an atexit handler.\n */\nstruct driver_config_entry {\n   struct driver_config_entry *next;\n   char *driverName;\n   char *config;\n};\n\nstatic pthread_mutex_t driver_config_mutex = PTHREAD_MUTEX_INITIALIZER;\nstatic struct driver_config_entry *driver_config_cache = NULL;\n\n/* Called as an atexit function. Otherwise, this would have to be called with\n * driver_config_mutex locked.\n */\nstatic void\nclear_driver_config_cache()\n{\n   while (driver_config_cache) {\n      struct driver_config_entry *e = driver_config_cache;\n      driver_config_cache = e->next;\n\n      free(e->driverName);\n      free(e->config);\n      free(e);\n   }\n}\n\nstatic char *\nget_driver_config(const char *driverName)\n{\n   void *handle;\n   char *config = NULL;\n   const __DRIextension **extensions = driOpenDriver(driverName, &handle);\n   if (extensions) {\n      for (int i = 0; extensions[i]; i++) {\n         if (strcmp(extensions[i]->name, __DRI_CONFIG_OPTIONS) != 0)\n            continue;\n\n         __DRIconfigOptionsExtension *ext =\n            (__DRIconfigOptionsExtension *)extensions[i];\n\n         if (ext->base.version >= 2)\n            config = ext->getXml(driverName);\n         else\n            config = strdup(ext->xml);\n\n         break;\n      }\n   }\n\n   if (!config) {\n      /* Fall back to the old method */\n      config = dlsym(handle, \"__driConfigOptions\");\n      if (config)\n         config = strdup(config);\n   }\n\n   dlclose(handle);\n\n   return config;\n}\n\n/*\n * Exported function for obtaining a driver's option list (UTF-8 encoded XML).\n *\n * The returned char pointer points directly into the driver. Therefore\n * it should be treated as a constant.\n *\n * If the driver was not found or does not support configuration NULL is\n * returned.\n */\n_GLX_PUBLIC const char *\nglXGetDriverConfig(const char *driverName)\n{\n   struct driver_config_entry *e;\n\n   pthread_mutex_lock(&driver_config_mutex);\n\n   for (e = driver_config_cache; e; e = e->next) {\n      if (strcmp(e->driverName, driverName) == 0)\n         goto out;\n   }\n\n   e = malloc(sizeof(*e));\n   if (!e)\n      goto out;\n\n   e->config = get_driver_config(driverName);\n   e->driverName = strdup(driverName);\n   if (!e->config || !e->driverName) {\n      free(e->config);\n      free(e->driverName);\n      free(e);\n      e = NULL;\n      goto out;\n   }\n\n   e->next = driver_config_cache;\n   driver_config_cache = e;\n\n   if (!e->next)\n      atexit(clear_driver_config_cache);\n\nout:\n   pthread_mutex_unlock(&driver_config_mutex);\n\n   return e ? e->config : NULL;\n}\n\n#endif /* GLX_DIRECT_RENDERING */\n",
        "/tmp/vanessa/spack-stage/spack-stage-mesa-master-nrat2nfszfps3qrvs2kywr374rcjkgv2/spack-src/src/glx/windows/windowsgl.c": "/*\n * Copyright \u00a9 2014 Jon Turney\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice (including the next\n * paragraph) shall be included in all copies or substantial portions of the\n * Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\n#include \"windowsgl.h\"\n#include \"windowsgl_internal.h\"\n\n#include \"glapi.h\"\n#include \"wgl.h\"\n\n#include <dlfcn.h>\n#include <assert.h>\n#include <stdio.h>\n#include <strings.h>\n\nstatic struct _glapi_table *windows_api = NULL;\n\nstatic void *\nwindows_get_dl_handle(void)\n{\n   static void *dl_handle = NULL;\n\n   if (!dl_handle)\n      dl_handle = dlopen(\"cygnativeGLthunk.dll\", RTLD_NOW);\n\n   return dl_handle;\n}\n\nstatic void\nwindows_glapi_create_table(void)\n{\n   if (windows_api)\n      return;\n\n   windows_api = _glapi_create_table_from_handle(windows_get_dl_handle(), \"gl\");\n   assert(windows_api);\n}\n\nstatic void windows_glapi_set_dispatch(void)\n{\n   windows_glapi_create_table();\n   _glapi_set_dispatch(windows_api);\n}\n\nwindowsContext *\nwindows_create_context(int pxfi, windowsContext *shared)\n{\n   windowsContext *gc;\n\n   gc = calloc(1, sizeof *gc);\n   if (gc == NULL)\n      return NULL;\n\n   // create a temporary, invisible window\n#define GL_TEMP_WINDOW_CLASS \"glTempWndClass\"\n   {\n      static wATOM glTempWndClass = 0;\n\n      if (glTempWndClass == 0) {\n         WNDCLASSEX wc;\n         wc.cbSize = sizeof(WNDCLASSEX);\n         wc.style = CS_HREDRAW | CS_VREDRAW;\n         wc.lpfnWndProc = DefWindowProc;\n         wc.cbClsExtra = 0;\n         wc.cbWndExtra = 0;\n         wc.hInstance = GetModuleHandle(NULL);\n         wc.hIcon = 0;\n         wc.hCursor = 0;\n         wc.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH);\n         wc.lpszMenuName = NULL;\n         wc.lpszClassName = GL_TEMP_WINDOW_CLASS;\n         wc.hIconSm = 0;\n         RegisterClassEx(&wc);\n      }\n   }\n\n   HWND hwnd = CreateWindowExA(0,\n                               GL_TEMP_WINDOW_CLASS,\n                               \"glWindow\",\n                               0,\n                               0, 0, 0, 0,\n                               NULL, NULL, GetModuleHandle(NULL), NULL);\n   HDC hdc = GetDC(hwnd);\n\n   // We must set the windows pixel format before we can create a WGL context\n   gc->pxfi = pxfi;\n   SetPixelFormat(hdc, gc->pxfi, NULL);\n\n   gc->ctx = wglCreateContext(hdc);\n\n   if (shared && gc->ctx)\n      wglShareLists(shared->ctx, gc->ctx);\n\n   ReleaseDC(hwnd, hdc);\n   DestroyWindow(hwnd);\n\n   if (!gc->ctx)\n   {\n     free(gc);\n     return NULL;\n   }\n\n   return gc;\n}\n\nwindowsContext *\nwindows_create_context_attribs(int pxfi, windowsContext *shared, const int *attribList)\n{\n   windowsContext *gc;\n\n   gc = calloc(1, sizeof *gc);\n   if (gc == NULL)\n      return NULL;\n\n   // create a temporary, invisible window\n#define GL_TEMP_WINDOW_CLASS \"glTempWndClass\"\n   {\n      static wATOM glTempWndClass = 0;\n\n      if (glTempWndClass == 0) {\n         WNDCLASSEX wc;\n         wc.cbSize = sizeof(WNDCLASSEX);\n         wc.style = CS_HREDRAW | CS_VREDRAW;\n         wc.lpfnWndProc = DefWindowProc;\n         wc.cbClsExtra = 0;\n         wc.cbWndExtra = 0;\n         wc.hInstance = GetModuleHandle(NULL);\n         wc.hIcon = 0;\n         wc.hCursor = 0;\n         wc.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH);\n         wc.lpszMenuName = NULL;\n         wc.lpszClassName = GL_TEMP_WINDOW_CLASS;\n         wc.hIconSm = 0;\n         RegisterClassEx(&wc);\n      }\n   }\n\n   HWND hwnd = CreateWindowExA(0,\n                               GL_TEMP_WINDOW_CLASS,\n                               \"glWindow\",\n                               0,\n                               0, 0, 0, 0,\n                               NULL, NULL, GetModuleHandle(NULL), NULL);\n   HDC hdc = GetDC(hwnd);\n   HGLRC shareContext = NULL;\n   if (shared)\n      shareContext = shared->ctx;\n\n   // We must set the windows pixel format before we can create a WGL context\n   gc->pxfi = pxfi;\n   SetPixelFormat(hdc, gc->pxfi, NULL);\n\n   gc->ctx = wglCreateContextAttribsARB(hdc, shareContext, attribList);\n\n   ReleaseDC(hwnd, hdc);\n   DestroyWindow(hwnd);\n\n   if (!gc->ctx)\n   {\n     free(gc);\n     return NULL;\n   }\n\n   return gc;\n}\n\nvoid\nwindows_destroy_context(windowsContext *context)\n{\n   wglDeleteContext(context->ctx);\n   context->ctx = NULL;\n   free(context);\n}\n\nint windows_bind_context(windowsContext *context, windowsDrawable *draw, windowsDrawable *read)\n{\n   HDC drawDc = draw->callbacks->getdc(draw);\n\n   if (!draw->pxfi)\n   {\n      SetPixelFormat(drawDc, context->pxfi, NULL);\n      draw->pxfi = context->pxfi;\n   }\n\n   if ((read != NULL) &&  (read != draw))\n   {\n      /*\n        If there is a separate read drawable, create a separate read DC, and\n        use the wglMakeContextCurrent extension to make the context current\n        drawing to one DC and reading from the other\n\n        Should only occur when WGL_ARB_make_current_read extension is present\n      */\n      HDC readDc = read->callbacks->getdc(read);\n\n      BOOL ret = wglMakeContextCurrentARB(drawDc, readDc, context->ctx);\n\n      read->callbacks->releasedc(read, readDc);\n\n      if (!ret) {\n         printf(\"wglMakeContextCurrentARB error: %08x\\n\", (int)GetLastError());\n         return FALSE;\n      }\n   }\n   else\n   {\n      /* Otherwise, just use wglMakeCurrent */\n      BOOL ret = wglMakeCurrent(drawDc, context->ctx);\n      if (!ret) {\n         printf(\"wglMakeCurrent error: %08x\\n\", (int)GetLastError());\n         return FALSE;\n      }\n   }\n\n   draw->callbacks->releasedc(draw, drawDc);\n\n   windows_glapi_set_dispatch();\n\n   return TRUE;\n}\n\nvoid windows_unbind_context(windowsContext * context)\n{\n   wglMakeCurrent(NULL, NULL);\n}\n\n/*\n *\n */\n\nvoid\nwindows_swap_buffers(windowsDrawable *draw)\n{\n   HDC drawDc = GetDC(draw->hWnd);\n   SwapBuffers(drawDc);\n   ReleaseDC(draw->hWnd, drawDc);\n}\n\n\ntypedef void (__stdcall * PFNGLADDSWAPHINTRECTWIN) (GLint x, GLint y,\n                                                    GLsizei width,\n                                                    GLsizei height);\n\nstatic void\nglAddSwapHintRectWIN(GLint x, GLint y, GLsizei width,\n                            GLsizei height)\n{\n   PFNGLADDSWAPHINTRECTWIN proc = (PFNGLADDSWAPHINTRECTWIN)wglGetProcAddress(\"glAddSwapHintRectWIN\");\n   if (proc)\n      proc(x, y, width, height);\n}\n\nvoid\nwindows_copy_subbuffer(windowsDrawable *draw,\n                      int x, int y, int width, int height)\n{\n   glAddSwapHintRectWIN(x, y, width, height);\n   windows_swap_buffers(draw);\n}\n\n/*\n * Helper function for calling a test function on an initial context\n */\nstatic void\nwindows_call_with_context(void (*proc)(HDC, void *), void *args)\n{\n   // create window class\n#define WIN_GL_TEST_WINDOW_CLASS \"GLTest\"\n   {\n      static wATOM glTestWndClass = 0;\n\n      if (glTestWndClass == 0) {\n         WNDCLASSEX wc;\n\n         wc.cbSize = sizeof(WNDCLASSEX);\n         wc.style = CS_HREDRAW | CS_VREDRAW;\n         wc.lpfnWndProc = DefWindowProc;\n         wc.cbClsExtra = 0;\n         wc.cbWndExtra = 0;\n         wc.hInstance = GetModuleHandle(NULL);\n         wc.hIcon = 0;\n         wc.hCursor = 0;\n         wc.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH);\n         wc.lpszMenuName = NULL;\n         wc.lpszClassName = WIN_GL_TEST_WINDOW_CLASS;\n         wc.hIconSm = 0;\n         glTestWndClass = RegisterClassEx(&wc);\n      }\n   }\n\n   // create an invisible window for a scratch DC\n   HWND hwnd = CreateWindowExA(0,\n                               WIN_GL_TEST_WINDOW_CLASS,\n                               \"GL Renderer Capabilities Test Window\",\n                               0, 0, 0, 0, 0, NULL, NULL, GetModuleHandle(NULL),\n                               NULL);\n   if (hwnd) {\n      HDC hdc = GetDC(hwnd);\n\n      // we must set a pixel format before we can create a context, just use the first one...\n      SetPixelFormat(hdc, 1, NULL);\n      HGLRC hglrc = wglCreateContext(hdc);\n      wglMakeCurrent(hdc, hglrc);\n\n      // call the test function\n      proc(hdc, args);\n\n      // clean up\n      wglMakeCurrent(NULL, NULL);\n      wglDeleteContext(hglrc);\n      ReleaseDC(hwnd, hdc);\n      DestroyWindow(hwnd);\n   }\n}\n\nstatic void\nwindows_check_render_test(HDC hdc, void *args)\n{\n   int *result = (int *)args;\n\n   /* Rather than play linkage games using stdcall to ensure we get\n      glGetString from opengl32.dll here, use dlsym */\n   void *dlhandle = windows_get_dl_handle();\n   const char *(*proc)(int) = dlsym(dlhandle, \"glGetString\");\n   const char *gl_renderer = (const char *)proc(GL_RENDERER);\n\n   if ((!gl_renderer) || (strcasecmp(gl_renderer, \"GDI Generic\") == 0))\n      *result = FALSE;\n   else\n      *result = TRUE;\n}\n\nint\nwindows_check_renderer(void)\n{\n   int result;\n   windows_call_with_context(windows_check_render_test, &result);\n   return result;\n}\n\ntypedef struct {\n   char *gl_extensions;\n   char *wgl_extensions;\n} windows_extensions_result;\n\nstatic void\nwindows_extensions_test(HDC hdc, void *args)\n{\n   windows_extensions_result *r = (windows_extensions_result *)args;\n\n   void *dlhandle = windows_get_dl_handle();\n   const char *(*proc)(int) = dlsym(dlhandle, \"glGetString\");\n\n   r->gl_extensions = strdup(proc(GL_EXTENSIONS));\n\n   wglResolveExtensionProcs();\n   r->wgl_extensions = strdup(wglGetExtensionsStringARB(hdc));\n}\n\nvoid\nwindows_extensions(char **gl_extensions, char **wgl_extensions)\n{\n   windows_extensions_result result;\n\n   *gl_extensions = \"\";\n   *wgl_extensions = \"\";\n\n   windows_call_with_context(windows_extensions_test, &result);\n\n   *gl_extensions = result.gl_extensions;\n   *wgl_extensions = result.wgl_extensions;\n}\n\nvoid windows_setTexBuffer(windowsContext *context, int textureTarget,\n                         int textureFormat, windowsDrawable *drawable)\n{\n   // not yet implemented\n}\n\nvoid windows_releaseTexBuffer(windowsContext *context, int textureTarget,\n                             windowsDrawable *drawable)\n{\n   // not yet implemented\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mesa-master-nrat2nfszfps3qrvs2kywr374rcjkgv2/spack-src/src/glx/apple/apple_cgl.c": "/*\n Copyright (c) 2008 Apple Inc.\n \n Permission is hereby granted, free of charge, to any person\n obtaining a copy of this software and associated documentation files\n (the \"Software\"), to deal in the Software without restriction,\n including without limitation the rights to use, copy, modify, merge,\n publish, distribute, sublicense, and/or sell copies of the Software,\n and to permit persons to whom the Software is furnished to do so,\n subject to the following conditions:\n \n The above copyright notice and this permission notice shall be\n included in all copies or substantial portions of the Software.\n \n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n NONINFRINGEMENT.  IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT\n HOLDER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n DEALINGS IN THE SOFTWARE.\n \n Except as contained in this notice, the name(s) of the above\n copyright holders shall not be used in advertising or otherwise to\n promote the sale, use or other dealings in this Software without\n prior written authorization.\n*/\n\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <dlfcn.h>\n\n#include \"apple_cgl.h\"\n#include \"apple_glx.h\"\n\n#ifndef OPENGL_FRAMEWORK_PATH\n#define OPENGL_FRAMEWORK_PATH \"/System/Library/Frameworks/OpenGL.framework/Versions/A/OpenGL\"\n#endif\n\nstatic void *dl_handle = NULL;\n\nstruct apple_cgl_api apple_cgl;\n\nstatic bool initialized = false;\n\nstatic void *\nsym(void *h, const char *name)\n{\n   void *s;\n\n   s = dlsym(h, name);\n\n   if (NULL == s) {\n      fprintf(stderr, \"error: %s\\n\", dlerror());\n      abort();\n   }\n\n   return s;\n}\n\nvoid\napple_cgl_init(void)\n{\n   void *h;\n   const char *opengl_framework_path;\n\n   if (initialized)\n      return;\n\n   opengl_framework_path = getenv(\"OPENGL_FRAMEWORK_PATH\");\n   if (!opengl_framework_path) {\n      opengl_framework_path = OPENGL_FRAMEWORK_PATH;\n   }\n\n   (void) dlerror();            /*drain dlerror */\n   h = dlopen(opengl_framework_path, RTLD_NOW);\n\n   if (NULL == h) {\n      fprintf(stderr, \"error: unable to dlopen %s : %s\\n\",\n              opengl_framework_path, dlerror());\n      abort();\n   }\n\n   dl_handle = h;\n\n   apple_cgl.get_version = sym(h, \"CGLGetVersion\");\n\n   apple_cgl.get_version(&apple_cgl.version_major, &apple_cgl.version_minor);\n\n   apple_glx_diagnostic(\"CGL major %d minor %d\\n\", apple_cgl.version_major, apple_cgl.version_minor);\n\n   if (1 != apple_cgl.version_major) {\n      fprintf(stderr, \"WARNING: the CGL major version has changed!\\n\"\n              \"libGL may be incompatible!\\n\");\n   }\n\n   apple_cgl.choose_pixel_format = sym(h, \"CGLChoosePixelFormat\");\n   apple_cgl.destroy_pixel_format = sym(h, \"CGLDestroyPixelFormat\");\n\n   apple_cgl.clear_drawable = sym(h, \"CGLClearDrawable\");\n   apple_cgl.flush_drawable = sym(h, \"CGLFlushDrawable\");\n\n   apple_cgl.create_context = sym(h, \"CGLCreateContext\");\n   apple_cgl.destroy_context = sym(h, \"CGLDestroyContext\");\n\n   apple_cgl.set_current_context = sym(h, \"CGLSetCurrentContext\");\n   apple_cgl.get_current_context = sym(h, \"CGLGetCurrentContext\");\n   apple_cgl.error_string = sym(h, \"CGLErrorString\");\n\n   apple_cgl.set_off_screen = sym(h, \"CGLSetOffScreen\");\n\n   apple_cgl.copy_context = sym(h, \"CGLCopyContext\");\n\n   apple_cgl.create_pbuffer = sym(h, \"CGLCreatePBuffer\");\n   apple_cgl.destroy_pbuffer = sym(h, \"CGLDestroyPBuffer\");\n   apple_cgl.set_pbuffer = sym(h, \"CGLSetPBuffer\");\n\n   initialized = true;\n}\n\nvoid *\napple_cgl_get_dl_handle(void)\n{\n   return dl_handle;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mesa-master-nrat2nfszfps3qrvs2kywr374rcjkgv2/spack-src/docs/libGL.txt": "\n\n\nIntroduction\n------------\n\nThis document describes the implementation of the XFree86 4.0 libGL.so\nlibrary defined by the Linux/OpenGL Base specification found at\nhttp://reality.sgi.com/opengl/linux/linuxbase.html.\n\nThe documentation is divided into two sections:\n    User's Guide\n    Driver Developer's Guide\n\nAuthor:  Brian Paul     (brian@precisioninsight.com)\nDate:    February 2000\n\n\n\nUser's Guide\n------------\n\nUsing libGL.so\n\nThe libGL.so library defines the gl- and glX-prefixed functions needed to\nrun OpenGL programs.  OpenGL client applications should link with the\n-lGL option to use it.\n\nlibGL.so serves two primary functions: GLX protocol generation for indirect\nrendering and loading/management of hardware drivers for direct rendering.\n\nWhen libGL.so initializes itself it uses the DRI to determine the\nappropriate hardware driver for each screen on the local X display.\nThe hardware drivers are expected to be in the /usr/X11R6/lib/modules/dri/\ndirectory.  Drivers are named with the convention <name>_dri.so where\n<name> is a driver such as \"radeon\", \"i965\", \"nouveau\", etc.\n\nThe LIBGL_DRIVERS_DIR environment variable may be used to specify a\ndifferent DRI modules directory, overriding /usr/X11R6/lib/modules/dri/.\nThis environment variable is ignored in setuid programs for security\nreasons.\n\nWhen libGL.so is unable to locate appropriate hardware drivers it will\nfall back to using indirect GLX rendering.\n\nTo aid in solving problems, libGL.so will print diagnostic messages to\nstderr if the LIBGL_DEBUG environment variable is defined.\n\nlibGL.so is thread safe.  The overhead of thread safety for common,\nsingle-thread clients is negligible.  However, the overhead of thread\nsafety for multi-threaded clients is significant.  Each GL API call\nrequires two calls to pthread_get_specific() which can noticeably\nimpact performance.  Warning:  libGL.so is thread safe but individual\nDRI drivers may not be.  Please consult the documentation for a driver\nto learn if it is thread safe.\n\n\n\nIndirect Rendering\n\nYou can force indirect rendering mode by setting the LIBGL_ALWAYS_INDIRECT\nenvironment variable to `true`.  Hardware acceleration will not be used.\n\n\n\nlibGL.so Extensibility\n\nlibGL.so is designed to be extended without upgrading.  That is,\ndrivers may install new OpenGL extension functions into libGL.so\nwithout requiring libGL.so to be replaced.  Clients of libGL.so should\nuse the glXGetProcAddressEXT() function to obtain the address of\nfunctions by name.  For more details of GLX_ARB_get_proc_address see\nhttp://oss.sgi.com/projects/ogl-sample/registry/ARB/get_proc_address.spec\n\nlibGL.so is also designed with flexibility such that it may be used\nwith many generations of hardware drivers to come.\n\n\n\n\nDriver Developer's Guide\n------------------------\n\nThis section describes the requirements to make an XFree86 4.0\nlibGL.so-compatible hardware driver.  It is not intended for end\nusers of libGL.so.\n\n\nXFree86 source files\n\nlibGL.so is built inside XFree86 with sources found in xc/lib/GL/.\nSpecifically, libGL.so is built from:\n\n\txc/lib/GL/glx/*.c\n\txc/lib/dri/XF86dri.c\n\txc/lib/dri/dri_glx.c\n\txc/lib/GL/mesa/src/glapi.c\n\txc/lib/GL/mesa/src/glapitemp.h\n\txc/lib/GL/mesa/src/glapitable.h\n\txc/lib/GL/mesa/src/glapioffsets.h\n\txc/lib/GL/mesa/src/glapinoop.c\n\txc/lib/GL/mesa/src/glheader.h\n\txc/lib/GL/mesa/src/glthread.c\n\txc/lib/GL/mesa/src/glthread.h\n\txc/lib/GL/mesa/src/X86/glapi_x86.S\n\txc/lib/GL/mesa/src/X86/assyntax.h\n\nUnderstand that the mesa/src/gl*.[ch] files are not tied to Mesa.  They\nhave no dependencies on the rest of Mesa and are designed to be reusable\nin a number of projects.\n\nThe glapi_x86.X and assyntax.h files implement x86-optimized dispatch\nof GL functions.  They are not required; C-based dispatch can be used\ninstead, with a slight performance penalty.\n\n\n\nDriver loading and binding\n\nWhen libGL.so initializes itself (via the __glXInitialize function) a\ncall is made to driCreateDisplay().  This function uses DRI facilities\nto determine the driver file appropriate for each screen on the local\ndisplay.  Each screen's driver is then opened with dlopen() and asked\nfor its __driCreateScreen() function.  The pointers to the __driCreateScreen()\nfunctions are kept in an array, indexed by screen number, in the\n__DRIdisplayRec struct.\n\nWhen a driver's __driCreateScreen() function is called, it must initialize\na __DRIscreenRec struct.  This struct acts as the root of a tree of\nfunction pointers which are called to create and destroy contexts and\ndrawables and perform all the operations needed by the GLX interface.\nSee the xc/lib/GL/glx/glxclient.h file for details.\n\n\n\nDynamic Extension Function Registration\n\nIn order to provide forward compatibility with future drivers, libGL.so\nallows drivers to register new OpenGL extension functions which weren't\nknown when libGL.so was built.\n\nThe register_extensions() function in xc/lib/GL/dri/dri_glx.c is called\nas soon as libGL.so is loaded.  This is done with gcc's constructor\nattribute.  This mechanism will likely have to be changed for other compilers.\n\nregister_extensions() loops over all local displays and screens, determines\nthe DRI driver for each, and calls the driver's __driRegisterExtensions()\nfunction, if present.\n\nThe __driRegisterExtensions() function can add new entrypoints to libGL\nby calling:\n\n    GLboolean _glapi_add_entrypoint(const char *funcName, GLuint offset)\n\nThe parameters are the name of the function (such as \"glFoobarEXT\") and the\noffset of the dispatch slot in the API dispatch table.  The return value\nindicates success (GL_TRUE) or failure (GL_FALSE).\n\n_glapi_add_entrypoint() will synthesize entrypoint code in assembly\nlanguage.  Assembly languages is required since parameter passing\ncan't be handled correctly using a C-based solution.\n\nThe address of the new entrypoint is obtained by calling the\nglXGetProcAddressARB() function.\n\nThe dispatch offset number MUST be a number allocated by SGI in the same\nmanner in which new GL_* constants are allocated.  Using an arbitrary\noffset number will result in many problems.\n\n\n\nDispatch Management\n\nWhen a GL context is made current, the driver must install its dispatch\ntable as the current dispatch table.  This is done by calling\n\n\tvoid _glapi_set_dispatch(struct _glapi_table *dispatch);\n\nThis will install the named dispatch table for the calling thread.\nThe current dispatch table for a thread can be obtained by calling\n\n\tstruct _glapi_table *_glapi_get_dispatch(void);\n\nFor higher performance in the common single-thread case, the global\nvariable _glapi_Dispatch will point to the current dispatch table.\nThis variable will be NULL when in multi-thread mode.\n\n\n\nContext Management\n\nlibGL.so uses the XFree86 xthreads package to manage a thread-specific\ncurrent context pointer.  See __glXGet/SetCurrentContext() in glext.c\n\nDrivers may use the _glapi_set/get_context() functions to maintain\na private thread-specific context pointer.\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-mesa-master-nrat2nfszfps3qrvs2kywr374rcjkgv2/spack-src/docs/relnotes/10.0.rst": "Mesa 10.0 Release Notes / (November 30th, 2013)\n===============================================\n\nMesa 10.0 is a new development release. People who are concerned with\nstability and reliability should stick with a previous release or wait\nfor Mesa 10.0.1.\n\nMesa 10.0 implements the OpenGL 3.3 API, but the version reported by\nglGetString(GL_VERSION) or glGetIntegerv(GL_MAJOR_VERSION) /\nglGetIntegerv(GL_MINOR_VERSION) depends on the particular driver being\nused. Some drivers don't support all the features required in OpenGL\n3.3. OpenGL 3.3 is **only** available if requested at context creation\nbecause compatibility contexts are not supported.\n\nMD5 checksums\n-------------\n\n::\n\n   b38626b96c664db67a534d7859682436  MesaLib-10.0.0.tar.gz\n   f3fe55d9735bea158bbe97ed9a0da819  MesaLib-10.0.0.tar.bz2\n   c6ee1ce51e3bf35947d2978b872daf51  MesaLib-10.0.0.zip\n\nNew features\n------------\n\nNote: some of the new features are only available with certain drivers.\n\n-  GL_AMD_seamless_cubemap_per_texture on i965.\n-  GL_ARB_conservative_depth on i965.\n-  GL_ARB_texture_gather on i965.\n-  GL_ARB_texture_query_levels on i965.\n-  GL_ARB_texture_mirror_clamp_to_edge.\n-  GL_ARB_transform_feedback2, GL_ARB_transform_feedback3, and\n   GL_ARB_transform_feedback_instanced on i965/Gen7 (with appropriate\n   kernel support).\n-  GL_ARB_sample_shading on i965.\n-  GL_ARB_shader_atomic_counters on i965.\n-  GL_ARB_vertex_attrib_binding\n-  GL_ARB_vertex_type_10f_11f_11f_rev on i965 and r600g\n-  GL_KHR_debug\n-  GLX_MESA_query_renderer\n\nBug fixes\n---------\n\nAttempts have been made to **not** include bugs fixed in previous 9.2\nreleases or bugs that were regressions during 10.0 development. This\nlist is likely incomplete.\n\n-  `Bug 47755 <https://bugs.freedesktop.org/show_bug.cgi?id=47755>`__ -\n   [glsl-compiler] no error checking when Interpolation qualifier for\n   built-in variable is different in vertex and fragment shader\n-  `Bug 52171 <https://bugs.freedesktop.org/show_bug.cgi?id=52171>`__ -\n   [gallium/r600/clover] Simple benchmarks failed to run\n-  `Bug 53077 <https://bugs.freedesktop.org/show_bug.cgi?id=53077>`__ -\n   [IVB] Output error with msaa when both of framebuffer and source\n   color's alpha are not 1\n-  `Bug 54867 <https://bugs.freedesktop.org/show_bug.cgi?id=54867>`__ -\n   bug in r300 compiler\n-  `Bug 60929 <https://bugs.freedesktop.org/show_bug.cgi?id=60929>`__ -\n   [r600-llvm] mono games with opengl are blocking on start\n-  `Bug 62142 <https://bugs.freedesktop.org/show_bug.cgi?id=62142>`__ -\n   Mesa/demo mipmap_limits upside down with running by SOFTWARE\n-  `Bug 62698 <https://bugs.freedesktop.org/show_bug.cgi?id=62698>`__ -\n   [bisected] WebGL demo \"Consumed\": texstate.c:628:\n   update_texture_state: Assertion \u201e__builtin_popcount(enabledTargets)\n   == 1\u201c failed.\n-  `Bug 64225 <https://bugs.freedesktop.org/show_bug.cgi?id=64225>`__ -\n   bfgminer --scyte generates Segmentation Fault on Northern Island\n-  `Bug 64226 <https://bugs.freedesktop.org/show_bug.cgi?id=64226>`__ -\n   python-opencl package generate segmentation fault at pipe_r600.so\n-  `Bug 64261 <https://bugs.freedesktop.org/show_bug.cgi?id=64261>`__ -\n   [SNB Bisected]Ogles3conform\n   GL3Tests_color_buffer_float_color_buffer_float_clamp_fixed.test fail\n-  `Bug 66213 <https://bugs.freedesktop.org/show_bug.cgi?id=66213>`__ -\n   Certain Mesa Demos Rendering Inverted (vertically)\n-  `Bug 66806 <https://bugs.freedesktop.org/show_bug.cgi?id=66806>`__ -\n   [softpipe] glxgears floating point exception\n-  `Bug 67921 <https://bugs.freedesktop.org/show_bug.cgi?id=67921>`__ -\n   [bisected commit 883987] crosscompiling fails with\n   util/u_cpu_detect.c:247:4: error: 'asm' undeclared (first use in this\n   function)\n-  `Bug 68162 <https://bugs.freedesktop.org/show_bug.cgi?id=68162>`__ -\n   [radeonsi] texture rendering is broken in Source-Engine games\n-  `Bug 68451 <https://bugs.freedesktop.org/show_bug.cgi?id=68451>`__ -\n   Texture flicker in native Dota2 in mesa 9.2.0rc1\n-  `Bug 68503 <https://bugs.freedesktop.org/show_bug.cgi?id=68503>`__ -\n   Graphical glitches in Serious Sam 3 when SB is enabled\n-  `Bug 68792 <https://bugs.freedesktop.org/show_bug.cgi?id=68792>`__ -\n   Problems during playback of h264 files using UVD and VLC on AMD E-350\n   CPU\n-  `Bug 68845 <https://bugs.freedesktop.org/show_bug.cgi?id=68845>`__ -\n   VDPAU/UVD regression\n-  `Bug 69078 <https://bugs.freedesktop.org/show_bug.cgi?id=69078>`__ -\n   Modern Warfare (1, 2 and 3) broken in Wine on SNB\n-  `Bug 69321 <https://bugs.freedesktop.org/show_bug.cgi?id=69321>`__ -\n   starting openCL crashes/boots system\n-  `Bug 70042 <https://bugs.freedesktop.org/show_bug.cgi?id=70042>`__ -\n   Major texture flickering in Dota 2 (r600g on HD 6950)\n-  `Bug 70088 <https://bugs.freedesktop.org/show_bug.cgi?id=70088>`__ -\n   Glamor on r600g crashes Xserver\n-  `Bug 70123 <https://bugs.freedesktop.org/show_bug.cgi?id=70123>`__ -\n   Freeze caused by 'winsys/radeon: remove cs_queue_empty' commit\n-  `Bug 70327 <https://bugs.freedesktop.org/show_bug.cgi?id=70327>`__ -\n   Casting floating point variable to integer not working properly while\n   constant gets converted properly\n-  `Bug 70891 <https://bugs.freedesktop.org/show_bug.cgi?id=70891>`__ -\n   CL_INVALID_BUILD_OPTIONS results in CL_INVALID_DEVICE when asking for\n   build log\n-  `Bug 70913 <https://bugs.freedesktop.org/show_bug.cgi?id=70913>`__ -\n   [PIGLIT,radeonsi] crash in\n   \"spec/EXT_framebuffer_multisample/sample-alpha-to-coverage 4 depth\"\n   (buffer overflow)\n-  `Bug 71022 <https://bugs.freedesktop.org/show_bug.cgi?id=71022>`__ -\n   configure: error: Expat required for DRI.\n-  `Bug 71110 <https://bugs.freedesktop.org/show_bug.cgi?id=71110>`__ -\n   xorg_driver.c:1030:2: error: too many arguments to function\n   \u2018DamageUnregister\u2019\n-  `Bug 71172 <https://bugs.freedesktop.org/show_bug.cgi?id=71172>`__ -\n   Segfault when running glxinfo. NV25GL [Quadro4 900 XGL]\n-  `Bug 71512 <https://bugs.freedesktop.org/show_bug.cgi?id=71512>`__ -\n   dlopen.h:54: undefined reference to \\`dlopen'\n-  `Bug 71870 <https://bugs.freedesktop.org/show_bug.cgi?id=71870>`__ -\n   Metro: Last Light rendering issues\n\nChanges\n-------\n\n-  Removed X.Org state tracker (unmaintained and broken)\n-  Removed the video-accel r300 targets\n-  Removed the video-accel softpipe targets\n",
        "/tmp/vanessa/spack-stage/spack-stage-mesa-master-nrat2nfszfps3qrvs2kywr374rcjkgv2/spack-src/docs/relnotes/10.5.9.rst": "Mesa 10.5.9 Release Notes / July 04, 2015\n=========================================\n\nMesa 10.5.9 is a bug fix release which fixes bugs found since the 10.5.8\nrelease.\n\nMesa 10.5.9 implements the OpenGL 3.3 API, but the version reported by\nglGetString(GL_VERSION) or glGetIntegerv(GL_MAJOR_VERSION) /\nglGetIntegerv(GL_MINOR_VERSION) depends on the particular driver being\nused. Some drivers don't support all the features required in OpenGL\n3.3. OpenGL 3.3 is **only** available if requested at context creation\nbecause compatibility contexts are not supported.\n\nSHA256 checksums\n----------------\n\n::\n\n   0c081b59572ee9732e7438d34adc3817fe8cc8d4b58abc0e71fd4b4c904945cb  mesa-10.5.9.tar.gz\n   71c69f31d3dbc35cfa79950e58a01d27030378d8c7ef1259a0b31d4d0487f4ec  mesa-10.5.9.tar.xz\n\nNew features\n------------\n\nNone\n\nBug fixes\n---------\n\nThis list is likely incomplete.\n\n-  `Bug 84225 <https://bugs.freedesktop.org/show_bug.cgi?id=84225>`__ -\n   Allow constant-index-expression sampler array indexing with GLSL-ES <\n   300\n-  `Bug 88999 <https://bugs.freedesktop.org/show_bug.cgi?id=88999>`__ -\n   [SKL] Compiz crashes after opening unity dash\n-  `Bug 89118 <https://bugs.freedesktop.org/show_bug.cgi?id=89118>`__ -\n   [SKL Bisected]many Ogles3conform cases core dumped\n-  `Bug 90537 <https://bugs.freedesktop.org/show_bug.cgi?id=90537>`__ -\n   radeonsi bo/va conflict on RADEON_GEM_VA\n   (rscreen->ws->buffer_from_handle returns NULL)\n-  `Bug 90839 <https://bugs.freedesktop.org/show_bug.cgi?id=90839>`__ -\n   [10.5.5/10.6 regression, bisected] PBO glDrawPixels no longer using\n   blit fastpath\n-  `Bug 90873 <https://bugs.freedesktop.org/show_bug.cgi?id=90873>`__ -\n   Kernel hang, TearFree On, Mate desktop environment\n-  `Bug 91056 <https://bugs.freedesktop.org/show_bug.cgi?id=91056>`__ -\n   The Bard's Tale (2005, native) has rendering issues\n-  `Bug 91117 <https://bugs.freedesktop.org/show_bug.cgi?id=91117>`__ -\n   Nimbus (running in wine) has rendering issues, objects are\n   semi-transparent\n-  `Bug 91124 <https://bugs.freedesktop.org/show_bug.cgi?id=91124>`__ -\n   Civilization V (in Wine) has rendering issues: text missing, menu bar\n   corrupted\n\nChanges\n-------\n\nBen Widawsky (2):\n\n-  i965/gen9: Implement Push Constant Buffer workaround\n-  i965/skl: Use 1 register for uniform pull constant payload\n\nBoyan Ding (1):\n\n-  egl/x11: Remove duplicate call to dri2_x11_add_configs_for_visuals\n\nChris Wilson (3):\n\n-  i965: Fix HW blitter pitch limits\n-  i915: Blit RGBX<->RGBA drawpixels\n-  i965: Export format comparison for blitting between miptrees\n\nEmil Velikov (6):\n\n-  docs: Add sha256sums for the 10.5.8 release\n-  configure: warn about shared_glapi & xlib-glx only when both are set\n-  configure: error out when building backend-less libEGL\n-  configure: error out when building libEGL without shared-glapi\n-  gbm: do not (over)link against libglapi.so\n-  Update version to 10.5.9\n\nFrank Henigman (1):\n\n-  gbm: dlopen libglapi so gbm_create_device works\n\nIlia Mirkin (8):\n\n-  glsl: add version checks to conditionals for builtin variable\n   enablement\n-  mesa: add GL_PROGRAM_PIPELINE support in KHR_debug calls\n-  glsl: binding point is a texture unit, which is a combined space\n-  nvc0: always put all tfb bufs into bufctx\n-  nv50,nvc0: make sure to pushbuf_refn before putting bo into\n   pushbuf_data\n-  nv50/ir: propagate modifier to right arg when const-folding mad\n-  nv50/ir: fix emission of address reg in 3rd source\n-  nv50/ir: copy joinAt when splitting both before and after\n\nMario Kleiner (2):\n\n-  nouveau: Use dup fd as key in drm-winsys hash table to fix\n   ZaphodHeads.\n-  winsys/radeon: Use dup fd as key in drm-winsys hash table to fix\n   ZaphodHeads.\n\nMichel D\u00e4nzer (1):\n\n-  winsys/radeon: Unmap GPU VM address range when destroying BO\n\nTapani P\u00e4lli (6):\n\n-  glsl: Allow dynamic sampler array indexing with GLSL ES < 3.00\n-  mesa/glsl: new compiler option EmitNoIndirectSampler\n-  i915: use EmitNoIndirectSampler\n-  mesa/st: use EmitNoIndirectSampler if !ARB_gpu_shader5\n-  i965: use EmitNoIndirectSampler for gen < 7\n-  glsl: validate sampler array indexing for 'constant-index-expression'\n",
        "/tmp/vanessa/spack-stage/spack-stage-mesa-master-nrat2nfszfps3qrvs2kywr374rcjkgv2/spack-src/docs/relnotes/11.1.4.rst": "Mesa 11.1.4 Release Notes / May 9, 2016\n=======================================\n\nMesa 11.1.4 is a bug fix release which fixes bugs found since the 11.1.3\nrelease.\n\nMesa 11.1.4 implements the OpenGL 4.1 API, but the version reported by\nglGetString(GL_VERSION) or glGetIntegerv(GL_MAJOR_VERSION) /\nglGetIntegerv(GL_MINOR_VERSION) depends on the particular driver being\nused. Some drivers don't support all the features required in OpenGL\n4.1. OpenGL 4.1 is **only** available if requested at context creation\nbecause compatibility contexts are not supported.\n\nSHA256 checksums\n----------------\n\n::\n\n   034231fffb22621dadb8e4a968cb44752b8b68db7a2417568d63c275b3490cea  mesa-11.1.4.tar.gz\n   0f781e9072655305f576efd4204d183bf99ac8cb8d9e0dd9fc2b4093230a0eba  mesa-11.1.4.tar.xz\n\nNew features\n------------\n\nNone\n\nBug fixes\n---------\n\nThis list is likely incomplete.\n\n-  `Bug 92850 <https://bugs.freedesktop.org/show_bug.cgi?id=92850>`__ -\n   Segfault loading War Thunder\n-  `Bug 93962 <https://bugs.freedesktop.org/show_bug.cgi?id=93962>`__ -\n   [HSW, regression, bisected, CTS]\n   ES2-CTS.gtf.GL2FixedTests.scissor.scissor - segfault/asserts\n-  `Bug 94955 <https://bugs.freedesktop.org/show_bug.cgi?id=94955>`__ -\n   Uninitialized variables leads to random segfaults (valgrind log,\n   apitrace attached)\n-  `Bug 94994 <https://bugs.freedesktop.org/show_bug.cgi?id=94994>`__ -\n   OSMesaGetProcAdress always fails on mangled OSMesa\n-  `Bug 95026 <https://bugs.freedesktop.org/show_bug.cgi?id=95026>`__ -\n   Alien Isolation segfault after initial loading screen/video\n-  `Bug 95133 <https://bugs.freedesktop.org/show_bug.cgi?id=95133>`__ -\n   X-COM Enemy Within crashes when entering tactical mission with\n   Bonaire\n\nChanges\n-------\n\nBrian Paul (1):\n\n-  gallium/util: initialize pipe_framebuffer_state to zeros\n\nChad Versace (1):\n\n-  dri: Fix robust context creation via EGL attribute\n\nEgbert Eich (1):\n\n-  dri2: Check for dummyContext to see if the glx_context is valid\n\nEmil Velikov (5):\n\n-  docs: add sha256 checksums for 11.1.3\n-  cherry-ignore: add non-applicable \"fix of a fix\"\n-  cherry-ignore: ignore st_DrawAtlasBitmaps mem leak fix\n-  cherry-ignore: add CodeEmitterGK110::emitATOM() fix\n-  Update version to 11.1.4\n\nEric Anholt (4):\n\n-  vc4: Fix subimage accesses to LT textures.\n-  vc4: Add support for rendering to cube map surfaces.\n-  vc4: Fix tests for format supported with nr_samples == 1.\n-  vc4: Make sure we recompile when sample_mask changes.\n\nFrederic Devernay (1):\n\n-  glapi: fix \\_glapi_get_proc_address() for mangled function names\n\nJason Ekstrand (2):\n\n-  i965/tiled_memcopy: Add aligned mem_copy parameters to the [de]tiling\n   functions\n-  i965/tiled_memcpy: Rework the RGBA -> BGRA mem_copy functions\n\nJonathan Gray (1):\n\n-  egl/x11: authenticate before doing chipset id ioctls\n\nJose Fonseca (1):\n\n-  winsys/sw/xlib: use correct free function for xlib_dt->data\n\nLeo Liu (1):\n\n-  radeon/uvd: fix tonga feedback buffer size\n\nMarek Ol\u0161\u00e1k (2):\n\n-  drirc: add a workaround for blackness in Warsow\n-  st/mesa: fix blit-based GetTexImage for non-finalized textures\n\nNicolai H\u00e4hnle (5):\n\n-  radeonsi: fix bounds check in si_create_vertex_elements\n-  gallium/radeon: handle failure when mapping staging buffer\n-  st/glsl_to_tgsi: reduce stack explosion in recursive expression\n   visitor\n-  gallium/radeon: fix crash in r600_set_streamout_targets\n-  radeonsi: correct NULL-pointer check in si_upload_const_buffer\n\nOded Gabbay (4):\n\n-  r600g/radeonsi: send endian info to format translation functions\n-  r600g: set endianess of 16/32-bit buffers according to do_endian_swap\n-  r600g: use do_endian_swap in color swapping functions\n-  r600g: use do_endian_swap in texture swapping function\n\nRoland Scheidegger (3):\n\n-  llvmpipe: (trivial) initialize src1_alpha var to NULL\n-  gallivm: fix bogus argument order to lp_build_sample_mipmap function\n-  gallivm: make sampling more robust against bogus coordinates\n\nSamuel Pitoiset (5):\n\n-  gk110/ir: make use of IMUL32I for all immediates\n-  nvc0/ir: fix wrong emission of (a OP b) OP c\n-  gk110/ir: add emission for (a OP b) OP c\n-  nvc0: reduce GL_MAX_3D_TEXTURE_SIZE to 2048 on Kepler+\n-  st/glsl_to_tgsi: fix potential crash when allocating temporaries\n\nStefan Dirsch (1):\n\n-  dri3: Check for dummyContext to see if the glx_context is valid\n\nThomas Hindoe Paaboel Andersen (1):\n\n-  st/va: avoid dereference after free in vlVaDestroyImage\n\nWuZhen (3):\n\n-  tgsi: initialize stack allocated struct\n-  winsys/sw/dri: use correct free function for dri_sw_dt->data\n-  android: enable dlopen() on all architectures\n",
        "/tmp/vanessa/spack-stage/spack-stage-mesa-master-nrat2nfszfps3qrvs2kywr374rcjkgv2/spack-src/docs/relnotes/10.6.1.rst": "Mesa 10.6.1 Release Notes / June 29, 2015\n=========================================\n\nMesa 10.6.1 is a bug fix release which fixes bugs found since the 10.6.0\nrelease.\n\nMesa 10.6.1 implements the OpenGL 3.3 API, but the version reported by\nglGetString(GL_VERSION) or glGetIntegerv(GL_MAJOR_VERSION) /\nglGetIntegerv(GL_MINOR_VERSION) depends on the particular driver being\nused. Some drivers don't support all the features required in OpenGL\n3.3. OpenGL 3.3 is **only** available if requested at context creation\nbecause compatibility contexts are not supported.\n\nSHA256 checksums\n----------------\n\n::\n\n   b4cccd4d0eabcc2bca00c3175d3ad88fdda57ffdb883a7998525b873a21fe607  mesa-10.6.1.tar.gz\n   6c80a2b647e57c85dc36e609d9aed17f878f0d8e0cf9ace86d14cf604101e1eb  mesa-10.6.1.tar.xz\n\nNew features\n------------\n\nNone\n\nBug fixes\n---------\n\nThis list is likely incomplete.\n\n-  `Bug 90347 <https://bugs.freedesktop.org/show_bug.cgi?id=90347>`__ -\n   [NVE0+] Failure to insert texbar under some circumstances (causing\n   bad colors in Terasology)\n\nChanges\n-------\n\nAnuj Phogat (4):\n\n-  mesa: Handle integer formats in need_rgb_to_luminance_conversion()\n-  mesa: Use helper function need_rgb_to_luminance_conversion()\n-  mesa: Turn need_rgb_to_luminance_conversion() in to a global function\n-  meta: Abort meta path if ReadPixels need rgb to luminance conversion\n\nBen Widawsky (1):\n\n-  i965/gen9: Implement Push Constant Buffer workaround\n\nBoyan Ding (2):\n\n-  egl/x11: Set version of swrastLoader to 2\n-  egl/x11: Remove duplicate call to dri2_x11_add_configs_for_visuals\n\nEmil Velikov (6):\n\n-  docs: Add sha256sums for the 10.6.0 release\n-  configure: warn about shared_glapi & xlib-glx only when both are set\n-  configure: error out when building backend-less libEGL\n-  configure: error out when building libEGL without shared-glapi\n-  gbm: do not (over)link against libglapi.so\n-  Update version to 10.6.1\n\nFrank Henigman (1):\n\n-  gbm: dlopen libglapi so gbm_create_device works\n\nIlia Mirkin (9):\n\n-  nvc0/ir: fix collection of first uses for texture barrier insertion\n-  nv50,nvc0: clamp uniform size to 64k\n-  nvc0/ir: can't have a join on a load with an indirect source\n-  glsl: handle conversions to double when comparing param matches\n-  glsl: add version checks to conditionals for builtin variable\n   enablement\n-  mesa: add GL_PROGRAM_PIPELINE support in KHR_debug calls\n-  glsl: binding point is a texture unit, which is a combined space\n-  nvc0: always put all tfb bufs into bufctx\n-  nv50,nvc0: make sure to pushbuf_refn before putting bo into\n   pushbuf_data\n",
        "/tmp/vanessa/spack-stage/spack-stage-mesa-master-nrat2nfszfps3qrvs2kywr374rcjkgv2/spack-src/docs/relnotes/11.2.2.rst": "Mesa 11.2.2 Release Notes / May 9, 2016\n=======================================\n\nMesa 11.2.2 is a bug fix release which fixes bugs found since the 11.2.1\nrelease.\n\nMesa 11.2.2 implements the OpenGL 4.1 API, but the version reported by\nglGetString(GL_VERSION) or glGetIntegerv(GL_MAJOR_VERSION) /\nglGetIntegerv(GL_MINOR_VERSION) depends on the particular driver being\nused. Some drivers don't support all the features required in OpenGL\n4.1. OpenGL 4.1 is **only** available if requested at context creation\nbecause compatibility contexts are not supported.\n\nSHA256 checksums\n----------------\n\n::\n\n   e2453014cd2cc5337a5180cdeffe8cf24fffbb83e20a96888e2b01df868eaae6  mesa-11.2.2.tar.gz\n   40e148812388ec7c6d7b6657d5a16e2e8dabba8b97ddfceea5197947647bdfb4  mesa-11.2.2.tar.xz\n\nNew features\n------------\n\nNone\n\nBug fixes\n---------\n\nThis list is likely incomplete.\n\n-  `Bug 92850 <https://bugs.freedesktop.org/show_bug.cgi?id=92850>`__ -\n   Segfault loading War Thunder\n-  `Bug 93767 <https://bugs.freedesktop.org/show_bug.cgi?id=93767>`__ -\n   Glitches with soft shadows and MSAA in Knights of the Old Republic 2\n-  `Bug 94955 <https://bugs.freedesktop.org/show_bug.cgi?id=94955>`__ -\n   Uninitialized variables leads to random segfaults (valgrind log,\n   apitrace attached)\n-  `Bug 94994 <https://bugs.freedesktop.org/show_bug.cgi?id=94994>`__ -\n   OSMesaGetProcAdress always fails on mangled OSMesa\n-  `Bug 95026 <https://bugs.freedesktop.org/show_bug.cgi?id=95026>`__ -\n   Alien Isolation segfault after initial loading screen/video\n-  `Bug 95133 <https://bugs.freedesktop.org/show_bug.cgi?id=95133>`__ -\n   X-COM Enemy Within crashes when entering tactical mission with\n   Bonaire\n-  `Bug 95164 <https://bugs.freedesktop.org/show_bug.cgi?id=95164>`__ -\n   GLSL compiler (linker I think) emits assertion upon call to\n   glAttachShader\n-  `Bug 95251 <https://bugs.freedesktop.org/show_bug.cgi?id=95251>`__ -\n   vdpau decoder capabilities: not supported\n\nChanges\n-------\n\nBoyuan Zhang (1):\n\n-  radeon/uvd: alignment fix for decode message buffer\n\nBrian Paul (2):\n\n-  st/mesa: fix sampler view leak in st_DrawAtlasBitmaps()\n-  gallium/util: initialize pipe_framebuffer_state to zeros\n\nChad Versace (1):\n\n-  dri: Fix robust context creation via EGL attribute\n\nEgbert Eich (1):\n\n-  dri2: Check for dummyContext to see if the glx_context is valid\n\nEmil Velikov (5):\n\n-  docs: add sha256 checksums for 11.2.1\n-  docs: update the sha256 checksums for 11.2.1\n-  cherry-ignore: remove duplicate commit\n-  cherry-ignore: ignore the GetSamplerParameterIuiv{EXT,OES} fixups\n-  Update version to 11.2.2\n\nEric Anholt (4):\n\n-  vc4: Fix subimage accesses to LT textures.\n-  vc4: Add support for rendering to cube map surfaces.\n-  vc4: Fix tests for format supported with nr_samples == 1.\n-  vc4: Make sure we recompile when sample_mask changes.\n\nFrederic Devernay (1):\n\n-  glapi: fix \\_glapi_get_proc_address() for mangled function names\n\nIlia Mirkin (2):\n\n-  nvc0: fix retrieving query results into buffer for timestamps\n-  nouveau/video: properly detect the decoder class for availability\n   checks\n\nJason Ekstrand (1):\n\n-  i965/fs: Properly report regs_written from SAMPLEINFO\n\nJonathan Gray (1):\n\n-  egl/x11: authenticate before doing chipset id ioctls\n\nJose Fonseca (1):\n\n-  winsys/sw/xlib: use correct free function for xlib_dt->data\n\nKenneth Graunke (3):\n\n-  i965: Fix clear code for ignoring colormask for XRGB formats on\n   Gen9+.\n-  glsl: Convert lower_vec_index_to_swizzle to a rvalue visitor.\n-  glsl: Lower vector_extracts to swizzles after lower_vector_derefs.\n\nLeo Liu (1):\n\n-  radeon/uvd: fix tonga feedback buffer size\n\nMarek Ol\u0161\u00e1k (1):\n\n-  st/mesa: fix blit-based GetTexImage for non-finalized textures\n\nNicolai H\u00e4hnle (5):\n\n-  gallium/radeon: handle failure when mapping staging buffer\n-  st/glsl_to_tgsi: reduce stack explosion in recursive expression\n   visitor\n-  gallium/radeon: fix crash in r600_set_streamout_targets\n-  radeonsi: correct NULL-pointer check in si_upload_const_buffer\n-  radeonsi: work around an MSAA fast stencil clear problem\n\nOded Gabbay (4):\n\n-  r600g/radeonsi: send endian info to format translation functions\n-  r600g: set endianess of 16/32-bit buffers according to do_endian_swap\n-  r600g: use do_endian_swap in color swapping functions\n-  r600g: use do_endian_swap in texture swapping function\n\nPatrick Rudolph (1):\n\n-  r600g: fix and optimize tgsi_cmp when using ABS and NEG modifier\n\nRoland Scheidegger (3):\n\n-  llvmpipe: (trivial) initialize src1_alpha var to NULL\n-  gallivm: fix bogus argument order to lp_build_sample_mipmap function\n-  gallivm: make sampling more robust against bogus coordinates\n\nSamuel Pitoiset (6):\n\n-  gk110/ir: do not overwrite def value with zero for EXCH ops\n-  gk110/ir: make use of IMUL32I for all immediates\n-  nvc0/ir: fix wrong emission of (a OP b) OP c\n-  gk110/ir: add emission for (a OP b) OP c\n-  nvc0: reduce GL_MAX_3D_TEXTURE_SIZE to 2048 on Kepler+\n-  st/glsl_to_tgsi: fix potential crash when allocating temporaries\n\nStefan Dirsch (1):\n\n-  dri3: Check for dummyContext to see if the glx_context is valid\n\nTopi Pohjolainen (2):\n\n-  i965/blorp/gen7: Prepare re-using for gen8\n-  i965/blorp: Use 8k chunk size for urb allocation\n\nWuZhen (3):\n\n-  tgsi: initialize stack allocated struct\n-  winsys/sw/dri: use correct free function for dri_sw_dt->data\n-  android: enable dlopen() on all architectures\n",
        "/tmp/vanessa/spack-stage/spack-stage-mesa-master-nrat2nfszfps3qrvs2kywr374rcjkgv2/spack-src/docs/relnotes/9.1.2.rst": "Mesa 9.1.2 Release Notes / April 30th, 2013\n===========================================\n\nMesa 9.1.2 is a bug fix release which fixes bugs found since the 9.1.1\nrelease.\n\nMesa 9.1 implements the OpenGL 3.1 API, but the version reported by\nglGetString(GL_VERSION) or glGetIntegerv(GL_MAJOR_VERSION) /\nglGetIntegerv(GL_MINOR_VERSION) depends on the particular driver being\nused. Some drivers don't support all the features required in OpenGL\n3.1. OpenGL 3.1 is **only** available if requested at context creation\nbecause GL_ARB_compatibility is not supported.\n\nMD5 checksums\n-------------\n\n::\n\n   df2aab86ff4a510ce5b0d074caa0a59f  MesaLib-9.1.2.tar.bz2\n   415c2bc3a9eb571aafbfa474ebf5a2e0  MesaLib-9.1.2.tar.gz\n   b1ae5a4d9255953980bc9254f5323420  MesaLib-9.1.2.zip\n\nNew features\n------------\n\nNone.\n\nBug fixes\n---------\n\nThis list is likely incomplete.\n\n-  `Bug 44567 <https://bugs.freedesktop.org/show_bug.cgi?id=44567>`__ -\n   [965gm] green artifacts when using GLSL in XBMC\n-  `Bug 59238 <https://bugs.freedesktop.org/show_bug.cgi?id=59238>`__ -\n   many new symbols in libxatracker after recent automake work\n-  `Bug 59445 <https://bugs.freedesktop.org/show_bug.cgi?id=59445>`__ -\n   [SNB/IVB/HSW Bisected]Oglc draw-buffers2(advanced.blending.none)\n   segfault\n-  `Bug 59495 <https://bugs.freedesktop.org/show_bug.cgi?id=59495>`__ -\n   [i965 Bisected]Oglc fbblit(advanced.blitFb-3d-cube.mirror.both) fails\n-  `Bug 60503 <https://bugs.freedesktop.org/show_bug.cgi?id=60503>`__ -\n   [r300g] Unigine Heaven 3.0: all objects are black\n-  `Bug 60510 <https://bugs.freedesktop.org/show_bug.cgi?id=60510>`__ -\n   Firefox 18.0.2 Crash On Nvidia GeForce2\n-  `Bug 61197 <https://bugs.freedesktop.org/show_bug.cgi?id=61197>`__ -\n   [SNB Bisected] kwin_gles screen corruption\n-  `Bug 61317 <https://bugs.freedesktop.org/show_bug.cgi?id=61317>`__ -\n   [IVB] corrupt rendering with UBOs\n-  `Bug 61395 <https://bugs.freedesktop.org/show_bug.cgi?id=61395>`__ -\n   glEdgeFlag can't be set to false\n-  `Bug 61947 <https://bugs.freedesktop.org/show_bug.cgi?id=61947>`__ -\n   nullpointer dereference causes xorg-server segfault when nouveau DRI\n   driver is loaded\n-  `Bug 62357 <https://bugs.freedesktop.org/show_bug.cgi?id=62357>`__ -\n   llvmpipe: Fragment Shader with \"return\" in main causes back output\n-  `Bug 62434 <https://bugs.freedesktop.org/show_bug.cgi?id=62434>`__ -\n   [bisected] 3284.073] (EE) AIGLX error: dlopen of\n   /usr/lib/xorg/modules/dri/r600_dri.so failed\n   (/usr/lib/libllvmradeon9.2.0.so: undefined symbol:\n   lp_build_tgsi_intrinsic)\n-  `Debian bug\n   #349437 <https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=349437>`__\n   - mesa - FTBFS: error: 'IEEE_ONE' undeclared\n-  `Redhat bug\n   #918661 <https://bugzilla.redhat.com/show_bug.cgi?id=918661>`__ -\n   crash in routine Avogadro UI manipulation\n\nChanges\n-------\n\nThe full set of changes can be viewed by using the following GIT\ncommand:\n\n::\n\n     git log mesa-9.1.1..mesa-9.1.2\n\nAdam Jackson (2):\n\n-  glx: Build with VISIBILITY_CFLAGS in automake\n-  linux: Don't emit a .note.ABI-tag section anymore (#26663)\n\nAlan Hourihane (3):\n\n-  Add missing GL_TEXTURE_CUBE_MAP entry in\n   \\_mesa_legal_texture_dimensions\n-  Unreference sampler object when it's currently bound to texture unit.\n-  mesa: fix glGetInteger*(GL_SAMPLER_BINDING).\n\nAlex Deucher (1):\n\n-  r600g: disable hyperz by default on 9.1\n\nAndreas Boll (5):\n\n-  radeon/llvm: Link against libgallium.la to fix an undefined symbol\n-  mesa: use ieee fp on s390 and m68k\n-  build: Enable x86 assembler on Hurd.\n-  osmesa: fix out-of-tree build\n-  gallium/egl: fix out-of-tree build\n\nAnuj Phogat (1):\n\n-  mesa: Fix FB blitting in case of zero size src or dst rect\n\nBrian Paul (4):\n\n-  mesa: flush current state when querying GL_EDGE_FLAG\n-  vbo: fix crash found with shared display lists\n-  llvmpipe: tweak CMD_BLOCK_MAX and LP_SCENE_MAX_SIZE\n-  llvmpipe: add some scene limit sanity check assertions\n\nCarl Worth (1):\n\n-  i965: Avoid segfault in gen6_upload_state\n\nChris Forbes (1):\n\n-  i965/vs: Fix Gen4/5 VUE map inconsistency with gl_ClipVertex\n\nChristoph Bumiller (4):\n\n-  nv50: fix 3D render target setup\n-  nv50,nvc0: disable DEPTH_RANGE_NEAR/FAR clipping during blit\n-  nv50,nvc0: fix 3d blits, restore viewport after blit\n-  nvc0: fix for 2d engine R source formats writing RRR1 and not R001\n\nEric Anholt (5):\n\n-  i965/fs: Fix register allocation for uniform pull constants in\n   16-wide.\n-  i965/fs: Fix broken rendering in large shaders with UBO loads.\n-  i965/fs: Also do the gen4 SEND dependency workaround against other\n   SENDs.\n-  i965: Add definitions for gen7+ data cache messages.\n-  mesa: Disable validate_ir_tree() on release builds.\n\nIan Romanick (5):\n\n-  docs: Add 9.1.1 release md5sums\n-  mesa: Add previously picked commit to .cherry-ignore\n-  glsl: Add missing bool case in glsl_type::get_scalar_type\n-  mesa: Note that patch dbf94d1 should't actually get picked to the 9.1\n   branch\n-  mesa: Bump version to 9.1.2\n\nJan de Groot (1):\n\n-  dri/nouveau: fix crash in nouveau_flush\n\nJos\u00e9 Fonseca (3):\n\n-  autotools: Add missing top-level include dir.\n-  mesa,gallium,egl,mapi: One definition of C99 inline/__func_\\_ to rule\n   them all.\n-  include: Fix build with VS 11 (i.e, 2012).\n\nKenneth Graunke (4):\n\n-  i965: Fix INTEL_DEBUG=shader_time for Haswell.\n-  i965: Specialize SURFACE_STATE creation for shader time.\n-  i965: Make INTEL_DEBUG=shader_time use the RAW surface format.\n-  i965: Don't use texture swizzling to force alpha to 1.0 if\n   unnecessary.\n\nMaarten Lankhorst (2):\n\n-  gallium/build: Fix visibility CFLAGS in automake\n-  radeon/llvm: Do not link against libgallium when building statically.\n\nMarcin Slusarz (1):\n\n-  dri/nouveau: NV17_3D class is not available for NV1a chipset\n\nMarek Ol\u0161\u00e1k (3):\n\n-  mesa: don't allocate a texture if width or height is 0 in\n   CopyTexImage\n-  gallium/tgsi: fix valgrind warning\n-  mesa: handle HALF_FLOAT like FLOAT in get_tex_rgba\n\nMartin Andersson (1):\n\n-  r600g: Use virtual address for PIPE_QUERY_SO\\* in r600_emit_query_end\n\nMatt Turner (3):\n\n-  configure.ac: Don't check for X11 unconditionally.\n-  configure.ac: Remove stale comment about --x-\\* arguments.\n-  mesa: Implement TEXTURE_IMMUTABLE_LEVELS for ES 3.0.\n\nMichel D\u00e4nzer (1):\n\n-  radeonsi: Emit pixel shader state even when only the vertex shader\n   changed\n\nPaul Berry (1):\n\n-  i965: Apply depthstencil alignment workaround when doing fast clears.\n\nRoland Scheidegger (1):\n\n-  gallivm: fix return opcode handling in main function of a shader\n\nTapani P\u00e4lli (1):\n\n-  intel: Fix regression in intel_create_image_from_name stride handling\n\nTom Stellard (1):\n\n-  r300g: Fix bug in OMOD optimization\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-mesa-master-nrat2nfszfps3qrvs2kywr374rcjkgv2/spack-src/src/freedreno/.gitlab-ci/traces/dEQP-GLES2.functional.texture.specification.basic_teximage2d.rgba16f_2d.rd.gz",
        "/tmp/vanessa/spack-stage/spack-stage-mesa-master-nrat2nfszfps3qrvs2kywr374rcjkgv2/spack-src/src/freedreno/.gitlab-ci/traces/shadow.rd.gz",
        "/tmp/vanessa/spack-stage/spack-stage-mesa-master-nrat2nfszfps3qrvs2kywr374rcjkgv2/spack-src/src/freedreno/.gitlab-ci/traces/es2gears-a320.rd.gz",
        "/tmp/vanessa/spack-stage/spack-stage-mesa-master-nrat2nfszfps3qrvs2kywr374rcjkgv2/spack-src/src/freedreno/.gitlab-ci/traces/fd-clouds.rd.gz",
        "/tmp/vanessa/spack-stage/spack-stage-mesa-master-nrat2nfszfps3qrvs2kywr374rcjkgv2/spack-src/src/freedreno/.gitlab-ci/traces/glxgears-a420.rd.gz",
        "/tmp/vanessa/spack-stage/spack-stage-mesa-master-nrat2nfszfps3qrvs2kywr374rcjkgv2/spack-src/src/freedreno/.gitlab-ci/traces/dEQP-VK.draw.indirect_draw.indexed.indirect_draw_count.triangle_list.rd.gz",
        "/tmp/vanessa/spack-stage/spack-stage-mesa-master-nrat2nfszfps3qrvs2kywr374rcjkgv2/spack-src/src/freedreno/.gitlab-ci/reference/afuc_test.fw",
        "/tmp/vanessa/spack-stage/spack-stage-mesa-master-nrat2nfszfps3qrvs2kywr374rcjkgv2/spack-src/src/gallium/drivers/panfrost/nir/nir_lower_blend.h",
        "/tmp/vanessa/spack-stage/spack-stage-mesa-master-nrat2nfszfps3qrvs2kywr374rcjkgv2/spack-src/src/gallium/drivers/svga/include/svga3d_surfacedefs.h",
        "/tmp/vanessa/spack-stage/spack-stage-mesa-master-nrat2nfszfps3qrvs2kywr374rcjkgv2/spack-src/src/mesa/x86/mmx_blendtmp.h",
        "/tmp/vanessa/spack-stage/spack-stage-mesa-master-nrat2nfszfps3qrvs2kywr374rcjkgv2/spack-src/.git/objects/pack/pack-f0c951dbcbb0759b466a7c1ecef0d1418d0523b0.pack",
        "/tmp/vanessa/spack-stage/spack-stage-mesa-master-nrat2nfszfps3qrvs2kywr374rcjkgv2/spack-src/.git/objects/pack/pack-f0c951dbcbb0759b466a7c1ecef0d1418d0523b0.idx",
        "/tmp/vanessa/spack-stage/spack-stage-mesa-master-nrat2nfszfps3qrvs2kywr374rcjkgv2/spack-src/docs/favicon.ico"
    ],
    "total_files": 8055
}