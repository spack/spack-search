{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.1.2-nak3eqkxfunb4z5owzsqogchnaejp7o4/spack-src/demo/manual2.py": "import _cffi_backend\n\nffi = _cffi_backend.FFI(b\"manual2\",\n    _version = 0x2601,\n    _types = b'\\x00\\x00\\x01\\x0D\\x00\\x00\\x07\\x01\\x00\\x00\\x00\\x0F\\x00\\x00\\x00\\x09\\x00\\x00\\x00\\x0B\\x00\\x00\\x01\\x03',\n    _globals = (b'\\xff\\xff\\xff\\x0bAA',0,b'\\xff\\xff\\xff\\x0bBB',-1,b'\\xff\\xff\\xff\\x0bCC',2,b'\\xff\\xff\\xff\\x1fFOO',0x9999999999999999,b'\\x00\\x00\\x00#close',0,b'\\x00\\x00\\x05#stdout',0),\n    _struct_unions = ((b'\\x00\\x00\\x00\\x03\\x00\\x00\\x00\\x00point_s',b'\\x00\\x00\\x01\\x11\\xff\\xff\\xff\\xffx',b'\\x00\\x00\\x01\\x11\\xff\\xff\\xff\\xffy'),),\n    _enums = (b'\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x07myenum_e\\x00AA,BB,CC',),\n    _typenames = (b'\\x00\\x00\\x00\\x01myint_t',),\n)\n\n\n\n# trying it out\nlib = ffi.dlopen(None)\nassert lib.AA == 0\nassert lib.BB == -1\nassert lib.FOO == 0x9999999999999999\nx = lib.close(-42)\nassert x == -1\n\nprint lib.stdout\n\nprint ffi.new(\"struct point_s *\")\nprint ffi.offsetof(\"struct point_s\", \"x\")\nprint ffi.offsetof(\"struct point_s\", \"y\")\nprint ffi.new(\"struct point_s[CC]\")\nassert ffi.sizeof(\"struct point_s[CC]\") == 2 * ffi.sizeof(\"struct point_s\")\n\nprint ffi.cast(\"enum myenum_e\", 2)\nprint ffi.cast(\"myint_t\", -2)\nassert ffi.typeof(\"myint_t\") == ffi.typeof(\"int\")\n\ndel ffi, lib\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.1.2-nak3eqkxfunb4z5owzsqogchnaejp7o4/spack-src/demo/readdir.py": "# A Linux-only demo\n#\nimport sys\n\nif not sys.platform.startswith('linux'):\n    raise Exception(\"Linux-only demo\")\n\nfrom _readdir import ffi\nlib = ffi.dlopen(None)\n\n\ndef walk(basefd, path):\n    print '{', path\n    dirfd = lib.openat(basefd, path, 0)\n    if dirfd < 0:\n        # error in openat()\n        return\n    dir = lib.fdopendir(dirfd)\n    dirent = ffi.new(\"struct dirent *\")\n    result = ffi.new(\"struct dirent **\")\n    while True:\n        if lib.readdir_r(dir, dirent, result):\n            # error in readdir_r()\n            break\n        if result[0] == ffi.NULL:\n            break\n        name = ffi.string(dirent.d_name)\n        print '%3d %s' % (dirent.d_type, name)\n        if dirent.d_type == 4 and name != '.' and name != '..':\n            walk(dirfd, name)\n    lib.closedir(dir)\n    print '}'\n\n\nwalk(-1, \"/tmp\")\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.1.2-nak3eqkxfunb4z5owzsqogchnaejp7o4/spack-src/demo/cffi-cocoa.py": "# Based on http://cocoawithlove.com/2010/09/minimalist-cocoa-programming.html\n# by Juraj Sukop.  This demo was eventually expanded into a more complete\n# Cocoa library available at https://bitbucket.org/sukop/nspython .\n\nfrom cffi import FFI\n\nffi = FFI()\nffi.cdef('''\n    \n    typedef signed char BOOL;\n    \n    typedef long NSInteger;\n    typedef unsigned long NSUInteger;\n    typedef NSInteger NSApplicationActivationPolicy;\n    typedef NSUInteger NSBackingStoreType;\n    typedef NSUInteger NSStringEncoding;\n    \n    typedef double CGFloat;\n    struct CGPoint {\n        CGFloat x;\n        CGFloat y;\n    };\n    typedef struct CGPoint CGPoint;\n    struct CGSize {\n        CGFloat width;\n        CGFloat height;\n    };\n    typedef struct CGSize CGSize;\n    struct CGRect {\n        CGPoint origin;\n        CGSize size;\n    };\n    typedef struct CGRect CGRect;\n    \n    typedef CGPoint NSPoint;\n    typedef CGSize NSSize;\n    typedef CGRect NSRect;\n    \n    typedef struct objc_class *Class;\n    typedef struct objc_object {\n        Class isa;\n    } *id;\n    typedef struct objc_selector *SEL;\n\n    SEL sel_registerName(const char *str);\n    id objc_getClass(const char *name);\n    id objc_msgSend(id theReceiver, SEL theSelector, ...);\n    \n''')\n\nobjc = ffi.dlopen('objc')\nappkit = ffi.dlopen('AppKit')\n\nnil = ffi.NULL\nYES = ffi.cast('BOOL', 1)\nNO = ffi.cast('BOOL', 0)\n\nNSASCIIStringEncoding = ffi.cast('NSStringEncoding', 1)\nNSApplicationActivationPolicyRegular = ffi.cast('NSApplicationActivationPolicy', 0)\nNSTitledWindowMask = ffi.cast('NSUInteger', 1)\nNSBackingStoreBuffered = ffi.cast('NSBackingStoreType', 2)\n\nNSMakePoint = lambda x, y: ffi.new('NSPoint *', (x, y))[0]\nNSMakeRect = lambda x, y, w, h: ffi.new('NSRect *', ((x, y), (w, h)))[0]\n\nget, send, sel = objc.objc_getClass, objc.objc_msgSend, objc.sel_registerName\nat = lambda s: send(\n    get('NSString'),\n    sel('stringWithCString:encoding:'),\n    ffi.new('char[]', s), NSASCIIStringEncoding)\n\nsend(get('NSAutoreleasePool'), sel('new'))\napp = send(get('NSApplication'), sel('sharedApplication'))\nsend(app, sel('setActivationPolicy:'), NSApplicationActivationPolicyRegular)\n\nmenubar = send(send(get('NSMenu'), sel('new')), sel('autorelease'))\nappMenuItem = send(send(get('NSMenuItem'), sel('new')), sel('autorelease'))\nsend(menubar, sel('addItem:'), appMenuItem)\nsend(app, sel('setMainMenu:'), menubar)\n\nappMenu = send(send(get('NSMenu'), sel('new')), sel('autorelease'))\nappName = send(send(get('NSProcessInfo'), sel('processInfo')), sel('processName'))\nquitTitle = send(at('Quit '), sel('stringByAppendingString:'), appName)\nquitMenuItem = send(send(send(\n            get('NSMenuItem'), sel('alloc')),\n        sel('initWithTitle:action:keyEquivalent:'),\n        quitTitle, sel('terminate:'), at('q')),\n    sel('autorelease'))\nsend(appMenu, sel('addItem:'), quitMenuItem)\nsend(appMenuItem, sel('setSubmenu:'), appMenu)\n\nwindow = send(send(send(\n            get('NSWindow'), sel('alloc')),\n        sel('initWithContentRect:styleMask:backing:defer:'),\n        NSMakeRect(0, 0, 200, 200), NSTitledWindowMask, NSBackingStoreBuffered, NO),\n    sel('autorelease'))\nsend(window, sel('cascadeTopLeftFromPoint:'), NSMakePoint(20, 20))\nsend(window, sel('setTitle:'), appName)\nsend(window, sel('makeKeyAndOrderFront:'), nil)\n\nsend(app, sel('activateIgnoringOtherApps:'), YES)\nsend(app, sel('run'))\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.1.2-nak3eqkxfunb4z5owzsqogchnaejp7o4/spack-src/testing/cffi1/test_verify1.py": "import os, sys, math, py\nfrom cffi import FFI, FFIError, VerificationError, VerificationMissing, model\nfrom cffi import recompiler\nfrom testing.support import *\nimport _cffi_backend\n\nlib_m = ['m']\nif sys.platform == 'win32':\n    #there is a small chance this fails on Mingw via environ $CC\n    import distutils.ccompiler\n    if distutils.ccompiler.get_default_compiler() == 'msvc':\n        lib_m = ['msvcrt']\n    extra_compile_args = []      # no obvious -Werror equivalent on MSVC\nelse:\n    if (sys.platform == 'darwin' and\n          [int(x) for x in os.uname()[2].split('.')] >= [11, 0, 0]):\n        # assume a standard clang or gcc\n        extra_compile_args = ['-Werror', '-Wall', '-Wextra', '-Wconversion']\n        # special things for clang\n        extra_compile_args.append('-Qunused-arguments')\n    else:\n        # assume a standard gcc\n        extra_compile_args = ['-Werror', '-Wall', '-Wextra', '-Wconversion']\n\nclass FFI(FFI):\n    error = _cffi_backend.FFI.error\n    _extra_compile_args = extra_compile_args\n    _verify_counter = 0\n\n    def verify(self, preamble='', *args, **kwds):\n        # HACK to reuse the tests from ../cffi0/test_verify.py\n        FFI._verify_counter += 1\n        module_name = 'verify%d' % FFI._verify_counter\n        try:\n            del self._assigned_source\n        except AttributeError:\n            pass\n        self.set_source(module_name, preamble)\n        return recompiler._verify(self, module_name, preamble, *args,\n                                  extra_compile_args=self._extra_compile_args,\n                                  **kwds)\n\nclass FFI_warnings_not_error(FFI):\n    _extra_compile_args = []\n\n\ndef test_missing_function(ffi=None):\n    # uses the FFI hacked above with '-Werror'\n    if ffi is None:\n        ffi = FFI()\n    ffi.cdef(\"void some_completely_unknown_function();\")\n    try:\n        lib = ffi.verify()\n    except (VerificationError, OSError, ImportError):\n        pass     # expected case: we get a VerificationError\n    else:\n        # but depending on compiler and loader details, maybe\n        # 'lib' could actually be imported but will fail if we\n        # actually try to call the unknown function...  Hard\n        # to test anything more.\n        pass\n\ndef test_missing_function_import_error():\n    # uses the original FFI that just gives a warning during compilation\n    test_missing_function(ffi=FFI_warnings_not_error())\n\ndef test_simple_case():\n    ffi = FFI()\n    ffi.cdef(\"double sin(double x);\")\n    lib = ffi.verify('#include <math.h>', libraries=lib_m)\n    assert lib.sin(1.23) == math.sin(1.23)\n\ndef _Wconversion(cdef, source, **kargs):\n    if sys.platform == 'win32':\n        py.test.skip(\"needs GCC or Clang\")\n    ffi = FFI()\n    ffi.cdef(cdef)\n    py.test.raises(VerificationError, ffi.verify, source, **kargs)\n    extra_compile_args_orig = extra_compile_args[:]\n    extra_compile_args.remove('-Wconversion')\n    try:\n        lib = ffi.verify(source, **kargs)\n    finally:\n        extra_compile_args[:] = extra_compile_args_orig\n    return lib\n\ndef test_Wconversion_unsigned():\n    _Wconversion(\"unsigned foo(void);\",\n                 \"int foo(void) { return -1;}\")\n\ndef test_Wconversion_integer():\n    _Wconversion(\"short foo(void);\",\n                 \"long long foo(void) { return 1<<sizeof(short);}\")\n\ndef test_Wconversion_floating():\n    lib = _Wconversion(\"float sin(double);\",\n                       \"#include <math.h>\", libraries=lib_m)\n    res = lib.sin(1.23)\n    assert res != math.sin(1.23)     # not exact, because of double->float\n    assert abs(res - math.sin(1.23)) < 1E-5\n\ndef test_Wconversion_float2int():\n    _Wconversion(\"int sinf(float);\",\n                 \"#include <math.h>\", libraries=lib_m)\n\ndef test_Wconversion_double2int():\n    _Wconversion(\"int sin(double);\",\n                 \"#include <math.h>\", libraries=lib_m)\n\ndef test_rounding_1():\n    ffi = FFI()\n    ffi.cdef(\"double sinf(float x);\")\n    lib = ffi.verify('#include <math.h>', libraries=lib_m)\n    res = lib.sinf(1.23)\n    assert res != math.sin(1.23)     # not exact, because of double->float\n    assert abs(res - math.sin(1.23)) < 1E-5\n\ndef test_rounding_2():\n    ffi = FFI()\n    ffi.cdef(\"double sin(float x);\")\n    lib = ffi.verify('#include <math.h>', libraries=lib_m)\n    res = lib.sin(1.23)\n    assert res != math.sin(1.23)     # not exact, because of double->float\n    assert abs(res - math.sin(1.23)) < 1E-5\n\ndef test_strlen_exact():\n    ffi = FFI()\n    ffi.cdef(\"size_t strlen(const char *s);\")\n    lib = ffi.verify(\"#include <string.h>\")\n    assert lib.strlen(b\"hi there!\") == 9\n\ndef test_strlen_approximate():\n    lib = _Wconversion(\"int strlen(char *s);\",\n                       \"#include <string.h>\")\n    assert lib.strlen(b\"hi there!\") == 9\n\ndef test_return_approximate():\n    for typename in ['short', 'int', 'long', 'long long']:\n        ffi = FFI()\n        ffi.cdef(\"%s foo(signed char x);\" % typename)\n        lib = ffi.verify(\"signed char foo(signed char x) { return x;}\")\n        assert lib.foo(-128) == -128\n        assert lib.foo(+127) == +127\n\ndef test_strlen_array_of_char():\n    ffi = FFI()\n    ffi.cdef(\"size_t strlen(char[]);\")\n    lib = ffi.verify(\"#include <string.h>\")\n    assert lib.strlen(b\"hello\") == 5\n\ndef test_longdouble():\n    ffi = FFI()\n    ffi.cdef(\"long double sinl(long double x);\")\n    lib = ffi.verify('#include <math.h>', libraries=lib_m)\n    for input in [1.23,\n                  ffi.cast(\"double\", 1.23),\n                  ffi.cast(\"long double\", 1.23)]:\n        x = lib.sinl(input)\n        assert repr(x).startswith(\"<cdata 'long double'\")\n        assert (float(x) - math.sin(1.23)) < 1E-10\n\ndef test_longdouble_precision():\n    # Test that we don't loose any precision of 'long double' when\n    # passing through Python and CFFI.\n    ffi = FFI()\n    ffi.cdef(\"long double step1(long double x);\")\n    SAME_SIZE = ffi.sizeof(\"long double\") == ffi.sizeof(\"double\")\n    lib = ffi.verify(\"\"\"\n        long double step1(long double x)\n        {\n            return 4*x-x*x;\n        }\n    \"\"\")\n    def do(cast_to_double):\n        x = 0.9789\n        for i in range(10000):\n            x = lib.step1(x)\n            if cast_to_double:\n                x = float(x)\n        return float(x)\n\n    more_precise = do(False)\n    less_precise = do(True)\n    if SAME_SIZE:\n        assert more_precise == less_precise\n    else:\n        assert abs(more_precise - less_precise) > 0.1\n        # Check the particular results on Intel\n        import platform\n        if (platform.machine().startswith('i386') or\n            platform.machine().startswith('x86')):\n            assert abs(more_precise - 0.656769) < 0.001\n            assert abs(less_precise - 3.99091) < 0.001\n        else:\n            py.test.skip(\"don't know the very exact precision of 'long double'\")\n\n\nall_primitive_types = model.PrimitiveType.ALL_PRIMITIVE_TYPES\nif sys.platform == 'win32':\n    all_primitive_types = all_primitive_types.copy()\n    del all_primitive_types['ssize_t']\nall_integer_types = sorted(tp for tp in all_primitive_types\n                           if all_primitive_types[tp] == 'i')\nall_float_types = sorted(tp for tp in all_primitive_types\n                            if all_primitive_types[tp] == 'f')\n\ndef all_signed_integer_types(ffi):\n    return [x for x in all_integer_types if int(ffi.cast(x, -1)) < 0]\n\ndef all_unsigned_integer_types(ffi):\n    return [x for x in all_integer_types if int(ffi.cast(x, -1)) > 0]\n\n\ndef test_primitive_category():\n    for typename in all_primitive_types:\n        tp = model.PrimitiveType(typename)\n        C = tp.is_char_type()\n        F = tp.is_float_type()\n        I = tp.is_integer_type()\n        assert C == (typename in ('char', 'wchar_t'))\n        assert F == (typename in ('float', 'double', 'long double'))\n        assert I + F + C == 1      # one and only one of them is true\n\ndef test_all_integer_and_float_types():\n    typenames = []\n    for typename in all_primitive_types:\n        if (all_primitive_types[typename] == 'c' or\n            typename == '_Bool' or typename == 'long double'):\n            pass\n        else:\n            typenames.append(typename)\n    #\n    ffi = FFI()\n    ffi.cdef('\\n'.join([\"%s foo_%s(%s);\" % (tp, tp.replace(' ', '_'), tp)\n                       for tp in typenames]))\n    lib = ffi.verify('\\n'.join([\"%s foo_%s(%s x) { return (%s)(x+1); }\" %\n                                (tp, tp.replace(' ', '_'), tp, tp)\n                                for tp in typenames]))\n    for typename in typenames:\n        foo = getattr(lib, 'foo_%s' % typename.replace(' ', '_'))\n        assert foo(42) == 43\n        if sys.version < '3':\n            assert foo(long(44)) == 45\n        assert foo(ffi.cast(typename, 46)) == 47\n        py.test.raises(TypeError, foo, ffi.NULL)\n        #\n        # check for overflow cases\n        if all_primitive_types[typename] == 'f':\n            continue\n        for value in [-2**80, -2**40, -2**20, -2**10, -2**5, -1,\n                      2**5, 2**10, 2**20, 2**40, 2**80]:\n            overflows = int(ffi.cast(typename, value)) != value\n            if overflows:\n                py.test.raises(OverflowError, foo, value)\n            else:\n                assert foo(value) == value + 1\n\ndef test_var_signed_integer_types():\n    ffi = FFI()\n    lst = all_signed_integer_types(ffi)\n    csource = \"\\n\".join([\"%s somevar_%s;\" % (tp, tp.replace(' ', '_'))\n                         for tp in lst])\n    ffi.cdef(csource)\n    lib = ffi.verify(csource)\n    for tp in lst:\n        varname = 'somevar_%s' % tp.replace(' ', '_')\n        sz = ffi.sizeof(tp)\n        max = (1 << (8*sz-1)) - 1\n        min = -(1 << (8*sz-1))\n        setattr(lib, varname, max)\n        assert getattr(lib, varname) == max\n        setattr(lib, varname, min)\n        assert getattr(lib, varname) == min\n        py.test.raises(OverflowError, setattr, lib, varname, max+1)\n        py.test.raises(OverflowError, setattr, lib, varname, min-1)\n\ndef test_var_unsigned_integer_types():\n    ffi = FFI()\n    lst = all_unsigned_integer_types(ffi)\n    csource = \"\\n\".join([\"%s somevar_%s;\" % (tp, tp.replace(' ', '_'))\n                         for tp in lst])\n    ffi.cdef(csource)\n    lib = ffi.verify(csource)\n    for tp in lst:\n        varname = 'somevar_%s' % tp.replace(' ', '_')\n        sz = ffi.sizeof(tp)\n        if tp != '_Bool':\n            max = (1 << (8*sz)) - 1\n        else:\n            max = 1\n        setattr(lib, varname, max)\n        assert getattr(lib, varname) == max\n        setattr(lib, varname, 0)\n        assert getattr(lib, varname) == 0\n        py.test.raises(OverflowError, setattr, lib, varname, max+1)\n        py.test.raises(OverflowError, setattr, lib, varname, -1)\n\ndef test_fn_signed_integer_types():\n    ffi = FFI()\n    lst = all_signed_integer_types(ffi)\n    cdefsrc = \"\\n\".join([\"%s somefn_%s(%s);\" % (tp, tp.replace(' ', '_'), tp)\n                         for tp in lst])\n    ffi.cdef(cdefsrc)\n    verifysrc = \"\\n\".join([\"%s somefn_%s(%s x) { return x; }\" %\n                           (tp, tp.replace(' ', '_'), tp) for tp in lst])\n    lib = ffi.verify(verifysrc)\n    for tp in lst:\n        fnname = 'somefn_%s' % tp.replace(' ', '_')\n        sz = ffi.sizeof(tp)\n        max = (1 << (8*sz-1)) - 1\n        min = -(1 << (8*sz-1))\n        fn = getattr(lib, fnname)\n        assert fn(max) == max\n        assert fn(min) == min\n        py.test.raises(OverflowError, fn, max + 1)\n        py.test.raises(OverflowError, fn, min - 1)\n\ndef test_fn_unsigned_integer_types():\n    ffi = FFI()\n    lst = all_unsigned_integer_types(ffi)\n    cdefsrc = \"\\n\".join([\"%s somefn_%s(%s);\" % (tp, tp.replace(' ', '_'), tp)\n                         for tp in lst])\n    ffi.cdef(cdefsrc)\n    verifysrc = \"\\n\".join([\"%s somefn_%s(%s x) { return x; }\" %\n                           (tp, tp.replace(' ', '_'), tp) for tp in lst])\n    lib = ffi.verify(verifysrc)\n    for tp in lst:\n        fnname = 'somefn_%s' % tp.replace(' ', '_')\n        sz = ffi.sizeof(tp)\n        if tp != '_Bool':\n            max = (1 << (8*sz)) - 1\n        else:\n            max = 1\n        fn = getattr(lib, fnname)\n        assert fn(max) == max\n        assert fn(0) == 0\n        py.test.raises(OverflowError, fn, max + 1)\n        py.test.raises(OverflowError, fn, -1)\n\ndef test_char_type():\n    ffi = FFI()\n    ffi.cdef(\"char foo(char);\")\n    lib = ffi.verify(\"char foo(char x) { return ++x; }\")\n    assert lib.foo(b\"A\") == b\"B\"\n    py.test.raises(TypeError, lib.foo, b\"bar\")\n    py.test.raises(TypeError, lib.foo, \"bar\")\n\ndef test_wchar_type():\n    ffi = FFI()\n    if ffi.sizeof('wchar_t') == 2:\n        uniexample1 = u+'\\u1234'\n        uniexample2 = u+'\\u1235'\n    else:\n        uniexample1 = u+'\\U00012345'\n        uniexample2 = u+'\\U00012346'\n    #\n    ffi.cdef(\"wchar_t foo(wchar_t);\")\n    lib = ffi.verify(\"wchar_t foo(wchar_t x) { return x+1; }\")\n    assert lib.foo(uniexample1) == uniexample2\n\ndef test_no_argument():\n    ffi = FFI()\n    ffi.cdef(\"int foo(void);\")\n    lib = ffi.verify(\"int foo(void) { return 42; }\")\n    assert lib.foo() == 42\n\ndef test_two_arguments():\n    ffi = FFI()\n    ffi.cdef(\"int foo(int, int);\")\n    lib = ffi.verify(\"int foo(int a, int b) { return a - b; }\")\n    assert lib.foo(40, -2) == 42\n\ndef test_macro():\n    ffi = FFI()\n    ffi.cdef(\"int foo(int, int);\")\n    lib = ffi.verify(\"#define foo(a, b) ((a) * (b))\")\n    assert lib.foo(-6, -7) == 42\n\ndef test_ptr():\n    ffi = FFI()\n    ffi.cdef(\"int *foo(int *);\")\n    lib = ffi.verify(\"int *foo(int *a) { return a; }\")\n    assert lib.foo(ffi.NULL) == ffi.NULL\n    p = ffi.new(\"int *\", 42)\n    q = ffi.new(\"int *\", 42)\n    assert lib.foo(p) == p\n    assert lib.foo(q) != p\n\ndef test_bogus_ptr():\n    ffi = FFI()\n    ffi.cdef(\"int *foo(int *);\")\n    lib = ffi.verify(\"int *foo(int *a) { return a; }\")\n    py.test.raises(TypeError, lib.foo, ffi.new(\"short *\", 42))\n\n\ndef test_verify_typedefs():\n    py.test.skip(\"ignored so far\")\n    types = ['signed char', 'unsigned char', 'int', 'long']\n    for cdefed in types:\n        for real in types:\n            ffi = FFI()\n            ffi.cdef(\"typedef %s foo_t;\" % cdefed)\n            if cdefed == real:\n                ffi.verify(\"typedef %s foo_t;\" % real)\n            else:\n                py.test.raises(VerificationError, ffi.verify,\n                               \"typedef %s foo_t;\" % real)\n\ndef test_nondecl_struct():\n    ffi = FFI()\n    ffi.cdef(\"typedef struct foo_s foo_t; int bar(foo_t *);\")\n    lib = ffi.verify(\"typedef struct foo_s foo_t;\\n\"\n                     \"int bar(foo_t *f) { (void)f; return 42; }\\n\")\n    assert lib.bar(ffi.NULL) == 42\n\ndef test_ffi_full_struct():\n    def check(verified_code):\n        ffi = FFI()\n        ffi.cdef(\"struct foo_s { char x; int y; long *z; };\")\n        ffi.verify(verified_code)\n        ffi.new(\"struct foo_s *\", {})\n\n    check(\"struct foo_s { char x; int y; long *z; };\")\n    #\n    if sys.platform != 'win32':  # XXX fixme: only gives warnings\n        py.test.raises(VerificationError, check,\n            \"struct foo_s { char x; int y; int *z; };\")\n    #\n    py.test.raises(VerificationError, check,\n        \"struct foo_s { int y; long *z; };\")     # cdef'ed field x is missing\n    #\n    e = py.test.raises(FFI.error, check,\n                       \"struct foo_s { int y; char x; long *z; };\")\n    assert str(e.value).startswith(\n        \"struct foo_s: wrong offset for field 'x'\"\n        \" (cdef says 0, but C compiler says 4)\")\n    #\n    e = py.test.raises(FFI.error, check,\n        \"struct foo_s { char x; int y; long *z; char extra; };\")\n    assert str(e.value).startswith(\n        \"struct foo_s: wrong total size\"\n        \" (cdef says %d, but C compiler says %d)\" % (\n            8 + FFI().sizeof('long *'),\n            8 + FFI().sizeof('long *') * 2))\n    #\n    # a corner case that we cannot really detect, but where it has no\n    # bad consequences: the size is the same, but there is an extra field\n    # that replaces what is just padding in our declaration above\n    check(\"struct foo_s { char x, extra; int y; long *z; };\")\n    #\n    e = py.test.raises(FFI.error, check,\n        \"struct foo_s { char x; short pad; short y; long *z; };\")\n    assert str(e.value).startswith(\n        \"struct foo_s: wrong size for field 'y'\"\n        \" (cdef says 4, but C compiler says 2)\")\n\ndef test_ffi_nonfull_struct():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n    struct foo_s {\n       int x;\n       ...;\n    };\n    \"\"\")\n    py.test.raises(VerificationMissing, ffi.sizeof, 'struct foo_s')\n    py.test.raises(VerificationMissing, ffi.offsetof, 'struct foo_s', 'x')\n    py.test.raises(VerificationMissing, ffi.new, 'struct foo_s *')\n    ffi.verify(\"\"\"\n    struct foo_s {\n       int a, b, x, c, d, e;\n    };\n    \"\"\")\n    assert ffi.sizeof('struct foo_s') == 6 * ffi.sizeof('int')\n    assert ffi.offsetof('struct foo_s', 'x') == 2 * ffi.sizeof('int')\n\ndef test_ffi_nonfull_alignment():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { char x; ...; };\")\n    ffi.verify(\"struct foo_s { int a, b; char x; };\")\n    assert ffi.sizeof('struct foo_s') == 3 * ffi.sizeof('int')\n    assert ffi.alignof('struct foo_s') == ffi.sizeof('int')\n\ndef _check_field_match(typename, real, expect_mismatch):\n    ffi = FFI()\n    testing_by_size = (expect_mismatch == 'by_size')\n    if testing_by_size:\n        expect_mismatch = ffi.sizeof(typename) != ffi.sizeof(real)\n    ffi.cdef(\"struct foo_s { %s x; ...; };\" % typename)\n    try:\n        ffi.verify(\"struct foo_s { %s x; };\" % real)\n        ffi.new(\"struct foo_s *\", [])  # because some mismatches show up lazily\n    except (VerificationError, ffi.error):\n        if not expect_mismatch:\n            if testing_by_size and typename != real:\n                print(\"ignoring mismatch between %s* and %s* even though \"\n                      \"they have the same size\" % (typename, real))\n                return\n            raise AssertionError(\"unexpected mismatch: %s should be accepted \"\n                                 \"as equal to %s\" % (typename, real))\n    else:\n        if expect_mismatch:\n            raise AssertionError(\"mismatch not detected: \"\n                                 \"%s != %s\" % (typename, real))\n\ndef test_struct_bad_sized_integer():\n    for typename in ['int8_t', 'int16_t', 'int32_t', 'int64_t']:\n        for real in ['int8_t', 'int16_t', 'int32_t', 'int64_t']:\n            _check_field_match(typename, real, \"by_size\")\n\ndef test_struct_bad_sized_float():\n    for typename in all_float_types:\n        for real in all_float_types:\n            _check_field_match(typename, real, \"by_size\")\n\ndef test_struct_signedness_ignored():\n    _check_field_match(\"int\", \"unsigned int\", expect_mismatch=False)\n    _check_field_match(\"unsigned short\", \"signed short\", expect_mismatch=False)\n\ndef test_struct_float_vs_int():\n    if sys.platform == 'win32':\n        py.test.skip(\"XXX fixme: only gives warnings\")\n    ffi = FFI()\n    for typename in all_signed_integer_types(ffi):\n        for real in all_float_types:\n            _check_field_match(typename, real, expect_mismatch=True)\n    for typename in all_float_types:\n        for real in all_signed_integer_types(ffi):\n            _check_field_match(typename, real, expect_mismatch=True)\n\ndef test_struct_array_field():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int a[17]; ...; };\")\n    ffi.verify(\"struct foo_s { int x; int a[17]; int y; };\")\n    assert ffi.sizeof('struct foo_s') == 19 * ffi.sizeof('int')\n    s = ffi.new(\"struct foo_s *\")\n    assert ffi.sizeof(s.a) == 17 * ffi.sizeof('int')\n\ndef test_struct_array_no_length():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int a[]; int y; ...; };\\n\"\n             \"int bar(struct foo_s *);\\n\")\n    lib = ffi.verify(\"struct foo_s { int x; int a[17]; int y; };\\n\"\n                     \"int bar(struct foo_s *f) { return f->a[14]; }\\n\")\n    assert ffi.sizeof('struct foo_s') == 19 * ffi.sizeof('int')\n    s = ffi.new(\"struct foo_s *\")\n    assert ffi.typeof(s.a) is ffi.typeof('int *')   # because no length\n    s.a[14] = 4242\n    assert lib.bar(s) == 4242\n    # with no declared length, out-of-bound accesses are not detected\n    s.a[17] = -521\n    assert s.y == s.a[17] == -521\n    #\n    s = ffi.new(\"struct foo_s *\", {'a': list(range(17))})\n    assert s.a[16] == 16\n    # overflows at construction time not detected either\n    s = ffi.new(\"struct foo_s *\", {'a': list(range(18))})\n    assert s.y == s.a[17] == 17\n\ndef test_struct_array_guess_length():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int a[...]; };\")\n    ffi.verify(\"struct foo_s { int x; int a[17]; int y; };\")\n    assert ffi.sizeof('struct foo_s') == 19 * ffi.sizeof('int')\n    s = ffi.new(\"struct foo_s *\")\n    assert ffi.sizeof(s.a) == 17 * ffi.sizeof('int')\n    py.test.raises(IndexError, 's.a[17]')\n\ndef test_struct_array_c99_1():\n    if sys.platform == 'win32':\n        py.test.skip(\"requires C99\")\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int x; int a[]; };\")\n    ffi.verify(\"struct foo_s { int x; int a[]; };\")\n    assert ffi.sizeof('struct foo_s') == 1 * ffi.sizeof('int')\n    s = ffi.new(\"struct foo_s *\", [424242, 4])\n    assert ffi.sizeof(s[0]) == 1 * ffi.sizeof('int')   # the same in C\n    assert s.a[3] == 0\n    s = ffi.new(\"struct foo_s *\", [424242, [-40, -30, -20, -10]])\n    assert ffi.sizeof(s[0]) == 1 * ffi.sizeof('int')\n    assert s.a[3] == -10\n    s = ffi.new(\"struct foo_s *\")\n    assert ffi.sizeof(s[0]) == 1 * ffi.sizeof('int')\n    s = ffi.new(\"struct foo_s *\", [424242])\n    assert ffi.sizeof(s[0]) == 1 * ffi.sizeof('int')\n\ndef test_struct_array_c99_2():\n    if sys.platform == 'win32':\n        py.test.skip(\"requires C99\")\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int x; int a[]; ...; };\")\n    ffi.verify(\"struct foo_s { int x, y; int a[]; };\")\n    assert ffi.sizeof('struct foo_s') == 2 * ffi.sizeof('int')\n    s = ffi.new(\"struct foo_s *\", [424242, 4])\n    assert ffi.sizeof(s[0]) == 2 * ffi.sizeof('int')\n    assert s.a[3] == 0\n    s = ffi.new(\"struct foo_s *\", [424242, [-40, -30, -20, -10]])\n    assert ffi.sizeof(s[0]) == 2 * ffi.sizeof('int')\n    assert s.a[3] == -10\n    s = ffi.new(\"struct foo_s *\")\n    assert ffi.sizeof(s[0]) == 2 * ffi.sizeof('int')\n    s = ffi.new(\"struct foo_s *\", [424242])\n    assert ffi.sizeof(s[0]) == 2 * ffi.sizeof('int')\n\ndef test_struct_ptr_to_array_field():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int (*a)[17]; ...; }; struct bar_s { ...; };\")\n    ffi.verify(\"struct foo_s { int x; int (*a)[17]; int y; };\\n\"\n               \"struct bar_s { int x; int *a; int y; };\")\n    assert ffi.sizeof('struct foo_s') == ffi.sizeof(\"struct bar_s\")\n    s = ffi.new(\"struct foo_s *\")\n    assert ffi.sizeof(s.a) == ffi.sizeof('int(*)[17]') == ffi.sizeof(\"int *\")\n\ndef test_struct_with_bitfield_exact():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int a:2, b:3; };\")\n    ffi.verify(\"struct foo_s { int a:2, b:3; };\")\n    s = ffi.new(\"struct foo_s *\")\n    s.b = 3\n    py.test.raises(OverflowError, \"s.b = 4\")\n    assert s.b == 3\n\ndef test_struct_with_bitfield_enum():\n    ffi = FFI()\n    code = \"\"\"\n        typedef enum { AA, BB, CC } foo_e;\n        typedef struct { foo_e f:2; } foo_s;\n    \"\"\"\n    ffi.cdef(code)\n    ffi.verify(code)\n    s = ffi.new(\"foo_s *\")\n    s.f = 1\n    assert s.f == 1\n    if int(ffi.cast(\"foo_e\", -1)) < 0:\n        two = -2\n    else:\n        two = 2\n    s.f = two\n    assert s.f == two\n\ndef test_unsupported_struct_with_bitfield_ellipsis():\n    ffi = FFI()\n    py.test.raises(NotImplementedError, ffi.cdef,\n                   \"struct foo_s { int a:2, b:3; ...; };\")\n\ndef test_global_constants():\n    ffi = FFI()\n    # use 'static const int', as generally documented, although in this\n    # case the 'static' is completely ignored.\n    ffi.cdef(\"static const int AA, BB, CC, DD;\")\n    lib = ffi.verify(\"#define AA 42\\n\"\n                     \"#define BB (-43)   // blah\\n\"\n                     \"#define CC (22*2)  /* foobar */\\n\"\n                     \"#define DD ((unsigned int)142)  /* foo\\nbar */\\n\")\n    assert lib.AA == 42\n    assert lib.BB == -43\n    assert lib.CC == 44\n    assert lib.DD == 142\n\ndef test_global_const_int_size():\n    # integer constants: ignore the declared type, always just use the value\n    for value in [-2**63, -2**31, -2**15,\n                  2**15-1, 2**15, 2**31-1, 2**31, 2**32-1, 2**32,\n                  2**63-1, 2**63, 2**64-1]:\n        ffi = FFI()\n        if value == int(ffi.cast(\"long long\", value)):\n            if value < 0:\n                vstr = '(-%dLL-1)' % (~value,)\n            else:\n                vstr = '%dLL' % value\n        elif value == int(ffi.cast(\"unsigned long long\", value)):\n            vstr = '%dULL' % value\n        else:\n            raise AssertionError(value)\n        ffi.cdef(\"static const unsigned short AA;\")\n        lib = ffi.verify(\"#define AA %s\\n\" % vstr)\n        assert lib.AA == value\n        assert type(lib.AA) is type(int(lib.AA))\n\ndef test_global_constants_non_int():\n    ffi = FFI()\n    ffi.cdef(\"static char *const PP;\")\n    lib = ffi.verify('static char *const PP = \"testing!\";\\n')\n    assert ffi.typeof(lib.PP) == ffi.typeof(\"char *\")\n    assert ffi.string(lib.PP) == b\"testing!\"\n\ndef test_nonfull_enum():\n    ffi = FFI()\n    ffi.cdef(\"enum ee { EE1, EE2, EE3, ... \\n \\t };\")\n    py.test.raises(VerificationMissing, ffi.cast, 'enum ee', 'EE2')\n    ffi.verify(\"enum ee { EE1=10, EE2, EE3=-10, EE4 };\")\n    assert ffi.string(ffi.cast('enum ee', 11)) == \"EE2\"\n    assert ffi.string(ffi.cast('enum ee', -10)) == \"EE3\"\n    #\n    # try again\n    ffi.verify(\"enum ee { EE1=10, EE2, EE3=-10, EE4 };\")\n    assert ffi.string(ffi.cast('enum ee', 11)) == \"EE2\"\n    #\n    assert ffi.typeof(\"enum ee\").relements == {'EE1': 10, 'EE2': 11, 'EE3': -10}\n    assert ffi.typeof(\"enum ee\").elements == {10: 'EE1', 11: 'EE2', -10: 'EE3'}\n\ndef test_full_enum():\n    ffi = FFI()\n    ffi.cdef(\"enum ee { EE1, EE2, EE3 };\")\n    ffi.verify(\"enum ee { EE1, EE2, EE3 };\")\n    py.test.raises(VerificationError, ffi.verify, \"enum ee { EE1, EE2 };\")\n    # disabled: for now, we always accept and fix transparently constant values\n    #e = py.test.raises(VerificationError, ffi.verify,\n    #                   \"enum ee { EE1, EE3, EE2 };\")\n    #assert str(e.value) == 'enum ee: EE2 has the real value 2, not 1'\n    # extra items cannot be seen and have no bad consequence anyway\n    lib = ffi.verify(\"enum ee { EE1, EE2, EE3, EE4 };\")\n    assert lib.EE3 == 2\n\ndef test_enum_usage():\n    ffi = FFI()\n    ffi.cdef(\"enum ee { EE1,EE2 }; typedef struct { enum ee x; } *sp;\")\n    lib = ffi.verify(\"enum ee { EE1,EE2 }; typedef struct { enum ee x; } *sp;\")\n    assert lib.EE2 == 1\n    s = ffi.new(\"sp\", [lib.EE2])\n    assert s.x == 1\n    s.x = 17\n    assert s.x == 17\n\ndef test_anonymous_enum():\n    ffi = FFI()\n    ffi.cdef(\"enum { EE1 }; enum { EE2, EE3 };\")\n    lib = ffi.verify(\"enum { EE1 }; enum { EE2, EE3 };\")\n    assert lib.EE1 == 0\n    assert lib.EE2 == 0\n    assert lib.EE3 == 1\n\ndef test_nonfull_anonymous_enum():\n    ffi = FFI()\n    ffi.cdef(\"enum { EE1, ... }; enum { EE3, ... };\")\n    lib = ffi.verify(\"enum { EE2, EE1 }; enum { EE3 };\")\n    assert lib.EE1 == 1\n    assert lib.EE3 == 0\n\ndef test_nonfull_enum_syntax2():\n    ffi = FFI()\n    ffi.cdef(\"enum ee { EE1, EE2=\\t..., EE3 };\")\n    py.test.raises(VerificationMissing, ffi.cast, 'enum ee', 'EE1')\n    ffi.verify(\"enum ee { EE1=10, EE2, EE3=-10, EE4 };\")\n    assert ffi.string(ffi.cast('enum ee', 11)) == 'EE2'\n    assert ffi.string(ffi.cast('enum ee', -10)) == 'EE3'\n    #\n    ffi = FFI()\n    ffi.cdef(\"enum ee { EE1, EE2=\\t... };\")\n    py.test.raises(VerificationMissing, ffi.cast, 'enum ee', 'EE1')\n    ffi.verify(\"enum ee { EE1=10, EE2, EE3=-10, EE4 };\")\n    assert ffi.string(ffi.cast('enum ee', 11)) == 'EE2'\n    #\n    ffi = FFI()\n    ffi.cdef(\"enum ee2 { EE4=..., EE5=..., ... };\")\n    ffi.verify(\"enum ee2 { EE4=-1234-5, EE5 }; \")\n    assert ffi.string(ffi.cast('enum ee2', -1239)) == 'EE4'\n    assert ffi.string(ffi.cast('enum ee2', -1238)) == 'EE5'\n\ndef test_get_set_errno():\n    ffi = FFI()\n    ffi.cdef(\"int foo(int);\")\n    lib = ffi.verify(\"\"\"\n        static int foo(int x)\n        {\n            errno += 1;\n            return x * 7;\n        }\n    \"\"\")\n    ffi.errno = 15\n    assert lib.foo(6) == 42\n    assert ffi.errno == 16\n\ndef test_define_int():\n    ffi = FFI()\n    ffi.cdef(\"#define FOO ...\\n\"\n             \"\\t#\\tdefine\\tBAR\\t...\\t\\n\"\n             \"#define BAZ ...\\n\")\n    lib = ffi.verify(\"#define FOO 42\\n\"\n                     \"#define BAR (-44)\\n\"\n                     \"#define BAZ 0xffffffffffffffffULL\\n\")\n    assert lib.FOO == 42\n    assert lib.BAR == -44\n    assert lib.BAZ == 0xffffffffffffffff\n\ndef test_access_variable():\n    ffi = FFI()\n    ffi.cdef(\"int foo(void);\\n\"\n             \"int somenumber;\")\n    lib = ffi.verify(\"\"\"\n        static int somenumber = 2;\n        static int foo(void) {\n            return somenumber * 7;\n        }\n    \"\"\")\n    assert lib.somenumber == 2\n    assert lib.foo() == 14\n    lib.somenumber = -6\n    assert lib.foo() == -42\n    assert lib.somenumber == -6\n    lib.somenumber = 2   # reset for the next run, if any\n\ndef test_access_address_of_variable():\n    # access the address of 'somenumber': need a trick\n    ffi = FFI()\n    ffi.cdef(\"int somenumber; static int *const somenumberptr;\")\n    lib = ffi.verify(\"\"\"\n        static int somenumber = 2;\n        #define somenumberptr (&somenumber)\n    \"\"\")\n    assert lib.somenumber == 2\n    lib.somenumberptr[0] = 42\n    assert lib.somenumber == 42\n    lib.somenumber = 2    # reset for the next run, if any\n\ndef test_access_array_variable(length=5):\n    ffi = FFI()\n    ffi.cdef(\"int foo(int);\\n\"\n             \"int somenumber[%s];\" % (length,))\n    lib = ffi.verify(\"\"\"\n        static int somenumber[] = {2, 2, 3, 4, 5};\n        static int foo(int i) {\n            return somenumber[i] * 7;\n        }\n    \"\"\")\n    if length == '':\n        # a global variable of an unknown array length is implicitly\n        # transformed into a global pointer variable, because we can only\n        # work with array instances whose length we know.  using a pointer\n        # instead of an array gives the correct effects.\n        assert repr(lib.somenumber).startswith(\"<cdata 'int *' 0x\")\n        py.test.raises(TypeError, len, lib.somenumber)\n    else:\n        assert repr(lib.somenumber).startswith(\"<cdata 'int[%s]' 0x\" % length)\n        assert len(lib.somenumber) == 5\n    assert lib.somenumber[3] == 4\n    assert lib.foo(3) == 28\n    lib.somenumber[3] = -6\n    assert lib.foo(3) == -42\n    assert lib.somenumber[3] == -6\n    assert lib.somenumber[4] == 5\n    lib.somenumber[3] = 4    # reset for the next run, if any\n\ndef test_access_array_variable_length_hidden():\n    test_access_array_variable(length='')\n\ndef test_access_struct_variable():\n    ffi = FFI()\n    ffi.cdef(\"struct foo { int x; ...; };\\n\"\n             \"int foo(int);\\n\"\n             \"struct foo stuff;\")\n    lib = ffi.verify(\"\"\"\n        struct foo { int x, y, z; };\n        static struct foo stuff = {2, 5, 8};\n        static int foo(int i) {\n            switch (i) {\n            case 0: return stuff.x * 7;\n            case 1: return stuff.y * 7;\n            case 2: return stuff.z * 7;\n            }\n            return -1;\n        }\n    \"\"\")\n    assert lib.stuff.x == 2\n    assert lib.foo(0) == 14\n    assert lib.foo(1) == 35\n    assert lib.foo(2) == 56\n    lib.stuff.x = -6\n    assert lib.foo(0) == -42\n    assert lib.foo(1) == 35\n    lib.stuff.x = 2      # reset for the next run, if any\n\ndef test_access_callback():\n    ffi = FFI()\n    ffi.cdef(\"int (*cb)(int);\\n\"\n             \"int foo(int);\\n\"\n             \"void reset_cb(void);\")\n    lib = ffi.verify(\"\"\"\n        static int g(int x) { return x * 7; }\n        static int (*cb)(int);\n        static int foo(int i) { return cb(i) - 1; }\n        static void reset_cb(void) { cb = g; }\n    \"\"\")\n    lib.reset_cb()\n    assert lib.foo(6) == 41\n    my_callback = ffi.callback(\"int(*)(int)\", lambda n: n * 222)\n    lib.cb = my_callback\n    assert lib.foo(4) == 887\n\ndef test_access_callback_function_typedef():\n    ffi = FFI()\n    ffi.cdef(\"typedef int mycallback_t(int);\\n\"\n             \"mycallback_t *cb;\\n\"\n             \"int foo(int);\\n\"\n             \"void reset_cb(void);\")\n    lib = ffi.verify(\"\"\"\n        static int g(int x) { return x * 7; }\n        static int (*cb)(int);\n        static int foo(int i) { return cb(i) - 1; }\n        static void reset_cb(void) { cb = g; }\n    \"\"\")\n    lib.reset_cb()\n    assert lib.foo(6) == 41\n    my_callback = ffi.callback(\"int(*)(int)\", lambda n: n * 222)\n    lib.cb = my_callback\n    assert lib.foo(4) == 887\n\ndef test_call_with_struct_ptr():\n    ffi = FFI()\n    ffi.cdef(\"typedef struct { int x; ...; } foo_t; int foo(foo_t *);\")\n    lib = ffi.verify(\"\"\"\n        typedef struct { int y, x; } foo_t;\n        static int foo(foo_t *f) { return f->x * 7; }\n    \"\"\")\n    f = ffi.new(\"foo_t *\")\n    f.x = 6\n    assert lib.foo(f) == 42\n\ndef test_unknown_type():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef ... token_t;\n        int foo(token_t *);\n        #define TOKEN_SIZE ...\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        typedef float token_t;\n        static int foo(token_t *tk) {\n            if (!tk)\n                return -42;\n            *tk += 1.601f;\n            return (int)*tk;\n        }\n        #define TOKEN_SIZE sizeof(token_t)\n    \"\"\")\n    # we cannot let ffi.new(\"token_t *\") work, because we don't know ahead of\n    # time if it's ok to ask 'sizeof(token_t)' in the C code or not.\n    # See test_unknown_type_2.  Workaround.\n    tkmem = ffi.new(\"char[]\", lib.TOKEN_SIZE)    # zero-initialized\n    tk = ffi.cast(\"token_t *\", tkmem)\n    results = [lib.foo(tk) for i in range(6)]\n    assert results == [1, 3, 4, 6, 8, 9]\n    assert lib.foo(ffi.NULL) == -42\n\ndef test_unknown_type_2():\n    ffi = FFI()\n    ffi.cdef(\"typedef ... token_t;\")\n    lib = ffi.verify(\"typedef struct token_s token_t;\")\n    # assert did not crash, even though 'sizeof(token_t)' is not valid in C.\n\ndef test_unknown_type_3():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef ... *token_p;\n        token_p foo(token_p);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        typedef struct _token_s *token_p;\n        token_p foo(token_p arg) {\n            if (arg)\n                return (token_p)0x12347;\n            else\n                return (token_p)0x12345;\n        }\n    \"\"\")\n    p = lib.foo(ffi.NULL)\n    assert int(ffi.cast(\"intptr_t\", p)) == 0x12345\n    q = lib.foo(p)\n    assert int(ffi.cast(\"intptr_t\", q)) == 0x12347\n\ndef test_varargs():\n    ffi = FFI()\n    ffi.cdef(\"int foo(int x, ...);\")\n    lib = ffi.verify(\"\"\"\n        int foo(int x, ...) {\n            va_list vargs;\n            va_start(vargs, x);\n            x -= va_arg(vargs, int);\n            x -= va_arg(vargs, int);\n            va_end(vargs);\n            return x;\n        }\n    \"\"\")\n    assert lib.foo(50, ffi.cast(\"int\", 5), ffi.cast(\"int\", 3)) == 42\n\ndef test_varargs_exact():\n    if sys.platform == 'win32':\n        py.test.skip(\"XXX fixme: only gives warnings\")\n    ffi = FFI()\n    ffi.cdef(\"int foo(int x, ...);\")\n    py.test.raises(VerificationError, ffi.verify, \"\"\"\n        int foo(long long x, ...) {\n            return x;\n        }\n    \"\"\")\n\ndef test_varargs_struct():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { char a; int b; }; int foo(int x, ...);\")\n    lib = ffi.verify(\"\"\"\n        struct foo_s {\n            char a; int b;\n        };\n        int foo(int x, ...) {\n            va_list vargs;\n            struct foo_s s;\n            va_start(vargs, x);\n            s = va_arg(vargs, struct foo_s);\n            va_end(vargs);\n            return s.a - s.b;\n        }\n    \"\"\")\n    s = ffi.new(\"struct foo_s *\", [b'B', 1])\n    assert lib.foo(50, s[0]) == ord('A')\n\ndef test_autofilled_struct_as_argument():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { long a; double b; ...; };\\n\"\n             \"int foo(struct foo_s);\")\n    lib = ffi.verify(\"\"\"\n        struct foo_s {\n            double b;\n            long a;\n        };\n        int foo(struct foo_s s) {\n            return (int)s.a - (int)s.b;\n        }\n    \"\"\")\n    s = ffi.new(\"struct foo_s *\", [100, 1])\n    assert lib.foo(s[0]) == 99\n    assert lib.foo([100, 1]) == 99\n\ndef test_autofilled_struct_as_argument_dynamic():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { long a; ...; };\\n\"\n             \"int (*foo)(struct foo_s);\")\n    lib = ffi.verify(\"\"\"\n        struct foo_s {\n            double b;\n            long a;\n        };\n        int foo1(struct foo_s s) {\n            return (int)s.a - (int)s.b;\n        }\n        int (*foo)(struct foo_s s) = &foo1;\n    \"\"\")\n    e = py.test.raises(NotImplementedError, lib.foo, \"?\")\n    msg = (\"ctype 'struct foo_s' not supported as argument (it is a struct \"\n           'declared with \"...;\", but the C calling convention may depend '\n           'on the missing fields)')\n    assert str(e.value) == msg\n\ndef test_func_returns_struct():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        struct foo_s { int aa, bb; };\n        struct foo_s foo(int a, int b);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        struct foo_s { int aa, bb; };\n        struct foo_s foo(int a, int b) {\n            struct foo_s r;\n            r.aa = a*a;\n            r.bb = b*b;\n            return r;\n        }\n    \"\"\")\n    s = lib.foo(6, 7)\n    assert repr(s) == \"<cdata 'struct foo_s' owning 8 bytes>\"\n    assert s.aa == 36\n    assert s.bb == 49\n\ndef test_func_as_funcptr():\n    ffi = FFI()\n    ffi.cdef(\"int *(*const fooptr)(void);\")\n    lib = ffi.verify(\"\"\"\n        int *foo(void) {\n            return (int*)\"foobar\";\n        }\n        int *(*fooptr)(void) = foo;\n    \"\"\")\n    foochar = ffi.cast(\"char *(*)(void)\", lib.fooptr)\n    s = foochar()\n    assert ffi.string(s) == b\"foobar\"\n\ndef test_funcptr_as_argument():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        void qsort(void *base, size_t nel, size_t width,\n            int (*compar)(const void *, const void *));\n    \"\"\")\n    ffi.verify(\"#include <stdlib.h>\")\n\ndef test_func_as_argument():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        void qsort(void *base, size_t nel, size_t width,\n            int compar(const void *, const void *));\n    \"\"\")\n    ffi.verify(\"#include <stdlib.h>\")\n\ndef test_array_as_argument():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        size_t strlen(char string[]);\n    \"\"\")\n    ffi.verify(\"#include <string.h>\")\n\ndef test_enum_as_argument():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        enum foo_e { AA, BB, ... };\n        int foo_func(enum foo_e);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        enum foo_e { AA, CC, BB };\n        int foo_func(enum foo_e e) { return (int)e; }\n    \"\"\")\n    assert lib.foo_func(lib.BB) == 2\n    py.test.raises(TypeError, lib.foo_func, \"BB\")\n\ndef test_enum_as_function_result():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        enum foo_e { AA, BB, ... };\n        enum foo_e foo_func(int x);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        enum foo_e { AA, CC, BB };\n        enum foo_e foo_func(int x) { return (enum foo_e)x; }\n    \"\"\")\n    assert lib.foo_func(lib.BB) == lib.BB == 2\n\ndef test_enum_values():\n    ffi = FFI()\n    ffi.cdef(\"enum enum1_e { AA, BB };\")\n    lib = ffi.verify(\"enum enum1_e { AA, BB };\")\n    assert lib.AA == 0\n    assert lib.BB == 1\n    assert ffi.string(ffi.cast(\"enum enum1_e\", 1)) == 'BB'\n\ndef test_typedef_complete_enum():\n    ffi = FFI()\n    ffi.cdef(\"typedef enum { AA, BB } enum1_t;\")\n    lib = ffi.verify(\"typedef enum { AA, BB } enum1_t;\")\n    assert ffi.string(ffi.cast(\"enum1_t\", 1)) == 'BB'\n    assert lib.AA == 0\n    assert lib.BB == 1\n\ndef test_typedef_broken_complete_enum():\n    # xxx this is broken in old cffis, but works with recompiler.py\n    ffi = FFI()\n    ffi.cdef(\"typedef enum { AA, BB } enum1_t;\")\n    lib = ffi.verify(\"typedef enum { AA, CC, BB } enum1_t;\")\n    assert lib.AA == 0\n    assert lib.BB == 2\n\ndef test_typedef_incomplete_enum():\n    ffi = FFI()\n    ffi.cdef(\"typedef enum { AA, BB, ... } enum1_t;\")\n    lib = ffi.verify(\"typedef enum { AA, CC, BB } enum1_t;\")\n    assert ffi.string(ffi.cast(\"enum1_t\", 1)) == '1'\n    assert ffi.string(ffi.cast(\"enum1_t\", 2)) == 'BB'\n    assert lib.AA == 0\n    assert lib.BB == 2\n\ndef test_typedef_enum_as_argument():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef enum { AA, BB, ... } foo_t;\n        int foo_func(foo_t);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        typedef enum { AA, CC, BB } foo_t;\n        int foo_func(foo_t e) { return (int)e; }\n    \"\"\")\n    assert lib.foo_func(lib.BB) == lib.BB == 2\n    py.test.raises(TypeError, lib.foo_func, \"BB\")\n\ndef test_typedef_enum_as_function_result():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef enum { AA, BB, ... } foo_t;\n        foo_t foo_func(int x);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        typedef enum { AA, CC, BB } foo_t;\n        foo_t foo_func(int x) { return (foo_t)x; }\n    \"\"\")\n    assert lib.foo_func(lib.BB) == lib.BB == 2\n\ndef test_function_typedef():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef double func_t(double);\n        func_t sin;\n    \"\"\")\n    lib = ffi.verify('#include <math.h>', libraries=lib_m)\n    assert lib.sin(1.23) == math.sin(1.23)\n\ndef test_callback_calling_convention():\n    py.test.skip(\"later\")\n    if sys.platform != 'win32':\n        py.test.skip(\"Windows only\")\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        int call1(int(*__cdecl cb)(int));\n        int call2(int(*__stdcall cb)(int));\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        int call1(int(*__cdecl cb)(int)) {\n            return cb(42) + 1;\n        }\n        int call2(int(*__stdcall cb)(int)) {\n            return cb(-42) - 6;\n        }\n    \"\"\")\n    xxx\n\ndef test_opaque_integer_as_function_result():\n    #import platform\n    #if platform.machine().startswith('sparc'):\n    #    py.test.skip('Breaks horribly on sparc (SIGILL + corrupted stack)')\n    #elif platform.machine() == 'mips64' and sys.maxsize > 2**32:\n    #    py.test.skip('Segfaults on mips64el')\n    # XXX bad abuse of \"struct { ...; }\".  It only works a bit by chance\n    # anyway.  XXX think about something better :-(\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef struct { ...; } myhandle_t;\n        myhandle_t foo(void);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        typedef short myhandle_t;\n        myhandle_t foo(void) { return 42; }\n    \"\"\")\n    h = lib.foo()\n    assert ffi.sizeof(h) == ffi.sizeof(\"short\")\n\ndef test_return_partial_struct():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef struct { int x; ...; } foo_t;\n        foo_t foo(void);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        typedef struct { int y, x; } foo_t;\n        foo_t foo(void) { foo_t r = { 45, 81 }; return r; }\n    \"\"\")\n    h = lib.foo()\n    assert ffi.sizeof(h) == 2 * ffi.sizeof(\"int\")\n    assert h.x == 81\n\ndef test_take_and_return_partial_structs():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef struct { int x; ...; } foo_t;\n        foo_t foo(foo_t, foo_t);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        typedef struct { int y, x; } foo_t;\n        foo_t foo(foo_t a, foo_t b) {\n            foo_t r = { 100, a.x * 5 + b.x * 7 };\n            return r;\n        }\n    \"\"\")\n    args = ffi.new(\"foo_t[3]\")\n    args[0].x = 1000\n    args[2].x = -498\n    h = lib.foo(args[0], args[2])\n    assert ffi.sizeof(h) == 2 * ffi.sizeof(\"int\")\n    assert h.x == 1000 * 5 - 498 * 7\n\ndef test_cannot_name_struct_type():\n    ffi = FFI()\n    ffi.cdef(\"typedef struct { int x; } **sp; void foo(sp);\")\n    e = py.test.raises(VerificationError, ffi.verify,\n                       \"typedef struct { int x; } **sp; void foo(sp x) { }\")\n    assert 'in argument of foo: unknown type name' in str(e.value)\n\ndef test_dont_check_unnamable_fields():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { struct { int x; } someone; };\")\n    ffi.verify(\"struct foo_s { struct { int x; } someone; };\")\n    # assert did not crash\n\ndef test_nested_anonymous_struct_exact():\n    if sys.platform == 'win32':\n        py.test.skip(\"nested anonymous struct/union\")\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        struct foo_s { struct { int a; char b; }; union { char c, d; }; };\n    \"\"\")\n    assert ffi.offsetof(\"struct foo_s\", \"c\") == 2 * ffi.sizeof(\"int\")\n    assert ffi.sizeof(\"struct foo_s\") == 3 * ffi.sizeof(\"int\")\n    ffi.verify(\"\"\"\n        struct foo_s { struct { int a; char b; }; union { char c, d; }; };\n    \"\"\")\n    p = ffi.new(\"struct foo_s *\")\n    assert ffi.sizeof(p[0]) == 3 * ffi.sizeof(\"int\")    # with alignment\n    p.a = 1234567\n    p.b = b'X'\n    p.c = b'Y'\n    assert p.a == 1234567\n    assert p.b == b'X'\n    assert p.c == b'Y'\n    assert p.d == b'Y'\n\ndef test_nested_anonymous_struct_exact_error():\n    if sys.platform == 'win32':\n        py.test.skip(\"nested anonymous struct/union\")\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        struct foo_s { struct { int a; char b; }; union { char c, d; }; };\n    \"\"\")\n    py.test.raises(VerificationError, ffi.verify, \"\"\"\n        struct foo_s { struct { int a; short b; }; union { char c, d; }; };\n    \"\"\")\n    # works fine now\n    #py.test.raises(VerificationError, ffi.verify, \"\"\"\n    #    struct foo_s { struct { int a; char e, b; }; union { char c, d; }; };\n    #\"\"\")\n\ndef test_nested_anonymous_struct_inexact_1():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        struct foo_s { struct { char b; ...; }; union { char c, d; }; };\n    \"\"\")\n    ffi.verify(\"\"\"\n        struct foo_s { int a, padding; char c, d, b; };\n    \"\"\")\n    assert ffi.sizeof(\"struct foo_s\") == 3 * ffi.sizeof(\"int\")\n\ndef test_nested_anonymous_struct_inexact_2():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        struct foo_s { union { char c, d; }; struct { int a; char b; }; ...; };\n    \"\"\")\n    ffi.verify(\"\"\"\n        struct foo_s { int a, padding; char c, d, b; };\n    \"\"\")\n    assert ffi.sizeof(\"struct foo_s\") == 3 * ffi.sizeof(\"int\")\n\ndef test_ffi_union():\n    ffi = FFI()\n    ffi.cdef(\"union foo_u { char x; long *z; };\")\n    ffi.verify(\"union foo_u { char x; int y; long *z; };\")\n\ndef test_ffi_union_partial():\n    ffi = FFI()\n    ffi.cdef(\"union foo_u { char x; ...; };\")\n    ffi.verify(\"union foo_u { char x; int y; };\")\n    assert ffi.sizeof(\"union foo_u\") == 4\n\ndef test_ffi_union_with_partial_struct():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int x; ...; }; union foo_u { struct foo_s s; };\")\n    ffi.verify(\"struct foo_s { int a; int x; }; \"\n               \"union foo_u { char b[32]; struct foo_s s; };\")\n    assert ffi.sizeof(\"struct foo_s\") == 8\n    assert ffi.sizeof(\"union foo_u\") == 32\n\ndef test_ffi_union_partial_2():\n    ffi = FFI()\n    ffi.cdef(\"typedef union { char x; ...; } u1;\")\n    ffi.verify(\"typedef union { char x; int y; } u1;\")\n    assert ffi.sizeof(\"u1\") == 4\n\ndef test_ffi_union_with_partial_struct_2():\n    ffi = FFI()\n    ffi.cdef(\"typedef struct { int x; ...; } s1;\"\n             \"typedef union { s1 s; } u1;\")\n    ffi.verify(\"typedef struct { int a; int x; } s1; \"\n               \"typedef union { char b[32]; s1 s; } u1;\")\n    assert ffi.sizeof(\"s1\") == 8\n    assert ffi.sizeof(\"u1\") == 32\n    assert ffi.offsetof(\"u1\", \"s\") == 0\n\ndef test_ffi_struct_packed():\n    if sys.platform == 'win32':\n        py.test.skip(\"needs a GCC extension\")\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int b; ...; };\")\n    ffi.verify(\"\"\"\n        struct foo_s {\n            char a;\n            int b;\n        } __attribute__((packed));\n    \"\"\")\n\ndef test_tmpdir():\n    import tempfile, os\n    from testing.udir import udir\n    tmpdir = tempfile.mkdtemp(dir=str(udir))\n    ffi = FFI()\n    ffi.cdef(\"int foo(int);\")\n    lib = ffi.verify(\"int foo(int a) { return a + 42; }\", tmpdir=tmpdir)\n    assert os.listdir(tmpdir)\n    assert lib.foo(100) == 142\n\ndef test_relative_to():\n    py.test.skip(\"not available\")\n    import tempfile, os\n    from testing.udir import udir\n    tmpdir = tempfile.mkdtemp(dir=str(udir))\n    ffi = FFI()\n    ffi.cdef(\"int foo(int);\")\n    f = open(os.path.join(tmpdir, 'foo.h'), 'w')\n    f.write(\"int foo(int a) { return a + 42; }\\n\")\n    f.close()\n    lib = ffi.verify('#include \"foo.h\"',\n                     include_dirs=['.'],\n                     relative_to=os.path.join(tmpdir, 'x'))\n    assert lib.foo(100) == 142\n\ndef test_bug1():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef struct tdlhandle_s { ...; } *tdl_handle_t;\n        typedef struct my_error_code_ {\n            tdl_handle_t *rh;\n        } my_error_code_t;\n    \"\"\")\n    ffi.verify(\"\"\"\n        typedef struct tdlhandle_s { int foo; } *tdl_handle_t;\n        typedef struct my_error_code_ {\n            tdl_handle_t *rh;\n        } my_error_code_t;\n    \"\"\")\n\ndef test_bool():\n    if sys.platform == 'win32':\n        py.test.skip(\"_Bool not in MSVC\")\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { _Bool x; };\"\n             \"_Bool foo(_Bool);\")\n    lib = ffi.verify(\"\"\"\n        struct foo_s { _Bool x; };\n        int foo(int arg) {\n            return !arg;\n        }\n    \"\"\")\n    p = ffi.new(\"struct foo_s *\")\n    p.x = 1\n    assert p.x == 1\n    py.test.raises(OverflowError, \"p.x = -1\")\n    py.test.raises(TypeError, \"p.x = 0.0\")\n    assert lib.foo(1) == 0\n    assert lib.foo(0) == 1\n    py.test.raises(OverflowError, lib.foo, 42)\n    py.test.raises(TypeError, lib.foo, 0.0)\n    assert int(ffi.cast(\"_Bool\", long(1))) == 1\n    assert int(ffi.cast(\"_Bool\", long(0))) == 0\n    assert int(ffi.cast(\"_Bool\", long(-1))) == 1\n    assert int(ffi.cast(\"_Bool\", 10**200)) == 1\n    assert int(ffi.cast(\"_Bool\", 10**40000)) == 1\n    #\n    class Foo(object):\n        def __int__(self):\n            self.seen = 1\n            return result\n    f = Foo()\n    f.seen = 0\n    result = 42\n    assert int(ffi.cast(\"_Bool\", f)) == 1\n    assert f.seen\n    f.seen = 0\n    result = 0\n    assert int(ffi.cast(\"_Bool\", f)) == 0\n    assert f.seen\n    #\n    py.test.raises(TypeError, ffi.cast, \"_Bool\", [])\n\ndef test_bool_on_long_double():\n    if sys.platform == 'win32':\n        py.test.skip(\"_Bool not in MSVC\")\n    f = 1E-250\n    if f == 0.0 or f*f != 0.0:\n        py.test.skip(\"unexpected precision\")\n    ffi = FFI()\n    ffi.cdef(\"long double square(long double f); _Bool opposite(_Bool);\")\n    lib = ffi.verify(\"long double square(long double f) { return f*f; }\\n\"\n                     \"_Bool opposite(_Bool x) { return !x; }\")\n    f0 = lib.square(0.0)\n    f2 = lib.square(f)\n    f3 = lib.square(f * 2.0)\n    if repr(f2) == repr(f3):\n        py.test.skip(\"long double doesn't have enough precision\")\n    assert float(f0) == float(f2) == float(f3) == 0.0  # too tiny for 'double'\n    assert int(ffi.cast(\"_Bool\", f2)) == 1\n    assert int(ffi.cast(\"_Bool\", f3)) == 1\n    assert int(ffi.cast(\"_Bool\", f0)) == 0\n    py.test.raises(TypeError, lib.opposite, f2)\n\ndef test_cannot_pass_float():\n    for basetype in ['char', 'short', 'int', 'long', 'long long']:\n        for sign in ['signed', 'unsigned']:\n            type = '%s %s' % (sign, basetype)\n            ffi = FFI()\n            ffi.cdef(\"struct foo_s { %s x; };\\n\"\n                     \"int foo(%s);\" % (type, type))\n            lib = ffi.verify(\"\"\"\n                struct foo_s { %s x; };\n                int foo(%s arg) {\n                    return !arg;\n                }\n            \"\"\" % (type, type))\n            p = ffi.new(\"struct foo_s *\")\n            py.test.raises(TypeError, \"p.x = 0.0\")\n            assert lib.foo(42) == 0\n            assert lib.foo(0) == 1\n            py.test.raises(TypeError, lib.foo, 0.0)\n\ndef test_cast_from_int_type_to_bool():\n    ffi = FFI()\n    for basetype in ['char', 'short', 'int', 'long', 'long long']:\n        for sign in ['signed', 'unsigned']:\n            type = '%s %s' % (sign, basetype)\n            assert int(ffi.cast(\"_Bool\", ffi.cast(type, 42))) == 1\n            assert int(ffi.cast(\"bool\", ffi.cast(type, 42))) == 1\n            assert int(ffi.cast(\"_Bool\", ffi.cast(type, 0))) == 0\n\ndef test_addressof():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        struct point_s { int x, y; };\n        struct foo_s { int z; struct point_s point; };\n        struct point_s sum_coord(struct point_s *);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        struct point_s { int x, y; };\n        struct foo_s { int z; struct point_s point; };\n        struct point_s sum_coord(struct point_s *point) {\n            struct point_s r;\n            r.x = point->x + point->y;\n            r.y = point->x - point->y;\n            return r;\n        }\n    \"\"\")\n    p = ffi.new(\"struct foo_s *\")\n    p.point.x = 16\n    p.point.y = 9\n    py.test.raises(TypeError, lib.sum_coord, p.point)\n    res = lib.sum_coord(ffi.addressof(p.point))\n    assert res.x == 25\n    assert res.y == 7\n    res2 = lib.sum_coord(ffi.addressof(res))\n    assert res2.x == 32\n    assert res2.y == 18\n    py.test.raises(TypeError, lib.sum_coord, res2)\n\ndef test_callback_in_thread():\n    py.test.xfail(\"adapt or remove\")\n    if sys.platform == 'win32':\n        py.test.skip(\"pthread only\")\n    import os, subprocess, imp\n    arg = os.path.join(os.path.dirname(__file__), 'callback_in_thread.py')\n    g = subprocess.Popen([sys.executable, arg,\n                          os.path.dirname(imp.find_module('cffi')[1])])\n    result = g.wait()\n    assert result == 0\n\ndef test_keepalive_lib():\n    py.test.xfail(\"adapt or remove\")\n    ffi = FFI()\n    ffi.cdef(\"int foobar(void);\")\n    lib = ffi.verify(\"int foobar(void) { return 42; }\")\n    func = lib.foobar\n    ffi_r = weakref.ref(ffi)\n    lib_r = weakref.ref(lib)\n    del ffi\n    import gc; gc.collect()       # lib stays alive\n    assert lib_r() is not None\n    assert ffi_r() is not None\n    assert func() == 42\n\ndef test_keepalive_ffi():\n    py.test.xfail(\"adapt or remove\")\n    ffi = FFI()\n    ffi.cdef(\"int foobar(void);\")\n    lib = ffi.verify(\"int foobar(void) { return 42; }\")\n    func = lib.foobar\n    ffi_r = weakref.ref(ffi)\n    lib_r = weakref.ref(lib)\n    del lib\n    import gc; gc.collect()       # ffi stays alive\n    assert ffi_r() is not None\n    assert lib_r() is not None\n    assert func() == 42\n\ndef test_FILE_stored_in_stdout():\n    if not sys.platform.startswith('linux'):\n        py.test.skip(\"likely, we cannot assign to stdout\")\n    ffi = FFI()\n    ffi.cdef(\"int printf(const char *, ...); FILE *setstdout(FILE *);\")\n    lib = ffi.verify(\"\"\"\n        #include <stdio.h>\n        FILE *setstdout(FILE *f) {\n            FILE *result = stdout;\n            stdout = f;\n            return result;\n        }\n    \"\"\")\n    import os\n    fdr, fdw = os.pipe()\n    fw1 = os.fdopen(fdw, 'wb', 256)\n    old_stdout = lib.setstdout(fw1)\n    try:\n        #\n        fw1.write(b\"X\")\n        r = lib.printf(b\"hello, %d!\\n\", ffi.cast(\"int\", 42))\n        fw1.close()\n        assert r == len(\"hello, 42!\\n\")\n        #\n    finally:\n        lib.setstdout(old_stdout)\n    #\n    result = os.read(fdr, 256)\n    os.close(fdr)\n    # the 'X' might remain in the user-level buffer of 'fw1' and\n    # end up showing up after the 'hello, 42!\\n'\n    assert result == b\"Xhello, 42!\\n\" or result == b\"hello, 42!\\nX\"\n\ndef test_FILE_stored_explicitly():\n    ffi = FFI()\n    ffi.cdef(\"int myprintf(const char *, int); FILE *myfile;\")\n    lib = ffi.verify(\"\"\"\n        #include <stdio.h>\n        FILE *myfile;\n        int myprintf(const char *out, int value) {\n            return fprintf(myfile, out, value);\n        }\n    \"\"\")\n    import os\n    fdr, fdw = os.pipe()\n    fw1 = os.fdopen(fdw, 'wb', 256)\n    lib.myfile = ffi.cast(\"FILE *\", fw1)\n    #\n    fw1.write(b\"X\")\n    r = lib.myprintf(b\"hello, %d!\\n\", ffi.cast(\"int\", 42))\n    fw1.close()\n    assert r == len(\"hello, 42!\\n\")\n    #\n    result = os.read(fdr, 256)\n    os.close(fdr)\n    # the 'X' might remain in the user-level buffer of 'fw1' and\n    # end up showing up after the 'hello, 42!\\n'\n    assert result == b\"Xhello, 42!\\n\" or result == b\"hello, 42!\\nX\"\n\ndef test_global_array_with_missing_length():\n    ffi = FFI()\n    ffi.cdef(\"int fooarray[];\")\n    lib = ffi.verify(\"int fooarray[50];\")\n    assert repr(lib.fooarray).startswith(\"<cdata 'int *'\")\n\ndef test_global_array_with_dotdotdot_length():\n    ffi = FFI()\n    ffi.cdef(\"int fooarray[...];\")\n    lib = ffi.verify(\"int fooarray[50];\")\n    assert repr(lib.fooarray).startswith(\"<cdata 'int[50]'\")\n\ndef test_bad_global_array_with_dotdotdot_length():\n    py.test.xfail(\"was detected only because 23 bytes cannot be divided by 4; \"\n                  \"redo more generally\")\n    ffi = FFI()\n    ffi.cdef(\"int fooarray[...];\")\n    py.test.raises(VerificationError, ffi.verify, \"char fooarray[23];\")\n\ndef test_struct_containing_struct():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { ...; }; struct bar_s { struct foo_s f; ...; };\")\n    ffi.verify(\"struct foo_s { int x; }; struct bar_s { struct foo_s f; };\")\n    #\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { struct bar_s f; ...; }; struct bar_s { ...; };\")\n    ffi.verify(\"struct bar_s { int x; }; struct foo_s { struct bar_s f; };\")\n\ndef test_struct_returned_by_func():\n    ffi = FFI()\n    ffi.cdef(\"typedef ... foo_t; foo_t myfunc(void);\")\n    e = py.test.raises(TypeError, ffi.verify,\n                       \"typedef struct { int x; } foo_t; \"\n                       \"foo_t myfunc(void) { foo_t x = { 42 }; return x; }\")\n    assert str(e.value) == (\n        \"function myfunc: 'foo_t' is used as result type, but is opaque\")\n\ndef test_include():\n    ffi1 = FFI()\n    ffi1.cdef(\"typedef struct { int x; ...; } foo_t;\")\n    ffi1.verify(\"typedef struct { int y, x; } foo_t;\")\n    ffi2 = FFI()\n    ffi2.include(ffi1)\n    ffi2.cdef(\"int myfunc(foo_t *);\")\n    lib = ffi2.verify(\"typedef struct { int y, x; } foo_t;\"\n                      \"int myfunc(foo_t *p) { return 42 * p->x; }\")\n    res = lib.myfunc(ffi2.new(\"foo_t *\", {'x': 10}))\n    assert res == 420\n    res = lib.myfunc(ffi1.new(\"foo_t *\", {'x': -10}))\n    assert res == -420\n\ndef test_include_enum():\n    ffi1 = FFI()\n    ffi1.cdef(\"enum foo_e { AA, ... };\")\n    lib1 = ffi1.verify(\"enum foo_e { CC, BB, AA };\")\n    ffi2 = FFI()\n    ffi2.include(ffi1)\n    ffi2.cdef(\"int myfunc(enum foo_e);\")\n    lib2 = ffi2.verify(\"enum foo_e { CC, BB, AA };\"\n                       \"int myfunc(enum foo_e x) { return (int)x; }\")\n    res = lib2.myfunc(lib2.AA)\n    assert res == 2\n\ndef test_named_pointer_as_argument():\n    ffi = FFI()\n    ffi.cdef(\"typedef struct { int x; } *mystruct_p;\\n\"\n             \"mystruct_p ff5a(mystruct_p);\")\n    lib = ffi.verify(\"typedef struct { int x; } *mystruct_p;\\n\"\n                     \"mystruct_p ff5a(mystruct_p p) { p->x += 40; return p; }\")\n    p = ffi.new(\"mystruct_p\", [-2])\n    q = lib.ff5a(p)\n    assert q == p\n    assert p.x == 38\n\ndef test_enum_size():\n    cases = [('123',           4, 4294967295),\n             ('4294967295U',   4, 4294967295),\n             ('-123',          4, -1),\n             ('-2147483647-1', 4, -1),\n             ]\n    if FFI().sizeof(\"long\") == 8:\n        cases += [('4294967296L',        8, 2**64-1),\n                  ('%dUL' % (2**64-1),   8, 2**64-1),\n                  ('-2147483649L',       8, -1),\n                  ('%dL-1L' % (1-2**63), 8, -1)]\n    for hidden_value, expected_size, expected_minus1 in cases:\n        if sys.platform == 'win32' and 'U' in hidden_value:\n            continue   # skipped on Windows\n        ffi = FFI()\n        ffi.cdef(\"enum foo_e { AA, BB, ... };\")\n        lib = ffi.verify(\"enum foo_e { AA, BB=%s };\" % hidden_value)\n        assert lib.AA == 0\n        assert lib.BB == eval(hidden_value.replace('U', '').replace('L', ''))\n        assert ffi.sizeof(\"enum foo_e\") == expected_size\n        if sys.platform != 'win32':\n            assert int(ffi.cast(\"enum foo_e\", -1)) == expected_minus1\n    # test with the large value hidden:\n    # disabled so far, doesn't work\n##    for hidden_value, expected_size, expected_minus1 in cases:\n##        ffi = FFI()\n##        ffi.cdef(\"enum foo_e { AA, BB, ... };\")\n##        lib = ffi.verify(\"enum foo_e { AA, BB=%s };\" % hidden_value)\n##        assert lib.AA == 0\n##        assert ffi.sizeof(\"enum foo_e\") == expected_size\n##        assert int(ffi.cast(\"enum foo_e\", -1)) == expected_minus1\n\ndef test_enum_bug118():\n    maxulong = 256 ** FFI().sizeof(\"unsigned long\") - 1\n    for c2, c2c in [(-1, ''),\n                    (-1, ''),\n                    (0xffffffff, 'U'),\n                    (maxulong, 'UL'),\n                    (-int(maxulong / 3), 'L')]:\n        if c2c and sys.platform == 'win32':\n            continue     # enums may always be signed with MSVC\n        ffi = FFI()\n        ffi.cdef(\"enum foo_e { AA };\")\n        lib = ffi.verify(\"enum foo_e { AA=%s%s };\" % (c2, c2c))\n        assert lib.AA == c2\n\ndef test_string_to_voidp_arg():\n    ffi = FFI()\n    ffi.cdef(\"int myfunc(void *);\")\n    lib = ffi.verify(\"int myfunc(void *p) { return ((signed char *)p)[0]; }\")\n    res = lib.myfunc(b\"hi!\")\n    assert res == ord(b\"h\")\n    p = ffi.new(\"char[]\", b\"gah\")\n    res = lib.myfunc(p)\n    assert res == ord(b\"g\")\n    res = lib.myfunc(ffi.cast(\"void *\", p))\n    assert res == ord(b\"g\")\n    res = lib.myfunc(ffi.cast(\"int *\", p))\n    assert res == ord(b\"g\")\n\ndef test_callback_indirection():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        int (*python_callback)(int how_many, int *values);\n        int (*const c_callback)(int,...);   /* pass this ptr to C routines */\n        int some_c_function(int(*cb)(int,...));\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        #include <stdarg.h>\n        #ifdef _WIN32\n        #include <malloc.h>\n        #define alloca _alloca\n        #else\n        # ifdef __FreeBSD__\n        #  include <stdlib.h>\n        # else\n        #  include <alloca.h>\n        # endif\n        #endif\n        static int (*python_callback)(int how_many, int *values);\n        static int c_callback(int how_many, ...) {\n            va_list ap;\n            /* collect the \"...\" arguments into the values[] array */\n            int i, *values = alloca((size_t)how_many * sizeof(int));\n            va_start(ap, how_many);\n            for (i=0; i<how_many; i++)\n                values[i] = va_arg(ap, int);\n            va_end(ap);\n            return python_callback(how_many, values);\n        }\n        int some_c_function(int(*cb)(int,...)) {\n            int result = cb(2, 10, 20);\n            result += cb(3, 30, 40, 50);\n            return result;\n        }\n    \"\"\")\n    seen = []\n    @ffi.callback(\"int(int, int*)\")\n    def python_callback(how_many, values):\n        seen.append([values[i] for i in range(how_many)])\n        return 42\n    lib.python_callback = python_callback\n\n    res = lib.some_c_function(lib.c_callback)\n    assert res == 84\n    assert seen == [[10, 20], [30, 40, 50]]\n\ndef test_floatstar_argument():\n    ffi = FFI()\n    ffi.cdef(\"float sum3floats(float *);\")\n    lib = ffi.verify(\"\"\"\n        float sum3floats(float *f) {\n            return f[0] + f[1] + f[2];\n        }\n    \"\"\")\n    assert lib.sum3floats((1.5, 2.5, 3.5)) == 7.5\n    p = ffi.new(\"float[]\", (1.5, 2.5, 3.5))\n    assert lib.sum3floats(p) == 7.5\n\ndef test_charstar_argument():\n    ffi = FFI()\n    ffi.cdef(\"char sum3chars(char *);\")\n    lib = ffi.verify(\"\"\"\n        char sum3chars(char *f) {\n            return (char)(f[0] + f[1] + f[2]);\n        }\n    \"\"\")\n    assert lib.sum3chars((b'\\x10', b'\\x20', b'\\x30')) == b'\\x60'\n    p = ffi.new(\"char[]\", b'\\x10\\x20\\x30')\n    assert lib.sum3chars(p) == b'\\x60'\n\ndef test_passing_string_or_NULL():\n    ffi = FFI()\n    ffi.cdef(\"int seeme1(char *); int seeme2(int *);\")\n    lib = ffi.verify(\"\"\"\n        int seeme1(char *x) {\n            return (x == NULL);\n        }\n        int seeme2(int *x) {\n            return (x == NULL);\n        }\n    \"\"\")\n    assert lib.seeme1(b\"foo\") == 0\n    assert lib.seeme1(ffi.NULL) == 1\n    assert lib.seeme2([42, 43]) == 0\n    assert lib.seeme2(ffi.NULL) == 1\n    py.test.raises(TypeError, lib.seeme1, None)\n    py.test.raises(TypeError, lib.seeme2, None)\n    py.test.raises(TypeError, lib.seeme1, 0.0)\n    py.test.raises(TypeError, lib.seeme2, 0.0)\n    py.test.raises(TypeError, lib.seeme1, 0)\n    py.test.raises(TypeError, lib.seeme2, 0)\n    zeroL  = 99999999999999999999\n    zeroL -= 99999999999999999999\n    py.test.raises(TypeError, lib.seeme2, zeroL)\n\ndef test_typeof_function():\n    ffi = FFI()\n    ffi.cdef(\"int foo(int, char);\")\n    lib = ffi.verify(\"int foo(int x, char y) { (void)x; (void)y; return 42; }\")\n    ctype = ffi.typeof(lib.foo)\n    assert len(ctype.args) == 2\n    assert ctype.result == ffi.typeof(\"int\")\n\ndef test_call_with_voidstar_arg():\n    ffi = FFI()\n    ffi.cdef(\"int f(void *);\")\n    lib = ffi.verify(\"int f(void *x) { return ((char*)x)[0]; }\")\n    assert lib.f(b\"foobar\") == ord(b\"f\")\n\ndef test_dir():\n    ffi = FFI()\n    ffi.cdef(\"\"\"void somefunc(void);\n                extern int somevar, somearray[2];\n                static char *const sv2;\n                enum my_e { AA, BB, ... };\n                #define FOO ...\"\"\")\n    lib = ffi.verify(\"\"\"void somefunc(void) { }\n                        int somevar, somearray[2];\n                        #define sv2 \"text\"\n                        enum my_e { AA, BB };\n                        #define FOO 42\"\"\")\n    assert dir(lib) == ['AA', 'BB', 'FOO', 'somearray',\n                        'somefunc', 'somevar', 'sv2']\n\ndef test_typeof_func_with_struct_argument():\n    ffi = FFI()\n    ffi.cdef(\"\"\"struct s { int a; }; int foo(struct s);\"\"\")\n    lib = ffi.verify(\"\"\"struct s { int a; };\n                        int foo(struct s x) { return x.a; }\"\"\")\n    s = ffi.new(\"struct s *\", [-1234])\n    m = lib.foo(s[0])\n    assert m == -1234\n    assert repr(ffi.typeof(lib.foo)) == \"<ctype 'int(*)(struct s)'>\"\n\ndef test_bug_const_char_ptr_array_1():\n    ffi = FFI()\n    ffi.cdef(\"\"\"const char *a[...];\"\"\")\n    lib = ffi.verify(\"\"\"const char *a[5];\"\"\")\n    assert repr(ffi.typeof(lib.a)) == \"<ctype 'char *[5]'>\"\n\ndef test_bug_const_char_ptr_array_2():\n    ffi = FFI_warnings_not_error()    # ignore warnings\n    ffi.cdef(\"\"\"const int a[];\"\"\")\n    lib = ffi.verify(\"\"\"const int a[5];\"\"\")\n    assert repr(ffi.typeof(lib.a)) == \"<ctype 'int *'>\"\n\ndef _test_various_calls(force_libffi):\n    cdef_source = \"\"\"\n    int xvalue;\n    long long ivalue, rvalue;\n    float fvalue;\n    double dvalue;\n    long double Dvalue;\n    signed char tf_bb(signed char x, signed char c);\n    unsigned char tf_bB(signed char x, unsigned char c);\n    short tf_bh(signed char x, short c);\n    unsigned short tf_bH(signed char x, unsigned short c);\n    int tf_bi(signed char x, int c);\n    unsigned int tf_bI(signed char x, unsigned int c);\n    long tf_bl(signed char x, long c);\n    unsigned long tf_bL(signed char x, unsigned long c);\n    long long tf_bq(signed char x, long long c);\n    unsigned long long tf_bQ(signed char x, unsigned long long c);\n    float tf_bf(signed char x, float c);\n    double tf_bd(signed char x, double c);\n    long double tf_bD(signed char x, long double c);\n    \"\"\"\n    if force_libffi:\n        cdef_source = (cdef_source\n            .replace('tf_', '(*const tf_')\n            .replace('(signed char x', ')(signed char x'))\n    ffi = FFI()\n    ffi.cdef(cdef_source)\n    lib = ffi.verify(\"\"\"\n    int xvalue;\n    long long ivalue, rvalue;\n    float fvalue;\n    double dvalue;\n    long double Dvalue;\n\n    typedef signed char b_t;\n    typedef unsigned char B_t;\n    typedef short h_t;\n    typedef unsigned short H_t;\n    typedef int i_t;\n    typedef unsigned int I_t;\n    typedef long l_t;\n    typedef unsigned long L_t;\n    typedef long long q_t;\n    typedef unsigned long long Q_t;\n    typedef float f_t;\n    typedef double d_t;\n    typedef long double D_t;\n    #define S(letter)  xvalue = (int)x; letter##value = (letter##_t)c;\n    #define R(letter)  return (letter##_t)rvalue;\n\n    signed char tf_bb(signed char x, signed char c) { S(i) R(b) }\n    unsigned char tf_bB(signed char x, unsigned char c) { S(i) R(B) }\n    short tf_bh(signed char x, short c) { S(i) R(h) }\n    unsigned short tf_bH(signed char x, unsigned short c) { S(i) R(H) }\n    int tf_bi(signed char x, int c) { S(i) R(i) }\n    unsigned int tf_bI(signed char x, unsigned int c) { S(i) R(I) }\n    long tf_bl(signed char x, long c) { S(i) R(l) }\n    unsigned long tf_bL(signed char x, unsigned long c) { S(i) R(L) }\n    long long tf_bq(signed char x, long long c) { S(i) R(q) }\n    unsigned long long tf_bQ(signed char x, unsigned long long c) { S(i) R(Q) }\n    float tf_bf(signed char x, float c) { S(f) R(f) }\n    double tf_bd(signed char x, double c) { S(d) R(d) }\n    long double tf_bD(signed char x, long double c) { S(D) R(D) }\n    \"\"\")\n    lib.rvalue = 0x7182838485868788\n    for kind, cname in [('b', 'signed char'),\n                        ('B', 'unsigned char'),\n                        ('h', 'short'),\n                        ('H', 'unsigned short'),\n                        ('i', 'int'),\n                        ('I', 'unsigned int'),\n                        ('l', 'long'),\n                        ('L', 'unsigned long'),\n                        ('q', 'long long'),\n                        ('Q', 'unsigned long long'),\n                        ('f', 'float'),\n                        ('d', 'double'),\n                        ('D', 'long double')]:\n        sign = +1 if 'unsigned' in cname else -1\n        lib.xvalue = 0\n        lib.ivalue = 0\n        lib.fvalue = 0\n        lib.dvalue = 0\n        lib.Dvalue = 0\n        fun = getattr(lib, 'tf_b' + kind)\n        res = fun(-42, sign * 99)\n        if kind == 'D':\n            res = float(res)\n        assert res == int(ffi.cast(cname, 0x7182838485868788))\n        assert lib.xvalue == -42\n        if kind in 'fdD':\n            assert float(getattr(lib, kind + 'value')) == -99.0\n        else:\n            assert lib.ivalue == sign * 99\n\ndef test_various_calls_direct():\n    _test_various_calls(force_libffi=False)\n\ndef test_various_calls_libffi():\n    _test_various_calls(force_libffi=True)\n\ndef test_ptr_to_opaque():\n    ffi = FFI()\n    ffi.cdef(\"typedef ... foo_t; int f1(foo_t*); foo_t *f2(int);\")\n    lib = ffi.verify(\"\"\"\n        #include <stdlib.h>\n        typedef struct { int x; } foo_t;\n        int f1(foo_t* p) {\n            int x = p->x;\n            free(p);\n            return x;\n        }\n        foo_t *f2(int x) {\n            foo_t *p = malloc(sizeof(foo_t));\n            p->x = x;\n            return p;\n        }\n    \"\"\")\n    p = lib.f2(42)\n    x = lib.f1(p)\n    assert x == 42\n\ndef _run_in_multiple_threads(test1):\n    test1()\n    import sys\n    try:\n        import thread\n    except ImportError:\n        import _thread as thread\n    errors = []\n    def wrapper(lock):\n        try:\n            test1()\n        except:\n            errors.append(sys.exc_info())\n        lock.release()\n    locks = []\n    for i in range(10):\n        _lock = thread.allocate_lock()\n        _lock.acquire()\n        thread.start_new_thread(wrapper, (_lock,))\n        locks.append(_lock)\n    for _lock in locks:\n        _lock.acquire()\n        if errors:\n            raise errors[0][1]\n\ndef test_errno_working_even_with_pypys_jit():\n    ffi = FFI()\n    ffi.cdef(\"int f(int);\")\n    lib = ffi.verify(\"\"\"\n        #include <errno.h>\n        int f(int x) { return (errno = errno + x); }\n    \"\"\")\n    @_run_in_multiple_threads\n    def test1():\n        ffi.errno = 0\n        for i in range(10000):\n            e = lib.f(1)\n            assert e == i + 1\n            assert ffi.errno == e\n        for i in range(10000):\n            ffi.errno = i\n            e = lib.f(42)\n            assert e == i + 42\n\ndef test_getlasterror_working_even_with_pypys_jit():\n    if sys.platform != 'win32':\n        py.test.skip(\"win32-only test\")\n    ffi = FFI()\n    ffi.cdef(\"void SetLastError(DWORD);\")\n    lib = ffi.dlopen(\"Kernel32.dll\")\n    @_run_in_multiple_threads\n    def test1():\n        for i in range(10000):\n            n = (1 << 29) + i\n            lib.SetLastError(n)\n            assert ffi.getwinerror()[0] == n\n\ndef test_verify_dlopen_flags():\n    if not hasattr(sys, 'setdlopenflags'):\n        py.test.skip(\"requires sys.setdlopenflags()\")\n    # Careful with RTLD_GLOBAL.  If by chance the FFI is not deleted\n    # promptly, like on PyPy, then other tests may see the same\n    # exported symbols as well.  So we must not export a simple name\n    # like 'foo'!\n    old = sys.getdlopenflags()\n    try:\n        ffi1 = FFI()\n        ffi1.cdef(\"int foo_verify_dlopen_flags;\")\n        sys.setdlopenflags(ffi1.RTLD_GLOBAL | ffi1.RTLD_NOW)\n        lib1 = ffi1.verify(\"int foo_verify_dlopen_flags;\")\n    finally:\n        sys.setdlopenflags(old)\n\n    ffi2 = FFI()\n    ffi2.cdef(\"int *getptr(void);\")\n    lib2 = ffi2.verify(\"\"\"\n        extern int foo_verify_dlopen_flags;\n        static int *getptr(void) { return &foo_verify_dlopen_flags; }\n    \"\"\")\n    p = lib2.getptr()\n    assert ffi1.addressof(lib1, 'foo_verify_dlopen_flags') == p\n\ndef test_consider_not_implemented_function_type():\n    ffi = FFI()\n    ffi.cdef(\"typedef union { int a; float b; } Data;\"\n             \"typedef struct { int a:2; } MyStr;\"\n             \"typedef void (*foofunc_t)(Data);\"\n             \"typedef Data (*bazfunc_t)(void);\"\n             \"typedef MyStr (*barfunc_t)(void);\")\n    fooptr = ffi.cast(\"foofunc_t\", 123)\n    bazptr = ffi.cast(\"bazfunc_t\", 123)\n    barptr = ffi.cast(\"barfunc_t\", 123)\n    # assert did not crash so far\n    e = py.test.raises(NotImplementedError, fooptr, ffi.new(\"Data *\"))\n    assert str(e.value) == (\n        \"ctype 'Data' (size 4) not supported as argument\")\n    e = py.test.raises(NotImplementedError, bazptr)\n    assert str(e.value) == (\n        \"ctype 'Data' (size 4) not supported as return value\")\n    e = py.test.raises(NotImplementedError, barptr)\n    assert str(e.value) == (\n        \"ctype 'MyStr' not supported as return value \"\n        \"(it is a struct with bit fields)\")\n\ndef test_verify_extra_arguments():\n    ffi = FFI()\n    ffi.cdef(\"#define ABA ...\")\n    lib = ffi.verify(\"\", define_macros=[('ABA', '42')])\n    assert lib.ABA == 42\n\ndef test_implicit_unicode_on_windows():\n    from cffi import FFIError\n    if sys.platform != 'win32':\n        py.test.skip(\"win32-only test\")\n    ffi = FFI()\n    e = py.test.raises(FFIError, ffi.cdef, \"int foo(LPTSTR);\")\n    assert str(e.value) == (\"The Windows type 'LPTSTR' is only available after\"\n                            \" you call ffi.set_unicode()\")\n    for with_unicode in [True, False]:\n        ffi = FFI()\n        ffi.set_unicode(with_unicode)\n        ffi.cdef(\"\"\"\n            DWORD GetModuleFileName(HMODULE hModule, LPTSTR lpFilename,\n                                    DWORD nSize);\n        \"\"\")\n        lib = ffi.verify(\"\"\"\n            #include <windows.h>\n        \"\"\", libraries=['Kernel32'])\n        outbuf = ffi.new(\"TCHAR[]\", 200)\n        n = lib.GetModuleFileName(ffi.NULL, outbuf, 500)\n        assert 0 < n < 500\n        for i in range(n):\n            #print repr(outbuf[i])\n            assert ord(outbuf[i]) != 0\n        assert ord(outbuf[n]) == 0\n        assert ord(outbuf[0]) < 128     # should be a letter, or '\\'\n\ndef test_define_known_value():\n    ffi = FFI()\n    ffi.cdef(\"#define FOO 0x123\")\n    lib = ffi.verify(\"#define FOO 0x123\")\n    assert lib.FOO == 0x123\n\ndef test_define_wrong_value():\n    ffi = FFI()\n    ffi.cdef(\"#define FOO 123\")\n    lib = ffi.verify(\"#define FOO 124\")     # used to complain\n    e = py.test.raises(ffi.error, \"lib.FOO\")\n    assert str(e.value) == (\"the C compiler says 'FOO' is equal to 124 (0x7c),\"\n                            \" but the cdef disagrees\")\n\ndef test_some_integer_type_for_issue73():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef int... AnIntegerWith32Bits;\n        typedef AnIntegerWith32Bits (*AFunctionReturningInteger) (void);\n        AnIntegerWith32Bits InvokeFunction(AFunctionReturningInteger);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        #ifdef __LP64__\n        typedef int AnIntegerWith32Bits;\n        #else\n        typedef long AnIntegerWith32Bits;\n        #endif\n        typedef AnIntegerWith32Bits (*AFunctionReturningInteger) (void);\n        AnIntegerWith32Bits InvokeFunction(AFunctionReturningInteger f) {\n            return f();\n        }\n    \"\"\")\n    @ffi.callback(\"AFunctionReturningInteger\")\n    def add():\n        return 3 + 4\n    x = lib.InvokeFunction(add)\n    assert x == 7\n\ndef test_unsupported_some_primitive_types():\n    ffi = FFI()\n    py.test.raises(FFIError, ffi.cdef, \"\"\"typedef void... foo_t;\"\"\")\n    #\n    ffi.cdef(\"typedef int... foo_t;\")\n    py.test.raises(VerificationError, ffi.verify, \"typedef float foo_t;\")\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.1.2-nak3eqkxfunb4z5owzsqogchnaejp7o4/spack-src/testing/cffi1/test_dlopen_unicode_literals.py": "import py, os\n\ns = \"\"\"from __future__ import unicode_literals\n\"\"\"\n\nwith open(os.path.join(os.path.dirname(__file__), 'test_dlopen.py')) as f:\n    s += f.read()\n\nexec(py.code.compile(s))\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.1.2-nak3eqkxfunb4z5owzsqogchnaejp7o4/spack-src/testing/cffi1/test_re_python.py": "import sys\nimport py\nfrom cffi import FFI\nfrom cffi import recompiler, ffiplatform\nfrom testing.udir import udir\n\n\ndef setup_module(mod):\n    SRC = \"\"\"\n    #include <string.h>\n    #define FOOBAR (-42)\n    static const int FOOBAZ = -43;\n    #define BIGPOS 420000000000L\n    #define BIGNEG -420000000000L\n    int add42(int x) { return x + 42; }\n    int add43(int x, ...) { return x; }\n    int globalvar42 = 1234;\n    const int globalconst42 = 4321;\n    const char *const globalconsthello = \"hello\";\n    struct foo_s;\n    typedef struct bar_s { int x; signed char a[]; } bar_t;\n    enum foo_e { AA, BB, CC };\n\n    void init_test_re_python(void) { }      /* windows hack */\n    void PyInit__test_re_python(void) { }   /* windows hack */\n    \"\"\"\n    tmpdir = udir.join('test_re_python')\n    tmpdir.ensure(dir=1)\n    c_file = tmpdir.join('_test_re_python.c')\n    c_file.write(SRC)\n    ext = ffiplatform.get_extension(\n        str(c_file),\n        '_test_re_python',\n        export_symbols=['add42', 'add43', 'globalvar42',\n                        'globalconst42', 'globalconsthello']\n    )\n    outputfilename = ffiplatform.compile(str(tmpdir), ext)\n    mod.extmod = outputfilename\n    mod.tmpdir = tmpdir\n    #\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n    #define FOOBAR -42\n    static const int FOOBAZ = -43;\n    #define BIGPOS 420000000000L\n    #define BIGNEG -420000000000L\n    int add42(int);\n    int add43(int, ...);\n    int globalvar42;\n    const int globalconst42;\n    const char *const globalconsthello = \"hello\";\n    int no_such_function(int);\n    int no_such_globalvar;\n    struct foo_s;\n    typedef struct bar_s { int x; signed char a[]; } bar_t;\n    enum foo_e { AA, BB, CC };\n    int strlen(const char *);\n    \"\"\")\n    ffi.set_source('re_python_pysrc', None)\n    ffi.emit_python_code(str(tmpdir.join('re_python_pysrc.py')))\n    mod.original_ffi = ffi\n    #\n    sys.path.insert(0, str(tmpdir))\n\n\ndef test_constant():\n    from re_python_pysrc import ffi\n    assert ffi.integer_const('FOOBAR') == -42\n    assert ffi.integer_const('FOOBAZ') == -43\n\ndef test_large_constant():\n    from re_python_pysrc import ffi\n    assert ffi.integer_const('BIGPOS') == 420000000000\n    assert ffi.integer_const('BIGNEG') == -420000000000\n\ndef test_function():\n    import _cffi_backend\n    from re_python_pysrc import ffi\n    lib = ffi.dlopen(extmod)\n    assert lib.add42(-10) == 32\n    assert type(lib.add42) is _cffi_backend.FFI.CData\n\ndef test_function_with_varargs():\n    import _cffi_backend\n    from re_python_pysrc import ffi\n    lib = ffi.dlopen(extmod, 0)\n    assert lib.add43(45, ffi.cast(\"int\", -5)) == 45\n    assert type(lib.add43) is _cffi_backend.FFI.CData\n\ndef test_dlopen_none():\n    import _cffi_backend\n    from re_python_pysrc import ffi\n    name = None\n    if sys.platform == 'win32':\n        import ctypes.util\n        name = ctypes.util.find_msvcrt()\n    lib = ffi.dlopen(name)\n    assert lib.strlen(b\"hello\") == 5\n\ndef test_dlclose():\n    import _cffi_backend\n    from re_python_pysrc import ffi\n    lib = ffi.dlopen(extmod)\n    ffi.dlclose(lib)\n    e = py.test.raises(ffi.error, ffi.dlclose, lib)\n    assert str(e.value).startswith(\n        \"library '%s' is already closed\" % (extmod,))\n    e = py.test.raises(ffi.error, getattr, lib, 'add42')\n    assert str(e.value) == (\n        \"library '%s' has been closed\" % (extmod,))\n\ndef test_constant_via_lib():\n    from re_python_pysrc import ffi\n    lib = ffi.dlopen(extmod)\n    assert lib.FOOBAR == -42\n    assert lib.FOOBAZ == -43\n\ndef test_opaque_struct():\n    from re_python_pysrc import ffi\n    ffi.cast(\"struct foo_s *\", 0)\n    py.test.raises(TypeError, ffi.new, \"struct foo_s *\")\n\ndef test_nonopaque_struct():\n    from re_python_pysrc import ffi\n    for p in [ffi.new(\"struct bar_s *\", [5, b\"foobar\"]),\n              ffi.new(\"bar_t *\", [5, b\"foobar\"])]:\n        assert p.x == 5\n        assert p.a[0] == ord('f')\n        assert p.a[5] == ord('r')\n\ndef test_enum():\n    from re_python_pysrc import ffi\n    assert ffi.integer_const(\"BB\") == 1\n    e = ffi.cast(\"enum foo_e\", 2)\n    assert ffi.string(e) == \"CC\"\n\ndef test_include_1():\n    sub_ffi = FFI()\n    sub_ffi.cdef(\"static const int k2 = 121212;\")\n    sub_ffi.include(original_ffi)\n    assert 'macro FOOBAR' in original_ffi._parser._declarations\n    assert 'macro FOOBAZ' in original_ffi._parser._declarations\n    sub_ffi.set_source('re_python_pysrc', None)\n    sub_ffi.emit_python_code(str(tmpdir.join('_re_include_1.py')))\n    #\n    if sys.version_info[:2] >= (3, 3):\n        import importlib\n        importlib.invalidate_caches()  # issue 197 (but can't reproduce myself)\n    #\n    from _re_include_1 import ffi\n    assert ffi.integer_const('FOOBAR') == -42\n    assert ffi.integer_const('FOOBAZ') == -43\n    assert ffi.integer_const('k2') == 121212\n    lib = ffi.dlopen(extmod)     # <- a random unrelated library would be fine\n    assert lib.FOOBAR == -42\n    assert lib.FOOBAZ == -43\n    assert lib.k2 == 121212\n    #\n    p = ffi.new(\"bar_t *\", [5, b\"foobar\"])\n    assert p.a[4] == ord('a')\n\ndef test_global_var():\n    from re_python_pysrc import ffi\n    lib = ffi.dlopen(extmod)\n    assert lib.globalvar42 == 1234\n    p = ffi.addressof(lib, 'globalvar42')\n    lib.globalvar42 += 5\n    assert p[0] == 1239\n    p[0] -= 1\n    assert lib.globalvar42 == 1238\n\ndef test_global_const_int():\n    from re_python_pysrc import ffi\n    lib = ffi.dlopen(extmod)\n    assert lib.globalconst42 == 4321\n    py.test.raises(AttributeError, ffi.addressof, lib, 'globalconst42')\n\ndef test_global_const_nonint():\n    from re_python_pysrc import ffi\n    lib = ffi.dlopen(extmod)\n    assert ffi.string(lib.globalconsthello, 8) == b\"hello\"\n    py.test.raises(AttributeError, ffi.addressof, lib, 'globalconsthello')\n\ndef test_rtld_constants():\n    from re_python_pysrc import ffi\n    ffi.RTLD_NOW    # check that we have the attributes\n    ffi.RTLD_LAZY\n    ffi.RTLD_GLOBAL\n\ndef test_no_such_function_or_global_var():\n    from re_python_pysrc import ffi\n    lib = ffi.dlopen(extmod)\n    e = py.test.raises(ffi.error, getattr, lib, 'no_such_function')\n    assert str(e.value).startswith(\n        \"symbol 'no_such_function' not found in library '\")\n    e = py.test.raises(ffi.error, getattr, lib, 'no_such_globalvar')\n    assert str(e.value).startswith(\n        \"symbol 'no_such_globalvar' not found in library '\")\n\ndef test_check_version():\n    import _cffi_backend\n    e = py.test.raises(ImportError, _cffi_backend.FFI,\n                       \"foobar\", _version=0x2594)\n    assert str(e.value).startswith(\n        \"cffi out-of-line Python module 'foobar' has unknown version\")\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.1.2-nak3eqkxfunb4z5owzsqogchnaejp7o4/spack-src/testing/cffi0/test_parsing.py": "import py, sys, re\nfrom cffi import FFI, FFIError, CDefError, VerificationError\n\nclass FakeBackend(object):\n\n    def nonstandard_integer_types(self):\n        return {}\n\n    def sizeof(self, name):\n        return 1\n\n    def load_library(self, name, flags):\n        if sys.platform == 'win32':\n            assert name is None or \"msvcr\" in name\n        else:\n            assert name is None or \"libc\" in name or \"libm\" in name\n        return FakeLibrary()\n\n    def new_function_type(self, args, result, has_varargs):\n        args = [arg.cdecl for arg in args]\n        result = result.cdecl\n        return FakeType(\n            '<func (%s), %s, %s>' % (', '.join(args), result, has_varargs))\n\n    def new_primitive_type(self, name):\n        assert name == name.lower()\n        return FakeType('<%s>' % name)\n\n    def new_pointer_type(self, itemtype):\n        return FakeType('<pointer to %s>' % (itemtype,))\n\n    def new_struct_type(self, name):\n        return FakeStruct(name)\n\n    def complete_struct_or_union(self, s, fields, tp=None,\n                                 totalsize=-1, totalalignment=-1, sflags=0):\n        assert isinstance(s, FakeStruct)\n        s.fields = fields\n\n    def new_array_type(self, ptrtype, length):\n        return FakeType('<array %s x %s>' % (ptrtype, length))\n\n    def new_void_type(self):\n        return FakeType(\"<void>\")\n    def cast(self, x, y):\n        return 'casted!'\n    def _get_types(self):\n        return \"CData\", \"CType\"\n\nclass FakeType(object):\n    def __init__(self, cdecl):\n        self.cdecl = cdecl\n    def __str__(self):\n        return self.cdecl\n\nclass FakeStruct(object):\n    def __init__(self, name):\n        self.name = name\n    def __str__(self):\n        return ', '.join([str(y) + str(x) for x, y, z in self.fields])\n\nclass FakeLibrary(object):\n\n    def load_function(self, BType, name):\n        return FakeFunction(BType, name)\n\nclass FakeFunction(object):\n\n    def __init__(self, BType, name):\n        self.BType = str(BType)\n        self.name = name\n\nlib_m = \"m\"\nif sys.platform == 'win32':\n    #there is a small chance this fails on Mingw via environ $CC\n    import distutils.ccompiler\n    if distutils.ccompiler.get_default_compiler() == 'msvc':\n        lib_m = 'msvcrt'\n\ndef test_simple():\n    ffi = FFI(backend=FakeBackend())\n    ffi.cdef(\"double sin(double x);\")\n    m = ffi.dlopen(lib_m)\n    func = m.sin    # should be a callable on real backends\n    assert func.name == 'sin'\n    assert func.BType == '<func (<double>), <double>, False>'\n\ndef test_pipe():\n    ffi = FFI(backend=FakeBackend())\n    ffi.cdef(\"int pipe(int pipefd[2]);\")\n    C = ffi.dlopen(None)\n    func = C.pipe\n    assert func.name == 'pipe'\n    assert func.BType == '<func (<pointer to <int>>), <int>, False>'\n\ndef test_vararg():\n    ffi = FFI(backend=FakeBackend())\n    ffi.cdef(\"short foo(int, ...);\")\n    C = ffi.dlopen(None)\n    func = C.foo\n    assert func.name == 'foo'\n    assert func.BType == '<func (<int>), <short>, True>'\n\ndef test_no_args():\n    ffi = FFI(backend=FakeBackend())\n    ffi.cdef(\"\"\"\n        int foo(void);\n        \"\"\")\n    C = ffi.dlopen(None)\n    assert C.foo.BType == '<func (), <int>, False>'\n\ndef test_typedef():\n    ffi = FFI(backend=FakeBackend())\n    ffi.cdef(\"\"\"\n        typedef unsigned int UInt;\n        typedef UInt UIntReally;\n        UInt foo(void);\n        \"\"\")\n    C = ffi.dlopen(None)\n    assert str(ffi.typeof(\"UIntReally\")) == '<unsigned int>'\n    assert C.foo.BType == '<func (), <unsigned int>, False>'\n\ndef test_typedef_more_complex():\n    ffi = FFI(backend=FakeBackend())\n    ffi.cdef(\"\"\"\n        typedef struct { int a, b; } foo_t, *foo_p;\n        int foo(foo_p[]);\n        \"\"\")\n    C = ffi.dlopen(None)\n    assert str(ffi.typeof(\"foo_t\")) == '<int>a, <int>b'\n    assert str(ffi.typeof(\"foo_p\")) == '<pointer to <int>a, <int>b>'\n    assert C.foo.BType == ('<func (<pointer to <pointer to '\n                           '<int>a, <int>b>>), <int>, False>')\n\ndef test_typedef_array_convert_array_to_pointer():\n    ffi = FFI(backend=FakeBackend())\n    ffi.cdef(\"\"\"\n        typedef int (*fn_t)(int[5]);\n        \"\"\")\n    with ffi._lock:\n        type = ffi._parser.parse_type(\"fn_t\")\n        BType = ffi._get_cached_btype(type)\n    assert str(BType) == '<func (<pointer to <int>>), <int>, False>'\n\ndef test_remove_comments():\n    ffi = FFI(backend=FakeBackend())\n    ffi.cdef(\"\"\"\n        double /*comment here*/ sin   // blah blah\n        /* multi-\n           line-\n           //comment */  (\n        // foo\n        double // bar      /* <- ignored, because it's in a comment itself\n        x, double/*several*//*comment*/y) /*on the same line*/\n        ;\n    \"\"\")\n    m = ffi.dlopen(lib_m)\n    func = m.sin\n    assert func.name == 'sin'\n    assert func.BType == '<func (<double>, <double>), <double>, False>'\n\ndef test_define_not_supported_for_now():\n    ffi = FFI(backend=FakeBackend())\n    e = py.test.raises(CDefError, ffi.cdef, '#define FOO \"blah\"')\n    assert str(e.value) == (\n        'only supports one of the following syntax:\\n'\n        '  #define FOO ...     (literally dot-dot-dot)\\n'\n        '  #define FOO NUMBER  (with NUMBER an integer'\n                                    ' constant, decimal/hex/octal)\\n'\n        'got:\\n'\n        '  #define FOO \"blah\"')\n\ndef test_unnamed_struct():\n    ffi = FFI(backend=FakeBackend())\n    ffi.cdef(\"typedef struct { int x; } foo_t;\\n\"\n             \"typedef struct { int y; } *bar_p;\\n\")\n    assert 'typedef foo_t' in ffi._parser._declarations\n    assert 'typedef bar_p' in ffi._parser._declarations\n    assert 'anonymous foo_t' in ffi._parser._declarations\n    type_foo = ffi._parser.parse_type(\"foo_t\")\n    type_bar = ffi._parser.parse_type(\"bar_p\").totype\n    assert repr(type_foo) == \"<foo_t>\"\n    assert repr(type_bar) == \"<struct $1>\"\n    py.test.raises(VerificationError, type_bar.get_c_name)\n    assert type_foo.get_c_name() == \"foo_t\"\n\ndef test_override():\n    ffi = FFI(backend=FakeBackend())\n    C = ffi.dlopen(None)\n    ffi.cdef(\"int foo(void);\")\n    py.test.raises(FFIError, ffi.cdef, \"long foo(void);\")\n    assert C.foo.BType == '<func (), <int>, False>'\n    ffi.cdef(\"long foo(void);\", override=True)\n    assert C.foo.BType == '<func (), <long>, False>'\n\ndef test_cannot_have_only_variadic_part():\n    # this checks that we get a sensible error if we try \"int foo(...);\"\n    ffi = FFI()\n    e = py.test.raises(CDefError, ffi.cdef, \"int foo(...);\")\n    assert str(e.value) == \\\n           \"foo: a function with only '(...)' as argument is not correct C\"\n\ndef test_parse_error():\n    ffi = FFI()\n    e = py.test.raises(CDefError, ffi.cdef, \" x y z \")\n    assert re.match(r'cannot parse \"x y z\"\\n:\\d+:', str(e.value))\n\ndef test_cannot_declare_enum_later():\n    ffi = FFI()\n    e = py.test.raises(NotImplementedError, ffi.cdef,\n                       \"typedef enum foo_e foo_t; enum foo_e { AA, BB };\")\n    assert str(e.value) == (\n           \"enum foo_e: the '{}' declaration should appear on the \"\n           \"first time the enum is mentioned, not later\")\n\ndef test_unknown_name():\n    ffi = FFI()\n    e = py.test.raises(CDefError, ffi.cast, \"foobarbazunknown\", 0)\n    assert str(e.value) == \"unknown identifier 'foobarbazunknown'\"\n    e = py.test.raises(CDefError, ffi.cast, \"foobarbazunknown*\", 0)\n    assert str(e.value).startswith('cannot parse \"foobarbazunknown*\"')\n    e = py.test.raises(CDefError, ffi.cast, \"int(*)(foobarbazunknown)\", 0)\n    assert str(e.value).startswith('cannot parse \"int(*)(foobarbazunknown)\"')\n\ndef test_redefine_common_type():\n    prefix = \"\" if sys.version_info < (3,) else \"b\"\n    ffi = FFI()\n    ffi.cdef(\"typedef char FILE;\")\n    assert repr(ffi.cast(\"FILE\", 123)) == \"<cdata 'char' %s'{'>\" % prefix\n    ffi.cdef(\"typedef char int32_t;\")\n    assert repr(ffi.cast(\"int32_t\", 123)) == \"<cdata 'char' %s'{'>\" % prefix\n\ndef test_bool():\n    ffi = FFI()\n    ffi.cdef(\"void f(bool);\")\n    #\n    ffi = FFI()\n    ffi.cdef(\"typedef _Bool bool; void f(bool);\")\n\ndef test_win_common_types():\n    from cffi.commontypes import COMMON_TYPES, _CACHE\n    from cffi.commontypes import win_common_types, resolve_common_type\n    #\n    def clear_all(extra={}, old_dict=COMMON_TYPES.copy()):\n        COMMON_TYPES.clear()\n        COMMON_TYPES.update(old_dict)\n        COMMON_TYPES.update(extra)\n        _CACHE.clear()\n    #\n    for maxsize in [2**32-1, 2**64-1]:\n        ct = win_common_types(maxsize)\n        clear_all(ct)\n        for key in sorted(ct):\n            if ct[key] != 'set-unicode-needed':\n                resolve_common_type(key)\n    # assert did not crash\n    # now try to use e.g. WPARAM (-> UINT_PTR -> unsigned 32/64-bit)\n    for maxsize in [2**32-1, 2**64-1]:\n        ct = win_common_types(maxsize)\n        clear_all(ct)\n        ffi = FFI()\n        value = int(ffi.cast(\"WPARAM\", -1))\n        assert value == maxsize\n    #\n    clear_all()\n\ndef test_WPARAM_on_windows():\n    if sys.platform != 'win32':\n        py.test.skip(\"Only for Windows\")\n    ffi = FFI()\n    ffi.cdef(\"void f(WPARAM);\")\n\ndef test__is_constant_globalvar():\n    from cffi.cparser import Parser, _get_parser\n    for input, expected_output in [\n        (\"int a;\",          False),\n        (\"const int a;\",    True),\n        (\"int *a;\",         False),\n        (\"const int *a;\",   False),\n        (\"int const *a;\",   False),\n        (\"int *const a;\",   True),\n        (\"int a[5];\",       False),\n        (\"const int a[5];\", False),\n        (\"int *a[5];\",      False),\n        (\"const int *a[5];\", False),\n        (\"int const *a[5];\", False),\n        (\"int *const a[5];\", False),\n        (\"int a[5][6];\",       False),\n        (\"const int a[5][6];\", False),\n        ]:\n        p = Parser()\n        ast = _get_parser().parse(input)\n        decl = ast.children()[0][1]\n        node = decl.type\n        assert p._is_constant_globalvar(node) == expected_output\n\ndef test_enum():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        enum Enum { POS = +1, TWO = 2, NIL = 0, NEG = -1};\n        \"\"\")\n    C = ffi.dlopen(None)\n    assert C.POS == 1\n    assert C.TWO == 2\n    assert C.NIL == 0\n    assert C.NEG == -1\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.1.2-nak3eqkxfunb4z5owzsqogchnaejp7o4/spack-src/testing/cffi0/test_unicode_literals.py": "#\n# ----------------------------------------------\n# WARNING, ALL LITERALS IN THIS FILE ARE UNICODE\n# ----------------------------------------------\n#\nfrom __future__ import unicode_literals\n#\n#\n#\nimport sys, math\nfrom cffi import FFI\n\nlib_m = \"m\"\nif sys.platform == 'win32':\n    #there is a small chance this fails on Mingw via environ $CC\n    import distutils.ccompiler\n    if distutils.ccompiler.get_default_compiler() == 'msvc':\n        lib_m = 'msvcrt'\n\n\ndef test_cast():\n    ffi = FFI()\n    assert int(ffi.cast(\"int\", 3.14)) == 3        # unicode literal\n\ndef test_new():\n    ffi = FFI()\n    assert ffi.new(\"int[]\", [3, 4, 5])[2] == 5    # unicode literal\n\ndef test_typeof():\n    ffi = FFI()\n    tp = ffi.typeof(\"int[51]\")                    # unicode literal\n    assert tp.length == 51\n\ndef test_sizeof():\n    ffi = FFI()\n    assert ffi.sizeof(\"int[51]\") == 51 * 4        # unicode literal\n\ndef test_alignof():\n    ffi = FFI()\n    assert ffi.alignof(\"int[51]\") == 4            # unicode literal\n\ndef test_getctype():\n    ffi = FFI()\n    assert ffi.getctype(\"int**\") == \"int * *\"     # unicode literal\n    assert type(ffi.getctype(\"int**\")) is str\n\ndef test_cdef():\n    ffi = FFI()\n    ffi.cdef(\"typedef int foo_t[50];\")            # unicode literal\n\ndef test_offsetof():\n    ffi = FFI()\n    ffi.cdef(\"typedef struct { int x, y; } foo_t;\")\n    assert ffi.offsetof(\"foo_t\", \"y\") == 4        # unicode literal\n\ndef test_enum():\n    ffi = FFI()\n    ffi.cdef(\"enum foo_e { AA, BB, CC };\")        # unicode literal\n    x = ffi.cast(\"enum foo_e\", 1)\n    assert int(ffi.cast(\"int\", x)) == 1\n\ndef test_dlopen():\n    ffi = FFI()\n    ffi.cdef(\"double sin(double x);\")\n    m = ffi.dlopen(lib_m)                           # unicode literal\n    x = m.sin(1.23)\n    assert x == math.sin(1.23)\n\ndef test_verify():\n    ffi = FFI()\n    ffi.cdef(\"double test_verify_1(double x);\")   # unicode literal\n    lib = ffi.verify(\"double test_verify_1(double x) { return x * 42.0; }\")\n    assert lib.test_verify_1(-1.5) == -63.0\n\ndef test_callback():\n    ffi = FFI()\n    cb = ffi.callback(\"int(int)\",                 # unicode literal\n                      lambda x: x + 42)\n    assert cb(5) == 47\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.1.2-nak3eqkxfunb4z5owzsqogchnaejp7o4/spack-src/testing/cffi0/test_function.py": "import py\nfrom cffi import FFI\nimport math, os, sys\nimport ctypes.util\nfrom cffi.backend_ctypes import CTypesBackend\nfrom testing.udir import udir\n\ntry:\n    from StringIO import StringIO\nexcept ImportError:\n    from io import StringIO\n\n\nclass FdWriteCapture(object):\n    \"\"\"xxx limited to capture at most 512 bytes of output, according\n    to the Posix manual.\"\"\"\n\n    def __init__(self, capture_fd):\n        self.capture_fd = capture_fd\n\n    def __enter__(self):\n        self.read_fd, self.write_fd = os.pipe()\n        self.copy_fd = os.dup(self.capture_fd)\n        os.dup2(self.write_fd, self.capture_fd)\n        return self\n\n    def __exit__(self, *args):\n        os.dup2(self.copy_fd, self.capture_fd)\n        os.close(self.copy_fd)\n        os.close(self.write_fd)\n        self._value = os.read(self.read_fd, 512)\n        os.close(self.read_fd)\n\n    def getvalue(self):\n        return self._value\n\nlib_m = 'm'\nif sys.platform == 'win32':\n    #there is a small chance this fails on Mingw via environ $CC\n    import distutils.ccompiler\n    if distutils.ccompiler.get_default_compiler() == 'msvc':\n        lib_m = 'msvcrt'\n\nclass TestFunction(object):\n    Backend = CTypesBackend\n\n    def test_sin(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            double sin(double x);\n        \"\"\")\n        m = ffi.dlopen(lib_m)\n        x = m.sin(1.23)\n        assert x == math.sin(1.23)\n\n    def test_sinf(self):\n        if sys.platform == 'win32':\n            py.test.skip(\"no sinf found in the Windows stdlib\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            float sinf(float x);\n        \"\"\")\n        m = ffi.dlopen(lib_m)\n        x = m.sinf(1.23)\n        assert type(x) is float\n        assert x != math.sin(1.23)    # rounding effects\n        assert abs(x - math.sin(1.23)) < 1E-6\n\n    def test_sin_no_return_value(self):\n        # check that 'void'-returning functions work too\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            void sin(double x);\n        \"\"\")\n        m = ffi.dlopen(lib_m)\n        x = m.sin(1.23)\n        assert x is None\n\n    def test_dlopen_filename(self):\n        path = ctypes.util.find_library(lib_m)\n        if not path:\n            py.test.skip(\"%s not found\" % lib_m)\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            double cos(double x);\n        \"\"\")\n        m = ffi.dlopen(path)\n        x = m.cos(1.23)\n        assert x == math.cos(1.23)\n\n        m = ffi.dlopen(os.path.basename(path))\n        x = m.cos(1.23)\n        assert x == math.cos(1.23)\n\n    def test_dlopen_flags(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            double cos(double x);\n        \"\"\")\n        m = ffi.dlopen(lib_m, ffi.RTLD_LAZY | ffi.RTLD_LOCAL)\n        x = m.cos(1.23)\n        assert x == math.cos(1.23)\n\n    def test_dlopen_constant(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            #define FOOBAR 42\n            static const float baz = 42.5;   /* not visible */\n            double sin(double x);\n        \"\"\")\n        m = ffi.dlopen(lib_m)\n        assert m.FOOBAR == 42\n        py.test.raises(NotImplementedError, \"m.baz\")\n\n    def test_tlsalloc(self):\n        if sys.platform != 'win32':\n            py.test.skip(\"win32 only\")\n        if self.Backend is CTypesBackend:\n            py.test.skip(\"ctypes complains on wrong calling conv\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"long TlsAlloc(void); int TlsFree(long);\")\n        lib = ffi.dlopen('KERNEL32.DLL')\n        x = lib.TlsAlloc()\n        assert x != 0\n        y = lib.TlsFree(x)\n        assert y != 0\n\n    def test_fputs(self):\n        if not sys.platform.startswith('linux'):\n            py.test.skip(\"probably no symbol 'stderr' in the lib\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            int fputs(const char *, void *);\n            void *stderr;\n        \"\"\")\n        ffi.C = ffi.dlopen(None)\n        ffi.C.fputs   # fetch before capturing, for easier debugging\n        with FdWriteCapture(2) as fd:\n            ffi.C.fputs(b\"hello\\n\", ffi.C.stderr)\n            ffi.C.fputs(b\"  world\\n\", ffi.C.stderr)\n        res = fd.getvalue()\n        assert res == b'hello\\n  world\\n'\n\n    def test_fputs_without_const(self):\n        if not sys.platform.startswith('linux'):\n            py.test.skip(\"probably no symbol 'stderr' in the lib\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            int fputs(char *, void *);\n            void *stderr;\n        \"\"\")\n        ffi.C = ffi.dlopen(None)\n        ffi.C.fputs   # fetch before capturing, for easier debugging\n        with FdWriteCapture(2) as fd:\n            ffi.C.fputs(b\"hello\\n\", ffi.C.stderr)\n            ffi.C.fputs(b\"  world\\n\", ffi.C.stderr)\n        res = fd.getvalue()\n        assert res == b'hello\\n  world\\n'\n\n    def test_vararg(self):\n        if not sys.platform.startswith('linux'):\n            py.test.skip(\"probably no symbol 'stderr' in the lib\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n           int fprintf(void *, const char *format, ...);\n           void *stderr;\n        \"\"\")\n        ffi.C = ffi.dlopen(None)\n        with FdWriteCapture(2) as fd:\n            ffi.C.fprintf(ffi.C.stderr, b\"hello with no arguments\\n\")\n            ffi.C.fprintf(ffi.C.stderr,\n                          b\"hello, %s!\\n\", ffi.new(\"char[]\", b\"world\"))\n            ffi.C.fprintf(ffi.C.stderr,\n                          ffi.new(\"char[]\", b\"hello, %s!\\n\"),\n                          ffi.new(\"char[]\", b\"world2\"))\n            ffi.C.fprintf(ffi.C.stderr,\n                          b\"hello int %d long %ld long long %lld\\n\",\n                          ffi.cast(\"int\", 42),\n                          ffi.cast(\"long\", 84),\n                          ffi.cast(\"long long\", 168))\n            ffi.C.fprintf(ffi.C.stderr, b\"hello %p\\n\", ffi.NULL)\n        res = fd.getvalue()\n        assert res == (b\"hello with no arguments\\n\"\n                       b\"hello, world!\\n\"\n                       b\"hello, world2!\\n\"\n                       b\"hello int 42 long 84 long long 168\\n\"\n                       b\"hello (nil)\\n\")\n\n    def test_must_specify_type_of_vararg(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n           int printf(const char *format, ...);\n        \"\"\")\n        ffi.C = ffi.dlopen(None)\n        e = py.test.raises(TypeError, ffi.C.printf, b\"hello %d\\n\", 42)\n        assert str(e.value) == (\"argument 2 passed in the variadic part \"\n                                \"needs to be a cdata object (got int)\")\n\n    def test_function_has_a_c_type(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            int puts(const char *);\n        \"\"\")\n        ffi.C = ffi.dlopen(None)\n        fptr = ffi.C.puts\n        assert ffi.typeof(fptr) == ffi.typeof(\"int(*)(const char*)\")\n        if self.Backend is CTypesBackend:\n            assert repr(fptr).startswith(\"<cdata 'int puts(char *)' 0x\")\n\n    def test_function_pointer(self):\n        ffi = FFI(backend=self.Backend())\n        def cb(charp):\n            assert repr(charp).startswith(\"<cdata 'char *' 0x\")\n            return 42\n        fptr = ffi.callback(\"int(*)(const char *txt)\", cb)\n        assert fptr != ffi.callback(\"int(*)(const char *)\", cb)\n        assert repr(fptr) == \"<cdata 'int(*)(char *)' calling %r>\" % (cb,)\n        res = fptr(b\"Hello\")\n        assert res == 42\n        #\n        if not sys.platform.startswith('linux'):\n            py.test.skip(\"probably no symbol 'stderr' in the lib\")\n        ffi.cdef(\"\"\"\n            int fputs(const char *, void *);\n            void *stderr;\n        \"\"\")\n        ffi.C = ffi.dlopen(None)\n        fptr = ffi.cast(\"int(*)(const char *txt, void *)\", ffi.C.fputs)\n        assert fptr == ffi.C.fputs\n        assert repr(fptr).startswith(\"<cdata 'int(*)(char *, void *)' 0x\")\n        with FdWriteCapture(2) as fd:\n            fptr(b\"world\\n\", ffi.C.stderr)\n        res = fd.getvalue()\n        assert res == b'world\\n'\n\n    def test_callback_returning_void(self):\n        ffi = FFI(backend=self.Backend())\n        for returnvalue in [None, 42]:\n            def cb():\n                return returnvalue\n            fptr = ffi.callback(\"void(*)(void)\", cb)\n            old_stderr = sys.stderr\n            try:\n                sys.stderr = StringIO()\n                returned = fptr()\n                printed = sys.stderr.getvalue()\n            finally:\n                sys.stderr = old_stderr\n            assert returned is None\n            if returnvalue is None:\n                assert printed == ''\n            else:\n                assert \"None\" in printed\n\n    def test_passing_array(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            int strlen(char[]);\n        \"\"\")\n        ffi.C = ffi.dlopen(None)\n        p = ffi.new(\"char[]\", b\"hello\")\n        res = ffi.C.strlen(p)\n        assert res == 5\n\n    def test_write_variable(self):\n        if not sys.platform.startswith('linux'):\n            py.test.skip(\"probably no symbol 'stdout' in the lib\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            void *stdout;\n        \"\"\")\n        C = ffi.dlopen(None)\n        pout = C.stdout\n        C.stdout = ffi.NULL\n        assert C.stdout == ffi.NULL\n        C.stdout = pout\n        assert C.stdout == pout\n\n    def test_strchr(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            char *strchr(const char *s, int c);\n        \"\"\")\n        ffi.C = ffi.dlopen(None)\n        p = ffi.new(\"char[]\", b\"hello world!\")\n        q = ffi.C.strchr(p, ord('w'))\n        assert ffi.string(q) == b\"world!\"\n\n    def test_function_with_struct_argument(self):\n        if sys.platform == 'win32':\n            py.test.skip(\"no 'inet_ntoa'\")\n        if (self.Backend is CTypesBackend and\n            '__pypy__' in sys.builtin_module_names):\n            py.test.skip(\"ctypes limitation on pypy\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            struct in_addr { unsigned int s_addr; };\n            char *inet_ntoa(struct in_addr in);\n        \"\"\")\n        ffi.C = ffi.dlopen(None)\n        ina = ffi.new(\"struct in_addr *\", [0x04040404])\n        a = ffi.C.inet_ntoa(ina[0])\n        assert ffi.string(a) == b'4.4.4.4'\n\n    def test_function_typedef(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            typedef double func_t(double);\n            func_t sin;\n        \"\"\")\n        m = ffi.dlopen(lib_m)\n        x = m.sin(1.23)\n        assert x == math.sin(1.23)\n\n    def test_fputs_custom_FILE(self):\n        if self.Backend is CTypesBackend:\n            py.test.skip(\"FILE not supported with the ctypes backend\")\n        filename = str(udir.join('fputs_custom_FILE'))\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"int fputs(const char *, FILE *);\")\n        C = ffi.dlopen(None)\n        with open(filename, 'wb') as f:\n            f.write(b'[')\n            C.fputs(b\"hello from custom file\", f)\n            f.write(b'][')\n            C.fputs(b\"some more output\", f)\n            f.write(b']')\n        with open(filename, 'rb') as f:\n            res = f.read()\n        assert res == b'[hello from custom file][some more output]'\n\n    def test_constants_on_lib(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"enum foo_e { AA, BB, CC=5, DD };\n                    typedef enum { EE=-5, FF } some_enum_t;\"\"\")\n        lib = ffi.dlopen(None)\n        assert lib.AA == 0\n        assert lib.BB == 1\n        assert lib.CC == 5\n        assert lib.DD == 6\n        assert lib.EE == -5\n        assert lib.FF == -4\n\n    def test_void_star_accepts_string(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"int strlen(const void *);\"\"\")\n        lib = ffi.dlopen(None)\n        res = lib.strlen(b\"hello\")\n        assert res == 5\n\n    def test_signed_char_star_accepts_string(self):\n        if self.Backend is CTypesBackend:\n            py.test.skip(\"not supported by the ctypes backend\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"int strlen(signed char *);\"\"\")\n        lib = ffi.dlopen(None)\n        res = lib.strlen(b\"hello\")\n        assert res == 5\n\n    def test_unsigned_char_star_accepts_string(self):\n        if self.Backend is CTypesBackend:\n            py.test.skip(\"not supported by the ctypes backend\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"int strlen(unsigned char *);\"\"\")\n        lib = ffi.dlopen(None)\n        res = lib.strlen(b\"hello\")\n        assert res == 5\n\n    def test_missing_function(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            int nonexistent();\n        \"\"\")\n        m = ffi.dlopen(lib_m)\n        assert not hasattr(m, 'nonexistent')\n\n    def test_wraps_from_stdlib(self):\n        import functools\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            double sin(double x);\n        \"\"\")\n        def my_decorator(f):\n            @functools.wraps(f)\n            def wrapper(*args):\n                return f(*args) + 100\n            return wrapper\n        m = ffi.dlopen(lib_m)\n        sin100 = my_decorator(m.sin)\n        x = sin100(1.23)\n        assert x == math.sin(1.23) + 100\n\n    def test_free_callback_cycle(self):\n        if self.Backend is CTypesBackend:\n            py.test.skip(\"seems to fail with the ctypes backend on windows\")\n        import weakref\n        def make_callback(data):\n            container = [data]\n            callback = ffi.callback('int()', lambda: len(container))\n            container.append(callback)\n            # Ref cycle: callback -> lambda (closure) -> container -> callback\n            return callback\n\n        class Data(object):\n            pass\n        ffi = FFI(backend=self.Backend())\n        data = Data()\n        callback = make_callback(data)\n        wr = weakref.ref(data)\n        del callback, data\n        for i in range(3):\n            if wr() is not None:\n                import gc; gc.collect()\n        assert wr() is None    # 'data' does not leak\n\n    def test_windows_stdcall(self):\n        if sys.platform != 'win32':\n            py.test.skip(\"Windows-only test\")\n        if self.Backend is CTypesBackend:\n            py.test.skip(\"not with the ctypes backend\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            BOOL QueryPerformanceFrequency(LONGLONG *lpFrequency);\n        \"\"\")\n        m = ffi.dlopen(\"Kernel32.dll\")\n        p_freq = ffi.new(\"LONGLONG *\")\n        res = m.QueryPerformanceFrequency(p_freq)\n        assert res != 0\n        assert p_freq[0] != 0\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.1.2-nak3eqkxfunb4z5owzsqogchnaejp7o4/spack-src/testing/cffi0/backend_tests.py": "import py\nimport platform\nimport sys, ctypes\nfrom cffi import FFI, CDefError, FFIError\nfrom testing.support import *\n\nSIZE_OF_INT   = ctypes.sizeof(ctypes.c_int)\nSIZE_OF_LONG  = ctypes.sizeof(ctypes.c_long)\nSIZE_OF_SHORT = ctypes.sizeof(ctypes.c_short)\nSIZE_OF_PTR   = ctypes.sizeof(ctypes.c_void_p)\nSIZE_OF_WCHAR = ctypes.sizeof(ctypes.c_wchar)\n\n\nclass BackendTests:\n\n    def test_integer_ranges(self):\n        ffi = FFI(backend=self.Backend())\n        for (c_type, size) in [('char', 1),\n                               ('short', 2),\n                               ('short int', 2),\n                               ('', 4),\n                               ('int', 4),\n                               ('long', SIZE_OF_LONG),\n                               ('long int', SIZE_OF_LONG),\n                               ('long long', 8),\n                               ('long long int', 8),\n                               ]:\n            for unsigned in [None, False, True]:\n                c_decl = {None: '',\n                          False: 'signed ',\n                          True: 'unsigned '}[unsigned] + c_type\n                if c_decl == 'char' or c_decl == '':\n                    continue\n                self._test_int_type(ffi, c_decl, size, unsigned)\n\n    def test_fixedsize_int(self):\n        ffi = FFI(backend=self.Backend())\n        for size in [1, 2, 4, 8]:\n            self._test_int_type(ffi, 'int%d_t' % (8*size), size, False)\n            self._test_int_type(ffi, 'uint%d_t' % (8*size), size, True)\n        self._test_int_type(ffi, 'intptr_t', SIZE_OF_PTR, False)\n        self._test_int_type(ffi, 'uintptr_t', SIZE_OF_PTR, True)\n        self._test_int_type(ffi, 'ptrdiff_t', SIZE_OF_PTR, False)\n        self._test_int_type(ffi, 'size_t', SIZE_OF_PTR, True)\n        self._test_int_type(ffi, 'ssize_t', SIZE_OF_PTR, False)\n\n    def _test_int_type(self, ffi, c_decl, size, unsigned):\n        if unsigned:\n            min = 0\n            max = (1 << (8*size)) - 1\n        else:\n            min = -(1 << (8*size-1))\n            max = (1 << (8*size-1)) - 1\n        min = int(min)\n        max = int(max)\n        p = ffi.cast(c_decl, min)\n        assert p != min       # no __eq__(int)\n        assert bool(p) is True\n        assert int(p) == min\n        p = ffi.cast(c_decl, max)\n        assert int(p) == max\n        p = ffi.cast(c_decl, long(max))\n        assert int(p) == max\n        q = ffi.cast(c_decl, min - 1)\n        assert ffi.typeof(q) is ffi.typeof(p) and int(q) == max\n        q = ffi.cast(c_decl, long(min - 1))\n        assert ffi.typeof(q) is ffi.typeof(p) and int(q) == max\n        assert q != p\n        assert int(q) == int(p)\n        assert hash(q) != hash(p)   # unlikely\n        c_decl_ptr = '%s *' % c_decl\n        py.test.raises(OverflowError, ffi.new, c_decl_ptr, min - 1)\n        py.test.raises(OverflowError, ffi.new, c_decl_ptr, max + 1)\n        py.test.raises(OverflowError, ffi.new, c_decl_ptr, long(min - 1))\n        py.test.raises(OverflowError, ffi.new, c_decl_ptr, long(max + 1))\n        assert ffi.new(c_decl_ptr, min)[0] == min\n        assert ffi.new(c_decl_ptr, max)[0] == max\n        assert ffi.new(c_decl_ptr, long(min))[0] == min\n        assert ffi.new(c_decl_ptr, long(max))[0] == max\n\n    def test_new_unsupported_type(self):\n        ffi = FFI(backend=self.Backend())\n        e = py.test.raises(TypeError, ffi.new, \"int\")\n        assert str(e.value) == \"expected a pointer or array ctype, got 'int'\"\n\n    def test_new_single_integer(self):\n        ffi = FFI(backend=self.Backend())\n        p = ffi.new(\"int *\")     # similar to ffi.new(\"int[1]\")\n        assert p[0] == 0\n        p[0] = -123\n        assert p[0] == -123\n        p = ffi.new(\"int *\", -42)\n        assert p[0] == -42\n        assert repr(p) == \"<cdata 'int *' owning %d bytes>\" % SIZE_OF_INT\n\n    def test_new_array_no_arg(self):\n        ffi = FFI(backend=self.Backend())\n        p = ffi.new(\"int[10]\")\n        # the object was zero-initialized:\n        for i in range(10):\n            assert p[i] == 0\n\n    def test_array_indexing(self):\n        ffi = FFI(backend=self.Backend())\n        p = ffi.new(\"int[10]\")\n        p[0] = 42\n        p[9] = 43\n        assert p[0] == 42\n        assert p[9] == 43\n        py.test.raises(IndexError, \"p[10]\")\n        py.test.raises(IndexError, \"p[10] = 44\")\n        py.test.raises(IndexError, \"p[-1]\")\n        py.test.raises(IndexError, \"p[-1] = 44\")\n\n    def test_new_array_args(self):\n        ffi = FFI(backend=self.Backend())\n        # this tries to be closer to C: where we say \"int x[5] = {10, 20, ..}\"\n        # then here we must enclose the items in a list\n        p = ffi.new(\"int[5]\", [10, 20, 30, 40, 50])\n        assert p[0] == 10\n        assert p[1] == 20\n        assert p[2] == 30\n        assert p[3] == 40\n        assert p[4] == 50\n        p = ffi.new(\"int[4]\", [25])\n        assert p[0] == 25\n        assert p[1] == 0     # follow C convention rather than LuaJIT's\n        assert p[2] == 0\n        assert p[3] == 0\n        p = ffi.new(\"int[4]\", [ffi.cast(\"int\", -5)])\n        assert p[0] == -5\n        assert repr(p) == \"<cdata 'int[4]' owning %d bytes>\" % (4*SIZE_OF_INT)\n\n    def test_new_array_varsize(self):\n        ffi = FFI(backend=self.Backend())\n        p = ffi.new(\"int[]\", 10)     # a single integer is the length\n        assert p[9] == 0\n        py.test.raises(IndexError, \"p[10]\")\n        #\n        py.test.raises(TypeError, ffi.new, \"int[]\")\n        #\n        p = ffi.new(\"int[]\", [-6, -7])    # a list is all the items, like C\n        assert p[0] == -6\n        assert p[1] == -7\n        py.test.raises(IndexError, \"p[2]\")\n        assert repr(p) == \"<cdata 'int[]' owning %d bytes>\" % (2*SIZE_OF_INT)\n        #\n        p = ffi.new(\"int[]\", 0)\n        py.test.raises(IndexError, \"p[0]\")\n        py.test.raises(ValueError, ffi.new, \"int[]\", -1)\n        assert repr(p) == \"<cdata 'int[]' owning 0 bytes>\"\n\n    def test_pointer_init(self):\n        ffi = FFI(backend=self.Backend())\n        n = ffi.new(\"int *\", 24)\n        a = ffi.new(\"int *[10]\", [ffi.NULL, ffi.NULL, n, n, ffi.NULL])\n        for i in range(10):\n            if i not in (2, 3):\n                assert a[i] == ffi.NULL\n        assert a[2] == a[3] == n\n\n    def test_cannot_cast(self):\n        ffi = FFI(backend=self.Backend())\n        a = ffi.new(\"short int[10]\")\n        e = py.test.raises(TypeError, ffi.new, \"long int **\", a)\n        msg = str(e.value)\n        assert \"'short[10]'\" in msg and \"'long *'\" in msg\n\n    def test_new_pointer_to_array(self):\n        ffi = FFI(backend=self.Backend())\n        a = ffi.new(\"int[4]\", [100, 102, 104, 106])\n        p = ffi.new(\"int **\", a)\n        assert p[0] == ffi.cast(\"int *\", a)\n        assert p[0][2] == 104\n        p = ffi.cast(\"int *\", a)\n        assert p[0] == 100\n        assert p[1] == 102\n        assert p[2] == 104\n        assert p[3] == 106\n        # keepalive: a\n\n    def test_pointer_direct(self):\n        ffi = FFI(backend=self.Backend())\n        p = ffi.cast(\"int*\", 0)\n        assert p is not None\n        assert bool(p) is False\n        assert p == ffi.cast(\"int*\", 0)\n        assert p != None\n        assert repr(p) == \"<cdata 'int *' NULL>\"\n        a = ffi.new(\"int[]\", [123, 456])\n        p = ffi.cast(\"int*\", a)\n        assert bool(p) is True\n        assert p == ffi.cast(\"int*\", a)\n        assert p != ffi.cast(\"int*\", 0)\n        assert p[0] == 123\n        assert p[1] == 456\n\n    def test_repr(self):\n        typerepr = self.TypeRepr\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo { short a, b, c; };\")\n        p = ffi.cast(\"short unsigned int\", 0)\n        assert repr(p) == \"<cdata 'unsigned short' 0>\"\n        assert repr(ffi.typeof(p)) == typerepr % \"unsigned short\"\n        p = ffi.cast(\"unsigned short int\", 0)\n        assert repr(p) == \"<cdata 'unsigned short' 0>\"\n        assert repr(ffi.typeof(p)) == typerepr % \"unsigned short\"\n        p = ffi.cast(\"int*\", 0)\n        assert repr(p) == \"<cdata 'int *' NULL>\"\n        assert repr(ffi.typeof(p)) == typerepr % \"int *\"\n        #\n        p = ffi.new(\"int*\")\n        assert repr(p) == \"<cdata 'int *' owning %d bytes>\" % SIZE_OF_INT\n        assert repr(ffi.typeof(p)) == typerepr % \"int *\"\n        p = ffi.new(\"int**\")\n        assert repr(p) == \"<cdata 'int * *' owning %d bytes>\" % SIZE_OF_PTR\n        assert repr(ffi.typeof(p)) == typerepr % \"int * *\"\n        p = ffi.new(\"int [2]\")\n        assert repr(p) == \"<cdata 'int[2]' owning %d bytes>\" % (2*SIZE_OF_INT)\n        assert repr(ffi.typeof(p)) == typerepr % \"int[2]\"\n        p = ffi.new(\"int*[2][3]\")\n        assert repr(p) == \"<cdata 'int *[2][3]' owning %d bytes>\" % (\n            6*SIZE_OF_PTR)\n        assert repr(ffi.typeof(p)) == typerepr % \"int *[2][3]\"\n        p = ffi.new(\"struct foo *\")\n        assert repr(p) == \"<cdata 'struct foo *' owning %d bytes>\" % (\n            3*SIZE_OF_SHORT)\n        assert repr(ffi.typeof(p)) == typerepr % \"struct foo *\"\n        #\n        q = ffi.cast(\"short\", -123)\n        assert repr(q) == \"<cdata 'short' -123>\"\n        assert repr(ffi.typeof(q)) == typerepr % \"short\"\n        p = ffi.new(\"int*\")\n        q = ffi.cast(\"short*\", p)\n        assert repr(q).startswith(\"<cdata 'short *' 0x\")\n        assert repr(ffi.typeof(q)) == typerepr % \"short *\"\n        p = ffi.new(\"int [2]\")\n        q = ffi.cast(\"int*\", p)\n        assert repr(q).startswith(\"<cdata 'int *' 0x\")\n        assert repr(ffi.typeof(q)) == typerepr % \"int *\"\n        p = ffi.new(\"struct foo*\")\n        q = ffi.cast(\"struct foo *\", p)\n        assert repr(q).startswith(\"<cdata 'struct foo *' 0x\")\n        assert repr(ffi.typeof(q)) == typerepr % \"struct foo *\"\n        prevrepr = repr(q)\n        q = q[0]\n        assert repr(q) == prevrepr.replace(' *', ' &')\n        assert repr(ffi.typeof(q)) == typerepr % \"struct foo\"\n\n    def test_new_array_of_array(self):\n        ffi = FFI(backend=self.Backend())\n        p = ffi.new(\"int[3][4]\")\n        p[0][0] = 10\n        p[2][3] = 33\n        assert p[0][0] == 10\n        assert p[2][3] == 33\n        py.test.raises(IndexError, \"p[1][-1]\")\n\n    def test_constructor_array_of_array(self):\n        ffi = FFI(backend=self.Backend())\n        p = ffi.new(\"int[3][2]\", [[10, 11], [12, 13], [14, 15]])\n        assert p[2][1] == 15\n\n    def test_new_array_of_pointer_1(self):\n        ffi = FFI(backend=self.Backend())\n        n = ffi.new(\"int*\", 99)\n        p = ffi.new(\"int*[4]\")\n        p[3] = n\n        a = p[3]\n        assert repr(a).startswith(\"<cdata 'int *' 0x\")\n        assert a[0] == 99\n\n    def test_new_array_of_pointer_2(self):\n        ffi = FFI(backend=self.Backend())\n        n = ffi.new(\"int[1]\", [99])\n        p = ffi.new(\"int*[4]\")\n        p[3] = n\n        a = p[3]\n        assert repr(a).startswith(\"<cdata 'int *' 0x\")\n        assert a[0] == 99\n\n    def test_char(self):\n        ffi = FFI(backend=self.Backend())\n        assert ffi.new(\"char*\", b\"\\xff\")[0] == b'\\xff'\n        assert ffi.new(\"char*\")[0] == b'\\x00'\n        assert int(ffi.cast(\"char\", 300)) == 300 - 256\n        assert bool(ffi.cast(\"char\", 0))\n        py.test.raises(TypeError, ffi.new, \"char*\", 32)\n        py.test.raises(TypeError, ffi.new, \"char*\", u+\"x\")\n        py.test.raises(TypeError, ffi.new, \"char*\", b\"foo\")\n        #\n        p = ffi.new(\"char[]\", [b'a', b'b', b'\\x9c'])\n        assert len(p) == 3\n        assert p[0] == b'a'\n        assert p[1] == b'b'\n        assert p[2] == b'\\x9c'\n        p[0] = b'\\xff'\n        assert p[0] == b'\\xff'\n        p = ffi.new(\"char[]\", b\"abcd\")\n        assert len(p) == 5\n        assert p[4] == b'\\x00'    # like in C, with:  char[] p = \"abcd\";\n        #\n        p = ffi.new(\"char[4]\", b\"ab\")\n        assert len(p) == 4\n        assert [p[i] for i in range(4)] == [b'a', b'b', b'\\x00', b'\\x00']\n        p = ffi.new(\"char[2]\", b\"ab\")\n        assert len(p) == 2\n        assert [p[i] for i in range(2)] == [b'a', b'b']\n        py.test.raises(IndexError, ffi.new, \"char[2]\", b\"abc\")\n\n    def check_wchar_t(self, ffi):\n        try:\n            ffi.cast(\"wchar_t\", 0)\n        except NotImplementedError:\n            py.test.skip(\"NotImplementedError: wchar_t\")\n\n    def test_wchar_t(self):\n        ffi = FFI(backend=self.Backend())\n        self.check_wchar_t(ffi)\n        assert ffi.new(\"wchar_t*\", u+'x')[0] == u+'x'\n        assert ffi.new(\"wchar_t*\", u+'\\u1234')[0] == u+'\\u1234'\n        if SIZE_OF_WCHAR > 2:\n            assert ffi.new(\"wchar_t*\", u+'\\U00012345')[0] == u+'\\U00012345'\n        else:\n            py.test.raises(TypeError, ffi.new, \"wchar_t*\", u+'\\U00012345')\n        assert ffi.new(\"wchar_t*\")[0] == u+'\\x00'\n        assert int(ffi.cast(\"wchar_t\", 300)) == 300\n        assert bool(ffi.cast(\"wchar_t\", 0))\n        py.test.raises(TypeError, ffi.new, \"wchar_t*\", 32)\n        py.test.raises(TypeError, ffi.new, \"wchar_t*\", \"foo\")\n        #\n        p = ffi.new(\"wchar_t[]\", [u+'a', u+'b', u+'\\u1234'])\n        assert len(p) == 3\n        assert p[0] == u+'a'\n        assert p[1] == u+'b' and type(p[1]) is unicode\n        assert p[2] == u+'\\u1234'\n        p[0] = u+'x'\n        assert p[0] == u+'x' and type(p[0]) is unicode\n        p[1] = u+'\\u1357'\n        assert p[1] == u+'\\u1357'\n        p = ffi.new(\"wchar_t[]\", u+\"abcd\")\n        assert len(p) == 5\n        assert p[4] == u+'\\x00'\n        p = ffi.new(\"wchar_t[]\", u+\"a\\u1234b\")\n        assert len(p) == 4\n        assert p[1] == u+'\\u1234'\n        #\n        p = ffi.new(\"wchar_t[]\", u+'\\U00023456')\n        if SIZE_OF_WCHAR == 2:\n            assert sys.maxunicode == 0xffff\n            assert len(p) == 3\n            assert p[0] == u+'\\ud84d'\n            assert p[1] == u+'\\udc56'\n            assert p[2] == u+'\\x00'\n        else:\n            assert len(p) == 2\n            assert p[0] == u+'\\U00023456'\n            assert p[1] == u+'\\x00'\n        #\n        p = ffi.new(\"wchar_t[4]\", u+\"ab\")\n        assert len(p) == 4\n        assert [p[i] for i in range(4)] == [u+'a', u+'b', u+'\\x00', u+'\\x00']\n        p = ffi.new(\"wchar_t[2]\", u+\"ab\")\n        assert len(p) == 2\n        assert [p[i] for i in range(2)] == [u+'a', u+'b']\n        py.test.raises(IndexError, ffi.new, \"wchar_t[2]\", u+\"abc\")\n\n    def test_none_as_null_doesnt_work(self):\n        ffi = FFI(backend=self.Backend())\n        p = ffi.new(\"int*[1]\")\n        assert p[0] is not None\n        assert p[0] != None\n        assert p[0] == ffi.NULL\n        assert repr(p[0]) == \"<cdata 'int *' NULL>\"\n        #\n        n = ffi.new(\"int*\", 99)\n        p = ffi.new(\"int*[]\", [n])\n        assert p[0][0] == 99\n        py.test.raises(TypeError, \"p[0] = None\")\n        p[0] = ffi.NULL\n        assert p[0] == ffi.NULL\n\n    def test_float(self):\n        ffi = FFI(backend=self.Backend())\n        p = ffi.new(\"float[]\", [-2, -2.5])\n        assert p[0] == -2.0\n        assert p[1] == -2.5\n        p[1] += 17.75\n        assert p[1] == 15.25\n        #\n        p = ffi.new(\"float*\", 15.75)\n        assert p[0] == 15.75\n        py.test.raises(TypeError, int, p)\n        py.test.raises(TypeError, float, p)\n        p[0] = 0.0\n        assert bool(p) is True\n        #\n        p = ffi.new(\"float*\", 1.1)\n        f = p[0]\n        assert f != 1.1      # because of rounding effect\n        assert abs(f - 1.1) < 1E-7\n        #\n        INF = 1E200 * 1E200\n        assert 1E200 != INF\n        p[0] = 1E200\n        assert p[0] == INF     # infinite, not enough precision\n\n    def test_struct_simple(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo { int a; short b, c; };\")\n        s = ffi.new(\"struct foo*\")\n        assert s.a == s.b == s.c == 0\n        s.b = -23\n        assert s.b == -23\n        py.test.raises(OverflowError, \"s.b = 32768\")\n        #\n        s = ffi.new(\"struct foo*\", [-2, -3])\n        assert s.a == -2\n        assert s.b == -3\n        assert s.c == 0\n        py.test.raises((AttributeError, TypeError), \"del s.a\")\n        assert repr(s) == \"<cdata 'struct foo *' owning %d bytes>\" % (\n            SIZE_OF_INT + 2 * SIZE_OF_SHORT)\n        #\n        py.test.raises(ValueError, ffi.new, \"struct foo*\", [1, 2, 3, 4])\n\n    def test_constructor_struct_from_dict(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo { int a; short b, c; };\")\n        s = ffi.new(\"struct foo*\", {'b': 123, 'c': 456})\n        assert s.a == 0\n        assert s.b == 123\n        assert s.c == 456\n        py.test.raises(KeyError, ffi.new, \"struct foo*\", {'d': 456})\n\n    def test_struct_pointer(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo { int a; short b, c; };\")\n        s = ffi.new(\"struct foo*\")\n        assert s[0].a == s[0].b == s[0].c == 0\n        s[0].b = -23\n        assert s[0].b == s.b == -23\n        py.test.raises(OverflowError, \"s[0].b = -32769\")\n        py.test.raises(IndexError, \"s[1]\")\n\n    def test_struct_opaque(self):\n        ffi = FFI(backend=self.Backend())\n        py.test.raises(TypeError, ffi.new, \"struct baz*\")\n        p = ffi.new(\"struct baz **\")    # this works\n        assert p[0] == ffi.NULL\n\n    def test_pointer_to_struct(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo { int a; short b, c; };\")\n        s = ffi.new(\"struct foo *\")\n        s.a = -42\n        assert s[0].a == -42\n        p = ffi.new(\"struct foo **\", s)\n        assert p[0].a == -42\n        assert p[0][0].a == -42\n        p[0].a = -43\n        assert s.a == -43\n        assert s[0].a == -43\n        p[0][0].a = -44\n        assert s.a == -44\n        assert s[0].a == -44\n        s.a = -45\n        assert p[0].a == -45\n        assert p[0][0].a == -45\n        s[0].a = -46\n        assert p[0].a == -46\n        assert p[0][0].a == -46\n\n    def test_constructor_struct_of_array(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo { int a[2]; char b[3]; };\")\n        s = ffi.new(\"struct foo *\", [[10, 11], [b'a', b'b', b'c']])\n        assert s.a[1] == 11\n        assert s.b[2] == b'c'\n        s.b[1] = b'X'\n        assert s.b[0] == b'a'\n        assert s.b[1] == b'X'\n        assert s.b[2] == b'c'\n\n    def test_recursive_struct(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo { int value; struct foo *next; };\")\n        s = ffi.new(\"struct foo*\")\n        t = ffi.new(\"struct foo*\")\n        s.value = 123\n        s.next = t\n        t.value = 456\n        assert s.value == 123\n        assert s.next.value == 456\n\n    def test_union_simple(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"union foo { int a; short b, c; };\")\n        u = ffi.new(\"union foo*\")\n        assert u.a == u.b == u.c == 0\n        u.b = -23\n        assert u.b == -23\n        assert u.a != 0\n        py.test.raises(OverflowError, \"u.b = 32768\")\n        #\n        u = ffi.new(\"union foo*\", [-2])\n        assert u.a == -2\n        py.test.raises((AttributeError, TypeError), \"del u.a\")\n        assert repr(u) == \"<cdata 'union foo *' owning %d bytes>\" % SIZE_OF_INT\n\n    def test_union_opaque(self):\n        ffi = FFI(backend=self.Backend())\n        py.test.raises(TypeError, ffi.new, \"union baz *\")\n        u = ffi.new(\"union baz **\")   # this works\n        assert u[0] == ffi.NULL\n\n    def test_union_initializer(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"union foo { char a; int b; };\")\n        py.test.raises(TypeError, ffi.new, \"union foo*\", b'A')\n        py.test.raises(TypeError, ffi.new, \"union foo*\", 5)\n        py.test.raises(ValueError, ffi.new, \"union foo*\", [b'A', 5])\n        u = ffi.new(\"union foo*\", [b'A'])\n        assert u.a == b'A'\n        py.test.raises(TypeError, ffi.new, \"union foo*\", [1005])\n        u = ffi.new(\"union foo*\", {'b': 12345})\n        assert u.b == 12345\n        u = ffi.new(\"union foo*\", [])\n        assert u.a == b'\\x00'\n        assert u.b == 0\n\n    def test_sizeof_type(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            struct foo { int a; short b, c, d; };\n            union foo { int a; short b, c, d; };\n        \"\"\")\n        for c_type, expected_size in [\n            ('char', 1),\n            ('unsigned int', 4),\n            ('char *', SIZE_OF_PTR),\n            ('int[5]', 20),\n            ('struct foo', 12),\n            ('union foo', 4),\n            ]:\n            size = ffi.sizeof(c_type)\n            assert size == expected_size, (size, expected_size, ctype)\n\n    def test_sizeof_cdata(self):\n        ffi = FFI(backend=self.Backend())\n        assert ffi.sizeof(ffi.new(\"short*\")) == SIZE_OF_PTR\n        assert ffi.sizeof(ffi.cast(\"short\", 123)) == SIZE_OF_SHORT\n        #\n        a = ffi.new(\"int[]\", [10, 11, 12, 13, 14])\n        assert len(a) == 5\n        assert ffi.sizeof(a) == 5 * SIZE_OF_INT\n\n    def test_string_from_char_pointer(self):\n        ffi = FFI(backend=self.Backend())\n        x = ffi.new(\"char*\", b\"x\")\n        assert str(x) == repr(x)\n        assert ffi.string(x) == b\"x\"\n        assert ffi.string(ffi.new(\"char*\", b\"\\x00\")) == b\"\"\n        py.test.raises(TypeError, ffi.new, \"char*\", unicode(\"foo\"))\n\n    def test_unicode_from_wchar_pointer(self):\n        ffi = FFI(backend=self.Backend())\n        self.check_wchar_t(ffi)\n        x = ffi.new(\"wchar_t*\", u+\"x\")\n        assert unicode(x) == unicode(repr(x))\n        assert ffi.string(x) == u+\"x\"\n        assert ffi.string(ffi.new(\"wchar_t*\", u+\"\\x00\")) == u+\"\"\n\n    def test_string_from_char_array(self):\n        ffi = FFI(backend=self.Backend())\n        p = ffi.new(\"char[]\", b\"hello.\")\n        p[5] = b'!'\n        assert ffi.string(p) == b\"hello!\"\n        p[6] = b'?'\n        assert ffi.string(p) == b\"hello!?\"\n        p[3] = b'\\x00'\n        assert ffi.string(p) == b\"hel\"\n        assert ffi.string(p, 2) == b\"he\"\n        py.test.raises(IndexError, \"p[7] = b'X'\")\n        #\n        a = ffi.new(\"char[]\", b\"hello\\x00world\")\n        assert len(a) == 12\n        p = ffi.cast(\"char *\", a)\n        assert ffi.string(p) == b'hello'\n\n    def test_string_from_wchar_array(self):\n        ffi = FFI(backend=self.Backend())\n        self.check_wchar_t(ffi)\n        assert ffi.string(ffi.cast(\"wchar_t\", \"x\")) == u+\"x\"\n        assert ffi.string(ffi.cast(\"wchar_t\", u+\"x\")) == u+\"x\"\n        x = ffi.cast(\"wchar_t\", \"x\")\n        assert str(x) == repr(x)\n        assert ffi.string(x) == u+\"x\"\n        #\n        p = ffi.new(\"wchar_t[]\", u+\"hello.\")\n        p[5] = u+'!'\n        assert ffi.string(p) == u+\"hello!\"\n        p[6] = u+'\\u04d2'\n        assert ffi.string(p) == u+\"hello!\\u04d2\"\n        p[3] = u+'\\x00'\n        assert ffi.string(p) == u+\"hel\"\n        assert ffi.string(p, 123) == u+\"hel\"\n        py.test.raises(IndexError, \"p[7] = u+'X'\")\n        #\n        a = ffi.new(\"wchar_t[]\", u+\"hello\\x00world\")\n        assert len(a) == 12\n        p = ffi.cast(\"wchar_t *\", a)\n        assert ffi.string(p) == u+'hello'\n        assert ffi.string(p, 123) == u+'hello'\n        assert ffi.string(p, 5) == u+'hello'\n        assert ffi.string(p, 2) == u+'he'\n\n    def test_fetch_const_char_p_field(self):\n        # 'const' is ignored so far\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo { const char *name; };\")\n        t = ffi.new(\"const char[]\", b\"testing\")\n        s = ffi.new(\"struct foo*\", [t])\n        assert type(s.name) not in (bytes, str, unicode)\n        assert ffi.string(s.name) == b\"testing\"\n        py.test.raises(TypeError, \"s.name = None\")\n        s.name = ffi.NULL\n        assert s.name == ffi.NULL\n\n    def test_fetch_const_wchar_p_field(self):\n        # 'const' is ignored so far\n        ffi = FFI(backend=self.Backend())\n        self.check_wchar_t(ffi)\n        ffi.cdef(\"struct foo { const wchar_t *name; };\")\n        t = ffi.new(\"const wchar_t[]\", u+\"testing\")\n        s = ffi.new(\"struct foo*\", [t])\n        assert type(s.name) not in (bytes, str, unicode)\n        assert ffi.string(s.name) == u+\"testing\"\n        s.name = ffi.NULL\n        assert s.name == ffi.NULL\n\n    def test_voidp(self):\n        ffi = FFI(backend=self.Backend())\n        py.test.raises(TypeError, ffi.new, \"void*\")\n        p = ffi.new(\"void **\")\n        assert p[0] == ffi.NULL\n        a = ffi.new(\"int[]\", [10, 11, 12])\n        p = ffi.new(\"void **\", a)\n        vp = p[0]\n        py.test.raises(TypeError, \"vp[0]\")\n        py.test.raises(TypeError, ffi.new, \"short **\", a)\n        #\n        ffi.cdef(\"struct foo { void *p; int *q; short *r; };\")\n        s = ffi.new(\"struct foo *\")\n        s.p = a    # works\n        s.q = a    # works\n        py.test.raises(TypeError, \"s.r = a\")    # fails\n        b = ffi.cast(\"int *\", a)\n        s.p = b    # works\n        s.q = b    # works\n        py.test.raises(TypeError, \"s.r = b\")    # fails\n\n    def test_functionptr_simple(self):\n        ffi = FFI(backend=self.Backend())\n        py.test.raises(TypeError, ffi.callback, \"int(*)(int)\", 0)\n        def cb(n):\n            return n + 1\n        cb.__qualname__ = 'cb'\n        p = ffi.callback(\"int(*)(int)\", cb)\n        res = p(41)     # calling an 'int(*)(int)', i.e. a function pointer\n        assert res == 42 and type(res) is int\n        res = p(ffi.cast(\"int\", -41))\n        assert res == -40 and type(res) is int\n        assert repr(p).startswith(\n            \"<cdata 'int(*)(int)' calling <function cb at 0x\")\n        assert ffi.typeof(p) is ffi.typeof(\"int(*)(int)\")\n        q = ffi.new(\"int(**)(int)\", p)\n        assert repr(q) == \"<cdata 'int(* *)(int)' owning %d bytes>\" % (\n            SIZE_OF_PTR)\n        py.test.raises(TypeError, \"q(43)\")\n        res = q[0](43)\n        assert res == 44\n        q = ffi.cast(\"int(*)(int)\", p)\n        assert repr(q).startswith(\"<cdata 'int(*)(int)' 0x\")\n        res = q(45)\n        assert res == 46\n\n    def test_functionptr_advanced(self):\n        ffi = FFI(backend=self.Backend())\n        t = ffi.typeof(\"int(*(*)(int))(int)\")\n        assert repr(t) == self.TypeRepr % \"int(*(*)(int))(int)\"\n\n    def test_functionptr_voidptr_return(self):\n        ffi = FFI(backend=self.Backend())\n        def cb():\n            return ffi.NULL\n        p = ffi.callback(\"void*(*)()\", cb)\n        res = p()\n        assert res is not None\n        assert res == ffi.NULL\n        int_ptr = ffi.new('int*')\n        void_ptr = ffi.cast('void*', int_ptr)\n        def cb():\n            return void_ptr\n        p = ffi.callback(\"void*(*)()\", cb)\n        res = p()\n        assert res == void_ptr\n\n    def test_functionptr_intptr_return(self):\n        ffi = FFI(backend=self.Backend())\n        def cb():\n            return ffi.NULL\n        p = ffi.callback(\"int*(*)()\", cb)\n        res = p()\n        assert res == ffi.NULL\n        int_ptr = ffi.new('int*')\n        def cb():\n            return int_ptr\n        p = ffi.callback(\"int*(*)()\", cb)\n        res = p()\n        assert repr(res).startswith(\"<cdata 'int *' 0x\")\n        assert res == int_ptr\n        int_array_ptr = ffi.new('int[1]')\n        def cb():\n            return int_array_ptr\n        p = ffi.callback(\"int*(*)()\", cb)\n        res = p()\n        assert repr(res).startswith(\"<cdata 'int *' 0x\")\n        assert res == int_array_ptr\n\n    def test_functionptr_void_return(self):\n        ffi = FFI(backend=self.Backend())\n        def foo():\n            pass\n        foo_cb = ffi.callback(\"void foo()\", foo)\n        result = foo_cb()\n        assert result is None\n\n    def test_char_cast(self):\n        ffi = FFI(backend=self.Backend())\n        p = ffi.cast(\"int\", b'\\x01')\n        assert ffi.typeof(p) is ffi.typeof(\"int\")\n        assert int(p) == 1\n        p = ffi.cast(\"int\", ffi.cast(\"char\", b\"a\"))\n        assert int(p) == ord(\"a\")\n        p = ffi.cast(\"int\", ffi.cast(\"char\", b\"\\x80\"))\n        assert int(p) == 0x80     # \"char\" is considered unsigned in this case\n        p = ffi.cast(\"int\", b\"\\x81\")\n        assert int(p) == 0x81\n\n    def test_wchar_cast(self):\n        ffi = FFI(backend=self.Backend())\n        self.check_wchar_t(ffi)\n        p = ffi.cast(\"int\", ffi.cast(\"wchar_t\", u+'\\u1234'))\n        assert int(p) == 0x1234\n        p = ffi.cast(\"long long\", ffi.cast(\"wchar_t\", -1))\n        if SIZE_OF_WCHAR == 2:      # 2 bytes, unsigned\n            assert int(p) == 0xffff\n        elif platform.machine() == 'aarch64': # 4 bytes, unsigned\n            assert int(p) == 0xffffffff\n        else:                       # 4 bytes, signed\n            assert int(p) == -1\n        p = ffi.cast(\"int\", u+'\\u1234')\n        assert int(p) == 0x1234\n\n    def test_cast_array_to_charp(self):\n        ffi = FFI(backend=self.Backend())\n        a = ffi.new(\"short int[]\", [0x1234, 0x5678])\n        p = ffi.cast(\"char*\", a)\n        data = b''.join([p[i] for i in range(4)])\n        if sys.byteorder == 'little':\n            assert data == b'\\x34\\x12\\x78\\x56'\n        else:\n            assert data == b'\\x12\\x34\\x56\\x78'\n\n    def test_cast_between_pointers(self):\n        ffi = FFI(backend=self.Backend())\n        a = ffi.new(\"short int[]\", [0x1234, 0x5678])\n        p = ffi.cast(\"short*\", a)\n        p2 = ffi.cast(\"int*\", p)\n        q = ffi.cast(\"char*\", p2)\n        data = b''.join([q[i] for i in range(4)])\n        if sys.byteorder == 'little':\n            assert data == b'\\x34\\x12\\x78\\x56'\n        else:\n            assert data == b'\\x12\\x34\\x56\\x78'\n\n    def test_cast_pointer_and_int(self):\n        ffi = FFI(backend=self.Backend())\n        a = ffi.new(\"short int[]\", [0x1234, 0x5678])\n        l1 = ffi.cast(\"intptr_t\", a)\n        p = ffi.cast(\"short*\", a)\n        l2 = ffi.cast(\"intptr_t\", p)\n        assert int(l1) == int(l2) != 0\n        q = ffi.cast(\"short*\", l1)\n        assert q == ffi.cast(\"short*\", int(l1))\n        assert q[0] == 0x1234\n        assert int(ffi.cast(\"intptr_t\", ffi.NULL)) == 0\n\n    def test_cast_functionptr_and_int(self):\n        ffi = FFI(backend=self.Backend())\n        def cb(n):\n            return n + 1\n        a = ffi.callback(\"int(*)(int)\", cb)\n        p = ffi.cast(\"void *\", a)\n        assert p\n        b = ffi.cast(\"int(*)(int)\", p)\n        assert b(41) == 42\n        assert a == b\n        assert hash(a) == hash(b)\n\n    def test_callback_crash(self):\n        ffi = FFI(backend=self.Backend())\n        def cb(n):\n            raise Exception\n        a = ffi.callback(\"int(*)(int)\", cb, error=42)\n        res = a(1)    # and the error reported to stderr\n        assert res == 42\n\n    def test_structptr_argument(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo_s { int a, b; };\")\n        def cb(p):\n            return p[0].a * 1000 + p[0].b * 100 + p[1].a * 10 + p[1].b\n        a = ffi.callback(\"int(*)(struct foo_s[])\", cb)\n        res = a([[5, 6], {'a': 7, 'b': 8}])\n        assert res == 5678\n        res = a([[5], {'b': 8}])\n        assert res == 5008\n\n    def test_array_argument_as_list(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo_s { int a, b; };\")\n        seen = []\n        def cb(argv):\n            seen.append(ffi.string(argv[0]))\n            seen.append(ffi.string(argv[1]))\n        a = ffi.callback(\"void(*)(char *[])\", cb)\n        a([ffi.new(\"char[]\", b\"foobar\"), ffi.new(\"char[]\", b\"baz\")])\n        assert seen == [b\"foobar\", b\"baz\"]\n\n    def test_cast_float(self):\n        ffi = FFI(backend=self.Backend())\n        a = ffi.cast(\"float\", 12)\n        assert float(a) == 12.0\n        a = ffi.cast(\"float\", 12.5)\n        assert float(a) == 12.5\n        a = ffi.cast(\"float\", b\"A\")\n        assert float(a) == ord(\"A\")\n        a = ffi.cast(\"int\", 12.9)\n        assert int(a) == 12\n        a = ffi.cast(\"char\", 66.9 + 256)\n        assert ffi.string(a) == b\"B\"\n        #\n        a = ffi.cast(\"float\", ffi.cast(\"int\", 12))\n        assert float(a) == 12.0\n        a = ffi.cast(\"float\", ffi.cast(\"double\", 12.5))\n        assert float(a) == 12.5\n        a = ffi.cast(\"float\", ffi.cast(\"char\", b\"A\"))\n        assert float(a) == ord(\"A\")\n        a = ffi.cast(\"int\", ffi.cast(\"double\", 12.9))\n        assert int(a) == 12\n        a = ffi.cast(\"char\", ffi.cast(\"double\", 66.9 + 256))\n        assert ffi.string(a) == b\"B\"\n\n    def test_enum(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"enum foo { A0, B0, CC0, D0 };\")\n        assert ffi.string(ffi.cast(\"enum foo\", 0)) == \"A0\"\n        assert ffi.string(ffi.cast(\"enum foo\", 2)) == \"CC0\"\n        assert ffi.string(ffi.cast(\"enum foo\", 3)) == \"D0\"\n        assert ffi.string(ffi.cast(\"enum foo\", 4)) == \"4\"\n        ffi.cdef(\"enum bar { A1, B1=-2, CC1, D1, E1 };\")\n        assert ffi.string(ffi.cast(\"enum bar\", 0)) == \"A1\"\n        assert ffi.string(ffi.cast(\"enum bar\", -2)) == \"B1\"\n        assert ffi.string(ffi.cast(\"enum bar\", -1)) == \"CC1\"\n        assert ffi.string(ffi.cast(\"enum bar\", 1)) == \"E1\"\n        assert ffi.cast(\"enum bar\", -2) != ffi.cast(\"enum bar\", -2)\n        assert ffi.cast(\"enum foo\", 0) != ffi.cast(\"enum bar\", 0)\n        assert ffi.cast(\"enum bar\", 0) != ffi.cast(\"int\", 0)\n        assert repr(ffi.cast(\"enum bar\", -1)) == \"<cdata 'enum bar' -1: CC1>\"\n        assert repr(ffi.cast(\"enum foo\", -1)) == (  # enums are unsigned, if\n            \"<cdata 'enum foo' 4294967295>\")        # they contain no neg value\n        ffi.cdef(\"enum baz { A2=0x1000, B2=0x2000 };\")\n        assert ffi.string(ffi.cast(\"enum baz\", 0x1000)) == \"A2\"\n        assert ffi.string(ffi.cast(\"enum baz\", 0x2000)) == \"B2\"\n\n    def test_enum_in_struct(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"enum foo { A, B, C, D }; struct bar { enum foo e; };\")\n        s = ffi.new(\"struct bar *\")\n        s.e = 0\n        assert s.e == 0\n        s.e = 3\n        assert s.e == 3\n        assert s[0].e == 3\n        s[0].e = 2\n        assert s.e == 2\n        assert s[0].e == 2\n        s.e = ffi.cast(\"enum foo\", -1)\n        assert s.e == 4294967295\n        assert s[0].e == 4294967295\n        s.e = s.e\n        py.test.raises(TypeError, \"s.e = 'B'\")\n        py.test.raises(TypeError, \"s.e = '2'\")\n        py.test.raises(TypeError, \"s.e = '#2'\")\n        py.test.raises(TypeError, \"s.e = '#7'\")\n\n    def test_enum_non_contiguous(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"enum foo { A, B=42, C };\")\n        assert ffi.string(ffi.cast(\"enum foo\", 0)) == \"A\"\n        assert ffi.string(ffi.cast(\"enum foo\", 42)) == \"B\"\n        assert ffi.string(ffi.cast(\"enum foo\", 43)) == \"C\"\n        invalid_value = ffi.cast(\"enum foo\", 2)\n        assert int(invalid_value) == 2\n        assert ffi.string(invalid_value) == \"2\"\n\n    def test_enum_char_hex_oct(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(r\"enum foo{A='!', B='\\'', C=0x10, D=010, E=- 0x10, F=-010};\")\n        assert ffi.string(ffi.cast(\"enum foo\", ord('!'))) == \"A\"\n        assert ffi.string(ffi.cast(\"enum foo\", ord(\"'\"))) == \"B\"\n        assert ffi.string(ffi.cast(\"enum foo\", 16)) == \"C\"\n        assert ffi.string(ffi.cast(\"enum foo\", 8)) == \"D\"\n        assert ffi.string(ffi.cast(\"enum foo\", -16)) == \"E\"\n        assert ffi.string(ffi.cast(\"enum foo\", -8)) == \"F\"\n\n    def test_array_of_struct(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo { int a, b; };\")\n        s = ffi.new(\"struct foo[1]\")\n        py.test.raises(AttributeError, 's.b')\n        py.test.raises(AttributeError, 's.b = 412')\n        s[0].b = 412\n        assert s[0].b == 412\n        py.test.raises(IndexError, 's[1]')\n\n    def test_pointer_to_array(self):\n        ffi = FFI(backend=self.Backend())\n        p = ffi.new(\"int(**)[5]\")\n        assert repr(p) == \"<cdata 'int(* *)[5]' owning %d bytes>\" % SIZE_OF_PTR\n\n    def test_iterate_array(self):\n        ffi = FFI(backend=self.Backend())\n        a = ffi.new(\"char[]\", b\"hello\")\n        assert list(a) == [b\"h\", b\"e\", b\"l\", b\"l\", b\"o\", b\"\\0\"]\n        assert list(iter(a)) == [b\"h\", b\"e\", b\"l\", b\"l\", b\"o\", b\"\\0\"]\n        #\n        py.test.raises(TypeError, iter, ffi.cast(\"char *\", a))\n        py.test.raises(TypeError, list, ffi.cast(\"char *\", a))\n        py.test.raises(TypeError, iter, ffi.new(\"int *\"))\n        py.test.raises(TypeError, list, ffi.new(\"int *\"))\n\n    def test_offsetof(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo { int a, b, c; };\")\n        assert ffi.offsetof(\"struct foo\", \"a\") == 0\n        assert ffi.offsetof(\"struct foo\", \"b\") == 4\n        assert ffi.offsetof(\"struct foo\", \"c\") == 8\n\n    def test_offsetof_nested(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo { int a, b, c; };\"\n                 \"struct bar { struct foo d, e; };\")\n        assert ffi.offsetof(\"struct bar\", \"e\") == 12\n        py.test.raises(KeyError, ffi.offsetof, \"struct bar\", \"e.a\")\n        assert ffi.offsetof(\"struct bar\", \"e\", \"a\") == 12\n        assert ffi.offsetof(\"struct bar\", \"e\", \"b\") == 16\n        assert ffi.offsetof(\"struct bar\", \"e\", \"c\") == 20\n\n    def test_offsetof_array(self):\n        ffi = FFI(backend=self.Backend())\n        assert ffi.offsetof(\"int[]\", 51) == 51 * ffi.sizeof(\"int\")\n        assert ffi.offsetof(\"int *\", 51) == 51 * ffi.sizeof(\"int\")\n        ffi.cdef(\"struct bar { int a, b; int c[99]; };\")\n        assert ffi.offsetof(\"struct bar\", \"c\") == 2 * ffi.sizeof(\"int\")\n        assert ffi.offsetof(\"struct bar\", \"c\", 0) == 2 * ffi.sizeof(\"int\")\n        assert ffi.offsetof(\"struct bar\", \"c\", 51) == 53 * ffi.sizeof(\"int\")\n\n    def test_alignof(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo { char a; short b; char c; };\")\n        assert ffi.alignof(\"int\") == 4\n        assert ffi.alignof(\"double\") in (4, 8)\n        assert ffi.alignof(\"struct foo\") == 2\n\n    def test_bitfield(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo { int a:10, b:20, c:3; };\")\n        assert ffi.sizeof(\"struct foo\") == 8\n        s = ffi.new(\"struct foo *\")\n        s.a = 511\n        py.test.raises(OverflowError, \"s.a = 512\")\n        py.test.raises(OverflowError, \"s[0].a = 512\")\n        assert s.a == 511\n        s.a = -512\n        py.test.raises(OverflowError, \"s.a = -513\")\n        py.test.raises(OverflowError, \"s[0].a = -513\")\n        assert s.a == -512\n        s.c = 3\n        assert s.c == 3\n        py.test.raises(OverflowError, \"s.c = 4\")\n        py.test.raises(OverflowError, \"s[0].c = 4\")\n        s.c = -4\n        assert s.c == -4\n\n    def test_bitfield_enum(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            typedef enum { AA, BB, CC } foo_e;\n            typedef struct { foo_e f:2; } foo_s;\n        \"\"\")\n        s = ffi.new(\"foo_s *\")\n        s.f = 2\n        assert s.f == 2\n\n    def test_anonymous_struct(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"typedef struct { int a; } foo_t;\")\n        ffi.cdef(\"typedef struct { char b, c; } bar_t;\")\n        f = ffi.new(\"foo_t *\", [12345])\n        b = ffi.new(\"bar_t *\", [b\"B\", b\"C\"])\n        assert f.a == 12345\n        assert b.b == b\"B\"\n        assert b.c == b\"C\"\n        assert repr(b).startswith(\"<cdata 'bar_t *'\")\n\n    def test_struct_with_two_usages(self):\n        for name in ['foo_s', '']:    # anonymous or not\n            ffi = FFI(backend=self.Backend())\n            ffi.cdef(\"typedef struct %s { int a; } foo_t, *foo_p;\" % name)\n            f = ffi.new(\"foo_t *\", [12345])\n            ps = ffi.new(\"foo_p[]\", [f])\n\n    def test_pointer_arithmetic(self):\n        ffi = FFI(backend=self.Backend())\n        s = ffi.new(\"short[]\", list(range(100, 110)))\n        p = ffi.cast(\"short *\", s)\n        assert p[2] == 102\n        assert p+1 == p+1\n        assert p+1 != p+0\n        assert p == p+0 == p-0\n        assert (p+1)[0] == 101\n        assert (p+19)[-10] == 109\n        assert (p+5) - (p+1) == 4\n        assert p == s+0\n        assert p+1 == s+1\n\n    def test_pointer_comparison(self):\n        ffi = FFI(backend=self.Backend())\n        s = ffi.new(\"short[]\", list(range(100)))\n        p = ffi.cast(\"short *\", s)\n        assert (p <  s) is False\n        assert (p <= s) is True\n        assert (p == s) is True\n        assert (p != s) is False\n        assert (p >  s) is False\n        assert (p >= s) is True\n        assert (s <  p) is False\n        assert (s <= p) is True\n        assert (s == p) is True\n        assert (s != p) is False\n        assert (s >  p) is False\n        assert (s >= p) is True\n        q = p + 1\n        assert (q <  s) is False\n        assert (q <= s) is False\n        assert (q == s) is False\n        assert (q != s) is True\n        assert (q >  s) is True\n        assert (q >= s) is True\n        assert (s <  q) is True\n        assert (s <= q) is True\n        assert (s == q) is False\n        assert (s != q) is True\n        assert (s >  q) is False\n        assert (s >= q) is False\n        assert (q <  p) is False\n        assert (q <= p) is False\n        assert (q == p) is False\n        assert (q != p) is True\n        assert (q >  p) is True\n        assert (q >= p) is True\n        assert (p <  q) is True\n        assert (p <= q) is True\n        assert (p == q) is False\n        assert (p != q) is True\n        assert (p >  q) is False\n        assert (p >= q) is False\n        #\n        assert (None == s) is False\n        assert (None != s) is True\n        assert (s == None) is False\n        assert (s != None) is True\n        assert (None == q) is False\n        assert (None != q) is True\n        assert (q == None) is False\n        assert (q != None) is True\n\n    def test_no_integer_comparison(self):\n        ffi = FFI(backend=self.Backend())\n        x = ffi.cast(\"int\", 123)\n        y = ffi.cast(\"int\", 456)\n        py.test.raises(TypeError, \"x < y\")\n        #\n        z = ffi.cast(\"double\", 78.9)\n        py.test.raises(TypeError, \"x < z\")\n        py.test.raises(TypeError, \"z < y\")\n\n    def test_ffi_buffer_ptr(self):\n        ffi = FFI(backend=self.Backend())\n        a = ffi.new(\"short *\", 100)\n        try:\n            b = ffi.buffer(a)\n        except NotImplementedError as e:\n            py.test.skip(str(e))\n        content = b[:]\n        assert len(content) == len(b) == 2\n        if sys.byteorder == 'little':\n            assert content == b'\\x64\\x00'\n            assert b[0] == b'\\x64'\n            b[0] = b'\\x65'\n        else:\n            assert content == b'\\x00\\x64'\n            assert b[1] == b'\\x64'\n            b[1] = b'\\x65'\n        assert a[0] == 101\n\n    def test_ffi_buffer_array(self):\n        ffi = FFI(backend=self.Backend())\n        a = ffi.new(\"int[]\", list(range(100, 110)))\n        try:\n            b = ffi.buffer(a)\n        except NotImplementedError as e:\n            py.test.skip(str(e))\n        content = b[:]\n        if sys.byteorder == 'little':\n            assert content.startswith(b'\\x64\\x00\\x00\\x00\\x65\\x00\\x00\\x00')\n            b[4] = b'\\x45'\n        else:\n            assert content.startswith(b'\\x00\\x00\\x00\\x64\\x00\\x00\\x00\\x65')\n            b[7] = b'\\x45'\n        assert len(content) == 4 * 10\n        assert a[1] == 0x45\n\n    def test_ffi_buffer_ptr_size(self):\n        ffi = FFI(backend=self.Backend())\n        a = ffi.new(\"short *\", 0x4243)\n        try:\n            b = ffi.buffer(a, 1)\n        except NotImplementedError as e:\n            py.test.skip(str(e))\n        content = b[:]\n        assert len(content) == 1\n        if sys.byteorder == 'little':\n            assert content == b'\\x43'\n            b[0] = b'\\x62'\n            assert a[0] == 0x4262\n        else:\n            assert content == b'\\x42'\n            b[0] = b'\\x63'\n            assert a[0] == 0x6343\n\n    def test_ffi_buffer_array_size(self):\n        ffi = FFI(backend=self.Backend())\n        a1 = ffi.new(\"int[]\", list(range(100, 110)))\n        a2 = ffi.new(\"int[]\", list(range(100, 115)))\n        try:\n            ffi.buffer(a1)\n        except NotImplementedError as e:\n            py.test.skip(str(e))\n        assert ffi.buffer(a1)[:] == ffi.buffer(a2, 4*10)[:]\n\n    def test_ffi_buffer_with_file(self):\n        ffi = FFI(backend=self.Backend())\n        import tempfile, os, array\n        fd, filename = tempfile.mkstemp()\n        f = os.fdopen(fd, 'r+b')\n        a = ffi.new(\"int[]\", list(range(1005)))\n        try:\n            ffi.buffer(a, 512)\n        except NotImplementedError as e:\n            py.test.skip(str(e))\n        f.write(ffi.buffer(a, 1000 * ffi.sizeof(\"int\")))\n        f.seek(0)\n        assert f.read() == array.array('i', range(1000)).tostring()\n        f.seek(0)\n        b = ffi.new(\"int[]\", 1005)\n        f.readinto(ffi.buffer(b, 1000 * ffi.sizeof(\"int\")))\n        assert list(a)[:1000] + [0] * (len(a)-1000) == list(b)\n        f.close()\n        os.unlink(filename)\n\n    def test_ffi_buffer_with_io(self):\n        ffi = FFI(backend=self.Backend())\n        import io, array\n        f = io.BytesIO()\n        a = ffi.new(\"int[]\", list(range(1005)))\n        try:\n            ffi.buffer(a, 512)\n        except NotImplementedError as e:\n            py.test.skip(str(e))\n        f.write(ffi.buffer(a, 1000 * ffi.sizeof(\"int\")))\n        f.seek(0)\n        assert f.read() == array.array('i', range(1000)).tostring()\n        f.seek(0)\n        b = ffi.new(\"int[]\", 1005)\n        f.readinto(ffi.buffer(b, 1000 * ffi.sizeof(\"int\")))\n        assert list(a)[:1000] + [0] * (len(a)-1000) == list(b)\n        f.close()\n\n    def test_array_in_struct(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo_s { int len; short data[5]; };\")\n        p = ffi.new(\"struct foo_s *\")\n        p.data[3] = 5\n        assert p.data[3] == 5\n        assert repr(p.data).startswith(\"<cdata 'short[5]' 0x\")\n\n    def test_struct_containing_array_varsize_workaround(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo_s { int len; short data[0]; };\")\n        p = ffi.new(\"char[]\", ffi.sizeof(\"struct foo_s\") + 7 * SIZE_OF_SHORT)\n        q = ffi.cast(\"struct foo_s *\", p)\n        assert q.len == 0\n        # 'q.data' gets not a 'short[0]', but just a 'short *' instead\n        assert repr(q.data).startswith(\"<cdata 'short *' 0x\")\n        assert q.data[6] == 0\n        q.data[6] = 15\n        assert q.data[6] == 15\n\n    def test_new_struct_containing_array_varsize(self):\n        py.test.skip(\"later?\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo_s { int len; short data[]; };\")\n        p = ffi.new(\"struct foo_s *\", 10)     # a single integer is the length\n        assert p.len == 0\n        assert p.data[9] == 0\n        py.test.raises(IndexError, \"p.data[10]\")\n\n    def test_ffi_typeof_getcname(self):\n        ffi = FFI(backend=self.Backend())\n        assert ffi.getctype(\"int\") == \"int\"\n        assert ffi.getctype(\"int\", 'x') == \"int x\"\n        assert ffi.getctype(\"int*\") == \"int *\"\n        assert ffi.getctype(\"int*\", '') == \"int *\"\n        assert ffi.getctype(\"int*\", 'x') == \"int * x\"\n        assert ffi.getctype(\"int\", '*') == \"int *\"\n        assert ffi.getctype(\"int\", ' * x ') == \"int * x\"\n        assert ffi.getctype(ffi.typeof(\"int*\"), '*') == \"int * *\"\n        assert ffi.getctype(\"int\", '[5]') == \"int[5]\"\n        assert ffi.getctype(\"int[5]\", '[6]') == \"int[6][5]\"\n        assert ffi.getctype(\"int[5]\", '(*)') == \"int(*)[5]\"\n        # special-case for convenience: automatically put '()' around '*'\n        assert ffi.getctype(\"int[5]\", '*') == \"int(*)[5]\"\n        assert ffi.getctype(\"int[5]\", '*foo') == \"int(*foo)[5]\"\n        assert ffi.getctype(\"int[5]\", ' ** foo ') == \"int(** foo)[5]\"\n\n    def test_array_of_func_ptr(self):\n        ffi = FFI(backend=self.Backend())\n        f = ffi.cast(\"int(*)(int)\", 42)\n        assert f != ffi.NULL\n        py.test.raises(CDefError, ffi.cast, \"int(int)\", 42)\n        py.test.raises(CDefError, ffi.new, \"int([5])(int)\")\n        a = ffi.new(\"int(*[5])(int)\", [f])\n        assert ffi.getctype(ffi.typeof(a)) == \"int(*[5])(int)\"\n        assert len(a) == 5\n        assert a[0] == f\n        assert a[1] == ffi.NULL\n        py.test.raises(TypeError, ffi.cast, \"int(*)(int)[5]\", 0)\n        #\n        def cb(n):\n            return n + 1\n        f = ffi.callback(\"int(*)(int)\", cb)\n        a = ffi.new(\"int(*[5])(int)\", [f, f])\n        assert a[1](42) == 43\n\n    def test_callback_as_function_argument(self):\n        # In C, function arguments can be declared with a function type,\n        # which is automatically replaced with the ptr-to-function type.\n        ffi = FFI(backend=self.Backend())\n        def cb(a, b):\n            return chr(ord(a) + ord(b)).encode()\n        f = ffi.callback(\"char cb(char, char)\", cb)\n        assert f(b'A', b'\\x01') == b'B'\n        def g(callback):\n            return callback(b'A', b'\\x01')\n        g = ffi.callback(\"char g(char cb(char, char))\", g)\n        assert g(f) == b'B'\n\n    def test_vararg_callback(self):\n        py.test.skip(\"callback with '...'\")\n        ffi = FFI(backend=self.Backend())\n        def cb(i, va_list):\n            j = ffi.va_arg(va_list, \"int\")\n            k = ffi.va_arg(va_list, \"long long\")\n            return i * 2 + j * 3 + k * 5\n        f = ffi.callback(\"long long cb(long i, ...)\", cb)\n        res = f(10, ffi.cast(\"int\", 100), ffi.cast(\"long long\", 1000))\n        assert res == 20 + 300 + 5000\n\n    def test_callback_decorator(self):\n        ffi = FFI(backend=self.Backend())\n        #\n        @ffi.callback(\"long(long, long)\", error=42)\n        def cb(a, b):\n            return a - b\n        #\n        assert cb(-100, -10) == -90\n        sz = ffi.sizeof(\"long\")\n        assert cb((1 << (sz*8-1)) - 1, -10) == 42\n\n    def test_unique_types(self):\n        ffi1 = FFI(backend=self.Backend())\n        ffi2 = FFI(backend=self.Backend())\n        assert ffi1.typeof(\"char\") is ffi2.typeof(\"char \")\n        assert ffi1.typeof(\"long\") is ffi2.typeof(\"signed long int\")\n        assert ffi1.typeof(\"double *\") is ffi2.typeof(\"double*\")\n        assert ffi1.typeof(\"int ***\") is ffi2.typeof(\" int * * *\")\n        assert ffi1.typeof(\"int[]\") is ffi2.typeof(\"signed int[]\")\n        assert ffi1.typeof(\"signed int*[17]\") is ffi2.typeof(\"int *[17]\")\n        assert ffi1.typeof(\"void\") is ffi2.typeof(\"void\")\n        assert ffi1.typeof(\"int(*)(int,int)\") is ffi2.typeof(\"int(*)(int,int)\")\n        #\n        # these depend on user-defined data, so should not be shared\n        assert ffi1.typeof(\"struct foo\") is not ffi2.typeof(\"struct foo\")\n        assert ffi1.typeof(\"union foo *\") is not ffi2.typeof(\"union foo*\")\n        assert ffi1.typeof(\"enum foo\") is not ffi2.typeof(\"enum foo\")\n        # sanity check: twice 'ffi1'\n        assert ffi1.typeof(\"struct foo*\") is ffi1.typeof(\"struct foo *\")\n\n    def test_anonymous_enum(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"typedef enum { Value0 = 0 } e, *pe;\\n\"\n                 \"typedef enum { Value1 = 1 } e1;\")\n        assert ffi.getctype(\"e*\") == 'e *'\n        assert ffi.getctype(\"pe\") == 'e *'\n        assert ffi.getctype(\"e1*\") == 'e1 *'\n\n    def test_new_ctype(self):\n        ffi = FFI(backend=self.Backend())\n        p = ffi.new(\"int *\")\n        py.test.raises(TypeError, ffi.new, p)\n        p = ffi.new(ffi.typeof(\"int *\"), 42)\n        assert p[0] == 42\n\n    def test_enum_with_non_injective_mapping(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"enum e { AA=0, BB=0, CC=0, DD=0 };\")\n        e = ffi.cast(\"enum e\", 0)\n        assert ffi.string(e) == \"AA\"     # pick the first one arbitrarily\n\n    def test_enum_refer_previous_enum_value(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"enum e { AA, BB=2, CC=4, DD=BB, EE, FF=CC, GG=FF };\")\n        assert ffi.string(ffi.cast(\"enum e\", 2)) == \"BB\"\n        assert ffi.string(ffi.cast(\"enum e\", 3)) == \"EE\"\n        assert ffi.sizeof(\"char[DD]\") == 2\n        assert ffi.sizeof(\"char[EE]\") == 3\n        assert ffi.sizeof(\"char[FF]\") == 4\n        assert ffi.sizeof(\"char[GG]\") == 4\n\n    def test_nested_anonymous_struct(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            struct foo_s {\n                struct { int a, b; };\n                union { int c, d; };\n            };\n        \"\"\")\n        assert ffi.sizeof(\"struct foo_s\") == 3 * SIZE_OF_INT\n        p = ffi.new(\"struct foo_s *\", [1, 2, 3])\n        assert p.a == 1\n        assert p.b == 2\n        assert p.c == 3\n        assert p.d == 3\n        p.d = 17\n        assert p.c == 17\n        p.b = 19\n        assert p.a == 1\n        assert p.b == 19\n        assert p.c == 17\n        assert p.d == 17\n        p = ffi.new(\"struct foo_s *\", {'b': 12, 'd': 14})\n        assert p.a == 0\n        assert p.b == 12\n        assert p.c == 14\n        assert p.d == 14\n\n    def test_nested_field_offset_align(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            struct foo_s {\n                struct { int a; char b; };\n                union { char c; };\n            };\n        \"\"\")\n        assert ffi.offsetof(\"struct foo_s\", \"c\") == 2 * SIZE_OF_INT\n        assert ffi.sizeof(\"struct foo_s\") == 3 * SIZE_OF_INT\n\n    def test_nested_anonymous_union(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            union foo_u {\n                struct { int a, b; };\n                union { int c, d; };\n            };\n        \"\"\")\n        assert ffi.sizeof(\"union foo_u\") == 2 * SIZE_OF_INT\n        p = ffi.new(\"union foo_u *\", [5])\n        assert p.a == 5\n        assert p.b == 0\n        assert p.c == 5\n        assert p.d == 5\n        p.d = 17\n        assert p.c == 17\n        assert p.a == 17\n        p.b = 19\n        assert p.a == 17\n        assert p.b == 19\n        assert p.c == 17\n        assert p.d == 17\n        p = ffi.new(\"union foo_u *\", {'d': 14})\n        assert p.a == 14\n        assert p.b == 0\n        assert p.c == 14\n        assert p.d == 14\n        p = ffi.new(\"union foo_u *\", {'b': 12})\n        assert p.a == 0\n        assert p.b == 12\n        assert p.c == 0\n        assert p.d == 0\n        # we cannot specify several items in the dict, even though\n        # in theory in this particular case it would make sense\n        # to give both 'a' and 'b'\n\n    def test_cast_to_array_type(self):\n        ffi = FFI(backend=self.Backend())\n        p = ffi.new(\"int[4]\", [-5])\n        q = ffi.cast(\"int[3]\", p)\n        assert q[0] == -5\n        assert repr(q).startswith(\"<cdata 'int[3]' 0x\")\n\n    def test_gc(self):\n        ffi = FFI(backend=self.Backend())\n        p = ffi.new(\"int *\", 123)\n        seen = []\n        def destructor(p1):\n            assert p1 is p\n            assert p1[0] == 123\n            seen.append(1)\n        q = ffi.gc(p, destructor)\n        import gc; gc.collect()\n        assert seen == []\n        del q\n        import gc; gc.collect(); gc.collect(); gc.collect()\n        assert seen == [1]\n\n    def test_gc_2(self):\n        ffi = FFI(backend=self.Backend())\n        p = ffi.new(\"int *\", 123)\n        seen = []\n        q1 = ffi.gc(p, lambda p: seen.append(1))\n        q2 = ffi.gc(q1, lambda p: seen.append(2))\n        import gc; gc.collect()\n        assert seen == []\n        del q1, q2\n        import gc; gc.collect(); gc.collect(); gc.collect(); gc.collect()\n        assert seen == [2, 1]\n\n    def test_gc_3(self):\n        ffi = FFI(backend=self.Backend())\n        p = ffi.new(\"int *\", 123)\n        r = ffi.new(\"int *\", 123)\n        seen = []\n        seen_r = []\n        q1 = ffi.gc(p, lambda p: seen.append(1))\n        s1 = ffi.gc(r, lambda r: seen_r.append(4))\n        q2 = ffi.gc(q1, lambda p: seen.append(2))\n        s2 = ffi.gc(s1, lambda r: seen_r.append(5))\n        q3 = ffi.gc(q2, lambda p: seen.append(3))\n        import gc; gc.collect()\n        assert seen == []\n        assert seen_r == []\n        del q1, q2, q3, s2, s1\n        import gc; gc.collect(); gc.collect(); gc.collect(); gc.collect()\n        assert seen == [3, 2, 1]\n        assert seen_r == [5, 4]\n\n    def test_gc_4(self):\n        ffi = FFI(backend=self.Backend())\n        p = ffi.new(\"int *\", 123)\n        seen = []\n        q1 = ffi.gc(p, lambda p: seen.append(1))\n        q2 = ffi.gc(q1, lambda p: seen.append(2))\n        q3 = ffi.gc(q2, lambda p: seen.append(3))\n        import gc; gc.collect()\n        assert seen == []\n        del q1, q3     # q2 remains, and has a hard ref to q1\n        import gc; gc.collect(); gc.collect(); gc.collect()\n        assert seen == [3]\n\n    def test_gc_finite_list(self):\n        ffi = FFI(backend=self.Backend())\n        p = ffi.new(\"int *\", 123)\n        keepalive = []\n        for i in range(10):\n            keepalive.append(ffi.gc(p, lambda p: None))\n            assert len(ffi.gc_weakrefs.data) == i + 1  #should be a private attr\n        del keepalive[:]\n        import gc; gc.collect(); gc.collect()\n        for i in range(10):\n            keepalive.append(ffi.gc(p, lambda p: None))\n        assert len(ffi.gc_weakrefs.data) == 10\n\n    def test_CData_CType(self):\n        ffi = FFI(backend=self.Backend())\n        assert isinstance(ffi.cast(\"int\", 0), ffi.CData)\n        assert isinstance(ffi.new(\"int *\"), ffi.CData)\n        assert not isinstance(ffi.typeof(\"int\"), ffi.CData)\n        assert not isinstance(ffi.cast(\"int\", 0), ffi.CType)\n        assert not isinstance(ffi.new(\"int *\"), ffi.CType)\n\n    def test_CData_CType_2(self):\n        ffi = FFI(backend=self.Backend())\n        assert isinstance(ffi.typeof(\"int\"), ffi.CType)\n\n    def test_bool(self):\n        ffi = FFI(backend=self.Backend())\n        assert int(ffi.cast(\"_Bool\", 0.1)) == 1\n        assert int(ffi.cast(\"_Bool\", -0.0)) == 0\n        assert int(ffi.cast(\"_Bool\", b'\\x02')) == 1\n        assert int(ffi.cast(\"_Bool\", b'\\x00')) == 0\n        assert int(ffi.cast(\"_Bool\", b'\\x80')) == 1\n        assert ffi.new(\"_Bool *\", False)[0] == 0\n        assert ffi.new(\"_Bool *\", 1)[0] == 1\n        py.test.raises(OverflowError, ffi.new, \"_Bool *\", 2)\n        py.test.raises(TypeError, ffi.string, ffi.cast(\"_Bool\", 2))\n\n    def test_use_own_bool(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"typedef int bool;\"\"\")\n\n    def test_ordering_bug1(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            struct foo_s {\n                struct bar_s *p;\n            };\n            struct bar_s {\n                struct foo_s foo;\n            };\n        \"\"\")\n        q = ffi.new(\"struct foo_s *\")\n        bar = ffi.new(\"struct bar_s *\")\n        q.p = bar\n        assert q.p.foo.p == ffi.NULL\n\n    def test_ordering_bug2(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            struct bar_s;\n\n            struct foo_s {\n                void (*foo)(struct bar_s[]);\n            };\n\n            struct bar_s {\n                struct foo_s foo;\n            };\n        \"\"\")\n        q = ffi.new(\"struct foo_s *\")\n\n    def test_addressof(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo_s { int x, y; };\")\n        p = ffi.new(\"struct foo_s *\")\n        a = ffi.addressof(p[0])\n        assert repr(a).startswith(\"<cdata 'struct foo_s *' 0x\")\n        assert a == p\n        py.test.raises(TypeError, ffi.addressof, p)\n        py.test.raises((AttributeError, TypeError), ffi.addressof, 5)\n        py.test.raises(TypeError, ffi.addressof, ffi.cast(\"int\", 5))\n\n    def test_addressof_field(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo_s { int x, y; };\")\n        p = ffi.new(\"struct foo_s *\")\n        a = ffi.addressof(p[0], 'y')\n        assert repr(a).startswith(\"<cdata 'int *' 0x\")\n        assert int(ffi.cast(\"uintptr_t\", a)) == (\n            int(ffi.cast(\"uintptr_t\", p)) + ffi.sizeof(\"int\"))\n        assert a == ffi.addressof(p, 'y')\n        assert a != ffi.addressof(p, 'x')\n\n    def test_addressof_field_nested(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo_s { int x, y; };\"\n                 \"struct bar_s { struct foo_s a, b; };\")\n        p = ffi.new(\"struct bar_s *\")\n        py.test.raises(KeyError, ffi.addressof, p[0], 'b.y')\n        a = ffi.addressof(p[0], 'b', 'y')\n        assert int(ffi.cast(\"uintptr_t\", a)) == (\n            int(ffi.cast(\"uintptr_t\", p)) +\n            ffi.sizeof(\"struct foo_s\") + ffi.sizeof(\"int\"))\n\n    def test_addressof_anonymous_struct(self):\n        ffi = FFI()\n        ffi.cdef(\"typedef struct { int x; } foo_t;\")\n        p = ffi.new(\"foo_t *\")\n        a = ffi.addressof(p[0])\n        assert a == p\n\n    def test_addressof_array(self):\n        ffi = FFI()\n        p = ffi.new(\"int[52]\")\n        p0 = ffi.addressof(p)\n        assert p0 == p\n        assert ffi.typeof(p0) is ffi.typeof(\"int(*)[52]\")\n        py.test.raises(TypeError, ffi.addressof, p0)\n        #\n        p1 = ffi.addressof(p, 25)\n        assert ffi.typeof(p1) is ffi.typeof(\"int *\")\n        assert (p1 - p) == 25\n        assert ffi.addressof(p, 0) == p\n\n    def test_addressof_pointer(self):\n        ffi = FFI()\n        array = ffi.new(\"int[50]\")\n        p = ffi.cast(\"int *\", array)\n        py.test.raises(TypeError, ffi.addressof, p)\n        assert ffi.addressof(p, 0) == p\n        assert ffi.addressof(p, 25) == p + 25\n        assert ffi.typeof(ffi.addressof(p, 25)) == ffi.typeof(p)\n        #\n        ffi.cdef(\"struct foo { int a, b; };\")\n        array = ffi.new(\"struct foo[50]\")\n        p = ffi.cast(\"int *\", array)\n        py.test.raises(TypeError, ffi.addressof, p)\n        assert ffi.addressof(p, 0) == p\n        assert ffi.addressof(p, 25) == p + 25\n        assert ffi.typeof(ffi.addressof(p, 25)) == ffi.typeof(p)\n\n    def test_addressof_array_in_struct(self):\n        ffi = FFI()\n        ffi.cdef(\"struct foo { int a, b; int c[50]; };\")\n        p = ffi.new(\"struct foo *\")\n        p1 = ffi.addressof(p, \"c\", 25)\n        assert ffi.typeof(p1) is ffi.typeof(\"int *\")\n        assert p1 == ffi.cast(\"int *\", p) + 27\n        assert ffi.addressof(p, \"c\") == ffi.cast(\"int *\", p) + 2\n        assert ffi.addressof(p, \"c\", 0) == ffi.cast(\"int *\", p) + 2\n        p2 = ffi.addressof(p, 1)\n        assert ffi.typeof(p2) is ffi.typeof(\"struct foo *\")\n        assert p2 == p + 1\n\n    def test_multiple_independent_structs(self):\n        ffi1 = FFI(); ffi1.cdef(\"struct foo { int x; };\")\n        ffi2 = FFI(); ffi2.cdef(\"struct foo { int y, z; };\")\n        foo1 = ffi1.new(\"struct foo *\", [10])\n        foo2 = ffi2.new(\"struct foo *\", [20, 30])\n        assert foo1.x == 10\n        assert foo2.y == 20\n        assert foo2.z == 30\n\n    def test_missing_include(self):\n        backend = self.Backend()\n        ffi1 = FFI(backend=backend)\n        ffi2 = FFI(backend=backend)\n        ffi1.cdef(\"typedef signed char schar_t;\")\n        py.test.raises(CDefError, ffi2.cast, \"schar_t\", 142)\n\n    def test_include_typedef(self):\n        backend = self.Backend()\n        ffi1 = FFI(backend=backend)\n        ffi2 = FFI(backend=backend)\n        ffi1.cdef(\"typedef signed char schar_t;\")\n        ffi2.include(ffi1)\n        p = ffi2.cast(\"schar_t\", 142)\n        assert int(p) == 142 - 256\n\n    def test_include_struct(self):\n        backend = self.Backend()\n        ffi1 = FFI(backend=backend)\n        ffi2 = FFI(backend=backend)\n        ffi1.cdef(\"struct foo { int x; };\")\n        ffi2.include(ffi1)\n        p = ffi2.new(\"struct foo *\", [142])\n        assert p.x == 142\n\n    def test_include_union(self):\n        backend = self.Backend()\n        ffi1 = FFI(backend=backend)\n        ffi2 = FFI(backend=backend)\n        ffi1.cdef(\"union foo { int x; };\")\n        ffi2.include(ffi1)\n        p = ffi2.new(\"union foo *\", [142])\n        assert p.x == 142\n\n    def test_include_enum(self):\n        backend = self.Backend()\n        ffi1 = FFI(backend=backend)\n        ffi2 = FFI(backend=backend)\n        ffi1.cdef(\"enum foo { FA, FB, FC };\")\n        ffi2.include(ffi1)\n        p = ffi2.cast(\"enum foo\", 1)\n        assert ffi2.string(p) == \"FB\"\n        assert ffi2.sizeof(\"char[FC]\") == 2\n\n    def test_include_typedef_2(self):\n        backend = self.Backend()\n        ffi1 = FFI(backend=backend)\n        ffi2 = FFI(backend=backend)\n        ffi1.cdef(\"typedef struct { int x; } *foo_p;\")\n        ffi2.include(ffi1)\n        p = ffi2.new(\"foo_p\", [142])\n        assert p.x == 142\n\n    def test_ignore_multiple_declarations_of_constant(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"#define FOO 42\")\n        ffi.cdef(\"#define FOO 42\")\n        py.test.raises(FFIError, ffi.cdef, \"#define FOO 43\")\n\n    def test_struct_packed(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct nonpacked { char a; int b; };\")\n        ffi.cdef(\"struct is_packed { char a; int b; };\", packed=True)\n        assert ffi.sizeof(\"struct nonpacked\") == 8\n        assert ffi.sizeof(\"struct is_packed\") == 5\n        assert ffi.alignof(\"struct nonpacked\") == 4\n        assert ffi.alignof(\"struct is_packed\") == 1\n        s = ffi.new(\"struct is_packed[2]\")\n        s[0].b = 42623381\n        s[0].a = b'X'\n        s[1].b = -4892220\n        s[1].a = b'Y'\n        assert s[0].b == 42623381\n        assert s[0].a == b'X'\n        assert s[1].b == -4892220\n        assert s[1].a == b'Y'\n\n    def test_define_integer_constant(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            #define DOT_0 0\n            #define DOT 100\n            #define DOT_OCT 0100l\n            #define DOT_HEX 0x100u\n            #define DOT_HEX2 0X10\n            #define DOT_UL 1000UL\n            enum foo {AA, BB=DOT, CC};\n        \"\"\")\n        lib = ffi.dlopen(None)\n        assert ffi.string(ffi.cast(\"enum foo\", 100)) == \"BB\"\n        assert lib.DOT_0 == 0\n        assert lib.DOT == 100\n        assert lib.DOT_OCT == 0o100\n        assert lib.DOT_HEX == 0x100\n        assert lib.DOT_HEX2 == 0x10\n        assert lib.DOT_UL == 1000\n\n    def test_opaque_struct_becomes_nonopaque(self):\n        # Issue #193: if we use a struct between the first cdef() where it is\n        # declared and another cdef() where its fields are defined, then the\n        # definition was ignored.\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo_s;\")\n        py.test.raises(TypeError, ffi.new, \"struct foo_s *\")\n        ffi.cdef(\"struct foo_s { int x; };\")\n        ffi.new(\"struct foo_s *\")\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.1.2-nak3eqkxfunb4z5owzsqogchnaejp7o4/spack-src/testing/cffi0/test_ffi_backend.py": "import py, sys, platform\nimport pytest\nfrom testing.cffi0 import backend_tests, test_function, test_ownlib\nfrom cffi import FFI\nimport _cffi_backend\n\n\nclass TestFFI(backend_tests.BackendTests,\n              test_function.TestFunction,\n              test_ownlib.TestOwnLib):\n    TypeRepr = \"<ctype '%s'>\"\n\n    @staticmethod\n    def Backend():\n        return _cffi_backend\n\n    def test_not_supported_bitfield_in_result(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo_s { int a,b,c,d,e; int x:1; };\")\n        e = py.test.raises(NotImplementedError, ffi.callback,\n                           \"struct foo_s foo(void)\", lambda: 42)\n        assert str(e.value) == (\"struct foo_s(*)(): \"\n            \"callback with unsupported argument or return type or with '...'\")\n\n    def test_inspecttype(self):\n        ffi = FFI(backend=self.Backend())\n        assert ffi.typeof(\"long\").kind == \"primitive\"\n        assert ffi.typeof(\"long(*)(long, long**, ...)\").cname == (\n            \"long(*)(long, long * *, ...)\")\n        assert ffi.typeof(\"long(*)(long, long**, ...)\").ellipsis is True\n\n    def test_new_handle(self):\n        ffi = FFI(backend=self.Backend())\n        o = [2, 3, 4]\n        p = ffi.new_handle(o)\n        assert ffi.typeof(p) == ffi.typeof(\"void *\")\n        assert ffi.from_handle(p) is o\n        assert ffi.from_handle(ffi.cast(\"char *\", p)) is o\n        py.test.raises(RuntimeError, ffi.from_handle, ffi.NULL)\n\n\nclass TestBitfield:\n    def check(self, source, expected_ofs_y, expected_align, expected_size):\n        # NOTE: 'expected_*' is the numbers expected from GCC.\n        # The numbers expected from MSVC are not explicitly written\n        # in this file, and will just be taken from the compiler.\n        ffi = FFI()\n        ffi.cdef(\"struct s1 { %s };\" % source)\n        ctype = ffi.typeof(\"struct s1\")\n        # verify the information with gcc\n        ffi1 = FFI()\n        ffi1.cdef(\"\"\"\n            static const int Gofs_y, Galign, Gsize;\n            struct s1 *try_with_value(int fieldnum, long long value);\n        \"\"\")\n        fnames = [name for name, cfield in ctype.fields\n                       if name and cfield.bitsize > 0]\n        setters = ['case %d: s.%s = value; break;' % iname\n                   for iname in enumerate(fnames)]\n        lib = ffi1.verify(\"\"\"\n            struct s1 { %s };\n            struct sa { char a; struct s1 b; };\n            #define Gofs_y  offsetof(struct s1, y)\n            #define Galign  offsetof(struct sa, b)\n            #define Gsize   sizeof(struct s1)\n            struct s1 *try_with_value(int fieldnum, long long value)\n            {\n                static struct s1 s;\n                memset(&s, 0, sizeof(s));\n                switch (fieldnum) { %s }\n                return &s;\n            }\n        \"\"\" % (source, ' '.join(setters)))\n        if sys.platform == 'win32':\n            expected_ofs_y = lib.Gofs_y\n            expected_align = lib.Galign\n            expected_size  = lib.Gsize\n        else:\n            assert (lib.Gofs_y, lib.Galign, lib.Gsize) == (\n                expected_ofs_y, expected_align, expected_size)\n        # the real test follows\n        assert ffi.offsetof(\"struct s1\", \"y\") == expected_ofs_y\n        assert ffi.alignof(\"struct s1\") == expected_align\n        assert ffi.sizeof(\"struct s1\") == expected_size\n        # compare the actual storage of the two\n        for name, cfield in ctype.fields:\n            if cfield.bitsize < 0 or not name:\n                continue\n            if int(ffi.cast(cfield.type, -1)) == -1:   # signed\n                min_value = -(1 << (cfield.bitsize-1))\n                max_value = (1 << (cfield.bitsize-1)) - 1\n            else:\n                min_value = 0\n                max_value = (1 << cfield.bitsize) - 1\n            for t in [1, 2, 4, 8, 16, 128, 2813, 89728, 981729,\n                     -1,-2,-4,-8,-16,-128,-2813,-89728,-981729]:\n                if min_value <= t <= max_value:\n                    self._fieldcheck(ffi, lib, fnames, name, t)\n\n    def _fieldcheck(self, ffi, lib, fnames, name, value):\n        s = ffi.new(\"struct s1 *\")\n        setattr(s, name, value)\n        assert getattr(s, name) == value\n        raw1 = ffi.buffer(s)[:]\n        t = lib.try_with_value(fnames.index(name), value)\n        raw2 = ffi.buffer(t, len(raw1))[:]\n        assert raw1 == raw2\n\n    def test_bitfield_basic(self):\n        self.check(\"int a; int b:9; int c:20; int y;\", 8, 4, 12)\n        self.check(\"int a; short b:9; short c:7; int y;\", 8, 4, 12)\n        self.check(\"int a; short b:9; short c:9; int y;\", 8, 4, 12)\n\n    def test_bitfield_reuse_if_enough_space(self):\n        self.check(\"int a:2; char y;\", 1, 4, 4)\n        self.check(\"int a:1; char b  ; int c:1; char y;\", 3, 4, 4)\n        self.check(\"int a:1; char b:8; int c:1; char y;\", 3, 4, 4)\n        self.check(\"char a; int b:9; char y;\", 3, 4, 4)\n        self.check(\"char a; short b:9; char y;\", 4, 2, 6)\n        self.check(\"int a:2; char b:6; char y;\", 1, 4, 4)\n        self.check(\"int a:2; char b:7; char y;\", 2, 4, 4)\n        self.check(\"int a:2; short b:15; char c:2; char y;\", 5, 4, 8)\n        self.check(\"int a:2; char b:1; char c:1; char y;\", 1, 4, 4)\n\n    @pytest.mark.skipif(\"platform.machine().startswith(('arm', 'aarch64'))\")\n    def test_bitfield_anonymous_no_align(self):\n        L = FFI().alignof(\"long long\")\n        self.check(\"char y; int :1;\", 0, 1, 2)\n        self.check(\"char x; int z:1; char y;\", 2, 4, 4)\n        self.check(\"char x; int  :1; char y;\", 2, 1, 3)\n        self.check(\"char x; long long z:48; char y;\", 7, L, 8)\n        self.check(\"char x; long long  :48; char y;\", 7, 1, 8)\n        self.check(\"char x; long long z:56; char y;\", 8, L, 8 + L)\n        self.check(\"char x; long long  :56; char y;\", 8, 1, 9)\n        self.check(\"char x; long long z:57; char y;\", L + 8, L, L + 8 + L)\n        self.check(\"char x; long long  :57; char y;\", L + 8, 1, L + 9)\n\n    @pytest.mark.skipif(\n        \"not platform.machine().startswith(('arm', 'aarch64'))\")\n    def test_bitfield_anonymous_align_arm(self):\n        L = FFI().alignof(\"long long\")\n        self.check(\"char y; int :1;\", 0, 4, 4)\n        self.check(\"char x; int z:1; char y;\", 2, 4, 4)\n        self.check(\"char x; int  :1; char y;\", 2, 4, 4)\n        self.check(\"char x; long long z:48; char y;\", 7, L, 8)\n        self.check(\"char x; long long  :48; char y;\", 7, 8, 8)\n        self.check(\"char x; long long z:56; char y;\", 8, L, 8 + L)\n        self.check(\"char x; long long  :56; char y;\", 8, L, 8 + L)\n        self.check(\"char x; long long z:57; char y;\", L + 8, L, L + 8 + L)\n        self.check(\"char x; long long  :57; char y;\", L + 8, L, L + 8 + L)\n\n    @pytest.mark.skipif(\"platform.machine().startswith(('arm', 'aarch64'))\")\n    def test_bitfield_zero(self):\n        L = FFI().alignof(\"long long\")\n        self.check(\"char y; int :0;\", 0, 1, 4)\n        self.check(\"char x; int :0; char y;\", 4, 1, 5)\n        self.check(\"char x; int :0; int :0; char y;\", 4, 1, 5)\n        self.check(\"char x; long long :0; char y;\", L, 1, L + 1)\n        self.check(\"short x, y; int :0; int :0;\", 2, 2, 4)\n        self.check(\"char x; int :0; short b:1; char y;\", 5, 2, 6)\n        self.check(\"int a:1; int :0; int b:1; char y;\", 5, 4, 8)\n\n    @pytest.mark.skipif(\n        \"not platform.machine().startswith(('arm', 'aarch64'))\")\n    def test_bitfield_zero_arm(self):\n        L = FFI().alignof(\"long long\")\n        self.check(\"char y; int :0;\", 0, 4, 4)\n        self.check(\"char x; int :0; char y;\", 4, 4, 8)\n        self.check(\"char x; int :0; int :0; char y;\", 4, 4, 8)\n        self.check(\"char x; long long :0; char y;\", L, 8, L + 8)\n        self.check(\"short x, y; int :0; int :0;\", 2, 4, 4)\n        self.check(\"char x; int :0; short b:1; char y;\", 5, 4, 8)\n        self.check(\"int a:1; int :0; int b:1; char y;\", 5, 4, 8)\n\n    def test_error_cases(self):\n        ffi = FFI()\n        py.test.raises(TypeError,\n            'ffi.cdef(\"struct s1 { float x:1; };\"); ffi.new(\"struct s1 *\")')\n        py.test.raises(TypeError,\n            'ffi.cdef(\"struct s2 { char x:0; };\"); ffi.new(\"struct s2 *\")')\n        py.test.raises(TypeError,\n            'ffi.cdef(\"struct s3 { char x:9; };\"); ffi.new(\"struct s3 *\")')\n\n    def test_struct_with_typedef(self):\n        ffi = FFI()\n        ffi.cdef(\"typedef struct { float x; } foo_t;\")\n        p = ffi.new(\"foo_t *\", [5.2])\n        assert repr(p).startswith(\"<cdata 'foo_t *' \")\n\n    def test_struct_array_no_length(self):\n        ffi = FFI()\n        ffi.cdef(\"struct foo_s { int x; int a[]; };\")\n        p = ffi.new(\"struct foo_s *\", [100, [200, 300, 400]])\n        assert p.x == 100\n        assert ffi.typeof(p.a) is ffi.typeof(\"int *\")   # no length available\n        assert p.a[0] == 200\n        assert p.a[1] == 300\n        assert p.a[2] == 400\n\n    @pytest.mark.skipif(\"sys.platform != 'win32'\")\n    def test_getwinerror(self):\n        ffi = FFI()\n        code, message = ffi.getwinerror(1155)\n        assert code == 1155\n        assert message == (\"No application is associated with the \"\n                           \"specified file for this operation\")\n        ffi.cdef(\"void SetLastError(int);\")\n        lib = ffi.dlopen(\"Kernel32.dll\")\n        lib.SetLastError(2)\n        code, message = ffi.getwinerror()\n        assert code == 2\n        assert message == \"The system cannot find the file specified\"\n        code, message = ffi.getwinerror(-1)\n        assert code == 2\n        assert message == \"The system cannot find the file specified\"\n\n    def test_from_buffer(self):\n        import array\n        ffi = FFI()\n        a = array.array('H', [10000, 20000, 30000])\n        c = ffi.from_buffer(a)\n        assert ffi.typeof(c) is ffi.typeof(\"char[]\")\n        ffi.cast(\"unsigned short *\", c)[1] += 500\n        assert list(a) == [10000, 20500, 30000]\n\n    def test_all_primitives(self):\n        ffi = FFI()\n        for name in [\n            \"char\",\n            \"short\",\n            \"int\",\n            \"long\",\n            \"long long\",\n            \"signed char\",\n            \"unsigned char\",\n            \"unsigned short\",\n            \"unsigned int\",\n            \"unsigned long\",\n            \"unsigned long long\",\n            \"float\",\n            \"double\",\n            \"long double\",\n            \"wchar_t\",\n            \"_Bool\",\n            \"int8_t\",\n            \"uint8_t\",\n            \"int16_t\",\n            \"uint16_t\",\n            \"int32_t\",\n            \"uint32_t\",\n            \"int64_t\",\n            \"uint64_t\",\n            \"int_least8_t\",\n            \"uint_least8_t\",\n            \"int_least16_t\",\n            \"uint_least16_t\",\n            \"int_least32_t\",\n            \"uint_least32_t\",\n            \"int_least64_t\",\n            \"uint_least64_t\",\n            \"int_fast8_t\",\n            \"uint_fast8_t\",\n            \"int_fast16_t\",\n            \"uint_fast16_t\",\n            \"int_fast32_t\",\n            \"uint_fast32_t\",\n            \"int_fast64_t\",\n            \"uint_fast64_t\",\n            \"intptr_t\",\n            \"uintptr_t\",\n            \"intmax_t\",\n            \"uintmax_t\",\n            \"ptrdiff_t\",\n            \"size_t\",\n            \"ssize_t\",\n            ]:\n            x = ffi.sizeof(name)\n            assert 1 <= x <= 16\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.1.2-nak3eqkxfunb4z5owzsqogchnaejp7o4/spack-src/testing/cffi0/test_ownlib.py": "import py, sys\nimport subprocess, weakref\nfrom cffi import FFI\nfrom cffi.backend_ctypes import CTypesBackend\n\n\nSOURCE = \"\"\"\\\n#include <errno.h>\n\n#ifdef _WIN32\n#define EXPORT __declspec(dllexport)\n#else\n#define EXPORT\n#endif\n\nEXPORT int test_getting_errno(void) {\n    errno = 123;\n    return -1;\n}\n\nEXPORT int test_setting_errno(void) {\n    return errno;\n};\n\ntypedef struct {\n    long x;\n    long y;\n} POINT;\n\ntypedef struct {\n    long left;\n    long top;\n    long right;\n    long bottom;\n} RECT;\n\n\nEXPORT int PointInRect(RECT *prc, POINT pt)\n{\n    if (pt.x < prc->left)\n        return 0;\n    if (pt.x > prc->right)\n        return 0;\n    if (pt.y < prc->top)\n        return 0;\n    if (pt.y > prc->bottom)\n        return 0;\n    return 1;\n};\n\nEXPORT long left = 10;\nEXPORT long top = 20;\nEXPORT long right = 30;\nEXPORT long bottom = 40;\n\nEXPORT RECT ReturnRect(int i, RECT ar, RECT* br, POINT cp, RECT dr,\n                        RECT *er, POINT fp, RECT gr)\n{\n    /*Check input */\n    if (ar.left + br->left + dr.left + er->left + gr.left != left * 5)\n    {\n        ar.left = 100;\n        return ar;\n    }\n    if (ar.right + br->right + dr.right + er->right + gr.right != right * 5)\n    {\n        ar.right = 100;\n        return ar;\n    }\n    if (cp.x != fp.x)\n    {\n        ar.left = -100;\n    }\n    if (cp.y != fp.y)\n    {\n        ar.left = -200;\n    }\n    switch(i)\n    {\n    case 0:\n        return ar;\n        break;\n    case 1:\n        return dr;\n        break;\n    case 2:\n        return gr;\n        break;\n\n    }\n    return ar;\n}\n\nEXPORT int my_array[7] = {0, 1, 2, 3, 4, 5, 6};\n\"\"\"\n\nclass TestOwnLib(object):\n    Backend = CTypesBackend\n\n    def setup_class(cls):\n        cls.module = None\n        from testing.udir import udir\n        udir.join('testownlib.c').write(SOURCE)\n        if sys.platform == 'win32':\n            import os\n            # did we already build it?\n            if os.path.exists(str(udir.join('testownlib.dll'))):\n                cls.module = str(udir.join('testownlib.dll'))\n                return\n            # try (not too hard) to find the version used to compile this python\n            # no mingw\n            from distutils.msvc9compiler import get_build_version\n            version = get_build_version()\n            toolskey = \"VS%0.f0COMNTOOLS\" % version\n            toolsdir = os.environ.get(toolskey, None)\n            if toolsdir is None:\n                return\n            productdir = os.path.join(toolsdir, os.pardir, os.pardir, \"VC\")\n            productdir = os.path.abspath(productdir)\n            vcvarsall = os.path.join(productdir, \"vcvarsall.bat\")\n            # 64?\n            arch = 'x86'\n            if sys.maxsize > 2**32:\n                arch = 'amd64'\n            if os.path.isfile(vcvarsall):\n                cmd = '\"%s\" %s' % (vcvarsall, arch) + ' & cl.exe testownlib.c ' \\\n                        ' /LD /Fetestownlib.dll'\n                subprocess.check_call(cmd, cwd = str(udir), shell=True)    \n                cls.module = str(udir.join('testownlib.dll'))\n        else:\n            subprocess.check_call(\n                'gcc testownlib.c -shared -fPIC -o testownlib.so',\n                cwd=str(udir), shell=True)\n            cls.module = str(udir.join('testownlib.so'))\n\n    def test_getting_errno(self):\n        if self.module is None:\n            py.test.skip(\"fix the auto-generation of the tiny test lib\")\n        if sys.platform == 'win32':\n            py.test.skip(\"fails, errno at multiple addresses\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            int test_getting_errno(void);\n        \"\"\")\n        ownlib = ffi.dlopen(self.module)\n        res = ownlib.test_getting_errno()\n        assert res == -1\n        assert ffi.errno == 123\n\n    def test_setting_errno(self):\n        if self.module is None:\n            py.test.skip(\"fix the auto-generation of the tiny test lib\")\n        if sys.platform == 'win32':\n            py.test.skip(\"fails, errno at multiple addresses\")\n        if self.Backend is CTypesBackend and '__pypy__' in sys.modules:\n            py.test.skip(\"XXX errno issue with ctypes on pypy?\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            int test_setting_errno(void);\n        \"\"\")\n        ownlib = ffi.dlopen(self.module)\n        ffi.errno = 42\n        res = ownlib.test_setting_errno()\n        assert res == 42\n        assert ffi.errno == 42\n\n    def test_my_array_7(self):\n        if self.module is None:\n            py.test.skip(\"fix the auto-generation of the tiny test lib\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            int my_array[7];\n        \"\"\")\n        ownlib = ffi.dlopen(self.module)\n        for i in range(7):\n            assert ownlib.my_array[i] == i\n        assert len(ownlib.my_array) == 7\n        if self.Backend is CTypesBackend:\n            py.test.skip(\"not supported by the ctypes backend\")\n        ownlib.my_array = list(range(10, 17))\n        for i in range(7):\n            assert ownlib.my_array[i] == 10 + i\n        ownlib.my_array = list(range(7))\n        for i in range(7):\n            assert ownlib.my_array[i] == i\n\n    def test_my_array_no_length(self):\n        if self.module is None:\n            py.test.skip(\"fix the auto-generation of the tiny test lib\")\n        if self.Backend is CTypesBackend:\n            py.test.skip(\"not supported by the ctypes backend\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            int my_array[];\n        \"\"\")\n        ownlib = ffi.dlopen(self.module)\n        for i in range(7):\n            assert ownlib.my_array[i] == i\n        py.test.raises(TypeError, len, ownlib.my_array)\n        ownlib.my_array = list(range(10, 17))\n        for i in range(7):\n            assert ownlib.my_array[i] == 10 + i\n        ownlib.my_array = list(range(7))\n        for i in range(7):\n            assert ownlib.my_array[i] == i\n\n    def test_keepalive_lib(self):\n        if self.module is None:\n            py.test.skip(\"fix the auto-generation of the tiny test lib\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            int test_getting_errno(void);\n        \"\"\")\n        ownlib = ffi.dlopen(self.module)\n        ffi_r = weakref.ref(ffi)\n        ownlib_r = weakref.ref(ownlib)\n        func = ownlib.test_getting_errno\n        del ffi\n        import gc; gc.collect()       # ownlib stays alive\n        assert ownlib_r() is not None\n        assert ffi_r() is not None    # kept alive by ownlib\n        res = func()\n        assert res == -1\n\n    def test_keepalive_ffi(self):\n        if self.module is None:\n            py.test.skip(\"fix the auto-generation of the tiny test lib\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            int test_getting_errno(void);\n        \"\"\")\n        ownlib = ffi.dlopen(self.module)\n        ffi_r = weakref.ref(ffi)\n        ownlib_r = weakref.ref(ownlib)\n        func = ownlib.test_getting_errno\n        del ownlib\n        import gc; gc.collect()       # ffi stays alive\n        assert ffi_r() is not None\n        assert ownlib_r() is not None # kept alive by ffi\n        res = func()\n        assert res == -1\n        if sys.platform != 'win32':  # else, errno at multiple addresses\n            assert ffi.errno == 123\n\n    def test_struct_by_value(self):\n        if self.module is None:\n            py.test.skip(\"fix the auto-generation of the tiny test lib\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            typedef struct {\n                long x;\n                long y;\n            } POINT;\n\n            typedef struct {\n                long left;\n                long top;\n                long right;\n                long bottom;\n            } RECT;\n            \n            long left, top, right, bottom;\n\n            RECT ReturnRect(int i, RECT ar, RECT* br, POINT cp, RECT dr,\n                        RECT *er, POINT fp, RECT gr);\n        \"\"\")\n        ownlib = ffi.dlopen(self.module)\n\n        rect = ffi.new('RECT[1]')\n        pt = ffi.new('POINT[1]')\n        pt[0].x = 15\n        pt[0].y = 25\n        rect[0].left = ownlib.left\n        rect[0].right = ownlib.right\n        rect[0].top = ownlib.top\n        rect[0].bottom = ownlib.bottom\n        \n        for i in range(4):\n            ret = ownlib.ReturnRect(i, rect[0], rect, pt[0], rect[0],\n                                    rect, pt[0], rect[0])\n            assert ret.left == ownlib.left\n            assert ret.right == ownlib.right\n            assert ret.top == ownlib.top\n            assert ret.bottom == ownlib.bottom\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.1.2-nak3eqkxfunb4z5owzsqogchnaejp7o4/spack-src/testing/cffi0/test_verify.py": "import py, re\nimport sys, os, math, weakref\nfrom cffi import FFI, VerificationError, VerificationMissing, model, FFIError\nfrom testing.support import *\n\n\nlib_m = ['m']\nif sys.platform == 'win32':\n    #there is a small chance this fails on Mingw via environ $CC\n    import distutils.ccompiler\n    if distutils.ccompiler.get_default_compiler() == 'msvc':\n        lib_m = ['msvcrt']\n    pass      # no obvious -Werror equivalent on MSVC\nelse:\n    if (sys.platform == 'darwin' and\n          [int(x) for x in os.uname()[2].split('.')] >= [11, 0, 0]):\n        # assume a standard clang or gcc\n        extra_compile_args = ['-Werror', '-Wall', '-Wextra', '-Wconversion']\n        # special things for clang\n        extra_compile_args.append('-Qunused-arguments')\n    else:\n        # assume a standard gcc\n        extra_compile_args = ['-Werror', '-Wall', '-Wextra', '-Wconversion']\n\n    class FFI(FFI):\n        def verify(self, *args, **kwds):\n            return super(FFI, self).verify(\n                *args, extra_compile_args=extra_compile_args, **kwds)\n\ndef setup_module():\n    import cffi.verifier\n    cffi.verifier.cleanup_tmpdir()\n    #\n    # check that no $ sign is produced in the C file; it used to be the\n    # case that anonymous enums would produce '$enum_$1', which was\n    # used as part of a function name.  GCC accepts such names, but it's\n    # apparently non-standard.\n    _r_comment = re.compile(r\"/\\*.*?\\*/|//.*?$\", re.DOTALL | re.MULTILINE)\n    _r_string = re.compile(r'\\\".*?\\\"')\n    def _write_source_and_check(self, file=None):\n        base_write_source(self, file)\n        if file is None:\n            f = open(self.sourcefilename)\n            data = f.read()\n            f.close()\n            data = _r_comment.sub(' ', data)\n            data = _r_string.sub('\"skipped\"', data)\n            assert '$' not in data\n    base_write_source = cffi.verifier.Verifier._write_source\n    cffi.verifier.Verifier._write_source = _write_source_and_check\n\n\ndef test_module_type():\n    import cffi.verifier\n    ffi = FFI()\n    lib = ffi.verify()\n    if hasattr(lib, '_cffi_python_module'):\n        print('verify got a PYTHON module')\n    if hasattr(lib, '_cffi_generic_module'):\n        print('verify got a GENERIC module')\n    expected_generic = (cffi.verifier._FORCE_GENERIC_ENGINE or\n                        '__pypy__' in sys.builtin_module_names)\n    assert hasattr(lib, '_cffi_python_module') == (not expected_generic)\n    assert hasattr(lib, '_cffi_generic_module') == expected_generic\n\ndef test_missing_function(ffi=None):\n    # uses the FFI hacked above with '-Werror'\n    if ffi is None:\n        ffi = FFI()\n    ffi.cdef(\"void some_completely_unknown_function();\")\n    try:\n        lib = ffi.verify()\n    except (VerificationError, OSError):\n        pass     # expected case: we get a VerificationError\n    else:\n        # but depending on compiler and loader details, maybe\n        # 'lib' could actually be imported but will fail if we\n        # actually try to call the unknown function...  Hard\n        # to test anything more.\n        pass\n\ndef test_missing_function_import_error():\n    # uses the original FFI that just gives a warning during compilation\n    import cffi\n    test_missing_function(ffi=cffi.FFI())\n\ndef test_simple_case():\n    ffi = FFI()\n    ffi.cdef(\"double sin(double x);\")\n    lib = ffi.verify('#include <math.h>', libraries=lib_m)\n    assert lib.sin(1.23) == math.sin(1.23)\n\ndef _Wconversion(cdef, source, **kargs):\n    if sys.platform == 'win32':\n        py.test.skip(\"needs GCC or Clang\")\n    ffi = FFI()\n    ffi.cdef(cdef)\n    py.test.raises(VerificationError, ffi.verify, source, **kargs)\n    extra_compile_args_orig = extra_compile_args[:]\n    extra_compile_args.remove('-Wconversion')\n    try:\n        lib = ffi.verify(source, **kargs)\n    finally:\n        extra_compile_args[:] = extra_compile_args_orig\n    return lib\n\ndef test_Wconversion_unsigned():\n    _Wconversion(\"unsigned foo(void);\",\n                 \"int foo(void) { return -1;}\")\n\ndef test_Wconversion_integer():\n    _Wconversion(\"short foo(void);\",\n                 \"long long foo(void) { return 1<<sizeof(short);}\")\n\ndef test_Wconversion_floating():\n    lib = _Wconversion(\"float sin(double);\",\n                       \"#include <math.h>\", libraries=lib_m)\n    res = lib.sin(1.23)\n    assert res != math.sin(1.23)     # not exact, because of double->float\n    assert abs(res - math.sin(1.23)) < 1E-5\n\ndef test_Wconversion_float2int():\n    _Wconversion(\"int sinf(float);\",\n                 \"#include <math.h>\", libraries=lib_m)\n\ndef test_Wconversion_double2int():\n    _Wconversion(\"int sin(double);\",\n                 \"#include <math.h>\", libraries=lib_m)\n\ndef test_rounding_1():\n    ffi = FFI()\n    ffi.cdef(\"double sinf(float x);\")\n    lib = ffi.verify('#include <math.h>', libraries=lib_m)\n    res = lib.sinf(1.23)\n    assert res != math.sin(1.23)     # not exact, because of double->float\n    assert abs(res - math.sin(1.23)) < 1E-5\n\ndef test_rounding_2():\n    ffi = FFI()\n    ffi.cdef(\"double sin(float x);\")\n    lib = ffi.verify('#include <math.h>', libraries=lib_m)\n    res = lib.sin(1.23)\n    assert res != math.sin(1.23)     # not exact, because of double->float\n    assert abs(res - math.sin(1.23)) < 1E-5\n\ndef test_strlen_exact():\n    ffi = FFI()\n    ffi.cdef(\"size_t strlen(const char *s);\")\n    lib = ffi.verify(\"#include <string.h>\")\n    assert lib.strlen(b\"hi there!\") == 9\n\ndef test_strlen_approximate():\n    lib = _Wconversion(\"int strlen(char *s);\",\n                       \"#include <string.h>\")\n    assert lib.strlen(b\"hi there!\") == 9\n\ndef test_return_approximate():\n    for typename in ['short', 'int', 'long', 'long long']:\n        ffi = FFI()\n        ffi.cdef(\"%s foo(signed char x);\" % typename)\n        lib = ffi.verify(\"signed char foo(signed char x) { return x;}\")\n        assert lib.foo(-128) == -128\n        assert lib.foo(+127) == +127\n\ndef test_strlen_array_of_char():\n    ffi = FFI()\n    ffi.cdef(\"size_t strlen(char[]);\")\n    lib = ffi.verify(\"#include <string.h>\")\n    assert lib.strlen(b\"hello\") == 5\n\ndef test_longdouble():\n    ffi = FFI()\n    ffi.cdef(\"long double sinl(long double x);\")\n    lib = ffi.verify('#include <math.h>', libraries=lib_m)\n    for input in [1.23,\n                  ffi.cast(\"double\", 1.23),\n                  ffi.cast(\"long double\", 1.23)]:\n        x = lib.sinl(input)\n        assert repr(x).startswith(\"<cdata 'long double'\")\n        assert (float(x) - math.sin(1.23)) < 1E-10\n\ndef test_longdouble_precision():\n    # Test that we don't loose any precision of 'long double' when\n    # passing through Python and CFFI.\n    ffi = FFI()\n    ffi.cdef(\"long double step1(long double x);\")\n    SAME_SIZE = ffi.sizeof(\"long double\") == ffi.sizeof(\"double\")\n    lib = ffi.verify(\"\"\"\n        long double step1(long double x)\n        {\n            return 4*x-x*x;\n        }\n    \"\"\")\n    def do(cast_to_double):\n        x = 0.9789\n        for i in range(10000):\n            x = lib.step1(x)\n            if cast_to_double:\n                x = float(x)\n        return float(x)\n\n    more_precise = do(False)\n    less_precise = do(True)\n    if SAME_SIZE:\n        assert more_precise == less_precise\n    else:\n        assert abs(more_precise - less_precise) > 0.1\n        # Check the particular results on Intel\n        import platform\n        if (platform.machine().startswith('i386') or\n            platform.machine().startswith('x86')):\n            assert abs(more_precise - 0.656769) < 0.001\n            assert abs(less_precise - 3.99091) < 0.001\n        else:\n            py.test.skip(\"don't know the very exact precision of 'long double'\")\n\n\nall_primitive_types = model.PrimitiveType.ALL_PRIMITIVE_TYPES\nif sys.platform == 'win32':\n    all_primitive_types = all_primitive_types.copy()\n    del all_primitive_types['ssize_t']\nall_integer_types = sorted(tp for tp in all_primitive_types\n                           if all_primitive_types[tp] == 'i')\nall_float_types = sorted(tp for tp in all_primitive_types\n                            if all_primitive_types[tp] == 'f')\n\ndef all_signed_integer_types(ffi):\n    return [x for x in all_integer_types if int(ffi.cast(x, -1)) < 0]\n\ndef all_unsigned_integer_types(ffi):\n    return [x for x in all_integer_types if int(ffi.cast(x, -1)) > 0]\n\n\ndef test_primitive_category():\n    for typename in all_primitive_types:\n        tp = model.PrimitiveType(typename)\n        C = tp.is_char_type()\n        F = tp.is_float_type()\n        I = tp.is_integer_type()\n        assert C == (typename in ('char', 'wchar_t'))\n        assert F == (typename in ('float', 'double', 'long double'))\n        assert I + F + C == 1      # one and only one of them is true\n\ndef test_all_integer_and_float_types():\n    typenames = []\n    for typename in all_primitive_types:\n        if (all_primitive_types[typename] == 'c' or\n            typename == '_Bool' or typename == 'long double'):\n            pass\n        else:\n            typenames.append(typename)\n    #\n    ffi = FFI()\n    ffi.cdef('\\n'.join([\"%s foo_%s(%s);\" % (tp, tp.replace(' ', '_'), tp)\n                       for tp in typenames]))\n    lib = ffi.verify('\\n'.join([\"%s foo_%s(%s x) { return (%s)(x+1); }\" %\n                                (tp, tp.replace(' ', '_'), tp, tp)\n                                for tp in typenames]))\n    for typename in typenames:\n        foo = getattr(lib, 'foo_%s' % typename.replace(' ', '_'))\n        assert foo(42) == 43\n        if sys.version < '3':\n            assert foo(long(44)) == 45\n        assert foo(ffi.cast(typename, 46)) == 47\n        py.test.raises(TypeError, foo, ffi.NULL)\n        #\n        # check for overflow cases\n        if all_primitive_types[typename] == 'f':\n            continue\n        for value in [-2**80, -2**40, -2**20, -2**10, -2**5, -1,\n                      2**5, 2**10, 2**20, 2**40, 2**80]:\n            overflows = int(ffi.cast(typename, value)) != value\n            if overflows:\n                py.test.raises(OverflowError, foo, value)\n            else:\n                assert foo(value) == value + 1\n\ndef test_var_signed_integer_types():\n    ffi = FFI()\n    lst = all_signed_integer_types(ffi)\n    csource = \"\\n\".join([\"%s somevar_%s;\" % (tp, tp.replace(' ', '_'))\n                         for tp in lst])\n    ffi.cdef(csource)\n    lib = ffi.verify(csource)\n    for tp in lst:\n        varname = 'somevar_%s' % tp.replace(' ', '_')\n        sz = ffi.sizeof(tp)\n        max = (1 << (8*sz-1)) - 1\n        min = -(1 << (8*sz-1))\n        setattr(lib, varname, max)\n        assert getattr(lib, varname) == max\n        setattr(lib, varname, min)\n        assert getattr(lib, varname) == min\n        py.test.raises(OverflowError, setattr, lib, varname, max+1)\n        py.test.raises(OverflowError, setattr, lib, varname, min-1)\n\ndef test_var_unsigned_integer_types():\n    ffi = FFI()\n    lst = all_unsigned_integer_types(ffi)\n    csource = \"\\n\".join([\"%s somevar_%s;\" % (tp, tp.replace(' ', '_'))\n                         for tp in lst])\n    ffi.cdef(csource)\n    lib = ffi.verify(csource)\n    for tp in lst:\n        varname = 'somevar_%s' % tp.replace(' ', '_')\n        sz = ffi.sizeof(tp)\n        if tp != '_Bool':\n            max = (1 << (8*sz)) - 1\n        else:\n            max = 1\n        setattr(lib, varname, max)\n        assert getattr(lib, varname) == max\n        setattr(lib, varname, 0)\n        assert getattr(lib, varname) == 0\n        py.test.raises(OverflowError, setattr, lib, varname, max+1)\n        py.test.raises(OverflowError, setattr, lib, varname, -1)\n\ndef test_fn_signed_integer_types():\n    ffi = FFI()\n    lst = all_signed_integer_types(ffi)\n    cdefsrc = \"\\n\".join([\"%s somefn_%s(%s);\" % (tp, tp.replace(' ', '_'), tp)\n                         for tp in lst])\n    ffi.cdef(cdefsrc)\n    verifysrc = \"\\n\".join([\"%s somefn_%s(%s x) { return x; }\" %\n                           (tp, tp.replace(' ', '_'), tp) for tp in lst])\n    lib = ffi.verify(verifysrc)\n    for tp in lst:\n        fnname = 'somefn_%s' % tp.replace(' ', '_')\n        sz = ffi.sizeof(tp)\n        max = (1 << (8*sz-1)) - 1\n        min = -(1 << (8*sz-1))\n        fn = getattr(lib, fnname)\n        assert fn(max) == max\n        assert fn(min) == min\n        py.test.raises(OverflowError, fn, max + 1)\n        py.test.raises(OverflowError, fn, min - 1)\n\ndef test_fn_unsigned_integer_types():\n    ffi = FFI()\n    lst = all_unsigned_integer_types(ffi)\n    cdefsrc = \"\\n\".join([\"%s somefn_%s(%s);\" % (tp, tp.replace(' ', '_'), tp)\n                         for tp in lst])\n    ffi.cdef(cdefsrc)\n    verifysrc = \"\\n\".join([\"%s somefn_%s(%s x) { return x; }\" %\n                           (tp, tp.replace(' ', '_'), tp) for tp in lst])\n    lib = ffi.verify(verifysrc)\n    for tp in lst:\n        fnname = 'somefn_%s' % tp.replace(' ', '_')\n        sz = ffi.sizeof(tp)\n        if tp != '_Bool':\n            max = (1 << (8*sz)) - 1\n        else:\n            max = 1\n        fn = getattr(lib, fnname)\n        assert fn(max) == max\n        assert fn(0) == 0\n        py.test.raises(OverflowError, fn, max + 1)\n        py.test.raises(OverflowError, fn, -1)\n\ndef test_char_type():\n    ffi = FFI()\n    ffi.cdef(\"char foo(char);\")\n    lib = ffi.verify(\"char foo(char x) { return ++x; }\")\n    assert lib.foo(b\"A\") == b\"B\"\n    py.test.raises(TypeError, lib.foo, b\"bar\")\n    py.test.raises(TypeError, lib.foo, \"bar\")\n\ndef test_wchar_type():\n    ffi = FFI()\n    if ffi.sizeof('wchar_t') == 2:\n        uniexample1 = u+'\\u1234'\n        uniexample2 = u+'\\u1235'\n    else:\n        uniexample1 = u+'\\U00012345'\n        uniexample2 = u+'\\U00012346'\n    #\n    ffi.cdef(\"wchar_t foo(wchar_t);\")\n    lib = ffi.verify(\"wchar_t foo(wchar_t x) { return x+1; }\")\n    assert lib.foo(uniexample1) == uniexample2\n\ndef test_no_argument():\n    ffi = FFI()\n    ffi.cdef(\"int foo(void);\")\n    lib = ffi.verify(\"int foo(void) { return 42; }\")\n    assert lib.foo() == 42\n\ndef test_two_arguments():\n    ffi = FFI()\n    ffi.cdef(\"int foo(int, int);\")\n    lib = ffi.verify(\"int foo(int a, int b) { return a - b; }\")\n    assert lib.foo(40, -2) == 42\n\ndef test_macro():\n    ffi = FFI()\n    ffi.cdef(\"int foo(int, int);\")\n    lib = ffi.verify(\"#define foo(a, b) ((a) * (b))\")\n    assert lib.foo(-6, -7) == 42\n\ndef test_ptr():\n    ffi = FFI()\n    ffi.cdef(\"int *foo(int *);\")\n    lib = ffi.verify(\"int *foo(int *a) { return a; }\")\n    assert lib.foo(ffi.NULL) == ffi.NULL\n    p = ffi.new(\"int *\", 42)\n    q = ffi.new(\"int *\", 42)\n    assert lib.foo(p) == p\n    assert lib.foo(q) != p\n\ndef test_bogus_ptr():\n    ffi = FFI()\n    ffi.cdef(\"int *foo(int *);\")\n    lib = ffi.verify(\"int *foo(int *a) { return a; }\")\n    py.test.raises(TypeError, lib.foo, ffi.new(\"short *\", 42))\n\n\ndef test_verify_typedefs():\n    py.test.skip(\"ignored so far\")\n    types = ['signed char', 'unsigned char', 'int', 'long']\n    for cdefed in types:\n        for real in types:\n            ffi = FFI()\n            ffi.cdef(\"typedef %s foo_t;\" % cdefed)\n            if cdefed == real:\n                ffi.verify(\"typedef %s foo_t;\" % real)\n            else:\n                py.test.raises(VerificationError, ffi.verify,\n                               \"typedef %s foo_t;\" % real)\n\ndef test_nondecl_struct():\n    ffi = FFI()\n    ffi.cdef(\"typedef struct foo_s foo_t; int bar(foo_t *);\")\n    lib = ffi.verify(\"typedef struct foo_s foo_t;\\n\"\n                     \"int bar(foo_t *f) { (void)f; return 42; }\\n\")\n    assert lib.bar(ffi.NULL) == 42\n\ndef test_ffi_full_struct():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { char x; int y; long *z; };\")\n    ffi.verify(\"struct foo_s { char x; int y; long *z; };\")\n    #\n    if sys.platform != 'win32':  # XXX fixme: only gives warnings\n        py.test.raises(VerificationError, ffi.verify,\n            \"struct foo_s { char x; int y; int *z; };\")\n    #\n    py.test.raises(VerificationError, ffi.verify,\n        \"struct foo_s { int y; long *z; };\")\n    #\n    e = py.test.raises(VerificationError, ffi.verify,\n        \"struct foo_s { int y; char x; long *z; };\")\n    assert str(e.value) == (\n        \"struct foo_s: wrong offset for field 'x'\"\n        \" (we have 0, but C compiler says 4)\")\n    #\n    e = py.test.raises(VerificationError, ffi.verify,\n        \"struct foo_s { char x; int y; long *z; char extra; };\")\n    assert str(e.value) == (\n        \"struct foo_s: wrong total size\"\n        \" (we have %d, but C compiler says %d)\" % (\n            ffi.sizeof(\"struct foo_s\"),\n            ffi.sizeof(\"struct foo_s\") + ffi.sizeof(\"long*\")))\n    #\n    # a corner case that we cannot really detect, but where it has no\n    # bad consequences: the size is the same, but there is an extra field\n    # that replaces what is just padding in our declaration above\n    ffi.verify(\"struct foo_s { char x, extra; int y; long *z; };\")\n    #\n    e = py.test.raises(VerificationError, ffi.verify,\n        \"struct foo_s { char x; short pad; short y; long *z; };\")\n    assert str(e.value) == (\n        \"struct foo_s: wrong size for field 'y'\"\n        \" (we have 4, but C compiler says 2)\")\n\ndef test_ffi_nonfull_struct():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n    struct foo_s {\n       int x;\n       ...;\n    };\n    \"\"\")\n    py.test.raises(VerificationMissing, ffi.sizeof, 'struct foo_s')\n    py.test.raises(VerificationMissing, ffi.offsetof, 'struct foo_s', 'x')\n    py.test.raises(VerificationMissing, ffi.new, 'struct foo_s *')\n    ffi.verify(\"\"\"\n    struct foo_s {\n       int a, b, x, c, d, e;\n    };\n    \"\"\")\n    assert ffi.sizeof('struct foo_s') == 6 * ffi.sizeof('int')\n    assert ffi.offsetof('struct foo_s', 'x') == 2 * ffi.sizeof('int')\n\ndef test_ffi_nonfull_alignment():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { char x; ...; };\")\n    ffi.verify(\"struct foo_s { int a, b; char x; };\")\n    assert ffi.sizeof('struct foo_s') == 3 * ffi.sizeof('int')\n    assert ffi.alignof('struct foo_s') == ffi.sizeof('int')\n\ndef _check_field_match(typename, real, expect_mismatch):\n    ffi = FFI()\n    testing_by_size = (expect_mismatch == 'by_size')\n    if testing_by_size:\n        expect_mismatch = ffi.sizeof(typename) != ffi.sizeof(real)\n    ffi.cdef(\"struct foo_s { %s x; ...; };\" % typename)\n    try:\n        ffi.verify(\"struct foo_s { %s x; };\" % real)\n    except VerificationError:\n        if not expect_mismatch:\n            if testing_by_size and typename != real:\n                print(\"ignoring mismatch between %s* and %s* even though \"\n                      \"they have the same size\" % (typename, real))\n                return\n            raise AssertionError(\"unexpected mismatch: %s should be accepted \"\n                                 \"as equal to %s\" % (typename, real))\n    else:\n        if expect_mismatch:\n            raise AssertionError(\"mismatch not detected: \"\n                                 \"%s != %s\" % (typename, real))\n\ndef test_struct_bad_sized_integer():\n    for typename in ['int8_t', 'int16_t', 'int32_t', 'int64_t']:\n        for real in ['int8_t', 'int16_t', 'int32_t', 'int64_t']:\n            _check_field_match(typename, real, \"by_size\")\n\ndef test_struct_bad_sized_float():\n    for typename in all_float_types:\n        for real in all_float_types:\n            _check_field_match(typename, real, \"by_size\")\n\ndef test_struct_signedness_ignored():\n    _check_field_match(\"int\", \"unsigned int\", expect_mismatch=False)\n    _check_field_match(\"unsigned short\", \"signed short\", expect_mismatch=False)\n\ndef test_struct_float_vs_int():\n    if sys.platform == 'win32':\n        py.test.skip(\"XXX fixme: only gives warnings\")\n    ffi = FFI()\n    for typename in all_signed_integer_types(ffi):\n        for real in all_float_types:\n            _check_field_match(typename, real, expect_mismatch=True)\n    for typename in all_float_types:\n        for real in all_signed_integer_types(ffi):\n            _check_field_match(typename, real, expect_mismatch=True)\n\ndef test_struct_array_field():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int a[17]; ...; };\")\n    ffi.verify(\"struct foo_s { int x; int a[17]; int y; };\")\n    assert ffi.sizeof('struct foo_s') == 19 * ffi.sizeof('int')\n    s = ffi.new(\"struct foo_s *\")\n    assert ffi.sizeof(s.a) == 17 * ffi.sizeof('int')\n\ndef test_struct_array_no_length():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int a[]; int y; ...; };\\n\"\n             \"int bar(struct foo_s *);\\n\")\n    lib = ffi.verify(\"struct foo_s { int x; int a[17]; int y; };\\n\"\n                     \"int bar(struct foo_s *f) { return f->a[14]; }\\n\")\n    assert ffi.sizeof('struct foo_s') == 19 * ffi.sizeof('int')\n    s = ffi.new(\"struct foo_s *\")\n    assert ffi.typeof(s.a) is ffi.typeof('int *')   # because no length\n    s.a[14] = 4242\n    assert lib.bar(s) == 4242\n    # with no declared length, out-of-bound accesses are not detected\n    s.a[17] = -521\n    assert s.y == s.a[17] == -521\n    #\n    s = ffi.new(\"struct foo_s *\", {'a': list(range(17))})\n    assert s.a[16] == 16\n    # overflows at construction time not detected either\n    s = ffi.new(\"struct foo_s *\", {'a': list(range(18))})\n    assert s.y == s.a[17] == 17\n\ndef test_struct_array_guess_length():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int a[...]; };\")\n    ffi.verify(\"struct foo_s { int x; int a[17]; int y; };\")\n    assert ffi.sizeof('struct foo_s') == 19 * ffi.sizeof('int')\n    s = ffi.new(\"struct foo_s *\")\n    assert ffi.sizeof(s.a) == 17 * ffi.sizeof('int')\n    py.test.raises(IndexError, 's.a[17]')\n\ndef test_struct_array_c99_1():\n    if sys.platform == 'win32':\n        py.test.skip(\"requires C99\")\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int x; int a[]; };\")\n    ffi.verify(\"struct foo_s { int x; int a[]; };\")\n    assert ffi.sizeof('struct foo_s') == 1 * ffi.sizeof('int')\n    s = ffi.new(\"struct foo_s *\", [424242, 4])\n    assert ffi.sizeof(s[0]) == 1 * ffi.sizeof('int')   # the same in C\n    assert s.a[3] == 0\n    s = ffi.new(\"struct foo_s *\", [424242, [-40, -30, -20, -10]])\n    assert ffi.sizeof(s[0]) == 1 * ffi.sizeof('int')\n    assert s.a[3] == -10\n    s = ffi.new(\"struct foo_s *\")\n    assert ffi.sizeof(s[0]) == 1 * ffi.sizeof('int')\n    s = ffi.new(\"struct foo_s *\", [424242])\n    assert ffi.sizeof(s[0]) == 1 * ffi.sizeof('int')\n\ndef test_struct_array_c99_2():\n    if sys.platform == 'win32':\n        py.test.skip(\"requires C99\")\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int x; int a[]; ...; };\")\n    ffi.verify(\"struct foo_s { int x, y; int a[]; };\")\n    assert ffi.sizeof('struct foo_s') == 2 * ffi.sizeof('int')\n    s = ffi.new(\"struct foo_s *\", [424242, 4])\n    assert ffi.sizeof(s[0]) == 2 * ffi.sizeof('int')\n    assert s.a[3] == 0\n    s = ffi.new(\"struct foo_s *\", [424242, [-40, -30, -20, -10]])\n    assert ffi.sizeof(s[0]) == 2 * ffi.sizeof('int')\n    assert s.a[3] == -10\n    s = ffi.new(\"struct foo_s *\")\n    assert ffi.sizeof(s[0]) == 2 * ffi.sizeof('int')\n    s = ffi.new(\"struct foo_s *\", [424242])\n    assert ffi.sizeof(s[0]) == 2 * ffi.sizeof('int')\n\ndef test_struct_ptr_to_array_field():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int (*a)[17]; ...; }; struct bar_s { ...; };\")\n    ffi.verify(\"struct foo_s { int x; int (*a)[17]; int y; };\\n\"\n               \"struct bar_s { int x; int *a; int y; };\")\n    assert ffi.sizeof('struct foo_s') == ffi.sizeof(\"struct bar_s\")\n    s = ffi.new(\"struct foo_s *\")\n    assert ffi.sizeof(s.a) == ffi.sizeof('int(*)[17]') == ffi.sizeof(\"int *\")\n\ndef test_struct_with_bitfield_exact():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int a:2, b:3; };\")\n    ffi.verify(\"struct foo_s { int a:2, b:3; };\")\n    s = ffi.new(\"struct foo_s *\")\n    s.b = 3\n    py.test.raises(OverflowError, \"s.b = 4\")\n    assert s.b == 3\n\ndef test_struct_with_bitfield_enum():\n    ffi = FFI()\n    code = \"\"\"\n        typedef enum { AA, BB, CC } foo_e;\n        typedef struct { foo_e f:2; } foo_s;\n    \"\"\"\n    ffi.cdef(code)\n    ffi.verify(code)\n    s = ffi.new(\"foo_s *\")\n    s.f = 2\n    assert s.f == 2\n\ndef test_unsupported_struct_with_bitfield_ellipsis():\n    ffi = FFI()\n    py.test.raises(NotImplementedError, ffi.cdef,\n                   \"struct foo_s { int a:2, b:3; ...; };\")\n\ndef test_global_constants():\n    ffi = FFI()\n    # use 'static const int', as generally documented, although in this\n    # case the 'static' is completely ignored.\n    ffi.cdef(\"static const int AA, BB, CC, DD;\")\n    lib = ffi.verify(\"#define AA 42\\n\"\n                     \"#define BB (-43)   // blah\\n\"\n                     \"#define CC (22*2)  /* foobar */\\n\"\n                     \"#define DD ((unsigned int)142)  /* foo\\nbar */\\n\")\n    assert lib.AA == 42\n    assert lib.BB == -43\n    assert lib.CC == 44\n    assert lib.DD == 142\n\ndef test_global_const_int_size():\n    # integer constants: ignore the declared type, always just use the value\n    for value in [-2**63, -2**31, -2**15,\n                  2**15-1, 2**15, 2**31-1, 2**31, 2**32-1, 2**32,\n                  2**63-1, 2**63, 2**64-1]:\n        ffi = FFI()\n        if value == int(ffi.cast(\"long long\", value)):\n            if value < 0:\n                vstr = '(-%dLL-1)' % (~value,)\n            else:\n                vstr = '%dLL' % value\n        elif value == int(ffi.cast(\"unsigned long long\", value)):\n            vstr = '%dULL' % value\n        else:\n            raise AssertionError(value)\n        ffi.cdef(\"static const unsigned short AA;\")\n        lib = ffi.verify(\"#define AA %s\\n\" % vstr)\n        assert lib.AA == value\n        assert type(lib.AA) is type(int(lib.AA))\n\ndef test_global_constants_non_int():\n    ffi = FFI()\n    ffi.cdef(\"static char *const PP;\")\n    lib = ffi.verify('static char *const PP = \"testing!\";\\n')\n    assert ffi.typeof(lib.PP) == ffi.typeof(\"char *\")\n    assert ffi.string(lib.PP) == b\"testing!\"\n\ndef test_nonfull_enum():\n    ffi = FFI()\n    ffi.cdef(\"enum ee { EE1, EE2, EE3, ... \\n \\t };\")\n    py.test.raises(VerificationMissing, ffi.cast, 'enum ee', 'EE2')\n    ffi.verify(\"enum ee { EE1=10, EE2, EE3=-10, EE4 };\")\n    assert ffi.string(ffi.cast('enum ee', 11)) == \"EE2\"\n    assert ffi.string(ffi.cast('enum ee', -10)) == \"EE3\"\n    #\n    # try again\n    ffi.verify(\"enum ee { EE1=10, EE2, EE3=-10, EE4 };\")\n    assert ffi.string(ffi.cast('enum ee', 11)) == \"EE2\"\n    #\n    assert ffi.typeof(\"enum ee\").relements == {'EE1': 10, 'EE2': 11, 'EE3': -10}\n    assert ffi.typeof(\"enum ee\").elements == {10: 'EE1', 11: 'EE2', -10: 'EE3'}\n\ndef test_full_enum():\n    ffi = FFI()\n    ffi.cdef(\"enum ee { EE1, EE2, EE3 };\")\n    ffi.verify(\"enum ee { EE1, EE2, EE3 };\")\n    py.test.raises(VerificationError, ffi.verify, \"enum ee { EE1, EE2 };\")\n    e = py.test.raises(VerificationError, ffi.verify,\n                       \"enum ee { EE1, EE3, EE2 };\")\n    assert str(e.value) == 'enum ee: EE2 has the real value 2, not 1'\n    # extra items cannot be seen and have no bad consequence anyway\n    lib = ffi.verify(\"enum ee { EE1, EE2, EE3, EE4 };\")\n    assert lib.EE3 == 2\n\ndef test_enum_usage():\n    ffi = FFI()\n    ffi.cdef(\"enum ee { EE1,EE2 }; typedef struct { enum ee x; } *sp;\")\n    lib = ffi.verify(\"enum ee { EE1,EE2 }; typedef struct { enum ee x; } *sp;\")\n    assert lib.EE2 == 1\n    s = ffi.new(\"sp\", [lib.EE2])\n    assert s.x == 1\n    s.x = 17\n    assert s.x == 17\n\ndef test_anonymous_enum():\n    ffi = FFI()\n    ffi.cdef(\"enum { EE1 }; enum { EE2, EE3 };\")\n    lib = ffi.verify(\"enum { EE1 }; enum { EE2, EE3 };\")\n    assert lib.EE1 == 0\n    assert lib.EE2 == 0\n    assert lib.EE3 == 1\n\ndef test_nonfull_anonymous_enum():\n    ffi = FFI()\n    ffi.cdef(\"enum { EE1, ... }; enum { EE3, ... };\")\n    lib = ffi.verify(\"enum { EE2, EE1 }; enum { EE3 };\")\n    assert lib.EE1 == 1\n    assert lib.EE3 == 0\n\ndef test_nonfull_enum_syntax2():\n    ffi = FFI()\n    ffi.cdef(\"enum ee { EE1, EE2=\\t..., EE3 };\")\n    py.test.raises(VerificationMissing, ffi.cast, 'enum ee', 'EE1')\n    ffi.verify(\"enum ee { EE1=10, EE2, EE3=-10, EE4 };\")\n    assert ffi.string(ffi.cast('enum ee', 11)) == 'EE2'\n    assert ffi.string(ffi.cast('enum ee', -10)) == 'EE3'\n    #\n    ffi = FFI()\n    ffi.cdef(\"enum ee { EE1, EE2=\\t... };\")\n    py.test.raises(VerificationMissing, ffi.cast, 'enum ee', 'EE1')\n    ffi.verify(\"enum ee { EE1=10, EE2, EE3=-10, EE4 };\")\n    assert ffi.string(ffi.cast('enum ee', 11)) == 'EE2'\n    #\n    ffi = FFI()\n    ffi.cdef(\"enum ee2 { EE4=..., EE5=..., ... };\")\n    ffi.verify(\"enum ee2 { EE4=-1234-5, EE5 }; \")\n    assert ffi.string(ffi.cast('enum ee2', -1239)) == 'EE4'\n    assert ffi.string(ffi.cast('enum ee2', -1238)) == 'EE5'\n\ndef test_nonfull_enum_bug3():\n    ffi = FFI()\n    ffi.cdef(\"enum ee2 { EE4=..., EE5=... };\")\n    ffi.cdef(\"enum ee6 { EE7=10, EE8=..., EE9=... };\")\n\ndef test_get_set_errno():\n    ffi = FFI()\n    ffi.cdef(\"int foo(int);\")\n    lib = ffi.verify(\"\"\"\n        static int foo(int x)\n        {\n            errno += 1;\n            return x * 7;\n        }\n    \"\"\")\n    ffi.errno = 15\n    assert lib.foo(6) == 42\n    assert ffi.errno == 16\n\ndef test_define_int():\n    ffi = FFI()\n    ffi.cdef(\"#define FOO ...\\n\"\n             \"\\t#\\tdefine\\tBAR\\t...\\t\\n\"\n             \"#define BAZ ...\\n\")\n    lib = ffi.verify(\"#define FOO 42\\n\"\n                     \"#define BAR (-44)\\n\"\n                     \"#define BAZ 0xffffffffffffffffULL\\n\")\n    assert lib.FOO == 42\n    assert lib.BAR == -44\n    assert lib.BAZ == 0xffffffffffffffff\n\ndef test_access_variable():\n    ffi = FFI()\n    ffi.cdef(\"int foo(void);\\n\"\n             \"int somenumber;\")\n    lib = ffi.verify(\"\"\"\n        static int somenumber = 2;\n        static int foo(void) {\n            return somenumber * 7;\n        }\n    \"\"\")\n    assert lib.somenumber == 2\n    assert lib.foo() == 14\n    lib.somenumber = -6\n    assert lib.foo() == -42\n    assert lib.somenumber == -6\n    lib.somenumber = 2   # reset for the next run, if any\n\ndef test_access_address_of_variable():\n    # access the address of 'somenumber': need a trick\n    ffi = FFI()\n    ffi.cdef(\"int somenumber; static int *const somenumberptr;\")\n    lib = ffi.verify(\"\"\"\n        static int somenumber = 2;\n        #define somenumberptr (&somenumber)\n    \"\"\")\n    assert lib.somenumber == 2\n    lib.somenumberptr[0] = 42\n    assert lib.somenumber == 42\n    lib.somenumber = 2    # reset for the next run, if any\n\ndef test_access_array_variable(length=5):\n    ffi = FFI()\n    ffi.cdef(\"int foo(int);\\n\"\n             \"int somenumber[%s];\" % (length,))\n    lib = ffi.verify(\"\"\"\n        static int somenumber[] = {2, 2, 3, 4, 5};\n        static int foo(int i) {\n            return somenumber[i] * 7;\n        }\n    \"\"\")\n    if length == '':\n        # a global variable of an unknown array length is implicitly\n        # transformed into a global pointer variable, because we can only\n        # work with array instances whose length we know.  using a pointer\n        # instead of an array gives the correct effects.\n        assert repr(lib.somenumber).startswith(\"<cdata 'int *' 0x\")\n        py.test.raises(TypeError, len, lib.somenumber)\n    else:\n        assert repr(lib.somenumber).startswith(\"<cdata 'int[%s]' 0x\" % length)\n        assert len(lib.somenumber) == 5\n    assert lib.somenumber[3] == 4\n    assert lib.foo(3) == 28\n    lib.somenumber[3] = -6\n    assert lib.foo(3) == -42\n    assert lib.somenumber[3] == -6\n    assert lib.somenumber[4] == 5\n    lib.somenumber[3] = 4    # reset for the next run, if any\n\ndef test_access_array_variable_length_hidden():\n    test_access_array_variable(length='')\n\ndef test_access_struct_variable():\n    ffi = FFI()\n    ffi.cdef(\"struct foo { int x; ...; };\\n\"\n             \"int foo(int);\\n\"\n             \"struct foo stuff;\")\n    lib = ffi.verify(\"\"\"\n        struct foo { int x, y, z; };\n        static struct foo stuff = {2, 5, 8};\n        static int foo(int i) {\n            switch (i) {\n            case 0: return stuff.x * 7;\n            case 1: return stuff.y * 7;\n            case 2: return stuff.z * 7;\n            }\n            return -1;\n        }\n    \"\"\")\n    assert lib.stuff.x == 2\n    assert lib.foo(0) == 14\n    assert lib.foo(1) == 35\n    assert lib.foo(2) == 56\n    lib.stuff.x = -6\n    assert lib.foo(0) == -42\n    assert lib.foo(1) == 35\n    lib.stuff.x = 2      # reset for the next run, if any\n\ndef test_access_callback():\n    ffi = FFI()\n    ffi.cdef(\"int (*cb)(int);\\n\"\n             \"int foo(int);\\n\"\n             \"void reset_cb(void);\")\n    lib = ffi.verify(\"\"\"\n        static int g(int x) { return x * 7; }\n        static int (*cb)(int);\n        static int foo(int i) { return cb(i) - 1; }\n        static void reset_cb(void) { cb = g; }\n    \"\"\")\n    lib.reset_cb()\n    assert lib.foo(6) == 41\n    my_callback = ffi.callback(\"int(*)(int)\", lambda n: n * 222)\n    lib.cb = my_callback\n    assert lib.foo(4) == 887\n\ndef test_access_callback_function_typedef():\n    ffi = FFI()\n    ffi.cdef(\"typedef int mycallback_t(int);\\n\"\n             \"mycallback_t *cb;\\n\"\n             \"int foo(int);\\n\"\n             \"void reset_cb(void);\")\n    lib = ffi.verify(\"\"\"\n        static int g(int x) { return x * 7; }\n        static int (*cb)(int);\n        static int foo(int i) { return cb(i) - 1; }\n        static void reset_cb(void) { cb = g; }\n    \"\"\")\n    lib.reset_cb()\n    assert lib.foo(6) == 41\n    my_callback = ffi.callback(\"int(*)(int)\", lambda n: n * 222)\n    lib.cb = my_callback\n    assert lib.foo(4) == 887\n\ndef test_ctypes_backend_forces_generic_engine():\n    from cffi.backend_ctypes import CTypesBackend\n    ffi = FFI(backend=CTypesBackend())\n    ffi.cdef(\"int func(int a);\")\n    lib = ffi.verify(\"int func(int a) { return a * 42; }\")\n    assert not hasattr(lib, '_cffi_python_module')\n    assert hasattr(lib, '_cffi_generic_module')\n    assert lib.func(100) == 4200\n\ndef test_call_with_struct_ptr():\n    ffi = FFI()\n    ffi.cdef(\"typedef struct { int x; ...; } foo_t; int foo(foo_t *);\")\n    lib = ffi.verify(\"\"\"\n        typedef struct { int y, x; } foo_t;\n        static int foo(foo_t *f) { return f->x * 7; }\n    \"\"\")\n    f = ffi.new(\"foo_t *\")\n    f.x = 6\n    assert lib.foo(f) == 42\n\ndef test_unknown_type():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef ... token_t;\n        int foo(token_t *);\n        #define TOKEN_SIZE ...\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        typedef float token_t;\n        static int foo(token_t *tk) {\n            if (!tk)\n                return -42;\n            *tk += 1.601f;\n            return (int)*tk;\n        }\n        #define TOKEN_SIZE sizeof(token_t)\n    \"\"\")\n    # we cannot let ffi.new(\"token_t *\") work, because we don't know ahead of\n    # time if it's ok to ask 'sizeof(token_t)' in the C code or not.\n    # See test_unknown_type_2.  Workaround.\n    tkmem = ffi.new(\"char[]\", lib.TOKEN_SIZE)    # zero-initialized\n    tk = ffi.cast(\"token_t *\", tkmem)\n    results = [lib.foo(tk) for i in range(6)]\n    assert results == [1, 3, 4, 6, 8, 9]\n    assert lib.foo(ffi.NULL) == -42\n\ndef test_unknown_type_2():\n    ffi = FFI()\n    ffi.cdef(\"typedef ... token_t;\")\n    lib = ffi.verify(\"typedef struct token_s token_t;\")\n    # assert did not crash, even though 'sizeof(token_t)' is not valid in C.\n\ndef test_unknown_type_3():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef ... *token_p;\n        token_p foo(token_p);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        typedef struct _token_s *token_p;\n        token_p foo(token_p arg) {\n            if (arg)\n                return (token_p)0x12347;\n            else\n                return (token_p)0x12345;\n        }\n    \"\"\")\n    p = lib.foo(ffi.NULL)\n    assert int(ffi.cast(\"intptr_t\", p)) == 0x12345\n    q = lib.foo(p)\n    assert int(ffi.cast(\"intptr_t\", q)) == 0x12347\n\ndef test_varargs():\n    ffi = FFI()\n    ffi.cdef(\"int foo(int x, ...);\")\n    lib = ffi.verify(\"\"\"\n        int foo(int x, ...) {\n            va_list vargs;\n            va_start(vargs, x);\n            x -= va_arg(vargs, int);\n            x -= va_arg(vargs, int);\n            va_end(vargs);\n            return x;\n        }\n    \"\"\")\n    assert lib.foo(50, ffi.cast(\"int\", 5), ffi.cast(\"int\", 3)) == 42\n\ndef test_varargs_exact():\n    if sys.platform == 'win32':\n        py.test.skip(\"XXX fixme: only gives warnings\")\n    ffi = FFI()\n    ffi.cdef(\"int foo(int x, ...);\")\n    py.test.raises(VerificationError, ffi.verify, \"\"\"\n        int foo(long long x, ...) {\n            return x;\n        }\n    \"\"\")\n\ndef test_varargs_struct():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { char a; int b; }; int foo(int x, ...);\")\n    lib = ffi.verify(\"\"\"\n        struct foo_s {\n            char a; int b;\n        };\n        int foo(int x, ...) {\n            va_list vargs;\n            struct foo_s s;\n            va_start(vargs, x);\n            s = va_arg(vargs, struct foo_s);\n            va_end(vargs);\n            return s.a - s.b;\n        }\n    \"\"\")\n    s = ffi.new(\"struct foo_s *\", [b'B', 1])\n    assert lib.foo(50, s[0]) == ord('A')\n\ndef test_autofilled_struct_as_argument():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { long a; double b; ...; };\\n\"\n             \"int foo(struct foo_s);\")\n    lib = ffi.verify(\"\"\"\n        struct foo_s {\n            double b;\n            long a;\n        };\n        int foo(struct foo_s s) {\n            return (int)s.a - (int)s.b;\n        }\n    \"\"\")\n    s = ffi.new(\"struct foo_s *\", [100, 1])\n    assert lib.foo(s[0]) == 99\n    assert lib.foo([100, 1]) == 99\n\ndef test_autofilled_struct_as_argument_dynamic():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { long a; ...; };\\n\"\n             \"int (*foo)(struct foo_s);\")\n    lib = ffi.verify(\"\"\"\n        struct foo_s {\n            double b;\n            long a;\n        };\n        int foo1(struct foo_s s) {\n            return (int)s.a - (int)s.b;\n        }\n        int (*foo)(struct foo_s s) = &foo1;\n    \"\"\")\n    e = py.test.raises(NotImplementedError, lib.foo, \"?\")\n    msg = (\"ctype 'struct foo_s' not supported as argument (it is a struct \"\n           'declared with \"...;\", but the C calling convention may depend '\n           'on the missing fields)')\n    assert str(e.value) == msg\n\ndef test_func_returns_struct():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        struct foo_s { int aa, bb; };\n        struct foo_s foo(int a, int b);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        struct foo_s { int aa, bb; };\n        struct foo_s foo(int a, int b) {\n            struct foo_s r;\n            r.aa = a*a;\n            r.bb = b*b;\n            return r;\n        }\n    \"\"\")\n    s = lib.foo(6, 7)\n    assert repr(s) == \"<cdata 'struct foo_s' owning 8 bytes>\"\n    assert s.aa == 36\n    assert s.bb == 49\n\ndef test_func_as_funcptr():\n    ffi = FFI()\n    ffi.cdef(\"int *(*const fooptr)(void);\")\n    lib = ffi.verify(\"\"\"\n        int *foo(void) {\n            return (int*)\"foobar\";\n        }\n        int *(*fooptr)(void) = foo;\n    \"\"\")\n    foochar = ffi.cast(\"char *(*)(void)\", lib.fooptr)\n    s = foochar()\n    assert ffi.string(s) == b\"foobar\"\n\ndef test_funcptr_as_argument():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        void qsort(void *base, size_t nel, size_t width,\n            int (*compar)(const void *, const void *));\n    \"\"\")\n    ffi.verify(\"#include <stdlib.h>\")\n\ndef test_func_as_argument():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        void qsort(void *base, size_t nel, size_t width,\n            int compar(const void *, const void *));\n    \"\"\")\n    ffi.verify(\"#include <stdlib.h>\")\n\ndef test_array_as_argument():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        size_t strlen(char string[]);\n    \"\"\")\n    ffi.verify(\"#include <string.h>\")\n\ndef test_enum_as_argument():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        enum foo_e { AA, BB, ... };\n        int foo_func(enum foo_e);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        enum foo_e { AA, CC, BB };\n        int foo_func(enum foo_e e) { return (int)e; }\n    \"\"\")\n    assert lib.foo_func(lib.BB) == 2\n    py.test.raises(TypeError, lib.foo_func, \"BB\")\n\ndef test_enum_as_function_result():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        enum foo_e { AA, BB, ... };\n        enum foo_e foo_func(int x);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        enum foo_e { AA, CC, BB };\n        enum foo_e foo_func(int x) { return (enum foo_e)x; }\n    \"\"\")\n    assert lib.foo_func(lib.BB) == lib.BB == 2\n\ndef test_enum_values():\n    ffi = FFI()\n    ffi.cdef(\"enum enum1_e { AA, BB };\")\n    lib = ffi.verify(\"enum enum1_e { AA, BB };\")\n    assert lib.AA == 0\n    assert lib.BB == 1\n    assert ffi.string(ffi.cast(\"enum enum1_e\", 1)) == 'BB'\n\ndef test_typedef_complete_enum():\n    ffi = FFI()\n    ffi.cdef(\"typedef enum { AA, BB } enum1_t;\")\n    lib = ffi.verify(\"typedef enum { AA, BB } enum1_t;\")\n    assert ffi.string(ffi.cast(\"enum1_t\", 1)) == 'BB'\n    assert lib.AA == 0\n    assert lib.BB == 1\n\ndef test_typedef_broken_complete_enum():\n    ffi = FFI()\n    ffi.cdef(\"typedef enum { AA, BB } enum1_t;\")\n    py.test.raises(VerificationError, ffi.verify,\n                   \"typedef enum { AA, CC, BB } enum1_t;\")\n\ndef test_typedef_incomplete_enum():\n    ffi = FFI()\n    ffi.cdef(\"typedef enum { AA, BB, ... } enum1_t;\")\n    lib = ffi.verify(\"typedef enum { AA, CC, BB } enum1_t;\")\n    assert ffi.string(ffi.cast(\"enum1_t\", 1)) == '1'\n    assert ffi.string(ffi.cast(\"enum1_t\", 2)) == 'BB'\n    assert lib.AA == 0\n    assert lib.BB == 2\n\ndef test_typedef_enum_as_argument():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef enum { AA, BB, ... } foo_t;\n        int foo_func(foo_t);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        typedef enum { AA, CC, BB } foo_t;\n        int foo_func(foo_t e) { return (int)e; }\n    \"\"\")\n    assert lib.foo_func(lib.BB) == lib.BB == 2\n    py.test.raises(TypeError, lib.foo_func, \"BB\")\n\ndef test_typedef_enum_as_function_result():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef enum { AA, BB, ... } foo_t;\n        foo_t foo_func(int x);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        typedef enum { AA, CC, BB } foo_t;\n        foo_t foo_func(int x) { return (foo_t)x; }\n    \"\"\")\n    assert lib.foo_func(lib.BB) == lib.BB == 2\n\ndef test_function_typedef():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef double func_t(double);\n        func_t sin;\n    \"\"\")\n    lib = ffi.verify('#include <math.h>', libraries=lib_m)\n    assert lib.sin(1.23) == math.sin(1.23)\n\ndef test_callback_calling_convention():\n    py.test.skip(\"later\")\n    if sys.platform != 'win32':\n        py.test.skip(\"Windows only\")\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        int call1(int(*__cdecl cb)(int));\n        int call2(int(*__stdcall cb)(int));\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        int call1(int(*__cdecl cb)(int)) {\n            return cb(42) + 1;\n        }\n        int call2(int(*__stdcall cb)(int)) {\n            return cb(-42) - 6;\n        }\n    \"\"\")\n    xxx\n\ndef test_opaque_integer_as_function_result():\n    #import platform\n    #if platform.machine().startswith('sparc'):\n    #    py.test.skip('Breaks horribly on sparc (SIGILL + corrupted stack)')\n    #elif platform.machine() == 'mips64' and sys.maxsize > 2**32:\n    #    py.test.skip('Segfaults on mips64el')\n    # XXX bad abuse of \"struct { ...; }\".  It only works a bit by chance\n    # anyway.  XXX think about something better :-(\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef struct { ...; } myhandle_t;\n        myhandle_t foo(void);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        typedef short myhandle_t;\n        myhandle_t foo(void) { return 42; }\n    \"\"\")\n    h = lib.foo()\n    assert ffi.sizeof(h) == ffi.sizeof(\"short\")\n\ndef test_return_partial_struct():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef struct { int x; ...; } foo_t;\n        foo_t foo(void);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        typedef struct { int y, x; } foo_t;\n        foo_t foo(void) { foo_t r = { 45, 81 }; return r; }\n    \"\"\")\n    h = lib.foo()\n    assert ffi.sizeof(h) == 2 * ffi.sizeof(\"int\")\n    assert h.x == 81\n\ndef test_take_and_return_partial_structs():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef struct { int x; ...; } foo_t;\n        foo_t foo(foo_t, foo_t);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        typedef struct { int y, x; } foo_t;\n        foo_t foo(foo_t a, foo_t b) {\n            foo_t r = { 100, a.x * 5 + b.x * 7 };\n            return r;\n        }\n    \"\"\")\n    args = ffi.new(\"foo_t[3]\")\n    args[0].x = 1000\n    args[2].x = -498\n    h = lib.foo(args[0], args[2])\n    assert ffi.sizeof(h) == 2 * ffi.sizeof(\"int\")\n    assert h.x == 1000 * 5 - 498 * 7\n\ndef test_cannot_name_struct_type():\n    ffi = FFI()\n    ffi.cdef(\"typedef struct { int x; } **sp; void foo(sp);\")\n    e = py.test.raises(VerificationError, ffi.verify,\n                       \"typedef struct { int x; } **sp; void foo(sp x) { }\")\n    assert 'in argument of foo: unknown type name' in str(e.value)\n\ndef test_dont_check_unnamable_fields():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { struct { int x; } someone; };\")\n    ffi.verify(\"struct foo_s { struct { int x; } someone; };\")\n    # assert did not crash\n\ndef test_nested_anonymous_struct_exact():\n    if sys.platform == 'win32':\n        py.test.skip(\"nested anonymous struct/union\")\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        struct foo_s { struct { int a; char b; }; union { char c, d; }; };\n    \"\"\")\n    ffi.verify(\"\"\"\n        struct foo_s { struct { int a; char b; }; union { char c, d; }; };\n    \"\"\")\n    p = ffi.new(\"struct foo_s *\")\n    assert ffi.sizeof(p[0]) == 3 * ffi.sizeof(\"int\")    # with alignment\n    p.a = 1234567\n    p.b = b'X'\n    p.c = b'Y'\n    assert p.a == 1234567\n    assert p.b == b'X'\n    assert p.c == b'Y'\n    assert p.d == b'Y'\n\ndef test_nested_anonymous_struct_exact_error():\n    if sys.platform == 'win32':\n        py.test.skip(\"nested anonymous struct/union\")\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        struct foo_s { struct { int a; char b; }; union { char c, d; }; };\n    \"\"\")\n    py.test.raises(VerificationError, ffi.verify, \"\"\"\n        struct foo_s { struct { int a; short b; }; union { char c, d; }; };\n    \"\"\")\n    py.test.raises(VerificationError, ffi.verify, \"\"\"\n        struct foo_s { struct { int a; char e, b; }; union { char c, d; }; };\n    \"\"\")\n\ndef test_nested_anonymous_struct_inexact_1():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        struct foo_s { struct { char b; ...; }; union { char c, d; }; };\n    \"\"\")\n    ffi.verify(\"\"\"\n        struct foo_s { int a, padding; char c, d, b; };\n    \"\"\")\n    assert ffi.sizeof(\"struct foo_s\") == 3 * ffi.sizeof(\"int\")\n\ndef test_nested_anonymous_struct_inexact_2():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        struct foo_s { union { char c, d; }; struct { int a; char b; }; ...; };\n    \"\"\")\n    ffi.verify(\"\"\"\n        struct foo_s { int a, padding; char c, d, b; };\n    \"\"\")\n    assert ffi.sizeof(\"struct foo_s\") == 3 * ffi.sizeof(\"int\")\n\ndef test_ffi_union():\n    ffi = FFI()\n    ffi.cdef(\"union foo_u { char x; long *z; };\")\n    ffi.verify(\"union foo_u { char x; int y; long *z; };\")\n\ndef test_ffi_union_partial():\n    ffi = FFI()\n    ffi.cdef(\"union foo_u { char x; ...; };\")\n    ffi.verify(\"union foo_u { char x; int y; };\")\n    assert ffi.sizeof(\"union foo_u\") == 4\n\ndef test_ffi_union_with_partial_struct():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int x; ...; }; union foo_u { struct foo_s s; };\")\n    ffi.verify(\"struct foo_s { int a; int x; }; \"\n               \"union foo_u { char b[32]; struct foo_s s; };\")\n    assert ffi.sizeof(\"struct foo_s\") == 8\n    assert ffi.sizeof(\"union foo_u\") == 32\n\ndef test_ffi_union_partial_2():\n    ffi = FFI()\n    ffi.cdef(\"typedef union { char x; ...; } u1;\")\n    ffi.verify(\"typedef union { char x; int y; } u1;\")\n    assert ffi.sizeof(\"u1\") == 4\n\ndef test_ffi_union_with_partial_struct_2():\n    ffi = FFI()\n    ffi.cdef(\"typedef struct { int x; ...; } s1;\"\n             \"typedef union { s1 s; } u1;\")\n    ffi.verify(\"typedef struct { int a; int x; } s1; \"\n               \"typedef union { char b[32]; s1 s; } u1;\")\n    assert ffi.sizeof(\"s1\") == 8\n    assert ffi.sizeof(\"u1\") == 32\n    assert ffi.offsetof(\"u1\", \"s\") == 0\n\ndef test_ffi_struct_packed():\n    if sys.platform == 'win32':\n        py.test.skip(\"needs a GCC extension\")\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int b; ...; };\")\n    ffi.verify(\"\"\"\n        struct foo_s {\n            char a;\n            int b;\n        } __attribute__((packed));\n    \"\"\")\n\ndef test_tmpdir():\n    import tempfile, os\n    from testing.udir import udir\n    tmpdir = tempfile.mkdtemp(dir=str(udir))\n    ffi = FFI()\n    ffi.cdef(\"int foo(int);\")\n    lib = ffi.verify(\"int foo(int a) { return a + 42; }\", tmpdir=tmpdir)\n    assert os.listdir(tmpdir)\n    assert lib.foo(100) == 142\n\ndef test_relative_to():\n    import tempfile, os\n    from testing.udir import udir\n    tmpdir = tempfile.mkdtemp(dir=str(udir))\n    ffi = FFI()\n    ffi.cdef(\"int foo(int);\")\n    f = open(os.path.join(tmpdir, 'foo.h'), 'w')\n    f.write(\"int foo(int a) { return a + 42; }\\n\")\n    f.close()\n    lib = ffi.verify('#include \"foo.h\"',\n                     include_dirs=['.'],\n                     relative_to=os.path.join(tmpdir, 'x'))\n    assert lib.foo(100) == 142\n\ndef test_bug1():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef struct tdlhandle_s { ...; } *tdl_handle_t;\n        typedef struct my_error_code_ {\n            tdl_handle_t *rh;\n        } my_error_code_t;\n    \"\"\")\n    ffi.verify(\"\"\"\n        typedef struct tdlhandle_s { int foo; } *tdl_handle_t;\n        typedef struct my_error_code_ {\n            tdl_handle_t *rh;\n        } my_error_code_t;\n    \"\"\")\n\ndef test_bool():\n    if sys.platform == 'win32':\n        py.test.skip(\"_Bool not in MSVC\")\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { _Bool x; };\"\n             \"_Bool foo(_Bool);\")\n    lib = ffi.verify(\"\"\"\n        struct foo_s { _Bool x; };\n        int foo(int arg) {\n            return !arg;\n        }\n    \"\"\")\n    p = ffi.new(\"struct foo_s *\")\n    p.x = 1\n    assert p.x == 1\n    py.test.raises(OverflowError, \"p.x = -1\")\n    py.test.raises(TypeError, \"p.x = 0.0\")\n    assert lib.foo(1) == 0\n    assert lib.foo(0) == 1\n    py.test.raises(OverflowError, lib.foo, 42)\n    py.test.raises(TypeError, lib.foo, 0.0)\n    assert int(ffi.cast(\"_Bool\", long(1))) == 1\n    assert int(ffi.cast(\"_Bool\", long(0))) == 0\n    assert int(ffi.cast(\"_Bool\", long(-1))) == 1\n    assert int(ffi.cast(\"_Bool\", 10**200)) == 1\n    assert int(ffi.cast(\"_Bool\", 10**40000)) == 1\n    #\n    class Foo(object):\n        def __int__(self):\n            self.seen = 1\n            return result\n    f = Foo()\n    f.seen = 0\n    result = 42\n    assert int(ffi.cast(\"_Bool\", f)) == 1\n    assert f.seen\n    f.seen = 0\n    result = 0\n    assert int(ffi.cast(\"_Bool\", f)) == 0\n    assert f.seen\n    #\n    py.test.raises(TypeError, ffi.cast, \"_Bool\", [])\n\ndef test_bool_on_long_double():\n    if sys.platform == 'win32':\n        py.test.skip(\"_Bool not in MSVC\")\n    f = 1E-250\n    if f == 0.0 or f*f != 0.0:\n        py.test.skip(\"unexpected precision\")\n    ffi = FFI()\n    ffi.cdef(\"long double square(long double f); _Bool opposite(_Bool);\")\n    lib = ffi.verify(\"long double square(long double f) { return f*f; }\\n\"\n                     \"_Bool opposite(_Bool x) { return !x; }\")\n    f0 = lib.square(0.0)\n    f2 = lib.square(f)\n    f3 = lib.square(f * 2.0)\n    if repr(f2) == repr(f3):\n        py.test.skip(\"long double doesn't have enough precision\")\n    assert float(f0) == float(f2) == float(f3) == 0.0  # too tiny for 'double'\n    assert int(ffi.cast(\"_Bool\", f2)) == 1\n    assert int(ffi.cast(\"_Bool\", f3)) == 1\n    assert int(ffi.cast(\"_Bool\", f0)) == 0\n    py.test.raises(TypeError, lib.opposite, f2)\n\ndef test_cannot_pass_float():\n    for basetype in ['char', 'short', 'int', 'long', 'long long']:\n        for sign in ['signed', 'unsigned']:\n            type = '%s %s' % (sign, basetype)\n            ffi = FFI()\n            ffi.cdef(\"struct foo_s { %s x; };\\n\"\n                     \"int foo(%s);\" % (type, type))\n            lib = ffi.verify(\"\"\"\n                struct foo_s { %s x; };\n                int foo(%s arg) {\n                    return !arg;\n                }\n            \"\"\" % (type, type))\n            p = ffi.new(\"struct foo_s *\")\n            py.test.raises(TypeError, \"p.x = 0.0\")\n            assert lib.foo(42) == 0\n            assert lib.foo(0) == 1\n            py.test.raises(TypeError, lib.foo, 0.0)\n\ndef test_cast_from_int_type_to_bool():\n    ffi = FFI()\n    for basetype in ['char', 'short', 'int', 'long', 'long long']:\n        for sign in ['signed', 'unsigned']:\n            type = '%s %s' % (sign, basetype)\n            assert int(ffi.cast(\"_Bool\", ffi.cast(type, 42))) == 1\n            assert int(ffi.cast(\"bool\", ffi.cast(type, 42))) == 1\n            assert int(ffi.cast(\"_Bool\", ffi.cast(type, 0))) == 0\n\ndef test_addressof():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        struct point_s { int x, y; };\n        struct foo_s { int z; struct point_s point; };\n        struct point_s sum_coord(struct point_s *);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        struct point_s { int x, y; };\n        struct foo_s { int z; struct point_s point; };\n        struct point_s sum_coord(struct point_s *point) {\n            struct point_s r;\n            r.x = point->x + point->y;\n            r.y = point->x - point->y;\n            return r;\n        }\n    \"\"\")\n    p = ffi.new(\"struct foo_s *\")\n    p.point.x = 16\n    p.point.y = 9\n    py.test.raises(TypeError, lib.sum_coord, p.point)\n    res = lib.sum_coord(ffi.addressof(p.point))\n    assert res.x == 25\n    assert res.y == 7\n    res2 = lib.sum_coord(ffi.addressof(res))\n    assert res2.x == 32\n    assert res2.y == 18\n    py.test.raises(TypeError, lib.sum_coord, res2)\n\ndef test_callback_in_thread():\n    if sys.platform == 'win32':\n        py.test.skip(\"pthread only\")\n    import os, subprocess, imp\n    arg = os.path.join(os.path.dirname(__file__), 'callback_in_thread.py')\n    g = subprocess.Popen([sys.executable, arg,\n                          os.path.dirname(imp.find_module('cffi')[1])])\n    result = g.wait()\n    assert result == 0\n\ndef test_keepalive_lib():\n    ffi = FFI()\n    ffi.cdef(\"int foobar(void);\")\n    lib = ffi.verify(\"int foobar(void) { return 42; }\")\n    func = lib.foobar\n    ffi_r = weakref.ref(ffi)\n    lib_r = weakref.ref(lib)\n    del ffi\n    import gc; gc.collect()       # lib stays alive\n    assert lib_r() is not None\n    assert ffi_r() is not None\n    assert func() == 42\n\ndef test_keepalive_ffi():\n    ffi = FFI()\n    ffi.cdef(\"int foobar(void);\")\n    lib = ffi.verify(\"int foobar(void) { return 42; }\")\n    func = lib.foobar\n    ffi_r = weakref.ref(ffi)\n    lib_r = weakref.ref(lib)\n    del lib\n    import gc; gc.collect()       # ffi stays alive\n    assert ffi_r() is not None\n    assert lib_r() is not None\n    assert func() == 42\n\ndef test_FILE_stored_in_stdout():\n    if not sys.platform.startswith('linux'):\n        py.test.skip(\"likely, we cannot assign to stdout\")\n    ffi = FFI()\n    ffi.cdef(\"int printf(const char *, ...); FILE *setstdout(FILE *);\")\n    lib = ffi.verify(\"\"\"\n        #include <stdio.h>\n        FILE *setstdout(FILE *f) {\n            FILE *result = stdout;\n            stdout = f;\n            return result;\n        }\n    \"\"\")\n    import os\n    fdr, fdw = os.pipe()\n    fw1 = os.fdopen(fdw, 'wb', 256)\n    old_stdout = lib.setstdout(fw1)\n    try:\n        #\n        fw1.write(b\"X\")\n        r = lib.printf(b\"hello, %d!\\n\", ffi.cast(\"int\", 42))\n        fw1.close()\n        assert r == len(\"hello, 42!\\n\")\n        #\n    finally:\n        lib.setstdout(old_stdout)\n    #\n    result = os.read(fdr, 256)\n    os.close(fdr)\n    # the 'X' might remain in the user-level buffer of 'fw1' and\n    # end up showing up after the 'hello, 42!\\n'\n    assert result == b\"Xhello, 42!\\n\" or result == b\"hello, 42!\\nX\"\n\ndef test_FILE_stored_explicitly():\n    ffi = FFI()\n    ffi.cdef(\"int myprintf(const char *, int); FILE *myfile;\")\n    lib = ffi.verify(\"\"\"\n        #include <stdio.h>\n        FILE *myfile;\n        int myprintf(const char *out, int value) {\n            return fprintf(myfile, out, value);\n        }\n    \"\"\")\n    import os\n    fdr, fdw = os.pipe()\n    fw1 = os.fdopen(fdw, 'wb', 256)\n    lib.myfile = ffi.cast(\"FILE *\", fw1)\n    #\n    fw1.write(b\"X\")\n    r = lib.myprintf(b\"hello, %d!\\n\", ffi.cast(\"int\", 42))\n    fw1.close()\n    assert r == len(\"hello, 42!\\n\")\n    #\n    result = os.read(fdr, 256)\n    os.close(fdr)\n    # the 'X' might remain in the user-level buffer of 'fw1' and\n    # end up showing up after the 'hello, 42!\\n'\n    assert result == b\"Xhello, 42!\\n\" or result == b\"hello, 42!\\nX\"\n\ndef test_global_array_with_missing_length():\n    ffi = FFI()\n    ffi.cdef(\"int fooarray[];\")\n    lib = ffi.verify(\"int fooarray[50];\")\n    assert repr(lib.fooarray).startswith(\"<cdata 'int *'\")\n\ndef test_global_array_with_dotdotdot_length():\n    ffi = FFI()\n    ffi.cdef(\"int fooarray[...];\")\n    lib = ffi.verify(\"int fooarray[50];\")\n    assert repr(lib.fooarray).startswith(\"<cdata 'int[50]'\")\n\ndef test_bad_global_array_with_dotdotdot_length():\n    ffi = FFI()\n    ffi.cdef(\"int fooarray[...];\")\n    py.test.raises(VerificationError, ffi.verify, \"char fooarray[23];\")\n\ndef test_struct_containing_struct():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { ...; }; struct bar_s { struct foo_s f; ...; };\")\n    ffi.verify(\"struct foo_s { int x; }; struct bar_s { struct foo_s f; };\")\n    #\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { struct bar_s f; ...; }; struct bar_s { ...; };\")\n    ffi.verify(\"struct bar_s { int x; }; struct foo_s { struct bar_s f; };\")\n\ndef test_struct_returned_by_func():\n    ffi = FFI()\n    ffi.cdef(\"typedef ... foo_t; foo_t myfunc(void);\")\n    e = py.test.raises(TypeError, ffi.verify,\n                       \"typedef struct { int x; } foo_t; \"\n                       \"foo_t myfunc(void) { foo_t x = { 42 }; return x; }\")\n    assert str(e.value) == (\n        \"function myfunc: 'foo_t' is used as result type, but is opaque\")\n\ndef test_include():\n    ffi1 = FFI()\n    ffi1.cdef(\"typedef struct { int x; ...; } foo_t;\")\n    ffi1.verify(\"typedef struct { int y, x; } foo_t;\")\n    ffi2 = FFI()\n    ffi2.include(ffi1)\n    ffi2.cdef(\"int myfunc(foo_t *);\")\n    lib = ffi2.verify(\"typedef struct { int y, x; } foo_t;\"\n                      \"int myfunc(foo_t *p) { return 42 * p->x; }\")\n    res = lib.myfunc(ffi2.new(\"foo_t *\", {'x': 10}))\n    assert res == 420\n    res = lib.myfunc(ffi1.new(\"foo_t *\", {'x': -10}))\n    assert res == -420\n\ndef test_include_enum():\n    ffi1 = FFI()\n    ffi1.cdef(\"enum foo_e { AA, ... };\")\n    lib1 = ffi1.verify(\"enum foo_e { CC, BB, AA };\")\n    ffi2 = FFI()\n    ffi2.include(ffi1)\n    ffi2.cdef(\"int myfunc(enum foo_e);\")\n    lib2 = ffi2.verify(\"enum foo_e { CC, BB, AA };\"\n                       \"int myfunc(enum foo_e x) { return (int)x; }\")\n    res = lib2.myfunc(lib2.AA)\n    assert res == 2\n\ndef test_named_pointer_as_argument():\n    ffi = FFI()\n    ffi.cdef(\"typedef struct { int x; } *mystruct_p;\\n\"\n             \"mystruct_p ff5a(mystruct_p);\")\n    lib = ffi.verify(\"typedef struct { int x; } *mystruct_p;\\n\"\n                     \"mystruct_p ff5a(mystruct_p p) { p->x += 40; return p; }\")\n    p = ffi.new(\"mystruct_p\", [-2])\n    q = lib.ff5a(p)\n    assert q == p\n    assert p.x == 38\n\ndef test_enum_size():\n    cases = [('123',           4, 4294967295),\n             ('4294967295U',   4, 4294967295),\n             ('-123',          4, -1),\n             ('-2147483647-1', 4, -1),\n             ]\n    if FFI().sizeof(\"long\") == 8:\n        cases += [('4294967296L',        8, 2**64-1),\n                  ('%dUL' % (2**64-1),   8, 2**64-1),\n                  ('-2147483649L',       8, -1),\n                  ('%dL-1L' % (1-2**63), 8, -1)]\n    for hidden_value, expected_size, expected_minus1 in cases:\n        if sys.platform == 'win32' and 'U' in hidden_value:\n            continue   # skipped on Windows\n        ffi = FFI()\n        ffi.cdef(\"enum foo_e { AA, BB, ... };\")\n        lib = ffi.verify(\"enum foo_e { AA, BB=%s };\" % hidden_value)\n        assert lib.AA == 0\n        assert lib.BB == eval(hidden_value.replace('U', '').replace('L', ''))\n        assert ffi.sizeof(\"enum foo_e\") == expected_size\n        assert int(ffi.cast(\"enum foo_e\", -1)) == expected_minus1\n    # test with the large value hidden:\n    # disabled so far, doesn't work\n##    for hidden_value, expected_size, expected_minus1 in cases:\n##        ffi = FFI()\n##        ffi.cdef(\"enum foo_e { AA, BB, ... };\")\n##        lib = ffi.verify(\"enum foo_e { AA, BB=%s };\" % hidden_value)\n##        assert lib.AA == 0\n##        assert ffi.sizeof(\"enum foo_e\") == expected_size\n##        assert int(ffi.cast(\"enum foo_e\", -1)) == expected_minus1\n\ndef test_enum_bug118():\n    maxulong = 256 ** FFI().sizeof(\"unsigned long\") - 1\n    for c1, c2, c2c in [(0xffffffff, -1, ''),\n                        (maxulong, -1, ''),\n                        (-1, 0xffffffff, 'U'),\n                        (-1, maxulong, 'UL')]:\n        if c2c and sys.platform == 'win32':\n            continue     # enums may always be signed with MSVC\n        ffi = FFI()\n        ffi.cdef(\"enum foo_e { AA=%s };\" % c1)\n        e = py.test.raises(VerificationError, ffi.verify,\n                           \"enum foo_e { AA=%s%s };\" % (c2, c2c))\n        assert str(e.value) == ('enum foo_e: AA has the real value %d, not %d'\n                                % (c2, c1))\n\ndef test_string_to_voidp_arg():\n    ffi = FFI()\n    ffi.cdef(\"int myfunc(void *);\")\n    lib = ffi.verify(\"int myfunc(void *p) { return ((signed char *)p)[0]; }\")\n    res = lib.myfunc(b\"hi!\")\n    assert res == ord(b\"h\")\n    p = ffi.new(\"char[]\", b\"gah\")\n    res = lib.myfunc(p)\n    assert res == ord(b\"g\")\n    res = lib.myfunc(ffi.cast(\"void *\", p))\n    assert res == ord(b\"g\")\n    res = lib.myfunc(ffi.cast(\"int *\", p))\n    assert res == ord(b\"g\")\n\ndef test_callback_indirection():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        int (*python_callback)(int how_many, int *values);\n        int (*const c_callback)(int,...);   /* pass this ptr to C routines */\n        int some_c_function(int(*cb)(int,...));\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        #include <stdarg.h>\n        #ifdef _WIN32\n        #include <malloc.h>\n        #define alloca _alloca\n        #else\n        # ifdef __FreeBSD__\n        #  include <stdlib.h>\n        # else\n        #  include <alloca.h>\n        # endif\n        #endif\n        static int (*python_callback)(int how_many, int *values);\n        static int c_callback(int how_many, ...) {\n            va_list ap;\n            /* collect the \"...\" arguments into the values[] array */\n            int i, *values = alloca((size_t)how_many * sizeof(int));\n            va_start(ap, how_many);\n            for (i=0; i<how_many; i++)\n                values[i] = va_arg(ap, int);\n            va_end(ap);\n            return python_callback(how_many, values);\n        }\n        int some_c_function(int(*cb)(int,...)) {\n            int result = cb(2, 10, 20);\n            result += cb(3, 30, 40, 50);\n            return result;\n        }\n    \"\"\")\n    seen = []\n    @ffi.callback(\"int(int, int*)\")\n    def python_callback(how_many, values):\n        seen.append([values[i] for i in range(how_many)])\n        return 42\n    lib.python_callback = python_callback\n\n    res = lib.some_c_function(lib.c_callback)\n    assert res == 84\n    assert seen == [[10, 20], [30, 40, 50]]\n\ndef test_floatstar_argument():\n    ffi = FFI()\n    ffi.cdef(\"float sum3floats(float *);\")\n    lib = ffi.verify(\"\"\"\n        float sum3floats(float *f) {\n            return f[0] + f[1] + f[2];\n        }\n    \"\"\")\n    assert lib.sum3floats((1.5, 2.5, 3.5)) == 7.5\n    p = ffi.new(\"float[]\", (1.5, 2.5, 3.5))\n    assert lib.sum3floats(p) == 7.5\n\ndef test_charstar_argument():\n    ffi = FFI()\n    ffi.cdef(\"char sum3chars(char *);\")\n    lib = ffi.verify(\"\"\"\n        char sum3chars(char *f) {\n            return (char)(f[0] + f[1] + f[2]);\n        }\n    \"\"\")\n    assert lib.sum3chars((b'\\x10', b'\\x20', b'\\x30')) == b'\\x60'\n    p = ffi.new(\"char[]\", b'\\x10\\x20\\x30')\n    assert lib.sum3chars(p) == b'\\x60'\n\ndef test_passing_string_or_NULL():\n    ffi = FFI()\n    ffi.cdef(\"int seeme1(char *); int seeme2(int *);\")\n    lib = ffi.verify(\"\"\"\n        int seeme1(char *x) {\n            return (x == NULL);\n        }\n        int seeme2(int *x) {\n            return (x == NULL);\n        }\n    \"\"\")\n    assert lib.seeme1(b\"foo\") == 0\n    assert lib.seeme1(ffi.NULL) == 1\n    assert lib.seeme2([42, 43]) == 0\n    assert lib.seeme2(ffi.NULL) == 1\n    py.test.raises(TypeError, lib.seeme1, None)\n    py.test.raises(TypeError, lib.seeme2, None)\n    py.test.raises(TypeError, lib.seeme1, 0.0)\n    py.test.raises(TypeError, lib.seeme2, 0.0)\n    py.test.raises(TypeError, lib.seeme1, 0)\n    py.test.raises(TypeError, lib.seeme2, 0)\n    zeroL  = 99999999999999999999\n    zeroL -= 99999999999999999999\n    py.test.raises(TypeError, lib.seeme2, zeroL)\n\ndef test_typeof_function():\n    ffi = FFI()\n    ffi.cdef(\"int foo(int, char);\")\n    lib = ffi.verify(\"int foo(int x, char y) { (void)x; (void)y; return 42; }\")\n    ctype = ffi.typeof(lib.foo)\n    assert len(ctype.args) == 2\n    assert ctype.result == ffi.typeof(\"int\")\n\ndef test_call_with_voidstar_arg():\n    ffi = FFI()\n    ffi.cdef(\"int f(void *);\")\n    lib = ffi.verify(\"int f(void *x) { return ((char*)x)[0]; }\")\n    assert lib.f(b\"foobar\") == ord(b\"f\")\n\ndef test_dir():\n    ffi = FFI()\n    ffi.cdef(\"\"\"void somefunc(void);\n                extern int somevar, somearray[2];\n                static char *const sv2;\n                enum my_e { AA, BB, ... };\n                #define FOO ...\"\"\")\n    lib = ffi.verify(\"\"\"void somefunc(void) { }\n                        int somevar, somearray[2];\n                        #define sv2 \"text\"\n                        enum my_e { AA, BB };\n                        #define FOO 42\"\"\")\n    assert dir(lib) == ['AA', 'BB', 'FOO', 'somearray',\n                        'somefunc', 'somevar', 'sv2']\n\ndef test_typeof_func_with_struct_argument():\n    ffi = FFI()\n    ffi.cdef(\"\"\"struct s { int a; }; int foo(struct s);\"\"\")\n    lib = ffi.verify(\"\"\"struct s { int a; };\n                        int foo(struct s x) { return x.a; }\"\"\")\n    s = ffi.new(\"struct s *\", [-1234])\n    m = lib.foo(s[0])\n    assert m == -1234\n    assert repr(ffi.typeof(lib.foo)) == \"<ctype 'int(*)(struct s)'>\"\n\ndef test_bug_const_char_ptr_array_1():\n    ffi = FFI()\n    ffi.cdef(\"\"\"const char *a[...];\"\"\")\n    lib = ffi.verify(\"\"\"const char *a[5];\"\"\")\n    assert repr(ffi.typeof(lib.a)) == \"<ctype 'char *[5]'>\"\n\ndef test_bug_const_char_ptr_array_2():\n    from cffi import FFI     # ignore warnings\n    ffi = FFI()\n    ffi.cdef(\"\"\"const int a[];\"\"\")\n    lib = ffi.verify(\"\"\"const int a[5];\"\"\")\n    assert repr(ffi.typeof(lib.a)) == \"<ctype 'int *'>\"\n\ndef _test_various_calls(force_libffi):\n    cdef_source = \"\"\"\n    int xvalue;\n    long long ivalue, rvalue;\n    float fvalue;\n    double dvalue;\n    long double Dvalue;\n    signed char tf_bb(signed char x, signed char c);\n    unsigned char tf_bB(signed char x, unsigned char c);\n    short tf_bh(signed char x, short c);\n    unsigned short tf_bH(signed char x, unsigned short c);\n    int tf_bi(signed char x, int c);\n    unsigned int tf_bI(signed char x, unsigned int c);\n    long tf_bl(signed char x, long c);\n    unsigned long tf_bL(signed char x, unsigned long c);\n    long long tf_bq(signed char x, long long c);\n    unsigned long long tf_bQ(signed char x, unsigned long long c);\n    float tf_bf(signed char x, float c);\n    double tf_bd(signed char x, double c);\n    long double tf_bD(signed char x, long double c);\n    \"\"\"\n    if force_libffi:\n        cdef_source = (cdef_source\n            .replace('tf_', '(*const tf_')\n            .replace('(signed char x', ')(signed char x'))\n    ffi = FFI()\n    ffi.cdef(cdef_source)\n    lib = ffi.verify(\"\"\"\n    int xvalue;\n    long long ivalue, rvalue;\n    float fvalue;\n    double dvalue;\n    long double Dvalue;\n\n    typedef signed char b_t;\n    typedef unsigned char B_t;\n    typedef short h_t;\n    typedef unsigned short H_t;\n    typedef int i_t;\n    typedef unsigned int I_t;\n    typedef long l_t;\n    typedef unsigned long L_t;\n    typedef long long q_t;\n    typedef unsigned long long Q_t;\n    typedef float f_t;\n    typedef double d_t;\n    typedef long double D_t;\n    #define S(letter)  xvalue = (int)x; letter##value = (letter##_t)c;\n    #define R(letter)  return (letter##_t)rvalue;\n\n    signed char tf_bb(signed char x, signed char c) { S(i) R(b) }\n    unsigned char tf_bB(signed char x, unsigned char c) { S(i) R(B) }\n    short tf_bh(signed char x, short c) { S(i) R(h) }\n    unsigned short tf_bH(signed char x, unsigned short c) { S(i) R(H) }\n    int tf_bi(signed char x, int c) { S(i) R(i) }\n    unsigned int tf_bI(signed char x, unsigned int c) { S(i) R(I) }\n    long tf_bl(signed char x, long c) { S(i) R(l) }\n    unsigned long tf_bL(signed char x, unsigned long c) { S(i) R(L) }\n    long long tf_bq(signed char x, long long c) { S(i) R(q) }\n    unsigned long long tf_bQ(signed char x, unsigned long long c) { S(i) R(Q) }\n    float tf_bf(signed char x, float c) { S(f) R(f) }\n    double tf_bd(signed char x, double c) { S(d) R(d) }\n    long double tf_bD(signed char x, long double c) { S(D) R(D) }\n    \"\"\")\n    lib.rvalue = 0x7182838485868788\n    for kind, cname in [('b', 'signed char'),\n                        ('B', 'unsigned char'),\n                        ('h', 'short'),\n                        ('H', 'unsigned short'),\n                        ('i', 'int'),\n                        ('I', 'unsigned int'),\n                        ('l', 'long'),\n                        ('L', 'unsigned long'),\n                        ('q', 'long long'),\n                        ('Q', 'unsigned long long'),\n                        ('f', 'float'),\n                        ('d', 'double'),\n                        ('D', 'long double')]:\n        sign = +1 if 'unsigned' in cname else -1\n        lib.xvalue = 0\n        lib.ivalue = 0\n        lib.fvalue = 0\n        lib.dvalue = 0\n        lib.Dvalue = 0\n        fun = getattr(lib, 'tf_b' + kind)\n        res = fun(-42, sign * 99)\n        if kind == 'D':\n            res = float(res)\n        assert res == int(ffi.cast(cname, 0x7182838485868788))\n        assert lib.xvalue == -42\n        if kind in 'fdD':\n            assert float(getattr(lib, kind + 'value')) == -99.0\n        else:\n            assert lib.ivalue == sign * 99\n\ndef test_various_calls_direct():\n    _test_various_calls(force_libffi=False)\n\ndef test_various_calls_libffi():\n    _test_various_calls(force_libffi=True)\n\ndef test_ptr_to_opaque():\n    ffi = FFI()\n    ffi.cdef(\"typedef ... foo_t; int f1(foo_t*); foo_t *f2(int);\")\n    lib = ffi.verify(\"\"\"\n        #include <stdlib.h>\n        typedef struct { int x; } foo_t;\n        int f1(foo_t* p) {\n            int x = p->x;\n            free(p);\n            return x;\n        }\n        foo_t *f2(int x) {\n            foo_t *p = malloc(sizeof(foo_t));\n            p->x = x;\n            return p;\n        }\n    \"\"\")\n    p = lib.f2(42)\n    x = lib.f1(p)\n    assert x == 42\n\ndef _run_in_multiple_threads(test1):\n    test1()\n    import sys\n    try:\n        import thread\n    except ImportError:\n        import _thread as thread\n    errors = []\n    def wrapper(lock):\n        try:\n            test1()\n        except:\n            errors.append(sys.exc_info())\n        lock.release()\n    locks = []\n    for i in range(10):\n        _lock = thread.allocate_lock()\n        _lock.acquire()\n        thread.start_new_thread(wrapper, (_lock,))\n        locks.append(_lock)\n    for _lock in locks:\n        _lock.acquire()\n        if errors:\n            raise errors[0][1]\n\ndef test_errno_working_even_with_pypys_jit():\n    ffi = FFI()\n    ffi.cdef(\"int f(int);\")\n    lib = ffi.verify(\"\"\"\n        #include <errno.h>\n        int f(int x) { return (errno = errno + x); }\n    \"\"\")\n    @_run_in_multiple_threads\n    def test1():\n        ffi.errno = 0\n        for i in range(10000):\n            e = lib.f(1)\n            assert e == i + 1\n            assert ffi.errno == e\n        for i in range(10000):\n            ffi.errno = i\n            e = lib.f(42)\n            assert e == i + 42\n\ndef test_getlasterror_working_even_with_pypys_jit():\n    if sys.platform != 'win32':\n        py.test.skip(\"win32-only test\")\n    ffi = FFI()\n    ffi.cdef(\"void SetLastError(DWORD);\")\n    lib = ffi.dlopen(\"Kernel32.dll\")\n    @_run_in_multiple_threads\n    def test1():\n        for i in range(10000):\n            n = (1 << 29) + i\n            lib.SetLastError(n)\n            assert ffi.getwinerror()[0] == n\n\ndef test_verify_dlopen_flags():\n    # Careful with RTLD_GLOBAL.  If by chance the FFI is not deleted\n    # promptly, like on PyPy, then other tests may see the same\n    # exported symbols as well.  So we must not export a simple name\n    # like 'foo'!\n    ffi1 = FFI()\n    ffi1.cdef(\"int foo_verify_dlopen_flags;\")\n\n    lib1 = ffi1.verify(\"int foo_verify_dlopen_flags;\",\n                       flags=ffi1.RTLD_GLOBAL | ffi1.RTLD_LAZY)\n    lib2 = get_second_lib()\n\n    lib1.foo_verify_dlopen_flags = 42\n    assert lib2.foo_verify_dlopen_flags == 42\n    lib2.foo_verify_dlopen_flags += 1\n    assert lib1.foo_verify_dlopen_flags == 43\n\ndef get_second_lib():\n    # Hack, using modulename makes the test fail\n    ffi2 = FFI()\n    ffi2.cdef(\"int foo_verify_dlopen_flags;\")\n    lib2 = ffi2.verify(\"int foo_verify_dlopen_flags;\",\n                       flags=ffi2.RTLD_GLOBAL | ffi2.RTLD_LAZY)\n    return lib2\n\ndef test_consider_not_implemented_function_type():\n    ffi = FFI()\n    ffi.cdef(\"typedef union { int a; float b; } Data;\"\n             \"typedef struct { int a:2; } MyStr;\"\n             \"typedef void (*foofunc_t)(Data);\"\n             \"typedef Data (*bazfunc_t)(void);\"\n             \"typedef MyStr (*barfunc_t)(void);\")\n    fooptr = ffi.cast(\"foofunc_t\", 123)\n    bazptr = ffi.cast(\"bazfunc_t\", 123)\n    barptr = ffi.cast(\"barfunc_t\", 123)\n    # assert did not crash so far\n    e = py.test.raises(NotImplementedError, fooptr, ffi.new(\"Data *\"))\n    assert str(e.value) == (\n        \"ctype 'Data' (size 4) not supported as argument\")\n    e = py.test.raises(NotImplementedError, bazptr)\n    assert str(e.value) == (\n        \"ctype 'Data' (size 4) not supported as return value\")\n    e = py.test.raises(NotImplementedError, barptr)\n    assert str(e.value) == (\n        \"ctype 'MyStr' not supported as return value \"\n        \"(it is a struct with bit fields)\")\n\ndef test_verify_extra_arguments():\n    ffi = FFI()\n    ffi.cdef(\"#define ABA ...\")\n    lib = ffi.verify(\"\", define_macros=[('ABA', '42')])\n    assert lib.ABA == 42\n\ndef test_implicit_unicode_on_windows():\n    if sys.platform != 'win32':\n        py.test.skip(\"win32-only test\")\n    ffi = FFI()\n    e = py.test.raises(FFIError, ffi.cdef, \"int foo(LPTSTR);\")\n    assert str(e.value) == (\"The Windows type 'LPTSTR' is only available after\"\n                            \" you call ffi.set_unicode()\")\n    for with_unicode in [True, False]:\n        ffi = FFI()\n        ffi.set_unicode(with_unicode)\n        ffi.cdef(\"\"\"\n            DWORD GetModuleFileName(HMODULE hModule, LPTSTR lpFilename,\n                                    DWORD nSize);\n        \"\"\")\n        lib = ffi.verify(\"\"\"\n            #include <windows.h>\n        \"\"\", libraries=['Kernel32'])\n        outbuf = ffi.new(\"TCHAR[]\", 200)\n        n = lib.GetModuleFileName(ffi.NULL, outbuf, 500)\n        assert 0 < n < 500\n        for i in range(n):\n            #print repr(outbuf[i])\n            assert ord(outbuf[i]) != 0\n        assert ord(outbuf[n]) == 0\n        assert ord(outbuf[0]) < 128     # should be a letter, or '\\'\n\ndef test_use_local_dir():\n    ffi = FFI()\n    lib = ffi.verify(\"\", modulename=\"test_use_local_dir\")\n    this_dir = os.path.dirname(__file__)\n    pycache_files = os.listdir(os.path.join(this_dir, '__pycache__'))\n    assert any('test_use_local_dir' in s for s in pycache_files)\n\ndef test_define_known_value():\n    ffi = FFI()\n    ffi.cdef(\"#define FOO 0x123\")\n    lib = ffi.verify(\"#define FOO 0x123\")\n    assert lib.FOO == 0x123\n\ndef test_define_wrong_value():\n    ffi = FFI()\n    ffi.cdef(\"#define FOO 123\")\n    e = py.test.raises(VerificationError, ffi.verify, \"#define FOO 124\")\n    assert str(e.value).endswith(\"FOO has the real value 124, not 123\")\n\ndef test_static_const_int_known_value():\n    ffi = FFI()\n    ffi.cdef(\"static const int FOO = 0x123;\")\n    lib = ffi.verify(\"#define FOO 0x123\")\n    assert lib.FOO == 0x123\n\ndef test_static_const_int_wrong_value():\n    ffi = FFI()\n    ffi.cdef(\"static const int FOO = 123;\")\n    e = py.test.raises(VerificationError, ffi.verify, \"#define FOO 124\")\n    assert str(e.value).endswith(\"FOO has the real value 124, not 123\")\n\ndef test_const_struct_global():\n    ffi = FFI()\n    ffi.cdef(\"typedef struct { int x; ...; } T; const T myglob;\")\n    lib = ffi.verify(\"typedef struct { double y; int x; } T;\"\n                     \"const T myglob = { 0.1, 42 };\")\n    assert ffi.typeof(lib.myglob) == ffi.typeof(\"T\")\n    assert lib.myglob.x == 42\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.1.2-nak3eqkxfunb4z5owzsqogchnaejp7o4/spack-src/cffi/api.py": "import sys, types\nfrom .lock import allocate_lock\n\ntry:\n    callable\nexcept NameError:\n    # Python 3.1\n    from collections import Callable\n    callable = lambda x: isinstance(x, Callable)\n\ntry:\n    basestring\nexcept NameError:\n    # Python 3.x\n    basestring = str\n\n\nclass FFIError(Exception):\n    pass\n\nclass CDefError(Exception):\n    def __str__(self):\n        try:\n            line = 'line %d: ' % (self.args[1].coord.line,)\n        except (AttributeError, TypeError, IndexError):\n            line = ''\n        return '%s%s' % (line, self.args[0])\n\n\nclass FFI(object):\n    r'''\n    The main top-level class that you instantiate once, or once per module.\n\n    Example usage:\n\n        ffi = FFI()\n        ffi.cdef(\"\"\"\n            int printf(const char *, ...);\n        \"\"\")\n\n        C = ffi.dlopen(None)   # standard library\n        -or-\n        C = ffi.verify()  # use a C compiler: verify the decl above is right\n\n        C.printf(\"hello, %s!\\n\", ffi.new(\"char[]\", \"world\"))\n    '''\n\n    def __init__(self, backend=None):\n        \"\"\"Create an FFI instance.  The 'backend' argument is used to\n        select a non-default backend, mostly for tests.\n        \"\"\"\n        from . import cparser, model\n        if backend is None:\n            # You need PyPy (>= 2.0 beta), or a CPython (>= 2.6) with\n            # _cffi_backend.so compiled.\n            import _cffi_backend as backend\n            from . import __version__\n            assert backend.__version__ == __version__, \\\n               \"version mismatch, %s != %s\" % (backend.__version__, __version__)\n            # (If you insist you can also try to pass the option\n            # 'backend=backend_ctypes.CTypesBackend()', but don't\n            # rely on it!  It's probably not going to work well.)\n\n        self._backend = backend\n        self._lock = allocate_lock()\n        self._parser = cparser.Parser()\n        self._cached_btypes = {}\n        self._parsed_types = types.ModuleType('parsed_types').__dict__\n        self._new_types = types.ModuleType('new_types').__dict__\n        self._function_caches = []\n        self._libraries = []\n        self._cdefsources = []\n        self._included_ffis = []\n        self._windows_unicode = None\n        if hasattr(backend, 'set_ffi'):\n            backend.set_ffi(self)\n        for name in backend.__dict__:\n            if name.startswith('RTLD_'):\n                setattr(self, name, getattr(backend, name))\n        #\n        with self._lock:\n            self.BVoidP = self._get_cached_btype(model.voidp_type)\n            self.BCharA = self._get_cached_btype(model.char_array_type)\n        if isinstance(backend, types.ModuleType):\n            # _cffi_backend: attach these constants to the class\n            if not hasattr(FFI, 'NULL'):\n                FFI.NULL = self.cast(self.BVoidP, 0)\n                FFI.CData, FFI.CType = backend._get_types()\n        else:\n            # ctypes backend: attach these constants to the instance\n            self.NULL = self.cast(self.BVoidP, 0)\n            self.CData, self.CType = backend._get_types()\n\n    def cdef(self, csource, override=False, packed=False):\n        \"\"\"Parse the given C source.  This registers all declared functions,\n        types, and global variables.  The functions and global variables can\n        then be accessed via either 'ffi.dlopen()' or 'ffi.verify()'.\n        The types can be used in 'ffi.new()' and other functions.\n        If 'packed' is specified as True, all structs declared inside this\n        cdef are packed, i.e. laid out without any field alignment at all.\n        \"\"\"\n        if not isinstance(csource, str):    # unicode, on Python 2\n            if not isinstance(csource, basestring):\n                raise TypeError(\"cdef() argument must be a string\")\n            csource = csource.encode('ascii')\n        with self._lock:\n            self._parser.parse(csource, override=override, packed=packed)\n            self._cdefsources.append(csource)\n            if override:\n                for cache in self._function_caches:\n                    cache.clear()\n            finishlist = self._parser._recomplete\n            if finishlist:\n                self._parser._recomplete = []\n                for tp in finishlist:\n                    tp.finish_backend_type(self, finishlist)\n\n    def dlopen(self, name, flags=0):\n        \"\"\"Load and return a dynamic library identified by 'name'.\n        The standard C library can be loaded by passing None.\n        Note that functions and types declared by 'ffi.cdef()' are not\n        linked to a particular library, just like C headers; in the\n        library we only look for the actual (untyped) symbols.\n        \"\"\"\n        assert isinstance(name, basestring) or name is None\n        with self._lock:\n            lib, function_cache = _make_ffi_library(self, name, flags)\n            self._function_caches.append(function_cache)\n            self._libraries.append(lib)\n        return lib\n\n    def _typeof_locked(self, cdecl):\n        # call me with the lock!\n        key = cdecl\n        if key in self._parsed_types:\n            return self._parsed_types[key]\n        #\n        if not isinstance(cdecl, str):    # unicode, on Python 2\n            cdecl = cdecl.encode('ascii')\n        #\n        type = self._parser.parse_type(cdecl)\n        really_a_function_type = type.is_raw_function\n        if really_a_function_type:\n            type = type.as_function_pointer()\n        btype = self._get_cached_btype(type)\n        result = btype, really_a_function_type\n        self._parsed_types[key] = result\n        return result\n\n    def _typeof(self, cdecl, consider_function_as_funcptr=False):\n        # string -> ctype object\n        try:\n            result = self._parsed_types[cdecl]\n        except KeyError:\n            with self._lock:\n                result = self._typeof_locked(cdecl)\n        #\n        btype, really_a_function_type = result\n        if really_a_function_type and not consider_function_as_funcptr:\n            raise CDefError(\"the type %r is a function type, not a \"\n                            \"pointer-to-function type\" % (cdecl,))\n        return btype\n\n    def typeof(self, cdecl):\n        \"\"\"Parse the C type given as a string and return the\n        corresponding <ctype> object.\n        It can also be used on 'cdata' instance to get its C type.\n        \"\"\"\n        if isinstance(cdecl, basestring):\n            return self._typeof(cdecl)\n        if isinstance(cdecl, self.CData):\n            return self._backend.typeof(cdecl)\n        if isinstance(cdecl, types.BuiltinFunctionType):\n            res = _builtin_function_type(cdecl)\n            if res is not None:\n                return res\n        if (isinstance(cdecl, types.FunctionType)\n                and hasattr(cdecl, '_cffi_base_type')):\n            with self._lock:\n                return self._get_cached_btype(cdecl._cffi_base_type)\n        raise TypeError(type(cdecl))\n\n    def sizeof(self, cdecl):\n        \"\"\"Return the size in bytes of the argument.  It can be a\n        string naming a C type, or a 'cdata' instance.\n        \"\"\"\n        if isinstance(cdecl, basestring):\n            BType = self._typeof(cdecl)\n            return self._backend.sizeof(BType)\n        else:\n            return self._backend.sizeof(cdecl)\n\n    def alignof(self, cdecl):\n        \"\"\"Return the natural alignment size in bytes of the C type\n        given as a string.\n        \"\"\"\n        if isinstance(cdecl, basestring):\n            cdecl = self._typeof(cdecl)\n        return self._backend.alignof(cdecl)\n\n    def offsetof(self, cdecl, *fields_or_indexes):\n        \"\"\"Return the offset of the named field inside the given\n        structure or array, which must be given as a C type name.  \n        You can give several field names in case of nested structures.\n        You can also give numeric values which correspond to array\n        items, in case of an array type.\n        \"\"\"\n        if isinstance(cdecl, basestring):\n            cdecl = self._typeof(cdecl)\n        return self._typeoffsetof(cdecl, *fields_or_indexes)[1]\n\n    def new(self, cdecl, init=None):\n        \"\"\"Allocate an instance according to the specified C type and\n        return a pointer to it.  The specified C type must be either a\n        pointer or an array: ``new('X *')`` allocates an X and returns\n        a pointer to it, whereas ``new('X[n]')`` allocates an array of\n        n X'es and returns an array referencing it (which works\n        mostly like a pointer, like in C).  You can also use\n        ``new('X[]', n)`` to allocate an array of a non-constant\n        length n.\n\n        The memory is initialized following the rules of declaring a\n        global variable in C: by default it is zero-initialized, but\n        an explicit initializer can be given which can be used to\n        fill all or part of the memory.\n\n        When the returned <cdata> object goes out of scope, the memory\n        is freed.  In other words the returned <cdata> object has\n        ownership of the value of type 'cdecl' that it points to.  This\n        means that the raw data can be used as long as this object is\n        kept alive, but must not be used for a longer time.  Be careful\n        about that when copying the pointer to the memory somewhere\n        else, e.g. into another structure.\n        \"\"\"\n        if isinstance(cdecl, basestring):\n            cdecl = self._typeof(cdecl)\n        return self._backend.newp(cdecl, init)\n\n    def cast(self, cdecl, source):\n        \"\"\"Similar to a C cast: returns an instance of the named C\n        type initialized with the given 'source'.  The source is\n        casted between integers or pointers of any type.\n        \"\"\"\n        if isinstance(cdecl, basestring):\n            cdecl = self._typeof(cdecl)\n        return self._backend.cast(cdecl, source)\n\n    def string(self, cdata, maxlen=-1):\n        \"\"\"Return a Python string (or unicode string) from the 'cdata'.\n        If 'cdata' is a pointer or array of characters or bytes, returns\n        the null-terminated string.  The returned string extends until\n        the first null character, or at most 'maxlen' characters.  If\n        'cdata' is an array then 'maxlen' defaults to its length.\n\n        If 'cdata' is a pointer or array of wchar_t, returns a unicode\n        string following the same rules.\n\n        If 'cdata' is a single character or byte or a wchar_t, returns\n        it as a string or unicode string.\n\n        If 'cdata' is an enum, returns the value of the enumerator as a\n        string, or 'NUMBER' if the value is out of range.\n        \"\"\"\n        return self._backend.string(cdata, maxlen)\n\n    def buffer(self, cdata, size=-1):\n        \"\"\"Return a read-write buffer object that references the raw C data\n        pointed to by the given 'cdata'.  The 'cdata' must be a pointer or\n        an array.  Can be passed to functions expecting a buffer, or directly\n        manipulated with:\n\n            buf[:]          get a copy of it in a regular string, or\n            buf[idx]        as a single character\n            buf[:] = ...\n            buf[idx] = ...  change the content\n        \"\"\"\n        return self._backend.buffer(cdata, size)\n\n    def from_buffer(self, python_buffer):\n        \"\"\"Return a <cdata 'char[]'> that points to the data of the\n        given Python object, which must support the buffer interface.\n        Note that this is not meant to be used on the built-in types str,\n        unicode, or bytearray (you can build 'char[]' arrays explicitly)\n        but only on objects containing large quantities of raw data\n        in some other format, like 'array.array' or numpy arrays.\n        \"\"\"\n        return self._backend.from_buffer(self.BCharA, python_buffer)\n\n    def callback(self, cdecl, python_callable=None, error=None):\n        \"\"\"Return a callback object or a decorator making such a\n        callback object.  'cdecl' must name a C function pointer type.\n        The callback invokes the specified 'python_callable' (which may\n        be provided either directly or via a decorator).  Important: the\n        callback object must be manually kept alive for as long as the\n        callback may be invoked from the C level.\n        \"\"\"\n        def callback_decorator_wrap(python_callable):\n            if not callable(python_callable):\n                raise TypeError(\"the 'python_callable' argument \"\n                                \"is not callable\")\n            return self._backend.callback(cdecl, python_callable, error)\n        if isinstance(cdecl, basestring):\n            cdecl = self._typeof(cdecl, consider_function_as_funcptr=True)\n        if python_callable is None:\n            return callback_decorator_wrap                # decorator mode\n        else:\n            return callback_decorator_wrap(python_callable)  # direct mode\n\n    def getctype(self, cdecl, replace_with=''):\n        \"\"\"Return a string giving the C type 'cdecl', which may be itself\n        a string or a <ctype> object.  If 'replace_with' is given, it gives\n        extra text to append (or insert for more complicated C types), like\n        a variable name, or '*' to get actually the C type 'pointer-to-cdecl'.\n        \"\"\"\n        if isinstance(cdecl, basestring):\n            cdecl = self._typeof(cdecl)\n        replace_with = replace_with.strip()\n        if (replace_with.startswith('*')\n                and '&[' in self._backend.getcname(cdecl, '&')):\n            replace_with = '(%s)' % replace_with\n        elif replace_with and not replace_with[0] in '[(':\n            replace_with = ' ' + replace_with\n        return self._backend.getcname(cdecl, replace_with)\n\n    def gc(self, cdata, destructor):\n        \"\"\"Return a new cdata object that points to the same\n        data.  Later, when this new cdata object is garbage-collected,\n        'destructor(old_cdata_object)' will be called.\n        \"\"\"\n        with self._lock:\n            try:\n                gc_weakrefs = self.gc_weakrefs\n            except AttributeError:\n                from .gc_weakref import GcWeakrefs\n                gc_weakrefs = self.gc_weakrefs = GcWeakrefs(self)\n            return gc_weakrefs.build(cdata, destructor)\n\n    def _get_cached_btype(self, type):\n        assert self._lock.acquire(False) is False\n        # call me with the lock!\n        try:\n            BType = self._cached_btypes[type]\n        except KeyError:\n            finishlist = []\n            BType = type.get_cached_btype(self, finishlist)\n            for type in finishlist:\n                type.finish_backend_type(self, finishlist)\n        return BType\n\n    def verify(self, source='', tmpdir=None, **kwargs):\n        \"\"\"Verify that the current ffi signatures compile on this\n        machine, and return a dynamic library object.  The dynamic\n        library can be used to call functions and access global\n        variables declared in this 'ffi'.  The library is compiled\n        by the C compiler: it gives you C-level API compatibility\n        (including calling macros).  This is unlike 'ffi.dlopen()',\n        which requires binary compatibility in the signatures.\n        \"\"\"\n        from .verifier import Verifier, _caller_dir_pycache\n        #\n        # If set_unicode(True) was called, insert the UNICODE and\n        # _UNICODE macro declarations\n        if self._windows_unicode:\n            self._apply_windows_unicode(kwargs)\n        #\n        # Set the tmpdir here, and not in Verifier.__init__: it picks\n        # up the caller's directory, which we want to be the caller of\n        # ffi.verify(), as opposed to the caller of Veritier().\n        tmpdir = tmpdir or _caller_dir_pycache()\n        #\n        # Make a Verifier() and use it to load the library.\n        self.verifier = Verifier(self, source, tmpdir, **kwargs)\n        lib = self.verifier.load_library()\n        #\n        # Save the loaded library for keep-alive purposes, even\n        # if the caller doesn't keep it alive itself (it should).\n        self._libraries.append(lib)\n        return lib\n\n    def _get_errno(self):\n        return self._backend.get_errno()\n    def _set_errno(self, errno):\n        self._backend.set_errno(errno)\n    errno = property(_get_errno, _set_errno, None,\n                     \"the value of 'errno' from/to the C calls\")\n\n    def getwinerror(self, code=-1):\n        return self._backend.getwinerror(code)\n\n    def _pointer_to(self, ctype):\n        from . import model\n        with self._lock:\n            return model.pointer_cache(self, ctype)\n\n    def addressof(self, cdata, *fields_or_indexes):\n        \"\"\"Return the address of a <cdata 'struct-or-union'>.\n        If 'fields_or_indexes' are given, returns the address of that\n        field or array item in the structure or array, recursively in\n        case of nested structures.\n        \"\"\"\n        ctype = self._backend.typeof(cdata)\n        if fields_or_indexes:\n            ctype, offset = self._typeoffsetof(ctype, *fields_or_indexes)\n        else:\n            if ctype.kind == \"pointer\":\n                raise TypeError(\"addressof(pointer)\")\n            offset = 0\n        ctypeptr = self._pointer_to(ctype)\n        return self._backend.rawaddressof(ctypeptr, cdata, offset)\n\n    def _typeoffsetof(self, ctype, field_or_index, *fields_or_indexes):\n        ctype, offset = self._backend.typeoffsetof(ctype, field_or_index)\n        for field1 in fields_or_indexes:\n            ctype, offset1 = self._backend.typeoffsetof(ctype, field1, 1)\n            offset += offset1\n        return ctype, offset\n\n    def include(self, ffi_to_include):\n        \"\"\"Includes the typedefs, structs, unions and enums defined\n        in another FFI instance.  Usage is similar to a #include in C,\n        where a part of the program might include types defined in\n        another part for its own usage.  Note that the include()\n        method has no effect on functions, constants and global\n        variables, which must anyway be accessed directly from the\n        lib object returned by the original FFI instance.\n        \"\"\"\n        if not isinstance(ffi_to_include, FFI):\n            raise TypeError(\"ffi.include() expects an argument that is also of\"\n                            \" type cffi.FFI, not %r\" % (\n                                type(ffi_to_include).__name__,))\n        with ffi_to_include._lock:\n            with self._lock:\n                self._parser.include(ffi_to_include._parser)\n                self._cdefsources.append('[')\n                self._cdefsources.extend(ffi_to_include._cdefsources)\n                self._cdefsources.append(']')\n                self._included_ffis.append(ffi_to_include)\n\n    def new_handle(self, x):\n        return self._backend.newp_handle(self.BVoidP, x)\n\n    def from_handle(self, x):\n        return self._backend.from_handle(x)\n\n    def set_unicode(self, enabled_flag):\n        \"\"\"Windows: if 'enabled_flag' is True, enable the UNICODE and\n        _UNICODE defines in C, and declare the types like TCHAR and LPTCSTR\n        to be (pointers to) wchar_t.  If 'enabled_flag' is False,\n        declare these types to be (pointers to) plain 8-bit characters.\n        This is mostly for backward compatibility; you usually want True.\n        \"\"\"\n        if self._windows_unicode is not None:\n            raise ValueError(\"set_unicode() can only be called once\")\n        enabled_flag = bool(enabled_flag)\n        if enabled_flag:\n            self.cdef(\"typedef wchar_t TBYTE;\"\n                      \"typedef wchar_t TCHAR;\"\n                      \"typedef const wchar_t *LPCTSTR;\"\n                      \"typedef const wchar_t *PCTSTR;\"\n                      \"typedef wchar_t *LPTSTR;\"\n                      \"typedef wchar_t *PTSTR;\"\n                      \"typedef TBYTE *PTBYTE;\"\n                      \"typedef TCHAR *PTCHAR;\")\n        else:\n            self.cdef(\"typedef char TBYTE;\"\n                      \"typedef char TCHAR;\"\n                      \"typedef const char *LPCTSTR;\"\n                      \"typedef const char *PCTSTR;\"\n                      \"typedef char *LPTSTR;\"\n                      \"typedef char *PTSTR;\"\n                      \"typedef TBYTE *PTBYTE;\"\n                      \"typedef TCHAR *PTCHAR;\")\n        self._windows_unicode = enabled_flag\n\n    def _apply_windows_unicode(self, kwds):\n        defmacros = kwds.get('define_macros', ())\n        if not isinstance(defmacros, (list, tuple)):\n            raise TypeError(\"'define_macros' must be a list or tuple\")\n        defmacros = list(defmacros) + [('UNICODE', '1'),\n                                       ('_UNICODE', '1')]\n        kwds['define_macros'] = defmacros\n\n    def set_source(self, module_name, source, source_extension='.c', **kwds):\n        if hasattr(self, '_assigned_source'):\n            raise ValueError(\"set_source() cannot be called several times \"\n                             \"per ffi object\")\n        if not isinstance(module_name, basestring):\n            raise TypeError(\"'module_name' must be a string\")\n        self._assigned_source = (str(module_name), source,\n                                 source_extension, kwds)\n\n    def distutils_extension(self, tmpdir='build', verbose=True):\n        from distutils.dir_util import mkpath\n        from .recompiler import recompile\n        #\n        if not hasattr(self, '_assigned_source'):\n            if hasattr(self, 'verifier'):     # fallback, 'tmpdir' ignored\n                return self.verifier.get_extension()\n            raise ValueError(\"set_source() must be called before\"\n                             \" distutils_extension()\")\n        module_name, source, source_extension, kwds = self._assigned_source\n        if source is None:\n            raise TypeError(\"distutils_extension() is only for C extension \"\n                            \"modules, not for dlopen()-style pure Python \"\n                            \"modules\")\n        mkpath(tmpdir)\n        ext, updated = recompile(self, module_name,\n                                 source, tmpdir=tmpdir, extradir=tmpdir,\n                                 source_extension=source_extension,\n                                 call_c_compiler=False, **kwds)\n        if verbose:\n            if updated:\n                sys.stderr.write(\"regenerated: %r\\n\" % (ext.sources[0],))\n            else:\n                sys.stderr.write(\"not modified: %r\\n\" % (ext.sources[0],))\n        return ext\n\n    def emit_c_code(self, filename):\n        from .recompiler import recompile\n        #\n        if not hasattr(self, '_assigned_source'):\n            raise ValueError(\"set_source() must be called before emit_c_code()\")\n        module_name, source, source_extension, kwds = self._assigned_source\n        if source is None:\n            raise TypeError(\"emit_c_code() is only for C extension modules, \"\n                            \"not for dlopen()-style pure Python modules\")\n        recompile(self, module_name, source,\n                  c_file=filename, call_c_compiler=False, **kwds)\n\n    def emit_python_code(self, filename):\n        from .recompiler import recompile\n        #\n        if not hasattr(self, '_assigned_source'):\n            raise ValueError(\"set_source() must be called before emit_c_code()\")\n        module_name, source, source_extension, kwds = self._assigned_source\n        if source is not None:\n            raise TypeError(\"emit_python_code() is only for dlopen()-style \"\n                            \"pure Python modules, not for C extension modules\")\n        recompile(self, module_name, source,\n                  c_file=filename, call_c_compiler=False, **kwds)\n\n    def compile(self, tmpdir='.'):\n        from .recompiler import recompile\n        #\n        if not hasattr(self, '_assigned_source'):\n            raise ValueError(\"set_source() must be called before compile()\")\n        module_name, source, source_extension, kwds = self._assigned_source\n        return recompile(self, module_name, source, tmpdir=tmpdir,\n                         source_extension=source_extension, **kwds)\n\n\ndef _load_backend_lib(backend, name, flags):\n    if name is None:\n        if sys.platform != \"win32\":\n            return backend.load_library(None, flags)\n        name = \"c\"    # Windows: load_library(None) fails, but this works\n                      # (backward compatibility hack only)\n    try:\n        if '.' not in name and '/' not in name:\n            raise OSError(\"library not found: %r\" % (name,))\n        return backend.load_library(name, flags)\n    except OSError:\n        import ctypes.util\n        path = ctypes.util.find_library(name)\n        if path is None:\n            raise     # propagate the original OSError\n        return backend.load_library(path, flags)\n\ndef _make_ffi_library(ffi, libname, flags):\n    import os\n    backend = ffi._backend\n    backendlib = _load_backend_lib(backend, libname, flags)\n    copied_enums = []\n    #\n    def make_accessor_locked(name):\n        key = 'function ' + name\n        if key in ffi._parser._declarations:\n            tp = ffi._parser._declarations[key]\n            BType = ffi._get_cached_btype(tp)\n            try:\n                value = backendlib.load_function(BType, name)\n            except KeyError as e:\n                raise AttributeError('%s: %s' % (name, e))\n            library.__dict__[name] = value\n            return\n        #\n        key = 'variable ' + name\n        if key in ffi._parser._declarations:\n            tp = ffi._parser._declarations[key]\n            BType = ffi._get_cached_btype(tp)\n            read_variable = backendlib.read_variable\n            write_variable = backendlib.write_variable\n            setattr(FFILibrary, name, property(\n                lambda self: read_variable(BType, name),\n                lambda self, value: write_variable(BType, name, value)))\n            return\n        #\n        if not copied_enums:\n            from . import model\n            for key, tp in ffi._parser._declarations.items():\n                if not isinstance(tp, model.EnumType):\n                    continue\n                for enumname, enumval in zip(tp.enumerators, tp.enumvalues):\n                    if enumname not in library.__dict__:\n                        library.__dict__[enumname] = enumval\n            for key, val in ffi._parser._int_constants.items():\n                if key not in library.__dict__:\n                    library.__dict__[key] = val\n\n            copied_enums.append(True)\n            if name in library.__dict__:\n                return\n        #\n        key = 'constant ' + name\n        if key in ffi._parser._declarations:\n            raise NotImplementedError(\"fetching a non-integer constant \"\n                                      \"after dlopen()\")\n        #\n        raise AttributeError(name)\n    #\n    def make_accessor(name):\n        with ffi._lock:\n            if name in library.__dict__ or name in FFILibrary.__dict__:\n                return    # added by another thread while waiting for the lock\n            make_accessor_locked(name)\n    #\n    class FFILibrary(object):\n        def __getattr__(self, name):\n            make_accessor(name)\n            return getattr(self, name)\n        def __setattr__(self, name, value):\n            try:\n                property = getattr(self.__class__, name)\n            except AttributeError:\n                make_accessor(name)\n                setattr(self, name, value)\n            else:\n                property.__set__(self, value)\n    #\n    if libname is not None:\n        try:\n            if not isinstance(libname, str):    # unicode, on Python 2\n                libname = libname.encode('utf-8')\n            FFILibrary.__name__ = 'FFILibrary_%s' % libname\n        except UnicodeError:\n            pass\n    library = FFILibrary()\n    return library, library.__dict__\n\ndef _builtin_function_type(func):\n    # a hack to make at least ffi.typeof(builtin_function) work,\n    # if the builtin function was obtained by 'vengine_cpy'.\n    import sys\n    try:\n        module = sys.modules[func.__module__]\n        ffi = module._cffi_original_ffi\n        types_of_builtin_funcs = module._cffi_types_of_builtin_funcs\n        tp = types_of_builtin_funcs[func]\n    except (KeyError, AttributeError, TypeError):\n        return None\n    else:\n        with ffi._lock:\n            return ffi._get_cached_btype(tp)\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.1.2-nak3eqkxfunb4z5owzsqogchnaejp7o4/spack-src/cffi/vengine_cpy.py": "import sys, imp\nfrom . import model, ffiplatform\n\n\nclass VCPythonEngine(object):\n    _class_key = 'x'\n    _gen_python_module = True\n\n    def __init__(self, verifier):\n        self.verifier = verifier\n        self.ffi = verifier.ffi\n        self._struct_pending_verification = {}\n        self._types_of_builtin_functions = {}\n\n    def patch_extension_kwds(self, kwds):\n        pass\n\n    def find_module(self, module_name, path, so_suffixes):\n        try:\n            f, filename, descr = imp.find_module(module_name, path)\n        except ImportError:\n            return None\n        if f is not None:\n            f.close()\n        # Note that after a setuptools installation, there are both .py\n        # and .so files with the same basename.  The code here relies on\n        # imp.find_module() locating the .so in priority.\n        if descr[0] not in so_suffixes:\n            return None\n        return filename\n\n    def collect_types(self):\n        self._typesdict = {}\n        self._generate(\"collecttype\")\n\n    def _prnt(self, what=''):\n        self._f.write(what + '\\n')\n\n    def _gettypenum(self, type):\n        # a KeyError here is a bug.  please report it! :-)\n        return self._typesdict[type]\n\n    def _do_collect_type(self, tp):\n        if ((not isinstance(tp, model.PrimitiveType)\n             or tp.name == 'long double')\n                and tp not in self._typesdict):\n            num = len(self._typesdict)\n            self._typesdict[tp] = num\n\n    def write_source_to_f(self):\n        self.collect_types()\n        #\n        # The new module will have a _cffi_setup() function that receives\n        # objects from the ffi world, and that calls some setup code in\n        # the module.  This setup code is split in several independent\n        # functions, e.g. one per constant.  The functions are \"chained\"\n        # by ending in a tail call to each other.\n        #\n        # This is further split in two chained lists, depending on if we\n        # can do it at import-time or if we must wait for _cffi_setup() to\n        # provide us with the <ctype> objects.  This is needed because we\n        # need the values of the enum constants in order to build the\n        # <ctype 'enum'> that we may have to pass to _cffi_setup().\n        #\n        # The following two 'chained_list_constants' items contains\n        # the head of these two chained lists, as a string that gives the\n        # call to do, if any.\n        self._chained_list_constants = ['((void)lib,0)', '((void)lib,0)']\n        #\n        prnt = self._prnt\n        # first paste some standard set of lines that are mostly '#define'\n        prnt(cffimod_header)\n        prnt()\n        # then paste the C source given by the user, verbatim.\n        prnt(self.verifier.preamble)\n        prnt()\n        #\n        # call generate_cpy_xxx_decl(), for every xxx found from\n        # ffi._parser._declarations.  This generates all the functions.\n        self._generate(\"decl\")\n        #\n        # implement the function _cffi_setup_custom() as calling the\n        # head of the chained list.\n        self._generate_setup_custom()\n        prnt()\n        #\n        # produce the method table, including the entries for the\n        # generated Python->C function wrappers, which are done\n        # by generate_cpy_function_method().\n        prnt('static PyMethodDef _cffi_methods[] = {')\n        self._generate(\"method\")\n        prnt('  {\"_cffi_setup\", _cffi_setup, METH_VARARGS, NULL},')\n        prnt('  {NULL, NULL, 0, NULL}    /* Sentinel */')\n        prnt('};')\n        prnt()\n        #\n        # standard init.\n        modname = self.verifier.get_module_name()\n        constants = self._chained_list_constants[False]\n        prnt('#if PY_MAJOR_VERSION >= 3')\n        prnt()\n        prnt('static struct PyModuleDef _cffi_module_def = {')\n        prnt('  PyModuleDef_HEAD_INIT,')\n        prnt('  \"%s\",' % modname)\n        prnt('  NULL,')\n        prnt('  -1,')\n        prnt('  _cffi_methods,')\n        prnt('  NULL, NULL, NULL, NULL')\n        prnt('};')\n        prnt()\n        prnt('PyMODINIT_FUNC')\n        prnt('PyInit_%s(void)' % modname)\n        prnt('{')\n        prnt('  PyObject *lib;')\n        prnt('  lib = PyModule_Create(&_cffi_module_def);')\n        prnt('  if (lib == NULL)')\n        prnt('    return NULL;')\n        prnt('  if (%s < 0 || _cffi_init() < 0) {' % (constants,))\n        prnt('    Py_DECREF(lib);')\n        prnt('    return NULL;')\n        prnt('  }')\n        prnt('  return lib;')\n        prnt('}')\n        prnt()\n        prnt('#else')\n        prnt()\n        prnt('PyMODINIT_FUNC')\n        prnt('init%s(void)' % modname)\n        prnt('{')\n        prnt('  PyObject *lib;')\n        prnt('  lib = Py_InitModule(\"%s\", _cffi_methods);' % modname)\n        prnt('  if (lib == NULL)')\n        prnt('    return;')\n        prnt('  if (%s < 0 || _cffi_init() < 0)' % (constants,))\n        prnt('    return;')\n        prnt('  return;')\n        prnt('}')\n        prnt()\n        prnt('#endif')\n\n    def load_library(self, flags=None):\n        # XXX review all usages of 'self' here!\n        # import it as a new extension module\n        imp.acquire_lock()\n        try:\n            if hasattr(sys, \"getdlopenflags\"):\n                previous_flags = sys.getdlopenflags()\n            try:\n                if hasattr(sys, \"setdlopenflags\") and flags is not None:\n                    sys.setdlopenflags(flags)\n                module = imp.load_dynamic(self.verifier.get_module_name(),\n                                          self.verifier.modulefilename)\n            except ImportError as e:\n                error = \"importing %r: %s\" % (self.verifier.modulefilename, e)\n                raise ffiplatform.VerificationError(error)\n            finally:\n                if hasattr(sys, \"setdlopenflags\"):\n                    sys.setdlopenflags(previous_flags)\n        finally:\n            imp.release_lock()\n        #\n        # call loading_cpy_struct() to get the struct layout inferred by\n        # the C compiler\n        self._load(module, 'loading')\n        #\n        # the C code will need the <ctype> objects.  Collect them in\n        # order in a list.\n        revmapping = dict([(value, key)\n                           for (key, value) in self._typesdict.items()])\n        lst = [revmapping[i] for i in range(len(revmapping))]\n        lst = list(map(self.ffi._get_cached_btype, lst))\n        #\n        # build the FFILibrary class and instance and call _cffi_setup().\n        # this will set up some fields like '_cffi_types', and only then\n        # it will invoke the chained list of functions that will really\n        # build (notably) the constant objects, as <cdata> if they are\n        # pointers, and store them as attributes on the 'library' object.\n        class FFILibrary(object):\n            _cffi_python_module = module\n            _cffi_ffi = self.ffi\n            _cffi_dir = []\n            def __dir__(self):\n                return FFILibrary._cffi_dir + list(self.__dict__)\n        library = FFILibrary()\n        if module._cffi_setup(lst, ffiplatform.VerificationError, library):\n            import warnings\n            warnings.warn(\"reimporting %r might overwrite older definitions\"\n                          % (self.verifier.get_module_name()))\n        #\n        # finally, call the loaded_cpy_xxx() functions.  This will perform\n        # the final adjustments, like copying the Python->C wrapper\n        # functions from the module to the 'library' object, and setting\n        # up the FFILibrary class with properties for the global C variables.\n        self._load(module, 'loaded', library=library)\n        module._cffi_original_ffi = self.ffi\n        module._cffi_types_of_builtin_funcs = self._types_of_builtin_functions\n        return library\n\n    def _get_declarations(self):\n        return sorted(self.ffi._parser._declarations.items())\n\n    def _generate(self, step_name):\n        for name, tp in self._get_declarations():\n            kind, realname = name.split(' ', 1)\n            try:\n                method = getattr(self, '_generate_cpy_%s_%s' % (kind,\n                                                                step_name))\n            except AttributeError:\n                raise ffiplatform.VerificationError(\n                    \"not implemented in verify(): %r\" % name)\n            try:\n                method(tp, realname)\n            except Exception as e:\n                model.attach_exception_info(e, name)\n                raise\n\n    def _load(self, module, step_name, **kwds):\n        for name, tp in self._get_declarations():\n            kind, realname = name.split(' ', 1)\n            method = getattr(self, '_%s_cpy_%s' % (step_name, kind))\n            try:\n                method(tp, realname, module, **kwds)\n            except Exception as e:\n                model.attach_exception_info(e, name)\n                raise\n\n    def _generate_nothing(self, tp, name):\n        pass\n\n    def _loaded_noop(self, tp, name, module, **kwds):\n        pass\n\n    # ----------\n\n    def _convert_funcarg_to_c(self, tp, fromvar, tovar, errcode):\n        extraarg = ''\n        if isinstance(tp, model.PrimitiveType):\n            if tp.is_integer_type() and tp.name != '_Bool':\n                converter = '_cffi_to_c_int'\n                extraarg = ', %s' % tp.name\n            else:\n                converter = '(%s)_cffi_to_c_%s' % (tp.get_c_name(''),\n                                                   tp.name.replace(' ', '_'))\n            errvalue = '-1'\n        #\n        elif isinstance(tp, model.PointerType):\n            self._convert_funcarg_to_c_ptr_or_array(tp, fromvar,\n                                                    tovar, errcode)\n            return\n        #\n        elif isinstance(tp, (model.StructOrUnion, model.EnumType)):\n            # a struct (not a struct pointer) as a function argument\n            self._prnt('  if (_cffi_to_c((char *)&%s, _cffi_type(%d), %s) < 0)'\n                      % (tovar, self._gettypenum(tp), fromvar))\n            self._prnt('    %s;' % errcode)\n            return\n        #\n        elif isinstance(tp, model.FunctionPtrType):\n            converter = '(%s)_cffi_to_c_pointer' % tp.get_c_name('')\n            extraarg = ', _cffi_type(%d)' % self._gettypenum(tp)\n            errvalue = 'NULL'\n        #\n        else:\n            raise NotImplementedError(tp)\n        #\n        self._prnt('  %s = %s(%s%s);' % (tovar, converter, fromvar, extraarg))\n        self._prnt('  if (%s == (%s)%s && PyErr_Occurred())' % (\n            tovar, tp.get_c_name(''), errvalue))\n        self._prnt('    %s;' % errcode)\n\n    def _extra_local_variables(self, tp, localvars):\n        if isinstance(tp, model.PointerType):\n            localvars.add('Py_ssize_t datasize')\n\n    def _convert_funcarg_to_c_ptr_or_array(self, tp, fromvar, tovar, errcode):\n        self._prnt('  datasize = _cffi_prepare_pointer_call_argument(')\n        self._prnt('      _cffi_type(%d), %s, (char **)&%s);' % (\n            self._gettypenum(tp), fromvar, tovar))\n        self._prnt('  if (datasize != 0) {')\n        self._prnt('    if (datasize < 0)')\n        self._prnt('      %s;' % errcode)\n        self._prnt('    %s = alloca((size_t)datasize);' % (tovar,))\n        self._prnt('    memset((void *)%s, 0, (size_t)datasize);' % (tovar,))\n        self._prnt('    if (_cffi_convert_array_from_object('\n                   '(char *)%s, _cffi_type(%d), %s) < 0)' % (\n            tovar, self._gettypenum(tp), fromvar))\n        self._prnt('      %s;' % errcode)\n        self._prnt('  }')\n\n    def _convert_expr_from_c(self, tp, var, context):\n        if isinstance(tp, model.PrimitiveType):\n            if tp.is_integer_type():\n                return '_cffi_from_c_int(%s, %s)' % (var, tp.name)\n            elif tp.name != 'long double':\n                return '_cffi_from_c_%s(%s)' % (tp.name.replace(' ', '_'), var)\n            else:\n                return '_cffi_from_c_deref((char *)&%s, _cffi_type(%d))' % (\n                    var, self._gettypenum(tp))\n        elif isinstance(tp, (model.PointerType, model.FunctionPtrType)):\n            return '_cffi_from_c_pointer((char *)%s, _cffi_type(%d))' % (\n                var, self._gettypenum(tp))\n        elif isinstance(tp, model.ArrayType):\n            return '_cffi_from_c_pointer((char *)%s, _cffi_type(%d))' % (\n                var, self._gettypenum(model.PointerType(tp.item)))\n        elif isinstance(tp, model.StructType):\n            if tp.fldnames is None:\n                raise TypeError(\"'%s' is used as %s, but is opaque\" % (\n                    tp._get_c_name(), context))\n            return '_cffi_from_c_struct((char *)&%s, _cffi_type(%d))' % (\n                var, self._gettypenum(tp))\n        elif isinstance(tp, model.EnumType):\n            return '_cffi_from_c_deref((char *)&%s, _cffi_type(%d))' % (\n                var, self._gettypenum(tp))\n        else:\n            raise NotImplementedError(tp)\n\n    # ----------\n    # typedefs: generates no code so far\n\n    _generate_cpy_typedef_collecttype = _generate_nothing\n    _generate_cpy_typedef_decl   = _generate_nothing\n    _generate_cpy_typedef_method = _generate_nothing\n    _loading_cpy_typedef         = _loaded_noop\n    _loaded_cpy_typedef          = _loaded_noop\n\n    # ----------\n    # function declarations\n\n    def _generate_cpy_function_collecttype(self, tp, name):\n        assert isinstance(tp, model.FunctionPtrType)\n        if tp.ellipsis:\n            self._do_collect_type(tp)\n        else:\n            # don't call _do_collect_type(tp) in this common case,\n            # otherwise test_autofilled_struct_as_argument fails\n            for type in tp.args:\n                self._do_collect_type(type)\n            self._do_collect_type(tp.result)\n\n    def _generate_cpy_function_decl(self, tp, name):\n        assert isinstance(tp, model.FunctionPtrType)\n        if tp.ellipsis:\n            # cannot support vararg functions better than this: check for its\n            # exact type (including the fixed arguments), and build it as a\n            # constant function pointer (no CPython wrapper)\n            self._generate_cpy_const(False, name, tp)\n            return\n        prnt = self._prnt\n        numargs = len(tp.args)\n        if numargs == 0:\n            argname = 'noarg'\n        elif numargs == 1:\n            argname = 'arg0'\n        else:\n            argname = 'args'\n        prnt('static PyObject *')\n        prnt('_cffi_f_%s(PyObject *self, PyObject *%s)' % (name, argname))\n        prnt('{')\n        #\n        context = 'argument of %s' % name\n        for i, type in enumerate(tp.args):\n            prnt('  %s;' % type.get_c_name(' x%d' % i, context))\n        #\n        localvars = set()\n        for type in tp.args:\n            self._extra_local_variables(type, localvars)\n        for decl in localvars:\n            prnt('  %s;' % (decl,))\n        #\n        if not isinstance(tp.result, model.VoidType):\n            result_code = 'result = '\n            context = 'result of %s' % name\n            prnt('  %s;' % tp.result.get_c_name(' result', context))\n        else:\n            result_code = ''\n        #\n        if len(tp.args) > 1:\n            rng = range(len(tp.args))\n            for i in rng:\n                prnt('  PyObject *arg%d;' % i)\n            prnt()\n            prnt('  if (!PyArg_ParseTuple(args, \"%s:%s\", %s))' % (\n                'O' * numargs, name, ', '.join(['&arg%d' % i for i in rng])))\n            prnt('    return NULL;')\n        prnt()\n        #\n        for i, type in enumerate(tp.args):\n            self._convert_funcarg_to_c(type, 'arg%d' % i, 'x%d' % i,\n                                       'return NULL')\n            prnt()\n        #\n        prnt('  Py_BEGIN_ALLOW_THREADS')\n        prnt('  _cffi_restore_errno();')\n        prnt('  { %s%s(%s); }' % (\n            result_code, name,\n            ', '.join(['x%d' % i for i in range(len(tp.args))])))\n        prnt('  _cffi_save_errno();')\n        prnt('  Py_END_ALLOW_THREADS')\n        prnt()\n        #\n        prnt('  (void)self; /* unused */')\n        if numargs == 0:\n            prnt('  (void)noarg; /* unused */')\n        if result_code:\n            prnt('  return %s;' %\n                 self._convert_expr_from_c(tp.result, 'result', 'result type'))\n        else:\n            prnt('  Py_INCREF(Py_None);')\n            prnt('  return Py_None;')\n        prnt('}')\n        prnt()\n\n    def _generate_cpy_function_method(self, tp, name):\n        if tp.ellipsis:\n            return\n        numargs = len(tp.args)\n        if numargs == 0:\n            meth = 'METH_NOARGS'\n        elif numargs == 1:\n            meth = 'METH_O'\n        else:\n            meth = 'METH_VARARGS'\n        self._prnt('  {\"%s\", _cffi_f_%s, %s, NULL},' % (name, name, meth))\n\n    _loading_cpy_function = _loaded_noop\n\n    def _loaded_cpy_function(self, tp, name, module, library):\n        if tp.ellipsis:\n            return\n        func = getattr(module, name)\n        setattr(library, name, func)\n        self._types_of_builtin_functions[func] = tp\n\n    # ----------\n    # named structs\n\n    _generate_cpy_struct_collecttype = _generate_nothing\n    def _generate_cpy_struct_decl(self, tp, name):\n        assert name == tp.name\n        self._generate_struct_or_union_decl(tp, 'struct', name)\n    def _generate_cpy_struct_method(self, tp, name):\n        self._generate_struct_or_union_method(tp, 'struct', name)\n    def _loading_cpy_struct(self, tp, name, module):\n        self._loading_struct_or_union(tp, 'struct', name, module)\n    def _loaded_cpy_struct(self, tp, name, module, **kwds):\n        self._loaded_struct_or_union(tp)\n\n    _generate_cpy_union_collecttype = _generate_nothing\n    def _generate_cpy_union_decl(self, tp, name):\n        assert name == tp.name\n        self._generate_struct_or_union_decl(tp, 'union', name)\n    def _generate_cpy_union_method(self, tp, name):\n        self._generate_struct_or_union_method(tp, 'union', name)\n    def _loading_cpy_union(self, tp, name, module):\n        self._loading_struct_or_union(tp, 'union', name, module)\n    def _loaded_cpy_union(self, tp, name, module, **kwds):\n        self._loaded_struct_or_union(tp)\n\n    def _generate_struct_or_union_decl(self, tp, prefix, name):\n        if tp.fldnames is None:\n            return     # nothing to do with opaque structs\n        checkfuncname = '_cffi_check_%s_%s' % (prefix, name)\n        layoutfuncname = '_cffi_layout_%s_%s' % (prefix, name)\n        cname = ('%s %s' % (prefix, name)).strip()\n        #\n        prnt = self._prnt\n        prnt('static void %s(%s *p)' % (checkfuncname, cname))\n        prnt('{')\n        prnt('  /* only to generate compile-time warnings or errors */')\n        prnt('  (void)p;')\n        for fname, ftype, fbitsize in tp.enumfields():\n            if (isinstance(ftype, model.PrimitiveType)\n                and ftype.is_integer_type()) or fbitsize >= 0:\n                # accept all integers, but complain on float or double\n                prnt('  (void)((p->%s) << 1);' % fname)\n            else:\n                # only accept exactly the type declared.\n                try:\n                    prnt('  { %s = &p->%s; (void)tmp; }' % (\n                        ftype.get_c_name('*tmp', 'field %r'%fname), fname))\n                except ffiplatform.VerificationError as e:\n                    prnt('  /* %s */' % str(e))   # cannot verify it, ignore\n        prnt('}')\n        prnt('static PyObject *')\n        prnt('%s(PyObject *self, PyObject *noarg)' % (layoutfuncname,))\n        prnt('{')\n        prnt('  struct _cffi_aligncheck { char x; %s y; };' % cname)\n        prnt('  static Py_ssize_t nums[] = {')\n        prnt('    sizeof(%s),' % cname)\n        prnt('    offsetof(struct _cffi_aligncheck, y),')\n        for fname, ftype, fbitsize in tp.enumfields():\n            if fbitsize >= 0:\n                continue      # xxx ignore fbitsize for now\n            prnt('    offsetof(%s, %s),' % (cname, fname))\n            if isinstance(ftype, model.ArrayType) and ftype.length is None:\n                prnt('    0,  /* %s */' % ftype._get_c_name())\n            else:\n                prnt('    sizeof(((%s *)0)->%s),' % (cname, fname))\n        prnt('    -1')\n        prnt('  };')\n        prnt('  (void)self; /* unused */')\n        prnt('  (void)noarg; /* unused */')\n        prnt('  return _cffi_get_struct_layout(nums);')\n        prnt('  /* the next line is not executed, but compiled */')\n        prnt('  %s(0);' % (checkfuncname,))\n        prnt('}')\n        prnt()\n\n    def _generate_struct_or_union_method(self, tp, prefix, name):\n        if tp.fldnames is None:\n            return     # nothing to do with opaque structs\n        layoutfuncname = '_cffi_layout_%s_%s' % (prefix, name)\n        self._prnt('  {\"%s\", %s, METH_NOARGS, NULL},' % (layoutfuncname,\n                                                         layoutfuncname))\n\n    def _loading_struct_or_union(self, tp, prefix, name, module):\n        if tp.fldnames is None:\n            return     # nothing to do with opaque structs\n        layoutfuncname = '_cffi_layout_%s_%s' % (prefix, name)\n        #\n        function = getattr(module, layoutfuncname)\n        layout = function()\n        if isinstance(tp, model.StructOrUnion) and tp.partial:\n            # use the function()'s sizes and offsets to guide the\n            # layout of the struct\n            totalsize = layout[0]\n            totalalignment = layout[1]\n            fieldofs = layout[2::2]\n            fieldsize = layout[3::2]\n            tp.force_flatten()\n            assert len(fieldofs) == len(fieldsize) == len(tp.fldnames)\n            tp.fixedlayout = fieldofs, fieldsize, totalsize, totalalignment\n        else:\n            cname = ('%s %s' % (prefix, name)).strip()\n            self._struct_pending_verification[tp] = layout, cname\n\n    def _loaded_struct_or_union(self, tp):\n        if tp.fldnames is None:\n            return     # nothing to do with opaque structs\n        self.ffi._get_cached_btype(tp)   # force 'fixedlayout' to be considered\n\n        if tp in self._struct_pending_verification:\n            # check that the layout sizes and offsets match the real ones\n            def check(realvalue, expectedvalue, msg):\n                if realvalue != expectedvalue:\n                    raise ffiplatform.VerificationError(\n                        \"%s (we have %d, but C compiler says %d)\"\n                        % (msg, expectedvalue, realvalue))\n            ffi = self.ffi\n            BStruct = ffi._get_cached_btype(tp)\n            layout, cname = self._struct_pending_verification.pop(tp)\n            check(layout[0], ffi.sizeof(BStruct), \"wrong total size\")\n            check(layout[1], ffi.alignof(BStruct), \"wrong total alignment\")\n            i = 2\n            for fname, ftype, fbitsize in tp.enumfields():\n                if fbitsize >= 0:\n                    continue        # xxx ignore fbitsize for now\n                check(layout[i], ffi.offsetof(BStruct, fname),\n                      \"wrong offset for field %r\" % (fname,))\n                if layout[i+1] != 0:\n                    BField = ffi._get_cached_btype(ftype)\n                    check(layout[i+1], ffi.sizeof(BField),\n                          \"wrong size for field %r\" % (fname,))\n                i += 2\n            assert i == len(layout)\n\n    # ----------\n    # 'anonymous' declarations.  These are produced for anonymous structs\n    # or unions; the 'name' is obtained by a typedef.\n\n    _generate_cpy_anonymous_collecttype = _generate_nothing\n\n    def _generate_cpy_anonymous_decl(self, tp, name):\n        if isinstance(tp, model.EnumType):\n            self._generate_cpy_enum_decl(tp, name, '')\n        else:\n            self._generate_struct_or_union_decl(tp, '', name)\n\n    def _generate_cpy_anonymous_method(self, tp, name):\n        if not isinstance(tp, model.EnumType):\n            self._generate_struct_or_union_method(tp, '', name)\n\n    def _loading_cpy_anonymous(self, tp, name, module):\n        if isinstance(tp, model.EnumType):\n            self._loading_cpy_enum(tp, name, module)\n        else:\n            self._loading_struct_or_union(tp, '', name, module)\n\n    def _loaded_cpy_anonymous(self, tp, name, module, **kwds):\n        if isinstance(tp, model.EnumType):\n            self._loaded_cpy_enum(tp, name, module, **kwds)\n        else:\n            self._loaded_struct_or_union(tp)\n\n    # ----------\n    # constants, likely declared with '#define'\n\n    def _generate_cpy_const(self, is_int, name, tp=None, category='const',\n                            vartp=None, delayed=True, size_too=False,\n                            check_value=None):\n        prnt = self._prnt\n        funcname = '_cffi_%s_%s' % (category, name)\n        prnt('static int %s(PyObject *lib)' % funcname)\n        prnt('{')\n        prnt('  PyObject *o;')\n        prnt('  int res;')\n        if not is_int:\n            prnt('  %s;' % (vartp or tp).get_c_name(' i', name))\n        else:\n            assert category == 'const'\n        #\n        if check_value is not None:\n            self._check_int_constant_value(name, check_value)\n        #\n        if not is_int:\n            if category == 'var':\n                realexpr = '&' + name\n            else:\n                realexpr = name\n            prnt('  i = (%s);' % (realexpr,))\n            prnt('  o = %s;' % (self._convert_expr_from_c(tp, 'i',\n                                                          'variable type'),))\n            assert delayed\n        else:\n            prnt('  o = _cffi_from_c_int_const(%s);' % name)\n        prnt('  if (o == NULL)')\n        prnt('    return -1;')\n        if size_too:\n            prnt('  {')\n            prnt('    PyObject *o1 = o;')\n            prnt('    o = Py_BuildValue(\"On\", o1, (Py_ssize_t)sizeof(%s));'\n                 % (name,))\n            prnt('    Py_DECREF(o1);')\n            prnt('    if (o == NULL)')\n            prnt('      return -1;')\n            prnt('  }')\n        prnt('  res = PyObject_SetAttrString(lib, \"%s\", o);' % name)\n        prnt('  Py_DECREF(o);')\n        prnt('  if (res < 0)')\n        prnt('    return -1;')\n        prnt('  return %s;' % self._chained_list_constants[delayed])\n        self._chained_list_constants[delayed] = funcname + '(lib)'\n        prnt('}')\n        prnt()\n\n    def _generate_cpy_constant_collecttype(self, tp, name):\n        is_int = isinstance(tp, model.PrimitiveType) and tp.is_integer_type()\n        if not is_int:\n            self._do_collect_type(tp)\n\n    def _generate_cpy_constant_decl(self, tp, name):\n        is_int = isinstance(tp, model.PrimitiveType) and tp.is_integer_type()\n        self._generate_cpy_const(is_int, name, tp)\n\n    _generate_cpy_constant_method = _generate_nothing\n    _loading_cpy_constant = _loaded_noop\n    _loaded_cpy_constant  = _loaded_noop\n\n    # ----------\n    # enums\n\n    def _check_int_constant_value(self, name, value, err_prefix=''):\n        prnt = self._prnt\n        if value <= 0:\n            prnt('  if ((%s) > 0 || (long)(%s) != %dL) {' % (\n                name, name, value))\n        else:\n            prnt('  if ((%s) <= 0 || (unsigned long)(%s) != %dUL) {' % (\n                name, name, value))\n        prnt('    char buf[64];')\n        prnt('    if ((%s) <= 0)' % name)\n        prnt('        snprintf(buf, 63, \"%%ld\", (long)(%s));' % name)\n        prnt('    else')\n        prnt('        snprintf(buf, 63, \"%%lu\", (unsigned long)(%s));' %\n             name)\n        prnt('    PyErr_Format(_cffi_VerificationError,')\n        prnt('                 \"%s%s has the real value %s, not %s\",')\n        prnt('                 \"%s\", \"%s\", buf, \"%d\");' % (\n            err_prefix, name, value))\n        prnt('    return -1;')\n        prnt('  }')\n\n    def _enum_funcname(self, prefix, name):\n        # \"$enum_$1\" => \"___D_enum____D_1\"\n        name = name.replace('$', '___D_')\n        return '_cffi_e_%s_%s' % (prefix, name)\n\n    def _generate_cpy_enum_decl(self, tp, name, prefix='enum'):\n        if tp.partial:\n            for enumerator in tp.enumerators:\n                self._generate_cpy_const(True, enumerator, delayed=False)\n            return\n        #\n        funcname = self._enum_funcname(prefix, name)\n        prnt = self._prnt\n        prnt('static int %s(PyObject *lib)' % funcname)\n        prnt('{')\n        for enumerator, enumvalue in zip(tp.enumerators, tp.enumvalues):\n            self._check_int_constant_value(enumerator, enumvalue,\n                                           \"enum %s: \" % name)\n        prnt('  return %s;' % self._chained_list_constants[True])\n        self._chained_list_constants[True] = funcname + '(lib)'\n        prnt('}')\n        prnt()\n\n    _generate_cpy_enum_collecttype = _generate_nothing\n    _generate_cpy_enum_method = _generate_nothing\n\n    def _loading_cpy_enum(self, tp, name, module):\n        if tp.partial:\n            enumvalues = [getattr(module, enumerator)\n                          for enumerator in tp.enumerators]\n            tp.enumvalues = tuple(enumvalues)\n            tp.partial_resolved = True\n\n    def _loaded_cpy_enum(self, tp, name, module, library):\n        for enumerator, enumvalue in zip(tp.enumerators, tp.enumvalues):\n            setattr(library, enumerator, enumvalue)\n\n    # ----------\n    # macros: for now only for integers\n\n    def _generate_cpy_macro_decl(self, tp, name):\n        if tp == '...':\n            check_value = None\n        else:\n            check_value = tp     # an integer\n        self._generate_cpy_const(True, name, check_value=check_value)\n\n    _generate_cpy_macro_collecttype = _generate_nothing\n    _generate_cpy_macro_method = _generate_nothing\n    _loading_cpy_macro = _loaded_noop\n    _loaded_cpy_macro  = _loaded_noop\n\n    # ----------\n    # global variables\n\n    def _generate_cpy_variable_collecttype(self, tp, name):\n        if isinstance(tp, model.ArrayType):\n            tp_ptr = model.PointerType(tp.item)\n        else:\n            tp_ptr = model.PointerType(tp)\n        self._do_collect_type(tp_ptr)\n\n    def _generate_cpy_variable_decl(self, tp, name):\n        if isinstance(tp, model.ArrayType):\n            tp_ptr = model.PointerType(tp.item)\n            self._generate_cpy_const(False, name, tp, vartp=tp_ptr,\n                                     size_too = (tp.length == '...'))\n        else:\n            tp_ptr = model.PointerType(tp)\n            self._generate_cpy_const(False, name, tp_ptr, category='var')\n\n    _generate_cpy_variable_method = _generate_nothing\n    _loading_cpy_variable = _loaded_noop\n\n    def _loaded_cpy_variable(self, tp, name, module, library):\n        value = getattr(library, name)\n        if isinstance(tp, model.ArrayType):   # int a[5] is \"constant\" in the\n                                              # sense that \"a=...\" is forbidden\n            if tp.length == '...':\n                assert isinstance(value, tuple)\n                (value, size) = value\n                BItemType = self.ffi._get_cached_btype(tp.item)\n                length, rest = divmod(size, self.ffi.sizeof(BItemType))\n                if rest != 0:\n                    raise ffiplatform.VerificationError(\n                        \"bad size: %r does not seem to be an array of %s\" %\n                        (name, tp.item))\n                tp = tp.resolve_length(length)\n            # 'value' is a <cdata 'type *'> which we have to replace with\n            # a <cdata 'type[N]'> if the N is actually known\n            if tp.length is not None:\n                BArray = self.ffi._get_cached_btype(tp)\n                value = self.ffi.cast(BArray, value)\n                setattr(library, name, value)\n            return\n        # remove ptr=<cdata 'int *'> from the library instance, and replace\n        # it by a property on the class, which reads/writes into ptr[0].\n        ptr = value\n        delattr(library, name)\n        def getter(library):\n            return ptr[0]\n        def setter(library, value):\n            ptr[0] = value\n        setattr(type(library), name, property(getter, setter))\n        type(library)._cffi_dir.append(name)\n\n    # ----------\n\n    def _generate_setup_custom(self):\n        prnt = self._prnt\n        prnt('static int _cffi_setup_custom(PyObject *lib)')\n        prnt('{')\n        prnt('  return %s;' % self._chained_list_constants[True])\n        prnt('}')\n\ncffimod_header = r'''\n#include <Python.h>\n#include <stddef.h>\n\n/* this block of #ifs should be kept exactly identical between\n   c/_cffi_backend.c, cffi/vengine_cpy.py, cffi/vengine_gen.py */\n#if defined(_MSC_VER)\n# include <malloc.h>   /* for alloca() */\n# if _MSC_VER < 1600   /* MSVC < 2010 */\n   typedef __int8 int8_t;\n   typedef __int16 int16_t;\n   typedef __int32 int32_t;\n   typedef __int64 int64_t;\n   typedef unsigned __int8 uint8_t;\n   typedef unsigned __int16 uint16_t;\n   typedef unsigned __int32 uint32_t;\n   typedef unsigned __int64 uint64_t;\n   typedef __int8 int_least8_t;\n   typedef __int16 int_least16_t;\n   typedef __int32 int_least32_t;\n   typedef __int64 int_least64_t;\n   typedef unsigned __int8 uint_least8_t;\n   typedef unsigned __int16 uint_least16_t;\n   typedef unsigned __int32 uint_least32_t;\n   typedef unsigned __int64 uint_least64_t;\n   typedef __int8 int_fast8_t;\n   typedef __int16 int_fast16_t;\n   typedef __int32 int_fast32_t;\n   typedef __int64 int_fast64_t;\n   typedef unsigned __int8 uint_fast8_t;\n   typedef unsigned __int16 uint_fast16_t;\n   typedef unsigned __int32 uint_fast32_t;\n   typedef unsigned __int64 uint_fast64_t;\n   typedef __int64 intmax_t;\n   typedef unsigned __int64 uintmax_t;\n# else\n#  include <stdint.h>\n# endif\n# if _MSC_VER < 1800   /* MSVC < 2013 */\n   typedef unsigned char _Bool;\n# endif\n#else\n# include <stdint.h>\n# if (defined (__SVR4) && defined (__sun)) || defined(_AIX)\n#  include <alloca.h>\n# endif\n#endif\n\n#if PY_MAJOR_VERSION < 3\n# undef PyCapsule_CheckExact\n# undef PyCapsule_GetPointer\n# define PyCapsule_CheckExact(capsule) (PyCObject_Check(capsule))\n# define PyCapsule_GetPointer(capsule, name) \\\n    (PyCObject_AsVoidPtr(capsule))\n#endif\n\n#if PY_MAJOR_VERSION >= 3\n# define PyInt_FromLong PyLong_FromLong\n#endif\n\n#define _cffi_from_c_double PyFloat_FromDouble\n#define _cffi_from_c_float PyFloat_FromDouble\n#define _cffi_from_c_long PyInt_FromLong\n#define _cffi_from_c_ulong PyLong_FromUnsignedLong\n#define _cffi_from_c_longlong PyLong_FromLongLong\n#define _cffi_from_c_ulonglong PyLong_FromUnsignedLongLong\n\n#define _cffi_to_c_double PyFloat_AsDouble\n#define _cffi_to_c_float PyFloat_AsDouble\n\n#define _cffi_from_c_int_const(x)                                        \\\n    (((x) > 0) ?                                                         \\\n        ((unsigned long long)(x) <= (unsigned long long)LONG_MAX) ?      \\\n            PyInt_FromLong((long)(x)) :                                  \\\n            PyLong_FromUnsignedLongLong((unsigned long long)(x)) :       \\\n        ((long long)(x) >= (long long)LONG_MIN) ?                        \\\n            PyInt_FromLong((long)(x)) :                                  \\\n            PyLong_FromLongLong((long long)(x)))\n\n#define _cffi_from_c_int(x, type)                                        \\\n    (((type)-1) > 0 ? /* unsigned */                                     \\\n        (sizeof(type) < sizeof(long) ?                                   \\\n            PyInt_FromLong((long)x) :                                    \\\n         sizeof(type) == sizeof(long) ?                                  \\\n            PyLong_FromUnsignedLong((unsigned long)x) :                  \\\n            PyLong_FromUnsignedLongLong((unsigned long long)x)) :        \\\n        (sizeof(type) <= sizeof(long) ?                                  \\\n            PyInt_FromLong((long)x) :                                    \\\n            PyLong_FromLongLong((long long)x)))\n\n#define _cffi_to_c_int(o, type)                                          \\\n    ((type)(                                                             \\\n     sizeof(type) == 1 ? (((type)-1) > 0 ? (type)_cffi_to_c_u8(o)        \\\n                                         : (type)_cffi_to_c_i8(o)) :     \\\n     sizeof(type) == 2 ? (((type)-1) > 0 ? (type)_cffi_to_c_u16(o)       \\\n                                         : (type)_cffi_to_c_i16(o)) :    \\\n     sizeof(type) == 4 ? (((type)-1) > 0 ? (type)_cffi_to_c_u32(o)       \\\n                                         : (type)_cffi_to_c_i32(o)) :    \\\n     sizeof(type) == 8 ? (((type)-1) > 0 ? (type)_cffi_to_c_u64(o)       \\\n                                         : (type)_cffi_to_c_i64(o)) :    \\\n     (Py_FatalError(\"unsupported size for type \" #type), (type)0)))\n\n#define _cffi_to_c_i8                                                    \\\n                 ((int(*)(PyObject *))_cffi_exports[1])\n#define _cffi_to_c_u8                                                    \\\n                 ((int(*)(PyObject *))_cffi_exports[2])\n#define _cffi_to_c_i16                                                   \\\n                 ((int(*)(PyObject *))_cffi_exports[3])\n#define _cffi_to_c_u16                                                   \\\n                 ((int(*)(PyObject *))_cffi_exports[4])\n#define _cffi_to_c_i32                                                   \\\n                 ((int(*)(PyObject *))_cffi_exports[5])\n#define _cffi_to_c_u32                                                   \\\n                 ((unsigned int(*)(PyObject *))_cffi_exports[6])\n#define _cffi_to_c_i64                                                   \\\n                 ((long long(*)(PyObject *))_cffi_exports[7])\n#define _cffi_to_c_u64                                                   \\\n                 ((unsigned long long(*)(PyObject *))_cffi_exports[8])\n#define _cffi_to_c_char                                                  \\\n                 ((int(*)(PyObject *))_cffi_exports[9])\n#define _cffi_from_c_pointer                                             \\\n    ((PyObject *(*)(char *, CTypeDescrObject *))_cffi_exports[10])\n#define _cffi_to_c_pointer                                               \\\n    ((char *(*)(PyObject *, CTypeDescrObject *))_cffi_exports[11])\n#define _cffi_get_struct_layout                                          \\\n    ((PyObject *(*)(Py_ssize_t[]))_cffi_exports[12])\n#define _cffi_restore_errno                                              \\\n    ((void(*)(void))_cffi_exports[13])\n#define _cffi_save_errno                                                 \\\n    ((void(*)(void))_cffi_exports[14])\n#define _cffi_from_c_char                                                \\\n    ((PyObject *(*)(char))_cffi_exports[15])\n#define _cffi_from_c_deref                                               \\\n    ((PyObject *(*)(char *, CTypeDescrObject *))_cffi_exports[16])\n#define _cffi_to_c                                                       \\\n    ((int(*)(char *, CTypeDescrObject *, PyObject *))_cffi_exports[17])\n#define _cffi_from_c_struct                                              \\\n    ((PyObject *(*)(char *, CTypeDescrObject *))_cffi_exports[18])\n#define _cffi_to_c_wchar_t                                               \\\n    ((wchar_t(*)(PyObject *))_cffi_exports[19])\n#define _cffi_from_c_wchar_t                                             \\\n    ((PyObject *(*)(wchar_t))_cffi_exports[20])\n#define _cffi_to_c_long_double                                           \\\n    ((long double(*)(PyObject *))_cffi_exports[21])\n#define _cffi_to_c__Bool                                                 \\\n    ((_Bool(*)(PyObject *))_cffi_exports[22])\n#define _cffi_prepare_pointer_call_argument                              \\\n    ((Py_ssize_t(*)(CTypeDescrObject *, PyObject *, char **))_cffi_exports[23])\n#define _cffi_convert_array_from_object                                  \\\n    ((int(*)(char *, CTypeDescrObject *, PyObject *))_cffi_exports[24])\n#define _CFFI_NUM_EXPORTS 25\n\ntypedef struct _ctypedescr CTypeDescrObject;\n\nstatic void *_cffi_exports[_CFFI_NUM_EXPORTS];\nstatic PyObject *_cffi_types, *_cffi_VerificationError;\n\nstatic int _cffi_setup_custom(PyObject *lib);   /* forward */\n\nstatic PyObject *_cffi_setup(PyObject *self, PyObject *args)\n{\n    PyObject *library;\n    int was_alive = (_cffi_types != NULL);\n    (void)self; /* unused */\n    if (!PyArg_ParseTuple(args, \"OOO\", &_cffi_types, &_cffi_VerificationError,\n                                       &library))\n        return NULL;\n    Py_INCREF(_cffi_types);\n    Py_INCREF(_cffi_VerificationError);\n    if (_cffi_setup_custom(library) < 0)\n        return NULL;\n    return PyBool_FromLong(was_alive);\n}\n\nstatic int _cffi_init(void)\n{\n    PyObject *module, *c_api_object = NULL;\n\n    module = PyImport_ImportModule(\"_cffi_backend\");\n    if (module == NULL)\n        goto failure;\n\n    c_api_object = PyObject_GetAttrString(module, \"_C_API\");\n    if (c_api_object == NULL)\n        goto failure;\n    if (!PyCapsule_CheckExact(c_api_object)) {\n        PyErr_SetNone(PyExc_ImportError);\n        goto failure;\n    }\n    memcpy(_cffi_exports, PyCapsule_GetPointer(c_api_object, \"cffi\"),\n           _CFFI_NUM_EXPORTS * sizeof(void *));\n\n    Py_DECREF(module);\n    Py_DECREF(c_api_object);\n    return 0;\n\n  failure:\n    Py_XDECREF(module);\n    Py_XDECREF(c_api_object);\n    return -1;\n}\n\n#define _cffi_type(num) ((CTypeDescrObject *)PyList_GET_ITEM(_cffi_types, num))\n\n/**********/\n'''\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.1.2-nak3eqkxfunb4z5owzsqogchnaejp7o4/spack-src/cffi/verifier.py": "import sys, os, binascii, shutil, io\nfrom . import __version_verifier_modules__\nfrom . import ffiplatform\n\nif sys.version_info >= (3, 3):\n    import importlib.machinery\n    def _extension_suffixes():\n        return importlib.machinery.EXTENSION_SUFFIXES[:]\nelse:\n    import imp\n    def _extension_suffixes():\n        return [suffix for suffix, _, type in imp.get_suffixes()\n                if type == imp.C_EXTENSION]\n\n\nif sys.version_info >= (3,):\n    NativeIO = io.StringIO\nelse:\n    class NativeIO(io.BytesIO):\n        def write(self, s):\n            if isinstance(s, unicode):\n                s = s.encode('ascii')\n            super(NativeIO, self).write(s)\n\n\nclass Verifier(object):\n\n    def __init__(self, ffi, preamble, tmpdir=None, modulename=None,\n                 ext_package=None, tag='', force_generic_engine=False,\n                 source_extension='.c', flags=None, relative_to=None, **kwds):\n        self.ffi = ffi\n        self.preamble = preamble\n        if not modulename:\n            flattened_kwds = ffiplatform.flatten(kwds)\n        vengine_class = _locate_engine_class(ffi, force_generic_engine)\n        self._vengine = vengine_class(self)\n        self._vengine.patch_extension_kwds(kwds)\n        self.flags = flags\n        self.kwds = self.make_relative_to(kwds, relative_to)\n        #\n        if modulename:\n            if tag:\n                raise TypeError(\"can't specify both 'modulename' and 'tag'\")\n        else:\n            key = '\\x00'.join([sys.version[:3], __version_verifier_modules__,\n                               preamble, flattened_kwds] +\n                              ffi._cdefsources)\n            if sys.version_info >= (3,):\n                key = key.encode('utf-8')\n            k1 = hex(binascii.crc32(key[0::2]) & 0xffffffff)\n            k1 = k1.lstrip('0x').rstrip('L')\n            k2 = hex(binascii.crc32(key[1::2]) & 0xffffffff)\n            k2 = k2.lstrip('0').rstrip('L')\n            modulename = '_cffi_%s_%s%s%s' % (tag, self._vengine._class_key,\n                                              k1, k2)\n        suffix = _get_so_suffixes()[0]\n        self.tmpdir = tmpdir or _caller_dir_pycache()\n        self.sourcefilename = os.path.join(self.tmpdir, modulename + source_extension)\n        self.modulefilename = os.path.join(self.tmpdir, modulename + suffix)\n        self.ext_package = ext_package\n        self._has_source = False\n        self._has_module = False\n\n    def write_source(self, file=None):\n        \"\"\"Write the C source code.  It is produced in 'self.sourcefilename',\n        which can be tweaked beforehand.\"\"\"\n        with self.ffi._lock:\n            if self._has_source and file is None:\n                raise ffiplatform.VerificationError(\n                    \"source code already written\")\n            self._write_source(file)\n\n    def compile_module(self):\n        \"\"\"Write the C source code (if not done already) and compile it.\n        This produces a dynamic link library in 'self.modulefilename'.\"\"\"\n        with self.ffi._lock:\n            if self._has_module:\n                raise ffiplatform.VerificationError(\"module already compiled\")\n            if not self._has_source:\n                self._write_source()\n            self._compile_module()\n\n    def load_library(self):\n        \"\"\"Get a C module from this Verifier instance.\n        Returns an instance of a FFILibrary class that behaves like the\n        objects returned by ffi.dlopen(), but that delegates all\n        operations to the C module.  If necessary, the C code is written\n        and compiled first.\n        \"\"\"\n        with self.ffi._lock:\n            if not self._has_module:\n                self._locate_module()\n                if not self._has_module:\n                    if not self._has_source:\n                        self._write_source()\n                    self._compile_module()\n            return self._load_library()\n\n    def get_module_name(self):\n        basename = os.path.basename(self.modulefilename)\n        # kill both the .so extension and the other .'s, as introduced\n        # by Python 3: 'basename.cpython-33m.so'\n        basename = basename.split('.', 1)[0]\n        # and the _d added in Python 2 debug builds --- but try to be\n        # conservative and not kill a legitimate _d\n        if basename.endswith('_d') and hasattr(sys, 'gettotalrefcount'):\n            basename = basename[:-2]\n        return basename\n\n    def get_extension(self):\n        if not self._has_source:\n            with self.ffi._lock:\n                if not self._has_source:\n                    self._write_source()\n        sourcename = ffiplatform.maybe_relative_path(self.sourcefilename)\n        modname = self.get_module_name()\n        return ffiplatform.get_extension(sourcename, modname, **self.kwds)\n\n    def generates_python_module(self):\n        return self._vengine._gen_python_module\n\n    def make_relative_to(self, kwds, relative_to):\n        if relative_to and os.path.dirname(relative_to):\n            dirname = os.path.dirname(relative_to)\n            kwds = kwds.copy()\n            for key in ffiplatform.LIST_OF_FILE_NAMES:\n                if key in kwds:\n                    lst = kwds[key]\n                    if not isinstance(lst, (list, tuple)):\n                        raise TypeError(\"keyword '%s' should be a list or tuple\"\n                                        % (key,))\n                    lst = [os.path.join(dirname, fn) for fn in lst]\n                    kwds[key] = lst\n        return kwds\n\n    # ----------\n\n    def _locate_module(self):\n        if not os.path.isfile(self.modulefilename):\n            if self.ext_package:\n                try:\n                    pkg = __import__(self.ext_package, None, None, ['__doc__'])\n                except ImportError:\n                    return      # cannot import the package itself, give up\n                    # (e.g. it might be called differently before installation)\n                path = pkg.__path__\n            else:\n                path = None\n            filename = self._vengine.find_module(self.get_module_name(), path,\n                                                 _get_so_suffixes())\n            if filename is None:\n                return\n            self.modulefilename = filename\n        self._vengine.collect_types()\n        self._has_module = True\n\n    def _write_source_to(self, file):\n        self._vengine._f = file\n        try:\n            self._vengine.write_source_to_f()\n        finally:\n            del self._vengine._f\n\n    def _write_source(self, file=None):\n        if file is not None:\n            self._write_source_to(file)\n        else:\n            # Write our source file to an in memory file.\n            f = NativeIO()\n            self._write_source_to(f)\n            source_data = f.getvalue()\n\n            # Determine if this matches the current file\n            if os.path.exists(self.sourcefilename):\n                with open(self.sourcefilename, \"r\") as fp:\n                    needs_written = not (fp.read() == source_data)\n            else:\n                needs_written = True\n\n            # Actually write the file out if it doesn't match\n            if needs_written:\n                _ensure_dir(self.sourcefilename)\n                with open(self.sourcefilename, \"w\") as fp:\n                    fp.write(source_data)\n\n            # Set this flag\n            self._has_source = True\n\n    def _compile_module(self):\n        # compile this C source\n        tmpdir = os.path.dirname(self.sourcefilename)\n        outputfilename = ffiplatform.compile(tmpdir, self.get_extension())\n        try:\n            same = ffiplatform.samefile(outputfilename, self.modulefilename)\n        except OSError:\n            same = False\n        if not same:\n            _ensure_dir(self.modulefilename)\n            shutil.move(outputfilename, self.modulefilename)\n        self._has_module = True\n\n    def _load_library(self):\n        assert self._has_module\n        if self.flags is not None:\n            return self._vengine.load_library(self.flags)\n        else:\n            return self._vengine.load_library()\n\n# ____________________________________________________________\n\n_FORCE_GENERIC_ENGINE = False      # for tests\n\ndef _locate_engine_class(ffi, force_generic_engine):\n    if _FORCE_GENERIC_ENGINE:\n        force_generic_engine = True\n    if not force_generic_engine:\n        if '__pypy__' in sys.builtin_module_names:\n            force_generic_engine = True\n        else:\n            try:\n                import _cffi_backend\n            except ImportError:\n                _cffi_backend = '?'\n            if ffi._backend is not _cffi_backend:\n                force_generic_engine = True\n    if force_generic_engine:\n        from . import vengine_gen\n        return vengine_gen.VGenericEngine\n    else:\n        from . import vengine_cpy\n        return vengine_cpy.VCPythonEngine\n\n# ____________________________________________________________\n\n_TMPDIR = None\n\ndef _caller_dir_pycache():\n    if _TMPDIR:\n        return _TMPDIR\n    result = os.environ.get('CFFI_TMPDIR')\n    if result:\n        return result\n    filename = sys._getframe(2).f_code.co_filename\n    return os.path.abspath(os.path.join(os.path.dirname(filename),\n                           '__pycache__'))\n\ndef set_tmpdir(dirname):\n    \"\"\"Set the temporary directory to use instead of __pycache__.\"\"\"\n    global _TMPDIR\n    _TMPDIR = dirname\n\ndef cleanup_tmpdir(tmpdir=None, keep_so=False):\n    \"\"\"Clean up the temporary directory by removing all files in it\n    called `_cffi_*.{c,so}` as well as the `build` subdirectory.\"\"\"\n    tmpdir = tmpdir or _caller_dir_pycache()\n    try:\n        filelist = os.listdir(tmpdir)\n    except OSError:\n        return\n    if keep_so:\n        suffix = '.c'   # only remove .c files\n    else:\n        suffix = _get_so_suffixes()[0].lower()\n    for fn in filelist:\n        if fn.lower().startswith('_cffi_') and (\n                fn.lower().endswith(suffix) or fn.lower().endswith('.c')):\n            try:\n                os.unlink(os.path.join(tmpdir, fn))\n            except OSError:\n                pass\n    clean_dir = [os.path.join(tmpdir, 'build')]\n    for dir in clean_dir:\n        try:\n            for fn in os.listdir(dir):\n                fn = os.path.join(dir, fn)\n                if os.path.isdir(fn):\n                    clean_dir.append(fn)\n                else:\n                    os.unlink(fn)\n        except OSError:\n            pass\n\ndef _get_so_suffixes():\n    suffixes = _extension_suffixes()\n    if not suffixes:\n        # bah, no C_EXTENSION available.  Occurs on pypy without cpyext\n        if sys.platform == 'win32':\n            suffixes = [\".pyd\"]\n        else:\n            suffixes = [\".so\"]\n\n    return suffixes\n\ndef _ensure_dir(filename):\n    try:\n        os.makedirs(os.path.dirname(filename))\n    except OSError:\n        pass\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.1.2-nak3eqkxfunb4z5owzsqogchnaejp7o4/spack-src/c/ffi_obj.c": "\n/* An FFI object has methods like ffi.new().  It is also a container\n   for the type declarations (typedefs and structs) that you can use,\n   say in ffi.new().\n\n   CTypeDescrObjects are internally stored in the dict 'types_dict'.\n   The types_dict is lazily filled with CTypeDescrObjects made from\n   reading a _cffi_type_context_s structure.\n\n   In \"modern\" mode, the FFI instance is made by the C extension\n   module originally created by recompile().  The _cffi_type_context_s\n   structure comes from global data in the C extension module.\n\n   In \"compatibility\" mode, an FFI instance is created explicitly by\n   the user, and its _cffi_type_context_s is initially empty.  You\n   need to call ffi.cdef() to add more information to it.\n*/\n\n#define FFI_COMPLEXITY_OUTPUT   1200     /* xxx should grow as needed */\n\n#define FFIObject_Check(op) PyObject_TypeCheck(op, &FFI_Type)\n#define LibObject_Check(ob)  ((Py_TYPE(ob) == &Lib_Type))\n\nstruct FFIObject_s {\n    PyObject_HEAD\n    PyObject *gc_wrefs, *gc_wrefs_freelist;\n    struct _cffi_parse_info_s info;\n    char ctx_is_static, ctx_is_nonempty;\n    builder_c_t types_builder;\n};\n\nstatic FFIObject *ffi_internal_new(PyTypeObject *ffitype,\n                                 const struct _cffi_type_context_s *static_ctx)\n{\n    static _cffi_opcode_t internal_output[FFI_COMPLEXITY_OUTPUT];\n\n    FFIObject *ffi;\n    if (static_ctx != NULL) {\n        ffi = (FFIObject *)PyObject_GC_New(FFIObject, ffitype);\n        /* we don't call PyObject_GC_Track() here: from _cffi_init_module()\n           it is not needed, because in this case the ffi object is immortal */\n    }\n    else {\n        ffi = (FFIObject *)ffitype->tp_alloc(ffitype, 0);\n    }\n    if (ffi == NULL)\n        return NULL;\n\n    if (init_builder_c(&ffi->types_builder, static_ctx) < 0) {\n        Py_DECREF(ffi);\n        return NULL;\n    }\n    ffi->gc_wrefs = NULL;\n    ffi->gc_wrefs_freelist = NULL;\n    ffi->info.ctx = &ffi->types_builder.ctx;\n    ffi->info.output = internal_output;\n    ffi->info.output_size = FFI_COMPLEXITY_OUTPUT;\n    ffi->ctx_is_static = (static_ctx != NULL);\n    ffi->ctx_is_nonempty = (static_ctx != NULL);\n    return ffi;\n}\n\nstatic void ffi_dealloc(FFIObject *ffi)\n{\n    PyObject_GC_UnTrack(ffi);\n    Py_XDECREF(ffi->gc_wrefs);\n    Py_XDECREF(ffi->gc_wrefs_freelist);\n\n    free_builder_c(&ffi->types_builder, ffi->ctx_is_static);\n\n    Py_TYPE(ffi)->tp_free((PyObject *)ffi);\n}\n\nstatic int ffi_traverse(FFIObject *ffi, visitproc visit, void *arg)\n{\n    Py_VISIT(ffi->types_builder.types_dict);\n    Py_VISIT(ffi->types_builder.included_ffis);\n    Py_VISIT(ffi->types_builder.included_libs);\n    Py_VISIT(ffi->gc_wrefs);\n    return 0;\n}\n\nstatic PyObject *ffiobj_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    /* user-facing initialization code, for explicit FFI() calls */\n    return (PyObject *)ffi_internal_new(type, NULL);\n}\n\n/* forward, declared in cdlopen.c because it's mostly useful for this case */\nstatic int ffiobj_init(PyObject *self, PyObject *args, PyObject *kwds);\n\nstatic PyObject *ffi_fetch_int_constant(FFIObject *ffi, char *name,\n                                        int recursion)\n{\n    int index;\n\n    index = search_in_globals(&ffi->types_builder.ctx, name, strlen(name));\n    if (index >= 0) {\n        const struct _cffi_global_s *g;\n        g = &ffi->types_builder.ctx.globals[index];\n\n        switch (_CFFI_GETOP(g->type_op)) {\n        case _CFFI_OP_CONSTANT_INT:\n        case _CFFI_OP_ENUM:\n            return realize_global_int(&ffi->types_builder, index);\n\n        default:\n            PyErr_Format(FFIError,\n                         \"function, global variable or non-integer constant \"\n                         \"'%.200s' must be fetched from its original 'lib' \"\n                         \"object\", name);\n            return NULL;\n        }\n    }\n\n    if (ffi->types_builder.included_ffis != NULL) {\n        Py_ssize_t i;\n        PyObject *included_ffis = ffi->types_builder.included_ffis;\n\n        if (recursion > 100) {\n            PyErr_SetString(PyExc_RuntimeError,\n                            \"recursion overflow in ffi.include() delegations\");\n            return NULL;\n        }\n\n        for (i = 0; i < PyTuple_GET_SIZE(included_ffis); i++) {\n            FFIObject *ffi1;\n            PyObject *x;\n\n            ffi1 = (FFIObject *)PyTuple_GET_ITEM(included_ffis, i);\n            x = ffi_fetch_int_constant(ffi1, name, recursion + 1);\n            if (x != NULL || PyErr_Occurred())\n                return x;\n        }\n    }\n    return NULL;     /* no exception set, means \"not found\" */\n}\n\n#define ACCEPT_STRING   1\n#define ACCEPT_CTYPE    2\n#define ACCEPT_CDATA    4\n#define ACCEPT_ALL      (ACCEPT_STRING | ACCEPT_CTYPE | ACCEPT_CDATA)\n#define CONSIDER_FN_AS_FNPTR  8\n\nstatic CTypeDescrObject *_ffi_bad_type(FFIObject *ffi, char *input_text)\n{\n    size_t length = strlen(input_text);\n    char *extra;\n\n    if (length > 500) {\n        extra = \"\";\n    }\n    else {\n        char *p;\n        size_t i, num_spaces = ffi->info.error_location;\n        extra = alloca(length + num_spaces + 4);\n        p = extra;\n        *p++ = '\\n';\n        for (i = 0; i < length; i++) {\n            if (' ' <= input_text[i] && input_text[i] < 0x7f)\n                *p++ = input_text[i];\n            else if (input_text[i] == '\\t' || input_text[i] == '\\n')\n                *p++ = ' ';\n            else\n                *p++ = '?';\n        }\n        *p++ = '\\n';\n        memset(p, ' ', num_spaces);\n        p += num_spaces;\n        *p++ = '^';\n        *p++ = 0;\n    }\n    PyErr_Format(FFIError, \"%s%s\", ffi->info.error_message, extra);\n    return NULL;\n}\n\nstatic CTypeDescrObject *_ffi_type(FFIObject *ffi, PyObject *arg,\n                                   int accept)\n{\n    /* Returns the CTypeDescrObject from the user-supplied 'arg'.\n       Does not return a new reference!\n    */\n    if ((accept & ACCEPT_STRING) && PyText_Check(arg)) {\n        PyObject *types_dict = ffi->types_builder.types_dict;\n        PyObject *x = PyDict_GetItem(types_dict, arg);\n\n        if (x == NULL) {\n            char *input_text = PyText_AS_UTF8(arg);\n            int err, index = parse_c_type(&ffi->info, input_text);\n            if (index < 0)\n                return _ffi_bad_type(ffi, input_text);\n\n            x = realize_c_type_or_func(&ffi->types_builder,\n                                       ffi->info.output, index);\n            if (x == NULL)\n                return NULL;\n\n            /* Cache under the name given by 'arg', in addition to the\n               fact that the same ct is probably already cached under\n               its standardized name.  In a few cases, it is not, e.g.\n               if it is a primitive; for the purpose of this function,\n               the important point is the following line, which makes\n               sure that in any case the next _ffi_type() with the same\n               'arg' will succeed early, in PyDict_GetItem() above.\n            */\n            err = PyDict_SetItem(types_dict, arg, x);\n            Py_DECREF(x); /* we know it was written in types_dict (unless out\n                             of mem), so there is at least that ref left */\n            if (err < 0)\n                return NULL;\n        }\n\n        if (CTypeDescr_Check(x))\n            return (CTypeDescrObject *)x;\n        else if (accept & CONSIDER_FN_AS_FNPTR)\n            return unwrap_fn_as_fnptr(x);\n        else\n            return unexpected_fn_type(x);\n    }\n    else if ((accept & ACCEPT_CTYPE) && CTypeDescr_Check(arg)) {\n        return (CTypeDescrObject *)arg;\n    }\n    else if ((accept & ACCEPT_CDATA) && CData_Check(arg)) {\n        return ((CDataObject *)arg)->c_type;\n    }\n#if PY_MAJOR_VERSION < 3\n    else if (PyUnicode_Check(arg)) {\n        CTypeDescrObject *result;\n        arg = PyUnicode_AsASCIIString(arg);\n        if (arg == NULL)\n            return NULL;\n        result = _ffi_type(ffi, arg, accept);\n        Py_DECREF(arg);\n        return result;\n    }\n#endif\n    else {\n        const char *m1 = (accept & ACCEPT_STRING) ? \"string\" : \"\";\n        const char *m2 = (accept & ACCEPT_CTYPE) ? \"ctype object\" : \"\";\n        const char *m3 = (accept & ACCEPT_CDATA) ? \"cdata object\" : \"\";\n        const char *s12 = (*m1 && (*m2 || *m3)) ? \" or \" : \"\";\n        const char *s23 = (*m2 && *m3) ? \" or \" : \"\";\n        PyErr_Format(PyExc_TypeError, \"expected a %s%s%s%s%s, got '%.200s'\",\n                     m1, s12, m2, s23, m3,\n                     Py_TYPE(arg)->tp_name);\n        return NULL;\n    }\n}\n\nPyDoc_STRVAR(ffi_sizeof_doc,\n\"Return the size in bytes of the argument.\\n\"\n\"It can be a string naming a C type, or a 'cdata' instance.\");\n\nstatic PyObject *ffi_sizeof(FFIObject *self, PyObject *arg)\n{\n    Py_ssize_t size;\n    CTypeDescrObject *ct = _ffi_type(self, arg, ACCEPT_ALL);\n    if (ct == NULL)\n        return NULL;\n\n    size = ct->ct_size;\n\n    if (CData_Check(arg)) {\n        CDataObject *cd = (CDataObject *)arg;\n        if (cd->c_type->ct_flags & CT_ARRAY)\n            size = get_array_length(cd) * cd->c_type->ct_itemdescr->ct_size;\n    }\n\n    if (size < 0) {\n        PyErr_Format(FFIError, \"don't know the size of ctype '%s'\",\n                     ct->ct_name);\n        return NULL;\n    }\n    return PyInt_FromSsize_t(size);\n}\n\nPyDoc_STRVAR(ffi_alignof_doc,\n\"Return the natural alignment size in bytes of the argument.\\n\"\n\"It can be a string naming a C type, or a 'cdata' instance.\");\n\nstatic PyObject *ffi_alignof(FFIObject *self, PyObject *arg)\n{\n    int align;\n    CTypeDescrObject *ct = _ffi_type(self, arg, ACCEPT_ALL);\n    if (ct == NULL)\n        return NULL;\n\n    align = get_alignment(ct);\n    if (align < 0)\n        return NULL;\n    return PyInt_FromLong(align);\n}\n\nPyDoc_STRVAR(ffi_typeof_doc,\n\"Parse the C type given as a string and return the\\n\"\n\"corresponding <ctype> object.\\n\"\n\"It can also be used on 'cdata' instance to get its C type.\");\n\nstatic PyObject *_cpyextfunc_type_index(PyObject *x);  /* forward */\n\nstatic PyObject *ffi_typeof(FFIObject *self, PyObject *arg)\n{\n    PyObject *x = (PyObject *)_ffi_type(self, arg, ACCEPT_STRING|ACCEPT_CDATA);\n    if (x != NULL) {\n        Py_INCREF(x);\n    }\n    else {\n        x = _cpyextfunc_type_index(arg);\n    }\n    return x;\n}\n\nPyDoc_STRVAR(ffi_new_doc,\n\"Allocate an instance according to the specified C type and return a\\n\"\n\"pointer to it.  The specified C type must be either a pointer or an\\n\"\n\"array: ``new('X *')`` allocates an X and returns a pointer to it,\\n\"\n\"whereas ``new('X[n]')`` allocates an array of n X'es and returns an\\n\"\n\"array referencing it (which works mostly like a pointer, like in C).\\n\"\n\"You can also use ``new('X[]', n)`` to allocate an array of a\\n\"\n\"non-constant length n.\\n\"\n\"\\n\"\n\"The memory is initialized following the rules of declaring a global\\n\"\n\"variable in C: by default it is zero-initialized, but an explicit\\n\"\n\"initializer can be given which can be used to fill all or part of the\\n\"\n\"memory.\\n\"\n\"\\n\"\n\"When the returned <cdata> object goes out of scope, the memory is\\n\"\n\"freed.  In other words the returned <cdata> object has ownership of\\n\"\n\"the value of type 'cdecl' that it points to.  This means that the raw\\n\"\n\"data can be used as long as this object is kept alive, but must not be\\n\"\n\"used for a longer time.  Be careful about that when copying the\\n\"\n\"pointer to the memory somewhere else, e.g. into another structure.\");\n\nstatic PyObject *ffi_new(FFIObject *self, PyObject *args, PyObject *kwds)\n{\n    CTypeDescrObject *ct;\n    PyObject *arg, *init = Py_None;\n    static char *keywords[] = {\"cdecl\", \"init\", NULL};\n    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"O|O:new\", keywords,\n                                     &arg, &init))\n        return NULL;\n\n    ct = _ffi_type(self, arg, ACCEPT_STRING|ACCEPT_CTYPE);\n    if (ct == NULL)\n        return NULL;\n\n    return direct_newp(ct, init);\n}\n\nPyDoc_STRVAR(ffi_cast_doc,\n\"Similar to a C cast: returns an instance of the named C\\n\"\n\"type initialized with the given 'source'.  The source is\\n\"\n\"casted between integers or pointers of any type.\");\n\nstatic PyObject *ffi_cast(FFIObject *self, PyObject *args)\n{\n    CTypeDescrObject *ct;\n    PyObject *ob, *arg;\n    if (!PyArg_ParseTuple(args, \"OO:cast\", &arg, &ob))\n        return NULL;\n\n    ct = _ffi_type(self, arg, ACCEPT_STRING|ACCEPT_CTYPE);\n    if (ct == NULL)\n        return NULL;\n\n    return do_cast(ct, ob);\n}\n\nPyDoc_STRVAR(ffi_string_doc,\n\"Return a Python string (or unicode string) from the 'cdata'.  If\\n\"\n\"'cdata' is a pointer or array of characters or bytes, returns the\\n\"\n\"null-terminated string.  The returned string extends until the first\\n\"\n\"null character, or at most 'maxlen' characters.  If 'cdata' is an\\n\"\n\"array then 'maxlen' defaults to its length.\\n\"\n\"\\n\"\n\"If 'cdata' is a pointer or array of wchar_t, returns a unicode string\\n\"\n\"following the same rules.\\n\"\n\"\\n\"\n\"If 'cdata' is a single character or byte or a wchar_t, returns it as a\\n\"\n\"string or unicode string.\\n\"\n\"\\n\"\n\"If 'cdata' is an enum, returns the value of the enumerator as a\\n\"\n\"string, or 'NUMBER' if the value is out of range.\");\n\n#define ffi_string  b_string     /* ffi_string() => b_string()\n                                    from _cffi_backend.c */\n\nPyDoc_STRVAR(ffi_buffer_doc,\n\"Return a read-write buffer object that references the raw C data\\n\"\n\"pointed to by the given 'cdata'.  The 'cdata' must be a pointer or an\\n\"\n\"array.  Can be passed to functions expecting a buffer, or directly\\n\"\n\"manipulated with:\\n\"\n\"\\n\"\n\"    buf[:]          get a copy of it in a regular string, or\\n\"\n\"    buf[idx]        as a single character\\n\"\n\"    buf[:] = ...\\n\"\n\"    buf[idx] = ...  change the content\");\n\n#define ffi_buffer  b_buffer     /* ffi_buffer() => b_buffer()\n                                    from _cffi_backend.c */\n\nPyDoc_STRVAR(ffi_offsetof_doc,\n\"Return the offset of the named field inside the given structure or\\n\"\n\"array, which must be given as a C type name.  You can give several\\n\"\n\"field names in case of nested structures.  You can also give numeric\\n\"\n\"values which correspond to array items, in case of an array type.\");\n\nstatic PyObject *ffi_offsetof(FFIObject *self, PyObject *args)\n{\n    PyObject *arg;\n    CTypeDescrObject *ct;\n    Py_ssize_t i, offset;\n\n    if (PyTuple_Size(args) < 2) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"offsetof() expects at least 2 arguments\");\n        return NULL;\n    }\n\n    arg = PyTuple_GET_ITEM(args, 0);\n    ct = _ffi_type(self, arg, ACCEPT_STRING|ACCEPT_CTYPE);\n    if (ct == NULL)\n        return NULL;\n\n    offset = 0;\n    for (i = 1; i < PyTuple_GET_SIZE(args); i++) {\n        Py_ssize_t ofs1;\n        ct = direct_typeoffsetof(ct, PyTuple_GET_ITEM(args, i), i > 1, &ofs1);\n        if (ct == NULL)\n            return NULL;\n        offset += ofs1;\n    }\n    return PyInt_FromSsize_t(offset);\n}\n\nPyDoc_STRVAR(ffi_addressof_doc,\n\"Limited equivalent to the '&' operator in C:\\n\"\n\"\\n\"\n\"1. ffi.addressof(<cdata 'struct-or-union'>) returns a cdata that is a\\n\"\n\"pointer to this struct or union.\\n\"\n\"\\n\"\n\"2. ffi.addressof(<cdata>, field-or-index...) returns the address of a\\n\"\n\"field or array item inside the given structure or array, recursively\\n\"\n\"in case of nested structures or arrays.\\n\"\n\"\\n\"\n\"3. ffi.addressof(<library>, \\\"name\\\") returns the address of the named\\n\"\n\"function or global variable.\");\n\nstatic PyObject *address_of_global_var(PyObject *args);  /* forward */\n\nstatic PyObject *ffi_addressof(FFIObject *self, PyObject *args)\n{\n    PyObject *arg, *z, *result;\n    CTypeDescrObject *ct;\n    Py_ssize_t i, offset = 0;\n    int accepted_flags;\n\n    if (PyTuple_Size(args) < 1) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"addressof() expects at least 1 argument\");\n        return NULL;\n    }\n\n    arg = PyTuple_GET_ITEM(args, 0);\n    if (LibObject_Check(arg)) {\n        /* case 3 in the docstring */\n        return address_of_global_var(args);\n    }\n\n    ct = _ffi_type(self, arg, ACCEPT_CDATA);\n    if (ct == NULL)\n        return NULL;\n\n    if (PyTuple_GET_SIZE(args) == 1) {\n        /* case 1 in the docstring */\n        accepted_flags = CT_STRUCT | CT_UNION | CT_ARRAY;\n        if ((ct->ct_flags & accepted_flags) == 0) {\n            PyErr_SetString(PyExc_TypeError,\n                            \"expected a cdata struct/union/array object\");\n            return NULL;\n        }\n    }\n    else {\n        /* case 2 in the docstring */\n        accepted_flags = CT_STRUCT | CT_UNION | CT_ARRAY | CT_POINTER;\n        if ((ct->ct_flags & accepted_flags) == 0) {\n            PyErr_SetString(PyExc_TypeError,\n                        \"expected a cdata struct/union/array/pointer object\");\n            return NULL;\n        }\n        for (i = 1; i < PyTuple_GET_SIZE(args); i++) {\n            Py_ssize_t ofs1;\n            ct = direct_typeoffsetof(ct, PyTuple_GET_ITEM(args, i),\n                                     i > 1, &ofs1);\n            if (ct == NULL)\n                return NULL;\n            offset += ofs1;\n        }\n    }\n\n    z = new_pointer_type(ct);\n    if (z == NULL)\n        return NULL;\n\n    result = new_simple_cdata(((CDataObject *)arg)->c_data + offset,\n                              (CTypeDescrObject *)z);\n    Py_DECREF(z);\n    return result;\n}\n\nstatic PyObject *_combine_type_name_l(CTypeDescrObject *ct,\n                                      size_t extra_text_len)\n{\n    size_t base_name_len;\n    PyObject *result;\n    char *p;\n\n    base_name_len = strlen(ct->ct_name);\n    result = PyBytes_FromStringAndSize(NULL, base_name_len + extra_text_len);\n    if (result == NULL)\n        return NULL;\n\n    p = PyBytes_AS_STRING(result);\n    memcpy(p, ct->ct_name, ct->ct_name_position);\n    p += ct->ct_name_position;\n    p += extra_text_len;\n    memcpy(p, ct->ct_name + ct->ct_name_position,\n           base_name_len - ct->ct_name_position);\n    return result;\n}\n\nPyDoc_STRVAR(ffi_getctype_doc,\n\"Return a string giving the C type 'cdecl', which may be itself a\\n\"\n\"string or a <ctype> object.  If 'replace_with' is given, it gives\\n\"\n\"extra text to append (or insert for more complicated C types), like a\\n\"\n\"variable name, or '*' to get actually the C type 'pointer-to-cdecl'.\");\n\nstatic PyObject *ffi_getctype(FFIObject *self, PyObject *args, PyObject *kwds)\n{\n    PyObject *c_decl, *res;\n    char *p, *replace_with = \"\";\n    int add_paren, add_space;\n    CTypeDescrObject *ct;\n    size_t replace_with_len;\n    static char *keywords[] = {\"cdecl\", \"replace_with\", NULL};\n#if PY_MAJOR_VERSION >= 3\n    PyObject *u;\n#endif\n\n    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"O|s:getctype\", keywords,\n                                     &c_decl, &replace_with))\n        return NULL;\n\n    ct = _ffi_type(self, c_decl, ACCEPT_STRING|ACCEPT_CTYPE);\n    if (ct == NULL)\n        return NULL;\n\n    while (replace_with[0] != 0 && isspace(replace_with[0]))\n        replace_with++;\n    replace_with_len = strlen(replace_with);\n    while (replace_with_len > 0 && isspace(replace_with[replace_with_len - 1]))\n        replace_with_len--;\n\n    add_paren = (replace_with[0] == '*' &&\n                 ((ct->ct_flags & CT_ARRAY) != 0));\n    add_space = (!add_paren && replace_with_len > 0 &&\n                 replace_with[0] != '[' && replace_with[0] != '(');\n\n    res = _combine_type_name_l(ct, replace_with_len + add_space + 2*add_paren);\n    if (res == NULL)\n        return NULL;\n\n    p = PyBytes_AS_STRING(res) + ct->ct_name_position;\n    if (add_paren)\n        *p++ = '(';\n    if (add_space)\n        *p++ = ' ';\n    memcpy(p, replace_with, replace_with_len);\n    if (add_paren)\n        p[replace_with_len] = ')';\n\n#if PY_MAJOR_VERSION >= 3\n    /* bytes -> unicode string */\n    u = PyUnicode_DecodeLatin1(PyBytes_AS_STRING(res),\n                               PyBytes_GET_SIZE(res),\n                               NULL);\n    Py_DECREF(res);\n    res = u;\n#endif\n\n    return res;\n}\n\nPyDoc_STRVAR(ffi_new_handle_doc,\n\"Return a non-NULL cdata of type 'void *' that contains an opaque\\n\"\n\"reference to the argument, which can be any Python object.  To cast it\\n\"\n\"back to the original object, use from_handle().  You must keep alive\\n\"\n\"the cdata object returned by new_handle()!\");\n\nstatic PyObject *ffi_new_handle(FFIObject *self, PyObject *arg)\n{\n    CDataObject *cd;\n\n    cd = (CDataObject *)PyObject_GC_New(CDataObject, &CDataOwningGC_Type);\n    if (cd == NULL)\n        return NULL;\n    Py_INCREF(g_ct_voidp);     // <ctype 'void *'>\n    cd->c_type = g_ct_voidp;\n    Py_INCREF(arg);\n    cd->c_data = ((char *)arg) - 42;\n    cd->c_weakreflist = NULL;\n    PyObject_GC_Track(cd);\n    return (PyObject *)cd;\n}\n\nPyDoc_STRVAR(ffi_from_handle_doc,\n\"Cast a 'void *' back to a Python object.  Must be used *only* on the\\n\"\n\"pointers returned by new_handle(), and *only* as long as the exact\\n\"\n\"cdata object returned by new_handle() is still alive (somewhere else\\n\"\n\"in the program).  Failure to follow these rules will crash.\");\n\nstatic PyObject *ffi_from_handle(PyObject *self, PyObject *arg)\n{\n    CTypeDescrObject *ct;\n    char *raw;\n    PyObject *x;\n    if (!CData_Check(arg)) {\n        PyErr_SetString(PyExc_TypeError, \"expected a 'cdata' object\");\n        return NULL;\n    }\n    ct = ((CDataObject *)arg)->c_type;\n    raw = ((CDataObject *)arg)->c_data;\n    if (!(ct->ct_flags & CT_CAST_ANYTHING)) {\n        PyErr_Format(PyExc_TypeError,\n                     \"expected a 'cdata' object with a 'void *' out of \"\n                     \"new_handle(), got '%s'\", ct->ct_name);\n        return NULL;\n    }\n    if (!raw) {\n        PyErr_SetString(PyExc_RuntimeError,\n                        \"cannot use from_handle() on NULL pointer\");\n        return NULL;\n    }\n    x = (PyObject *)(raw + 42);\n    Py_INCREF(x);\n    return x;\n}\n\nPyDoc_STRVAR(ffi_from_buffer_doc,\n\"Return a <cdata 'char[]'> that points to the data of the given Python\\n\"\n\"object, which must support the buffer interface.  Note that this is\\n\"\n\"not meant to be used on the built-in types str, unicode, or bytearray\\n\"\n\"(you can build 'char[]' arrays explicitly) but only on objects\\n\"\n\"containing large quantities of raw data in some other format, like\\n\"\n\"'array.array' or numpy arrays.\");\n\nstatic PyObject *ffi_from_buffer(PyObject *self, PyObject *arg)\n{\n    return direct_from_buffer(g_ct_chararray, arg);\n}\n\nPyDoc_STRVAR(ffi_gc_doc,\n\"Return a new cdata object that points to the same data.\\n\"\n\"Later, when this new cdata object is garbage-collected,\\n\"\n\"'destructor(old_cdata_object)' will be called.\");\n\nstatic PyObject *gc_weakrefs_build(FFIObject *ffi, CDataObject *cd,\n                                   PyObject *destructor);   /* forward */\n\nstatic PyObject *ffi_gc(FFIObject *self, PyObject *args, PyObject *kwds)\n{\n    CDataObject *cd;\n    PyObject *destructor;\n    static char *keywords[] = {\"cdata\", \"destructor\", NULL};\n\n    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"O!O:gc\", keywords,\n                                     &CData_Type, &cd, &destructor))\n        return NULL;\n\n    return gc_weakrefs_build(self, cd, destructor);\n}\n\nPyDoc_STRVAR(ffi_callback_doc,\n\"Return a callback object or a decorator making such a callback object.\\n\"\n\"'cdecl' must name a C function pointer type.  The callback invokes the\\n\"\n\"specified 'python_callable' (which may be provided either directly or\\n\"\n\"via a decorator).  Important: the callback object must be manually\\n\"\n\"kept alive for as long as the callback may be invoked from the C code.\");\n\nstatic PyObject *_ffi_callback_decorator(PyObject *outer_args, PyObject *fn)\n{\n    PyObject *res, *old;\n\n    old = PyTuple_GET_ITEM(outer_args, 1);\n    PyTuple_SET_ITEM(outer_args, 1, fn);\n    res = b_callback(NULL, outer_args);\n    PyTuple_SET_ITEM(outer_args, 1, old);\n    return res;\n}\n\nstatic PyObject *ffi_callback(FFIObject *self, PyObject *args, PyObject *kwds)\n{\n    PyObject *c_decl, *python_callable = Py_None, *error = Py_None;\n    PyObject *res;\n    static char *keywords[] = {\"cdecl\", \"python_callable\", \"error\", NULL};\n\n    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"O|OO\", keywords,\n                                     &c_decl, &python_callable, &error))\n        return NULL;\n\n    c_decl = (PyObject *)_ffi_type(self, c_decl, ACCEPT_STRING | ACCEPT_CTYPE |\n                                                 CONSIDER_FN_AS_FNPTR);\n    if (c_decl == NULL)\n        return NULL;\n\n    args = Py_BuildValue(\"(OOO)\", c_decl, python_callable, error);\n    if (args == NULL)\n        return NULL;\n\n    if (python_callable != Py_None) {\n        res = b_callback(NULL, args);\n    }\n    else {\n        static PyMethodDef md = {\"callback_decorator\",\n                                 (PyCFunction)_ffi_callback_decorator, METH_O};\n        res = PyCFunction_New(&md, args);\n    }\n    Py_DECREF(args);\n    return res;\n}\n\n#ifdef MS_WIN32\nPyDoc_STRVAR(ffi_getwinerror_doc,\n\"Return either the GetLastError() or the error number given by the\\n\"\n\"optional 'code' argument, as a tuple '(code, message)'.\");\n\n#define ffi_getwinerror  b_getwinerror  /* ffi_getwinerror() => b_getwinerror()\n                                           from misc_win32.h */\n#endif\n\nPyDoc_STRVAR(ffi_errno_doc, \"the value of 'errno' from/to the C calls\");\n\nstatic PyObject *ffi_get_errno(PyObject *self, void *closure)\n{\n    /* xxx maybe think about how to make the saved errno local\n       to an ffi instance */\n    return b_get_errno(NULL, NULL);\n}\n\nstatic int ffi_set_errno(PyObject *self, PyObject *newval, void *closure)\n{\n    PyObject *x = b_set_errno(NULL, newval);\n    if (x == NULL)\n        return -1;\n    Py_DECREF(x);\n    return 0;\n}\n\nPyDoc_STRVAR(ffi_dlopen_doc,\n\"Load and return a dynamic library identified by 'name'.  The standard\\n\"\n\"C library can be loaded by passing None.\\n\"\n\"\\n\"\n\"Note that functions and types declared with 'ffi.cdef()' are not\\n\"\n\"linked to a particular library, just like C headers.  In the library\\n\"\n\"we only look for the actual (untyped) symbols at the time of their\\n\"\n\"first access.\");\n\nPyDoc_STRVAR(ffi_dlclose_doc,\n\"Close a library obtained with ffi.dlopen().  After this call, access to\\n\"\n\"functions or variables from the library will fail (possibly with a\\n\"\n\"segmentation fault).\");\n\nstatic PyObject *ffi_dlopen(PyObject *self, PyObject *args);  /* forward */\nstatic PyObject *ffi_dlclose(PyObject *self, PyObject *args);  /* forward */\n\nPyDoc_STRVAR(ffi_int_const_doc,\n\"Get the value of an integer constant.\\n\"\n\"\\n\"\n\"'ffi.integer_const(\\\"xxx\\\")' is equivalent to 'lib.xxx' if xxx names an\\n\"\n\"integer constant.  The point of this function is limited to use cases\\n\"\n\"where you have an 'ffi' object but not any associated 'lib' object.\");\n\nstatic PyObject *ffi_int_const(FFIObject *self, PyObject *args, PyObject *kwds)\n{\n    char *name;\n    PyObject *x;\n    static char *keywords[] = {\"name\", NULL};\n\n    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"s\", keywords, &name))\n        return NULL;\n\n    x = ffi_fetch_int_constant(self, name, 0);\n\n    if (x == NULL && !PyErr_Occurred()) {\n        PyErr_Format(PyExc_AttributeError,\n                     \"integer constant '%.200s' not found\", name);\n    }\n    return x;\n}\n\n#define METH_VKW  (METH_VARARGS | METH_KEYWORDS)\nstatic PyMethodDef ffi_methods[] = {\n {\"addressof\",  (PyCFunction)ffi_addressof,  METH_VARARGS, ffi_addressof_doc},\n {\"alignof\",    (PyCFunction)ffi_alignof,    METH_O,       ffi_alignof_doc},\n {\"buffer\",     (PyCFunction)ffi_buffer,     METH_VKW,     ffi_buffer_doc},\n {\"callback\",   (PyCFunction)ffi_callback,   METH_VKW,     ffi_callback_doc},\n {\"cast\",       (PyCFunction)ffi_cast,       METH_VARARGS, ffi_cast_doc},\n {\"dlclose\",    (PyCFunction)ffi_dlclose,    METH_VARARGS, ffi_dlclose_doc},\n {\"dlopen\",     (PyCFunction)ffi_dlopen,     METH_VARARGS, ffi_dlopen_doc},\n {\"from_buffer\",(PyCFunction)ffi_from_buffer,METH_O,       ffi_from_buffer_doc},\n {\"from_handle\",(PyCFunction)ffi_from_handle,METH_O,       ffi_from_handle_doc},\n {\"gc\",         (PyCFunction)ffi_gc,         METH_VKW,     ffi_gc_doc},\n {\"getctype\",   (PyCFunction)ffi_getctype,   METH_VKW,     ffi_getctype_doc},\n#ifdef MS_WIN32\n {\"getwinerror\",(PyCFunction)ffi_getwinerror,METH_VKW,     ffi_getwinerror_doc},\n#endif\n {\"integer_const\",(PyCFunction)ffi_int_const,METH_VKW,     ffi_int_const_doc},\n {\"new\",        (PyCFunction)ffi_new,        METH_VKW,     ffi_new_doc},\n {\"new_handle\", (PyCFunction)ffi_new_handle, METH_O,       ffi_new_handle_doc},\n {\"offsetof\",   (PyCFunction)ffi_offsetof,   METH_VARARGS, ffi_offsetof_doc},\n {\"sizeof\",     (PyCFunction)ffi_sizeof,     METH_O,       ffi_sizeof_doc},\n {\"string\",     (PyCFunction)ffi_string,     METH_VKW,     ffi_string_doc},\n {\"typeof\",     (PyCFunction)ffi_typeof,     METH_O,       ffi_typeof_doc},\n {NULL}\n};\n\nstatic PyGetSetDef ffi_getsets[] = {\n    {\"errno\",  ffi_get_errno,  ffi_set_errno,  ffi_errno_doc},\n    {NULL}\n};\n\nstatic PyTypeObject FFI_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"CompiledFFI\",\n    sizeof(FFIObject),\n    0,\n    (destructor)ffi_dealloc,                    /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_compare */\n    0,                                          /* tp_repr */\n    0,                                          /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    PyObject_GenericGetAttr,                    /* tp_getattro */\n    0,                                          /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |\n        Py_TPFLAGS_BASETYPE,                    /* tp_flags */\n    0,                                          /* tp_doc */\n    (traverseproc)ffi_traverse,                 /* tp_traverse */\n    0,                                          /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    ffi_methods,                                /* tp_methods */\n    0,                                          /* tp_members */\n    ffi_getsets,                                /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    ffiobj_init,                                /* tp_init */\n    0,                                          /* tp_alloc */\n    ffiobj_new,                                 /* tp_new */\n    PyObject_GC_Del,                            /* tp_free */\n};\n\n\nstatic PyObject *\n_fetch_external_struct_or_union(const struct _cffi_struct_union_s *s,\n                                PyObject *included_ffis, int recursion)\n{\n    Py_ssize_t i;\n\n    if (included_ffis == NULL)\n        return NULL;\n\n    if (recursion > 100) {\n        PyErr_SetString(PyExc_RuntimeError,\n                        \"recursion overflow in ffi.include() delegations\");\n        return NULL;\n    }\n\n    for (i = 0; i < PyTuple_GET_SIZE(included_ffis); i++) {\n        FFIObject *ffi1;\n        const struct _cffi_struct_union_s *s1;\n        int sindex;\n        PyObject *x;\n\n        ffi1 = (FFIObject *)PyTuple_GET_ITEM(included_ffis, i);\n        sindex = search_in_struct_unions(&ffi1->types_builder.ctx, s->name,\n                                         strlen(s->name));\n        if (sindex < 0)  /* not found at all */\n            continue;\n        s1 = &ffi1->types_builder.ctx.struct_unions[sindex];\n        if ((s1->flags & (_CFFI_F_EXTERNAL | _CFFI_F_UNION))\n                == (s->flags & _CFFI_F_UNION)) {\n            /* s1 is not external, and the same kind (struct or union) as s */\n            return _realize_c_struct_or_union(&ffi1->types_builder, sindex);\n        }\n        /* not found, look more recursively */\n        x = _fetch_external_struct_or_union(\n                s, ffi1->types_builder.included_ffis, recursion + 1);\n        if (x != NULL || PyErr_Occurred())\n            return x;   /* either found, or got an error */\n    }\n    return NULL;   /* not found at all, leave without an error */\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.1.2-nak3eqkxfunb4z5owzsqogchnaejp7o4/spack-src/c/_cffi_backend.c": "#define PY_SSIZE_T_CLEAN\n#include <Python.h>\n#include \"structmember.h\"\n\n#ifdef MS_WIN32\n#include <windows.h>\n#include \"misc_win32.h\"\n#else\n#include <stddef.h>\n#include <stdint.h>\n#include <dlfcn.h>\n#include <errno.h>\n#include <ffi.h>\n#include <sys/mman.h>\n#endif\n\n/* this block of #ifs should be kept exactly identical between\n   c/_cffi_backend.c, cffi/vengine_cpy.py, cffi/vengine_gen.py */\n#if defined(_MSC_VER)\n# include <malloc.h>   /* for alloca() */\n# if _MSC_VER < 1600   /* MSVC < 2010 */\n   typedef __int8 int8_t;\n   typedef __int16 int16_t;\n   typedef __int32 int32_t;\n   typedef __int64 int64_t;\n   typedef unsigned __int8 uint8_t;\n   typedef unsigned __int16 uint16_t;\n   typedef unsigned __int32 uint32_t;\n   typedef unsigned __int64 uint64_t;\n   typedef __int8 int_least8_t;\n   typedef __int16 int_least16_t;\n   typedef __int32 int_least32_t;\n   typedef __int64 int_least64_t;\n   typedef unsigned __int8 uint_least8_t;\n   typedef unsigned __int16 uint_least16_t;\n   typedef unsigned __int32 uint_least32_t;\n   typedef unsigned __int64 uint_least64_t;\n   typedef __int8 int_fast8_t;\n   typedef __int16 int_fast16_t;\n   typedef __int32 int_fast32_t;\n   typedef __int64 int_fast64_t;\n   typedef unsigned __int8 uint_fast8_t;\n   typedef unsigned __int16 uint_fast16_t;\n   typedef unsigned __int32 uint_fast32_t;\n   typedef unsigned __int64 uint_fast64_t;\n   typedef __int64 intmax_t;\n   typedef unsigned __int64 uintmax_t;\n# else\n#  include <stdint.h>\n# endif\n# if _MSC_VER < 1800   /* MSVC < 2013 */\n   typedef unsigned char _Bool;\n# endif\n#else\n# include <stdint.h>\n# if (defined (__SVR4) && defined (__sun)) || defined(_AIX)\n#  include <alloca.h>\n# endif\n#endif\n\n#include \"malloc_closure.h\"\n\n#if PY_MAJOR_VERSION >= 3\n# define STR_OR_BYTES \"bytes\"\n# define PyText_Type PyUnicode_Type\n# define PyText_Check PyUnicode_Check\n# define PyTextAny_Check PyUnicode_Check\n# define PyText_FromFormat PyUnicode_FromFormat\n# define PyText_AsUTF8 _PyUnicode_AsString   /* PyUnicode_AsUTF8 in Py3.3 */\n# define PyText_AS_UTF8 _PyUnicode_AsString\n# define PyText_GetSize PyUnicode_GetSize\n# define PyText_FromString PyUnicode_FromString\n# define PyText_FromStringAndSize PyUnicode_FromStringAndSize\n# define PyText_InternInPlace PyUnicode_InternInPlace\n# define PyText_InternFromString PyUnicode_InternFromString\n# define PyIntOrLong_Check PyLong_Check\n#else\n# define STR_OR_BYTES \"str\"\n# define PyText_Type PyString_Type\n# define PyText_Check PyString_Check\n# define PyTextAny_Check(op) (PyString_Check(op) || PyUnicode_Check(op))\n# define PyText_FromFormat PyString_FromFormat\n# define PyText_AsUTF8 PyString_AsString\n# define PyText_AS_UTF8 PyString_AS_STRING\n# define PyText_GetSize PyString_Size\n# define PyText_FromString PyString_FromString\n# define PyText_FromStringAndSize PyString_FromStringAndSize\n# define PyText_InternInPlace PyString_InternInPlace\n# define PyText_InternFromString PyString_InternFromString\n# define PyIntOrLong_Check(op) (PyInt_Check(op) || PyLong_Check(op))\n#endif\n\n#if PY_MAJOR_VERSION >= 3\n# define PyInt_FromLong PyLong_FromLong\n# define PyInt_FromSsize_t PyLong_FromSsize_t\n# define PyInt_AsSsize_t PyLong_AsSsize_t\n# define PyInt_AsLong PyLong_AsLong\n#endif\n\n#if PY_MAJOR_VERSION >= 3\n/* This is the default on Python3 and constant has been removed. */\n# define Py_TPFLAGS_CHECKTYPES 0\n#endif\n\n#if PY_MAJOR_VERSION < 3\n#define PyCapsule_New(pointer, name, destructor)        \\\n    (PyCObject_FromVoidPtr(pointer, destructor))\n#endif\n\n/************************************************************/\n\n/* base type flag: exactly one of the following: */\n#define CT_PRIMITIVE_SIGNED   1    /* signed integer */\n#define CT_PRIMITIVE_UNSIGNED 2    /* unsigned integer */\n#define CT_PRIMITIVE_CHAR     4    /* char, wchar_t */\n#define CT_PRIMITIVE_FLOAT    8    /* float, double, long double */\n#define CT_POINTER           16    /* pointer, excluding ptr-to-func */\n#define CT_ARRAY             32    /* array */\n#define CT_STRUCT            64    /* struct */\n#define CT_UNION            128    /* union */\n#define CT_FUNCTIONPTR      256    /* pointer to function */\n#define CT_VOID             512    /* void */\n\n/* other flags that may also be set in addition to the base flag: */\n#define CT_CAST_ANYTHING         1024    /* 'char *' and 'void *' only */\n#define CT_PRIMITIVE_FITS_LONG   2048\n#define CT_IS_OPAQUE             4096\n#define CT_IS_ENUM               8192\n#define CT_IS_PTR_TO_OWNED      16384\n#define CT_CUSTOM_FIELD_POS     32768\n#define CT_IS_LONGDOUBLE        65536\n#define CT_IS_BOOL             131072\n#define CT_IS_FILE             262144\n#define CT_IS_VOID_PTR         524288\n#define CT_WITH_VAR_ARRAY     1048576\n#define CT_IS_UNSIZED_CHAR_A  2097152\n#define CT_LAZY_FIELD_LIST    4194304\n#define CT_PRIMITIVE_ANY  (CT_PRIMITIVE_SIGNED |        \\\n                           CT_PRIMITIVE_UNSIGNED |      \\\n                           CT_PRIMITIVE_CHAR |          \\\n                           CT_PRIMITIVE_FLOAT)\n\ntypedef struct _ctypedescr {\n    PyObject_VAR_HEAD\n\n    struct _ctypedescr *ct_itemdescr;  /* ptrs and arrays: the item type */\n    PyObject *ct_stuff;                /* structs: dict of the fields\n                                          arrays: ctypedescr of the ptr type\n                                          function: tuple(abi, ctres, ctargs..)\n                                          enum: pair {\"name\":x},{x:\"name\"}\n                                          ptrs: lazily, ctypedescr of array */\n    void *ct_extra;                    /* structs: first field (not a ref!)\n                                          function types: cif_description\n                                          primitives: prebuilt \"cif\" object */\n\n    PyObject *ct_weakreflist;    /* weakref support */\n\n    Py_ssize_t ct_size;     /* size of instances, or -1 if unknown */\n    Py_ssize_t ct_length;   /* length of arrays, or -1 if unknown;\n                               or alignment of primitive and struct types;\n                               always -1 for pointers */\n    int ct_flags;           /* CT_xxx flags */\n\n    int ct_name_position;   /* index in ct_name of where to put a var name */\n    char ct_name[1];        /* string, e.g. \"int *\" for pointers to ints */\n} CTypeDescrObject;\n\ntypedef struct {\n    PyObject_HEAD\n    CTypeDescrObject *c_type;\n    char *c_data;\n    PyObject *c_weakreflist;\n} CDataObject;\n\ntypedef struct cfieldobject_s {\n    PyObject_HEAD\n    CTypeDescrObject *cf_type;\n    Py_ssize_t cf_offset;\n    short cf_bitshift;   /* >= 0: bitshift; or BS_REGULAR or BS_EMPTY_ARRAY */\n    short cf_bitsize;\n    struct cfieldobject_s *cf_next;\n} CFieldObject;\n#define BS_REGULAR     (-1)      /* a regular field, not with bitshift */\n#define BS_EMPTY_ARRAY (-2)      /* a field which is an array 'type[0]' */\n\nstatic PyTypeObject CTypeDescr_Type;\nstatic PyTypeObject CField_Type;\nstatic PyTypeObject CData_Type;\nstatic PyTypeObject CDataOwning_Type;\nstatic PyTypeObject CDataOwningGC_Type;\n\n#define CTypeDescr_Check(ob)  (Py_TYPE(ob) == &CTypeDescr_Type)\n#define CData_Check(ob)       (Py_TYPE(ob) == &CData_Type ||            \\\n                               Py_TYPE(ob) == &CDataOwning_Type ||      \\\n                               Py_TYPE(ob) == &CDataOwningGC_Type)\n#define CDataOwn_Check(ob)    (Py_TYPE(ob) == &CDataOwning_Type ||      \\\n                               Py_TYPE(ob) == &CDataOwningGC_Type)\n\ntypedef union {\n    unsigned char m_char;\n    unsigned short m_short;\n    unsigned int m_int;\n    unsigned long m_long;\n    unsigned long long m_longlong;\n    float m_float;\n    double m_double;\n    long double m_longdouble;\n} union_alignment;\n\ntypedef struct {\n    CDataObject head;\n    union_alignment alignment;\n} CDataObject_casted_primitive;\n\ntypedef struct {\n    CDataObject head;\n    union_alignment alignment;\n} CDataObject_own_nolength;\n\ntypedef struct {\n    CDataObject head;\n    Py_ssize_t length;\n    union_alignment alignment;\n} CDataObject_own_length;\n\ntypedef struct {\n    CDataObject head;\n    PyObject *structobj;\n} CDataObject_own_structptr;\n\ntypedef struct {\n    CDataObject head;\n    Py_ssize_t length;     /* same as CDataObject_own_length up to here */\n    Py_buffer *bufferview;\n} CDataObject_owngc_frombuf;\n\ntypedef struct {\n    ffi_cif cif;\n    /* the following information is used when doing the call:\n       - a buffer of size 'exchange_size' is malloced\n       - the arguments are converted from Python objects to raw data\n       - the i'th raw data is stored at 'buffer + exchange_offset_arg[1+i]'\n       - the call is done\n       - the result is read back from 'buffer + exchange_offset_arg[0]' */\n    Py_ssize_t exchange_size;\n    Py_ssize_t exchange_offset_arg[1];\n} cif_description_t;\n\n\n/* whenever running Python code, the errno is saved in this thread-local\n   variable */\n#ifndef MS_WIN32\n# ifdef USE__THREAD\n/* This macro ^^^ is defined by setup.py if it finds that it is\n   syntactically valid to use \"__thread\" with this C compiler. */\nstatic __thread int cffi_saved_errno = 0;\nstatic void save_errno(void) { cffi_saved_errno = errno; }\nstatic void restore_errno(void) { errno = cffi_saved_errno; }\nstatic void init_errno(void) { }\n# else\n#  include \"misc_thread.h\"\n# endif\n# define save_errno_only      save_errno\n# define restore_errno_only   restore_errno\n#endif\n\n#include \"minibuffer.h\"\n\n#if PY_MAJOR_VERSION >= 3\n# include \"file_emulator.h\"\n#endif\n\n#ifdef HAVE_WCHAR_H\n# include \"wchar_helper.h\"\n#endif\n\nstatic PyObject *FFIError;\n\n/************************************************************/\n\nstatic CTypeDescrObject *\nctypedescr_new(int name_size)\n{\n    CTypeDescrObject *ct = PyObject_GC_NewVar(CTypeDescrObject,\n                                              &CTypeDescr_Type,\n                                              name_size);\n    if (ct == NULL)\n        return NULL;\n\n    ct->ct_itemdescr = NULL;\n    ct->ct_stuff = NULL;\n    ct->ct_weakreflist = NULL;\n    PyObject_GC_Track(ct);\n    return ct;\n}\n\nstatic CTypeDescrObject *\nctypedescr_new_on_top(CTypeDescrObject *ct_base, const char *extra_text,\n                      int extra_position)\n{\n    int base_name_len = strlen(ct_base->ct_name);\n    int extra_name_len = strlen(extra_text);\n    CTypeDescrObject *ct = ctypedescr_new(base_name_len + extra_name_len + 1);\n    char *p;\n    if (ct == NULL)\n        return NULL;\n\n    Py_INCREF(ct_base);\n    ct->ct_itemdescr = ct_base;\n    ct->ct_name_position = ct_base->ct_name_position + extra_position;\n\n    p = ct->ct_name;\n    memcpy(p, ct_base->ct_name, ct_base->ct_name_position);\n    p += ct_base->ct_name_position;\n    memcpy(p, extra_text, extra_name_len);\n    p += extra_name_len;\n    memcpy(p, ct_base->ct_name + ct_base->ct_name_position,\n           base_name_len - ct_base->ct_name_position + 1);\n\n    return ct;\n}\n\nstatic PyObject *\nctypedescr_repr(CTypeDescrObject *ct)\n{\n    return PyText_FromFormat(\"<ctype '%s'>\", ct->ct_name);\n}\n\nstatic void\nctypedescr_dealloc(CTypeDescrObject *ct)\n{\n    PyObject_GC_UnTrack(ct);\n    if (ct->ct_weakreflist != NULL)\n        PyObject_ClearWeakRefs((PyObject *) ct);\n    Py_XDECREF(ct->ct_itemdescr);\n    Py_XDECREF(ct->ct_stuff);\n    if (ct->ct_flags & CT_FUNCTIONPTR)\n        PyObject_Free(ct->ct_extra);\n    Py_TYPE(ct)->tp_free((PyObject *)ct);\n}\n\nstatic int\nctypedescr_traverse(CTypeDescrObject *ct, visitproc visit, void *arg)\n{\n    Py_VISIT(ct->ct_itemdescr);\n    Py_VISIT(ct->ct_stuff);\n    return 0;\n}\n\nstatic int\nctypedescr_clear(CTypeDescrObject *ct)\n{\n    Py_CLEAR(ct->ct_itemdescr);\n    Py_CLEAR(ct->ct_stuff);\n    return 0;\n}\n\n\nstatic PyObject *nosuchattr(const char *attr)\n{\n    PyErr_SetString(PyExc_AttributeError, attr);\n    return NULL;\n}\n\nstatic PyObject *ctypeget_kind(CTypeDescrObject *ct, void *context)\n{\n    char *result;\n    if (ct->ct_flags & CT_PRIMITIVE_ANY) {\n        if (ct->ct_flags & CT_IS_ENUM)\n            result = \"enum\";\n        else\n            result = \"primitive\";\n    }\n    else if (ct->ct_flags & CT_POINTER) {\n        result = \"pointer\";\n    }\n    else if (ct->ct_flags & CT_ARRAY) {\n        result = \"array\";\n    }\n    else if (ct->ct_flags & CT_VOID) {\n        result = \"void\";\n    }\n    else if (ct->ct_flags & CT_STRUCT) {\n        result = \"struct\";\n    }\n    else if (ct->ct_flags & CT_UNION) {\n        result = \"union\";\n    }\n    else if (ct->ct_flags & CT_FUNCTIONPTR) {\n        result = \"function\";\n    }\n    else\n        result = \"?\";\n\n    return PyText_FromString(result);\n}\n\nstatic PyObject *ctypeget_cname(CTypeDescrObject *ct, void *context)\n{\n    return PyText_FromString(ct->ct_name);\n}\n\nstatic PyObject *ctypeget_item(CTypeDescrObject *ct, void *context)\n{\n    if (ct->ct_flags & (CT_POINTER | CT_ARRAY)) {\n        Py_INCREF(ct->ct_itemdescr);\n        return (PyObject *)ct->ct_itemdescr;\n    }\n    return nosuchattr(\"item\");\n}\n\nstatic PyObject *ctypeget_length(CTypeDescrObject *ct, void *context)\n{\n    if (ct->ct_flags & CT_ARRAY) {\n        if (ct->ct_length >= 0) {\n            return PyInt_FromSsize_t(ct->ct_length);\n        }\n        else {\n            Py_INCREF(Py_None);\n            return Py_None;\n        }\n    }\n    return nosuchattr(\"length\");\n}\n\nstatic PyObject *\nget_field_name(CTypeDescrObject *ct, CFieldObject *cf);   /* forward */\n\n#define force_lazy_struct(ct)                                           \\\n    ((ct)->ct_stuff != NULL ? 1 : do_realize_lazy_struct(ct))\n\nstatic int do_realize_lazy_struct(CTypeDescrObject *ct);\n/* forward, implemented in realize_c_type.c */\n\nstatic PyObject *ctypeget_fields(CTypeDescrObject *ct, void *context)\n{\n    if (ct->ct_flags & (CT_STRUCT | CT_UNION)) {\n        if (!(ct->ct_flags & CT_IS_OPAQUE)) {\n            CFieldObject *cf;\n            PyObject *res;\n            if (force_lazy_struct(ct) < 0)\n                return NULL;\n            res = PyList_New(0);\n            if (res == NULL)\n                return NULL;\n            for (cf = (CFieldObject *)ct->ct_extra;\n                 cf != NULL; cf = cf->cf_next) {\n                PyObject *o = PyTuple_Pack(2, get_field_name(ct, cf),\n                                           (PyObject *)cf);\n                int err = (o != NULL) ? PyList_Append(res, o) : -1;\n                Py_XDECREF(o);\n                if (err < 0) {\n                    Py_DECREF(res);\n                    return NULL;\n                }\n            }\n            return res;\n        }\n        else {\n            Py_INCREF(Py_None);\n            return Py_None;\n        }\n    }\n    return nosuchattr(\"fields\");\n}\n\nstatic PyObject *ctypeget_args(CTypeDescrObject *ct, void *context)\n{\n    if (ct->ct_flags & CT_FUNCTIONPTR) {\n        PyObject *t = ct->ct_stuff;\n        return PyTuple_GetSlice(t, 2, PyTuple_GET_SIZE(t));\n    }\n    return nosuchattr(\"args\");\n}\n\nstatic PyObject *ctypeget_result(CTypeDescrObject *ct, void *context)\n{\n    if (ct->ct_flags & CT_FUNCTIONPTR) {\n        PyObject *res = PyTuple_GetItem(ct->ct_stuff, 1);\n        Py_XINCREF(res);\n        return res;\n    }\n    return nosuchattr(\"result\");\n}\n\nstatic PyObject *ctypeget_ellipsis(CTypeDescrObject *ct, void *context)\n{\n    if (ct->ct_flags & CT_FUNCTIONPTR) {\n        PyObject *res = ct->ct_extra ? Py_False : Py_True;\n        Py_INCREF(res);\n        return res;\n    }\n    return nosuchattr(\"ellipsis\");\n}\n\nstatic PyObject *ctypeget_abi(CTypeDescrObject *ct, void *context)\n{\n    if (ct->ct_flags & CT_FUNCTIONPTR) {\n        PyObject *res = PyTuple_GetItem(ct->ct_stuff, 0);\n        Py_XINCREF(res);\n        return res;\n    }\n    return nosuchattr(\"abi\");\n}\n\nstatic PyObject *ctypeget_elements(CTypeDescrObject *ct, void *context)\n{\n    if (ct->ct_flags & CT_IS_ENUM) {\n        PyObject *res = PyTuple_GetItem(ct->ct_stuff, 1);\n        if (res) res = PyDict_Copy(res);\n        return res;\n    }\n    return nosuchattr(\"elements\");\n}\n\nstatic PyObject *ctypeget_relements(CTypeDescrObject *ct, void *context)\n{\n    if (ct->ct_flags & CT_IS_ENUM) {\n        PyObject *res = PyTuple_GetItem(ct->ct_stuff, 0);\n        if (res) res = PyDict_Copy(res);\n        return res;\n    }\n    return nosuchattr(\"relements\");\n}\n\nstatic PyGetSetDef ctypedescr_getsets[] = {\n    {\"kind\", (getter)ctypeget_kind, NULL, \"kind\"},\n    {\"cname\", (getter)ctypeget_cname, NULL, \"C name\"},\n    {\"item\", (getter)ctypeget_item, NULL, \"pointer to, or array of\"},\n    {\"length\", (getter)ctypeget_length, NULL, \"array length or None\"},\n    {\"fields\", (getter)ctypeget_fields, NULL, \"struct or union fields\"},\n    {\"args\", (getter)ctypeget_args, NULL, \"function argument types\"},\n    {\"result\", (getter)ctypeget_result, NULL, \"function result type\"},\n    {\"ellipsis\", (getter)ctypeget_ellipsis, NULL, \"function has '...'\"},\n    {\"abi\", (getter)ctypeget_abi, NULL, \"function ABI\"},\n    {\"elements\", (getter)ctypeget_elements, NULL, \"enum elements\"},\n    {\"relements\", (getter)ctypeget_relements, NULL, \"enum elements, reverse\"},\n    {NULL}                        /* sentinel */\n};\n\nstatic PyObject *\nctypedescr_dir(PyObject *ct, PyObject *noarg)\n{\n    int err;\n    struct PyGetSetDef *gsdef;\n    PyObject *res = PyList_New(0);\n    if (res == NULL)\n        return NULL;\n\n    for (gsdef = ctypedescr_getsets; gsdef->name; gsdef++) {\n        PyObject *x = PyObject_GetAttrString(ct, gsdef->name);\n        if (x == NULL) {\n            PyErr_Clear();\n        }\n        else {\n            Py_DECREF(x);\n            x = PyText_FromString(gsdef->name);\n            err = (x != NULL) ? PyList_Append(res, x) : -1;\n            Py_XDECREF(x);\n            if (err < 0) {\n                Py_DECREF(res);\n                return NULL;\n            }\n        }\n    }\n    return res;\n}\n\nstatic PyMethodDef ctypedescr_methods[] = {\n    {\"__dir__\",   ctypedescr_dir,  METH_NOARGS},\n    {NULL,        NULL}           /* sentinel */\n};\n\nstatic PyTypeObject CTypeDescr_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_cffi_backend.CTypeDescr\",\n    offsetof(CTypeDescrObject, ct_name),\n    sizeof(char),\n    (destructor)ctypedescr_dealloc,             /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_compare */\n    (reprfunc)ctypedescr_repr,                  /* tp_repr */\n    0,                                          /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    PyObject_GenericGetAttr,                    /* tp_getattro */\n    0,                                          /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,    /* tp_flags */\n    0,                                          /* tp_doc */\n    (traverseproc)ctypedescr_traverse,          /* tp_traverse */\n    (inquiry)ctypedescr_clear,                  /* tp_clear */\n    0,                                          /* tp_richcompare */\n    offsetof(CTypeDescrObject, ct_weakreflist), /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    ctypedescr_methods,                         /* tp_methods */\n    0,                                          /* tp_members */\n    ctypedescr_getsets,                         /* tp_getset */\n};\n\n/************************************************************/\n\nstatic PyObject *\nget_field_name(CTypeDescrObject *ct, CFieldObject *cf)\n{\n    Py_ssize_t i = 0;\n    PyObject *d_key, *d_value;\n    while (PyDict_Next(ct->ct_stuff, &i, &d_key, &d_value)) {\n        if (d_value == (PyObject *)cf)\n            return d_key;\n    }\n    Py_FatalError(\"_cffi_backend: get_field_name()\");\n    return NULL;\n}\n\nstatic void\ncfield_dealloc(CFieldObject *cf)\n{\n    Py_DECREF(cf->cf_type);\n    PyObject_Del(cf);\n}\n\n#undef OFF\n#define OFF(x) offsetof(CFieldObject, x)\n\nstatic PyMemberDef cfield_members[] = {\n    {\"type\", T_OBJECT, OFF(cf_type), READONLY},\n    {\"offset\", T_PYSSIZET, OFF(cf_offset), READONLY},\n    {\"bitshift\", T_SHORT, OFF(cf_bitshift), READONLY},\n    {\"bitsize\", T_SHORT, OFF(cf_bitsize), READONLY},\n    {NULL}      /* Sentinel */\n};\n#undef OFF\n\nstatic PyTypeObject CField_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_cffi_backend.CField\",\n    sizeof(CFieldObject),\n    0,\n    (destructor)cfield_dealloc,                 /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_compare */\n    0,                                          /* tp_repr */\n    0,                                          /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    PyObject_GenericGetAttr,                    /* tp_getattro */\n    0,                                          /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT,                         /* tp_flags */\n    0,                                          /* tp_doc */\n    0,                                          /* tp_traverse */\n    0,                                          /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    0,                                          /* tp_methods */\n    cfield_members,                             /* tp_members */\n};\n\n/************************************************************/\n\nstatic int\nCDataObject_Or_PyFloat_Check(PyObject *ob)\n{\n    return (PyFloat_Check(ob) ||\n            (CData_Check(ob) &&\n             (((CDataObject *)ob)->c_type->ct_flags & CT_PRIMITIVE_FLOAT)));\n}\n\nstatic PY_LONG_LONG\n_my_PyLong_AsLongLong(PyObject *ob)\n{\n    /* (possibly) convert and cast a Python object to a long long.\n       Like PyLong_AsLongLong(), this version accepts a Python int too, and\n       does convertions from other types of objects.  The difference is that\n       this version refuses floats. */\n#if PY_MAJOR_VERSION < 3\n    if (PyInt_Check(ob)) {\n        return PyInt_AS_LONG(ob);\n    }\n    else \n#endif\n    if (PyLong_Check(ob)) {\n        return PyLong_AsLongLong(ob);\n    }\n    else {\n        PyObject *io;\n        PY_LONG_LONG res;\n        PyNumberMethods *nb = ob->ob_type->tp_as_number;\n\n        if (CDataObject_Or_PyFloat_Check(ob) ||\n                nb == NULL || nb->nb_int == NULL) {\n            PyErr_SetString(PyExc_TypeError, \"an integer is required\");\n            return -1;\n        }\n        io = (*nb->nb_int) (ob);\n        if (io == NULL)\n            return -1;\n\n        if (PyIntOrLong_Check(io)) {\n            res = _my_PyLong_AsLongLong(io);\n        }\n        else {\n            PyErr_SetString(PyExc_TypeError, \"integer conversion failed\");\n            res = -1;\n        }\n        Py_DECREF(io);\n        return res;\n    }\n}\n\nstatic unsigned PY_LONG_LONG\n_my_PyLong_AsUnsignedLongLong(PyObject *ob, int strict)\n{\n    /* (possibly) convert and cast a Python object to an unsigned long long.\n       Like PyLong_AsLongLong(), this version accepts a Python int too, and\n       does convertions from other types of objects.  If 'strict', complains\n       with OverflowError and refuses floats.  If '!strict', rounds floats\n       and masks the result. */\n#if PY_MAJOR_VERSION < 3\n    if (PyInt_Check(ob)) {\n        long value1 = PyInt_AS_LONG(ob);\n        if (strict && value1 < 0)\n            goto negative;\n        return (unsigned PY_LONG_LONG)(PY_LONG_LONG)value1;\n    }\n    else\n#endif\n    if (PyLong_Check(ob)) {\n        if (strict) {\n            if (_PyLong_Sign(ob) < 0)\n                goto negative;\n            return PyLong_AsUnsignedLongLong(ob);\n        }\n        else {\n            return PyLong_AsUnsignedLongLongMask(ob);\n        }\n    }\n    else {\n        PyObject *io;\n        unsigned PY_LONG_LONG res;\n        PyNumberMethods *nb = ob->ob_type->tp_as_number;\n\n        if ((strict && CDataObject_Or_PyFloat_Check(ob)) ||\n                nb == NULL || nb->nb_int == NULL) {\n            PyErr_SetString(PyExc_TypeError, \"an integer is required\");\n            return (unsigned PY_LONG_LONG)-1;\n        }\n        io = (*nb->nb_int) (ob);\n        if (io == NULL)\n            return (unsigned PY_LONG_LONG)-1;\n\n        if (PyIntOrLong_Check(io)) {\n            res = _my_PyLong_AsUnsignedLongLong(io, strict);\n        }\n        else {\n            PyErr_SetString(PyExc_TypeError, \"integer conversion failed\");\n            res = (unsigned PY_LONG_LONG)-1;\n        }\n        Py_DECREF(io);\n        return res;\n    }\n\n negative:\n    PyErr_SetString(PyExc_OverflowError,\n                    \"can't convert negative number to unsigned\");\n    return (unsigned PY_LONG_LONG)-1;\n}\n\n#define _read_raw_data(type)                    \\\n    do {                                        \\\n        if (size == sizeof(type)) {             \\\n            type r;                             \\\n            memcpy(&r, target, sizeof(type));   \\\n            return r;                           \\\n        }                                       \\\n    } while(0)\n\nstatic PY_LONG_LONG\nread_raw_signed_data(char *target, int size)\n{\n    _read_raw_data(signed char);\n    _read_raw_data(short);\n    _read_raw_data(int);\n    _read_raw_data(long);\n    _read_raw_data(PY_LONG_LONG);\n    Py_FatalError(\"read_raw_signed_data: bad integer size\");\n    return 0;\n}\n\nstatic unsigned PY_LONG_LONG\nread_raw_unsigned_data(char *target, int size)\n{\n    _read_raw_data(unsigned char);\n    _read_raw_data(unsigned short);\n    _read_raw_data(unsigned int);\n    _read_raw_data(unsigned long);\n    _read_raw_data(unsigned PY_LONG_LONG);\n    Py_FatalError(\"read_raw_unsigned_data: bad integer size\");\n    return 0;\n}\n\n#define _write_raw_data(type)                           \\\n    do {                                                \\\n        if (size == sizeof(type)) {                     \\\n            type r = (type)source;                      \\\n            memcpy(target, &r, sizeof(type));           \\\n            return;                                     \\\n        }                                               \\\n    } while(0)\n\nstatic void\nwrite_raw_integer_data(char *target, unsigned PY_LONG_LONG source, int size)\n{\n    _write_raw_data(unsigned char);\n    _write_raw_data(unsigned short);\n    _write_raw_data(unsigned int);\n    _write_raw_data(unsigned long);\n    _write_raw_data(unsigned PY_LONG_LONG);\n    Py_FatalError(\"write_raw_integer_data: bad integer size\");\n}\n\nstatic double\nread_raw_float_data(char *target, int size)\n{\n    _read_raw_data(float);\n    _read_raw_data(double);\n    Py_FatalError(\"read_raw_float_data: bad float size\");\n    return 0;\n}\n\nstatic long double\nread_raw_longdouble_data(char *target)\n{\n    int size = sizeof(long double);\n    _read_raw_data(long double);\n    Py_FatalError(\"read_raw_longdouble_data: bad long double size\");\n    return 0;\n}\n\nstatic void\nwrite_raw_float_data(char *target, double source, int size)\n{\n    _write_raw_data(float);\n    _write_raw_data(double);\n    Py_FatalError(\"write_raw_float_data: bad float size\");\n}\n\nstatic void\nwrite_raw_longdouble_data(char *target, long double source)\n{\n    int size = sizeof(long double);\n    _write_raw_data(long double);\n}\n\nstatic PyObject *\nnew_simple_cdata(char *data, CTypeDescrObject *ct)\n{\n    CDataObject *cd = PyObject_New(CDataObject, &CData_Type);\n    if (cd == NULL)\n        return NULL;\n    Py_INCREF(ct);\n    cd->c_data = data;\n    cd->c_type = ct;\n    cd->c_weakreflist = NULL;\n    return (PyObject *)cd;\n}\n\nstatic CDataObject *_new_casted_primitive(CTypeDescrObject *ct);  /*forward*/\n\nstatic PyObject *\nconvert_to_object(char *data, CTypeDescrObject *ct)\n{\n    if (!(ct->ct_flags & CT_PRIMITIVE_ANY)) {\n        /* non-primitive types (check done just for performance) */\n        if (ct->ct_flags & (CT_POINTER|CT_FUNCTIONPTR)) {\n            char *ptrdata = *(char **)data;\n            /*READ(data, sizeof(char *))*/\n            return new_simple_cdata(ptrdata, ct);\n        }\n        else if (ct->ct_flags & CT_IS_OPAQUE) {\n            PyErr_Format(PyExc_TypeError, \"cdata '%s' is opaque\",\n                         ct->ct_name);\n            return NULL;\n        }\n        else if (ct->ct_flags & (CT_STRUCT|CT_UNION)) {\n            return new_simple_cdata(data, ct);\n        }\n        else if (ct->ct_flags & CT_ARRAY) {\n            if (ct->ct_length < 0) {\n                /* we can't return a <cdata 'int[]'> here, because we don't\n                   know the length to give it.  As a compromize, returns\n                   <cdata 'int *'> in this case. */\n                ct = (CTypeDescrObject *)ct->ct_stuff;\n            }\n            return new_simple_cdata(data, ct);\n        }\n    }\n    else if (ct->ct_flags & CT_PRIMITIVE_SIGNED) {\n        PY_LONG_LONG value;\n        /*READ(data, ct->ct_size)*/\n        value = read_raw_signed_data(data, ct->ct_size);\n        if (ct->ct_flags & CT_PRIMITIVE_FITS_LONG)\n            return PyInt_FromLong((long)value);\n        else\n            return PyLong_FromLongLong(value);\n    }\n    else if (ct->ct_flags & CT_PRIMITIVE_UNSIGNED) {\n        unsigned PY_LONG_LONG value;\n        /*READ(data, ct->ct_size)*/\n        value = read_raw_unsigned_data(data, ct->ct_size);\n\n        if (ct->ct_flags & CT_PRIMITIVE_FITS_LONG)\n            return PyInt_FromLong((long)value);\n        else\n            return PyLong_FromUnsignedLongLong(value);\n    }\n    else if (ct->ct_flags & CT_PRIMITIVE_FLOAT) {\n        /*READ(data, ct->ct_size)*/\n        if (!(ct->ct_flags & CT_IS_LONGDOUBLE)) {\n            double value = read_raw_float_data(data, ct->ct_size);\n            return PyFloat_FromDouble(value);\n        }\n        else {\n            long double value = read_raw_longdouble_data(data);\n            CDataObject *cd = _new_casted_primitive(ct);\n            if (cd != NULL)\n                write_raw_longdouble_data(cd->c_data, value);\n            return (PyObject *)cd;\n        }\n    }\n    else if (ct->ct_flags & CT_PRIMITIVE_CHAR) {\n        /*READ(data, ct->ct_size)*/\n        if (ct->ct_size == sizeof(char))\n            return PyBytes_FromStringAndSize(data, 1);\n#ifdef HAVE_WCHAR_H\n        else\n            return _my_PyUnicode_FromWideChar((wchar_t *)data, 1);\n#endif\n    }\n\n    PyErr_Format(PyExc_SystemError,\n                 \"convert_to_object: '%s'\", ct->ct_name);\n    return NULL;\n}\n\nstatic PyObject *\nconvert_to_object_bitfield(char *data, CFieldObject *cf)\n{\n    CTypeDescrObject *ct = cf->cf_type;\n    /*READ(data, ct->ct_size)*/\n\n    if (ct->ct_flags & CT_PRIMITIVE_SIGNED) {\n        unsigned PY_LONG_LONG value, valuemask, shiftforsign;\n        PY_LONG_LONG result;\n\n        value = (unsigned PY_LONG_LONG)read_raw_signed_data(data, ct->ct_size);\n        valuemask = (1ULL << cf->cf_bitsize) - 1ULL;\n        shiftforsign = 1ULL << (cf->cf_bitsize - 1);\n        value = ((value >> cf->cf_bitshift) + shiftforsign) & valuemask;\n        result = ((PY_LONG_LONG)value) - (PY_LONG_LONG)shiftforsign;\n\n        if (ct->ct_flags & CT_PRIMITIVE_FITS_LONG)\n            return PyInt_FromLong((long)result);\n        else\n            return PyLong_FromLongLong(result);\n    }\n    else {\n        unsigned PY_LONG_LONG value, valuemask;\n\n        value = read_raw_unsigned_data(data, ct->ct_size);\n        valuemask = (1ULL << cf->cf_bitsize) - 1ULL;\n        value = (value >> cf->cf_bitshift) & valuemask;\n\n        if (ct->ct_flags & CT_PRIMITIVE_FITS_LONG)\n            return PyInt_FromLong((long)value);\n        else\n            return PyLong_FromUnsignedLongLong(value);\n    }\n}\n\nstatic int _convert_overflow(PyObject *init, const char *ct_name)\n{\n    PyObject *s;\n    if (PyErr_Occurred())   /* already an exception pending */\n        return -1;\n    s = PyObject_Str(init);\n    if (s == NULL)\n        return -1;\n    PyErr_Format(PyExc_OverflowError, \"integer %s does not fit '%s'\",\n                 PyText_AS_UTF8(s), ct_name);\n    Py_DECREF(s);\n    return -1;\n}\n\nstatic int _convert_to_char(PyObject *init)\n{\n    if (PyBytes_Check(init) && PyBytes_GET_SIZE(init) == 1) {\n        return (unsigned char)(PyBytes_AS_STRING(init)[0]);\n    }\n    if (CData_Check(init) &&\n           (((CDataObject *)init)->c_type->ct_flags & CT_PRIMITIVE_CHAR) &&\n           (((CDataObject *)init)->c_type->ct_size == sizeof(char))) {\n        char *data = ((CDataObject *)init)->c_data;\n        /*READ(data, 1)*/\n        return *(unsigned char *)data;\n    }\n    PyErr_Format(PyExc_TypeError,\n                 \"initializer for ctype 'char' must be a \"STR_OR_BYTES\n                 \" of length 1, not %.200s\", Py_TYPE(init)->tp_name);\n    return -1;\n}\n\n#ifdef HAVE_WCHAR_H\nstatic wchar_t _convert_to_wchar_t(PyObject *init)\n{\n    if (PyUnicode_Check(init)) {\n        wchar_t ordinal;\n        if (_my_PyUnicode_AsSingleWideChar(init, &ordinal) == 0)\n            return ordinal;\n    }\n    if (CData_Check(init) &&\n           (((CDataObject *)init)->c_type->ct_flags & CT_PRIMITIVE_CHAR) &&\n           (((CDataObject *)init)->c_type->ct_size == sizeof(wchar_t))) {\n        char *data = ((CDataObject *)init)->c_data;\n        /*READ(data, sizeof(wchar_t))*/\n        return *(wchar_t *)data;\n    }\n    PyErr_Format(PyExc_TypeError,\n                 \"initializer for ctype 'wchar_t' must be a unicode string \"\n                 \"of length 1, not %.200s\", Py_TYPE(init)->tp_name);\n    return (wchar_t)-1;\n}\n#endif\n\nstatic int _convert_error(PyObject *init, const char *ct_name,\n                          const char *expected)\n{\n    if (CData_Check(init))\n        PyErr_Format(PyExc_TypeError,\n                     \"initializer for ctype '%s' must be a %s, \"\n                     \"not cdata '%s'\",\n                     ct_name, expected,\n                     ((CDataObject *)init)->c_type->ct_name);\n    else\n        PyErr_Format(PyExc_TypeError,\n                     \"initializer for ctype '%s' must be a %s, \"\n                     \"not %.200s\",\n                     ct_name, expected, Py_TYPE(init)->tp_name);\n    return -1;\n}\n\nstatic int    /* forward */\nconvert_from_object(char *data, CTypeDescrObject *ct, PyObject *init);\nstatic int    /* forward */\nconvert_from_object_bitfield(char *data, CFieldObject *cf, PyObject *init);\n\nstatic Py_ssize_t\nget_new_array_length(PyObject **pvalue)\n{\n    PyObject *value = *pvalue;\n\n    if (PyList_Check(value) || PyTuple_Check(value)) {\n        return PySequence_Fast_GET_SIZE(value);\n    }\n    else if (PyBytes_Check(value)) {\n        /* from a string, we add the null terminator */\n        return PyBytes_GET_SIZE(value) + 1;\n    }\n    else if (PyUnicode_Check(value)) {\n        /* from a unicode, we add the null terminator */\n        return _my_PyUnicode_SizeAsWideChar(value) + 1;\n    }\n    else {\n        Py_ssize_t explicitlength;\n        explicitlength = PyNumber_AsSsize_t(value, PyExc_OverflowError);\n        if (explicitlength < 0) {\n            if (!PyErr_Occurred())\n                PyErr_SetString(PyExc_ValueError, \"negative array length\");\n            return -1;\n        }\n        *pvalue = Py_None;\n        return explicitlength;\n    }\n}\n\nstatic int\nconvert_field_from_object(char *data, CFieldObject *cf, PyObject *value)\n{\n    data += cf->cf_offset;\n    if (cf->cf_bitshift >= 0)\n        return convert_from_object_bitfield(data, cf, value);\n    else\n        return convert_from_object(data, cf->cf_type, value);\n}\n\nstatic int\nconvert_vfield_from_object(char *data, CFieldObject *cf, PyObject *value,\n                           Py_ssize_t *optvarsize)\n{\n    /* a special case for var-sized C99 arrays */\n    if ((cf->cf_type->ct_flags & CT_ARRAY) && cf->cf_type->ct_size < 0) {\n        Py_ssize_t varsizelength = get_new_array_length(&value);\n        if (varsizelength < 0)\n            return -1;\n        if (optvarsize != NULL) {\n            /* in this mode, the only purpose of this function is to compute\n               the real size of the structure from a var-sized C99 array */\n            Py_ssize_t size, itemsize;\n            assert(data == NULL);\n            itemsize = cf->cf_type->ct_itemdescr->ct_size;\n            size = cf->cf_offset + itemsize * varsizelength;\n            if (size < 0 ||\n                ((size - cf->cf_offset) / itemsize) != varsizelength) {\n                PyErr_SetString(PyExc_OverflowError,\n                                \"array size would overflow a Py_ssize_t\");\n                return -1;\n            }\n            if (size > *optvarsize)\n                *optvarsize = size;\n            return 0;\n        }\n        /* if 'value' was only an integer, get_new_array_length() returns\n           it and convert 'value' to be None.  Detect if this was the case,\n           and if so, stop here, leaving the content uninitialized\n           (it should be zero-initialized from somewhere else). */\n        if (value == Py_None)\n            return 0;\n    }\n    if (optvarsize == NULL)\n        return convert_field_from_object(data, cf, value);\n    else\n        return 0;\n}\n\nstatic int\nconvert_array_from_object(char *data, CTypeDescrObject *ct, PyObject *init)\n{\n    /* used by convert_from_object(), and also to decode lists/tuples/unicodes\n       passed as function arguments.  'ct' is an CT_ARRAY in the first case\n       and a CT_POINTER in the second case. */\n    const char *expected;\n    CTypeDescrObject *ctitem = ct->ct_itemdescr;\n\n    if (PyList_Check(init) || PyTuple_Check(init)) {\n        PyObject **items;\n        Py_ssize_t i, n;\n        n = PySequence_Fast_GET_SIZE(init);\n        if (ct->ct_length >= 0 && n > ct->ct_length) {\n            PyErr_Format(PyExc_IndexError,\n                         \"too many initializers for '%s' (got %zd)\",\n                         ct->ct_name, n);\n            return -1;\n        }\n        items = PySequence_Fast_ITEMS(init);\n        for (i=0; i<n; i++) {\n            if (convert_from_object(data, ctitem, items[i]) < 0)\n                return -1;\n            data += ctitem->ct_size;\n        }\n        return 0;\n    }\n    else if ((ctitem->ct_flags & CT_PRIMITIVE_CHAR) ||\n             ((ctitem->ct_flags & (CT_PRIMITIVE_SIGNED|CT_PRIMITIVE_UNSIGNED))\n              && (ctitem->ct_size == sizeof(char)))) {\n        if (ctitem->ct_size == sizeof(char)) {\n            char *srcdata;\n            Py_ssize_t n;\n            if (!PyBytes_Check(init)) {\n                expected = STR_OR_BYTES\" or list or tuple\";\n                goto cannot_convert;\n            }\n            n = PyBytes_GET_SIZE(init);\n            if (ct->ct_length >= 0 && n > ct->ct_length) {\n                PyErr_Format(PyExc_IndexError,\n                             \"initializer \"STR_OR_BYTES\" is too long for '%s' \"\n                             \"(got %zd characters)\", ct->ct_name, n);\n                return -1;\n            }\n            if (n != ct->ct_length)\n                n++;\n            srcdata = PyBytes_AS_STRING(init);\n            memcpy(data, srcdata, n);\n            return 0;\n        }\n#ifdef HAVE_WCHAR_H\n        else {\n            Py_ssize_t n;\n            if (!PyUnicode_Check(init)) {\n                expected = \"unicode or list or tuple\";\n                goto cannot_convert;\n            }\n            n = _my_PyUnicode_SizeAsWideChar(init);\n            if (ct->ct_length >= 0 && n > ct->ct_length) {\n                PyErr_Format(PyExc_IndexError,\n                             \"initializer unicode is too long for '%s' \"\n                             \"(got %zd characters)\", ct->ct_name, n);\n                return -1;\n            }\n            if (n != ct->ct_length)\n                n++;\n            _my_PyUnicode_AsWideChar(init, (wchar_t *)data, n);\n            return 0;\n        }\n#endif\n    }\n    else {\n        expected = \"list or tuple\";\n        goto cannot_convert;\n    }\n\n cannot_convert:\n    return _convert_error(init, ct->ct_name, expected);\n}\n\nstatic int\nconvert_struct_from_object(char *data, CTypeDescrObject *ct, PyObject *init,\n                           Py_ssize_t *optvarsize)\n{\n    const char *expected;\n\n    if (force_lazy_struct(ct) <= 0) {\n        if (!PyErr_Occurred())\n            PyErr_Format(PyExc_TypeError, \"'%s' is opaque\", ct->ct_name);\n        return -1;\n    }\n\n    if (ct->ct_flags & CT_UNION) {\n        Py_ssize_t n = PyObject_Size(init);\n        if (n < 0)\n            return -1;\n        if (n > 1) {\n            PyErr_Format(PyExc_ValueError,\n                         \"initializer for '%s': %zd items given, but \"\n                         \"only one supported (use a dict if needed)\",\n                         ct->ct_name, n);\n            return -1;\n        }\n    }\n    if (PyList_Check(init) || PyTuple_Check(init)) {\n        PyObject **items = PySequence_Fast_ITEMS(init);\n        Py_ssize_t i, n = PySequence_Fast_GET_SIZE(init);\n        CFieldObject *cf = (CFieldObject *)ct->ct_extra;\n\n        for (i=0; i<n; i++) {\n            if (cf == NULL) {\n                PyErr_Format(PyExc_ValueError,\n                             \"too many initializers for '%s' (got %zd)\",\n                             ct->ct_name, n);\n                return -1;\n            }\n            if (convert_vfield_from_object(data, cf, items[i], optvarsize) < 0)\n                return -1;\n            cf = cf->cf_next;\n        }\n        return 0;\n    }\n    if (PyDict_Check(init)) {\n        PyObject *d_key, *d_value;\n        Py_ssize_t i = 0;\n        CFieldObject *cf;\n\n        while (PyDict_Next(init, &i, &d_key, &d_value)) {\n            cf = (CFieldObject *)PyDict_GetItem(ct->ct_stuff, d_key);\n            if (cf == NULL) {\n                PyErr_SetObject(PyExc_KeyError, d_key);\n                return -1;\n            }\n            if (convert_vfield_from_object(data, cf, d_value, optvarsize) < 0)\n                return -1;\n        }\n        return 0;\n    }\n    expected = optvarsize == NULL ? \"list or tuple or dict or struct-cdata\"\n                                  : \"list or tuple or dict\";\n    return _convert_error(init, ct->ct_name, expected);\n}\n\n#ifdef __GNUC__\n# if __GNUC__ >= 4\n/* Don't go inlining this huge function.  Needed because occasionally\n   it gets inlined in places where is causes a warning: call to\n   __builtin___memcpy_chk will always overflow destination buffer\n   (which is places where the 'ct' should never represent such a large\n   primitive type anyway). */\n__attribute__((noinline))\n# endif\n#endif\nstatic int\nconvert_from_object(char *data, CTypeDescrObject *ct, PyObject *init)\n{\n    const char *expected;\n    char buf[sizeof(PY_LONG_LONG)];\n\n    /*if (ct->ct_size > 0)*/\n        /*WRITE(data, ct->ct_size)*/\n\n    if (ct->ct_flags & CT_ARRAY) {\n        return convert_array_from_object(data, ct, init);\n    }\n    if (ct->ct_flags & (CT_POINTER|CT_FUNCTIONPTR)) {\n        char *ptrdata;\n        CTypeDescrObject *ctinit;\n\n        if (!CData_Check(init)) {\n            expected = \"cdata pointer\";\n            goto cannot_convert;\n        }\n        ctinit = ((CDataObject *)init)->c_type;\n        if (!(ctinit->ct_flags & (CT_POINTER|CT_FUNCTIONPTR))) {\n            if (ctinit->ct_flags & CT_ARRAY)\n                ctinit = (CTypeDescrObject *)ctinit->ct_stuff;\n            else {\n                expected = \"pointer or array\";\n                goto cannot_convert;\n            }\n        }\n        if (ctinit != ct) {\n            if ((ct->ct_flags & CT_CAST_ANYTHING) ||\n                (ctinit->ct_flags & CT_CAST_ANYTHING))\n                ;   /* accept void* or char* as either source or target */\n            else {\n                expected = \"pointer to same type\";\n                goto cannot_convert;\n            }\n        }\n        ptrdata = ((CDataObject *)init)->c_data;\n\n        *(char **)data = ptrdata;\n        return 0;\n    }\n    if (ct->ct_flags & CT_PRIMITIVE_SIGNED) {\n        PY_LONG_LONG value = _my_PyLong_AsLongLong(init);\n        if (value == -1 && PyErr_Occurred())\n            return -1;\n        write_raw_integer_data(buf, value, ct->ct_size);\n        if (value != read_raw_signed_data(buf, ct->ct_size))\n            goto overflow;\n        write_raw_integer_data(data, value, ct->ct_size);\n        return 0;\n    }\n    if (ct->ct_flags & CT_PRIMITIVE_UNSIGNED) {\n        unsigned PY_LONG_LONG value = _my_PyLong_AsUnsignedLongLong(init, 1);\n        if (value == (unsigned PY_LONG_LONG)-1 && PyErr_Occurred())\n            return -1;\n        if (ct->ct_flags & CT_IS_BOOL)\n            if (value & ~1)      /* value != 0 && value != 1 */\n                goto overflow;\n        write_raw_integer_data(buf, value, ct->ct_size);\n        if (value != read_raw_unsigned_data(buf, ct->ct_size))\n            goto overflow;\n        write_raw_integer_data(data, value, ct->ct_size);\n        return 0;\n    }\n    if (ct->ct_flags & CT_PRIMITIVE_FLOAT) {\n        double value;\n        if ((ct->ct_flags & CT_IS_LONGDOUBLE) &&\n                CData_Check(init) &&\n                (((CDataObject *)init)->c_type->ct_flags & CT_IS_LONGDOUBLE)) {\n            long double lvalue;\n            char *initdata = ((CDataObject *)init)->c_data;\n            /*READ(initdata, sizeof(long double))*/\n            lvalue = read_raw_longdouble_data(initdata);\n            write_raw_longdouble_data(data, lvalue);\n            return 0;\n        }\n        value = PyFloat_AsDouble(init);\n        if (value == -1.0 && PyErr_Occurred())\n            return -1;\n        if (!(ct->ct_flags & CT_IS_LONGDOUBLE))\n            write_raw_float_data(data, value, ct->ct_size);\n        else\n            write_raw_longdouble_data(data, (long double)value);\n        return 0;\n    }\n    if (ct->ct_flags & CT_PRIMITIVE_CHAR) {\n        if (ct->ct_size == sizeof(char)) {\n            int res = _convert_to_char(init);\n            if (res < 0)\n                return -1;\n            data[0] = res;\n            return 0;\n        }\n#ifdef HAVE_WCHAR_H\n        else {\n            wchar_t res = _convert_to_wchar_t(init);\n            if (res == (wchar_t)-1 && PyErr_Occurred())\n                return -1;\n            *(wchar_t *)data = res;\n            return 0;\n        }\n#endif\n    }\n    if (ct->ct_flags & (CT_STRUCT|CT_UNION)) {\n\n        if (CData_Check(init)) {\n            if (((CDataObject *)init)->c_type == ct && ct->ct_size >= 0) {\n                memcpy(data, ((CDataObject *)init)->c_data, ct->ct_size);\n                return 0;\n            }\n        }\n        return convert_struct_from_object(data, ct, init, NULL);\n    }\n    PyErr_Format(PyExc_SystemError,\n                 \"convert_from_object: '%s'\", ct->ct_name);\n    return -1;\n\n overflow:\n    return _convert_overflow(init, ct->ct_name);\n\n cannot_convert:\n    return _convert_error(init, ct->ct_name, expected);\n}\n\nstatic int\nconvert_from_object_bitfield(char *data, CFieldObject *cf, PyObject *init)\n{\n    CTypeDescrObject *ct = cf->cf_type;\n    PY_LONG_LONG fmin, fmax, value = PyLong_AsLongLong(init);\n    unsigned PY_LONG_LONG rawfielddata, rawvalue, rawmask;\n    if (value == -1 && PyErr_Occurred())\n        return -1;\n\n    if (ct->ct_flags & CT_PRIMITIVE_SIGNED) {\n        fmin = -(1LL << (cf->cf_bitsize-1));\n        fmax = (1LL << (cf->cf_bitsize-1)) - 1LL;\n        if (fmax == 0)\n            fmax = 1;    /* special case to let \"int x:1\" receive \"1\" */\n    }\n    else {\n        fmin = 0LL;\n        fmax = (PY_LONG_LONG)((1ULL << cf->cf_bitsize) - 1ULL);\n    }\n    if (value < fmin || value > fmax) {\n        /* phew, PyErr_Format does not support \"%lld\" in Python 2.6 */\n        PyObject *svalue = NULL, *sfmin = NULL, *sfmax = NULL;\n        PyObject *lfmin = NULL, *lfmax = NULL;\n        svalue = PyObject_Str(init);\n        if (svalue == NULL) goto skip;\n        lfmin = PyLong_FromLongLong(fmin);\n        if (lfmin == NULL) goto skip;\n        sfmin = PyObject_Str(lfmin);\n        if (sfmin == NULL) goto skip;\n        lfmax = PyLong_FromLongLong(fmax);\n        if (lfmax == NULL) goto skip;\n        sfmax = PyObject_Str(lfmax);\n        if (sfmax == NULL) goto skip;\n        PyErr_Format(PyExc_OverflowError,\n                     \"value %s outside the range allowed by the \"\n                     \"bit field width: %s <= x <= %s\",\n                     PyText_AS_UTF8(svalue),\n                     PyText_AS_UTF8(sfmin),\n                     PyText_AS_UTF8(sfmax));\n       skip:\n        Py_XDECREF(svalue);\n        Py_XDECREF(sfmin);\n        Py_XDECREF(sfmax);\n        Py_XDECREF(lfmin);\n        Py_XDECREF(lfmax);\n        return -1;\n    }\n\n    rawmask = ((1ULL << cf->cf_bitsize) - 1ULL) << cf->cf_bitshift;\n    rawvalue = ((unsigned PY_LONG_LONG)value) << cf->cf_bitshift;\n    /*WRITE(data, ct->ct_size)*/\n    rawfielddata = read_raw_unsigned_data(data, ct->ct_size);\n    rawfielddata = (rawfielddata & ~rawmask) | (rawvalue & rawmask);\n    write_raw_integer_data(data, rawfielddata, ct->ct_size);\n    return 0;\n}\n\nstatic Py_ssize_t\nget_array_length(CDataObject *cd)\n{\n    if (cd->c_type->ct_length < 0)\n        return ((CDataObject_own_length *)cd)->length;\n    else\n        return cd->c_type->ct_length;\n}\n\nstatic int\nget_alignment(CTypeDescrObject *ct)\n{\n    int align;\n retry:\n    if ((ct->ct_flags & (CT_PRIMITIVE_ANY|CT_STRUCT|CT_UNION)) &&\n        !(ct->ct_flags & CT_IS_OPAQUE)) {\n        align = ct->ct_length;\n        if (align == -1 && (ct->ct_flags & CT_LAZY_FIELD_LIST)) {\n            force_lazy_struct(ct);\n            align = ct->ct_length;\n        }\n    }\n    else if (ct->ct_flags & (CT_POINTER|CT_FUNCTIONPTR)) {\n        struct aligncheck_ptr { char x; char *y; };\n        align = offsetof(struct aligncheck_ptr, y);\n    }\n    else if (ct->ct_flags & CT_ARRAY) {\n        ct = ct->ct_itemdescr;\n        goto retry;\n    }\n    else {\n        PyErr_Format(PyExc_ValueError, \"ctype '%s' is of unknown alignment\",\n                     ct->ct_name);\n        return -1;\n    }\n\n    if ((align < 1) || (align & (align-1))) {\n        PyErr_Format(PyExc_SystemError,\n                     \"found for ctype '%s' bogus alignment '%d'\",\n                     ct->ct_name, align);\n        return -1;\n    }\n    return align;\n}\n\nstatic void cdata_dealloc(CDataObject *cd)\n{\n    if (cd->c_weakreflist != NULL)\n        PyObject_ClearWeakRefs((PyObject *) cd);\n\n    Py_DECREF(cd->c_type);\n#ifndef CFFI_MEM_LEAK     /* never release anything, tests only */\n    Py_TYPE(cd)->tp_free((PyObject *)cd);\n#endif\n}\n\nstatic void cdataowning_dealloc(CDataObject *cd)\n{\n    assert(!(cd->c_type->ct_flags & (CT_IS_VOID_PTR | CT_FUNCTIONPTR)));\n\n    if (cd->c_type->ct_flags & CT_IS_PTR_TO_OWNED) {\n        Py_DECREF(((CDataObject_own_structptr *)cd)->structobj);\n    }\n#if defined(CFFI_MEM_DEBUG) || defined(CFFI_MEM_LEAK)\n    if (cd->c_type->ct_flags & (CT_PRIMITIVE_ANY | CT_STRUCT | CT_UNION)) {\n        assert(cd->c_type->ct_size >= 0);\n        memset(cd->c_data, 0xDD, cd->c_type->ct_size);\n    }\n    else if (cd->c_type->ct_flags & CT_ARRAY) {\n        Py_ssize_t x = get_array_length(cd);\n        assert(x >= 0);\n        x *= cd->c_type->ct_itemdescr->ct_size;\n        assert(x >= 0);\n        memset(cd->c_data, 0xDD, x);\n    }\n#endif\n    cdata_dealloc(cd);\n}\n\nstatic void cdataowninggc_dealloc(CDataObject *cd)\n{\n    assert(!(cd->c_type->ct_flags & (CT_IS_PTR_TO_OWNED |\n                                     CT_PRIMITIVE_ANY |\n                                     CT_STRUCT | CT_UNION)));\n    PyObject_GC_UnTrack(cd);\n\n    if (cd->c_type->ct_flags & CT_IS_VOID_PTR) {        /* a handle */\n        PyObject *x = (PyObject *)(cd->c_data + 42);\n        Py_DECREF(x);\n    }\n    else if (cd->c_type->ct_flags & CT_FUNCTIONPTR) {   /* a callback */\n        ffi_closure *closure = (ffi_closure *)cd->c_data;\n        PyObject *args = (PyObject *)(closure->user_data);\n        Py_XDECREF(args);\n        cffi_closure_free(closure);\n    }\n    else if (cd->c_type->ct_flags & CT_IS_UNSIZED_CHAR_A) {  /* from_buffer */\n        Py_buffer *view = ((CDataObject_owngc_frombuf *)cd)->bufferview;\n        PyBuffer_Release(view);\n        PyObject_Free(view);\n    }\n    cdata_dealloc(cd);\n}\n\nstatic int cdataowninggc_traverse(CDataObject *cd, visitproc visit, void *arg)\n{\n    if (cd->c_type->ct_flags & CT_IS_VOID_PTR) {        /* a handle */\n        PyObject *x = (PyObject *)(cd->c_data + 42);\n        Py_VISIT(x);\n    }\n    else if (cd->c_type->ct_flags & CT_FUNCTIONPTR) {   /* a callback */\n        ffi_closure *closure = (ffi_closure *)cd->c_data;\n        PyObject *args = (PyObject *)(closure->user_data);\n        Py_VISIT(args);\n    }\n    else if (cd->c_type->ct_flags & CT_IS_UNSIZED_CHAR_A) {  /* from_buffer */\n        Py_buffer *view = ((CDataObject_owngc_frombuf *)cd)->bufferview;\n        Py_VISIT(view->obj);\n    }\n    return 0;\n}\n\nstatic int cdataowninggc_clear(CDataObject *cd)\n{\n    if (cd->c_type->ct_flags & CT_IS_VOID_PTR) {        /* a handle */\n        PyObject *x = (PyObject *)(cd->c_data + 42);\n        Py_INCREF(Py_None);\n        cd->c_data = ((char *)Py_None) - 42;\n        Py_DECREF(x);\n    }\n    else if (cd->c_type->ct_flags & CT_FUNCTIONPTR) {   /* a callback */\n        ffi_closure *closure = (ffi_closure *)cd->c_data;\n        PyObject *args = (PyObject *)(closure->user_data);\n        closure->user_data = NULL;\n        Py_XDECREF(args);\n    }\n    else if (cd->c_type->ct_flags & CT_IS_UNSIZED_CHAR_A) {  /* from_buffer */\n        Py_buffer *view = ((CDataObject_owngc_frombuf *)cd)->bufferview;\n        PyBuffer_Release(view);\n    }\n    return 0;\n}\n\nstatic PyObject *cdata_float(CDataObject *cd);  /*forward*/\n\nstatic PyObject *convert_cdata_to_enum_string(CDataObject *cd, int both)\n{\n    PyObject *d_key, *d_value;\n    CTypeDescrObject *ct = cd->c_type;\n\n    assert(ct->ct_flags & CT_IS_ENUM);\n    d_key = convert_to_object(cd->c_data, ct);\n    if (d_key == NULL)\n        return NULL;\n\n    d_value = PyDict_GetItem(PyTuple_GET_ITEM(ct->ct_stuff, 1), d_key);\n    if (d_value != NULL) {\n        if (both) {\n            PyObject *o = PyObject_Str(d_key);\n            if (o == NULL)\n                d_value = NULL;\n            else {\n                d_value = PyText_FromFormat(\"%s: %s\",\n                                            PyText_AS_UTF8(o),\n                                            PyText_AS_UTF8(d_value));\n                Py_DECREF(o);\n            }\n        }\n        else\n            Py_INCREF(d_value);\n    }\n    else\n        d_value = PyObject_Str(d_key);\n    Py_DECREF(d_key);\n    return d_value;\n}\n\nstatic PyObject *cdata_repr(CDataObject *cd)\n{\n    char *extra;\n    PyObject *result, *s;\n\n    if (cd->c_type->ct_flags & CT_PRIMITIVE_ANY) {\n        if (cd->c_type->ct_flags & CT_IS_ENUM) {\n            s = convert_cdata_to_enum_string(cd, 1);\n        }\n        else if (cd->c_type->ct_flags & CT_IS_LONGDOUBLE) {\n            long double lvalue;\n            char buffer[128];   /* big enough */\n            /*READ(cd->c_data, sizeof(long double)*/\n            lvalue = read_raw_longdouble_data(cd->c_data);\n            sprintf(buffer, \"%LE\", lvalue);\n            s = PyText_FromString(buffer);\n        }\n        else {\n            PyObject *o = convert_to_object(cd->c_data, cd->c_type);\n            if (o == NULL)\n                return NULL;\n            s = PyObject_Repr(o);\n            Py_DECREF(o);\n        }\n    }\n    else if ((cd->c_type->ct_flags & CT_ARRAY) && cd->c_type->ct_length < 0) {\n        s = PyText_FromFormat(\"sliced length %zd\", get_array_length(cd));\n    }\n    else {\n        if (cd->c_data != NULL) {\n            s = PyText_FromFormat(\"%p\", cd->c_data);\n        }\n        else\n            s = PyText_FromString(\"NULL\");\n    }\n    if (s == NULL)\n        return NULL;\n    /* it's slightly confusing to get \"<cdata 'struct foo' 0x...>\" because the\n       struct foo is not owned.  Trying to make it clearer, write in this\n       case \"<cdata 'struct foo &' 0x...>\". */\n    if (cd->c_type->ct_flags & (CT_STRUCT|CT_UNION))\n        extra = \" &\";\n    else\n        extra = \"\";\n    result = PyText_FromFormat(\"<cdata '%s%s' %s>\",\n                               cd->c_type->ct_name, extra,\n                               PyText_AsUTF8(s));\n    Py_DECREF(s);\n    return result;\n}\n\nstatic PyObject *_cdata_repr2(CDataObject *cd, char *text, PyObject *x)\n{\n    PyObject *res, *s = PyObject_Repr(x);\n    if (s == NULL)\n        return NULL;\n    res = PyText_FromFormat(\"<cdata '%s' %s %s>\",\n                            cd->c_type->ct_name, text, PyText_AsUTF8(s));\n    Py_DECREF(s);\n    return res;\n}\n\nstatic PyObject *cdataowning_repr(CDataObject *cd)\n{\n    Py_ssize_t size;\n    if (cd->c_type->ct_flags & CT_POINTER)\n        size = cd->c_type->ct_itemdescr->ct_size;\n    else if (cd->c_type->ct_flags & CT_ARRAY)\n        size = get_array_length(cd) * cd->c_type->ct_itemdescr->ct_size;\n    else\n        size = cd->c_type->ct_size;\n\n    return PyText_FromFormat(\"<cdata '%s' owning %zd bytes>\",\n                             cd->c_type->ct_name, size);\n}\n\nstatic PyObject *cdataowninggc_repr(CDataObject *cd)\n{\n    if (cd->c_type->ct_flags & CT_IS_VOID_PTR) {        /* a handle */\n        PyObject *x = (PyObject *)(cd->c_data + 42);\n        return _cdata_repr2(cd, \"handle to\", x);\n    }\n    else if (cd->c_type->ct_flags & CT_FUNCTIONPTR) {   /* a callback */\n        PyObject *args = (PyObject *)((ffi_closure *)cd->c_data)->user_data;\n        if (args == NULL)\n            return cdata_repr(cd);\n        else\n            return _cdata_repr2(cd, \"calling\", PyTuple_GET_ITEM(args, 1));\n    }\n    else if (cd->c_type->ct_flags & CT_IS_UNSIZED_CHAR_A) {  /* from_buffer */\n        Py_buffer *view = ((CDataObject_owngc_frombuf *)cd)->bufferview;\n        Py_ssize_t buflen = get_array_length(cd);\n        return PyText_FromFormat(\n            \"<cdata '%s' buffer len %zd from '%.200s' object>\",\n            cd->c_type->ct_name,\n            buflen,\n            view->obj ? Py_TYPE(view->obj)->tp_name : \"(null)\");\n    }\n    return cdataowning_repr(cd);\n}\n\nstatic int cdata_nonzero(CDataObject *cd)\n{\n    return cd->c_data != NULL;\n}\n\nstatic PyObject *cdata_int(CDataObject *cd)\n{\n    if ((cd->c_type->ct_flags & (CT_PRIMITIVE_SIGNED|CT_PRIMITIVE_FITS_LONG))\n                             == (CT_PRIMITIVE_SIGNED|CT_PRIMITIVE_FITS_LONG)) {\n        /* this case is to handle enums, but also serves as a slight\n           performance improvement for some other primitive types */\n        long value;\n        /*READ(cd->c_data, cd->c_type->ct_size)*/\n        value = (long)read_raw_signed_data(cd->c_data, cd->c_type->ct_size);\n        return PyInt_FromLong(value);\n    }\n    if (cd->c_type->ct_flags & (CT_PRIMITIVE_SIGNED|CT_PRIMITIVE_UNSIGNED)) {\n        return convert_to_object(cd->c_data, cd->c_type);\n    }\n    else if (cd->c_type->ct_flags & CT_PRIMITIVE_CHAR) {\n        /*READ(cd->c_data, cd->c_type->ct_size)*/\n        if (cd->c_type->ct_size == sizeof(char))\n            return PyInt_FromLong((unsigned char)cd->c_data[0]);\n#ifdef HAVE_WCHAR_H\n        else\n            return PyInt_FromLong((long)*(wchar_t *)cd->c_data);\n#endif\n    }\n    else if (cd->c_type->ct_flags & CT_PRIMITIVE_FLOAT) {\n        PyObject *o = cdata_float(cd);\n#if PY_MAJOR_VERSION < 3\n        PyObject *r = o ? PyNumber_Int(o) : NULL;\n#else\n        PyObject *r = o ? PyNumber_Long(o) : NULL;\n#endif\n        Py_XDECREF(o);\n        return r;\n    }\n    PyErr_Format(PyExc_TypeError, \"int() not supported on cdata '%s'\",\n                 cd->c_type->ct_name);\n    return NULL;\n}\n\n#if PY_MAJOR_VERSION < 3\nstatic PyObject *cdata_long(CDataObject *cd)\n{\n    PyObject *res = cdata_int(cd);\n    if (res != NULL && PyInt_CheckExact(res)) {\n        PyObject *o = PyLong_FromLong(PyInt_AS_LONG(res));\n        Py_DECREF(res);\n        res = o;\n    }\n    return res;\n}\n#endif\n\nstatic PyObject *cdata_float(CDataObject *cd)\n{\n    if (cd->c_type->ct_flags & CT_PRIMITIVE_FLOAT) {\n        double value;\n        /*READ(cd->c_data, cd->c_type->ct_size)*/\n        if (!(cd->c_type->ct_flags & CT_IS_LONGDOUBLE)) {\n            value = read_raw_float_data(cd->c_data, cd->c_type->ct_size);\n        }\n        else {\n            value = (double)read_raw_longdouble_data(cd->c_data);\n        }\n        return PyFloat_FromDouble(value);\n    }\n    PyErr_Format(PyExc_TypeError, \"float() not supported on cdata '%s'\",\n                 cd->c_type->ct_name);\n    return NULL;\n}\n\nstatic PyObject *cdata_richcompare(PyObject *v, PyObject *w, int op)\n{\n    int res;\n    PyObject *pyres;\n    char *v_cdata, *w_cdata;\n\n    assert(CData_Check(v));\n    if (!CData_Check(w)) {\n        pyres = Py_NotImplemented;\n        goto done;\n    }\n\n    if ((op != Py_EQ && op != Py_NE) &&\n        ((((CDataObject *)v)->c_type->ct_flags & CT_PRIMITIVE_ANY) ||\n         (((CDataObject *)w)->c_type->ct_flags & CT_PRIMITIVE_ANY)))\n        goto Error;\n\n    v_cdata = ((CDataObject *)v)->c_data;\n    w_cdata = ((CDataObject *)w)->c_data;\n\n    switch (op) {\n    case Py_EQ: res = (v_cdata == w_cdata); break;\n    case Py_NE: res = (v_cdata != w_cdata); break;\n    case Py_LT: res = (v_cdata <  w_cdata); break;\n    case Py_LE: res = (v_cdata <= w_cdata); break;\n    case Py_GT: res = (v_cdata >  w_cdata); break;\n    case Py_GE: res = (v_cdata >= w_cdata); break;\n    default: res = -1;\n    }\n    pyres = res ? Py_True : Py_False;\n done:\n    Py_INCREF(pyres);\n    return pyres;\n\n Error:\n    PyErr_SetString(PyExc_TypeError,\n                    \"cannot do comparison on a primitive cdata\");\n    return NULL;\n}\n\nstatic long cdata_hash(CDataObject *cd)\n{\n    return _Py_HashPointer(cd->c_data);\n}\n\nstatic Py_ssize_t\ncdata_length(CDataObject *cd)\n{\n    if (cd->c_type->ct_flags & CT_ARRAY) {\n        return get_array_length(cd);\n    }\n    PyErr_Format(PyExc_TypeError, \"cdata of type '%s' has no len()\",\n                 cd->c_type->ct_name);\n    return -1;\n}\n\nstatic char *\n_cdata_get_indexed_ptr(CDataObject *cd, PyObject *key)\n{\n    Py_ssize_t i = PyNumber_AsSsize_t(key, PyExc_IndexError);\n    if (i == -1 && PyErr_Occurred())\n        return NULL;\n\n    if (cd->c_type->ct_flags & CT_POINTER) {\n        if (CDataOwn_Check(cd) && i != 0) {\n            PyErr_Format(PyExc_IndexError,\n                         \"cdata '%s' can only be indexed by 0\",\n                         cd->c_type->ct_name);\n            return NULL;\n        }\n    }\n    else if (cd->c_type->ct_flags & CT_ARRAY) {\n        if (i < 0) {\n            PyErr_SetString(PyExc_IndexError,\n                            \"negative index not supported\");\n            return NULL;\n        }\n        if (i >= get_array_length(cd)) {\n            PyErr_Format(PyExc_IndexError,\n                         \"index too large for cdata '%s' (expected %zd < %zd)\",\n                         cd->c_type->ct_name,\n                         i, get_array_length(cd));\n            return NULL;\n        }\n    }\n    else {\n        PyErr_Format(PyExc_TypeError, \"cdata of type '%s' cannot be indexed\",\n                     cd->c_type->ct_name);\n        return NULL;\n    }\n    return cd->c_data + i * cd->c_type->ct_itemdescr->ct_size;\n}\n\nstatic PyObject *\nnew_array_type(CTypeDescrObject *ctptr, Py_ssize_t length);   /* forward */\n\nstatic CTypeDescrObject *\n_cdata_getslicearg(CDataObject *cd, PySliceObject *slice, Py_ssize_t bounds[])\n{\n    Py_ssize_t start, stop;\n    CTypeDescrObject *ct;\n\n    start = PyInt_AsSsize_t(slice->start);\n    if (start == -1 && PyErr_Occurred()) {\n        if (slice->start == Py_None)\n            PyErr_SetString(PyExc_IndexError, \"slice start must be specified\");\n        return NULL;\n    }\n    stop = PyInt_AsSsize_t(slice->stop);\n    if (stop == -1 && PyErr_Occurred()) {\n        if (slice->stop == Py_None)\n            PyErr_SetString(PyExc_IndexError, \"slice stop must be specified\");\n        return NULL;\n    }\n    if (slice->step != Py_None) {\n        PyErr_SetString(PyExc_IndexError, \"slice with step not supported\");\n        return NULL;\n    }\n    if (start > stop) {\n        PyErr_SetString(PyExc_IndexError, \"slice start > stop\");\n        return NULL;\n    }\n\n    ct = cd->c_type;\n    if (ct->ct_flags & CT_ARRAY) {\n        if (start < 0) {\n            PyErr_SetString(PyExc_IndexError,\n                            \"negative index not supported\");\n            return NULL;\n        }\n        if (stop > get_array_length(cd)) {\n            PyErr_Format(PyExc_IndexError,\n                         \"index too large (expected %zd <= %zd)\",\n                         stop, get_array_length(cd));\n            return NULL;\n        }\n        ct = (CTypeDescrObject *)ct->ct_stuff;\n    }\n    else if (!(ct->ct_flags & CT_POINTER)) {\n        PyErr_Format(PyExc_TypeError, \"cdata of type '%s' cannot be indexed\",\n                     ct->ct_name);\n        return NULL;\n    }\n\n    bounds[0] = start;\n    bounds[1] = stop - start;\n    return ct;\n}\n\nstatic PyObject *\ncdata_slice(CDataObject *cd, PySliceObject *slice)\n{\n    Py_ssize_t bounds[2];\n    CDataObject_own_length *scd;\n    CTypeDescrObject *ct = _cdata_getslicearg(cd, slice, bounds);\n    if (ct == NULL)\n        return NULL;\n\n    if (ct->ct_stuff == NULL) {\n        ct->ct_stuff = new_array_type(ct, -1);\n        if (ct->ct_stuff == NULL)\n            return NULL;\n    }\n    ct = (CTypeDescrObject *)ct->ct_stuff;\n\n    scd = (CDataObject_own_length *)PyObject_Malloc(\n              offsetof(CDataObject_own_length, alignment));\n    if (PyObject_Init((PyObject *)scd, &CData_Type) == NULL)\n        return NULL;\n    Py_INCREF(ct);\n    scd->head.c_type = ct;\n    scd->head.c_data = cd->c_data + ct->ct_itemdescr->ct_size * bounds[0];\n    scd->head.c_weakreflist = NULL;\n    scd->length = bounds[1];\n    return (PyObject *)scd;\n}\n\nstatic int\ncdata_ass_slice(CDataObject *cd, PySliceObject *slice, PyObject *v)\n{\n    Py_ssize_t bounds[2], i, length, itemsize;\n    PyObject *it, *item;\n    PyObject *(*iternext)(PyObject *);\n    char *cdata;\n    int err;\n    CTypeDescrObject *ct = _cdata_getslicearg(cd, slice, bounds);\n    if (ct == NULL)\n        return -1;\n    ct = ct->ct_itemdescr;\n    itemsize = ct->ct_size;\n    cdata = cd->c_data + itemsize * bounds[0];\n    length = bounds[1];\n\n    if (CData_Check(v)) {\n        CTypeDescrObject *ctv = ((CDataObject *)v)->c_type;\n        if ((ctv->ct_flags & CT_ARRAY) && (ctv->ct_itemdescr == ct) &&\n            (get_array_length((CDataObject *)v) == length)) {\n            /* fast path: copying from exactly the correct type */\n            memmove(cdata, ((CDataObject *)v)->c_data, itemsize * length);\n            return 0;\n        }\n    }\n\n    /* A fast path for <char[]>[0:N] = b\"somestring\", which also adds\n       support for Python 3: otherwise, you get integers while enumerating\n       the string, and you can't set them to characters :-/\n    */\n    if (PyBytes_Check(v) && (ct->ct_flags & CT_PRIMITIVE_CHAR)\n            && itemsize == sizeof(char)) {\n        if (PyBytes_GET_SIZE(v) != length) {\n            PyErr_Format(PyExc_ValueError,\n                         \"need a string of length %zd, got %zd\",\n                         length, PyBytes_GET_SIZE(v));\n            return -1;\n        }\n        memcpy(cdata, PyBytes_AS_STRING(v), length);\n        return 0;\n    }\n\n    it = PyObject_GetIter(v);\n    if (it == NULL)\n        return -1;\n    iternext = *it->ob_type->tp_iternext;\n\n    for (i = 0; i < length; i++) {\n        item = iternext(it);\n        if (item == NULL) {\n            if (!PyErr_Occurred())\n                PyErr_Format(PyExc_ValueError,\n                             \"need %zd values to unpack, got %zd\",\n                             length, i);\n            goto error;\n        }\n        err = convert_from_object(cdata, ct, item);\n        Py_DECREF(item);\n        if (err < 0)\n            goto error;\n\n        cdata += itemsize;\n    }\n    item = iternext(it);\n    if (item != NULL) {\n        Py_DECREF(item);\n        PyErr_Format(PyExc_ValueError,\n                     \"got more than %zd values to unpack\", length);\n    }\n error:\n    Py_DECREF(it);\n    return PyErr_Occurred() ? -1 : 0;\n}\n\nstatic PyObject *\ncdataowning_subscript(CDataObject *cd, PyObject *key)\n{\n    char *c;\n    if (PySlice_Check(key))\n        return cdata_slice(cd, (PySliceObject *)key);\n\n    c = _cdata_get_indexed_ptr(cd, key);\n    /* use 'mp_subscript' instead of 'sq_item' because we don't want\n       negative indexes to be corrected automatically */\n    if (c == NULL && PyErr_Occurred())\n        return NULL;\n\n    if (cd->c_type->ct_flags & CT_IS_PTR_TO_OWNED) {\n        PyObject *res = ((CDataObject_own_structptr *)cd)->structobj;\n        Py_INCREF(res);\n        return res;\n    }\n    else {\n        return convert_to_object(c, cd->c_type->ct_itemdescr);\n    }\n}\n\nstatic PyObject *\ncdata_subscript(CDataObject *cd, PyObject *key)\n{\n    char *c;\n    if (PySlice_Check(key))\n        return cdata_slice(cd, (PySliceObject *)key);\n\n    c = _cdata_get_indexed_ptr(cd, key);\n    /* use 'mp_subscript' instead of 'sq_item' because we don't want\n       negative indexes to be corrected automatically */\n    if (c == NULL && PyErr_Occurred())\n        return NULL;\n    return convert_to_object(c, cd->c_type->ct_itemdescr);\n}\n\nstatic int\ncdata_ass_sub(CDataObject *cd, PyObject *key, PyObject *v)\n{\n    char *c;\n    CTypeDescrObject *ctitem;\n    if (PySlice_Check(key))\n        return cdata_ass_slice(cd, (PySliceObject *)key, v);\n\n    c = _cdata_get_indexed_ptr(cd, key);\n    ctitem = cd->c_type->ct_itemdescr;\n    /* use 'mp_ass_subscript' instead of 'sq_ass_item' because we don't want\n       negative indexes to be corrected automatically */\n    if (c == NULL && PyErr_Occurred())\n        return -1;\n    if (v == NULL) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"'del x[n]' not supported for cdata objects\");\n        return -1;\n    }\n    return convert_from_object(c, ctitem, v);\n}\n\nstatic PyObject *\n_cdata_add_or_sub(PyObject *v, PyObject *w, int sign)\n{\n    Py_ssize_t i, itemsize;\n    CDataObject *cd;\n    CTypeDescrObject *ctptr;\n\n    if (!CData_Check(v)) {\n        PyObject *swap;\n        assert(CData_Check(w));\n        if (sign != 1)\n            goto not_implemented;\n        swap = v;\n        v = w;\n        w = swap;\n    }\n\n    i = PyNumber_AsSsize_t(w, PyExc_OverflowError);\n    if (i == -1 && PyErr_Occurred())\n        return NULL;\n    i *= sign;\n\n    cd = (CDataObject *)v;\n    if (cd->c_type->ct_flags & CT_POINTER)\n        ctptr = cd->c_type;\n    else if (cd->c_type->ct_flags & CT_ARRAY) {\n        ctptr = (CTypeDescrObject *)cd->c_type->ct_stuff;\n    }\n    else {\n        PyErr_Format(PyExc_TypeError, \"cannot add a cdata '%s' and a number\",\n                     cd->c_type->ct_name);\n        return NULL;\n    }\n    itemsize = ctptr->ct_itemdescr->ct_size;\n    if (itemsize < 0) {\n        if (ctptr->ct_flags & CT_IS_VOID_PTR) {\n            itemsize = 1;\n        }\n        else {\n            PyErr_Format(PyExc_TypeError,\n                         \"ctype '%s' points to items of unknown size\",\n                         cd->c_type->ct_name);\n            return NULL;\n        }\n    }\n    return new_simple_cdata(cd->c_data + i * itemsize, ctptr);\n\n not_implemented:\n    Py_INCREF(Py_NotImplemented);\n    return Py_NotImplemented;\n}\n\nstatic PyObject *\ncdata_add(PyObject *v, PyObject *w)\n{\n    return _cdata_add_or_sub(v, w, +1);\n}\n\nstatic PyObject *\ncdata_sub(PyObject *v, PyObject *w)\n{\n    if (CData_Check(v) && CData_Check(w)) {\n        CDataObject *cdv = (CDataObject *)v;\n        CDataObject *cdw = (CDataObject *)w;\n        CTypeDescrObject *ct = cdw->c_type;\n        Py_ssize_t diff, itemsize;\n\n        if (ct->ct_flags & CT_ARRAY)     /* ptr_to_T - array_of_T: ok */\n            ct = (CTypeDescrObject *)ct->ct_stuff;\n\n        if (ct != cdv->c_type || !(ct->ct_flags & CT_POINTER) ||\n                (ct->ct_itemdescr->ct_size <= 0 &&\n                 !(ct->ct_flags & CT_IS_VOID_PTR))) {\n            PyErr_Format(PyExc_TypeError,\n                         \"cannot subtract cdata '%s' and cdata '%s'\",\n                         cdv->c_type->ct_name, ct->ct_name);\n            return NULL;\n        }\n        itemsize = ct->ct_itemdescr->ct_size;\n        if (itemsize <= 0) itemsize = 1;\n        diff = (cdv->c_data - cdw->c_data) / itemsize;\n#if PY_MAJOR_VERSION < 3\n        return PyInt_FromSsize_t(diff);\n#else\n        return PyLong_FromSsize_t(diff);\n#endif\n    }\n\n    return _cdata_add_or_sub(v, w, -1);\n}\n\nstatic PyObject *\ncdata_getattro(CDataObject *cd, PyObject *attr)\n{\n    CFieldObject *cf;\n    CTypeDescrObject *ct = cd->c_type;\n\n    if (ct->ct_flags & CT_POINTER)\n        ct = ct->ct_itemdescr;\n\n    if (ct->ct_flags & (CT_STRUCT|CT_UNION)) {\n        switch (force_lazy_struct(ct)) {\n        case 1:\n            cf = (CFieldObject *)PyDict_GetItem(ct->ct_stuff, attr);\n            if (cf != NULL) {\n                /* read the field 'cf' */\n                char *data = cd->c_data + cf->cf_offset;\n                if (cf->cf_bitshift == BS_REGULAR)\n                    return convert_to_object(data, cf->cf_type);\n                else if (cf->cf_bitshift == BS_EMPTY_ARRAY)\n                    return new_simple_cdata(data,\n                        (CTypeDescrObject *)cf->cf_type->ct_stuff);\n                else\n                    return convert_to_object_bitfield(data, cf);\n            }\n            break;\n        case -1:\n            return NULL;\n        default:\n            break;\n        }\n    }\n    return PyObject_GenericGetAttr((PyObject *)cd, attr);\n}\n\nstatic int\ncdata_setattro(CDataObject *cd, PyObject *attr, PyObject *value)\n{\n    CFieldObject *cf;\n    CTypeDescrObject *ct = cd->c_type;\n\n    if (ct->ct_flags & CT_POINTER)\n        ct = ct->ct_itemdescr;\n\n    if (ct->ct_flags & (CT_STRUCT|CT_UNION)) {\n        switch (force_lazy_struct(ct)) {\n        case 1:\n            cf = (CFieldObject *)PyDict_GetItem(ct->ct_stuff, attr);\n            if (cf != NULL) {\n                /* write the field 'cf' */\n                if (value != NULL) {\n                    return convert_field_from_object(cd->c_data, cf, value);\n                }\n                else {\n                    PyErr_SetString(PyExc_AttributeError,\n                                    \"cannot delete struct field\");\n                    return -1;\n                }\n            }\n            break;\n        case -1:\n            return -1;\n        default:\n            break;\n        }\n    }\n    return PyObject_GenericSetAttr((PyObject *)cd, attr, value);\n}\n\nstatic PyObject *\nconvert_struct_to_owning_object(char *data, CTypeDescrObject *ct); /*forward*/\n\nstatic cif_description_t *\nfb_prepare_cif(PyObject *fargs, CTypeDescrObject *, ffi_abi);      /*forward*/\n\nstatic PyObject *new_primitive_type(const char *name);             /*forward*/\n\nstatic CTypeDescrObject *_get_ct_int(void)\n{\n    static CTypeDescrObject *ct_int = NULL;\n    if (ct_int == NULL) {\n        ct_int = (CTypeDescrObject *)new_primitive_type(\"int\");\n    }\n    return ct_int;\n}\n\nstatic Py_ssize_t\n_prepare_pointer_call_argument(CTypeDescrObject *ctptr, PyObject *init,\n                               char **output_data)\n{\n    /* 'ctptr' is here a pointer type 'ITEM *'.  Accept as argument an\n       initializer for an array 'ITEM[]'.  This includes the case of\n       passing a Python byte string to a 'char *' argument.\n\n       This function returns -1 if an error occurred,\n       0 if conversion succeeded (into *output_data),\n       or N > 0 if conversion would require N bytes of storage.\n    */\n    Py_ssize_t length, datasize;\n    CTypeDescrObject *ctitem;\n\n    if (CData_Check(init))\n        goto convert_default;\n\n    ctitem = ctptr->ct_itemdescr;\n    /* XXX some code duplication, how to avoid it? */\n    if (PyBytes_Check(init)) {\n        /* from a string: just returning the string here is fine.\n           We assume that the C code won't modify the 'char *' data. */\n        if ((ctptr->ct_flags & CT_CAST_ANYTHING) ||\n            ((ctitem->ct_flags & (CT_PRIMITIVE_SIGNED|CT_PRIMITIVE_UNSIGNED))\n             && (ctitem->ct_size == sizeof(char)))) {\n#if defined(CFFI_MEM_DEBUG) || defined(CFFI_MEM_LEAK)\n            length = PyBytes_GET_SIZE(init) + 1;\n#else\n            *output_data = PyBytes_AS_STRING(init);\n            return 0;\n#endif\n        }\n        else\n            goto convert_default;\n    }\n    else if (PyList_Check(init) || PyTuple_Check(init)) {\n        length = PySequence_Fast_GET_SIZE(init);\n    }\n    else if (PyUnicode_Check(init)) {\n        /* from a unicode, we add the null terminator */\n        length = _my_PyUnicode_SizeAsWideChar(init) + 1;\n    }\n    else if ((ctitem->ct_flags & CT_IS_FILE) && PyFile_Check(init)) {\n        *output_data = (char *)PyFile_AsFile(init);\n        if (*output_data == NULL && PyErr_Occurred())\n            return -1;\n        return 0;\n    }\n    else {\n        /* refuse to receive just an integer (and interpret it\n           as the array size) */\n        goto convert_default;\n    }\n\n    if (ctitem->ct_size <= 0)\n        goto convert_default;\n    datasize = length * ctitem->ct_size;\n    if ((datasize / ctitem->ct_size) != length) {\n        PyErr_SetString(PyExc_OverflowError,\n                        \"array size would overflow a Py_ssize_t\");\n        return -1;\n    }\n    if (datasize <= 0)\n        datasize = 1;\n    return datasize;\n\n convert_default:\n    return convert_from_object((char *)output_data, ctptr, init);\n}\n\nstatic PyObject*\ncdata_call(CDataObject *cd, PyObject *args, PyObject *kwds)\n{\n    char *buffer;\n    void** buffer_array;\n    cif_description_t *cif_descr;\n    Py_ssize_t i, nargs, nargs_declared;\n    PyObject *signature, *res = NULL, *fvarargs;\n    CTypeDescrObject *fresult;\n    char *resultdata;\n    char *errormsg;\n\n    if (!(cd->c_type->ct_flags & CT_FUNCTIONPTR)) {\n        PyErr_Format(PyExc_TypeError, \"cdata '%s' is not callable\",\n                     cd->c_type->ct_name);\n        return NULL;\n    }\n    if (kwds != NULL && PyDict_Size(kwds) != 0) {\n        PyErr_SetString(PyExc_TypeError,\n                \"a cdata function cannot be called with keyword arguments\");\n        return NULL;\n    }\n    signature = cd->c_type->ct_stuff;\n    nargs = PyTuple_Size(args);\n    if (nargs < 0)\n        return NULL;\n    nargs_declared = PyTuple_GET_SIZE(signature) - 2;\n    fresult = (CTypeDescrObject *)PyTuple_GET_ITEM(signature, 1);\n    fvarargs = NULL;\n    buffer = NULL;\n\n    cif_descr = (cif_description_t *)cd->c_type->ct_extra;\n\n    if (cif_descr != NULL) {\n        /* regular case: this function does not take '...' arguments */\n        if (nargs != nargs_declared) {\n            errormsg = \"'%s' expects %zd arguments, got %zd\";\n          bad_number_of_arguments:\n            PyErr_Format(PyExc_TypeError, errormsg,\n                         cd->c_type->ct_name, nargs_declared, nargs);\n            goto error;\n        }\n    }\n    else {\n        /* call of a variadic function */\n        ffi_abi fabi;\n        if (nargs < nargs_declared) {\n            errormsg = \"'%s' expects at least %zd arguments, got %zd\";\n            goto bad_number_of_arguments;\n        }\n        fvarargs = PyTuple_New(nargs);\n        if (fvarargs == NULL)\n            goto error;\n        for (i = 0; i < nargs_declared; i++) {\n            PyObject *o = PyTuple_GET_ITEM(signature, 2 + i);\n            Py_INCREF(o);\n            PyTuple_SET_ITEM(fvarargs, i, o);\n        }\n        for (i = nargs_declared; i < nargs; i++) {\n            PyObject *obj = PyTuple_GET_ITEM(args, i);\n            CTypeDescrObject *ct;\n\n            if (CData_Check(obj)) {\n                ct = ((CDataObject *)obj)->c_type;\n                if (ct->ct_flags & (CT_PRIMITIVE_CHAR | CT_PRIMITIVE_UNSIGNED |\n                                    CT_PRIMITIVE_SIGNED)) {\n                    if (ct->ct_size < (Py_ssize_t)sizeof(int)) {\n                        ct = _get_ct_int();\n                        if (ct == NULL)\n                            goto error;\n                    }\n                }\n                else if (ct->ct_flags & CT_ARRAY) {\n                    ct = (CTypeDescrObject *)ct->ct_stuff;\n                }\n                Py_INCREF(ct);\n            }\n            else {\n                PyErr_Format(PyExc_TypeError,\n                             \"argument %zd passed in the variadic part \"\n                             \"needs to be a cdata object (got %.200s)\",\n                             i + 1, Py_TYPE(obj)->tp_name);\n                goto error;\n            }\n            PyTuple_SET_ITEM(fvarargs, i, (PyObject *)ct);\n        }\n#if PY_MAJOR_VERSION < 3\n        fabi = PyInt_AS_LONG(PyTuple_GET_ITEM(signature, 0));\n#else\n        fabi = PyLong_AS_LONG(PyTuple_GET_ITEM(signature, 0));\n#endif\n        cif_descr = fb_prepare_cif(fvarargs, fresult, fabi);\n        if (cif_descr == NULL)\n            goto error;\n    }\n\n    buffer = PyObject_Malloc(cif_descr->exchange_size);\n    if (buffer == NULL) {\n        PyErr_NoMemory();\n        goto error;\n    }\n\n    buffer_array = (void **)buffer;\n\n    for (i=0; i<nargs; i++) {\n        CTypeDescrObject *argtype;\n        char *data = buffer + cif_descr->exchange_offset_arg[1 + i];\n        PyObject *obj = PyTuple_GET_ITEM(args, i);\n\n        buffer_array[i] = data;\n\n        if (i < nargs_declared)\n            argtype = (CTypeDescrObject *)PyTuple_GET_ITEM(signature, 2 + i);\n        else\n            argtype = (CTypeDescrObject *)PyTuple_GET_ITEM(fvarargs, i);\n\n        if (argtype->ct_flags & CT_POINTER) {\n            char *tmpbuf;\n            Py_ssize_t datasize = _prepare_pointer_call_argument(\n                                            argtype, obj, (char **)data);\n            if (datasize == 0)\n                ;    /* successfully filled '*data' */\n            else if (datasize < 0)\n                goto error;\n            else {\n                tmpbuf = alloca(datasize);\n                memset(tmpbuf, 0, datasize);\n                *(char **)data = tmpbuf;\n                if (convert_array_from_object(tmpbuf, argtype, obj) < 0)\n                    goto error;\n            }\n        }\n        else if (convert_from_object(data, argtype, obj) < 0)\n            goto error;\n    }\n\n    resultdata = buffer + cif_descr->exchange_offset_arg[0];\n    /*READ(cd->c_data, sizeof(void(*)(void)))*/\n\n    Py_BEGIN_ALLOW_THREADS\n    restore_errno();\n    ffi_call(&cif_descr->cif, (void (*)(void))(cd->c_data),\n             resultdata, buffer_array);\n    save_errno();\n    Py_END_ALLOW_THREADS\n\n    if (fresult->ct_flags & (CT_PRIMITIVE_CHAR | CT_PRIMITIVE_SIGNED |\n                             CT_PRIMITIVE_UNSIGNED)) {\n#ifdef WORDS_BIGENDIAN\n        /* For results of precisely these types, libffi has a strange\n           rule that they will be returned as a whole 'ffi_arg' if they\n           are smaller.  The difference only matters on big-endian. */\n        if (fresult->ct_size < sizeof(ffi_arg))\n            resultdata += (sizeof(ffi_arg) - fresult->ct_size);\n#endif\n        res = convert_to_object(resultdata, fresult);\n    }\n    else if (fresult->ct_flags & CT_VOID) {\n        res = Py_None;\n        Py_INCREF(res);\n    }\n    else if (fresult->ct_flags & CT_STRUCT) {\n        res = convert_struct_to_owning_object(resultdata, fresult);\n    }\n    else {\n        res = convert_to_object(resultdata, fresult);\n    }\n    /* fall-through */\n\n error:\n    if (buffer)\n        PyObject_Free(buffer);\n    if (fvarargs != NULL) {\n        Py_DECREF(fvarargs);\n        if (cif_descr != NULL)  /* but only if fvarargs != NULL, if variadic */\n            PyObject_Free(cif_descr);\n    }\n    return res;\n}\n\nstatic PyObject *cdata_iter(CDataObject *);\n\nstatic PyNumberMethods CData_as_number = {\n    (binaryfunc)cdata_add,      /*nb_add*/\n    (binaryfunc)cdata_sub,      /*nb_subtract*/\n    0,                          /*nb_multiply*/\n#if PY_MAJOR_VERSION < 3\n    0,                          /*nb_divide*/\n#endif\n    0,                          /*nb_remainder*/\n    0,                          /*nb_divmod*/\n    0,                          /*nb_power*/\n    0,                          /*nb_negative*/\n    0,                          /*nb_positive*/\n    0,                          /*nb_absolute*/\n    (inquiry)cdata_nonzero,     /*nb_nonzero*/\n    0,                          /*nb_invert*/\n    0,                          /*nb_lshift*/\n    0,                          /*nb_rshift*/\n    0,                          /*nb_and*/\n    0,                          /*nb_xor*/\n    0,                          /*nb_or*/\n#if PY_MAJOR_VERSION < 3\n    0,                          /*nb_coerce*/\n#endif\n    (unaryfunc)cdata_int,       /*nb_int*/\n#if PY_MAJOR_VERSION < 3\n    (unaryfunc)cdata_long,      /*nb_long*/\n#else\n    0,\n#endif\n    (unaryfunc)cdata_float,     /*nb_float*/\n    0,                          /*nb_oct*/\n    0,                          /*nb_hex*/\n};\n\nstatic PyMappingMethods CData_as_mapping = {\n    (lenfunc)cdata_length, /*mp_length*/\n    (binaryfunc)cdata_subscript, /*mp_subscript*/\n    (objobjargproc)cdata_ass_sub, /*mp_ass_subscript*/\n};\n\nstatic PyMappingMethods CDataOwn_as_mapping = {\n    (lenfunc)cdata_length, /*mp_length*/\n    (binaryfunc)cdataowning_subscript, /*mp_subscript*/\n    (objobjargproc)cdata_ass_sub, /*mp_ass_subscript*/\n};\n\nstatic PyTypeObject CData_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_cffi_backend.CData\",\n    sizeof(CDataObject),\n    0,\n    (destructor)cdata_dealloc,                  /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_compare */\n    (reprfunc)cdata_repr,                       /* tp_repr */\n    &CData_as_number,                           /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    &CData_as_mapping,                          /* tp_as_mapping */\n    (hashfunc)cdata_hash,                       /* tp_hash */\n    (ternaryfunc)cdata_call,                    /* tp_call */\n    0,                                          /* tp_str */\n    (getattrofunc)cdata_getattro,               /* tp_getattro */\n    (setattrofunc)cdata_setattro,               /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_CHECKTYPES, /* tp_flags */\n    0,                                          /* tp_doc */\n    0,                                          /* tp_traverse */\n    0,                                          /* tp_clear */\n    cdata_richcompare,                          /* tp_richcompare */\n    offsetof(CDataObject, c_weakreflist),       /* tp_weaklistoffset */\n    (getiterfunc)cdata_iter,                    /* tp_iter */\n    0,                                          /* tp_iternext */\n};\n\nstatic PyTypeObject CDataOwning_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_cffi_backend.CDataOwn\",\n    sizeof(CDataObject),\n    0,\n    (destructor)cdataowning_dealloc,            /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_compare */\n    (reprfunc)cdataowning_repr,                 /* tp_repr */\n    0,                                          /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    &CDataOwn_as_mapping,                       /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    0,                                          /* tp_getattro */\n    0,                                          /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_CHECKTYPES, /* tp_flags */\n    0,                                          /* tp_doc */\n    0,                                          /* tp_traverse */\n    0,                                          /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    0,                                          /* tp_methods */\n    0,                                          /* tp_members */\n    0,                                          /* tp_getset */\n    &CData_Type,                                /* tp_base */\n};\n\nstatic PyTypeObject CDataOwningGC_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_cffi_backend.CDataOwnGC\",\n    sizeof(CDataObject_owngc_frombuf),\n    0,\n    (destructor)cdataowninggc_dealloc,          /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_compare */\n    (reprfunc)cdataowninggc_repr,               /* tp_repr */\n    0,                                          /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    0,                                          /* tp_getattro */\n    0,                                          /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_CHECKTYPES  /* tp_flags */\n                       | Py_TPFLAGS_HAVE_GC,\n    0,                                          /* tp_doc */\n    (traverseproc)cdataowninggc_traverse,       /* tp_traverse */\n    (inquiry)cdataowninggc_clear,               /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    0,                                          /* tp_methods */\n    0,                                          /* tp_members */\n    0,                                          /* tp_getset */\n    &CDataOwning_Type,                          /* tp_base */\n};\n\n/************************************************************/\n\ntypedef struct {\n    PyObject_HEAD\n    char *di_next, *di_stop;\n    CDataObject *di_object;\n    CTypeDescrObject *di_itemtype;\n} CDataIterObject;\n\nstatic PyObject *\ncdataiter_next(CDataIterObject *it)\n{\n    char *result = it->di_next;\n    if (result != it->di_stop) {\n        it->di_next = result + it->di_itemtype->ct_size;\n        return convert_to_object(result, it->di_itemtype);\n    }\n    return NULL;\n}\n\nstatic void\ncdataiter_dealloc(CDataIterObject *it)\n{\n    Py_DECREF(it->di_object);\n    PyObject_Del(it);\n}\n\nstatic PyTypeObject CDataIter_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_cffi_backend.CDataIter\",              /* tp_name */\n    sizeof(CDataIterObject),                /* tp_basicsize */\n    0,                                      /* tp_itemsize */\n    /* methods */\n    (destructor)cdataiter_dealloc,          /* tp_dealloc */\n    0,                                      /* tp_print */\n    0,                                      /* tp_getattr */\n    0,                                      /* tp_setattr */\n    0,                                      /* tp_compare */\n    0,                                      /* tp_repr */\n    0,                                      /* tp_as_number */\n    0,                                      /* tp_as_sequence */\n    0,                                      /* tp_as_mapping */\n    0,                                      /* tp_hash */\n    0,                                      /* tp_call */\n    0,                                      /* tp_str */\n    PyObject_GenericGetAttr,                /* tp_getattro */\n    0,                                      /* tp_setattro */\n    0,                                      /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT,                     /* tp_flags */\n    0,                                      /* tp_doc */\n    0,                                      /* tp_traverse */\n    0,                                      /* tp_clear */\n    0,                                      /* tp_richcompare */\n    0,                                      /* tp_weaklistoffset */\n    PyObject_SelfIter,                      /* tp_iter */\n    (iternextfunc)cdataiter_next,           /* tp_iternext */\n};\n\nstatic PyObject *\ncdata_iter(CDataObject *cd)\n{\n    CDataIterObject *it;\n\n    if (!(cd->c_type->ct_flags & CT_ARRAY)) {\n        PyErr_Format(PyExc_TypeError, \"cdata '%s' does not support iteration\",\n                     cd->c_type->ct_name);\n        return NULL;\n    }\n\n    it = PyObject_New(CDataIterObject, &CDataIter_Type);\n    if (it == NULL)\n        return NULL;\n\n    Py_INCREF(cd);\n    it->di_object = cd;\n    it->di_itemtype = cd->c_type->ct_itemdescr;\n    it->di_next = cd->c_data;\n    it->di_stop = cd->c_data + get_array_length(cd) * it->di_itemtype->ct_size;\n    return (PyObject *)it;\n}\n\n/************************************************************/\n\nstatic CDataObject *allocate_owning_object(Py_ssize_t size,\n                                           CTypeDescrObject *ct)\n{\n    CDataObject *cd;\n    cd = (CDataObject *)PyObject_Malloc(size);\n    if (PyObject_Init((PyObject *)cd, &CDataOwning_Type) == NULL)\n        return NULL;\n\n    Py_INCREF(ct);\n    cd->c_type = ct;\n    cd->c_weakreflist = NULL;\n    return cd;\n}\n\nstatic PyObject *\nconvert_struct_to_owning_object(char *data, CTypeDescrObject *ct)\n{\n    CDataObject *cd;\n    Py_ssize_t dataoffset = offsetof(CDataObject_own_nolength, alignment);\n    Py_ssize_t datasize = ct->ct_size;\n\n    if ((ct->ct_flags & (CT_STRUCT|CT_IS_OPAQUE)) != CT_STRUCT) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"return type is not a struct or is opaque\");\n        return NULL;\n    }\n    cd = allocate_owning_object(dataoffset + datasize, ct);\n    if (cd == NULL)\n        return NULL;\n    cd->c_data = ((char *)cd) + dataoffset;\n\n    memcpy(cd->c_data, data, datasize);\n    return (PyObject *)cd;\n}\n\nstatic PyObject *direct_newp(CTypeDescrObject *ct, PyObject *init)\n{\n    CTypeDescrObject *ctitem;\n    CDataObject *cd;\n    Py_ssize_t dataoffset, datasize, explicitlength;\n\n    explicitlength = -1;\n    if (ct->ct_flags & CT_POINTER) {\n        dataoffset = offsetof(CDataObject_own_nolength, alignment);\n        ctitem = ct->ct_itemdescr;\n        datasize = ctitem->ct_size;\n        if (datasize < 0) {\n            PyErr_Format(PyExc_TypeError,\n                         \"cannot instantiate ctype '%s' of unknown size\",\n                         ctitem->ct_name);\n            return NULL;\n        }\n        if (ctitem->ct_flags & CT_PRIMITIVE_CHAR)\n            datasize *= 2;   /* forcefully add another character: a null */\n\n        if ((ctitem->ct_flags & (CT_STRUCT | CT_UNION)) && init != Py_None) {\n            if (force_lazy_struct(ctitem) < 0)   /* for CT_WITH_VAR_ARRAY */\n                return NULL;\n            if (ctitem->ct_flags & CT_WITH_VAR_ARRAY) {\n                Py_ssize_t optvarsize = datasize;\n                if (convert_struct_from_object(NULL,ctitem, init,\n                                               &optvarsize) < 0)\n                    return NULL;\n                datasize = optvarsize;\n            }\n        }\n    }\n    else if (ct->ct_flags & CT_ARRAY) {\n        dataoffset = offsetof(CDataObject_own_nolength, alignment);\n        datasize = ct->ct_size;\n        if (datasize < 0) {\n            explicitlength = get_new_array_length(&init);\n            if (explicitlength < 0)\n                return NULL;\n            ctitem = ct->ct_itemdescr;\n            dataoffset = offsetof(CDataObject_own_length, alignment);\n            datasize = explicitlength * ctitem->ct_size;\n            if (explicitlength > 0 &&\n                    (datasize / explicitlength) != ctitem->ct_size) {\n                PyErr_SetString(PyExc_OverflowError,\n                                \"array size would overflow a Py_ssize_t\");\n                return NULL;\n            }\n        }\n    }\n    else {\n        PyErr_Format(PyExc_TypeError,\n                     \"expected a pointer or array ctype, got '%s'\",\n                     ct->ct_name);\n        return NULL;\n    }\n\n    if (ct->ct_flags & CT_IS_PTR_TO_OWNED) {\n        /* common case of ptr-to-struct (or ptr-to-union): for this case\n           we build two objects instead of one, with the memory-owning\n           one being really the struct (or union) and the returned one\n           having a strong reference to it */\n        CDataObject *cds;\n\n        cds = allocate_owning_object(dataoffset + datasize, ct->ct_itemdescr);\n        if (cds == NULL)\n            return NULL;\n\n        cd = allocate_owning_object(sizeof(CDataObject_own_structptr), ct);\n        if (cd == NULL) {\n            Py_DECREF(cds);\n            return NULL;\n        }\n        /* store the only reference to cds into cd */\n        ((CDataObject_own_structptr *)cd)->structobj = (PyObject *)cds;\n        assert(explicitlength < 0);\n\n        cds->c_data = cd->c_data = ((char *)cds) + dataoffset;\n    }\n    else {\n        cd = allocate_owning_object(dataoffset + datasize, ct);\n        if (cd == NULL)\n            return NULL;\n\n        cd->c_data = ((char *)cd) + dataoffset;\n        if (explicitlength >= 0)\n            ((CDataObject_own_length*)cd)->length = explicitlength;\n    }\n\n    memset(cd->c_data, 0, datasize);\n    if (init != Py_None) {\n        if (convert_from_object(cd->c_data,\n              (ct->ct_flags & CT_POINTER) ? ct->ct_itemdescr : ct, init) < 0) {\n            Py_DECREF(cd);\n            return NULL;\n        }\n    }\n    return (PyObject *)cd;\n}\n\nstatic PyObject *b_newp(PyObject *self, PyObject *args)\n{\n    CTypeDescrObject *ct;\n    PyObject *init = Py_None;\n    if (!PyArg_ParseTuple(args, \"O!|O:newp\", &CTypeDescr_Type, &ct, &init))\n        return NULL;\n    return direct_newp(ct, init);\n}\n\nstatic int\n_my_PyObject_AsBool(PyObject *ob)\n{\n    /* convert and cast a Python object to a boolean.  Accept an integer\n       or a float object, up to a CData 'long double'. */\n    PyObject *io;\n    PyNumberMethods *nb;\n    int res;\n\n#if PY_MAJOR_VERSION < 3\n    if (PyInt_Check(ob)) {\n        return PyInt_AS_LONG(ob) != 0;\n    }\n    else\n#endif\n    if (PyLong_Check(ob)) {\n        return _PyLong_Sign(ob) != 0;\n    }\n    else if (PyFloat_Check(ob)) {\n        return PyFloat_AS_DOUBLE(ob) != 0.0;\n    }\n    else if (CData_Check(ob)) {\n        CDataObject *cd = (CDataObject *)ob;\n        if (cd->c_type->ct_flags & CT_PRIMITIVE_FLOAT) {\n            /*READ(cd->c_data, cd->c_type->ct_size)*/\n            if (cd->c_type->ct_flags & CT_IS_LONGDOUBLE) {\n                /* 'long double' objects: return the answer directly */\n                return read_raw_longdouble_data(cd->c_data) != 0.0;\n            }\n            else {\n                /* 'float'/'double' objects: return the answer directly */\n                return read_raw_float_data(cd->c_data,\n                                           cd->c_type->ct_size) != 0.0;\n            }\n        }\n    }\n    nb = ob->ob_type->tp_as_number;\n    if (nb == NULL || (nb->nb_float == NULL && nb->nb_int == NULL)) {\n        PyErr_SetString(PyExc_TypeError, \"integer/float expected\");\n        return -1;\n    }\n    if (nb->nb_float && !CData_Check(ob))\n        io = (*nb->nb_float) (ob);\n    else\n        io = (*nb->nb_int) (ob);\n    if (io == NULL)\n        return -1;\n\n    if (PyIntOrLong_Check(io) || PyFloat_Check(io)) {\n        res = _my_PyObject_AsBool(io);\n    }\n    else {\n        PyErr_SetString(PyExc_TypeError, \"integer/float conversion failed\");\n        res = -1;\n    }\n    Py_DECREF(io);\n    return res;\n}\n\nstatic CDataObject *_new_casted_primitive(CTypeDescrObject *ct)\n{\n    int dataoffset = offsetof(CDataObject_casted_primitive, alignment);\n    CDataObject *cd = (CDataObject *)PyObject_Malloc(dataoffset + ct->ct_size);\n    if (PyObject_Init((PyObject *)cd, &CData_Type) == NULL)\n        return NULL;\n    Py_INCREF(ct);\n    cd->c_type = ct;\n    cd->c_data = ((char*)cd) + dataoffset;\n    cd->c_weakreflist = NULL;\n    return cd;\n}\n\nstatic CDataObject *cast_to_integer_or_char(CTypeDescrObject *ct, PyObject *ob)\n{\n    unsigned PY_LONG_LONG value;\n    CDataObject *cd;\n\n    if (CData_Check(ob) &&\n        ((CDataObject *)ob)->c_type->ct_flags &\n                                 (CT_POINTER|CT_FUNCTIONPTR|CT_ARRAY)) {\n        value = (Py_intptr_t)((CDataObject *)ob)->c_data;\n    }\n#if PY_MAJOR_VERSION < 3\n    else if (PyString_Check(ob)) {\n        if (PyString_GET_SIZE(ob) != 1) {\n            PyErr_Format(PyExc_TypeError,\n                         \"cannot cast string of length %zd to ctype '%s'\",\n                         PyString_GET_SIZE(ob), ct->ct_name);\n            return NULL;\n        }\n        value = (unsigned char)PyString_AS_STRING(ob)[0];\n    }\n#endif\n#ifdef HAVE_WCHAR_H\n    else if (PyUnicode_Check(ob)) {\n        wchar_t ordinal;\n        if (_my_PyUnicode_AsSingleWideChar(ob, &ordinal) < 0) {\n            PyErr_Format(PyExc_TypeError,\n                      \"cannot cast unicode string of length %zd to ctype '%s'\",\n                         PyUnicode_GET_SIZE(ob), ct->ct_name);\n            return NULL;\n        }\n        value = (long)ordinal;\n    }\n#endif\n    else if (PyBytes_Check(ob)) {\n        int res = _convert_to_char(ob);\n        if (res < 0)\n            return NULL;\n        value = (unsigned char)res;\n    }\n    else if (ct->ct_flags & CT_IS_BOOL) {\n        int res = _my_PyObject_AsBool(ob);\n        if (res < 0)\n            return NULL;\n        value = res;\n    }\n    else {\n        value = _my_PyLong_AsUnsignedLongLong(ob, 0);\n        if (value == (unsigned PY_LONG_LONG)-1 && PyErr_Occurred())\n            return NULL;\n    }\n    if (ct->ct_flags & CT_IS_BOOL)\n        value = !!value;\n    cd = _new_casted_primitive(ct);\n    if (cd != NULL)\n        write_raw_integer_data(cd->c_data, value, ct->ct_size);\n    return cd;\n}\n\nstatic PyObject *do_cast(CTypeDescrObject *ct, PyObject *ob)\n{\n    CDataObject *cd;\n\n    if (ct->ct_flags & (CT_POINTER|CT_FUNCTIONPTR|CT_ARRAY) &&\n        ct->ct_size >= 0) {\n        /* cast to a pointer, to a funcptr, or to an array.\n           Note that casting to an array is an extension to the C language,\n           which seems to be necessary in order to sanely get a\n           <cdata 'int[3]'> at some address. */\n        unsigned PY_LONG_LONG value;\n\n        if (CData_Check(ob)) {\n            CDataObject *cdsrc = (CDataObject *)ob;\n            if (cdsrc->c_type->ct_flags &\n                    (CT_POINTER|CT_FUNCTIONPTR|CT_ARRAY)) {\n                return new_simple_cdata(cdsrc->c_data, ct);\n            }\n        }\n        if ((ct->ct_flags & CT_POINTER) &&\n                (ct->ct_itemdescr->ct_flags & CT_IS_FILE) &&\n                PyFile_Check(ob)) {\n            FILE *f = PyFile_AsFile(ob);\n            if (f == NULL && PyErr_Occurred())\n                return NULL;\n            return new_simple_cdata((char *)f, ct);\n        }\n        value = _my_PyLong_AsUnsignedLongLong(ob, 0);\n        if (value == (unsigned PY_LONG_LONG)-1 && PyErr_Occurred())\n            return NULL;\n        return new_simple_cdata((char *)(Py_intptr_t)value, ct);\n    }\n    else if (ct->ct_flags & (CT_PRIMITIVE_SIGNED|CT_PRIMITIVE_UNSIGNED\n                             |CT_PRIMITIVE_CHAR)) {\n        /* cast to an integer type or a char */\n        return (PyObject *)cast_to_integer_or_char(ct, ob);\n    }\n    else if (ct->ct_flags & CT_PRIMITIVE_FLOAT) {\n        /* cast to a float */\n        double value;\n        PyObject *io;\n\n        if (CData_Check(ob)) {\n            CDataObject *cdsrc = (CDataObject *)ob;\n\n            if (!(cdsrc->c_type->ct_flags & CT_PRIMITIVE_ANY))\n                goto cannot_cast;\n            io = convert_to_object(cdsrc->c_data, cdsrc->c_type);\n            if (io == NULL)\n                return NULL;\n        }\n        else {\n            io = ob;\n            Py_INCREF(io);\n        }\n\n        if (PyBytes_Check(io)) {\n            if (PyBytes_GET_SIZE(io) != 1) {\n                Py_DECREF(io);\n                goto cannot_cast;\n            }\n            value = (unsigned char)PyBytes_AS_STRING(io)[0];\n        }\n#if HAVE_WCHAR_H\n        else if (PyUnicode_Check(io)) {\n            wchar_t ordinal;\n            if (_my_PyUnicode_AsSingleWideChar(io, &ordinal) < 0) {\n                Py_DECREF(io);\n                goto cannot_cast;\n            }\n            value = (long)ordinal;\n        }\n#endif\n        else if ((ct->ct_flags & CT_IS_LONGDOUBLE) &&\n                 CData_Check(io) &&\n                 (((CDataObject *)io)->c_type->ct_flags & CT_IS_LONGDOUBLE)) {\n            long double lvalue;\n            char *data = ((CDataObject *)io)->c_data;\n            /*READ(data, sizeof(long double)*/\n            lvalue = read_raw_longdouble_data(data);\n            Py_DECREF(io);\n            cd = _new_casted_primitive(ct);\n            if (cd != NULL)\n                write_raw_longdouble_data(cd->c_data, lvalue);\n            return (PyObject *)cd;\n        }\n        else {\n            value = PyFloat_AsDouble(io);\n        }\n        Py_DECREF(io);\n        if (value == -1.0 && PyErr_Occurred())\n            return NULL;\n\n        cd = _new_casted_primitive(ct);\n        if (cd != NULL) {\n            if (!(ct->ct_flags & CT_IS_LONGDOUBLE))\n                write_raw_float_data(cd->c_data, value, ct->ct_size);\n            else\n                write_raw_longdouble_data(cd->c_data, (long double)value);\n        }\n        return (PyObject *)cd;\n    }\n    else {\n        PyErr_Format(PyExc_TypeError, \"cannot cast to ctype '%s'\",\n                     ct->ct_name);\n        return NULL;\n    }\n\n cannot_cast:\n    if (CData_Check(ob))\n        PyErr_Format(PyExc_TypeError, \"cannot cast ctype '%s' to ctype '%s'\",\n                     ((CDataObject *)ob)->c_type->ct_name, ct->ct_name);\n    else\n        PyErr_Format(PyExc_TypeError,\n                     \"cannot cast %.200s object to ctype '%s'\",\n                     Py_TYPE(ob)->tp_name, ct->ct_name);\n    return NULL;\n}\n\nstatic PyObject *b_cast(PyObject *self, PyObject *args)\n{\n    CTypeDescrObject *ct;\n    PyObject *ob;\n    if (!PyArg_ParseTuple(args, \"O!O:cast\", &CTypeDescr_Type, &ct, &ob))\n        return NULL;\n\n    return do_cast(ct, ob);\n}\n\n/************************************************************/\n\ntypedef struct {\n    PyObject_HEAD\n    void *dl_handle;\n    char *dl_name;\n} DynLibObject;\n\nstatic void dl_dealloc(DynLibObject *dlobj)\n{\n    dlclose(dlobj->dl_handle);\n    free(dlobj->dl_name);\n    PyObject_Del(dlobj);\n}\n\nstatic PyObject *dl_repr(DynLibObject *dlobj)\n{\n    return PyText_FromFormat(\"<clibrary '%s'>\", dlobj->dl_name);\n}\n\nstatic PyObject *dl_load_function(DynLibObject *dlobj, PyObject *args)\n{\n    CTypeDescrObject *ct;\n    char *funcname;\n    void *funcptr;\n    int ok;\n\n    if (!PyArg_ParseTuple(args, \"O!s:load_function\",\n                          &CTypeDescr_Type, &ct, &funcname))\n        return NULL;\n\n    ok = 0;\n    if (ct->ct_flags & CT_FUNCTIONPTR)\n        ok = 1;\n    if ((ct->ct_flags & CT_POINTER) && (ct->ct_itemdescr->ct_flags & CT_VOID))\n        ok = 1;\n    if (!ok) {\n        PyErr_Format(PyExc_TypeError, \"function cdata expected, got '%s'\",\n                     ct->ct_name);\n        return NULL;\n    }\n    dlerror();   /* clear error condition */\n    funcptr = dlsym(dlobj->dl_handle, funcname);\n    if (funcptr == NULL) {\n        const char *error = dlerror();\n        PyErr_Format(PyExc_KeyError,\n                     \"function '%s' not found in library '%s': %s\",\n                     funcname, dlobj->dl_name, error);\n        return NULL;\n    }\n\n    return new_simple_cdata(funcptr, ct);\n}\n\nstatic PyObject *dl_read_variable(DynLibObject *dlobj, PyObject *args)\n{\n    CTypeDescrObject *ct;\n    char *varname;\n    char *data;\n\n    if (!PyArg_ParseTuple(args, \"O!s:read_variable\",\n                          &CTypeDescr_Type, &ct, &varname))\n        return NULL;\n\n    dlerror();   /* clear error condition */\n    data = dlsym(dlobj->dl_handle, varname);\n    if (data == NULL) {\n        const char *error = dlerror();\n        if (error != NULL) {\n            PyErr_Format(PyExc_KeyError,\n                         \"variable '%s' not found in library '%s': %s\",\n                         varname, dlobj->dl_name, error);\n            return NULL;\n        }\n    }\n    return convert_to_object(data, ct);\n}\n\nstatic PyObject *dl_write_variable(DynLibObject *dlobj, PyObject *args)\n{\n    CTypeDescrObject *ct;\n    PyObject *value;\n    char *varname;\n    char *data;\n\n    if (!PyArg_ParseTuple(args, \"O!sO:write_variable\",\n                          &CTypeDescr_Type, &ct, &varname, &value))\n        return NULL;\n\n    dlerror();   /* clear error condition */\n    data = dlsym(dlobj->dl_handle, varname);\n    if (data == NULL) {\n        const char *error = dlerror();\n        PyErr_Format(PyExc_KeyError,\n                     \"variable '%s' not found in library '%s': %s\",\n                     varname, dlobj->dl_name, error);\n        return NULL;\n    }\n    if (convert_from_object(data, ct, value) < 0)\n        return NULL;\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nstatic PyMethodDef dl_methods[] = {\n    {\"load_function\",   (PyCFunction)dl_load_function,  METH_VARARGS},\n    {\"read_variable\",   (PyCFunction)dl_read_variable,  METH_VARARGS},\n    {\"write_variable\",  (PyCFunction)dl_write_variable, METH_VARARGS},\n    {NULL,              NULL}           /* sentinel */\n};\n\nstatic PyTypeObject dl_type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_cffi_backend.Library\",            /* tp_name */\n    sizeof(DynLibObject),               /* tp_basicsize */\n    0,                                  /* tp_itemsize */\n    /* methods */\n    (destructor)dl_dealloc,             /* tp_dealloc */\n    0,                                  /* tp_print */\n    0,                                  /* tp_getattr */\n    0,                                  /* tp_setattr */\n    0,                                  /* tp_compare */\n    (reprfunc)dl_repr,                  /* tp_repr */\n    0,                                  /* tp_as_number */\n    0,                                  /* tp_as_sequence */\n    0,                                  /* tp_as_mapping */\n    0,                                  /* tp_hash */\n    0,                                  /* tp_call */\n    0,                                  /* tp_str */\n    PyObject_GenericGetAttr,            /* tp_getattro */\n    0,                                  /* tp_setattro */\n    0,                                  /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT,                 /* tp_flags */\n    0,                                  /* tp_doc */\n    0,                                  /* tp_traverse */\n    0,                                  /* tp_clear */\n    0,                                  /* tp_richcompare */\n    0,                                  /* tp_weaklistoffset */\n    0,                                  /* tp_iter */\n    0,                                  /* tp_iternext */\n    dl_methods,                         /* tp_methods */\n};\n\nstatic PyObject *b_load_library(PyObject *self, PyObject *args)\n{\n    char *filename_or_null, *printable_filename;\n    void *handle;\n    DynLibObject *dlobj;\n    int flags = 0;\n\n    if (PyTuple_GET_SIZE(args) == 0 || PyTuple_GET_ITEM(args, 0) == Py_None) {\n        PyObject *dummy;\n        if (!PyArg_ParseTuple(args, \"|Oi:load_library\",\n                              &dummy, &flags))\n            return NULL;\n        filename_or_null = NULL;\n    }\n    else if (!PyArg_ParseTuple(args, \"et|i:load_library\",\n                          Py_FileSystemDefaultEncoding, &filename_or_null,\n                          &flags))\n        return NULL;\n\n    if ((flags & (RTLD_NOW | RTLD_LAZY)) == 0)\n        flags |= RTLD_NOW;\n\n    printable_filename = filename_or_null ? filename_or_null : \"<None>\";\n    handle = dlopen(filename_or_null, flags);\n    if (handle == NULL) {\n        const char *error = dlerror();\n        PyErr_Format(PyExc_OSError, \"cannot load library %s: %s\",\n                     printable_filename, error);\n        return NULL;\n    }\n\n    dlobj = PyObject_New(DynLibObject, &dl_type);\n    if (dlobj == NULL) {\n        dlclose(handle);\n        return NULL;\n    }\n    dlobj->dl_handle = handle;\n    dlobj->dl_name = strdup(printable_filename);\n    return (PyObject *)dlobj;\n}\n\n/************************************************************/\n\nstatic PyObject *unique_cache;\n\nstatic PyObject *get_unique_type(CTypeDescrObject *x,\n                                 const void *unique_key[], long keylength)\n{\n    /* Replace the CTypeDescrObject 'x' with a standardized one.\n       This either just returns x, or x is decrefed and a new reference\n       to the already-existing equivalent is returned.\n\n       In this function, 'x' always contains a reference that must be\n       either decrefed or returned.\n\n       Keys:\n           void       [\"void\"]\n           primitive  [&static_struct]\n           pointer    [ctype]\n           array      [ctype, length]\n           funcptr    [ctresult, ellipsis+abi, num_args, ctargs...]\n    */\n    long i;\n    PyObject *key, *y;\n    const void **pkey;\n    int err;\n\n    key = PyBytes_FromStringAndSize(NULL, keylength * sizeof(void *));\n    if (key == NULL)\n        goto error;\n\n    pkey = (const void **)PyBytes_AS_STRING(key);\n    for (i = 0; i < keylength; i++)\n        pkey[i] = unique_key[i];\n\n    y = PyDict_GetItem(unique_cache, key);\n    if (y != NULL) {\n        Py_DECREF(key);\n        Py_INCREF(y);\n        Py_DECREF(x);\n        return y;\n    }\n    err = PyDict_SetItem(unique_cache, key, (PyObject *)x);\n    Py_DECREF(key);\n    if (err < 0)\n        goto error;\n\n    return (PyObject *)x;\n\n error:\n    Py_DECREF(x);\n    return NULL;\n}\n\nstatic PyObject *new_primitive_type(const char *name)\n{\n#define ENUM_PRIMITIVE_TYPES                                    \\\n       EPTYPE(c, char, CT_PRIMITIVE_CHAR)                       \\\n       EPTYPE(s, short, CT_PRIMITIVE_SIGNED )                   \\\n       EPTYPE(i, int, CT_PRIMITIVE_SIGNED )                     \\\n       EPTYPE(l, long, CT_PRIMITIVE_SIGNED )                    \\\n       EPTYPE(ll, long long, CT_PRIMITIVE_SIGNED )              \\\n       EPTYPE(sc, signed char, CT_PRIMITIVE_SIGNED )            \\\n       EPTYPE(uc, unsigned char, CT_PRIMITIVE_UNSIGNED )        \\\n       EPTYPE(us, unsigned short, CT_PRIMITIVE_UNSIGNED )       \\\n       EPTYPE(ui, unsigned int, CT_PRIMITIVE_UNSIGNED )         \\\n       EPTYPE(ul, unsigned long, CT_PRIMITIVE_UNSIGNED )        \\\n       EPTYPE(ull, unsigned long long, CT_PRIMITIVE_UNSIGNED )  \\\n       EPTYPE(f, float, CT_PRIMITIVE_FLOAT )                    \\\n       EPTYPE(d, double, CT_PRIMITIVE_FLOAT )                   \\\n       EPTYPE(ld, long double, CT_PRIMITIVE_FLOAT | CT_IS_LONGDOUBLE ) \\\n       ENUM_PRIMITIVE_TYPES_WCHAR                               \\\n       EPTYPE(b, _Bool, CT_PRIMITIVE_UNSIGNED | CT_IS_BOOL )    \\\n     /* the following types are not primitive in the C sense */ \\\n       EPTYPE(i8, int8_t, CT_PRIMITIVE_SIGNED)                  \\\n       EPTYPE(u8, uint8_t, CT_PRIMITIVE_UNSIGNED)               \\\n       EPTYPE(i16, int16_t, CT_PRIMITIVE_SIGNED)                \\\n       EPTYPE(u16, uint16_t, CT_PRIMITIVE_UNSIGNED)             \\\n       EPTYPE(i32, int32_t, CT_PRIMITIVE_SIGNED)                \\\n       EPTYPE(u32, uint32_t, CT_PRIMITIVE_UNSIGNED)             \\\n       EPTYPE(i64, int64_t, CT_PRIMITIVE_SIGNED)                \\\n       EPTYPE(u64, uint64_t, CT_PRIMITIVE_UNSIGNED)             \\\n       EPTYPE(il8, int_least8_t, CT_PRIMITIVE_SIGNED)           \\\n       EPTYPE(ul8, uint_least8_t, CT_PRIMITIVE_UNSIGNED)        \\\n       EPTYPE(il16, int_least16_t, CT_PRIMITIVE_SIGNED)         \\\n       EPTYPE(ul16, uint_least16_t, CT_PRIMITIVE_UNSIGNED)      \\\n       EPTYPE(il32, int_least32_t, CT_PRIMITIVE_SIGNED)         \\\n       EPTYPE(ul32, uint_least32_t, CT_PRIMITIVE_UNSIGNED)      \\\n       EPTYPE(il64, int_least64_t, CT_PRIMITIVE_SIGNED)         \\\n       EPTYPE(ul64, uint_least64_t, CT_PRIMITIVE_UNSIGNED)      \\\n       EPTYPE(if8, int_fast8_t, CT_PRIMITIVE_SIGNED)            \\\n       EPTYPE(uf8, uint_fast8_t, CT_PRIMITIVE_UNSIGNED)         \\\n       EPTYPE(if16, int_fast16_t, CT_PRIMITIVE_SIGNED)          \\\n       EPTYPE(uf16, uint_fast16_t, CT_PRIMITIVE_UNSIGNED)       \\\n       EPTYPE(if32, int_fast32_t, CT_PRIMITIVE_SIGNED)          \\\n       EPTYPE(uf32, uint_fast32_t, CT_PRIMITIVE_UNSIGNED)       \\\n       EPTYPE(if64, int_fast64_t, CT_PRIMITIVE_SIGNED)          \\\n       EPTYPE(uf64, uint_fast64_t, CT_PRIMITIVE_UNSIGNED)       \\\n       EPTYPE(ip, intptr_t, CT_PRIMITIVE_SIGNED)                \\\n       EPTYPE(up, uintptr_t, CT_PRIMITIVE_UNSIGNED)             \\\n       EPTYPE(im, intmax_t, CT_PRIMITIVE_SIGNED)                \\\n       EPTYPE(um, uintmax_t, CT_PRIMITIVE_UNSIGNED)             \\\n       EPTYPE(pd, ptrdiff_t, CT_PRIMITIVE_SIGNED)               \\\n       EPTYPE(sz, size_t, CT_PRIMITIVE_UNSIGNED)                \\\n       EPTYPE(ssz, ssize_t, CT_PRIMITIVE_SIGNED)\n\n#ifdef HAVE_WCHAR_H\n# define ENUM_PRIMITIVE_TYPES_WCHAR                             \\\n       EPTYPE(wc, wchar_t, CT_PRIMITIVE_CHAR )\n#else\n# define ENUM_PRIMITIVE_TYPES_WCHAR   /* nothing */\n#endif\n\n#define EPTYPE(code, typename, flags)                   \\\n    struct aligncheck_##code { char x; typename y; };\n    ENUM_PRIMITIVE_TYPES\n#undef EPTYPE\n\n    CTypeDescrObject *td;\n    static const struct descr_s { const char *name; int size, align, flags; }\n    types[] = {\n#define EPTYPE(code, typename, flags)                   \\\n        { #typename,                                    \\\n          sizeof(typename),                             \\\n          offsetof(struct aligncheck_##code, y),        \\\n          flags                                         \\\n        },\n    ENUM_PRIMITIVE_TYPES\n#undef EPTYPE\n#undef ENUM_PRIMITIVE_TYPES_WCHAR\n#undef ENUM_PRIMITIVE_TYPES\n        { NULL }\n    };\n    const struct descr_s *ptypes;\n    const void *unique_key[1];\n    int name_size;\n    ffi_type *ffitype;\n\n    for (ptypes=types; ; ptypes++) {\n        if (ptypes->name == NULL) {\n#ifndef HAVE_WCHAR_H\n            if (strcmp(name, \"wchar_t\"))\n                PyErr_SetString(PyExc_NotImplementedError, name);\n            else\n#endif\n            PyErr_SetString(PyExc_KeyError, name);\n            return NULL;\n        }\n        if (strcmp(name, ptypes->name) == 0)\n            break;\n    }\n\n    if (ptypes->flags & CT_PRIMITIVE_SIGNED) {\n        switch (ptypes->size) {\n        case 1: ffitype = &ffi_type_sint8; break;\n        case 2: ffitype = &ffi_type_sint16; break;\n        case 4: ffitype = &ffi_type_sint32; break;\n        case 8: ffitype = &ffi_type_sint64; break;\n        default: goto bad_ffi_type;\n        }\n    }\n    else if (ptypes->flags & CT_PRIMITIVE_FLOAT) {\n        if (strcmp(ptypes->name, \"float\") == 0)\n            ffitype = &ffi_type_float;\n        else if (strcmp(ptypes->name, \"double\") == 0)\n            ffitype = &ffi_type_double;\n        else if (strcmp(ptypes->name, \"long double\") == 0)\n            ffitype = &ffi_type_longdouble;\n        else\n            goto bad_ffi_type;\n    }\n    else {\n        switch (ptypes->size) {\n        case 1: ffitype = &ffi_type_uint8; break;\n        case 2: ffitype = &ffi_type_uint16; break;\n        case 4: ffitype = &ffi_type_uint32; break;\n        case 8: ffitype = &ffi_type_uint64; break;\n        default: goto bad_ffi_type;\n        }\n    }\n\n    name_size = strlen(ptypes->name) + 1;\n    td = ctypedescr_new(name_size);\n    if (td == NULL)\n        return NULL;\n\n    memcpy(td->ct_name, name, name_size);\n    td->ct_size = ptypes->size;\n    td->ct_length = ptypes->align;\n    td->ct_extra = ffitype;\n    td->ct_flags = ptypes->flags;\n    if (td->ct_flags & (CT_PRIMITIVE_SIGNED | CT_PRIMITIVE_CHAR)) {\n        if (td->ct_size <= (Py_ssize_t)sizeof(long))\n            td->ct_flags |= CT_PRIMITIVE_FITS_LONG;\n    }\n    else if (td->ct_flags & CT_PRIMITIVE_UNSIGNED) {\n        if (td->ct_size < (Py_ssize_t)sizeof(long))\n            td->ct_flags |= CT_PRIMITIVE_FITS_LONG;\n    }\n    td->ct_name_position = strlen(td->ct_name);\n    unique_key[0] = ptypes;\n    return get_unique_type(td, unique_key, 1);\n\n bad_ffi_type:\n    PyErr_Format(PyExc_NotImplementedError,\n                 \"primitive type '%s' has size %d; \"\n                 \"the supported sizes are 1, 2, 4, 8\",\n                 name, (int)ptypes->size);\n    return NULL;\n}\n\nstatic PyObject *b_new_primitive_type(PyObject *self, PyObject *args)\n{\n    char *name;\n    if (!PyArg_ParseTuple(args, \"s:new_primitive_type\", &name))\n        return NULL;\n    return new_primitive_type(name);\n}\n\nstatic PyObject *new_pointer_type(CTypeDescrObject *ctitem)\n{\n    CTypeDescrObject *td;\n    const char *extra;\n    const void *unique_key[1];\n\n    if (ctitem->ct_flags & CT_ARRAY)\n        extra = \"(*)\";   /* obscure case: see test_array_add */\n    else\n        extra = \" *\";\n    td = ctypedescr_new_on_top(ctitem, extra, 2);\n    if (td == NULL)\n        return NULL;\n\n    td->ct_size = sizeof(void *);\n    td->ct_length = -1;\n    td->ct_flags = CT_POINTER;\n    if (ctitem->ct_flags & (CT_STRUCT|CT_UNION))\n        td->ct_flags |= CT_IS_PTR_TO_OWNED;\n    if (ctitem->ct_flags & CT_VOID)\n        td->ct_flags |= CT_IS_VOID_PTR;\n    if ((ctitem->ct_flags & CT_VOID) ||\n        ((ctitem->ct_flags & CT_PRIMITIVE_CHAR) &&\n         ctitem->ct_size == sizeof(char)))\n        td->ct_flags |= CT_CAST_ANYTHING;   /* 'void *' or 'char *' only */\n    unique_key[0] = ctitem;\n    return get_unique_type(td, unique_key, 1);\n}\n\nstatic PyObject *b_new_pointer_type(PyObject *self, PyObject *args)\n{\n    CTypeDescrObject *ctitem;\n    if (!PyArg_ParseTuple(args, \"O!:new_pointer_type\",\n                          &CTypeDescr_Type, &ctitem))\n        return NULL;\n    return new_pointer_type(ctitem);\n}\n\nstatic PyObject *b_new_array_type(PyObject *self, PyObject *args)\n{\n    PyObject *lengthobj;\n    Py_ssize_t length;\n    CTypeDescrObject *ctptr;\n\n    if (!PyArg_ParseTuple(args, \"O!O:new_array_type\",\n                          &CTypeDescr_Type, &ctptr, &lengthobj))\n        return NULL;\n\n    if (lengthobj == Py_None) {\n        length = -1;\n    }\n    else {\n        length = PyNumber_AsSsize_t(lengthobj, PyExc_OverflowError);\n        if (length < 0) {\n            if (!PyErr_Occurred())\n                PyErr_SetString(PyExc_ValueError, \"negative array length\");\n            return NULL;\n        }\n    }\n    return new_array_type(ctptr, length);\n}\n\nstatic PyObject *\nnew_array_type(CTypeDescrObject *ctptr, Py_ssize_t length)\n{\n    CTypeDescrObject *td, *ctitem;\n    char extra_text[32];\n    Py_ssize_t arraysize;\n    int flags = CT_ARRAY;\n    const void *unique_key[2];\n\n    if (!(ctptr->ct_flags & CT_POINTER)) {\n        PyErr_SetString(PyExc_TypeError, \"first arg must be a pointer ctype\");\n        return NULL;\n    }\n    ctitem = ctptr->ct_itemdescr;\n    if (ctitem->ct_size < 0) {\n        PyErr_Format(PyExc_ValueError, \"array item of unknown size: '%s'\",\n                     ctitem->ct_name);\n        return NULL;\n    }\n\n    if (length < 0) {\n        sprintf(extra_text, \"[]\");\n        length = -1;\n        arraysize = -1;\n        if ((ctitem->ct_flags & CT_PRIMITIVE_CHAR) &&\n                ctitem->ct_size == sizeof(char))\n            flags |= CT_IS_UNSIZED_CHAR_A;\n    }\n    else {\n        sprintf(extra_text, \"[%llu]\", (unsigned PY_LONG_LONG)length);\n        arraysize = length * ctitem->ct_size;\n        if (length > 0 && (arraysize / length) != ctitem->ct_size) {\n            PyErr_SetString(PyExc_OverflowError,\n                            \"array size would overflow a Py_ssize_t\");\n            return NULL;\n        }\n    }\n    td = ctypedescr_new_on_top(ctitem, extra_text, 0);\n    if (td == NULL)\n        return NULL;\n\n    Py_INCREF(ctptr);\n    td->ct_stuff = (PyObject *)ctptr;\n    td->ct_size = arraysize;\n    td->ct_length = length;\n    td->ct_flags = flags;\n    unique_key[0] = ctptr;\n    unique_key[1] = (void *)length;\n    return get_unique_type(td, unique_key, 2);\n}\n\nstatic PyObject *new_void_type(void)\n{\n    int name_size = strlen(\"void\") + 1;\n    const void *unique_key[1];\n    CTypeDescrObject *td = ctypedescr_new(name_size);\n    if (td == NULL)\n        return NULL;\n\n    memcpy(td->ct_name, \"void\", name_size);\n    td->ct_size = -1;\n    td->ct_flags = CT_VOID | CT_IS_OPAQUE;\n    td->ct_name_position = strlen(\"void\");\n    unique_key[0] = \"void\";\n    return get_unique_type(td, unique_key, 1);\n}\n\nstatic PyObject *b_new_void_type(PyObject *self, PyObject *args)\n{\n    return new_void_type();\n}\n\nstatic PyObject *new_struct_or_union_type(const char *name, int flag)\n{\n    int namelen = strlen(name);\n    CTypeDescrObject *td = ctypedescr_new(namelen + 1);\n    if (td == NULL)\n        return NULL;\n\n    td->ct_size = -1;\n    td->ct_length = -1;\n    td->ct_flags = flag | CT_IS_OPAQUE;\n    td->ct_extra = NULL;\n    memcpy(td->ct_name, name, namelen + 1);\n    td->ct_name_position = namelen;\n    return (PyObject *)td;\n}\n\nstatic PyObject *b_new_struct_type(PyObject *self, PyObject *args)\n{\n    char *name;\n    int flag;\n    if (!PyArg_ParseTuple(args, \"s:new_struct_type\", &name))\n        return NULL;\n\n    flag = CT_STRUCT;\n    if (strcmp(name, \"struct _IO_FILE\") == 0 || strcmp(name, \"FILE\") == 0)\n        flag |= CT_IS_FILE;\n    return new_struct_or_union_type(name, flag);\n}\n\nstatic PyObject *b_new_union_type(PyObject *self, PyObject *args)\n{\n    char *name;\n    if (!PyArg_ParseTuple(args, \"s:new_union_type\", &name))\n        return NULL;\n    return new_struct_or_union_type(name, CT_UNION);\n}\n\nstatic CFieldObject *\n_add_field(PyObject *interned_fields, PyObject *fname, CTypeDescrObject *ftype,\n           Py_ssize_t offset, int bitshift, int fbitsize)\n{\n    int err;\n    Py_ssize_t prev_size;\n    CFieldObject *cf = PyObject_New(CFieldObject, &CField_Type);\n    if (cf == NULL)\n        return NULL;\n\n    Py_INCREF(ftype);\n    cf->cf_type = ftype;\n    cf->cf_offset = offset;\n    cf->cf_bitshift = bitshift;\n    cf->cf_bitsize = fbitsize;\n\n    Py_INCREF(fname);\n    PyText_InternInPlace(&fname);\n    prev_size = PyDict_Size(interned_fields);\n    err = PyDict_SetItem(interned_fields, fname, (PyObject *)cf);\n    Py_DECREF(fname);\n    Py_DECREF(cf);\n    if (err < 0)\n        return NULL;\n\n    if (PyDict_Size(interned_fields) != prev_size + 1) {\n        PyErr_Format(PyExc_KeyError, \"duplicate field name '%s'\",\n                     PyText_AS_UTF8(fname));\n        return NULL;\n    }\n    return cf;   /* borrowed reference */\n}\n\n#define SF_MSVC_BITFIELDS     0x01\n#define SF_GCC_ARM_BITFIELDS  0x02\n#define SF_GCC_X86_BITFIELDS  0x10\n\n#define SF_GCC_BIG_ENDIAN     0x04\n#define SF_GCC_LITTLE_ENDIAN  0x40\n\n#define SF_PACKED             0x08\n#define SF_STD_FIELD_POS      0x80\n\nstatic int complete_sflags(int sflags)\n{\n    /* add one of the SF_xxx_BITFIELDS flags if none is specified */\n    if (!(sflags & (SF_MSVC_BITFIELDS | SF_GCC_ARM_BITFIELDS |\n                    SF_GCC_X86_BITFIELDS))) {\n#ifdef MS_WIN32\n        sflags |= SF_MSVC_BITFIELDS;\n#else\n# if defined(__arm__) || defined(__aarch64__)\n        sflags |= SF_GCC_ARM_BITFIELDS;\n# else\n        sflags |= SF_GCC_X86_BITFIELDS;\n# endif\n#endif\n    }\n    /* add one of SF_GCC_xx_ENDIAN if none is specified */\n    if (!(sflags & (SF_GCC_BIG_ENDIAN | SF_GCC_LITTLE_ENDIAN))) {\n        int _check_endian = 1;\n        if (*(char *)&_check_endian == 0)\n            sflags |= SF_GCC_BIG_ENDIAN;\n        else\n            sflags |= SF_GCC_LITTLE_ENDIAN;\n    }\n    return sflags;\n}\n\nstatic int detect_custom_layout(CTypeDescrObject *ct, int sflags,\n                                Py_ssize_t cdef_value,\n                                Py_ssize_t compiler_value,\n                                const char *msg1, const char *txt,\n                                const char *msg2)\n{\n    if (compiler_value != cdef_value) {\n        if (sflags & SF_STD_FIELD_POS) {\n            PyErr_Format(FFIError,\n                         \"%s: %s%s%s (cdef says %zd, but C compiler says %zd).\"\n                         \" fix it or use \\\"...;\\\" in the cdef for %s to \"\n                         \"make it flexible\",\n                         ct->ct_name, msg1, txt, msg2,\n                         cdef_value, compiler_value,\n                         ct->ct_name);\n            return -1;\n        }\n        ct->ct_flags |= CT_CUSTOM_FIELD_POS;\n    }\n    return 0;\n}\n\nstatic PyObject *b_complete_struct_or_union(PyObject *self, PyObject *args)\n{\n    CTypeDescrObject *ct;\n    PyObject *fields, *interned_fields, *ignored;\n    int is_union, alignment;\n    Py_ssize_t boffset, i, nb_fields, boffsetmax, alignedsize;\n    Py_ssize_t totalsize = -1;\n    int totalalignment = -1;\n    CFieldObject **previous;\n    int prev_bitfield_size, prev_bitfield_free;\n    int sflags = 0;\n\n    if (!PyArg_ParseTuple(args, \"O!O!|Onii:complete_struct_or_union\",\n                          &CTypeDescr_Type, &ct,\n                          &PyList_Type, &fields,\n                          &ignored, &totalsize, &totalalignment, &sflags))\n        return NULL;\n\n    sflags = complete_sflags(sflags);\n\n    if ((ct->ct_flags & (CT_STRUCT|CT_IS_OPAQUE)) ==\n                        (CT_STRUCT|CT_IS_OPAQUE)) {\n        is_union = 0;\n    }\n    else if ((ct->ct_flags & (CT_UNION|CT_IS_OPAQUE)) ==\n                             (CT_UNION|CT_IS_OPAQUE)) {\n        is_union = 1;\n    }\n    else {\n        PyErr_SetString(PyExc_TypeError,\n                  \"first arg must be a non-initialized struct or union ctype\");\n        return NULL;\n    }\n    ct->ct_flags &= ~CT_CUSTOM_FIELD_POS;\n\n    alignment = 1;\n    boffset = 0;         /* this number is in *bits*, not bytes! */\n    boffsetmax = 0;      /* the maximum value of boffset, in bits too */\n    prev_bitfield_size = 0;\n    prev_bitfield_free = 0;\n    nb_fields = PyList_GET_SIZE(fields);\n    interned_fields = PyDict_New();\n    if (interned_fields == NULL)\n        return NULL;\n\n    previous = (CFieldObject **)&ct->ct_extra;\n\n    for (i=0; i<nb_fields; i++) {\n        PyObject *fname;\n        CTypeDescrObject *ftype;\n        int fbitsize = -1, falign, do_align;\n        Py_ssize_t foffset = -1;\n\n        if (!PyArg_ParseTuple(PyList_GET_ITEM(fields, i), \"O!O!|in:list item\",\n                              &PyText_Type, &fname,\n                              &CTypeDescr_Type, &ftype,\n                              &fbitsize, &foffset))\n            goto error;\n\n        if (ftype->ct_size < 0) {\n            if ((ftype->ct_flags & CT_ARRAY) && fbitsize < 0\n                    && (i == nb_fields - 1 || foffset != -1)) {\n                ct->ct_flags |= CT_WITH_VAR_ARRAY;\n            }\n            else {\n                PyErr_Format(PyExc_TypeError,\n                             \"field '%s.%s' has ctype '%s' of unknown size\",\n                             ct->ct_name, PyText_AS_UTF8(fname),\n                             ftype->ct_name);\n                goto error;\n            }\n        }\n\n        if (is_union)\n            boffset = 0;   /* reset each field at offset 0 */\n\n        /* update the total alignment requirement, but skip it if the\n           field is an anonymous bitfield or if SF_PACKED */\n        falign = (sflags & SF_PACKED) ? 1 : get_alignment(ftype);\n        if (falign < 0)\n            goto error;\n\n        do_align = 1;\n        if (!(sflags & SF_GCC_ARM_BITFIELDS) && fbitsize >= 0) {\n            if (!(sflags & SF_MSVC_BITFIELDS)) {\n                /* GCC: anonymous bitfields (of any size) don't cause alignment */\n                do_align = PyText_GetSize(fname) > 0;\n            }\n            else {\n                /* MSVC: zero-sized bitfields don't cause alignment */\n                do_align = fbitsize > 0;\n            }\n        }\n        if (alignment < falign && do_align)\n            alignment = falign;\n\n        if (fbitsize < 0) {\n            /* not a bitfield: common case */\n            int bs_flag;\n\n            if (ftype->ct_flags & CT_ARRAY && ftype->ct_length == 0)\n                bs_flag = BS_EMPTY_ARRAY;\n            else\n                bs_flag = BS_REGULAR;\n\n            /* align this field to its own 'falign' by inserting padding */\n            boffset = (boffset + falign*8-1) & ~(falign*8-1); /* bits! */\n\n            if (foffset >= 0) {\n                /* a forced field position: ignore the offset just computed,\n                   except to know if we must set CT_CUSTOM_FIELD_POS */\n                if (detect_custom_layout(ct, sflags, boffset / 8, foffset,\n                                         \"wrong offset for field '\",\n                                         PyText_AS_UTF8(fname), \"'\") < 0)\n                    goto error;\n                boffset = foffset * 8;\n            }\n\n            if (PyText_GetSize(fname) == 0 &&\n                    ftype->ct_flags & (CT_STRUCT|CT_UNION)) {\n                /* a nested anonymous struct or union */\n                CFieldObject *cfsrc = (CFieldObject *)ftype->ct_extra;\n                for (; cfsrc != NULL; cfsrc = cfsrc->cf_next) {\n                    /* broken complexity in the call to get_field_name(),\n                       but we'll assume you never do that with nested\n                       anonymous structures with thousand of fields */\n                    *previous = _add_field(interned_fields,\n                                           get_field_name(ftype, cfsrc),\n                                           cfsrc->cf_type,\n                                           boffset / 8 + cfsrc->cf_offset,\n                                           cfsrc->cf_bitshift,\n                                           cfsrc->cf_bitsize);\n                    if (*previous == NULL)\n                        goto error;\n                    previous = &(*previous)->cf_next;\n                }\n                /* always forbid such structures from being passed by value */\n                ct->ct_flags |= CT_CUSTOM_FIELD_POS;\n            }\n            else {\n                *previous = _add_field(interned_fields, fname, ftype,\n                                        boffset / 8, bs_flag, -1);\n                if (*previous == NULL)\n                    goto error;\n                previous = &(*previous)->cf_next;\n            }\n            if (ftype->ct_size >= 0)\n                boffset += ftype->ct_size * 8;\n            prev_bitfield_size = 0;\n        }\n        else {\n            /* this is the case of a bitfield */\n            Py_ssize_t field_offset_bytes;\n            int bits_already_occupied, bitshift;\n\n            if (foffset >= 0) {\n                PyErr_Format(PyExc_TypeError,\n                             \"field '%s.%s' is a bitfield, \"\n                             \"but a fixed offset is specified\",\n                             ct->ct_name, PyText_AS_UTF8(fname));\n                goto error;\n            }\n\n            if (!(ftype->ct_flags & (CT_PRIMITIVE_SIGNED |\n                                     CT_PRIMITIVE_UNSIGNED |\n                                     CT_PRIMITIVE_CHAR))) {\n                PyErr_Format(PyExc_TypeError,\n                        \"field '%s.%s' declared as '%s' cannot be a bit field\",\n                             ct->ct_name, PyText_AS_UTF8(fname),\n                             ftype->ct_name);\n                goto error;\n            }\n            if (fbitsize > 8 * ftype->ct_size) {\n                PyErr_Format(PyExc_TypeError,\n                             \"bit field '%s.%s' is declared '%s:%d', which \"\n                             \"exceeds the width of the type\",\n                             ct->ct_name, PyText_AS_UTF8(fname),\n                             ftype->ct_name, fbitsize);\n                goto error;\n            }\n\n            /* compute the starting position of the theoretical field\n               that covers a complete 'ftype', inside of which we will\n               locate the real bitfield */\n            field_offset_bytes = boffset / 8;\n            field_offset_bytes &= ~(falign - 1);\n\n            if (fbitsize == 0) {\n                if (PyText_GetSize(fname) > 0) {\n                    PyErr_Format(PyExc_TypeError,\n                                 \"field '%s.%s' is declared with :0\",\n                                 ct->ct_name, PyText_AS_UTF8(fname));\n                    goto error;\n                }\n                if (!(sflags & SF_MSVC_BITFIELDS)) {\n                    /* GCC's notion of \"ftype :0;\" */\n\n                    /* pad boffset to a value aligned for \"ftype\" */\n                    if (boffset > field_offset_bytes * 8) {\n                        field_offset_bytes += falign;\n                        assert(boffset < field_offset_bytes * 8);\n                    }\n                    boffset = field_offset_bytes * 8;\n                }\n                else {\n                    /* MSVC's notion of \"ftype :0;\" */\n\n                    /* Mostly ignored.  It seems they only serve as\n                       separator between other bitfields, to force them\n                       into separate words. */\n                }\n                prev_bitfield_size = 0;\n            }\n            else {\n                if (!(sflags & SF_MSVC_BITFIELDS)) {\n                    /* GCC's algorithm */\n\n                    /* Can the field start at the offset given by 'boffset'?  It\n                       can if it would entirely fit into an aligned ftype field. */\n                    bits_already_occupied = boffset - (field_offset_bytes * 8);\n\n                    if (bits_already_occupied + fbitsize > 8 * ftype->ct_size) {\n                        /* it would not fit, we need to start at the next\n                           allowed position */\n                        if ((sflags & SF_PACKED) &&\n                            (bits_already_occupied & 7)) {\n                            PyErr_Format(PyExc_NotImplementedError,\n                                \"with 'packed', gcc would compile field \"\n                                \"'%s.%s' to reuse some bits in the previous \"\n                                \"field\", ct->ct_name, PyText_AS_UTF8(fname));\n                            goto error;\n                        }\n                        field_offset_bytes += falign;\n                        assert(boffset < field_offset_bytes * 8);\n                        boffset = field_offset_bytes * 8;\n                        bitshift = 0;\n                    }\n                    else {\n                        bitshift = bits_already_occupied;\n                        assert(bitshift >= 0);\n                    }\n                    boffset += fbitsize;\n                }\n                else {\n                    /* MSVC's algorithm */\n\n                    /* A bitfield is considered as taking the full width\n                       of their declared type.  It can share some bits\n                       with the previous field only if it was also a\n                       bitfield and used a type of the same size. */\n                    if (prev_bitfield_size == ftype->ct_size &&\n                        prev_bitfield_free >= fbitsize) {\n                        /* yes: reuse */\n                        bitshift = 8 * prev_bitfield_size - prev_bitfield_free;\n                    }\n                    else {\n                        /* no: start a new full field */\n                        boffset = (boffset + falign*8-1) & ~(falign*8-1); /*align*/\n                        boffset += ftype->ct_size * 8;\n                        bitshift = 0;\n                        prev_bitfield_size = ftype->ct_size;\n                        prev_bitfield_free = 8 * prev_bitfield_size;\n                    }\n                    prev_bitfield_free -= fbitsize;\n                    field_offset_bytes = boffset / 8 - ftype->ct_size;\n                }\n\n                if (sflags & SF_GCC_BIG_ENDIAN)\n                    bitshift = 8 * ftype->ct_size - fbitsize - bitshift;\n\n                *previous = _add_field(interned_fields, fname, ftype,\n                                       field_offset_bytes, bitshift, fbitsize);\n                if (*previous == NULL)\n                    goto error;\n                previous = &(*previous)->cf_next;\n            }\n        }\n\n        if (boffset > boffsetmax)\n            boffsetmax = boffset;\n    }\n    *previous = NULL;\n\n    /* Like C, if the size of this structure would be zero, we compute it\n       as 1 instead.  But for ctypes support, we allow the manually-\n       specified totalsize to be zero in this case. */\n    boffsetmax = (boffsetmax + 7) / 8;        /* bits -> bytes */\n    alignedsize = (boffsetmax + alignment - 1) & ~(alignment-1);\n    if (alignedsize == 0)\n        alignedsize = 1;\n\n    if (totalsize < 0) {\n        totalsize = alignedsize;\n    }\n    else {\n        if (detect_custom_layout(ct, sflags, alignedsize,\n                                 totalsize, \"wrong total size\", \"\", \"\") < 0)\n            goto error;\n        if (totalsize < boffsetmax) {\n            PyErr_Format(PyExc_TypeError,\n                         \"%s cannot be of size %zd: there are fields at least \"\n                         \"up to %zd\", ct->ct_name, totalsize, boffsetmax);\n            goto error;\n        }\n    }\n    if (totalalignment < 0) {\n        totalalignment = alignment;\n    }\n    else {\n        if (detect_custom_layout(ct, sflags, alignment, totalalignment,\n                                 \"wrong total alignment\", \"\", \"\") < 0)\n            goto error;\n    }\n\n    ct->ct_size = totalsize;\n    ct->ct_length = totalalignment;\n    ct->ct_stuff = interned_fields;\n    ct->ct_flags &= ~CT_IS_OPAQUE;\n\n    Py_INCREF(Py_None);\n    return Py_None;\n\n error:\n    ct->ct_extra = NULL;\n    Py_DECREF(interned_fields);\n    return NULL;\n}\n\nstruct funcbuilder_s {\n    Py_ssize_t nb_bytes;\n    char *bufferp;\n    ffi_type **atypes;\n    ffi_type *rtype;\n    Py_ssize_t nargs;\n    CTypeDescrObject *fct;\n};\n\nstatic void *fb_alloc(struct funcbuilder_s *fb, Py_ssize_t size)\n{\n    if (fb->bufferp == NULL) {\n        fb->nb_bytes += size;\n        return NULL;\n    }\n    else {\n        char *result = fb->bufferp;\n        fb->bufferp += size;\n        return result;\n    }\n}\n\nstatic ffi_type *fb_fill_type(struct funcbuilder_s *fb, CTypeDescrObject *ct,\n                              int is_result_type)\n{\n    const char *place = is_result_type ? \"return value\" : \"argument\";\n\n    if (ct->ct_flags & CT_PRIMITIVE_ANY) {\n        return (ffi_type *)ct->ct_extra;\n    }\n    else if (ct->ct_flags & (CT_POINTER|CT_FUNCTIONPTR)) {\n        return &ffi_type_pointer;\n    }\n    else if ((ct->ct_flags & CT_VOID) && is_result_type) {\n        return &ffi_type_void;\n    }\n\n    if (ct->ct_size <= 0) {\n        PyErr_Format(PyExc_TypeError,\n                     ct->ct_size < 0 ? \"ctype '%s' has incomplete type\"\n                                     : \"ctype '%s' has size 0\",\n                     ct->ct_name);\n        return NULL;\n    }\n    if (ct->ct_flags & CT_STRUCT) {\n        ffi_type *ffistruct, *ffifield;\n        ffi_type **elements;\n        Py_ssize_t i, n, nflat;\n        CFieldObject *cf;\n\n        /* We can't pass a struct that was completed by verify().\n           Issue: assume verify() is given \"struct { long b; ...; }\".\n           Then it will complete it in the same way whether it is actually\n           \"struct { long a, b; }\" or \"struct { double a; long b; }\".\n           But on 64-bit UNIX, these two structs are passed by value\n           differently: e.g. on x86-64, \"b\" ends up in register \"rsi\" in\n           the first case and \"rdi\" in the second case.\n\n           Another reason for CT_CUSTOM_FIELD_POS would be anonymous\n           nested structures: we lost the information about having it\n           here, so better safe (and forbid it) than sorry (and maybe\n           crash).\n        */\n        if (force_lazy_struct(ct) < 0)\n            return NULL;\n        if (ct->ct_flags & CT_CUSTOM_FIELD_POS) {\n            /* these NotImplementedErrors may be caught and ignored until\n               a real call is made to a function of this type */\n            PyErr_Format(PyExc_NotImplementedError,\n                \"ctype '%s' not supported as %s (it is a struct declared \"\n                \"with \\\"...;\\\", but the C calling convention may depend \"\n                \"on the missing fields)\", ct->ct_name, place);\n            return NULL;\n        }\n\n        n = PyDict_Size(ct->ct_stuff);\n        nflat = 0;\n\n        /* walk the fields, expanding arrays into repetitions; first,\n           only count how many flattened fields there are */\n        cf = (CFieldObject *)ct->ct_extra;\n        for (i=0; i<n; i++) {\n            Py_ssize_t flat;\n            CTypeDescrObject *ct1;\n            assert(cf != NULL);\n            if (cf->cf_bitshift >= 0) {\n                PyErr_Format(PyExc_NotImplementedError,\n                     \"ctype '%s' not supported as %s\"\n                     \" (it is a struct with bit fields)\",\n                     ct->ct_name, place);\n                return NULL;\n            }\n            flat = 1;\n            ct1 = cf->cf_type;\n            while (ct1->ct_flags & CT_ARRAY) {\n                flat *= ct1->ct_length;\n                ct1 = ct1->ct_itemdescr;\n            }\n            if (flat <= 0) {\n                PyErr_Format(PyExc_NotImplementedError,\n                     \"ctype '%s' not supported as %s\"\n                     \" (it is a struct with a zero-length array)\",\n                     ct->ct_name, place);\n                return NULL;\n            }\n            nflat += flat;\n            cf = cf->cf_next;\n        }\n        assert(cf == NULL);\n\n        /* next, allocate and fill the flattened list */\n        elements = fb_alloc(fb, (nflat + 1) * sizeof(ffi_type*));\n        nflat = 0;\n        cf = (CFieldObject *)ct->ct_extra;\n        for (i=0; i<n; i++) {\n            Py_ssize_t j, flat = 1;\n            CTypeDescrObject *ct = cf->cf_type;\n            while (ct->ct_flags & CT_ARRAY) {\n                flat *= ct->ct_length;\n                ct = ct->ct_itemdescr;\n            }\n            ffifield = fb_fill_type(fb, ct, 0);\n            if (elements != NULL) {\n                for (j=0; j<flat; j++)\n                    elements[nflat++] = ffifield;\n            }\n            cf = cf->cf_next;\n        }\n\n        /* finally, allocate the FFI_TYPE_STRUCT */\n        ffistruct = fb_alloc(fb, sizeof(ffi_type));\n        if (ffistruct != NULL) {\n            elements[nflat] = NULL;\n            ffistruct->size = ct->ct_size;\n            ffistruct->alignment = ct->ct_length;\n            ffistruct->type = FFI_TYPE_STRUCT;\n            ffistruct->elements = elements;\n        }\n        return ffistruct;\n    }\n    else {\n        PyErr_Format(PyExc_NotImplementedError,\n                     \"ctype '%s' (size %zd) not supported as %s\",\n                     ct->ct_name, ct->ct_size, place);\n        return NULL;\n    }\n}\n\n#define ALIGN_ARG(n)  ((n) + 7) & ~7\n\nstatic int fb_build(struct funcbuilder_s *fb, PyObject *fargs,\n                    CTypeDescrObject *fresult)\n{\n    Py_ssize_t i, nargs = PyTuple_GET_SIZE(fargs);\n    Py_ssize_t exchange_offset;\n    cif_description_t *cif_descr;\n\n    /* ffi buffer: start with a cif_description */\n    cif_descr = fb_alloc(fb, sizeof(cif_description_t) +\n                             nargs * sizeof(Py_ssize_t));\n\n    /* ffi buffer: next comes an array of 'ffi_type*', one per argument */\n    fb->atypes = fb_alloc(fb, nargs * sizeof(ffi_type*));\n    fb->nargs = nargs;\n\n    /* ffi buffer: next comes the result type */\n    fb->rtype = fb_fill_type(fb, fresult, 1);\n    if (PyErr_Occurred())\n        return -1;\n    if (cif_descr != NULL) {\n        /* exchange data size */\n        /* first, enough room for an array of 'nargs' pointers */\n        exchange_offset = nargs * sizeof(void*);\n        exchange_offset = ALIGN_ARG(exchange_offset);\n        cif_descr->exchange_offset_arg[0] = exchange_offset;\n        /* then enough room for the result --- which means at least\n           sizeof(ffi_arg), according to the ffi docs */\n        i = fb->rtype->size;\n        if (i < (Py_ssize_t)sizeof(ffi_arg))\n            i = sizeof(ffi_arg);\n        exchange_offset += i;\n    }\n    else\n        exchange_offset = 0;   /* not used */\n\n    /* loop over the arguments */\n    for (i=0; i<nargs; i++) {\n        CTypeDescrObject *farg;\n        ffi_type *atype;\n\n        farg = (CTypeDescrObject *)PyTuple_GET_ITEM(fargs, i);\n        /* convert arrays to pointers */\n        if (farg->ct_flags & CT_ARRAY)\n            farg = (CTypeDescrObject *)farg->ct_stuff;\n\n        /* ffi buffer: fill in the ffi for the i'th argument */\n        assert(farg != NULL);\n        atype = fb_fill_type(fb, farg, 0);\n        if (PyErr_Occurred())\n            return -1;\n\n        if (fb->atypes != NULL) {\n            fb->atypes[i] = atype;\n            /* exchange data size */\n            exchange_offset = ALIGN_ARG(exchange_offset);\n            cif_descr->exchange_offset_arg[1 + i] = exchange_offset;\n            exchange_offset += atype->size;\n        }\n    }\n\n    if (cif_descr != NULL) {\n        /* exchange data size */\n        cif_descr->exchange_size = exchange_offset;\n    }\n    return 0;\n}\n\n#undef ALIGN_ARG\n\nstatic void fb_cat_name(struct funcbuilder_s *fb, char *piece, int piecelen)\n{\n    if (fb->bufferp == NULL) {\n        fb->nb_bytes += piecelen;\n    }\n    else {\n        memcpy(fb->bufferp, piece, piecelen);\n        fb->bufferp += piecelen;\n    }\n}\n\nstatic int fb_build_name(struct funcbuilder_s *fb, PyObject *fargs,\n                         CTypeDescrObject *fresult, int ellipsis)\n{\n    Py_ssize_t i, nargs = PyTuple_GET_SIZE(fargs);\n    fb->nargs = nargs;\n\n    /* name: the function type name we build here is, like in C, made\n       as follows:\n\n         RESULT_TYPE_HEAD (*)(ARG_1_TYPE, ARG_2_TYPE, etc) RESULT_TYPE_TAIL\n    */\n    fb_cat_name(fb, fresult->ct_name, fresult->ct_name_position);\n    fb_cat_name(fb, \"(*)(\", 4);\n    if (fb->fct) {\n        i = fresult->ct_name_position + 2;  /* between '(*' and ')(' */\n        fb->fct->ct_name_position = i;\n    }\n\n    /* loop over the arguments */\n    for (i=0; i<nargs; i++) {\n        CTypeDescrObject *farg;\n\n        farg = (CTypeDescrObject *)PyTuple_GET_ITEM(fargs, i);\n        if (!CTypeDescr_Check(farg)) {\n            PyErr_SetString(PyExc_TypeError, \"expected a tuple of ctypes\");\n            return -1;\n        }\n        /* name: concatenate the name of the i'th argument's type */\n        if (i > 0)\n            fb_cat_name(fb, \", \", 2);\n        fb_cat_name(fb, farg->ct_name, strlen(farg->ct_name));\n    }\n\n    /* name: add the '...' if needed */\n    if (ellipsis) {\n        if (nargs > 0)\n            fb_cat_name(fb, \", \", 2);\n        fb_cat_name(fb, \"...\", 3);\n    }\n\n    /* name: concatenate the tail of the result type */\n    fb_cat_name(fb, \")\", 1);\n    fb_cat_name(fb, fresult->ct_name + fresult->ct_name_position,\n                strlen(fresult->ct_name) - fresult->ct_name_position + 1);\n    return 0;\n}\n\nstatic CTypeDescrObject *fb_prepare_ctype(struct funcbuilder_s *fb,\n                                          PyObject *fargs,\n                                          CTypeDescrObject *fresult,\n                                          int ellipsis)\n{\n    CTypeDescrObject *fct;\n\n    fb->nb_bytes = 0;\n    fb->bufferp = NULL;\n    fb->fct = NULL;\n\n    /* compute the total size needed for the name */\n    if (fb_build_name(fb, fargs, fresult, ellipsis) < 0)\n        return NULL;\n\n    /* allocate the function type */\n    fct = ctypedescr_new(fb->nb_bytes);\n    if (fct == NULL)\n        return NULL;\n    fb->fct = fct;\n\n    /* call again fb_build_name() to really build the ct_name */\n    fb->bufferp = fct->ct_name;\n    if (fb_build_name(fb, fargs, fresult, ellipsis) < 0)\n        goto error;\n    assert(fb->bufferp == fct->ct_name + fb->nb_bytes);\n\n    fct->ct_extra = NULL;\n    fct->ct_size = sizeof(void(*)(void));\n    fct->ct_flags = CT_FUNCTIONPTR;\n    return fct;\n\n error:\n    Py_DECREF(fct);\n    return NULL;\n}\n\nstatic cif_description_t *fb_prepare_cif(PyObject *fargs,\n                                         CTypeDescrObject *fresult,\n                                         ffi_abi fabi)\n{\n    char *buffer;\n    cif_description_t *cif_descr;\n    struct funcbuilder_s funcbuffer;\n\n    funcbuffer.nb_bytes = 0;\n    funcbuffer.bufferp = NULL;\n\n    /* compute the total size needed in the buffer for libffi */\n    if (fb_build(&funcbuffer, fargs, fresult) < 0)\n        return NULL;\n\n    /* allocate the buffer */\n    buffer = PyObject_Malloc(funcbuffer.nb_bytes);\n    if (buffer == NULL) {\n        PyErr_NoMemory();\n        return NULL;\n    }\n\n    /* call again fb_build() to really build the libffi data structures */\n    funcbuffer.bufferp = buffer;\n    if (fb_build(&funcbuffer, fargs, fresult) < 0)\n        goto error;\n    assert(funcbuffer.bufferp == buffer + funcbuffer.nb_bytes);\n\n    cif_descr = (cif_description_t *)buffer;\n    if (ffi_prep_cif(&cif_descr->cif, fabi, funcbuffer.nargs,\n                     funcbuffer.rtype, funcbuffer.atypes) != FFI_OK) {\n        PyErr_SetString(PyExc_SystemError,\n                        \"libffi failed to build this function type\");\n        goto error;\n    }\n    return cif_descr;\n\n error:\n    PyObject_Free(buffer);\n    return NULL;\n}\n\nstatic PyObject *new_function_type(PyObject *fargs,   /* tuple */\n                                   CTypeDescrObject *fresult,\n                                   int ellipsis, int fabi)\n{\n    PyObject *fabiobj;\n    CTypeDescrObject *fct;\n    struct funcbuilder_s funcbuilder;\n    Py_ssize_t i;\n    const void **unique_key;\n\n    if ((fresult->ct_size < 0 && !(fresult->ct_flags & CT_VOID)) ||\n        (fresult->ct_flags & CT_ARRAY)) {\n        char *msg;\n        if (fresult->ct_flags & CT_IS_OPAQUE)\n            msg = \"result type '%s' is opaque\";\n        else\n            msg = \"invalid result type: '%s'\";\n        PyErr_Format(PyExc_TypeError, msg, fresult->ct_name);\n        return NULL;\n    }\n\n    fct = fb_prepare_ctype(&funcbuilder, fargs, fresult, ellipsis);\n    if (fct == NULL)\n        return NULL;\n\n    if (!ellipsis) {\n        /* Functions with '...' varargs are stored without a cif_descr\n           at all.  The cif is computed on every call from the actual\n           types passed in.  For all other functions, the cif_descr\n           is computed here. */\n        cif_description_t *cif_descr;\n\n        cif_descr = fb_prepare_cif(fargs, fresult, fabi);\n        if (cif_descr == NULL) {\n            if (PyErr_ExceptionMatches(PyExc_NotImplementedError)) {\n                PyErr_Clear();   /* will get the exception if we see an\n                                    actual call */\n            }\n            else\n                goto error;\n        }\n\n        fct->ct_extra = (char *)cif_descr;\n    }\n\n    /* build the signature, given by a tuple of ctype objects */\n    fct->ct_stuff = PyTuple_New(2 + funcbuilder.nargs);\n    if (fct->ct_stuff == NULL)\n        goto error;\n    fabiobj = PyInt_FromLong(fabi);\n    if (fabiobj == NULL)\n        goto error;\n    PyTuple_SET_ITEM(fct->ct_stuff, 0, fabiobj);\n\n    Py_INCREF(fresult);\n    PyTuple_SET_ITEM(fct->ct_stuff, 1, (PyObject *)fresult);\n    for (i=0; i<funcbuilder.nargs; i++) {\n        PyObject *o = PyTuple_GET_ITEM(fargs, i);\n        /* convert arrays into pointers */\n        if (((CTypeDescrObject *)o)->ct_flags & CT_ARRAY)\n            o = ((CTypeDescrObject *)o)->ct_stuff;\n        Py_INCREF(o);\n        PyTuple_SET_ITEM(fct->ct_stuff, 2 + i, o);\n    }\n\n    /* [ctresult, ellipsis+abi, num_args, ctargs...] */\n    unique_key = alloca((3 + funcbuilder.nargs) * sizeof(void *));\n    unique_key[0] = fresult;\n    unique_key[1] = (const void *)(Py_ssize_t)((fabi << 1) | !!ellipsis);\n    unique_key[2] = (const void *)(Py_ssize_t)(funcbuilder.nargs);\n    for (i=0; i<funcbuilder.nargs; i++)\n        unique_key[3 + i] = PyTuple_GET_ITEM(fct->ct_stuff, 2 + i);\n    return get_unique_type(fct, unique_key, 3 + funcbuilder.nargs);\n\n error:\n    Py_DECREF(fct);\n    return NULL;\n}\n\nstatic PyObject *b_new_function_type(PyObject *self, PyObject *args)\n{\n    PyObject *fargs;\n    CTypeDescrObject *fresult;\n    int ellipsis = 0, fabi = FFI_DEFAULT_ABI;\n\n    if (!PyArg_ParseTuple(args, \"O!O!|ii:new_function_type\",\n                          &PyTuple_Type, &fargs,\n                          &CTypeDescr_Type, &fresult,\n                          &ellipsis,\n                          &fabi))\n        return NULL;\n\n    return new_function_type(fargs, fresult, ellipsis, fabi);\n}\n\nstatic int convert_from_object_fficallback(char *result,\n                                           CTypeDescrObject *ctype,\n                                           PyObject *pyobj)\n{\n    /* work work work around a libffi irregularity: for integer return\n       types we have to fill at least a complete 'ffi_arg'-sized result\n       buffer. */\n    if (ctype->ct_size < (Py_ssize_t)sizeof(ffi_arg)) {\n        if (ctype->ct_flags & CT_VOID) {\n            if (pyobj == Py_None) {\n                return 0;\n            }\n            else {\n                PyErr_SetString(PyExc_TypeError,\n                    \"callback with the return type 'void' must return None\");\n                return -1;\n            }\n        }\n        if (ctype->ct_flags & CT_PRIMITIVE_SIGNED) {\n            PY_LONG_LONG value;\n            /* It's probably fine to always zero-extend, but you never\n               know: maybe some code somewhere expects a negative\n               'short' result to be returned into EAX as a 32-bit\n               negative number.  Better safe than sorry.  This code\n               is about that case.  Let's ignore this for enums.\n            */\n            /* do a first conversion only to detect overflows.  This\n               conversion produces stuff that is otherwise ignored. */\n            if (convert_from_object(result, ctype, pyobj) < 0)\n                return -1;\n            /* manual inlining and tweaking of convert_from_object()\n               in order to write a whole 'ffi_arg'. */\n            value = _my_PyLong_AsLongLong(pyobj);\n            if (value == -1 && PyErr_Occurred())\n                return -1;\n            write_raw_integer_data(result, value, sizeof(ffi_arg));\n            return 0;\n        }\n        else if (ctype->ct_flags & (CT_PRIMITIVE_CHAR | CT_PRIMITIVE_SIGNED |\n                                    CT_PRIMITIVE_UNSIGNED)) {\n            /* zero extension: fill the '*result' with zeros, and (on big-\n               endian machines) correct the 'result' pointer to write to */\n            memset(result, 0, sizeof(ffi_arg));\n#ifdef WORDS_BIGENDIAN\n            result += (sizeof(ffi_arg) - ctype->ct_size);\n#endif\n        }\n    }\n    return convert_from_object(result, ctype, pyobj);\n}\n\nstatic void _my_PyErr_WriteUnraisable(PyObject *obj, char *extra_error_line)\n{\n    /* like PyErr_WriteUnraisable(), but write a full traceback */\n    PyObject *f, *t, *v, *tb;\n    PyErr_Fetch(&t, &v, &tb);\n#if PY_MAJOR_VERSION >= 3\n    /* jump through hoops to ensure the tb is attached to v, on Python 3 */\n    PyErr_NormalizeException(&t, &v, &tb);\n    if (tb == NULL) {\n        tb = Py_None;\n        Py_INCREF(tb);\n    }\n    PyException_SetTraceback(v, tb);\n#endif\n    f = PySys_GetObject(\"stderr\");\n    if (f != NULL) {\n        PyFile_WriteString(\"From cffi callback \", f);\n        PyFile_WriteObject(obj, f, 0);\n        PyFile_WriteString(\":\\n\", f);\n        if (extra_error_line != NULL)\n            PyFile_WriteString(extra_error_line, f);\n        PyErr_Display(t, v, tb);\n    }\n    Py_XDECREF(t);\n    Py_XDECREF(v);\n    Py_XDECREF(tb);\n}\n\nstatic void invoke_callback(ffi_cif *cif, void *result, void **args,\n                            void *userdata)\n{\n    save_errno();\n    {\n#ifdef WITH_THREAD\n    PyGILState_STATE state = PyGILState_Ensure();\n#endif\n    PyObject *cb_args = (PyObject *)userdata;\n    CTypeDescrObject *ct = (CTypeDescrObject *)PyTuple_GET_ITEM(cb_args, 0);\n    PyObject *signature = ct->ct_stuff;\n    PyObject *py_ob = PyTuple_GET_ITEM(cb_args, 1);\n    PyObject *py_args = NULL;\n    PyObject *py_res = NULL;\n    PyObject *py_rawerr;\n    Py_ssize_t i, n;\n    char *extra_error_line = NULL;\n\n#define SIGNATURE(i)  ((CTypeDescrObject *)PyTuple_GET_ITEM(signature, i))\n\n    Py_INCREF(cb_args);\n\n    n = PyTuple_GET_SIZE(signature) - 2;\n    py_args = PyTuple_New(n);\n    if (py_args == NULL)\n        goto error;\n\n    for (i=0; i<n; i++) {\n        PyObject *a = convert_to_object(args[i], SIGNATURE(2 + i));\n        if (a == NULL)\n            goto error;\n        PyTuple_SET_ITEM(py_args, i, a);\n    }\n\n    py_res = PyEval_CallObject(py_ob, py_args);\n    if (py_res == NULL)\n        goto error;\n    if (convert_from_object_fficallback(result, SIGNATURE(1), py_res) < 0) {\n        extra_error_line = \"Trying to convert the result back to C:\\n\";\n        goto error;\n    }\n done:\n    Py_XDECREF(py_args);\n    Py_XDECREF(py_res);\n    Py_DECREF(cb_args);\n#ifdef WITH_THREAD\n    PyGILState_Release(state);\n#endif\n    restore_errno();\n    return;\n\n error:\n    _my_PyErr_WriteUnraisable(py_ob, extra_error_line);\n    if (SIGNATURE(1)->ct_size > 0) {\n        py_rawerr = PyTuple_GET_ITEM(cb_args, 2);\n        memcpy(result, PyBytes_AS_STRING(py_rawerr),\n                       PyBytes_GET_SIZE(py_rawerr));\n    }\n    goto done;\n    }\n\n#undef SIGNATURE\n}\n\nstatic PyObject *b_callback(PyObject *self, PyObject *args)\n{\n    CTypeDescrObject *ct, *ctresult;\n    CDataObject *cd;\n    PyObject *ob, *error_ob = Py_None;\n    PyObject *py_rawerr, *infotuple = NULL;\n    cif_description_t *cif_descr;\n    ffi_closure *closure;\n    Py_ssize_t size;\n\n    if (!PyArg_ParseTuple(args, \"O!O|O:callback\", &CTypeDescr_Type, &ct, &ob,\n                          &error_ob))\n        return NULL;\n\n    if (!(ct->ct_flags & CT_FUNCTIONPTR)) {\n        PyErr_Format(PyExc_TypeError, \"expected a function ctype, got '%s'\",\n                     ct->ct_name);\n        return NULL;\n    }\n    if (!PyCallable_Check(ob)) {\n        PyErr_Format(PyExc_TypeError,\n                     \"expected a callable object, not %.200s\",\n                     Py_TYPE(ob)->tp_name);\n        return NULL;\n    }\n\n    ctresult = (CTypeDescrObject *)PyTuple_GET_ITEM(ct->ct_stuff, 1);\n    size = ctresult->ct_size;\n    if (size < (Py_ssize_t)sizeof(ffi_arg))\n        size = sizeof(ffi_arg);\n    py_rawerr = PyBytes_FromStringAndSize(NULL, size);\n    if (py_rawerr == NULL)\n        return NULL;\n    memset(PyBytes_AS_STRING(py_rawerr), 0, size);\n    if (error_ob != Py_None) {\n        if (convert_from_object_fficallback(\n                PyBytes_AS_STRING(py_rawerr), ctresult, error_ob) < 0) {\n            Py_DECREF(py_rawerr);\n            return NULL;\n        }\n    }\n    infotuple = Py_BuildValue(\"OOO\", ct, ob, py_rawerr);\n    Py_DECREF(py_rawerr);\n    if (infotuple == NULL)\n        return NULL;\n\n    closure = cffi_closure_alloc();\n\n    cd = PyObject_GC_New(CDataObject, &CDataOwningGC_Type);\n    if (cd == NULL)\n        goto error;\n    Py_INCREF(ct);\n    cd->c_type = ct;\n    cd->c_data = (char *)closure;\n    cd->c_weakreflist = NULL;\n    PyObject_GC_Track(cd);\n\n    cif_descr = (cif_description_t *)ct->ct_extra;\n    if (cif_descr == NULL) {\n        PyErr_Format(PyExc_NotImplementedError,\n                     \"%s: callback with unsupported argument or \"\n                     \"return type or with '...'\", ct->ct_name);\n        goto error;\n    }\n    if (ffi_prep_closure(closure, &cif_descr->cif,\n                         invoke_callback, infotuple) != FFI_OK) {\n        PyErr_SetString(PyExc_SystemError,\n                        \"libffi failed to build this callback\");\n        goto error;\n    }\n    assert(closure->user_data == infotuple);\n#ifdef WITH_THREAD\n    PyEval_InitThreads();\n#endif\n    return (PyObject *)cd;\n\n error:\n    closure->user_data = NULL;\n    if (cd == NULL)\n        cffi_closure_free(closure);\n    else\n        Py_DECREF(cd);\n    Py_XDECREF(infotuple);\n    return NULL;\n}\n\nstatic PyObject *b_new_enum_type(PyObject *self, PyObject *args)\n{\n    char *ename;\n    PyObject *enumerators, *enumvalues;\n    PyObject *dict1 = NULL, *dict2 = NULL, *combined = NULL, *tmpkey = NULL;\n    int name_size;\n    CTypeDescrObject *td, *basetd;\n    Py_ssize_t i, n;\n\n    if (!PyArg_ParseTuple(args, \"sO!O!O!:new_enum_type\",\n                          &ename,\n                          &PyTuple_Type, &enumerators,\n                          &PyTuple_Type, &enumvalues,\n                          &CTypeDescr_Type, &basetd))\n        return NULL;\n\n    n = PyTuple_GET_SIZE(enumerators);\n    if (n != PyTuple_GET_SIZE(enumvalues)) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"tuple args must have the same size\");\n        return NULL;\n    }\n\n    if (!(basetd->ct_flags & (CT_PRIMITIVE_SIGNED|CT_PRIMITIVE_UNSIGNED))) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"expected a primitive signed or unsigned base type\");\n        return NULL;\n    }\n\n    dict1 = PyDict_New();\n    if (dict1 == NULL)\n        goto error;\n    dict2 = PyDict_New();\n    if (dict2 == NULL)\n        goto error;\n\n    for (i=n; --i >= 0; ) {\n        long long lvalue;\n        PyObject *value = PyTuple_GET_ITEM(enumvalues, i);\n        tmpkey = PyTuple_GET_ITEM(enumerators, i);\n        Py_INCREF(tmpkey);\n        if (!PyText_Check(tmpkey)) {\n#if PY_MAJOR_VERSION < 3\n            if (PyUnicode_Check(tmpkey)) {\n                char *text = PyText_AsUTF8(tmpkey);\n                if (text == NULL)\n                    goto error;\n                Py_DECREF(tmpkey);\n                tmpkey = PyString_FromString(text);\n                if (tmpkey == NULL)\n                    goto error;\n            }\n            else\n#endif\n            {\n                PyErr_SetString(PyExc_TypeError,\n                                \"enumerators must be a list of strings\");\n                goto error;\n            }\n        }\n        if (convert_from_object((char*)&lvalue, basetd, value) < 0)\n            goto error;     /* out-of-range or badly typed 'value' */\n        if (PyDict_SetItem(dict1, tmpkey, value) < 0)\n            goto error;\n        if (PyDict_SetItem(dict2, value, tmpkey) < 0)\n            goto error;\n        Py_DECREF(tmpkey);\n        tmpkey = NULL;\n    }\n\n    combined = PyTuple_Pack(2, dict1, dict2);\n    if (combined == NULL)\n        goto error;\n\n    Py_CLEAR(dict2);\n    Py_CLEAR(dict1);\n\n    name_size = strlen(ename) + 1;\n    td = ctypedescr_new(name_size);\n    if (td == NULL)\n        goto error;\n\n    memcpy(td->ct_name, ename, name_size);\n    td->ct_stuff = combined;\n    td->ct_size = basetd->ct_size;\n    td->ct_length = basetd->ct_length;   /* alignment */\n    td->ct_extra = basetd->ct_extra;     /* ffi type  */\n    td->ct_flags = basetd->ct_flags | CT_IS_ENUM;\n    td->ct_name_position = name_size - 1;\n    return (PyObject *)td;\n\n error:\n    Py_XDECREF(tmpkey);\n    Py_XDECREF(combined);\n    Py_XDECREF(dict2);\n    Py_XDECREF(dict1);\n    return NULL;\n}\n\nstatic PyObject *b_alignof(PyObject *self, PyObject *arg)\n{\n    int align;\n    if (!CTypeDescr_Check(arg)) {\n        PyErr_SetString(PyExc_TypeError, \"expected a 'ctype' object\");\n        return NULL;\n    }\n    align = get_alignment((CTypeDescrObject *)arg);\n    if (align < 0)\n        return NULL;\n    return PyInt_FromLong(align);\n}\n\nstatic PyObject *b_sizeof(PyObject *self, PyObject *arg)\n{\n    Py_ssize_t size;\n\n    if (CData_Check(arg)) {\n        CDataObject *cd = (CDataObject *)arg;\n\n        if (cd->c_type->ct_flags & CT_ARRAY)\n            size = get_array_length(cd) * cd->c_type->ct_itemdescr->ct_size;\n        else\n            size = cd->c_type->ct_size;\n    }\n    else if (CTypeDescr_Check(arg)) {\n        size = ((CTypeDescrObject *)arg)->ct_size;\n        if (size < 0) {\n            PyErr_Format(PyExc_ValueError, \"ctype '%s' is of unknown size\",\n                         ((CTypeDescrObject *)arg)->ct_name);\n            return NULL;\n        }\n    }\n    else {\n        PyErr_SetString(PyExc_TypeError,\n                        \"expected a 'cdata' or 'ctype' object\");\n        return NULL;\n    }\n    return PyInt_FromSsize_t(size);\n}\n\nstatic PyObject *b_typeof(PyObject *self, PyObject *arg)\n{\n    PyObject *res;\n\n    if (!CData_Check(arg)) {\n        PyErr_SetString(PyExc_TypeError, \"expected a 'cdata' object\");\n        return NULL;\n    }\n    res = (PyObject *)((CDataObject *)arg)->c_type;\n    Py_INCREF(res);\n    return res;\n}\n\nstatic CTypeDescrObject *direct_typeoffsetof(CTypeDescrObject *ct,\n                                             PyObject *fieldname,\n                                             int following, Py_ssize_t *offset)\n{\n    /* Does not return a new reference! */\n    CTypeDescrObject *res;\n    CFieldObject *cf;\n\n    if (PyTextAny_Check(fieldname)) {\n        if (!following && (ct->ct_flags & CT_POINTER))\n            ct = ct->ct_itemdescr;\n        if (!(ct->ct_flags & (CT_STRUCT|CT_UNION))) {\n            PyErr_SetString(PyExc_TypeError,\n                            \"with a field name argument, expected a \"\n                            \"struct or union ctype\");\n            return NULL;\n        }\n        if (force_lazy_struct(ct) <= 0) {\n            if (!PyErr_Occurred())\n                PyErr_SetString(PyExc_TypeError, \"struct/union is opaque\");\n            return NULL;\n        }\n        cf = (CFieldObject *)PyDict_GetItem(ct->ct_stuff, fieldname);\n        if (cf == NULL) {\n            PyErr_SetObject(PyExc_KeyError, fieldname);\n            return NULL;\n        }\n        if (cf->cf_bitshift >= 0) {\n            PyErr_SetString(PyExc_TypeError, \"not supported for bitfields\");\n            return NULL;\n        }\n        res = cf->cf_type;\n        *offset = cf->cf_offset;\n    }\n    else {\n        ssize_t index = PyInt_AsSsize_t(fieldname);\n        if (index < 0 && PyErr_Occurred()) {\n            PyErr_SetString(PyExc_TypeError,\n                            \"field name or array index expected\");\n            return NULL;\n        }\n\n        if (!(ct->ct_flags & (CT_ARRAY|CT_POINTER)) ||\n                ct->ct_itemdescr->ct_size < 0) {\n            PyErr_SetString(PyExc_TypeError, \"with an integer argument, \"\n                                             \"expected an array ctype or a \"\n                                             \"pointer to non-opaque\");\n            return NULL;\n        }\n        res = ct->ct_itemdescr;\n        *offset = index * ct->ct_itemdescr->ct_size;\n        if ((*offset / ct->ct_itemdescr->ct_size) != index) {\n            PyErr_SetString(PyExc_OverflowError,\n                            \"array offset would overflow a Py_ssize_t\");\n            return NULL;\n        }\n    }\n    return res;\n}\n\nstatic PyObject *b_typeoffsetof(PyObject *self, PyObject *args)\n{\n    PyObject *res, *fieldname;\n    CTypeDescrObject *ct;\n    Py_ssize_t offset;\n    int following = 0;\n\n    if (!PyArg_ParseTuple(args, \"O!O|i:typeoffsetof\",\n                          &CTypeDescr_Type, &ct, &fieldname, &following))\n        return NULL;\n\n    res = (PyObject *)direct_typeoffsetof(ct, fieldname, following, &offset);\n    if (res == NULL)\n        return NULL;\n\n    return Py_BuildValue(\"(On)\", res, offset);\n}\n\nstatic PyObject *b_rawaddressof(PyObject *self, PyObject *args)\n{\n    CTypeDescrObject *ct;\n    CDataObject *cd;\n    Py_ssize_t offset;\n    int accepted_flags;\n\n    if (!PyArg_ParseTuple(args, \"O!O!n:rawaddressof\",\n                          &CTypeDescr_Type, &ct,\n                          &CData_Type, &cd,\n                          &offset))\n        return NULL;\n\n    accepted_flags = CT_STRUCT | CT_UNION | CT_ARRAY | CT_POINTER;\n    if ((cd->c_type->ct_flags & accepted_flags) == 0) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"expected a cdata struct/union/array/pointer object\");\n        return NULL;\n    }\n    if ((ct->ct_flags & CT_POINTER) == 0) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"expected a pointer ctype\");\n        return NULL;\n    }\n    return new_simple_cdata(cd->c_data + offset, ct);\n}\n\nstatic PyObject *b_getcname(PyObject *self, PyObject *args)\n{\n    CTypeDescrObject *ct;\n    char *replace_with, *p, *s;\n    Py_ssize_t namelen, replacelen;\n\n    if (!PyArg_ParseTuple(args, \"O!s:getcname\",\n                          &CTypeDescr_Type, &ct, &replace_with))\n        return NULL;\n\n    namelen = strlen(ct->ct_name);\n    replacelen = strlen(replace_with);\n    s = p = alloca(namelen + replacelen + 1);\n    memcpy(p, ct->ct_name, ct->ct_name_position);\n    p += ct->ct_name_position;\n    memcpy(p, replace_with, replacelen);\n    p += replacelen;\n    memcpy(p, ct->ct_name + ct->ct_name_position,\n           namelen - ct->ct_name_position);\n\n    return PyText_FromStringAndSize(s, namelen + replacelen);\n}\n\nstatic PyObject *b_string(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    CDataObject *cd;\n    Py_ssize_t maxlen = -1;\n    static char *keywords[] = {\"cdata\", \"maxlen\", NULL};\n\n    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"O!|n:string\", keywords,\n                                     &CData_Type, &cd, &maxlen))\n        return NULL;\n\n    if (cd->c_type->ct_itemdescr != NULL &&\n        cd->c_type->ct_itemdescr->ct_flags & (CT_PRIMITIVE_CHAR |\n                                              CT_PRIMITIVE_SIGNED |\n                                              CT_PRIMITIVE_UNSIGNED)) {\n        Py_ssize_t length = maxlen;\n        if (cd->c_data == NULL) {\n            PyObject *s = cdata_repr(cd);\n            if (s != NULL) {\n                PyErr_Format(PyExc_RuntimeError,\n                             \"cannot use string() on %s\",\n                             PyText_AS_UTF8(s));\n                Py_DECREF(s);\n            }\n            return NULL;\n        }\n        if (length < 0 && cd->c_type->ct_flags & CT_ARRAY) {\n            length = get_array_length(cd);\n        }\n        if (cd->c_type->ct_itemdescr->ct_size == sizeof(char)) {\n            const char *start = cd->c_data;\n            if (length < 0) {\n                /*READ(start, 1)*/\n                length = strlen(start);\n                /*READ(start, length)*/\n            }\n            else {\n                const char *end;\n                /*READ(start, length)*/\n                end = (const char *)memchr(start, 0, length);\n                if (end != NULL)\n                    length = end - start;\n            }\n            return PyBytes_FromStringAndSize(start, length);\n        }\n#ifdef HAVE_WCHAR_H\n        else if (cd->c_type->ct_itemdescr->ct_flags & CT_PRIMITIVE_CHAR) {\n            const wchar_t *start = (wchar_t *)cd->c_data;\n            assert(cd->c_type->ct_itemdescr->ct_size == sizeof(wchar_t));\n            if (length < 0) {\n                /*READ(start, sizeof(wchar_t))*/\n                length = 0;\n                while (start[length])\n                    length++;\n                /*READ(start, sizeof(wchar_t) * length)*/\n            }\n            else {\n                /*READ(start, sizeof(wchar_t) * length)*/\n                maxlen = length;\n                length = 0;\n                while (length < maxlen && start[length])\n                    length++;\n            }\n            return _my_PyUnicode_FromWideChar(start, length);\n        }\n#endif\n    }\n    else if (cd->c_type->ct_flags & CT_IS_ENUM) {\n        return convert_cdata_to_enum_string(cd, 0);\n    }\n    else if (cd->c_type->ct_flags & CT_IS_BOOL) {\n        /* fall through to TypeError */\n    }\n    else if (cd->c_type->ct_flags & (CT_PRIMITIVE_CHAR |\n                                     CT_PRIMITIVE_SIGNED |\n                                     CT_PRIMITIVE_UNSIGNED)) {\n        /*READ(cd->c_data, cd->c_type->ct_size)*/\n        if (cd->c_type->ct_size == sizeof(char))\n            return PyBytes_FromStringAndSize(cd->c_data, 1);\n#ifdef HAVE_WCHAR_H\n        else if (cd->c_type->ct_flags & CT_PRIMITIVE_CHAR) {\n            assert(cd->c_type->ct_size == sizeof(wchar_t));\n            return _my_PyUnicode_FromWideChar((wchar_t *)cd->c_data, 1);\n        }\n#endif\n    }\n    PyErr_Format(PyExc_TypeError, \"string(): unexpected cdata '%s' argument\",\n                 cd->c_type->ct_name);\n    return NULL;\n}\n\nstatic PyObject *b_buffer(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    CDataObject *cd;\n    Py_ssize_t size = -1;\n    static char *keywords[] = {\"cdata\", \"size\", NULL};\n\n    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"O!|n:buffer\", keywords,\n                                     &CData_Type, &cd, &size))\n        return NULL;\n\n    if (cd->c_type->ct_flags & CT_POINTER) {\n        if (size < 0)\n            size = cd->c_type->ct_itemdescr->ct_size;\n    }\n    else if (cd->c_type->ct_flags & CT_ARRAY) {\n        if (size < 0)\n            size = get_array_length(cd) * cd->c_type->ct_itemdescr->ct_size;\n    }\n    else {\n        PyErr_Format(PyExc_TypeError,\n                     \"expected a pointer or array cdata, got '%s'\",\n                     cd->c_type->ct_name);\n        return NULL;\n    }\n    if (size < 0) {\n        PyErr_Format(PyExc_TypeError,\n                     \"don't know the size pointed to by '%s'\",\n                     cd->c_type->ct_name);\n        return NULL;\n    }\n    /*WRITE(cd->c_data, size)*/\n    return minibuffer_new(cd->c_data, size, (PyObject *)cd);\n}\n\nstatic PyObject *b_get_errno(PyObject *self, PyObject *noarg)\n{\n    int err;\n    restore_errno_only();\n    err = errno;\n    errno = 0;\n    return PyInt_FromLong(err);\n}\n\nstatic PyObject *b_set_errno(PyObject *self, PyObject *arg)\n{\n    long ival = PyInt_AsLong(arg);\n    if (ival == -1 && PyErr_Occurred())\n        return NULL;\n    else if (ival < INT_MIN || ival > INT_MAX) {\n        PyErr_SetString(PyExc_OverflowError, \"errno value too large\");\n        return NULL;\n    }\n    errno = (int)ival;\n    save_errno_only();\n    errno = 0;\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nstatic PyObject *b_newp_handle(PyObject *self, PyObject *args)\n{\n    CTypeDescrObject *ct;\n    CDataObject *cd;\n    PyObject *x;\n    if (!PyArg_ParseTuple(args, \"O!O\", &CTypeDescr_Type, &ct, &x))\n        return NULL;\n\n    if (!(ct->ct_flags & CT_IS_VOID_PTR)) {\n        PyErr_Format(PyExc_TypeError, \"needs 'void *', got '%s'\", ct->ct_name);\n        return NULL;\n    }\n\n    cd = (CDataObject *)PyObject_GC_New(CDataObject, &CDataOwningGC_Type);\n    if (cd == NULL)\n        return NULL;\n    Py_INCREF(ct);\n    cd->c_type = ct;\n    Py_INCREF(x);\n    cd->c_data = ((char *)x) - 42;\n    cd->c_weakreflist = NULL;\n    PyObject_GC_Track(cd);\n    return (PyObject *)cd;\n}\n\nstatic PyObject *b_from_handle(PyObject *self, PyObject *arg)\n{\n    CTypeDescrObject *ct;\n    char *raw;\n    PyObject *x;\n    if (!CData_Check(arg)) {\n        PyErr_SetString(PyExc_TypeError, \"expected a 'cdata' object\");\n        return NULL;\n    }\n    ct = ((CDataObject *)arg)->c_type;\n    raw = ((CDataObject *)arg)->c_data;\n    if (!(ct->ct_flags & CT_CAST_ANYTHING)) {\n        PyErr_Format(PyExc_TypeError,\n                     \"expected a 'cdata' object with a 'void *' out of \"\n                     \"new_handle(), got '%s'\", ct->ct_name);\n        return NULL;\n    }\n    if (!raw) {\n        PyErr_SetString(PyExc_RuntimeError,\n                        \"cannot use from_handle() on NULL pointer\");\n        return NULL;\n    }\n    x = (PyObject *)(raw + 42);\n    if (Py_REFCNT(x) <= 0) {\n        Py_FatalError(\"ffi.from_handle() detected that the address passed \"\n                      \"points to garbage. If it is really the result of \"\n                      \"ffi.new_handle(), then the Python object has already \"\n                      \"been garbage collected\");\n    }\n    Py_INCREF(x);\n    return x;\n}\n\nstatic int _my_PyObject_GetContiguousBuffer(PyObject *x, Py_buffer *view)\n{\n#if PY_MAJOR_VERSION < 3\n    /* Some objects only support the buffer interface and CPython doesn't\n       translate it into the memoryview interface, mess.  Hack a very\n       minimal content for 'view'.  Don't care if the other fields are\n       uninitialized: we only call PyBuffer_Release(), which only reads\n       'view->obj'. */\n    PyBufferProcs *pb = x->ob_type->tp_as_buffer;\n    if (pb && !pb->bf_releasebuffer) {\n        /* we used to try all three in some vaguely sensible order,\n           i.e. first the write.  But trying to call the write on a\n           read-only buffer fails with TypeError.  So we use a less-\n           sensible order now.  See test_from_buffer_more_cases. */\n        readbufferproc proc = (readbufferproc)pb->bf_getreadbuffer;\n        if (!proc)     proc = (readbufferproc)pb->bf_getcharbuffer;\n        if (!proc)     proc = (readbufferproc)pb->bf_getwritebuffer;\n        if (proc && pb->bf_getsegcount) {\n            if ((*pb->bf_getsegcount)(x, NULL) != 1) {\n                PyErr_SetString(PyExc_TypeError,\n                                \"expected a single-segment buffer object\");\n                return -1;\n            }\n            view->len = (*proc)(x, 0, &view->buf);\n            if (view->len < 0)\n                return -1;\n            view->obj = x;\n            Py_INCREF(x);\n            return 0;\n        }\n    }\n#endif\n\n    if (PyObject_GetBuffer(x, view, PyBUF_SIMPLE) < 0)\n        return -1;\n\n    if (!PyBuffer_IsContiguous(view, 'A')) {\n        PyBuffer_Release(view);\n        PyErr_SetString(PyExc_TypeError, \"contiguous buffer expected\");\n        return -1;\n    }\n    return 0;\n}\n\nstatic int invalid_input_buffer_type(PyObject *x)\n{\n#if PY_MAJOR_VERSION < 3\n    if (PyBuffer_Check(x)) {\n        /* XXX fish fish fish in an inofficial way */\n        typedef struct {\n            PyObject_HEAD\n            PyObject *b_base;\n        } _my_PyBufferObject;\n\n        _my_PyBufferObject *b = (_my_PyBufferObject *)x;\n        x = b->b_base;\n        if (x == NULL)\n            return 0;\n    }\n    else\n#endif\n#if PY_MAJOR_VERSION > 2 || PY_MINOR_VERSION > 6\n    if (PyMemoryView_Check(x)) {\n        x = PyMemoryView_GET_BASE(x);\n        if (x == NULL)\n            return 0;\n    }\n    else\n#endif\n        ;\n\n    if (PyBytes_Check(x) || PyUnicode_Check(x))\n        return 1;\n    if (PyByteArray_Check(x)) /* <= this one here for PyPy compatibility */\n        return 1;\n    return 0;\n}\n\nstatic PyObject *direct_from_buffer(CTypeDescrObject *ct, PyObject *x)\n{\n    CDataObject *cd;\n    Py_buffer *view;\n\n    if (invalid_input_buffer_type(x)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"from_buffer() cannot return the address of the \"\n                        \"raw string within a \"STR_OR_BYTES\" or unicode or \"\n                        \"bytearray object\");\n        return NULL;\n    }\n\n    view = PyObject_Malloc(sizeof(Py_buffer));\n    if (_my_PyObject_GetContiguousBuffer(x, view) < 0)\n        goto error1;\n\n    cd = (CDataObject *)PyObject_GC_New(CDataObject_owngc_frombuf,\n                                        &CDataOwningGC_Type);\n    if (cd == NULL)\n        goto error2;\n\n    Py_INCREF(ct);\n    cd->c_type = ct;\n    cd->c_data = view->buf;\n    cd->c_weakreflist = NULL;\n    ((CDataObject_owngc_frombuf *)cd)->length = view->len;\n    ((CDataObject_owngc_frombuf *)cd)->bufferview = view;\n    PyObject_GC_Track(cd);\n    return (PyObject *)cd;\n\n error2:\n    PyBuffer_Release(view);\n error1:\n    PyObject_Free(view);\n    return NULL;\n}\n\nstatic PyObject *b_from_buffer(PyObject *self, PyObject *args)\n{\n    CTypeDescrObject *ct;\n    PyObject *x;\n\n    if (!PyArg_ParseTuple(args, \"O!O\", &CTypeDescr_Type, &ct, &x))\n        return NULL;\n\n    if (!(ct->ct_flags & CT_IS_UNSIZED_CHAR_A)) {\n        PyErr_Format(PyExc_TypeError, \"needs 'char[]', got '%s'\", ct->ct_name);\n        return NULL;\n    }\n    return direct_from_buffer(ct, x);\n}\n\nstatic PyObject *b__get_types(PyObject *self, PyObject *noarg)\n{\n    return PyTuple_Pack(2, (PyObject *)&CData_Type,\n                           (PyObject *)&CTypeDescr_Type);\n}\n\n/************************************************************/\n\nstatic char _testfunc0(char a, char b)\n{\n    return a + b;\n}\nstatic long _testfunc1(int a, long b)\n{\n    return (long)a + b;\n}\nstatic PY_LONG_LONG _testfunc2(PY_LONG_LONG a, PY_LONG_LONG b)\n{\n    return a + b;\n}\nstatic double _testfunc3(float a, double b)\n{\n    return a + b;\n}\nstatic float _testfunc4(float a, double b)\n{\n    return (float)(a + b);\n}\nstatic void _testfunc5(void)\n{\n    errno = errno + 15;\n}\nstatic int *_testfunc6(int *x)\n{\n    static int y;\n    y = *x - 1000;\n    return &y;\n}\nstruct _testfunc7_s { unsigned char a1; short a2; };\nstatic short _testfunc7(struct _testfunc7_s inlined)\n{\n    return inlined.a1 + inlined.a2;\n}\nstatic int _testfunc9(int num, ...)\n{\n    va_list vargs;\n    int i, total = 0;\n    va_start(vargs, num);\n    for (i=0; i<num; i++) {\n        int value = va_arg(vargs, int);\n        if (value == 0)\n            value = -66666666;\n        total += value;\n    }\n    va_end(vargs);\n    return total;\n}\n\nstatic struct _testfunc7_s _testfunc10(int n)\n{\n    struct _testfunc7_s result;\n    result.a1 = n;\n    result.a2 = n * n;\n    return result;\n}\n\nstruct _testfunc11_s { int a1, a2; };\nstatic struct _testfunc11_s _testfunc11(int n)\n{\n    struct _testfunc11_s result;\n    result.a1 = n;\n    result.a2 = n * n;\n    return result;\n}\n\nstruct _testfunc12_s { double a1; };\nstatic struct _testfunc12_s _testfunc12(int n)\n{\n    struct _testfunc12_s result;\n    result.a1 = n;\n    return result;\n}\n\nstruct _testfunc13_s { int a1, a2, a3; };\nstatic struct _testfunc13_s _testfunc13(int n)\n{\n    struct _testfunc13_s result;\n    result.a1 = n;\n    result.a2 = n * n;\n    result.a3 = n * n * n;\n    return result;\n}\n\nstruct _testfunc14_s { float a1; };\nstatic struct _testfunc14_s _testfunc14(int n)\n{\n    struct _testfunc14_s result;\n    result.a1 = (float)n;\n    return result;\n}\n\nstruct _testfunc15_s { float a1; int a2; };\nstatic struct _testfunc15_s _testfunc15(int n)\n{\n    struct _testfunc15_s result;\n    result.a1 = (float)n;\n    result.a2 = n * n;\n    return result;\n}\n\nstruct _testfunc16_s { float a1, a2; };\nstatic struct _testfunc16_s _testfunc16(int n)\n{\n    struct _testfunc16_s result;\n    result.a1 = (float)n;\n    result.a2 = -(float)n;\n    return result;\n}\n\nstruct _testfunc17_s { int a1; float a2; };\nstatic struct _testfunc17_s _testfunc17(int n)\n{\n    struct _testfunc17_s result;\n    result.a1 = n;\n    result.a2 = (float)n * (float)n;\n    return result;\n}\n\nstatic int _testfunc18(struct _testfunc17_s *ptr)\n{\n    return ptr->a1 + (int)ptr->a2;\n}\n\nstatic long double _testfunc19(long double x, int count)\n{\n    int i;\n    for (i=0; i<count; i++) {\n        x = 4*x - x*x;\n    }\n    return x;\n}\n\nstatic short _testfunc20(struct _testfunc7_s *ptr)\n{\n    return ptr->a1 + ptr->a2;\n}\n\nstruct _testfunc21_s { int a, b, c, d, e, f, g, h, i, j; };\nstatic int _testfunc21(struct _testfunc21_s inlined)\n{\n    return ((inlined.a << 0) +\n            (inlined.b << 1) +\n            (inlined.c << 2) +\n            (inlined.d << 3) +\n            (inlined.e << 4) +\n            (inlined.f << 5) +\n            (inlined.g << 6) +\n            (inlined.h << 7) +\n            (inlined.i << 8) +\n            (inlined.j << 9));\n}\n\nstruct _testfunc22_s { int a[10]; };\nstatic struct _testfunc22_s _testfunc22(struct _testfunc22_s s1,\n                                        struct _testfunc22_s s2)\n{\n    struct _testfunc22_s result;\n    int i;\n    for (i=0; i<10; i++)\n        result.a[i] = s1.a[i] - s2.a[i];\n    return result;\n}\n\nstatic int _testfunc23(char *p)\n{\n    if (p)\n        return 1000 * p[0];\n    return -42;\n}\n\nstatic PyObject *b__testfunc(PyObject *self, PyObject *args)\n{\n    /* for testing only */\n    int i;\n    void *f;\n    if (!PyArg_ParseTuple(args, \"i:_testfunc\", &i))\n        return NULL;\n    switch (i) {\n    case 0: f = &_testfunc0; break;\n    case 1: f = &_testfunc1; break;\n    case 2: f = &_testfunc2; break;\n    case 3: f = &_testfunc3; break;\n    case 4: f = &_testfunc4; break;\n    case 5: f = &_testfunc5; break;\n    case 6: f = &_testfunc6; break;\n    case 7: f = &_testfunc7; break;\n    case 8: f = stderr; break;\n    case 9: f = &_testfunc9; break;\n    case 10: f = &_testfunc10; break;\n    case 11: f = &_testfunc11; break;\n    case 12: f = &_testfunc12; break;\n    case 13: f = &_testfunc13; break;\n    case 14: f = &_testfunc14; break;\n    case 15: f = &_testfunc15; break;\n    case 16: f = &_testfunc16; break;\n    case 17: f = &_testfunc17; break;\n    case 18: f = &_testfunc18; break;\n    case 19: f = &_testfunc19; break;\n    case 20: f = &_testfunc20; break;\n    case 21: f = &_testfunc21; break;\n    case 22: f = &_testfunc22; break;\n    case 23: f = &_testfunc23; break;\n    default:\n        PyErr_SetNone(PyExc_ValueError);\n        return NULL;\n    }\n    return PyLong_FromVoidPtr(f);\n}\n\n#if PY_MAJOR_VERSION < 3\nstatic Py_ssize_t _test_segcountproc(PyObject *o, Py_ssize_t *ignored)\n{\n    return 1;\n}\nstatic Py_ssize_t _test_getreadbuf(PyObject *o, Py_ssize_t i, void **r)\n{\n    static char buf[] = \"RDB\";\n    *r = buf;\n    return 3;\n}\nstatic Py_ssize_t _test_getwritebuf(PyObject *o, Py_ssize_t i, void **r)\n{\n    static char buf[] = \"WRB\";\n    *r = buf;\n    return 3;\n}\nstatic Py_ssize_t _test_getcharbuf(PyObject *o, Py_ssize_t i, char **r)\n{\n    static char buf[] = \"CHB\";\n    *r = buf;\n    return 3;\n}\n#endif\nstatic int _test_getbuf(PyObject *self, Py_buffer *view, int flags)\n{\n    static char buf[] = \"GTB\";\n    return PyBuffer_FillInfo(view, self, buf, 3, /*readonly=*/0, flags);\n}\nstatic int _test_getbuf_ro(PyObject *self, Py_buffer *view, int flags)\n{\n    static char buf[] = \"ROB\";\n    return PyBuffer_FillInfo(view, self, buf, 3, /*readonly=*/1, flags);\n}\n\n\nstatic PyObject *b__testbuff(PyObject *self, PyObject *args)\n{\n    /* for testing only */\n    int methods;\n    PyTypeObject *obj;\n    if (!PyArg_ParseTuple(args, \"O!i|_testbuff\", &PyType_Type, &obj, &methods))\n        return NULL;\n\n    assert(obj->tp_as_buffer != NULL);\n\n#if PY_MAJOR_VERSION < 3\n    obj->tp_as_buffer->bf_getsegcount = &_test_segcountproc;\n    obj->tp_flags |= Py_TPFLAGS_HAVE_GETCHARBUFFER;\n    obj->tp_flags |= Py_TPFLAGS_HAVE_NEWBUFFER;\n    if (methods & 1)  obj->tp_as_buffer->bf_getreadbuffer  = &_test_getreadbuf;\n    if (methods & 2)  obj->tp_as_buffer->bf_getwritebuffer = &_test_getwritebuf;\n    if (methods & 4)  obj->tp_as_buffer->bf_getcharbuffer  = &_test_getcharbuf;\n#endif\n    if (methods & 8)  obj->tp_as_buffer->bf_getbuffer      = &_test_getbuf;\n    if (methods & 16) obj->tp_as_buffer->bf_getbuffer      = &_test_getbuf_ro;\n\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nstatic PyObject *b_init_cffi_1_0_external_module(PyObject *, PyObject *);\n/* forward, see cffi1_module.c */\n\n\nstatic PyMethodDef FFIBackendMethods[] = {\n    {\"load_library\", b_load_library, METH_VARARGS},\n    {\"new_primitive_type\", b_new_primitive_type, METH_VARARGS},\n    {\"new_pointer_type\", b_new_pointer_type, METH_VARARGS},\n    {\"new_array_type\", b_new_array_type, METH_VARARGS},\n    {\"new_void_type\", b_new_void_type, METH_NOARGS},\n    {\"new_struct_type\", b_new_struct_type, METH_VARARGS},\n    {\"new_union_type\", b_new_union_type, METH_VARARGS},\n    {\"complete_struct_or_union\", b_complete_struct_or_union, METH_VARARGS},\n    {\"new_function_type\", b_new_function_type, METH_VARARGS},\n    {\"new_enum_type\", b_new_enum_type, METH_VARARGS},\n    {\"newp\", b_newp, METH_VARARGS},\n    {\"cast\", b_cast, METH_VARARGS},\n    {\"callback\", b_callback, METH_VARARGS},\n    {\"alignof\", b_alignof, METH_O},\n    {\"sizeof\", b_sizeof, METH_O},\n    {\"typeof\", b_typeof, METH_O},\n    {\"typeoffsetof\", b_typeoffsetof, METH_VARARGS},\n    {\"rawaddressof\", b_rawaddressof, METH_VARARGS},\n    {\"getcname\", b_getcname, METH_VARARGS},\n    {\"string\", (PyCFunction)b_string, METH_VARARGS | METH_KEYWORDS},\n    {\"buffer\", (PyCFunction)b_buffer, METH_VARARGS | METH_KEYWORDS},\n    {\"get_errno\", b_get_errno, METH_NOARGS},\n    {\"set_errno\", b_set_errno, METH_O},\n    {\"newp_handle\", b_newp_handle, METH_VARARGS},\n    {\"from_handle\", b_from_handle, METH_O},\n    {\"from_buffer\", b_from_buffer, METH_VARARGS},\n#ifdef MS_WIN32\n    {\"getwinerror\", (PyCFunction)b_getwinerror, METH_VARARGS | METH_KEYWORDS},\n#endif\n    {\"_get_types\", b__get_types, METH_NOARGS},\n    {\"_testfunc\", b__testfunc, METH_VARARGS},\n    {\"_testbuff\", b__testbuff, METH_VARARGS},\n    {\"_init_cffi_1_0_external_module\", b_init_cffi_1_0_external_module, METH_O},\n    {NULL,     NULL}    /* Sentinel */\n};\n\n/************************************************************/\n/* Functions used by '_cffi_N.so', the generated modules    */\n\n#define _cffi_to_c_SIGNED_FN(RETURNTYPE, SIZE)                          \\\nstatic RETURNTYPE _cffi_to_c_i##SIZE(PyObject *obj) {                   \\\n    PY_LONG_LONG tmp = _my_PyLong_AsLongLong(obj);                      \\\n    if ((tmp > (PY_LONG_LONG)((1ULL<<(SIZE-1)) - 1)) ||                 \\\n        (tmp < (PY_LONG_LONG)(0ULL-(1ULL<<(SIZE-1)))))                  \\\n        if (!PyErr_Occurred())                                          \\\n            return (RETURNTYPE)_convert_overflow(obj, #SIZE \"-bit int\"); \\\n    return (RETURNTYPE)tmp;                                             \\\n}\n\n#define _cffi_to_c_UNSIGNED_FN(RETURNTYPE, SIZE)                        \\\nstatic RETURNTYPE _cffi_to_c_u##SIZE(PyObject *obj) {                   \\\n    unsigned PY_LONG_LONG tmp = _my_PyLong_AsUnsignedLongLong(obj, 1);  \\\n    if (tmp > ~(((unsigned PY_LONG_LONG)-2) << (SIZE-1)))               \\\n        if (!PyErr_Occurred())                                          \\\n            return (RETURNTYPE)_convert_overflow(obj,                   \\\n                                   #SIZE \"-bit unsigned int\");          \\\n    return (RETURNTYPE)tmp;                                             \\\n}\n\n_cffi_to_c_SIGNED_FN(int, 8)\n_cffi_to_c_SIGNED_FN(int, 16)\n_cffi_to_c_SIGNED_FN(int, 32)\n_cffi_to_c_SIGNED_FN(PY_LONG_LONG, 64)\n_cffi_to_c_UNSIGNED_FN(int, 8)\n_cffi_to_c_UNSIGNED_FN(int, 16)\n_cffi_to_c_UNSIGNED_FN(unsigned int, 32)\n_cffi_to_c_UNSIGNED_FN(unsigned PY_LONG_LONG, 64)\n\nstatic PyObject *_cffi_from_c_pointer(char *ptr, CTypeDescrObject *ct)\n{\n    return convert_to_object((char *)&ptr, ct);\n}\n\nstatic char *_cffi_to_c_pointer(PyObject *obj, CTypeDescrObject *ct)\n{\n    char *result;\n    if (convert_from_object((char *)&result, ct, obj) < 0) {\n        if ((ct->ct_flags & CT_POINTER) &&\n                (ct->ct_itemdescr->ct_flags & CT_IS_FILE) &&\n                PyFile_Check(obj)) {\n            PyErr_Clear();\n            return (char *)PyFile_AsFile(obj);\n        }\n        return NULL;\n    }\n    return result;\n}\n\nstatic long double _cffi_to_c_long_double(PyObject *obj)\n{\n    if (CData_Check(obj) &&\n            (((CDataObject *)obj)->c_type->ct_flags & CT_IS_LONGDOUBLE)) {\n        char *data = ((CDataObject *)obj)->c_data;\n        /*READ(data, sizeof(long double))*/\n        return read_raw_longdouble_data(data);\n    }\n    else\n        return PyFloat_AsDouble(obj);\n}\n\nstatic _Bool _cffi_to_c__Bool(PyObject *obj)\n{\n    PY_LONG_LONG tmp = _my_PyLong_AsLongLong(obj);\n    if (tmp == 0)\n        return 0;\n    else if (tmp == 1)\n        return 1;\n    else if (PyErr_Occurred())\n        return (_Bool)-1;\n    else\n        return (_Bool)_convert_overflow(obj, \"_Bool\");\n}\n\nstatic PyObject *_cffi_get_struct_layout(Py_ssize_t nums[])\n{\n    PyObject *result;\n    int count = 0;\n    while (nums[count] >= 0)\n        count++;\n\n    result = PyList_New(count);\n    if (result == NULL)\n        return NULL;\n\n    while (--count >= 0) {\n        PyObject *o = PyInt_FromSsize_t(nums[count]);\n        if (o == NULL) {\n            Py_DECREF(result);\n            return NULL;\n        }\n        PyList_SET_ITEM(result, count, o);\n    }\n    return result;\n}\n\nstatic PyObject *_cffi_from_c_char(char x) {\n    return PyBytes_FromStringAndSize(&x, 1);\n}\n\n#ifdef HAVE_WCHAR_H\nstatic PyObject *_cffi_from_c_wchar_t(wchar_t x) {\n    return _my_PyUnicode_FromWideChar(&x, 1);\n}\n#endif\n\nstatic void *cffi_exports[] = {\n    NULL,\n    _cffi_to_c_i8,\n    _cffi_to_c_u8,\n    _cffi_to_c_i16,\n    _cffi_to_c_u16,\n    _cffi_to_c_i32,\n    _cffi_to_c_u32,\n    _cffi_to_c_i64,\n    _cffi_to_c_u64,\n    _convert_to_char,\n    _cffi_from_c_pointer,\n    _cffi_to_c_pointer,\n    _cffi_get_struct_layout,\n    restore_errno,\n    save_errno,\n    _cffi_from_c_char,\n    convert_to_object,\n    convert_from_object,\n    convert_struct_to_owning_object,\n#ifdef HAVE_WCHAR_H\n    _convert_to_wchar_t,\n    _cffi_from_c_wchar_t,\n#else\n    0,\n    0,\n#endif\n    _cffi_to_c_long_double,\n    _cffi_to_c__Bool,\n    _prepare_pointer_call_argument,\n    convert_array_from_object,\n};\n\nstatic struct { const char *name; int value; } all_dlopen_flags[] = {\n    { \"RTLD_LAZY\",     RTLD_LAZY     },\n    { \"RTLD_NOW\",      RTLD_NOW      },\n    { \"RTLD_GLOBAL\",   RTLD_GLOBAL   },\n#ifdef RTLD_LOCAL\n    { \"RTLD_LOCAL\",    RTLD_LOCAL    },\n#else\n    { \"RTLD_LOCAL\",    0             },\n#endif\n#ifdef RTLD_NODELETE\n    { \"RTLD_NODELETE\", RTLD_NODELETE },\n#endif\n#ifdef RTLD_NOLOAD\n    { \"RTLD_NOLOAD\",   RTLD_NOLOAD   },\n#endif\n#ifdef RTLD_DEEPBIND\n    { \"RTLD_DEEPBIND\", RTLD_DEEPBIND },\n#endif\n    { NULL, 0 }\n};\n\n\n/************************************************************/\n\n#include \"cffi1_module.c\"\n\n/************************************************************/\n\n#if PY_MAJOR_VERSION >= 3\nstatic struct PyModuleDef FFIBackendModuleDef = {\n  PyModuleDef_HEAD_INIT,\n  \"_cffi_backend\",\n  NULL,\n  -1,\n  FFIBackendMethods,\n  NULL, NULL, NULL, NULL\n};\n#define INITERROR return NULL\n\nPyMODINIT_FUNC\nPyInit__cffi_backend(void)\n#else\n#define INITERROR return\n\nPyMODINIT_FUNC\ninit_cffi_backend(void)\n#endif\n{\n    PyObject *m, *v;\n    int i;\n\n    v = PySys_GetObject(\"version\");\n    if (v == NULL || !PyText_Check(v) ||\n            strncmp(PyText_AS_UTF8(v), PY_VERSION, 3) != 0) {\n        PyErr_Format(PyExc_ImportError,\n                     \"this module was compiled for Python %c%c%c\",\n                     PY_VERSION[0], PY_VERSION[1], PY_VERSION[2]);\n        INITERROR;\n    }\n\n#if PY_MAJOR_VERSION >= 3\n    m = PyModule_Create(&FFIBackendModuleDef);\n#else\n    m = Py_InitModule(\"_cffi_backend\", FFIBackendMethods);\n#endif\n\n    if (m == NULL)\n        INITERROR;\n\n    unique_cache = PyDict_New();\n    if (unique_cache == NULL)\n        INITERROR;\n\n    if (PyType_Ready(&dl_type) < 0)\n        INITERROR;\n    if (PyType_Ready(&CTypeDescr_Type) < 0)\n        INITERROR;\n    if (PyType_Ready(&CField_Type) < 0)\n        INITERROR;\n    if (PyType_Ready(&CData_Type) < 0)\n        INITERROR;\n    if (PyType_Ready(&CDataOwning_Type) < 0)\n        INITERROR;\n    if (PyType_Ready(&CDataOwningGC_Type) < 0)\n        INITERROR;\n    if (PyType_Ready(&CDataIter_Type) < 0)\n        INITERROR;\n    if (PyType_Ready(&MiniBuffer_Type) < 0)\n        INITERROR;\n\n    v = PyText_FromString(\"_cffi_backend\");\n    if (v == NULL || PyDict_SetItemString(CData_Type.tp_dict,\n                                          \"__module__\", v) < 0)\n        INITERROR;\n    v = PyText_FromString(\"<cdata>\");\n    if (v == NULL || PyDict_SetItemString(CData_Type.tp_dict,\n                                          \"__name__\", v) < 0)\n        INITERROR;\n\n    /* this is for backward compatibility only */\n    v = PyCapsule_New((void *)cffi_exports, \"cffi\", NULL);\n    if (v == NULL || PyModule_AddObject(m, \"_C_API\", v) < 0)\n        INITERROR;\n\n    v = PyText_FromString(\"1.1.2\");\n    if (v == NULL || PyModule_AddObject(m, \"__version__\", v) < 0)\n        INITERROR;\n\n    if (PyModule_AddIntConstant(m, \"FFI_DEFAULT_ABI\", FFI_DEFAULT_ABI) < 0 ||\n#if defined(MS_WIN32) && !defined(_WIN64)\n        PyModule_AddIntConstant(m, \"FFI_STDCALL\", FFI_STDCALL) < 0 ||\n#endif\n#ifdef FFI_CDECL\n        PyModule_AddIntConstant(m, \"FFI_CDECL\", FFI_CDECL) < 0 ||   /* win32 */\n#else\n        PyModule_AddIntConstant(m, \"FFI_CDECL\", FFI_DEFAULT_ABI) < 0 ||\n#endif\n\n#ifdef MS_WIN32\n#  ifdef _WIN64\n        PyModule_AddIntConstant(m, \"_WIN\", 64) < 0 ||   /* win64 */\n#  else\n        PyModule_AddIntConstant(m, \"_WIN\", 32) < 0 ||   /* win32 */\n#  endif\n#endif\n        0)\n      INITERROR;\n\n    for (i = 0; all_dlopen_flags[i].name != NULL; i++) {\n        if (PyModule_AddIntConstant(m,\n                                    all_dlopen_flags[i].name,\n                                    all_dlopen_flags[i].value) < 0)\n            INITERROR;\n    }\n\n    init_errno();\n\n    if (init_ffi_lib(m) < 0)\n        INITERROR;\n\n#if PY_MAJOR_VERSION >= 3\n    if (init_file_emulator() < 0)\n        INITERROR;\n    return m;\n#endif\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.1.2-nak3eqkxfunb4z5owzsqogchnaejp7o4/spack-src/c/lib_obj.c": "\n/* A Lib object is what is in the \"lib\" attribute of a C extension\n   module originally created by recompile().\n\n   A Lib object is special in the sense that it has a custom\n   __getattr__ which returns C globals, functions and constants.  It\n   raises AttributeError for anything else, even attrs like '__class__'.\n\n   A Lib object has got a reference to the _cffi_type_context_s\n   structure, which is used to create lazily the objects returned by\n   __getattr__.\n*/\n\nstruct CPyExtFunc_s {\n    PyMethodDef md;\n    void *direct_fn;\n    int type_index;\n};\nstatic const char cpyextfunc_doc[] =\n    \"direct call to the C function of the same name\";\n\nstruct LibObject_s {\n    PyObject_HEAD\n    builder_c_t *l_types_builder; /* same as the one on the ffi object */\n    PyObject *l_dict;           /* content, built lazily */\n    PyObject *l_libname;        /* some string that gives the name of the lib */\n    FFIObject *l_ffi;           /* reference back to the ffi object */\n    void *l_libhandle;          /* the dlopen()ed handle, if any */\n};\n\nstatic struct CPyExtFunc_s *_cpyextfunc_get(PyObject *x)\n{\n    struct CPyExtFunc_s *exf;\n\n    if (!PyCFunction_Check(x))\n        return NULL;\n    if (!LibObject_Check(PyCFunction_GET_SELF(x)))\n        return NULL;\n\n    exf = (struct CPyExtFunc_s *)(((PyCFunctionObject *)x) -> m_ml);\n    if (exf->md.ml_doc != cpyextfunc_doc)\n        return NULL;\n\n    return exf;\n}\n\nstatic PyObject *_cpyextfunc_type(LibObject *lib, struct CPyExtFunc_s *exf)\n{\n    PyObject *tuple, *result;\n    tuple = realize_c_type_or_func(lib->l_types_builder,\n                                   lib->l_types_builder->ctx.types,\n                                   exf->type_index);\n    if (tuple == NULL)\n        return NULL;\n\n    /* 'tuple' is a tuple of length 1 containing the real CT_FUNCTIONPTR\n       object */\n    result = PyTuple_GetItem(tuple, 0);\n    Py_XINCREF(result);\n    Py_DECREF(tuple);\n    return result;\n}\n\nstatic PyObject *_cpyextfunc_type_index(PyObject *x)\n{\n    struct CPyExtFunc_s *exf;\n    LibObject *lib;\n\n    assert(PyErr_Occurred());\n    exf = _cpyextfunc_get(x);\n    if (exf == NULL)\n        return NULL;    /* still the same exception is set */\n\n    PyErr_Clear();\n\n    lib = (LibObject *)PyCFunction_GET_SELF(x);\n    return _cpyextfunc_type(lib, exf);\n}\n\nstatic void cdlopen_close_ignore_errors(void *libhandle);  /* forward */\nstatic void *cdlopen_fetch(PyObject *libname, void *libhandle, char *symbol);\n\nstatic void lib_dealloc(LibObject *lib)\n{\n    cdlopen_close_ignore_errors(lib->l_libhandle);\n    Py_DECREF(lib->l_dict);\n    Py_DECREF(lib->l_libname);\n    Py_DECREF(lib->l_ffi);\n    PyObject_Del(lib);\n}\n\nstatic int lib_traverse(LibObject *lib, visitproc visit, void *arg)\n{\n    Py_VISIT(lib->l_dict);\n    Py_VISIT(lib->l_libname);\n    Py_VISIT(lib->l_ffi);\n    return 0;\n}\n\nstatic PyObject *lib_repr(LibObject *lib)\n{\n    return PyText_FromFormat(\"<Lib object for '%.200s'>\",\n                             PyText_AS_UTF8(lib->l_libname));\n}\n\nstatic PyObject *lib_build_cpython_func(LibObject *lib,\n                                        const struct _cffi_global_s *g,\n                                        const char *s, int flags)\n{\n    /* First make sure the argument types and return type are really\n       built.  The C extension code can then assume that they are,\n       by calling _cffi_type().\n    */\n    CTypeDescrObject *ct;\n    struct CPyExtFunc_s *xfunc;\n    int i, type_index = _CFFI_GETARG(g->type_op);\n    _cffi_opcode_t *opcodes = lib->l_types_builder->ctx.types;\n\n    if ((((uintptr_t)opcodes[type_index]) & 1) == 0) {\n        /* the function type was already built.  No need to force\n           the arg and return value to be built again. */\n    }\n    else {\n        assert(_CFFI_GETOP(opcodes[type_index]) == _CFFI_OP_FUNCTION);\n\n        /* return type: */\n        ct = realize_c_type(lib->l_types_builder, opcodes,\n                            _CFFI_GETARG(opcodes[type_index]));\n        if (ct == NULL)\n            return NULL;\n        Py_DECREF(ct);\n\n        /* argument types: */\n        i = type_index + 1;\n        while (_CFFI_GETOP(opcodes[i]) != _CFFI_OP_FUNCTION_END) {\n            ct = realize_c_type(lib->l_types_builder, opcodes, i);\n            if (ct == NULL)\n                return NULL;\n            Py_DECREF(ct);\n            i++;\n        }\n    }\n\n    /* xxx the few bytes of memory we allocate here leak, but it's a\n       minor concern because it should only occur for CPYTHON_BLTN.\n       There is one per real C function in a CFFI C extension module.\n       CPython never unloads its C extension modules anyway.\n    */\n    xfunc = PyMem_Malloc(sizeof(struct CPyExtFunc_s));\n    if (xfunc == NULL) {\n        PyErr_NoMemory();\n        return NULL;\n    }\n    memset((char *)xfunc, 0, sizeof(struct CPyExtFunc_s));\n    assert(g->address);\n    xfunc->md.ml_meth = (PyCFunction)g->address;\n    xfunc->md.ml_flags = flags;\n    xfunc->md.ml_name = g->name;\n    xfunc->md.ml_doc = cpyextfunc_doc;\n    xfunc->direct_fn = g->size_or_direct_fn;\n    xfunc->type_index = type_index;\n\n    return PyCFunction_NewEx(&xfunc->md, (PyObject *)lib, lib->l_libname);\n}\n\nstatic PyObject *lib_build_and_cache_attr(LibObject *lib, PyObject *name,\n                                          int recursion)\n{\n    /* does not return a new reference! */\n    PyObject *x;\n    int index;\n    const struct _cffi_global_s *g;\n    CTypeDescrObject *ct;\n    builder_c_t *types_builder = lib->l_types_builder;\n    char *s = PyText_AsUTF8(name);\n    if (s == NULL)\n        return NULL;\n\n    index = search_in_globals(&types_builder->ctx, s, strlen(s));\n    if (index < 0) {\n\n        if (types_builder->included_libs != NULL) {\n            Py_ssize_t i;\n            PyObject *included_ffis = types_builder->included_ffis;\n            PyObject *included_libs = types_builder->included_libs;\n\n            if (recursion > 100) {\n                PyErr_SetString(PyExc_RuntimeError,\n                    \"recursion overflow in ffi.include() delegations\");\n                return NULL;\n            }\n\n            for (i = 0; i < PyTuple_GET_SIZE(included_libs); i++) {\n                LibObject *lib1;\n\n                lib1 = (LibObject *)PyTuple_GET_ITEM(included_libs, i);\n                if (lib1 != NULL) {\n                    x = PyDict_GetItem(lib1->l_dict, name);\n                    if (x != NULL) {\n                        Py_INCREF(x);\n                        goto found;\n                    }\n                    x = lib_build_and_cache_attr(lib1, name, recursion + 1);\n                    if (x != NULL) {\n                        Py_INCREF(x);\n                        goto found;\n                    }\n                }\n                else {\n                    FFIObject *ffi1;\n\n                    ffi1 = (FFIObject *)PyTuple_GetItem(included_ffis, i);\n                    if (ffi1 == NULL)\n                        return NULL;\n                    x = ffi_fetch_int_constant(ffi1, s, recursion + 1);\n                    if (x != NULL)\n                        goto found;\n                }\n                if (PyErr_Occurred())\n                    return NULL;\n            }\n        }\n\n        if (recursion > 0)\n            return NULL;  /* no error set, continue looking elsewhere */\n\n        PyErr_Format(PyExc_AttributeError,\n                     \"cffi library '%.200s' has no function, constant \"\n                     \"or global variable named '%.200s'\",\n                     PyText_AS_UTF8(lib->l_libname), s);\n        return NULL;\n    }\n\n    g = &types_builder->ctx.globals[index];\n\n    switch (_CFFI_GETOP(g->type_op)) {\n\n    case _CFFI_OP_CPYTHON_BLTN_V:\n        x = lib_build_cpython_func(lib, g, s, METH_VARARGS);\n        break;\n\n    case _CFFI_OP_CPYTHON_BLTN_N:\n        x = lib_build_cpython_func(lib, g, s, METH_NOARGS);\n        break;\n\n    case _CFFI_OP_CPYTHON_BLTN_O:\n        x = lib_build_cpython_func(lib, g, s, METH_O);\n        break;\n\n    case _CFFI_OP_CONSTANT_INT:\n    case _CFFI_OP_ENUM:\n    {\n        /* a constant integer whose value, in an \"unsigned long long\",\n           is obtained by calling the function at g->address */\n        x = realize_global_int(types_builder, index);\n        break;\n    }\n\n    case _CFFI_OP_CONSTANT:\n    case _CFFI_OP_DLOPEN_CONST:\n    {\n        /* a constant which is not of integer type */\n        char *data;\n        ct = realize_c_type(types_builder, types_builder->ctx.types,\n                            _CFFI_GETARG(g->type_op));\n        if (ct == NULL)\n            return NULL;\n\n        if (ct->ct_size <= 0) {\n            PyErr_SetString(PyExc_SystemError, \"constant has no known size\");\n            return NULL;\n        }\n        if (g->address == NULL) {\n            /* for dlopen() style */\n            assert(_CFFI_GETOP(g->type_op) == _CFFI_OP_DLOPEN_CONST);\n            data = cdlopen_fetch(lib->l_libname, lib->l_libhandle, s);\n            if (data == NULL)\n                return NULL;\n        }\n        else {\n            /* xxx the few bytes of memory we allocate here leak, but it's\n               a minor concern because it should only occur for\n               OP_CONSTANT.  There is one per real non-integer C constant\n               in a CFFI C extension module.  CPython never unloads its C\n               extension modules anyway.  Note that we used to do alloca(),\n               but see issue #198. */\n            assert(_CFFI_GETOP(g->type_op) == _CFFI_OP_CONSTANT);\n            data = PyMem_Malloc(ct->ct_size);\n            if (data == NULL) {\n                PyErr_NoMemory();\n                return NULL;\n            }\n            ((void(*)(char*))g->address)(data);\n        }\n        x = convert_to_object(data, ct);\n        Py_DECREF(ct);\n        break;\n    }\n\n    case _CFFI_OP_GLOBAL_VAR:\n    {\n        /* global variable of the exact type specified here */\n        Py_ssize_t g_size = (Py_ssize_t)g->size_or_direct_fn;\n        ct = realize_c_type(types_builder, types_builder->ctx.types,\n                            _CFFI_GETARG(g->type_op));\n        if (ct == NULL)\n            return NULL;\n        if (g_size != ct->ct_size && g_size != 0 && ct->ct_size > 0) {\n            PyErr_Format(FFIError,\n                         \"global variable '%.200s' should be %zd bytes \"\n                         \"according to the cdef, but is actually %zd\",\n                         s, ct->ct_size, g_size);\n            x = NULL;\n        }\n        else {\n            void *address = g->address;\n            if (address == NULL) {\n                /* for dlopen() style */\n                address = cdlopen_fetch(lib->l_libname, lib->l_libhandle, s);\n                if (address == NULL)\n                    return NULL;\n            }\n            x = make_global_var(ct, address);\n        }\n        Py_DECREF(ct);\n        break;\n    }\n\n    case _CFFI_OP_DLOPEN_FUNC:\n    {\n        /* For dlopen(): the function of the given 'name'.  We use\n           dlsym() to get the address of something in the dynamic\n           library, which we interpret as being exactly a function of\n           the specified type.\n        */\n        PyObject *ct1;\n        void *address = cdlopen_fetch(lib->l_libname, lib->l_libhandle, s);\n        if (address == NULL)\n            return NULL;\n\n        ct1 = realize_c_type_or_func(types_builder,\n                                     types_builder->ctx.types,\n                                     _CFFI_GETARG(g->type_op));\n        if (ct1 == NULL)\n            return NULL;\n\n        assert(!CTypeDescr_Check(ct1));   /* must be a function */\n        x = new_simple_cdata(address, unwrap_fn_as_fnptr(ct1));\n\n        Py_DECREF(ct1);\n        break;\n    }\n\n    default:\n        PyErr_Format(PyExc_NotImplementedError, \"in lib_build_attr: op=%d\",\n                     (int)_CFFI_GETOP(g->type_op));\n        return NULL;\n    }\n\n found:\n    if (x != NULL) {\n        int err = PyDict_SetItem(lib->l_dict, name, x);\n        Py_DECREF(x);\n        if (err < 0)     /* else there is still one ref left in the dict */\n            return NULL;\n    }\n    return x;\n}\n\n#define LIB_GET_OR_CACHE_ADDR(x, lib, name, error)      \\\n    do {                                                \\\n        x = PyDict_GetItem(lib->l_dict, name);          \\\n        if (x == NULL) {                                \\\n            x = lib_build_and_cache_attr(lib, name, 0); \\\n            if (x == NULL) {                            \\\n                error;                                  \\\n            }                                           \\\n        }                                               \\\n    } while (0)\n\nstatic PyObject *lib_getattr(LibObject *lib, PyObject *name)\n{\n    PyObject *x;\n    LIB_GET_OR_CACHE_ADDR(x, lib, name, return NULL);\n\n    if (GlobSupport_Check(x)) {\n        return read_global_var((GlobSupportObject *)x);\n    }\n    Py_INCREF(x);\n    return x;\n}\n\nstatic int lib_setattr(LibObject *lib, PyObject *name, PyObject *val)\n{\n    PyObject *x;\n    LIB_GET_OR_CACHE_ADDR(x, lib, name, return -1);\n\n    if (val == NULL) {\n        PyErr_SetString(PyExc_AttributeError, \"C attribute cannot be deleted\");\n        return -1;\n    }\n\n    if (GlobSupport_Check(x)) {\n        return write_global_var((GlobSupportObject *)x, val);\n    }\n\n    PyErr_Format(PyExc_AttributeError,\n                 \"cannot write to function or constant '%.200s'\",\n                 PyText_Check(name) ? PyText_AS_UTF8(name) : \"?\");\n    return -1;\n}\n\nstatic PyObject *lib_dir(LibObject *lib, PyObject *noarg)\n{\n    const struct _cffi_global_s *g = lib->l_types_builder->ctx.globals;\n    int i, total = lib->l_types_builder->ctx.num_globals;\n    PyObject *lst = PyList_New(total);\n    if (lst == NULL)\n        return NULL;\n\n    for (i = 0; i < total; i++) {\n        PyObject *s = PyText_FromString(g[i].name);\n        if (s == NULL) {\n            Py_DECREF(lst);\n            return NULL;\n        }\n        PyList_SET_ITEM(lst, i, s);\n    }\n    return lst;\n}\n\nstatic PyMethodDef lib_methods[] = {\n    {\"__dir__\",   (PyCFunction)lib_dir,  METH_NOARGS},\n    {NULL,        NULL}           /* sentinel */\n};\n\nstatic PyTypeObject Lib_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"CompiledLib\",\n    sizeof(LibObject),\n    0,\n    (destructor)lib_dealloc,                    /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_compare */\n    (reprfunc)lib_repr,                         /* tp_repr */\n    0,                                          /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    (getattrofunc)lib_getattr,                  /* tp_getattro */\n    (setattrofunc)lib_setattr,                  /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT,                         /* tp_flags */\n    0,                                          /* tp_doc */\n    (traverseproc)lib_traverse,                 /* tp_traverse */\n    0,                                          /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    lib_methods,                                /* tp_methods */\n    0,                                          /* tp_members */\n    0,                                          /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    offsetof(LibObject, l_dict),                /* tp_dictoffset */\n};\n\nstatic LibObject *lib_internal_new(FFIObject *ffi, char *module_name,\n                                   void *dlopen_libhandle)\n{\n    LibObject *lib;\n    PyObject *libname, *dict;\n\n    libname = PyText_FromString(module_name);\n    if (libname == NULL)\n        goto err1;\n\n    dict = PyDict_New();\n    if (dict == NULL)\n        goto err2;\n\n    lib = PyObject_New(LibObject, &Lib_Type);\n    if (lib == NULL)\n        goto err3;\n\n    lib->l_types_builder = &ffi->types_builder;\n    lib->l_dict = dict;\n    lib->l_libname = libname;\n    Py_INCREF(ffi);\n    lib->l_ffi = ffi;\n    lib->l_libhandle = dlopen_libhandle;\n    return lib;\n\n err3:\n    Py_DECREF(dict);\n err2:\n    Py_DECREF(libname);\n err1:\n    cdlopen_close_ignore_errors(dlopen_libhandle);\n    return NULL;\n}\n\nstatic PyObject *address_of_global_var(PyObject *args)\n{\n    LibObject *lib;\n    PyObject *x, *o_varname;\n    char *varname;\n\n    if (!PyArg_ParseTuple(args, \"O!s\", &Lib_Type, &lib, &varname))\n        return NULL;\n\n    /* rebuild a string from 'varname', to do typechecks and to force\n       a unicode back to a plain string (on python 2) */\n    o_varname = PyText_FromString(varname);\n    if (o_varname == NULL)\n        return NULL;\n\n    LIB_GET_OR_CACHE_ADDR(x, lib, o_varname, goto error);\n    Py_DECREF(o_varname);\n    if (GlobSupport_Check(x)) {\n        return cg_addressof_global_var((GlobSupportObject *)x);\n    }\n    else {\n        struct CPyExtFunc_s *exf = _cpyextfunc_get(x);\n        if (exf != NULL) {  /* an OP_CPYTHON_BLTN: '&func' returns a cdata */\n            PyObject *ct;\n            if (exf->direct_fn == NULL) {\n                Py_INCREF(x);    /* backward compatibility */\n                return x;\n            }\n            ct = _cpyextfunc_type(lib, exf);\n            if (ct == NULL)\n                return NULL;\n            x = new_simple_cdata(exf->direct_fn, (CTypeDescrObject *)ct);\n            Py_DECREF(ct);\n            return x;\n        }\n        if (CData_Check(x) &&  /* a constant functionptr cdata: 'f == &f' */\n                (((CDataObject *)x)->c_type->ct_flags & CT_FUNCTIONPTR) != 0) {\n            Py_INCREF(x);\n            return x;\n        }\n        else {\n            PyErr_Format(PyExc_AttributeError,\n                         \"cannot take the address of the constant '%.200s'\",\n                         varname);\n            return NULL;\n        }\n    }\n\n error:\n    Py_DECREF(o_varname);\n    return NULL;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.1.2-nak3eqkxfunb4z5owzsqogchnaejp7o4/spack-src/c/cffi1_module.c": "\n#include \"parse_c_type.c\"\n#include \"realize_c_type.c\"\n\n#define CFFI_VERSION_MIN    0x2601\n#define CFFI_VERSION_MAX    0x26FF\n\ntypedef struct FFIObject_s FFIObject;\ntypedef struct LibObject_s LibObject;\n\nstatic PyTypeObject FFI_Type;   /* forward */\nstatic PyTypeObject Lib_Type;   /* forward */\n\n#include \"ffi_obj.c\"\n#include \"cglob.c\"\n#include \"cgc.c\"\n#include \"lib_obj.c\"\n#include \"cdlopen.c\"\n\n\nstatic int init_ffi_lib(PyObject *m)\n{\n    PyObject *x;\n    int i;\n\n    if (PyType_Ready(&FFI_Type) < 0)\n        return -1;\n    if (PyType_Ready(&Lib_Type) < 0)\n        return -1;\n    if (init_global_types_dict(FFI_Type.tp_dict) < 0)\n        return -1;\n\n    FFIError = PyErr_NewException(\"ffi.error\", NULL, NULL);\n    if (FFIError == NULL)\n        return -1;\n    if (PyDict_SetItemString(FFI_Type.tp_dict, \"error\", FFIError) < 0)\n        return -1;\n    if (PyDict_SetItemString(FFI_Type.tp_dict, \"CType\",\n                             (PyObject *)&CTypeDescr_Type) < 0)\n        return -1;\n    if (PyDict_SetItemString(FFI_Type.tp_dict, \"CData\",\n                             (PyObject *)&CData_Type) < 0)\n        return -1;\n\n    for (i = 0; all_dlopen_flags[i].name != NULL; i++) {\n        x = PyInt_FromLong(all_dlopen_flags[i].value);\n        if (x == NULL || PyDict_SetItemString(FFI_Type.tp_dict,\n                                              all_dlopen_flags[i].name,\n                                              x) < 0)\n            return -1;\n        Py_DECREF(x);\n    }\n\n    x = (PyObject *)&FFI_Type;\n    Py_INCREF(x);\n    if (PyModule_AddObject(m, \"FFI\", x) < 0)\n        return -1;\n    x = (PyObject *)&Lib_Type;\n    Py_INCREF(x);\n    if (PyModule_AddObject(m, \"Lib\", x) < 0)\n        return -1;\n\n    return 0;\n}\n\nstatic int make_included_tuples(char *module_name,\n                                const char *const *ctx_includes,\n                                PyObject **included_ffis,\n                                PyObject **included_libs)\n{\n    Py_ssize_t num = 0;\n    const char *const *p_include;\n\n    if (ctx_includes == NULL)\n        return 0;\n\n    for (p_include = ctx_includes; *p_include; p_include++) {\n        num++;\n    }\n    *included_ffis = PyTuple_New(num);\n    *included_libs = PyTuple_New(num);\n    if (*included_ffis == NULL || *included_libs == NULL)\n        goto error;\n\n    num = 0;\n    for (p_include = ctx_includes; *p_include; p_include++) {\n        PyObject *included_ffi, *included_lib;\n        PyObject *m = PyImport_ImportModule(*p_include);\n        if (m == NULL)\n            goto import_error;\n\n        included_ffi = PyObject_GetAttrString(m, \"ffi\");\n        PyTuple_SET_ITEM(*included_ffis, num, included_ffi);\n\n        included_lib = (included_ffi == NULL) ? NULL :\n                       PyObject_GetAttrString(m, \"lib\");\n        PyTuple_SET_ITEM(*included_libs, num, included_lib);\n\n        Py_DECREF(m);\n        if (included_lib == NULL)\n            goto import_error;\n\n        if (!FFIObject_Check(included_ffi) ||\n            !LibObject_Check(included_lib))\n            goto import_error;\n        num++;\n    }\n    return 0;\n\n import_error:\n    PyErr_Format(PyExc_ImportError,\n                 \"while loading %.200s: failed to import ffi, lib from %.200s\",\n                 module_name, *p_include);\n error:\n    Py_XDECREF(*included_ffis); *included_ffis = NULL;\n    Py_XDECREF(*included_libs); *included_libs = NULL;\n    return -1;\n}\n\nstatic PyObject *_my_Py_InitModule(char *module_name)\n{\n#if PY_MAJOR_VERSION >= 3\n    struct PyModuleDef *module_def, local_module_def = {\n        PyModuleDef_HEAD_INIT,\n        module_name,\n        NULL,\n        -1,\n        NULL, NULL, NULL, NULL, NULL\n    };\n    /* note: the 'module_def' is allocated dynamically and leaks,\n       but anyway the C extension module can never be unloaded */\n    module_def = PyMem_Malloc(sizeof(struct PyModuleDef));\n    if (module_def == NULL)\n        return PyErr_NoMemory();\n    *module_def = local_module_def;\n    return PyModule_Create(module_def);\n#else\n    return Py_InitModule(module_name, NULL);\n#endif\n}\n\nstatic PyObject *b_init_cffi_1_0_external_module(PyObject *self, PyObject *arg)\n{\n    PyObject *m;\n    FFIObject *ffi;\n    LibObject *lib;\n    Py_ssize_t version;\n    char *module_name, *exports;\n    void **raw;\n    const struct _cffi_type_context_s *ctx;\n\n    raw = (void **)PyLong_AsVoidPtr(arg);\n    if (raw == NULL)\n        return NULL;\n\n    module_name = (char *)raw[0];\n    version = (Py_ssize_t)raw[1];\n    exports = (char *)raw[2];\n    ctx = (const struct _cffi_type_context_s *)raw[3];\n\n    if (version < CFFI_VERSION_MIN || version > CFFI_VERSION_MAX) {\n        if (!PyErr_Occurred())\n            PyErr_Format(PyExc_ImportError,\n                         \"cffi extension module '%s' has unknown version %p\",\n                         module_name, (void *)version);\n        return NULL;\n    }\n\n    /* initialize the exports array */\n    memcpy(exports, (char *)cffi_exports, sizeof(cffi_exports));\n\n    /* make the module object */\n    m = _my_Py_InitModule(module_name);\n    if (m == NULL)\n        return NULL;\n\n    /* build the FFI and Lib object inside this new module */\n    ffi = ffi_internal_new(&FFI_Type, ctx);\n    Py_XINCREF(ffi);    /* make the ffi object really immortal */\n    if (ffi == NULL || PyModule_AddObject(m, \"ffi\", (PyObject *)ffi) < 0)\n        return NULL;\n\n    lib = lib_internal_new(ffi, module_name, NULL);\n    if (lib == NULL || PyModule_AddObject(m, \"lib\", (PyObject *)lib) < 0)\n        return NULL;\n\n    if (make_included_tuples(module_name, ctx->includes,\n                             &ffi->types_builder.included_ffis,\n                             &lib->l_types_builder->included_libs) < 0)\n        return NULL;\n\n    return m;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.1.2-nak3eqkxfunb4z5owzsqogchnaejp7o4/spack-src/c/cdlopen.c": "/* ffi.dlopen() interface with dlopen()/dlsym()/dlclose() */\n\nstatic void *cdlopen_fetch(PyObject *libname, void *libhandle, char *symbol)\n{\n    void *address;\n\n    if (libhandle == NULL) {\n        PyErr_Format(FFIError, \"library '%s' has been closed\",\n                     PyText_AS_UTF8(libname));\n        return NULL;\n    }\n\n    dlerror();   /* clear error condition */\n    address = dlsym(libhandle, symbol);\n    if (address == NULL) {\n        const char *error = dlerror();\n        PyErr_Format(FFIError, \"symbol '%s' not found in library '%s': %s\",\n                     symbol, PyText_AS_UTF8(libname), error);\n    }\n    return address;\n}\n\nstatic void cdlopen_close_ignore_errors(void *libhandle)\n{\n    if (libhandle != NULL)\n        dlclose(libhandle);\n}\n\nstatic int cdlopen_close(PyObject *libname, void *libhandle)\n{\n    if (libhandle != NULL && dlclose(libhandle) != 0) {\n        const char *error = dlerror();\n        PyErr_Format(FFIError, \"closing library '%s': %s\",\n                     PyText_AS_UTF8(libname), error);\n        return -1;\n    }\n    return 0;\n}\n\nstatic PyObject *ffi_dlopen(PyObject *self, PyObject *args)\n{\n    char *filename_or_null, *printable_filename;\n    void *handle;\n    int flags = 0;\n\n    if (PyTuple_GET_SIZE(args) == 0 || PyTuple_GET_ITEM(args, 0) == Py_None) {\n        PyObject *dummy;\n        if (!PyArg_ParseTuple(args, \"|Oi:load_library\",\n                              &dummy, &flags))\n            return NULL;\n        filename_or_null = NULL;\n    }\n    else if (!PyArg_ParseTuple(args, \"et|i:load_library\",\n                          Py_FileSystemDefaultEncoding, &filename_or_null,\n                          &flags))\n        return NULL;\n\n    if ((flags & (RTLD_NOW | RTLD_LAZY)) == 0)\n        flags |= RTLD_NOW;\n    printable_filename = filename_or_null ? filename_or_null : \"<None>\";\n\n    handle = dlopen(filename_or_null, flags);\n    if (handle == NULL) {\n        const char *error = dlerror();\n        PyErr_Format(PyExc_OSError, \"cannot load library '%s': %s\",\n                     printable_filename, error);\n        return NULL;\n    }\n    return (PyObject *)lib_internal_new((FFIObject *)self,\n                                        printable_filename, handle);\n}\n\nstatic PyObject *ffi_dlclose(PyObject *self, PyObject *args)\n{\n    LibObject *lib;\n    void *libhandle;\n    if (!PyArg_ParseTuple(args, \"O!\", &Lib_Type, &lib))\n        return NULL;\n\n    libhandle = lib->l_libhandle;\n    lib->l_libhandle = NULL;\n\n    if (libhandle == NULL) {\n        PyErr_Format(FFIError, \"library '%s' is already closed \"\n                     \"or was not created with ffi.dlopen()\",\n                     PyText_AS_UTF8(lib->l_libname));\n        return NULL;\n    }\n\n    /* Clear the dict to force further accesses to do cdlopen_fetch()\n       again, and fail because the library was closed. */\n    PyDict_Clear(lib->l_dict);\n\n    if (cdlopen_close(lib->l_libname, libhandle) < 0)\n        return NULL;\n\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\n\nstatic Py_ssize_t cdl_4bytes(char *src)\n{\n    /* read 4 bytes in little-endian order; return it as a signed integer */\n    signed char *ssrc = (signed char *)src;\n    unsigned char *usrc = (unsigned char *)src;\n    return (ssrc[0] << 24) | (usrc[1] << 16) | (usrc[2] << 8) | usrc[3];\n}\n\nstatic _cffi_opcode_t cdl_opcode(char *src)\n{\n    return (_cffi_opcode_t)cdl_4bytes(src);\n}\n\ntypedef struct {\n    unsigned long long value;\n    int neg;\n} cdl_intconst_t;\n\nstatic int _cdl_realize_global_int(struct _cffi_getconst_s *gc)\n{\n    /* The 'address' field of 'struct _cffi_global_s' is set to point\n       to this function in case ffiobj_init() sees constant integers.\n       This fishes around after the 'ctx->globals' array, which is\n       initialized to contain another array, this time of\n       'cdl_intconst_t' structures.  We get the nth one and it tells\n       us what to return.\n    */\n    cdl_intconst_t *ic;\n    ic = (cdl_intconst_t *)(gc->ctx->globals + gc->ctx->num_globals);\n    ic += gc->gindex;\n    gc->value = ic->value;\n    return ic->neg;\n}\n\nstatic int ffiobj_init(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    FFIObject *ffi;\n    static char *keywords[] = {\"module_name\", \"_version\", \"_types\",\n                               \"_globals\", \"_struct_unions\", \"_enums\",\n                               \"_typenames\", \"_includes\", NULL};\n    char *ffiname = \"?\", *types = NULL, *building = NULL;\n    Py_ssize_t version = -1;\n    Py_ssize_t types_len = 0;\n    PyObject *globals = NULL, *struct_unions = NULL, *enums = NULL;\n    PyObject *typenames = NULL, *includes = NULL;\n\n    if (!PyArg_ParseTupleAndKeywords(args, kwds,\n                                     \"|sns#O!O!O!O!O!:FFI\", keywords,\n                                     &ffiname, &version, &types, &types_len,\n                                     &PyTuple_Type, &globals,\n                                     &PyTuple_Type, &struct_unions,\n                                     &PyTuple_Type, &enums,\n                                     &PyTuple_Type, &typenames,\n                                     &PyTuple_Type, &includes))\n        return -1;\n\n    ffi = (FFIObject *)self;\n    if (ffi->ctx_is_nonempty) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"cannot call FFI.__init__() more than once\");\n        return -1;\n    }\n    ffi->ctx_is_nonempty = 1;\n\n    if (version == -1 && types_len == 0)\n        return 0;\n    if (version < CFFI_VERSION_MIN || version > CFFI_VERSION_MAX) {\n        PyErr_Format(PyExc_ImportError,\n                     \"cffi out-of-line Python module '%s' has unknown \"\n                     \"version %p\", ffiname, (void *)version);\n        return -1;\n    }\n\n    if (types_len > 0) {\n        /* unpack a string of 4-byte entries into an array of _cffi_opcode_t */\n        _cffi_opcode_t *ntypes;\n        Py_ssize_t i, n = types_len / 4;\n\n        building = PyMem_Malloc(n * sizeof(_cffi_opcode_t));\n        if (building == NULL)\n            goto error;\n        ntypes = (_cffi_opcode_t *)building;\n\n        for (i = 0; i < n; i++) {\n            ntypes[i] = cdl_opcode(types);\n            types += 4;\n        }\n        ffi->types_builder.ctx.types = ntypes;\n        ffi->types_builder.ctx.num_types = n;\n        building = NULL;\n    }\n\n    if (globals != NULL) {\n        /* unpack a tuple alternating strings and ints, each two together\n           describing one global_s entry with no specified address or size.\n           The int is only used with integer constants. */\n        struct _cffi_global_s *nglobs;\n        cdl_intconst_t *nintconsts;\n        Py_ssize_t i, n = PyTuple_GET_SIZE(globals) / 2;\n\n        i = n * (sizeof(struct _cffi_global_s) + sizeof(cdl_intconst_t));\n        building = PyMem_Malloc(i);\n        if (building == NULL)\n            goto error;\n        memset(building, 0, i);\n        nglobs = (struct _cffi_global_s *)building;\n        nintconsts = (cdl_intconst_t *)(nglobs + n);\n\n        for (i = 0; i < n; i++) {\n            char *g = PyBytes_AS_STRING(PyTuple_GET_ITEM(globals, i * 2));\n            nglobs[i].type_op = cdl_opcode(g); g += 4;\n            nglobs[i].name = g;\n            if (_CFFI_GETOP(nglobs[i].type_op) == _CFFI_OP_CONSTANT_INT ||\n                _CFFI_GETOP(nglobs[i].type_op) == _CFFI_OP_ENUM) {\n                PyObject *o = PyTuple_GET_ITEM(globals, i * 2 + 1);\n                nglobs[i].address = &_cdl_realize_global_int;\n#if PY_MAJOR_VERSION < 3\n                if (PyInt_Check(o)) {\n                    nintconsts[i].neg = PyInt_AS_LONG(o) <= 0;\n                    nintconsts[i].value = (long long)PyInt_AS_LONG(o);\n                }\n                else\n#endif\n                {\n                    nintconsts[i].neg = PyObject_RichCompareBool(o, Py_False,\n                                                                 Py_LE);\n                    nintconsts[i].value = PyLong_AsUnsignedLongLongMask(o);\n                    if (PyErr_Occurred())\n                        goto error;\n                }\n            }\n        }\n        ffi->types_builder.ctx.globals = nglobs;\n        ffi->types_builder.ctx.num_globals = n;\n        building = NULL;\n    }\n\n    if (struct_unions != NULL) {\n        /* unpack a tuple of struct/unions, each described as a sub-tuple;\n           the item 0 of each sub-tuple describes the struct/union, and\n           the items 1..N-1 describe the fields, if any */\n        struct _cffi_struct_union_s *nstructs;\n        struct _cffi_field_s *nfields;\n        Py_ssize_t i, n = PyTuple_GET_SIZE(struct_unions);\n        Py_ssize_t nf = 0;   /* total number of fields */\n\n        for (i = 0; i < n; i++) {\n            nf += PyTuple_GET_SIZE(PyTuple_GET_ITEM(struct_unions, i)) - 1;\n        }\n        i = (n * sizeof(struct _cffi_struct_union_s) +\n             nf * sizeof(struct _cffi_field_s));\n        building = PyMem_Malloc(i);\n        if (building == NULL)\n            goto error;\n        memset(building, 0, i);\n        nstructs = (struct _cffi_struct_union_s *)building;\n        nfields = (struct _cffi_field_s *)(nstructs + n);\n        nf = 0;\n\n        for (i = 0; i < n; i++) {\n            /* 'desc' is the tuple of strings (desc_struct, desc_field_1, ..) */\n            PyObject *desc = PyTuple_GET_ITEM(struct_unions, i);\n            Py_ssize_t j, nf1 = PyTuple_GET_SIZE(desc) - 1;\n            char *s = PyBytes_AS_STRING(PyTuple_GET_ITEM(desc, 0));\n            /* 's' is the first string, describing the struct/union */\n            nstructs[i].type_index = cdl_4bytes(s); s += 4;\n            nstructs[i].flags = cdl_4bytes(s); s += 4;\n            nstructs[i].name = s;\n            if (nstructs[i].flags & (_CFFI_F_OPAQUE | _CFFI_F_EXTERNAL)) {\n                nstructs[i].size = (size_t)-1;\n                nstructs[i].alignment = -1;\n                nstructs[i].first_field_index = -1;\n                nstructs[i].num_fields = 0;\n                assert(nf1 == 0);\n            }\n            else {\n                nstructs[i].size = (size_t)-2;\n                nstructs[i].alignment = -2;\n                nstructs[i].first_field_index = nf;\n                nstructs[i].num_fields = nf1;\n            }\n            for (j = 0; j < nf1; j++) {\n                char *f = PyBytes_AS_STRING(PyTuple_GET_ITEM(desc, j + 1));\n                /* 'f' is one of the other strings beyond the first one,\n                   describing one field each */\n                nfields[nf].field_type_op = cdl_opcode(f); f += 4;\n                nfields[nf].field_offset = (size_t)-1;\n                if (_CFFI_GETOP(nfields[nf].field_type_op) != _CFFI_OP_NOOP) {\n                    nfields[nf].field_size = cdl_4bytes(f); f += 4;\n                }\n                else {\n                    nfields[nf].field_size = (size_t)-1;\n                }\n                nfields[nf].name = f;\n                nf++;\n            }\n        }\n        ffi->types_builder.ctx.struct_unions = nstructs;\n        ffi->types_builder.ctx.fields = nfields;\n        ffi->types_builder.ctx.num_struct_unions = n;\n        building = NULL;\n    }\n\n    if (enums != NULL) {\n        /* unpack a tuple of strings, each of which describes one enum_s\n           entry */\n        struct _cffi_enum_s *nenums;\n        Py_ssize_t i, n = PyTuple_GET_SIZE(enums);\n\n        i = n * sizeof(struct _cffi_enum_s);\n        building = PyMem_Malloc(i);\n        if (building == NULL)\n            goto error;\n        memset(building, 0, i);\n        nenums = (struct _cffi_enum_s *)building;\n\n        for (i = 0; i < n; i++) {\n            char *e = PyBytes_AS_STRING(PyTuple_GET_ITEM(enums, i));\n            /* 'e' is a string describing the enum */\n            nenums[i].type_index = cdl_4bytes(e); e += 4;\n            nenums[i].type_prim = cdl_4bytes(e); e += 4;\n            nenums[i].name = e; e += strlen(e) + 1;\n            nenums[i].enumerators = e;\n        }\n        ffi->types_builder.ctx.enums = nenums;\n        ffi->types_builder.ctx.num_enums = n;\n        building = NULL;\n    }\n\n    if (typenames != NULL) {\n        /* unpack a tuple of strings, each of which describes one typename_s\n           entry */\n        struct _cffi_typename_s *ntypenames;\n        Py_ssize_t i, n = PyTuple_GET_SIZE(typenames);\n\n        i = n * sizeof(struct _cffi_typename_s);\n        building = PyMem_Malloc(i);\n        if (building == NULL)\n            goto error;\n        memset(building, 0, i);\n        ntypenames = (struct _cffi_typename_s *)building;\n\n        for (i = 0; i < n; i++) {\n            char *t = PyBytes_AS_STRING(PyTuple_GET_ITEM(typenames, i));\n            /* 't' is a string describing the typename */\n            ntypenames[i].type_index = cdl_4bytes(t); t += 4;\n            ntypenames[i].name = t;\n        }\n        ffi->types_builder.ctx.typenames = ntypenames;\n        ffi->types_builder.ctx.num_typenames = n;\n        building = NULL;\n    }\n\n    if (includes != NULL) {\n        PyObject *included_libs;\n\n        included_libs = PyTuple_New(PyTuple_GET_SIZE(includes));\n        if (included_libs == NULL)\n            return -1;\n\n        Py_INCREF(includes);\n        ffi->types_builder.included_ffis = includes;\n        ffi->types_builder.included_libs = included_libs;\n    }\n\n    /* Above, we took directly some \"char *\" strings out of the strings,\n       typically from somewhere inside tuples.  Keep them alive by\n       incref'ing the whole input arguments. */\n    Py_INCREF(args);\n    Py_XINCREF(kwds);\n    ffi->types_builder._keepalive1 = args;\n    ffi->types_builder._keepalive2 = kwds;\n    return 0;\n\n error:\n    if (building != NULL)\n        PyMem_Free(building);\n    if (!PyErr_Occurred())\n        PyErr_NoMemory();\n    return -1;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.1.2-nak3eqkxfunb4z5owzsqogchnaejp7o4/spack-src/c/misc_win32.h": "#include <malloc.h>   /* for alloca() */\n\n/************************************************************/\n/* errno and GetLastError support */\n\nstruct cffi_errno_s {\n    int saved_errno;\n    int saved_lasterror;\n};\n\nstatic DWORD cffi_tls_index;\n\nstatic void init_errno(void)\n{\n    cffi_tls_index = TlsAlloc();\n    if (cffi_tls_index == TLS_OUT_OF_INDEXES)\n        PyErr_SetString(PyExc_WindowsError, \"TlsAlloc() failed\");\n}\n\nstatic struct cffi_errno_s *_geterrno_object(void)\n{\n    LPVOID p = TlsGetValue(cffi_tls_index);\n\n    if (p == NULL) {\n        /* XXX this malloc() leaks */\n        p = malloc(sizeof(struct cffi_errno_s));\n        if (p == NULL)\n            return NULL;\n        memset(p, 0, sizeof(struct cffi_errno_s));\n        TlsSetValue(cffi_tls_index, p);\n    }\n    return (struct cffi_errno_s *)p;\n}\n\nstatic void save_errno(void)\n{\n    int current_err = errno;\n    int current_lasterr = GetLastError();\n    struct cffi_errno_s *p;\n\n    p = _geterrno_object();\n    if (p != NULL) {\n        p->saved_errno = current_err;\n        p->saved_lasterror = current_lasterr;\n    }\n    /* else: cannot report the error */\n}\n\nstatic void save_errno_only(void)\n{\n    int current_err = errno;\n    struct cffi_errno_s *p;\n\n    p = _geterrno_object();\n    if (p != NULL) {\n        p->saved_errno = current_err;\n    }\n    /* else: cannot report the error */\n}\n\nstatic void restore_errno(void)\n{\n    struct cffi_errno_s *p;\n\n    p = _geterrno_object();\n    if (p != NULL) {\n        SetLastError(p->saved_lasterror);\n        errno = p->saved_errno;\n    }\n    /* else: cannot report the error */\n}\n\nstatic void restore_errno_only(void)\n{\n    struct cffi_errno_s *p;\n\n    p = _geterrno_object();\n    if (p != NULL) {\n        errno = p->saved_errno;\n    }\n    /* else: cannot report the error */\n}\n\n#if PY_MAJOR_VERSION >= 3\nstatic PyObject *b_getwinerror(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    int err = -1;\n    int len;\n    WCHAR *s_buf = NULL; /* Free via LocalFree */\n    PyObject *v, *message;\n    static char *keywords[] = {\"code\", NULL};\n\n    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"|i\", keywords, &err))\n        return NULL;\n\n    if (err == -1) {\n        struct cffi_errno_s *p;\n        p = _geterrno_object();\n        if (p == NULL)\n            return PyErr_NoMemory();\n        err = p->saved_lasterror;\n    }\n\n    len = FormatMessageW(\n        /* Error API error */\n        FORMAT_MESSAGE_ALLOCATE_BUFFER |\n        FORMAT_MESSAGE_FROM_SYSTEM |\n        FORMAT_MESSAGE_IGNORE_INSERTS,\n        NULL,           /* no message source */\n        err,\n        MAKELANGID(LANG_NEUTRAL,\n        SUBLANG_DEFAULT), /* Default language */\n        (LPWSTR) &s_buf,\n        0,              /* size not used */\n        NULL);          /* no args */\n    if (len==0) {\n        /* Only seen this in out of mem situations */\n        message = PyUnicode_FromFormat(\"Windows Error 0x%X\", err);\n    } else {\n        /* remove trailing cr/lf and dots */\n        while (len > 0 && (s_buf[len-1] <= L' ' || s_buf[len-1] == L'.'))\n            s_buf[--len] = L'\\0';\n        message = PyUnicode_FromWideChar(s_buf, len);\n    }\n    if (message != NULL)\n        v = Py_BuildValue(\"(iO)\", err, message);\n    else\n        v = NULL;\n    LocalFree(s_buf);\n    return v;\n}\n#else\nstatic PyObject *b_getwinerror(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    int err = -1;\n    int len;\n    char *s;\n    char *s_buf = NULL; /* Free via LocalFree */\n    char s_small_buf[28]; /* Room for \"Windows Error 0xFFFFFFFF\" */\n    PyObject *v;\n    static char *keywords[] = {\"code\", NULL};\n\n    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"|i\", keywords, &err))\n        return NULL;\n\n    if (err == -1) {\n        struct cffi_errno_s *p;\n        p = _geterrno_object();\n        if (p == NULL)\n            return PyErr_NoMemory();\n        err = p->saved_lasterror;\n    }\n\n    len = FormatMessage(\n        /* Error API error */\n        FORMAT_MESSAGE_ALLOCATE_BUFFER |\n        FORMAT_MESSAGE_FROM_SYSTEM |\n        FORMAT_MESSAGE_IGNORE_INSERTS,\n        NULL,           /* no message source */\n        err,\n        MAKELANGID(LANG_NEUTRAL,\n        SUBLANG_DEFAULT), /* Default language */\n        (LPTSTR) &s_buf,\n        0,              /* size not used */\n        NULL);          /* no args */\n    if (len==0) {\n        /* Only seen this in out of mem situations */\n        sprintf(s_small_buf, \"Windows Error 0x%X\", err);\n        s = s_small_buf;\n        s_buf = NULL;\n    } else {\n        s = s_buf;\n        /* remove trailing cr/lf and dots */\n        while (len > 0 && (s[len-1] <= ' ' || s[len-1] == '.'))\n            s[--len] = '\\0';\n    }\n    v = Py_BuildValue(\"(is)\", err, s);\n    LocalFree(s_buf);\n    return v;\n}\n#endif\n\n/************************************************************/\n/* Emulate dlopen()&co. from the Windows API */\n\n#define RTLD_LAZY   0\n#define RTLD_NOW    0\n#define RTLD_GLOBAL 0\n#define RTLD_LOCAL  0\n\nstatic void *dlopen(const char *filename, int flag)\n{\n    return (void *)LoadLibrary(filename);\n}\n\nstatic void *dlsym(void *handle, const char *symbol)\n{\n    void *address = GetProcAddress((HMODULE)handle, symbol);\n#ifndef MS_WIN64\n    if (!address) {\n        /* If 'symbol' is not found, then try '_symbol@N' for N in\n           (0, 4, 8, 12, ..., 124).  Unlike ctypes, we try to do that\n           for any symbol, although in theory it should only be done\n           for __stdcall functions.\n        */\n        int i;\n        char *mangled_name = alloca(1 + strlen(symbol) + 1 + 3 + 1);\n        if (!mangled_name)\n            return NULL;\n        for (i = 0; i < 32; i++) {\n            sprintf(mangled_name, \"_%s@%d\", symbol, i * 4);\n            address = GetProcAddress((HMODULE)handle, mangled_name);\n            if (address)\n                break;\n        }\n    }\n#endif\n    return address;\n}\n\nstatic int dlclose(void *handle)\n{\n    return FreeLibrary((HMODULE)handle) ? 0 : -1;\n}\n\nstatic const char *dlerror(void)\n{\n    static char buf[32];\n    DWORD dw = GetLastError(); \n    if (dw == 0)\n        return NULL;\n    sprintf(buf, \"error 0x%x\", (unsigned int)dw);\n    return buf;\n}\n\n/************************************************************/\n/* obscure */\n\n#define ffi_prep_closure(a,b,c,d)  ffi_prep_closure_loc(a,b,c,d,a)\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.1.2-nak3eqkxfunb4z5owzsqogchnaejp7o4/spack-src/cffi.egg-info/SOURCES.txt": "AUTHORS\nLICENSE\nMANIFEST.in\nsetup.py\nsetup_base.py\nc/_cffi_backend.c\nc/cdlopen.c\nc/cffi1_module.c\nc/cgc.c\nc/cglob.c\nc/ffi_obj.c\nc/file_emulator.h\nc/lib_obj.c\nc/malloc_closure.h\nc/minibuffer.h\nc/misc_thread.h\nc/misc_win32.h\nc/parse_c_type.c\nc/realize_c_type.c\nc/test_c.py\nc/wchar_helper.h\nc/libffi_msvc/ffi.c\nc/libffi_msvc/ffi.h\nc/libffi_msvc/ffi_common.h\nc/libffi_msvc/fficonfig.h\nc/libffi_msvc/ffitarget.h\nc/libffi_msvc/prep_cif.c\nc/libffi_msvc/types.c\nc/libffi_msvc/win32.c\nc/libffi_msvc/win64.asm\nc/libffi_msvc/win64.obj\ncffi/__init__.py\ncffi/_cffi_include.h\ncffi/api.py\ncffi/backend_ctypes.py\ncffi/cffi_opcode.py\ncffi/commontypes.py\ncffi/cparser.py\ncffi/ffiplatform.py\ncffi/gc_weakref.py\ncffi/lock.py\ncffi/model.py\ncffi/parse_c_type.h\ncffi/recompiler.py\ncffi/setuptools_ext.py\ncffi/vengine_cpy.py\ncffi/vengine_gen.py\ncffi/verifier.py\ncffi.egg-info/PKG-INFO\ncffi.egg-info/SOURCES.txt\ncffi.egg-info/dependency_links.txt\ncffi.egg-info/entry_points.txt\ncffi.egg-info/not-zip-safe\ncffi.egg-info/requires.txt\ncffi.egg-info/top_level.txt\ndemo/_curses.py\ndemo/_curses_build.py\ndemo/_curses_setup.py\ndemo/api.py\ndemo/bsdopendirtype.py\ndemo/bsdopendirtype_build.py\ndemo/bsdopendirtype_setup.py\ndemo/btrfs-snap.py\ndemo/cffi-cocoa.py\ndemo/fastcsv.py\ndemo/gmp.py\ndemo/manual.c\ndemo/manual2.py\ndemo/pwuid.py\ndemo/py.cleanup\ndemo/pyobj.py\ndemo/readdir.py\ndemo/readdir2.py\ndemo/readdir2_build.py\ndemo/readdir2_setup.py\ndemo/readdir_build.py\ndemo/readdir_ctypes.py\ndemo/readdir_setup.py\ndemo/recopendirtype.py\ndemo/recopendirtype_build.py\ndemo/setup.py\ndemo/setup_manual.py\ndemo/winclipboard.py\ndemo/xclient.py\ndoc/Makefile\ndoc/make.bat\ndoc/misc/design.rst\ndoc/misc/grant-cffi-1.0.rst\ndoc/misc/parse_c_type.rst\ndoc/source/cdef.rst\ndoc/source/conf.py\ndoc/source/index.rst\ndoc/source/installation.rst\ndoc/source/overview.rst\ndoc/source/using.rst\ndoc/source/whatsnew.rst\ntesting/__init__.py\ntesting/support.py\ntesting/udir.py\ntesting/cffi0/__init__.py\ntesting/cffi0/backend_tests.py\ntesting/cffi0/callback_in_thread.py\ntesting/cffi0/test_cdata.py\ntesting/cffi0/test_ctypes.py\ntesting/cffi0/test_ffi_backend.py\ntesting/cffi0/test_function.py\ntesting/cffi0/test_model.py\ntesting/cffi0/test_ownlib.py\ntesting/cffi0/test_parsing.py\ntesting/cffi0/test_platform.py\ntesting/cffi0/test_unicode_literals.py\ntesting/cffi0/test_verify.py\ntesting/cffi0/test_verify2.py\ntesting/cffi0/test_version.py\ntesting/cffi0/test_vgen.py\ntesting/cffi0/test_vgen2.py\ntesting/cffi0/test_zdistutils.py\ntesting/cffi0/test_zintegration.py\ntesting/cffi0/snippets/distutils_module/setup.py\ntesting/cffi0/snippets/distutils_module/snip_basic_verify.py\ntesting/cffi0/snippets/distutils_package_1/setup.py\ntesting/cffi0/snippets/distutils_package_1/snip_basic_verify1/__init__.py\ntesting/cffi0/snippets/distutils_package_2/setup.py\ntesting/cffi0/snippets/distutils_package_2/snip_basic_verify2/__init__.py\ntesting/cffi0/snippets/infrastructure/setup.py\ntesting/cffi0/snippets/infrastructure/snip_infrastructure/__init__.py\ntesting/cffi0/snippets/setuptools_module/setup.py\ntesting/cffi0/snippets/setuptools_module/snip_setuptools_verify.py\ntesting/cffi0/snippets/setuptools_package_1/setup.py\ntesting/cffi0/snippets/setuptools_package_1/snip_setuptools_verify1/__init__.py\ntesting/cffi0/snippets/setuptools_package_2/setup.py\ntesting/cffi0/snippets/setuptools_package_2/snip_setuptools_verify2/__init__.py\ntesting/cffi1/__init__.py\ntesting/cffi1/test_cffi_binary.py\ntesting/cffi1/test_dlopen.py\ntesting/cffi1/test_dlopen_unicode_literals.py\ntesting/cffi1/test_ffi_obj.py\ntesting/cffi1/test_new_ffi_1.py\ntesting/cffi1/test_parse_c_type.py\ntesting/cffi1/test_re_python.py\ntesting/cffi1/test_realize_c_type.py\ntesting/cffi1/test_recompiler.py\ntesting/cffi1/test_unicode_literals.py\ntesting/cffi1/test_verify1.py\ntesting/cffi1/test_zdist.py",
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.1.2-nak3eqkxfunb4z5owzsqogchnaejp7o4/spack-src/doc/source/cdef.rst": "======================================\nPreparing and Distributing modules\n======================================\n\nThere are three or four different ways to use CFFI in a project.\nIn order of complexity:\n\n* The **\"in-line\", \"ABI mode\"**:\n\n  .. code-block:: python\n\n    import cffi\n\n    ffi = cffi.FFI()\n    ffi.cdef(\"C-like declarations\")\n    lib = ffi.dlopen(\"libpath\")\n\n    # use ffi and lib here\n\n.. _out-of-line-abi:\n\n* The **\"out-of-line\",** but still **\"ABI mode\",** useful to organize\n  the code and reduce the import time:\n\n  .. code-block:: python\n\n    # in a separate file \"package/foo_build.py\"\n    import cffi\n\n    ffi = cffi.FFI()\n    ffi.set_source(\"package._foo\", None)\n    ffi.cdef(\"C-like declarations\")\n\n    if __name__ == \"__main__\":\n        ffi.compile()\n\n  Running ``python foo_build.py`` produces a file ``_foo.py``, which\n  can then be imported in the main program:\n\n  .. code-block:: python\n\n    from package._foo import ffi\n    lib = ffi.dlopen(\"libpath\")\n\n    # use ffi and lib here\n\n.. _out-of-line-api:\n\n* The **\"out-of-line\", \"API mode\"** gives you the most flexibility to\n  access a C library at the level of C, instead of at the binary\n  level:\n\n  .. code-block:: python\n\n    # in a separate file \"package/foo_build.py\"\n    import cffi\n\n    ffi = cffi.FFI()\n    ffi.set_source(\"package._foo\", \"real C code\")   # <=\n    ffi.cdef(\"C-like declarations with '...'\")\n\n    if __name__ == \"__main__\":\n        ffi.compile()\n\n  Running ``python foo_build.py`` produces a file ``_foo.c`` and\n  invokes the C compiler to turn it into a file ``_foo.so`` (or\n  ``_foo.pyd`` or ``_foo.dylib``).  It is a C extension module which\n  can be imported in the main program:\n\n  .. code-block:: python\n\n    from package._foo import ffi, lib\n    # no ffi.dlopen()\n\n    # use ffi and lib here\n\n.. _distutils-setuptools:\n\n* Finally, you can (but don't have to) use CFFI's **Distutils** or\n  **Setuptools integration** when writing a ``setup.py``.  For\n  Distutils (only in out-of-line API mode):\n\n  .. code-block:: python\n\n    # setup.py (requires CFFI to be installed first)\n    from distutils.core import setup\n\n    import foo_build   # possibly with sys.path tricks to find it\n\n    setup(\n        ...,\n        ext_modules=[foo_build.ffi.distutils_extension()],\n    )\n\n  For Setuptools (out-of-line, but works in ABI or API mode;\n  recommended):\n\n  .. code-block:: python\n\n    # setup.py (with automatic dependency tracking)\n    from setuptools import setup\n\n    setup(\n        ...,\n        setup_requires=[\"cffi>=1.0.0\"],\n        cffi_modules=[\"package/foo_build.py:ffi\"],\n        install_requires=[\"cffi>=1.0.0\"],\n    )\n\nNote that CFFI actually contains two different ``FFI`` classes.  The\npage `Using the ffi/lib objects`_ describes the common functionality.\nIt is what you get in the ``from package._foo import ffi`` lines above.\nOn the other hand, the extended ``FFI`` class is the one you get from\n``import cffi; ffi = cffi.FFI()``.  It has the same functionality (for\nin-line use), but also the extra methods described below (to prepare\nthe FFI).\n\n.. _`Using the ffi/lib objects`: using.html\n\nThe reason for this split of functionality is that a regular program\nusing CFFI out-of-line does not need to import the ``cffi`` pure\nPython package at all.  (Internally it still needs ``_cffi_backend``,\na C extension module that comes with CFFI; this is why CFFI is also\nlisted in ``install_requires=..`` above.  In the future this might be\nsplit into a different PyPI package that only installs\n``_cffi_backend``.)\n\nNote that a few small differences do exist: notably, ``from _foo import\nffi`` returns an object of a type written in C, which does not let you\nadd random attributes to it (nor does it have all the\nunderscore-prefixed internal attributes of the Python version).\nSimilarly, the ``lib`` objects returned by the C version are read-only,\napart from writes to global variables.  Also, ``lib.__dict__`` no\nlonger works (it now tries to look up a hypothetical symbol\n``__dict__`` from the C library); use instead ``dir(lib)``.\n\n\nffi.cdef(): declaring types and functions\n-----------------------------------------\n\n**ffi.cdef(source)**: parses the given C source.\nIt registers all the functions, types, constants and global variables in\nthe C source.  The types can be used immediately in ``ffi.new()`` and\nother functions.  Before you can access the functions and global\nvariables, you need to give ``ffi`` another piece of information: where\nthey actually come from (which you do with either ``ffi.dlopen()`` or\n``ffi.set_source()``).\n\n.. _`all types listed above`:\n\nThe C source is parsed internally (using ``pycparser``).  This code\ncannot contain ``#include``.  It should typically be a self-contained\npiece of declarations extracted from a man page.  The only things it\ncan assume to exist are the standard types:\n\n* char, short, int, long, long long (both signed and unsigned)\n\n* float, double, long double\n\n* intN_t, uintN_t (for N=8,16,32,64), intptr_t, uintptr_t, ptrdiff_t,\n  size_t, ssize_t\n\n* wchar_t (if supported by the backend)\n\n* _Bool and bool (equivalent).  If not directly supported by the C\n  compiler, this is declared with the size of ``unsigned char``.\n\n* FILE.  You can declare C functions taking a ``FILE *`` argument and\n  call them with a Python file object.  If needed, you can also do\n  ``c_f = ffi.cast(\"FILE *\", fileobj)`` and then pass around ``c_f``.\n\n* all `common Windows types`_ are defined if you run\n  on Windows (``DWORD``, ``LPARAM``, etc.).  *Changed in version 0.9:* the\n  types ``TBYTE TCHAR LPCTSTR PCTSTR LPTSTR PTSTR PTBYTE PTCHAR`` are no\n  longer automatically defined; see `ffi.set_unicode()`_.\n\n* *New in version 0.9.3:* the other standard integer types from\n  stdint.h, like ``intmax_t``, as long as they map to integers of 1,\n  2, 4 or 8 bytes.  Larger integers are not supported.\n\n.. _`common Windows types`: http://msdn.microsoft.com/en-us/library/windows/desktop/aa383751%28v=vs.85%29.aspx\n\n.. \"versionadded:: 0.9.3\": intmax_t etc.\n\nThe declarations can also contain \"``...``\" at various places; these are\nplaceholders that will be completed by the compiler.  More information\nabout it below in `Letting the C compiler fill the gaps`_.\n\nNote that all standard type names listed above are handled as\n*defaults* only (apart from the ones that are keywords in the C\nlanguage).  If your ``cdef`` contains an explicit typedef that\nredefines one of the types above, then the default described above is\nignored.  (This is a bit hard to implement cleanly, so in some corner\ncases it might fail, notably with the error ``Multiple type specifiers\nwith a type tag``.  Please report it as a bug if it does.)\n\nMultiple calls to ``ffi.cdef()`` are possible.  Beware that it can be\nslow to call ``ffi.cdef()`` a lot of times, a consideration that is\nimportant mainly in in-line mode.\n\n.. versionadded:: 0.8.2\n   The ``ffi.cdef()`` call takes an optional\n   argument ``packed``: if True, then all structs declared within\n   this cdef are \"packed\".  If you need both packed and non-packed\n   structs, use several cdefs in sequence.)  This\n   has a meaning similar to ``__attribute__((packed))`` in GCC.  It\n   specifies that all structure fields should have an alignment of one\n   byte.  (Note that the packed attribute has no effect on bit fields so\n   far, which mean that they may be packed differently than on GCC.\n   Also, this has no effect on structs declared with ``\"...;\"``---next\n   section.)\n\n.. _`ffi.set_unicode()`:\n\n**ffi.set_unicode(enabled_flag)**: Windows: if ``enabled_flag`` is\nTrue, enable the ``UNICODE`` and ``_UNICODE`` defines in C, and\ndeclare the types ``TBYTE TCHAR LPCTSTR PCTSTR LPTSTR PTSTR PTBYTE\nPTCHAR`` to be (pointers to) ``wchar_t``.  If ``enabled_flag`` is\nFalse, declare these types to be (pointers to) plain 8-bit characters.\n(These types are not predeclared at all if you don't call\n``set_unicode()``.)  *New in version 0.9.*\n\nThe reason behind this method is that a lot of standard functions have\ntwo versions, like ``MessageBoxA()`` and ``MessageBoxW()``.  The\nofficial interface is ``MessageBox()`` with arguments like\n``LPTCSTR``.  Depending on whether ``UNICODE`` is defined or not, the\nstandard header renames the generic function name to one of the two\nspecialized versions, and declares the correct (unicode or not) types.\n\nUsually, the right thing to do is to call this method with True.  Be\naware (particularly on Python 2) that, afterwards, you need to pass unicode\nstrings as arguments instead of not byte strings.  (Before cffi version 0.9,\n``TCHAR`` and friends where hard-coded as unicode, but ``UNICODE`` was,\ninconsistently, not defined by default.)\n\n.. \"versionadded:: 0.9\" --- inlined in the previous paragraph\n\n\nffi.dlopen(): loading libraries in ABI mode\n-------------------------------------------\n\n``ffi.dlopen(libpath, [flags])``: this function opens a shared library and\nreturns a module-like library object.  Use this when you are fine with\nthe limitations of ABI-level access to the system.  In case of doubt, read\nagain `ABI versus API`_ in the overview.\n\n.. _`ABI versus API`: overflow.html#abi-versus-api\n\nYou can use the library object to call the functions previously\ndeclared by ``ffi.cdef()``, to read constants, and to read or write\nglobal variables.  Note that you can use a single ``cdef()`` to\ndeclare functions from multiple libraries, as long as you load each of\nthem with ``dlopen()`` and access the functions from the correct one.\n\nThe ``libpath`` is the file name of the shared library, which can\ncontain a full path or not (in which case it is searched in standard\nlocations, as described in ``man dlopen``), with extensions or not.\nAlternatively, if ``libpath`` is None, it returns the standard C library\n(which can be used to access the functions of glibc, on Linux).\n\nLet me state it again: this gives ABI-level access to the library, so\nyou need to have all types declared manually exactly as they were\nwhile the library was made.  No checking is done.  Mismatches can\ncause random crashes.\n\nNote that only functions and global variables live in library objects;\nthe types exist in the ``ffi`` instance independently of library objects.\nThis is due to the C model: the types you declare in C are not tied to a\nparticular library, as long as you ``#include`` their headers; but you\ncannot call functions from a library without linking it in your program,\nas ``dlopen()`` does dynamically in C.\n\nFor the optional ``flags`` argument, see ``man dlopen`` (ignored on\nWindows).  It defaults to ``ffi.RTLD_NOW``.\n\nThis function returns a \"library\" object that gets closed when it goes\nout of scope.  Make sure you keep the library object around as long as\nneeded.  (Alternatively, the out-of-line FFIs have a method\n``ffi.dlclose(lib)``.)\n\n.. _dlopen-note:\n\nNote: the old version of ``ffi.dlopen()`` from the in-line ABI mode\ntries to use ``ctypes.util.find_library()`` if it cannot directly find\nthe library.  The newer out-of-line ``ffi.dlopen()`` no longer does it\nautomatically; it simply passes the argument it receives to the\nunderlying ``dlopen()`` or ``LoadLibrary()`` function.  If needed, it\nis up to you to use ``ctypes.util.find_library()`` or any other way to\nlook for the library's filename.  This also means that\n``ffi.dlopen(None)`` no longer work on Windows; try instead\n``ffi.dlopen(ctypes.util.find_library('c'))``.\n\n\nffi.set_source(): preparing out-of-line modules\n-----------------------------------------------\n\n**ffi.set_source(module_name, c_header_source, [\\*\\*keywords...])**:\nprepare the ffi for producing out-of-line an external module called\n``module_name``.  *New in version 1.0.*\n\n``ffi.set_source()`` by itself does not write any file, but merely\nrecords its arguments for later.  It can therefore be called before or\nafter ``ffi.cdef()``.\n\nIn **ABI mode,** you call ``ffi.set_source(module_name, None)``.  The\nargument is the name (or dotted name inside a package) of the Python\nmodule to generate.  In this mode, no C compiler is called.\n\nIn **API mode,** the ``c_header_source`` argument is a string that\nwill be pasted into the .c file generated.  This piece of C code\ntypically contains some ``#include``, but may also contain more,\nlike definitions for custom \"wrapper\" C functions.  The goal is that\nthe .c file can be generated like this::\n\n    // C file \"module_name.c\"\n    #include <Python.h>\n\n    ...c_header_source...\n\n    ...magic code...\n\nwhere the \"magic code\" is automatically generated from the ``cdef()``.\nFor example, if the ``cdef()`` contains ``int foo(int x);`` then the\nmagic code will contain logic to call the function ``foo()`` with an\ninteger argument, itself wrapped inside some CPython or PyPy-specific\ncode.\n\nThe keywords arguments to ``set_source()`` control how the C compiler\nwill be called.  They are passed directly to distutils_ or setuptools_\nand include at least ``sources``, ``include_dirs``, ``define_macros``,\n``undef_macros``, ``libraries``, ``library_dirs``, ``extra_objects``,\n``extra_compile_args`` and ``extra_link_args``.  You typically need at\nleast ``libraries=['foo']`` in order to link with ``libfoo.so`` or\n``libfoo.so.X.Y``, or ``foo.dll`` on Windows.  The ``sources`` is a\nlist of extra .c files compiled and linked together (the file\n``module_name.c`` shown above is always generated and automatically added as the\nfirst argument to ``sources``).  See the distutils documentations for\n`more information about the other arguments`__.\n\n.. __: http://docs.python.org/distutils/setupscript.html#library-options\n.. _distutils: http://docs.python.org/distutils/setupscript.html#describing-extension-modules\n.. _setuptools: https://pythonhosted.org/setuptools/setuptools.html\n\nAn extra keyword argument processed internally is\n``source_extension``, defaulting to ``\".c\"``.  The file generated will\nbe actually called ``module_name + source_extension``.  Example for\nC++ (but note that there are still a few known issues of C-versus-C++\ncompatibility):\n\n.. code-block:: python\n\n    ffi.set_source(\"mymodule\", '''\n    extern \"C\" {\n        int somefunc(int somearg) { return real_cpp_func(somearg); }\n    }\n    ''', source_extension='.cpp')\n\n\nLetting the C compiler fill the gaps\n------------------------------------\n\nIf you are using a C compiler (\"API mode\"), then:\n\n*  functions taking or returning integer or float-point arguments can be\n   misdeclared: if e.g. a function is declared by ``cdef()`` as taking a\n   ``int``, but actually takes a ``long``, then the C compiler handles the\n   difference.\n\n*  other arguments are checked: you get a compilation warning or error\n   if you pass a ``int *`` argument to a function expecting a ``long *``.\n\n*  similarly, most other things declared in the ``cdef()`` are checked,\n   to the best we implemented so far; mistakes give compilation\n   warnings or errors.\n\nMoreover, you can use \"``...``\" (literally, dot-dot-dot) in the\n``cdef()`` at various places, in order to ask the C compiler to fill\nin the details.  These places are:\n\n*  structure declarations: any ``struct { }`` that ends with \"``...;``\" as\n   the last \"field\" is\n   partial: it may be missing fields and/or have them declared out of order.\n   This declaration will be corrected by the compiler.  (But note that you\n   can only access fields that you declared, not others.)  Any ``struct``\n   declaration which doesn't use \"``...``\" is assumed to be exact, but this is\n   checked: you get an error if it is not correct.\n\n*  *New in version 1.1:* integer types: the syntax \"``typedef\n   int... foo_t;``\" declares the type ``foo_t`` as an integer type\n   whose exact size and signedness is not specified.  The compiler will\n   figure it out.  (Note that this requires ``set_source()``; it does\n   not work with ``verify()``.)  The ``int...`` can be replaced with\n   ``long...`` or ``unsigned long long...`` or any other primitive\n   integer type, with no effect.  The type will always map to one of\n   ``(u)int(8,16,32,64)_t`` in Python, but in the generated C code,\n   only ``foo_t`` is used.\n\n*  unknown types: the syntax \"``typedef ... foo_t;``\" declares the type\n   ``foo_t`` as opaque.  Useful mainly for when the API takes and returns\n   ``foo_t *`` without you needing to look inside the ``foo_t``.  Also\n   works with \"``typedef ... *foo_p;``\" which declares the pointer type\n   ``foo_p`` without giving a name to the opaque type itself.  Note that\n   such an opaque struct has no known size, which prevents some operations\n   from working (mostly like in C).  *You cannot use this syntax to\n   declare a specific type, like an integer type!  It declares opaque\n   struct-like types only.*  In some cases you need to say that\n   ``foo_t`` is not opaque, but just a struct where you don't know any\n   field; then you would use \"``typedef struct { ...; } foo_t;``\".\n\n*  array lengths: when used as structure fields or in global variables,\n   arrays can have an unspecified length, as in \"``int n[...];``\".  The\n   length is completed by the C compiler.\n   This is slightly different from \"``int n[];``\", because the latter\n   means that the length is not known even to the C compiler, and thus\n   no attempt is made to complete it.  *New in version 1.1:* support\n   for multidimensional arrays: \"``int n[...][...];``\".\n\n*  enums: if you don't know the exact order (or values) of the declared\n   constants, then use this syntax: \"``enum foo { A, B, C, ... };``\"\n   (with a trailing \"``...``\").  The C compiler will be used to figure\n   out the exact values of the constants.  An alternative syntax is\n   \"``enum foo { A=..., B, C };``\" or even\n   \"``enum foo { A=..., B=..., C=... };``\".  Like\n   with structs, an ``enum`` without \"``...``\" is assumed to\n   be exact, and this is checked.\n\n*  integer constants and macros: you can write in the ``cdef`` the line\n   \"``#define FOO ...``\", with any macro name FOO but with ``...`` as\n   a value.  Provided the macro\n   is defined to be an integer value, this value will be available via\n   an attribute of the library object.  The\n   same effect can be achieved by writing a declaration\n   ``static const int FOO;``.  The latter is more general because it\n   supports other types than integer types (note: the C syntax is then\n   to write the ``const`` together with the variable name, as in\n   ``static char *const FOO;``).\n\nCurrently, it is not supported to find automatically which of the\nvarious integer or float types you need at which place.\nIf a type is named, and an integer type, then use ``typedef\nint... the_type_name;``.  In the case of\nfunction arguments or return type, when it is a simple integer/float\ntype, it may be misdeclared (if you misdeclare a function ``void\nf(long)`` as ``void f(int)``, it still works, but you have to call it\nwith arguments that fit an int).  But it doesn't work any longer for\nmore complex types (e.g. you cannot misdeclare a ``int *`` argument as\n``long *``) or in other locations (e.g. a global array ``int a[5];``\nmust not be misdeclared ``long a[5];``).  CFFI considers `all types listed\nabove`_ as primitive (so ``long long a[5];`` and ``int64_t a[5]`` are\ndifferent declarations).\n\n\nffi.compile() etc.: compiling out-of-line modules\n-------------------------------------------------\n\nYou can use one of the following functions to actually generate the\n.py or .c file prepared with ``ffi.set_source()`` and ``ffi.cdef()``.\n\nNote that these function won't overwrite a .py/.c file with exactly\nthe same content, to preserve the mtime.  In some cases where you need\nthe mtime to be updated anyway, delete the file before calling the\nfunctions.\n\n**ffi.compile(tmpdir='.'):** explicitly generate the .py or .c file,\nand (if .c) compile it.  The output file is (or are) put in the\ndirectory given by ``tmpdir``.  In the examples given here, we use\n``if __name__ == \"__main__\": ffi.compile()`` in the build scripts---if\nthey are directly executed, this makes them rebuild the .py/.c file in\nthe current directory.  (Note: if a package is specified in the call\nto ``set_source()``, then a corresponding subdirectory of the ``tmpdir``\nis used.)\n\n**ffi.emit_python_code(filename):** generate the given .py file (same\nas ``ffi.compile()`` for ABI mode, with an explicitly-named file to\nwrite).  If you choose, you can include this .py file pre-packaged in\nyour own distributions: it is identical for any Python version (2 or\n3).\n\n**ffi.emit_c_code(filename):** generate the given .c file (for API\nmode) without compiling it.  Can be used if you have some other method\nto compile it, e.g. if you want to integrate with some larger build\nsystem that will compile this file for you.  You can also distribute\nthe .c file: unless the build script you used depends on the OS or\nplatform, the .c file itself is generic (it would be exactly the same\nif produced on a different OS, with a different version of CPython, or\nwith PyPy; it is done with generating the appropriate ``#ifdef``).\n\n**ffi.distutils_extension(tmpdir='build', verbose=True):** for\ndistutils-based ``setup.py`` files.  Calling this creates the .c file\nif needed in the given ``tmpdir``, and returns a\n``distutils.core.Extension`` instance.\n\nFor Setuptools, you use instead the line\n``cffi_modules=[\"path/to/foo_build.py:ffi\"]`` in ``setup.py``.  This\nline asks Setuptools to import and use a helper provided by CFFI,\nwhich in turn executes the file ``path/to/foo_build.py`` (as with\n``execfile()``) and looks up its global variable called ``ffi``.  You\ncan also say ``cffi_modules=[\"path/to/foo_build.py:maker\"]``, where\n``maker`` names a global function; it is called with no argument and\nis supposed to return a ``FFI`` object.\n\n\nffi.include(): combining multiple CFFI interfaces\n-------------------------------------------------\n\n**ffi.include(other_ffi)**: includes the typedefs, structs, unions,\nenums and constants defined in another FFI instance.  This is meant\nfor large projects where one CFFI-based interface depends on some\ntypes declared in a different CFFI-based interface.\n\n*Note that you should only use one ffi object per library; the intended\nusage of ffi.include() is if you want to interface with several\ninter-dependent libraries.*  For only one library, make one ``ffi``\nobject.  (You can write several ``cdef()`` calls over the same ``ffi``\nfrom several Python files, if one file would be too large.)\n\nFor out-of-line modules, the ``ffi.include(other_ffi)`` line should\noccur in the build script, and the ``other_ffi`` argument should be\nanother FFI that comes from another build script.  When the two build\nscripts are turned into generated files, say ``_ffi.so`` and\n``_other_ffi.so``, then importing ``_ffi.so`` will internally cause\n``_other_ffi.so`` to be imported.  At that point, the real\ndeclarations from ``_other_ffi.so`` are combined with the real\ndeclarations from ``_ffi.so``.\n\nThe usage of ``ffi.include()`` is the cdef-level equivalent of a\n``#include`` in C, where a part of the program might include types and\nfunctions defined in another part for its own usage.  You can see on\nthe ``ffi`` object (and associated ``lib`` objects on the *including*\nside) the types and constants declared on the included side.  In API\nmode, you can also see the functions and global variables directly.\nIn ABI mode, these must be accessed via the original ``other_lib``\nobject returned by the ``dlopen()`` method on ``other_ffi``.\n\n\nffi.cdef() limitations\n----------------------\n\nAll of the ANSI C *declarations* should be supported in ``cdef()``,\nand some of C99.  (This excludes any ``#include`` or ``#ifdef``.)\nKnown missing features that are GCC or MSVC extensions:\n\n* Any ``__attribute__`` or ``#pragma pack(n)``\n\n* Additional types: complex numbers, special-size floating and fixed\n  point types, vector types, and so on.  You might be able to access an\n  array of complex numbers by declaring it as an array of ``struct\n  my_complex { double real, imag; }``, but in general you should declare\n  them as ``struct { ...; }`` and cannot access them directly.  This\n  means that you cannot call any function which has an argument or\n  return value of this type (this would need added support in libffi).\n  You need to write wrapper functions in C, e.g. ``void\n  foo_wrapper(struct my_complex c) { foo(c.real + c.imag*1j); }``, and\n  call ``foo_wrapper`` rather than ``foo`` directly.\n\n* Thread-local variables (access them via getter/setter functions)\n\n* Function pointers with non-default calling conventions (e.g. on\n  Windows, \"stdcall\").\n\nNote that since version 0.8, declarations like ``int field[];`` in\nstructures are interpreted as variable-length structures.  Declarations\nlike ``int field[...];`` on the other hand are arrays whose length is\ngoing to be completed by the compiler.  You can use ``int field[];``\nfor array fields that are not, in fact, variable-length; it works too,\nbut in this case, as CFFI\nbelieves it cannot ask the C compiler for the length of the array, you\nget reduced safety checks: for example, you risk overwriting the\nfollowing fields by passing too many array items in the constructor.\n\n\nDebugging dlopen'ed C libraries\n-------------------------------\n\nA few C libraries are actually hard to use correctly in a ``dlopen()``\nsetting.  This is because most C libraries are intented for, and tested\nwith, a situation where they are *linked* with another program, using\neither static linking or dynamic linking --- but from a program written\nin C, at start-up, using the linker's capabilities instead of\n``dlopen()``.\n\nThis can occasionally create issues.  You would have the same issues in\nanother setting than CFFI, like with ``ctypes`` or even plain C code that\ncalls ``dlopen()``.  This section contains a few generally useful\nenvironment variables (on Linux) that can help when debugging these\nissues.\n\n**export LD_TRACE_LOADED_OBJECTS=all**\n\n    provides a lot of information, sometimes too much depending on the\n    setting.  Output verbose debugging information about the dynamic\n    linker. If set to ``all`` prints all debugging information it has, if\n    set to ``help`` prints a help message about which categories can be\n    specified in this environment variable\n\n**export LD_VERBOSE=1**\n\n    (glibc since 2.1) If set to a nonempty string, output symbol\n    versioning information about the program if querying information\n    about the program (i.e., either ``LD_TRACE_LOADED_OBJECTS`` has been set,\n    or ``--list`` or ``--verify`` options have been given to the dynamic\n    linker).\n\n**export LD_WARN=1**\n\n    (ELF only)(glibc since 2.1.3) If set to a nonempty string, warn\n    about unresolved symbols.\n\n\nffi.verify(): in-line API-mode\n------------------------------\n\n**ffi.verify()** is supported for backward compatibility, but is\ndeprecated.  ``ffi.verify(c_header_source, tmpdir=.., ext_package=..,\nmodulename=.., flags=.., **kwargs)`` makes and compiles a C file from\nthe ``ffi.cdef()``, like ``ffi.set_source()`` in API mode, and then\nimmediately loads and returns the dynamic library object.  Some\nnon-trivial logic is used to decide if the dynamic library must be\nrecompiled or not; see below for ways to control it.\n\nThe ``c_header_source`` and the extra keyword arguments have the\nsame meaning as in ``ffi.set_source()``.\n\nOne remaining use case for ``ffi.verify()`` would be the following\nhack to find explicitly the size of any type, in bytes, and have it\navailable in Python immediately (e.g. because it is needed in order to\nwrite the rest of the build script):\n\n.. code-block:: python\n\n    ffi = cffi.FFI()\n    ffi.cdef(\"const int mysize;\")\n    lib = ffi.verify(\"const int mysize = sizeof(THE_TYPE);\")\n    print lib.mysize\n\nExtra arguments to ``ffi.verify()``:\n    \n*  ``tmpdir`` controls where the C\n   files are created and compiled. Unless the ``CFFI_TMPDIR`` environment\n   variable is set, the default is\n   ``directory_containing_the_py_file/__pycache__`` using the\n   directory name of the .py file that contains the actual call to\n   ``ffi.verify()``.  (This is a bit of a hack but is generally\n   consistent with the location of the .pyc files for your library.\n   The name ``__pycache__`` itself comes from Python 3.)\n\n*  ``ext_package`` controls in which package the\n   compiled extension module should be looked from.  This is\n   only useful after distributing ffi.verify()-based modules.\n\n*  The ``tag`` argument gives an extra string inserted in the\n   middle of the extension module's name: ``_cffi_<tag>_<hash>``.\n   Useful to give a bit more context, e.g. when debugging.\n\n*  The ``modulename`` argument can be used to force a specific module\n   name, overriding the name ``_cffi_<tag>_<hash>``.  Use with care,\n   e.g. if you are passing variable information to ``verify()`` but\n   still want the module name to be always the same (e.g. absolute\n   paths to local files).  In this case, no hash is computed and if\n   the module name already exists it will be reused without further\n   check.  Be sure to have other means of clearing the ``tmpdir``\n   whenever you change your sources.\n\n* ``source_extension`` has the same meaning as in ``ffi.set_source()``.\n\n*  The optional ``flags`` argument has been added in version 0.9;\n   see ``man dlopen``\n   (ignored on Windows).  It defaults to ``ffi.RTLD_NOW``.  (With\n   ``ffi.set_source()``, you would use ``sys.setdlopenflags()``.)\n\n*  The optional ``relative_to`` argument is useful if you need to list\n   local files passed to the C compiler::\n\n     ext = ffi.verify(..., sources=['foo.c'], relative_to=__file__)\n\n   The line above is roughly the same as::\n\n     ext = ffi.verify(..., sources=['/path/to/this/file/foo.c'])\n\n   except that the default name of the produced library is built from\n   the CRC checkum of the argument ``sources``, as well as most other\n   arguments you give to ``ffi.verify()`` -- but not ``relative_to``.\n   So if you used the second line, it would stop finding the\n   already-compiled library after your project is installed, because\n   the ``'/path/to/this/file'`` suddenly changed.  The first line does\n   not have this problem.\n\nNote that during development, every time you change the C sources that\nyou pass to ``cdef()`` or ``verify()``, then the latter will create a\nnew module file name, based on two CRC32 hashes computed from these\nstrings.  This creates more and more files in the ``__pycache__``\ndirectory.  It is recommended that you clean it up from time to time.\nA nice way to do that is to add, in your test suite, a call to\n``cffi.verifier.cleanup_tmpdir()``.  Alternatively, you can manually\nremove the whole ``__pycache__`` directory.\n\nAn alternative cache directory can be given as the ``tmpdir`` argument\nto ``verify()``, via the environment variable ``CFFI_TMPDIR``, or by\ncalling ``cffi.verifier.set_tmpdir(path)`` prior to calling\n``verify``.\n\n\nUpgrading from CFFI 0.9 to CFFI 1.0\n-----------------------------------\n\nCFFI 1.0 is backward-compatible, but it is still a good idea to\nconsider moving to the out-of-line approach new in 1.0.  Here are the\nsteps.\n\n**ABI mode** if your CFFI project uses ``ffi.dlopen()``:\n\n.. code-block:: python\n\n    import cffi\n\n    ffi = cffi.FFI()\n    ffi.cdef(\"stuff\")\n    lib = ffi.dlopen(\"libpath\")\n\nand *if* the \"stuff\" part is big enough that import time is a concern,\nthen rewrite it as described in `the out-of-line but still ABI mode`__\nabove.  Optionally, see also the `setuptools integration`__ paragraph.\n\n.. __: out-of-line-abi_\n.. __: distutils-setuptools_\n\n\n**API mode** if your CFFI project uses ``ffi.verify()``:\n\n.. code-block:: python\n\n    import cffi\n\n    ffi = cffi.FFI()\n    ffi.cdef(\"stuff\")\n    lib = ffi.verify(\"real C code\")\n\nthen you should really rewrite it as described in `the out-of-line,\nAPI mode`__ above.  It avoids a number of issues that have caused\n``ffi.verify()`` to grow a number of extra arguments over time.  Then\nsee the `distutils or setuptools`__ paragraph.  Also, remember to\nremove the ``ext_package=\"..\"`` from your ``setup.py``, which was\nsometimes needed with ``verify()`` but is just creating confusion with\n``set_source()``.\n\n.. __: out-of-line-api_\n.. __: distutils-setuptools_\n\nThe following example should work both with old (pre-1.0) and new\nversions of CFFI---supporting both is important to run on PyPy,\nbecause CFFI 1.0 does not work in PyPy < 2.6:\n\n.. code-block:: python\n\n    # in a separate file \"package/foo_build.py\"\n    import cffi\n\n    ffi = cffi.FFI()\n    C_HEADER_SRC = '''\n        #include \"somelib.h\"\n    '''\n    C_KEYWORDS = dict(libraries=['somelib'])\n\n    if hasattr(ffi, 'set_source'):\n        ffi.set_source(\"package._foo\", C_HEADER_SRC, **C_KEYWORDS)\n\n    ffi.cdef('''\n        int foo(int);\n    ''')\n\n    if __name__ == \"__main__\":\n        ffi.compile()\n\nAnd in the main program:\n\n.. code-block:: python\n\n    try:\n        from package._foo import ffi, lib\n    except ImportError:\n        from package.foo_build import ffi, C_HEADER_SRC, C_KEYWORDS\n        lib = ffi.verify(C_HEADER_SRC, **C_KEYWORDS)\n\n(FWIW, this latest trick can be used more generally to allow the\nimport to \"work\" even if the ``_foo`` module was not generated.)\n\nWriting a ``setup.py`` script that works both with CFFI 0.9 and 1.0\nrequires explicitly checking the version of CFFI that we can have---it\nis hard-coded as a built-in module in PyPy:\n\n.. code-block:: python\n\n    if '_cffi_backend' in sys.builtin_module_names:   # PyPy\n        import _cffi_backend\n        requires_cffi = \"cffi==\" + _cffi_backend.__version__\n    else:\n        requires_cffi = \"cffi>=1.0.0\"\n\nThen we use the ``requires_cffi`` variable to give different arguments to\n``setup()`` as needed, e.g.:\n\n.. code-block:: python\n\n    if requires_cffi.startswith(\"cffi==0.\"):\n        # backward compatibility: we have \"cffi==0.*\"\n        from package.foo_build import ffi\n        extra_args = dict(\n            ext_modules=[ffi.verifier.get_extension()],\n            ext_packages=\"...\",    # if needed\n        )\n    else:\n        extra_args = dict(\n            setup_requires=[requires_cffi],\n            cffi_modules=['package/foo_build.py:ffi'],\n        )\n    setup(\n        name=...,\n        ...,\n        install_requires=[requires_cffi],\n        **extra_args\n    )\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.1.2-nak3eqkxfunb4z5owzsqogchnaejp7o4/spack-src/doc/source/whatsnew.rst": "======================\nWhat's New\n======================\n\n\n1.1.2\n=====\n\n* ``ffi.gc()``: fixed a race condition in multithreaded programs\n  introduced in 1.1.1\n\n\n1.1.1\n=====\n\n* Out-of-line mode: ``ffi.string()``, ``ffi.buffer()`` and\n  ``ffi.getwinerror()`` didn't accept their arguments as keyword\n  arguments, unlike their in-line mode equivalent.  (It worked in PyPy.)\n\n* Out-of-line ABI mode: documented a restriction__ of ``ffi.dlopen()``\n  when compared to the in-line mode.\n\n* ``ffi.gc()``: when called several times with equal pointers, it was\n  accidentally registering only the last destructor, or even none at\n  all depending on details.  (It was correctly registering all of them\n  only in PyPy, and only with the out-of-line FFIs.)\n\n.. __: cdef.html#dlopen-note\n\n\n1.1.0\n=====\n\n* Out-of-line API mode: we can now declare integer types with\n  ``typedef int... foo_t;``.  The exact size and signedness of ``foo_t``\n  is figured out by the compiler.\n\n* Out-of-line API mode: we can now declare multidimensional arrays\n  (as fields or as globals) with ``int n[...][...]``.  Before, only the\n  outermost dimension would support the ``...`` syntax.\n\n* Out-of-line ABI mode: we now support any constant declaration,\n  instead of only integers whose value is given in the cdef.  Such \"new\"\n  constants, i.e. either non-integers or without a value given in the\n  cdef, must correspond to actual symbols in the lib.  At runtime they\n  are looked up the first time we access them.  This is useful if the\n  library defines ``extern const sometype somename;``.\n\n* ``ffi.addressof(lib, \"func_name\")`` now returns a regular cdata object\n  of type \"pointer to function\".  You can use it on any function from a\n  library in API mode (in ABI mode, all functions are already regular\n  cdata objects).  To support this, you need to recompile your cffi\n  modules.\n\n* Issue #198: in API mode, if you declare constants of a ``struct``\n  type, what you saw from lib.CONSTANT was corrupted.\n\n* Issue #196: ``ffi.set_source(\"package._ffi\", None)`` would\n  incorrectly generate the Python source to ``package._ffi.py`` instead\n  of ``package/_ffi.py``.  Also fixed: in some cases, if the C file was\n  in ``build/foo.c``, the .o file would be put in ``build/build/foo.o``.\n\n\n1.0.3\n=====\n\n* Same as 1.0.2, apart from doc and test fixes on some platforms.\n\n\n1.0.2\n=====\n\n* Variadic C functions (ending in a \"...\" argument) were not supported\n  in the out-of-line ABI mode.  This was a bug---there was even a\n  (non-working) example__ doing exactly that!\n\n.. __: overview.html#out-of-line-abi-level\n\n\n1.0.1\n=====\n\n* ``ffi.set_source()`` crashed if passed a ``sources=[..]`` argument.\n  Fixed by chrippa on pull request #60.\n\n* Issue #193: if we use a struct between the first cdef() where it is\n  declared and another cdef() where its fields are defined, then this\n  definition was ignored.\n\n* Enums were buggy if you used too many \"...\" in their definition.\n\n\n1.0.0\n=====\n\n* The main news item is out-of-line module generation:\n\n  * `for ABI level`_, with ``ffi.dlopen()``\n\n  * `for API level`_, which used to be with ``ffi.verify()``, now deprecated\n\n* (this page will list what is new from all versions from 1.0.0\n  forward.)\n\n.. _`for ABI level`: overview.html#out-of-line-abi-level\n.. _`for API level`: overview.html#out-of-line-api-level\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.1.2-nak3eqkxfunb4z5owzsqogchnaejp7o4/spack-src/doc/source/using.rst": "================================\nUsing the ffi/lib objects\n================================\n\nKeep this page under your pillow.\n\n\n.. _working:\n\nWorking with pointers, structures and arrays\n--------------------------------------------\n\nThe C code's integers and floating-point values are mapped to Python's\nregular ``int``, ``long`` and ``float``.  Moreover, the C type ``char``\ncorresponds to single-character strings in Python.  (If you want it to\nmap to small integers, use either ``signed char`` or ``unsigned char``.)\n\nSimilarly, the C type ``wchar_t`` corresponds to single-character\nunicode strings.  Note that in some situations (a narrow Python build\nwith an underlying 4-bytes wchar_t type), a single wchar_t character\nmay correspond to a pair of surrogates, which is represented as a\nunicode string of length 2.  If you need to convert such a 2-chars\nunicode string to an integer, ``ord(x)`` does not work; use instead\n``int(ffi.cast('wchar_t', x))``.\n\nPointers, structures and arrays are more complex: they don't have an\nobvious Python equivalent.  Thus, they correspond to objects of type\n``cdata``, which are printed for example as\n``<cdata 'struct foo_s *' 0xa3290d8>``.\n\n``ffi.new(ctype, [initializer])``: this function builds and returns a\nnew cdata object of the given ``ctype``.  The ctype is usually some\nconstant string describing the C type.  It must be a pointer or array\ntype.  If it is a pointer, e.g. ``\"int *\"`` or ``struct foo *``, then\nit allocates the memory for one ``int`` or ``struct foo``.  If it is\nan array, e.g. ``int[10]``, then it allocates the memory for ten\n``int``.  In both cases the returned cdata is of type ``ctype``.\n\nThe memory is initially filled with zeros.  An initializer can be given\ntoo, as described later.\n\nExample::\n\n    >>> ffi.new(\"char *\")\n    <cdata 'char *' owning 1 bytes>\n    >>> ffi.new(\"int *\")\n    <cdata 'int *' owning 4 bytes>\n    >>> ffi.new(\"int[10]\")\n    <cdata 'int[10]' owning 40 bytes>\n\nUnlike C, the returned pointer object has *ownership* on the allocated\nmemory: when this exact object is garbage-collected, then the memory is\nfreed.  If, at the level of C, you store a pointer to the memory\nsomewhere else, then make sure you also keep the object alive for as\nlong as needed.  (This also applies if you immediately cast the returned\npointer to a pointer of a different type: only the original object has\nownership, so you must keep it alive.  As soon as you forget it, then\nthe casted pointer will point to garbage!  In other words, the ownership\nrules are attached to the *wrapper* cdata objects: they are not, and\ncannot, be attached to the underlying raw memory.)  Example:\n\n.. code-block:: python\n\n    global_weakkeydict = weakref.WeakKeyDictionary()\n\n    s1   = ffi.new(\"struct foo *\")\n    fld1 = ffi.new(\"struct bar *\")\n    fld2 = ffi.new(\"struct bar *\")\n    s1.thefield1 = fld1\n    s1.thefield2 = fld2\n    # here the 'fld1' and 'fld2' object must not go away,\n    # otherwise 's1.thefield1/2' will point to garbage!\n    global_weakkeydict[s1] = (fld1, fld2)\n    # now 's1' keeps alive 'fld1' and 'fld2'.  When 's1' goes\n    # away, then the weak dictionary entry will be removed.\n\nThe cdata objects support mostly the same operations as in C: you can\nread or write from pointers, arrays and structures.  Dereferencing a\npointer is done usually in C with the syntax ``*p``, which is not valid\nPython, so instead you have to use the alternative syntax ``p[0]``\n(which is also valid C).  Additionally, the ``p.x`` and ``p->x``\nsyntaxes in C both become ``p.x`` in Python.\n\nWe have ``ffi.NULL`` to use in the same places as the C ``NULL``.\nLike the latter, it is actually defined to be ``ffi.cast(\"void *\",\n0)``.  For example, reading a NULL pointer returns a ``<cdata 'type *'\nNULL>``, which you can check for e.g. by comparing it with\n``ffi.NULL``.\n\nThere is no general equivalent to the ``&`` operator in C (because it\nwould not fit nicely in the model, and it does not seem to be needed\nhere).  But see `ffi.addressof()`_.\n\nAny operation that would in C return a pointer or array or struct type\ngives you a fresh cdata object.  Unlike the \"original\" one, these fresh\ncdata objects don't have ownership: they are merely references to\nexisting memory.\n\nAs an exception to the above rule, dereferencing a pointer that owns a\n*struct* or *union* object returns a cdata struct or union object\nthat \"co-owns\" the same memory.  Thus in this case there are two\nobjects that can keep the same memory alive.  This is done for cases where\nyou really want to have a struct object but don't have any convenient\nplace to keep alive the original pointer object (returned by\n``ffi.new()``).\n\nExample:\n\n.. code-block:: python\n\n    # void somefunction(int *);\n\n    x = ffi.new(\"int *\")      # allocate one int, and return a pointer to it\n    x[0] = 42                 # fill it\n    lib.somefunction(x)       # call the C function\n    print x[0]                # read the possibly-changed value\n\nThe equivalent of C casts are provided with ``ffi.cast(\"type\", value)``.\nThey should work in the same cases as they do in C.  Additionally, this\nis the only way to get cdata objects of integer or floating-point type::\n\n    >>> x = ffi.cast(\"int\", 42)\n    >>> x\n    <cdata 'int' 42>\n    >>> int(x)\n    42\n\nTo cast a pointer to an int, cast it to ``intptr_t`` or ``uintptr_t``,\nwhich are defined by C to be large enough integer types (example on 32\nbits)::\n\n    >>> int(ffi.cast(\"intptr_t\", pointer_cdata))    # signed\n    -1340782304\n    >>> int(ffi.cast(\"uintptr_t\", pointer_cdata))   # unsigned\n    2954184992L\n\nThe initializer given as the optional second argument to ``ffi.new()``\ncan be mostly anything that you would use as an initializer for C code,\nwith lists or tuples instead of using the C syntax ``{ .., .., .. }``.\nExample::\n\n    typedef struct { int x, y; } foo_t;\n\n    foo_t v = { 1, 2 };            // C syntax\n    v = ffi.new(\"foo_t *\", [1, 2]) # CFFI equivalent\n\n    foo_t v = { .y=1, .x=2 };                // C99 syntax\n    v = ffi.new(\"foo_t *\", {'y': 1, 'x': 2}) # CFFI equivalent\n\nLike C, arrays of chars can also be initialized from a string, in\nwhich case a terminating null character is appended implicitly::\n\n    >>> x = ffi.new(\"char[]\", \"hello\")\n    >>> x\n    <cdata 'char[]' owning 6 bytes>\n    >>> len(x)        # the actual size of the array\n    6\n    >>> x[5]          # the last item in the array\n    '\\x00'\n    >>> x[0] = 'H'    # change the first item\n    >>> ffi.string(x) # interpret 'x' as a regular null-terminated string\n    'Hello'\n\nSimilarly, arrays of wchar_t can be initialized from a unicode string,\nand calling ``ffi.string()`` on the cdata object returns the current unicode\nstring stored in the wchar_t array (adding surrogates if necessary).\n\nNote that unlike Python lists or tuples, but like C, you *cannot* index in\na C array from the end using negative numbers.\n\nMore generally, the C array types can have their length unspecified in C\ntypes, as long as their length can be derived from the initializer, like\nin C::\n\n    int array[] = { 1, 2, 3, 4 };           // C syntax\n    array = ffi.new(\"int[]\", [1, 2, 3, 4])  # CFFI equivalent\n\nAs an extension, the initializer can also be just a number, giving\nthe length (in case you just want zero-initialization)::\n\n    int array[1000];                  // C syntax\n    array = ffi.new(\"int[1000]\")      # CFFI 1st equivalent\n    array = ffi.new(\"int[]\", 1000)    # CFFI 2nd equivalent\n\nThis is useful if the length is not actually a constant, to avoid things\nlike ``ffi.new(\"int[%d]\" % x)``.  Indeed, this is not recommended:\n``ffi`` normally caches the string ``\"int[]\"`` to not need to re-parse\nit all the time.\n\nThe C99 variable-sized structures are supported too, as long as the\ninitializer says how long the array should be:\n\n.. code-block:: python\n\n    # typedef struct { int x; int y[]; } foo_t;\n\n    p = ffi.new(\"foo_t *\", [5, [6, 7, 8]]) # length 3\n    p = ffi.new(\"foo_t *\", [5, 3])         # length 3 with 0 in the array\n    p = ffi.new(\"foo_t *\", {'y': 3})       # length 3 with 0 everywhere\n\n\nPython 3 support\n----------------\n\nPython 3 is supported, but the main point to note is that the ``char`` C\ntype corresponds to the ``bytes`` Python type, and not ``str``.  It is\nyour responsibility to encode/decode all Python strings to bytes when\npassing them to or receiving them from CFFI.\n\nThis only concerns the ``char`` type and derivative types; other parts\nof the API that accept strings in Python 2 continue to accept strings in\nPython 3.\n\n\nAn example of calling a main-like thing\n---------------------------------------\n\nImagine we have something like this:\n\n.. code-block:: python\n\n   from cffi import FFI\n   ffi = FFI()\n   ffi.cdef(\"\"\"\n      int main_like(int argv, char *argv[]);\n   \"\"\")\n   lib = ffi.dlopen(\"some_library.so\")\n\nNow, everything is simple, except, how do we create the ``char**`` argument\nhere?\nThe first idea:\n\n.. code-block:: python\n\n   lib.main_like(2, [\"arg0\", \"arg1\"])\n\ndoes not work, because the initializer receives two Python ``str`` objects\nwhere it was expecting ``<cdata 'char *'>`` objects.  You need to use\n``ffi.new()`` explicitly to make these objects:\n\n.. code-block:: python\n\n   lib.main_like(2, [ffi.new(\"char[]\", \"arg0\"),\n                     ffi.new(\"char[]\", \"arg1\")])\n\nNote that the two ``<cdata 'char[]'>`` objects are kept alive for the\nduration of the call: they are only freed when the list itself is freed,\nand the list is only freed when the call returns.\n\nIf you want instead to build an \"argv\" variable that you want to reuse,\nthen more care is needed:\n\n.. code-block:: python\n\n   # DOES NOT WORK!\n   argv = ffi.new(\"char *[]\", [ffi.new(\"char[]\", \"arg0\"),\n                               ffi.new(\"char[]\", \"arg1\")])\n\nIn the above example, the inner \"arg0\" string is deallocated as soon\nas \"argv\" is built.  You have to make sure that you keep a reference\nto the inner \"char[]\" objects, either directly or by keeping the list\nalive like this:\n\n.. code-block:: python\n\n   argv_keepalive = [ffi.new(\"char[]\", \"arg0\"),\n                     ffi.new(\"char[]\", \"arg1\")]\n   argv = ffi.new(\"char *[]\", argv_keepalive)\n\n\nFunction calls\n--------------\n\nWhen calling C functions, passing arguments follows mostly the same\nrules as assigning to structure fields, and the return value follows the\nsame rules as reading a structure field.  For example:\n\n.. code-block:: python\n\n    # int foo(short a, int b);\n\n    n = lib.foo(2, 3)     # returns a normal integer\n    lib.foo(40000, 3)     # raises OverflowError\n\nYou can pass to ``char *`` arguments a normal Python string (but don't\npass a normal Python string to functions that take a ``char *``\nargument and may mutate it!):\n\n.. code-block:: python\n\n    # size_t strlen(const char *);\n\n    assert lib.strlen(\"hello\") == 5\n\nYou can also pass unicode strings as ``wchar_t *`` arguments.  Note that\nin general, there is no difference between C argument declarations that\nuse ``type *`` or ``type[]``.  For example, ``int *`` is fully\nequivalent to ``int[]`` or ``int[5]``.  So you can pass an ``int *`` as\na list of integers:\n\n.. code-block:: python\n\n    # void do_something_with_array(int *array);\n\n    lib.do_something_with_array([1, 2, 3, 4, 5])\n\nCFFI supports passing and returning structs to functions and callbacks.\nExample:\n\n.. code-block:: python\n\n    # struct foo_s { int a, b; };\n    # struct foo_s function_returning_a_struct(void);\n\n    myfoo = lib.function_returning_a_struct()\n    # `myfoo`: <cdata 'struct foo_s' owning 8 bytes>\n\nThere are a few (obscure) limitations to the argument types and return\ntype.  You cannot pass directly as argument a union (but a *pointer*\nto a union is fine), nor a struct which uses bitfields (but a\n*pointer* to such a struct is fine).  If you pass a struct (not a\n*pointer* to a struct), the struct type cannot have been declared with\n\"``...;``\" in the ``cdef()``; you need to declare it completely in\n``cdef()``.  You can work around these limitations by writing a C\nfunction with a simpler signature in the C header code passed to\n``ffi.set_source()``, and have this C function call the real one.\n\nAside from these limitations, functions and callbacks can receive and\nreturn structs.\n\nFor performance, API-level functions are not returned as ``<cdata>``\nobjects, but as a different type (on CPython, ``<built-in\nfunction>``).  This means you cannot e.g. pass them to some other C\nfunction expecting a function pointer argument.  Only ``ffi.typeof()``\nworks on them.  To get a cdata containing a regular function pointer,\nuse ``ffi.addressof(lib, \"name\")`` (new in version 1.1).\n\nBefore version 1.1, if you really need a cdata pointer to the function,\nuse the following workaround:\n\n.. code-block:: python\n  \n    ffi.cdef(\"\"\" int (*foo)(int a, int b); \"\"\")\n\ni.e. declare them as pointer-to-function in the cdef (even if they are\nregular functions in the C code).\n\n\nVariadic function calls\n-----------------------\n\nVariadic functions in C (which end with \"``...``\" as their last\nargument) can be declared and called normally, with the exception that\nall the arguments passed in the variable part *must* be cdata objects.\nThis is because it would not be possible to guess, if you wrote this::\n\n    lib.printf(\"hello, %d\\n\", 42)   # doesn't work!\n\nthat you really meant the 42 to be passed as a C ``int``, and not a\n``long`` or ``long long``.  The same issue occurs with ``float`` versus\n``double``.  So you have to force cdata objects of the C type you want,\nif necessary with ``ffi.cast()``:\n\n.. code-block:: python\n  \n    lib.printf(\"hello, %d\\n\", ffi.cast(\"int\", 42))\n    lib.printf(\"hello, %ld\\n\", ffi.cast(\"long\", 42))\n    lib.printf(\"hello, %f\\n\", ffi.cast(\"double\", 42))\n\nBut of course:\n\n.. code-block:: python\n\n    lib.printf(\"hello, %s\\n\", ffi.new(\"char[]\", \"world\"))\n\nNote that if you are using ``dlopen()``, the function declaration in the\n``cdef()`` must match the original one in C exactly, as usual --- in\nparticular, if this function is variadic in C, then its ``cdef()``\ndeclaration must also be variadic.  You cannot declare it in the\n``cdef()`` with fixed arguments instead, even if you plan to only call\nit with these argument types.  The reason is that some architectures\nhave a different calling convention depending on whether the function\nsignature is fixed or not.  (On x86-64, the difference can sometimes be\nseen in PyPy's JIT-generated code if some arguments are ``double``.)\n\nNote that the function signature ``int foo();`` is interpreted by CFFI\nas equivalent to ``int foo(void);``.  This differs from the C standard,\nin which ``int foo();`` is really like ``int foo(...);`` and can be\ncalled with any arguments.  (This feature of C is a pre-C89 relic: the\narguments cannot be accessed at all in the body of ``foo()`` without\nrelying on compiler-specific extensions.  Nowadays virtually all code\nwith ``int foo();`` really means ``int foo(void);``.)\n\n\nCallbacks\n---------\n\nHere is how to make a new ``<cdata>`` object that contains a pointer\nto a function, where that function invokes back a Python function of\nyour choice::\n\n    >>> @ffi.callback(\"int(int, int)\")\n    >>> def myfunc(x, y):\n    ...    return x + y\n    ...\n    >>> myfunc\n    <cdata 'int(*)(int, int)' calling <function myfunc at 0xf757bbc4>>\n\nNote that ``\"int(*)(int, int)\"`` is a C *function pointer* type, whereas\n``\"int(int, int)\"`` is a C *function* type.  Either can be specified to\nffi.callback() and the result is the same.\n\nWarning: like ffi.new(), ffi.callback() returns a cdata that has\nownership of its C data.  (In this case, the necessary C data contains\nthe libffi data structures to do a callback.)  This means that the\ncallback can only be invoked as long as this cdata object is alive.\nIf you store the function pointer into C code, then make sure you also\nkeep this object alive for as long as the callback may be invoked.\nThe easiest way to do that is to always use ``@ffi.callback()`` at\nmodule-level only, and to pass \"context\" information around with\n`ffi.new_handle()`_, if possible.\n\nNote that callbacks of a variadic function type are not supported.  A\nworkaround is to add custom C code.  In the following example, a\ncallback gets a first argument that counts how many extra ``int``\narguments are passed:\n\n.. code-block:: python\n\n    # file \"example_build.py\"\n\n    import cffi\n\n    ffi = cffi.FFI()\n    ffi.cdef(\"\"\"\n        int (*python_callback)(int how_many, int *values);\n        void *const c_callback;   /* pass this const ptr to C routines */\n    \"\"\")\n    lib = ffi.set_source(\"_example\", \"\"\"\n        #include <stdarg.h>\n        #include <alloca.h>\n        static int (*python_callback)(int how_many, int *values);\n        static int c_callback(int how_many, ...) {\n            va_list ap;\n            /* collect the \"...\" arguments into the values[] array */\n            int i, *values = alloca(how_many * sizeof(int));\n            va_start(ap, how_many);\n            for (i=0; i<how_many; i++)\n                values[i] = va_arg(ap, int);\n            va_end(ap);\n            return python_callback(how_many, values);\n        }\n    \"\"\")\n\n.. code-block:: python\n    \n    # file \"example.py\"\n\n    from _example import ffi, lib\n\n    @ffi.callback(\"int(int, int *)\")\n    def python_callback(how_many, values):\n        print values     # a list\n        return 0\n    lib.python_callback = python_callback\n\nWindows: you can't yet specify the calling convention of callbacks.\n(For regular calls, the correct calling convention should be\nautomatically inferred by the C backend.)  Use an indirection, like\nin the example just above.\n\nBe careful when writing the Python callback function: if it returns an\nobject of the wrong type, or more generally raises an exception, then\nthe exception cannot be propagated.  Instead, it is printed to stderr\nand the C-level callback is made to return a default value.\n\nThe returned value in case of errors is 0 or null by default, but can be\nspecified with the ``error`` keyword argument to ``ffi.callback()``:\n\n.. code-block:: python\n\n    @ffi.callback(\"int(int, int)\", error=-1)\n\nIn all cases the exception is printed to stderr, so this should be\nused only as a last-resort solution.\n\nDeprecated: you can also use ``ffi.callback()`` not as a decorator but\ndirectly as ``ffi.callback(\"int(int, int)\", myfunc)``.  This is\ndiscouraged: using this a style, we are more likely to forget the\ncallback object too early, when it is still in use.\n\n\nFFI Interface\n-------------\n\n**ffi.new(cdecl, init=None)**:\nallocate an instance according to the specified C type and return a\npointer to it.  The specified C type must be either a pointer or an\narray: ``new('X *')`` allocates an X and returns a pointer to it,\nwhereas ``new('X[n]')`` allocates an array of n X'es and returns an\narray referencing it (which works mostly like a pointer, like in C).\nYou can also use ``new('X[]', n)`` to allocate an array of a\nnon-constant length n.  See above__ for other valid initializers.\n\n.. __: working_\n\nWhen the returned ``<cdata>`` object goes out of scope, the memory is\nfreed.  In other words the returned ``<cdata>`` object has ownership of\nthe value of type ``cdecl`` that it points to.  This means that the raw\ndata can be used as long as this object is kept alive, but must not be\nused for a longer time.  Be careful about that when copying the\npointer to the memory somewhere else, e.g. into another structure.\n\n**ffi.cast(\"C type\", value)**: similar to a C cast: returns an\ninstance of the named C type initialized with the given value.  The\nvalue is casted between integers or pointers of any type.\n\n**ffi.error**: the Python exception raised in various cases.  (Don't\nconfuse it with ``ffi.errno``.)\n        \n**ffi.errno**: the value of ``errno`` received from the most recent C call\nin this thread, and passed to the following C call.  (This is a property.)\n\n**ffi.getwinerror(code=-1)**: on Windows, in addition to ``errno`` we\nalso save and restore the ``GetLastError()`` value across function\ncalls.  This function returns this error code as a tuple ``(code,\nmessage)``, adding a readable message like Python does when raising\nWindowsError.  If the argument ``code`` is given, format that code into\na message instead of using ``GetLastError()``.  *New in version 0.8.*\n(Note that it is also possible to declare and call the ``GetLastError()``\nfunction as usual.)\n\n.. \"versionadded:: 0.8\" --- inlined in the previous paragraph\n\n**ffi.string(cdata, [maxlen])**: return a Python string (or unicode\nstring) from the 'cdata'.\n\n- If 'cdata' is a pointer or array of characters or bytes, returns the\n  null-terminated string.  The returned string extends until the first\n  null character, or at most 'maxlen' characters.  If 'cdata' is an\n  array then 'maxlen' defaults to its length.  See ``ffi.buffer()`` below\n  for a way to continue past the first null character.  *Python 3:* this\n  returns a ``bytes``, not a ``str``.\n\n- If 'cdata' is a pointer or array of wchar_t, returns a unicode string\n  following the same rules.\n\n- If 'cdata' is a single character or byte or a wchar_t, returns it as a\n  byte string or unicode string.  (Note that in some situation a single\n  wchar_t may require a Python unicode string of length 2.)\n\n- If 'cdata' is an enum, returns the value of the enumerator as a string.\n  If the value is out of range, it is simply returned as the stringified\n  integer.\n\n\n**ffi.buffer(cdata, [size])**: return a buffer object that references\nthe raw C data pointed to by the given 'cdata', of 'size' bytes.  The\n'cdata' must be a pointer or an array.  If unspecified, the size of the\nbuffer is either the size of what ``cdata`` points to, or the whole size\nof the array.  Getting a buffer is useful because you can read from it\nwithout an extra copy, or write into it to change the original value;\nyou can use for example ``file.write()`` and ``file.readinto()`` with\nsuch a buffer (for files opened in binary mode).  (Remember that like in\nC, you can use ``array + index`` to get the pointer to the index'th item of\nan array.)\n\nThe returned object is not a built-in buffer nor memoryview object,\nbecause these objects' API changes too much across Python versions.\nInstead it has the following Python API (a subset of Python 2's\n``buffer``):\n\n- ``buf[:]`` or ``bytes(buf)``: fetch a copy as a regular byte string (or\n  ``buf[start:end]`` for a part)\n\n- ``buf[:] = newstr``: change the original content (or ``buf[start:end]\n  = newstr``)\n\n- ``len(buf), buf[index], buf[index] = newchar``: access as a sequence\n  of characters.\n\nThe buffer object returned by ``ffi.buffer(cdata)`` keeps alive the\n``cdata`` object: if it was originally an owning cdata, then its\nowned memory will not be freed as long as the buffer is alive.\n\n.. versionchanged:: 0.8.2\n   Before version 0.8.2, ``bytes(buf)`` was supported in Python 3 to get\n   the content of the buffer, but on Python 2 it would return the repr\n   ``<_cffi_backend.buffer object>``.  This has been fixed.  But you\n   should avoid using ``str(buf)``: it gives inconsistent results\n   between Python 2 and Python 3 (this is similar to how ``str()``\n   gives inconsistent results on regular byte strings).  Use ``buf[:]``\n   instead.\n\n**ffi.from_buffer(python_buffer)**: return a ``<cdata 'char[]'>`` that\npoints to the data of the given Python object, which must support the\nbuffer interface.  This is the opposite of ``ffi.buffer()``.  It gives\na (read-write) reference to the existing data, not a copy; for this\nreason, and for PyPy compatibility, it does not work with the built-in\ntypes str or unicode or bytearray (or buffers/memoryviews on them).\nIt is meant to be used on objects\ncontaining large quantities of raw data, like ``array.array`` or numpy\narrays.  It supports both the old buffer API (in Python 2.x) and the\nnew memoryview API.  The original object is kept alive (and, in case\nof memoryview, locked) as long as the cdata object returned by\n``ffi.from_buffer()`` is alive.  *New in version 0.9.*\n\n.. \"versionadded:: 0.9\" --- inlined in the previous paragraph\n\n\n**ffi.typeof(\"C type\" or cdata object)**: return an object of type\n``<ctype>`` corresponding to the parsed string, or to the C type of the\ncdata instance.  Usually you don't need to call this function or to\nexplicitly manipulate ``<ctype>`` objects in your code: any place that\naccepts a C type can receive either a string or a pre-parsed ``ctype``\nobject (and because of caching of the string, there is no real\nperformance difference).  It can still be useful in writing typechecks,\ne.g.:\n\n.. code-block:: python\n  \n    def myfunction(ptr):\n        assert ffi.typeof(ptr) is ffi.typeof(\"foo_t*\")\n        ...\n\nNote also that the mapping from strings like ``\"foo_t*\"`` to the\n``<ctype>`` objects is stored in some internal dictionary.  This\nguarantees that there is only one ``<ctype 'foo_t *'>`` object, so you\ncan use the ``is`` operator to compare it.  The downside is that the\ndictionary entries are immortal for now.  In the future, we may add\ntransparent reclamation of old, unused entries.  In the meantime, note\nthat using strings like ``\"int[%d]\" % length`` to name a type will\ncreate many immortal cached entries if called with many different\nlengths.\n\n**ffi.CData, ffi.CType**: the Python type of the objects referred to\nas ``<cdata>`` and ``<ctype>`` in the rest of this document.  Note\nthat some cdata objects may be actually of a subclass of\n``ffi.CData``, and similarly with ctype, so you should check with\n``if isinstance(x, ffi.CData)``.  Also, ``<ctype>`` objects have\na number of attributes for introspection: ``kind`` and ``cname`` are\nalways present, and depending on the kind they may also have\n``item``, ``length``, ``fields``, ``args``, ``result``, ``ellipsis``,\n``abi``, ``elements`` and ``relements``.\n\n**ffi.NULL**: a constant NULL of type ``<cdata 'void *'>``.\n\n**ffi.sizeof(\"C type\" or cdata object)**: return the size of the\nargument in bytes.  The argument can be either a C type, or a cdata object,\nlike in the equivalent ``sizeof`` operator in C.\n\n**ffi.alignof(\"C type\")**: return the natural alignment size in bytes of\nthe argument.  Corresponds to the ``__alignof__`` operator in GCC.\n\n\n**ffi.offsetof(\"C struct or array type\", \\*fields_or_indexes)**: return the\noffset within the struct of the given field.  Corresponds to ``offsetof()``\nin C.\n\n.. versionchanged:: 0.9\n   You can give several field names in case of nested structures.  You\n   can also give numeric values which correspond to array items, in case\n   of a pointer or array type.  For example, ``ffi.offsetof(\"int[5]\", 2)``\n   is equal to the size of two integers, as is ``ffi.offsetof(\"int *\", 2)``.\n\n   \n**ffi.getctype(\"C type\" or <ctype>, extra=\"\")**: return the string\nrepresentation of the given C type.  If non-empty, the \"extra\" string is\nappended (or inserted at the right place in more complicated cases); it\ncan be the name of a variable to declare, or an extra part of the type\nlike ``\"*\"`` or ``\"[5]\"``.  For example\n``ffi.getctype(ffi.typeof(x), \"*\")`` returns the string representation\nof the C type \"pointer to the same type than x\"; and\n``ffi.getctype(\"char[80]\", \"a\") == \"char a[80]\"``.\n\n\n**ffi.gc(cdata, destructor)**: return a new cdata object that points to the\nsame data.  Later, when this new cdata object is garbage-collected,\n``destructor(old_cdata_object)`` will be called.  Example of usage:\n``ptr = ffi.gc(lib.malloc(42), lib.free)``.  Note that like objects\nreturned by ``ffi.new()``, the returned pointer objects have *ownership*,\nwhich means the destructor is called as soon as *this* exact returned\nobject is garbage-collected.\n\nNote that this should be avoided for large memory allocations or\nfor limited resources.  This is particularly true on PyPy: its GC does\nnot know how much memory or how many resources the returned ``ptr``\nholds.  It will only run its GC when enough memory it knows about has\nbeen allocated (and thus run the destructor possibly later than you\nwould expect).  Moreover, the destructor is called in whatever thread\nPyPy is at that moment, which might be a problem for some C libraries.\nIn these cases, consider writing a wrapper class with custom ``__enter__()``\nand ``__exit__()`` methods, allocating and freeing the C data at known\npoints in time, and using it in a ``with`` statement.\n\n\n.. _`ffi.new_handle()`:\n\n**ffi.new_handle(python_object)**: return a non-NULL cdata of type\n``void *`` that contains an opaque reference to ``python_object``.  You\ncan pass it around to C functions or store it into C structures.  Later,\nyou can use **ffi.from_handle(p)** to retrive the original\n``python_object`` from a value with the same ``void *`` pointer.\n*Calling ffi.from_handle(p) is invalid and will likely crash if\nthe cdata object returned by new_handle() is not kept alive!*\n\n(In case you are wondering, this ``void *`` is not a ``PyObject *``\npointer.  This wouldn't make sense on PyPy anyway.)\n\nThe ``ffi.new_handle()/from_handle()`` functions *conceptually* work\nlike this:\n\n* ``new_handle()`` returns a cdata object that contains a reference to\n  the Python object; we call them collectively the \"handle\" cdata\n  objects.  The ``void *`` value in this handle cdata object is random\n  but unique.\n\n* ``from_handle(p)`` searches all live \"handle\" cdata objects for the\n  one that has the same value ``p`` as its ``void *`` value.  It then\n  returns the Python object referenced by that handle cdata object.\n  If none is found, you get \"undefined behavior\" (i.e. crashes).\n\nThe \"handle\" cdata object keeps the Python object alive, similar to\nhow ``ffi.new()`` returns a cdata object that keeps a piece of memory\nalive.  If the handle cdata object *itself* is not alive any more,\nthen the association ``void * -> python_object`` is dead and\n``from_handle()`` will crash.\n\n\n.. _`ffi.addressof()`:\n\n**ffi.addressof(cdata, \\*fields_or_indexes)**: limited equivalent to\nthe '&' operator in C:\n\n1. ``ffi.addressof(<cdata 'struct-or-union'>)`` returns a cdata that\nis a pointer to this struct or union.  The returned pointer is only\nvalid as long as the original ``cdata`` object is; be sure to keep it\nalive if it was obtained directly from ``ffi.new()``.\n\n2. ``ffi.addressof(<cdata>, field-or-index...)`` returns the address\nof a field or array item inside the given structure or array.  In case\nof nested structures or arrays, you can give more than one field or\nindex to look recursively.  Note that ``ffi.addressof(array, index)``\ncan also be expressed as ``array + index``: this is true both in CFFI\nand in C, where ``&array[index]`` is just ``array + index``.\n\n3. ``ffi.addressof(<library>, \"name\")`` returns the address of the\nnamed function or global variable from the given library object.\n*New in version 1.1:* for functions, it returns a regular cdata\nobject containing a pointer to the function.\n\nNote that the case 1. cannot be used to take the address of a\nprimitive or pointer, but only a struct or union.  It would be\ndifficult to implement because only structs and unions are internally\nstored as an indirect pointer to the data.  If you need a C int whose\naddress can be taken, use ``ffi.new(\"int[1]\")`` in the first place;\nsimilarly, for a pointer, use ``ffi.new(\"foo_t *[1]\")``.\n\n\n**ffi.dlopen(libpath, [flags])**: opens and returns a \"handle\" to a\ndynamic library, as a ``<lib>`` object.  See `Preparing and\nDistributing modules`_.\n\n**ffi.dlclose(lib)**: explicitly closes a ``<lib>`` object returned\nby ``ffi.dlopen()``.\n\n**ffi.RLTD_...**: constants: flags for ``ffi.dlopen()``.\n\n.. _`Preparing and Distributing modules`: cdef.html#loading-libraries\n\n\nReference: conversions\n----------------------\n\nThis section documents all the conversions that are allowed when\n*writing into* a C data structure (or passing arguments to a function\ncall), and *reading from* a C data structure (or getting the result of a\nfunction call).  The last column gives the type-specific operations\nallowed.\n\n+---------------+------------------------+------------------+----------------+\n|    C type     |   writing into         | reading from     |other operations|\n+===============+========================+==================+================+\n|   integers    | an integer or anything | a Python int or  | int()          |\n|   and enums   | on which int() works   | long, depending  |                |\n|   `(*****)`   | (but not a float!).    | on the type      |                |\n|               | Must be within range.  |                  |                |\n+---------------+------------------------+------------------+----------------+\n|   ``char``    | a string of length 1   | a string of      | int()          |\n|               | or another <cdata char>| length 1         |                |\n+---------------+------------------------+------------------+----------------+\n|  ``wchar_t``  | a unicode of length 1  | a unicode of     |                |\n|               | (or maybe 2 if         | length 1         | int()          |\n|               | surrogates) or         | (or maybe 2 if   |                |\n|               | another <cdata wchar_t>| surrogates)      |                |\n+---------------+------------------------+------------------+----------------+\n|  ``float``,   | a float or anything on | a Python float   | float(), int() |\n|  ``double``   | which float() works    |                  |                |\n+---------------+------------------------+------------------+----------------+\n|``long double``| another <cdata> with   | a <cdata>, to    | float(), int() |\n|               | a ``long double``, or  | avoid loosing    |                |\n|               | anything on which      | precision `(***)`|                |\n|               | float() works          |                  |                |\n+---------------+------------------------+------------------+----------------+\n|  pointers     | another <cdata> with   | a <cdata>        |``[]`` `(****)`,|\n|               | a compatible type (i.e.|                  |``+``, ``-``,   |\n|               | same type or ``char*`` |                  |bool()          |\n|               | or ``void*``, or as an |                  |                |\n|               | array instead) `(*)`   |                  |                |\n+---------------+------------------------+                  |                |\n|  ``void *``,  | another <cdata> with   |                  |                |\n|  ``char *``   | any pointer or array   |                  |                |\n|               | type                   |                  |                |\n+---------------+------------------------+                  +----------------+\n|  pointers to  | same as pointers       |                  | ``[]``, ``+``, |\n|  structure or |                        |                  | ``-``, bool(), |\n|  union        |                        |                  | and read/write |\n|               |                        |                  | struct fields  |\n+---------------+------------------------+                  +----------------+\n| function      | same as pointers       |                  | bool(),        |\n| pointers      |                        |                  | call `(**)`    |\n+---------------+------------------------+------------------+----------------+\n|  arrays       | a list or tuple of     | a <cdata>        |len(), iter(),  |\n|               | items                  |                  |``[]`` `(****)`,|\n|               |                        |                  |``+``, ``-``    |\n+---------------+------------------------+                  +----------------+\n|  ``char[]``   | same as arrays, or a   |                  | len(), iter(), |\n|               | Python string          |                  | ``[]``, ``+``, |\n|               |                        |                  | ``-``          |\n+---------------+------------------------+                  +----------------+\n| ``wchar_t[]`` | same as arrays, or a   |                  | len(), iter(), |\n|               | Python unicode         |                  | ``[]``,        |\n|               |                        |                  | ``+``, ``-``   |\n|               |                        |                  |                |\n+---------------+------------------------+------------------+----------------+\n| structure     | a list or tuple or     | a <cdata>        | read/write     |\n|               | dict of the field      |                  | fields         |\n|               | values, or a same-type |                  |                |\n|               | <cdata>                |                  |                |\n+---------------+------------------------+                  +----------------+\n| union         | same as struct, but    |                  | read/write     |\n|               | with at most one field |                  | fields         |\n+---------------+------------------------+------------------+----------------+\n\n`(*)` ``item *`` is ``item[]`` in function arguments:\n\n   In a function declaration, as per the C standard, a ``item *``\n   argument is identical to a ``item[]`` argument (and ``ffi.cdef()``\n   doesn't record the difference).  So when you call such a function,\n   you can pass an argument that is accepted by either C type, like\n   for example passing a Python string to a ``char *`` argument\n   (because it works for ``char[]`` arguments) or a list of integers\n   to a ``int *`` argument (it works for ``int[]`` arguments).  Note\n   that even if you want to pass a single ``item``, you need to\n   specify it in a list of length 1; for example, a ``struct point_s\n   *`` argument might be passed as ``[[x, y]]`` or ``[{'x': 5, 'y':\n   10}]``.\n\n   As an optimization, the CPython version of CFFI assumes that a\n   function with a ``char *`` argument to which you pass a Python\n   string will not actually modify the array of characters passed in,\n   and so passes directly a pointer inside the Python string object.\n\n`(**)` C function calls are done with the GIL released.\n\n   Note that we assume that the called functions are *not* using the\n   Python API from Python.h.  For example, we don't check afterwards\n   if they set a Python exception.  You may work around it, but mixing\n   CFFI with ``Python.h`` is not recommended.\n\n`(***)` ``long double`` support:\n\n   We keep ``long double`` values inside a cdata object to avoid\n   loosing precision.  Normal Python floating-point numbers only\n   contain enough precision for a ``double``.  If you really want to\n   convert such an object to a regular Python float (i.e. a C\n   ``double``), call ``float()``.  If you need to do arithmetic on\n   such numbers without any precision loss, you need instead to define\n   and use a family of C functions like ``long double add(long double\n   a, long double b);``.\n\n`(****)` Slicing with ``x[start:stop]``:\n\n   Slicing is allowed, as long as you specify explicitly both ``start``\n   and ``stop`` (and don't give any ``step``).  It gives a cdata\n   object that is a \"view\" of all items from ``start`` to ``stop``.\n   It is a cdata of type \"array\" (so e.g. passing it as an argument to a\n   C function would just convert it to a pointer to the ``start`` item).\n   As with indexing, negative bounds mean really negative indices, like in\n   C.  As for slice assignment, it accepts any iterable, including a list\n   of items or another array-like cdata object, but the length must match.\n   (Note that this behavior differs from initialization: e.g. you can\n   say ``chararray[10:15] = \"hello\"``, but the assigned string must be of\n   exactly the correct length; no implicit null character is added.)\n\n`(*****)` Enums are handled like ints:\n\n   Like C, enum types are mostly int types (unsigned or signed, int or\n   long; note that GCC's first choice is unsigned).  Reading an enum\n   field of a structure, for example, returns you an integer.  To\n   compare their value symbolically, use code like ``if x.field ==\n   lib.FOO``.  If you really want to get their value as a string, use\n   ``ffi.string(ffi.cast(\"the_enum_type\", x.field))``.\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.1.2-nak3eqkxfunb4z5owzsqogchnaejp7o4/spack-src/doc/source/overview.rst": "=======================================================\nOverview\n=======================================================\n\nCFFI can be used in one of four modes: \"ABI\" versus \"API\" level,\neach with \"in-line\" or \"out-of-line\" preparation (or compilation).\n\nThe **ABI mode** accesses libraries at the binary level, whereas the\n**API mode** accesses them with a C compiler.  This is described in\ndetail below__.\n\n.. __: `abi-versus-api`_\n\nIn the **in-line mode,** everything is set up every time you import\nyour Python code.  In the **out-of-line mode,** you have a separate\nstep of preparation (and possibly C compilation) that produces a\nmodule which your main program can then import.\n\n(The examples below assume that you have `installed CFFI`__.)\n\n.. __: installation.html\n\n\nSimple example (ABI level, in-line)\n-----------------------------------\n\n.. code-block:: python\n\n    >>> from cffi import FFI\n    >>> ffi = FFI()\n    >>> ffi.cdef(\"\"\"\n    ...     int printf(const char *format, ...);   // copy-pasted from the man page\n    ... \"\"\")                                  \n    >>> C = ffi.dlopen(None)                     # loads the entire C namespace\n    >>> arg = ffi.new(\"char[]\", \"world\")         # equivalent to C code: char arg[] = \"world\";\n    >>> C.printf(\"hi there, %s!\\n\", arg)         # call printf\n    hi there, world!\n    17                                           # this is the return value\n    >>>\n\nNote that on Python 3 you need to pass byte strings to ``char *``\narguments.  In the above example it would be ``b\"world\"`` and ``b\"hi\nthere, %s!\\n\"``.  In general it is ``somestring.encode(myencoding)``.\n\n\n.. _out-of-line-abi-level:\n\nOut-of-line example (ABI level, out-of-line)\n--------------------------------------------\n\nIn a real program, you would not include the ``ffi.cdef()`` in your\nmain program's modules.  Instead, you can rewrite it as follows.  It\nmassively reduces the import times, because it is slow to parse a\nlarge C header.  It also allows you to do more detailed checkings\nduring build-time without worrying about performance (e.g. calling\n``cdef()`` many times with small pieces of declarations, based\non the version of libraries detected on the system).\n\n.. code-block:: python\n\n    # file \"simple_example_build.py\"\n\n    # Note: this particular example fails before version 1.0.2\n    # because it combines variadic function and ABI level.\n\n    from cffi import FFI\n\n    ffi = FFI()\n    ffi.set_source(\"_simple_example\", None)\n    ffi.cdef(\"\"\"\n        int printf(const char *format, ...);\n    \"\"\")\n\n    if __name__ == \"__main__\":\n        ffi.compile()\n\nRunning it once produces ``_simple_example.py``.  Your main program\nonly imports this generated module, not ``simple_example_build.py``\nany more:\n\n.. code-block:: python\n\n    from _simple_example import ffi\n\n    lib = ffi.dlopen(None)      # Unix: open the standard C library\n    #import ctypes.util         # or, try this on Windows:\n    #lib = ffi.dlopen(ctypes.util.find_library(\"c\"))\n\n    lib.printf(b\"hi there, number %d\\n\", ffi.cast(\"int\", 2))\n\nNote that this ``ffi.dlopen()``, unlike the one from in-line mode,\ndoes not invoke any additional magic to locate the library: it must be\na path name (with or without a directory), as required by the C\n``dlopen()`` or ``LoadLibrary()`` functions.  This means that\n``ffi.dlopen(\"libfoo.so\")`` is ok, but ``ffi.dlopen(\"foo\")`` is not.\nIn the latter case, you could replace it with\n``ffi.dlopen(ctypes.util.find_library(\"foo\"))``.  Also, None is only\nrecognized on Unix to open the standard C library.\n\nFor distribution purposes, remember that there is a new\n``_simple_example.py`` file generated.  You can either include it\nstatically within your project's source files, or, with Setuptools,\nyou can say in the ``setup.py``:\n\n.. code-block:: python\n\n    from setuptools import setup\n\n    setup(\n        ...\n        setup_requires=[\"cffi>=1.0.0\"],\n        cffi_modules=[\"simple_example_build.py:ffi\"],\n        install_requires=[\"cffi>=1.0.0\"],\n    )\n\n\n.. _out-of-line-api-level:\n.. _real-example:\n\nReal example (API level, out-of-line)\n-------------------------------------\n\n.. code-block:: python\n\n    # file \"example_build.py\"\n\n    from cffi import FFI\n    ffi = FFI()\n\n    ffi.set_source(\"_example\",\n        \"\"\" // passed to the real C compiler\n            #include <sys/types.h>\n            #include <pwd.h>\n        \"\"\",\n        libraries=[])   # or a list of libraries to link with\n\n    ffi.cdef(\"\"\"     // some declarations from the man page\n        struct passwd {\n            char *pw_name;\n            ...;     // literally dot-dot-dot\n        };\n        struct passwd *getpwuid(int uid);\n    \"\"\")\n\n    if __name__ == \"__main__\":\n        ffi.compile()\n\nYou need to run the ``example_build.py`` script once to generate\n\"source code\" into the file ``_example.c`` and compile this to a\nregular C extension module.  (CFFI selects either Python or C for the\nmodule to generate based on whether the second argument to\n``set_source()`` is ``None`` or not.)\n\nThen, in your main program, you use:\n\n.. code-block:: python\n\n    from _example import ffi, lib\n\n    p = lib.getpwuid(0)\n    assert ffi.string(p.pw_name) == b'root'\n\nNote that this works independently of the exact C layout of ``struct\npasswd`` (it is \"API level\", as opposed to \"ABI level\").  It requires\na C compiler in order to run ``example_build.py``, but it is much more\nportable than trying to get the details of the fields of ``struct\npasswd`` exactly right.  Similarly, we declared ``getpwuid()`` as\ntaking an ``int`` argument.  On some platforms this might be slightly\nincorrect---but it does not matter.\n\nTo integrate it inside a ``setup.py`` distribution with Setuptools:\n\n.. code-block:: python\n\n    from setuptools import setup\n\n    setup(\n        ...\n        setup_requires=[\"cffi>=1.0.0\"],\n        cffi_modules=[\"example_build.py:ffi\"],\n        install_requires=[\"cffi>=1.0.0\"],\n    )\n\nStruct/Array Example (minimal, in-line)\n---------------------------------------\n\n.. code-block:: python\n\n    from cffi import FFI\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef struct {\n            unsigned char r, g, b;\n        } pixel_t;\n    \"\"\")\n    image = ffi.new(\"pixel_t[]\", 800*600)\n\n    f = open('data', 'rb')     # binary mode -- important\n    f.readinto(ffi.buffer(image))\n    f.close()\n\n    image[100].r = 255\n    image[100].g = 192\n    image[100].b = 128\n\n    f = open('data', 'wb')\n    f.write(ffi.buffer(image))\n    f.close()\n\nThis can be used as a more flexible replacement of the struct_ and\narray_ modules.  You could also call ``ffi.new(\"pixel_t[600][800]\")``\nand get a two-dimensional array.\n\n.. _struct: http://docs.python.org/library/struct.html\n.. _array: http://docs.python.org/library/array.html\n\nThis example also admits an out-of-line equivalent.  It is similar to\n`Out-of-line example (ABI level, out-of-line)`_ above, but without any\ncall to ``ffi.dlopen()``.  In the main program, you write ``from\n_simple_example import ffi`` and then the same content as the in-line\nexample above starting from the line ``image = ffi.new(\"pixel_t[]\",\n800*600)``.\n\n\n.. _performance:\n\nPurely for performance (API level, out-of-line)\n-----------------------------------------------\n\nA variant of the `section above`__ where the goal is not to call an\nexisting C library, but to compile and call some C function written\ndirectly in the build script:\n\n.. __: real-example_\n\n.. code-block:: python\n\n    # file \"example_build.py\"\n\n    from cffi import FFI\n    ffi = FFI()\n\n    ffi.cdef(\"int foo(int *, int *, int);\")\n\n    ffi.set_source(\"_example\",\n    \"\"\"\n        static int foo(int *buffer_in, int *buffer_out, int x)\n        {\n            /* some algorithm that is seriously faster in C than in Python */\n        }\n    \"\"\")\n\n    if __name__ == \"__main__\":\n        ffi.compile()\n\n.. code-block:: python\n\n    # file \"example.py\"\n\n    from _example import ffi, lib\n\n    buffer_in = ffi.new(\"int[]\", 1000)\n    # initialize buffer_in here...\n\n    # easier to do all buffer allocations in Python and pass them to C,\n    # even for output-only arguments\n    buffer_out = ffi.new(\"int[]\", 1000)\n\n    result = lib.foo(buffer_in, buffer_out, 1000)\n\n\nWhat actually happened?\n-----------------------\n\nThe CFFI interface operates on the same level as C - you declare types\nand functions using the same syntax as you would define them in C.  This\nmeans that most of the documentation or examples can be copied straight\nfrom the man pages.\n\nThe declarations can contain **types, functions, constants**\nand **global variables.** What you pass to the ``cdef()`` must not\ncontain more than that; in particular, ``#ifdef`` or ``#include``\ndirectives are not supported.  The cdef in the above examples are just\nthat - they declared \"there is a function in the C level with this\ngiven signature\", or \"there is a struct type with this shape\".\n\nIn the ABI examples, the ``dlopen()`` calls load libraries manually.\nAt the binary level, a program is split into multiple namespaces---a\nglobal one (on some platforms), plus one namespace per library.  So\n``dlopen()`` returns a ``<FFILibrary>`` object, and this object has\ngot as attributes all function, constant and variable symbols that are\ncoming from this library and that have been declared in the\n``cdef()``.\n\nBy opposition, the API examples work like a C program does: the C\nlinker (static or dynamic) is responsible for finding any symbol used.\nYou name the libraries in the ``libraries`` keyword argument to\n``set_source()``.  Other common arguments include ``library_dirs`` and\n``include_dirs``; all these arguments are passed to the standard\ndistutils/setuptools.\n\nThe ``ffi.new()`` lines allocate C objects.  They are filled\nwith zeroes initially, unless the optional second argument is used.\nIf specified, this argument gives an \"initializer\", like you can use\nwith C code to initialize global variables.\n\nThe actual ``lib.*()`` function calls should be obvious: it's like C.\n\n\n.. _abi-versus-api:\n\nABI versus API\n--------------\n\nAccessing the C library at the binary level (\"ABI\") is fraught\nwith problems, particularly on non-Windows platforms.  You are not\nmeant to access fields by guessing where they are in the structures.\n*The C libraries are typically meant to be used with a C compiler.*\n\nThe second example shows how to do that: instead of doing a ``dlopen()``,\nwe use ``set_source(..., \"C header...\")``.  When using this approach\nwe have the advantage that we can use \"``...``\" at various places in\nthe ``cdef()``, and the missing information will be completed with the\nhelp of the C compiler.  Actually, a single C source file is produced,\nwhich contains first the ``C header`` part unmodified, followed by\n\"magic\" C code and declarations derived from the ``cdef()``.  When\nthis C file is compiled, the resulting C extension module will contain\nall the information we need---or the C compiler will give warnings or\nerrors, as usual e.g. if you misdeclare some function's signature.\n\nNote that the ``C header`` part can contain arbitrary C code.  You can\nuse it to declare some more helper functions written in C.  To export\nthese helpers to Python, put their signature in the ``cdef()`` too.\n(You can use the ``static`` C keyword, as in ``static int\nmyhelper(int x) { real_code_here; }``, because these helpers are only\nreferenced from the \"magic\" C code that is generated afterwards in the\nsame C file.)\n\nThis can be used for example to wrap \"crazy\" macros into more standard\nC functions.  The extra layer of C can be useful for other reasons\ntoo, like calling functions that expect some complicated argument\nstructures that you prefer to build in C rather than in Python.  On\nthe other hand, if all you need is to call \"function-like\" macros,\nthen you can directly declare them in the ``cdef()`` as if they were\nfunctions.\n\nThe generated piece of C code should be the same independently on the\nplatform on which you run it, so in simple cases you can simply\ndistribute the pre-generated C code and treat it as a regular C\nextension module.  The special Setuptools lines in the `example\nabove`__ are meant for the more complicated cases where we need to\nregenerate the C sources as well---e.g. because the Python script that\nregenerates this file will itself look around the system to know what\nit should include or not.\n\n.. __: real-example_\n\nNote that the \"API level + in-line\" mode combination is deprecated.\nIt used to be done with ``lib = ffi.verify(\"C header\")``.  The\nout-of-line variant with ``set_source(\"modname\", \"C header\")`` is\npreferred.\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.1.2-nak3eqkxfunb4z5owzsqogchnaejp7o4/spack-src/c/libffi_msvc/win64.obj"
    ],
    "total_files": 141
}