{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.13.0-jlicqgsrlask3n7tsdckxmdwv6d5zp4o/spack-src/demo/manual2.py": "import _cffi_backend\n\nffi = _cffi_backend.FFI(b\"manual2\",\n    _version = 0x2601,\n    _types = b'\\x00\\x00\\x01\\x0D\\x00\\x00\\x07\\x01\\x00\\x00\\x00\\x0F\\x00\\x00\\x00\\x09\\x00\\x00\\x00\\x0B\\x00\\x00\\x01\\x03',\n    _globals = (b'\\xff\\xff\\xff\\x0bAA',0,b'\\xff\\xff\\xff\\x0bBB',-1,b'\\xff\\xff\\xff\\x0bCC',2,b'\\xff\\xff\\xff\\x1fFOO',0x9999999999999999,b'\\x00\\x00\\x00#close',0,b'\\x00\\x00\\x05#stdout',0),\n    _struct_unions = ((b'\\x00\\x00\\x00\\x03\\x00\\x00\\x00\\x00point_s',b'\\x00\\x00\\x01\\x11\\xff\\xff\\xff\\xffx',b'\\x00\\x00\\x01\\x11\\xff\\xff\\xff\\xffy'),),\n    _enums = (b'\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x07myenum_e\\x00AA,BB,CC',),\n    _typenames = (b'\\x00\\x00\\x00\\x01myint_t',),\n)\n\n\n\n# trying it out\nlib = ffi.dlopen(None)\nassert lib.AA == 0\nassert lib.BB == -1\nassert lib.FOO == 0x9999999999999999\nx = lib.close(-42)\nassert x == -1\n\nprint lib.stdout\n\nprint ffi.new(\"struct point_s *\")\nprint ffi.offsetof(\"struct point_s\", \"x\")\nprint ffi.offsetof(\"struct point_s\", \"y\")\nprint ffi.new(\"struct point_s[CC]\")\nassert ffi.sizeof(\"struct point_s[CC]\") == 2 * ffi.sizeof(\"struct point_s\")\n\nprint ffi.cast(\"enum myenum_e\", 2)\nprint ffi.cast(\"myint_t\", -2)\nassert ffi.typeof(\"myint_t\") == ffi.typeof(\"int\")\n\ndel ffi, lib\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.13.0-jlicqgsrlask3n7tsdckxmdwv6d5zp4o/spack-src/demo/readdir.py": "# A Linux-only demo\n#\nimport sys\n\nif not sys.platform.startswith('linux'):\n    raise Exception(\"Linux-only demo\")\n\nfrom _readdir import ffi\nlib = ffi.dlopen(None)\n\n\ndef walk(basefd, path):\n    print '{', path\n    dirfd = lib.openat(basefd, path, 0)\n    if dirfd < 0:\n        # error in openat()\n        return\n    dir = lib.fdopendir(dirfd)\n    dirent = ffi.new(\"struct dirent *\")\n    result = ffi.new(\"struct dirent **\")\n    while True:\n        if lib.readdir_r(dir, dirent, result):\n            # error in readdir_r()\n            break\n        if result[0] == ffi.NULL:\n            break\n        name = ffi.string(dirent.d_name)\n        print '%3d %s' % (dirent.d_type, name)\n        if dirent.d_type == 4 and name != '.' and name != '..':\n            walk(dirfd, name)\n    lib.closedir(dir)\n    print '}'\n\n\nwalk(-1, \"/tmp\")\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.13.0-jlicqgsrlask3n7tsdckxmdwv6d5zp4o/spack-src/demo/cffi-cocoa.py": "# Based on http://cocoawithlove.com/2010/09/minimalist-cocoa-programming.html\n# by Juraj Sukop.  This demo was eventually expanded into a more complete\n# Cocoa library available at https://bitbucket.org/sukop/nspython .\n\nfrom cffi import FFI\n\nffi = FFI()\nffi.cdef('''\n    \n    typedef signed char BOOL;\n    \n    typedef long NSInteger;\n    typedef unsigned long NSUInteger;\n    typedef NSInteger NSApplicationActivationPolicy;\n    typedef NSUInteger NSBackingStoreType;\n    typedef NSUInteger NSStringEncoding;\n    \n    typedef double CGFloat;\n    struct CGPoint {\n        CGFloat x;\n        CGFloat y;\n    };\n    typedef struct CGPoint CGPoint;\n    struct CGSize {\n        CGFloat width;\n        CGFloat height;\n    };\n    typedef struct CGSize CGSize;\n    struct CGRect {\n        CGPoint origin;\n        CGSize size;\n    };\n    typedef struct CGRect CGRect;\n    \n    typedef CGPoint NSPoint;\n    typedef CGSize NSSize;\n    typedef CGRect NSRect;\n    \n    typedef struct objc_class *Class;\n    typedef struct objc_object {\n        Class isa;\n    } *id;\n    typedef struct objc_selector *SEL;\n\n    SEL sel_registerName(const char *str);\n    id objc_getClass(const char *name);\n    id objc_msgSend(id theReceiver, SEL theSelector, ...);\n    \n''')\n\nobjc = ffi.dlopen('objc')\nappkit = ffi.dlopen('AppKit')\n\nnil = ffi.NULL\nYES = ffi.cast('BOOL', 1)\nNO = ffi.cast('BOOL', 0)\n\nNSASCIIStringEncoding = ffi.cast('NSStringEncoding', 1)\nNSApplicationActivationPolicyRegular = ffi.cast('NSApplicationActivationPolicy', 0)\nNSTitledWindowMask = ffi.cast('NSUInteger', 1)\nNSBackingStoreBuffered = ffi.cast('NSBackingStoreType', 2)\n\nNSMakePoint = lambda x, y: ffi.new('NSPoint *', (x, y))[0]\nNSMakeRect = lambda x, y, w, h: ffi.new('NSRect *', ((x, y), (w, h)))[0]\n\nget, send, sel = objc.objc_getClass, objc.objc_msgSend, objc.sel_registerName\nat = lambda s: send(\n    get('NSString'),\n    sel('stringWithCString:encoding:'),\n    ffi.new('char[]', s), NSASCIIStringEncoding)\n\nsend(get('NSAutoreleasePool'), sel('new'))\napp = send(get('NSApplication'), sel('sharedApplication'))\nsend(app, sel('setActivationPolicy:'), NSApplicationActivationPolicyRegular)\n\nmenubar = send(send(get('NSMenu'), sel('new')), sel('autorelease'))\nappMenuItem = send(send(get('NSMenuItem'), sel('new')), sel('autorelease'))\nsend(menubar, sel('addItem:'), appMenuItem)\nsend(app, sel('setMainMenu:'), menubar)\n\nappMenu = send(send(get('NSMenu'), sel('new')), sel('autorelease'))\nappName = send(send(get('NSProcessInfo'), sel('processInfo')), sel('processName'))\nquitTitle = send(at('Quit '), sel('stringByAppendingString:'), appName)\nquitMenuItem = send(send(send(\n            get('NSMenuItem'), sel('alloc')),\n        sel('initWithTitle:action:keyEquivalent:'),\n        quitTitle, sel('terminate:'), at('q')),\n    sel('autorelease'))\nsend(appMenu, sel('addItem:'), quitMenuItem)\nsend(appMenuItem, sel('setSubmenu:'), appMenu)\n\nwindow = send(send(send(\n            get('NSWindow'), sel('alloc')),\n        sel('initWithContentRect:styleMask:backing:defer:'),\n        NSMakeRect(0, 0, 200, 200), NSTitledWindowMask, NSBackingStoreBuffered, NO),\n    sel('autorelease'))\nsend(window, sel('cascadeTopLeftFromPoint:'), NSMakePoint(20, 20))\nsend(window, sel('setTitle:'), appName)\nsend(window, sel('makeKeyAndOrderFront:'), nil)\n\nsend(app, sel('activateIgnoringOtherApps:'), YES)\nsend(app, sel('run'))\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.13.0-jlicqgsrlask3n7tsdckxmdwv6d5zp4o/spack-src/testing/cffi1/test_verify1.py": "import os, sys, math, py\nimport pytest\nfrom cffi import FFI, FFIError, VerificationError, VerificationMissing, model\nfrom cffi import CDefError\nfrom cffi import recompiler\nfrom testing.support import *\nfrom testing.support import _verify\nimport _cffi_backend\n\nlib_m = ['m']\nif sys.platform == 'win32':\n    #there is a small chance this fails on Mingw via environ $CC\n    import distutils.ccompiler\n    if distutils.ccompiler.get_default_compiler() == 'msvc':\n        lib_m = ['msvcrt']\n    extra_compile_args = []      # no obvious -Werror equivalent on MSVC\nelse:\n    if (sys.platform == 'darwin' and\n          [int(x) for x in os.uname()[2].split('.')] >= [11, 0, 0]):\n        # assume a standard clang or gcc\n        extra_compile_args = ['-Werror', '-Wall', '-Wextra', '-Wconversion']\n        # special things for clang\n        extra_compile_args.append('-Qunused-arguments')\n    else:\n        # assume a standard gcc\n        extra_compile_args = ['-Werror', '-Wall', '-Wextra', '-Wconversion',\n                              '-Wno-unused-parameter']\n\nclass FFI(FFI):\n    error = _cffi_backend.FFI.error\n    _extra_compile_args = extra_compile_args\n    _verify_counter = 0\n\n    def verify(self, preamble='', *args, **kwds):\n        # HACK to reuse the tests from ../cffi0/test_verify.py\n        FFI._verify_counter += 1\n        module_name = 'verify%d' % FFI._verify_counter\n        try:\n            del self._assigned_source\n        except AttributeError:\n            pass\n        self.set_source(module_name, preamble)\n        return _verify(self, module_name, preamble, *args,\n                       extra_compile_args=self._extra_compile_args, **kwds)\n\nclass FFI_warnings_not_error(FFI):\n    _extra_compile_args = []\n\n\ndef test_missing_function(ffi=None):\n    # uses the FFI hacked above with '-Werror'\n    if ffi is None:\n        ffi = FFI()\n    ffi.cdef(\"void some_completely_unknown_function();\")\n    try:\n        lib = ffi.verify()\n    except (VerificationError, OSError, ImportError):\n        pass     # expected case: we get a VerificationError\n    else:\n        # but depending on compiler and loader details, maybe\n        # 'lib' could actually be imported but will fail if we\n        # actually try to call the unknown function...  Hard\n        # to test anything more.\n        pass\n\ndef test_missing_function_import_error():\n    # uses the original FFI that just gives a warning during compilation\n    test_missing_function(ffi=FFI_warnings_not_error())\n\ndef test_simple_case():\n    ffi = FFI()\n    ffi.cdef(\"double sin(double x);\")\n    lib = ffi.verify('#include <math.h>', libraries=lib_m)\n    assert lib.sin(1.23) == math.sin(1.23)\n\ndef _Wconversion(cdef, source, **kargs):\n    if sys.platform in ('win32', 'darwin'):\n        py.test.skip(\"needs GCC\")\n    ffi = FFI()\n    ffi.cdef(cdef)\n    py.test.raises(VerificationError, ffi.verify, source, **kargs)\n    extra_compile_args_orig = extra_compile_args[:]\n    extra_compile_args.remove('-Wconversion')\n    try:\n        lib = ffi.verify(source, **kargs)\n    finally:\n        extra_compile_args[:] = extra_compile_args_orig\n    return lib\n\ndef test_Wconversion_unsigned():\n    _Wconversion(\"unsigned foo(void);\",\n                 \"int foo(void) { return -1;}\")\n\ndef test_Wconversion_integer():\n    _Wconversion(\"short foo(void);\",\n                 \"long long foo(void) { return 1<<sizeof(short);}\")\n\ndef test_Wconversion_floating():\n    lib = _Wconversion(\"float sin(double);\",\n                       \"#include <math.h>\", libraries=lib_m)\n    res = lib.sin(1.23)\n    assert res != math.sin(1.23)     # not exact, because of double->float\n    assert abs(res - math.sin(1.23)) < 1E-5\n\ndef test_Wconversion_float2int():\n    _Wconversion(\"int sinf(float);\",\n                 \"#include <math.h>\", libraries=lib_m)\n\ndef test_Wconversion_double2int():\n    _Wconversion(\"int sin(double);\",\n                 \"#include <math.h>\", libraries=lib_m)\n\ndef test_rounding_1():\n    ffi = FFI()\n    ffi.cdef(\"double sinf(float x);\")\n    lib = ffi.verify('#include <math.h>', libraries=lib_m)\n    res = lib.sinf(1.23)\n    assert res != math.sin(1.23)     # not exact, because of double->float\n    assert abs(res - math.sin(1.23)) < 1E-5\n\ndef test_rounding_2():\n    ffi = FFI()\n    ffi.cdef(\"double sin(float x);\")\n    lib = ffi.verify('#include <math.h>', libraries=lib_m)\n    res = lib.sin(1.23)\n    assert res != math.sin(1.23)     # not exact, because of double->float\n    assert abs(res - math.sin(1.23)) < 1E-5\n\ndef test_strlen_exact():\n    ffi = FFI()\n    ffi.cdef(\"size_t strlen(const char *s);\")\n    lib = ffi.verify(\"#include <string.h>\")\n    assert lib.strlen(b\"hi there!\") == 9\n\ndef test_strlen_approximate():\n    lib = _Wconversion(\"int strlen(char *s);\",\n                       \"#include <string.h>\")\n    assert lib.strlen(b\"hi there!\") == 9\n\ndef test_return_approximate():\n    for typename in ['short', 'int', 'long', 'long long']:\n        ffi = FFI()\n        ffi.cdef(\"%s foo(signed char x);\" % typename)\n        lib = ffi.verify(\"signed char foo(signed char x) { return x;}\")\n        assert lib.foo(-128) == -128\n        assert lib.foo(+127) == +127\n\ndef test_strlen_array_of_char():\n    ffi = FFI()\n    ffi.cdef(\"size_t strlen(char[]);\")\n    lib = ffi.verify(\"#include <string.h>\")\n    assert lib.strlen(b\"hello\") == 5\n\ndef test_longdouble():\n    ffi = FFI()\n    ffi.cdef(\"long double sinl(long double x);\")\n    lib = ffi.verify('#include <math.h>', libraries=lib_m)\n    for input in [1.23,\n                  ffi.cast(\"double\", 1.23),\n                  ffi.cast(\"long double\", 1.23)]:\n        x = lib.sinl(input)\n        assert repr(x).startswith(\"<cdata 'long double'\")\n        assert (float(x) - math.sin(1.23)) < 1E-10\n\ndef test_longdouble_precision():\n    # Test that we don't loose any precision of 'long double' when\n    # passing through Python and CFFI.\n    ffi = FFI()\n    ffi.cdef(\"long double step1(long double x);\")\n    SAME_SIZE = ffi.sizeof(\"long double\") == ffi.sizeof(\"double\")\n    lib = ffi.verify(\"\"\"\n        long double step1(long double x)\n        {\n            return 4*x-x*x;\n        }\n    \"\"\")\n    def do(cast_to_double):\n        x = 0.9789\n        for i in range(10000):\n            x = lib.step1(x)\n            if cast_to_double:\n                x = float(x)\n        return float(x)\n\n    more_precise = do(False)\n    less_precise = do(True)\n    if SAME_SIZE:\n        assert more_precise == less_precise\n    else:\n        assert abs(more_precise - less_precise) > 0.1\n        # Check the particular results on Intel\n        import platform\n        if (platform.machine().startswith('i386') or\n            platform.machine().startswith('i486') or\n            platform.machine().startswith('i586') or\n            platform.machine().startswith('i686') or\n            platform.machine().startswith('x86')):\n            assert abs(more_precise - 0.656769) < 0.001\n            assert abs(less_precise - 3.99091) < 0.001\n        else:\n            py.test.skip(\"don't know the very exact precision of 'long double'\")\n\n\nall_primitive_types = model.PrimitiveType.ALL_PRIMITIVE_TYPES\nif sys.platform == 'win32':\n    all_primitive_types = all_primitive_types.copy()\n    del all_primitive_types['ssize_t']\nall_integer_types = sorted(tp for tp in all_primitive_types\n                           if all_primitive_types[tp] == 'i')\nall_float_types = sorted(tp for tp in all_primitive_types\n                            if all_primitive_types[tp] == 'f')\n\ndef all_signed_integer_types(ffi):\n    return [x for x in all_integer_types if int(ffi.cast(x, -1)) < 0]\n\ndef all_unsigned_integer_types(ffi):\n    return [x for x in all_integer_types if int(ffi.cast(x, -1)) > 0]\n\n\ndef test_primitive_category():\n    for typename in all_primitive_types:\n        tp = model.PrimitiveType(typename)\n        C = tp.is_char_type()\n        F = tp.is_float_type()\n        X = tp.is_complex_type()\n        I = tp.is_integer_type()\n        assert C == (typename in ('char', 'wchar_t', 'char16_t', 'char32_t'))\n        assert F == (typename in ('float', 'double', 'long double'))\n        assert X == (typename in ('float _Complex', 'double _Complex'))\n        assert I + F + C + X == 1      # one and only one of them is true\n\ndef test_all_integer_and_float_types():\n    typenames = []\n    for typename in all_primitive_types:\n        if (all_primitive_types[typename] == 'c' or\n            all_primitive_types[typename] == 'j' or    # complex\n            typename == '_Bool' or typename == 'long double'):\n            pass\n        else:\n            typenames.append(typename)\n    #\n    ffi = FFI()\n    ffi.cdef('\\n'.join([\"%s foo_%s(%s);\" % (tp, tp.replace(' ', '_'), tp)\n                       for tp in typenames]))\n    lib = ffi.verify('\\n'.join([\"%s foo_%s(%s x) { return (%s)(x+1); }\" %\n                                (tp, tp.replace(' ', '_'), tp, tp)\n                                for tp in typenames]))\n    for typename in typenames:\n        foo = getattr(lib, 'foo_%s' % typename.replace(' ', '_'))\n        assert foo(42) == 43\n        if sys.version < '3':\n            assert foo(long(44)) == 45\n        assert foo(ffi.cast(typename, 46)) == 47\n        py.test.raises(TypeError, foo, ffi.NULL)\n        #\n        # check for overflow cases\n        if all_primitive_types[typename] == 'f':\n            continue\n        for value in [-2**80, -2**40, -2**20, -2**10, -2**5, -1,\n                      2**5, 2**10, 2**20, 2**40, 2**80]:\n            overflows = int(ffi.cast(typename, value)) != value\n            if overflows:\n                py.test.raises(OverflowError, foo, value)\n            else:\n                assert foo(value) == value + 1\n\ndef test_var_signed_integer_types():\n    ffi = FFI()\n    lst = all_signed_integer_types(ffi)\n    csource = \"\\n\".join([\"%s somevar_%s;\" % (tp, tp.replace(' ', '_'))\n                         for tp in lst])\n    ffi.cdef(csource)\n    lib = ffi.verify(csource)\n    for tp in lst:\n        varname = 'somevar_%s' % tp.replace(' ', '_')\n        sz = ffi.sizeof(tp)\n        max = (1 << (8*sz-1)) - 1\n        min = -(1 << (8*sz-1))\n        setattr(lib, varname, max)\n        assert getattr(lib, varname) == max\n        setattr(lib, varname, min)\n        assert getattr(lib, varname) == min\n        py.test.raises(OverflowError, setattr, lib, varname, max+1)\n        py.test.raises(OverflowError, setattr, lib, varname, min-1)\n\ndef test_var_unsigned_integer_types():\n    ffi = FFI()\n    lst = all_unsigned_integer_types(ffi)\n    csource = \"\\n\".join([\"%s somevar_%s;\" % (tp, tp.replace(' ', '_'))\n                         for tp in lst])\n    ffi.cdef(csource)\n    lib = ffi.verify(csource)\n    for tp in lst:\n        varname = 'somevar_%s' % tp.replace(' ', '_')\n        sz = ffi.sizeof(tp)\n        if tp != '_Bool':\n            max = (1 << (8*sz)) - 1\n        else:\n            max = 1\n        setattr(lib, varname, max)\n        assert getattr(lib, varname) == max\n        setattr(lib, varname, 0)\n        assert getattr(lib, varname) == 0\n        py.test.raises(OverflowError, setattr, lib, varname, max+1)\n        py.test.raises(OverflowError, setattr, lib, varname, -1)\n\ndef test_fn_signed_integer_types():\n    ffi = FFI()\n    lst = all_signed_integer_types(ffi)\n    cdefsrc = \"\\n\".join([\"%s somefn_%s(%s);\" % (tp, tp.replace(' ', '_'), tp)\n                         for tp in lst])\n    ffi.cdef(cdefsrc)\n    verifysrc = \"\\n\".join([\"%s somefn_%s(%s x) { return x; }\" %\n                           (tp, tp.replace(' ', '_'), tp) for tp in lst])\n    lib = ffi.verify(verifysrc)\n    for tp in lst:\n        fnname = 'somefn_%s' % tp.replace(' ', '_')\n        sz = ffi.sizeof(tp)\n        max = (1 << (8*sz-1)) - 1\n        min = -(1 << (8*sz-1))\n        fn = getattr(lib, fnname)\n        assert fn(max) == max\n        assert fn(min) == min\n        py.test.raises(OverflowError, fn, max + 1)\n        py.test.raises(OverflowError, fn, min - 1)\n\ndef test_fn_unsigned_integer_types():\n    ffi = FFI()\n    lst = all_unsigned_integer_types(ffi)\n    cdefsrc = \"\\n\".join([\"%s somefn_%s(%s);\" % (tp, tp.replace(' ', '_'), tp)\n                         for tp in lst])\n    ffi.cdef(cdefsrc)\n    verifysrc = \"\\n\".join([\"%s somefn_%s(%s x) { return x; }\" %\n                           (tp, tp.replace(' ', '_'), tp) for tp in lst])\n    lib = ffi.verify(verifysrc)\n    for tp in lst:\n        fnname = 'somefn_%s' % tp.replace(' ', '_')\n        sz = ffi.sizeof(tp)\n        if tp != '_Bool':\n            max = (1 << (8*sz)) - 1\n        else:\n            max = 1\n        fn = getattr(lib, fnname)\n        assert fn(max) == max\n        assert fn(0) == 0\n        py.test.raises(OverflowError, fn, max + 1)\n        py.test.raises(OverflowError, fn, -1)\n\ndef test_char_type():\n    ffi = FFI()\n    ffi.cdef(\"char foo(char);\")\n    lib = ffi.verify(\"char foo(char x) { return ++x; }\")\n    assert lib.foo(b\"A\") == b\"B\"\n    py.test.raises(TypeError, lib.foo, b\"bar\")\n    py.test.raises(TypeError, lib.foo, \"bar\")\n\ndef test_wchar_type():\n    ffi = FFI()\n    if ffi.sizeof('wchar_t') == 2:\n        uniexample1 = u+'\\u1234'\n        uniexample2 = u+'\\u1235'\n    else:\n        uniexample1 = u+'\\U00012345'\n        uniexample2 = u+'\\U00012346'\n    #\n    ffi.cdef(\"wchar_t foo(wchar_t);\")\n    lib = ffi.verify(\"wchar_t foo(wchar_t x) { return x+1; }\")\n    assert lib.foo(uniexample1) == uniexample2\n\ndef test_no_argument():\n    ffi = FFI()\n    ffi.cdef(\"int foo(void);\")\n    lib = ffi.verify(\"int foo(void) { return 42; }\")\n    assert lib.foo() == 42\n\ndef test_two_arguments():\n    ffi = FFI()\n    ffi.cdef(\"int foo(int, int);\")\n    lib = ffi.verify(\"int foo(int a, int b) { return a - b; }\")\n    assert lib.foo(40, -2) == 42\n\ndef test_macro():\n    ffi = FFI()\n    ffi.cdef(\"int foo(int, int);\")\n    lib = ffi.verify(\"#define foo(a, b) ((a) * (b))\")\n    assert lib.foo(-6, -7) == 42\n\ndef test_ptr():\n    ffi = FFI()\n    ffi.cdef(\"int *foo(int *);\")\n    lib = ffi.verify(\"int *foo(int *a) { return a; }\")\n    assert lib.foo(ffi.NULL) == ffi.NULL\n    p = ffi.new(\"int *\", 42)\n    q = ffi.new(\"int *\", 42)\n    assert lib.foo(p) == p\n    assert lib.foo(q) != p\n\ndef test_bogus_ptr():\n    ffi = FFI()\n    ffi.cdef(\"int *foo(int *);\")\n    lib = ffi.verify(\"int *foo(int *a) { return a; }\")\n    py.test.raises(TypeError, lib.foo, ffi.new(\"short *\", 42))\n\n\ndef test_verify_typedefs():\n    py.test.skip(\"ignored so far\")\n    types = ['signed char', 'unsigned char', 'int', 'long']\n    for cdefed in types:\n        for real in types:\n            ffi = FFI()\n            ffi.cdef(\"typedef %s foo_t;\" % cdefed)\n            if cdefed == real:\n                ffi.verify(\"typedef %s foo_t;\" % real)\n            else:\n                py.test.raises(VerificationError, ffi.verify,\n                               \"typedef %s foo_t;\" % real)\n\ndef test_nondecl_struct():\n    ffi = FFI()\n    ffi.cdef(\"typedef struct foo_s foo_t; int bar(foo_t *);\")\n    lib = ffi.verify(\"typedef struct foo_s foo_t;\\n\"\n                     \"int bar(foo_t *f) { (void)f; return 42; }\\n\")\n    assert lib.bar(ffi.NULL) == 42\n\ndef test_ffi_full_struct():\n    def check(verified_code):\n        ffi = FFI()\n        ffi.cdef(\"struct foo_s { char x; int y; long *z; };\")\n        ffi.verify(verified_code)\n        ffi.new(\"struct foo_s *\", {})\n\n    check(\"struct foo_s { char x; int y; long *z; };\")\n    #\n    if sys.platform != 'win32':  # XXX fixme: only gives warnings\n        py.test.raises(VerificationError, check,\n            \"struct foo_s { char x; int y; int *z; };\")\n    #\n    py.test.raises(VerificationError, check,\n        \"struct foo_s { int y; long *z; };\")     # cdef'ed field x is missing\n    #\n    e = py.test.raises(FFI.error, check,\n                       \"struct foo_s { int y; char x; long *z; };\")\n    assert str(e.value).startswith(\n        \"struct foo_s: wrong offset for field 'x'\"\n        \" (cdef says 0, but C compiler says 4)\")\n    #\n    e = py.test.raises(FFI.error, check,\n        \"struct foo_s { char x; int y; long *z; char extra; };\")\n    assert str(e.value).startswith(\n        \"struct foo_s: wrong total size\"\n        \" (cdef says %d, but C compiler says %d)\" % (\n            8 + FFI().sizeof('long *'),\n            8 + FFI().sizeof('long *') * 2))\n    #\n    # a corner case that we cannot really detect, but where it has no\n    # bad consequences: the size is the same, but there is an extra field\n    # that replaces what is just padding in our declaration above\n    check(\"struct foo_s { char x, extra; int y; long *z; };\")\n    #\n    e = py.test.raises(FFI.error, check,\n        \"struct foo_s { char x; short pad; short y; long *z; };\")\n    assert str(e.value).startswith(\n        \"struct foo_s: wrong size for field 'y'\"\n        \" (cdef says 4, but C compiler says 2)\")\n\ndef test_ffi_nonfull_struct():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n    struct foo_s {\n       int x;\n       ...;\n    };\n    \"\"\")\n    py.test.raises(VerificationMissing, ffi.sizeof, 'struct foo_s')\n    py.test.raises(VerificationMissing, ffi.offsetof, 'struct foo_s', 'x')\n    py.test.raises(VerificationMissing, ffi.new, 'struct foo_s *')\n    ffi.verify(\"\"\"\n    struct foo_s {\n       int a, b, x, c, d, e;\n    };\n    \"\"\")\n    assert ffi.sizeof('struct foo_s') == 6 * ffi.sizeof('int')\n    assert ffi.offsetof('struct foo_s', 'x') == 2 * ffi.sizeof('int')\n\ndef test_ffi_nonfull_alignment():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { char x; ...; };\")\n    ffi.verify(\"struct foo_s { int a, b; char x; };\")\n    assert ffi.sizeof('struct foo_s') == 3 * ffi.sizeof('int')\n    assert ffi.alignof('struct foo_s') == ffi.sizeof('int')\n\ndef _check_field_match(typename, real, expect_mismatch):\n    ffi = FFI()\n    testing_by_size = (expect_mismatch == 'by_size')\n    if testing_by_size:\n        expect_mismatch = ffi.sizeof(typename) != ffi.sizeof(real)\n    ffi.cdef(\"struct foo_s { %s x; ...; };\" % typename)\n    try:\n        ffi.verify(\"struct foo_s { %s x; };\" % real)\n        ffi.new(\"struct foo_s *\", [])  # because some mismatches show up lazily\n    except (VerificationError, ffi.error):\n        if not expect_mismatch:\n            if testing_by_size and typename != real:\n                print(\"ignoring mismatch between %s* and %s* even though \"\n                      \"they have the same size\" % (typename, real))\n                return\n            raise AssertionError(\"unexpected mismatch: %s should be accepted \"\n                                 \"as equal to %s\" % (typename, real))\n    else:\n        if expect_mismatch:\n            raise AssertionError(\"mismatch not detected: \"\n                                 \"%s != %s\" % (typename, real))\n\ndef test_struct_bad_sized_integer():\n    for typename in ['int8_t', 'int16_t', 'int32_t', 'int64_t']:\n        for real in ['int8_t', 'int16_t', 'int32_t', 'int64_t']:\n            _check_field_match(typename, real, \"by_size\")\n\ndef test_struct_bad_sized_float():\n    for typename in all_float_types:\n        for real in all_float_types:\n            _check_field_match(typename, real, \"by_size\")\n\ndef test_struct_signedness_ignored():\n    _check_field_match(\"int\", \"unsigned int\", expect_mismatch=False)\n    _check_field_match(\"unsigned short\", \"signed short\", expect_mismatch=False)\n\ndef test_struct_float_vs_int():\n    if sys.platform == 'win32':\n        py.test.skip(\"XXX fixme: only gives warnings\")\n    ffi = FFI()\n    for typename in all_signed_integer_types(ffi):\n        for real in all_float_types:\n            _check_field_match(typename, real, expect_mismatch=True)\n    for typename in all_float_types:\n        for real in all_signed_integer_types(ffi):\n            _check_field_match(typename, real, expect_mismatch=True)\n\ndef test_struct_array_field():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int a[17]; ...; };\")\n    ffi.verify(\"struct foo_s { int x; int a[17]; int y; };\")\n    assert ffi.sizeof('struct foo_s') == 19 * ffi.sizeof('int')\n    s = ffi.new(\"struct foo_s *\")\n    assert ffi.sizeof(s.a) == 17 * ffi.sizeof('int')\n\ndef test_struct_array_no_length():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int a[]; int y; ...; };\\n\"\n             \"int bar(struct foo_s *);\\n\")\n    lib = ffi.verify(\"struct foo_s { int x; int a[17]; int y; };\\n\"\n                     \"int bar(struct foo_s *f) { return f->a[14]; }\\n\")\n    assert ffi.sizeof('struct foo_s') == 19 * ffi.sizeof('int')\n    s = ffi.new(\"struct foo_s *\")\n    assert ffi.typeof(s.a) is ffi.typeof('int[]')   # implicit max length\n    assert len(s.a) == 18  # max length, computed from the size and start offset\n    s.a[14] = 4242\n    assert lib.bar(s) == 4242\n    # with no declared length, out-of-bound accesses are not detected\n    s.a[17] = -521\n    assert s.y == s.a[17] == -521\n    #\n    s = ffi.new(\"struct foo_s *\", {'a': list(range(17))})\n    assert s.a[16] == 16\n    # overflows at construction time not detected either\n    s = ffi.new(\"struct foo_s *\", {'a': list(range(18))})\n    assert s.y == s.a[17] == 17\n\ndef test_struct_array_guess_length():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int a[...]; };\")\n    ffi.verify(\"struct foo_s { int x; int a[17]; int y; };\")\n    assert ffi.sizeof('struct foo_s') == 19 * ffi.sizeof('int')\n    s = ffi.new(\"struct foo_s *\")\n    assert ffi.sizeof(s.a) == 17 * ffi.sizeof('int')\n    with pytest.raises(IndexError):\n        s.a[17]\n\ndef test_struct_array_c99_1():\n    if sys.platform == 'win32':\n        py.test.skip(\"requires C99\")\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int x; int a[]; };\")\n    ffi.verify(\"struct foo_s { int x; int a[]; };\")\n    assert ffi.sizeof('struct foo_s') == 1 * ffi.sizeof('int')\n    s = ffi.new(\"struct foo_s *\", [424242, 4])\n    assert ffi.sizeof(ffi.typeof(s[0])) == 1 * ffi.sizeof('int')\n    assert ffi.sizeof(s[0]) == 5 * ffi.sizeof('int')\n    # ^^^ explanation: if you write in C: \"char x[5];\", then\n    # \"sizeof(x)\" will evaluate to 5.  The behavior above is\n    # a generalization of that to \"struct foo_s[len(a)=5] x;\"\n    # if you could do that in C.\n    assert s.a[3] == 0\n    s = ffi.new(\"struct foo_s *\", [424242, [-40, -30, -20, -10]])\n    assert ffi.sizeof(s[0]) == 5 * ffi.sizeof('int')\n    assert s.a[3] == -10\n    s = ffi.new(\"struct foo_s *\")\n    assert ffi.sizeof(s[0]) == 1 * ffi.sizeof('int')\n    s = ffi.new(\"struct foo_s *\", [424242])\n    assert ffi.sizeof(s[0]) == 1 * ffi.sizeof('int')\n\ndef test_struct_array_c99_2():\n    if sys.platform == 'win32':\n        py.test.skip(\"requires C99\")\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int x; int a[]; ...; };\")\n    ffi.verify(\"struct foo_s { int x, y; int a[]; };\")\n    assert ffi.sizeof('struct foo_s') == 2 * ffi.sizeof('int')\n    s = ffi.new(\"struct foo_s *\", [424242, 4])\n    assert ffi.sizeof(s[0]) == 6 * ffi.sizeof('int')\n    assert s.a[3] == 0\n    s = ffi.new(\"struct foo_s *\", [424242, [-40, -30, -20, -10]])\n    assert ffi.sizeof(s[0]) == 6 * ffi.sizeof('int')\n    assert s.a[3] == -10\n    s = ffi.new(\"struct foo_s *\")\n    assert ffi.sizeof(s[0]) == 2 * ffi.sizeof('int')\n    s = ffi.new(\"struct foo_s *\", [424242])\n    assert ffi.sizeof(s[0]) == 2 * ffi.sizeof('int')\n\ndef test_struct_ptr_to_array_field():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int (*a)[17]; ...; }; struct bar_s { ...; };\")\n    ffi.verify(\"struct foo_s { int x; int (*a)[17]; int y; };\\n\"\n               \"struct bar_s { int x; int *a; int y; };\")\n    assert ffi.sizeof('struct foo_s') == ffi.sizeof(\"struct bar_s\")\n    s = ffi.new(\"struct foo_s *\")\n    assert ffi.sizeof(s.a) == ffi.sizeof('int(*)[17]') == ffi.sizeof(\"int *\")\n\ndef test_struct_with_bitfield_exact():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int a:2, b:3; };\")\n    ffi.verify(\"struct foo_s { int a:2, b:3; };\")\n    s = ffi.new(\"struct foo_s *\")\n    s.b = 3\n    with pytest.raises(OverflowError):\n        s.b = 4\n    assert s.b == 3\n\ndef test_struct_with_bitfield_enum():\n    ffi = FFI()\n    code = \"\"\"\n        typedef enum { AA, BB, CC } foo_e;\n        typedef struct { foo_e f:2; } foo_s;\n    \"\"\"\n    ffi.cdef(code)\n    ffi.verify(code)\n    s = ffi.new(\"foo_s *\")\n    s.f = 1\n    assert s.f == 1\n    if int(ffi.cast(\"foo_e\", -1)) < 0:\n        two = -2\n    else:\n        two = 2\n    s.f = two\n    assert s.f == two\n\ndef test_unsupported_struct_with_bitfield_ellipsis():\n    ffi = FFI()\n    py.test.raises(NotImplementedError, ffi.cdef,\n                   \"struct foo_s { int a:2, b:3; ...; };\")\n\ndef test_global_constants():\n    ffi = FFI()\n    # use 'static const int', as generally documented, although in this\n    # case the 'static' is completely ignored.\n    ffi.cdef(\"static const int AA, BB, CC, DD;\")\n    lib = ffi.verify(\"#define AA 42\\n\"\n                     \"#define BB (-43)   // blah\\n\"\n                     \"#define CC (22*2)  /* foobar */\\n\"\n                     \"#define DD ((unsigned int)142)  /* foo\\nbar */\\n\")\n    assert lib.AA == 42\n    assert lib.BB == -43\n    assert lib.CC == 44\n    assert lib.DD == 142\n\ndef test_global_const_int_size():\n    # integer constants: ignore the declared type, always just use the value\n    for value in [-2**63, -2**31, -2**15,\n                  2**15-1, 2**15, 2**31-1, 2**31, 2**32-1, 2**32,\n                  2**63-1, 2**63, 2**64-1]:\n        ffi = FFI()\n        if value == int(ffi.cast(\"long long\", value)):\n            if value < 0:\n                vstr = '(-%dLL-1)' % (~value,)\n            else:\n                vstr = '%dLL' % value\n        elif value == int(ffi.cast(\"unsigned long long\", value)):\n            vstr = '%dULL' % value\n        else:\n            raise AssertionError(value)\n        ffi.cdef(\"static const unsigned short AA;\")\n        lib = ffi.verify(\"#define AA %s\\n\" % vstr)\n        assert lib.AA == value\n        assert type(lib.AA) is type(int(lib.AA))\n\ndef test_global_constants_non_int():\n    ffi = FFI()\n    ffi.cdef(\"static char *const PP;\")\n    lib = ffi.verify('static char *const PP = \"testing!\";\\n')\n    assert ffi.typeof(lib.PP) == ffi.typeof(\"char *\")\n    assert ffi.string(lib.PP) == b\"testing!\"\n\ndef test_nonfull_enum():\n    ffi = FFI()\n    ffi.cdef(\"enum ee { EE1, EE2, EE3, ... \\n \\t };\")\n    py.test.raises(VerificationMissing, ffi.cast, 'enum ee', 'EE2')\n    ffi.verify(\"enum ee { EE1=10, EE2, EE3=-10, EE4 };\")\n    assert ffi.string(ffi.cast('enum ee', 11)) == \"EE2\"\n    assert ffi.string(ffi.cast('enum ee', -10)) == \"EE3\"\n    #\n    assert ffi.typeof(\"enum ee\").relements == {'EE1': 10, 'EE2': 11, 'EE3': -10}\n    assert ffi.typeof(\"enum ee\").elements == {10: 'EE1', 11: 'EE2', -10: 'EE3'}\n\ndef test_full_enum():\n    ffi = FFI()\n    ffi.cdef(\"enum ee { EE1, EE2, EE3 };\")\n    lib = ffi.verify(\"enum ee { EE1, EE2, EE3 };\")\n    assert [lib.EE1, lib.EE2, lib.EE3] == [0, 1, 2]\n\ndef test_enum_usage():\n    ffi = FFI()\n    ffi.cdef(\"enum ee { EE1,EE2 }; typedef struct { enum ee x; } *sp;\")\n    lib = ffi.verify(\"enum ee { EE1,EE2 }; typedef struct { enum ee x; } *sp;\")\n    assert lib.EE2 == 1\n    s = ffi.new(\"sp\", [lib.EE2])\n    assert s.x == 1\n    s.x = 17\n    assert s.x == 17\n\ndef test_anonymous_enum():\n    ffi = FFI()\n    ffi.cdef(\"enum { EE1 }; enum { EE2, EE3 };\")\n    lib = ffi.verify(\"enum { EE1 }; enum { EE2, EE3 };\")\n    assert lib.EE1 == 0\n    assert lib.EE2 == 0\n    assert lib.EE3 == 1\n\ndef test_nonfull_anonymous_enum():\n    ffi = FFI()\n    ffi.cdef(\"enum { EE1, ... }; enum { EE3, ... };\")\n    lib = ffi.verify(\"enum { EE2, EE1 }; enum { EE3 };\")\n    assert lib.EE1 == 1\n    assert lib.EE3 == 0\n\ndef test_nonfull_enum_syntax2():\n    ffi = FFI()\n    ffi.cdef(\"enum ee { EE1, EE2=\\t..., EE3 };\")\n    py.test.raises(VerificationMissing, ffi.cast, 'enum ee', 'EE1')\n    ffi.verify(\"enum ee { EE1=10, EE2, EE3=-10, EE4 };\")\n    assert ffi.string(ffi.cast('enum ee', 11)) == 'EE2'\n    assert ffi.string(ffi.cast('enum ee', -10)) == 'EE3'\n    #\n    ffi = FFI()\n    ffi.cdef(\"enum ee { EE1, EE2=\\t... };\")\n    py.test.raises(VerificationMissing, ffi.cast, 'enum ee', 'EE1')\n    ffi.verify(\"enum ee { EE1=10, EE2, EE3=-10, EE4 };\")\n    assert ffi.string(ffi.cast('enum ee', 11)) == 'EE2'\n    #\n    ffi = FFI()\n    ffi.cdef(\"enum ee2 { EE4=..., EE5=..., ... };\")\n    ffi.verify(\"enum ee2 { EE4=-1234-5, EE5 }; \")\n    assert ffi.string(ffi.cast('enum ee2', -1239)) == 'EE4'\n    assert ffi.string(ffi.cast('enum ee2', -1238)) == 'EE5'\n\ndef test_get_set_errno():\n    ffi = FFI()\n    ffi.cdef(\"int foo(int);\")\n    lib = ffi.verify(\"\"\"\n        static int foo(int x)\n        {\n            errno += 1;\n            return x * 7;\n        }\n    \"\"\")\n    ffi.errno = 15\n    assert lib.foo(6) == 42\n    assert ffi.errno == 16\n\ndef test_define_int():\n    ffi = FFI()\n    ffi.cdef(\"#define FOO ...\\n\"\n             \"\\t#\\tdefine\\tBAR\\t...\\t\\n\"\n             \"#define BAZ ...\\n\")\n    lib = ffi.verify(\"#define FOO 42\\n\"\n                     \"#define BAR (-44)\\n\"\n                     \"#define BAZ 0xffffffffffffffffULL\\n\")\n    assert lib.FOO == 42\n    assert lib.BAR == -44\n    assert lib.BAZ == 0xffffffffffffffff\n\ndef test_access_variable():\n    ffi = FFI()\n    ffi.cdef(\"int foo(void);\\n\"\n             \"int somenumber;\")\n    lib = ffi.verify(\"\"\"\n        static int somenumber = 2;\n        static int foo(void) {\n            return somenumber * 7;\n        }\n    \"\"\")\n    assert lib.somenumber == 2\n    assert lib.foo() == 14\n    lib.somenumber = -6\n    assert lib.foo() == -42\n    assert lib.somenumber == -6\n    lib.somenumber = 2   # reset for the next run, if any\n\ndef test_access_address_of_variable():\n    # access the address of 'somenumber': need a trick\n    ffi = FFI()\n    ffi.cdef(\"int somenumber; static int *const somenumberptr;\")\n    lib = ffi.verify(\"\"\"\n        static int somenumber = 2;\n        #define somenumberptr (&somenumber)\n    \"\"\")\n    assert lib.somenumber == 2\n    lib.somenumberptr[0] = 42\n    assert lib.somenumber == 42\n    lib.somenumber = 2    # reset for the next run, if any\n\ndef test_access_array_variable(length=5):\n    ffi = FFI()\n    ffi.cdef(\"int foo(int);\\n\"\n             \"int somenumber[%s];\" % (length,))\n    lib = ffi.verify(\"\"\"\n        static int somenumber[] = {2, 2, 3, 4, 5};\n        static int foo(int i) {\n            return somenumber[i] * 7;\n        }\n    \"\"\")\n    if length == '':\n        # a global variable of an unknown array length is implicitly\n        # transformed into a global pointer variable, because we can only\n        # work with array instances whose length we know.  using a pointer\n        # instead of an array gives the correct effects.\n        assert repr(lib.somenumber).startswith(\"<cdata 'int *' 0x\")\n        py.test.raises(TypeError, len, lib.somenumber)\n    else:\n        assert repr(lib.somenumber).startswith(\"<cdata 'int[%s]' 0x\" % length)\n        assert len(lib.somenumber) == 5\n    assert lib.somenumber[3] == 4\n    assert lib.foo(3) == 28\n    lib.somenumber[3] = -6\n    assert lib.foo(3) == -42\n    assert lib.somenumber[3] == -6\n    assert lib.somenumber[4] == 5\n    lib.somenumber[3] = 4    # reset for the next run, if any\n\ndef test_access_array_variable_length_hidden():\n    test_access_array_variable(length='')\n\ndef test_access_struct_variable():\n    ffi = FFI()\n    ffi.cdef(\"struct foo { int x; ...; };\\n\"\n             \"int foo(int);\\n\"\n             \"struct foo stuff;\")\n    lib = ffi.verify(\"\"\"\n        struct foo { int x, y, z; };\n        static struct foo stuff = {2, 5, 8};\n        static int foo(int i) {\n            switch (i) {\n            case 0: return stuff.x * 7;\n            case 1: return stuff.y * 7;\n            case 2: return stuff.z * 7;\n            }\n            return -1;\n        }\n    \"\"\")\n    assert lib.stuff.x == 2\n    assert lib.foo(0) == 14\n    assert lib.foo(1) == 35\n    assert lib.foo(2) == 56\n    lib.stuff.x = -6\n    assert lib.foo(0) == -42\n    assert lib.foo(1) == 35\n    lib.stuff.x = 2      # reset for the next run, if any\n\ndef test_access_callback():\n    ffi = FFI()\n    ffi.cdef(\"int (*cb)(int);\\n\"\n             \"int foo(int);\\n\"\n             \"void reset_cb(void);\")\n    lib = ffi.verify(\"\"\"\n        static int g(int x) { return x * 7; }\n        static int (*cb)(int);\n        static int foo(int i) { return cb(i) - 1; }\n        static void reset_cb(void) { cb = g; }\n    \"\"\")\n    lib.reset_cb()\n    assert lib.foo(6) == 41\n    my_callback = ffi.callback(\"int(*)(int)\", lambda n: n * 222)\n    lib.cb = my_callback\n    assert lib.foo(4) == 887\n\ndef test_access_callback_function_typedef():\n    ffi = FFI()\n    ffi.cdef(\"typedef int mycallback_t(int);\\n\"\n             \"mycallback_t *cb;\\n\"\n             \"int foo(int);\\n\"\n             \"void reset_cb(void);\")\n    lib = ffi.verify(\"\"\"\n        static int g(int x) { return x * 7; }\n        static int (*cb)(int);\n        static int foo(int i) { return cb(i) - 1; }\n        static void reset_cb(void) { cb = g; }\n    \"\"\")\n    lib.reset_cb()\n    assert lib.foo(6) == 41\n    my_callback = ffi.callback(\"int(*)(int)\", lambda n: n * 222)\n    lib.cb = my_callback\n    assert lib.foo(4) == 887\n\ndef test_call_with_struct_ptr():\n    ffi = FFI()\n    ffi.cdef(\"typedef struct { int x; ...; } foo_t; int foo(foo_t *);\")\n    lib = ffi.verify(\"\"\"\n        typedef struct { int y, x; } foo_t;\n        static int foo(foo_t *f) { return f->x * 7; }\n    \"\"\")\n    f = ffi.new(\"foo_t *\")\n    f.x = 6\n    assert lib.foo(f) == 42\n\ndef test_unknown_type():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef ... token_t;\n        int foo(token_t *);\n        #define TOKEN_SIZE ...\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        typedef float token_t;\n        static int foo(token_t *tk) {\n            if (!tk)\n                return -42;\n            *tk += 1.601f;\n            return (int)*tk;\n        }\n        #define TOKEN_SIZE sizeof(token_t)\n    \"\"\")\n    # we cannot let ffi.new(\"token_t *\") work, because we don't know ahead of\n    # time if it's ok to ask 'sizeof(token_t)' in the C code or not.\n    # See test_unknown_type_2.  Workaround.\n    tkmem = ffi.new(\"char[]\", lib.TOKEN_SIZE)    # zero-initialized\n    tk = ffi.cast(\"token_t *\", tkmem)\n    results = [lib.foo(tk) for i in range(6)]\n    assert results == [1, 3, 4, 6, 8, 9]\n    assert lib.foo(ffi.NULL) == -42\n\ndef test_unknown_type_2():\n    ffi = FFI()\n    ffi.cdef(\"typedef ... token_t;\")\n    lib = ffi.verify(\"typedef struct token_s token_t;\")\n    # assert did not crash, even though 'sizeof(token_t)' is not valid in C.\n\ndef test_unknown_type_3():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef ... *token_p;\n        token_p foo(token_p);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        typedef struct _token_s *token_p;\n        token_p foo(token_p arg) {\n            if (arg)\n                return (token_p)0x12347;\n            else\n                return (token_p)0x12345;\n        }\n    \"\"\")\n    p = lib.foo(ffi.NULL)\n    assert int(ffi.cast(\"intptr_t\", p)) == 0x12345\n    q = lib.foo(p)\n    assert int(ffi.cast(\"intptr_t\", q)) == 0x12347\n\ndef test_varargs():\n    ffi = FFI()\n    ffi.cdef(\"int foo(int x, ...);\")\n    lib = ffi.verify(\"\"\"\n        int foo(int x, ...) {\n            va_list vargs;\n            va_start(vargs, x);\n            x -= va_arg(vargs, int);\n            x -= va_arg(vargs, int);\n            va_end(vargs);\n            return x;\n        }\n    \"\"\")\n    assert lib.foo(50, ffi.cast(\"int\", 5), ffi.cast(\"int\", 3)) == 42\n\ndef test_varargs_exact():\n    if sys.platform == 'win32':\n        py.test.skip(\"XXX fixme: only gives warnings\")\n    ffi = FFI()\n    ffi.cdef(\"int foo(int x, ...);\")\n    py.test.raises(VerificationError, ffi.verify, \"\"\"\n        int foo(long long x, ...) {\n            return x;\n        }\n    \"\"\")\n\ndef test_varargs_struct():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { char a; int b; }; int foo(int x, ...);\")\n    lib = ffi.verify(\"\"\"\n        struct foo_s {\n            char a; int b;\n        };\n        int foo(int x, ...) {\n            va_list vargs;\n            struct foo_s s;\n            va_start(vargs, x);\n            s = va_arg(vargs, struct foo_s);\n            va_end(vargs);\n            return s.a - s.b;\n        }\n    \"\"\")\n    s = ffi.new(\"struct foo_s *\", [b'B', 1])\n    assert lib.foo(50, s[0]) == ord('A')\n\ndef test_autofilled_struct_as_argument():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { long a; double b; ...; };\\n\"\n             \"int foo(struct foo_s);\")\n    lib = ffi.verify(\"\"\"\n        struct foo_s {\n            double b;\n            long a;\n        };\n        int foo(struct foo_s s) {\n            return (int)s.a - (int)s.b;\n        }\n    \"\"\")\n    s = ffi.new(\"struct foo_s *\", [100, 1])\n    assert lib.foo(s[0]) == 99\n    assert lib.foo([100, 1]) == 99\n\ndef test_autofilled_struct_as_argument_dynamic():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { long a; ...; };\\n\"\n             \"int (*foo)(struct foo_s);\")\n    lib = ffi.verify(\"\"\"\n        struct foo_s {\n            double b;\n            long a;\n        };\n        int foo1(struct foo_s s) {\n            return (int)s.a - (int)s.b;\n        }\n        int (*foo)(struct foo_s s) = &foo1;\n    \"\"\")\n    e = py.test.raises(NotImplementedError, lib.foo, \"?\")\n    msg = (\"ctype 'struct foo_s' not supported as argument.  It is a struct \"\n           'declared with \"...;\", but the C calling convention may depend on '\n           \"the missing fields; or, it contains anonymous struct/unions.  \"\n           \"Such structs are only supported as argument \"\n           \"if the function is 'API mode' and non-variadic (i.e. declared \"\n           \"inside ffibuilder.cdef()+ffibuilder.set_source() and not taking \"\n           \"a final '...' argument)\")\n    assert str(e.value) == msg\n\ndef test_func_returns_struct():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        struct foo_s { int aa, bb; };\n        struct foo_s foo(int a, int b);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        struct foo_s { int aa, bb; };\n        struct foo_s foo(int a, int b) {\n            struct foo_s r;\n            r.aa = a*a;\n            r.bb = b*b;\n            return r;\n        }\n    \"\"\")\n    s = lib.foo(6, 7)\n    assert repr(s) == \"<cdata 'struct foo_s' owning 8 bytes>\"\n    assert s.aa == 36\n    assert s.bb == 49\n\ndef test_func_as_funcptr():\n    ffi = FFI()\n    ffi.cdef(\"int *(*const fooptr)(void);\")\n    lib = ffi.verify(\"\"\"\n        int *foo(void) {\n            return (int*)\"foobar\";\n        }\n        int *(*fooptr)(void) = foo;\n    \"\"\")\n    foochar = ffi.cast(\"char *(*)(void)\", lib.fooptr)\n    s = foochar()\n    assert ffi.string(s) == b\"foobar\"\n\ndef test_funcptr_as_argument():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        void qsort(void *base, size_t nel, size_t width,\n            int (*compar)(const void *, const void *));\n    \"\"\")\n    ffi.verify(\"#include <stdlib.h>\")\n\ndef test_func_as_argument():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        void qsort(void *base, size_t nel, size_t width,\n            int compar(const void *, const void *));\n    \"\"\")\n    ffi.verify(\"#include <stdlib.h>\")\n\ndef test_array_as_argument():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        size_t strlen(char string[]);\n    \"\"\")\n    ffi.verify(\"#include <string.h>\")\n\ndef test_enum_as_argument():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        enum foo_e { AA, BB, ... };\n        int foo_func(enum foo_e);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        enum foo_e { AA, CC, BB };\n        int foo_func(enum foo_e e) { return (int)e; }\n    \"\"\")\n    assert lib.foo_func(lib.BB) == 2\n    py.test.raises(TypeError, lib.foo_func, \"BB\")\n\ndef test_enum_as_function_result():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        enum foo_e { AA, BB, ... };\n        enum foo_e foo_func(int x);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        enum foo_e { AA, CC, BB };\n        enum foo_e foo_func(int x) { return (enum foo_e)x; }\n    \"\"\")\n    assert lib.foo_func(lib.BB) == lib.BB == 2\n\ndef test_enum_values():\n    ffi = FFI()\n    ffi.cdef(\"enum enum1_e { AA, BB };\")\n    lib = ffi.verify(\"enum enum1_e { AA, BB };\")\n    assert lib.AA == 0\n    assert lib.BB == 1\n    assert ffi.string(ffi.cast(\"enum enum1_e\", 1)) == 'BB'\n\ndef test_typedef_complete_enum():\n    ffi = FFI()\n    ffi.cdef(\"typedef enum { AA, BB } enum1_t;\")\n    lib = ffi.verify(\"typedef enum { AA, BB } enum1_t;\")\n    assert ffi.string(ffi.cast(\"enum1_t\", 1)) == 'BB'\n    assert lib.AA == 0\n    assert lib.BB == 1\n\ndef test_typedef_broken_complete_enum():\n    # xxx this is broken in old cffis, but works with recompiler.py\n    ffi = FFI()\n    ffi.cdef(\"typedef enum { AA, BB } enum1_t;\")\n    lib = ffi.verify(\"typedef enum { AA, CC, BB } enum1_t;\")\n    assert lib.AA == 0\n    assert lib.BB == 2\n\ndef test_typedef_incomplete_enum():\n    ffi = FFI()\n    ffi.cdef(\"typedef enum { AA, BB, ... } enum1_t;\")\n    lib = ffi.verify(\"typedef enum { AA, CC, BB } enum1_t;\")\n    assert ffi.string(ffi.cast(\"enum1_t\", 1)) == '1'\n    assert ffi.string(ffi.cast(\"enum1_t\", 2)) == 'BB'\n    assert lib.AA == 0\n    assert lib.BB == 2\n\ndef test_typedef_enum_as_argument():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef enum { AA, BB, ... } foo_t;\n        int foo_func(foo_t);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        typedef enum { AA, CC, BB } foo_t;\n        int foo_func(foo_t e) { return (int)e; }\n    \"\"\")\n    assert lib.foo_func(lib.BB) == lib.BB == 2\n    py.test.raises(TypeError, lib.foo_func, \"BB\")\n\ndef test_typedef_enum_as_function_result():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef enum { AA, BB, ... } foo_t;\n        foo_t foo_func(int x);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        typedef enum { AA, CC, BB } foo_t;\n        foo_t foo_func(int x) { return (foo_t)x; }\n    \"\"\")\n    assert lib.foo_func(lib.BB) == lib.BB == 2\n\ndef test_function_typedef():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef double func_t(double);\n        func_t sin;\n    \"\"\")\n    lib = ffi.verify('#include <math.h>', libraries=lib_m)\n    assert lib.sin(1.23) == math.sin(1.23)\n\ndef test_opaque_integer_as_function_result():\n    #import platform\n    #if platform.machine().startswith('sparc'):\n    #    py.test.skip('Breaks horribly on sparc (SIGILL + corrupted stack)')\n    #elif platform.machine() == 'mips64' and sys.maxsize > 2**32:\n    #    py.test.skip('Segfaults on mips64el')\n    # XXX bad abuse of \"struct { ...; }\".  It only works a bit by chance\n    # anyway.  XXX think about something better :-(\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef struct { ...; } myhandle_t;\n        myhandle_t foo(void);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        typedef short myhandle_t;\n        myhandle_t foo(void) { return 42; }\n    \"\"\")\n    h = lib.foo()\n    assert ffi.sizeof(h) == ffi.sizeof(\"short\")\n\ndef test_return_partial_struct():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef struct { int x; ...; } foo_t;\n        foo_t foo(void);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        typedef struct { int y, x; } foo_t;\n        foo_t foo(void) { foo_t r = { 45, 81 }; return r; }\n    \"\"\")\n    h = lib.foo()\n    assert ffi.sizeof(h) == 2 * ffi.sizeof(\"int\")\n    assert h.x == 81\n\ndef test_take_and_return_partial_structs():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef struct { int x; ...; } foo_t;\n        foo_t foo(foo_t, foo_t);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        typedef struct { int y, x; } foo_t;\n        foo_t foo(foo_t a, foo_t b) {\n            foo_t r = { 100, a.x * 5 + b.x * 7 };\n            return r;\n        }\n    \"\"\")\n    args = ffi.new(\"foo_t[3]\")\n    args[0].x = 1000\n    args[2].x = -498\n    h = lib.foo(args[0], args[2])\n    assert ffi.sizeof(h) == 2 * ffi.sizeof(\"int\")\n    assert h.x == 1000 * 5 - 498 * 7\n\ndef test_cannot_name_struct_type():\n    ffi = FFI()\n    ffi.cdef(\"typedef struct { int x; } **sp; void foo(sp);\")\n    e = py.test.raises(VerificationError, ffi.verify,\n                       \"typedef struct { int x; } **sp; void foo(sp x) { }\")\n    assert 'in argument of foo: unknown type name' in str(e.value)\n\ndef test_dont_check_unnamable_fields():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { struct { int x; } someone; };\")\n    ffi.verify(\"struct foo_s { struct { int x; } someone; };\")\n    # assert did not crash\n\ndef test_nested_anonymous_struct_exact():\n    if sys.platform == 'win32':\n        py.test.skip(\"nested anonymous struct/union\")\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        struct foo_s { struct { int a; char b; }; union { char c, d; }; };\n    \"\"\")\n    assert ffi.offsetof(\"struct foo_s\", \"c\") == 2 * ffi.sizeof(\"int\")\n    assert ffi.sizeof(\"struct foo_s\") == 3 * ffi.sizeof(\"int\")\n    ffi.verify(\"\"\"\n        struct foo_s { struct { int a; char b; }; union { char c, d; }; };\n    \"\"\")\n    p = ffi.new(\"struct foo_s *\")\n    assert ffi.sizeof(p[0]) == 3 * ffi.sizeof(\"int\")    # with alignment\n    p.a = 1234567\n    p.b = b'X'\n    p.c = b'Y'\n    assert p.a == 1234567\n    assert p.b == b'X'\n    assert p.c == b'Y'\n    assert p.d == b'Y'\n\ndef test_nested_anonymous_struct_exact_error():\n    if sys.platform == 'win32':\n        py.test.skip(\"nested anonymous struct/union\")\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        struct foo_s { struct { int a; char b; }; union { char c, d; }; };\n    \"\"\")\n    py.test.raises(VerificationError, ffi.verify, \"\"\"\n        struct foo_s { struct { int a; short b; }; union { char c, d; }; };\n    \"\"\")\n    # works fine now\n    #py.test.raises(VerificationError, ffi.verify, \"\"\"\n    #    struct foo_s { struct { int a; char e, b; }; union { char c, d; }; };\n    #\"\"\")\n\ndef test_nested_anonymous_struct_inexact_1():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        struct foo_s { struct { char b; ...; }; union { char c, d; }; };\n    \"\"\")\n    ffi.verify(\"\"\"\n        struct foo_s { int a, padding; char c, d, b; };\n    \"\"\")\n    assert ffi.sizeof(\"struct foo_s\") == 3 * ffi.sizeof(\"int\")\n\ndef test_nested_anonymous_struct_inexact_2():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        struct foo_s { union { char c, d; }; struct { int a; char b; }; ...; };\n    \"\"\")\n    ffi.verify(\"\"\"\n        struct foo_s { int a, padding; char c, d, b; };\n    \"\"\")\n    assert ffi.sizeof(\"struct foo_s\") == 3 * ffi.sizeof(\"int\")\n\ndef test_ffi_union():\n    ffi = FFI()\n    ffi.cdef(\"union foo_u { char x; long *z; };\")\n    ffi.verify(\"union foo_u { char x; int y; long *z; };\")\n\ndef test_ffi_union_partial():\n    ffi = FFI()\n    ffi.cdef(\"union foo_u { char x; ...; };\")\n    ffi.verify(\"union foo_u { char x; int y; };\")\n    assert ffi.sizeof(\"union foo_u\") == 4\n\ndef test_ffi_union_with_partial_struct():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int x; ...; }; union foo_u { struct foo_s s; };\")\n    ffi.verify(\"struct foo_s { int a; int x; }; \"\n               \"union foo_u { char b[32]; struct foo_s s; };\")\n    assert ffi.sizeof(\"struct foo_s\") == 8\n    assert ffi.sizeof(\"union foo_u\") == 32\n\ndef test_ffi_union_partial_2():\n    ffi = FFI()\n    ffi.cdef(\"typedef union { char x; ...; } u1;\")\n    ffi.verify(\"typedef union { char x; int y; } u1;\")\n    assert ffi.sizeof(\"u1\") == 4\n\ndef test_ffi_union_with_partial_struct_2():\n    ffi = FFI()\n    ffi.cdef(\"typedef struct { int x; ...; } s1;\"\n             \"typedef union { s1 s; } u1;\")\n    ffi.verify(\"typedef struct { int a; int x; } s1; \"\n               \"typedef union { char b[32]; s1 s; } u1;\")\n    assert ffi.sizeof(\"s1\") == 8\n    assert ffi.sizeof(\"u1\") == 32\n    assert ffi.offsetof(\"u1\", \"s\") == 0\n\ndef test_ffi_struct_packed():\n    if sys.platform == 'win32':\n        py.test.skip(\"needs a GCC extension\")\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int b; ...; };\")\n    ffi.verify(\"\"\"\n        struct foo_s {\n            char a;\n            int b;\n        } __attribute__((packed));\n    \"\"\")\n\ndef test_tmpdir():\n    import tempfile, os\n    from testing.udir import udir\n    tmpdir = tempfile.mkdtemp(dir=str(udir))\n    ffi = FFI()\n    ffi.cdef(\"int foo(int);\")\n    lib = ffi.verify(\"int foo(int a) { return a + 42; }\", tmpdir=tmpdir)\n    assert os.listdir(tmpdir)\n    assert lib.foo(100) == 142\n\ndef test_relative_to():\n    py.test.skip(\"not available\")\n    import tempfile, os\n    from testing.udir import udir\n    tmpdir = tempfile.mkdtemp(dir=str(udir))\n    ffi = FFI()\n    ffi.cdef(\"int foo(int);\")\n    f = open(os.path.join(tmpdir, 'foo.h'), 'w')\n    f.write(\"int foo(int a) { return a + 42; }\\n\")\n    f.close()\n    lib = ffi.verify('#include \"foo.h\"',\n                     include_dirs=['.'],\n                     relative_to=os.path.join(tmpdir, 'x'))\n    assert lib.foo(100) == 142\n\ndef test_bug1():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef struct tdlhandle_s { ...; } *tdl_handle_t;\n        typedef struct my_error_code_ {\n            tdl_handle_t *rh;\n        } my_error_code_t;\n    \"\"\")\n    ffi.verify(\"\"\"\n        typedef struct tdlhandle_s { int foo; } *tdl_handle_t;\n        typedef struct my_error_code_ {\n            tdl_handle_t *rh;\n        } my_error_code_t;\n    \"\"\")\n\ndef test_bool():\n    if sys.platform == 'win32':\n        py.test.skip(\"_Bool not in MSVC\")\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { _Bool x; };\"\n             \"_Bool foo(_Bool); _Bool (*foop)(_Bool);\")\n    lib = ffi.verify(\"\"\"\n        struct foo_s { _Bool x; };\n        int foo(int arg) {\n            return !arg;\n        }\n        _Bool _foofunc(_Bool x) {\n            return !x;\n        }\n        _Bool (*foop)(_Bool) = _foofunc;\n    \"\"\")\n    p = ffi.new(\"struct foo_s *\")\n    p.x = 1\n    assert p.x is True\n    with pytest.raises(OverflowError):\n        p.x = -1\n    with pytest.raises(TypeError):\n        p.x = 0.0\n    assert lib.foop(1) is False\n    assert lib.foop(True) is False\n    assert lib.foop(0) is True\n    py.test.raises(OverflowError, lib.foop, 42)\n    py.test.raises(TypeError, lib.foop, 0.0)\n    assert lib.foo(1) is False\n    assert lib.foo(True) is False\n    assert lib.foo(0) is True\n    py.test.raises(OverflowError, lib.foo, 42)\n    py.test.raises(TypeError, lib.foo, 0.0)\n    assert int(ffi.cast(\"_Bool\", long(1))) == 1\n    assert int(ffi.cast(\"_Bool\", long(0))) == 0\n    assert int(ffi.cast(\"_Bool\", long(-1))) == 1\n    assert int(ffi.cast(\"_Bool\", 10**200)) == 1\n    assert int(ffi.cast(\"_Bool\", 10**40000)) == 1\n    #\n    class Foo(object):\n        def __int__(self):\n            self.seen = 1\n            return result\n    f = Foo()\n    f.seen = 0\n    result = 42\n    assert int(ffi.cast(\"_Bool\", f)) == 1\n    assert f.seen\n    f.seen = 0\n    result = 0\n    assert int(ffi.cast(\"_Bool\", f)) == 0\n    assert f.seen\n    #\n    py.test.raises(TypeError, ffi.cast, \"_Bool\", [])\n\ndef test_bool_on_long_double():\n    if sys.platform == 'win32':\n        py.test.skip(\"_Bool not in MSVC\")\n    f = 1E-250\n    if f == 0.0 or f*f != 0.0:\n        py.test.skip(\"unexpected precision\")\n    ffi = FFI()\n    ffi.cdef(\"long double square(long double f); _Bool opposite(_Bool);\")\n    lib = ffi.verify(\"long double square(long double f) { return f*f; }\\n\"\n                     \"_Bool opposite(_Bool x) { return !x; }\")\n    f0 = lib.square(0.0)\n    f2 = lib.square(f)\n    f3 = lib.square(f * 2.0)\n    if repr(f2) == repr(f3):\n        py.test.skip(\"long double doesn't have enough precision\")\n    assert float(f0) == float(f2) == float(f3) == 0.0  # too tiny for 'double'\n    assert int(ffi.cast(\"_Bool\", f2)) == 1\n    assert int(ffi.cast(\"_Bool\", f3)) == 1\n    assert int(ffi.cast(\"_Bool\", f0)) == 0\n    py.test.raises(TypeError, lib.opposite, f2)\n\ndef test_cannot_pass_float():\n    for basetype in ['char', 'short', 'int', 'long', 'long long']:\n        for sign in ['signed', 'unsigned']:\n            type = '%s %s' % (sign, basetype)\n            ffi = FFI()\n            ffi.cdef(\"struct foo_s { %s x; };\\n\"\n                     \"int foo(%s);\" % (type, type))\n            lib = ffi.verify(\"\"\"\n                struct foo_s { %s x; };\n                int foo(%s arg) {\n                    return !arg;\n                }\n            \"\"\" % (type, type))\n            p = ffi.new(\"struct foo_s *\")\n            with pytest.raises(TypeError):\n                p.x = 0.0\n            assert lib.foo(42) == 0\n            assert lib.foo(0) == 1\n            py.test.raises(TypeError, lib.foo, 0.0)\n\ndef test_addressof():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        struct point_s { int x, y; };\n        struct foo_s { int z; struct point_s point; };\n        struct point_s sum_coord(struct point_s *);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        struct point_s { int x, y; };\n        struct foo_s { int z; struct point_s point; };\n        struct point_s sum_coord(struct point_s *point) {\n            struct point_s r;\n            r.x = point->x + point->y;\n            r.y = point->x - point->y;\n            return r;\n        }\n    \"\"\")\n    p = ffi.new(\"struct foo_s *\")\n    p.point.x = 16\n    p.point.y = 9\n    py.test.raises(TypeError, lib.sum_coord, p.point)\n    res = lib.sum_coord(ffi.addressof(p.point))\n    assert res.x == 25\n    assert res.y == 7\n    res2 = lib.sum_coord(ffi.addressof(res))\n    assert res2.x == 32\n    assert res2.y == 18\n    py.test.raises(TypeError, lib.sum_coord, res2)\n\ndef test_callback_in_thread():\n    py.test.xfail(\"adapt or remove\")\n    if sys.platform == 'win32':\n        py.test.skip(\"pthread only\")\n    import os, subprocess, imp\n    arg = os.path.join(os.path.dirname(__file__), 'callback_in_thread.py')\n    g = subprocess.Popen([sys.executable, arg,\n                          os.path.dirname(imp.find_module('cffi')[1])])\n    result = g.wait()\n    assert result == 0\n\ndef test_keepalive_lib():\n    py.test.xfail(\"adapt or remove\")\n    ffi = FFI()\n    ffi.cdef(\"int foobar(void);\")\n    lib = ffi.verify(\"int foobar(void) { return 42; }\")\n    func = lib.foobar\n    ffi_r = weakref.ref(ffi)\n    lib_r = weakref.ref(lib)\n    del ffi\n    import gc; gc.collect()       # lib stays alive\n    assert lib_r() is not None\n    assert ffi_r() is not None\n    assert func() == 42\n\ndef test_keepalive_ffi():\n    py.test.xfail(\"adapt or remove\")\n    ffi = FFI()\n    ffi.cdef(\"int foobar(void);\")\n    lib = ffi.verify(\"int foobar(void) { return 42; }\")\n    func = lib.foobar\n    ffi_r = weakref.ref(ffi)\n    lib_r = weakref.ref(lib)\n    del lib\n    import gc; gc.collect()       # ffi stays alive\n    assert ffi_r() is not None\n    assert lib_r() is not None\n    assert func() == 42\n\ndef test_FILE_stored_in_stdout():\n    if not sys.platform.startswith('linux'):\n        py.test.skip(\"likely, we cannot assign to stdout\")\n    ffi = FFI()\n    ffi.cdef(\"int printf(const char *, ...); FILE *setstdout(FILE *);\")\n    lib = ffi.verify(\"\"\"\n        #include <stdio.h>\n        FILE *setstdout(FILE *f) {\n            FILE *result = stdout;\n            stdout = f;\n            return result;\n        }\n    \"\"\")\n    import os\n    fdr, fdw = os.pipe()\n    fw1 = os.fdopen(fdw, 'wb', 256)\n    old_stdout = lib.setstdout(fw1)\n    try:\n        #\n        fw1.write(b\"X\")\n        r = lib.printf(b\"hello, %d!\\n\", ffi.cast(\"int\", 42))\n        fw1.close()\n        assert r == len(\"hello, 42!\\n\")\n        #\n    finally:\n        lib.setstdout(old_stdout)\n    #\n    result = os.read(fdr, 256)\n    os.close(fdr)\n    # the 'X' might remain in the user-level buffer of 'fw1' and\n    # end up showing up after the 'hello, 42!\\n'\n    assert result == b\"Xhello, 42!\\n\" or result == b\"hello, 42!\\nX\"\n\ndef test_FILE_stored_explicitly():\n    ffi = FFI()\n    ffi.cdef(\"int myprintf11(const char *, int); FILE *myfile;\")\n    lib = ffi.verify(\"\"\"\n        #include <stdio.h>\n        FILE *myfile;\n        int myprintf11(const char *out, int value) {\n            return fprintf(myfile, out, value);\n        }\n    \"\"\")\n    import os\n    fdr, fdw = os.pipe()\n    fw1 = os.fdopen(fdw, 'wb', 256)\n    lib.myfile = ffi.cast(\"FILE *\", fw1)\n    #\n    fw1.write(b\"X\")\n    r = lib.myprintf11(b\"hello, %d!\\n\", ffi.cast(\"int\", 42))\n    fw1.close()\n    assert r == len(\"hello, 42!\\n\")\n    #\n    result = os.read(fdr, 256)\n    os.close(fdr)\n    # the 'X' might remain in the user-level buffer of 'fw1' and\n    # end up showing up after the 'hello, 42!\\n'\n    assert result == b\"Xhello, 42!\\n\" or result == b\"hello, 42!\\nX\"\n\ndef test_global_array_with_missing_length():\n    ffi = FFI()\n    ffi.cdef(\"int fooarray[];\")\n    lib = ffi.verify(\"int fooarray[50];\")\n    assert repr(lib.fooarray).startswith(\"<cdata 'int *'\")\n\ndef test_global_array_with_dotdotdot_length():\n    ffi = FFI()\n    ffi.cdef(\"int fooarray[...];\")\n    lib = ffi.verify(\"int fooarray[50];\")\n    assert repr(lib.fooarray).startswith(\"<cdata 'int[50]'\")\n\ndef test_bad_global_array_with_dotdotdot_length():\n    py.test.xfail(\"was detected only because 23 bytes cannot be divided by 4; \"\n                  \"redo more generally\")\n    ffi = FFI()\n    ffi.cdef(\"int fooarray[...];\")\n    py.test.raises(VerificationError, ffi.verify, \"char fooarray[23];\")\n\ndef test_struct_containing_struct():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { ...; }; struct bar_s { struct foo_s f; ...; };\")\n    ffi.verify(\"struct foo_s { int x; }; struct bar_s { struct foo_s f; };\")\n    #\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { struct bar_s f; ...; }; struct bar_s { ...; };\")\n    ffi.verify(\"struct bar_s { int x; }; struct foo_s { struct bar_s f; };\")\n\ndef test_struct_returned_by_func():\n    ffi = FFI()\n    ffi.cdef(\"typedef ... foo_t; foo_t myfunc(void);\")\n    e = py.test.raises(TypeError, ffi.verify,\n                       \"typedef struct { int x; } foo_t; \"\n                       \"foo_t myfunc(void) { foo_t x = { 42 }; return x; }\")\n    assert str(e.value) == (\n        \"function myfunc: 'foo_t' is used as result type, but is opaque\")\n\ndef test_include():\n    ffi1 = FFI()\n    ffi1.cdef(\"typedef struct { int x; ...; } foo_t;\")\n    ffi1.verify(\"typedef struct { int y, x; } foo_t;\")\n    ffi2 = FFI()\n    ffi2.include(ffi1)\n    ffi2.cdef(\"int myfunc(foo_t *);\")\n    lib = ffi2.verify(\"typedef struct { int y, x; } foo_t;\"\n                      \"int myfunc(foo_t *p) { return 42 * p->x; }\")\n    res = lib.myfunc(ffi2.new(\"foo_t *\", {'x': 10}))\n    assert res == 420\n    res = lib.myfunc(ffi1.new(\"foo_t *\", {'x': -10}))\n    assert res == -420\n\ndef test_include_enum():\n    ffi1 = FFI()\n    ffi1.cdef(\"enum foo_e { AA, ... };\")\n    lib1 = ffi1.verify(\"enum foo_e { CC, BB, AA };\")\n    ffi2 = FFI()\n    ffi2.include(ffi1)\n    ffi2.cdef(\"int myfunc(enum foo_e);\")\n    lib2 = ffi2.verify(\"enum foo_e { CC, BB, AA };\"\n                       \"int myfunc(enum foo_e x) { return (int)x; }\")\n    res = lib2.myfunc(lib2.AA)\n    assert res == 2\n\ndef test_named_pointer_as_argument():\n    ffi = FFI()\n    ffi.cdef(\"typedef struct { int x; } *mystruct_p;\\n\"\n             \"mystruct_p ff5a(mystruct_p);\")\n    lib = ffi.verify(\"typedef struct { int x; } *mystruct_p;\\n\"\n                     \"mystruct_p ff5a(mystruct_p p) { p->x += 40; return p; }\")\n    p = ffi.new(\"mystruct_p\", [-2])\n    q = lib.ff5a(p)\n    assert q == p\n    assert p.x == 38\n\ndef test_enum_size():\n    cases = [('123',           4, 4294967295),\n             ('4294967295U',   4, 4294967295),\n             ('-123',          4, -1),\n             ('-2147483647-1', 4, -1),\n             ]\n    if FFI().sizeof(\"long\") == 8:\n        cases += [('4294967296L',        8, 2**64-1),\n                  ('%dUL' % (2**64-1),   8, 2**64-1),\n                  ('-2147483649L',       8, -1),\n                  ('%dL-1L' % (1-2**63), 8, -1)]\n    for hidden_value, expected_size, expected_minus1 in cases:\n        if sys.platform == 'win32' and 'U' in hidden_value:\n            continue   # skipped on Windows\n        ffi = FFI()\n        ffi.cdef(\"enum foo_e { AA, BB, ... };\")\n        lib = ffi.verify(\"enum foo_e { AA, BB=%s };\" % hidden_value)\n        assert lib.AA == 0\n        assert lib.BB == eval(hidden_value.replace('U', '').replace('L', ''))\n        assert ffi.sizeof(\"enum foo_e\") == expected_size\n        if sys.platform != 'win32':\n            assert int(ffi.cast(\"enum foo_e\", -1)) == expected_minus1\n    # test with the large value hidden:\n    # disabled so far, doesn't work\n##    for hidden_value, expected_size, expected_minus1 in cases:\n##        ffi = FFI()\n##        ffi.cdef(\"enum foo_e { AA, BB, ... };\")\n##        lib = ffi.verify(\"enum foo_e { AA, BB=%s };\" % hidden_value)\n##        assert lib.AA == 0\n##        assert ffi.sizeof(\"enum foo_e\") == expected_size\n##        assert int(ffi.cast(\"enum foo_e\", -1)) == expected_minus1\n\ndef test_enum_bug118():\n    maxulong = 256 ** FFI().sizeof(\"unsigned long\") - 1\n    for c2, c2c in [(-1, ''),\n                    (-1, ''),\n                    (0xffffffff, 'U'),\n                    (maxulong, 'UL'),\n                    (-int(maxulong / 3), 'L')]:\n        if c2c and sys.platform == 'win32':\n            continue     # enums may always be signed with MSVC\n        ffi = FFI()\n        ffi.cdef(\"enum foo_e { AA };\")\n        lib = ffi.verify(\"enum foo_e { AA=%s%s };\" % (c2, c2c))\n        assert lib.AA == c2\n\ndef test_string_to_voidp_arg():\n    ffi = FFI()\n    ffi.cdef(\"int myfunc(void *);\")\n    lib = ffi.verify(\"int myfunc(void *p) { return ((signed char *)p)[0]; }\")\n    res = lib.myfunc(b\"hi!\")\n    assert res == ord(b\"h\")\n    p = ffi.new(\"char[]\", b\"gah\")\n    res = lib.myfunc(p)\n    assert res == ord(b\"g\")\n    res = lib.myfunc(ffi.cast(\"void *\", p))\n    assert res == ord(b\"g\")\n    res = lib.myfunc(ffi.cast(\"int *\", p))\n    assert res == ord(b\"g\")\n\ndef test_callback_indirection():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        int (*python_callback)(int how_many, int *values);\n        int (*const c_callback)(int,...);   /* pass this ptr to C routines */\n        int some_c_function(int(*cb)(int,...));\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        #include <stdarg.h>\n        #ifdef _WIN32\n        #include <malloc.h>\n        #define alloca _alloca\n        #else\n        # ifdef __FreeBSD__\n        #  include <stdlib.h>\n        # else\n        #  include <alloca.h>\n        # endif\n        #endif\n        static int (*python_callback)(int how_many, int *values);\n        static int c_callback(int how_many, ...) {\n            va_list ap;\n            /* collect the \"...\" arguments into the values[] array */\n            int i, *values = alloca((size_t)how_many * sizeof(int));\n            va_start(ap, how_many);\n            for (i=0; i<how_many; i++)\n                values[i] = va_arg(ap, int);\n            va_end(ap);\n            return python_callback(how_many, values);\n        }\n        int some_c_function(int(*cb)(int,...)) {\n            int result = cb(2, 10, 20);\n            result += cb(3, 30, 40, 50);\n            return result;\n        }\n    \"\"\")\n    seen = []\n    @ffi.callback(\"int(int, int*)\")\n    def python_callback(how_many, values):\n        seen.append([values[i] for i in range(how_many)])\n        return 42\n    lib.python_callback = python_callback\n\n    res = lib.some_c_function(lib.c_callback)\n    assert res == 84\n    assert seen == [[10, 20], [30, 40, 50]]\n\ndef test_floatstar_argument():\n    ffi = FFI()\n    ffi.cdef(\"float sum3floats(float *);\")\n    lib = ffi.verify(\"\"\"\n        float sum3floats(float *f) {\n            return f[0] + f[1] + f[2];\n        }\n    \"\"\")\n    assert lib.sum3floats((1.5, 2.5, 3.5)) == 7.5\n    p = ffi.new(\"float[]\", (1.5, 2.5, 3.5))\n    assert lib.sum3floats(p) == 7.5\n\ndef test_charstar_argument():\n    ffi = FFI()\n    ffi.cdef(\"char sum3chars(char *);\")\n    lib = ffi.verify(\"\"\"\n        char sum3chars(char *f) {\n            return (char)(f[0] + f[1] + f[2]);\n        }\n    \"\"\")\n    assert lib.sum3chars((b'\\x10', b'\\x20', b'\\x30')) == b'\\x60'\n    p = ffi.new(\"char[]\", b'\\x10\\x20\\x30')\n    assert lib.sum3chars(p) == b'\\x60'\n\ndef test_passing_string_or_NULL():\n    ffi = FFI()\n    ffi.cdef(\"int seeme1(char *); int seeme2(int *);\")\n    lib = ffi.verify(\"\"\"\n        int seeme1(char *x) {\n            return (x == NULL);\n        }\n        int seeme2(int *x) {\n            return (x == NULL);\n        }\n    \"\"\")\n    assert lib.seeme1(b\"foo\") == 0\n    assert lib.seeme1(ffi.NULL) == 1\n    assert lib.seeme2([42, 43]) == 0\n    assert lib.seeme2(ffi.NULL) == 1\n    py.test.raises(TypeError, lib.seeme1, None)\n    py.test.raises(TypeError, lib.seeme2, None)\n    py.test.raises(TypeError, lib.seeme1, 0.0)\n    py.test.raises(TypeError, lib.seeme2, 0.0)\n    py.test.raises(TypeError, lib.seeme1, 0)\n    py.test.raises(TypeError, lib.seeme2, 0)\n    zeroL  = 99999999999999999999\n    zeroL -= 99999999999999999999\n    py.test.raises(TypeError, lib.seeme2, zeroL)\n\ndef test_typeof_function():\n    ffi = FFI()\n    ffi.cdef(\"int foo(int, char);\")\n    lib = ffi.verify(\"int foo(int x, char y) { (void)x; (void)y; return 42; }\")\n    ctype = ffi.typeof(lib.foo)\n    assert len(ctype.args) == 2\n    assert ctype.result == ffi.typeof(\"int\")\n\ndef test_call_with_voidstar_arg():\n    ffi = FFI()\n    ffi.cdef(\"int f(void *);\")\n    lib = ffi.verify(\"int f(void *x) { return ((char*)x)[0]; }\")\n    assert lib.f(b\"foobar\") == ord(b\"f\")\n\ndef test_dir():\n    ffi = FFI()\n    ffi.cdef(\"\"\"void somefunc(void);\n                extern int somevar, somearray[2];\n                static char *const sv2;\n                enum my_e { AA, BB, ... };\n                #define FOO ...\"\"\")\n    lib = ffi.verify(\"\"\"void somefunc(void) { }\n                        int somevar, somearray[2];\n                        #define sv2 \"text\"\n                        enum my_e { AA, BB };\n                        #define FOO 42\"\"\")\n    assert dir(lib) == ['AA', 'BB', 'FOO', 'somearray',\n                        'somefunc', 'somevar', 'sv2']\n\ndef test_typeof_func_with_struct_argument():\n    ffi = FFI()\n    ffi.cdef(\"\"\"struct s { int a; }; int foo(struct s);\"\"\")\n    lib = ffi.verify(\"\"\"struct s { int a; };\n                        int foo(struct s x) { return x.a; }\"\"\")\n    s = ffi.new(\"struct s *\", [-1234])\n    m = lib.foo(s[0])\n    assert m == -1234\n    assert repr(ffi.typeof(lib.foo)) == \"<ctype 'int(*)(struct s)'>\"\n\ndef test_bug_const_char_ptr_array_1():\n    ffi = FFI()\n    ffi.cdef(\"\"\"const char *a[...];\"\"\")\n    lib = ffi.verify(\"\"\"const char *a[5];\"\"\")\n    assert repr(ffi.typeof(lib.a)) == \"<ctype 'char *[5]'>\"\n\ndef test_bug_const_char_ptr_array_2():\n    ffi = FFI()\n    ffi.cdef(\"\"\"const int a[];\"\"\")\n    lib = ffi.verify(\"\"\"const int a[5];\"\"\")\n    assert repr(ffi.typeof(lib.a)) == \"<ctype 'int *'>\"\n\ndef _test_various_calls(force_libffi):\n    cdef_source = \"\"\"\n    int xvalue;\n    long long ivalue, rvalue;\n    float fvalue;\n    double dvalue;\n    long double Dvalue;\n    signed char tf_bb(signed char x, signed char c);\n    unsigned char tf_bB(signed char x, unsigned char c);\n    short tf_bh(signed char x, short c);\n    unsigned short tf_bH(signed char x, unsigned short c);\n    int tf_bi(signed char x, int c);\n    unsigned int tf_bI(signed char x, unsigned int c);\n    long tf_bl(signed char x, long c);\n    unsigned long tf_bL(signed char x, unsigned long c);\n    long long tf_bq(signed char x, long long c);\n    unsigned long long tf_bQ(signed char x, unsigned long long c);\n    float tf_bf(signed char x, float c);\n    double tf_bd(signed char x, double c);\n    long double tf_bD(signed char x, long double c);\n    \"\"\"\n    if force_libffi:\n        cdef_source = (cdef_source\n            .replace('tf_', '(*const tf_')\n            .replace('(signed char x', ')(signed char x'))\n    ffi = FFI()\n    ffi.cdef(cdef_source)\n    lib = ffi.verify(\"\"\"\n    int xvalue;\n    long long ivalue, rvalue;\n    float fvalue;\n    double dvalue;\n    long double Dvalue;\n\n    typedef signed char b_t;\n    typedef unsigned char B_t;\n    typedef short h_t;\n    typedef unsigned short H_t;\n    typedef int i_t;\n    typedef unsigned int I_t;\n    typedef long l_t;\n    typedef unsigned long L_t;\n    typedef long long q_t;\n    typedef unsigned long long Q_t;\n    typedef float f_t;\n    typedef double d_t;\n    typedef long double D_t;\n    #define S(letter)  xvalue = (int)x; letter##value = (letter##_t)c;\n    #define R(letter)  return (letter##_t)rvalue;\n\n    signed char tf_bb(signed char x, signed char c) { S(i) R(b) }\n    unsigned char tf_bB(signed char x, unsigned char c) { S(i) R(B) }\n    short tf_bh(signed char x, short c) { S(i) R(h) }\n    unsigned short tf_bH(signed char x, unsigned short c) { S(i) R(H) }\n    int tf_bi(signed char x, int c) { S(i) R(i) }\n    unsigned int tf_bI(signed char x, unsigned int c) { S(i) R(I) }\n    long tf_bl(signed char x, long c) { S(i) R(l) }\n    unsigned long tf_bL(signed char x, unsigned long c) { S(i) R(L) }\n    long long tf_bq(signed char x, long long c) { S(i) R(q) }\n    unsigned long long tf_bQ(signed char x, unsigned long long c) { S(i) R(Q) }\n    float tf_bf(signed char x, float c) { S(f) R(f) }\n    double tf_bd(signed char x, double c) { S(d) R(d) }\n    long double tf_bD(signed char x, long double c) { S(D) R(D) }\n    \"\"\")\n    lib.rvalue = 0x7182838485868788\n    for kind, cname in [('b', 'signed char'),\n                        ('B', 'unsigned char'),\n                        ('h', 'short'),\n                        ('H', 'unsigned short'),\n                        ('i', 'int'),\n                        ('I', 'unsigned int'),\n                        ('l', 'long'),\n                        ('L', 'unsigned long'),\n                        ('q', 'long long'),\n                        ('Q', 'unsigned long long'),\n                        ('f', 'float'),\n                        ('d', 'double'),\n                        ('D', 'long double')]:\n        sign = +1 if 'unsigned' in cname else -1\n        lib.xvalue = 0\n        lib.ivalue = 0\n        lib.fvalue = 0\n        lib.dvalue = 0\n        lib.Dvalue = 0\n        fun = getattr(lib, 'tf_b' + kind)\n        res = fun(-42, sign * 99)\n        if kind == 'D':\n            res = float(res)\n        assert res == int(ffi.cast(cname, 0x7182838485868788))\n        assert lib.xvalue == -42\n        if kind in 'fdD':\n            assert float(getattr(lib, kind + 'value')) == -99.0\n        else:\n            assert lib.ivalue == sign * 99\n\ndef test_various_calls_direct():\n    _test_various_calls(force_libffi=False)\n\ndef test_various_calls_libffi():\n    _test_various_calls(force_libffi=True)\n\ndef test_ptr_to_opaque():\n    ffi = FFI()\n    ffi.cdef(\"typedef ... foo_t; int f1(foo_t*); foo_t *f2(int);\")\n    lib = ffi.verify(\"\"\"\n        #include <stdlib.h>\n        typedef struct { int x; } foo_t;\n        int f1(foo_t* p) {\n            int x = p->x;\n            free(p);\n            return x;\n        }\n        foo_t *f2(int x) {\n            foo_t *p = malloc(sizeof(foo_t));\n            p->x = x;\n            return p;\n        }\n    \"\"\")\n    p = lib.f2(42)\n    x = lib.f1(p)\n    assert x == 42\n\ndef _run_in_multiple_threads(test1):\n    test1()\n    import sys\n    try:\n        import thread\n    except ImportError:\n        import _thread as thread\n    errors = []\n    def wrapper(lock):\n        try:\n            test1()\n        except:\n            errors.append(sys.exc_info())\n        lock.release()\n    locks = []\n    for i in range(10):\n        _lock = thread.allocate_lock()\n        _lock.acquire()\n        thread.start_new_thread(wrapper, (_lock,))\n        locks.append(_lock)\n    for _lock in locks:\n        _lock.acquire()\n        if errors:\n            raise errors[0][1]\n\ndef test_errno_working_even_with_pypys_jit():\n    ffi = FFI()\n    ffi.cdef(\"int f(int);\")\n    lib = ffi.verify(\"\"\"\n        #include <errno.h>\n        int f(int x) { return (errno = errno + x); }\n    \"\"\")\n    @_run_in_multiple_threads\n    def test1():\n        ffi.errno = 0\n        for i in range(10000):\n            e = lib.f(1)\n            assert e == i + 1\n            assert ffi.errno == e\n        for i in range(10000):\n            ffi.errno = i\n            e = lib.f(42)\n            assert e == i + 42\n\ndef test_getlasterror_working_even_with_pypys_jit():\n    if sys.platform != 'win32':\n        py.test.skip(\"win32-only test\")\n    ffi = FFI()\n    ffi.cdef(\"void SetLastError(DWORD);\")\n    lib = ffi.dlopen(\"Kernel32.dll\")\n    @_run_in_multiple_threads\n    def test1():\n        for i in range(10000):\n            n = (1 << 29) + i\n            lib.SetLastError(n)\n            assert ffi.getwinerror()[0] == n\n\ndef test_verify_dlopen_flags():\n    if not hasattr(sys, 'setdlopenflags'):\n        py.test.skip(\"requires sys.setdlopenflags()\")\n    # Careful with RTLD_GLOBAL.  If by chance the FFI is not deleted\n    # promptly, like on PyPy, then other tests may see the same\n    # exported symbols as well.  So we must not export a simple name\n    # like 'foo'!\n    old = sys.getdlopenflags()\n    try:\n        ffi1 = FFI()\n        ffi1.cdef(\"int foo_verify_dlopen_flags_1;\")\n        sys.setdlopenflags(ffi1.RTLD_GLOBAL | ffi1.RTLD_NOW)\n        lib1 = ffi1.verify(\"int foo_verify_dlopen_flags_1;\")\n    finally:\n        sys.setdlopenflags(old)\n\n    ffi2 = FFI()\n    ffi2.cdef(\"int *getptr(void);\")\n    lib2 = ffi2.verify(\"\"\"\n        extern int foo_verify_dlopen_flags_1;\n        static int *getptr(void) { return &foo_verify_dlopen_flags_1; }\n    \"\"\")\n    p = lib2.getptr()\n    assert ffi1.addressof(lib1, 'foo_verify_dlopen_flags_1') == p\n\ndef test_consider_not_implemented_function_type():\n    ffi = FFI()\n    ffi.cdef(\"typedef union { int a; float b; } Data;\"\n             \"typedef struct { int a:2; } MyStr;\"\n             \"typedef void (*foofunc_t)(Data);\"\n             \"typedef Data (*bazfunc_t)(void);\"\n             \"typedef MyStr (*barfunc_t)(void);\")\n    fooptr = ffi.cast(\"foofunc_t\", 123)\n    bazptr = ffi.cast(\"bazfunc_t\", 123)\n    barptr = ffi.cast(\"barfunc_t\", 123)\n    # assert did not crash so far\n    e = py.test.raises(NotImplementedError, fooptr, ffi.new(\"Data *\"))\n    assert str(e.value) == (\n        \"ctype 'Data' not supported as argument by libffi.  Unions are only \"\n        \"supported as argument if the function is 'API mode' and \"\n        \"non-variadic (i.e. declared inside ffibuilder.cdef()+\"\n        \"ffibuilder.set_source() and not taking a final '...' argument)\")\n    e = py.test.raises(NotImplementedError, bazptr)\n    assert str(e.value) == (\n        \"ctype 'Data' not supported as return value by libffi.  Unions are \"\n        \"only supported as return value if the function is 'API mode' and \"\n        \"non-variadic (i.e. declared inside ffibuilder.cdef()+\"\n        \"ffibuilder.set_source() and not taking a final '...' argument)\")\n    e = py.test.raises(NotImplementedError, barptr)\n    assert str(e.value) == (\n        \"ctype 'MyStr' not supported as return value.  It is a struct with \"\n        \"bit fields, which libffi does not support.  Such structs are only \"\n        \"supported as return value if the function is 'API mode' and non-\"\n        \"variadic (i.e. declared inside ffibuilder.cdef()+ffibuilder.\"\n        \"set_source() and not taking a final '...' argument)\")\n\ndef test_verify_extra_arguments():\n    ffi = FFI()\n    ffi.cdef(\"#define ABA ...\")\n    lib = ffi.verify(\"\", define_macros=[('ABA', '42')])\n    assert lib.ABA == 42\n\ndef test_implicit_unicode_on_windows():\n    from cffi import FFIError\n    if sys.platform != 'win32':\n        py.test.skip(\"win32-only test\")\n    ffi = FFI()\n    e = py.test.raises(FFIError, ffi.cdef, \"int foo(LPTSTR);\")\n    assert str(e.value) == (\"The Windows type 'LPTSTR' is only available after\"\n                            \" you call ffi.set_unicode()\")\n    for with_unicode in [True, False]:\n        ffi = FFI()\n        ffi.set_unicode(with_unicode)\n        ffi.cdef(\"\"\"\n            DWORD GetModuleFileName(HMODULE hModule, LPTSTR lpFilename,\n                                    DWORD nSize);\n        \"\"\")\n        lib = ffi.verify(\"\"\"\n            #include <windows.h>\n        \"\"\", libraries=['Kernel32'])\n        outbuf = ffi.new(\"TCHAR[]\", 200)\n        n = lib.GetModuleFileName(ffi.NULL, outbuf, 500)\n        assert 0 < n < 500\n        for i in range(n):\n            #print repr(outbuf[i])\n            assert ord(outbuf[i]) != 0\n        assert ord(outbuf[n]) == 0\n        assert ord(outbuf[0]) < 128     # should be a letter, or '\\'\n\ndef test_define_known_value():\n    ffi = FFI()\n    ffi.cdef(\"#define FOO 0x123\")\n    lib = ffi.verify(\"#define FOO 0x123\")\n    assert lib.FOO == 0x123\n\ndef test_define_wrong_value():\n    ffi = FFI()\n    ffi.cdef(\"#define FOO 123\")\n    lib = ffi.verify(\"#define FOO 124\")     # used to complain\n    with pytest.raises(ffi.error) as e:\n        lib.FOO\n    assert str(e.value) == (\"the C compiler says 'FOO' is equal to 124 (0x7c),\"\n                            \" but the cdef disagrees\")\n\ndef test_some_integer_type_for_issue73():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef int... AnIntegerWith32Bits;\n        typedef AnIntegerWith32Bits (*AFunctionReturningInteger) (void);\n        AnIntegerWith32Bits InvokeFunction(AFunctionReturningInteger);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        #ifdef __LP64__\n        typedef int AnIntegerWith32Bits;\n        #else\n        typedef long AnIntegerWith32Bits;\n        #endif\n        typedef AnIntegerWith32Bits (*AFunctionReturningInteger) (void);\n        AnIntegerWith32Bits InvokeFunction(AFunctionReturningInteger f) {\n            return f();\n        }\n    \"\"\")\n    @ffi.callback(\"AFunctionReturningInteger\")\n    def add():\n        return 3 + 4\n    x = lib.InvokeFunction(add)\n    assert x == 7\n\ndef test_unsupported_some_primitive_types():\n    ffi = FFI()\n    py.test.raises((FFIError,      # with pycparser <= 2.17\n                    CDefError),    # with pycparser >= 2.18\n                   ffi.cdef, \"\"\"typedef void... foo_t;\"\"\")\n    #\n    ffi.cdef(\"typedef int... foo_t;\")\n    py.test.raises(VerificationError, ffi.verify, \"typedef float foo_t;\")\n\ndef test_windows_dllimport_data():\n    if sys.platform != 'win32':\n        py.test.skip(\"Windows only\")\n    from testing.udir import udir\n    tmpfile = udir.join('dllimport_data.c')\n    tmpfile.write('int my_value = 42;\\n')\n    ffi = FFI()\n    ffi.cdef(\"int my_value;\")\n    lib = ffi.verify(\"extern __declspec(dllimport) int my_value;\",\n                     sources = [str(tmpfile)])\n    assert lib.my_value == 42\n\ndef test_macro_var():\n    ffi = FFI()\n    ffi.cdef(\"int myarray[50], my_value;\")\n    lib = ffi.verify(\"\"\"\n        int myarray[50];\n        int *get_my_value(void) {\n            static int index = 0;\n            return &myarray[index++];\n        }\n        #define my_value (*get_my_value())\n    \"\"\")\n    assert lib.my_value == 0             # [0]\n    lib.my_value = 42                    # [1]\n    assert lib.myarray[1] == 42\n    assert lib.my_value == 0             # [2]\n    lib.myarray[3] = 63\n    assert lib.my_value == 63            # [3]\n    p = ffi.addressof(lib, 'my_value')   # [4]\n    assert p[-1] == 63\n    assert p[0] == 0\n    assert p == lib.myarray + 4\n    p[1] = 82\n    assert lib.my_value == 82            # [5]\n\ndef test_const_pointer_to_pointer():\n    ffi = FFI()\n    ffi.cdef(\"struct s { char *const *a; };\")\n    ffi.verify(\"struct s { char *const *a; };\")\n\ndef test_share_FILE():\n    ffi1 = FFI()\n    ffi1.cdef(\"void do_stuff(FILE *);\")\n    lib1 = ffi1.verify(\"void do_stuff(FILE *f) { (void)f; }\")\n    ffi2 = FFI()\n    ffi2.cdef(\"FILE *barize(void);\")\n    lib2 = ffi2.verify(\"FILE *barize(void) { return NULL; }\")\n    lib1.do_stuff(lib2.barize())\n\ndef test_win_common_types():\n    if sys.platform != 'win32':\n        py.test.skip(\"Windows only\")\n    ffi = FFI()\n    ffi.set_unicode(True)\n    ffi.verify(\"\")\n    assert ffi.typeof(\"PBYTE\") is ffi.typeof(\"unsigned char *\")\n    if sys.maxsize > 2**32:\n        expected = \"unsigned long long\"\n    else:\n        expected = \"unsigned int\"\n    assert ffi.typeof(\"UINT_PTR\") is ffi.typeof(expected)\n    assert ffi.typeof(\"PTSTR\") is ffi.typeof(\"wchar_t *\")\n\ndef _only_test_on_linux_intel():\n    if not sys.platform.startswith('linux'):\n        py.test.skip('only running the memory-intensive test on Linux')\n    import platform\n    machine = platform.machine()\n    if 'x86' not in machine and 'x64' not in machine:\n        py.test.skip('only running the memory-intensive test on x86/x64')\n\ndef test_ffi_gc_size_arg():\n    _only_test_on_linux_intel()\n    ffi = FFI()\n    ffi.cdef(\"void *malloc(size_t); void free(void *);\")\n    lib = ffi.verify(r\"\"\"\n        #include <stdlib.h>\n    \"\"\")\n    for i in range(2000):\n        p = lib.malloc(20*1024*1024)    # 20 MB\n        p1 = ffi.cast(\"char *\", p)\n        for j in range(0, 20*1024*1024, 4096):\n            p1[j] = b'!'\n        p = ffi.gc(p, lib.free, 20*1024*1024)\n        del p\n        # with PyPy's GC, the above would rapidly consume 40 GB of RAM\n        # without the third argument to ffi.gc()\n\ndef test_ffi_gc_size_arg_2():\n    # a variant of the above: this \"attack\" works on cpython's cyclic gc too\n    # and I found no obvious way to prevent that.  So for now, this test\n    # is skipped on CPython, where it eats all the memory.\n    if '__pypy__' not in sys.builtin_module_names:\n        py.test.skip(\"find a way to tweak the cyclic GC of CPython\")\n    _only_test_on_linux_intel()\n    ffi = FFI()\n    ffi.cdef(\"void *malloc(size_t); void free(void *);\")\n    lib = ffi.verify(r\"\"\"\n        #include <stdlib.h>\n    \"\"\")\n    class X(object):\n        pass\n    for i in range(2000):\n        p = lib.malloc(50*1024*1024)    # 50 MB\n        p1 = ffi.cast(\"char *\", p)\n        for j in range(0, 50*1024*1024, 4096):\n            p1[j] = b'!'\n        p = ffi.gc(p, lib.free, 50*1024*1024)\n        x = X()\n        x.p = p\n        x.cyclic = x\n        del p, x\n\ndef test_ffi_new_with_cycles():\n    # still another variant, with ffi.new()\n    if '__pypy__' not in sys.builtin_module_names:\n        py.test.skip(\"find a way to tweak the cyclic GC of CPython\")\n    ffi = FFI()\n    ffi.cdef(\"\")\n    lib = ffi.verify(\"\")\n    class X(object):\n        pass\n    for i in range(2000):\n        p = ffi.new(\"char[]\", 50*1024*1024)    # 50 MB\n        for j in range(0, 50*1024*1024, 4096):\n            p[j] = b'!'\n        x = X()\n        x.p = p\n        x.cyclic = x\n        del p, x\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.13.0-jlicqgsrlask3n7tsdckxmdwv6d5zp4o/spack-src/testing/cffi1/test_dlopen_unicode_literals.py": "import py, os\n\ns = \"\"\"from __future__ import unicode_literals\n\"\"\"\n\nwith open(os.path.join(os.path.dirname(__file__), 'test_dlopen.py')) as f:\n    s += f.read()\n\nexec(py.code.compile(s))\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.13.0-jlicqgsrlask3n7tsdckxmdwv6d5zp4o/spack-src/testing/cffi1/test_re_python.py": "import sys, os\nimport py\nfrom cffi import FFI\nfrom cffi import recompiler, ffiplatform, VerificationMissing\nfrom testing.udir import udir\nfrom testing.support import u\n\n\ndef setup_module(mod):\n    SRC = \"\"\"\n    #include <string.h>\n    #define FOOBAR (-42)\n    static const int FOOBAZ = -43;\n    #define BIGPOS 420000000000L\n    #define BIGNEG -420000000000L\n    int add42(int x) { return x + 42; }\n    int add43(int x, ...) { return x; }\n    int globalvar42 = 1234;\n    const int globalconst42 = 4321;\n    const char *const globalconsthello = \"hello\";\n    struct foo_s;\n    typedef struct bar_s { int x; signed char a[]; } bar_t;\n    enum foo_e { AA, BB, CC };\n\n    void init_test_re_python(void) { }      /* windows hack */\n    void PyInit__test_re_python(void) { }   /* windows hack */\n    \"\"\"\n    tmpdir = udir.join('test_re_python')\n    tmpdir.ensure(dir=1)\n    c_file = tmpdir.join('_test_re_python.c')\n    c_file.write(SRC)\n    ext = ffiplatform.get_extension(\n        str(c_file),\n        '_test_re_python',\n        export_symbols=['add42', 'add43', 'globalvar42',\n                        'globalconst42', 'globalconsthello']\n    )\n    outputfilename = ffiplatform.compile(str(tmpdir), ext)\n\n    # test with a non-ascii char\n    ofn, oext = os.path.splitext(outputfilename)\n    if sys.platform == \"win32\":\n        unicode_name = ofn + (u+'\\u03be') + oext\n    else:\n        unicode_name = ofn + (u+'\\xe9') + oext\n        try:\n            unicode_name.encode(sys.getfilesystemencoding())\n        except UnicodeEncodeError:\n            unicode_name = None\n    if unicode_name is not None:\n        print(repr(outputfilename) + ' ==> ' + repr(unicode_name))\n        os.rename(outputfilename, unicode_name)\n        outputfilename = unicode_name\n\n    mod.extmod = outputfilename\n    mod.tmpdir = tmpdir\n    #\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n    #define FOOBAR -42\n    static const int FOOBAZ = -43;\n    #define BIGPOS 420000000000L\n    #define BIGNEG -420000000000L\n    int add42(int);\n    int add43(int, ...);\n    int globalvar42;\n    const int globalconst42;\n    const char *const globalconsthello;\n    int no_such_function(int);\n    int no_such_globalvar;\n    struct foo_s;\n    typedef struct bar_s { int x; signed char a[]; } bar_t;\n    enum foo_e { AA, BB, CC };\n    int strlen(const char *);\n    struct with_union { union { int a; char b; }; };\n    union with_struct { struct { int a; char b; }; };\n    struct NVGcolor { union { float rgba[4]; struct { float r,g,b,a; }; }; };\n    \"\"\")\n    ffi.set_source('re_python_pysrc', None)\n    ffi.emit_python_code(str(tmpdir.join('re_python_pysrc.py')))\n    mod.original_ffi = ffi\n    #\n    sys.path.insert(0, str(tmpdir))\n\n\ndef test_constant():\n    from re_python_pysrc import ffi\n    assert ffi.integer_const('FOOBAR') == -42\n    assert ffi.integer_const('FOOBAZ') == -43\n\ndef test_large_constant():\n    from re_python_pysrc import ffi\n    assert ffi.integer_const('BIGPOS') == 420000000000\n    assert ffi.integer_const('BIGNEG') == -420000000000\n\ndef test_function():\n    import _cffi_backend\n    from re_python_pysrc import ffi\n    lib = ffi.dlopen(extmod)\n    assert lib.add42(-10) == 32\n    assert type(lib.add42) is _cffi_backend.FFI.CData\n\ndef test_function_with_varargs():\n    import _cffi_backend\n    from re_python_pysrc import ffi\n    lib = ffi.dlopen(extmod, 0)\n    assert lib.add43(45, ffi.cast(\"int\", -5)) == 45\n    assert type(lib.add43) is _cffi_backend.FFI.CData\n\ndef test_dlopen_none():\n    import _cffi_backend\n    from re_python_pysrc import ffi\n    name = None\n    if sys.platform == 'win32':\n        import ctypes.util\n        name = ctypes.util.find_msvcrt()\n        if name is None:\n            py.test.skip(\"dlopen(None) cannot work on Windows with Python 3\")\n    lib = ffi.dlopen(name)\n    assert lib.strlen(b\"hello\") == 5\n\ndef test_dlclose():\n    import _cffi_backend\n    from re_python_pysrc import ffi\n    lib = ffi.dlopen(extmod)\n    ffi.dlclose(lib)\n    if type(extmod) is not str:   # unicode, on python 2\n        str_extmod = extmod.encode('utf-8')\n    else:\n        str_extmod = extmod\n    e = py.test.raises(ffi.error, getattr, lib, 'add42')\n    assert str(e.value) == (\n        \"library '%s' has been closed\" % (str_extmod,))\n    ffi.dlclose(lib)   # does not raise\n\ndef test_constant_via_lib():\n    from re_python_pysrc import ffi\n    lib = ffi.dlopen(extmod)\n    assert lib.FOOBAR == -42\n    assert lib.FOOBAZ == -43\n\ndef test_opaque_struct():\n    from re_python_pysrc import ffi\n    ffi.cast(\"struct foo_s *\", 0)\n    py.test.raises(TypeError, ffi.new, \"struct foo_s *\")\n\ndef test_nonopaque_struct():\n    from re_python_pysrc import ffi\n    for p in [ffi.new(\"struct bar_s *\", [5, b\"foobar\"]),\n              ffi.new(\"bar_t *\", [5, b\"foobar\"])]:\n        assert p.x == 5\n        assert p.a[0] == ord('f')\n        assert p.a[5] == ord('r')\n\ndef test_enum():\n    from re_python_pysrc import ffi\n    assert ffi.integer_const(\"BB\") == 1\n    e = ffi.cast(\"enum foo_e\", 2)\n    assert ffi.string(e) == \"CC\"\n\ndef test_include_1():\n    sub_ffi = FFI()\n    sub_ffi.cdef(\"static const int k2 = 121212;\")\n    sub_ffi.include(original_ffi)\n    assert 'macro FOOBAR' in original_ffi._parser._declarations\n    assert 'macro FOOBAZ' in original_ffi._parser._declarations\n    sub_ffi.set_source('re_python_pysrc', None)\n    sub_ffi.emit_python_code(str(tmpdir.join('_re_include_1.py')))\n    #\n    if sys.version_info[:2] >= (3, 3):\n        import importlib\n        importlib.invalidate_caches()  # issue 197 (but can't reproduce myself)\n    #\n    from _re_include_1 import ffi\n    assert ffi.integer_const('FOOBAR') == -42\n    assert ffi.integer_const('FOOBAZ') == -43\n    assert ffi.integer_const('k2') == 121212\n    lib = ffi.dlopen(extmod)     # <- a random unrelated library would be fine\n    assert lib.FOOBAR == -42\n    assert lib.FOOBAZ == -43\n    assert lib.k2 == 121212\n    #\n    p = ffi.new(\"bar_t *\", [5, b\"foobar\"])\n    assert p.a[4] == ord('a')\n\ndef test_global_var():\n    from re_python_pysrc import ffi\n    lib = ffi.dlopen(extmod)\n    assert lib.globalvar42 == 1234\n    p = ffi.addressof(lib, 'globalvar42')\n    lib.globalvar42 += 5\n    assert p[0] == 1239\n    p[0] -= 1\n    assert lib.globalvar42 == 1238\n\ndef test_global_const_int():\n    from re_python_pysrc import ffi\n    lib = ffi.dlopen(extmod)\n    assert lib.globalconst42 == 4321\n    py.test.raises(AttributeError, ffi.addressof, lib, 'globalconst42')\n\ndef test_global_const_nonint():\n    from re_python_pysrc import ffi\n    lib = ffi.dlopen(extmod)\n    assert ffi.string(lib.globalconsthello, 8) == b\"hello\"\n    py.test.raises(AttributeError, ffi.addressof, lib, 'globalconsthello')\n\ndef test_rtld_constants():\n    from re_python_pysrc import ffi\n    ffi.RTLD_NOW    # check that we have the attributes\n    ffi.RTLD_LAZY\n    ffi.RTLD_GLOBAL\n\ndef test_no_such_function_or_global_var():\n    from re_python_pysrc import ffi\n    lib = ffi.dlopen(extmod)\n    e = py.test.raises(ffi.error, getattr, lib, 'no_such_function')\n    assert str(e.value).startswith(\n        \"symbol 'no_such_function' not found in library '\")\n    e = py.test.raises(ffi.error, getattr, lib, 'no_such_globalvar')\n    assert str(e.value).startswith(\n        \"symbol 'no_such_globalvar' not found in library '\")\n\ndef test_check_version():\n    import _cffi_backend\n    e = py.test.raises(ImportError, _cffi_backend.FFI,\n                       \"foobar\", _version=0x2594)\n    assert str(e.value).startswith(\n        \"cffi out-of-line Python module 'foobar' has unknown version\")\n\ndef test_partial_enum():\n    ffi = FFI()\n    ffi.cdef(\"enum foo { A, B, ... };\")\n    ffi.set_source('test_partial_enum', None)\n    py.test.raises(VerificationMissing, ffi.emit_python_code,\n                   str(tmpdir.join('test_partial_enum.py')))\n\ndef test_anonymous_union_inside_struct():\n    # based on issue #357\n    from re_python_pysrc import ffi\n    INT = ffi.sizeof(\"int\")\n    assert ffi.offsetof(\"struct with_union\", \"a\") == 0\n    assert ffi.offsetof(\"struct with_union\", \"b\") == 0\n    assert ffi.sizeof(\"struct with_union\") == INT\n    #\n    assert ffi.offsetof(\"union with_struct\", \"a\") == 0\n    assert ffi.offsetof(\"union with_struct\", \"b\") == INT\n    assert ffi.sizeof(\"union with_struct\") >= INT + 1\n    #\n    FLOAT = ffi.sizeof(\"float\")\n    assert ffi.sizeof(\"struct NVGcolor\") == FLOAT * 4\n    assert ffi.offsetof(\"struct NVGcolor\", \"rgba\") == 0\n    assert ffi.offsetof(\"struct NVGcolor\", \"r\") == 0\n    assert ffi.offsetof(\"struct NVGcolor\", \"g\") == FLOAT\n    assert ffi.offsetof(\"struct NVGcolor\", \"b\") == FLOAT * 2\n    assert ffi.offsetof(\"struct NVGcolor\", \"a\") == FLOAT * 3\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.13.0-jlicqgsrlask3n7tsdckxmdwv6d5zp4o/spack-src/testing/cffi0/test_parsing.py": "import py, sys, re\nfrom cffi import FFI, FFIError, CDefError, VerificationError\nfrom .backend_tests import needs_dlopen_none\n\n\nclass FakeBackend(object):\n\n    def nonstandard_integer_types(self):\n        return {}\n\n    def sizeof(self, name):\n        return 1\n\n    def load_library(self, name, flags):\n        if sys.platform == 'win32':\n            assert name is None or \"msvcr\" in name\n        else:\n            assert name is None or \"libc\" in name or \"libm\" in name\n        return FakeLibrary()\n\n    def new_function_type(self, args, result, has_varargs):\n        args = [arg.cdecl for arg in args]\n        result = result.cdecl\n        return FakeType(\n            '<func (%s), %s, %s>' % (', '.join(args), result, has_varargs))\n\n    def new_primitive_type(self, name):\n        assert name == name.lower()\n        return FakeType('<%s>' % name)\n\n    def new_pointer_type(self, itemtype):\n        return FakeType('<pointer to %s>' % (itemtype,))\n\n    def new_struct_type(self, name):\n        return FakeStruct(name)\n\n    def complete_struct_or_union(self, s, fields, tp=None,\n                                 totalsize=-1, totalalignment=-1, sflags=0):\n        assert isinstance(s, FakeStruct)\n        s.fields = fields\n\n    def new_array_type(self, ptrtype, length):\n        return FakeType('<array %s x %s>' % (ptrtype, length))\n\n    def new_void_type(self):\n        return FakeType(\"<void>\")\n    def cast(self, x, y):\n        return 'casted!'\n    def _get_types(self):\n        return \"CData\", \"CType\"\n\n    buffer = \"buffer type\"\n\nclass FakeType(object):\n    def __init__(self, cdecl):\n        self.cdecl = cdecl\n    def __str__(self):\n        return self.cdecl\n\nclass FakeStruct(object):\n    def __init__(self, name):\n        self.name = name\n    def __str__(self):\n        return ', '.join([str(y) + str(x) for x, y, z in self.fields])\n\nclass FakeLibrary(object):\n\n    def load_function(self, BType, name):\n        return FakeFunction(BType, name)\n\nclass FakeFunction(object):\n\n    def __init__(self, BType, name):\n        self.BType = str(BType)\n        self.name = name\n\nlib_m = \"m\"\nif sys.platform == 'win32':\n    #there is a small chance this fails on Mingw via environ $CC\n    import distutils.ccompiler\n    if distutils.ccompiler.get_default_compiler() == 'msvc':\n        lib_m = 'msvcrt'\n\ndef test_simple():\n    ffi = FFI(backend=FakeBackend())\n    ffi.cdef(\"double sin(double x);\")\n    m = ffi.dlopen(lib_m)\n    func = m.sin    # should be a callable on real backends\n    assert func.name == 'sin'\n    assert func.BType == '<func (<double>), <double>, False>'\n\ndef test_pipe():\n    ffi = FFI(backend=FakeBackend())\n    ffi.cdef(\"int pipe(int pipefd[2]);\")\n    needs_dlopen_none()\n    C = ffi.dlopen(None)\n    func = C.pipe\n    assert func.name == 'pipe'\n    assert func.BType == '<func (<pointer to <int>>), <int>, False>'\n\ndef test_vararg():\n    ffi = FFI(backend=FakeBackend())\n    ffi.cdef(\"short foo(int, ...);\")\n    needs_dlopen_none()\n    C = ffi.dlopen(None)\n    func = C.foo\n    assert func.name == 'foo'\n    assert func.BType == '<func (<int>), <short>, True>'\n\ndef test_no_args():\n    ffi = FFI(backend=FakeBackend())\n    ffi.cdef(\"\"\"\n        int foo(void);\n        \"\"\")\n    needs_dlopen_none()\n    C = ffi.dlopen(None)\n    assert C.foo.BType == '<func (), <int>, False>'\n\ndef test_typedef():\n    ffi = FFI(backend=FakeBackend())\n    ffi.cdef(\"\"\"\n        typedef unsigned int UInt;\n        typedef UInt UIntReally;\n        UInt foo(void);\n        \"\"\")\n    needs_dlopen_none()\n    C = ffi.dlopen(None)\n    assert str(ffi.typeof(\"UIntReally\")) == '<unsigned int>'\n    assert C.foo.BType == '<func (), <unsigned int>, False>'\n\ndef test_typedef_more_complex():\n    ffi = FFI(backend=FakeBackend())\n    ffi.cdef(\"\"\"\n        typedef struct { int a, b; } foo_t, *foo_p;\n        int foo(foo_p[]);\n        \"\"\")\n    needs_dlopen_none()\n    C = ffi.dlopen(None)\n    assert str(ffi.typeof(\"foo_t\")) == '<int>a, <int>b'\n    assert str(ffi.typeof(\"foo_p\")) == '<pointer to <int>a, <int>b>'\n    assert C.foo.BType == ('<func (<pointer to <pointer to '\n                           '<int>a, <int>b>>), <int>, False>')\n\ndef test_typedef_array_convert_array_to_pointer():\n    ffi = FFI(backend=FakeBackend())\n    ffi.cdef(\"\"\"\n        typedef int (*fn_t)(int[5]);\n        \"\"\")\n    with ffi._lock:\n        type = ffi._parser.parse_type(\"fn_t\")\n        BType = ffi._get_cached_btype(type)\n    assert str(BType) == '<func (<pointer to <int>>), <int>, False>'\n\ndef test_remove_comments():\n    ffi = FFI(backend=FakeBackend())\n    ffi.cdef(\"\"\"\n        double /*comment here*/ sin   // blah blah\n        /* multi-\n           line-\n           //comment */  (\n        // foo\n        double // bar      /* <- ignored, because it's in a comment itself\n        x, double/*several*//*comment*/y) /*on the same line*/\n        ;\n    \"\"\")\n    m = ffi.dlopen(lib_m)\n    func = m.sin\n    assert func.name == 'sin'\n    assert func.BType == '<func (<double>, <double>), <double>, False>'\n\ndef test_remove_line_continuation_comments():\n    ffi = FFI(backend=FakeBackend())\n    ffi.cdef(\"\"\"\n        double // blah \\\\\n                  more comments\n        x(void);\n        double // blah\\\\\\\\\n        y(void);\n        double // blah\\\\ \\\n                  etc\n        z(void);\n    \"\"\")\n    m = ffi.dlopen(lib_m)\n    m.x\n    m.y\n    m.z\n\ndef test_line_continuation_in_defines():\n    ffi = FFI(backend=FakeBackend())\n    ffi.cdef(\"\"\"\n        #define ABC\\\\\n            42\n        #define BCD   \\\\\n            43\n    \"\"\")\n    m = ffi.dlopen(lib_m)\n    assert m.ABC == 42\n    assert m.BCD == 43\n\ndef test_define_not_supported_for_now():\n    ffi = FFI(backend=FakeBackend())\n    e = py.test.raises(CDefError, ffi.cdef, '#define FOO \"blah\"')\n    assert str(e.value) == (\n        'only supports one of the following syntax:\\n'\n        '  #define FOO ...     (literally dot-dot-dot)\\n'\n        '  #define FOO NUMBER  (with NUMBER an integer'\n                                    ' constant, decimal/hex/octal)\\n'\n        'got:\\n'\n        '  #define FOO \"blah\"')\n\ndef test_unnamed_struct():\n    ffi = FFI(backend=FakeBackend())\n    ffi.cdef(\"typedef struct { int x; } foo_t;\\n\"\n             \"typedef struct { int y; } *bar_p;\\n\")\n    assert 'typedef foo_t' in ffi._parser._declarations\n    assert 'typedef bar_p' in ffi._parser._declarations\n    assert 'anonymous foo_t' in ffi._parser._declarations\n    type_foo = ffi._parser.parse_type(\"foo_t\")\n    type_bar = ffi._parser.parse_type(\"bar_p\").totype\n    assert repr(type_foo) == \"<foo_t>\"\n    assert repr(type_bar) == \"<struct $1>\"\n    py.test.raises(VerificationError, type_bar.get_c_name)\n    assert type_foo.get_c_name() == \"foo_t\"\n\ndef test_override():\n    ffi = FFI(backend=FakeBackend())\n    needs_dlopen_none()\n    C = ffi.dlopen(None)\n    ffi.cdef(\"int foo(void);\")\n    py.test.raises(FFIError, ffi.cdef, \"long foo(void);\")\n    assert C.foo.BType == '<func (), <int>, False>'\n    ffi.cdef(\"long foo(void);\", override=True)\n    assert C.foo.BType == '<func (), <long>, False>'\n\ndef test_cannot_have_only_variadic_part():\n    # this checks that we get a sensible error if we try \"int foo(...);\"\n    ffi = FFI()\n    e = py.test.raises(CDefError, ffi.cdef, \"int foo(...);\")\n    assert str(e.value) == (\n           \"<cdef source string>:1: foo: a function with only '(...)' \"\n           \"as argument is not correct C\")\n\ndef test_parse_error():\n    ffi = FFI()\n    e = py.test.raises(CDefError, ffi.cdef, \" x y z \")\n    assert str(e.value).startswith(\n        'cannot parse \"x y z\"\\n<cdef source string>:1:')\n    e = py.test.raises(CDefError, ffi.cdef, \"\\n\\n\\n x y z \")\n    assert str(e.value).startswith(\n        'cannot parse \"x y z\"\\n<cdef source string>:4:')\n\ndef test_error_custom_lineno():\n    ffi = FFI()\n    e = py.test.raises(CDefError, ffi.cdef, \"\"\"\n# 42 \"foobar\"\n\n    a b c d\n    \"\"\")\n    assert str(e.value).startswith('parse error\\nfoobar:43:')\n\ndef test_cannot_declare_enum_later():\n    ffi = FFI()\n    e = py.test.raises(NotImplementedError, ffi.cdef,\n                       \"typedef enum foo_e foo_t; enum foo_e { AA, BB };\")\n    assert str(e.value) == (\n           \"enum foo_e: the '{}' declaration should appear on the \"\n           \"first time the enum is mentioned, not later\")\n\ndef test_unknown_name():\n    ffi = FFI()\n    e = py.test.raises(CDefError, ffi.cast, \"foobarbazunknown\", 0)\n    assert str(e.value) == \"unknown identifier 'foobarbazunknown'\"\n    e = py.test.raises(CDefError, ffi.cast, \"foobarbazunknown*\", 0)\n    assert str(e.value).startswith('cannot parse \"foobarbazunknown*\"')\n    e = py.test.raises(CDefError, ffi.cast, \"int(*)(foobarbazunknown)\", 0)\n    assert str(e.value).startswith('cannot parse \"int(*)(foobarbazunknown)\"')\n\ndef test_redefine_common_type():\n    prefix = \"\" if sys.version_info < (3,) else \"b\"\n    ffi = FFI()\n    ffi.cdef(\"typedef char FILE;\")\n    assert repr(ffi.cast(\"FILE\", 123)) == \"<cdata 'char' %s'{'>\" % prefix\n    ffi.cdef(\"typedef char int32_t;\")\n    assert repr(ffi.cast(\"int32_t\", 123)) == \"<cdata 'char' %s'{'>\" % prefix\n    ffi = FFI()\n    ffi.cdef(\"typedef int bool, *FILE;\")\n    assert repr(ffi.cast(\"bool\", 123)) == \"<cdata 'int' 123>\"\n    assert re.match(r\"<cdata 'int [*]' 0[xX]?0*7[bB]>\",\n                    repr(ffi.cast(\"FILE\", 123)))\n    ffi = FFI()\n    ffi.cdef(\"typedef bool (*fn_t)(bool, bool);\")   # \"bool,\" but within \"( )\"\n\ndef test_bool():\n    ffi = FFI()\n    ffi.cdef(\"void f(bool);\")\n    #\n    ffi = FFI()\n    ffi.cdef(\"typedef _Bool bool; void f(bool);\")\n\ndef test_unknown_argument_type():\n    ffi = FFI()\n    e = py.test.raises(CDefError, ffi.cdef, \"void f(foobarbazzz);\")\n    assert str(e.value) == (\"<cdef source string>:1: f arg 1:\"\n                            \" unknown type 'foobarbazzz' (if you meant\"\n                            \" to use the old C syntax of giving untyped\"\n                            \" arguments, it is not supported)\")\n\ndef test_void_renamed_as_only_arg():\n    ffi = FFI()\n    ffi.cdef(\"typedef void void_t1;\"\n             \"typedef void_t1 void_t;\"\n             \"typedef int (*func_t)(void_t);\")\n    assert ffi.typeof(\"func_t\").args == ()\n\ndef test_WPARAM_on_windows():\n    if sys.platform != 'win32':\n        py.test.skip(\"Only for Windows\")\n    ffi = FFI()\n    ffi.cdef(\"void f(WPARAM);\")\n    #\n    # WPARAM -> UINT_PTR -> unsigned 32/64-bit integer\n    ffi = FFI()\n    value = int(ffi.cast(\"WPARAM\", -42))\n    assert value == sys.maxsize * 2 - 40\n\ndef test__is_constant_globalvar():\n    for input, expected_output in [\n        (\"int a;\",          False),\n        (\"const int a;\",    True),\n        (\"int *a;\",         False),\n        (\"const int *a;\",   False),\n        (\"int const *a;\",   False),\n        (\"int *const a;\",   True),\n        (\"int a[5];\",       False),\n        (\"const int a[5];\", False),\n        (\"int *a[5];\",      False),\n        (\"const int *a[5];\", False),\n        (\"int const *a[5];\", False),\n        (\"int *const a[5];\", False),\n        (\"int a[5][6];\",       False),\n        (\"const int a[5][6];\", False),\n        ]:\n        ffi = FFI()\n        ffi.cdef(input)\n        declarations = ffi._parser._declarations\n        assert ('constant a' in declarations) == expected_output\n        assert ('variable a' in declarations) == (not expected_output)\n\ndef test_restrict():\n    from cffi import model\n    for input, expected_output in [\n        (\"int a;\",             False),\n        (\"restrict int a;\",    True),\n        (\"int *a;\",            False),\n        ]:\n        ffi = FFI()\n        ffi.cdef(input)\n        tp, quals = ffi._parser._declarations['variable a']\n        assert bool(quals & model.Q_RESTRICT) == expected_output\n\ndef test_different_const_funcptr_types():\n    lst = []\n    for input in [\n        \"int(*)(int *a)\",\n        \"int(*)(int const *a)\",\n        \"int(*)(int * const a)\",\n        \"int(*)(int const a[])\"]:\n        ffi = FFI(backend=FakeBackend())\n        lst.append(ffi._parser.parse_type(input))\n    assert lst[0] != lst[1]\n    assert lst[0] == lst[2]\n    assert lst[1] == lst[3]\n\ndef test_const_pointer_to_pointer():\n    from cffi import model\n    ffi = FFI(backend=FakeBackend())\n    #\n    tp, qual = ffi._parser.parse_type_and_quals(\"char * * (* const)\")\n    assert (str(tp), qual) == (\"<char * * *>\", model.Q_CONST)\n    tp, qual = ffi._parser.parse_type_and_quals(\"char * (* const (*))\")\n    assert (str(tp), qual) == (\"<char * * const *>\", 0)\n    tp, qual = ffi._parser.parse_type_and_quals(\"char (* const (* (*)))\")\n    assert (str(tp), qual) == (\"<char * const * *>\", 0)\n    tp, qual = ffi._parser.parse_type_and_quals(\"char const * * *\")\n    assert (str(tp), qual) == (\"<char const * * *>\", 0)\n    tp, qual = ffi._parser.parse_type_and_quals(\"const char * * *\")\n    assert (str(tp), qual) == (\"<char const * * *>\", 0)\n    #\n    tp, qual = ffi._parser.parse_type_and_quals(\"char * * * const const\")\n    assert (str(tp), qual) == (\"<char * * *>\", model.Q_CONST)\n    tp, qual = ffi._parser.parse_type_and_quals(\"char * * volatile *\")\n    assert (str(tp), qual) == (\"<char * * volatile *>\", 0)\n    tp, qual = ffi._parser.parse_type_and_quals(\"char * volatile restrict * *\")\n    assert (str(tp), qual) == (\"<char * __restrict volatile * *>\", 0)\n    tp, qual = ffi._parser.parse_type_and_quals(\"char const volatile * * *\")\n    assert (str(tp), qual) == (\"<char volatile const * * *>\", 0)\n    tp, qual = ffi._parser.parse_type_and_quals(\"const char * * *\")\n    assert (str(tp), qual) == (\"<char const * * *>\", 0)\n    #\n    tp, qual = ffi._parser.parse_type_and_quals(\n        \"int(char*const*, short****const*)\")\n    assert (str(tp), qual) == (\n        \"<int()(char * const *, short * * * * const *)>\", 0)\n    tp, qual = ffi._parser.parse_type_and_quals(\n        \"char*const*(short*const****)\")\n    assert (str(tp), qual) == (\n        \"<char * const *()(short * const * * * *)>\", 0)\n\ndef test_enum():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        enum Enum {\n            POS = +1,\n            TWO = 2,\n            NIL = 0,\n            NEG = -1,\n            ADDSUB = (POS+TWO)-1,\n            DIVMULINT = (3 * 3) / 2,\n            SHIFT = (1 << 3) >> 1,\n            BINOPS = (0x7 & 0x1) | 0x8,\n            XOR = 0xf ^ 0xa\n        };\n        \"\"\")\n    needs_dlopen_none()\n    C = ffi.dlopen(None)\n    assert C.POS == 1\n    assert C.TWO == 2\n    assert C.NIL == 0\n    assert C.NEG == -1\n    assert C.ADDSUB == 2\n    assert C.DIVMULINT == 4\n    assert C.SHIFT == 4\n    assert C.BINOPS == 0b1001\n    assert C.XOR == 0b0101\n\ndef test_stdcall():\n    ffi = FFI()\n    tp = ffi.typeof(\"int(*)(int __stdcall x(int),\"\n                    \"       long (__cdecl*y)(void),\"\n                    \"       short(WINAPI *z)(short))\")\n    if sys.platform == 'win32' and sys.maxsize < 2**32:\n        stdcall = '__stdcall '\n    else:\n        stdcall = ''\n    assert str(tp) == (\n        \"<ctype 'int(*)(int(%s*)(int), \"\n                        \"long(*)(), \"\n                        \"short(%s*)(short))'>\" % (stdcall, stdcall))\n\ndef test_extern_python():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        int bok(int, int);\n        extern \"Python\" int foobar(int, int);\n        int baz(int, int);\n    \"\"\")\n    assert sorted(ffi._parser._declarations) == [\n        'extern_python foobar', 'function baz', 'function bok']\n    assert (ffi._parser._declarations['function bok'] ==\n            ffi._parser._declarations['extern_python foobar'] ==\n            ffi._parser._declarations['function baz'])\n\ndef test_extern_python_group():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        int bok(int);\n        extern \"Python\" {int foobar(int, int);int bzrrr(int);}\n        int baz(int, int);\n    \"\"\")\n    assert sorted(ffi._parser._declarations) == [\n        'extern_python bzrrr', 'extern_python foobar',\n        'function baz', 'function bok']\n    assert (ffi._parser._declarations['function baz'] ==\n            ffi._parser._declarations['extern_python foobar'] !=\n            ffi._parser._declarations['function bok'] ==\n            ffi._parser._declarations['extern_python bzrrr'])\n\ndef test_error_invalid_syntax_for_cdef():\n    ffi = FFI()\n    e = py.test.raises(CDefError, ffi.cdef, 'void foo(void) {}')\n    assert str(e.value) == ('<cdef source string>:1: unexpected <FuncDef>: '\n                            'this construct is valid C but not valid in cdef()')\n\ndef test_unsigned_int_suffix_for_constant():\n    ffi = FFI()\n    ffi.cdef(\"\"\"enum e {\n                    bin_0=0b10,\n                    bin_1=0b10u,\n                    bin_2=0b10U,\n                    bin_3=0b10l,\n                    bin_4=0b10L,\n                    bin_5=0b10ll,\n                    bin_6=0b10LL,\n                    oct_0=010,\n                    oct_1=010u,\n                    oct_2=010U,\n                    oct_3=010l,\n                    oct_4=010L,\n                    oct_5=010ll,\n                    oct_6=010LL,\n                    dec_0=10,\n                    dec_1=10u,\n                    dec_2=10U,\n                    dec_3=10l,\n                    dec_4=10L,\n                    dec_5=10ll,\n                    dec_6=10LL,\n                    hex_0=0x10,\n                    hex_1=0x10u,\n                    hex_2=0x10U,\n                    hex_3=0x10l,\n                    hex_4=0x10L,\n                    hex_5=0x10ll,\n                    hex_6=0x10LL,};\"\"\")\n    needs_dlopen_none()\n    C = ffi.dlopen(None)\n    for base, expected_result in (('bin', 2), ('oct', 8), ('dec', 10), ('hex', 16)):\n        for index in range(7):\n            assert getattr(C, '{base}_{index}'.format(base=base, index=index)) == expected_result\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.13.0-jlicqgsrlask3n7tsdckxmdwv6d5zp4o/spack-src/testing/cffi0/test_unicode_literals.py": "#\n# ----------------------------------------------\n# WARNING, ALL LITERALS IN THIS FILE ARE UNICODE\n# ----------------------------------------------\n#\nfrom __future__ import unicode_literals\n#\n#\n#\nimport sys, math\nfrom cffi import FFI\n\nlib_m = \"m\"\nif sys.platform == 'win32':\n    #there is a small chance this fails on Mingw via environ $CC\n    import distutils.ccompiler\n    if distutils.ccompiler.get_default_compiler() == 'msvc':\n        lib_m = 'msvcrt'\n\n\ndef test_cast():\n    ffi = FFI()\n    assert int(ffi.cast(\"int\", 3.14)) == 3        # unicode literal\n\ndef test_new():\n    ffi = FFI()\n    assert ffi.new(\"int[]\", [3, 4, 5])[2] == 5    # unicode literal\n\ndef test_typeof():\n    ffi = FFI()\n    tp = ffi.typeof(\"int[51]\")                    # unicode literal\n    assert tp.length == 51\n\ndef test_sizeof():\n    ffi = FFI()\n    assert ffi.sizeof(\"int[51]\") == 51 * 4        # unicode literal\n\ndef test_alignof():\n    ffi = FFI()\n    assert ffi.alignof(\"int[51]\") == 4            # unicode literal\n\ndef test_getctype():\n    ffi = FFI()\n    assert ffi.getctype(\"int**\") == \"int * *\"     # unicode literal\n    assert type(ffi.getctype(\"int**\")) is str\n\ndef test_cdef():\n    ffi = FFI()\n    ffi.cdef(\"typedef int foo_t[50];\")            # unicode literal\n\ndef test_offsetof():\n    ffi = FFI()\n    ffi.cdef(\"typedef struct { int x, y; } foo_t;\")\n    assert ffi.offsetof(\"foo_t\", \"y\") == 4        # unicode literal\n\ndef test_enum():\n    ffi = FFI()\n    ffi.cdef(\"enum foo_e { AA, BB, CC };\")        # unicode literal\n    x = ffi.cast(\"enum foo_e\", 1)\n    assert int(ffi.cast(\"int\", x)) == 1\n\ndef test_dlopen():\n    ffi = FFI()\n    ffi.cdef(\"double sin(double x);\")\n    m = ffi.dlopen(lib_m)                           # unicode literal\n    x = m.sin(1.23)\n    assert x == math.sin(1.23)\n\ndef test_verify():\n    ffi = FFI()\n    ffi.cdef(\"double test_verify_1(double x);\")   # unicode literal\n    lib = ffi.verify(\"double test_verify_1(double x) { return x * 42.0; }\")\n    assert lib.test_verify_1(-1.5) == -63.0\n\ndef test_callback():\n    ffi = FFI()\n    cb = ffi.callback(\"int(int)\",                 # unicode literal\n                      lambda x: x + 42)\n    assert cb(5) == 47\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.13.0-jlicqgsrlask3n7tsdckxmdwv6d5zp4o/spack-src/testing/cffi0/test_function.py": "import py\nimport pytest\nfrom cffi import FFI, CDefError\nimport math, os, sys\nimport ctypes.util\nfrom cffi.backend_ctypes import CTypesBackend\nfrom testing.udir import udir\nfrom testing.support import FdWriteCapture\nfrom .backend_tests import needs_dlopen_none\n\ntry:\n    from StringIO import StringIO\nexcept ImportError:\n    from io import StringIO\n\n\nlib_m = 'm'\nif sys.platform == 'win32':\n    #there is a small chance this fails on Mingw via environ $CC\n    import distutils.ccompiler\n    if distutils.ccompiler.get_default_compiler() == 'msvc':\n        lib_m = 'msvcrt'\n\nclass TestFunction(object):\n    Backend = CTypesBackend\n\n    def test_sin(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            double sin(double x);\n        \"\"\")\n        m = ffi.dlopen(lib_m)\n        x = m.sin(1.23)\n        assert x == math.sin(1.23)\n\n    def test_sinf(self):\n        if sys.platform == 'win32':\n            py.test.skip(\"no sinf found in the Windows stdlib\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            float sinf(float x);\n        \"\"\")\n        m = ffi.dlopen(lib_m)\n        x = m.sinf(1.23)\n        assert type(x) is float\n        assert x != math.sin(1.23)    # rounding effects\n        assert abs(x - math.sin(1.23)) < 1E-6\n\n    def test_getenv_no_return_value(self):\n        # check that 'void'-returning functions work too\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            void getenv(char *);\n        \"\"\")\n        needs_dlopen_none()\n        m = ffi.dlopen(None)\n        x = m.getenv(b\"FOO\")\n        assert x is None\n\n    def test_dlopen_filename(self):\n        path = ctypes.util.find_library(lib_m)\n        if not path:\n            py.test.skip(\"%s not found\" % lib_m)\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            double cos(double x);\n        \"\"\")\n        m = ffi.dlopen(path)\n        x = m.cos(1.23)\n        assert x == math.cos(1.23)\n\n        m = ffi.dlopen(os.path.basename(path))\n        x = m.cos(1.23)\n        assert x == math.cos(1.23)\n\n    def test_dlopen_flags(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            double cos(double x);\n        \"\"\")\n        m = ffi.dlopen(lib_m, ffi.RTLD_LAZY | ffi.RTLD_LOCAL)\n        x = m.cos(1.23)\n        assert x == math.cos(1.23)\n\n    def test_dlopen_constant(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            #define FOOBAR 42\n            static const float baz = 42.5;   /* not visible */\n            double sin(double x);\n        \"\"\")\n        m = ffi.dlopen(lib_m)\n        assert m.FOOBAR == 42\n        with pytest.raises(NotImplementedError):\n            m.baz\n\n    def test_tlsalloc(self):\n        if sys.platform != 'win32':\n            py.test.skip(\"win32 only\")\n        if self.Backend is CTypesBackend:\n            py.test.skip(\"ctypes complains on wrong calling conv\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"long TlsAlloc(void); int TlsFree(long);\")\n        lib = ffi.dlopen('KERNEL32.DLL')\n        x = lib.TlsAlloc()\n        assert x != 0\n        y = lib.TlsFree(x)\n        assert y != 0\n\n    def test_fputs(self):\n        if not sys.platform.startswith('linux'):\n            py.test.skip(\"probably no symbol 'stderr' in the lib\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            int fputs(const char *, void *);\n            void *stderr;\n        \"\"\")\n        needs_dlopen_none()\n        ffi.C = ffi.dlopen(None)\n        ffi.C.fputs   # fetch before capturing, for easier debugging\n        with FdWriteCapture() as fd:\n            ffi.C.fputs(b\"hello\\n\", ffi.C.stderr)\n            ffi.C.fputs(b\"  world\\n\", ffi.C.stderr)\n        res = fd.getvalue()\n        assert res == b'hello\\n  world\\n'\n\n    def test_fputs_without_const(self):\n        if not sys.platform.startswith('linux'):\n            py.test.skip(\"probably no symbol 'stderr' in the lib\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            int fputs(char *, void *);\n            void *stderr;\n        \"\"\")\n        needs_dlopen_none()\n        ffi.C = ffi.dlopen(None)\n        ffi.C.fputs   # fetch before capturing, for easier debugging\n        with FdWriteCapture() as fd:\n            ffi.C.fputs(b\"hello\\n\", ffi.C.stderr)\n            ffi.C.fputs(b\"  world\\n\", ffi.C.stderr)\n        res = fd.getvalue()\n        assert res == b'hello\\n  world\\n'\n\n    def test_vararg(self):\n        if not sys.platform.startswith('linux'):\n            py.test.skip(\"probably no symbol 'stderr' in the lib\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n           int fprintf(void *, const char *format, ...);\n           void *stderr;\n        \"\"\")\n        needs_dlopen_none()\n        ffi.C = ffi.dlopen(None)\n        with FdWriteCapture() as fd:\n            ffi.C.fprintf(ffi.C.stderr, b\"hello with no arguments\\n\")\n            ffi.C.fprintf(ffi.C.stderr,\n                          b\"hello, %s!\\n\", ffi.new(\"char[]\", b\"world\"))\n            ffi.C.fprintf(ffi.C.stderr,\n                          ffi.new(\"char[]\", b\"hello, %s!\\n\"),\n                          ffi.new(\"char[]\", b\"world2\"))\n            ffi.C.fprintf(ffi.C.stderr,\n                          b\"hello int %d long %ld long long %lld\\n\",\n                          ffi.cast(\"int\", 42),\n                          ffi.cast(\"long\", 84),\n                          ffi.cast(\"long long\", 168))\n            ffi.C.fprintf(ffi.C.stderr, b\"hello %p\\n\", ffi.NULL)\n        res = fd.getvalue()\n        assert res == (b\"hello with no arguments\\n\"\n                       b\"hello, world!\\n\"\n                       b\"hello, world2!\\n\"\n                       b\"hello int 42 long 84 long long 168\\n\"\n                       b\"hello (nil)\\n\")\n\n    def test_must_specify_type_of_vararg(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n           int printf(const char *format, ...);\n        \"\"\")\n        needs_dlopen_none()\n        ffi.C = ffi.dlopen(None)\n        e = py.test.raises(TypeError, ffi.C.printf, b\"hello %d\\n\", 42)\n        assert str(e.value) == (\"argument 2 passed in the variadic part \"\n                                \"needs to be a cdata object (got int)\")\n\n    def test_function_has_a_c_type(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            int puts(const char *);\n        \"\"\")\n        needs_dlopen_none()\n        ffi.C = ffi.dlopen(None)\n        fptr = ffi.C.puts\n        assert ffi.typeof(fptr) == ffi.typeof(\"int(*)(const char*)\")\n        if self.Backend is CTypesBackend:\n            assert repr(fptr).startswith(\"<cdata 'int puts(char *)' 0x\")\n\n    def test_function_pointer(self):\n        ffi = FFI(backend=self.Backend())\n        def cb(charp):\n            assert repr(charp).startswith(\"<cdata 'char *' 0x\")\n            return 42\n        fptr = ffi.callback(\"int(*)(const char *txt)\", cb)\n        assert fptr != ffi.callback(\"int(*)(const char *)\", cb)\n        assert repr(fptr) == \"<cdata 'int(*)(char *)' calling %r>\" % (cb,)\n        res = fptr(b\"Hello\")\n        assert res == 42\n        #\n        if not sys.platform.startswith('linux'):\n            py.test.skip(\"probably no symbol 'stderr' in the lib\")\n        ffi.cdef(\"\"\"\n            int fputs(const char *, void *);\n            void *stderr;\n        \"\"\")\n        needs_dlopen_none()\n        ffi.C = ffi.dlopen(None)\n        fptr = ffi.cast(\"int(*)(const char *txt, void *)\", ffi.C.fputs)\n        assert fptr == ffi.C.fputs\n        assert repr(fptr).startswith(\"<cdata 'int(*)(char *, void *)' 0x\")\n        with FdWriteCapture() as fd:\n            fptr(b\"world\\n\", ffi.C.stderr)\n        res = fd.getvalue()\n        assert res == b'world\\n'\n\n    def test_callback_returning_void(self):\n        ffi = FFI(backend=self.Backend())\n        for returnvalue in [None, 42]:\n            def cb():\n                return returnvalue\n            fptr = ffi.callback(\"void(*)(void)\", cb)\n            old_stderr = sys.stderr\n            try:\n                sys.stderr = StringIO()\n                returned = fptr()\n                printed = sys.stderr.getvalue()\n            finally:\n                sys.stderr = old_stderr\n            assert returned is None\n            if returnvalue is None:\n                assert printed == ''\n            else:\n                assert \"None\" in printed\n\n    def test_passing_array(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            int strlen(char[]);\n        \"\"\")\n        needs_dlopen_none()\n        ffi.C = ffi.dlopen(None)\n        p = ffi.new(\"char[]\", b\"hello\")\n        res = ffi.C.strlen(p)\n        assert res == 5\n\n    def test_write_variable(self):\n        if not sys.platform.startswith('linux'):\n            py.test.skip(\"probably no symbol 'stdout' in the lib\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            void *stdout;\n        \"\"\")\n        needs_dlopen_none()\n        C = ffi.dlopen(None)\n        pout = C.stdout\n        C.stdout = ffi.NULL\n        assert C.stdout == ffi.NULL\n        C.stdout = pout\n        assert C.stdout == pout\n\n    def test_strchr(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            char *strchr(const char *s, int c);\n        \"\"\")\n        needs_dlopen_none()\n        ffi.C = ffi.dlopen(None)\n        p = ffi.new(\"char[]\", b\"hello world!\")\n        q = ffi.C.strchr(p, ord('w'))\n        assert ffi.string(q) == b\"world!\"\n\n    def test_function_with_struct_argument(self):\n        if sys.platform == 'win32':\n            py.test.skip(\"no 'inet_ntoa'\")\n        if (self.Backend is CTypesBackend and\n            '__pypy__' in sys.builtin_module_names):\n            py.test.skip(\"ctypes limitation on pypy\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            struct in_addr { unsigned int s_addr; };\n            char *inet_ntoa(struct in_addr in);\n        \"\"\")\n        needs_dlopen_none()\n        ffi.C = ffi.dlopen(None)\n        ina = ffi.new(\"struct in_addr *\", [0x04040404])\n        a = ffi.C.inet_ntoa(ina[0])\n        assert ffi.string(a) == b'4.4.4.4'\n\n    def test_function_typedef(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            typedef double func_t(double);\n            func_t sin;\n        \"\"\")\n        m = ffi.dlopen(lib_m)\n        x = m.sin(1.23)\n        assert x == math.sin(1.23)\n\n    def test_fputs_custom_FILE(self):\n        if self.Backend is CTypesBackend:\n            py.test.skip(\"FILE not supported with the ctypes backend\")\n        filename = str(udir.join('fputs_custom_FILE'))\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"int fputs(const char *, FILE *);\")\n        needs_dlopen_none()\n        C = ffi.dlopen(None)\n        with open(filename, 'wb') as f:\n            f.write(b'[')\n            C.fputs(b\"hello from custom file\", f)\n            f.write(b'][')\n            C.fputs(b\"some more output\", f)\n            f.write(b']')\n        with open(filename, 'rb') as f:\n            res = f.read()\n        assert res == b'[hello from custom file][some more output]'\n\n    def test_constants_on_lib(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"enum foo_e { AA, BB, CC=5, DD };\n                    typedef enum { EE=-5, FF } some_enum_t;\"\"\")\n        needs_dlopen_none()\n        lib = ffi.dlopen(None)\n        assert lib.AA == 0\n        assert lib.BB == 1\n        assert lib.CC == 5\n        assert lib.DD == 6\n        assert lib.EE == -5\n        assert lib.FF == -4\n\n    def test_void_star_accepts_string(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"int strlen(const void *);\"\"\")\n        needs_dlopen_none()\n        lib = ffi.dlopen(None)\n        res = lib.strlen(b\"hello\")\n        assert res == 5\n\n    def test_signed_char_star_accepts_string(self):\n        if self.Backend is CTypesBackend:\n            py.test.skip(\"not supported by the ctypes backend\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"int strlen(signed char *);\"\"\")\n        needs_dlopen_none()\n        lib = ffi.dlopen(None)\n        res = lib.strlen(b\"hello\")\n        assert res == 5\n\n    def test_unsigned_char_star_accepts_string(self):\n        if self.Backend is CTypesBackend:\n            py.test.skip(\"not supported by the ctypes backend\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"int strlen(unsigned char *);\"\"\")\n        needs_dlopen_none()\n        lib = ffi.dlopen(None)\n        res = lib.strlen(b\"hello\")\n        assert res == 5\n\n    def test_missing_function(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            int nonexistent();\n        \"\"\")\n        m = ffi.dlopen(lib_m)\n        assert not hasattr(m, 'nonexistent')\n\n    def test_wraps_from_stdlib(self):\n        import functools\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            double sin(double x);\n        \"\"\")\n        def my_decorator(f):\n            @functools.wraps(f)\n            def wrapper(*args):\n                return f(*args) + 100\n            return wrapper\n        m = ffi.dlopen(lib_m)\n        sin100 = my_decorator(m.sin)\n        x = sin100(1.23)\n        assert x == math.sin(1.23) + 100\n\n    def test_free_callback_cycle(self):\n        if self.Backend is CTypesBackend:\n            py.test.skip(\"seems to fail with the ctypes backend on windows\")\n        import weakref\n        def make_callback(data):\n            container = [data]\n            callback = ffi.callback('int()', lambda: len(container))\n            container.append(callback)\n            # Ref cycle: callback -> lambda (closure) -> container -> callback\n            return callback\n\n        class Data(object):\n            pass\n        ffi = FFI(backend=self.Backend())\n        data = Data()\n        callback = make_callback(data)\n        wr = weakref.ref(data)\n        del callback, data\n        for i in range(3):\n            if wr() is not None:\n                import gc; gc.collect()\n        assert wr() is None    # 'data' does not leak\n\n    def test_windows_stdcall(self):\n        if sys.platform != 'win32':\n            py.test.skip(\"Windows-only test\")\n        if self.Backend is CTypesBackend:\n            py.test.skip(\"not with the ctypes backend\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            BOOL QueryPerformanceFrequency(LONGLONG *lpFrequency);\n        \"\"\")\n        m = ffi.dlopen(\"Kernel32.dll\")\n        p_freq = ffi.new(\"LONGLONG *\")\n        res = m.QueryPerformanceFrequency(p_freq)\n        assert res != 0\n        assert p_freq[0] != 0\n\n    def test_explicit_cdecl_stdcall(self):\n        if sys.platform != 'win32':\n            py.test.skip(\"Windows-only test\")\n        if self.Backend is CTypesBackend:\n            py.test.skip(\"not with the ctypes backend\")\n        win64 = (sys.maxsize > 2**32)\n        #\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            BOOL QueryPerformanceFrequency(LONGLONG *lpFrequency);\n        \"\"\")\n        m = ffi.dlopen(\"Kernel32.dll\")\n        tp = ffi.typeof(m.QueryPerformanceFrequency)\n        assert str(tp) == \"<ctype 'int(*)(long long *)'>\"\n        #\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            BOOL __cdecl QueryPerformanceFrequency(LONGLONG *lpFrequency);\n        \"\"\")\n        m = ffi.dlopen(\"Kernel32.dll\")\n        tpc = ffi.typeof(m.QueryPerformanceFrequency)\n        assert tpc is tp\n        #\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            BOOL WINAPI QueryPerformanceFrequency(LONGLONG *lpFrequency);\n        \"\"\")\n        m = ffi.dlopen(\"Kernel32.dll\")\n        tps = ffi.typeof(m.QueryPerformanceFrequency)\n        if win64:\n            assert tps is tpc\n        else:\n            assert tps is not tpc\n            assert str(tps) == \"<ctype 'int(__stdcall *)(long long *)'>\"\n        #\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"typedef int (__cdecl *fnc_t)(int);\")\n        ffi.cdef(\"typedef int (__stdcall *fns_t)(int);\")\n        tpc = ffi.typeof(\"fnc_t\")\n        tps = ffi.typeof(\"fns_t\")\n        assert str(tpc) == \"<ctype 'int(*)(int)'>\"\n        if win64:\n            assert tps is tpc\n        else:\n            assert str(tps) == \"<ctype 'int(__stdcall *)(int)'>\"\n        #\n        fnc = ffi.cast(\"fnc_t\", 0)\n        fns = ffi.cast(\"fns_t\", 0)\n        ffi.new(\"fnc_t[]\", [fnc])\n        if not win64:\n            py.test.raises(TypeError, ffi.new, \"fnc_t[]\", [fns])\n            py.test.raises(TypeError, ffi.new, \"fns_t[]\", [fnc])\n        ffi.new(\"fns_t[]\", [fns])\n\n    def test_stdcall_only_on_windows(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"double __stdcall sin(double x);\")     # stdcall ignored\n        m = ffi.dlopen(lib_m)\n        if (sys.platform == 'win32' and sys.maxsize < 2**32 and\n                self.Backend is not CTypesBackend):\n            assert \"double(__stdcall *)(double)\" in str(ffi.typeof(m.sin))\n        else:\n            assert \"double(*)(double)\" in str(ffi.typeof(m.sin))\n        x = m.sin(1.23)\n        assert x == math.sin(1.23)\n\n    def test_dir_on_dlopen_lib(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            typedef enum { MYE1, MYE2 } myenum_t;\n            double myfunc(double);\n            double myvar;\n            const double myconst;\n            #define MYFOO 42\n        \"\"\")\n        m = ffi.dlopen(lib_m)\n        assert dir(m) == ['MYE1', 'MYE2', 'MYFOO', 'myconst', 'myfunc', 'myvar']\n\n    def test_dlclose(self):\n        if self.Backend is CTypesBackend:\n            py.test.skip(\"not with the ctypes backend\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"int foobar(void); int foobaz;\")\n        lib = ffi.dlopen(lib_m)\n        ffi.dlclose(lib)\n        e = py.test.raises(ValueError, getattr, lib, 'foobar')\n        assert str(e.value).startswith(\"library '\")\n        assert str(e.value).endswith(\"' has already been closed\")\n        e = py.test.raises(ValueError, getattr, lib, 'foobaz')\n        assert str(e.value).startswith(\"library '\")\n        assert str(e.value).endswith(\"' has already been closed\")\n        e = py.test.raises(ValueError, setattr, lib, 'foobaz', 42)\n        assert str(e.value).startswith(\"library '\")\n        assert str(e.value).endswith(\"' has already been closed\")\n        ffi.dlclose(lib)    # does not raise\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.13.0-jlicqgsrlask3n7tsdckxmdwv6d5zp4o/spack-src/testing/cffi0/backend_tests.py": "import py\nimport pytest\nimport platform\nimport sys, ctypes\nfrom cffi import FFI, CDefError, FFIError, VerificationMissing\nfrom testing.support import *\n\nSIZE_OF_INT   = ctypes.sizeof(ctypes.c_int)\nSIZE_OF_LONG  = ctypes.sizeof(ctypes.c_long)\nSIZE_OF_SHORT = ctypes.sizeof(ctypes.c_short)\nSIZE_OF_PTR   = ctypes.sizeof(ctypes.c_void_p)\nSIZE_OF_WCHAR = ctypes.sizeof(ctypes.c_wchar)\n\ndef needs_dlopen_none():\n    if sys.platform == 'win32' and sys.version_info >= (3,):\n        py.test.skip(\"dlopen(None) cannot work on Windows for Python 3\")\n\n\nclass BackendTests:\n\n    def test_integer_ranges(self):\n        ffi = FFI(backend=self.Backend())\n        for (c_type, size) in [('char', 1),\n                               ('short', 2),\n                               ('short int', 2),\n                               ('', 4),\n                               ('int', 4),\n                               ('long', SIZE_OF_LONG),\n                               ('long int', SIZE_OF_LONG),\n                               ('long long', 8),\n                               ('long long int', 8),\n                               ]:\n            for unsigned in [None, False, True]:\n                c_decl = {None: '',\n                          False: 'signed ',\n                          True: 'unsigned '}[unsigned] + c_type\n                if c_decl == 'char' or c_decl == '':\n                    continue\n                self._test_int_type(ffi, c_decl, size, unsigned)\n\n    def test_fixedsize_int(self):\n        ffi = FFI(backend=self.Backend())\n        for size in [1, 2, 4, 8]:\n            self._test_int_type(ffi, 'int%d_t' % (8*size), size, False)\n            self._test_int_type(ffi, 'uint%d_t' % (8*size), size, True)\n        self._test_int_type(ffi, 'intptr_t', SIZE_OF_PTR, False)\n        self._test_int_type(ffi, 'uintptr_t', SIZE_OF_PTR, True)\n        self._test_int_type(ffi, 'ptrdiff_t', SIZE_OF_PTR, False)\n        self._test_int_type(ffi, 'size_t', SIZE_OF_PTR, True)\n        self._test_int_type(ffi, 'ssize_t', SIZE_OF_PTR, False)\n\n    def _test_int_type(self, ffi, c_decl, size, unsigned):\n        if unsigned:\n            min = 0\n            max = (1 << (8*size)) - 1\n        else:\n            min = -(1 << (8*size-1))\n            max = (1 << (8*size-1)) - 1\n        min = int(min)\n        max = int(max)\n        p = ffi.cast(c_decl, min)\n        assert p == min\n        assert hash(p) == hash(min)\n        assert bool(p) is bool(min)\n        assert int(p) == min\n        p = ffi.cast(c_decl, max)\n        assert int(p) == max\n        p = ffi.cast(c_decl, long(max))\n        assert int(p) == max\n        q = ffi.cast(c_decl, min - 1)\n        assert ffi.typeof(q) is ffi.typeof(p) and int(q) == max\n        q = ffi.cast(c_decl, long(min - 1))\n        assert ffi.typeof(q) is ffi.typeof(p) and int(q) == max\n        assert q == p\n        assert int(q) == int(p)\n        assert hash(q) == hash(p)\n        c_decl_ptr = '%s *' % c_decl\n        py.test.raises(OverflowError, ffi.new, c_decl_ptr, min - 1)\n        py.test.raises(OverflowError, ffi.new, c_decl_ptr, max + 1)\n        py.test.raises(OverflowError, ffi.new, c_decl_ptr, long(min - 1))\n        py.test.raises(OverflowError, ffi.new, c_decl_ptr, long(max + 1))\n        assert ffi.new(c_decl_ptr, min)[0] == min\n        assert ffi.new(c_decl_ptr, max)[0] == max\n        assert ffi.new(c_decl_ptr, long(min))[0] == min\n        assert ffi.new(c_decl_ptr, long(max))[0] == max\n\n    def test_new_unsupported_type(self):\n        ffi = FFI(backend=self.Backend())\n        e = py.test.raises(TypeError, ffi.new, \"int\")\n        assert str(e.value) == \"expected a pointer or array ctype, got 'int'\"\n\n    def test_new_single_integer(self):\n        ffi = FFI(backend=self.Backend())\n        p = ffi.new(\"int *\")     # similar to ffi.new(\"int[1]\")\n        assert p[0] == 0\n        p[0] = -123\n        assert p[0] == -123\n        p = ffi.new(\"int *\", -42)\n        assert p[0] == -42\n        assert repr(p) == \"<cdata 'int *' owning %d bytes>\" % SIZE_OF_INT\n\n    def test_new_array_no_arg(self):\n        ffi = FFI(backend=self.Backend())\n        p = ffi.new(\"int[10]\")\n        # the object was zero-initialized:\n        for i in range(10):\n            assert p[i] == 0\n\n    def test_array_indexing(self):\n        ffi = FFI(backend=self.Backend())\n        p = ffi.new(\"int[10]\")\n        p[0] = 42\n        p[9] = 43\n        assert p[0] == 42\n        assert p[9] == 43\n        with pytest.raises(IndexError):\n            p[10]\n        with pytest.raises(IndexError):\n            p[10] = 44\n        with pytest.raises(IndexError):\n            p[-1]\n        with pytest.raises(IndexError):\n            p[-1] = 44\n\n    def test_new_array_args(self):\n        ffi = FFI(backend=self.Backend())\n        # this tries to be closer to C: where we say \"int x[5] = {10, 20, ..}\"\n        # then here we must enclose the items in a list\n        p = ffi.new(\"int[5]\", [10, 20, 30, 40, 50])\n        assert p[0] == 10\n        assert p[1] == 20\n        assert p[2] == 30\n        assert p[3] == 40\n        assert p[4] == 50\n        p = ffi.new(\"int[4]\", [25])\n        assert p[0] == 25\n        assert p[1] == 0     # follow C convention rather than LuaJIT's\n        assert p[2] == 0\n        assert p[3] == 0\n        p = ffi.new(\"int[4]\", [ffi.cast(\"int\", -5)])\n        assert p[0] == -5\n        assert repr(p) == \"<cdata 'int[4]' owning %d bytes>\" % (4*SIZE_OF_INT)\n\n    def test_new_array_varsize(self):\n        ffi = FFI(backend=self.Backend())\n        p = ffi.new(\"int[]\", 10)     # a single integer is the length\n        assert p[9] == 0\n        with pytest.raises(IndexError):\n            p[10]\n        #\n        py.test.raises(TypeError, ffi.new, \"int[]\")\n        #\n        p = ffi.new(\"int[]\", [-6, -7])    # a list is all the items, like C\n        assert p[0] == -6\n        assert p[1] == -7\n        with pytest.raises(IndexError):\n            p[2]\n        assert repr(p) == \"<cdata 'int[]' owning %d bytes>\" % (2*SIZE_OF_INT)\n        #\n        p = ffi.new(\"int[]\", 0)\n        with pytest.raises(IndexError):\n            p[0]\n        py.test.raises(ValueError, ffi.new, \"int[]\", -1)\n        assert repr(p) == \"<cdata 'int[]' owning 0 bytes>\"\n\n    def test_pointer_init(self):\n        ffi = FFI(backend=self.Backend())\n        n = ffi.new(\"int *\", 24)\n        a = ffi.new(\"int *[10]\", [ffi.NULL, ffi.NULL, n, n, ffi.NULL])\n        for i in range(10):\n            if i not in (2, 3):\n                assert a[i] == ffi.NULL\n        assert a[2] == a[3] == n\n\n    def test_cannot_cast(self):\n        ffi = FFI(backend=self.Backend())\n        a = ffi.new(\"short int[10]\")\n        e = py.test.raises(TypeError, ffi.new, \"long int **\", a)\n        msg = str(e.value)\n        assert \"'short[10]'\" in msg and \"'long *'\" in msg\n\n    def test_new_pointer_to_array(self):\n        ffi = FFI(backend=self.Backend())\n        a = ffi.new(\"int[4]\", [100, 102, 104, 106])\n        p = ffi.new(\"int **\", a)\n        assert p[0] == ffi.cast(\"int *\", a)\n        assert p[0][2] == 104\n        p = ffi.cast(\"int *\", a)\n        assert p[0] == 100\n        assert p[1] == 102\n        assert p[2] == 104\n        assert p[3] == 106\n        # keepalive: a\n\n    def test_pointer_direct(self):\n        ffi = FFI(backend=self.Backend())\n        p = ffi.cast(\"int*\", 0)\n        assert p is not None\n        assert bool(p) is False\n        assert p == ffi.cast(\"int*\", 0)\n        assert p != None\n        assert repr(p) == \"<cdata 'int *' NULL>\"\n        a = ffi.new(\"int[]\", [123, 456])\n        p = ffi.cast(\"int*\", a)\n        assert bool(p) is True\n        assert p == ffi.cast(\"int*\", a)\n        assert p != ffi.cast(\"int*\", 0)\n        assert p[0] == 123\n        assert p[1] == 456\n\n    def test_repr(self):\n        typerepr = self.TypeRepr\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo { short a, b, c; };\")\n        p = ffi.cast(\"short unsigned int\", 0)\n        assert repr(p) == \"<cdata 'unsigned short' 0>\"\n        assert repr(ffi.typeof(p)) == typerepr % \"unsigned short\"\n        p = ffi.cast(\"unsigned short int\", 0)\n        assert repr(p) == \"<cdata 'unsigned short' 0>\"\n        assert repr(ffi.typeof(p)) == typerepr % \"unsigned short\"\n        p = ffi.cast(\"int*\", 0)\n        assert repr(p) == \"<cdata 'int *' NULL>\"\n        assert repr(ffi.typeof(p)) == typerepr % \"int *\"\n        #\n        p = ffi.new(\"int*\")\n        assert repr(p) == \"<cdata 'int *' owning %d bytes>\" % SIZE_OF_INT\n        assert repr(ffi.typeof(p)) == typerepr % \"int *\"\n        p = ffi.new(\"int**\")\n        assert repr(p) == \"<cdata 'int * *' owning %d bytes>\" % SIZE_OF_PTR\n        assert repr(ffi.typeof(p)) == typerepr % \"int * *\"\n        p = ffi.new(\"int [2]\")\n        assert repr(p) == \"<cdata 'int[2]' owning %d bytes>\" % (2*SIZE_OF_INT)\n        assert repr(ffi.typeof(p)) == typerepr % \"int[2]\"\n        p = ffi.new(\"int*[2][3]\")\n        assert repr(p) == \"<cdata 'int *[2][3]' owning %d bytes>\" % (\n            6*SIZE_OF_PTR)\n        assert repr(ffi.typeof(p)) == typerepr % \"int *[2][3]\"\n        p = ffi.new(\"struct foo *\")\n        assert repr(p) == \"<cdata 'struct foo *' owning %d bytes>\" % (\n            3*SIZE_OF_SHORT)\n        assert repr(ffi.typeof(p)) == typerepr % \"struct foo *\"\n        #\n        q = ffi.cast(\"short\", -123)\n        assert repr(q) == \"<cdata 'short' -123>\"\n        assert repr(ffi.typeof(q)) == typerepr % \"short\"\n        p = ffi.new(\"int*\")\n        q = ffi.cast(\"short*\", p)\n        assert repr(q).startswith(\"<cdata 'short *' 0x\")\n        assert repr(ffi.typeof(q)) == typerepr % \"short *\"\n        p = ffi.new(\"int [2]\")\n        q = ffi.cast(\"int*\", p)\n        assert repr(q).startswith(\"<cdata 'int *' 0x\")\n        assert repr(ffi.typeof(q)) == typerepr % \"int *\"\n        p = ffi.new(\"struct foo*\")\n        q = ffi.cast(\"struct foo *\", p)\n        assert repr(q).startswith(\"<cdata 'struct foo *' 0x\")\n        assert repr(ffi.typeof(q)) == typerepr % \"struct foo *\"\n        prevrepr = repr(q)\n        q = q[0]\n        assert repr(q) == prevrepr.replace(' *', ' &')\n        assert repr(ffi.typeof(q)) == typerepr % \"struct foo\"\n\n    def test_new_array_of_array(self):\n        ffi = FFI(backend=self.Backend())\n        p = ffi.new(\"int[3][4]\")\n        p[0][0] = 10\n        p[2][3] = 33\n        assert p[0][0] == 10\n        assert p[2][3] == 33\n        with pytest.raises(IndexError):\n            p[1][-1]\n\n    def test_constructor_array_of_array(self):\n        ffi = FFI(backend=self.Backend())\n        p = ffi.new(\"int[3][2]\", [[10, 11], [12, 13], [14, 15]])\n        assert p[2][1] == 15\n\n    def test_new_array_of_pointer_1(self):\n        ffi = FFI(backend=self.Backend())\n        n = ffi.new(\"int*\", 99)\n        p = ffi.new(\"int*[4]\")\n        p[3] = n\n        a = p[3]\n        assert repr(a).startswith(\"<cdata 'int *' 0x\")\n        assert a[0] == 99\n\n    def test_new_array_of_pointer_2(self):\n        ffi = FFI(backend=self.Backend())\n        n = ffi.new(\"int[1]\", [99])\n        p = ffi.new(\"int*[4]\")\n        p[3] = n\n        a = p[3]\n        assert repr(a).startswith(\"<cdata 'int *' 0x\")\n        assert a[0] == 99\n\n    def test_char(self):\n        ffi = FFI(backend=self.Backend())\n        assert ffi.new(\"char*\", b\"\\xff\")[0] == b'\\xff'\n        assert ffi.new(\"char*\")[0] == b'\\x00'\n        assert int(ffi.cast(\"char\", 300)) == 300 - 256\n        assert not bool(ffi.cast(\"char\", 0))\n        assert bool(ffi.cast(\"char\", 1))\n        assert bool(ffi.cast(\"char\", 255))\n        py.test.raises(TypeError, ffi.new, \"char*\", 32)\n        py.test.raises(TypeError, ffi.new, \"char*\", u+\"x\")\n        py.test.raises(TypeError, ffi.new, \"char*\", b\"foo\")\n        #\n        p = ffi.new(\"char[]\", [b'a', b'b', b'\\x9c'])\n        assert len(p) == 3\n        assert p[0] == b'a'\n        assert p[1] == b'b'\n        assert p[2] == b'\\x9c'\n        p[0] = b'\\xff'\n        assert p[0] == b'\\xff'\n        p = ffi.new(\"char[]\", b\"abcd\")\n        assert len(p) == 5\n        assert p[4] == b'\\x00'    # like in C, with:  char[] p = \"abcd\";\n        #\n        p = ffi.new(\"char[4]\", b\"ab\")\n        assert len(p) == 4\n        assert [p[i] for i in range(4)] == [b'a', b'b', b'\\x00', b'\\x00']\n        p = ffi.new(\"char[2]\", b\"ab\")\n        assert len(p) == 2\n        assert [p[i] for i in range(2)] == [b'a', b'b']\n        py.test.raises(IndexError, ffi.new, \"char[2]\", b\"abc\")\n\n    def check_wchar_t(self, ffi):\n        try:\n            ffi.cast(\"wchar_t\", 0)\n        except NotImplementedError:\n            py.test.skip(\"NotImplementedError: wchar_t\")\n\n    def test_wchar_t(self):\n        ffi = FFI(backend=self.Backend())\n        self.check_wchar_t(ffi)\n        assert ffi.new(\"wchar_t*\", u+'x')[0] == u+'x'\n        assert ffi.new(\"wchar_t*\", u+'\\u1234')[0] == u+'\\u1234'\n        if SIZE_OF_WCHAR > 2:\n            assert ffi.new(\"wchar_t*\", u+'\\U00012345')[0] == u+'\\U00012345'\n        else:\n            py.test.raises(TypeError, ffi.new, \"wchar_t*\", u+'\\U00012345')\n        assert ffi.new(\"wchar_t*\")[0] == u+'\\x00'\n        assert int(ffi.cast(\"wchar_t\", 300)) == 300\n        assert not bool(ffi.cast(\"wchar_t\", 0))\n        assert bool(ffi.cast(\"wchar_t\", 1))\n        assert bool(ffi.cast(\"wchar_t\", 65535))\n        if SIZE_OF_WCHAR > 2:\n            assert bool(ffi.cast(\"wchar_t\", 65536))\n        py.test.raises(TypeError, ffi.new, \"wchar_t*\", 32)\n        py.test.raises(TypeError, ffi.new, \"wchar_t*\", \"foo\")\n        #\n        p = ffi.new(\"wchar_t[]\", [u+'a', u+'b', u+'\\u1234'])\n        assert len(p) == 3\n        assert p[0] == u+'a'\n        assert p[1] == u+'b' and type(p[1]) is unicode\n        assert p[2] == u+'\\u1234'\n        p[0] = u+'x'\n        assert p[0] == u+'x' and type(p[0]) is unicode\n        p[1] = u+'\\u1357'\n        assert p[1] == u+'\\u1357'\n        p = ffi.new(\"wchar_t[]\", u+\"abcd\")\n        assert len(p) == 5\n        assert p[4] == u+'\\x00'\n        p = ffi.new(\"wchar_t[]\", u+\"a\\u1234b\")\n        assert len(p) == 4\n        assert p[1] == u+'\\u1234'\n        #\n        p = ffi.new(\"wchar_t[]\", u+'\\U00023456')\n        if SIZE_OF_WCHAR == 2:\n            assert len(p) == 3\n            assert p[0] == u+'\\ud84d'\n            assert p[1] == u+'\\udc56'\n            assert p[2] == u+'\\x00'\n        else:\n            assert len(p) == 2\n            assert p[0] == u+'\\U00023456'\n            assert p[1] == u+'\\x00'\n        #\n        p = ffi.new(\"wchar_t[4]\", u+\"ab\")\n        assert len(p) == 4\n        assert [p[i] for i in range(4)] == [u+'a', u+'b', u+'\\x00', u+'\\x00']\n        p = ffi.new(\"wchar_t[2]\", u+\"ab\")\n        assert len(p) == 2\n        assert [p[i] for i in range(2)] == [u+'a', u+'b']\n        py.test.raises(IndexError, ffi.new, \"wchar_t[2]\", u+\"abc\")\n\n    def test_none_as_null_doesnt_work(self):\n        ffi = FFI(backend=self.Backend())\n        p = ffi.new(\"int*[1]\")\n        assert p[0] is not None\n        assert p[0] != None\n        assert p[0] == ffi.NULL\n        assert repr(p[0]) == \"<cdata 'int *' NULL>\"\n        #\n        n = ffi.new(\"int*\", 99)\n        p = ffi.new(\"int*[]\", [n])\n        assert p[0][0] == 99\n        with pytest.raises(TypeError):\n            p[0] = None\n        p[0] = ffi.NULL\n        assert p[0] == ffi.NULL\n\n    def test_float(self):\n        ffi = FFI(backend=self.Backend())\n        p = ffi.new(\"float[]\", [-2, -2.5])\n        assert p[0] == -2.0\n        assert p[1] == -2.5\n        p[1] += 17.75\n        assert p[1] == 15.25\n        #\n        p = ffi.new(\"float*\", 15.75)\n        assert p[0] == 15.75\n        py.test.raises(TypeError, int, p)\n        py.test.raises(TypeError, float, p)\n        p[0] = 0.0\n        assert bool(p) is True\n        #\n        p = ffi.new(\"float*\", 1.1)\n        f = p[0]\n        assert f != 1.1      # because of rounding effect\n        assert abs(f - 1.1) < 1E-7\n        #\n        INF = 1E200 * 1E200\n        assert 1E200 != INF\n        p[0] = 1E200\n        assert p[0] == INF     # infinite, not enough precision\n\n    def test_struct_simple(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo { int a; short b, c; };\")\n        s = ffi.new(\"struct foo*\")\n        assert s.a == s.b == s.c == 0\n        s.b = -23\n        assert s.b == -23\n        with pytest.raises(OverflowError):\n            s.b = 32768\n        #\n        s = ffi.new(\"struct foo*\", [-2, -3])\n        assert s.a == -2\n        assert s.b == -3\n        assert s.c == 0\n        with pytest.raises((AttributeError, TypeError)):\n            del s.a\n        assert repr(s) == \"<cdata 'struct foo *' owning %d bytes>\" % (\n            SIZE_OF_INT + 2 * SIZE_OF_SHORT)\n        #\n        py.test.raises(ValueError, ffi.new, \"struct foo*\", [1, 2, 3, 4])\n\n    def test_constructor_struct_from_dict(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo { int a; short b, c; };\")\n        s = ffi.new(\"struct foo*\", {'b': 123, 'c': 456})\n        assert s.a == 0\n        assert s.b == 123\n        assert s.c == 456\n        py.test.raises(KeyError, ffi.new, \"struct foo*\", {'d': 456})\n\n    def test_struct_pointer(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo { int a; short b, c; };\")\n        s = ffi.new(\"struct foo*\")\n        assert s[0].a == s[0].b == s[0].c == 0\n        s[0].b = -23\n        assert s[0].b == s.b == -23\n        with pytest.raises(OverflowError):\n            s[0].b = -32769\n        with pytest.raises(IndexError):\n            s[1]\n\n    def test_struct_opaque(self):\n        ffi = FFI(backend=self.Backend())\n        py.test.raises(TypeError, ffi.new, \"struct baz*\")\n        p = ffi.new(\"struct baz **\")    # this works\n        assert p[0] == ffi.NULL\n\n    def test_pointer_to_struct(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo { int a; short b, c; };\")\n        s = ffi.new(\"struct foo *\")\n        s.a = -42\n        assert s[0].a == -42\n        p = ffi.new(\"struct foo **\", s)\n        assert p[0].a == -42\n        assert p[0][0].a == -42\n        p[0].a = -43\n        assert s.a == -43\n        assert s[0].a == -43\n        p[0][0].a = -44\n        assert s.a == -44\n        assert s[0].a == -44\n        s.a = -45\n        assert p[0].a == -45\n        assert p[0][0].a == -45\n        s[0].a = -46\n        assert p[0].a == -46\n        assert p[0][0].a == -46\n\n    def test_constructor_struct_of_array(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo { int a[2]; char b[3]; };\")\n        s = ffi.new(\"struct foo *\", [[10, 11], [b'a', b'b', b'c']])\n        assert s.a[1] == 11\n        assert s.b[2] == b'c'\n        s.b[1] = b'X'\n        assert s.b[0] == b'a'\n        assert s.b[1] == b'X'\n        assert s.b[2] == b'c'\n\n    def test_recursive_struct(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo { int value; struct foo *next; };\")\n        s = ffi.new(\"struct foo*\")\n        t = ffi.new(\"struct foo*\")\n        s.value = 123\n        s.next = t\n        t.value = 456\n        assert s.value == 123\n        assert s.next.value == 456\n\n    def test_union_simple(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"union foo { int a; short b, c; };\")\n        u = ffi.new(\"union foo*\")\n        assert u.a == u.b == u.c == 0\n        u.b = -23\n        assert u.b == -23\n        assert u.a != 0\n        with pytest.raises(OverflowError):\n            u.b = 32768\n        #\n        u = ffi.new(\"union foo*\", [-2])\n        assert u.a == -2\n        with pytest.raises((AttributeError, TypeError)):\n            del u.a\n        assert repr(u) == \"<cdata 'union foo *' owning %d bytes>\" % SIZE_OF_INT\n\n    def test_union_opaque(self):\n        ffi = FFI(backend=self.Backend())\n        py.test.raises(TypeError, ffi.new, \"union baz *\")\n        u = ffi.new(\"union baz **\")   # this works\n        assert u[0] == ffi.NULL\n\n    def test_union_initializer(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"union foo { char a; int b; };\")\n        py.test.raises(TypeError, ffi.new, \"union foo*\", b'A')\n        py.test.raises(TypeError, ffi.new, \"union foo*\", 5)\n        py.test.raises(ValueError, ffi.new, \"union foo*\", [b'A', 5])\n        u = ffi.new(\"union foo*\", [b'A'])\n        assert u.a == b'A'\n        py.test.raises(TypeError, ffi.new, \"union foo*\", [1005])\n        u = ffi.new(\"union foo*\", {'b': 12345})\n        assert u.b == 12345\n        u = ffi.new(\"union foo*\", [])\n        assert u.a == b'\\x00'\n        assert u.b == 0\n\n    def test_sizeof_type(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            struct foo { int a; short b, c, d; };\n            union foo { int a; short b, c, d; };\n        \"\"\")\n        for c_type, expected_size in [\n            ('char', 1),\n            ('unsigned int', 4),\n            ('char *', SIZE_OF_PTR),\n            ('int[5]', 20),\n            ('struct foo', 12),\n            ('union foo', 4),\n            ]:\n            size = ffi.sizeof(c_type)\n            assert size == expected_size, (size, expected_size, ctype)\n\n    def test_sizeof_cdata(self):\n        ffi = FFI(backend=self.Backend())\n        assert ffi.sizeof(ffi.new(\"short*\")) == SIZE_OF_PTR\n        assert ffi.sizeof(ffi.cast(\"short\", 123)) == SIZE_OF_SHORT\n        #\n        a = ffi.new(\"int[]\", [10, 11, 12, 13, 14])\n        assert len(a) == 5\n        assert ffi.sizeof(a) == 5 * SIZE_OF_INT\n\n    def test_string_from_char_pointer(self):\n        ffi = FFI(backend=self.Backend())\n        x = ffi.new(\"char*\", b\"x\")\n        assert str(x) == repr(x)\n        assert ffi.string(x) == b\"x\"\n        assert ffi.string(ffi.new(\"char*\", b\"\\x00\")) == b\"\"\n        py.test.raises(TypeError, ffi.new, \"char*\", unicode(\"foo\"))\n\n    def test_unicode_from_wchar_pointer(self):\n        ffi = FFI(backend=self.Backend())\n        self.check_wchar_t(ffi)\n        x = ffi.new(\"wchar_t*\", u+\"x\")\n        assert unicode(x) == unicode(repr(x))\n        assert ffi.string(x) == u+\"x\"\n        assert ffi.string(ffi.new(\"wchar_t*\", u+\"\\x00\")) == u+\"\"\n\n    def test_string_from_char_array(self):\n        ffi = FFI(backend=self.Backend())\n        p = ffi.new(\"char[]\", b\"hello.\")\n        p[5] = b'!'\n        assert ffi.string(p) == b\"hello!\"\n        p[6] = b'?'\n        assert ffi.string(p) == b\"hello!?\"\n        p[3] = b'\\x00'\n        assert ffi.string(p) == b\"hel\"\n        assert ffi.string(p, 2) == b\"he\"\n        with pytest.raises(IndexError):\n            p[7] = b'X'\n        #\n        a = ffi.new(\"char[]\", b\"hello\\x00world\")\n        assert len(a) == 12\n        p = ffi.cast(\"char *\", a)\n        assert ffi.string(p) == b'hello'\n\n    def test_string_from_wchar_array(self):\n        ffi = FFI(backend=self.Backend())\n        self.check_wchar_t(ffi)\n        assert ffi.string(ffi.cast(\"wchar_t\", \"x\")) == u+\"x\"\n        assert ffi.string(ffi.cast(\"wchar_t\", u+\"x\")) == u+\"x\"\n        x = ffi.cast(\"wchar_t\", \"x\")\n        assert str(x) == repr(x)\n        assert ffi.string(x) == u+\"x\"\n        #\n        p = ffi.new(\"wchar_t[]\", u+\"hello.\")\n        p[5] = u+'!'\n        assert ffi.string(p) == u+\"hello!\"\n        p[6] = u+'\\u04d2'\n        assert ffi.string(p) == u+\"hello!\\u04d2\"\n        p[3] = u+'\\x00'\n        assert ffi.string(p) == u+\"hel\"\n        assert ffi.string(p, 123) == u+\"hel\"\n        with pytest.raises(IndexError):\n            p[7] = u+'X'\n        #\n        a = ffi.new(\"wchar_t[]\", u+\"hello\\x00world\")\n        assert len(a) == 12\n        p = ffi.cast(\"wchar_t *\", a)\n        assert ffi.string(p) == u+'hello'\n        assert ffi.string(p, 123) == u+'hello'\n        assert ffi.string(p, 5) == u+'hello'\n        assert ffi.string(p, 2) == u+'he'\n\n    def test_fetch_const_char_p_field(self):\n        # 'const' is ignored so far\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo { const char *name; };\")\n        t = ffi.new(\"const char[]\", b\"testing\")\n        s = ffi.new(\"struct foo*\", [t])\n        assert type(s.name) not in (bytes, str, unicode)\n        assert ffi.string(s.name) == b\"testing\"\n        with pytest.raises(TypeError):\n            s.name = None\n        s.name = ffi.NULL\n        assert s.name == ffi.NULL\n\n    def test_fetch_const_wchar_p_field(self):\n        # 'const' is ignored so far\n        ffi = FFI(backend=self.Backend())\n        self.check_wchar_t(ffi)\n        ffi.cdef(\"struct foo { const wchar_t *name; };\")\n        t = ffi.new(\"const wchar_t[]\", u+\"testing\")\n        s = ffi.new(\"struct foo*\", [t])\n        assert type(s.name) not in (bytes, str, unicode)\n        assert ffi.string(s.name) == u+\"testing\"\n        s.name = ffi.NULL\n        assert s.name == ffi.NULL\n\n    def test_voidp(self):\n        ffi = FFI(backend=self.Backend())\n        py.test.raises(TypeError, ffi.new, \"void*\")\n        p = ffi.new(\"void **\")\n        assert p[0] == ffi.NULL\n        a = ffi.new(\"int[]\", [10, 11, 12])\n        p = ffi.new(\"void **\", a)\n        vp = p[0]\n        with pytest.raises(TypeError):\n            vp[0]\n        py.test.raises(TypeError, ffi.new, \"short **\", a)\n        #\n        ffi.cdef(\"struct foo { void *p; int *q; short *r; };\")\n        s = ffi.new(\"struct foo *\")\n        s.p = a    # works\n        s.q = a    # works\n        with pytest.raises(TypeError):\n            s.r = a    # fails\n        b = ffi.cast(\"int *\", a)\n        s.p = b    # works\n        s.q = b    # works\n        with pytest.raises(TypeError):\n            s.r = b    # fails\n\n    def test_functionptr_simple(self):\n        ffi = FFI(backend=self.Backend())\n        py.test.raises(TypeError, ffi.callback, \"int(*)(int)\", 0)\n        def cb(n):\n            return n + 1\n        cb.__qualname__ = 'cb'\n        p = ffi.callback(\"int(*)(int)\", cb)\n        res = p(41)     # calling an 'int(*)(int)', i.e. a function pointer\n        assert res == 42 and type(res) is int\n        res = p(ffi.cast(\"int\", -41))\n        assert res == -40 and type(res) is int\n        assert repr(p).startswith(\n            \"<cdata 'int(*)(int)' calling <function cb at 0x\")\n        assert ffi.typeof(p) is ffi.typeof(\"int(*)(int)\")\n        q = ffi.new(\"int(**)(int)\", p)\n        assert repr(q) == \"<cdata 'int(* *)(int)' owning %d bytes>\" % (\n            SIZE_OF_PTR)\n        with pytest.raises(TypeError):\n            q(43)\n        res = q[0](43)\n        assert res == 44\n        q = ffi.cast(\"int(*)(int)\", p)\n        assert repr(q).startswith(\"<cdata 'int(*)(int)' 0x\")\n        res = q(45)\n        assert res == 46\n\n    def test_functionptr_advanced(self):\n        ffi = FFI(backend=self.Backend())\n        t = ffi.typeof(\"int(*(*)(int))(int)\")\n        assert repr(t) == self.TypeRepr % \"int(*(*)(int))(int)\"\n\n    def test_functionptr_voidptr_return(self):\n        ffi = FFI(backend=self.Backend())\n        def cb():\n            return ffi.NULL\n        p = ffi.callback(\"void*(*)()\", cb)\n        res = p()\n        assert res is not None\n        assert res == ffi.NULL\n        int_ptr = ffi.new('int*')\n        void_ptr = ffi.cast('void*', int_ptr)\n        def cb():\n            return void_ptr\n        p = ffi.callback(\"void*(*)()\", cb)\n        res = p()\n        assert res == void_ptr\n\n    def test_functionptr_intptr_return(self):\n        ffi = FFI(backend=self.Backend())\n        def cb():\n            return ffi.NULL\n        p = ffi.callback(\"int*(*)()\", cb)\n        res = p()\n        assert res == ffi.NULL\n        int_ptr = ffi.new('int*')\n        def cb():\n            return int_ptr\n        p = ffi.callback(\"int*(*)()\", cb)\n        res = p()\n        assert repr(res).startswith(\"<cdata 'int *' 0x\")\n        assert res == int_ptr\n        int_array_ptr = ffi.new('int[1]')\n        def cb():\n            return int_array_ptr\n        p = ffi.callback(\"int*(*)()\", cb)\n        res = p()\n        assert repr(res).startswith(\"<cdata 'int *' 0x\")\n        assert res == int_array_ptr\n\n    def test_functionptr_void_return(self):\n        ffi = FFI(backend=self.Backend())\n        def foo():\n            pass\n        foo_cb = ffi.callback(\"void foo()\", foo)\n        result = foo_cb()\n        assert result is None\n\n    def test_char_cast(self):\n        ffi = FFI(backend=self.Backend())\n        p = ffi.cast(\"int\", b'\\x01')\n        assert ffi.typeof(p) is ffi.typeof(\"int\")\n        assert int(p) == 1\n        p = ffi.cast(\"int\", ffi.cast(\"char\", b\"a\"))\n        assert int(p) == ord(\"a\")\n        p = ffi.cast(\"int\", ffi.cast(\"char\", b\"\\x80\"))\n        assert int(p) == 0x80     # \"char\" is considered unsigned in this case\n        p = ffi.cast(\"int\", b\"\\x81\")\n        assert int(p) == 0x81\n\n    def test_wchar_cast(self):\n        ffi = FFI(backend=self.Backend())\n        self.check_wchar_t(ffi)\n        p = ffi.cast(\"int\", ffi.cast(\"wchar_t\", u+'\\u1234'))\n        assert int(p) == 0x1234\n        p = ffi.cast(\"long long\", ffi.cast(\"wchar_t\", -1))\n        if SIZE_OF_WCHAR == 2:      # 2 bytes, unsigned\n            assert int(p) == 0xffff\n        elif (sys.platform.startswith('linux') and\n              platform.machine().startswith('x86')):   # known to be signed\n            assert int(p) == -1\n        else:                     # in general, it can be either signed or not\n            assert int(p) in [-1, 0xffffffff]  # e.g. on arm, both cases occur\n        p = ffi.cast(\"int\", u+'\\u1234')\n        assert int(p) == 0x1234\n\n    def test_cast_array_to_charp(self):\n        ffi = FFI(backend=self.Backend())\n        a = ffi.new(\"short int[]\", [0x1234, 0x5678])\n        p = ffi.cast(\"char*\", a)\n        data = b''.join([p[i] for i in range(4)])\n        if sys.byteorder == 'little':\n            assert data == b'\\x34\\x12\\x78\\x56'\n        else:\n            assert data == b'\\x12\\x34\\x56\\x78'\n\n    def test_cast_between_pointers(self):\n        ffi = FFI(backend=self.Backend())\n        a = ffi.new(\"short int[]\", [0x1234, 0x5678])\n        p = ffi.cast(\"short*\", a)\n        p2 = ffi.cast(\"int*\", p)\n        q = ffi.cast(\"char*\", p2)\n        data = b''.join([q[i] for i in range(4)])\n        if sys.byteorder == 'little':\n            assert data == b'\\x34\\x12\\x78\\x56'\n        else:\n            assert data == b'\\x12\\x34\\x56\\x78'\n\n    def test_cast_pointer_and_int(self):\n        ffi = FFI(backend=self.Backend())\n        a = ffi.new(\"short int[]\", [0x1234, 0x5678])\n        l1 = ffi.cast(\"intptr_t\", a)\n        p = ffi.cast(\"short*\", a)\n        l2 = ffi.cast(\"intptr_t\", p)\n        assert int(l1) == int(l2) != 0\n        q = ffi.cast(\"short*\", l1)\n        assert q == ffi.cast(\"short*\", int(l1))\n        assert q[0] == 0x1234\n        assert int(ffi.cast(\"intptr_t\", ffi.NULL)) == 0\n\n    def test_cast_functionptr_and_int(self):\n        ffi = FFI(backend=self.Backend())\n        def cb(n):\n            return n + 1\n        a = ffi.callback(\"int(*)(int)\", cb)\n        p = ffi.cast(\"void *\", a)\n        assert p\n        b = ffi.cast(\"int(*)(int)\", p)\n        assert b(41) == 42\n        assert a == b\n        assert hash(a) == hash(b)\n\n    def test_callback_crash(self):\n        ffi = FFI(backend=self.Backend())\n        def cb(n):\n            raise Exception\n        a = ffi.callback(\"int(*)(int)\", cb, error=42)\n        res = a(1)    # and the error reported to stderr\n        assert res == 42\n\n    def test_structptr_argument(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo_s { int a, b; };\")\n        def cb(p):\n            return p[0].a * 1000 + p[0].b * 100 + p[1].a * 10 + p[1].b\n        a = ffi.callback(\"int(*)(struct foo_s[])\", cb)\n        res = a([[5, 6], {'a': 7, 'b': 8}])\n        assert res == 5678\n        res = a([[5], {'b': 8}])\n        assert res == 5008\n\n    def test_array_argument_as_list(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo_s { int a, b; };\")\n        seen = []\n        def cb(argv):\n            seen.append(ffi.string(argv[0]))\n            seen.append(ffi.string(argv[1]))\n        a = ffi.callback(\"void(*)(char *[])\", cb)\n        a([ffi.new(\"char[]\", b\"foobar\"), ffi.new(\"char[]\", b\"baz\")])\n        assert seen == [b\"foobar\", b\"baz\"]\n\n    def test_cast_float(self):\n        ffi = FFI(backend=self.Backend())\n        a = ffi.cast(\"float\", 12)\n        assert float(a) == 12.0\n        a = ffi.cast(\"float\", 12.5)\n        assert float(a) == 12.5\n        a = ffi.cast(\"float\", b\"A\")\n        assert float(a) == ord(\"A\")\n        a = ffi.cast(\"int\", 12.9)\n        assert int(a) == 12\n        a = ffi.cast(\"char\", 66.9 + 256)\n        assert ffi.string(a) == b\"B\"\n        #\n        a = ffi.cast(\"float\", ffi.cast(\"int\", 12))\n        assert float(a) == 12.0\n        a = ffi.cast(\"float\", ffi.cast(\"double\", 12.5))\n        assert float(a) == 12.5\n        a = ffi.cast(\"float\", ffi.cast(\"char\", b\"A\"))\n        assert float(a) == ord(\"A\")\n        a = ffi.cast(\"int\", ffi.cast(\"double\", 12.9))\n        assert int(a) == 12\n        a = ffi.cast(\"char\", ffi.cast(\"double\", 66.9 + 256))\n        assert ffi.string(a) == b\"B\"\n\n    def test_enum(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"enum foo { A0, B0, CC0, D0 };\")\n        assert ffi.string(ffi.cast(\"enum foo\", 0)) == \"A0\"\n        assert ffi.string(ffi.cast(\"enum foo\", 2)) == \"CC0\"\n        assert ffi.string(ffi.cast(\"enum foo\", 3)) == \"D0\"\n        assert ffi.string(ffi.cast(\"enum foo\", 4)) == \"4\"\n        ffi.cdef(\"enum bar { A1, B1=-2, CC1, D1, E1 };\")\n        assert ffi.string(ffi.cast(\"enum bar\", 0)) == \"A1\"\n        assert ffi.string(ffi.cast(\"enum bar\", -2)) == \"B1\"\n        assert ffi.string(ffi.cast(\"enum bar\", -1)) == \"CC1\"\n        assert ffi.string(ffi.cast(\"enum bar\", 1)) == \"E1\"\n        assert ffi.cast(\"enum bar\", -2) == ffi.cast(\"enum bar\", -2)\n        assert ffi.cast(\"enum foo\", 0) == ffi.cast(\"enum bar\", 0)\n        assert ffi.cast(\"enum bar\", 0) == ffi.cast(\"int\", 0)\n        assert repr(ffi.cast(\"enum bar\", -1)) == \"<cdata 'enum bar' -1: CC1>\"\n        assert repr(ffi.cast(\"enum foo\", -1)) == (  # enums are unsigned, if\n            \"<cdata 'enum foo' 4294967295>\")        # they contain no neg value\n        ffi.cdef(\"enum baz { A2=0x1000, B2=0x2000 };\")\n        assert ffi.string(ffi.cast(\"enum baz\", 0x1000)) == \"A2\"\n        assert ffi.string(ffi.cast(\"enum baz\", 0x2000)) == \"B2\"\n\n    def test_enum_in_struct(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"enum foo { A, B, C, D }; struct bar { enum foo e; };\")\n        s = ffi.new(\"struct bar *\")\n        s.e = 0\n        assert s.e == 0\n        s.e = 3\n        assert s.e == 3\n        assert s[0].e == 3\n        s[0].e = 2\n        assert s.e == 2\n        assert s[0].e == 2\n        s.e = ffi.cast(\"enum foo\", -1)\n        assert s.e == 4294967295\n        assert s[0].e == 4294967295\n        s.e = s.e\n        with pytest.raises(TypeError):\n            s.e = 'B'\n        with pytest.raises(TypeError):\n            s.e = '2'\n        with pytest.raises(TypeError):\n            s.e = '#2'\n        with pytest.raises(TypeError):\n            s.e = '#7'\n\n    def test_enum_non_contiguous(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"enum foo { A, B=42, C };\")\n        assert ffi.string(ffi.cast(\"enum foo\", 0)) == \"A\"\n        assert ffi.string(ffi.cast(\"enum foo\", 42)) == \"B\"\n        assert ffi.string(ffi.cast(\"enum foo\", 43)) == \"C\"\n        invalid_value = ffi.cast(\"enum foo\", 2)\n        assert int(invalid_value) == 2\n        assert ffi.string(invalid_value) == \"2\"\n\n    def test_enum_char_hex_oct(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(r\"enum foo{A='!', B='\\'', C=0x10, D=010, E=- 0x10, F=-010};\")\n        assert ffi.string(ffi.cast(\"enum foo\", ord('!'))) == \"A\"\n        assert ffi.string(ffi.cast(\"enum foo\", ord(\"'\"))) == \"B\"\n        assert ffi.string(ffi.cast(\"enum foo\", 16)) == \"C\"\n        assert ffi.string(ffi.cast(\"enum foo\", 8)) == \"D\"\n        assert ffi.string(ffi.cast(\"enum foo\", -16)) == \"E\"\n        assert ffi.string(ffi.cast(\"enum foo\", -8)) == \"F\"\n\n    def test_enum_partial(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(r\"enum foo {A, ...}; enum bar { B, C };\")\n        needs_dlopen_none()\n        lib = ffi.dlopen(None)\n        assert lib.B == 0\n        py.test.raises(VerificationMissing, getattr, lib, \"A\")\n        assert lib.C == 1\n\n    def test_array_of_struct(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo { int a, b; };\")\n        s = ffi.new(\"struct foo[1]\")\n        with pytest.raises(AttributeError):\n            s.b\n        with pytest.raises(AttributeError):\n            s.b = 412\n        s[0].b = 412\n        assert s[0].b == 412\n        with pytest.raises(IndexError):\n            s[1]\n\n    def test_pointer_to_array(self):\n        ffi = FFI(backend=self.Backend())\n        p = ffi.new(\"int(**)[5]\")\n        assert repr(p) == \"<cdata 'int(* *)[5]' owning %d bytes>\" % SIZE_OF_PTR\n\n    def test_iterate_array(self):\n        ffi = FFI(backend=self.Backend())\n        a = ffi.new(\"char[]\", b\"hello\")\n        assert list(a) == [b\"h\", b\"e\", b\"l\", b\"l\", b\"o\", b\"\\0\"]\n        assert list(iter(a)) == [b\"h\", b\"e\", b\"l\", b\"l\", b\"o\", b\"\\0\"]\n        #\n        py.test.raises(TypeError, iter, ffi.cast(\"char *\", a))\n        py.test.raises(TypeError, list, ffi.cast(\"char *\", a))\n        py.test.raises(TypeError, iter, ffi.new(\"int *\"))\n        py.test.raises(TypeError, list, ffi.new(\"int *\"))\n\n    def test_offsetof(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo { int a, b, c; };\")\n        assert ffi.offsetof(\"struct foo\", \"a\") == 0\n        assert ffi.offsetof(\"struct foo\", \"b\") == 4\n        assert ffi.offsetof(\"struct foo\", \"c\") == 8\n\n    def test_offsetof_nested(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo { int a, b, c; };\"\n                 \"struct bar { struct foo d, e; };\")\n        assert ffi.offsetof(\"struct bar\", \"e\") == 12\n        py.test.raises(KeyError, ffi.offsetof, \"struct bar\", \"e.a\")\n        assert ffi.offsetof(\"struct bar\", \"e\", \"a\") == 12\n        assert ffi.offsetof(\"struct bar\", \"e\", \"b\") == 16\n        assert ffi.offsetof(\"struct bar\", \"e\", \"c\") == 20\n\n    def test_offsetof_array(self):\n        ffi = FFI(backend=self.Backend())\n        assert ffi.offsetof(\"int[]\", 51) == 51 * ffi.sizeof(\"int\")\n        assert ffi.offsetof(\"int *\", 51) == 51 * ffi.sizeof(\"int\")\n        ffi.cdef(\"struct bar { int a, b; int c[99]; };\")\n        assert ffi.offsetof(\"struct bar\", \"c\") == 2 * ffi.sizeof(\"int\")\n        assert ffi.offsetof(\"struct bar\", \"c\", 0) == 2 * ffi.sizeof(\"int\")\n        assert ffi.offsetof(\"struct bar\", \"c\", 51) == 53 * ffi.sizeof(\"int\")\n\n    def test_alignof(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo { char a; short b; char c; };\")\n        assert ffi.alignof(\"int\") == 4\n        assert ffi.alignof(\"double\") in (4, 8)\n        assert ffi.alignof(\"struct foo\") == 2\n\n    def test_bitfield(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo { int a:10, b:20, c:3; };\")\n        assert ffi.sizeof(\"struct foo\") == 8\n        s = ffi.new(\"struct foo *\")\n        s.a = 511\n        with pytest.raises(OverflowError):\n            s.a = 512\n        with pytest.raises(OverflowError):\n            s[0].a = 512\n        assert s.a == 511\n        s.a = -512\n        with pytest.raises(OverflowError):\n            s.a = -513\n        with pytest.raises(OverflowError):\n            s[0].a = -513\n        assert s.a == -512\n        s.c = 3\n        assert s.c == 3\n        with pytest.raises(OverflowError):\n            s.c = 4\n        with pytest.raises(OverflowError):\n            s[0].c = 4\n        s.c = -4\n        assert s.c == -4\n\n    def test_bitfield_enum(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            typedef enum { AA, BB, CC } foo_e;\n            typedef struct { foo_e f:2; } foo_s;\n        \"\"\")\n        s = ffi.new(\"foo_s *\")\n        s.f = 2\n        assert s.f == 2\n\n    def test_anonymous_struct(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"typedef struct { int a; } foo_t;\")\n        ffi.cdef(\"typedef struct { char b, c; } bar_t;\")\n        f = ffi.new(\"foo_t *\", [12345])\n        b = ffi.new(\"bar_t *\", [b\"B\", b\"C\"])\n        assert f.a == 12345\n        assert b.b == b\"B\"\n        assert b.c == b\"C\"\n        assert repr(b).startswith(\"<cdata 'bar_t *'\")\n\n    def test_struct_with_two_usages(self):\n        for name in ['foo_s', '']:    # anonymous or not\n            ffi = FFI(backend=self.Backend())\n            ffi.cdef(\"typedef struct %s { int a; } foo_t, *foo_p;\" % name)\n            f = ffi.new(\"foo_t *\", [12345])\n            ps = ffi.new(\"foo_p[]\", [f])\n\n    def test_pointer_arithmetic(self):\n        ffi = FFI(backend=self.Backend())\n        s = ffi.new(\"short[]\", list(range(100, 110)))\n        p = ffi.cast(\"short *\", s)\n        assert p[2] == 102\n        assert p+1 == p+1\n        assert p+1 != p+0\n        assert p == p+0 == p-0\n        assert (p+1)[0] == 101\n        assert (p+19)[-10] == 109\n        assert (p+5) - (p+1) == 4\n        assert p == s+0\n        assert p+1 == s+1\n\n    def test_pointer_comparison(self):\n        ffi = FFI(backend=self.Backend())\n        s = ffi.new(\"short[]\", list(range(100)))\n        p = ffi.cast(\"short *\", s)\n        assert (p <  s) is False\n        assert (p <= s) is True\n        assert (p == s) is True\n        assert (p != s) is False\n        assert (p >  s) is False\n        assert (p >= s) is True\n        assert (s <  p) is False\n        assert (s <= p) is True\n        assert (s == p) is True\n        assert (s != p) is False\n        assert (s >  p) is False\n        assert (s >= p) is True\n        q = p + 1\n        assert (q <  s) is False\n        assert (q <= s) is False\n        assert (q == s) is False\n        assert (q != s) is True\n        assert (q >  s) is True\n        assert (q >= s) is True\n        assert (s <  q) is True\n        assert (s <= q) is True\n        assert (s == q) is False\n        assert (s != q) is True\n        assert (s >  q) is False\n        assert (s >= q) is False\n        assert (q <  p) is False\n        assert (q <= p) is False\n        assert (q == p) is False\n        assert (q != p) is True\n        assert (q >  p) is True\n        assert (q >= p) is True\n        assert (p <  q) is True\n        assert (p <= q) is True\n        assert (p == q) is False\n        assert (p != q) is True\n        assert (p >  q) is False\n        assert (p >= q) is False\n        #\n        assert (None == s) is False\n        assert (None != s) is True\n        assert (s == None) is False\n        assert (s != None) is True\n        assert (None == q) is False\n        assert (None != q) is True\n        assert (q == None) is False\n        assert (q != None) is True\n\n    def test_integer_comparison(self):\n        ffi = FFI(backend=self.Backend())\n        x = ffi.cast(\"int\", 123)\n        y = ffi.cast(\"int\", 456)\n        assert x < y\n        #\n        z = ffi.cast(\"double\", 78.9)\n        assert x > z\n        assert y > z\n\n    def test_ffi_buffer_ptr(self):\n        ffi = FFI(backend=self.Backend())\n        a = ffi.new(\"short *\", 100)\n        try:\n            b = ffi.buffer(a)\n        except NotImplementedError as e:\n            py.test.skip(str(e))\n        assert type(b) is ffi.buffer\n        content = b[:]\n        assert len(content) == len(b) == 2\n        if sys.byteorder == 'little':\n            assert content == b'\\x64\\x00'\n            assert b[0] == b'\\x64'\n            b[0] = b'\\x65'\n        else:\n            assert content == b'\\x00\\x64'\n            assert b[1] == b'\\x64'\n            b[1] = b'\\x65'\n        assert a[0] == 101\n\n    def test_ffi_buffer_array(self):\n        ffi = FFI(backend=self.Backend())\n        a = ffi.new(\"int[]\", list(range(100, 110)))\n        try:\n            b = ffi.buffer(a)\n        except NotImplementedError as e:\n            py.test.skip(str(e))\n        content = b[:]\n        if sys.byteorder == 'little':\n            assert content.startswith(b'\\x64\\x00\\x00\\x00\\x65\\x00\\x00\\x00')\n            b[4] = b'\\x45'\n        else:\n            assert content.startswith(b'\\x00\\x00\\x00\\x64\\x00\\x00\\x00\\x65')\n            b[7] = b'\\x45'\n        assert len(content) == 4 * 10\n        assert a[1] == 0x45\n\n    def test_ffi_buffer_ptr_size(self):\n        ffi = FFI(backend=self.Backend())\n        a = ffi.new(\"short *\", 0x4243)\n        try:\n            b = ffi.buffer(a, 1)\n        except NotImplementedError as e:\n            py.test.skip(str(e))\n        content = b[:]\n        assert len(content) == 1\n        if sys.byteorder == 'little':\n            assert content == b'\\x43'\n            b[0] = b'\\x62'\n            assert a[0] == 0x4262\n        else:\n            assert content == b'\\x42'\n            b[0] = b'\\x63'\n            assert a[0] == 0x6343\n\n    def test_ffi_buffer_array_size(self):\n        ffi = FFI(backend=self.Backend())\n        a1 = ffi.new(\"int[]\", list(range(100, 110)))\n        a2 = ffi.new(\"int[]\", list(range(100, 115)))\n        try:\n            ffi.buffer(a1)\n        except NotImplementedError as e:\n            py.test.skip(str(e))\n        assert ffi.buffer(a1)[:] == ffi.buffer(a2, 4*10)[:]\n\n    def test_ffi_buffer_with_file(self):\n        ffi = FFI(backend=self.Backend())\n        import tempfile, os, array\n        fd, filename = tempfile.mkstemp()\n        f = os.fdopen(fd, 'r+b')\n        a = ffi.new(\"int[]\", list(range(1005)))\n        try:\n            ffi.buffer(a, 512)\n        except NotImplementedError as e:\n            py.test.skip(str(e))\n        f.write(ffi.buffer(a, 1000 * ffi.sizeof(\"int\")))\n        f.seek(0)\n        assert f.read() == array.array('i', range(1000)).tostring()\n        f.seek(0)\n        b = ffi.new(\"int[]\", 1005)\n        f.readinto(ffi.buffer(b, 1000 * ffi.sizeof(\"int\")))\n        assert list(a)[:1000] + [0] * (len(a)-1000) == list(b)\n        f.close()\n        os.unlink(filename)\n\n    def test_ffi_buffer_with_io(self):\n        ffi = FFI(backend=self.Backend())\n        import io, array\n        f = io.BytesIO()\n        a = ffi.new(\"int[]\", list(range(1005)))\n        try:\n            ffi.buffer(a, 512)\n        except NotImplementedError as e:\n            py.test.skip(str(e))\n        f.write(ffi.buffer(a, 1000 * ffi.sizeof(\"int\")))\n        f.seek(0)\n        assert f.read() == array.array('i', range(1000)).tostring()\n        f.seek(0)\n        b = ffi.new(\"int[]\", 1005)\n        f.readinto(ffi.buffer(b, 1000 * ffi.sizeof(\"int\")))\n        assert list(a)[:1000] + [0] * (len(a)-1000) == list(b)\n        f.close()\n\n    def test_ffi_buffer_comparisons(self):\n        ffi = FFI(backend=self.Backend())\n        ba = bytearray(range(100, 110))\n        if sys.version_info >= (2, 7):\n            assert ba == memoryview(ba)    # justification for the following\n        a = ffi.new(\"uint8_t[]\", list(ba))\n        c = ffi.new(\"uint8_t[]\", [99] + list(ba))\n        try:\n            b_full = ffi.buffer(a)\n            b_short = ffi.buffer(a, 3)\n            b_mid = ffi.buffer(a, 6)\n            b_other = ffi.buffer(c, 6)\n        except NotImplementedError as e:\n            py.test.skip(str(e))\n        else:\n            content = b_full[:]\n            assert content == b_full == ba\n            assert b_other < b_short < b_mid < b_full\n            assert ba > b_mid > ba[0:2]\n            assert b_short != ba[1:4]\n\n    def test_array_in_struct(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo_s { int len; short data[5]; };\")\n        p = ffi.new(\"struct foo_s *\")\n        p.data[3] = 5\n        assert p.data[3] == 5\n        assert repr(p.data).startswith(\"<cdata 'short[5]' 0x\")\n\n    def test_struct_containing_array_varsize_workaround(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo_s { int len; short data[0]; };\")\n        p = ffi.new(\"char[]\", ffi.sizeof(\"struct foo_s\") + 7 * SIZE_OF_SHORT)\n        q = ffi.cast(\"struct foo_s *\", p)\n        assert q.len == 0\n        # 'q.data' gets not a 'short[0]', but just a 'short *' instead\n        assert repr(q.data).startswith(\"<cdata 'short *' 0x\")\n        assert q.data[6] == 0\n        q.data[6] = 15\n        assert q.data[6] == 15\n\n    def test_new_struct_containing_array_varsize(self):\n        py.test.skip(\"later?\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo_s { int len; short data[]; };\")\n        p = ffi.new(\"struct foo_s *\", 10)     # a single integer is the length\n        assert p.len == 0\n        assert p.data[9] == 0\n        with pytest.raises(IndexError):\n            p.data[10]\n\n    def test_ffi_typeof_getcname(self):\n        ffi = FFI(backend=self.Backend())\n        assert ffi.getctype(\"int\") == \"int\"\n        assert ffi.getctype(\"int\", 'x') == \"int x\"\n        assert ffi.getctype(\"int*\") == \"int *\"\n        assert ffi.getctype(\"int*\", '') == \"int *\"\n        assert ffi.getctype(\"int*\", 'x') == \"int * x\"\n        assert ffi.getctype(\"int\", '*') == \"int *\"\n        assert ffi.getctype(\"int\", ' * x ') == \"int * x\"\n        assert ffi.getctype(ffi.typeof(\"int*\"), '*') == \"int * *\"\n        assert ffi.getctype(\"int\", '[5]') == \"int[5]\"\n        assert ffi.getctype(\"int[5]\", '[6]') == \"int[6][5]\"\n        assert ffi.getctype(\"int[5]\", '(*)') == \"int(*)[5]\"\n        # special-case for convenience: automatically put '()' around '*'\n        assert ffi.getctype(\"int[5]\", '*') == \"int(*)[5]\"\n        assert ffi.getctype(\"int[5]\", '*foo') == \"int(*foo)[5]\"\n        assert ffi.getctype(\"int[5]\", ' ** foo ') == \"int(** foo)[5]\"\n\n    def test_array_of_func_ptr(self):\n        ffi = FFI(backend=self.Backend())\n        f = ffi.cast(\"int(*)(int)\", 42)\n        assert f != ffi.NULL\n        py.test.raises(CDefError, ffi.cast, \"int(int)\", 42)\n        py.test.raises(CDefError, ffi.new, \"int([5])(int)\")\n        a = ffi.new(\"int(*[5])(int)\", [f])\n        assert ffi.getctype(ffi.typeof(a)) == \"int(*[5])(int)\"\n        assert len(a) == 5\n        assert a[0] == f\n        assert a[1] == ffi.NULL\n        py.test.raises(TypeError, ffi.cast, \"int(*)(int)[5]\", 0)\n        #\n        def cb(n):\n            return n + 1\n        f = ffi.callback(\"int(*)(int)\", cb)\n        a = ffi.new(\"int(*[5])(int)\", [f, f])\n        assert a[1](42) == 43\n\n    def test_callback_as_function_argument(self):\n        # In C, function arguments can be declared with a function type,\n        # which is automatically replaced with the ptr-to-function type.\n        ffi = FFI(backend=self.Backend())\n        def cb(a, b):\n            return chr(ord(a) + ord(b)).encode()\n        f = ffi.callback(\"char cb(char, char)\", cb)\n        assert f(b'A', b'\\x01') == b'B'\n        def g(callback):\n            return callback(b'A', b'\\x01')\n        g = ffi.callback(\"char g(char cb(char, char))\", g)\n        assert g(f) == b'B'\n\n    def test_vararg_callback(self):\n        py.test.skip(\"callback with '...'\")\n        ffi = FFI(backend=self.Backend())\n        def cb(i, va_list):\n            j = ffi.va_arg(va_list, \"int\")\n            k = ffi.va_arg(va_list, \"long long\")\n            return i * 2 + j * 3 + k * 5\n        f = ffi.callback(\"long long cb(long i, ...)\", cb)\n        res = f(10, ffi.cast(\"int\", 100), ffi.cast(\"long long\", 1000))\n        assert res == 20 + 300 + 5000\n\n    def test_callback_decorator(self):\n        ffi = FFI(backend=self.Backend())\n        #\n        @ffi.callback(\"long(long, long)\", error=42)\n        def cb(a, b):\n            return a - b\n        #\n        assert cb(-100, -10) == -90\n        sz = ffi.sizeof(\"long\")\n        assert cb((1 << (sz*8-1)) - 1, -10) == 42\n\n    def test_unique_types(self):\n        ffi1 = FFI(backend=self.Backend())\n        ffi2 = FFI(backend=self.Backend())\n        assert ffi1.typeof(\"char\") is ffi2.typeof(\"char \")\n        assert ffi1.typeof(\"long\") is ffi2.typeof(\"signed long int\")\n        assert ffi1.typeof(\"double *\") is ffi2.typeof(\"double*\")\n        assert ffi1.typeof(\"int ***\") is ffi2.typeof(\" int * * *\")\n        assert ffi1.typeof(\"int[]\") is ffi2.typeof(\"signed int[]\")\n        assert ffi1.typeof(\"signed int*[17]\") is ffi2.typeof(\"int *[17]\")\n        assert ffi1.typeof(\"void\") is ffi2.typeof(\"void\")\n        assert ffi1.typeof(\"int(*)(int,int)\") is ffi2.typeof(\"int(*)(int,int)\")\n        #\n        # these depend on user-defined data, so should not be shared\n        assert ffi1.typeof(\"struct foo\") is not ffi2.typeof(\"struct foo\")\n        assert ffi1.typeof(\"union foo *\") is not ffi2.typeof(\"union foo*\")\n        # the following test is an opaque enum, which we no longer support\n        #assert ffi1.typeof(\"enum foo\") is not ffi2.typeof(\"enum foo\")\n        # sanity check: twice 'ffi1'\n        assert ffi1.typeof(\"struct foo*\") is ffi1.typeof(\"struct foo *\")\n\n    def test_anonymous_enum(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"typedef enum { Value0 = 0 } e, *pe;\\n\"\n                 \"typedef enum { Value1 = 1 } e1;\")\n        assert ffi.getctype(\"e*\") == 'e *'\n        assert ffi.getctype(\"pe\") == 'e *'\n        assert ffi.getctype(\"e1*\") == 'e1 *'\n\n    def test_opaque_enum(self):\n        import warnings\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"enum foo;\")\n        with warnings.catch_warnings(record=True) as log:\n            warnings.simplefilter(\"always\")\n            n = ffi.cast(\"enum foo\", -1)\n            assert int(n) == 0xffffffff\n        assert str(log[0].message) == (\n            \"'enum foo' has no values explicitly defined; \"\n            \"guessing that it is equivalent to 'unsigned int'\")\n\n    def test_new_ctype(self):\n        ffi = FFI(backend=self.Backend())\n        p = ffi.new(\"int *\")\n        py.test.raises(TypeError, ffi.new, p)\n        p = ffi.new(ffi.typeof(\"int *\"), 42)\n        assert p[0] == 42\n\n    def test_enum_with_non_injective_mapping(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"enum e { AA=0, BB=0, CC=0, DD=0 };\")\n        e = ffi.cast(\"enum e\", 0)\n        assert ffi.string(e) == \"AA\"     # pick the first one arbitrarily\n\n    def test_enum_refer_previous_enum_value(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"enum e { AA, BB=2, CC=4, DD=BB, EE, FF=CC, GG=FF };\")\n        assert ffi.string(ffi.cast(\"enum e\", 2)) == \"BB\"\n        assert ffi.string(ffi.cast(\"enum e\", 3)) == \"EE\"\n        assert ffi.sizeof(\"char[DD]\") == 2\n        assert ffi.sizeof(\"char[EE]\") == 3\n        assert ffi.sizeof(\"char[FF]\") == 4\n        assert ffi.sizeof(\"char[GG]\") == 4\n\n    def test_nested_anonymous_struct(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            struct foo_s {\n                struct { int a, b; };\n                union { int c, d; };\n            };\n        \"\"\")\n        assert ffi.sizeof(\"struct foo_s\") == 3 * SIZE_OF_INT\n        p = ffi.new(\"struct foo_s *\", [1, 2, 3])\n        assert p.a == 1\n        assert p.b == 2\n        assert p.c == 3\n        assert p.d == 3\n        p.d = 17\n        assert p.c == 17\n        p.b = 19\n        assert p.a == 1\n        assert p.b == 19\n        assert p.c == 17\n        assert p.d == 17\n        p = ffi.new(\"struct foo_s *\", {'b': 12, 'd': 14})\n        assert p.a == 0\n        assert p.b == 12\n        assert p.c == 14\n        assert p.d == 14\n        py.test.raises(ValueError, ffi.new, \"struct foo_s *\", [0, 0, 0, 0])\n\n    def test_nested_field_offset_align(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            struct foo_s {\n                struct { int a; char b; };\n                union { char c; };\n            };\n        \"\"\")\n        assert ffi.offsetof(\"struct foo_s\", \"c\") == 2 * SIZE_OF_INT\n        assert ffi.sizeof(\"struct foo_s\") == 3 * SIZE_OF_INT\n\n    def test_nested_anonymous_union(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            union foo_u {\n                struct { int a, b; };\n                union { int c, d; };\n            };\n        \"\"\")\n        assert ffi.sizeof(\"union foo_u\") == 2 * SIZE_OF_INT\n        p = ffi.new(\"union foo_u *\", [5])\n        assert p.a == 5\n        assert p.b == 0\n        assert p.c == 5\n        assert p.d == 5\n        p.d = 17\n        assert p.c == 17\n        assert p.a == 17\n        p.b = 19\n        assert p.a == 17\n        assert p.b == 19\n        assert p.c == 17\n        assert p.d == 17\n        p = ffi.new(\"union foo_u *\", {'d': 14})\n        assert p.a == 14\n        assert p.b == 0\n        assert p.c == 14\n        assert p.d == 14\n        p = ffi.new(\"union foo_u *\", {'a': -63, 'b': 12})\n        assert p.a == -63\n        assert p.b == 12\n        assert p.c == -63\n        assert p.d == -63\n        p = ffi.new(\"union foo_u *\", [123, 456])\n        assert p.a == 123\n        assert p.b == 456\n        assert p.c == 123\n        assert p.d == 123\n        py.test.raises(ValueError, ffi.new, \"union foo_u *\", [0, 0, 0])\n\n    def test_nested_anonymous_struct_2(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            struct foo_s {\n                int a;\n                union { int b; union { int c, d; }; };\n                int e;\n            };\n        \"\"\")\n        assert ffi.sizeof(\"struct foo_s\") == 3 * SIZE_OF_INT\n        p = ffi.new(\"struct foo_s *\", [11, 22, 33])\n        assert p.a == 11\n        assert p.b == p.c == p.d == 22\n        assert p.e == 33\n        py.test.raises(ValueError, ffi.new, \"struct foo_s *\", [11, 22, 33, 44])\n        FOO = ffi.typeof(\"struct foo_s\")\n        fields = [(name, fld.offset, fld.flags) for (name, fld) in FOO.fields]\n        assert fields == [\n            ('a', 0 * SIZE_OF_INT, 0),\n            ('b', 1 * SIZE_OF_INT, 0),\n            ('c', 1 * SIZE_OF_INT, 1),\n            ('d', 1 * SIZE_OF_INT, 1),\n            ('e', 2 * SIZE_OF_INT, 0),\n        ]\n\n    def test_cast_to_array_type(self):\n        ffi = FFI(backend=self.Backend())\n        p = ffi.new(\"int[4]\", [-5])\n        q = ffi.cast(\"int[3]\", p)\n        assert q[0] == -5\n        assert repr(q).startswith(\"<cdata 'int[3]' 0x\")\n\n    def test_gc(self):\n        ffi = FFI(backend=self.Backend())\n        p = ffi.new(\"int *\", 123)\n        seen = []\n        def destructor(p1):\n            assert p1 is p\n            assert p1[0] == 123\n            seen.append(1)\n        q = ffi.gc(p, destructor)\n        assert ffi.typeof(q) is ffi.typeof(p)\n        import gc; gc.collect()\n        assert seen == []\n        del q\n        import gc; gc.collect(); gc.collect(); gc.collect()\n        assert seen == [1]\n\n    def test_gc_2(self):\n        ffi = FFI(backend=self.Backend())\n        p = ffi.new(\"int *\", 123)\n        seen = []\n        q1 = ffi.gc(p, lambda p: seen.append(1))\n        q2 = ffi.gc(q1, lambda p: seen.append(2))\n        import gc; gc.collect()\n        assert seen == []\n        del q1, q2\n        import gc; gc.collect(); gc.collect(); gc.collect(); gc.collect()\n        assert seen == [2, 1]\n\n    def test_gc_3(self):\n        ffi = FFI(backend=self.Backend())\n        p = ffi.new(\"int *\", 123)\n        r = ffi.new(\"int *\", 123)\n        seen = []\n        seen_r = []\n        q1 = ffi.gc(p, lambda p: seen.append(1))\n        s1 = ffi.gc(r, lambda r: seen_r.append(4))\n        q2 = ffi.gc(q1, lambda p: seen.append(2))\n        s2 = ffi.gc(s1, lambda r: seen_r.append(5))\n        q3 = ffi.gc(q2, lambda p: seen.append(3))\n        import gc; gc.collect()\n        assert seen == []\n        assert seen_r == []\n        del q1, q2, q3, s2, s1\n        import gc; gc.collect(); gc.collect(); gc.collect(); gc.collect()\n        assert seen == [3, 2, 1]\n        assert seen_r == [5, 4]\n\n    def test_gc_4(self):\n        ffi = FFI(backend=self.Backend())\n        p = ffi.new(\"int *\", 123)\n        seen = []\n        q1 = ffi.gc(p, lambda p: seen.append(1))\n        q2 = ffi.gc(q1, lambda p: seen.append(2))\n        q3 = ffi.gc(q2, lambda p: seen.append(3))\n        import gc; gc.collect()\n        assert seen == []\n        del q1, q3     # q2 remains, and has a hard ref to q1\n        import gc; gc.collect(); gc.collect(); gc.collect()\n        assert seen == [3]\n\n    def test_gc_disable(self):\n        ffi = FFI(backend=self.Backend())\n        p = ffi.new(\"int *\", 123)\n        py.test.raises(TypeError, ffi.gc, p, None)\n        seen = []\n        q1 = ffi.gc(p, lambda p: seen.append(1))\n        q2 = ffi.gc(q1, lambda p: seen.append(2))\n        import gc; gc.collect()\n        assert seen == []\n        assert ffi.gc(q1, None) is None\n        del q1, q2\n        import gc; gc.collect(); gc.collect(); gc.collect()\n        assert seen == [2]\n\n    def test_gc_finite_list(self):\n        ffi = FFI(backend=self.Backend())\n        p = ffi.new(\"int *\", 123)\n        keepalive = []\n        for i in range(10):\n            keepalive.append(ffi.gc(p, lambda p: None))\n        del keepalive[:]\n        import gc; gc.collect(); gc.collect()\n        for i in range(10):\n            keepalive.append(ffi.gc(p, lambda p: None))\n\n    def test_CData_CType(self):\n        ffi = FFI(backend=self.Backend())\n        assert isinstance(ffi.cast(\"int\", 0), ffi.CData)\n        assert isinstance(ffi.new(\"int *\"), ffi.CData)\n        assert not isinstance(ffi.typeof(\"int\"), ffi.CData)\n        assert not isinstance(ffi.cast(\"int\", 0), ffi.CType)\n        assert not isinstance(ffi.new(\"int *\"), ffi.CType)\n\n    def test_CData_CType_2(self):\n        ffi = FFI(backend=self.Backend())\n        assert isinstance(ffi.typeof(\"int\"), ffi.CType)\n\n    def test_bool(self):\n        ffi = FFI(backend=self.Backend())\n        assert int(ffi.cast(\"_Bool\", 0.1)) == 1\n        assert int(ffi.cast(\"_Bool\", -0.0)) == 0\n        assert int(ffi.cast(\"_Bool\", b'\\x02')) == 1\n        assert int(ffi.cast(\"_Bool\", b'\\x00')) == 0\n        assert int(ffi.cast(\"_Bool\", b'\\x80')) == 1\n        assert ffi.new(\"_Bool *\", False)[0] == 0\n        assert ffi.new(\"_Bool *\", 1)[0] == 1\n        py.test.raises(OverflowError, ffi.new, \"_Bool *\", 2)\n        py.test.raises(TypeError, ffi.string, ffi.cast(\"_Bool\", 2))\n\n    def test_use_own_bool(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"typedef int bool;\"\"\")\n\n    def test_ordering_bug1(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            struct foo_s {\n                struct bar_s *p;\n            };\n            struct bar_s {\n                struct foo_s foo;\n            };\n        \"\"\")\n        q = ffi.new(\"struct foo_s *\")\n        bar = ffi.new(\"struct bar_s *\")\n        q.p = bar\n        assert q.p.foo.p == ffi.NULL\n\n    def test_ordering_bug2(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            struct bar_s;\n\n            struct foo_s {\n                void (*foo)(struct bar_s[]);\n            };\n\n            struct bar_s {\n                struct foo_s foo;\n            };\n        \"\"\")\n        q = ffi.new(\"struct foo_s *\")\n\n    def test_addressof(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo_s { int x, y; };\")\n        p = ffi.new(\"struct foo_s *\")\n        a = ffi.addressof(p[0])\n        assert repr(a).startswith(\"<cdata 'struct foo_s *' 0x\")\n        assert a == p\n        py.test.raises(TypeError, ffi.addressof, p)\n        py.test.raises((AttributeError, TypeError), ffi.addressof, 5)\n        py.test.raises(TypeError, ffi.addressof, ffi.cast(\"int\", 5))\n\n    def test_addressof_field(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo_s { int x, y; };\")\n        p = ffi.new(\"struct foo_s *\")\n        a = ffi.addressof(p[0], 'y')\n        assert repr(a).startswith(\"<cdata 'int *' 0x\")\n        assert int(ffi.cast(\"uintptr_t\", a)) == (\n            int(ffi.cast(\"uintptr_t\", p)) + ffi.sizeof(\"int\"))\n        assert a == ffi.addressof(p, 'y')\n        assert a != ffi.addressof(p, 'x')\n\n    def test_addressof_field_nested(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo_s { int x, y; };\"\n                 \"struct bar_s { struct foo_s a, b; };\")\n        p = ffi.new(\"struct bar_s *\")\n        py.test.raises(KeyError, ffi.addressof, p[0], 'b.y')\n        a = ffi.addressof(p[0], 'b', 'y')\n        assert int(ffi.cast(\"uintptr_t\", a)) == (\n            int(ffi.cast(\"uintptr_t\", p)) +\n            ffi.sizeof(\"struct foo_s\") + ffi.sizeof(\"int\"))\n\n    def test_addressof_anonymous_struct(self):\n        ffi = FFI()\n        ffi.cdef(\"typedef struct { int x; } foo_t;\")\n        p = ffi.new(\"foo_t *\")\n        a = ffi.addressof(p[0])\n        assert a == p\n\n    def test_addressof_array(self):\n        ffi = FFI()\n        p = ffi.new(\"int[52]\")\n        p0 = ffi.addressof(p)\n        assert p0 == p\n        assert ffi.typeof(p0) is ffi.typeof(\"int(*)[52]\")\n        py.test.raises(TypeError, ffi.addressof, p0)\n        #\n        p1 = ffi.addressof(p, 25)\n        assert ffi.typeof(p1) is ffi.typeof(\"int *\")\n        assert (p1 - p) == 25\n        assert ffi.addressof(p, 0) == p\n\n    def test_addressof_pointer(self):\n        ffi = FFI()\n        array = ffi.new(\"int[50]\")\n        p = ffi.cast(\"int *\", array)\n        py.test.raises(TypeError, ffi.addressof, p)\n        assert ffi.addressof(p, 0) == p\n        assert ffi.addressof(p, 25) == p + 25\n        assert ffi.typeof(ffi.addressof(p, 25)) == ffi.typeof(p)\n        #\n        ffi.cdef(\"struct foo { int a, b; };\")\n        array = ffi.new(\"struct foo[50]\")\n        p = ffi.cast(\"int *\", array)\n        py.test.raises(TypeError, ffi.addressof, p)\n        assert ffi.addressof(p, 0) == p\n        assert ffi.addressof(p, 25) == p + 25\n        assert ffi.typeof(ffi.addressof(p, 25)) == ffi.typeof(p)\n\n    def test_addressof_array_in_struct(self):\n        ffi = FFI()\n        ffi.cdef(\"struct foo { int a, b; int c[50]; };\")\n        p = ffi.new(\"struct foo *\")\n        p1 = ffi.addressof(p, \"c\", 25)\n        assert ffi.typeof(p1) is ffi.typeof(\"int *\")\n        assert p1 == ffi.cast(\"int *\", p) + 27\n        assert ffi.addressof(p, \"c\") == ffi.cast(\"int *\", p) + 2\n        assert ffi.addressof(p, \"c\", 0) == ffi.cast(\"int *\", p) + 2\n        p2 = ffi.addressof(p, 1)\n        assert ffi.typeof(p2) is ffi.typeof(\"struct foo *\")\n        assert p2 == p + 1\n\n    def test_multiple_independent_structs(self):\n        ffi1 = FFI(); ffi1.cdef(\"struct foo { int x; };\")\n        ffi2 = FFI(); ffi2.cdef(\"struct foo { int y, z; };\")\n        foo1 = ffi1.new(\"struct foo *\", [10])\n        foo2 = ffi2.new(\"struct foo *\", [20, 30])\n        assert foo1.x == 10\n        assert foo2.y == 20\n        assert foo2.z == 30\n\n    def test_missing_include(self):\n        backend = self.Backend()\n        ffi1 = FFI(backend=backend)\n        ffi2 = FFI(backend=backend)\n        ffi1.cdef(\"typedef signed char schar_t;\")\n        py.test.raises(CDefError, ffi2.cast, \"schar_t\", 142)\n\n    def test_include_typedef(self):\n        backend = self.Backend()\n        ffi1 = FFI(backend=backend)\n        ffi2 = FFI(backend=backend)\n        ffi1.cdef(\"typedef signed char schar_t;\")\n        ffi2.include(ffi1)\n        p = ffi2.cast(\"schar_t\", 142)\n        assert int(p) == 142 - 256\n\n    def test_include_struct(self):\n        backend = self.Backend()\n        ffi1 = FFI(backend=backend)\n        ffi2 = FFI(backend=backend)\n        ffi1.cdef(\"struct foo { int x; };\")\n        ffi2.include(ffi1)\n        p = ffi2.new(\"struct foo *\", [142])\n        assert p.x == 142\n\n    def test_include_union(self):\n        backend = self.Backend()\n        ffi1 = FFI(backend=backend)\n        ffi2 = FFI(backend=backend)\n        ffi1.cdef(\"union foo { int x; };\")\n        ffi2.include(ffi1)\n        p = ffi2.new(\"union foo *\", [142])\n        assert p.x == 142\n\n    def test_include_enum(self):\n        backend = self.Backend()\n        ffi1 = FFI(backend=backend)\n        ffi2 = FFI(backend=backend)\n        ffi1.cdef(\"enum foo { FA, FB, FC };\")\n        ffi2.include(ffi1)\n        p = ffi2.cast(\"enum foo\", 1)\n        assert ffi2.string(p) == \"FB\"\n        assert ffi2.sizeof(\"char[FC]\") == 2\n\n    def test_include_typedef_2(self):\n        backend = self.Backend()\n        ffi1 = FFI(backend=backend)\n        ffi2 = FFI(backend=backend)\n        ffi1.cdef(\"typedef struct { int x; } *foo_p;\")\n        ffi2.include(ffi1)\n        p = ffi2.new(\"foo_p\", [142])\n        assert p.x == 142\n\n    def test_ignore_multiple_declarations_of_constant(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"#define FOO 42\")\n        ffi.cdef(\"#define FOO 42\")\n        py.test.raises(FFIError, ffi.cdef, \"#define FOO 43\")\n\n    def test_struct_packed(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct nonpacked { char a; int b; };\")\n        ffi.cdef(\"struct is_packed { char a; int b; };\", packed=True)\n        ffi.cdef(\"struct is_packed1 { char a; int b; };\", pack=1)\n        ffi.cdef(\"struct is_packed2 { char a; int b; };\", pack=2)\n        ffi.cdef(\"struct is_packed4 { char a; int b; };\", pack=4)\n        ffi.cdef(\"struct is_packed8 { char a; int b; };\", pack=8)\n        assert ffi.sizeof(\"struct nonpacked\") == 8\n        assert ffi.sizeof(\"struct is_packed\") == 5\n        assert ffi.sizeof(\"struct is_packed1\") == 5\n        assert ffi.sizeof(\"struct is_packed2\") == 6\n        assert ffi.sizeof(\"struct is_packed4\") == 8\n        assert ffi.sizeof(\"struct is_packed8\") == 8\n        assert ffi.alignof(\"struct nonpacked\") == 4\n        assert ffi.alignof(\"struct is_packed\") == 1\n        assert ffi.alignof(\"struct is_packed1\") == 1\n        assert ffi.alignof(\"struct is_packed2\") == 2\n        assert ffi.alignof(\"struct is_packed4\") == 4\n        assert ffi.alignof(\"struct is_packed8\") == 4\n        for name in ['is_packed', 'is_packed1', 'is_packed2',\n                     'is_packed4', 'is_packed8']:\n            s = ffi.new(\"struct %s[2]\" % name)\n            s[0].b = 42623381\n            s[0].a = b'X'\n            s[1].b = -4892220\n            s[1].a = b'Y'\n            assert s[0].b == 42623381\n            assert s[0].a == b'X'\n            assert s[1].b == -4892220\n            assert s[1].a == b'Y'\n\n    def test_pack_valueerror(self):\n        ffi = FFI(backend=self.Backend())\n        py.test.raises(ValueError, ffi.cdef, \"\", pack=3)\n        py.test.raises(ValueError, ffi.cdef, \"\", packed=2)\n        py.test.raises(ValueError, ffi.cdef, \"\", packed=True, pack=1)\n\n    def test_define_integer_constant(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            #define DOT_0 0\n            #define DOT 100\n            #define DOT_OCT 0100l\n            #define DOT_HEX 0x100u\n            #define DOT_HEX2 0X10\n            #define DOT_UL 1000UL\n            enum foo {AA, BB=DOT, CC};\n        \"\"\")\n        needs_dlopen_none()\n        lib = ffi.dlopen(None)\n        assert ffi.string(ffi.cast(\"enum foo\", 100)) == \"BB\"\n        assert lib.DOT_0 == 0\n        assert lib.DOT == 100\n        assert lib.DOT_OCT == 0o100\n        assert lib.DOT_HEX == 0x100\n        assert lib.DOT_HEX2 == 0x10\n        assert lib.DOT_UL == 1000\n\n    def test_opaque_struct_becomes_nonopaque(self):\n        # Issue #193: if we use a struct between the first cdef() where it is\n        # declared and another cdef() where its fields are defined, then the\n        # definition was ignored.\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo_s;\")\n        py.test.raises(TypeError, ffi.new, \"struct foo_s *\")\n        ffi.cdef(\"struct foo_s { int x; };\")\n        ffi.new(\"struct foo_s *\")\n\n    def test_ffi_self_include(self):\n        ffi = FFI(backend=self.Backend())\n        py.test.raises(ValueError, ffi.include, ffi)\n\n    def test_anonymous_enum_include(self):\n        ffi1 = FFI()\n        ffi1.cdef(\"enum { EE1 };\")\n        ffi = FFI()\n        ffi.include(ffi1)\n        ffi.cdef(\"enum { EE2, EE3 };\")\n        needs_dlopen_none()\n        lib = ffi.dlopen(None)\n        assert lib.EE1 == 0\n        assert lib.EE2 == 0\n        assert lib.EE3 == 1\n\n    def test_init_once(self):\n        def do_init():\n            seen.append(1)\n            return 42\n        ffi = FFI()\n        seen = []\n        for i in range(3):\n            res = ffi.init_once(do_init, \"tag1\")\n            assert res == 42\n            assert seen == [1]\n        for i in range(3):\n            res = ffi.init_once(do_init, \"tag2\")\n            assert res == 42\n            assert seen == [1, 1]\n\n    def test_init_once_multithread(self):\n        import sys, time\n        if sys.version_info < (3,):\n            import thread\n        else:\n            import _thread as thread\n        #\n        def do_init():\n            seen.append('init!')\n            time.sleep(1)\n            seen.append('init done')\n            return 7\n        ffi = FFI()\n        seen = []\n        for i in range(6):\n            def f():\n                res = ffi.init_once(do_init, \"tag\")\n                seen.append(res)\n            thread.start_new_thread(f, ())\n        time.sleep(1.5)\n        assert seen == ['init!', 'init done'] + 6 * [7]\n\n    def test_sizeof_struct_directly(self):\n        # only works with the Python FFI instances\n        ffi = FFI(backend=self.Backend())\n        assert ffi.sizeof(\"struct{int a;}\") == ffi.sizeof(\"int\")\n\n    def test_callback_large_struct(self):\n        ffi = FFI(backend=self.Backend())\n        # more than 8 bytes\n        ffi.cdef(\"struct foo_s { unsigned long a, b, c; };\")\n        #\n        @ffi.callback(\"void(struct foo_s)\")\n        def cb(s):\n            seen.append(ffi.typeof(s))\n            s.a += 1\n            s.b += 2\n            s.c += 3\n            seen.append(s.a)\n            seen.append(s.b)\n            seen.append(s.c)\n        #\n        s1 = ffi.new(\"struct foo_s *\", {'a': 100, 'b': 200, 'c': 300})\n        seen = []\n        cb(s1[0])\n        assert len(seen) == 4\n        assert s1.a == 100     # unmodified\n        assert s1.b == 200\n        assert s1.c == 300\n        assert seen[0] == ffi.typeof(\"struct foo_s\")\n        assert seen[1] == 101\n        assert seen[2] == 202\n        assert seen[3] == 303\n\n    def test_ffi_array_as_init(self):\n        ffi = FFI(backend=self.Backend())\n        p = ffi.new(\"int[4]\", [10, 20, 30, 400])\n        q = ffi.new(\"int[4]\", p)\n        assert list(q) == [10, 20, 30, 400]\n        py.test.raises(TypeError, ffi.new, \"int[3]\", p)\n        py.test.raises(TypeError, ffi.new, \"int[5]\", p)\n        py.test.raises(TypeError, ffi.new, \"int16_t[4]\", p)\n        s = ffi.new(\"struct {int i[4];}*\", {'i': p})\n        assert list(s.i) == [10, 20, 30, 400]\n\n    def test_too_many_initializers(self):\n        ffi = FFI(backend=self.Backend())\n        py.test.raises(IndexError, ffi.new, \"int[4]\", [10, 20, 30, 40, 50])\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.13.0-jlicqgsrlask3n7tsdckxmdwv6d5zp4o/spack-src/testing/cffi0/test_ffi_backend.py": "import py, sys, platform\nimport pytest\nfrom testing.cffi0 import backend_tests, test_function, test_ownlib\nfrom testing.support import u\nfrom cffi import FFI\nimport _cffi_backend\n\n\nclass TestFFI(backend_tests.BackendTests,\n              test_function.TestFunction,\n              test_ownlib.TestOwnLib):\n    TypeRepr = \"<ctype '%s'>\"\n\n    @staticmethod\n    def Backend():\n        return _cffi_backend\n\n    def test_not_supported_bitfield_in_result(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo_s { int a,b,c,d,e; int x:1; };\")\n        e = py.test.raises(NotImplementedError, ffi.callback,\n                           \"struct foo_s foo(void)\", lambda: 42)\n        assert str(e.value) == (\"struct foo_s(*)(): \"\n            \"callback with unsupported argument or return type or with '...'\")\n\n    def test_inspecttype(self):\n        ffi = FFI(backend=self.Backend())\n        assert ffi.typeof(\"long\").kind == \"primitive\"\n        assert ffi.typeof(\"long(*)(long, long**, ...)\").cname == (\n            \"long(*)(long, long * *, ...)\")\n        assert ffi.typeof(\"long(*)(long, long**, ...)\").ellipsis is True\n\n    def test_new_handle(self):\n        ffi = FFI(backend=self.Backend())\n        o = [2, 3, 4]\n        p = ffi.new_handle(o)\n        assert ffi.typeof(p) == ffi.typeof(\"void *\")\n        assert ffi.from_handle(p) is o\n        assert ffi.from_handle(ffi.cast(\"char *\", p)) is o\n        py.test.raises(RuntimeError, ffi.from_handle, ffi.NULL)\n\n    def test_callback_onerror(self):\n        ffi = FFI(backend=self.Backend())\n        seen = []\n        def oops(*args):\n            seen.append(args)\n        def otherfunc():\n            raise LookupError\n        def cb(n):\n            otherfunc()\n        a = ffi.callback(\"int(*)(int)\", cb, error=42, onerror=oops)\n        res = a(234)\n        assert res == 42\n        assert len(seen) == 1\n        exc, val, tb = seen[0]\n        assert exc is LookupError\n        assert isinstance(val, LookupError)\n        assert tb.tb_frame.f_code.co_name == 'cb'\n        assert tb.tb_frame.f_locals['n'] == 234\n\n    def test_ffi_new_allocator_2(self):\n        ffi = FFI(backend=self.Backend())\n        seen = []\n        def myalloc(size):\n            seen.append(size)\n            return ffi.new(\"char[]\", b\"X\" * size)\n        def myfree(raw):\n            seen.append(raw)\n        alloc1 = ffi.new_allocator(myalloc, myfree)\n        alloc2 = ffi.new_allocator(alloc=myalloc, free=myfree,\n                                   should_clear_after_alloc=False)\n        p1 = alloc1(\"int[10]\")\n        p2 = alloc2(\"int[]\", 10)\n        assert seen == [40, 40]\n        assert ffi.typeof(p1) == ffi.typeof(\"int[10]\")\n        assert ffi.sizeof(p1) == 40\n        assert ffi.typeof(p2) == ffi.typeof(\"int[]\")\n        assert ffi.sizeof(p2) == 40\n        assert p1[5] == 0\n        assert p2[6] == ord('X') * 0x01010101\n        raw1 = ffi.cast(\"char *\", p1)\n        raw2 = ffi.cast(\"char *\", p2)\n        del p1, p2\n        retries = 0\n        while len(seen) != 4:\n            retries += 1\n            assert retries <= 5\n            import gc; gc.collect()\n        assert seen == [40, 40, raw1, raw2]\n        assert repr(seen[2]) == \"<cdata 'char[]' owning 41 bytes>\"\n        assert repr(seen[3]) == \"<cdata 'char[]' owning 41 bytes>\"\n\n    def test_ffi_new_allocator_3(self):\n        ffi = FFI(backend=self.Backend())\n        seen = []\n        def myalloc(size):\n            seen.append(size)\n            return ffi.new(\"char[]\", b\"X\" * size)\n        alloc1 = ffi.new_allocator(myalloc)    # no 'free'\n        p1 = alloc1(\"int[10]\")\n        assert seen == [40]\n        assert ffi.typeof(p1) == ffi.typeof(\"int[10]\")\n        assert ffi.sizeof(p1) == 40\n        assert p1[5] == 0\n\n    def test_ffi_new_allocator_4(self):\n        ffi = FFI(backend=self.Backend())\n        py.test.raises(TypeError, ffi.new_allocator, free=lambda x: None)\n        #\n        def myalloc2(size):\n            raise LookupError\n        alloc2 = ffi.new_allocator(myalloc2)\n        py.test.raises(LookupError, alloc2, \"int[5]\")\n        #\n        def myalloc3(size):\n            return 42\n        alloc3 = ffi.new_allocator(myalloc3)\n        e = py.test.raises(TypeError, alloc3, \"int[5]\")\n        assert str(e.value) == \"alloc() must return a cdata object (got int)\"\n        #\n        def myalloc4(size):\n            return ffi.cast(\"int\", 42)\n        alloc4 = ffi.new_allocator(myalloc4)\n        e = py.test.raises(TypeError, alloc4, \"int[5]\")\n        assert str(e.value) == \"alloc() must return a cdata pointer, not 'int'\"\n        #\n        def myalloc5(size):\n            return ffi.NULL\n        alloc5 = ffi.new_allocator(myalloc5)\n        py.test.raises(MemoryError, alloc5, \"int[5]\")\n\n    def test_new_struct_containing_struct_containing_array_varsize(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            struct foo_s { int len[100]; short data[]; };\n            struct bar_s { int abc[100]; struct foo_s tail; };\n        \"\"\")\n        # loop to try to detect heap overwrites, if the size allocated\n        # is too small\n        for i in range(1, 501, 100):\n            p = ffi.new(\"struct bar_s *\", [[10], [[20], [3,4,5,6,7,8,9] * i]])\n            assert p.abc[0] == 10\n            assert p.tail.len[0] == 20\n            assert p.tail.data[0] == 3\n            assert p.tail.data[6] == 9\n            assert p.tail.data[7 * i - 1] == 9\n\n    def test_bogus_struct_containing_struct_containing_array_varsize(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            struct foo_s { signed char len; signed char data[]; };\n            struct bar_s { struct foo_s foo; int bcd; };\n        \"\"\")\n        p = ffi.new(\"struct bar_s *\", [[123, [45, 56, 67, 78]], 9999999])\n        assert p.foo.len == 123\n        assert p.foo.data[0] == 45\n        assert p.foo.data[1] == 56\n        assert p.foo.data[2] == 67\n        assert p.bcd == 9999999\n        assert p.foo.data[3] != 78   # has been overwritten with 9999999\n\n\nclass TestBitfield:\n    def check(self, source, expected_ofs_y, expected_align, expected_size):\n        # NOTE: 'expected_*' is the numbers expected from GCC.\n        # The numbers expected from MSVC are not explicitly written\n        # in this file, and will just be taken from the compiler.\n        ffi = FFI()\n        ffi.cdef(\"struct s1 { %s };\" % source)\n        ctype = ffi.typeof(\"struct s1\")\n        # verify the information with gcc\n        ffi1 = FFI()\n        ffi1.cdef(\"\"\"\n            static const int Gofs_y, Galign, Gsize;\n            struct s1 *try_with_value(int fieldnum, long long value);\n        \"\"\")\n        fnames = [name for name, cfield in ctype.fields\n                       if name and cfield.bitsize > 0]\n        setters = ['case %d: s.%s = value; break;' % iname\n                   for iname in enumerate(fnames)]\n        lib = ffi1.verify(\"\"\"\n            struct s1 { %s };\n            struct sa { char a; struct s1 b; };\n            #define Gofs_y  offsetof(struct s1, y)\n            #define Galign  offsetof(struct sa, b)\n            #define Gsize   sizeof(struct s1)\n            struct s1 *try_with_value(int fieldnum, long long value)\n            {\n                static struct s1 s;\n                memset(&s, 0, sizeof(s));\n                switch (fieldnum) { %s }\n                return &s;\n            }\n        \"\"\" % (source, ' '.join(setters)))\n        if sys.platform == 'win32':\n            expected_ofs_y = lib.Gofs_y\n            expected_align = lib.Galign\n            expected_size  = lib.Gsize\n        else:\n            assert (lib.Gofs_y, lib.Galign, lib.Gsize) == (\n                expected_ofs_y, expected_align, expected_size)\n        # the real test follows\n        assert ffi.offsetof(\"struct s1\", \"y\") == expected_ofs_y\n        assert ffi.alignof(\"struct s1\") == expected_align\n        assert ffi.sizeof(\"struct s1\") == expected_size\n        # compare the actual storage of the two\n        for name, cfield in ctype.fields:\n            if cfield.bitsize < 0 or not name:\n                continue\n            if int(ffi.cast(cfield.type, -1)) == -1:   # signed\n                min_value = -(1 << (cfield.bitsize-1))\n                max_value = (1 << (cfield.bitsize-1)) - 1\n            else:\n                min_value = 0\n                max_value = (1 << cfield.bitsize) - 1\n            for t in [1, 2, 4, 8, 16, 128, 2813, 89728, 981729,\n                     -1,-2,-4,-8,-16,-128,-2813,-89728,-981729]:\n                if min_value <= t <= max_value:\n                    self._fieldcheck(ffi, lib, fnames, name, t)\n\n    def _fieldcheck(self, ffi, lib, fnames, name, value):\n        s = ffi.new(\"struct s1 *\")\n        setattr(s, name, value)\n        assert getattr(s, name) == value\n        raw1 = ffi.buffer(s)[:]\n        buff1 = ffi.buffer(s)\n        t = lib.try_with_value(fnames.index(name), value)\n        raw2 = ffi.buffer(t, len(raw1))[:]\n        assert raw1 == raw2\n        buff2 = ffi.buffer(t, len(buff1))\n        assert buff1 == buff2\n\n    def test_bitfield_basic(self):\n        self.check(\"int a; int b:9; int c:20; int y;\", 8, 4, 12)\n        self.check(\"int a; short b:9; short c:7; int y;\", 8, 4, 12)\n        self.check(\"int a; short b:9; short c:9; int y;\", 8, 4, 12)\n\n    def test_bitfield_reuse_if_enough_space(self):\n        self.check(\"int a:2; char y;\", 1, 4, 4)\n        self.check(\"int a:1; char b  ; int c:1; char y;\", 3, 4, 4)\n        self.check(\"int a:1; char b:8; int c:1; char y;\", 3, 4, 4)\n        self.check(\"char a; int b:9; char y;\", 3, 4, 4)\n        self.check(\"char a; short b:9; char y;\", 4, 2, 6)\n        self.check(\"int a:2; char b:6; char y;\", 1, 4, 4)\n        self.check(\"int a:2; char b:7; char y;\", 2, 4, 4)\n        self.check(\"int a:2; short b:15; char c:2; char y;\", 5, 4, 8)\n        self.check(\"int a:2; char b:1; char c:1; char y;\", 1, 4, 4)\n\n    @pytest.mark.skipif(\"platform.machine().startswith(('arm', 'aarch64'))\")\n    def test_bitfield_anonymous_no_align(self):\n        L = FFI().alignof(\"long long\")\n        self.check(\"char y; int :1;\", 0, 1, 2)\n        self.check(\"char x; int z:1; char y;\", 2, 4, 4)\n        self.check(\"char x; int  :1; char y;\", 2, 1, 3)\n        self.check(\"char x; long long z:48; char y;\", 7, L, 8)\n        self.check(\"char x; long long  :48; char y;\", 7, 1, 8)\n        self.check(\"char x; long long z:56; char y;\", 8, L, 8 + L)\n        self.check(\"char x; long long  :56; char y;\", 8, 1, 9)\n        self.check(\"char x; long long z:57; char y;\", L + 8, L, L + 8 + L)\n        self.check(\"char x; long long  :57; char y;\", L + 8, 1, L + 9)\n\n    @pytest.mark.skipif(\n        \"not platform.machine().startswith(('arm', 'aarch64'))\")\n    def test_bitfield_anonymous_align_arm(self):\n        L = FFI().alignof(\"long long\")\n        self.check(\"char y; int :1;\", 0, 4, 4)\n        self.check(\"char x; int z:1; char y;\", 2, 4, 4)\n        self.check(\"char x; int  :1; char y;\", 2, 4, 4)\n        self.check(\"char x; long long z:48; char y;\", 7, L, 8)\n        self.check(\"char x; long long  :48; char y;\", 7, 8, 8)\n        self.check(\"char x; long long z:56; char y;\", 8, L, 8 + L)\n        self.check(\"char x; long long  :56; char y;\", 8, L, 8 + L)\n        self.check(\"char x; long long z:57; char y;\", L + 8, L, L + 8 + L)\n        self.check(\"char x; long long  :57; char y;\", L + 8, L, L + 8 + L)\n\n    @pytest.mark.skipif(\"platform.machine().startswith(('arm', 'aarch64'))\")\n    def test_bitfield_zero(self):\n        L = FFI().alignof(\"long long\")\n        self.check(\"char y; int :0;\", 0, 1, 4)\n        self.check(\"char x; int :0; char y;\", 4, 1, 5)\n        self.check(\"char x; int :0; int :0; char y;\", 4, 1, 5)\n        self.check(\"char x; long long :0; char y;\", L, 1, L + 1)\n        self.check(\"short x, y; int :0; int :0;\", 2, 2, 4)\n        self.check(\"char x; int :0; short b:1; char y;\", 5, 2, 6)\n        self.check(\"int a:1; int :0; int b:1; char y;\", 5, 4, 8)\n\n    @pytest.mark.skipif(\n        \"not platform.machine().startswith(('arm', 'aarch64'))\")\n    def test_bitfield_zero_arm(self):\n        L = FFI().alignof(\"long long\")\n        self.check(\"char y; int :0;\", 0, 4, 4)\n        self.check(\"char x; int :0; char y;\", 4, 4, 8)\n        self.check(\"char x; int :0; int :0; char y;\", 4, 4, 8)\n        self.check(\"char x; long long :0; char y;\", L, 8, L + 8)\n        self.check(\"short x, y; int :0; int :0;\", 2, 4, 4)\n        self.check(\"char x; int :0; short b:1; char y;\", 5, 4, 8)\n        self.check(\"int a:1; int :0; int b:1; char y;\", 5, 4, 8)\n\n    def test_error_cases(self):\n        ffi = FFI()\n        ffi.cdef(\"struct s1 { float x:1; };\")\n        with pytest.raises(TypeError):\n            ffi.new(\"struct s1 *\")\n        ffi.cdef(\"struct s2 { char x:0; };\")\n        with pytest.raises(TypeError):\n            ffi.new(\"struct s2 *\")\n        ffi.cdef(\"struct s3 { char x:9; };\")\n        with pytest.raises(TypeError):\n            ffi.new(\"struct s3 *\")\n\n    def test_struct_with_typedef(self):\n        ffi = FFI()\n        ffi.cdef(\"typedef struct { float x; } foo_t;\")\n        p = ffi.new(\"foo_t *\", [5.2])\n        assert repr(p).startswith(\"<cdata 'foo_t *' \")\n\n    def test_struct_array_no_length(self):\n        ffi = FFI()\n        ffi.cdef(\"struct foo_s { int x; int a[]; };\")\n        p = ffi.new(\"struct foo_s *\", [100, [200, 300, 400]])\n        assert p.x == 100\n        assert ffi.typeof(p.a) is ffi.typeof(\"int[]\")\n        assert len(p.a) == 3                            # length recorded\n        assert p.a[0] == 200\n        assert p.a[1] == 300\n        assert p.a[2] == 400\n        assert list(p.a) == [200, 300, 400]\n        q = ffi.cast(\"struct foo_s *\", p)\n        assert q.x == 100\n        assert ffi.typeof(q.a) is ffi.typeof(\"int *\")   # no length recorded\n        py.test.raises(TypeError, len, q.a)\n        assert q.a[0] == 200\n        assert q.a[1] == 300\n        assert q.a[2] == 400\n        py.test.raises(TypeError, list, q.a)\n\n    @pytest.mark.skipif(\"sys.platform != 'win32'\")\n    def test_getwinerror(self):\n        ffi = FFI()\n        code, message = ffi.getwinerror(1155)\n        assert code == 1155\n        assert message == (\"No application is associated with the \"\n                           \"specified file for this operation\")\n        ffi.cdef(\"void SetLastError(int);\")\n        lib = ffi.dlopen(\"Kernel32.dll\")\n        lib.SetLastError(2)\n        code, message = ffi.getwinerror()\n        assert code == 2\n        assert message == \"The system cannot find the file specified\"\n        code, message = ffi.getwinerror(-1)\n        assert code == 2\n        assert message == \"The system cannot find the file specified\"\n\n    def test_from_buffer(self):\n        import array\n        ffi = FFI()\n        a = array.array('H', [10000, 20000, 30000])\n        c = ffi.from_buffer(a)\n        assert ffi.typeof(c) is ffi.typeof(\"char[]\")\n        assert len(c) == 6\n        ffi.cast(\"unsigned short *\", c)[1] += 500\n        assert list(a) == [10000, 20500, 30000]\n        assert c == ffi.from_buffer(\"char[]\", a, True)\n        assert c == ffi.from_buffer(a, require_writable=True)\n        #\n        c = ffi.from_buffer(\"unsigned short[]\", a)\n        assert len(c) == 3\n        assert c[1] == 20500\n        #\n        p = ffi.from_buffer(b\"abcd\")\n        assert p[2] == b\"c\"\n        #\n        assert p == ffi.from_buffer(b\"abcd\", require_writable=False)\n        py.test.raises((TypeError, BufferError), ffi.from_buffer,\n                                                 \"char[]\", b\"abcd\", True)\n        py.test.raises((TypeError, BufferError), ffi.from_buffer, b\"abcd\",\n                                                 require_writable=True)\n\n    def test_release(self):\n        ffi = FFI()\n        p = ffi.new(\"int[]\", 123)\n        ffi.release(p)\n        # here, reading p[0] might give garbage or segfault...\n        ffi.release(p)   # no effect\n\n    def test_memmove(self):\n        ffi = FFI()\n        p = ffi.new(\"short[]\", [-1234, -2345, -3456, -4567, -5678])\n        ffi.memmove(p, p + 1, 4)\n        assert list(p) == [-2345, -3456, -3456, -4567, -5678]\n        p[2] = 999\n        ffi.memmove(p + 2, p, 6)\n        assert list(p) == [-2345, -3456, -2345, -3456, 999]\n        ffi.memmove(p + 4, ffi.new(\"char[]\", b\"\\x71\\x72\"), 2)\n        if sys.byteorder == 'little':\n            assert list(p) == [-2345, -3456, -2345, -3456, 0x7271]\n        else:\n            assert list(p) == [-2345, -3456, -2345, -3456, 0x7172]\n\n    def test_memmove_buffer(self):\n        import array\n        ffi = FFI()\n        a = array.array('H', [10000, 20000, 30000])\n        p = ffi.new(\"short[]\", 5)\n        ffi.memmove(p, a, 6)\n        assert list(p) == [10000, 20000, 30000, 0, 0]\n        ffi.memmove(p + 1, a, 6)\n        assert list(p) == [10000, 10000, 20000, 30000, 0]\n        b = array.array('h', [-1000, -2000, -3000])\n        ffi.memmove(b, a, 4)\n        assert b.tolist() == [10000, 20000, -3000]\n        assert a.tolist() == [10000, 20000, 30000]\n        p[0] = 999\n        p[1] = 998\n        p[2] = 997\n        p[3] = 996\n        p[4] = 995\n        ffi.memmove(b, p, 2)\n        assert b.tolist() == [999, 20000, -3000]\n        ffi.memmove(b, p + 2, 4)\n        assert b.tolist() == [997, 996, -3000]\n        p[2] = -p[2]\n        p[3] = -p[3]\n        ffi.memmove(b, p + 2, 6)\n        assert b.tolist() == [-997, -996, 995]\n\n    def test_memmove_readonly_readwrite(self):\n        ffi = FFI()\n        p = ffi.new(\"signed char[]\", 5)\n        ffi.memmove(p, b\"abcde\", 3)\n        assert list(p) == [ord(\"a\"), ord(\"b\"), ord(\"c\"), 0, 0]\n        ffi.memmove(p, bytearray(b\"ABCDE\"), 2)\n        assert list(p) == [ord(\"A\"), ord(\"B\"), ord(\"c\"), 0, 0]\n        py.test.raises((TypeError, BufferError), ffi.memmove, b\"abcde\", p, 3)\n        ba = bytearray(b\"xxxxx\")\n        ffi.memmove(dest=ba, src=p, n=3)\n        assert ba == bytearray(b\"ABcxx\")\n\n    def test_all_primitives(self):\n        ffi = FFI()\n        for name in [\n            \"char\",\n            \"short\",\n            \"int\",\n            \"long\",\n            \"long long\",\n            \"signed char\",\n            \"unsigned char\",\n            \"unsigned short\",\n            \"unsigned int\",\n            \"unsigned long\",\n            \"unsigned long long\",\n            \"float\",\n            \"double\",\n            \"long double\",\n            \"wchar_t\",\n            \"char16_t\",\n            \"char32_t\",\n            \"_Bool\",\n            \"int8_t\",\n            \"uint8_t\",\n            \"int16_t\",\n            \"uint16_t\",\n            \"int32_t\",\n            \"uint32_t\",\n            \"int64_t\",\n            \"uint64_t\",\n            \"int_least8_t\",\n            \"uint_least8_t\",\n            \"int_least16_t\",\n            \"uint_least16_t\",\n            \"int_least32_t\",\n            \"uint_least32_t\",\n            \"int_least64_t\",\n            \"uint_least64_t\",\n            \"int_fast8_t\",\n            \"uint_fast8_t\",\n            \"int_fast16_t\",\n            \"uint_fast16_t\",\n            \"int_fast32_t\",\n            \"uint_fast32_t\",\n            \"int_fast64_t\",\n            \"uint_fast64_t\",\n            \"intptr_t\",\n            \"uintptr_t\",\n            \"intmax_t\",\n            \"uintmax_t\",\n            \"ptrdiff_t\",\n            \"size_t\",\n            \"ssize_t\",\n            ]:\n            x = ffi.sizeof(name)\n            assert 1 <= x <= 16\n\n    def test_ffi_def_extern(self):\n        ffi = FFI()\n        py.test.raises(ValueError, ffi.def_extern)\n\n    def test_introspect_typedef(self):\n        ffi = FFI()\n        ffi.cdef(\"typedef int foo_t;\")\n        assert ffi.list_types() == (['foo_t'], [], [])\n        assert ffi.typeof('foo_t').kind == 'primitive'\n        assert ffi.typeof('foo_t').cname == 'int'\n        #\n        ffi.cdef(\"typedef signed char a_t, c_t, g_t, b_t;\")\n        assert ffi.list_types() == (['a_t', 'b_t', 'c_t', 'foo_t', 'g_t'],\n                                    [], [])\n\n    def test_introspect_struct(self):\n        ffi = FFI()\n        ffi.cdef(\"struct foo_s { int a; };\")\n        assert ffi.list_types() == ([], ['foo_s'], [])\n        assert ffi.typeof('struct foo_s').kind == 'struct'\n        assert ffi.typeof('struct foo_s').cname == 'struct foo_s'\n\n    def test_introspect_union(self):\n        ffi = FFI()\n        ffi.cdef(\"union foo_s { int a; };\")\n        assert ffi.list_types() == ([], [], ['foo_s'])\n        assert ffi.typeof('union foo_s').kind == 'union'\n        assert ffi.typeof('union foo_s').cname == 'union foo_s'\n\n    def test_introspect_struct_and_typedef(self):\n        ffi = FFI()\n        ffi.cdef(\"typedef struct { int a; } foo_t;\")\n        assert ffi.list_types() == (['foo_t'], [], [])\n        assert ffi.typeof('foo_t').kind == 'struct'\n        assert ffi.typeof('foo_t').cname == 'foo_t'\n\n    def test_introspect_included_type(self):\n        ffi1 = FFI()\n        ffi2 = FFI()\n        ffi1.cdef(\"typedef signed char schar_t; struct sint_t { int x; };\")\n        ffi2.include(ffi1)\n        assert ffi1.list_types() == ffi2.list_types() == (\n            ['schar_t'], ['sint_t'], [])\n\n    def test_introspect_order(self):\n        ffi = FFI()\n        ffi.cdef(\"union CFFIaaa { int a; }; typedef struct CFFIccc { int a; } CFFIb;\")\n        ffi.cdef(\"union CFFIg   { int a; }; typedef struct CFFIcc  { int a; } CFFIbbb;\")\n        ffi.cdef(\"union CFFIaa  { int a; }; typedef struct CFFIa   { int a; } CFFIbb;\")\n        assert ffi.list_types() == (['CFFIb', 'CFFIbb', 'CFFIbbb'],\n                                    ['CFFIa', 'CFFIcc', 'CFFIccc'],\n                                    ['CFFIaa', 'CFFIaaa', 'CFFIg'])\n\n    def test_unpack(self):\n        ffi = FFI()\n        p = ffi.new(\"char[]\", b\"abc\\x00def\")\n        assert ffi.unpack(p+1, 7) == b\"bc\\x00def\\x00\"\n        p = ffi.new(\"int[]\", [-123456789])\n        assert ffi.unpack(p, 1) == [-123456789]\n\n    def test_negative_array_size(self):\n        ffi = FFI()\n        py.test.raises(ValueError, ffi.cast, \"int[-5]\", 0)\n\n    def test_cannot_instantiate_manually(self):\n        ffi = FFI()\n        ct = type(ffi.typeof(\"void *\"))\n        py.test.raises(TypeError, ct)\n        py.test.raises(TypeError, ct, ffi.NULL)\n        for cd in [type(ffi.cast(\"void *\", 0)),\n                   type(ffi.new(\"char[]\", 3)),\n                   type(ffi.gc(ffi.NULL, lambda x: None))]:\n            py.test.raises(TypeError, cd)\n            py.test.raises(TypeError, cd, ffi.NULL)\n            py.test.raises(TypeError, cd, ffi.typeof(\"void *\"))\n\n    def test_explicitly_defined_char16_t(self):\n        ffi = FFI()\n        ffi.cdef(\"typedef uint16_t char16_t;\")\n        x = ffi.cast(\"char16_t\", 1234)\n        assert ffi.typeof(x) is ffi.typeof(\"uint16_t\")\n\n    def test_char16_t(self):\n        ffi = FFI()\n        x = ffi.new(\"char16_t[]\", 5)\n        assert len(x) == 5 and ffi.sizeof(x) == 10\n        x[2] = u+'\\u1324'\n        assert x[2] == u+'\\u1324'\n        y = ffi.new(\"char16_t[]\", u+'\\u1234\\u5678')\n        assert len(y) == 3\n        assert list(y) == [u+'\\u1234', u+'\\u5678', u+'\\x00']\n        assert ffi.string(y) == u+'\\u1234\\u5678'\n        z = ffi.new(\"char16_t[]\", u+'\\U00012345')\n        assert len(z) == 3\n        assert list(z) == [u+'\\ud808', u+'\\udf45', u+'\\x00']\n        assert ffi.string(z) == u+'\\U00012345'\n\n    def test_char32_t(self):\n        ffi = FFI()\n        x = ffi.new(\"char32_t[]\", 5)\n        assert len(x) == 5 and ffi.sizeof(x) == 20\n        x[3] = u+'\\U00013245'\n        assert x[3] == u+'\\U00013245'\n        y = ffi.new(\"char32_t[]\", u+'\\u1234\\u5678')\n        assert len(y) == 3\n        assert list(y) == [u+'\\u1234', u+'\\u5678', u+'\\x00']\n        py_uni = u+'\\U00012345'\n        z = ffi.new(\"char32_t[]\", py_uni)\n        assert len(z) == 2\n        assert list(z) == [py_uni, u+'\\x00']    # maybe a 2-unichars string\n        assert ffi.string(z) == py_uni\n        if len(py_uni) == 1:    # 4-bytes unicodes in Python\n            s = ffi.new(\"char32_t[]\", u+'\\ud808\\udf00')\n            assert len(s) == 3\n            assert list(s) == [u+'\\ud808', u+'\\udf00', u+'\\x00']\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.13.0-jlicqgsrlask3n7tsdckxmdwv6d5zp4o/spack-src/testing/cffi0/test_ownlib.py": "import py, sys, os\nimport subprocess, weakref\nfrom cffi import FFI\nfrom cffi.backend_ctypes import CTypesBackend\nfrom testing.support import u\n\n\nSOURCE = \"\"\"\\\n#include <errno.h>\n\n#ifdef _WIN32\n#define EXPORT __declspec(dllexport)\n#else\n#define EXPORT\n#endif\n\nEXPORT int test_getting_errno(void) {\n    errno = 123;\n    return -1;\n}\n\nEXPORT int test_setting_errno(void) {\n    return errno;\n};\n\ntypedef struct {\n    long x;\n    long y;\n} POINT;\n\ntypedef struct {\n    long left;\n    long top;\n    long right;\n    long bottom;\n} RECT;\n\n\nEXPORT int PointInRect(RECT *prc, POINT pt)\n{\n    if (pt.x < prc->left)\n        return 0;\n    if (pt.x > prc->right)\n        return 0;\n    if (pt.y < prc->top)\n        return 0;\n    if (pt.y > prc->bottom)\n        return 0;\n    return 1;\n};\n\nEXPORT long left = 10;\nEXPORT long top = 20;\nEXPORT long right = 30;\nEXPORT long bottom = 40;\n\nEXPORT RECT ReturnRect(int i, RECT ar, RECT* br, POINT cp, RECT dr,\n                        RECT *er, POINT fp, RECT gr)\n{\n    /*Check input */\n    if (ar.left + br->left + dr.left + er->left + gr.left != left * 5)\n    {\n        ar.left = 100;\n        return ar;\n    }\n    if (ar.right + br->right + dr.right + er->right + gr.right != right * 5)\n    {\n        ar.right = 100;\n        return ar;\n    }\n    if (cp.x != fp.x)\n    {\n        ar.left = -100;\n    }\n    if (cp.y != fp.y)\n    {\n        ar.left = -200;\n    }\n    switch(i)\n    {\n    case 0:\n        return ar;\n        break;\n    case 1:\n        return dr;\n        break;\n    case 2:\n        return gr;\n        break;\n\n    }\n    return ar;\n}\n\nEXPORT int my_array[7] = {0, 1, 2, 3, 4, 5, 6};\n\nEXPORT unsigned short foo_2bytes(unsigned short a)\n{\n    return (unsigned short)(a + 42);\n}\nEXPORT unsigned int foo_4bytes(unsigned int a)\n{\n    return (unsigned int)(a + 42);\n}\n\nEXPORT void modify_struct_value(RECT r)\n{\n    r.left = r.right = r.top = r.bottom = 500;\n}\n\"\"\"\n\nclass TestOwnLib(object):\n    Backend = CTypesBackend\n\n    def setup_class(cls):\n        cls.module = None\n        from testing.udir import udir\n        udir.join('testownlib.c').write(SOURCE)\n        if sys.platform == 'win32':\n            # did we already build it?\n            if cls.Backend is CTypesBackend:\n                dll_path = str(udir) + '\\\\testownlib1.dll'   # only ascii for the ctypes backend\n            else:\n                dll_path = str(udir) + '\\\\' + (u+'testownlib\\u03be.dll')   # non-ascii char\n            if os.path.exists(dll_path):\n                cls.module = dll_path\n                return\n            # try (not too hard) to find the version used to compile this python\n            # no mingw\n            from distutils.msvc9compiler import get_build_version\n            version = get_build_version()\n            toolskey = \"VS%0.f0COMNTOOLS\" % version\n            toolsdir = os.environ.get(toolskey, None)\n            if toolsdir is None:\n                return\n            productdir = os.path.join(toolsdir, os.pardir, os.pardir, \"VC\")\n            productdir = os.path.abspath(productdir)\n            vcvarsall = os.path.join(productdir, \"vcvarsall.bat\")\n            # 64?\n            arch = 'x86'\n            if sys.maxsize > 2**32:\n                arch = 'amd64'\n            if os.path.isfile(vcvarsall):\n                cmd = '\"%s\" %s' % (vcvarsall, arch) + ' & cl.exe testownlib.c ' \\\n                        ' /LD /Fetestownlib.dll'\n                subprocess.check_call(cmd, cwd = str(udir), shell=True)\n                os.rename(str(udir) + '\\\\testownlib.dll', dll_path)\n                cls.module = dll_path\n        else:\n            encoded = None\n            if cls.Backend is not CTypesBackend:\n                try:\n                    unicode_name = u+'testownlibcaf\\xe9'\n                    encoded = unicode_name.encode(sys.getfilesystemencoding())\n                    if sys.version_info >= (3,):\n                        encoded = str(unicode_name)\n                except UnicodeEncodeError:\n                    pass\n            if encoded is None:\n                unicode_name = u+'testownlib'\n                encoded = str(unicode_name)\n            subprocess.check_call(\n                \"cc testownlib.c -shared -fPIC -o '%s.so'\" % (encoded,),\n                cwd=str(udir), shell=True)\n            cls.module = os.path.join(str(udir), unicode_name + (u+'.so'))\n        print(repr(cls.module))\n\n    def test_getting_errno(self):\n        if self.module is None:\n            py.test.skip(\"fix the auto-generation of the tiny test lib\")\n        if sys.platform == 'win32':\n            py.test.skip(\"fails, errno at multiple addresses\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            int test_getting_errno(void);\n        \"\"\")\n        ownlib = ffi.dlopen(self.module)\n        res = ownlib.test_getting_errno()\n        assert res == -1\n        assert ffi.errno == 123\n\n    def test_setting_errno(self):\n        if self.module is None:\n            py.test.skip(\"fix the auto-generation of the tiny test lib\")\n        if sys.platform == 'win32':\n            py.test.skip(\"fails, errno at multiple addresses\")\n        if self.Backend is CTypesBackend and '__pypy__' in sys.modules:\n            py.test.skip(\"XXX errno issue with ctypes on pypy?\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            int test_setting_errno(void);\n        \"\"\")\n        ownlib = ffi.dlopen(self.module)\n        ffi.errno = 42\n        res = ownlib.test_setting_errno()\n        assert res == 42\n        assert ffi.errno == 42\n\n    def test_my_array_7(self):\n        if self.module is None:\n            py.test.skip(\"fix the auto-generation of the tiny test lib\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            int my_array[7];\n        \"\"\")\n        ownlib = ffi.dlopen(self.module)\n        for i in range(7):\n            assert ownlib.my_array[i] == i\n        assert len(ownlib.my_array) == 7\n        if self.Backend is CTypesBackend:\n            py.test.skip(\"not supported by the ctypes backend\")\n        ownlib.my_array = list(range(10, 17))\n        for i in range(7):\n            assert ownlib.my_array[i] == 10 + i\n        ownlib.my_array = list(range(7))\n        for i in range(7):\n            assert ownlib.my_array[i] == i\n\n    def test_my_array_no_length(self):\n        if self.module is None:\n            py.test.skip(\"fix the auto-generation of the tiny test lib\")\n        if self.Backend is CTypesBackend:\n            py.test.skip(\"not supported by the ctypes backend\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            int my_array[];\n        \"\"\")\n        ownlib = ffi.dlopen(self.module)\n        for i in range(7):\n            assert ownlib.my_array[i] == i\n        py.test.raises(TypeError, len, ownlib.my_array)\n        ownlib.my_array = list(range(10, 17))\n        for i in range(7):\n            assert ownlib.my_array[i] == 10 + i\n        ownlib.my_array = list(range(7))\n        for i in range(7):\n            assert ownlib.my_array[i] == i\n\n    def test_keepalive_lib(self):\n        if self.module is None:\n            py.test.skip(\"fix the auto-generation of the tiny test lib\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            int test_getting_errno(void);\n        \"\"\")\n        ownlib = ffi.dlopen(self.module)\n        ffi_r = weakref.ref(ffi)\n        ownlib_r = weakref.ref(ownlib)\n        func = ownlib.test_getting_errno\n        del ffi\n        import gc; gc.collect()       # ownlib stays alive\n        assert ownlib_r() is not None\n        assert ffi_r() is not None    # kept alive by ownlib\n        res = func()\n        assert res == -1\n\n    def test_keepalive_ffi(self):\n        if self.module is None:\n            py.test.skip(\"fix the auto-generation of the tiny test lib\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            int test_getting_errno(void);\n        \"\"\")\n        ownlib = ffi.dlopen(self.module)\n        ffi_r = weakref.ref(ffi)\n        ownlib_r = weakref.ref(ownlib)\n        func = ownlib.test_getting_errno\n        del ownlib\n        import gc; gc.collect()       # ffi stays alive\n        assert ffi_r() is not None\n        assert ownlib_r() is not None # kept alive by ffi\n        res = func()\n        assert res == -1\n        if sys.platform != 'win32':  # else, errno at multiple addresses\n            assert ffi.errno == 123\n\n    def test_struct_by_value(self):\n        if self.module is None:\n            py.test.skip(\"fix the auto-generation of the tiny test lib\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            typedef struct {\n                long x;\n                long y;\n            } POINT;\n\n            typedef struct {\n                long left;\n                long top;\n                long right;\n                long bottom;\n            } RECT;\n            \n            long left, top, right, bottom;\n\n            RECT ReturnRect(int i, RECT ar, RECT* br, POINT cp, RECT dr,\n                        RECT *er, POINT fp, RECT gr);\n        \"\"\")\n        ownlib = ffi.dlopen(self.module)\n\n        rect = ffi.new('RECT[1]')\n        pt = ffi.new('POINT[1]')\n        pt[0].x = 15\n        pt[0].y = 25\n        rect[0].left = ownlib.left\n        rect[0].right = ownlib.right\n        rect[0].top = ownlib.top\n        rect[0].bottom = ownlib.bottom\n        \n        for i in range(4):\n            ret = ownlib.ReturnRect(i, rect[0], rect, pt[0], rect[0],\n                                    rect, pt[0], rect[0])\n            assert ret.left == ownlib.left\n            assert ret.right == ownlib.right\n            assert ret.top == ownlib.top\n            assert ret.bottom == ownlib.bottom\n\n    def test_addressof_lib(self):\n        if self.module is None:\n            py.test.skip(\"fix the auto-generation of the tiny test lib\")\n        if self.Backend is CTypesBackend:\n            py.test.skip(\"not implemented with the ctypes backend\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"long left; int test_getting_errno(void);\")\n        lib = ffi.dlopen(self.module)\n        lib.left = 123456\n        p = ffi.addressof(lib, \"left\")\n        assert ffi.typeof(p) == ffi.typeof(\"long *\")\n        assert p[0] == 123456\n        p[0] += 1\n        assert lib.left == 123457\n        pfn = ffi.addressof(lib, \"test_getting_errno\")\n        assert ffi.typeof(pfn) == ffi.typeof(\"int(*)(void)\")\n        assert pfn == lib.test_getting_errno\n\n    def test_char16_char32_t(self):\n        if self.module is None:\n            py.test.skip(\"fix the auto-generation of the tiny test lib\")\n        if self.Backend is CTypesBackend:\n            py.test.skip(\"not implemented with the ctypes backend\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            char16_t foo_2bytes(char16_t);\n            char32_t foo_4bytes(char32_t);\n        \"\"\")\n        lib = ffi.dlopen(self.module)\n        assert lib.foo_2bytes(u+'\\u1234') == u+'\\u125e'\n        assert lib.foo_4bytes(u+'\\u1234') == u+'\\u125e'\n        assert lib.foo_4bytes(u+'\\U00012345') == u+'\\U0001236f'\n\n    def test_modify_struct_value(self):\n        if self.module is None:\n            py.test.skip(\"fix the auto-generation of the tiny test lib\")\n        if self.Backend is CTypesBackend:\n            py.test.skip(\"fails with the ctypes backend on some architectures\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            typedef struct {\n                long left;\n                long top;\n                long right;\n                long bottom;\n            } RECT;\n\n            void modify_struct_value(RECT r);\n        \"\"\")\n        lib = ffi.dlopen(self.module)\n        s = ffi.new(\"RECT *\", [11, 22, 33, 44])\n        lib.modify_struct_value(s[0])\n        assert s.left == 11\n        assert s.top == 22\n        assert s.right == 33\n        assert s.bottom == 44\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.13.0-jlicqgsrlask3n7tsdckxmdwv6d5zp4o/spack-src/testing/cffi0/test_verify.py": "import py, re\nimport pytest\nimport sys, os, math, weakref\nfrom cffi import FFI, VerificationError, VerificationMissing, model, FFIError\nfrom testing.support import *\n\n\nlib_m = ['m']\nif sys.platform == 'win32':\n    #there is a small chance this fails on Mingw via environ $CC\n    import distutils.ccompiler\n    if distutils.ccompiler.get_default_compiler() == 'msvc':\n        lib_m = ['msvcrt']\n    pass      # no obvious -Werror equivalent on MSVC\nelse:\n    if (sys.platform == 'darwin' and\n          [int(x) for x in os.uname()[2].split('.')] >= [11, 0, 0]):\n        # assume a standard clang or gcc\n        extra_compile_args = ['-Werror', '-Wall', '-Wextra', '-Wconversion']\n        # special things for clang\n        extra_compile_args.append('-Qunused-arguments')\n    else:\n        # assume a standard gcc\n        extra_compile_args = ['-Werror', '-Wall', '-Wextra', '-Wconversion',\n                              '-Wno-unused-parameter']\n\n    class FFI(FFI):\n        def verify(self, *args, **kwds):\n            return super(FFI, self).verify(\n                *args, extra_compile_args=extra_compile_args, **kwds)\n\ndef setup_module():\n    import cffi.verifier\n    cffi.verifier.cleanup_tmpdir()\n    #\n    # check that no $ sign is produced in the C file; it used to be the\n    # case that anonymous enums would produce '$enum_$1', which was\n    # used as part of a function name.  GCC accepts such names, but it's\n    # apparently non-standard.\n    _r_comment = re.compile(r\"/\\*.*?\\*/|//.*?$\", re.DOTALL | re.MULTILINE)\n    _r_string = re.compile(r'\\\".*?\\\"')\n    def _write_source_and_check(self, file=None):\n        base_write_source(self, file)\n        if file is None:\n            f = open(self.sourcefilename)\n            data = f.read()\n            f.close()\n            data = _r_comment.sub(' ', data)\n            data = _r_string.sub('\"skipped\"', data)\n            assert '$' not in data\n    base_write_source = cffi.verifier.Verifier._write_source\n    cffi.verifier.Verifier._write_source = _write_source_and_check\n\n\ndef test_module_type():\n    import cffi.verifier\n    ffi = FFI()\n    lib = ffi.verify()\n    if hasattr(lib, '_cffi_python_module'):\n        print('verify got a PYTHON module')\n    if hasattr(lib, '_cffi_generic_module'):\n        print('verify got a GENERIC module')\n    expected_generic = (cffi.verifier._FORCE_GENERIC_ENGINE or\n                        '__pypy__' in sys.builtin_module_names)\n    assert hasattr(lib, '_cffi_python_module') == (not expected_generic)\n    assert hasattr(lib, '_cffi_generic_module') == expected_generic\n\ndef test_missing_function(ffi=None):\n    # uses the FFI hacked above with '-Werror'\n    if ffi is None:\n        ffi = FFI()\n    ffi.cdef(\"void some_completely_unknown_function();\")\n    try:\n        lib = ffi.verify()\n    except (VerificationError, OSError):\n        pass     # expected case: we get a VerificationError\n    else:\n        # but depending on compiler and loader details, maybe\n        # 'lib' could actually be imported but will fail if we\n        # actually try to call the unknown function...  Hard\n        # to test anything more.\n        pass\n\ndef test_missing_function_import_error():\n    # uses the original FFI that just gives a warning during compilation\n    import cffi\n    test_missing_function(ffi=cffi.FFI())\n\ndef test_simple_case():\n    ffi = FFI()\n    ffi.cdef(\"double sin(double x);\")\n    lib = ffi.verify('#include <math.h>', libraries=lib_m)\n    assert lib.sin(1.23) == math.sin(1.23)\n\ndef _Wconversion(cdef, source, **kargs):\n    if sys.platform in ('win32', 'darwin'):\n        py.test.skip(\"needs GCC\")\n    ffi = FFI()\n    ffi.cdef(cdef)\n    py.test.raises(VerificationError, ffi.verify, source, **kargs)\n    extra_compile_args_orig = extra_compile_args[:]\n    extra_compile_args.remove('-Wconversion')\n    try:\n        lib = ffi.verify(source, **kargs)\n    finally:\n        extra_compile_args[:] = extra_compile_args_orig\n    return lib\n\ndef test_Wconversion_unsigned():\n    _Wconversion(\"unsigned foo(void);\",\n                 \"int foo(void) { return -1;}\")\n\ndef test_Wconversion_integer():\n    _Wconversion(\"short foo(void);\",\n                 \"long long foo(void) { return 1<<sizeof(short);}\")\n\ndef test_Wconversion_floating():\n    lib = _Wconversion(\"float sin(double);\",\n                       \"#include <math.h>\", libraries=lib_m)\n    res = lib.sin(1.23)\n    assert res != math.sin(1.23)     # not exact, because of double->float\n    assert abs(res - math.sin(1.23)) < 1E-5\n\ndef test_Wconversion_float2int():\n    _Wconversion(\"int sinf(float);\",\n                 \"#include <math.h>\", libraries=lib_m)\n\ndef test_Wconversion_double2int():\n    _Wconversion(\"int sin(double);\",\n                 \"#include <math.h>\", libraries=lib_m)\n\ndef test_rounding_1():\n    ffi = FFI()\n    ffi.cdef(\"double sinf(float x);\")\n    lib = ffi.verify('#include <math.h>', libraries=lib_m)\n    res = lib.sinf(1.23)\n    assert res != math.sin(1.23)     # not exact, because of double->float\n    assert abs(res - math.sin(1.23)) < 1E-5\n\ndef test_rounding_2():\n    ffi = FFI()\n    ffi.cdef(\"double sin(float x);\")\n    lib = ffi.verify('#include <math.h>', libraries=lib_m)\n    res = lib.sin(1.23)\n    assert res != math.sin(1.23)     # not exact, because of double->float\n    assert abs(res - math.sin(1.23)) < 1E-5\n\ndef test_strlen_exact():\n    ffi = FFI()\n    ffi.cdef(\"size_t strlen(const char *s);\")\n    lib = ffi.verify(\"#include <string.h>\")\n    assert lib.strlen(b\"hi there!\") == 9\n\ndef test_strlen_approximate():\n    lib = _Wconversion(\"int strlen(char *s);\",\n                       \"#include <string.h>\")\n    assert lib.strlen(b\"hi there!\") == 9\n\ndef test_return_approximate():\n    for typename in ['short', 'int', 'long', 'long long']:\n        ffi = FFI()\n        ffi.cdef(\"%s foo(signed char x);\" % typename)\n        lib = ffi.verify(\"signed char foo(signed char x) { return x;}\")\n        assert lib.foo(-128) == -128\n        assert lib.foo(+127) == +127\n\ndef test_strlen_array_of_char():\n    ffi = FFI()\n    ffi.cdef(\"size_t strlen(char[]);\")\n    lib = ffi.verify(\"#include <string.h>\")\n    assert lib.strlen(b\"hello\") == 5\n\ndef test_longdouble():\n    ffi = FFI()\n    ffi.cdef(\"long double sinl(long double x);\")\n    lib = ffi.verify('#include <math.h>', libraries=lib_m)\n    for input in [1.23,\n                  ffi.cast(\"double\", 1.23),\n                  ffi.cast(\"long double\", 1.23)]:\n        x = lib.sinl(input)\n        assert repr(x).startswith(\"<cdata 'long double'\")\n        assert (float(x) - math.sin(1.23)) < 1E-10\n\ndef test_longdouble_precision():\n    # Test that we don't loose any precision of 'long double' when\n    # passing through Python and CFFI.\n    ffi = FFI()\n    ffi.cdef(\"long double step1(long double x);\")\n    SAME_SIZE = ffi.sizeof(\"long double\") == ffi.sizeof(\"double\")\n    lib = ffi.verify(\"\"\"\n        long double step1(long double x)\n        {\n            return 4*x-x*x;\n        }\n    \"\"\")\n    def do(cast_to_double):\n        x = 0.9789\n        for i in range(10000):\n            x = lib.step1(x)\n            if cast_to_double:\n                x = float(x)\n        return float(x)\n\n    more_precise = do(False)\n    less_precise = do(True)\n    if SAME_SIZE:\n        assert more_precise == less_precise\n    else:\n        assert abs(more_precise - less_precise) > 0.1\n        # Check the particular results on Intel\n        import platform\n        if (platform.machine().startswith('i386') or\n            platform.machine().startswith('i486') or\n            platform.machine().startswith('i586') or\n            platform.machine().startswith('i686') or\n            platform.machine().startswith('x86')):\n            assert abs(more_precise - 0.656769) < 0.001\n            assert abs(less_precise - 3.99091) < 0.001\n        else:\n            py.test.skip(\"don't know the very exact precision of 'long double'\")\n\n\nall_primitive_types = model.PrimitiveType.ALL_PRIMITIVE_TYPES\nif sys.platform == 'win32':\n    all_primitive_types = all_primitive_types.copy()\n    del all_primitive_types['ssize_t']\nall_integer_types = sorted(tp for tp in all_primitive_types\n                           if all_primitive_types[tp] == 'i')\nall_float_types = sorted(tp for tp in all_primitive_types\n                            if all_primitive_types[tp] == 'f')\n\ndef all_signed_integer_types(ffi):\n    return [x for x in all_integer_types if int(ffi.cast(x, -1)) < 0]\n\ndef all_unsigned_integer_types(ffi):\n    return [x for x in all_integer_types if int(ffi.cast(x, -1)) > 0]\n\n\ndef test_primitive_category():\n    for typename in all_primitive_types:\n        tp = model.PrimitiveType(typename)\n        C = tp.is_char_type()\n        F = tp.is_float_type()\n        X = tp.is_complex_type()\n        I = tp.is_integer_type()\n        assert C == (typename in ('char', 'wchar_t', 'char16_t', 'char32_t'))\n        assert F == (typename in ('float', 'double', 'long double'))\n        assert X == (typename in ('float _Complex', 'double _Complex'))\n        assert I + F + C + X == 1      # one and only one of them is true\n\ndef test_all_integer_and_float_types():\n    typenames = []\n    for typename in all_primitive_types:\n        if (all_primitive_types[typename] == 'c' or\n            all_primitive_types[typename] == 'j' or    # complex\n            typename == '_Bool' or typename == 'long double'):\n            pass\n        else:\n            typenames.append(typename)\n    #\n    ffi = FFI()\n    ffi.cdef('\\n'.join([\"%s foo_%s(%s);\" % (tp, tp.replace(' ', '_'), tp)\n                       for tp in typenames]))\n    lib = ffi.verify('\\n'.join([\"%s foo_%s(%s x) { return (%s)(x+1); }\" %\n                                (tp, tp.replace(' ', '_'), tp, tp)\n                                for tp in typenames]))\n    for typename in typenames:\n        foo = getattr(lib, 'foo_%s' % typename.replace(' ', '_'))\n        assert foo(42) == 43\n        if sys.version < '3':\n            assert foo(long(44)) == 45\n        assert foo(ffi.cast(typename, 46)) == 47\n        py.test.raises(TypeError, foo, ffi.NULL)\n        #\n        # check for overflow cases\n        if all_primitive_types[typename] == 'f':\n            continue\n        for value in [-2**80, -2**40, -2**20, -2**10, -2**5, -1,\n                      2**5, 2**10, 2**20, 2**40, 2**80]:\n            overflows = int(ffi.cast(typename, value)) != value\n            if overflows:\n                py.test.raises(OverflowError, foo, value)\n            else:\n                assert foo(value) == value + 1\n\ndef test_var_signed_integer_types():\n    ffi = FFI()\n    lst = all_signed_integer_types(ffi)\n    csource = \"\\n\".join([\"%s somevar_%s;\" % (tp, tp.replace(' ', '_'))\n                         for tp in lst])\n    ffi.cdef(csource)\n    lib = ffi.verify(csource)\n    for tp in lst:\n        varname = 'somevar_%s' % tp.replace(' ', '_')\n        sz = ffi.sizeof(tp)\n        max = (1 << (8*sz-1)) - 1\n        min = -(1 << (8*sz-1))\n        setattr(lib, varname, max)\n        assert getattr(lib, varname) == max\n        setattr(lib, varname, min)\n        assert getattr(lib, varname) == min\n        py.test.raises(OverflowError, setattr, lib, varname, max+1)\n        py.test.raises(OverflowError, setattr, lib, varname, min-1)\n\ndef test_var_unsigned_integer_types():\n    ffi = FFI()\n    lst = all_unsigned_integer_types(ffi)\n    csource = \"\\n\".join([\"%s somevar_%s;\" % (tp, tp.replace(' ', '_'))\n                         for tp in lst])\n    ffi.cdef(csource)\n    lib = ffi.verify(csource)\n    for tp in lst:\n        varname = 'somevar_%s' % tp.replace(' ', '_')\n        sz = ffi.sizeof(tp)\n        if tp != '_Bool':\n            max = (1 << (8*sz)) - 1\n        else:\n            max = 1\n        setattr(lib, varname, max)\n        assert getattr(lib, varname) == max\n        setattr(lib, varname, 0)\n        assert getattr(lib, varname) == 0\n        py.test.raises(OverflowError, setattr, lib, varname, max+1)\n        py.test.raises(OverflowError, setattr, lib, varname, -1)\n\ndef test_fn_signed_integer_types():\n    ffi = FFI()\n    lst = all_signed_integer_types(ffi)\n    cdefsrc = \"\\n\".join([\"%s somefn_%s(%s);\" % (tp, tp.replace(' ', '_'), tp)\n                         for tp in lst])\n    ffi.cdef(cdefsrc)\n    verifysrc = \"\\n\".join([\"%s somefn_%s(%s x) { return x; }\" %\n                           (tp, tp.replace(' ', '_'), tp) for tp in lst])\n    lib = ffi.verify(verifysrc)\n    for tp in lst:\n        fnname = 'somefn_%s' % tp.replace(' ', '_')\n        sz = ffi.sizeof(tp)\n        max = (1 << (8*sz-1)) - 1\n        min = -(1 << (8*sz-1))\n        fn = getattr(lib, fnname)\n        assert fn(max) == max\n        assert fn(min) == min\n        py.test.raises(OverflowError, fn, max + 1)\n        py.test.raises(OverflowError, fn, min - 1)\n\ndef test_fn_unsigned_integer_types():\n    ffi = FFI()\n    lst = all_unsigned_integer_types(ffi)\n    cdefsrc = \"\\n\".join([\"%s somefn_%s(%s);\" % (tp, tp.replace(' ', '_'), tp)\n                         for tp in lst])\n    ffi.cdef(cdefsrc)\n    verifysrc = \"\\n\".join([\"%s somefn_%s(%s x) { return x; }\" %\n                           (tp, tp.replace(' ', '_'), tp) for tp in lst])\n    lib = ffi.verify(verifysrc)\n    for tp in lst:\n        fnname = 'somefn_%s' % tp.replace(' ', '_')\n        sz = ffi.sizeof(tp)\n        if tp != '_Bool':\n            max = (1 << (8*sz)) - 1\n        else:\n            max = 1\n        fn = getattr(lib, fnname)\n        assert fn(max) == max\n        assert fn(0) == 0\n        py.test.raises(OverflowError, fn, max + 1)\n        py.test.raises(OverflowError, fn, -1)\n\ndef test_char_type():\n    ffi = FFI()\n    ffi.cdef(\"char foo(char);\")\n    lib = ffi.verify(\"char foo(char x) { return ++x; }\")\n    assert lib.foo(b\"A\") == b\"B\"\n    py.test.raises(TypeError, lib.foo, b\"bar\")\n    py.test.raises(TypeError, lib.foo, \"bar\")\n\ndef test_wchar_type():\n    ffi = FFI()\n    if ffi.sizeof('wchar_t') == 2:\n        uniexample1 = u+'\\u1234'\n        uniexample2 = u+'\\u1235'\n    else:\n        uniexample1 = u+'\\U00012345'\n        uniexample2 = u+'\\U00012346'\n    #\n    ffi.cdef(\"wchar_t foo(wchar_t);\")\n    lib = ffi.verify(\"wchar_t foo(wchar_t x) { return x+1; }\")\n    assert lib.foo(uniexample1) == uniexample2\n\ndef test_char16_char32_type():\n    py.test.skip(\"XXX test or fully prevent char16_t and char32_t from \"\n                 \"working in ffi.verify() mode\")\n\ndef test_no_argument():\n    ffi = FFI()\n    ffi.cdef(\"int foo(void);\")\n    lib = ffi.verify(\"int foo(void) { return 42; }\")\n    assert lib.foo() == 42\n\ndef test_two_arguments():\n    ffi = FFI()\n    ffi.cdef(\"int foo(int, int);\")\n    lib = ffi.verify(\"int foo(int a, int b) { return a - b; }\")\n    assert lib.foo(40, -2) == 42\n\ndef test_macro():\n    ffi = FFI()\n    ffi.cdef(\"int foo(int, int);\")\n    lib = ffi.verify(\"#define foo(a, b) ((a) * (b))\")\n    assert lib.foo(-6, -7) == 42\n\ndef test_ptr():\n    ffi = FFI()\n    ffi.cdef(\"int *foo(int *);\")\n    lib = ffi.verify(\"int *foo(int *a) { return a; }\")\n    assert lib.foo(ffi.NULL) == ffi.NULL\n    p = ffi.new(\"int *\", 42)\n    q = ffi.new(\"int *\", 42)\n    assert lib.foo(p) == p\n    assert lib.foo(q) != p\n\ndef test_bogus_ptr():\n    ffi = FFI()\n    ffi.cdef(\"int *foo(int *);\")\n    lib = ffi.verify(\"int *foo(int *a) { return a; }\")\n    py.test.raises(TypeError, lib.foo, ffi.new(\"short *\", 42))\n\n\ndef test_verify_typedefs():\n    py.test.skip(\"ignored so far\")\n    types = ['signed char', 'unsigned char', 'int', 'long']\n    for cdefed in types:\n        for real in types:\n            ffi = FFI()\n            ffi.cdef(\"typedef %s foo_t;\" % cdefed)\n            if cdefed == real:\n                ffi.verify(\"typedef %s foo_t;\" % real)\n            else:\n                py.test.raises(VerificationError, ffi.verify,\n                               \"typedef %s foo_t;\" % real)\n\ndef test_nondecl_struct():\n    ffi = FFI()\n    ffi.cdef(\"typedef struct foo_s foo_t; int bar(foo_t *);\")\n    lib = ffi.verify(\"typedef struct foo_s foo_t;\\n\"\n                     \"int bar(foo_t *f) { (void)f; return 42; }\\n\")\n    assert lib.bar(ffi.NULL) == 42\n\ndef test_ffi_full_struct():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { char x; int y; long *z; };\")\n    ffi.verify(\"struct foo_s { char x; int y; long *z; };\")\n    #\n    if sys.platform != 'win32':  # XXX fixme: only gives warnings\n        py.test.raises(VerificationError, ffi.verify,\n            \"struct foo_s { char x; int y; int *z; };\")\n    #\n    py.test.raises(VerificationError, ffi.verify,\n        \"struct foo_s { int y; long *z; };\")\n    #\n    e = py.test.raises(VerificationError, ffi.verify,\n        \"struct foo_s { int y; char x; long *z; };\")\n    assert str(e.value) == (\n        \"struct foo_s: wrong offset for field 'x'\"\n        \" (we have 0, but C compiler says 4)\")\n    #\n    e = py.test.raises(VerificationError, ffi.verify,\n        \"struct foo_s { char x; int y; long *z; char extra; };\")\n    assert str(e.value) == (\n        \"struct foo_s: wrong total size\"\n        \" (we have %d, but C compiler says %d)\" % (\n            ffi.sizeof(\"struct foo_s\"),\n            ffi.sizeof(\"struct foo_s\") + ffi.sizeof(\"long*\")))\n    #\n    # a corner case that we cannot really detect, but where it has no\n    # bad consequences: the size is the same, but there is an extra field\n    # that replaces what is just padding in our declaration above\n    ffi.verify(\"struct foo_s { char x, extra; int y; long *z; };\")\n    #\n    e = py.test.raises(VerificationError, ffi.verify,\n        \"struct foo_s { char x; short pad; short y; long *z; };\")\n    assert str(e.value) == (\n        \"struct foo_s: wrong size for field 'y'\"\n        \" (we have 4, but C compiler says 2)\")\n\ndef test_ffi_nonfull_struct():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n    struct foo_s {\n       int x;\n       ...;\n    };\n    \"\"\")\n    py.test.raises(VerificationMissing, ffi.sizeof, 'struct foo_s')\n    py.test.raises(VerificationMissing, ffi.offsetof, 'struct foo_s', 'x')\n    py.test.raises(VerificationMissing, ffi.new, 'struct foo_s *')\n    ffi.verify(\"\"\"\n    struct foo_s {\n       int a, b, x, c, d, e;\n    };\n    \"\"\")\n    assert ffi.sizeof('struct foo_s') == 6 * ffi.sizeof('int')\n    assert ffi.offsetof('struct foo_s', 'x') == 2 * ffi.sizeof('int')\n\ndef test_ffi_nonfull_alignment():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { char x; ...; };\")\n    ffi.verify(\"struct foo_s { int a, b; char x; };\")\n    assert ffi.sizeof('struct foo_s') == 3 * ffi.sizeof('int')\n    assert ffi.alignof('struct foo_s') == ffi.sizeof('int')\n\ndef _check_field_match(typename, real, expect_mismatch):\n    ffi = FFI()\n    testing_by_size = (expect_mismatch == 'by_size')\n    if testing_by_size:\n        expect_mismatch = ffi.sizeof(typename) != ffi.sizeof(real)\n    ffi.cdef(\"struct foo_s { %s x; ...; };\" % typename)\n    try:\n        ffi.verify(\"struct foo_s { %s x; };\" % real)\n    except VerificationError:\n        if not expect_mismatch:\n            if testing_by_size and typename != real:\n                print(\"ignoring mismatch between %s* and %s* even though \"\n                      \"they have the same size\" % (typename, real))\n                return\n            raise AssertionError(\"unexpected mismatch: %s should be accepted \"\n                                 \"as equal to %s\" % (typename, real))\n    else:\n        if expect_mismatch:\n            raise AssertionError(\"mismatch not detected: \"\n                                 \"%s != %s\" % (typename, real))\n\ndef test_struct_bad_sized_integer():\n    for typename in ['int8_t', 'int16_t', 'int32_t', 'int64_t']:\n        for real in ['int8_t', 'int16_t', 'int32_t', 'int64_t']:\n            _check_field_match(typename, real, \"by_size\")\n\ndef test_struct_bad_sized_float():\n    for typename in all_float_types:\n        for real in all_float_types:\n            _check_field_match(typename, real, \"by_size\")\n\ndef test_struct_signedness_ignored():\n    _check_field_match(\"int\", \"unsigned int\", expect_mismatch=False)\n    _check_field_match(\"unsigned short\", \"signed short\", expect_mismatch=False)\n\ndef test_struct_float_vs_int():\n    if sys.platform == 'win32':\n        py.test.skip(\"XXX fixme: only gives warnings\")\n    ffi = FFI()\n    for typename in all_signed_integer_types(ffi):\n        for real in all_float_types:\n            _check_field_match(typename, real, expect_mismatch=True)\n    for typename in all_float_types:\n        for real in all_signed_integer_types(ffi):\n            _check_field_match(typename, real, expect_mismatch=True)\n\ndef test_struct_array_field():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int a[17]; ...; };\")\n    ffi.verify(\"struct foo_s { int x; int a[17]; int y; };\")\n    assert ffi.sizeof('struct foo_s') == 19 * ffi.sizeof('int')\n    s = ffi.new(\"struct foo_s *\")\n    assert ffi.sizeof(s.a) == 17 * ffi.sizeof('int')\n\ndef test_struct_array_no_length():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int a[]; int y; ...; };\\n\"\n             \"int bar(struct foo_s *);\\n\")\n    lib = ffi.verify(\"struct foo_s { int x; int a[17]; int y; };\\n\"\n                     \"int bar(struct foo_s *f) { return f->a[14]; }\\n\")\n    assert ffi.sizeof('struct foo_s') == 19 * ffi.sizeof('int')\n    s = ffi.new(\"struct foo_s *\")\n    assert ffi.typeof(s.a) is ffi.typeof('int[]')   # implicit max length\n    assert len(s.a) == 18  # max length, computed from the size and start offset\n    s.a[14] = 4242\n    assert lib.bar(s) == 4242\n    # with no declared length, out-of-bound accesses are not detected\n    s.a[17] = -521\n    assert s.y == s.a[17] == -521\n    #\n    s = ffi.new(\"struct foo_s *\", {'a': list(range(17))})\n    assert s.a[16] == 16\n    # overflows at construction time not detected either\n    s = ffi.new(\"struct foo_s *\", {'a': list(range(18))})\n    assert s.y == s.a[17] == 17\n\ndef test_struct_array_guess_length():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int a[...]; };\")\n    ffi.verify(\"struct foo_s { int x; int a[17]; int y; };\")\n    assert ffi.sizeof('struct foo_s') == 19 * ffi.sizeof('int')\n    s = ffi.new(\"struct foo_s *\")\n    assert ffi.sizeof(s.a) == 17 * ffi.sizeof('int')\n    with pytest.raises(IndexError):\n        s.a[17]\n\ndef test_struct_array_c99_1():\n    if sys.platform == 'win32':\n        py.test.skip(\"requires C99\")\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int x; int a[]; };\")\n    ffi.verify(\"struct foo_s { int x; int a[]; };\")\n    assert ffi.sizeof('struct foo_s') == 1 * ffi.sizeof('int')\n    s = ffi.new(\"struct foo_s *\", [424242, 4])\n    assert ffi.sizeof(ffi.typeof(s[0])) == 1 * ffi.sizeof('int')\n    assert ffi.sizeof(s[0]) == 5 * ffi.sizeof('int')\n    # ^^^ explanation: if you write in C: \"char x[5];\", then\n    # \"sizeof(x)\" will evaluate to 5.  The behavior above is\n    # a generalization of that to \"struct foo_s[len(a)=5] x;\"\n    # if you could do that in C.\n    assert s.a[3] == 0\n    s = ffi.new(\"struct foo_s *\", [424242, [-40, -30, -20, -10]])\n    assert ffi.sizeof(s[0]) == 5 * ffi.sizeof('int')\n    assert s.a[3] == -10\n    s = ffi.new(\"struct foo_s *\")\n    assert ffi.sizeof(s[0]) == 1 * ffi.sizeof('int')\n    s = ffi.new(\"struct foo_s *\", [424242])\n    assert ffi.sizeof(s[0]) == 1 * ffi.sizeof('int')\n\ndef test_struct_array_c99_2():\n    if sys.platform == 'win32':\n        py.test.skip(\"requires C99\")\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int x; int a[]; ...; };\")\n    ffi.verify(\"struct foo_s { int x, y; int a[]; };\")\n    assert ffi.sizeof('struct foo_s') == 2 * ffi.sizeof('int')\n    s = ffi.new(\"struct foo_s *\", [424242, 4])\n    assert ffi.sizeof(s[0]) == 6 * ffi.sizeof('int')\n    assert s.a[3] == 0\n    s = ffi.new(\"struct foo_s *\", [424242, [-40, -30, -20, -10]])\n    assert ffi.sizeof(s[0]) == 6 * ffi.sizeof('int')\n    assert s.a[3] == -10\n    s = ffi.new(\"struct foo_s *\")\n    assert ffi.sizeof(s[0]) == 2 * ffi.sizeof('int')\n    s = ffi.new(\"struct foo_s *\", [424242])\n    assert ffi.sizeof(s[0]) == 2 * ffi.sizeof('int')\n\ndef test_struct_ptr_to_array_field():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int (*a)[17]; ...; }; struct bar_s { ...; };\")\n    ffi.verify(\"struct foo_s { int x; int (*a)[17]; int y; };\\n\"\n               \"struct bar_s { int x; int *a; int y; };\")\n    assert ffi.sizeof('struct foo_s') == ffi.sizeof(\"struct bar_s\")\n    s = ffi.new(\"struct foo_s *\")\n    assert ffi.sizeof(s.a) == ffi.sizeof('int(*)[17]') == ffi.sizeof(\"int *\")\n\ndef test_struct_with_bitfield_exact():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int a:2, b:3; };\")\n    ffi.verify(\"struct foo_s { int a:2, b:3; };\")\n    s = ffi.new(\"struct foo_s *\")\n    s.b = 3\n    with pytest.raises(OverflowError):\n        s.b = 4\n    assert s.b == 3\n\ndef test_struct_with_bitfield_enum():\n    ffi = FFI()\n    code = \"\"\"\n        typedef enum { AA, BB, CC } foo_e;\n        typedef struct { foo_e f:2; } foo_s;\n    \"\"\"\n    ffi.cdef(code)\n    ffi.verify(code)\n    s = ffi.new(\"foo_s *\")\n    s.f = 2\n    assert s.f == 2\n\ndef test_unsupported_struct_with_bitfield_ellipsis():\n    ffi = FFI()\n    py.test.raises(NotImplementedError, ffi.cdef,\n                   \"struct foo_s { int a:2, b:3; ...; };\")\n\ndef test_global_constants():\n    ffi = FFI()\n    # use 'static const int', as generally documented, although in this\n    # case the 'static' is completely ignored.\n    ffi.cdef(\"static const int AA, BB, CC, DD;\")\n    lib = ffi.verify(\"#define AA 42\\n\"\n                     \"#define BB (-43)   // blah\\n\"\n                     \"#define CC (22*2)  /* foobar */\\n\"\n                     \"#define DD ((unsigned int)142)  /* foo\\nbar */\\n\")\n    assert lib.AA == 42\n    assert lib.BB == -43\n    assert lib.CC == 44\n    assert lib.DD == 142\n\ndef test_global_const_int_size():\n    # integer constants: ignore the declared type, always just use the value\n    for value in [-2**63, -2**31, -2**15,\n                  2**15-1, 2**15, 2**31-1, 2**31, 2**32-1, 2**32,\n                  2**63-1, 2**63, 2**64-1]:\n        ffi = FFI()\n        if value == int(ffi.cast(\"long long\", value)):\n            if value < 0:\n                vstr = '(-%dLL-1)' % (~value,)\n            else:\n                vstr = '%dLL' % value\n        elif value == int(ffi.cast(\"unsigned long long\", value)):\n            vstr = '%dULL' % value\n        else:\n            raise AssertionError(value)\n        ffi.cdef(\"static const unsigned short AA;\")\n        lib = ffi.verify(\"#define AA %s\\n\" % vstr)\n        assert lib.AA == value\n        assert type(lib.AA) is type(int(lib.AA))\n\ndef test_global_constants_non_int():\n    ffi = FFI()\n    ffi.cdef(\"static char *const PP;\")\n    lib = ffi.verify('static char *const PP = \"testing!\";\\n')\n    assert ffi.typeof(lib.PP) == ffi.typeof(\"char *\")\n    assert ffi.string(lib.PP) == b\"testing!\"\n\ndef test_nonfull_enum():\n    ffi = FFI()\n    ffi.cdef(\"enum ee { EE1, EE2, EE3, ... \\n \\t };\")\n    py.test.raises(VerificationMissing, ffi.cast, 'enum ee', 'EE2')\n    ffi.verify(\"enum ee { EE1=10, EE2, EE3=-10, EE4 };\")\n    assert ffi.string(ffi.cast('enum ee', 11)) == \"EE2\"\n    assert ffi.string(ffi.cast('enum ee', -10)) == \"EE3\"\n    #\n    # try again\n    ffi.verify(\"enum ee { EE1=10, EE2, EE3=-10, EE4 };\")\n    assert ffi.string(ffi.cast('enum ee', 11)) == \"EE2\"\n    #\n    assert ffi.typeof(\"enum ee\").relements == {'EE1': 10, 'EE2': 11, 'EE3': -10}\n    assert ffi.typeof(\"enum ee\").elements == {10: 'EE1', 11: 'EE2', -10: 'EE3'}\n\ndef test_full_enum():\n    ffi = FFI()\n    ffi.cdef(\"enum ee { EE1, EE2, EE3 };\")\n    ffi.verify(\"enum ee { EE1, EE2, EE3 };\")\n    py.test.raises(VerificationError, ffi.verify, \"enum ee { EE1, EE2 };\")\n    e = py.test.raises(VerificationError, ffi.verify,\n                       \"enum ee { EE1, EE3, EE2 };\")\n    assert str(e.value) == 'enum ee: EE2 has the real value 2, not 1'\n    # extra items cannot be seen and have no bad consequence anyway\n    lib = ffi.verify(\"enum ee { EE1, EE2, EE3, EE4 };\")\n    assert lib.EE3 == 2\n\ndef test_enum_usage():\n    ffi = FFI()\n    ffi.cdef(\"enum ee { EE1,EE2 }; typedef struct { enum ee x; } *sp;\")\n    lib = ffi.verify(\"enum ee { EE1,EE2 }; typedef struct { enum ee x; } *sp;\")\n    assert lib.EE2 == 1\n    s = ffi.new(\"sp\", [lib.EE2])\n    assert s.x == 1\n    s.x = 17\n    assert s.x == 17\n\ndef test_anonymous_enum():\n    ffi = FFI()\n    ffi.cdef(\"enum { EE1 }; enum { EE2, EE3 };\")\n    lib = ffi.verify(\"enum { EE1 }; enum { EE2, EE3 };\")\n    assert lib.EE1 == 0\n    assert lib.EE2 == 0\n    assert lib.EE3 == 1\n\ndef test_nonfull_anonymous_enum():\n    ffi = FFI()\n    ffi.cdef(\"enum { EE1, ... }; enum { EE3, ... };\")\n    lib = ffi.verify(\"enum { EE2, EE1 }; enum { EE3 };\")\n    assert lib.EE1 == 1\n    assert lib.EE3 == 0\n\ndef test_nonfull_enum_syntax2():\n    ffi = FFI()\n    ffi.cdef(\"enum ee { EE1, EE2=\\t..., EE3 };\")\n    py.test.raises(VerificationMissing, ffi.cast, 'enum ee', 'EE1')\n    ffi.verify(\"enum ee { EE1=10, EE2, EE3=-10, EE4 };\")\n    assert ffi.string(ffi.cast('enum ee', 11)) == 'EE2'\n    assert ffi.string(ffi.cast('enum ee', -10)) == 'EE3'\n    #\n    ffi = FFI()\n    ffi.cdef(\"enum ee { EE1, EE2=\\t... };\")\n    py.test.raises(VerificationMissing, ffi.cast, 'enum ee', 'EE1')\n    ffi.verify(\"enum ee { EE1=10, EE2, EE3=-10, EE4 };\")\n    assert ffi.string(ffi.cast('enum ee', 11)) == 'EE2'\n    #\n    ffi = FFI()\n    ffi.cdef(\"enum ee2 { EE4=..., EE5=..., ... };\")\n    ffi.verify(\"enum ee2 { EE4=-1234-5, EE5 }; \")\n    assert ffi.string(ffi.cast('enum ee2', -1239)) == 'EE4'\n    assert ffi.string(ffi.cast('enum ee2', -1238)) == 'EE5'\n\ndef test_nonfull_enum_bug3():\n    ffi = FFI()\n    ffi.cdef(\"enum ee2 { EE4=..., EE5=... };\")\n    ffi.cdef(\"enum ee6 { EE7=10, EE8=..., EE9=... };\")\n\ndef test_get_set_errno():\n    ffi = FFI()\n    ffi.cdef(\"int foo(int);\")\n    lib = ffi.verify(\"\"\"\n        static int foo(int x)\n        {\n            errno += 1;\n            return x * 7;\n        }\n    \"\"\")\n    ffi.errno = 15\n    assert lib.foo(6) == 42\n    assert ffi.errno == 16\n\ndef test_define_int():\n    ffi = FFI()\n    ffi.cdef(\"#define FOO ...\\n\"\n             \"\\t#\\tdefine\\tBAR\\t...\\t\\n\"\n             \"#define BAZ ...\\n\")\n    lib = ffi.verify(\"#define FOO 42\\n\"\n                     \"#define BAR (-44)\\n\"\n                     \"#define BAZ 0xffffffffffffffffULL\\n\")\n    assert lib.FOO == 42\n    assert lib.BAR == -44\n    assert lib.BAZ == 0xffffffffffffffff\n\ndef test_access_variable():\n    ffi = FFI()\n    ffi.cdef(\"int foo(void);\\n\"\n             \"int somenumber;\")\n    lib = ffi.verify(\"\"\"\n        static int somenumber = 2;\n        static int foo(void) {\n            return somenumber * 7;\n        }\n    \"\"\")\n    assert lib.somenumber == 2\n    assert lib.foo() == 14\n    lib.somenumber = -6\n    assert lib.foo() == -42\n    assert lib.somenumber == -6\n    lib.somenumber = 2   # reset for the next run, if any\n\ndef test_access_address_of_variable():\n    # access the address of 'somenumber': need a trick\n    ffi = FFI()\n    ffi.cdef(\"int somenumber; static int *const somenumberptr;\")\n    lib = ffi.verify(\"\"\"\n        static int somenumber = 2;\n        #define somenumberptr (&somenumber)\n    \"\"\")\n    assert lib.somenumber == 2\n    lib.somenumberptr[0] = 42\n    assert lib.somenumber == 42\n    lib.somenumber = 2    # reset for the next run, if any\n\ndef test_access_array_variable(length=5):\n    ffi = FFI()\n    ffi.cdef(\"int foo(int);\\n\"\n             \"int somenumber[%s];\" % (length,))\n    lib = ffi.verify(\"\"\"\n        static int somenumber[] = {2, 2, 3, 4, 5};\n        static int foo(int i) {\n            return somenumber[i] * 7;\n        }\n    \"\"\")\n    if length == '':\n        # a global variable of an unknown array length is implicitly\n        # transformed into a global pointer variable, because we can only\n        # work with array instances whose length we know.  using a pointer\n        # instead of an array gives the correct effects.\n        assert repr(lib.somenumber).startswith(\"<cdata 'int *' 0x\")\n        py.test.raises(TypeError, len, lib.somenumber)\n    else:\n        assert repr(lib.somenumber).startswith(\"<cdata 'int[%s]' 0x\" % length)\n        assert len(lib.somenumber) == 5\n    assert lib.somenumber[3] == 4\n    assert lib.foo(3) == 28\n    lib.somenumber[3] = -6\n    assert lib.foo(3) == -42\n    assert lib.somenumber[3] == -6\n    assert lib.somenumber[4] == 5\n    lib.somenumber[3] = 4    # reset for the next run, if any\n\ndef test_access_array_variable_length_hidden():\n    test_access_array_variable(length='')\n\ndef test_access_struct_variable():\n    ffi = FFI()\n    ffi.cdef(\"struct foo { int x; ...; };\\n\"\n             \"int foo(int);\\n\"\n             \"struct foo stuff;\")\n    lib = ffi.verify(\"\"\"\n        struct foo { int x, y, z; };\n        static struct foo stuff = {2, 5, 8};\n        static int foo(int i) {\n            switch (i) {\n            case 0: return stuff.x * 7;\n            case 1: return stuff.y * 7;\n            case 2: return stuff.z * 7;\n            }\n            return -1;\n        }\n    \"\"\")\n    assert lib.stuff.x == 2\n    assert lib.foo(0) == 14\n    assert lib.foo(1) == 35\n    assert lib.foo(2) == 56\n    lib.stuff.x = -6\n    assert lib.foo(0) == -42\n    assert lib.foo(1) == 35\n    lib.stuff.x = 2      # reset for the next run, if any\n\ndef test_access_callback():\n    ffi = FFI()\n    ffi.cdef(\"int (*cb)(int);\\n\"\n             \"int foo(int);\\n\"\n             \"void reset_cb(void);\")\n    lib = ffi.verify(\"\"\"\n        static int g(int x) { return x * 7; }\n        static int (*cb)(int);\n        static int foo(int i) { return cb(i) - 1; }\n        static void reset_cb(void) { cb = g; }\n    \"\"\")\n    lib.reset_cb()\n    assert lib.foo(6) == 41\n    my_callback = ffi.callback(\"int(*)(int)\", lambda n: n * 222)\n    lib.cb = my_callback\n    assert lib.foo(4) == 887\n\ndef test_access_callback_function_typedef():\n    ffi = FFI()\n    ffi.cdef(\"typedef int mycallback_t(int);\\n\"\n             \"mycallback_t *cb;\\n\"\n             \"int foo(int);\\n\"\n             \"void reset_cb(void);\")\n    lib = ffi.verify(\"\"\"\n        static int g(int x) { return x * 7; }\n        static int (*cb)(int);\n        static int foo(int i) { return cb(i) - 1; }\n        static void reset_cb(void) { cb = g; }\n    \"\"\")\n    lib.reset_cb()\n    assert lib.foo(6) == 41\n    my_callback = ffi.callback(\"int(*)(int)\", lambda n: n * 222)\n    lib.cb = my_callback\n    assert lib.foo(4) == 887\n\ndef test_ctypes_backend_forces_generic_engine():\n    from cffi.backend_ctypes import CTypesBackend\n    ffi = FFI(backend=CTypesBackend())\n    ffi.cdef(\"int func(int a);\")\n    lib = ffi.verify(\"int func(int a) { return a * 42; }\")\n    assert not hasattr(lib, '_cffi_python_module')\n    assert hasattr(lib, '_cffi_generic_module')\n    assert lib.func(100) == 4200\n\ndef test_call_with_struct_ptr():\n    ffi = FFI()\n    ffi.cdef(\"typedef struct { int x; ...; } foo_t; int foo(foo_t *);\")\n    lib = ffi.verify(\"\"\"\n        typedef struct { int y, x; } foo_t;\n        static int foo(foo_t *f) { return f->x * 7; }\n    \"\"\")\n    f = ffi.new(\"foo_t *\")\n    f.x = 6\n    assert lib.foo(f) == 42\n\ndef test_unknown_type():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef ... token_t;\n        int foo(token_t *);\n        #define TOKEN_SIZE ...\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        typedef float token_t;\n        static int foo(token_t *tk) {\n            if (!tk)\n                return -42;\n            *tk += 1.601f;\n            return (int)*tk;\n        }\n        #define TOKEN_SIZE sizeof(token_t)\n    \"\"\")\n    # we cannot let ffi.new(\"token_t *\") work, because we don't know ahead of\n    # time if it's ok to ask 'sizeof(token_t)' in the C code or not.\n    # See test_unknown_type_2.  Workaround.\n    tkmem = ffi.new(\"char[]\", lib.TOKEN_SIZE)    # zero-initialized\n    tk = ffi.cast(\"token_t *\", tkmem)\n    results = [lib.foo(tk) for i in range(6)]\n    assert results == [1, 3, 4, 6, 8, 9]\n    assert lib.foo(ffi.NULL) == -42\n\ndef test_unknown_type_2():\n    ffi = FFI()\n    ffi.cdef(\"typedef ... token_t;\")\n    lib = ffi.verify(\"typedef struct token_s token_t;\")\n    # assert did not crash, even though 'sizeof(token_t)' is not valid in C.\n\ndef test_unknown_type_3():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef ... *token_p;\n        token_p foo(token_p);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        typedef struct _token_s *token_p;\n        token_p foo(token_p arg) {\n            if (arg)\n                return (token_p)0x12347;\n            else\n                return (token_p)0x12345;\n        }\n    \"\"\")\n    p = lib.foo(ffi.NULL)\n    assert int(ffi.cast(\"intptr_t\", p)) == 0x12345\n    q = lib.foo(p)\n    assert int(ffi.cast(\"intptr_t\", q)) == 0x12347\n\ndef test_varargs():\n    ffi = FFI()\n    ffi.cdef(\"int foo(int x, ...);\")\n    lib = ffi.verify(\"\"\"\n        int foo(int x, ...) {\n            va_list vargs;\n            va_start(vargs, x);\n            x -= va_arg(vargs, int);\n            x -= va_arg(vargs, int);\n            va_end(vargs);\n            return x;\n        }\n    \"\"\")\n    assert lib.foo(50, ffi.cast(\"int\", 5), ffi.cast(\"int\", 3)) == 42\n\ndef test_varargs_exact():\n    if sys.platform == 'win32':\n        py.test.skip(\"XXX fixme: only gives warnings\")\n    ffi = FFI()\n    ffi.cdef(\"int foo(int x, ...);\")\n    py.test.raises(VerificationError, ffi.verify, \"\"\"\n        int foo(long long x, ...) {\n            return x;\n        }\n    \"\"\")\n\ndef test_varargs_struct():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { char a; int b; }; int foo(int x, ...);\")\n    lib = ffi.verify(\"\"\"\n        struct foo_s {\n            char a; int b;\n        };\n        int foo(int x, ...) {\n            va_list vargs;\n            struct foo_s s;\n            va_start(vargs, x);\n            s = va_arg(vargs, struct foo_s);\n            va_end(vargs);\n            return s.a - s.b;\n        }\n    \"\"\")\n    s = ffi.new(\"struct foo_s *\", [b'B', 1])\n    assert lib.foo(50, s[0]) == ord('A')\n\ndef test_autofilled_struct_as_argument():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { long a; double b; ...; };\\n\"\n             \"int foo(struct foo_s);\")\n    lib = ffi.verify(\"\"\"\n        struct foo_s {\n            double b;\n            long a;\n        };\n        int foo(struct foo_s s) {\n            return (int)s.a - (int)s.b;\n        }\n    \"\"\")\n    s = ffi.new(\"struct foo_s *\", [100, 1])\n    assert lib.foo(s[0]) == 99\n    assert lib.foo([100, 1]) == 99\n\ndef test_autofilled_struct_as_argument_dynamic():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { long a; ...; };\\n\"\n             \"int (*foo)(struct foo_s);\")\n    lib = ffi.verify(\"\"\"\n        struct foo_s {\n            double b;\n            long a;\n        };\n        int foo1(struct foo_s s) {\n            return (int)s.a - (int)s.b;\n        }\n        int (*foo)(struct foo_s s) = &foo1;\n    \"\"\")\n    e = py.test.raises(NotImplementedError, lib.foo, \"?\")\n    msg = (\"ctype 'struct foo_s' not supported as argument.  It is a struct \"\n           'declared with \"...;\", but the C calling convention may depend on '\n           \"the missing fields; or, it contains anonymous struct/unions.  \"\n           \"Such structs are only supported as argument \"\n           \"if the function is 'API mode' and non-variadic (i.e. declared \"\n           \"inside ffibuilder.cdef()+ffibuilder.set_source() and not taking \"\n           \"a final '...' argument)\")\n    assert str(e.value) == msg\n\ndef test_func_returns_struct():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        struct foo_s { int aa, bb; };\n        struct foo_s foo(int a, int b);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        struct foo_s { int aa, bb; };\n        struct foo_s foo(int a, int b) {\n            struct foo_s r;\n            r.aa = a*a;\n            r.bb = b*b;\n            return r;\n        }\n    \"\"\")\n    s = lib.foo(6, 7)\n    assert repr(s) == \"<cdata 'struct foo_s' owning 8 bytes>\"\n    assert s.aa == 36\n    assert s.bb == 49\n\ndef test_func_as_funcptr():\n    ffi = FFI()\n    ffi.cdef(\"int *(*const fooptr)(void);\")\n    lib = ffi.verify(\"\"\"\n        int *foo(void) {\n            return (int*)\"foobar\";\n        }\n        int *(*fooptr)(void) = foo;\n    \"\"\")\n    foochar = ffi.cast(\"char *(*)(void)\", lib.fooptr)\n    s = foochar()\n    assert ffi.string(s) == b\"foobar\"\n\ndef test_funcptr_as_argument():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        void qsort(void *base, size_t nel, size_t width,\n            int (*compar)(const void *, const void *));\n    \"\"\")\n    ffi.verify(\"#include <stdlib.h>\")\n\ndef test_func_as_argument():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        void qsort(void *base, size_t nel, size_t width,\n            int compar(const void *, const void *));\n    \"\"\")\n    ffi.verify(\"#include <stdlib.h>\")\n\ndef test_array_as_argument():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        size_t strlen(char string[]);\n    \"\"\")\n    ffi.verify(\"#include <string.h>\")\n\ndef test_enum_as_argument():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        enum foo_e { AA, BB, ... };\n        int foo_func(enum foo_e);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        enum foo_e { AA, CC, BB };\n        int foo_func(enum foo_e e) { return (int)e; }\n    \"\"\")\n    assert lib.foo_func(lib.BB) == 2\n    py.test.raises(TypeError, lib.foo_func, \"BB\")\n\ndef test_enum_as_function_result():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        enum foo_e { AA, BB, ... };\n        enum foo_e foo_func(int x);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        enum foo_e { AA, CC, BB };\n        enum foo_e foo_func(int x) { return (enum foo_e)x; }\n    \"\"\")\n    assert lib.foo_func(lib.BB) == lib.BB == 2\n\ndef test_enum_values():\n    ffi = FFI()\n    ffi.cdef(\"enum enum1_e { AA, BB };\")\n    lib = ffi.verify(\"enum enum1_e { AA, BB };\")\n    assert lib.AA == 0\n    assert lib.BB == 1\n    assert ffi.string(ffi.cast(\"enum enum1_e\", 1)) == 'BB'\n\ndef test_typedef_complete_enum():\n    ffi = FFI()\n    ffi.cdef(\"typedef enum { AA, BB } enum1_t;\")\n    lib = ffi.verify(\"typedef enum { AA, BB } enum1_t;\")\n    assert ffi.string(ffi.cast(\"enum1_t\", 1)) == 'BB'\n    assert lib.AA == 0\n    assert lib.BB == 1\n\ndef test_typedef_broken_complete_enum():\n    ffi = FFI()\n    ffi.cdef(\"typedef enum { AA, BB } enum1_t;\")\n    py.test.raises(VerificationError, ffi.verify,\n                   \"typedef enum { AA, CC, BB } enum1_t;\")\n\ndef test_typedef_incomplete_enum():\n    ffi = FFI()\n    ffi.cdef(\"typedef enum { AA, BB, ... } enum1_t;\")\n    lib = ffi.verify(\"typedef enum { AA, CC, BB } enum1_t;\")\n    assert ffi.string(ffi.cast(\"enum1_t\", 1)) == '1'\n    assert ffi.string(ffi.cast(\"enum1_t\", 2)) == 'BB'\n    assert lib.AA == 0\n    assert lib.BB == 2\n\ndef test_typedef_enum_as_argument():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef enum { AA, BB, ... } foo_t;\n        int foo_func(foo_t);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        typedef enum { AA, CC, BB } foo_t;\n        int foo_func(foo_t e) { return (int)e; }\n    \"\"\")\n    assert lib.foo_func(lib.BB) == lib.BB == 2\n    py.test.raises(TypeError, lib.foo_func, \"BB\")\n\ndef test_typedef_enum_as_function_result():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef enum { AA, BB, ... } foo_t;\n        foo_t foo_func(int x);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        typedef enum { AA, CC, BB } foo_t;\n        foo_t foo_func(int x) { return (foo_t)x; }\n    \"\"\")\n    assert lib.foo_func(lib.BB) == lib.BB == 2\n\ndef test_function_typedef():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef double func_t(double);\n        func_t sin;\n    \"\"\")\n    lib = ffi.verify('#include <math.h>', libraries=lib_m)\n    assert lib.sin(1.23) == math.sin(1.23)\n\ndef test_opaque_integer_as_function_result():\n    #import platform\n    #if platform.machine().startswith('sparc'):\n    #    py.test.skip('Breaks horribly on sparc (SIGILL + corrupted stack)')\n    #elif platform.machine() == 'mips64' and sys.maxsize > 2**32:\n    #    py.test.skip('Segfaults on mips64el')\n    # XXX bad abuse of \"struct { ...; }\".  It only works a bit by chance\n    # anyway.  XXX think about something better :-(\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef struct { ...; } myhandle_t;\n        myhandle_t foo(void);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        typedef short myhandle_t;\n        myhandle_t foo(void) { return 42; }\n    \"\"\")\n    h = lib.foo()\n    assert ffi.sizeof(h) == ffi.sizeof(\"short\")\n\ndef test_return_partial_struct():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef struct { int x; ...; } foo_t;\n        foo_t foo(void);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        typedef struct { int y, x; } foo_t;\n        foo_t foo(void) { foo_t r = { 45, 81 }; return r; }\n    \"\"\")\n    h = lib.foo()\n    assert ffi.sizeof(h) == 2 * ffi.sizeof(\"int\")\n    assert h.x == 81\n\ndef test_take_and_return_partial_structs():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef struct { int x; ...; } foo_t;\n        foo_t foo(foo_t, foo_t);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        typedef struct { int y, x; } foo_t;\n        foo_t foo(foo_t a, foo_t b) {\n            foo_t r = { 100, a.x * 5 + b.x * 7 };\n            return r;\n        }\n    \"\"\")\n    args = ffi.new(\"foo_t[3]\")\n    args[0].x = 1000\n    args[2].x = -498\n    h = lib.foo(args[0], args[2])\n    assert ffi.sizeof(h) == 2 * ffi.sizeof(\"int\")\n    assert h.x == 1000 * 5 - 498 * 7\n\ndef test_cannot_name_struct_type():\n    ffi = FFI()\n    ffi.cdef(\"typedef struct { int x; } **sp; void foo(sp);\")\n    e = py.test.raises(VerificationError, ffi.verify,\n                       \"typedef struct { int x; } **sp; void foo(sp x) { }\")\n    assert 'in argument of foo: unknown type name' in str(e.value)\n\ndef test_dont_check_unnamable_fields():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { struct { int x; } someone; };\")\n    ffi.verify(\"struct foo_s { struct { int x; } someone; };\")\n    # assert did not crash\n\ndef test_nested_anonymous_struct_exact():\n    if sys.platform == 'win32':\n        py.test.skip(\"nested anonymous struct/union\")\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        struct foo_s { struct { int a; char b; }; union { char c, d; }; };\n    \"\"\")\n    ffi.verify(\"\"\"\n        struct foo_s { struct { int a; char b; }; union { char c, d; }; };\n    \"\"\")\n    p = ffi.new(\"struct foo_s *\")\n    assert ffi.sizeof(p[0]) == 3 * ffi.sizeof(\"int\")    # with alignment\n    p.a = 1234567\n    p.b = b'X'\n    p.c = b'Y'\n    assert p.a == 1234567\n    assert p.b == b'X'\n    assert p.c == b'Y'\n    assert p.d == b'Y'\n\ndef test_nested_anonymous_struct_exact_error():\n    if sys.platform == 'win32':\n        py.test.skip(\"nested anonymous struct/union\")\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        struct foo_s { struct { int a; char b; }; union { char c, d; }; };\n    \"\"\")\n    py.test.raises(VerificationError, ffi.verify, \"\"\"\n        struct foo_s { struct { int a; short b; }; union { char c, d; }; };\n    \"\"\")\n    py.test.raises(VerificationError, ffi.verify, \"\"\"\n        struct foo_s { struct { int a; char e, b; }; union { char c, d; }; };\n    \"\"\")\n\ndef test_nested_anonymous_struct_inexact_1():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        struct foo_s { struct { char b; ...; }; union { char c, d; }; };\n    \"\"\")\n    ffi.verify(\"\"\"\n        struct foo_s { int a, padding; char c, d, b; };\n    \"\"\")\n    assert ffi.sizeof(\"struct foo_s\") == 3 * ffi.sizeof(\"int\")\n\ndef test_nested_anonymous_struct_inexact_2():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        struct foo_s { union { char c, d; }; struct { int a; char b; }; ...; };\n    \"\"\")\n    ffi.verify(\"\"\"\n        struct foo_s { int a, padding; char c, d, b; };\n    \"\"\")\n    assert ffi.sizeof(\"struct foo_s\") == 3 * ffi.sizeof(\"int\")\n\ndef test_ffi_union():\n    ffi = FFI()\n    ffi.cdef(\"union foo_u { char x; long *z; };\")\n    ffi.verify(\"union foo_u { char x; int y; long *z; };\")\n\ndef test_ffi_union_partial():\n    ffi = FFI()\n    ffi.cdef(\"union foo_u { char x; ...; };\")\n    ffi.verify(\"union foo_u { char x; int y; };\")\n    assert ffi.sizeof(\"union foo_u\") == 4\n\ndef test_ffi_union_with_partial_struct():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int x; ...; }; union foo_u { struct foo_s s; };\")\n    ffi.verify(\"struct foo_s { int a; int x; }; \"\n               \"union foo_u { char b[32]; struct foo_s s; };\")\n    assert ffi.sizeof(\"struct foo_s\") == 8\n    assert ffi.sizeof(\"union foo_u\") == 32\n\ndef test_ffi_union_partial_2():\n    ffi = FFI()\n    ffi.cdef(\"typedef union { char x; ...; } u1;\")\n    ffi.verify(\"typedef union { char x; int y; } u1;\")\n    assert ffi.sizeof(\"u1\") == 4\n\ndef test_ffi_union_with_partial_struct_2():\n    ffi = FFI()\n    ffi.cdef(\"typedef struct { int x; ...; } s1;\"\n             \"typedef union { s1 s; } u1;\")\n    ffi.verify(\"typedef struct { int a; int x; } s1; \"\n               \"typedef union { char b[32]; s1 s; } u1;\")\n    assert ffi.sizeof(\"s1\") == 8\n    assert ffi.sizeof(\"u1\") == 32\n    assert ffi.offsetof(\"u1\", \"s\") == 0\n\ndef test_ffi_struct_packed():\n    if sys.platform == 'win32':\n        py.test.skip(\"needs a GCC extension\")\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int b; ...; };\")\n    ffi.verify(\"\"\"\n        struct foo_s {\n            char a;\n            int b;\n        } __attribute__((packed));\n    \"\"\")\n\ndef test_tmpdir():\n    import tempfile, os\n    from testing.udir import udir\n    tmpdir = tempfile.mkdtemp(dir=str(udir))\n    ffi = FFI()\n    ffi.cdef(\"int foo(int);\")\n    lib = ffi.verify(\"int foo(int a) { return a + 42; }\", tmpdir=tmpdir)\n    assert os.listdir(tmpdir)\n    assert lib.foo(100) == 142\n\ndef test_relative_to():\n    import tempfile, os\n    from testing.udir import udir\n    tmpdir = tempfile.mkdtemp(dir=str(udir))\n    ffi = FFI()\n    ffi.cdef(\"int foo(int);\")\n    f = open(os.path.join(tmpdir, 'foo.h'), 'w')\n    f.write(\"int foo(int a) { return a + 42; }\\n\")\n    f.close()\n    lib = ffi.verify('#include \"foo.h\"',\n                     include_dirs=['.'],\n                     relative_to=os.path.join(tmpdir, 'x'))\n    assert lib.foo(100) == 142\n\ndef test_bug1():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef struct tdlhandle_s { ...; } *tdl_handle_t;\n        typedef struct my_error_code_ {\n            tdl_handle_t *rh;\n        } my_error_code_t;\n    \"\"\")\n    ffi.verify(\"\"\"\n        typedef struct tdlhandle_s { int foo; } *tdl_handle_t;\n        typedef struct my_error_code_ {\n            tdl_handle_t *rh;\n        } my_error_code_t;\n    \"\"\")\n\ndef test_bool():\n    if sys.platform == 'win32':\n        py.test.skip(\"_Bool not in MSVC\")\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { _Bool x; };\"\n             \"_Bool foo(_Bool); _Bool (*foop)(_Bool);\")\n    lib = ffi.verify(\"\"\"\n        struct foo_s { _Bool x; };\n        int foo(int arg) {\n            return !arg;\n        }\n        _Bool _foofunc(_Bool x) {\n            return !x;\n        }\n        _Bool (*foop)(_Bool) = _foofunc;\n    \"\"\")\n    p = ffi.new(\"struct foo_s *\")\n    p.x = 1\n    assert p.x is True\n    with pytest.raises(OverflowError):\n        p.x = -1\n    with pytest.raises(TypeError):\n        p.x = 0.0\n    assert lib.foop(1) is False\n    assert lib.foop(True) is False\n    assert lib.foop(0) is True\n    py.test.raises(OverflowError, lib.foop, 42)\n    py.test.raises(TypeError, lib.foop, 0.0)\n    assert lib.foo(1) is False\n    assert lib.foo(True) is False\n    assert lib.foo(0) is True\n    py.test.raises(OverflowError, lib.foo, 42)\n    py.test.raises(TypeError, lib.foo, 0.0)\n    assert int(ffi.cast(\"_Bool\", long(1))) == 1\n    assert int(ffi.cast(\"_Bool\", long(0))) == 0\n    assert int(ffi.cast(\"_Bool\", long(-1))) == 1\n    assert int(ffi.cast(\"_Bool\", 10**200)) == 1\n    assert int(ffi.cast(\"_Bool\", 10**40000)) == 1\n    #\n    class Foo(object):\n        def __int__(self):\n            self.seen = 1\n            return result\n    f = Foo()\n    f.seen = 0\n    result = 42\n    assert int(ffi.cast(\"_Bool\", f)) == 1\n    assert f.seen\n    f.seen = 0\n    result = 0\n    assert int(ffi.cast(\"_Bool\", f)) == 0\n    assert f.seen\n    #\n    py.test.raises(TypeError, ffi.cast, \"_Bool\", [])\n\ndef test_bool_on_long_double():\n    if sys.platform == 'win32':\n        py.test.skip(\"_Bool not in MSVC\")\n    f = 1E-250\n    if f == 0.0 or f*f != 0.0:\n        py.test.skip(\"unexpected precision\")\n    ffi = FFI()\n    ffi.cdef(\"long double square(long double f); _Bool opposite(_Bool);\")\n    lib = ffi.verify(\"long double square(long double f) { return f*f; }\\n\"\n                     \"_Bool opposite(_Bool x) { return !x; }\")\n    f0 = lib.square(0.0)\n    f2 = lib.square(f)\n    f3 = lib.square(f * 2.0)\n    if repr(f2) == repr(f3):\n        py.test.skip(\"long double doesn't have enough precision\")\n    assert float(f0) == float(f2) == float(f3) == 0.0  # too tiny for 'double'\n    assert int(ffi.cast(\"_Bool\", f2)) == 1\n    assert int(ffi.cast(\"_Bool\", f3)) == 1\n    assert int(ffi.cast(\"_Bool\", f0)) == 0\n    py.test.raises(TypeError, lib.opposite, f2)\n\ndef test_cannot_pass_float():\n    for basetype in ['char', 'short', 'int', 'long', 'long long']:\n        for sign in ['signed', 'unsigned']:\n            type = '%s %s' % (sign, basetype)\n            ffi = FFI()\n            ffi.cdef(\"struct foo_s { %s x; };\\n\"\n                     \"int foo(%s);\" % (type, type))\n            lib = ffi.verify(\"\"\"\n                struct foo_s { %s x; };\n                int foo(%s arg) {\n                    return !arg;\n                }\n            \"\"\" % (type, type))\n            p = ffi.new(\"struct foo_s *\")\n            with pytest.raises(TypeError):\n                p.x = 0.0\n            assert lib.foo(42) == 0\n            assert lib.foo(0) == 1\n            py.test.raises(TypeError, lib.foo, 0.0)\n\ndef test_cast_from_int_type_to_bool():\n    ffi = FFI()\n    for basetype in ['char', 'short', 'int', 'long', 'long long']:\n        for sign in ['signed', 'unsigned']:\n            type = '%s %s' % (sign, basetype)\n            assert int(ffi.cast(\"_Bool\", ffi.cast(type, 42))) == 1\n            assert int(ffi.cast(\"bool\", ffi.cast(type, 42))) == 1\n            assert int(ffi.cast(\"_Bool\", ffi.cast(type, 0))) == 0\n\ndef test_addressof():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        struct point_s { int x, y; };\n        struct foo_s { int z; struct point_s point; };\n        struct point_s sum_coord(struct point_s *);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        struct point_s { int x, y; };\n        struct foo_s { int z; struct point_s point; };\n        struct point_s sum_coord(struct point_s *point) {\n            struct point_s r;\n            r.x = point->x + point->y;\n            r.y = point->x - point->y;\n            return r;\n        }\n    \"\"\")\n    p = ffi.new(\"struct foo_s *\")\n    p.point.x = 16\n    p.point.y = 9\n    py.test.raises(TypeError, lib.sum_coord, p.point)\n    res = lib.sum_coord(ffi.addressof(p.point))\n    assert res.x == 25\n    assert res.y == 7\n    res2 = lib.sum_coord(ffi.addressof(res))\n    assert res2.x == 32\n    assert res2.y == 18\n    py.test.raises(TypeError, lib.sum_coord, res2)\n\ndef test_callback_in_thread():\n    if sys.platform == 'win32':\n        py.test.skip(\"pthread only\")\n    import os, subprocess, imp\n    arg = os.path.join(os.path.dirname(__file__), 'callback_in_thread.py')\n    g = subprocess.Popen([sys.executable, arg,\n                          os.path.dirname(imp.find_module('cffi')[1])])\n    result = g.wait()\n    assert result == 0\n\ndef test_keepalive_lib():\n    ffi = FFI()\n    ffi.cdef(\"int foobar(void);\")\n    lib = ffi.verify(\"int foobar(void) { return 42; }\")\n    func = lib.foobar\n    ffi_r = weakref.ref(ffi)\n    lib_r = weakref.ref(lib)\n    del ffi\n    import gc; gc.collect()       # lib stays alive\n    assert lib_r() is not None\n    assert ffi_r() is not None\n    assert func() == 42\n\ndef test_keepalive_ffi():\n    ffi = FFI()\n    ffi.cdef(\"int foobar(void);\")\n    lib = ffi.verify(\"int foobar(void) { return 42; }\")\n    func = lib.foobar\n    ffi_r = weakref.ref(ffi)\n    lib_r = weakref.ref(lib)\n    del lib\n    import gc; gc.collect()       # ffi stays alive\n    assert ffi_r() is not None\n    assert lib_r() is not None\n    assert func() == 42\n\ndef test_FILE_stored_in_stdout():\n    if not sys.platform.startswith('linux'):\n        py.test.skip(\"likely, we cannot assign to stdout\")\n    ffi = FFI()\n    ffi.cdef(\"int printf(const char *, ...); FILE *setstdout(FILE *);\")\n    lib = ffi.verify(\"\"\"\n        #include <stdio.h>\n        FILE *setstdout(FILE *f) {\n            FILE *result = stdout;\n            stdout = f;\n            return result;\n        }\n    \"\"\")\n    import os\n    fdr, fdw = os.pipe()\n    fw1 = os.fdopen(fdw, 'wb', 256)\n    old_stdout = lib.setstdout(fw1)\n    try:\n        #\n        fw1.write(b\"X\")\n        r = lib.printf(b\"hello, %d!\\n\", ffi.cast(\"int\", 42))\n        fw1.close()\n        assert r == len(\"hello, 42!\\n\")\n        #\n    finally:\n        lib.setstdout(old_stdout)\n    #\n    result = os.read(fdr, 256)\n    os.close(fdr)\n    # the 'X' might remain in the user-level buffer of 'fw1' and\n    # end up showing up after the 'hello, 42!\\n'\n    assert result == b\"Xhello, 42!\\n\" or result == b\"hello, 42!\\nX\"\n\ndef test_FILE_stored_explicitly():\n    ffi = FFI()\n    ffi.cdef(\"int myprintf11(const char *, int); FILE *myfile;\")\n    lib = ffi.verify(\"\"\"\n        #include <stdio.h>\n        FILE *myfile;\n        int myprintf11(const char *out, int value) {\n            return fprintf(myfile, out, value);\n        }\n    \"\"\")\n    import os\n    fdr, fdw = os.pipe()\n    fw1 = os.fdopen(fdw, 'wb', 256)\n    lib.myfile = ffi.cast(\"FILE *\", fw1)\n    #\n    fw1.write(b\"X\")\n    r = lib.myprintf11(b\"hello, %d!\\n\", ffi.cast(\"int\", 42))\n    fw1.close()\n    assert r == len(\"hello, 42!\\n\")\n    #\n    result = os.read(fdr, 256)\n    os.close(fdr)\n    # the 'X' might remain in the user-level buffer of 'fw1' and\n    # end up showing up after the 'hello, 42!\\n'\n    assert result == b\"Xhello, 42!\\n\" or result == b\"hello, 42!\\nX\"\n\ndef test_global_array_with_missing_length():\n    ffi = FFI()\n    ffi.cdef(\"int fooarray[];\")\n    lib = ffi.verify(\"int fooarray[50];\")\n    assert repr(lib.fooarray).startswith(\"<cdata 'int *'\")\n\ndef test_global_array_with_dotdotdot_length():\n    ffi = FFI()\n    ffi.cdef(\"int fooarray[...];\")\n    lib = ffi.verify(\"int fooarray[50];\")\n    assert repr(lib.fooarray).startswith(\"<cdata 'int[50]'\")\n\ndef test_bad_global_array_with_dotdotdot_length():\n    ffi = FFI()\n    ffi.cdef(\"int fooarray[...];\")\n    py.test.raises(VerificationError, ffi.verify, \"char fooarray[23];\")\n\ndef test_struct_containing_struct():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { ...; }; struct bar_s { struct foo_s f; ...; };\")\n    ffi.verify(\"struct foo_s { int x; }; struct bar_s { struct foo_s f; };\")\n    #\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { struct bar_s f; ...; }; struct bar_s { ...; };\")\n    ffi.verify(\"struct bar_s { int x; }; struct foo_s { struct bar_s f; };\")\n\ndef test_struct_returned_by_func():\n    ffi = FFI()\n    ffi.cdef(\"typedef ... foo_t; foo_t myfunc(void);\")\n    e = py.test.raises(TypeError, ffi.verify,\n                       \"typedef struct { int x; } foo_t; \"\n                       \"foo_t myfunc(void) { foo_t x = { 42 }; return x; }\")\n    assert str(e.value) == (\n        \"function myfunc: 'foo_t' is used as result type, but is opaque\")\n\ndef test_include():\n    ffi1 = FFI()\n    ffi1.cdef(\"typedef struct { int x; ...; } foo_t;\")\n    ffi1.verify(\"typedef struct { int y, x; } foo_t;\")\n    ffi2 = FFI()\n    ffi2.include(ffi1)\n    ffi2.cdef(\"int myfunc(foo_t *);\")\n    lib = ffi2.verify(\"typedef struct { int y, x; } foo_t;\"\n                      \"int myfunc(foo_t *p) { return 42 * p->x; }\")\n    res = lib.myfunc(ffi2.new(\"foo_t *\", {'x': 10}))\n    assert res == 420\n    res = lib.myfunc(ffi1.new(\"foo_t *\", {'x': -10}))\n    assert res == -420\n\ndef test_include_enum():\n    ffi1 = FFI()\n    ffi1.cdef(\"enum foo_e { AA, ... };\")\n    lib1 = ffi1.verify(\"enum foo_e { CC, BB, AA };\")\n    ffi2 = FFI()\n    ffi2.include(ffi1)\n    ffi2.cdef(\"int myfunc(enum foo_e);\")\n    lib2 = ffi2.verify(\"enum foo_e { CC, BB, AA };\"\n                       \"int myfunc(enum foo_e x) { return (int)x; }\")\n    res = lib2.myfunc(lib2.AA)\n    assert res == 2\n\ndef test_named_pointer_as_argument():\n    ffi = FFI()\n    ffi.cdef(\"typedef struct { int x; } *mystruct_p;\\n\"\n             \"mystruct_p ff5a(mystruct_p);\")\n    lib = ffi.verify(\"typedef struct { int x; } *mystruct_p;\\n\"\n                     \"mystruct_p ff5a(mystruct_p p) { p->x += 40; return p; }\")\n    p = ffi.new(\"mystruct_p\", [-2])\n    q = lib.ff5a(p)\n    assert q == p\n    assert p.x == 38\n\ndef test_enum_size():\n    cases = [('123',           4, 4294967295),\n             ('4294967295U',   4, 4294967295),\n             ('-123',          4, -1),\n             ('-2147483647-1', 4, -1),\n             ]\n    if FFI().sizeof(\"long\") == 8:\n        cases += [('4294967296L',        8, 2**64-1),\n                  ('%dUL' % (2**64-1),   8, 2**64-1),\n                  ('-2147483649L',       8, -1),\n                  ('%dL-1L' % (1-2**63), 8, -1)]\n    for hidden_value, expected_size, expected_minus1 in cases:\n        if sys.platform == 'win32' and 'U' in hidden_value:\n            continue   # skipped on Windows\n        ffi = FFI()\n        ffi.cdef(\"enum foo_e { AA, BB, ... };\")\n        lib = ffi.verify(\"enum foo_e { AA, BB=%s };\" % hidden_value)\n        assert lib.AA == 0\n        assert lib.BB == eval(hidden_value.replace('U', '').replace('L', ''))\n        assert ffi.sizeof(\"enum foo_e\") == expected_size\n        assert int(ffi.cast(\"enum foo_e\", -1)) == expected_minus1\n    # test with the large value hidden:\n    # disabled so far, doesn't work\n##    for hidden_value, expected_size, expected_minus1 in cases:\n##        ffi = FFI()\n##        ffi.cdef(\"enum foo_e { AA, BB, ... };\")\n##        lib = ffi.verify(\"enum foo_e { AA, BB=%s };\" % hidden_value)\n##        assert lib.AA == 0\n##        assert ffi.sizeof(\"enum foo_e\") == expected_size\n##        assert int(ffi.cast(\"enum foo_e\", -1)) == expected_minus1\n\ndef test_enum_bug118():\n    maxulong = 256 ** FFI().sizeof(\"unsigned long\") - 1\n    for c1, c2, c2c in [(0xffffffff, -1, ''),\n                        (maxulong, -1, ''),\n                        (-1, 0xffffffff, 'U'),\n                        (-1, maxulong, 'UL')]:\n        if c2c and sys.platform == 'win32':\n            continue     # enums may always be signed with MSVC\n        ffi = FFI()\n        ffi.cdef(\"enum foo_e { AA=%s };\" % c1)\n        e = py.test.raises(VerificationError, ffi.verify,\n                           \"enum foo_e { AA=%s%s };\" % (c2, c2c))\n        assert str(e.value) == ('enum foo_e: AA has the real value %d, not %d'\n                                % (c2, c1))\n\ndef test_string_to_voidp_arg():\n    ffi = FFI()\n    ffi.cdef(\"int myfunc(void *);\")\n    lib = ffi.verify(\"int myfunc(void *p) { return ((signed char *)p)[0]; }\")\n    res = lib.myfunc(b\"hi!\")\n    assert res == ord(b\"h\")\n    p = ffi.new(\"char[]\", b\"gah\")\n    res = lib.myfunc(p)\n    assert res == ord(b\"g\")\n    res = lib.myfunc(ffi.cast(\"void *\", p))\n    assert res == ord(b\"g\")\n    res = lib.myfunc(ffi.cast(\"int *\", p))\n    assert res == ord(b\"g\")\n\ndef test_callback_indirection():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        int (*python_callback)(int how_many, int *values);\n        int (*const c_callback)(int,...);   /* pass this ptr to C routines */\n        int some_c_function(int(*cb)(int,...));\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        #include <stdarg.h>\n        #ifdef _WIN32\n        #include <malloc.h>\n        #define alloca _alloca\n        #else\n        # ifdef __FreeBSD__\n        #  include <stdlib.h>\n        # else\n        #  include <alloca.h>\n        # endif\n        #endif\n        static int (*python_callback)(int how_many, int *values);\n        static int c_callback(int how_many, ...) {\n            va_list ap;\n            /* collect the \"...\" arguments into the values[] array */\n            int i, *values = alloca((size_t)how_many * sizeof(int));\n            va_start(ap, how_many);\n            for (i=0; i<how_many; i++)\n                values[i] = va_arg(ap, int);\n            va_end(ap);\n            return python_callback(how_many, values);\n        }\n        int some_c_function(int(*cb)(int,...)) {\n            int result = cb(2, 10, 20);\n            result += cb(3, 30, 40, 50);\n            return result;\n        }\n    \"\"\")\n    seen = []\n    @ffi.callback(\"int(int, int*)\")\n    def python_callback(how_many, values):\n        seen.append([values[i] for i in range(how_many)])\n        return 42\n    lib.python_callback = python_callback\n\n    res = lib.some_c_function(lib.c_callback)\n    assert res == 84\n    assert seen == [[10, 20], [30, 40, 50]]\n\ndef test_floatstar_argument():\n    ffi = FFI()\n    ffi.cdef(\"float sum3floats(float *);\")\n    lib = ffi.verify(\"\"\"\n        float sum3floats(float *f) {\n            return f[0] + f[1] + f[2];\n        }\n    \"\"\")\n    assert lib.sum3floats((1.5, 2.5, 3.5)) == 7.5\n    p = ffi.new(\"float[]\", (1.5, 2.5, 3.5))\n    assert lib.sum3floats(p) == 7.5\n\ndef test_charstar_argument():\n    ffi = FFI()\n    ffi.cdef(\"char sum3chars(char *);\")\n    lib = ffi.verify(\"\"\"\n        char sum3chars(char *f) {\n            return (char)(f[0] + f[1] + f[2]);\n        }\n    \"\"\")\n    assert lib.sum3chars((b'\\x10', b'\\x20', b'\\x30')) == b'\\x60'\n    p = ffi.new(\"char[]\", b'\\x10\\x20\\x30')\n    assert lib.sum3chars(p) == b'\\x60'\n\ndef test_passing_string_or_NULL():\n    ffi = FFI()\n    ffi.cdef(\"int seeme1(char *); int seeme2(int *);\")\n    lib = ffi.verify(\"\"\"\n        int seeme1(char *x) {\n            return (x == NULL);\n        }\n        int seeme2(int *x) {\n            return (x == NULL);\n        }\n    \"\"\")\n    assert lib.seeme1(b\"foo\") == 0\n    assert lib.seeme1(ffi.NULL) == 1\n    assert lib.seeme2([42, 43]) == 0\n    assert lib.seeme2(ffi.NULL) == 1\n    py.test.raises(TypeError, lib.seeme1, None)\n    py.test.raises(TypeError, lib.seeme2, None)\n    py.test.raises(TypeError, lib.seeme1, 0.0)\n    py.test.raises(TypeError, lib.seeme2, 0.0)\n    py.test.raises(TypeError, lib.seeme1, 0)\n    py.test.raises(TypeError, lib.seeme2, 0)\n    zeroL  = 99999999999999999999\n    zeroL -= 99999999999999999999\n    py.test.raises(TypeError, lib.seeme2, zeroL)\n\ndef test_typeof_function():\n    ffi = FFI()\n    ffi.cdef(\"int foo(int, char);\")\n    lib = ffi.verify(\"int foo(int x, char y) { (void)x; (void)y; return 42; }\")\n    ctype = ffi.typeof(lib.foo)\n    assert len(ctype.args) == 2\n    assert ctype.result == ffi.typeof(\"int\")\n\ndef test_call_with_voidstar_arg():\n    ffi = FFI()\n    ffi.cdef(\"int f(void *);\")\n    lib = ffi.verify(\"int f(void *x) { return ((char*)x)[0]; }\")\n    assert lib.f(b\"foobar\") == ord(b\"f\")\n\ndef test_dir():\n    ffi = FFI()\n    ffi.cdef(\"\"\"void somefunc(void);\n                extern int somevar, somearray[2];\n                static char *const sv2;\n                enum my_e { AA, BB, ... };\n                #define FOO ...\"\"\")\n    lib = ffi.verify(\"\"\"void somefunc(void) { }\n                        int somevar, somearray[2];\n                        #define sv2 \"text\"\n                        enum my_e { AA, BB };\n                        #define FOO 42\"\"\")\n    assert dir(lib) == ['AA', 'BB', 'FOO', 'somearray',\n                        'somefunc', 'somevar', 'sv2']\n\ndef test_typeof_func_with_struct_argument():\n    ffi = FFI()\n    ffi.cdef(\"\"\"struct s { int a; }; int foo(struct s);\"\"\")\n    lib = ffi.verify(\"\"\"struct s { int a; };\n                        int foo(struct s x) { return x.a; }\"\"\")\n    s = ffi.new(\"struct s *\", [-1234])\n    m = lib.foo(s[0])\n    assert m == -1234\n    assert repr(ffi.typeof(lib.foo)) == \"<ctype 'int(*)(struct s)'>\"\n\ndef test_bug_const_char_ptr_array_1():\n    ffi = FFI()\n    ffi.cdef(\"\"\"const char *a[...];\"\"\")\n    lib = ffi.verify(\"\"\"const char *a[5];\"\"\")\n    assert repr(ffi.typeof(lib.a)) == \"<ctype 'char *[5]'>\"\n\ndef test_bug_const_char_ptr_array_2():\n    from cffi import FFI     # ignore warnings\n    ffi = FFI()\n    ffi.cdef(\"\"\"const int a[];\"\"\")\n    lib = ffi.verify(\"\"\"const int a[5];\"\"\")\n    assert repr(ffi.typeof(lib.a)) == \"<ctype 'int *'>\"\n\ndef _test_various_calls(force_libffi):\n    cdef_source = \"\"\"\n    int xvalue;\n    long long ivalue, rvalue;\n    float fvalue;\n    double dvalue;\n    long double Dvalue;\n    signed char tf_bb(signed char x, signed char c);\n    unsigned char tf_bB(signed char x, unsigned char c);\n    short tf_bh(signed char x, short c);\n    unsigned short tf_bH(signed char x, unsigned short c);\n    int tf_bi(signed char x, int c);\n    unsigned int tf_bI(signed char x, unsigned int c);\n    long tf_bl(signed char x, long c);\n    unsigned long tf_bL(signed char x, unsigned long c);\n    long long tf_bq(signed char x, long long c);\n    unsigned long long tf_bQ(signed char x, unsigned long long c);\n    float tf_bf(signed char x, float c);\n    double tf_bd(signed char x, double c);\n    long double tf_bD(signed char x, long double c);\n    \"\"\"\n    if force_libffi:\n        cdef_source = (cdef_source\n            .replace('tf_', '(*const tf_')\n            .replace('(signed char x', ')(signed char x'))\n    ffi = FFI()\n    ffi.cdef(cdef_source)\n    lib = ffi.verify(\"\"\"\n    int xvalue;\n    long long ivalue, rvalue;\n    float fvalue;\n    double dvalue;\n    long double Dvalue;\n\n    typedef signed char b_t;\n    typedef unsigned char B_t;\n    typedef short h_t;\n    typedef unsigned short H_t;\n    typedef int i_t;\n    typedef unsigned int I_t;\n    typedef long l_t;\n    typedef unsigned long L_t;\n    typedef long long q_t;\n    typedef unsigned long long Q_t;\n    typedef float f_t;\n    typedef double d_t;\n    typedef long double D_t;\n    #define S(letter)  xvalue = (int)x; letter##value = (letter##_t)c;\n    #define R(letter)  return (letter##_t)rvalue;\n\n    signed char tf_bb(signed char x, signed char c) { S(i) R(b) }\n    unsigned char tf_bB(signed char x, unsigned char c) { S(i) R(B) }\n    short tf_bh(signed char x, short c) { S(i) R(h) }\n    unsigned short tf_bH(signed char x, unsigned short c) { S(i) R(H) }\n    int tf_bi(signed char x, int c) { S(i) R(i) }\n    unsigned int tf_bI(signed char x, unsigned int c) { S(i) R(I) }\n    long tf_bl(signed char x, long c) { S(i) R(l) }\n    unsigned long tf_bL(signed char x, unsigned long c) { S(i) R(L) }\n    long long tf_bq(signed char x, long long c) { S(i) R(q) }\n    unsigned long long tf_bQ(signed char x, unsigned long long c) { S(i) R(Q) }\n    float tf_bf(signed char x, float c) { S(f) R(f) }\n    double tf_bd(signed char x, double c) { S(d) R(d) }\n    long double tf_bD(signed char x, long double c) { S(D) R(D) }\n    \"\"\")\n    lib.rvalue = 0x7182838485868788\n    for kind, cname in [('b', 'signed char'),\n                        ('B', 'unsigned char'),\n                        ('h', 'short'),\n                        ('H', 'unsigned short'),\n                        ('i', 'int'),\n                        ('I', 'unsigned int'),\n                        ('l', 'long'),\n                        ('L', 'unsigned long'),\n                        ('q', 'long long'),\n                        ('Q', 'unsigned long long'),\n                        ('f', 'float'),\n                        ('d', 'double'),\n                        ('D', 'long double')]:\n        sign = +1 if 'unsigned' in cname else -1\n        lib.xvalue = 0\n        lib.ivalue = 0\n        lib.fvalue = 0\n        lib.dvalue = 0\n        lib.Dvalue = 0\n        fun = getattr(lib, 'tf_b' + kind)\n        res = fun(-42, sign * 99)\n        if kind == 'D':\n            res = float(res)\n        assert res == int(ffi.cast(cname, 0x7182838485868788))\n        assert lib.xvalue == -42\n        if kind in 'fdD':\n            assert float(getattr(lib, kind + 'value')) == -99.0\n        else:\n            assert lib.ivalue == sign * 99\n\ndef test_various_calls_direct():\n    _test_various_calls(force_libffi=False)\n\ndef test_various_calls_libffi():\n    _test_various_calls(force_libffi=True)\n\ndef test_ptr_to_opaque():\n    ffi = FFI()\n    ffi.cdef(\"typedef ... foo_t; int f1(foo_t*); foo_t *f2(int);\")\n    lib = ffi.verify(\"\"\"\n        #include <stdlib.h>\n        typedef struct { int x; } foo_t;\n        int f1(foo_t* p) {\n            int x = p->x;\n            free(p);\n            return x;\n        }\n        foo_t *f2(int x) {\n            foo_t *p = malloc(sizeof(foo_t));\n            p->x = x;\n            return p;\n        }\n    \"\"\")\n    p = lib.f2(42)\n    x = lib.f1(p)\n    assert x == 42\n\ndef _run_in_multiple_threads(test1):\n    test1()\n    import sys\n    try:\n        import thread\n    except ImportError:\n        import _thread as thread\n    errors = []\n    def wrapper(lock):\n        try:\n            test1()\n        except:\n            errors.append(sys.exc_info())\n        lock.release()\n    locks = []\n    for i in range(10):\n        _lock = thread.allocate_lock()\n        _lock.acquire()\n        thread.start_new_thread(wrapper, (_lock,))\n        locks.append(_lock)\n    for _lock in locks:\n        _lock.acquire()\n        if errors:\n            raise errors[0][1]\n\ndef test_errno_working_even_with_pypys_jit():\n    # NOTE: on some platforms, to work correctly, this test needs to be\n    # compiled with -pthread.  Otherwise, the accesses to errno done from f()\n    # are compiled by assuming this small library won't be used from multiple\n    # threads, which is wrong.  If you see failures _and_ if you pass your\n    # own CFLAGS environment variable, please make sure \"-pthread\" is in it.\n    ffi = FFI()\n    ffi.cdef(\"int f(int);\")\n    lib = ffi.verify(\"\"\"\n        #include <errno.h>\n        int f(int x) { return (errno = errno + x); }\n    \"\"\")\n    @_run_in_multiple_threads\n    def test1():\n        ffi.errno = 0\n        for i in range(10000):\n            e = lib.f(1)\n            assert e == i + 1\n            assert ffi.errno == e\n        for i in range(10000):\n            ffi.errno = i\n            e = lib.f(42)\n            assert e == i + 42\n\ndef test_getlasterror_working_even_with_pypys_jit():\n    if sys.platform != 'win32':\n        py.test.skip(\"win32-only test\")\n    ffi = FFI()\n    ffi.cdef(\"void SetLastError(DWORD);\")\n    lib = ffi.dlopen(\"Kernel32.dll\")\n    @_run_in_multiple_threads\n    def test1():\n        for i in range(10000):\n            n = (1 << 29) + i\n            lib.SetLastError(n)\n            assert ffi.getwinerror()[0] == n\n\ndef test_verify_dlopen_flags():\n    # Careful with RTLD_GLOBAL.  If by chance the FFI is not deleted\n    # promptly, like on PyPy, then other tests may see the same\n    # exported symbols as well.  So we must not export a simple name\n    # like 'foo'!\n    ffi1 = FFI()\n    ffi1.cdef(\"int foo_verify_dlopen_flags;\")\n\n    lib1 = ffi1.verify(\"int foo_verify_dlopen_flags;\",\n                       flags=ffi1.RTLD_GLOBAL | ffi1.RTLD_LAZY)\n    lib2 = get_second_lib()\n\n    lib1.foo_verify_dlopen_flags = 42\n    assert lib2.foo_verify_dlopen_flags == 42\n    lib2.foo_verify_dlopen_flags += 1\n    assert lib1.foo_verify_dlopen_flags == 43\n\ndef get_second_lib():\n    # Hack, using modulename makes the test fail\n    ffi2 = FFI()\n    ffi2.cdef(\"int foo_verify_dlopen_flags;\")\n    lib2 = ffi2.verify(\"int foo_verify_dlopen_flags;\",\n                       flags=ffi2.RTLD_GLOBAL | ffi2.RTLD_LAZY)\n    return lib2\n\ndef test_consider_not_implemented_function_type():\n    ffi = FFI()\n    ffi.cdef(\"typedef union { int a; float b; } Data;\"\n             \"typedef struct { int a:2; } MyStr;\"\n             \"typedef void (*foofunc_t)(Data);\"\n             \"typedef Data (*bazfunc_t)(void);\"\n             \"typedef MyStr (*barfunc_t)(void);\")\n    fooptr = ffi.cast(\"foofunc_t\", 123)\n    bazptr = ffi.cast(\"bazfunc_t\", 123)\n    barptr = ffi.cast(\"barfunc_t\", 123)\n    # assert did not crash so far\n    e = py.test.raises(NotImplementedError, fooptr, ffi.new(\"Data *\"))\n    assert str(e.value) == (\n        \"ctype 'Data' not supported as argument by libffi.  Unions are only \"\n        \"supported as argument if the function is 'API mode' and \"\n        \"non-variadic (i.e. declared inside ffibuilder.cdef()+\"\n        \"ffibuilder.set_source() and not taking a final '...' argument)\")\n    e = py.test.raises(NotImplementedError, bazptr)\n    assert str(e.value) == (\n        \"ctype 'Data' not supported as return value by libffi.  Unions are \"\n        \"only supported as return value if the function is 'API mode' and \"\n        \"non-variadic (i.e. declared inside ffibuilder.cdef()+\"\n        \"ffibuilder.set_source() and not taking a final '...' argument)\")\n    e = py.test.raises(NotImplementedError, barptr)\n    assert str(e.value) == (\n        \"ctype 'MyStr' not supported as return value.  It is a struct with \"\n        \"bit fields, which libffi does not support.  Such structs are only \"\n        \"supported as return value if the function is 'API mode' and non-\"\n        \"variadic (i.e. declared inside ffibuilder.cdef()+ffibuilder.\"\n        \"set_source() and not taking a final '...' argument)\")\n\ndef test_verify_extra_arguments():\n    ffi = FFI()\n    ffi.cdef(\"#define ABA ...\")\n    lib = ffi.verify(\"\", define_macros=[('ABA', '42')])\n    assert lib.ABA == 42\n\ndef test_implicit_unicode_on_windows():\n    if sys.platform != 'win32':\n        py.test.skip(\"win32-only test\")\n    ffi = FFI()\n    e = py.test.raises(FFIError, ffi.cdef, \"int foo(LPTSTR);\")\n    assert str(e.value) == (\"The Windows type 'LPTSTR' is only available after\"\n                            \" you call ffi.set_unicode()\")\n    for with_unicode in [True, False]:\n        ffi = FFI()\n        ffi.set_unicode(with_unicode)\n        ffi.cdef(\"\"\"\n            DWORD GetModuleFileName(HMODULE hModule, LPTSTR lpFilename,\n                                    DWORD nSize);\n        \"\"\")\n        lib = ffi.verify(\"\"\"\n            #include <windows.h>\n        \"\"\", libraries=['Kernel32'])\n        outbuf = ffi.new(\"TCHAR[]\", 200)\n        n = lib.GetModuleFileName(ffi.NULL, outbuf, 500)\n        assert 0 < n < 500\n        for i in range(n):\n            #print repr(outbuf[i])\n            assert ord(outbuf[i]) != 0\n        assert ord(outbuf[n]) == 0\n        assert ord(outbuf[0]) < 128     # should be a letter, or '\\'\n\ndef test_use_local_dir():\n    ffi = FFI()\n    lib = ffi.verify(\"\", modulename=\"test_use_local_dir\")\n    this_dir = os.path.dirname(__file__)\n    pycache_files = os.listdir(os.path.join(this_dir, '__pycache__'))\n    assert any('test_use_local_dir' in s for s in pycache_files)\n\ndef test_define_known_value():\n    ffi = FFI()\n    ffi.cdef(\"#define FOO 0x123\")\n    lib = ffi.verify(\"#define FOO 0x123\")\n    assert lib.FOO == 0x123\n\ndef test_define_wrong_value():\n    ffi = FFI()\n    ffi.cdef(\"#define FOO 123\")\n    e = py.test.raises(VerificationError, ffi.verify, \"#define FOO 124\")\n    assert str(e.value).endswith(\"FOO has the real value 124, not 123\")\n\ndef test_static_const_int_known_value():\n    ffi = FFI()\n    ffi.cdef(\"static const int FOO = 0x123;\")\n    lib = ffi.verify(\"#define FOO 0x123\")\n    assert lib.FOO == 0x123\n\ndef test_static_const_int_wrong_value():\n    ffi = FFI()\n    ffi.cdef(\"static const int FOO = 123;\")\n    e = py.test.raises(VerificationError, ffi.verify, \"#define FOO 124\")\n    assert str(e.value).endswith(\"FOO has the real value 124, not 123\")\n\ndef test_const_struct_global():\n    ffi = FFI()\n    ffi.cdef(\"typedef struct { int x; ...; } T; const T myglob;\")\n    lib = ffi.verify(\"typedef struct { double y; int x; } T;\"\n                     \"const T myglob = { 0.1, 42 };\")\n    assert ffi.typeof(lib.myglob) == ffi.typeof(\"T\")\n    assert lib.myglob.x == 42\n\ndef test_dont_support_int_dotdotdot():\n    ffi = FFI()\n    ffi.cdef(\"typedef int... t1;\")\n    e = py.test.raises(VerificationError, ffi.verify, \"\")\n    assert str(e.value) == (\"feature not supported with ffi.verify(), but only \"\n                            \"with ffi.set_source(): 'typedef int... t1'\")\n    ffi = FFI()\n    ffi.cdef(\"typedef double ... t1;\")\n    e = py.test.raises(VerificationError, ffi.verify, \"\")\n    assert str(e.value) == (\"feature not supported with ffi.verify(), but only \"\n                         \"with ffi.set_source(): 'typedef float... t1'\")\n\ndef test_const_fields():\n    ffi = FFI()\n    ffi.cdef(\"\"\"struct foo_s { const int a; void *const b; };\"\"\")\n    ffi.verify(\"\"\"struct foo_s { const int a; void *const b; };\"\"\")\n    foo_s = ffi.typeof(\"struct foo_s\")\n    assert foo_s.fields[0][0] == 'a'\n    assert foo_s.fields[0][1].type is ffi.typeof(\"int\")\n    assert foo_s.fields[1][0] == 'b'\n    assert foo_s.fields[1][1].type is ffi.typeof(\"void *\")\n\ndef test_win32_calling_convention_0():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        int call1(int(__cdecl   *cb)(int));\n        int (*const call2)(int(__stdcall *cb)(int));\n    \"\"\")\n    lib = ffi.verify(r\"\"\"\n        #ifndef _MSC_VER\n        #  define __stdcall  /* nothing */\n        #endif\n        int call1(int(*cb)(int)) {\n            int i, result = 0;\n            //printf(\"call1: cb = %p\\n\", cb);\n            for (i = 0; i < 1000; i++)\n                result += cb(i);\n            //printf(\"result = %d\\n\", result);\n            return result;\n        }\n        int call2(int(__stdcall *cb)(int)) {\n            int i, result = 0;\n            //printf(\"call2: cb = %p\\n\", cb);\n            for (i = 0; i < 1000; i++)\n                result += cb(-i);\n            //printf(\"result = %d\\n\", result);\n            return result;\n        }\n    \"\"\")\n    @ffi.callback(\"int(int)\")\n    def cb1(x):\n        return x * 2\n    @ffi.callback(\"int __stdcall(int)\")\n    def cb2(x):\n        return x * 3\n    #print 'cb1 =', cb1\n    res = lib.call1(cb1)\n    assert res == 500*999*2\n    #print 'cb2 =', cb2\n    #print ffi.typeof(lib.call2)\n    #print 'call2 =', lib.call2\n    res = lib.call2(cb2)\n    #print '...'\n    assert res == -500*999*3\n    #print 'done'\n    if sys.platform == 'win32' and sys.maxsize < 2**32:\n        assert '__stdcall' in str(ffi.typeof(cb2))\n        assert '__stdcall' not in str(ffi.typeof(cb1))\n        py.test.raises(TypeError, lib.call1, cb2)\n        py.test.raises(TypeError, lib.call2, cb1)\n    else:\n        assert '__stdcall' not in str(ffi.typeof(cb2))\n        assert ffi.typeof(cb2) is ffi.typeof(cb1)\n\ndef test_win32_calling_convention_1():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        int __cdecl   call1(int(__cdecl   *cb)(int));\n        int __stdcall call2(int(__stdcall *cb)(int));\n        int (__cdecl   *const cb1)(int);\n        int (__stdcall *const cb2)(int);\n    \"\"\")\n    lib = ffi.verify(r\"\"\"\n        #ifndef _MSC_VER\n        #  define __cdecl\n        #  define __stdcall\n        #endif\n        int __cdecl   cb1(int x) { return x * 2; }\n        int __stdcall cb2(int x) { return x * 3; }\n\n        int __cdecl call1(int(__cdecl *cb)(int)) {\n            int i, result = 0;\n            //printf(\"here1\\n\");\n            //printf(\"cb = %p, cb1 = %p\\n\", cb, (void *)cb1);\n            for (i = 0; i < 1000; i++)\n                result += cb(i);\n            //printf(\"result = %d\\n\", result);\n            return result;\n        }\n        int __stdcall call2(int(__stdcall *cb)(int)) {\n            int i, result = 0;\n            //printf(\"here1\\n\");\n            //printf(\"cb = %p, cb2 = %p\\n\", cb, (void *)cb2);\n            for (i = 0; i < 1000; i++)\n                result += cb(-i);\n            //printf(\"result = %d\\n\", result);\n            return result;\n        }\n    \"\"\")\n    assert lib.call1(lib.cb1) == 500*999*2\n    assert lib.call2(lib.cb2) == -500*999*3\n\ndef test_win32_calling_convention_2():\n    # any mistake in the declaration of plain function (including the\n    # precise argument types and, here, the calling convention) are\n    # automatically corrected.  But this does not apply to the 'cb'\n    # function pointer argument.\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        int __stdcall call1(int(__cdecl   *cb)(int));\n        int __cdecl   call2(int(__stdcall *cb)(int));\n        int (__cdecl   *const cb1)(int);\n        int (__stdcall *const cb2)(int);\n    \"\"\")\n    lib = ffi.verify(r\"\"\"\n        #ifndef _MSC_VER\n        #  define __cdecl\n        #  define __stdcall\n        #endif\n        int __cdecl call1(int(__cdecl *cb)(int)) {\n            int i, result = 0;\n            for (i = 0; i < 1000; i++)\n                result += cb(i);\n            return result;\n        }\n        int __stdcall call2(int(__stdcall *cb)(int)) {\n            int i, result = 0;\n            for (i = 0; i < 1000; i++)\n                result += cb(-i);\n            return result;\n        }\n        int __cdecl   cb1(int x) { return x * 2; }\n        int __stdcall cb2(int x) { return x * 3; }\n    \"\"\")\n    assert lib.call1(lib.cb1) == 500*999*2\n    assert lib.call2(lib.cb2) == -500*999*3\n\ndef test_win32_calling_convention_3():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        struct point { int x, y; };\n\n        int (*const cb1)(struct point);\n        int (__stdcall *const cb2)(struct point);\n\n        struct point __stdcall call1(int(*cb)(struct point));\n        struct point call2(int(__stdcall *cb)(struct point));\n    \"\"\")\n    lib = ffi.verify(r\"\"\"\n        #ifndef _MSC_VER\n        #  define __cdecl\n        #  define __stdcall\n        #endif\n        struct point { int x, y; };\n        int           cb1(struct point pt) { return pt.x + 10 * pt.y; }\n        int __stdcall cb2(struct point pt) { return pt.x + 100 * pt.y; }\n        struct point __stdcall call1(int(__cdecl *cb)(struct point)) {\n            int i;\n            struct point result = { 0, 0 };\n            //printf(\"here1\\n\");\n            //printf(\"cb = %p, cb1 = %p\\n\", cb, (void *)cb1);\n            for (i = 0; i < 1000; i++) {\n                struct point p = { i, -i };\n                int r = cb(p);\n                result.x += r;\n                result.y -= r;\n            }\n            return result;\n        }\n        struct point __cdecl call2(int(__stdcall *cb)(struct point)) {\n            int i;\n            struct point result = { 0, 0 };\n            for (i = 0; i < 1000; i++) {\n                struct point p = { -i, i };\n                int r = cb(p);\n                result.x += r;\n                result.y -= r;\n            }\n            return result;\n        }\n    \"\"\")\n    if sys.platform == 'win32' and sys.maxsize < 2**32:\n        py.test.raises(TypeError, lib.call1, lib.cb2)\n        py.test.raises(TypeError, lib.call2, lib.cb1)\n    pt = lib.call1(lib.cb1)\n    assert (pt.x, pt.y) == (-9*500*999, 9*500*999)\n    pt = lib.call2(lib.cb2)\n    assert (pt.x, pt.y) == (99*500*999, -99*500*999)\n\ndef _only_test_on_linux_intel():\n    if not sys.platform.startswith('linux'):\n        py.test.skip('only running the memory-intensive test on Linux')\n    import platform\n    machine = platform.machine()\n    if 'x86' not in machine and 'x64' not in machine:\n        py.test.skip('only running the memory-intensive test on x86/x64')\n\ndef test_ffi_gc_size_arg():\n    # with PyPy's GC, these calls to ffi.gc() would rapidly consume\n    # 40 GB of RAM without the third argument\n    _only_test_on_linux_intel()\n    ffi = FFI()\n    ffi.cdef(\"void *malloc(size_t); void free(void *);\")\n    lib = ffi.verify(r\"\"\"\n        #include <stdlib.h>\n    \"\"\")\n    for i in range(2000):\n        p = lib.malloc(20*1024*1024)    # 20 MB\n        p1 = ffi.cast(\"char *\", p)\n        for j in range(0, 20*1024*1024, 4096):\n            p1[j] = b'!'\n        p = ffi.gc(p, lib.free, 20*1024*1024)\n        del p\n\ndef test_ffi_gc_size_arg_2():\n    # a variant of the above: this \"attack\" works on cpython's cyclic gc too\n    # and I found no obvious way to prevent that.  So for now, this test\n    # is skipped on CPython, where it eats all the memory.\n    if '__pypy__' not in sys.builtin_module_names:\n        py.test.skip(\"find a way to tweak the cyclic GC of CPython\")\n    _only_test_on_linux_intel()\n    ffi = FFI()\n    ffi.cdef(\"void *malloc(size_t); void free(void *);\")\n    lib = ffi.verify(r\"\"\"\n        #include <stdlib.h>\n    \"\"\")\n    class X(object):\n        pass\n    for i in range(2000):\n        p = lib.malloc(50*1024*1024)    # 50 MB\n        p1 = ffi.cast(\"char *\", p)\n        for j in range(0, 50*1024*1024, 4096):\n            p1[j] = b'!'\n        p = ffi.gc(p, lib.free, 50*1024*1024)\n        x = X()\n        x.p = p\n        x.cyclic = x\n        del p, x\n\ndef test_ffi_new_with_cycles():\n    # still another variant, with ffi.new()\n    if '__pypy__' not in sys.builtin_module_names:\n        py.test.skip(\"find a way to tweak the cyclic GC of CPython\")\n    ffi = FFI()\n    ffi.cdef(\"\")\n    lib = ffi.verify(\"\")\n    class X(object):\n        pass\n    for i in range(2000):\n        p = ffi.new(\"char[]\", 50*1024*1024)    # 50 MB\n        for j in range(0, 50*1024*1024, 4096):\n            p[j] = b'!'\n        x = X()\n        x.p = p\n        x.cyclic = x\n        del p, x\n\ndef test_arithmetic_in_cdef():\n    for a in [0, 11, 15]:\n        ffi = FFI()\n        ffi.cdef(\"\"\"\n            enum FOO {\n                DIVNN = ((-?) / (-3)),\n                DIVNP = ((-?) / (+3)),\n                DIVPN = ((+?) / (-3)),\n                MODNN = ((-?) % (-3)),\n                MODNP = ((-?) % (+3)),\n                MODPN = ((+?) % (-3)),\n                };\n        \"\"\".replace('?', str(a)))\n        lib = ffi.verify(\"\"\"\n            enum FOO {\n                DIVNN = ((-?) / (-3)),\n                DIVNP = ((-?) / (+3)),\n                DIVPN = ((+?) / (-3)),\n                MODNN = ((-?) % (-3)),\n                MODNP = ((-?) % (+3)),\n                MODPN = ((+?) % (-3)),\n                };\n        \"\"\".replace('?', str(a)))\n        # the verify() crashes if the values in the enum are different from\n        # the values we computed ourselves from the cdef()\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.13.0-jlicqgsrlask3n7tsdckxmdwv6d5zp4o/spack-src/cffi/api.py": "import sys, types\nfrom .lock import allocate_lock\nfrom .error import CDefError\nfrom . import model\n\ntry:\n    callable\nexcept NameError:\n    # Python 3.1\n    from collections import Callable\n    callable = lambda x: isinstance(x, Callable)\n\ntry:\n    basestring\nexcept NameError:\n    # Python 3.x\n    basestring = str\n\n_unspecified = object()\n\n\n\nclass FFI(object):\n    r'''\n    The main top-level class that you instantiate once, or once per module.\n\n    Example usage:\n\n        ffi = FFI()\n        ffi.cdef(\"\"\"\n            int printf(const char *, ...);\n        \"\"\")\n\n        C = ffi.dlopen(None)   # standard library\n        -or-\n        C = ffi.verify()  # use a C compiler: verify the decl above is right\n\n        C.printf(\"hello, %s!\\n\", ffi.new(\"char[]\", \"world\"))\n    '''\n\n    def __init__(self, backend=None):\n        \"\"\"Create an FFI instance.  The 'backend' argument is used to\n        select a non-default backend, mostly for tests.\n        \"\"\"\n        if backend is None:\n            # You need PyPy (>= 2.0 beta), or a CPython (>= 2.6) with\n            # _cffi_backend.so compiled.\n            import _cffi_backend as backend\n            from . import __version__\n            if backend.__version__ != __version__:\n                # bad version!  Try to be as explicit as possible.\n                if hasattr(backend, '__file__'):\n                    # CPython\n                    raise Exception(\"Version mismatch: this is the 'cffi' package version %s, located in %r.  When we import the top-level '_cffi_backend' extension module, we get version %s, located in %r.  The two versions should be equal; check your installation.\" % (\n                        __version__, __file__,\n                        backend.__version__, backend.__file__))\n                else:\n                    # PyPy\n                    raise Exception(\"Version mismatch: this is the 'cffi' package version %s, located in %r.  This interpreter comes with a built-in '_cffi_backend' module, which is version %s.  The two versions should be equal; check your installation.\" % (\n                        __version__, __file__, backend.__version__))\n            # (If you insist you can also try to pass the option\n            # 'backend=backend_ctypes.CTypesBackend()', but don't\n            # rely on it!  It's probably not going to work well.)\n\n        from . import cparser\n        self._backend = backend\n        self._lock = allocate_lock()\n        self._parser = cparser.Parser()\n        self._cached_btypes = {}\n        self._parsed_types = types.ModuleType('parsed_types').__dict__\n        self._new_types = types.ModuleType('new_types').__dict__\n        self._function_caches = []\n        self._libraries = []\n        self._cdefsources = []\n        self._included_ffis = []\n        self._windows_unicode = None\n        self._init_once_cache = {}\n        self._cdef_version = None\n        self._embedding = None\n        self._typecache = model.get_typecache(backend)\n        if hasattr(backend, 'set_ffi'):\n            backend.set_ffi(self)\n        for name in list(backend.__dict__):\n            if name.startswith('RTLD_'):\n                setattr(self, name, getattr(backend, name))\n        #\n        with self._lock:\n            self.BVoidP = self._get_cached_btype(model.voidp_type)\n            self.BCharA = self._get_cached_btype(model.char_array_type)\n        if isinstance(backend, types.ModuleType):\n            # _cffi_backend: attach these constants to the class\n            if not hasattr(FFI, 'NULL'):\n                FFI.NULL = self.cast(self.BVoidP, 0)\n                FFI.CData, FFI.CType = backend._get_types()\n        else:\n            # ctypes backend: attach these constants to the instance\n            self.NULL = self.cast(self.BVoidP, 0)\n            self.CData, self.CType = backend._get_types()\n        self.buffer = backend.buffer\n\n    def cdef(self, csource, override=False, packed=False, pack=None):\n        \"\"\"Parse the given C source.  This registers all declared functions,\n        types, and global variables.  The functions and global variables can\n        then be accessed via either 'ffi.dlopen()' or 'ffi.verify()'.\n        The types can be used in 'ffi.new()' and other functions.\n        If 'packed' is specified as True, all structs declared inside this\n        cdef are packed, i.e. laid out without any field alignment at all.\n        Alternatively, 'pack' can be a small integer, and requests for\n        alignment greater than that are ignored (pack=1 is equivalent to\n        packed=True).\n        \"\"\"\n        self._cdef(csource, override=override, packed=packed, pack=pack)\n\n    def embedding_api(self, csource, packed=False, pack=None):\n        self._cdef(csource, packed=packed, pack=pack, dllexport=True)\n        if self._embedding is None:\n            self._embedding = ''\n\n    def _cdef(self, csource, override=False, **options):\n        if not isinstance(csource, str):    # unicode, on Python 2\n            if not isinstance(csource, basestring):\n                raise TypeError(\"cdef() argument must be a string\")\n            csource = csource.encode('ascii')\n        with self._lock:\n            self._cdef_version = object()\n            self._parser.parse(csource, override=override, **options)\n            self._cdefsources.append(csource)\n            if override:\n                for cache in self._function_caches:\n                    cache.clear()\n            finishlist = self._parser._recomplete\n            if finishlist:\n                self._parser._recomplete = []\n                for tp in finishlist:\n                    tp.finish_backend_type(self, finishlist)\n\n    def dlopen(self, name, flags=0):\n        \"\"\"Load and return a dynamic library identified by 'name'.\n        The standard C library can be loaded by passing None.\n        Note that functions and types declared by 'ffi.cdef()' are not\n        linked to a particular library, just like C headers; in the\n        library we only look for the actual (untyped) symbols.\n        \"\"\"\n        assert isinstance(name, basestring) or name is None\n        with self._lock:\n            lib, function_cache = _make_ffi_library(self, name, flags)\n            self._function_caches.append(function_cache)\n            self._libraries.append(lib)\n        return lib\n\n    def dlclose(self, lib):\n        \"\"\"Close a library obtained with ffi.dlopen().  After this call,\n        access to functions or variables from the library will fail\n        (possibly with a segmentation fault).\n        \"\"\"\n        type(lib).__cffi_close__(lib)\n\n    def _typeof_locked(self, cdecl):\n        # call me with the lock!\n        key = cdecl\n        if key in self._parsed_types:\n            return self._parsed_types[key]\n        #\n        if not isinstance(cdecl, str):    # unicode, on Python 2\n            cdecl = cdecl.encode('ascii')\n        #\n        type = self._parser.parse_type(cdecl)\n        really_a_function_type = type.is_raw_function\n        if really_a_function_type:\n            type = type.as_function_pointer()\n        btype = self._get_cached_btype(type)\n        result = btype, really_a_function_type\n        self._parsed_types[key] = result\n        return result\n\n    def _typeof(self, cdecl, consider_function_as_funcptr=False):\n        # string -> ctype object\n        try:\n            result = self._parsed_types[cdecl]\n        except KeyError:\n            with self._lock:\n                result = self._typeof_locked(cdecl)\n        #\n        btype, really_a_function_type = result\n        if really_a_function_type and not consider_function_as_funcptr:\n            raise CDefError(\"the type %r is a function type, not a \"\n                            \"pointer-to-function type\" % (cdecl,))\n        return btype\n\n    def typeof(self, cdecl):\n        \"\"\"Parse the C type given as a string and return the\n        corresponding <ctype> object.\n        It can also be used on 'cdata' instance to get its C type.\n        \"\"\"\n        if isinstance(cdecl, basestring):\n            return self._typeof(cdecl)\n        if isinstance(cdecl, self.CData):\n            return self._backend.typeof(cdecl)\n        if isinstance(cdecl, types.BuiltinFunctionType):\n            res = _builtin_function_type(cdecl)\n            if res is not None:\n                return res\n        if (isinstance(cdecl, types.FunctionType)\n                and hasattr(cdecl, '_cffi_base_type')):\n            with self._lock:\n                return self._get_cached_btype(cdecl._cffi_base_type)\n        raise TypeError(type(cdecl))\n\n    def sizeof(self, cdecl):\n        \"\"\"Return the size in bytes of the argument.  It can be a\n        string naming a C type, or a 'cdata' instance.\n        \"\"\"\n        if isinstance(cdecl, basestring):\n            BType = self._typeof(cdecl)\n            return self._backend.sizeof(BType)\n        else:\n            return self._backend.sizeof(cdecl)\n\n    def alignof(self, cdecl):\n        \"\"\"Return the natural alignment size in bytes of the C type\n        given as a string.\n        \"\"\"\n        if isinstance(cdecl, basestring):\n            cdecl = self._typeof(cdecl)\n        return self._backend.alignof(cdecl)\n\n    def offsetof(self, cdecl, *fields_or_indexes):\n        \"\"\"Return the offset of the named field inside the given\n        structure or array, which must be given as a C type name.\n        You can give several field names in case of nested structures.\n        You can also give numeric values which correspond to array\n        items, in case of an array type.\n        \"\"\"\n        if isinstance(cdecl, basestring):\n            cdecl = self._typeof(cdecl)\n        return self._typeoffsetof(cdecl, *fields_or_indexes)[1]\n\n    def new(self, cdecl, init=None):\n        \"\"\"Allocate an instance according to the specified C type and\n        return a pointer to it.  The specified C type must be either a\n        pointer or an array: ``new('X *')`` allocates an X and returns\n        a pointer to it, whereas ``new('X[n]')`` allocates an array of\n        n X'es and returns an array referencing it (which works\n        mostly like a pointer, like in C).  You can also use\n        ``new('X[]', n)`` to allocate an array of a non-constant\n        length n.\n\n        The memory is initialized following the rules of declaring a\n        global variable in C: by default it is zero-initialized, but\n        an explicit initializer can be given which can be used to\n        fill all or part of the memory.\n\n        When the returned <cdata> object goes out of scope, the memory\n        is freed.  In other words the returned <cdata> object has\n        ownership of the value of type 'cdecl' that it points to.  This\n        means that the raw data can be used as long as this object is\n        kept alive, but must not be used for a longer time.  Be careful\n        about that when copying the pointer to the memory somewhere\n        else, e.g. into another structure.\n        \"\"\"\n        if isinstance(cdecl, basestring):\n            cdecl = self._typeof(cdecl)\n        return self._backend.newp(cdecl, init)\n\n    def new_allocator(self, alloc=None, free=None,\n                      should_clear_after_alloc=True):\n        \"\"\"Return a new allocator, i.e. a function that behaves like ffi.new()\n        but uses the provided low-level 'alloc' and 'free' functions.\n\n        'alloc' is called with the size as argument.  If it returns NULL, a\n        MemoryError is raised.  'free' is called with the result of 'alloc'\n        as argument.  Both can be either Python function or directly C\n        functions.  If 'free' is None, then no free function is called.\n        If both 'alloc' and 'free' are None, the default is used.\n\n        If 'should_clear_after_alloc' is set to False, then the memory\n        returned by 'alloc' is assumed to be already cleared (or you are\n        fine with garbage); otherwise CFFI will clear it.\n        \"\"\"\n        compiled_ffi = self._backend.FFI()\n        allocator = compiled_ffi.new_allocator(alloc, free,\n                                               should_clear_after_alloc)\n        def allocate(cdecl, init=None):\n            if isinstance(cdecl, basestring):\n                cdecl = self._typeof(cdecl)\n            return allocator(cdecl, init)\n        return allocate\n\n    def cast(self, cdecl, source):\n        \"\"\"Similar to a C cast: returns an instance of the named C\n        type initialized with the given 'source'.  The source is\n        casted between integers or pointers of any type.\n        \"\"\"\n        if isinstance(cdecl, basestring):\n            cdecl = self._typeof(cdecl)\n        return self._backend.cast(cdecl, source)\n\n    def string(self, cdata, maxlen=-1):\n        \"\"\"Return a Python string (or unicode string) from the 'cdata'.\n        If 'cdata' is a pointer or array of characters or bytes, returns\n        the null-terminated string.  The returned string extends until\n        the first null character, or at most 'maxlen' characters.  If\n        'cdata' is an array then 'maxlen' defaults to its length.\n\n        If 'cdata' is a pointer or array of wchar_t, returns a unicode\n        string following the same rules.\n\n        If 'cdata' is a single character or byte or a wchar_t, returns\n        it as a string or unicode string.\n\n        If 'cdata' is an enum, returns the value of the enumerator as a\n        string, or 'NUMBER' if the value is out of range.\n        \"\"\"\n        return self._backend.string(cdata, maxlen)\n\n    def unpack(self, cdata, length):\n        \"\"\"Unpack an array of C data of the given length,\n        returning a Python string/unicode/list.\n\n        If 'cdata' is a pointer to 'char', returns a byte string.\n        It does not stop at the first null.  This is equivalent to:\n        ffi.buffer(cdata, length)[:]\n\n        If 'cdata' is a pointer to 'wchar_t', returns a unicode string.\n        'length' is measured in wchar_t's; it is not the size in bytes.\n\n        If 'cdata' is a pointer to anything else, returns a list of\n        'length' items.  This is a faster equivalent to:\n        [cdata[i] for i in range(length)]\n        \"\"\"\n        return self._backend.unpack(cdata, length)\n\n   #def buffer(self, cdata, size=-1):\n   #    \"\"\"Return a read-write buffer object that references the raw C data\n   #    pointed to by the given 'cdata'.  The 'cdata' must be a pointer or\n   #    an array.  Can be passed to functions expecting a buffer, or directly\n   #    manipulated with:\n   #\n   #        buf[:]          get a copy of it in a regular string, or\n   #        buf[idx]        as a single character\n   #        buf[:] = ...\n   #        buf[idx] = ...  change the content\n   #    \"\"\"\n   #    note that 'buffer' is a type, set on this instance by __init__\n\n    def from_buffer(self, cdecl, python_buffer=_unspecified,\n                    require_writable=False):\n        \"\"\"Return a cdata of the given type pointing to the data of the\n        given Python object, which must support the buffer interface.\n        Note that this is not meant to be used on the built-in types\n        str or unicode (you can build 'char[]' arrays explicitly)\n        but only on objects containing large quantities of raw data\n        in some other format, like 'array.array' or numpy arrays.\n\n        The first argument is optional and default to 'char[]'.\n        \"\"\"\n        if python_buffer is _unspecified:\n            cdecl, python_buffer = self.BCharA, cdecl\n        elif isinstance(cdecl, basestring):\n            cdecl = self._typeof(cdecl)\n        return self._backend.from_buffer(cdecl, python_buffer,\n                                         require_writable)\n\n    def memmove(self, dest, src, n):\n        \"\"\"ffi.memmove(dest, src, n) copies n bytes of memory from src to dest.\n\n        Like the C function memmove(), the memory areas may overlap;\n        apart from that it behaves like the C function memcpy().\n\n        'src' can be any cdata ptr or array, or any Python buffer object.\n        'dest' can be any cdata ptr or array, or a writable Python buffer\n        object.  The size to copy, 'n', is always measured in bytes.\n\n        Unlike other methods, this one supports all Python buffer including\n        byte strings and bytearrays---but it still does not support\n        non-contiguous buffers.\n        \"\"\"\n        return self._backend.memmove(dest, src, n)\n\n    def callback(self, cdecl, python_callable=None, error=None, onerror=None):\n        \"\"\"Return a callback object or a decorator making such a\n        callback object.  'cdecl' must name a C function pointer type.\n        The callback invokes the specified 'python_callable' (which may\n        be provided either directly or via a decorator).  Important: the\n        callback object must be manually kept alive for as long as the\n        callback may be invoked from the C level.\n        \"\"\"\n        def callback_decorator_wrap(python_callable):\n            if not callable(python_callable):\n                raise TypeError(\"the 'python_callable' argument \"\n                                \"is not callable\")\n            return self._backend.callback(cdecl, python_callable,\n                                          error, onerror)\n        if isinstance(cdecl, basestring):\n            cdecl = self._typeof(cdecl, consider_function_as_funcptr=True)\n        if python_callable is None:\n            return callback_decorator_wrap                # decorator mode\n        else:\n            return callback_decorator_wrap(python_callable)  # direct mode\n\n    def getctype(self, cdecl, replace_with=''):\n        \"\"\"Return a string giving the C type 'cdecl', which may be itself\n        a string or a <ctype> object.  If 'replace_with' is given, it gives\n        extra text to append (or insert for more complicated C types), like\n        a variable name, or '*' to get actually the C type 'pointer-to-cdecl'.\n        \"\"\"\n        if isinstance(cdecl, basestring):\n            cdecl = self._typeof(cdecl)\n        replace_with = replace_with.strip()\n        if (replace_with.startswith('*')\n                and '&[' in self._backend.getcname(cdecl, '&')):\n            replace_with = '(%s)' % replace_with\n        elif replace_with and not replace_with[0] in '[(':\n            replace_with = ' ' + replace_with\n        return self._backend.getcname(cdecl, replace_with)\n\n    def gc(self, cdata, destructor, size=0):\n        \"\"\"Return a new cdata object that points to the same\n        data.  Later, when this new cdata object is garbage-collected,\n        'destructor(old_cdata_object)' will be called.\n\n        The optional 'size' gives an estimate of the size, used to\n        trigger the garbage collection more eagerly.  So far only used\n        on PyPy.  It tells the GC that the returned object keeps alive\n        roughly 'size' bytes of external memory.\n        \"\"\"\n        return self._backend.gcp(cdata, destructor, size)\n\n    def _get_cached_btype(self, type):\n        assert self._lock.acquire(False) is False\n        # call me with the lock!\n        try:\n            BType = self._cached_btypes[type]\n        except KeyError:\n            finishlist = []\n            BType = type.get_cached_btype(self, finishlist)\n            for type in finishlist:\n                type.finish_backend_type(self, finishlist)\n        return BType\n\n    def verify(self, source='', tmpdir=None, **kwargs):\n        \"\"\"Verify that the current ffi signatures compile on this\n        machine, and return a dynamic library object.  The dynamic\n        library can be used to call functions and access global\n        variables declared in this 'ffi'.  The library is compiled\n        by the C compiler: it gives you C-level API compatibility\n        (including calling macros).  This is unlike 'ffi.dlopen()',\n        which requires binary compatibility in the signatures.\n        \"\"\"\n        from .verifier import Verifier, _caller_dir_pycache\n        #\n        # If set_unicode(True) was called, insert the UNICODE and\n        # _UNICODE macro declarations\n        if self._windows_unicode:\n            self._apply_windows_unicode(kwargs)\n        #\n        # Set the tmpdir here, and not in Verifier.__init__: it picks\n        # up the caller's directory, which we want to be the caller of\n        # ffi.verify(), as opposed to the caller of Veritier().\n        tmpdir = tmpdir or _caller_dir_pycache()\n        #\n        # Make a Verifier() and use it to load the library.\n        self.verifier = Verifier(self, source, tmpdir, **kwargs)\n        lib = self.verifier.load_library()\n        #\n        # Save the loaded library for keep-alive purposes, even\n        # if the caller doesn't keep it alive itself (it should).\n        self._libraries.append(lib)\n        return lib\n\n    def _get_errno(self):\n        return self._backend.get_errno()\n    def _set_errno(self, errno):\n        self._backend.set_errno(errno)\n    errno = property(_get_errno, _set_errno, None,\n                     \"the value of 'errno' from/to the C calls\")\n\n    def getwinerror(self, code=-1):\n        return self._backend.getwinerror(code)\n\n    def _pointer_to(self, ctype):\n        with self._lock:\n            return model.pointer_cache(self, ctype)\n\n    def addressof(self, cdata, *fields_or_indexes):\n        \"\"\"Return the address of a <cdata 'struct-or-union'>.\n        If 'fields_or_indexes' are given, returns the address of that\n        field or array item in the structure or array, recursively in\n        case of nested structures.\n        \"\"\"\n        try:\n            ctype = self._backend.typeof(cdata)\n        except TypeError:\n            if '__addressof__' in type(cdata).__dict__:\n                return type(cdata).__addressof__(cdata, *fields_or_indexes)\n            raise\n        if fields_or_indexes:\n            ctype, offset = self._typeoffsetof(ctype, *fields_or_indexes)\n        else:\n            if ctype.kind == \"pointer\":\n                raise TypeError(\"addressof(pointer)\")\n            offset = 0\n        ctypeptr = self._pointer_to(ctype)\n        return self._backend.rawaddressof(ctypeptr, cdata, offset)\n\n    def _typeoffsetof(self, ctype, field_or_index, *fields_or_indexes):\n        ctype, offset = self._backend.typeoffsetof(ctype, field_or_index)\n        for field1 in fields_or_indexes:\n            ctype, offset1 = self._backend.typeoffsetof(ctype, field1, 1)\n            offset += offset1\n        return ctype, offset\n\n    def include(self, ffi_to_include):\n        \"\"\"Includes the typedefs, structs, unions and enums defined\n        in another FFI instance.  Usage is similar to a #include in C,\n        where a part of the program might include types defined in\n        another part for its own usage.  Note that the include()\n        method has no effect on functions, constants and global\n        variables, which must anyway be accessed directly from the\n        lib object returned by the original FFI instance.\n        \"\"\"\n        if not isinstance(ffi_to_include, FFI):\n            raise TypeError(\"ffi.include() expects an argument that is also of\"\n                            \" type cffi.FFI, not %r\" % (\n                                type(ffi_to_include).__name__,))\n        if ffi_to_include is self:\n            raise ValueError(\"self.include(self)\")\n        with ffi_to_include._lock:\n            with self._lock:\n                self._parser.include(ffi_to_include._parser)\n                self._cdefsources.append('[')\n                self._cdefsources.extend(ffi_to_include._cdefsources)\n                self._cdefsources.append(']')\n                self._included_ffis.append(ffi_to_include)\n\n    def new_handle(self, x):\n        return self._backend.newp_handle(self.BVoidP, x)\n\n    def from_handle(self, x):\n        return self._backend.from_handle(x)\n\n    def release(self, x):\n        self._backend.release(x)\n\n    def set_unicode(self, enabled_flag):\n        \"\"\"Windows: if 'enabled_flag' is True, enable the UNICODE and\n        _UNICODE defines in C, and declare the types like TCHAR and LPTCSTR\n        to be (pointers to) wchar_t.  If 'enabled_flag' is False,\n        declare these types to be (pointers to) plain 8-bit characters.\n        This is mostly for backward compatibility; you usually want True.\n        \"\"\"\n        if self._windows_unicode is not None:\n            raise ValueError(\"set_unicode() can only be called once\")\n        enabled_flag = bool(enabled_flag)\n        if enabled_flag:\n            self.cdef(\"typedef wchar_t TBYTE;\"\n                      \"typedef wchar_t TCHAR;\"\n                      \"typedef const wchar_t *LPCTSTR;\"\n                      \"typedef const wchar_t *PCTSTR;\"\n                      \"typedef wchar_t *LPTSTR;\"\n                      \"typedef wchar_t *PTSTR;\"\n                      \"typedef TBYTE *PTBYTE;\"\n                      \"typedef TCHAR *PTCHAR;\")\n        else:\n            self.cdef(\"typedef char TBYTE;\"\n                      \"typedef char TCHAR;\"\n                      \"typedef const char *LPCTSTR;\"\n                      \"typedef const char *PCTSTR;\"\n                      \"typedef char *LPTSTR;\"\n                      \"typedef char *PTSTR;\"\n                      \"typedef TBYTE *PTBYTE;\"\n                      \"typedef TCHAR *PTCHAR;\")\n        self._windows_unicode = enabled_flag\n\n    def _apply_windows_unicode(self, kwds):\n        defmacros = kwds.get('define_macros', ())\n        if not isinstance(defmacros, (list, tuple)):\n            raise TypeError(\"'define_macros' must be a list or tuple\")\n        defmacros = list(defmacros) + [('UNICODE', '1'),\n                                       ('_UNICODE', '1')]\n        kwds['define_macros'] = defmacros\n\n    def _apply_embedding_fix(self, kwds):\n        # must include an argument like \"-lpython2.7\" for the compiler\n        def ensure(key, value):\n            lst = kwds.setdefault(key, [])\n            if value not in lst:\n                lst.append(value)\n        #\n        if '__pypy__' in sys.builtin_module_names:\n            import os\n            if sys.platform == \"win32\":\n                # we need 'libpypy-c.lib'.  Current distributions of\n                # pypy (>= 4.1) contain it as 'libs/python27.lib'.\n                pythonlib = \"python{0[0]}{0[1]}\".format(sys.version_info)\n                if hasattr(sys, 'prefix'):\n                    ensure('library_dirs', os.path.join(sys.prefix, 'libs'))\n            else:\n                # we need 'libpypy-c.{so,dylib}', which should be by\n                # default located in 'sys.prefix/bin' for installed\n                # systems.\n                if sys.version_info < (3,):\n                    pythonlib = \"pypy-c\"\n                else:\n                    pythonlib = \"pypy3-c\"\n                if hasattr(sys, 'prefix'):\n                    ensure('library_dirs', os.path.join(sys.prefix, 'bin'))\n            # On uninstalled pypy's, the libpypy-c is typically found in\n            # .../pypy/goal/.\n            if hasattr(sys, 'prefix'):\n                ensure('library_dirs', os.path.join(sys.prefix, 'pypy', 'goal'))\n        else:\n            if sys.platform == \"win32\":\n                template = \"python%d%d\"\n                if hasattr(sys, 'gettotalrefcount'):\n                    template += '_d'\n            else:\n                try:\n                    import sysconfig\n                except ImportError:    # 2.6\n                    from distutils import sysconfig\n                template = \"python%d.%d\"\n                if sysconfig.get_config_var('DEBUG_EXT'):\n                    template += sysconfig.get_config_var('DEBUG_EXT')\n            pythonlib = (template %\n                    (sys.hexversion >> 24, (sys.hexversion >> 16) & 0xff))\n            if hasattr(sys, 'abiflags'):\n                pythonlib += sys.abiflags\n        ensure('libraries', pythonlib)\n        if sys.platform == \"win32\":\n            ensure('extra_link_args', '/MANIFEST')\n\n    def set_source(self, module_name, source, source_extension='.c', **kwds):\n        import os\n        if hasattr(self, '_assigned_source'):\n            raise ValueError(\"set_source() cannot be called several times \"\n                             \"per ffi object\")\n        if not isinstance(module_name, basestring):\n            raise TypeError(\"'module_name' must be a string\")\n        if os.sep in module_name or (os.altsep and os.altsep in module_name):\n            raise ValueError(\"'module_name' must not contain '/': use a dotted \"\n                             \"name to make a 'package.module' location\")\n        self._assigned_source = (str(module_name), source,\n                                 source_extension, kwds)\n\n    def set_source_pkgconfig(self, module_name, pkgconfig_libs, source,\n                             source_extension='.c', **kwds):\n        from . import pkgconfig\n        if not isinstance(pkgconfig_libs, list):\n            raise TypeError(\"the pkgconfig_libs argument must be a list \"\n                            \"of package names\")\n        kwds2 = pkgconfig.flags_from_pkgconfig(pkgconfig_libs)\n        pkgconfig.merge_flags(kwds, kwds2)\n        self.set_source(module_name, source, source_extension, **kwds)\n\n    def distutils_extension(self, tmpdir='build', verbose=True):\n        from distutils.dir_util import mkpath\n        from .recompiler import recompile\n        #\n        if not hasattr(self, '_assigned_source'):\n            if hasattr(self, 'verifier'):     # fallback, 'tmpdir' ignored\n                return self.verifier.get_extension()\n            raise ValueError(\"set_source() must be called before\"\n                             \" distutils_extension()\")\n        module_name, source, source_extension, kwds = self._assigned_source\n        if source is None:\n            raise TypeError(\"distutils_extension() is only for C extension \"\n                            \"modules, not for dlopen()-style pure Python \"\n                            \"modules\")\n        mkpath(tmpdir)\n        ext, updated = recompile(self, module_name,\n                                 source, tmpdir=tmpdir, extradir=tmpdir,\n                                 source_extension=source_extension,\n                                 call_c_compiler=False, **kwds)\n        if verbose:\n            if updated:\n                sys.stderr.write(\"regenerated: %r\\n\" % (ext.sources[0],))\n            else:\n                sys.stderr.write(\"not modified: %r\\n\" % (ext.sources[0],))\n        return ext\n\n    def emit_c_code(self, filename):\n        from .recompiler import recompile\n        #\n        if not hasattr(self, '_assigned_source'):\n            raise ValueError(\"set_source() must be called before emit_c_code()\")\n        module_name, source, source_extension, kwds = self._assigned_source\n        if source is None:\n            raise TypeError(\"emit_c_code() is only for C extension modules, \"\n                            \"not for dlopen()-style pure Python modules\")\n        recompile(self, module_name, source,\n                  c_file=filename, call_c_compiler=False, **kwds)\n\n    def emit_python_code(self, filename):\n        from .recompiler import recompile\n        #\n        if not hasattr(self, '_assigned_source'):\n            raise ValueError(\"set_source() must be called before emit_c_code()\")\n        module_name, source, source_extension, kwds = self._assigned_source\n        if source is not None:\n            raise TypeError(\"emit_python_code() is only for dlopen()-style \"\n                            \"pure Python modules, not for C extension modules\")\n        recompile(self, module_name, source,\n                  c_file=filename, call_c_compiler=False, **kwds)\n\n    def compile(self, tmpdir='.', verbose=0, target=None, debug=None):\n        \"\"\"The 'target' argument gives the final file name of the\n        compiled DLL.  Use '*' to force distutils' choice, suitable for\n        regular CPython C API modules.  Use a file name ending in '.*'\n        to ask for the system's default extension for dynamic libraries\n        (.so/.dll/.dylib).\n\n        The default is '*' when building a non-embedded C API extension,\n        and (module_name + '.*') when building an embedded library.\n        \"\"\"\n        from .recompiler import recompile\n        #\n        if not hasattr(self, '_assigned_source'):\n            raise ValueError(\"set_source() must be called before compile()\")\n        module_name, source, source_extension, kwds = self._assigned_source\n        return recompile(self, module_name, source, tmpdir=tmpdir,\n                         target=target, source_extension=source_extension,\n                         compiler_verbose=verbose, debug=debug, **kwds)\n\n    def init_once(self, func, tag):\n        # Read _init_once_cache[tag], which is either (False, lock) if\n        # we're calling the function now in some thread, or (True, result).\n        # Don't call setdefault() in most cases, to avoid allocating and\n        # immediately freeing a lock; but still use setdefaut() to avoid\n        # races.\n        try:\n            x = self._init_once_cache[tag]\n        except KeyError:\n            x = self._init_once_cache.setdefault(tag, (False, allocate_lock()))\n        # Common case: we got (True, result), so we return the result.\n        if x[0]:\n            return x[1]\n        # Else, it's a lock.  Acquire it to serialize the following tests.\n        with x[1]:\n            # Read again from _init_once_cache the current status.\n            x = self._init_once_cache[tag]\n            if x[0]:\n                return x[1]\n            # Call the function and store the result back.\n            result = func()\n            self._init_once_cache[tag] = (True, result)\n        return result\n\n    def embedding_init_code(self, pysource):\n        if self._embedding:\n            raise ValueError(\"embedding_init_code() can only be called once\")\n        # fix 'pysource' before it gets dumped into the C file:\n        # - remove empty lines at the beginning, so it starts at \"line 1\"\n        # - dedent, if all non-empty lines are indented\n        # - check for SyntaxErrors\n        import re\n        match = re.match(r'\\s*\\n', pysource)\n        if match:\n            pysource = pysource[match.end():]\n        lines = pysource.splitlines() or ['']\n        prefix = re.match(r'\\s*', lines[0]).group()\n        for i in range(1, len(lines)):\n            line = lines[i]\n            if line.rstrip():\n                while not line.startswith(prefix):\n                    prefix = prefix[:-1]\n        i = len(prefix)\n        lines = [line[i:]+'\\n' for line in lines]\n        pysource = ''.join(lines)\n        #\n        compile(pysource, \"cffi_init\", \"exec\")\n        #\n        self._embedding = pysource\n\n    def def_extern(self, *args, **kwds):\n        raise ValueError(\"ffi.def_extern() is only available on API-mode FFI \"\n                         \"objects\")\n\n    def list_types(self):\n        \"\"\"Returns the user type names known to this FFI instance.\n        This returns a tuple containing three lists of names:\n        (typedef_names, names_of_structs, names_of_unions)\n        \"\"\"\n        typedefs = []\n        structs = []\n        unions = []\n        for key in self._parser._declarations:\n            if key.startswith('typedef '):\n                typedefs.append(key[8:])\n            elif key.startswith('struct '):\n                structs.append(key[7:])\n            elif key.startswith('union '):\n                unions.append(key[6:])\n        typedefs.sort()\n        structs.sort()\n        unions.sort()\n        return (typedefs, structs, unions)\n\n\ndef _load_backend_lib(backend, name, flags):\n    import os\n    if name is None:\n        if sys.platform != \"win32\":\n            return backend.load_library(None, flags)\n        name = \"c\"    # Windows: load_library(None) fails, but this works\n                      # on Python 2 (backward compatibility hack only)\n    first_error = None\n    if '.' in name or '/' in name or os.sep in name:\n        try:\n            return backend.load_library(name, flags)\n        except OSError as e:\n            first_error = e\n    import ctypes.util\n    path = ctypes.util.find_library(name)\n    if path is None:\n        if name == \"c\" and sys.platform == \"win32\" and sys.version_info >= (3,):\n            raise OSError(\"dlopen(None) cannot work on Windows for Python 3 \"\n                          \"(see http://bugs.python.org/issue23606)\")\n        msg = (\"ctypes.util.find_library() did not manage \"\n               \"to locate a library called %r\" % (name,))\n        if first_error is not None:\n            msg = \"%s.  Additionally, %s\" % (first_error, msg)\n        raise OSError(msg)\n    return backend.load_library(path, flags)\n\ndef _make_ffi_library(ffi, libname, flags):\n    backend = ffi._backend\n    backendlib = _load_backend_lib(backend, libname, flags)\n    #\n    def accessor_function(name):\n        key = 'function ' + name\n        tp, _ = ffi._parser._declarations[key]\n        BType = ffi._get_cached_btype(tp)\n        value = backendlib.load_function(BType, name)\n        library.__dict__[name] = value\n    #\n    def accessor_variable(name):\n        key = 'variable ' + name\n        tp, _ = ffi._parser._declarations[key]\n        BType = ffi._get_cached_btype(tp)\n        read_variable = backendlib.read_variable\n        write_variable = backendlib.write_variable\n        setattr(FFILibrary, name, property(\n            lambda self: read_variable(BType, name),\n            lambda self, value: write_variable(BType, name, value)))\n    #\n    def addressof_var(name):\n        try:\n            return addr_variables[name]\n        except KeyError:\n            with ffi._lock:\n                if name not in addr_variables:\n                    key = 'variable ' + name\n                    tp, _ = ffi._parser._declarations[key]\n                    BType = ffi._get_cached_btype(tp)\n                    if BType.kind != 'array':\n                        BType = model.pointer_cache(ffi, BType)\n                    p = backendlib.load_function(BType, name)\n                    addr_variables[name] = p\n            return addr_variables[name]\n    #\n    def accessor_constant(name):\n        raise NotImplementedError(\"non-integer constant '%s' cannot be \"\n                                  \"accessed from a dlopen() library\" % (name,))\n    #\n    def accessor_int_constant(name):\n        library.__dict__[name] = ffi._parser._int_constants[name]\n    #\n    accessors = {}\n    accessors_version = [False]\n    addr_variables = {}\n    #\n    def update_accessors():\n        if accessors_version[0] is ffi._cdef_version:\n            return\n        #\n        for key, (tp, _) in ffi._parser._declarations.items():\n            if not isinstance(tp, model.EnumType):\n                tag, name = key.split(' ', 1)\n                if tag == 'function':\n                    accessors[name] = accessor_function\n                elif tag == 'variable':\n                    accessors[name] = accessor_variable\n                elif tag == 'constant':\n                    accessors[name] = accessor_constant\n            else:\n                for i, enumname in enumerate(tp.enumerators):\n                    def accessor_enum(name, tp=tp, i=i):\n                        tp.check_not_partial()\n                        library.__dict__[name] = tp.enumvalues[i]\n                    accessors[enumname] = accessor_enum\n        for name in ffi._parser._int_constants:\n            accessors.setdefault(name, accessor_int_constant)\n        accessors_version[0] = ffi._cdef_version\n    #\n    def make_accessor(name):\n        with ffi._lock:\n            if name in library.__dict__ or name in FFILibrary.__dict__:\n                return    # added by another thread while waiting for the lock\n            if name not in accessors:\n                update_accessors()\n                if name not in accessors:\n                    raise AttributeError(name)\n            accessors[name](name)\n    #\n    class FFILibrary(object):\n        def __getattr__(self, name):\n            make_accessor(name)\n            return getattr(self, name)\n        def __setattr__(self, name, value):\n            try:\n                property = getattr(self.__class__, name)\n            except AttributeError:\n                make_accessor(name)\n                setattr(self, name, value)\n            else:\n                property.__set__(self, value)\n        def __dir__(self):\n            with ffi._lock:\n                update_accessors()\n                return accessors.keys()\n        def __addressof__(self, name):\n            if name in library.__dict__:\n                return library.__dict__[name]\n            if name in FFILibrary.__dict__:\n                return addressof_var(name)\n            make_accessor(name)\n            if name in library.__dict__:\n                return library.__dict__[name]\n            if name in FFILibrary.__dict__:\n                return addressof_var(name)\n            raise AttributeError(\"cffi library has no function or \"\n                                 \"global variable named '%s'\" % (name,))\n        def __cffi_close__(self):\n            backendlib.close_lib()\n            self.__dict__.clear()\n    #\n    if libname is not None:\n        try:\n            if not isinstance(libname, str):    # unicode, on Python 2\n                libname = libname.encode('utf-8')\n            FFILibrary.__name__ = 'FFILibrary_%s' % libname\n        except UnicodeError:\n            pass\n    library = FFILibrary()\n    return library, library.__dict__\n\ndef _builtin_function_type(func):\n    # a hack to make at least ffi.typeof(builtin_function) work,\n    # if the builtin function was obtained by 'vengine_cpy'.\n    import sys\n    try:\n        module = sys.modules[func.__module__]\n        ffi = module._cffi_original_ffi\n        types_of_builtin_funcs = module._cffi_types_of_builtin_funcs\n        tp = types_of_builtin_funcs[func]\n    except (KeyError, AttributeError, TypeError):\n        return None\n    else:\n        with ffi._lock:\n            return ffi._get_cached_btype(tp)\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.13.0-jlicqgsrlask3n7tsdckxmdwv6d5zp4o/spack-src/cffi/vengine_cpy.py": "#\n# DEPRECATED: implementation for ffi.verify()\n#\nimport sys, imp\nfrom . import model\nfrom .error import VerificationError\n\n\nclass VCPythonEngine(object):\n    _class_key = 'x'\n    _gen_python_module = True\n\n    def __init__(self, verifier):\n        self.verifier = verifier\n        self.ffi = verifier.ffi\n        self._struct_pending_verification = {}\n        self._types_of_builtin_functions = {}\n\n    def patch_extension_kwds(self, kwds):\n        pass\n\n    def find_module(self, module_name, path, so_suffixes):\n        try:\n            f, filename, descr = imp.find_module(module_name, path)\n        except ImportError:\n            return None\n        if f is not None:\n            f.close()\n        # Note that after a setuptools installation, there are both .py\n        # and .so files with the same basename.  The code here relies on\n        # imp.find_module() locating the .so in priority.\n        if descr[0] not in so_suffixes:\n            return None\n        return filename\n\n    def collect_types(self):\n        self._typesdict = {}\n        self._generate(\"collecttype\")\n\n    def _prnt(self, what=''):\n        self._f.write(what + '\\n')\n\n    def _gettypenum(self, type):\n        # a KeyError here is a bug.  please report it! :-)\n        return self._typesdict[type]\n\n    def _do_collect_type(self, tp):\n        if ((not isinstance(tp, model.PrimitiveType)\n             or tp.name == 'long double')\n                and tp not in self._typesdict):\n            num = len(self._typesdict)\n            self._typesdict[tp] = num\n\n    def write_source_to_f(self):\n        self.collect_types()\n        #\n        # The new module will have a _cffi_setup() function that receives\n        # objects from the ffi world, and that calls some setup code in\n        # the module.  This setup code is split in several independent\n        # functions, e.g. one per constant.  The functions are \"chained\"\n        # by ending in a tail call to each other.\n        #\n        # This is further split in two chained lists, depending on if we\n        # can do it at import-time or if we must wait for _cffi_setup() to\n        # provide us with the <ctype> objects.  This is needed because we\n        # need the values of the enum constants in order to build the\n        # <ctype 'enum'> that we may have to pass to _cffi_setup().\n        #\n        # The following two 'chained_list_constants' items contains\n        # the head of these two chained lists, as a string that gives the\n        # call to do, if any.\n        self._chained_list_constants = ['((void)lib,0)', '((void)lib,0)']\n        #\n        prnt = self._prnt\n        # first paste some standard set of lines that are mostly '#define'\n        prnt(cffimod_header)\n        prnt()\n        # then paste the C source given by the user, verbatim.\n        prnt(self.verifier.preamble)\n        prnt()\n        #\n        # call generate_cpy_xxx_decl(), for every xxx found from\n        # ffi._parser._declarations.  This generates all the functions.\n        self._generate(\"decl\")\n        #\n        # implement the function _cffi_setup_custom() as calling the\n        # head of the chained list.\n        self._generate_setup_custom()\n        prnt()\n        #\n        # produce the method table, including the entries for the\n        # generated Python->C function wrappers, which are done\n        # by generate_cpy_function_method().\n        prnt('static PyMethodDef _cffi_methods[] = {')\n        self._generate(\"method\")\n        prnt('  {\"_cffi_setup\", _cffi_setup, METH_VARARGS, NULL},')\n        prnt('  {NULL, NULL, 0, NULL}    /* Sentinel */')\n        prnt('};')\n        prnt()\n        #\n        # standard init.\n        modname = self.verifier.get_module_name()\n        constants = self._chained_list_constants[False]\n        prnt('#if PY_MAJOR_VERSION >= 3')\n        prnt()\n        prnt('static struct PyModuleDef _cffi_module_def = {')\n        prnt('  PyModuleDef_HEAD_INIT,')\n        prnt('  \"%s\",' % modname)\n        prnt('  NULL,')\n        prnt('  -1,')\n        prnt('  _cffi_methods,')\n        prnt('  NULL, NULL, NULL, NULL')\n        prnt('};')\n        prnt()\n        prnt('PyMODINIT_FUNC')\n        prnt('PyInit_%s(void)' % modname)\n        prnt('{')\n        prnt('  PyObject *lib;')\n        prnt('  lib = PyModule_Create(&_cffi_module_def);')\n        prnt('  if (lib == NULL)')\n        prnt('    return NULL;')\n        prnt('  if (%s < 0 || _cffi_init() < 0) {' % (constants,))\n        prnt('    Py_DECREF(lib);')\n        prnt('    return NULL;')\n        prnt('  }')\n        prnt('  return lib;')\n        prnt('}')\n        prnt()\n        prnt('#else')\n        prnt()\n        prnt('PyMODINIT_FUNC')\n        prnt('init%s(void)' % modname)\n        prnt('{')\n        prnt('  PyObject *lib;')\n        prnt('  lib = Py_InitModule(\"%s\", _cffi_methods);' % modname)\n        prnt('  if (lib == NULL)')\n        prnt('    return;')\n        prnt('  if (%s < 0 || _cffi_init() < 0)' % (constants,))\n        prnt('    return;')\n        prnt('  return;')\n        prnt('}')\n        prnt()\n        prnt('#endif')\n\n    def load_library(self, flags=None):\n        # XXX review all usages of 'self' here!\n        # import it as a new extension module\n        imp.acquire_lock()\n        try:\n            if hasattr(sys, \"getdlopenflags\"):\n                previous_flags = sys.getdlopenflags()\n            try:\n                if hasattr(sys, \"setdlopenflags\") and flags is not None:\n                    sys.setdlopenflags(flags)\n                module = imp.load_dynamic(self.verifier.get_module_name(),\n                                          self.verifier.modulefilename)\n            except ImportError as e:\n                error = \"importing %r: %s\" % (self.verifier.modulefilename, e)\n                raise VerificationError(error)\n            finally:\n                if hasattr(sys, \"setdlopenflags\"):\n                    sys.setdlopenflags(previous_flags)\n        finally:\n            imp.release_lock()\n        #\n        # call loading_cpy_struct() to get the struct layout inferred by\n        # the C compiler\n        self._load(module, 'loading')\n        #\n        # the C code will need the <ctype> objects.  Collect them in\n        # order in a list.\n        revmapping = dict([(value, key)\n                           for (key, value) in self._typesdict.items()])\n        lst = [revmapping[i] for i in range(len(revmapping))]\n        lst = list(map(self.ffi._get_cached_btype, lst))\n        #\n        # build the FFILibrary class and instance and call _cffi_setup().\n        # this will set up some fields like '_cffi_types', and only then\n        # it will invoke the chained list of functions that will really\n        # build (notably) the constant objects, as <cdata> if they are\n        # pointers, and store them as attributes on the 'library' object.\n        class FFILibrary(object):\n            _cffi_python_module = module\n            _cffi_ffi = self.ffi\n            _cffi_dir = []\n            def __dir__(self):\n                return FFILibrary._cffi_dir + list(self.__dict__)\n        library = FFILibrary()\n        if module._cffi_setup(lst, VerificationError, library):\n            import warnings\n            warnings.warn(\"reimporting %r might overwrite older definitions\"\n                          % (self.verifier.get_module_name()))\n        #\n        # finally, call the loaded_cpy_xxx() functions.  This will perform\n        # the final adjustments, like copying the Python->C wrapper\n        # functions from the module to the 'library' object, and setting\n        # up the FFILibrary class with properties for the global C variables.\n        self._load(module, 'loaded', library=library)\n        module._cffi_original_ffi = self.ffi\n        module._cffi_types_of_builtin_funcs = self._types_of_builtin_functions\n        return library\n\n    def _get_declarations(self):\n        lst = [(key, tp) for (key, (tp, qual)) in\n                                self.ffi._parser._declarations.items()]\n        lst.sort()\n        return lst\n\n    def _generate(self, step_name):\n        for name, tp in self._get_declarations():\n            kind, realname = name.split(' ', 1)\n            try:\n                method = getattr(self, '_generate_cpy_%s_%s' % (kind,\n                                                                step_name))\n            except AttributeError:\n                raise VerificationError(\n                    \"not implemented in verify(): %r\" % name)\n            try:\n                method(tp, realname)\n            except Exception as e:\n                model.attach_exception_info(e, name)\n                raise\n\n    def _load(self, module, step_name, **kwds):\n        for name, tp in self._get_declarations():\n            kind, realname = name.split(' ', 1)\n            method = getattr(self, '_%s_cpy_%s' % (step_name, kind))\n            try:\n                method(tp, realname, module, **kwds)\n            except Exception as e:\n                model.attach_exception_info(e, name)\n                raise\n\n    def _generate_nothing(self, tp, name):\n        pass\n\n    def _loaded_noop(self, tp, name, module, **kwds):\n        pass\n\n    # ----------\n\n    def _convert_funcarg_to_c(self, tp, fromvar, tovar, errcode):\n        extraarg = ''\n        if isinstance(tp, model.PrimitiveType):\n            if tp.is_integer_type() and tp.name != '_Bool':\n                converter = '_cffi_to_c_int'\n                extraarg = ', %s' % tp.name\n            else:\n                converter = '(%s)_cffi_to_c_%s' % (tp.get_c_name(''),\n                                                   tp.name.replace(' ', '_'))\n            errvalue = '-1'\n        #\n        elif isinstance(tp, model.PointerType):\n            self._convert_funcarg_to_c_ptr_or_array(tp, fromvar,\n                                                    tovar, errcode)\n            return\n        #\n        elif isinstance(tp, (model.StructOrUnion, model.EnumType)):\n            # a struct (not a struct pointer) as a function argument\n            self._prnt('  if (_cffi_to_c((char *)&%s, _cffi_type(%d), %s) < 0)'\n                      % (tovar, self._gettypenum(tp), fromvar))\n            self._prnt('    %s;' % errcode)\n            return\n        #\n        elif isinstance(tp, model.FunctionPtrType):\n            converter = '(%s)_cffi_to_c_pointer' % tp.get_c_name('')\n            extraarg = ', _cffi_type(%d)' % self._gettypenum(tp)\n            errvalue = 'NULL'\n        #\n        else:\n            raise NotImplementedError(tp)\n        #\n        self._prnt('  %s = %s(%s%s);' % (tovar, converter, fromvar, extraarg))\n        self._prnt('  if (%s == (%s)%s && PyErr_Occurred())' % (\n            tovar, tp.get_c_name(''), errvalue))\n        self._prnt('    %s;' % errcode)\n\n    def _extra_local_variables(self, tp, localvars):\n        if isinstance(tp, model.PointerType):\n            localvars.add('Py_ssize_t datasize')\n\n    def _convert_funcarg_to_c_ptr_or_array(self, tp, fromvar, tovar, errcode):\n        self._prnt('  datasize = _cffi_prepare_pointer_call_argument(')\n        self._prnt('      _cffi_type(%d), %s, (char **)&%s);' % (\n            self._gettypenum(tp), fromvar, tovar))\n        self._prnt('  if (datasize != 0) {')\n        self._prnt('    if (datasize < 0)')\n        self._prnt('      %s;' % errcode)\n        self._prnt('    %s = alloca((size_t)datasize);' % (tovar,))\n        self._prnt('    memset((void *)%s, 0, (size_t)datasize);' % (tovar,))\n        self._prnt('    if (_cffi_convert_array_from_object('\n                   '(char *)%s, _cffi_type(%d), %s) < 0)' % (\n            tovar, self._gettypenum(tp), fromvar))\n        self._prnt('      %s;' % errcode)\n        self._prnt('  }')\n\n    def _convert_expr_from_c(self, tp, var, context):\n        if isinstance(tp, model.PrimitiveType):\n            if tp.is_integer_type() and tp.name != '_Bool':\n                return '_cffi_from_c_int(%s, %s)' % (var, tp.name)\n            elif tp.name != 'long double':\n                return '_cffi_from_c_%s(%s)' % (tp.name.replace(' ', '_'), var)\n            else:\n                return '_cffi_from_c_deref((char *)&%s, _cffi_type(%d))' % (\n                    var, self._gettypenum(tp))\n        elif isinstance(tp, (model.PointerType, model.FunctionPtrType)):\n            return '_cffi_from_c_pointer((char *)%s, _cffi_type(%d))' % (\n                var, self._gettypenum(tp))\n        elif isinstance(tp, model.ArrayType):\n            return '_cffi_from_c_pointer((char *)%s, _cffi_type(%d))' % (\n                var, self._gettypenum(model.PointerType(tp.item)))\n        elif isinstance(tp, model.StructOrUnion):\n            if tp.fldnames is None:\n                raise TypeError(\"'%s' is used as %s, but is opaque\" % (\n                    tp._get_c_name(), context))\n            return '_cffi_from_c_struct((char *)&%s, _cffi_type(%d))' % (\n                var, self._gettypenum(tp))\n        elif isinstance(tp, model.EnumType):\n            return '_cffi_from_c_deref((char *)&%s, _cffi_type(%d))' % (\n                var, self._gettypenum(tp))\n        else:\n            raise NotImplementedError(tp)\n\n    # ----------\n    # typedefs: generates no code so far\n\n    _generate_cpy_typedef_collecttype = _generate_nothing\n    _generate_cpy_typedef_decl   = _generate_nothing\n    _generate_cpy_typedef_method = _generate_nothing\n    _loading_cpy_typedef         = _loaded_noop\n    _loaded_cpy_typedef          = _loaded_noop\n\n    # ----------\n    # function declarations\n\n    def _generate_cpy_function_collecttype(self, tp, name):\n        assert isinstance(tp, model.FunctionPtrType)\n        if tp.ellipsis:\n            self._do_collect_type(tp)\n        else:\n            # don't call _do_collect_type(tp) in this common case,\n            # otherwise test_autofilled_struct_as_argument fails\n            for type in tp.args:\n                self._do_collect_type(type)\n            self._do_collect_type(tp.result)\n\n    def _generate_cpy_function_decl(self, tp, name):\n        assert isinstance(tp, model.FunctionPtrType)\n        if tp.ellipsis:\n            # cannot support vararg functions better than this: check for its\n            # exact type (including the fixed arguments), and build it as a\n            # constant function pointer (no CPython wrapper)\n            self._generate_cpy_const(False, name, tp)\n            return\n        prnt = self._prnt\n        numargs = len(tp.args)\n        if numargs == 0:\n            argname = 'noarg'\n        elif numargs == 1:\n            argname = 'arg0'\n        else:\n            argname = 'args'\n        prnt('static PyObject *')\n        prnt('_cffi_f_%s(PyObject *self, PyObject *%s)' % (name, argname))\n        prnt('{')\n        #\n        context = 'argument of %s' % name\n        for i, type in enumerate(tp.args):\n            prnt('  %s;' % type.get_c_name(' x%d' % i, context))\n        #\n        localvars = set()\n        for type in tp.args:\n            self._extra_local_variables(type, localvars)\n        for decl in localvars:\n            prnt('  %s;' % (decl,))\n        #\n        if not isinstance(tp.result, model.VoidType):\n            result_code = 'result = '\n            context = 'result of %s' % name\n            prnt('  %s;' % tp.result.get_c_name(' result', context))\n        else:\n            result_code = ''\n        #\n        if len(tp.args) > 1:\n            rng = range(len(tp.args))\n            for i in rng:\n                prnt('  PyObject *arg%d;' % i)\n            prnt()\n            prnt('  if (!PyArg_ParseTuple(args, \"%s:%s\", %s))' % (\n                'O' * numargs, name, ', '.join(['&arg%d' % i for i in rng])))\n            prnt('    return NULL;')\n        prnt()\n        #\n        for i, type in enumerate(tp.args):\n            self._convert_funcarg_to_c(type, 'arg%d' % i, 'x%d' % i,\n                                       'return NULL')\n            prnt()\n        #\n        prnt('  Py_BEGIN_ALLOW_THREADS')\n        prnt('  _cffi_restore_errno();')\n        prnt('  { %s%s(%s); }' % (\n            result_code, name,\n            ', '.join(['x%d' % i for i in range(len(tp.args))])))\n        prnt('  _cffi_save_errno();')\n        prnt('  Py_END_ALLOW_THREADS')\n        prnt()\n        #\n        prnt('  (void)self; /* unused */')\n        if numargs == 0:\n            prnt('  (void)noarg; /* unused */')\n        if result_code:\n            prnt('  return %s;' %\n                 self._convert_expr_from_c(tp.result, 'result', 'result type'))\n        else:\n            prnt('  Py_INCREF(Py_None);')\n            prnt('  return Py_None;')\n        prnt('}')\n        prnt()\n\n    def _generate_cpy_function_method(self, tp, name):\n        if tp.ellipsis:\n            return\n        numargs = len(tp.args)\n        if numargs == 0:\n            meth = 'METH_NOARGS'\n        elif numargs == 1:\n            meth = 'METH_O'\n        else:\n            meth = 'METH_VARARGS'\n        self._prnt('  {\"%s\", _cffi_f_%s, %s, NULL},' % (name, name, meth))\n\n    _loading_cpy_function = _loaded_noop\n\n    def _loaded_cpy_function(self, tp, name, module, library):\n        if tp.ellipsis:\n            return\n        func = getattr(module, name)\n        setattr(library, name, func)\n        self._types_of_builtin_functions[func] = tp\n\n    # ----------\n    # named structs\n\n    _generate_cpy_struct_collecttype = _generate_nothing\n    def _generate_cpy_struct_decl(self, tp, name):\n        assert name == tp.name\n        self._generate_struct_or_union_decl(tp, 'struct', name)\n    def _generate_cpy_struct_method(self, tp, name):\n        self._generate_struct_or_union_method(tp, 'struct', name)\n    def _loading_cpy_struct(self, tp, name, module):\n        self._loading_struct_or_union(tp, 'struct', name, module)\n    def _loaded_cpy_struct(self, tp, name, module, **kwds):\n        self._loaded_struct_or_union(tp)\n\n    _generate_cpy_union_collecttype = _generate_nothing\n    def _generate_cpy_union_decl(self, tp, name):\n        assert name == tp.name\n        self._generate_struct_or_union_decl(tp, 'union', name)\n    def _generate_cpy_union_method(self, tp, name):\n        self._generate_struct_or_union_method(tp, 'union', name)\n    def _loading_cpy_union(self, tp, name, module):\n        self._loading_struct_or_union(tp, 'union', name, module)\n    def _loaded_cpy_union(self, tp, name, module, **kwds):\n        self._loaded_struct_or_union(tp)\n\n    def _generate_struct_or_union_decl(self, tp, prefix, name):\n        if tp.fldnames is None:\n            return     # nothing to do with opaque structs\n        checkfuncname = '_cffi_check_%s_%s' % (prefix, name)\n        layoutfuncname = '_cffi_layout_%s_%s' % (prefix, name)\n        cname = ('%s %s' % (prefix, name)).strip()\n        #\n        prnt = self._prnt\n        prnt('static void %s(%s *p)' % (checkfuncname, cname))\n        prnt('{')\n        prnt('  /* only to generate compile-time warnings or errors */')\n        prnt('  (void)p;')\n        for fname, ftype, fbitsize, fqual in tp.enumfields():\n            if (isinstance(ftype, model.PrimitiveType)\n                and ftype.is_integer_type()) or fbitsize >= 0:\n                # accept all integers, but complain on float or double\n                prnt('  (void)((p->%s) << 1);' % fname)\n            else:\n                # only accept exactly the type declared.\n                try:\n                    prnt('  { %s = &p->%s; (void)tmp; }' % (\n                        ftype.get_c_name('*tmp', 'field %r'%fname, quals=fqual),\n                        fname))\n                except VerificationError as e:\n                    prnt('  /* %s */' % str(e))   # cannot verify it, ignore\n        prnt('}')\n        prnt('static PyObject *')\n        prnt('%s(PyObject *self, PyObject *noarg)' % (layoutfuncname,))\n        prnt('{')\n        prnt('  struct _cffi_aligncheck { char x; %s y; };' % cname)\n        prnt('  static Py_ssize_t nums[] = {')\n        prnt('    sizeof(%s),' % cname)\n        prnt('    offsetof(struct _cffi_aligncheck, y),')\n        for fname, ftype, fbitsize, fqual in tp.enumfields():\n            if fbitsize >= 0:\n                continue      # xxx ignore fbitsize for now\n            prnt('    offsetof(%s, %s),' % (cname, fname))\n            if isinstance(ftype, model.ArrayType) and ftype.length is None:\n                prnt('    0,  /* %s */' % ftype._get_c_name())\n            else:\n                prnt('    sizeof(((%s *)0)->%s),' % (cname, fname))\n        prnt('    -1')\n        prnt('  };')\n        prnt('  (void)self; /* unused */')\n        prnt('  (void)noarg; /* unused */')\n        prnt('  return _cffi_get_struct_layout(nums);')\n        prnt('  /* the next line is not executed, but compiled */')\n        prnt('  %s(0);' % (checkfuncname,))\n        prnt('}')\n        prnt()\n\n    def _generate_struct_or_union_method(self, tp, prefix, name):\n        if tp.fldnames is None:\n            return     # nothing to do with opaque structs\n        layoutfuncname = '_cffi_layout_%s_%s' % (prefix, name)\n        self._prnt('  {\"%s\", %s, METH_NOARGS, NULL},' % (layoutfuncname,\n                                                         layoutfuncname))\n\n    def _loading_struct_or_union(self, tp, prefix, name, module):\n        if tp.fldnames is None:\n            return     # nothing to do with opaque structs\n        layoutfuncname = '_cffi_layout_%s_%s' % (prefix, name)\n        #\n        function = getattr(module, layoutfuncname)\n        layout = function()\n        if isinstance(tp, model.StructOrUnion) and tp.partial:\n            # use the function()'s sizes and offsets to guide the\n            # layout of the struct\n            totalsize = layout[0]\n            totalalignment = layout[1]\n            fieldofs = layout[2::2]\n            fieldsize = layout[3::2]\n            tp.force_flatten()\n            assert len(fieldofs) == len(fieldsize) == len(tp.fldnames)\n            tp.fixedlayout = fieldofs, fieldsize, totalsize, totalalignment\n        else:\n            cname = ('%s %s' % (prefix, name)).strip()\n            self._struct_pending_verification[tp] = layout, cname\n\n    def _loaded_struct_or_union(self, tp):\n        if tp.fldnames is None:\n            return     # nothing to do with opaque structs\n        self.ffi._get_cached_btype(tp)   # force 'fixedlayout' to be considered\n\n        if tp in self._struct_pending_verification:\n            # check that the layout sizes and offsets match the real ones\n            def check(realvalue, expectedvalue, msg):\n                if realvalue != expectedvalue:\n                    raise VerificationError(\n                        \"%s (we have %d, but C compiler says %d)\"\n                        % (msg, expectedvalue, realvalue))\n            ffi = self.ffi\n            BStruct = ffi._get_cached_btype(tp)\n            layout, cname = self._struct_pending_verification.pop(tp)\n            check(layout[0], ffi.sizeof(BStruct), \"wrong total size\")\n            check(layout[1], ffi.alignof(BStruct), \"wrong total alignment\")\n            i = 2\n            for fname, ftype, fbitsize, fqual in tp.enumfields():\n                if fbitsize >= 0:\n                    continue        # xxx ignore fbitsize for now\n                check(layout[i], ffi.offsetof(BStruct, fname),\n                      \"wrong offset for field %r\" % (fname,))\n                if layout[i+1] != 0:\n                    BField = ffi._get_cached_btype(ftype)\n                    check(layout[i+1], ffi.sizeof(BField),\n                          \"wrong size for field %r\" % (fname,))\n                i += 2\n            assert i == len(layout)\n\n    # ----------\n    # 'anonymous' declarations.  These are produced for anonymous structs\n    # or unions; the 'name' is obtained by a typedef.\n\n    _generate_cpy_anonymous_collecttype = _generate_nothing\n\n    def _generate_cpy_anonymous_decl(self, tp, name):\n        if isinstance(tp, model.EnumType):\n            self._generate_cpy_enum_decl(tp, name, '')\n        else:\n            self._generate_struct_or_union_decl(tp, '', name)\n\n    def _generate_cpy_anonymous_method(self, tp, name):\n        if not isinstance(tp, model.EnumType):\n            self._generate_struct_or_union_method(tp, '', name)\n\n    def _loading_cpy_anonymous(self, tp, name, module):\n        if isinstance(tp, model.EnumType):\n            self._loading_cpy_enum(tp, name, module)\n        else:\n            self._loading_struct_or_union(tp, '', name, module)\n\n    def _loaded_cpy_anonymous(self, tp, name, module, **kwds):\n        if isinstance(tp, model.EnumType):\n            self._loaded_cpy_enum(tp, name, module, **kwds)\n        else:\n            self._loaded_struct_or_union(tp)\n\n    # ----------\n    # constants, likely declared with '#define'\n\n    def _generate_cpy_const(self, is_int, name, tp=None, category='const',\n                            vartp=None, delayed=True, size_too=False,\n                            check_value=None):\n        prnt = self._prnt\n        funcname = '_cffi_%s_%s' % (category, name)\n        prnt('static int %s(PyObject *lib)' % funcname)\n        prnt('{')\n        prnt('  PyObject *o;')\n        prnt('  int res;')\n        if not is_int:\n            prnt('  %s;' % (vartp or tp).get_c_name(' i', name))\n        else:\n            assert category == 'const'\n        #\n        if check_value is not None:\n            self._check_int_constant_value(name, check_value)\n        #\n        if not is_int:\n            if category == 'var':\n                realexpr = '&' + name\n            else:\n                realexpr = name\n            prnt('  i = (%s);' % (realexpr,))\n            prnt('  o = %s;' % (self._convert_expr_from_c(tp, 'i',\n                                                          'variable type'),))\n            assert delayed\n        else:\n            prnt('  o = _cffi_from_c_int_const(%s);' % name)\n        prnt('  if (o == NULL)')\n        prnt('    return -1;')\n        if size_too:\n            prnt('  {')\n            prnt('    PyObject *o1 = o;')\n            prnt('    o = Py_BuildValue(\"On\", o1, (Py_ssize_t)sizeof(%s));'\n                 % (name,))\n            prnt('    Py_DECREF(o1);')\n            prnt('    if (o == NULL)')\n            prnt('      return -1;')\n            prnt('  }')\n        prnt('  res = PyObject_SetAttrString(lib, \"%s\", o);' % name)\n        prnt('  Py_DECREF(o);')\n        prnt('  if (res < 0)')\n        prnt('    return -1;')\n        prnt('  return %s;' % self._chained_list_constants[delayed])\n        self._chained_list_constants[delayed] = funcname + '(lib)'\n        prnt('}')\n        prnt()\n\n    def _generate_cpy_constant_collecttype(self, tp, name):\n        is_int = isinstance(tp, model.PrimitiveType) and tp.is_integer_type()\n        if not is_int:\n            self._do_collect_type(tp)\n\n    def _generate_cpy_constant_decl(self, tp, name):\n        is_int = isinstance(tp, model.PrimitiveType) and tp.is_integer_type()\n        self._generate_cpy_const(is_int, name, tp)\n\n    _generate_cpy_constant_method = _generate_nothing\n    _loading_cpy_constant = _loaded_noop\n    _loaded_cpy_constant  = _loaded_noop\n\n    # ----------\n    # enums\n\n    def _check_int_constant_value(self, name, value, err_prefix=''):\n        prnt = self._prnt\n        if value <= 0:\n            prnt('  if ((%s) > 0 || (long)(%s) != %dL) {' % (\n                name, name, value))\n        else:\n            prnt('  if ((%s) <= 0 || (unsigned long)(%s) != %dUL) {' % (\n                name, name, value))\n        prnt('    char buf[64];')\n        prnt('    if ((%s) <= 0)' % name)\n        prnt('        snprintf(buf, 63, \"%%ld\", (long)(%s));' % name)\n        prnt('    else')\n        prnt('        snprintf(buf, 63, \"%%lu\", (unsigned long)(%s));' %\n             name)\n        prnt('    PyErr_Format(_cffi_VerificationError,')\n        prnt('                 \"%s%s has the real value %s, not %s\",')\n        prnt('                 \"%s\", \"%s\", buf, \"%d\");' % (\n            err_prefix, name, value))\n        prnt('    return -1;')\n        prnt('  }')\n\n    def _enum_funcname(self, prefix, name):\n        # \"$enum_$1\" => \"___D_enum____D_1\"\n        name = name.replace('$', '___D_')\n        return '_cffi_e_%s_%s' % (prefix, name)\n\n    def _generate_cpy_enum_decl(self, tp, name, prefix='enum'):\n        if tp.partial:\n            for enumerator in tp.enumerators:\n                self._generate_cpy_const(True, enumerator, delayed=False)\n            return\n        #\n        funcname = self._enum_funcname(prefix, name)\n        prnt = self._prnt\n        prnt('static int %s(PyObject *lib)' % funcname)\n        prnt('{')\n        for enumerator, enumvalue in zip(tp.enumerators, tp.enumvalues):\n            self._check_int_constant_value(enumerator, enumvalue,\n                                           \"enum %s: \" % name)\n        prnt('  return %s;' % self._chained_list_constants[True])\n        self._chained_list_constants[True] = funcname + '(lib)'\n        prnt('}')\n        prnt()\n\n    _generate_cpy_enum_collecttype = _generate_nothing\n    _generate_cpy_enum_method = _generate_nothing\n\n    def _loading_cpy_enum(self, tp, name, module):\n        if tp.partial:\n            enumvalues = [getattr(module, enumerator)\n                          for enumerator in tp.enumerators]\n            tp.enumvalues = tuple(enumvalues)\n            tp.partial_resolved = True\n\n    def _loaded_cpy_enum(self, tp, name, module, library):\n        for enumerator, enumvalue in zip(tp.enumerators, tp.enumvalues):\n            setattr(library, enumerator, enumvalue)\n\n    # ----------\n    # macros: for now only for integers\n\n    def _generate_cpy_macro_decl(self, tp, name):\n        if tp == '...':\n            check_value = None\n        else:\n            check_value = tp     # an integer\n        self._generate_cpy_const(True, name, check_value=check_value)\n\n    _generate_cpy_macro_collecttype = _generate_nothing\n    _generate_cpy_macro_method = _generate_nothing\n    _loading_cpy_macro = _loaded_noop\n    _loaded_cpy_macro  = _loaded_noop\n\n    # ----------\n    # global variables\n\n    def _generate_cpy_variable_collecttype(self, tp, name):\n        if isinstance(tp, model.ArrayType):\n            tp_ptr = model.PointerType(tp.item)\n        else:\n            tp_ptr = model.PointerType(tp)\n        self._do_collect_type(tp_ptr)\n\n    def _generate_cpy_variable_decl(self, tp, name):\n        if isinstance(tp, model.ArrayType):\n            tp_ptr = model.PointerType(tp.item)\n            self._generate_cpy_const(False, name, tp, vartp=tp_ptr,\n                                     size_too = (tp.length == '...'))\n        else:\n            tp_ptr = model.PointerType(tp)\n            self._generate_cpy_const(False, name, tp_ptr, category='var')\n\n    _generate_cpy_variable_method = _generate_nothing\n    _loading_cpy_variable = _loaded_noop\n\n    def _loaded_cpy_variable(self, tp, name, module, library):\n        value = getattr(library, name)\n        if isinstance(tp, model.ArrayType):   # int a[5] is \"constant\" in the\n                                              # sense that \"a=...\" is forbidden\n            if tp.length == '...':\n                assert isinstance(value, tuple)\n                (value, size) = value\n                BItemType = self.ffi._get_cached_btype(tp.item)\n                length, rest = divmod(size, self.ffi.sizeof(BItemType))\n                if rest != 0:\n                    raise VerificationError(\n                        \"bad size: %r does not seem to be an array of %s\" %\n                        (name, tp.item))\n                tp = tp.resolve_length(length)\n            # 'value' is a <cdata 'type *'> which we have to replace with\n            # a <cdata 'type[N]'> if the N is actually known\n            if tp.length is not None:\n                BArray = self.ffi._get_cached_btype(tp)\n                value = self.ffi.cast(BArray, value)\n                setattr(library, name, value)\n            return\n        # remove ptr=<cdata 'int *'> from the library instance, and replace\n        # it by a property on the class, which reads/writes into ptr[0].\n        ptr = value\n        delattr(library, name)\n        def getter(library):\n            return ptr[0]\n        def setter(library, value):\n            ptr[0] = value\n        setattr(type(library), name, property(getter, setter))\n        type(library)._cffi_dir.append(name)\n\n    # ----------\n\n    def _generate_setup_custom(self):\n        prnt = self._prnt\n        prnt('static int _cffi_setup_custom(PyObject *lib)')\n        prnt('{')\n        prnt('  return %s;' % self._chained_list_constants[True])\n        prnt('}')\n\ncffimod_header = r'''\n#include <Python.h>\n#include <stddef.h>\n\n/* this block of #ifs should be kept exactly identical between\n   c/_cffi_backend.c, cffi/vengine_cpy.py, cffi/vengine_gen.py\n   and cffi/_cffi_include.h */\n#if defined(_MSC_VER)\n# include <malloc.h>   /* for alloca() */\n# if _MSC_VER < 1600   /* MSVC < 2010 */\n   typedef __int8 int8_t;\n   typedef __int16 int16_t;\n   typedef __int32 int32_t;\n   typedef __int64 int64_t;\n   typedef unsigned __int8 uint8_t;\n   typedef unsigned __int16 uint16_t;\n   typedef unsigned __int32 uint32_t;\n   typedef unsigned __int64 uint64_t;\n   typedef __int8 int_least8_t;\n   typedef __int16 int_least16_t;\n   typedef __int32 int_least32_t;\n   typedef __int64 int_least64_t;\n   typedef unsigned __int8 uint_least8_t;\n   typedef unsigned __int16 uint_least16_t;\n   typedef unsigned __int32 uint_least32_t;\n   typedef unsigned __int64 uint_least64_t;\n   typedef __int8 int_fast8_t;\n   typedef __int16 int_fast16_t;\n   typedef __int32 int_fast32_t;\n   typedef __int64 int_fast64_t;\n   typedef unsigned __int8 uint_fast8_t;\n   typedef unsigned __int16 uint_fast16_t;\n   typedef unsigned __int32 uint_fast32_t;\n   typedef unsigned __int64 uint_fast64_t;\n   typedef __int64 intmax_t;\n   typedef unsigned __int64 uintmax_t;\n# else\n#  include <stdint.h>\n# endif\n# if _MSC_VER < 1800   /* MSVC < 2013 */\n#  ifndef __cplusplus\n    typedef unsigned char _Bool;\n#  endif\n# endif\n#else\n# include <stdint.h>\n# if (defined (__SVR4) && defined (__sun)) || defined(_AIX) || defined(__hpux)\n#  include <alloca.h>\n# endif\n#endif\n\n#if PY_MAJOR_VERSION < 3\n# undef PyCapsule_CheckExact\n# undef PyCapsule_GetPointer\n# define PyCapsule_CheckExact(capsule) (PyCObject_Check(capsule))\n# define PyCapsule_GetPointer(capsule, name) \\\n    (PyCObject_AsVoidPtr(capsule))\n#endif\n\n#if PY_MAJOR_VERSION >= 3\n# define PyInt_FromLong PyLong_FromLong\n#endif\n\n#define _cffi_from_c_double PyFloat_FromDouble\n#define _cffi_from_c_float PyFloat_FromDouble\n#define _cffi_from_c_long PyInt_FromLong\n#define _cffi_from_c_ulong PyLong_FromUnsignedLong\n#define _cffi_from_c_longlong PyLong_FromLongLong\n#define _cffi_from_c_ulonglong PyLong_FromUnsignedLongLong\n#define _cffi_from_c__Bool PyBool_FromLong\n\n#define _cffi_to_c_double PyFloat_AsDouble\n#define _cffi_to_c_float PyFloat_AsDouble\n\n#define _cffi_from_c_int_const(x)                                        \\\n    (((x) > 0) ?                                                         \\\n        ((unsigned long long)(x) <= (unsigned long long)LONG_MAX) ?      \\\n            PyInt_FromLong((long)(x)) :                                  \\\n            PyLong_FromUnsignedLongLong((unsigned long long)(x)) :       \\\n        ((long long)(x) >= (long long)LONG_MIN) ?                        \\\n            PyInt_FromLong((long)(x)) :                                  \\\n            PyLong_FromLongLong((long long)(x)))\n\n#define _cffi_from_c_int(x, type)                                        \\\n    (((type)-1) > 0 ? /* unsigned */                                     \\\n        (sizeof(type) < sizeof(long) ?                                   \\\n            PyInt_FromLong((long)x) :                                    \\\n         sizeof(type) == sizeof(long) ?                                  \\\n            PyLong_FromUnsignedLong((unsigned long)x) :                  \\\n            PyLong_FromUnsignedLongLong((unsigned long long)x)) :        \\\n        (sizeof(type) <= sizeof(long) ?                                  \\\n            PyInt_FromLong((long)x) :                                    \\\n            PyLong_FromLongLong((long long)x)))\n\n#define _cffi_to_c_int(o, type)                                          \\\n    ((type)(                                                             \\\n     sizeof(type) == 1 ? (((type)-1) > 0 ? (type)_cffi_to_c_u8(o)        \\\n                                         : (type)_cffi_to_c_i8(o)) :     \\\n     sizeof(type) == 2 ? (((type)-1) > 0 ? (type)_cffi_to_c_u16(o)       \\\n                                         : (type)_cffi_to_c_i16(o)) :    \\\n     sizeof(type) == 4 ? (((type)-1) > 0 ? (type)_cffi_to_c_u32(o)       \\\n                                         : (type)_cffi_to_c_i32(o)) :    \\\n     sizeof(type) == 8 ? (((type)-1) > 0 ? (type)_cffi_to_c_u64(o)       \\\n                                         : (type)_cffi_to_c_i64(o)) :    \\\n     (Py_FatalError(\"unsupported size for type \" #type), (type)0)))\n\n#define _cffi_to_c_i8                                                    \\\n                 ((int(*)(PyObject *))_cffi_exports[1])\n#define _cffi_to_c_u8                                                    \\\n                 ((int(*)(PyObject *))_cffi_exports[2])\n#define _cffi_to_c_i16                                                   \\\n                 ((int(*)(PyObject *))_cffi_exports[3])\n#define _cffi_to_c_u16                                                   \\\n                 ((int(*)(PyObject *))_cffi_exports[4])\n#define _cffi_to_c_i32                                                   \\\n                 ((int(*)(PyObject *))_cffi_exports[5])\n#define _cffi_to_c_u32                                                   \\\n                 ((unsigned int(*)(PyObject *))_cffi_exports[6])\n#define _cffi_to_c_i64                                                   \\\n                 ((long long(*)(PyObject *))_cffi_exports[7])\n#define _cffi_to_c_u64                                                   \\\n                 ((unsigned long long(*)(PyObject *))_cffi_exports[8])\n#define _cffi_to_c_char                                                  \\\n                 ((int(*)(PyObject *))_cffi_exports[9])\n#define _cffi_from_c_pointer                                             \\\n    ((PyObject *(*)(char *, CTypeDescrObject *))_cffi_exports[10])\n#define _cffi_to_c_pointer                                               \\\n    ((char *(*)(PyObject *, CTypeDescrObject *))_cffi_exports[11])\n#define _cffi_get_struct_layout                                          \\\n    ((PyObject *(*)(Py_ssize_t[]))_cffi_exports[12])\n#define _cffi_restore_errno                                              \\\n    ((void(*)(void))_cffi_exports[13])\n#define _cffi_save_errno                                                 \\\n    ((void(*)(void))_cffi_exports[14])\n#define _cffi_from_c_char                                                \\\n    ((PyObject *(*)(char))_cffi_exports[15])\n#define _cffi_from_c_deref                                               \\\n    ((PyObject *(*)(char *, CTypeDescrObject *))_cffi_exports[16])\n#define _cffi_to_c                                                       \\\n    ((int(*)(char *, CTypeDescrObject *, PyObject *))_cffi_exports[17])\n#define _cffi_from_c_struct                                              \\\n    ((PyObject *(*)(char *, CTypeDescrObject *))_cffi_exports[18])\n#define _cffi_to_c_wchar_t                                               \\\n    ((wchar_t(*)(PyObject *))_cffi_exports[19])\n#define _cffi_from_c_wchar_t                                             \\\n    ((PyObject *(*)(wchar_t))_cffi_exports[20])\n#define _cffi_to_c_long_double                                           \\\n    ((long double(*)(PyObject *))_cffi_exports[21])\n#define _cffi_to_c__Bool                                                 \\\n    ((_Bool(*)(PyObject *))_cffi_exports[22])\n#define _cffi_prepare_pointer_call_argument                              \\\n    ((Py_ssize_t(*)(CTypeDescrObject *, PyObject *, char **))_cffi_exports[23])\n#define _cffi_convert_array_from_object                                  \\\n    ((int(*)(char *, CTypeDescrObject *, PyObject *))_cffi_exports[24])\n#define _CFFI_NUM_EXPORTS 25\n\ntypedef struct _ctypedescr CTypeDescrObject;\n\nstatic void *_cffi_exports[_CFFI_NUM_EXPORTS];\nstatic PyObject *_cffi_types, *_cffi_VerificationError;\n\nstatic int _cffi_setup_custom(PyObject *lib);   /* forward */\n\nstatic PyObject *_cffi_setup(PyObject *self, PyObject *args)\n{\n    PyObject *library;\n    int was_alive = (_cffi_types != NULL);\n    (void)self; /* unused */\n    if (!PyArg_ParseTuple(args, \"OOO\", &_cffi_types, &_cffi_VerificationError,\n                                       &library))\n        return NULL;\n    Py_INCREF(_cffi_types);\n    Py_INCREF(_cffi_VerificationError);\n    if (_cffi_setup_custom(library) < 0)\n        return NULL;\n    return PyBool_FromLong(was_alive);\n}\n\nstatic int _cffi_init(void)\n{\n    PyObject *module, *c_api_object = NULL;\n\n    module = PyImport_ImportModule(\"_cffi_backend\");\n    if (module == NULL)\n        goto failure;\n\n    c_api_object = PyObject_GetAttrString(module, \"_C_API\");\n    if (c_api_object == NULL)\n        goto failure;\n    if (!PyCapsule_CheckExact(c_api_object)) {\n        PyErr_SetNone(PyExc_ImportError);\n        goto failure;\n    }\n    memcpy(_cffi_exports, PyCapsule_GetPointer(c_api_object, \"cffi\"),\n           _CFFI_NUM_EXPORTS * sizeof(void *));\n\n    Py_DECREF(module);\n    Py_DECREF(c_api_object);\n    return 0;\n\n  failure:\n    Py_XDECREF(module);\n    Py_XDECREF(c_api_object);\n    return -1;\n}\n\n#define _cffi_type(num) ((CTypeDescrObject *)PyList_GET_ITEM(_cffi_types, num))\n\n/**********/\n'''\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.13.0-jlicqgsrlask3n7tsdckxmdwv6d5zp4o/spack-src/cffi/verifier.py": "#\n# DEPRECATED: implementation for ffi.verify()\n#\nimport sys, os, binascii, shutil, io\nfrom . import __version_verifier_modules__\nfrom . import ffiplatform\nfrom .error import VerificationError\n\nif sys.version_info >= (3, 3):\n    import importlib.machinery\n    def _extension_suffixes():\n        return importlib.machinery.EXTENSION_SUFFIXES[:]\nelse:\n    import imp\n    def _extension_suffixes():\n        return [suffix for suffix, _, type in imp.get_suffixes()\n                if type == imp.C_EXTENSION]\n\n\nif sys.version_info >= (3,):\n    NativeIO = io.StringIO\nelse:\n    class NativeIO(io.BytesIO):\n        def write(self, s):\n            if isinstance(s, unicode):\n                s = s.encode('ascii')\n            super(NativeIO, self).write(s)\n\n\nclass Verifier(object):\n\n    def __init__(self, ffi, preamble, tmpdir=None, modulename=None,\n                 ext_package=None, tag='', force_generic_engine=False,\n                 source_extension='.c', flags=None, relative_to=None, **kwds):\n        if ffi._parser._uses_new_feature:\n            raise VerificationError(\n                \"feature not supported with ffi.verify(), but only \"\n                \"with ffi.set_source(): %s\" % (ffi._parser._uses_new_feature,))\n        self.ffi = ffi\n        self.preamble = preamble\n        if not modulename:\n            flattened_kwds = ffiplatform.flatten(kwds)\n        vengine_class = _locate_engine_class(ffi, force_generic_engine)\n        self._vengine = vengine_class(self)\n        self._vengine.patch_extension_kwds(kwds)\n        self.flags = flags\n        self.kwds = self.make_relative_to(kwds, relative_to)\n        #\n        if modulename:\n            if tag:\n                raise TypeError(\"can't specify both 'modulename' and 'tag'\")\n        else:\n            key = '\\x00'.join([sys.version[:3], __version_verifier_modules__,\n                               preamble, flattened_kwds] +\n                              ffi._cdefsources)\n            if sys.version_info >= (3,):\n                key = key.encode('utf-8')\n            k1 = hex(binascii.crc32(key[0::2]) & 0xffffffff)\n            k1 = k1.lstrip('0x').rstrip('L')\n            k2 = hex(binascii.crc32(key[1::2]) & 0xffffffff)\n            k2 = k2.lstrip('0').rstrip('L')\n            modulename = '_cffi_%s_%s%s%s' % (tag, self._vengine._class_key,\n                                              k1, k2)\n        suffix = _get_so_suffixes()[0]\n        self.tmpdir = tmpdir or _caller_dir_pycache()\n        self.sourcefilename = os.path.join(self.tmpdir, modulename + source_extension)\n        self.modulefilename = os.path.join(self.tmpdir, modulename + suffix)\n        self.ext_package = ext_package\n        self._has_source = False\n        self._has_module = False\n\n    def write_source(self, file=None):\n        \"\"\"Write the C source code.  It is produced in 'self.sourcefilename',\n        which can be tweaked beforehand.\"\"\"\n        with self.ffi._lock:\n            if self._has_source and file is None:\n                raise VerificationError(\n                    \"source code already written\")\n            self._write_source(file)\n\n    def compile_module(self):\n        \"\"\"Write the C source code (if not done already) and compile it.\n        This produces a dynamic link library in 'self.modulefilename'.\"\"\"\n        with self.ffi._lock:\n            if self._has_module:\n                raise VerificationError(\"module already compiled\")\n            if not self._has_source:\n                self._write_source()\n            self._compile_module()\n\n    def load_library(self):\n        \"\"\"Get a C module from this Verifier instance.\n        Returns an instance of a FFILibrary class that behaves like the\n        objects returned by ffi.dlopen(), but that delegates all\n        operations to the C module.  If necessary, the C code is written\n        and compiled first.\n        \"\"\"\n        with self.ffi._lock:\n            if not self._has_module:\n                self._locate_module()\n                if not self._has_module:\n                    if not self._has_source:\n                        self._write_source()\n                    self._compile_module()\n            return self._load_library()\n\n    def get_module_name(self):\n        basename = os.path.basename(self.modulefilename)\n        # kill both the .so extension and the other .'s, as introduced\n        # by Python 3: 'basename.cpython-33m.so'\n        basename = basename.split('.', 1)[0]\n        # and the _d added in Python 2 debug builds --- but try to be\n        # conservative and not kill a legitimate _d\n        if basename.endswith('_d') and hasattr(sys, 'gettotalrefcount'):\n            basename = basename[:-2]\n        return basename\n\n    def get_extension(self):\n        ffiplatform._hack_at_distutils() # backward compatibility hack\n        if not self._has_source:\n            with self.ffi._lock:\n                if not self._has_source:\n                    self._write_source()\n        sourcename = ffiplatform.maybe_relative_path(self.sourcefilename)\n        modname = self.get_module_name()\n        return ffiplatform.get_extension(sourcename, modname, **self.kwds)\n\n    def generates_python_module(self):\n        return self._vengine._gen_python_module\n\n    def make_relative_to(self, kwds, relative_to):\n        if relative_to and os.path.dirname(relative_to):\n            dirname = os.path.dirname(relative_to)\n            kwds = kwds.copy()\n            for key in ffiplatform.LIST_OF_FILE_NAMES:\n                if key in kwds:\n                    lst = kwds[key]\n                    if not isinstance(lst, (list, tuple)):\n                        raise TypeError(\"keyword '%s' should be a list or tuple\"\n                                        % (key,))\n                    lst = [os.path.join(dirname, fn) for fn in lst]\n                    kwds[key] = lst\n        return kwds\n\n    # ----------\n\n    def _locate_module(self):\n        if not os.path.isfile(self.modulefilename):\n            if self.ext_package:\n                try:\n                    pkg = __import__(self.ext_package, None, None, ['__doc__'])\n                except ImportError:\n                    return      # cannot import the package itself, give up\n                    # (e.g. it might be called differently before installation)\n                path = pkg.__path__\n            else:\n                path = None\n            filename = self._vengine.find_module(self.get_module_name(), path,\n                                                 _get_so_suffixes())\n            if filename is None:\n                return\n            self.modulefilename = filename\n        self._vengine.collect_types()\n        self._has_module = True\n\n    def _write_source_to(self, file):\n        self._vengine._f = file\n        try:\n            self._vengine.write_source_to_f()\n        finally:\n            del self._vengine._f\n\n    def _write_source(self, file=None):\n        if file is not None:\n            self._write_source_to(file)\n        else:\n            # Write our source file to an in memory file.\n            f = NativeIO()\n            self._write_source_to(f)\n            source_data = f.getvalue()\n\n            # Determine if this matches the current file\n            if os.path.exists(self.sourcefilename):\n                with open(self.sourcefilename, \"r\") as fp:\n                    needs_written = not (fp.read() == source_data)\n            else:\n                needs_written = True\n\n            # Actually write the file out if it doesn't match\n            if needs_written:\n                _ensure_dir(self.sourcefilename)\n                with open(self.sourcefilename, \"w\") as fp:\n                    fp.write(source_data)\n\n            # Set this flag\n            self._has_source = True\n\n    def _compile_module(self):\n        # compile this C source\n        tmpdir = os.path.dirname(self.sourcefilename)\n        outputfilename = ffiplatform.compile(tmpdir, self.get_extension())\n        try:\n            same = ffiplatform.samefile(outputfilename, self.modulefilename)\n        except OSError:\n            same = False\n        if not same:\n            _ensure_dir(self.modulefilename)\n            shutil.move(outputfilename, self.modulefilename)\n        self._has_module = True\n\n    def _load_library(self):\n        assert self._has_module\n        if self.flags is not None:\n            return self._vengine.load_library(self.flags)\n        else:\n            return self._vengine.load_library()\n\n# ____________________________________________________________\n\n_FORCE_GENERIC_ENGINE = False      # for tests\n\ndef _locate_engine_class(ffi, force_generic_engine):\n    if _FORCE_GENERIC_ENGINE:\n        force_generic_engine = True\n    if not force_generic_engine:\n        if '__pypy__' in sys.builtin_module_names:\n            force_generic_engine = True\n        else:\n            try:\n                import _cffi_backend\n            except ImportError:\n                _cffi_backend = '?'\n            if ffi._backend is not _cffi_backend:\n                force_generic_engine = True\n    if force_generic_engine:\n        from . import vengine_gen\n        return vengine_gen.VGenericEngine\n    else:\n        from . import vengine_cpy\n        return vengine_cpy.VCPythonEngine\n\n# ____________________________________________________________\n\n_TMPDIR = None\n\ndef _caller_dir_pycache():\n    if _TMPDIR:\n        return _TMPDIR\n    result = os.environ.get('CFFI_TMPDIR')\n    if result:\n        return result\n    filename = sys._getframe(2).f_code.co_filename\n    return os.path.abspath(os.path.join(os.path.dirname(filename),\n                           '__pycache__'))\n\ndef set_tmpdir(dirname):\n    \"\"\"Set the temporary directory to use instead of __pycache__.\"\"\"\n    global _TMPDIR\n    _TMPDIR = dirname\n\ndef cleanup_tmpdir(tmpdir=None, keep_so=False):\n    \"\"\"Clean up the temporary directory by removing all files in it\n    called `_cffi_*.{c,so}` as well as the `build` subdirectory.\"\"\"\n    tmpdir = tmpdir or _caller_dir_pycache()\n    try:\n        filelist = os.listdir(tmpdir)\n    except OSError:\n        return\n    if keep_so:\n        suffix = '.c'   # only remove .c files\n    else:\n        suffix = _get_so_suffixes()[0].lower()\n    for fn in filelist:\n        if fn.lower().startswith('_cffi_') and (\n                fn.lower().endswith(suffix) or fn.lower().endswith('.c')):\n            try:\n                os.unlink(os.path.join(tmpdir, fn))\n            except OSError:\n                pass\n    clean_dir = [os.path.join(tmpdir, 'build')]\n    for dir in clean_dir:\n        try:\n            for fn in os.listdir(dir):\n                fn = os.path.join(dir, fn)\n                if os.path.isdir(fn):\n                    clean_dir.append(fn)\n                else:\n                    os.unlink(fn)\n        except OSError:\n            pass\n\ndef _get_so_suffixes():\n    suffixes = _extension_suffixes()\n    if not suffixes:\n        # bah, no C_EXTENSION available.  Occurs on pypy without cpyext\n        if sys.platform == 'win32':\n            suffixes = [\".pyd\"]\n        else:\n            suffixes = [\".so\"]\n\n    return suffixes\n\ndef _ensure_dir(filename):\n    dirname = os.path.dirname(filename)\n    if dirname and not os.path.isdir(dirname):\n        os.makedirs(dirname)\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.13.0-jlicqgsrlask3n7tsdckxmdwv6d5zp4o/spack-src/c/ffi_obj.c": "\n/* An FFI object has methods like ffi.new().  It is also a container\n   for the type declarations (typedefs and structs) that you can use,\n   say in ffi.new().\n\n   CTypeDescrObjects are internally stored in the dict 'types_dict'.\n   The types_dict is lazily filled with CTypeDescrObjects made from\n   reading a _cffi_type_context_s structure.\n\n   In \"modern\" mode, the FFI instance is made by the C extension\n   module originally created by recompile().  The _cffi_type_context_s\n   structure comes from global data in the C extension module.\n\n   In \"compatibility\" mode, an FFI instance is created explicitly by\n   the user, and its _cffi_type_context_s is initially empty.  You\n   need to call ffi.cdef() to add more information to it.\n*/\n\n#define FFI_COMPLEXITY_OUTPUT   1200     /* xxx should grow as needed */\n\n#define FFIObject_Check(op) PyObject_TypeCheck(op, &FFI_Type)\n#define LibObject_Check(ob)  ((Py_TYPE(ob) == &Lib_Type))\n\nstruct FFIObject_s {\n    PyObject_HEAD\n    PyObject *gc_wrefs, *gc_wrefs_freelist;\n    PyObject *init_once_cache;\n    struct _cffi_parse_info_s info;\n    char ctx_is_static, ctx_is_nonempty;\n    builder_c_t types_builder;\n};\n\nstatic FFIObject *ffi_internal_new(PyTypeObject *ffitype,\n                                 const struct _cffi_type_context_s *static_ctx)\n{\n    static _cffi_opcode_t internal_output[FFI_COMPLEXITY_OUTPUT];\n\n    FFIObject *ffi;\n    if (static_ctx != NULL) {\n        ffi = (FFIObject *)PyObject_GC_New(FFIObject, ffitype);\n        /* we don't call PyObject_GC_Track() here: from _cffi_init_module()\n           it is not needed, because in this case the ffi object is immortal */\n    }\n    else {\n        ffi = (FFIObject *)ffitype->tp_alloc(ffitype, 0);\n    }\n    if (ffi == NULL)\n        return NULL;\n\n    if (init_builder_c(&ffi->types_builder, static_ctx) < 0) {\n        Py_DECREF(ffi);\n        return NULL;\n    }\n    ffi->gc_wrefs = NULL;\n    ffi->gc_wrefs_freelist = NULL;\n    ffi->init_once_cache = NULL;\n    ffi->info.ctx = &ffi->types_builder.ctx;\n    ffi->info.output = internal_output;\n    ffi->info.output_size = FFI_COMPLEXITY_OUTPUT;\n    ffi->ctx_is_static = (static_ctx != NULL);\n    ffi->ctx_is_nonempty = (static_ctx != NULL);\n    return ffi;\n}\n\nstatic void ffi_dealloc(FFIObject *ffi)\n{\n    PyObject_GC_UnTrack(ffi);\n    Py_XDECREF(ffi->gc_wrefs);\n    Py_XDECREF(ffi->gc_wrefs_freelist);\n    Py_XDECREF(ffi->init_once_cache);\n\n    free_builder_c(&ffi->types_builder, ffi->ctx_is_static);\n\n    Py_TYPE(ffi)->tp_free((PyObject *)ffi);\n}\n\nstatic int ffi_traverse(FFIObject *ffi, visitproc visit, void *arg)\n{\n    Py_VISIT(ffi->types_builder.types_dict);\n    Py_VISIT(ffi->types_builder.included_ffis);\n    Py_VISIT(ffi->types_builder.included_libs);\n    Py_VISIT(ffi->gc_wrefs);\n    return 0;\n}\n\nstatic PyObject *ffiobj_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    /* user-facing initialization code, for explicit FFI() calls */\n    return (PyObject *)ffi_internal_new(type, NULL);\n}\n\n/* forward, declared in cdlopen.c because it's mostly useful for this case */\nstatic int ffiobj_init(PyObject *self, PyObject *args, PyObject *kwds);\n\nstatic PyObject *ffi_fetch_int_constant(FFIObject *ffi, const char *name,\n                                        int recursion)\n{\n    int index;\n\n    index = search_in_globals(&ffi->types_builder.ctx, name, strlen(name));\n    if (index >= 0) {\n        const struct _cffi_global_s *g;\n        g = &ffi->types_builder.ctx.globals[index];\n\n        switch (_CFFI_GETOP(g->type_op)) {\n        case _CFFI_OP_CONSTANT_INT:\n        case _CFFI_OP_ENUM:\n            return realize_global_int(&ffi->types_builder, index);\n\n        default:\n            PyErr_Format(FFIError,\n                         \"function, global variable or non-integer constant \"\n                         \"'%.200s' must be fetched from its original 'lib' \"\n                         \"object\", name);\n            return NULL;\n        }\n    }\n\n    if (ffi->types_builder.included_ffis != NULL) {\n        Py_ssize_t i;\n        PyObject *included_ffis = ffi->types_builder.included_ffis;\n\n        if (recursion > 100) {\n            PyErr_SetString(PyExc_RuntimeError,\n                            \"recursion overflow in ffi.include() delegations\");\n            return NULL;\n        }\n\n        for (i = 0; i < PyTuple_GET_SIZE(included_ffis); i++) {\n            FFIObject *ffi1;\n            PyObject *x;\n\n            ffi1 = (FFIObject *)PyTuple_GET_ITEM(included_ffis, i);\n            x = ffi_fetch_int_constant(ffi1, name, recursion + 1);\n            if (x != NULL || PyErr_Occurred())\n                return x;\n        }\n    }\n    return NULL;     /* no exception set, means \"not found\" */\n}\n\n#define ACCEPT_STRING   1\n#define ACCEPT_CTYPE    2\n#define ACCEPT_CDATA    4\n#define ACCEPT_ALL      (ACCEPT_STRING | ACCEPT_CTYPE | ACCEPT_CDATA)\n#define CONSIDER_FN_AS_FNPTR  8\n\nstatic CTypeDescrObject *_ffi_bad_type(FFIObject *ffi, const char *input_text)\n{\n    size_t length = strlen(input_text);\n    char *extra;\n\n    if (length > 500) {\n        extra = \"\";\n    }\n    else {\n        char *p;\n        size_t i, num_spaces = ffi->info.error_location;\n        extra = alloca(length + num_spaces + 4);\n        p = extra;\n        *p++ = '\\n';\n        for (i = 0; i < length; i++) {\n            if (' ' <= input_text[i] && input_text[i] < 0x7f)\n                *p++ = input_text[i];\n            else if (input_text[i] == '\\t' || input_text[i] == '\\n')\n                *p++ = ' ';\n            else\n                *p++ = '?';\n        }\n        *p++ = '\\n';\n        memset(p, ' ', num_spaces);\n        p += num_spaces;\n        *p++ = '^';\n        *p++ = 0;\n    }\n    PyErr_Format(FFIError, \"%s%s\", ffi->info.error_message, extra);\n    return NULL;\n}\n\nstatic CTypeDescrObject *_ffi_type(FFIObject *ffi, PyObject *arg,\n                                   int accept)\n{\n    /* Returns the CTypeDescrObject from the user-supplied 'arg'.\n       Does not return a new reference!\n    */\n    if ((accept & ACCEPT_STRING) && PyText_Check(arg)) {\n        PyObject *types_dict = ffi->types_builder.types_dict;\n        PyObject *x = PyDict_GetItem(types_dict, arg);\n\n        if (x == NULL) {\n            const char *input_text = PyText_AS_UTF8(arg);\n            int err, index = parse_c_type(&ffi->info, input_text);\n            if (index < 0)\n                return _ffi_bad_type(ffi, input_text);\n\n            x = realize_c_type_or_func(&ffi->types_builder,\n                                       ffi->info.output, index);\n            if (x == NULL)\n                return NULL;\n\n            /* Cache under the name given by 'arg', in addition to the\n               fact that the same ct is probably already cached under\n               its standardized name.  In a few cases, it is not, e.g.\n               if it is a primitive; for the purpose of this function,\n               the important point is the following line, which makes\n               sure that in any case the next _ffi_type() with the same\n               'arg' will succeed early, in PyDict_GetItem() above.\n            */\n            err = PyDict_SetItem(types_dict, arg, x);\n            Py_DECREF(x); /* we know it was written in types_dict (unless out\n                             of mem), so there is at least that ref left */\n            if (err < 0)\n                return NULL;\n        }\n\n        if (CTypeDescr_Check(x))\n            return (CTypeDescrObject *)x;\n        else if (accept & CONSIDER_FN_AS_FNPTR)\n            return unwrap_fn_as_fnptr(x);\n        else\n            return unexpected_fn_type(x);\n    }\n    else if ((accept & ACCEPT_CTYPE) && CTypeDescr_Check(arg)) {\n        return (CTypeDescrObject *)arg;\n    }\n    else if ((accept & ACCEPT_CDATA) && CData_Check(arg)) {\n        return ((CDataObject *)arg)->c_type;\n    }\n#if PY_MAJOR_VERSION < 3\n    else if (PyUnicode_Check(arg)) {\n        CTypeDescrObject *result;\n        arg = PyUnicode_AsASCIIString(arg);\n        if (arg == NULL)\n            return NULL;\n        result = _ffi_type(ffi, arg, accept);\n        Py_DECREF(arg);\n        return result;\n    }\n#endif\n    else {\n        const char *m1 = (accept & ACCEPT_STRING) ? \"string\" : \"\";\n        const char *m2 = (accept & ACCEPT_CTYPE) ? \"ctype object\" : \"\";\n        const char *m3 = (accept & ACCEPT_CDATA) ? \"cdata object\" : \"\";\n        const char *s12 = (*m1 && (*m2 || *m3)) ? \" or \" : \"\";\n        const char *s23 = (*m2 && *m3) ? \" or \" : \"\";\n        PyErr_Format(PyExc_TypeError, \"expected a %s%s%s%s%s, got '%.200s'\",\n                     m1, s12, m2, s23, m3,\n                     Py_TYPE(arg)->tp_name);\n        return NULL;\n    }\n}\n\nPyDoc_STRVAR(ffi_sizeof_doc,\n\"Return the size in bytes of the argument.\\n\"\n\"It can be a string naming a C type, or a 'cdata' instance.\");\n\nstatic PyObject *ffi_sizeof(FFIObject *self, PyObject *arg)\n{\n    Py_ssize_t size;\n\n    if (CData_Check(arg)) {\n        size = direct_sizeof_cdata((CDataObject *)arg);\n    }\n    else {\n        CTypeDescrObject *ct = _ffi_type(self, arg, ACCEPT_ALL);\n        if (ct == NULL)\n            return NULL;\n        size = ct->ct_size;\n        if (size < 0) {\n            PyErr_Format(FFIError, \"don't know the size of ctype '%s'\",\n                         ct->ct_name);\n            return NULL;\n        }\n    }\n    return PyInt_FromSsize_t(size);\n}\n\nPyDoc_STRVAR(ffi_alignof_doc,\n\"Return the natural alignment size in bytes of the argument.\\n\"\n\"It can be a string naming a C type, or a 'cdata' instance.\");\n\nstatic PyObject *ffi_alignof(FFIObject *self, PyObject *arg)\n{\n    int align;\n    CTypeDescrObject *ct = _ffi_type(self, arg, ACCEPT_ALL);\n    if (ct == NULL)\n        return NULL;\n\n    align = get_alignment(ct);\n    if (align < 0)\n        return NULL;\n    return PyInt_FromLong(align);\n}\n\nPyDoc_STRVAR(ffi_typeof_doc,\n\"Parse the C type given as a string and return the\\n\"\n\"corresponding <ctype> object.\\n\"\n\"It can also be used on 'cdata' instance to get its C type.\");\n\nstatic PyObject *_cpyextfunc_type_index(PyObject *x);  /* forward */\n\nstatic PyObject *ffi_typeof(FFIObject *self, PyObject *arg)\n{\n    PyObject *x = (PyObject *)_ffi_type(self, arg, ACCEPT_STRING|ACCEPT_CDATA);\n    if (x != NULL) {\n        Py_INCREF(x);\n    }\n    else {\n        x = _cpyextfunc_type_index(arg);\n    }\n    return x;\n}\n\nPyDoc_STRVAR(ffi_new_doc,\n\"Allocate an instance according to the specified C type and return a\\n\"\n\"pointer to it.  The specified C type must be either a pointer or an\\n\"\n\"array: ``new('X *')`` allocates an X and returns a pointer to it,\\n\"\n\"whereas ``new('X[n]')`` allocates an array of n X'es and returns an\\n\"\n\"array referencing it (which works mostly like a pointer, like in C).\\n\"\n\"You can also use ``new('X[]', n)`` to allocate an array of a\\n\"\n\"non-constant length n.\\n\"\n\"\\n\"\n\"The memory is initialized following the rules of declaring a global\\n\"\n\"variable in C: by default it is zero-initialized, but an explicit\\n\"\n\"initializer can be given which can be used to fill all or part of the\\n\"\n\"memory.\\n\"\n\"\\n\"\n\"When the returned <cdata> object goes out of scope, the memory is\\n\"\n\"freed.  In other words the returned <cdata> object has ownership of\\n\"\n\"the value of type 'cdecl' that it points to.  This means that the raw\\n\"\n\"data can be used as long as this object is kept alive, but must not be\\n\"\n\"used for a longer time.  Be careful about that when copying the\\n\"\n\"pointer to the memory somewhere else, e.g. into another structure.\");\n\nstatic PyObject *_ffi_new(FFIObject *self, PyObject *args, PyObject *kwds,\n                          const cffi_allocator_t *allocator)\n{\n    CTypeDescrObject *ct;\n    PyObject *arg, *init = Py_None;\n    static char *keywords[] = {\"cdecl\", \"init\", NULL};\n    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"O|O:new\", keywords,\n                                     &arg, &init))\n        return NULL;\n\n    ct = _ffi_type(self, arg, ACCEPT_STRING|ACCEPT_CTYPE);\n    if (ct == NULL)\n        return NULL;\n\n    return direct_newp(ct, init, allocator);\n}\n\nstatic PyObject *ffi_new(FFIObject *self, PyObject *args, PyObject *kwds)\n{\n    return _ffi_new(self, args, kwds, &default_allocator);\n}\n\nstatic PyObject *_ffi_new_with_allocator(PyObject *allocator, PyObject *args,\n                                         PyObject *kwds)\n{\n    cffi_allocator_t alloc1;\n    PyObject *my_alloc, *my_free;\n    my_alloc = PyTuple_GET_ITEM(allocator, 1);\n    my_free  = PyTuple_GET_ITEM(allocator, 2);\n    alloc1.ca_alloc = (my_alloc == Py_None ? NULL : my_alloc);\n    alloc1.ca_free  = (my_free  == Py_None ? NULL : my_free);\n    alloc1.ca_dont_clear = (PyTuple_GET_ITEM(allocator, 3) == Py_False);\n\n    return _ffi_new((FFIObject *)PyTuple_GET_ITEM(allocator, 0),\n                    args, kwds, &alloc1);\n}\n\nPyDoc_STRVAR(ffi_new_allocator_doc,\n\"Return a new allocator, i.e. a function that behaves like ffi.new()\\n\"\n\"but uses the provided low-level 'alloc' and 'free' functions.\\n\"\n\"\\n\"\n\"'alloc' is called with the size as argument.  If it returns NULL, a\\n\"\n\"MemoryError is raised.  'free' is called with the result of 'alloc'\\n\"\n\"as argument.  Both can be either Python functions or directly C\\n\"\n\"functions.  If 'free' is None, then no free function is called.\\n\"\n\"If both 'alloc' and 'free' are None, the default is used.\\n\"\n\"\\n\"\n\"If 'should_clear_after_alloc' is set to False, then the memory\\n\"\n\"returned by 'alloc' is assumed to be already cleared (or you are\\n\"\n\"fine with garbage); otherwise CFFI will clear it.\");\n\nstatic PyObject *ffi_new_allocator(FFIObject *self, PyObject *args,\n                                   PyObject *kwds)\n{\n    PyObject *allocator, *result;\n    PyObject *my_alloc = Py_None, *my_free = Py_None;\n    int should_clear_after_alloc = 1;\n    static char *keywords[] = {\"alloc\", \"free\", \"should_clear_after_alloc\",\n                               NULL};\n    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"|OOi:new_allocator\", keywords,\n                                     &my_alloc, &my_free,\n                                     &should_clear_after_alloc))\n        return NULL;\n\n    if (my_alloc == Py_None && my_free != Py_None) {\n        PyErr_SetString(PyExc_TypeError, \"cannot pass 'free' without 'alloc'\");\n        return NULL;\n    }\n\n    allocator = PyTuple_Pack(4,\n                             (PyObject *)self,\n                             my_alloc,\n                             my_free,\n                             PyBool_FromLong(should_clear_after_alloc));\n    if (allocator == NULL)\n        return NULL;\n\n    {\n        static PyMethodDef md = {\"allocator\",\n                                 (PyCFunction)_ffi_new_with_allocator,\n                                 METH_VARARGS | METH_KEYWORDS};\n        result = PyCFunction_New(&md, allocator);\n    }\n    Py_DECREF(allocator);\n    return result;\n}\n\nPyDoc_STRVAR(ffi_cast_doc,\n\"Similar to a C cast: returns an instance of the named C\\n\"\n\"type initialized with the given 'source'.  The source is\\n\"\n\"casted between integers or pointers of any type.\");\n\nstatic PyObject *ffi_cast(FFIObject *self, PyObject *args)\n{\n    CTypeDescrObject *ct;\n    PyObject *ob, *arg;\n    if (!PyArg_ParseTuple(args, \"OO:cast\", &arg, &ob))\n        return NULL;\n\n    ct = _ffi_type(self, arg, ACCEPT_STRING|ACCEPT_CTYPE);\n    if (ct == NULL)\n        return NULL;\n\n    return do_cast(ct, ob);\n}\n\nPyDoc_STRVAR(ffi_string_doc,\n\"Return a Python string (or unicode string) from the 'cdata'.  If\\n\"\n\"'cdata' is a pointer or array of characters or bytes, returns the\\n\"\n\"null-terminated string.  The returned string extends until the first\\n\"\n\"null character, or at most 'maxlen' characters.  If 'cdata' is an\\n\"\n\"array then 'maxlen' defaults to its length.\\n\"\n\"\\n\"\n\"If 'cdata' is a pointer or array of wchar_t, returns a unicode string\\n\"\n\"following the same rules.\\n\"\n\"\\n\"\n\"If 'cdata' is a single character or byte or a wchar_t, returns it as a\\n\"\n\"string or unicode string.\\n\"\n\"\\n\"\n\"If 'cdata' is an enum, returns the value of the enumerator as a\\n\"\n\"string, or 'NUMBER' if the value is out of range.\");\n\n#define ffi_string  b_string     /* ffi_string() => b_string()\n                                    from _cffi_backend.c */\n\nPyDoc_STRVAR(ffi_unpack_doc,\n\"Unpack an array of C data of the given length,\\n\"\n\"returning a Python string/unicode/list.\\n\"\n\"\\n\"\n\"If 'cdata' is a pointer to 'char', returns a byte string.\\n\"\n\"It does not stop at the first null.  This is equivalent to:\\n\"\n\"ffi.buffer(cdata, length)[:]\\n\"\n\"\\n\"\n\"If 'cdata' is a pointer to 'wchar_t', returns a unicode string.\\n\"\n\"'length' is measured in wchar_t's; it is not the size in bytes.\\n\"\n\"\\n\"\n\"If 'cdata' is a pointer to anything else, returns a list of\\n\"\n\"'length' items.  This is a faster equivalent to:\\n\"\n\"[cdata[i] for i in range(length)]\");\n\n#define ffi_unpack  b_unpack     /* ffi_unpack() => b_unpack()\n                                    from _cffi_backend.c */\n\n\nPyDoc_STRVAR(ffi_offsetof_doc,\n\"Return the offset of the named field inside the given structure or\\n\"\n\"array, which must be given as a C type name.  You can give several\\n\"\n\"field names in case of nested structures.  You can also give numeric\\n\"\n\"values which correspond to array items, in case of an array type.\");\n\nstatic PyObject *ffi_offsetof(FFIObject *self, PyObject *args)\n{\n    PyObject *arg;\n    CTypeDescrObject *ct;\n    Py_ssize_t i, offset;\n\n    if (PyTuple_Size(args) < 2) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"offsetof() expects at least 2 arguments\");\n        return NULL;\n    }\n\n    arg = PyTuple_GET_ITEM(args, 0);\n    ct = _ffi_type(self, arg, ACCEPT_STRING|ACCEPT_CTYPE);\n    if (ct == NULL)\n        return NULL;\n\n    offset = 0;\n    for (i = 1; i < PyTuple_GET_SIZE(args); i++) {\n        Py_ssize_t ofs1;\n        ct = direct_typeoffsetof(ct, PyTuple_GET_ITEM(args, i), i > 1, &ofs1);\n        if (ct == NULL)\n            return NULL;\n        offset += ofs1;\n    }\n    return PyInt_FromSsize_t(offset);\n}\n\nPyDoc_STRVAR(ffi_addressof_doc,\n\"Limited equivalent to the '&' operator in C:\\n\"\n\"\\n\"\n\"1. ffi.addressof(<cdata 'struct-or-union'>) returns a cdata that is a\\n\"\n\"pointer to this struct or union.\\n\"\n\"\\n\"\n\"2. ffi.addressof(<cdata>, field-or-index...) returns the address of a\\n\"\n\"field or array item inside the given structure or array, recursively\\n\"\n\"in case of nested structures or arrays.\\n\"\n\"\\n\"\n\"3. ffi.addressof(<library>, \\\"name\\\") returns the address of the named\\n\"\n\"function or global variable.\");\n\nstatic PyObject *address_of_global_var(PyObject *args);  /* forward */\n\nstatic PyObject *ffi_addressof(FFIObject *self, PyObject *args)\n{\n    PyObject *arg, *z, *result;\n    CTypeDescrObject *ct;\n    Py_ssize_t i, offset = 0;\n    int accepted_flags;\n\n    if (PyTuple_Size(args) < 1) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"addressof() expects at least 1 argument\");\n        return NULL;\n    }\n\n    arg = PyTuple_GET_ITEM(args, 0);\n    if (LibObject_Check(arg)) {\n        /* case 3 in the docstring */\n        return address_of_global_var(args);\n    }\n\n    ct = _ffi_type(self, arg, ACCEPT_CDATA);\n    if (ct == NULL)\n        return NULL;\n\n    if (PyTuple_GET_SIZE(args) == 1) {\n        /* case 1 in the docstring */\n        accepted_flags = CT_STRUCT | CT_UNION | CT_ARRAY;\n        if ((ct->ct_flags & accepted_flags) == 0) {\n            PyErr_SetString(PyExc_TypeError,\n                            \"expected a cdata struct/union/array object\");\n            return NULL;\n        }\n    }\n    else {\n        /* case 2 in the docstring */\n        accepted_flags = CT_STRUCT | CT_UNION | CT_ARRAY | CT_POINTER;\n        if ((ct->ct_flags & accepted_flags) == 0) {\n            PyErr_SetString(PyExc_TypeError,\n                        \"expected a cdata struct/union/array/pointer object\");\n            return NULL;\n        }\n        for (i = 1; i < PyTuple_GET_SIZE(args); i++) {\n            Py_ssize_t ofs1;\n            ct = direct_typeoffsetof(ct, PyTuple_GET_ITEM(args, i),\n                                     i > 1, &ofs1);\n            if (ct == NULL)\n                return NULL;\n            offset += ofs1;\n        }\n    }\n\n    z = new_pointer_type(ct);\n    if (z == NULL)\n        return NULL;\n\n    result = new_simple_cdata(((CDataObject *)arg)->c_data + offset,\n                              (CTypeDescrObject *)z);\n    Py_DECREF(z);\n    return result;\n}\n\nstatic PyObject *_combine_type_name_l(CTypeDescrObject *ct,\n                                      size_t extra_text_len)\n{\n    size_t base_name_len;\n    PyObject *result;\n    char *p;\n\n    base_name_len = strlen(ct->ct_name);\n    result = PyBytes_FromStringAndSize(NULL, base_name_len + extra_text_len);\n    if (result == NULL)\n        return NULL;\n\n    p = PyBytes_AS_STRING(result);\n    memcpy(p, ct->ct_name, ct->ct_name_position);\n    p += ct->ct_name_position;\n    p += extra_text_len;\n    memcpy(p, ct->ct_name + ct->ct_name_position,\n           base_name_len - ct->ct_name_position);\n    return result;\n}\n\nPyDoc_STRVAR(ffi_getctype_doc,\n\"Return a string giving the C type 'cdecl', which may be itself a\\n\"\n\"string or a <ctype> object.  If 'replace_with' is given, it gives\\n\"\n\"extra text to append (or insert for more complicated C types), like a\\n\"\n\"variable name, or '*' to get actually the C type 'pointer-to-cdecl'.\");\n\nstatic PyObject *ffi_getctype(FFIObject *self, PyObject *args, PyObject *kwds)\n{\n    PyObject *c_decl, *res;\n    char *p, *replace_with = \"\";\n    int add_paren, add_space;\n    CTypeDescrObject *ct;\n    size_t replace_with_len;\n    static char *keywords[] = {\"cdecl\", \"replace_with\", NULL};\n#if PY_MAJOR_VERSION >= 3\n    PyObject *u;\n#endif\n\n    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"O|s:getctype\", keywords,\n                                     &c_decl, &replace_with))\n        return NULL;\n\n    ct = _ffi_type(self, c_decl, ACCEPT_STRING|ACCEPT_CTYPE);\n    if (ct == NULL)\n        return NULL;\n\n    while (replace_with[0] != 0 && isspace(replace_with[0]))\n        replace_with++;\n    replace_with_len = strlen(replace_with);\n    while (replace_with_len > 0 && isspace(replace_with[replace_with_len - 1]))\n        replace_with_len--;\n\n    add_paren = (replace_with[0] == '*' &&\n                 ((ct->ct_flags & CT_ARRAY) != 0));\n    add_space = (!add_paren && replace_with_len > 0 &&\n                 replace_with[0] != '[' && replace_with[0] != '(');\n\n    res = _combine_type_name_l(ct, replace_with_len + add_space + 2*add_paren);\n    if (res == NULL)\n        return NULL;\n\n    p = PyBytes_AS_STRING(res) + ct->ct_name_position;\n    if (add_paren)\n        *p++ = '(';\n    if (add_space)\n        *p++ = ' ';\n    memcpy(p, replace_with, replace_with_len);\n    if (add_paren)\n        p[replace_with_len] = ')';\n\n#if PY_MAJOR_VERSION >= 3\n    /* bytes -> unicode string */\n    u = PyUnicode_DecodeLatin1(PyBytes_AS_STRING(res),\n                               PyBytes_GET_SIZE(res),\n                               NULL);\n    Py_DECREF(res);\n    res = u;\n#endif\n\n    return res;\n}\n\nPyDoc_STRVAR(ffi_new_handle_doc,\n\"Return a non-NULL cdata of type 'void *' that contains an opaque\\n\"\n\"reference to the argument, which can be any Python object.  To cast it\\n\"\n\"back to the original object, use from_handle().  You must keep alive\\n\"\n\"the cdata object returned by new_handle()!\");\n\nstatic PyObject *ffi_new_handle(FFIObject *self, PyObject *arg)\n{\n    /* g_ct_voidp is equal to <ctype 'void *'> */\n    return newp_handle(g_ct_voidp, arg);\n}\n\nPyDoc_STRVAR(ffi_from_handle_doc,\n\"Cast a 'void *' back to a Python object.  Must be used *only* on the\\n\"\n\"pointers returned by new_handle(), and *only* as long as the exact\\n\"\n\"cdata object returned by new_handle() is still alive (somewhere else\\n\"\n\"in the program).  Failure to follow these rules will crash.\");\n\n#define ffi_from_handle  b_from_handle   /* ffi_from_handle => b_from_handle\n                                            from _cffi_backend.c */\n\nPyDoc_STRVAR(ffi_from_buffer_doc,\n\"Return a <cdata 'char[]'> that points to the data of the given Python\\n\"\n\"object, which must support the buffer interface.  Note that this is\\n\"\n\"not meant to be used on the built-in types str or unicode\\n\"\n\"(you can build 'char[]' arrays explicitly) but only on objects\\n\"\n\"containing large quantities of raw data in some other format, like\\n\"\n\"'array.array' or numpy arrays.\");\n\nstatic PyObject *ffi_from_buffer(FFIObject *self, PyObject *args,\n                                 PyObject *kwds)\n{\n    PyObject *cdecl1, *python_buf = NULL;\n    CTypeDescrObject *ct;\n    int require_writable = 0;\n    static char *keywords[] = {\"cdecl\", \"python_buffer\",\n                               \"require_writable\", NULL};\n\n    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"O|Oi:from_buffer\", keywords,\n                                     &cdecl1, &python_buf, &require_writable))\n        return NULL;\n\n    if (python_buf == NULL) {\n        python_buf = cdecl1;\n        ct = g_ct_chararray;\n    }\n    else {\n        ct = _ffi_type(self, cdecl1, ACCEPT_STRING|ACCEPT_CTYPE);\n        if (ct == NULL)\n            return NULL;\n    }\n    return direct_from_buffer(ct, python_buf, require_writable);\n}\n\nPyDoc_STRVAR(ffi_gc_doc,\n\"Return a new cdata object that points to the same data.\\n\"\n\"Later, when this new cdata object is garbage-collected,\\n\"\n\"'destructor(old_cdata_object)' will be called.\\n\"\n\"\\n\"\n\"The optional 'size' gives an estimate of the size, used to\\n\"\n\"trigger the garbage collection more eagerly.  So far only used\\n\"\n\"on PyPy.  It tells the GC that the returned object keeps alive\\n\"\n\"roughly 'size' bytes of external memory.\");\n\n#define ffi_gc  b_gcp     /* ffi_gc() => b_gcp()\n                             from _cffi_backend.c */\n\nPyDoc_STRVAR(ffi_def_extern_doc,\n\"A decorator.  Attaches the decorated Python function to the C code\\n\"\n\"generated for the 'extern \\\"Python\\\"' function of the same name.\\n\"\n\"Calling the C function will then invoke the Python function.\\n\"\n\"\\n\"\n\"Optional arguments: 'name' is the name of the C function, if\\n\"\n\"different from the Python function; and 'error' and 'onerror'\\n\"\n\"handle what occurs if the Python function raises an exception\\n\"\n\"(see the docs for details).\");\n\n/* forward; see call_python.c */\nstatic PyObject *_ffi_def_extern_decorator(PyObject *, PyObject *);\n\nstatic PyObject *ffi_def_extern(FFIObject *self, PyObject *args,\n                                PyObject *kwds)\n{\n    static PyMethodDef md = {\"def_extern_decorator\",\n                             (PyCFunction)_ffi_def_extern_decorator, METH_O};\n    PyObject *name = Py_None, *error = Py_None;\n    PyObject *res, *onerror = Py_None;\n    static char *keywords[] = {\"name\", \"error\", \"onerror\", NULL};\n\n    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"|OOO\", keywords,\n                                     &name, &error, &onerror))\n        return NULL;\n\n    args = Py_BuildValue(\"(OOOO)\", (PyObject *)self, name, error, onerror);\n    if (args == NULL)\n        return NULL;\n\n    res = PyCFunction_New(&md, args);\n    Py_DECREF(args);\n    return res;\n}\n\nPyDoc_STRVAR(ffi_callback_doc,\n\"Return a callback object or a decorator making such a callback object.\\n\"\n\"'cdecl' must name a C function pointer type.  The callback invokes the\\n\"\n\"specified 'python_callable' (which may be provided either directly or\\n\"\n\"via a decorator).  Important: the callback object must be manually\\n\"\n\"kept alive for as long as the callback may be invoked from the C code.\");\n\nstatic PyObject *_ffi_callback_decorator(PyObject *outer_args, PyObject *fn)\n{\n    PyObject *res, *old;\n\n    old = PyTuple_GET_ITEM(outer_args, 1);\n    PyTuple_SET_ITEM(outer_args, 1, fn);\n    res = b_callback(NULL, outer_args);\n    PyTuple_SET_ITEM(outer_args, 1, old);\n    return res;\n}\n\nstatic PyObject *ffi_callback(FFIObject *self, PyObject *args, PyObject *kwds)\n{\n    PyObject *c_decl, *python_callable = Py_None, *error = Py_None;\n    PyObject *res, *onerror = Py_None;\n    static char *keywords[] = {\"cdecl\", \"python_callable\", \"error\",\n                               \"onerror\", NULL};\n\n    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"O|OOO\", keywords,\n                                     &c_decl, &python_callable, &error,\n                                     &onerror))\n        return NULL;\n\n    c_decl = (PyObject *)_ffi_type(self, c_decl, ACCEPT_STRING | ACCEPT_CTYPE |\n                                                 CONSIDER_FN_AS_FNPTR);\n    if (c_decl == NULL)\n        return NULL;\n\n    args = Py_BuildValue(\"(OOOO)\", c_decl, python_callable, error, onerror);\n    if (args == NULL)\n        return NULL;\n\n    if (python_callable != Py_None) {\n        res = b_callback(NULL, args);\n    }\n    else {\n        static PyMethodDef md = {\"callback_decorator\",\n                                 (PyCFunction)_ffi_callback_decorator, METH_O};\n        res = PyCFunction_New(&md, args);\n    }\n    Py_DECREF(args);\n    return res;\n}\n\n#ifdef MS_WIN32\nPyDoc_STRVAR(ffi_getwinerror_doc,\n\"Return either the GetLastError() or the error number given by the\\n\"\n\"optional 'code' argument, as a tuple '(code, message)'.\");\n\n#define ffi_getwinerror  b_getwinerror  /* ffi_getwinerror() => b_getwinerror()\n                                           from misc_win32.h */\n#endif\n\nPyDoc_STRVAR(ffi_errno_doc, \"the value of 'errno' from/to the C calls\");\n\nstatic PyObject *ffi_get_errno(PyObject *self, void *closure)\n{\n    /* xxx maybe think about how to make the saved errno local\n       to an ffi instance */\n    return b_get_errno(NULL, NULL);\n}\n\nstatic int ffi_set_errno(PyObject *self, PyObject *newval, void *closure)\n{\n    PyObject *x = b_set_errno(NULL, newval);\n    if (x == NULL)\n        return -1;\n    Py_DECREF(x);\n    return 0;\n}\n\nPyDoc_STRVAR(ffi_dlopen_doc,\n\"Load and return a dynamic library identified by 'name'.  The standard\\n\"\n\"C library can be loaded by passing None.\\n\"\n\"\\n\"\n\"Note that functions and types declared with 'ffi.cdef()' are not\\n\"\n\"linked to a particular library, just like C headers.  In the library\\n\"\n\"we only look for the actual (untyped) symbols at the time of their\\n\"\n\"first access.\");\n\nPyDoc_STRVAR(ffi_dlclose_doc,\n\"Close a library obtained with ffi.dlopen().  After this call, access to\\n\"\n\"functions or variables from the library will fail (possibly with a\\n\"\n\"segmentation fault).\");\n\nstatic PyObject *ffi_dlopen(PyObject *self, PyObject *args);  /* forward */\nstatic PyObject *ffi_dlclose(PyObject *self, PyObject *args);  /* forward */\n\nPyDoc_STRVAR(ffi_int_const_doc,\n\"Get the value of an integer constant.\\n\"\n\"\\n\"\n\"'ffi.integer_const(\\\"xxx\\\")' is equivalent to 'lib.xxx' if xxx names an\\n\"\n\"integer constant.  The point of this function is limited to use cases\\n\"\n\"where you have an 'ffi' object but not any associated 'lib' object.\");\n\nstatic PyObject *ffi_int_const(FFIObject *self, PyObject *args, PyObject *kwds)\n{\n    char *name;\n    PyObject *x;\n    static char *keywords[] = {\"name\", NULL};\n\n    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"s\", keywords, &name))\n        return NULL;\n\n    x = ffi_fetch_int_constant(self, name, 0);\n\n    if (x == NULL && !PyErr_Occurred()) {\n        PyErr_Format(PyExc_AttributeError,\n                     \"integer constant '%.200s' not found\", name);\n    }\n    return x;\n}\n\nPyDoc_STRVAR(ffi_list_types_doc,\n\"Returns the user type names known to this FFI instance.\\n\"\n\"This returns a tuple containing three lists of names:\\n\"\n\"(typedef_names, names_of_structs, names_of_unions)\");\n\nstatic PyObject *ffi_list_types(FFIObject *self, PyObject *noargs)\n{\n    Py_ssize_t i, n1 = self->types_builder.ctx.num_typenames;\n    Py_ssize_t n23 = self->types_builder.ctx.num_struct_unions;\n    PyObject *o, *lst[3] = {NULL, NULL, NULL}, *result = NULL;\n\n    lst[0] = PyList_New(n1);\n    if (lst[0] == NULL)\n        goto error;\n    lst[1] = PyList_New(0);\n    if (lst[1] == NULL)\n        goto error;\n    lst[2] = PyList_New(0);\n    if (lst[2] == NULL)\n        goto error;\n\n    for (i = 0; i < n1; i++) {\n        o = PyText_FromString(self->types_builder.ctx.typenames[i].name);\n        if (o == NULL)\n            goto error;\n        PyList_SET_ITEM(lst[0], i, o);\n    }\n\n    for (i = 0; i < n23; i++) {\n        const struct _cffi_struct_union_s *s;\n        int err, index;\n\n        s = &self->types_builder.ctx.struct_unions[i];\n        if (s->name[0] == '$')\n            continue;\n\n        o = PyText_FromString(s->name);\n        if (o == NULL)\n            goto error;\n        index = (s->flags & _CFFI_F_UNION) ? 2 : 1;\n        err = PyList_Append(lst[index], o);\n        Py_DECREF(o);\n        if (err < 0)\n            goto error;\n    }\n    result = PyTuple_Pack(3, lst[0], lst[1], lst[2]);\n    /* fall-through */\n error:\n    Py_XDECREF(lst[2]);\n    Py_XDECREF(lst[1]);\n    Py_XDECREF(lst[0]);\n    return result;\n}\n\nPyDoc_STRVAR(ffi_memmove_doc,\n\"ffi.memmove(dest, src, n) copies n bytes of memory from src to dest.\\n\"\n\"\\n\"\n\"Like the C function memmove(), the memory areas may overlap;\\n\"\n\"apart from that it behaves like the C function memcpy().\\n\"\n\"\\n\"\n\"'src' can be any cdata ptr or array, or any Python buffer object.\\n\"\n\"'dest' can be any cdata ptr or array, or a writable Python buffer\\n\"\n\"object.  The size to copy, 'n', is always measured in bytes.\\n\"\n\"\\n\"\n\"Unlike other methods, this one supports all Python buffer including\\n\"\n\"byte strings and bytearrays---but it still does not support\\n\"\n\"non-contiguous buffers.\");\n\n#define ffi_memmove  b_memmove     /* ffi_memmove() => b_memmove()\n                                      from _cffi_backend.c */\n\nPyDoc_STRVAR(ffi_init_once_doc,\n\"init_once(function, tag): run function() once.  More precisely,\\n\"\n\"'function()' is called the first time we see a given 'tag'.\\n\"\n\"\\n\"\n\"The return value of function() is remembered and returned by the current\\n\"\n\"and all future init_once() with the same tag.  If init_once() is called\\n\"\n\"from multiple threads in parallel, all calls block until the execution\\n\"\n\"of function() is done.  If function() raises an exception, it is\\n\"\n\"propagated and nothing is cached.\");\n\n#if PY_MAJOR_VERSION < 3\n/* PyCapsule_New is redefined to be PyCObject_FromVoidPtr in _cffi_backend,\n   which gives 2.6 compatibility; but the destructor signature is different */\nstatic void _free_init_once_lock(void *lock)\n{\n    PyThread_free_lock((PyThread_type_lock)lock);\n}\n#else\nstatic void _free_init_once_lock(PyObject *capsule)\n{\n    PyThread_type_lock lock;\n    lock = PyCapsule_GetPointer(capsule, \"cffi_init_once_lock\");\n    if (lock != NULL)\n        PyThread_free_lock(lock);\n}\n#endif\n\nstatic PyObject *ffi_init_once(FFIObject *self, PyObject *args, PyObject *kwds)\n{\n    static char *keywords[] = {\"func\", \"tag\", NULL};\n    PyObject *cache, *func, *tag, *tup, *res, *x, *lockobj;\n    PyThread_type_lock lock;\n\n    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"OO\", keywords, &func, &tag))\n        return NULL;\n\n    /* a lot of fun with reference counting and error checking\n       in this function */\n\n    /* atomically get or create a new dict (no GIL release) */\n    cache = self->init_once_cache;\n    if (cache == NULL) {\n        cache = PyDict_New();\n        if (cache == NULL)\n            return NULL;\n        self->init_once_cache = cache;\n    }\n\n    /* get the tuple from cache[tag], or make a new one: (False, lock) */\n    tup = PyDict_GetItem(cache, tag);\n    if (tup == NULL) {\n        lock = PyThread_allocate_lock();\n        if (lock == NULL)\n            return NULL;\n        x = PyCapsule_New(lock, \"cffi_init_once_lock\", _free_init_once_lock);\n        if (x == NULL) {\n            PyThread_free_lock(lock);\n            return NULL;\n        }\n        tup = PyTuple_Pack(2, Py_False, x);\n        Py_DECREF(x);\n        if (tup == NULL)\n            return NULL;\n        x = tup;\n\n        /* Possible corner case if 'tag' is an object overriding __eq__\n           in pure Python: the GIL may be released when we are running it.\n           We really need to call dict.setdefault(). */\n        tup = PyObject_CallMethod(cache, \"setdefault\", \"OO\", tag, x);\n        Py_DECREF(x);\n        if (tup == NULL)\n            return NULL;\n\n        Py_DECREF(tup);   /* there is still a ref inside the dict */\n    }\n\n    res = PyTuple_GET_ITEM(tup, 1);\n    Py_INCREF(res);\n\n    if (PyTuple_GET_ITEM(tup, 0) == Py_True) {\n        /* tup == (True, result): return the result. */\n        return res;\n    }\n\n    /* tup == (False, lock) */\n    lockobj = res;\n    lock = (PyThread_type_lock)PyCapsule_GetPointer(lockobj,\n                                                    \"cffi_init_once_lock\");\n    if (lock == NULL) {\n        Py_DECREF(lockobj);\n        return NULL;\n    }\n\n    Py_BEGIN_ALLOW_THREADS\n    PyThread_acquire_lock(lock, WAIT_LOCK);\n    Py_END_ALLOW_THREADS\n\n    x = PyDict_GetItem(cache, tag);\n    if (x != NULL && PyTuple_GET_ITEM(x, 0) == Py_True) {\n        /* the real result was put in the dict while we were waiting\n           for PyThread_acquire_lock() above */\n        res = PyTuple_GET_ITEM(x, 1);\n        Py_INCREF(res);\n    }\n    else {\n        res = PyObject_CallFunction(func, \"\");\n        if (res != NULL) {\n            tup = PyTuple_Pack(2, Py_True, res);\n            if (tup == NULL || PyDict_SetItem(cache, tag, tup) < 0) {\n                Py_XDECREF(tup);\n                Py_DECREF(res);\n                res = NULL;\n            }\n        }\n    }\n\n    PyThread_release_lock(lock);\n    Py_DECREF(lockobj);\n    return res;\n}\n\nPyDoc_STRVAR(ffi_release_doc,\n\"Release now the resources held by a 'cdata' object from ffi.new(),\\n\"\n\"ffi.gc() or ffi.from_buffer().  The cdata object must not be used\\n\"\n\"afterwards.\\n\"\n\"\\n\"\n\"'ffi.release(cdata)' is equivalent to 'cdata.__exit__()'.\\n\"\n\"\\n\"\n\"Note that on CPython this method has no effect (so far) on objects\\n\"\n\"returned by ffi.new(), because the memory is allocated inline with the\\n\"\n\"cdata object and cannot be freed independently.  It might be fixed in\\n\"\n\"future releases of cffi.\");\n\n#define ffi_release  b_release     /* ffi_release() => b_release()\n                                      from _cffi_backend.c */\n\n\n#define METH_VKW  (METH_VARARGS | METH_KEYWORDS)\nstatic PyMethodDef ffi_methods[] = {\n {\"addressof\",  (PyCFunction)ffi_addressof,  METH_VARARGS, ffi_addressof_doc},\n {\"alignof\",    (PyCFunction)ffi_alignof,    METH_O,       ffi_alignof_doc},\n {\"def_extern\", (PyCFunction)ffi_def_extern, METH_VKW,     ffi_def_extern_doc},\n {\"callback\",   (PyCFunction)ffi_callback,   METH_VKW,     ffi_callback_doc},\n {\"cast\",       (PyCFunction)ffi_cast,       METH_VARARGS, ffi_cast_doc},\n {\"dlclose\",    (PyCFunction)ffi_dlclose,    METH_VARARGS, ffi_dlclose_doc},\n {\"dlopen\",     (PyCFunction)ffi_dlopen,     METH_VARARGS, ffi_dlopen_doc},\n {\"from_buffer\",(PyCFunction)ffi_from_buffer,METH_VKW,     ffi_from_buffer_doc},\n {\"from_handle\",(PyCFunction)ffi_from_handle,METH_O,       ffi_from_handle_doc},\n {\"gc\",         (PyCFunction)ffi_gc,         METH_VKW,     ffi_gc_doc},\n {\"getctype\",   (PyCFunction)ffi_getctype,   METH_VKW,     ffi_getctype_doc},\n#ifdef MS_WIN32\n {\"getwinerror\",(PyCFunction)ffi_getwinerror,METH_VKW,     ffi_getwinerror_doc},\n#endif\n {\"init_once\",  (PyCFunction)ffi_init_once,  METH_VKW,     ffi_init_once_doc},\n {\"integer_const\",(PyCFunction)ffi_int_const,METH_VKW,     ffi_int_const_doc},\n {\"list_types\", (PyCFunction)ffi_list_types, METH_NOARGS,  ffi_list_types_doc},\n {\"memmove\",    (PyCFunction)ffi_memmove,    METH_VKW,     ffi_memmove_doc},\n {\"new\",        (PyCFunction)ffi_new,        METH_VKW,     ffi_new_doc},\n{\"new_allocator\",(PyCFunction)ffi_new_allocator,METH_VKW,ffi_new_allocator_doc},\n {\"new_handle\", (PyCFunction)ffi_new_handle, METH_O,       ffi_new_handle_doc},\n {\"offsetof\",   (PyCFunction)ffi_offsetof,   METH_VARARGS, ffi_offsetof_doc},\n {\"release\",    (PyCFunction)ffi_release,    METH_O,       ffi_release_doc},\n {\"sizeof\",     (PyCFunction)ffi_sizeof,     METH_O,       ffi_sizeof_doc},\n {\"string\",     (PyCFunction)ffi_string,     METH_VKW,     ffi_string_doc},\n {\"typeof\",     (PyCFunction)ffi_typeof,     METH_O,       ffi_typeof_doc},\n {\"unpack\",     (PyCFunction)ffi_unpack,     METH_VKW,     ffi_unpack_doc},\n {NULL}\n};\n\nstatic PyGetSetDef ffi_getsets[] = {\n    {\"errno\",  ffi_get_errno,  ffi_set_errno,  ffi_errno_doc},\n    {NULL}\n};\n\nstatic PyTypeObject FFI_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"CompiledFFI\",\n    sizeof(FFIObject),\n    0,\n    (destructor)ffi_dealloc,                    /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_compare */\n    0,                                          /* tp_repr */\n    0,                                          /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    PyObject_GenericGetAttr,                    /* tp_getattro */\n    0,                                          /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |\n        Py_TPFLAGS_BASETYPE,                    /* tp_flags */\n    0,                                          /* tp_doc */\n    (traverseproc)ffi_traverse,                 /* tp_traverse */\n    0,                                          /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    ffi_methods,                                /* tp_methods */\n    0,                                          /* tp_members */\n    ffi_getsets,                                /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    ffiobj_init,                                /* tp_init */\n    0,                                          /* tp_alloc */\n    ffiobj_new,                                 /* tp_new */\n    PyObject_GC_Del,                            /* tp_free */\n};\n\n\nstatic PyObject *\n_fetch_external_struct_or_union(const struct _cffi_struct_union_s *s,\n                                PyObject *included_ffis, int recursion)\n{\n    Py_ssize_t i;\n\n    if (included_ffis == NULL)\n        return NULL;\n\n    if (recursion > 100) {\n        PyErr_SetString(PyExc_RuntimeError,\n                        \"recursion overflow in ffi.include() delegations\");\n        return NULL;\n    }\n\n    for (i = 0; i < PyTuple_GET_SIZE(included_ffis); i++) {\n        FFIObject *ffi1;\n        const struct _cffi_struct_union_s *s1;\n        int sindex;\n        PyObject *x;\n\n        ffi1 = (FFIObject *)PyTuple_GET_ITEM(included_ffis, i);\n        sindex = search_in_struct_unions(&ffi1->types_builder.ctx, s->name,\n                                         strlen(s->name));\n        if (sindex < 0)  /* not found at all */\n            continue;\n        s1 = &ffi1->types_builder.ctx.struct_unions[sindex];\n        if ((s1->flags & (_CFFI_F_EXTERNAL | _CFFI_F_UNION))\n                == (s->flags & _CFFI_F_UNION)) {\n            /* s1 is not external, and the same kind (struct or union) as s */\n            return _realize_c_struct_or_union(&ffi1->types_builder, sindex);\n        }\n        /* not found, look more recursively */\n        x = _fetch_external_struct_or_union(\n                s, ffi1->types_builder.included_ffis, recursion + 1);\n        if (x != NULL || PyErr_Occurred())\n            return x;   /* either found, or got an error */\n    }\n    return NULL;   /* not found at all, leave without an error */\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.13.0-jlicqgsrlask3n7tsdckxmdwv6d5zp4o/spack-src/c/_cffi_backend.c": "#define PY_SSIZE_T_CLEAN\n#include <Python.h>\n#include \"structmember.h\"\n\n#define CFFI_VERSION  \"1.13.0\"\n\n#ifdef MS_WIN32\n#include <windows.h>\n#include \"misc_win32.h\"\n#else\n#include <stddef.h>\n#include <stdint.h>\n#include <dlfcn.h>\n#include <errno.h>\n#include <ffi.h>\n#include <sys/mman.h>\n#endif\n\n/* this block of #ifs should be kept exactly identical between\n   c/_cffi_backend.c, cffi/vengine_cpy.py, cffi/vengine_gen.py */\n#if defined(_MSC_VER)\n# include <malloc.h>   /* for alloca() */\n# if _MSC_VER < 1600   /* MSVC < 2010 */\n   typedef __int8 int8_t;\n   typedef __int16 int16_t;\n   typedef __int32 int32_t;\n   typedef __int64 int64_t;\n   typedef unsigned __int8 uint8_t;\n   typedef unsigned __int16 uint16_t;\n   typedef unsigned __int32 uint32_t;\n   typedef unsigned __int64 uint64_t;\n   typedef __int8 int_least8_t;\n   typedef __int16 int_least16_t;\n   typedef __int32 int_least32_t;\n   typedef __int64 int_least64_t;\n   typedef unsigned __int8 uint_least8_t;\n   typedef unsigned __int16 uint_least16_t;\n   typedef unsigned __int32 uint_least32_t;\n   typedef unsigned __int64 uint_least64_t;\n   typedef __int8 int_fast8_t;\n   typedef __int16 int_fast16_t;\n   typedef __int32 int_fast32_t;\n   typedef __int64 int_fast64_t;\n   typedef unsigned __int8 uint_fast8_t;\n   typedef unsigned __int16 uint_fast16_t;\n   typedef unsigned __int32 uint_fast32_t;\n   typedef unsigned __int64 uint_fast64_t;\n   typedef __int64 intmax_t;\n   typedef unsigned __int64 uintmax_t;\n# else\n#  include <stdint.h>\n# endif\n# if _MSC_VER < 1800   /* MSVC < 2013 */\n   typedef unsigned char _Bool;\n# endif\n#else\n# include <stdint.h>\n# if (defined (__SVR4) && defined (__sun)) || defined(_AIX) || defined(__hpux)\n#  include <alloca.h>\n# endif\n#endif\n\n\n/* Define the following macro ONLY if you trust libffi's version of\n * ffi_closure_alloc() more than the code in malloc_closure.h.\n * IMPORTANT: DO NOT ENABLE THIS ON LINUX, unless you understand exactly\n * why I recommend against it and decide that you trust it more than my\n * analysis below.\n *\n * There are two versions of this code: one inside libffi itself, and\n * one inside malloc_closure.h here.  Both should be fine as long as the\n * Linux distribution does _not_ enable extra security features.  If it\n * does, then the code in malloc_closure.h will cleanly crash because\n * there is no reasonable way to obtain a read-write-execute memory\n * page.  On the other hand, the code in libffi will appear to\n * work---but will actually randomly crash after a fork() if the child\n * does not immediately call exec().  This second crash is of the kind\n * that can be turned into an attack vector by a motivated attacker.\n * So, _enabling_ extra security features _opens_ an attack vector.\n * That sounds like a horribly bad idea to me, and is the reason for why\n * I prefer CFFI crashing cleanly.\n *\n * Currently, we use libffi's ffi_closure_alloc() only on NetBSD.  It is\n * known that on the NetBSD kernel, a different strategy is used which\n * should not be open to the fork() bug.\n */\n#ifdef __NetBSD__\n# define CFFI_TRUST_LIBFFI\n#endif\n\n#ifndef CFFI_TRUST_LIBFFI\n# include \"malloc_closure.h\"\n#endif\n\n\n#if PY_MAJOR_VERSION >= 3\n# define STR_OR_BYTES \"bytes\"\n# define PyText_Type PyUnicode_Type\n# define PyText_Check PyUnicode_Check\n# define PyTextAny_Check PyUnicode_Check\n# define PyText_FromFormat PyUnicode_FromFormat\n# define PyText_AsUTF8 _PyUnicode_AsString   /* PyUnicode_AsUTF8 in Py3.3 */\n# define PyText_AS_UTF8 _PyUnicode_AsString\n# if PY_VERSION_HEX >= 0x03030000\n#  define PyText_GetSize PyUnicode_GetLength\n# else\n#  define PyText_GetSize PyUnicode_GetSize\n# endif\n# define PyText_FromString PyUnicode_FromString\n# define PyText_FromStringAndSize PyUnicode_FromStringAndSize\n# define PyText_InternInPlace PyUnicode_InternInPlace\n# define PyText_InternFromString PyUnicode_InternFromString\n# define PyIntOrLong_Check PyLong_Check\n#else\n# define STR_OR_BYTES \"str\"\n# define PyText_Type PyString_Type\n# define PyText_Check PyString_Check\n# define PyTextAny_Check(op) (PyString_Check(op) || PyUnicode_Check(op))\n# define PyText_FromFormat PyString_FromFormat\n# define PyText_AsUTF8 PyString_AsString\n# define PyText_AS_UTF8 PyString_AS_STRING\n# define PyText_GetSize PyString_Size\n# define PyText_FromString PyString_FromString\n# define PyText_FromStringAndSize PyString_FromStringAndSize\n# define PyText_InternInPlace PyString_InternInPlace\n# define PyText_InternFromString PyString_InternFromString\n# define PyIntOrLong_Check(op) (PyInt_Check(op) || PyLong_Check(op))\n#endif\n\n#if PY_MAJOR_VERSION >= 3\n# define PyInt_FromLong PyLong_FromLong\n# define PyInt_FromSsize_t PyLong_FromSsize_t\n# define PyInt_AsSsize_t PyLong_AsSsize_t\n# define PyInt_AsLong PyLong_AsLong\n#endif\n\n#if PY_MAJOR_VERSION >= 3\n/* This is the default on Python3 and constant has been removed. */\n# define Py_TPFLAGS_CHECKTYPES 0\n#endif\n\n#if PY_MAJOR_VERSION < 3\n# undef PyCapsule_GetPointer\n# undef PyCapsule_New\n# define PyCapsule_GetPointer(capsule, name) \\\n    (PyCObject_AsVoidPtr(capsule))\n# define PyCapsule_New(pointer, name, destructor) \\\n    (PyCObject_FromVoidPtr(pointer, destructor))\n#endif\n\n/************************************************************/\n\n/* base type flag: exactly one of the following: */\n#define CT_PRIMITIVE_SIGNED   0x001   /* signed integer */\n#define CT_PRIMITIVE_UNSIGNED 0x002   /* unsigned integer */\n#define CT_PRIMITIVE_CHAR     0x004   /* char, wchar_t, charN_t */\n#define CT_PRIMITIVE_FLOAT    0x008   /* float, double, long double */\n#define CT_POINTER            0x010   /* pointer, excluding ptr-to-func */\n#define CT_ARRAY              0x020   /* array */\n#define CT_STRUCT             0x040   /* struct */\n#define CT_UNION              0x080   /* union */\n#define CT_FUNCTIONPTR        0x100   /* pointer to function */\n#define CT_VOID               0x200   /* void */\n#define CT_PRIMITIVE_COMPLEX  0x400   /* float _Complex, double _Complex */\n\n/* other flags that may also be set in addition to the base flag: */\n#define CT_IS_VOIDCHAR_PTR     0x00001000\n#define CT_PRIMITIVE_FITS_LONG 0x00002000\n#define CT_IS_OPAQUE           0x00004000\n#define CT_IS_ENUM             0x00008000\n#define CT_IS_PTR_TO_OWNED     0x00010000 /* only owned if CDataOwning_Type */\n#define CT_CUSTOM_FIELD_POS    0x00020000\n#define CT_IS_LONGDOUBLE       0x00040000\n#define CT_IS_BOOL             0x00080000\n#define CT_IS_FILE             0x00100000\n#define CT_IS_VOID_PTR         0x00200000\n#define CT_WITH_VAR_ARRAY      0x00400000 /* with open-ended array, anywhere */\n/* unused                      0x00800000 */\n#define CT_LAZY_FIELD_LIST     0x01000000\n#define CT_WITH_PACKED_CHANGE  0x02000000\n#define CT_IS_SIGNED_WCHAR     0x04000000\n#define CT_PRIMITIVE_ANY  (CT_PRIMITIVE_SIGNED |        \\\n                           CT_PRIMITIVE_UNSIGNED |      \\\n                           CT_PRIMITIVE_CHAR |          \\\n                           CT_PRIMITIVE_FLOAT |         \\\n                           CT_PRIMITIVE_COMPLEX)\n\ntypedef struct _ctypedescr {\n    PyObject_VAR_HEAD\n\n    struct _ctypedescr *ct_itemdescr;  /* ptrs and arrays: the item type */\n    PyObject *ct_stuff;                /* structs: dict of the fields\n                                          arrays: ctypedescr of the ptr type\n                                          function: tuple(abi, ctres, ctargs..)\n                                          enum: pair {\"name\":x},{x:\"name\"}\n                                          ptrs: lazily, ctypedescr of array */\n    void *ct_extra;                    /* structs: first field (not a ref!)\n                                          function types: cif_description\n                                          primitives: prebuilt \"cif\" object */\n\n    PyObject *ct_weakreflist;    /* weakref support */\n\n    PyObject *ct_unique_key;    /* key in unique_cache (a string, but not\n                                   human-readable) */\n\n    Py_ssize_t ct_size;     /* size of instances, or -1 if unknown */\n    Py_ssize_t ct_length;   /* length of arrays, or -1 if unknown;\n                               or alignment of primitive and struct types;\n                               always -1 for pointers */\n    int ct_flags;           /* CT_xxx flags */\n\n    int ct_name_position;   /* index in ct_name of where to put a var name */\n    char ct_name[1];        /* string, e.g. \"int *\" for pointers to ints */\n} CTypeDescrObject;\n\ntypedef struct {\n    PyObject_HEAD\n    CTypeDescrObject *c_type;\n    char *c_data;\n    PyObject *c_weakreflist;\n} CDataObject;\n\ntypedef struct cfieldobject_s {\n    PyObject_HEAD\n    CTypeDescrObject *cf_type;\n    Py_ssize_t cf_offset;\n    short cf_bitshift;   /* >= 0: bitshift; or BS_REGULAR or BS_EMPTY_ARRAY */\n    short cf_bitsize;\n    unsigned char cf_flags;   /* BF_... */\n    struct cfieldobject_s *cf_next;\n} CFieldObject;\n#define BS_REGULAR            (-1) /* a regular field, not with bitshift */\n#define BS_EMPTY_ARRAY        (-2) /* a field declared 'type[0]' or 'type[]' */\n#define BF_IGNORE_IN_CTOR     0x01 /* union field not in the first place */\n\nstatic PyTypeObject CTypeDescr_Type;\nstatic PyTypeObject CField_Type;\nstatic PyTypeObject CData_Type;\nstatic PyTypeObject CDataOwning_Type;\nstatic PyTypeObject CDataOwningGC_Type;\nstatic PyTypeObject CDataFromBuf_Type;\nstatic PyTypeObject CDataGCP_Type;\n\n#define CTypeDescr_Check(ob)  (Py_TYPE(ob) == &CTypeDescr_Type)\n#define CData_Check(ob)       (Py_TYPE(ob) == &CData_Type ||            \\\n                               Py_TYPE(ob) == &CDataOwning_Type ||      \\\n                               Py_TYPE(ob) == &CDataOwningGC_Type ||    \\\n                               Py_TYPE(ob) == &CDataFromBuf_Type ||     \\\n                               Py_TYPE(ob) == &CDataGCP_Type)\n#define CDataOwn_Check(ob)    (Py_TYPE(ob) == &CDataOwning_Type ||      \\\n                               Py_TYPE(ob) == &CDataOwningGC_Type)\n\ntypedef union {\n    unsigned char m_char;\n    unsigned short m_short;\n    unsigned int m_int;\n    unsigned long m_long;\n    unsigned long long m_longlong;\n    float m_float;\n    double m_double;\n    long double m_longdouble;\n} union_alignment;\n\ntypedef struct {\n    CDataObject head;\n    union_alignment alignment;\n} CDataObject_casted_primitive;\n\ntypedef struct {\n    CDataObject head;\n    union_alignment alignment;\n} CDataObject_own_nolength;\n\ntypedef struct {\n    CDataObject head;\n    Py_ssize_t length;\n    union_alignment alignment;\n} CDataObject_own_length;\n\ntypedef struct {\n    CDataObject head;\n    PyObject *structobj;   /* for ffi.new_handle() or ffi.new(\"struct *\") */\n} CDataObject_own_structptr;\n\ntypedef struct {\n    CDataObject head;\n    Py_ssize_t length;     /* same as CDataObject_own_length up to here */\n    Py_buffer *bufferview;\n} CDataObject_frombuf;\n\ntypedef struct {\n    CDataObject head;\n    Py_ssize_t length;     /* same as CDataObject_own_length up to here */\n    PyObject *origobj;\n    PyObject *destructor;\n} CDataObject_gcp;\n\ntypedef struct {\n    CDataObject head;\n    ffi_closure *closure;\n} CDataObject_closure;\n\ntypedef struct {\n    ffi_cif cif;\n    /* the following information is used when doing the call:\n       - a buffer of size 'exchange_size' is malloced\n       - the arguments are converted from Python objects to raw data\n       - the i'th raw data is stored at 'buffer + exchange_offset_arg[1+i]'\n       - the call is done\n       - the result is read back from 'buffer + exchange_offset_arg[0]' */\n    Py_ssize_t exchange_size;\n    Py_ssize_t exchange_offset_arg[1];\n} cif_description_t;\n\n#define ADD_WRAPAROUND(x, y)  ((Py_ssize_t)(((size_t)(x)) + ((size_t)(y))))\n#define MUL_WRAPAROUND(x, y)  ((Py_ssize_t)(((size_t)(x)) * ((size_t)(y))))\n\n\n/* whenever running Python code, the errno is saved in this thread-local\n   variable */\n#ifndef MS_WIN32\n# include \"misc_thread_posix.h\"\n#endif\n\n#include \"minibuffer.h\"\n\n#if PY_MAJOR_VERSION >= 3\n# include \"file_emulator.h\"\n#endif\n\n#ifdef PyUnicode_KIND     /* Python >= 3.3 */\n# include \"wchar_helper_3.h\"\n#else\n# include \"wchar_helper.h\"\n#endif\n\n#include \"../cffi/_cffi_errors.h\"\n\ntypedef struct _cffi_allocator_s {\n    PyObject *ca_alloc, *ca_free;\n    int ca_dont_clear;\n} cffi_allocator_t;\nstatic const cffi_allocator_t default_allocator = { NULL, NULL, 0 };\nstatic PyObject *FFIError;\nstatic PyObject *unique_cache;\n\n/************************************************************/\n\nstatic CTypeDescrObject *\nctypedescr_new(int name_size)\n{\n    CTypeDescrObject *ct = PyObject_GC_NewVar(CTypeDescrObject,\n                                              &CTypeDescr_Type,\n                                              name_size);\n    if (ct == NULL)\n        return NULL;\n\n    ct->ct_itemdescr = NULL;\n    ct->ct_stuff = NULL;\n    ct->ct_weakreflist = NULL;\n    ct->ct_unique_key = NULL;\n    PyObject_GC_Track(ct);\n    return ct;\n}\n\nstatic CTypeDescrObject *\nctypedescr_new_on_top(CTypeDescrObject *ct_base, const char *extra_text,\n                      int extra_position)\n{\n    int base_name_len = strlen(ct_base->ct_name);\n    int extra_name_len = strlen(extra_text);\n    CTypeDescrObject *ct = ctypedescr_new(base_name_len + extra_name_len + 1);\n    char *p;\n    if (ct == NULL)\n        return NULL;\n\n    Py_INCREF(ct_base);\n    ct->ct_itemdescr = ct_base;\n    ct->ct_name_position = ct_base->ct_name_position + extra_position;\n\n    p = ct->ct_name;\n    memcpy(p, ct_base->ct_name, ct_base->ct_name_position);\n    p += ct_base->ct_name_position;\n    memcpy(p, extra_text, extra_name_len);\n    p += extra_name_len;\n    memcpy(p, ct_base->ct_name + ct_base->ct_name_position,\n           base_name_len - ct_base->ct_name_position + 1);\n\n    return ct;\n}\n\nstatic PyObject *\nctypedescr_repr(CTypeDescrObject *ct)\n{\n    return PyText_FromFormat(\"<ctype '%s'>\", ct->ct_name);\n}\n\nstatic void\nctypedescr_dealloc(CTypeDescrObject *ct)\n{\n    PyObject_GC_UnTrack(ct);\n    if (ct->ct_weakreflist != NULL)\n        PyObject_ClearWeakRefs((PyObject *) ct);\n\n    if (ct->ct_unique_key != NULL) {\n        /* revive dead object temporarily for DelItem */\n        Py_REFCNT(ct) = 43;\n        PyDict_DelItem(unique_cache, ct->ct_unique_key);\n        assert(Py_REFCNT(ct) == 42);\n        Py_REFCNT(ct) = 0;\n        Py_DECREF(ct->ct_unique_key);\n    }\n    Py_XDECREF(ct->ct_itemdescr);\n    Py_XDECREF(ct->ct_stuff);\n    if (ct->ct_flags & CT_FUNCTIONPTR)\n        PyObject_Free(ct->ct_extra);\n    Py_TYPE(ct)->tp_free((PyObject *)ct);\n}\n\nstatic int\nctypedescr_traverse(CTypeDescrObject *ct, visitproc visit, void *arg)\n{\n    Py_VISIT(ct->ct_itemdescr);\n    Py_VISIT(ct->ct_stuff);\n    return 0;\n}\n\nstatic int\nctypedescr_clear(CTypeDescrObject *ct)\n{\n    Py_CLEAR(ct->ct_itemdescr);\n    Py_CLEAR(ct->ct_stuff);\n    return 0;\n}\n\n\nstatic PyObject *nosuchattr(const char *attr)\n{\n    PyErr_SetString(PyExc_AttributeError, attr);\n    return NULL;\n}\n\nstatic PyObject *ctypeget_kind(CTypeDescrObject *ct, void *context)\n{\n    char *result;\n    if (ct->ct_flags & CT_PRIMITIVE_ANY) {\n        if (ct->ct_flags & CT_IS_ENUM)\n            result = \"enum\";\n        else\n            result = \"primitive\";\n    }\n    else if (ct->ct_flags & CT_POINTER) {\n        result = \"pointer\";\n    }\n    else if (ct->ct_flags & CT_ARRAY) {\n        result = \"array\";\n    }\n    else if (ct->ct_flags & CT_VOID) {\n        result = \"void\";\n    }\n    else if (ct->ct_flags & CT_STRUCT) {\n        result = \"struct\";\n    }\n    else if (ct->ct_flags & CT_UNION) {\n        result = \"union\";\n    }\n    else if (ct->ct_flags & CT_FUNCTIONPTR) {\n        result = \"function\";\n    }\n    else\n        result = \"?\";\n\n    return PyText_FromString(result);\n}\n\nstatic PyObject *ctypeget_cname(CTypeDescrObject *ct, void *context)\n{\n    return PyText_FromString(ct->ct_name);\n}\n\nstatic PyObject *ctypeget_item(CTypeDescrObject *ct, void *context)\n{\n    if (ct->ct_flags & (CT_POINTER | CT_ARRAY)) {\n        Py_INCREF(ct->ct_itemdescr);\n        return (PyObject *)ct->ct_itemdescr;\n    }\n    return nosuchattr(\"item\");\n}\n\nstatic PyObject *ctypeget_length(CTypeDescrObject *ct, void *context)\n{\n    if (ct->ct_flags & CT_ARRAY) {\n        if (ct->ct_length >= 0) {\n            return PyInt_FromSsize_t(ct->ct_length);\n        }\n        else {\n            Py_INCREF(Py_None);\n            return Py_None;\n        }\n    }\n    return nosuchattr(\"length\");\n}\n\nstatic PyObject *\nget_field_name(CTypeDescrObject *ct, CFieldObject *cf);   /* forward */\n\n/* returns 0 if the struct ctype is opaque, 1 if it is not, or -1 if\n   an exception occurs */\n#define force_lazy_struct(ct)                                           \\\n    ((ct)->ct_stuff != NULL ? 1 : do_realize_lazy_struct(ct))\n\nstatic int do_realize_lazy_struct(CTypeDescrObject *ct);\n/* forward, implemented in realize_c_type.c */\n\nstatic PyObject *ctypeget_fields(CTypeDescrObject *ct, void *context)\n{\n    if (ct->ct_flags & (CT_STRUCT | CT_UNION)) {\n        if (!(ct->ct_flags & CT_IS_OPAQUE)) {\n            CFieldObject *cf;\n            PyObject *res;\n            if (force_lazy_struct(ct) < 0)\n                return NULL;\n            res = PyList_New(0);\n            if (res == NULL)\n                return NULL;\n            for (cf = (CFieldObject *)ct->ct_extra;\n                 cf != NULL; cf = cf->cf_next) {\n                PyObject *o = PyTuple_Pack(2, get_field_name(ct, cf),\n                                           (PyObject *)cf);\n                int err = (o != NULL) ? PyList_Append(res, o) : -1;\n                Py_XDECREF(o);\n                if (err < 0) {\n                    Py_DECREF(res);\n                    return NULL;\n                }\n            }\n            return res;\n        }\n        else {\n            Py_INCREF(Py_None);\n            return Py_None;\n        }\n    }\n    return nosuchattr(\"fields\");\n}\n\nstatic PyObject *ctypeget_args(CTypeDescrObject *ct, void *context)\n{\n    if (ct->ct_flags & CT_FUNCTIONPTR) {\n        PyObject *t = ct->ct_stuff;\n        return PyTuple_GetSlice(t, 2, PyTuple_GET_SIZE(t));\n    }\n    return nosuchattr(\"args\");\n}\n\nstatic PyObject *ctypeget_result(CTypeDescrObject *ct, void *context)\n{\n    if (ct->ct_flags & CT_FUNCTIONPTR) {\n        PyObject *res = PyTuple_GetItem(ct->ct_stuff, 1);\n        Py_XINCREF(res);\n        return res;\n    }\n    return nosuchattr(\"result\");\n}\n\nstatic PyObject *ctypeget_ellipsis(CTypeDescrObject *ct, void *context)\n{\n    if (ct->ct_flags & CT_FUNCTIONPTR) {\n        PyObject *res = ct->ct_extra ? Py_False : Py_True;\n        Py_INCREF(res);\n        return res;\n    }\n    return nosuchattr(\"ellipsis\");\n}\n\nstatic PyObject *ctypeget_abi(CTypeDescrObject *ct, void *context)\n{\n    if (ct->ct_flags & CT_FUNCTIONPTR) {\n        PyObject *res = PyTuple_GetItem(ct->ct_stuff, 0);\n        Py_XINCREF(res);\n        return res;\n    }\n    return nosuchattr(\"abi\");\n}\n\nstatic PyObject *ctypeget_elements(CTypeDescrObject *ct, void *context)\n{\n    if (ct->ct_flags & CT_IS_ENUM) {\n        PyObject *res = PyTuple_GetItem(ct->ct_stuff, 1);\n        if (res) res = PyDict_Copy(res);\n        return res;\n    }\n    return nosuchattr(\"elements\");\n}\n\nstatic PyObject *ctypeget_relements(CTypeDescrObject *ct, void *context)\n{\n    if (ct->ct_flags & CT_IS_ENUM) {\n        PyObject *res = PyTuple_GetItem(ct->ct_stuff, 0);\n        if (res) res = PyDict_Copy(res);\n        return res;\n    }\n    return nosuchattr(\"relements\");\n}\n\nstatic PyGetSetDef ctypedescr_getsets[] = {\n    {\"kind\", (getter)ctypeget_kind, NULL, \"kind\"},\n    {\"cname\", (getter)ctypeget_cname, NULL, \"C name\"},\n    {\"item\", (getter)ctypeget_item, NULL, \"pointer to, or array of\"},\n    {\"length\", (getter)ctypeget_length, NULL, \"array length or None\"},\n    {\"fields\", (getter)ctypeget_fields, NULL, \"struct or union fields\"},\n    {\"args\", (getter)ctypeget_args, NULL, \"function argument types\"},\n    {\"result\", (getter)ctypeget_result, NULL, \"function result type\"},\n    {\"ellipsis\", (getter)ctypeget_ellipsis, NULL, \"function has '...'\"},\n    {\"abi\", (getter)ctypeget_abi, NULL, \"function ABI\"},\n    {\"elements\", (getter)ctypeget_elements, NULL, \"enum elements\"},\n    {\"relements\", (getter)ctypeget_relements, NULL, \"enum elements, reverse\"},\n    {NULL}                        /* sentinel */\n};\n\nstatic PyObject *\nctypedescr_dir(PyObject *ct, PyObject *noarg)\n{\n    int err;\n    struct PyGetSetDef *gsdef;\n    PyObject *res = PyList_New(0);\n    if (res == NULL)\n        return NULL;\n\n    for (gsdef = ctypedescr_getsets; gsdef->name; gsdef++) {\n        PyObject *x = PyObject_GetAttrString(ct, gsdef->name);\n        if (x == NULL) {\n            PyErr_Clear();\n        }\n        else {\n            Py_DECREF(x);\n            x = PyText_FromString(gsdef->name);\n            err = (x != NULL) ? PyList_Append(res, x) : -1;\n            Py_XDECREF(x);\n            if (err < 0) {\n                Py_DECREF(res);\n                return NULL;\n            }\n        }\n    }\n    return res;\n}\n\nstatic PyMethodDef ctypedescr_methods[] = {\n    {\"__dir__\",   ctypedescr_dir,  METH_NOARGS},\n    {NULL,        NULL}           /* sentinel */\n};\n\nstatic PyTypeObject CTypeDescr_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_cffi_backend.CTypeDescr\",\n    offsetof(CTypeDescrObject, ct_name),\n    sizeof(char),\n    (destructor)ctypedescr_dealloc,             /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_compare */\n    (reprfunc)ctypedescr_repr,                  /* tp_repr */\n    0,                                          /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    PyObject_GenericGetAttr,                    /* tp_getattro */\n    0,                                          /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,    /* tp_flags */\n    0,                                          /* tp_doc */\n    (traverseproc)ctypedescr_traverse,          /* tp_traverse */\n    (inquiry)ctypedescr_clear,                  /* tp_clear */\n    0,                                          /* tp_richcompare */\n    offsetof(CTypeDescrObject, ct_weakreflist), /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    ctypedescr_methods,                         /* tp_methods */\n    0,                                          /* tp_members */\n    ctypedescr_getsets,                         /* tp_getset */\n};\n\n/************************************************************/\n\nstatic PyObject *\nget_field_name(CTypeDescrObject *ct, CFieldObject *cf)\n{\n    Py_ssize_t i = 0;\n    PyObject *d_key, *d_value;\n    while (PyDict_Next(ct->ct_stuff, &i, &d_key, &d_value)) {\n        if (d_value == (PyObject *)cf)\n            return d_key;\n    }\n    Py_FatalError(\"_cffi_backend: get_field_name()\");\n    return NULL;\n}\n\nstatic void\ncfield_dealloc(CFieldObject *cf)\n{\n    Py_DECREF(cf->cf_type);\n    PyObject_Del(cf);\n}\n\n#undef OFF\n#define OFF(x) offsetof(CFieldObject, x)\n\nstatic PyMemberDef cfield_members[] = {\n    {\"type\", T_OBJECT, OFF(cf_type), READONLY},\n    {\"offset\", T_PYSSIZET, OFF(cf_offset), READONLY},\n    {\"bitshift\", T_SHORT, OFF(cf_bitshift), READONLY},\n    {\"bitsize\", T_SHORT, OFF(cf_bitsize), READONLY},\n    {\"flags\", T_UBYTE, OFF(cf_flags), READONLY},\n    {NULL}      /* Sentinel */\n};\n#undef OFF\n\nstatic PyTypeObject CField_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_cffi_backend.CField\",\n    sizeof(CFieldObject),\n    0,\n    (destructor)cfield_dealloc,                 /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_compare */\n    0,                                          /* tp_repr */\n    0,                                          /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    PyObject_GenericGetAttr,                    /* tp_getattro */\n    0,                                          /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT,                         /* tp_flags */\n    0,                                          /* tp_doc */\n    0,                                          /* tp_traverse */\n    0,                                          /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    0,                                          /* tp_methods */\n    cfield_members,                             /* tp_members */\n};\n\n/************************************************************/\n\nstatic int\nCDataObject_Or_PyFloat_Check(PyObject *ob)\n{\n    return (PyFloat_Check(ob) ||\n            (CData_Check(ob) &&\n             (((CDataObject *)ob)->c_type->ct_flags & CT_PRIMITIVE_FLOAT)));\n}\n\nstatic PY_LONG_LONG\n_my_PyLong_AsLongLong(PyObject *ob)\n{\n    /* (possibly) convert and cast a Python object to a long long.\n       Like PyLong_AsLongLong(), this version accepts a Python int too, and\n       does convertions from other types of objects.  The difference is that\n       this version refuses floats. */\n#if PY_MAJOR_VERSION < 3\n    if (PyInt_Check(ob)) {\n        return PyInt_AS_LONG(ob);\n    }\n    else \n#endif\n    if (PyLong_Check(ob)) {\n        return PyLong_AsLongLong(ob);\n    }\n    else {\n        PyObject *io;\n        PY_LONG_LONG res;\n        PyNumberMethods *nb = ob->ob_type->tp_as_number;\n\n        if (CDataObject_Or_PyFloat_Check(ob) ||\n                nb == NULL || nb->nb_int == NULL) {\n            PyErr_SetString(PyExc_TypeError, \"an integer is required\");\n            return -1;\n        }\n        io = (*nb->nb_int) (ob);\n        if (io == NULL)\n            return -1;\n\n        if (PyIntOrLong_Check(io)) {\n            res = _my_PyLong_AsLongLong(io);\n        }\n        else {\n            PyErr_SetString(PyExc_TypeError, \"integer conversion failed\");\n            res = -1;\n        }\n        Py_DECREF(io);\n        return res;\n    }\n}\n\nstatic unsigned PY_LONG_LONG\n_my_PyLong_AsUnsignedLongLong(PyObject *ob, int strict)\n{\n    /* (possibly) convert and cast a Python object to an unsigned long long.\n       Like PyLong_AsLongLong(), this version accepts a Python int too, and\n       does convertions from other types of objects.  If 'strict', complains\n       with OverflowError and refuses floats.  If '!strict', rounds floats\n       and masks the result. */\n#if PY_MAJOR_VERSION < 3\n    if (PyInt_Check(ob)) {\n        long value1 = PyInt_AS_LONG(ob);\n        if (strict && value1 < 0)\n            goto negative;\n        return (unsigned PY_LONG_LONG)(PY_LONG_LONG)value1;\n    }\n    else\n#endif\n    if (PyLong_Check(ob)) {\n        if (strict) {\n            if (_PyLong_Sign(ob) < 0)\n                goto negative;\n            return PyLong_AsUnsignedLongLong(ob);\n        }\n        else {\n            return PyLong_AsUnsignedLongLongMask(ob);\n        }\n    }\n    else {\n        PyObject *io;\n        unsigned PY_LONG_LONG res;\n        PyNumberMethods *nb = ob->ob_type->tp_as_number;\n\n        if ((strict && CDataObject_Or_PyFloat_Check(ob)) ||\n                nb == NULL || nb->nb_int == NULL) {\n            PyErr_SetString(PyExc_TypeError, \"an integer is required\");\n            return (unsigned PY_LONG_LONG)-1;\n        }\n        io = (*nb->nb_int) (ob);\n        if (io == NULL)\n            return (unsigned PY_LONG_LONG)-1;\n\n        if (PyIntOrLong_Check(io)) {\n            res = _my_PyLong_AsUnsignedLongLong(io, strict);\n        }\n        else {\n            PyErr_SetString(PyExc_TypeError, \"integer conversion failed\");\n            res = (unsigned PY_LONG_LONG)-1;\n        }\n        Py_DECREF(io);\n        return res;\n    }\n\n negative:\n    PyErr_SetString(PyExc_OverflowError,\n                    \"can't convert negative number to unsigned\");\n    return (unsigned PY_LONG_LONG)-1;\n}\n\n#define _read_raw_data(type)                    \\\n    do {                                        \\\n        if (size == sizeof(type)) {             \\\n            type r;                             \\\n            memcpy(&r, target, sizeof(type));   \\\n            return r;                           \\\n        }                                       \\\n    } while(0)\n\nstatic PY_LONG_LONG\nread_raw_signed_data(char *target, int size)\n{\n    _read_raw_data(signed char);\n    _read_raw_data(short);\n    _read_raw_data(int);\n    _read_raw_data(long);\n    _read_raw_data(PY_LONG_LONG);\n    Py_FatalError(\"read_raw_signed_data: bad integer size\");\n    return 0;\n}\n\nstatic unsigned PY_LONG_LONG\nread_raw_unsigned_data(char *target, int size)\n{\n    _read_raw_data(unsigned char);\n    _read_raw_data(unsigned short);\n    _read_raw_data(unsigned int);\n    _read_raw_data(unsigned long);\n    _read_raw_data(unsigned PY_LONG_LONG);\n    Py_FatalError(\"read_raw_unsigned_data: bad integer size\");\n    return 0;\n}\n\n#ifdef __GNUC__\n/* This is a workaround for what I think is a GCC bug on several\n   platforms.  See issue #378. */\n__attribute__((noinline))\n#endif\nvoid _cffi_memcpy(char *target, const void *src, size_t size)\n{\n    memcpy(target, src, size);\n}\n\n#define _write_raw_data(type)                           \\\n    do {                                                \\\n        if (size == sizeof(type)) {                     \\\n            type r = (type)source;                      \\\n            _cffi_memcpy(target, &r, sizeof(type));           \\\n            return;                                     \\\n        }                                               \\\n    } while(0)\n\nstatic void\nwrite_raw_integer_data(char *target, unsigned PY_LONG_LONG source, int size)\n{\n    _write_raw_data(unsigned char);\n    _write_raw_data(unsigned short);\n    _write_raw_data(unsigned int);\n    _write_raw_data(unsigned long);\n    _write_raw_data(unsigned PY_LONG_LONG);\n    Py_FatalError(\"write_raw_integer_data: bad integer size\");\n}\n\nstatic double\nread_raw_float_data(char *target, int size)\n{\n    _read_raw_data(float);\n    _read_raw_data(double);\n    Py_FatalError(\"read_raw_float_data: bad float size\");\n    return 0;\n}\n\nstatic long double\nread_raw_longdouble_data(char *target)\n{\n    int size = sizeof(long double);\n    _read_raw_data(long double);\n    Py_FatalError(\"read_raw_longdouble_data: bad long double size\");\n    return 0;\n}\n\nstatic Py_complex\nread_raw_complex_data(char *target, int size)\n{\n    Py_complex r = {0.0, 0.0};\n    if (size == 2*sizeof(float)) {\n        float real_part, imag_part;\n        memcpy(&real_part, target + 0,             sizeof(float));\n        memcpy(&imag_part, target + sizeof(float), sizeof(float));\n        r.real = real_part;\n        r.imag = imag_part;\n        return r;\n    }\n    if (size == 2*sizeof(double)) {\n        memcpy(&r, target, 2*sizeof(double));\n        return r;\n    }\n    Py_FatalError(\"read_raw_complex_data: bad complex size\");\n    return r;\n}\n\nstatic void\nwrite_raw_float_data(char *target, double source, int size)\n{\n    _write_raw_data(float);\n    _write_raw_data(double);\n    Py_FatalError(\"write_raw_float_data: bad float size\");\n}\n\nstatic void\nwrite_raw_longdouble_data(char *target, long double source)\n{\n    int size = sizeof(long double);\n    _write_raw_data(long double);\n}\n\n#define _write_raw_complex_data(type)                      \\\n    do {                                                   \\\n        if (size == 2*sizeof(type)) {                      \\\n            type r = (type)source.real;                    \\\n            type i = (type)source.imag;                    \\\n            _cffi_memcpy(target, &r, sizeof(type));              \\\n            _cffi_memcpy(target+sizeof(type), &i, sizeof(type)); \\\n            return;                                        \\\n        }                                                  \\\n    } while(0)\n\nstatic void\nwrite_raw_complex_data(char *target, Py_complex source, int size)\n{\n    _write_raw_complex_data(float);\n    _write_raw_complex_data(double);\n    Py_FatalError(\"write_raw_complex_data: bad complex size\");\n}\n\nstatic PyObject *\nnew_simple_cdata(char *data, CTypeDescrObject *ct)\n{\n    CDataObject *cd = PyObject_New(CDataObject, &CData_Type);\n    if (cd == NULL)\n        return NULL;\n    Py_INCREF(ct);\n    cd->c_data = data;\n    cd->c_type = ct;\n    cd->c_weakreflist = NULL;\n    return (PyObject *)cd;\n}\n\nstatic PyObject *\nnew_sized_cdata(char *data, CTypeDescrObject *ct, Py_ssize_t length)\n{\n    CDataObject_own_length *scd;\n\n    scd = (CDataObject_own_length *)PyObject_Malloc(\n        offsetof(CDataObject_own_length, alignment));\n    if (PyObject_Init((PyObject *)scd, &CData_Type) == NULL)\n        return NULL;\n    Py_INCREF(ct);\n    scd->head.c_type = ct;\n    scd->head.c_data = data;\n    scd->head.c_weakreflist = NULL;\n    scd->length = length;\n    return (PyObject *)scd;\n}\n\nstatic CDataObject *_new_casted_primitive(CTypeDescrObject *ct);  /*forward*/\n\nstatic PyObject *\nconvert_to_object(char *data, CTypeDescrObject *ct)\n{\n    if (!(ct->ct_flags & CT_PRIMITIVE_ANY)) {\n        /* non-primitive types (check done just for performance) */\n        if (ct->ct_flags & (CT_POINTER|CT_FUNCTIONPTR)) {\n            char *ptrdata = *(char **)data;\n            /*READ(data, sizeof(char *))*/\n            return new_simple_cdata(ptrdata, ct);\n        }\n        else if (ct->ct_flags & CT_IS_OPAQUE) {\n            PyErr_Format(PyExc_TypeError, \"cdata '%s' is opaque\",\n                         ct->ct_name);\n            return NULL;\n        }\n        else if (ct->ct_flags & (CT_STRUCT|CT_UNION)) {\n            return new_simple_cdata(data, ct);\n        }\n        else if (ct->ct_flags & CT_ARRAY) {\n            if (ct->ct_length < 0) {\n                /* we can't return a <cdata 'int[]'> here, because we don't\n                   know the length to give it.  As a compromize, returns\n                   <cdata 'int *'> in this case. */\n                ct = (CTypeDescrObject *)ct->ct_stuff;\n            }\n            return new_simple_cdata(data, ct);\n        }\n    }\n    else if (ct->ct_flags & CT_PRIMITIVE_SIGNED) {\n        PY_LONG_LONG value;\n        /*READ(data, ct->ct_size)*/\n        value = read_raw_signed_data(data, ct->ct_size);\n        if (ct->ct_flags & CT_PRIMITIVE_FITS_LONG)\n            return PyInt_FromLong((long)value);\n        else\n            return PyLong_FromLongLong(value);\n    }\n    else if (ct->ct_flags & CT_PRIMITIVE_UNSIGNED) {\n        unsigned PY_LONG_LONG value;\n        /*READ(data, ct->ct_size)*/\n        value = read_raw_unsigned_data(data, ct->ct_size);\n\n        if (ct->ct_flags & CT_PRIMITIVE_FITS_LONG) {\n            if (ct->ct_flags & CT_IS_BOOL) {\n                PyObject *x;\n                switch ((int)value) {\n                case 0: x = Py_False; break;\n                case 1: x = Py_True; break;\n                default:\n                    PyErr_Format(PyExc_ValueError,\n                                 \"got a _Bool of value %d, expected 0 or 1\",\n                                 (int)value);\n                    return NULL;\n                }\n                Py_INCREF(x);\n                return x;\n            }\n            return PyInt_FromLong((long)value);\n        }\n        else\n            return PyLong_FromUnsignedLongLong(value);\n    }\n    else if (ct->ct_flags & CT_PRIMITIVE_FLOAT) {\n        /*READ(data, ct->ct_size)*/\n        if (!(ct->ct_flags & CT_IS_LONGDOUBLE)) {\n            double value = read_raw_float_data(data, ct->ct_size);\n            return PyFloat_FromDouble(value);\n        }\n        else {\n            long double value = read_raw_longdouble_data(data);\n            CDataObject *cd = _new_casted_primitive(ct);\n            if (cd != NULL)\n                write_raw_longdouble_data(cd->c_data, value);\n            return (PyObject *)cd;\n        }\n    }\n    else if (ct->ct_flags & CT_PRIMITIVE_CHAR) {\n        /*READ(data, ct->ct_size)*/\n        switch (ct->ct_size) {\n        case sizeof(char):\n            return PyBytes_FromStringAndSize(data, 1);\n        case 2:\n            return _my_PyUnicode_FromChar16((cffi_char16_t *)data, 1);\n        case 4:\n            return _my_PyUnicode_FromChar32((cffi_char32_t *)data, 1);\n        }\n    }\n    else if (ct->ct_flags & CT_PRIMITIVE_COMPLEX) {\n        Py_complex value = read_raw_complex_data(data, ct->ct_size);\n        return PyComplex_FromCComplex(value);\n    }\n\n    PyErr_Format(PyExc_SystemError,\n                 \"convert_to_object: '%s'\", ct->ct_name);\n    return NULL;\n}\n\nstatic PyObject *\nconvert_to_object_bitfield(char *data, CFieldObject *cf)\n{\n    CTypeDescrObject *ct = cf->cf_type;\n    /*READ(data, ct->ct_size)*/\n\n    if (ct->ct_flags & CT_PRIMITIVE_SIGNED) {\n        unsigned PY_LONG_LONG value, valuemask, shiftforsign;\n        PY_LONG_LONG result;\n\n        value = (unsigned PY_LONG_LONG)read_raw_signed_data(data, ct->ct_size);\n        valuemask = (1ULL << cf->cf_bitsize) - 1ULL;\n        shiftforsign = 1ULL << (cf->cf_bitsize - 1);\n        value = ((value >> cf->cf_bitshift) + shiftforsign) & valuemask;\n        result = ((PY_LONG_LONG)value) - (PY_LONG_LONG)shiftforsign;\n\n        if (ct->ct_flags & CT_PRIMITIVE_FITS_LONG)\n            return PyInt_FromLong((long)result);\n        else\n            return PyLong_FromLongLong(result);\n    }\n    else {\n        unsigned PY_LONG_LONG value, valuemask;\n\n        value = read_raw_unsigned_data(data, ct->ct_size);\n        valuemask = (1ULL << cf->cf_bitsize) - 1ULL;\n        value = (value >> cf->cf_bitshift) & valuemask;\n\n        if (ct->ct_flags & CT_PRIMITIVE_FITS_LONG)\n            return PyInt_FromLong((long)value);\n        else\n            return PyLong_FromUnsignedLongLong(value);\n    }\n}\n\nstatic int _convert_overflow(PyObject *init, const char *ct_name)\n{\n    PyObject *s;\n    if (PyErr_Occurred())   /* already an exception pending */\n        return -1;\n    s = PyObject_Str(init);\n    if (s == NULL)\n        return -1;\n    PyErr_Format(PyExc_OverflowError, \"integer %s does not fit '%s'\",\n                 PyText_AS_UTF8(s), ct_name);\n    Py_DECREF(s);\n    return -1;\n}\n\nstatic int _convert_to_char(PyObject *init)\n{\n    if (PyBytes_Check(init) && PyBytes_GET_SIZE(init) == 1) {\n        return (unsigned char)(PyBytes_AS_STRING(init)[0]);\n    }\n    if (CData_Check(init) &&\n           (((CDataObject *)init)->c_type->ct_flags & CT_PRIMITIVE_CHAR) &&\n           (((CDataObject *)init)->c_type->ct_size == sizeof(char))) {\n        char *data = ((CDataObject *)init)->c_data;\n        /*READ(data, 1)*/\n        return *(unsigned char *)data;\n    }\n    PyErr_Format(PyExc_TypeError,\n                 \"initializer for ctype 'char' must be a \"STR_OR_BYTES\n                 \" of length 1, not %.200s\", Py_TYPE(init)->tp_name);\n    return -1;\n}\n\nstatic cffi_char16_t _convert_to_char16_t(PyObject *init)\n{\n    char err_got[80];\n    err_got[0] = 0;\n\n    if (PyUnicode_Check(init)) {\n        cffi_char16_t ordinal;\n        if (_my_PyUnicode_AsSingleChar16(init, &ordinal, err_got) == 0)\n            return ordinal;\n    }\n    if (CData_Check(init) &&\n           (((CDataObject *)init)->c_type->ct_flags & CT_PRIMITIVE_CHAR) &&\n           (((CDataObject *)init)->c_type->ct_size == 2)) {\n        char *data = ((CDataObject *)init)->c_data;\n        /*READ(data, 2)*/\n        return *(cffi_char16_t *)data;\n    }\n    PyErr_Format(PyExc_TypeError,\n                 \"initializer for ctype 'char16_t' must be a unicode string \"\n                 \"of length 1, not %.200s\",\n                 err_got[0] == 0 ? Py_TYPE(init)->tp_name : err_got);\n    return (cffi_char16_t)-1;\n}\n\nstatic cffi_char32_t _convert_to_char32_t(PyObject *init)\n{\n    char err_got[80];\n    err_got[0] = 0;\n\n    if (PyUnicode_Check(init)) {\n        cffi_char32_t ordinal;\n        if (_my_PyUnicode_AsSingleChar32(init, &ordinal, err_got) == 0)\n            return ordinal;\n    }\n    if (CData_Check(init) &&\n           (((CDataObject *)init)->c_type->ct_flags & CT_PRIMITIVE_CHAR) &&\n           (((CDataObject *)init)->c_type->ct_size == 4)) {\n        char *data = ((CDataObject *)init)->c_data;\n        /*READ(data, 4)*/\n        return *(cffi_char32_t *)data;\n    }\n    PyErr_Format(PyExc_TypeError,\n                 \"initializer for ctype 'char32_t' must be a unicode string \"\n                 \"of length 1, not %.200s\",\n                 err_got[0] == 0 ? Py_TYPE(init)->tp_name : err_got);\n    return (cffi_char32_t)-1;\n}\n\nstatic int _convert_error(PyObject *init, CTypeDescrObject *ct,\n                          const char *expected)\n{\n    if (CData_Check(init)) {\n        CTypeDescrObject *ct2 = ((CDataObject *)init)->c_type;\n        if (strcmp(ct->ct_name, ct2->ct_name) != 0)\n            PyErr_Format(PyExc_TypeError,\n                         \"initializer for ctype '%s' must be a %s, \"\n                         \"not cdata '%s'\",\n                         ct->ct_name, expected, ct2->ct_name);\n        else if (ct != ct2) {\n            /* in case we'd give the error message \"initializer for\n               ctype 'A' must be a pointer to same type, not cdata\n               'B'\", but with A=B, then give instead a different error\n               message to try to clear up the confusion */\n            PyErr_Format(PyExc_TypeError,\n                         \"initializer for ctype '%s' appears indeed to be '%s',\"\n                         \" but the types are different (check that you are not\"\n                         \" e.g. mixing up different ffi instances)\",\n                         ct->ct_name, ct2->ct_name);\n        }\n        else\n        {\n            PyErr_Format(PyExc_SystemError,\n                         \"initializer for ctype '%s' is correct, but we get \"\n                         \"an internal mismatch--please report a bug\",\n                         ct->ct_name);\n        }\n    }\n    else\n        PyErr_Format(PyExc_TypeError,\n                     \"initializer for ctype '%s' must be a %s, \"\n                     \"not %.200s\",\n                     ct->ct_name, expected, Py_TYPE(init)->tp_name);\n    return -1;\n}\n\nstatic int    /* forward */\nconvert_from_object(char *data, CTypeDescrObject *ct, PyObject *init);\nstatic int    /* forward */\nconvert_from_object_bitfield(char *data, CFieldObject *cf, PyObject *init);\n\nstatic Py_ssize_t\nget_new_array_length(CTypeDescrObject *ctitem, PyObject **pvalue)\n{\n    PyObject *value = *pvalue;\n\n    if (PyList_Check(value) || PyTuple_Check(value)) {\n        return PySequence_Fast_GET_SIZE(value);\n    }\n    else if (PyBytes_Check(value)) {\n        /* from a string, we add the null terminator */\n        return PyBytes_GET_SIZE(value) + 1;\n    }\n    else if (PyUnicode_Check(value)) {\n        /* from a unicode, we add the null terminator */\n        int length;\n        if (ctitem->ct_size == 2)\n            length = _my_PyUnicode_SizeAsChar16(value);\n        else\n            length = _my_PyUnicode_SizeAsChar32(value);\n        return length + 1;\n    }\n    else {\n        Py_ssize_t explicitlength;\n        explicitlength = PyNumber_AsSsize_t(value, PyExc_OverflowError);\n        if (explicitlength < 0) {\n            if (PyErr_Occurred()) {\n                if (PyErr_ExceptionMatches(PyExc_TypeError))\n                    PyErr_Format(PyExc_TypeError,\n                        \"expected new array length or list/tuple/str, \"\n                        \"not %.200s\", Py_TYPE(value)->tp_name);\n            }\n            else\n                PyErr_SetString(PyExc_ValueError, \"negative array length\");\n            return -1;\n        }\n        *pvalue = Py_None;\n        return explicitlength;\n    }\n}\n\nstatic int\nconvert_field_from_object(char *data, CFieldObject *cf, PyObject *value)\n{\n    data += cf->cf_offset;\n    if (cf->cf_bitshift >= 0)\n        return convert_from_object_bitfield(data, cf, value);\n    else\n        return convert_from_object(data, cf->cf_type, value);\n}\n\nstatic int\nadd_varsize_length(Py_ssize_t offset, Py_ssize_t itemsize,\n                   Py_ssize_t varsizelength, Py_ssize_t *optvarsize)\n{\n    /* update '*optvarsize' to account for an array of 'varsizelength'\n       elements, each of size 'itemsize', that starts at 'offset'. */\n    Py_ssize_t size = ADD_WRAPAROUND(offset,\n                              MUL_WRAPAROUND(itemsize, varsizelength));\n    if (size < 0 ||\n        ((size - offset) / itemsize) != varsizelength) {\n        PyErr_SetString(PyExc_OverflowError,\n                        \"array size would overflow a Py_ssize_t\");\n        return -1;\n    }\n    if (size > *optvarsize)\n        *optvarsize = size;\n    return 0;\n}\n\nstatic int\nconvert_struct_from_object(char *data, CTypeDescrObject *ct, PyObject *init,\n                           Py_ssize_t *optvarsize);  /* forward */\n\nstatic int\nconvert_vfield_from_object(char *data, CFieldObject *cf, PyObject *value,\n                           Py_ssize_t *optvarsize)\n{\n    /* a special case for var-sized C99 arrays */\n    if ((cf->cf_type->ct_flags & CT_ARRAY) && cf->cf_type->ct_size < 0) {\n        Py_ssize_t varsizelength = get_new_array_length(\n                                      cf->cf_type->ct_itemdescr, &value);\n        if (varsizelength < 0)\n            return -1;\n        if (optvarsize != NULL) {\n            /* in this mode, the only purpose of this function is to compute\n               the real size of the structure from a var-sized C99 array */\n            assert(data == NULL);\n            return add_varsize_length(cf->cf_offset,\n                cf->cf_type->ct_itemdescr->ct_size,\n                varsizelength,\n                optvarsize);\n        }\n        /* if 'value' was only an integer, get_new_array_length() returns\n           it and convert 'value' to be None.  Detect if this was the case,\n           and if so, stop here, leaving the content uninitialized\n           (it should be zero-initialized from somewhere else). */\n        if (value == Py_None)\n            return 0;\n    }\n    if (optvarsize == NULL) {\n        return convert_field_from_object(data, cf, value);\n    }\n    else if ((cf->cf_type->ct_flags & CT_WITH_VAR_ARRAY) != 0 &&\n             !CData_Check(value)) {\n        Py_ssize_t subsize = cf->cf_type->ct_size;\n        if (convert_struct_from_object(NULL, cf->cf_type, value, &subsize) < 0)\n            return -1;\n        return add_varsize_length(cf->cf_offset, 1, subsize, optvarsize);\n    }\n    else\n        return 0;\n}\n\nstatic int\nmust_be_array_of_zero_or_one(const char *data, Py_ssize_t n)\n{\n    Py_ssize_t i;\n    for (i = 0; i < n; i++) {\n        if (((unsigned char)data[i]) > 1) {\n            PyErr_SetString(PyExc_ValueError,\n                \"an array of _Bool can only contain \\\\x00 or \\\\x01\");\n            return -1;\n        }\n    }\n    return 0;\n}\n\nstatic Py_ssize_t\nget_array_length(CDataObject *cd)\n{\n    if (cd->c_type->ct_length < 0)\n        return ((CDataObject_own_length *)cd)->length;\n    else\n        return cd->c_type->ct_length;\n}\n\nstatic int\nconvert_array_from_object(char *data, CTypeDescrObject *ct, PyObject *init)\n{\n    /* used by convert_from_object(), and also to decode lists/tuples/unicodes\n       passed as function arguments.  'ct' is an CT_ARRAY in the first case\n       and a CT_POINTER in the second case. */\n    const char *expected;\n    CTypeDescrObject *ctitem = ct->ct_itemdescr;\n\n    if (PyList_Check(init) || PyTuple_Check(init)) {\n        PyObject **items;\n        Py_ssize_t i, n;\n        n = PySequence_Fast_GET_SIZE(init);\n        if (ct->ct_length >= 0 && n > ct->ct_length) {\n            PyErr_Format(PyExc_IndexError,\n                         \"too many initializers for '%s' (got %zd)\",\n                         ct->ct_name, n);\n            return -1;\n        }\n        items = PySequence_Fast_ITEMS(init);\n        for (i=0; i<n; i++) {\n            if (convert_from_object(data, ctitem, items[i]) < 0)\n                return -1;\n            data += ctitem->ct_size;\n        }\n        return 0;\n    }\n    else if ((ctitem->ct_flags & CT_PRIMITIVE_CHAR) ||\n             ((ctitem->ct_flags & (CT_PRIMITIVE_SIGNED|CT_PRIMITIVE_UNSIGNED))\n              && (ctitem->ct_size == sizeof(char)))) {\n        if (ctitem->ct_size == sizeof(char)) {\n            char *srcdata;\n            Py_ssize_t n;\n            if (!PyBytes_Check(init)) {\n                expected = STR_OR_BYTES\" or list or tuple\";\n                goto cannot_convert;\n            }\n            n = PyBytes_GET_SIZE(init);\n            if (ct->ct_length >= 0 && n > ct->ct_length) {\n                PyErr_Format(PyExc_IndexError,\n                             \"initializer \"STR_OR_BYTES\" is too long for '%s' \"\n                             \"(got %zd characters)\", ct->ct_name, n);\n                return -1;\n            }\n            if (n != ct->ct_length)\n                n++;\n            srcdata = PyBytes_AS_STRING(init);\n            if (ctitem->ct_flags & CT_IS_BOOL)\n                if (must_be_array_of_zero_or_one(srcdata, n) < 0)\n                    return -1;\n            memcpy(data, srcdata, n);\n            return 0;\n        }\n        else {\n            Py_ssize_t n;\n            if (!PyUnicode_Check(init)) {\n                expected = \"unicode or list or tuple\";\n                goto cannot_convert;\n            }\n\n            if (ctitem->ct_size == 4)\n                n = _my_PyUnicode_SizeAsChar32(init);\n            else\n                n = _my_PyUnicode_SizeAsChar16(init);\n\n            if (ct->ct_length >= 0 && n > ct->ct_length) {\n                PyErr_Format(PyExc_IndexError,\n                             \"initializer unicode is too long for '%s' \"\n                             \"(got %zd characters)\", ct->ct_name, n);\n                return -1;\n            }\n            if (n != ct->ct_length)\n                n++;\n            if (ctitem->ct_size == 4)\n                return _my_PyUnicode_AsChar32(init, (cffi_char32_t *)data, n);\n            else\n                return _my_PyUnicode_AsChar16(init, (cffi_char16_t *)data, n);\n        }\n    }\n    else {\n        expected = \"list or tuple\";\n        goto cannot_convert;\n    }\n\n cannot_convert:\n    if ((ct->ct_flags & CT_ARRAY) && CData_Check(init))\n    {\n        CDataObject *cd = (CDataObject *)init;\n        if (cd->c_type == ct)\n        {\n            Py_ssize_t n = get_array_length(cd);\n            memcpy(data, cd->c_data, n * ctitem->ct_size);\n            return 0;\n        }\n    }\n    return _convert_error(init, ct, expected);\n}\n\nstatic int\nconvert_struct_from_object(char *data, CTypeDescrObject *ct, PyObject *init,\n                           Py_ssize_t *optvarsize)\n{\n    /* does not accept 'init' being already a CData */\n    const char *expected;\n\n    if (force_lazy_struct(ct) <= 0) {\n        if (!PyErr_Occurred())\n            PyErr_Format(PyExc_TypeError, \"'%s' is opaque\", ct->ct_name);\n        return -1;\n    }\n\n    if (PyList_Check(init) || PyTuple_Check(init)) {\n        PyObject **items = PySequence_Fast_ITEMS(init);\n        Py_ssize_t i, n = PySequence_Fast_GET_SIZE(init);\n        CFieldObject *cf = (CFieldObject *)ct->ct_extra;\n\n        for (i=0; i<n; i++) {\n            while (cf != NULL && (cf->cf_flags & BF_IGNORE_IN_CTOR))\n                cf = cf->cf_next;\n            if (cf == NULL) {\n                PyErr_Format(PyExc_ValueError,\n                             \"too many initializers for '%s' (got %zd)\",\n                             ct->ct_name, n);\n                return -1;\n            }\n            if (convert_vfield_from_object(data, cf, items[i], optvarsize) < 0)\n                return -1;\n            cf = cf->cf_next;\n        }\n        return 0;\n    }\n    if (PyDict_Check(init)) {\n        PyObject *d_key, *d_value;\n        Py_ssize_t i = 0;\n        CFieldObject *cf;\n\n        while (PyDict_Next(init, &i, &d_key, &d_value)) {\n            cf = (CFieldObject *)PyDict_GetItem(ct->ct_stuff, d_key);\n            if (cf == NULL) {\n                PyErr_SetObject(PyExc_KeyError, d_key);\n                return -1;\n            }\n            if (convert_vfield_from_object(data, cf, d_value, optvarsize) < 0)\n                return -1;\n        }\n        return 0;\n    }\n    expected = optvarsize == NULL ? \"list or tuple or dict or struct-cdata\"\n                                  : \"list or tuple or dict\";\n    return _convert_error(init, ct, expected);\n}\n\n#ifdef __GNUC__\n# if __GNUC__ >= 4\n/* Don't go inlining this huge function.  Needed because occasionally\n   it gets inlined in places where is causes a warning: call to\n   __builtin___memcpy_chk will always overflow destination buffer\n   (which is places where the 'ct' should never represent such a large\n   primitive type anyway). */\n__attribute__((noinline))\n# endif\n#endif\nstatic int\nconvert_from_object(char *data, CTypeDescrObject *ct, PyObject *init)\n{\n    const char *expected;\n    char buf[sizeof(PY_LONG_LONG)];\n\n    /*if (ct->ct_size > 0)*/\n        /*WRITE(data, ct->ct_size)*/\n\n    if (ct->ct_flags & CT_ARRAY) {\n        return convert_array_from_object(data, ct, init);\n    }\n    if (ct->ct_flags & (CT_POINTER|CT_FUNCTIONPTR)) {\n        char *ptrdata;\n        CTypeDescrObject *ctinit;\n\n        if (!CData_Check(init)) {\n            expected = \"cdata pointer\";\n            goto cannot_convert;\n        }\n        ctinit = ((CDataObject *)init)->c_type;\n        if (!(ctinit->ct_flags & (CT_POINTER|CT_FUNCTIONPTR))) {\n            if (ctinit->ct_flags & CT_ARRAY)\n                ctinit = (CTypeDescrObject *)ctinit->ct_stuff;\n            else {\n                expected = \"pointer or array\";\n                goto cannot_convert;\n            }\n        }\n        if (ctinit != ct) {\n            int combined_flags = ct->ct_flags | ctinit->ct_flags;\n            if (combined_flags & CT_IS_VOID_PTR)\n                ;   /* accept \"void *\" as either source or target */\n            else if (combined_flags & CT_IS_VOIDCHAR_PTR) {\n                /* for backward compatibility, accept \"char *\" as either\n                   source of target.  This is not what C does, though,\n                   so emit a warning that will eventually turn into an\n                   error.  The warning is turned off if both types are\n                   pointers to single bytes. */\n                char *msg = (ct->ct_flags & CT_IS_VOIDCHAR_PTR ?\n                    \"implicit cast to 'char *' from a different pointer type: \"\n                    \"will be forbidden in the future (check that the types \"\n                    \"are as you expect; use an explicit ffi.cast() if they \"\n                    \"are correct)\" :\n                    \"implicit cast from 'char *' to a different pointer type: \"\n                    \"will be forbidden in the future (check that the types \"\n                    \"are as you expect; use an explicit ffi.cast() if they \"\n                    \"are correct)\");\n                if ((ct->ct_flags & ctinit->ct_flags & CT_POINTER) &&\n                    ct->ct_itemdescr->ct_size == 1 &&\n                    ctinit->ct_itemdescr->ct_size == 1) {\n                    /* no warning */\n                }\n                else if (PyErr_WarnEx(PyExc_UserWarning, msg, 1))\n                    return -1;\n            }\n            else {\n                expected = \"pointer to same type\";\n                goto cannot_convert;\n            }\n        }\n        ptrdata = ((CDataObject *)init)->c_data;\n\n        *(char **)data = ptrdata;\n        return 0;\n    }\n    if (ct->ct_flags & CT_PRIMITIVE_SIGNED) {\n        PY_LONG_LONG value = _my_PyLong_AsLongLong(init);\n        if (value == -1 && PyErr_Occurred())\n            return -1;\n        write_raw_integer_data(buf, value, ct->ct_size);\n        if (value != read_raw_signed_data(buf, ct->ct_size))\n            goto overflow;\n        write_raw_integer_data(data, value, ct->ct_size);\n        return 0;\n    }\n    if (ct->ct_flags & CT_PRIMITIVE_UNSIGNED) {\n        unsigned PY_LONG_LONG value = _my_PyLong_AsUnsignedLongLong(init, 1);\n        if (value == (unsigned PY_LONG_LONG)-1 && PyErr_Occurred())\n            return -1;\n        if (ct->ct_flags & CT_IS_BOOL) {\n            if (value > 1ULL)      /* value != 0 && value != 1 */\n                goto overflow;\n        }\n        else {\n            write_raw_integer_data(buf, value, ct->ct_size);\n            if (value != read_raw_unsigned_data(buf, ct->ct_size))\n                goto overflow;\n        }\n        write_raw_integer_data(data, value, ct->ct_size);\n        return 0;\n    }\n    if (ct->ct_flags & CT_PRIMITIVE_FLOAT) {\n        double value;\n        if ((ct->ct_flags & CT_IS_LONGDOUBLE) &&\n                CData_Check(init) &&\n                (((CDataObject *)init)->c_type->ct_flags & CT_IS_LONGDOUBLE)) {\n            long double lvalue;\n            char *initdata = ((CDataObject *)init)->c_data;\n            /*READ(initdata, sizeof(long double))*/\n            lvalue = read_raw_longdouble_data(initdata);\n            write_raw_longdouble_data(data, lvalue);\n            return 0;\n        }\n        value = PyFloat_AsDouble(init);\n        if (value == -1.0 && PyErr_Occurred())\n            return -1;\n        if (!(ct->ct_flags & CT_IS_LONGDOUBLE))\n            write_raw_float_data(data, value, ct->ct_size);\n        else\n            write_raw_longdouble_data(data, (long double)value);\n        return 0;\n    }\n    if (ct->ct_flags & CT_PRIMITIVE_CHAR) {\n        switch (ct->ct_size) {\n        case sizeof(char): {\n            int res = _convert_to_char(init);\n            if (res < 0)\n                return -1;\n            data[0] = res;\n            return 0;\n        }\n        case 2: {\n            cffi_char16_t res = _convert_to_char16_t(init);\n            if (res == (cffi_char16_t)-1 && PyErr_Occurred())\n                return -1;\n            *(cffi_char16_t *)data = res;\n            return 0;\n        }\n        case 4: {\n            cffi_char32_t res = _convert_to_char32_t(init);\n            if (res == (cffi_char32_t)-1 && PyErr_Occurred())\n                return -1;\n            *(cffi_char32_t *)data = res;\n            return 0;\n        }\n        }\n    }\n    if (ct->ct_flags & (CT_STRUCT|CT_UNION)) {\n\n        if (CData_Check(init)) {\n            if (((CDataObject *)init)->c_type == ct && ct->ct_size >= 0) {\n                memcpy(data, ((CDataObject *)init)->c_data, ct->ct_size);\n                return 0;\n            }\n        }\n        return convert_struct_from_object(data, ct, init, NULL);\n    }\n    if (ct->ct_flags & CT_PRIMITIVE_COMPLEX) {\n        Py_complex value = PyComplex_AsCComplex(init);\n        if (PyErr_Occurred())\n            return -1;\n        write_raw_complex_data(data, value, ct->ct_size);\n        return 0;\n    }\n    PyErr_Format(PyExc_SystemError,\n                 \"convert_from_object: '%s'\", ct->ct_name);\n    return -1;\n\n overflow:\n    return _convert_overflow(init, ct->ct_name);\n\n cannot_convert:\n    return _convert_error(init, ct, expected);\n}\n\nstatic int\nconvert_from_object_bitfield(char *data, CFieldObject *cf, PyObject *init)\n{\n    CTypeDescrObject *ct = cf->cf_type;\n    PY_LONG_LONG fmin, fmax, value = PyLong_AsLongLong(init);\n    unsigned PY_LONG_LONG rawfielddata, rawvalue, rawmask;\n    if (value == -1 && PyErr_Occurred())\n        return -1;\n\n    if (ct->ct_flags & CT_PRIMITIVE_SIGNED) {\n        fmin = -(1LL << (cf->cf_bitsize-1));\n        fmax = (1LL << (cf->cf_bitsize-1)) - 1LL;\n        if (fmax == 0)\n            fmax = 1;    /* special case to let \"int x:1\" receive \"1\" */\n    }\n    else {\n        fmin = 0LL;\n        fmax = (PY_LONG_LONG)((1ULL << cf->cf_bitsize) - 1ULL);\n    }\n    if (value < fmin || value > fmax) {\n        /* phew, PyErr_Format does not support \"%lld\" in Python 2.6 */\n        PyObject *svalue = NULL, *sfmin = NULL, *sfmax = NULL;\n        PyObject *lfmin = NULL, *lfmax = NULL;\n        svalue = PyObject_Str(init);\n        if (svalue == NULL) goto skip;\n        lfmin = PyLong_FromLongLong(fmin);\n        if (lfmin == NULL) goto skip;\n        sfmin = PyObject_Str(lfmin);\n        if (sfmin == NULL) goto skip;\n        lfmax = PyLong_FromLongLong(fmax);\n        if (lfmax == NULL) goto skip;\n        sfmax = PyObject_Str(lfmax);\n        if (sfmax == NULL) goto skip;\n        PyErr_Format(PyExc_OverflowError,\n                     \"value %s outside the range allowed by the \"\n                     \"bit field width: %s <= x <= %s\",\n                     PyText_AS_UTF8(svalue),\n                     PyText_AS_UTF8(sfmin),\n                     PyText_AS_UTF8(sfmax));\n       skip:\n        Py_XDECREF(svalue);\n        Py_XDECREF(sfmin);\n        Py_XDECREF(sfmax);\n        Py_XDECREF(lfmin);\n        Py_XDECREF(lfmax);\n        return -1;\n    }\n\n    rawmask = ((1ULL << cf->cf_bitsize) - 1ULL) << cf->cf_bitshift;\n    rawvalue = ((unsigned PY_LONG_LONG)value) << cf->cf_bitshift;\n    /*WRITE(data, ct->ct_size)*/\n    rawfielddata = read_raw_unsigned_data(data, ct->ct_size);\n    rawfielddata = (rawfielddata & ~rawmask) | (rawvalue & rawmask);\n    write_raw_integer_data(data, rawfielddata, ct->ct_size);\n    return 0;\n}\n\nstatic int\nget_alignment(CTypeDescrObject *ct)\n{\n    int align;\n retry:\n    if ((ct->ct_flags & (CT_PRIMITIVE_ANY|CT_STRUCT|CT_UNION)) &&\n        !(ct->ct_flags & CT_IS_OPAQUE)) {\n        align = ct->ct_length;\n        if (align == -1 && (ct->ct_flags & CT_LAZY_FIELD_LIST)) {\n            force_lazy_struct(ct);\n            align = ct->ct_length;\n        }\n    }\n    else if (ct->ct_flags & (CT_POINTER|CT_FUNCTIONPTR)) {\n        struct aligncheck_ptr { char x; char *y; };\n        align = offsetof(struct aligncheck_ptr, y);\n    }\n    else if (ct->ct_flags & CT_ARRAY) {\n        ct = ct->ct_itemdescr;\n        goto retry;\n    }\n    else {\n        PyErr_Format(PyExc_ValueError, \"ctype '%s' is of unknown alignment\",\n                     ct->ct_name);\n        return -1;\n    }\n\n    if ((align < 1) || (align & (align-1))) {\n        PyErr_Format(PyExc_SystemError,\n                     \"found for ctype '%s' bogus alignment '%d'\",\n                     ct->ct_name, align);\n        return -1;\n    }\n    return align;\n}\n\nstatic void cdata_dealloc(CDataObject *cd)\n{\n    if (cd->c_weakreflist != NULL)\n        PyObject_ClearWeakRefs((PyObject *) cd);\n\n    Py_DECREF(cd->c_type);\n#ifndef CFFI_MEM_LEAK     /* never release anything, tests only */\n    Py_TYPE(cd)->tp_free((PyObject *)cd);\n#endif\n}\n\nstatic void cdataowning_dealloc(CDataObject *cd)\n{\n    assert(!(cd->c_type->ct_flags & (CT_IS_VOID_PTR | CT_FUNCTIONPTR)));\n\n    if (cd->c_type->ct_flags & CT_IS_PTR_TO_OWNED) {\n        /* for ffi.new(\"struct *\") */\n        Py_DECREF(((CDataObject_own_structptr *)cd)->structobj);\n    }\n#if defined(CFFI_MEM_DEBUG) || defined(CFFI_MEM_LEAK)\n    if (cd->c_type->ct_flags & (CT_PRIMITIVE_ANY | CT_STRUCT | CT_UNION)) {\n        assert(cd->c_type->ct_size >= 0);\n        memset(cd->c_data, 0xDD, cd->c_type->ct_size);\n    }\n    else if (cd->c_type->ct_flags & CT_ARRAY) {\n        Py_ssize_t x = get_array_length(cd);\n        assert(x >= 0);\n        x *= cd->c_type->ct_itemdescr->ct_size;\n        assert(x >= 0);\n        memset(cd->c_data, 0xDD, x);\n    }\n#endif\n    cdata_dealloc(cd);\n}\n\nstatic void cdataowninggc_dealloc(CDataObject *cd)\n{\n    PyObject_GC_UnTrack(cd);\n\n    if (cd->c_type->ct_flags & CT_IS_VOID_PTR) {        /* a handle */\n        PyObject *x = ((CDataObject_own_structptr *)cd)->structobj;\n        Py_DECREF(x);\n    }\n    else if (cd->c_type->ct_flags & CT_FUNCTIONPTR) {   /* a callback */\n        ffi_closure *closure = ((CDataObject_closure *)cd)->closure;\n        PyObject *args = (PyObject *)(closure->user_data);\n        Py_XDECREF(args);\n#ifdef CFFI_TRUST_LIBFFI\n        ffi_closure_free(closure);\n#else\n        cffi_closure_free(closure);\n#endif\n    }\n    else {\n        Py_FatalError(\"cdata CDataOwningGC_Type with unexpected type flags\");\n    }\n    cdata_dealloc(cd);\n}\n\nstatic void cdatafrombuf_dealloc(CDataObject *cd)\n{\n    Py_buffer *view = ((CDataObject_frombuf *)cd)->bufferview;\n    cdata_dealloc(cd);\n\n    PyBuffer_Release(view);\n    PyObject_Free(view);\n}\n\nstatic int cdataowninggc_traverse(CDataObject *cd, visitproc visit, void *arg)\n{\n    if (cd->c_type->ct_flags & CT_IS_VOID_PTR) {        /* a handle */\n        PyObject *x = ((CDataObject_own_structptr *)cd)->structobj;\n        Py_VISIT(x);\n    }\n    else if (cd->c_type->ct_flags & CT_FUNCTIONPTR) {   /* a callback */\n        ffi_closure *closure = ((CDataObject_closure *)cd)->closure;\n        PyObject *args = (PyObject *)(closure->user_data);\n        Py_VISIT(args);\n    }\n    return 0;\n}\n\nstatic int cdatafrombuf_traverse(CDataObject *cd, visitproc visit, void *arg)\n{\n    Py_buffer *view = ((CDataObject_frombuf *)cd)->bufferview;\n    Py_VISIT(view->obj);\n    return 0;\n}\n\nstatic int cdataowninggc_clear(CDataObject *cd)\n{\n    if (cd->c_type->ct_flags & CT_IS_VOID_PTR) {        /* a handle */\n        CDataObject_own_structptr *cd1 = (CDataObject_own_structptr *)cd;\n        PyObject *x = cd1->structobj;\n        Py_INCREF(Py_None);\n        cd1->structobj = Py_None;\n        Py_DECREF(x);\n    }\n    else if (cd->c_type->ct_flags & CT_FUNCTIONPTR) {   /* a callback */\n        ffi_closure *closure = ((CDataObject_closure *)cd)->closure;\n        PyObject *args = (PyObject *)(closure->user_data);\n        closure->user_data = NULL;\n        Py_XDECREF(args);\n    }\n    return 0;\n}\n\nstatic int cdatafrombuf_clear(CDataObject *cd)\n{\n    Py_buffer *view = ((CDataObject_frombuf *)cd)->bufferview;\n    PyBuffer_Release(view);\n    return 0;\n}\n\n/* forward */\nstatic void _my_PyErr_WriteUnraisable(PyObject *t, PyObject *v, PyObject *tb,\n                                      char *objdescr, PyObject *obj,\n                                      char *extra_error_line);\n\n\nstatic void gcp_finalize(PyObject *destructor, PyObject *origobj)\n{\n    /* NOTE: this decrements the reference count of the two arguments */\n\n    if (destructor != NULL) {\n        PyObject *result;\n        PyObject *error_type, *error_value, *error_traceback;\n\n        /* Save the current exception */\n        PyErr_Fetch(&error_type, &error_value, &error_traceback);\n\n        result = PyObject_CallFunctionObjArgs(destructor, origobj, NULL);\n        if (result != NULL) {\n            Py_DECREF(result);\n        }\n        else {\n            PyObject *t, *v, *tb;\n            PyErr_Fetch(&t, &v, &tb);\n            /* Don't use error capture here, because it is very much\n             * like errors at __del__(), and these ones are not captured\n             * either */\n            /* ecap = _cffi_start_error_capture(); */\n            _my_PyErr_WriteUnraisable(t, v, tb, \"From callback for ffi.gc \",\n                                      origobj, NULL);\n            /* _cffi_stop_error_capture(ecap); */\n        }\n        Py_DECREF(destructor);\n\n        /* Restore the saved exception */\n        PyErr_Restore(error_type, error_value, error_traceback);\n    }\n    Py_XDECREF(origobj);\n}\n\nstatic void cdatagcp_finalize(CDataObject_gcp *cd)\n{\n    PyObject *destructor = cd->destructor;\n    PyObject *origobj = cd->origobj;\n    cd->destructor = NULL;\n    cd->origobj = NULL;\n    gcp_finalize(destructor, origobj);\n}\n\nstatic void cdatagcp_dealloc(CDataObject_gcp *cd)\n{\n    PyObject *destructor = cd->destructor;\n    PyObject *origobj = cd->origobj;\n    cdata_dealloc((CDataObject *)cd);\n\n    gcp_finalize(destructor, origobj);\n}\n\nstatic int cdatagcp_traverse(CDataObject_gcp *cd, visitproc visit, void *arg)\n{\n    Py_VISIT(cd->destructor);\n    Py_VISIT(cd->origobj);\n    return 0;\n}\n\nstatic PyObject *cdata_float(CDataObject *cd);  /*forward*/\n\nstatic PyObject *convert_cdata_to_enum_string(CDataObject *cd, int both)\n{\n    PyObject *d_key, *d_value;\n    CTypeDescrObject *ct = cd->c_type;\n\n    assert(ct->ct_flags & CT_IS_ENUM);\n    d_key = convert_to_object(cd->c_data, ct);\n    if (d_key == NULL)\n        return NULL;\n\n    d_value = PyDict_GetItem(PyTuple_GET_ITEM(ct->ct_stuff, 1), d_key);\n    if (d_value != NULL) {\n        if (both) {\n            PyObject *o = PyObject_Str(d_key);\n            if (o == NULL)\n                d_value = NULL;\n            else {\n                d_value = PyText_FromFormat(\"%s: %s\",\n                                            PyText_AS_UTF8(o),\n                                            PyText_AS_UTF8(d_value));\n                Py_DECREF(o);\n            }\n        }\n        else\n            Py_INCREF(d_value);\n    }\n    else\n        d_value = PyObject_Str(d_key);\n    Py_DECREF(d_key);\n    return d_value;\n}\n\nstatic PyObject *cdata_repr(CDataObject *cd)\n{\n    char *extra;\n    PyObject *result, *s;\n\n    if (cd->c_type->ct_flags & CT_PRIMITIVE_ANY) {\n        if (cd->c_type->ct_flags & CT_IS_ENUM) {\n            s = convert_cdata_to_enum_string(cd, 1);\n        }\n        else if (cd->c_type->ct_flags & CT_IS_LONGDOUBLE) {\n            long double lvalue;\n            char buffer[128];   /* big enough */\n            /*READ(cd->c_data, sizeof(long double)*/\n            lvalue = read_raw_longdouble_data(cd->c_data);\n            sprintf(buffer, \"%LE\", lvalue);\n            s = PyText_FromString(buffer);\n        }\n        else {\n            PyObject *o = convert_to_object(cd->c_data, cd->c_type);\n            if (o == NULL)\n                return NULL;\n            s = PyObject_Repr(o);\n            Py_DECREF(o);\n        }\n    }\n    else if ((cd->c_type->ct_flags & CT_ARRAY) && cd->c_type->ct_length < 0) {\n        s = PyText_FromFormat(\"sliced length %zd\", get_array_length(cd));\n    }\n    else {\n        if (cd->c_data != NULL) {\n            s = PyText_FromFormat(\"%p\", cd->c_data);\n        }\n        else\n            s = PyText_FromString(\"NULL\");\n    }\n    if (s == NULL)\n        return NULL;\n    /* it's slightly confusing to get \"<cdata 'struct foo' 0x...>\" because the\n       struct foo is not owned.  Trying to make it clearer, write in this\n       case \"<cdata 'struct foo &' 0x...>\". */\n    if (cd->c_type->ct_flags & (CT_STRUCT|CT_UNION))\n        extra = \" &\";\n    else\n        extra = \"\";\n    result = PyText_FromFormat(\"<cdata '%s%s' %s>\",\n                               cd->c_type->ct_name, extra,\n                               PyText_AsUTF8(s));\n    Py_DECREF(s);\n    return result;\n}\n\nstatic PyObject *_cdata_repr2(CDataObject *cd, char *text, PyObject *x)\n{\n    PyObject *res, *s = PyObject_Repr(x);\n    if (s == NULL)\n        return NULL;\n    res = PyText_FromFormat(\"<cdata '%s' %s %s>\",\n                            cd->c_type->ct_name, text, PyText_AsUTF8(s));\n    Py_DECREF(s);\n    return res;\n}\n\nstatic Py_ssize_t _cdata_var_byte_size(CDataObject *cd)\n{\n    /* If 'cd' is a 'struct foo' or 'struct foo *' allocated with\n       ffi.new(), and if the struct foo contains a varsize array,\n       then return the real allocated size.  Otherwise, return -1. */\n    if (!CDataOwn_Check(cd))\n        return -1;\n\n    if (cd->c_type->ct_flags & CT_IS_PTR_TO_OWNED) {\n        cd = (CDataObject *)((CDataObject_own_structptr *)cd)->structobj;\n    }\n    if (cd->c_type->ct_flags & CT_WITH_VAR_ARRAY) {\n        return ((CDataObject_own_length *)cd)->length;\n    }\n    return -1;\n}\n\nstatic PyObject *_frombuf_repr(CDataObject *cd, const char *cd_type_name)\n{\n    Py_buffer *view = ((CDataObject_frombuf *)cd)->bufferview;\n    const char *obj_tp_name;\n    if (view->obj == NULL) {\n        return PyText_FromFormat(\n            \"<cdata '%s' buffer RELEASED>\",\n            cd_type_name);\n    }\n\n    obj_tp_name = Py_TYPE(view->obj)->tp_name;\n    if (cd->c_type->ct_flags & CT_ARRAY)\n    {\n        Py_ssize_t buflen = get_array_length(cd);\n        return PyText_FromFormat(\n            \"<cdata '%s' buffer len %zd from '%.200s' object>\",\n            cd_type_name,\n            buflen,\n            obj_tp_name);\n    }\n    else\n    {\n        return PyText_FromFormat(\n            \"<cdata '%s' buffer from '%.200s' object>\",\n            cd_type_name,\n            obj_tp_name);\n    }\n}\n\nstatic PyObject *cdataowning_repr(CDataObject *cd)\n{\n    Py_ssize_t size = _cdata_var_byte_size(cd);\n    if (size < 0) {\n        if (cd->c_type->ct_flags & CT_POINTER)\n            size = cd->c_type->ct_itemdescr->ct_size;\n        else if (cd->c_type->ct_flags & CT_ARRAY)\n            size = get_array_length(cd) * cd->c_type->ct_itemdescr->ct_size;\n        else\n            size = cd->c_type->ct_size;\n    }\n    return PyText_FromFormat(\"<cdata '%s' owning %zd bytes>\",\n                             cd->c_type->ct_name, size);\n}\n\nstatic PyObject *cdataowninggc_repr(CDataObject *cd)\n{\n    if (cd->c_type->ct_flags & CT_IS_VOID_PTR) {        /* a handle */\n        PyObject *x = ((CDataObject_own_structptr *)cd)->structobj;\n        return _cdata_repr2(cd, \"handle to\", x);\n    }\n    else if (cd->c_type->ct_flags & CT_FUNCTIONPTR) {   /* a callback */\n        ffi_closure *closure = ((CDataObject_closure *)cd)->closure;\n        PyObject *args = (PyObject *)closure->user_data;\n        if (args == NULL)\n            return cdata_repr(cd);\n        else\n            return _cdata_repr2(cd, \"calling\", PyTuple_GET_ITEM(args, 1));\n    }\n    return cdataowning_repr(cd);   /* but should be unreachable */\n}\n\nstatic PyObject *cdatafrombuf_repr(CDataObject *cd)\n{\n    return _frombuf_repr(cd, cd->c_type->ct_name);\n}\n\nstatic int cdata_nonzero(CDataObject *cd)\n{\n    if (cd->c_type->ct_flags & CT_PRIMITIVE_ANY) {\n        if (cd->c_type->ct_flags & (CT_PRIMITIVE_SIGNED |\n                                    CT_PRIMITIVE_UNSIGNED |\n                                    CT_PRIMITIVE_CHAR))\n            return read_raw_unsigned_data(cd->c_data, cd->c_type->ct_size) != 0;\n\n        if (cd->c_type->ct_flags & CT_PRIMITIVE_FLOAT) {\n            if (cd->c_type->ct_flags & CT_IS_LONGDOUBLE)\n                return read_raw_longdouble_data(cd->c_data) != 0.0;\n            return read_raw_float_data(cd->c_data, cd->c_type->ct_size) != 0.0;\n        }\n        if (cd->c_type->ct_flags & CT_PRIMITIVE_COMPLEX) {\n            Py_complex value = read_raw_complex_data(cd->c_data,\n                                                     cd->c_type->ct_size);\n            return value.real != 0.0 || value.imag != 0.0;\n        }\n    }\n    return cd->c_data != NULL;\n}\n\nstatic PyObject *cdata_int(CDataObject *cd)\n{\n    if ((cd->c_type->ct_flags & (CT_PRIMITIVE_SIGNED|CT_PRIMITIVE_FITS_LONG))\n                             == (CT_PRIMITIVE_SIGNED|CT_PRIMITIVE_FITS_LONG)) {\n        /* this case is to handle enums, but also serves as a slight\n           performance improvement for some other primitive types */\n        long value;\n        /*READ(cd->c_data, cd->c_type->ct_size)*/\n        value = (long)read_raw_signed_data(cd->c_data, cd->c_type->ct_size);\n        return PyInt_FromLong(value);\n    }\n    if (cd->c_type->ct_flags & (CT_PRIMITIVE_SIGNED|CT_PRIMITIVE_UNSIGNED)) {\n        PyObject *result = convert_to_object(cd->c_data, cd->c_type);\n        if (result != NULL && PyBool_Check(result))\n            result = PyInt_FromLong(PyInt_AsLong(result));\n        return result;\n    }\n    else if (cd->c_type->ct_flags & CT_PRIMITIVE_CHAR) {\n        /*READ(cd->c_data, cd->c_type->ct_size)*/\n        switch (cd->c_type->ct_size) {\n        case sizeof(char):\n            return PyInt_FromLong((unsigned char)cd->c_data[0]);\n        case 2:\n            return PyInt_FromLong((long)*(cffi_char16_t *)cd->c_data);\n        case 4:\n            if (cd->c_type->ct_flags & CT_IS_SIGNED_WCHAR)\n                return PyInt_FromLong((long)*(int32_t *)cd->c_data);\n            else if (sizeof(long) > 4)\n                return PyInt_FromLong(*(uint32_t *)cd->c_data);\n            else\n                return PyLong_FromUnsignedLong(*(uint32_t *)cd->c_data);\n        }\n    }\n    else if (cd->c_type->ct_flags & CT_PRIMITIVE_FLOAT) {\n        PyObject *o = cdata_float(cd);\n#if PY_MAJOR_VERSION < 3\n        PyObject *r = o ? PyNumber_Int(o) : NULL;\n#else\n        PyObject *r = o ? PyNumber_Long(o) : NULL;\n#endif\n        Py_XDECREF(o);\n        return r;\n    }\n    PyErr_Format(PyExc_TypeError, \"int() not supported on cdata '%s'\",\n                 cd->c_type->ct_name);\n    return NULL;\n}\n\n#if PY_MAJOR_VERSION < 3\nstatic PyObject *cdata_long(CDataObject *cd)\n{\n    PyObject *res = cdata_int(cd);\n    if (res != NULL && PyInt_CheckExact(res)) {\n        PyObject *o = PyLong_FromLong(PyInt_AS_LONG(res));\n        Py_DECREF(res);\n        res = o;\n    }\n    return res;\n}\n#endif\n\nstatic PyObject *cdata_float(CDataObject *cd)\n{\n    if (cd->c_type->ct_flags & CT_PRIMITIVE_FLOAT) {\n        double value;\n        /*READ(cd->c_data, cd->c_type->ct_size)*/\n        if (!(cd->c_type->ct_flags & CT_IS_LONGDOUBLE)) {\n            value = read_raw_float_data(cd->c_data, cd->c_type->ct_size);\n        }\n        else {\n            value = (double)read_raw_longdouble_data(cd->c_data);\n        }\n        return PyFloat_FromDouble(value);\n    }\n    PyErr_Format(PyExc_TypeError, \"float() not supported on cdata '%s'\",\n                 cd->c_type->ct_name);\n    return NULL;\n}\n\nstatic PyObject *cdata_richcompare(PyObject *v, PyObject *w, int op)\n{\n    int v_is_ptr, w_is_ptr;\n    PyObject *pyres;\n\n    assert(CData_Check(v));\n\n    /* Comparisons involving a primitive cdata work differently than\n     * comparisons involving a struct/array/pointer.\n     *\n     * If v or w is a struct/array/pointer, then the other must be too\n     * (otherwise we return NotImplemented and leave the case to\n     * Python).  If both are, then we compare the addresses.\n     *\n     * If v and/or w is a primitive cdata, then we convert the cdata(s)\n     * to regular Python objects and redo the comparison there.\n     */\n\n    v_is_ptr = !(((CDataObject *)v)->c_type->ct_flags & CT_PRIMITIVE_ANY);\n    w_is_ptr = CData_Check(w) &&\n                  !(((CDataObject *)w)->c_type->ct_flags & CT_PRIMITIVE_ANY);\n\n    if (v_is_ptr && w_is_ptr) {\n        int res;\n        char *v_cdata = ((CDataObject *)v)->c_data;\n        char *w_cdata = ((CDataObject *)w)->c_data;\n\n        switch (op) {\n        case Py_EQ: res = (v_cdata == w_cdata); break;\n        case Py_NE: res = (v_cdata != w_cdata); break;\n        case Py_LT: res = (v_cdata <  w_cdata); break;\n        case Py_LE: res = (v_cdata <= w_cdata); break;\n        case Py_GT: res = (v_cdata >  w_cdata); break;\n        case Py_GE: res = (v_cdata >= w_cdata); break;\n        default: res = -1;\n        }\n        pyres = res ? Py_True : Py_False;\n    }\n    else if (v_is_ptr || w_is_ptr) {\n        pyres = Py_NotImplemented;\n    }\n    else {\n        PyObject *aa[2];\n        int i;\n\n        aa[0] = v; Py_INCREF(v);\n        aa[1] = w; Py_INCREF(w);\n        pyres = NULL;\n\n        for (i = 0; i < 2; i++) {\n            v = aa[i];\n            if (!CData_Check(v))\n                continue;\n            w = convert_to_object(((CDataObject *)v)->c_data,\n                                  ((CDataObject *)v)->c_type);\n            if (w == NULL)\n                goto error;\n            if (CData_Check(w)) {\n                Py_DECREF(w);\n                PyErr_Format(PyExc_NotImplementedError,\n                             \"cannot use <cdata '%s'> in a comparison\",\n                             ((CDataObject *)v)->c_type->ct_name);\n                goto error;\n            }\n            aa[i] = w;\n            Py_DECREF(v);\n        }\n        pyres = PyObject_RichCompare(aa[0], aa[1], op);\n     error:\n        Py_DECREF(aa[1]);\n        Py_DECREF(aa[0]);\n        return pyres;\n    }\n\n    Py_INCREF(pyres);\n    return pyres;\n}\n\n#if PY_MAJOR_VERSION < 3\ntypedef long Py_hash_t;\n#endif\n\nstatic Py_hash_t cdata_hash(PyObject *v)\n{\n    if (((CDataObject *)v)->c_type->ct_flags & CT_PRIMITIVE_ANY) {\n        PyObject *vv = convert_to_object(((CDataObject *)v)->c_data,\n                                         ((CDataObject *)v)->c_type);\n        if (vv == NULL)\n            return -1;\n        if (!CData_Check(vv)) {\n            Py_hash_t hash = PyObject_Hash(vv);\n            Py_DECREF(vv);\n            return hash;\n        }\n        Py_DECREF(vv);\n    }\n    return _Py_HashPointer(((CDataObject *)v)->c_data);\n}\n\nstatic Py_ssize_t\ncdata_length(CDataObject *cd)\n{\n    if (cd->c_type->ct_flags & CT_ARRAY) {\n        return get_array_length(cd);\n    }\n    PyErr_Format(PyExc_TypeError, \"cdata of type '%s' has no len()\",\n                 cd->c_type->ct_name);\n    return -1;\n}\n\nstatic char *\n_cdata_get_indexed_ptr(CDataObject *cd, PyObject *key)\n{\n    Py_ssize_t i = PyNumber_AsSsize_t(key, PyExc_IndexError);\n    if (i == -1 && PyErr_Occurred())\n        return NULL;\n\n    if (cd->c_type->ct_flags & CT_POINTER) {\n        if (CDataOwn_Check(cd)) {\n            if (i != 0) {\n                PyErr_Format(PyExc_IndexError,\n                             \"cdata '%s' can only be indexed by 0\",\n                             cd->c_type->ct_name);\n                return NULL;\n            }\n        }\n        else {\n            if (cd->c_data == NULL) {\n                PyErr_Format(PyExc_RuntimeError,\n                             \"cannot dereference null pointer from cdata '%s'\",\n                             cd->c_type->ct_name);\n                return NULL;\n            }\n        }\n    }\n    else if (cd->c_type->ct_flags & CT_ARRAY) {\n        if (i < 0) {\n            PyErr_SetString(PyExc_IndexError,\n                            \"negative index\");\n            return NULL;\n        }\n        if (i >= get_array_length(cd)) {\n            PyErr_Format(PyExc_IndexError,\n                         \"index too large for cdata '%s' (expected %zd < %zd)\",\n                         cd->c_type->ct_name,\n                         i, get_array_length(cd));\n            return NULL;\n        }\n    }\n    else {\n        PyErr_Format(PyExc_TypeError, \"cdata of type '%s' cannot be indexed\",\n                     cd->c_type->ct_name);\n        return NULL;\n    }\n    return cd->c_data + i * cd->c_type->ct_itemdescr->ct_size;\n}\n\nstatic PyObject *\nnew_array_type(CTypeDescrObject *ctptr, Py_ssize_t length);   /* forward */\n\nstatic CTypeDescrObject *\n_cdata_getslicearg(CDataObject *cd, PySliceObject *slice, Py_ssize_t bounds[])\n{\n    Py_ssize_t start, stop;\n    CTypeDescrObject *ct;\n\n    start = PyInt_AsSsize_t(slice->start);\n    if (start == -1 && PyErr_Occurred()) {\n        if (slice->start == Py_None)\n            PyErr_SetString(PyExc_IndexError, \"slice start must be specified\");\n        return NULL;\n    }\n    stop = PyInt_AsSsize_t(slice->stop);\n    if (stop == -1 && PyErr_Occurred()) {\n        if (slice->stop == Py_None)\n            PyErr_SetString(PyExc_IndexError, \"slice stop must be specified\");\n        return NULL;\n    }\n    if (slice->step != Py_None) {\n        PyErr_SetString(PyExc_IndexError, \"slice with step not supported\");\n        return NULL;\n    }\n    if (start > stop) {\n        PyErr_SetString(PyExc_IndexError, \"slice start > stop\");\n        return NULL;\n    }\n\n    ct = cd->c_type;\n    if (ct->ct_flags & CT_ARRAY) {\n        if (start < 0) {\n            PyErr_SetString(PyExc_IndexError,\n                            \"negative index\");\n            return NULL;\n        }\n        if (stop > get_array_length(cd)) {\n            PyErr_Format(PyExc_IndexError,\n                         \"index too large (expected %zd <= %zd)\",\n                         stop, get_array_length(cd));\n            return NULL;\n        }\n        ct = (CTypeDescrObject *)ct->ct_stuff;\n    }\n    else if (!(ct->ct_flags & CT_POINTER)) {\n        PyErr_Format(PyExc_TypeError, \"cdata of type '%s' cannot be indexed\",\n                     ct->ct_name);\n        return NULL;\n    }\n\n    bounds[0] = start;\n    bounds[1] = stop - start;\n    return ct;\n}\n\nstatic PyObject *\ncdata_slice(CDataObject *cd, PySliceObject *slice)\n{\n    char *cdata;\n    Py_ssize_t bounds[2];\n    CTypeDescrObject *ct = _cdata_getslicearg(cd, slice, bounds);\n    if (ct == NULL)\n        return NULL;\n\n    if (ct->ct_stuff == NULL) {\n        ct->ct_stuff = new_array_type(ct, -1);\n        if (ct->ct_stuff == NULL)\n            return NULL;\n    }\n    ct = (CTypeDescrObject *)ct->ct_stuff;\n\n    cdata = cd->c_data + ct->ct_itemdescr->ct_size * bounds[0];\n    return new_sized_cdata(cdata, ct, bounds[1]);\n}\n\nstatic int\ncdata_ass_slice(CDataObject *cd, PySliceObject *slice, PyObject *v)\n{\n    Py_ssize_t bounds[2], i, length, itemsize;\n    PyObject *it, *item;\n    PyObject *(*iternext)(PyObject *);\n    char *cdata;\n    int err;\n    CTypeDescrObject *ct = _cdata_getslicearg(cd, slice, bounds);\n    if (ct == NULL)\n        return -1;\n    ct = ct->ct_itemdescr;\n    itemsize = ct->ct_size;\n    cdata = cd->c_data + itemsize * bounds[0];\n    length = bounds[1];\n\n    if (CData_Check(v)) {\n        CTypeDescrObject *ctv = ((CDataObject *)v)->c_type;\n        if ((ctv->ct_flags & CT_ARRAY) && (ctv->ct_itemdescr == ct) &&\n            (get_array_length((CDataObject *)v) == length)) {\n            /* fast path: copying from exactly the correct type */\n            memmove(cdata, ((CDataObject *)v)->c_data, itemsize * length);\n            return 0;\n        }\n    }\n\n    /* A fast path for <char[]>[0:N] = b\"somestring\" or bytearray, which\n       also adds support for Python 3: otherwise, you get integers while\n       enumerating the string, and you can't set them to characters :-/\n    */\n    if ((ct->ct_flags & CT_PRIMITIVE_CHAR) && itemsize == sizeof(char)) {\n        char *src;\n        Py_ssize_t srclen;\n        if (PyBytes_Check(v)) {\n            srclen = PyBytes_GET_SIZE(v);\n            src = PyBytes_AS_STRING(v);\n        }\n        else if (PyByteArray_Check(v)) {\n            srclen = PyByteArray_GET_SIZE(v);\n            src = PyByteArray_AS_STRING(v);\n        }\n        else\n            goto other_types;\n\n        if (srclen != length) {\n            PyErr_Format(PyExc_ValueError,\n                         \"need a string of length %zd, got %zd\",\n                         length, srclen);\n            return -1;\n        }\n        memcpy(cdata, src, length);\n        return 0;\n    }\n   other_types:\n\n    it = PyObject_GetIter(v);\n    if (it == NULL)\n        return -1;\n    iternext = *it->ob_type->tp_iternext;\n\n    for (i = 0; i < length; i++) {\n        item = iternext(it);\n        if (item == NULL) {\n            if (!PyErr_Occurred())\n                PyErr_Format(PyExc_ValueError,\n                             \"need %zd values to unpack, got %zd\",\n                             length, i);\n            goto error;\n        }\n        err = convert_from_object(cdata, ct, item);\n        Py_DECREF(item);\n        if (err < 0)\n            goto error;\n\n        cdata += itemsize;\n    }\n    item = iternext(it);\n    if (item != NULL) {\n        Py_DECREF(item);\n        PyErr_Format(PyExc_ValueError,\n                     \"got more than %zd values to unpack\", length);\n    }\n error:\n    Py_DECREF(it);\n    return PyErr_Occurred() ? -1 : 0;\n}\n\nstatic PyObject *\ncdataowning_subscript(CDataObject *cd, PyObject *key)\n{\n    char *c;\n    if (PySlice_Check(key))\n        return cdata_slice(cd, (PySliceObject *)key);\n\n    c = _cdata_get_indexed_ptr(cd, key);\n    /* use 'mp_subscript' instead of 'sq_item' because we don't want\n       negative indexes to be corrected automatically */\n    if (c == NULL && PyErr_Occurred())\n        return NULL;\n\n    if (cd->c_type->ct_flags & CT_IS_PTR_TO_OWNED) {\n        PyObject *res = ((CDataObject_own_structptr *)cd)->structobj;\n        Py_INCREF(res);\n        return res;\n    }\n    else {\n        return convert_to_object(c, cd->c_type->ct_itemdescr);\n    }\n}\n\nstatic PyObject *\ncdata_subscript(CDataObject *cd, PyObject *key)\n{\n    char *c;\n    if (PySlice_Check(key))\n        return cdata_slice(cd, (PySliceObject *)key);\n\n    c = _cdata_get_indexed_ptr(cd, key);\n    /* use 'mp_subscript' instead of 'sq_item' because we don't want\n       negative indexes to be corrected automatically */\n    if (c == NULL && PyErr_Occurred())\n        return NULL;\n    return convert_to_object(c, cd->c_type->ct_itemdescr);\n}\n\nstatic int\ncdata_ass_sub(CDataObject *cd, PyObject *key, PyObject *v)\n{\n    char *c;\n    CTypeDescrObject *ctitem;\n    if (PySlice_Check(key))\n        return cdata_ass_slice(cd, (PySliceObject *)key, v);\n\n    c = _cdata_get_indexed_ptr(cd, key);\n    ctitem = cd->c_type->ct_itemdescr;\n    /* use 'mp_ass_subscript' instead of 'sq_ass_item' because we don't want\n       negative indexes to be corrected automatically */\n    if (c == NULL && PyErr_Occurred())\n        return -1;\n    if (v == NULL) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"'del x[n]' not supported for cdata objects\");\n        return -1;\n    }\n    return convert_from_object(c, ctitem, v);\n}\n\nstatic PyObject *\n_cdata_add_or_sub(PyObject *v, PyObject *w, int sign)\n{\n    Py_ssize_t i, itemsize;\n    CDataObject *cd;\n    CTypeDescrObject *ctptr;\n\n    if (!CData_Check(v)) {\n        PyObject *swap;\n        assert(CData_Check(w));\n        if (sign != 1)\n            goto not_implemented;\n        swap = v;\n        v = w;\n        w = swap;\n    }\n\n    i = PyNumber_AsSsize_t(w, PyExc_OverflowError);\n    if (i == -1 && PyErr_Occurred())\n        return NULL;\n    i *= sign;\n\n    cd = (CDataObject *)v;\n    if (cd->c_type->ct_flags & CT_POINTER)\n        ctptr = cd->c_type;\n    else if (cd->c_type->ct_flags & CT_ARRAY) {\n        ctptr = (CTypeDescrObject *)cd->c_type->ct_stuff;\n    }\n    else {\n        PyErr_Format(PyExc_TypeError, \"cannot add a cdata '%s' and a number\",\n                     cd->c_type->ct_name);\n        return NULL;\n    }\n    itemsize = ctptr->ct_itemdescr->ct_size;\n    if (itemsize < 0) {\n        if (ctptr->ct_flags & CT_IS_VOID_PTR) {\n            itemsize = 1;\n        }\n        else {\n            PyErr_Format(PyExc_TypeError,\n                         \"ctype '%s' points to items of unknown size\",\n                         cd->c_type->ct_name);\n            return NULL;\n        }\n    }\n    return new_simple_cdata(cd->c_data + i * itemsize, ctptr);\n\n not_implemented:\n    Py_INCREF(Py_NotImplemented);\n    return Py_NotImplemented;\n}\n\nstatic PyObject *\ncdata_add(PyObject *v, PyObject *w)\n{\n    return _cdata_add_or_sub(v, w, +1);\n}\n\nstatic PyObject *\ncdata_sub(PyObject *v, PyObject *w)\n{\n    if (CData_Check(v) && CData_Check(w)) {\n        CDataObject *cdv = (CDataObject *)v;\n        CDataObject *cdw = (CDataObject *)w;\n        CTypeDescrObject *ct = cdw->c_type;\n        Py_ssize_t diff, itemsize;\n\n        if (ct->ct_flags & CT_ARRAY)     /* ptr_to_T - array_of_T: ok */\n            ct = (CTypeDescrObject *)ct->ct_stuff;\n\n        if (ct != cdv->c_type || !(ct->ct_flags & CT_POINTER) ||\n                (ct->ct_itemdescr->ct_size <= 0 &&\n                 !(ct->ct_flags & CT_IS_VOID_PTR))) {\n            PyErr_Format(PyExc_TypeError,\n                         \"cannot subtract cdata '%s' and cdata '%s'\",\n                         cdv->c_type->ct_name, ct->ct_name);\n            return NULL;\n        }\n        itemsize = ct->ct_itemdescr->ct_size;\n        diff = cdv->c_data - cdw->c_data;\n        if (itemsize > 1) {\n            if (diff % itemsize) {\n                PyErr_SetString(PyExc_ValueError,\n                     \"pointer subtraction: the distance between the two \"\n                     \"pointers is not a multiple of the item size\");\n                return NULL;\n            }\n            diff = diff / itemsize;\n        }\n#if PY_MAJOR_VERSION < 3\n        return PyInt_FromSsize_t(diff);\n#else\n        return PyLong_FromSsize_t(diff);\n#endif\n    }\n\n    return _cdata_add_or_sub(v, w, -1);\n}\n\nstatic void\n_cdata_attr_errmsg(char *errmsg, CDataObject *cd, PyObject *attr)\n{\n    const char *text;\n    if (!PyErr_ExceptionMatches(PyExc_AttributeError))\n        return;\n    PyErr_Clear();\n    text = PyText_AsUTF8(attr);\n    if (text == NULL)\n        return;\n    PyErr_Format(PyExc_AttributeError, errmsg, cd->c_type->ct_name, text);\n}\n\nstatic PyObject *\ncdata_getattro(CDataObject *cd, PyObject *attr)\n{\n    CFieldObject *cf;\n    CTypeDescrObject *ct = cd->c_type;\n    char *errmsg = \"cdata '%s' has no attribute '%s'\";\n    PyObject *x;\n\n    if (ct->ct_flags & CT_POINTER)\n        ct = ct->ct_itemdescr;\n\n    if (ct->ct_flags & (CT_STRUCT|CT_UNION)) {\n        switch (force_lazy_struct(ct)) {\n        case 1:\n            cf = (CFieldObject *)PyDict_GetItem(ct->ct_stuff, attr);\n            if (cf != NULL) {\n                /* read the field 'cf' */\n                char *data = cd->c_data + cf->cf_offset;\n                Py_ssize_t array_len, size;\n\n                if (cf->cf_bitshift == BS_REGULAR) {\n                    return convert_to_object(data, cf->cf_type);\n                }\n                else if (cf->cf_bitshift != BS_EMPTY_ARRAY) {\n                    return convert_to_object_bitfield(data, cf);\n                }\n\n                /* variable-length array: */\n                /* if reading variable length array from variable length\n                   struct, calculate array type from allocated length */\n                size = _cdata_var_byte_size(cd) - cf->cf_offset;\n                if (size >= 0) {\n                    array_len = size / cf->cf_type->ct_itemdescr->ct_size;\n                    return new_sized_cdata(data, cf->cf_type, array_len);\n                }\n                return new_simple_cdata(data,\n                    (CTypeDescrObject *)cf->cf_type->ct_stuff);\n            }\n            errmsg = \"cdata '%s' has no field '%s'\";\n            break;\n        case -1:\n            return NULL;\n        default:\n            errmsg = \"cdata '%s' points to an opaque type: cannot read fields\";\n            break;\n        }\n    }\n    x = PyObject_GenericGetAttr((PyObject *)cd, attr);\n    if (x == NULL)\n        _cdata_attr_errmsg(errmsg, cd, attr);\n    return x;\n}\n\nstatic int\ncdata_setattro(CDataObject *cd, PyObject *attr, PyObject *value)\n{\n    CFieldObject *cf;\n    CTypeDescrObject *ct = cd->c_type;\n    char *errmsg = \"cdata '%s' has no attribute '%s'\";\n    int x;\n\n    if (ct->ct_flags & CT_POINTER)\n        ct = ct->ct_itemdescr;\n\n    if (ct->ct_flags & (CT_STRUCT|CT_UNION)) {\n        switch (force_lazy_struct(ct)) {\n        case 1:\n            cf = (CFieldObject *)PyDict_GetItem(ct->ct_stuff, attr);\n            if (cf != NULL) {\n                /* write the field 'cf' */\n                if (value != NULL) {\n                    return convert_field_from_object(cd->c_data, cf, value);\n                }\n                else {\n                    PyErr_SetString(PyExc_AttributeError,\n                                    \"cannot delete struct field\");\n                    return -1;\n                }\n            }\n            errmsg = \"cdata '%s' has no field '%s'\";\n            break;\n        case -1:\n            return -1;\n        default:\n            errmsg = \"cdata '%s' points to an opaque type: cannot write fields\";\n            break;\n        }\n    }\n    x = PyObject_GenericSetAttr((PyObject *)cd, attr, value);\n    if (x < 0)\n        _cdata_attr_errmsg(errmsg, cd, attr);\n    return x;\n}\n\nstatic PyObject *\nconvert_struct_to_owning_object(char *data, CTypeDescrObject *ct); /*forward*/\n\nstatic cif_description_t *\nfb_prepare_cif(PyObject *fargs, CTypeDescrObject *, ffi_abi);      /*forward*/\n\nstatic PyObject *new_primitive_type(const char *name);             /*forward*/\n\nstatic CTypeDescrObject *_get_ct_int(void)\n{\n    static CTypeDescrObject *ct_int = NULL;\n    if (ct_int == NULL) {\n        ct_int = (CTypeDescrObject *)new_primitive_type(\"int\");\n    }\n    return ct_int;\n}\n\nstatic Py_ssize_t\n_prepare_pointer_call_argument(CTypeDescrObject *ctptr, PyObject *init,\n                               char **output_data)\n{\n    /* 'ctptr' is here a pointer type 'ITEM *'.  Accept as argument an\n       initializer for an array 'ITEM[]'.  This includes the case of\n       passing a Python byte string to a 'char *' argument.\n\n       This function returns -1 if an error occurred,\n       0 if conversion succeeded (into *output_data),\n       or N > 0 if conversion would require N bytes of storage.\n    */\n    Py_ssize_t length, datasize;\n    CTypeDescrObject *ctitem;\n\n    if (CData_Check(init))\n        goto convert_default;\n\n    ctitem = ctptr->ct_itemdescr;\n    /* XXX some code duplication, how to avoid it? */\n    if (PyBytes_Check(init)) {\n        /* from a string: just returning the string here is fine.\n           We assume that the C code won't modify the 'char *' data. */\n        if ((ctptr->ct_flags & CT_IS_VOIDCHAR_PTR) ||\n            ((ctitem->ct_flags & (CT_PRIMITIVE_SIGNED|CT_PRIMITIVE_UNSIGNED))\n             && (ctitem->ct_size == sizeof(char)))) {\n#if defined(CFFI_MEM_DEBUG) || defined(CFFI_MEM_LEAK)\n            length = PyBytes_GET_SIZE(init) + 1;\n#else\n            *output_data = PyBytes_AS_STRING(init);\n            if (ctitem->ct_flags & CT_IS_BOOL)\n                if (must_be_array_of_zero_or_one(*output_data,\n                                                 PyBytes_GET_SIZE(init)) < 0)\n                    return -1;\n            return 0;\n#endif\n        }\n        else\n            goto convert_default;\n    }\n    else if (PyList_Check(init) || PyTuple_Check(init)) {\n        length = PySequence_Fast_GET_SIZE(init);\n    }\n    else if (PyUnicode_Check(init)) {\n        /* from a unicode, we add the null terminator */\n        if (ctitem->ct_size == 2)\n            length = _my_PyUnicode_SizeAsChar16(init);\n        else\n            length = _my_PyUnicode_SizeAsChar32(init);\n        length += 1;\n    }\n    else if ((ctitem->ct_flags & CT_IS_FILE) && PyFile_Check(init)) {\n        *output_data = (char *)PyFile_AsFile(init);\n        if (*output_data == NULL && PyErr_Occurred())\n            return -1;\n        return 0;\n    }\n    else {\n        /* refuse to receive just an integer (and interpret it\n           as the array size) */\n        goto convert_default;\n    }\n\n    if (ctitem->ct_size <= 0)\n        goto convert_default;\n    datasize = MUL_WRAPAROUND(length, ctitem->ct_size);\n    if ((datasize / ctitem->ct_size) != length) {\n        PyErr_SetString(PyExc_OverflowError,\n                        \"array size would overflow a Py_ssize_t\");\n        return -1;\n    }\n    if (datasize <= 0)\n        datasize = 1;\n    return datasize;\n\n convert_default:\n    return convert_from_object((char *)output_data, ctptr, init);\n}\n\nstatic PyObject*\ncdata_call(CDataObject *cd, PyObject *args, PyObject *kwds)\n{\n    char *buffer;\n    void** buffer_array;\n    cif_description_t *cif_descr;\n    Py_ssize_t i, nargs, nargs_declared;\n    PyObject *signature, *res = NULL, *fvarargs;\n    CTypeDescrObject *fresult;\n    char *resultdata;\n    char *errormsg;\n\n    if (!(cd->c_type->ct_flags & CT_FUNCTIONPTR)) {\n        PyErr_Format(PyExc_TypeError, \"cdata '%s' is not callable\",\n                     cd->c_type->ct_name);\n        return NULL;\n    }\n    if (cd->c_data == NULL) {\n        PyErr_Format(PyExc_RuntimeError,\n                     \"cannot call null pointer pointer from cdata '%s'\",\n                     cd->c_type->ct_name);\n        return NULL;\n    }\n    if (kwds != NULL && PyDict_Size(kwds) != 0) {\n        PyErr_SetString(PyExc_TypeError,\n                \"a cdata function cannot be called with keyword arguments\");\n        return NULL;\n    }\n    signature = cd->c_type->ct_stuff;\n    nargs = PyTuple_Size(args);\n    if (nargs < 0)\n        return NULL;\n    nargs_declared = PyTuple_GET_SIZE(signature) - 2;\n    fresult = (CTypeDescrObject *)PyTuple_GET_ITEM(signature, 1);\n    fvarargs = NULL;\n    buffer = NULL;\n\n    cif_descr = (cif_description_t *)cd->c_type->ct_extra;\n\n    if (cif_descr != NULL) {\n        /* regular case: this function does not take '...' arguments */\n        if (nargs != nargs_declared) {\n            errormsg = \"'%s' expects %zd arguments, got %zd\";\n          bad_number_of_arguments:\n            PyErr_Format(PyExc_TypeError, errormsg,\n                         cd->c_type->ct_name, nargs_declared, nargs);\n            goto error;\n        }\n    }\n    else {\n        /* call of a variadic function */\n        ffi_abi fabi;\n        if (nargs < nargs_declared) {\n            errormsg = \"'%s' expects at least %zd arguments, got %zd\";\n            goto bad_number_of_arguments;\n        }\n        fvarargs = PyTuple_New(nargs);\n        if (fvarargs == NULL)\n            goto error;\n        for (i = 0; i < nargs_declared; i++) {\n            PyObject *o = PyTuple_GET_ITEM(signature, 2 + i);\n            Py_INCREF(o);\n            PyTuple_SET_ITEM(fvarargs, i, o);\n        }\n        for (i = nargs_declared; i < nargs; i++) {\n            PyObject *obj = PyTuple_GET_ITEM(args, i);\n            CTypeDescrObject *ct;\n\n            if (CData_Check(obj)) {\n                ct = ((CDataObject *)obj)->c_type;\n                if (ct->ct_flags & (CT_PRIMITIVE_CHAR | CT_PRIMITIVE_UNSIGNED |\n                                    CT_PRIMITIVE_SIGNED)) {\n                    if (ct->ct_size < (Py_ssize_t)sizeof(int)) {\n                        ct = _get_ct_int();\n                        if (ct == NULL)\n                            goto error;\n                    }\n                }\n                else if (ct->ct_flags & CT_ARRAY) {\n                    ct = (CTypeDescrObject *)ct->ct_stuff;\n                }\n                Py_INCREF(ct);\n            }\n            else {\n                PyErr_Format(PyExc_TypeError,\n                             \"argument %zd passed in the variadic part \"\n                             \"needs to be a cdata object (got %.200s)\",\n                             i + 1, Py_TYPE(obj)->tp_name);\n                goto error;\n            }\n            PyTuple_SET_ITEM(fvarargs, i, (PyObject *)ct);\n        }\n#if PY_MAJOR_VERSION < 3\n        fabi = PyInt_AS_LONG(PyTuple_GET_ITEM(signature, 0));\n#else\n        fabi = PyLong_AS_LONG(PyTuple_GET_ITEM(signature, 0));\n#endif\n        cif_descr = fb_prepare_cif(fvarargs, fresult, fabi);\n        if (cif_descr == NULL)\n            goto error;\n    }\n\n    buffer = PyObject_Malloc(cif_descr->exchange_size);\n    if (buffer == NULL) {\n        PyErr_NoMemory();\n        goto error;\n    }\n\n    buffer_array = (void **)buffer;\n\n    for (i=0; i<nargs; i++) {\n        CTypeDescrObject *argtype;\n        char *data = buffer + cif_descr->exchange_offset_arg[1 + i];\n        PyObject *obj = PyTuple_GET_ITEM(args, i);\n\n        buffer_array[i] = data;\n\n        if (i < nargs_declared)\n            argtype = (CTypeDescrObject *)PyTuple_GET_ITEM(signature, 2 + i);\n        else\n            argtype = (CTypeDescrObject *)PyTuple_GET_ITEM(fvarargs, i);\n\n        if (argtype->ct_flags & CT_POINTER) {\n            char *tmpbuf;\n            Py_ssize_t datasize = _prepare_pointer_call_argument(\n                                            argtype, obj, (char **)data);\n            if (datasize == 0)\n                ;    /* successfully filled '*data' */\n            else if (datasize < 0)\n                goto error;\n            else {\n                tmpbuf = alloca(datasize);\n                memset(tmpbuf, 0, datasize);\n                *(char **)data = tmpbuf;\n                if (convert_array_from_object(tmpbuf, argtype, obj) < 0)\n                    goto error;\n            }\n        }\n        else if (convert_from_object(data, argtype, obj) < 0)\n            goto error;\n    }\n\n    resultdata = buffer + cif_descr->exchange_offset_arg[0];\n    /*READ(cd->c_data, sizeof(void(*)(void)))*/\n\n    Py_BEGIN_ALLOW_THREADS\n    restore_errno();\n    ffi_call(&cif_descr->cif, (void (*)(void))(cd->c_data),\n             resultdata, buffer_array);\n    save_errno();\n    Py_END_ALLOW_THREADS\n\n    if (fresult->ct_flags & (CT_PRIMITIVE_CHAR | CT_PRIMITIVE_SIGNED |\n                             CT_PRIMITIVE_UNSIGNED)) {\n#ifdef WORDS_BIGENDIAN\n        /* For results of precisely these types, libffi has a strange\n           rule that they will be returned as a whole 'ffi_arg' if they\n           are smaller.  The difference only matters on big-endian. */\n        if (fresult->ct_size < sizeof(ffi_arg))\n            resultdata += (sizeof(ffi_arg) - fresult->ct_size);\n#endif\n        res = convert_to_object(resultdata, fresult);\n    }\n    else if (fresult->ct_flags & CT_VOID) {\n        res = Py_None;\n        Py_INCREF(res);\n    }\n    else if (fresult->ct_flags & CT_STRUCT) {\n        res = convert_struct_to_owning_object(resultdata, fresult);\n    }\n    else {\n        res = convert_to_object(resultdata, fresult);\n    }\n    /* fall-through */\n\n error:\n    if (buffer)\n        PyObject_Free(buffer);\n    if (fvarargs != NULL) {\n        Py_DECREF(fvarargs);\n        if (cif_descr != NULL)  /* but only if fvarargs != NULL, if variadic */\n            PyObject_Free(cif_descr);\n    }\n    return res;\n}\n\nstatic PyObject *cdata_dir(PyObject *cd, PyObject *noarg)\n{\n    CTypeDescrObject *ct = ((CDataObject *)cd)->c_type;\n\n    /* replace the type 'pointer-to-t' with just 't' */\n    if (ct->ct_flags & CT_POINTER) {\n        ct = ct->ct_itemdescr;\n    }\n    if ((ct->ct_flags & (CT_STRUCT | CT_UNION)) &&\n        !(ct->ct_flags & CT_IS_OPAQUE)) {\n\n        /* for non-opaque structs or unions */\n        if (force_lazy_struct(ct) < 0)\n            return NULL;\n        return PyDict_Keys(ct->ct_stuff);\n    }\n    else {\n        return PyList_New(0);   /* empty list for the other cases */\n    }\n}\n\nstatic PyObject *cdata_complex(PyObject *cd_, PyObject *noarg)\n{\n    CDataObject *cd = (CDataObject *)cd_;\n\n    if (cd->c_type->ct_flags & CT_PRIMITIVE_COMPLEX) {\n        Py_complex value = read_raw_complex_data(cd->c_data, cd->c_type->ct_size);\n        PyObject *op = PyComplex_FromCComplex(value);\n        return op;\n    }\n    /* <cdata 'float'> or <cdata 'int'> cannot be directly converted by\n       calling complex(), just like <cdata 'int'> cannot be directly\n       converted by calling float() */\n\n    PyErr_Format(PyExc_TypeError, \"complex() not supported on cdata '%s'\",\n                 cd->c_type->ct_name);\n    return NULL;\n}\n\nstatic int explicit_release_case(PyObject *cd)\n{\n    CTypeDescrObject *ct = ((CDataObject *)cd)->c_type;\n    if (Py_TYPE(cd) == &CDataOwning_Type) {\n        if ((ct->ct_flags & (CT_POINTER | CT_ARRAY)) != 0)   /* ffi.new() */\n            return 0;\n    }\n    else if (Py_TYPE(cd) == &CDataFromBuf_Type) {\n        return 1;    /* ffi.from_buffer() */\n    }\n    else if (Py_TYPE(cd) == &CDataGCP_Type) {\n        return 2;    /* ffi.gc() */\n    }\n    PyErr_SetString(PyExc_ValueError,\n        \"only 'cdata' object from ffi.new(), ffi.gc(), ffi.from_buffer() \"\n        \"or ffi.new_allocator()() can be used with the 'with' keyword or \"\n        \"ffi.release()\");\n    return -1;\n}\n\nstatic PyObject *cdata_enter(PyObject *cd, PyObject *noarg)\n{\n    if (explicit_release_case(cd) < 0)   /* only to check the ctype */\n        return NULL;\n    Py_INCREF(cd);\n    return cd;\n}\n\nstatic PyObject *cdata_exit(PyObject *cd, PyObject *args)\n{\n    /* 'args' ignored */\n    CTypeDescrObject *ct;\n    Py_buffer *view;\n    switch (explicit_release_case(cd))\n    {\n        case 0:    /* ffi.new() */\n            /* no effect on CPython: raw memory is allocated with the\n               same malloc() as the object itself, so it can't be\n               released independently.  If we use a custom allocator,\n               then it's implemented with ffi.gc(). */\n            ct = ((CDataObject *)cd)->c_type;\n            if (ct->ct_flags & CT_IS_PTR_TO_OWNED) {\n                PyObject *x = ((CDataObject_own_structptr *)cd)->structobj;\n                if (Py_TYPE(x) == &CDataGCP_Type) {\n                    /* this is a special case for\n                       ffi.new_allocator()(\"struct-or-union *\") */\n                    cdatagcp_finalize((CDataObject_gcp *)x);\n                }\n            }\n            break;\n\n        case 1:    /* ffi.from_buffer() */\n            view = ((CDataObject_frombuf *)cd)->bufferview;\n            PyBuffer_Release(view);\n            break;\n\n        case 2:    /* ffi.gc() or ffi.new_allocator()(\"not-struct-nor-union\") */\n            /* call the destructor immediately */\n            cdatagcp_finalize((CDataObject_gcp *)cd);\n            break;\n\n        default:\n            return NULL;\n    }\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nstatic PyObject *cdata_iter(CDataObject *);\n\nstatic PyNumberMethods CData_as_number = {\n    (binaryfunc)cdata_add,      /*nb_add*/\n    (binaryfunc)cdata_sub,      /*nb_subtract*/\n    0,                          /*nb_multiply*/\n#if PY_MAJOR_VERSION < 3\n    0,                          /*nb_divide*/\n#endif\n    0,                          /*nb_remainder*/\n    0,                          /*nb_divmod*/\n    0,                          /*nb_power*/\n    0,                          /*nb_negative*/\n    0,                          /*nb_positive*/\n    0,                          /*nb_absolute*/\n    (inquiry)cdata_nonzero,     /*nb_nonzero*/\n    0,                          /*nb_invert*/\n    0,                          /*nb_lshift*/\n    0,                          /*nb_rshift*/\n    0,                          /*nb_and*/\n    0,                          /*nb_xor*/\n    0,                          /*nb_or*/\n#if PY_MAJOR_VERSION < 3\n    0,                          /*nb_coerce*/\n#endif\n    (unaryfunc)cdata_int,       /*nb_int*/\n#if PY_MAJOR_VERSION < 3\n    (unaryfunc)cdata_long,      /*nb_long*/\n#else\n    0,\n#endif\n    (unaryfunc)cdata_float,     /*nb_float*/\n    0,                          /*nb_oct*/\n    0,                          /*nb_hex*/\n};\n\nstatic PyMappingMethods CData_as_mapping = {\n    (lenfunc)cdata_length, /*mp_length*/\n    (binaryfunc)cdata_subscript, /*mp_subscript*/\n    (objobjargproc)cdata_ass_sub, /*mp_ass_subscript*/\n};\n\nstatic PyMappingMethods CDataOwn_as_mapping = {\n    (lenfunc)cdata_length, /*mp_length*/\n    (binaryfunc)cdataowning_subscript, /*mp_subscript*/\n    (objobjargproc)cdata_ass_sub, /*mp_ass_subscript*/\n};\n\nstatic PyMethodDef cdata_methods[] = {\n    {\"__dir__\",     cdata_dir,      METH_NOARGS},\n    {\"__complex__\", cdata_complex,  METH_NOARGS},\n    {\"__enter__\",   cdata_enter,    METH_NOARGS},\n    {\"__exit__\",    cdata_exit,     METH_VARARGS},\n    {NULL,          NULL}           /* sentinel */\n};\n\nstatic PyTypeObject CData_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_cffi_backend.CData\",\n    sizeof(CDataObject),\n    0,\n    (destructor)cdata_dealloc,                  /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_compare */\n    (reprfunc)cdata_repr,                       /* tp_repr */\n    &CData_as_number,                           /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    &CData_as_mapping,                          /* tp_as_mapping */\n    cdata_hash,                                 /* tp_hash */\n    (ternaryfunc)cdata_call,                    /* tp_call */\n    0,                                          /* tp_str */\n    (getattrofunc)cdata_getattro,               /* tp_getattro */\n    (setattrofunc)cdata_setattro,               /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_CHECKTYPES, /* tp_flags */\n    0,                                          /* tp_doc */\n    0,                                          /* tp_traverse */\n    0,                                          /* tp_clear */\n    cdata_richcompare,                          /* tp_richcompare */\n    offsetof(CDataObject, c_weakreflist),       /* tp_weaklistoffset */\n    (getiterfunc)cdata_iter,                    /* tp_iter */\n    0,                                          /* tp_iternext */\n    cdata_methods,                              /* tp_methods */\n    0,                                          /* tp_members */\n    0,                                          /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    0,                                          /* tp_init */\n    0,                                          /* tp_alloc */\n    0,                                          /* tp_new */\n    PyObject_Del,                               /* tp_free */\n};\n\nstatic PyTypeObject CDataOwning_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_cffi_backend.CDataOwn\",\n    sizeof(CDataObject),\n    0,\n    (destructor)cdataowning_dealloc,            /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_compare */\n    (reprfunc)cdataowning_repr,                 /* tp_repr */\n    0,  /* inherited */                         /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    &CDataOwn_as_mapping,                       /* tp_as_mapping */\n    0,  /* inherited */                         /* tp_hash */\n    0,  /* inherited */                         /* tp_call */\n    0,                                          /* tp_str */\n    0,  /* inherited */                         /* tp_getattro */\n    0,  /* inherited */                         /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_CHECKTYPES, /* tp_flags */\n    0,                                          /* tp_doc */\n    0,                                          /* tp_traverse */\n    0,                                          /* tp_clear */\n    0,  /* inherited */                         /* tp_richcompare */\n    0,  /* inherited */                         /* tp_weaklistoffset */\n    0,  /* inherited */                         /* tp_iter */\n    0,                                          /* tp_iternext */\n    0,  /* inherited */                         /* tp_methods */\n    0,                                          /* tp_members */\n    0,                                          /* tp_getset */\n    &CData_Type,                                /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    0,                                          /* tp_init */\n    0,                                          /* tp_alloc */\n    0,                                          /* tp_new */\n    free,                                       /* tp_free */\n};\n\nstatic PyTypeObject CDataOwningGC_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_cffi_backend.CDataOwnGC\",\n    sizeof(CDataObject_own_structptr),\n    0,\n    (destructor)cdataowninggc_dealloc,          /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_compare */\n    (reprfunc)cdataowninggc_repr,               /* tp_repr */\n    0,  /* inherited */                         /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    0,  /* inherited */                         /* tp_as_mapping */\n    0,  /* inherited */                         /* tp_hash */\n    0,  /* inherited */                         /* tp_call */\n    0,                                          /* tp_str */\n    0,  /* inherited */                         /* tp_getattro */\n    0,  /* inherited */                         /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_CHECKTYPES  /* tp_flags */\n                       | Py_TPFLAGS_HAVE_GC,\n    0,                                          /* tp_doc */\n    (traverseproc)cdataowninggc_traverse,       /* tp_traverse */\n    (inquiry)cdataowninggc_clear,               /* tp_clear */\n    0,  /* inherited */                         /* tp_richcompare */\n    0,  /* inherited */                         /* tp_weaklistoffset */\n    0,  /* inherited */                         /* tp_iter */\n    0,                                          /* tp_iternext */\n    0,  /* inherited */                         /* tp_methods */\n    0,                                          /* tp_members */\n    0,                                          /* tp_getset */\n    &CDataOwning_Type,                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    0,                                          /* tp_init */\n    0,                                          /* tp_alloc */\n    0,                                          /* tp_new */\n    PyObject_GC_Del,                            /* tp_free */\n};\n\nstatic PyTypeObject CDataFromBuf_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_cffi_backend.CDataFromBuf\",\n    sizeof(CDataObject_frombuf),\n    0,\n    (destructor)cdatafrombuf_dealloc,           /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_compare */\n    (reprfunc)cdatafrombuf_repr,                /* tp_repr */\n    0,  /* inherited */                         /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    0,  /* inherited */                         /* tp_as_mapping */\n    0,  /* inherited */                         /* tp_hash */\n    0,  /* inherited */                         /* tp_call */\n    0,                                          /* tp_str */\n    0,  /* inherited */                         /* tp_getattro */\n    0,  /* inherited */                         /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_CHECKTYPES  /* tp_flags */\n                       | Py_TPFLAGS_HAVE_GC,\n    0,                                          /* tp_doc */\n    (traverseproc)cdatafrombuf_traverse,        /* tp_traverse */\n    (inquiry)cdatafrombuf_clear,                /* tp_clear */\n    0,  /* inherited */                         /* tp_richcompare */\n    0,  /* inherited */                         /* tp_weaklistoffset */\n    0,  /* inherited */                         /* tp_iter */\n    0,                                          /* tp_iternext */\n    0,  /* inherited */                         /* tp_methods */\n    0,                                          /* tp_members */\n    0,                                          /* tp_getset */\n    &CData_Type,                                /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    0,                                          /* tp_init */\n    0,                                          /* tp_alloc */\n    0,                                          /* tp_new */\n    PyObject_GC_Del,                            /* tp_free */\n};\n\nstatic PyTypeObject CDataGCP_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_cffi_backend.CDataGCP\",\n    sizeof(CDataObject_gcp),\n    0,\n    (destructor)cdatagcp_dealloc,               /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_compare */\n    0,  /* inherited */                         /* tp_repr */\n    0,  /* inherited */                         /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    0,  /* inherited */                         /* tp_as_mapping */\n    0,  /* inherited */                         /* tp_hash */\n    0,  /* inherited */                         /* tp_call */\n    0,                                          /* tp_str */\n    0,  /* inherited */                         /* tp_getattro */\n    0,  /* inherited */                         /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_CHECKTYPES  /* tp_flags */\n#ifdef Py_TPFLAGS_HAVE_FINALIZE\n                       | Py_TPFLAGS_HAVE_FINALIZE\n#endif\n                       | Py_TPFLAGS_HAVE_GC,\n    0,                                          /* tp_doc */\n    (traverseproc)cdatagcp_traverse,            /* tp_traverse */\n    0,                                          /* tp_clear */\n    0,  /* inherited */                         /* tp_richcompare */\n    0,  /* inherited */                         /* tp_weaklistoffset */\n    0,  /* inherited */                         /* tp_iter */\n    0,                                          /* tp_iternext */\n    0,  /* inherited */                         /* tp_methods */\n    0,                                          /* tp_members */\n    0,                                          /* tp_getset */\n    &CData_Type,                                /* tp_base */\n#ifdef Py_TPFLAGS_HAVE_FINALIZE  /* CPython >= 3.4 */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    0,                                          /* tp_init */\n    0,                                          /* tp_alloc */\n    0,                                          /* tp_new */\n    0,  /* inherited */                         /* tp_free */\n    0,                                          /* tp_is_gc */\n    0,                                          /* tp_bases */\n    0,                                          /* tp_mro */\n    0,                                          /* tp_cache */\n    0,                                          /* tp_subclasses */\n    0,                                          /* tp_weaklist */\n    0,                                          /* tp_del */\n    0,                                          /* version_tag */\n    (destructor)cdatagcp_finalize,              /* tp_finalize */\n#endif\n};\n\n/************************************************************/\n\ntypedef struct {\n    PyObject_HEAD\n    char *di_next, *di_stop;\n    CDataObject *di_object;\n    CTypeDescrObject *di_itemtype;\n} CDataIterObject;\n\nstatic PyObject *\ncdataiter_next(CDataIterObject *it)\n{\n    char *result = it->di_next;\n    if (result != it->di_stop) {\n        it->di_next = result + it->di_itemtype->ct_size;\n        return convert_to_object(result, it->di_itemtype);\n    }\n    return NULL;\n}\n\nstatic void\ncdataiter_dealloc(CDataIterObject *it)\n{\n    Py_DECREF(it->di_object);\n    PyObject_Del(it);\n}\n\nstatic PyTypeObject CDataIter_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_cffi_backend.CDataIter\",              /* tp_name */\n    sizeof(CDataIterObject),                /* tp_basicsize */\n    0,                                      /* tp_itemsize */\n    /* methods */\n    (destructor)cdataiter_dealloc,          /* tp_dealloc */\n    0,                                      /* tp_print */\n    0,                                      /* tp_getattr */\n    0,                                      /* tp_setattr */\n    0,                                      /* tp_compare */\n    0,                                      /* tp_repr */\n    0,                                      /* tp_as_number */\n    0,                                      /* tp_as_sequence */\n    0,                                      /* tp_as_mapping */\n    0,                                      /* tp_hash */\n    0,                                      /* tp_call */\n    0,                                      /* tp_str */\n    PyObject_GenericGetAttr,                /* tp_getattro */\n    0,                                      /* tp_setattro */\n    0,                                      /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT,                     /* tp_flags */\n    0,                                      /* tp_doc */\n    0,                                      /* tp_traverse */\n    0,                                      /* tp_clear */\n    0,                                      /* tp_richcompare */\n    0,                                      /* tp_weaklistoffset */\n    PyObject_SelfIter,                      /* tp_iter */\n    (iternextfunc)cdataiter_next,           /* tp_iternext */\n};\n\nstatic PyObject *\ncdata_iter(CDataObject *cd)\n{\n    CDataIterObject *it;\n\n    if (!(cd->c_type->ct_flags & CT_ARRAY)) {\n        PyErr_Format(PyExc_TypeError, \"cdata '%s' does not support iteration\",\n                     cd->c_type->ct_name);\n        return NULL;\n    }\n\n    it = PyObject_New(CDataIterObject, &CDataIter_Type);\n    if (it == NULL)\n        return NULL;\n\n    Py_INCREF(cd);\n    it->di_object = cd;\n    it->di_itemtype = cd->c_type->ct_itemdescr;\n    it->di_next = cd->c_data;\n    it->di_stop = cd->c_data + get_array_length(cd) * it->di_itemtype->ct_size;\n    return (PyObject *)it;\n}\n\n/************************************************************/\n\nstatic CDataObject *allocate_owning_object(Py_ssize_t size,\n                                           CTypeDescrObject *ct,\n                                           int dont_clear)\n{\n    /* note: objects with &CDataOwning_Type are always allocated with\n       either a plain malloc() or calloc(), and freed with free(). */\n    CDataObject *cd;\n    if (dont_clear)\n        cd = malloc(size);\n    else\n        cd = calloc(size, 1);\n    if (PyObject_Init((PyObject *)cd, &CDataOwning_Type) == NULL)\n        return NULL;\n\n    Py_INCREF(ct);\n    cd->c_type = ct;\n    cd->c_weakreflist = NULL;\n    return cd;\n}\n\nstatic PyObject *\nconvert_struct_to_owning_object(char *data, CTypeDescrObject *ct)\n{\n    /* also accepts unions, for the API mode */\n    CDataObject *cd;\n    Py_ssize_t dataoffset = offsetof(CDataObject_own_nolength, alignment);\n    Py_ssize_t datasize = ct->ct_size;\n\n    if (datasize < 0) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"return type is an opaque structure or union\");\n        return NULL;\n    }\n    if (ct->ct_flags & CT_WITH_VAR_ARRAY) {\n        PyErr_SetString(PyExc_TypeError,\n                  \"return type is a struct/union with a varsize array member\");\n        return NULL;\n    }\n    cd = allocate_owning_object(dataoffset + datasize, ct, /*dont_clear=*/1);\n    if (cd == NULL)\n        return NULL;\n    cd->c_data = ((char *)cd) + dataoffset;\n\n    memcpy(cd->c_data, data, datasize);\n    return (PyObject *)cd;\n}\n\nstatic CDataObject *allocate_gcp_object(CDataObject *origobj,\n                                        CTypeDescrObject *ct,\n                                        PyObject *destructor)\n{\n    CDataObject_gcp *cd = PyObject_GC_New(CDataObject_gcp, &CDataGCP_Type);\n    if (cd == NULL)\n        return NULL;\n\n    Py_XINCREF(destructor);\n    Py_INCREF(origobj);\n    Py_INCREF(ct);\n    cd->head.c_data = origobj->c_data;\n    cd->head.c_type = ct;\n    cd->head.c_weakreflist = NULL;\n    cd->origobj = (PyObject *)origobj;\n    cd->destructor = destructor;\n\n    PyObject_GC_Track(cd);\n    return (CDataObject *)cd;\n}\n\nstatic CDataObject *allocate_with_allocator(Py_ssize_t basesize,\n                                            Py_ssize_t datasize,\n                                            CTypeDescrObject *ct,\n                                            const cffi_allocator_t *allocator)\n{\n    CDataObject *cd;\n\n    if (allocator->ca_alloc == NULL) {\n        cd = allocate_owning_object(basesize + datasize, ct,\n                                    allocator->ca_dont_clear);\n        if (cd == NULL)\n            return NULL;\n        cd->c_data = ((char *)cd) + basesize;\n    }\n    else {\n        PyObject *res = PyObject_CallFunction(allocator->ca_alloc, \"n\", datasize);\n        if (res == NULL)\n            return NULL;\n\n        if (!CData_Check(res)) {\n            PyErr_Format(PyExc_TypeError,\n                         \"alloc() must return a cdata object (got %.200s)\",\n                         Py_TYPE(res)->tp_name);\n            Py_DECREF(res);\n            return NULL;\n        }\n        cd = (CDataObject *)res;\n        if (!(cd->c_type->ct_flags & (CT_POINTER|CT_ARRAY))) {\n            PyErr_Format(PyExc_TypeError,\n                         \"alloc() must return a cdata pointer, not '%s'\",\n                         cd->c_type->ct_name);\n            Py_DECREF(res);\n            return NULL;\n        }\n        if (!cd->c_data) {\n            PyErr_SetString(PyExc_MemoryError, \"alloc() returned NULL\");\n            Py_DECREF(res);\n            return NULL;\n        }\n\n        cd = allocate_gcp_object(cd, ct, allocator->ca_free);\n        Py_DECREF(res);\n        if (!allocator->ca_dont_clear)\n            memset(cd->c_data, 0, datasize);\n    }\n    return cd;\n}\n\nstatic PyObject *direct_newp(CTypeDescrObject *ct, PyObject *init,\n                             const cffi_allocator_t *allocator)\n{\n    CTypeDescrObject *ctitem;\n    CDataObject *cd;\n    Py_ssize_t dataoffset, datasize, explicitlength;\n\n    explicitlength = -1;\n    if (ct->ct_flags & CT_POINTER) {\n        dataoffset = offsetof(CDataObject_own_nolength, alignment);\n        ctitem = ct->ct_itemdescr;\n        datasize = ctitem->ct_size;\n        if (datasize < 0) {\n            PyErr_Format(PyExc_TypeError,\n                         \"cannot instantiate ctype '%s' of unknown size\",\n                         ctitem->ct_name);\n            return NULL;\n        }\n        if (ctitem->ct_flags & CT_PRIMITIVE_CHAR)\n            datasize *= 2;   /* forcefully add another character: a null */\n\n        if (ctitem->ct_flags & (CT_STRUCT | CT_UNION)) {\n            if (force_lazy_struct(ctitem) < 0)   /* for CT_WITH_VAR_ARRAY */\n                return NULL;\n\n            if (ctitem->ct_flags & CT_WITH_VAR_ARRAY) {\n                assert(ct->ct_flags & CT_IS_PTR_TO_OWNED);\n                dataoffset = offsetof(CDataObject_own_length, alignment);\n\n                if (init != Py_None) {\n                    Py_ssize_t optvarsize = datasize;\n                    if (convert_struct_from_object(NULL, ctitem, init,\n                                                   &optvarsize) < 0)\n                        return NULL;\n                    datasize = optvarsize;\n                }\n            }\n        }\n    }\n    else if (ct->ct_flags & CT_ARRAY) {\n        dataoffset = offsetof(CDataObject_own_nolength, alignment);\n        datasize = ct->ct_size;\n        if (datasize < 0) {\n            explicitlength = get_new_array_length(ct->ct_itemdescr, &init);\n            if (explicitlength < 0)\n                return NULL;\n            ctitem = ct->ct_itemdescr;\n            dataoffset = offsetof(CDataObject_own_length, alignment);\n            datasize = MUL_WRAPAROUND(explicitlength, ctitem->ct_size);\n            if (explicitlength > 0 &&\n                    (datasize / explicitlength) != ctitem->ct_size) {\n                PyErr_SetString(PyExc_OverflowError,\n                                \"array size would overflow a Py_ssize_t\");\n                return NULL;\n            }\n        }\n    }\n    else {\n        PyErr_Format(PyExc_TypeError,\n                     \"expected a pointer or array ctype, got '%s'\",\n                     ct->ct_name);\n        return NULL;\n    }\n\n    if (ct->ct_flags & CT_IS_PTR_TO_OWNED) {\n        /* common case of ptr-to-struct (or ptr-to-union): for this case\n           we build two objects instead of one, with the memory-owning\n           one being really the struct (or union) and the returned one\n           having a strong reference to it */\n        CDataObject *cds;\n\n        cds = allocate_with_allocator(dataoffset, datasize, ct->ct_itemdescr,\n                                      allocator);\n        if (cds == NULL)\n            return NULL;\n\n        cd = allocate_owning_object(sizeof(CDataObject_own_structptr), ct,\n                                    /*dont_clear=*/1);\n        if (cd == NULL) {\n            Py_DECREF(cds);\n            return NULL;\n        }\n        /* store the only reference to cds into cd */\n        ((CDataObject_own_structptr *)cd)->structobj = (PyObject *)cds;\n        /* store information about the allocated size of the struct */\n        if (dataoffset == offsetof(CDataObject_own_length, alignment)) {\n            ((CDataObject_own_length *)cds)->length = datasize;\n        }\n        assert(explicitlength < 0);\n\n        cd->c_data = cds->c_data;\n    }\n    else {\n        cd = allocate_with_allocator(dataoffset, datasize, ct, allocator);\n        if (cd == NULL)\n            return NULL;\n\n        if (explicitlength >= 0)\n            ((CDataObject_own_length*)cd)->length = explicitlength;\n    }\n\n    if (init != Py_None) {\n        if (convert_from_object(cd->c_data,\n              (ct->ct_flags & CT_POINTER) ? ct->ct_itemdescr : ct, init) < 0) {\n            Py_DECREF(cd);\n            return NULL;\n        }\n    }\n    return (PyObject *)cd;\n}\n\nstatic PyObject *b_newp(PyObject *self, PyObject *args)\n{\n    CTypeDescrObject *ct;\n    PyObject *init = Py_None;\n    if (!PyArg_ParseTuple(args, \"O!|O:newp\", &CTypeDescr_Type, &ct, &init))\n        return NULL;\n    return direct_newp(ct, init, &default_allocator);\n}\n\nstatic int\n_my_PyObject_AsBool(PyObject *ob)\n{\n    /* convert and cast a Python object to a boolean.  Accept an integer\n       or a float object, up to a CData 'long double'. */\n    PyObject *io;\n    PyNumberMethods *nb;\n    int res;\n\n#if PY_MAJOR_VERSION < 3\n    if (PyInt_Check(ob)) {\n        return PyInt_AS_LONG(ob) != 0;\n    }\n    else\n#endif\n    if (PyLong_Check(ob)) {\n        return _PyLong_Sign(ob) != 0;\n    }\n    else if (PyFloat_Check(ob)) {\n        return PyFloat_AS_DOUBLE(ob) != 0.0;\n    }\n    else if (CData_Check(ob)) {\n        CDataObject *cd = (CDataObject *)ob;\n        if (cd->c_type->ct_flags & CT_PRIMITIVE_FLOAT) {\n            /*READ(cd->c_data, cd->c_type->ct_size)*/\n            if (cd->c_type->ct_flags & CT_IS_LONGDOUBLE) {\n                /* 'long double' objects: return the answer directly */\n                return read_raw_longdouble_data(cd->c_data) != 0.0;\n            }\n            else {\n                /* 'float'/'double' objects: return the answer directly */\n                return read_raw_float_data(cd->c_data,\n                                           cd->c_type->ct_size) != 0.0;\n            }\n        }\n    }\n    nb = ob->ob_type->tp_as_number;\n    if (nb == NULL || (nb->nb_float == NULL && nb->nb_int == NULL)) {\n        PyErr_SetString(PyExc_TypeError, \"integer/float expected\");\n        return -1;\n    }\n    if (nb->nb_float && !CData_Check(ob))\n        io = (*nb->nb_float) (ob);\n    else\n        io = (*nb->nb_int) (ob);\n    if (io == NULL)\n        return -1;\n\n    if (PyIntOrLong_Check(io) || PyFloat_Check(io)) {\n        res = _my_PyObject_AsBool(io);\n    }\n    else {\n        PyErr_SetString(PyExc_TypeError, \"integer/float conversion failed\");\n        res = -1;\n    }\n    Py_DECREF(io);\n    return res;\n}\n\nstatic CDataObject *_new_casted_primitive(CTypeDescrObject *ct)\n{\n    int dataoffset = offsetof(CDataObject_casted_primitive, alignment);\n    CDataObject *cd = (CDataObject *)PyObject_Malloc(dataoffset + ct->ct_size);\n    if (PyObject_Init((PyObject *)cd, &CData_Type) == NULL)\n        return NULL;\n    Py_INCREF(ct);\n    cd->c_type = ct;\n    cd->c_data = ((char*)cd) + dataoffset;\n    cd->c_weakreflist = NULL;\n    return cd;\n}\n\nstatic CDataObject *cast_to_integer_or_char(CTypeDescrObject *ct, PyObject *ob)\n{\n    unsigned PY_LONG_LONG value;\n    CDataObject *cd;\n\n    if (CData_Check(ob) &&\n        ((CDataObject *)ob)->c_type->ct_flags &\n                                 (CT_POINTER|CT_FUNCTIONPTR|CT_ARRAY)) {\n        value = (Py_intptr_t)((CDataObject *)ob)->c_data;\n    }\n#if PY_MAJOR_VERSION < 3\n    else if (PyString_Check(ob)) {\n        if (PyString_GET_SIZE(ob) != 1) {\n            PyErr_Format(PyExc_TypeError,\n                         \"cannot cast string of length %zd to ctype '%s'\",\n                         PyString_GET_SIZE(ob), ct->ct_name);\n            return NULL;\n        }\n        value = (unsigned char)PyString_AS_STRING(ob)[0];\n    }\n#endif\n    else if (PyUnicode_Check(ob)) {\n        char err_buf[80];\n        cffi_char32_t ordinal;\n        if (_my_PyUnicode_AsSingleChar32(ob, &ordinal, err_buf) < 0) {\n            PyErr_Format(PyExc_TypeError,\n                         \"cannot cast %s to ctype '%s'\", err_buf, ct->ct_name);\n            return NULL;\n        }\n        /* the types char16_t and char32_t are both unsigned.  However,\n           wchar_t might be signed.  In theory it does not matter,\n           because 'ordinal' comes from a regular Python unicode. */\n#ifdef HAVE_WCHAR_H\n        if (ct->ct_flags & CT_IS_SIGNED_WCHAR)\n            value = (wchar_t)ordinal;\n        else\n#endif\n            value = ordinal;\n    }\n    else if (PyBytes_Check(ob)) {\n        int res = _convert_to_char(ob);\n        if (res < 0)\n            return NULL;\n        value = (unsigned char)res;\n    }\n    else if (ct->ct_flags & CT_IS_BOOL) {\n        int res = _my_PyObject_AsBool(ob);\n        if (res < 0)\n            return NULL;\n        value = res;\n    }\n    else {\n        value = _my_PyLong_AsUnsignedLongLong(ob, 0);\n        if (value == (unsigned PY_LONG_LONG)-1 && PyErr_Occurred())\n            return NULL;\n    }\n    if (ct->ct_flags & CT_IS_BOOL)\n        value = !!value;\n    cd = _new_casted_primitive(ct);\n    if (cd != NULL)\n        write_raw_integer_data(cd->c_data, value, ct->ct_size);\n    return cd;\n}\n\n/* returns -1 if cannot cast, 0 if we don't get a value, 1 if we do */\nstatic int check_bytes_for_float_compatible(PyObject *io, double *out_value)\n{\n    if (PyBytes_Check(io)) {\n        if (PyBytes_GET_SIZE(io) != 1)\n            goto error;\n        *out_value = (unsigned char)PyBytes_AS_STRING(io)[0];\n        return 1;\n    }\n    else if (PyUnicode_Check(io)) {\n        char ignored[80];\n        cffi_char32_t ordinal;\n        if (_my_PyUnicode_AsSingleChar32(io, &ordinal, ignored) < 0)\n            goto error;\n        /* the signness of the 32-bit version of wide chars should not\n         * matter here, because 'ordinal' comes from a normal Python\n         * unicode string */\n        *out_value = ordinal;\n        return 1;\n    }\n    *out_value = 0;   /* silence a gcc warning if this function is inlined */\n    return 0;\n\n error:\n    Py_DECREF(io);\n    *out_value = 0;   /* silence a gcc warning if this function is inlined */\n    return -1;\n}\n\nstatic PyObject *do_cast(CTypeDescrObject *ct, PyObject *ob)\n{\n    CDataObject *cd;\n\n    if (ct->ct_flags & (CT_POINTER|CT_FUNCTIONPTR|CT_ARRAY) &&\n        ct->ct_size >= 0) {\n        /* cast to a pointer, to a funcptr, or to an array.\n           Note that casting to an array is an extension to the C language,\n           which seems to be necessary in order to sanely get a\n           <cdata 'int[3]'> at some address. */\n        unsigned PY_LONG_LONG value;\n\n        if (CData_Check(ob)) {\n            CDataObject *cdsrc = (CDataObject *)ob;\n            if (cdsrc->c_type->ct_flags &\n                    (CT_POINTER|CT_FUNCTIONPTR|CT_ARRAY)) {\n                return new_simple_cdata(cdsrc->c_data, ct);\n            }\n        }\n        if ((ct->ct_flags & CT_POINTER) &&\n                (ct->ct_itemdescr->ct_flags & CT_IS_FILE) &&\n                PyFile_Check(ob)) {\n            FILE *f = PyFile_AsFile(ob);\n            if (f == NULL && PyErr_Occurred())\n                return NULL;\n            return new_simple_cdata((char *)f, ct);\n        }\n        value = _my_PyLong_AsUnsignedLongLong(ob, 0);\n        if (value == (unsigned PY_LONG_LONG)-1 && PyErr_Occurred())\n            return NULL;\n        return new_simple_cdata((char *)(Py_intptr_t)value, ct);\n    }\n    else if (ct->ct_flags & (CT_PRIMITIVE_SIGNED|CT_PRIMITIVE_UNSIGNED\n                             |CT_PRIMITIVE_CHAR)) {\n        /* cast to an integer type or a char */\n        return (PyObject *)cast_to_integer_or_char(ct, ob);\n    }\n    else if (ct->ct_flags & CT_PRIMITIVE_FLOAT) {\n        /* cast to a float */\n        double value;\n        PyObject *io;\n        int res;\n\n        if (CData_Check(ob)) {\n            CDataObject *cdsrc = (CDataObject *)ob;\n\n            if (!(cdsrc->c_type->ct_flags & CT_PRIMITIVE_ANY))\n                goto cannot_cast;\n            io = convert_to_object(cdsrc->c_data, cdsrc->c_type);\n            if (io == NULL)\n                return NULL;\n        }\n        else {\n            io = ob;\n            Py_INCREF(io);\n        }\n\n        res = check_bytes_for_float_compatible(io, &value);\n        if (res == -1)\n            goto cannot_cast;\n        if (res == 0) {\n            if ((ct->ct_flags & CT_IS_LONGDOUBLE) &&\n                 CData_Check(io) &&\n                 (((CDataObject *)io)->c_type->ct_flags & CT_IS_LONGDOUBLE)) {\n                long double lvalue;\n                char *data = ((CDataObject *)io)->c_data;\n                /*READ(data, sizeof(long double)*/\n                lvalue = read_raw_longdouble_data(data);\n                Py_DECREF(io);\n                cd = _new_casted_primitive(ct);\n                if (cd != NULL)\n                    write_raw_longdouble_data(cd->c_data, lvalue);\n                return (PyObject *)cd;\n            }\n            value = PyFloat_AsDouble(io);\n        }\n        Py_DECREF(io);\n        if (value == -1.0 && PyErr_Occurred())\n            return NULL;\n\n        cd = _new_casted_primitive(ct);\n        if (cd != NULL) {\n            if (!(ct->ct_flags & CT_IS_LONGDOUBLE))\n                write_raw_float_data(cd->c_data, value, ct->ct_size);\n            else\n                write_raw_longdouble_data(cd->c_data, (long double)value);\n        }\n        return (PyObject *)cd;\n    }\n    else if (ct->ct_flags & CT_PRIMITIVE_COMPLEX) {\n        /* cast to a complex */\n        Py_complex value;\n        PyObject *io;\n        int res;\n\n        if (CData_Check(ob)) {\n            CDataObject *cdsrc = (CDataObject *)ob;\n\n            if (!(cdsrc->c_type->ct_flags & CT_PRIMITIVE_ANY))\n                goto cannot_cast;\n            io = convert_to_object(cdsrc->c_data, cdsrc->c_type);\n            if (io == NULL)\n                return NULL;\n        }\n        else {\n            io = ob;\n            Py_INCREF(io);\n        }\n\n        res = check_bytes_for_float_compatible(io, &value.real);\n        if (res == -1)\n            goto cannot_cast;\n        if (res == 1) {\n            // got it from string\n            value.imag = 0.0;\n        } else {\n            value = PyComplex_AsCComplex(io);\n        }\n        Py_DECREF(io);\n        if (PyErr_Occurred()) {\n            return NULL;\n        }\n        cd = _new_casted_primitive(ct);\n        if (cd != NULL) {\n            write_raw_complex_data(cd->c_data, value, ct->ct_size);\n        }\n        return (PyObject *)cd;\n    }\n    else {\n        PyErr_Format(PyExc_TypeError, \"cannot cast to ctype '%s'\",\n                     ct->ct_name);\n        return NULL;\n    }\n\n cannot_cast:\n    if (CData_Check(ob))\n        PyErr_Format(PyExc_TypeError, \"cannot cast ctype '%s' to ctype '%s'\",\n                     ((CDataObject *)ob)->c_type->ct_name, ct->ct_name);\n    else\n        PyErr_Format(PyExc_TypeError,\n                     \"cannot cast %.200s object to ctype '%s'\",\n                     Py_TYPE(ob)->tp_name, ct->ct_name);\n    return NULL;\n}\n\nstatic PyObject *b_cast(PyObject *self, PyObject *args)\n{\n    CTypeDescrObject *ct;\n    PyObject *ob;\n    if (!PyArg_ParseTuple(args, \"O!O:cast\", &CTypeDescr_Type, &ct, &ob))\n        return NULL;\n\n    return do_cast(ct, ob);\n}\n\n/************************************************************/\n\ntypedef struct {\n    PyObject_HEAD\n    void *dl_handle;\n    char *dl_name;\n} DynLibObject;\n\nstatic void dl_dealloc(DynLibObject *dlobj)\n{\n    if (dlobj->dl_handle != NULL)\n        dlclose(dlobj->dl_handle);\n    free(dlobj->dl_name);\n    PyObject_Del(dlobj);\n}\n\nstatic PyObject *dl_repr(DynLibObject *dlobj)\n{\n    return PyText_FromFormat(\"<clibrary '%s'>\", dlobj->dl_name);\n}\n\nstatic int dl_check_closed(DynLibObject *dlobj)\n{\n    if (dlobj->dl_handle == NULL)\n    {\n        PyErr_Format(PyExc_ValueError, \"library '%s' has already been closed\",\n                     dlobj->dl_name);\n        return -1;\n    }\n    return 0;\n}\n\nstatic PyObject *dl_load_function(DynLibObject *dlobj, PyObject *args)\n{\n    CTypeDescrObject *ct;\n    char *funcname;\n    void *funcptr;\n\n    if (!PyArg_ParseTuple(args, \"O!s:load_function\",\n                          &CTypeDescr_Type, &ct, &funcname))\n        return NULL;\n\n    if (dl_check_closed(dlobj) < 0)\n        return NULL;\n\n    if (!(ct->ct_flags & (CT_FUNCTIONPTR | CT_POINTER | CT_ARRAY))) {\n        PyErr_Format(PyExc_TypeError,\n                     \"function or pointer or array cdata expected, got '%s'\",\n                     ct->ct_name);\n        return NULL;\n    }\n    dlerror();   /* clear error condition */\n    funcptr = dlsym(dlobj->dl_handle, funcname);\n    if (funcptr == NULL) {\n        const char *error = dlerror();\n        PyErr_Format(PyExc_AttributeError,\n                     \"function/symbol '%s' not found in library '%s': %s\",\n                     funcname, dlobj->dl_name, error);\n        return NULL;\n    }\n\n    if ((ct->ct_flags & CT_ARRAY) && ct->ct_length < 0) {\n        ct = (CTypeDescrObject *)ct->ct_stuff;\n    }\n    return new_simple_cdata(funcptr, ct);\n}\n\nstatic PyObject *dl_read_variable(DynLibObject *dlobj, PyObject *args)\n{\n    CTypeDescrObject *ct;\n    char *varname;\n    char *data;\n\n    if (!PyArg_ParseTuple(args, \"O!s:read_variable\",\n                          &CTypeDescr_Type, &ct, &varname))\n        return NULL;\n\n    if (dl_check_closed(dlobj) < 0)\n        return NULL;\n\n    dlerror();   /* clear error condition */\n    data = dlsym(dlobj->dl_handle, varname);\n    if (data == NULL) {\n        const char *error = dlerror();\n        if (error != NULL) {\n            PyErr_Format(PyExc_KeyError,\n                         \"variable '%s' not found in library '%s': %s\",\n                         varname, dlobj->dl_name, error);\n            return NULL;\n        }\n    }\n    return convert_to_object(data, ct);\n}\n\nstatic PyObject *dl_write_variable(DynLibObject *dlobj, PyObject *args)\n{\n    CTypeDescrObject *ct;\n    PyObject *value;\n    char *varname;\n    char *data;\n\n    if (!PyArg_ParseTuple(args, \"O!sO:write_variable\",\n                          &CTypeDescr_Type, &ct, &varname, &value))\n        return NULL;\n\n    if (dl_check_closed(dlobj) < 0)\n        return NULL;\n\n    dlerror();   /* clear error condition */\n    data = dlsym(dlobj->dl_handle, varname);\n    if (data == NULL) {\n        const char *error = dlerror();\n        PyErr_Format(PyExc_KeyError,\n                     \"variable '%s' not found in library '%s': %s\",\n                     varname, dlobj->dl_name, error);\n        return NULL;\n    }\n    if (convert_from_object(data, ct, value) < 0)\n        return NULL;\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nstatic PyObject *dl_close_lib(DynLibObject *dlobj, PyObject *no_args)\n{\n    if (dlobj->dl_handle != NULL)\n    {\n        dlclose(dlobj->dl_handle);\n        dlobj->dl_handle = NULL;\n    }\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nstatic PyMethodDef dl_methods[] = {\n    {\"load_function\",   (PyCFunction)dl_load_function,  METH_VARARGS},\n    {\"read_variable\",   (PyCFunction)dl_read_variable,  METH_VARARGS},\n    {\"write_variable\",  (PyCFunction)dl_write_variable, METH_VARARGS},\n    {\"close_lib\",       (PyCFunction)dl_close_lib,      METH_NOARGS},\n    {NULL,              NULL}           /* sentinel */\n};\n\nstatic PyTypeObject dl_type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_cffi_backend.Library\",            /* tp_name */\n    sizeof(DynLibObject),               /* tp_basicsize */\n    0,                                  /* tp_itemsize */\n    /* methods */\n    (destructor)dl_dealloc,             /* tp_dealloc */\n    0,                                  /* tp_print */\n    0,                                  /* tp_getattr */\n    0,                                  /* tp_setattr */\n    0,                                  /* tp_compare */\n    (reprfunc)dl_repr,                  /* tp_repr */\n    0,                                  /* tp_as_number */\n    0,                                  /* tp_as_sequence */\n    0,                                  /* tp_as_mapping */\n    0,                                  /* tp_hash */\n    0,                                  /* tp_call */\n    0,                                  /* tp_str */\n    PyObject_GenericGetAttr,            /* tp_getattro */\n    0,                                  /* tp_setattro */\n    0,                                  /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT,                 /* tp_flags */\n    0,                                  /* tp_doc */\n    0,                                  /* tp_traverse */\n    0,                                  /* tp_clear */\n    0,                                  /* tp_richcompare */\n    0,                                  /* tp_weaklistoffset */\n    0,                                  /* tp_iter */\n    0,                                  /* tp_iternext */\n    dl_methods,                         /* tp_methods */\n};\n\nstatic void *b_do_dlopen(PyObject *args, const char **p_printable_filename,\n                         PyObject **p_temp)\n{\n    /* Logic to call the correct version of dlopen().  Returns NULL in case of error.\n       Otherwise, '*p_printable_filename' will point to a printable char version of\n       the filename (maybe utf-8-encoded).  '*p_temp' will be set either to NULL or\n       to a temporary object that must be freed after looking at printable_filename.\n    */\n    void *handle;\n    char *filename_or_null;\n    int flags = 0;\n    *p_temp = NULL;\n    \n    if (PyTuple_GET_SIZE(args) == 0 || PyTuple_GET_ITEM(args, 0) == Py_None) {\n        PyObject *dummy;\n        if (!PyArg_ParseTuple(args, \"|Oi:load_library\",\n                              &dummy, &flags))\n            return NULL;\n        filename_or_null = NULL;\n        *p_printable_filename = \"<None>\";\n    }\n    else\n    {\n        PyObject *s = PyTuple_GET_ITEM(args, 0);\n#ifdef MS_WIN32\n        Py_UNICODE *filenameW;\n        if (PyArg_ParseTuple(args, \"u|i:load_library\", &filenameW, &flags))\n        {\n#if PY_MAJOR_VERSION < 3\n            s = PyUnicode_AsUTF8String(s);\n            if (s == NULL)\n                return NULL;\n            *p_temp = s;\n#endif\n            *p_printable_filename = PyText_AsUTF8(s);\n            if (*p_printable_filename == NULL)\n                return NULL;\n\n            handle = dlopenW(filenameW);\n            goto got_handle;\n        }\n        PyErr_Clear();\n#endif\n        if (!PyArg_ParseTuple(args, \"et|i:load_library\",\n                     Py_FileSystemDefaultEncoding, &filename_or_null, &flags))\n            return NULL;\n#if PY_MAJOR_VERSION < 3\n        if (PyUnicode_Check(s))\n        {\n            s = PyUnicode_AsUTF8String(s);\n            if (s == NULL)\n                return NULL;\n            *p_temp = s;\n        }\n#endif\n        *p_printable_filename = PyText_AsUTF8(s);\n        if (*p_printable_filename == NULL)\n            return NULL;\n    }\n    if ((flags & (RTLD_NOW | RTLD_LAZY)) == 0)\n        flags |= RTLD_NOW;\n\n    handle = dlopen(filename_or_null, flags);\n\n#ifdef MS_WIN32\n  got_handle:\n#endif\n    if (handle == NULL) {\n        const char *error = dlerror();\n        PyErr_Format(PyExc_OSError, \"cannot load library '%s': %s\",\n                     *p_printable_filename, error);\n        return NULL;\n    }\n    return handle;\n}\n\nstatic PyObject *b_load_library(PyObject *self, PyObject *args)\n{\n    const char *printable_filename;\n    PyObject *temp;\n    void *handle;\n    DynLibObject *dlobj = NULL;\n\n    handle = b_do_dlopen(args, &printable_filename, &temp);\n    if (handle == NULL)\n        goto error;\n\n    dlobj = PyObject_New(DynLibObject, &dl_type);\n    if (dlobj == NULL) {\n        dlclose(handle);\n        goto error;\n    }\n    dlobj->dl_handle = handle;\n    dlobj->dl_name = strdup(printable_filename);\n \n error:\n    Py_XDECREF(temp);\n    return (PyObject *)dlobj;\n}\n\n/************************************************************/\n\nstatic PyObject *get_unique_type(CTypeDescrObject *x,\n                                 const void *unique_key[], long keylength)\n{\n    /* Replace the CTypeDescrObject 'x' with a standardized one.\n       This either just returns x, or x is decrefed and a new reference\n       to the already-existing equivalent is returned.\n\n       In this function, 'x' always contains a reference that must be\n       either decrefed or returned.\n\n       Keys:\n           void       [\"void\"]\n           primitive  [&static_struct]\n           pointer    [ctype]\n           array      [ctype, length]\n           funcptr    [ctresult, ellipsis+abi, num_args, ctargs...]\n    */\n    PyObject *key, *y;\n    void *pkey;\n\n    key = PyBytes_FromStringAndSize(NULL, keylength * sizeof(void *));\n    if (key == NULL)\n        goto error;\n\n    pkey = PyBytes_AS_STRING(key);\n    memcpy(pkey, unique_key, keylength * sizeof(void *));\n\n    y = PyDict_GetItem(unique_cache, key);\n    if (y != NULL) {\n        Py_DECREF(key);\n        Py_INCREF(y);\n        Py_DECREF(x);\n        return y;\n    }\n    if (PyDict_SetItem(unique_cache, key, (PyObject *)x) < 0) {\n        Py_DECREF(key);\n        goto error;\n    }\n    /* Haaaack for our reference count hack: gcmodule.c must not see this\n       dictionary.  The problem is that any PyDict_SetItem() notices that\n       'x' is tracked and re-tracks the unique_cache dictionary.  So here\n       we re-untrack it again... */\n    PyObject_GC_UnTrack(unique_cache);\n\n    assert(x->ct_unique_key == NULL);\n    x->ct_unique_key = key; /* the key will be freed in ctypedescr_dealloc() */\n    /* the 'value' in unique_cache doesn't count as 1, but don't use\n       Py_DECREF(x) here because it will confuse debug builds into thinking\n       there was an extra DECREF in total. */\n    ((PyObject *)x)->ob_refcnt--;\n    return (PyObject *)x;\n\n error:\n    Py_DECREF(x);\n    return NULL;\n}\n\n/* according to the C standard, these types should be equivalent to the\n   _Complex types for the purposes of storage (not arguments in calls!) */\ntypedef float cffi_float_complex_t[2];\ntypedef double cffi_double_complex_t[2];\n\nstatic PyObject *new_primitive_type(const char *name)\n{\n#define ENUM_PRIMITIVE_TYPES                                    \\\n       EPTYPE(c, char, CT_PRIMITIVE_CHAR)                       \\\n       EPTYPE(s, short, CT_PRIMITIVE_SIGNED )                   \\\n       EPTYPE(i, int, CT_PRIMITIVE_SIGNED )                     \\\n       EPTYPE(l, long, CT_PRIMITIVE_SIGNED )                    \\\n       EPTYPE(ll, long long, CT_PRIMITIVE_SIGNED )              \\\n       EPTYPE(sc, signed char, CT_PRIMITIVE_SIGNED )            \\\n       EPTYPE(uc, unsigned char, CT_PRIMITIVE_UNSIGNED )        \\\n       EPTYPE(us, unsigned short, CT_PRIMITIVE_UNSIGNED )       \\\n       EPTYPE(ui, unsigned int, CT_PRIMITIVE_UNSIGNED )         \\\n       EPTYPE(ul, unsigned long, CT_PRIMITIVE_UNSIGNED )        \\\n       EPTYPE(ull, unsigned long long, CT_PRIMITIVE_UNSIGNED )  \\\n       EPTYPE(f, float, CT_PRIMITIVE_FLOAT )                    \\\n       EPTYPE(d, double, CT_PRIMITIVE_FLOAT )                   \\\n       EPTYPE(ld, long double, CT_PRIMITIVE_FLOAT | CT_IS_LONGDOUBLE ) \\\n       EPTYPE2(fc, \"float _Complex\", cffi_float_complex_t, CT_PRIMITIVE_COMPLEX ) \\\n       EPTYPE2(dc, \"double _Complex\", cffi_double_complex_t, CT_PRIMITIVE_COMPLEX ) \\\n       ENUM_PRIMITIVE_TYPES_WCHAR                               \\\n       EPTYPE2(c16, \"char16_t\", cffi_char16_t, CT_PRIMITIVE_CHAR ) \\\n       EPTYPE2(c32, \"char32_t\", cffi_char32_t, CT_PRIMITIVE_CHAR ) \\\n       EPTYPE(b, _Bool, CT_PRIMITIVE_UNSIGNED | CT_IS_BOOL )    \\\n     /* the following types are not primitive in the C sense */ \\\n       EPTYPE(i8, int8_t, CT_PRIMITIVE_SIGNED)                  \\\n       EPTYPE(u8, uint8_t, CT_PRIMITIVE_UNSIGNED)               \\\n       EPTYPE(i16, int16_t, CT_PRIMITIVE_SIGNED)                \\\n       EPTYPE(u16, uint16_t, CT_PRIMITIVE_UNSIGNED)             \\\n       EPTYPE(i32, int32_t, CT_PRIMITIVE_SIGNED)                \\\n       EPTYPE(u32, uint32_t, CT_PRIMITIVE_UNSIGNED)             \\\n       EPTYPE(i64, int64_t, CT_PRIMITIVE_SIGNED)                \\\n       EPTYPE(u64, uint64_t, CT_PRIMITIVE_UNSIGNED)             \\\n       EPTYPE(il8, int_least8_t, CT_PRIMITIVE_SIGNED)           \\\n       EPTYPE(ul8, uint_least8_t, CT_PRIMITIVE_UNSIGNED)        \\\n       EPTYPE(il16, int_least16_t, CT_PRIMITIVE_SIGNED)         \\\n       EPTYPE(ul16, uint_least16_t, CT_PRIMITIVE_UNSIGNED)      \\\n       EPTYPE(il32, int_least32_t, CT_PRIMITIVE_SIGNED)         \\\n       EPTYPE(ul32, uint_least32_t, CT_PRIMITIVE_UNSIGNED)      \\\n       EPTYPE(il64, int_least64_t, CT_PRIMITIVE_SIGNED)         \\\n       EPTYPE(ul64, uint_least64_t, CT_PRIMITIVE_UNSIGNED)      \\\n       EPTYPE(if8, int_fast8_t, CT_PRIMITIVE_SIGNED)            \\\n       EPTYPE(uf8, uint_fast8_t, CT_PRIMITIVE_UNSIGNED)         \\\n       EPTYPE(if16, int_fast16_t, CT_PRIMITIVE_SIGNED)          \\\n       EPTYPE(uf16, uint_fast16_t, CT_PRIMITIVE_UNSIGNED)       \\\n       EPTYPE(if32, int_fast32_t, CT_PRIMITIVE_SIGNED)          \\\n       EPTYPE(uf32, uint_fast32_t, CT_PRIMITIVE_UNSIGNED)       \\\n       EPTYPE(if64, int_fast64_t, CT_PRIMITIVE_SIGNED)          \\\n       EPTYPE(uf64, uint_fast64_t, CT_PRIMITIVE_UNSIGNED)       \\\n       EPTYPE(ip, intptr_t, CT_PRIMITIVE_SIGNED)                \\\n       EPTYPE(up, uintptr_t, CT_PRIMITIVE_UNSIGNED)             \\\n       EPTYPE(im, intmax_t, CT_PRIMITIVE_SIGNED)                \\\n       EPTYPE(um, uintmax_t, CT_PRIMITIVE_UNSIGNED)             \\\n       EPTYPE(pd, ptrdiff_t, CT_PRIMITIVE_SIGNED)               \\\n       EPTYPE(sz, size_t, CT_PRIMITIVE_UNSIGNED)                \\\n       EPTYPE2(ssz, \"ssize_t\", Py_ssize_t, CT_PRIMITIVE_SIGNED)\n\n#ifdef HAVE_WCHAR_H\n# define ENUM_PRIMITIVE_TYPES_WCHAR                             \\\n       EPTYPE(wc, wchar_t, CT_PRIMITIVE_CHAR |                  \\\n                           (((wchar_t)-1) > 0 ? 0 : CT_IS_SIGNED_WCHAR))\n#else\n# define ENUM_PRIMITIVE_TYPES_WCHAR   /* nothing */\n#endif\n\n#define EPTYPE(code, typename, flags)  EPTYPE2(code, #typename, typename, flags)\n\n#define EPTYPE2(code, export_name, typename, flags)     \\\n    struct aligncheck_##code { char x; typename y; };\n    ENUM_PRIMITIVE_TYPES\n#undef EPTYPE2\n\n    CTypeDescrObject *td;\n    static const struct descr_s { const char *name; int size, align, flags; }\n    types[] = {\n#define EPTYPE2(code, export_name, typename, flags)     \\\n        { export_name,                                  \\\n          sizeof(typename),                             \\\n          offsetof(struct aligncheck_##code, y),        \\\n          flags                                         \\\n        },\n    ENUM_PRIMITIVE_TYPES\n#undef EPTYPE2\n#undef EPTYPE\n#undef ENUM_PRIMITIVE_TYPES_WCHAR\n#undef ENUM_PRIMITIVE_TYPES\n        { NULL }\n    };\n    const struct descr_s *ptypes;\n    const void *unique_key[1];\n    int name_size;\n    ffi_type *ffitype;\n\n    for (ptypes=types; ; ptypes++) {\n        if (ptypes->name == NULL) {\n#ifndef HAVE_WCHAR_H\n            if (strcmp(name, \"wchar_t\"))\n                PyErr_SetString(PyExc_NotImplementedError, name);\n            else\n#endif\n            PyErr_SetString(PyExc_KeyError, name);\n            return NULL;\n        }\n        if (strcmp(name, ptypes->name) == 0)\n            break;\n    }\n\n    if (ptypes->flags & CT_PRIMITIVE_SIGNED) {\n        switch (ptypes->size) {\n        case 1: ffitype = &ffi_type_sint8; break;\n        case 2: ffitype = &ffi_type_sint16; break;\n        case 4: ffitype = &ffi_type_sint32; break;\n        case 8: ffitype = &ffi_type_sint64; break;\n        default: goto bad_ffi_type;\n        }\n    }\n    else if (ptypes->flags & CT_PRIMITIVE_FLOAT) {\n        if (strcmp(ptypes->name, \"float\") == 0)\n            ffitype = &ffi_type_float;\n        else if (strcmp(ptypes->name, \"double\") == 0)\n            ffitype = &ffi_type_double;\n        else if (strcmp(ptypes->name, \"long double\") == 0) {\n            /* assume that if sizeof(double) == sizeof(long double), then\n               the two types are equivalent for C.  libffi bugs on Win64\n               if a function's return type is ffi_type_longdouble... */\n            if (sizeof(double) == sizeof(long double))\n                ffitype = &ffi_type_double;\n            else\n                ffitype = &ffi_type_longdouble;\n        }\n        else\n            goto bad_ffi_type;\n    }\n    else if (ptypes->flags & CT_PRIMITIVE_COMPLEX) {\n        /* As of March 2017, still no libffi support for complex.\n           It fails silently if we try to use ffi_type_complex_float\n           or ffi_type_complex_double.  Better not use it at all.\n         */\n        ffitype = NULL;\n    }\n    else {\n        switch (ptypes->size) {\n        case 1: ffitype = &ffi_type_uint8; break;\n        case 2: ffitype = &ffi_type_uint16; break;\n        case 4: ffitype = &ffi_type_uint32; break;\n        case 8: ffitype = &ffi_type_uint64; break;\n        default: goto bad_ffi_type;\n        }\n    }\n\n    name_size = strlen(ptypes->name) + 1;\n    td = ctypedescr_new(name_size);\n    if (td == NULL)\n        return NULL;\n\n    memcpy(td->ct_name, name, name_size);\n    td->ct_size = ptypes->size;\n    td->ct_length = ptypes->align;\n    td->ct_extra = ffitype;\n    td->ct_flags = ptypes->flags;\n    if (td->ct_flags & (CT_PRIMITIVE_SIGNED | CT_PRIMITIVE_CHAR)) {\n        if (td->ct_size <= (Py_ssize_t)sizeof(long))\n            td->ct_flags |= CT_PRIMITIVE_FITS_LONG;\n    }\n    else if (td->ct_flags & CT_PRIMITIVE_UNSIGNED) {\n        if (td->ct_size < (Py_ssize_t)sizeof(long))\n            td->ct_flags |= CT_PRIMITIVE_FITS_LONG;\n    }\n    td->ct_name_position = strlen(td->ct_name);\n    unique_key[0] = ptypes;\n    return get_unique_type(td, unique_key, 1);\n\n bad_ffi_type:\n    PyErr_Format(PyExc_NotImplementedError,\n                 \"primitive type '%s' has size %d; \"\n                 \"the supported sizes are 1, 2, 4, 8\",\n                 name, (int)ptypes->size);\n    return NULL;\n}\n\nstatic PyObject *b_new_primitive_type(PyObject *self, PyObject *args)\n{\n    char *name;\n    if (!PyArg_ParseTuple(args, \"s:new_primitive_type\", &name))\n        return NULL;\n    return new_primitive_type(name);\n}\n\nstatic PyObject *new_pointer_type(CTypeDescrObject *ctitem)\n{\n    CTypeDescrObject *td;\n    const char *extra;\n    const void *unique_key[1];\n\n    if (ctitem->ct_flags & CT_ARRAY)\n        extra = \"(*)\";   /* obscure case: see test_array_add */\n    else\n        extra = \" *\";\n    td = ctypedescr_new_on_top(ctitem, extra, 2);\n    if (td == NULL)\n        return NULL;\n\n    td->ct_size = sizeof(void *);\n    td->ct_length = -1;\n    td->ct_flags = CT_POINTER;\n    if (ctitem->ct_flags & (CT_STRUCT|CT_UNION))\n        td->ct_flags |= CT_IS_PTR_TO_OWNED;\n    if (ctitem->ct_flags & CT_VOID)\n        td->ct_flags |= CT_IS_VOID_PTR;\n    if ((ctitem->ct_flags & CT_VOID) ||\n        ((ctitem->ct_flags & CT_PRIMITIVE_CHAR) &&\n         ctitem->ct_size == sizeof(char)))\n        td->ct_flags |= CT_IS_VOIDCHAR_PTR;   /* 'void *' or 'char *' only */\n    unique_key[0] = ctitem;\n    return get_unique_type(td, unique_key, 1);\n}\n\nstatic PyObject *b_new_pointer_type(PyObject *self, PyObject *args)\n{\n    CTypeDescrObject *ctitem;\n    if (!PyArg_ParseTuple(args, \"O!:new_pointer_type\",\n                          &CTypeDescr_Type, &ctitem))\n        return NULL;\n    return new_pointer_type(ctitem);\n}\n\nstatic PyObject *b_new_array_type(PyObject *self, PyObject *args)\n{\n    PyObject *lengthobj;\n    Py_ssize_t length;\n    CTypeDescrObject *ctptr;\n\n    if (!PyArg_ParseTuple(args, \"O!O:new_array_type\",\n                          &CTypeDescr_Type, &ctptr, &lengthobj))\n        return NULL;\n\n    if (lengthobj == Py_None) {\n        length = -1;\n    }\n    else {\n        length = PyNumber_AsSsize_t(lengthobj, PyExc_OverflowError);\n        if (length < 0) {\n            if (!PyErr_Occurred())\n                PyErr_SetString(PyExc_ValueError, \"negative array length\");\n            return NULL;\n        }\n    }\n    return new_array_type(ctptr, length);\n}\n\nstatic PyObject *\nnew_array_type(CTypeDescrObject *ctptr, Py_ssize_t length)\n{\n    CTypeDescrObject *td, *ctitem;\n    char extra_text[32];\n    Py_ssize_t arraysize;\n    int flags = CT_ARRAY;\n    const void *unique_key[2];\n\n    if (!(ctptr->ct_flags & CT_POINTER)) {\n        PyErr_SetString(PyExc_TypeError, \"first arg must be a pointer ctype\");\n        return NULL;\n    }\n    ctitem = ctptr->ct_itemdescr;\n    if (ctitem->ct_size < 0) {\n        PyErr_Format(PyExc_ValueError, \"array item of unknown size: '%s'\",\n                     ctitem->ct_name);\n        return NULL;\n    }\n\n    if (length < 0) {\n        sprintf(extra_text, \"[]\");\n        length = -1;\n        arraysize = -1;\n    }\n    else {\n        sprintf(extra_text, \"[%llu]\", (unsigned PY_LONG_LONG)length);\n        arraysize = MUL_WRAPAROUND(length, ctitem->ct_size);\n        if (length > 0 && (arraysize / length) != ctitem->ct_size) {\n            PyErr_SetString(PyExc_OverflowError,\n                            \"array size would overflow a Py_ssize_t\");\n            return NULL;\n        }\n    }\n    td = ctypedescr_new_on_top(ctitem, extra_text, 0);\n    if (td == NULL)\n        return NULL;\n\n    Py_INCREF(ctptr);\n    td->ct_stuff = (PyObject *)ctptr;\n    td->ct_size = arraysize;\n    td->ct_length = length;\n    td->ct_flags = flags;\n    unique_key[0] = ctptr;\n    unique_key[1] = (void *)length;\n    return get_unique_type(td, unique_key, 2);\n}\n\nstatic PyObject *new_void_type(void)\n{\n    int name_size = strlen(\"void\") + 1;\n    const void *unique_key[1];\n    CTypeDescrObject *td = ctypedescr_new(name_size);\n    if (td == NULL)\n        return NULL;\n\n    memcpy(td->ct_name, \"void\", name_size);\n    td->ct_size = -1;\n    td->ct_flags = CT_VOID | CT_IS_OPAQUE;\n    td->ct_name_position = strlen(\"void\");\n    unique_key[0] = \"void\";\n    return get_unique_type(td, unique_key, 1);\n}\n\nstatic PyObject *b_new_void_type(PyObject *self, PyObject *args)\n{\n    return new_void_type();\n}\n\nstatic PyObject *new_struct_or_union_type(const char *name, int flag)\n{\n    int namelen = strlen(name);\n    CTypeDescrObject *td = ctypedescr_new(namelen + 1);\n    if (td == NULL)\n        return NULL;\n\n    td->ct_size = -1;\n    td->ct_length = -1;\n    td->ct_flags = flag | CT_IS_OPAQUE;\n    td->ct_extra = NULL;\n    memcpy(td->ct_name, name, namelen + 1);\n    td->ct_name_position = namelen;\n    return (PyObject *)td;\n}\n\nstatic PyObject *b_new_struct_type(PyObject *self, PyObject *args)\n{\n    char *name;\n    int flag;\n    if (!PyArg_ParseTuple(args, \"s:new_struct_type\", &name))\n        return NULL;\n\n    flag = CT_STRUCT;\n    if (strcmp(name, \"struct _IO_FILE\") == 0 || strcmp(name, \"FILE\") == 0)\n        flag |= CT_IS_FILE;\n    return new_struct_or_union_type(name, flag);\n}\n\nstatic PyObject *b_new_union_type(PyObject *self, PyObject *args)\n{\n    char *name;\n    if (!PyArg_ParseTuple(args, \"s:new_union_type\", &name))\n        return NULL;\n    return new_struct_or_union_type(name, CT_UNION);\n}\n\nstatic CFieldObject *\n_add_field(PyObject *interned_fields, PyObject *fname, CTypeDescrObject *ftype,\n           Py_ssize_t offset, int bitshift, int fbitsize, int flags)\n{\n    int err;\n    Py_ssize_t prev_size;\n    CFieldObject *cf = PyObject_New(CFieldObject, &CField_Type);\n    if (cf == NULL)\n        return NULL;\n\n    Py_INCREF(ftype);\n    cf->cf_type = ftype;\n    cf->cf_offset = offset;\n    cf->cf_bitshift = bitshift;\n    cf->cf_bitsize = fbitsize;\n    cf->cf_flags = flags;\n\n    Py_INCREF(fname);\n    PyText_InternInPlace(&fname);\n    prev_size = PyDict_Size(interned_fields);\n    err = PyDict_SetItem(interned_fields, fname, (PyObject *)cf);\n    Py_DECREF(fname);\n    Py_DECREF(cf);\n    if (err < 0)\n        return NULL;\n\n    if (PyDict_Size(interned_fields) != prev_size + 1) {\n        PyErr_Format(PyExc_KeyError, \"duplicate field name '%s'\",\n                     PyText_AS_UTF8(fname));\n        return NULL;\n    }\n    return cf;   /* borrowed reference */\n}\n\n#define SF_MSVC_BITFIELDS     0x01\n#define SF_GCC_ARM_BITFIELDS  0x02\n#define SF_GCC_X86_BITFIELDS  0x10\n\n#define SF_GCC_BIG_ENDIAN     0x04\n#define SF_GCC_LITTLE_ENDIAN  0x40\n\n#define SF_PACKED             0x08\n#define SF_STD_FIELD_POS      0x80\n\n#ifdef MS_WIN32\n#  define SF_DEFAULT_PACKING     8\n#else\n#  define SF_DEFAULT_PACKING   0x40000000   /* a huge power of two */\n#endif\n\nstatic int complete_sflags(int sflags)\n{\n    /* add one of the SF_xxx_BITFIELDS flags if none is specified */\n    if (!(sflags & (SF_MSVC_BITFIELDS | SF_GCC_ARM_BITFIELDS |\n                    SF_GCC_X86_BITFIELDS))) {\n#ifdef MS_WIN32\n        sflags |= SF_MSVC_BITFIELDS;\n#else\n# if defined(__arm__) || defined(__aarch64__)\n        sflags |= SF_GCC_ARM_BITFIELDS;\n# else\n        sflags |= SF_GCC_X86_BITFIELDS;\n# endif\n#endif\n    }\n    /* add one of SF_GCC_xx_ENDIAN if none is specified */\n    if (!(sflags & (SF_GCC_BIG_ENDIAN | SF_GCC_LITTLE_ENDIAN))) {\n        int _check_endian = 1;\n        if (*(char *)&_check_endian == 0)\n            sflags |= SF_GCC_BIG_ENDIAN;\n        else\n            sflags |= SF_GCC_LITTLE_ENDIAN;\n    }\n    return sflags;\n}\n\nstatic int detect_custom_layout(CTypeDescrObject *ct, int sflags,\n                                Py_ssize_t cdef_value,\n                                Py_ssize_t compiler_value,\n                                const char *msg1, const char *txt,\n                                const char *msg2)\n{\n    if (compiler_value != cdef_value) {\n        if (sflags & SF_STD_FIELD_POS) {\n            PyErr_Format(FFIError,\n                         \"%s: %s%s%s (cdef says %zd, but C compiler says %zd).\"\n                         \" fix it or use \\\"...;\\\" in the cdef for %s to \"\n                         \"make it flexible\",\n                         ct->ct_name, msg1, txt, msg2,\n                         cdef_value, compiler_value,\n                         ct->ct_name);\n            return -1;\n        }\n        ct->ct_flags |= CT_CUSTOM_FIELD_POS;\n    }\n    return 0;\n}\n\n#define ROUNDUP_BYTES(bytes, bits)    ((bytes) + ((bits) > 0))\n\nstatic PyObject *b_complete_struct_or_union(PyObject *self, PyObject *args)\n{\n    CTypeDescrObject *ct;\n    PyObject *fields, *interned_fields, *ignored;\n    int is_union, alignment;\n    Py_ssize_t byteoffset, i, nb_fields, byteoffsetmax, alignedsize;\n    int bitoffset;\n    Py_ssize_t byteoffsetorg;\n    Py_ssize_t totalsize = -1;\n    int totalalignment = -1;\n    CFieldObject **previous;\n    int prev_bitfield_size, prev_bitfield_free;\n    int sflags = 0, fflags;\n    int pack = 0;\n\n    if (!PyArg_ParseTuple(args, \"O!O!|Oniii:complete_struct_or_union\",\n                          &CTypeDescr_Type, &ct,\n                          &PyList_Type, &fields,\n                          &ignored, &totalsize, &totalalignment, &sflags,\n                          &pack))\n        return NULL;\n\n    sflags = complete_sflags(sflags);\n    if (sflags & SF_PACKED)\n        pack = 1;\n    else if (pack <= 0)\n        pack = SF_DEFAULT_PACKING;\n    else\n        sflags |= SF_PACKED;\n\n    if ((ct->ct_flags & (CT_STRUCT|CT_IS_OPAQUE)) ==\n                        (CT_STRUCT|CT_IS_OPAQUE)) {\n        is_union = 0;\n    }\n    else if ((ct->ct_flags & (CT_UNION|CT_IS_OPAQUE)) ==\n                             (CT_UNION|CT_IS_OPAQUE)) {\n        is_union = 1;\n    }\n    else {\n        PyErr_SetString(PyExc_TypeError,\n                  \"first arg must be a non-initialized struct or union ctype\");\n        return NULL;\n    }\n    ct->ct_flags &= ~(CT_CUSTOM_FIELD_POS | CT_WITH_PACKED_CHANGE);\n\n    alignment = 1;\n    byteoffset = 0;     /* the real value is 'byteoffset+bitoffset*8', which */\n    bitoffset = 0;      /* counts the offset in bits */\n    byteoffsetmax = 0; /* the maximum value of byteoffset-rounded-up-to-byte */\n    prev_bitfield_size = 0;\n    prev_bitfield_free = 0;\n    nb_fields = PyList_GET_SIZE(fields);\n    interned_fields = PyDict_New();\n    if (interned_fields == NULL)\n        return NULL;\n\n    previous = (CFieldObject **)&ct->ct_extra;\n\n    for (i=0; i<nb_fields; i++) {\n        PyObject *fname;\n        CTypeDescrObject *ftype;\n        int fbitsize = -1, falign, falignorg, do_align;\n        Py_ssize_t foffset = -1;\n\n        if (!PyArg_ParseTuple(PyList_GET_ITEM(fields, i), \"O!O!|in:list item\",\n                              &PyText_Type, &fname,\n                              &CTypeDescr_Type, &ftype,\n                              &fbitsize, &foffset))\n            goto error;\n\n        if (ftype->ct_size < 0) {\n            if ((ftype->ct_flags & CT_ARRAY) && fbitsize < 0\n                    && (i == nb_fields - 1 || foffset != -1)) {\n                ct->ct_flags |= CT_WITH_VAR_ARRAY;\n            }\n            else {\n                PyErr_Format(PyExc_TypeError,\n                             \"field '%s.%s' has ctype '%s' of unknown size\",\n                             ct->ct_name, PyText_AS_UTF8(fname),\n                             ftype->ct_name);\n                goto error;\n            }\n        }\n        else if (ftype->ct_flags & (CT_STRUCT|CT_UNION)) {\n            if (force_lazy_struct(ftype) < 0)   /* for CT_WITH_VAR_ARRAY */\n                return NULL;\n\n            /* GCC (or maybe C99) accepts var-sized struct fields that are not\n               the last field of a larger struct.  That's why there is no\n               check here for \"last field\": we propagate the flag\n               CT_WITH_VAR_ARRAY to any struct that contains either an open-\n               ended array or another struct that recursively contains an\n               open-ended array. */\n            if (ftype->ct_flags & CT_WITH_VAR_ARRAY)\n                ct->ct_flags |= CT_WITH_VAR_ARRAY;\n        }\n\n        if (is_union)\n            byteoffset = bitoffset = 0;   /* reset each field at offset 0 */\n\n        /* update the total alignment requirement, but skip it if the\n           field is an anonymous bitfield or if SF_PACKED */\n        falignorg = get_alignment(ftype);\n        if (falignorg < 0)\n            goto error;\n        falign = (pack < falignorg) ? pack : falignorg;\n\n        do_align = 1;\n        if (!(sflags & SF_GCC_ARM_BITFIELDS) && fbitsize >= 0) {\n            if (!(sflags & SF_MSVC_BITFIELDS)) {\n                /* GCC: anonymous bitfields (of any size) don't cause alignment */\n                do_align = PyText_GetSize(fname) > 0;\n            }\n            else {\n                /* MSVC: zero-sized bitfields don't cause alignment */\n                do_align = fbitsize > 0;\n            }\n        }\n        if (alignment < falign && do_align)\n            alignment = falign;\n\n        fflags = (is_union && i > 0) ? BF_IGNORE_IN_CTOR : 0;\n\n        if (fbitsize < 0) {\n            /* not a bitfield: common case */\n            int bs_flag;\n\n            if ((ftype->ct_flags & CT_ARRAY) && ftype->ct_length <= 0)\n                bs_flag = BS_EMPTY_ARRAY;\n            else\n                bs_flag = BS_REGULAR;\n\n            /* align this field to its own 'falign' by inserting padding */\n\n            /* first, pad to the next byte,\n             * then pad to 'falign' or 'falignorg' bytes */\n            byteoffset = ROUNDUP_BYTES(byteoffset, bitoffset);\n            bitoffset = 0;\n            byteoffsetorg = (byteoffset + falignorg-1) & ~(falignorg-1);\n            byteoffset = (byteoffset + falign-1) & ~(falign-1);\n\n            if (byteoffsetorg != byteoffset) {\n                ct->ct_flags |= CT_WITH_PACKED_CHANGE;\n            }\n\n            if (foffset >= 0) {\n                /* a forced field position: ignore the offset just computed,\n                   except to know if we must set CT_CUSTOM_FIELD_POS */\n                if (detect_custom_layout(ct, sflags, byteoffset, foffset,\n                                         \"wrong offset for field '\",\n                                         PyText_AS_UTF8(fname), \"'\") < 0)\n                    goto error;\n                byteoffset = foffset;\n            }\n\n            if (PyText_GetSize(fname) == 0 &&\n                    ftype->ct_flags & (CT_STRUCT|CT_UNION)) {\n                /* a nested anonymous struct or union */\n                CFieldObject *cfsrc = (CFieldObject *)ftype->ct_extra;\n                for (; cfsrc != NULL; cfsrc = cfsrc->cf_next) {\n                    /* broken complexity in the call to get_field_name(),\n                       but we'll assume you never do that with nested\n                       anonymous structures with thousand of fields */\n                    *previous = _add_field(interned_fields,\n                                           get_field_name(ftype, cfsrc),\n                                           cfsrc->cf_type,\n                                           byteoffset + cfsrc->cf_offset,\n                                           cfsrc->cf_bitshift,\n                                           cfsrc->cf_bitsize,\n                                           cfsrc->cf_flags | fflags);\n                    if (*previous == NULL)\n                        goto error;\n                    previous = &(*previous)->cf_next;\n                }\n                /* always forbid such structures from being passed by value */\n                ct->ct_flags |= CT_CUSTOM_FIELD_POS;\n            }\n            else {\n                *previous = _add_field(interned_fields, fname, ftype,\n                                       byteoffset, bs_flag, -1, fflags);\n                if (*previous == NULL)\n                    goto error;\n                previous = &(*previous)->cf_next;\n            }\n            if (ftype->ct_size >= 0)\n                byteoffset += ftype->ct_size;\n            prev_bitfield_size = 0;\n        }\n        else {\n            /* this is the case of a bitfield */\n            Py_ssize_t field_offset_bytes;\n            int bits_already_occupied, bitshift;\n\n            if (foffset >= 0) {\n                PyErr_Format(PyExc_TypeError,\n                             \"field '%s.%s' is a bitfield, \"\n                             \"but a fixed offset is specified\",\n                             ct->ct_name, PyText_AS_UTF8(fname));\n                goto error;\n            }\n\n            if (!(ftype->ct_flags & (CT_PRIMITIVE_SIGNED |\n                                     CT_PRIMITIVE_UNSIGNED |\n                                     CT_PRIMITIVE_CHAR))) {\n                PyErr_Format(PyExc_TypeError,\n                        \"field '%s.%s' declared as '%s' cannot be a bit field\",\n                             ct->ct_name, PyText_AS_UTF8(fname),\n                             ftype->ct_name);\n                goto error;\n            }\n            if (fbitsize > 8 * ftype->ct_size) {\n                PyErr_Format(PyExc_TypeError,\n                             \"bit field '%s.%s' is declared '%s:%d', which \"\n                             \"exceeds the width of the type\",\n                             ct->ct_name, PyText_AS_UTF8(fname),\n                             ftype->ct_name, fbitsize);\n                goto error;\n            }\n\n            /* compute the starting position of the theoretical field\n               that covers a complete 'ftype', inside of which we will\n               locate the real bitfield */\n            field_offset_bytes = byteoffset;\n            field_offset_bytes &= ~(falign - 1);\n\n            if (fbitsize == 0) {\n                if (PyText_GetSize(fname) > 0) {\n                    PyErr_Format(PyExc_TypeError,\n                                 \"field '%s.%s' is declared with :0\",\n                                 ct->ct_name, PyText_AS_UTF8(fname));\n                    goto error;\n                }\n                if (!(sflags & SF_MSVC_BITFIELDS)) {\n                    /* GCC's notion of \"ftype :0;\" */\n\n                    /* pad byteoffset to a value aligned for \"ftype\" */\n                    if (ROUNDUP_BYTES(byteoffset, bitoffset) > field_offset_bytes) {\n                        field_offset_bytes += falign;\n                        assert(byteoffset < field_offset_bytes);\n                    }\n                    byteoffset = field_offset_bytes;\n                    bitoffset = 0;\n                }\n                else {\n                    /* MSVC's notion of \"ftype :0;\" */\n\n                    /* Mostly ignored.  It seems they only serve as\n                       separator between other bitfields, to force them\n                       into separate words. */\n                }\n                prev_bitfield_size = 0;\n            }\n            else {\n                if (!(sflags & SF_MSVC_BITFIELDS)) {\n                    /* GCC's algorithm */\n\n                    /* Can the field start at the offset given by 'boffset'?  It\n                       can if it would entirely fit into an aligned ftype field. */\n                    bits_already_occupied = (byteoffset-field_offset_bytes) * 8\n                        + bitoffset;\n\n                    if (bits_already_occupied + fbitsize > 8 * ftype->ct_size) {\n                        /* it would not fit, we need to start at the next\n                           allowed position */\n                        if ((sflags & SF_PACKED) &&\n                            (bits_already_occupied & 7)) {\n                            PyErr_Format(PyExc_NotImplementedError,\n                                \"with 'packed', gcc would compile field \"\n                                \"'%s.%s' to reuse some bits in the previous \"\n                                \"field\", ct->ct_name, PyText_AS_UTF8(fname));\n                            goto error;\n                        }\n                        field_offset_bytes += falign;\n                        assert(byteoffset < field_offset_bytes);\n                        byteoffset = field_offset_bytes;\n                        bitoffset = 0;\n                        bitshift = 0;\n                    }\n                    else {\n                        bitshift = bits_already_occupied;\n                        assert(bitshift >= 0);\n                    }\n                    bitoffset += fbitsize;\n                    byteoffset += (bitoffset >> 3);\n                    bitoffset &= 7;\n                }\n                else {\n                    /* MSVC's algorithm */\n\n                    /* A bitfield is considered as taking the full width\n                       of their declared type.  It can share some bits\n                       with the previous field only if it was also a\n                       bitfield and used a type of the same size. */\n                    if (prev_bitfield_size == ftype->ct_size &&\n                        prev_bitfield_free >= fbitsize) {\n                        /* yes: reuse */\n                        bitshift = 8 * prev_bitfield_size - prev_bitfield_free;\n                    }\n                    else {\n                        /* no: start a new full field */\n                        byteoffset = ROUNDUP_BYTES(byteoffset, bitoffset);\n                        bitoffset = 0;\n                        /* align */\n                        byteoffset = (byteoffset + falign-1) & ~(falign-1);\n                        byteoffset += ftype->ct_size;\n                        bitshift = 0;\n                        prev_bitfield_size = ftype->ct_size;\n                        prev_bitfield_free = 8 * prev_bitfield_size;\n                    }\n                    prev_bitfield_free -= fbitsize;\n                    field_offset_bytes = byteoffset - ftype->ct_size;\n                }\n                if (sflags & SF_GCC_BIG_ENDIAN)\n                    bitshift = 8 * ftype->ct_size - fbitsize - bitshift;\n\n                if (PyText_GetSize(fname) > 0) {\n\n                    *previous = _add_field(interned_fields, fname, ftype,\n                                       field_offset_bytes, bitshift, fbitsize,\n                                       fflags);\n                    if (*previous == NULL)\n                        goto error;\n                    previous = &(*previous)->cf_next;\n                }\n            }\n        }\n\n        assert(bitoffset == (bitoffset & 7));\n        if (ROUNDUP_BYTES(byteoffset, bitoffset) > byteoffsetmax)\n            byteoffsetmax = ROUNDUP_BYTES(byteoffset, bitoffset);\n    }\n    *previous = NULL;\n\n    /* Like C, if the size of this structure would be zero, we compute it\n       as 1 instead.  But for ctypes support, we allow the manually-\n       specified totalsize to be zero in this case. */\n    alignedsize = (byteoffsetmax + alignment - 1) & ~(alignment-1);\n    if (alignedsize == 0)\n        alignedsize = 1;\n\n    if (totalsize < 0) {\n        totalsize = alignedsize;\n    }\n    else {\n        if (detect_custom_layout(ct, sflags, alignedsize,\n                                 totalsize, \"wrong total size\", \"\", \"\") < 0)\n            goto error;\n        if (totalsize < byteoffsetmax) {\n            PyErr_Format(PyExc_TypeError,\n                         \"%s cannot be of size %zd: there are fields at least \"\n                         \"up to %zd\", ct->ct_name, totalsize, byteoffsetmax);\n            goto error;\n        }\n    }\n    if (totalalignment < 0) {\n        totalalignment = alignment;\n    }\n    else {\n        if (detect_custom_layout(ct, sflags, alignment, totalalignment,\n                                 \"wrong total alignment\", \"\", \"\") < 0)\n            goto error;\n    }\n\n    ct->ct_size = totalsize;\n    ct->ct_length = totalalignment;\n    ct->ct_stuff = interned_fields;\n    ct->ct_flags &= ~CT_IS_OPAQUE;\n\n    Py_INCREF(Py_None);\n    return Py_None;\n\n error:\n    ct->ct_extra = NULL;\n    Py_DECREF(interned_fields);\n    return NULL;\n}\n\nstruct funcbuilder_s {\n    Py_ssize_t nb_bytes;\n    char *bufferp;\n    ffi_type **atypes;\n    ffi_type *rtype;\n    Py_ssize_t nargs;\n    CTypeDescrObject *fct;\n};\n\nstatic void *fb_alloc(struct funcbuilder_s *fb, Py_ssize_t size)\n{\n    if (fb->bufferp == NULL) {\n        fb->nb_bytes += size;\n        return NULL;\n    }\n    else {\n        char *result = fb->bufferp;\n        fb->bufferp += size;\n        return result;\n    }\n}\n\n#define SUPPORTED_IN_API_MODE                                            \\\n        \" are only supported as %s if the function is \"                  \\\n        \"'API mode' and non-variadic (i.e. declared inside ffibuilder\"   \\\n        \".cdef()+ffibuilder.set_source() and not taking a final '...' \"  \\\n        \"argument)\"\n\nstatic ffi_type *fb_unsupported(CTypeDescrObject *ct, const char *place,\n                                const char *detail)\n{\n    PyErr_Format(PyExc_NotImplementedError,\n        \"ctype '%s' not supported as %s.  %s.  \"\n        \"Such structs\" SUPPORTED_IN_API_MODE,\n        ct->ct_name, place, detail, place);\n    return NULL;\n}\n\nstatic ffi_type *fb_fill_type(struct funcbuilder_s *fb, CTypeDescrObject *ct,\n                              int is_result_type)\n{\n    const char *place = is_result_type ? \"return value\" : \"argument\";\n\n    if (ct->ct_flags & (CT_PRIMITIVE_ANY & ~CT_PRIMITIVE_COMPLEX)) {\n        return (ffi_type *)ct->ct_extra;\n    }\n    else if (ct->ct_flags & (CT_POINTER|CT_FUNCTIONPTR)) {\n        return &ffi_type_pointer;\n    }\n    else if ((ct->ct_flags & CT_VOID) && is_result_type) {\n        return &ffi_type_void;\n    }\n\n    if (ct->ct_size <= 0) {\n        PyErr_Format(PyExc_TypeError,\n                     ct->ct_size < 0 ? \"ctype '%s' has incomplete type\"\n                                     : \"ctype '%s' has size 0\",\n                     ct->ct_name);\n        return NULL;\n    }\n    if (ct->ct_flags & CT_STRUCT) {\n        ffi_type *ffistruct, *ffifield;\n        ffi_type **elements;\n        Py_ssize_t i, n, nflat;\n        CFieldObject *cf;\n\n        /* We can't pass a struct that was completed by verify().\n           Issue: assume verify() is given \"struct { long b; ...; }\".\n           Then it will complete it in the same way whether it is actually\n           \"struct { long a, b; }\" or \"struct { double a; long b; }\".\n           But on 64-bit UNIX, these two structs are passed by value\n           differently: e.g. on x86-64, \"b\" ends up in register \"rsi\" in\n           the first case and \"rdi\" in the second case.\n\n           Another reason for CT_CUSTOM_FIELD_POS would be anonymous\n           nested structures: we lost the information about having it\n           here, so better safe (and forbid it) than sorry (and maybe\n           crash).  Note: it seems we only get in this case with\n           ffi.verify().\n        */\n        if (force_lazy_struct(ct) < 0)\n            return NULL;\n        if (ct->ct_flags & CT_CUSTOM_FIELD_POS) {\n            /* these NotImplementedErrors may be caught and ignored until\n               a real call is made to a function of this type */\n            return fb_unsupported(ct, place,\n                \"It is a struct declared with \\\"...;\\\", but the C \"\n                \"calling convention may depend on the missing fields; \"\n                \"or, it contains anonymous struct/unions\");\n        }\n        /* Another reason: __attribute__((packed)) is not supported by libffi.\n        */\n        if (ct->ct_flags & CT_WITH_PACKED_CHANGE) {\n            return fb_unsupported(ct, place,\n                \"It is a 'packed' structure, with a different layout than \"\n                \"expected by libffi\");\n        }\n\n        n = PyDict_Size(ct->ct_stuff);\n        nflat = 0;\n\n        /* walk the fields, expanding arrays into repetitions; first,\n           only count how many flattened fields there are */\n        cf = (CFieldObject *)ct->ct_extra;\n        for (i=0; i<n; i++) {\n            Py_ssize_t flat;\n            CTypeDescrObject *ct1;\n            assert(cf != NULL);\n            if (cf->cf_bitshift >= 0) {\n                return fb_unsupported(ct, place,\n                    \"It is a struct with bit fields, which libffi does not \"\n                    \"support\");\n            }\n            flat = 1;\n            ct1 = cf->cf_type;\n            while (ct1->ct_flags & CT_ARRAY) {\n                flat *= ct1->ct_length;\n                ct1 = ct1->ct_itemdescr;\n            }\n            if (flat <= 0) {\n                return fb_unsupported(ct, place,\n                    \"It is a struct with a zero-length array, which libffi \"\n                    \"does not support\");\n            }\n            nflat += flat;\n            cf = cf->cf_next;\n        }\n        assert(cf == NULL);\n\n        /* next, allocate and fill the flattened list */\n        elements = fb_alloc(fb, (nflat + 1) * sizeof(ffi_type*));\n        nflat = 0;\n        cf = (CFieldObject *)ct->ct_extra;\n        for (i=0; i<n; i++) {\n            Py_ssize_t j, flat = 1;\n            CTypeDescrObject *ct = cf->cf_type;\n            while (ct->ct_flags & CT_ARRAY) {\n                flat *= ct->ct_length;\n                ct = ct->ct_itemdescr;\n            }\n            ffifield = fb_fill_type(fb, ct, 0);\n            if (PyErr_Occurred())\n                return NULL;\n            if (elements != NULL) {\n                for (j=0; j<flat; j++)\n                    elements[nflat++] = ffifield;\n            }\n            cf = cf->cf_next;\n        }\n\n        /* finally, allocate the FFI_TYPE_STRUCT */\n        ffistruct = fb_alloc(fb, sizeof(ffi_type));\n        if (ffistruct != NULL) {\n            elements[nflat] = NULL;\n            ffistruct->size = ct->ct_size;\n            ffistruct->alignment = ct->ct_length;\n            ffistruct->type = FFI_TYPE_STRUCT;\n            ffistruct->elements = elements;\n        }\n        return ffistruct;\n    }\n    else if (ct->ct_flags & CT_UNION) {\n        PyErr_Format(PyExc_NotImplementedError,\n                     \"ctype '%s' not supported as %s by libffi.  \"\n                     \"Unions\" SUPPORTED_IN_API_MODE,\n                     ct->ct_name, place, place);\n        return NULL;\n    }\n    else {\n        char *extra = \"\";\n        if (ct->ct_flags & CT_PRIMITIVE_COMPLEX)\n            extra = \" (the support for complex types inside libffi \"\n                    \"is mostly missing at this point, so CFFI only \"\n                    \"supports complex types as arguments or return \"\n                    \"value in API-mode functions)\";\n\n        PyErr_Format(PyExc_NotImplementedError,\n                     \"ctype '%s' (size %zd) not supported as %s%s\",\n                     ct->ct_name, ct->ct_size, place, extra);\n        return NULL;\n    }\n}\n\n#define ALIGN_ARG(n)  ((n) + 7) & ~7\n\nstatic int fb_build(struct funcbuilder_s *fb, PyObject *fargs,\n                    CTypeDescrObject *fresult)\n{\n    Py_ssize_t i, nargs = PyTuple_GET_SIZE(fargs);\n    Py_ssize_t exchange_offset;\n    cif_description_t *cif_descr;\n\n    /* ffi buffer: start with a cif_description */\n    cif_descr = fb_alloc(fb, sizeof(cif_description_t) +\n                             nargs * sizeof(Py_ssize_t));\n\n    /* ffi buffer: next comes an array of 'ffi_type*', one per argument */\n    fb->atypes = fb_alloc(fb, nargs * sizeof(ffi_type*));\n    fb->nargs = nargs;\n\n    /* ffi buffer: next comes the result type */\n    fb->rtype = fb_fill_type(fb, fresult, 1);\n    if (PyErr_Occurred())\n        return -1;\n    if (cif_descr != NULL) {\n        /* exchange data size */\n        /* first, enough room for an array of 'nargs' pointers */\n        exchange_offset = nargs * sizeof(void*);\n        exchange_offset = ALIGN_ARG(exchange_offset);\n        cif_descr->exchange_offset_arg[0] = exchange_offset;\n        /* then enough room for the result --- which means at least\n           sizeof(ffi_arg), according to the ffi docs */\n        i = fb->rtype->size;\n        if (i < (Py_ssize_t)sizeof(ffi_arg))\n            i = sizeof(ffi_arg);\n        exchange_offset += i;\n    }\n    else\n        exchange_offset = 0;   /* not used */\n\n    /* loop over the arguments */\n    for (i=0; i<nargs; i++) {\n        CTypeDescrObject *farg;\n        ffi_type *atype;\n\n        farg = (CTypeDescrObject *)PyTuple_GET_ITEM(fargs, i);\n        /* convert arrays to pointers */\n        if (farg->ct_flags & CT_ARRAY)\n            farg = (CTypeDescrObject *)farg->ct_stuff;\n\n        /* ffi buffer: fill in the ffi for the i'th argument */\n        assert(farg != NULL);\n        atype = fb_fill_type(fb, farg, 0);\n        if (PyErr_Occurred())\n            return -1;\n\n        if (fb->atypes != NULL) {\n            fb->atypes[i] = atype;\n            /* exchange data size */\n            exchange_offset = ALIGN_ARG(exchange_offset);\n            cif_descr->exchange_offset_arg[1 + i] = exchange_offset;\n            exchange_offset += atype->size;\n        }\n    }\n\n    if (cif_descr != NULL) {\n        /* exchange data size */\n        /* we also align it to the next multiple of 8, in an attempt to\n           work around bugs(?) of libffi like #241 */\n        cif_descr->exchange_size = ALIGN_ARG(exchange_offset);\n    }\n    return 0;\n}\n\n#undef ALIGN_ARG\n\nstatic void fb_cat_name(struct funcbuilder_s *fb, const char *piece,\n                        int piecelen)\n{\n    if (fb->bufferp == NULL) {\n        fb->nb_bytes += piecelen;\n    }\n    else {\n        memcpy(fb->bufferp, piece, piecelen);\n        fb->bufferp += piecelen;\n    }\n}\n\nstatic int fb_build_name(struct funcbuilder_s *fb, const char *repl,\n                         CTypeDescrObject **pfargs, Py_ssize_t nargs,\n                         CTypeDescrObject *fresult, int ellipsis)\n{\n    Py_ssize_t i;\n    fb->nargs = nargs;\n\n    /* name: the function type name we build here is, like in C, made\n       as follows:\n\n         RESULT_TYPE_HEAD (*)(ARG_1_TYPE, ARG_2_TYPE, etc) RESULT_TYPE_TAIL\n    */\n    fb_cat_name(fb, fresult->ct_name, fresult->ct_name_position);\n    if (repl[0] != '(' &&\n        fresult->ct_name[fresult->ct_name_position - 1] != '*')\n        fb_cat_name(fb, \" \", 1);   /* add a space */\n    fb_cat_name(fb, repl, strlen(repl));\n    if (fb->fct) {\n        i = strlen(repl) - 1;      /* between '(*' and ')' */\n        assert(repl[i] == ')');\n        fb->fct->ct_name_position = fresult->ct_name_position + i;\n    }\n    fb_cat_name(fb, \"(\", 1);\n\n    /* loop over the arguments */\n    for (i=0; i<nargs; i++) {\n        CTypeDescrObject *farg;\n\n        farg = pfargs[i];\n        if (!CTypeDescr_Check(farg)) {\n            PyErr_SetString(PyExc_TypeError, \"expected a tuple of ctypes\");\n            return -1;\n        }\n        /* name: concatenate the name of the i'th argument's type */\n        if (i > 0)\n            fb_cat_name(fb, \", \", 2);\n        fb_cat_name(fb, farg->ct_name, strlen(farg->ct_name));\n    }\n\n    /* name: add the '...' if needed */\n    if (ellipsis) {\n        if (nargs > 0)\n            fb_cat_name(fb, \", \", 2);\n        fb_cat_name(fb, \"...\", 3);\n    }\n\n    /* name: concatenate the tail of the result type */\n    fb_cat_name(fb, \")\", 1);\n    fb_cat_name(fb, fresult->ct_name + fresult->ct_name_position,\n                strlen(fresult->ct_name) - fresult->ct_name_position + 1);\n    return 0;\n}\n\nstatic CTypeDescrObject *fb_prepare_ctype(struct funcbuilder_s *fb,\n                                          PyObject *fargs,\n                                          CTypeDescrObject *fresult,\n                                          int ellipsis, int fabi)\n{\n    CTypeDescrObject *fct, **pfargs;\n    Py_ssize_t nargs;\n    char *repl = \"(*)\";\n\n    fb->nb_bytes = 0;\n    fb->bufferp = NULL;\n    fb->fct = NULL;\n\n    pfargs = (CTypeDescrObject **)&PyTuple_GET_ITEM(fargs, 0);\n    nargs = PyTuple_GET_SIZE(fargs);\n#if defined(MS_WIN32) && !defined(_WIN64)\n    if (fabi == FFI_STDCALL)\n        repl = \"(__stdcall *)\";\n#endif\n\n    /* compute the total size needed for the name */\n    if (fb_build_name(fb, repl, pfargs, nargs, fresult, ellipsis) < 0)\n        return NULL;\n\n    /* allocate the function type */\n    fct = ctypedescr_new(fb->nb_bytes);\n    if (fct == NULL)\n        return NULL;\n    fb->fct = fct;\n\n    /* call again fb_build_name() to really build the ct_name */\n    fb->bufferp = fct->ct_name;\n    if (fb_build_name(fb, repl, pfargs, nargs, fresult, ellipsis) < 0)\n        goto error;\n    assert(fb->bufferp == fct->ct_name + fb->nb_bytes);\n\n    fct->ct_extra = NULL;\n    fct->ct_size = sizeof(void(*)(void));\n    fct->ct_flags = CT_FUNCTIONPTR;\n    return fct;\n\n error:\n    Py_DECREF(fct);\n    return NULL;\n}\n\nstatic cif_description_t *fb_prepare_cif(PyObject *fargs,\n                                         CTypeDescrObject *fresult,\n                                         ffi_abi fabi)\n{\n    char *buffer;\n    cif_description_t *cif_descr;\n    struct funcbuilder_s funcbuffer;\n\n    funcbuffer.nb_bytes = 0;\n    funcbuffer.bufferp = NULL;\n\n    /* compute the total size needed in the buffer for libffi */\n    if (fb_build(&funcbuffer, fargs, fresult) < 0)\n        return NULL;\n\n    /* allocate the buffer */\n    buffer = PyObject_Malloc(funcbuffer.nb_bytes);\n    if (buffer == NULL) {\n        PyErr_NoMemory();\n        return NULL;\n    }\n\n    /* call again fb_build() to really build the libffi data structures */\n    funcbuffer.bufferp = buffer;\n    if (fb_build(&funcbuffer, fargs, fresult) < 0)\n        goto error;\n    assert(funcbuffer.bufferp == buffer + funcbuffer.nb_bytes);\n\n    cif_descr = (cif_description_t *)buffer;\n    if (ffi_prep_cif(&cif_descr->cif, fabi, funcbuffer.nargs,\n                     funcbuffer.rtype, funcbuffer.atypes) != FFI_OK) {\n        PyErr_SetString(PyExc_SystemError,\n                        \"libffi failed to build this function type\");\n        goto error;\n    }\n    return cif_descr;\n\n error:\n    PyObject_Free(buffer);\n    return NULL;\n}\n\nstatic PyObject *new_function_type(PyObject *fargs,   /* tuple */\n                                   CTypeDescrObject *fresult,\n                                   int ellipsis, int fabi)\n{\n    PyObject *fabiobj;\n    CTypeDescrObject *fct;\n    struct funcbuilder_s funcbuilder;\n    Py_ssize_t i;\n    const void **unique_key;\n\n    if ((fresult->ct_size < 0 && !(fresult->ct_flags & CT_VOID)) ||\n        (fresult->ct_flags & CT_ARRAY)) {\n        char *msg;\n        if (fresult->ct_flags & CT_IS_OPAQUE)\n            msg = \"result type '%s' is opaque\";\n        else\n            msg = \"invalid result type: '%s'\";\n        PyErr_Format(PyExc_TypeError, msg, fresult->ct_name);\n        return NULL;\n    }\n\n    fct = fb_prepare_ctype(&funcbuilder, fargs, fresult, ellipsis, fabi);\n    if (fct == NULL)\n        return NULL;\n\n    if (!ellipsis) {\n        /* Functions with '...' varargs are stored without a cif_descr\n           at all.  The cif is computed on every call from the actual\n           types passed in.  For all other functions, the cif_descr\n           is computed here. */\n        cif_description_t *cif_descr;\n\n        cif_descr = fb_prepare_cif(fargs, fresult, fabi);\n        if (cif_descr == NULL) {\n            if (PyErr_ExceptionMatches(PyExc_NotImplementedError)) {\n                PyErr_Clear();   /* will get the exception if we see an\n                                    actual call */\n            }\n            else\n                goto error;\n        }\n\n        fct->ct_extra = (char *)cif_descr;\n    }\n\n    /* build the signature, given by a tuple of ctype objects */\n    fct->ct_stuff = PyTuple_New(2 + funcbuilder.nargs);\n    if (fct->ct_stuff == NULL)\n        goto error;\n    fabiobj = PyInt_FromLong(fabi);\n    if (fabiobj == NULL)\n        goto error;\n    PyTuple_SET_ITEM(fct->ct_stuff, 0, fabiobj);\n\n    Py_INCREF(fresult);\n    PyTuple_SET_ITEM(fct->ct_stuff, 1, (PyObject *)fresult);\n    for (i=0; i<funcbuilder.nargs; i++) {\n        PyObject *o = PyTuple_GET_ITEM(fargs, i);\n        /* convert arrays into pointers */\n        if (((CTypeDescrObject *)o)->ct_flags & CT_ARRAY)\n            o = ((CTypeDescrObject *)o)->ct_stuff;\n        Py_INCREF(o);\n        PyTuple_SET_ITEM(fct->ct_stuff, 2 + i, o);\n    }\n\n    /* [ctresult, ellipsis+abi, num_args, ctargs...] */\n    unique_key = alloca((3 + funcbuilder.nargs) * sizeof(void *));\n    unique_key[0] = fresult;\n    unique_key[1] = (const void *)(Py_ssize_t)((fabi << 1) | !!ellipsis);\n    unique_key[2] = (const void *)(Py_ssize_t)(funcbuilder.nargs);\n    for (i=0; i<funcbuilder.nargs; i++)\n        unique_key[3 + i] = PyTuple_GET_ITEM(fct->ct_stuff, 2 + i);\n    return get_unique_type(fct, unique_key, 3 + funcbuilder.nargs);\n\n error:\n    Py_DECREF(fct);\n    return NULL;\n}\n\nstatic PyObject *b_new_function_type(PyObject *self, PyObject *args)\n{\n    PyObject *fargs;\n    CTypeDescrObject *fresult;\n    int ellipsis = 0, fabi = FFI_DEFAULT_ABI;\n\n    if (!PyArg_ParseTuple(args, \"O!O!|ii:new_function_type\",\n                          &PyTuple_Type, &fargs,\n                          &CTypeDescr_Type, &fresult,\n                          &ellipsis,\n                          &fabi))\n        return NULL;\n\n    return new_function_type(fargs, fresult, ellipsis, fabi);\n}\n\nstatic int convert_from_object_fficallback(char *result,\n                                           CTypeDescrObject *ctype,\n                                           PyObject *pyobj,\n                                           int encode_result_for_libffi)\n{\n    /* work work work around a libffi irregularity: for integer return\n       types we have to fill at least a complete 'ffi_arg'-sized result\n       buffer. */\n    if (ctype->ct_size < (Py_ssize_t)sizeof(ffi_arg)) {\n        if (ctype->ct_flags & CT_VOID) {\n            if (pyobj == Py_None) {\n                return 0;\n            }\n            else {\n                PyErr_SetString(PyExc_TypeError,\n                    \"callback with the return type 'void' must return None\");\n                return -1;\n            }\n        }\n        if (!encode_result_for_libffi)\n            goto skip;\n        if (ctype->ct_flags & CT_PRIMITIVE_SIGNED) {\n            PY_LONG_LONG value;\n            /* It's probably fine to always zero-extend, but you never\n               know: maybe some code somewhere expects a negative\n               'short' result to be returned into EAX as a 32-bit\n               negative number.  Better safe than sorry.  This code\n               is about that case.  Let's ignore this for enums.\n            */\n            /* do a first conversion only to detect overflows.  This\n               conversion produces stuff that is otherwise ignored. */\n            if (convert_from_object(result, ctype, pyobj) < 0)\n                return -1;\n            /* manual inlining and tweaking of convert_from_object()\n               in order to write a whole 'ffi_arg'. */\n            value = _my_PyLong_AsLongLong(pyobj);\n            if (value == -1 && PyErr_Occurred())\n                return -1;\n            write_raw_integer_data(result, value, sizeof(ffi_arg));\n            return 0;\n        }\n        else if (ctype->ct_flags & (CT_PRIMITIVE_CHAR | CT_PRIMITIVE_SIGNED |\n                                    CT_PRIMITIVE_UNSIGNED |\n                                    CT_POINTER | CT_FUNCTIONPTR)) {\n            /* zero extension: fill the '*result' with zeros, and (on big-\n               endian machines) correct the 'result' pointer to write to.\n               We also do that for pointers, even though we're normally not\n               in this branch because ctype->ct_size == sizeof(ffi_arg) for\n               pointers---except on some architectures like x32 (issue #372).\n             */\n            memset(result, 0, sizeof(ffi_arg));\n#ifdef WORDS_BIGENDIAN\n            result += (sizeof(ffi_arg) - ctype->ct_size);\n#endif\n        }\n    }\n skip:\n    return convert_from_object(result, ctype, pyobj);\n}\n\nstatic void _my_PyErr_WriteUnraisable(PyObject *t, PyObject *v, PyObject *tb,\n                                      char *objdescr, PyObject *obj,\n                                      char *extra_error_line)\n{\n    /* like PyErr_WriteUnraisable(), but write a full traceback */\n    PyObject *f;\n#if PY_MAJOR_VERSION >= 3\n    /* jump through hoops to ensure the tb is attached to v, on Python 3 */\n    PyErr_NormalizeException(&t, &v, &tb);\n    if (tb == NULL) {\n        tb = Py_None;\n        Py_INCREF(tb);\n    }\n    PyException_SetTraceback(v, tb);\n#endif\n    f = PySys_GetObject(\"stderr\");\n    if (f != NULL) {\n        if (obj != NULL) {\n            PyFile_WriteString(objdescr, f);\n            PyFile_WriteObject(obj, f, 0);\n            PyFile_WriteString(\":\\n\", f);\n        }\n        if (extra_error_line != NULL)\n            PyFile_WriteString(extra_error_line, f);\n        PyErr_Display(t, v, tb);\n    }\n    Py_XDECREF(t);\n    Py_XDECREF(v);\n    Py_XDECREF(tb);\n}\n\nstatic void general_invoke_callback(int decode_args_from_libffi,\n                                    void *result, char *args, void *userdata)\n{\n    PyObject *cb_args = (PyObject *)userdata;\n    CTypeDescrObject *ct = (CTypeDescrObject *)PyTuple_GET_ITEM(cb_args, 0);\n    PyObject *signature = ct->ct_stuff;\n    PyObject *py_ob = PyTuple_GET_ITEM(cb_args, 1);\n    PyObject *py_args = NULL;\n    PyObject *py_res = NULL;\n    PyObject *py_rawerr;\n    PyObject *onerror_cb;\n    Py_ssize_t i, n;\n    char *extra_error_line = NULL;\n\n#define SIGNATURE(i)  ((CTypeDescrObject *)PyTuple_GET_ITEM(signature, i))\n\n    Py_INCREF(cb_args);\n\n    n = PyTuple_GET_SIZE(signature) - 2;\n    py_args = PyTuple_New(n);\n    if (py_args == NULL)\n        goto error;\n\n    for (i=0; i<n; i++) {\n        char *a_src;\n        PyObject *a;\n        CTypeDescrObject *a_ct = SIGNATURE(2 + i);\n\n        if (decode_args_from_libffi) {\n            a_src = ((void **)args)[i];\n        }\n        else {\n            a_src = args + i * 8;\n            if (a_ct->ct_flags & (CT_IS_LONGDOUBLE | CT_STRUCT | CT_UNION))\n                a_src = *(char **)a_src;\n        }\n        a = convert_to_object(a_src, a_ct);\n        if (a == NULL)\n            goto error;\n        PyTuple_SET_ITEM(py_args, i, a);\n    }\n\n    py_res = PyObject_Call(py_ob, py_args, NULL);\n    if (py_res == NULL)\n        goto error;\n    if (convert_from_object_fficallback(result, SIGNATURE(1), py_res,\n                                        decode_args_from_libffi) < 0) {\n        extra_error_line = \"Trying to convert the result back to C:\\n\";\n        goto error;\n    }\n done:\n    Py_XDECREF(py_args);\n    Py_XDECREF(py_res);\n    Py_DECREF(cb_args);\n    return;\n\n error:\n    if (SIGNATURE(1)->ct_size > 0) {\n        py_rawerr = PyTuple_GET_ITEM(cb_args, 2);\n        memcpy(result, PyBytes_AS_STRING(py_rawerr),\n                       PyBytes_GET_SIZE(py_rawerr));\n    }\n    onerror_cb = PyTuple_GET_ITEM(cb_args, 3);\n    if (onerror_cb == Py_None) {\n        PyObject *ecap, *t, *v, *tb;\n        PyErr_Fetch(&t, &v, &tb);\n        ecap = _cffi_start_error_capture();\n        _my_PyErr_WriteUnraisable(t, v, tb, \"From cffi callback \", py_ob,\n                                  extra_error_line);\n        _cffi_stop_error_capture(ecap);\n    }\n    else {\n        PyObject *exc1, *val1, *tb1, *res1, *exc2, *val2, *tb2;\n        PyErr_Fetch(&exc1, &val1, &tb1);\n        PyErr_NormalizeException(&exc1, &val1, &tb1);\n        res1 = PyObject_CallFunctionObjArgs(onerror_cb,\n                                            exc1 ? exc1 : Py_None,\n                                            val1 ? val1 : Py_None,\n                                            tb1  ? tb1  : Py_None,\n                                            NULL);\n        if (res1 != NULL) {\n            if (res1 != Py_None)\n                convert_from_object_fficallback(result, SIGNATURE(1), res1,\n                                                decode_args_from_libffi);\n            Py_DECREF(res1);\n        }\n        if (!PyErr_Occurred()) {\n            Py_XDECREF(exc1);\n            Py_XDECREF(val1);\n            Py_XDECREF(tb1);\n        }\n        else {\n            /* double exception! print a double-traceback... */\n            PyObject *ecap;\n            PyErr_Fetch(&exc2, &val2, &tb2);\n            ecap = _cffi_start_error_capture();\n            _my_PyErr_WriteUnraisable(exc1, val1, tb1,\n                                      \"From cffi callback \", py_ob,\n                                      extra_error_line);\n            extra_error_line = (\"\\nDuring the call to 'onerror', \"\n                                \"another exception occurred:\\n\\n\");\n            _my_PyErr_WriteUnraisable(exc2, val2, tb2,\n                                      NULL, NULL, extra_error_line);\n            _cffi_stop_error_capture(ecap);\n        }\n    }\n    goto done;\n\n#undef SIGNATURE\n}\n\nstatic void invoke_callback(ffi_cif *cif, void *result, void **args,\n                            void *userdata)\n{\n    save_errno();\n    {\n        PyGILState_STATE state = gil_ensure();\n        general_invoke_callback(1, result, (char *)args, userdata);\n        gil_release(state);\n    }\n    restore_errno();\n}\n\nstatic PyObject *prepare_callback_info_tuple(CTypeDescrObject *ct,\n                                             PyObject *ob,\n                                             PyObject *error_ob,\n                                             PyObject *onerror_ob,\n                                             int decode_args_from_libffi)\n{\n    CTypeDescrObject *ctresult;\n    PyObject *py_rawerr, *infotuple;\n    Py_ssize_t size;\n\n    if (!(ct->ct_flags & CT_FUNCTIONPTR)) {\n        PyErr_Format(PyExc_TypeError, \"expected a function ctype, got '%s'\",\n                     ct->ct_name);\n        return NULL;\n    }\n    if (!PyCallable_Check(ob)) {\n        PyErr_Format(PyExc_TypeError,\n                     \"expected a callable object, not %.200s\",\n                     Py_TYPE(ob)->tp_name);\n        return NULL;\n    }\n    if (onerror_ob != Py_None && !PyCallable_Check(onerror_ob)) {\n        PyErr_Format(PyExc_TypeError,\n                     \"expected a callable object for 'onerror', not %.200s\",\n                     Py_TYPE(onerror_ob)->tp_name);\n        return NULL;\n    }\n\n    ctresult = (CTypeDescrObject *)PyTuple_GET_ITEM(ct->ct_stuff, 1);\n    size = ctresult->ct_size;\n    if (size < (Py_ssize_t)sizeof(ffi_arg))\n        size = sizeof(ffi_arg);\n    py_rawerr = PyBytes_FromStringAndSize(NULL, size);\n    if (py_rawerr == NULL)\n        return NULL;\n    memset(PyBytes_AS_STRING(py_rawerr), 0, size);\n    if (error_ob != Py_None) {\n        if (convert_from_object_fficallback(\n                PyBytes_AS_STRING(py_rawerr), ctresult, error_ob,\n                decode_args_from_libffi) < 0) {\n            Py_DECREF(py_rawerr);\n            return NULL;\n        }\n    }\n    infotuple = Py_BuildValue(\"OOOO\", ct, ob, py_rawerr, onerror_ob);\n    Py_DECREF(py_rawerr);\n\n#ifdef WITH_THREAD\n    /* We must setup the GIL here, in case the callback is invoked in\n       some other non-Pythonic thread.  This is the same as ctypes. */\n    PyEval_InitThreads();\n#endif\n\n    return infotuple;\n}\n\nstatic PyObject *b_callback(PyObject *self, PyObject *args)\n{\n    CTypeDescrObject *ct;\n    CDataObject_closure *cd;\n    PyObject *ob, *error_ob = Py_None, *onerror_ob = Py_None;\n    PyObject *infotuple;\n    cif_description_t *cif_descr;\n    ffi_closure *closure;\n    void *closure_exec;\n\n    if (!PyArg_ParseTuple(args, \"O!O|OO:callback\", &CTypeDescr_Type, &ct, &ob,\n                          &error_ob, &onerror_ob))\n        return NULL;\n\n    infotuple = prepare_callback_info_tuple(ct, ob, error_ob, onerror_ob, 1);\n    if (infotuple == NULL)\n        return NULL;\n\n#ifdef CFFI_TRUST_LIBFFI\n    closure = ffi_closure_alloc(sizeof(ffi_closure), &closure_exec);\n#else\n    closure = cffi_closure_alloc();\n    closure_exec = closure;\n#endif\n    if (closure == NULL) {\n        Py_DECREF(infotuple);\n        PyErr_SetString(PyExc_MemoryError,\n            \"Cannot allocate write+execute memory for ffi.callback(). \"\n            \"You might be running on a system that prevents this. \"\n            \"For more information, see \"\n            \"https://cffi.readthedocs.io/en/latest/using.html#callbacks\");\n        return NULL;\n    }\n    cd = PyObject_GC_New(CDataObject_closure, &CDataOwningGC_Type);\n    if (cd == NULL)\n        goto error;\n    Py_INCREF(ct);\n    cd->head.c_type = ct;\n    cd->head.c_data = (char *)closure_exec;\n    cd->head.c_weakreflist = NULL;\n    cd->closure = closure;\n    PyObject_GC_Track(cd);\n\n    cif_descr = (cif_description_t *)ct->ct_extra;\n    if (cif_descr == NULL) {\n        PyErr_Format(PyExc_NotImplementedError,\n                     \"%s: callback with unsupported argument or \"\n                     \"return type or with '...'\", ct->ct_name);\n        goto error;\n    }\n#ifdef CFFI_TRUST_LIBFFI\n    if (ffi_prep_closure_loc(closure, &cif_descr->cif,\n                         invoke_callback, infotuple, closure_exec) != FFI_OK) {\n#else\n    if (ffi_prep_closure(closure, &cif_descr->cif,\n                         invoke_callback, infotuple) != FFI_OK) {\n#endif\n        PyErr_SetString(PyExc_SystemError,\n                        \"libffi failed to build this callback\");\n        goto error;\n    }\n    if (closure->user_data != infotuple) {\n        /* Issue #266.  Should not occur, but could, if we are using\n           at runtime a version of libffi compiled with a different\n           'ffi_closure' structure than the one we expect from ffi.h\n           (e.g. difference in details of the platform): a difference\n           in FFI_TRAMPOLINE_SIZE means that the 'user_data' field\n           ends up somewhere else, and so the test above fails.\n        */\n        PyErr_SetString(PyExc_SystemError,\n            \"ffi_prep_closure(): bad user_data (it seems that the \"\n            \"version of the libffi library seen at runtime is \"\n            \"different from the 'ffi.h' file seen at compile-time)\");\n        goto error;\n    }\n    return (PyObject *)cd;\n\n error:\n    closure->user_data = NULL;\n    if (cd == NULL) {\n#ifdef CFFI_TRUST_LIBFFI\n        ffi_closure_free(closure);\n#else\n        cffi_closure_free(closure);\n#endif\n    }\n    else\n        Py_DECREF(cd);\n    Py_XDECREF(infotuple);\n    return NULL;\n}\n\nstatic PyObject *b_new_enum_type(PyObject *self, PyObject *args)\n{\n    char *ename;\n    PyObject *enumerators, *enumvalues;\n    PyObject *dict1 = NULL, *dict2 = NULL, *combined = NULL, *tmpkey = NULL;\n    int name_size;\n    CTypeDescrObject *td, *basetd;\n    Py_ssize_t i, n;\n\n    if (!PyArg_ParseTuple(args, \"sO!O!O!:new_enum_type\",\n                          &ename,\n                          &PyTuple_Type, &enumerators,\n                          &PyTuple_Type, &enumvalues,\n                          &CTypeDescr_Type, &basetd))\n        return NULL;\n\n    n = PyTuple_GET_SIZE(enumerators);\n    if (n != PyTuple_GET_SIZE(enumvalues)) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"tuple args must have the same size\");\n        return NULL;\n    }\n\n    if (!(basetd->ct_flags & (CT_PRIMITIVE_SIGNED|CT_PRIMITIVE_UNSIGNED))) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"expected a primitive signed or unsigned base type\");\n        return NULL;\n    }\n\n    dict1 = PyDict_New();\n    if (dict1 == NULL)\n        goto error;\n    dict2 = PyDict_New();\n    if (dict2 == NULL)\n        goto error;\n\n    for (i=n; --i >= 0; ) {\n        long long lvalue;\n        PyObject *value = PyTuple_GET_ITEM(enumvalues, i);\n        tmpkey = PyTuple_GET_ITEM(enumerators, i);\n        Py_INCREF(tmpkey);\n        if (!PyText_Check(tmpkey)) {\n#if PY_MAJOR_VERSION < 3\n            if (PyUnicode_Check(tmpkey)) {\n                const char *text = PyText_AsUTF8(tmpkey);\n                if (text == NULL)\n                    goto error;\n                Py_DECREF(tmpkey);\n                tmpkey = PyString_FromString(text);\n                if (tmpkey == NULL)\n                    goto error;\n            }\n            else\n#endif\n            {\n                PyErr_SetString(PyExc_TypeError,\n                                \"enumerators must be a list of strings\");\n                goto error;\n            }\n        }\n        if (convert_from_object((char*)&lvalue, basetd, value) < 0)\n            goto error;     /* out-of-range or badly typed 'value' */\n        if (PyDict_SetItem(dict1, tmpkey, value) < 0)\n            goto error;\n        if (PyDict_SetItem(dict2, value, tmpkey) < 0)\n            goto error;\n        Py_DECREF(tmpkey);\n        tmpkey = NULL;\n    }\n\n    combined = PyTuple_Pack(2, dict1, dict2);\n    if (combined == NULL)\n        goto error;\n\n    Py_CLEAR(dict2);\n    Py_CLEAR(dict1);\n\n    name_size = strlen(ename) + 1;\n    td = ctypedescr_new(name_size);\n    if (td == NULL)\n        goto error;\n\n    memcpy(td->ct_name, ename, name_size);\n    td->ct_stuff = combined;\n    td->ct_size = basetd->ct_size;\n    td->ct_length = basetd->ct_length;   /* alignment */\n    td->ct_extra = basetd->ct_extra;     /* ffi type  */\n    td->ct_flags = basetd->ct_flags | CT_IS_ENUM;\n    td->ct_name_position = name_size - 1;\n    return (PyObject *)td;\n\n error:\n    Py_XDECREF(tmpkey);\n    Py_XDECREF(combined);\n    Py_XDECREF(dict2);\n    Py_XDECREF(dict1);\n    return NULL;\n}\n\nstatic PyObject *b_alignof(PyObject *self, PyObject *arg)\n{\n    int align;\n    if (!CTypeDescr_Check(arg)) {\n        PyErr_SetString(PyExc_TypeError, \"expected a 'ctype' object\");\n        return NULL;\n    }\n    align = get_alignment((CTypeDescrObject *)arg);\n    if (align < 0)\n        return NULL;\n    return PyInt_FromLong(align);\n}\n\nstatic Py_ssize_t direct_sizeof_cdata(CDataObject *cd)\n{\n    Py_ssize_t size;\n    if (cd->c_type->ct_flags & CT_ARRAY)\n        size = get_array_length(cd) * cd->c_type->ct_itemdescr->ct_size;\n    else {\n        size = -1;\n        if (cd->c_type->ct_flags & (CT_STRUCT | CT_UNION))\n            size = _cdata_var_byte_size(cd);\n        if (size < 0)\n            size = cd->c_type->ct_size;\n    }\n    return size;\n}\n\nstatic PyObject *b_sizeof(PyObject *self, PyObject *arg)\n{\n    Py_ssize_t size;\n\n    if (CData_Check(arg)) {\n        size = direct_sizeof_cdata((CDataObject *)arg);\n    }\n    else if (CTypeDescr_Check(arg)) {\n        size = ((CTypeDescrObject *)arg)->ct_size;\n        if (size < 0) {\n            PyErr_Format(PyExc_ValueError, \"ctype '%s' is of unknown size\",\n                         ((CTypeDescrObject *)arg)->ct_name);\n            return NULL;\n        }\n    }\n    else {\n        PyErr_SetString(PyExc_TypeError,\n                        \"expected a 'cdata' or 'ctype' object\");\n        return NULL;\n    }\n    return PyInt_FromSsize_t(size);\n}\n\nstatic PyObject *b_typeof(PyObject *self, PyObject *arg)\n{\n    PyObject *res;\n\n    if (!CData_Check(arg)) {\n        PyErr_SetString(PyExc_TypeError, \"expected a 'cdata' object\");\n        return NULL;\n    }\n    res = (PyObject *)((CDataObject *)arg)->c_type;\n    Py_INCREF(res);\n    return res;\n}\n\nstatic CTypeDescrObject *direct_typeoffsetof(CTypeDescrObject *ct,\n                                             PyObject *fieldname,\n                                             int following, Py_ssize_t *offset)\n{\n    /* Does not return a new reference! */\n    CTypeDescrObject *res;\n    CFieldObject *cf;\n\n    if (PyTextAny_Check(fieldname)) {\n        if (!following && (ct->ct_flags & CT_POINTER))\n            ct = ct->ct_itemdescr;\n        if (!(ct->ct_flags & (CT_STRUCT|CT_UNION))) {\n            PyErr_SetString(PyExc_TypeError,\n                            \"with a field name argument, expected a \"\n                            \"struct or union ctype\");\n            return NULL;\n        }\n        if (force_lazy_struct(ct) <= 0) {\n            if (!PyErr_Occurred())\n                PyErr_SetString(PyExc_TypeError, \"struct/union is opaque\");\n            return NULL;\n        }\n        cf = (CFieldObject *)PyDict_GetItem(ct->ct_stuff, fieldname);\n        if (cf == NULL) {\n            PyErr_SetObject(PyExc_KeyError, fieldname);\n            return NULL;\n        }\n        if (cf->cf_bitshift >= 0) {\n            PyErr_SetString(PyExc_TypeError, \"not supported for bitfields\");\n            return NULL;\n        }\n        res = cf->cf_type;\n        *offset = cf->cf_offset;\n    }\n    else {\n        Py_ssize_t index = PyInt_AsSsize_t(fieldname);\n        if (index < 0 && PyErr_Occurred()) {\n            PyErr_SetString(PyExc_TypeError,\n                            \"field name or array index expected\");\n            return NULL;\n        }\n\n        if (!(ct->ct_flags & (CT_ARRAY|CT_POINTER)) ||\n                ct->ct_itemdescr->ct_size < 0) {\n            PyErr_SetString(PyExc_TypeError, \"with an integer argument, \"\n                                             \"expected an array ctype or a \"\n                                             \"pointer to non-opaque\");\n            return NULL;\n        }\n        res = ct->ct_itemdescr;\n        *offset = MUL_WRAPAROUND(index, ct->ct_itemdescr->ct_size);\n        if ((*offset / ct->ct_itemdescr->ct_size) != index) {\n            PyErr_SetString(PyExc_OverflowError,\n                            \"array offset would overflow a Py_ssize_t\");\n            return NULL;\n        }\n    }\n    return res;\n}\n\nstatic PyObject *b_typeoffsetof(PyObject *self, PyObject *args)\n{\n    PyObject *res, *fieldname;\n    CTypeDescrObject *ct;\n    Py_ssize_t offset;\n    int following = 0;\n\n    if (!PyArg_ParseTuple(args, \"O!O|i:typeoffsetof\",\n                          &CTypeDescr_Type, &ct, &fieldname, &following))\n        return NULL;\n\n    res = (PyObject *)direct_typeoffsetof(ct, fieldname, following, &offset);\n    if (res == NULL)\n        return NULL;\n\n    return Py_BuildValue(\"(On)\", res, offset);\n}\n\nstatic PyObject *b_rawaddressof(PyObject *self, PyObject *args)\n{\n    CTypeDescrObject *ct;\n    CDataObject *cd;\n    Py_ssize_t offset;\n    int accepted_flags;\n\n    if (!PyArg_ParseTuple(args, \"O!O!n:rawaddressof\",\n                          &CTypeDescr_Type, &ct,\n                          &CData_Type, &cd,\n                          &offset))\n        return NULL;\n\n    accepted_flags = CT_STRUCT | CT_UNION | CT_ARRAY | CT_POINTER;\n    if ((cd->c_type->ct_flags & accepted_flags) == 0) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"expected a cdata struct/union/array/pointer object\");\n        return NULL;\n    }\n    if ((ct->ct_flags & CT_POINTER) == 0) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"expected a pointer ctype\");\n        return NULL;\n    }\n    return new_simple_cdata(cd->c_data + offset, ct);\n}\n\nstatic PyObject *b_getcname(PyObject *self, PyObject *args)\n{\n    CTypeDescrObject *ct;\n    char *replace_with, *p, *s;\n    Py_ssize_t namelen, replacelen;\n\n    if (!PyArg_ParseTuple(args, \"O!s:getcname\",\n                          &CTypeDescr_Type, &ct, &replace_with))\n        return NULL;\n\n    namelen = strlen(ct->ct_name);\n    replacelen = strlen(replace_with);\n    s = p = alloca(namelen + replacelen + 1);\n    memcpy(p, ct->ct_name, ct->ct_name_position);\n    p += ct->ct_name_position;\n    memcpy(p, replace_with, replacelen);\n    p += replacelen;\n    memcpy(p, ct->ct_name + ct->ct_name_position,\n           namelen - ct->ct_name_position);\n\n    return PyText_FromStringAndSize(s, namelen + replacelen);\n}\n\nstatic PyObject *b_string(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    CDataObject *cd;\n    Py_ssize_t maxlen = -1;\n    static char *keywords[] = {\"cdata\", \"maxlen\", NULL};\n\n    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"O!|n:string\", keywords,\n                                     &CData_Type, &cd, &maxlen))\n        return NULL;\n\n    if (cd->c_type->ct_itemdescr != NULL &&\n        cd->c_type->ct_itemdescr->ct_flags & (CT_PRIMITIVE_CHAR |\n                                              CT_PRIMITIVE_SIGNED |\n                                              CT_PRIMITIVE_UNSIGNED) &&\n        !(cd->c_type->ct_itemdescr->ct_flags & CT_IS_BOOL)) {\n        Py_ssize_t length = maxlen;\n        if (cd->c_data == NULL) {\n            PyObject *s = cdata_repr(cd);\n            if (s != NULL) {\n                PyErr_Format(PyExc_RuntimeError,\n                             \"cannot use string() on %s\",\n                             PyText_AS_UTF8(s));\n                Py_DECREF(s);\n            }\n            return NULL;\n        }\n        if (length < 0 && cd->c_type->ct_flags & CT_ARRAY) {\n            length = get_array_length(cd);\n        }\n        if (cd->c_type->ct_itemdescr->ct_size == sizeof(char)) {\n            const char *start = cd->c_data;\n            if (length < 0) {\n                /*READ(start, 1)*/\n                length = strlen(start);\n                /*READ(start, length)*/\n            }\n            else {\n                const char *end;\n                /*READ(start, length)*/\n                end = (const char *)memchr(start, 0, length);\n                if (end != NULL)\n                    length = end - start;\n            }\n            return PyBytes_FromStringAndSize(start, length);\n        }\n        else if (cd->c_type->ct_itemdescr->ct_flags & CT_PRIMITIVE_CHAR) {\n            switch (cd->c_type->ct_itemdescr->ct_size) {\n            case 2: {\n                const cffi_char16_t *start = (cffi_char16_t *)cd->c_data;\n                if (length < 0) {\n                    /*READ(start, 2)*/\n                    length = 0;\n                    while (start[length])\n                        length++;\n                    /*READ(start, 2 * length)*/\n                }\n                else {\n                    /*READ(start, 2 * length)*/\n                    maxlen = length;\n                    length = 0;\n                    while (length < maxlen && start[length])\n                        length++;\n                }\n                return _my_PyUnicode_FromChar16(start, length);\n            }\n            case 4: {\n                const cffi_char32_t *start = (cffi_char32_t *)cd->c_data;\n                if (length < 0) {\n                    /*READ(start, 4)*/\n                    length = 0;\n                    while (start[length])\n                        length++;\n                    /*READ(start, 4 * length)*/\n                }\n                else {\n                    /*READ(start, 4 * length)*/\n                    maxlen = length;\n                    length = 0;\n                    while (length < maxlen && start[length])\n                        length++;\n                }\n                return _my_PyUnicode_FromChar32(start, length);\n            }\n            }\n        }\n    }\n    else if (cd->c_type->ct_flags & CT_IS_ENUM) {\n        return convert_cdata_to_enum_string(cd, 0);\n    }\n    else if (cd->c_type->ct_flags & CT_IS_BOOL) {\n        /* fall through to TypeError */\n    }\n    else if (cd->c_type->ct_flags & (CT_PRIMITIVE_CHAR |\n                                     CT_PRIMITIVE_SIGNED |\n                                     CT_PRIMITIVE_UNSIGNED)) {\n        /*READ(cd->c_data, cd->c_type->ct_size)*/\n        if (cd->c_type->ct_size == sizeof(char))\n            return PyBytes_FromStringAndSize(cd->c_data, 1);\n        else if (cd->c_type->ct_flags & CT_PRIMITIVE_CHAR) {\n            switch (cd->c_type->ct_size) {\n            case 2:\n                return _my_PyUnicode_FromChar16((cffi_char16_t *)cd->c_data, 1);\n            case 4:\n                return _my_PyUnicode_FromChar32((cffi_char32_t *)cd->c_data, 1);\n            }\n        }\n    }\n    PyErr_Format(PyExc_TypeError, \"string(): unexpected cdata '%s' argument\",\n                 cd->c_type->ct_name);\n    return NULL;\n}\n\nstatic PyObject *b_unpack(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    CDataObject *cd;\n    CTypeDescrObject *ctitem;\n    Py_ssize_t i, length, itemsize;\n    PyObject *result;\n    char *src;\n    int casenum;\n    static char *keywords[] = {\"cdata\", \"length\", NULL};\n\n    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"O!n:unpack\", keywords,\n                                     &CData_Type, &cd, &length))\n        return NULL;\n\n    if (!(cd->c_type->ct_flags & (CT_ARRAY|CT_POINTER))) {\n        PyErr_Format(PyExc_TypeError,\n                     \"expected a pointer or array, got '%s'\",\n                     cd->c_type->ct_name);\n        return NULL;\n    }\n    if (length < 0) {\n        PyErr_SetString(PyExc_ValueError, \"'length' cannot be negative\");\n        return NULL;\n    }\n    if (cd->c_data == NULL) {\n        PyObject *s = cdata_repr(cd);\n        if (s != NULL) {\n            PyErr_Format(PyExc_RuntimeError,\n                         \"cannot use unpack() on %s\",\n                         PyText_AS_UTF8(s));\n            Py_DECREF(s);\n        }\n        return NULL;\n    }\n\n    /* byte- and unicode strings */\n    ctitem = cd->c_type->ct_itemdescr;\n    if (ctitem->ct_flags & CT_PRIMITIVE_CHAR) {\n        switch (ctitem->ct_size) {\n        case sizeof(char):\n            return PyBytes_FromStringAndSize(cd->c_data, length);\n        case 2:\n            return _my_PyUnicode_FromChar16((cffi_char16_t *)cd->c_data,length);\n        case 4:\n            return _my_PyUnicode_FromChar32((cffi_char32_t *)cd->c_data,length);\n        }\n    }\n\n    /* else, the result is a list.  This implementation should be\n       equivalent to but much faster than '[p[i] for i in range(length)]'.\n       (Note that on PyPy, 'list(p[0:length])' should be equally fast,\n       but arguably, finding out that there *is* such an unexpected way\n       to write things down is the real problem.)\n    */\n    result = PyList_New(length);\n    if (result == NULL)\n        return NULL;\n\n    src = cd->c_data;\n    itemsize = ctitem->ct_size;\n    if (itemsize < 0) {\n        Py_DECREF(result);\n        PyErr_Format(PyExc_ValueError, \"'%s' points to items of unknown size\",\n                     cd->c_type->ct_name);\n        return NULL;\n    }\n\n    /* Determine some common fast-paths for the loop below.  The case -1\n       is the fall-back, which always gives the right answer. */\n\n#define ALIGNMENT_CHECK(align)                          \\\n        (((align) & ((align) - 1)) == 0 &&              \\\n         (((uintptr_t)src) & ((align) - 1)) == 0)\n\n    casenum = -1;\n\n    if ((ctitem->ct_flags & CT_PRIMITIVE_ANY) &&\n            ALIGNMENT_CHECK(ctitem->ct_length)) {\n        /* Source data is fully aligned; we can directly read without\n           memcpy().  The unaligned case is expected to be rare; in\n           this situation it is ok to fall back to the general\n           convert_to_object() in the loop.  For now we also use this\n           fall-back for types that are too large.\n        */\n        if (ctitem->ct_flags & CT_PRIMITIVE_SIGNED) {\n            if (itemsize == sizeof(long))             casenum = 3;\n            else if (itemsize == sizeof(int))         casenum = 2;\n            else if (itemsize == sizeof(short))       casenum = 1;\n            else if (itemsize == sizeof(signed char)) casenum = 0;\n        }\n        else if (ctitem->ct_flags & CT_PRIMITIVE_UNSIGNED) {\n            /* Note: we never pick case 6 if sizeof(int) == sizeof(long),\n               so that case 6 below can assume that the 'unsigned int' result\n               would always fit in a 'signed long'. */\n            if (ctitem->ct_flags & CT_IS_BOOL)           casenum = 11;\n            else if (itemsize == sizeof(unsigned long))  casenum = 7;\n            else if (itemsize == sizeof(unsigned int))   casenum = 6;\n            else if (itemsize == sizeof(unsigned short)) casenum = 5;\n            else if (itemsize == sizeof(unsigned char))  casenum = 4;\n        }\n        else if (ctitem->ct_flags & CT_PRIMITIVE_FLOAT) {\n            if      (itemsize == sizeof(double)) casenum = 9;\n            else if (itemsize == sizeof(float))  casenum = 8;\n        }\n    }\n    else if (ctitem->ct_flags & (CT_POINTER | CT_FUNCTIONPTR)) {\n        casenum = 10;    /* any pointer */\n    }\n#undef ALIGNMENT_CHECK\n\n    for (i = 0; i < length; i++) {\n        PyObject *x;\n        switch (casenum) {\n            /* general case */\n        default: x = convert_to_object(src, ctitem); break;\n\n            /* special cases for performance only */\n        case 0: x = PyInt_FromLong(*(signed char *)src); break;\n        case 1: x = PyInt_FromLong(*(short *)src); break;\n        case 2: x = PyInt_FromLong(*(int *)src); break;\n        case 3: x = PyInt_FromLong(*(long *)src); break;\n        case 4: x = PyInt_FromLong(*(unsigned char *)src); break;\n        case 5: x = PyInt_FromLong(*(unsigned short *)src); break;\n        case 6: x = PyInt_FromLong((long)*(unsigned int *)src); break;\n        case 7: x = PyLong_FromUnsignedLong(*(unsigned long *)src); break;\n        case 8: x = PyFloat_FromDouble(*(float *)src); break;\n        case 9: x = PyFloat_FromDouble(*(double *)src); break;\n        case 10: x = new_simple_cdata(*(char **)src, ctitem); break;\n        case 11:\n            switch (*(unsigned char *)src) {\n            case 0: x = Py_False; Py_INCREF(x); break;\n            case 1: x = Py_True;  Py_INCREF(x); break;\n            default: x = convert_to_object(src, ctitem); /* error */\n            }\n            break;\n        }\n        if (x == NULL) {\n            Py_DECREF(result);\n            return NULL;\n        }\n        PyList_SET_ITEM(result, i, x);\n        src += itemsize;\n    }\n    return result;\n}\n\nstatic PyObject *\nb_buffer_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    /* this is the constructor of the type implemented in minibuffer.h */\n    CDataObject *cd;\n    Py_ssize_t size = -1;\n    static char *keywords[] = {\"cdata\", \"size\", NULL};\n\n    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"O!|n:buffer\", keywords,\n                                     &CData_Type, &cd, &size))\n        return NULL;\n\n    if (size < 0)\n        size = _cdata_var_byte_size(cd);\n\n    if (cd->c_type->ct_flags & CT_POINTER) {\n        if (size < 0)\n            size = cd->c_type->ct_itemdescr->ct_size;\n    }\n    else if (cd->c_type->ct_flags & CT_ARRAY) {\n        if (size < 0)\n            size = get_array_length(cd) * cd->c_type->ct_itemdescr->ct_size;\n    }\n    else {\n        PyErr_Format(PyExc_TypeError,\n                     \"expected a pointer or array cdata, got '%s'\",\n                     cd->c_type->ct_name);\n        return NULL;\n    }\n    if (size < 0) {\n        PyErr_Format(PyExc_TypeError,\n                     \"don't know the size pointed to by '%s'\",\n                     cd->c_type->ct_name);\n        return NULL;\n    }\n    /*WRITE(cd->c_data, size)*/\n    return minibuffer_new(cd->c_data, size, (PyObject *)cd);\n}\n\nstatic PyObject *b_get_errno(PyObject *self, PyObject *noarg)\n{\n    int err;\n    restore_errno_only();\n    err = errno;\n    errno = 0;\n    return PyInt_FromLong(err);\n}\n\nstatic PyObject *b_set_errno(PyObject *self, PyObject *arg)\n{\n    long ival = PyInt_AsLong(arg);\n    if (ival == -1 && PyErr_Occurred())\n        return NULL;\n    else if (ival < INT_MIN || ival > INT_MAX) {\n        PyErr_SetString(PyExc_OverflowError, \"errno value too large\");\n        return NULL;\n    }\n    errno = (int)ival;\n    save_errno_only();\n    errno = 0;\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nstatic PyObject *newp_handle(CTypeDescrObject *ct_voidp, PyObject *x)\n{\n    CDataObject_own_structptr *cd;\n    cd = (CDataObject_own_structptr *)PyObject_GC_New(CDataObject_own_structptr,\n                                                      &CDataOwningGC_Type);\n    if (cd == NULL)\n        return NULL;\n    Py_INCREF(ct_voidp);        /* must be \"void *\" */\n    cd->head.c_type = ct_voidp;\n    cd->head.c_data = (char *)cd;\n    cd->head.c_weakreflist = NULL;\n    Py_INCREF(x);\n    cd->structobj = x;\n    PyObject_GC_Track(cd);\n    return (PyObject *)cd;\n}\n\nstatic PyObject *b_newp_handle(PyObject *self, PyObject *args)\n{\n    CTypeDescrObject *ct;\n    PyObject *x;\n    if (!PyArg_ParseTuple(args, \"O!O\", &CTypeDescr_Type, &ct, &x))\n        return NULL;\n\n    if (!(ct->ct_flags & CT_IS_VOID_PTR)) {\n        PyErr_Format(PyExc_TypeError, \"needs 'void *', got '%s'\", ct->ct_name);\n        return NULL;\n    }\n\n    return newp_handle(ct, x);\n}\n\nstatic PyObject *b_from_handle(PyObject *self, PyObject *arg)\n{\n    CTypeDescrObject *ct;\n    CDataObject_own_structptr *orgcd;\n    PyObject *x;\n    if (!CData_Check(arg)) {\n        PyErr_SetString(PyExc_TypeError, \"expected a 'cdata' object\");\n        return NULL;\n    }\n    ct = ((CDataObject *)arg)->c_type;\n    if (!(ct->ct_flags & CT_IS_VOIDCHAR_PTR)) {\n        PyErr_Format(PyExc_TypeError,\n                     \"expected a 'cdata' object with a 'void *' out of \"\n                     \"new_handle(), got '%s'\", ct->ct_name);\n        return NULL;\n    }\n    orgcd = (CDataObject_own_structptr *)((CDataObject *)arg)->c_data;\n    if (!orgcd) {\n        PyErr_SetString(PyExc_RuntimeError,\n                        \"cannot use from_handle() on NULL pointer\");\n        return NULL;\n    }\n    if (Py_REFCNT(orgcd) <= 0 || Py_TYPE(orgcd) != &CDataOwningGC_Type) {\n        Py_FatalError(\"ffi.from_handle() detected that the address passed \"\n                      \"points to garbage. If it is really the result of \"\n                      \"ffi.new_handle(), then the Python object has already \"\n                      \"been garbage collected\");\n    }\n    x = orgcd->structobj;\n    Py_INCREF(x);\n    return x;\n}\n\nstatic int _my_PyObject_GetContiguousBuffer(PyObject *x, Py_buffer *view,\n                                            int writable_only)\n{\n#if PY_MAJOR_VERSION < 3\n    /* Some objects only support the buffer interface and CPython doesn't\n       translate it into the memoryview interface, mess.  Hack a very\n       minimal content for 'view'.  Don't care if the other fields are\n       uninitialized: we only call PyBuffer_Release(), which only reads\n       'view->obj'. */\n    PyBufferProcs *pb = x->ob_type->tp_as_buffer;\n    if (pb && !pb->bf_releasebuffer) {\n        /* we used to try all three in some vaguely sensible order,\n           i.e. first the write.  But trying to call the write on a\n           read-only buffer fails with TypeError.  So we use a less-\n           sensible order now.  See test_from_buffer_more_cases.\n\n           If 'writable_only', we only try bf_getwritebuffer.\n        */\n        readbufferproc proc = NULL;\n        if (!writable_only) {\n            proc = (readbufferproc)pb->bf_getreadbuffer;\n            if (!proc)\n                proc = (readbufferproc)pb->bf_getcharbuffer;\n        }\n        if (!proc)\n            proc = (readbufferproc)pb->bf_getwritebuffer;\n\n        if (proc && pb->bf_getsegcount) {\n            if ((*pb->bf_getsegcount)(x, NULL) != 1) {\n                PyErr_SetString(PyExc_TypeError,\n                                \"expected a single-segment buffer object\");\n                return -1;\n            }\n            view->len = (*proc)(x, 0, &view->buf);\n            if (view->len < 0)\n                return -1;\n            view->obj = x;\n            Py_INCREF(x);\n            return 0;\n        }\n    }\n#endif\n\n    if (PyObject_GetBuffer(x, view, writable_only ? PyBUF_WRITABLE\n                                                  : PyBUF_SIMPLE) < 0)\n        return -1;\n\n    if (!PyBuffer_IsContiguous(view, 'A')) {\n        PyBuffer_Release(view);\n        PyErr_SetString(PyExc_TypeError, \"contiguous buffer expected\");\n        return -1;\n    }\n    return 0;\n}\n\nstatic PyObject *direct_from_buffer(CTypeDescrObject *ct, PyObject *x,\n                                    int require_writable)\n{\n    CDataObject *cd;\n    Py_buffer *view;\n    Py_ssize_t arraylength, minimumlength = 0;\n\n    if (!(ct->ct_flags & (CT_ARRAY | CT_POINTER))) {\n        PyErr_Format(PyExc_TypeError,\n                     \"expected a pointer or array ctype, got '%s'\",\n                     ct->ct_name);\n        return NULL;\n    }\n\n    /* PyPy 5.7 can obtain buffers for string (python 2)\n       or bytes (python 3). from_buffer(u\"foo\") is disallowed.\n     */\n    if (PyUnicode_Check(x)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"from_buffer() cannot return the address \"\n                        \"of a unicode object\");\n        return NULL;\n    }\n\n    view = PyObject_Malloc(sizeof(Py_buffer));\n    if (view == NULL) {\n        PyErr_NoMemory();\n        return NULL;\n    }\n    if (_my_PyObject_GetContiguousBuffer(x, view, require_writable) < 0)\n        goto error1;\n\n    if (ct->ct_flags & CT_POINTER)\n    {\n        arraylength = view->len;   /* number of bytes, not used so far */\n    }\n    else {\n        /* ct->ct_flags & CT_ARRAY */\n        if (ct->ct_length >= 0) {\n            /* it's an array with a fixed length; make sure that the\n               buffer contains enough bytes. */\n            minimumlength = ct->ct_size;\n            arraylength = ct->ct_length;\n        }\n        else {\n            /* it's an open 'array[]' */\n            if (ct->ct_itemdescr->ct_size == 1) {\n                /* fast path, performance only */\n                arraylength = view->len;\n            }\n            else if (ct->ct_itemdescr->ct_size > 0) {\n                /* give it as many items as fit the buffer.  Ignore a\n                   partial last element. */\n                arraylength = view->len / ct->ct_itemdescr->ct_size;\n            }\n            else {\n                /* it's an array 'empty[]'.  Unsupported obscure case:\n                   the problem is that setting the length of the result\n                   to anything large (like SSIZE_T_MAX) is dangerous,\n                   because if someone tries to loop over it, it will\n                   turn effectively into an infinite loop. */\n                PyErr_Format(PyExc_ZeroDivisionError,\n                    \"from_buffer('%s', ..): the actual length of the array \"\n                    \"cannot be computed\", ct->ct_name);\n                goto error2;\n            }\n        }\n    }\n    if (view->len < minimumlength) {\n        PyErr_Format(PyExc_ValueError,\n            \"buffer is too small (%zd bytes) for '%s' (%zd bytes)\",\n            view->len, ct->ct_name, minimumlength);\n        goto error2;\n    }\n\n    cd = (CDataObject *)PyObject_GC_New(CDataObject_frombuf,\n                                        &CDataFromBuf_Type);\n    if (cd == NULL)\n        goto error2;\n\n    Py_INCREF(ct);\n    cd->c_type = ct;\n    cd->c_data = view->buf;\n    cd->c_weakreflist = NULL;\n    ((CDataObject_frombuf *)cd)->length = arraylength;\n    ((CDataObject_frombuf *)cd)->bufferview = view;\n    PyObject_GC_Track(cd);\n    return (PyObject *)cd;\n\n error2:\n    PyBuffer_Release(view);\n error1:\n    PyObject_Free(view);\n    return NULL;\n}\n\nstatic PyObject *b_from_buffer(PyObject *self, PyObject *args)\n{\n    CTypeDescrObject *ct;\n    PyObject *x;\n    int require_writable = 0;\n\n    if (!PyArg_ParseTuple(args, \"O!O|i\", &CTypeDescr_Type, &ct, &x,\n                          &require_writable))\n        return NULL;\n\n    return direct_from_buffer(ct, x, require_writable);\n}\n\nstatic int _fetch_as_buffer(PyObject *x, Py_buffer *view, int writable_only)\n{\n    if (CData_Check(x)) {\n        CTypeDescrObject *ct = ((CDataObject *)x)->c_type;\n        if (!(ct->ct_flags & (CT_POINTER|CT_ARRAY))) {\n            PyErr_Format(PyExc_TypeError,\n                         \"expected a pointer or array ctype, got '%s'\",\n                         ct->ct_name);\n            return -1;\n        }\n        view->buf = ((CDataObject *)x)->c_data;\n        view->obj = NULL;\n        return 0;\n    }\n    else {\n        return _my_PyObject_GetContiguousBuffer(x, view, writable_only);\n    }\n}\n\nstatic PyObject *b_memmove(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    PyObject *dest_obj, *src_obj;\n    Py_buffer dest_view, src_view;\n    Py_ssize_t n;\n    static char *keywords[] = {\"dest\", \"src\", \"n\", NULL};\n\n    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"OOn\", keywords,\n                                     &dest_obj, &src_obj, &n))\n        return NULL;\n    if (n < 0) {\n        PyErr_SetString(PyExc_ValueError, \"negative size\");\n        return NULL;\n    }\n\n    if (_fetch_as_buffer(src_obj, &src_view, 0) < 0) {\n        return NULL;\n    }\n    if (_fetch_as_buffer(dest_obj, &dest_view, 1) < 0) {\n        PyBuffer_Release(&src_view);\n        return NULL;\n    }\n\n    memmove(dest_view.buf, src_view.buf, n);\n\n    PyBuffer_Release(&dest_view);\n    PyBuffer_Release(&src_view);\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nstatic PyObject *b__get_types(PyObject *self, PyObject *noarg)\n{\n    return PyTuple_Pack(2, (PyObject *)&CData_Type,\n                           (PyObject *)&CTypeDescr_Type);\n}\n\n/* forward, in commontypes.c */\nstatic PyObject *b__get_common_types(PyObject *self, PyObject *arg);\n\nstatic PyObject *b_gcp(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    CDataObject *cd;\n    CDataObject *origobj;\n    PyObject *destructor;\n    Py_ssize_t ignored;   /* for pypy */\n    static char *keywords[] = {\"cdata\", \"destructor\", \"size\", NULL};\n\n    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"O!O|n:gc\", keywords,\n                                     &CData_Type, &origobj, &destructor,\n                                     &ignored))\n        return NULL;\n\n    if (destructor == Py_None) {\n\tif (!PyObject_TypeCheck(origobj, &CDataGCP_Type)) {\n\t    PyErr_SetString(PyExc_TypeError,\n\t\t\t    \"Can remove destructor only on a object \"\n\t\t\t    \"previously returned by ffi.gc()\");\n\t    return NULL;\n\t}\n\tPy_CLEAR(((CDataObject_gcp *)origobj)->destructor);\n\tPy_RETURN_NONE;\n    }\n\n    cd = allocate_gcp_object(origobj, origobj->c_type, destructor);\n    return (PyObject *)cd;\n}\n\nstatic PyObject *b_release(PyObject *self, PyObject *arg)\n{\n    if (!CData_Check(arg)) {\n        PyErr_SetString(PyExc_TypeError, \"expected a 'cdata' object\");\n        return NULL;\n    }\n    return cdata_exit(arg, NULL);\n}\n\n/************************************************************/\n\nstatic char _testfunc0(char a, char b)\n{\n    return a + b;\n}\nstatic long _testfunc1(int a, long b)\n{\n    return (long)a + b;\n}\nstatic PY_LONG_LONG _testfunc2(PY_LONG_LONG a, PY_LONG_LONG b)\n{\n    return a + b;\n}\nstatic double _testfunc3(float a, double b)\n{\n    return a + b;\n}\nstatic float _testfunc4(float a, double b)\n{\n    return (float)(a + b);\n}\nstatic void _testfunc5(void)\n{\n    errno = errno + 15;\n}\nstatic int *_testfunc6(int *x)\n{\n    static int y;\n    y = *x - 1000;\n    return &y;\n}\nstruct _testfunc7_s { unsigned char a1; short a2; };\nstatic short _testfunc7(struct _testfunc7_s inlined)\n{\n    return inlined.a1 + inlined.a2;\n}\nstatic int _testfunc9(int num, ...)\n{\n    va_list vargs;\n    int i, total = 0;\n    va_start(vargs, num);\n    for (i=0; i<num; i++) {\n        int value = va_arg(vargs, int);\n        if (value == 0)\n            value = -66666666;\n        total += value;\n    }\n    va_end(vargs);\n    return total;\n}\n\nstatic struct _testfunc7_s _testfunc10(int n)\n{\n    struct _testfunc7_s result;\n    result.a1 = n;\n    result.a2 = n * n;\n    return result;\n}\n\nstruct _testfunc11_s { int a1, a2; };\nstatic struct _testfunc11_s _testfunc11(int n)\n{\n    struct _testfunc11_s result;\n    result.a1 = n;\n    result.a2 = n * n;\n    return result;\n}\n\nstruct _testfunc12_s { double a1; };\nstatic struct _testfunc12_s _testfunc12(int n)\n{\n    struct _testfunc12_s result;\n    result.a1 = n;\n    return result;\n}\n\nstruct _testfunc13_s { int a1, a2, a3; };\nstatic struct _testfunc13_s _testfunc13(int n)\n{\n    struct _testfunc13_s result;\n    result.a1 = n;\n    result.a2 = n * n;\n    result.a3 = n * n * n;\n    return result;\n}\n\nstruct _testfunc14_s { float a1; };\nstatic struct _testfunc14_s _testfunc14(int n)\n{\n    struct _testfunc14_s result;\n    result.a1 = (float)n;\n    return result;\n}\n\nstruct _testfunc15_s { float a1; int a2; };\nstatic struct _testfunc15_s _testfunc15(int n)\n{\n    struct _testfunc15_s result;\n    result.a1 = (float)n;\n    result.a2 = n * n;\n    return result;\n}\n\nstruct _testfunc16_s { float a1, a2; };\nstatic struct _testfunc16_s _testfunc16(int n)\n{\n    struct _testfunc16_s result;\n    result.a1 = (float)n;\n    result.a2 = -(float)n;\n    return result;\n}\n\nstruct _testfunc17_s { int a1; float a2; };\nstatic struct _testfunc17_s _testfunc17(int n)\n{\n    struct _testfunc17_s result;\n    result.a1 = n;\n    result.a2 = (float)n * (float)n;\n    return result;\n}\n\nstatic int _testfunc18(struct _testfunc17_s *ptr)\n{\n    return ptr->a1 + (int)ptr->a2;\n}\n\nstatic long double _testfunc19(long double x, int count)\n{\n    int i;\n    for (i=0; i<count; i++) {\n        x = 4*x - x*x;\n    }\n    return x;\n}\n\nstatic short _testfunc20(struct _testfunc7_s *ptr)\n{\n    return ptr->a1 + ptr->a2;\n}\n\nstruct _testfunc21_s { int a, b, c, d, e, f, g, h, i, j; };\nstatic int _testfunc21(struct _testfunc21_s inlined)\n{\n    return ((inlined.a << 0) +\n            (inlined.b << 1) +\n            (inlined.c << 2) +\n            (inlined.d << 3) +\n            (inlined.e << 4) +\n            (inlined.f << 5) +\n            (inlined.g << 6) +\n            (inlined.h << 7) +\n            (inlined.i << 8) +\n            (inlined.j << 9));\n}\n\nstruct _testfunc22_s { int a[10]; };\nstatic struct _testfunc22_s _testfunc22(struct _testfunc22_s s1,\n                                        struct _testfunc22_s s2)\n{\n    struct _testfunc22_s result;\n    int i;\n    for (i=0; i<10; i++)\n        result.a[i] = s1.a[i] - s2.a[i];\n    return result;\n}\n\nstatic int _testfunc23(char *p)\n{\n    if (p)\n        return 1000 * p[0];\n    return -42;\n}\n\n#if 0   /* libffi doesn't properly support complexes currently */\n        /* also, MSVC might not support _Complex... */\n        /* if this is enabled one day, remember to also add _Complex\n         * arguments in addition to return values. */\nstatic float _Complex _testfunc24(float a, float b)\n{\n    return a + I*2.0*b;\n}\nstatic double _Complex _testfunc25(double a, double b)\n{\n    return a + I*2.0*b;\n}\n#endif\n\nstatic PyObject *b__testfunc(PyObject *self, PyObject *args)\n{\n    /* for testing only */\n    int i;\n    void *f;\n    if (!PyArg_ParseTuple(args, \"i:_testfunc\", &i))\n        return NULL;\n    switch (i) {\n    case 0: f = &_testfunc0; break;\n    case 1: f = &_testfunc1; break;\n    case 2: f = &_testfunc2; break;\n    case 3: f = &_testfunc3; break;\n    case 4: f = &_testfunc4; break;\n    case 5: f = &_testfunc5; break;\n    case 6: f = &_testfunc6; break;\n    case 7: f = &_testfunc7; break;\n    case 8: f = stderr; break;\n    case 9: f = &_testfunc9; break;\n    case 10: f = &_testfunc10; break;\n    case 11: f = &_testfunc11; break;\n    case 12: f = &_testfunc12; break;\n    case 13: f = &_testfunc13; break;\n    case 14: f = &_testfunc14; break;\n    case 15: f = &_testfunc15; break;\n    case 16: f = &_testfunc16; break;\n    case 17: f = &_testfunc17; break;\n    case 18: f = &_testfunc18; break;\n    case 19: f = &_testfunc19; break;\n    case 20: f = &_testfunc20; break;\n    case 21: f = &_testfunc21; break;\n    case 22: f = &_testfunc22; break;\n    case 23: f = &_testfunc23; break;\n#if 0\n    case 24: f = &_testfunc24; break;\n    case 25: f = &_testfunc25; break;\n#endif\n    default:\n        PyErr_SetNone(PyExc_ValueError);\n        return NULL;\n    }\n    return PyLong_FromVoidPtr(f);\n}\n\n#if PY_MAJOR_VERSION < 3\nstatic Py_ssize_t _test_segcountproc(PyObject *o, Py_ssize_t *ignored)\n{\n    return 1;\n}\nstatic Py_ssize_t _test_getreadbuf(PyObject *o, Py_ssize_t i, void **r)\n{\n    static char buf[] = \"RDB\";\n    *r = buf;\n    return 3;\n}\nstatic Py_ssize_t _test_getwritebuf(PyObject *o, Py_ssize_t i, void **r)\n{\n    static char buf[] = \"WRB\";\n    *r = buf;\n    return 3;\n}\nstatic Py_ssize_t _test_getcharbuf(PyObject *o, Py_ssize_t i, char **r)\n{\n    static char buf[] = \"CHB\";\n    *r = buf;\n    return 3;\n}\n#endif\nstatic int _test_getbuf(PyObject *self, Py_buffer *view, int flags)\n{\n    static char buf[] = \"GTB\";\n    return PyBuffer_FillInfo(view, self, buf, 3, /*readonly=*/0, flags);\n}\nstatic int _test_getbuf_ro(PyObject *self, Py_buffer *view, int flags)\n{\n    static char buf[] = \"ROB\";\n    return PyBuffer_FillInfo(view, self, buf, 3, /*readonly=*/1, flags);\n}\n\n\nstatic PyObject *b__testbuff(PyObject *self, PyObject *args)\n{\n    /* for testing only */\n    int methods;\n    PyTypeObject *obj;\n    if (!PyArg_ParseTuple(args, \"O!i|_testbuff\", &PyType_Type, &obj, &methods))\n        return NULL;\n\n    assert(obj->tp_as_buffer != NULL);\n\n#if PY_MAJOR_VERSION < 3\n    obj->tp_as_buffer->bf_getsegcount = &_test_segcountproc;\n    obj->tp_flags |= Py_TPFLAGS_HAVE_GETCHARBUFFER;\n    obj->tp_flags |= Py_TPFLAGS_HAVE_NEWBUFFER;\n    if (methods & 1)  obj->tp_as_buffer->bf_getreadbuffer  = &_test_getreadbuf;\n    if (methods & 2)  obj->tp_as_buffer->bf_getwritebuffer = &_test_getwritebuf;\n    if (methods & 4)  obj->tp_as_buffer->bf_getcharbuffer  = &_test_getcharbuf;\n#endif\n    if (methods & 8)  obj->tp_as_buffer->bf_getbuffer      = &_test_getbuf;\n    if (methods & 16) obj->tp_as_buffer->bf_getbuffer      = &_test_getbuf_ro;\n\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nstatic PyObject *b_init_cffi_1_0_external_module(PyObject *, PyObject *);\n/* forward, see cffi1_module.c */\n\n\nstatic PyMethodDef FFIBackendMethods[] = {\n    {\"load_library\", b_load_library, METH_VARARGS},\n    {\"new_primitive_type\", b_new_primitive_type, METH_VARARGS},\n    {\"new_pointer_type\", b_new_pointer_type, METH_VARARGS},\n    {\"new_array_type\", b_new_array_type, METH_VARARGS},\n    {\"new_void_type\", b_new_void_type, METH_NOARGS},\n    {\"new_struct_type\", b_new_struct_type, METH_VARARGS},\n    {\"new_union_type\", b_new_union_type, METH_VARARGS},\n    {\"complete_struct_or_union\", b_complete_struct_or_union, METH_VARARGS},\n    {\"new_function_type\", b_new_function_type, METH_VARARGS},\n    {\"new_enum_type\", b_new_enum_type, METH_VARARGS},\n    {\"newp\", b_newp, METH_VARARGS},\n    {\"cast\", b_cast, METH_VARARGS},\n    {\"callback\", b_callback, METH_VARARGS},\n    {\"alignof\", b_alignof, METH_O},\n    {\"sizeof\", b_sizeof, METH_O},\n    {\"typeof\", b_typeof, METH_O},\n    {\"typeoffsetof\", b_typeoffsetof, METH_VARARGS},\n    {\"rawaddressof\", b_rawaddressof, METH_VARARGS},\n    {\"getcname\", b_getcname, METH_VARARGS},\n    {\"string\", (PyCFunction)b_string, METH_VARARGS | METH_KEYWORDS},\n    {\"unpack\", (PyCFunction)b_unpack, METH_VARARGS | METH_KEYWORDS},\n    {\"get_errno\", b_get_errno, METH_NOARGS},\n    {\"set_errno\", b_set_errno, METH_O},\n    {\"newp_handle\", b_newp_handle, METH_VARARGS},\n    {\"from_handle\", b_from_handle, METH_O},\n    {\"from_buffer\", b_from_buffer, METH_VARARGS},\n    {\"memmove\", (PyCFunction)b_memmove, METH_VARARGS | METH_KEYWORDS},\n    {\"gcp\", (PyCFunction)b_gcp, METH_VARARGS | METH_KEYWORDS},\n    {\"release\", b_release, METH_O},\n#ifdef MS_WIN32\n    {\"getwinerror\", (PyCFunction)b_getwinerror, METH_VARARGS | METH_KEYWORDS},\n#endif\n    {\"_get_types\", b__get_types, METH_NOARGS},\n    {\"_get_common_types\", b__get_common_types, METH_O},\n    {\"_testfunc\", b__testfunc, METH_VARARGS},\n    {\"_testbuff\", b__testbuff, METH_VARARGS},\n    {\"_init_cffi_1_0_external_module\", b_init_cffi_1_0_external_module, METH_O},\n    {NULL,     NULL}    /* Sentinel */\n};\n\n/************************************************************/\n/* Functions used by '_cffi_N.so', the generated modules    */\n\n#define _cffi_to_c_SIGNED_FN(RETURNTYPE, SIZE)                          \\\nstatic RETURNTYPE _cffi_to_c_i##SIZE(PyObject *obj) {                   \\\n    PY_LONG_LONG tmp = _my_PyLong_AsLongLong(obj);                      \\\n    if ((tmp > (PY_LONG_LONG)((1ULL<<(SIZE-1)) - 1)) ||                 \\\n        (tmp < (PY_LONG_LONG)(0ULL-(1ULL<<(SIZE-1)))))                  \\\n        if (!PyErr_Occurred())                                          \\\n            return (RETURNTYPE)_convert_overflow(obj, #SIZE \"-bit int\"); \\\n    return (RETURNTYPE)tmp;                                             \\\n}\n\n#define _cffi_to_c_UNSIGNED_FN(RETURNTYPE, SIZE)                        \\\nstatic RETURNTYPE _cffi_to_c_u##SIZE(PyObject *obj) {                   \\\n    unsigned PY_LONG_LONG tmp = _my_PyLong_AsUnsignedLongLong(obj, 1);  \\\n    if (tmp > ~(((unsigned PY_LONG_LONG)-2) << (SIZE-1)))               \\\n        if (!PyErr_Occurred())                                          \\\n            return (RETURNTYPE)_convert_overflow(obj,                   \\\n                                   #SIZE \"-bit unsigned int\");          \\\n    return (RETURNTYPE)tmp;                                             \\\n}\n\n_cffi_to_c_SIGNED_FN(int, 8)\n_cffi_to_c_SIGNED_FN(int, 16)\n_cffi_to_c_SIGNED_FN(int, 32)\n_cffi_to_c_SIGNED_FN(PY_LONG_LONG, 64)\n_cffi_to_c_UNSIGNED_FN(int, 8)\n_cffi_to_c_UNSIGNED_FN(int, 16)\n_cffi_to_c_UNSIGNED_FN(unsigned int, 32)\n_cffi_to_c_UNSIGNED_FN(unsigned PY_LONG_LONG, 64)\n\nstatic PyObject *_cffi_from_c_pointer(char *ptr, CTypeDescrObject *ct)\n{\n    return convert_to_object((char *)&ptr, ct);\n}\n\nstatic char *_cffi_to_c_pointer(PyObject *obj, CTypeDescrObject *ct)\n{\n    char *result;\n    if (convert_from_object((char *)&result, ct, obj) < 0) {\n        if ((ct->ct_flags & CT_POINTER) &&\n                (ct->ct_itemdescr->ct_flags & CT_IS_FILE) &&\n                PyFile_Check(obj)) {\n            PyErr_Clear();\n            return (char *)PyFile_AsFile(obj);\n        }\n        return NULL;\n    }\n    return result;\n}\n\nstatic long double _cffi_to_c_long_double(PyObject *obj)\n{\n    if (CData_Check(obj) &&\n            (((CDataObject *)obj)->c_type->ct_flags & CT_IS_LONGDOUBLE)) {\n        char *data = ((CDataObject *)obj)->c_data;\n        /*READ(data, sizeof(long double))*/\n        return read_raw_longdouble_data(data);\n    }\n    else\n        return PyFloat_AsDouble(obj);\n}\n\nstatic _Bool _cffi_to_c__Bool(PyObject *obj)\n{\n    PY_LONG_LONG tmp = _my_PyLong_AsLongLong(obj);\n    if (tmp == 0)\n        return 0;\n    else if (tmp == 1)\n        return 1;\n    else if (PyErr_Occurred())\n        return (_Bool)-1;\n    else\n        return (_Bool)_convert_overflow(obj, \"_Bool\");\n}\n\nstatic PyObject *_cffi_get_struct_layout(Py_ssize_t nums[])\n{\n    PyObject *result;\n    int count = 0;\n    while (nums[count] >= 0)\n        count++;\n\n    result = PyList_New(count);\n    if (result == NULL)\n        return NULL;\n\n    while (--count >= 0) {\n        PyObject *o = PyInt_FromSsize_t(nums[count]);\n        if (o == NULL) {\n            Py_DECREF(result);\n            return NULL;\n        }\n        PyList_SET_ITEM(result, count, o);\n    }\n    return result;\n}\n\nstatic PyObject *_cffi_from_c_char(char x) {\n    return PyBytes_FromStringAndSize(&x, 1);\n}\n\n/* backward-compatibility hack: instead of _cffi_to_c_char16_t() and\n * _cffi_to_c_char32_t(), we have _cffi_to_c_wchar_t() handling whatever\n * size is wchar_t, and _cffi_to_c_wchar3216_t() handling the opposite.\n */\n#ifdef HAVE_WCHAR_H\ntypedef wchar_t cffi_wchar_t;\n#else\ntypedef uint16_t cffi_wchar_t;   /* random pick... */\n#endif\n\nstatic cffi_wchar_t _cffi_to_c_wchar_t(PyObject *init)\n{\n    if (sizeof(cffi_wchar_t) == 2)\n        return (cffi_wchar_t)_convert_to_char16_t(init);\n    else\n        return (cffi_wchar_t)_convert_to_char32_t(init);\n}\nstatic PyObject *_cffi_from_c_wchar_t(cffi_wchar_t x) {\n    if (sizeof(cffi_wchar_t) == 2) {\n        cffi_char16_t input = x;\n        return _my_PyUnicode_FromChar16(&input, 1);\n    }\n    else {\n        cffi_char32_t input = x;\n        return _my_PyUnicode_FromChar32(&input, 1);\n    }\n}\nstatic int _cffi_to_c_wchar3216_t(PyObject *init)\n{\n    if (sizeof(cffi_wchar_t) == 4)\n        return (int)_convert_to_char16_t(init);\n    else\n        return (int)_convert_to_char32_t(init);\n}\nstatic PyObject *_cffi_from_c_wchar3216_t(int x) {\n    if (sizeof(cffi_wchar_t) == 4) {\n        cffi_char16_t input = x;\n        return _my_PyUnicode_FromChar16(&input, 1);\n    }\n    else {\n        cffi_char32_t input = x;\n        return _my_PyUnicode_FromChar32(&input, 1);\n    }\n}\n\nstruct _cffi_externpy_s;      /* forward declaration */\nstatic void cffi_call_python(struct _cffi_externpy_s *, char *args);\n\nstatic void *cffi_exports[] = {\n    NULL,\n    _cffi_to_c_i8,\n    _cffi_to_c_u8,\n    _cffi_to_c_i16,\n    _cffi_to_c_u16,\n    _cffi_to_c_i32,\n    _cffi_to_c_u32,\n    _cffi_to_c_i64,\n    _cffi_to_c_u64,\n    _convert_to_char,\n    _cffi_from_c_pointer,\n    _cffi_to_c_pointer,\n    _cffi_get_struct_layout,\n    restore_errno,\n    save_errno,\n    _cffi_from_c_char,\n    convert_to_object,\n    convert_from_object,\n    convert_struct_to_owning_object,\n    _cffi_to_c_wchar_t,\n    _cffi_from_c_wchar_t,\n    _cffi_to_c_long_double,\n    _cffi_to_c__Bool,\n    _prepare_pointer_call_argument,\n    convert_array_from_object,\n    cffi_call_python,\n    _cffi_to_c_wchar3216_t,\n    _cffi_from_c_wchar3216_t,\n};\n\nstatic struct { const char *name; int value; } all_dlopen_flags[] = {\n    { \"RTLD_LAZY\",     RTLD_LAZY     },\n    { \"RTLD_NOW\",      RTLD_NOW      },\n    { \"RTLD_GLOBAL\",   RTLD_GLOBAL   },\n#ifdef RTLD_LOCAL\n    { \"RTLD_LOCAL\",    RTLD_LOCAL    },\n#else\n    { \"RTLD_LOCAL\",    0             },\n#endif\n#ifdef RTLD_NODELETE\n    { \"RTLD_NODELETE\", RTLD_NODELETE },\n#endif\n#ifdef RTLD_NOLOAD\n    { \"RTLD_NOLOAD\",   RTLD_NOLOAD   },\n#endif\n#ifdef RTLD_DEEPBIND\n    { \"RTLD_DEEPBIND\", RTLD_DEEPBIND },\n#endif\n    { NULL, 0 }\n};\n\n\n/************************************************************/\n\n#include \"cffi1_module.c\"\n\n/************************************************************/\n\n#if PY_MAJOR_VERSION >= 3\nstatic struct PyModuleDef FFIBackendModuleDef = {\n  PyModuleDef_HEAD_INIT,\n  \"_cffi_backend\",\n  NULL,\n  -1,\n  FFIBackendMethods,\n  NULL, NULL, NULL, NULL\n};\n#define INITERROR return NULL\n\nPyMODINIT_FUNC\nPyInit__cffi_backend(void)\n#else\n#define INITERROR return\n\nPyMODINIT_FUNC\ninit_cffi_backend(void)\n#endif\n{\n    PyObject *m, *v;\n    int i;\n    static char init_done = 0;\n\n    v = PySys_GetObject(\"version\");\n    if (v == NULL || !PyText_Check(v) ||\n            strncmp(PyText_AS_UTF8(v), PY_VERSION, 3) != 0) {\n        PyErr_Format(PyExc_ImportError,\n                     \"this module was compiled for Python %c%c%c\",\n                     PY_VERSION[0], PY_VERSION[1], PY_VERSION[2]);\n        INITERROR;\n    }\n\n#if PY_MAJOR_VERSION >= 3\n    m = PyModule_Create(&FFIBackendModuleDef);\n#else\n    m = Py_InitModule(\"_cffi_backend\", FFIBackendMethods);\n#endif\n\n    if (m == NULL)\n        INITERROR;\n\n    if (unique_cache == NULL) {\n        unique_cache = PyDict_New();\n        if (unique_cache == NULL)\n            INITERROR;\n    }\n\n    if (PyType_Ready(&dl_type) < 0)\n        INITERROR;\n    if (PyType_Ready(&CTypeDescr_Type) < 0)\n        INITERROR;\n    if (PyType_Ready(&CField_Type) < 0)\n        INITERROR;\n    if (PyType_Ready(&CData_Type) < 0)\n        INITERROR;\n    if (PyType_Ready(&CDataOwning_Type) < 0)\n        INITERROR;\n    if (PyType_Ready(&CDataOwningGC_Type) < 0)\n        INITERROR;\n    if (PyType_Ready(&CDataFromBuf_Type) < 0)\n        INITERROR;\n    if (PyType_Ready(&CDataGCP_Type) < 0)\n        INITERROR;\n    if (PyType_Ready(&CDataIter_Type) < 0)\n        INITERROR;\n    if (PyType_Ready(&MiniBuffer_Type) < 0)\n        INITERROR;\n\n    if (!init_done) {\n        v = PyText_FromString(\"_cffi_backend\");\n        if (v == NULL || PyDict_SetItemString(CData_Type.tp_dict,\n                                              \"__module__\", v) < 0)\n            INITERROR;\n        v = PyText_FromString(\"<cdata>\");\n        if (v == NULL || PyDict_SetItemString(CData_Type.tp_dict,\n                                              \"__name__\", v) < 0)\n            INITERROR;\n        init_done = 1;\n    }\n\n    /* this is for backward compatibility only */\n    v = PyCapsule_New((void *)cffi_exports, \"cffi\", NULL);\n    if (v == NULL || PyModule_AddObject(m, \"_C_API\", v) < 0)\n        INITERROR;\n\n    v = PyText_FromString(CFFI_VERSION);\n    if (v == NULL || PyModule_AddObject(m, \"__version__\", v) < 0)\n        INITERROR;\n\n    if (PyModule_AddIntConstant(m, \"FFI_DEFAULT_ABI\", FFI_DEFAULT_ABI) < 0 ||\n#if defined(MS_WIN32) && !defined(_WIN64)\n        PyModule_AddIntConstant(m, \"FFI_STDCALL\", FFI_STDCALL) < 0 ||\n#endif\n        PyModule_AddIntConstant(m, \"FFI_CDECL\", FFI_DEFAULT_ABI) < 0 ||\n\n#ifdef MS_WIN32\n#  ifdef _WIN64\n        PyModule_AddIntConstant(m, \"_WIN\", 64) < 0 ||   /* win64 */\n#  else\n        PyModule_AddIntConstant(m, \"_WIN\", 32) < 0 ||   /* win32 */\n#  endif\n#endif\n        0)\n      INITERROR;\n\n    for (i = 0; all_dlopen_flags[i].name != NULL; i++) {\n        if (PyModule_AddIntConstant(m,\n                                    all_dlopen_flags[i].name,\n                                    all_dlopen_flags[i].value) < 0)\n            INITERROR;\n    }\n\n    Py_INCREF(&MiniBuffer_Type);\n    if (PyModule_AddObject(m, \"buffer\", (PyObject *)&MiniBuffer_Type) < 0)\n        INITERROR;\n\n    init_cffi_tls();\n    if (PyErr_Occurred())\n        INITERROR;\n    init_cffi_tls_zombie();\n    if (PyErr_Occurred())\n        INITERROR;\n\n    if (init_ffi_lib(m) < 0)\n        INITERROR;\n\n#if PY_MAJOR_VERSION >= 3\n    if (init_file_emulator() < 0)\n        INITERROR;\n    return m;\n#endif\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.13.0-jlicqgsrlask3n7tsdckxmdwv6d5zp4o/spack-src/c/lib_obj.c": "\n/* A Lib object is what is in the \"lib\" attribute of a C extension\n   module originally created by recompile().\n\n   A Lib object is special in the sense that it has a custom\n   __getattr__ which returns C globals, functions and constants.  The\n   original idea was to raise AttributeError for anything else, even\n   attrs like '__class__', but it breaks various things; now, standard\n   attrs are returned, but in the unlikely case where a user cdef()s\n   the same name, then the standard attr is hidden (and the various\n   things like introspection might break).\n\n   A Lib object has got a reference to the _cffi_type_context_s\n   structure, which is used to create lazily the objects returned by\n   __getattr__.\n*/\n\nstruct CPyExtFunc_s {\n    PyMethodDef md;\n    void *direct_fn;\n    int type_index;\n    char doc[1];\n};\n\nstruct LibObject_s {\n    PyObject_HEAD\n    builder_c_t *l_types_builder; /* same as the one on the ffi object */\n    PyObject *l_dict;           /* content, built lazily */\n    PyObject *l_libname;        /* some string that gives the name of the lib */\n    FFIObject *l_ffi;           /* reference back to the ffi object */\n    void *l_libhandle;          /* the dlopen()ed handle, if any */\n};\n\nstatic struct CPyExtFunc_s *_cpyextfunc_get(PyObject *x)\n{\n    PyObject *y;\n    LibObject *lo;\n    PyCFunctionObject *fo;\n\n    if (!PyCFunction_Check(x))\n        return NULL;\n    y = PyCFunction_GET_SELF(x);\n    if (!LibObject_Check(y))\n        return NULL;\n\n    fo = (PyCFunctionObject *)x;\n    lo = (LibObject *)y;\n    if (lo->l_libname != fo->m_module)\n        return NULL;\n\n    return (struct CPyExtFunc_s *)(fo->m_ml);\n}\n\nstatic PyObject *_cpyextfunc_type(LibObject *lib, struct CPyExtFunc_s *exf)\n{\n    PyObject *tuple, *result;\n    tuple = realize_c_type_or_func(lib->l_types_builder,\n                                   lib->l_types_builder->ctx.types,\n                                   exf->type_index);\n    if (tuple == NULL)\n        return NULL;\n\n    /* 'tuple' is a tuple of length 1 containing the real CT_FUNCTIONPTR\n       object */\n    result = PyTuple_GetItem(tuple, 0);\n    Py_XINCREF(result);\n    Py_DECREF(tuple);\n    return result;\n}\n\nstatic PyObject *_cpyextfunc_type_index(PyObject *x)\n{\n    struct CPyExtFunc_s *exf;\n    LibObject *lib;\n\n    assert(PyErr_Occurred());\n    exf = _cpyextfunc_get(x);\n    if (exf == NULL)\n        return NULL;    /* still the same exception is set */\n\n    PyErr_Clear();\n\n    lib = (LibObject *)PyCFunction_GET_SELF(x);\n    return _cpyextfunc_type(lib, exf);\n}\n\nstatic void cdlopen_close_ignore_errors(void *libhandle);  /* forward */\nstatic void *cdlopen_fetch(PyObject *libname, void *libhandle,\n                           const char *symbol);\n\nstatic void lib_dealloc(LibObject *lib)\n{\n    PyObject_GC_UnTrack(lib);\n    cdlopen_close_ignore_errors(lib->l_libhandle);\n    Py_DECREF(lib->l_dict);\n    Py_DECREF(lib->l_libname);\n    Py_DECREF(lib->l_ffi);\n    PyObject_GC_Del(lib);\n}\n\nstatic int lib_traverse(LibObject *lib, visitproc visit, void *arg)\n{\n    Py_VISIT(lib->l_dict);\n    Py_VISIT(lib->l_libname);\n    Py_VISIT(lib->l_ffi);\n    return 0;\n}\n\nstatic PyObject *lib_repr(LibObject *lib)\n{\n    return PyText_FromFormat(\"<Lib object for '%.200s'>\",\n                             PyText_AS_UTF8(lib->l_libname));\n}\n\nstatic PyObject *lib_build_cpython_func(LibObject *lib,\n                                        const struct _cffi_global_s *g,\n                                        const char *s, int flags)\n{\n    /* First make sure the argument types and return type are really\n       built.  The C extension code can then assume that they are,\n       by calling _cffi_type().\n    */\n    PyObject *result = NULL;\n    CTypeDescrObject **pfargs = NULL;\n    CTypeDescrObject *fresult;\n    Py_ssize_t nargs = 0;\n    struct CPyExtFunc_s *xfunc;\n    int i, type_index = _CFFI_GETARG(g->type_op);\n    _cffi_opcode_t *opcodes = lib->l_types_builder->ctx.types;\n    static const char *const format = \";\\n\\nCFFI C function from %s.lib\";\n    const char *libname = PyText_AS_UTF8(lib->l_libname);\n    struct funcbuilder_s funcbuilder;\n\n    /* return type: */\n    fresult = realize_c_func_return_type(lib->l_types_builder, opcodes,\n                                       type_index);\n    if (fresult == NULL)\n        goto error;\n\n    /* argument types: */\n    /* note that if the arguments are already built, they have a\n       pointer in the 'opcodes' array, and GETOP() returns a\n       random even value.  But OP_FUNCTION_END is odd, so the\n       condition below still works correctly. */\n    i = type_index + 1;\n    while (_CFFI_GETOP(opcodes[i]) != _CFFI_OP_FUNCTION_END)\n        i++;\n    pfargs = alloca(sizeof(CTypeDescrObject *) * (i - type_index - 1));\n    i = type_index + 1;\n    while (_CFFI_GETOP(opcodes[i]) != _CFFI_OP_FUNCTION_END) {\n        CTypeDescrObject *ct = realize_c_type(lib->l_types_builder, opcodes, i);\n        if (ct == NULL)\n            goto error;\n        pfargs[nargs++] = ct;\n        i++;\n    }\n\n    memset(&funcbuilder, 0, sizeof(funcbuilder));\n    if (fb_build_name(&funcbuilder, g->name, pfargs, nargs, fresult, 0) < 0)\n        goto error;\n\n    /* The few bytes of memory we allocate here appear to leak, but\n       this is not a real leak.  Indeed, CPython never unloads its C\n       extension modules.  There is only one PyMem_Malloc() per real\n       C function in a CFFI C extension module.  That means that this\n       PyMem_Malloc() could also have been written with a static\n       global variable generated for each CPYTHON_BLTN defined in the\n       C extension, and the effect would be the same (but a bit more\n       complicated).\n    */\n    xfunc = PyMem_Malloc(sizeof(struct CPyExtFunc_s) +\n                         funcbuilder.nb_bytes +\n                         strlen(format) + strlen(libname));\n    if (xfunc == NULL) {\n        PyErr_NoMemory();\n        goto error;\n    }\n    memset((char *)xfunc, 0, sizeof(struct CPyExtFunc_s));\n    assert(g->address);\n    xfunc->md.ml_meth = (PyCFunction)g->address;\n    xfunc->md.ml_flags = flags;\n    xfunc->md.ml_name = g->name;\n    xfunc->md.ml_doc = xfunc->doc;\n    xfunc->direct_fn = g->size_or_direct_fn;\n    xfunc->type_index = type_index;\n\n    /* build the docstring */\n    funcbuilder.bufferp = xfunc->doc;\n    if (fb_build_name(&funcbuilder, g->name, pfargs, nargs, fresult, 0) < 0)\n        goto error;\n    sprintf(funcbuilder.bufferp - 1, format, libname);\n    /* done building the docstring */\n\n    result = PyCFunction_NewEx(&xfunc->md, (PyObject *)lib, lib->l_libname);\n    /* fall-through */\n error:\n    Py_XDECREF(fresult);\n    while (nargs > 0) {\n        --nargs;\n        Py_DECREF(pfargs[nargs]);\n    }\n    return result;\n}\n\nstatic PyObject *lib_build_and_cache_attr(LibObject *lib, PyObject *name,\n                                          int recursion)\n{\n    /* does not return a new reference! */\n    PyObject *x;\n    int index;\n    const struct _cffi_global_s *g;\n    CTypeDescrObject *ct;\n    builder_c_t *types_builder = lib->l_types_builder;\n    const char *s = PyText_AsUTF8(name);\n    if (s == NULL)\n        return NULL;\n\n    index = search_in_globals(&types_builder->ctx, s, strlen(s));\n    if (index < 0) {\n\n        if (types_builder->included_libs != NULL) {\n            Py_ssize_t i;\n            PyObject *included_ffis = types_builder->included_ffis;\n            PyObject *included_libs = types_builder->included_libs;\n\n            if (recursion > 100) {\n                PyErr_SetString(PyExc_RuntimeError,\n                    \"recursion overflow in ffi.include() delegations\");\n                return NULL;\n            }\n\n            for (i = 0; i < PyTuple_GET_SIZE(included_libs); i++) {\n                LibObject *lib1;\n\n                lib1 = (LibObject *)PyTuple_GET_ITEM(included_libs, i);\n                if (lib1 != NULL) {\n                    x = PyDict_GetItem(lib1->l_dict, name);\n                    if (x != NULL) {\n                        Py_INCREF(x);\n                        goto found;\n                    }\n                    x = lib_build_and_cache_attr(lib1, name, recursion + 1);\n                    if (x != NULL) {\n                        Py_INCREF(x);\n                        goto found;\n                    }\n                }\n                else {\n                    FFIObject *ffi1;\n\n                    ffi1 = (FFIObject *)PyTuple_GetItem(included_ffis, i);\n                    if (ffi1 == NULL)\n                        return NULL;\n                    x = ffi_fetch_int_constant(ffi1, s, recursion + 1);\n                    if (x != NULL)\n                        goto found;\n                }\n                if (PyErr_Occurred())\n                    return NULL;\n            }\n        }\n\n        if (recursion > 0)\n            return NULL;  /* no error set, continue looking elsewhere */\n\n        PyErr_Format(PyExc_AttributeError,\n                     \"cffi library '%.200s' has no function, constant \"\n                     \"or global variable named '%.200s'\",\n                     PyText_AS_UTF8(lib->l_libname), s);\n        return NULL;\n    }\n\n    g = &types_builder->ctx.globals[index];\n\n    switch (_CFFI_GETOP(g->type_op)) {\n\n    case _CFFI_OP_CPYTHON_BLTN_V:\n        x = lib_build_cpython_func(lib, g, s, METH_VARARGS);\n        break;\n\n    case _CFFI_OP_CPYTHON_BLTN_N:\n        x = lib_build_cpython_func(lib, g, s, METH_NOARGS);\n        break;\n\n    case _CFFI_OP_CPYTHON_BLTN_O:\n        x = lib_build_cpython_func(lib, g, s, METH_O);\n        break;\n\n    case _CFFI_OP_CONSTANT_INT:\n    case _CFFI_OP_ENUM:\n    {\n        /* a constant integer whose value, in an \"unsigned long long\",\n           is obtained by calling the function at g->address */\n        x = realize_global_int(types_builder, index);\n        break;\n    }\n\n    case _CFFI_OP_CONSTANT:\n    case _CFFI_OP_DLOPEN_CONST:\n    {\n        /* a constant which is not of integer type */\n        char *data;\n        ct = realize_c_type(types_builder, types_builder->ctx.types,\n                            _CFFI_GETARG(g->type_op));\n        if (ct == NULL)\n            return NULL;\n\n        if (ct->ct_size <= 0) {\n            PyErr_Format(FFIError, \"constant '%s' is of type '%s', \"\n                         \"whose size is not known\", s, ct->ct_name);\n            return NULL;\n        }\n        if (g->address == NULL) {\n            /* for dlopen() style */\n            assert(_CFFI_GETOP(g->type_op) == _CFFI_OP_DLOPEN_CONST);\n            data = cdlopen_fetch(lib->l_libname, lib->l_libhandle, s);\n            if (data == NULL)\n                return NULL;\n        }\n        else {\n            /* The few bytes of memory we allocate here appear to leak, but\n               this is not a real leak.  Indeed, CPython never unloads its C\n               extension modules.  There is only one PyMem_Malloc() per real\n               non-integer C constant in a CFFI C extension module.  That\n               means that this PyMem_Malloc() could also have been written\n               with a static global variable generated for each OP_CONSTANT\n               defined in the C extension, and the effect would be the same\n               (but a bit more complicated).\n\n               Note that we used to do alloca(), but see issue #198.  We\n               could still do alloca(), or explicit PyMem_Free(), in some\n               cases; but there is no point and it only makes the remaining\n               less-common cases more suspicious.\n            */\n            assert(_CFFI_GETOP(g->type_op) == _CFFI_OP_CONSTANT);\n            data = PyMem_Malloc(ct->ct_size);\n            if (data == NULL) {\n                PyErr_NoMemory();\n                return NULL;\n            }\n            ((void(*)(char*))g->address)(data);\n        }\n        x = convert_to_object(data, ct);\n        Py_DECREF(ct);\n        break;\n    }\n\n    case _CFFI_OP_GLOBAL_VAR:\n    {\n        /* global variable of the exact type specified here\n           (nowadays, only used by the ABI mode or backward\n           compatibility; see _CFFI_OP_GLOBAL_VAR_F for the API mode)\n         */\n        Py_ssize_t g_size = (Py_ssize_t)g->size_or_direct_fn;\n        ct = realize_c_type(types_builder, types_builder->ctx.types,\n                            _CFFI_GETARG(g->type_op));\n        if (ct == NULL)\n            return NULL;\n        if (g_size != ct->ct_size && g_size != 0 && ct->ct_size > 0) {\n            PyErr_Format(FFIError,\n                         \"global variable '%.200s' should be %zd bytes \"\n                         \"according to the cdef, but is actually %zd\",\n                         s, ct->ct_size, g_size);\n            x = NULL;\n        }\n        else {\n            void *address = g->address;\n            if (address == NULL) {\n                /* for dlopen() style */\n                address = cdlopen_fetch(lib->l_libname, lib->l_libhandle, s);\n                if (address == NULL)\n                    return NULL;\n            }\n            x = make_global_var(name, ct, address, NULL);\n        }\n        Py_DECREF(ct);\n        break;\n    }\n\n    case _CFFI_OP_GLOBAL_VAR_F:\n        ct = realize_c_type(types_builder, types_builder->ctx.types,\n                            _CFFI_GETARG(g->type_op));\n        if (ct == NULL)\n            return NULL;\n        x = make_global_var(name, ct, NULL, (gs_fetch_addr_fn)g->address);\n        Py_DECREF(ct);\n        break;\n\n    case _CFFI_OP_DLOPEN_FUNC:\n    {\n        /* For dlopen(): the function of the given 'name'.  We use\n           dlsym() to get the address of something in the dynamic\n           library, which we interpret as being exactly a function of\n           the specified type.\n        */\n        PyObject *ct1;\n        void *address = cdlopen_fetch(lib->l_libname, lib->l_libhandle, s);\n        if (address == NULL)\n            return NULL;\n\n        ct1 = realize_c_type_or_func(types_builder,\n                                     types_builder->ctx.types,\n                                     _CFFI_GETARG(g->type_op));\n        if (ct1 == NULL)\n            return NULL;\n\n        assert(!CTypeDescr_Check(ct1));   /* must be a function */\n        x = new_simple_cdata(address, unwrap_fn_as_fnptr(ct1));\n\n        Py_DECREF(ct1);\n        break;\n    }\n\n    case _CFFI_OP_EXTERN_PYTHON:\n        /* for reading 'lib.bar' where bar is declared with extern \"Python\" */\n        ct = realize_c_type(types_builder, types_builder->ctx.types,\n                            _CFFI_GETARG(g->type_op));\n        if (ct == NULL)\n            return NULL;\n        x = convert_to_object((char *)&g->size_or_direct_fn, ct);\n        Py_DECREF(ct);\n        break;\n\n    default:\n        PyErr_Format(PyExc_NotImplementedError, \"in lib_build_attr: op=%d\",\n                     (int)_CFFI_GETOP(g->type_op));\n        return NULL;\n    }\n\n found:\n    if (x != NULL) {\n        int err = PyDict_SetItem(lib->l_dict, name, x);\n        Py_DECREF(x);\n        if (err < 0)     /* else there is still one ref left in the dict */\n            return NULL;\n    }\n    return x;\n}\n\n#define LIB_GET_OR_CACHE_ADDR(x, lib, name, error)      \\\n    do {                                                \\\n        x = PyDict_GetItem(lib->l_dict, name);          \\\n        if (x == NULL) {                                \\\n            x = lib_build_and_cache_attr(lib, name, 0); \\\n            if (x == NULL) {                            \\\n                error;                                  \\\n            }                                           \\\n        }                                               \\\n    } while (0)\n\nstatic PyObject *_lib_dir1(LibObject *lib, int ignore_global_vars)\n{\n    const struct _cffi_global_s *g = lib->l_types_builder->ctx.globals;\n    int i, count = 0, total = lib->l_types_builder->ctx.num_globals;\n    PyObject *s, *lst = PyList_New(total);\n    if (lst == NULL)\n        return NULL;\n\n    for (i = 0; i < total; i++) {\n        if (ignore_global_vars) {\n            int op = _CFFI_GETOP(g[i].type_op);\n            if (op == _CFFI_OP_GLOBAL_VAR || op == _CFFI_OP_GLOBAL_VAR_F)\n                continue;\n        }\n        s = PyText_FromString(g[i].name);\n        if (s == NULL)\n            goto error;\n        PyList_SET_ITEM(lst, count, s);\n        count++;\n    }\n    if (PyList_SetSlice(lst, count, total, NULL) < 0)\n        goto error;\n    return lst;\n\n error:\n    Py_DECREF(lst);\n    return NULL;\n}\n\nstatic PyObject *_lib_dict(LibObject *lib)\n{\n    const struct _cffi_global_s *g = lib->l_types_builder->ctx.globals;\n    int i, total = lib->l_types_builder->ctx.num_globals;\n    PyObject *name, *x, *d = PyDict_New();\n    if (d == NULL)\n        return NULL;\n\n    for (i = 0; i < total; i++) {\n        name = PyText_FromString(g[i].name);\n        if (name == NULL)\n            goto error;\n\n        LIB_GET_OR_CACHE_ADDR(x, lib, name, goto error);\n\n        if (PyDict_SetItem(d, name, x) < 0)\n            goto error;\n        Py_DECREF(name);\n    }\n    return d;\n\n error:\n    Py_XDECREF(name);\n    Py_DECREF(d);\n    return NULL;\n}\n\nstatic PyObject *lib_getattr(LibObject *lib, PyObject *name)\n{\n    const char *p;\n    PyObject *x;\n    LIB_GET_OR_CACHE_ADDR(x, lib, name, goto missing);\n\n    if (GlobSupport_Check(x)) {\n        return read_global_var((GlobSupportObject *)x);\n    }\n    Py_INCREF(x);\n    return x;\n\n missing:\n    /*** ATTRIBUTEERROR IS SET HERE ***/\n    p = PyText_AsUTF8(name);\n    if (p == NULL)\n        return NULL;\n    if (strcmp(p, \"__all__\") == 0) {\n        PyErr_Clear();\n        return _lib_dir1(lib, 1);\n    }\n    if (strcmp(p, \"__dict__\") == 0) {\n        PyErr_Clear();\n        return _lib_dict(lib);\n    }\n    if (strcmp(p, \"__class__\") == 0) {\n        PyErr_Clear();\n        x = (PyObject *)&PyModule_Type;\n        /* ^^^ used to be Py_TYPE(lib).  But HAAAAAACK!  That makes\n           help() behave correctly.  I couldn't find a more reasonable\n           way.  Urgh. */\n        Py_INCREF(x);\n        return x;\n    }\n    /* this hack is for Python 3.5, and also to give a more \n       module-like behavior */\n    if (strcmp(p, \"__name__\") == 0) {\n        PyErr_Clear();\n        return PyText_FromFormat(\"%s.lib\", PyText_AS_UTF8(lib->l_libname));\n    }\n#if PY_MAJOR_VERSION >= 3\n    if (strcmp(p, \"__loader__\") == 0 || strcmp(p, \"__spec__\") == 0) {\n        /* some more module-like behavior hacks */\n        PyErr_Clear();\n        Py_INCREF(Py_None);\n        return Py_None;\n    }\n#endif\n    return NULL;\n}\n\nstatic int lib_setattr(LibObject *lib, PyObject *name, PyObject *val)\n{\n    PyObject *x;\n    LIB_GET_OR_CACHE_ADDR(x, lib, name, return -1);\n\n    if (val == NULL) {\n        PyErr_SetString(PyExc_AttributeError, \"C attribute cannot be deleted\");\n        return -1;\n    }\n\n    if (GlobSupport_Check(x)) {\n        return write_global_var((GlobSupportObject *)x, val);\n    }\n\n    PyErr_Format(PyExc_AttributeError,\n                 \"cannot write to function or constant '%.200s'\",\n                 PyText_Check(name) ? PyText_AS_UTF8(name) : \"?\");\n    return -1;\n}\n\nstatic PyObject *lib_dir(PyObject *self, PyObject *noarg)\n{\n    return _lib_dir1((LibObject *)self, 0);\n}\n\nstatic PyMethodDef lib_methods[] = {\n    {\"__dir__\",   lib_dir,  METH_NOARGS},\n    {NULL,        NULL}           /* sentinel */\n};\n\nstatic PyTypeObject Lib_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"CompiledLib\",\n    sizeof(LibObject),\n    0,\n    (destructor)lib_dealloc,                    /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_compare */\n    (reprfunc)lib_repr,                         /* tp_repr */\n    0,                                          /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    (getattrofunc)lib_getattr,                  /* tp_getattro */\n    (setattrofunc)lib_setattr,                  /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,    /* tp_flags */\n    0,                                          /* tp_doc */\n    (traverseproc)lib_traverse,                 /* tp_traverse */\n    0,                                          /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    lib_methods,                                /* tp_methods */\n    0,                                          /* tp_members */\n    0,                                          /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    offsetof(LibObject, l_dict),                /* tp_dictoffset */\n};\n\nstatic LibObject *lib_internal_new(FFIObject *ffi, const char *module_name,\n                                   void *dlopen_libhandle)\n{\n    LibObject *lib;\n    PyObject *libname, *dict;\n\n    libname = PyText_FromString(module_name);\n    if (libname == NULL)\n        goto err1;\n\n    dict = PyDict_New();\n    if (dict == NULL)\n        goto err2;\n\n    lib = (LibObject *)PyType_GenericAlloc(&Lib_Type, 0);\n    if (lib == NULL)\n        goto err3;\n\n    lib->l_types_builder = &ffi->types_builder;\n    lib->l_dict = dict;\n    lib->l_libname = libname;\n    Py_INCREF(ffi);\n    lib->l_ffi = ffi;\n    lib->l_libhandle = dlopen_libhandle;\n    return lib;\n\n err3:\n    Py_DECREF(dict);\n err2:\n    Py_DECREF(libname);\n err1:\n    cdlopen_close_ignore_errors(dlopen_libhandle);\n    return NULL;\n}\n\nstatic PyObject *address_of_global_var(PyObject *args)\n{\n    LibObject *lib;\n    PyObject *x, *o_varname;\n    char *varname;\n\n    if (!PyArg_ParseTuple(args, \"O!s\", &Lib_Type, &lib, &varname))\n        return NULL;\n\n    /* rebuild a string from 'varname', to do typechecks and to force\n       a unicode back to a plain string (on python 2) */\n    o_varname = PyText_FromString(varname);\n    if (o_varname == NULL)\n        return NULL;\n\n    LIB_GET_OR_CACHE_ADDR(x, lib, o_varname, goto error);\n    Py_DECREF(o_varname);\n    if (GlobSupport_Check(x)) {\n        return cg_addressof_global_var((GlobSupportObject *)x);\n    }\n    else {\n        struct CPyExtFunc_s *exf = _cpyextfunc_get(x);\n        if (exf != NULL) {  /* an OP_CPYTHON_BLTN: '&func' returns a cdata */\n            PyObject *ct;\n            if (exf->direct_fn == NULL) {\n                Py_INCREF(x);    /* backward compatibility */\n                return x;\n            }\n            ct = _cpyextfunc_type(lib, exf);\n            if (ct == NULL)\n                return NULL;\n            x = new_simple_cdata(exf->direct_fn, (CTypeDescrObject *)ct);\n            Py_DECREF(ct);\n            return x;\n        }\n        if (CData_Check(x) &&  /* a constant functionptr cdata: 'f == &f' */\n                (((CDataObject *)x)->c_type->ct_flags & CT_FUNCTIONPTR) != 0) {\n            Py_INCREF(x);\n            return x;\n        }\n        else {\n            PyErr_Format(PyExc_AttributeError,\n                         \"cannot take the address of the constant '%.200s'\",\n                         varname);\n            return NULL;\n        }\n    }\n\n error:\n    Py_DECREF(o_varname);\n    return NULL;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.13.0-jlicqgsrlask3n7tsdckxmdwv6d5zp4o/spack-src/c/test_c.py": "import py\nimport pytest\n\ndef _setup_path():\n    import os, sys\n    if '__pypy__' in sys.builtin_module_names:\n        py.test.skip(\"_cffi_backend.c: not tested on top of pypy, \"\n                     \"use pypy/module/_cffi_backend/test/ instead.\")\n    sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))\n_setup_path()\nfrom _cffi_backend import *\nfrom _cffi_backend import _testfunc, _get_types, _get_common_types, __version__\n\n# ____________________________________________________________\n\nimport sys\nassert __version__ == \"1.13.0\", (\"This test_c.py file is for testing a version\"\n                                 \" of cffi that differs from the one that we\"\n                                 \" get from 'import _cffi_backend'\")\nif sys.version_info < (3,):\n    type_or_class = \"type\"\n    mandatory_b_prefix = ''\n    mandatory_u_prefix = 'u'\n    bytechr = chr\n    bitem2bchr = lambda x: x\n    class U(object):\n        def __add__(self, other):\n            return eval('u'+repr(other).replace(r'\\\\u', r'\\u')\n                                       .replace(r'\\\\U', r'\\U'))\n    u = U()\n    str2bytes = str\n    strict_compare = False\nelse:\n    type_or_class = \"class\"\n    long = int\n    unicode = str\n    unichr = chr\n    mandatory_b_prefix = 'b'\n    mandatory_u_prefix = ''\n    bytechr = lambda n: bytes([n])\n    bitem2bchr = bytechr\n    u = \"\"\n    str2bytes = lambda s: bytes(s, \"ascii\")\n    strict_compare = True\n\ndef size_of_int():\n    BInt = new_primitive_type(\"int\")\n    return sizeof(BInt)\n\ndef size_of_long():\n    BLong = new_primitive_type(\"long\")\n    return sizeof(BLong)\n\ndef size_of_ptr():\n    BInt = new_primitive_type(\"int\")\n    BPtr = new_pointer_type(BInt)\n    return sizeof(BPtr)\n\n\ndef find_and_load_library(name, flags=RTLD_NOW):\n    import ctypes.util\n    if name is None:\n        path = None\n    else:\n        path = ctypes.util.find_library(name)\n        if path is None and name == 'c':\n            assert sys.platform == 'win32'\n            assert sys.version_info >= (3,)\n            py.test.skip(\"dlopen(None) cannot work on Windows with Python 3\")\n    return load_library(path, flags)\n\ndef test_load_library():\n    x = find_and_load_library('c')\n    assert repr(x).startswith(\"<clibrary '\")\n    x = find_and_load_library('c', RTLD_NOW | RTLD_GLOBAL)\n    assert repr(x).startswith(\"<clibrary '\")\n    x = find_and_load_library('c', RTLD_LAZY)\n    assert repr(x).startswith(\"<clibrary '\")\n\ndef test_all_rtld_symbols():\n    import sys\n    FFI_DEFAULT_ABI        # these symbols must be defined\n    FFI_CDECL\n    RTLD_LAZY\n    RTLD_NOW\n    RTLD_GLOBAL\n    RTLD_LOCAL\n    if sys.platform.startswith(\"linux\"):\n        RTLD_NODELETE\n        RTLD_NOLOAD\n        RTLD_DEEPBIND\n\ndef test_new_primitive_type():\n    py.test.raises(KeyError, new_primitive_type, \"foo\")\n    p = new_primitive_type(\"signed char\")\n    assert repr(p) == \"<ctype 'signed char'>\"\n\ndef check_dir(p, expected):\n    got = [name for name in dir(p) if not name.startswith('_')]\n    assert got == sorted(expected)\n\ndef test_inspect_primitive_type():\n    p = new_primitive_type(\"signed char\")\n    assert p.kind == \"primitive\"\n    assert p.cname == \"signed char\"\n    check_dir(p, ['cname', 'kind'])\n\ndef test_cast_to_signed_char():\n    p = new_primitive_type(\"signed char\")\n    x = cast(p, -65 + 17*256)\n    assert repr(x) == \"<cdata 'signed char' -65>\"\n    assert repr(type(x)) == \"<%s '_cffi_backend.CData'>\" % type_or_class\n    assert int(x) == -65\n    x = cast(p, -66 + (1<<199)*256)\n    assert repr(x) == \"<cdata 'signed char' -66>\"\n    assert int(x) == -66\n    assert (x == cast(p, -66)) is True\n    assert (x != cast(p, -66)) is False\n    q = new_primitive_type(\"short\")\n    assert (x == cast(q, -66)) is True\n    assert (x != cast(q, -66)) is False\n\ndef test_sizeof_type():\n    py.test.raises(TypeError, sizeof, 42.5)\n    p = new_primitive_type(\"short\")\n    assert sizeof(p) == 2\n\ndef test_integer_types():\n    for name in ['signed char', 'short', 'int', 'long', 'long long']:\n        p = new_primitive_type(name)\n        size = sizeof(p)\n        min = -(1 << (8*size-1))\n        max = (1 << (8*size-1)) - 1\n        assert int(cast(p, min)) == min\n        assert int(cast(p, max)) == max\n        assert int(cast(p, min - 1)) == max\n        assert int(cast(p, max + 1)) == min\n        py.test.raises(TypeError, cast, p, None)\n        assert long(cast(p, min - 1)) == max\n        assert int(cast(p, b'\\x08')) == 8\n        assert int(cast(p, u+'\\x08')) == 8\n    for name in ['char', 'short', 'int', 'long', 'long long']:\n        p = new_primitive_type('unsigned ' + name)\n        size = sizeof(p)\n        max = (1 << (8*size)) - 1\n        assert int(cast(p, 0)) == 0\n        assert int(cast(p, max)) == max\n        assert int(cast(p, -1)) == max\n        assert int(cast(p, max + 1)) == 0\n        assert long(cast(p, -1)) == max\n        assert int(cast(p, b'\\xFE')) == 254\n        assert int(cast(p, u+'\\xFE')) == 254\n\ndef test_no_float_on_int_types():\n    p = new_primitive_type('long')\n    py.test.raises(TypeError, float, cast(p, 42))\n    py.test.raises(TypeError, complex, cast(p, 42))\n\ndef test_float_types():\n    INF = 1E200 * 1E200\n    for name in [\"float\", \"double\"]:\n        p = new_primitive_type(name)\n        assert bool(cast(p, 0)) is False      # since 1.7\n        assert bool(cast(p, -0.0)) is False   # since 1.7\n        assert bool(cast(p, 1e-42)) is True\n        assert bool(cast(p, -1e-42)) is True\n        assert bool(cast(p, INF))\n        assert bool(cast(p, -INF))\n        assert bool(cast(p, float(\"nan\")))\n        assert int(cast(p, -150)) == -150\n        assert int(cast(p, 61.91)) == 61\n        assert long(cast(p, 61.91)) == 61\n        assert type(int(cast(p, 61.91))) is int\n        assert type(int(cast(p, 1E22))) is long\n        assert type(long(cast(p, 61.91))) is long\n        assert type(long(cast(p, 1E22))) is long\n        py.test.raises(OverflowError, int, cast(p, INF))\n        py.test.raises(OverflowError, int, cast(p, -INF))\n        assert float(cast(p, 1.25)) == 1.25\n        assert float(cast(p, INF)) == INF\n        assert float(cast(p, -INF)) == -INF\n        if name == \"float\":\n            assert float(cast(p, 1.1)) != 1.1     # rounding error\n            assert float(cast(p, 1E200)) == INF   # limited range\n\n        assert cast(p, -1.1) == cast(p, -1.1)\n        assert repr(float(cast(p, -0.0))) == '-0.0'\n        assert float(cast(p, b'\\x09')) == 9.0\n        assert float(cast(p, u+'\\x09')) == 9.0\n        assert float(cast(p, True)) == 1.0\n        py.test.raises(TypeError, cast, p, None)\n\ndef test_complex_types():\n    INF = 1E200 * 1E200\n    for name in [\"float\", \"double\"]:\n        p = new_primitive_type(name + \" _Complex\")\n        assert bool(cast(p, 0)) is False\n        assert bool(cast(p, INF))\n        assert bool(cast(p, -INF))\n        assert bool(cast(p, 0j)) is False\n        assert bool(cast(p, INF*1j))\n        assert bool(cast(p, -INF*1j))\n        # \"can't convert complex to float\", like CPython's \"float(0j)\"\n        py.test.raises(TypeError, int, cast(p, -150))\n        py.test.raises(TypeError, long, cast(p, -150))\n        py.test.raises(TypeError, float, cast(p, -150))\n        assert complex(cast(p, 1.25)) == 1.25\n        assert complex(cast(p, 1.25j)) == 1.25j\n        assert complex(cast(p, complex(0,INF))) == complex(0,INF)\n        assert complex(cast(p, -INF)) == -INF\n        if name == \"float\":\n            assert complex(cast(p, 1.1j)) != 1.1j         # rounding error\n            assert complex(cast(p, 1E200+3j)) == INF+3j   # limited range\n            assert complex(cast(p, complex(3,1E200))) == complex(3,INF) # limited range\n\n        assert cast(p, -1.1j) == cast(p, -1.1j)\n        assert repr(complex(cast(p, -0.0)).real) == '-0.0'\n        #assert repr(complex(cast(p, -0j))) == '-0j'   # http://bugs.python.org/issue29602\n        assert complex(cast(p, b'\\x09')) == 9.0 + 0j\n        assert complex(cast(p, u+'\\x09')) == 9.0 + 0j\n        assert complex(cast(p, True)) == 1.0 + 0j\n        py.test.raises(TypeError, cast, p, None)\n        #\n        py.test.raises(TypeError, cast, new_primitive_type(name), 1+0j)\n        #\n        for basetype in [\"char\", \"int\", \"uint64_t\", \"float\",\n                         \"double\", \"long double\"]:\n            baseobj = cast(new_primitive_type(basetype), 65)\n            py.test.raises(TypeError, complex, baseobj)\n        #\n        BArray = new_array_type(new_pointer_type(p), 10)\n        x = newp(BArray, None)\n        x[5] = 12.34 + 56.78j\n        assert type(x[5]) is complex\n        assert abs(x[5] - (12.34 + 56.78j)) < 1e-5\n        assert (x[5] == 12.34 + 56.78j) == (name == \"double\")  # rounding error\n        #\n        class Foo:\n            def __complex__(self):\n                return 2 + 3j\n        assert complex(Foo()) == 2 + 3j\n        assert complex(cast(p, Foo())) == 2 + 3j\n    py.test.raises(TypeError, cast, new_primitive_type(\"int\"), 1+0j)\n\ndef test_character_type():\n    p = new_primitive_type(\"char\")\n    assert bool(cast(p, 'A')) is True\n    assert bool(cast(p, '\\x00')) is False    # since 1.7\n    assert cast(p, '\\x00') == cast(p, -17*256)\n    assert int(cast(p, 'A')) == 65\n    assert long(cast(p, 'A')) == 65\n    assert type(int(cast(p, 'A'))) is int\n    assert type(long(cast(p, 'A'))) is long\n    assert str(cast(p, 'A')) == repr(cast(p, 'A'))\n    assert repr(cast(p, 'A')) == \"<cdata 'char' %s'A'>\" % mandatory_b_prefix\n    assert repr(cast(p, 255)) == r\"<cdata 'char' %s'\\xff'>\" % mandatory_b_prefix\n    assert repr(cast(p, 0)) == r\"<cdata 'char' %s'\\x00'>\" % mandatory_b_prefix\n\ndef test_pointer_type():\n    p = new_primitive_type(\"int\")\n    assert repr(p) == \"<ctype 'int'>\"\n    p = new_pointer_type(p)\n    assert repr(p) == \"<ctype 'int *'>\"\n    p = new_pointer_type(p)\n    assert repr(p) == \"<ctype 'int * *'>\"\n    p = new_pointer_type(p)\n    assert repr(p) == \"<ctype 'int * * *'>\"\n\ndef test_inspect_pointer_type():\n    p1 = new_primitive_type(\"int\")\n    p2 = new_pointer_type(p1)\n    assert p2.kind == \"pointer\"\n    assert p2.cname == \"int *\"\n    assert p2.item is p1\n    check_dir(p2, ['cname', 'kind', 'item'])\n    p3 = new_pointer_type(p2)\n    assert p3.item is p2\n\ndef test_pointer_to_int():\n    BInt = new_primitive_type(\"int\")\n    py.test.raises(TypeError, newp, BInt)\n    py.test.raises(TypeError, newp, BInt, None)\n    BPtr = new_pointer_type(BInt)\n    p = newp(BPtr)\n    assert repr(p) == \"<cdata 'int *' owning %d bytes>\" % size_of_int()\n    p = newp(BPtr, None)\n    assert repr(p) == \"<cdata 'int *' owning %d bytes>\" % size_of_int()\n    p = newp(BPtr, 5000)\n    assert repr(p) == \"<cdata 'int *' owning %d bytes>\" % size_of_int()\n    q = cast(BPtr, p)\n    assert repr(q).startswith(\"<cdata 'int *' 0x\")\n    assert p == q\n    assert hash(p) == hash(q)\n    e = py.test.raises(TypeError, newp, new_array_type(BPtr, None), None)\n    assert str(e.value) == (\n        \"expected new array length or list/tuple/str, not NoneType\")\n\ndef test_pointer_bool():\n    BInt = new_primitive_type(\"int\")\n    BPtr = new_pointer_type(BInt)\n    p = cast(BPtr, 0)\n    assert bool(p) is False\n    p = cast(BPtr, 42)\n    assert bool(p) is True\n\ndef test_pointer_to_pointer():\n    BInt = new_primitive_type(\"int\")\n    BPtr = new_pointer_type(BInt)\n    BPtrPtr = new_pointer_type(BPtr)\n    p = newp(BPtrPtr, None)\n    assert repr(p) == \"<cdata 'int * *' owning %d bytes>\" % size_of_ptr()\n\ndef test_reading_pointer_to_int():\n    BInt = new_primitive_type(\"int\")\n    BPtr = new_pointer_type(BInt)\n    p = newp(BPtr, None)\n    assert p[0] == 0\n    p = newp(BPtr, 5000)\n    assert p[0] == 5000\n    with pytest.raises(IndexError):\n        p[1]\n    with pytest.raises(IndexError):\n        p[-1]\n\ndef test_reading_pointer_to_float():\n    BFloat = new_primitive_type(\"float\")\n    py.test.raises(TypeError, newp, BFloat, None)\n    BPtr = new_pointer_type(BFloat)\n    p = newp(BPtr, None)\n    assert p[0] == 0.0 and type(p[0]) is float\n    p = newp(BPtr, 1.25)\n    assert p[0] == 1.25 and type(p[0]) is float\n    p = newp(BPtr, 1.1)\n    assert p[0] != 1.1 and abs(p[0] - 1.1) < 1E-5   # rounding errors\n\ndef test_cast_float_to_int():\n    for type in [\"int\", \"unsigned int\", \"long\", \"unsigned long\",\n                 \"long long\", \"unsigned long long\"]:\n        p = new_primitive_type(type)\n        assert int(cast(p, 4.2)) == 4\n        py.test.raises(TypeError, newp, new_pointer_type(p), 4.2)\n\ndef test_newp_integer_types():\n    for name in ['signed char', 'short', 'int', 'long', 'long long']:\n        p = new_primitive_type(name)\n        pp = new_pointer_type(p)\n        size = sizeof(p)\n        min = -(1 << (8*size-1))\n        max = (1 << (8*size-1)) - 1\n        assert newp(pp, min)[0] == min\n        assert newp(pp, max)[0] == max\n        py.test.raises(OverflowError, newp, pp, min - 2 ** 32)\n        py.test.raises(OverflowError, newp, pp, min - 2 ** 64)\n        py.test.raises(OverflowError, newp, pp, max + 2 ** 32)\n        py.test.raises(OverflowError, newp, pp, max + 2 ** 64)\n        py.test.raises(OverflowError, newp, pp, min - 1)\n        py.test.raises(OverflowError, newp, pp, max + 1)\n        py.test.raises(OverflowError, newp, pp, min - 1 - 2 ** 32)\n        py.test.raises(OverflowError, newp, pp, min - 1 - 2 ** 64)\n        py.test.raises(OverflowError, newp, pp, max + 1)\n        py.test.raises(OverflowError, newp, pp, max + 1 + 2 ** 32)\n        py.test.raises(OverflowError, newp, pp, max + 1 + 2 ** 64)\n        py.test.raises(TypeError, newp, pp, 1.0)\n    for name in ['char', 'short', 'int', 'long', 'long long']:\n        p = new_primitive_type('unsigned ' + name)\n        pp = new_pointer_type(p)\n        size = sizeof(p)\n        max = (1 << (8*size)) - 1\n        assert newp(pp, 0)[0] == 0\n        assert newp(pp, max)[0] == max\n        py.test.raises(OverflowError, newp, pp, -1)\n        py.test.raises(OverflowError, newp, pp, max + 1)\n\ndef test_reading_pointer_to_char():\n    BChar = new_primitive_type(\"char\")\n    py.test.raises(TypeError, newp, BChar, None)\n    BPtr = new_pointer_type(BChar)\n    p = newp(BPtr, None)\n    assert p[0] == b'\\x00'\n    p = newp(BPtr, b'A')\n    assert p[0] == b'A'\n    py.test.raises(TypeError, newp, BPtr, 65)\n    py.test.raises(TypeError, newp, BPtr, b\"foo\")\n    py.test.raises(TypeError, newp, BPtr, u+\"foo\")\n    c = cast(BChar, b'A')\n    assert str(c) == repr(c)\n    assert int(c) == ord(b'A')\n    py.test.raises(TypeError, cast, BChar, b'foo')\n    py.test.raises(TypeError, cast, BChar, u+'foo')\n    e = py.test.raises(TypeError, newp, new_array_type(BPtr, None), 12.3)\n    assert str(e.value) == (\n        \"expected new array length or list/tuple/str, not float\")\n\ndef test_reading_pointer_to_pointer():\n    BVoidP = new_pointer_type(new_void_type())\n    BCharP = new_pointer_type(new_primitive_type(\"char\"))\n    BInt = new_primitive_type(\"int\")\n    BIntPtr = new_pointer_type(BInt)\n    BIntPtrPtr = new_pointer_type(BIntPtr)\n    q = newp(BIntPtr, 42)\n    assert q[0] == 42\n    p = newp(BIntPtrPtr, None)\n    assert p[0] is not None\n    assert p[0] == cast(BVoidP, 0)\n    assert p[0] == cast(BCharP, 0)\n    assert p[0] != None\n    assert repr(p[0]) == \"<cdata 'int *' NULL>\"\n    p[0] = q\n    assert p[0] != cast(BVoidP, 0)\n    assert p[0] != cast(BCharP, 0)\n    assert p[0][0] == 42\n    q[0] += 1\n    assert p[0][0] == 43\n    p = newp(BIntPtrPtr, q)\n    assert p[0][0] == 43\n\ndef test_load_standard_library():\n    if sys.platform == \"win32\":\n        py.test.raises(OSError, find_and_load_library, None)\n        return\n    x = find_and_load_library(None)\n    BVoidP = new_pointer_type(new_void_type())\n    assert x.load_function(BVoidP, 'strcpy')\n    py.test.raises(AttributeError, x.load_function,\n                   BVoidP, 'xxx_this_function_does_not_exist')\n    # the next one is from 'libm', not 'libc', but we assume\n    # that it is already loaded too, so it should work\n    assert x.load_function(BVoidP, 'sqrt')\n    #\n    x.close_lib()\n    py.test.raises(ValueError, x.load_function, BVoidP, 'sqrt')\n    x.close_lib()\n\ndef test_no_len_on_nonarray():\n    p = new_primitive_type(\"int\")\n    py.test.raises(TypeError, len, cast(p, 42))\n\ndef test_cmp_none():\n    p = new_primitive_type(\"int\")\n    x = cast(p, 42)\n    assert (x == None) is False\n    assert (x != None) is True\n    assert (x == [\"hello\"]) is False\n    assert (x != [\"hello\"]) is True\n    y = cast(p, 0)\n    assert (y == None) is False\n\ndef test_invalid_indexing():\n    p = new_primitive_type(\"int\")\n    x = cast(p, 42)\n    with pytest.raises(TypeError):\n        x[0]\n\ndef test_default_str():\n    BChar = new_primitive_type(\"char\")\n    x = cast(BChar, 42)\n    assert str(x) == repr(x)\n    BInt = new_primitive_type(\"int\")\n    x = cast(BInt, 42)\n    assert str(x) == repr(x)\n    BArray = new_array_type(new_pointer_type(BInt), 10)\n    x = newp(BArray, None)\n    assert str(x) == repr(x)\n\ndef test_default_unicode():\n    BInt = new_primitive_type(\"int\")\n    x = cast(BInt, 42)\n    assert unicode(x) == unicode(repr(x))\n    BArray = new_array_type(new_pointer_type(BInt), 10)\n    x = newp(BArray, None)\n    assert unicode(x) == unicode(repr(x))\n\ndef test_cast_from_cdataint():\n    BInt = new_primitive_type(\"int\")\n    x = cast(BInt, 0)\n    y = cast(new_pointer_type(BInt), x)\n    assert bool(y) is False\n    #\n    x = cast(BInt, 42)\n    y = cast(BInt, x)\n    assert int(y) == 42\n    y = cast(new_primitive_type(\"char\"), x)\n    assert int(y) == 42\n    y = cast(new_primitive_type(\"float\"), x)\n    assert float(y) == 42.0\n    #\n    z = cast(BInt, 42.5)\n    assert int(z) == 42\n    z = cast(BInt, y)\n    assert int(z) == 42\n\ndef test_void_type():\n    p = new_void_type()\n    assert p.kind == \"void\"\n    assert p.cname == \"void\"\n    check_dir(p, ['kind', 'cname'])\n\ndef test_array_type():\n    p = new_primitive_type(\"int\")\n    assert repr(p) == \"<ctype 'int'>\"\n    #\n    py.test.raises(TypeError, new_array_type, new_pointer_type(p), \"foo\")\n    py.test.raises(ValueError, new_array_type, new_pointer_type(p), -42)\n    #\n    p1 = new_array_type(new_pointer_type(p), None)\n    assert repr(p1) == \"<ctype 'int[]'>\"\n    py.test.raises(ValueError, new_array_type, new_pointer_type(p1), 42)\n    #\n    p1 = new_array_type(new_pointer_type(p), 42)\n    p2 = new_array_type(new_pointer_type(p1), 25)\n    assert repr(p2) == \"<ctype 'int[25][42]'>\"\n    p2 = new_array_type(new_pointer_type(p1), None)\n    assert repr(p2) == \"<ctype 'int[][42]'>\"\n    #\n    py.test.raises(OverflowError,\n                   new_array_type, new_pointer_type(p), sys.maxsize+1)\n    py.test.raises(OverflowError,\n                   new_array_type, new_pointer_type(p), sys.maxsize // 3)\n\ndef test_inspect_array_type():\n    p = new_primitive_type(\"int\")\n    p1 = new_array_type(new_pointer_type(p), None)\n    assert p1.kind == \"array\"\n    assert p1.cname == \"int[]\"\n    assert p1.item is p\n    assert p1.length is None\n    check_dir(p1, ['cname', 'kind', 'item', 'length'])\n    p1 = new_array_type(new_pointer_type(p), 42)\n    assert p1.kind == \"array\"\n    assert p1.cname == \"int[42]\"\n    assert p1.item is p\n    assert p1.length == 42\n    check_dir(p1, ['cname', 'kind', 'item', 'length'])\n\ndef test_array_instance():\n    LENGTH = 1423\n    p = new_primitive_type(\"int\")\n    p1 = new_array_type(new_pointer_type(p), LENGTH)\n    a = newp(p1, None)\n    assert repr(a) == \"<cdata 'int[%d]' owning %d bytes>\" % (\n        LENGTH, LENGTH * size_of_int())\n    assert len(a) == LENGTH\n    for i in range(LENGTH):\n        assert a[i] == 0\n    with pytest.raises(IndexError):\n        a[LENGTH]\n    with pytest.raises(IndexError):\n        a[-1]\n    for i in range(LENGTH):\n        a[i] = i * i + 1\n    for i in range(LENGTH):\n        assert a[i] == i * i + 1\n    with pytest.raises(IndexError) as e:\n        a[LENGTH+100] = 500\n    assert ('(expected %d < %d)' % (LENGTH+100, LENGTH)) in str(e.value)\n    py.test.raises(TypeError, int, a)\n\ndef test_array_of_unknown_length_instance():\n    p = new_primitive_type(\"int\")\n    p1 = new_array_type(new_pointer_type(p), None)\n    py.test.raises(TypeError, newp, p1, None)\n    py.test.raises(ValueError, newp, p1, -42)\n    a = newp(p1, 42)\n    assert len(a) == 42\n    for i in range(42):\n        a[i] -= i\n    for i in range(42):\n        assert a[i] == -i\n    with pytest.raises(IndexError):\n        a[42]\n    with pytest.raises(IndexError):\n        a[-1]\n    with pytest.raises(IndexError):\n        a[42] = 123\n    with pytest.raises(IndexError):\n        a[-1] = 456\n\ndef test_array_of_unknown_length_instance_with_initializer():\n    p = new_primitive_type(\"int\")\n    p1 = new_array_type(new_pointer_type(p), None)\n    a = newp(p1, list(range(42)))\n    assert len(a) == 42\n    a = newp(p1, tuple(range(142)))\n    assert len(a) == 142\n\ndef test_array_initializer():\n    p = new_primitive_type(\"int\")\n    p1 = new_array_type(new_pointer_type(p), None)\n    a = newp(p1, list(range(100, 142)))\n    for i in range(42):\n        assert a[i] == 100 + i\n    #\n    p2 = new_array_type(new_pointer_type(p), 43)\n    a = newp(p2, tuple(range(100, 142)))\n    for i in range(42):\n        assert a[i] == 100 + i\n    assert a[42] == 0      # extra uninitialized item\n\ndef test_array_add():\n    p = new_primitive_type(\"int\")\n    p1 = new_array_type(new_pointer_type(p), 5)    # int[5]\n    p2 = new_array_type(new_pointer_type(p1), 3)   # int[3][5]\n    a = newp(p2, [list(range(n, n+5)) for n in [100, 200, 300]])\n    assert repr(a) == \"<cdata 'int[3][5]' owning %d bytes>\" % (\n        3*5*size_of_int(),)\n    assert repr(a + 0).startswith(\"<cdata 'int(*)[5]' 0x\")\n    assert 0 + a == a + 0 != 1 + a == a + 1\n    assert repr(a[0]).startswith(\"<cdata 'int[5]' 0x\")\n    assert repr((a + 0)[0]).startswith(\"<cdata 'int[5]' 0x\")\n    assert repr(a[0] + 0).startswith(\"<cdata 'int *' 0x\")\n    assert type(a[0][0]) is int\n    assert type((a[0] + 0)[0]) is int\n\ndef test_array_sub():\n    BInt = new_primitive_type(\"int\")\n    BArray = new_array_type(new_pointer_type(BInt), 5)   # int[5]\n    a = newp(BArray, None)\n    p = a + 1\n    assert p - a == 1\n    assert p - (a+0) == 1\n    assert a == (p - 1)\n    BPtr = new_pointer_type(new_primitive_type(\"short\"))\n    q = newp(BPtr, None)\n    with pytest.raises(TypeError):\n        p - q\n    with pytest.raises(TypeError):\n        q - p\n    with pytest.raises(TypeError):\n        a - q\n    with pytest.raises(TypeError) as e:\n        q - a\n    assert str(e.value) == \"cannot subtract cdata 'short *' and cdata 'int *'\"\n\ndef test_ptr_sub_unaligned():\n    BInt = new_primitive_type(\"int\")\n    BIntPtr = new_pointer_type(BInt)\n    a = cast(BIntPtr, 1240)\n    for bi in range(1430, 1438):\n        b = cast(BIntPtr, bi)\n        if ((bi - 1240) % size_of_int()) == 0:\n            assert b - a == (bi - 1240) // size_of_int()\n            assert a - b == (1240 - bi) // size_of_int()\n        else:\n            with pytest.raises(ValueError):\n                b - a\n            with pytest.raises(ValueError):\n                a - b\n\ndef test_cast_primitive_from_cdata():\n    p = new_primitive_type(\"int\")\n    n = cast(p, cast(p, -42))\n    assert int(n) == -42\n    #\n    p = new_primitive_type(\"unsigned int\")\n    n = cast(p, cast(p, 42))\n    assert int(n) == 42\n    #\n    p = new_primitive_type(\"long long\")\n    n = cast(p, cast(p, -(1<<60)))\n    assert int(n) == -(1<<60)\n    #\n    p = new_primitive_type(\"unsigned long long\")\n    n = cast(p, cast(p, 1<<63))\n    assert int(n) == 1<<63\n    #\n    p = new_primitive_type(\"float\")\n    n = cast(p, cast(p, 42.5))\n    assert float(n) == 42.5\n    #\n    p = new_primitive_type(\"char\")\n    n = cast(p, cast(p, \"A\"))\n    assert int(n) == ord(\"A\")\n\ndef test_new_primitive_from_cdata():\n    p = new_primitive_type(\"int\")\n    p1 = new_pointer_type(p)\n    n = newp(p1, cast(p, -42))\n    assert n[0] == -42\n    #\n    p = new_primitive_type(\"unsigned int\")\n    p1 = new_pointer_type(p)\n    n = newp(p1, cast(p, 42))\n    assert n[0] == 42\n    #\n    p = new_primitive_type(\"float\")\n    p1 = new_pointer_type(p)\n    n = newp(p1, cast(p, 42.5))\n    assert n[0] == 42.5\n    #\n    p = new_primitive_type(\"char\")\n    p1 = new_pointer_type(p)\n    n = newp(p1, cast(p, \"A\"))\n    assert n[0] == b\"A\"\n\ndef test_cast_between_pointers():\n    BIntP = new_pointer_type(new_primitive_type(\"int\"))\n    BIntA = new_array_type(BIntP, None)\n    a = newp(BIntA, [40, 41, 42, 43, 44])\n    BShortP = new_pointer_type(new_primitive_type(\"short\"))\n    b = cast(BShortP, a)\n    c = cast(BIntP, b)\n    assert c[3] == 43\n    BLongLong = new_primitive_type(\"long long\")\n    d = cast(BLongLong, c)\n    e = cast(BIntP, d)\n    assert e[3] == 43\n    f = cast(BIntP, int(d))\n    assert f[3] == 43\n    #\n    b = cast(BShortP, 0)\n    assert not b\n    c = cast(BIntP, b)\n    assert not c\n    assert int(cast(BLongLong, c)) == 0\n\ndef test_alignof():\n    BInt = new_primitive_type(\"int\")\n    assert alignof(BInt) == sizeof(BInt)\n    BPtr = new_pointer_type(BInt)\n    assert alignof(BPtr) == sizeof(BPtr)\n    BArray = new_array_type(BPtr, None)\n    assert alignof(BArray) == alignof(BInt)\n\ndef test_new_struct_type():\n    BStruct = new_struct_type(\"foo\")\n    assert repr(BStruct) == \"<ctype 'foo'>\"\n    BStruct = new_struct_type(\"struct foo\")\n    assert repr(BStruct) == \"<ctype 'struct foo'>\"\n    BPtr = new_pointer_type(BStruct)\n    assert repr(BPtr) == \"<ctype 'struct foo *'>\"\n    py.test.raises(ValueError, sizeof, BStruct)\n    py.test.raises(ValueError, alignof, BStruct)\n\ndef test_new_union_type():\n    BUnion = new_union_type(\"union foo\")\n    assert repr(BUnion) == \"<ctype 'union foo'>\"\n    BPtr = new_pointer_type(BUnion)\n    assert repr(BPtr) == \"<ctype 'union foo *'>\"\n\ndef test_complete_struct():\n    BLong = new_primitive_type(\"long\")\n    BChar = new_primitive_type(\"char\")\n    BShort = new_primitive_type(\"short\")\n    BStruct = new_struct_type(\"struct foo\")\n    assert BStruct.kind == \"struct\"\n    assert BStruct.cname == \"struct foo\"\n    assert BStruct.fields is None\n    check_dir(BStruct, ['cname', 'kind', 'fields'])\n    #\n    complete_struct_or_union(BStruct, [('a1', BLong, -1),\n                                       ('a2', BChar, -1),\n                                       ('a3', BShort, -1)])\n    d = BStruct.fields\n    assert len(d) == 3\n    assert d[0][0] == 'a1'\n    assert d[0][1].type is BLong\n    assert d[0][1].offset == 0\n    assert d[0][1].bitshift == -1\n    assert d[0][1].bitsize == -1\n    assert d[1][0] == 'a2'\n    assert d[1][1].type is BChar\n    assert d[1][1].offset == sizeof(BLong)\n    assert d[1][1].bitshift == -1\n    assert d[1][1].bitsize == -1\n    assert d[2][0] == 'a3'\n    assert d[2][1].type is BShort\n    assert d[2][1].offset == sizeof(BLong) + sizeof(BShort)\n    assert d[2][1].bitshift == -1\n    assert d[2][1].bitsize == -1\n    assert sizeof(BStruct) == 2 * sizeof(BLong)\n    assert alignof(BStruct) == alignof(BLong)\n\ndef test_complete_union():\n    BLong = new_primitive_type(\"long\")\n    BChar = new_primitive_type(\"char\")\n    BUnion = new_union_type(\"union foo\")\n    assert BUnion.kind == \"union\"\n    assert BUnion.cname == \"union foo\"\n    assert BUnion.fields is None\n    complete_struct_or_union(BUnion, [('a1', BLong, -1),\n                                      ('a2', BChar, -1)])\n    d = BUnion.fields\n    assert len(d) == 2\n    assert d[0][0] == 'a1'\n    assert d[0][1].type is BLong\n    assert d[0][1].offset == 0\n    assert d[1][0] == 'a2'\n    assert d[1][1].type is BChar\n    assert d[1][1].offset == 0\n    assert sizeof(BUnion) == sizeof(BLong)\n    assert alignof(BUnion) == alignof(BLong)\n\ndef test_struct_instance():\n    BInt = new_primitive_type(\"int\")\n    BStruct = new_struct_type(\"struct foo\")\n    BStructPtr = new_pointer_type(BStruct)\n    p = cast(BStructPtr, 42)\n    with pytest.raises(AttributeError) as e:\n        p.a1    # opaque\n    assert str(e.value) == (\"cdata 'struct foo *' points to an opaque type: \"\n                            \"cannot read fields\")\n    with pytest.raises(AttributeError) as e:\n        p.a1 = 10    # opaque\n    assert str(e.value) == (\"cdata 'struct foo *' points to an opaque type: \"\n                            \"cannot write fields\")\n\n    complete_struct_or_union(BStruct, [('a1', BInt, -1),\n                                       ('a2', BInt, -1)])\n    p = newp(BStructPtr, None)\n    s = p[0]\n    assert s.a1 == 0\n    s.a2 = 123\n    assert s.a1 == 0\n    assert s.a2 == 123\n    with pytest.raises(OverflowError):\n        s.a1 = sys.maxsize+1\n    assert s.a1 == 0\n    with pytest.raises(AttributeError) as e:\n        p.foobar\n    assert str(e.value) == \"cdata 'struct foo *' has no field 'foobar'\"\n    with pytest.raises(AttributeError) as e:\n        p.foobar = 42\n    assert str(e.value) == \"cdata 'struct foo *' has no field 'foobar'\"\n    with pytest.raises(AttributeError) as e:\n        s.foobar\n    assert str(e.value) == \"cdata 'struct foo' has no field 'foobar'\"\n    with pytest.raises(AttributeError) as e:\n        s.foobar = 42\n    assert str(e.value) == \"cdata 'struct foo' has no field 'foobar'\"\n    j = cast(BInt, 42)\n    with pytest.raises(AttributeError) as e:\n        j.foobar\n    assert str(e.value) == \"cdata 'int' has no attribute 'foobar'\"\n    with pytest.raises(AttributeError) as e:\n        j.foobar = 42\n    assert str(e.value) == \"cdata 'int' has no attribute 'foobar'\"\n    j = cast(new_pointer_type(BInt), 42)\n    with pytest.raises(AttributeError) as e:\n        j.foobar\n    assert str(e.value) == \"cdata 'int *' has no attribute 'foobar'\"\n    with pytest.raises(AttributeError) as e:\n        j.foobar = 42\n    assert str(e.value) == \"cdata 'int *' has no attribute 'foobar'\"\n    pp = newp(new_pointer_type(BStructPtr), p)\n    with pytest.raises(AttributeError) as e:\n        pp.a1\n    assert str(e.value) == \"cdata 'struct foo * *' has no attribute 'a1'\"\n    with pytest.raises(AttributeError) as e:\n        pp.a1 = 42\n    assert str(e.value) == \"cdata 'struct foo * *' has no attribute 'a1'\"\n\ndef test_union_instance():\n    BInt = new_primitive_type(\"int\")\n    BUInt = new_primitive_type(\"unsigned int\")\n    BUnion = new_union_type(\"union bar\")\n    complete_struct_or_union(BUnion, [('a1', BInt, -1), ('a2', BUInt, -1)])\n    p = newp(new_pointer_type(BUnion), [-42])\n    bigval = -42 + (1 << (8*size_of_int()))\n    assert p.a1 == -42\n    assert p.a2 == bigval\n    p = newp(new_pointer_type(BUnion), {'a2': bigval})\n    assert p.a1 == -42\n    assert p.a2 == bigval\n    py.test.raises(OverflowError, newp, new_pointer_type(BUnion),\n                   {'a1': bigval})\n    p = newp(new_pointer_type(BUnion), [])\n    assert p.a1 == p.a2 == 0\n\ndef test_struct_pointer():\n    BInt = new_primitive_type(\"int\")\n    BStruct = new_struct_type(\"struct foo\")\n    BStructPtr = new_pointer_type(BStruct)\n    complete_struct_or_union(BStruct, [('a1', BInt, -1),\n                                       ('a2', BInt, -1)])\n    p = newp(BStructPtr, None)\n    assert p.a1 == 0      # read/write via the pointer (C equivalent: '->')\n    p.a2 = 123\n    assert p.a1 == 0\n    assert p.a2 == 123\n\ndef test_struct_init_list():\n    BVoidP = new_pointer_type(new_void_type())\n    BInt = new_primitive_type(\"int\")\n    BIntPtr = new_pointer_type(BInt)\n    BStruct = new_struct_type(\"struct foo\")\n    BStructPtr = new_pointer_type(BStruct)\n    complete_struct_or_union(BStruct, [('a1', BInt, -1),\n                                       ('a2', BInt, -1),\n                                       ('a3', BInt, -1),\n                                       ('p4', BIntPtr, -1)])\n    s = newp(BStructPtr, [123, 456])\n    assert s.a1 == 123\n    assert s.a2 == 456\n    assert s.a3 == 0\n    assert s.p4 == cast(BVoidP, 0)\n    assert s.p4 != 0\n    #\n    s = newp(BStructPtr, {'a2': 41122, 'a3': -123})\n    assert s.a1 == 0\n    assert s.a2 == 41122\n    assert s.a3 == -123\n    assert s.p4 == cast(BVoidP, 0)\n    #\n    py.test.raises(KeyError, newp, BStructPtr, {'foobar': 0})\n    #\n    p = newp(BIntPtr, 14141)\n    s = newp(BStructPtr, [12, 34, 56, p])\n    assert s.p4 == p\n    assert s.p4\n    #\n    s = newp(BStructPtr, [12, 34, 56, cast(BVoidP, 0)])\n    assert s.p4 == cast(BVoidP, 0)\n    assert not s.p4\n    #\n    py.test.raises(TypeError, newp, BStructPtr, [12, 34, 56, None])\n\ndef test_array_in_struct():\n    BInt = new_primitive_type(\"int\")\n    BStruct = new_struct_type(\"struct foo\")\n    BArrayInt5 = new_array_type(new_pointer_type(BInt), 5)\n    complete_struct_or_union(BStruct, [('a1', BArrayInt5, -1)])\n    s = newp(new_pointer_type(BStruct), [[20, 24, 27, 29, 30]])\n    assert s.a1[2] == 27\n    assert repr(s.a1).startswith(\"<cdata 'int[5]' 0x\")\n\ndef test_offsetof():\n    def offsetof(BType, fieldname):\n        return typeoffsetof(BType, fieldname)[1]\n    BInt = new_primitive_type(\"int\")\n    BStruct = new_struct_type(\"struct foo\")\n    py.test.raises(TypeError, offsetof, BInt, \"abc\")\n    py.test.raises(TypeError, offsetof, BStruct, \"abc\")\n    complete_struct_or_union(BStruct, [('abc', BInt, -1), ('def', BInt, -1)])\n    assert offsetof(BStruct, 'abc') == 0\n    assert offsetof(BStruct, 'def') == size_of_int()\n    py.test.raises(KeyError, offsetof, BStruct, \"ghi\")\n    assert offsetof(new_pointer_type(BStruct), \"def\") == size_of_int()\n\ndef test_function_type():\n    BInt = new_primitive_type(\"int\")\n    BFunc = new_function_type((BInt, BInt), BInt, False)\n    assert repr(BFunc) == \"<ctype 'int(*)(int, int)'>\"\n    BFunc2 = new_function_type((), BFunc, False)\n    assert repr(BFunc2) == \"<ctype 'int(*(*)())(int, int)'>\"\n\ndef test_inspect_function_type():\n    BInt = new_primitive_type(\"int\")\n    BFunc = new_function_type((BInt, BInt), BInt, False)\n    assert BFunc.kind == \"function\"\n    assert BFunc.cname == \"int(*)(int, int)\"\n    assert BFunc.args == (BInt, BInt)\n    assert BFunc.result is BInt\n    assert BFunc.ellipsis is False\n    assert BFunc.abi == FFI_DEFAULT_ABI\n\ndef test_function_type_taking_struct():\n    BChar = new_primitive_type(\"char\")\n    BShort = new_primitive_type(\"short\")\n    BStruct = new_struct_type(\"struct foo\")\n    complete_struct_or_union(BStruct, [('a1', BChar, -1),\n                                       ('a2', BShort, -1)])\n    BFunc = new_function_type((BStruct,), BShort, False)\n    assert repr(BFunc) == \"<ctype 'short(*)(struct foo)'>\"\n\ndef test_function_void_result():\n    BVoid = new_void_type()\n    BInt = new_primitive_type(\"int\")\n    BFunc = new_function_type((BInt, BInt), BVoid, False)\n    assert repr(BFunc) == \"<ctype 'void(*)(int, int)'>\"\n\ndef test_function_void_arg():\n    BVoid = new_void_type()\n    BInt = new_primitive_type(\"int\")\n    py.test.raises(TypeError, new_function_type, (BVoid,), BInt, False)\n\ndef test_call_function_0():\n    BSignedChar = new_primitive_type(\"signed char\")\n    BFunc0 = new_function_type((BSignedChar, BSignedChar), BSignedChar, False)\n    f = cast(BFunc0, _testfunc(0))\n    assert f(40, 2) == 42\n    assert f(-100, -100) == -200 + 256\n    py.test.raises(OverflowError, f, 128, 0)\n    py.test.raises(OverflowError, f, 0, 128)\n\ndef test_call_function_0_pretend_bool_result():\n    BSignedChar = new_primitive_type(\"signed char\")\n    BBool = new_primitive_type(\"_Bool\")\n    BFunc0 = new_function_type((BSignedChar, BSignedChar), BBool, False)\n    f = cast(BFunc0, _testfunc(0))\n    assert f(40, -39) is True\n    assert f(40, -40) is False\n    py.test.raises(ValueError, f, 40, 2)\n\ndef test_call_function_1():\n    BInt = new_primitive_type(\"int\")\n    BLong = new_primitive_type(\"long\")\n    BFunc1 = new_function_type((BInt, BLong), BLong, False)\n    f = cast(BFunc1, _testfunc(1))\n    assert f(40, 2) == 42\n    assert f(-100, -100) == -200\n    int_max = (1 << (8*size_of_int()-1)) - 1\n    long_max = (1 << (8*size_of_long()-1)) - 1\n    if int_max == long_max:\n        assert f(int_max, 1) == - int_max - 1\n    else:\n        assert f(int_max, 1) == int_max + 1\n\ndef test_call_function_2():\n    BLongLong = new_primitive_type(\"long long\")\n    BFunc2 = new_function_type((BLongLong, BLongLong), BLongLong, False)\n    f = cast(BFunc2, _testfunc(2))\n    longlong_max = (1 << (8*sizeof(BLongLong)-1)) - 1\n    assert f(longlong_max - 42, 42) == longlong_max\n    assert f(43, longlong_max - 42) == - longlong_max - 1\n\ndef test_call_function_3():\n    BFloat = new_primitive_type(\"float\")\n    BDouble = new_primitive_type(\"double\")\n    BFunc3 = new_function_type((BFloat, BDouble), BDouble, False)\n    f = cast(BFunc3, _testfunc(3))\n    assert f(1.25, 5.1) == 1.25 + 5.1     # exact\n    res = f(1.3, 5.1)\n    assert res != 6.4 and abs(res - 6.4) < 1E-5    # inexact\n\ndef test_call_function_4():\n    BFloat = new_primitive_type(\"float\")\n    BDouble = new_primitive_type(\"double\")\n    BFunc4 = new_function_type((BFloat, BDouble), BFloat, False)\n    f = cast(BFunc4, _testfunc(4))\n    res = f(1.25, 5.1)\n    assert res != 6.35 and abs(res - 6.35) < 1E-5    # inexact\n\ndef test_call_function_5():\n    BVoid = new_void_type()\n    BFunc5 = new_function_type((), BVoid, False)\n    f = cast(BFunc5, _testfunc(5))\n    f()   # did not crash\n\ndef test_call_function_6():\n    BInt = new_primitive_type(\"int\")\n    BIntPtr = new_pointer_type(BInt)\n    BFunc6 = new_function_type((BIntPtr,), BIntPtr, False)\n    f = cast(BFunc6, _testfunc(6))\n    x = newp(BIntPtr, 42)\n    res = f(x)\n    assert typeof(res) is BIntPtr\n    assert res[0] == 42 - 1000\n    #\n    BIntArray = new_array_type(BIntPtr, None)\n    BFunc6bis = new_function_type((BIntArray,), BIntPtr, False)\n    f = cast(BFunc6bis, _testfunc(6))\n    #\n    res = f([142])\n    assert typeof(res) is BIntPtr\n    assert res[0] == 142 - 1000\n    #\n    res = f((143,))\n    assert typeof(res) is BIntPtr\n    assert res[0] == 143 - 1000\n    #\n    x = newp(BIntArray, [242])\n    res = f(x)\n    assert typeof(res) is BIntPtr\n    assert res[0] == 242 - 1000\n    #\n    py.test.raises(TypeError, f, 123456)\n    py.test.raises(TypeError, f, \"foo\")\n    py.test.raises(TypeError, f, u+\"bar\")\n\ndef test_call_function_7():\n    BChar = new_primitive_type(\"char\")\n    BShort = new_primitive_type(\"short\")\n    BStruct = new_struct_type(\"struct foo\")\n    BStructPtr = new_pointer_type(BStruct)\n    complete_struct_or_union(BStruct, [('a1', BChar, -1),\n                                       ('a2', BShort, -1)])\n    BFunc7 = new_function_type((BStruct,), BShort, False)\n    f = cast(BFunc7, _testfunc(7))\n    res = f({'a1': b'A', 'a2': -4042})\n    assert res == -4042 + ord(b'A')\n    #\n    x = newp(BStructPtr, {'a1': b'A', 'a2': -4042})\n    res = f(x[0])\n    assert res == -4042 + ord(b'A')\n\ndef test_call_function_20():\n    BChar = new_primitive_type(\"char\")\n    BShort = new_primitive_type(\"short\")\n    BStruct = new_struct_type(\"struct foo\")\n    BStructPtr = new_pointer_type(BStruct)\n    complete_struct_or_union(BStruct, [('a1', BChar, -1),\n                                       ('a2', BShort, -1)])\n    BFunc20 = new_function_type((BStructPtr,), BShort, False)\n    f = cast(BFunc20, _testfunc(20))\n    x = newp(BStructPtr, {'a1': b'A', 'a2': -4042})\n    # can't pass a 'struct foo'\n    py.test.raises(TypeError, f, x[0])\n\ndef test_call_function_21():\n    BInt = new_primitive_type(\"int\")\n    BStruct = new_struct_type(\"struct foo\")\n    complete_struct_or_union(BStruct, [('a', BInt, -1),\n                                       ('b', BInt, -1),\n                                       ('c', BInt, -1),\n                                       ('d', BInt, -1),\n                                       ('e', BInt, -1),\n                                       ('f', BInt, -1),\n                                       ('g', BInt, -1),\n                                       ('h', BInt, -1),\n                                       ('i', BInt, -1),\n                                       ('j', BInt, -1)])\n    BFunc21 = new_function_type((BStruct,), BInt, False)\n    f = cast(BFunc21, _testfunc(21))\n    res = f(list(range(13, 3, -1)))\n    lst = [(n << i) for (i, n) in enumerate(range(13, 3, -1))]\n    assert res == sum(lst)\n\ndef test_call_function_22():\n    BInt = new_primitive_type(\"int\")\n    BArray10 = new_array_type(new_pointer_type(BInt), 10)\n    BStruct = new_struct_type(\"struct foo\")\n    BStructP = new_pointer_type(BStruct)\n    complete_struct_or_union(BStruct, [('a', BArray10, -1)])\n    BFunc22 = new_function_type((BStruct, BStruct), BStruct, False)\n    f = cast(BFunc22, _testfunc(22))\n    p1 = newp(BStructP, {'a': list(range(100, 110))})\n    p2 = newp(BStructP, {'a': list(range(1000, 1100, 10))})\n    res = f(p1[0], p2[0])\n    for i in range(10):\n        assert res.a[i] == p1.a[i] - p2.a[i]\n\ndef test_call_function_23():\n    BVoid = new_void_type()          # declaring the function as int(void*)\n    BVoidP = new_pointer_type(BVoid)\n    BInt = new_primitive_type(\"int\")\n    BFunc23 = new_function_type((BVoidP,), BInt, False)\n    f = cast(BFunc23, _testfunc(23))\n    res = f(b\"foo\")\n    assert res == 1000 * ord(b'f')\n    res = f(cast(BVoidP, 0))        # NULL\n    assert res == -42\n    py.test.raises(TypeError, f, None)\n    py.test.raises(TypeError, f, 0)\n    py.test.raises(TypeError, f, 0.0)\n\ndef test_call_function_23_bis():\n    # declaring the function as int(unsigned char*)\n    BUChar = new_primitive_type(\"unsigned char\")\n    BUCharP = new_pointer_type(BUChar)\n    BInt = new_primitive_type(\"int\")\n    BFunc23 = new_function_type((BUCharP,), BInt, False)\n    f = cast(BFunc23, _testfunc(23))\n    res = f(b\"foo\")\n    assert res == 1000 * ord(b'f')\n\ndef test_call_function_23_bool_array():\n    # declaring the function as int(_Bool*)\n    BBool = new_primitive_type(\"_Bool\")\n    BBoolP = new_pointer_type(BBool)\n    BInt = new_primitive_type(\"int\")\n    BFunc23 = new_function_type((BBoolP,), BInt, False)\n    f = cast(BFunc23, _testfunc(23))\n    res = f(b\"\\x01\\x01\")\n    assert res == 1000\n    py.test.raises(ValueError, f, b\"\\x02\\x02\")\n\ndef test_cannot_pass_struct_with_array_of_length_0():\n    BInt = new_primitive_type(\"int\")\n    BArray0 = new_array_type(new_pointer_type(BInt), 0)\n    BStruct = new_struct_type(\"struct foo\")\n    BStructP = new_pointer_type(BStruct)\n    complete_struct_or_union(BStruct, [('a', BArray0)])\n    BFunc = new_function_type((BStruct,), BInt, False)\n    py.test.raises(NotImplementedError, cast(BFunc, 123), cast(BStructP, 123))\n    BFunc2 = new_function_type((BInt,), BStruct, False)\n    py.test.raises(NotImplementedError, cast(BFunc2, 123), 123)\n\ndef test_call_function_9():\n    BInt = new_primitive_type(\"int\")\n    BFunc9 = new_function_type((BInt,), BInt, True)    # vararg\n    f = cast(BFunc9, _testfunc(9))\n    assert f(0) == 0\n    assert f(1, cast(BInt, 42)) == 42\n    assert f(2, cast(BInt, 40), cast(BInt, 2)) == 42\n    py.test.raises(TypeError, f, 1, 42)\n    py.test.raises(TypeError, f, 2, None)\n    # promotion of chars and shorts to ints\n    BSChar = new_primitive_type(\"signed char\")\n    BUChar = new_primitive_type(\"unsigned char\")\n    BSShort = new_primitive_type(\"short\")\n    assert f(3, cast(BSChar, -3), cast(BUChar, 200), cast(BSShort, -5)) == 192\n\ndef test_call_function_24():\n    BFloat = new_primitive_type(\"float\")\n    BFloatComplex = new_primitive_type(\"float _Complex\")\n    BFunc3 = new_function_type((BFloat, BFloat), BFloatComplex, False)\n    if 0:   # libffi returning nonsense silently, so logic disabled for now\n        f = cast(BFunc3, _testfunc(24))\n        result = f(1.25, 5.1)\n        assert type(result) == complex\n        assert result.real == 1.25   # exact\n        assert (result.imag != 2*5.1) and (abs(result.imag - 2*5.1) < 1e-5) # inexact\n    else:\n        f = cast(BFunc3, _testfunc(9))\n        py.test.raises(NotImplementedError, f, 12.3, 34.5)\n\ndef test_call_function_25():\n    BDouble = new_primitive_type(\"double\")\n    BDoubleComplex = new_primitive_type(\"double _Complex\")\n    BFunc3 = new_function_type((BDouble, BDouble), BDoubleComplex, False)\n    if 0:   # libffi returning nonsense silently, so logic disabled for now\n        f = cast(BFunc3, _testfunc(25))\n        result = f(1.25, 5.1)\n        assert type(result) == complex\n        assert result.real == 1.25   # exact\n        assert (result.imag != 2*5.1) and (abs(result.imag - 2*5.1) < 1e-10) # inexact\n    else:\n        f = cast(BFunc3, _testfunc(9))\n        py.test.raises(NotImplementedError, f, 12.3, 34.5)\n\ndef test_cannot_call_with_a_autocompleted_struct():\n    BSChar = new_primitive_type(\"signed char\")\n    BDouble = new_primitive_type(\"double\")\n    BStruct = new_struct_type(\"struct foo\")\n    BStructPtr = new_pointer_type(BStruct)\n    complete_struct_or_union(BStruct, [('c', BDouble, -1, 8),\n                                       ('a', BSChar, -1, 2),\n                                       ('b', BSChar, -1, 0)])\n    BFunc = new_function_type((BStruct,), BDouble)   # internally not callable\n    dummy_func = cast(BFunc, 42)\n    e = py.test.raises(NotImplementedError, dummy_func, \"?\")\n    msg = (\"ctype 'struct foo' not supported as argument.  It is a struct \"\n           'declared with \"...;\", but the C calling convention may depend '\n           \"on the missing fields; or, it contains anonymous struct/unions.  \"\n           \"Such structs are only supported as argument if the function is \"\n           \"'API mode' and non-variadic (i.e. declared inside ffibuilder.\"\n           \"cdef()+ffibuilder.set_source() and not taking a final '...' \"\n           \"argument)\")\n    assert str(e.value) == msg\n\ndef test_new_charp():\n    BChar = new_primitive_type(\"char\")\n    BCharP = new_pointer_type(BChar)\n    BCharA = new_array_type(BCharP, None)\n    x = newp(BCharA, 42)\n    assert len(x) == 42\n    x = newp(BCharA, b\"foobar\")\n    assert len(x) == 7\n\ndef test_load_and_call_function():\n    BChar = new_primitive_type(\"char\")\n    BCharP = new_pointer_type(BChar)\n    BLong = new_primitive_type(\"long\")\n    BFunc = new_function_type((BCharP,), BLong, False)\n    ll = find_and_load_library('c')\n    strlen = ll.load_function(BFunc, \"strlen\")\n    input = newp(new_array_type(BCharP, None), b\"foobar\")\n    assert strlen(input) == 6\n    #\n    assert strlen(b\"foobarbaz\") == 9\n    #\n    BVoidP = new_pointer_type(new_void_type())\n    strlenaddr = ll.load_function(BVoidP, \"strlen\")\n    assert strlenaddr == cast(BVoidP, strlen)\n\ndef test_read_variable():\n    ## FIXME: this test assumes glibc specific behavior, it's not compliant with C standard\n    ## https://bugs.pypy.org/issue1643\n    if not sys.platform.startswith(\"linux\"):\n        py.test.skip(\"untested\")\n    BVoidP = new_pointer_type(new_void_type())\n    ll = find_and_load_library('c')\n    stderr = ll.read_variable(BVoidP, \"stderr\")\n    assert stderr == cast(BVoidP, _testfunc(8))\n    #\n    ll.close_lib()\n    py.test.raises(ValueError, ll.read_variable, BVoidP, \"stderr\")\n\ndef test_read_variable_as_unknown_length_array():\n    ## FIXME: this test assumes glibc specific behavior, it's not compliant with C standard\n    ## https://bugs.pypy.org/issue1643\n    if not sys.platform.startswith(\"linux\"):\n        py.test.skip(\"untested\")\n    BCharP = new_pointer_type(new_primitive_type(\"char\"))\n    BArray = new_array_type(BCharP, None)\n    ll = find_and_load_library('c')\n    stderr = ll.read_variable(BArray, \"stderr\")\n    assert repr(stderr).startswith(\"<cdata 'char *' 0x\")\n    # ^^ and not 'char[]', which is basically not allowed and would crash\n\ndef test_write_variable():\n    ## FIXME: this test assumes glibc specific behavior, it's not compliant with C standard\n    ## https://bugs.pypy.org/issue1643\n    if not sys.platform.startswith(\"linux\"):\n        py.test.skip(\"untested\")\n    BVoidP = new_pointer_type(new_void_type())\n    ll = find_and_load_library('c')\n    stderr = ll.read_variable(BVoidP, \"stderr\")\n    ll.write_variable(BVoidP, \"stderr\", cast(BVoidP, 0))\n    assert ll.read_variable(BVoidP, \"stderr\") is not None\n    assert not ll.read_variable(BVoidP, \"stderr\")\n    ll.write_variable(BVoidP, \"stderr\", stderr)\n    assert ll.read_variable(BVoidP, \"stderr\") == stderr\n    #\n    ll.close_lib()\n    py.test.raises(ValueError, ll.write_variable, BVoidP, \"stderr\", stderr)\n\ndef test_callback():\n    BInt = new_primitive_type(\"int\")\n    def make_callback():\n        def cb(n):\n            return n + 1\n        BFunc = new_function_type((BInt,), BInt, False)\n        return callback(BFunc, cb, 42)    # 'cb' and 'BFunc' go out of scope\n    f = make_callback()\n    assert f(-142) == -141\n    assert repr(f).startswith(\n        \"<cdata 'int(*)(int)' calling <function \")\n    assert \"cb at 0x\" in repr(f)\n    e = py.test.raises(TypeError, f)\n    assert str(e.value) == \"'int(*)(int)' expects 1 arguments, got 0\"\n\ndef test_callback_exception():\n    try:\n        import cStringIO\n    except ImportError:\n        import io as cStringIO    # Python 3\n    import linecache\n    def matches(istr, ipattern):\n        str, pattern = istr, ipattern\n        while '$' in pattern:\n            i = pattern.index('$')\n            assert str[:i] == pattern[:i]\n            j = str.find(pattern[i+1], i)\n            assert i + 1 <= j <= str.find('\\n', i)\n            str = str[j:]\n            pattern = pattern[i+1:]\n        assert str == pattern\n        return True\n    def check_value(x):\n        if x == 10000:\n            raise ValueError(42)\n    def Zcb1(x):\n        check_value(x)\n        return x * 3\n    BShort = new_primitive_type(\"short\")\n    BFunc = new_function_type((BShort,), BShort, False)\n    f = callback(BFunc, Zcb1, -42)\n    #\n    seen = []\n    oops_result = None\n    def oops(*args):\n        seen.append(args)\n        return oops_result\n    ff = callback(BFunc, Zcb1, -42, oops)\n    #\n    orig_stderr = sys.stderr\n    orig_getline = linecache.getline\n    try:\n        linecache.getline = lambda *args: 'LINE'    # hack: speed up PyPy tests\n        sys.stderr = cStringIO.StringIO()\n        assert f(100) == 300\n        assert sys.stderr.getvalue() == ''\n        assert f(10000) == -42\n        assert matches(sys.stderr.getvalue(), \"\"\"\\\nFrom cffi callback <function$Zcb1 at 0x$>:\nTraceback (most recent call last):\n  File \"$\", line $, in Zcb1\n    $\n  File \"$\", line $, in check_value\n    $\nValueError: 42\n\"\"\")\n        sys.stderr = cStringIO.StringIO()\n        bigvalue = 20000\n        assert f(bigvalue) == -42\n        assert matches(sys.stderr.getvalue(), \"\"\"\\\nFrom cffi callback <function$Zcb1 at 0x$>:\nTrying to convert the result back to C:\nOverflowError: integer 60000 does not fit 'short'\n\"\"\")\n        sys.stderr = cStringIO.StringIO()\n        bigvalue = 20000\n        assert len(seen) == 0\n        assert ff(bigvalue) == -42\n        assert sys.stderr.getvalue() == \"\"\n        assert len(seen) == 1\n        exc, val, tb = seen[0]\n        assert exc is OverflowError\n        assert str(val) == \"integer 60000 does not fit 'short'\"\n        #\n        sys.stderr = cStringIO.StringIO()\n        bigvalue = 20000\n        del seen[:]\n        oops_result = 81\n        assert ff(bigvalue) == 81\n        oops_result = None\n        assert sys.stderr.getvalue() == \"\"\n        assert len(seen) == 1\n        exc, val, tb = seen[0]\n        assert exc is OverflowError\n        assert str(val) == \"integer 60000 does not fit 'short'\"\n        #\n        sys.stderr = cStringIO.StringIO()\n        bigvalue = 20000\n        del seen[:]\n        oops_result = \"xy\"     # not None and not an int!\n        assert ff(bigvalue) == -42\n        oops_result = None\n        assert matches(sys.stderr.getvalue(), \"\"\"\\\nFrom cffi callback <function$Zcb1 at 0x$>:\nTrying to convert the result back to C:\nOverflowError: integer 60000 does not fit 'short'\n\nDuring the call to 'onerror', another exception occurred:\n\nTypeError: $integer$\n\"\"\")\n        #\n        sys.stderr = cStringIO.StringIO()\n        seen = \"not a list\"    # this makes the oops() function crash\n        assert ff(bigvalue) == -42\n        assert matches(sys.stderr.getvalue(), \"\"\"\\\nFrom cffi callback <function$Zcb1 at 0x$>:\nTrying to convert the result back to C:\nOverflowError: integer 60000 does not fit 'short'\n\nDuring the call to 'onerror', another exception occurred:\n\nTraceback (most recent call last):\n  File \"$\", line $, in oops\n    $\nAttributeError: 'str' object has no attribute 'append'\n\"\"\")\n    finally:\n        sys.stderr = orig_stderr\n        linecache.getline = orig_getline\n\ndef test_callback_return_type():\n    for rettype in [\"signed char\", \"short\", \"int\", \"long\", \"long long\",\n                    \"unsigned char\", \"unsigned short\", \"unsigned int\",\n                    \"unsigned long\", \"unsigned long long\"]:\n        BRet = new_primitive_type(rettype)\n        def cb(n):\n            return n + 1\n        BFunc = new_function_type((BRet,), BRet)\n        f = callback(BFunc, cb, 42)\n        assert f(41) == 42\n        if rettype.startswith(\"unsigned \"):\n            min = 0\n            max = (1 << (8*sizeof(BRet))) - 1\n        else:\n            min = -(1 << (8*sizeof(BRet)-1))\n            max = (1 << (8*sizeof(BRet)-1)) - 1\n        assert f(min) == min + 1\n        assert f(max - 1) == max\n        assert f(max) == 42\n\ndef test_a_lot_of_callbacks():\n    BIGNUM = 10000\n    if 'PY_DOT_PY' in globals(): BIGNUM = 100   # tests on py.py\n    #\n    BInt = new_primitive_type(\"int\")\n    BFunc = new_function_type((BInt,), BInt, False)\n    def make_callback(m):\n        def cb(n):\n            return n + m\n        return callback(BFunc, cb, 42)    # 'cb' and 'BFunc' go out of scope\n    #\n    flist = [make_callback(i) for i in range(BIGNUM)]\n    for i, f in enumerate(flist):\n        assert f(-142) == -142 + i\n\ndef test_callback_receiving_tiny_struct():\n    BSChar = new_primitive_type(\"signed char\")\n    BInt = new_primitive_type(\"int\")\n    BStruct = new_struct_type(\"struct foo\")\n    BStructPtr = new_pointer_type(BStruct)\n    complete_struct_or_union(BStruct, [('a', BSChar, -1),\n                                       ('b', BSChar, -1)])\n    def cb(s):\n        return s.a + 10 * s.b\n    BFunc = new_function_type((BStruct,), BInt)\n    f = callback(BFunc, cb)\n    p = newp(BStructPtr, [-2, -4])\n    n = f(p[0])\n    assert n == -42\n\ndef test_callback_returning_tiny_struct():\n    BSChar = new_primitive_type(\"signed char\")\n    BInt = new_primitive_type(\"int\")\n    BStruct = new_struct_type(\"struct foo\")\n    BStructPtr = new_pointer_type(BStruct)\n    complete_struct_or_union(BStruct, [('a', BSChar, -1),\n                                       ('b', BSChar, -1)])\n    def cb(n):\n        return newp(BStructPtr, [-n, -3*n])[0]\n    BFunc = new_function_type((BInt,), BStruct)\n    f = callback(BFunc, cb)\n    s = f(10)\n    assert typeof(s) is BStruct\n    assert repr(s) == \"<cdata 'struct foo' owning 2 bytes>\"\n    assert s.a == -10\n    assert s.b == -30\n\ndef test_callback_receiving_struct():\n    BSChar = new_primitive_type(\"signed char\")\n    BInt = new_primitive_type(\"int\")\n    BDouble = new_primitive_type(\"double\")\n    BStruct = new_struct_type(\"struct foo\")\n    BStructPtr = new_pointer_type(BStruct)\n    complete_struct_or_union(BStruct, [('a', BSChar, -1),\n                                       ('b', BDouble, -1)])\n    def cb(s):\n        return s.a + int(s.b)\n    BFunc = new_function_type((BStruct,), BInt)\n    f = callback(BFunc, cb)\n    p = newp(BStructPtr, [-2, 44.444])\n    n = f(p[0])\n    assert n == 42\n\ndef test_callback_returning_struct():\n    BSChar = new_primitive_type(\"signed char\")\n    BInt = new_primitive_type(\"int\")\n    BDouble = new_primitive_type(\"double\")\n    BStruct = new_struct_type(\"struct foo\")\n    BStructPtr = new_pointer_type(BStruct)\n    complete_struct_or_union(BStruct, [('a', BSChar, -1),\n                                       ('b', BDouble, -1)])\n    def cb(n):\n        return newp(BStructPtr, [-n, 1E-42])[0]\n    BFunc = new_function_type((BInt,), BStruct)\n    f = callback(BFunc, cb)\n    s = f(10)\n    assert typeof(s) is BStruct\n    assert repr(s) in [\"<cdata 'struct foo' owning 12 bytes>\",\n                       \"<cdata 'struct foo' owning 16 bytes>\"]\n    assert s.a == -10\n    assert s.b == 1E-42\n\ndef test_callback_receiving_big_struct():\n    BInt = new_primitive_type(\"int\")\n    BStruct = new_struct_type(\"struct foo\")\n    BStructPtr = new_pointer_type(BStruct)\n    complete_struct_or_union(BStruct, [('a', BInt, -1),\n                                       ('b', BInt, -1),\n                                       ('c', BInt, -1),\n                                       ('d', BInt, -1),\n                                       ('e', BInt, -1),\n                                       ('f', BInt, -1),\n                                       ('g', BInt, -1),\n                                       ('h', BInt, -1),\n                                       ('i', BInt, -1),\n                                       ('j', BInt, -1)])\n    def cb(s):\n        for i, name in enumerate(\"abcdefghij\"):\n            assert getattr(s, name) == 13 - i\n        return 42\n    BFunc = new_function_type((BStruct,), BInt)\n    f = callback(BFunc, cb)\n    p = newp(BStructPtr, list(range(13, 3, -1)))\n    n = f(p[0])\n    assert n == 42\n\ndef test_callback_returning_big_struct():\n    BInt = new_primitive_type(\"int\")\n    BStruct = new_struct_type(\"struct foo\")\n    BStructPtr = new_pointer_type(BStruct)\n    complete_struct_or_union(BStruct, [('a', BInt, -1),\n                                       ('b', BInt, -1),\n                                       ('c', BInt, -1),\n                                       ('d', BInt, -1),\n                                       ('e', BInt, -1),\n                                       ('f', BInt, -1),\n                                       ('g', BInt, -1),\n                                       ('h', BInt, -1),\n                                       ('i', BInt, -1),\n                                       ('j', BInt, -1)])\n    def cb():\n        return newp(BStructPtr, list(range(13, 3, -1)))[0]\n    BFunc = new_function_type((), BStruct)\n    f = callback(BFunc, cb)\n    s = f()\n    assert typeof(s) is BStruct\n    assert repr(s) in [\"<cdata 'struct foo' owning 40 bytes>\",\n                       \"<cdata 'struct foo' owning 80 bytes>\"]\n    for i, name in enumerate(\"abcdefghij\"):\n        assert getattr(s, name) == 13 - i\n\ndef test_callback_returning_void():\n    BVoid = new_void_type()\n    BFunc = new_function_type((), BVoid, False)\n    def cb():\n        seen.append(42)\n    f = callback(BFunc, cb)\n    seen = []\n    f()\n    assert seen == [42]\n    py.test.raises(TypeError, callback, BFunc, cb, -42)\n\ndef test_enum_type():\n    BUInt = new_primitive_type(\"unsigned int\")\n    BEnum = new_enum_type(\"foo\", (), (), BUInt)\n    assert repr(BEnum) == \"<ctype 'foo'>\"\n    assert BEnum.kind == \"enum\"\n    assert BEnum.cname == \"foo\"\n    assert BEnum.elements == {}\n    #\n    BInt = new_primitive_type(\"int\")\n    BEnum = new_enum_type(\"enum foo\", ('def', 'c', 'ab'), (0, 1, -20), BInt)\n    assert BEnum.kind == \"enum\"\n    assert BEnum.cname == \"enum foo\"\n    assert BEnum.elements == {-20: 'ab', 0: 'def', 1: 'c'}\n    # 'elements' is not the real dict, but merely a copy\n    BEnum.elements[2] = '??'\n    assert BEnum.elements == {-20: 'ab', 0: 'def', 1: 'c'}\n    #\n    BEnum = new_enum_type(\"enum bar\", ('ab', 'cd'), (5, 5), BUInt)\n    assert BEnum.elements == {5: 'ab'}\n    assert BEnum.relements == {'ab': 5, 'cd': 5}\n\ndef test_cast_to_enum():\n    BInt = new_primitive_type(\"int\")\n    BEnum = new_enum_type(\"enum foo\", ('def', 'c', 'ab'), (0, 1, -20), BInt)\n    assert sizeof(BEnum) == sizeof(BInt)\n    e = cast(BEnum, 0)\n    assert repr(e) == \"<cdata 'enum foo' 0: def>\"\n    assert repr(cast(BEnum, -42)) == \"<cdata 'enum foo' -42>\"\n    assert repr(cast(BEnum, -20)) == \"<cdata 'enum foo' -20: ab>\"\n    assert string(e) == 'def'\n    assert string(cast(BEnum, -20)) == 'ab'\n    assert int(cast(BEnum, 1)) == 1\n    assert int(cast(BEnum, 0)) == 0\n    assert int(cast(BEnum, -242 + 2**128)) == -242\n    assert string(cast(BEnum, -242 + 2**128)) == '-242'\n    #\n    BUInt = new_primitive_type(\"unsigned int\")\n    BEnum = new_enum_type(\"enum bar\", ('def', 'c', 'ab'), (0, 1, 20), BUInt)\n    e = cast(BEnum, -1)\n    assert repr(e) == \"<cdata 'enum bar' 4294967295>\"     # unsigned int\n    #\n    BLong = new_primitive_type(\"long\")\n    BEnum = new_enum_type(\"enum baz\", (), (), BLong)\n    assert sizeof(BEnum) == sizeof(BLong)\n    e = cast(BEnum, -1)\n    assert repr(e) == \"<cdata 'enum baz' -1>\"\n\ndef test_enum_with_non_injective_mapping():\n    BInt = new_primitive_type(\"int\")\n    BEnum = new_enum_type(\"enum foo\", ('ab', 'cd'), (7, 7), BInt)\n    e = cast(BEnum, 7)\n    assert repr(e) == \"<cdata 'enum foo' 7: ab>\"\n    assert string(e) == 'ab'\n\ndef test_enum_in_struct():\n    BInt = new_primitive_type(\"int\")\n    BEnum = new_enum_type(\"enum foo\", ('def', 'c', 'ab'), (0, 1, -20), BInt)\n    BStruct = new_struct_type(\"struct bar\")\n    BStructPtr = new_pointer_type(BStruct)\n    complete_struct_or_union(BStruct, [('a1', BEnum, -1)])\n    p = newp(BStructPtr, [-20])\n    assert p.a1 == -20\n    p = newp(BStructPtr, [12])\n    assert p.a1 == 12\n    e = py.test.raises(TypeError, newp, BStructPtr, [None])\n    msg = str(e.value)\n    assert (\"an integer is required\" in msg or  # CPython\n            \"unsupported operand type for int(): 'NoneType'\" in msg or  # old PyPys\n            \"expected integer, got NoneType object\" in msg) # newer PyPys\n    with pytest.raises(TypeError):\n        p.a1 = \"def\"\n    if sys.version_info < (3,):\n        BEnum2 = new_enum_type(unicode(\"foo\"), (unicode('abc'),), (5,), BInt)\n        assert string(cast(BEnum2, 5)) == 'abc'\n        assert type(string(cast(BEnum2, 5))) is str\n\ndef test_enum_overflow():\n    max_uint = 2 ** (size_of_int()*8) - 1\n    max_int = max_uint // 2\n    max_ulong = 2 ** (size_of_long()*8) - 1\n    max_long = max_ulong // 2\n    for BPrimitive in [new_primitive_type(\"int\"),\n                       new_primitive_type(\"unsigned int\"),\n                       new_primitive_type(\"long\"),\n                       new_primitive_type(\"unsigned long\")]:\n        for x in [max_uint, max_int, max_ulong, max_long]:\n            for testcase in [x, x+1, -x-1, -x-2]:\n                if int(cast(BPrimitive, testcase)) == testcase:\n                    # fits\n                    BEnum = new_enum_type(\"foo\", (\"AA\",), (testcase,),\n                                          BPrimitive)\n                    assert int(cast(BEnum, testcase)) == testcase\n                else:\n                    # overflows\n                    py.test.raises(OverflowError, new_enum_type,\n                                   \"foo\", (\"AA\",), (testcase,), BPrimitive)\n\ndef test_callback_returning_enum():\n    BInt = new_primitive_type(\"int\")\n    BEnum = new_enum_type(\"foo\", ('def', 'c', 'ab'), (0, 1, -20), BInt)\n    def cb(n):\n        if n & 1:\n            return cast(BEnum, n)\n        else:\n            return n\n    BFunc = new_function_type((BInt,), BEnum)\n    f = callback(BFunc, cb)\n    assert f(0) == 0\n    assert f(1) == 1\n    assert f(-20) == -20\n    assert f(20) == 20\n    assert f(21) == 21\n\ndef test_callback_returning_enum_unsigned():\n    BInt = new_primitive_type(\"int\")\n    BUInt = new_primitive_type(\"unsigned int\")\n    BEnum = new_enum_type(\"foo\", ('def', 'c', 'ab'), (0, 1, 20), BUInt)\n    def cb(n):\n        if n & 1:\n            return cast(BEnum, n)\n        else:\n            return n\n    BFunc = new_function_type((BInt,), BEnum)\n    f = callback(BFunc, cb)\n    assert f(0) == 0\n    assert f(1) == 1\n    assert f(-21) == 2**32 - 21\n    assert f(20) == 20\n    assert f(21) == 21\n\ndef test_callback_returning_char():\n    BInt = new_primitive_type(\"int\")\n    BChar = new_primitive_type(\"char\")\n    def cb(n):\n        return bytechr(n)\n    BFunc = new_function_type((BInt,), BChar)\n    f = callback(BFunc, cb)\n    assert f(0) == b'\\x00'\n    assert f(255) == b'\\xFF'\n\ndef _hacked_pypy_uni4():\n    pyuni4 = {1: True, 2: False}[len(u+'\\U00012345')]\n    return 'PY_DOT_PY' in globals() and not pyuni4\n\ndef test_callback_returning_wchar_t():\n    BInt = new_primitive_type(\"int\")\n    BWChar = new_primitive_type(\"wchar_t\")\n    def cb(n):\n        if n == -1:\n            return u+'\\U00012345'\n        if n == -2:\n            raise ValueError\n        return unichr(n)\n    BFunc = new_function_type((BInt,), BWChar)\n    f = callback(BFunc, cb)\n    assert f(0) == unichr(0)\n    assert f(255) == unichr(255)\n    assert f(0x1234) == u+'\\u1234'\n    if sizeof(BWChar) == 4 and not _hacked_pypy_uni4():\n        assert f(-1) == u+'\\U00012345'\n    assert f(-2) == u+'\\x00'   # and an exception printed to stderr\n\ndef test_struct_with_bitfields():\n    BLong = new_primitive_type(\"long\")\n    BStruct = new_struct_type(\"struct foo\")\n    LONGBITS = 8 * sizeof(BLong)\n    complete_struct_or_union(BStruct, [('a1', BLong, 1),\n                                       ('a2', BLong, 2),\n                                       ('a3', BLong, 3),\n                                       ('a4', BLong, LONGBITS - 5)])\n    d = BStruct.fields\n    assert d[0][1].offset == d[1][1].offset == d[2][1].offset == 0\n    assert d[3][1].offset == sizeof(BLong)\n    def f(m, r):\n        if sys.byteorder == 'little':\n            return r\n        else:\n            return LONGBITS - m - r\n    assert d[0][1].bitshift == f(1, 0)\n    assert d[0][1].bitsize == 1\n    assert d[1][1].bitshift == f(2, 1)\n    assert d[1][1].bitsize == 2\n    assert d[2][1].bitshift == f(3, 3)\n    assert d[2][1].bitsize == 3\n    assert d[3][1].bitshift == f(LONGBITS - 5, 0)\n    assert d[3][1].bitsize == LONGBITS - 5\n    assert sizeof(BStruct) == 2 * sizeof(BLong)\n    assert alignof(BStruct) == alignof(BLong)\n\ndef test_bitfield_instance():\n    BInt = new_primitive_type(\"int\")\n    BUnsignedInt = new_primitive_type(\"unsigned int\")\n    BStruct = new_struct_type(\"struct foo\")\n    complete_struct_or_union(BStruct, [('a1', BInt, 1),\n                                       ('a2', BUnsignedInt, 2),\n                                       ('a3', BInt, 3)])\n    p = newp(new_pointer_type(BStruct), None)\n    p.a1 = -1\n    assert p.a1 == -1\n    p.a1 = 0\n    with pytest.raises(OverflowError):\n        p.a1 = 2\n    assert p.a1 == 0\n    #\n    p.a1 = -1\n    p.a2 = 3\n    p.a3 = -4\n    with pytest.raises(OverflowError):\n        p.a3 = 4\n    with pytest.raises(OverflowError) as e:\n        p.a3 = -5\n    assert str(e.value) == (\"value -5 outside the range allowed by the \"\n                            \"bit field width: -4 <= x <= 3\")\n    assert p.a1 == -1 and p.a2 == 3 and p.a3 == -4\n    #\n    # special case for convenience: \"int x:1\", while normally signed,\n    # allows also setting the value \"1\" (it still gets read back as -1)\n    p.a1 = 1\n    assert p.a1 == -1\n    with pytest.raises(OverflowError) as e:\n        p.a1 = -2\n    assert str(e.value) == (\"value -2 outside the range allowed by the \"\n                            \"bit field width: -1 <= x <= 1\")\n\ndef test_bitfield_instance_init():\n    BInt = new_primitive_type(\"int\")\n    BStruct = new_struct_type(\"struct foo\")\n    complete_struct_or_union(BStruct, [('a1', BInt, 1)])\n    p = newp(new_pointer_type(BStruct), [-1])\n    assert p.a1 == -1\n    p = newp(new_pointer_type(BStruct), {'a1': -1})\n    assert p.a1 == -1\n    #\n    BUnion = new_union_type(\"union bar\")\n    complete_struct_or_union(BUnion, [('a1', BInt, 1)])\n    p = newp(new_pointer_type(BUnion), [-1])\n    assert p.a1 == -1\n\ndef test_weakref():\n    import _weakref\n    BInt = new_primitive_type(\"int\")\n    BPtr = new_pointer_type(BInt)\n    rlist = [_weakref.ref(BInt),\n             _weakref.ref(newp(BPtr, 42)),\n             _weakref.ref(cast(BPtr, 42)),\n             _weakref.ref(cast(BInt, 42)),\n             _weakref.ref(buffer(newp(BPtr, 42))),\n             ]\n    for i in range(5):\n        import gc; gc.collect()\n        if [r() for r in rlist] == [None for r in rlist]:\n            break\n\ndef test_no_inheritance():\n    BInt = new_primitive_type(\"int\")\n    try:\n        class foo(type(BInt)): pass\n    except TypeError:\n        pass\n    else:\n        raise AssertionError\n    x = cast(BInt, 42)\n    try:\n        class foo(type(x)): pass\n    except TypeError:\n        pass\n    else:\n        raise AssertionError\n\ndef test_assign_string():\n    BChar = new_primitive_type(\"char\")\n    BArray1 = new_array_type(new_pointer_type(BChar), 5)\n    BArray2 = new_array_type(new_pointer_type(BArray1), 5)\n    a = newp(BArray2, [b\"abc\", b\"de\", b\"ghij\"])\n    assert string(a[1]) == b\"de\"\n    assert string(a[2]) == b\"ghij\"\n    a[2] = b\".\"\n    assert string(a[2]) == b\".\"\n    a[2] = b\"12345\"\n    assert string(a[2]) == b\"12345\"\n    with pytest.raises(IndexError) as e:\n        a[2] = b\"123456\"\n    assert 'char[5]' in str(e.value)\n    assert 'got 6 characters' in str(e.value)\n\ndef test_add_error():\n    x = cast(new_primitive_type(\"int\"), 42)\n    with pytest.raises(TypeError):\n        x + 1\n    with pytest.raises(TypeError):\n        x - 1\n\ndef test_void_errors():\n    py.test.raises(ValueError, alignof, new_void_type())\n    py.test.raises(TypeError, newp, new_pointer_type(new_void_type()), None)\n\ndef test_too_many_items():\n    BChar = new_primitive_type(\"char\")\n    BArray = new_array_type(new_pointer_type(BChar), 5)\n    py.test.raises(IndexError, newp, BArray, tuple(b'123456'))\n    py.test.raises(IndexError, newp, BArray, list(b'123456'))\n    py.test.raises(IndexError, newp, BArray, b'123456')\n    BStruct = new_struct_type(\"struct foo\")\n    complete_struct_or_union(BStruct, [])\n    py.test.raises(TypeError, newp, new_pointer_type(BStruct), b'')\n    py.test.raises(ValueError, newp, new_pointer_type(BStruct), [b'1'])\n\ndef test_more_type_errors():\n    BInt = new_primitive_type(\"int\")\n    BChar = new_primitive_type(\"char\")\n    BArray = new_array_type(new_pointer_type(BChar), 5)\n    py.test.raises(TypeError, newp, BArray, 12.34)\n    BArray = new_array_type(new_pointer_type(BInt), 5)\n    py.test.raises(TypeError, newp, BArray, 12.34)\n    BFloat = new_primitive_type(\"float\")\n    py.test.raises(TypeError, cast, BFloat, newp(BArray, None))\n\ndef test_more_overflow_errors():\n    BUInt = new_primitive_type(\"unsigned int\")\n    py.test.raises(OverflowError, newp, new_pointer_type(BUInt), -1)\n    py.test.raises(OverflowError, newp, new_pointer_type(BUInt), 2**32)\n\ndef test_newp_copying():\n    \"\"\"Test that we can do newp(<type>, <cdata of the given type>) for most\n    types, including same-type arrays.\n    \"\"\"\n    BInt = new_primitive_type(\"int\")\n    p = newp(new_pointer_type(BInt), cast(BInt, 42))\n    assert p[0] == 42\n    #\n    BUInt = new_primitive_type(\"unsigned int\")\n    p = newp(new_pointer_type(BUInt), cast(BUInt, 42))\n    assert p[0] == 42\n    #\n    BChar = new_primitive_type(\"char\")\n    p = newp(new_pointer_type(BChar), cast(BChar, '!'))\n    assert p[0] == b'!'\n    #\n    BFloat = new_primitive_type(\"float\")\n    p = newp(new_pointer_type(BFloat), cast(BFloat, 12.25))\n    assert p[0] == 12.25\n    #\n    BStruct = new_struct_type(\"struct foo_s\")\n    BStructPtr = new_pointer_type(BStruct)\n    complete_struct_or_union(BStruct, [('a1', BInt, -1)])\n    s1 = newp(BStructPtr, [42])\n    p1 = newp(new_pointer_type(BStructPtr), s1)\n    assert p1[0] == s1\n    #\n    BArray = new_array_type(new_pointer_type(BInt), None)\n    a1 = newp(BArray, [1, 2, 3, 4])\n    py.test.raises(TypeError, newp, BArray, a1)\n    BArray6 = new_array_type(new_pointer_type(BInt), 6)\n    a1 = newp(BArray6, [10, 20, 30])\n    a2 = newp(BArray6, a1)\n    assert list(a2) == [10, 20, 30, 0, 0, 0]\n    #\n    s1 = newp(BStructPtr, [42])\n    s2 = newp(BStructPtr, s1[0])\n    assert s2.a1 == 42\n    #\n    BUnion = new_union_type(\"union foo_u\")\n    BUnionPtr = new_pointer_type(BUnion)\n    complete_struct_or_union(BUnion, [('a1', BInt, -1)])\n    u1 = newp(BUnionPtr, [42])\n    u2 = newp(BUnionPtr, u1[0])\n    assert u2.a1 == 42\n    #\n    BFunc = new_function_type((BInt,), BUInt)\n    p1 = cast(BFunc, 42)\n    p2 = newp(new_pointer_type(BFunc), p1)\n    assert p2[0] == p1\n\ndef test_string():\n    BChar = new_primitive_type(\"char\")\n    assert string(cast(BChar, 42)) == b'*'\n    assert string(cast(BChar, 0)) == b'\\x00'\n    BCharP = new_pointer_type(BChar)\n    BArray = new_array_type(BCharP, 10)\n    a = newp(BArray, b\"hello\")\n    assert len(a) == 10\n    assert string(a) == b\"hello\"\n    p = a + 2\n    assert string(p) == b\"llo\"\n    assert string(newp(new_array_type(BCharP, 4), b\"abcd\")) == b\"abcd\"\n    py.test.raises(RuntimeError, string, cast(BCharP, 0))\n    assert string(a, 4) == b\"hell\"\n    assert string(a, 5) == b\"hello\"\n    assert string(a, 6) == b\"hello\"\n\ndef test_string_byte():\n    BByte = new_primitive_type(\"signed char\")\n    assert string(cast(BByte, 42)) == b'*'\n    assert string(cast(BByte, 0)) == b'\\x00'\n    BArray = new_array_type(new_pointer_type(BByte), None)\n    a = newp(BArray, [65, 66, 67])\n    assert type(string(a)) is bytes and string(a) == b'ABC'\n    #\n    BByte = new_primitive_type(\"unsigned char\")\n    assert string(cast(BByte, 42)) == b'*'\n    assert string(cast(BByte, 0)) == b'\\x00'\n    BArray = new_array_type(new_pointer_type(BByte), None)\n    a = newp(BArray, [65, 66, 67])\n    assert type(string(a)) is bytes and string(a) == b'ABC'\n    if 'PY_DOT_PY' not in globals() and sys.version_info < (3,):\n        assert string(a, 8).startswith(b'ABC')  # may contain additional garbage\n\ndef test_string_wchar():\n    for typename in [\"wchar_t\", \"char16_t\", \"char32_t\"]:\n        _test_string_wchar_variant(typename)\n\ndef _test_string_wchar_variant(typename):\n    BWChar = new_primitive_type(typename)\n    assert string(cast(BWChar, 42)) == u+'*'\n    assert string(cast(BWChar, 0x4253)) == u+'\\u4253'\n    assert string(cast(BWChar, 0)) == u+'\\x00'\n    BArray = new_array_type(new_pointer_type(BWChar), None)\n    a = newp(BArray, [u+'A', u+'B', u+'C'])\n    assert type(string(a)) is unicode and string(a) == u+'ABC'\n    if 'PY_DOT_PY' not in globals() and sys.version_info < (3,):\n        try:\n            # may contain additional garbage\n            assert string(a, 8).startswith(u+'ABC')\n        except ValueError:    # garbage contains values > 0x10FFFF\n            assert sizeof(BWChar) == 4\n\ndef test_string_typeerror():\n    BShort = new_primitive_type(\"short\")\n    BArray = new_array_type(new_pointer_type(BShort), None)\n    a = newp(BArray, [65, 66, 67])\n    py.test.raises(TypeError, string, a)\n\ndef test_bug_convert_to_ptr():\n    BChar = new_primitive_type(\"char\")\n    BCharP = new_pointer_type(BChar)\n    BDouble = new_primitive_type(\"double\")\n    x = cast(BDouble, 42)\n    py.test.raises(TypeError, newp, new_pointer_type(BCharP), x)\n\ndef test_set_struct_fields():\n    BChar = new_primitive_type(\"char\")\n    BCharP = new_pointer_type(BChar)\n    BCharArray10 = new_array_type(BCharP, 10)\n    BStruct = new_struct_type(\"struct foo\")\n    BStructPtr = new_pointer_type(BStruct)\n    complete_struct_or_union(BStruct, [('a1', BCharArray10, -1)])\n    p = newp(BStructPtr, None)\n    assert string(p.a1) == b''\n    p.a1 = b'foo'\n    assert string(p.a1) == b'foo'\n    assert list(p.a1) == [b'f', b'o', b'o'] + [b'\\x00'] * 7\n    p.a1 = [b'x', b'y']\n    assert string(p.a1) == b'xyo'\n\ndef test_invalid_function_result_types():\n    BFunc = new_function_type((), new_void_type())\n    BArray = new_array_type(new_pointer_type(BFunc), 5)        # works\n    new_function_type((), BFunc)    # works\n    new_function_type((), new_primitive_type(\"int\"))\n    new_function_type((), new_pointer_type(BFunc))\n    BUnion = new_union_type(\"union foo_u\")\n    complete_struct_or_union(BUnion, [])\n    BFunc = new_function_type((), BUnion)\n    py.test.raises(NotImplementedError, cast(BFunc, 123))\n    py.test.raises(TypeError, new_function_type, (), BArray)\n\ndef test_struct_return_in_func():\n    BChar = new_primitive_type(\"char\")\n    BShort = new_primitive_type(\"short\")\n    BFloat = new_primitive_type(\"float\")\n    BDouble = new_primitive_type(\"double\")\n    BInt = new_primitive_type(\"int\")\n    BStruct = new_struct_type(\"struct foo_s\")\n    complete_struct_or_union(BStruct, [('a1', BChar, -1),\n                                       ('a2', BShort, -1)])\n    BFunc10 = new_function_type((BInt,), BStruct)\n    f = cast(BFunc10, _testfunc(10))\n    s = f(40)\n    assert repr(s) == \"<cdata 'struct foo_s' owning 4 bytes>\"\n    assert s.a1 == bytechr(40)\n    assert s.a2 == 40 * 40\n    #\n    BStruct11 = new_struct_type(\"struct test11\")\n    complete_struct_or_union(BStruct11, [('a1', BInt, -1),\n                                         ('a2', BInt, -1)])\n    BFunc11 = new_function_type((BInt,), BStruct11)\n    f = cast(BFunc11, _testfunc(11))\n    s = f(40)\n    assert repr(s) == \"<cdata 'struct test11' owning 8 bytes>\"\n    assert s.a1 == 40\n    assert s.a2 == 40 * 40\n    #\n    BStruct12 = new_struct_type(\"struct test12\")\n    complete_struct_or_union(BStruct12, [('a1', BDouble, -1),\n                                         ])\n    BFunc12 = new_function_type((BInt,), BStruct12)\n    f = cast(BFunc12, _testfunc(12))\n    s = f(40)\n    assert repr(s) == \"<cdata 'struct test12' owning 8 bytes>\"\n    assert s.a1 == 40.0\n    #\n    BStruct13 = new_struct_type(\"struct test13\")\n    complete_struct_or_union(BStruct13, [('a1', BInt, -1),\n                                         ('a2', BInt, -1),\n                                         ('a3', BInt, -1)])\n    BFunc13 = new_function_type((BInt,), BStruct13)\n    f = cast(BFunc13, _testfunc(13))\n    s = f(40)\n    assert repr(s) == \"<cdata 'struct test13' owning 12 bytes>\"\n    assert s.a1 == 40\n    assert s.a2 == 40 * 40\n    assert s.a3 == 40 * 40 * 40\n    #\n    BStruct14 = new_struct_type(\"struct test14\")\n    complete_struct_or_union(BStruct14, [('a1', BFloat, -1),\n                                         ])\n    BFunc14 = new_function_type((BInt,), BStruct14)\n    f = cast(BFunc14, _testfunc(14))\n    s = f(40)\n    assert repr(s) == \"<cdata 'struct test14' owning 4 bytes>\"\n    assert s.a1 == 40.0\n    #\n    BStruct15 = new_struct_type(\"struct test15\")\n    complete_struct_or_union(BStruct15, [('a1', BFloat, -1),\n                                         ('a2', BInt, -1)])\n    BFunc15 = new_function_type((BInt,), BStruct15)\n    f = cast(BFunc15, _testfunc(15))\n    s = f(40)\n    assert repr(s) == \"<cdata 'struct test15' owning 8 bytes>\"\n    assert s.a1 == 40.0\n    assert s.a2 == 40 * 40\n    #\n    BStruct16 = new_struct_type(\"struct test16\")\n    complete_struct_or_union(BStruct16, [('a1', BFloat, -1),\n                                         ('a2', BFloat, -1)])\n    BFunc16 = new_function_type((BInt,), BStruct16)\n    f = cast(BFunc16, _testfunc(16))\n    s = f(40)\n    assert repr(s) == \"<cdata 'struct test16' owning 8 bytes>\"\n    assert s.a1 == 40.0\n    assert s.a2 == -40.0\n    #\n    BStruct17 = new_struct_type(\"struct test17\")\n    complete_struct_or_union(BStruct17, [('a1', BInt, -1),\n                                         ('a2', BFloat, -1)])\n    BFunc17 = new_function_type((BInt,), BStruct17)\n    f = cast(BFunc17, _testfunc(17))\n    s = f(40)\n    assert repr(s) == \"<cdata 'struct test17' owning 8 bytes>\"\n    assert s.a1 == 40\n    assert s.a2 == 40.0 * 40.0\n    #\n    BStruct17Ptr = new_pointer_type(BStruct17)\n    BFunc18 = new_function_type((BStruct17Ptr,), BInt)\n    f = cast(BFunc18, _testfunc(18))\n    x = f([[40, 2.5]])\n    assert x == 42\n    x = f([{'a2': 43.1}])\n    assert x == 43\n\ndef test_cast_with_functionptr():\n    BFunc = new_function_type((), new_void_type())\n    BFunc2 = new_function_type((), new_primitive_type(\"short\"))\n    BCharP = new_pointer_type(new_primitive_type(\"char\"))\n    BIntP = new_pointer_type(new_primitive_type(\"int\"))\n    BStruct = new_struct_type(\"struct foo\")\n    BStructPtr = new_pointer_type(BStruct)\n    complete_struct_or_union(BStruct, [('a1', BFunc, -1)])\n    newp(BStructPtr, [cast(BFunc, 0)])\n    newp(BStructPtr, [cast(BCharP, 0)])\n    py.test.raises(TypeError, newp, BStructPtr, [cast(BIntP, 0)])\n    py.test.raises(TypeError, newp, BStructPtr, [cast(BFunc2, 0)])\n\ndef test_wchar():\n    _test_wchar_variant(\"wchar_t\")\n    if sys.platform.startswith(\"linux\"):\n        BWChar = new_primitive_type(\"wchar_t\")\n        assert sizeof(BWChar) == 4\n        # wchar_t is often signed on Linux, but not always (e.g. on ARM)\n        assert int(cast(BWChar, -1)) in (-1, 4294967295)\n\ndef test_char16():\n    BChar16 = new_primitive_type(\"char16_t\")\n    assert sizeof(BChar16) == 2\n    _test_wchar_variant(\"char16_t\")\n    assert int(cast(BChar16, -1)) == 0xffff       # always unsigned\n\ndef test_char32():\n    BChar32 = new_primitive_type(\"char32_t\")\n    assert sizeof(BChar32) == 4\n    _test_wchar_variant(\"char32_t\")\n    assert int(cast(BChar32, -1)) == 0xffffffff   # always unsigned\n\ndef _test_wchar_variant(typename):\n    BWChar = new_primitive_type(typename)\n    BInt = new_primitive_type(\"int\")\n    pyuni4 = {1: True, 2: False}[len(u+'\\U00012345')]\n    wchar4 = {2: False, 4: True}[sizeof(BWChar)]\n    assert str(cast(BWChar, 0x45)) == \"<cdata '%s' %s'E'>\" % (\n        typename, mandatory_u_prefix)\n    assert str(cast(BWChar, 0x1234)) == \"<cdata '%s' %s'\\u1234'>\" % (\n        typename, mandatory_u_prefix)\n    if not _hacked_pypy_uni4():\n        if wchar4:\n            x = cast(BWChar, 0x12345)\n            assert str(x) == \"<cdata '%s' %s'\\U00012345'>\" % (\n                typename, mandatory_u_prefix)\n            assert int(x) == 0x12345\n        else:\n            x = cast(BWChar, 0x18345)\n            assert str(x) == \"<cdata '%s' %s'\\u8345'>\" % (\n                typename, mandatory_u_prefix)\n            assert int(x) == 0x8345\n    #\n    BWCharP = new_pointer_type(BWChar)\n    BStruct = new_struct_type(\"struct foo_s\")\n    BStructPtr = new_pointer_type(BStruct)\n    complete_struct_or_union(BStruct, [('a1', BWChar, -1),\n                                       ('a2', BWCharP, -1)])\n    s = newp(BStructPtr)\n    s.a1 = u+'\\x00'\n    assert s.a1 == u+'\\x00'\n    with pytest.raises(TypeError):\n        s.a1 = b'a'\n    with pytest.raises(TypeError):\n        s.a1 = bytechr(0xFF)\n    s.a1 = u+'\\u1234'\n    assert s.a1 == u+'\\u1234'\n    if pyuni4:\n        if wchar4:\n            s.a1 = u+'\\U00012345'\n            assert s.a1 == u+'\\U00012345'\n    elif wchar4:\n        if not _hacked_pypy_uni4():\n            s.a1 = cast(BWChar, 0x12345)\n            assert s.a1 == u+'\\ud808\\udf45'\n            s.a1 = u+'\\ud807\\udf44'\n            assert s.a1 == u+'\\U00011f44'\n    else:\n        with pytest.raises(TypeError):\n            s.a1 = u+'\\U00012345'\n    #\n    BWCharArray = new_array_type(BWCharP, None)\n    a = newp(BWCharArray, u+'hello \\u1234 world')\n    assert len(a) == 14   # including the final null\n    assert string(a) == u+'hello \\u1234 world'\n    a[13] = u+'!'\n    assert string(a) == u+'hello \\u1234 world!'\n    assert str(a) == repr(a)\n    assert a[6] == u+'\\u1234'\n    a[6] = u+'-'\n    assert string(a) == u+'hello - world!'\n    assert str(a) == repr(a)\n    #\n    if wchar4 and not _hacked_pypy_uni4():\n        u1 = u+'\\U00012345\\U00012346\\U00012347'\n        a = newp(BWCharArray, u1)\n        assert len(a) == 4\n        assert string(a) == u1\n        assert len(list(a)) == 4\n        expected = [u+'\\U00012345', u+'\\U00012346', u+'\\U00012347', unichr(0)]\n        assert list(a) == expected\n        got = [a[i] for i in range(4)]\n        assert got == expected\n        with pytest.raises(IndexError):\n            a[4]\n    #\n    w = cast(BWChar, 'a')\n    assert repr(w) == \"<cdata '%s' %s'a'>\" % (typename, mandatory_u_prefix)\n    assert str(w) == repr(w)\n    assert string(w) == u+'a'\n    assert int(w) == ord('a')\n    w = cast(BWChar, 0x1234)\n    assert repr(w) == \"<cdata '%s' %s'\\u1234'>\" % (typename, mandatory_u_prefix)\n    assert str(w) == repr(w)\n    assert string(w) == u+'\\u1234'\n    assert int(w) == 0x1234\n    w = cast(BWChar, u+'\\u8234')\n    assert repr(w) == \"<cdata '%s' %s'\\u8234'>\" % (typename, mandatory_u_prefix)\n    assert str(w) == repr(w)\n    assert string(w) == u+'\\u8234'\n    assert int(w) == 0x8234\n    w = cast(BInt, u+'\\u1234')\n    assert repr(w) == \"<cdata 'int' 4660>\"\n    if wchar4 and not _hacked_pypy_uni4():\n        w = cast(BWChar, u+'\\U00012345')\n        assert repr(w) == \"<cdata '%s' %s'\\U00012345'>\" % (\n            typename, mandatory_u_prefix)\n        assert str(w) == repr(w)\n        assert string(w) == u+'\\U00012345'\n        assert int(w) == 0x12345\n        w = cast(BInt, u+'\\U00012345')\n        assert repr(w) == \"<cdata 'int' 74565>\"\n    py.test.raises(TypeError, cast, BInt, u+'')\n    py.test.raises(TypeError, cast, BInt, u+'XX')\n    assert int(cast(BInt, u+'a')) == ord('a')\n    #\n    a = newp(BWCharArray, u+'hello - world')\n    p = cast(BWCharP, a)\n    assert string(p) == u+'hello - world'\n    p[6] = u+'\\u2345'\n    assert string(p) == u+'hello \\u2345 world'\n    #\n    s = newp(BStructPtr, [u+'\\u1234', p])\n    assert s.a1 == u+'\\u1234'\n    assert s.a2 == p\n    assert str(s.a2) == repr(s.a2)\n    assert string(s.a2) == u+'hello \\u2345 world'\n    #\n    q = cast(BWCharP, 0)\n    assert str(q) == repr(q)\n    py.test.raises(RuntimeError, string, q)\n    #\n    def cb(p):\n        assert repr(p).startswith(\"<cdata '%s *' 0x\" % typename)\n        return len(string(p))\n    BFunc = new_function_type((BWCharP,), BInt, False)\n    f = callback(BFunc, cb, -42)\n    assert f(u+'a\\u1234b') == 3\n    #\n    if wchar4 and not pyuni4 and not _hacked_pypy_uni4():\n        # try out-of-range wchar_t values\n        x = cast(BWChar, 1114112)\n        py.test.raises(ValueError, string, x)\n        x = cast(BWChar, -1)\n        py.test.raises(ValueError, string, x)\n\ndef test_wchar_variants_mix():\n    BWChar  = new_primitive_type(\"wchar_t\")\n    BChar16 = new_primitive_type(\"char16_t\")\n    BChar32 = new_primitive_type(\"char32_t\")\n    assert int(cast(BChar32, cast(BChar16, -2))) == 0xfffe\n    assert int(cast(BWChar, cast(BChar16, -2))) == 0xfffe\n    assert int(cast(BChar16, cast(BChar32, 0x0001f345))) == 0xf345\n    assert int(cast(BChar16, cast(BWChar, 0x0001f345))) == 0xf345\n    #\n    BChar16A = new_array_type(new_pointer_type(BChar16), None)\n    BChar32A = new_array_type(new_pointer_type(BChar32), None)\n    x = cast(BChar32, 'A')\n    py.test.raises(TypeError, newp, BChar16A, [x])\n    x = cast(BChar16, 'A')\n    py.test.raises(TypeError, newp, BChar32A, [x])\n    #\n    a = newp(BChar16A, u+'\\U00012345')\n    assert len(a) == 3\n    a = newp(BChar32A, u+'\\U00012345')\n    assert len(a) == 2   # even if the Python unicode string above is 2 chars\n\ndef test_keepalive_struct():\n    # exception to the no-keepalive rule: p=newp(BStructPtr) returns a\n    # pointer owning the memory, and p[0] returns a pointer to the\n    # struct that *also* owns the memory\n    BStruct = new_struct_type(\"struct foo\")\n    BStructPtr = new_pointer_type(BStruct)\n    complete_struct_or_union(BStruct, [('a1', new_primitive_type(\"int\"), -1),\n                                       ('a2', new_primitive_type(\"int\"), -1),\n                                       ('a3', new_primitive_type(\"int\"), -1)])\n    p = newp(BStructPtr)\n    assert repr(p) == \"<cdata 'struct foo *' owning 12 bytes>\"\n    q = p[0]\n    assert repr(q) == \"<cdata 'struct foo' owning 12 bytes>\"\n    q.a1 = 123456\n    assert p.a1 == 123456\n    r = cast(BStructPtr, p)\n    assert repr(r[0]).startswith(\"<cdata 'struct foo &' 0x\")\n    del p\n    import gc; gc.collect()\n    assert q.a1 == 123456\n    assert repr(q) == \"<cdata 'struct foo' owning 12 bytes>\"\n    assert q.a1 == 123456\n\ndef test_nokeepalive_struct():\n    BStruct = new_struct_type(\"struct foo\")\n    BStructPtr = new_pointer_type(BStruct)\n    BStructPtrPtr = new_pointer_type(BStructPtr)\n    complete_struct_or_union(BStruct, [('a1', new_primitive_type(\"int\"), -1)])\n    p = newp(BStructPtr)\n    pp = newp(BStructPtrPtr)\n    pp[0] = p\n    s = pp[0][0]\n    assert repr(s).startswith(\"<cdata 'struct foo &' 0x\")\n\ndef test_owning_repr():\n    BInt = new_primitive_type(\"int\")\n    BArray = new_array_type(new_pointer_type(BInt), None)   # int[]\n    p = newp(BArray, 7)\n    assert repr(p) == \"<cdata 'int[]' owning 28 bytes>\"\n    assert sizeof(p) == 28\n    #\n    BArray = new_array_type(new_pointer_type(BInt), 7)   # int[7]\n    p = newp(BArray, None)\n    assert repr(p) == \"<cdata 'int[7]' owning 28 bytes>\"\n    assert sizeof(p) == 28\n\ndef test_cannot_dereference_void():\n    BVoidP = new_pointer_type(new_void_type())\n    p = cast(BVoidP, 123456)\n    with pytest.raises(TypeError):\n        p[0]\n    p = cast(BVoidP, 0)\n    with pytest.raises((TypeError, RuntimeError)):\n        p[0]\n\ndef test_iter():\n    BInt = new_primitive_type(\"int\")\n    BIntP = new_pointer_type(BInt)\n    BArray = new_array_type(BIntP, None)   # int[]\n    p = newp(BArray, 7)\n    assert list(p) == list(iter(p)) == [0] * 7\n    #\n    py.test.raises(TypeError, iter, cast(BInt, 5))\n    py.test.raises(TypeError, iter, cast(BIntP, 123456))\n\ndef test_cmp():\n    BInt = new_primitive_type(\"int\")\n    BIntP = new_pointer_type(BInt)\n    BVoidP = new_pointer_type(new_void_type())\n    p = newp(BIntP, 123)\n    q = cast(BInt, 124)\n    assert (p == q) is False\n    assert (p != q) is True\n    assert (q == p) is False\n    assert (q != p) is True\n    if strict_compare:\n        with pytest.raises(TypeError): p < q\n        with pytest.raises(TypeError): p <= q\n        with pytest.raises(TypeError): q < p\n        with pytest.raises(TypeError): q <= p\n        with pytest.raises(TypeError): p > q\n        with pytest.raises(TypeError): p >= q\n    r = cast(BVoidP, p)\n    assert (p <  r) is False\n    assert (p <= r) is True\n    assert (p == r) is True\n    assert (p != r) is False\n    assert (p >  r) is False\n    assert (p >= r) is True\n    s = newp(BIntP, 125)\n    assert (p == s) is False\n    assert (p != s) is True\n    assert (p < s) is (p <= s) is (s > p) is (s >= p)\n    assert (p > s) is (p >= s) is (s < p) is (s <= p)\n    assert (p < s) ^ (p > s)\n\ndef test_buffer():\n    try:\n        import __builtin__\n    except ImportError:\n        import builtins as __builtin__\n    BShort = new_primitive_type(\"short\")\n    s = newp(new_pointer_type(BShort), 100)\n    assert sizeof(s) == size_of_ptr()\n    assert sizeof(BShort) == 2\n    assert len(buffer(s)) == 2\n    #\n    BChar = new_primitive_type(\"char\")\n    BCharArray = new_array_type(new_pointer_type(BChar), None)\n    c = newp(BCharArray, b\"hi there\")\n    #\n    buf = buffer(c)\n    assert repr(buf).startswith('<_cffi_backend.buffer object at 0x')\n    assert bytes(buf) == b\"hi there\\x00\"\n    assert type(buf) is buffer\n    if sys.version_info < (3,):\n        assert str(buf) == \"hi there\\x00\"\n        assert unicode(buf) == u+\"hi there\\x00\"\n    else:\n        assert str(buf) == repr(buf)\n    # --mb_length--\n    assert len(buf) == len(b\"hi there\\x00\")\n    # --mb_item--\n    for i in range(-12, 12):\n        try:\n            expected = b\"hi there\\x00\"[i]\n        except IndexError:\n            with pytest.raises(IndexError):\n                buf[i]\n        else:\n            assert buf[i] == bitem2bchr(expected)\n    # --mb_slice--\n    assert buf[:] == b\"hi there\\x00\"\n    for i in range(-12, 12):\n        assert buf[i:] == b\"hi there\\x00\"[i:]\n        assert buf[:i] == b\"hi there\\x00\"[:i]\n        for j in range(-12, 12):\n            assert buf[i:j] == b\"hi there\\x00\"[i:j]\n    # --misc--\n    assert list(buf) == list(map(bitem2bchr, b\"hi there\\x00\"))\n    # --mb_as_buffer--\n    if hasattr(__builtin__, 'buffer'):          # Python <= 2.7\n        py.test.raises(TypeError, __builtin__.buffer, c)\n        bf1 = __builtin__.buffer(buf)\n        assert len(bf1) == len(buf) and bf1[3] == \"t\"\n    if hasattr(__builtin__, 'memoryview'):      # Python >= 2.7\n        py.test.raises(TypeError, memoryview, c)\n        mv1 = memoryview(buf)\n        assert len(mv1) == len(buf) and mv1[3] in (b\"t\", ord(b\"t\"))\n    # --mb_ass_item--\n    expected = list(map(bitem2bchr, b\"hi there\\x00\"))\n    for i in range(-12, 12):\n        try:\n            expected[i] = bytechr(i & 0xff)\n        except IndexError:\n            with pytest.raises(IndexError):\n                buf[i] = bytechr(i & 0xff)\n        else:\n            buf[i] = bytechr(i & 0xff)\n        assert list(buf) == expected\n    # --mb_ass_slice--\n    buf[:] = b\"hi there\\x00\"\n    assert list(buf) == list(c) == list(map(bitem2bchr, b\"hi there\\x00\"))\n    with pytest.raises(ValueError):\n        buf[:] = b\"shorter\"\n    with pytest.raises(ValueError):\n        buf[:] = b\"this is much too long!\"\n    buf[4:2] = b\"\"   # no effect, but should work\n    assert buf[:] == b\"hi there\\x00\"\n    buf[:2] = b\"HI\"\n    assert buf[:] == b\"HI there\\x00\"\n    buf[:2] = b\"hi\"\n    expected = list(map(bitem2bchr, b\"hi there\\x00\"))\n    x = 0\n    for i in range(-12, 12):\n        for j in range(-12, 12):\n            start = i if i >= 0 else i + len(buf)\n            stop  = j if j >= 0 else j + len(buf)\n            start = max(0, min(len(buf), start))\n            stop  = max(0, min(len(buf), stop))\n            sample = bytechr(x & 0xff) * (stop - start)\n            x += 1\n            buf[i:j] = sample\n            expected[i:j] = map(bitem2bchr, sample)\n            assert list(buf) == expected\n\ndef test_getcname():\n    BUChar = new_primitive_type(\"unsigned char\")\n    BArray = new_array_type(new_pointer_type(BUChar), 123)\n    assert getcname(BArray, \"<-->\") == \"unsigned char<-->[123]\"\n\ndef test_errno():\n    BVoid = new_void_type()\n    BFunc5 = new_function_type((), BVoid)\n    f = cast(BFunc5, _testfunc(5))\n    set_errno(50)\n    f()\n    assert get_errno() == 65\n    f(); f()\n    assert get_errno() == 95\n\ndef test_errno_callback():\n    if globals().get('PY_DOT_PY') == '2.5':\n        py.test.skip(\"cannot run this test on py.py with Python 2.5\")\n    set_errno(95)\n    def cb():\n        e = get_errno()\n        set_errno(e - 6)\n    BVoid = new_void_type()\n    BFunc5 = new_function_type((), BVoid)\n    f = callback(BFunc5, cb)\n    f()\n    assert get_errno() == 89\n    f(); f()\n    assert get_errno() == 77\n\ndef test_cast_to_array():\n    # not valid in C!  extension to get a non-owning <cdata 'int[3]'>\n    BInt = new_primitive_type(\"int\")\n    BIntP = new_pointer_type(BInt)\n    BArray = new_array_type(BIntP, 3)\n    x = cast(BArray, 0)\n    assert repr(x) == \"<cdata 'int[3]' NULL>\"\n\ndef test_cast_invalid():\n    BStruct = new_struct_type(\"struct foo\")\n    complete_struct_or_union(BStruct, [])\n    p = cast(new_pointer_type(BStruct), 123456)\n    s = p[0]\n    py.test.raises(TypeError, cast, BStruct, s)\n\ndef test_bug_float_convertion():\n    BDouble = new_primitive_type(\"double\")\n    BDoubleP = new_pointer_type(BDouble)\n    py.test.raises(TypeError, newp, BDoubleP, \"foobar\")\n\ndef test_bug_delitem():\n    BChar = new_primitive_type(\"char\")\n    BCharP = new_pointer_type(BChar)\n    x = newp(BCharP)\n    with pytest.raises(TypeError):\n        del x[0]\n\ndef test_bug_delattr():\n    BLong = new_primitive_type(\"long\")\n    BStruct = new_struct_type(\"struct foo\")\n    complete_struct_or_union(BStruct, [('a1', BLong, -1)])\n    x = newp(new_pointer_type(BStruct))\n    with pytest.raises(AttributeError):\n        del x.a1\n\ndef test_variable_length_struct():\n    py.test.skip(\"later\")\n    BLong = new_primitive_type(\"long\")\n    BArray = new_array_type(new_pointer_type(BLong), None)\n    BStruct = new_struct_type(\"struct foo\")\n    BStructP = new_pointer_type(BStruct)\n    complete_struct_or_union(BStruct, [('a1', BLong, -1),\n                                       ('a2', BArray, -1)])\n    assert sizeof(BStruct) == size_of_long()\n    assert alignof(BStruct) == alignof(BLong)\n    #\n    py.test.raises(TypeError, newp, BStructP, None)\n    x = newp(BStructP, 5)\n    assert sizeof(x) == 6 * size_of_long()\n    x[4] = 123\n    assert x[4] == 123\n    with pytest.raises(IndexError):\n        x[5]\n    assert len(x.a2) == 5\n    #\n    py.test.raises(TypeError, newp, BStructP, [123])\n    x = newp(BStructP, [123, 5])\n    assert x.a1 == 123\n    assert len(x.a2) == 5\n    assert list(x.a2) == [0] * 5\n    #\n    x = newp(BStructP, {'a2': 5})\n    assert x.a1 == 0\n    assert len(x.a2) == 5\n    assert list(x.a2) == [0] * 5\n    #\n    x = newp(BStructP, [123, (4, 5)])\n    assert x.a1 == 123\n    assert len(x.a2) == 2\n    assert list(x.a2) == [4, 5]\n    #\n    x = newp(BStructP, {'a2': (4, 5)})\n    assert x.a1 == 0\n    assert len(x.a2) == 2\n    assert list(x.a2) == [4, 5]\n\ndef test_autocast_int():\n    BInt = new_primitive_type(\"int\")\n    BIntPtr = new_pointer_type(BInt)\n    BLongLong = new_primitive_type(\"long long\")\n    BULongLong = new_primitive_type(\"unsigned long long\")\n    BULongLongPtr = new_pointer_type(BULongLong)\n    x = newp(BIntPtr, cast(BInt, 42))\n    assert x[0] == 42\n    x = newp(BIntPtr, cast(BLongLong, 42))\n    assert x[0] == 42\n    x = newp(BIntPtr, cast(BULongLong, 42))\n    assert x[0] == 42\n    x = newp(BULongLongPtr, cast(BInt, 42))\n    assert x[0] == 42\n    py.test.raises(OverflowError, newp, BULongLongPtr, cast(BInt, -42))\n    x = cast(BInt, cast(BInt, 42))\n    assert int(x) == 42\n    x = cast(BInt, cast(BLongLong, 42))\n    assert int(x) == 42\n    x = cast(BInt, cast(BULongLong, 42))\n    assert int(x) == 42\n    x = cast(BULongLong, cast(BInt, 42))\n    assert int(x) == 42\n    x = cast(BULongLong, cast(BInt, -42))\n    assert int(x) == 2 ** 64 - 42\n    x = cast(BIntPtr, cast(BInt, 42))\n    assert int(cast(BInt, x)) == 42\n\ndef test_autocast_float():\n    BFloat = new_primitive_type(\"float\")\n    BDouble = new_primitive_type(\"float\")\n    BFloatPtr = new_pointer_type(BFloat)\n    x = newp(BFloatPtr, cast(BDouble, 12.5))\n    assert x[0] == 12.5\n    x = cast(BFloat, cast(BDouble, 12.5))\n    assert float(x) == 12.5\n\ndef test_longdouble():\n    py_py = 'PY_DOT_PY' in globals()\n    BInt = new_primitive_type(\"int\")\n    BLongDouble = new_primitive_type(\"long double\")\n    BLongDoublePtr = new_pointer_type(BLongDouble)\n    BLongDoubleArray = new_array_type(BLongDoublePtr, None)\n    a = newp(BLongDoubleArray, 1)\n    x = a[0]\n    if not py_py:\n        assert repr(x).startswith(\"<cdata 'long double' 0.0\")\n    assert float(x) == 0.0\n    assert int(x) == 0\n    #\n    b = newp(BLongDoubleArray, [1.23])\n    x = b[0]\n    if not py_py:\n        assert repr(x).startswith(\"<cdata 'long double' 1.23\")\n    assert float(x) == 1.23\n    assert int(x) == 1\n    #\n    BFunc19 = new_function_type((BLongDouble, BInt), BLongDouble)\n    f = cast(BFunc19, _testfunc(19))\n    start = lstart = 1.5\n    for i in range(107):\n        start = 4 * start - start * start\n        lstart = f(lstart, 1)\n    lother = f(1.5, 107)\n    if not py_py:\n        assert float(lstart) == float(lother)\n        assert repr(lstart) == repr(lother)\n        if sizeof(BLongDouble) > sizeof(new_primitive_type(\"double\")):\n            assert float(lstart) != start\n            assert repr(lstart).startswith(\"<cdata 'long double' \")\n    #\n    c = newp(BLongDoubleArray, [lstart])\n    x = c[0]\n    assert float(f(lstart, 107)) == float(f(x, 107))\n\ndef test_get_array_of_length_zero():\n    for length in [0, 5, 10]:\n        BLong = new_primitive_type(\"long\")\n        BLongP = new_pointer_type(BLong)\n        BArray0 = new_array_type(BLongP, length)\n        BStruct = new_struct_type(\"struct foo\")\n        BStructPtr = new_pointer_type(BStruct)\n        complete_struct_or_union(BStruct, [('a1', BArray0, -1)])\n        p = newp(BStructPtr, None)\n        if length == 0:\n            assert repr(p.a1).startswith(\"<cdata 'long *' 0x\")\n        else:\n            assert repr(p.a1).startswith(\"<cdata 'long[%d]' 0x\" % length)\n\ndef test_nested_anonymous_struct():\n    BInt = new_primitive_type(\"int\")\n    BChar = new_primitive_type(\"char\")\n    BStruct = new_struct_type(\"struct foo\")\n    BInnerStruct = new_struct_type(\"struct foo\")\n    complete_struct_or_union(BInnerStruct, [('a1', BInt, -1),\n                                            ('a2', BChar, -1)])\n    complete_struct_or_union(BStruct, [('', BInnerStruct, -1),\n                                       ('a3', BChar, -1)])\n    assert sizeof(BInnerStruct) == sizeof(BInt) * 2   # with alignment\n    assert sizeof(BStruct) == sizeof(BInt) * 3        # 'a3' is placed after\n    d = BStruct.fields\n    assert len(d) == 3\n    assert d[0][0] == 'a1'\n    assert d[0][1].type is BInt\n    assert d[0][1].offset == 0\n    assert d[0][1].bitshift == -1\n    assert d[0][1].bitsize == -1\n    assert d[1][0] == 'a2'\n    assert d[1][1].type is BChar\n    assert d[1][1].offset == sizeof(BInt)\n    assert d[1][1].bitshift == -1\n    assert d[1][1].bitsize == -1\n    assert d[2][0] == 'a3'\n    assert d[2][1].type is BChar\n    assert d[2][1].offset == sizeof(BInt) * 2\n    assert d[2][1].bitshift == -1\n    assert d[2][1].bitsize == -1\n\ndef test_nested_anonymous_struct_2():\n    BInt = new_primitive_type(\"int\")\n    BStruct = new_struct_type(\"struct foo\")\n    BInnerUnion = new_union_type(\"union bar\")\n    complete_struct_or_union(BInnerUnion, [('a1', BInt, -1),\n                                           ('a2', BInt, -1)])\n    complete_struct_or_union(BStruct, [('b1', BInt, -1),\n                                       ('', BInnerUnion, -1),\n                                       ('b2', BInt, -1)])\n    assert sizeof(BInnerUnion) == sizeof(BInt)\n    assert sizeof(BStruct) == sizeof(BInt) * 3\n    fields = [(name, fld.offset, fld.flags) for (name, fld) in BStruct.fields]\n    assert fields == [\n        ('b1', 0 * sizeof(BInt), 0),\n        ('a1', 1 * sizeof(BInt), 0),\n        ('a2', 1 * sizeof(BInt), 1),\n        ('b2', 2 * sizeof(BInt), 0),\n    ]\n\ndef test_sizeof_union():\n    # a union has the largest alignment of its members, and a total size\n    # that is the largest of its items *possibly further aligned* if\n    # another smaller item has a larger alignment...\n    BChar = new_primitive_type(\"char\")\n    BShort = new_primitive_type(\"short\")\n    assert sizeof(BShort) == alignof(BShort) == 2\n    BStruct = new_struct_type(\"struct foo\")\n    complete_struct_or_union(BStruct, [('a1', BChar),\n                                       ('a2', BChar),\n                                       ('a3', BChar)])\n    assert sizeof(BStruct) == 3 and alignof(BStruct) == 1\n    BUnion = new_union_type(\"union u\")\n    complete_struct_or_union(BUnion, [('s', BStruct),\n                                      ('i', BShort)])\n    assert sizeof(BUnion) == 4\n    assert alignof(BUnion) == 2\n\ndef test_unaligned_struct():\n    BInt = new_primitive_type(\"int\")\n    BStruct = new_struct_type(\"struct foo\")\n    complete_struct_or_union(BStruct, [('b', BInt, -1, 1)],\n                             None, 5, 1)\n\ndef test_CData_CType():\n    CData, CType = _get_types()\n    BChar = new_primitive_type(\"char\")\n    BCharP = new_pointer_type(BChar)\n    nullchr = cast(BChar, 0)\n    chrref = newp(BCharP, None)\n    assert isinstance(nullchr, CData)\n    assert isinstance(chrref, CData)\n    assert not isinstance(BChar, CData)\n    assert not isinstance(nullchr, CType)\n    assert not isinstance(chrref, CType)\n    assert isinstance(BChar, CType)\n\ndef test_no_cdata_float():\n    BInt = new_primitive_type(\"int\")\n    BIntP = new_pointer_type(BInt)\n    BUInt = new_primitive_type(\"unsigned int\")\n    BUIntP = new_pointer_type(BUInt)\n    BFloat = new_primitive_type(\"float\")\n    py.test.raises(TypeError, newp, BIntP, cast(BFloat, 0.0))\n    py.test.raises(TypeError, newp, BUIntP, cast(BFloat, 0.0))\n\ndef test_bool():\n    BBool = new_primitive_type(\"_Bool\")\n    BBoolP = new_pointer_type(BBool)\n    assert int(cast(BBool, False)) == 0\n    assert int(cast(BBool, True)) == 1\n    assert bool(cast(BBool, False)) is False    # since 1.7\n    assert bool(cast(BBool, True)) is True\n    assert int(cast(BBool, 3)) == 1\n    assert int(cast(BBool, long(3))) == 1\n    assert int(cast(BBool, long(10)**4000)) == 1\n    assert int(cast(BBool, -0.1)) == 1\n    assert int(cast(BBool, -0.0)) == 0\n    assert int(cast(BBool, '\\x00')) == 0\n    assert int(cast(BBool, '\\xff')) == 1\n    assert newp(BBoolP, False)[0] == 0\n    assert newp(BBoolP, True)[0] == 1\n    assert newp(BBoolP, 0)[0] == 0\n    assert newp(BBoolP, 1)[0] == 1\n    py.test.raises(TypeError, newp, BBoolP, 1.0)\n    py.test.raises(TypeError, newp, BBoolP, '\\x00')\n    py.test.raises(OverflowError, newp, BBoolP, 2)\n    py.test.raises(OverflowError, newp, BBoolP, -1)\n    BCharP = new_pointer_type(new_primitive_type(\"char\"))\n    p = newp(BCharP, b'\\x01')\n    q = cast(BBoolP, p)\n    assert q[0] is True\n    p = newp(BCharP, b'\\x00')\n    q = cast(BBoolP, p)\n    assert q[0] is False\n    py.test.raises(TypeError, string, cast(BBool, False))\n    BDouble = new_primitive_type(\"double\")\n    assert int(cast(BBool, cast(BDouble, 0.1))) == 1\n    assert int(cast(BBool, cast(BDouble, 0.0))) == 0\n    BBoolA = new_array_type(BBoolP, None)\n    p = newp(BBoolA, b'\\x01\\x00')\n    assert p[0] is True\n    assert p[1] is False\n\ndef test_bool_forbidden_cases():\n    BBool = new_primitive_type(\"_Bool\")\n    BBoolP = new_pointer_type(BBool)\n    BBoolA = new_array_type(BBoolP, None)\n    BCharP = new_pointer_type(new_primitive_type(\"char\"))\n    p = newp(BCharP, b'X')\n    q = cast(BBoolP, p)\n    with pytest.raises(ValueError):\n        q[0]\n    py.test.raises(TypeError, newp, BBoolP, b'\\x00')\n    assert newp(BBoolP, 0)[0] is False\n    assert newp(BBoolP, 1)[0] is True\n    py.test.raises(OverflowError, newp, BBoolP, 2)\n    py.test.raises(OverflowError, newp, BBoolP, -1)\n    py.test.raises(ValueError, newp, BBoolA, b'\\x00\\x01\\x02')\n    py.test.raises(OverflowError, newp, BBoolA, [0, 1, 2])\n    py.test.raises(TypeError, string, newp(BBoolP, 1))\n    py.test.raises(TypeError, string, newp(BBoolA, [1]))\n\ndef test_typeoffsetof():\n    BChar = new_primitive_type(\"char\")\n    BStruct = new_struct_type(\"struct foo\")\n    BStructPtr = new_pointer_type(BStruct)\n    complete_struct_or_union(BStruct, [('a1', BChar, -1),\n                                       ('a2', BChar, -1),\n                                       ('a3', BChar, -1)])\n    py.test.raises(TypeError, typeoffsetof, BStructPtr, None)\n    py.test.raises(TypeError, typeoffsetof, BStruct, None)\n    assert typeoffsetof(BStructPtr, 'a1') == (BChar, 0)\n    assert typeoffsetof(BStruct, 'a1') == (BChar, 0)\n    assert typeoffsetof(BStructPtr, 'a2') == (BChar, 1)\n    assert typeoffsetof(BStruct, 'a3') == (BChar, 2)\n    assert typeoffsetof(BStructPtr, 'a2', 0) == (BChar, 1)\n    assert typeoffsetof(BStruct, u+'a3') == (BChar, 2)\n    py.test.raises(TypeError, typeoffsetof, BStructPtr, 'a2', 1)\n    py.test.raises(KeyError, typeoffsetof, BStructPtr, 'a4')\n    py.test.raises(KeyError, typeoffsetof, BStruct, 'a5')\n    py.test.raises(TypeError, typeoffsetof, BStruct, 42)\n    py.test.raises(TypeError, typeoffsetof, BChar, 'a1')\n\ndef test_typeoffsetof_array():\n    BInt = new_primitive_type(\"int\")\n    BIntP = new_pointer_type(BInt)\n    BArray = new_array_type(BIntP, None)\n    py.test.raises(TypeError, typeoffsetof, BArray, None)\n    py.test.raises(TypeError, typeoffsetof, BArray, 'a1')\n    assert typeoffsetof(BArray, 51) == (BInt, 51 * size_of_int())\n    assert typeoffsetof(BIntP, 51) == (BInt, 51 * size_of_int())\n    assert typeoffsetof(BArray, -51) == (BInt, -51 * size_of_int())\n    MAX = sys.maxsize // size_of_int()\n    assert typeoffsetof(BArray, MAX) == (BInt, MAX * size_of_int())\n    assert typeoffsetof(BIntP, MAX) == (BInt, MAX * size_of_int())\n    py.test.raises(OverflowError, typeoffsetof, BArray, MAX + 1)\n\ndef test_typeoffsetof_no_bitfield():\n    BInt = new_primitive_type(\"int\")\n    BStruct = new_struct_type(\"struct foo\")\n    complete_struct_or_union(BStruct, [('a1', BInt, 4)])\n    py.test.raises(TypeError, typeoffsetof, BStruct, 'a1')\n\ndef test_rawaddressof():\n    BChar = new_primitive_type(\"char\")\n    BCharP = new_pointer_type(BChar)\n    BStruct = new_struct_type(\"struct foo\")\n    BStructPtr = new_pointer_type(BStruct)\n    complete_struct_or_union(BStruct, [('a1', BChar, -1),\n                                       ('a2', BChar, -1),\n                                       ('a3', BChar, -1)])\n    p = newp(BStructPtr)\n    assert repr(p) == \"<cdata 'struct foo *' owning 3 bytes>\"\n    s = p[0]\n    assert repr(s) == \"<cdata 'struct foo' owning 3 bytes>\"\n    a = rawaddressof(BStructPtr, s, 0)\n    assert repr(a).startswith(\"<cdata 'struct foo *' 0x\")\n    py.test.raises(TypeError, rawaddressof, BStruct, s, 0)\n    b = rawaddressof(BCharP, s, 0)\n    assert b == cast(BCharP, p)\n    c = rawaddressof(BStructPtr, a, 0)\n    assert c == a\n    py.test.raises(TypeError, rawaddressof, BStructPtr, cast(BChar, '?'), 0)\n    #\n    d = rawaddressof(BCharP, s, 1)\n    assert d == cast(BCharP, p) + 1\n    #\n    e = cast(BCharP, 109238)\n    f = rawaddressof(BCharP, e, 42)\n    assert f == e + 42\n    #\n    BCharA = new_array_type(BCharP, None)\n    e = newp(BCharA, 50)\n    f = rawaddressof(BCharP, e, 42)\n    assert f == e + 42\n\ndef test_newp_signed_unsigned_char():\n    BCharArray = new_array_type(\n        new_pointer_type(new_primitive_type(\"char\")), None)\n    p = newp(BCharArray, b\"foo\")\n    assert len(p) == 4\n    assert list(p) == [b\"f\", b\"o\", b\"o\", b\"\\x00\"]\n    #\n    BUCharArray = new_array_type(\n        new_pointer_type(new_primitive_type(\"unsigned char\")), None)\n    p = newp(BUCharArray, b\"fo\\xff\")\n    assert len(p) == 4\n    assert list(p) == [ord(\"f\"), ord(\"o\"), 0xff, 0]\n    #\n    BSCharArray = new_array_type(\n        new_pointer_type(new_primitive_type(\"signed char\")), None)\n    p = newp(BSCharArray, b\"fo\\xff\")\n    assert len(p) == 4\n    assert list(p) == [ord(\"f\"), ord(\"o\"), -1, 0]\n\ndef test_newp_from_bytearray_doesnt_work():\n    BCharArray = new_array_type(\n        new_pointer_type(new_primitive_type(\"char\")), None)\n    py.test.raises(TypeError, newp, BCharArray, bytearray(b\"foo\"))\n    p = newp(BCharArray, 5)\n    buffer(p)[:] = bytearray(b\"foo.\\x00\")\n    assert len(p) == 5\n    assert list(p) == [b\"f\", b\"o\", b\"o\", b\".\", b\"\\x00\"]\n    p[1:3] = bytearray(b\"XY\")\n    assert list(p) == [b\"f\", b\"X\", b\"Y\", b\".\", b\"\\x00\"]\n\ndef test_string_assignment_to_byte_array():\n    BByteArray = new_array_type(\n        new_pointer_type(new_primitive_type(\"unsigned char\")), None)\n    p = newp(BByteArray, 5)\n    p[0:3] = bytearray(b\"XYZ\")\n    assert list(p) == [ord(\"X\"), ord(\"Y\"), ord(\"Z\"), 0, 0]\n\n# XXX hack\nif sys.version_info >= (3,):\n    try:\n        import posix, io\n        posix.fdopen = io.open\n    except ImportError:\n        pass   # win32\n\ndef test_FILE():\n    if sys.platform == \"win32\":\n        py.test.skip(\"testing FILE not implemented\")\n    #\n    BFILE = new_struct_type(\"struct _IO_FILE\")\n    BFILEP = new_pointer_type(BFILE)\n    BChar = new_primitive_type(\"char\")\n    BCharP = new_pointer_type(BChar)\n    BInt = new_primitive_type(\"int\")\n    BFunc = new_function_type((BCharP, BFILEP), BInt, False)\n    BFunc2 = new_function_type((BFILEP, BCharP), BInt, True)\n    ll = find_and_load_library('c')\n    fputs = ll.load_function(BFunc, \"fputs\")\n    fscanf = ll.load_function(BFunc2, \"fscanf\")\n    #\n    import posix\n    fdr, fdw = posix.pipe()\n    fr1 = posix.fdopen(fdr, 'rb', 256)\n    fw1 = posix.fdopen(fdw, 'wb', 256)\n    #\n    fw1.write(b\"X\")\n    res = fputs(b\"hello world\\n\", fw1)\n    assert res >= 0\n    fw1.flush()     # should not be needed\n    #\n    p = newp(new_array_type(BCharP, 100), None)\n    res = fscanf(fr1, b\"%s\\n\", p)\n    assert res == 1\n    assert string(p) == b\"Xhello\"\n    fr1.close()\n    fw1.close()\n\ndef test_FILE_only_for_FILE_arg():\n    if sys.platform == \"win32\":\n        py.test.skip(\"testing FILE not implemented\")\n    #\n    B_NOT_FILE = new_struct_type(\"struct NOT_FILE\")\n    B_NOT_FILEP = new_pointer_type(B_NOT_FILE)\n    BChar = new_primitive_type(\"char\")\n    BCharP = new_pointer_type(BChar)\n    BInt = new_primitive_type(\"int\")\n    BFunc = new_function_type((BCharP, B_NOT_FILEP), BInt, False)\n    ll = find_and_load_library('c')\n    fputs = ll.load_function(BFunc, \"fputs\")\n    #\n    import posix\n    fdr, fdw = posix.pipe()\n    fr1 = posix.fdopen(fdr, 'r')\n    fw1 = posix.fdopen(fdw, 'w')\n    #\n    e = py.test.raises(TypeError, fputs, b\"hello world\\n\", fw1)\n    assert str(e.value).startswith(\n        \"initializer for ctype 'struct NOT_FILE *' must \"\n        \"be a cdata pointer, not \")\n\ndef test_FILE_object():\n    if sys.platform == \"win32\":\n        py.test.skip(\"testing FILE not implemented\")\n    #\n    BFILE = new_struct_type(\"FILE\")\n    BFILEP = new_pointer_type(BFILE)\n    BChar = new_primitive_type(\"char\")\n    BCharP = new_pointer_type(BChar)\n    BInt = new_primitive_type(\"int\")\n    BFunc = new_function_type((BCharP, BFILEP), BInt, False)\n    BFunc2 = new_function_type((BFILEP,), BInt, False)\n    ll = find_and_load_library('c')\n    fputs = ll.load_function(BFunc, \"fputs\")\n    fileno = ll.load_function(BFunc2, \"fileno\")\n    #\n    import posix\n    fdr, fdw = posix.pipe()\n    fw1 = posix.fdopen(fdw, 'wb', 256)\n    #\n    fw1p = cast(BFILEP, fw1)\n    fw1.write(b\"X\")\n    fw1.flush()\n    res = fputs(b\"hello\\n\", fw1p)\n    assert res >= 0\n    res = fileno(fw1p)\n    assert (res == fdw) == (sys.version_info < (3,))\n    fw1.close()\n    #\n    data = posix.read(fdr, 256)\n    assert data == b\"Xhello\\n\"\n    posix.close(fdr)\n\ndef test_errno_saved():\n    set_errno(42)\n    # a random function that will reset errno to 0 (at least on non-windows)\n    import os; os.stat('.')\n    #\n    res = get_errno()\n    assert res == 42\n\ndef test_GetLastError():\n    if sys.platform != \"win32\":\n        py.test.skip(\"GetLastError(): only for Windows\")\n    #\n    lib = find_and_load_library('KERNEL32.DLL')\n    BInt = new_primitive_type(\"int\")\n    BVoid = new_void_type()\n    BFunc1 = new_function_type((BInt,), BVoid, False)\n    BFunc2 = new_function_type((), BInt, False)\n    SetLastError = lib.load_function(BFunc1, \"SetLastError\")\n    GetLastError = lib.load_function(BFunc2, \"GetLastError\")\n    #\n    SetLastError(42)\n    # a random function that will reset the real GetLastError() to 0\n    import nt; nt.stat('.')\n    #\n    res = GetLastError()\n    assert res == 42\n    #\n    SetLastError(2)\n    code, message = getwinerror()\n    assert code == 2\n    assert message == \"The system cannot find the file specified\"\n    #\n    code, message = getwinerror(1155)\n    assert code == 1155\n    assert message == (\"No application is associated with the \"\n                       \"specified file for this operation\")\n\ndef test_nonstandard_integer_types():\n    for typename in ['int8_t', 'uint8_t', 'int16_t', 'uint16_t', 'int32_t',\n                     'uint32_t', 'int64_t', 'uint64_t', 'intptr_t',\n                     'uintptr_t', 'ptrdiff_t', 'size_t', 'ssize_t',\n                     'int_least8_t',  'uint_least8_t',\n                     'int_least16_t', 'uint_least16_t',\n                     'int_least32_t', 'uint_least32_t',\n                     'int_least64_t', 'uint_least64_t',\n                     'int_fast8_t',  'uint_fast8_t',\n                     'int_fast16_t', 'uint_fast16_t',\n                     'int_fast32_t', 'uint_fast32_t',\n                     'int_fast64_t', 'uint_fast64_t',\n                     'intmax_t', 'uintmax_t']:\n        new_primitive_type(typename)    # works\n\ndef test_cannot_convert_unicode_to_charp():\n    BCharP = new_pointer_type(new_primitive_type(\"char\"))\n    BCharArray = new_array_type(BCharP, None)\n    py.test.raises(TypeError, newp, BCharArray, u+'foobar')\n\ndef test_buffer_keepalive():\n    BCharP = new_pointer_type(new_primitive_type(\"char\"))\n    BCharArray = new_array_type(BCharP, None)\n    buflist = []\n    for i in range(20):\n        c = newp(BCharArray, str2bytes(\"hi there %d\" % i))\n        buflist.append(buffer(c))\n    import gc; gc.collect()\n    for i in range(20):\n        buf = buflist[i]\n        assert buf[:] == str2bytes(\"hi there %d\\x00\" % i)\n\ndef test_slice():\n    BIntP = new_pointer_type(new_primitive_type(\"int\"))\n    BIntArray = new_array_type(BIntP, None)\n    c = newp(BIntArray, 5)\n    assert len(c) == 5\n    assert repr(c) == \"<cdata 'int[]' owning 20 bytes>\"\n    d = c[1:4]\n    assert len(d) == 3\n    assert repr(d) == \"<cdata 'int[]' sliced length 3>\"\n    d[0] = 123\n    d[2] = 456\n    assert c[1] == 123\n    assert c[3] == 456\n    assert d[2] == 456\n    with pytest.raises(IndexError):\n        d[3]\n    with pytest.raises(IndexError):\n        d[-1]\n\ndef test_slice_ptr():\n    BIntP = new_pointer_type(new_primitive_type(\"int\"))\n    BIntArray = new_array_type(BIntP, None)\n    c = newp(BIntArray, 5)\n    d = (c+1)[0:2]\n    assert len(d) == 2\n    assert repr(d) == \"<cdata 'int[]' sliced length 2>\"\n    d[1] += 50\n    assert c[2] == 50\n\ndef test_slice_array_checkbounds():\n    BIntP = new_pointer_type(new_primitive_type(\"int\"))\n    BIntArray = new_array_type(BIntP, None)\n    c = newp(BIntArray, 5)\n    c[0:5]\n    assert len(c[5:5]) == 0\n    with pytest.raises(IndexError):\n        c[-1:1]\n    cp = c + 0\n    cp[-1:1]\n\ndef test_nonstandard_slice():\n    BIntP = new_pointer_type(new_primitive_type(\"int\"))\n    BIntArray = new_array_type(BIntP, None)\n    c = newp(BIntArray, 5)\n    with pytest.raises(IndexError) as e:\n        c[:5]\n    assert str(e.value) == \"slice start must be specified\"\n    with pytest.raises(IndexError) as e:\n        c[4:]\n    assert str(e.value) == \"slice stop must be specified\"\n    with pytest.raises(IndexError) as e:\n        c[1:2:3]\n    assert str(e.value) == \"slice with step not supported\"\n    with pytest.raises(IndexError) as e:\n        c[1:2:1]\n    assert str(e.value) == \"slice with step not supported\"\n    with pytest.raises(IndexError) as e:\n        c[4:2]\n    assert str(e.value) == \"slice start > stop\"\n    with pytest.raises(IndexError) as e:\n        c[6:6]\n    assert str(e.value) == \"index too large (expected 6 <= 5)\"\n\ndef test_setslice():\n    BIntP = new_pointer_type(new_primitive_type(\"int\"))\n    BIntArray = new_array_type(BIntP, None)\n    c = newp(BIntArray, 5)\n    c[1:3] = [100, 200]\n    assert list(c) == [0, 100, 200, 0, 0]\n    cp = c + 3\n    cp[-1:1] = [300, 400]\n    assert list(c) == [0, 100, 300, 400, 0]\n    cp[-1:1] = iter([500, 600])\n    assert list(c) == [0, 100, 500, 600, 0]\n    with pytest.raises(ValueError):\n        cp[-1:1] = [1000]\n    assert list(c) == [0, 100, 1000, 600, 0]\n    with pytest.raises(ValueError):\n        cp[-1:1] = (700, 800, 900)\n    assert list(c) == [0, 100, 700, 800, 0]\n\ndef test_setslice_array():\n    BIntP = new_pointer_type(new_primitive_type(\"int\"))\n    BIntArray = new_array_type(BIntP, None)\n    c = newp(BIntArray, 5)\n    d = newp(BIntArray, [10, 20, 30])\n    c[1:4] = d\n    assert list(c) == [0, 10, 20, 30, 0]\n    #\n    BShortP = new_pointer_type(new_primitive_type(\"short\"))\n    BShortArray = new_array_type(BShortP, None)\n    d = newp(BShortArray, [40, 50])\n    c[1:3] = d\n    assert list(c) == [0, 40, 50, 30, 0]\n\ndef test_cdata_name_module_doc():\n    p = new_primitive_type(\"signed char\")\n    x = cast(p, 17)\n    assert x.__module__ == '_cffi_backend'\n    assert x.__name__ == '<cdata>'\n    assert hasattr(x, '__doc__')\n\ndef test_different_types_of_ptr_equality():\n    BVoidP = new_pointer_type(new_void_type())\n    BIntP = new_pointer_type(new_primitive_type(\"int\"))\n    x = cast(BVoidP, 12345)\n    assert x == cast(BIntP, 12345)\n    assert x != cast(BIntP, 12344)\n    assert hash(x) == hash(cast(BIntP, 12345))\n\ndef test_new_handle():\n    import _weakref\n    BVoidP = new_pointer_type(new_void_type())\n    BCharP = new_pointer_type(new_primitive_type(\"char\"))\n    class mylist(list):\n        pass\n    o = mylist([2, 3, 4])\n    x = newp_handle(BVoidP, o)\n    assert repr(x) == \"<cdata 'void *' handle to [2, 3, 4]>\"\n    assert x\n    assert from_handle(x) is o\n    assert from_handle(cast(BCharP, x)) is o\n    wr = _weakref.ref(o)\n    del o\n    import gc; gc.collect()\n    assert wr() is not None\n    assert from_handle(x) == list((2, 3, 4))\n    assert from_handle(cast(BCharP, x)) == list((2, 3, 4))\n    del x\n    for i in range(3):\n        if wr() is not None:\n            import gc; gc.collect()\n    assert wr() is None\n    py.test.raises(RuntimeError, from_handle, cast(BCharP, 0))\n\ndef test_new_handle_cycle():\n    import _weakref\n    BVoidP = new_pointer_type(new_void_type())\n    class A(object):\n        pass\n    o = A()\n    o.cycle = newp_handle(BVoidP, o)\n    wr = _weakref.ref(o)\n    del o\n    for i in range(3):\n        if wr() is not None:\n            import gc; gc.collect()\n    assert wr() is None\n\ndef _test_bitfield_details(flag):\n    BChar = new_primitive_type(\"char\")\n    BShort = new_primitive_type(\"short\")\n    BInt = new_primitive_type(\"int\")\n    BUInt = new_primitive_type(\"unsigned int\")\n    BStruct = new_struct_type(\"struct foo1\")\n    complete_struct_or_union(BStruct, [('a', BChar, -1),\n                                       ('b1', BInt, 9),\n                                       ('b2', BUInt, 7),\n                                       ('c', BChar, -1)], -1, -1, -1, flag)\n    if not (flag & SF_MSVC_BITFIELDS):   # gcc, any variant\n        assert typeoffsetof(BStruct, 'c') == (BChar, 3)\n        assert sizeof(BStruct) == 4\n    else:               # msvc\n        assert typeoffsetof(BStruct, 'c') == (BChar, 8)\n        assert sizeof(BStruct) == 12\n    assert alignof(BStruct) == 4\n    #\n    p = newp(new_pointer_type(BStruct), None)\n    p.a = b'A'\n    p.b1 = -201\n    p.b2 = 99\n    p.c = b'\\x9D'\n    raw = buffer(p)[:]\n    if sys.byteorder == 'little':\n        if flag & SF_MSVC_BITFIELDS:\n            assert raw == b'A\\x00\\x00\\x007\\xC7\\x00\\x00\\x9D\\x00\\x00\\x00'\n        elif flag & SF_GCC_LITTLE_ENDIAN:\n            assert raw == b'A7\\xC7\\x9D'\n        elif flag & SF_GCC_BIG_ENDIAN:\n            assert raw == b'A\\xE3\\x9B\\x9D'\n        else:\n            raise AssertionError(\"bad flag\")\n    else:\n        if flag & SF_MSVC_BITFIELDS:\n            assert raw == b'A\\x00\\x00\\x00\\x00\\x00\\xC77\\x9D\\x00\\x00\\x00'\n        elif flag & SF_GCC_LITTLE_ENDIAN:\n            assert raw == b'A\\xC77\\x9D'\n        elif flag & SF_GCC_BIG_ENDIAN:\n            assert raw == b'A\\x9B\\xE3\\x9D'\n        else:\n            raise AssertionError(\"bad flag\")\n    #\n    BStruct = new_struct_type(\"struct foo2\")\n    complete_struct_or_union(BStruct, [('a', BChar, -1),\n                                       ('',  BShort, 9),\n                                       ('c', BChar, -1)], -1, -1, -1, flag)\n    assert typeoffsetof(BStruct, 'c') == (BChar, 4)\n    if flag & SF_MSVC_BITFIELDS:\n        assert sizeof(BStruct) == 6\n        assert alignof(BStruct) == 2\n    elif flag & SF_GCC_X86_BITFIELDS:\n        assert sizeof(BStruct) == 5\n        assert alignof(BStruct) == 1\n    elif flag & SF_GCC_ARM_BITFIELDS:\n        assert sizeof(BStruct) == 6\n        assert alignof(BStruct) == 2\n    else:\n        raise AssertionError(\"bad flag\")\n    #\n    BStruct = new_struct_type(\"struct foo2\")\n    complete_struct_or_union(BStruct, [('a', BChar, -1),\n                                       ('',  BInt, 0),\n                                       ('',  BInt, 0),\n                                       ('c', BChar, -1)], -1, -1, -1, flag)\n    if flag & SF_MSVC_BITFIELDS:\n        assert typeoffsetof(BStruct, 'c') == (BChar, 1)\n        assert sizeof(BStruct) == 2\n        assert alignof(BStruct) == 1\n    elif flag & SF_GCC_X86_BITFIELDS:\n        assert typeoffsetof(BStruct, 'c') == (BChar, 4)\n        assert sizeof(BStruct) == 5\n        assert alignof(BStruct) == 1\n    elif flag & SF_GCC_ARM_BITFIELDS:\n        assert typeoffsetof(BStruct, 'c') == (BChar, 4)\n        assert sizeof(BStruct) == 8\n        assert alignof(BStruct) == 4\n    else:\n        raise AssertionError(\"bad flag\")\n\n\nSF_MSVC_BITFIELDS     = 0x01\nSF_GCC_ARM_BITFIELDS  = 0x02\nSF_GCC_X86_BITFIELDS  = 0x10\n\nSF_GCC_BIG_ENDIAN     = 0x04\nSF_GCC_LITTLE_ENDIAN  = 0x40\n\nSF_PACKED             = 0x08\n\ndef test_bitfield_as_x86_gcc():\n    _test_bitfield_details(flag=SF_GCC_X86_BITFIELDS|SF_GCC_LITTLE_ENDIAN)\n\ndef test_bitfield_as_msvc():\n    _test_bitfield_details(flag=SF_MSVC_BITFIELDS|SF_GCC_LITTLE_ENDIAN)\n\ndef test_bitfield_as_arm_gcc():\n    _test_bitfield_details(flag=SF_GCC_ARM_BITFIELDS|SF_GCC_LITTLE_ENDIAN)\n\ndef test_bitfield_as_ppc_gcc():\n    # PowerPC uses the same format as X86, but is big-endian\n    _test_bitfield_details(flag=SF_GCC_X86_BITFIELDS|SF_GCC_BIG_ENDIAN)\n\n\ndef test_struct_array_no_length():\n    BInt = new_primitive_type(\"int\")\n    BIntP = new_pointer_type(BInt)\n    BArray = new_array_type(BIntP, None)\n    BStruct = new_struct_type(\"foo\")\n    py.test.raises(TypeError, complete_struct_or_union,\n                   BStruct, [('x', BArray),\n                             ('y', BInt)])\n    #\n    BStruct = new_struct_type(\"foo\")\n    complete_struct_or_union(BStruct, [('x', BInt),\n                                       ('y', BArray)])\n    assert sizeof(BStruct) == size_of_int()\n    d = BStruct.fields\n    assert len(d) == 2\n    assert d[0][0] == 'x'\n    assert d[0][1].type is BInt\n    assert d[0][1].offset == 0\n    assert d[0][1].bitshift == -1\n    assert d[0][1].bitsize == -1\n    assert d[1][0] == 'y'\n    assert d[1][1].type is BArray\n    assert d[1][1].offset == size_of_int()\n    assert d[1][1].bitshift == -2\n    assert d[1][1].bitsize == -1\n    #\n    p = newp(new_pointer_type(BStruct))\n    p.x = 42\n    assert p.x == 42\n    assert typeof(p.y) is BArray\n    assert len(p.y) == 0\n    assert p.y == cast(BIntP, p) + 1\n    #\n    p = newp(new_pointer_type(BStruct), [100])\n    assert p.x == 100\n    assert len(p.y) == 0\n    #\n    # Tests for\n    #    ffi.new(\"struct_with_var_array *\", [field.., [the_array_items..]])\n    #    ffi.new(\"struct_with_var_array *\", [field.., array_size])\n    plist = []\n    for i in range(20):\n        if i % 2 == 0:\n            p = newp(new_pointer_type(BStruct), [100, [200, i, 400]])\n        else:\n            p = newp(new_pointer_type(BStruct), [100, 3])\n            p.y[1] = i\n            p.y[0] = 200\n            assert p.y[2] == 0\n            p.y[2] = 400\n        assert len(p.y) == 3\n        assert len(p[0].y) == 3\n        assert len(buffer(p)) == sizeof(BInt) * 4\n        assert sizeof(p[0]) == sizeof(BInt) * 4\n        plist.append(p)\n    for i in range(20):\n        p = plist[i]\n        assert p.x == 100\n        assert p.y[0] == 200\n        assert p.y[1] == i\n        assert p.y[2] == 400\n        assert list(p.y) == [200, i, 400]\n    #\n    # the following assignment works, as it normally would, for any array field\n    p.y = [501, 601]\n    assert list(p.y) == [501, 601, 400]\n    p[0].y = [500, 600]\n    assert list(p[0].y) == [500, 600, 400]\n    assert repr(p) == \"<cdata 'foo *' owning %d bytes>\" % (\n        sizeof(BStruct) + 3 * sizeof(BInt),)\n    assert repr(p[0]) == \"<cdata 'foo' owning %d bytes>\" % (\n        sizeof(BStruct) + 3 * sizeof(BInt),)\n    assert sizeof(p[0]) == sizeof(BStruct) + 3 * sizeof(BInt)\n    #\n    # from a non-owning pointer, we can't get the length\n    q = cast(new_pointer_type(BStruct), p)\n    assert q.y[0] == 500\n    assert q[0].y[0] == 500\n    py.test.raises(TypeError, len, q.y)\n    py.test.raises(TypeError, len, q[0].y)\n    assert typeof(q.y) is BIntP\n    assert typeof(q[0].y) is BIntP\n    assert sizeof(q[0]) == sizeof(BStruct)\n    #\n    # error cases\n    with pytest.raises(IndexError):\n        p.y[4]\n    with pytest.raises(TypeError):\n        p.y = cast(BIntP, 0)\n    with pytest.raises(TypeError):\n        p.y = 15\n    with pytest.raises(TypeError):\n        p.y = None\n    #\n    # accepting this may be specified by the C99 standard,\n    # or a GCC strangeness...\n    BStruct2 = new_struct_type(\"bar\")\n    complete_struct_or_union(BStruct2, [('f', BStruct),\n                                        ('n', BInt)])\n    p = newp(new_pointer_type(BStruct2), {'n': 42})\n    assert p.n == 42\n    #\n    # more error cases\n    py.test.raises(TypeError, newp, new_pointer_type(BStruct), [100, None])\n    BArray4 = new_array_type(BIntP, 4)\n    BStruct4 = new_struct_type(\"test4\")\n    complete_struct_or_union(BStruct4, [('a', BArray4)])   # not varsized\n    py.test.raises(TypeError, newp, new_pointer_type(BStruct4), [None])\n    py.test.raises(TypeError, newp, new_pointer_type(BStruct4), [4])\n    p = newp(new_pointer_type(BStruct4), [[10, 20, 30]])\n    assert p.a[0] == 10\n    assert p.a[1] == 20\n    assert p.a[2] == 30\n    assert p.a[3] == 0\n    #\n    # struct of struct of varsized array\n    BStruct2 = new_struct_type(\"bar\")\n    complete_struct_or_union(BStruct2, [('head', BInt),\n                                        ('tail', BStruct)])\n    for i in range(2):   # try to detect heap overwrites\n        p = newp(new_pointer_type(BStruct2), [100, [200, list(range(50))]])\n        assert p.tail.y[49] == 49\n\n\ndef test_struct_array_no_length_explicit_position():\n    BInt = new_primitive_type(\"int\")\n    BIntP = new_pointer_type(BInt)\n    BArray = new_array_type(BIntP, None)\n    BStruct = new_struct_type(\"foo\")\n    complete_struct_or_union(BStruct, [('x', BArray, -1, 0), # actually 3 items\n                                       ('y', BInt, -1, 12)])\n    p = newp(new_pointer_type(BStruct), [[10, 20], 30])\n    assert p.x[0] == 10\n    assert p.x[1] == 20\n    assert p.x[2] == 0\n    assert p.y == 30\n    p = newp(new_pointer_type(BStruct), {'x': [40], 'y': 50})\n    assert p.x[0] == 40\n    assert p.x[1] == 0\n    assert p.x[2] == 0\n    assert p.y == 50\n    p = newp(new_pointer_type(BStruct), {'y': 60})\n    assert p.x[0] == 0\n    assert p.x[1] == 0\n    assert p.x[2] == 0\n    assert p.y == 60\n    #\n    # This \"should\" work too, allocating a larger structure\n    # (a bit strange in this case, but useful in general)\n    plist = []\n    for i in range(20):\n        p = newp(new_pointer_type(BStruct), [[10, 20, 30, 40, 50, 60, 70]])\n        plist.append(p)\n    for i in range(20):\n        p = plist[i]\n        assert p.x[0] == 10\n        assert p.x[1] == 20\n        assert p.x[2] == 30\n        assert p.x[3] == 40 == p.y\n        assert p.x[4] == 50\n        assert p.x[5] == 60\n        assert p.x[6] == 70\n\ndef test_struct_array_not_aligned():\n    # struct a { int x; char y; char z[]; };\n    # ends up of size 8, but 'z' is at offset 5\n    BChar = new_primitive_type(\"char\")\n    BInt = new_primitive_type(\"int\")\n    BCharP = new_pointer_type(BChar)\n    BArray = new_array_type(BCharP, None)\n    BStruct = new_struct_type(\"foo\")\n    complete_struct_or_union(BStruct, [('x', BInt),\n                                       ('y', BChar),\n                                       ('z', BArray)])\n    assert sizeof(BStruct) == 2 * size_of_int()\n    def offsetof(BType, fieldname):\n        return typeoffsetof(BType, fieldname)[1]\n    base = offsetof(BStruct, 'z')\n    assert base == size_of_int() + 1\n    #\n    p = newp(new_pointer_type(BStruct), {'z': 3})\n    assert sizeof(p[0]) == base + 3\n    q = newp(new_pointer_type(BStruct), {'z': size_of_int()})\n    assert sizeof(q) == size_of_ptr()\n    assert sizeof(q[0]) == base + size_of_int()\n    assert len(p.z) == 3\n    assert len(p[0].z) == 3\n    assert len(q.z) == size_of_int()\n    assert len(q[0].z) == size_of_int()\n\ndef test_ass_slice():\n    BChar = new_primitive_type(\"char\")\n    BArray = new_array_type(new_pointer_type(BChar), None)\n    p = newp(BArray, b\"foobar\")\n    p[2:5] = [b\"*\", b\"Z\", b\"T\"]\n    p[1:3] = b\"XY\"\n    assert list(p) == [b\"f\", b\"X\", b\"Y\", b\"Z\", b\"T\", b\"r\", b\"\\x00\"]\n    with pytest.raises(TypeError):\n        p[1:5] = u+'XYZT'\n    with pytest.raises(TypeError):\n        p[1:5] = [1, 2, 3, 4]\n    #\n    for typename in [\"wchar_t\", \"char16_t\", \"char32_t\"]:\n        BUniChar = new_primitive_type(typename)\n        BArray = new_array_type(new_pointer_type(BUniChar), None)\n        p = newp(BArray, u+\"foobar\")\n        p[2:5] = [u+\"*\", u+\"Z\", u+\"T\"]\n        p[1:3] = u+\"XY\"\n        assert list(p) == [u+\"f\", u+\"X\", u+\"Y\", u+\"Z\", u+\"T\", u+\"r\", u+\"\\x00\"]\n        with pytest.raises(TypeError):\n            p[1:5] = b'XYZT'\n        with pytest.raises(TypeError):\n            p[1:5] = [1, 2, 3, 4]\n\ndef test_void_p_arithmetic():\n    BVoid = new_void_type()\n    BInt = new_primitive_type(\"intptr_t\")\n    p = cast(new_pointer_type(BVoid), 100000)\n    assert int(cast(BInt, p)) == 100000\n    assert int(cast(BInt, p + 42)) == 100042\n    assert int(cast(BInt, p - (-42))) == 100042\n    assert (p + 42) - p == 42\n    q = cast(new_pointer_type(new_primitive_type(\"char\")), 100000)\n    with pytest.raises(TypeError):\n        p - q\n    with pytest.raises(TypeError):\n        q - p\n    with pytest.raises(TypeError):\n        p + cast(new_primitive_type('int'), 42)\n    with pytest.raises(TypeError):\n        p - cast(new_primitive_type('int'), 42)\n\ndef test_sizeof_sliced_array():\n    BInt = new_primitive_type(\"int\")\n    BArray = new_array_type(new_pointer_type(BInt), 10)\n    p = newp(BArray, None)\n    assert sizeof(p[2:9]) == 7 * sizeof(BInt)\n\ndef test_packed():\n    BLong = new_primitive_type(\"long\")\n    BChar = new_primitive_type(\"char\")\n    BShort = new_primitive_type(\"short\")\n    for extra_args in [(SF_PACKED,), (0, 1)]:\n        BStruct = new_struct_type(\"struct foo\")\n        complete_struct_or_union(BStruct, [('a1', BLong, -1),\n                                           ('a2', BChar, -1),\n                                           ('a3', BShort, -1)],\n                                 None, -1, -1, *extra_args)\n        d = BStruct.fields\n        assert len(d) == 3\n        assert d[0][0] == 'a1'\n        assert d[0][1].type is BLong\n        assert d[0][1].offset == 0\n        assert d[0][1].bitshift == -1\n        assert d[0][1].bitsize == -1\n        assert d[1][0] == 'a2'\n        assert d[1][1].type is BChar\n        assert d[1][1].offset == sizeof(BLong)\n        assert d[1][1].bitshift == -1\n        assert d[1][1].bitsize == -1\n        assert d[2][0] == 'a3'\n        assert d[2][1].type is BShort\n        assert d[2][1].offset == sizeof(BLong) + sizeof(BChar)\n        assert d[2][1].bitshift == -1\n        assert d[2][1].bitsize == -1\n        assert sizeof(BStruct) == sizeof(BLong) + sizeof(BChar) + sizeof(BShort)\n        assert alignof(BStruct) == 1\n    #\n    BStruct2 = new_struct_type(\"struct foo\")\n    complete_struct_or_union(BStruct2, [('b1', BChar, -1),\n                                        ('b2', BLong, -1)],\n                             None, -1, -1, 0, 2)\n    d = BStruct2.fields\n    assert len(d) == 2\n    assert d[0][0] == 'b1'\n    assert d[0][1].type is BChar\n    assert d[0][1].offset == 0\n    assert d[0][1].bitshift == -1\n    assert d[0][1].bitsize == -1\n    assert d[1][0] == 'b2'\n    assert d[1][1].type is BLong\n    assert d[1][1].offset == 2\n    assert d[1][1].bitshift == -1\n    assert d[1][1].bitsize == -1\n    assert sizeof(BStruct2) == 2 + sizeof(BLong)\n    assert alignof(BStruct2) == 2\n\ndef test_packed_with_bitfields():\n    if sys.platform == \"win32\":\n        py.test.skip(\"testing gcc behavior\")\n    BLong = new_primitive_type(\"long\")\n    BChar = new_primitive_type(\"char\")\n    BStruct = new_struct_type(\"struct foo\")\n    py.test.raises(NotImplementedError,\n                   complete_struct_or_union,\n                   BStruct, [('a1', BLong, 30),\n                             ('a2', BChar, 5)],\n                   None, -1, -1, SF_PACKED)\n\ndef test_from_buffer():\n    import array\n    a = array.array('H', [10000, 20000, 30000])\n    BChar = new_primitive_type(\"char\")\n    BCharP = new_pointer_type(BChar)\n    BCharA = new_array_type(BCharP, None)\n    c = from_buffer(BCharA, a)\n    assert typeof(c) is BCharA\n    assert len(c) == 6\n    assert repr(c) == \"<cdata 'char[]' buffer len 6 from 'array.array' object>\"\n    p = new_pointer_type(new_primitive_type(\"unsigned short\"))\n    cast(p, c)[1] += 500\n    assert list(a) == [10000, 20500, 30000]\n\ndef test_from_buffer_not_str_unicode():\n    BChar = new_primitive_type(\"char\")\n    BCharP = new_pointer_type(BChar)\n    BCharA = new_array_type(BCharP, None)\n    p1 = from_buffer(BCharA, b\"foo\")\n    assert p1 == from_buffer(BCharA, b\"foo\")\n    import gc; gc.collect()\n    assert p1 == from_buffer(BCharA, b\"foo\")\n    py.test.raises(TypeError, from_buffer, BCharA, u+\"foo\")\n    try:\n        from __builtin__ import buffer\n    except ImportError:\n        pass\n    else:\n        # Python 2 only\n        contents = from_buffer(BCharA, buffer(b\"foo\"))\n        assert len(contents) == len(p1)\n        for i in range(len(contents)):\n            assert contents[i] == p1[i]\n        p4 = buffer(u+\"foo\")\n        contents = from_buffer(BCharA, buffer(u+\"foo\"))\n        assert len(contents) == len(p4)\n        for i in range(len(contents)):\n            assert contents[i] == p4[i]\n    try:\n        from __builtin__ import memoryview\n    except ImportError:\n        pass\n    else:\n        contents = from_buffer(BCharA, memoryview(b\"foo\"))\n        assert len(contents) == len(p1)\n        for i in range(len(contents)):\n            assert contents[i] == p1[i]\n\n\ndef test_from_buffer_bytearray():\n    a = bytearray(b\"xyz\")\n    BChar = new_primitive_type(\"char\")\n    BCharP = new_pointer_type(BChar)\n    BCharA = new_array_type(BCharP, None)\n    p = from_buffer(BCharA, a)\n    assert typeof(p) is BCharA\n    assert len(p) == 3\n    assert repr(p) == \"<cdata 'char[]' buffer len 3 from 'bytearray' object>\"\n    assert p[2] == b\"z\"\n    p[2] = b\".\"\n    assert a[2] == ord(\".\")\n    a[2] = ord(\"?\")\n    assert p[2] == b\"?\"\n\ndef test_from_buffer_more_cases():\n    try:\n        from _cffi_backend import _testbuff\n    except ImportError:\n        py.test.skip(\"not for pypy\")\n    BChar = new_primitive_type(\"char\")\n    BCharP = new_pointer_type(BChar)\n    BCharA = new_array_type(BCharP, None)\n    #\n    def check1(bufobj, expected):\n        c = from_buffer(BCharA, bufobj)\n        assert typeof(c) is BCharA\n        if sys.version_info >= (3,):\n            expected = [bytes(c, \"ascii\") for c in expected]\n        assert list(c) == list(expected)\n    #\n    def check(methods, expected, expected_for_memoryview=None):\n        if sys.version_info >= (3,):\n            if methods <= 7:\n                return\n            if expected_for_memoryview is not None:\n                expected = expected_for_memoryview\n        class X(object):\n            pass\n        _testbuff(X, methods)\n        bufobj = X()\n        check1(bufobj, expected)\n        try:\n            from __builtin__ import buffer\n            bufobjb = buffer(bufobj)\n        except (TypeError, ImportError):\n            pass\n        else:\n            check1(bufobjb, expected)\n        try:\n            bufobjm = memoryview(bufobj)\n        except (TypeError, NameError):\n            pass\n        else:\n            check1(bufobjm, expected_for_memoryview or expected)\n    #\n    check(1, \"RDB\")\n    check(2, \"WRB\")\n    check(4, \"CHB\")\n    check(8, \"GTB\")\n    check(16, \"ROB\")\n    #\n    check(1 | 2,  \"RDB\")\n    check(1 | 4,  \"RDB\")\n    check(2 | 4,  \"CHB\")\n    check(1 | 8,  \"RDB\", \"GTB\")\n    check(1 | 16, \"RDB\", \"ROB\")\n    check(2 | 8,  \"WRB\", \"GTB\")\n    check(2 | 16, \"WRB\", \"ROB\")\n    check(4 | 8,  \"CHB\", \"GTB\")\n    check(4 | 16, \"CHB\", \"ROB\")\n\ndef test_from_buffer_require_writable():\n    BChar = new_primitive_type(\"char\")\n    BCharP = new_pointer_type(BChar)\n    BCharA = new_array_type(BCharP, None)\n    p1 = from_buffer(BCharA, b\"foo\", False)\n    assert p1 == from_buffer(BCharA, b\"foo\", False)\n    py.test.raises((TypeError, BufferError), from_buffer, BCharA, b\"foo\", True)\n    ba = bytearray(b\"foo\")\n    p1 = from_buffer(BCharA, ba, True)\n    p1[0] = b\"g\"\n    assert ba == b\"goo\"\n\ndef test_from_buffer_types():\n    BInt = new_primitive_type(\"int\")\n    BIntP = new_pointer_type(BInt)\n    BIntA = new_array_type(BIntP, None)\n    lst = [-12345678, 87654321, 489148]\n    bytestring = bytearray(buffer(newp(BIntA, lst))[:] + b'XYZ')\n    lst2 = lst + [42, -999999999]\n    bytestring2 = bytearray(buffer(newp(BIntA, lst2))[:] + b'XYZ')\n    #\n    p1 = from_buffer(BIntA, bytestring)      # int[]\n    assert typeof(p1) is BIntA\n    assert len(p1) == 3\n    assert p1[0] == lst[0]\n    assert p1[1] == lst[1]\n    assert p1[2] == lst[2]\n    with pytest.raises(IndexError):\n        p1[3]\n    with pytest.raises(IndexError):\n        p1[-1]\n    #\n    py.test.raises(TypeError, from_buffer, BInt, bytestring)\n    #\n    p2 = from_buffer(BIntP, bytestring)      # int *\n    assert p2 == p1 or 'PY_DOT_PY' in globals()\n    # note: on py.py ^^^, bytearray buffers are not emulated well enough\n    assert typeof(p2) is BIntP\n    assert p2[0] == lst[0]\n    assert p2[1] == lst[1]\n    assert p2[2] == lst[2]\n    # hopefully does not crash, but doesn't raise an exception:\n    p2[3]\n    p2[-1]\n    # not enough data even for one, but this is not enforced:\n    from_buffer(BIntP, b\"\")\n    #\n    BIntA2 = new_array_type(BIntP, 2)\n    p2 = from_buffer(BIntA2, bytestring)     # int[2]\n    assert typeof(p2) is BIntA2\n    assert len(p2) == 2\n    assert p2[0] == lst[0]\n    assert p2[1] == lst[1]\n    with pytest.raises(IndexError):\n        p2[2]\n    with pytest.raises(IndexError):\n        p2[-1]\n    assert p2 == p1 or 'PY_DOT_PY' in globals()\n    #\n    BIntA4 = new_array_type(BIntP, 4)        # int[4]: too big\n    py.test.raises(ValueError, from_buffer, BIntA4, bytestring)\n    #\n    BStruct = new_struct_type(\"foo\")\n    complete_struct_or_union(BStruct, [('a1', BInt, -1),\n                                       ('a2', BInt, -1)])\n    BStructP = new_pointer_type(BStruct)\n    BStructA = new_array_type(BStructP, None)\n    p1 = from_buffer(BStructA, bytestring2)   # struct[]\n    assert len(p1) == 2\n    assert typeof(p1) is BStructA\n    assert p1[0].a1 == lst2[0]\n    assert p1[0].a2 == lst2[1]\n    assert p1[1].a1 == lst2[2]\n    assert p1[1].a2 == lst2[3]\n    with pytest.raises(IndexError):\n        p1[2]\n    with pytest.raises(IndexError):\n        p1[-1]\n    assert repr(p1) == \"<cdata 'foo[]' buffer len 2 from 'bytearray' object>\"\n    #\n    p2 = from_buffer(BStructP, bytestring2)    # 'struct *'\n    assert p2 == p1 or 'PY_DOT_PY' in globals()\n    assert typeof(p2) is BStructP\n    assert p2.a1 == lst2[0]\n    assert p2.a2 == lst2[1]\n    assert p2[0].a1 == lst2[0]\n    assert p2[0].a2 == lst2[1]\n    assert p2[1].a1 == lst2[2]\n    assert p2[1].a2 == lst2[3]\n    # does not crash:\n    p2[2]\n    p2[-1]\n    # not enough data even for one, but this is not enforced:\n    from_buffer(BStructP, b\"\")\n    from_buffer(BStructP, b\"1234567\")\n    #\n    release(p1)\n    assert repr(p1) == \"<cdata 'foo[]' buffer RELEASED>\"\n    #\n    BEmptyStruct = new_struct_type(\"empty\")\n    complete_struct_or_union(BEmptyStruct, [], Ellipsis, 0)\n    assert sizeof(BEmptyStruct) == 0\n    BEmptyStructP = new_pointer_type(BEmptyStruct)\n    BEmptyStructA = new_array_type(BEmptyStructP, None)\n    py.test.raises(ZeroDivisionError, from_buffer,      # empty[]\n                                      BEmptyStructA, bytestring)\n    #\n    BEmptyStructA5 = new_array_type(BEmptyStructP, 5)\n    p1 = from_buffer(BEmptyStructA5, bytestring)   # struct empty[5]\n    assert typeof(p1) is BEmptyStructA5\n    assert len(p1) == 5\n    assert (cast(BIntP, p1) == from_buffer(BIntA, bytestring)\n            or 'PY_DOT_PY' in globals())\n    #\n    BVarStruct = new_struct_type(\"varfoo\")\n    BVarStructP = new_pointer_type(BVarStruct)\n    complete_struct_or_union(BVarStruct, [('a1', BInt, -1),\n                                          ('va', BIntA, -1)])\n    with pytest.raises(TypeError):\n        from_buffer(BVarStruct, bytestring)\n    pv = from_buffer(BVarStructP, bytestring)    # varfoo *\n    assert pv.a1 == lst[0]\n    assert pv.va[0] == lst[1]\n    assert pv.va[1] == lst[2]\n    assert sizeof(pv[0]) == 1 * size_of_int()\n    with pytest.raises(TypeError):\n        len(pv.va)\n    # hopefully does not crash, but doesn't raise an exception:\n    pv.va[2]\n    pv.va[-1]\n    # not enough data even for one, but this is not enforced:\n    from_buffer(BVarStructP, b\"\")\n    assert repr(pv) == \"<cdata 'varfoo *' buffer from 'bytearray' object>\"\n    assert repr(pv[0]).startswith(\"<cdata 'varfoo &' \")\n    #\n    release(pv)\n    assert repr(pv) == \"<cdata 'varfoo *' buffer RELEASED>\"\n    assert repr(pv[0]).startswith(\"<cdata 'varfoo &' \")\n    #\n    pv = from_buffer(BVarStructP, bytestring)    # make a fresh one\n    with pytest.raises(ValueError):\n        release(pv[0])\n\ndef test_memmove():\n    Short = new_primitive_type(\"short\")\n    ShortA = new_array_type(new_pointer_type(Short), None)\n    Char = new_primitive_type(\"char\")\n    CharA = new_array_type(new_pointer_type(Char), None)\n    p = newp(ShortA, [-1234, -2345, -3456, -4567, -5678])\n    memmove(p, p + 1, 4)\n    assert list(p) == [-2345, -3456, -3456, -4567, -5678]\n    p[2] = 999\n    memmove(p + 2, p, 6)\n    assert list(p) == [-2345, -3456, -2345, -3456, 999]\n    memmove(p + 4, newp(CharA, b\"\\x71\\x72\"), 2)\n    if sys.byteorder == 'little':\n        assert list(p) == [-2345, -3456, -2345, -3456, 0x7271]\n    else:\n        assert list(p) == [-2345, -3456, -2345, -3456, 0x7172]\n\ndef test_memmove_buffer():\n    import array\n    Short = new_primitive_type(\"short\")\n    ShortA = new_array_type(new_pointer_type(Short), None)\n    a = array.array('H', [10000, 20000, 30000])\n    p = newp(ShortA, 5)\n    memmove(p, a, 6)\n    assert list(p) == [10000, 20000, 30000, 0, 0]\n    memmove(p + 1, a, 6)\n    assert list(p) == [10000, 10000, 20000, 30000, 0]\n    b = array.array('h', [-1000, -2000, -3000])\n    memmove(b, a, 4)\n    assert b.tolist() == [10000, 20000, -3000]\n    assert a.tolist() == [10000, 20000, 30000]\n    p[0] = 999\n    p[1] = 998\n    p[2] = 997\n    p[3] = 996\n    p[4] = 995\n    memmove(b, p, 2)\n    assert b.tolist() == [999, 20000, -3000]\n    memmove(b, p + 2, 4)\n    assert b.tolist() == [997, 996, -3000]\n    p[2] = -p[2]\n    p[3] = -p[3]\n    memmove(b, p + 2, 6)\n    assert b.tolist() == [-997, -996, 995]\n\ndef test_memmove_readonly_readwrite():\n    SignedChar = new_primitive_type(\"signed char\")\n    SignedCharA = new_array_type(new_pointer_type(SignedChar), None)\n    p = newp(SignedCharA, 5)\n    memmove(p, b\"abcde\", 3)\n    assert list(p) == [ord(\"a\"), ord(\"b\"), ord(\"c\"), 0, 0]\n    memmove(p, bytearray(b\"ABCDE\"), 2)\n    assert list(p) == [ord(\"A\"), ord(\"B\"), ord(\"c\"), 0, 0]\n    py.test.raises((TypeError, BufferError), memmove, b\"abcde\", p, 3)\n    ba = bytearray(b\"xxxxx\")\n    memmove(dest=ba, src=p, n=3)\n    assert ba == bytearray(b\"ABcxx\")\n    memmove(ba, b\"EFGH\", 4)\n    assert ba == bytearray(b\"EFGHx\")\n\ndef test_memmove_sign_check():\n    SignedChar = new_primitive_type(\"signed char\")\n    SignedCharA = new_array_type(new_pointer_type(SignedChar), None)\n    p = newp(SignedCharA, 5)\n    py.test.raises(ValueError, memmove, p, p + 1, -1)   # not segfault\n\ndef test_memmove_bad_cdata():\n    BInt = new_primitive_type(\"int\")\n    p = cast(BInt, 42)\n    py.test.raises(TypeError, memmove, p, bytearray(b'a'), 1)\n    py.test.raises(TypeError, memmove, bytearray(b'a'), p, 1)\n\ndef test_dereference_null_ptr():\n    BInt = new_primitive_type(\"int\")\n    BIntPtr = new_pointer_type(BInt)\n    p = cast(BIntPtr, 0)\n    with pytest.raises(RuntimeError):\n        p[0]\n    with pytest.raises(RuntimeError):\n        p[0] = 42\n    with pytest.raises(RuntimeError):\n        p[42]\n    with pytest.raises(RuntimeError):\n        p[42] = -1\n\ndef test_mixup():\n    BStruct1 = new_struct_type(\"foo\")\n    BStruct2 = new_struct_type(\"foo\")   # <= same name as BStruct1\n    BStruct3 = new_struct_type(\"bar\")\n    BStruct1Ptr = new_pointer_type(BStruct1)\n    BStruct2Ptr = new_pointer_type(BStruct2)\n    BStruct3Ptr = new_pointer_type(BStruct3)\n    BStruct1PtrPtr = new_pointer_type(BStruct1Ptr)\n    BStruct2PtrPtr = new_pointer_type(BStruct2Ptr)\n    BStruct3PtrPtr = new_pointer_type(BStruct3Ptr)\n    pp1 = newp(BStruct1PtrPtr)\n    pp2 = newp(BStruct2PtrPtr)\n    pp3 = newp(BStruct3PtrPtr)\n    pp1[0] = pp1[0]\n    with pytest.raises(TypeError) as e:\n        pp3[0] = pp1[0]\n    assert str(e.value).startswith(\"initializer for ctype 'bar *' must be a \")\n    assert str(e.value).endswith(\", not cdata 'foo *'\")\n    with pytest.raises(TypeError) as e:\n        pp2[0] = pp1[0]\n    assert str(e.value) == (\"initializer for ctype 'foo *' appears indeed to \"\n                            \"be 'foo *', but the types are different (check \"\n                            \"that you are not e.g. mixing up different ffi \"\n                            \"instances)\")\n\ndef test_stdcall_function_type():\n    assert FFI_CDECL == FFI_DEFAULT_ABI\n    try:\n        stdcall = FFI_STDCALL\n    except NameError:\n        stdcall = FFI_DEFAULT_ABI\n    BInt = new_primitive_type(\"int\")\n    BFunc = new_function_type((BInt, BInt), BInt, False, stdcall)\n    if stdcall != FFI_DEFAULT_ABI:\n        assert repr(BFunc) == \"<ctype 'int(__stdcall *)(int, int)'>\"\n    else:\n        assert repr(BFunc) == \"<ctype 'int(*)(int, int)'>\"\n\ndef test_get_common_types():\n    d = {}\n    _get_common_types(d)\n    assert d['bool'] == '_Bool'\n\ndef test_unpack():\n    BChar = new_primitive_type(\"char\")\n    BArray = new_array_type(new_pointer_type(BChar), 10)   # char[10]\n    p = newp(BArray, b\"abc\\x00def\")\n    p0 = p\n    assert unpack(p, 10) == b\"abc\\x00def\\x00\\x00\\x00\"\n    assert unpack(p+1, 5) == b\"bc\\x00de\"\n\n    for typename in [\"wchar_t\", \"char16_t\", \"char32_t\"]:\n        BWChar = new_primitive_type(typename)\n        BArray = new_array_type(new_pointer_type(BWChar), 10)   # wchar_t[10]\n        p = newp(BArray, u\"abc\\x00def\")\n        assert unpack(p, 10) == u\"abc\\x00def\\x00\\x00\\x00\"\n\n    for typename, samples in [\n            (\"uint8_t\",  [0, 2**8-1]),\n            (\"uint16_t\", [0, 2**16-1]),\n            (\"uint32_t\", [0, 2**32-1]),\n            (\"uint64_t\", [0, 2**64-1]),\n            (\"int8_t\",  [-2**7, 2**7-1]),\n            (\"int16_t\", [-2**15, 2**15-1]),\n            (\"int32_t\", [-2**31, 2**31-1]),\n            (\"int64_t\", [-2**63, 2**63-1]),\n            (\"_Bool\", [False, True]),\n            (\"float\", [0.0, 10.5]),\n            (\"double\", [12.34, 56.78]),\n            ]:\n        BItem = new_primitive_type(typename)\n        BArray = new_array_type(new_pointer_type(BItem), 10)\n        p = newp(BArray, samples)\n        result = unpack(p, len(samples))\n        assert result == samples\n        for i in range(len(samples)):\n            assert result[i] == p[i] and type(result[i]) is type(p[i])\n            assert (type(result[i]) is bool) == (type(samples[i]) is bool)\n    #\n    BInt = new_primitive_type(\"int\")\n    py.test.raises(TypeError, unpack, p)\n    py.test.raises(TypeError, unpack, b\"foobar\", 6)\n    py.test.raises(TypeError, unpack, cast(BInt, 42), 1)\n    #\n    BPtr = new_pointer_type(BInt)\n    random_ptr = cast(BPtr, -424344)\n    other_ptr = cast(BPtr, 54321)\n    BArray = new_array_type(new_pointer_type(BPtr), None)\n    lst = unpack(newp(BArray, [random_ptr, other_ptr]), 2)\n    assert lst == [random_ptr, other_ptr]\n    #\n    BFunc = new_function_type((BInt, BInt), BInt, False)\n    BFuncPtr = new_pointer_type(BFunc)\n    lst = unpack(newp(new_array_type(BFuncPtr, None), 2), 2)\n    assert len(lst) == 2\n    assert not lst[0] and not lst[1]\n    assert typeof(lst[0]) is BFunc\n    #\n    BStruct = new_struct_type(\"foo\")\n    BStructPtr = new_pointer_type(BStruct)\n    e = py.test.raises(ValueError, unpack, cast(BStructPtr, 42), 5)\n    assert str(e.value) == \"'foo *' points to items of unknown size\"\n    complete_struct_or_union(BStruct, [('a1', BInt, -1),\n                                       ('a2', BInt, -1)])\n    array_of_structs = newp(new_array_type(BStructPtr, None), [[4,5], [6,7]])\n    lst = unpack(array_of_structs, 2)\n    assert typeof(lst[0]) is BStruct\n    assert lst[0].a1 == 4 and lst[1].a2 == 7\n    #\n    py.test.raises(RuntimeError, unpack, cast(new_pointer_type(BChar), 0), 0)\n    py.test.raises(RuntimeError, unpack, cast(new_pointer_type(BChar), 0), 10)\n    #\n    py.test.raises(ValueError, unpack, p0, -1)\n    py.test.raises(ValueError, unpack, p, -1)\n\ndef test_cdata_dir():\n    BInt = new_primitive_type(\"int\")\n    p = cast(BInt, 42)\n    check_dir(p, [])\n    p = newp(new_array_type(new_pointer_type(BInt), None), 5)\n    check_dir(p, [])\n    BStruct = new_struct_type(\"foo\")\n    p = cast(new_pointer_type(BStruct), 0)\n    check_dir(p, [])    # opaque\n    complete_struct_or_union(BStruct, [('a2', BInt, -1),\n                                       ('a1', BInt, -1)])\n    check_dir(p, ['a1', 'a2'])   # always sorted\n    p = newp(new_pointer_type(BStruct), None)\n    check_dir(p, ['a1', 'a2'])\n    check_dir(p[0], ['a1', 'a2'])\n    pp = newp(new_pointer_type(new_pointer_type(BStruct)), p)\n    check_dir(pp, [])\n    check_dir(pp[0], ['a1', 'a2'])\n    check_dir(pp[0][0], ['a1', 'a2'])\n\ndef test_char_pointer_conversion():\n    import warnings\n    assert __version__.startswith(\"1.\"), (\n        \"the warning will be an error if we ever release cffi 2.x\")\n    BCharP = new_pointer_type(new_primitive_type(\"char\"))\n    BIntP = new_pointer_type(new_primitive_type(\"int\"))\n    BVoidP = new_pointer_type(new_void_type())\n    BUCharP = new_pointer_type(new_primitive_type(\"unsigned char\"))\n    z1 = cast(BCharP, 0)\n    z2 = cast(BIntP, 0)\n    z3 = cast(BVoidP, 0)\n    z4 = cast(BUCharP, 0)\n    with warnings.catch_warnings(record=True) as w:\n        warnings.simplefilter(\"always\")\n        newp(new_pointer_type(BIntP), z1)    # warn\n        assert len(w) == 1\n        newp(new_pointer_type(BVoidP), z1)   # fine\n        assert len(w) == 1\n        newp(new_pointer_type(BCharP), z2)   # warn\n        assert len(w) == 2\n        newp(new_pointer_type(BVoidP), z2)   # fine\n        assert len(w) == 2\n        newp(new_pointer_type(BCharP), z3)   # fine\n        assert len(w) == 2\n        newp(new_pointer_type(BIntP), z3)    # fine\n        assert len(w) == 2\n        newp(new_pointer_type(BCharP), z4)   # fine (ignore signedness here)\n        assert len(w) == 2\n        newp(new_pointer_type(BUCharP), z1)  # fine (ignore signedness here)\n        assert len(w) == 2\n        newp(new_pointer_type(BUCharP), z3)  # fine\n        assert len(w) == 2\n    # check that the warnings are associated with lines in this file\n    assert w[1].lineno == w[0].lineno + 4\n\ndef test_primitive_comparison():\n    def assert_eq(a, b):\n        assert (a == b) is True\n        assert (b == a) is True\n        assert (a != b) is False\n        assert (b != a) is False\n        assert (a < b) is False\n        assert (a <= b) is True\n        assert (a > b) is False\n        assert (a >= b) is True\n        assert (b < a) is False\n        assert (b <= a) is True\n        assert (b > a) is False\n        assert (b >= a) is True\n        assert hash(a) == hash(b)\n    def assert_lt(a, b, check_hash=True):\n        assert (a == b) is False\n        assert (b == a) is False\n        assert (a != b) is True\n        assert (b != a) is True\n        assert (a < b) is True\n        assert (a <= b) is True\n        assert (a > b) is False\n        assert (a >= b) is False\n        assert (b < a) is False\n        assert (b <= a) is False\n        assert (b > a) is True\n        assert (b >= a) is True\n        if check_hash:\n            assert hash(a) != hash(b)    # (or at least, it is unlikely)\n    def assert_gt(a, b, check_hash=True):\n        assert_lt(b, a, check_hash)\n    def assert_ne(a, b):\n        assert (a == b) is False\n        assert (b == a) is False\n        assert (a != b) is True\n        assert (b != a) is True\n        if strict_compare:\n            with pytest.raises(TypeError): a < b\n            with pytest.raises(TypeError): a <= b\n            with pytest.raises(TypeError): a > b\n            with pytest.raises(TypeError): a >= b\n            with pytest.raises(TypeError): b < a\n            with pytest.raises(TypeError): b <= a\n            with pytest.raises(TypeError): b > a\n            with pytest.raises(TypeError): b >= a\n        elif a < b:\n            assert_lt(a, b)\n        else:\n            assert_lt(b, a)\n    assert_eq(5, 5)\n    assert_lt(3, 5)\n    assert_ne('5', 5)\n    #\n    t1 = new_primitive_type(\"char\")\n    t2 = new_primitive_type(\"int\")\n    t3 = new_primitive_type(\"unsigned char\")\n    t4 = new_primitive_type(\"unsigned int\")\n    t5 = new_primitive_type(\"float\")\n    t6 = new_primitive_type(\"double\")\n    assert_eq(cast(t1, 65), b'A')\n    assert_lt(cast(t1, 64), b'\\x99')\n    assert_gt(cast(t1, 200), b'A')\n    assert_ne(cast(t1, 65), 65)\n    assert_eq(cast(t2, -25), -25)\n    assert_lt(cast(t2, -25), -24)\n    assert_gt(cast(t2, -25), -26)\n    assert_eq(cast(t3, 65), 65)\n    assert_ne(cast(t3, 65), b'A')\n    assert_ne(cast(t3, 65), cast(t1, 65))\n    assert_gt(cast(t4, -1), -1, check_hash=False)\n    assert_gt(cast(t4, -1), cast(t2, -1), check_hash=False)\n    assert_gt(cast(t4, -1), 99999)\n    assert_eq(cast(t4, -1), 256 ** size_of_int() - 1)\n    assert_eq(cast(t5, 3.0), 3)\n    assert_eq(cast(t5, 3.5), 3.5)\n    assert_lt(cast(t5, 3.3), 3.3)   # imperfect rounding\n    assert_eq(cast(t6, 3.3), 3.3)\n    assert_eq(cast(t5, 3.5), cast(t6, 3.5))\n    assert_lt(cast(t5, 3.1), cast(t6, 3.1))   # imperfect rounding\n    assert_eq(cast(t5, 7.0), cast(t3, 7))\n    assert_lt(cast(t5, 3.1), 3.101)\n    assert_gt(cast(t5, 3.1), 3)\n\ndef test_explicit_release_new():\n    # release() on a ffi.new() object has no effect on CPython, but\n    # really releases memory on PyPy.  We can't test that effect\n    # though, because a released cdata is not marked.\n    BIntP = new_pointer_type(new_primitive_type(\"int\"))\n    p = newp(BIntP)\n    p[0] = 42\n    with pytest.raises(IndexError):\n        p[1]\n    release(p)\n    # here, reading p[0] might give garbage or segfault...\n    release(p)   # no effect\n    #\n    BStruct = new_struct_type(\"struct foo\")\n    BStructP = new_pointer_type(BStruct)\n    complete_struct_or_union(BStruct, [('p', BIntP, -1)])\n    pstruct = newp(BStructP)\n    assert pstruct.p == cast(BIntP, 0)\n    release(pstruct)\n    # here, reading pstruct.p might give garbage or segfault...\n    release(pstruct)   # no effect\n\ndef test_explicit_release_new_contextmgr():\n    BIntP = new_pointer_type(new_primitive_type(\"int\"))\n    with newp(BIntP) as p:\n        p[0] = 42\n        assert p[0] == 42\n    # here, reading p[0] might give garbage or segfault...\n    release(p)   # no effect\n\ndef test_explicit_release_badtype():\n    BIntP = new_pointer_type(new_primitive_type(\"int\"))\n    p = cast(BIntP, 12345)\n    py.test.raises(ValueError, release, p)\n    py.test.raises(ValueError, release, p)\n    BStruct = new_struct_type(\"struct foo\")\n    BStructP = new_pointer_type(BStruct)\n    complete_struct_or_union(BStruct, [('p', BIntP, -1)])\n    pstruct = newp(BStructP)\n    py.test.raises(ValueError, release, pstruct[0])\n\ndef test_explicit_release_badtype_contextmgr():\n    BIntP = new_pointer_type(new_primitive_type(\"int\"))\n    p = cast(BIntP, 12345)\n    with pytest.raises(ValueError):\n        with p:\n            pass\n    with pytest.raises(ValueError):\n        with p:\n            pass\n\ndef test_explicit_release_gc():\n    BIntP = new_pointer_type(new_primitive_type(\"int\"))\n    seen = []\n    intp1 = newp(BIntP, 12345)\n    p1 = cast(BIntP, intp1)\n    p = gcp(p1, seen.append)\n    assert seen == []\n    release(p)\n    assert seen == [p1]\n    assert p1[0] == 12345\n    assert p[0] == 12345  # true so far, but might change to raise RuntimeError\n    release(p)   # no effect\n\ndef test_explicit_release_gc_contextmgr():\n    BIntP = new_pointer_type(new_primitive_type(\"int\"))\n    seen = []\n    intp1 = newp(BIntP, 12345)\n    p1 = cast(BIntP, intp1)\n    p = gcp(p1, seen.append)\n    with p:\n        assert p[0] == 12345\n        assert seen == []\n    assert seen == [p1]\n    assert p1[0] == 12345\n    assert p[0] == 12345  # true so far, but might change to raise RuntimeError\n    release(p)   # no effect\n\ndef test_explicit_release_from_buffer():\n    a = bytearray(b\"xyz\")\n    BChar = new_primitive_type(\"char\")\n    BCharP = new_pointer_type(BChar)\n    BCharA = new_array_type(BCharP, None)\n    p = from_buffer(BCharA, a)\n    assert p[2] == b\"z\"\n    assert repr(p) == \"<cdata 'char[]' buffer len 3 from 'bytearray' object>\"\n    release(p)\n    assert p[2] == b\"z\"  # true so far, but might change to raise RuntimeError\n    assert repr(p) == \"<cdata 'char[]' buffer RELEASED>\"\n    release(p)   # no effect\n\ndef test_explicit_release_from_buffer_contextmgr():\n    a = bytearray(b\"xyz\")\n    BChar = new_primitive_type(\"char\")\n    BCharP = new_pointer_type(BChar)\n    BCharA = new_array_type(BCharP, None)\n    p = from_buffer(BCharA, a)\n    with p:\n        assert p[2] == b\"z\"\n    assert p[2] == b\"z\"  # true so far, but might change to raise RuntimeError\n    assert repr(p) == \"<cdata 'char[]' buffer RELEASED>\"\n    release(p)   # no effect\n\ndef test_explicit_release_bytearray_on_cpython():\n    if '__pypy__' in sys.builtin_module_names:\n        py.test.skip(\"pypy's bytearray are never locked\")\n    a = bytearray(b\"xyz\")\n    BChar = new_primitive_type(\"char\")\n    BCharP = new_pointer_type(BChar)\n    BCharA = new_array_type(BCharP, None)\n    a += b't' * 10\n    p = from_buffer(BCharA, a)\n    with pytest.raises(BufferError):\n        a += b'u' * 100\n    release(p)\n    a += b'v' * 100\n    release(p)   # no effect\n    a += b'w' * 1000\n    assert a == bytearray(b\"xyz\" + b't' * 10 + b'v' * 100 + b'w' * 1000)\n\ndef test_int_doesnt_give_bool():\n    BBool = new_primitive_type(\"_Bool\")\n    x = int(cast(BBool, 42))\n    assert type(x) is int and x == 1\n    x = long(cast(BBool, 42))\n    assert type(x) is long and x == 1\n    with pytest.raises(TypeError):\n        float(cast(BBool, 42))\n    with pytest.raises(TypeError):\n        complex(cast(BBool, 42))\n\ndef test_cannot_call_null_function_pointer():\n    BInt = new_primitive_type(\"int\")\n    BFunc = new_function_type((BInt, BInt), BInt, False)\n    f = cast(BFunc, 0)\n    with pytest.raises(RuntimeError):\n        f(40, 2)\n\ndef test_huge_structure():\n    BChar = new_primitive_type(\"char\")\n    BArray = new_array_type(new_pointer_type(BChar), sys.maxsize)\n    assert sizeof(BArray) == sys.maxsize\n    BStruct = new_struct_type(\"struct foo\")\n    complete_struct_or_union(BStruct, [('a1', BArray, -1)])\n    assert sizeof(BStruct) == sys.maxsize\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.13.0-jlicqgsrlask3n7tsdckxmdwv6d5zp4o/spack-src/c/cffi1_module.c": "\n#include \"parse_c_type.c\"\n#include \"realize_c_type.c\"\n\n#define CFFI_VERSION_MIN            0x2601\n#define CFFI_VERSION_CHAR16CHAR32   0x2801\n#define CFFI_VERSION_MAX            0x28FF\n\ntypedef struct FFIObject_s FFIObject;\ntypedef struct LibObject_s LibObject;\n\nstatic PyTypeObject FFI_Type;   /* forward */\nstatic PyTypeObject Lib_Type;   /* forward */\n\n#include \"ffi_obj.c\"\n#include \"cglob.c\"\n#include \"lib_obj.c\"\n#include \"cdlopen.c\"\n#include \"commontypes.c\"\n#include \"call_python.c\"\n\n\nstatic int init_ffi_lib(PyObject *m)\n{\n    PyObject *x;\n    int i, res;\n    static char init_done = 0;\n\n    if (PyType_Ready(&FFI_Type) < 0)\n        return -1;\n    if (PyType_Ready(&Lib_Type) < 0)\n        return -1;\n\n    if (!init_done) {\n        if (init_global_types_dict(FFI_Type.tp_dict) < 0)\n            return -1;\n\n        FFIError = PyErr_NewException(\"ffi.error\", NULL, NULL);\n        if (FFIError == NULL)\n            return -1;\n        if (PyDict_SetItemString(FFI_Type.tp_dict, \"error\", FFIError) < 0)\n            return -1;\n        if (PyDict_SetItemString(FFI_Type.tp_dict, \"CType\",\n                                 (PyObject *)&CTypeDescr_Type) < 0)\n            return -1;\n        if (PyDict_SetItemString(FFI_Type.tp_dict, \"CData\",\n                                 (PyObject *)&CData_Type) < 0)\n            return -1;\n        if (PyDict_SetItemString(FFI_Type.tp_dict, \"buffer\",\n                                 (PyObject *)&MiniBuffer_Type) < 0)\n            return -1;\n\n        for (i = 0; all_dlopen_flags[i].name != NULL; i++) {\n            x = PyInt_FromLong(all_dlopen_flags[i].value);\n            if (x == NULL)\n                return -1;\n            res = PyDict_SetItemString(FFI_Type.tp_dict,\n                                       all_dlopen_flags[i].name, x);\n            Py_DECREF(x);\n            if (res < 0)\n                return -1;\n        }\n        init_done = 1;\n    }\n\n    x = (PyObject *)&FFI_Type;\n    Py_INCREF(x);\n    if (PyModule_AddObject(m, \"FFI\", x) < 0)\n        return -1;\n    x = (PyObject *)&Lib_Type;\n    Py_INCREF(x);\n    if (PyModule_AddObject(m, \"Lib\", x) < 0)\n        return -1;\n\n    return 0;\n}\n\nstatic int make_included_tuples(char *module_name,\n                                const char *const *ctx_includes,\n                                PyObject **included_ffis,\n                                PyObject **included_libs)\n{\n    Py_ssize_t num = 0;\n    const char *const *p_include;\n\n    if (ctx_includes == NULL)\n        return 0;\n\n    for (p_include = ctx_includes; *p_include; p_include++) {\n        num++;\n    }\n    *included_ffis = PyTuple_New(num);\n    *included_libs = PyTuple_New(num);\n    if (*included_ffis == NULL || *included_libs == NULL)\n        goto error;\n\n    num = 0;\n    for (p_include = ctx_includes; *p_include; p_include++) {\n        PyObject *included_ffi, *included_lib;\n        PyObject *m = PyImport_ImportModule(*p_include);\n        if (m == NULL)\n            goto import_error;\n\n        included_ffi = PyObject_GetAttrString(m, \"ffi\");\n        PyTuple_SET_ITEM(*included_ffis, num, included_ffi);\n\n        included_lib = (included_ffi == NULL) ? NULL :\n                       PyObject_GetAttrString(m, \"lib\");\n        PyTuple_SET_ITEM(*included_libs, num, included_lib);\n\n        Py_DECREF(m);\n        if (included_lib == NULL)\n            goto import_error;\n\n        if (!FFIObject_Check(included_ffi) ||\n            !LibObject_Check(included_lib))\n            goto import_error;\n        num++;\n    }\n    return 0;\n\n import_error:\n    PyErr_Format(PyExc_ImportError,\n                 \"while loading %.200s: failed to import ffi, lib from %.200s\",\n                 module_name, *p_include);\n error:\n    Py_XDECREF(*included_ffis); *included_ffis = NULL;\n    Py_XDECREF(*included_libs); *included_libs = NULL;\n    return -1;\n}\n\nstatic PyObject *_my_Py_InitModule(char *module_name)\n{\n#if PY_MAJOR_VERSION >= 3\n    struct PyModuleDef *module_def, local_module_def = {\n        PyModuleDef_HEAD_INIT,\n        module_name,\n        NULL,\n        -1,\n        NULL, NULL, NULL, NULL, NULL\n    };\n    /* note: the 'module_def' is allocated dynamically and leaks,\n       but anyway the C extension module can never be unloaded */\n    module_def = PyMem_Malloc(sizeof(struct PyModuleDef));\n    if (module_def == NULL)\n        return PyErr_NoMemory();\n    *module_def = local_module_def;\n    return PyModule_Create(module_def);\n#else\n    return Py_InitModule(module_name, NULL);\n#endif\n}\n\nstatic PyObject *b_init_cffi_1_0_external_module(PyObject *self, PyObject *arg)\n{\n    PyObject *m, *modules_dict;\n    FFIObject *ffi;\n    LibObject *lib;\n    Py_ssize_t version, num_exports;\n    char *module_name, *exports, *module_name_with_lib;\n    void **raw;\n    const struct _cffi_type_context_s *ctx;\n\n    raw = (void **)PyLong_AsVoidPtr(arg);\n    if (raw == NULL)\n        return NULL;\n\n    module_name = (char *)raw[0];\n    version = (Py_ssize_t)raw[1];\n    exports = (char *)raw[2];\n    ctx = (const struct _cffi_type_context_s *)raw[3];\n\n    if (version < CFFI_VERSION_MIN || version > CFFI_VERSION_MAX) {\n        if (!PyErr_Occurred())\n            PyErr_Format(PyExc_ImportError,\n                \"cffi extension module '%s' uses an unknown version tag %p. \"\n                \"This module might need a more recent version of cffi \"\n                \"than the one currently installed, which is %s\",\n                module_name, (void *)version, CFFI_VERSION);\n        return NULL;\n    }\n\n    /* initialize the exports array */\n    num_exports = 25;\n    if (ctx->flags & 1)    /* set to mean that 'extern \"Python\"' is used */\n        num_exports = 26;\n    if (version >= CFFI_VERSION_CHAR16CHAR32)\n        num_exports = 28;\n    memcpy(exports, (char *)cffi_exports, num_exports * sizeof(void *));\n\n    /* make the module object */\n    m = _my_Py_InitModule(module_name);\n    if (m == NULL)\n        return NULL;\n\n    /* build the FFI and Lib object inside this new module */\n    ffi = ffi_internal_new(&FFI_Type, ctx);\n    Py_XINCREF(ffi);    /* make the ffi object really immortal */\n    if (ffi == NULL || PyModule_AddObject(m, \"ffi\", (PyObject *)ffi) < 0)\n        return NULL;\n\n    lib = lib_internal_new(ffi, module_name, NULL);\n    if (lib == NULL || PyModule_AddObject(m, \"lib\", (PyObject *)lib) < 0)\n        return NULL;\n\n    if (make_included_tuples(module_name, ctx->includes,\n                             &ffi->types_builder.included_ffis,\n                             &lib->l_types_builder->included_libs) < 0)\n        return NULL;\n\n    /* add manually 'module_name.lib' in sys.modules:\n       see test_import_from_lib */\n    modules_dict = PySys_GetObject(\"modules\");\n    if (!modules_dict)\n        return NULL;\n    module_name_with_lib = alloca(strlen(module_name) + 5);\n    strcpy(module_name_with_lib, module_name);\n    strcat(module_name_with_lib, \".lib\");\n    if (PyDict_SetItemString(modules_dict, module_name_with_lib,\n                             (PyObject *)lib) < 0)\n        return NULL;\n\n#if PY_MAJOR_VERSION >= 3\n    /* add manually 'module_name' in sys.modules: it seems that \n       Py_InitModule() is not enough to do that */\n    if (PyDict_SetItemString(modules_dict, module_name, m) < 0)\n        return NULL;\n#endif\n\n    return m;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.13.0-jlicqgsrlask3n7tsdckxmdwv6d5zp4o/spack-src/c/cdlopen.c": "/* ffi.dlopen() interface with dlopen()/dlsym()/dlclose() */\n\nstatic void *cdlopen_fetch(PyObject *libname, void *libhandle,\n                           const char *symbol)\n{\n    void *address;\n\n    if (libhandle == NULL) {\n        PyErr_Format(FFIError, \"library '%s' has been closed\",\n                     PyText_AS_UTF8(libname));\n        return NULL;\n    }\n\n    dlerror();   /* clear error condition */\n    address = dlsym(libhandle, symbol);\n    if (address == NULL) {\n        const char *error = dlerror();\n        PyErr_Format(FFIError, \"symbol '%s' not found in library '%s': %s\",\n                     symbol, PyText_AS_UTF8(libname), error);\n    }\n    return address;\n}\n\nstatic void cdlopen_close_ignore_errors(void *libhandle)\n{\n    if (libhandle != NULL)\n        dlclose(libhandle);\n}\n\nstatic int cdlopen_close(PyObject *libname, void *libhandle)\n{\n    if (libhandle != NULL && dlclose(libhandle) != 0) {\n        const char *error = dlerror();\n        PyErr_Format(FFIError, \"closing library '%s': %s\",\n                     PyText_AS_UTF8(libname), error);\n        return -1;\n    }\n    return 0;\n}\n\nstatic PyObject *ffi_dlopen(PyObject *self, PyObject *args)\n{\n    const char *modname;\n    PyObject *temp, *result = NULL;\n    void *handle;\n\n    handle = b_do_dlopen(args, &modname, &temp);\n    if (handle != NULL)\n    {\n        result = (PyObject *)lib_internal_new((FFIObject *)self,\n                                              modname, handle);\n    }\n    Py_XDECREF(temp);\n    return result;\n}\n\nstatic PyObject *ffi_dlclose(PyObject *self, PyObject *args)\n{\n    LibObject *lib;\n    void *libhandle;\n    if (!PyArg_ParseTuple(args, \"O!\", &Lib_Type, &lib))\n        return NULL;\n\n    libhandle = lib->l_libhandle;\n    if (libhandle != NULL)\n    {\n        lib->l_libhandle = NULL;\n\n        /* Clear the dict to force further accesses to do cdlopen_fetch()\n           again, and fail because the library was closed. */\n        PyDict_Clear(lib->l_dict);\n\n        if (cdlopen_close(lib->l_libname, libhandle) < 0)\n            return NULL;\n    }\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\n\nstatic Py_ssize_t cdl_4bytes(char *src)\n{\n    /* read 4 bytes in little-endian order; return it as a signed integer */\n    signed char *ssrc = (signed char *)src;\n    unsigned char *usrc = (unsigned char *)src;\n    return (ssrc[0] << 24) | (usrc[1] << 16) | (usrc[2] << 8) | usrc[3];\n}\n\nstatic _cffi_opcode_t cdl_opcode(char *src)\n{\n    return (_cffi_opcode_t)cdl_4bytes(src);\n}\n\ntypedef struct {\n    unsigned long long value;\n    int neg;\n} cdl_intconst_t;\n\nstatic int _cdl_realize_global_int(struct _cffi_getconst_s *gc)\n{\n    /* The 'address' field of 'struct _cffi_global_s' is set to point\n       to this function in case ffiobj_init() sees constant integers.\n       This fishes around after the 'ctx->globals' array, which is\n       initialized to contain another array, this time of\n       'cdl_intconst_t' structures.  We get the nth one and it tells\n       us what to return.\n    */\n    cdl_intconst_t *ic;\n    ic = (cdl_intconst_t *)(gc->ctx->globals + gc->ctx->num_globals);\n    ic += gc->gindex;\n    gc->value = ic->value;\n    return ic->neg;\n}\n\nstatic int ffiobj_init(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    FFIObject *ffi;\n    static char *keywords[] = {\"module_name\", \"_version\", \"_types\",\n                               \"_globals\", \"_struct_unions\", \"_enums\",\n                               \"_typenames\", \"_includes\", NULL};\n    char *ffiname = \"?\", *types = NULL, *building = NULL;\n    Py_ssize_t version = -1;\n    Py_ssize_t types_len = 0;\n    PyObject *globals = NULL, *struct_unions = NULL, *enums = NULL;\n    PyObject *typenames = NULL, *includes = NULL;\n\n    if (!PyArg_ParseTupleAndKeywords(args, kwds,\n                                     \"|sns#O!O!O!O!O!:FFI\", keywords,\n                                     &ffiname, &version, &types, &types_len,\n                                     &PyTuple_Type, &globals,\n                                     &PyTuple_Type, &struct_unions,\n                                     &PyTuple_Type, &enums,\n                                     &PyTuple_Type, &typenames,\n                                     &PyTuple_Type, &includes))\n        return -1;\n\n    ffi = (FFIObject *)self;\n    if (ffi->ctx_is_nonempty) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"cannot call FFI.__init__() more than once\");\n        return -1;\n    }\n    ffi->ctx_is_nonempty = 1;\n\n    if (version == -1 && types_len == 0)\n        return 0;\n    if (version < CFFI_VERSION_MIN || version > CFFI_VERSION_MAX) {\n        PyErr_Format(PyExc_ImportError,\n                     \"cffi out-of-line Python module '%s' has unknown \"\n                     \"version %p\", ffiname, (void *)version);\n        return -1;\n    }\n\n    if (types_len > 0) {\n        /* unpack a string of 4-byte entries into an array of _cffi_opcode_t */\n        _cffi_opcode_t *ntypes;\n        Py_ssize_t i, n = types_len / 4;\n\n        building = PyMem_Malloc(n * sizeof(_cffi_opcode_t));\n        if (building == NULL)\n            goto error;\n        ntypes = (_cffi_opcode_t *)building;\n\n        for (i = 0; i < n; i++) {\n            ntypes[i] = cdl_opcode(types);\n            types += 4;\n        }\n        ffi->types_builder.ctx.types = ntypes;\n        ffi->types_builder.ctx.num_types = n;\n        building = NULL;\n    }\n\n    if (globals != NULL) {\n        /* unpack a tuple alternating strings and ints, each two together\n           describing one global_s entry with no specified address or size.\n           The int is only used with integer constants. */\n        struct _cffi_global_s *nglobs;\n        cdl_intconst_t *nintconsts;\n        Py_ssize_t i, n = PyTuple_GET_SIZE(globals) / 2;\n\n        i = n * (sizeof(struct _cffi_global_s) + sizeof(cdl_intconst_t));\n        building = PyMem_Malloc(i);\n        if (building == NULL)\n            goto error;\n        memset(building, 0, i);\n        nglobs = (struct _cffi_global_s *)building;\n        nintconsts = (cdl_intconst_t *)(nglobs + n);\n\n        for (i = 0; i < n; i++) {\n            char *g = PyBytes_AS_STRING(PyTuple_GET_ITEM(globals, i * 2));\n            nglobs[i].type_op = cdl_opcode(g); g += 4;\n            nglobs[i].name = g;\n            if (_CFFI_GETOP(nglobs[i].type_op) == _CFFI_OP_CONSTANT_INT ||\n                _CFFI_GETOP(nglobs[i].type_op) == _CFFI_OP_ENUM) {\n                PyObject *o = PyTuple_GET_ITEM(globals, i * 2 + 1);\n                nglobs[i].address = &_cdl_realize_global_int;\n#if PY_MAJOR_VERSION < 3\n                if (PyInt_Check(o)) {\n                    nintconsts[i].neg = PyInt_AS_LONG(o) <= 0;\n                    nintconsts[i].value = (long long)PyInt_AS_LONG(o);\n                }\n                else\n#endif\n                {\n                    nintconsts[i].neg = PyObject_RichCompareBool(o, Py_False,\n                                                                 Py_LE);\n                    nintconsts[i].value = PyLong_AsUnsignedLongLongMask(o);\n                    if (PyErr_Occurred())\n                        goto error;\n                }\n            }\n        }\n        ffi->types_builder.ctx.globals = nglobs;\n        ffi->types_builder.ctx.num_globals = n;\n        building = NULL;\n    }\n\n    if (struct_unions != NULL) {\n        /* unpack a tuple of struct/unions, each described as a sub-tuple;\n           the item 0 of each sub-tuple describes the struct/union, and\n           the items 1..N-1 describe the fields, if any */\n        struct _cffi_struct_union_s *nstructs;\n        struct _cffi_field_s *nfields;\n        Py_ssize_t i, n = PyTuple_GET_SIZE(struct_unions);\n        Py_ssize_t nf = 0;   /* total number of fields */\n\n        for (i = 0; i < n; i++) {\n            nf += PyTuple_GET_SIZE(PyTuple_GET_ITEM(struct_unions, i)) - 1;\n        }\n        i = (n * sizeof(struct _cffi_struct_union_s) +\n             nf * sizeof(struct _cffi_field_s));\n        building = PyMem_Malloc(i);\n        if (building == NULL)\n            goto error;\n        memset(building, 0, i);\n        nstructs = (struct _cffi_struct_union_s *)building;\n        nfields = (struct _cffi_field_s *)(nstructs + n);\n        nf = 0;\n\n        for (i = 0; i < n; i++) {\n            /* 'desc' is the tuple of strings (desc_struct, desc_field_1, ..) */\n            PyObject *desc = PyTuple_GET_ITEM(struct_unions, i);\n            Py_ssize_t j, nf1 = PyTuple_GET_SIZE(desc) - 1;\n            char *s = PyBytes_AS_STRING(PyTuple_GET_ITEM(desc, 0));\n            /* 's' is the first string, describing the struct/union */\n            nstructs[i].type_index = cdl_4bytes(s); s += 4;\n            nstructs[i].flags = cdl_4bytes(s); s += 4;\n            nstructs[i].name = s;\n            if (nstructs[i].flags & (_CFFI_F_OPAQUE | _CFFI_F_EXTERNAL)) {\n                nstructs[i].size = (size_t)-1;\n                nstructs[i].alignment = -1;\n                nstructs[i].first_field_index = -1;\n                nstructs[i].num_fields = 0;\n                assert(nf1 == 0);\n            }\n            else {\n                nstructs[i].size = (size_t)-2;\n                nstructs[i].alignment = -2;\n                nstructs[i].first_field_index = nf;\n                nstructs[i].num_fields = nf1;\n            }\n            for (j = 0; j < nf1; j++) {\n                char *f = PyBytes_AS_STRING(PyTuple_GET_ITEM(desc, j + 1));\n                /* 'f' is one of the other strings beyond the first one,\n                   describing one field each */\n                nfields[nf].field_type_op = cdl_opcode(f); f += 4;\n                nfields[nf].field_offset = (size_t)-1;\n                if (_CFFI_GETOP(nfields[nf].field_type_op) != _CFFI_OP_NOOP) {\n                    nfields[nf].field_size = cdl_4bytes(f); f += 4;\n                }\n                else {\n                    nfields[nf].field_size = (size_t)-1;\n                }\n                nfields[nf].name = f;\n                nf++;\n            }\n        }\n        ffi->types_builder.ctx.struct_unions = nstructs;\n        ffi->types_builder.ctx.fields = nfields;\n        ffi->types_builder.ctx.num_struct_unions = n;\n        building = NULL;\n    }\n\n    if (enums != NULL) {\n        /* unpack a tuple of strings, each of which describes one enum_s\n           entry */\n        struct _cffi_enum_s *nenums;\n        Py_ssize_t i, n = PyTuple_GET_SIZE(enums);\n\n        i = n * sizeof(struct _cffi_enum_s);\n        building = PyMem_Malloc(i);\n        if (building == NULL)\n            goto error;\n        memset(building, 0, i);\n        nenums = (struct _cffi_enum_s *)building;\n\n        for (i = 0; i < n; i++) {\n            char *e = PyBytes_AS_STRING(PyTuple_GET_ITEM(enums, i));\n            /* 'e' is a string describing the enum */\n            nenums[i].type_index = cdl_4bytes(e); e += 4;\n            nenums[i].type_prim = cdl_4bytes(e); e += 4;\n            nenums[i].name = e; e += strlen(e) + 1;\n            nenums[i].enumerators = e;\n        }\n        ffi->types_builder.ctx.enums = nenums;\n        ffi->types_builder.ctx.num_enums = n;\n        building = NULL;\n    }\n\n    if (typenames != NULL) {\n        /* unpack a tuple of strings, each of which describes one typename_s\n           entry */\n        struct _cffi_typename_s *ntypenames;\n        Py_ssize_t i, n = PyTuple_GET_SIZE(typenames);\n\n        i = n * sizeof(struct _cffi_typename_s);\n        building = PyMem_Malloc(i);\n        if (building == NULL)\n            goto error;\n        memset(building, 0, i);\n        ntypenames = (struct _cffi_typename_s *)building;\n\n        for (i = 0; i < n; i++) {\n            char *t = PyBytes_AS_STRING(PyTuple_GET_ITEM(typenames, i));\n            /* 't' is a string describing the typename */\n            ntypenames[i].type_index = cdl_4bytes(t); t += 4;\n            ntypenames[i].name = t;\n        }\n        ffi->types_builder.ctx.typenames = ntypenames;\n        ffi->types_builder.ctx.num_typenames = n;\n        building = NULL;\n    }\n\n    if (includes != NULL) {\n        PyObject *included_libs;\n\n        included_libs = PyTuple_New(PyTuple_GET_SIZE(includes));\n        if (included_libs == NULL)\n            return -1;\n\n        Py_INCREF(includes);\n        ffi->types_builder.included_ffis = includes;\n        ffi->types_builder.included_libs = included_libs;\n    }\n\n    /* Above, we took directly some \"char *\" strings out of the strings,\n       typically from somewhere inside tuples.  Keep them alive by\n       incref'ing the whole input arguments. */\n    Py_INCREF(args);\n    Py_XINCREF(kwds);\n    ffi->types_builder._keepalive1 = args;\n    ffi->types_builder._keepalive2 = kwds;\n    return 0;\n\n error:\n    if (building != NULL)\n        PyMem_Free(building);\n    if (!PyErr_Occurred())\n        PyErr_NoMemory();\n    return -1;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.13.0-jlicqgsrlask3n7tsdckxmdwv6d5zp4o/spack-src/c/misc_win32.h": "#include <malloc.h>   /* for alloca() */\n\n\n/************************************************************/\n/* errno and GetLastError support */\n\n#include \"misc_thread_common.h\"\n\nstatic DWORD cffi_tls_index = TLS_OUT_OF_INDEXES;\n\nBOOL WINAPI DllMain(HINSTANCE hinstDLL,\n                    DWORD     reason_for_call,\n                    LPVOID    reserved)\n{\n    LPVOID p;\n\n    switch (reason_for_call) {\n\n    case DLL_THREAD_DETACH:\n        if (cffi_tls_index != TLS_OUT_OF_INDEXES) {\n            p = TlsGetValue(cffi_tls_index);\n            if (p != NULL) {\n                TlsSetValue(cffi_tls_index, NULL);\n                cffi_thread_shutdown(p);\n            }\n        }\n        break;\n\n    default:\n        break;\n    }\n    return TRUE;\n}\n\nstatic void init_cffi_tls(void)\n{\n    if (cffi_tls_index == TLS_OUT_OF_INDEXES) {\n        cffi_tls_index = TlsAlloc();\n        if (cffi_tls_index == TLS_OUT_OF_INDEXES)\n            PyErr_SetString(PyExc_WindowsError, \"TlsAlloc() failed\");\n    }\n}\n\nstatic struct cffi_tls_s *get_cffi_tls(void)\n{\n    LPVOID p = TlsGetValue(cffi_tls_index);\n\n    if (p == NULL) {\n        p = malloc(sizeof(struct cffi_tls_s));\n        if (p == NULL)\n            return NULL;\n        memset(p, 0, sizeof(struct cffi_tls_s));\n        TlsSetValue(cffi_tls_index, p);\n    }\n    return (struct cffi_tls_s *)p;\n}\n\n#ifdef USE__THREAD\n# error \"unexpected USE__THREAD on Windows\"\n#endif\n\nstatic void save_errno(void)\n{\n    int current_err = errno;\n    int current_lasterr = GetLastError();\n    struct cffi_tls_s *p = get_cffi_tls();\n    if (p != NULL) {\n        p->saved_errno = current_err;\n        p->saved_lasterror = current_lasterr;\n    }\n    /* else: cannot report the error */\n}\n\nstatic void restore_errno(void)\n{\n    struct cffi_tls_s *p = get_cffi_tls();\n    if (p != NULL) {\n        SetLastError(p->saved_lasterror);\n        errno = p->saved_errno;\n    }\n    /* else: cannot report the error */\n}\n\n/************************************************************/\n\n\n#if PY_MAJOR_VERSION >= 3\nstatic PyObject *b_getwinerror(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    int err = -1;\n    int len;\n    WCHAR *s_buf = NULL; /* Free via LocalFree */\n    PyObject *v, *message;\n    static char *keywords[] = {\"code\", NULL};\n\n    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"|i\", keywords, &err))\n        return NULL;\n\n    if (err == -1) {\n        struct cffi_tls_s *p = get_cffi_tls();\n        if (p == NULL)\n            return PyErr_NoMemory();\n        err = p->saved_lasterror;\n    }\n\n    len = FormatMessageW(\n        /* Error API error */\n        FORMAT_MESSAGE_ALLOCATE_BUFFER |\n        FORMAT_MESSAGE_FROM_SYSTEM |\n        FORMAT_MESSAGE_IGNORE_INSERTS,\n        NULL,           /* no message source */\n        err,\n        MAKELANGID(LANG_NEUTRAL,\n        SUBLANG_DEFAULT), /* Default language */\n        (LPWSTR) &s_buf,\n        0,              /* size not used */\n        NULL);          /* no args */\n    if (len==0) {\n        /* Only seen this in out of mem situations */\n        message = PyUnicode_FromFormat(\"Windows Error 0x%X\", err);\n    } else {\n        /* remove trailing cr/lf and dots */\n        while (len > 0 && (s_buf[len-1] <= L' ' || s_buf[len-1] == L'.'))\n            s_buf[--len] = L'\\0';\n        message = PyUnicode_FromWideChar(s_buf, len);\n    }\n    if (message != NULL)\n        v = Py_BuildValue(\"(iO)\", err, message);\n    else\n        v = NULL;\n    LocalFree(s_buf);\n    return v;\n}\n#else\nstatic PyObject *b_getwinerror(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    int err = -1;\n    int len;\n    char *s;\n    char *s_buf = NULL; /* Free via LocalFree */\n    char s_small_buf[40]; /* Room for \"Windows Error 0xFFFFFFFFFFFFFFFF\" */\n    PyObject *v;\n    static char *keywords[] = {\"code\", NULL};\n\n    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"|i\", keywords, &err))\n        return NULL;\n\n    if (err == -1) {\n        struct cffi_tls_s *p = get_cffi_tls();\n        if (p == NULL)\n            return PyErr_NoMemory();\n        err = p->saved_lasterror;\n    }\n\n    len = FormatMessage(\n        /* Error API error */\n        FORMAT_MESSAGE_ALLOCATE_BUFFER |\n        FORMAT_MESSAGE_FROM_SYSTEM |\n        FORMAT_MESSAGE_IGNORE_INSERTS,\n        NULL,           /* no message source */\n        err,\n        MAKELANGID(LANG_NEUTRAL,\n        SUBLANG_DEFAULT), /* Default language */\n        (LPTSTR) &s_buf,\n        0,              /* size not used */\n        NULL);          /* no args */\n    if (len==0) {\n        /* Only seen this in out of mem situations */\n        sprintf(s_small_buf, \"Windows Error 0x%X\", err);\n        s = s_small_buf;\n        s_buf = NULL;\n    } else {\n        s = s_buf;\n        /* remove trailing cr/lf and dots */\n        while (len > 0 && (s[len-1] <= ' ' || s[len-1] == '.'))\n            s[--len] = '\\0';\n    }\n    v = Py_BuildValue(\"(is)\", err, s);\n    LocalFree(s_buf);\n    return v;\n}\n#endif\n\n\n/************************************************************/\n/* Emulate dlopen()&co. from the Windows API */\n\n#define RTLD_LAZY   0\n#define RTLD_NOW    0\n#define RTLD_GLOBAL 0\n#define RTLD_LOCAL  0\n\nstatic void *dlopen(const char *filename, int flag)\n{\n    return (void *)LoadLibraryA(filename);\n}\n\nstatic void *dlopenW(const wchar_t *filename)\n{\n    return (void *)LoadLibraryW(filename);\n}\n\nstatic void *dlsym(void *handle, const char *symbol)\n{\n    void *address = GetProcAddress((HMODULE)handle, symbol);\n#ifndef MS_WIN64\n    if (!address) {\n        /* If 'symbol' is not found, then try '_symbol@N' for N in\n           (0, 4, 8, 12, ..., 124).  Unlike ctypes, we try to do that\n           for any symbol, although in theory it should only be done\n           for __stdcall functions.\n        */\n        int i;\n        char *mangled_name = alloca(1 + strlen(symbol) + 1 + 3 + 1);\n        if (!mangled_name)\n            return NULL;\n        for (i = 0; i < 32; i++) {\n            sprintf(mangled_name, \"_%s@%d\", symbol, i * 4);\n            address = GetProcAddress((HMODULE)handle, mangled_name);\n            if (address)\n                break;\n        }\n    }\n#endif\n    return address;\n}\n\nstatic int dlclose(void *handle)\n{\n    return FreeLibrary((HMODULE)handle) ? 0 : -1;\n}\n\nstatic const char *dlerror(void)\n{\n    static char buf[32];\n    DWORD dw = GetLastError(); \n    if (dw == 0)\n        return NULL;\n    sprintf(buf, \"error 0x%x\", (unsigned int)dw);\n    return buf;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.13.0-jlicqgsrlask3n7tsdckxmdwv6d5zp4o/spack-src/cffi.egg-info/SOURCES.txt": "AUTHORS\nLICENSE\nMANIFEST.in\nREADME.md\nsetup.cfg\nsetup.py\nsetup_base.py\nc/_cffi_backend.c\nc/call_python.c\nc/cdlopen.c\nc/cffi1_module.c\nc/cglob.c\nc/commontypes.c\nc/ffi_obj.c\nc/file_emulator.h\nc/lib_obj.c\nc/malloc_closure.h\nc/minibuffer.h\nc/misc_thread_common.h\nc/misc_thread_posix.h\nc/misc_win32.h\nc/parse_c_type.c\nc/realize_c_type.c\nc/test_c.py\nc/wchar_helper.h\nc/wchar_helper_3.h\nc/libffi_msvc/ffi.c\nc/libffi_msvc/ffi.h\nc/libffi_msvc/ffi_common.h\nc/libffi_msvc/fficonfig.h\nc/libffi_msvc/ffitarget.h\nc/libffi_msvc/prep_cif.c\nc/libffi_msvc/types.c\nc/libffi_msvc/win32.c\nc/libffi_msvc/win64.asm\nc/libffi_msvc/win64.obj\ncffi/__init__.py\ncffi/_cffi_errors.h\ncffi/_cffi_include.h\ncffi/_embedding.h\ncffi/api.py\ncffi/backend_ctypes.py\ncffi/cffi_opcode.py\ncffi/commontypes.py\ncffi/cparser.py\ncffi/error.py\ncffi/ffiplatform.py\ncffi/lock.py\ncffi/model.py\ncffi/parse_c_type.h\ncffi/pkgconfig.py\ncffi/recompiler.py\ncffi/setuptools_ext.py\ncffi/vengine_cpy.py\ncffi/vengine_gen.py\ncffi/verifier.py\ncffi.egg-info/PKG-INFO\ncffi.egg-info/SOURCES.txt\ncffi.egg-info/dependency_links.txt\ncffi.egg-info/entry_points.txt\ncffi.egg-info/not-zip-safe\ncffi.egg-info/requires.txt\ncffi.egg-info/top_level.txt\ndemo/_curses.py\ndemo/_curses_build.py\ndemo/_curses_setup.py\ndemo/api.py\ndemo/bsdopendirtype.py\ndemo/bsdopendirtype_build.py\ndemo/bsdopendirtype_setup.py\ndemo/btrfs-snap.py\ndemo/cffi-cocoa.py\ndemo/embedding.py\ndemo/embedding_test.c\ndemo/extern_python.py\ndemo/extern_python_varargs.py\ndemo/fastcsv.py\ndemo/gmp.py\ndemo/gmp_build.py\ndemo/manual.c\ndemo/manual2.py\ndemo/pwuid.py\ndemo/pwuid_build.py\ndemo/py.cleanup\ndemo/pyobj.py\ndemo/readdir.py\ndemo/readdir2.py\ndemo/readdir2_build.py\ndemo/readdir2_setup.py\ndemo/readdir_build.py\ndemo/readdir_ctypes.py\ndemo/readdir_setup.py\ndemo/recopendirtype.py\ndemo/recopendirtype_build.py\ndemo/setup_manual.py\ndemo/winclipboard.py\ndemo/winclipboard_build.py\ndemo/xclient.py\ndemo/xclient_build.py\ndoc/Makefile\ndoc/make.bat\ndoc/misc/design.rst\ndoc/misc/grant-cffi-1.0.rst\ndoc/misc/parse_c_type.rst\ndoc/source/cdef.rst\ndoc/source/conf.py\ndoc/source/embedding.rst\ndoc/source/goals.rst\ndoc/source/index.rst\ndoc/source/installation.rst\ndoc/source/overview.rst\ndoc/source/ref.rst\ndoc/source/using.rst\ndoc/source/whatsnew.rst\ntesting/__init__.py\ntesting/support.py\ntesting/udir.py\ntesting/cffi0/__init__.py\ntesting/cffi0/backend_tests.py\ntesting/cffi0/callback_in_thread.py\ntesting/cffi0/test_cdata.py\ntesting/cffi0/test_ctypes.py\ntesting/cffi0/test_ffi_backend.py\ntesting/cffi0/test_function.py\ntesting/cffi0/test_model.py\ntesting/cffi0/test_ownlib.py\ntesting/cffi0/test_parsing.py\ntesting/cffi0/test_platform.py\ntesting/cffi0/test_unicode_literals.py\ntesting/cffi0/test_verify.py\ntesting/cffi0/test_verify2.py\ntesting/cffi0/test_version.py\ntesting/cffi0/test_vgen.py\ntesting/cffi0/test_vgen2.py\ntesting/cffi0/test_zdistutils.py\ntesting/cffi0/test_zintegration.py\ntesting/cffi0/snippets/distutils_module/setup.py\ntesting/cffi0/snippets/distutils_module/snip_basic_verify.py\ntesting/cffi0/snippets/distutils_package_1/setup.py\ntesting/cffi0/snippets/distutils_package_1/snip_basic_verify1/__init__.py\ntesting/cffi0/snippets/distutils_package_2/setup.py\ntesting/cffi0/snippets/distutils_package_2/snip_basic_verify2/__init__.py\ntesting/cffi0/snippets/infrastructure/setup.py\ntesting/cffi0/snippets/infrastructure/snip_infrastructure/__init__.py\ntesting/cffi0/snippets/setuptools_module/setup.py\ntesting/cffi0/snippets/setuptools_module/snip_setuptools_verify.py\ntesting/cffi0/snippets/setuptools_package_1/setup.py\ntesting/cffi0/snippets/setuptools_package_1/snip_setuptools_verify1/__init__.py\ntesting/cffi0/snippets/setuptools_package_2/setup.py\ntesting/cffi0/snippets/setuptools_package_2/snip_setuptools_verify2/__init__.py\ntesting/cffi1/__init__.py\ntesting/cffi1/test_cffi_binary.py\ntesting/cffi1/test_commontypes.py\ntesting/cffi1/test_dlopen.py\ntesting/cffi1/test_dlopen_unicode_literals.py\ntesting/cffi1/test_ffi_obj.py\ntesting/cffi1/test_new_ffi_1.py\ntesting/cffi1/test_parse_c_type.py\ntesting/cffi1/test_pkgconfig.py\ntesting/cffi1/test_re_python.py\ntesting/cffi1/test_realize_c_type.py\ntesting/cffi1/test_recompiler.py\ntesting/cffi1/test_unicode_literals.py\ntesting/cffi1/test_verify1.py\ntesting/cffi1/test_zdist.py\ntesting/embedding/__init__.py\ntesting/embedding/add1-test.c\ntesting/embedding/add1.py\ntesting/embedding/add2-test.c\ntesting/embedding/add2.py\ntesting/embedding/add3.py\ntesting/embedding/add_recursive-test.c\ntesting/embedding/add_recursive.py\ntesting/embedding/empty.py\ntesting/embedding/initerror.py\ntesting/embedding/perf-test.c\ntesting/embedding/perf.py\ntesting/embedding/test_basic.py\ntesting/embedding/test_performance.py\ntesting/embedding/test_recursive.py\ntesting/embedding/test_thread.py\ntesting/embedding/test_tlocal.py\ntesting/embedding/thread-test.h\ntesting/embedding/thread1-test.c\ntesting/embedding/thread2-test.c\ntesting/embedding/thread3-test.c\ntesting/embedding/tlocal-test.c\ntesting/embedding/tlocal.py",
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.13.0-jlicqgsrlask3n7tsdckxmdwv6d5zp4o/spack-src/doc/source/ref.rst": "================================\nCFFI Reference\n================================\n\n.. contents::\n\n\nFFI Interface\n-------------\n\n*This page documents the runtime interface of the two types \"FFI\" and\n\"CompiledFFI\".  These two types are very similar to each other.  You get\na CompiledFFI object if you import an out-of-line module.  You get a FFI\nobject from explicitly writing cffi.FFI().  Unlike CompiledFFI, the type\nFFI has also got additional methods documented on the* `next page`__.\n\n.. __: cdef.html\n\n\nffi.NULL\n++++++++\n\n**ffi.NULL**: a constant NULL of type ``<cdata 'void *'>``.\n\n\nffi.error\n+++++++++\n\n**ffi.error**: the Python exception raised in various cases.  (Don't\nconfuse it with ``ffi.errno``.)\n\n\nffi.new()\n+++++++++\n\n**ffi.new(cdecl, init=None)**:\nallocate an instance according to the specified C type and return a\npointer to it.  The specified C type must be either a pointer or an\narray: ``new('X *')`` allocates an X and returns a pointer to it,\nwhereas ``new('X[n]')`` allocates an array of n X'es and returns an\narray referencing it (which works mostly like a pointer, like in C).\nYou can also use ``new('X[]', n)`` to allocate an array of a\nnon-constant length n.  See the `detailed documentation`__ for other\nvalid initializers.\n\n.. __: using.html#working\n\nWhen the returned ``<cdata>`` object goes out of scope, the memory is\nfreed.  In other words the returned ``<cdata>`` object has ownership of\nthe value of type ``cdecl`` that it points to.  This means that the raw\ndata can be used as long as this object is kept alive, but must not be\nused for a longer time.  Be careful about that when copying the\npointer to the memory somewhere else, e.g. into another structure.\nAlso, this means that a line like ``x = ffi.cast(\"B *\", ffi.new(\"A *\"))``\nor ``x = ffi.new(\"struct s[1]\")[0]`` is wrong: the newly allocated object\ngoes out of scope instantly, and so is freed immediately, and ``x`` is\ngarbage.  The only case where this is fine comes from a special case for\npointers-to-struct and pointers-to-union types: after\n``p = ffi.new(\"struct-or-union *\", ..)``, then either ``p`` or ``p[0]``\nkeeps the memory alive.\n\nThe returned memory is initially cleared (filled with zeroes), before\nthe optional initializer is applied.  For performance, see\n`ffi.new_allocator()`_ for a way to allocate non-zero-initialized\nmemory.\n\n*New in version 1.12:* see also ``ffi.release()``.\n\n\nffi.cast()\n++++++++++\n\n**ffi.cast(\"C type\", value)**: similar to a C cast: returns an\ninstance of the named C type initialized with the given value.  The\nvalue is casted between integers or pointers of any type.\n\n\n.. _ffi-errno:\n.. _ffi-getwinerror:\n\nffi.errno, ffi.getwinerror()\n++++++++++++++++++++++++++++\n\n**ffi.errno**: the value of ``errno`` received from the most recent C call\nin this thread, and passed to the following C call.  (This is a thread-local\nread-write property.)\n\n**ffi.getwinerror(code=-1)**: on Windows, in addition to ``errno`` we\nalso save and restore the ``GetLastError()`` value across function\ncalls.  This function returns this error code as a tuple ``(code,\nmessage)``, adding a readable message like Python does when raising\nWindowsError.  If the argument ``code`` is given, format that code into\na message instead of using ``GetLastError()``.\n(Note that it is also possible to declare and call the ``GetLastError()``\nfunction as usual.)\n\n\n.. _ffi-string:\n.. _ffi-unpack:\n\nffi.string(), ffi.unpack()\n++++++++++++++++++++++++++\n\n**ffi.string(cdata, [maxlen])**: return a Python string (or unicode\nstring) from the 'cdata'.\n\n- If 'cdata' is a pointer or array of characters or bytes, returns the\n  null-terminated string.  The returned string extends until the first\n  null character.  The 'maxlen' argument limits how far we look for a\n  null character.  If 'cdata' is an\n  array then 'maxlen' defaults to its length.  See ``ffi.unpack()`` below\n  for a way to continue past the first null character.  *Python 3:* this\n  returns a ``bytes``, not a ``str``.\n\n- If 'cdata' is a pointer or array of wchar_t, returns a unicode string\n  following the same rules.  *New in version 1.11:* can also be\n  char16_t or char32_t.\n\n- If 'cdata' is a single character or byte or a wchar_t or charN_t,\n  returns it as a byte string or unicode string.  (Note that in some\n  situation a single wchar_t or char32_t may require a Python unicode\n  string of length 2.)\n\n- If 'cdata' is an enum, returns the value of the enumerator as a string.\n  If the value is out of range, it is simply returned as the stringified\n  integer.\n\n**ffi.unpack(cdata, length)**: unpacks an array of C data of the given\nlength, returning a Python string/unicode/list.  The 'cdata' should be\na pointer; if it is an array it is first converted to the pointer\ntype.  *New in version 1.6.*\n\n- If 'cdata' is a pointer to 'char', returns a byte string.  It does\n  not stop at the first null.  (An equivalent way to do that is\n  ``ffi.buffer(cdata, length)[:]``.)\n\n- If 'cdata' is a pointer to 'wchar_t', returns a unicode string.\n  ('length' is measured in number of wchar_t; it is not the size in\n  bytes.)  *New in version 1.11:* can also be char16_t or char32_t.\n\n- If 'cdata' is a pointer to anything else, returns a list, of the\n  given 'length'.  (A slower way to do that is ``[cdata[i] for i in\n  range(length)]``.)\n\n\n.. _ffi-buffer:\n.. _ffi-from-buffer:\n\nffi.buffer(), ffi.from_buffer()\n+++++++++++++++++++++++++++++++\n\n**ffi.buffer(cdata, [size])**: return a buffer object that references\nthe raw C data pointed to by the given 'cdata', of 'size' bytes.  What\nPython calls \"a buffer\", or more precisely \"an object supporting the\nbuffer interface\", is an object that represents some raw memory and\nthat can be passed around to various built-in or extension functions;\nthese built-in functions read from or write to the raw memory directly,\nwithout needing an extra copy.\n\nThe 'cdata' argument\nmust be a pointer or an array.  If unspecified, the size of the\nbuffer is either the size of what ``cdata`` points to, or the whole size\nof the array.\n\nHere are a few examples of where buffer() would be useful:\n\n-  use ``file.write()`` and ``file.readinto()`` with\n   such a buffer (for files opened in binary mode)\n\n-  overwrite the content of a struct: if ``p`` is a cdata pointing to\n   it, use ``ffi.buffer(p)[:] = newcontent``, where ``newcontent`` is\n   a bytes object (``str`` in Python 2).\n\nRemember that like in C, you can use ``array + index`` to get the pointer\nto the index'th item of an array.  (In C you might more naturally write\n``&array[index]``, but that is equivalent.)\n\nThe returned object's type is not the builtin ``buffer`` nor ``memoryview``\ntypes, because these types' API changes too much across Python versions.\nInstead it has the following Python API (a subset of Python 2's ``buffer``)\nin addition to supporting the buffer interface:\n\n- ``buf[:]`` or ``bytes(buf)``: copy data out of the buffer, returning a\n  regular byte string (or ``buf[start:end]`` for a part)\n\n- ``buf[:] = newstr``: copy data into the buffer (or ``buf[start:end]\n  = newstr``)\n\n- ``len(buf)``, ``buf[index]``, ``buf[index] = newchar``: access as a sequence\n  of characters.\n\nThe buffer object returned by ``ffi.buffer(cdata)`` keeps alive the\n``cdata`` object: if it was originally an owning cdata, then its\nowned memory will not be freed as long as the buffer is alive.\n\nPython 2/3 compatibility note: you should avoid using ``str(buf)``,\nbecause it gives inconsistent results between Python 2 and Python 3.\n(This is similar to how ``str()`` gives inconsistent results on regular\nbyte strings).  Use ``buf[:]`` instead.\n\n*New in version 1.10:* ``ffi.buffer`` is now the type of the returned\nbuffer objects; ``ffi.buffer()`` actually calls the constructor.\n\n**ffi.from_buffer([cdecl,] python_buffer, require_writable=False)**:\nreturn an array cdata (by default a ``<cdata 'char[]'>``) that\npoints to the data of the given Python object, which must support the\nbuffer interface.  Note that ``ffi.from_buffer()`` turns a generic\nPython buffer object into a cdata object, whereas ``ffi.buffer()`` does\nthe opposite conversion.  Both calls don't actually copy any data.\n\n``ffi.from_buffer()`` is meant to be used on objects\ncontaining large quantities of raw data, like bytearrays\nor ``array.array`` or numpy\narrays.  It supports both the old *buffer* API (in Python 2.x) and the\nnew *memoryview* API.  Note that if you pass a read-only buffer object,\nyou still get a regular ``<cdata 'char[]'>``; it is your responsibility\nnot to write there if the original buffer doesn't expect you to.\n*In particular, never modify byte strings!*\n\nThe original object is kept alive (and, in case\nof memoryview, locked) as long as the cdata object returned by\n``ffi.from_buffer()`` is alive.\n\nA common use case is calling a C function with some ``char *`` that\npoints to the internal buffer of a Python object; for this case you\ncan directly pass ``ffi.from_buffer(python_buffer)`` as argument to\nthe call.\n\n*New in version 1.10:* the ``python_buffer`` can be anything supporting\nthe buffer/memoryview interface (except unicode strings).  Previously,\nbytearray objects were supported in version 1.7 onwards (careful, if you\nresize the bytearray, the ``<cdata>`` object will point to freed\nmemory); and byte strings were supported in version 1.8 onwards.\n\n*New in version 1.12:* added the optional *first* argument ``cdecl``, and\nthe keyword argument ``require_writable``:\n\n* ``cdecl`` defaults to ``\"char[]\"``, but a different array\n  or (from version 1.13) pointer type can be\n  specified for the result.  A value like ``\"int[]\"`` will return an array of\n  ints instead of chars, and its length will be set to the number of ints\n  that fit in the buffer (rounded down if the division is not exact).  Values\n  like ``\"int[42]\"`` or ``\"int[2][3]\"`` will return an array of exactly 42\n  (resp. 2-by-3) ints, raising a ValueError if the buffer is too small.  The\n  difference between specifying ``\"int[]\"`` and using the older code ``p1 =\n  ffi.from_buffer(x); p2 = ffi.cast(\"int *\", p1)`` is that the older code\n  needs to keep ``p1`` alive as long as ``p2`` is in use, because only ``p1``\n  keeps the underlying Python object alive and locked.  (In addition,\n  ``ffi.from_buffer(\"int[]\", x)`` gives better array bound checking.)\n\n  *New in version 1.13:* ``cdecl`` can be a pointer type.  If it points\n  to a struct or union, you can, as usual, write ``p.field`` instead of\n  ``p[0].field``.  You can also access ``p[n]``; note that CFFI does not\n  perform any bounds checking in this case.  Note also that ``p[0]`` cannot\n  be used to keep the buffer alive (unlike what occurs with ``ffi.new()``).\n\n* if ``require_writable`` is set to True, the function fails if the buffer\n  obtained from ``python_buffer`` is read-only (e.g. if ``python_buffer`` is\n  a byte string).  The exact exception is raised by the object itself, and\n  for things like bytes it varies with the Python version, so don't rely on\n  it.  (Before version 1.12, the same effect can be achieved with a hack:\n  call ``ffi.memmove(python_buffer, b\"\", 0)``.  This has no effect if the\n  object is writable, but fails if it is read-only.)  Please keep in mind\n  that CFFI does not implement the C keyword ``const``: even if you set\n  ``require_writable`` to False explicitly, you still get a regular\n  read-write cdata pointer.\n\n*New in version 1.12:* see also ``ffi.release()``.\n\n\nffi.memmove()\n+++++++++++++\n\n**ffi.memmove(dest, src, n)**: copy ``n`` bytes from memory area\n``src`` to memory area ``dest``.  See examples below.  Inspired by the\nC functions ``memcpy()`` and ``memmove()``---like the latter, the\nareas can overlap.  Each of ``dest`` and ``src`` can be either a cdata\npointer or a Python object supporting the buffer/memoryview interface.\nIn the case of ``dest``, the buffer/memoryview must be writable.\n*New in version 1.3.*  Examples:\n\n* ``ffi.memmove(myptr, b\"hello\", 5)`` copies the 5 bytes of\n  ``b\"hello\"`` to the area that ``myptr`` points to.\n\n* ``ba = bytearray(100); ffi.memmove(ba, myptr, 100)`` copies 100\n  bytes from ``myptr`` into the bytearray ``ba``.\n\n* ``ffi.memmove(myptr + 1, myptr, 100)`` shifts 100 bytes from\n  the memory at ``myptr`` to the memory at ``myptr + 1``.\n\nIn versions before 1.10, ``ffi.from_buffer()`` had restrictions on the\ntype of buffer, which made ``ffi.memmove()`` more general.\n\n.. _ffi-typeof:\n.. _ffi-sizeof:\n.. _ffi-alignof:\n\nffi.typeof(), ffi.sizeof(), ffi.alignof()\n+++++++++++++++++++++++++++++++++++++++++\n\n**ffi.typeof(\"C type\" or cdata object)**: return an object of type\n``<ctype>`` corresponding to the parsed string, or to the C type of the\ncdata instance.  Usually you don't need to call this function or to\nexplicitly manipulate ``<ctype>`` objects in your code: any place that\naccepts a C type can receive either a string or a pre-parsed ``ctype``\nobject (and because of caching of the string, there is no real\nperformance difference).  It can still be useful in writing typechecks,\ne.g.:\n\n.. code-block:: python\n  \n    def myfunction(ptr):\n        assert ffi.typeof(ptr) is ffi.typeof(\"foo_t*\")\n        ...\n\nNote also that the mapping from strings like ``\"foo_t*\"`` to the\n``<ctype>`` objects is stored in some internal dictionary.  This\nguarantees that there is only one ``<ctype 'foo_t *'>`` object, so you\ncan use the ``is`` operator to compare it.  The downside is that the\ndictionary entries are immortal for now.  In the future, we may add\ntransparent reclamation of old, unused entries.  In the meantime, note\nthat using strings like ``\"int[%d]\" % length`` to name a type will\ncreate many immortal cached entries if called with many different\nlengths.\n\n**ffi.sizeof(\"C type\" or cdata object)**: return the size of the\nargument in bytes.  The argument can be either a C type, or a cdata object,\nlike in the equivalent ``sizeof`` operator in C.\n\nFor ``array = ffi.new(\"T[]\", n)``, then ``ffi.sizeof(array)`` returns\n``n * ffi.sizeof(\"T\")``.  *New in version 1.9:* Similar rules apply for\nstructures with a variable-sized array at the end.  More precisely, if\n``p`` was returned by ``ffi.new(\"struct foo *\", ...)``, then\n``ffi.sizeof(p[0])`` now returns the total allocated size.  In previous\nversions, it used to just return ``ffi.sizeof(ffi.typeof(p[0]))``, which\nis the size of the structure ignoring the variable-sized part.  (Note\nthat due to alignment, it is possible for ``ffi.sizeof(p[0])`` to return\na value smaller than ``ffi.sizeof(ffi.typeof(p[0]))``.)\n\n**ffi.alignof(\"C type\")**: return the natural alignment size in bytes of\nthe argument.  Corresponds to the ``__alignof__`` operator in GCC.\n\n\n.. _ffi-offsetof:\n.. _ffi-addressof:\n\nffi.offsetof(), ffi.addressof()\n+++++++++++++++++++++++++++++++\n\n**ffi.offsetof(\"C struct or array type\", \\*fields_or_indexes)**: return the\noffset within the struct of the given field.  Corresponds to ``offsetof()``\nin C.\n\nYou can give several field names in case of nested structures.  You\ncan also give numeric values which correspond to array items, in case\nof a pointer or array type.  For example, ``ffi.offsetof(\"int[5]\", 2)``\nis equal to the size of two integers, as is ``ffi.offsetof(\"int *\", 2)``.\n\n\n**ffi.addressof(cdata, \\*fields_or_indexes)**: limited equivalent to\nthe '&' operator in C:\n\n1. ``ffi.addressof(<cdata 'struct-or-union'>)`` returns a cdata that\nis a pointer to this struct or union.  The returned pointer is only\nvalid as long as the original ``cdata`` object is; be sure to keep it\nalive if it was obtained directly from ``ffi.new()``.\n\n2. ``ffi.addressof(<cdata>, field-or-index...)`` returns the address\nof a field or array item inside the given structure or array.  In case\nof nested structures or arrays, you can give more than one field or\nindex to look recursively.  Note that ``ffi.addressof(array, index)``\ncan also be expressed as ``array + index``: this is true both in CFFI\nand in C, where ``&array[index]`` is just ``array + index``.\n\n3. ``ffi.addressof(<library>, \"name\")`` returns the address of the\nnamed function or global variable from the given library object.\nFor functions, it returns a regular cdata\nobject containing a pointer to the function.\n\nNote that the case 1. cannot be used to take the address of a\nprimitive or pointer, but only a struct or union.  It would be\ndifficult to implement because only structs and unions are internally\nstored as an indirect pointer to the data.  If you need a C int whose\naddress can be taken, use ``ffi.new(\"int[1]\")`` in the first place;\nsimilarly, for a pointer, use ``ffi.new(\"foo_t *[1]\")``.\n\n\n.. _ffi-cdata:\n.. _ffi-ctype:\n\nffi.CData, ffi.CType\n++++++++++++++++++++\n\n**ffi.CData, ffi.CType**: the Python type of the objects referred to\nas ``<cdata>`` and ``<ctype>`` in the rest of this document.  Note\nthat some cdata objects may be actually of a subclass of\n``ffi.CData``, and similarly with ctype, so you should check with\n``if isinstance(x, ffi.CData)``.  Also, ``<ctype>`` objects have\na number of attributes for introspection: ``kind`` and ``cname`` are\nalways present, and depending on the kind they may also have\n``item``, ``length``, ``fields``, ``args``, ``result``, ``ellipsis``,\n``abi``, ``elements`` and ``relements``.\n\n*New in version 1.10:* ``ffi.buffer`` is now `a type`__ as well.\n\n.. __: #ffi-buffer\n\n\n.. _ffi-gc:\n\nffi.gc()\n++++++++\n\n**ffi.gc(cdata, destructor, size=0)**:\nreturn a new cdata object that points to the\nsame data.  Later, when this new cdata object is garbage-collected,\n``destructor(old_cdata_object)`` will be called.  Example of usage:\n``ptr = ffi.gc(lib.custom_malloc(42), lib.custom_free)``.\nNote that like objects\nreturned by ``ffi.new()``, the returned pointer objects have *ownership*,\nwhich means the destructor is called as soon as *this* exact returned\nobject is garbage-collected.\n\n*New in version 1.12:* see also ``ffi.release()``.\n\n**ffi.gc(ptr, None, size=0)**:\nremoves the ownership on a object returned by a\nregular call to ``ffi.gc``, and no destructor will be called when it\nis garbage-collected.  The object is modified in-place, and the\nfunction returns ``None``.  *New in version 1.7: ffi.gc(ptr, None)*\n\nNote that ``ffi.gc()`` should be avoided for limited resources, or (with\ncffi below 1.11) for large memory allocations.  This is particularly\ntrue on PyPy: its GC does not know how much memory or how many resources\nthe returned ``ptr`` holds.  It will only run its GC when enough memory\nit knows about has been allocated (and thus run the destructor possibly\nlater than you would expect).  Moreover, the destructor is called in\nwhatever thread PyPy is at that moment, which might be a problem for\nsome C libraries.  In these cases, consider writing a wrapper class with\ncustom ``__enter__()`` and ``__exit__()`` methods, allocating and\nfreeing the C data at known points in time, and using it in a ``with``\nstatement.  In cffi 1.12, see also ``ffi.release()``.\n\n*New in version 1.11:* the ``size`` argument.  If given, this should be\nan estimate of the size (in bytes) that ``ptr`` keeps alive.  This\ninformation is passed on to the garbage collector, fixing part of the\nproblem described above.  The ``size`` argument is most important on\nPyPy; on CPython, it is ignored so far, but in the future it could be\nused to trigger more eagerly the cyclic reference GC, too (see CPython\n`issue 31105`__).\n\nThe form ``ffi.gc(ptr, None, size=0)`` can be called with a negative\n``size``, to cancel the estimate.  It is not mandatory, though:\nnothing gets out of sync if the size estimates do not match.  It only\nmakes the next GC start more or less early.\n\nNote that if you have several ``ffi.gc()`` objects, the corresponding\ndestructors will be called in a random order.  If you need a particular\norder, see the discussion in `issue 340`__.\n\n.. __: http://bugs.python.org/issue31105\n.. __: https://bitbucket.org/cffi/cffi/issues/340/resources-release-issues\n\n\n.. _ffi-new-handle:\n.. _ffi-from-handle:\n\nffi.new_handle(), ffi.from_handle()\n+++++++++++++++++++++++++++++++++++\n\n**ffi.new_handle(python_object)**: return a non-NULL cdata of type\n``void *`` that contains an opaque reference to ``python_object``.  You\ncan pass it around to C functions or store it into C structures.  Later,\nyou can use **ffi.from_handle(p)** to retrieve the original\n``python_object`` from a value with the same ``void *`` pointer.\n*Calling ffi.from_handle(p) is invalid and will likely crash if\nthe cdata object returned by new_handle() is not kept alive!*\n\nSee a `typical usage example`_ below.\n\n(In case you are wondering, this ``void *`` is not the ``PyObject *``\npointer.  This wouldn't make sense on PyPy anyway.)\n\nThe ``ffi.new_handle()/from_handle()`` functions *conceptually* work\nlike this:\n\n* ``new_handle()`` returns cdata objects that contains references to\n  the Python objects; we call them collectively the \"handle\" cdata\n  objects.  The ``void *`` value in these handle cdata objects are\n  random but unique.\n\n* ``from_handle(p)`` searches all live \"handle\" cdata objects for the\n  one that has the same value ``p`` as its ``void *`` value.  It then\n  returns the Python object referenced by that handle cdata object.\n  If none is found, you get \"undefined behavior\" (i.e. crashes).\n\nThe \"handle\" cdata object keeps the Python object alive, similar to\nhow ``ffi.new()`` returns a cdata object that keeps a piece of memory\nalive.  If the handle cdata object *itself* is not alive any more,\nthen the association ``void * -> python_object`` is dead and\n``from_handle()`` will crash.\n\n*New in version 1.4:* two calls to ``new_handle(x)`` are guaranteed to\nreturn cdata objects with different ``void *`` values, even with the\nsame ``x``.  This is a useful feature that avoids issues with unexpected\nduplicates in the following trick: if you need to keep alive the\n\"handle\" until explicitly asked to free it, but don't have a natural\nPython-side place to attach it to, then the easiest is to ``add()`` it\nto a global set.  It can later be removed from the set by\n``global_set.discard(p)``, with ``p`` any cdata object whose ``void *``\nvalue compares equal.\n\n.. _`typical usage example`:\n\nUsage example: suppose you have a C library where you must call a\n``lib.process_document()`` function which invokes some callback.  The\n``process_document()`` function receives a pointer to a callback and a\n``void *`` argument.  The callback is then invoked with the ``void\n*data`` argument that is equal to the provided value.  In this typical\ncase, you can implement it like this (out-of-line API mode)::\n\n    class MyDocument:\n        ...\n\n        def process(self):\n            h = ffi.new_handle(self)\n            lib.process_document(lib.my_callback,   # the callback\n                                 h,                 # 'void *data'\n                                 args...)\n            # 'h' stays alive until here, which means that the\n            # ffi.from_handle() done in my_callback() during\n            # the call to process_document() is safe\n\n        def callback(self, arg1, arg2):\n            ...\n\n    # the actual callback is this one-liner global function:\n    @ffi.def_extern()\n    def my_callback(arg1, arg2, data):\n        return ffi.from_handle(data).callback(arg1, arg2)\n\n\n.. _ffi-dlopen:\n.. _ffi-dlclose:\n\nffi.dlopen(), ffi.dlclose()\n+++++++++++++++++++++++++++\n\n**ffi.dlopen(libpath, [flags])**: opens and returns a \"handle\" to a\ndynamic library, as a ``<lib>`` object.  See `Preparing and\nDistributing modules`_.\n\n**ffi.dlclose(lib)**: explicitly closes a ``<lib>`` object returned\nby ``ffi.dlopen()``.\n\n**ffi.RLTD_...**: constants: flags for ``ffi.dlopen()``.\n\n\nffi.new_allocator()\n+++++++++++++++++++\n\n**ffi.new_allocator(alloc=None, free=None, should_clear_after_alloc=True)**:\nreturns a new allocator.  An \"allocator\" is a callable that behaves like\n``ffi.new()`` but uses the provided low-level ``alloc`` and ``free``\nfunctions.  *New in version 1.2.*\n\n``alloc()`` is invoked with the size as sole argument.  If it returns\nNULL, a MemoryError is raised.  Later, if ``free`` is not None, it will\nbe called with the result of ``alloc()`` as argument.  Both can be either\nPython function or directly C functions.  If only ``free`` is None, then no\nfree function is called.  If both ``alloc`` and ``free`` are None, the\ndefault alloc/free combination is used.  (In other words, the call\n``ffi.new(*args)`` is equivalent to ``ffi.new_allocator()(*args)``.)\n\nIf ``should_clear_after_alloc`` is set to False, then the memory\nreturned by ``alloc()`` is assumed to be already cleared (or you are\nfine with garbage); otherwise CFFI will clear it.  Example: for\nperformance, if you are using ``ffi.new()`` to allocate large chunks of\nmemory where the initial content can be left uninitialized, you can do::\n\n    # at module level\n    new_nonzero = ffi.new_allocator(should_clear_after_alloc=False)\n\n    # then replace `p = ffi.new(\"char[]\", bigsize)` with:\n        p = new_nonzero(\"char[]\", bigsize)\n\n**NOTE:** the following is a general warning that applies particularly\n(but not only) to PyPy versions 5.6 or older (PyPy > 5.6 attempts to\naccount for the memory returned by ``ffi.new()`` or a custom allocator;\nand CPython uses reference counting).  If you do large allocations, then\nthere is no hard guarantee about when the memory will be freed.  You\nshould avoid both ``new()`` and ``new_allocator()()`` if you want to be\nsure that the memory is promptly released, e.g. before you allocate more\nof it.\n\nAn alternative is to declare and call the C ``malloc()`` and ``free()``\nfunctions, or some variant like ``mmap()`` and ``munmap()``.  Then you\ncontrol exactly when the memory is allocated and freed.  For example,\nadd these two lines to your existing ``ffibuilder.cdef()``::\n\n    void *malloc(size_t size);\n    void free(void *ptr);\n\nand then call these two functions manually::\n\n    p = lib.malloc(n * ffi.sizeof(\"int\"))\n    try:\n        my_array = ffi.cast(\"int *\", p)\n        ...\n    finally:\n        lib.free(p)\n\nIn cffi version 1.12 you can indeed use ``ffi.new_allocator()`` but use the\n``with`` statement (see ``ffi.release()``) to force the free function to be\ncalled at a known point.  The above is equivalent to this code::\n\n    my_new = ffi.new_allocator(lib.malloc, lib.free)  # at global level\n    ...\n    with my_new(\"int[]\", n) as my_array:\n        ...\n\n**Warning:** due to a bug, ``p = ffi.new_allocator(..)(\"struct-or-union *\")``\nmight not follow the rule that either ``p`` or ``p[0]`` keeps the memory\nalive, which holds for the normal ``ffi.new(\"struct-or-union *\")`` allocator.\nIt may sometimes be the case that if there is only a reference to ``p[0]``,\nthe memory is freed.  The cause is that the rule doesn't hold for\n``ffi.gc()``, which is sometimes used in the implementation of\n``ffi.new_allocator()()``; this might be fixed in a future release.\n\n\n.. _ffi-release:\n\nffi.release() and the context manager\n+++++++++++++++++++++++++++++++++++++\n\n**ffi.release(cdata)**: release the resources held by a cdata object from\n``ffi.new()``, ``ffi.gc()``, ``ffi.from_buffer()`` or\n``ffi.new_allocator()()``.  The cdata object must not be used afterwards.\nThe normal Python destructor of the cdata object releases the same resources,\nbut this allows the releasing to occur at a known time, as opposed as at an\nunspecified point in the future.\n*New in version 1.12.*\n\n``ffi.release(cdata)`` is equivalent to ``cdata.__exit__()``, which means that\nyou can use the ``with`` statement to ensure that the cdata is released at the\nend of a block (in version 1.12 and above)::\n\n    with ffi.from_buffer(...) as p:\n        do something with p\n\nThe effect is more precisely as follows:\n\n* on an object returned from ``ffi.gc(destructor)``, ``ffi.release()`` will\n  cause the ``destructor`` to be called immediately.\n\n* on an object returned from a custom allocator, the custom free function\n  is called immediately.\n\n* on CPython, ``ffi.from_buffer(buf)`` locks the buffer, so ``ffi.release()``\n  can be used to unlock it at a known time.  On PyPy, there is no locking\n  (so far); the effect of ``ffi.release()`` is limited to removing the link,\n  allowing the original buffer object to be garbage-collected even if the\n  cdata object stays alive.\n\n* on CPython this method has no effect (so far) on objects returned by\n  ``ffi.new()``, because the memory is allocated inline with the cdata object\n  and cannot be freed independently.  It might be fixed in future releases of\n  cffi.\n\n* on PyPy, ``ffi.release()`` frees the ``ffi.new()`` memory immediately.  It is\n  useful because otherwise the memory is kept alive until the next GC occurs.\n  If you allocate large amounts of memory with ``ffi.new()`` and don't free\n  them with ``ffi.release()``, PyPy (>= 5.7) runs its GC more often to\n  compensate, so the total memory allocated should be kept within bounds\n  anyway; but calling ``ffi.release()`` explicitly should improve performance\n  by reducing the frequency of GC runs.\n\nAfter ``ffi.release(x)``, do not use anything pointed to by ``x`` any longer.\nAs an exception to this rule, you can call ``ffi.release(x)`` several times\nfor the exact same cdata object ``x``; the calls after the first one are\nignored.\n\n\nffi.init_once()\n+++++++++++++++\n\n**ffi.init_once(function, tag)**: run ``function()`` once.  The\n``tag`` should be a primitive object, like a string, that identifies\nthe function: ``function()`` is only called the first time we see the\n``tag``.  The return value of ``function()`` is remembered and\nreturned by the current and all future ``init_once()`` with the same\ntag.  If ``init_once()`` is called from multiple threads in parallel,\nall calls block until the execution of ``function()`` is done.  If\n``function()`` raises an exception, it is propagated and nothing is\ncached (i.e. ``function()`` will be called again, in case we catch the\nexception and try ``init_once()`` again).  *New in version 1.4.*\n\nExample::\n\n    from _xyz_cffi import ffi, lib\n\n    def initlib():\n        lib.init_my_library()\n\n    def make_new_foo():\n        ffi.init_once(initlib, \"init\")\n        return lib.make_foo()\n\n``init_once()`` is optimized to run very quickly if ``function()`` has\nalready been called.  (On PyPy, the cost is zero---the JIT usually\nremoves everything in the machine code it produces.)\n\n*Note:* one motivation__ for ``init_once()`` is the CPython notion of\n\"subinterpreters\" in the embedded case.  If you are using the\nout-of-line API mode, ``function()`` is called only once even in the\npresence of multiple subinterpreters, and its return value is shared\namong all subinterpreters.  The goal is to mimic the way traditional\nCPython C extension modules have their init code executed only once in\ntotal even if there are subinterpreters.  In the example above, the C\nfunction ``init_my_library()`` is called once in total, not once per\nsubinterpreter.  For this reason, avoid Python-level side-effects in\n``function()`` (as they will only be applied in the first\nsubinterpreter to run); instead, return a value, as in the following\nexample::\n\n   def init_get_max():\n       return lib.initialize_once_and_get_some_maximum_number()\n\n   def process(i):\n       if i > ffi.init_once(init_get_max, \"max\"):\n           raise IndexError(\"index too large!\")\n       ...\n\n.. __: https://bitbucket.org/cffi/cffi/issues/233/\n\n\n.. _ffi-getctype:\n.. _ffi-list-types:\n\nffi.getctype(), ffi.list_types()\n++++++++++++++++++++++++++++++++\n\n**ffi.getctype(\"C type\" or <ctype>, extra=\"\")**: return the string\nrepresentation of the given C type.  If non-empty, the \"extra\" string is\nappended (or inserted at the right place in more complicated cases); it\ncan be the name of a variable to declare, or an extra part of the type\nlike ``\"*\"`` or ``\"[5]\"``.  For example\n``ffi.getctype(ffi.typeof(x), \"*\")`` returns the string representation\nof the C type \"pointer to the same type than x\"; and\n``ffi.getctype(\"char[80]\", \"a\") == \"char a[80]\"``.\n\n**ffi.list_types()**: Returns the user type names known to this FFI\ninstance.  This returns a tuple containing three lists of names:\n``(typedef_names, names_of_structs, names_of_unions)``.  *New in\nversion 1.6.*\n\n\n.. _`Preparing and Distributing modules`: cdef.html#loading-libraries\n\n\nConversions\n-----------\n\nThis section documents all the conversions that are allowed when\n*writing into* a C data structure (or passing arguments to a function\ncall), and *reading from* a C data structure (or getting the result of a\nfunction call).  The last column gives the type-specific operations\nallowed.\n\n+---------------+------------------------+------------------+----------------+\n|    C type     |   writing into         | reading from     |other operations|\n+===============+========================+==================+================+\n|   integers    | an integer or anything | a Python int or  | int(), bool()  |\n|   and enums   | on which int() works   | long, depending  | `[6]`,         |\n|   `[5]`       | (but not a float!).    | on the type      | ``<``          |\n|               | Must be within range.  | (ver. 1.10: or a |                |\n|               |                        | bool)            |                |\n+---------------+------------------------+------------------+----------------+\n|   ``char``    | a string of length 1   | a string of      | int(), bool(), |\n|               | or another <cdata char>| length 1         | ``<``          |\n+---------------+------------------------+------------------+----------------+\n| ``wchar_t``,  | a unicode of length 1  | a unicode of     |                |\n| ``char16_t``, | (or maybe 2 if         | length 1         | int(),         |\n| ``char32_t``  | surrogates) or         | (or maybe 2 if   | bool(), ``<``  |\n| `[8]`         | another similar <cdata>| surrogates)      |                |\n+---------------+------------------------+------------------+----------------+\n|  ``float``,   | a float or anything on | a Python float   | float(), int(),|\n|  ``double``   | which float() works    |                  | bool(), ``<``  |\n+---------------+------------------------+------------------+----------------+\n|``long double``| another <cdata> with   | a <cdata>, to    | float(), int(),|\n|               | a ``long double``, or  | avoid loosing    | bool()         |\n|               | anything on which      | precision `[3]`  |                |\n|               | float() works          |                  |                |\n+---------------+------------------------+------------------+----------------+\n| ``float``     | a complex number       | a Python complex | complex(),     |\n| ``_Complex``, | or anything on which   | number           | bool()         |\n| ``double``    | complex() works        |                  | `[7]`          |\n| ``_Complex``  |                        |                  |                |\n+---------------+------------------------+------------------+----------------+\n|  pointers     | another <cdata> with   | a <cdata>        |``[]`` `[4]`,   |\n|               | a compatible type (i.e.|                  |``+``, ``-``,   |\n|               | same type              |                  |bool()          |\n|               | or ``void*``, or as an |                  |                |\n|               | array instead) `[1]`   |                  |                |\n+---------------+------------------------+                  |                |\n|  ``void *``   | another <cdata> with   |                  |                |\n|               | any pointer or array   |                  |                |\n|               | type                   |                  |                |\n+---------------+------------------------+                  +----------------+\n|  pointers to  | same as pointers       |                  | ``[]``, ``+``, |\n|  structure or |                        |                  | ``-``, bool(), |\n|  union        |                        |                  | and read/write |\n|               |                        |                  | struct fields  |\n+---------------+------------------------+                  +----------------+\n| function      | same as pointers       |                  | bool(),        |\n| pointers      |                        |                  | call `[2]`     |\n+---------------+------------------------+------------------+----------------+\n|  arrays       | a list or tuple of     | a <cdata>        |len(), iter(),  |\n|               | items                  |                  |``[]`` `[4]`,   |\n|               |                        |                  |``+``, ``-``    |\n+---------------+------------------------+                  +----------------+\n| ``char[]``,   | same as arrays, or a   |                  | len(), iter(), |\n| ``un/signed`` | Python byte string     |                  | ``[]``, ``+``, |\n| ``char[]``,   |                        |                  | ``-``          |\n| ``_Bool[]``   |                        |                  |                |\n+---------------+------------------------+                  +----------------+\n|``wchar_t[]``, | same as arrays, or a   |                  | len(), iter(), |\n|``char16_t[]``,| Python unicode string  |                  | ``[]``,        |\n|``char32_t[]`` |                        |                  | ``+``, ``-``   |\n|               |                        |                  |                |\n+---------------+------------------------+------------------+----------------+\n| structure     | a list or tuple or     | a <cdata>        | read/write     |\n|               | dict of the field      |                  | fields         |\n|               | values, or a same-type |                  |                |\n|               | <cdata>                |                  |                |\n+---------------+------------------------+                  +----------------+\n| union         | same as struct, but    |                  | read/write     |\n|               | with at most one field |                  | fields         |\n+---------------+------------------------+------------------+----------------+\n\n`[1]` ``item *`` is ``item[]`` in function arguments:\n\n   In a function declaration, as per the C standard, a ``item *``\n   argument is identical to a ``item[]`` argument (and ``ffi.cdef()``\n   doesn't record the difference).  So when you call such a function,\n   you can pass an argument that is accepted by either C type, like\n   for example passing a Python string to a ``char *`` argument\n   (because it works for ``char[]`` arguments) or a list of integers\n   to a ``int *`` argument (it works for ``int[]`` arguments).  Note\n   that even if you want to pass a single ``item``, you need to\n   specify it in a list of length 1; for example, a ``struct point_s\n   *`` argument might be passed as ``[[x, y]]`` or ``[{'x': 5, 'y':\n   10}]``.\n\n   As an optimization, CFFI assumes that a\n   function with a ``char *`` argument to which you pass a Python\n   string will not actually modify the array of characters passed in,\n   and so passes directly a pointer inside the Python string object.\n   (On PyPy, this optimization is only available since PyPy 5.4\n   with CFFI 1.8.)\n\n`[2]` C function calls are done with the GIL released.\n\n   Note that we assume that the called functions are *not* using the\n   Python API from Python.h.  For example, we don't check afterwards\n   if they set a Python exception.  You may work around it, but mixing\n   CFFI with ``Python.h`` is not recommended.  (If you do that, on\n   PyPy and on some platforms like Windows, you may need to explicitly\n   link to ``libpypy-c.dll`` to access the CPython C API compatibility\n   layer; indeed, CFFI-generated modules on PyPy don't link to\n   ``libpypy-c.dll`` on their own.  But really, don't do that in the\n   first place.)\n\n`[3]` ``long double`` support:\n\n   We keep ``long double`` values inside a cdata object to avoid\n   loosing precision.  Normal Python floating-point numbers only\n   contain enough precision for a ``double``.  If you really want to\n   convert such an object to a regular Python float (i.e. a C\n   ``double``), call ``float()``.  If you need to do arithmetic on\n   such numbers without any precision loss, you need instead to define\n   and use a family of C functions like ``long double add(long double\n   a, long double b);``.\n\n`[4]` Slicing with ``x[start:stop]``:\n\n   Slicing is allowed, as long as you specify explicitly both ``start``\n   and ``stop`` (and don't give any ``step``).  It gives a cdata\n   object that is a \"view\" of all items from ``start`` to ``stop``.\n   It is a cdata of type \"array\" (so e.g. passing it as an argument to a\n   C function would just convert it to a pointer to the ``start`` item).\n   As with indexing, negative bounds mean really negative indices, like in\n   C.  As for slice assignment, it accepts any iterable, including a list\n   of items or another array-like cdata object, but the length must match.\n   (Note that this behavior differs from initialization: e.g. you can\n   say ``chararray[10:15] = \"hello\"``, but the assigned string must be of\n   exactly the correct length; no implicit null character is added.)\n\n`[5]` Enums are handled like ints:\n\n   Like C, enum types are mostly int types (unsigned or signed, int or\n   long; note that GCC's first choice is unsigned).  Reading an enum\n   field of a structure, for example, returns you an integer.  To\n   compare their value symbolically, use code like ``if x.field ==\n   lib.FOO``.  If you really want to get their value as a string, use\n   ``ffi.string(ffi.cast(\"the_enum_type\", x.field))``.\n\n`[6]` bool() on a primitive cdata:\n\n   *New in version 1.7.*  In previous versions, it only worked on\n   pointers; for primitives it always returned True.\n\n   *New in version 1.10:*  The C type ``_Bool`` or ``bool`` converts to\n   Python booleans now.  You get an exception if a C ``_Bool`` happens\n   to contain a value different from 0 and 1 (this case triggers\n   undefined behavior in C; if you really have to interface with a\n   library relying on this, don't use ``_Bool`` in the CFFI side).\n   Also, when converting from a byte string to a ``_Bool[]``, only the\n   bytes ``\\x00`` and ``\\x01`` are accepted.\n\n`[7]` libffi does not support complex numbers:\n\n   *New in version 1.11:* CFFI now supports complex numbers directly.\n   Note however that libffi does not.  This means that C functions that\n   take directly as argument types or return type a complex type cannot\n   be called by CFFI, unless they are directly using the API mode.\n\n`[8]` ``wchar_t``, ``char16_t`` and ``char32_t``\n\n   See `Unicode character types`_ below.\n\n\n.. _file:\n\nSupport for FILE\n++++++++++++++++\n\nYou can declare C functions taking a ``FILE *`` argument and\ncall them with a Python file object.  If needed, you can also do ``c_f\n= ffi.cast(\"FILE *\", fileobj)`` and then pass around ``c_f``.\n\nNote, however, that CFFI does this by a best-effort approach.  If you\nneed finer control over buffering, flushing, and timely closing of the\n``FILE *``, then you should not use this special support for ``FILE *``.\nInstead, you can handle regular ``FILE *`` cdata objects that you\nexplicitly make using fdopen(), like this:\n\n.. code-block:: python\n\n    ffi.cdef('''\n        FILE *fdopen(int, const char *);   // from the C <stdio.h>\n        int fclose(FILE *);\n    ''')\n\n    myfile.flush()                    # make sure the file is flushed\n    newfd = os.dup(myfile.fileno())   # make a copy of the file descriptor\n    fp = lib.fdopen(newfd, \"w\")       # make a cdata 'FILE *' around newfd\n    lib.write_stuff_to_file(fp)       # invoke the external function\n    lib.fclose(fp)                    # when you're done, close fp (and newfd)\n\nThe special support for ``FILE *`` is anyway implemented in a similar manner\non CPython 3.x and on PyPy, because these Python implementations' files are\nnot natively based on ``FILE *``.  Doing it explicity offers more control.\n\n\n.. _unichar:\n\nUnicode character types\n+++++++++++++++++++++++\n\nThe ``wchar_t`` type has the same signedness as the underlying\nplatform's.  For example, on Linux, it is a signed 32-bit integer.\nHowever, the types ``char16_t`` and ``char32_t`` (*new in version 1.11*)\nare always unsigned.\n\nNote that CFFI assumes that these types are meant to contain UTF-16 or\nUTF-32 characters in the native endianness.  More precisely:\n\n* ``char32_t`` is assumed to contain UTF-32, or UCS4, which is just the\n  unicode codepoint;\n\n* ``char16_t`` is assumed to contain UTF-16, i.e. UCS2 plus surrogates;\n\n* ``wchar_t`` is assumed to contain either UTF-32 or UTF-16 based on its\n  actual platform-defined size of 4 or 2 bytes.\n\nWhether this assumption is true or not is unspecified by the C language.\nIn theory, the C library you are interfacing with could use one of these\ntypes with a different meaning.  You would then need to handle it\nyourself---for example, by using ``uint32_t`` instead of ``char32_t`` in\nthe ``cdef()``, and building the expected arrays of ``uint32_t``\nmanually.\n\nPython itself can be compiled with ``sys.maxunicode == 65535`` or\n``sys.maxunicode == 1114111`` (Python >= 3.3 is always 1114111).  This\nchanges the handling of surrogates (which are pairs of 16-bit\n\"characters\" which actually stand for a single codepoint whose value is\ngreater than 65535).  If your Python is ``sys.maxunicode == 1114111``,\nthen it can store arbitrary unicode codepoints; surrogates are\nautomatically inserted when converting from Python unicodes to UTF-16,\nand automatically removed when converting back.   On the other hand, if\nyour Python is ``sys.maxunicode == 65535``, then it is the other way\naround: surrogates are removed when converting from Python unicodes\nto UTF-32, and added when converting back.  In other words, surrogate\nconversion is done only when there is a size mismatch.\n\nNote that Python's internal representations is not specified.  For\nexample, on CPython >= 3.3, it will use 1- or 2- or 4-bytes arrays\ndepending on what the string actually contains.  With CFFI, when you\npass a Python byte string to a C function expecting a ``char*``, then\nwe pass directly a pointer to the existing data without needing a\ntemporary buffer; however, the same cannot cleanly be done with\n*unicode* string arguments and the ``wchar_t*`` / ``char16_t*`` /\n``char32_t*`` types, because of the changing internal\nrepresentation.  As a result, and for consistency, CFFI always allocates\na temporary buffer for unicode strings.\n\n**Warning:** for now, if you use ``char16_t`` and ``char32_t`` with\n``set_source()``, you have to make sure yourself that the types are\ndeclared by the C source you provide to ``set_source()``.  They would be\ndeclared if you ``#include`` a library that explicitly uses them, for\nexample, or when using C++11.  Otherwise, you need ``#include\n<uchar.h>`` on Linux, or more generally something like ``typedef\nuint16_t char16_t;``.  This is not done automatically by CFFI because\n``uchar.h`` is not standard across platforms, and writing a ``typedef``\nlike above would crash if the type happens to be already defined.\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.13.0-jlicqgsrlask3n7tsdckxmdwv6d5zp4o/spack-src/doc/source/cdef.rst": "======================================\nPreparing and Distributing modules\n======================================\n\n.. contents::\n\nThere are three or four different ways to use CFFI in a project.\nIn order of complexity:\n\n* The **\"in-line\", \"ABI mode\"**:\n\n  .. code-block:: python\n\n    import cffi\n\n    ffi = cffi.FFI()\n    ffi.cdef(\"C-like declarations\")\n    lib = ffi.dlopen(\"libpath\")\n\n    # use ffi and lib here\n\n.. _out-of-line-abi:\n\n* The **\"out-of-line\",** but still **\"ABI mode\",** useful to organize\n  the code and reduce the import time:\n\n  .. code-block:: python\n\n    # in a separate file \"package/foo_build.py\"\n    import cffi\n\n    ffibuilder = cffi.FFI()\n    ffibuilder.set_source(\"package._foo\", None)\n    ffibuilder.cdef(\"C-like declarations\")\n\n    if __name__ == \"__main__\":\n        ffibuilder.compile()\n\n  Running ``python foo_build.py`` produces a file ``_foo.py``, which\n  can then be imported in the main program:\n\n  .. code-block:: python\n\n    from package._foo import ffi\n    lib = ffi.dlopen(\"libpath\")\n\n    # use ffi and lib here\n\n.. _out-of-line-api:\n\n* The **\"out-of-line\", \"API mode\"** gives you the most flexibility\n  and speed to access a C library at the level of C, instead of at the\n  binary level:\n\n  .. code-block:: python\n\n    # in a separate file \"package/foo_build.py\"\n    import cffi\n\n    ffibuilder = cffi.FFI()\n    ffibuilder.set_source(\"package._foo\", r\"\"\"real C code\"\"\")   # <=\n    ffibuilder.cdef(\"C-like declarations with '...'\")\n\n    if __name__ == \"__main__\":\n        ffibuilder.compile(verbose=True)\n\n  Running ``python foo_build.py`` produces a file ``_foo.c`` and\n  invokes the C compiler to turn it into a file ``_foo.so`` (or\n  ``_foo.pyd`` or ``_foo.dylib``).  It is a C extension module which\n  can be imported in the main program:\n\n  .. code-block:: python\n\n    from package._foo import ffi, lib\n    # no ffi.dlopen()\n\n    # use ffi and lib here\n\n.. _distutils-setuptools:\n\n* Finally, you can (but don't have to) use CFFI's **Distutils** or\n  **Setuptools integration** when writing a ``setup.py``.  For\n  Distutils (only in out-of-line API mode):\n\n  .. code-block:: python\n\n    # setup.py (requires CFFI to be installed first)\n    from distutils.core import setup\n\n    import foo_build   # possibly with sys.path tricks to find it\n\n    setup(\n        ...,\n        ext_modules=[foo_build.ffibuilder.distutils_extension()],\n    )\n\n  For Setuptools (out-of-line, but works in ABI or API mode;\n  recommended):\n\n  .. code-block:: python\n\n    # setup.py (with automatic dependency tracking)\n    from setuptools import setup\n\n    setup(\n        ...,\n        setup_requires=[\"cffi>=1.0.0\"],\n        cffi_modules=[\"package/foo_build.py:ffibuilder\"],\n        install_requires=[\"cffi>=1.0.0\"],\n    )\n\n  Note again that the ``foo_build.py`` example contains the following\n  lines, which mean that the ``ffibuilder`` is not actually compiled\n  when ``package.foo_build`` is merely imported---it will be compiled\n  independently by the Setuptools logic, using compilation parameters\n  provided by Setuptools:\n\n  .. code-block:: python\n\n    if __name__ == \"__main__\":    # not when running with setuptools\n        ffibuilder.compile(verbose=True)\n\n* Note that some bundler tools that try to find all modules used by a\n  project, like PyInstaller, will miss ``_cffi_backend`` in the\n  out-of-line mode because your program contains no explicit ``import\n  cffi`` or ``import _cffi_backend``.  You need to add\n  ``_cffi_backend`` explicitly (as a \"hidden import\" in PyInstaller,\n  but it can also be done more generally by adding the line ``import\n  _cffi_backend`` in your main program).\n\nNote that CFFI actually contains two different ``FFI`` classes.  The\npage `Using the ffi/lib objects`_ describes the common functionality.\nIt is what you get in the ``from package._foo import ffi`` lines above.\nOn the other hand, the extended ``FFI`` class is the one you get from\n``import cffi; ffi_or_ffibuilder = cffi.FFI()``.  It has the same\nfunctionality (for in-line use), but also the extra methods described\nbelow (to prepare the FFI).  NOTE: We use the name ``ffibuilder``\ninstead of ``ffi`` in the out-of-line context, when the code is about\nproducing a ``_foo.so`` file; this is an attempt to distinguish it\nfrom the different ``ffi`` object that you get by later saying\n``from _foo import ffi``.\n\n.. _`Using the ffi/lib objects`: using.html\n\nThe reason for this split of functionality is that a regular program\nusing CFFI out-of-line does not need to import the ``cffi`` pure\nPython package at all.  (Internally it still needs ``_cffi_backend``,\na C extension module that comes with CFFI; this is why CFFI is also\nlisted in ``install_requires=..`` above.  In the future this might be\nsplit into a different PyPI package that only installs\n``_cffi_backend``.)\n\nNote that a few small differences do exist: notably, ``from _foo import\nffi`` returns an object of a type written in C, which does not let you\nadd random attributes to it (nor does it have all the\nunderscore-prefixed internal attributes of the Python version).\nSimilarly, the ``lib`` objects returned by the C version are read-only,\napart from writes to global variables.  Also, ``lib.__dict__`` does\nnot work before version 1.2 or if ``lib`` happens to declare a name\ncalled ``__dict__`` (use instead ``dir(lib)``).  The same is true\nfor ``lib.__class__``, ``lib.__all__`` and ``lib.__name__`` added\nin successive versions.\n\n\n.. _cdef:\n\nffi/ffibuilder.cdef(): declaring types and functions\n----------------------------------------------------\n\n**ffi/ffibuilder.cdef(source)**: parses the given C source.\nIt registers all the functions, types, constants and global variables in\nthe C source.  The types can be used immediately in ``ffi.new()`` and\nother functions.  Before you can access the functions and global\nvariables, you need to give ``ffi`` another piece of information: where\nthey actually come from (which you do with either ``ffi.dlopen()`` or\n``ffi.set_source()``).\n\n.. _`all types listed above`:\n\nThe C source is parsed internally (using ``pycparser``).  This code\ncannot contain ``#include``.  It should typically be a self-contained\npiece of declarations extracted from a man page.  The only things it\ncan assume to exist are the standard types:\n\n* char, short, int, long, long long (both signed and unsigned)\n\n* float, double, long double\n\n* intN_t, uintN_t (for N=8,16,32,64), intptr_t, uintptr_t, ptrdiff_t,\n  size_t, ssize_t\n\n* wchar_t (if supported by the backend).  *New in version 1.11:*\n  char16_t and char32_t.\n\n* _Bool and bool (equivalent).  If not directly supported by the C\n  compiler, this is declared with the size of ``unsigned char``.\n\n* FILE.  `See here.`__\n\n* all `common Windows types`_ are defined if you run\n  on Windows (``DWORD``, ``LPARAM``, etc.).  Exception:\n  ``TBYTE TCHAR LPCTSTR PCTSTR LPTSTR PTSTR PTBYTE PTCHAR`` are\n  not automatically defined; see `ffi.set_unicode()`_.\n\n* the other standard integer types from\n  stdint.h, like ``intmax_t``, as long as they map to integers of 1,\n  2, 4 or 8 bytes.  Larger integers are not supported.\n\n.. __: ref.html#file\n.. _`common Windows types`: http://msdn.microsoft.com/en-us/library/windows/desktop/aa383751%28v=vs.85%29.aspx\n\nThe declarations can also contain \"``...``\" at various places; these are\nplaceholders that will be completed by the compiler.  More information\nabout it below in `Letting the C compiler fill the gaps`_.\n\nNote that all standard type names listed above are handled as\n*defaults* only (apart from the ones that are keywords in the C\nlanguage).  If your ``cdef`` contains an explicit typedef that\nredefines one of the types above, then the default described above is\nignored.  (This is a bit hard to implement cleanly, so in some corner\ncases it might fail, notably with the error ``Multiple type specifiers\nwith a type tag``.  Please report it as a bug if it does.)\n\nMultiple calls to ``ffi.cdef()`` are possible.  Beware that it can be\nslow to call ``ffi.cdef()`` a lot of times, a consideration that is\nimportant mainly in in-line mode.\n\nThe ``ffi.cdef()`` call optionally takes an extra argument: either\n``packed`` or ``pack``.  If you pass ``packed=True``,\nthen all structs declared within\nthis cdef are \"packed\".  (If you need both packed and non-packed\nstructs, use several cdefs in sequence.)  This\nhas a meaning similar to ``__attribute__((packed))`` in GCC.  It\nspecifies that all structure fields should have an alignment of one\nbyte.  (Note that the packed attribute has no effect on bit fields so\nfar, which mean that they may be packed differently than on GCC.\nAlso, this has no effect on structs declared with ``\"...;\"``---more\nabout it later in `Letting the C compiler fill the gaps`_.)\n*New in version 1.12:*  In ABI mode, you can also pass ``pack=n``,\nwith an integer ``n`` which must be a power of two.  Then the\nalignment of any field is limited to ``n`` if it would otherwise be\ngreater than ``n``.  Passing ``pack=1`` is equivalent to passing\n``packed=True``.  This is meant to emulate ``#pragma pack(n)`` from\nthe MSVC compiler.  On Windows, the default is ``pack=8`` (from cffi\n1.12 onwards); on other platforms, the default is ``pack=None``.\n\nNote that you can use the type-qualifiers ``const`` and ``restrict``\n(but not ``__restrict`` or ``__restrict__``) in the ``cdef()``, but\nthis has no effect on the cdata objects that you get at run-time (they\nare never ``const``).  The effect is limited to knowing if a global\nvariable is meant to be a constant or not.  Also, *new in version\n1.3:* when using ``set_source()`` or ``verify()``, these two\nqualifiers are copied from the cdef to the generated C code; this\nfixes warnings by the C compiler.\n\nNote a trick if you copy-paste code from sources in which there are\nextra macros (for example, the Windows documentation uses SAL\nannotations like ``_In_`` or ``_Out_``).  These hints must be removed\nin the string given to cdef(), but it can be done programmatically\nlike this::\n\n    ffi.cdef(re.sub(r\"\\b(_In_|_Inout_|_Out_|_Outptr_)(opt_)?\\b\", \" \",\n      \"\"\"\n        DWORD WINAPI GetModuleFileName(\n          _In_opt_ HMODULE hModule,\n          _Out_    LPTSTR  lpFilename,\n          _In_     DWORD   nSize\n        );\n      \"\"\"))\n\nNote also that pycparser, the underlying C parser, recognizes\npreprocessor-like directives in the following format: ``# NUMBER\n\"FILE\"``.  For example, if you put ``# 42 \"foo.h\"`` in the middle of the\nstring passed to ``cdef()`` and there is an error two lines later, then\nit is reported with an error message that starts with ``foo.h:43:`` (the\nline which is given the number 42 is the line immediately after the\ndirective).  *New in version 1.10.1:*  CFFI automatically puts the line\n``# 1 \"<cdef source string>\"`` just before the string you give to\n``cdef()``.\n\n\n.. _`ffi.set_unicode()`:\n\n**ffi.set_unicode(enabled_flag)**: Windows: if ``enabled_flag`` is\nTrue, enable the ``UNICODE`` and ``_UNICODE`` defines in C, and\ndeclare the types ``TBYTE TCHAR LPCTSTR PCTSTR LPTSTR PTSTR PTBYTE\nPTCHAR`` to be (pointers to) ``wchar_t``.  If ``enabled_flag`` is\nFalse, declare these types to be (pointers to) plain 8-bit characters.\n(These types are not predeclared at all if you don't call\n``set_unicode()``.)\n\nThe reason behind this method is that a lot of standard functions have\ntwo versions, like ``MessageBoxA()`` and ``MessageBoxW()``.  The\nofficial interface is ``MessageBox()`` with arguments like\n``LPTCSTR``.  Depending on whether ``UNICODE`` is defined or not, the\nstandard header renames the generic function name to one of the two\nspecialized versions, and declares the correct (unicode or not) types.\n\nUsually, the right thing to do is to call this method with True.  Be\naware (particularly on Python 2) that, afterwards, you need to pass unicode\nstrings as arguments instead of byte strings.\n\n\n.. _loading-libraries:\n\nffi.dlopen(): loading libraries in ABI mode\n-------------------------------------------\n\n``ffi.dlopen(libpath, [flags])``: this function opens a shared library and\nreturns a module-like library object.  Use this when you are fine with\nthe limitations of ABI-level access to the system (dependency on ABI\ndetails, getting crashes instead of C compiler errors/warnings, and\nhigher overhead to call the C functions).  In case of doubt, read again\n`ABI versus API`_ in the overview.\n\n.. _`ABI versus API`: overview.html#abi-versus-api\n\nYou can use the library object to call the functions previously\ndeclared by ``ffi.cdef()``, to read constants, and to read or write\nglobal variables.  Note that you can use a single ``cdef()`` to\ndeclare functions from multiple libraries, as long as you load each of\nthem with ``dlopen()`` and access the functions from the correct one.\n\nThe ``libpath`` is the file name of the shared library, which can\ncontain a full path or not (in which case it is searched in standard\nlocations, as described in ``man dlopen``), with extensions or not.\nAlternatively, if ``libpath`` is None, it returns the standard C library\n(which can be used to access the functions of glibc, on Linux).  Note\nthat ``libpath`` `cannot be None`__ on Windows with Python 3.\n\n.. __: http://bugs.python.org/issue23606\n\nLet me state it again: this gives ABI-level access to the library, so\nyou need to have all types declared manually exactly as they were\nwhile the library was made.  No checking is done.  Mismatches can\ncause random crashes.  API-level access, on the other hand, is safer.\nSpeed-wise, API-level access is much faster (it is common to have\nthe opposite misconception about performance).\n\nNote that only functions and global variables live in library objects;\nthe types exist in the ``ffi`` instance independently of library objects.\nThis is due to the C model: the types you declare in C are not tied to a\nparticular library, as long as you ``#include`` their headers; but you\ncannot call functions from a library without linking it in your program,\nas ``dlopen()`` does dynamically in C.\n\nFor the optional ``flags`` argument, see ``man dlopen`` (ignored on\nWindows).  It defaults to ``ffi.RTLD_NOW``.\n\nThis function returns a \"library\" object that gets closed when it goes\nout of scope.  Make sure you keep the library object around as long as\nneeded.  (Alternatively, the out-of-line FFIs have a method\n``ffi.dlclose(lib)``.)\n\n.. _dlopen-note:\n\nNote: the old version of ``ffi.dlopen()`` from the in-line ABI mode\ntries to use ``ctypes.util.find_library()`` if it cannot directly find\nthe library.  The newer out-of-line ``ffi.dlopen()`` no longer does it\nautomatically; it simply passes the argument it receives to the\nunderlying ``dlopen()`` or ``LoadLibrary()`` function.  If needed, it\nis up to you to use ``ctypes.util.find_library()`` or any other way to\nlook for the library's filename.  This also means that\n``ffi.dlopen(None)`` no longer work on Windows; try instead\n``ffi.dlopen(ctypes.util.find_library('c'))``.\n\n\nffibuilder.set_source(): preparing out-of-line modules\n------------------------------------------------------\n\n**ffibuilder.set_source(module_name, c_header_source, [\\*\\*keywords...])**:\nprepare the ffi for producing out-of-line an external module called\n``module_name``.\n\n``ffibuilder.set_source()`` by itself does not write any file, but merely\nrecords its arguments for later.  It can therefore be called before or\nafter ``ffibuilder.cdef()``.\n\nIn **ABI mode,** you call ``ffibuilder.set_source(module_name, None)``.  The\nargument is the name (or dotted name inside a package) of the Python\nmodule to generate.  In this mode, no C compiler is called.\n\nIn **API mode,** the ``c_header_source`` argument is a string that\nwill be pasted into the .c file generated.  Typically, it is specified as\n``r\"\"\" ...multiple lines of C code... \"\"\"`` (the ``r`` prefix allows these\nlines to contain a literal ``\\n``, for example).  This piece of C code\ntypically contains some ``#include``, but may also contain more,\nlike definitions for custom \"wrapper\" C functions.  The goal is that\nthe .c file can be generated like this::\n\n    // C file \"module_name.c\"\n    #include <Python.h>\n\n    ...c_header_source...\n\n    ...magic code...\n\nwhere the \"magic code\" is automatically generated from the ``cdef()``.\nFor example, if the ``cdef()`` contains ``int foo(int x);`` then the\nmagic code will contain logic to call the function ``foo()`` with an\ninteger argument, itself wrapped inside some CPython or PyPy-specific\ncode.\n\nThe keywords arguments to ``set_source()`` control how the C compiler\nwill be called.  They are passed directly to distutils_ or setuptools_\nand include at least ``sources``, ``include_dirs``, ``define_macros``,\n``undef_macros``, ``libraries``, ``library_dirs``, ``extra_objects``,\n``extra_compile_args`` and ``extra_link_args``.  You typically need at\nleast ``libraries=['foo']`` in order to link with ``libfoo.so`` or\n``libfoo.so.X.Y``, or ``foo.dll`` on Windows.  The ``sources`` is a\nlist of extra .c files compiled and linked together (the file\n``module_name.c`` shown above is always generated and automatically added as the\nfirst argument to ``sources``).  See the distutils documentations for\n`more information about the other arguments`__.\n\n.. __: http://docs.python.org/distutils/setupscript.html#library-options\n.. _distutils: http://docs.python.org/distutils/setupscript.html#describing-extension-modules\n.. _setuptools: https://pythonhosted.org/setuptools/setuptools.html\n\nAn extra keyword argument processed internally is\n``source_extension``, defaulting to ``\".c\"``.  The file generated will\nbe actually called ``module_name + source_extension``.  Example for\nC++ (but note that there are still a few known issues of C-versus-C++\ncompatibility):\n\n.. code-block:: python\n\n    ffibuilder.set_source(\"mymodule\", r'''\n    extern \"C\" {\n        int somefunc(int somearg) { return real_cpp_func(somearg); }\n    }\n    ''', source_extension='.cpp')\n\n.. _pkgconfig:\n\n**ffibuilder.set_source_pkgconfig(module_name, pkgconfig_libs,\nc_header_source, [\\*\\*keywords...])**:\n\n*New in version 1.12.*  This is equivalent to ``set_source()`` but it\nfirst calls the system utility ``pkg-config`` with the package names\ngiven in the list ``pkgconfig_libs``.  It collects the information\nobtained in this way and adds it to the explicitly-provided\n``**keywords`` (if any).  This should probably not be used on Windows.\n\nIf the ``pkg-config`` program is not installed or does not know about\nthe requested library, the call fails with ``cffi.PkgConfigError``.  If\nnecessary, you can catch this error and try to call ``set_source()``\ndirectly.  (Ideally, you should also do that if the ``ffibuilder``\ninstance has no method ``set_source_pkgconfig()``, to support older\nversions of cffi.)\n\n\nLetting the C compiler fill the gaps\n------------------------------------\n\nIf you are using a C compiler (\"API mode\"), then:\n\n*  functions taking or returning integer or float-point arguments can be\n   misdeclared: if e.g. a function is declared by ``cdef()`` as taking a\n   ``int``, but actually takes a ``long``, then the C compiler handles the\n   difference.\n\n*  other arguments are checked: you get a compilation warning or error\n   if you pass a ``int *`` argument to a function expecting a ``long *``.\n\n*  similarly, most other things declared in the ``cdef()`` are checked,\n   to the best we implemented so far; mistakes give compilation\n   warnings or errors.\n\nMoreover, you can use \"``...``\" (literally, dot-dot-dot) in the\n``cdef()`` at various places, in order to ask the C compiler to fill\nin the details.  These places are:\n\n*  structure declarations: any ``struct { }`` that ends with \"``...;``\" as\n   the last \"field\" is\n   partial: it may be missing fields and/or have them declared out of order.\n   This declaration will be corrected by the compiler.  (But note that you\n   can only access fields that you declared, not others.)  Any ``struct``\n   declaration which doesn't use \"``...``\" is assumed to be exact, but this is\n   checked: you get an error if it is not correct.\n\n*  integer types: the syntax \"``typedef\n   int... foo_t;``\" declares the type ``foo_t`` as an integer type\n   whose exact size and signedness is not specified.  The compiler will\n   figure it out.  (Note that this requires ``set_source()``; it does\n   not work with ``verify()``.)  The ``int...`` can be replaced with\n   ``long...`` or ``unsigned long long...`` or any other primitive\n   integer type, with no effect.  The type will always map to one of\n   ``(u)int(8,16,32,64)_t`` in Python, but in the generated C code,\n   only ``foo_t`` is used.\n\n* *New in version 1.3:* floating-point types: \"``typedef\n  float... foo_t;``\" (or equivalently \"``typedef double... foo_t;``\")\n  declares ``foo_t`` as a-float-or-a-double; the compiler will figure\n  out which it is.  Note that if the actual C type is even larger\n  (``long double`` on some platforms), then compilation will fail.\n  The problem is that the Python \"float\" type cannot be used to store\n  the extra precision.  (Use the non-dot-dot-dot syntax ``typedef long\n  double foo_t;`` as usual, which returns values that are not Python\n  floats at all but cdata \"long double\" objects.)\n\n*  unknown types: the syntax \"``typedef ... foo_t;``\" declares the type\n   ``foo_t`` as opaque.  Useful mainly for when the API takes and returns\n   ``foo_t *`` without you needing to look inside the ``foo_t``.  Also\n   works with \"``typedef ... *foo_p;``\" which declares the pointer type\n   ``foo_p`` without giving a name to the opaque type itself.  Note that\n   such an opaque struct has no known size, which prevents some operations\n   from working (mostly like in C).  *You cannot use this syntax to\n   declare a specific type, like an integer type!  It declares opaque\n   struct-like types only.*  In some cases you need to say that\n   ``foo_t`` is not opaque, but just a struct where you don't know any\n   field; then you would use \"``typedef struct { ...; } foo_t;``\".\n\n*  array lengths: when used as structure fields or in global variables,\n   arrays can have an unspecified length, as in \"``int n[...];``\".  The\n   length is completed by the C compiler.\n   This is slightly different from \"``int n[];``\", because the latter\n   means that the length is not known even to the C compiler, and thus\n   no attempt is made to complete it.  This supports\n   multidimensional arrays: \"``int n[...][...];``\".\n\n   *New in version 1.2:* \"``int m[][...];``\", i.e. ``...`` can be used\n   in the innermost dimensions without being also used in the outermost\n   dimension.  In the example given, the length of the ``m`` array is\n   assumed not to be known to the C compiler, but the length of every\n   item (like the sub-array ``m[0]``) is always known the C compiler.\n   In other words, only the outermost dimension can be specified as\n   ``[]``, both in C and in CFFI, but any dimension can be given as\n   ``[...]`` in CFFI.\n\n*  enums: if you don't know the exact order (or values) of the declared\n   constants, then use this syntax: \"``enum foo { A, B, C, ... };``\"\n   (with a trailing \"``...``\").  The C compiler will be used to figure\n   out the exact values of the constants.  An alternative syntax is\n   \"``enum foo { A=..., B, C };``\" or even\n   \"``enum foo { A=..., B=..., C=... };``\".  Like\n   with structs, an ``enum`` without \"``...``\" is assumed to\n   be exact, and this is checked.\n\n*  integer constants and macros: you can write in the ``cdef`` the line\n   \"``#define FOO ...``\", with any macro name FOO but with ``...`` as\n   a value.  Provided the macro\n   is defined to be an integer value, this value will be available via\n   an attribute of the library object.  The\n   same effect can be achieved by writing a declaration\n   ``static const int FOO;``.  The latter is more general because it\n   supports other types than integer types (note: the C syntax is then\n   to write the ``const`` together with the variable name, as in\n   ``static char *const FOO;``).\n\nCurrently, it is not supported to find automatically which of the\nvarious integer or float types you need at which place---except in the\nfollowing case: if such a type is explicitly named.  For an integer\ntype, use ``typedef int... the_type_name;``, or another type like\n``typedef unsigned long... the_type_name;``.  Both are equivalent and\nreplaced by the real C type, which must be an integer type.\nSimilarly, for floating-point types, use ``typedef float...\nthe_type_name;`` or equivalently ``typedef double...  the_type_name;``.\nNote that ``long double`` cannot be detected this way.\n\nIn the case of function arguments or return types, when it is a simple\ninteger/float type, you can simply misdeclare it.  If you misdeclare a\nfunction ``void f(long)`` as ``void f(int)``, it still works (but you\nhave to call it with arguments that fit an int).  It works because the C\ncompiler will do the casting for us.  This C-level casting of arguments\nand return types only works for regular function, and not for function\npointer types; currently, it also does not work for variadic functions.\n\nFor more complex types, you have no choice but be precise.  For example,\nyou cannot misdeclare a ``int *`` argument as ``long *``, or a global\narray ``int a[5];`` as ``long a[5];``.  CFFI considers `all types listed\nabove`_ as primitive (so ``long long a[5];`` and ``int64_t a[5]`` are\ndifferent declarations).  The reason for that is detailed in `a comment\nabout an issue.`__\n\n.. __: https://bitbucket.org/cffi/cffi/issues/265/cffi-doesnt-allow-creating-pointers-to#comment-28406958\n\n\nffibuilder.compile() etc.: compiling out-of-line modules\n--------------------------------------------------------\n\nYou can use one of the following functions to actually generate the\n.py or .c file prepared with ``ffibuilder.set_source()`` and\n``ffibuilder.cdef()``.\n\nNote that these function won't overwrite a .py/.c file with exactly\nthe same content, to preserve the mtime.  In some cases where you need\nthe mtime to be updated anyway, delete the file before calling the\nfunctions.\n\n*New in version 1.8:* the C code produced by ``emit_c_code()`` or\n``compile()`` contains ``#define Py_LIMITED_API``.  This means that on\nCPython >= 3.2, compiling this source produces a binary .so/.dll that\nshould work for any version of CPython >= 3.2 (as opposed to only for\nthe same version of CPython x.y).  However, the standard ``distutils``\npackage will still produce a file called e.g.\n``NAME.cpython-35m-x86_64-linux-gnu.so``.  You can manually rename it to\n``NAME.abi3.so``, or use setuptools version 26 or later.  Also, note\nthat compiling with a debug version of Python will not actually define\n``Py_LIMITED_API``, as doing so makes ``Python.h`` unhappy.\n\n*New in version 1.12:* ``Py_LIMITED_API`` is now defined on Windows too.\nIf you use ``virtualenv``, you need a recent version of it: versions\nolder than 16.0.0 forgot to copy ``python3.dll`` into the virtual\nenvironment.  In case upgrading ``virtualenv`` is a real problem, you\ncan manually edit the C code to remove the first line ``# define\nPy_LIMITED_API``.\n\n**ffibuilder.compile(tmpdir='.', verbose=False, debug=None):**\nexplicitly generate the .py or .c file,\nand (if .c) compile it.  The output file is (or are) put in the\ndirectory given by ``tmpdir``.  In the examples given here, we use\n``if __name__ == \"__main__\": ffibuilder.compile()`` in the build scripts---if\nthey are directly executed, this makes them rebuild the .py/.c file in\nthe current directory.  (Note: if a package is specified in the call\nto ``set_source()``, then a corresponding subdirectory of the ``tmpdir``\nis used.)\n\n*New in version 1.4:* ``verbose`` argument.  If True, it prints the\nusual distutils output, including the command lines that call the\ncompiler.  (This parameter might be changed to True by default in a\nfuture release.)\n\n*New in version 1.8.1:* ``debug`` argument.  If set to a bool, it\ncontrols whether the C code is compiled in debug mode or not.  The\ndefault None means to use the host Python's ``sys.flags.debug``.\nStarting with version 1.8.1, if you are running a debug-mode Python, the\nC code is thus compiled in debug mode by default (note that it is anyway\nnecessary to do so on Windows).\n\n**ffibuilder.emit_python_code(filename):** generate the given .py file (same\nas ``ffibuilder.compile()`` for ABI mode, with an explicitly-named file to\nwrite).  If you choose, you can include this .py file pre-packaged in\nyour own distributions: it is identical for any Python version (2 or\n3).\n\n**ffibuilder.emit_c_code(filename):** generate the given .c file (for API\nmode) without compiling it.  Can be used if you have some other method\nto compile it, e.g. if you want to integrate with some larger build\nsystem that will compile this file for you.  You can also distribute\nthe .c file: unless the build script you used depends on the OS or\nplatform, the .c file itself is generic (it would be exactly the same\nif produced on a different OS, with a different version of CPython, or\nwith PyPy; it is done with generating the appropriate ``#ifdef``).\n\n**ffibuilder.distutils_extension(tmpdir='build', verbose=True):** for\ndistutils-based ``setup.py`` files.  Calling this creates the .c file\nif needed in the given ``tmpdir``, and returns a\n``distutils.core.Extension`` instance.\n\nFor Setuptools, you use instead the line\n``cffi_modules=[\"path/to/foo_build.py:ffibuilder\"]`` in ``setup.py``.  This\nline asks Setuptools to import and use a helper provided by CFFI,\nwhich in turn executes the file ``path/to/foo_build.py`` (as with\n``execfile()``) and looks up its global variable called ``ffibuilder``.  You\ncan also say ``cffi_modules=[\"path/to/foo_build.py:maker\"]``, where\n``maker`` names a global function; it is called with no argument and\nis supposed to return a ``FFI`` object.\n\n\nffi/ffibuilder.include(): combining multiple CFFI interfaces\n------------------------------------------------------------\n\n**ffi/ffibuilder.include(other_ffi)**: includes the typedefs, structs, unions,\nenums and constants defined in another FFI instance.  This is meant\nfor large projects where one CFFI-based interface depends on some\ntypes declared in a different CFFI-based interface.\n\n*Note that you should only use one ffi object per library; the intended\nusage of ffi.include() is if you want to interface with several\ninter-dependent libraries.*  For only one library, make one ``ffi``\nobject.  (You can write several ``cdef()`` calls over the same ``ffi``\nfrom several Python files, if one file would be too large.)\n\nFor out-of-line modules, the ``ffibuilder.include(other_ffibuilder)``\nline should\noccur in the build script, and the ``other_ffibuilder`` argument should be\nanother FFI instance that comes from another build script.  When the two build\nscripts are turned into generated files, say ``_ffi.so`` and\n``_other_ffi.so``, then importing ``_ffi.so`` will internally cause\n``_other_ffi.so`` to be imported.  At that point, the real\ndeclarations from ``_other_ffi.so`` are combined with the real\ndeclarations from ``_ffi.so``.\n\nThe usage of ``ffi.include()`` is the cdef-level equivalent of a\n``#include`` in C, where a part of the program might include types and\nfunctions defined in another part for its own usage.  You can see on\nthe ``ffi`` object (and associated ``lib`` objects on the *including*\nside) the types and constants declared on the included side.  In API\nmode, you can also see the functions and global variables directly.\nIn ABI mode, these must be accessed via the original ``other_lib``\nobject returned by the ``dlopen()`` method on ``other_ffi``.\n\n\nffi.cdef() limitations\n----------------------\n\nAll of the ANSI C *declarations* should be supported in ``cdef()``,\nand some of C99.  (This excludes any ``#include`` or ``#ifdef``.)\nKnown missing features that are either in C99, or are GCC or MSVC\nextensions:\n\n* Any ``__attribute__`` or ``#pragma pack(n)``\n\n* Additional types: special-size floating and fixed\n  point types, vector types, and so on.\n\n* The C99 types ``float _Complex`` and ``double _Complex`` are supported\n  by cffi since version 1.11, but not libffi: you cannot call C\n  functions with complex arguments or return value, except if they are\n  directly API-mode functions.  The type ``long double _Complex`` is not\n  supported at all (declare and use it as if it were an array of two\n  ``long double``, and write wrapper functions in C with set_source()).\n\n* ``__restrict__`` or ``__restrict`` are extensions of, respectively,\n   GCC and MSVC.  They are not recognized.  But ``restrict`` is a C\n   keyword and is accepted (and ignored).\n\nNote that declarations like ``int field[];`` in\nstructures are interpreted as variable-length structures.  Declarations\nlike ``int field[...];`` on the other hand are arrays whose length is\ngoing to be completed by the compiler.  You can use ``int field[];``\nfor array fields that are not, in fact, variable-length; it works too,\nbut in this case, as CFFI\nbelieves it cannot ask the C compiler for the length of the array, you\nget reduced safety checks: for example, you risk overwriting the\nfollowing fields by passing too many array items in the constructor.\n\n*New in version 1.2:*\nThread-local variables (``__thread``) can be accessed, as well as\nvariables defined as dynamic macros (``#define myvar  (*fetchme())``).\nBefore version 1.2, you need to write getter/setter functions.\n\nNote that if you declare a variable in ``cdef()`` without using\n``const``, CFFI assumes it is a read-write variable and generates two\npieces of code, one to read it and one to write it.  If the variable\ncannot in fact be written to in C code, for one reason or another, it\nwill not compile.  In this case, you can declare it as a constant: for\nexample, instead of ``foo_t *myglob;`` you would use ``foo_t *const\nmyglob;``.  Note also that ``const foo_t *myglob;``  is a *variable;* it\ncontains a variable pointer to a constant ``foo_t``.\n\n\nDebugging dlopen'ed C libraries\n-------------------------------\n\nA few C libraries are actually hard to use correctly in a ``dlopen()``\nsetting.  This is because most C libraries are intended for, and tested\nwith, a situation where they are *linked* with another program, using\neither static linking or dynamic linking --- but from a program written\nin C, at start-up, using the linker's capabilities instead of\n``dlopen()``.\n\nThis can occasionally create issues.  You would have the same issues in\nanother setting than CFFI, like with ``ctypes`` or even plain C code that\ncalls ``dlopen()``.  This section contains a few generally useful\nenvironment variables (on Linux) that can help when debugging these\nissues.\n\n**export LD_TRACE_LOADED_OBJECTS=all**\n\n    provides a lot of information, sometimes too much depending on the\n    setting.  Output verbose debugging information about the dynamic\n    linker. If set to ``all`` prints all debugging information it has, if\n    set to ``help`` prints a help message about which categories can be\n    specified in this environment variable\n\n**export LD_VERBOSE=1**\n\n    (glibc since 2.1) If set to a nonempty string, output symbol\n    versioning information about the program if querying information\n    about the program (i.e., either ``LD_TRACE_LOADED_OBJECTS`` has been set,\n    or ``--list`` or ``--verify`` options have been given to the dynamic\n    linker).\n\n**export LD_WARN=1**\n\n    (ELF only)(glibc since 2.1.3) If set to a nonempty string, warn\n    about unresolved symbols.\n\n\nffi.verify(): in-line API-mode\n------------------------------\n\n**ffi.verify()** is supported for backward compatibility, but is\ndeprecated.  ``ffi.verify(c_header_source, tmpdir=.., ext_package=..,\nmodulename=.., flags=.., **kwargs)`` makes and compiles a C file from\nthe ``ffi.cdef()``, like ``ffi.set_source()`` in API mode, and then\nimmediately loads and returns the dynamic library object.  Some\nnon-trivial logic is used to decide if the dynamic library must be\nrecompiled or not; see below for ways to control it.\n\nThe ``c_header_source`` and the extra keyword arguments have the\nsame meaning as in ``ffi.set_source()``.\n\nOne remaining use case for ``ffi.verify()`` would be the following\nhack to find explicitly the size of any type, in bytes, and have it\navailable in Python immediately (e.g. because it is needed in order to\nwrite the rest of the build script):\n\n.. code-block:: python\n\n    ffi = cffi.FFI()\n    ffi.cdef(\"const int mysize;\")\n    lib = ffi.verify(\"const int mysize = sizeof(THE_TYPE);\")\n    print lib.mysize\n\nExtra arguments to ``ffi.verify()``:\n    \n*  ``tmpdir`` controls where the C\n   files are created and compiled. Unless the ``CFFI_TMPDIR`` environment\n   variable is set, the default is\n   ``directory_containing_the_py_file/__pycache__`` using the\n   directory name of the .py file that contains the actual call to\n   ``ffi.verify()``.  (This is a bit of a hack but is generally\n   consistent with the location of the .pyc files for your library.\n   The name ``__pycache__`` itself comes from Python 3.)\n\n*  ``ext_package`` controls in which package the\n   compiled extension module should be looked from.  This is\n   only useful after distributing ffi.verify()-based modules.\n\n*  The ``tag`` argument gives an extra string inserted in the\n   middle of the extension module's name: ``_cffi_<tag>_<hash>``.\n   Useful to give a bit more context, e.g. when debugging.\n\n*  The ``modulename`` argument can be used to force a specific module\n   name, overriding the name ``_cffi_<tag>_<hash>``.  Use with care,\n   e.g. if you are passing variable information to ``verify()`` but\n   still want the module name to be always the same (e.g. absolute\n   paths to local files).  In this case, no hash is computed and if\n   the module name already exists it will be reused without further\n   check.  Be sure to have other means of clearing the ``tmpdir``\n   whenever you change your sources.\n\n* ``source_extension`` has the same meaning as in ``ffibuilder.set_source()``.\n\n*  The optional ``flags`` argument (ignored on Windows) defaults to\n   ``ffi.RTLD_NOW``; see ``man dlopen``.  (With\n   ``ffibuilder.set_source()``, you would use ``sys.setdlopenflags()``.)\n\n*  The optional ``relative_to`` argument is useful if you need to list\n   local files passed to the C compiler::\n\n     ext = ffi.verify(..., sources=['foo.c'], relative_to=__file__)\n\n   The line above is roughly the same as::\n\n     ext = ffi.verify(..., sources=['/path/to/this/file/foo.c'])\n\n   except that the default name of the produced library is built from\n   the CRC checkum of the argument ``sources``, as well as most other\n   arguments you give to ``ffi.verify()`` -- but not ``relative_to``.\n   So if you used the second line, it would stop finding the\n   already-compiled library after your project is installed, because\n   the ``'/path/to/this/file'`` suddenly changed.  The first line does\n   not have this problem.\n\nNote that during development, every time you change the C sources that\nyou pass to ``cdef()`` or ``verify()``, then the latter will create a\nnew module file name, based on two CRC32 hashes computed from these\nstrings.  This creates more and more files in the ``__pycache__``\ndirectory.  It is recommended that you clean it up from time to time.\nA nice way to do that is to add, in your test suite, a call to\n``cffi.verifier.cleanup_tmpdir()``.  Alternatively, you can manually\nremove the whole ``__pycache__`` directory.\n\nAn alternative cache directory can be given as the ``tmpdir`` argument\nto ``verify()``, via the environment variable ``CFFI_TMPDIR``, or by\ncalling ``cffi.verifier.set_tmpdir(path)`` prior to calling\n``verify``.\n\n\nUpgrading from CFFI 0.9 to CFFI 1.0\n-----------------------------------\n\nCFFI 1.0 is backward-compatible, but it is still a good idea to\nconsider moving to the out-of-line approach new in 1.0.  Here are the\nsteps.\n\n**ABI mode** if your CFFI project uses ``ffi.dlopen()``:\n\n.. code-block:: python\n\n    import cffi\n\n    ffi = cffi.FFI()\n    ffi.cdef(\"stuff\")\n    lib = ffi.dlopen(\"libpath\")\n\nand *if* the \"stuff\" part is big enough that import time is a concern,\nthen rewrite it as described in `the out-of-line but still ABI mode`__\nabove.  Optionally, see also the `setuptools integration`__ paragraph.\n\n.. __: out-of-line-abi_\n.. __: distutils-setuptools_\n\n\n**API mode** if your CFFI project uses ``ffi.verify()``:\n\n.. code-block:: python\n\n    import cffi\n\n    ffi = cffi.FFI()\n    ffi.cdef(\"stuff\")\n    lib = ffi.verify(\"real C code\")\n\nthen you should really rewrite it as described in `the out-of-line,\nAPI mode`__ above.  It avoids a number of issues that have caused\n``ffi.verify()`` to grow a number of extra arguments over time.  Then\nsee the `distutils or setuptools`__ paragraph.  Also, remember to\nremove the ``ext_package=\"..\"`` from your ``setup.py``, which was\nsometimes needed with ``verify()`` but is just creating confusion with\n``set_source()``.\n\n.. __: out-of-line-api_\n.. __: distutils-setuptools_\n\nThe following example should work both with old (pre-1.0) and new\nversions of CFFI---supporting both is important to run on old\nversions of PyPy (CFFI 1.0 does not work in PyPy < 2.6):\n\n.. code-block:: python\n\n    # in a separate file \"package/foo_build.py\"\n    import cffi\n\n    ffi = cffi.FFI()\n    C_HEADER_SRC = r'''\n        #include \"somelib.h\"\n    '''\n    C_KEYWORDS = dict(libraries=['somelib'])\n\n    if hasattr(ffi, 'set_source'):\n        ffi.set_source(\"package._foo\", C_HEADER_SRC, **C_KEYWORDS)\n\n    ffi.cdef('''\n        int foo(int);\n    ''')\n\n    if __name__ == \"__main__\":\n        ffi.compile()\n\nAnd in the main program:\n\n.. code-block:: python\n\n    try:\n        from package._foo import ffi, lib\n    except ImportError:\n        from package.foo_build import ffi, C_HEADER_SRC, C_KEYWORDS\n        lib = ffi.verify(C_HEADER_SRC, **C_KEYWORDS)\n\n(FWIW, this latest trick can be used more generally to allow the\nimport to \"work\" even if the ``_foo`` module was not generated.)\n\nWriting a ``setup.py`` script that works both with CFFI 0.9 and 1.0\nrequires explicitly checking the version of CFFI that we can have---it\nis hard-coded as a built-in module in PyPy:\n\n.. code-block:: python\n\n    if '_cffi_backend' in sys.builtin_module_names:   # PyPy\n        import _cffi_backend\n        requires_cffi = \"cffi==\" + _cffi_backend.__version__\n    else:\n        requires_cffi = \"cffi>=1.0.0\"\n\nThen we use the ``requires_cffi`` variable to give different arguments to\n``setup()`` as needed, e.g.:\n\n.. code-block:: python\n\n    if requires_cffi.startswith(\"cffi==0.\"):\n        # backward compatibility: we have \"cffi==0.*\"\n        from package.foo_build import ffi\n        extra_args = dict(\n            ext_modules=[ffi.verifier.get_extension()],\n            ext_package=\"...\",    # if needed\n        )\n    else:\n        extra_args = dict(\n            setup_requires=[requires_cffi],\n            cffi_modules=['package/foo_build.py:ffi'],\n        )\n    setup(\n        name=...,\n        ...,\n        install_requires=[requires_cffi],\n        **extra_args\n    )\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.13.0-jlicqgsrlask3n7tsdckxmdwv6d5zp4o/spack-src/doc/source/whatsnew.rst": "======================\nWhat's New\n======================\n\n\nv1.13\n=====\n\n* ``ffi.from_buffer(\"type *\", ..)`` is now supported, in addition to\n  ``\"type[]\"``.  You can then write ``p.field`` to access the items, instead\n  of only ``p[0].field``.  Be careful that no bounds checking is performed, so\n  ``p[n]`` might access data out of bounds.\n\n* fix for structs containing unnamed bitfields like ``int : 1;``.\n\n* when calling cdata of \"function pointer\" type, give a RuntimeError instead\n  of a crash if the pointer happens to be NULL\n\n* support some more binary operations between constants in enum definitions\n  (PR #96)\n\n* silence a warning incorrectly emitted if you use a quote in a preprocessor\n  line\n\n* detect a corner case that would throw the C code into an infinite\n  recursion, with ``ffi.cdef(\"\"\"struct X { void(*fnptr)(struct X); };\"\"\")``\n\n\nv1.12.3\n=======\n\n* Fix for nested struct types that end in a var-sized array (#405).\n\n* Add support for using ``U`` and ``L`` characters at the end of integer\n  constants in ``ffi.cdef()`` (thanks Guillaume).\n\n* More 3.8 fixes.\n\n\nv1.12.2\n=======\n\n* Added temporary workaround to compile on CPython 3.8.0a2.\n\n\nv1.12.1\n=======\n\n* CPython 3 on Windows: we again no longer compile with ``Py_LIMITED_API``\n  by default because such modules *still* cannot be used with virtualenv.\n  The problem is that it doesn't work in CPython <= 3.4, and for\n  technical reason we can't enable this flag automatically based on the\n  version of Python.\n\n  Like before, `Issue #350`_ mentions a workaround if you still want\n  the ``Py_LIMITED_API`` flag and *either* you are not concerned about\n  virtualenv *or* you are sure your module will not be used on CPython\n  <= 3.4: pass ``define_macros=[(\"Py_LIMITED_API\", None)]`` to the\n  ``ffibuilder.set_source()`` call.\n\n\nv1.12\n=====\n\n* `Direct support for pkg-config`__.\n\n* ``ffi.from_buffer()`` takes a new optional *first* argument that gives\n  the array type of the result.  It also takes an optional keyword argument\n  ``require_writable`` to refuse read-only Python buffers.\n\n* ``ffi.new()``, ``ffi.gc()`` or ``ffi.from_buffer()`` cdata objects\n  can now be released at known times, either by using the ``with``\n  keyword or by calling the new ``ffi.release()``.\n\n* Windows, CPython 3.x: cffi modules are linked with ``python3.dll``\n  again.  This makes them independant on the exact CPython version,\n  like they are on other platforms.  **It requires virtualenv 16.0.0.**\n\n* Accept an expression like ``ffi.new(\"int[4]\", p)`` if ``p`` is itself\n  another cdata ``int[4]``.\n\n* CPython 2.x: ``ffi.dlopen()`` failed with non-ascii file names on Posix\n\n* CPython: if a thread is started from C and then runs Python code (with\n  callbacks or with the embedding solution), then previous versions of\n  cffi would contain possible crashes and/or memory leaks.  Hopefully,\n  this has been fixed (see `issue #362`_).\n\n* Support for ``ffi.cdef(..., pack=N)`` where N is a power of two.\n  Means to emulate ``#pragma pack(N)`` on MSVC.  Also, the default on\n  Windows is now ``pack=8``, like on MSVC.  This might make a difference\n  in corner cases, although I can't think of one in the context of CFFI.\n  The old way ``ffi.cdef(..., packed=True)`` remains and is equivalent\n  to ``pack=1`` (saying e.g. that fields like ``int`` should be aligned\n  to 1 byte instead of 4).\n\n.. __: cdef.html#pkgconfig\n.. _`issue #362`: https://bitbucket.org/cffi/cffi/issues/362/\n\n\nOlder Versions\n==============\n\nv1.11.5\n-------\n\n* `Issue #357`_: fix ``ffi.emit_python_code()`` which generated a buggy\n  Python file if you are using a ``struct`` with an anonymous ``union``\n  field or vice-versa.\n\n* Windows: ``ffi.dlopen()`` should now handle unicode filenames.\n\n* ABI mode: implemented ``ffi.dlclose()`` for the in-line case (it used\n  to be present only in the out-of-line case).\n\n* Fixed a corner case for ``setup.py install --record=xx --root=yy``\n  with an out-of-line ABI module.  Also fixed `Issue #345`_.\n\n* More hacks on Windows for running CFFI's own ``setup.py``.\n\n* `Issue #358`_: in embedding, to protect against (the rare case of)\n  Python initialization from several threads in parallel, we have to use\n  a spin-lock.  On CPython 3 it is worse because it might spin-lock for\n  a long time (execution of ``Py_InitializeEx()``).  Sadly, recent\n  changes to CPython make that solution needed on CPython 2 too.\n\n* CPython 3 on Windows: we no longer compile with ``Py_LIMITED_API``\n  by default because such modules cannot be used with virtualenv.\n  `Issue #350`_ mentions a workaround if you still want that and are not\n  concerned about virtualenv: pass a ``define_macros=[(\"Py_LIMITED_API\",\n  None)]`` to the ``ffibuilder.set_source()`` call.\n\n.. _`Issue #345`: https://bitbucket.org/cffi/cffi/issues/345/\n.. _`Issue #350`: https://bitbucket.org/cffi/cffi/issues/350/\n.. _`Issue #358`: https://bitbucket.org/cffi/cffi/issues/358/\n.. _`Issue #357`: https://bitbucket.org/cffi/cffi/issues/357/\n\n\nv1.11.4\n-------\n\n* Windows: reverted linking with ``python3.dll``, because\n  virtualenv does not make this DLL available to virtual environments\n  for now.  See `Issue #355`_.  On Windows only, the C extension\n  modules created by cffi follow for now the standard naming scheme\n  ``foo.cp36-win32.pyd``, to make it clear that they are regular\n  CPython modules depending on ``python36.dll``.\n\n.. _`Issue #355`: https://bitbucket.org/cffi/cffi/issues/355/\n\n\nv1.11.3\n-------\n\n* Fix on CPython 3.x: reading the attributes ``__loader__`` or\n  ``__spec__`` from the cffi-generated lib modules gave a buggy\n  SystemError.  (These attributes are always None, and provided only to\n  help compatibility with tools that expect them in all modules.)\n\n* More Windows fixes: workaround for MSVC not supporting large\n  literal strings in C code (from\n  ``ffi.embedding_init_code(large_string)``); and an issue with\n  ``Py_LIMITED_API`` linking with ``python35.dll/python36.dll`` instead\n  of ``python3.dll``.\n\n* Small documentation improvements.\n\n\nv1.11.2\n-------\n\n* Fix Windows issue with managing the thread-state on CPython 3.0 to 3.5\n\n\nv1.11.1\n-------\n\n* Fix tests, remove deprecated C API usage\n\n* Fix (hack) for 3.6.0/3.6.1/3.6.2 giving incompatible binary extensions\n  (cpython issue `#29943`_)\n\n* Fix for 3.7.0a1+\n\n.. _`#29943`: https://bugs.python.org/issue29943\n\n\nv1.11\n-----\n\n* Support the modern standard types ``char16_t`` and ``char32_t``.\n  These work like ``wchar_t``: they represent one unicode character, or\n  when used as ``charN_t *`` or ``charN_t[]`` they represent a unicode\n  string.  The difference with ``wchar_t`` is that they have a known,\n  fixed size.  They should work at all places that used to work with\n  ``wchar_t`` (please report an issue if I missed something).  Note\n  that with ``set_source()``, you need to make sure that these types are\n  actually defined by the C source you provide (if used in ``cdef()``).\n\n* Support the C99 types ``float _Complex`` and ``double _Complex``.\n  Note that libffi doesn't support them, which means that in the ABI\n  mode you still cannot call C functions that take complex numbers\n  directly as arguments or return type.\n\n* Fixed a rare race condition when creating multiple ``FFI`` instances\n  from multiple threads.  (Note that you aren't meant to create many\n  ``FFI`` instances: in inline mode, you should write ``ffi =\n  cffi.FFI()`` at module level just after ``import cffi``; and in\n  out-of-line mode you don't instantiate ``FFI`` explicitly at all.)\n\n* Windows: using callbacks can be messy because the CFFI internal error\n  messages show up to stderr---but stderr goes nowhere in many\n  applications.  This makes it particularly hard to get started with the\n  embedding mode.  (Once you get started, you can at least use\n  ``@ffi.def_extern(onerror=...)`` and send the error logs where it\n  makes sense for your application, or record them in log files, and so\n  on.)  So what is new in CFFI is that now, on Windows CFFI will try to\n  open a non-modal MessageBox (in addition to sending raw messages to\n  stderr).  The MessageBox is only visible if the process stays alive:\n  typically, console applications that crash close immediately, but that\n  is also the situation where stderr should be visible anyway.\n\n* Progress on support for `callbacks in NetBSD`__.\n\n* Functions returning booleans would in some case still return 0 or 1\n  instead of False or True.  Fixed.\n\n* `ffi.gc()`__ now takes an optional third parameter, which gives an\n  estimate of the size (in bytes) of the object.  So far, this is only\n  used by PyPy, to make the next GC occur more quickly (`issue #320`__).\n  In the future, this might have an effect on CPython too (provided\n  the CPython `issue 31105`__ is addressed).\n\n* Add a note to the documentation: the ABI mode gives function objects\n  that are *slower* to call than the API mode does.  For some reason it\n  is often thought to be faster.  It is not!\n\n.. __: https://bitbucket.org/cffi/cffi/issues/321/cffi-191-segmentation-fault-during-self\n.. __: ref.html#ffi-gc\n.. __: https://bitbucket.org/cffi/cffi/issues/320/improve-memory_pressure-management\n.. __: http://bugs.python.org/issue31105\n\n\nv1.10.1\n-------\n\n(only released inside PyPy 5.8.0)\n\n* Fixed the line numbers reported in case of ``cdef()`` errors.\n  Also, I just noticed, but pycparser always supported the preprocessor\n  directive ``# 42 \"foo.h\"`` to mean \"from the next line, we're in file\n  foo.h starting from line 42\", which it puts in the error messages.\n\n\nv1.10\n-----\n\n* Issue #295: use calloc() directly instead of\n  PyObject_Malloc()+memset() to handle ffi.new() with a default\n  allocator.  Speeds up ``ffi.new(large-array)`` where most of the time\n  you never touch most of the array.\n\n* Some OS/X build fixes (\"only with Xcode but without CLT\").\n\n* Improve a couple of error messages: when getting mismatched versions\n  of cffi and its backend; and when calling functions which cannot be\n  called with libffi because an argument is a struct that is \"too\n  complicated\" (and not a struct *pointer*, which always works).\n\n* Add support for some unusual compilers (non-msvc, non-gcc, non-icc,\n  non-clang)\n\n* Implemented the remaining cases for ``ffi.from_buffer``.  Now all\n  buffer/memoryview objects can be passed.  The one remaining check is\n  against passing unicode strings in Python 2.  (They support the buffer\n  interface, but that gives the raw bytes behind the UTF16/UCS4 storage,\n  which is most of the times not what you expect.  In Python 3 this has\n  been fixed and the unicode strings don't support the memoryview\n  interface any more.)\n\n* The C type ``_Bool`` or ``bool`` now converts to a Python boolean\n  when reading, instead of the content of the byte as an integer.  The\n  potential incompatibility here is what occurs if the byte contains a\n  value different from 0 and 1.  Previously, it would just return it;\n  with this change, CFFI raises an exception in this case.  But this\n  case means \"undefined behavior\" in C; if you really have to interface\n  with a library relying on this, don't use ``bool`` in the CFFI side.\n  Also, it is still valid to use a byte string as initializer for a\n  ``bool[]``, but now it must only contain ``\\x00`` or ``\\x01``.  As an\n  aside, ``ffi.string()`` no longer works on ``bool[]`` (but it never\n  made much sense, as this function stops at the first zero).\n\n* ``ffi.buffer`` is now the name of cffi's buffer type, and\n  ``ffi.buffer()`` works like before but is the constructor of that type.\n\n* ``ffi.addressof(lib, \"name\")``  now works also in in-line mode, not\n  only in out-of-line mode.  This is useful for taking the address of\n  global variables.\n\n* Issue #255: ``cdata`` objects of a primitive type (integers, floats,\n  char) are now compared and ordered by value.  For example, ``<cdata\n  'int' 42>`` compares equal to ``42`` and ``<cdata 'char' b'A'>``\n  compares equal to ``b'A'``.  Unlike C, ``<cdata 'int' -1>`` does not\n  compare equal to ``ffi.cast(\"unsigned int\", -1)``: it compares\n  smaller, because ``-1 < 4294967295``.\n\n* PyPy: ``ffi.new()`` and ``ffi.new_allocator()()`` did not record\n  \"memory pressure\", causing the GC to run too infrequently if you call\n  ``ffi.new()`` very often and/or with large arrays.  Fixed in PyPy 5.7.\n\n* Support in ``ffi.cdef()`` for numeric expressions with ``+`` or\n  ``-``.  Assumes that there is no overflow; it should be fixed first\n  before we add more general support for arbitrary arithmetic on\n  constants.\n\n\nv1.9\n----\n\n* Structs with variable-sized arrays as their last field: now we track\n  the length of the array after ``ffi.new()`` is called, just like we\n  always tracked the length of ``ffi.new(\"int[]\", 42)``.  This lets us\n  detect out-of-range accesses to array items.  This also lets us\n  display a better ``repr()``, and have the total size returned by\n  ``ffi.sizeof()`` and ``ffi.buffer()``.  Previously both functions\n  would return a result based on the size of the declared structure\n  type, with an assumed empty array.  (Thanks andrew for starting this\n  refactoring.)\n\n* Add support in ``cdef()/set_source()`` for unspecified-length arrays\n  in typedefs: ``typedef int foo_t[...];``.  It was already supported\n  for global variables or structure fields.\n\n* I turned in v1.8 a warning from ``cffi/model.py`` into an error:\n  ``'enum xxx' has no values explicitly defined: refusing to guess which\n  integer type it is meant to be (unsigned/signed, int/long)``.  Now I'm\n  turning it back to a warning again; it seems that guessing that the\n  enum has size ``int`` is a 99%-safe bet.  (But not 100%, so it stays\n  as a warning.)\n\n* Fix leaks in the code handling ``FILE *`` arguments.  In CPython 3\n  there is a remaining issue that is hard to fix: if you pass a Python\n  file object to a ``FILE *`` argument, then ``os.dup()`` is used and\n  the new file descriptor is only closed when the GC reclaims the Python\n  file object---and not at the earlier time when you call ``close()``,\n  which only closes the original file descriptor.  If this is an issue,\n  you should avoid this automatic convertion of Python file objects:\n  instead, explicitly manipulate file descriptors and call ``fdopen()``\n  from C (...via cffi).\n\n\nv1.8.3\n------\n\n* When passing a ``void *`` argument to a function with a different\n  pointer type, or vice-versa, the cast occurs automatically, like in C.\n  The same occurs for initialization with ``ffi.new()`` and a few other\n  places.  However, I thought that ``char *`` had the same\n  property---but I was mistaken.  In C you get the usual warning if you\n  try to give a ``char *`` to a ``char **`` argument, for example.\n  Sorry about the confusion.  This has been fixed in CFFI by giving for\n  now a warning, too.  It will turn into an error in a future version.\n\n\nv1.8.2\n------\n\n* Issue #283: fixed ``ffi.new()`` on structures/unions with nested\n  anonymous structures/unions, when there is at least one union in\n  the mix.  When initialized with a list or a dict, it should now\n  behave more closely like the ``{ }`` syntax does in GCC.\n\n\nv1.8.1\n------\n\n* CPython 3.x: experimental: the generated C extension modules now use\n  the \"limited API\", which means that, as a compiled .so/.dll, it should\n  work directly on any version of CPython >= 3.2.  The name produced by\n  distutils is still version-specific.  To get the version-independent\n  name, you can rename it manually to ``NAME.abi3.so``, or use the very\n  recent setuptools 26.\n\n* Added ``ffi.compile(debug=...)``, similar to ``python setup.py build\n  --debug`` but defaulting to True if we are running a debugging\n  version of Python itself.\n\n\nv1.8\n----\n\n* Removed the restriction that ``ffi.from_buffer()`` cannot be used on\n  byte strings.  Now you can get a ``char *`` out of a byte string,\n  which is valid as long as the string object is kept alive.  (But\n  don't use it to *modify* the string object!  If you need this, use\n  ``bytearray`` or other official techniques.)\n\n* PyPy 5.4 can now pass a byte string directly to a ``char *``\n  argument (in older versions, a copy would be made).  This used to be\n  a CPython-only optimization.\n\n\nv1.7\n----\n\n* ``ffi.gc(p, None)`` removes the destructor on an object previously\n  created by another call to ``ffi.gc()``\n\n* ``bool(ffi.cast(\"primitive type\", x))`` now returns False if the\n  value is zero (including ``-0.0``), and True otherwise.  Previously\n  this would only return False for cdata objects of a pointer type when\n  the pointer is NULL.\n\n* bytearrays: ``ffi.from_buffer(bytearray-object)`` is now supported.\n  (The reason it was not supported was that it was hard to do in PyPy,\n  but it works since PyPy 5.3.)  To call a C function with a ``char *``\n  argument from a buffer object---now including bytearrays---you write\n  ``lib.foo(ffi.from_buffer(x))``.  Additionally, this is now supported:\n  ``p[0:length] = bytearray-object``.  The problem with this was that a\n  iterating over bytearrays gives *numbers* instead of *characters*.\n  (Now it is implemented with just a memcpy, of course, not actually\n  iterating over the characters.)\n\n* C++: compiling the generated C code with C++ was supposed to work,\n  but failed if you make use the ``bool`` type (because that is rendered\n  as the C ``_Bool`` type, which doesn't exist in C++).\n\n* ``help(lib)`` and ``help(lib.myfunc)`` now give useful information,\n  as well as ``dir(p)`` where ``p`` is a struct or pointer-to-struct.\n\n\nv1.6\n----\n\n* `ffi.list_types()`_\n\n* `ffi.unpack()`_\n\n* `extern \"Python+C\"`_\n\n* in API mode, ``lib.foo.__doc__`` contains the C signature now.  On\n  CPython you can say ``help(lib.foo)``, but for some reason\n  ``help(lib)`` (or ``help(lib.foo)`` on PyPy) is still useless; I\n  haven't yet figured out the hacks needed to convince ``pydoc`` to\n  show more.  (You can use ``dir(lib)`` but it is not most helpful.)\n\n* Yet another attempt at robustness of ``ffi.def_extern()`` against\n  CPython's interpreter shutdown logic.\n\n.. _`ffi.list_types()`: ref.html#ffi-list-types\n.. _`ffi.unpack()`: ref.html#ffi-unpack\n.. _`extern \"Python+C\"`: using.html#extern-python-c\n\n\nv1.5.2\n------\n\n* Fix 1.5.1 for Python 2.6.\n\n\nv1.5.1\n------\n\n* A few installation-time tweaks (thanks Stefano!)\n\n* Issue #245: Win32: ``__stdcall`` was never generated for\n  ``extern \"Python\"`` functions\n\n* Issue #246: trying to be more robust against CPython's fragile\n  interpreter shutdown logic\n\n\nv1.5.0\n------\n\n* Support for `using CFFI for embedding`__.\n\n.. __: embedding.html\n\n\nv1.4.2\n------\n\nNothing changed from v1.4.1.\n\n\nv1.4.1\n------\n\n* Fix the compilation failure of cffi on CPython 3.5.0.  (3.5.1 works;\n  some detail changed that makes some underscore-starting macros\n  disappear from view of extension modules, and I worked around it,\n  thinking it changed in all 3.5 versions---but no: it was only in\n  3.5.1.)\n\n\nv1.4.0\n------\n\n* A `better way to do callbacks`__ has been added (faster and more\n  portable, and usually cleaner).  It is a mechanism for the\n  out-of-line API mode that replaces the dynamic creation of callback\n  objects (i.e. C functions that invoke Python) with the static\n  declaration in ``cdef()`` of which callbacks are needed.  This is\n  more C-like, in that you have to structure your code around the idea\n  that you get a fixed number of function pointers, instead of\n  creating them on-the-fly.\n\n* ``ffi.compile()`` now takes an optional ``verbose`` argument.  When\n  ``True``, distutils prints the calls to the compiler.\n\n* ``ffi.compile()`` used to fail if given ``sources`` with a path that\n  includes ``\"..\"``.  Fixed.\n\n* ``ffi.init_once()`` added.  See docs__.\n\n* ``dir(lib)`` now works on libs returned by ``ffi.dlopen()`` too.\n\n* Cleaned up and modernized the content of the ``demo`` subdirectory\n  in the sources (thanks matti!).\n\n* ``ffi.new_handle()`` is now guaranteed to return unique ``void *``\n  values, even if called twice on the same object.  Previously, in\n  that case, CPython would return two ``cdata`` objects with the same\n  ``void *`` value.  This change is useful to add and remove handles\n  from a global dict (or set) without worrying about duplicates.\n  It already used to work like that on PyPy.\n  *This change can break code that used to work on CPython by relying\n  on the object to be kept alive by other means than keeping the\n  result of ffi.new_handle() alive.*  (The corresponding `warning in\n  the docs`__ of ``ffi.new_handle()`` has been here since v0.8!)\n\n.. __: using.html#extern-python\n.. __: ref.html#ffi-init-once\n.. __: ref.html#ffi-new-handle\n\n\nv1.3.1\n------\n\n* The optional typedefs (``bool``, ``FILE`` and all Windows types) were\n  not always available from out-of-line FFI objects.\n\n* Opaque enums are phased out from the cdefs: they now give a warning,\n  instead of (possibly wrongly) being assumed equal to ``unsigned int``.\n  Please report if you get a reasonable use case for them.\n\n* Some parsing details, notably ``volatile`` is passed along like\n  ``const`` and ``restrict``.  Also, older versions of pycparser\n  mis-parse some pointer-to-pointer types like ``char * const *``: the\n  \"const\" ends up at the wrong place.  Added a workaround.\n\n\nv1.3.0\n------\n\n* Added `ffi.memmove()`_.\n\n* Pull request #64: out-of-line API mode: we can now declare\n  floating-point types with ``typedef float... foo_t;``.  This only\n  works if ``foo_t`` is a float or a double, not ``long double``.\n\n* Issue #217: fix possible unaligned pointer manipulation, which crashes\n  on some architectures (64-bit, non-x86).\n\n* Issues #64 and #126: when using ``set_source()`` or ``verify()``,\n  the ``const`` and ``restrict`` keywords are copied from the cdef\n  to the generated C code; this fixes warnings by the C compiler.\n  It also fixes corner cases like ``typedef const int T; T a;``\n  which would previously not consider ``a`` as a constant.  (The\n  cdata objects themselves are never ``const``.)\n\n* Win32: support for ``__stdcall``.  For callbacks and function\n  pointers; regular C functions still don't need to have their `calling\n  convention`_ declared.\n\n* Windows: CPython 2.7 distutils doesn't work with Microsoft's official\n  Visual Studio for Python, and I'm told this is `not a bug`__.  For\n  ffi.compile(), we `removed a workaround`__ that was inside cffi but\n  which had unwanted side-effects.  Try saying ``import setuptools``\n  first, which patches distutils...\n\n.. _`ffi.memmove()`: ref.html#ffi-memmove\n.. __: https://bugs.python.org/issue23246\n.. __: https://bitbucket.org/cffi/cffi/pull-requests/65/remove-_hack_at_distutils-which-imports/diff\n.. _`calling convention`: using.html#windows-calling-conventions\n\n\nv1.2.1\n------\n\nNothing changed from v1.2.0.\n\n\nv1.2.0\n------\n\n* Out-of-line mode: ``int a[][...];`` can be used to declare a structure\n  field or global variable which is, simultaneously, of total length\n  unknown to the C compiler (the ``a[]`` part) and each element is\n  itself an array of N integers, where the value of N *is* known to the\n  C compiler (the ``int`` and ``[...]`` parts around it).  Similarly,\n  ``int a[5][...];`` is supported (but probably less useful: remember\n  that in C it means ``int (a[5])[...];``).\n\n* PyPy: the ``lib.some_function`` objects were missing the attributes\n  ``__name__``, ``__module__`` and ``__doc__`` that are expected e.g. by\n  some decorators-management functions from ``functools``.\n\n* Out-of-line API mode: you can now do ``from _example.lib import x``\n  to import the name ``x`` from ``_example.lib``, even though the\n  ``lib`` object is not a standard module object.  (Also works in ``from\n  _example.lib import *``, but this is even more of a hack and will fail\n  if ``lib`` happens to declare a name called ``__all__``.  Note that\n  ``*`` excludes the global variables; only the functions and constants\n  make sense to import like this.)\n\n* ``lib.__dict__`` works again and gives you a copy of the\n  dict---assuming that ``lib`` has got no symbol called precisely\n  ``__dict__``.  (In general, it is safer to use ``dir(lib)``.)\n\n* Out-of-line API mode: global variables are now fetched on demand at\n  every access.  It fixes issue #212 (Windows DLL variables), and also\n  allows variables that are defined as dynamic macros (like ``errno``)\n  or ``__thread`` -local variables.  (This change might also tighten\n  the C compiler's check on the variables' type.)\n\n* Issue #209: dereferencing NULL pointers now raises RuntimeError\n  instead of segfaulting.  Meant as a debugging aid.  The check is\n  only for NULL: if you dereference random or dead pointers you might\n  still get segfaults.\n\n* Issue #152: callbacks__: added an argument ``ffi.callback(...,\n  onerror=...)``.  If the main callback function raises an exception\n  and ``onerror`` is provided, then ``onerror(exception, exc_value,\n  traceback)`` is called.  This is similar to writing a ``try:\n  except:`` in the main callback function, but in some cases (e.g. a\n  signal) an exception can occur at the very start of the callback\n  function---before it had time to enter the ``try: except:`` block.\n\n* Issue #115: added ``ffi.new_allocator()``, which officializes\n  support for `alternative allocators`__.\n\n.. __: using.html#callbacks\n.. __: ref.html#ffi-new-allocator\n\n\nv1.1.2\n------\n\n* ``ffi.gc()``: fixed a race condition in multithreaded programs\n  introduced in 1.1.1\n\n\nv1.1.1\n------\n\n* Out-of-line mode: ``ffi.string()``, ``ffi.buffer()`` and\n  ``ffi.getwinerror()`` didn't accept their arguments as keyword\n  arguments, unlike their in-line mode equivalent.  (It worked in PyPy.)\n\n* Out-of-line ABI mode: documented a restriction__ of ``ffi.dlopen()``\n  when compared to the in-line mode.\n\n* ``ffi.gc()``: when called several times with equal pointers, it was\n  accidentally registering only the last destructor, or even none at\n  all depending on details.  (It was correctly registering all of them\n  only in PyPy, and only with the out-of-line FFIs.)\n\n.. __: cdef.html#dlopen-note\n\n\nv1.1.0\n------\n\n* Out-of-line API mode: we can now declare integer types with\n  ``typedef int... foo_t;``.  The exact size and signedness of ``foo_t``\n  is figured out by the compiler.\n\n* Out-of-line API mode: we can now declare multidimensional arrays\n  (as fields or as globals) with ``int n[...][...]``.  Before, only the\n  outermost dimension would support the ``...`` syntax.\n\n* Out-of-line ABI mode: we now support any constant declaration,\n  instead of only integers whose value is given in the cdef.  Such \"new\"\n  constants, i.e. either non-integers or without a value given in the\n  cdef, must correspond to actual symbols in the lib.  At runtime they\n  are looked up the first time we access them.  This is useful if the\n  library defines ``extern const sometype somename;``.\n\n* ``ffi.addressof(lib, \"func_name\")`` now returns a regular cdata object\n  of type \"pointer to function\".  You can use it on any function from a\n  library in API mode (in ABI mode, all functions are already regular\n  cdata objects).  To support this, you need to recompile your cffi\n  modules.\n\n* Issue #198: in API mode, if you declare constants of a ``struct``\n  type, what you saw from lib.CONSTANT was corrupted.\n\n* Issue #196: ``ffi.set_source(\"package._ffi\", None)`` would\n  incorrectly generate the Python source to ``package._ffi.py`` instead\n  of ``package/_ffi.py``.  Also fixed: in some cases, if the C file was\n  in ``build/foo.c``, the .o file would be put in ``build/build/foo.o``.\n\n\nv1.0.3\n------\n\n* Same as 1.0.2, apart from doc and test fixes on some platforms.\n\n\nv1.0.2\n------\n\n* Variadic C functions (ending in a \"...\" argument) were not supported\n  in the out-of-line ABI mode.  This was a bug---there was even a\n  (non-working) example__ doing exactly that!\n\n.. __: overview.html#out-of-line-abi-level\n\n\nv1.0.1\n------\n\n* ``ffi.set_source()`` crashed if passed a ``sources=[..]`` argument.\n  Fixed by chrippa on pull request #60.\n\n* Issue #193: if we use a struct between the first cdef() where it is\n  declared and another cdef() where its fields are defined, then this\n  definition was ignored.\n\n* Enums were buggy if you used too many \"...\" in their definition.\n\n\nv1.0.0\n------\n\n* The main news item is out-of-line module generation:\n\n  * `for ABI level`_, with ``ffi.dlopen()``\n\n  * `for API level`_, which used to be with ``ffi.verify()``, now deprecated\n\n* (this page will list what is new from all versions from 1.0.0\n  forward.)\n\n.. _`for ABI level`: overview.html#out-of-line-abi-level\n.. _`for API level`: overview.html#out-of-line-api-level\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.13.0-jlicqgsrlask3n7tsdckxmdwv6d5zp4o/spack-src/doc/source/using.rst": "================================\nUsing the ffi/lib objects\n================================\n\n.. contents::\n\nKeep this page under your pillow.\n\n\n.. _working:\n\nWorking with pointers, structures and arrays\n--------------------------------------------\n\nThe C code's integers and floating-point values are mapped to Python's\nregular ``int``, ``long`` and ``float``.  Moreover, the C type ``char``\ncorresponds to single-character strings in Python.  (If you want it to\nmap to small integers, use either ``signed char`` or ``unsigned char``.)\n\nSimilarly, the C type ``wchar_t`` corresponds to single-character\nunicode strings.  Note that in some situations (a narrow Python build\nwith an underlying 4-bytes wchar_t type), a single wchar_t character\nmay correspond to a pair of surrogates, which is represented as a\nunicode string of length 2.  If you need to convert such a 2-chars\nunicode string to an integer, ``ord(x)`` does not work; use instead\n``int(ffi.cast('wchar_t', x))``.\n\n*New in version 1.11:* in addition to ``wchar_t``, the C types\n``char16_t`` and ``char32_t`` work the same but with a known fixed size.\nIn previous versions, this could be achieved using ``uint16_t`` and\n``int32_t`` but without automatic conversion to Python unicodes.\n\nPointers, structures and arrays are more complex: they don't have an\nobvious Python equivalent.  Thus, they correspond to objects of type\n``cdata``, which are printed for example as\n``<cdata 'struct foo_s *' 0xa3290d8>``.\n\n``ffi.new(ctype, [initializer])``: this function builds and returns a\nnew cdata object of the given ``ctype``.  The ctype is usually some\nconstant string describing the C type.  It must be a pointer or array\ntype.  If it is a pointer, e.g. ``\"int *\"`` or ``struct foo *``, then\nit allocates the memory for one ``int`` or ``struct foo``.  If it is\nan array, e.g. ``int[10]``, then it allocates the memory for ten\n``int``.  In both cases the returned cdata is of type ``ctype``.\n\nThe memory is initially filled with zeros.  An initializer can be given\ntoo, as described later.\n\nExample::\n\n    >>> ffi.new(\"int *\")\n    <cdata 'int *' owning 4 bytes>\n    >>> ffi.new(\"int[10]\")\n    <cdata 'int[10]' owning 40 bytes>\n\n    >>> ffi.new(\"char *\")          # allocates only one char---not a C string!\n    <cdata 'char *' owning 1 bytes>\n    >>> ffi.new(\"char[]\", \"foobar\")  # this allocates a C string, ending in \\0\n    <cdata 'char[]' owning 7 bytes>\n\nUnlike C, the returned pointer object has *ownership* on the allocated\nmemory: when this exact object is garbage-collected, then the memory is\nfreed.  If, at the level of C, you store a pointer to the memory\nsomewhere else, then make sure you also keep the object alive for as\nlong as needed.  (This also applies if you immediately cast the returned\npointer to a pointer of a different type: only the original object has\nownership, so you must keep it alive.  As soon as you forget it, then\nthe casted pointer will point to garbage!  In other words, the ownership\nrules are attached to the *wrapper* cdata objects: they are not, and\ncannot, be attached to the underlying raw memory.)  Example:\n\n.. code-block:: python\n\n    global_weakkeydict = weakref.WeakKeyDictionary()\n\n    def make_foo():\n        s1   = ffi.new(\"struct foo *\")\n        fld1 = ffi.new(\"struct bar *\")\n        fld2 = ffi.new(\"struct bar *\")\n        s1.thefield1 = fld1\n        s1.thefield2 = fld2\n        # here the 'fld1' and 'fld2' object must not go away,\n        # otherwise 's1.thefield1/2' will point to garbage!\n        global_weakkeydict[s1] = (fld1, fld2)\n        # now 's1' keeps alive 'fld1' and 'fld2'.  When 's1' goes\n        # away, then the weak dictionary entry will be removed.\n        return s1\n\nUsually you don't need a weak dict: for example, to call a function with\na ``char * *`` argument that contains a pointer to a ``char *`` pointer,\nit is enough to do this:\n\n.. code-block:: python\n\n    p = ffi.new(\"char[]\", \"hello, world\")    # p is a 'char *'\n    q = ffi.new(\"char **\", p)                # q is a 'char **'\n    lib.myfunction(q)\n    # p is alive at least until here, so that's fine\n\nHowever, this is always wrong (usage of freed memory):\n\n.. code-block:: python\n\n    p = ffi.new(\"char **\", ffi.new(\"char[]\", \"hello, world\"))\n    # WRONG!  as soon as p is built, the inner ffi.new() gets freed!\n\nThis is wrong too, for the same reason:\n\n.. code-block:: python\n\n    p = ffi.new(\"struct my_stuff\")\n    p.foo = ffi.new(\"char[]\", \"hello, world\")\n    # WRONG!  as soon as p.foo is set, the ffi.new() gets freed!\n\n\nThe cdata objects support mostly the same operations as in C: you can\nread or write from pointers, arrays and structures.  Dereferencing a\npointer is done usually in C with the syntax ``*p``, which is not valid\nPython, so instead you have to use the alternative syntax ``p[0]``\n(which is also valid C).  Additionally, the ``p.x`` and ``p->x``\nsyntaxes in C both become ``p.x`` in Python.\n\nWe have ``ffi.NULL`` to use in the same places as the C ``NULL``.\nLike the latter, it is actually defined to be ``ffi.cast(\"void *\",\n0)``.  For example, reading a NULL pointer returns a ``<cdata 'type *'\nNULL>``, which you can check for e.g. by comparing it with\n``ffi.NULL``.\n\nThere is no general equivalent to the ``&`` operator in C (because it\nwould not fit nicely in the model, and it does not seem to be needed\nhere).  There is `ffi.addressof()`__, but only for some cases.  You\ncannot take the \"address\" of a number in Python, for example; similarly,\nyou cannot take the address of a CFFI pointer.  If you have this kind\nof C code::\n\n    int x, y;\n    fetch_size(&x, &y);\n\n    opaque_t *handle;      // some opaque pointer\n    init_stuff(&handle);   // initializes the variable 'handle'\n    more_stuff(handle);    // pass the handle around to more functions\n\nthen you need to rewrite it like this, replacing the variables in C\nwith what is logically pointers to the variables:\n\n.. code-block:: python\n\n    px = ffi.new(\"int *\")\n    py = ffi.new(\"int *\")              arr = ffi.new(\"int[2]\")\n    lib.fetch_size(px, py)    -OR-     lib.fetch_size(arr, arr + 1)\n    x = px[0]                          x = arr[0]\n    y = py[0]                          y = arr[1]\n\n    p_handle = ffi.new(\"opaque_t **\")\n    lib.init_stuff(p_handle)   # pass the pointer to the 'handle' pointer\n    handle = p_handle[0]       # now we can read 'handle' out of 'p_handle'\n    lib.more_stuff(handle)\n\n.. __: ref.html#ffi-addressof\n\n\nAny operation that would in C return a pointer or array or struct type\ngives you a fresh cdata object.  Unlike the \"original\" one, these fresh\ncdata objects don't have ownership: they are merely references to\nexisting memory.\n\nAs an exception to the above rule, dereferencing a pointer that owns a\n*struct* or *union* object returns a cdata struct or union object\nthat \"co-owns\" the same memory.  Thus in this case there are two\nobjects that can keep the same memory alive.  This is done for cases where\nyou really want to have a struct object but don't have any convenient\nplace to keep alive the original pointer object (returned by\n``ffi.new()``).\n\nExample:\n\n.. code-block:: python\n\n    # void somefunction(int *);\n\n    x = ffi.new(\"int *\")      # allocate one int, and return a pointer to it\n    x[0] = 42                 # fill it\n    lib.somefunction(x)       # call the C function\n    print x[0]                # read the possibly-changed value\n\nThe equivalent of C casts are provided with ``ffi.cast(\"type\", value)``.\nThey should work in the same cases as they do in C.  Additionally, this\nis the only way to get cdata objects of integer or floating-point type::\n\n    >>> x = ffi.cast(\"int\", 42)\n    >>> x\n    <cdata 'int' 42>\n    >>> int(x)\n    42\n\nTo cast a pointer to an int, cast it to ``intptr_t`` or ``uintptr_t``,\nwhich are defined by C to be large enough integer types (example on 32\nbits)::\n\n    >>> int(ffi.cast(\"intptr_t\", pointer_cdata))    # signed\n    -1340782304\n    >>> int(ffi.cast(\"uintptr_t\", pointer_cdata))   # unsigned\n    2954184992L\n\nThe initializer given as the optional second argument to ``ffi.new()``\ncan be mostly anything that you would use as an initializer for C code,\nwith lists or tuples instead of using the C syntax ``{ .., .., .. }``.\nExample::\n\n    typedef struct { int x, y; } foo_t;\n\n    foo_t v = { 1, 2 };            // C syntax\n    v = ffi.new(\"foo_t *\", [1, 2]) # CFFI equivalent\n\n    foo_t v = { .y=1, .x=2 };                // C99 syntax\n    v = ffi.new(\"foo_t *\", {'y': 1, 'x': 2}) # CFFI equivalent\n\nLike C, arrays of chars can also be initialized from a string, in\nwhich case a terminating null character is appended implicitly::\n\n    >>> x = ffi.new(\"char[]\", \"hello\")\n    >>> x\n    <cdata 'char[]' owning 6 bytes>\n    >>> len(x)        # the actual size of the array\n    6\n    >>> x[5]          # the last item in the array\n    '\\x00'\n    >>> x[0] = 'H'    # change the first item\n    >>> ffi.string(x) # interpret 'x' as a regular null-terminated string\n    'Hello'\n\nSimilarly, arrays of wchar_t or char16_t or char32_t can be initialized\nfrom a unicode string,\nand calling ``ffi.string()`` on the cdata object returns the current unicode\nstring stored in the source array (adding surrogates if necessary).\nSee the `Unicode character types`__ section for more details.\n\n.. __: ref.html#unichar\n\nNote that unlike Python lists or tuples, but like C, you *cannot* index in\na C array from the end using negative numbers.\n\nMore generally, the C array types can have their length unspecified in C\ntypes, as long as their length can be derived from the initializer, like\nin C::\n\n    int array[] = { 1, 2, 3, 4 };           // C syntax\n    array = ffi.new(\"int[]\", [1, 2, 3, 4])  # CFFI equivalent\n\nAs an extension, the initializer can also be just a number, giving\nthe length (in case you just want zero-initialization)::\n\n    int array[1000];                  // C syntax\n    array = ffi.new(\"int[1000]\")      # CFFI 1st equivalent\n    array = ffi.new(\"int[]\", 1000)    # CFFI 2nd equivalent\n\nThis is useful if the length is not actually a constant, to avoid things\nlike ``ffi.new(\"int[%d]\" % x)``.  Indeed, this is not recommended:\n``ffi`` normally caches the string ``\"int[]\"`` to not need to re-parse\nit all the time.\n\nThe C99 variable-sized structures are supported too, as long as the\ninitializer says how long the array should be:\n\n.. code-block:: python\n\n    # typedef struct { int x; int y[]; } foo_t;\n\n    p = ffi.new(\"foo_t *\", [5, [6, 7, 8]]) # length 3\n    p = ffi.new(\"foo_t *\", [5, 3])         # length 3 with 0 in the array\n    p = ffi.new(\"foo_t *\", {'y': 3})       # length 3 with 0 everywhere\n\nFinally, note that any Python object used as initializer can also be\nused directly without ``ffi.new()`` in assignments to array items or\nstruct fields.  In fact, ``p = ffi.new(\"T*\", initializer)`` is\nequivalent to ``p = ffi.new(\"T*\"); p[0] = initializer``.  Examples:\n\n.. code-block:: python\n\n    # if 'p' is a <cdata 'int[5][5]'>\n    p[2] = [10, 20]             # writes to p[2][0] and p[2][1]\n\n    # if 'p' is a <cdata 'foo_t *'>, and foo_t has fields x, y and z\n    p[0] = {'x': 10, 'z': 20}   # writes to p.x and p.z; p.y unmodified\n\n    # if, on the other hand, foo_t has a field 'char a[5]':\n    p.a = \"abc\"                 # writes 'a', 'b', 'c' and '\\0'; p.a[4] unmodified\n\nIn function calls, when passing arguments, these rules can be used too;\nsee `Function calls`_.\n\n\nPython 3 support\n----------------\n\nPython 3 is supported, but the main point to note is that the ``char`` C\ntype corresponds to the ``bytes`` Python type, and not ``str``.  It is\nyour responsibility to encode/decode all Python strings to bytes when\npassing them to or receiving them from CFFI.\n\nThis only concerns the ``char`` type and derivative types; other parts\nof the API that accept strings in Python 2 continue to accept strings in\nPython 3.\n\n\nAn example of calling a main-like thing\n---------------------------------------\n\nImagine we have something like this:\n\n.. code-block:: python\n\n   from cffi import FFI\n   ffi = FFI()\n   ffi.cdef(\"\"\"\n      int main_like(int argv, char *argv[]);\n   \"\"\")\n   lib = ffi.dlopen(\"some_library.so\")\n\nNow, everything is simple, except, how do we create the ``char**`` argument\nhere?\nThe first idea:\n\n.. code-block:: python\n\n   lib.main_like(2, [\"arg0\", \"arg1\"])\n\ndoes not work, because the initializer receives two Python ``str`` objects\nwhere it was expecting ``<cdata 'char *'>`` objects.  You need to use\n``ffi.new()`` explicitly to make these objects:\n\n.. code-block:: python\n\n   lib.main_like(2, [ffi.new(\"char[]\", \"arg0\"),\n                     ffi.new(\"char[]\", \"arg1\")])\n\nNote that the two ``<cdata 'char[]'>`` objects are kept alive for the\nduration of the call: they are only freed when the list itself is freed,\nand the list is only freed when the call returns.\n\nIf you want instead to build an \"argv\" variable that you want to reuse,\nthen more care is needed:\n\n.. code-block:: python\n\n   # DOES NOT WORK!\n   argv = ffi.new(\"char *[]\", [ffi.new(\"char[]\", \"arg0\"),\n                               ffi.new(\"char[]\", \"arg1\")])\n\nIn the above example, the inner \"arg0\" string is deallocated as soon\nas \"argv\" is built.  You have to make sure that you keep a reference\nto the inner \"char[]\" objects, either directly or by keeping the list\nalive like this:\n\n.. code-block:: python\n\n   argv_keepalive = [ffi.new(\"char[]\", \"arg0\"),\n                     ffi.new(\"char[]\", \"arg1\")]\n   argv = ffi.new(\"char *[]\", argv_keepalive)\n\n\nFunction calls\n--------------\n\nWhen calling C functions, passing arguments follows mostly the same\nrules as assigning to structure fields, and the return value follows the\nsame rules as reading a structure field.  For example:\n\n.. code-block:: python\n\n    # int foo(short a, int b);\n\n    n = lib.foo(2, 3)     # returns a normal integer\n    lib.foo(40000, 3)     # raises OverflowError\n\nYou can pass to ``char *`` arguments a normal Python string (but don't\npass a normal Python string to functions that take a ``char *``\nargument and may mutate it!):\n\n.. code-block:: python\n\n    # size_t strlen(const char *);\n\n    assert lib.strlen(\"hello\") == 5\n\nYou can also pass unicode strings as ``wchar_t *`` or ``char16_t *`` or\n``char32_t *`` arguments.  Note that\nthe C language makes no difference between argument declarations that\nuse ``type *`` or ``type[]``.  For example, ``int *`` is fully\nequivalent to ``int[]`` (or even ``int[5]``; the 5 is ignored).  For CFFI,\nthis means that you can always pass arguments that can be converted to\neither ``int *`` or ``int[]``.  For example:\n\n.. code-block:: python\n\n    # void do_something_with_array(int *array);\n\n    lib.do_something_with_array([1, 2, 3, 4, 5])    # works for int[]\n\nSee `Reference: conversions`__ for a similar way to pass ``struct foo_s\n*`` arguments---but in general, it is clearer in this case to pass\n``ffi.new('struct foo_s *', initializer)``.\n\n__ ref.html#conversions\n\nCFFI supports passing and returning structs and unions to functions and\ncallbacks.  Example:\n\n.. code-block:: python\n\n    # struct foo_s { int a, b; };\n    # struct foo_s function_returning_a_struct(void);\n\n    myfoo = lib.function_returning_a_struct()\n    # `myfoo`: <cdata 'struct foo_s' owning 8 bytes>\n\nFor performance, non-variadic API-level functions that you get by\nwriting ``lib.some_function`` are not ``<cdata>``\nobjects, but an object of a different type (on CPython, ``<built-in\nfunction>``).  This means you cannot pass them directly to some other C\nfunction expecting a function pointer argument.  Only ``ffi.typeof()``\nworks on them.  To get a cdata containing a regular function pointer,\nuse ``ffi.addressof(lib, \"name\")``.\n\nThere are a few (obscure) limitations to the supported argument and\nreturn types.  These limitations come from libffi and apply only to\ncalling ``<cdata>`` function pointers; in other words, they don't\napply to non-variadic ``cdef()``-declared functions if you are using\nthe API mode.  The limitations are that you cannot pass directly as\nargument or return type:\n\n* a union (but a *pointer* to a union is fine);\n\n* a struct which uses bitfields (but a *pointer* to such a struct is\n  fine);\n\n* a struct that was declared with \"``...``\" in the ``cdef()``.\n\nIn API mode, you can work around these limitations: for example, if you\nneed to call such a function pointer from Python, you can instead write\na custom C function that accepts the function pointer and the real\narguments and that does the call from C.  Then declare that custom C\nfunction in the ``cdef()`` and use it from Python.\n\n\nVariadic function calls\n-----------------------\n\nVariadic functions in C (which end with \"``...``\" as their last\nargument) can be declared and called normally, with the exception that\nall the arguments passed in the variable part *must* be cdata objects.\nThis is because it would not be possible to guess, if you wrote this::\n\n    lib.printf(\"hello, %d\\n\", 42)   # doesn't work!\n\nthat you really meant the 42 to be passed as a C ``int``, and not a\n``long`` or ``long long``.  The same issue occurs with ``float`` versus\n``double``.  So you have to force cdata objects of the C type you want,\nif necessary with ``ffi.cast()``:\n\n.. code-block:: python\n  \n    lib.printf(\"hello, %d\\n\", ffi.cast(\"int\", 42))\n    lib.printf(\"hello, %ld\\n\", ffi.cast(\"long\", 42))\n    lib.printf(\"hello, %f\\n\", ffi.cast(\"double\", 42))\n\nBut of course:\n\n.. code-block:: python\n\n    lib.printf(\"hello, %s\\n\", ffi.new(\"char[]\", \"world\"))\n\nNote that if you are using ``dlopen()``, the function declaration in the\n``cdef()`` must match the original one in C exactly, as usual --- in\nparticular, if this function is variadic in C, then its ``cdef()``\ndeclaration must also be variadic.  You cannot declare it in the\n``cdef()`` with fixed arguments instead, even if you plan to only call\nit with these argument types.  The reason is that some architectures\nhave a different calling convention depending on whether the function\nsignature is fixed or not.  (On x86-64, the difference can sometimes be\nseen in PyPy's JIT-generated code if some arguments are ``double``.)\n\nNote that the function signature ``int foo();`` is interpreted by CFFI\nas equivalent to ``int foo(void);``.  This differs from the C standard,\nin which ``int foo();`` is really like ``int foo(...);`` and can be\ncalled with any arguments.  (This feature of C is a pre-C89 relic: the\narguments cannot be accessed at all in the body of ``foo()`` without\nrelying on compiler-specific extensions.  Nowadays virtually all code\nwith ``int foo();`` really means ``int foo(void);``.)\n\n\nMemory pressure (PyPy)\n----------------------\n\nThis paragraph applies only to PyPy, because its garbage collector (GC)\nis different from CPython's.  It is very common in C code to have pairs\nof functions, one which performs memory allocations or acquires other\nresources, and the other which frees them again.  Depending on how you\nstructure your Python code, the freeing function is only called when the\nGC decides a particular (Python) object can be freed.  This occurs\nnotably in these cases:\n\n* If you use a ``__del__()`` method to call the freeing function.\n\n* If you use ``ffi.gc()`` without also using ``ffi.release()``.\n\n* This does not occur if you call the freeing function at a\n  deterministic time, like in a regular ``try: finally:`` block.  It\n  does however occur *inside a generator---* if the generator is not\n  explicitly exhausted but forgotten at a ``yield`` point, then the code\n  in the enclosing ``finally`` block is only invoked at the next GC.\n\nIn these cases, you may have to use the built-in function\n``__pypy__.add_memory_pressure(n)``.  Its argument ``n`` is an estimate\nof how much memory pressure to add.  For example, if the pair of C\nfunctions that we are talking about is ``malloc(n)`` and ``free()`` or\nsimilar, you would call ``__pypy__.add_memory_pressure(n)`` after\n``malloc(n)``.  Doing so is not always a complete answer to the problem,\nbut it makes the next GC occur earlier, which is often enough.\n\nThe same applies if the memory allocations are indirect, e.g. the C\nfunction allocates some internal data structures.  In that case, call\n``__pypy__.add_memory_pressure(n)`` with an argument ``n`` that is an\nrough estimation.  Knowing the exact size is not important, and memory\npressure doesn't have to be manually brought down again after calling\nthe freeing function.  If you are writing wrappers for the allocating /\nfreeing pair of functions, you should probably call\n``__pypy__.add_memory_pressure()`` in the former even if the user may\ninvoke the latter at a known point with a ``finally:`` block.\n\nIn case this solution is not sufficient, or if the acquired resource is\nnot memory but something else more limited (like file descriptors), then\nthere is no better way than restructuring your code to make sure the\nfreeing function is called at a known point and not indirectly by the\nGC.\n\nNote that in PyPy <= 5.6 the discussion above also applies to\n``ffi.new()``.  In more recent versions of PyPy, both ``ffi.new()`` and\n``ffi.new_allocator()()`` automatically account for the memory pressure\nthey create.  (In case you need to support both older and newer PyPy's,\ntry calling ``__pypy__.add_memory_pressure()`` anyway; it is better to\noverestimate than not account for the memory pressure.)\n\n\n.. _extern-python:\n.. _`extern \"Python\"`:\n\nExtern \"Python\" (new-style callbacks)\n-------------------------------------\n\nWhen the C code needs a pointer to a function which invokes back a\nPython function of your choice, here is how you do it in the\nout-of-line API mode.  The next section about Callbacks_ describes the\nABI-mode solution.\n\nThis is *new in version 1.4.*  Use old-style Callbacks_ if backward\ncompatibility is an issue.  (The original callbacks are slower to\ninvoke and have the same issue as libffi's callbacks; notably, see the\nwarning__.  The new style described in the present section does not\nuse libffi's callbacks at all.)\n\n.. __: Callbacks_\n\nIn the builder script, declare in the cdef a function prefixed with\n``extern \"Python\"``::\n\n    ffibuilder.cdef(\"\"\"\n        extern \"Python\" int my_callback(int, int);\n\n        void library_function(int(*callback)(int, int));\n    \"\"\")\n    ffibuilder.set_source(\"_my_example\", r\"\"\"\n        #include <some_library.h>\n    \"\"\")\n\nThe function ``my_callback()`` is then implemented in Python inside\nyour application's code::\n\n    from _my_example import ffi, lib\n\n    @ffi.def_extern()\n    def my_callback(x, y):\n        return 42\n\nYou obtain a ``<cdata>`` pointer-to-function object by getting\n``lib.my_callback``.  This ``<cdata>`` can be passed to C code and\nthen works like a callback: when the C code calls this function\npointer, the Python function ``my_callback`` is called.  (You need\nto pass ``lib.my_callback`` to C code, and not ``my_callback``: the\nlatter is just the Python function above, which cannot be passed to C.)\n\nCFFI implements this by defining ``my_callback`` as a static C\nfunction, written after the ``set_source()`` code.  The ``<cdata>``\nthen points to this function.  What this function does is invoke the\nPython function object that is, at runtime, attached with\n``@ffi.def_extern()``.\n\nThe ``@ffi.def_extern()`` decorator should be applied to **global\nfunctions,** one for each ``extern \"Python\"`` function of the same\nname.\n\nTo support some corner cases, it is possible to redefine the attached\nPython function by calling ``@ffi.def_extern()`` again for the same\nname---but this is not recommended!  Better attach a single global\nPython function for this name, and write it more flexibly in the first\nplace.  This is because each ``extern \"Python\"`` function turns into\nonly one C function.  Calling ``@ffi.def_extern()`` again changes this\nfunction's C logic to call the new Python function; the old Python\nfunction is not callable any more.  The C function pointer you get\nfrom ``lib.my_function`` is always this C function's address, i.e. it\nremains the same.\n\nExtern \"Python\" and ``void *`` arguments\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nAs described just before, you cannot use ``extern \"Python\"`` to make a\nvariable number of C function pointers.  However, achieving that\nresult is not possible in pure C code either.  For this reason, it is\nusual for C to define callbacks with a ``void *data`` argument.  You\ncan use ``ffi.new_handle()`` and ``ffi.from_handle()`` to pass a\nPython object through this ``void *`` argument.  For example, if the C\ntype of the callbacks is::\n\n    typedef void (*event_cb_t)(event_t *evt, void *userdata);\n\nand you register events by calling this function::\n\n    void event_cb_register(event_cb_t cb, void *userdata);\n\nThen you would write this in the build script::\n\n    ffibuilder.cdef(\"\"\"\n        typedef ... event_t;\n        typedef void (*event_cb_t)(event_t *evt, void *userdata);\n        void event_cb_register(event_cb_t cb, void *userdata);\n\n        extern \"Python\" void my_event_callback(event_t *, void *);\n    \"\"\")\n    ffibuilder.set_source(\"_demo_cffi\", r\"\"\"\n        #include <the_event_library.h>\n    \"\"\")\n\nand in your main application you register events like this::\n\n    from _demo_cffi import ffi, lib\n\n    class Widget(object):\n        def __init__(self):\n            userdata = ffi.new_handle(self)\n            self._userdata = userdata     # must keep this alive!\n            lib.event_cb_register(lib.my_event_callback, userdata)\n\n        def process_event(self, evt):\n            print \"got event!\"\n\n    @ffi.def_extern()\n    def my_event_callback(evt, userdata):\n        widget = ffi.from_handle(userdata)\n        widget.process_event(evt)\n\nSome other libraries don't have an explicit ``void *`` argument, but\nlet you attach the ``void *`` to an existing structure.  For example,\nthe library might say that ``widget->userdata`` is a generic field\nreserved for the application.  If the event's signature is now this::\n\n    typedef void (*event_cb_t)(widget_t *w, event_t *evt);\n\nThen you can use the ``void *`` field in the low-level\n``widget_t *`` like this::\n\n    from _demo_cffi import ffi, lib\n\n    class Widget(object):\n        def __init__(self):\n            ll_widget = lib.new_widget(500, 500)\n            self.ll_widget = ll_widget       # <cdata 'struct widget *'>\n            userdata = ffi.new_handle(self)\n            self._userdata = userdata        # must still keep this alive!\n            ll_widget.userdata = userdata    # this makes a copy of the \"void *\"\n            lib.event_cb_register(ll_widget, lib.my_event_callback)\n\n        def process_event(self, evt):\n            print \"got event!\"\n\n    @ffi.def_extern()\n    def my_event_callback(ll_widget, evt):\n        widget = ffi.from_handle(ll_widget.userdata)\n        widget.process_event(evt)\n\nExtern \"Python\" accessed from C directly\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIn case you want to access some ``extern \"Python\"`` function directly\nfrom the C code written in ``set_source()``, you need to write a\nforward declaration.  (By default it needs to be static, but see\n`next paragraph`__.)  The real implementation of this function\nis added by CFFI *after* the C code---this is needed because the\ndeclaration might use types defined by ``set_source()``\n(e.g. ``event_t`` above, from the ``#include``), so it cannot be\ngenerated before.\n\n.. __: `extern-python-c`_\n\n::\n\n    ffibuilder.set_source(\"_demo_cffi\", r\"\"\"\n        #include <the_event_library.h>\n\n        static void my_event_callback(widget_t *, event_t *);\n\n        /* here you can write C code which uses '&my_event_callback' */\n    \"\"\")\n\nThis can also be used to write custom C code which calls Python\ndirectly.  Here is an example (inefficient in this case, but might be\nuseful if the logic in ``my_algo()`` is much more complex)::\n\n    ffibuilder.cdef(\"\"\"\n        extern \"Python\" int f(int);\n        int my_algo(int);\n    \"\"\")\n    ffibuilder.set_source(\"_example_cffi\", r\"\"\"\n        static int f(int);   /* the forward declaration */\n\n        static int my_algo(int n) {\n            int i, sum = 0;\n            for (i = 0; i < n; i++)\n                sum += f(i);     /* call f() here */\n            return sum;\n        }\n    \"\"\")\n\n.. _extern-python-c:\n\nExtern \"Python+C\"\n~~~~~~~~~~~~~~~~~\n\nFunctions declared with ``extern \"Python\"`` are generated as\n``static`` functions in the C source.  However, in some cases it is\nconvenient to make them non-static, typically when you want to make\nthem directly callable from other C source files.  To do that, you can\nsay ``extern \"Python+C\"`` instead of just ``extern \"Python\"``.  *New\nin version 1.6.*\n\n+------------------------------------+--------------------------------------+\n| if the cdef contains               | then CFFI generates                  |\n+------------------------------------+--------------------------------------+\n| ``extern \"Python\" int f(int);``    | ``static int f(int) { /* code */ }`` |\n+------------------------------------+--------------------------------------+\n| ``extern \"Python+C\" int f(int);``  | ``int f(int) { /* code */ }``        |\n+------------------------------------+--------------------------------------+\n\nThe name ``extern \"Python+C\"`` comes from the fact that we want an\nextern function in both senses: as an ``extern \"Python\"``, and as a\nC function that is not static.\n\nYou cannot make CFFI generate additional macros or other\ncompiler-specific stuff like the GCC ``__attribute__``.  You can only\ncontrol whether the function should be ``static`` or not.  But often,\nthese attributes must be written alongside the function *header*, and\nit is fine if the function *implementation* does not repeat them::\n\n    ffibuilder.cdef(\"\"\"\n        extern \"Python+C\" int f(int);      /* not static */\n    \"\"\")\n    ffibuilder.set_source(\"_example_cffi\", r\"\"\"\n        /* the forward declaration, setting a gcc attribute\n           (this line could also be in some .h file, to be included\n           both here and in the other C files of the project) */\n        int f(int) __attribute__((visibility(\"hidden\")));\n    \"\"\")\n\n\nExtern \"Python\": reference\n~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n``extern \"Python\"`` must appear in the cdef().  Like the C++ ``extern\n\"C\"`` syntax, it can also be used with braces around a group of\nfunctions::\n\n    extern \"Python\" {\n        int foo(int);\n        int bar(int);\n    }\n\nThe ``extern \"Python\"`` functions cannot be variadic for now.  This\nmay be implemented in the future.  (`This demo`__ shows how to do it\nanyway, but it is a bit lengthy.)\n\n.. __: https://bitbucket.org/cffi/cffi/src/default/demo/extern_python_varargs.py\n\nEach corresponding Python callback function is defined with the\n``@ffi.def_extern()`` decorator.  Be careful when writing this\nfunction: if it raises an exception, or tries to return an object of\nthe wrong type, then the exception cannot be propagated.  Instead, the\nexception is printed to stderr and the C-level callback is made to\nreturn a default value.  This can be controlled with ``error`` and\n``onerror``, described below.\n\n.. _def-extern:\n\nThe ``@ffi.def_extern()`` decorator takes these optional arguments:\n\n* ``name``: the name of the function as written in the cdef.  By default\n  it is taken from the name of the Python function you decorate.\n\n.. _error_onerror:\n\n* ``error``: the returned value in case the Python function raises an\n  exception.  It is 0 or null by default.  The exception is still\n  printed to stderr, so this should be used only as a last-resort\n  solution.\n\n* ``onerror``: if you want to be sure to catch all exceptions, use\n  ``@ffi.def_extern(onerror=my_handler)``.  If an exception occurs and\n  ``onerror`` is specified, then ``onerror(exception, exc_value,\n  traceback)`` is called.  This is useful in some situations where you\n  cannot simply write ``try: except:`` in the main callback function,\n  because it might not catch exceptions raised by signal handlers: if\n  a signal occurs while in C, the Python signal handler is called as\n  soon as possible, which is after entering the callback function but\n  *before* executing even the ``try:``.  If the signal handler raises,\n  we are not in the ``try: except:`` yet.\n\n  If ``onerror`` is called and returns normally, then it is assumed\n  that it handled the exception on its own and nothing is printed to\n  stderr.  If ``onerror`` raises, then both tracebacks are printed.\n  Finally, ``onerror`` can itself provide the result value of the\n  callback in C, but doesn't have to: if it simply returns None---or\n  if ``onerror`` itself fails---then the value of ``error`` will be\n  used, if any.\n\n  Note the following hack: in ``onerror``, you can access the original\n  callback arguments as follows.  First check if ``traceback`` is not\n  None (it is None e.g. if the whole function ran successfully but\n  there was an error converting the value returned: this occurs after\n  the call).  If ``traceback`` is not None, then\n  ``traceback.tb_frame`` is the frame of the outermost function,\n  i.e. directly the frame of the function decorated with\n  ``@ffi.def_extern()``.  So you can get the value of ``argname`` in\n  that frame by reading ``traceback.tb_frame.f_locals['argname']``.\n\n\n.. _Callbacks:\n\nCallbacks (old style)\n---------------------\n\nHere is how to make a new ``<cdata>`` object that contains a pointer\nto a function, where that function invokes back a Python function of\nyour choice::\n\n    >>> @ffi.callback(\"int(int, int)\")\n    >>> def myfunc(x, y):\n    ...    return x + y\n    ...\n    >>> myfunc\n    <cdata 'int(*)(int, int)' calling <function myfunc at 0xf757bbc4>>\n\nNote that ``\"int(*)(int, int)\"`` is a C *function pointer* type, whereas\n``\"int(int, int)\"`` is a C *function* type.  Either can be specified to\nffi.callback() and the result is the same.\n\n.. warning::\n\n    Callbacks are provided for the ABI mode or for backward\n    compatibility.  If you are using the out-of-line API mode, it is\n    recommended to use the `extern \"Python\"`_ mechanism instead of\n    callbacks: it gives faster and cleaner code.  It also avoids several\n    issues with old-style callbacks:\n\n    - On less common architecture, libffi is more likely to crash on\n      callbacks (`e.g. on NetBSD`__);\n\n    - On hardened systems like PAX and SELinux, the extra memory\n      protections can interfere (for example, on SELinux you need to\n      run with ``deny_execmem`` set to ``off``).\n\n    - `On Mac OS X,`__ you need to give your application the entitlement\n      ``com.apple.security.cs.allow-unsigned-executable-memory``.\n\n    Note also that a cffi fix for this issue was attempted---see\n    the ``ffi_closure_alloc`` branch---but was not merged because it\n    creates potential `memory corruption`__ with ``fork()``.\n\n    In other words: yes, it is dangerous to allow write+execute memory in your\n    program; that's why the various \"hardening\" options above exist.  But at\n    the same time, these options open wide the door to another attack: if the\n    program forks and then attempts to call any of the ``ffi.callback()``, then\n    this immediately results in a crash---or, with a minimal amount of work\n    from an attacker, arbitrary code execution.  To me it sounds even more\n    dangerous than the original problem, and that's why cffi is not playing\n    along.\n\n    To fix the issue once and for all on the affected platforms, you need\n    to refactor the involved code so that it no longer uses ``ffi.callback()``.\n\n.. __: https://github.com/pyca/pyopenssl/issues/596\n.. __: https://bitbucket.org/cffi/cffi/issues/391/\n.. __: https://bugzilla.redhat.com/show_bug.cgi?id=1249685\n\nWarning: like ffi.new(), ffi.callback() returns a cdata that has\nownership of its C data.  (In this case, the necessary C data contains\nthe libffi data structures to do a callback.)  This means that the\ncallback can only be invoked as long as this cdata object is alive.\nIf you store the function pointer into C code, then make sure you also\nkeep this object alive for as long as the callback may be invoked.\nThe easiest way to do that is to always use ``@ffi.callback()`` at\nmodule-level only, and to pass \"context\" information around with\n`ffi.new_handle()`__, if possible.  Example:\n\n.. __: ref.html#new-handle\n\n.. code-block:: python\n\n    # a good way to use this decorator is once at global level\n    @ffi.callback(\"int(int, void *)\")\n    def my_global_callback(x, handle):\n        return ffi.from_handle(handle).some_method(x)\n\n\n    class Foo(object):\n\n        def __init__(self):\n            handle = ffi.new_handle(self)\n            self._handle = handle   # must be kept alive\n            lib.register_stuff_with_callback_and_voidp_arg(my_global_callback, handle)\n\n        def some_method(self, x):\n            print \"method called!\"\n\n(See also the section about `extern \"Python\"`_ above, where the same\ngeneral style is used.)\n\nNote that callbacks of a variadic function type are not supported.  A\nworkaround is to add custom C code.  In the following example, a\ncallback gets a first argument that counts how many extra ``int``\narguments are passed:\n\n.. code-block:: python\n\n    # file \"example_build.py\"\n\n    import cffi\n\n    ffibuilder = cffi.FFI()\n    ffibuilder.cdef(\"\"\"\n        int (*python_callback)(int how_many, int *values);\n        void *const c_callback;   /* pass this const ptr to C routines */\n    \"\"\")\n    ffibuilder.set_source(\"_example\", r\"\"\"\n        #include <stdarg.h>\n        #include <alloca.h>\n        static int (*python_callback)(int how_many, int *values);\n        static int c_callback(int how_many, ...) {\n            va_list ap;\n            /* collect the \"...\" arguments into the values[] array */\n            int i, *values = alloca(how_many * sizeof(int));\n            va_start(ap, how_many);\n            for (i=0; i<how_many; i++)\n                values[i] = va_arg(ap, int);\n            va_end(ap);\n            return python_callback(how_many, values);\n        }\n    \"\"\")\n    ffibuilder.compile(verbose=True)\n\n.. code-block:: python\n    \n    # file \"example.py\"\n\n    from _example import ffi, lib\n\n    @ffi.callback(\"int(int, int *)\")\n    def python_callback(how_many, values):\n        print ffi.unpack(values, how_many)\n        return 0\n    lib.python_callback = python_callback\n\nDeprecated: you can also use ``ffi.callback()`` not as a decorator but\ndirectly as ``ffi.callback(\"int(int, int)\", myfunc)``.  This is\ndiscouraged: using this a style, we are more likely to forget the\ncallback object too early, when it is still in use.\n\nThe ``ffi.callback()`` decorator also accepts the optional argument\n``error``, and from CFFI version 1.2 the optional argument ``onerror``.\nThese two work in the same way as `described above for extern \"Python\".`__\n\n.. __: error_onerror_\n\n\n\nWindows: calling conventions\n----------------------------\n\nOn Win32, functions can have two main calling conventions: either\n\"cdecl\" (the default), or \"stdcall\" (also known as \"WINAPI\").  There\nare also other rare calling conventions, but these are not supported.\n*New in version 1.3.*\n\nWhen you issue calls from Python to C, the implementation is such that\nit works with any of these two main calling conventions; you don't\nhave to specify it.  However, if you manipulate variables of type\n\"function pointer\" or declare callbacks, then the calling convention\nmust be correct.  This is done by writing ``__cdecl`` or ``__stdcall``\nin the type, like in C::\n\n    @ffi.callback(\"int __stdcall(int, int)\")\n    def AddNumbers(x, y):\n        return x + y\n\nor::\n\n    ffibuilder.cdef(\"\"\"\n        struct foo_s {\n            int (__stdcall *MyFuncPtr)(int, int);\n        };\n    \"\"\")\n\n``__cdecl`` is supported but is always the default so it can be left\nout.  In the ``cdef()``, you can also use ``WINAPI`` as equivalent to\n``__stdcall``.  As mentioned above, it is mostly not needed (but doesn't\nhurt) to say ``WINAPI`` or ``__stdcall`` when declaring a plain\nfunction in the ``cdef()``.  (The difference can still be seen if you\ntake explicitly a pointer to this function with ``ffi.addressof()``,\nor if the function is ``extern \"Python\"``.)\n\nThese calling convention specifiers are accepted but ignored on any\nplatform other than 32-bit Windows.\n\nIn CFFI versions before 1.3, the calling convention specifiers are not\nrecognized.  In API mode, you could work around it by using an\nindirection, like in the example in the section about Callbacks_\n(``\"example_build.py\"``).  There was no way to use stdcall callbacks\nin ABI mode.\n\n\nFFI Interface\n-------------\n\n(The reference for the FFI interface has been moved to the `next page`__.)\n\n.. __: ref.html\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.13.0-jlicqgsrlask3n7tsdckxmdwv6d5zp4o/spack-src/doc/source/overview.rst": "=======================================================\nOverview\n=======================================================\n\n.. contents::\n   \n\nThe first section presents a simple working\nexample of using CFFI to call a C function in a compiled shared object\n(DLL) from Python. CFFI is\nflexible and covers several other use cases presented in the second\nsection. The third section shows how to export Python functions\nto a Python interpreter embedded in a C or C++ application. The last\ntwo sections delve deeper in the CFFI library.\n\nMake sure you have `cffi installed`__.\n\n.. __: installation.html\n\n.. _out-of-line-api-level:\n.. _real-example:\n\n\nMain mode of usage\n------------------\n\nThe main way to use CFFI is as an interface to some already-compiled\nshared object which is provided by other means.  Imagine that you have a\nsystem-installed shared object called ``piapprox.dll`` (Windows) or\n``libpiapprox.so`` (Linux and others) or ``libpiapprox.dylib`` (OS X),\nexporting a function ``float pi_approx(int n);`` that computes some\napproximation of pi given a number of iterations. You want to call\nthis function from Python. Note this method works equally well with a\nstatic library ``piapprox.lib`` (Windows) or ``libpiapprox.a``.\n\nCreate the file ``piapprox_build.py``:\n\n.. code-block:: python\n\n      from cffi import FFI\n      ffibuilder = FFI()\n\n      # cdef() expects a single string declaring the C types, functions and\n      # globals needed to use the shared object. It must be in valid C syntax.\n      ffibuilder.cdef(\"\"\"\n          float pi_approx(int n);\n      \"\"\")\n\n      # set_source() gives the name of the python extension module to\n      # produce, and some C source code as a string.  This C code needs\n      # to make the declarated functions, types and globals available,\n      # so it is often just the \"#include\".\n      ffibuilder.set_source(\"_pi_cffi\",\n      \"\"\"\n      \t   #include \"pi.h\"   // the C header of the library\n      \"\"\",\n      \t   libraries=['piapprox'])   # library name, for the linker\n\n      if __name__ == \"__main__\":\n          ffibuilder.compile(verbose=True)\n\nExecute this script.  If everything is OK, it should produce\n``_pi_cffi.c``, and then invoke the compiler on it.  The produced\n``_pi_cffi.c`` contains a copy of the string given in ``set_source()``,\nin this example the ``#include \"pi.h\"``. Afterwards, it contains glue code\nfor all the functions, types and globals declared in the ``cdef()`` above.\n\nAt runtime, you use the extension module like this:\n\n.. code-block:: python\n\n    from _pi_cffi import ffi, lib\n    print(lib.pi_approx(5000))\n\nThat's all!  In the rest of this page, we describe some more advanced\nexamples and other CFFI modes.  In particular, there is a complete\nexample `if you don't have an already-installed C library to call`_.\n\nFor more information about the ``cdef()`` and ``set_source()`` methods\nof the ``FFI`` class, see `Preparing and Distributing modules`__.\n\n.. __: cdef.html\n\nWhen your example works, a common alternative to running the build\nscript manually is to have it run as part of a ``setup.py``.  Here is\nan example using the Setuptools distribution:\n\n.. code-block:: python\n\n    from setuptools import setup\n\n    setup(\n        ...\n        setup_requires=[\"cffi>=1.0.0\"],\n        cffi_modules=[\"piapprox_build:ffibuilder\"], # \"filename:global\"\n        install_requires=[\"cffi>=1.0.0\"],\n    )\n\n\nOther CFFI modes\n----------------\n\nCFFI can be used in one of four modes: \"ABI\" versus \"API\" level,\neach with \"in-line\" or \"out-of-line\" preparation (or compilation).\n\nThe **ABI mode** accesses libraries at the binary level, whereas the\nfaster **API mode** accesses them with a C compiler.  We explain the\ndifference in more details below__.\n\n.. __: `abi-versus-api`_\n\nIn the **in-line mode,** everything is set up every time you import\nyour Python code.  In the **out-of-line mode,** you have a separate\nstep of preparation (and possibly C compilation) that produces a\nmodule which your main program can then import.\n\n\nSimple example (ABI level, in-line)\n+++++++++++++++++++++++++++++++++++\n\nMay look familiar to those who have used ctypes_.\n\n.. code-block:: python\n\n    >>> from cffi import FFI\n    >>> ffi = FFI()\n    >>> ffi.cdef(\"\"\"\n    ...     int printf(const char *format, ...);   // copy-pasted from the man page\n    ... \"\"\")                                  \n    >>> C = ffi.dlopen(None)                     # loads the entire C namespace\n    >>> arg = ffi.new(\"char[]\", b\"world\")        # equivalent to C code: char arg[] = \"world\";\n    >>> C.printf(b\"hi there, %s.\\n\", arg)        # call printf\n    hi there, world.\n    17                                           # this is the return value\n    >>>\n\nNote that ``char *`` arguments expect a ``bytes`` object.  If you have a\n``str`` (or a ``unicode`` on Python 2) you need to encode it explicitly\nwith ``somestring.encode(myencoding)``.\n\n*Python 3 on Windows:* ``ffi.dlopen(None)`` does not work.  This problem\nis messy and not really fixable.  The problem does not occur if you try\nto call a function from a specific DLL that exists on your system: then\nyou use ``ffi.dlopen(\"path.dll\")``.\n\n*This example does not call any C compiler.  It works in the so-called\nABI mode, which means that it will crash if you call some function or\naccess some fields of a structure that was slightly misdeclared in the\ncdef().*\n\nIf using a C compiler to install your module is an option, it is highly\nrecommended to use the API mode instead.  (It is also faster.)\n\n\nStruct/Array Example (minimal, in-line)\n+++++++++++++++++++++++++++++++++++++++\n\n.. code-block:: python\n\n    from cffi import FFI\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef struct {\n            unsigned char r, g, b;\n        } pixel_t;\n    \"\"\")\n    image = ffi.new(\"pixel_t[]\", 800*600)\n\n    f = open('data', 'rb')     # binary mode -- important\n    f.readinto(ffi.buffer(image))\n    f.close()\n\n    image[100].r = 255\n    image[100].g = 192\n    image[100].b = 128\n\n    f = open('data', 'wb')\n    f.write(ffi.buffer(image))\n    f.close()\n\nThis can be used as a more flexible replacement of the struct_ and\narray_ modules, and replaces ctypes_.  You could also call ``ffi.new(\"pixel_t[600][800]\")``\nand get a two-dimensional array.\n\n.. _struct: http://docs.python.org/library/struct.html\n.. _array: http://docs.python.org/library/array.html\n.. _ctypes: http://docs.python.org/library/ctypes.html\n\n*This example does not call any C compiler.*\n\nThis example also admits an out-of-line equivalent.  It is similar to\nthe first example `Main mode of usage`_ above,\nbut passing ``None`` as the second argument to\n``ffibuilder.set_source()``.  Then in the main program you write\n``from _simple_example import ffi`` and then the same content as the\nin-line example above starting from the line ``image =\nffi.new(\"pixel_t[]\", 800*600)``.\n\n\nAPI Mode, calling the C standard library\n++++++++++++++++++++++++++++++++++++++++\n\n.. code-block:: python\n\n    # file \"example_build.py\"\n\n    # Note: we instantiate the same 'cffi.FFI' class as in the previous\n    # example, but call the result 'ffibuilder' now instead of 'ffi';\n    # this is to avoid confusion with the other 'ffi' object you get below\n\n    from cffi import FFI\n    ffibuilder = FFI()\n\n    ffibuilder.set_source(\"_example\",\n       r\"\"\" // passed to the real C compiler,\n            // contains implementation of things declared in cdef()\n            #include <sys/types.h>\n            #include <pwd.h>\n\n            // We can also define custom wrappers or other functions\n            // here (this is an example only):\n            static struct passwd *get_pw_for_root(void) {\n                return getpwuid(0);\n            }\n        \"\"\",\n        libraries=[])   # or a list of libraries to link with\n        # (more arguments like setup.py's Extension class:\n        # include_dirs=[..], extra_objects=[..], and so on)\n\n    ffibuilder.cdef(\"\"\"\n        // declarations that are shared between Python and C\n        struct passwd {\n            char *pw_name;\n            ...;     // literally dot-dot-dot\n        };\n        struct passwd *getpwuid(int uid);     // defined in <pwd.h>\n        struct passwd *get_pw_for_root(void); // defined in set_source()\n    \"\"\")\n\n    if __name__ == \"__main__\":\n        ffibuilder.compile(verbose=True)\n\nYou need to run the ``example_build.py`` script once to generate\n\"source code\" into the file ``_example.c`` and compile this to a\nregular C extension module.  (CFFI selects either Python or C for the\nmodule to generate based on whether the second argument to\n``set_source()`` is ``None`` or not.)\n\n*You need a C compiler for this single step.  It produces a file called\ne.g. _example.so or _example.pyd.  If needed, it can be distributed in\nprecompiled form like any other extension module.*\n\nThen, in your main program, you use:\n\n.. code-block:: python\n\n    from _example import ffi, lib\n\n    p = lib.getpwuid(0)\n    assert ffi.string(p.pw_name) == b'root'\n    p = lib.get_pw_for_root()\n    assert ffi.string(p.pw_name) == b'root'\n\nNote that this works independently of the exact C layout of ``struct\npasswd`` (it is \"API level\", as opposed to \"ABI level\").  It requires\na C compiler in order to run ``example_build.py``, but it is much more\nportable than trying to get the details of the fields of ``struct\npasswd`` exactly right.  Similarly, in the ``cdef()`` we declared\n``getpwuid()`` as taking an ``int`` argument; on some platforms this\nmight be slightly incorrect---but it does not matter.\n\nNote also that at runtime, the API mode is faster than the ABI mode.\n\nTo integrate it inside a ``setup.py`` distribution with Setuptools:\n\n.. code-block:: python\n\n    from setuptools import setup\n\n    setup(\n        ...\n        setup_requires=[\"cffi>=1.0.0\"],\n        cffi_modules=[\"example_build.py:ffibuilder\"],\n        install_requires=[\"cffi>=1.0.0\"],\n    )\n\n\n.. _`if you don't have an already-installed C library to call`:\n\nAPI Mode, calling C sources instead of a compiled library\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\nIf you want to call some library that is not precompiled, but for which\nyou have C sources, then the easiest solution is to make a single\nextension module that is compiled from both the C sources of this\nlibrary, and the additional CFFI wrappers.  For example, say you start\nwith the files ``pi.c`` and ``pi.h``:\n\n   .. code-block:: C\n\n      /* filename: pi.c*/\n      # include <stdlib.h>\n      # include <math.h>\n       \n      /* Returns a very crude approximation of Pi\n         given a int: a number of iteration */\n      float pi_approx(int n){\n      \n        double i,x,y,sum=0;\n      \n        for(i=0;i<n;i++){\n      \n          x=rand();\n          y=rand();\n      \n          if (sqrt(x*x+y*y) < sqrt((double)RAND_MAX*RAND_MAX))\n            sum++; }\n      \n        return 4*(float)sum/(float)n; }\n\n   .. code-block:: C\n\n      /* filename: pi.h*/\n      float pi_approx(int n);\n      \nCreate a script named ``pi_extension_build.py``, building\nthe C extension:\n\n   .. code-block:: python\n\n      from cffi import FFI\n      ffibuilder = FFI()\n      \n      ffibuilder.cdef(\"float pi_approx(int n);\")\n   \n      ffibuilder.set_source(\"_pi\",  # name of the output C extension\n      \"\"\"\n          #include \"pi.h\"',\n      \"\"\",\n          sources=['pi.c'],   # includes pi.c as additional sources\n          libraries=['m'])    # on Unix, link with the math library\n   \n      if __name__ == \"__main__\":\n          ffibuilder.compile(verbose=True)\n\nBuild the extension:\n   \n   .. code-block:: shell\n\n      python pi_extension_build.py\n\nObserve, in the working directory, the generated output files:\n``_pi.c``, ``_pi.o`` and the compiled C extension (called ``_pi.so`` on\nLinux for example).  It can be called from Python:\n\n   .. code-block:: python\n   \n       from _pi.lib import pi_approx\n   \n       approx = pi_approx(10)\n       assert str(pi_approximation).startswith(\"3.\")\n   \n       approx = pi_approx(10000)\n       assert str(approx).startswith(\"3.1\")  \n\n\n.. _performance:\n\nPurely for performance (API level, out-of-line)\n+++++++++++++++++++++++++++++++++++++++++++++++\n\nA variant of the `section above`__ where the goal is not to call an\nexisting C library, but to compile and call some C function written\ndirectly in the build script:\n\n.. __: real-example_\n\n.. code-block:: python\n\n    # file \"example_build.py\"\n\n    from cffi import FFI\n    ffibuilder = FFI()\n\n    ffibuilder.cdef(\"int foo(int *, int *, int);\")\n\n    ffibuilder.set_source(\"_example\",\n    r\"\"\"\n        static int foo(int *buffer_in, int *buffer_out, int x)\n        {\n            /* some algorithm that is seriously faster in C than in Python */\n        }\n    \"\"\")\n\n    if __name__ == \"__main__\":\n        ffibuilder.compile(verbose=True)\n\n.. code-block:: python\n\n    # file \"example.py\"\n\n    from _example import ffi, lib\n\n    buffer_in = ffi.new(\"int[]\", 1000)\n    # initialize buffer_in here...\n\n    # easier to do all buffer allocations in Python and pass them to C,\n    # even for output-only arguments\n    buffer_out = ffi.new(\"int[]\", 1000)\n\n    result = lib.foo(buffer_in, buffer_out, 1000)\n\n*You need a C compiler to run example_build.py, once.  It produces a\nfile called e.g. _example.so or _example.pyd.  If needed, it can be\ndistributed in precompiled form like any other extension module.*\n\n\n.. _out-of-line-abi-level:\n\nOut-of-line, ABI level\n++++++++++++++++++++++\n\nThe out-of-line ABI mode is a mixture of the regular (API) out-of-line\nmode and the in-line ABI mode.  It lets you use the ABI mode, with its\nadvantages (not requiring a C compiler) and problems (crashes more\neasily).\n\nThis mixture mode lets you massively reduces the import times, because\nit is slow to parse a large C header.  It also allows you to do more\ndetailed checkings during build-time without worrying about performance\n(e.g. calling ``cdef()`` many times with small pieces of declarations,\nbased on the version of libraries detected on the system).\n\n.. code-block:: python\n\n    # file \"simple_example_build.py\"\n\n    from cffi import FFI\n\n    ffibuilder = FFI()\n    # Note that the actual source is None\n    ffibuilder.set_source(\"_simple_example\", None)\n    ffibuilder.cdef(\"\"\"\n        int printf(const char *format, ...);\n    \"\"\")\n\n    if __name__ == \"__main__\":\n        ffibuilder.compile(verbose=True)\n\nRunning it once produces ``_simple_example.py``.  Your main program\nonly imports this generated module, not ``simple_example_build.py``\nany more:\n\n.. code-block:: python\n\n    from _simple_example import ffi\n\n    lib = ffi.dlopen(None)      # Unix: open the standard C library\n    #import ctypes.util         # or, try this on Windows:\n    #lib = ffi.dlopen(ctypes.util.find_library(\"c\"))\n\n    lib.printf(b\"hi there, number %d\\n\", ffi.cast(\"int\", 2))\n\nNote that this ``ffi.dlopen()``, unlike the one from in-line mode,\ndoes not invoke any additional magic to locate the library: it must be\na path name (with or without a directory), as required by the C\n``dlopen()`` or ``LoadLibrary()`` functions.  This means that\n``ffi.dlopen(\"libfoo.so\")`` is ok, but ``ffi.dlopen(\"foo\")`` is not.\nIn the latter case, you could replace it with\n``ffi.dlopen(ctypes.util.find_library(\"foo\"))``.  Also, None is only\nrecognized on Unix to open the standard C library.\n\nFor distribution purposes, remember that there is a new\n``_simple_example.py`` file generated.  You can either include it\nstatically within your project's source files, or, with Setuptools,\nyou can say in the ``setup.py``:\n\n.. code-block:: python\n\n    from setuptools import setup\n\n    setup(\n        ...\n        setup_requires=[\"cffi>=1.0.0\"],\n        cffi_modules=[\"simple_example_build.py:ffibuilder\"],\n        install_requires=[\"cffi>=1.0.0\"],\n    )\n\nIn summary, this mode is useful when you wish to declare many C structures but\ndo not need fast interaction with a shared object. It is useful for parsing\nbinary files, for instance.\n\n\nIn-line, API level\n++++++++++++++++++\n\nThe \"API level + in-line\" mode combination exists but is long\ndeprecated.  It used to be done with ``lib = ffi.verify(\"C header\")``.\nThe out-of-line variant with ``set_source(\"modname\", \"C header\")`` is\npreferred and avoids a number of problems when the project grows in\nsize.\n\n\n.. _embedding:\n\nEmbedding\n---------\n\n*New in version 1.5.*\n\nCFFI can be used for embedding__: creating a standard\ndynamically-linked library (``.dll`` under Windows, ``.so`` elsewhere)\nwhich can be used from a C application.\n\n.. code-block:: python\n\n    import cffi\n    ffibuilder = cffi.FFI()\n\n    ffibuilder.embedding_api(\"\"\"\n        int do_stuff(int, int);\n    \"\"\")\n\n    ffibuilder.set_source(\"my_plugin\", \"\")\n\n    ffibuilder.embedding_init_code(\"\"\"\n        from my_plugin import ffi\n\n        @ffi.def_extern()\n        def do_stuff(x, y):\n            print(\"adding %d and %d\" % (x, y))\n            return x + y\n    \"\"\")\n\n    ffibuilder.compile(target=\"plugin-1.5.*\", verbose=True)\n\nThis simple example creates ``plugin-1.5.dll`` or ``plugin-1.5.so`` as\na DLL with a single exported function, ``do_stuff()``.  You execute\nthe script above once, with the interpreter you want to have\ninternally used; it can be CPython 2.x or 3.x or PyPy.  This DLL can\nthen be used \"as usual\" from an application; the application doesn't\nneed to know that it is talking with a library made with Python and\nCFFI.  At runtime, when the application calls ``int do_stuff(int,\nint)``, the Python interpreter is automatically initialized and ``def\ndo_stuff(x, y):`` gets called.  `See the details in the documentation\nabout embedding.`__\n\n.. __: embedding.html\n.. __: embedding.html\n\n\nWhat actually happened?\n-----------------------\n\nThe CFFI interface operates on the same level as C - you declare types\nand functions using the same syntax as you would define them in C.  This\nmeans that most of the documentation or examples can be copied straight\nfrom the man pages.\n\nThe declarations can contain **types, functions, constants**\nand **global variables.** What you pass to the ``cdef()`` must not\ncontain more than that; in particular, ``#ifdef`` or ``#include``\ndirectives are not supported.  The cdef in the above examples are just\nthat - they declared \"there is a function in the C level with this\ngiven signature\", or \"there is a struct type with this shape\".\n\nIn the ABI examples, the ``dlopen()`` calls load libraries manually.\nAt the binary level, a program is split into multiple namespaces---a\nglobal one (on some platforms), plus one namespace per library.  So\n``dlopen()`` returns a ``<FFILibrary>`` object, and this object has\ngot as attributes all function, constant and variable symbols that are\ncoming from this library and that have been declared in the\n``cdef()``.  If you have several interdependent libraries to load,\nyou would call ``cdef()`` only once but ``dlopen()`` several times.\n\nBy opposition, the API mode works more closely like a C program: the C\nlinker (static or dynamic) is responsible for finding any symbol used.\nYou name the libraries in the ``libraries`` keyword argument to\n``set_source()``, but never need to say which symbol comes\nfrom which library.\nOther common arguments to ``set_source()`` include ``library_dirs`` and\n``include_dirs``; all these arguments are passed to the standard\ndistutils/setuptools.\n\nThe ``ffi.new()`` lines allocate C objects.  They are filled\nwith zeroes initially, unless the optional second argument is used.\nIf specified, this argument gives an \"initializer\", like you can use\nwith C code to initialize global variables.\n\nThe actual ``lib.*()`` function calls should be obvious: it's like C.\n\n\n.. _abi-versus-api:\n\nABI versus API\n--------------\n\nAccessing the C library at the binary level (\"ABI\") is fraught\nwith problems, particularly on non-Windows platforms.\n\nThe most immediate drawback of the ABI level is that calling functions\nneeds to go through the very general *libffi* library, which is slow\n(and not always perfectly tested on non-standard platforms).  The API\nmode instead compiles a CPython C wrapper that directly invokes the\ntarget function.  It can be massively faster (and works\nbetter than libffi ever will).\n\nThe more fundamental reason to prefer the API mode is that *the C\nlibraries are typically meant to be used with a C compiler.* You are not\nsupposed to do things like guess where fields are in the structures.\nThe \"real example\" above shows how CFFI uses a C compiler under the\nhood: this example uses ``set_source(..., \"C source...\")`` and never\n``dlopen()``.  When using this approach,\nwe have the advantage that we can use literally \"``...``\" at various places in\nthe ``cdef()``, and the missing information will be completed with the\nhelp of the C compiler.  CFFI will turn this into a single C source file,\nwhich contains the \"C source\" part unmodified, followed by some\n\"magic\" C code and declarations derived from the ``cdef()``.  When\nthis C file is compiled, the resulting C extension module will contain\nall the information we need---or the C compiler will give warnings or\nerrors, as usual e.g. if we misdeclare some function's signature.\n\nNote that the \"C source\" part from ``set_source()`` can contain\narbitrary C code.  You can use this to declare some\nmore helper functions written in C.  To export\nthese helpers to Python, put their signature in the ``cdef()`` too.\n(You can use the ``static`` C keyword in the \"C source\" part,\nas in ``static int myhelper(int x) { return x * 42; }``,\nbecause these helpers are only\nreferenced from the \"magic\" C code that is generated afterwards in the\nsame C file.)\n\nThis can be used for example to wrap \"crazy\" macros into more standard\nC functions.  The extra layer of C can be useful for other reasons\ntoo, like calling functions that expect some complicated argument\nstructures that you prefer to build in C rather than in Python.  (On\nthe other hand, if all you need is to call \"function-like\" macros,\nthen you can directly declare them in the ``cdef()`` as if they were\nfunctions.)\n\nThe generated piece of C code should be the same independently on the\nplatform on which you run it (or the Python version), so in simple cases\nyou can directly distribute the pre-generated C code and treat it as a\nregular C extension module (which depends on the ``_cffi_backend``\nmodule, on CPython).  The special Setuptools lines in the `example\nabove`__ are meant for the more complicated cases where we need to\nregenerate the C sources as well---e.g. because the Python script that\nregenerates this file will itself look around the system to know what it\nshould include or not.\n\n.. __: real-example_\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.13.0-jlicqgsrlask3n7tsdckxmdwv6d5zp4o/spack-src/doc/source/embedding.rst": "================================\nUsing CFFI for embedding\n================================\n\n.. contents::\n\nYou can use CFFI to generate C code which exports the API of your choice\nto any C application that wants to link with this C code.  This API,\nwhich you define yourself, ends up as the API of a ``.so/.dll/.dylib``\nlibrary---or you can statically link it within a larger application.\n\nPossible use cases:\n\n* Exposing a library written in Python directly to C/C++ programs.\n\n* Using Python to make a \"plug-in\" for an existing C/C++ program that is\n  already written to load them.\n\n* Using Python to implement part of a larger C/C++ application (with\n  static linking).\n\n* Writing a small C/C++ wrapper around Python, hiding the fact that the\n  application is actually written in Python (to make a custom\n  command-line interface; for distribution purposes; or simply to make\n  it a bit harder to reverse-engineer the application).\n\nThe general idea is as follows:\n\n* You write and execute a Python script, which produces a ``.c`` file\n  with the API of your choice (and optionally compile it into a\n  ``.so/.dll/.dylib``).  The script also gives some Python code to be\n  \"frozen\" inside the ``.so``.\n\n* At runtime, the C application loads this ``.so/.dll/.dylib`` (or is\n  statically linked with the ``.c`` source) without having to know that\n  it was produced from Python and CFFI.\n\n* The first time a C function is called, Python is initialized and\n  the frozen Python code is executed.\n\n* The frozen Python code defines more Python functions that implement the\n  C functions of your API, which are then used for all subsequent C\n  function calls.\n\nOne of the goals of this approach is to be entirely independent from\nthe CPython C API: no ``Py_Initialize()`` nor ``PyRun_SimpleString()``\nnor even ``PyObject``.  It works identically on CPython and PyPy.\n\nThis is entirely *new in version 1.5.*  (PyPy contains CFFI 1.5 since\nrelease 5.0.)\n\n\nUsage\n-----\n\n.. __: overview.html#embedding\n\nSee the `paragraph in the overview page`__ for a quick introduction.\nIn this section, we explain every step in more details.  We will use\nhere this slightly expanded example:\n\n.. code-block:: c\n\n    /* file plugin.h */\n    typedef struct { int x, y; } point_t;\n    extern int do_stuff(point_t *);\n\n.. code-block:: c\n\n    /* file plugin.h, Windows-friendly version */\n    typedef struct { int x, y; } point_t;\n\n    /* When including this file from ffibuilder.set_source(), the\n       following macro is defined to '__declspec(dllexport)'.  When\n       including this file directly from your C program, we define\n       it to 'extern __declspec(dllimport)' instead.\n\n       With non-MSVC compilers we simply define it to 'extern'.\n       (The 'extern' is needed for sharing global variables;\n       functions would be fine without it.  The macros always\n       include 'extern': you must not repeat it when using the\n       macros later.)\n    */\n    #ifndef CFFI_DLLEXPORT\n    #  if defined(_MSC_VER)\n    #    define CFFI_DLLEXPORT  extern __declspec(dllimport)\n    #  else\n    #    define CFFI_DLLEXPORT  extern\n    #  endif\n    #endif\n\n    CFFI_DLLEXPORT int do_stuff(point_t *);\n\n.. code-block:: python\n\n    # file plugin_build.py\n    import cffi\n    ffibuilder = cffi.FFI()\n\n    with open('plugin.h') as f:\n        # read plugin.h and pass it to embedding_api(), manually\n        # removing the '#' directives and the CFFI_DLLEXPORT\n        data = ''.join([line for line in f if not line.startswith('#')])\n        data = data.replace('CFFI_DLLEXPORT', '')\n        ffibuilder.embedding_api(data)\n\n    ffibuilder.set_source(\"my_plugin\", r'''\n        #include \"plugin.h\"\n    ''')\n\n    ffibuilder.embedding_init_code(\"\"\"\n        from my_plugin import ffi\n\n        @ffi.def_extern()\n        def do_stuff(p):\n            print(\"adding %d and %d\" % (p.x, p.y))\n            return p.x + p.y\n    \"\"\")\n\n    ffibuilder.compile(target=\"plugin-1.5.*\", verbose=True)\n    # or: ffibuilder.emit_c_code(\"my_plugin.c\")\n\nRunning the code above produces a *DLL*, i,e, a dynamically-loadable\nlibrary.  It is a file with the extension ``.dll`` on Windows,\n``.dylib`` on Mac OS/X, or ``.so`` on other platforms.  As usual, it\nis produced by generating some intermediate ``.c`` code and then\ncalling the regular platform-specific C compiler.  See below__ for\nsome pointers to C-level issues with using the produced library.\n\n.. __: `Issues about using the .so`_\n\nHere are some details about the methods used above:\n\n* **ffibuilder.embedding_api(source):** parses the given C source, which\n  declares functions that you want to be exported by the DLL.  It can\n  also declare types, constants and global variables that are part of\n  the C-level API of your DLL.\n\n  The functions that are found in ``source`` will be automatically\n  defined in the ``.c`` file: they will contain code that initializes\n  the Python interpreter the first time any of them is called,\n  followed by code to call the attached Python function (with\n  ``@ffi.def_extern()``, see next point).\n\n  The global variables, on the other hand, are not automatically\n  produced.  You have to write their definition explicitly in\n  ``ffibuilder.set_source()``, as regular C code (see the point after next).\n\n* **ffibuilder.embedding_init_code(python_code):** this gives\n  initialization-time Python source code.  This code is copied\n  (\"frozen\") inside the DLL.  At runtime, the code is executed when\n  the DLL is first initialized, just after Python itself is\n  initialized.  This newly initialized Python interpreter has got an\n  extra \"built-in\" module that can be loaded magically without\n  accessing any files, with a line like \"``from my_plugin import ffi,\n  lib``\".  The name ``my_plugin`` comes from the first argument to\n  ``ffibuilder.set_source()``.  This module represents \"the caller's C world\"\n  from the point of view of Python.\n\n  The initialization-time Python code can import other modules or\n  packages as usual.  You may have typical Python issues like needing\n  to set up ``sys.path`` somehow manually first.\n\n  For every function declared within ``ffibuilder.embedding_api()``, the\n  initialization-time Python code or one of the modules it imports\n  should use the decorator ``@ffi.def_extern()`` to attach a\n  corresponding Python function to it.\n\n  If the initialization-time Python code fails with an exception, then\n  you get a traceback printed to stderr, along with more information\n  to help you identify problems like wrong ``sys.path``.  If some\n  function remains unattached at the time where the C code tries to\n  call it, an error message is also printed to stderr and the function\n  returns zero/null.\n\n  Note that the CFFI module never calls ``exit()``, but CPython itself\n  contains code that calls ``exit()``, for example if importing\n  ``site`` fails.  This may be worked around in the future.\n\n* **ffibuilder.set_source(c_module_name, c_code):** set the name of the\n  module from Python's point of view.  It also gives more C code which\n  will be included in the generated C code.  In trivial examples it\n  can be an empty string.  It is where you would ``#include`` some\n  other files, define global variables, and so on.  The macro\n  ``CFFI_DLLEXPORT`` is available to this C code: it expands to the\n  platform-specific way of saying \"the following declaration should be\n  exported from the DLL\".  For example, you would put \"``extern int\n  my_glob;``\" in ``ffibuilder.embedding_api()`` and \"``CFFI_DLLEXPORT int\n  my_glob = 42;``\" in ``ffibuilder.set_source()``.\n\n  Currently, any *type* declared in ``ffibuilder.embedding_api()`` must also\n  be present in the ``c_code``.  This is automatic if this code\n  contains a line like ``#include \"plugin.h\"`` in the example above.\n\n* **ffibuilder.compile([target=...] [, verbose=True]):** make the C code and\n  compile it.  By default, it produces a file called\n  ``c_module_name.dll``, ``c_module_name.dylib`` or\n  ``c_module_name.so``, but the default can be changed with the\n  optional ``target`` keyword argument.  You can use\n  ``target=\"foo.*\"`` with a literal ``*`` to ask for a file called\n  ``foo.dll`` on Windows, ``foo.dylib`` on OS/X and ``foo.so``\n  elsewhere.  One reason for specifying an alternate ``target`` is to\n  include characters not usually allowed in Python module names, like\n  \"``plugin-1.5.*``\".\n\n  For more complicated cases, you can call instead\n  ``ffibuilder.emit_c_code(\"foo.c\")`` and compile the resulting ``foo.c``\n  file using other means.  CFFI's compilation logic is based on the\n  standard library ``distutils`` package, which is really developed\n  and tested for the purpose of making CPython extension modules; it\n  might not always be appropriate for making general DLLs.  Also, just\n  getting the C code is what you need if you do not want to make a\n  stand-alone ``.so/.dll/.dylib`` file: this C file can be compiled\n  and statically linked as part of a larger application.\n\n\nMore reading\n------------\n\nIf you're reading this page about embedding and you are not familiar\nwith CFFI already, here are a few pointers to what you could read\nnext:\n\n* For the ``@ffi.def_extern()`` functions, integer C types are passed\n  simply as Python integers; and simple pointers-to-struct and basic\n  arrays are all straightforward enough.  However, sooner or later you\n  will need to read about this topic in more details here__.\n\n* ``@ffi.def_extern()``: see `documentation here,`__ notably on what\n  happens if the Python function raises an exception.\n\n* To create Python objects attached to C data, one common solution is\n  to use ``ffi.new_handle()``.  See documentation here__.\n\n* In embedding mode, the major direction is C code that calls Python\n  functions.  This is the opposite of the regular extending mode of\n  CFFI, in which the major direction is Python code calling C.  That's\n  why the page `Using the ffi/lib objects`_ talks first about the\n  latter, and why the direction \"C code that calls Python\" is\n  generally referred to as \"callbacks\" in that page.  If you also\n  need to have your Python code call C code, read more about\n  `Embedding and Extending`_ below.\n\n* ``ffibuilder.embedding_api(source)``: follows the same syntax as\n  ``ffibuilder.cdef()``, `documented here.`__  You can use the \"``...``\"\n  syntax as well, although in practice it may be less useful than it\n  is for ``cdef()``.  On the other hand, it is expected that often the\n  C sources that you need to give to ``ffibuilder.embedding_api()`` would be\n  exactly the same as the content of some ``.h`` file that you want to\n  give to users of your DLL.  That's why the example above does this::\n\n      with open('foo.h') as f:\n          ffibuilder.embedding_api(f.read())\n\n  Note that a drawback of this approach is that ``ffibuilder.embedding_api()``\n  doesn't support ``#ifdef`` directives.  You may have to use a more\n  convoluted expression like::\n\n      with open('foo.h') as f:\n          lines = [line for line in f if not line.startswith('#')]\n          ffibuilder.embedding_api(''.join(lines))\n\n  As in the example above, you can also use the same ``foo.h`` from\n  ``ffibuilder.set_source()``::\n\n      ffibuilder.set_source('module_name', r'''\n          #include \"foo.h\"\n      ''')\n\n\n.. __: using.html#working\n.. __: using.html#def-extern\n.. __: ref.html#ffi-new-handle\n.. __: cdef.html#cdef\n\n.. _`Using the ffi/lib objects`: using.html\n\n\nTroubleshooting\n---------------\n\n* The error message\n\n    cffi extension module 'c_module_name' has unknown version 0x2701\n\n  means that the running Python interpreter located a CFFI version older\n  than 1.5.  CFFI 1.5 or newer must be installed in the running Python.\n\n* On PyPy, the error message\n\n    debug: pypy_setup_home: directories 'lib-python' and 'lib_pypy' not\n    found in pypy's shared library location or in any parent directory\n\n  means that the ``libpypy-c.so`` file was found, but the standard library\n  was not found from this location.  This occurs at least on some Linux\n  distributions, because they put ``libpypy-c.so`` inside ``/usr/lib/``,\n  instead of the way we recommend, which is: keep that file inside\n  ``/opt/pypy/bin/`` and put a symlink to there from ``/usr/lib/``.\n  The quickest fix is to do that change manually.\n\n\nIssues about using the .so\n--------------------------\n\nThis paragraph describes issues that are not necessarily specific to\nCFFI.  It assumes that you have obtained the ``.so/.dylib/.dll`` file as\ndescribed above, but that you have troubles using it.  (In summary: it\nis a mess.  This is my own experience, slowly built by using Google and\nby listening to reports from various platforms.  Please report any\ninaccuracies in this paragraph or better ways to do things.)\n\n* The file produced by CFFI should follow this naming pattern:\n  ``libmy_plugin.so`` on Linux, ``libmy_plugin.dylib`` on Mac, or\n  ``my_plugin.dll`` on Windows (no ``lib`` prefix on Windows).\n\n* First note that this file does not contain the Python interpreter\n  nor the standard library of Python.  You still need it to be\n  somewhere.  There are ways to compact it to a smaller number of files,\n  but this is outside the scope of CFFI (please report if you used some\n  of these ways successfully so that I can add some links here).\n\n* In what we'll call the \"main program\", the ``.so`` can be either\n  used dynamically (e.g. by calling ``dlopen()`` or ``LoadLibrary()``\n  inside the main program), or at compile-time (e.g. by compiling it\n  with ``gcc -lmy_plugin``).  The former case is always used if you're\n  building a plugin for a program, and the program itself doesn't need\n  to be recompiled.  The latter case is for making a CFFI library that\n  is more tightly integrated inside the main program.\n\n* In the case of compile-time usage: you can add the gcc\n  option ``-Lsome/path/`` before ``-lmy_plugin`` to describe where the\n  ``libmy_plugin.so`` is.  On some platforms, notably Linux, ``gcc``\n  will complain if it can find ``libmy_plugin.so`` but not\n  ``libpython27.so`` or ``libpypy-c.so``.  To fix it, you need to call\n  ``LD_LIBRARY_PATH=/some/path/to/libpypy gcc``.\n\n* When actually executing the main program, it needs to find the\n  ``libmy_plugin.so`` but also ``libpython27.so`` or ``libpypy-c.so``.\n  For PyPy, unpack a PyPy distribution and you get a full directory\n  structure with ``libpypy-c.so`` inside a ``bin`` subdirectory, or on\n  Windows ``pypy-c.dll`` inside the top directory; you must not move\n  this file around, but just point to it.  One way to point to it is by\n  running the main program with some environment variable:\n  ``LD_LIBRARY_PATH=/some/path/to/libpypy`` on Linux,\n  ``DYLD_LIBRARY_PATH=/some/path/to/libpypy`` on OS/X.\n\n* You can avoid the ``LD_LIBRARY_PATH`` issue if you compile\n  ``libmy_plugin.so`` with the path hard-coded inside in the first\n  place.  On Linux, this is done by ``gcc -Wl,-rpath=/some/path``.  You\n  would put this option in ``ffibuilder.set_source(\"my_plugin\", ...,\n  extra_link_args=['-Wl,-rpath=/some/path/to/libpypy'])``.  The path can\n  start with ``$ORIGIN`` to mean \"the directory where\n  ``libmy_plugin.so`` is\".  You can then specify a path relative to that\n  place, like ``extra_link_args=['-Wl,-rpath=$ORIGIN/../venv/bin']``.\n  Use ``ldd libmy_plugin.so`` to look at what path is currently compiled\n  in after the expansion of ``$ORIGIN``.)\n\n  After this, you don't need ``LD_LIBRARY_PATH`` any more to locate\n  ``libpython27.so`` or ``libpypy-c.so`` at runtime.  In theory it\n  should also cover the call to ``gcc`` for the main program.  I wasn't\n  able to make ``gcc`` happy without ``LD_LIBRARY_PATH`` on Linux if\n  the rpath starts with ``$ORIGIN``, though.\n\n* The same rpath trick might be used to let the main program find\n  ``libmy_plugin.so`` in the first place without ``LD_LIBRARY_PATH``.\n  (This doesn't apply if the main program uses ``dlopen()`` to load it\n  as a dynamic plugin.)  You'd make the main program with ``gcc\n  -Wl,-rpath=/path/to/libmyplugin``, possibly with ``$ORIGIN``.  The\n  ``$`` in ``$ORIGIN`` causes various shell problems on its own: if\n  using a common shell you need to say ``gcc\n  -Wl,-rpath=\\$ORIGIN``.  From a Makefile, you need to say\n  something like ``gcc -Wl,-rpath=\\$$ORIGIN``.\n\n* On some Linux distributions, notably Debian, the ``.so`` files of\n  CPython C extension modules may be compiled without saying that they\n  depend on ``libpythonX.Y.so``.  This makes such Python systems\n  unsuitable for embedding if the embedder uses ``dlopen(...,\n  RTLD_LOCAL)``.  You get an ``undefined symbol`` error.  See\n  `issue #264`__.  A workaround is to first call\n  ``dlopen(\"libpythonX.Y.so\", RTLD_LAZY|RTLD_GLOBAL)``, which will\n  force ``libpythonX.Y.so`` to be loaded first.\n\n.. __: https://bitbucket.org/cffi/cffi/issues/264/\n\n\nUsing multiple CFFI-made DLLs\n-----------------------------\n\nMultiple CFFI-made DLLs can be used by the same process.\n\nNote that all CFFI-made DLLs in a process share a single Python\ninterpreter.  The effect is the same as the one you get by trying to\nbuild a large Python application by assembling a lot of unrelated\npackages.  Some of these might be libraries that monkey-patch some\nfunctions from the standard library, for example, which might be\nunexpected from other parts.\n\n\nMultithreading\n--------------\n\nMultithreading should work transparently, based on Python's standard\nGlobal Interpreter Lock.\n\nIf two threads both try to call a C function when Python is not yet\ninitialized, then locking occurs.  One thread proceeds with\ninitialization and blocks the other thread.  The other thread will be\nallowed to continue only when the execution of the initialization-time\nPython code is done.\n\nIf the two threads call two *different* CFFI-made DLLs, the Python\ninitialization itself will still be serialized, but the two pieces of\ninitialization-time Python code will not.  The idea is that there is a\npriori no reason for one DLL to wait for initialization of the other\nDLL to be complete.\n\nAfter initialization, Python's standard Global Interpreter Lock kicks\nin.  The end result is that when one CPU progresses on executing\nPython code, no other CPU can progress on executing more Python code\nfrom another thread of the same process.  At regular intervals, the\nlock switches to a different thread, so that no single thread should\nappear to block indefinitely.\n\n\nTesting\n-------\n\nFor testing purposes, a CFFI-made DLL can be imported in a running\nPython interpreter instead of being loaded like a C shared library.\n\nYou might have some issues with the file name: for example, on\nWindows, Python expects the file to be called ``c_module_name.pyd``,\nbut the CFFI-made DLL is called ``target.dll`` instead.  The base name\n``target`` is the one specified in ``ffibuilder.compile()``, and on Windows\nthe extension is ``.dll`` instead of ``.pyd``.  You have to rename or\ncopy the file, or on POSIX use a symlink.\n\nThe module then works like a regular CFFI extension module.  It is\nimported with \"``from c_module_name import ffi, lib``\" and exposes on\nthe ``lib`` object all C functions.  You can test it by calling these\nC functions.  The initialization-time Python code frozen inside the\nDLL is executed the first time such a call is done.\n\n\nEmbedding and Extending\n-----------------------\n\nThe embedding mode is not incompatible with the non-embedding mode of\nCFFI.\n\nYou can use *both* ``ffibuilder.embedding_api()`` and\n``ffibuilder.cdef()`` in the\nsame build script.  You put in the former the declarations you want to\nbe exported by the DLL; you put in the latter only the C functions and\ntypes that you want to share between C and Python, but not export from\nthe DLL.\n\nAs an example of that, consider the case where you would like to have\na DLL-exported C function written in C directly, maybe to handle some\ncases before calling Python functions.  To do that, you must *not* put\nthe function's signature in ``ffibuilder.embedding_api()``.  (Note that this\nrequires more hacks if you use ``ffibuilder.embedding_api(f.read())``.)\nYou must only write the custom function definition in\n``ffibuilder.set_source()``, and prefix it with the macro CFFI_DLLEXPORT:\n\n.. code-block:: c\n\n    CFFI_DLLEXPORT int myfunc(int a, int b)\n    {\n        /* implementation here */\n    }\n\nThis function can, if it wants, invoke Python functions using the\ngeneral mechanism of \"callbacks\"---called this way because it is a\ncall from C to Python, although in this case it is not calling\nanything back:\n\n.. code-block:: python\n\n    ffibuilder.cdef(\"\"\"\n        extern \"Python\" int mycb(int);\n    \"\"\")\n\n    ffibuilder.set_source(\"my_plugin\", r\"\"\"\n\n        static int mycb(int);   /* the callback: forward declaration, to make\n                                   it accessible from the C code that follows */\n\n        CFFI_DLLEXPORT int myfunc(int a, int b)\n        {\n            int product = a * b;   /* some custom C code */\n            return mycb(product);\n        }\n    \"\"\")\n\nand then the Python initialization code needs to contain the lines:\n\n.. code-block:: python\n\n    @ffi.def_extern()\n    def mycb(x):\n        print \"hi, I'm called with x =\", x\n        return x * 10\n\nThis ``@ffi.def_extern`` is attaching a Python function to the C\ncallback ``mycb()``, which in this case is not exported from the DLL.\nNevertheless, the automatic initialization of Python occurs when\n``mycb()`` is called, if it happens to be the first function called\nfrom C.  More precisely, it does not happen when ``myfunc()`` is\ncalled: this is just a C function, with no extra code magically\ninserted around it.  It only happens when ``myfunc()`` calls\n``mycb()``.\n\nAs the above explanation hints, this is how ``ffibuilder.embedding_api()``\nactually implements function calls that directly invoke Python code;\nhere, we have merely decomposed it explicitly, in order to add some\ncustom C code in the middle.\n\nIn case you need to force, from C code, Python to be initialized\nbefore the first ``@ffi.def_extern()`` is called, you can do so by\ncalling the C function ``cffi_start_python()`` with no argument.  It\nreturns an integer, 0 or -1, to tell if the initialization succeeded\nor not.  Currently there is no way to prevent a failing initialization\nfrom also dumping a traceback and more information to stderr.\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.13.0-jlicqgsrlask3n7tsdckxmdwv6d5zp4o/spack-src/c/libffi_msvc/win64.obj"
    ],
    "total_files": 183
}