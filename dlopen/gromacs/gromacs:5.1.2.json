{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-gromacs-5.1.2-tz5blkl5h4hbtzrte7ypqrgwjwhftnur/spack-src/CMakeLists.txt": "#\n# This file is part of the GROMACS molecular simulation package.\n#\n# Copyright (c) 2009,2010,2011,2012,2013,2014,2015, by the GROMACS development team, led by\n# Mark Abraham, David van der Spoel, Berk Hess, and Erik Lindahl,\n# and including many others, as listed in the AUTHORS file in the\n# top-level source directory and at http://www.gromacs.org.\n#\n# GROMACS is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public License\n# as published by the Free Software Foundation; either version 2.1\n# of the License, or (at your option) any later version.\n#\n# GROMACS is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public\n# License along with GROMACS; if not, see\n# http://www.gnu.org/licenses, or write to the Free Software Foundation,\n# Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA.\n#\n# If you want to redistribute modifications to GROMACS, please\n# consider that scientific software is very special. Version\n# control is crucial - bugs must be traceable. We will be happy to\n# consider code for inclusion in the official distribution, but\n# derived work must not be called official GROMACS. Details are found\n# in the README & COPYING files - if they are missing, get the\n# official version at http://www.gromacs.org.\n#\n# To help us fund GROMACS development, we humbly ask that you cite\n# the research papers on the package. Check out http://www.gromacs.org.\n\ncmake_minimum_required(VERSION 2.8.8)\n# When we require cmake >= 2.8.12, it will provide\n# CMAKE_MINIMUM_REQUIRED_VERSION automatically, but in the meantime we\n# need to set a variable, and it must have a different name.\nset(GMX_CMAKE_MINIMUM_REQUIRED_VERSION \"2.8.8\")\n\n# CMake modules/macros are in a subdirectory to keep this file cleaner\n# This needs to be set before project() in order to pick up toolchain files\nlist(APPEND CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/cmake ${CMAKE_CURRENT_SOURCE_DIR}/cmake/Platform)\n\nproject(Gromacs)\n\nset(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)\nset(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)\nset(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)\n\n# Set up common version variables, as well as general information about\n# the build tree (whether the build is from a source package or from a git\n# repository).  Also declares a few functions that will be used for generating\n# version info files later.\ninclude(gmxVersionInfo)\n\nif(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT AND UNIX)\n    set(CMAKE_INSTALL_PREFIX \"/usr/local/gromacs\" CACHE STRING \"Installation prefix (installation will need write permissions here)\" FORCE)\nendif()\nif(\"${CMAKE_INSTALL_PREFIX}\" STREQUAL \"${CMAKE_BINARY_DIR}\")\n    message(FATAL_ERROR \"GROMACS cannot be installed into the build tree, choose a different location for CMAKE_INSTALL_PREFIX\")\nendif()\n\ninclude(gmxBuildTypeReference)\ninclude(gmxBuildTypeProfile)\ninclude(gmxBuildTypeTSAN)\ninclude(gmxBuildTypeASAN)\ninclude(gmxBuildTypeMSAN)\ninclude(gmxBuildTypeReleaseWithAssert)\n\nif(NOT CMAKE_BUILD_TYPE)\n    set(CMAKE_BUILD_TYPE \"Release\" CACHE STRING \"Choose the type of build, options are: Debug Release RelWithDebInfo MinSizeRel Reference RelWithAssert Profile.\" FORCE)\n    # There's no need to offer a user the choice of ThreadSanitizer\n    # Set the possible values of build type for cmake-gui\n    set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS \"Debug\" \"Release\"\n        \"MinSizeRel\" \"RelWithDebInfo\" \"Reference\" \"RelWithAssert\" \"Profile\")\nendif()\nif(CMAKE_CONFIGURATION_TYPES)\n    # Add appropriate GROMACS-specific build types for the Visual\n    # Studio generator (Debug, Release, MinSizeRel and RelWithDebInfo\n    # are already present by default).\n    list(APPEND CMAKE_CONFIGURATION_TYPES \"RelWithAssert\" \"Reference\")\n    list(REMOVE_DUPLICATES CMAKE_CONFIGURATION_TYPES)\n    set(CMAKE_CONFIGURATION_TYPES \"${CMAKE_CONFIGURATION_TYPES}\" CACHE STRING\n        \"List of configuration types\"\n        FORCE)\nendif()\nset(build_types_with_explicit_flags RELEASE DEBUG RELWITHDEBINFO RELWITHASSERT MINSIZEREL PROFILE)\n\nset_property(GLOBAL PROPERTY FIND_LIBRARY_USE_LIB64_PATHS ON)\n\n# Set a default valgrind suppression file.\n# This unfortunately needs to duplicate information from CTest to work as\n# expected...\nset(MEMORYCHECK_SUPPRESSIONS_FILE\n    \"${CMAKE_SOURCE_DIR}/cmake/legacy_and_external.supp\"\n    CACHE FILEPATH\n    \"File that contains suppressions for the memory checker\")\ninclude(CTest)\n\ninclude(gmxCPackUtilities)\ngmx_cpack_init()\n\n# Variables that accumulate stuff influencing the installed headers\nset(INSTALLED_HEADER_INCLUDE_DIRS \"\")\nset(INSTALLED_HEADER_DEFINITIONS \"\")\n\n########################################################################\n# Check and warn if cache generated on a different host is being reused\n########################################################################\nif(CMAKE_HOST_UNIX)\n    execute_process(COMMAND hostname\n                    OUTPUT_VARIABLE TMP_HOSTNAME\n                    OUTPUT_STRIP_TRAILING_WHITESPACE)\n    if(GMX_BUILD_HOSTNAME AND NOT \"${GMX_BUILD_HOSTNAME}\" STREQUAL \"${TMP_HOSTNAME}\")\n        message(WARNING \"\n            The CMake cache, probably generated on a different host (${GMX_BUILD_HOSTNAME}),\n            is being reused! This could lead to inconsistencies; therefore, it is\n            recommended to regenerate the cache!\")\n    endif()\n    set(GMX_BUILD_HOSTNAME \"${TMP_HOSTNAME}\" CACHE INTERNAL\n            \"Hostname of the machine where the cache was generated.\")\nendif()\n\n########################################################################\n# Detect architecture before setting options so we can alter defaults\n########################################################################\n# Detect the architecture the compiler is targetting, detect\n# SIMD instructions possibilities on that hardware, suggest SIMD instruction set\n# to use if none is specified, and populate the cache option for CPU\n# SIMD.\ninclude(gmxDetectTargetArchitecture)\ngmx_detect_target_architecture()\n\n########################################################################\n# User input options                                                   #\n########################################################################\ninclude(gmxOptionUtilities)\n\nset(CMAKE_PREFIX_PATH \"\" CACHE STRING \"Extra locations to search for external libraries and tools (give directory without lib, bin, or include)\")\n\nif(GMX_TARGET_FUJITSU_SPARC64)\n    # Fujitsu only has SIMD in double precision, so this will be faster\n    set(GMX_DOUBLE_DEFAULT ON)\nelse()\n    set(GMX_DOUBLE_DEFAULT OFF)\nendif()\noption(GMX_DOUBLE \"Use double precision (much slower, use only if you really need it)\" ${GMX_DOUBLE_DEFAULT})\noption(GMX_RELAXED_DOUBLE_PRECISION \"Accept single precision 1/sqrt(x) when using Fujitsu HPC-ACE SIMD\" OFF)\nmark_as_advanced(GMX_RELAXED_DOUBLE_PRECISION)\n\noption(GMX_MPI    \"Build a parallel (message-passing) version of GROMACS\" OFF)\noption(GMX_THREAD_MPI  \"Build a thread-MPI-based multithreaded version of GROMACS (not compatible with MPI)\" ON)\ngmx_dependent_option(\n    GMX_MPI_IN_PLACE\n    \"Enable MPI_IN_PLACE for MPIs that have it defined\"\n    ON\n    GMX_MPI)\nmark_as_advanced(GMX_MPI_IN_PLACE)\noption(GMX_SOFTWARE_INVSQRT \"Use GROMACS software 1/sqrt\" ON)\nmark_as_advanced(GMX_SOFTWARE_INVSQRT)\noption(GMX_FAHCORE \"Build a library with mdrun functionality\" OFF)\nmark_as_advanced(GMX_FAHCORE)\n\noption(GMX_COOL_QUOTES \"Enable GROMACS cool quotes\" ON)\nmark_as_advanced(GMX_COOL_QUOTES)\ngmx_add_cache_dependency(GMX_COOL_QUOTES BOOL \"NOT GMX_FAHCORE\" OFF)\n\noption(GMX_USE_OPENCL \"Enable OpenCL acceleration\" OFF)\n\n# Decide on GPU settings based on user-settings and GPU/CUDA detection.\n# We support CUDA >=v4.0 on *nix, but <= v4.1 doesn't work with MSVC\nif(MSVC)\n    set(REQUIRED_CUDA_VERSION 4.1)\nelse()\n    set(REQUIRED_CUDA_VERSION 4.0)\nendif()\nset(REQUIRED_CUDA_COMPUTE_CAPABILITY 2.0)\n\n# OpenCL required version: 1.1 or newer\nset(REQUIRED_OPENCL_MIN_VERSION 1.1)\n\nif(NOT GMX_USE_OPENCL)\n    # CUDA detection is done only if GMX_USE_OPENCL is OFF\n    include(gmxManageGPU)\nelse()\n    #Now the OpenCL path\n    if(GMX_GPU)\n        include(gmxManageOpenCL)\n    else(GMX_GPU)\n        message(FATAL_ERROR \"OpenCL requested but GPU option is not enabled (try -DGMX_GPU=on) \")\n    endif(GMX_GPU)\nendif()\n\ninclude(gmxDetectSimd)\ngmx_detect_simd(GMX_SUGGESTED_SIMD)\n\ngmx_option_multichoice(\n    GMX_SIMD\n    \"SIMD instruction set for CPU kernels and compiler optimization\"\n    \"${GMX_SUGGESTED_SIMD}\"\n    None SSE2 SSE4.1 AVX_128_FMA AVX_256 AVX2_256 AVX_512F AVX_512ER MIC ARM_NEON ARM_NEON_ASIMD IBM_QPX IBM_VMX IBM_VSX Sparc64_HPC_ACE Reference)\n\nif(GMX_TARGET_MIC)\n    set(GMX_FFT_LIBRARY_DEFAULT \"mkl\")\nelse()\n    set(GMX_FFT_LIBRARY_DEFAULT \"fftw3\")\nendif()\n\ngmx_option_multichoice(\n    GMX_FFT_LIBRARY\n    \"FFT library\"\n    \"${GMX_FFT_LIBRARY_DEFAULT}\"\n    fftw3 mkl \"fftpack[built-in]\")\ngmx_dependent_option(\n    GMX_BUILD_OWN_FFTW\n    \"Download and build FFTW 3 during the GROMACS build process, rather than fall back on the really slow fftpack.\"\n    OFF\n    \"GMX_FFT_LIBRARY STREQUAL FFTW3\")\ngmx_dependent_option(\n    GMX_DISABLE_FFTW_MEASURE\n    \"Do not optimize FFTW setups (not needed with SSE)\"\n    OFF\n    \"GMX_FFT_LIBRARY STREQUAL FFTW3\")\nmark_as_advanced(GMX_BUILD_OWN_FFTW)\nmark_as_advanced(GMX_DISABLE_FFTW_MEASURE)\n\ngmx_option_multichoice(\n    GMX_QMMM_PROGRAM\n    \"QM package for QM/MM\"\n    None\n    none gaussian mopac gamess orca)\n\ngmx_dependent_cache_variable(GMX_SIMD_REF_FLOAT_WIDTH  \"Reference SIMD single precision width\" STRING \"4\" \"GMX_SIMD STREQUAL REFERENCE\")\ngmx_dependent_cache_variable(GMX_SIMD_REF_DOUBLE_WIDTH \"Reference SIMD double precision width\" STRING \"2\" \"GMX_SIMD STREQUAL REFERENCE\")\n\n# This should be moved to a separate NBNXN cmake module when that code is cleaned up and modularized\n\noption(GMX_BROKEN_CALLOC \"Work around broken calloc()\" OFF)\nmark_as_advanced(GMX_BROKEN_CALLOC)\noption(GMX_LOAD_PLUGINS \"Compile with plugin support, needed to read VMD supported file formats\" ON)\nmark_as_advanced(GMX_LOAD_PLUGINS)\n\noption(GMX_GPU  \"Enable GPU acceleration\" ON)\noption(GMX_OPENMP \"Enable OpenMP-based multithreading\" ON)\n\noption(GMX_USE_TNG \"Use the TNG library for trajectory I/O\" ON)\n\noption(GMX_BUILD_MDRUN_ONLY \"Build and install only the mdrun binary\" OFF)\n\noption(GMX_CYCLE_SUBCOUNTERS \"Enable cycle subcounters to get a more detailed cycle timings\" OFF)\nmark_as_advanced(GMX_CYCLE_SUBCOUNTERS)\n\noption(GMX_SKIP_DEFAULT_CFLAGS \"Don't automatically add suggested/required Compiler flags.\" OFF)\nmark_as_advanced(GMX_SKIP_DEFAULT_CFLAGS)\n\noption(GMX_BUILD_FOR_COVERAGE\n       \"Tune build for better code coverage metrics (e.g., disable asserts)\"\n       OFF)\nmark_as_advanced(GMX_BUILD_FOR_COVERAGE)\n\noption(GMX_DEVELOPER_BUILD\n    \"Enable Developer convenience features: always build unit-tests\"\n    OFF)\nmark_as_advanced(GMX_DEVELOPER_BUILD)\n\noption(GMX_BUILD_SHARED_EXE\n    \"Build exectuables as shared binaries. If not set, this disables rpath and dynamic linker flags in an attempt to build a static binary, but this may require setting up the toolchain properly and making appropriate libraries available.\"\n    ON)\nmark_as_advanced(GMX_BUILD_SHARED_EXE)\n\n######################################################################\n# Detect OpenMP support\n######################################################################\n# The OpenMP detection _must_ come before tests for other CFLAGS.\ninclude(gmxManageOpenMP)\n\n\n\n######################################################################\n# Compiler tests\n# These need to be done early (before further tests).\n#####################################################################\n\n# The cmake/Check{C,CXX}CompilerFlag.cmake files in the GROMACS distribution\n# are used with permission from CMake v3.0.0 so that GROMACS can detect\n# invalid options with the Intel Compilers, and we have added a line\n# to detect warnings with the Fujitsu compilers on K computer and ICC.\n# CMake-3.0 also has a bug where the FAIL_REGEX pattern for AIX contains\n# a semicolon. Since this is also used as a separator in lists inside CMake,\n# that string ends up being split into two separate patterns, and the last\n# part is just a single word that also matches other messages. We solved this\n# by replacing the semicolon with a period that matches any character.\n#\n# These files should be removed from the source tree when a CMake version that\n# includes the features in question becomes required for building GROMACS.\ninclude(CheckCCompilerFlag)\ninclude(CheckCXXCompilerFlag)\n\ninclude(gmxCFlags)\ngmx_c_flags()\n\n# This variable should be used for additional compiler flags which are not\n# generated in gmxCFlags nor are SIMD or MPI related.\nset(EXTRA_C_FLAGS \"\")\nset(EXTRA_CXX_FLAGS \"\")\n\n# Run through a number of tests for buggy compilers and other issues\ninclude(gmxTestCompilerProblems)\ngmx_test_compiler_problems()\n# GMX_SIMD will not be set automatically until the second\n# pass (which is not strictly guaranteed to occur), so putting this\n# check here among logically-related tests is inefficient, but the\n# potential loss is likely zero.\nif(GMX_SIMD STREQUAL \"AVX_256\"\n        AND CMAKE_COMPILER_IS_GNUCC\n        AND (C_COMPILER_VERSION VERSION_EQUAL \"4.6.1\"\n            OR CXX_COMPILER_VERSION VERSION_EQUAL \"4.6.1\"))\n    message(FATAL_ERROR \"gcc 4.6.1 has buggy support for AVX, and GROMACS mdrun will not work. If you want simulation performance, use a more recent compiler. Otherwise, use GMX_SIMD=SSE4.1\")\n    # See http://gcc.gnu.org/bugzilla/show_bug.cgi?id=49002\nendif()\n\n\nif(GMX_DOUBLE)\n    add_definitions(-DGMX_DOUBLE)\n    list(APPEND INSTALLED_HEADER_DEFINITIONS \"-DGMX_DOUBLE\")\n    if(GMX_RELAXED_DOUBLE_PRECISION)\n        add_definitions(-DGMX_RELAXED_DOUBLE_PRECISION)\n    endif()\nendif()\nif(GMX_SOFTWARE_INVSQRT)\n    list(APPEND INSTALLED_HEADER_DEFINITIONS \"-DGMX_SOFTWARE_INVSQRT\")\nendif()\n\nif(WIN32)\n    list(APPEND GMX_EXTRA_LIBRARIES \"wsock32\")\n    add_definitions(-DGMX_HAVE_WINSOCK)\nendif()\n\n\n\n########################################################################\n# Basic system tests (standard libraries, headers, functions, types)   #\n########################################################################\ninclude(CheckIncludeFiles)\ninclude(CheckIncludeFileCXX)\ncheck_include_files(unistd.h     HAVE_UNISTD_H)\ncheck_include_files(pwd.h        HAVE_PWD_H)\ncheck_include_files(dirent.h     HAVE_DIRENT_H)\ncheck_include_files(time.h       HAVE_TIME_H)\ncheck_include_files(sys/time.h   HAVE_SYS_TIME_H)\ncheck_include_files(io.h         HAVE_IO_H)\ncheck_include_files(sched.h      HAVE_SCHED_H)\n\ncheck_include_files(regex.h      HAVE_POSIX_REGEX)\n# TODO: It could be nice to inform the user if no regex support is found,\n# as selections won't be fully functional.\n\ninclude(CheckCXXSymbolExists)\ncheck_cxx_symbol_exists(posix_memalign    stdlib.h     HAVE_POSIX_MEMALIGN)\ncheck_cxx_symbol_exists(memalign          stdlib.h     HAVE_MEMALIGN)\ncheck_cxx_symbol_exists(_aligned_malloc   stdlib.h     HAVE__ALIGNED_MALLOC)\ncheck_cxx_symbol_exists(gettimeofday      sys/time.h   HAVE_GETTIMEOFDAY)\ncheck_cxx_symbol_exists(sysconf           unistd.h     HAVE_SYSCONF)\ncheck_cxx_symbol_exists(nice              unistd.h     HAVE_NICE)\ncheck_cxx_symbol_exists(fsync             unistd.h     HAVE_FSYNC)\ncheck_cxx_symbol_exists(_fileno           stdio.h      HAVE__FILENO)\ncheck_cxx_symbol_exists(fileno            stdio.h      HAVE_FILENO)\ncheck_cxx_symbol_exists(_commit           io.h         HAVE__COMMIT)\ncheck_cxx_symbol_exists(sigaction         signal.h     HAVE_SIGACTION)\ncheck_cxx_symbol_exists(rsqrt             math.h       HAVE_RSQRT)\ncheck_cxx_symbol_exists(rsqrtf            math.h       HAVE_RSQRTF)\ncheck_cxx_symbol_exists(sqrtf             math.h       HAVE_SQRTF)\n\ninclude(CheckLibraryExists)\nfind_library(HAVE_LIBM m)\ncheck_library_exists(rt clock_gettime \"\" HAVE_CLOCK_GETTIME)\ncheck_library_exists(m feenableexcept \"\" HAVE_FEENABLEEXCEPT)\n\ninclude(TestSchedAffinity)\ntest_sched_affinity(HAVE_SCHED_AFFINITY)\n\ninclude(TestBigEndian)\ntest_big_endian(GMX_INTEGER_BIG_ENDIAN)\n\nset(GMX_USE_NICE 0)\nif (HAVE_UNISTD_H AND HAVE_NICE)\n    set(GMX_USE_NICE 1)\nendif()\n\n# Management of GROMACS options for specific toolchains should go\n# here. Because the initial settings for some of the main options have\n# already happened, but things like library detection and MPI compiler\n# feature detection have not, the docstrings for any over-rides of\n# GROMACS defaults or user settings will make sense. Also, any\n# toolchain-related reasons for choosing whether to detect various\n# things can be sorted out now, before the detection takes place.\nif(${CMAKE_SYSTEM_NAME} MATCHES BlueGene)\n    include(gmxManageBlueGene)\nendif()\n\nif(GMX_TARGET_FUJITSU_SPARC64)\n    include(gmxManageFujitsuSparc64)\nendif()\n\n########################################################################\n#Process MPI settings\n########################################################################\ninclude(gmxManageMPI)\n\n\n########################################################################\n#Process shared/static library settings\n########################################################################\ninclude(gmxManageSharedLibraries)\n\n\n########################################################################\n# Find external packages                                               #\n########################################################################\n\n# TNG wants zlib if it is available. And static libxml2 might have a dependency\nfind_package(ZLIB QUIET)\ninclude(gmxTestZLib)\ngmx_test_zlib(HAVE_ZLIB)\n\n# Unconditionally find the package, as it is also required for unit\n# tests. This exports LIBXML2_FOUND, which we should not use because\n# it does not tell us that linking will succeed. Instead, we test that\n# next.\nif(DEFINED LIBXML2_LIBRARIES)\n  set(LibXml2_FIND_QUIETLY TRUE)\nendif()\nfind_package(LibXml2)\ninclude(gmxTestLibXml2)\ngmx_test_libxml2(HAVE_LIBXML2)\noption(GMX_XML \"Use libxml2 to parse xml files (currently has no effect)\" ${HAVE_LIBXML2})\nset(PKG_XML \"\")\nmark_as_advanced(GMX_XML)\n# Don't actually do anything, since libxml2 is currently not used by libgromacs\n#if(GMX_XML AND NOT HAVE_LIBXML2)\n#    message(FATAL_ERROR \"libxml2 not found. Set GMX_XML=OFF to compile without XML support\")\n#endif()\n#if(GMX_XML)\n#    include_directories(${LIBXML2_INCLUDE_DIR})\n#    set(PKG_XML libxml-2.0)\n#    set(XML_LIBRARIES ${LIBXML2_LIBRARIES})\n#endif()\n\noption(GMX_EXTRAE \"Add support for tracing using EXTRAE\" OFF)\nmark_as_advanced(GMX_EXTRAE)\n\nif (GMX_EXTRAE)\n  find_package(EXTRAE)\n  if(EXTRAE_FOUND)\n    include_directories(SYSTEM ${EXTRAE_INCLUDE_DIR})\n    set(HAVE_EXTRAE 1)\n  else()\n    message(FATAL_ERROR \"EXTRAE library was not found. Please add the correct path to CMAKE_PREFIX_PATH\")\n  endif()\nendif()\n\noption(GMX_X11 \"Use X window system\" OFF)\nif (GMX_X11)\n    find_package(X11)\n    # X11 includes/libraries are only set in the ngmx subdirectory!\n    if(NOT X11_FOUND)\n        message(FATAL_ERROR\n                \"X11 include files and/or libraries were not found. \"\n                \"Set GMX_X11=OFF to compile without X11 support. \"\n                \"gmx view will not be available.\")\n    endif()\n    include_directories(SYSTEM ${X11_INCLUDE_DIR})\nendif()\n\ninclude(ThreadMPI)\n# Enable core threading facilities\ntmpi_enable_core(\"${CMAKE_SOURCE_DIR}/src/external/thread_mpi/include\")\n# Enable tMPI C++ support\ntmpi_enable_cxx()\nif(GMX_THREAD_MPI)\n    # enable MPI functions\n    tmpi_enable()\n    set(MPI_IN_PLACE_EXISTS 1)\nendif()\n# If atomics are manually disabled a define is needed because atomics.h doesn't depend on config.h\nif (TMPI_ATOMICS_DISABLED)\n   add_definitions(-DTMPI_ATOMICS_DISABLED)\nendif()\n\nif(GMX_GPU)\n    # now that we have detected the dependencies, do the second configure pass\n    gmx_gpu_setup()\nendif()\n\nif(CYGWIN)\n    set(GMX_CYGWIN 1)\nendif()\n\nif(WIN32)\n    set(GMX_NATIVE_WINDOWS 1)\n    # This makes windows.h not declare min/max as macros that would break\n    # C++ code using std::min/std::max.\n    add_definitions(-DNOMINMAX)\nendif()\n\nif(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\") #Work-around for cmake bug #10837\n    if (CMAKE_COMPILER_IS_GNUCC OR CMAKE_C_COMPILER_ID MATCHES \"Intel\" OR CMAKE_C_COMPILER_ID MATCHES \"Clang\")\n        set(CMAKE_INCLUDE_SYSTEM_FLAG_C \"-isystem \")\n    endif()\n    if (CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES \"Intel\" OR CMAKE_CXX_COMPILER_ID MATCHES \"Clang\")\n        set(CMAKE_INCLUDE_SYSTEM_FLAG_CXX \"-isystem \")\n    endif()\nendif()\n\n# Detect boost unless GMX_EXTERNAL_BOOST is explicitly OFF\n# Used for default if GMX_EXTERNAL_BOOST is not defined (first CMake pass)\nif(NOT DEFINED GMX_EXTERNAL_BOOST OR GMX_EXTERNAL_BOOST)\n    if(DEFINED Boost_INCLUDE_DIR)\n        set(Boost_FIND_QUIETLY TRUE)\n    endif()\n    find_package(Boost 1.44.0)\n    if(Boost_FOUND AND Boost_VERSION VERSION_LESS \"104400\")\n        set(Boost_FOUND FALSE)\n    endif()\n    # Print the notification only on first run, when determining the default\n    if(NOT DEFINED GMX_EXTERNAL_BOOST AND NOT Boost_FOUND)\n        message(\"Boost >= 1.44 not found. Using minimal internal version. \"\n                \"This may cause trouble if you plan on compiling/linking other \"\n                \"software that uses Boost against GROMACS.\")\n    endif()\nendif()\noption(GMX_EXTERNAL_BOOST \"Use external Boost instead of minimal built-in version\"\n       ${Boost_FOUND})\nif(GMX_EXTERNAL_BOOST AND NOT Boost_FOUND)\n    message(FATAL_ERROR\n        \"Boost >= 1.44 not found. \"\n        \"You can set GMX_EXTERNAL_BOOST=OFF to compile against minimal \"\n        \"version of Boost included with GROMACS.\")\nendif()\n\nif(NOT DEFINED GMX_BUILD_UNITTESTS AND NOT HAVE_LIBXML2)\n    message(WARNING \"libxml2 not found. Will build GROMACS without unit-tests. This is not recommended, because the unit-tests help to verify that GROMACS functions correctly. Most likely you are missing the libxml2-dev(el) package. After you installed it, set GMX_BUILD_UNITTESTS=ON.\")\nendif()\noption(GMX_BUILD_UNITTESTS \"Build unit tests with BUILD_TESTING (uses Google C++ Testing and Mocking Frameworks, requires libxml2)\" ${HAVE_LIBXML2})\nmark_as_advanced(GMX_BUILD_UNITTESTS)\ngmx_add_cache_dependency(GMX_BUILD_UNITTESTS BOOL BUILD_TESTING OFF)\nif (GMX_BUILD_UNITTESTS AND NOT HAVE_LIBXML2)\n    message(FATAL_ERROR\n        \"Cannot build unit tests without libxml2. \"\n        \"Either set GMX_BUILD_UNITTESTS=OFF or tell CMake how to find a working version of libxml2.\")\nendif()\n\n########################################################################\n# Our own GROMACS tests\n########################################################################\n\nadd_definitions( -DHAVE_CONFIG_H )\ninclude_directories(BEFORE ${CMAKE_SOURCE_DIR}/src)\ninclude_directories(BEFORE ${CMAKE_SOURCE_DIR}/src/external/thread_mpi/include)\n# Required for config.h, maybe should only be set in src/CMakeLists.txt\ninclude_directories(BEFORE ${CMAKE_BINARY_DIR}/src)\n\ninclude(gmxTestInlineASM)\ngmx_test_inline_asm_gcc_x86(GMX_X86_GCC_INLINE_ASM)\n\ninclude(gmxSetBuildInformation)\ngmx_set_build_information()\n# Turn on RDTSCP if:\n# - the build system's CPU supports it\n# - the acceleration is set to AVX as all AVX-capable CPUs support AVX (which\n#   at this point means that the user set it).\n# Note: it's better to not use the later set value of GMX_SIMD because\n# it reflects the system's capability of both compiling and running AVX code.\n# TODO: After merge with 5.0 one could implement a cache variable dependency\n# such that GMX_USE_RDTSCP can change if GMX_SIMD is changed to AVX\n# after the first cmake pass.\nif (BUILD_CPU_FEATURES MATCHES \"rdtscp\" OR GMX_SIMD MATCHES \"AVX\")\n    set(GMX_USE_RDTSCP_DEFAULT_VALUE ON)\nelse()\n    set(GMX_USE_RDTSCP_DEFAULT_VALUE OFF)\nendif()\noption(GMX_USE_RDTSCP \"Use RDTSCP for better CPU-based timers (available on recent x86 CPUs; might need to be off when compiling for heterogeneous environments)\" ${GMX_USE_RDTSCP_DEFAULT_VALUE})\nmark_as_advanced(GMX_USE_RDTSCP)\nif(GMX_USE_RDTSCP)\n    set(HAVE_RDTSCP 1)\nendif()\n\ninclude(gmxTestFloatFormat)\ngmx_test_float_format(GMX_FLOAT_FORMAT_IEEE754\n                      GMX_IEEE754_BIG_ENDIAN_BYTE_ORDER\n                      GMX_IEEE754_BIG_ENDIAN_WORD_ORDER)\n\ninclude(gmxTestLargeFiles)\ngmx_test_large_files(GMX_LARGEFILES)\n\ninclude(gmxTestSignal)\ngmx_test_sigusr1(HAVE_SIGUSR1)\n\ninclude(gmxTestPipes)\ngmx_test_pipes(HAVE_PIPES)\n\ninclude(gmxTestIsfinite)\ngmx_test_isfinite(HAVE_ISFINITE)\ngmx_test__isfinite(HAVE__ISFINITE)\ngmx_test__finite(HAVE__FINITE)\n\ninclude(gmxTestCXX11)\ngmx_test_cxx11(GMX_CXX11_SUPPORTED GMX_CXX11_FLAGS)\ninclude(CMakeDependentOption)\n# clang with some older versions of boost fail to work with C++11\nif(CMAKE_CXX_COMPILER_ID MATCHES Clang AND\n    (Boost_VERSION VERSION_EQUAL 104601 OR Boost_VERSION VERSION_EQUAL 104700))\n    set(CLANG_AND_OLD_EXTERNAL_BOOST TRUE)\nendif()\n# nvcc does not support C++11 flags, so with GPUs we prefer to skip C++11 flags\n# entirely to keep the compilation environment uniform.\ncmake_dependent_option(GMX_CXX11\n    \"Use C++11 features\"\n    ON \"GMX_CXX11_SUPPORTED AND NOT GMX_GPU AND NOT CLANG_AND_OLD_EXTERNAL_BOOST\" OFF)\nmark_as_advanced(GMX_CXX11)\nif(GMX_CXX11)\n    set(EXTRA_CXX_FLAGS \"${EXTRA_CXX_FLAGS} ${GMX_CXX11_FLAGS}\")\nendif()\n\n# Now we can test for CXX11_REGEX include file\ncheck_include_file_cxx(regex     HAVE_CXX11_REGEX)\n\ninclude(gmxTestXDR)\ngmx_test_xdr(GMX_SYSTEM_XDR)\nif(NOT GMX_SYSTEM_XDR)\n    set(GMX_INTERNAL_XDR 1)\nendif()\n\n\n##################################################\n# Process SIMD instruction settings\n##################################################\n# This checks what flags to add in order to\n# support the SIMD instructions we need, it sets\n# correct defines for the SIMD instructions supported,\n# and adds advanced options to control accuracy\n# for SIMD math operations.\ninclude(gmxManageSimd)\ngmx_manage_simd()\n\n# Process QM/MM Settings\nif(${GMX_QMMM_PROGRAM} STREQUAL \"GAUSSIAN\")\n    set(GMX_QMMM_GAUSSIAN 1)\nelseif(${GMX_QMMM_PROGRAM} STREQUAL \"MOPAC\")\n    set(GMX_QMMM_MOPAC 1)\nelseif(${GMX_QMMM_PROGRAM} STREQUAL \"GAMESS\")\n    set(GMX_QMMM_GAMESS 1)\nelseif(${GMX_QMMM_PROGRAM} STREQUAL \"ORCA\")\n    set(GMX_QMMM_ORCA 1)\nelseif(${GMX_QMMM_PROGRAM} STREQUAL \"NONE\")\n    # nothing to do\nelse()\n    gmx_invalid_option_value(GMX_QMMM_PROGRAM)\nendif()\n\n\n##################################################\n# Process FFT library settings\n##################################################\ninclude(gmxManageFFTLibraries)\n\n\ninclude(gmxManageLinearAlgebraLibraries)\n\n# Whether GROMACS will really try to compile support for VMD plugins\nset(GMX_USE_PLUGINS OFF)\n\nif(GMX_LOAD_PLUGINS)\n  if(NOT WIN32)\n    # Native Windows does not have, nor need dlopen\n    include(gmxTestdlopen)\n    gmx_test_dlopen(HAVE_DLOPEN)\n  endif()\n\n  # so, should we use plug-ins?\n  if(WIN32 OR (HAVE_DLOPEN AND BUILD_SHARED_LIBS))\n    if(NOT VMD_QUIETLY)\n      MESSAGE(STATUS \"Using dynamic plugins (e.g VMD-supported file formats)\")\n    endif()\n    if(NOT GMX_VMD_PLUGIN_PATH)\n      find_package(VMD)\n    endif()\n    set(GMX_USE_PLUGINS ON)\n    list(APPEND GMX_EXTRA_LIBRARIES ${CMAKE_DL_LIBS}) # magic cross-platform pre-set variable for dlopen library\n    set(PKG_DL_LIBS \"-l${CMAKE_DL_LIBS}\")\n  else()\n    set(PKG_DL_LIBS)\n  endif()\nendif()\nset(VMD_QUIETLY TRUE CACHE INTERNAL \"\")\n\n# Link real-time library for POSIX timers. The check for clock_gettime\n# confirms the linkability of rt.\nif(HAVE_TIME_H AND HAVE_UNISTD_H AND HAVE_CLOCK_GETTIME)\n    list(APPEND GMX_EXTRA_LIBRARIES rt)\nendif()\n\n# Math and thread libraries must often come after all others when linking...\nif(HAVE_LIBM)\n    list(APPEND GMX_EXTRA_LIBRARIES m)\nendif()\n\noption(GMX_NACL \"Configure for Native Client builds\" OFF)\nif (GMX_NACL)\n  list(APPEND GMX_EXTRA_LIBRARIES nosys)\n  set(GMX_EXE_LINKER_FLAGS \"${CMAKE_EXE_LINKER_FLAGS} -lnosys\")\n  # TODO: Is this still necessary with the check for its presence?\n  set(GMX_USE_NICE 0)\n  set(GMX_NO_RENAME 1)\nendif()\nmark_as_advanced(GMX_NACL)\n\nif(GMX_FAHCORE)\n  set(COREWRAP_INCLUDE_DIR \"${CMAKE_SOURCE_DIR}/../corewrap\" CACHE STRING\n      \"Path to swindirect.h\")\n  include_directories(${COREWRAP_INCLUDE_DIR})\nendif()\n\n# Value of GMX_BUILD_HELP=AUTO tries to generate things, but will only\n# produce warnings if that fails.\nset(build_help_default AUTO)\nif (SOURCE_IS_SOURCE_DISTRIBUTION OR CMAKE_CROSSCOMPILING)\n    set(build_help_default OFF)\nendif()\ngmx_option_trivalue(GMX_BUILD_HELP \"Build completions automatically (requires that compiled binaries can be executed on the build host) and install man pages if built (requires building the 'man' target manually)\" ${build_help_default})\nmark_as_advanced(GMX_BUILD_HELP)\nif (GMX_BUILD_HELP AND SOURCE_IS_SOURCE_DISTRIBUTION AND BUILD_IS_INSOURCE)\n    message(FATAL_ERROR\n        \"Rebuilding shell completions or man pages is not supported for \"\n        \"in-source builds from a source distribution. \"\n        \"Set GMX_BUILD_HELP=OFF or do an out-of-source build to proceed.\")\nendif()\n\n# # # # # # # # # # NO MORE TESTS AFTER THIS LINE! # # # # # # # # # # #\n# these are set after everything else\nif (NOT GMX_SKIP_DEFAULT_CFLAGS)\n    set(CMAKE_C_FLAGS \"${SIMD_C_FLAGS} ${MPI_COMPILE_FLAGS} ${EXTRA_C_FLAGS} ${CMAKE_C_FLAGS}\")\n    set(CMAKE_CXX_FLAGS \"${SIMD_CXX_FLAGS} ${MPI_COMPILE_FLAGS} ${EXTRA_CXX_FLAGS} ${CMAKE_CXX_FLAGS}\")\n    set(CMAKE_EXE_LINKER_FLAGS \"${FFT_LINKER_FLAGS} ${MPI_LINKER_FLAGS} ${CMAKE_EXE_LINKER_FLAGS}\")\n    set(CMAKE_SHARED_LINKER_FLAGS \"${FFT_LINKER_FLAGS} ${MPI_LINKER_FLAGS} ${CMAKE_SHARED_LINKER_FLAGS}\")\nelse()\n    message(\"Recommended flags which are not added because GMX_SKIP_DEFAULT_CFLAGS=yes:\")\n    message(\"CMAKE_C_FLAGS: ${SIMD_C_FLAGS} ${MPI_COMPILE_FLAGS} ${EXTRA_C_FLAGS} ${GMXC_CFLAGS}\")\n    message(\"CMAKE_C_FLAGS_RELEASE: ${GMXC_CFLAGS_RELEASE}\")\n    message(\"CMAKE_C_FLAGS_DEBUG: ${GMXC_CFLAGS_DEBUG}\")\n    message(\"CMAKE_CXX_FLAGS: ${SIMD_CXX_FLAGS} ${MPI_COMPILE_FLAGS} ${EXTRA_CXX_FLAGS} ${GMXC_CXXFLAGS}\")\n    message(\"CMAKE_CXX_FLAGS_RELEASE: ${GMXC_CXXFLAGS_RELEASE}\")\n    message(\"CMAKE_CXX_FLAGS_DEBUG: ${GMXC_CXXFLAGS_DEBUG}\")\n    message(\"CMAKE_EXE_LINKER_FLAGS: ${FFT_LINKER_FLAGS} ${MPI_LINKER_FLAGS}\")\n    message(\"CMAKE_SHARED_LINKER_FLAGS: ${MPI_LINKER_FLAGS}\")\nendif()\n\nif(NOT GMX_OPENMP)\n    #Unset all OpenMP flags in case OpenMP was disabled either by the user\n    #or because it was only partially detected (e.g. only for C but not C++ compiler)\n    unset(OpenMP_C_FLAGS CACHE)\n    unset(OpenMP_CXX_FLAGS CACHE)\nelse()\n    set(GMX_EXE_LINKER_FLAGS ${GMX_EXE_LINKER_FLAGS} ${OpenMP_LINKER_FLAGS})\n    set(GMX_SHARED_LINKER_FLAGS ${GMX_SHARED_LINKER_FLAGS} ${OpenMP_SHARED_LINKER_FLAGS})\nendif()\n\n########################################################################\n# Specify install locations\n########################################################################\n# Use GNUInstallDirs to set paths on multiarch systems.\ninclude(GNUInstallDirs)\n\n# Customization for the installation tree paths.\nset(GMX_LIB_INSTALL_DIR ${CMAKE_INSTALL_LIBDIR} CACHE STRING\n    \"Library installation directory (default: ${CMAKE_INSTALL_LIBDIR})\")\nset(GMX_DATA_INSTALL_DIR gromacs CACHE STRING\n    \"Data installation directory under share/ (default: gromacs)\")\nmark_as_advanced(GMX_LIB_INSTALL_DIR GMX_DATA_INSTALL_DIR)\n\n# These variables are used internally to provide a central location for\n# customizing the install locations.\nset(LIB_INSTALL_DIR       ${GMX_LIB_INSTALL_DIR})\nset(BIN_INSTALL_DIR       bin)\n# This variable also gets written into config.h for use in finding the data\n# directories.\nset(DATA_INSTALL_DIR      share/${GMX_DATA_INSTALL_DIR})\nset(MAN_INSTALL_DIR       share/man)\n# If the nesting level wrt. the installation root is changed,\n# gromacs-config.cmake.cmakein needs to be adapted.\nset(CMAKE_INSTALL_DIR     share/cmake)\n# TODO: Make GMXRC adapt if this is changed\nset(PKGCONFIG_INSTALL_DIR ${LIB_INSTALL_DIR}/pkgconfig)\nset(OCL_INSTALL_DIR       ${DATA_INSTALL_DIR}/opencl)\nset(INCL_INSTALL_DIR      include)\n\nlist(APPEND INSTALLED_HEADER_INCLUDE_DIRS ${INCL_INSTALL_DIR})\n\n# Binary and library suffix options\ninclude(gmxManageSuffixes)\n\n################################################################\n# Shared library load path settings\n################################################################\n# CMake supports RPATH on OS X only from 2.8.12 upwards.\n# CMAKE_SYSTEM_VERSION > 8.0 matches OS X 10.5 and above, where RPATH support\n# was added.\n\nif(NOT GMX_BUILD_SHARED_EXE)\n    # No rpath\n    set(CMAKE_SKIP_RPATH TRUE)\n    set(CMAKE_EXE_LINK_DYNAMIC_C_FLAGS) # remove -Wl,-Bdynamic\n    set(CMAKE_EXE_LINK_DYNAMIC_CXX_FLAGS)\nelseif((NOT CMAKE_SYSTEM_NAME STREQUAL \"Darwin\") OR\n   ((CMAKE_SYSTEM_VERSION VERSION_GREATER 8.0) AND (NOT CMAKE_VERSION VERSION_LESS 2.8.12)))\n    # The build folder always has bin/ and lib/; if we are also going to\n    # install to lib/, then the installation RPATH works also in the build\n    # tree.  This makes installation slightly faster (no need to rewrite the\n    # RPATHs), and makes the binaries in the build tree relocatable.\n    if(GMX_LIB_INSTALL_DIR STREQUAL \"lib\")\n        set(CMAKE_BUILD_WITH_INSTALL_RPATH TRUE)\n    endif()\n    # Set the RPATH as relative to the executable location to make the\n    # binaries relocatable.\n    if(NOT CMAKE_SYSTEM_NAME STREQUAL \"Darwin\")\n        set(CMAKE_INSTALL_RPATH \"\\$ORIGIN/../${GMX_LIB_INSTALL_DIR}\")\n    else()\n        set(CMAKE_INSTALL_RPATH \"@executable_path/../${GMX_LIB_INSTALL_DIR}\")\n    endif()\n    set(CMAKE_INSTALL_RPATH_USE_LINK_PATH TRUE)\n    set(CMAKE_MACOSX_RPATH 1)\nelse()\n    # We are on Darwin/OSX, and CMake cannot handle RPATHs automatically.\n    if(CMAKE_SYSTEM_VERSION VERSION_GREATER 8.0)\n        # Set the RPATH options manually.\n        set(CMAKE_INSTALL_NAME_DIR \"@rpath\")\n        set(GMX_EXE_LINKER_FLAGS ${GMX_EXE_LINKER_FLAGS} \"-Wl,-rpath,@executable_path/../${GMX_LIB_INSTALL_DIR}\")\n    else()\n        # Use the old INSTALL_NAME_DIR mechanism if RPATH is not supported.\n        set(CMAKE_INSTALL_NAME_DIR \"${CMAKE_INSTALL_PREFIX}/${LIB_INSTALL_DIR}\")\n    endif()\nendif()\n\n#COPYING file: Only necessary for binary distributions.\n#Simpler to always install.\ninstall(FILES COPYING DESTINATION ${DATA_INSTALL_DIR} COMPONENT data)\n\nif(GMX_EXTERNAL_BOOST)\n    include_directories(SYSTEM ${Boost_INCLUDE_DIRS})\n    list(APPEND INSTALLED_HEADER_INCLUDE_DIRS ${Boost_INCLUDE_DIRS})\nelse()\n    include_directories(BEFORE SYSTEM ${CMAKE_SOURCE_DIR}/src/external/boost)\n    list(APPEND INSTALLED_HEADER_INCLUDE_DIRS ${INCL_INSTALL_DIR}/gromacs/external/boost)\n    list(APPEND INSTALLED_HEADED_DEFINITIONS \"-DBOOST_NO_TYPEID\")\n    # typeid not supported for minimal internal version\n    # (would add significant amount of code)\n    add_definitions(-DBOOST_NO_TYPEID)\n    if (NOT GMX_BUILD_MDRUN_ONLY)\n        install(DIRECTORY ${CMAKE_SOURCE_DIR}/src/external/boost/boost\n                DESTINATION ${INCL_INSTALL_DIR}/gromacs/external/boost\n                COMPONENT development)\n    endif()\nendif()\n\nif (GMX_BUILD_FOR_COVERAGE)\n    # Code heavy with asserts makes conditional coverage close to useless metric,\n    # as by design most of the false branches are impossible to trigger in\n    # correctly functioning code.  And the benefit of testing those that could\n    # be triggered by using an API against its specification isn't usually\n    # worth the effort.\n    add_definitions(-DNDEBUG -DBOOST_DISABLE_ASSERTS -DGMX_DISABLE_ASSERTS)\nendif()\n\nif (BUILD_TESTING)\n    # \"tests\" target builds all the separate test binaries.\n    add_custom_target(tests)\n    # \"run-ctest\" is an internal target that actually runs the tests.\n    # This is necessary to be able to add separate targets that execute as part\n    # of 'make check', but are ensured to be executed after the actual tests.\n    add_custom_target(run-ctest\n                      COMMAND ${CMAKE_CTEST_COMMAND} --output-on-failure\n                      COMMENT \"Running all tests\"\n                      VERBATIM)\n    add_dependencies(run-ctest tests)\n    # \"check\" target builds and runs all tests.\n    add_custom_target(check DEPENDS run-ctest)\nendif()\n\nif (NOT GMX_BUILD_MDRUN_ONLY)\n    add_subdirectory(docs)\n    add_subdirectory(share)\n    add_subdirectory(scripts)\nendif()\nadd_subdirectory(src)\n\nif (BUILD_TESTING)\n    add_subdirectory(tests)\nendif()\n\ngmx_cpack_write_config()\n\n# Issue a warning if NVIDIA GPUs were detected, but CUDA was not found.\n# Don't bother the user after the first configure pass.\nif ((CUDA_NOTFOUND_AUTO AND GMX_DETECT_GPU_AVAILABLE) AND NOT GMX_GPU_DETECTION_DONE)\n    message(WARNING \"${CUDA_NOTFOUND_MESSAGE}\")\nendif()\nset(GMX_GPU_DETECTION_DONE TRUE CACHE INTERNAL \"Whether GPU detection has already been done\")\n\n#######################\n## uninstall target\n#######################\nCONFIGURE_FILE(   \"${CMAKE_CURRENT_SOURCE_DIR}/cmake/cmake_uninstall.cmake.in\"\n                  \"${CMAKE_CURRENT_BINARY_DIR}/cmake/cmake_uninstall.cmake\"\n                  IMMEDIATE @ONLY)\n###########################\nADD_CUSTOM_TARGET(uninstall\n                  \"${CMAKE_COMMAND}\" -P\n                  \"${CMAKE_CURRENT_BINARY_DIR}/cmake/cmake_uninstall.cmake\")\n###########################\nset_directory_properties(PROPERTIES\n            ADDITIONAL_MAKE_CLEAN_FILES \"install_manifest.txt\")\n",
        "/tmp/vanessa/spack-stage/spack-stage-gromacs-5.1.2-tz5blkl5h4hbtzrte7ypqrgwjwhftnur/spack-src/src/external/vmd_molfile/vmddlopen.c": "/* -*- mode: c; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4; c-file-style: \"stroustrup\"; -*-\n *\n * \n * This file is part of Gromacs        Copyright (c) 1991-2008\n * David van der Spoel, Erik Lindahl, Berk Hess, University of Groningen.\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * To help us fund GROMACS development, we humbly ask that you cite\n * the research papers on the package. Check out http://www.gromacs.org\n * \n * And Hey:\n * Gnomes, ROck Monsters And Chili Sauce\n */\n\n/***************************************************************************\n *cr\n *cr            (C) Copyright 1995-2009 The Board of Trustees of the\n *cr                        University of Illinois\n *cr                         All Rights Reserved\n *cr\nDeveloped by:           Theoretical and Computational Biophysics Group\n                        University of Illinois at Urbana-Champaign\n                        http://www.ks.uiuc.edu/\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the Software), to deal with\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to\ndo so, subject to the following conditions:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimers.\n\nRedistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimers in the documentation\nand/or other materials provided with the distribution.\n\nNeither the names of Theoretical and Computational Biophysics Group,\nUniversity of Illinois at Urbana-Champaign, nor the names of its contributors\nmay be used to endorse or promote products derived from this Software without\nspecific prior written permission.\n\nTHE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\nTHE CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR\nOTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\nARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS WITH THE SOFTWARE.\n ***************************************************************************/\n\n/***************************************************************************\n * RCS INFORMATION:\n *\n *      $RCSfile: vmddlopen.c,v $\n *      $Author: johns $        $Locker:  $             $State: Exp $\n *      $Revision: 1.18 $      $Date: 2009/07/07 02:40:05 $\n *\n ***************************************************************************\n * DESCRIPTION:\n *   Routines for loading dynamic link libraries and shared object files\n *   on various platforms, abstracting from machine dependent APIs.\n *\n ***************************************************************************/\n\n#include <stdio.h> \n#include <stdlib.h>\n#include <string.h>\n#include \"vmddlopen.h\"\n\n#if defined(__hpux)\n\n#include <dl.h>\n#include <errno.h>\n#include <string.h>\n\nvoid *vmddlopen( const char *path) {\n    void *ret;\n    ret = shl_load( path, BIND_IMMEDIATE | BIND_FIRST | BIND_VERBOSE, 0);\n    return ret;\n}\n\nint vmddlclose( void *handle ) {\n    return shl_unload( (shl_t) handle );\n}\n\nvoid *vmddlsym( void *handle, const char *sym ) {\n    void *value=0;\n\n    if ( shl_findsym( (shl_t*)&handle, sym, TYPE_UNDEFINED, &value ) != 0 ) \n\treturn 0;\n    return value;\n}\n\nconst char *vmddlerror( void  ) {\n    return strerror( errno );\n}\n\n#elif 0 && defined(__APPLE__)\n/*\n * This is only needed for MacOS X version 10.3 or older\n */\n#include <mach-o/dyld.h>\n\nvoid *vmddlopen( const char *path) {\n  NSObjectFileImage image;\n  NSObjectFileImageReturnCode retval;\n  NSModule module;\n\n  retval = NSCreateObjectFileImageFromFile(path, &image);\n  if (retval != NSObjectFileImageSuccess)\n    return NULL;\n\n  module = NSLinkModule(image, path,\n            NSLINKMODULE_OPTION_BINDNOW | NSLINKMODULE_OPTION_PRIVATE\n            | NSLINKMODULE_OPTION_RETURN_ON_ERROR);\n  return module;  /* module will be NULL on error */\n}\n\nint vmddlclose( void *handle ) {\n  NSModule module = (NSModule *)handle;\n  NSUnLinkModule(module, NSUNLINKMODULE_OPTION_NONE);\n  return 0;\n}\n\nvoid *vmddlsym( void *handle, const char *symname ) {\n  char *realsymname;\n  NSModule module;\n  NSSymbol sym;\n  /* Hack around the leading underscore in the symbol name */\n  realsymname = (char *)malloc(strlen(symname)+2);\n  strcpy(realsymname, \"_\");\n  strcat(realsymname, symname);\n  module = (NSModule)handle;\n  sym = NSLookupSymbolInModule(module, realsymname);\n  free(realsymname);\n  if (sym) \n    return (void *)(NSAddressOfSymbol(sym));\n  return NULL;\n}\n\nconst char *vmddlerror( void  ) {\n  NSLinkEditErrors c;\n  int errorNumber;\n  const char *fileName;\n  const char *errorString = NULL;\n  NSLinkEditError(&c, &errorNumber, &fileName, &errorString);\n  return errorString;\n}\n\n#elif defined( _WIN32 ) || defined( _WIN64 )\n\n#include <windows.h>\n\nvoid *vmddlopen(const char *fname) {\n  return (void *)LoadLibrary(fname);\n}\n\nconst char *vmddlerror(void) {\n  static CHAR szBuf[80]; \n  DWORD dw = GetLastError(); \n \n  sprintf(szBuf, \"vmddlopen failed: GetLastError returned %lu\\n\", dw);\n  return szBuf;\n}\n\nvoid *vmddlsym(void *h, const char *sym) {\n  return (void *)GetProcAddress((HINSTANCE)h, sym);\n}\n\nint vmddlclose(void *h) {\n  /* FreeLibrary returns nonzero on success */\n  return !FreeLibrary((HINSTANCE)h);\n}\n\n#else\n\n/* All remaining platforms (not Windows, HP-UX, or MacOS X <= 10.3) */\n#include <dlfcn.h>\n\nvoid *vmddlopen(const char *fname) {\n  return dlopen(fname, RTLD_NOW);\n}\nconst char *vmddlerror(void) {\n  return dlerror();\n}\nvoid *vmddlsym(void *h, const char *sym) {\n  return dlsym(h, sym);\n}\nint vmddlclose(void *h) {\n  return dlclose(h);\n}\n#endif \n",
        "/tmp/vanessa/spack-stage/spack-stage-gromacs-5.1.2-tz5blkl5h4hbtzrte7ypqrgwjwhftnur/spack-src/src/external/vmd_molfile/vmdplugin.h": "/* -*- mode: c; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4; c-file-style: \"stroustrup\"; -*-\n *\n * \n * This file is part of Gromacs        Copyright (c) 1991-2008\n * David van der Spoel, Erik Lindahl, Berk Hess, University of Groningen.\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * To help us fund GROMACS development, we humbly ask that you cite\n * the research papers on the package. Check out http://www.gromacs.org\n * \n * And Hey:\n * Gnomes, ROck Monsters And Chili Sauce\n */\n\n/***************************************************************************\n *cr\n *cr            (C) Copyright 1995-2006 The Board of Trustees of the\n *cr                        University of Illinois\n *cr                         All Rights Reserved\n *cr\nDeveloped by:           Theoretical and Computational Biophysics Group\n                        University of Illinois at Urbana-Champaign\n                        http://www.ks.uiuc.edu/\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the Software), to deal with\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to\ndo so, subject to the following conditions:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimers.\n\nRedistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimers in the documentation\nand/or other materials provided with the distribution.\n\nNeither the names of Theoretical and Computational Biophysics Group,\nUniversity of Illinois at Urbana-Champaign, nor the names of its contributors\nmay be used to endorse or promote products derived from this Software without\nspecific prior written permission.\n\nTHE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\nTHE CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR\nOTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\nARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS WITH THE SOFTWARE.\n ***************************************************************************/\n\n/***************************************************************************\n * RCS INFORMATION:\n *\n *      $RCSfile: vmdplugin.h,v $\n *      $Author: johns $       $Locker:  $             $State: Exp $\n *      $Revision: 1.32 $       $Date: 2009/02/24 05:12:35 $\n *\n ***************************************************************************/\n\n/** @file\n * This header must be included by every VMD plugin library.  It defines the\n * API for every plugin so that VMD can organize the plugins it finds.  \n */\n\n#ifndef VMD_PLUGIN_H\n#define VMD_PLUGIN_H\n\n\n/* \n * Preprocessor tricks to make it easier for us to redefine the names of\n * functions when building static plugins.\n */\n#if !defined(VMDPLUGIN)\n/** \n  * macro defining VMDPLUGIN if it hasn't already been set to the name of \n  * a static plugin that is being compiled.  This is the catch-all case.\n  */\n#define VMDPLUGIN vmdplugin\n#endif\n/** concatenation macro, joins args x and y together as a single string */\n#define xcat(x, y) cat(x, y)\n/** concatenation macro, joins args x and y together as a single string */\n#define cat(x, y) x ## y \n\n/*\n *  macros to correctly define plugin function names depending on whether \n *  the plugin is being compiled for static linkage or dynamic loading. \n *  When compiled for static linkage, each plugin needs to have unique\n *  function names for all of its entry points.  When compiled for dynamic\n *  loading, the plugins must name their entry points consistently so that\n *  the plugin loading mechanism can find the register, register_tcl, init,\n *  and fini routines via dlopen() or similar operating system interfaces.\n */\n/*@{*/\n/** Macro names entry points correctly for static linkage or dynamic loading */\n#define VMDPLUGIN_register     xcat(VMDPLUGIN, _register)\n#define VMDPLUGIN_register_tcl xcat(VMDPLUGIN, _register_tcl)\n#define VMDPLUGIN_init         xcat(VMDPLUGIN, _init)\n#define VMDPLUGIN_fini         xcat(VMDPLUGIN, _fini)\n/*@}*/\n\n\n/** \"WIN32\" is defined on both WIN32 and WIN64 platforms... */\n#if (defined(WIN32)) \n#define WIN32_LEAN_AND_MEAN\n#include <windows.h>\n\n#if !defined(STATIC_PLUGIN)\n#if defined(VMDPLUGIN_EXPORTS)\n/** \n *  Only define DllMain for plugins, not in VMD or in statically linked plugins\n *  VMDPLUGIN_EXPORTS is only defined when compiling dynamically loaded plugins\n */\nBOOL APIENTRY DllMain( HANDLE hModule,\n                       DWORD ul_reason_for_call,\n                       LPVOID lpReserved\n                     )\n{\n  return TRUE;\n}\n\n#define VMDPLUGIN_API __declspec(dllexport)\n#else\n#define VMDPLUGIN_API __declspec(dllimport)\n#endif /* VMDPLUGIN_EXPORTS */\n#else  /* ! STATIC_PLUGIN */\n#define VMDPLUGIN_API\n#endif /* ! STATIC_PLUGIN */\n#else\n/** If we're not compiling on Windows, then this macro is defined empty */\n#define VMDPLUGIN_API \n#endif\n\n/** define plugin linkage correctly for both C and C++ based plugins */\n#ifdef __cplusplus\n#define VMDPLUGIN_EXTERN extern \"C\" VMDPLUGIN_API\n#else\n#define VMDPLUGIN_EXTERN extern VMDPLUGIN_API\n#endif  /* __cplusplus */\n\n/* \n * Plugin API functions start here \n */\n\n\n/** \n * Init routine: called the first time the library is loaded by the \n * application and before any other API functions are referenced.\n * Return 0 on success.\n */\nVMDPLUGIN_EXTERN int VMDPLUGIN_init(void);\n\n/**\n * Macro for creating a struct header used in all plugin structures.\n * \n * This header should be placed at the top of every plugin API definition \n * so that it can be treated as a subtype of the base plugin type.\n *\n * abiversion: Defines the ABI for the base plugin type (not for other plugins)\n * type: A string descriptor of the plugin type.\n * name: A name for the plugin.\n * author: A string identifier, possibly including newlines.\n * Major and minor version.  \n * is_reentrant: Whether this library can be run concurrently with itself.\n */\n#define vmdplugin_HEAD \\\n  int abiversion; \\\n  const char *type; \\\n  const char *name; \\\n  const char *prettyname; \\\n  const char *author; \\\n  int majorv; \\\n  int minorv; \\\n  int is_reentrant\n\n/** \n  * Typedef for generic plugin header, individual plugins can\n  * make their own structures as long as the header info remains \n  * the same as the generic plugin header, most easily done by \n  * using the vmdplugin_HEAD macro.\n  */\ntypedef struct {\n  vmdplugin_HEAD;\n} vmdplugin_t;\n\n/**\n * Use this macro to initialize the abiversion member of each plugin\n */\n#define vmdplugin_ABIVERSION  16\n\n/*@{*/\n/** Use this macro to indicate a plugin's thread-safety at registration time */\n#define VMDPLUGIN_THREADUNSAFE 0\n#define VMDPLUGIN_THREADSAFE   1\n/*@}*/\n\n/*@{*/\n/** Error return code for use in the plugin registration and init functions */\n#define VMDPLUGIN_SUCCESS      0\n#define VMDPLUGIN_ERROR       -1\n/*@}*/\n\n/** \n * Function pointer typedef for register callback functions\n */\ntypedef int (*vmdplugin_register_cb)(void *, vmdplugin_t *);\n\n/**\n * Allow the library to register plugins with the application.\n * The callback should be called using the passed-in void pointer, which\n * should not be interpreted in any way by the library.  Each vmdplugin_t\n * pointer passed to the application should point to statically-allocated\n * or heap-allocated memory and should never be later modified by the plugin.\n * Applications must be permitted to retain only a copy of the the plugin\n * pointer, without making any deep copy of the items in the struct.\n */\nVMDPLUGIN_EXTERN int VMDPLUGIN_register(void *, vmdplugin_register_cb);\n\n/**\n * Allow the library to register Tcl extensions.  \n * This API is optional; if found by dlopen, it will be called after first\n * calling init and register.  \n */\nVMDPLUGIN_EXTERN int VMDPLUGIN_register_tcl(void *, void *tcl_interp, \n    vmdplugin_register_cb);\n\n/**\n * The Fini method is called when the application will no longer use \n * any plugins in the library.  \n */\nVMDPLUGIN_EXTERN int VMDPLUGIN_fini(void);\n\n#endif   /* VMD_PLUGIN_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gromacs-5.1.2-tz5blkl5h4hbtzrte7ypqrgwjwhftnur/spack-src/src/external/vmd_molfile/vmddlopen.h": "/* -*- mode: c; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4; c-file-style: \"stroustrup\"; -*-\n *\n * \n * This file is part of Gromacs        Copyright (c) 1991-2008\n * David van der Spoel, Erik Lindahl, Berk Hess, University of Groningen.\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * To help us fund GROMACS development, we humbly ask that you cite\n * the research papers on the package. Check out http://www.gromacs.org\n * \n * And Hey:\n * Gnomes, ROck Monsters And Chili Sauce\n */\n\n/***************************************************************************\n *cr\n *cr            (C) Copyright 1995-2009 The Board of Trustees of the\n *cr                        University of Illinois\n *cr                         All Rights Reserved\n *cr\nDeveloped by:           Theoretical and Computational Biophysics Group\n                        University of Illinois at Urbana-Champaign\n                        http://www.ks.uiuc.edu/\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the Software), to deal with\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to\ndo so, subject to the following conditions:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimers.\n\nRedistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimers in the documentation\nand/or other materials provided with the distribution.\n\nNeither the names of Theoretical and Computational Biophysics Group,\nUniversity of Illinois at Urbana-Champaign, nor the names of its contributors\nmay be used to endorse or promote products derived from this Software without\nspecific prior written permission.\n\nTHE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\nTHE CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR\nOTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\nARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS WITH THE SOFTWARE.\n ***************************************************************************/\n\n/***************************************************************************\n * RCS INFORMATION:\n *\n *      $RCSfile: vmddlopen.h,v $\n *      $Author: johns $        $Locker:  $             $State: Exp $\n *      $Revision: 1.9 $      $Date: 2009/07/07 02:40:05 $\n *\n ***************************************************************************\n * DESCRIPTION:\n *   Routines for loading dynamic link libraries and shared object files\n *   on various platforms, abstracting from machine dependent APIs.\n *\n * LICENSE:\n *   UIUC Open Source License \n *   http://www.ks.uiuc.edu/Research/vmd/plugins/pluginlicense.html\n *\n ***************************************************************************/\n\n/*\n * vmddlopen: thin multi-platform wrapper around dlopen/LoadLibrary\n */\n\n#ifndef VMD_DLOPEN__\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* Try to open the specified library.  All symbols must be resolved or the \n * load will fail (RTLD_NOW).  \n */\nvoid *vmddlopen(const char *fname);\n\n/* Try to load the specified symbol using the given handle.  Returns NULL if \n * the symbol cannot be loaded.\n */\nvoid *vmddlsym(void *h, const char *sym);\n\n/* Unload the library.  Return 0 on success, nonzero on error. \n */\nint vmddlclose(void *h);\n\n/* Return last error from any of the above functions.  Not thread-safe on\n * Windows due to static buffer in our code. \n */ \nconst char *vmddlerror(void);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-gromacs-5.1.2-tz5blkl5h4hbtzrte7ypqrgwjwhftnur/spack-src/src/gromacs/fileio/vmdio.c": "/*\n * This file is part of the GROMACS molecular simulation package.\n *\n * Copyright (c) 2009,2010,2012,2013,2014,2015, by the GROMACS development team, led by\n * Mark Abraham, David van der Spoel, Berk Hess, and Erik Lindahl,\n * and including many others, as listed in the AUTHORS file in the\n * top-level source directory and at http://www.gromacs.org.\n *\n * GROMACS is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public License\n * as published by the Free Software Foundation; either version 2.1\n * of the License, or (at your option) any later version.\n *\n * GROMACS is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with GROMACS; if not, see\n * http://www.gnu.org/licenses, or write to the Free Software Foundation,\n * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA.\n *\n * If you want to redistribute modifications to GROMACS, please\n * consider that scientific software is very special. Version\n * control is crucial - bugs must be traceable. We will be happy to\n * consider code for inclusion in the official distribution, but\n * derived work must not be called official GROMACS. Details are found\n * in the README & COPYING files - if they are missing, get the\n * official version at http://www.gromacs.org.\n *\n * To help us fund GROMACS development, we humbly ask that you cite\n * the research papers on the package. Check out http://www.gromacs.org.\n */\n#include \"gmxpre.h\"\n\n#include \"vmdio.h\"\n\n#include \"config.h\"\n\n/* Derived from PluginMgr.C and catdcd.c */\n\n/* PluginMgr.C: Copyright: */\n/***************************************************************************\n * cr\n * cr            (C) Copyright 1995-2009 The Board of Trustees of the\n * cr                        University of Illinois\n * cr                         All Rights Reserved\n * cr\n   Developed by:           Theoretical and Computational Biophysics Group\n                        University of Illinois at Urbana-Champaign\n                        http://www.ks.uiuc.edu/\n\n   Permission is hereby granted, free of charge, to any person obtaining a copy of\n   this software and associated documentation files (the Software), to deal with\n   the Software without restriction, including without limitation the rights to\n   use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n   of the Software, and to permit persons to whom the Software is furnished to\n   do so, subject to the following conditions:\n\n   Redistributions of source code must retain the above copyright notice,\n   this list of conditions and the following disclaimers.\n\n   Redistributions in binary form must reproduce the above copyright notice,\n   this list of conditions and the following disclaimers in the documentation\n   and/or other materials provided with the distribution.\n\n   Neither the names of Theoretical and Computational Biophysics Group,\n   University of Illinois at Urbana-Champaign, nor the names of its contributors\n   may be used to endorse or promote products derived from this Software without\n   specific prior written permission.\n\n   THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n   THE CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n   OTHER DEALINGS WITH THE SOFTWARE.\n ***************************************************************************/\n\n/* catdcd.c: Copyright: */\n/*****************************************************************************/\n/*                                                                           */\n/* (C) Copyright 2001-2005 Justin Gullingsrud and the University of Illinois.*/\n/*                                                                           */\n/*****************************************************************************/\n\n#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n/*\n * Plugin header files; get plugin source from www.ks.uiuc.edu/Research/vmd\"\n */\n#include \"external/vmd_molfile/molfile_plugin.h\"\n#include \"external/vmd_molfile/vmddlopen.h\"\n#ifndef GMX_NATIVE_WINDOWS\n#include <glob.h>\n#else\n#ifndef _WIN32_IE\n#define _WIN32_IE 0x0500 /* SHGetFolderPath is available since WinXP/IE5 */\n#endif\n#include <shlobj.h>\n#include <windows.h>\n#endif\n\n#include \"gromacs/fileio/gmxfio.h\"\n#include \"gromacs/fileio/trx.h\"\n#include \"gromacs/math/vec.h\"\n#include \"gromacs/utility/basedefinitions.h\"\n#include \"gromacs/utility/futil.h\"\n#include \"gromacs/utility/smalloc.h\"\n\n\ntypedef int (*initfunc)(void);\ntypedef int (*regfunc)(void *, vmdplugin_register_cb);\ntypedef int (*finifunc)(void);\n\n\n\nstatic int register_cb(void *v, vmdplugin_t *p)\n{\n    const char     *key       = p->name;\n    t_gmxvmdplugin *vmdplugin = (t_gmxvmdplugin*)v;\n\n    if (strcmp(key, vmdplugin->filetype) == 0)\n    {\n        vmdplugin->api = (molfile_plugin_t *)p;\n    }\n    return VMDPLUGIN_SUCCESS;\n}\n\nstatic int load_sharedlibrary_plugins(const char *fullpath, t_gmxvmdplugin* vmdplugin)\n{\n    /* Open the dll; try to execute the init function. */\n    void *handle, *ifunc, *registerfunc;\n    handle = vmddlopen(fullpath);\n    if (!handle)\n    {\n        if (debug)\n        {\n            fprintf(debug, \"\\nUnable to open dynamic library %s.\\n%s\\n\",  fullpath, vmddlerror());         /*only to debug because of stdc++ erros */\n        }\n        return 0;\n    }\n\n    ifunc = vmddlsym(handle, \"vmdplugin_init\");\n    if (!ifunc || ((initfunc)(ifunc))())\n    {\n        printf(\"\\nvmdplugin_init() for %s returned an error; plugin(s) not loaded.\\n\", fullpath);\n        vmddlclose(handle);\n        return 0;\n    }\n\n    registerfunc = vmddlsym(handle, \"vmdplugin_register\");\n    if (!registerfunc)\n    {\n        printf(\"\\nDidn't find the register function in %s; plugin(s) not loaded.\\n\", fullpath);\n        vmddlclose(handle);\n        return 0;\n    }\n    else\n    {\n        /* Load plugins from the library.*/\n        ((regfunc)registerfunc)(vmdplugin, register_cb);\n    }\n\n    /* in case this library does not support the filetype, close it */\n    if (vmdplugin->api == NULL)\n    {\n        vmddlclose(handle);\n    }\n\n    return 1;\n}\n\n/*return: 1: success, 0: last frame, -1: error*/\ngmx_bool read_next_vmd_frame(t_trxframe *fr)\n{\n    int                rc, i;\n    rvec               vec, angle;\n    molfile_timestep_t ts;\n\n\n    fr->bV = fr->vmdplugin->bV;\n\n#ifdef GMX_DOUBLE\n    snew(ts.coords, fr->natoms*3);\n    if (fr->bV)\n    {\n        snew(ts.velocities, fr->natoms*3);\n    }\n#else\n    ts.coords = (float*)fr->x;\n    if (fr->bV)\n    {\n        ts.velocities = (float*)fr->v;\n    }\n#endif\n\n    rc = fr->vmdplugin->api->read_next_timestep(fr->vmdplugin->handle, fr->natoms, &ts);\n\n    if (rc < -1)\n    {\n        fprintf(stderr, \"\\nError reading input file (error code %d)\\n\", rc);\n    }\n    if (rc < 0)\n    {\n        fr->vmdplugin->api->close_file_read(fr->vmdplugin->handle);\n        return 0;\n    }\n\n#ifdef GMX_DOUBLE\n    for (i = 0; i < fr->natoms; i++)\n    {\n        fr->x[i][0] = .1*ts.coords[i*3];\n        fr->x[i][1] = .1*ts.coords[i*3+1];\n        fr->x[i][2] = .1*ts.coords[i*3+2];\n        if (fr->bV)\n        {\n            fr->v[i][0] = .1*ts.velocities[i*3];\n            fr->v[i][1] = .1*ts.velocities[i*3+1];\n            fr->v[i][2] = .1*ts.velocities[i*3+2];\n        }\n    }\n    sfree(ts.coords);\n    if (fr->bV)\n    {\n        sfree(ts.velocities);\n    }\n#else\n    for (i = 0; i < fr->natoms; i++)\n    {\n        svmul(.1, fr->x[i], fr->x[i]);\n        if (fr->bV)\n        {\n            svmul(.1, fr->v[i], fr->v[i]);\n        }\n    }\n#endif\n\n    fr->bX   = 1;\n    fr->bBox = 1;\n    vec[0]   = .1*ts.A; vec[1] = .1*ts.B; vec[2] = .1*ts.C;\n    angle[0] = ts.alpha; angle[1] = ts.beta; angle[2] = ts.gamma;\n    matrix_convert(fr->box, vec, angle);\n    if (fr->vmdplugin->api->abiversion > 10)\n    {\n        fr->bTime = TRUE;\n        fr->time  = ts.physical_time;\n    }\n    else\n    {\n        fr->bTime = FALSE;\n    }\n\n\n    return 1;\n}\n\nstatic int load_vmd_library(const char *fn, t_gmxvmdplugin *vmdplugin)\n{\n    char            pathname[GMX_PATH_MAX], filename[GMX_PATH_MAX];\n    const char     *pathenv;\n    const char     *err;\n    int             i;\n    int             ret = 0;\n    char            pathenv_buffer[GMX_PATH_MAX];\n#ifndef GMX_NATIVE_WINDOWS\n    glob_t          globbuf;\n    const char     *defpath_suffix = \"/plugins/*/molfile\";\n    const char     *defpathenv     = GMX_VMD_PLUGIN_PATH;\n#else\n    WIN32_FIND_DATA ffd;\n    HANDLE          hFind = INVALID_HANDLE_VALUE;\n    char            progfolder[GMX_PATH_MAX];\n    char            defpathenv[GMX_PATH_MAX];\n    const char     *defpath_suffix = \"\\\\plugins\\\\WIN32\\\\molfile\";\n    SHGetFolderPath(NULL, CSIDL_PROGRAM_FILES, NULL, SHGFP_TYPE_CURRENT, progfolder);\n    sprintf(defpathenv, \"%s\\\\University of Illinois\\\\VMD\\\\plugins\\\\WIN32\\\\molfile\", progfolder);\n#endif\n\n    vmdplugin->api      = NULL;\n    vmdplugin->filetype = strrchr(fn, '.');\n    if (!vmdplugin->filetype)\n    {\n        return 0;\n    }\n    vmdplugin->filetype++;\n\n    /* First look for an explicit path given at run time for the\n     * plugins, then an implicit run-time path, and finally for one\n     * given at configure time. This last might be hard-coded to the\n     * default for VMD installs. */\n    pathenv = getenv(\"VMD_PLUGIN_PATH\");\n    if (pathenv == NULL)\n    {\n        pathenv = getenv(\"VMDDIR\");\n        if (NULL == pathenv)\n        {\n            printf(\"\\nNeither VMD_PLUGIN_PATH or VMDDIR set. \");\n            printf(\"Using default location:\\n%s\\n\", defpathenv);\n            pathenv = defpathenv;\n        }\n        else\n        {\n            printf(\"\\nVMD_PLUGIN_PATH no set, but VMDDIR is set. \");\n#ifdef _MSC_VER\n            _snprintf_s(pathenv_buffer, sizeof(pathenv_buffer), _TRUNCATE, \"%s%s\", pathenv, defpath_suffix);\n#else\n            snprintf(pathenv_buffer, sizeof(pathenv_buffer), \"%s%s\", pathenv, defpath_suffix);\n#endif\n            printf(\"Using semi-default location:\\n%s\\n\", pathenv_buffer);\n            pathenv = pathenv_buffer;\n        }\n    }\n    strncpy(pathname, pathenv, sizeof(pathname));\n#ifndef GMX_NATIVE_WINDOWS\n    strcat(pathname, \"/*.so\");\n    glob(pathname, 0, NULL, &globbuf);\n    if (globbuf.gl_pathc == 0)\n    {\n        printf(\"\\nNo VMD Plugins found\\n\"\n               \"Set the environment variable VMD_PLUGIN_PATH to the molfile folder within the\\n\"\n               \"VMD installation.\\n\"\n               \"The architecture (e.g. 32bit versus 64bit) of GROMACS and VMD has to match.\\n\");\n        return 0;\n    }\n    for (i = 0; i < globbuf.gl_pathc && vmdplugin->api == NULL; i++)\n    {\n        /* FIXME: Undefined which plugin is chosen if more than one plugin\n           can read a certain file ending. Requires some additional command\n           line option or enviroment variable to specify which plugin should\n           be picked.\n         */\n        ret |= load_sharedlibrary_plugins(globbuf.gl_pathv[i], vmdplugin);\n    }\n    globfree(&globbuf);\n#else\n    strcat(pathname, \"\\\\*.so\");\n    hFind = FindFirstFile(pathname, &ffd);\n    if (INVALID_HANDLE_VALUE == hFind)\n    {\n        printf(\"\\nNo VMD Plugins found\\n\");\n        return 0;\n    }\n    do\n    {\n        sprintf(filename, \"%s\\\\%s\", pathenv, ffd.cFileName);\n        ret |= load_sharedlibrary_plugins(filename, vmdplugin);\n    }\n    while (FindNextFile(hFind, &ffd )  != 0 && vmdplugin->api == NULL);\n    FindClose(hFind);\n#endif\n\n    if (!ret)\n    {\n        printf(\"\\nCould not open any VMD library.\\n\");\n        err = vmddlerror();\n        if (!err)\n        {\n            printf(\"Compiled with dlopen?\\n\");\n        }\n        else\n        {\n            printf(\"Last error:\\n%s\\n\", err);\n        }\n        return 0;\n    }\n\n    if (vmdplugin->api == NULL)\n    {\n        printf(\"\\nNo plugin for %s found\\n\", vmdplugin->filetype);\n        return 0;\n    }\n\n    if (vmdplugin->api->abiversion < 10)\n    {\n        printf(\"\\nPlugin and/or VMD is too old. At least VMD 1.8.6 is required.\\n\");\n        return 0;\n    }\n\n    printf(\"\\nUsing VMD plugin: %s (%s)\\n\", vmdplugin->api->name, vmdplugin->api->prettyname);\n\n    return 1;\n\n}\n\nint read_first_vmd_frame(const char *fn, t_trxframe *fr)\n{\n    molfile_timestep_metadata_t *metadata = NULL;\n\n    snew(fr->vmdplugin, 1);\n    if (!load_vmd_library(fn, fr->vmdplugin))\n    {\n        return 0;\n    }\n\n    fr->vmdplugin->handle = fr->vmdplugin->api->open_file_read(fn, fr->vmdplugin->filetype, &fr->natoms);\n\n    if (!fr->vmdplugin->handle)\n    {\n        fprintf(stderr, \"\\nError: could not open file '%s' for reading.\\n\",\n                fn);\n        return 0;\n    }\n\n    if (fr->natoms == MOLFILE_NUMATOMS_UNKNOWN)\n    {\n        fprintf(stderr, \"\\nFormat of file %s does not record number of atoms.\\n\", fn);\n        return 0;\n    }\n    else if (fr->natoms == MOLFILE_NUMATOMS_NONE)\n    {\n        fprintf(stderr, \"\\nNo atoms found by VMD plugin in file %s.\\n\", fn );\n        return 0;\n    }\n    else if (fr->natoms < 1)     /*should not be reached*/\n    {\n        fprintf(stderr, \"\\nUnknown number of atoms %d for VMD plugin opening file %s.\\n\",\n                fr->natoms, fn );\n        return 0;\n    }\n\n    snew(fr->x, fr->natoms);\n\n    fr->vmdplugin->bV = 0;\n    if (fr->vmdplugin->api->abiversion > 10 && fr->vmdplugin->api->read_timestep_metadata)\n    {\n        fr->vmdplugin->api->read_timestep_metadata(fr->vmdplugin->handle, metadata);\n        assert(metadata);\n        fr->vmdplugin->bV = metadata->has_velocities;\n        if (fr->vmdplugin->bV)\n        {\n            snew(fr->v, fr->natoms);\n        }\n    }\n    else\n    {\n        fprintf(stderr,\n                \"\\nThis trajectory is being read with a VMD plug-in from before VMD\"\n                \"\\nversion 1.8, or from a trajectory that lacks time step metadata.\"\n                \"\\nEither way, GROMACS cannot tell whether the trajectory has velocities.\\n\");\n    }\n    return 1;\n\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-gromacs-5.1.2-tz5blkl5h4hbtzrte7ypqrgwjwhftnur/spack-src/src/gromacs/fileio/CMakeLists.txt": "#\n# This file is part of the GROMACS molecular simulation package.\n#\n# Copyright (c) 2013,2014, by the GROMACS development team, led by\n# Mark Abraham, David van der Spoel, Berk Hess, and Erik Lindahl,\n# and including many others, as listed in the AUTHORS file in the\n# top-level source directory and at http://www.gromacs.org.\n#\n# GROMACS is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public License\n# as published by the Free Software Foundation; either version 2.1\n# of the License, or (at your option) any later version.\n#\n# GROMACS is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public\n# License along with GROMACS; if not, see\n# http://www.gnu.org/licenses, or write to the Free Software Foundation,\n# Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA.\n#\n# If you want to redistribute modifications to GROMACS, please\n# consider that scientific software is very special. Version\n# control is crucial - bugs must be traceable. We will be happy to\n# consider code for inclusion in the official distribution, but\n# derived work must not be called official GROMACS. Details are found\n# in the README & COPYING files - if they are missing, get the\n# official version at http://www.gromacs.org.\n#\n# To help us fund GROMACS development, we humbly ask that you cite\n# the research papers on the package. Check out http://www.gromacs.org.\n\nfile(GLOB FILEIO_SOURCES *.cpp *.c)\n\nif(GMX_USE_PLUGINS)\n  set(FILEIO_SOURCES ${FILEIO_SOURCES} ${CMAKE_SOURCE_DIR}/src/external/vmd_molfile/vmddlopen.c)\nelse()\n  list(REMOVE_ITEM FILEIO_SOURCES ${CMAKE_CURRENT_SOURCE_DIR}/vmdio.c)\nendif()\n\nset(LIBGROMACS_SOURCES ${LIBGROMACS_SOURCES} ${FILEIO_SOURCES} PARENT_SCOPE)\n\ngmx_install_headers(\n    confio.h\n    enxio.h\n    filenm.h\n    gmxfio.h\n    matio.h\n    mdoutf.h\n    mtxio.h\n    pdbio.h\n    tpxio.h\n    trajectory_writing.h\n    trnio.h\n    trx.h\n    trxio.h\n    xdr_datatype.h\n    xtcio.h\n    xvgr.h\n    )\n\nif (GMX_USE_TNG AND TNG_IO_DEFINITIONS)\n    set_property(SOURCE tngio.cpp\n                 APPEND PROPERTY COMPILE_DEFINITIONS ${TNG_IO_DEFINITIONS})\n    set_property(SOURCE tngio_for_tools.cpp\n                 APPEND PROPERTY COMPILE_DEFINITIONS ${TNG_IO_DEFINITIONS})\nendif()\n\nif (BUILD_TESTING)\n     add_subdirectory(tests)\nendif()\n",
        "/tmp/vanessa/spack-stage/spack-stage-gromacs-5.1.2-tz5blkl5h4hbtzrte7ypqrgwjwhftnur/spack-src/cmake/TestVMD.c": "#include \"molfile_plugin.h\"\n#include \"vmddlopen.c\"\n#include \"stdio.h\"\n\nstatic int register_cb(void *v, vmdplugin_t *p) {\n    *(molfile_plugin_t**)v = (molfile_plugin_t *)p;\n    return VMDPLUGIN_SUCCESS;\n}\n\ntypedef int (*initfunc)(void);\ntypedef int (*regfunc)(void *, vmdplugin_register_cb);\n\n/*run: gcc TestVMD.c -DGMX_USE_PLUGINS -Wall -ldl src/gmxlib/vmddlopen.c -I src/gmxlib && ./a.out .../xyzplugin.so ; echo $?*/\nint main(int argc, char** argv)\n{\n    void *handle, *ifunc, *registerfunc;\n    molfile_plugin_t* api;\n    if (argc!=2) return -1;\n    handle = vmddlopen(argv[1]);\n    if (!handle)\n    {\n        fprintf(stderr,\"%s\\n\",vmddlerror());\n        return 1;\n    }\n    ifunc = vmddlsym(handle, \"vmdplugin_init\");\n    if (!ifunc || ((initfunc)(ifunc))()) return 2;\n    registerfunc = vmddlsym(handle, \"vmdplugin_register\");\n    if (!registerfunc) return 3;\n    ((regfunc)registerfunc)(&api, register_cb);\n    if (!api) return 4;\n    if (api->abiversion<10) return 5;\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-gromacs-5.1.2-tz5blkl5h4hbtzrte7ypqrgwjwhftnur/spack-src/cmake/gmxTestdlopen.cmake": "#\n# This file is part of the GROMACS molecular simulation package.\n#\n# Copyright (c) 2012,2015, by the GROMACS development team, led by\n# Mark Abraham, David van der Spoel, Berk Hess, and Erik Lindahl,\n# and including many others, as listed in the AUTHORS file in the\n# top-level source directory and at http://www.gromacs.org.\n#\n# GROMACS is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public License\n# as published by the Free Software Foundation; either version 2.1\n# of the License, or (at your option) any later version.\n#\n# GROMACS is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public\n# License along with GROMACS; if not, see\n# http://www.gnu.org/licenses, or write to the Free Software Foundation,\n# Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA.\n#\n# If you want to redistribute modifications to GROMACS, please\n# consider that scientific software is very special. Version\n# control is crucial - bugs must be traceable. We will be happy to\n# consider code for inclusion in the official distribution, but\n# derived work must not be called official GROMACS. Details are found\n# in the README & COPYING files - if they are missing, get the\n# official version at http://www.gromacs.org.\n#\n# To help us fund GROMACS development, we humbly ask that you cite\n# the research papers on the package. Check out http://www.gromacs.org.\n\n# - Define macro to check if DLOPEN is defined\n#\n#  GMX_TEST_DLOPEN(VARIABLE)\n#\n#  VARIABLE will be set if dlopen is present in dlfcn.h\n#\n\nMACRO(GMX_TEST_DLOPEN VARIABLE)\n  IF(NOT DEFINED ${VARIABLE})\n    MESSAGE(STATUS \"Checking for dlopen\")\n\n    set(CMAKE_REQUIRED_INCLUDES \"dlfcn.h\")\n    set(CMAKE_REQUIRED_LIBRARIES \"dl\")\n    check_c_source_compiles(\n      \"#include <dlfcn.h>\nint main(void) {\n  dlopen(0,0);\n  return 0;\n}\" ${VARIABLE})\n\n    IF(${VARIABLE})\n      MESSAGE(STATUS \"Checking for dlopen - found\")\n      set(${VARIABLE} 1 CACHE INTERNAL \"Result of test for dlopen\" FORCE)\n    ELSE()\n      MESSAGE(STATUS \"Checking for dlopen - not found\")\n      set(${VARIABLE} 0 CACHE INTERNAL \"Result of test for dlopen\" FORCE)\n    ENDIF()\n    set(CMAKE_REQUIRED_INCLUDES)\n    set(CMAKE_REQUIRED_LIBRARIES)\n  ENDIF()\nENDMACRO()\n",
        "/tmp/vanessa/spack-stage/spack-stage-gromacs-5.1.2-tz5blkl5h4hbtzrte7ypqrgwjwhftnur/spack-src/docs/manual/special.tex": "%\n% This file is part of the GROMACS molecular simulation package.\n%\n% Copyright (c) 2013,2014,2015, by the GROMACS development team, led by\n% Mark Abraham, David van der Spoel, Berk Hess, and Erik Lindahl,\n% and including many others, as listed in the AUTHORS file in the\n% top-level source directory and at http://www.gromacs.org.\n%\n% GROMACS is free software; you can redistribute it and/or\n% modify it under the terms of the GNU Lesser General Public License\n% as published by the Free Software Foundation; either version 2.1\n% of the License, or (at your option) any later version.\n%\n% GROMACS is distributed in the hope that it will be useful,\n% but WITHOUT ANY WARRANTY; without even the implied warranty of\n% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n% Lesser General Public License for more details.\n%\n% You should have received a copy of the GNU Lesser General Public\n% License along with GROMACS; if not, see\n% http://www.gnu.org/licenses, or write to the Free Software Foundation,\n% Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA.\n%\n% If you want to redistribute modifications to GROMACS, please\n% consider that scientific software is very special. Version\n% control is crucial - bugs must be traceable. We will be happy to\n% consider code for inclusion in the official distribution, but\n% derived work must not be called official GROMACS. Details are found\n% in the README & COPYING files - if they are missing, get the\n% official version at http://www.gromacs.org.\n%\n% To help us fund GROMACS development, we humbly ask that you cite\n% the research papers on the package. Check out http://www.gromacs.org.\n\n\\chapter{Special Topics}\n\\label{ch:special}\n\n\n\\section{Free energy implementation}\n\\label{sec:dgimplement}\nFor free energy calculations, there are two things that must be\nspecified; the end states, and the pathway connecting the end states.\nThe end states can be specified in two ways.  The most straightforward\nis through the specification of end states in the topology file.  Most\npotential forms support both an $A$ state and a $B$ state. Whenever both\nstates are specified, then the $A$ state corresponds to the initial free\nenergy state, and the $B$ state corresponds to the final state.\n\nIn some cases, the end state can also be defined in some cases without\naltering the topology, solely through the {\\tt .mdp} file, through the use\nof the {\\tt couple-moltype},{\\tt couple-lambda0}, {\\tt couple-lambda1}, and\n{\\tt couple-intramol} mdp keywords.  Any molecule type selected in\n{\\tt couple-moltype} will automatically have a $B$ state implicitly\nconstructed (and the $A$ state redefined) according to the {\\tt couple-lambda}\nkeywords. {\\tt couple-lambda0} and {\\tt couple-lambda1} define the non-bonded\nparameters that are present in the $A$ state ({\\tt couple-lambda0})\nand the $B$ state ({\\tt couple-lambda1}).  The choices are 'q','vdw', and\n'vdw-q'; these indicate the Coulombic, van der Waals, or both parameters\nthat are turned on in the respective state.\n\nOnce the end states are defined, then the path between the end states\nhas to be defined. This path is defined solely in the .mdp file.\nStarting in 4.6, $\\lambda$ is a vector of components, with Coulombic,\nvan der Waals, bonded, restraint, and mass components all able to be\nadjusted independently.  This makes it possible to turn off the\nCoulombic term linearly, and then the van der Waals using soft core,\nall in the same simulation.  This is especially useful for replica\nexchange or expanded ensemble simulations, where it is important to\nsample all the way from interacting to non-interacting states in the\nsame simulation to improve sampling.\n\n{\\tt fep-lambdas} is the default array of $\\lambda$ values ranging\nfrom 0 to 1.  All of the other lambda arrays use the values in this\narray if they are not specified.  The previous behavior, where the\npathway is controlled by a single $\\lambda$ variable, can be preserved\nby using only {\\tt fep-lambdas} to define the pathway.\n\nFor example, if you wanted to first to change the Coulombic terms,\nthen the van der Waals terms, changing bonded at the same time rate as\nthe van der Waals, but changing the restraints throughout the first\ntwo-thirds of the simulation, then you could use this $\\lambda$ vector:\n\n\\begin{verbatim}\ncoul-lambdas           = 0.0 0.2 0.5 1.0 1.0 1.0 1.0 1.0 1.0 1.0\nvdw-lambdas            = 0.0 0.0 0.0 0.0 0.4 0.5 0.6 0.7 0.8 1.0\nbonded-lambdas         = 0.0 0.0 0.0 0.0 0.4 0.5 0.6 0.7 0.8 1.0\nrestraint-lambdas      = 0.0 0.0 0.1 0.2 0.3 0.5 0.7 1.0 1.0 1.0\n\\end{verbatim}\n\nThis is also equivalent to:\n\n\\begin{verbatim}\nfep-lambdas            = 0.0 0.0 0.0 0.0 0.4 0.5 0.6 0.7 0.8 1.0\ncoul-lambdas           = 0.0 0.2 0.5 1.0 1.0 1.0 1.0 1.0 1.0 1.0\nrestraint-lambdas      = 0.0 0.0 0.1 0.2 0.3 0.5 0.7 1.0 1.0 1.0\n\\end{verbatim}\nThe {\\tt fep-lambda array}, in this case, is being used as the default to\nfill in the bonded and van der Waals $\\lambda$ arrays.  Usually, it's best to fill\nin all arrays explicitly, just to make sure things are properly\nassigned.\n\nIf you want to turn on only restraints going from $A$ to $B$, then it would be:\n\\begin{verbatim}\nrestraint-lambdas      = 0.0 0.1 0.2 0.4 0.6 1.0\n\\end{verbatim}\nand all of the other components of the $\\lambda$ vector would be left in the $A$ state.\n\nTo compute free energies with a vector $\\lambda$ using\nthermodynamic integration, then the TI equation becomes vector equation:\n\\beq\n\\Delta F = \\int \\langle \\nabla H \\rangle \\cdot d\\vec{\\lambda}\n\\eeq\nor for finite differences:\n\\beq\n\\Delta F \\approx \\int \\sum \\langle \\nabla H \\rangle \\cdot \\Delta\\lambda\n\\eeq\n\nThe external {\\tt pymbar} script downloaded from https://SimTK.org/home/pymbar can\ncompute this integral automatically from the {\\gromacs} dhdl.xvg output.\n\n\\section{Potential of mean force}\n\nA potential of mean force (PMF) is a potential that is obtained\nby integrating the mean force from an ensemble of configurations.\nIn {\\gromacs}, there are several different methods to calculate the mean force.\nEach method has its limitations, which are listed below.\n\\begin{itemize}\n\\item{\\bf pull code:} between the centers of mass of molecules or groups of molecules.\n\\item{\\bf free-energy code with harmonic bonds or constraints:} between single atoms. \n\\item{\\bf free-energy code with position restraints:} changing the conformation of a relatively immobile group of atoms.\n\\item{\\bf pull code in limited cases:} between groups of atoms that are\npart of a larger molecule for which the bonds are constrained with\nSHAKE or LINCS. If the pull group if relatively large,\nthe pull code can be used.\n\\end{itemize}\nThe pull and free-energy code a described in more detail\nin the following two sections.\n\n\\subsubsection{Entropic effects}\nWhen a distance between two atoms or the centers of mass of two groups\nis constrained or restrained, there will be a purely entropic contribution\nto the PMF due to the rotation of the two groups~\\cite{RMNeumann1980a}.\nFor a system of two non-interacting masses the potential of mean force is:\n\\beq\nV_{pmf}(r) = -(n_c - 1) k_B T \\log(r)\n\\eeq\nwhere $n_c$ is the number of dimensions in which the constraint works\n(i.e. $n_c=3$ for a normal constraint and $n_c=1$ when only\nthe $z$-direction is constrained).\nWhether one needs to correct for this contribution depends on what\nthe PMF should represent. When one wants to pull a substrate\ninto a protein, this entropic term indeed contributes to the work to\nget the substrate into the protein. But when calculating a PMF\nbetween two solutes in a solvent, for the purpose of simulating\nwithout solvent, the entropic contribution should be removed.\n{\\bf Note} that this term can be significant; when at 300K the distance is halved,\nthe contribution is 3.5 kJ~mol$^{-1}$.\n\n\\section{Non-equilibrium pulling}\nWhen the distance between two groups is changed continuously,\nwork is applied to the system, which means that the system is no longer\nin equilibrium. Although in the limit of very slow pulling\nthe system is again in equilibrium, for many systems this limit\nis not reachable within reasonable computational time.\nHowever, one can use the Jarzynski relation~\\cite{Jarzynski1997a}\nto obtain the equilibrium free-energy difference $\\Delta G$\nbetween two distances from many non-equilibrium simulations:\n\\begin{equation}\n   \\Delta G_{AB} = -k_BT \\log \\left\\langle e^{-\\beta W_{AB}} \\right\\rangle_A\n   \\label{eq:Jarz}\n\\end{equation}\nwhere $W_{AB}$ is the work performed to force the system along one path\nfrom state A to B, the angular bracket denotes averaging over\na canonical ensemble of the initial state A and $\\beta=1/k_B T$.\n\n\n\\section{The pull code}\n\\index{center-of-mass pulling}\n\\label{sec:pull}\nThe pull code applies forces or constraints between the centers\nof mass of one or more pairs of groups of atoms.\nEach pull reaction coordinate is called a ``coordinate'' and it operates\non usually two, but sometimes more, pull groups. A pull group can be part of one or more pull\ncoordinates. Furthermore, a coordinate can also operate on a single group\nand an absolute reference position in space.\nThe distance between a pair of groups can be determined\nin 1, 2 or 3 dimensions, or can be along a user-defined vector.\nThe reference distance can be constant or can change linearly with time.\nNormally all atoms are weighted by their mass, but an additional\nweighting factor can also be used.\n\\begin{figure}\n\\centerline{\\includegraphics[width=6cm,angle=270]{plots/pull}}\n\\caption{Schematic picture of pulling a lipid out of a lipid bilayer\nwith umbrella pulling. $V_{rup}$ is the velocity at which the spring is\nretracted, $Z_{link}$ is the atom to which the spring is attached and\n$Z_{spring}$ is the location of the spring.}\n\\label{fig:pull} \n\\end{figure}\n\nThree different types of calculation are supported,\nand in all cases the reference distance can be constant\nor linearly changing with time.\n\\begin{enumerate}\n\\item{\\textbf{Umbrella pulling}\\swapindexquiet{umbrella}{pulling}}\nA harmonic potential is applied between\nthe centers of mass of two groups.\nThus, the force is proportional to the displacement.\n\\item{\\textbf{Constraint pulling\\swapindexquiet{constraint}{pulling}}}\nThe distance between the centers of mass of two groups is constrained.\nThe constraint force can be written to a file.\nThis method uses the SHAKE algorithm but only needs 1 iteration to be\nexact if only two groups are constrained. \n\\item{\\textbf{Constant force pulling}}\nA constant force is applied between the centers of mass of two groups.\nThus, the potential is linear.\nIn this case there is no reference distance of pull rate.\n\\item{\\textbf{Flat bottom pulling}}\nLike umbrella pulling, but the potential and force are zero for\nnegative deviations. This is useful for restraining the distance\nbetween e.g. two molecules to a certain maximum distance.\n\\end{enumerate}\n\n\\subsubsection{Definition of the center of mass}\n\nIn {\\gromacs}, there are three ways to define the center of mass of a group.\nThe standard way is a ``plain'' center of mass, possibly with additional\nweighting factors. With periodic boundary conditions it is no longer\npossible to uniquely define the center of mass of a group of atoms.\nTherefore, a reference atom is used. For determining the center of mass,\nfor all other atoms in the group, the closest periodic image to the reference\natom is used. This uniquely defines the center of mass.\nBy default, the middle (determined by the order in the topology) atom\nis used as a reference atom, but the user can also select any other atom\nif it would be closer to center of the group.\n\nFor a layered system, for instance a lipid bilayer, it may be of interest\nto calculate the PMF of a lipid as function of its distance\nfrom the whole bilayer. The whole bilayer can be taken as reference\ngroup in that case, but it might also be of interest to define the\nreaction coordinate for the PMF more locally. The {\\tt .mdp} option\n{\\tt pull-coord?-geometry = cylinder} does not\nuse all the atoms of the reference group, but instead dynamically only those\nwithin a cylinder with radius {\\tt pull-cylinder-r} around the pull vector going\nthrough the pull group. This only\nworks for distances defined in one dimension, and the cylinder is\noriented with its long axis along this one dimension. To avoid jumps in\nthe pull force, contributions of atoms are weighted as a function of distance\n(in addition to the mass weighting):\n\\bea\nw(r < r_\\mathrm{cyl}) & = &\n1-2 \\left(\\frac{r}{r_\\mathrm{cyl}}\\right)^2 + \\left(\\frac{r}{r_\\mathrm{cyl}}\\right)^4 \\\\\nw(r \\geq r_\\mathrm{cyl}) & = & 0\n\\eea\nNote that the radial dependence on the weight causes a radial force on\nboth cylinder group and the other pull group. This is an undesirable,\nbut unavoidable effect. To minimize this effect, the cylinder radius should\nbe chosen sufficiently large. The effective mass is 0.47 times that of\na cylinder with uniform weights and equal to the mass of uniform cylinder\nof 0.79 times the radius.\n\n\\begin{figure}\n\\centerline{\\includegraphics[width=6cm]{plots/pullref}}\n\\caption{Comparison of a plain center of mass reference group versus a cylinder\nreference group applied to interface systems. C is the reference group.\nThe circles represent the center of mass of two groups plus the reference group,\n$d_c$ is the reference distance.}\n\\label{fig:pullref} \n\\end{figure}   \n\nFor a group of molecules in a periodic system, a plain reference group\nmight not be well-defined. An example is a water slab that is connected\nperiodically in $x$ and $y$, but has two liquid-vapor interfaces along $z$.\nIn such a setup, water molecules can evaporate from the liquid and they\nwill move through the vapor, through the periodic boundary, to the other\ninterface. Such a system is inherently periodic and there is no proper way\nof defining a ``plain'' center of mass along $z$. A proper solution is to using\na cosine shaped weighting profile for all atoms in the reference group.\nThe profile is a cosine with a single period in the unit cell. Its phase\nis optimized to give the maximum sum of weights, including mass weighting.\nThis provides a unique and continuous reference position that is nearly\nidentical to the plain center of mass position in case all atoms are all\nwithin a half of the unit-cell length. See ref \\cite{Engin2010a} for details.\n\nWhen relative weights $w_i$ are used during the calculations, either\nby supplying weights in the input or due to cylinder geometry\nor due to cosine weighting,\nthe weights need to be scaled to conserve momentum:\n\\beq\nw'_i = w_i\n\\left. \\sum_{j=1}^N w_j \\, m_j \\right/ \\sum_{j=1}^N w_j^2 \\, m_j\n\\eeq\nwhere $m_j$ is the mass of atom $j$ of the group.\nThe mass of the group, required for calculating the constraint force, is:\n\\beq\nM = \\sum_{i=1}^N w'_i \\, m_i\n\\eeq\nThe definition of the weighted center of mass is:\n\\beq\n\\ve{r}_{com} = \\left. \\sum_{i=1}^N w'_i \\, m_i \\, \\ve{r}_i \\right/ M\n\\eeq\nFrom the centers of mass the AFM, constraint, or umbrella force $\\ve{F}_{\\!com}$\non each group can be calculated.\nThe force on the center of mass of a group is redistributed to the atoms\nas follows:\n\\beq\n\\ve{F}_{\\!i} = \\frac{w'_i \\, m_i}{M} \\, \\ve{F}_{\\!com}\n\\eeq\n\n\\subsubsection{Definition of the pull direction}\n\nThe most common setup is to pull along the direction of the vector containing\nthe two pull groups, this is selected with\n{\\tt pull-coord?-geometry = distance}. You might want to pull along a certain\nvector instead, which is selected with {\\tt pull-coord?-geometry = direction}.\nBut this can cause unwanted torque forces in the system, unless you pull against a reference group with (nearly) fixed orientation, e.g. a membrane protein embedded in a membrane along x/y while pulling along z. If your reference group does not have a fixed orientation, you should probably use\n{\\tt pull-coord?-geometry = direction-relative}, see \\figref{pulldirrel}.\nSince the potential now depends on the coordinates of two additional groups defining the orientation, the torque forces will work on these two groups.\n\n\\begin{figure}\n\\centerline{\\includegraphics[width=5cm]{plots/pulldirrel}}\n\\caption{The pull setup for geometry {\\tt direction-relative}. The ``normal'' pull groups are 1 and 2. Groups 3 and 4 define the pull direction and thus the direction of the normal pull forces (red). This leads to reaction forces (blue) on groups 3 and 4, which are perpendicular to the pull direction. Their magnitude is given by the ``normal'' pull force times the ratio of $d_p$ and the distance between groups 3 and 4.}\n\\label{fig:pulldirrel} \n\\end{figure}   \n\n\n\\subsubsection{Limitations}\nThere is one theoretical limitation:\nstrictly speaking, constraint forces can only be calculated between\ngroups that are not connected by constraints to the rest of the system.\nIf a group contains part of a molecule of which the bond lengths\nare constrained, the pull constraint and LINCS or SHAKE bond constraint\nalgorithms should be iterated simultaneously. This is not done in {\\gromacs}.\nThis means that for simulations with {\\tt constraints = all-bonds}\nin the {\\tt .mdp} file pulling is, strictly speaking,\nlimited to whole molecules or groups of molecules.\nIn some cases this limitation can be avoided by using the free energy code,\nsee \\secref{fepmf}.\nIn practice, the errors caused by not iterating the two constraint\nalgorithms can be negligible when the pull group consists of a large\namount of atoms and/or the pull force is small.\nIn such cases, the constraint correction displacement of the pull group\nis small compared to the bond lengths.\n\n\n\n\\section{\\normindex{Enforced Rotation}}\n\\index{rotational pulling|see{enforced rotation}}\n\\index{pulling, rotational|see{enforced rotation}}\n\\label{sec:rotation}\n\n\\mathchardef\\mhyphen=\"2D\n\\newcommand{\\rotiso     }{^\\mathrm{iso}}\n\\newcommand{\\rotisopf   }{^\\mathrm{iso\\mhyphen pf}}\n\\newcommand{\\rotpm      }{^\\mathrm{pm}}\n\\newcommand{\\rotpmpf    }{^\\mathrm{pm\\mhyphen pf}}\n\\newcommand{\\rotrm      }{^\\mathrm{rm}}\n\\newcommand{\\rotrmpf    }{^\\mathrm{rm\\mhyphen pf}}\n\\newcommand{\\rotrmtwo   }{^\\mathrm{rm2}}\n\\newcommand{\\rotrmtwopf }{^\\mathrm{rm2\\mhyphen pf}}\n\\newcommand{\\rotflex    }{^\\mathrm{flex}}\n\\newcommand{\\rotflext   }{^\\mathrm{flex\\mhyphen t}}\n\\newcommand{\\rotflextwo }{^\\mathrm{flex2}}\n\\newcommand{\\rotflextwot}{^\\mathrm{flex2\\mhyphen t}}\n\nThis module can be used to enforce the rotation of a group of atoms, as {\\eg}\na protein subunit. There are a variety of rotation potentials, among them\ncomplex ones that allow flexible adaptations of both the rotated subunit as\nwell as the local rotation axis during the simulation. An example application \ncan be found in ref. \\cite{Kutzner2011}.\n\n\\begin{figure}\n\\centerline{\\includegraphics[width=13cm]{plots/rotation.pdf}}\n\\caption[Fixed and flexible axis rotation]{Comparison of fixed and flexible axis\nrotation. \n{\\sf A:} Rotating the sketched shape inside the white tubular cavity can create\nartifacts when a fixed rotation axis (dashed) is used. More realistically, the\nshape would revolve like a flexible pipe-cleaner (dotted) inside the bearing (gray). \n{\\sf B:} Fixed rotation around an axis \\ve{v} with a pivot point\nspecified by the vector \\ve{u}. \n{\\sf C:} Subdividing the rotating fragment into slabs with separate rotation\naxes ($\\uparrow$) and pivot points ($\\bullet$) for each slab allows for\nflexibility. The distance between two slabs with indices $n$ and $n+1$ is $\\Delta x$.}\n\\label{fig:rotation}\n\\end{figure}\n\n\\begin{figure}\n\\centerline{\\includegraphics[width=13cm]{plots/equipotential.pdf}}\n\\caption{Selection of different rotation potentials and definition of notation.\nAll four potentials $V$ (color coded) are shown for a single atom at position\n$\\ve{x}_j(t)$.\n{\\sf A:} Isotropic potential $V\\rotiso$,\n{\\sf B:} radial motion potential $V\\rotrm$ and flexible potential\n$V\\rotflex$,\n{\\sf C--D:} radial motion\\,2 potential $V\\rotrmtwo$ and\nflexible\\,2 potential $V\\rotflextwo$ for $\\epsilon' = 0$\\,nm$^2$ {\\sf (C)}\nand $\\epsilon' = 0.01$\\,nm$^2$ {\\sf (D)}. The rotation axis is perpendicular to\nthe plane and marked by $\\otimes$. The light gray contours indicate Boltzmann factors\n$e^{-V/(k_B T)}$ in the $\\ve{x}_j$-plane for $T=300$\\,K and\n$k=200$\\,kJ/(mol$\\cdot$nm$^2$). The green arrow shows the direction of the\nforce $\\ve{F}_{\\!j}$ acting on atom $j$; the blue dashed line indicates the\nmotion of the reference position.}\n\\label{fig:equipotential}\n\\end{figure}\n\n\\subsection{Fixed Axis Rotation}\n\\subsubsection{Stationary Axis with an Isotropic Potential}\nIn the fixed axis approach (see \\figref{rotation}B), torque on a group of $N$\natoms with positions $\\ve{x}_i$ (denoted ``rotation group'') is applied by\nrotating a reference set of atomic positions -- usually their initial positions\n$\\ve{y}_i^0$ -- at a constant angular velocity $\\omega$ around an axis\ndefined by a direction vector $\\hat{\\ve{v}}$ and a pivot point \\ve{u}.\nTo that aim, each atom with position $\\ve{x}_i$ is attracted by a\n``virtual spring'' potential to its moving reference position\n$\\ve{y}_i = \\mathbf{\\Omega}(t) (\\ve{y}_i^0 - \\ve{u})$,\nwhere $\\mathbf{\\Omega}(t)$ is a matrix that describes the rotation around the\naxis. In the simplest case, the ``springs'' are described by a harmonic\npotential,\n\\beq\nV\\rotiso = \\frac{k}{2} \\sum_{i=1}^{N} w_i \\left[ \\mathbf{\\Omega}(t)\n(\\ve{y}_i^0 - \\ve{u}) - (\\ve{x}_i - \\ve{u})  \\right]^2 ,\n\\label{eqn:potiso}\n\\eeq\nwith optional mass-weighted prefactors $w_i = N \\, m_i/M$ with total mass\n$M = \\sum_{i=1}^N m_i$.\nThe rotation matrix $\\mathbf{\\Omega}(t)$ is \n\\newcommand{\\omcost}{\\,\\xi\\,}   % abbreviation\n\\begin{displaymath}\n\\mathbf{\\Omega}(t) =  \n\\left(   \n\\begin{array}{ccc}\n\\cos\\omega t + v_x^2\\omcost       & v_x v_y\\omcost - v_z\\sin\\omega t  & v_x v_z\\omcost + v_y\\sin\\omega t\\\\\nv_x v_y\\omcost + v_z\\sin\\omega t  & \\cos\\omega t + v_y^2\\omcost       & v_y v_z\\omcost - v_x\\sin\\omega t\\\\\nv_x v_z\\omcost - v_y\\sin\\omega t  & v_y v_z\\omcost + v_x\\sin\\omega t  & \\cos\\omega t + v_z^2\\omcost     \\\\\n\\end{array}\n\\right) ,\n\\end{displaymath}\nwhere $v_x$, $v_y$, and $v_z$ are the components of the normalized rotation vector\n$\\hat{\\ve{v}}$, and $\\omcost := 1-\\cos(\\omega t)$. As illustrated in\n\\figref{equipotential}A for a single atom $j$, the\nrotation matrix $\\mathbf{\\Omega}(t)$ operates on the initial reference positions\n$\\ve{y}_j^0 = \\ve{x}_j(t_0)$ of atom $j$ at $t=t_0$. At a later\ntime $t$, the reference position has rotated away from its initial place\n(along the blue dashed line), resulting in the force\n\\beq\n\\ve{F}_{\\!j}\\rotiso \n= -\\nabla_{\\!j} \\, V\\rotiso \n= k \\, w_j \\left[\n\\mathbf{\\Omega}(t) (\\ve{y}_j^0 - \\ve{u}) - (\\ve{x}_j - \\ve{u} ) \\right] ,\n\\label{eqn:force_fixed}\n\\eeq\nwhich is directed towards the reference position.\n\n\n\\subsubsection{Pivot-Free Isotropic Potential}\nInstead of a fixed pivot vector \\ve{u} this potential uses the center of\nmass $\\ve{x}_c$ of the rotation group as pivot for the rotation axis,\n\\beq\n\\ve{x}_c   = \\frac{1}{M} \\sum_{i=1}^N m_i \\ve{x}_i \n\\label{eqn:com}\n\\mbox{\\hspace{4ex}and\\hspace{4ex}}\n\\ve{y}_c^0 = \\frac{1}{M} \\sum_{i=1}^N m_i \\ve{y}_i^0 \\ ,\n\\eeq\nwhich yields the ``pivot-free'' isotropic potential\n\\beq\nV\\rotisopf = \\frac{k}{2} \\sum_{i=1}^{N} w_i \\left[ \\mathbf{\\Omega}(t)\n(\\ve{y}_i^0 - \\ve{y}_c^0) - (\\ve{x}_i - \\ve{x}_c) \\right]^2 ,\n\\label{eqn:potisopf}\n\\eeq\nwith forces\n\\beq\n\\mathbf{F}_{\\!j}\\rotisopf = k \\, w_j \n\\left[ \n\\mathbf{\\Omega}(t) ( \\ve{y}_j^0 - \\ve{y}_c^0) \n                 - ( \\ve{x}_j   - \\ve{x}_c )\n\\right] .\n\\label{eqn:force_isopf}\n\\eeq\nWithout mass-weighting, the pivot $\\ve{x}_c$ is the geometrical center of\nthe group. \n\\label{sec:fixed}\n\n\\subsubsection{Parallel Motion Potential Variant}\nThe forces generated by the isotropic potentials\n(\\eqnsref{potiso}{potisopf}) also contain components parallel\nto the rotation axis and thereby restrain motions along the axis of either the\nwhole rotation group (in case of $V\\rotiso$) or within\nthe rotation group (in case of $V\\rotisopf$). For cases where\nunrestrained motion along the axis is preferred, we have implemented a \n``parallel motion'' variant by eliminating all components parallel to the\nrotation axis for the potential. This is achieved by projecting the distance\nvectors between reference and actual positions\n\\beq\n\\ve{r}_i = \\mathbf{\\Omega}(t) (\\ve{y}_i^0 - \\ve{u}) - (\\ve{x}_i - \\ve{u})\n\\eeq\nonto the plane perpendicular to the rotation vector,\n\\beq\n\\label{eqn:project}\n\\ve{r}_i^\\perp :=  \\ve{r}_i - (\\ve{r}_i \\cdot \\hat{\\ve{v}})\\hat{\\ve{v}} \\ ,\n\\eeq\nyielding\n\\bea\n\\nonumber\nV\\rotpm &=& \\frac{k}{2} \\sum_{i=1}^{N} w_i ( \\ve{r}_i^\\perp )^2 \\\\\n        &=& \\frac{k}{2} \\sum_{i=1}^{N} w_i\n \\left\\lbrace\n \\mathbf{\\Omega}(t)\n   (\\ve{y}_i^0 - \\ve{u}) - (\\ve{x}_i - \\ve{u})  \\right. \\nonumber \\\\\n&& \\left. - \\left\\lbrace\n\\left[ \\mathbf{\\Omega}(t)(\\ve{y}_i^0 - \\ve{u}) - (\\ve{x}_i - \\ve{u}) \\right] \\cdot\\hat{\\ve{v}}\n  \\right\\rbrace\\hat{\\ve{v}} \\right\\rbrace^2 ,\n\\label{eqn:potpm}\n\\eea\nand similarly\n\\beq\n\\ve{F}_{\\!j}\\rotpm = k \\, w_j \\, \\ve{r}_j^\\perp .\n\\label{eqn:force_pm}\n\\eeq\n\n\\subsubsection{Pivot-Free Parallel Motion Potential}\nReplacing in \\eqnref{potpm} the fixed pivot \\ve{u} by the center \nof mass $\\ve{x_c}$ yields the pivot-free variant of the parallel motion\npotential. With\n\\beq\n\\ve{s}_i = \\mathbf{\\Omega}(t) (\\ve{y}_i^0 - \\ve{y}_c^0) - (\\ve{x}_i - \\ve{x}_c)\n\\eeq\nthe respective potential and forces are\n\\bea\nV\\rotpmpf &=& \\frac{k}{2} \\sum_{i=1}^{N} w_i ( \\ve{s}_i^\\perp )^2 \\ , \\\\\n\\label{eqn:potpmpf}\n\\ve{F}_{\\!j}\\rotpmpf &=& k \\, w_j \\, \\ve{s}_j^\\perp .\n\\label{eqn:force_pmpf}\n\\eea\n\n\\subsubsection{Radial Motion Potential}\nIn the above variants, the minimum of the rotation potential is either a single\npoint at the reference position $\\ve{y}_i$ (for the isotropic potentials) or a\nsingle line through $\\ve{y}_i$ parallel to the rotation axis (for the\nparallel motion potentials). As a result, radial forces restrict radial motions\nof the atoms. The two subsequent types of rotation potentials, $V\\rotrm$\nand $V\\rotrmtwo$, drastically reduce or even eliminate this effect. The first\nvariant, $V\\rotrm$ (\\figref{equipotential}B), eliminates all force\ncomponents parallel to the vector connecting the reference atom and the\nrotation axis,\n\\beq\nV\\rotrm = \\frac{k}{2} \\sum_{i=1}^{N} w_i \\left[\n\\ve{p}_i\n\\cdot(\\ve{x}_i - \\ve{u}) \\right]^2 ,\n\\label{eqn:potrm}\n\\eeq\nwith\n\\beq\n\\ve{p}_i := \n\\frac{\\hat{\\ve{v}}\\times \\mathbf{\\Omega}(t) (\\ve{y}_i^0 - \\ve{u})} {\\| \\hat{\\ve{v}}\\times \\mathbf{\\Omega}(t) (\\ve{y}_i^0 - \\ve{u})\\|} \\ .\n\\eeq\nThis variant depends only on the distance $\\ve{p}_i \\cdot (\\ve{x}_i -\n\\ve{u})$ of atom $i$ from the plane spanned by $\\hat{\\ve{v}}$ and\n$\\mathbf{\\Omega}(t)(\\ve{y}_i^0 - \\ve{u})$. The resulting force is\n\\beq\n\\mathbf{F}_{\\!j}\\rotrm =\n -k \\, w_j \\left[ \\ve{p}_j\\cdot(\\ve{x}_j - \\ve{u}) \\right] \\,\\ve{p}_j \\,  .\n\\label{eqn:potrm_force}\n\\eeq\n\n\\subsubsection{Pivot-Free Radial Motion Potential}\nProceeding similar to the pivot-free isotropic potential yields a pivot-free\nversion of the above potential. With\n\\beq\n\\ve{q}_i := \n\\frac{\\hat{\\ve{v}}\\times \\mathbf{\\Omega}(t) (\\ve{y}_i^0 - \\ve{y}_c^0)} {\\| \\hat{\\ve{v}}\\times \\mathbf{\\Omega}(t) (\\ve{y}_i^0 - \\ve{y}_c^0)\\|} \\, ,\n\\eeq\nthe potential and force for the pivot-free variant of the radial motion potential read\n\\bea\nV\\rotrmpf & = & \\frac{k}{2} \\sum_{i=1}^{N} w_i \\left[\n\\ve{q}_i\n\\cdot(\\ve{x}_i - \\ve{x}_c)\n\\right]^2 \\, , \\\\\n\\label{eqn:potrmpf}\n\\mathbf{F}_{\\!j}\\rotrmpf & = &\n -k \\, w_j \\left[ \\ve{q}_j\\cdot(\\ve{x}_j - \\ve{x}_c) \\right] \\,\\ve{q}_j \n + k   \\frac{m_j}{M} \\sum_{i=1}^{N} w_i \\left[\n \\ve{q}_i\\cdot(\\ve{x}_i - \\ve{x}_c) \\right]\\,\\ve{q}_i \\, .\n\\label{eqn:potrmpf_force}\n\\eea\n\n\\subsubsection{Radial Motion 2 Alternative Potential}\nAs seen in \\figref{equipotential}B, the force resulting from\n$V\\rotrm$ still contains a small, second-order radial component. In most\ncases, this perturbation is tolerable; if not, the following\nalternative, $V\\rotrmtwo$, fully eliminates the radial contribution to the\nforce, as depicted in \\figref{equipotential}C,\n\\beq\nV\\rotrmtwo = \n\\frac{k}{2} \\sum_{i=1}^{N} w_i\\, \n\\frac{\\left[ (\\hat{\\ve{v}} \\times ( \\ve{x}_i - \\ve{u} ))\n\\cdot \\mathbf{\\Omega}(t)(\\ve{y}_i^0 - \\ve{u}) \\right]^2}\n{\\| \\hat{\\ve{v}} \\times (\\ve{x}_i - \\ve{u}) \\|^2 +\n\\epsilon'} \\, ,\n\\label{eqn:potrm2}\n\\eeq\nwhere a small parameter $\\epsilon'$ has been introduced to avoid singularities.\nFor $\\epsilon'=0$\\,nm$^2$, the equipotential planes are spanned by $\\ve{x}_i -\n\\ve{u}$ and $\\hat{\\ve{v}}$, yielding a force \nperpendicular to $\\ve{x}_i - \\ve{u}$, thus not contracting or\nexpanding structural parts that moved away from or toward the rotation axis.\n\nChoosing a small positive  $\\epsilon'$ ({\\eg},\n$\\epsilon'=0.01$\\,nm$^2$, \\figref{equipotential}D) in the denominator of\n\\eqnref{potrm2} yields a well-defined potential and continuous forces also \nclose to the rotation axis, which is not the case for $\\epsilon'=0$\\,nm$^2$ \n(\\figref{equipotential}C). With\n\\bea\n\\ve{r}_i & := & \\mathbf{\\Omega}(t)(\\ve{y}_i^0 - \\ve{u})\\\\\n\\ve{s}_i & := & \\frac{\\hat{\\ve{v}} \\times (\\ve{x}_i -\n\\ve{u} ) }{ \\| \\hat{\\ve{v}} \\times (\\ve{x}_i - \\ve{u})\n\\| } \\equiv \\; \\Psi_{i} \\;\\; {\\hat{\\ve{v}} \\times\n(\\ve{x}_i-\\ve{u} ) }\\\\\n\\Psi_i^{*}   & := & \\frac{1}{ \\| \\hat{\\ve{v}} \\times\n(\\ve{x}_i-\\ve{u}) \\|^2 + \\epsilon'}\n\\eea\nthe force on atom $j$ reads\n\\beq\n\\ve{F}_{\\!j}\\rotrmtwo  = \n- k\\; \n\\left\\lbrace w_j\\;\n(\\ve{s}_j\\cdot\\ve{r}_{\\!j})\\;\n\\left[ \\frac{\\Psi_{\\!j}^*   }{\\Psi_{\\!j}  }  \\ve{r}_{\\!j} \n     - \\frac{\\Psi_{\\!j}^{*2}}{\\Psi_{\\!j}^3}\n     (\\ve{s}_j\\cdot\\ve{r}_{\\!j})\\ve{s}_j \\right]\n\\right\\rbrace \\times \\hat{\\ve{v}} .\n\\label{eqn:potrm2_force}\n\\eeq\n\n\\subsubsection{Pivot-Free Radial Motion 2 Potential}\nThe pivot-free variant of the above potential is\n\\beq\nV\\rotrmtwopf = \n\\frac{k}{2} \\sum_{i=1}^{N} w_i\\, \n\\frac{\\left[ (\\hat{\\ve{v}} \\times ( \\ve{x}_i - \\ve{x}_c ))\n\\cdot \\mathbf{\\Omega}(t)(\\ve{y}_i^0 - \\ve{y}_c) \\right]^2}\n{\\| \\hat{\\ve{v}} \\times (\\ve{x}_i - \\ve{x}_c) \\|^2 +\n\\epsilon'} \\, .\n\\label{eqn:potrm2pf}\n\\eeq\nWith\n\\bea\n\\ve{r}_i & := & \\mathbf{\\Omega}(t)(\\ve{y}_i^0 - \\ve{y}_c)\\\\\n\\ve{s}_i & := & \\frac{\\hat{\\ve{v}} \\times (\\ve{x}_i -\n\\ve{x}_c ) }{ \\| \\hat{\\ve{v}} \\times (\\ve{x}_i - \\ve{x}_c)\n\\| } \\equiv \\; \\Psi_{i} \\;\\; {\\hat{\\ve{v}} \\times\n(\\ve{x}_i-\\ve{x}_c ) }\\\\ \\Psi_i^{*}   & := & \\frac{1}{ \\| \\hat{\\ve{v}} \\times\n(\\ve{x}_i-\\ve{x}_c) \\|^2 + \\epsilon'}\n\\eea\nthe force on atom $j$ reads\n\\bea\n\\nonumber\n\\ve{F}_{\\!j}\\rotrmtwopf & = &\n- k\\; \n\\left\\lbrace w_j\\;\n(\\ve{s}_j\\cdot\\ve{r}_{\\!j})\\;\n\\left[ \\frac{\\Psi_{\\!j}^*   }{\\Psi_{\\!j}  } \\ve{r}_{\\!j} \n     - \\frac{\\Psi_{\\!j}^{*2}}{\\Psi_{\\!j}^3}\n     (\\ve{s}_j\\cdot\\ve{r}_{\\!j})\\ve{s}_j \\right]\n\\right\\rbrace \\times \\hat{\\ve{v}}\\\\\n     & &\n+ k\\;\\frac{m_j}{M} \\left\\lbrace \\sum_{i=1}^{N}\nw_i\\;(\\ve{s}_i\\cdot\\ve{r}_i) \\; \n\\left[ \\frac{\\Psi_i^*   }{\\Psi_i  }  \\ve{r}_i\n     - \\frac{\\Psi_i^{*2}}{\\Psi_i^3} (\\ve{s}_i\\cdot\\ve{r}_i )\\;\n     \\ve{s}_i \\right] \\right\\rbrace \\times \\hat{\\ve{v}} \\, .\n\\label{eqn:potrm2pf_force}\n\\eea\n\n\\subsection{Flexible Axis Rotation}\nAs sketched in \\figref{rotation}A--B, the rigid body behavior of\nthe fixed axis rotation scheme is a drawback for many applications. In\nparticular, deformations of the rotation group are suppressed when the\nequilibrium atom positions directly depend on the reference positions. \nTo avoid this limitation, \\eqnsref{potrmpf}{potrm2pf}\nwill now be generalized towards a ``flexible axis'' as sketched in\n\\figref{rotation}C. This will be achieved by subdividing the\nrotation group into a set of equidistant slabs perpendicular to\nthe rotation vector, and by applying a separate rotation potential to each\nof these slabs. \\figref{rotation}C shows the midplanes of the slabs \nas dotted straight lines and the centers as thick black dots.\n\nTo avoid discontinuities in the potential and in the forces, we define\n``soft slabs'' by weighing the contributions of each\nslab $n$ to the total potential function $V\\rotflex$ by a Gaussian\nfunction\n\\beq\n\\label{eqn:gaussian}\ng_n(\\ve{x}_i) = \\Gamma \\ \\mbox{exp} \\left(\n-\\frac{\\beta_n^2(\\ve{x}_i)}{2\\sigma^2}  \\right) ,\n\\eeq\ncentered at the midplane of the $n$th slab. Here $\\sigma$ is the width\nof the Gaussian function, $\\Delta x$ the distance between adjacent slabs, and\n\\beq\n\\beta_n(\\ve{x}_i) := \\ve{x}_i \\cdot \\hat{\\ve{v}} - n \\, \\Delta x \\, .\n\\eeq\n%\n\\begin{figure}\n\\centerline{\\includegraphics[width=6.5cm]{plots/gaussians.pdf}}\n\\caption{Gaussian functions $g_n$ centered at $n \\, \\Delta x$ for a slab\ndistance $\\Delta x = 1.5$ nm and $n \\geq -2$. Gaussian function $g_0$ is\nhighlighted in bold; the dashed line depicts the sum of the shown Gaussian\nfunctions.}\n\\label{fig:gaussians}\n\\end{figure}\n%\nA most convenient choice is $\\sigma = 0.7 \\Delta x$ and\n\\begin{displaymath}\n1/\\Gamma = \\sum_{n \\in Z}\n\\mbox{exp}\n\\left(-\\frac{(n - \\frac{1}{4})^2}{2\\cdot 0.7^2}\\right)\n\\approx 1.75464 \\, ,\n\\end{displaymath}\nwhich yields a nearly constant sum, essentially independent of $\\ve{x}_i$\n(dashed line in \\figref{gaussians}), {\\ie},\n\\beq\n\\sum_{n \\in Z} g_n(\\ve{x}_i) =  1 + \\epsilon(\\ve{x}_i) \\, ,\n\\label{eqn:normal}\n\\eeq\nwith $ | \\epsilon(\\ve{x}_i) | < 1.3\\cdot 10^{-4}$. This choice also\nimplies that the individual contributions to the force from the slabs add up to\nunity such that no further normalization is required.\n\nTo each slab center $\\ve{x}_c^n$, all atoms contribute by their\nGaussian-weighted (optionally also mass-weighted) position vectors \n$g_n(\\ve{x}_i) \\, \\ve{x}_i$. The\ninstantaneous slab centers $\\ve{x}_c^n$ are calculated from the\ncurrent positions $\\ve{x}_i$,\n\\beq\n\\label{eqn:defx0} \n\\ve{x}_c^n =\n\\frac{\\sum_{i=1}^N g_n(\\ve{x}_i) \\, m_i \\, \\ve{x}_i}\n     {\\sum_{i=1}^N g_n(\\ve{x}_i) \\, m_i} \\, ,\\\\\n\\eeq\nwhile the reference centers $\\ve{y}_c^n$ are calculated from the reference \npositions $\\ve{y}_i^0$,\n\\beq\n\\label{eqn:defy0}\n\\ve{y}_c^n =\n\\frac{\\sum_{i=1}^N g_n(\\ve{y}_i^0) \\, m_i \\, \\ve{y}_i^0}\n     {\\sum_{i=1}^N g_n(\\ve{y}_i^0) \\, m_i} \\, .\n\\eeq\nDue to the rapid decay of $g_n$, each slab\nwill essentially involve contributions from atoms located within $\\approx\n3\\Delta x$ from the slab center only.\n\n\\subsubsection{Flexible Axis Potential}\nWe consider two flexible axis variants. For the first variant,\nthe slab segmentation procedure with Gaussian weighting is applied to the radial \nmotion potential (\\eqnref{potrmpf}\\,/\\,\\figref{equipotential}B),\nyielding as the contribution of slab $n$\n\\begin{displaymath}\nV^n = \n\\frac{k}{2} \\sum_{i=1}^{N} w_i \\, g_n(\\ve{x}_i) \n\\left[\n\\ve{q}_i^n\n\\cdot\n (\\ve{x}_i - \\ve{x}_c^n) \n\\right]^2  ,\n\\label{eqn:flexpot}\n\\end{displaymath}\nand a total potential function\n\\beq \nV\\rotflex = \\sum_n V^n \\, .\n\\label{eqn:potflex}\n\\eeq\nNote that the global center of mass $\\ve{x}_c$ used in\n\\eqnref{potrmpf} is now replaced by $\\ve{x}_c^n$, the center of mass of\nthe slab. With\n\\bea\n\\ve{q}_i^n & := & \\frac{\\hat{\\ve{v}} \\times\n\\mathbf{\\Omega}(t)(\\ve{y}_i^0 - \\ve{y}_c^n) }{ \\| \\hat{\\ve{v}}\n\\times \\mathbf{\\Omega}(t)(\\ve{y}_i^0 - \\ve{y}_c^n) \\| } \\\\\nb_i^n         & := & \\ve{q}_i^n \\cdot (\\ve{x}_i - \\ve{x}_c^n) \\, ,\n\\eea\nthe resulting force on atom $j$ reads\n\\bea\n\\nonumber\\hspace{-15mm}\n\\ve{F}_{\\!j}\\rotflex &=&\n- \\, k \\, w_j \\sum_n g_n(\\ve{x}_j) \\, b_j^n \\left\\lbrace  \\ve{q}_j^n -\nb_j^n \\frac{\\beta_n(\\ve{x}_j)}{2\\sigma^2} \\hat{\\ve{v}} \\right\\rbrace \\\\ & &\n+ \\, k \\, m_j \\sum_n \\frac{g_n(\\ve{x}_j)}{\\sum_h g_n(\\ve{x}_h)}\n\\sum_{i=1}^{N} w_i \\, g_n(\\ve{x}_i) \\, b_i^n \\left\\lbrace \n\\ve{q}_i^n -\\frac{\\beta_n(\\ve{x}_j)}{\\sigma^2}\n\\left[ \\ve{q}_i^n \\cdot (\\ve{x}_j - \\ve{x}_c^n )\\right]\n\\hat{\\ve{v}} \\right\\rbrace .\n\\label{eqn:potflex_force}\n\\eea\n%\nNote that for $V\\rotflex$, as defined, the slabs are fixed in space and so\nare the reference centers $\\ve{y}_c^n$. If during the simulation the\nrotation group moves too far in $\\ve{v}$ direction, it may enter a\nregion where -- due to the lack of nearby reference positions -- no reference\nslab centers are defined, rendering the potential evaluation impossible. \nWe therefore have included a slightly modified version of this potential that\navoids this problem by attaching the midplane of slab $n=0$ to the center of mass \nof the rotation group, yielding slabs that move with the rotation group. \nThis is achieved by subtracting the center of mass $\\ve{x}_c$ of the\ngroup from the positions, \n\\beq\n\\tilde{\\ve{x}}_i = \\ve{x}_i - \\ve{x}_c \\, , \\mbox{\\ \\ \\ and \\ \\ } \n\\tilde{\\ve{y}}_i^0 = \\ve{y}_i^0 - \\ve{y}_c^0 \\, ,\n\\label{eqn:trafo} \n\\eeq\nsuch that\n\\bea\nV\\rotflext \n  & = & \\frac{k}{2} \\sum_n \\sum_{i=1}^{N} w_i \\, g_n(\\tilde{\\ve{x}}_i)\n  \\left[ \\frac{\\hat{\\ve{v}} \\times \\mathbf{\\Omega}(t)(\\tilde{\\ve{y}}_i^0\n  - \\tilde{\\ve{y}}_c^n) }{ \\| \\hat{\\ve{v}} \\times\n\\mathbf{\\Omega}(t)(\\tilde{\\ve{y}}_i^0 -\n\\tilde{\\ve{y}}_c^n) \\| }\n\\cdot\n (\\tilde{\\ve{x}}_i - \\tilde{\\ve{x}}_c^n) \n\\right]^2 .\n\\label{eqn:potflext}\n\\eea\nTo simplify the force derivation, and for efficiency reasons, we here assume\n$\\ve{x}_c$ to be constant, and thus $\\partial \\ve{x}_c / \\partial x =\n\\partial \\ve{x}_c / \\partial y = \\partial \\ve{x}_c / \\partial z = 0$. The\nresulting force error is small (of order $O(1/N)$ or $O(m_j/M)$ if\nmass-weighting is applied) and can therefore be tolerated. With this assumption,\nthe forces $\\ve{F}\\rotflext$ have the same form as\n\\eqnref{potflex_force}.\n\n\\subsubsection{Flexible Axis 2 Alternative Potential}\nIn this second variant, slab segmentation is applied to $V\\rotrmtwo$\n(\\eqnref{potrm2pf}), resulting in a flexible axis potential without radial\nforce contributions (\\figref{equipotential}C),\n\\beq\nV\\rotflextwo = \n\\frac{k}{2} \\sum_{i=1}^{N} \\sum_n w_i\\,g_n(\\ve{x}_i) \n\\frac{\\left[ (\\hat{\\ve{v}} \\times ( \\ve{x}_i - \\ve{x}_c^n ))\n\\cdot \\mathbf{\\Omega}(t)(\\ve{y}_i^0 - \\ve{y}_c^n) \\right]^2}\n{\\| \\hat{\\ve{v}} \\times (\\ve{x}_i - \\ve{x}_c^n) \\|^2 +\n\\epsilon'} \\, .\n\\label{eqn:potflex2}\n\\eeq\nWith\n\\bea\n\\ve{r}_i^n & := & \\mathbf{\\Omega}(t)(\\ve{y}_i^0 - \\ve{y}_c^n)\\\\\n\\ve{s}_i^n & := & \\frac{\\hat{\\ve{v}} \\times (\\ve{x}_i -\n\\ve{x}_c^n ) }{ \\| \\hat{\\ve{v}} \\times (\\ve{x}_i - \\ve{x}_c^n)\n\\| } \\equiv \\; \\psi_{i} \\;\\; {\\hat{\\ve{v}} \\times (\\ve{x}_i-\\ve{x}_c^n ) }\\\\\n\\psi_i^{*}     & := & \\frac{1}{ \\| \\hat{\\ve{v}} \\times (\\ve{x}_i-\\ve{x}_c^n) \\|^2 + \\epsilon'}\\\\ \nW_j^n          & := & \\frac{g_n(\\ve{x}_j)\\,m_j}{\\sum_h g_n(\\ve{x}_h)\\,m_h}\\\\\n\\ve{S}^n   & := & \n\\sum_{i=1}^{N} w_i\\;g_n(\\ve{x}_i)\n\\; (\\ve{s}_i^n\\cdot\\ve{r}_i^n)\n\\left[ \\frac{\\psi_i^*   }{\\psi_i  }  \\ve{r}_i^n\n     - \\frac{\\psi_i^{*2}}{\\psi_i^3} (\\ve{s}_i^n\\cdot\\ve{r}_i^n )\\;\n     \\ve{s}_i^n \\right] \\label{eqn:Sn}\n\\eea\nthe force on atom $j$ reads\n\\bea\n\\nonumber\n\\ve{F}_{\\!j}\\rotflextwo & = &\n- k\\; \n\\left\\lbrace \\sum_n w_j\\;g_n(\\ve{x}_j)\\;\n(\\ve{s}_j^n\\cdot\\ve{r}_{\\!j}^n)\\;\n\\left[ \\frac{\\psi_j^*   }{\\psi_j  }  \\ve{r}_{\\!j}^n \n     - \\frac{\\psi_j^{*2}}{\\psi_j^3} (\\ve{s}_j^n\\cdot\\ve{r}_{\\!j}^n)\\;\n     \\ve{s}_{\\!j}^n \\right] \\right\\rbrace \\times \\hat{\\ve{v}} \\\\\n\\nonumber\n& &\n+ k \\left\\lbrace \\sum_n W_{\\!j}^n \\, \\ve{S}^n \\right\\rbrace \\times\n\\hat{\\ve{v}}\n- k \\left\\lbrace \\sum_n W_{\\!j}^n \\; \\frac{\\beta_n(\\ve{x}_j)}{\\sigma^2} \\frac{1}{\\psi_j}\\;\\; \n\\ve{s}_j^n \\cdot \n\\ve{S}^n \\right\\rbrace \\hat{\\ve{v}}\\\\ \n& & \n+ \\frac{k}{2} \\left\\lbrace \\sum_n w_j\\;g_n(\\ve{x}_j)\n\\frac{\\beta_n(\\ve{x}_j)}{\\sigma^2} \n\\frac{\\psi_j^*}{\\psi_j^2}( \\ve{s}_j^n \\cdot \\ve{r}_{\\!j}^n )^2 \\right\\rbrace\n\\hat{\\ve{v}} .\n\\label{eqn:potflex2_force}\n\\eea\n\nApplying transformation (\\ref{eqn:trafo}) yields a ``translation-tolerant''\nversion of the flexible\\,2 potential, $V\\rotflextwot$. Again,\nassuming that $\\partial \\ve{x}_c / \\partial x$,  $\\partial \\ve{x}_c /\n\\partial y$, $\\partial \\ve{x}_c / \\partial z$ are small, the\nresulting equations for $V\\rotflextwot$ and $\\ve{F}\\rotflextwot$ are\nsimilar to those of $V\\rotflextwo$ and $\\ve{F}\\rotflextwo$.\n\n\\subsection{Usage}\nTo apply enforced rotation, the particles $i$ that are to\nbe subjected to one of the rotation potentials are defined via index groups\n{\\tt rot-group0}, {\\tt rot-group1}, etc., in the {\\tt .mdp} input file. \nThe reference positions $\\ve{y}_i^0$ are\nread from a special {\\tt .trr} file provided to {\\tt grompp}. If no such file is found,\n$\\ve{x}_i(t=0)$ are used as reference positions and written to {\\tt .trr} such\nthat they can be used for subsequent setups. All parameters of the potentials\nsuch as $k$, $\\epsilon'$, etc. (\\tabref{vars}) are provided as {\\tt .mdp}\nparameters; {\\tt rot-type} selects the type of the potential. \nThe option {\\tt rot-massw} allows to choose whether or not to use\nmass-weighted averaging. \nFor the flexible potentials, a cutoff value $g_n^\\mathrm{min}$ \n(typically  $g_n^\\mathrm{min}=0.001$) makes shure that only\nsignificant contributions to $V$ and \\ve{F} are evaluated, {\\ie} terms with \n$g_n(\\ve{x}) < g_n^\\mathrm{min}$ are omitted.\n\\tabref{quantities} summarizes observables that are written\nto additional output files and which are described below.\n\n\n\\begin{table}[tbp]\n\\caption{Parameters used by the various rotation potentials.\n{\\sf x}'s indicate which parameter is actually used for a given potential.}\n%\\small\n\n\\newcommand{\\kunit}{$\\frac{\\mathrm{kJ}}{\\mathrm{mol} \\cdot \\mathrm{nm}^2}$}\n\\newcommand{\\smtt}[1]{{\\hspace{-0.5ex}\\small #1\\hspace{-0.5ex}}}\n\\label{tab:vars}\n\\begin{center}\n\\begin{tabular}{l>{$}l<{$}rccccccc}\n\\hline\nparameter           &               &                      & $k$      & $\\hat{\\ve{v}}$ & $\\ve{u}$     & $\\omega$    & $\\epsilon'$ & $\\Delta x$        & $g_n^\\mathrm{min}$ \\\\\n\\multicolumn{3}{l}{{\\tt .mdp} input variable name}         & \\smtt{k} & \\smtt{vec}     & \\smtt{pivot} & \\smtt{rate} & \\smtt{eps}  & \\smtt{slab-dist}  & \\smtt{min-gauss}   \\\\\nunit                &               &                      & \\kunit   & -              & nm           & $^\\circ$/ps & nm$^2$      & nm                & \\,-\\,              \\\\[1mm]\n\\hline \\multicolumn{2}{l}{fixed axis potentials:} & eqn.\\\\\nisotropic           & V\\rotiso      & (\\ref{eqn:potiso})   & {\\sf x}  & {\\sf x}        & {\\sf x}      & {\\sf x}     & -           & -                 &  -                 \\\\\n--- pivot-free      & V\\rotisopf    & (\\ref{eqn:potisopf}) & {\\sf x}  & {\\sf x}        & -            & {\\sf x}     & -           & -                 &  -                 \\\\\nparallel motion     & V\\rotpm       & (\\ref{eqn:potpm})    & {\\sf x}  & {\\sf x}        & {\\sf x}      & {\\sf x}     & -           & -                 &  -                 \\\\\n--- pivot-free      & V\\rotpmpf     & (\\ref{eqn:potpmpf})  & {\\sf x}  & {\\sf x}        & -            & {\\sf x}     & -           & -                 &  -                 \\\\\nradial motion       & V\\rotrm       & (\\ref{eqn:potrm})    & {\\sf x}  & {\\sf x}        & {\\sf x}      & {\\sf x}     & -           & -                 &  -                 \\\\\n--- pivot-free      & V\\rotrmpf     & (\\ref{eqn:potrmpf})  & {\\sf x}  & {\\sf x}        & -            & {\\sf x}     & -           & -                 &  -                 \\\\\nradial motion\\,2    & V\\rotrmtwo    & (\\ref{eqn:potrm2})   & {\\sf x}  & {\\sf x}        & {\\sf x}      & {\\sf x}     & {\\sf x}     & -                 &  -                 \\\\\n--- pivot-free      & V\\rotrmtwopf  & (\\ref{eqn:potrm2pf}) & {\\sf x}  & {\\sf x}        & -            & {\\sf x}     & {\\sf x}     & -                 &  -                 \\\\ \\hline\n\\multicolumn{2}{l}{flexible axis potentials:}  & eqn.\\\\\nflexible            & V\\rotflex     & (\\ref{eqn:potflex})  & {\\sf x}  & {\\sf x}        & -            & {\\sf x}     & -           & {\\sf x}           &  {\\sf x}           \\\\\n--- transl. tol.    & V\\rotflext    & (\\ref{eqn:potflext}) & {\\sf x}  & {\\sf x}        & -            & {\\sf x}     & -           & {\\sf x}           &  {\\sf x}           \\\\\nflexible\\,2         & V\\rotflextwo  & (\\ref{eqn:potflex2}) & {\\sf x}  & {\\sf x}        & -            & {\\sf x}     & {\\sf x}     & {\\sf x}           &  {\\sf x}           \\\\\n--- transl. tol.    & V\\rotflextwot &  -                   & {\\sf x}  & {\\sf x}        & -            & {\\sf x}     & {\\sf x}     & {\\sf x}           &  {\\sf x}           \\\\\n\\hline\n\\end{tabular}\n\\end{center}\n\\end{table}\n\n\\begin{table}\n\\caption{Quantities recorded in output files during enforced rotation simulations.\nAll slab-wise data is written every {\\tt nstsout} steps, other rotation data every {\\tt nstrout} steps.}\n\\label{tab:quantities}\n\\begin{center}\n\\begin{tabular}{llllcc}\n\\hline\nquantity                                             & unit    & equation                          & output file     & fixed   & flexible\\\\ \\hline\n$V(t)$                                               & kJ/mol  & see \\ref{tab:vars}                & {\\tt rotation}  & {\\sf x} & {\\sf x} \\\\\n$\\theta_\\mathrm{ref}(t)$                             & degrees & $\\theta_\\mathrm{ref}(t)=\\omega t$ & {\\tt rotation}  & {\\sf x} & {\\sf x} \\\\\n$\\theta_\\mathrm{av}(t)$                              & degrees & (\\ref{eqn:avangle})               & {\\tt rotation}  & {\\sf x} & -       \\\\\n$\\theta_\\mathrm{fit}(t)$, $\\theta_\\mathrm{fit}(t,n)$ & degrees & (\\ref{eqn:rmsdfit})               & {\\tt rotangles} & -       & {\\sf x} \\\\\n$\\ve{y}_0(n)$, $\\ve{x}_0(t,n)$                       & nm      & (\\ref{eqn:defx0}, \\ref{eqn:defy0})& {\\tt rotslabs}  & -       & {\\sf x} \\\\\n$\\tau(t)$                                            & kJ/mol  & (\\ref{eqn:torque})                & {\\tt rotation}  & {\\sf x} & -       \\\\\n$\\tau(t,n)$                                          & kJ/mol  & (\\ref{eqn:torque})                & {\\tt rottorque} & -       & {\\sf x} \\\\ \\hline\n\\end{tabular}\n\\end{center}\n\\end{table}\n\n\n\\subsubsection*{Angle of Rotation Groups: Fixed Axis}\nFor fixed axis rotation, the average angle $\\theta_\\mathrm{av}(t)$ of the \ngroup relative to the reference group is determined via the distance-weighted\nangular deviation of all rotation group atoms from their reference positions,\n\\beq\n\\theta_\\mathrm{av} = \\left. \\sum_{i=1}^{N} r_i \\ \\theta_i \\right/ \\sum_{i=1}^N r_i \\ .\n\\label{eqn:avangle}\n\\eeq\nHere, $r_i$ is the distance of the reference position to the rotation axis, and\nthe difference angles $\\theta_i$ are determined from the atomic positions, \nprojected onto a plane perpendicular to the rotation axis through pivot point\n$\\ve{u}$ (see \\eqnref{project} for the definition of $\\perp$),\n\\beq\n\\cos \\theta_i = \n\\frac{(\\ve{y}_i-\\ve{u})^\\perp \\cdot (\\ve{x}_i-\\ve{u})^\\perp}\n     { \\| (\\ve{y}_i-\\ve{u})^\\perp \\cdot (\\ve{x}_i-\\ve{u})^\\perp\n     \\| } \\ .\n\\eeq\n%\nThe sign of $\\theta_\\mathrm{av}$ is chosen such that\n$\\theta_\\mathrm{av} > 0$ if the actual structure rotates ahead of the reference.\n\n\\subsubsection*{Angle of Rotation Groups: Flexible Axis}\nFor flexible axis rotation, two outputs are provided, the angle of the\nentire rotation group, and separate angles for the segments in the slabs.\nThe angle of the entire rotation group is determined by an RMSD fit \nof $\\ve{x}_i$\nto the reference positions $\\ve{y}_i^0$ at $t=0$, yielding $\\theta_\\mathrm{fit}$\nas the angle by which the reference has to be rotated around $\\hat{\\ve{v}}$ \nfor the optimal fit,\n\\beq\n\\mathrm{RMSD} \\big( \\ve{x}_i,\\ \\mathbf{\\Omega}(\\theta_\\mathrm{fit})\n\\ve{y}_i^0 \\big) \\stackrel{!}{=} \\mathrm{min} \\, .\n\\label{eqn:rmsdfit}\n\\eeq\nTo determine the local angle for each slab $n$, both reference and actual\npositions are weighted with the Gaussian function of slab $n$, and \n$\\theta_\\mathrm{fit}(t,n)$ is calculated as in \\eqnref{rmsdfit}) from the\nGaussian-weighted positions.\n\nFor all angles, the {\\tt .mdp} input option {\\tt rot-fit-method} controls\nwhether a normal RMSD fit is performed or whether for the fit each\nposition $\\ve{x}_i$ is put at the same distance to the rotation axis as its\nreference counterpart $\\ve{y}_i^0$. In the latter case, the RMSD\nmeasures only angular differences, not radial ones.\n\n\n\\subsubsection*{Angle Determination by Searching the Energy Minimum}\nAlternatively, for {\\tt rot-fit-method = potential}, the angle of the rotation \ngroup is determined as the angle for which the rotation potential energy is minimal.\nTherefore, the used rotation potential is additionally evaluated for a set of angles\naround the current reference angle. In this case, the {\\tt rotangles.log} output file\ncontains the values of the rotation potential at the chosen set of angles, while \n{\\tt rotation.xvg} lists the angle with minimal potential energy.\n\n\n\\subsubsection*{Torque}\n\\label{torque}\nThe torque $\\ve{\\tau}(t)$ exerted by the rotation potential is calculated for fixed\naxis rotation via\n\\beq\n\\ve{\\tau}(t) = \\sum_{i=1}^{N} \\ve{r}_i(t) \\times \\ve{f}_{\\!i}^\\perp(t) ,\n\\label{eqn:torque}\n\\eeq\nwhere $\\ve{r}_i(t)$ is the distance vector from the rotation axis to\n$\\ve{x}_i(t)$ and $\\ve{f}_{\\!i}^\\perp(t)$ is the force component\nperpendicular to $\\ve{r}_i(t)$ and $\\hat{\\ve{v}}$. For flexible axis\nrotation, torques $\\ve{\\tau}_{\\!n}$ are calculated for each slab using the\nlocal rotation axis of the slab and the Gaussian-weighted positions.\n\n\n\\section{\\normindex{Computational Electrophysiology}}\n\\label{sec:compel}\n\nThe Computational Electrophysiology (CompEL) protocol \\cite{Kutzner2011b} allows the simulation of\nion flux through membrane channels, driven by transmembrane potentials or ion\nconcentration gradients. Just as in real cells, CompEL establishes transmembrane\npotentials by sustaining a small imbalance of charges $\\Delta q$ across the membrane,\nwhich gives rise to a potential difference $\\Delta U$ according to the membrane capacitance:\n\\beq\n\\Delta U = \\Delta q / C_{membrane}\n\\eeq\nThe transmembrane electric field and concentration gradients are controlled by\n{\\tt .mdp} options, which allow the user to set reference counts for the ions on either side\nof the membrane. If a difference between the actual and the reference numbers persists\nover a certain time span, specified by the user, a number of ion/water pairs are\nexchanged between the compartments until the reference numbers are restored.\nAlongside the calculation of channel conductance and ion selectivity, CompEL simulations also\nenable determination of the channel reversal potential, an important\ncharacteristic obtained in electrophysiology experiments.\n\nIn a CompEL setup, the simulation system is divided into two compartments {\\bf A} and {\\bf B}\nwith independent ion concentrations. This is best achieved by using double bilayer systems with\na copy (or copies) of the channel/pore of interest in each bilayer (\\figref{compelsetup} A, B).\nIf the channel axes point in the same direction, channel flux is observed\nsimultaneously at positive and negative potentials in this way, which is for instance\nimportant for studying channel rectification.\n\n\\begin{figure}\n\\centerline{\\includegraphics[width=13.5cm]{plots/compelsetup.pdf}}\n\\caption{Typical double-membrane setup for CompEL simulations (A, B). Plot (C) shows\nthe potential difference $\\Delta U$ resulting\nfrom the selected charge imbalance $\\Delta q_{ref}$ between the compartments.}\n\\label{fig:compelsetup}\n\\end{figure}\n\nThe potential difference $\\Delta U$ across the membrane is easily calculated with the\n{\\tt gmx potential} utility. By this, the potential drop along $z$ or the\npore axis is exactly known in each time interval of the simulation (\\figref{compelsetup} C).\nType and number of ions $n_i$ of charge $q_i$, traversing the channel in the simulation,\nare written to the {\\tt swapions.xvg} output file, from which the average channel\nconductance $G$ in each interval $\\Delta t$ is determined by:\n\\beq\nG = \\frac{\\sum_{i} n_{i}q_{i}}{\\Delta t \\, \\Delta U} \\, .\n\\eeq\nThe ion selectivity is calculated as the number flux ratio of different species.\nBest results are obtained by averaging these values over several overlapping time intervals.\n\nThe calculation of reversal potentials is best achieved using a small set of simulations in which a given\ntransmembrane concentration gradient is complemented with small ion imbalances of varying magnitude. For\nexample, if one compartment contains 1\\,M salt and the other 0.1\\,M, and given charge neutrality otherwise,\na set of simulations with $\\Delta q = 0\\,e$, $\\Delta q = 2\\,e$, $\\Delta q = 4\\,e$ could\nbe used. Fitting a straight line through the current-voltage relationship of all obtained\n$I$-$U$ pairs near zero current will then yield $U_{rev}$.\n\n\\subsection{Usage}\nThe following {\\tt .mdp} options control the CompEL protocol:\n{\\small\n\\begin{verbatim}\nswapcoords     = Z            ; Swap positions: no, X, Y, Z\nswap-frequency = 100          ; Swap attempt frequency\n\\end{verbatim}}\nChoose {\\tt Z} if your membrane is in the $xy$-plane (\\figref{compelsetup} A, B).\nIons will be exchanged between compartments depending on their $z$-positions alone.\n{\\tt swap-frequency} determines how often a swap attempt will be made.\nThis step requires that the positions of the ions, solvent, and swap groups are\ncommunicated between the parallel processes, so if chosen too small it can decrease the simulation\nperformance.\n{\\small\n\\begin{verbatim}\nsplit-group0   = channel0     ; Defines compartment boundary \nsplit-group1   = channel1     ; Defines other compartment boundary \nmassw-split0   = no           ; use mass-weighted center?\nmassw-split1   = no\n\\end{verbatim}}\n{\\tt split-group0} and {\\tt split-group1} are two index groups that define the boundaries\nbetween the two compartments, which are usually the centers of the channels.\nIf {\\tt massw-split0} or {\\tt massw-split1} are set to {\\tt yes}, the center of mass\nof each index group is used as boundary, here in $z$-direction. Otherwise, the\ngeometrical centers will be used ($\\times$ in \\figref{compelsetup} A). If, such as here, a membrane\nchannel is selected as split group, the center of the channel will define the dividing\nplane between the compartments (dashed horizontal line in the figure). All index groups\nmust be defined in the index file.\n{\\small\n\\begin{verbatim}\nswap-group     = NA+_CL-      ; Ions to be included in exchange\nsolvent-group  = SOL          ; Group name of solvent molecules\ncyl0-r         = 5.0          ; Split cylinder 0: pore radius (nm)\ncyl0-up        = 0.75         ; Split cylinder 0 upper extension (nm)\ncyl0-down      = 0.75         ; Split cylinder 0 lower extension (nm)\ncyl1-r         = 5.0          ; same for other channel\ncyl1-up        = 0.75\ncyl1-down      = 0.75\ncoupl-steps    = 10           ; Average over these many swap steps\nthreshold      = 1            ; Do not swap if < threshold\n\\end{verbatim}}\n{\\tt swap-group} identifies the index group of ions that \nshould be involved in the flux and exchange cycles, {\\tt solvent-group} defines the solvent\ngroup with which they are swapped. The cylinder options only influence the counting of\nions, i.e., ions will be counted as having traveled through either channel 0 or channel 1\naccording to the definition of (channel) cylinder radius, upper and lower extension,\nrelative to the location of the respective split group. This will not affect the actual\nflux or exchange, but will provide you with the ion permeation numbers across\neach of the channels. Note that an ion can only be counted as passing through a particular\nchannel if it is detected \\emph{within} the defined split cylinder in a swap step.\nIf {\\tt swap-frequency} is chosen too high, a particular ion may be detected in compartment {\\bf A}\nin one swap step, and in compartment {\\bf B} in the following swap step, so it will be unclear\nthrough which of the channels it has passed.\n\n{\\tt coupl-steps} sets the number of swap attempt steps. A discrepancy between\nactual and reference ion numbers in each compartment must persist over this many attempts\nbefore an actual exchange takes place. If {\\tt coupl-steps} is set to 1, then the momentary ion distribution determines\nwhether ions are exchanged. {\\tt coupl-steps} \\textgreater\\ 1 will use the time-average\nof ion distributions over the selected number of attempt steps instead. This can be useful, for example,\nwhen ions diffuse near compartment boundaries, which would lead to numerous unproductive\nion exchanges. A {\\tt threshold} of 1 means that a swap is performed if the average ion\ncount in a compartment differs by at least 1 from the requested values. Higher thresholds\nwill lead to toleration of larger differences. Ions are exchanged until the requested\nnumber $\\pm$ the threshold is reached.\n\n{\\small\n\\begin{verbatim}\nanionsA  = -1                 ; Reference count of anions in A\ncationsA = -1                 ; ... of cations in A\nanionsB  = -1                 ; ... of anions in B\ncationsB = -1                 ; ... of cations in B\n\\end{verbatim}}\nThese options set the requested number of anions and cations for each of the two compartments.\nA number of {\\tt -1} means fix the numbers found in time step 0. Note that these numbers\nneed to add up to the total number of ions in the swap group.\n\nNote that a double-layered system for CompEL simulations can be easily prepared by\nduplicating an existing membrane/channel MD system in the direction of the membrane\nnormal (typically $z$) with {\\tt gmx editconf -translate 0 0 <l_z>}, where {\\tt l_z}\nis the box length in that direction. If you have already defined index groups for\nthe channel for the single-layered system, {\\tt gmx make_ndx -n index.ndx -twin} will\nprovide you with the groups for the double-layered system.\n\nTo suppress large fluctuations of the membranes along the swap direction,\nit may be useful to apply a harmonic potential (acting only in the swap dimension)\nbetween each of the two channel and/or bilayer centers using umbrella pulling\n(see section~\\ref{sec:pull}).\n\n\\subsection*{Multimeric channels}\nIf a split group consists of more than one molecule, the correct PBC image of all molecules\nwith respect to each other has to be chosen such that the channel center can be correctly\ndetermined. \\gromacs\\ assumes that the starting structure in the {\\tt .tpr}\nfile has the correct PBC representation. Set the following environment variable\nto check whether that is the case:\n\\begin{itemize}\n\\item   {\\tt GMX_COMPELDUMP}: output the starting structure after it has been made whole to\n        {\\tt .pdb} file.\n\\end{itemize}\n\n\n\\section{Calculating a PMF using the free-energy code}\n\\label{sec:fepmf}\n\\index{potentials of mean force}\n\\index{free energy calculations}\nThe free-energy coupling-parameter approach (see~\\secref{fecalc})\nprovides several ways to calculate potentials of mean force.\nA potential of mean force between two atoms can be calculated\nby connecting them with a harmonic potential or a constraint.\nFor this purpose there are special potentials that avoid the generation of\nextra exclusions, see~\\secref{excl}.\nWhen the position of the minimum or the constraint length is 1 nm more\nin state B than in state A, the restraint or constraint force is given\nby $\\partial H/\\partial \\lambda$.\nThe distance between the atoms can be changed as a function of $\\lambda$\nand time by setting {\\tt delta-lambda} in the {\\tt .mdp} file.\nThe results should be identical (although not numerically\ndue to the different implementations) to the results of the pull code\nwith umbrella sampling and constraint pulling.\nUnlike the pull code, the free energy code can also handle atoms that\nare connected by constraints.\n\nPotentials of mean force can also be calculated using position restraints.\nWith position restraints, atoms can be linked to a position in space\nwith a harmonic potential (see \\ssecref{positionrestraint}).\nThese positions can be made a function of the coupling parameter $\\lambda$.\nThe positions for the A and the B states are supplied to {\\tt grompp} with\nthe {\\tt -r} and {\\tt -rb} options, respectively.\nOne could use this approach to do \\normindex{targeted MD};\nnote that we do not encourage the use of targeted MD for proteins.\nA protein can be forced from one conformation to another by using\nthese conformations as position restraint coordinates for state A and B.\nOne can then slowly change $\\lambda$ from 0 to 1.\nThe main drawback of this approach is that the conformational freedom\nof the protein is severely limited by the position restraints,\nindependent of the change from state A to B.\nAlso, the protein is forced from state A to B in an almost straight line,\nwhereas the real pathway might be very different.\nAn example of a more fruitful application is a solid system or a liquid\nconfined between walls where one wants to measure the force required\nto change the separation between the boundaries or walls.\nBecause the boundaries (or walls) already need to be fixed,\nthe position restraints do not limit the system in its sampling.\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\\newcommand{\\amine}{\\sf -NH$_2$}\n\\newcommand{\\amines}{\\sf -NH-}\n\\newcommand{\\aminep}{\\sf -NH$_3^+$}\n\\section{Removing fastest \\swapindex{degrees of}{freedom}}\n\\label{sec:rmfast}\nThe maximum time step in MD simulations is limited by the smallest\noscillation period that can be found in the simulated\nsystem. Bond-stretching vibrations are in their quantum-mechanical\nground state and are therefore better represented by a constraint \ninstead of a harmonic potential.\n\nFor the remaining degrees of freedom, the shortest oscillation period\n(as measured from a simulation) is 13~fs for bond-angle vibrations\ninvolving hydrogen atoms. Taking as a guideline that with a Verlet\n(leap-frog) integration scheme a minimum of 5 numerical integration\nsteps should be performed per period of a harmonic oscillation in\norder to integrate it with reasonable accuracy, the maximum time step\nwill be about 3~fs. Disregarding these very fast oscillations of\nperiod 13~fs, the next shortest periods are around 20~fs, which will\nallow a maximum time step of about 4~fs.\n\nRemoving the bond-angle degrees of freedom from hydrogen atoms can\nbest be done by defining them as \\normindex{virtual interaction sites}\ninstead of normal atoms. Whereas a normal atom is connected to the molecule\nwith bonds, angles and dihedrals, a virtual site's position is calculated\nfrom the position of three nearby heavy atoms in a predefined manner\n(see also \\secref{virtual_sites}). For the hydrogens in water and in\nhydroxyl, sulfhydryl, or amine groups, no degrees of freedom can be\nremoved, because rotational freedom should be preserved. The only\nother option available to slow down these motions is to increase the\nmass of the hydrogen atoms at the expense of the mass of the connected\nheavy atom. This will increase the moment of inertia of the water\nmolecules and the hydroxyl, sulfhydryl, or amine groups, without\naffecting the equilibrium properties of the system and without\naffecting the dynamical properties too much. These constructions will\nshortly be described in \\secref{vsitehydro} and have previously\nbeen described in full detail~\\cite{feenstra99}.\n\nUsing both virtual sites and \\swapindex{modified}{mass}es, the next\nbottleneck is likely to be formed by the improper dihedrals (which are\nused to preserve planarity or chirality of molecular groups) and the\npeptide dihedrals. The peptide dihedral cannot be changed without\naffecting the physical behavior of the protein. The improper dihedrals\nthat preserve planarity mostly deal with aromatic residues. Bonds,\nangles, and dihedrals in these residues can also be replaced with\nsomewhat elaborate virtual site constructions.\n\nAll modifications described in this section can be performed using the\n{\\gromacs} topology building tool {\\tt \\normindex{pdb2gmx}}. Separate\noptions exist to increase hydrogen masses, virtualize all hydrogen atoms,\nor also virtualize all aromatic residues. {\\bf Note} that when all hydrogen\natoms are virtualized, those inside the aromatic residues will be\nvirtualized as well, {\\ie} hydrogens in the aromatic residues are treated\ndifferently depending on the treatment of the aromatic residues.\n\nParameters for the virtual site constructions for the hydrogen atoms are\ninferred from the force-field parameters ({\\em vis}. bond lengths and\nangles) directly by {\\tt \\normindex{grompp}} while processing the\ntopology file.  The constructions for the aromatic residues are based\non the bond lengths and angles for the geometry as described in the\nforce fields, but these parameters are hard-coded into {\\tt\n\\normindex{pdb2gmx}} due to the complex nature of the construction\nneeded for a whole aromatic group.\n\n\\subsection{Hydrogen bond-angle vibrations}\n\\label{sec:vsitehydro}\n\\subsubsection{Construction of virtual sites} %%%%%%%%%%%%%%%%%%%%%%%%%\n\\begin{figure}\n\\centerline{\\includegraphics[width=11cm]{plots/dumtypes}}\n\\caption[Virtual site constructions for hydrogen atoms.]{The different\ntypes of virtual site constructions used for hydrogen atoms. The atoms\nused in the construction of the virtual site(s) are depicted as black\ncircles, virtual sites as gray ones. Hydrogens are smaller than heavy\natoms. {\\sf A}: fixed bond angle, note that here the hydrogen is not a\nvirtual site; {\\sf B}: in the plane of three atoms, with fixed distance;\n{\\sf C}: in the plane of three atoms, with fixed angle and distance;\n{\\sf D}: construction for amine groups ({\\amine} or {\\aminep}), see\ntext for details.}\n\\label{fig:vsitehydro}\n\\end{figure}\n\nThe goal of defining hydrogen atoms as virtual sites is to remove all\nhigh-frequency degrees of freedom from them. In some cases, not all\ndegrees of freedom of a hydrogen atom should be removed, {\\eg} in the\ncase of hydroxyl or amine groups the rotational freedom of the\nhydrogen atom(s) should be preserved. Care should be taken that no\nunwanted correlations are introduced by the construction of virtual\nsites, {\\eg} bond-angle vibration between the constructing atoms could\ntranslate into hydrogen bond-length vibration. Additionally, since\nvirtual sites are by definition massless, in order to preserve total\nsystem mass, the mass of each hydrogen atom that is treated as virtual\nsite should be added to the bonded heavy atom.\n\nTaking into account these considerations, the hydrogen atoms in a\nprotein naturally fall into several categories, each requiring a\ndifferent approach (see also \\figref{vsitehydro}).\n\n\\begin{itemize}\n\n\\item{\\em hydroxyl ({\\sf -OH}) or sulfhydryl ({\\sf -SH})\nhydrogen:\\/} The only internal degree of freedom in a hydroxyl group\nthat can be constrained is the bending of the {\\sf C-O-H} angle. This\nangle is fixed by defining an additional bond of appropriate length,\nsee \\figref{vsitehydro}A. Doing so removes the high-frequency angle bending,\nbut leaves the dihedral rotational freedom. The same goes for a\nsulfhydryl group. {\\bf Note} that in these cases the hydrogen is not treated\nas a virtual site.\n\n\\item{\\em single amine or amide ({\\amines}) and aromatic hydrogens\n({\\sf -CH-}):\\/} The position of these hydrogens cannot be constructed\nfrom a linear combination of bond vectors, because of the flexibility\nof the angle between the heavy atoms. Instead, the hydrogen atom is\npositioned at a fixed distance from the bonded heavy atom on a line\ngoing through the bonded heavy atom and a point on the line through\nboth second bonded atoms, see \\figref{vsitehydro}B.\n\n\\item{\\em planar amine ({\\amine}) hydrogens:\\/} The method used for\nthe single amide hydrogen is not well suited for planar amine groups,\nbecause no suitable two heavy atoms can be found to define the\ndirection of the hydrogen atoms. Instead, the hydrogen is constructed\nat a fixed distance from the nitrogen atom, with a fixed angle to the\ncarbon atom, in the plane defined by one of the other heavy atoms, see\n\\figref{vsitehydro}C.\n\n\\item{\\em amine group (umbrella {\\amine} or {\\aminep}) hydrogens:\\/}\nAmine hydrogens with rotational freedom cannot be constructed as virtual\nsites from the heavy atoms they are connected to, since this would\nresult in loss of the rotational freedom of the amine group. To\npreserve the rotational freedom while removing the hydrogen bond-angle\ndegrees of freedom, two ``dummy masses'' are constructed with the same\ntotal mass, moment of inertia (for rotation around the {\\sf C-N} bond)\nand center of mass as the amine group. These dummy masses have no\ninteraction with any other atom, except for the fact that they are\nconnected to the carbon and to each other, resulting in a rigid\ntriangle. From these three particles, the positions of the nitrogen and\nhydrogen atoms are constructed as linear combinations of the two\ncarbon-mass vectors and their outer product, resulting in an amine\ngroup with rotational freedom intact, but without other internal\ndegrees of freedom. See \\figref{vsitehydro}D.\n\n\\end{itemize}\n\n\\begin{figure}\n\\centerline{\\includegraphics[width=15cm]{plots/dumaro}}\n\\caption[Virtual site constructions for aromatic residues.]{The\ndifferent types of virtual site constructions used for aromatic\nresidues. The atoms used in the construction of the virtual site(s) are\ndepicted as black circles, virtual sites as gray ones. Hydrogens are\nsmaller than heavy atoms. {\\sf A}: phenylalanine; {\\sf B}: tyrosine\n(note that the hydroxyl hydrogen is {\\em not} a virtual site); {\\sf C}:\ntryptophan; {\\sf D}: histidine.}\n\\label{fig:vistearo}\n\\end{figure}\n\n\\subsection{Out-of-plane vibrations in aromatic groups}\n\\label{sec:vsitearo}\nThe planar arrangements in the side chains of the aromatic residues\nlends itself perfectly to a virtual-site construction, giving a\nperfectly planar group without the inherently unstable constraints\nthat are necessary to keep normal atoms in a plane. The basic approach\nis to define three atoms or dummy masses with constraints between them\nto fix the geometry and create the rest of the atoms as simple virtual\nsites type (see \\secref{virtual_sites}) from these three. Each of\nthe aromatic residues require a different approach:\n\n\\begin{itemize}\n\n\\item{\\em Phenylalanine:\\/} {\\sf C}$_\\gamma$, {\\sf C}$_{{\\epsilon}1}$,\nand {\\sf C}$_{{\\epsilon}2}$ are kept as normal atoms, but with each a\nmass of one third the total mass of the phenyl group. See\n\\figref{vsitehydro}A.\n\n\\item{\\em Tyrosine:\\/} The ring is treated identically to the\nphenylalanine ring. Additionally, constraints are defined between {\\sf\nC}$_{{\\epsilon}1}$, {\\sf C}$_{{\\epsilon}2}$, and {\\sf O}$_{\\eta}$.\nThe original improper dihedral angles will keep both triangles (one\nfor the ring and one with {\\sf O}$_{\\eta}$) in a plane, but due to the\nlarger moments of inertia this construction will be much more\nstable. The bond-angle in the hydroxyl group will be constrained by a\nconstraint between {\\sf C}$_\\gamma$ and {\\sf H}$_{\\eta}$. {\\bf Note} that\nthe hydrogen is not treated as a virtual site. See\n\\figref{vsitehydro}B.\n\n\\item{\\em Tryptophan:\\/} {\\sf C}$_\\beta$ is kept as a normal atom\nand two dummy masses are created at the center of mass of each of the\nrings, each with a mass equal to the total mass of the respective ring\n({\\sf C}$_{{\\delta}2}$ and {\\sf C}$_{{\\epsilon}2}$ are each\ncounted half for each ring). This keeps the overall center of mass and\nthe moment of inertia almost (but not quite) equal to what it was. See\n\\figref{vsitehydro}C.\n\n\\item{\\em Histidine:\\/} {\\sf C}$_\\gamma$, {\\sf C}$_{{\\epsilon}1}$\nand {\\sf N}$_{{\\epsilon}2}$ are kept as normal atoms, but with masses\nredistributed such that the center of mass of the ring is\npreserved. See \\figref{vsitehydro}D.\n\n\\end{itemize}\n\n\\section{Viscosity calculation\\index{viscosity}}\n\nThe shear viscosity is a property of liquids that can be determined easily  \nby experiment. It is useful for parameterizing a force field\nbecause it is a kinetic property, while most other properties\nwhich are used for parameterization are thermodynamic.\nThe viscosity is also an important property, since it influences\nthe rates of conformational changes of molecules solvated in the liquid.\n\nThe viscosity can be calculated from an equilibrium simulation using\nan Einstein relation:\n\\beq\n\\eta = \\frac{1}{2}\\frac{V}{k_B T} \\lim_{t \\rightarrow \\infty}\n\\frac{\\mbox{d}}{\\mbox{d} t} \\left\\langle \n\\left( \\int_{t_0}^{{t_0}+t} P_{xz}(t') \\mbox{d} t' \\right)^2\n\\right\\rangle_{t_0}\n\\eeq\nThis can be done with {\\tt g_energy}.\nThis method converges very slowly~\\cite{Hess2002a}, and as such\na nanosecond simulation might not\nbe long enough for an accurate determination of the viscosity.\nThe result is very dependent on the treatment of the electrostatics.\nUsing a (short) cut-off results in large noise on the off-diagonal\npressure elements, which can increase the calculated viscosity by an order\nof magnitude.\n\n{\\gromacs} also has a non-equilibrium method for determining\nthe viscosity~\\cite{Hess2002a}.\nThis makes use of the fact that energy, which is fed into system by\nexternal forces, is dissipated through viscous friction. The generated heat\nis removed by coupling to a heat bath. For a Newtonian liquid adding a \nsmall force will result in a velocity gradient according to the following\nequation:\n\\beq\na_x(z) + \\frac{\\eta}{\\rho} \\frac{\\partial^2 v_x(z)}{\\partial z^2} = 0\n\\eeq\nHere we have applied an acceleration $a_x(z)$ in the $x$-direction, which\nis a function of the $z$-coordinate.\nIn {\\gromacs} the acceleration profile is:\n\\beq\na_x(z) = A \\cos\\left(\\frac{2\\pi z}{l_z}\\right)\n\\eeq\nwhere $l_z$ is the height of the box. The generated velocity profile is:\n\\beq\nv_x(z) = V \\cos\\left(\\frac{2\\pi z}{l_z}\\right)\n\\eeq\n\\beq\nV = A \\frac{\\rho}{\\eta}\\left(\\frac{l_z}{2\\pi}\\right)^2\n\\eeq\nThe viscosity can be calculated from $A$ and $V$:\n\\beq\n\\label{visc}\n\\eta = \\frac{A}{V}\\rho \\left(\\frac{l_z}{2\\pi}\\right)^2\n\\eeq\n\nIn the simulation $V$ is defined as:\n\\beq\nV = \\frac{\\displaystyle \\sum_{i=1}^N m_i v_{i,x} 2 \\cos\\left(\\frac{2\\pi z}{l_z}\\right)}\n         {\\displaystyle \\sum_{i=1}^N m_i}\n\\eeq\nThe generated velocity profile is not coupled to the heat bath. Moreover,\nthe velocity profile is excluded from the kinetic energy.\nOne would like $V$ to be as large as possible to get good statistics.\nHowever, the shear rate should not be so high that the system gets too far\nfrom equilibrium. The maximum shear rate occurs where the cosine is zero,\nthe rate being:\n\\beq\n\\mbox{sh}_{\\max} =  \\max_z \\left| \\frac{\\partial v_x(z)}{\\partial z} \\right|\n= A \\frac{\\rho}{\\eta} \\frac{l_z}{2\\pi}\n\\eeq\nFor a simulation with: $\\eta=10^{-3}$ [kg\\,m$^{-1}$\\,s$^{-1}$],\n$\\rho=10^3$\\,[kg\\,m$^{-3}$] and $l_z=2\\pi$\\,[nm],\n$\\mbox{sh}_{\\max}=1$\\,[ps\\,nm$^{-1}$] $A$.\nThis shear rate should be smaller than one over the longest\ncorrelation time in the system. For most liquids, this will be the rotation\ncorrelation time, which is around 10 ps. In this case, $A$ should\nbe smaller than 0.1\\,[nm\\,ps$^{-2}$].\nWhen the shear rate is too high, the observed viscosity will be too low.\nBecause $V$ is proportional to the square of the box height,\nthe optimal box is elongated in the $z$-direction.\nIn general, a simulation length of 100 ps is enough to obtain an\naccurate value for the viscosity.\n\nThe heat generated by the viscous friction is removed by coupling to a heat\nbath. Because this coupling is not instantaneous the real temperature of the\nliquid will be slightly lower than the observed temperature.\nBerendsen derived this temperature shift~\\cite{Berendsen91}, which can\nbe written in terms of the shear rate as:\n\\beq\nT_s = \\frac{\\eta\\,\\tau}{2 \\rho\\,C_v} \\mbox{sh}_{\\max}^2\n\\eeq\nwhere $\\tau$ is the coupling time for the Berendsen thermostat and\n$C_v$ is the heat capacity. Using the values of the example above,\n$\\tau=10^{-13}$ [s] and $C_v=2 \\cdot 10^3$\\,[J kg$^{-1}$\\,K$^{-1}$], we\nget: $T_s=25$\\,[K\\,ps$^{-2}$]\\,sh$_{\\max}^2$. When we want the shear\nrate to be smaller than $1/10$\\,[ps$^{-1}$], $T_s$ is smaller than\n0.25\\,[K], which is negligible.\n\n{\\bf Note} that the system has to build up the velocity profile when starting\nfrom an equilibrium state. This build-up time is of the order of the\ncorrelation time of the liquid.\n\nTwo quantities are written to the energy file, along with their averages\nand fluctuations: $V$ and $1/\\eta$, as obtained from (\\ref{visc}).\n\n\\section{Tabulated interaction functions\\index{tabulated interaction functions}}\n\\subsection{Cubic splines for potentials}\n\\label{subsec:cubicspline}\nIn some of the inner loops of {\\gromacs}, look-up tables are used \nfor computation of potential and forces. \nThe tables are interpolated using a cubic\nspline algorithm. \nThere are separate tables for electrostatic, dispersion, and repulsion\ninteractions,\nbut for the sake of caching performance these have been combined\ninto a single array. \nThe cubic spline interpolation for $x_i \\leq x < x_{i+1}$ looks like this:\n\\beq\nV_s(x) = A_0 + A_1 \\,\\epsilon + A_2 \\,\\epsilon^2 + A_3 \\,\\epsilon^3\n\\label{eqn:spline}\n\\eeq\nwhere the table spacing $h$ and fraction $\\epsilon$ are given by:\n\\bea\nh\t&=&\tx_{i+1} - x_i\t\\\\\n\\epsilon&=&\t(x - x_i)/h\n\\eea\nso that $0 \\le \\epsilon < 1$.\nFrom this, we can calculate the derivative in order to determine the forces:\n\\beq\n-V_s'(x) ~=~ \n-\\frac{{\\rm d}V_s(x)}{{\\rm d}\\epsilon}\\frac{{\\rm d}\\epsilon}{{\\rm d}x} ~=~\n-(A_1 + 2 A_2 \\,\\epsilon + 3 A_3 \\,\\epsilon^2)/h\n\\eeq\nThe four coefficients are determined from the four conditions\nthat $V_s$ and $-V_s'$ at both ends of each interval should match\nthe exact potential $V$ and force $-V'$.\nThis results in the following errors for each interval:\n\\bea\n|V_s  - V  |_{max} &=& V'''' \\frac{h^4}{384} + O(h^5) \\\\\n|V_s' - V' |_{max} &=& V'''' \\frac{h^3}{72\\sqrt{3}} + O(h^4) \\\\\n|V_s''- V''|_{max} &=& V'''' \\frac{h^2}{12}  + O(h^3)\n\\eea\nV and V' are continuous, while V'' is the first discontinuous\nderivative.\nThe number of points per nanometer is 500 and 2000\nfor mixed- and double-precision versions of {\\gromacs}, respectively.\nThis means that the errors in the potential and force will usually\nbe smaller than the mixed precision accuracy.\n\n{\\gromacs} stores $A_0$, $A_1$, $A_2$ and $A_3$.\nThe force routines get a table with these four parameters and\na scaling factor $s$ that is equal to the number of points per nm.\n({\\bf Note} that $h$ is $s^{-1}$).\nThe algorithm goes a little something like this:\n\\begin{enumerate}\n\\item\tCalculate distance vector (\\ve{r}$_{ij}$) and distance r$_{ij}$\n\\item\tMultiply r$_{ij}$ by $s$ and truncate to an integer value $n_0$\n\tto get a table index\n\\item\tCalculate fractional component ($\\epsilon$ = $s$r$_{ij} - n_0$) \n\tand $\\epsilon^2$ \n\\item\tDo the interpolation to calculate the potential $V$ and the scalar force $f$\n\\item\tCalculate the vector force \\ve{F} by multiplying $f$ with \\ve{r}$_{ij}$\n\\end{enumerate}\n\n{\\bf Note} that table look-up is significantly {\\em\nslower} than computation of the most simple Lennard-Jones and Coulomb\ninteraction. However, it is much faster than the shifted Coulomb\nfunction used in conjunction with the PPPM method. Finally, it is much\neasier to modify a table for the potential (and get a graphical\nrepresentation of it) than to modify the inner loops of the MD\nprogram.\n\n\\subsection{User-specified potential functions}\n\\label{subsec:userpot}\nYou can also use your own potential functions\\index{potential function} without \nediting the {\\gromacs} code.  The potential function should be according to the \nfollowing equation\n\\beq\nV(r_{ij}) ~=~ \\frac{q_i q_j}{4 \\pi\\epsilon_0} f(r_{ij}) + C_6 \\,g(r_{ij}) + C_{12} \\,h(r_{ij})\n\\eeq\nwhere $f$, $g$, and $h$ are user defined functions. {\\bf Note} that if $g(r)$ represents a\nnormal dispersion interaction, $g(r)$ should be $<$ 0. C$_6$, C$_{12}$\nand the charges are read from the topology. Also note that combination\nrules are only supported for Lennard-Jones and Buckingham, and that\nyour tables should match the parameters in the binary topology.\n\nWhen you add the following lines in your {\\tt .mdp} file:\n\n{\\small\n\\begin{verbatim}\nrlist           = 1.0\ncoulombtype     = User\nrcoulomb        = 1.0\nvdwtype         = User\nrvdw            = 1.0\n\\end{verbatim}}\n\n{\\tt mdrun} will read a single non-bonded table file,\nor multiple when {\\tt energygrp-table} is set (see below).\nThe name of the file(s) can be set with the {\\tt mdrun} option {\\tt -table}.\nThe table file should contain seven columns of table look-up data in the\norder: $x$, $f(x)$, $-f'(x)$, $g(x)$, $-g'(x)$, $h(x)$, $-h'(x)$.\nThe $x$ should run from 0 to $r_c+1$ (the value of {\\tt table_extension} can be\nchanged in the {\\tt .mdp} file).\nYou can choose the spacing you like; for the standard tables {\\gromacs}\nuses a spacing of 0.002 and 0.0005 nm when you run in mixed\nand double precision, respectively.  In this\ncontext, $r_c$ denotes the maximum of the two cut-offs {\\tt rvdw} and\n{\\tt rcoulomb} (see above). These variables need not be the same (and\nneed not be 1.0 either).  Some functions used for potentials contain a\nsingularity at $x = 0$, but since atoms are normally not closer to each\nother than 0.1 nm, the function value at $x = 0$ is not important.\nFinally, it is also\npossible to combine a standard Coulomb with a modified LJ potential\n(or vice versa). One then specifies {\\eg} {\\tt coulombtype = Cut-off} or\n{\\tt coulombtype = PME}, combined with {\\tt vdwtype = User}.  The table file must\nalways contain the 7 columns however, and meaningful data (i.e. not\nzeroes) must be entered in all columns.  A number of pre-built table\nfiles can be found in the {\\tt GMXLIB} directory for 6-8, 6-9, 6-10, 6-11, and 6-12\nLennard-Jones potentials combined with a normal Coulomb.\n\nIf you want to have different functional forms between different\ngroups of atoms, this can be set through energy groups.\nDifferent tables can be used for non-bonded interactions between\ndifferent energy groups pairs through the {\\tt .mdp} option {\\tt energygrp-table}\n(see details in the User Guide).\nAtoms that should interact with a different potential should\nbe put into different energy groups.\nBetween group pairs which are not listed in {\\tt energygrp-table},\nthe normal user tables will be used. This makes it easy to use\na different functional form between a few types of atoms.\n\n\\section{Mixed Quantum-Classical simulation techniques}\n\nIn a molecular mechanics (MM) force field, the influence of electrons\nis expressed by empirical parameters that are assigned on the basis of\nexperimental data, or on the basis of results from high-level quantum\nchemistry calculations. These are valid for the ground state of a\ngiven covalent structure, and the MM approximation is usually\nsufficiently accurate for ground-state processes in which the overall\nconnectivity between the atoms in the system remains\nunchanged. However, for processes in which the connectivity does\nchange, such as chemical reactions, or processes that involve multiple\nelectronic states, such as photochemical conversions, electrons can no\nlonger be ignored, and a quantum mechanical description is required\nfor at least those parts of the system in which the reaction takes\nplace.\n\nOne approach to the simulation of chemical reactions in solution, or\nin enzymes, is to use a combination of quantum mechanics (QM) and\nmolecular mechanics (MM). The reacting parts of the system are treated\nquantum mechanically, with the remainder being modeled using the\nforce field. The current version of {\\gromacs} provides interfaces to\nseveral popular Quantum Chemistry packages (MOPAC~\\cite{mopac},\nGAMESS-UK~\\cite{gamess-uk}, Gaussian~\\cite{g03} and CPMD~\\cite{Car85a}).\n\n{\\gromacs} interactions between the two subsystems are\neither handled as described by Field {\\em et al.}~\\cite{Field90a} or\nwithin the ONIOM approach by Morokuma and coworkers~\\cite{Maseras96a,\nSvensson96a}.\n\n\\subsection{Overview}\n\nTwo approaches for describing the interactions between the QM and MM\nsubsystems are supported in this version:\n\n\\begin{enumerate}\n\\item{\\textbf{Electronic Embedding}} The electrostatic interactions\nbetween the electrons of the QM region and the MM atoms and between\nthe QM nuclei and the MM atoms are included in the Hamiltonian for\nthe QM subsystem: \\beq H^{QM/MM} =\nH^{QM}_e-\\sum_i^n\\sum_J^M\\frac{e^2Q_J}{4\\pi\\epsilon_0r_{iJ}}+\\sum_A^N\\sum_J^M\\frac{e^2Z_AQ_J}{e\\pi\\epsilon_0R_{AJ}},\n\\eeq where $n$ and $N$ are the number of electrons and nuclei in the\nQM region, respectively, and $M$ is the number of charged MM\natoms. The first term on the right hand side is the original\nelectronic Hamiltonian of an isolated QM system. The first of the\ndouble sums is the total electrostatic interaction between the QM\nelectrons and the MM atoms. The total electrostatic interaction of the\nQM nuclei with the MM atoms is given by the second double sum. Bonded\ninteractions between QM and MM atoms are described at the MM level by\nthe appropriate force-field terms. Chemical bonds that connect the two\nsubsystems are capped by a hydrogen atom to complete the valence of\nthe QM region. The force on this atom, which is present in the QM\nregion only, is distributed over the two atoms of the bond. The cap\natom is usually referred to as a link atom.\n\n\\item{\\textbf{ONIOM}} In the ONIOM approach, the energy and gradients\nare first evaluated for the isolated QM subsystem at the desired level\nof {\\it{ab initio}} theory. Subsequently, the energy and gradients of\nthe total system, including the QM region, are computed using the\nmolecular mechanics force field and added to the energy and gradients\ncalculated for the isolated QM subsystem. Finally, in order to correct\nfor counting the interactions inside the QM region twice, a molecular\nmechanics calculation is performed on the isolated QM subsystem and\nthe energy and gradients are subtracted. This leads to the following\nexpression for the total QM/MM energy (and gradients likewise): \\beq\nE_{tot} = E_{I}^{QM}\n+E_{I+II}^{MM}-E_{I}^{MM}, \\eeq where the\nsubscripts I and II refer to the QM and MM subsystems,\nrespectively. The superscripts indicate at what level of theory the\nenergies are computed. The ONIOM scheme has the\nadvantage that it is not restricted to a two-layer QM/MM description,\nbut can easily handle more than two layers, with each layer described\nat a different level of theory.\n\\end{enumerate}\n\n\\subsection{Usage}\n\nTo make use of the QM/MM functionality in {\\gromacs}, one needs to:\n\n\\begin{enumerate}\n\\item introduce link atoms at the QM/MM boundary, if needed;\n\\item specify which atoms are to be treated at a QM level;\n\\item specify the QM level, basis set, type of QM/MM interface and so on. \n\\end{enumerate}\n\n\\subsubsection{Adding link atoms}\n\nAt the bond that connects the QM and MM subsystems, a link atoms is\nintroduced.  In {\\gromacs} the link atom has special atomtype, called\nLA. This atomtype is treated as a hydrogen atom in the QM calculation,\nand as a virtual site in the force-field calculation. The link atoms, if\nany, are part of the system, but have no interaction with any other\natom, except that the QM force working on it is distributed over the\ntwo atoms of the bond. In the topology, the link atom (LA), therefore,\nis defined as a virtual site atom:\n\n{\\small\n\\begin{verbatim}\n[ virtual_sites2 ]\nLA QMatom MMatom 1 0.65\n\\end{verbatim}}\n\nSee~\\secref{vsitetop} for more details on how virtual sites are\ntreated. The link atom is replaced at every step of the simulation.\n\nIn addition, the bond itself is replaced by a constraint:\n\n{\\small\n\\begin{verbatim}\n[ constraints ]\nQMatom MMatom 2 0.153\n\\end{verbatim}}\n\n{\\bf Note} that, because in our system the QM/MM bond is a carbon-carbon\nbond (0.153 nm), we use a constraint length of 0.153 nm, and dummy\nposition of 0.65. The latter is the ratio between the ideal C-H\nbond length and the ideal C-C bond length. With this ratio, the link\natom is always 0.1 nm away from the {\\tt QMatom}, consistent with the\ncarbon-hydrogen bond length. If the QM and MM subsystems are connected\nby a different kind of bond, a different constraint and a different\ndummy position, appropriate for that bond type, are required.\n\n\\subsubsection{Specifying the QM atoms}\n\nAtoms that should be treated at a QM level of theory, including the\nlink atoms, are added to the index file. In addition, the chemical\nbonds between the atoms in the QM region are to be defined as\nconnect bonds (bond type 5) in the topology file:\n\n{\\small\n\\begin{verbatim}\n[ bonds ]\nQMatom1 QMatom2 5\nQMatom2 QMatom3 5\n\\end{verbatim}}\n\n\\subsubsection{Specifying the QM/MM simulation parameters}\n\nIn the {\\tt .mdp} file, the following parameters control a QM/MM simulation.\n\n\\begin{description}\n\n\\item[\\tt QMMM = no]\\mbox{}\\\\ If this is set to {\\tt yes}, a QM/MM\nsimulation is requested. Several groups of atoms can be described at\ndifferent QM levels separately. These are specified in the QMMM-grps\nfield separated by spaces. The level of {\\it{ab initio}} theory at which the\ngroups are described is specified by {\\tt QMmethod} and {\\tt QMbasis}\nFields. Describing the groups at different levels of theory is only\npossible with the ONIOM QM/MM scheme, specified by {\\tt QMMMscheme}.\n\n\\item[\\tt QMMM-grps =]\\mbox{}\\\\groups to be described at the QM level\n\n\\item[\\tt QMMMscheme = normal]\\mbox{}\\\\Options are {\\tt normal} and\n{\\tt ONIOM}. This selects the QM/MM interface. {\\tt normal} implies\nthat the QM subsystem is electronically embedded in the MM\nsubsystem. There can only be one {\\tt QMMM-grps} that is modeled at\nthe {\\tt QMmethod} and {\\tt QMbasis} level of {\\it{ ab initio}}\ntheory. The rest of the system is described at the MM level. The QM\nand MM subsystems interact as follows: MM point charges are included\nin the QM one-electron Hamiltonian and all Lennard-Jones interactions\nare described at the MM level. If {\\tt ONIOM} is selected, the\ninteraction between the subsystem is described using the ONIOM method\nby Morokuma and co-workers. There can be more than one QMMM-grps each\nmodeled at a different level of QM theory (QMmethod and QMbasis).\n\n\\item[\\tt QMmethod = ]\\mbox{}\\\\Method used to compute the energy\nand gradients on the QM atoms. Available methods are AM1, PM3, RHF,\nUHF, DFT, B3LYP, MP2, CASSCF, MMVB and CPMD. For CASSCF, the number of\nelectrons and orbitals included in the active space is specified by\n{\\tt CASelectrons} and {\\tt CASorbitals}. For CPMD, the plane-wave\ncut-off is specified by the {\\tt planewavecutoff} keyword.\n\n\\item[\\tt QMbasis = ]\\mbox{}\\\\Gaussian basis set used to expand the\nelectronic wave-function. Only Gaussian basis sets are currently\navailable, i.e. STO-3G, 3-21G, 3-21G*, 3-21+G*, 6-21G, 6-31G, 6-31G*,\n6-31+G*, and 6-311G. For CPMD, which uses plane wave expansion rather\nthan atom-centered basis functions, the {\\tt planewavecutoff} keyword\ncontrols the plane wave expansion.\n\n\\item[\\tt QMcharge = ]\\mbox{}\\\\The total charge in {\\it{e}} of the {\\tt\nQMMM-grps}. In case there are more than one {\\tt QMMM-grps}, the total\ncharge of each ONIOM layer needs to be specified separately.\n\n\\item[\\tt QMmult = ]\\mbox{}\\\\The multiplicity of the {\\tt\nQMMM-grps}. In case there are more than one {\\tt QMMM-grps}, the\nmultiplicity of each ONIOM layer needs to be specified separately.\n\n\\item[\\tt CASorbitals = ]\\mbox{}\\\\The number of orbitals to be\nincluded in the active space when doing a CASSCF computation.\n\n\\item[\\tt CASelectrons = ]\\mbox{}\\\\The number of electrons to be\nincluded in the active space when doing a CASSCF computation.\n\n\\item[\\tt SH = no]\\mbox{}\\\\If this is set to yes, a QM/MM MD\nsimulation on the excited state-potential energy surface and enforce a\ndiabatic hop to the ground-state when the system hits the conical\nintersection hyperline in the course the simulation. This option only\nworks in combination with the CASSCF method.\n\n\\end{description}\n\n\\subsection{Output}\n\nThe energies and gradients computed in the QM calculation are added to\nthose computed by {\\gromacs}. In the {\\tt .edr} file there is a section\nfor the total QM energy.\n\n\\subsection{Future developments}\n\nSeveral features are currently under development to increase the\naccuracy of the QM/MM interface. One useful feature is the use of\ndelocalized MM charges in the QM computations. The most important\nbenefit of using such smeared-out charges is that the Coulombic\npotential has a finite value at interatomic distances. In the point\ncharge representation, the partially-charged MM atoms close to the QM\nregion tend to ``over-polarize'' the QM system, which leads to artifacts\nin the calculation.\n\nWhat is needed as well is a transition state optimizer.\n\n\\section{\\normindex{Adaptive Resolution Scheme}}\n\\newcommand{\\adress}{AdResS}\nThe adaptive resolution scheme~\\cite{Praprotnik2005,Praprotnik2008} (\\seeindex{\\adress}{Adaptive Resolution Scheme}) couples two systems with different resolutions by a force interpolation scheme.\nIn contrast to the mixed Quantum-Classical simulation techniques of the previous section, the number of high resolution particles is not fixed, but can vary over the simulation time.\n\nBelow we discuss {\\adress} for a double resolution (atomistic and coarse grained) representation of the same system. See \\figref{adress} for illustration.\nThe details of implementation described in this section were published in~\\cite{Junghans2010,Fritsch2012}.\n\n\\begin{figure}\n\\begin{center}\n\\includegraphics[width=0.5\\textwidth]{plots/adress}\n\\caption{A schematic illustration of the {\\adress} method for water.} \n\\label{fig:adress}\n\\end{center}\n\\end{figure}\nEvery molecule needs a well-defined mapping point (usually the center of mass)\nbut any other linear combination of particle coordinates is also sufficient. \nIn the topology the mapping point is defined by a virtual site. The forces in the coarse-grained region are functions of the mapping point positions only.\nIn this implementation molecules are modeled by charge groups or sets of charge groups, which actually allows one to have multiple mapping points per molecule. This can be useful for bigger molecules like polymers. In that case one has to also extend the AdResS description to bonded interactions~\\cite{Praprotnik2011}, which will be implemented into \\gromacs in one of the future versions.\n\nThe force between two molecules is given by~\\cite{Praprotnik2005}\n\\footnote{Note that the equation obeys Newton's third law, which is not the case for other interpolation schemes~\\cite{DelleSite2007}.}:\n\\begin{equation}\n\\vec{F}_{\\alpha\\beta}=w_\\alpha w_\\beta \\vec{F}^\\mathrm{ex,mol}_{\\alpha\\beta} + \\left[1-w_\\alpha w_\\beta\\right] \\vec{F}^\\mathrm{cg,mol}_{\\alpha\\beta}~,\n\\label{eqn:interpolation}\n\\end{equation}\nwhere $\\alpha$ and $\\beta$ label the two molecules and $w_\\alpha$, $w_\\beta$ are the adaptive weights of the two molecules.\n\nThe first part, which represents the explicit interaction of the molecules, can be written as:\n\\begin{equation}\n\\vec{F}^\\mathrm{ex,mol}_{\\alpha\\beta}=\\sum_{i\\in\\alpha}\\sum_{j\\in\\beta} \\vec{F}^\\mathrm{ex}_{ij}~,\n\\end{equation}\nwhere $\\vec{F}^\\mathrm{ex}_{ij}$ is the force between the $i$th atom  in  $\\alpha$th molecule and the $j$th atom in the $\\beta$th molecule, which is given by an explicit force field.\nThe second part of \\eqnref{interpolation} comes from the coarse-grained interaction of the molecules.\nIn \\gromacs a slightly extended case is implemented:\n\\begin{equation}\n  \\vec{F}_{\\alpha\\beta}=\\sum_{i\\in\\alpha}\\sum_{j\\in\\beta} w_i w_j \\vec{F}^\\mathrm{ex}_{ij} + \\left[1-w_\\alpha w_\\beta\\right] \\vec{F}^\\mathrm{cg,mol}_{\\alpha\\beta}~,\n\\label{eqn:interpolation2}\n\\end{equation}\nwhere $w_i$ and $w_j$ are atom-wise weights, which are determined by the {\\tt adress-site} option. For {\\tt adress-site} being the center of mass, atom $i$ has the weight of the center of mass of its \\emph{charge group}.\nThe weight $w_\\alpha$ of molecule $\\alpha$ is determined by the position of coarse-grained particle, which is constructed as a virtual site from the atomistic particles as specified in the topology.\nThis extension allows one to perform all kind of AdResS variations, but the common case can be recovered by using a center of mass virtual site in the topology, {\\tt adress-site=COM} and putting all atoms (except the virtual site representing the coarse-grained interaction) of a molecule into one charge group.\nFor big molecules, it is sometimes useful to use an atom-based weight, which can be either be achieved by setting {\\tt adress-site=atomperatom} or putting every atom into a separate charge group (the center of mass of a charge group with one atom is the atom itself).\n\nThe coarse-grained force field $\\vec{F}^\\mathrm{cg}$ is usually derived from the atomistic system by structure-based coarse-graining (see \\secref{cg-forcefields}). To specify which atoms belong to a coarse-grained representation, energy groups are used.\nEach coarse-grained interaction has to be associated with a specific energy group, which is why the virtual sites representing the coarse-grained interactions also have to be in different charge groups. The energy groups which are treated as coarse-grained interactions are then listed in {\\tt adress_cg_grp_names}.\nThe most important element of this interpolation (see \\eqnref{interpolation} and \\eqnref{interpolation2}) is the adaptive weighting function (for illustration see \\figref{adress}):\n\\begin{equation}\nw(x)=\n\\left\\{\\begin{array}{c@{\\;:\\;}l}\n1&\\mathrm{atomistic/explicit\\;region}\\\\\n0<w<1&\\mathrm{hybrid\\;region}\\\\\n0&\\mathrm{coarse-grained\\;region}\n\\end{array}\\right.~,\n\\label{equ:weighting}\n\\end{equation}\nwhich has a value between 0 and 1.\nThis definition of $w$ gives a purely explicit force in the explicit region and a purely coarse-grained force in the coarse-grained region,\nso essentially \\eqnref{interpolation} only the hybrid region has mixed interactions which would not appear in a standard simulation.\nIn {\\gromacs}, a $\\cos^2$-like function is implemented as a weighting function:\n\\begin{equation}\nw(x)=\n\\left\\{\\begin{array}{c@{\\;:\\;}r@{x}l}\n0&&>d_\\mathrm{ex}+d_\\mathrm{hy}\\\\\n\\cos^2\\left(\\frac{\\pi}{2d_\\mathrm{hy}}(x-d_\\mathrm{ex})\\right)&d_\\mathrm{ex}+d_\\mathrm{hy}>&>d_\\mathrm{ex}\\\\\n1&d_\\mathrm{ex}>&\n\\end{array}\\right.~,\n\\label{equ:wf}\n\\end{equation}\nwhere $d_\\mathrm{ex}$ and $d_\\mathrm{hy}$ are the sizes of the explicit and the hybrid region, respectively.\nDepending on the physical interest of the research, other functions could be implemented as long as the following boundary conditions are fulfilled:\nThe function is 1) continuous, 2) monotonic and 3) has zero derivatives at the boundaries.\nSpherical and one-dimensional splitting  of the simulation box has been implemented ({\\tt adress-type} option)\nand depending on this, the distance $x$ to the center of the explicit region is calculated as follows:\n\\begin{equation}\nx=\n\\left\\{\n\\begin{array}{c@{\\;:\\;}l}\n  |(\\vec{R}_\\alpha-\\vec{R}_\\mathrm{ct})\\cdot\\hat{e}|&\\mathrm{splitting\\;in\\;}\\hat{e}\\mathrm{\\;direction}\\\\\n|\\vec{R}_\\alpha-\\vec{R}_\\mathrm{ct}|&\\mathrm{spherical\\;splitting}\n\\end{array}\n\\right.~,\n\\end{equation}\nwhere $\\vec{R}_\\mathrm{ct}$ is the center of the explicit zone (defined by {\\tt adress-reference-coords} option). $\\vec{R}_\\alpha$ is the mapping point of the $\\alpha$th molecule. For the center of mass mapping, it is given by:\n\\begin{equation}\nR_\\alpha=\\frac{\\sum_{i\\in\\alpha}m_i r_i}{\\sum_{i\\in\\alpha}m_i}\n\\label{equ:com-def}\n\\end{equation}\nNote that the value of the weighting function depends exclusively on the mapping of the molecule.\n\nThe interpolation of forces (see \\eqnref{interpolation2}) can produce inhomogeneities in the density and affect the structure of the system in the hybrid region.\n\nOne way of reducing the density inhomogeneities is by the application of the so-called thermodynamic force (TF)~\\cite{Poblete2010}.\nSuch a force consists of a space-dependent external field applied in the hybrid region on the coarse-grained site of each molecule. It can be specified for each of the species of the system.\nThe TF compensates the pressure profile~\\cite{Fritsch2012b} that emerges under a homogeneous density profile. Therefore, it can correct the local density inhomogeneities in the hybrid region and it also allows the coupling of atomistic and coarse-grained representations which by construction have different pressures at the target density.\nThe field can be determined by an iterative procedure, which is described in detail in the \\href{http://code.google.com/p/votca/downloads/list?&q=manual}{manual} of the \\normindex{VOTCA package}~\\cite{ruehle2009}. Setting the {\\tt adress-interface-correction} to {\\tt thermoforce} enables the TF correction and\\newline{\\tt adress-tf-grp-names} defines the energy groups to act on.\n\n\\subsection{Example: Adaptive resolution simulation of water}\\label{subsec:adressexample}\nIn this section the set up of  an adaptive resolution simulation coupling atomistic SPC ~\\cite{Berendsen81} water to its coarse-grained representation will be explained (as used in \\cite{Fritsch2012b}).\nThe following steps are required to setup the simulation:\n\\begin{itemize}\n\\item Perform a reference all-atom simulation\n\\item Create a coarse-grained representation and save it as tabulated interaction function \n\\item Create a hybrid topology for the SPC water\n\\item Modify the atomistic coordinate file to include the coarse grained representation\n\\item Define the geometry of the adaptive simulation in the grompp input file\n\\item Create an index file\n\\end{itemize}\nThe coarse-grained representation of the interaction is stored as tabulated interaction function see \\ssecref{userpot}. The convention is to use the $C^{(12)}$  columns with the  $C^{(12)}$- coefficient set to 1. All other columns should be zero. The VOTCA manual has detailed instructions and a tutorial for SPC water on how to coarse-grain the interaction using various techniques.\nHere we named the coarse grained interaction CG, so the corresponding tabulated file is {\\tt table_CG_CG.xvg}. To create the topology one can start from the atomistic topology file (e.g. share/gromacs/top/oplsaa.ff/spc.itp), we are assuming rigid water here. In the VOTCA tutorial the file is named {\\tt hybrid_spc.itp}.\nThe only difference to the atomistic topology is the addition of a coarse-grained virtual site:\n{\\small\n\\begin{verbatim}\n[ moleculetype ]\n; molname       nrexcl\nSOL             2\n\n[ atoms ]\n;   nr   type  resnr residue  atom   cgnr     charge       mass\n     1  opls_116   1    SOL     OW      1      -0.82\n     2  opls_117   1    SOL    HW1      1       0.41\n     3  opls_117   1    SOL    HW2      1       0.41\n     4     CG      1    SOL     CG      2       0\n\n\n[ settles ]\n; OW    funct   doh     dhh\n1       1       0.1     0.16330\n\n[ exclusions ]\n1       2       3\n2       1       3\n3       1       2\n\n[ virtual_sites3 ]\n; Site from funct a d\n4 1 2 3 1 0.05595E+00 0.05595E+00\n\\end{verbatim}}\nThe virtual site type 3 with the specified coefficients places the virtual site in the center of mass of the molecule (for larger molecules virtual_sitesn has to be used).\nWe now need to include our modified water model in the topology file and define the type {\\tt CG}. In {\\tt topol.top}:\n{\\small\n\\begin{verbatim}\n#include \"ffoplsaa.itp\"\n\n[ atomtypes ]\n;name  mass        charge    ptype   sigma     epsilon\n CG    0.00000     0.0000    V       1    0.25\n\n#include \"hybrid_spc.itp\"\n\n[ system ]\nAdaptive water\n[ molecules ]\nSOL    8507\n\\end{verbatim}}\nThe $\\sigma$ and $\\epsilon$ values correspond to $C_6=1$ and $C_{12}=1$ and thus the table file should contain the coarse-grained interaction in either the $C_6$ or $C_{12}$ column. In the example the OPLS force field is used where $\\sigma$ and $\\epsilon$ are specified.\nNote that for force fields which define atomtypes directly in terms of $C_6$ and $C_{12}$, one can simply set $C_6=0$ and $C_{12}=1$. See section \\ssecref{userpot} for more details on tabulated interactions. Since now the water molecule has a virtual site the coordinate file also needs to include that.\n{\\small\n\\begin{verbatim}\nadaptive water coordinates\n34028\n    1SOL     OW    1   0.283   0.886   0.647\n    1SOL    HW1    2   0.359   0.884   0.711\n    1SOL    HW2    3   0.308   0.938   0.566\n    1SOL     CG    4   0.289   0.889   0.646\n    1SOL     OW    5   1.848   0.918   0.082\n    1SOL    HW1    6   1.760   0.930   0.129\n    1SOL    HW2    7   1.921   0.912   0.150\n    1SOL     CG    8   1.847   0.918   0.088\n    (...)\n\\end{verbatim}}\nThis file can be created manually or using the VOTCA tool {\\tt csg_map } with the {\\tt --hybrid} option.\\\\\nIn the grompp input file the AdResS feature needs to be enabled and the geometry defined.\n{\\small\n\\begin{verbatim}\n(...)\n; AdResS relevant options\nenergygrps               = CG\nenergygrp_table          = CG CG\n\n; Method for doing Van der Waals\nvdw-type                 = user\n\nadress                  = yes\nadress_type             = xsplit\nadress_ex_width         = 1.5\nadress_hy_width         = 1.5\nadress_interface_correction = off\nadress_reference_coords = 8 0 0\nadress_cg_grp_names = CG\n\\end{verbatim}}\n\nHere we are defining an energy group {\\tt CG} which consists of the coarse-grained virtual site.\nAs discussed above, the coarse-grained interaction is usually tabulated. This requires the {\\tt vdw-type} parameter to be set to {\\tt user}. In the case where multi-component systems are coarse-grained, an energy group has to be defined for each component. Note that all the energy groups defining coarse-grained representations have to be listed again in {\\tt adress_cg_grp_names} to distinguish them from regular energy groups.\\\\\nThe index file has to be updated to have a group CG which includes all the coarse-grained virtual sites. This can be done easily using the {\\tt make_ndx} tool of gromacs.\n\n\\section{Using VMD plug-ins for trajectory file I/O}\n\\index{VMD plug-ins}\\index{trajectory file}{\\gromacs} tools are able\nto use the plug-ins found in an existing installation of\n\\href{http://www.ks.uiuc.edu/Research/vmd}{VMD} in order to read and\nwrite trajectory files in formats that are not native to\n{\\gromacs}. You will be able to supply an AMBER DCD-format trajectory\nfilename directly to {\\gromacs} tools, for example.\n\nThis requires a VMD installation not older than version 1.8, that your\nsystem provides the dlopen function so that programs can determine at\nrun time what plug-ins exist, and that you build shared libraries when\nbuilding {\\gromacs}. CMake will find the vmd executable in your path, and\nfrom it, or the environment variable {\\tt VMDDIR} at configuration or\nrun time, locate the plug-ins. Alternatively, the {\\tt VMD_PLUGIN_PATH}\ncan be used at run time to specify a path where these plug-ins can be\nfound. Note that these plug-ins are in a binary format, and that format\nmust match the architecture of the machine attempting to use them.\n\n\n\\section{\\normindex{Interactive Molecular Dynamics}}\n{\\gromacs} supports the interactive molecular dynamics (IMD) protocol as implemented\nby \\href{http://www.ks.uiuc.edu/Research/vmd}{VMD} to control a running simulation\nin NAMD. IMD allows to monitor a running {\\gromacs} simulation from a VMD client.\nIn addition, the user can interact with the simulation by pulling on atoms, residues\nor fragments with a mouse or a force-feedback device. Additional information about\nthe {\\gromacs} implementation and an exemplary {\\gromacs} IMD system can be found\n\\href{http://www.mpibpc.mpg.de/grubmueller/interactivemd}{on this homepage}.\n\n\\subsection{Simulation input preparation}\nThe {\\gromacs} implementation allows transmission and interaction with a part of the\nrunning simulation only, e.g.\\ in cases where no water molecules should be transmitted\nor pulled. The group is specified via the {\\tt .mdp} option {\\tt IMD-group}. When\n{\\tt IMD-group} is empty, the IMD protocol is disabled and cannot be enabled via the\nswitches in {\\tt mdrun}. To interact with the entire system, {\\tt IMD-group} can\nbe set to {\\tt System}. When using {\\tt grompp}, a {\\tt .gro} file\nto be used as VMD input is written out ({\\tt -imd} switch of {\\tt grompp}).\n\n\\subsection{Starting the simulation}\nCommunication between VMD and {\\gromacs} is achieved via TCP sockets and thus enables\ncontrolling an {\\tt mdrun} running locally or on a remote cluster. The port for the\nconnection can be specified with the {\\tt -imdport} switch of {\\tt mdrun}, 8888 is\nthe default. If a port number of 0 or smaller is provided, {\\gromacs} automatically\nassigns a free port to use with IMD.\n\nEvery $N$ steps, the {\\tt mdrun} client receives the applied forces from VMD and sends the new\npositions to the client. VMD permits increasing or decreasing the communication frequency\ninteractively.\nBy default, the simulation starts and runs even if no IMD client is connected. This\nbehavior is changed by the {\\tt -imdwait} switch of {\\tt mdrun}. After startup and\nwhenever the client has disconnected, the integration stops until reconnection of\nthe client.\nWhen the {\\tt -imdterm} switch is used, the simulation can be terminated by pressing\nthe stop button in VMD. This is disabled by default.\nFinally, to allow interacting with the simulation (i.e. pulling from VMD) the {\\tt -imdpull}\nswitch has to be used.\nTherefore, a simulation can only be monitored but not influenced from the VMD client\nwhen none of {\\tt -imdwait}, {\\tt -imdterm} or {\\tt -imdpull} are set. However, since\nthe IMD protocol requires no authentication, it is not advisable to run simulations on\na host directly reachable from an insecure environment. Secure shell forwarding of TCP\ncan be used to connect to running simulations not directly reachable from the interacting host.\nNote that the IMD command line switches of {\\tt mdrun} are hidden by default and show\nup in the help text only with {\\tt gmx mdrun -h -hidden}.\n\n\\subsection{Connecting from VMD}\nIn VMD, first the structure corresponding to the IMD group has to be loaded ({\\it File\n$\\rightarrow$ New Molecule}). Then the IMD connection window has to be used\n({\\it Extensions $\\rightarrow$ Simulation $\\rightarrow$ IMD Connect (NAMD)}). In the IMD\nconnection window, hostname and port have to be specified and followed by pressing\n{\\it Connect}. {\\it Detach Sim} allows disconnecting without terminating the simulation, while\n{\\it Stop Sim} ends the simulation on the next neighbor searching step (if allowed by\n{\\tt -imdterm}).\n\nThe timestep transfer rate allows adjusting the communication frequency between simulation\nand IMD client. Setting the keep rate loads every $N^\\mathrm{th}$ frame into VMD instead\nof discarding them when a new one is received. The displayed energies are in SI units\nin contrast to energies displayed from NAMD simulations.\n\n\n% LocalWords:  PMF pmf kJ mol Jarzynski BT bilayer rup mdp AFM fepmf fecalc rb\n% LocalWords:  posre grompp fs Verlet dihedrals hydrogens hydroxyl sulfhydryl\n% LocalWords:  vsitehydro planarity chirality pdb gmx virtualize virtualized xz\n% LocalWords:  vis massless tryptophan histidine phenyl parameterizing ij PPPM\n% LocalWords:  parameterization Berendsen rlist coulombtype rcoulomb vdwtype LJ\n% LocalWords:  rvdw energygrp mdrun pre GMXLIB MOPAC GAMESS CPMD ONIOM\n% LocalWords:  Morokuma iJ AQ AJ initio atomtype QMatom MMatom QMMM grps et al\n% LocalWords:  QMmethod QMbasis QMMMscheme RHF DFT LYP CASSCF MMVB CASelectrons\n% LocalWords:  CASorbitals planewavecutoff STO QMcharge QMmult diabatic edr\n% LocalWords:  hyperline delocalized Coulombic indices nm ccc th ps\n% LocalWords:  GTX CPUs GHz md sd bd vv avek tcoupl andersen tc OPLSAA GROMOS\n% LocalWords:  OBC obc CCMA tol pbc xyz barostat pcoupl acc gpu PLUGIN Cmake GX\n% LocalWords:  MSVC gcc installpath cmake DGMX DCMAKE functionalities GPGPU GTS\n% LocalWords:  OpenCL DeviceID gromacs gpus html GeForce Quadro FX Plex CX GF\n% LocalWords:  VMD DCD GROningen MAchine BIOSON Groningen der Spoel Drunen Comp\n% LocalWords:  Phys Comm moltype intramol vdw Waals fep multivector pf\n% LocalWords:  pymbar dhdl xvg LINCS Entropic entropic solutes ref com iso pm\n% LocalWords:  rm prefactors equipotential potiso potisopf potpm trr\n% LocalWords:  potrm potrmpf midplanes midplane gaussians potflex vars massw av\n% LocalWords:  shure observables rccccccc vec eps dist min eqn transl nstsout\n% LocalWords:  nstrout rotangles rotslabs rottorque RMSD rmsdfit excl NH amine\n% LocalWords:  positionrestraint es SH phenylalanine solvated sh nanometer QM\n% LocalWords:  Lennard Buckingham UK Svensson ab vsitetop co UHF MP interatomic\n% LocalWords:  AdResS adress cg grp coords TF VOTCA thermoforce tf SPC userpot\n% LocalWords:  itp sitesn atomtypes ff csg ndx Tesla CHARMM AA gauss\n% LocalWords:  CMAP nocmap fators Monte performant lib LD DIR llllcc\n% LocalWords:  CMake homepage DEV overclocking GT dlopen vmd VMDDIR\n% LocalWords:  versa PME atomperatom graining forcefields hy spc OPLS\n% LocalWords:  topol multi\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-gromacs-5.1.2-tz5blkl5h4hbtzrte7ypqrgwjwhftnur/spack-src/src/external/tng_io/example_files/tng_example.tng",
        "/tmp/vanessa/spack-stage/spack-stage-gromacs-5.1.2-tz5blkl5h4hbtzrte7ypqrgwjwhftnur/spack-src/src/external/boost/boost/smart_ptr/detail/atomic_count_gcc.hpp",
        "/tmp/vanessa/spack-stage/spack-stage-gromacs-5.1.2-tz5blkl5h4hbtzrte7ypqrgwjwhftnur/spack-src/src/programs/mdrun/tests/spc2.trr",
        "/tmp/vanessa/spack-stage/spack-stage-gromacs-5.1.2-tz5blkl5h4hbtzrte7ypqrgwjwhftnur/spack-src/src/gromacs/fileio/tests/spc2-traj.tng",
        "/tmp/vanessa/spack-stage/spack-stage-gromacs-5.1.2-tz5blkl5h4hbtzrte7ypqrgwjwhftnur/spack-src/src/gromacs/gmxana/legacytests/spc2-traj.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-gromacs-5.1.2-tz5blkl5h4hbtzrte7ypqrgwjwhftnur/spack-src/src/gromacs/gmxana/legacytests/spc2-traj.tng",
        "/tmp/vanessa/spack-stage/spack-stage-gromacs-5.1.2-tz5blkl5h4hbtzrte7ypqrgwjwhftnur/spack-src/src/gromacs/gmxana/legacytests/spc2-traj.g96",
        "/tmp/vanessa/spack-stage/spack-stage-gromacs-5.1.2-tz5blkl5h4hbtzrte7ypqrgwjwhftnur/spack-src/src/gromacs/gmxana/legacytests/spc2-traj.trr",
        "/tmp/vanessa/spack-stage/spack-stage-gromacs-5.1.2-tz5blkl5h4hbtzrte7ypqrgwjwhftnur/spack-src/src/gromacs/trajectoryanalysis/tests/freevolume.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-gromacs-5.1.2-tz5blkl5h4hbtzrte7ypqrgwjwhftnur/spack-src/src/gromacs/trajectoryanalysis/tests/freevolume.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-gromacs-5.1.2-tz5blkl5h4hbtzrte7ypqrgwjwhftnur/spack-src/docs/gmxsphinx.pyc",
        "/tmp/vanessa/spack-stage/spack-stage-gromacs-5.1.2-tz5blkl5h4hbtzrte7ypqrgwjwhftnur/spack-src/docs/manual/plots/peregrine.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gromacs-5.1.2-tz5blkl5h4hbtzrte7ypqrgwjwhftnur/spack-src/docs/manual/plots/fp-highres.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gromacs-5.1.2-tz5blkl5h4hbtzrte7ypqrgwjwhftnur/spack-src/docs/manual/plots/f-imps.eps",
        "/tmp/vanessa/spack-stage/spack-stage-gromacs-5.1.2-tz5blkl5h4hbtzrte7ypqrgwjwhftnur/spack-src/docs/manual/plots/f-bham.eps",
        "/tmp/vanessa/spack-stage/spack-stage-gromacs-5.1.2-tz5blkl5h4hbtzrte7ypqrgwjwhftnur/spack-src/docs/manual/plots/f-pr.eps",
        "/tmp/vanessa/spack-stage/spack-stage-gromacs-5.1.2-tz5blkl5h4hbtzrte7ypqrgwjwhftnur/spack-src/docs/manual/plots/f-bond.eps",
        "/tmp/vanessa/spack-stage/spack-stage-gromacs-5.1.2-tz5blkl5h4hbtzrte7ypqrgwjwhftnur/spack-src/docs/manual/plots/f-dih.eps",
        "/tmp/vanessa/spack-stage/spack-stage-gromacs-5.1.2-tz5blkl5h4hbtzrte7ypqrgwjwhftnur/spack-src/docs/manual/plots/f-lj.eps",
        "/tmp/vanessa/spack-stage/spack-stage-gromacs-5.1.2-tz5blkl5h4hbtzrte7ypqrgwjwhftnur/spack-src/docs/manual/plots/equipotential.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gromacs-5.1.2-tz5blkl5h4hbtzrte7ypqrgwjwhftnur/spack-src/docs/manual/plots/compelsetup.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gromacs-5.1.2-tz5blkl5h4hbtzrte7ypqrgwjwhftnur/spack-src/docs/manual/plots/rama.eps",
        "/tmp/vanessa/spack-stage/spack-stage-gromacs-5.1.2-tz5blkl5h4hbtzrte7ypqrgwjwhftnur/spack-src/docs/manual/plots/f-rbs.eps",
        "/tmp/vanessa/spack-stage/spack-stage-gromacs-5.1.2-tz5blkl5h4hbtzrte7ypqrgwjwhftnur/spack-src/docs/manual/plots/adress.png",
        "/tmp/vanessa/spack-stage/spack-stage-gromacs-5.1.2-tz5blkl5h4hbtzrte7ypqrgwjwhftnur/spack-src/docs/manual/plots/gaussians.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gromacs-5.1.2-tz5blkl5h4hbtzrte7ypqrgwjwhftnur/spack-src/docs/manual/plots/sgangle.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gromacs-5.1.2-tz5blkl5h4hbtzrte7ypqrgwjwhftnur/spack-src/docs/manual/plots/rotation.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gromacs-5.1.2-tz5blkl5h4hbtzrte7ypqrgwjwhftnur/spack-src/docs/user-guide/plotje.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gromacs-5.1.2-tz5blkl5h4hbtzrte7ypqrgwjwhftnur/spack-src/docs/user-guide/xvgr.gif"
    ],
    "total_files": 4523
}