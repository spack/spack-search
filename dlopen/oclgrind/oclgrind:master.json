{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-oclgrind-master-wszi2yn2gtslctfn7lono7dykvsswk65/spack-src/CMakeLists.txt": "# CMakeLists.txt (Oclgrind)\n# Copyright (c) 2013-2019, James Price and Simon McIntosh-Smith,\n# University of Bristol. All rights reserved.\n#\n# This program is provided under a three-clause BSD license. For full\n# license terms please see the LICENSE file distributed with this\n# source code.\n\ncmake_minimum_required(VERSION 3.1)\nproject(Oclgrind)\nset(Oclgrind_VERSION_MAJOR 19)\nset(Oclgrind_VERSION_MINOR 10)\n\ninclude(CheckIncludeFiles)\ninclude(CheckIncludeFileCXX)\ninclude(CheckLibraryExists)\ninclude(TestBigEndian)\n\n# Enable C99 for GCC (required for tests)\nif (CMAKE_COMPILER_IS_GNUCC)\n  set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -std=c99\")\nendif()\n\n# Require C++14 (hard requirement for LLVM >10)\nset(CMAKE_CXX_STANDARD 14)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n\n# Enable rpath on OS X\nset(CMAKE_MACOSX_RPATH 1)\n\nif (NOT \"${CMAKE_SYSTEM_NAME}\" STREQUAL \"Windows\")\n  set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -fno-rtti\")\n  set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -Wall\")\n  set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -Wno-strict-aliasing\")\nendif()\n\n# Disable min/max macros on Windows\nif (\"${CMAKE_SYSTEM_NAME}\" STREQUAL \"Windows\")\n  add_definitions(-DNOMINMAX)\nendif()\n\n# Suppress warnings from OpenCL runtime API headers\nif (\"${CMAKE_CXX_COMPILER_ID}\" STREQUAL \"Clang\")\n  set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -Wno-ignored-attributes\")\n  set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -Wno-gcc-compat\")\n  set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -Wno-availability\")\nendif()\n\n# Detect endianness\ntest_big_endian(IS_BIG_ENDIAN)\n\n\n# Find LLVM\nfind_package(LLVM REQUIRED CONFIG NO_CMAKE_BUILDS_PATH)\nmessage(STATUS \"Found LLVM ${LLVM_PACKAGE_VERSION}\")\nmessage(STATUS \"Using LLVMConfig.cmake in: ${LLVM_DIR}\")\n\n# Check LLVM version\nif (${LLVM_PACKAGE_VERSION} VERSION_LESS \"11.0\")\n  message(FATAL_ERROR \"LLVM version must be >= 11.0\")\nendif()\n\n# Add flags for LLVM\nadd_definitions(${LLVM_DEFINITIONS})\ninclude_directories(${LLVM_INCLUDE_DIRS})\nlink_directories(${LLVM_LIBRARY_DIRS})\n\n# Get LLVM libraries for linking\nlist(FIND LLVM_AVAILABLE_LIBS LLVM _LLVM_SHARED_INDEX)\nif (${_LLVM_SHARED_INDEX} GREATER -1)\n  set(LLVM_LIBS LLVM)\nelse()\n  llvm_map_components_to_libnames(LLVM_LIBS\n    bitreader bitwriter core coroutines coverage frontendopenmp instrumentation\n    ipo irreader linker lto mcparser objcarcopts option target)\nendif()\n\n# https://bugs.llvm.org/show_bug.cgi?id=44870\nlist(FIND LLVM_AVAILABLE_LIBS Polly _POLLY_INDEX)\nif (${_POLLY_INDEX} GREATER -1)\n  list(APPEND LLVM_LIBS Polly)\nendif()\n\n# Allow user to set path to Clang installation via CLANG_ROOT\nset (CLANG_ROOT \" \" CACHE PATH \"Root of Clang installation\")\nif (NOT ${CLANG_ROOT} STREQUAL \" \")\n  include_directories(\"${CLANG_ROOT}/include\")\n  link_directories(\"${CLANG_ROOT}/lib\")\n  set(CMAKE_REQUIRED_INCLUDES\n      \"${CMAKE_REQUIRED_INCLUDES};${CLANG_ROOT}/include\")\nendif()\n\nset(CMAKE_REQUIRED_INCLUDES\n    \"${CMAKE_REQUIRED_INCLUDES};${LLVM_INCLUDE_DIRS}\")\nset(CMAKE_REQUIRED_DEFINITIONS\n    \"${CMAKE_REQUIRED_DEFINITIONS};${LLVM_DEFINITIONS}\")\n\n# Check for Clang headers\nunset(CLANG_HEADER CACHE)\nfind_path(CLANG_HEADER \"clang/CodeGen/CodeGenAction.h\"\n          PATHS \"${CLANG_ROOT}/include\" \"${LLVM_INCLUDE_DIRS}\"\n          NO_DEFAULT_PATH)\nfind_path(CLANG_HEADER \"clang/CodeGen/CodeGenAction.h\")\nif (\"${CLANG_HEADER}\" STREQUAL \"CLANG_HEADER-NOTFOUND\")\n  message(FATAL_ERROR \"Clang headers not found (set CLANG_ROOT)\")\nendif()\n\n# Check for Clang libraries\nunset(CLANG_LIB CACHE)\nfind_library(CLANG_LIB \"clangFrontend\"\n             PATHS \"${CLANG_ROOT}/lib\" \"${LLVM_LIBRARY_DIRS}\"\n             NO_DEFAULT_PATH)\nfind_library(CLANG_LIB \"clangFrontend\")\nset(CLANG_LIBS\n  clangCodeGen clangFrontend clangSerialization clangDriver\n  clangParse clangSema clangAnalysis clangEdit clangAST clangASTMatchers\n  clangLex clangBasic)\n\nif (\"${CLANG_LIB}\" STREQUAL \"CLANG_LIB-NOTFOUND\")\n  # https://releases.llvm.org/10.0.0/tools/clang/docs/ReleaseNotes.html#build-system-changes\n  find_library(CLANG_LIB \"clang-cpp\"\n               PATHS \"${CLANG_ROOT}/lib\" \"${LLVM_LIBRARY_DIRS}\"\n               NO_DEFAULT_PATH)\n  find_library(CLANG_LIB \"clang-cpp\")\n  set(CLANG_LIBS \"clang-cpp\")\n\n  if (\"${CLANG_LIB}\" STREQUAL \"CLANG_LIB-NOTFOUND\")\n    message(FATAL_ERROR \"Clang libraries not found (set CLANG_ROOT)\")\n  endif()\nendif()\n\n# Get path to Clang's opencl-c.h header\nget_filename_component(CLANG_LIB_DIR \"${CLANG_LIB}\" DIRECTORY)\nset(CLANG_FULL_VERSION\n    \"${LLVM_VERSION_MAJOR}.${LLVM_VERSION_MINOR}.${LLVM_VERSION_PATCH}\")\nset(CLANG_OPENCL_C_H\n    \"${CLANG_LIB_DIR}/clang/${CLANG_FULL_VERSION}/include/opencl-c.h\")\nif (NOT EXISTS \"${CLANG_OPENCL_C_H}\")\n  message(FATAL_ERROR \"\\nClang opencl-c.h not found:\\n\\t${CLANG_OPENCL_C_H}\")\nelse()\n  message(STATUS \"Using opencl-c.h: ${CLANG_OPENCL_C_H}\")\nendif()\n\n# Check for clang\nfind_program(CLANG clang\n             PATHS \"${CLANG_ROOT}/bin\" \"${LLVM_TOOLS_BINARY_DIR}\"\n             NO_DEFAULT_PATH)\nfind_program(CLANG clang)\nif (\"${CLANG}\" STREQUAL \"CLANG-NOTFOUND\")\n  message(FATAL_ERROR \"Could not find clang binary\")\nendif()\n\n\n# Check for GNU readline library\nif (NOT \"${CMAKE_SYSTEM_NAME}\" STREQUAL \"Windows\")\n  set(READLINE_DIR \"\" CACHE PATH \"Location of GNU readline library\")\n\n  set(CMAKE_REQUIRED_INCLUDES ${READLINE_DIR}/include)\n  include_directories(${READLINE_DIR}/include)\n  link_directories(${READLINE_DIR}/lib)\n\n  check_include_files(\"stdio.h;readline/readline.h\" HAVE_READLINE_H)\n  check_include_files(\"stdio.h;readline/history.h\" HAVE_HISTORY_H)\n  check_library_exists(readline readline\n                       \"${READLINE_DIR}/lib\" HAVE_READLINE_LIB)\n  check_library_exists(readline add_history\n                       \"${READLINE_DIR}/lib\" HAVE_HISTORY_LIB)\n  if (HAVE_READLINE_H AND HAVE_HISTORY_H AND\n      HAVE_READLINE_LIB AND HAVE_HISTORY_LIB)\n    set(HAVE_READLINE 1)\n    list(APPEND CORE_EXTRA_LIBS readline)\n  else()\n    set(HAVE_READLINE 0)\n    message(WARNING \"GNU readline library not found (set READLINE_DIR)\\n\"\n                    \"The interactive debugger will not have a command history.\")\n  endif()\nelse()\n set(HAVE_READLINE 0)\nendif()\n\n# Check for library directory suffixes\nset(_LIBDIR_SUFFIX \"\")\nget_property(USING_LIB64 GLOBAL PROPERTY FIND_LIBRARY_USE_LIB64_PATHS)\nif (USING_LIB64 AND NOT \"${CMAKE_SYSTEM_NAME}\" STREQUAL \"Darwin\")\n  set(_LIBDIR_SUFFIX \"64\")\nendif()\nset(LIBDIR_SUFFIX \"${_LIBDIR_SUFFIX}\"\n    CACHE STRING \"Suffix for installed library directory\")\n\n# Generate stringified opencl-c.h\nadd_custom_command(\n  OUTPUT src/core/opencl-c.h.cpp\n  COMMAND ${CMAKE_COMMAND} -DSOURCE_FILE=${CLANG_OPENCL_C_H}\n    -P ${CMAKE_SOURCE_DIR}/src/core/gen_opencl-c.h.cmake\n  DEPENDS ${CLANG_OPENCL_C_H} src/core/gen_opencl-c.h.cmake\n)\n\ninclude_directories(\"src/\" \"${PROJECT_BINARY_DIR}\")\n\nif (NOT \"${CMAKE_SYSTEM_NAME}\" STREQUAL \"Windows\")\n  set(CORE_LIB_TYPE \"SHARED\")\nendif()\n\nset(CORE_HEADERS\n  src/core/common.h\n  src/core/Context.h\n  src/core/half.h\n  src/core/Kernel.h\n  src/core/KernelInvocation.h\n  src/core/Memory.h\n  src/core/Plugin.h\n  src/core/Program.h\n  src/core/Queue.h\n  src/core/WorkItem.h\n  src/core/WorkGroup.h)\n\nadd_library(oclgrind ${CORE_LIB_TYPE}\n  ${CORE_HEADERS}\n  src/core/opencl-c.h.cpp\n  src/core/common.cpp\n  src/core/Context.cpp\n  src/core/half.cpp\n  src/core/Kernel.cpp\n  src/core/KernelInvocation.cpp\n  src/core/Memory.cpp\n  src/core/Plugin.cpp\n  src/core/Program.cpp\n  src/core/Queue.cpp\n  src/core/WorkItem.cpp\n  src/core/WorkItemBuiltins.cpp\n  src/core/WorkGroup.cpp\n  src/plugins/InstructionCounter.h\n  src/plugins/InstructionCounter.cpp\n  src/plugins/InteractiveDebugger.h\n  src/plugins/InteractiveDebugger.cpp\n  src/plugins/Logger.h\n  src/plugins/Logger.cpp\n  src/plugins/MemCheck.h\n  src/plugins/MemCheck.cpp\n  src/plugins/RaceDetector.h\n  src/plugins/RaceDetector.cpp\n  src/plugins/Uninitialized.h\n  src/plugins/Uninitialized.cpp)\ntarget_link_libraries(oclgrind\n  PRIVATE ${CORE_EXTRA_LIBS} ${CLANG_LIBS}\n  PUBLIC ${LLVM_LIBS})\n\nif (\"${CMAKE_SYSTEM_NAME}\" STREQUAL \"Windows\")\n  target_link_libraries(oclgrind PRIVATE Version)\nendif()\n\n# Sources for OpenCL runtime API frontend\nset(RUNTIME_SOURCES\n  src/runtime/async_queue.h\n  src/runtime/async_queue.cpp\n  src/runtime/icd.h\n  src/runtime/runtime.cpp)\n\n# Add ICD exports on Windows\nif (\"${CMAKE_SYSTEM_NAME}\" STREQUAL \"Windows\")\n  set(DLL_EXPORTS src/runtime/icd.def)\nendif()\n\nadd_library(oclgrind-rt-icd SHARED ${RUNTIME_SOURCES} ${DLL_EXPORTS})\nset_target_properties(oclgrind-rt-icd PROPERTIES COMPILE_FLAGS -DOCLGRIND_ICD)\ntarget_link_libraries(oclgrind-rt-icd ${CMAKE_DL_LIBS} oclgrind)\n\n# Add runtime exports on Windows\nif (\"${CMAKE_SYSTEM_NAME}\" STREQUAL \"Windows\")\n  set(DLL_EXPORTS src/runtime/runtime.def)\nendif()\n\nadd_library(oclgrind-rt SHARED ${RUNTIME_SOURCES} ${DLL_EXPORTS})\ntarget_link_libraries(oclgrind-rt ${CMAKE_DL_LIBS} oclgrind)\n\nif (UNIX AND NOT APPLE)\n  # Change the SONAME of the library so that it gets recognized by dlopen\n  set_target_properties(oclgrind-rt PROPERTIES\n                        NO_SONAME ON\n                        LINK_FLAGS \"-Wl,-soname,libOpenCL.so\")\nendif()\n\nadd_executable(oclgrind-exe src/runtime/oclgrind.cpp)\nset_target_properties(oclgrind-exe PROPERTIES OUTPUT_NAME oclgrind)\ntarget_compile_definitions(oclgrind-exe PRIVATE\n                           \"-DLIBDIR_SUFFIX=\\\"${LIBDIR_SUFFIX}\\\"\")\n\nadd_executable(oclgrind-kernel\n  src/kernel/oclgrind-kernel.cpp\n  src/kernel/Simulation.h\n  src/kernel/Simulation.cpp)\ntarget_link_libraries(oclgrind-kernel oclgrind)\n\nset(OPENCL_C_H\n ${CMAKE_BINARY_DIR}/include/oclgrind/opencl-c.h\n ${CMAKE_BINARY_DIR}/include/oclgrind/opencl-c-1.2-32.pch\n ${CMAKE_BINARY_DIR}/include/oclgrind/opencl-c-1.2-64.pch\n ${CMAKE_BINARY_DIR}/include/oclgrind/opencl-c-2.0-32.pch\n ${CMAKE_BINARY_DIR}/include/oclgrind/opencl-c-2.0-64.pch\n)\n\nadd_custom_target(OPENCL_C_HEADERS ALL DEPENDS ${OPENCL_C_H})\n\nadd_custom_command(\n  OUTPUT include/oclgrind/opencl-c.h\n  POST_BUILD\n  COMMAND ${CMAKE_COMMAND} -E\n    copy ${CLANG_OPENCL_C_H} include/oclgrind/opencl-c.h\n  DEPENDS ${CLANG_OPENCL_C_H})\n\n# Generate precompiled headers for opencl-c.h\nset(OPENCL_C_H_SYSROOT \"${CMAKE_BINARY_DIR}/include/oclgrind/\")\nif (\"${CMAKE_SYSTEM_NAME}\" STREQUAL \"Windows\")\n  string(REPLACE \"/\" \"\\\\\" OPENCL_C_H_SYSROOT \"${OPENCL_C_H_SYSROOT}\")\nendif()\nadd_custom_command(\n  OUTPUT include/oclgrind/opencl-c-1.2-32.pch\n  POST_BUILD\n  COMMAND\n    ${CLANG}\n    -cc1 -x cl -cl-std=CL1.2 -O0 -fno-builtin -fgnu89-inline\n    -emit-pch -triple spir-unknown-unknown\n    -relocatable-pch -isysroot \"${OPENCL_C_H_SYSROOT}\"\n    include/oclgrind/opencl-c.h\n    -o include/oclgrind/opencl-c-1.2-32.pch\n  DEPENDS include/oclgrind/opencl-c.h\n)\nadd_custom_command(\n  OUTPUT include/oclgrind/opencl-c-1.2-64.pch\n  POST_BUILD\n  COMMAND\n    ${CLANG}\n    -cc1 -x cl -cl-std=CL1.2 -O0 -fno-builtin -fgnu89-inline\n    -emit-pch -triple spir64-unknown-unknown\n    -relocatable-pch -isysroot \"${OPENCL_C_H_SYSROOT}\"\n    include/oclgrind/opencl-c.h\n    -o include/oclgrind/opencl-c-1.2-64.pch\n  DEPENDS include/oclgrind/opencl-c.h\n)\nadd_custom_command(\n  OUTPUT include/oclgrind/opencl-c-2.0-32.pch\n  POST_BUILD\n  COMMAND\n    ${CLANG}\n    -cc1 -x cl -cl-std=CL2.0 -O0 -fno-builtin -fgnu89-inline\n    -emit-pch -triple spir-unknown-unknown\n    -relocatable-pch -isysroot \"${OPENCL_C_H_SYSROOT}\"\n    include/oclgrind/opencl-c.h\n    -o include/oclgrind/opencl-c-2.0-32.pch\n  DEPENDS include/oclgrind/opencl-c.h\n)\nadd_custom_command(\n  OUTPUT include/oclgrind/opencl-c-2.0-64.pch\n  POST_BUILD\n  COMMAND\n    ${CLANG}\n    -cc1 -x cl -cl-std=CL2.0 -O0 -fno-builtin -fgnu89-inline\n    -emit-pch -triple spir64-unknown-unknown\n    -relocatable-pch -isysroot \"${OPENCL_C_H_SYSROOT}\"\n    include/oclgrind/opencl-c.h\n    -o include/oclgrind/opencl-c-2.0-64.pch\n  DEPENDS include/oclgrind/opencl-c.h\n)\n\n\n# Generate config.h\nset(LLVM_VERSION ${LLVM_VERSION_MAJOR}${LLVM_VERSION_MINOR})\nconfigure_file(\"config.h.in\" \"config.h\")\n\n\n# Generate ICD loader if not on Windows\nif (NOT \"${CMAKE_SYSTEM_NAME}\" STREQUAL \"Windows\")\n  file(GENERATE OUTPUT ${CMAKE_BINARY_DIR}/oclgrind.icd\n       CONTENT \"${CMAKE_INSTALL_PREFIX}/lib${LIBDIR_SUFFIX}/$<TARGET_FILE_NAME:oclgrind-rt-icd>\\n\")\nendif()\n\ninstall(TARGETS\n  oclgrind-exe oclgrind-kernel\n  DESTINATION bin)\ninstall(TARGETS\n  oclgrind oclgrind-rt oclgrind-rt-icd\n  DESTINATION \"lib${LIBDIR_SUFFIX}\")\ninstall(FILES\n  ${CORE_HEADERS} ${OPENCL_C_H}\n  DESTINATION include/oclgrind)\nif (\"${CMAKE_SYSTEM_NAME}\" STREQUAL \"Windows\")\n  install(FILES\n    src/CL/cl.h\n    src/CL/cl_d3d10.h\n    src/CL/cl_d3d11.h\n    src/CL/cl_dx9_media_sharing.h\n    src/CL/cl_egl.h\n    src/CL/cl_ext.h\n    src/CL/cl_gl.h\n    src/CL/cl_gl_ext.h\n    src/CL/cl_platform.h\n    src/CL/opencl.h\n    DESTINATION include/CL)\nendif()\n\n\n# Tests\nenable_testing()\n\n# Check for Python\nfind_package(PythonInterp)\nif (PYTHONINTERP_FOUND)\n\n  # Add test directories\n  add_subdirectory(tests/apps)\n  add_subdirectory(tests/kernels)\n  add_subdirectory(tests/runtime)\n\nelse()\n  message(WARNING \"Tests will not be run (Python required)\")\nendif()\n\n\n# CPack config\nset(CPACK_PACKAGE_DESCRIPTION_SUMMARY \"OpenCL device simulator\")\nset(CPACK_PACKAGE_DESCRIPTION_FILE\n    \"${CMAKE_SOURCE_DIR}/src/install/cpack-description\")\nset(CPACK_PACKAGE_VENDOR \"University of Bristol\")\nset(CPACK_PACKAGE_VERSION_MAJOR ${Oclgrind_VERSION_MAJOR})\nset(CPACK_PACKAGE_VERSION_MINOR ${Oclgrind_VERSION_MINOR})\nset(CPACK_PACKAGE_VERSION \"${Oclgrind_VERSION_MAJOR}.${Oclgrind_VERSION_MINOR}\")\nset(CPACK_PACKAGE_VERSION_PATCH \"0\")\n\n# CPack RPM config\nset(CPACK_RPM_PACKAGE_GROUP \"Development/Tools\")\nset(CPACK_RPM_PACKAGE_LICENSE \"BSD\")\n\ninclude(CPack)\n",
        "/tmp/vanessa/spack-stage/spack-stage-oclgrind-master-wszi2yn2gtslctfn7lono7dykvsswk65/spack-src/src/core/Context.cpp": "// Context.cpp (Oclgrind)\n// Copyright (c) 2013-2019, James Price and Simon McIntosh-Smith,\n// University of Bristol. All rights reserved.\n//\n// This program is provided under a three-clause BSD license. For full\n// license terms please see the LICENSE file distributed with this\n// source code.\n\n#include \"common.h\"\n#include \"config.h\"\n\n#if defined(_WIN32) && !defined(__MINGW32__)\n#include <windows.h>\n#undef ERROR\n#else\n#include <dlfcn.h>\n#endif\n\n#include <mutex>\n\n#include \"llvm/IR/DebugInfo.h\"\n#include \"llvm/IR/Instruction.h\"\n#include \"llvm/IR/LLVMContext.h\"\n\n#include \"Context.h\"\n#include \"Kernel.h\"\n#include \"KernelInvocation.h\"\n#include \"Memory.h\"\n#include \"Program.h\"\n#include \"WorkGroup.h\"\n#include \"WorkItem.h\"\n\n#include \"plugins/InstructionCounter.h\"\n#include \"plugins/InteractiveDebugger.h\"\n#include \"plugins/Logger.h\"\n#include \"plugins/MemCheck.h\"\n#include \"plugins/RaceDetector.h\"\n#include \"plugins/Uninitialized.h\"\n\nusing namespace oclgrind;\nusing namespace std;\n\nContext::Context()\n{\n  m_llvmContext = new llvm::LLVMContext;\n\n  m_globalMemory =\n    new Memory(AddrSpaceGlobal, sizeof(size_t) == 8 ? 16 : 8, this);\n  m_kernelInvocation = NULL;\n\n  loadPlugins();\n}\n\nContext::~Context()\n{\n  delete m_llvmContext;\n  delete m_globalMemory;\n\n  unloadPlugins();\n}\n\nbool Context::isThreadSafe() const\n{\n  for (const PluginEntry& p : m_plugins)\n  {\n    if (!p.first->isThreadSafe())\n      return false;\n  }\n  return true;\n}\n\nMemory* Context::getGlobalMemory() const\n{\n  return m_globalMemory;\n}\n\nllvm::LLVMContext* Context::getLLVMContext() const\n{\n  return m_llvmContext;\n}\n\nvoid Context::loadPlugins()\n{\n  // Create core plugins\n  m_plugins.push_back(make_pair(new Logger(this), true));\n  m_plugins.push_back(make_pair(new MemCheck(this), true));\n\n  if (checkEnv(\"OCLGRIND_INST_COUNTS\"))\n    m_plugins.push_back(make_pair(new InstructionCounter(this), true));\n\n  if (checkEnv(\"OCLGRIND_DATA_RACES\"))\n    m_plugins.push_back(make_pair(new RaceDetector(this), true));\n\n  if (checkEnv(\"OCLGRIND_UNINITIALIZED\"))\n    m_plugins.push_back(make_pair(new Uninitialized(this), true));\n\n  if (checkEnv(\"OCLGRIND_INTERACTIVE\"))\n    m_plugins.push_back(make_pair(new InteractiveDebugger(this), true));\n\n  // Load dynamic plugins\n  const char* dynamicPlugins = getenv(\"OCLGRIND_PLUGINS\");\n  if (dynamicPlugins)\n  {\n    std::istringstream ss(dynamicPlugins);\n    std::string libpath;\n    while (std::getline(ss, libpath, ':'))\n    {\n#if defined(_WIN32) && !defined(__MINGW32__)\n      HMODULE library = LoadLibraryA(libpath.c_str());\n      if (!library)\n      {\n        cerr << \"Loading Oclgrind plugin failed (LoadLibrary): \"\n             << GetLastError() << endl;\n        continue;\n      }\n\n      void* initialize = GetProcAddress(library, \"initializePlugins\");\n      if (!initialize)\n      {\n        cerr << \"Loading Oclgrind plugin failed (GetProcAddress): \"\n             << GetLastError() << endl;\n        continue;\n      }\n#else\n      void* library = dlopen(libpath.c_str(), RTLD_NOW);\n      if (!library)\n      {\n        cerr << \"Loading Oclgrind plugin failed (dlopen): \" << dlerror()\n             << endl;\n        continue;\n      }\n\n      void* initialize = dlsym(library, \"initializePlugins\");\n      if (!initialize)\n      {\n        cerr << \"Loading Oclgrind plugin failed (dlsym): \" << dlerror() << endl;\n        continue;\n      }\n#endif\n\n      ((void (*)(Context*))initialize)(this);\n      m_pluginLibraries.push_back(library);\n    }\n  }\n}\n\nvoid Context::unloadPlugins()\n{\n  // Release dynamic plugin libraries\n  list<void*>::iterator plibItr;\n  for (plibItr = m_pluginLibraries.begin(); plibItr != m_pluginLibraries.end();\n       plibItr++)\n  {\n#if defined(_WIN32) && !defined(__MINGW32__)\n    void* release = GetProcAddress((HMODULE)*plibItr, \"releasePlugins\");\n    if (release)\n    {\n      ((void (*)(Context*))release)(this);\n    }\n    FreeLibrary((HMODULE)*plibItr);\n#else\n    void* release = dlsym(*plibItr, \"releasePlugins\");\n    if (release)\n    {\n      ((void (*)(Context*))release)(this);\n    }\n    dlclose(*plibItr);\n#endif\n  }\n\n  // Destroy internal plugins\n  PluginList::iterator pItr;\n  for (pItr = m_plugins.begin(); pItr != m_plugins.end(); pItr++)\n  {\n    if (pItr->second)\n      delete pItr->first;\n  }\n\n  m_plugins.clear();\n}\n\nvoid Context::registerPlugin(Plugin* plugin)\n{\n  m_plugins.push_back(make_pair(plugin, false));\n}\n\nvoid Context::unregisterPlugin(Plugin* plugin)\n{\n  m_plugins.remove(make_pair(plugin, false));\n}\n\nvoid Context::logError(const char* error) const\n{\n  Message msg(ERROR, this);\n  msg << error << endl\n      << msg.INDENT << \"Kernel: \" << msg.CURRENT_KERNEL << endl\n      << \"Entity: \" << msg.CURRENT_ENTITY << endl\n      << msg.CURRENT_LOCATION << endl;\n  msg.send();\n}\n\n#define NOTIFY(function, ...)                                                  \\\n  {                                                                            \\\n    PluginList::const_iterator pluginItr;                                      \\\n    for (pluginItr = m_plugins.begin(); pluginItr != m_plugins.end();          \\\n         pluginItr++)                                                          \\\n    {                                                                          \\\n      pluginItr->first->function(__VA_ARGS__);                                 \\\n    }                                                                          \\\n  }\n\nvoid Context::notifyInstructionExecuted(const WorkItem* workItem,\n                                        const llvm::Instruction* instruction,\n                                        const TypedValue& result) const\n{\n  NOTIFY(instructionExecuted, workItem, instruction, result);\n}\n\nvoid Context::notifyKernelBegin(const KernelInvocation* kernelInvocation) const\n{\n  assert(m_kernelInvocation == NULL);\n  m_kernelInvocation = kernelInvocation;\n\n  NOTIFY(kernelBegin, kernelInvocation);\n}\n\nvoid Context::notifyKernelEnd(const KernelInvocation* kernelInvocation) const\n{\n  NOTIFY(kernelEnd, kernelInvocation);\n\n  assert(m_kernelInvocation == kernelInvocation);\n  m_kernelInvocation = NULL;\n}\n\nvoid Context::notifyMemoryAllocated(const Memory* memory, size_t address,\n                                    size_t size, cl_mem_flags flags,\n                                    const uint8_t* initData) const\n{\n  NOTIFY(memoryAllocated, memory, address, size, flags, initData);\n}\n\nvoid Context::notifyMemoryAtomicLoad(const Memory* memory, AtomicOp op,\n                                     size_t address, size_t size) const\n{\n  if (m_kernelInvocation && m_kernelInvocation->getCurrentWorkItem())\n  {\n    NOTIFY(memoryAtomicLoad, memory, m_kernelInvocation->getCurrentWorkItem(),\n           op, address, size);\n  }\n}\n\nvoid Context::notifyMemoryAtomicStore(const Memory* memory, AtomicOp op,\n                                      size_t address, size_t size) const\n{\n  if (m_kernelInvocation && m_kernelInvocation->getCurrentWorkItem())\n  {\n    NOTIFY(memoryAtomicStore, memory, m_kernelInvocation->getCurrentWorkItem(),\n           op, address, size);\n  }\n}\n\nvoid Context::notifyMemoryDeallocated(const Memory* memory,\n                                      size_t address) const\n{\n  NOTIFY(memoryDeallocated, memory, address);\n}\n\nvoid Context::notifyMemoryLoad(const Memory* memory, size_t address,\n                               size_t size) const\n{\n  if (m_kernelInvocation)\n  {\n    if (m_kernelInvocation->getCurrentWorkItem())\n    {\n      NOTIFY(memoryLoad, memory, m_kernelInvocation->getCurrentWorkItem(),\n             address, size);\n    }\n    else if (m_kernelInvocation->getCurrentWorkGroup())\n    {\n      NOTIFY(memoryLoad, memory, m_kernelInvocation->getCurrentWorkGroup(),\n             address, size);\n    }\n  }\n  else\n  {\n    NOTIFY(hostMemoryLoad, memory, address, size);\n  }\n}\n\nvoid Context::notifyMemoryMap(const Memory* memory, size_t address,\n                              size_t offset, size_t size,\n                              cl_mem_flags flags) const\n{\n  NOTIFY(memoryMap, memory, address, offset, size, flags);\n}\n\nvoid Context::notifyMemoryStore(const Memory* memory, size_t address,\n                                size_t size, const uint8_t* storeData) const\n{\n  if (m_kernelInvocation)\n  {\n    if (m_kernelInvocation->getCurrentWorkItem())\n    {\n      NOTIFY(memoryStore, memory, m_kernelInvocation->getCurrentWorkItem(),\n             address, size, storeData);\n    }\n    else if (m_kernelInvocation->getCurrentWorkGroup())\n    {\n      NOTIFY(memoryStore, memory, m_kernelInvocation->getCurrentWorkGroup(),\n             address, size, storeData);\n    }\n  }\n  else\n  {\n    NOTIFY(hostMemoryStore, memory, address, size, storeData);\n  }\n}\n\nvoid Context::notifyMessage(MessageType type, const char* message) const\n{\n  NOTIFY(log, type, message);\n}\n\nvoid Context::notifyMemoryUnmap(const Memory* memory, size_t address,\n                                const void* ptr) const\n{\n  NOTIFY(memoryUnmap, memory, address, ptr);\n}\n\nvoid Context::notifyWorkGroupBarrier(const WorkGroup* workGroup,\n                                     uint32_t flags) const\n{\n  NOTIFY(workGroupBarrier, workGroup, flags);\n}\n\nvoid Context::notifyWorkGroupBegin(const WorkGroup* workGroup) const\n{\n  NOTIFY(workGroupBegin, workGroup);\n}\n\nvoid Context::notifyWorkGroupComplete(const WorkGroup* workGroup) const\n{\n  NOTIFY(workGroupComplete, workGroup);\n}\n\nvoid Context::notifyWorkItemBegin(const WorkItem* workItem) const\n{\n  NOTIFY(workItemBegin, workItem);\n}\n\nvoid Context::notifyWorkItemComplete(const WorkItem* workItem) const\n{\n  NOTIFY(workItemComplete, workItem);\n}\n\n#undef NOTIFY\n\nContext::Message::Message(MessageType type, const Context* context)\n{\n  m_type = type;\n  m_context = context;\n  m_kernelInvocation = context->m_kernelInvocation;\n}\n\nContext::Message& Context::Message::operator<<(const special& id)\n{\n  switch (id)\n  {\n  case INDENT:\n    m_indentModifiers.push_back(m_stream.tellp());\n    break;\n  case UNINDENT:\n    m_indentModifiers.push_back(-m_stream.tellp());\n    break;\n  case CURRENT_KERNEL:\n    *this << m_kernelInvocation->getKernel()->getName();\n    break;\n  case CURRENT_WORK_ITEM_GLOBAL:\n  {\n    const WorkItem* workItem = m_kernelInvocation->getCurrentWorkItem();\n    if (workItem)\n    {\n      *this << workItem->getGlobalID();\n    }\n    else\n    {\n      *this << \"(none)\";\n    }\n    break;\n  }\n  case CURRENT_WORK_ITEM_LOCAL:\n  {\n    const WorkItem* workItem = m_kernelInvocation->getCurrentWorkItem();\n    if (workItem)\n    {\n      *this << workItem->getLocalID();\n    }\n    else\n    {\n      *this << \"(none)\";\n    }\n    break;\n  }\n  case CURRENT_WORK_GROUP:\n  {\n    const WorkGroup* workGroup = m_kernelInvocation->getCurrentWorkGroup();\n    if (workGroup)\n    {\n      *this << workGroup->getGroupID();\n    }\n    else\n    {\n      *this << \"(none)\";\n    }\n    break;\n  }\n  case CURRENT_ENTITY:\n  {\n    const WorkItem* workItem = m_kernelInvocation->getCurrentWorkItem();\n    const WorkGroup* workGroup = m_kernelInvocation->getCurrentWorkGroup();\n    if (workItem)\n    {\n      *this << \"Global\" << workItem->getGlobalID() << \" Local\"\n            << workItem->getLocalID() << \" \";\n    }\n    if (workGroup)\n    {\n      *this << \"Group\" << workGroup->getGroupID();\n    }\n    if (!workItem && !workGroup)\n    {\n      *this << \"(unknown)\";\n    }\n    break;\n  }\n  case CURRENT_LOCATION:\n  {\n    const llvm::Instruction* instruction = NULL;\n    const WorkItem* workItem = m_kernelInvocation->getCurrentWorkItem();\n    const WorkGroup* workGroup = m_kernelInvocation->getCurrentWorkGroup();\n    if (workItem)\n    {\n      instruction = workItem->getCurrentInstruction();\n    }\n    else if (workGroup)\n    {\n      instruction = workGroup->getCurrentBarrier();\n    }\n\n    *this << instruction;\n    break;\n  }\n  }\n  return *this;\n}\n\nContext::Message&\nContext::Message::operator<<(const llvm::Instruction* instruction)\n{\n  // Use mutex as some part of LLVM used by dumpInstruction() is not thread-safe\n  static std::mutex mtx;\n  std::lock_guard<std::mutex> lock(mtx);\n\n  if (instruction)\n  {\n    // Output instruction\n    dumpInstruction(m_stream, instruction);\n    *this << endl;\n\n    // Output debug information\n    llvm::MDNode* md = instruction->getMetadata(\"dbg\");\n    if (!md)\n    {\n      *this << \"Debugging information not available.\" << endl;\n    }\n    else\n    {\n      llvm::DILocation* loc = (llvm::DILocation*)md;\n      unsigned lineNumber = loc->getLine();\n      unsigned columnNumber = loc->getColumn();\n      llvm::StringRef filename = loc->getFilename();\n\n      *this << \"At line \" << dec << lineNumber << \" (column \" << columnNumber\n            << \")\"\n            << \" of \" << filename.str() << \":\" << endl;\n\n      // Get source line\n      const Program* program = m_kernelInvocation->getKernel()->getProgram();\n      const char* line = program->getSourceLine(lineNumber);\n      if (line)\n      {\n        while (isspace(line[0]))\n          line++;\n        *this << \"  \" << line;\n      }\n      else\n        *this << \"  (source not available)\";\n    }\n  }\n  else\n  {\n    *this << \"(location unknown)\";\n  }\n\n  return *this;\n}\n\nContext::Message&\nContext::Message::operator<<(std::ostream& (*t)(std::ostream&))\n{\n  m_stream << t;\n  return *this;\n}\n\nContext::Message& Context::Message::operator<<(std::ios& (*t)(std::ios&))\n{\n  m_stream << t;\n  return *this;\n}\n\nContext::Message&\nContext::Message::operator<<(std::ios_base& (*t)(std::ios_base&))\n{\n  m_stream << t;\n  return *this;\n}\n\nvoid Context::Message::send() const\n{\n  string msg;\n\n  string line;\n  int currentIndent = 0;\n  list<int>::const_iterator itr = m_indentModifiers.begin();\n\n  m_stream.clear();\n  m_stream.seekg(0);\n  while (m_stream.good())\n  {\n    getline(m_stream, line);\n\n    // TODO: Wrap long lines\n    msg += line;\n\n    // Check for indentation modifiers\n    long pos = m_stream.tellg();\n    if (itr != m_indentModifiers.end() && pos >= abs(*itr))\n    {\n      if (*itr >= 0)\n        currentIndent++;\n      else\n        currentIndent--;\n      itr++;\n    }\n\n    if (!m_stream.eof())\n    {\n      // Add newline and indentation\n      msg += '\\n';\n      for (int i = 0; i < currentIndent; i++)\n        msg += '\\t';\n    }\n  }\n\n  m_context->notifyMessage(m_type, msg.c_str());\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-oclgrind-master-wszi2yn2gtslctfn7lono7dykvsswk65/spack-src/src/install/oclgrind-icd.reg",
        "/tmp/vanessa/spack-stage/spack-stage-oclgrind-master-wszi2yn2gtslctfn7lono7dykvsswk65/spack-src/.git/objects/pack/pack-1ba79687b7998bf58b787a452df5f2ca8b920362.pack",
        "/tmp/vanessa/spack-stage/spack-stage-oclgrind-master-wszi2yn2gtslctfn7lono7dykvsswk65/spack-src/.git/objects/pack/pack-1ba79687b7998bf58b787a452df5f2ca8b920362.idx"
    ],
    "total_files": 383
}