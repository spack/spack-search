{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-saws-develop-zqo76cxj3ulpp5ka4xq64qfxm62zubta/spack-src/src/mongoose.c": "// Copyright (c) 2004-2013 Sergey Lyubka\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n#if defined(_WIN32)\n#define _CRT_SECURE_NO_WARNINGS // Disable deprecation warning in VS2005\n#else\n#ifdef __linux__\n#define _XOPEN_SOURCE 600     // For flockfile() on Linux\n#endif\n#define _LARGEFILE_SOURCE     // Enable 64-bit file offsets\n#define __STDC_FORMAT_MACROS  // <inttypes.h> wants this for C++\n#define __STDC_LIMIT_MACROS   // C++ wants that for INT64_MAX\n#endif\n\n#if defined (_MSC_VER)\n// conditional expression is constant: introduced by FD_SET(..)\n#pragma warning (disable : 4127)\n// non-constant aggregate initializer: issued due to missing C99 support\n#pragma warning (disable : 4204)\n#endif\n\n// Disable WIN32_LEAN_AND_MEAN.\n// This makes windows.h always include winsock2.h\n#ifdef WIN32_LEAN_AND_MEAN\n#undef WIN32_LEAN_AND_MEAN\n#endif\n\n#if defined(__SYMBIAN32__)\n#define NO_SSL // SSL is not supported\n#define NO_CGI // CGI is not supported\n#define PATH_MAX FILENAME_MAX\n#endif // __SYMBIAN32__\n\n#ifndef _WIN32_WCE // Some ANSI #includes are not available on Windows CE\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <signal.h>\n#include <fcntl.h>\n#endif // !_WIN32_WCE\n\n#include <time.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <assert.h>\n#include <string.h>\n#include <ctype.h>\n#include <limits.h>\n#include <stddef.h>\n#include <stdio.h>\n\n#if defined(_WIN32) && !defined(__SYMBIAN32__) // Windows specific\n#define _WIN32_WINNT 0x0400 // To make it link in VS2005\n#include <windows.h>\n\n#ifndef PATH_MAX\n#define PATH_MAX MAX_PATH\n#endif\n\n#ifndef _WIN32_WCE\n#include <process.h>\n#include <direct.h>\n#include <io.h>\n#else // _WIN32_WCE\n#define NO_CGI // WinCE has no pipes\n\ntypedef long off_t;\n\n#define errno   GetLastError()\n#define strerror(x)  _ultoa(x, (char *) _alloca(sizeof(x) *3 ), 10)\n#endif // _WIN32_WCE\n\n#define MAKEUQUAD(lo, hi) ((uint64_t)(((uint32_t)(lo)) | \\\n      ((uint64_t)((uint32_t)(hi))) << 32))\n#define RATE_DIFF 10000000 // 100 nsecs\n#define EPOCH_DIFF MAKEUQUAD(0xd53e8000, 0x019db1de)\n#define SYS2UNIX_TIME(lo, hi) \\\n  (time_t) ((MAKEUQUAD((lo), (hi)) - EPOCH_DIFF) / RATE_DIFF)\n\n// Visual Studio 6 does not know __func__ or __FUNCTION__\n// The rest of MS compilers use __FUNCTION__, not C99 __func__\n// Also use _strtoui64 on modern M$ compilers\n#if defined(_MSC_VER) && _MSC_VER < 1300\n#define STRX(x) #x\n#define STR(x) STRX(x)\n#define __func__ __FILE__ \":\" STR(__LINE__)\n#define strtoull(x, y, z) strtoul(x, y, z)\n#define strtoll(x, y, z) strtol(x, y, z)\n#else\n#define __func__  __FUNCTION__\n#define strtoull(x, y, z) _strtoui64(x, y, z)\n#define strtoll(x, y, z) _strtoi64(x, y, z)\n#endif // _MSC_VER\n\n#define ERRNO   GetLastError()\n#define NO_SOCKLEN_T\n#define SSL_LIB   \"ssleay32.dll\"\n#define CRYPTO_LIB  \"libeay32.dll\"\n#define O_NONBLOCK  0\n#if !defined(EWOULDBLOCK)\n#define EWOULDBLOCK  WSAEWOULDBLOCK\n#endif // !EWOULDBLOCK\n#define _POSIX_\n#define INT64_FMT  \"I64d\"\n\n#define WINCDECL __cdecl\n#define SHUT_WR 1\n#define snprintf _snprintf\n#define vsnprintf _vsnprintf\n#define mg_sleep(x) Sleep(x)\n\n#define pipe(x) _pipe(x, MG_BUF_LEN, _O_BINARY)\n#define popen(x, y) _popen(x, y)\n#define pclose(x) _pclose(x)\n#define close(x) _close(x)\n#define dlsym(x,y) GetProcAddress((HINSTANCE) (x), (y))\n#define RTLD_LAZY  0\n#define fseeko(x, y, z) _lseeki64(_fileno(x), (y), (z))\n#define fdopen(x, y) _fdopen((x), (y))\n#define write(x, y, z) _write((x), (y), (unsigned) z)\n#define read(x, y, z) _read((x), (y), (unsigned) z)\n#define flockfile(x) EnterCriticalSection(&global_log_file_lock)\n#define funlockfile(x) LeaveCriticalSection(&global_log_file_lock)\n#define sleep(x) Sleep((x) * 1000)\n#define va_copy(x, y) x = y\n\n#if !defined(fileno)\n#define fileno(x) _fileno(x)\n#endif // !fileno MINGW #defines fileno\n\ntypedef HANDLE pthread_mutex_t;\ntypedef struct {HANDLE signal, broadcast;} pthread_cond_t;\ntypedef DWORD pthread_t;\n#define pid_t HANDLE // MINGW typedefs pid_t to int. Using #define here.\n\nstatic int pthread_mutex_lock(pthread_mutex_t *);\nstatic int pthread_mutex_unlock(pthread_mutex_t *);\nstatic void to_unicode(const char *path, wchar_t *wbuf, size_t wbuf_len);\nstruct file;\nstatic char *mg_fgets(char *buf, size_t size, struct file *filep, char **p);\n\n#if defined(HAVE_STDINT)\n#include <stdint.h>\n#else\ntypedef unsigned int  uint32_t;\ntypedef unsigned short  uint16_t;\ntypedef unsigned __int64 uint64_t;\ntypedef __int64   int64_t;\n#define INT64_MAX  9223372036854775807\n#endif // HAVE_STDINT\n\n// POSIX dirent interface\nstruct dirent {\n  char d_name[PATH_MAX];\n};\n\ntypedef struct DIR {\n  HANDLE   handle;\n  WIN32_FIND_DATAW info;\n  struct dirent  result;\n} DIR;\n\n#ifndef HAS_POLL\nstruct pollfd {\n  int fd;\n  short events;\n  short revents;\n};\n#define POLLIN 1\n#endif\n\n\n// Mark required libraries\n#pragma comment(lib, \"Ws2_32.lib\")\n\n#else    // UNIX  specific\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/poll.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <sys/time.h>\n#include <stdint.h>\n#include <inttypes.h>\n#include <netdb.h>\n\n#include <pwd.h>\n#include <unistd.h>\n#include <dirent.h>\n#if !defined(NO_SSL_DL) && !defined(NO_SSL)\n#include <dlfcn.h>\n#endif\n#include <pthread.h>\n#if defined(__MACH__)\n#define SSL_LIB   \"libssl.dylib\"\n#define CRYPTO_LIB  \"libcrypto.dylib\"\n#else\n#if !defined(SSL_LIB)\n#define SSL_LIB   \"libssl.so\"\n#endif\n#if !defined(CRYPTO_LIB)\n#define CRYPTO_LIB  \"libcrypto.so\"\n#endif\n#endif\n#ifndef O_BINARY\n#define O_BINARY  0\n#endif // O_BINARY\n#define closesocket(a) close(a)\n#define mg_mkdir(x, y) mkdir(x, y)\n#define mg_remove(x) remove(x)\n#define mg_rename(x, y) rename(x, y)\n#define mg_sleep(x) usleep((x) * 1000)\n#define ERRNO errno\n#define INVALID_SOCKET (-1)\n#define INT64_FMT PRId64\ntypedef int SOCKET;\n#define WINCDECL\n\n#endif // End of Windows and UNIX specific includes\n\n#include <mongoose.h>\n\n#ifdef USE_LUA\n#include <lua.h>\n#include <lauxlib.h>\n#endif\n\n#define MONGOOSE_VERSION \"3.7\"\n#define PASSWORDS_FILE_NAME \".htpasswd\"\n#define CGI_ENVIRONMENT_SIZE 4096\n#define MAX_CGI_ENVIR_VARS 64\n#define MG_BUF_LEN 8192\n#define MAX_REQUEST_SIZE 16384\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\n#ifdef _WIN32\nstatic CRITICAL_SECTION global_log_file_lock;\nstatic pthread_t pthread_self(void) {\n  return GetCurrentThreadId();\n}\n#endif // _WIN32\n\n#ifdef DEBUG_TRACE\n#undef DEBUG_TRACE\n#define DEBUG_TRACE(x)\n#else\n#if defined(DEBUG)\n#define DEBUG_TRACE(x) do { \\\n  flockfile(stdout); \\\n  printf(\"*** %lu.%p.%s.%d: \", \\\n         (unsigned long) time(NULL), (void *) pthread_self(), \\\n         __func__, __LINE__); \\\n  printf x; \\\n  putchar('\\n'); \\\n  fflush(stdout); \\\n  funlockfile(stdout); \\\n} while (0)\n#else\n#define DEBUG_TRACE(x)\n#endif // DEBUG\n#endif // DEBUG_TRACE\n\n// Darwin prior to 7.0 and Win32 do not have socklen_t\n#ifdef NO_SOCKLEN_T\ntypedef int socklen_t;\n#endif // NO_SOCKLEN_T\n#define _DARWIN_UNLIMITED_SELECT\n\n#if !defined(MSG_NOSIGNAL)\n#define MSG_NOSIGNAL 0\n#endif\n\n#if !defined(SOMAXCONN)\n#define SOMAXCONN 100\n#endif\n\n#if !defined(PATH_MAX)\n#define PATH_MAX 4096\n#endif\n\nstatic const char *http_500_error = \"Internal Server Error\";\n\n#if defined(NO_SSL_DL)\n#include <openssl/ssl.h>\n#else\n// SSL loaded dynamically from DLL.\n// I put the prototypes here to be independent from OpenSSL source installation.\ntypedef struct ssl_st SSL;\ntypedef struct ssl_method_st SSL_METHOD;\ntypedef struct ssl_ctx_st SSL_CTX;\n\nstruct ssl_func {\n  const char *name;   // SSL function name\n  void  (*ptr)(void); // Function pointer\n};\n\n#define SSL_free (* (void (*)(SSL *)) ssl_sw[0].ptr)\n#define SSL_accept (* (int (*)(SSL *)) ssl_sw[1].ptr)\n#define SSL_connect (* (int (*)(SSL *)) ssl_sw[2].ptr)\n#define SSL_read (* (int (*)(SSL *, void *, int)) ssl_sw[3].ptr)\n#define SSL_write (* (int (*)(SSL *, const void *,int)) ssl_sw[4].ptr)\n#define SSL_get_error (* (int (*)(SSL *, int)) ssl_sw[5].ptr)\n#define SSL_set_fd (* (int (*)(SSL *, SOCKET)) ssl_sw[6].ptr)\n#define SSL_new (* (SSL * (*)(SSL_CTX *)) ssl_sw[7].ptr)\n#define SSL_CTX_new (* (SSL_CTX * (*)(SSL_METHOD *)) ssl_sw[8].ptr)\n#define SSLv23_server_method (* (SSL_METHOD * (*)(void)) ssl_sw[9].ptr)\n#define SSL_library_init (* (int (*)(void)) ssl_sw[10].ptr)\n#define SSL_CTX_use_PrivateKey_file (* (int (*)(SSL_CTX *, \\\n        const char *, int)) ssl_sw[11].ptr)\n#define SSL_CTX_use_certificate_file (* (int (*)(SSL_CTX *, \\\n        const char *, int)) ssl_sw[12].ptr)\n#define SSL_CTX_set_default_passwd_cb \\\n  (* (void (*)(SSL_CTX *, mg_callback_t)) ssl_sw[13].ptr)\n#define SSL_CTX_free (* (void (*)(SSL_CTX *)) ssl_sw[14].ptr)\n#define SSL_load_error_strings (* (void (*)(void)) ssl_sw[15].ptr)\n#define SSL_CTX_use_certificate_chain_file \\\n  (* (int (*)(SSL_CTX *, const char *)) ssl_sw[16].ptr)\n#define SSLv23_client_method (* (SSL_METHOD * (*)(void)) ssl_sw[17].ptr)\n#define SSL_pending (* (int (*)(SSL *)) ssl_sw[18].ptr)\n#define SSL_CTX_set_verify (* (void (*)(SSL_CTX *, int, int)) ssl_sw[19].ptr)\n\n#define CRYPTO_num_locks (* (int (*)(void)) crypto_sw[0].ptr)\n#define CRYPTO_set_locking_callback \\\n  (* (void (*)(void (*)(int, int, const char *, int))) crypto_sw[1].ptr)\n#define CRYPTO_set_id_callback \\\n  (* (void (*)(unsigned long (*)(void))) crypto_sw[2].ptr)\n#define ERR_get_error (* (unsigned long (*)(void)) crypto_sw[3].ptr)\n#define ERR_error_string (* (char * (*)(unsigned long,char *)) crypto_sw[4].ptr)\n\n// set_ssl_option() function updates this array.\n// It loads SSL library dynamically and changes NULLs to the actual addresses\n// of respective functions. The macros above (like SSL_connect()) are really\n// just calling these functions indirectly via the pointer.\nstatic struct ssl_func ssl_sw[] = {\n  {\"SSL_free\",   NULL},\n  {\"SSL_accept\",   NULL},\n  {\"SSL_connect\",   NULL},\n  {\"SSL_read\",   NULL},\n  {\"SSL_write\",   NULL},\n  {\"SSL_get_error\",  NULL},\n  {\"SSL_set_fd\",   NULL},\n  {\"SSL_new\",   NULL},\n  {\"SSL_CTX_new\",   NULL},\n  {\"SSLv23_server_method\", NULL},\n  {\"SSL_library_init\",  NULL},\n  {\"SSL_CTX_use_PrivateKey_file\", NULL},\n  {\"SSL_CTX_use_certificate_file\",NULL},\n  {\"SSL_CTX_set_default_passwd_cb\",NULL},\n  {\"SSL_CTX_free\",  NULL},\n  {\"SSL_load_error_strings\", NULL},\n  {\"SSL_CTX_use_certificate_chain_file\", NULL},\n  {\"SSLv23_client_method\", NULL},\n  {\"SSL_pending\", NULL},\n  {\"SSL_CTX_set_verify\", NULL},\n  {NULL,    NULL}\n};\n\n// Similar array as ssl_sw. These functions could be located in different lib.\n#if !defined(NO_SSL)\nstatic struct ssl_func crypto_sw[] = {\n  {\"CRYPTO_num_locks\",  NULL},\n  {\"CRYPTO_set_locking_callback\", NULL},\n  {\"CRYPTO_set_id_callback\", NULL},\n  {\"ERR_get_error\",  NULL},\n  {\"ERR_error_string\", NULL},\n  {NULL,    NULL}\n};\n#endif // NO_SSL\n#endif // NO_SSL_DL\n\nstatic const char *month_names[] = {\n  \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n  \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"\n};\n\n// Unified socket address. For IPv6 support, add IPv6 address structure\n// in the union u.\nunion usa {\n  struct sockaddr sa;\n  struct sockaddr_in sin;\n#if defined(USE_IPV6)\n  struct sockaddr_in6 sin6;\n#endif\n};\n\n// Describes a string (chunk of memory).\nstruct vec {\n  const char *ptr;\n  size_t len;\n};\n\nstruct file {\n  int is_directory;\n  time_t modification_time;\n  int64_t size;\n  FILE *fp;\n  const char *membuf;   // Non-NULL if file data is in memory\n};\n#define STRUCT_FILE_INITIALIZER {0, 0, 0, NULL, NULL}\n\n// Describes listening socket, or socket which was accept()-ed by the master\n// thread and queued for future handling by the worker thread.\nstruct socket {\n  SOCKET sock;          // Listening socket\n  union usa lsa;        // Local socket address\n  union usa rsa;        // Remote socket address\n  unsigned is_ssl:1;    // Is port SSL-ed\n  unsigned ssl_redir:1; // Is port supposed to redirect everything to SSL port\n};\n\n// NOTE(lsm): this enum shoulds be in sync with the config_options below.\nenum {\n  CGI_EXTENSIONS, CGI_ENVIRONMENT, PUT_DELETE_PASSWORDS_FILE, CGI_INTERPRETER,\n  PROTECT_URI, AUTHENTICATION_DOMAIN, SSI_EXTENSIONS, THROTTLE,\n  ACCESS_LOG_FILE, ENABLE_DIRECTORY_LISTING, ERROR_LOG_FILE,\n  GLOBAL_PASSWORDS_FILE, INDEX_FILES, ENABLE_KEEP_ALIVE, ACCESS_CONTROL_LIST,\n  EXTRA_MIME_TYPES, LISTENING_PORTS, DOCUMENT_ROOT, SSL_CERTIFICATE,\n  NUM_THREADS, RUN_AS_USER, REWRITE, HIDE_FILES, REQUEST_TIMEOUT,\n  NUM_OPTIONS\n};\n\nstatic const char *config_options[] = {\n  \"C\", \"cgi_pattern\", \"**.cgi$|**.pl$|**.php$\",\n  \"E\", \"cgi_environment\", NULL,\n  \"G\", \"put_delete_auth_file\", NULL,\n  \"I\", \"cgi_interpreter\", NULL,\n  \"P\", \"protect_uri\", NULL,\n  \"R\", \"authentication_domain\", \"mydomain.com\",\n  \"S\", \"ssi_pattern\", \"**.shtml$|**.shtm$\",\n  \"T\", \"throttle\", NULL,\n  \"a\", \"access_log_file\", NULL,\n  \"d\", \"enable_directory_listing\", \"yes\",\n  \"e\", \"error_log_file\", NULL,\n  \"g\", \"global_auth_file\", NULL,\n  \"i\", \"index_files\", \"index.html,index.htm,index.cgi,index.shtml,index.php\",\n  \"k\", \"enable_keep_alive\", \"no\",\n  \"l\", \"access_control_list\", NULL,\n  \"m\", \"extra_mime_types\", NULL,\n  \"p\", \"listening_ports\", \"8080\",\n  \"r\", \"document_root\",  \".\",\n  \"s\", \"ssl_certificate\", NULL,\n  \"t\", \"num_threads\", \"20\",\n  \"u\", \"run_as_user\", NULL,\n  \"w\", \"url_rewrite_patterns\", NULL,\n  \"x\", \"hide_files_patterns\", NULL,\n  \"z\", \"request_timeout_ms\", \"30000\",\n  NULL\n};\n#define ENTRIES_PER_CONFIG_OPTION 3\n\nstruct mg_context {\n  volatile int stop_flag;         // Should we stop event loop\n  SSL_CTX *ssl_ctx;               // SSL context\n  char *config[NUM_OPTIONS];      // Mongoose configuration parameters\n  struct mg_callbacks callbacks;  // User-defined callback function\n  void *user_data;                // User-defined data\n\n  struct socket *listening_sockets;\n  int num_listening_sockets;\n\n  volatile int num_threads;  // Number of threads\n  pthread_mutex_t mutex;     // Protects (max|num)_threads\n  pthread_cond_t  cond;      // Condvar for tracking workers terminations\n\n  struct socket queue[20];   // Accepted sockets\n  volatile int sq_head;      // Head of the socket queue\n  volatile int sq_tail;      // Tail of the socket queue\n  pthread_cond_t sq_full;    // Signaled when socket is produced\n  pthread_cond_t sq_empty;   // Signaled when socket is consumed\n};\n\nstruct mg_connection {\n  struct mg_request_info request_info;\n  struct mg_context *ctx;\n  SSL *ssl;                   // SSL descriptor\n  SSL_CTX *client_ssl_ctx;    // SSL context for client connections\n  struct socket client;       // Connected client\n  time_t birth_time;          // Time when request was received\n  int64_t num_bytes_sent;     // Total bytes sent to client\n  int64_t content_len;        // Content-Length header value\n  int64_t consumed_content;   // How many bytes of content have been read\n  char *buf;                  // Buffer for received data\n  char *path_info;            // PATH_INFO part of the URL\n  int must_close;             // 1 if connection must be closed\n  int buf_size;               // Buffer size\n  int request_len;            // Size of the request + headers in a buffer\n  int data_len;               // Total size of data in a buffer\n  int status_code;            // HTTP reply status code, e.g. 200\n  int throttle;               // Throttling, bytes/sec. <= 0 means no throttle\n  time_t last_throttle_time;  // Last time throttled data was sent\n  int64_t last_throttle_bytes;// Bytes sent this second\n};\n\nconst char **mg_get_valid_option_names(void) {\n  return config_options;\n}\n\nstatic int is_file_in_memory(struct mg_connection *conn, const char *path,\n                             struct file *filep) {\n  size_t size = 0;\n  if ((filep->membuf = conn->ctx->callbacks.open_file == NULL ? NULL :\n       conn->ctx->callbacks.open_file(conn, path, &size)) != NULL) {\n    // NOTE: override filep->size only on success. Otherwise, it might break\n    // constructs like if (!mg_stat() || !mg_fopen()) ...\n    filep->size = size;\n  }\n  return filep->membuf != NULL;\n}\n\nstatic int is_file_opened(const struct file *filep) {\n  return filep->membuf != NULL || filep->fp != NULL;\n}\n\nstatic int mg_fopen(struct mg_connection *conn, const char *path,\n                    const char *mode, struct file *filep) {\n  if (!is_file_in_memory(conn, path, filep)) {\n#ifdef _WIN32\n    wchar_t wbuf[PATH_MAX], wmode[20];\n    to_unicode(path, wbuf, ARRAY_SIZE(wbuf));\n    MultiByteToWideChar(CP_UTF8, 0, mode, -1, wmode, ARRAY_SIZE(wmode));\n    filep->fp = _wfopen(wbuf, wmode);\n#else\n    filep->fp = fopen(path, mode);\n#endif\n  }\n\n  return is_file_opened(filep);\n}\n\nstatic void mg_fclose(struct file *filep) {\n  if (filep != NULL && filep->fp != NULL) {\n    fclose(filep->fp);\n  }\n}\n\nstatic int get_option_index(const char *name) {\n  int i;\n\n  for (i = 0; config_options[i] != NULL; i += ENTRIES_PER_CONFIG_OPTION) {\n    if (strcmp(config_options[i], name) == 0 ||\n        strcmp(config_options[i + 1], name) == 0) {\n      return i / ENTRIES_PER_CONFIG_OPTION;\n    }\n  }\n  return -1;\n}\n\nconst char *mg_get_option(const struct mg_context *ctx, const char *name) {\n  int i;\n  if ((i = get_option_index(name)) == -1) {\n    return NULL;\n  } else if (ctx->config[i] == NULL) {\n    return \"\";\n  } else {\n    return ctx->config[i];\n  }\n}\n\nstatic void sockaddr_to_string(char *buf, size_t len,\n                                     const union usa *usa) {\n  buf[0] = '\\0';\n#if defined(USE_IPV6)\n  inet_ntop(usa->sa.sa_family, usa->sa.sa_family == AF_INET ?\n            (void *) &usa->sin.sin_addr :\n            (void *) &usa->sin6.sin6_addr, buf, len);\n#elif defined(_WIN32)\n  // Only Windoze Vista (and newer) have inet_ntop()\n  strncpy(buf, inet_ntoa(usa->sin.sin_addr), len);\n#else\n  inet_ntop(usa->sa.sa_family, (void *) &usa->sin.sin_addr, buf, len);\n#endif\n}\n\nstatic void cry(struct mg_connection *conn,\n                PRINTF_FORMAT_STRING(const char *fmt), ...) PRINTF_ARGS(2, 3);\n\n// Print error message to the opened error log stream.\nstatic void cry(struct mg_connection *conn, const char *fmt, ...) {\n  char buf[MG_BUF_LEN], src_addr[20];\n  va_list ap;\n  FILE *fp;\n  time_t timestamp;\n\n  va_start(ap, fmt);\n  (void) vsnprintf(buf, sizeof(buf), fmt, ap);\n  va_end(ap);\n\n  // Do not lock when getting the callback value, here and below.\n  // I suppose this is fine, since function cannot disappear in the\n  // same way string option can.\n  if (conn->ctx->callbacks.log_message == NULL ||\n      conn->ctx->callbacks.log_message(conn, buf) == 0) {\n    fp = conn->ctx == NULL || conn->ctx->config[ERROR_LOG_FILE] == NULL ? NULL :\n      fopen(conn->ctx->config[ERROR_LOG_FILE], \"a+\");\n\n    if (fp != NULL) {\n      flockfile(fp);\n      timestamp = time(NULL);\n\n      sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);\n      fprintf(fp, \"[%010lu] [error] [client %s] \", (unsigned long) timestamp,\n              src_addr);\n\n      if (conn->request_info.request_method != NULL) {\n        fprintf(fp, \"%s %s: \", conn->request_info.request_method,\n                conn->request_info.uri);\n      }\n\n      fprintf(fp, \"%s\", buf);\n      fputc('\\n', fp);\n      funlockfile(fp);\n      fclose(fp);\n    }\n  }\n}\n\n// Return fake connection structure. Used for logging, if connection\n// is not applicable at the moment of logging.\nstatic struct mg_connection *fc(struct mg_context *ctx) {\n  static struct mg_connection fake_connection;\n  fake_connection.ctx = ctx;\n  return &fake_connection;\n}\n\nconst char *mg_version(void) {\n  return MONGOOSE_VERSION;\n}\n\nstruct mg_request_info *mg_get_request_info(struct mg_connection *conn) {\n  return &conn->request_info;\n}\n\nstatic void mg_strlcpy(register char *dst, register const char *src, size_t n) {\n  for (; *src != '\\0' && n > 1; n--) {\n    *dst++ = *src++;\n  }\n  *dst = '\\0';\n}\n\nstatic int lowercase(const char *s) {\n  return tolower(* (const unsigned char *) s);\n}\n\nstatic int mg_strncasecmp(const char *s1, const char *s2, size_t len) {\n  int diff = 0;\n\n  if (len > 0)\n    do {\n      diff = lowercase(s1++) - lowercase(s2++);\n    } while (diff == 0 && s1[-1] != '\\0' && --len > 0);\n\n  return diff;\n}\n\nstatic int mg_strcasecmp(const char *s1, const char *s2) {\n  int diff;\n\n  do {\n    diff = lowercase(s1++) - lowercase(s2++);\n  } while (diff == 0 && s1[-1] != '\\0');\n\n  return diff;\n}\n\nstatic char * mg_strndup(const char *ptr, size_t len) {\n  char *p;\n\n  if ((p = (char *) malloc(len + 1)) != NULL) {\n    mg_strlcpy(p, ptr, len + 1);\n  }\n\n  return p;\n}\n\nstatic char * mg_strdup(const char *str) {\n  return mg_strndup(str, strlen(str));\n}\n\n// Like snprintf(), but never returns negative value, or a value\n// that is larger than a supplied buffer.\n// Thanks to Adam Zeldis to pointing snprintf()-caused vulnerability\n// in his audit report.\nstatic int mg_vsnprintf(struct mg_connection *conn, char *buf, size_t buflen,\n                        const char *fmt, va_list ap) {\n  int n;\n\n  if (buflen == 0)\n    return 0;\n\n  n = vsnprintf(buf, buflen, fmt, ap);\n\n  if (n < 0) {\n    cry(conn, \"vsnprintf error\");\n    n = 0;\n  } else if (n >= (int) buflen) {\n    cry(conn, \"truncating vsnprintf buffer: [%.*s]\",\n        n > 200 ? 200 : n, buf);\n    n = (int) buflen - 1;\n  }\n  buf[n] = '\\0';\n\n  return n;\n}\n\nstatic int mg_snprintf(struct mg_connection *conn, char *buf, size_t buflen,\n                       PRINTF_FORMAT_STRING(const char *fmt), ...)\n  PRINTF_ARGS(4, 5);\n\nstatic int mg_snprintf(struct mg_connection *conn, char *buf, size_t buflen,\n                       const char *fmt, ...) {\n  va_list ap;\n  int n;\n\n  va_start(ap, fmt);\n  n = mg_vsnprintf(conn, buf, buflen, fmt, ap);\n  va_end(ap);\n\n  return n;\n}\n\n// Skip the characters until one of the delimiters characters found.\n// 0-terminate resulting word. Skip the delimiter and following whitespaces.\n// Advance pointer to buffer to the next word. Return found 0-terminated word.\n// Delimiters can be quoted with quotechar.\nstatic char *skip_quoted(char **buf, const char *delimiters,\n                         const char *whitespace, char quotechar) {\n  char *p, *begin_word, *end_word, *end_whitespace;\n\n  begin_word = *buf;\n  end_word = begin_word + strcspn(begin_word, delimiters);\n\n  // Check for quotechar\n  if (end_word > begin_word) {\n    p = end_word - 1;\n    while (*p == quotechar) {\n      // If there is anything beyond end_word, copy it\n      if (*end_word == '\\0') {\n        *p = '\\0';\n        break;\n      } else {\n        size_t end_off = strcspn(end_word + 1, delimiters);\n        memmove (p, end_word, end_off + 1);\n        p += end_off; // p must correspond to end_word - 1\n        end_word += end_off + 1;\n      }\n    }\n    for (p++; p < end_word; p++) {\n      *p = '\\0';\n    }\n  }\n\n  if (*end_word == '\\0') {\n    *buf = end_word;\n  } else {\n    end_whitespace = end_word + 1 + strspn(end_word + 1, whitespace);\n\n    for (p = end_word; p < end_whitespace; p++) {\n      *p = '\\0';\n    }\n\n    *buf = end_whitespace;\n  }\n\n  return begin_word;\n}\n\n// Simplified version of skip_quoted without quote char\n// and whitespace == delimiters\nstatic char *skip(char **buf, const char *delimiters) {\n  return skip_quoted(buf, delimiters, delimiters, 0);\n}\n\n\n// Return HTTP header value, or NULL if not found.\nstatic const char *get_header(const struct mg_request_info *ri,\n                              const char *name) {\n  int i;\n\n  for (i = 0; i < ri->num_headers; i++)\n    if (!mg_strcasecmp(name, ri->http_headers[i].name))\n      return ri->http_headers[i].value;\n\n  return NULL;\n}\n\nconst char *mg_get_header(const struct mg_connection *conn, const char *name) {\n  return get_header(&conn->request_info, name);\n}\n\n// A helper function for traversing a comma separated list of values.\n// It returns a list pointer shifted to the next value, or NULL if the end\n// of the list found.\n// Value is stored in val vector. If value has form \"x=y\", then eq_val\n// vector is initialized to point to the \"y\" part, and val vector length\n// is adjusted to point only to \"x\".\nstatic const char *next_option(const char *list, struct vec *val,\n                               struct vec *eq_val) {\n  if (list == NULL || *list == '\\0') {\n    // End of the list\n    list = NULL;\n  } else {\n    val->ptr = list;\n    if ((list = strchr(val->ptr, ',')) != NULL) {\n      // Comma found. Store length and shift the list ptr\n      val->len = list - val->ptr;\n      list++;\n    } else {\n      // This value is the last one\n      list = val->ptr + strlen(val->ptr);\n      val->len = list - val->ptr;\n    }\n\n    if (eq_val != NULL) {\n      // Value has form \"x=y\", adjust pointers and lengths\n      // so that val points to \"x\", and eq_val points to \"y\".\n      eq_val->len = 0;\n      eq_val->ptr = (const char *) memchr(val->ptr, '=', val->len);\n      if (eq_val->ptr != NULL) {\n        eq_val->ptr++;  // Skip over '=' character\n        eq_val->len = val->ptr + val->len - eq_val->ptr;\n        val->len = (eq_val->ptr - val->ptr) - 1;\n      }\n    }\n  }\n\n  return list;\n}\n\nstatic int match_prefix(const char *pattern, int pattern_len, const char *str) {\n  const char *or_str;\n  int i, j, len, res;\n\n  if ((or_str = (const char *) memchr(pattern, '|', pattern_len)) != NULL) {\n    res = match_prefix(pattern, or_str - pattern, str);\n    return res > 0 ? res :\n        match_prefix(or_str + 1, (pattern + pattern_len) - (or_str + 1), str);\n  }\n\n  i = j = 0;\n  res = -1;\n  for (; i < pattern_len; i++, j++) {\n    if (pattern[i] == '?' && str[j] != '\\0') {\n      continue;\n    } else if (pattern[i] == '$') {\n      return str[j] == '\\0' ? j : -1;\n    } else if (pattern[i] == '*') {\n      i++;\n      if (pattern[i] == '*') {\n        i++;\n        len = (int) strlen(str + j);\n      } else {\n        len = (int) strcspn(str + j, \"/\");\n      }\n      if (i == pattern_len) {\n        return j + len;\n      }\n      do {\n        res = match_prefix(pattern + i, pattern_len - i, str + j + len);\n      } while (res == -1 && len-- > 0);\n      return res == -1 ? -1 : j + res + len;\n    } else if (pattern[i] != str[j]) {\n      return -1;\n    }\n  }\n  return j;\n}\n\n// HTTP 1.1 assumes keep alive if \"Connection:\" header is not set\n// This function must tolerate situations when connection info is not\n// set up, for example if request parsing failed.\nstatic int should_keep_alive(const struct mg_connection *conn) {\n  const char *http_version = conn->request_info.http_version;\n  const char *header = mg_get_header(conn, \"Connection\");\n  if (conn->must_close ||\n      conn->status_code == 401 ||\n      mg_strcasecmp(conn->ctx->config[ENABLE_KEEP_ALIVE], \"yes\") != 0 ||\n      (header != NULL && mg_strcasecmp(header, \"keep-alive\") != 0) ||\n      (header == NULL && http_version && strcmp(http_version, \"1.1\"))) {\n    return 0;\n  }\n  return 1;\n}\n\nstatic const char *suggest_connection_header(const struct mg_connection *conn) {\n  return should_keep_alive(conn) ? \"keep-alive\" : \"close\";\n}\n\nstatic void send_http_error(struct mg_connection *, int, const char *,\n                            PRINTF_FORMAT_STRING(const char *fmt), ...)\n  PRINTF_ARGS(4, 5);\n\n\nstatic void send_http_error(struct mg_connection *conn, int status,\n                            const char *reason, const char *fmt, ...) {\n  char buf[MG_BUF_LEN];\n  va_list ap;\n  int len = 0;\n\n  conn->status_code = status;\n  buf[0] = '\\0';\n\n  // Errors 1xx, 204 and 304 MUST NOT send a body\n  if (status > 199 && status != 204 && status != 304) {\n    len = mg_snprintf(conn, buf, sizeof(buf), \"Error %d: %s\", status, reason);\n    buf[len++] = '\\n';\n\n    va_start(ap, fmt);\n    len += mg_vsnprintf(conn, buf + len, sizeof(buf) - len, fmt, ap);\n    va_end(ap);\n  }\n  DEBUG_TRACE((\"[%s]\", buf));\n\n  mg_printf(conn, \"HTTP/1.1 %d %s\\r\\n\"\n            \"Content-Length: %d\\r\\n\"\n            \"Connection: %s\\r\\n\\r\\n\", status, reason, len,\n            suggest_connection_header(conn));\n  conn->num_bytes_sent += mg_printf(conn, \"%s\", buf);\n}\n\n#if defined(_WIN32) && !defined(__SYMBIAN32__)\nstatic int pthread_mutex_init(pthread_mutex_t *mutex, void *unused) {\n  unused = NULL;\n  *mutex = CreateMutex(NULL, FALSE, NULL);\n  return *mutex == NULL ? -1 : 0;\n}\n\nstatic int pthread_mutex_destroy(pthread_mutex_t *mutex) {\n  return CloseHandle(*mutex) == 0 ? -1 : 0;\n}\n\nstatic int pthread_mutex_lock(pthread_mutex_t *mutex) {\n  return WaitForSingleObject(*mutex, INFINITE) == WAIT_OBJECT_0? 0 : -1;\n}\n\nstatic int pthread_mutex_unlock(pthread_mutex_t *mutex) {\n  return ReleaseMutex(*mutex) == 0 ? -1 : 0;\n}\n\nstatic int pthread_cond_init(pthread_cond_t *cv, const void *unused) {\n  unused = NULL;\n  cv->signal = CreateEvent(NULL, FALSE, FALSE, NULL);\n  cv->broadcast = CreateEvent(NULL, TRUE, FALSE, NULL);\n  return cv->signal != NULL && cv->broadcast != NULL ? 0 : -1;\n}\n\nstatic int pthread_cond_wait(pthread_cond_t *cv, pthread_mutex_t *mutex) {\n  HANDLE handles[] = {cv->signal, cv->broadcast};\n  ReleaseMutex(*mutex);\n  WaitForMultipleObjects(2, handles, FALSE, INFINITE);\n  return WaitForSingleObject(*mutex, INFINITE) == WAIT_OBJECT_0? 0 : -1;\n}\n\nstatic int pthread_cond_signal(pthread_cond_t *cv) {\n  return SetEvent(cv->signal) == 0 ? -1 : 0;\n}\n\nstatic int pthread_cond_broadcast(pthread_cond_t *cv) {\n  // Implementation with PulseEvent() has race condition, see\n  // http://www.cs.wustl.edu/~schmidt/win32-cv-1.html\n  return PulseEvent(cv->broadcast) == 0 ? -1 : 0;\n}\n\nstatic int pthread_cond_destroy(pthread_cond_t *cv) {\n  return CloseHandle(cv->signal) && CloseHandle(cv->broadcast) ? 0 : -1;\n}\n\n// For Windows, change all slashes to backslashes in path names.\nstatic void change_slashes_to_backslashes(char *path) {\n  int i;\n\n  for (i = 0; path[i] != '\\0'; i++) {\n    if (path[i] == '/')\n      path[i] = '\\\\';\n    // i > 0 check is to preserve UNC paths, like \\\\server\\file.txt\n    if (path[i] == '\\\\' && i > 0)\n      while (path[i + 1] == '\\\\' || path[i + 1] == '/')\n        (void) memmove(path + i + 1,\n            path + i + 2, strlen(path + i + 1));\n  }\n}\n\n// Encode 'path' which is assumed UTF-8 string, into UNICODE string.\n// wbuf and wbuf_len is a target buffer and its length.\nstatic void to_unicode(const char *path, wchar_t *wbuf, size_t wbuf_len) {\n  char buf[PATH_MAX], buf2[PATH_MAX], *p;\n\n  mg_strlcpy(buf, path, sizeof(buf));\n  change_slashes_to_backslashes(buf);\n\n  // Point p to the end of the file name\n  p = buf + strlen(buf) - 1;\n\n  // Convert to Unicode and back. If doubly-converted string does not\n  // match the original, something is fishy, reject.\n  memset(wbuf, 0, wbuf_len * sizeof(wchar_t));\n  MultiByteToWideChar(CP_UTF8, 0, buf, -1, wbuf, (int) wbuf_len);\n  WideCharToMultiByte(CP_UTF8, 0, wbuf, (int) wbuf_len, buf2, sizeof(buf2),\n                      NULL, NULL);\n  if (strcmp(buf, buf2) != 0) {\n    wbuf[0] = L'\\0';\n  }\n}\n\n#if defined(_WIN32_WCE)\nstatic time_t time(time_t *ptime) {\n  time_t t;\n  SYSTEMTIME st;\n  FILETIME ft;\n\n  GetSystemTime(&st);\n  SystemTimeToFileTime(&st, &ft);\n  t = SYS2UNIX_TIME(ft.dwLowDateTime, ft.dwHighDateTime);\n\n  if (ptime != NULL) {\n    *ptime = t;\n  }\n\n  return t;\n}\n\nstatic struct tm *localtime(const time_t *ptime, struct tm *ptm) {\n  int64_t t = ((int64_t) *ptime) * RATE_DIFF + EPOCH_DIFF;\n  FILETIME ft, lft;\n  SYSTEMTIME st;\n  TIME_ZONE_INFORMATION tzinfo;\n\n  if (ptm == NULL) {\n    return NULL;\n  }\n\n  * (int64_t *) &ft = t;\n  FileTimeToLocalFileTime(&ft, &lft);\n  FileTimeToSystemTime(&lft, &st);\n  ptm->tm_year = st.wYear - 1900;\n  ptm->tm_mon = st.wMonth - 1;\n  ptm->tm_wday = st.wDayOfWeek;\n  ptm->tm_mday = st.wDay;\n  ptm->tm_hour = st.wHour;\n  ptm->tm_min = st.wMinute;\n  ptm->tm_sec = st.wSecond;\n  ptm->tm_yday = 0; // hope nobody uses this\n  ptm->tm_isdst =\n    GetTimeZoneInformation(&tzinfo) == TIME_ZONE_ID_DAYLIGHT ? 1 : 0;\n\n  return ptm;\n}\n\nstatic struct tm *gmtime(const time_t *ptime, struct tm *ptm) {\n  // FIXME(lsm): fix this.\n  return localtime(ptime, ptm);\n}\n\nstatic size_t strftime(char *dst, size_t dst_size, const char *fmt,\n                       const struct tm *tm) {\n  (void) snprintf(dst, dst_size, \"implement strftime() for WinCE\");\n  return 0;\n}\n#endif\n\nstatic int mg_rename(const char* oldname, const char* newname) {\n  wchar_t woldbuf[PATH_MAX];\n  wchar_t wnewbuf[PATH_MAX];\n\n  to_unicode(oldname, woldbuf, ARRAY_SIZE(woldbuf));\n  to_unicode(newname, wnewbuf, ARRAY_SIZE(wnewbuf));\n\n  return MoveFileW(woldbuf, wnewbuf) ? 0 : -1;\n}\n\n// Windows happily opens files with some garbage at the end of file name.\n// For example, fopen(\"a.cgi    \", \"r\") on Windows successfully opens\n// \"a.cgi\", despite one would expect an error back.\n// This function returns non-0 if path ends with some garbage.\nstatic int path_cannot_disclose_cgi(const char *path) {\n  static const char *allowed_last_characters = \"_-\";\n  int last = path[strlen(path) - 1];\n  return isalnum(last) || strchr(allowed_last_characters, last) != NULL;\n}\n\nstatic int mg_stat(struct mg_connection *conn, const char *path,\n                   struct file *filep) {\n  wchar_t wbuf[PATH_MAX];\n  WIN32_FILE_ATTRIBUTE_DATA info;\n\n  if (!is_file_in_memory(conn, path, filep)) {\n    to_unicode(path, wbuf, ARRAY_SIZE(wbuf));\n    if (GetFileAttributesExW(wbuf, GetFileExInfoStandard, &info) != 0) {\n      filep->size = MAKEUQUAD(info.nFileSizeLow, info.nFileSizeHigh);\n      filep->modification_time = SYS2UNIX_TIME(\n          info.ftLastWriteTime.dwLowDateTime,\n          info.ftLastWriteTime.dwHighDateTime);\n      filep->is_directory = info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY;\n      // If file name is fishy, reset the file structure and return error.\n      // Note it is important to reset, not just return the error, cause\n      // functions like is_file_opened() check the struct.\n      if (!filep->is_directory && !path_cannot_disclose_cgi(path)) {\n        memset(filep, 0, sizeof(*filep));\n      }\n    }\n  }\n\n  return filep->membuf != NULL || filep->modification_time != 0;\n}\n\nstatic int mg_remove(const char *path) {\n  wchar_t wbuf[PATH_MAX];\n  to_unicode(path, wbuf, ARRAY_SIZE(wbuf));\n  return DeleteFileW(wbuf) ? 0 : -1;\n}\n\nstatic int mg_mkdir(const char *path, int mode) {\n  char buf[PATH_MAX];\n  wchar_t wbuf[PATH_MAX];\n\n  mode = 0; // Unused\n  mg_strlcpy(buf, path, sizeof(buf));\n  change_slashes_to_backslashes(buf);\n\n  (void) MultiByteToWideChar(CP_UTF8, 0, buf, -1, wbuf, ARRAY_SIZE(wbuf));\n\n  return CreateDirectoryW(wbuf, NULL) ? 0 : -1;\n}\n\n// Implementation of POSIX opendir/closedir/readdir for Windows.\nstatic DIR * opendir(const char *name) {\n  DIR *dir = NULL;\n  wchar_t wpath[PATH_MAX];\n  DWORD attrs;\n\n  if (name == NULL) {\n    SetLastError(ERROR_BAD_ARGUMENTS);\n  } else if ((dir = (DIR *) malloc(sizeof(*dir))) == NULL) {\n    SetLastError(ERROR_NOT_ENOUGH_MEMORY);\n  } else {\n    to_unicode(name, wpath, ARRAY_SIZE(wpath));\n    attrs = GetFileAttributesW(wpath);\n    if (attrs != 0xFFFFFFFF &&\n        ((attrs & FILE_ATTRIBUTE_DIRECTORY) == FILE_ATTRIBUTE_DIRECTORY)) {\n      (void) wcscat(wpath, L\"\\\\*\");\n      dir->handle = FindFirstFileW(wpath, &dir->info);\n      dir->result.d_name[0] = '\\0';\n    } else {\n      free(dir);\n      dir = NULL;\n    }\n  }\n\n  return dir;\n}\n\nstatic int closedir(DIR *dir) {\n  int result = 0;\n\n  if (dir != NULL) {\n    if (dir->handle != INVALID_HANDLE_VALUE)\n      result = FindClose(dir->handle) ? 0 : -1;\n\n    free(dir);\n  } else {\n    result = -1;\n    SetLastError(ERROR_BAD_ARGUMENTS);\n  }\n\n  return result;\n}\n\nstatic struct dirent *readdir(DIR *dir) {\n  struct dirent *result = 0;\n\n  if (dir) {\n    if (dir->handle != INVALID_HANDLE_VALUE) {\n      result = &dir->result;\n      (void) WideCharToMultiByte(CP_UTF8, 0,\n          dir->info.cFileName, -1, result->d_name,\n          sizeof(result->d_name), NULL, NULL);\n\n      if (!FindNextFileW(dir->handle, &dir->info)) {\n        (void) FindClose(dir->handle);\n        dir->handle = INVALID_HANDLE_VALUE;\n      }\n\n    } else {\n      SetLastError(ERROR_FILE_NOT_FOUND);\n    }\n  } else {\n    SetLastError(ERROR_BAD_ARGUMENTS);\n  }\n\n  return result;\n}\n\n#ifndef HAVE_POLL\nstatic int poll(struct pollfd *pfd, int n, int milliseconds) {\n  struct timeval tv;\n  fd_set set;\n  int i, result;\n\n  tv.tv_sec = milliseconds / 1000;\n  tv.tv_usec = (milliseconds % 1000) * 1000;\n  FD_ZERO(&set);\n\n  for (i = 0; i < n; i++) {\n    FD_SET((SOCKET) pfd[i].fd, &set);\n    pfd[i].revents = 0;\n  }\n\n  if ((result = select(0, &set, NULL, NULL, &tv)) > 0) {\n    for (i = 0; i < n; i++) {\n      if (FD_ISSET(pfd[i].fd, &set)) {\n        pfd[i].revents = POLLIN;\n      }\n    }\n  }\n\n  return result;\n}\n#endif // HAVE_POLL\n\n#define set_close_on_exec(x) // No FD_CLOEXEC on Windows\n\nint mg_start_thread(mg_thread_func_t f, void *p) {\n  return _beginthread((void (__cdecl *)(void *)) f, 0, p) == -1L ? -1 : 0;\n}\n\nstatic HANDLE dlopen(const char *dll_name, int flags) {\n  wchar_t wbuf[PATH_MAX];\n  flags = 0; // Unused\n  to_unicode(dll_name, wbuf, ARRAY_SIZE(wbuf));\n  return LoadLibraryW(wbuf);\n}\n\n#if !defined(NO_CGI)\n#define SIGKILL 0\nstatic int kill(pid_t pid, int sig_num) {\n  (void) TerminateProcess(pid, sig_num);\n  (void) CloseHandle(pid);\n  return 0;\n}\n\nstatic void trim_trailing_whitespaces(char *s) {\n  char *e = s + strlen(s) - 1;\n  while (e > s && isspace(* (unsigned char *) e)) {\n    *e-- = '\\0';\n  }\n}\n\nstatic pid_t spawn_process(struct mg_connection *conn, const char *prog,\n                           char *envblk, char *envp[], int fd_stdin,\n                           int fd_stdout, const char *dir) {\n  HANDLE me;\n  char *p, *interp, full_interp[PATH_MAX], full_dir[PATH_MAX],\n       cmdline[PATH_MAX], buf[PATH_MAX];\n  struct file file = STRUCT_FILE_INITIALIZER;\n  STARTUPINFOA si = { sizeof(si) };\n  PROCESS_INFORMATION pi = { 0 };\n\n  envp = NULL; // Unused\n\n  // TODO(lsm): redirect CGI errors to the error log file\n  si.dwFlags = STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;\n  si.wShowWindow = SW_HIDE;\n\n  me = GetCurrentProcess();\n  DuplicateHandle(me, (HANDLE) _get_osfhandle(fd_stdin), me,\n                  &si.hStdInput, 0, TRUE, DUPLICATE_SAME_ACCESS);\n  DuplicateHandle(me, (HANDLE) _get_osfhandle(fd_stdout), me,\n                  &si.hStdOutput, 0, TRUE, DUPLICATE_SAME_ACCESS);\n\n  // If CGI file is a script, try to read the interpreter line\n  interp = conn->ctx->config[CGI_INTERPRETER];\n  if (interp == NULL) {\n    buf[0] = buf[1] = '\\0';\n\n    // Read the first line of the script into the buffer\n    snprintf(cmdline, sizeof(cmdline), \"%s%c%s\", dir, '/', prog);\n    if (mg_fopen(conn, cmdline, \"r\", &file)) {\n      p = (char *) file.membuf;\n      mg_fgets(buf, sizeof(buf), &file, &p);\n      mg_fclose(&file);\n      buf[sizeof(buf) - 1] = '\\0';\n    }\n\n    if (buf[0] == '#' && buf[1] == '!') {\n      trim_trailing_whitespaces(buf + 2);\n    } else {\n      buf[2] = '\\0';\n    }\n    interp = buf + 2;\n  }\n\n  if (interp[0] != '\\0') {\n    GetFullPathNameA(interp, sizeof(full_interp), full_interp, NULL);\n    interp = full_interp;\n  }\n  GetFullPathNameA(dir, sizeof(full_dir), full_dir, NULL);\n\n  mg_snprintf(conn, cmdline, sizeof(cmdline), \"%s%s%s\\\\%s\",\n              interp, interp[0] == '\\0' ? \"\" : \" \", full_dir, prog);\n\n  DEBUG_TRACE((\"Running [%s]\", cmdline));\n  if (CreateProcessA(NULL, cmdline, NULL, NULL, TRUE,\n        CREATE_NEW_PROCESS_GROUP, envblk, NULL, &si, &pi) == 0) {\n    cry(conn, \"%s: CreateProcess(%s): %d\",\n        __func__, cmdline, ERRNO);\n    pi.hProcess = (pid_t) -1;\n  }\n\n  // Always close these to prevent handle leakage.\n  (void) close(fd_stdin);\n  (void) close(fd_stdout);\n\n  (void) CloseHandle(si.hStdOutput);\n  (void) CloseHandle(si.hStdInput);\n  (void) CloseHandle(pi.hThread);\n\n  return (pid_t) pi.hProcess;\n}\n#endif // !NO_CGI\n\nstatic int set_non_blocking_mode(SOCKET sock) {\n  unsigned long on = 1;\n  return ioctlsocket(sock, FIONBIO, &on);\n}\n\n#else\nstatic int mg_stat(struct mg_connection *conn, const char *path,\n                   struct file *filep) {\n  struct stat st;\n\n  if (!is_file_in_memory(conn, path, filep) && !stat(path, &st)) {\n    filep->size = st.st_size;\n    filep->modification_time = st.st_mtime;\n    filep->is_directory = S_ISDIR(st.st_mode);\n  } else {\n    filep->modification_time = (time_t) 0;\n  }\n\n  return filep->membuf != NULL || filep->modification_time != (time_t) 0;\n}\n\nstatic void set_close_on_exec(int fd) {\n  fcntl(fd, F_SETFD, FD_CLOEXEC);\n}\n\nint mg_start_thread(mg_thread_func_t func, void *param) {\n  pthread_t thread_id;\n  pthread_attr_t attr;\n\n  (void) pthread_attr_init(&attr);\n  (void) pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n  // TODO(lsm): figure out why mongoose dies on Linux if next line is enabled\n  // (void) pthread_attr_setstacksize(&attr, sizeof(struct mg_connection) * 5);\n\n  return pthread_create(&thread_id, &attr, func, param);\n}\n\n#ifndef NO_CGI\nstatic pid_t spawn_process(struct mg_connection *conn, const char *prog,\n                           char *envblk, char *envp[], int fd_stdin,\n                           int fd_stdout, const char *dir) {\n  pid_t pid;\n  const char *interp;\n\n  (void) envblk;\n\n  if ((pid = fork()) == -1) {\n    // Parent\n    send_http_error(conn, 500, http_500_error, \"fork(): %s\", strerror(ERRNO));\n  } else if (pid == 0) {\n    // Child\n    if (chdir(dir) != 0) {\n      cry(conn, \"%s: chdir(%s): %s\", __func__, dir, strerror(ERRNO));\n    } else if (dup2(fd_stdin, 0) == -1) {\n      cry(conn, \"%s: dup2(%d, 0): %s\", __func__, fd_stdin, strerror(ERRNO));\n    } else if (dup2(fd_stdout, 1) == -1) {\n      cry(conn, \"%s: dup2(%d, 1): %s\", __func__, fd_stdout, strerror(ERRNO));\n    } else {\n      (void) dup2(fd_stdout, 2);\n      (void) close(fd_stdin);\n      (void) close(fd_stdout);\n\n      // After exec, all signal handlers are restored to their default values,\n      // with one exception of SIGCHLD. According to POSIX.1-2001 and Linux's\n      // implementation, SIGCHLD's handler will leave unchanged after exec\n      // if it was set to be ignored. Restore it to default action.\n      signal(SIGCHLD, SIG_DFL);\n\n      interp = conn->ctx->config[CGI_INTERPRETER];\n      if (interp == NULL) {\n        (void) execle(prog, prog, NULL, envp);\n        cry(conn, \"%s: execle(%s): %s\", __func__, prog, strerror(ERRNO));\n      } else {\n        (void) execle(interp, interp, prog, NULL, envp);\n        cry(conn, \"%s: execle(%s %s): %s\", __func__, interp, prog,\n            strerror(ERRNO));\n      }\n    }\n    exit(EXIT_FAILURE);\n  }\n\n  // Parent. Close stdio descriptors\n  (void) close(fd_stdin);\n  (void) close(fd_stdout);\n\n  return pid;\n}\n#endif // !NO_CGI\n\nstatic int set_non_blocking_mode(SOCKET sock) {\n  int flags;\n\n  flags = fcntl(sock, F_GETFL, 0);\n  (void) fcntl(sock, F_SETFL, flags | O_NONBLOCK);\n\n  return 0;\n}\n#endif // _WIN32\n\n// Write data to the IO channel - opened file descriptor, socket or SSL\n// descriptor. Return number of bytes written.\nstatic int64_t push(FILE *fp, SOCKET sock, SSL *ssl, const char *buf,\n                    int64_t len) {\n  int64_t sent;\n  int n, k;\n\n  sent = 0;\n  while (sent < len) {\n\n    // How many bytes we send in this iteration\n    k = len - sent > INT_MAX ? INT_MAX : (int) (len - sent);\n\n#ifndef NO_SSL\n    if (ssl != NULL) {\n      n = SSL_write(ssl, buf + sent, k);\n    } else\n#endif\n      if (fp != NULL) {\n      n = (int) fwrite(buf + sent, 1, (size_t) k, fp);\n      if (ferror(fp))\n        n = -1;\n    } else {\n      n = send(sock, buf + sent, (size_t) k, MSG_NOSIGNAL);\n    }\n\n    if (n <= 0)\n      break;\n\n    sent += n;\n  }\n\n  return sent;\n}\n\n// Read from IO channel - opened file descriptor, socket, or SSL descriptor.\n// Return negative value on error, or number of bytes read on success.\nstatic int pull(FILE *fp, struct mg_connection *conn, char *buf, int len) {\n  int nread;\n\n  if (fp != NULL) {\n    // Use read() instead of fread(), because if we're reading from the CGI\n    // pipe, fread() may block until IO buffer is filled up. We cannot afford\n    // to block and must pass all read bytes immediately to the client.\n    nread = read(fileno(fp), buf, (size_t) len);\n#ifndef NO_SSL\n  } else if (conn->ssl != NULL) {\n    nread = SSL_read(conn->ssl, buf, len);\n#endif\n  } else {\n    nread = recv(conn->client.sock, buf, (size_t) len, 0);\n  }\n\n  return conn->ctx->stop_flag ? -1 : nread;\n}\n\nint mg_read(struct mg_connection *conn, void *buf, size_t len) {\n  int n, buffered_len, nread;\n  const char *body;\n\n  nread = 0;\n  if (conn->consumed_content < conn->content_len) {\n    // Adjust number of bytes to read.\n    int64_t to_read = conn->content_len - conn->consumed_content;\n    if (to_read < (int64_t) len) {\n      len = (size_t) to_read;\n    }\n\n    // Return buffered data\n    body = conn->buf + conn->request_len + conn->consumed_content;\n    buffered_len = &conn->buf[conn->data_len] - body;\n    if (buffered_len > 0) {\n      if (len < (size_t) buffered_len) {\n        buffered_len = (int) len;\n      }\n      memcpy(buf, body, (size_t) buffered_len);\n      len -= buffered_len;\n      conn->consumed_content += buffered_len;\n      nread += buffered_len;\n      buf = (char *) buf + buffered_len;\n    }\n\n    // We have returned all buffered data. Read new data from the remote socket.\n    while (len > 0) {\n      n = pull(NULL, conn, (char *) buf, (int) len);\n      if (n < 0) {\n        nread = n;  // Propagate the error\n        break;\n      } else if (n == 0) {\n        break;  // No more data to read\n      } else {\n        buf = (char *) buf + n;\n        conn->consumed_content += n;\n        nread += n;\n        len -= n;\n      }\n    }\n  }\n  return nread;\n}\n\nint mg_write(struct mg_connection *conn, const void *buf, size_t len) {\n  time_t now;\n  int64_t n, total, allowed;\n\n  if (conn->throttle > 0) {\n    if ((now = time(NULL)) != conn->last_throttle_time) {\n      conn->last_throttle_time = now;\n      conn->last_throttle_bytes = 0;\n    }\n    allowed = conn->throttle - conn->last_throttle_bytes;\n    if (allowed > (int64_t) len) {\n      allowed = len;\n    }\n    if ((total = push(NULL, conn->client.sock, conn->ssl, (const char *) buf,\n                      (int64_t) allowed)) == allowed) {\n      buf = (char *) buf + total;\n      conn->last_throttle_bytes += total;\n      while (total < (int64_t) len && conn->ctx->stop_flag == 0) {\n        allowed = conn->throttle > (int64_t) len - total ?\n          (int64_t) len - total : conn->throttle;\n        if ((n = push(NULL, conn->client.sock, conn->ssl, (const char *) buf,\n                      (int64_t) allowed)) != allowed) {\n          break;\n        }\n        sleep(1);\n        conn->last_throttle_bytes = allowed;\n        conn->last_throttle_time = time(NULL);\n        buf = (char *) buf + n;\n        total += n;\n      }\n    }\n  } else {\n    total = push(NULL, conn->client.sock, conn->ssl, (const char *) buf,\n                 (int64_t) len);\n  }\n  return (int) total;\n}\n\n// Print message to buffer. If buffer is large enough to hold the message,\n// return buffer. If buffer is to small, allocate large enough buffer on heap,\n// and return allocated buffer.\nstatic int alloc_vprintf(char **buf, size_t size, const char *fmt, va_list ap) {\n  va_list ap_copy;\n  int len;\n\n  // Windows is not standard-compliant, and vsnprintf() returns -1 if\n  // buffer is too small. Also, older versions of msvcrt.dll do not have\n  // _vscprintf().  However, if size is 0, vsnprintf() behaves correctly.\n  // Therefore, we make two passes: on first pass, get required message length.\n  // On second pass, actually print the message.\n  va_copy(ap_copy, ap);\n  len = vsnprintf(NULL, 0, fmt, ap_copy);\n\n  if (len > (int) size &&\n      (size = len + 1) > 0 &&\n      (*buf = (char *) malloc(size)) == NULL) {\n    len = -1;  // Allocation failed, mark failure\n  } else {\n    va_copy(ap_copy, ap);\n    vsnprintf(*buf, size, fmt, ap_copy);\n  }\n\n  return len;\n}\n\nint mg_vprintf(struct mg_connection *conn, const char *fmt, va_list ap) {\n  char mem[MG_BUF_LEN], *buf = mem;\n  int len;\n\n  if ((len = alloc_vprintf(&buf, sizeof(mem), fmt, ap)) > 0) {\n    len = mg_write(conn, buf, (size_t) len);\n  }\n  if (buf != mem && buf != NULL) {\n    free(buf);\n  }\n\n  return len;\n}\n\nint mg_printf(struct mg_connection *conn, const char *fmt, ...) {\n  va_list ap;\n  va_start(ap, fmt);\n  return mg_vprintf(conn, fmt, ap);\n}\n\n// URL-decode input buffer into destination buffer.\n// 0-terminate the destination buffer. Return the length of decoded data.\n// form-url-encoded data differs from URI encoding in a way that it\n// uses '+' as character for space, see RFC 1866 section 8.2.1\n// http://ftp.ics.uci.edu/pub/ietf/html/rfc1866.txt\nstatic int url_decode(const char *src, int src_len, char *dst,\n                      int dst_len, int is_form_url_encoded) {\n  int i, j, a, b;\n#define HEXTOI(x) (isdigit(x) ? x - '0' : x - 'W')\n\n  for (i = j = 0; i < src_len && j < dst_len - 1; i++, j++) {\n    if (src[i] == '%' &&\n        isxdigit(* (const unsigned char *) (src + i + 1)) &&\n        isxdigit(* (const unsigned char *) (src + i + 2))) {\n      a = tolower(* (const unsigned char *) (src + i + 1));\n      b = tolower(* (const unsigned char *) (src + i + 2));\n      dst[j] = (char) ((HEXTOI(a) << 4) | HEXTOI(b));\n      i += 2;\n    } else if (is_form_url_encoded && src[i] == '+') {\n      dst[j] = ' ';\n    } else {\n      dst[j] = src[i];\n    }\n  }\n\n  dst[j] = '\\0'; // Null-terminate the destination\n\n  return i >= src_len ? j : -1;\n}\n\nint mg_get_var(const char *data, size_t data_len, const char *name,\n               char *dst, size_t dst_len) {\n  const char *p, *e, *s;\n  size_t name_len;\n  int len;\n\n  if (dst == NULL || dst_len == 0) {\n    len = -2;\n  } else if (data == NULL || name == NULL || data_len == 0) {\n    len = -1;\n    dst[0] = '\\0';\n  } else {\n    name_len = strlen(name);\n    e = data + data_len;\n    len = -1;\n    dst[0] = '\\0';\n\n    // data is \"var1=val1&var2=val2...\". Find variable first\n    for (p = data; p + name_len < e; p++) {\n      if ((p == data || p[-1] == '&') && p[name_len] == '=' &&\n          !mg_strncasecmp(name, p, name_len)) {\n\n        // Point p to variable value\n        p += name_len + 1;\n\n        // Point s to the end of the value\n        s = (const char *) memchr(p, '&', (size_t)(e - p));\n        if (s == NULL) {\n          s = e;\n        }\n        assert(s >= p);\n\n        // Decode variable into destination buffer\n        len = url_decode(p, (size_t)(s - p), dst, dst_len, 1);\n\n        // Redirect error code from -1 to -2 (destination buffer too small).\n        if (len == -1) {\n          len = -2;\n        }\n        break;\n      }\n    }\n  }\n\n  return len;\n}\n\nint mg_get_cookie(const struct mg_connection *conn, const char *cookie_name,\n                  char *dst, size_t dst_size) {\n  const char *s, *p, *end;\n  int name_len, len = -1;\n\n  if (dst == NULL || dst_size == 0) {\n      len = -2;\n  } else if (cookie_name == NULL || (s = mg_get_header(conn, \"Cookie\")) == NULL) {\n      len = -1;\n      dst[0] = '\\0';\n  } else {\n    name_len = (int) strlen(cookie_name);\n    end = s + strlen(s);\n    dst[0] = '\\0';\n\n    for (; (s = strstr(s, cookie_name)) != NULL; s += name_len) {\n      if (s[name_len] == '=') {\n        s += name_len + 1;\n        if ((p = strchr(s, ' ')) == NULL)\n          p = end;\n        if (p[-1] == ';')\n          p--;\n        if (*s == '\"' && p[-1] == '\"' && p > s + 1) {\n          s++;\n          p--;\n        }\n        if ((size_t) (p - s) < dst_size) {\n          len = p - s;\n          mg_strlcpy(dst, s, (size_t) len + 1);\n        } else {\n          len = -2;\n        }\n        break;\n      }\n    }\n  }\n  return len;\n}\n\nchar* mg_document_roots[10];\nint mg_number_document_roots = 0;\n\nstatic void convert_uri_to_file_name(struct mg_connection *conn, char *buf,\n                                     size_t buf_len, struct file *filep) {\n  struct vec a, b;\n  const char *rewrite, *uri = conn->request_info.uri;\n  char *p;\n  int match_len;\n  int i;\n\n  for (i=-1; i<mg_number_document_roots; i++) {\n\n    // Using buf_len - 1 because memmove() for PATH_INFO may shift part\n    // of the path one byte on the right.\n    if (i==-1) mg_snprintf(conn, buf, buf_len - 1, \"%s%s\", conn->ctx->config[DOCUMENT_ROOT],uri);\n    else mg_snprintf(conn, buf, buf_len - 1, \"%s%s\",mg_document_roots[i] ,uri);\n\n    rewrite = conn->ctx->config[REWRITE];\n    while ((rewrite = next_option(rewrite, &a, &b)) != NULL) {\n      if ((match_len = match_prefix(a.ptr, a.len, uri)) > 0) {\n\tmg_snprintf(conn, buf, buf_len - 1, \"%.*s%s\", (int) b.len, b.ptr,uri + match_len);\n\tbreak;\n      }\n    }\n    if (mg_stat(conn, buf, filep)) return;\n  }\n\t\t\t\t   \n  if (!mg_stat(conn, buf, filep)) {\n    // Support PATH_INFO for CGI scripts.\n    for (p = buf + strlen(buf); p > buf + 1; p--) {\n      if (*p == '/') {\n        *p = '\\0';\n        if (match_prefix(conn->ctx->config[CGI_EXTENSIONS],\n                         strlen(conn->ctx->config[CGI_EXTENSIONS]), buf) > 0 &&\n            mg_stat(conn, buf, filep)) {\n          // Shift PATH_INFO block one character right, e.g.\n          //  \"/x.cgi/foo/bar\\x00\" => \"/x.cgi\\x00/foo/bar\\x00\"\n          // conn->path_info is pointing to the local variable \"path\" declared\n          // in handle_request(), so PATH_INFO is not valid after\n          // handle_request returns.\n          conn->path_info = p + 1;\n          memmove(p + 2, p + 1, strlen(p + 1) + 1);  // +1 is for trailing \\0\n          p[1] = '/';\n          break;\n        } else {\n          *p = '/';\n        }\n      }\n    }\n  }\n}\n\n// Check whether full request is buffered. Return:\n//   -1  if request is malformed\n//    0  if request is not yet fully buffered\n//   >0  actual request length, including last \\r\\n\\r\\n\nstatic int get_request_len(const char *buf, int buflen) {\n  const char *s, *e;\n  int len = 0;\n\n  for (s = buf, e = s + buflen - 1; len <= 0 && s < e; s++)\n    // Control characters are not allowed but >=128 is.\n    if (!isprint(* (const unsigned char *) s) && *s != '\\r' &&\n        *s != '\\n' && * (const unsigned char *) s < 128) {\n      len = -1;\n      break;  // [i_a] abort scan as soon as one malformed character is found;\n              // don't let subsequent \\r\\n\\r\\n win us over anyhow\n    } else if (s[0] == '\\n' && s[1] == '\\n') {\n      len = (int) (s - buf) + 2;\n    } else if (s[0] == '\\n' && &s[1] < e &&\n        s[1] == '\\r' && s[2] == '\\n') {\n      len = (int) (s - buf) + 3;\n    }\n\n  return len;\n}\n\n// Convert month to the month number. Return -1 on error, or month number\nstatic int get_month_index(const char *s) {\n  size_t i;\n\n  for (i = 0; i < ARRAY_SIZE(month_names); i++)\n    if (!strcmp(s, month_names[i]))\n      return (int) i;\n\n  return -1;\n}\n\nstatic int num_leap_years(int year) {\n  return year / 4 - year / 100 + year / 400;\n}\n\n// Parse UTC date-time string, and return the corresponding time_t value.\nstatic time_t parse_date_string(const char *datetime) {\n  static const unsigned short days_before_month[] = {\n    0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334\n  };\n  char month_str[32];\n  int second, minute, hour, day, month, year, leap_days, days;\n  time_t result = (time_t) 0;\n\n  if (((sscanf(datetime, \"%d/%3s/%d %d:%d:%d\",\n               &day, month_str, &year, &hour, &minute, &second) == 6) ||\n       (sscanf(datetime, \"%d %3s %d %d:%d:%d\",\n               &day, month_str, &year, &hour, &minute, &second) == 6) ||\n       (sscanf(datetime, \"%*3s, %d %3s %d %d:%d:%d\",\n               &day, month_str, &year, &hour, &minute, &second) == 6) ||\n       (sscanf(datetime, \"%d-%3s-%d %d:%d:%d\",\n               &day, month_str, &year, &hour, &minute, &second) == 6)) &&\n      year > 1970 &&\n      (month = get_month_index(month_str)) != -1) {\n    leap_days = num_leap_years(year) - num_leap_years(1970);\n    year -= 1970;\n    days = year * 365 + days_before_month[month] + (day - 1) + leap_days;\n    result = days * 24 * 3600 + hour * 3600 + minute * 60 + second;\n  }\n\n  return result;\n}\n\n// Protect against directory disclosure attack by removing '..',\n// excessive '/' and '\\' characters\nstatic void remove_double_dots_and_double_slashes(char *s) {\n  char *p = s;\n\n  while (*s != '\\0') {\n    *p++ = *s++;\n    if (s[-1] == '/' || s[-1] == '\\\\') {\n      // Skip all following slashes, backslashes and double-dots\n      while (s[0] != '\\0') {\n        if (s[0] == '/' || s[0] == '\\\\') {\n          s++;\n        } else if (s[0] == '.' && s[1] == '.') {\n          s += 2;\n        } else {\n          break;\n        }\n      }\n    }\n  }\n  *p = '\\0';\n}\n\nstatic const struct {\n  const char *extension;\n  size_t ext_len;\n  const char *mime_type;\n} builtin_mime_types[] = {\n  {\".html\", 5, \"text/html\"},\n  {\".htm\", 4, \"text/html\"},\n  {\".shtm\", 5, \"text/html\"},\n  {\".shtml\", 6, \"text/html\"},\n  {\".css\", 4, \"text/css\"},\n  {\".js\",  3, \"application/x-javascript\"},\n  {\".ico\", 4, \"image/x-icon\"},\n  {\".gif\", 4, \"image/gif\"},\n  {\".jpg\", 4, \"image/jpeg\"},\n  {\".jpeg\", 5, \"image/jpeg\"},\n  {\".png\", 4, \"image/png\"},\n  {\".svg\", 4, \"image/svg+xml\"},\n  {\".txt\", 4, \"text/plain\"},\n  {\".torrent\", 8, \"application/x-bittorrent\"},\n  {\".wav\", 4, \"audio/x-wav\"},\n  {\".mp3\", 4, \"audio/x-mp3\"},\n  {\".mid\", 4, \"audio/mid\"},\n  {\".m3u\", 4, \"audio/x-mpegurl\"},\n  {\".ogg\", 4, \"audio/ogg\"},\n  {\".ram\", 4, \"audio/x-pn-realaudio\"},\n  {\".xml\", 4, \"text/xml\"},\n  {\".json\",  5, \"text/json\"},\n  {\".xslt\", 5, \"application/xml\"},\n  {\".xsl\", 4, \"application/xml\"},\n  {\".ra\",  3, \"audio/x-pn-realaudio\"},\n  {\".doc\", 4, \"application/msword\"},\n  {\".exe\", 4, \"application/octet-stream\"},\n  {\".zip\", 4, \"application/x-zip-compressed\"},\n  {\".xls\", 4, \"application/excel\"},\n  {\".tgz\", 4, \"application/x-tar-gz\"},\n  {\".tar\", 4, \"application/x-tar\"},\n  {\".gz\",  3, \"application/x-gunzip\"},\n  {\".arj\", 4, \"application/x-arj-compressed\"},\n  {\".rar\", 4, \"application/x-arj-compressed\"},\n  {\".rtf\", 4, \"application/rtf\"},\n  {\".pdf\", 4, \"application/pdf\"},\n  {\".swf\", 4, \"application/x-shockwave-flash\"},\n  {\".mpg\", 4, \"video/mpeg\"},\n  {\".webm\", 5, \"video/webm\"},\n  {\".mpeg\", 5, \"video/mpeg\"},\n  {\".mp4\", 4, \"video/mp4\"},\n  {\".m4v\", 4, \"video/x-m4v\"},\n  {\".asf\", 4, \"video/x-ms-asf\"},\n  {\".avi\", 4, \"video/x-msvideo\"},\n  {\".bmp\", 4, \"image/bmp\"},\n  {NULL,  0, NULL}\n};\n\nconst char *mg_get_builtin_mime_type(const char *path) {\n  const char *ext;\n  size_t i, path_len;\n\n  path_len = strlen(path);\n\n  for (i = 0; builtin_mime_types[i].extension != NULL; i++) {\n    ext = path + (path_len - builtin_mime_types[i].ext_len);\n    if (path_len > builtin_mime_types[i].ext_len &&\n        mg_strcasecmp(ext, builtin_mime_types[i].extension) == 0) {\n      return builtin_mime_types[i].mime_type;\n    }\n  }\n\n  return \"text/plain\";\n}\n\n// Look at the \"path\" extension and figure what mime type it has.\n// Store mime type in the vector.\nstatic void get_mime_type(struct mg_context *ctx, const char *path,\n                          struct vec *vec) {\n  struct vec ext_vec, mime_vec;\n  const char *list, *ext;\n  size_t path_len;\n\n  path_len = strlen(path);\n\n  // Scan user-defined mime types first, in case user wants to\n  // override default mime types.\n  list = ctx->config[EXTRA_MIME_TYPES];\n  while ((list = next_option(list, &ext_vec, &mime_vec)) != NULL) {\n    // ext now points to the path suffix\n    ext = path + path_len - ext_vec.len;\n    if (mg_strncasecmp(ext, ext_vec.ptr, ext_vec.len) == 0) {\n      *vec = mime_vec;\n      return;\n    }\n  }\n\n  vec->ptr = mg_get_builtin_mime_type(path);\n  vec->len = strlen(vec->ptr);\n}\n\nstatic int is_big_endian(void) {\n  static const int n = 1;\n  return ((char *) &n)[0] == 0;\n}\n\n#ifndef HAVE_MD5\ntypedef struct MD5Context {\n  uint32_t buf[4];\n  uint32_t bits[2];\n  unsigned char in[64];\n} MD5_CTX;\n\nstatic void byteReverse(unsigned char *buf, unsigned longs) {\n  uint32_t t;\n\n  // Forrest: MD5 expect LITTLE_ENDIAN, swap if BIG_ENDIAN\n  if (is_big_endian()) {\n    do {\n      t = (uint32_t) ((unsigned) buf[3] << 8 | buf[2]) << 16 |\n        ((unsigned) buf[1] << 8 | buf[0]);\n      * (uint32_t *) buf = t;\n      buf += 4;\n    } while (--longs);\n  }\n}\n\n#define F1(x, y, z) (z ^ (x & (y ^ z)))\n#define F2(x, y, z) F1(z, x, y)\n#define F3(x, y, z) (x ^ y ^ z)\n#define F4(x, y, z) (y ^ (x | ~z))\n\n#define MD5STEP(f, w, x, y, z, data, s) \\\n  ( w += f(x, y, z) + data,  w = w<<s | w>>(32-s),  w += x )\n\n// Start MD5 accumulation.  Set bit count to 0 and buffer to mysterious\n// initialization constants.\nstatic void MD5Init(MD5_CTX *ctx) {\n  ctx->buf[0] = 0x67452301;\n  ctx->buf[1] = 0xefcdab89;\n  ctx->buf[2] = 0x98badcfe;\n  ctx->buf[3] = 0x10325476;\n\n  ctx->bits[0] = 0;\n  ctx->bits[1] = 0;\n}\n\nstatic void MD5Transform(uint32_t buf[4], uint32_t const in[16]) {\n  register uint32_t a, b, c, d;\n\n  a = buf[0];\n  b = buf[1];\n  c = buf[2];\n  d = buf[3];\n\n  MD5STEP(F1, a, b, c, d, in[0] + 0xd76aa478, 7);\n  MD5STEP(F1, d, a, b, c, in[1] + 0xe8c7b756, 12);\n  MD5STEP(F1, c, d, a, b, in[2] + 0x242070db, 17);\n  MD5STEP(F1, b, c, d, a, in[3] + 0xc1bdceee, 22);\n  MD5STEP(F1, a, b, c, d, in[4] + 0xf57c0faf, 7);\n  MD5STEP(F1, d, a, b, c, in[5] + 0x4787c62a, 12);\n  MD5STEP(F1, c, d, a, b, in[6] + 0xa8304613, 17);\n  MD5STEP(F1, b, c, d, a, in[7] + 0xfd469501, 22);\n  MD5STEP(F1, a, b, c, d, in[8] + 0x698098d8, 7);\n  MD5STEP(F1, d, a, b, c, in[9] + 0x8b44f7af, 12);\n  MD5STEP(F1, c, d, a, b, in[10] + 0xffff5bb1, 17);\n  MD5STEP(F1, b, c, d, a, in[11] + 0x895cd7be, 22);\n  MD5STEP(F1, a, b, c, d, in[12] + 0x6b901122, 7);\n  MD5STEP(F1, d, a, b, c, in[13] + 0xfd987193, 12);\n  MD5STEP(F1, c, d, a, b, in[14] + 0xa679438e, 17);\n  MD5STEP(F1, b, c, d, a, in[15] + 0x49b40821, 22);\n\n  MD5STEP(F2, a, b, c, d, in[1] + 0xf61e2562, 5);\n  MD5STEP(F2, d, a, b, c, in[6] + 0xc040b340, 9);\n  MD5STEP(F2, c, d, a, b, in[11] + 0x265e5a51, 14);\n  MD5STEP(F2, b, c, d, a, in[0] + 0xe9b6c7aa, 20);\n  MD5STEP(F2, a, b, c, d, in[5] + 0xd62f105d, 5);\n  MD5STEP(F2, d, a, b, c, in[10] + 0x02441453, 9);\n  MD5STEP(F2, c, d, a, b, in[15] + 0xd8a1e681, 14);\n  MD5STEP(F2, b, c, d, a, in[4] + 0xe7d3fbc8, 20);\n  MD5STEP(F2, a, b, c, d, in[9] + 0x21e1cde6, 5);\n  MD5STEP(F2, d, a, b, c, in[14] + 0xc33707d6, 9);\n  MD5STEP(F2, c, d, a, b, in[3] + 0xf4d50d87, 14);\n  MD5STEP(F2, b, c, d, a, in[8] + 0x455a14ed, 20);\n  MD5STEP(F2, a, b, c, d, in[13] + 0xa9e3e905, 5);\n  MD5STEP(F2, d, a, b, c, in[2] + 0xfcefa3f8, 9);\n  MD5STEP(F2, c, d, a, b, in[7] + 0x676f02d9, 14);\n  MD5STEP(F2, b, c, d, a, in[12] + 0x8d2a4c8a, 20);\n\n  MD5STEP(F3, a, b, c, d, in[5] + 0xfffa3942, 4);\n  MD5STEP(F3, d, a, b, c, in[8] + 0x8771f681, 11);\n  MD5STEP(F3, c, d, a, b, in[11] + 0x6d9d6122, 16);\n  MD5STEP(F3, b, c, d, a, in[14] + 0xfde5380c, 23);\n  MD5STEP(F3, a, b, c, d, in[1] + 0xa4beea44, 4);\n  MD5STEP(F3, d, a, b, c, in[4] + 0x4bdecfa9, 11);\n  MD5STEP(F3, c, d, a, b, in[7] + 0xf6bb4b60, 16);\n  MD5STEP(F3, b, c, d, a, in[10] + 0xbebfbc70, 23);\n  MD5STEP(F3, a, b, c, d, in[13] + 0x289b7ec6, 4);\n  MD5STEP(F3, d, a, b, c, in[0] + 0xeaa127fa, 11);\n  MD5STEP(F3, c, d, a, b, in[3] + 0xd4ef3085, 16);\n  MD5STEP(F3, b, c, d, a, in[6] + 0x04881d05, 23);\n  MD5STEP(F3, a, b, c, d, in[9] + 0xd9d4d039, 4);\n  MD5STEP(F3, d, a, b, c, in[12] + 0xe6db99e5, 11);\n  MD5STEP(F3, c, d, a, b, in[15] + 0x1fa27cf8, 16);\n  MD5STEP(F3, b, c, d, a, in[2] + 0xc4ac5665, 23);\n\n  MD5STEP(F4, a, b, c, d, in[0] + 0xf4292244, 6);\n  MD5STEP(F4, d, a, b, c, in[7] + 0x432aff97, 10);\n  MD5STEP(F4, c, d, a, b, in[14] + 0xab9423a7, 15);\n  MD5STEP(F4, b, c, d, a, in[5] + 0xfc93a039, 21);\n  MD5STEP(F4, a, b, c, d, in[12] + 0x655b59c3, 6);\n  MD5STEP(F4, d, a, b, c, in[3] + 0x8f0ccc92, 10);\n  MD5STEP(F4, c, d, a, b, in[10] + 0xffeff47d, 15);\n  MD5STEP(F4, b, c, d, a, in[1] + 0x85845dd1, 21);\n  MD5STEP(F4, a, b, c, d, in[8] + 0x6fa87e4f, 6);\n  MD5STEP(F4, d, a, b, c, in[15] + 0xfe2ce6e0, 10);\n  MD5STEP(F4, c, d, a, b, in[6] + 0xa3014314, 15);\n  MD5STEP(F4, b, c, d, a, in[13] + 0x4e0811a1, 21);\n  MD5STEP(F4, a, b, c, d, in[4] + 0xf7537e82, 6);\n  MD5STEP(F4, d, a, b, c, in[11] + 0xbd3af235, 10);\n  MD5STEP(F4, c, d, a, b, in[2] + 0x2ad7d2bb, 15);\n  MD5STEP(F4, b, c, d, a, in[9] + 0xeb86d391, 21);\n\n  buf[0] += a;\n  buf[1] += b;\n  buf[2] += c;\n  buf[3] += d;\n}\n\nstatic void MD5Update(MD5_CTX *ctx, unsigned char const *buf, unsigned len) {\n  uint32_t t;\n\n  t = ctx->bits[0];\n  if ((ctx->bits[0] = t + ((uint32_t) len << 3)) < t)\n    ctx->bits[1]++;\n  ctx->bits[1] += len >> 29;\n\n  t = (t >> 3) & 0x3f;\n\n  if (t) {\n    unsigned char *p = (unsigned char *) ctx->in + t;\n\n    t = 64 - t;\n    if (len < t) {\n      memcpy(p, buf, len);\n      return;\n    }\n    memcpy(p, buf, t);\n    byteReverse(ctx->in, 16);\n    MD5Transform(ctx->buf, (uint32_t *) ctx->in);\n    buf += t;\n    len -= t;\n  }\n\n  while (len >= 64) {\n    memcpy(ctx->in, buf, 64);\n    byteReverse(ctx->in, 16);\n    MD5Transform(ctx->buf, (uint32_t *) ctx->in);\n    buf += 64;\n    len -= 64;\n  }\n\n  memcpy(ctx->in, buf, len);\n}\n\nstatic void MD5Final(unsigned char digest[16], MD5_CTX *ctx) {\n  unsigned count;\n  unsigned char *p;\n\n  count = (ctx->bits[0] >> 3) & 0x3F;\n\n  p = ctx->in + count;\n  *p++ = 0x80;\n  count = 64 - 1 - count;\n  if (count < 8) {\n    memset(p, 0, count);\n    byteReverse(ctx->in, 16);\n    MD5Transform(ctx->buf, (uint32_t *) ctx->in);\n    memset(ctx->in, 0, 56);\n  } else {\n    memset(p, 0, count - 8);\n  }\n  byteReverse(ctx->in, 14);\n\n  ((uint32_t *) ctx->in)[14] = ctx->bits[0];\n  ((uint32_t *) ctx->in)[15] = ctx->bits[1];\n\n  MD5Transform(ctx->buf, (uint32_t *) ctx->in);\n  byteReverse((unsigned char *) ctx->buf, 4);\n  memcpy(digest, ctx->buf, 16);\n  memset((char *) ctx, 0, sizeof(*ctx));\n}\n#endif // !HAVE_MD5\n\n// Stringify binary data. Output buffer must be twice as big as input,\n// because each byte takes 2 bytes in string representation\nstatic void bin2str(char *to, const unsigned char *p, size_t len) {\n  static const char *hex = \"0123456789abcdef\";\n\n  for (; len--; p++) {\n    *to++ = hex[p[0] >> 4];\n    *to++ = hex[p[0] & 0x0f];\n  }\n  *to = '\\0';\n}\n\n// Return stringified MD5 hash for list of strings. Buffer must be 33 bytes.\nvoid mg_md5(char buf[33], ...) {\n  unsigned char hash[16];\n  const char *p;\n  va_list ap;\n  MD5_CTX ctx;\n\n  MD5Init(&ctx);\n\n  va_start(ap, buf);\n  while ((p = va_arg(ap, const char *)) != NULL) {\n    MD5Update(&ctx, (const unsigned char *) p, (unsigned) strlen(p));\n  }\n  va_end(ap);\n\n  MD5Final(hash, &ctx);\n  bin2str(buf, hash, sizeof(hash));\n}\n\n// Check the user's password, return 1 if OK\nstatic int check_password(const char *method, const char *ha1, const char *uri,\n                          const char *nonce, const char *nc, const char *cnonce,\n                          const char *qop, const char *response) {\n  char ha2[32 + 1], expected_response[32 + 1];\n\n  // Some of the parameters may be NULL\n  if (method == NULL || nonce == NULL || nc == NULL || cnonce == NULL ||\n      qop == NULL || response == NULL) {\n    return 0;\n  }\n\n  // NOTE(lsm): due to a bug in MSIE, we do not compare the URI\n  // TODO(lsm): check for authentication timeout\n  if (// strcmp(dig->uri, c->ouri) != 0 ||\n      strlen(response) != 32\n      // || now - strtoul(dig->nonce, NULL, 10) > 3600\n      ) {\n    return 0;\n  }\n\n  mg_md5(ha2, method, \":\", uri, NULL);\n  mg_md5(expected_response, ha1, \":\", nonce, \":\", nc,\n      \":\", cnonce, \":\", qop, \":\", ha2, NULL);\n\n  return mg_strcasecmp(response, expected_response) == 0;\n}\n\n// Use the global passwords file, if specified by auth_gpass option,\n// or search for .htpasswd in the requested directory.\nstatic void open_auth_file(struct mg_connection *conn, const char *path,\n                           struct file *filep) {\n  char name[PATH_MAX];\n  const char *p, *e, *gpass = conn->ctx->config[GLOBAL_PASSWORDS_FILE];\n\n  if (gpass != NULL) {\n    // Use global passwords file\n    if (!mg_fopen(conn, gpass, \"r\", filep)) {\n      cry(conn, \"fopen(%s): %s\", gpass, strerror(ERRNO));\n    }\n  } else if (mg_stat(conn, path, filep) && filep->is_directory) {\n    mg_snprintf(conn, name, sizeof(name), \"%s%c%s\",\n                path, '/', PASSWORDS_FILE_NAME);\n    mg_fopen(conn, name, \"r\", filep);\n  } else {\n     // Try to find .htpasswd in requested directory.\n    for (p = path, e = p + strlen(p) - 1; e > p; e--)\n      if (e[0] == '/')\n        break;\n    mg_snprintf(conn, name, sizeof(name), \"%.*s%c%s\",\n                (int) (e - p), p, '/', PASSWORDS_FILE_NAME);\n    mg_fopen(conn, name, \"r\", filep);\n  }\n}\n\n// Parsed Authorization header\nstruct ah {\n  char *user, *uri, *cnonce, *response, *qop, *nc, *nonce;\n};\n\n// Return 1 on success. Always initializes the ah structure.\nstatic int parse_auth_header(struct mg_connection *conn, char *buf,\n                             size_t buf_size, struct ah *ah) {\n  char *name, *value, *s;\n  const char *auth_header;\n\n  (void) memset(ah, 0, sizeof(*ah));\n  if ((auth_header = mg_get_header(conn, \"Authorization\")) == NULL ||\n      mg_strncasecmp(auth_header, \"Digest \", 7) != 0) {\n    return 0;\n  }\n\n  // Make modifiable copy of the auth header\n  (void) mg_strlcpy(buf, auth_header + 7, buf_size);\n  s = buf;\n\n  // Parse authorization header\n  for (;;) {\n    // Gobble initial spaces\n    while (isspace(* (unsigned char *) s)) {\n      s++;\n    }\n    name = skip_quoted(&s, \"=\", \" \", 0);\n    // Value is either quote-delimited, or ends at first comma or space.\n    if (s[0] == '\\\"') {\n      s++;\n      value = skip_quoted(&s, \"\\\"\", \" \", '\\\\');\n      if (s[0] == ',') {\n        s++;\n      }\n    } else {\n      value = skip_quoted(&s, \", \", \" \", 0);  // IE uses commas, FF uses spaces\n    }\n    if (*name == '\\0') {\n      break;\n    }\n\n    if (!strcmp(name, \"username\")) {\n      ah->user = value;\n    } else if (!strcmp(name, \"cnonce\")) {\n      ah->cnonce = value;\n    } else if (!strcmp(name, \"response\")) {\n      ah->response = value;\n    } else if (!strcmp(name, \"uri\")) {\n      ah->uri = value;\n    } else if (!strcmp(name, \"qop\")) {\n      ah->qop = value;\n    } else if (!strcmp(name, \"nc\")) {\n      ah->nc = value;\n    } else if (!strcmp(name, \"nonce\")) {\n      ah->nonce = value;\n    }\n  }\n\n  // CGI needs it as REMOTE_USER\n  if (ah->user != NULL) {\n    conn->request_info.remote_user = mg_strdup(ah->user);\n  } else {\n    return 0;\n  }\n\n  return 1;\n}\n\nstatic char *mg_fgets(char *buf, size_t size, struct file *filep, char **p) {\n  char *eof;\n  size_t len;\n\n  if (filep->membuf != NULL && *p != NULL) {\n    eof = memchr(*p, '\\n', &filep->membuf[filep->size] - *p);\n    len = (size_t) (eof - *p) > size - 1 ? size - 1 : (size_t) (eof - *p);\n    memcpy(buf, *p, len);\n    buf[len] = '\\0';\n    *p = eof;\n    return eof;\n  } else if (filep->fp != NULL) {\n    return fgets(buf, size, filep->fp);\n  } else {\n    return NULL;\n  }\n}\n\n// Authorize against the opened passwords file. Return 1 if authorized.\nstatic int authorize(struct mg_connection *conn, struct file *filep) {\n  struct ah ah;\n  char line[256], f_user[256], ha1[256], f_domain[256], buf[MG_BUF_LEN], *p;\n\n  if (!parse_auth_header(conn, buf, sizeof(buf), &ah)) {\n    return 0;\n  }\n\n  // Loop over passwords file\n  p = (char *) filep->membuf;\n  while (mg_fgets(line, sizeof(line), filep, &p) != NULL) {\n    if (sscanf(line, \"%[^:]:%[^:]:%s\", f_user, f_domain, ha1) != 3) {\n      continue;\n    }\n\n    if (!strcmp(ah.user, f_user) &&\n        !strcmp(conn->ctx->config[AUTHENTICATION_DOMAIN], f_domain))\n      return check_password(conn->request_info.request_method, ha1, ah.uri,\n                            ah.nonce, ah.nc, ah.cnonce, ah.qop, ah.response);\n  }\n\n  return 0;\n}\n\n// Return 1 if request is authorised, 0 otherwise.\nstatic int check_authorization(struct mg_connection *conn, const char *path) {\n  char fname[PATH_MAX];\n  struct vec uri_vec, filename_vec;\n  const char *list;\n  struct file file = STRUCT_FILE_INITIALIZER;\n  int authorized = 1;\n\n  list = conn->ctx->config[PROTECT_URI];\n  while ((list = next_option(list, &uri_vec, &filename_vec)) != NULL) {\n    if (!memcmp(conn->request_info.uri, uri_vec.ptr, uri_vec.len)) {\n      mg_snprintf(conn, fname, sizeof(fname), \"%.*s\",\n                  (int) filename_vec.len, filename_vec.ptr);\n      if (!mg_fopen(conn, fname, \"r\", &file)) {\n        cry(conn, \"%s: cannot open %s: %s\", __func__, fname, strerror(errno));\n      }\n      break;\n    }\n  }\n\n  if (!is_file_opened(&file)) {\n    open_auth_file(conn, path, &file);\n  }\n\n  if (is_file_opened(&file)) {\n    authorized = authorize(conn, &file);\n    mg_fclose(&file);\n  }\n\n  return authorized;\n}\n\nstatic void send_authorization_request(struct mg_connection *conn) {\n  conn->status_code = 401;\n  mg_printf(conn,\n            \"HTTP/1.1 401 Unauthorized\\r\\n\"\n            \"Content-Length: 0\\r\\n\"\n            \"WWW-Authenticate: Digest qop=\\\"auth\\\", \"\n            \"realm=\\\"%s\\\", nonce=\\\"%lu\\\"\\r\\n\\r\\n\",\n            conn->ctx->config[AUTHENTICATION_DOMAIN],\n            (unsigned long) time(NULL));\n}\n\nstatic int is_authorized_for_put(struct mg_connection *conn) {\n  struct file file = STRUCT_FILE_INITIALIZER;\n  const char *passfile = conn->ctx->config[PUT_DELETE_PASSWORDS_FILE];\n  int ret = 0;\n\n  if (passfile != NULL && mg_fopen(conn, passfile, \"r\", &file)) {\n    ret = authorize(conn, &file);\n    mg_fclose(&file);\n  }\n\n  return ret;\n}\n\nint mg_modify_passwords_file(const char *fname, const char *domain,\n                             const char *user, const char *pass) {\n  int found;\n  char line[512], u[512], d[512], ha1[33], tmp[PATH_MAX];\n  FILE *fp, *fp2;\n\n  found = 0;\n  fp = fp2 = NULL;\n\n  // Regard empty password as no password - remove user record.\n  if (pass != NULL && pass[0] == '\\0') {\n    pass = NULL;\n  }\n\n  (void) snprintf(tmp, sizeof(tmp), \"%s.tmp\", fname);\n\n  // Create the file if does not exist\n  if ((fp = fopen(fname, \"a+\")) != NULL) {\n    (void) fclose(fp);\n  }\n\n  // Open the given file and temporary file\n  if ((fp = fopen(fname, \"r\")) == NULL) {\n    return 0;\n  } else if ((fp2 = fopen(tmp, \"w+\")) == NULL) {\n    fclose(fp);\n    return 0;\n  }\n\n  // Copy the stuff to temporary file\n  while (fgets(line, sizeof(line), fp) != NULL) {\n    if (sscanf(line, \"%[^:]:%[^:]:%*s\", u, d) != 2) {\n      continue;\n    }\n\n    if (!strcmp(u, user) && !strcmp(d, domain)) {\n      found++;\n      if (pass != NULL) {\n        mg_md5(ha1, user, \":\", domain, \":\", pass, NULL);\n        fprintf(fp2, \"%s:%s:%s\\n\", user, domain, ha1);\n      }\n    } else {\n      fprintf(fp2, \"%s\", line);\n    }\n  }\n\n  // If new user, just add it\n  if (!found && pass != NULL) {\n    mg_md5(ha1, user, \":\", domain, \":\", pass, NULL);\n    fprintf(fp2, \"%s:%s:%s\\n\", user, domain, ha1);\n  }\n\n  // Close files\n  fclose(fp);\n  fclose(fp2);\n\n  // Put the temp file in place of real file\n  remove(fname);\n  rename(tmp, fname);\n\n  return 1;\n}\n\nstruct de {\n  struct mg_connection *conn;\n  char *file_name;\n  struct file file;\n};\n\nstatic void url_encode(const char *src, char *dst, size_t dst_len) {\n  static const char *dont_escape = \"._-$,;~()\";\n  static const char *hex = \"0123456789abcdef\";\n  const char *end = dst + dst_len - 1;\n\n  for (; *src != '\\0' && dst < end; src++, dst++) {\n    if (isalnum(*(const unsigned char *) src) ||\n        strchr(dont_escape, * (const unsigned char *) src) != NULL) {\n      *dst = *src;\n    } else if (dst + 2 < end) {\n      dst[0] = '%';\n      dst[1] = hex[(* (const unsigned char *) src) >> 4];\n      dst[2] = hex[(* (const unsigned char *) src) & 0xf];\n      dst += 2;\n    }\n  }\n\n  *dst = '\\0';\n}\n\nstatic void print_dir_entry(struct de *de) {\n  char size[64], mod[64], href[PATH_MAX];\n\n  if (de->file.is_directory) {\n    mg_snprintf(de->conn, size, sizeof(size), \"%s\", \"[DIRECTORY]\");\n  } else {\n     // We use (signed) cast below because MSVC 6 compiler cannot\n     // convert unsigned __int64 to double. Sigh.\n    if (de->file.size < 1024) {\n      mg_snprintf(de->conn, size, sizeof(size), \"%d\", (int) de->file.size);\n    } else if (de->file.size < 0x100000) {\n      mg_snprintf(de->conn, size, sizeof(size),\n                  \"%.1fk\", (double) de->file.size / 1024.0);\n    } else if (de->file.size < 0x40000000) {\n      mg_snprintf(de->conn, size, sizeof(size),\n                  \"%.1fM\", (double) de->file.size / 1048576);\n    } else {\n      mg_snprintf(de->conn, size, sizeof(size),\n                  \"%.1fG\", (double) de->file.size / 1073741824);\n    }\n  }\n  strftime(mod, sizeof(mod), \"%d-%b-%Y %H:%M\",\n           localtime(&de->file.modification_time));\n  url_encode(de->file_name, href, sizeof(href));\n  de->conn->num_bytes_sent += mg_printf(de->conn,\n      \"<tr><td><a href=\\\"%s%s%s\\\">%s%s</a></td>\"\n      \"<td>&nbsp;%s</td><td>&nbsp;&nbsp;%s</td></tr>\\n\",\n      de->conn->request_info.uri, href, de->file.is_directory ? \"/\" : \"\",\n      de->file_name, de->file.is_directory ? \"/\" : \"\", mod, size);\n}\n\n// This function is called from send_directory() and used for\n// sorting directory entries by size, or name, or modification time.\n// On windows, __cdecl specification is needed in case if project is built\n// with __stdcall convention. qsort always requires __cdels callback.\nstatic int WINCDECL compare_dir_entries(const void *p1, const void *p2) {\n  const struct de *a = (const struct de *) p1, *b = (const struct de *) p2;\n  const char *query_string = a->conn->request_info.query_string;\n  int cmp_result = 0;\n\n  if (query_string == NULL) {\n    query_string = \"na\";\n  }\n\n  if (a->file.is_directory && !b->file.is_directory) {\n    return -1;  // Always put directories on top\n  } else if (!a->file.is_directory && b->file.is_directory) {\n    return 1;   // Always put directories on top\n  } else if (*query_string == 'n') {\n    cmp_result = strcmp(a->file_name, b->file_name);\n  } else if (*query_string == 's') {\n    cmp_result = a->file.size == b->file.size ? 0 :\n      a->file.size > b->file.size ? 1 : -1;\n  } else if (*query_string == 'd') {\n    cmp_result = a->file.modification_time == b->file.modification_time ? 0 :\n      a->file.modification_time > b->file.modification_time ? 1 : -1;\n  }\n\n  return query_string[1] == 'd' ? -cmp_result : cmp_result;\n}\n\nstatic int must_hide_file(struct mg_connection *conn, const char *path) {\n  const char *pw_pattern = \"**\" PASSWORDS_FILE_NAME \"$\";\n  const char *pattern = conn->ctx->config[HIDE_FILES];\n  return match_prefix(pw_pattern, strlen(pw_pattern), path) > 0 ||\n    (pattern != NULL && match_prefix(pattern, strlen(pattern), path) > 0);\n}\n\nstatic int scan_directory(struct mg_connection *conn, const char *dir,\n                          void *data, void (*cb)(struct de *, void *)) {\n  char path[PATH_MAX];\n  struct dirent *dp;\n  DIR *dirp;\n  struct de de;\n\n  if ((dirp = opendir(dir)) == NULL) {\n    return 0;\n  } else {\n    de.conn = conn;\n\n    while ((dp = readdir(dirp)) != NULL) {\n      // Do not show current dir and hidden files\n      if (!strcmp(dp->d_name, \".\") ||\n          !strcmp(dp->d_name, \"..\") ||\n          must_hide_file(conn, dp->d_name)) {\n        continue;\n      }\n\n      mg_snprintf(conn, path, sizeof(path), \"%s%c%s\", dir, '/', dp->d_name);\n\n      // If we don't memset stat structure to zero, mtime will have\n      // garbage and strftime() will segfault later on in\n      // print_dir_entry(). memset is required only if mg_stat()\n      // fails. For more details, see\n      // http://code.google.com/p/mongoose/issues/detail?id=79\n      memset(&de.file, 0, sizeof(de.file));\n      mg_stat(conn, path, &de.file);\n\n      de.file_name = dp->d_name;\n      cb(&de, data);\n    }\n    (void) closedir(dirp);\n  }\n  return 1;\n}\n\nstruct dir_scan_data {\n  struct de *entries;\n  int num_entries;\n  int arr_size;\n};\n\nstatic void dir_scan_callback(struct de *de, void *data) {\n  struct dir_scan_data *dsd = (struct dir_scan_data *) data;\n\n  if (dsd->entries == NULL || dsd->num_entries >= dsd->arr_size) {\n    dsd->arr_size *= 2;\n    dsd->entries = (struct de *) realloc(dsd->entries, dsd->arr_size *\n                                         sizeof(dsd->entries[0]));\n  }\n  if (dsd->entries == NULL) {\n    // TODO(lsm): propagate an error to the caller\n    dsd->num_entries = 0;\n  } else {\n    dsd->entries[dsd->num_entries].file_name = mg_strdup(de->file_name);\n    dsd->entries[dsd->num_entries].file = de->file;\n    dsd->entries[dsd->num_entries].conn = de->conn;\n    dsd->num_entries++;\n  }\n}\n\nstatic void handle_directory_request(struct mg_connection *conn,\n                                     const char *dir) {\n  int i, sort_direction;\n  struct dir_scan_data data = { NULL, 0, 128 };\n\n  if (!scan_directory(conn, dir, &data, dir_scan_callback)) {\n    send_http_error(conn, 500, \"Cannot open directory\",\n                    \"Error: opendir(%s): %s\", dir, strerror(ERRNO));\n    return;\n  }\n\n  sort_direction = conn->request_info.query_string != NULL &&\n    conn->request_info.query_string[1] == 'd' ? 'a' : 'd';\n\n  conn->must_close = 1;\n  mg_printf(conn, \"%s\",\n            \"HTTP/1.1 200 OK\\r\\n\"\n            \"Connection: close\\r\\n\"\n            \"Content-Type: text/html; charset=utf-8\\r\\n\\r\\n\");\n\n  conn->num_bytes_sent += mg_printf(conn,\n      \"<html><head><title>Index of %s</title>\"\n      \"<style>th {text-align: left;}</style></head>\"\n      \"<body><h1>Index of %s</h1><pre><table cellpadding=\\\"0\\\">\"\n      \"<tr><th><a href=\\\"?n%c\\\">Name</a></th>\"\n      \"<th><a href=\\\"?d%c\\\">Modified</a></th>\"\n      \"<th><a href=\\\"?s%c\\\">Size</a></th></tr>\"\n      \"<tr><td colspan=\\\"3\\\"><hr></td></tr>\",\n      conn->request_info.uri, conn->request_info.uri,\n      sort_direction, sort_direction, sort_direction);\n\n  // Print first entry - link to a parent directory\n  conn->num_bytes_sent += mg_printf(conn,\n      \"<tr><td><a href=\\\"%s%s\\\">%s</a></td>\"\n      \"<td>&nbsp;%s</td><td>&nbsp;&nbsp;%s</td></tr>\\n\",\n      conn->request_info.uri, \"..\", \"Parent directory\", \"-\", \"-\");\n\n  // Sort and print directory entries\n  qsort(data.entries, (size_t) data.num_entries, sizeof(data.entries[0]),\n        compare_dir_entries);\n  for (i = 0; i < data.num_entries; i++) {\n    print_dir_entry(&data.entries[i]);\n    free(data.entries[i].file_name);\n  }\n  free(data.entries);\n\n  conn->num_bytes_sent += mg_printf(conn, \"%s\", \"</table></body></html>\");\n  conn->status_code = 200;\n}\n\n// Send len bytes from the opened file to the client.\nstatic void send_file_data(struct mg_connection *conn, struct file *filep,\n                           int64_t offset, int64_t len) {\n  char buf[MG_BUF_LEN];\n  int to_read, num_read, num_written;\n\n  if (len > 0 && filep->membuf != NULL && filep->size > 0) {\n    if (len > filep->size - offset) {\n      len = filep->size - offset;\n    }\n    mg_write(conn, filep->membuf + offset, (size_t) len);\n  } else if (len > 0 && filep->fp != NULL) {\n    fseeko(filep->fp, offset, SEEK_SET);\n    while (len > 0) {\n      // Calculate how much to read from the file in the buffer\n      to_read = sizeof(buf);\n      if ((int64_t) to_read > len) {\n        to_read = (int) len;\n      }\n\n      // Read from file, exit the loop on error\n      if ((num_read = fread(buf, 1, (size_t) to_read, filep->fp)) <= 0) {\n        break;\n      }\n\n      // Send read bytes to the client, exit the loop on error\n      if ((num_written = mg_write(conn, buf, (size_t) num_read)) != num_read) {\n        break;\n      }\n\n      // Both read and were successful, adjust counters\n      conn->num_bytes_sent += num_written;\n      len -= num_written;\n    }\n  }\n}\n\nstatic int parse_range_header(const char *header, int64_t *a, int64_t *b) {\n  return sscanf(header, \"bytes=%\" INT64_FMT \"-%\" INT64_FMT, a, b);\n}\n\nstatic void gmt_time_string(char *buf, size_t buf_len, time_t *t) {\n  strftime(buf, buf_len, \"%a, %d %b %Y %H:%M:%S GMT\", gmtime(t));\n}\n\nstatic void construct_etag(char *buf, size_t buf_len,\n                           const struct file *filep) {\n  snprintf(buf, buf_len, \"\\\"%lx.%\" INT64_FMT \"\\\"\",\n           (unsigned long) filep->modification_time, filep->size);\n}\n\nstatic void fclose_on_exec(struct file *filep) {\n  if (filep != NULL && filep->fp != NULL) {\n#ifndef _WIN32\n    fcntl(fileno(filep->fp), F_SETFD, FD_CLOEXEC);\n#endif\n  }\n}\n\nstatic void handle_file_request(struct mg_connection *conn, const char *path,\n                                struct file *filep) {\n  char date[64], lm[64], etag[64], range[64];\n  const char *msg = \"OK\", *hdr;\n  time_t curtime = time(NULL);\n  int64_t cl, r1, r2;\n  struct vec mime_vec;\n  int n;\n\n  get_mime_type(conn->ctx, path, &mime_vec);\n  cl = filep->size;\n  conn->status_code = 200;\n  range[0] = '\\0';\n\n  if (!mg_fopen(conn, path, \"rb\", filep)) {\n    send_http_error(conn, 500, http_500_error,\n                    \"fopen(%s): %s\", path, strerror(ERRNO));\n    return;\n  }\n  fclose_on_exec(filep);\n\n  // If Range: header specified, act accordingly\n  r1 = r2 = 0;\n  hdr = mg_get_header(conn, \"Range\");\n  if (hdr != NULL && (n = parse_range_header(hdr, &r1, &r2)) > 0 &&\n      r1 >= 0 && r2 > 0) {\n    conn->status_code = 206;\n    cl = n == 2 ? (r2 > cl ? cl : r2) - r1 + 1: cl - r1;\n    mg_snprintf(conn, range, sizeof(range),\n                \"Content-Range: bytes \"\n                \"%\" INT64_FMT \"-%\"\n                INT64_FMT \"/%\" INT64_FMT \"\\r\\n\",\n                r1, r1 + cl - 1, filep->size);\n    msg = \"Partial Content\";\n  }\n\n  // Prepare Etag, Date, Last-Modified headers. Must be in UTC, according to\n  // http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3\n  gmt_time_string(date, sizeof(date), &curtime);\n  gmt_time_string(lm, sizeof(lm), &filep->modification_time);\n  construct_etag(etag, sizeof(etag), filep);\n\n  (void) mg_printf(conn,\n      \"HTTP/1.1 %d %s\\r\\n\"\n      \"Date: %s\\r\\n\"\n      \"Last-Modified: %s\\r\\n\"\n      \"Etag: %s\\r\\n\"\n      \"Content-Type: %.*s\\r\\n\"\n      \"Content-Length: %\" INT64_FMT \"\\r\\n\"\n      \"Connection: %s\\r\\n\"\n      \"Accept-Ranges: bytes\\r\\n\"\n      \"%s\\r\\n\",\n      conn->status_code, msg, date, lm, etag, (int) mime_vec.len,\n      mime_vec.ptr, cl, suggest_connection_header(conn), range);\n\n  if (strcmp(conn->request_info.request_method, \"HEAD\") != 0) {\n    send_file_data(conn, filep, r1, cl);\n  }\n  mg_fclose(filep);\n}\n\nvoid mg_send_file(struct mg_connection *conn, const char *path) {\n  struct file file = STRUCT_FILE_INITIALIZER;\n  if (mg_stat(conn, path, &file)) {\n    handle_file_request(conn, path, &file);\n  } else {\n    send_http_error(conn, 404, \"Not Found\", \"%s\", \"File not found\");\n  }\n}\n\n\n// Parse HTTP headers from the given buffer, advance buffer to the point\n// where parsing stopped.\nstatic void parse_http_headers(char **buf, struct mg_request_info *ri) {\n  int i;\n\n  for (i = 0; i < (int) ARRAY_SIZE(ri->http_headers); i++) {\n    ri->http_headers[i].name = skip_quoted(buf, \":\", \" \", 0);\n    ri->http_headers[i].value = skip(buf, \"\\r\\n\");\n    if (ri->http_headers[i].name[0] == '\\0')\n      break;\n    ri->num_headers = i + 1;\n  }\n}\n\nstatic int is_valid_http_method(const char *method) {\n  return !strcmp(method, \"GET\") || !strcmp(method, \"POST\") ||\n    !strcmp(method, \"HEAD\") || !strcmp(method, \"CONNECT\") ||\n    !strcmp(method, \"PUT\") || !strcmp(method, \"DELETE\") ||\n    !strcmp(method, \"OPTIONS\") || !strcmp(method, \"PROPFIND\");\n}\n\n// Parse HTTP request, fill in mg_request_info structure.\n// This function modifies the buffer by NUL-terminating\n// HTTP request components, header names and header values.\nstatic int parse_http_message(char *buf, int len, struct mg_request_info *ri) {\n  int is_request, request_length = get_request_len(buf, len);\n  if (request_length > 0) {\n    // Reset attributes. DO NOT TOUCH is_ssl, remote_ip, remote_port\n    ri->remote_user = ri->request_method = ri->uri = ri->http_version = NULL;\n    ri->num_headers = 0;\n\n    buf[request_length - 1] = '\\0';\n\n    // RFC says that all initial whitespaces should be ingored\n    while (*buf != '\\0' && isspace(* (unsigned char *) buf)) {\n      buf++;\n    }\n    ri->request_method = skip(&buf, \" \");\n    ri->uri = skip(&buf, \" \");\n    ri->http_version = skip(&buf, \"\\r\\n\");\n    if (((is_request = is_valid_http_method(ri->request_method)) &&\n         memcmp(ri->http_version, \"HTTP/\", 5) != 0) ||\n        (!is_request && memcmp(ri->request_method, \"HTTP/\", 5)) != 0) {\n      request_length = -1;\n    } else {\n      if (is_request) {\n        ri->http_version += 5;\n      }\n      parse_http_headers(&buf, ri);\n    }\n  }\n  return request_length;\n}\n\n// Keep reading the input (either opened file descriptor fd, or socket sock,\n// or SSL descriptor ssl) into buffer buf, until \\r\\n\\r\\n appears in the\n// buffer (which marks the end of HTTP request). Buffer buf may already\n// have some data. The length of the data is stored in nread.\n// Upon every read operation, increase nread by the number of bytes read.\nstatic int read_request(FILE *fp, struct mg_connection *conn,\n                        char *buf, int bufsiz, int *nread) {\n  int request_len, n = 0;\n\n  request_len = get_request_len(buf, *nread);\n  while (*nread < bufsiz && request_len == 0 &&\n         (n = pull(fp, conn, buf + *nread, bufsiz - *nread)) > 0) {\n    *nread += n;\n    request_len = get_request_len(buf, *nread);\n  }\n\n  return request_len <= 0 && n <= 0 ? -1 : request_len;\n}\n\n// For given directory path, substitute it to valid index file.\n// Return 0 if index file has been found, -1 if not found.\n// If the file is found, it's stats is returned in stp.\nstatic int substitute_index_file(struct mg_connection *conn, char *path,\n                                 size_t path_len, struct file *filep) {\n  const char *list = conn->ctx->config[INDEX_FILES];\n  struct file file = STRUCT_FILE_INITIALIZER;\n  struct vec filename_vec;\n  size_t n = strlen(path);\n  int found = 0;\n\n  // The 'path' given to us points to the directory. Remove all trailing\n  // directory separator characters from the end of the path, and\n  // then append single directory separator character.\n  while (n > 0 && path[n - 1] == '/') {\n    n--;\n  }\n  path[n] = '/';\n\n  // Traverse index files list. For each entry, append it to the given\n  // path and see if the file exists. If it exists, break the loop\n  while ((list = next_option(list, &filename_vec, NULL)) != NULL) {\n\n    // Ignore too long entries that may overflow path buffer\n    if (filename_vec.len > path_len - (n + 2))\n      continue;\n\n    // Prepare full path to the index file\n    mg_strlcpy(path + n + 1, filename_vec.ptr, filename_vec.len + 1);\n\n    // Does it exist?\n    if (mg_stat(conn, path, &file)) {\n      // Yes it does, break the loop\n      *filep = file;\n      found = 1;\n      break;\n    }\n  }\n\n  // If no index file exists, restore directory path\n  if (!found) {\n    path[n] = '\\0';\n  }\n\n  return found;\n}\n\n// Return True if we should reply 304 Not Modified.\nstatic int is_not_modified(const struct mg_connection *conn,\n                           const struct file *filep) {\n  char etag[64];\n  const char *ims = mg_get_header(conn, \"If-Modified-Since\");\n  const char *inm = mg_get_header(conn, \"If-None-Match\");\n  construct_etag(etag, sizeof(etag), filep);\n  return (inm != NULL && !mg_strcasecmp(etag, inm)) ||\n    (ims != NULL && filep->modification_time <= parse_date_string(ims));\n}\n\nstatic int forward_body_data(struct mg_connection *conn, FILE *fp,\n                             SOCKET sock, SSL *ssl) {\n  const char *expect, *body;\n  char buf[MG_BUF_LEN];\n  int to_read, nread, buffered_len, success = 0;\n\n  expect = mg_get_header(conn, \"Expect\");\n  assert(fp != NULL);\n\n  if (conn->content_len == -1) {\n    send_http_error(conn, 411, \"Length Required\", \"%s\", \"\");\n  } else if (expect != NULL && mg_strcasecmp(expect, \"100-continue\")) {\n    send_http_error(conn, 417, \"Expectation Failed\", \"%s\", \"\");\n  } else {\n    if (expect != NULL) {\n      (void) mg_printf(conn, \"%s\", \"HTTP/1.1 100 Continue\\r\\n\\r\\n\");\n    }\n\n    body = conn->buf + conn->request_len + conn->consumed_content;\n    buffered_len = &conn->buf[conn->data_len] - body;\n    assert(buffered_len >= 0);\n    assert(conn->consumed_content == 0);\n\n    if (buffered_len > 0) {\n      if ((int64_t) buffered_len > conn->content_len) {\n        buffered_len = (int) conn->content_len;\n      }\n      push(fp, sock, ssl, body, (int64_t) buffered_len);\n      conn->consumed_content += buffered_len;\n    }\n\n    nread = 0;\n    while (conn->consumed_content < conn->content_len) {\n      to_read = sizeof(buf);\n      if ((int64_t) to_read > conn->content_len - conn->consumed_content) {\n        to_read = (int) (conn->content_len - conn->consumed_content);\n      }\n      nread = pull(NULL, conn, buf, to_read);\n      if (nread <= 0 || push(fp, sock, ssl, buf, nread) != nread) {\n        break;\n      }\n      conn->consumed_content += nread;\n    }\n\n    if (conn->consumed_content == conn->content_len) {\n      success = nread >= 0;\n    }\n\n    // Each error code path in this function must send an error\n    if (!success) {\n      send_http_error(conn, 577, http_500_error, \"%s\", \"\");\n    }\n  }\n\n  return success;\n}\n\n#if !defined(NO_CGI)\n// This structure helps to create an environment for the spawned CGI program.\n// Environment is an array of \"VARIABLE=VALUE\\0\" ASCIIZ strings,\n// last element must be NULL.\n// However, on Windows there is a requirement that all these VARIABLE=VALUE\\0\n// strings must reside in a contiguous buffer. The end of the buffer is\n// marked by two '\\0' characters.\n// We satisfy both worlds: we create an envp array (which is vars), all\n// entries are actually pointers inside buf.\nstruct cgi_env_block {\n  struct mg_connection *conn;\n  char buf[CGI_ENVIRONMENT_SIZE]; // Environment buffer\n  int len; // Space taken\n  char *vars[MAX_CGI_ENVIR_VARS]; // char **envp\n  int nvars; // Number of variables\n};\n\nstatic char *addenv(struct cgi_env_block *block,\n                    PRINTF_FORMAT_STRING(const char *fmt), ...)\n  PRINTF_ARGS(2, 3);\n\n// Append VARIABLE=VALUE\\0 string to the buffer, and add a respective\n// pointer into the vars array.\nstatic char *addenv(struct cgi_env_block *block, const char *fmt, ...) {\n  int n, space;\n  char *added;\n  va_list ap;\n\n  // Calculate how much space is left in the buffer\n  space = sizeof(block->buf) - block->len - 2;\n  assert(space >= 0);\n\n  // Make a pointer to the free space int the buffer\n  added = block->buf + block->len;\n\n  // Copy VARIABLE=VALUE\\0 string into the free space\n  va_start(ap, fmt);\n  n = mg_vsnprintf(block->conn, added, (size_t) space, fmt, ap);\n  va_end(ap);\n\n  // Make sure we do not overflow buffer and the envp array\n  if (n > 0 && n + 1 < space &&\n      block->nvars < (int) ARRAY_SIZE(block->vars) - 2) {\n    // Append a pointer to the added string into the envp array\n    block->vars[block->nvars++] = added;\n    // Bump up used length counter. Include \\0 terminator\n    block->len += n + 1;\n  } else {\n    cry(block->conn, \"%s: CGI env buffer truncated for [%s]\", __func__, fmt);\n  }\n\n  return added;\n}\n\nstatic void prepare_cgi_environment(struct mg_connection *conn,\n                                    const char *prog,\n                                    struct cgi_env_block *blk) {\n  const char *s, *slash;\n  struct vec var_vec;\n  char *p, src_addr[20];\n  int  i;\n\n  blk->len = blk->nvars = 0;\n  blk->conn = conn;\n  sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);\n\n  addenv(blk, \"SERVER_NAME=%s\", conn->ctx->config[AUTHENTICATION_DOMAIN]);\n  addenv(blk, \"SERVER_ROOT=%s\", conn->ctx->config[DOCUMENT_ROOT]);\n  addenv(blk, \"DOCUMENT_ROOT=%s\", conn->ctx->config[DOCUMENT_ROOT]);\n\n  // Prepare the environment block\n  addenv(blk, \"%s\", \"GATEWAY_INTERFACE=CGI/1.1\");\n  addenv(blk, \"%s\", \"SERVER_PROTOCOL=HTTP/1.1\");\n  addenv(blk, \"%s\", \"REDIRECT_STATUS=200\"); // For PHP\n\n  // TODO(lsm): fix this for IPv6 case\n  addenv(blk, \"SERVER_PORT=%d\", ntohs(conn->client.lsa.sin.sin_port));\n\n  addenv(blk, \"REQUEST_METHOD=%s\", conn->request_info.request_method);\n  addenv(blk, \"REMOTE_ADDR=%s\", src_addr);\n  addenv(blk, \"REMOTE_PORT=%d\", conn->request_info.remote_port);\n  addenv(blk, \"REQUEST_URI=%s\", conn->request_info.uri);\n\n  // SCRIPT_NAME\n  assert(conn->request_info.uri[0] == '/');\n  slash = strrchr(conn->request_info.uri, '/');\n  if ((s = strrchr(prog, '/')) == NULL)\n    s = prog;\n  addenv(blk, \"SCRIPT_NAME=%.*s%s\", (int) (slash - conn->request_info.uri),\n         conn->request_info.uri, s);\n\n  addenv(blk, \"SCRIPT_FILENAME=%s\", prog);\n  addenv(blk, \"PATH_TRANSLATED=%s\", prog);\n  addenv(blk, \"HTTPS=%s\", conn->ssl == NULL ? \"off\" : \"on\");\n\n  if ((s = mg_get_header(conn, \"Content-Type\")) != NULL)\n    addenv(blk, \"CONTENT_TYPE=%s\", s);\n\n  if (conn->request_info.query_string != NULL)\n    addenv(blk, \"QUERY_STRING=%s\", conn->request_info.query_string);\n\n  if ((s = mg_get_header(conn, \"Content-Length\")) != NULL)\n    addenv(blk, \"CONTENT_LENGTH=%s\", s);\n\n  if ((s = getenv(\"PATH\")) != NULL)\n    addenv(blk, \"PATH=%s\", s);\n\n  if (conn->path_info != NULL) {\n    addenv(blk, \"PATH_INFO=%s\", conn->path_info);\n  }\n\n#if defined(_WIN32)\n  if ((s = getenv(\"COMSPEC\")) != NULL) {\n    addenv(blk, \"COMSPEC=%s\", s);\n  }\n  if ((s = getenv(\"SYSTEMROOT\")) != NULL) {\n    addenv(blk, \"SYSTEMROOT=%s\", s);\n  }\n  if ((s = getenv(\"SystemDrive\")) != NULL) {\n    addenv(blk, \"SystemDrive=%s\", s);\n  }\n#else\n  if ((s = getenv(\"LD_LIBRARY_PATH\")) != NULL)\n    addenv(blk, \"LD_LIBRARY_PATH=%s\", s);\n#endif // _WIN32\n\n  if ((s = getenv(\"PERLLIB\")) != NULL)\n    addenv(blk, \"PERLLIB=%s\", s);\n\n  if (conn->request_info.remote_user != NULL) {\n    addenv(blk, \"REMOTE_USER=%s\", conn->request_info.remote_user);\n    addenv(blk, \"%s\", \"AUTH_TYPE=Digest\");\n  }\n\n  // Add all headers as HTTP_* variables\n  for (i = 0; i < conn->request_info.num_headers; i++) {\n    p = addenv(blk, \"HTTP_%s=%s\",\n        conn->request_info.http_headers[i].name,\n        conn->request_info.http_headers[i].value);\n\n    // Convert variable name into uppercase, and change - to _\n    for (; *p != '=' && *p != '\\0'; p++) {\n      if (*p == '-')\n        *p = '_';\n      *p = (char) toupper(* (unsigned char *) p);\n    }\n  }\n\n  // Add user-specified variables\n  s = conn->ctx->config[CGI_ENVIRONMENT];\n  while ((s = next_option(s, &var_vec, NULL)) != NULL) {\n    addenv(blk, \"%.*s\", (int) var_vec.len, var_vec.ptr);\n  }\n\n  blk->vars[blk->nvars++] = NULL;\n  blk->buf[blk->len++] = '\\0';\n\n  assert(blk->nvars < (int) ARRAY_SIZE(blk->vars));\n  assert(blk->len > 0);\n  assert(blk->len < (int) sizeof(blk->buf));\n}\n\nstatic void handle_cgi_request(struct mg_connection *conn, const char *prog) {\n  int headers_len, data_len, i, fd_stdin[2], fd_stdout[2];\n  const char *status, *status_text;\n  char buf[16384], *pbuf, dir[PATH_MAX], *p;\n  struct mg_request_info ri;\n  struct cgi_env_block blk;\n  FILE *in, *out;\n  struct file fout = STRUCT_FILE_INITIALIZER;\n  pid_t pid;\n\n  prepare_cgi_environment(conn, prog, &blk);\n\n  // CGI must be executed in its own directory. 'dir' must point to the\n  // directory containing executable program, 'p' must point to the\n  // executable program name relative to 'dir'.\n  (void) mg_snprintf(conn, dir, sizeof(dir), \"%s\", prog);\n  if ((p = strrchr(dir, '/')) != NULL) {\n    *p++ = '\\0';\n  } else {\n    dir[0] = '.', dir[1] = '\\0';\n    p = (char *) prog;\n  }\n\n  pid = (pid_t) -1;\n  fd_stdin[0] = fd_stdin[1] = fd_stdout[0] = fd_stdout[1] = -1;\n  in = out = NULL;\n\n  if (pipe(fd_stdin) != 0 || pipe(fd_stdout) != 0) {\n    send_http_error(conn, 500, http_500_error,\n        \"Cannot create CGI pipe: %s\", strerror(ERRNO));\n    goto done;\n  }\n\n  pid = spawn_process(conn, p, blk.buf, blk.vars, fd_stdin[0], fd_stdout[1],\n                      dir);\n  // spawn_process() must close those!\n  // If we don't mark them as closed, close() attempt before\n  // return from this function throws an exception on Windows.\n  // Windows does not like when closed descriptor is closed again.\n  fd_stdin[0] = fd_stdout[1] = -1;\n\n  if (pid == (pid_t) -1) {\n    send_http_error(conn, 500, http_500_error,\n        \"Cannot spawn CGI process [%s]: %s\", prog, strerror(ERRNO));\n    goto done;\n  }\n\n  if ((in = fdopen(fd_stdin[1], \"wb\")) == NULL ||\n      (out = fdopen(fd_stdout[0], \"rb\")) == NULL) {\n    send_http_error(conn, 500, http_500_error,\n        \"fopen: %s\", strerror(ERRNO));\n    goto done;\n  }\n\n  setbuf(in, NULL);\n  setbuf(out, NULL);\n  fout.fp = out;\n\n  // Send POST data to the CGI process if needed\n  if (!strcmp(conn->request_info.request_method, \"POST\") &&\n      !forward_body_data(conn, in, INVALID_SOCKET, NULL)) {\n    goto done;\n  }\n\n  // Close so child gets an EOF.\n  fclose(in);\n  in = NULL;\n  fd_stdin[1] = -1;\n\n  // Now read CGI reply into a buffer. We need to set correct\n  // status code, thus we need to see all HTTP headers first.\n  // Do not send anything back to client, until we buffer in all\n  // HTTP headers.\n  data_len = 0;\n  headers_len = read_request(out, conn, buf, sizeof(buf), &data_len);\n  if (headers_len <= 0) {\n    send_http_error(conn, 500, http_500_error,\n                    \"CGI program sent malformed or too big (>%u bytes) \"\n                    \"HTTP headers: [%.*s]\",\n                    (unsigned) sizeof(buf), data_len, buf);\n    goto done;\n  }\n  pbuf = buf;\n  buf[headers_len - 1] = '\\0';\n  parse_http_headers(&pbuf, &ri);\n\n  // Make up and send the status line\n  status_text = \"OK\";\n  if ((status = get_header(&ri, \"Status\")) != NULL) {\n    conn->status_code = atoi(status);\n    status_text = status;\n    while (isdigit(* (unsigned char *) status_text) || *status_text == ' ') {\n      status_text++;\n    }\n  } else if (get_header(&ri, \"Location\") != NULL) {\n    conn->status_code = 302;\n  } else {\n    conn->status_code = 200;\n  }\n  if (get_header(&ri, \"Connection\") != NULL &&\n      !mg_strcasecmp(get_header(&ri, \"Connection\"), \"keep-alive\")) {\n    conn->must_close = 1;\n  }\n  (void) mg_printf(conn, \"HTTP/1.1 %d %s\\r\\n\", conn->status_code,\n                   status_text);\n\n  // Send headers\n  for (i = 0; i < ri.num_headers; i++) {\n    mg_printf(conn, \"%s: %s\\r\\n\",\n              ri.http_headers[i].name, ri.http_headers[i].value);\n  }\n  mg_write(conn, \"\\r\\n\", 2);\n\n  // Send chunk of data that may have been read after the headers\n  conn->num_bytes_sent += mg_write(conn, buf + headers_len,\n                                   (size_t)(data_len - headers_len));\n\n  // Read the rest of CGI output and send to the client\n  send_file_data(conn, &fout, 0, INT64_MAX);\n\ndone:\n  if (pid != (pid_t) -1) {\n    kill(pid, SIGKILL);\n  }\n  if (fd_stdin[0] != -1) {\n    close(fd_stdin[0]);\n  }\n  if (fd_stdout[1] != -1) {\n    close(fd_stdout[1]);\n  }\n\n  if (in != NULL) {\n    fclose(in);\n  } else if (fd_stdin[1] != -1) {\n    close(fd_stdin[1]);\n  }\n\n  if (out != NULL) {\n    fclose(out);\n  } else if (fd_stdout[0] != -1) {\n    close(fd_stdout[0]);\n  }\n}\n#endif // !NO_CGI\n\n// For a given PUT path, create all intermediate subdirectories\n// for given path. Return 0 if the path itself is a directory,\n// or -1 on error, 1 if OK.\nstatic int put_dir(struct mg_connection *conn, const char *path) {\n  char buf[PATH_MAX];\n  const char *s, *p;\n  struct file file = STRUCT_FILE_INITIALIZER;\n  int len, res = 1;\n\n  for (s = p = path + 2; (p = strchr(s, '/')) != NULL; s = ++p) {\n    len = p - path;\n    if (len >= (int) sizeof(buf)) {\n      res = -1;\n      break;\n    }\n    memcpy(buf, path, len);\n    buf[len] = '\\0';\n\n    // Try to create intermediate directory\n    DEBUG_TRACE((\"mkdir(%s)\", buf));\n    if (!mg_stat(conn, buf, &file) && mg_mkdir(buf, 0755) != 0) {\n      res = -1;\n      break;\n    }\n\n    // Is path itself a directory?\n    if (p[1] == '\\0') {\n      res = 0;\n    }\n  }\n\n  return res;\n}\n\nstatic void put_file(struct mg_connection *conn, const char *path) {\n  struct file file = STRUCT_FILE_INITIALIZER;\n  const char *range;\n  int64_t r1, r2;\n  int rc;\n\n  conn->status_code = mg_stat(conn, path, &file) ? 200 : 201;\n\n  if ((rc = put_dir(conn, path)) == 0) {\n    mg_printf(conn, \"HTTP/1.1 %d OK\\r\\n\\r\\n\", conn->status_code);\n  } else if (rc == -1) {\n    send_http_error(conn, 500, http_500_error,\n                    \"put_dir(%s): %s\", path, strerror(ERRNO));\n  } else if (!mg_fopen(conn, path, \"wb+\", &file) || file.fp == NULL) {\n    mg_fclose(&file);\n    send_http_error(conn, 500, http_500_error,\n                    \"fopen(%s): %s\", path, strerror(ERRNO));\n  } else {\n    fclose_on_exec(&file);\n    range = mg_get_header(conn, \"Content-Range\");\n    r1 = r2 = 0;\n    if (range != NULL && parse_range_header(range, &r1, &r2) > 0) {\n      conn->status_code = 206;\n      fseeko(file.fp, r1, SEEK_SET);\n    }\n    if (forward_body_data(conn, file.fp, INVALID_SOCKET, NULL)) {\n      mg_printf(conn, \"HTTP/1.1 %d OK\\r\\n\\r\\n\", conn->status_code);\n    }\n    mg_fclose(&file);\n  }\n}\n\nstatic void send_ssi_file(struct mg_connection *, const char *,\n                          struct file *, int);\n\nstatic void do_ssi_include(struct mg_connection *conn, const char *ssi,\n                           char *tag, int include_level) {\n  char file_name[MG_BUF_LEN], path[PATH_MAX], *p;\n  struct file file = STRUCT_FILE_INITIALIZER;\n\n  // sscanf() is safe here, since send_ssi_file() also uses buffer\n  // of size MG_BUF_LEN to get the tag. So strlen(tag) is always < MG_BUF_LEN.\n  if (sscanf(tag, \" virtual=\\\"%[^\\\"]\\\"\", file_name) == 1) {\n    // File name is relative to the webserver root\n    (void) mg_snprintf(conn, path, sizeof(path), \"%s%c%s\",\n        conn->ctx->config[DOCUMENT_ROOT], '/', file_name);\n  } else if (sscanf(tag, \" file=\\\"%[^\\\"]\\\"\", file_name) == 1) {\n    // File name is relative to the webserver working directory\n    // or it is absolute system path\n    (void) mg_snprintf(conn, path, sizeof(path), \"%s\", file_name);\n  } else if (sscanf(tag, \" \\\"%[^\\\"]\\\"\", file_name) == 1) {\n    // File name is relative to the currect document\n    (void) mg_snprintf(conn, path, sizeof(path), \"%s\", ssi);\n    if ((p = strrchr(path, '/')) != NULL) {\n      p[1] = '\\0';\n    }\n    (void) mg_snprintf(conn, path + strlen(path),\n        sizeof(path) - strlen(path), \"%s\", file_name);\n  } else {\n    cry(conn, \"Bad SSI #include: [%s]\", tag);\n    return;\n  }\n\n  if (!mg_fopen(conn, path, \"rb\", &file)) {\n    cry(conn, \"Cannot open SSI #include: [%s]: fopen(%s): %s\",\n        tag, path, strerror(ERRNO));\n  } else {\n    fclose_on_exec(&file);\n    if (match_prefix(conn->ctx->config[SSI_EXTENSIONS],\n                     strlen(conn->ctx->config[SSI_EXTENSIONS]), path) > 0) {\n      send_ssi_file(conn, path, &file, include_level + 1);\n    } else {\n      send_file_data(conn, &file, 0, INT64_MAX);\n    }\n    mg_fclose(&file);\n  }\n}\n\n#if !defined(NO_POPEN)\nstatic void do_ssi_exec(struct mg_connection *conn, char *tag) {\n  char cmd[MG_BUF_LEN];\n  struct file file = STRUCT_FILE_INITIALIZER;\n\n  if (sscanf(tag, \" \\\"%[^\\\"]\\\"\", cmd) != 1) {\n    cry(conn, \"Bad SSI #exec: [%s]\", tag);\n  } else if ((file.fp = popen(cmd, \"r\")) == NULL) {\n    cry(conn, \"Cannot SSI #exec: [%s]: %s\", cmd, strerror(ERRNO));\n  } else {\n    send_file_data(conn, &file, 0, INT64_MAX);\n    pclose(file.fp);\n  }\n}\n#endif // !NO_POPEN\n\nstatic int mg_fgetc(struct file *filep, int offset) {\n  if (filep->membuf != NULL && offset >=0 && offset < filep->size) {\n    return ((unsigned char *) filep->membuf)[offset];\n  } else if (filep->fp != NULL) {\n    return fgetc(filep->fp);\n  } else {\n    return EOF;\n  }\n}\n\nstatic void send_ssi_file(struct mg_connection *conn, const char *path,\n                          struct file *filep, int include_level) {\n  char buf[MG_BUF_LEN];\n  int ch, offset, len, in_ssi_tag;\n\n  if (include_level > 10) {\n    cry(conn, \"SSI #include level is too deep (%s)\", path);\n    return;\n  }\n\n  in_ssi_tag = len = offset = 0;\n  while ((ch = mg_fgetc(filep, offset)) != EOF) {\n    if (in_ssi_tag && ch == '>') {\n      in_ssi_tag = 0;\n      buf[len++] = (char) ch;\n      buf[len] = '\\0';\n      assert(len <= (int) sizeof(buf));\n      if (len < 6 || memcmp(buf, \"<!--#\", 5) != 0) {\n        // Not an SSI tag, pass it\n        (void) mg_write(conn, buf, (size_t) len);\n      } else {\n        if (!memcmp(buf + 5, \"include\", 7)) {\n          do_ssi_include(conn, path, buf + 12, include_level);\n#if !defined(NO_POPEN)\n        } else if (!memcmp(buf + 5, \"exec\", 4)) {\n          do_ssi_exec(conn, buf + 9);\n#endif // !NO_POPEN\n        } else {\n          cry(conn, \"%s: unknown SSI \" \"command: \\\"%s\\\"\", path, buf);\n        }\n      }\n      len = 0;\n    } else if (in_ssi_tag) {\n      if (len == 5 && memcmp(buf, \"<!--#\", 5) != 0) {\n        // Not an SSI tag\n        in_ssi_tag = 0;\n      } else if (len == (int) sizeof(buf) - 2) {\n        cry(conn, \"%s: SSI tag is too large\", path);\n        len = 0;\n      }\n      buf[len++] = ch & 0xff;\n    } else if (ch == '<') {\n      in_ssi_tag = 1;\n      if (len > 0) {\n        mg_write(conn, buf, (size_t) len);\n      }\n      len = 0;\n      buf[len++] = ch & 0xff;\n    } else {\n      buf[len++] = ch & 0xff;\n      if (len == (int) sizeof(buf)) {\n        mg_write(conn, buf, (size_t) len);\n        len = 0;\n      }\n    }\n  }\n\n  // Send the rest of buffered data\n  if (len > 0) {\n    mg_write(conn, buf, (size_t) len);\n  }\n}\n\nstatic void handle_ssi_file_request(struct mg_connection *conn,\n                                    const char *path) {\n  struct file file = STRUCT_FILE_INITIALIZER;\n\n  if (!mg_fopen(conn, path, \"rb\", &file)) {\n    send_http_error(conn, 500, http_500_error, \"fopen(%s): %s\", path,\n                    strerror(ERRNO));\n  } else {\n    conn->must_close = 1;\n    fclose_on_exec(&file);\n    mg_printf(conn, \"HTTP/1.1 200 OK\\r\\n\"\n              \"Content-Type: text/html\\r\\nConnection: %s\\r\\n\\r\\n\",\n              suggest_connection_header(conn));\n    send_ssi_file(conn, path, &file, 0);\n    mg_fclose(&file);\n  }\n}\n\nstatic void send_options(struct mg_connection *conn) {\n  conn->status_code = 200;\n\n  mg_printf(conn, \"%s\", \"HTTP/1.1 200 OK\\r\\n\"\n            \"Allow: GET, POST, HEAD, CONNECT, PUT, DELETE, OPTIONS\\r\\n\"\n            \"DAV: 1\\r\\n\\r\\n\");\n}\n\n// Writes PROPFIND properties for a collection element\nstatic void print_props(struct mg_connection *conn, const char* uri,\n                        struct file *filep) {\n  char mtime[64];\n  gmt_time_string(mtime, sizeof(mtime), &filep->modification_time);\n  conn->num_bytes_sent += mg_printf(conn,\n      \"<d:response>\"\n       \"<d:href>%s</d:href>\"\n       \"<d:propstat>\"\n        \"<d:prop>\"\n         \"<d:resourcetype>%s</d:resourcetype>\"\n         \"<d:getcontentlength>%\" INT64_FMT \"</d:getcontentlength>\"\n         \"<d:getlastmodified>%s</d:getlastmodified>\"\n        \"</d:prop>\"\n        \"<d:status>HTTP/1.1 200 OK</d:status>\"\n       \"</d:propstat>\"\n      \"</d:response>\\n\",\n      uri,\n      filep->is_directory ? \"<d:collection/>\" : \"\",\n      filep->size,\n      mtime);\n}\n\nstatic void print_dav_dir_entry(struct de *de, void *data) {\n  char href[PATH_MAX];\n  struct mg_connection *conn = (struct mg_connection *) data;\n  mg_snprintf(conn, href, sizeof(href), \"%s%s\",\n              conn->request_info.uri, de->file_name);\n  print_props(conn, href, &de->file);\n}\n\nstatic void handle_propfind(struct mg_connection *conn, const char *path,\n                            struct file *filep) {\n  const char *depth = mg_get_header(conn, \"Depth\");\n\n  conn->must_close = 1;\n  conn->status_code = 207;\n  mg_printf(conn, \"HTTP/1.1 207 Multi-Status\\r\\n\"\n            \"Connection: close\\r\\n\"\n            \"Content-Type: text/xml; charset=utf-8\\r\\n\\r\\n\");\n\n  conn->num_bytes_sent += mg_printf(conn,\n      \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\"\n      \"<d:multistatus xmlns:d='DAV:'>\\n\");\n\n  // Print properties for the requested resource itself\n  print_props(conn, conn->request_info.uri, filep);\n\n  // If it is a directory, print directory entries too if Depth is not 0\n  if (filep->is_directory &&\n      !mg_strcasecmp(conn->ctx->config[ENABLE_DIRECTORY_LISTING], \"yes\") &&\n      (depth == NULL || strcmp(depth, \"0\") != 0)) {\n    scan_directory(conn, path, conn, &print_dav_dir_entry);\n  }\n\n  conn->num_bytes_sent += mg_printf(conn, \"%s\\n\", \"</d:multistatus>\");\n}\n\n#if defined(USE_WEBSOCKET)\n\n// START OF SHA-1 code\n// Copyright(c) By Steve Reid <steve@edmweb.com>\n#define SHA1HANDSOFF\n#if defined(__sun)\n#include \"solarisfixes.h\"\n#endif\n\nunion char64long16 { unsigned char c[64]; uint32_t l[16]; };\n\n#define rol(value, bits) (((value) << (bits)) | ((value) >> (32 - (bits))))\n\nstatic uint32_t blk0(union char64long16 *block, int i) {\n  // Forrest: SHA expect BIG_ENDIAN, swap if LITTLE_ENDIAN\n  if (!is_big_endian()) {\n    block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |\n      (rol(block->l[i], 8) & 0x00FF00FF);\n  }\n  return block->l[i];\n}\n\n#define blk(i) (block->l[i&15] = rol(block->l[(i+13)&15]^block->l[(i+8)&15] \\\n    ^block->l[(i+2)&15]^block->l[i&15],1))\n#define R0(v,w,x,y,z,i) z+=((w&(x^y))^y)+blk0(block, i)+0x5A827999+rol(v,5);w=rol(w,30);\n#define R1(v,w,x,y,z,i) z+=((w&(x^y))^y)+blk(i)+0x5A827999+rol(v,5);w=rol(w,30);\n#define R2(v,w,x,y,z,i) z+=(w^x^y)+blk(i)+0x6ED9EBA1+rol(v,5);w=rol(w,30);\n#define R3(v,w,x,y,z,i) z+=(((w|x)&y)|(w&x))+blk(i)+0x8F1BBCDC+rol(v,5);w=rol(w,30);\n#define R4(v,w,x,y,z,i) z+=(w^x^y)+blk(i)+0xCA62C1D6+rol(v,5);w=rol(w,30);\n\ntypedef struct {\n    uint32_t state[5];\n    uint32_t count[2];\n    unsigned char buffer[64];\n} SHA1_CTX;\n\nstatic void SHA1Transform(uint32_t state[5], const unsigned char buffer[64]) {\n  uint32_t a, b, c, d, e;\n  union char64long16 block[1];\n\n  memcpy(block, buffer, 64);\n  a = state[0];\n  b = state[1];\n  c = state[2];\n  d = state[3];\n  e = state[4];\n  R0(a,b,c,d,e, 0); R0(e,a,b,c,d, 1); R0(d,e,a,b,c, 2); R0(c,d,e,a,b, 3);\n  R0(b,c,d,e,a, 4); R0(a,b,c,d,e, 5); R0(e,a,b,c,d, 6); R0(d,e,a,b,c, 7);\n  R0(c,d,e,a,b, 8); R0(b,c,d,e,a, 9); R0(a,b,c,d,e,10); R0(e,a,b,c,d,11);\n  R0(d,e,a,b,c,12); R0(c,d,e,a,b,13); R0(b,c,d,e,a,14); R0(a,b,c,d,e,15);\n  R1(e,a,b,c,d,16); R1(d,e,a,b,c,17); R1(c,d,e,a,b,18); R1(b,c,d,e,a,19);\n  R2(a,b,c,d,e,20); R2(e,a,b,c,d,21); R2(d,e,a,b,c,22); R2(c,d,e,a,b,23);\n  R2(b,c,d,e,a,24); R2(a,b,c,d,e,25); R2(e,a,b,c,d,26); R2(d,e,a,b,c,27);\n  R2(c,d,e,a,b,28); R2(b,c,d,e,a,29); R2(a,b,c,d,e,30); R2(e,a,b,c,d,31);\n  R2(d,e,a,b,c,32); R2(c,d,e,a,b,33); R2(b,c,d,e,a,34); R2(a,b,c,d,e,35);\n  R2(e,a,b,c,d,36); R2(d,e,a,b,c,37); R2(c,d,e,a,b,38); R2(b,c,d,e,a,39);\n  R3(a,b,c,d,e,40); R3(e,a,b,c,d,41); R3(d,e,a,b,c,42); R3(c,d,e,a,b,43);\n  R3(b,c,d,e,a,44); R3(a,b,c,d,e,45); R3(e,a,b,c,d,46); R3(d,e,a,b,c,47);\n  R3(c,d,e,a,b,48); R3(b,c,d,e,a,49); R3(a,b,c,d,e,50); R3(e,a,b,c,d,51);\n  R3(d,e,a,b,c,52); R3(c,d,e,a,b,53); R3(b,c,d,e,a,54); R3(a,b,c,d,e,55);\n  R3(e,a,b,c,d,56); R3(d,e,a,b,c,57); R3(c,d,e,a,b,58); R3(b,c,d,e,a,59);\n  R4(a,b,c,d,e,60); R4(e,a,b,c,d,61); R4(d,e,a,b,c,62); R4(c,d,e,a,b,63);\n  R4(b,c,d,e,a,64); R4(a,b,c,d,e,65); R4(e,a,b,c,d,66); R4(d,e,a,b,c,67);\n  R4(c,d,e,a,b,68); R4(b,c,d,e,a,69); R4(a,b,c,d,e,70); R4(e,a,b,c,d,71);\n  R4(d,e,a,b,c,72); R4(c,d,e,a,b,73); R4(b,c,d,e,a,74); R4(a,b,c,d,e,75);\n  R4(e,a,b,c,d,76); R4(d,e,a,b,c,77); R4(c,d,e,a,b,78); R4(b,c,d,e,a,79);\n  state[0] += a;\n  state[1] += b;\n  state[2] += c;\n  state[3] += d;\n  state[4] += e;\n  a = b = c = d = e = 0;\n  memset(block, '\\0', sizeof(block));\n}\n\nstatic void SHA1Init(SHA1_CTX* context) {\n  context->state[0] = 0x67452301;\n  context->state[1] = 0xEFCDAB89;\n  context->state[2] = 0x98BADCFE;\n  context->state[3] = 0x10325476;\n  context->state[4] = 0xC3D2E1F0;\n  context->count[0] = context->count[1] = 0;\n}\n\nstatic void SHA1Update(SHA1_CTX* context, const unsigned char* data,\n                       uint32_t len) {\n  uint32_t i, j;\n\n  j = context->count[0];\n  if ((context->count[0] += len << 3) < j)\n    context->count[1]++;\n  context->count[1] += (len>>29);\n  j = (j >> 3) & 63;\n  if ((j + len) > 63) {\n    memcpy(&context->buffer[j], data, (i = 64-j));\n    SHA1Transform(context->state, context->buffer);\n    for ( ; i + 63 < len; i += 64) {\n      SHA1Transform(context->state, &data[i]);\n    }\n    j = 0;\n  }\n  else i = 0;\n  memcpy(&context->buffer[j], &data[i], len - i);\n}\n\nstatic void SHA1Final(unsigned char digest[20], SHA1_CTX* context) {\n  unsigned i;\n  unsigned char finalcount[8], c;\n\n  for (i = 0; i < 8; i++) {\n    finalcount[i] = (unsigned char)((context->count[(i >= 4 ? 0 : 1)]\n                                     >> ((3-(i & 3)) * 8) ) & 255);\n  }\n  c = 0200;\n  SHA1Update(context, &c, 1);\n  while ((context->count[0] & 504) != 448) {\n    c = 0000;\n    SHA1Update(context, &c, 1);\n  }\n  SHA1Update(context, finalcount, 8);\n  for (i = 0; i < 20; i++) {\n    digest[i] = (unsigned char)\n      ((context->state[i>>2] >> ((3-(i & 3)) * 8) ) & 255);\n  }\n  memset(context, '\\0', sizeof(*context));\n  memset(&finalcount, '\\0', sizeof(finalcount));\n}\n// END OF SHA1 CODE\n\nstatic void base64_encode(const unsigned char *src, int src_len, char *dst) {\n  static const char *b64 =\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n  int i, j, a, b, c;\n\n  for (i = j = 0; i < src_len; i += 3) {\n    a = src[i];\n    b = i + 1 >= src_len ? 0 : src[i + 1];\n    c = i + 2 >= src_len ? 0 : src[i + 2];\n\n    dst[j++] = b64[a >> 2];\n    dst[j++] = b64[((a & 3) << 4) | (b >> 4)];\n    if (i + 1 < src_len) {\n      dst[j++] = b64[(b & 15) << 2 | (c >> 6)];\n    }\n    if (i + 2 < src_len) {\n      dst[j++] = b64[c & 63];\n    }\n  }\n  while (j % 4 != 0) {\n    dst[j++] = '=';\n  }\n  dst[j++] = '\\0';\n}\n\nstatic void send_websocket_handshake(struct mg_connection *conn) {\n  static const char *magic = \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\";\n  char buf[100], sha[20], b64_sha[sizeof(sha) * 2];\n  SHA1_CTX sha_ctx;\n\n  mg_snprintf(conn, buf, sizeof(buf), \"%s%s\",\n              mg_get_header(conn, \"Sec-WebSocket-Key\"), magic);\n  SHA1Init(&sha_ctx);\n  SHA1Update(&sha_ctx, (unsigned char *) buf, strlen(buf));\n  SHA1Final((unsigned char *) sha, &sha_ctx);\n  base64_encode((unsigned char *) sha, sizeof(sha), b64_sha);\n  mg_printf(conn, \"%s%s%s\",\n            \"HTTP/1.1 101 Switching Protocols\\r\\n\"\n            \"Upgrade: websocket\\r\\n\"\n            \"Connection: Upgrade\\r\\n\"\n            \"Sec-WebSocket-Accept: \", b64_sha, \"\\r\\n\\r\\n\");\n}\n\nstatic void read_websocket(struct mg_connection *conn) {\n  unsigned char *buf = (unsigned char *) conn->buf + conn->request_len;\n  int n, len, mask_len, body_len, discard_len;\n\n  for (;;) {\n    if ((body_len = conn->data_len - conn->request_len) >= 2) {\n      len = buf[1] & 127;\n      mask_len = buf[1] & 128 ? 4 : 0;\n      if (len < 126) {\n        conn->content_len = 2 + mask_len + len;\n      } else if (len == 126 && body_len >= 4) {\n        conn->content_len = 4 + mask_len + ((((int) buf[2]) << 8) + buf[3]);\n      } else if (body_len >= 10) {\n        conn->content_len = 10 + mask_len +\n          (((uint64_t) htonl(* (uint32_t *) &buf[2])) << 32) +\n          htonl(* (uint32_t *) &buf[6]);\n      }\n    }\n\n    if (conn->content_len > 0) {\n      if (conn->ctx->callbacks.websocket_data != NULL &&\n          conn->ctx->callbacks.websocket_data(conn) == 0) {\n        break;  // Callback signalled to exit\n      }\n      discard_len = conn->content_len > body_len ?\n          body_len : (int) conn->content_len;\n      memmove(buf, buf + discard_len, conn->data_len - discard_len);\n      conn->data_len -= discard_len;\n      conn->content_len = conn->consumed_content = 0;\n    } else {\n      n = pull(NULL, conn, conn->buf + conn->data_len,\n               conn->buf_size - conn->data_len);\n      if (n <= 0) {\n        break;\n      }\n      conn->data_len += n;\n    }\n  }\n}\n\nstatic void handle_websocket_request(struct mg_connection *conn) {\n  if (strcmp(mg_get_header(conn, \"Sec-WebSocket-Version\"), \"13\") != 0) {\n    send_http_error(conn, 426, \"Upgrade Required\", \"%s\", \"Upgrade Required\");\n  } else if (conn->ctx->callbacks.websocket_connect != NULL &&\n             conn->ctx->callbacks.websocket_connect(conn) != 0) {\n    // Callback has returned non-zero, do not proceed with handshake\n  } else {\n    send_websocket_handshake(conn);\n    if (conn->ctx->callbacks.websocket_ready != NULL) {\n      conn->ctx->callbacks.websocket_ready(conn);\n    }\n    read_websocket(conn);\n  }\n}\n\nstatic int is_websocket_request(const struct mg_connection *conn) {\n  const char *host, *upgrade, *connection, *version, *key;\n\n  host = mg_get_header(conn, \"Host\");\n  upgrade = mg_get_header(conn, \"Upgrade\");\n  connection = mg_get_header(conn, \"Connection\");\n  key = mg_get_header(conn, \"Sec-WebSocket-Key\");\n  version = mg_get_header(conn, \"Sec-WebSocket-Version\");\n\n  return host != NULL && upgrade != NULL && connection != NULL &&\n    key != NULL && version != NULL &&\n    strstr(upgrade, \"websocket\") != NULL &&\n    strstr(connection, \"Upgrade\") != NULL;\n}\n#endif // !USE_WEBSOCKET\n\nstatic int isbyte(int n) {\n  return n >= 0 && n <= 255;\n}\n\nstatic int parse_net(const char *spec, uint32_t *net, uint32_t *mask) {\n  int n, a, b, c, d, slash = 32, len = 0;\n\n  if ((sscanf(spec, \"%d.%d.%d.%d/%d%n\", &a, &b, &c, &d, &slash, &n) == 5 ||\n      sscanf(spec, \"%d.%d.%d.%d%n\", &a, &b, &c, &d, &n) == 4) &&\n      isbyte(a) && isbyte(b) && isbyte(c) && isbyte(d) &&\n      slash >= 0 && slash < 33) {\n    len = n;\n    *net = ((uint32_t)a << 24) | ((uint32_t)b << 16) | ((uint32_t)c << 8) | d;\n    *mask = slash ? 0xffffffffU << (32 - slash) : 0;\n  }\n\n  return len;\n}\n\nstatic int set_throttle(const char *spec, uint32_t remote_ip, const char *uri) {\n  int throttle = 0;\n  struct vec vec, val;\n  uint32_t net, mask;\n  char mult;\n  double v;\n\n  while ((spec = next_option(spec, &vec, &val)) != NULL) {\n    mult = ',';\n    if (sscanf(val.ptr, \"%lf%c\", &v, &mult) < 1 || v < 0 ||\n        (lowercase(&mult) != 'k' && lowercase(&mult) != 'm' && mult != ',')) {\n      continue;\n    }\n    v *= lowercase(&mult) == 'k' ? 1024 : lowercase(&mult) == 'm' ? 1048576 : 1;\n    if (vec.len == 1 && vec.ptr[0] == '*') {\n      throttle = (int) v;\n    } else if (parse_net(vec.ptr, &net, &mask) > 0) {\n      if ((remote_ip & mask) == net) {\n        throttle = (int) v;\n      }\n    } else if (match_prefix(vec.ptr, vec.len, uri) > 0) {\n      throttle = (int) v;\n    }\n  }\n\n  return throttle;\n}\n\nstatic uint32_t get_remote_ip(const struct mg_connection *conn) {\n  return ntohl(* (uint32_t *) &conn->client.rsa.sin.sin_addr);\n}\n\n#ifdef USE_LUA\n\n#ifdef _WIN32\nstatic void *mmap(void *addr, int64_t len, int prot, int flags, int fd,\n                  int offset) {\n  HANDLE fh = (HANDLE) _get_osfhandle(fd);\n  HANDLE mh = CreateFileMapping(fh, 0, PAGE_READONLY, 0, 0, 0);\n  void *p = MapViewOfFile(mh, FILE_MAP_READ, 0, 0, (size_t) len);\n  CloseHandle(fh);\n  CloseHandle(mh);\n  return p;\n}\n#define munmap(x, y)  UnmapViewOfFile(x)\n#define MAP_FAILED NULL\n#define MAP_PRIVATE 0\n#define PROT_READ 0\n#else\n#include <sys/mman.h>\n#endif\n\nstatic void lsp(struct mg_connection *conn, const char *p, int64_t len,\n                lua_State *L) {\n  int i, j, pos = 0;\n\n  for (i = 0; i < len; i++) {\n    if (p[i] == '<' && p[i + 1] == '?') {\n      for (j = i + 1; j < len ; j++) {\n        if (p[j] == '?' && p[j + 1] == '>') {\n          mg_write(conn, p + pos, i - pos);\n          if (luaL_loadbuffer(L, p + (i + 2), j - (i + 2), \"\") == LUA_OK) {\n            lua_pcall(L, 0, LUA_MULTRET, 0);\n          }\n          pos = j + 2;\n          i = pos - 1;\n          break;\n        }\n      }\n    }\n  }\n\n  if (i > pos) {\n    mg_write(conn, p + pos, i - pos);\n  }\n}\n\nstatic int lsp_mg_print(lua_State *L) {\n  int i, num_args;\n  const char *str;\n  size_t size;\n  struct mg_connection *conn = lua_touserdata(L, lua_upvalueindex(1));\n\n  num_args = lua_gettop(L);\n  for (i = 1; i <= num_args; i++) {\n    if (lua_isstring(L, i)) {\n      str = lua_tolstring(L, i, &size);\n      mg_write(conn, str, size);\n    }\n  }\n\n  return 0;\n}\n\nstatic int lsp_mg_read(lua_State *L) {\n  struct mg_connection *conn = lua_touserdata(L, lua_upvalueindex(1));\n  char buf[1024];\n  int len = mg_read(conn, buf, sizeof(buf));\n\n  lua_settop(L, 0);\n  lua_pushlstring(L, buf, len);\n\n  return 1;\n}\n\nstatic void reg_string(struct lua_State *L, const char *name, const char *val) {\n  lua_pushstring(L, name);\n  lua_pushstring(L, val);\n  lua_rawset(L, -3);\n}\n\nstatic void reg_int(struct lua_State *L, const char *name, int val) {\n  lua_pushstring(L, name);\n  lua_pushinteger(L, val);\n  lua_rawset(L, -3);\n}\n\nstatic void prepare_lua_environment(struct mg_connection *conn, lua_State *L) {\n  const struct mg_request_info *ri = mg_get_request_info(conn);\n  extern void luaL_openlibs(lua_State *);\n  int i;\n\n  luaL_openlibs(L);\n#ifdef USE_LUA_SQLITE3\n  { extern int luaopen_lsqlite3(lua_State *); luaopen_lsqlite3(L); }\n#endif\n\n  // Register \"print\" function which calls mg_write()\n  lua_pushlightuserdata(L, conn);\n  lua_pushcclosure(L, lsp_mg_print, 1);\n  lua_setglobal(L, \"print\");\n\n  // Register mg_read()\n  lua_pushlightuserdata(L, conn);\n  lua_pushcclosure(L, lsp_mg_read, 1);\n  lua_setglobal(L, \"read\");\n\n  // Export request_info\n  lua_newtable(L);\n  reg_string(L, \"request_method\", ri->request_method);\n  reg_string(L, \"uri\", ri->uri);\n  reg_string(L, \"http_version\", ri->http_version);\n  reg_string(L, \"query_string\", ri->query_string);\n  reg_int(L, \"remote_ip\", ri->remote_ip);\n  reg_int(L, \"remote_port\", ri->remote_port);\n  reg_int(L, \"num_headers\", ri->num_headers);\n  lua_pushstring(L, \"http_headers\");\n  lua_newtable(L);\n  for (i = 0; i < ri->num_headers; i++) {\n    reg_string(L, ri->http_headers[i].name, ri->http_headers[i].value);\n  }\n  lua_rawset(L, -3);\n  lua_setglobal(L, \"request_info\");\n}\n\nstatic void handle_lsp_request(struct mg_connection *conn, const char *path,\n                               struct file *filep) {\n  void *p = NULL;\n  lua_State *L = NULL;\n\n  if (!mg_stat(conn, path, filep) || !mg_fopen(conn, path, \"r\", filep)) {\n    send_http_error(conn, 404, \"Not Found\", \"%s\", \"File not found\");\n  } else if (filep->membuf == NULL &&\n             (p = mmap(NULL, (size_t) filep->size, PROT_READ, MAP_PRIVATE,\n                       fileno(filep->fp), 0)) == MAP_FAILED) {\n    send_http_error(conn, 500, http_500_error, \"mmap(%s, %zu, %d): %s\", path,\n                    (size_t) filep->size, fileno(filep->fp), strerror(errno));\n  } else if ((L = luaL_newstate()) == NULL) {\n    send_http_error(conn, 500, http_500_error, \"%s\", \"luaL_newstate failed\");\n  } else {\n    // We're not sending HTTP headers here, Lua page must do it.\n    prepare_lua_environment(conn, L);\n    if (conn->ctx->callbacks.init_lua != NULL) {\n      conn->ctx->callbacks.init_lua(conn, L);\n    }\n    lsp(conn, filep->membuf == NULL ? p : filep->membuf, filep->size, L);\n  }\n\n  if (L) lua_close(L);\n  if (p) munmap(p, filep->size);\n  mg_fclose(filep);\n}\n#endif // USE_LUA\n\nint mg_upload(struct mg_connection *conn, const char *destination_dir) {\n  const char *content_type_header, *boundary_start;\n  char buf[MG_BUF_LEN], path[PATH_MAX], fname[1024], boundary[100], *s;\n  FILE *fp;\n  int bl, n, i, j, headers_len, boundary_len, len = 0, num_uploaded_files = 0;\n\n  // Request looks like this:\n  //\n  // POST /upload HTTP/1.1\n  // Host: 127.0.0.1:8080\n  // Content-Length: 244894\n  // Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryRVr\n  //\n  // ------WebKitFormBoundaryRVr\n  // Content-Disposition: form-data; name=\"file\"; filename=\"accum.png\"\n  // Content-Type: image/png\n  //\n  //  <89>PNG\n  //  <PNG DATA>\n  // ------WebKitFormBoundaryRVr\n\n  // Extract boundary string from the Content-Type header\n  if ((content_type_header = mg_get_header(conn, \"Content-Type\")) == NULL ||\n      (boundary_start = strstr(content_type_header, \"boundary=\")) == NULL ||\n      (sscanf(boundary_start, \"boundary=\\\"%99[^\\\"]\\\"\", boundary) == 0 &&\n       sscanf(boundary_start, \"boundary=%99s\", boundary) == 0) ||\n      boundary[0] == '\\0') {\n    return num_uploaded_files;\n  }\n\n  boundary_len = strlen(boundary);\n  bl = boundary_len + 4;  // \\r\\n--<boundary>\n  for (;;) {\n    // Pull in headers\n    assert(len >= 0 && len <= (int) sizeof(buf));\n    while ((n = mg_read(conn, buf + len, sizeof(buf) - len)) > 0) {\n      len += n;\n    }\n    if ((headers_len = get_request_len(buf, len)) <= 0) {\n      break;\n    }\n\n    // Fetch file name.\n    fname[0] = '\\0';\n    for (i = j = 0; i < headers_len; i++) {\n      if (buf[i] == '\\r' && buf[i + 1] == '\\n') {\n        buf[i] = buf[i + 1] = '\\0';\n        // TODO(lsm): don't expect filename to be the 3rd field,\n        // parse the header properly instead.\n        sscanf(&buf[j], \"Content-Disposition: %*s %*s filename=\\\"%1023[^\\\"]\",\n               fname);\n        j = i + 2;\n      }\n    }\n\n    // Give up if the headers are not what we expect\n    if (fname[0] == '\\0') {\n      break;\n    }\n\n    // Move data to the beginning of the buffer\n    assert(len >= headers_len);\n    memmove(buf, &buf[headers_len], len - headers_len);\n    len -= headers_len;\n\n    // We open the file with exclusive lock held. This guarantee us\n    // there is no other thread can save into the same file simultaneously.\n    fp = NULL;\n    // Construct destination file name. Do not allow paths to have slashes.\n    if ((s = strrchr(fname, '/')) == NULL) {\n      s = fname;\n    }\n    // Open file in binary mode. TODO: set an exclusive lock.\n    snprintf(path, sizeof(path), \"%s/%s\", destination_dir, s);\n    if ((fp = fopen(path, \"wb\")) == NULL) {\n      break;\n    }\n\n    // Read POST data, write into file until boundary is found.\n    n = 0;\n    do {\n      len += n;\n      for (i = 0; i < len - bl; i++) {\n        if (!memcmp(&buf[i], \"\\r\\n--\", 4) &&\n            !memcmp(&buf[i + 4], boundary, boundary_len)) {\n          // Found boundary, that's the end of file data.\n          fwrite(buf, 1, i, fp);\n          fflush(fp);\n          num_uploaded_files++;\n          if (conn->ctx->callbacks.upload != NULL) {\n            conn->ctx->callbacks.upload(conn, path);\n          }\n          memmove(buf, &buf[i + bl], len - (i + bl));\n          len -= i + bl;\n          break;\n        }\n      }\n      if (len > bl) {\n        fwrite(buf, 1, len - bl, fp);\n        memmove(buf, &buf[len - bl], bl);\n        len = bl;\n      }\n    } while ((n = mg_read(conn, buf + len, sizeof(buf) - len)) > 0);\n    fclose(fp);\n  }\n\n  return num_uploaded_files;\n}\n\nstatic int is_put_or_delete_request(const struct mg_connection *conn) {\n  const char *s = conn->request_info.request_method;\n  return s != NULL && (!strcmp(s, \"PUT\") || !strcmp(s, \"DELETE\"));\n}\n\nstatic int get_first_ssl_listener_index(const struct mg_context *ctx) {\n  int i, index = -1;\n  for (i = 0; index == -1 && i < ctx->num_listening_sockets; i++) {\n    index = ctx->listening_sockets[i].is_ssl ? i : -1;\n  }\n  return index;\n}\n\nstatic void redirect_to_https_port(struct mg_connection *conn, int ssl_index) {\n  char host[1025];\n  const char *host_header;\n\n  if ((host_header = mg_get_header(conn, \"Host\")) == NULL ||\n      sscanf(host_header, \"%1024[^:]\", host) == 0) {\n    // Cannot get host from the Host: header. Fallback to our IP address.\n    sockaddr_to_string(host, sizeof(host), &conn->client.lsa);\n  }\n\n  mg_printf(conn, \"HTTP/1.1 302 Found\\r\\nLocation: https://%s:%d%s\\r\\n\\r\\n\",\n            host, (int) ntohs(conn->ctx->listening_sockets[ssl_index].\n                              lsa.sin.sin_port), conn->request_info.uri);\n}\n\n// This is the heart of the Mongoose's logic.\n// This function is called when the request is read, parsed and validated,\n// and Mongoose must decide what action to take: serve a file, or\n// a directory, or call embedded function, etcetera.\nstatic void handle_request(struct mg_connection *conn) {\n  struct mg_request_info *ri = &conn->request_info;\n  char path[PATH_MAX];\n  int uri_len, ssl_index;\n  struct file file = STRUCT_FILE_INITIALIZER;\n\n  if ((conn->request_info.query_string = strchr(ri->uri, '?')) != NULL) {\n    * ((char *) conn->request_info.query_string++) = '\\0';\n  }\n  uri_len = (int) strlen(ri->uri);\n  url_decode(ri->uri, uri_len, (char *) ri->uri, uri_len + 1, 0);\n  remove_double_dots_and_double_slashes((char *) ri->uri);\n  convert_uri_to_file_name(conn, path, sizeof(path), &file);\n  conn->throttle = set_throttle(conn->ctx->config[THROTTLE],\n                                get_remote_ip(conn), ri->uri);\n\n  DEBUG_TRACE((\"%s\", ri->uri));\n  if (conn->ctx->callbacks.begin_request != NULL &&\n      conn->ctx->callbacks.begin_request(conn)) {\n    // Do nothing, callback has served the request\n  } else if (!conn->client.is_ssl && conn->client.ssl_redir &&\n      (ssl_index = get_first_ssl_listener_index(conn->ctx)) > -1) {\n    redirect_to_https_port(conn, ssl_index);\n  } else if (!is_put_or_delete_request(conn) &&\n             !check_authorization(conn, path)) {\n    send_authorization_request(conn);\n#if defined(USE_WEBSOCKET)\n  } else if (is_websocket_request(conn)) {\n    handle_websocket_request(conn);\n#endif\n  } else if (!strcmp(ri->request_method, \"OPTIONS\")) {\n    send_options(conn);\n  } else if (conn->ctx->config[DOCUMENT_ROOT] == NULL) {\n    send_http_error(conn, 404, \"Not Found\", \"Not Found\");\n  } else if (is_put_or_delete_request(conn) &&\n             (conn->ctx->config[PUT_DELETE_PASSWORDS_FILE] == NULL ||\n              is_authorized_for_put(conn) != 1)) {\n    send_authorization_request(conn);\n  } else if (!strcmp(ri->request_method, \"PUT\")) {\n    put_file(conn, path);\n  } else if (!strcmp(ri->request_method, \"DELETE\")) {\n    if (mg_remove(path) == 0) {\n      send_http_error(conn, 200, \"OK\", \"%s\", \"\");\n    } else {\n      send_http_error(conn, 500, http_500_error, \"remove(%s): %s\", path,\n                      strerror(ERRNO));\n    }\n  } else if ((file.membuf == NULL && file.modification_time == (time_t) 0) ||\n             must_hide_file(conn, path)) {\n    send_http_error(conn, 404, \"Not Found\", \"%s\", \"File not found\");\n  } else if (file.is_directory && ri->uri[uri_len - 1] != '/') {\n    mg_printf(conn, \"HTTP/1.1 301 Moved Permanently\\r\\n\"\n              \"Location: %s/\\r\\n\\r\\n\", ri->uri);\n  } else if (!strcmp(ri->request_method, \"PROPFIND\")) {\n    handle_propfind(conn, path, &file);\n  } else if (file.is_directory &&\n             !substitute_index_file(conn, path, sizeof(path), &file)) {\n    if (!mg_strcasecmp(conn->ctx->config[ENABLE_DIRECTORY_LISTING], \"yes\")) {\n      handle_directory_request(conn, path);\n    } else {\n      send_http_error(conn, 403, \"Directory Listing Denied\",\n          \"Directory listing denied\");\n    }\n#ifdef USE_LUA\n  } else if (match_prefix(\"**.lp$\", 6, path) > 0) {\n    handle_lsp_request(conn, path, &file);\n#endif\n#if !defined(NO_CGI)\n  } else if (match_prefix(conn->ctx->config[CGI_EXTENSIONS],\n                          strlen(conn->ctx->config[CGI_EXTENSIONS]),\n                          path) > 0) {\n    if (strcmp(ri->request_method, \"POST\") &&\n        strcmp(ri->request_method, \"HEAD\") &&\n        strcmp(ri->request_method, \"GET\")) {\n      send_http_error(conn, 501, \"Not Implemented\",\n                      \"Method %s is not implemented\", ri->request_method);\n    } else {\n      handle_cgi_request(conn, path);\n    }\n#endif // !NO_CGI\n  } else if (match_prefix(conn->ctx->config[SSI_EXTENSIONS],\n                          strlen(conn->ctx->config[SSI_EXTENSIONS]),\n                          path) > 0) {\n    handle_ssi_file_request(conn, path);\n  } else if (is_not_modified(conn, &file)) {\n    send_http_error(conn, 304, \"Not Modified\", \"%s\", \"\");\n  } else {\n    handle_file_request(conn, path, &file);\n  }\n}\n\nstatic void close_all_listening_sockets(struct mg_context *ctx) {\n  int i;\n  for (i = 0; i < ctx->num_listening_sockets; i++) {\n    closesocket(ctx->listening_sockets[i].sock);\n  }\n  free(ctx->listening_sockets);\n}\n\n// Valid listening port specification is: [ip_address:]port[s]\n// Examples: 80, 443s, 127.0.0.1:3128, 1.2.3.4:8080s\n// TODO(lsm): add parsing of the IPv6 address\nstatic int parse_port_string(const struct vec *vec, struct socket *so) {\n  int a, b, c, d, port, len;\n\n  // MacOS needs that. If we do not zero it, subsequent bind() will fail.\n  // Also, all-zeroes in the socket address means binding to all addresses\n  // for both IPv4 and IPv6 (INADDR_ANY and IN6ADDR_ANY_INIT).\n  memset(so, 0, sizeof(*so));\n\n  if (sscanf(vec->ptr, \"%d.%d.%d.%d:%d%n\", &a, &b, &c, &d, &port, &len) == 5) {\n    // Bind to a specific IPv4 address\n    so->lsa.sin.sin_addr.s_addr = htonl((a << 24) | (b << 16) | (c << 8) | d);\n  } else if (sscanf(vec->ptr, \"%d%n\", &port, &len) != 1 ||\n             len <= 0 ||\n             len > (int) vec->len ||\n             (vec->ptr[len] && vec->ptr[len] != 's' &&\n              vec->ptr[len] != 'r' && vec->ptr[len] != ',')) {\n    return 0;\n  }\n\n  so->is_ssl = vec->ptr[len] == 's';\n  so->ssl_redir = vec->ptr[len] == 'r';\n#if defined(USE_IPV6)\n  so->lsa.sin6.sin6_family = AF_INET6;\n  so->lsa.sin6.sin6_port = htons((uint16_t) port);\n#else\n  so->lsa.sin.sin_family = AF_INET;\n  so->lsa.sin.sin_port = htons((uint16_t) port);\n#endif\n\n  return 1;\n}\n\nstatic int set_ports_option(struct mg_context *ctx) {\n  const char *list = ctx->config[LISTENING_PORTS];\n  int on = 1, success = 1;\n  struct vec vec;\n  struct socket so;\n\n  while (success && (list = next_option(list, &vec, NULL)) != NULL) {\n    if (!parse_port_string(&vec, &so)) {\n      cry(fc(ctx), \"%s: %.*s: invalid port spec. Expecting list of: %s\",\n          __func__, (int) vec.len, vec.ptr, \"[IP_ADDRESS:]PORT[s|p]\");\n      success = 0;\n    } else if (so.is_ssl && ctx->ssl_ctx == NULL) {\n      cry(fc(ctx), \"Cannot add SSL socket, is -ssl_certificate option set?\");\n      success = 0;\n    } else if ((so.sock = socket(so.lsa.sa.sa_family, SOCK_STREAM, 6)) ==\n               INVALID_SOCKET ||\n               // On Windows, SO_REUSEADDR is recommended only for\n               // broadcast UDP sockets\n               setsockopt(so.sock, SOL_SOCKET, SO_REUSEADDR,\n                          (void *) &on, sizeof(on)) != 0 ||\n               bind(so.sock, &so.lsa.sa, sizeof(so.lsa)) != 0 ||\n               listen(so.sock, SOMAXCONN) != 0) {\n      cry(fc(ctx), \"%s: cannot bind to %.*s: %s\", __func__,\n          (int) vec.len, vec.ptr, strerror(ERRNO));\n      closesocket(so.sock);\n      success = 0;\n    } else {\n      set_close_on_exec(so.sock);\n      // TODO: handle realloc failure\n      ctx->listening_sockets = realloc(ctx->listening_sockets,\n                                       (ctx->num_listening_sockets + 1) *\n                                       sizeof(ctx->listening_sockets[0]));\n      ctx->listening_sockets[ctx->num_listening_sockets] = so;\n      ctx->num_listening_sockets++;\n    }\n  }\n\n  if (!success) {\n    close_all_listening_sockets(ctx);\n  }\n\n  return success;\n}\n\nstatic void log_header(const struct mg_connection *conn, const char *header,\n                       FILE *fp) {\n  const char *header_value;\n\n  if ((header_value = mg_get_header(conn, header)) == NULL) {\n    (void) fprintf(fp, \"%s\", \" -\");\n  } else {\n    (void) fprintf(fp, \" \\\"%s\\\"\", header_value);\n  }\n}\n\nstatic void log_access(const struct mg_connection *conn) {\n  const struct mg_request_info *ri;\n  FILE *fp;\n  char date[64], src_addr[20];\n\n  fp = conn->ctx->config[ACCESS_LOG_FILE] == NULL ?  NULL :\n    fopen(conn->ctx->config[ACCESS_LOG_FILE], \"a+\");\n\n  if (fp == NULL)\n    return;\n\n  strftime(date, sizeof(date), \"%d/%b/%Y:%H:%M:%S %z\",\n           localtime(&conn->birth_time));\n\n  ri = &conn->request_info;\n  flockfile(fp);\n\n  sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);\n  fprintf(fp, \"%s - %s [%s] \\\"%s %s HTTP/%s\\\" %d %\" INT64_FMT,\n          src_addr, ri->remote_user == NULL ? \"-\" : ri->remote_user, date,\n          ri->request_method ? ri->request_method : \"-\",\n          ri->uri ? ri->uri : \"-\", ri->http_version,\n          conn->status_code, conn->num_bytes_sent);\n  log_header(conn, \"Referer\", fp);\n  log_header(conn, \"User-Agent\", fp);\n  fputc('\\n', fp);\n  fflush(fp);\n\n  funlockfile(fp);\n  fclose(fp);\n}\n\n// Verify given socket address against the ACL.\n// Return -1 if ACL is malformed, 0 if address is disallowed, 1 if allowed.\nstatic int check_acl(struct mg_context *ctx, uint32_t remote_ip) {\n  int allowed, flag;\n  uint32_t net, mask;\n  struct vec vec;\n  const char *list = ctx->config[ACCESS_CONTROL_LIST];\n\n  // If any ACL is set, deny by default\n  allowed = list == NULL ? '+' : '-';\n\n  while ((list = next_option(list, &vec, NULL)) != NULL) {\n    flag = vec.ptr[0];\n    if ((flag != '+' && flag != '-') ||\n        parse_net(&vec.ptr[1], &net, &mask) == 0) {\n      cry(fc(ctx), \"%s: subnet must be [+|-]x.x.x.x[/x]\", __func__);\n      return -1;\n    }\n\n    if (net == (remote_ip & mask)) {\n      allowed = flag;\n    }\n  }\n\n  return allowed == '+';\n}\n\n#if !defined(_WIN32)\nstatic int set_uid_option(struct mg_context *ctx) {\n  struct passwd *pw;\n  const char *uid = ctx->config[RUN_AS_USER];\n  int success = 0;\n\n  if (uid == NULL) {\n    success = 1;\n  } else {\n    if ((pw = getpwnam(uid)) == NULL) {\n      cry(fc(ctx), \"%s: unknown user [%s]\", __func__, uid);\n    } else if (setgid(pw->pw_gid) == -1) {\n      cry(fc(ctx), \"%s: setgid(%s): %s\", __func__, uid, strerror(errno));\n    } else if (setuid(pw->pw_uid) == -1) {\n      cry(fc(ctx), \"%s: setuid(%s): %s\", __func__, uid, strerror(errno));\n    } else {\n      success = 1;\n    }\n  }\n\n  return success;\n}\n#endif // !_WIN32\n\n#if !defined(NO_SSL)\nstatic pthread_mutex_t *ssl_mutexes;\n\nstatic int sslize(struct mg_connection *conn, SSL_CTX *s, int (*func)(SSL *)) {\n  return (conn->ssl = SSL_new(s)) != NULL &&\n    SSL_set_fd(conn->ssl, conn->client.sock) == 1 &&\n    func(conn->ssl) == 1;\n}\n\n// Return OpenSSL error message\nstatic const char *ssl_error(void) {\n  unsigned long err;\n  err = ERR_get_error();\n  return err == 0 ? \"\" : ERR_error_string(err, NULL);\n}\n\nstatic void ssl_locking_callback(int mode, int mutex_num, const char *file,\n                                 int line) {\n  (void) line;\n  (void) file;\n\n  if (mode & 1) {  // 1 is CRYPTO_LOCK\n    (void) pthread_mutex_lock(&ssl_mutexes[mutex_num]);\n  } else {\n    (void) pthread_mutex_unlock(&ssl_mutexes[mutex_num]);\n  }\n}\n\nstatic unsigned long ssl_id_callback(void) {\n  return (unsigned long) pthread_self();\n}\n\n#if !defined(NO_SSL_DL)\nstatic int load_dll(struct mg_context *ctx, const char *dll_name,\n                    struct ssl_func *sw) {\n  union {void *p; void (*fp)(void);} u;\n  void  *dll_handle;\n  struct ssl_func *fp;\n\n  if ((dll_handle = dlopen(dll_name, RTLD_LAZY)) == NULL) {\n    cry(fc(ctx), \"%s: cannot load %s\", __func__, dll_name);\n    return 0;\n  }\n\n  for (fp = sw; fp->name != NULL; fp++) {\n#ifdef _WIN32\n    // GetProcAddress() returns pointer to function\n    u.fp = (void (*)(void)) dlsym(dll_handle, fp->name);\n#else\n    // dlsym() on UNIX returns void *. ISO C forbids casts of data pointers to\n    // function pointers. We need to use a union to make a cast.\n    u.p = dlsym(dll_handle, fp->name);\n#endif // _WIN32\n    if (u.fp == NULL) {\n      cry(fc(ctx), \"%s: %s: cannot find %s\", __func__, dll_name, fp->name);\n      return 0;\n    } else {\n      fp->ptr = u.fp;\n    }\n  }\n\n  return 1;\n}\n#endif // NO_SSL_DL\n\n// Dynamically load SSL library. Set up ctx->ssl_ctx pointer.\nstatic int set_ssl_option(struct mg_context *ctx) {\n  int i, size;\n  const char *pem;\n\n  // If PEM file is not specified, skip SSL initialization.\n  if ((pem = ctx->config[SSL_CERTIFICATE]) == NULL) {\n    return 1;\n  }\n\n#if !defined(NO_SSL_DL)\n  if (!load_dll(ctx, SSL_LIB, ssl_sw) ||\n      !load_dll(ctx, CRYPTO_LIB, crypto_sw)) {\n    return 0;\n  }\n#endif // NO_SSL_DL\n\n  // Initialize SSL library\n  SSL_library_init();\n  SSL_load_error_strings();\n\n  if ((ctx->ssl_ctx = SSL_CTX_new(SSLv23_server_method())) == NULL) {\n    cry(fc(ctx), \"SSL_CTX_new (server) error: %s\", ssl_error());\n    return 0;\n  }\n\n  // If user callback returned non-NULL, that means that user callback has\n  // set up certificate itself. In this case, skip sertificate setting.\n  if ((ctx->callbacks.init_ssl == NULL ||\n       !ctx->callbacks.init_ssl(ctx->ssl_ctx)) &&\n      (SSL_CTX_use_certificate_file(ctx->ssl_ctx, pem, 1) == 0 ||\n       SSL_CTX_use_PrivateKey_file(ctx->ssl_ctx, pem, 1) == 0)) {\n    cry(fc(ctx), \"%s: cannot open %s: %s\", __func__, pem, ssl_error());\n    return 0;\n  }\n\n  if (pem != NULL) {\n    (void) SSL_CTX_use_certificate_chain_file(ctx->ssl_ctx, pem);\n  }\n\n  // Initialize locking callbacks, needed for thread safety.\n  // http://www.openssl.org/support/faq.html#PROG1\n  size = sizeof(pthread_mutex_t) * CRYPTO_num_locks();\n  if ((ssl_mutexes = (pthread_mutex_t *) malloc((size_t)size)) == NULL) {\n    cry(fc(ctx), \"%s: cannot allocate mutexes: %s\", __func__, ssl_error());\n    return 0;\n  }\n\n  for (i = 0; i < CRYPTO_num_locks(); i++) {\n    pthread_mutex_init(&ssl_mutexes[i], NULL);\n  }\n\n  CRYPTO_set_locking_callback(&ssl_locking_callback);\n  CRYPTO_set_id_callback(&ssl_id_callback);\n\n  return 1;\n}\n\nstatic void uninitialize_ssl(struct mg_context *ctx) {\n  int i;\n  if (ctx->ssl_ctx != NULL) {\n    CRYPTO_set_locking_callback(NULL);\n    for (i = 0; i < CRYPTO_num_locks(); i++) {\n      pthread_mutex_destroy(&ssl_mutexes[i]);\n    }\n    CRYPTO_set_locking_callback(NULL);\n    CRYPTO_set_id_callback(NULL);\n  }\n}\n#endif // !NO_SSL\n\nstatic int set_gpass_option(struct mg_context *ctx) {\n  struct file file = STRUCT_FILE_INITIALIZER;\n  const char *path = ctx->config[GLOBAL_PASSWORDS_FILE];\n  if (path != NULL && !mg_stat(fc(ctx), path, &file)) {\n    cry(fc(ctx), \"Cannot open %s: %s\", path, strerror(ERRNO));\n    return 0;\n  }\n  return 1;\n}\n\nstatic int set_acl_option(struct mg_context *ctx) {\n  return check_acl(ctx, (uint32_t) 0x7f000001UL) != -1;\n}\n\nstatic void reset_per_request_attributes(struct mg_connection *conn) {\n  conn->path_info = NULL;\n  conn->num_bytes_sent = conn->consumed_content = 0;\n  conn->status_code = -1;\n  conn->must_close = conn->request_len = conn->throttle = 0;\n}\n\nstatic void close_socket_gracefully(struct mg_connection *conn) {\n#if defined(_WIN32)\n  char buf[MG_BUF_LEN];\n  int n;\n#endif\n  struct linger linger;\n\n  // Set linger option to avoid socket hanging out after close. This prevent\n  // ephemeral port exhaust problem under high QPS.\n  linger.l_onoff = 1;\n  linger.l_linger = 1;\n  setsockopt(conn->client.sock, SOL_SOCKET, SO_LINGER,\n             (char *) &linger, sizeof(linger));\n\n  // Send FIN to the client\n  shutdown(conn->client.sock, SHUT_WR);\n  set_non_blocking_mode(conn->client.sock);\n\n#if defined(_WIN32)\n  // Read and discard pending incoming data. If we do not do that and close the\n  // socket, the data in the send buffer may be discarded. This\n  // behaviour is seen on Windows, when client keeps sending data\n  // when server decides to close the connection; then when client\n  // does recv() it gets no data back.\n  do {\n    n = pull(NULL, conn, buf, sizeof(buf));\n  } while (n > 0);\n#endif\n\n  // Now we know that our FIN is ACK-ed, safe to close\n  closesocket(conn->client.sock);\n}\n\nstatic void close_connection(struct mg_connection *conn) {\n  conn->must_close = 1;\n  if (conn->client.sock != INVALID_SOCKET) {\n    close_socket_gracefully(conn);\n  }\n#ifndef NO_SSL\n  // Must be done AFTER socket is closed\n  if (conn->ssl != NULL) {\n    SSL_free(conn->ssl);\n  }\n#endif\n}\n\nvoid mg_close_connection(struct mg_connection *conn) {\n#ifndef NO_SSL\n  if (conn->client_ssl_ctx != NULL) {\n    SSL_CTX_free((SSL_CTX *) conn->client_ssl_ctx);\n  }\n#endif\n  close_connection(conn);\n  free(conn);\n}\n\nstruct mg_connection *mg_connect(const char *host, int port, int use_ssl,\n                                 char *ebuf, size_t ebuf_len) {\n  static struct mg_context fake_ctx;\n  struct mg_connection *conn = NULL;\n  struct sockaddr_in sin;\n  struct hostent *he;\n  int sock;\n\n  if (host == NULL) {\n    snprintf(ebuf, ebuf_len, \"%s\", \"NULL host\");\n  } else if (use_ssl && SSLv23_client_method == NULL) {\n    snprintf(ebuf, ebuf_len, \"%s\", \"SSL is not initialized\");\n  } else if ((he = gethostbyname(host)) == NULL) {\n    snprintf(ebuf, ebuf_len, \"gethostbyname(%s): %s\", host, strerror(ERRNO));\n  } else if ((sock = socket(PF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET) {\n    snprintf(ebuf, ebuf_len, \"socket(): %s\", strerror(ERRNO));\n  } else {\n    sin.sin_family = AF_INET;\n    sin.sin_port = htons((uint16_t) port);\n    sin.sin_addr = * (struct in_addr *) he->h_addr_list[0];\n    if (connect(sock, (struct sockaddr *) &sin, sizeof(sin)) != 0) {\n      snprintf(ebuf, ebuf_len, \"connect(%s:%d): %s\",\n               host, port, strerror(ERRNO));\n      closesocket(sock);\n    } else if ((conn = (struct mg_connection *)\n                calloc(1, sizeof(*conn) + MAX_REQUEST_SIZE)) == NULL) {\n      snprintf(ebuf, ebuf_len, \"calloc(): %s\", strerror(ERRNO));\n      closesocket(sock);\n#ifndef NO_SSL\n    } else if (use_ssl && (conn->client_ssl_ctx =\n                           SSL_CTX_new(SSLv23_client_method())) == NULL) {\n      snprintf(ebuf, ebuf_len, \"SSL_CTX_new error\");\n      closesocket(sock);\n      free(conn);\n      conn = NULL;\n#endif // NO_SSL\n    } else {\n      conn->buf_size = MAX_REQUEST_SIZE;\n      conn->buf = (char *) (conn + 1);\n      conn->ctx = &fake_ctx;\n      conn->client.sock = sock;\n      conn->client.rsa.sin = sin;\n      conn->client.is_ssl = use_ssl;\n#ifndef NO_SSL\n      if (use_ssl) {\n        // SSL_CTX_set_verify call is needed to switch off server certificate\n        // checking, which is off by default in OpenSSL and on in yaSSL.\n        SSL_CTX_set_verify(conn->client_ssl_ctx, 0, 0);\n        sslize(conn, conn->client_ssl_ctx, SSL_connect);\n      }\n#endif\n    }\n  }\n\n  return conn;\n}\n\nstatic int is_valid_uri(const char *uri) {\n  // Conform to http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1.2\n  // URI can be an asterisk (*) or should start with slash.\n  return uri[0] == '/' || (uri[0] == '*' && uri[1] == '\\0');\n}\n\nstatic int getreq(struct mg_connection *conn, char *ebuf, size_t ebuf_len) {\n  const char *cl;\n\n  ebuf[0] = '\\0';\n  reset_per_request_attributes(conn);\n  conn->request_len = read_request(NULL, conn, conn->buf, conn->buf_size,\n                                   &conn->data_len);\n  assert(conn->request_len < 0 || conn->data_len >= conn->request_len);\n\n  if (conn->request_len == 0 && conn->data_len == conn->buf_size) {\n    snprintf(ebuf, ebuf_len, \"%s\", \"Request Too Large\");\n  } if (conn->request_len <= 0) {\n    snprintf(ebuf, ebuf_len, \"%s\", \"Client closed connection\");\n  } else if (parse_http_message(conn->buf, conn->buf_size,\n                                &conn->request_info) <= 0) {\n    snprintf(ebuf, ebuf_len, \"Bad request: [%.*s]\", conn->data_len, conn->buf);\n  } else {\n    // Request is valid\n    if ((cl = get_header(&conn->request_info, \"Content-Length\")) != NULL) {\n      conn->content_len = strtoll(cl, NULL, 10);\n    } else if (!mg_strcasecmp(conn->request_info.request_method, \"POST\") ||\n               !mg_strcasecmp(conn->request_info.request_method, \"PUT\")) {\n      conn->content_len = -1;\n    } else {\n      conn->content_len = 0;\n    }\n    conn->birth_time = time(NULL);\n  }\n  return ebuf[0] == '\\0';\n}\n\nstruct mg_connection *mg_download(const char *host, int port, int use_ssl,\n                                  char *ebuf, size_t ebuf_len,\n                                  const char *fmt, ...) {\n  struct mg_connection *conn;\n  va_list ap;\n\n  va_start(ap, fmt);\n  ebuf[0] = '\\0';\n  if ((conn = mg_connect(host, port, use_ssl, ebuf, ebuf_len)) == NULL) {\n  } else if (mg_vprintf(conn, fmt, ap) <= 0) {\n    snprintf(ebuf, ebuf_len, \"%s\", \"Error sending request\");\n  } else {\n    getreq(conn, ebuf, ebuf_len);\n  }\n  if (ebuf[0] != '\\0' && conn != NULL) {\n    mg_close_connection(conn);\n    conn = NULL;\n  }\n\n  return conn;\n}\n\nstatic void process_new_connection(struct mg_connection *conn) {\n  struct mg_request_info *ri = &conn->request_info;\n  int keep_alive_enabled, keep_alive, discard_len;\n  char ebuf[100];\n\n  keep_alive_enabled = !strcmp(conn->ctx->config[ENABLE_KEEP_ALIVE], \"yes\");\n  keep_alive = 0;\n\n  // Important: on new connection, reset the receiving buffer. Credit goes\n  // to crule42.\n  conn->data_len = 0;\n  do {\n    if (!getreq(conn, ebuf, sizeof(ebuf))) {\n      send_http_error(conn, 500, \"Server Error\", \"%s\", ebuf);\n    } else if (!is_valid_uri(conn->request_info.uri)) {\n      snprintf(ebuf, sizeof(ebuf), \"Invalid URI: [%s]\", ri->uri);\n      send_http_error(conn, 400, \"Bad Request\", \"%s\", ebuf);\n    } else if (strcmp(ri->http_version, \"1.0\") &&\n               strcmp(ri->http_version, \"1.1\")) {\n      snprintf(ebuf, sizeof(ebuf), \"Bad HTTP version: [%s]\", ri->http_version);\n      send_http_error(conn, 505, \"Bad HTTP version\", \"%s\", ebuf);\n    }\n\n    if (ebuf[0] == '\\0') {\n      handle_request(conn);\n      if (conn->ctx->callbacks.end_request != NULL) {\n        conn->ctx->callbacks.end_request(conn, conn->status_code);\n      }\n      log_access(conn);\n    }\n    if (ri->remote_user != NULL) {\n      free((void *) ri->remote_user);\n    }\n\n    // NOTE(lsm): order is important here. should_keep_alive() call\n    // is using parsed request, which will be invalid after memmove's below.\n    // Therefore, memorize should_keep_alive() result now for later use\n    // in loop exit condition.\n    keep_alive = should_keep_alive(conn);\n\n    // Discard all buffered data for this request\n    discard_len = conn->content_len >= 0 &&\n      conn->request_len + conn->content_len < (int64_t) conn->data_len ?\n      (int) (conn->request_len + conn->content_len) : conn->data_len;\n    memmove(conn->buf, conn->buf + discard_len, conn->data_len - discard_len);\n    conn->data_len -= discard_len;\n    assert(conn->data_len >= 0);\n    assert(conn->data_len <= conn->buf_size);\n\n  } while (conn->ctx->stop_flag == 0 &&\n           keep_alive_enabled &&\n           conn->content_len >= 0 &&\n           keep_alive);\n}\n\n// Worker threads take accepted socket from the queue\nstatic int consume_socket(struct mg_context *ctx, struct socket *sp) {\n  (void) pthread_mutex_lock(&ctx->mutex);\n  DEBUG_TRACE((\"going idle\"));\n\n  // If the queue is empty, wait. We're idle at this point.\n  while (ctx->sq_head == ctx->sq_tail && ctx->stop_flag == 0) {\n    pthread_cond_wait(&ctx->sq_full, &ctx->mutex);\n  }\n\n  // If we're stopping, sq_head may be equal to sq_tail.\n  if (ctx->sq_head > ctx->sq_tail) {\n    // Copy socket from the queue and increment tail\n    *sp = ctx->queue[ctx->sq_tail % ARRAY_SIZE(ctx->queue)];\n    ctx->sq_tail++;\n    DEBUG_TRACE((\"grabbed socket %d, going busy\", sp->sock));\n\n    // Wrap pointers if needed\n    while (ctx->sq_tail > (int) ARRAY_SIZE(ctx->queue)) {\n      ctx->sq_tail -= ARRAY_SIZE(ctx->queue);\n      ctx->sq_head -= ARRAY_SIZE(ctx->queue);\n    }\n  }\n\n  (void) pthread_cond_signal(&ctx->sq_empty);\n  (void) pthread_mutex_unlock(&ctx->mutex);\n\n  return !ctx->stop_flag;\n}\n\nstatic void *worker_thread(void *thread_func_param) {\n  struct mg_context *ctx = thread_func_param;\n  struct mg_connection *conn;\n\n  conn = (struct mg_connection *) calloc(1, sizeof(*conn) + MAX_REQUEST_SIZE);\n  if (conn == NULL) {\n    cry(fc(ctx), \"%s\", \"Cannot create new connection struct, OOM\");\n  } else {\n    conn->buf_size = MAX_REQUEST_SIZE;\n    conn->buf = (char *) (conn + 1);\n    conn->ctx = ctx;\n    conn->request_info.user_data = ctx->user_data;\n\n    // Call consume_socket() even when ctx->stop_flag > 0, to let it signal\n    // sq_empty condvar to wake up the master waiting in produce_socket()\n    while (consume_socket(ctx, &conn->client)) {\n      conn->birth_time = time(NULL);\n\n      // Fill in IP, port info early so even if SSL setup below fails,\n      // error handler would have the corresponding info.\n      // Thanks to Johannes Winkelmann for the patch.\n      // TODO(lsm): Fix IPv6 case\n      conn->request_info.remote_port = ntohs(conn->client.rsa.sin.sin_port);\n      memcpy(&conn->request_info.remote_ip,\n             &conn->client.rsa.sin.sin_addr.s_addr, 4);\n      conn->request_info.remote_ip = ntohl(conn->request_info.remote_ip);\n      conn->request_info.is_ssl = conn->client.is_ssl;\n\n      if (!conn->client.is_ssl\n#ifndef NO_SSL\n          || sslize(conn, conn->ctx->ssl_ctx, SSL_accept)\n#endif\n         ) {\n        process_new_connection(conn);\n      }\n\n      close_connection(conn);\n    }\n    free(conn);\n  }\n\n  // Signal master that we're done with connection and exiting\n  (void) pthread_mutex_lock(&ctx->mutex);\n  ctx->num_threads--;\n  (void) pthread_cond_signal(&ctx->cond);\n  assert(ctx->num_threads >= 0);\n  (void) pthread_mutex_unlock(&ctx->mutex);\n\n  DEBUG_TRACE((\"exiting\"));\n  return NULL;\n}\n\n// Master thread adds accepted socket to a queue\nstatic void produce_socket(struct mg_context *ctx, const struct socket *sp) {\n  (void) pthread_mutex_lock(&ctx->mutex);\n\n  // If the queue is full, wait\n  while (ctx->stop_flag == 0 &&\n         ctx->sq_head - ctx->sq_tail >= (int) ARRAY_SIZE(ctx->queue)) {\n    (void) pthread_cond_wait(&ctx->sq_empty, &ctx->mutex);\n  }\n\n  if (ctx->sq_head - ctx->sq_tail < (int) ARRAY_SIZE(ctx->queue)) {\n    // Copy socket to the queue and increment head\n    ctx->queue[ctx->sq_head % ARRAY_SIZE(ctx->queue)] = *sp;\n    ctx->sq_head++;\n    DEBUG_TRACE((\"queued socket %d\", sp->sock));\n  }\n\n  (void) pthread_cond_signal(&ctx->sq_full);\n  (void) pthread_mutex_unlock(&ctx->mutex);\n}\n\nstatic int set_sock_timeout(SOCKET sock, int milliseconds) {\n#ifdef _WIN32\n  DWORD t = milliseconds;\n#else\n  struct timeval t;\n  t.tv_sec = milliseconds / 1000;\n  t.tv_usec = (milliseconds * 1000) % 1000000;\n#endif\n  return setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, (void *) &t, sizeof(t)) ||\n    setsockopt(sock, SOL_SOCKET, SO_SNDTIMEO, (void *) &t, sizeof(t));\n}\n\nstatic void accept_new_connection(const struct socket *listener,\n                                  struct mg_context *ctx) {\n  struct socket so;\n  char src_addr[20];\n  socklen_t len = sizeof(so.rsa);\n  int on = 1;\n\n  if ((so.sock = accept(listener->sock, &so.rsa.sa, &len)) == INVALID_SOCKET) {\n  } else if (!check_acl(ctx, ntohl(* (uint32_t *) &so.rsa.sin.sin_addr))) {\n    sockaddr_to_string(src_addr, sizeof(src_addr), &so.rsa);\n    cry(fc(ctx), \"%s: %s is not allowed to connect\", __func__, src_addr);\n    closesocket(so.sock);\n  } else {\n    // Put so socket structure into the queue\n    DEBUG_TRACE((\"Accepted socket %d\", (int) so.sock));\n    so.is_ssl = listener->is_ssl;\n    so.ssl_redir = listener->ssl_redir;\n    getsockname(so.sock, &so.lsa.sa, &len);\n    // Set TCP keep-alive. This is needed because if HTTP-level keep-alive\n    // is enabled, and client resets the connection, server won't get\n    // TCP FIN or RST and will keep the connection open forever. With TCP\n    // keep-alive, next keep-alive handshake will figure out that the client\n    // is down and will close the server end.\n    // Thanks to Igor Klopov who suggested the patch.\n    setsockopt(so.sock, SOL_SOCKET, SO_KEEPALIVE, (void *) &on, sizeof(on));\n    set_sock_timeout(so.sock, atoi(ctx->config[REQUEST_TIMEOUT]));\n    produce_socket(ctx, &so);\n  }\n}\n\nstatic void *master_thread(void *thread_func_param) {\n  struct mg_context *ctx = thread_func_param;\n  struct pollfd *pfd;\n  int i;\n\n  // Increase priority of the master thread\n#if defined(_WIN32)\n  SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_ABOVE_NORMAL);\n#endif\n\n#if defined(ISSUE_317)\n  struct sched_param sched_param;\n  sched_param.sched_priority = sched_get_priority_max(SCHED_RR);\n  pthread_setschedparam(pthread_self(), SCHED_RR, &sched_param);\n#endif\n\n  pfd = calloc(ctx->num_listening_sockets, sizeof(pfd[0]));\n  while (ctx->stop_flag == 0) {\n    for (i = 0; i < ctx->num_listening_sockets; i++) {\n      pfd[i].fd = ctx->listening_sockets[i].sock;\n      pfd[i].events = POLLIN;\n    }\n\n    if (poll(pfd, ctx->num_listening_sockets, 200) > 0) {\n      for (i = 0; i < ctx->num_listening_sockets; i++) {\n        if (ctx->stop_flag == 0 && pfd[i].revents == POLLIN) {\n          accept_new_connection(&ctx->listening_sockets[i], ctx);\n        }\n      }\n    }\n  }\n  free(pfd);\n  DEBUG_TRACE((\"stopping workers\"));\n\n  // Stop signal received: somebody called mg_stop. Quit.\n  close_all_listening_sockets(ctx);\n\n  // Wakeup workers that are waiting for connections to handle.\n  pthread_cond_broadcast(&ctx->sq_full);\n\n  // Wait until all threads finish\n  (void) pthread_mutex_lock(&ctx->mutex);\n  while (ctx->num_threads > 0) {\n    (void) pthread_cond_wait(&ctx->cond, &ctx->mutex);\n  }\n  (void) pthread_mutex_unlock(&ctx->mutex);\n\n  // All threads exited, no sync is needed. Destroy mutex and condvars\n  (void) pthread_mutex_destroy(&ctx->mutex);\n  (void) pthread_cond_destroy(&ctx->cond);\n  (void) pthread_cond_destroy(&ctx->sq_empty);\n  (void) pthread_cond_destroy(&ctx->sq_full);\n\n#if !defined(NO_SSL)\n  uninitialize_ssl(ctx);\n#endif\n  DEBUG_TRACE((\"exiting\"));\n\n  // Signal mg_stop() that we're done.\n  // WARNING: This must be the very last thing this\n  // thread does, as ctx becomes invalid after this line.\n  ctx->stop_flag = 2;\n  return NULL;\n}\n\nstatic void free_context(struct mg_context *ctx) {\n  int i;\n\n  // Deallocate config parameters\n  for (i = 0; i < NUM_OPTIONS; i++) {\n    if (ctx->config[i] != NULL)\n      free(ctx->config[i]);\n  }\n\n#ifndef NO_SSL\n  // Deallocate SSL context\n  if (ctx->ssl_ctx != NULL) {\n    SSL_CTX_free(ctx->ssl_ctx);\n  }\n  if (ssl_mutexes != NULL) {\n    free(ssl_mutexes);\n    ssl_mutexes = NULL;\n  }\n#endif // !NO_SSL\n\n  // Deallocate context itself\n  free(ctx);\n}\n\nvoid mg_stop(struct mg_context *ctx) {\n  ctx->stop_flag = 1;\n\n  // Wait until mg_fini() stops\n  while (ctx->stop_flag != 2) {\n    (void) mg_sleep(10);\n  }\n  free_context(ctx);\n\n#if defined(_WIN32) && !defined(__SYMBIAN32__)\n  (void) WSACleanup();\n#endif // _WIN32\n}\n\nstruct mg_context *mg_start(const struct mg_callbacks *callbacks,\n                            void *user_data,\n                            const char **options) {\n  struct mg_context *ctx;\n  const char *name, *value, *default_value;\n  int i;\n\n#if defined(_WIN32) && !defined(__SYMBIAN32__)\n  WSADATA data;\n  WSAStartup(MAKEWORD(2,2), &data);\n  InitializeCriticalSection(&global_log_file_lock);\n#endif // _WIN32\n\n  // Allocate context and initialize reasonable general case defaults.\n  // TODO(lsm): do proper error handling here.\n  if ((ctx = (struct mg_context *) calloc(1, sizeof(*ctx))) == NULL) {\n    return NULL;\n  }\n  ctx->callbacks = *callbacks;\n  ctx->user_data = user_data;\n\n  while (options && (name = *options++) != NULL) {\n    if ((i = get_option_index(name)) == -1) {\n      cry(fc(ctx), \"Invalid option: %s\", name);\n      free_context(ctx);\n      return NULL;\n    } else if ((value = *options++) == NULL) {\n      cry(fc(ctx), \"%s: option value cannot be NULL\", name);\n      free_context(ctx);\n      return NULL;\n    }\n    if (ctx->config[i] != NULL) {\n      cry(fc(ctx), \"warning: %s: duplicate option\", name);\n      free(ctx->config[i]);\n    }\n    ctx->config[i] = mg_strdup(value);\n    DEBUG_TRACE((\"[%s] -> [%s]\", name, value));\n  }\n\n  // Set default value if needed\n  for (i = 0; config_options[i * ENTRIES_PER_CONFIG_OPTION] != NULL; i++) {\n    default_value = config_options[i * ENTRIES_PER_CONFIG_OPTION + 2];\n    if (ctx->config[i] == NULL && default_value != NULL) {\n      ctx->config[i] = mg_strdup(default_value);\n      DEBUG_TRACE((\"Setting default: [%s] -> [%s]\",\n                   config_options[i * ENTRIES_PER_CONFIG_OPTION + 1],\n                   default_value));\n    }\n  }\n\n  // NOTE(lsm): order is important here. SSL certificates must\n  // be initialized before listening ports. UID must be set last.\n  if (!set_gpass_option(ctx) ||\n#if !defined(NO_SSL)\n      !set_ssl_option(ctx) ||\n#endif\n      !set_ports_option(ctx) ||\n#if !defined(_WIN32)\n      !set_uid_option(ctx) ||\n#endif\n      !set_acl_option(ctx)) {\n    free_context(ctx);\n    return NULL;\n  }\n\n#if !defined(_WIN32) && !defined(__SYMBIAN32__)\n  // Ignore SIGPIPE signal, so if browser cancels the request, it\n  // won't kill the whole process.\n  (void) signal(SIGPIPE, SIG_IGN);\n  // Also ignoring SIGCHLD to let the OS to reap zombies properly.\n  (void) signal(SIGCHLD, SIG_IGN);\n#endif // !_WIN32\n\n  (void) pthread_mutex_init(&ctx->mutex, NULL);\n  (void) pthread_cond_init(&ctx->cond, NULL);\n  (void) pthread_cond_init(&ctx->sq_empty, NULL);\n  (void) pthread_cond_init(&ctx->sq_full, NULL);\n\n  // Start master (listening) thread\n  mg_start_thread(master_thread, ctx);\n\n  // Start worker threads\n  for (i = 0; i < atoi(ctx->config[NUM_THREADS]); i++) {\n    if (mg_start_thread(worker_thread, ctx) != 0) {\n      cry(fc(ctx), \"Cannot start worker thread: %d\", ERRNO);\n    } else {\n      ctx->num_threads++;\n    }\n  }\n\n  return ctx;\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-saws-develop-zqo76cxj3ulpp5ka4xq64qfxm62zubta/spack-src/software_discl_form.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-saws-develop-zqo76cxj3ulpp5ka4xq64qfxm62zubta/spack-src/doc/manual/TitlePage.doc",
        "/tmp/vanessa/spack-stage/spack-stage-saws-develop-zqo76cxj3ulpp5ka4xq64qfxm62zubta/spack-src/doc/manual/SAWs.pdf"
    ],
    "total_files": 40
}