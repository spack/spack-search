{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-openssh-8.4p1-gs222i4ctitv7fl27wgnurjoqoks3e7r/spack-src/config.h.in": "/* config.h.in.  Generated from configure.ac by autoheader.  */\n\n/* Define if building universal (internal helper macro) */\n#undef AC_APPLE_UNIVERSAL_BUILD\n\n/* Define if you have a getaddrinfo that fails for the all-zeros IPv6 address\n   */\n#undef AIX_GETNAMEINFO_HACK\n\n/* Define if your AIX loginfailed() function takes 4 arguments (AIX >= 5.2) */\n#undef AIX_LOGINFAILED_4ARG\n\n/* System only supports IPv4 audit records */\n#undef AU_IPv4\n\n/* Define if your resolver libs need this for getrrsetbyname */\n#undef BIND_8_COMPAT\n\n/* The system has incomplete BSM API */\n#undef BROKEN_BSM_API\n\n/* Define if cmsg_type is not passed correctly */\n#undef BROKEN_CMSG_TYPE\n\n/* getaddrinfo is broken (if present) */\n#undef BROKEN_GETADDRINFO\n\n/* getgroups(0,NULL) will return -1 */\n#undef BROKEN_GETGROUPS\n\n/* FreeBSD glob does not do what we need */\n#undef BROKEN_GLOB\n\n/* Define if you system's inet_ntoa is busted (e.g. Irix gcc issue) */\n#undef BROKEN_INET_NTOA\n\n/* Define if your struct dirent expects you to allocate extra space for d_name\n   */\n#undef BROKEN_ONE_BYTE_DIRENT_D_NAME\n\n/* Can't do comparisons on readv */\n#undef BROKEN_READV_COMPARISON\n\n/* NetBSD read function is sometimes redirected, breaking atomicio comparisons\n   against it */\n#undef BROKEN_READ_COMPARISON\n\n/* Needed for NeXT */\n#undef BROKEN_SAVED_UIDS\n\n/* Define if your setregid() is broken */\n#undef BROKEN_SETREGID\n\n/* Define if your setresgid() is broken */\n#undef BROKEN_SETRESGID\n\n/* Define if your setresuid() is broken */\n#undef BROKEN_SETRESUID\n\n/* Define if your setreuid() is broken */\n#undef BROKEN_SETREUID\n\n/* LynxOS has broken setvbuf() implementation */\n#undef BROKEN_SETVBUF\n\n/* QNX shadow support is broken */\n#undef BROKEN_SHADOW_EXPIRE\n\n/* Define if your snprintf is busted */\n#undef BROKEN_SNPRINTF\n\n/* strndup broken, see APAR IY61211 */\n#undef BROKEN_STRNDUP\n\n/* strnlen broken, see APAR IY62551 */\n#undef BROKEN_STRNLEN\n\n/* strnvis detected broken */\n#undef BROKEN_STRNVIS\n\n/* tcgetattr with ICANON may hang */\n#undef BROKEN_TCGETATTR_ICANON\n\n/* updwtmpx is broken (if present) */\n#undef BROKEN_UPDWTMPX\n\n/* Define if you have BSD auth support */\n#undef BSD_AUTH\n\n/* Define if you want to specify the path to your lastlog file */\n#undef CONF_LASTLOG_FILE\n\n/* Define if you want to specify the path to your utmp file */\n#undef CONF_UTMP_FILE\n\n/* Define if you want to specify the path to your wtmpx file */\n#undef CONF_WTMPX_FILE\n\n/* Define if you want to specify the path to your wtmp file */\n#undef CONF_WTMP_FILE\n\n/* Need to call setpgrp as root */\n#undef DISABLE_FD_PASSING\n\n/* Define if you don't want to use lastlog */\n#undef DISABLE_LASTLOG\n\n/* Define if you don't want to use your system's login() call */\n#undef DISABLE_LOGIN\n\n/* Define if you don't want to use pututline() etc. to write [uw]tmp */\n#undef DISABLE_PUTUTLINE\n\n/* Define if you don't want to use pututxline() etc. to write [uw]tmpx */\n#undef DISABLE_PUTUTXLINE\n\n/* Define if you want to disable shadow passwords */\n#undef DISABLE_SHADOW\n\n/* Define if you don't want to use utmp */\n#undef DISABLE_UTMP\n\n/* Define if you don't want to use utmpx */\n#undef DISABLE_UTMPX\n\n/* Define if you don't want to use wtmp */\n#undef DISABLE_WTMP\n\n/* Define if you don't want to use wtmpx */\n#undef DISABLE_WTMPX\n\n/* Enable for PKCS#11 support */\n#undef ENABLE_PKCS11\n\n/* Enable for U2F/FIDO support */\n#undef ENABLE_SK\n\n/* Enable for built-in U2F/FIDO support */\n#undef ENABLE_SK_INTERNAL\n\n/* define if fflush(NULL) does not work */\n#undef FFLUSH_NULL_BUG\n\n/* File names may not contain backslash characters */\n#undef FILESYSTEM_NO_BACKSLASH\n\n/* fsid_t has member val */\n#undef FSID_HAS_VAL\n\n/* fsid_t has member __val */\n#undef FSID_HAS___VAL\n\n/* getpgrp takes one arg */\n#undef GETPGRP_VOID\n\n/* Conflicting defs for getspnam */\n#undef GETSPNAM_CONFLICTING_DEFS\n\n/* Define if your system glob() function has the GLOB_ALTDIRFUNC extension */\n#undef GLOB_HAS_ALTDIRFUNC\n\n/* Define if your system glob() function has gl_matchc options in glob_t */\n#undef GLOB_HAS_GL_MATCHC\n\n/* Define if your system glob() function has gl_statv options in glob_t */\n#undef GLOB_HAS_GL_STATV\n\n/* Define this if you want GSSAPI support in the version 2 protocol */\n#undef GSSAPI\n\n/* Define if you want to use shadow password expire field */\n#undef HAS_SHADOW_EXPIRE\n\n/* Define if your system uses access rights style file descriptor passing */\n#undef HAVE_ACCRIGHTS_IN_MSGHDR\n\n/* Define if you have ut_addr in utmp.h */\n#undef HAVE_ADDR_IN_UTMP\n\n/* Define if you have ut_addr in utmpx.h */\n#undef HAVE_ADDR_IN_UTMPX\n\n/* Define if you have ut_addr_v6 in utmp.h */\n#undef HAVE_ADDR_V6_IN_UTMP\n\n/* Define if you have ut_addr_v6 in utmpx.h */\n#undef HAVE_ADDR_V6_IN_UTMPX\n\n/* Define to 1 if you have the `arc4random' function. */\n#undef HAVE_ARC4RANDOM\n\n/* Define to 1 if you have the `arc4random_buf' function. */\n#undef HAVE_ARC4RANDOM_BUF\n\n/* Define to 1 if you have the `arc4random_stir' function. */\n#undef HAVE_ARC4RANDOM_STIR\n\n/* Define to 1 if you have the `arc4random_uniform' function. */\n#undef HAVE_ARC4RANDOM_UNIFORM\n\n/* Define to 1 if you have the `asprintf' function. */\n#undef HAVE_ASPRINTF\n\n/* OpenBSD's gcc has bounded */\n#undef HAVE_ATTRIBUTE__BOUNDED__\n\n/* Have attribute nonnull */\n#undef HAVE_ATTRIBUTE__NONNULL__\n\n/* OpenBSD's gcc has sentinel */\n#undef HAVE_ATTRIBUTE__SENTINEL__\n\n/* Define to 1 if you have the `aug_get_machine' function. */\n#undef HAVE_AUG_GET_MACHINE\n\n/* Define to 1 if you have the `b64_ntop' function. */\n#undef HAVE_B64_NTOP\n\n/* Define to 1 if you have the `b64_pton' function. */\n#undef HAVE_B64_PTON\n\n/* Define if you have the basename function. */\n#undef HAVE_BASENAME\n\n/* Define to 1 if you have the `bcopy' function. */\n#undef HAVE_BCOPY\n\n/* Define to 1 if you have the `bcrypt_pbkdf' function. */\n#undef HAVE_BCRYPT_PBKDF\n\n/* Define to 1 if you have the `bindresvport_sa' function. */\n#undef HAVE_BINDRESVPORT_SA\n\n/* Define to 1 if you have the `blf_enc' function. */\n#undef HAVE_BLF_ENC\n\n/* Define to 1 if you have the <blf.h> header file. */\n#undef HAVE_BLF_H\n\n/* Define to 1 if you have the `Blowfish_expand0state' function. */\n#undef HAVE_BLOWFISH_EXPAND0STATE\n\n/* Define to 1 if you have the `Blowfish_expandstate' function. */\n#undef HAVE_BLOWFISH_EXPANDSTATE\n\n/* Define to 1 if you have the `Blowfish_initstate' function. */\n#undef HAVE_BLOWFISH_INITSTATE\n\n/* Define to 1 if you have the `Blowfish_stream2word' function. */\n#undef HAVE_BLOWFISH_STREAM2WORD\n\n/* Define to 1 if you have the `BN_is_prime_ex' function. */\n#undef HAVE_BN_IS_PRIME_EX\n\n/* Define to 1 if you have the <bsd/libutil.h> header file. */\n#undef HAVE_BSD_LIBUTIL_H\n\n/* Define to 1 if you have the <bsm/audit.h> header file. */\n#undef HAVE_BSM_AUDIT_H\n\n/* Define to 1 if you have the <bstring.h> header file. */\n#undef HAVE_BSTRING_H\n\n/* Define to 1 if you have the `bzero' function. */\n#undef HAVE_BZERO\n\n/* calloc(0, x) returns NULL */\n#undef HAVE_CALLOC\n\n/* Define to 1 if you have the `cap_rights_limit' function. */\n#undef HAVE_CAP_RIGHTS_LIMIT\n\n/* Define to 1 if you have the `clock' function. */\n#undef HAVE_CLOCK\n\n/* Have clock_gettime */\n#undef HAVE_CLOCK_GETTIME\n\n/* define if you have clock_t data type */\n#undef HAVE_CLOCK_T\n\n/* Define to 1 if you have the `closefrom' function. */\n#undef HAVE_CLOSEFROM\n\n/* Define if gai_strerror() returns const char * */\n#undef HAVE_CONST_GAI_STRERROR_PROTO\n\n/* Define if your system uses ancillary data style file descriptor passing */\n#undef HAVE_CONTROL_IN_MSGHDR\n\n/* Define to 1 if you have the `crypt' function. */\n#undef HAVE_CRYPT\n\n/* Define to 1 if you have the <crypto/sha2.h> header file. */\n#undef HAVE_CRYPTO_SHA2_H\n\n/* Define to 1 if you have the <crypt.h> header file. */\n#undef HAVE_CRYPT_H\n\n/* Define if you are on Cygwin */\n#undef HAVE_CYGWIN\n\n/* Define if your libraries define daemon() */\n#undef HAVE_DAEMON\n\n/* Define to 1 if you have the declaration of `AI_NUMERICSERV', and to 0 if\n   you don't. */\n#undef HAVE_DECL_AI_NUMERICSERV\n\n/* Define to 1 if you have the declaration of `authenticate', and to 0 if you\n   don't. */\n#undef HAVE_DECL_AUTHENTICATE\n\n/* Define to 1 if you have the declaration of `bzero', and to 0 if you don't.\n   */\n#undef HAVE_DECL_BZERO\n\n/* Define to 1 if you have the declaration of `getpeereid', and to 0 if you\n   don't. */\n#undef HAVE_DECL_GETPEEREID\n\n/* Define to 1 if you have the declaration of `GLOB_NOMATCH', and to 0 if you\n   don't. */\n#undef HAVE_DECL_GLOB_NOMATCH\n\n/* Define to 1 if you have the declaration of `GSS_C_NT_HOSTBASED_SERVICE',\n   and to 0 if you don't. */\n#undef HAVE_DECL_GSS_C_NT_HOSTBASED_SERVICE\n\n/* Define to 1 if you have the declaration of `howmany', and to 0 if you\n   don't. */\n#undef HAVE_DECL_HOWMANY\n\n/* Define to 1 if you have the declaration of `h_errno', and to 0 if you\n   don't. */\n#undef HAVE_DECL_H_ERRNO\n\n/* Define to 1 if you have the declaration of `loginfailed', and to 0 if you\n   don't. */\n#undef HAVE_DECL_LOGINFAILED\n\n/* Define to 1 if you have the declaration of `loginrestrictions', and to 0 if\n   you don't. */\n#undef HAVE_DECL_LOGINRESTRICTIONS\n\n/* Define to 1 if you have the declaration of `loginsuccess', and to 0 if you\n   don't. */\n#undef HAVE_DECL_LOGINSUCCESS\n\n/* Define to 1 if you have the declaration of `MAXSYMLINKS', and to 0 if you\n   don't. */\n#undef HAVE_DECL_MAXSYMLINKS\n\n/* Define to 1 if you have the declaration of `memmem', and to 0 if you don't.\n   */\n#undef HAVE_DECL_MEMMEM\n\n/* Define to 1 if you have the declaration of `NFDBITS', and to 0 if you\n   don't. */\n#undef HAVE_DECL_NFDBITS\n\n/* Define to 1 if you have the declaration of `offsetof', and to 0 if you\n   don't. */\n#undef HAVE_DECL_OFFSETOF\n\n/* Define to 1 if you have the declaration of `O_NONBLOCK', and to 0 if you\n   don't. */\n#undef HAVE_DECL_O_NONBLOCK\n\n/* Define to 1 if you have the declaration of `passwdexpired', and to 0 if you\n   don't. */\n#undef HAVE_DECL_PASSWDEXPIRED\n\n/* Define to 1 if you have the declaration of `readv', and to 0 if you don't.\n   */\n#undef HAVE_DECL_READV\n\n/* Define to 1 if you have the declaration of `setauthdb', and to 0 if you\n   don't. */\n#undef HAVE_DECL_SETAUTHDB\n\n/* Define to 1 if you have the declaration of `SHUT_RD', and to 0 if you\n   don't. */\n#undef HAVE_DECL_SHUT_RD\n\n/* Define to 1 if you have the declaration of `UINT32_MAX', and to 0 if you\n   don't. */\n#undef HAVE_DECL_UINT32_MAX\n\n/* Define to 1 if you have the declaration of `writev', and to 0 if you don't.\n   */\n#undef HAVE_DECL_WRITEV\n\n/* Define to 1 if you have the declaration of `_getlong', and to 0 if you\n   don't. */\n#undef HAVE_DECL__GETLONG\n\n/* Define to 1 if you have the declaration of `_getshort', and to 0 if you\n   don't. */\n#undef HAVE_DECL__GETSHORT\n\n/* Define to 1 if you have the `DES_crypt' function. */\n#undef HAVE_DES_CRYPT\n\n/* Define if you have /dev/ptmx */\n#undef HAVE_DEV_PTMX\n\n/* Define if you have /dev/ptc */\n#undef HAVE_DEV_PTS_AND_PTC\n\n/* Define to 1 if you have the `DH_get0_key' function. */\n#undef HAVE_DH_GET0_KEY\n\n/* Define to 1 if you have the `DH_get0_pqg' function. */\n#undef HAVE_DH_GET0_PQG\n\n/* Define to 1 if you have the `DH_set0_key' function. */\n#undef HAVE_DH_SET0_KEY\n\n/* Define to 1 if you have the `DH_set0_pqg' function. */\n#undef HAVE_DH_SET0_PQG\n\n/* Define to 1 if you have the `DH_set_length' function. */\n#undef HAVE_DH_SET_LENGTH\n\n/* Define to 1 if you have the <dirent.h> header file. */\n#undef HAVE_DIRENT_H\n\n/* Define to 1 if you have the `dirfd' function. */\n#undef HAVE_DIRFD\n\n/* Define to 1 if you have the `dirname' function. */\n#undef HAVE_DIRNAME\n\n/* Define to 1 if you have the `dlopen' function. */\n#undef HAVE_DLOPEN\n\n/* Define to 1 if you have the `DSA_generate_parameters_ex' function. */\n#undef HAVE_DSA_GENERATE_PARAMETERS_EX\n\n/* Define to 1 if you have the `DSA_get0_key' function. */\n#undef HAVE_DSA_GET0_KEY\n\n/* Define to 1 if you have the `DSA_get0_pqg' function. */\n#undef HAVE_DSA_GET0_PQG\n\n/* Define to 1 if you have the `DSA_set0_key' function. */\n#undef HAVE_DSA_SET0_KEY\n\n/* Define to 1 if you have the `DSA_set0_pqg' function. */\n#undef HAVE_DSA_SET0_PQG\n\n/* Define to 1 if you have the `DSA_SIG_get0' function. */\n#undef HAVE_DSA_SIG_GET0\n\n/* Define to 1 if you have the `DSA_SIG_set0' function. */\n#undef HAVE_DSA_SIG_SET0\n\n/* Define to 1 if you have the `ECDSA_SIG_get0' function. */\n#undef HAVE_ECDSA_SIG_GET0\n\n/* Define to 1 if you have the `ECDSA_SIG_set0' function. */\n#undef HAVE_ECDSA_SIG_SET0\n\n/* Define to 1 if you have the `EC_KEY_METHOD_new' function. */\n#undef HAVE_EC_KEY_METHOD_NEW\n\n/* Define to 1 if you have the <elf.h> header file. */\n#undef HAVE_ELF_H\n\n/* Define to 1 if you have the `endgrent' function. */\n#undef HAVE_ENDGRENT\n\n/* Define to 1 if you have the <endian.h> header file. */\n#undef HAVE_ENDIAN_H\n\n/* Define to 1 if you have the `endutent' function. */\n#undef HAVE_ENDUTENT\n\n/* Define to 1 if you have the `endutxent' function. */\n#undef HAVE_ENDUTXENT\n\n/* Define to 1 if you have the `err' function. */\n#undef HAVE_ERR\n\n/* Define to 1 if you have the `errx' function. */\n#undef HAVE_ERRX\n\n/* Define to 1 if you have the <err.h> header file. */\n#undef HAVE_ERR_H\n\n/* Define if your system has /etc/default/login */\n#undef HAVE_ETC_DEFAULT_LOGIN\n\n/* Define to 1 if you have the `EVP_chacha20' function. */\n#undef HAVE_EVP_CHACHA20\n\n/* Define to 1 if you have the `EVP_CIPHER_CTX_ctrl' function. */\n#undef HAVE_EVP_CIPHER_CTX_CTRL\n\n/* Define to 1 if you have the `EVP_CIPHER_CTX_get_iv' function. */\n#undef HAVE_EVP_CIPHER_CTX_GET_IV\n\n/* Define to 1 if you have the `EVP_CIPHER_CTX_iv' function. */\n#undef HAVE_EVP_CIPHER_CTX_IV\n\n/* Define to 1 if you have the `EVP_CIPHER_CTX_iv_noconst' function. */\n#undef HAVE_EVP_CIPHER_CTX_IV_NOCONST\n\n/* Define to 1 if you have the `EVP_CIPHER_CTX_set_iv' function. */\n#undef HAVE_EVP_CIPHER_CTX_SET_IV\n\n/* Define to 1 if you have the `EVP_DigestFinal_ex' function. */\n#undef HAVE_EVP_DIGESTFINAL_EX\n\n/* Define to 1 if you have the `EVP_DigestInit_ex' function. */\n#undef HAVE_EVP_DIGESTINIT_EX\n\n/* Define to 1 if you have the `EVP_MD_CTX_cleanup' function. */\n#undef HAVE_EVP_MD_CTX_CLEANUP\n\n/* Define to 1 if you have the `EVP_MD_CTX_copy_ex' function. */\n#undef HAVE_EVP_MD_CTX_COPY_EX\n\n/* Define to 1 if you have the `EVP_MD_CTX_free' function. */\n#undef HAVE_EVP_MD_CTX_FREE\n\n/* Define to 1 if you have the `EVP_MD_CTX_init' function. */\n#undef HAVE_EVP_MD_CTX_INIT\n\n/* Define to 1 if you have the `EVP_MD_CTX_new' function. */\n#undef HAVE_EVP_MD_CTX_NEW\n\n/* Define to 1 if you have the `EVP_PKEY_get0_RSA' function. */\n#undef HAVE_EVP_PKEY_GET0_RSA\n\n/* Define to 1 if you have the `EVP_sha256' function. */\n#undef HAVE_EVP_SHA256\n\n/* Define to 1 if you have the `EVP_sha384' function. */\n#undef HAVE_EVP_SHA384\n\n/* Define to 1 if you have the `EVP_sha512' function. */\n#undef HAVE_EVP_SHA512\n\n/* Define if you have ut_exit in utmp.h */\n#undef HAVE_EXIT_IN_UTMP\n\n/* Define to 1 if you have the `explicit_bzero' function. */\n#undef HAVE_EXPLICIT_BZERO\n\n/* Define to 1 if you have the `fchmod' function. */\n#undef HAVE_FCHMOD\n\n/* Define to 1 if you have the `fchmodat' function. */\n#undef HAVE_FCHMODAT\n\n/* Define to 1 if you have the `fchown' function. */\n#undef HAVE_FCHOWN\n\n/* Define to 1 if you have the `fchownat' function. */\n#undef HAVE_FCHOWNAT\n\n/* Use F_CLOSEM fcntl for closefrom */\n#undef HAVE_FCNTL_CLOSEM\n\n/* Define to 1 if you have the <fcntl.h> header file. */\n#undef HAVE_FCNTL_H\n\n/* Define to 1 if the system has the type `fd_mask'. */\n#undef HAVE_FD_MASK\n\n/* Define to 1 if you have the <features.h> header file. */\n#undef HAVE_FEATURES_H\n\n/* Define to 1 if you have the `fido_cred_prot' function. */\n#undef HAVE_FIDO_CRED_PROT\n\n/* Define to 1 if you have the `fido_cred_set_prot' function. */\n#undef HAVE_FIDO_CRED_SET_PROT\n\n/* Define to 1 if you have the `fido_dev_get_touch_begin' function. */\n#undef HAVE_FIDO_DEV_GET_TOUCH_BEGIN\n\n/* Define to 1 if you have the `fido_dev_get_touch_status' function. */\n#undef HAVE_FIDO_DEV_GET_TOUCH_STATUS\n\n/* Define to 1 if you have the `fido_dev_supports_cred_prot' function. */\n#undef HAVE_FIDO_DEV_SUPPORTS_CRED_PROT\n\n/* Define to 1 if you have the <floatingpoint.h> header file. */\n#undef HAVE_FLOATINGPOINT_H\n\n/* Define to 1 if you have the `flock' function. */\n#undef HAVE_FLOCK\n\n/* Define to 1 if you have the `fmt_scaled' function. */\n#undef HAVE_FMT_SCALED\n\n/* Define to 1 if you have the `fnmatch' function. */\n#undef HAVE_FNMATCH\n\n/* Define to 1 if you have the <fnmatch.h> header file. */\n#undef HAVE_FNMATCH_H\n\n/* Define to 1 if you have the `freeaddrinfo' function. */\n#undef HAVE_FREEADDRINFO\n\n/* Define to 1 if you have the `freezero' function. */\n#undef HAVE_FREEZERO\n\n/* Define to 1 if the system has the type `fsblkcnt_t'. */\n#undef HAVE_FSBLKCNT_T\n\n/* Define to 1 if the system has the type `fsfilcnt_t'. */\n#undef HAVE_FSFILCNT_T\n\n/* Define to 1 if you have the `fstatfs' function. */\n#undef HAVE_FSTATFS\n\n/* Define to 1 if you have the `fstatvfs' function. */\n#undef HAVE_FSTATVFS\n\n/* Define to 1 if you have the `futimes' function. */\n#undef HAVE_FUTIMES\n\n/* Define to 1 if you have the `gai_strerror' function. */\n#undef HAVE_GAI_STRERROR\n\n/* Define to 1 if you have the `getaddrinfo' function. */\n#undef HAVE_GETADDRINFO\n\n/* Define to 1 if you have the `getaudit' function. */\n#undef HAVE_GETAUDIT\n\n/* Define to 1 if you have the `getaudit_addr' function. */\n#undef HAVE_GETAUDIT_ADDR\n\n/* Define to 1 if you have the `getcwd' function. */\n#undef HAVE_GETCWD\n\n/* Define to 1 if you have the `getgrouplist' function. */\n#undef HAVE_GETGROUPLIST\n\n/* Define to 1 if you have the `getgrset' function. */\n#undef HAVE_GETGRSET\n\n/* Define to 1 if you have the `getlastlogxbyname' function. */\n#undef HAVE_GETLASTLOGXBYNAME\n\n/* Define to 1 if you have the `getline' function. */\n#undef HAVE_GETLINE\n\n/* Define to 1 if you have the `getluid' function. */\n#undef HAVE_GETLUID\n\n/* Define to 1 if you have the `getnameinfo' function. */\n#undef HAVE_GETNAMEINFO\n\n/* Define to 1 if you have the `getopt' function. */\n#undef HAVE_GETOPT\n\n/* Define to 1 if you have the <getopt.h> header file. */\n#undef HAVE_GETOPT_H\n\n/* Define if your getopt(3) defines and uses optreset */\n#undef HAVE_GETOPT_OPTRESET\n\n/* Define if your libraries define getpagesize() */\n#undef HAVE_GETPAGESIZE\n\n/* Define to 1 if you have the `getpeereid' function. */\n#undef HAVE_GETPEEREID\n\n/* Define to 1 if you have the `getpeerucred' function. */\n#undef HAVE_GETPEERUCRED\n\n/* Define to 1 if you have the `getpgid' function. */\n#undef HAVE_GETPGID\n\n/* Define to 1 if you have the `getpgrp' function. */\n#undef HAVE_GETPGRP\n\n/* Define to 1 if you have the `getpwanam' function. */\n#undef HAVE_GETPWANAM\n\n/* Define to 1 if you have the `getrandom' function. */\n#undef HAVE_GETRANDOM\n\n/* Define to 1 if you have the `getrlimit' function. */\n#undef HAVE_GETRLIMIT\n\n/* Define if getrrsetbyname() exists */\n#undef HAVE_GETRRSETBYNAME\n\n/* Define to 1 if you have the `getseuserbyname' function. */\n#undef HAVE_GETSEUSERBYNAME\n\n/* Define to 1 if you have the `getsid' function. */\n#undef HAVE_GETSID\n\n/* Define to 1 if you have the `gettimeofday' function. */\n#undef HAVE_GETTIMEOFDAY\n\n/* Define to 1 if you have the `getttyent' function. */\n#undef HAVE_GETTTYENT\n\n/* Define to 1 if you have the `getutent' function. */\n#undef HAVE_GETUTENT\n\n/* Define to 1 if you have the `getutid' function. */\n#undef HAVE_GETUTID\n\n/* Define to 1 if you have the `getutline' function. */\n#undef HAVE_GETUTLINE\n\n/* Define to 1 if you have the `getutxent' function. */\n#undef HAVE_GETUTXENT\n\n/* Define to 1 if you have the `getutxid' function. */\n#undef HAVE_GETUTXID\n\n/* Define to 1 if you have the `getutxline' function. */\n#undef HAVE_GETUTXLINE\n\n/* Define to 1 if you have the `getutxuser' function. */\n#undef HAVE_GETUTXUSER\n\n/* Define to 1 if you have the `get_default_context_with_level' function. */\n#undef HAVE_GET_DEFAULT_CONTEXT_WITH_LEVEL\n\n/* Define to 1 if you have the `glob' function. */\n#undef HAVE_GLOB\n\n/* Define to 1 if you have the <glob.h> header file. */\n#undef HAVE_GLOB_H\n\n/* Define to 1 if you have the `group_from_gid' function. */\n#undef HAVE_GROUP_FROM_GID\n\n/* Define to 1 if you have the <gssapi_generic.h> header file. */\n#undef HAVE_GSSAPI_GENERIC_H\n\n/* Define to 1 if you have the <gssapi/gssapi_generic.h> header file. */\n#undef HAVE_GSSAPI_GSSAPI_GENERIC_H\n\n/* Define to 1 if you have the <gssapi/gssapi.h> header file. */\n#undef HAVE_GSSAPI_GSSAPI_H\n\n/* Define to 1 if you have the <gssapi/gssapi_krb5.h> header file. */\n#undef HAVE_GSSAPI_GSSAPI_KRB5_H\n\n/* Define to 1 if you have the <gssapi.h> header file. */\n#undef HAVE_GSSAPI_H\n\n/* Define to 1 if you have the <gssapi_krb5.h> header file. */\n#undef HAVE_GSSAPI_KRB5_H\n\n/* Define if HEADER.ad exists in arpa/nameser.h */\n#undef HAVE_HEADER_AD\n\n/* Define to 1 if you have the `HMAC_CTX_init' function. */\n#undef HAVE_HMAC_CTX_INIT\n\n/* Define if you have ut_host in utmp.h */\n#undef HAVE_HOST_IN_UTMP\n\n/* Define if you have ut_host in utmpx.h */\n#undef HAVE_HOST_IN_UTMPX\n\n/* Define to 1 if you have the <iaf.h> header file. */\n#undef HAVE_IAF_H\n\n/* Define to 1 if you have the <ia.h> header file. */\n#undef HAVE_IA_H\n\n/* Define if you have ut_id in utmp.h */\n#undef HAVE_ID_IN_UTMP\n\n/* Define if you have ut_id in utmpx.h */\n#undef HAVE_ID_IN_UTMPX\n\n/* Define to 1 if you have the <ifaddrs.h> header file. */\n#undef HAVE_IFADDRS_H\n\n/* Define to 1 if you have the `inet_aton' function. */\n#undef HAVE_INET_ATON\n\n/* Define to 1 if you have the `inet_ntoa' function. */\n#undef HAVE_INET_NTOA\n\n/* Define to 1 if you have the `inet_ntop' function. */\n#undef HAVE_INET_NTOP\n\n/* Define to 1 if you have the `innetgr' function. */\n#undef HAVE_INNETGR\n\n/* define if you have int64_t data type */\n#undef HAVE_INT64_T\n\n/* Define to 1 if the system has the type `intmax_t'. */\n#undef HAVE_INTMAX_T\n\n/* Define to 1 if you have the <inttypes.h> header file. */\n#undef HAVE_INTTYPES_H\n\n/* define if you have intxx_t data type */\n#undef HAVE_INTXX_T\n\n/* Define to 1 if the system has the type `in_addr_t'. */\n#undef HAVE_IN_ADDR_T\n\n/* Define to 1 if the system has the type `in_port_t'. */\n#undef HAVE_IN_PORT_T\n\n/* Define if you have isblank(3C). */\n#undef HAVE_ISBLANK\n\n/* Define to 1 if you have the `krb5_cc_new_unique' function. */\n#undef HAVE_KRB5_CC_NEW_UNIQUE\n\n/* Define to 1 if you have the `krb5_free_error_message' function. */\n#undef HAVE_KRB5_FREE_ERROR_MESSAGE\n\n/* Define to 1 if you have the `krb5_get_error_message' function. */\n#undef HAVE_KRB5_GET_ERROR_MESSAGE\n\n/* Define to 1 if you have the <langinfo.h> header file. */\n#undef HAVE_LANGINFO_H\n\n/* Define to 1 if you have the <lastlog.h> header file. */\n#undef HAVE_LASTLOG_H\n\n/* Define if you want ldns support */\n#undef HAVE_LDNS\n\n/* Define to 1 if you have the <libaudit.h> header file. */\n#undef HAVE_LIBAUDIT_H\n\n/* Define to 1 if you have the `bsm' library (-lbsm). */\n#undef HAVE_LIBBSM\n\n/* Define to 1 if you have the `crypt' library (-lcrypt). */\n#undef HAVE_LIBCRYPT\n\n/* Define to 1 if you have the `dl' library (-ldl). */\n#undef HAVE_LIBDL\n\n/* Define to 1 if you have the <libgen.h> header file. */\n#undef HAVE_LIBGEN_H\n\n/* Define if system has libiaf that supports set_id */\n#undef HAVE_LIBIAF\n\n/* Define to 1 if you have the `network' library (-lnetwork). */\n#undef HAVE_LIBNETWORK\n\n/* Define to 1 if you have the `pam' library (-lpam). */\n#undef HAVE_LIBPAM\n\n/* Define to 1 if you have the <libproc.h> header file. */\n#undef HAVE_LIBPROC_H\n\n/* Define to 1 if you have the `socket' library (-lsocket). */\n#undef HAVE_LIBSOCKET\n\n/* Define to 1 if you have the <libutil.h> header file. */\n#undef HAVE_LIBUTIL_H\n\n/* Define to 1 if you have the `xnet' library (-lxnet). */\n#undef HAVE_LIBXNET\n\n/* Define to 1 if you have the `z' library (-lz). */\n#undef HAVE_LIBZ\n\n/* Define to 1 if you have the <limits.h> header file. */\n#undef HAVE_LIMITS_H\n\n/* Define to 1 if you have the <linux/audit.h> header file. */\n#undef HAVE_LINUX_AUDIT_H\n\n/* Define to 1 if you have the <linux/filter.h> header file. */\n#undef HAVE_LINUX_FILTER_H\n\n/* Define to 1 if you have the <linux/if_tun.h> header file. */\n#undef HAVE_LINUX_IF_TUN_H\n\n/* Define to 1 if you have the <linux/seccomp.h> header file. */\n#undef HAVE_LINUX_SECCOMP_H\n\n/* Define to 1 if you have the `llabs' function. */\n#undef HAVE_LLABS\n\n/* Define to 1 if you have the <locale.h> header file. */\n#undef HAVE_LOCALE_H\n\n/* Define to 1 if you have the `localtime_r' function. */\n#undef HAVE_LOCALTIME_R\n\n/* Define to 1 if you have the `login' function. */\n#undef HAVE_LOGIN\n\n/* Define to 1 if you have the <login_cap.h> header file. */\n#undef HAVE_LOGIN_CAP_H\n\n/* Define to 1 if you have the `login_getcapbool' function. */\n#undef HAVE_LOGIN_GETCAPBOOL\n\n/* Define to 1 if you have the <login.h> header file. */\n#undef HAVE_LOGIN_H\n\n/* Define to 1 if you have the `logout' function. */\n#undef HAVE_LOGOUT\n\n/* Define to 1 if you have the `logwtmp' function. */\n#undef HAVE_LOGWTMP\n\n/* Define to 1 if the system has the type `long double'. */\n#undef HAVE_LONG_DOUBLE\n\n/* Define to 1 if the system has the type `long long'. */\n#undef HAVE_LONG_LONG\n\n/* Define to 1 if you have the <maillock.h> header file. */\n#undef HAVE_MAILLOCK_H\n\n/* Define to 1 if your system has a GNU libc compatible `malloc' function, and\n   to 0 otherwise. */\n#undef HAVE_MALLOC\n\n/* Define to 1 if you have the `mblen' function. */\n#undef HAVE_MBLEN\n\n/* Define to 1 if you have the `mbtowc' function. */\n#undef HAVE_MBTOWC\n\n/* Define to 1 if you have the `md5_crypt' function. */\n#undef HAVE_MD5_CRYPT\n\n/* Define if you want to allow MD5 passwords */\n#undef HAVE_MD5_PASSWORDS\n\n/* Define to 1 if you have the `memmem' function. */\n#undef HAVE_MEMMEM\n\n/* Define to 1 if you have the `memmove' function. */\n#undef HAVE_MEMMOVE\n\n/* Define to 1 if you have the <memory.h> header file. */\n#undef HAVE_MEMORY_H\n\n/* Define to 1 if you have the `memset_s' function. */\n#undef HAVE_MEMSET_S\n\n/* Define to 1 if you have the `mkdtemp' function. */\n#undef HAVE_MKDTEMP\n\n/* define if you have mode_t data type */\n#undef HAVE_MODE_T\n\n/* Some systems put nanosleep outside of libc */\n#undef HAVE_NANOSLEEP\n\n/* Define to 1 if you have the <ndir.h> header file. */\n#undef HAVE_NDIR_H\n\n/* Define to 1 if you have the <netdb.h> header file. */\n#undef HAVE_NETDB_H\n\n/* Define to 1 if you have the <netgroup.h> header file. */\n#undef HAVE_NETGROUP_H\n\n/* Define to 1 if you have the <net/if_tun.h> header file. */\n#undef HAVE_NET_IF_TUN_H\n\n/* Define to 1 if you have the <net/route.h> header file. */\n#undef HAVE_NET_ROUTE_H\n\n/* Define if you are on NeXT */\n#undef HAVE_NEXT\n\n/* Define to 1 if you have the `ngetaddrinfo' function. */\n#undef HAVE_NGETADDRINFO\n\n/* Define to 1 if you have the `nl_langinfo' function. */\n#undef HAVE_NL_LANGINFO\n\n/* Define to 1 if you have the `nsleep' function. */\n#undef HAVE_NSLEEP\n\n/* Define to 1 if you have the `ogetaddrinfo' function. */\n#undef HAVE_OGETADDRINFO\n\n/* Define if you have an old version of PAM which takes only one argument to\n   pam_strerror */\n#undef HAVE_OLD_PAM\n\n/* Define to 1 if you have the `openlog_r' function. */\n#undef HAVE_OPENLOG_R\n\n/* Define to 1 if you have the `openpty' function. */\n#undef HAVE_OPENPTY\n\n/* as a macro */\n#undef HAVE_OPENSSL_ADD_ALL_ALGORITHMS\n\n/* Define to 1 if you have the `OPENSSL_init_crypto' function. */\n#undef HAVE_OPENSSL_INIT_CRYPTO\n\n/* Define to 1 if you have the `OpenSSL_version' function. */\n#undef HAVE_OPENSSL_VERSION\n\n/* Define to 1 if you have the `OpenSSL_version_num' function. */\n#undef HAVE_OPENSSL_VERSION_NUM\n\n/* Define if you have Digital Unix Security Integration Architecture */\n#undef HAVE_OSF_SIA\n\n/* Define to 1 if you have the `pam_getenvlist' function. */\n#undef HAVE_PAM_GETENVLIST\n\n/* Define to 1 if you have the <pam/pam_appl.h> header file. */\n#undef HAVE_PAM_PAM_APPL_H\n\n/* Define to 1 if you have the `pam_putenv' function. */\n#undef HAVE_PAM_PUTENV\n\n/* Define to 1 if you have the <paths.h> header file. */\n#undef HAVE_PATHS_H\n\n/* Define if you have ut_pid in utmp.h */\n#undef HAVE_PID_IN_UTMP\n\n/* define if you have pid_t data type */\n#undef HAVE_PID_T\n\n/* Define to 1 if you have the `pledge' function. */\n#undef HAVE_PLEDGE\n\n/* Define to 1 if you have the `poll' function. */\n#undef HAVE_POLL\n\n/* Define to 1 if you have the <poll.h> header file. */\n#undef HAVE_POLL_H\n\n/* Define to 1 if you have the `prctl' function. */\n#undef HAVE_PRCTL\n\n/* Define to 1 if you have the `priv_basicset' function. */\n#undef HAVE_PRIV_BASICSET\n\n/* Define to 1 if you have the <priv.h> header file. */\n#undef HAVE_PRIV_H\n\n/* Define if you have /proc/$pid/fd */\n#undef HAVE_PROC_PID\n\n/* Define to 1 if you have the `proc_pidinfo' function. */\n#undef HAVE_PROC_PIDINFO\n\n/* Define to 1 if you have the `pstat' function. */\n#undef HAVE_PSTAT\n\n/* Define to 1 if you have the <pty.h> header file. */\n#undef HAVE_PTY_H\n\n/* Define to 1 if you have the `pututline' function. */\n#undef HAVE_PUTUTLINE\n\n/* Define to 1 if you have the `pututxline' function. */\n#undef HAVE_PUTUTXLINE\n\n/* Define to 1 if you have the `raise' function. */\n#undef HAVE_RAISE\n\n/* Define to 1 if you have the `readpassphrase' function. */\n#undef HAVE_READPASSPHRASE\n\n/* Define to 1 if you have the <readpassphrase.h> header file. */\n#undef HAVE_READPASSPHRASE_H\n\n/* Define to 1 if your system has a GNU libc compatible `realloc' function,\n   and to 0 otherwise. */\n#undef HAVE_REALLOC\n\n/* Define to 1 if you have the `reallocarray' function. */\n#undef HAVE_REALLOCARRAY\n\n/* Define to 1 if you have the `realpath' function. */\n#undef HAVE_REALPATH\n\n/* Define to 1 if you have the `recallocarray' function. */\n#undef HAVE_RECALLOCARRAY\n\n/* Define to 1 if you have the `recvmsg' function. */\n#undef HAVE_RECVMSG\n\n/* sys/resource.h has RLIMIT_NPROC */\n#undef HAVE_RLIMIT_NPROC\n\n/* Define to 1 if you have the <rpc/types.h> header file. */\n#undef HAVE_RPC_TYPES_H\n\n/* Define to 1 if you have the `rresvport_af' function. */\n#undef HAVE_RRESVPORT_AF\n\n/* Define to 1 if you have the `RSA_generate_key_ex' function. */\n#undef HAVE_RSA_GENERATE_KEY_EX\n\n/* Define to 1 if you have the `RSA_get0_crt_params' function. */\n#undef HAVE_RSA_GET0_CRT_PARAMS\n\n/* Define to 1 if you have the `RSA_get0_factors' function. */\n#undef HAVE_RSA_GET0_FACTORS\n\n/* Define to 1 if you have the `RSA_get0_key' function. */\n#undef HAVE_RSA_GET0_KEY\n\n/* Define to 1 if you have the `RSA_get_default_method' function. */\n#undef HAVE_RSA_GET_DEFAULT_METHOD\n\n/* Define to 1 if you have the `RSA_meth_dup' function. */\n#undef HAVE_RSA_METH_DUP\n\n/* Define to 1 if you have the `RSA_meth_free' function. */\n#undef HAVE_RSA_METH_FREE\n\n/* Define to 1 if you have the `RSA_meth_get_finish' function. */\n#undef HAVE_RSA_METH_GET_FINISH\n\n/* Define to 1 if you have the `RSA_meth_set1_name' function. */\n#undef HAVE_RSA_METH_SET1_NAME\n\n/* Define to 1 if you have the `RSA_meth_set_finish' function. */\n#undef HAVE_RSA_METH_SET_FINISH\n\n/* Define to 1 if you have the `RSA_meth_set_priv_dec' function. */\n#undef HAVE_RSA_METH_SET_PRIV_DEC\n\n/* Define to 1 if you have the `RSA_meth_set_priv_enc' function. */\n#undef HAVE_RSA_METH_SET_PRIV_ENC\n\n/* Define to 1 if you have the `RSA_set0_crt_params' function. */\n#undef HAVE_RSA_SET0_CRT_PARAMS\n\n/* Define to 1 if you have the `RSA_set0_factors' function. */\n#undef HAVE_RSA_SET0_FACTORS\n\n/* Define to 1 if you have the `RSA_set0_key' function. */\n#undef HAVE_RSA_SET0_KEY\n\n/* Define to 1 if you have the <sandbox.h> header file. */\n#undef HAVE_SANDBOX_H\n\n/* Define to 1 if you have the `sandbox_init' function. */\n#undef HAVE_SANDBOX_INIT\n\n/* define if you have sa_family_t data type */\n#undef HAVE_SA_FAMILY_T\n\n/* Define to 1 if you have the `scan_scaled' function. */\n#undef HAVE_SCAN_SCALED\n\n/* Define if you have SecureWare-based protected password database */\n#undef HAVE_SECUREWARE\n\n/* Define to 1 if you have the <security/pam_appl.h> header file. */\n#undef HAVE_SECURITY_PAM_APPL_H\n\n/* Define to 1 if you have the `sendmsg' function. */\n#undef HAVE_SENDMSG\n\n/* Define to 1 if you have the `setauthdb' function. */\n#undef HAVE_SETAUTHDB\n\n/* Define to 1 if you have the `setdtablesize' function. */\n#undef HAVE_SETDTABLESIZE\n\n/* Define to 1 if you have the `setegid' function. */\n#undef HAVE_SETEGID\n\n/* Define to 1 if you have the `setenv' function. */\n#undef HAVE_SETENV\n\n/* Define to 1 if you have the `seteuid' function. */\n#undef HAVE_SETEUID\n\n/* Define to 1 if you have the `setgroupent' function. */\n#undef HAVE_SETGROUPENT\n\n/* Define to 1 if you have the `setgroups' function. */\n#undef HAVE_SETGROUPS\n\n/* Define to 1 if you have the `setlinebuf' function. */\n#undef HAVE_SETLINEBUF\n\n/* Define to 1 if you have the `setlogin' function. */\n#undef HAVE_SETLOGIN\n\n/* Define to 1 if you have the `setluid' function. */\n#undef HAVE_SETLUID\n\n/* Define to 1 if you have the `setpassent' function. */\n#undef HAVE_SETPASSENT\n\n/* Define to 1 if you have the `setpcred' function. */\n#undef HAVE_SETPCRED\n\n/* Define to 1 if you have the `setpflags' function. */\n#undef HAVE_SETPFLAGS\n\n/* Define to 1 if you have the `setppriv' function. */\n#undef HAVE_SETPPRIV\n\n/* Define to 1 if you have the `setproctitle' function. */\n#undef HAVE_SETPROCTITLE\n\n/* Define to 1 if you have the `setregid' function. */\n#undef HAVE_SETREGID\n\n/* Define to 1 if you have the `setresgid' function. */\n#undef HAVE_SETRESGID\n\n/* Define to 1 if you have the `setresuid' function. */\n#undef HAVE_SETRESUID\n\n/* Define to 1 if you have the `setreuid' function. */\n#undef HAVE_SETREUID\n\n/* Define to 1 if you have the `setrlimit' function. */\n#undef HAVE_SETRLIMIT\n\n/* Define to 1 if you have the `setsid' function. */\n#undef HAVE_SETSID\n\n/* Define to 1 if you have the `setutent' function. */\n#undef HAVE_SETUTENT\n\n/* Define to 1 if you have the `setutxdb' function. */\n#undef HAVE_SETUTXDB\n\n/* Define to 1 if you have the `setutxent' function. */\n#undef HAVE_SETUTXENT\n\n/* Define to 1 if you have the `setvbuf' function. */\n#undef HAVE_SETVBUF\n\n/* Define to 1 if you have the `set_id' function. */\n#undef HAVE_SET_ID\n\n/* Define to 1 if you have the `SHA256Update' function. */\n#undef HAVE_SHA256UPDATE\n\n/* Define to 1 if you have the <sha2.h> header file. */\n#undef HAVE_SHA2_H\n\n/* Define to 1 if you have the `SHA384Update' function. */\n#undef HAVE_SHA384UPDATE\n\n/* Define to 1 if you have the `SHA512Update' function. */\n#undef HAVE_SHA512UPDATE\n\n/* Define to 1 if you have the <shadow.h> header file. */\n#undef HAVE_SHADOW_H\n\n/* Define to 1 if you have the `sigaction' function. */\n#undef HAVE_SIGACTION\n\n/* Define to 1 if you have the `sigvec' function. */\n#undef HAVE_SIGVEC\n\n/* Define to 1 if the system has the type `sig_atomic_t'. */\n#undef HAVE_SIG_ATOMIC_T\n\n/* define if you have size_t data type */\n#undef HAVE_SIZE_T\n\n/* Define to 1 if you have the `snprintf' function. */\n#undef HAVE_SNPRINTF\n\n/* Define to 1 if you have the `socketpair' function. */\n#undef HAVE_SOCKETPAIR\n\n/* Have PEERCRED socket option */\n#undef HAVE_SO_PEERCRED\n\n/* define if you have ssize_t data type */\n#undef HAVE_SSIZE_T\n\n/* Fields in struct sockaddr_storage */\n#undef HAVE_SS_FAMILY_IN_SS\n\n/* Define if you have ut_ss in utmpx.h */\n#undef HAVE_SS_IN_UTMPX\n\n/* Define to 1 if you have the `statfs' function. */\n#undef HAVE_STATFS\n\n/* Define to 1 if you have the `statvfs' function. */\n#undef HAVE_STATVFS\n\n/* Define to 1 if you have the <stddef.h> header file. */\n#undef HAVE_STDDEF_H\n\n/* Define to 1 if you have the <stdint.h> header file. */\n#undef HAVE_STDINT_H\n\n/* Define to 1 if you have the <stdlib.h> header file. */\n#undef HAVE_STDLIB_H\n\n/* Define to 1 if you have the `strcasestr' function. */\n#undef HAVE_STRCASESTR\n\n/* Define to 1 if you have the `strdup' function. */\n#undef HAVE_STRDUP\n\n/* Define to 1 if you have the `strerror' function. */\n#undef HAVE_STRERROR\n\n/* Define to 1 if you have the `strftime' function. */\n#undef HAVE_STRFTIME\n\n/* Silly mkstemp() */\n#undef HAVE_STRICT_MKSTEMP\n\n/* Define to 1 if you have the <strings.h> header file. */\n#undef HAVE_STRINGS_H\n\n/* Define to 1 if you have the <string.h> header file. */\n#undef HAVE_STRING_H\n\n/* Define to 1 if you have the `strlcat' function. */\n#undef HAVE_STRLCAT\n\n/* Define to 1 if you have the `strlcpy' function. */\n#undef HAVE_STRLCPY\n\n/* Define to 1 if you have the `strmode' function. */\n#undef HAVE_STRMODE\n\n/* Define to 1 if you have the `strndup' function. */\n#undef HAVE_STRNDUP\n\n/* Define to 1 if you have the `strnlen' function. */\n#undef HAVE_STRNLEN\n\n/* Define to 1 if you have the `strnvis' function. */\n#undef HAVE_STRNVIS\n\n/* Define to 1 if you have the `strptime' function. */\n#undef HAVE_STRPTIME\n\n/* Define to 1 if you have the `strsep' function. */\n#undef HAVE_STRSEP\n\n/* Define to 1 if you have the `strsignal' function. */\n#undef HAVE_STRSIGNAL\n\n/* Define to 1 if you have the `strtoll' function. */\n#undef HAVE_STRTOLL\n\n/* Define to 1 if you have the `strtonum' function. */\n#undef HAVE_STRTONUM\n\n/* Define to 1 if you have the `strtoul' function. */\n#undef HAVE_STRTOUL\n\n/* Define to 1 if you have the `strtoull' function. */\n#undef HAVE_STRTOULL\n\n/* define if you have struct addrinfo data type */\n#undef HAVE_STRUCT_ADDRINFO\n\n/* define if you have struct in6_addr data type */\n#undef HAVE_STRUCT_IN6_ADDR\n\n/* Define to 1 if `pw_change' is a member of `struct passwd'. */\n#undef HAVE_STRUCT_PASSWD_PW_CHANGE\n\n/* Define to 1 if `pw_class' is a member of `struct passwd'. */\n#undef HAVE_STRUCT_PASSWD_PW_CLASS\n\n/* Define to 1 if `pw_expire' is a member of `struct passwd'. */\n#undef HAVE_STRUCT_PASSWD_PW_EXPIRE\n\n/* Define to 1 if `pw_gecos' is a member of `struct passwd'. */\n#undef HAVE_STRUCT_PASSWD_PW_GECOS\n\n/* define if you have struct sockaddr_in6 data type */\n#undef HAVE_STRUCT_SOCKADDR_IN6\n\n/* Define to 1 if `sin6_scope_id' is a member of `struct sockaddr_in6'. */\n#undef HAVE_STRUCT_SOCKADDR_IN6_SIN6_SCOPE_ID\n\n/* define if you have struct sockaddr_storage data type */\n#undef HAVE_STRUCT_SOCKADDR_STORAGE\n\n/* Define to 1 if `f_files' is a member of `struct statfs'. */\n#undef HAVE_STRUCT_STATFS_F_FILES\n\n/* Define to 1 if `f_flags' is a member of `struct statfs'. */\n#undef HAVE_STRUCT_STATFS_F_FLAGS\n\n/* Define to 1 if `st_blksize' is a member of `struct stat'. */\n#undef HAVE_STRUCT_STAT_ST_BLKSIZE\n\n/* Define to 1 if `st_mtim' is a member of `struct stat'. */\n#undef HAVE_STRUCT_STAT_ST_MTIM\n\n/* Define to 1 if `st_mtime' is a member of `struct stat'. */\n#undef HAVE_STRUCT_STAT_ST_MTIME\n\n/* define if you have struct timespec */\n#undef HAVE_STRUCT_TIMESPEC\n\n/* define if you have struct timeval */\n#undef HAVE_STRUCT_TIMEVAL\n\n/* Define to 1 if you have the `swap32' function. */\n#undef HAVE_SWAP32\n\n/* Define to 1 if you have the `sysconf' function. */\n#undef HAVE_SYSCONF\n\n/* Define if you have syslen in utmpx.h */\n#undef HAVE_SYSLEN_IN_UTMPX\n\n/* Define to 1 if you have the <sys/audit.h> header file. */\n#undef HAVE_SYS_AUDIT_H\n\n/* Define to 1 if you have the <sys/bitypes.h> header file. */\n#undef HAVE_SYS_BITYPES_H\n\n/* Define to 1 if you have the <sys/bsdtty.h> header file. */\n#undef HAVE_SYS_BSDTTY_H\n\n/* Define to 1 if you have the <sys/byteorder.h> header file. */\n#undef HAVE_SYS_BYTEORDER_H\n\n/* Define to 1 if you have the <sys/capsicum.h> header file. */\n#undef HAVE_SYS_CAPSICUM_H\n\n/* Define to 1 if you have the <sys/cdefs.h> header file. */\n#undef HAVE_SYS_CDEFS_H\n\n/* Define to 1 if you have the <sys/dir.h> header file. */\n#undef HAVE_SYS_DIR_H\n\n/* Define if your system defines sys_errlist[] */\n#undef HAVE_SYS_ERRLIST\n\n/* Define to 1 if you have the <sys/file.h> header file. */\n#undef HAVE_SYS_FILE_H\n\n/* Define to 1 if you have the <sys/label.h> header file. */\n#undef HAVE_SYS_LABEL_H\n\n/* Define to 1 if you have the <sys/mman.h> header file. */\n#undef HAVE_SYS_MMAN_H\n\n/* Define to 1 if you have the <sys/mount.h> header file. */\n#undef HAVE_SYS_MOUNT_H\n\n/* Define to 1 if you have the <sys/ndir.h> header file. */\n#undef HAVE_SYS_NDIR_H\n\n/* Define if your system defines sys_nerr */\n#undef HAVE_SYS_NERR\n\n/* Define to 1 if you have the <sys/poll.h> header file. */\n#undef HAVE_SYS_POLL_H\n\n/* Define to 1 if you have the <sys/prctl.h> header file. */\n#undef HAVE_SYS_PRCTL_H\n\n/* Define to 1 if you have the <sys/pstat.h> header file. */\n#undef HAVE_SYS_PSTAT_H\n\n/* Define to 1 if you have the <sys/ptms.h> header file. */\n#undef HAVE_SYS_PTMS_H\n\n/* Define to 1 if you have the <sys/ptrace.h> header file. */\n#undef HAVE_SYS_PTRACE_H\n\n/* Define to 1 if you have the <sys/random.h> header file. */\n#undef HAVE_SYS_RANDOM_H\n\n/* Define to 1 if you have the <sys/select.h> header file. */\n#undef HAVE_SYS_SELECT_H\n\n/* Define to 1 if you have the <sys/statvfs.h> header file. */\n#undef HAVE_SYS_STATVFS_H\n\n/* Define to 1 if you have the <sys/stat.h> header file. */\n#undef HAVE_SYS_STAT_H\n\n/* Define to 1 if you have the <sys/stream.h> header file. */\n#undef HAVE_SYS_STREAM_H\n\n/* Define to 1 if you have the <sys/stropts.h> header file. */\n#undef HAVE_SYS_STROPTS_H\n\n/* Define to 1 if you have the <sys/strtio.h> header file. */\n#undef HAVE_SYS_STRTIO_H\n\n/* Define to 1 if you have the <sys/sysctl.h> header file. */\n#undef HAVE_SYS_SYSCTL_H\n\n/* Force use of sys/syslog.h on Ultrix */\n#undef HAVE_SYS_SYSLOG_H\n\n/* Define to 1 if you have the <sys/sysmacros.h> header file. */\n#undef HAVE_SYS_SYSMACROS_H\n\n/* Define to 1 if you have the <sys/timers.h> header file. */\n#undef HAVE_SYS_TIMERS_H\n\n/* Define to 1 if you have the <sys/time.h> header file. */\n#undef HAVE_SYS_TIME_H\n\n/* Define to 1 if you have the <sys/types.h> header file. */\n#undef HAVE_SYS_TYPES_H\n\n/* Define to 1 if you have the <sys/un.h> header file. */\n#undef HAVE_SYS_UN_H\n\n/* Define to 1 if you have the <sys/vfs.h> header file. */\n#undef HAVE_SYS_VFS_H\n\n/* Define to 1 if you have the `tcgetpgrp' function. */\n#undef HAVE_TCGETPGRP\n\n/* Define to 1 if you have the `tcsendbreak' function. */\n#undef HAVE_TCSENDBREAK\n\n/* Define to 1 if you have the `time' function. */\n#undef HAVE_TIME\n\n/* Define to 1 if you have the <time.h> header file. */\n#undef HAVE_TIME_H\n\n/* Define if you have ut_time in utmp.h */\n#undef HAVE_TIME_IN_UTMP\n\n/* Define if you have ut_time in utmpx.h */\n#undef HAVE_TIME_IN_UTMPX\n\n/* Define to 1 if you have the `timingsafe_bcmp' function. */\n#undef HAVE_TIMINGSAFE_BCMP\n\n/* Define to 1 if you have the <tmpdir.h> header file. */\n#undef HAVE_TMPDIR_H\n\n/* Define to 1 if you have the `truncate' function. */\n#undef HAVE_TRUNCATE\n\n/* Define to 1 if you have the <ttyent.h> header file. */\n#undef HAVE_TTYENT_H\n\n/* Define if you have ut_tv in utmp.h */\n#undef HAVE_TV_IN_UTMP\n\n/* Define if you have ut_tv in utmpx.h */\n#undef HAVE_TV_IN_UTMPX\n\n/* Define if you have ut_type in utmp.h */\n#undef HAVE_TYPE_IN_UTMP\n\n/* Define if you have ut_type in utmpx.h */\n#undef HAVE_TYPE_IN_UTMPX\n\n/* Define to 1 if you have the <ucred.h> header file. */\n#undef HAVE_UCRED_H\n\n/* Define to 1 if the system has the type `uintmax_t'. */\n#undef HAVE_UINTMAX_T\n\n/* define if you have uintxx_t data type */\n#undef HAVE_UINTXX_T\n\n/* Define to 1 if you have the <unistd.h> header file. */\n#undef HAVE_UNISTD_H\n\n/* Define to 1 if you have the `unsetenv' function. */\n#undef HAVE_UNSETENV\n\n/* Define to 1 if the system has the type `unsigned long long'. */\n#undef HAVE_UNSIGNED_LONG_LONG\n\n/* Define to 1 if you have the `updwtmp' function. */\n#undef HAVE_UPDWTMP\n\n/* Define to 1 if you have the `updwtmpx' function. */\n#undef HAVE_UPDWTMPX\n\n/* Define to 1 if you have the <usersec.h> header file. */\n#undef HAVE_USERSEC_H\n\n/* Define to 1 if you have the `user_from_uid' function. */\n#undef HAVE_USER_FROM_UID\n\n/* Define to 1 if you have the `usleep' function. */\n#undef HAVE_USLEEP\n\n/* Define to 1 if you have the <util.h> header file. */\n#undef HAVE_UTIL_H\n\n/* Define to 1 if you have the `utimensat' function. */\n#undef HAVE_UTIMENSAT\n\n/* Define to 1 if you have the `utimes' function. */\n#undef HAVE_UTIMES\n\n/* Define to 1 if you have the <utime.h> header file. */\n#undef HAVE_UTIME_H\n\n/* Define to 1 if you have the `utmpname' function. */\n#undef HAVE_UTMPNAME\n\n/* Define to 1 if you have the `utmpxname' function. */\n#undef HAVE_UTMPXNAME\n\n/* Define to 1 if you have the <utmpx.h> header file. */\n#undef HAVE_UTMPX_H\n\n/* Define to 1 if you have the <utmp.h> header file. */\n#undef HAVE_UTMP_H\n\n/* define if you have u_char data type */\n#undef HAVE_U_CHAR\n\n/* define if you have u_int data type */\n#undef HAVE_U_INT\n\n/* define if you have u_int64_t data type */\n#undef HAVE_U_INT64_T\n\n/* define if you have u_intxx_t data type */\n#undef HAVE_U_INTXX_T\n\n/* Define to 1 if you have the `vasprintf' function. */\n#undef HAVE_VASPRINTF\n\n/* Define if va_copy exists */\n#undef HAVE_VA_COPY\n\n/* Define to 1 if you have the <vis.h> header file. */\n#undef HAVE_VIS_H\n\n/* Define to 1 if you have the `vsnprintf' function. */\n#undef HAVE_VSNPRINTF\n\n/* Define to 1 if you have the `waitpid' function. */\n#undef HAVE_WAITPID\n\n/* Define to 1 if you have the `warn' function. */\n#undef HAVE_WARN\n\n/* Define to 1 if you have the <wchar.h> header file. */\n#undef HAVE_WCHAR_H\n\n/* Define to 1 if you have the `wcwidth' function. */\n#undef HAVE_WCWIDTH\n\n/* Define to 1 if you have the `_getlong' function. */\n#undef HAVE__GETLONG\n\n/* Define to 1 if you have the `_getpty' function. */\n#undef HAVE__GETPTY\n\n/* Define to 1 if you have the `_getshort' function. */\n#undef HAVE__GETSHORT\n\n/* Define if you have struct __res_state _res as an extern */\n#undef HAVE__RES_EXTERN\n\n/* Define to 1 if you have the `__b64_ntop' function. */\n#undef HAVE___B64_NTOP\n\n/* Define to 1 if you have the `__b64_pton' function. */\n#undef HAVE___B64_PTON\n\n/* Define if compiler implements __FUNCTION__ */\n#undef HAVE___FUNCTION__\n\n/* Define if libc defines __progname */\n#undef HAVE___PROGNAME\n\n/* Fields in struct sockaddr_storage */\n#undef HAVE___SS_FAMILY_IN_SS\n\n/* Define if __va_copy exists */\n#undef HAVE___VA_COPY\n\n/* Define if compiler implements __func__ */\n#undef HAVE___func__\n\n/* Define this if you are using the Heimdal version of Kerberos V5 */\n#undef HEIMDAL\n\n/* Define if you need to use IP address instead of hostname in $DISPLAY */\n#undef IPADDR_IN_DISPLAY\n\n/* Detect IPv4 in IPv6 mapped addresses and treat as IPv4 */\n#undef IPV4_IN_IPV6\n\n/* Define if your system choked on IP TOS setting */\n#undef IP_TOS_IS_BROKEN\n\n/* Define if you want Kerberos 5 support */\n#undef KRB5\n\n/* Define if pututxline updates lastlog too */\n#undef LASTLOG_WRITE_PUTUTXLINE\n\n/* Define to whatever link() returns for \"not supported\" if it doesn't return\n   EOPNOTSUPP. */\n#undef LINK_OPNOTSUPP_ERRNO\n\n/* Adjust Linux out-of-memory killer */\n#undef LINUX_OOM_ADJUST\n\n/* max value of long long calculated by configure */\n#undef LLONG_MAX\n\n/* min value of long long calculated by configure */\n#undef LLONG_MIN\n\n/* Account locked with pw(1) */\n#undef LOCKED_PASSWD_PREFIX\n\n/* String used in /etc/passwd to denote locked account */\n#undef LOCKED_PASSWD_STRING\n\n/* String used in /etc/passwd to denote locked account */\n#undef LOCKED_PASSWD_SUBSTR\n\n/* Some systems need a utmpx entry for /bin/login to work */\n#undef LOGIN_NEEDS_UTMPX\n\n/* Set this to your mail directory if you do not have _PATH_MAILDIR */\n#undef MAIL_DIRECTORY\n\n/* Need setpgrp to for controlling tty */\n#undef NEED_SETPGRP\n\n/* compiler does not accept __attribute__ on prototype args */\n#undef NO_ATTRIBUTE_ON_PROTOTYPE_ARGS\n\n/* compiler does not accept __attribute__ on return types */\n#undef NO_ATTRIBUTE_ON_RETURN_TYPE\n\n/* SA_RESTARTed signals do no interrupt select */\n#undef NO_SA_RESTART\n\n/* Define to disable UID restoration test */\n#undef NO_UID_RESTORATION_TEST\n\n/* Define if X11 doesn't support AF_UNIX sockets on that system */\n#undef NO_X11_UNIX_SOCKETS\n\n/* Define if EVP_DigestUpdate returns void */\n#undef OPENSSL_EVP_DIGESTUPDATE_VOID\n\n/* OpenSSL has ECC */\n#undef OPENSSL_HAS_ECC\n\n/* libcrypto has NID_X9_62_prime256v1 */\n#undef OPENSSL_HAS_NISTP256\n\n/* libcrypto has NID_secp384r1 */\n#undef OPENSSL_HAS_NISTP384\n\n/* libcrypto has NID_secp521r1 */\n#undef OPENSSL_HAS_NISTP521\n\n/* libcrypto has EVP AES CTR */\n#undef OPENSSL_HAVE_EVPCTR\n\n/* libcrypto has EVP AES GCM */\n#undef OPENSSL_HAVE_EVPGCM\n\n/* libcrypto is missing AES 192 and 256 bit functions */\n#undef OPENSSL_LOBOTOMISED_AES\n\n/* Define if you want the OpenSSL internally seeded PRNG only */\n#undef OPENSSL_PRNG_ONLY\n\n/* Define to the address where bug reports for this package should be sent. */\n#undef PACKAGE_BUGREPORT\n\n/* Define to the full name of this package. */\n#undef PACKAGE_NAME\n\n/* Define to the full name and version of this package. */\n#undef PACKAGE_STRING\n\n/* Define to the one symbol short name of this package. */\n#undef PACKAGE_TARNAME\n\n/* Define to the home page for this package. */\n#undef PACKAGE_URL\n\n/* Define to the version of this package. */\n#undef PACKAGE_VERSION\n\n/* Define if you are using Solaris-derived PAM which passes pam_messages to\n   the conversation function with an extra level of indirection */\n#undef PAM_SUN_CODEBASE\n\n/* Work around problematic Linux PAM modules handling of PAM_TTY */\n#undef PAM_TTY_KLUDGE\n\n/* must supply username to passwd */\n#undef PASSWD_NEEDS_USERNAME\n\n/* System dirs owned by bin (uid 2) */\n#undef PLATFORM_SYS_DIR_UID\n\n/* Port number of PRNGD/EGD random number socket */\n#undef PRNGD_PORT\n\n/* Location of PRNGD/EGD random number socket */\n#undef PRNGD_SOCKET\n\n/* read(1) can return 0 for a non-closed fd */\n#undef PTY_ZEROREAD\n\n/* Sandbox using capsicum */\n#undef SANDBOX_CAPSICUM\n\n/* Sandbox using Darwin sandbox_init(3) */\n#undef SANDBOX_DARWIN\n\n/* no privsep sandboxing */\n#undef SANDBOX_NULL\n\n/* Sandbox using pledge(2) */\n#undef SANDBOX_PLEDGE\n\n/* Sandbox using setrlimit(2) */\n#undef SANDBOX_RLIMIT\n\n/* Sandbox using seccomp filter */\n#undef SANDBOX_SECCOMP_FILTER\n\n/* setrlimit RLIMIT_FSIZE works */\n#undef SANDBOX_SKIP_RLIMIT_FSIZE\n\n/* define if setrlimit RLIMIT_NOFILE breaks things */\n#undef SANDBOX_SKIP_RLIMIT_NOFILE\n\n/* Sandbox using Solaris/Illumos privileges */\n#undef SANDBOX_SOLARIS\n\n/* Sandbox using systrace(4) */\n#undef SANDBOX_SYSTRACE\n\n/* Specify the system call convention in use */\n#undef SECCOMP_AUDIT_ARCH\n\n/* Define if your platform breaks doing a seteuid before a setuid */\n#undef SETEUID_BREAKS_SETUID\n\n/* The size of `int', as computed by sizeof. */\n#undef SIZEOF_INT\n\n/* The size of `long int', as computed by sizeof. */\n#undef SIZEOF_LONG_INT\n\n/* The size of `long long int', as computed by sizeof. */\n#undef SIZEOF_LONG_LONG_INT\n\n/* The size of `short int', as computed by sizeof. */\n#undef SIZEOF_SHORT_INT\n\n/* The size of `size_t', as computed by sizeof. */\n#undef SIZEOF_SIZE_T\n\n/* Define as const if snprintf() can declare const char *fmt */\n#undef SNPRINTF_CONST\n\n/* Define to a Set Process Title type if your system is supported by\n   bsd-setproctitle.c */\n#undef SPT_TYPE\n\n/* Define if sshd somehow reacquires a controlling TTY after setsid() */\n#undef SSHD_ACQUIRES_CTTY\n\n/* sshd PAM service name */\n#undef SSHD_PAM_SERVICE\n\n/* Define if pam_chauthtok wants real uid set to the unpriv'ed user */\n#undef SSHPAM_CHAUTHTOK_NEEDS_RUID\n\n/* Use audit debugging module */\n#undef SSH_AUDIT_EVENTS\n\n/* Windows is sensitive to read buffer size */\n#undef SSH_IOBUFSZ\n\n/* non-privileged user for privilege separation */\n#undef SSH_PRIVSEP_USER\n\n/* Use tunnel device compatibility to OpenBSD */\n#undef SSH_TUN_COMPAT_AF\n\n/* Open tunnel devices the FreeBSD way */\n#undef SSH_TUN_FREEBSD\n\n/* Open tunnel devices the Linux tun/tap way */\n#undef SSH_TUN_LINUX\n\n/* No layer 2 tunnel support */\n#undef SSH_TUN_NO_L2\n\n/* Open tunnel devices the OpenBSD way */\n#undef SSH_TUN_OPENBSD\n\n/* Prepend the address family to IP tunnel traffic */\n#undef SSH_TUN_PREPEND_AF\n\n/* Define to 1 if you have the ANSI C header files. */\n#undef STDC_HEADERS\n\n/* Define if you want a different $PATH for the superuser */\n#undef SUPERUSER_PATH\n\n/* syslog_r function is safe to use in in a signal handler */\n#undef SYSLOG_R_SAFE_IN_SIGHAND\n\n/* Support routing domains using Linux VRF */\n#undef SYS_RDOMAIN_LINUX\n\n/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */\n#undef TIME_WITH_SYS_TIME\n\n/* Support passwords > 8 chars */\n#undef UNIXWARE_LONG_PASSWORDS\n\n/* Specify default $PATH */\n#undef USER_PATH\n\n/* Define this if you want to use libkafs' AFS support */\n#undef USE_AFS\n\n/* Use BSM audit module */\n#undef USE_BSM_AUDIT\n\n/* Use btmp to log bad logins */\n#undef USE_BTMP\n\n/* Use libedit for sftp */\n#undef USE_LIBEDIT\n\n/* Use Linux audit module */\n#undef USE_LINUX_AUDIT\n\n/* Enable OpenSSL engine support */\n#undef USE_OPENSSL_ENGINE\n\n/* Define if you want to enable PAM support */\n#undef USE_PAM\n\n/* Use PIPES instead of a socketpair() */\n#undef USE_PIPES\n\n/* Define if you have Solaris privileges */\n#undef USE_SOLARIS_PRIVS\n\n/* Define if you have Solaris process contracts */\n#undef USE_SOLARIS_PROCESS_CONTRACTS\n\n/* Define if you have Solaris projects */\n#undef USE_SOLARIS_PROJECTS\n\n/* Define if you shouldn't strip 'tty' from your ttyname in [uw]tmp */\n#undef WITH_ABBREV_NO_TTY\n\n/* Define if you want to enable AIX4's authenticate function */\n#undef WITH_AIXAUTHENTICATE\n\n/* Define if you have/want arrays (cluster-wide session management, not C\n   arrays) */\n#undef WITH_IRIX_ARRAY\n\n/* Define if you want IRIX audit trails */\n#undef WITH_IRIX_AUDIT\n\n/* Define if you want IRIX kernel jobs */\n#undef WITH_IRIX_JOBS\n\n/* Define if you want IRIX project management */\n#undef WITH_IRIX_PROJECT\n\n/* use libcrypto for cryptography */\n#undef WITH_OPENSSL\n\n/* Define if you want SELinux support. */\n#undef WITH_SELINUX\n\n/* Enable zlib */\n#undef WITH_ZLIB\n\n/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most\n   significant byte first (like Motorola and SPARC, unlike Intel). */\n#if defined AC_APPLE_UNIVERSAL_BUILD\n# if defined __BIG_ENDIAN__\n#  define WORDS_BIGENDIAN 1\n# endif\n#else\n# ifndef WORDS_BIGENDIAN\n#  undef WORDS_BIGENDIAN\n# endif\n#endif\n\n/* Define if xauth is found in your path */\n#undef XAUTH_PATH\n\n/* Enable large inode numbers on Mac OS X 10.5.  */\n#ifndef _DARWIN_USE_64_BIT_INODE\n# define _DARWIN_USE_64_BIT_INODE 1\n#endif\n\n/* Number of bits in a file offset, on hosts where this is settable. */\n#undef _FILE_OFFSET_BITS\n\n/* Define for large files, on AIX-style hosts. */\n#undef _LARGE_FILES\n\n/* log for bad login attempts */\n#undef _PATH_BTMP\n\n/* Full path of your \"passwd\" program */\n#undef _PATH_PASSWD_PROG\n\n/* Specify location of ssh.pid */\n#undef _PATH_SSH_PIDDIR\n\n/* Define if we don't have struct __res_state in resolv.h */\n#undef __res_state\n\n/* Define to rpl_calloc if the replacement function should be used. */\n#undef calloc\n\n/* Define to `__inline__' or `__inline' if that's what the C compiler\n   calls it, or to nothing if 'inline' is not supported under any name.  */\n#ifndef __cplusplus\n#undef inline\n#endif\n\n/* Define to rpl_malloc if the replacement function should be used. */\n#undef malloc\n\n/* Define to rpl_realloc if the replacement function should be used. */\n#undef realloc\n\n/* type to use in place of socklen_t if not defined */\n#undef socklen_t\n",
        "/tmp/vanessa/spack-stage/spack-stage-openssh-8.4p1-gs222i4ctitv7fl27wgnurjoqoks3e7r/spack-src/configure.ac": "#\n# Copyright (c) 1999-2004 Damien Miller\n#\n# Permission to use, copy, modify, and distribute this software for any\n# purpose with or without fee is hereby granted, provided that the above\n# copyright notice and this permission notice appear in all copies.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\nAC_INIT([OpenSSH], [Portable], [openssh-unix-dev@mindrot.org])\nAC_CONFIG_MACRO_DIR([m4])\nAC_CONFIG_SRCDIR([ssh.c])\nAC_LANG([C])\n\nAC_CONFIG_HEADER([config.h])\nAC_PROG_CC([cc gcc])\nAC_CANONICAL_HOST\nAC_C_BIGENDIAN\n\n# Checks for programs.\nAC_PROG_AWK\nAC_PROG_CPP\nAC_PROG_RANLIB\nAC_PROG_INSTALL\nAC_PROG_EGREP\nAC_PROG_MKDIR_P\nAC_CHECK_TOOLS([AR], [ar])\nAC_PATH_PROG([CAT], [cat])\nAC_PATH_PROG([KILL], [kill])\nAC_PATH_PROG([SED], [sed])\nAC_PATH_PROG([TEST_MINUS_S_SH], [bash])\nAC_PATH_PROG([TEST_MINUS_S_SH], [ksh])\nAC_PATH_PROG([TEST_MINUS_S_SH], [sh])\nAC_PATH_PROG([SH], [sh])\nAC_PATH_PROG([GROFF], [groff])\nAC_PATH_PROG([NROFF], [nroff awf])\nAC_PATH_PROG([MANDOC], [mandoc])\nAC_SUBST([TEST_SHELL], [sh])\n\ndnl select manpage formatter to be used to build \"cat\" format pages.\nif test \"x$MANDOC\" != \"x\" ; then\n\tMANFMT=\"$MANDOC\"\nelif test \"x$NROFF\" != \"x\" ; then\n\tMANFMT=\"$NROFF -mandoc\"\nelif test \"x$GROFF\" != \"x\" ; then\n\tMANFMT=\"$GROFF -mandoc -Tascii\"\nelse\n\tAC_MSG_WARN([no manpage formatter found])\n\tMANFMT=\"false\"\nfi\nAC_SUBST([MANFMT])\n\ndnl for buildpkg.sh\nAC_PATH_PROG([PATH_GROUPADD_PROG], [groupadd], [groupadd],\n\t[/usr/sbin${PATH_SEPARATOR}/etc])\nAC_PATH_PROG([PATH_USERADD_PROG], [useradd], [useradd],\n\t[/usr/sbin${PATH_SEPARATOR}/etc])\nAC_CHECK_PROG([MAKE_PACKAGE_SUPPORTED], [pkgmk], [yes], [no])\nif test -x /sbin/sh; then\n\tAC_SUBST([STARTUP_SCRIPT_SHELL], [/sbin/sh])\nelse\n\tAC_SUBST([STARTUP_SCRIPT_SHELL], [/bin/sh])\nfi\n\n# System features\nAC_SYS_LARGEFILE\n\nif test -z \"$AR\" ; then\n\tAC_MSG_ERROR([*** 'ar' missing, please install or fix your \\$PATH ***])\nfi\n\nAC_PATH_PROG([PATH_PASSWD_PROG], [passwd])\nif test ! -z \"$PATH_PASSWD_PROG\" ; then\n\tAC_DEFINE_UNQUOTED([_PATH_PASSWD_PROG], [\"$PATH_PASSWD_PROG\"],\n\t\t[Full path of your \"passwd\" program])\nfi\n\ndnl Since autoconf doesn't support it very well,  we no longer allow users to\ndnl override LD, however keeping the hook here for now in case there's a use\ndnl use case we overlooked and someone needs to re-enable it.  Unless a good\ndnl reason is found we'll be removing this in future.\nLD=\"$CC\"\nAC_SUBST([LD])\n\nAC_C_INLINE\n\nAC_CHECK_DECL([LLONG_MAX], [have_llong_max=1], , [#include <limits.h>])\nAC_CHECK_DECL([LONG_LONG_MAX], [have_long_long_max=1], , [#include <limits.h>])\nAC_CHECK_DECL([SYSTR_POLICY_KILL], [have_systr_policy_kill=1], , [\n\t#include <sys/types.h>\n\t#include <sys/param.h>\n\t#include <dev/systrace.h>\n])\nAC_CHECK_DECL([RLIMIT_NPROC],\n    [AC_DEFINE([HAVE_RLIMIT_NPROC], [], [sys/resource.h has RLIMIT_NPROC])], , [\n\t#include <sys/types.h>\n\t#include <sys/resource.h>\n])\nAC_CHECK_DECL([PR_SET_NO_NEW_PRIVS], [have_linux_no_new_privs=1], , [\n\t#include <sys/types.h>\n\t#include <linux/prctl.h>\n])\n\nopenssl=yes\nAC_ARG_WITH([openssl],\n\t[  --without-openssl       Disable use of OpenSSL; use only limited internal crypto **EXPERIMENTAL** ],\n\t[  if test \"x$withval\" = \"xno\" ; then\n\t\topenssl=no\n\t   fi\n\t]\n)\nAC_MSG_CHECKING([whether OpenSSL will be used for cryptography])\nif test \"x$openssl\" = \"xyes\" ; then\n\tAC_MSG_RESULT([yes])\n\tAC_DEFINE_UNQUOTED([WITH_OPENSSL], [1], [use libcrypto for cryptography])\nelse\n\tAC_MSG_RESULT([no])\nfi\n\nuse_stack_protector=1\nuse_toolchain_hardening=1\nAC_ARG_WITH([stackprotect],\n    [  --without-stackprotect  Don't use compiler's stack protection], [\n    if test \"x$withval\" = \"xno\"; then\n\tuse_stack_protector=0\n    fi ])\nAC_ARG_WITH([hardening],\n    [  --without-hardening     Don't use toolchain hardening flags], [\n    if test \"x$withval\" = \"xno\"; then\n\tuse_toolchain_hardening=0\n    fi ])\n\n# We use -Werror for the tests only so that we catch warnings like \"this is\n# on by default\" for things like -fPIE.\nAC_MSG_CHECKING([if $CC supports -Werror])\nsaved_CFLAGS=\"$CFLAGS\"\nCFLAGS=\"$CFLAGS -Werror\"\nAC_COMPILE_IFELSE([AC_LANG_SOURCE([[int main(void) { return 0; }]])],\n\t[ AC_MSG_RESULT([yes])\n\t  WERROR=\"-Werror\"],\n\t[ AC_MSG_RESULT([no])\n\t  WERROR=\"\" ]\n)\nCFLAGS=\"$saved_CFLAGS\"\n\nif test \"$GCC\" = \"yes\" || test \"$GCC\" = \"egcs\"; then\n\tOSSH_CHECK_CFLAG_COMPILE([-pipe])\n\tOSSH_CHECK_CFLAG_COMPILE([-Wunknown-warning-option])\n\tOSSH_CHECK_CFLAG_COMPILE([-Wno-error=format-truncation])\n\tOSSH_CHECK_CFLAG_COMPILE([-Qunused-arguments])\n\tOSSH_CHECK_CFLAG_COMPILE([-Wall])\n\tOSSH_CHECK_CFLAG_COMPILE([-Wextra])\n\tOSSH_CHECK_CFLAG_COMPILE([-Wpointer-arith])\n\tOSSH_CHECK_CFLAG_COMPILE([-Wuninitialized])\n\tOSSH_CHECK_CFLAG_COMPILE([-Wsign-compare])\n\tOSSH_CHECK_CFLAG_COMPILE([-Wformat-security])\n\tOSSH_CHECK_CFLAG_COMPILE([-Wsizeof-pointer-memaccess])\n\tOSSH_CHECK_CFLAG_COMPILE([-Wpointer-sign], [-Wno-pointer-sign])\n\tOSSH_CHECK_CFLAG_COMPILE([-Wunused-parameter], [-Wno-unused-parameter])\n\tOSSH_CHECK_CFLAG_COMPILE([-Wunused-result], [-Wno-unused-result])\n\tOSSH_CHECK_CFLAG_COMPILE([-Wimplicit-fallthrough])\n\tOSSH_CHECK_CFLAG_COMPILE([-fno-strict-aliasing])\n    if test \"x$use_toolchain_hardening\" = \"x1\"; then\n\tOSSH_CHECK_CFLAG_COMPILE([-mretpoline]) # clang\n\tOSSH_CHECK_LDFLAG_LINK([-Wl,-z,retpolineplt])\n\tOSSH_CHECK_CFLAG_COMPILE([-D_FORTIFY_SOURCE=2])\n\tOSSH_CHECK_LDFLAG_LINK([-Wl,-z,relro])\n\tOSSH_CHECK_LDFLAG_LINK([-Wl,-z,now])\n\tOSSH_CHECK_LDFLAG_LINK([-Wl,-z,noexecstack])\n\t# NB. -ftrapv expects certain support functions to be present in\n\t# the compiler library (libgcc or similar) to detect integer operations\n\t# that can overflow. We must check that the result of enabling it\n\t# actually links. The test program compiled/linked includes a number\n\t# of integer operations that should exercise this.\n\tOSSH_CHECK_CFLAG_LINK([-ftrapv])\n    fi\n\tAC_MSG_CHECKING([gcc version])\n\tGCC_VER=`$CC -v 2>&1 | $AWK '/gcc version /{print $3}'`\n\tcase $GCC_VER in\n\t\t1.*) no_attrib_nonnull=1 ;;\n\t\t2.8* | 2.9*)\n\t\t     no_attrib_nonnull=1\n\t\t     ;;\n\t\t2.*) no_attrib_nonnull=1 ;;\n\t\t*) ;;\n\tesac\n\tAC_MSG_RESULT([$GCC_VER])\n\n\tAC_MSG_CHECKING([if $CC accepts -fno-builtin-memset])\n\tsaved_CFLAGS=\"$CFLAGS\"\n\tCFLAGS=\"$CFLAGS -fno-builtin-memset\"\n\tAC_LINK_IFELSE([AC_LANG_PROGRAM([[ #include <string.h> ]],\n\t\t\t[[ char b[10]; memset(b, 0, sizeof(b)); ]])],\n\t\t[ AC_MSG_RESULT([yes]) ],\n\t\t[ AC_MSG_RESULT([no])\n\t\t  CFLAGS=\"$saved_CFLAGS\" ]\n\t)\n\n\t# -fstack-protector-all doesn't always work for some GCC versions\n\t# and/or platforms, so we test if we can.  If it's not supported\n\t# on a given platform gcc will emit a warning so we use -Werror.\n\tif test \"x$use_stack_protector\" = \"x1\"; then\n\t    for t in -fstack-protector-strong -fstack-protector-all \\\n\t\t    -fstack-protector; do\n\t\tAC_MSG_CHECKING([if $CC supports $t])\n\t\tsaved_CFLAGS=\"$CFLAGS\"\n\t\tsaved_LDFLAGS=\"$LDFLAGS\"\n\t\tCFLAGS=\"$CFLAGS $t -Werror\"\n\t\tLDFLAGS=\"$LDFLAGS $t -Werror\"\n\t\tAC_LINK_IFELSE(\n\t\t\t[AC_LANG_PROGRAM([[\n\t#include <stdio.h>\n\tint func (int t) {char b[100]; snprintf(b,sizeof b,\"%d\",t); return t;}\n\t\t\t ]],\n\t\t\t[[\n\tchar x[256];\n\tsnprintf(x, sizeof(x), \"XXX%d\", func(1));\n\t\t\t ]])],\n\t\t    [ AC_MSG_RESULT([yes])\n\t\t      CFLAGS=\"$saved_CFLAGS $t\"\n\t\t      LDFLAGS=\"$saved_LDFLAGS $t\"\n\t\t      AC_MSG_CHECKING([if $t works])\n\t\t      AC_RUN_IFELSE(\n\t\t\t[AC_LANG_PROGRAM([[\n\t#include <stdio.h>\n\tint func (int t) {char b[100]; snprintf(b,sizeof b,\"%d\",t); return t;}\n\t\t\t]],\n\t\t\t[[\n\tchar x[256];\n\tsnprintf(x, sizeof(x), \"XXX%d\", func(1));\n\t\t\t]])],\n\t\t\t[ AC_MSG_RESULT([yes])\n\t\t\t  break ],\n\t\t\t[ AC_MSG_RESULT([no]) ],\n\t\t\t[ AC_MSG_WARN([cross compiling: cannot test])\n\t\t\t  break ]\n\t\t      )\n\t\t    ],\n\t\t    [ AC_MSG_RESULT([no]) ]\n\t\t)\n\t\tCFLAGS=\"$saved_CFLAGS\"\n\t\tLDFLAGS=\"$saved_LDFLAGS\"\n\t    done\n\tfi\n\n\tif test -z \"$have_llong_max\"; then\n\t\t# retry LLONG_MAX with -std=gnu99, needed on some Linuxes\n\t\tunset ac_cv_have_decl_LLONG_MAX\n\t\tsaved_CFLAGS=\"$CFLAGS\"\n\t\tCFLAGS=\"$CFLAGS -std=gnu99\"\n\t\tAC_CHECK_DECL([LLONG_MAX],\n\t\t    [have_llong_max=1],\n\t\t    [CFLAGS=\"$saved_CFLAGS\"],\n\t\t    [#include <limits.h>]\n\t\t)\n\tfi\nfi\n\nAC_MSG_CHECKING([if compiler allows __attribute__ on return types])\nAC_COMPILE_IFELSE(\n    [AC_LANG_PROGRAM([[\n#include <stdlib.h>\n__attribute__((__unused__)) static void foo(void){return;}]],\n    [[ exit(0); ]])],\n    [ AC_MSG_RESULT([yes]) ],\n    [ AC_MSG_RESULT([no])\n      AC_DEFINE(NO_ATTRIBUTE_ON_RETURN_TYPE, 1,\n\t [compiler does not accept __attribute__ on return types]) ]\n)\n\nAC_MSG_CHECKING([if compiler allows __attribute__ prototype args])\nAC_COMPILE_IFELSE(\n    [AC_LANG_PROGRAM([[\n#include <stdlib.h>\ntypedef void foo(const char *, ...) __attribute__((format(printf, 1, 2)));]],\n    [[ exit(0); ]])],\n    [ AC_MSG_RESULT([yes]) ],\n    [ AC_MSG_RESULT([no])\n      AC_DEFINE(NO_ATTRIBUTE_ON_PROTOTYPE_ARGS, 1,\n\t [compiler does not accept __attribute__ on prototype args]) ]\n)\n\nif test \"x$no_attrib_nonnull\" != \"x1\" ; then\n\tAC_DEFINE([HAVE_ATTRIBUTE__NONNULL__], [1], [Have attribute nonnull])\nfi\n\nAC_ARG_WITH([rpath],\n\t[  --without-rpath         Disable auto-added -R linker paths],\n\t[\n\t\tif test \"x$withval\" = \"xno\" ; then\n\t\t\trpath_opt=\"\"\n\t\telif test \"x$withval\" = \"xyes\" ; then\n\t\t\trpath_opt=\"-R\"\n\t\telse\n\t\t\trpath_opt=\"$withval\"\n\t\tfi\n\t]\n)\n\n# Allow user to specify flags\nAC_ARG_WITH([cflags],\n\t[  --with-cflags           Specify additional flags to pass to compiler],\n\t[\n\t\tif test -n \"$withval\"  &&  test \"x$withval\" != \"xno\"  &&  \\\n\t\t    test \"x${withval}\" != \"xyes\"; then\n\t\t\tCFLAGS=\"$CFLAGS $withval\"\n\t\tfi\n\t]\n)\n\nAC_ARG_WITH([cflags-after],\n\t[  --with-cflags-after     Specify additional flags to pass to compiler after configure],\n\t[\n\t\tif test -n \"$withval\"  &&  test \"x$withval\" != \"xno\"  &&  \\\n\t\t    test \"x${withval}\" != \"xyes\"; then\n\t\t\tCFLAGS_AFTER=\"$withval\"\n\t\tfi\n\t]\n)\nAC_ARG_WITH([cppflags],\n\t[  --with-cppflags         Specify additional flags to pass to preprocessor] ,\n\t[\n\t\tif test -n \"$withval\"  &&  test \"x$withval\" != \"xno\"  &&  \\\n\t\t    test \"x${withval}\" != \"xyes\"; then\n\t\t\tCPPFLAGS=\"$CPPFLAGS $withval\"\n\t\tfi\n\t]\n)\nAC_ARG_WITH([ldflags],\n\t[  --with-ldflags          Specify additional flags to pass to linker],\n\t[\n\t\tif test -n \"$withval\"  &&  test \"x$withval\" != \"xno\"  &&  \\\n\t\t    test \"x${withval}\" != \"xyes\"; then\n\t\t\tLDFLAGS=\"$LDFLAGS $withval\"\n\t\tfi\n\t]\n)\nAC_ARG_WITH([ldflags-after],\n\t[  --with-ldflags-after    Specify additional flags to pass to linker after configure],\n\t[\n\t\tif test -n \"$withval\"  &&  test \"x$withval\" != \"xno\"  &&  \\\n\t\t    test \"x${withval}\" != \"xyes\"; then\n\t\t\tLDFLAGS_AFTER=\"$withval\"\n\t\tfi\n\t]\n)\nAC_ARG_WITH([libs],\n\t[  --with-libs             Specify additional libraries to link with],\n\t[\n\t\tif test -n \"$withval\"  &&  test \"x$withval\" != \"xno\"  &&  \\\n\t\t    test \"x${withval}\" != \"xyes\"; then\n\t\t\tLIBS=\"$LIBS $withval\"\n\t\tfi\n\t]\n)\nAC_ARG_WITH([Werror],\n\t[  --with-Werror           Build main code with -Werror],\n\t[\n\t\tif test -n \"$withval\"  &&  test \"x$withval\" != \"xno\"; then\n\t\t\twerror_flags=\"-Werror\"\n\t\t\tif test \"x${withval}\" != \"xyes\"; then\n\t\t\t\twerror_flags=\"$withval\"\n\t\t\tfi\n\t\tfi\n\t]\n)\n\nAC_CHECK_HEADERS([ \\\n\tblf.h \\\n\tbstring.h \\\n\tcrypt.h \\\n\tcrypto/sha2.h \\\n\tdirent.h \\\n\tendian.h \\\n\telf.h \\\n\terr.h \\\n\tfeatures.h \\\n\tfcntl.h \\\n\tfloatingpoint.h \\\n\tfnmatch.h \\\n\tgetopt.h \\\n\tglob.h \\\n\tia.h \\\n\tiaf.h \\\n\tifaddrs.h \\\n\tinttypes.h \\\n\tlanginfo.h \\\n\tlimits.h \\\n\tlocale.h \\\n\tlogin.h \\\n\tmaillock.h \\\n\tndir.h \\\n\tnet/if_tun.h \\\n\tnetdb.h \\\n\tnetgroup.h \\\n\tpam/pam_appl.h \\\n\tpaths.h \\\n\tpoll.h \\\n\tpty.h \\\n\treadpassphrase.h \\\n\trpc/types.h \\\n\tsecurity/pam_appl.h \\\n\tsha2.h \\\n\tshadow.h \\\n\tstddef.h \\\n\tstdint.h \\\n\tstring.h \\\n\tstrings.h \\\n\tsys/bitypes.h \\\n\tsys/byteorder.h \\\n\tsys/bsdtty.h \\\n\tsys/cdefs.h \\\n\tsys/dir.h \\\n\tsys/file.h \\\n\tsys/mman.h \\\n\tsys/label.h \\\n\tsys/ndir.h \\\n\tsys/poll.h \\\n\tsys/prctl.h \\\n\tsys/pstat.h \\\n\tsys/ptrace.h \\\n\tsys/random.h \\\n\tsys/select.h \\\n\tsys/stat.h \\\n\tsys/stream.h \\\n\tsys/stropts.h \\\n\tsys/strtio.h \\\n\tsys/statvfs.h \\\n\tsys/sysmacros.h \\\n\tsys/time.h \\\n\tsys/timers.h \\\n\tsys/vfs.h \\\n\ttime.h \\\n\ttmpdir.h \\\n\tttyent.h \\\n\tucred.h \\\n\tunistd.h \\\n\tusersec.h \\\n\tutil.h \\\n\tutime.h \\\n\tutmp.h \\\n\tutmpx.h \\\n\tvis.h \\\n\twchar.h \\\n])\n\n# On some platforms (eg SunOS4) sys/audit.h requires sys/[time|types|label.h]\n# to be included first.\nAC_CHECK_HEADERS([sys/audit.h], [], [], [\n#ifdef HAVE_SYS_TIME_H\n# include <sys/time.h>\n#endif\n#ifdef HAVE_SYS_TYPES_H\n# include <sys/types.h>\n#endif\n#ifdef HAVE_SYS_LABEL_H\n# include <sys/label.h>\n#endif\n])\n\n# sys/capsicum.h requires sys/types.h\nAC_CHECK_HEADERS([sys/capsicum.h], [], [], [\n#ifdef HAVE_SYS_TYPES_H\n# include <sys/types.h>\n#endif\n])\n\n# net/route.h requires sys/socket.h and sys/types.h.\n# sys/sysctl.h also requires sys/param.h\nAC_CHECK_HEADERS([net/route.h sys/sysctl.h], [], [], [\n#ifdef HAVE_SYS_TYPES_H\n# include <sys/types.h>\n#endif\n#include <sys/param.h>\n#include <sys/socket.h>\n])\n\n# lastlog.h requires sys/time.h to be included first on Solaris\nAC_CHECK_HEADERS([lastlog.h], [], [], [\n#ifdef HAVE_SYS_TIME_H\n# include <sys/time.h>\n#endif\n])\n\n# sys/ptms.h requires sys/stream.h to be included first on Solaris\nAC_CHECK_HEADERS([sys/ptms.h], [], [], [\n#ifdef HAVE_SYS_STREAM_H\n# include <sys/stream.h>\n#endif\n])\n\n# login_cap.h requires sys/types.h on NetBSD\nAC_CHECK_HEADERS([login_cap.h], [], [], [\n#include <sys/types.h>\n])\n\n# older BSDs need sys/param.h before sys/mount.h\nAC_CHECK_HEADERS([sys/mount.h], [], [], [\n#include <sys/param.h>\n])\n\n# Android requires sys/socket.h to be included before sys/un.h\nAC_CHECK_HEADERS([sys/un.h], [], [], [\n#include <sys/types.h>\n#include <sys/socket.h>\n])\n\n# Messages for features tested for in target-specific section\nSIA_MSG=\"no\"\nSPC_MSG=\"no\"\nSP_MSG=\"no\"\nSPP_MSG=\"no\"\n\n# Support for Solaris/Illumos privileges (this test is used by both\n# the --with-solaris-privs option and --with-sandbox=solaris).\nSOLARIS_PRIVS=\"no\"\n\nAC_CHECK_SIZEOF([size_t])\n\n# Check for some target-specific stuff\ncase \"$host\" in\n*-*-aix*)\n\t# Some versions of VAC won't allow macro redefinitions at\n\t# -qlanglevel=ansi, and autoconf 2.60 sometimes insists on using that\n\t# particularly with older versions of vac or xlc.\n\t# It also throws errors about null macro arguments, but these are\n\t# not fatal.\n\tAC_MSG_CHECKING([if compiler allows macro redefinitions])\n\tAC_COMPILE_IFELSE(\n\t    [AC_LANG_PROGRAM([[\n#define testmacro foo\n#define testmacro bar]],\n\t    [[ exit(0); ]])],\n\t    [ AC_MSG_RESULT([yes]) ],\n\t    [ AC_MSG_RESULT([no])\n\t      CC=\"`echo $CC | sed 's/-qlanglvl\\=ansi//g'`\"\n\t      CFLAGS=\"`echo $CFLAGS | sed 's/-qlanglvl\\=ansi//g'`\"\n\t      CPPFLAGS=\"`echo $CPPFLAGS | sed 's/-qlanglvl\\=ansi//g'`\"\n\t    ]\n\t)\n\n\tAC_MSG_CHECKING([how to specify blibpath for linker ($LD)])\n\tif (test -z \"$blibpath\"); then\n\t\tblibpath=\"/usr/lib:/lib\"\n\tfi\n\tsaved_LDFLAGS=\"$LDFLAGS\"\n\tif test \"$GCC\" = \"yes\"; then\n\t\tflags=\"-Wl,-blibpath: -Wl,-rpath, -blibpath:\"\n\telse\n\t\tflags=\"-blibpath: -Wl,-blibpath: -Wl,-rpath,\"\n\tfi\n\tfor tryflags in $flags ;do\n\t\tif (test -z \"$blibflags\"); then\n\t\t\tLDFLAGS=\"$saved_LDFLAGS $tryflags$blibpath\"\n\t\t\tAC_LINK_IFELSE([AC_LANG_PROGRAM([[]], [[]])],\n\t\t\t[blibflags=$tryflags], [])\n\t\tfi\n\tdone\n\tif (test -z \"$blibflags\"); then\n\t\tAC_MSG_RESULT([not found])\n\t\tAC_MSG_ERROR([*** must be able to specify blibpath on AIX - check config.log])\n\telse\n\t\tAC_MSG_RESULT([$blibflags])\n\tfi\n\tLDFLAGS=\"$saved_LDFLAGS\"\n\tdnl Check for authenticate.  Might be in libs.a on older AIXes\n\tAC_CHECK_FUNC([authenticate], [AC_DEFINE([WITH_AIXAUTHENTICATE], [1],\n\t\t[Define if you want to enable AIX4's authenticate function])],\n\t\t[AC_CHECK_LIB([s], [authenticate],\n\t\t\t[ AC_DEFINE([WITH_AIXAUTHENTICATE])\n\t\t\t\tLIBS=\"$LIBS -ls\"\n\t\t\t])\n\t\t])\n\tdnl Check for various auth function declarations in headers.\n\tAC_CHECK_DECLS([authenticate, loginrestrictions, loginsuccess,\n\t    passwdexpired, setauthdb], , , [#include <usersec.h>])\n\tdnl Check if loginfailed is declared and takes 4 arguments (AIX >= 5.2)\n\tAC_CHECK_DECLS([loginfailed],\n\t    [AC_MSG_CHECKING([if loginfailed takes 4 arguments])\n\t    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[ #include <usersec.h> ]],\n\t\t[[ (void)loginfailed(\"user\",\"host\",\"tty\",0); ]])],\n\t\t[AC_MSG_RESULT([yes])\n\t\tAC_DEFINE([AIX_LOGINFAILED_4ARG], [1],\n\t\t\t[Define if your AIX loginfailed() function\n\t\t\ttakes 4 arguments (AIX >= 5.2)])], [AC_MSG_RESULT([no])\n\t    ])],\n\t    [],\n\t    [#include <usersec.h>]\n\t)\n\tAC_CHECK_FUNCS([getgrset setauthdb])\n\tAC_CHECK_DECL([F_CLOSEM],\n\t    AC_DEFINE([HAVE_FCNTL_CLOSEM], [1], [Use F_CLOSEM fcntl for closefrom]),\n\t    [],\n\t    [ #include <limits.h>\n\t      #include <fcntl.h> ]\n\t)\n\tcheck_for_aix_broken_getaddrinfo=1\n\tAC_DEFINE([SETEUID_BREAKS_SETUID], [1],\n\t    [Define if your platform breaks doing a seteuid before a setuid])\n\tAC_DEFINE([BROKEN_SETREUID], [1], [Define if your setreuid() is broken])\n\tAC_DEFINE([BROKEN_SETREGID], [1], [Define if your setregid() is broken])\n\tdnl AIX handles lastlog as part of its login message\n\tAC_DEFINE([DISABLE_LASTLOG], [1], [Define if you don't want to use lastlog])\n\tAC_DEFINE([LOGIN_NEEDS_UTMPX], [1],\n\t\t[Some systems need a utmpx entry for /bin/login to work])\n\tAC_DEFINE([SPT_TYPE], [SPT_REUSEARGV],\n\t\t[Define to a Set Process Title type if your system is\n\t\tsupported by bsd-setproctitle.c])\n\tAC_DEFINE([SSHPAM_CHAUTHTOK_NEEDS_RUID], [1],\n\t    [AIX 5.2 and 5.3 (and presumably newer) require this])\n\tAC_DEFINE([PTY_ZEROREAD], [1], [read(1) can return 0 for a non-closed fd])\n\tAC_DEFINE([PLATFORM_SYS_DIR_UID], 2, [System dirs owned by bin (uid 2)])\n\tAC_DEFINE([BROKEN_STRNDUP], 1, [strndup broken, see APAR IY61211])\n\tAC_DEFINE([BROKEN_STRNLEN], 1, [strnlen broken, see APAR IY62551])\n\t;;\n*-*-android*)\n\tAC_DEFINE([DISABLE_UTMP], [1], [Define if you don't want to use utmp])\n\tAC_DEFINE([DISABLE_WTMP], [1], [Define if you don't want to use wtmp])\n\t;;\n*-*-cygwin*)\n\tcheck_for_libcrypt_later=1\n\tLIBS=\"$LIBS /usr/lib/textreadmode.o\"\n\tAC_DEFINE([HAVE_CYGWIN], [1], [Define if you are on Cygwin])\n\tAC_DEFINE([USE_PIPES], [1], [Use PIPES instead of a socketpair()])\n\tAC_DEFINE([NO_UID_RESTORATION_TEST], [1],\n\t\t[Define to disable UID restoration test])\n\tAC_DEFINE([DISABLE_SHADOW], [1],\n\t\t[Define if you want to disable shadow passwords])\n\tAC_DEFINE([NO_X11_UNIX_SOCKETS], [1],\n\t\t[Define if X11 doesn't support AF_UNIX sockets on that system])\n\tAC_DEFINE([DISABLE_FD_PASSING], [1],\n\t\t[Define if your platform needs to skip post auth\n\t\tfile descriptor passing])\n\tAC_DEFINE([SSH_IOBUFSZ], [65535], [Windows is sensitive to read buffer size])\n\tAC_DEFINE([FILESYSTEM_NO_BACKSLASH], [1], [File names may not contain backslash characters])\n\t# Cygwin defines optargs, optargs as declspec(dllimport) for historical\n\t# reasons which cause compile warnings, so we disable those warnings.\n\tOSSH_CHECK_CFLAG_COMPILE([-Wno-attributes])\n\t;;\n*-*-dgux*)\n\tAC_DEFINE([IP_TOS_IS_BROKEN], [1],\n\t\t[Define if your system choked on IP TOS setting])\n\tAC_DEFINE([SETEUID_BREAKS_SETUID])\n\tAC_DEFINE([BROKEN_SETREUID])\n\tAC_DEFINE([BROKEN_SETREGID])\n\t;;\n*-*-darwin*)\n\tuse_pie=auto\n\tAC_MSG_CHECKING([if we have working getaddrinfo])\n\tAC_RUN_IFELSE([AC_LANG_SOURCE([[\n#include <mach-o/dyld.h>\n#include <stdlib.h>\nmain() { if (NSVersionOfRunTimeLibrary(\"System\") >= (60 << 16))\n\t\texit(0);\n\telse\n\t\texit(1);\n}\n\t\t\t]])],\n\t[AC_MSG_RESULT([working])],\n\t[AC_MSG_RESULT([buggy])\n\tAC_DEFINE([BROKEN_GETADDRINFO], [1],\n\t\t[getaddrinfo is broken (if present)])\n\t],\n\t[AC_MSG_RESULT([assume it is working])])\n\tAC_DEFINE([SETEUID_BREAKS_SETUID])\n\tAC_DEFINE([BROKEN_SETREUID])\n\tAC_DEFINE([BROKEN_SETREGID])\n\tAC_DEFINE([BROKEN_GLOB], [1], [OS X glob does not do what we expect])\n\tAC_DEFINE_UNQUOTED([BIND_8_COMPAT], [1],\n\t\t[Define if your resolver libs need this for getrrsetbyname])\n\tAC_DEFINE([SSH_TUN_FREEBSD], [1], [Open tunnel devices the FreeBSD way])\n\tAC_DEFINE([SSH_TUN_COMPAT_AF], [1],\n\t    [Use tunnel device compatibility to OpenBSD])\n\tAC_DEFINE([SSH_TUN_PREPEND_AF], [1],\n\t    [Prepend the address family to IP tunnel traffic])\n\tm4_pattern_allow([AU_IPv])\n\tAC_CHECK_DECL([AU_IPv4], [],\n\t    AC_DEFINE([AU_IPv4], [0], [System only supports IPv4 audit records])\n\t    [#include <bsm/audit.h>]\n\tAC_DEFINE([LASTLOG_WRITE_PUTUTXLINE], [1],\n\t    [Define if pututxline updates lastlog too])\n\t)\n\tAC_DEFINE([SPT_TYPE], [SPT_REUSEARGV],\n\t\t[Define to a Set Process Title type if your system is\n\t\tsupported by bsd-setproctitle.c])\n\tAC_CHECK_FUNCS([sandbox_init])\n\tAC_CHECK_HEADERS([sandbox.h])\n\tAC_CHECK_LIB([sandbox], [sandbox_apply], [\n\t    SSHDLIBS=\"$SSHDLIBS -lsandbox\"\n\t])\n\t# proc_pidinfo()-based closefrom() replacement.\n\tAC_CHECK_HEADERS([libproc.h])\n\tAC_CHECK_FUNCS([proc_pidinfo])\n\t;;\n*-*-dragonfly*)\n\tSSHDLIBS=\"$SSHDLIBS -lcrypt\"\n\tTEST_MALLOC_OPTIONS=\"AFGJPRX\"\n\t;;\n*-*-haiku*)\n\tLIBS=\"$LIBS -lbsd \"\n\tCFLAGS=\"$CFLAGS -D_BSD_SOURCE\"\n\tAC_CHECK_LIB([network], [socket])\n\tAC_DEFINE([HAVE_U_INT64_T])\n\tAC_DEFINE([DISABLE_UTMPX], [1], [no utmpx])\n\tMANTYPE=man\n\t;;\n*-*-hpux*)\n\t# first we define all of the options common to all HP-UX releases\n\tCPPFLAGS=\"$CPPFLAGS -D_HPUX_SOURCE -D_XOPEN_SOURCE -D_XOPEN_SOURCE_EXTENDED=1\"\n\tIPADDR_IN_DISPLAY=yes\n\tAC_DEFINE([USE_PIPES])\n\tAC_DEFINE([LOGIN_NEEDS_UTMPX])\n\tAC_DEFINE([LOCKED_PASSWD_STRING], [\"*\"],\n\t\t[String used in /etc/passwd to denote locked account])\n\tAC_DEFINE([SPT_TYPE], [SPT_PSTAT])\n\tAC_DEFINE([PLATFORM_SYS_DIR_UID], 2, [System dirs owned by bin (uid 2)])\n\tmaildir=\"/var/mail\"\n\tLIBS=\"$LIBS -lsec\"\n\tAC_CHECK_LIB([xnet], [t_error], ,\n\t    [AC_MSG_ERROR([*** -lxnet needed on HP-UX - check config.log ***])])\n\n\t# next, we define all of the options specific to major releases\n\tcase \"$host\" in\n\t*-*-hpux10*)\n\t\tif test -z \"$GCC\"; then\n\t\t\tCFLAGS=\"$CFLAGS -Ae\"\n\t\tfi\n\t\t;;\n\t*-*-hpux11*)\n\t\tAC_DEFINE([PAM_SUN_CODEBASE], [1],\n\t\t\t[Define if you are using Solaris-derived PAM which\n\t\t\tpasses pam_messages to the conversation function\n\t\t\twith an extra level of indirection])\n\t\tAC_DEFINE([DISABLE_UTMP], [1],\n\t\t\t[Define if you don't want to use utmp])\n\t\tAC_DEFINE([USE_BTMP], [1], [Use btmp to log bad logins])\n\t\tcheck_for_hpux_broken_getaddrinfo=1\n\t\tcheck_for_conflicting_getspnam=1\n\t\t;;\n\tesac\n\n\t# lastly, we define options specific to minor releases\n\tcase \"$host\" in\n\t*-*-hpux10.26)\n\t\tAC_DEFINE([HAVE_SECUREWARE], [1],\n\t\t\t[Define if you have SecureWare-based\n\t\t\tprotected password database])\n\t\tdisable_ptmx_check=yes\n\t\tLIBS=\"$LIBS -lsecpw\"\n\t\t;;\n\tesac\n\t;;\n*-*-irix5*)\n\tPATH=\"$PATH:/usr/etc\"\n\tAC_DEFINE([BROKEN_INET_NTOA], [1],\n\t\t[Define if you system's inet_ntoa is busted\n\t\t(e.g. Irix gcc issue)])\n\tAC_DEFINE([SETEUID_BREAKS_SETUID])\n\tAC_DEFINE([BROKEN_SETREUID])\n\tAC_DEFINE([BROKEN_SETREGID])\n\tAC_DEFINE([WITH_ABBREV_NO_TTY], [1],\n\t\t[Define if you shouldn't strip 'tty' from your\n\t\tttyname in [uw]tmp])\n\tAC_DEFINE([LOCKED_PASSWD_STRING], [\"*LK*\"])\n\t;;\n*-*-irix6*)\n\tPATH=\"$PATH:/usr/etc\"\n\tAC_DEFINE([WITH_IRIX_ARRAY], [1],\n\t\t[Define if you have/want arrays\n\t\t(cluster-wide session management, not C arrays)])\n\tAC_DEFINE([WITH_IRIX_PROJECT], [1],\n\t\t[Define if you want IRIX project management])\n\tAC_DEFINE([WITH_IRIX_AUDIT], [1],\n\t\t[Define if you want IRIX audit trails])\n\tAC_CHECK_FUNC([jlimit_startjob], [AC_DEFINE([WITH_IRIX_JOBS], [1],\n\t\t[Define if you want IRIX kernel jobs])])\n\tAC_DEFINE([BROKEN_INET_NTOA])\n\tAC_DEFINE([SETEUID_BREAKS_SETUID])\n\tAC_DEFINE([BROKEN_SETREUID])\n\tAC_DEFINE([BROKEN_SETREGID])\n\tAC_DEFINE([BROKEN_UPDWTMPX], [1], [updwtmpx is broken (if present)])\n\tAC_DEFINE([WITH_ABBREV_NO_TTY])\n\tAC_DEFINE([LOCKED_PASSWD_STRING], [\"*LK*\"])\n\t;;\n*-*-k*bsd*-gnu | *-*-kopensolaris*-gnu)\n\tcheck_for_libcrypt_later=1\n\tAC_DEFINE([PAM_TTY_KLUDGE])\n\tAC_DEFINE([LOCKED_PASSWD_PREFIX], [\"!\"])\n\tAC_DEFINE([SPT_TYPE], [SPT_REUSEARGV])\n\tAC_DEFINE([_PATH_BTMP], [\"/var/log/btmp\"], [log for bad login attempts])\n\tAC_DEFINE([USE_BTMP], [1], [Use btmp to log bad logins])\n\t;;\n*-*-linux*)\n\tno_dev_ptmx=1\n\tuse_pie=auto\n\tcheck_for_libcrypt_later=1\n\tcheck_for_openpty_ctty_bug=1\n\tdnl Target SUSv3/POSIX.1-2001 plus BSD specifics.\n\tdnl _DEFAULT_SOURCE is the new name for _BSD_SOURCE\n\tCPPFLAGS=\"$CPPFLAGS -D_XOPEN_SOURCE=600 -D_BSD_SOURCE -D_DEFAULT_SOURCE\"\n\tAC_DEFINE([PAM_TTY_KLUDGE], [1],\n\t\t[Work around problematic Linux PAM modules handling of PAM_TTY])\n\tAC_DEFINE([LOCKED_PASSWD_PREFIX], [\"!\"],\n\t\t[String used in /etc/passwd to denote locked account])\n\tAC_DEFINE([SPT_TYPE], [SPT_REUSEARGV])\n\tAC_DEFINE([LINK_OPNOTSUPP_ERRNO], [EPERM],\n\t\t[Define to whatever link() returns for \"not supported\"\n\t\tif it doesn't return EOPNOTSUPP.])\n\tAC_DEFINE([_PATH_BTMP], [\"/var/log/btmp\"], [log for bad login attempts])\n\tAC_DEFINE([USE_BTMP])\n\tAC_DEFINE([LINUX_OOM_ADJUST], [1], [Adjust Linux out-of-memory killer])\n\tinet6_default_4in6=yes\n\tcase `uname -r` in\n\t1.*|2.0.*)\n\t\tAC_DEFINE([BROKEN_CMSG_TYPE], [1],\n\t\t\t[Define if cmsg_type is not passed correctly])\n\t\t;;\n\tesac\n\t# tun(4) forwarding compat code\n\tAC_CHECK_HEADERS([linux/if_tun.h])\n\tif test \"x$ac_cv_header_linux_if_tun_h\" = \"xyes\" ; then\n\t\tAC_DEFINE([SSH_TUN_LINUX], [1],\n\t\t    [Open tunnel devices the Linux tun/tap way])\n\t\tAC_DEFINE([SSH_TUN_COMPAT_AF], [1],\n\t\t    [Use tunnel device compatibility to OpenBSD])\n\t\tAC_DEFINE([SSH_TUN_PREPEND_AF], [1],\n\t\t    [Prepend the address family to IP tunnel traffic])\n\tfi\n\tAC_CHECK_HEADER([linux/if.h],\n\t    AC_DEFINE([SYS_RDOMAIN_LINUX], [1],\n\t\t[Support routing domains using Linux VRF]), [], [\n#ifdef HAVE_SYS_TYPES_H\n# include <sys/types.h>\n#endif\n\t    ])\n\tAC_CHECK_HEADERS([linux/seccomp.h linux/filter.h linux/audit.h], [],\n\t    [], [#include <linux/types.h>])\n\t# Obtain MIPS ABI\n\tcase \"$host\" in\n\tmips*)\n\t\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#if _MIPS_SIM != _ABIO32\n#error\n#endif\n\t\t\t]])],[mips_abi=\"o32\"],[AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#if _MIPS_SIM != _ABIN32\n#error\n#endif\n\t\t\t\t]])],[mips_abi=\"n32\"],[AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#if _MIPS_SIM != _ABI64\n#error\n#endif\n\t\t\t\t\t]])],[mips_abi=\"n64\"],[AC_MSG_ERROR([unknown MIPS ABI])\n\t\t\t\t])\n\t\t\t])\n\t\t])\n\t\t;;\n\tesac\n\tAC_MSG_CHECKING([for seccomp architecture])\n\tseccomp_audit_arch=\n\tcase \"$host\" in\n\tx86_64-*)\n\t\tseccomp_audit_arch=AUDIT_ARCH_X86_64\n\t\t# X32: AMD64 instructions in 32bit address space.\n\t\tif test \"x$ac_cv_sizeof_size_t\" = \"x4\" ; then\n\t\t\tseccomp_audit_arch=AUDIT_ARCH_I386\n\t\tfi\n\t\t;;\n\ti*86-*)\n\t\tseccomp_audit_arch=AUDIT_ARCH_I386\n\t\t;;\n\tarm*-*)\n\t\tseccomp_audit_arch=AUDIT_ARCH_ARM\n\t\t;;\n\taarch64*-*)\n\t\tseccomp_audit_arch=AUDIT_ARCH_AARCH64\n\t\t;;\n\ts390x-*)\n\t\tseccomp_audit_arch=AUDIT_ARCH_S390X\n\t\t;;\n\ts390-*)\n\t\tseccomp_audit_arch=AUDIT_ARCH_S390\n\t\t;;\n\tpowerpc64-*)\n\t\tseccomp_audit_arch=AUDIT_ARCH_PPC64\n\t\t;;\n\tpowerpc64le-*)\n\t\tseccomp_audit_arch=AUDIT_ARCH_PPC64LE\n\t\t;;\n\tmips-*)\n\t\tseccomp_audit_arch=AUDIT_ARCH_MIPS\n\t\t;;\n\tmipsel-*)\n\t\tseccomp_audit_arch=AUDIT_ARCH_MIPSEL\n\t\t;;\n\tmips64-*)\n\t\tcase \"$mips_abi\" in\n\t\t\"n32\")\n\t\t\tseccomp_audit_arch=AUDIT_ARCH_MIPS64N32\n\t\t\t;;\n\t\t\"n64\")\n\t\t\tseccomp_audit_arch=AUDIT_ARCH_MIPS64\n\t\t\t;;\n\t\tesac\n\t\t;;\n\tmips64el-*)\n\t\tcase \"$mips_abi\" in\n\t\t\"n32\")\n\t\t\tseccomp_audit_arch=AUDIT_ARCH_MIPSEL64N32\n\t\t\t;;\n\t\t\"n64\")\n\t\t\tseccomp_audit_arch=AUDIT_ARCH_MIPSEL64\n\t\t\t;;\n\t\tesac\n\t\t;;\n\triscv64-*)\n\t\tseccomp_audit_arch=AUDIT_ARCH_RISCV64\n\t\t;;\n\tesac\n\tif test \"x$seccomp_audit_arch\" != \"x\" ; then\n\t\tAC_MSG_RESULT([\"$seccomp_audit_arch\"])\n\t\tAC_DEFINE_UNQUOTED([SECCOMP_AUDIT_ARCH], [$seccomp_audit_arch],\n\t\t    [Specify the system call convention in use])\n\telse\n\t\tAC_MSG_RESULT([architecture not supported])\n\tfi\n\t;;\nmips-sony-bsd|mips-sony-newsos4)\n\tAC_DEFINE([NEED_SETPGRP], [1], [Need setpgrp to acquire controlling tty])\n\tSONY=1\n\t;;\n*-*-netbsd*)\n\tcheck_for_libcrypt_before=1\n\tif test \"x$withval\" != \"xno\" ; then\n\t\trpath_opt=\"-R\"\n\tfi\n\tCPPFLAGS=\"$CPPFLAGS -D_OPENBSD_SOURCE\"\n\tAC_DEFINE([SSH_TUN_FREEBSD], [1], [Open tunnel devices the FreeBSD way])\n\tAC_CHECK_HEADER([net/if_tap.h], ,\n\t    AC_DEFINE([SSH_TUN_NO_L2], [1], [No layer 2 tunnel support]))\n\tAC_DEFINE([SSH_TUN_PREPEND_AF], [1],\n\t    [Prepend the address family to IP tunnel traffic])\n\tTEST_MALLOC_OPTIONS=\"AJRX\"\n\tAC_DEFINE([BROKEN_READ_COMPARISON], [1],\n\t    [NetBSD read function is sometimes redirected, breaking atomicio comparisons against it])\n\t;;\n*-*-freebsd*)\n\tcheck_for_libcrypt_later=1\n\tAC_DEFINE([LOCKED_PASSWD_PREFIX], [\"*LOCKED*\"], [Account locked with pw(1)])\n\tAC_DEFINE([SSH_TUN_FREEBSD], [1], [Open tunnel devices the FreeBSD way])\n\tAC_CHECK_HEADER([net/if_tap.h], ,\n\t    AC_DEFINE([SSH_TUN_NO_L2], [1], [No layer 2 tunnel support]))\n\tAC_DEFINE([BROKEN_GLOB], [1], [FreeBSD glob does not do what we need])\n\tTEST_MALLOC_OPTIONS=\"AJRX\"\n\t# Preauth crypto occasionally uses file descriptors for crypto offload\n\t# and will crash if they cannot be opened.\n\tAC_DEFINE([SANDBOX_SKIP_RLIMIT_NOFILE], [1],\n\t    [define if setrlimit RLIMIT_NOFILE breaks things])\n\t;;\n*-*-bsdi*)\n\tAC_DEFINE([SETEUID_BREAKS_SETUID])\n\tAC_DEFINE([BROKEN_SETREUID])\n\tAC_DEFINE([BROKEN_SETREGID])\n\t;;\n*-next-*)\n\tconf_lastlog_location=\"/usr/adm/lastlog\"\n\tconf_utmp_location=/etc/utmp\n\tconf_wtmp_location=/usr/adm/wtmp\n\tmaildir=/usr/spool/mail\n\tAC_DEFINE([HAVE_NEXT], [1], [Define if you are on NeXT])\n\tAC_DEFINE([USE_PIPES])\n\tAC_DEFINE([BROKEN_SAVED_UIDS], [1], [Needed for NeXT])\n\t;;\n*-*-openbsd*)\n\tuse_pie=auto\n\tAC_DEFINE([HAVE_ATTRIBUTE__SENTINEL__], [1], [OpenBSD's gcc has sentinel])\n\tAC_DEFINE([HAVE_ATTRIBUTE__BOUNDED__], [1], [OpenBSD's gcc has bounded])\n\tAC_DEFINE([SSH_TUN_OPENBSD], [1], [Open tunnel devices the OpenBSD way])\n\tAC_DEFINE([SYSLOG_R_SAFE_IN_SIGHAND], [1],\n\t    [syslog_r function is safe to use in in a signal handler])\n\tTEST_MALLOC_OPTIONS=\"AFGJPRX\"\n\t;;\n*-*-solaris*)\n\tif test \"x$withval\" != \"xno\" ; then\n\t\trpath_opt=\"-R\"\n\tfi\n\tAC_DEFINE([PAM_SUN_CODEBASE])\n\tAC_DEFINE([LOGIN_NEEDS_UTMPX])\n\tAC_DEFINE([PAM_TTY_KLUDGE])\n\tAC_DEFINE([SSHPAM_CHAUTHTOK_NEEDS_RUID], [1],\n\t\t[Define if pam_chauthtok wants real uid set\n\t\tto the unpriv'ed user])\n\tAC_DEFINE([LOCKED_PASSWD_STRING], [\"*LK*\"])\n\t# Pushing STREAMS modules will cause sshd to acquire a controlling tty.\n\tAC_DEFINE([SSHD_ACQUIRES_CTTY], [1],\n\t\t[Define if sshd somehow reacquires a controlling TTY\n\t\tafter setsid()])\n\tAC_DEFINE([PASSWD_NEEDS_USERNAME], [1], [must supply username to passwd\n\t\tin case the name is longer than 8 chars])\n\tAC_DEFINE([BROKEN_TCGETATTR_ICANON], [1], [tcgetattr with ICANON may hang])\n\texternal_path_file=/etc/default/login\n\t# hardwire lastlog location (can't detect it on some versions)\n\tconf_lastlog_location=\"/var/adm/lastlog\"\n\tAC_MSG_CHECKING([for obsolete utmp and wtmp in solaris2.x])\n\tsol2ver=`echo \"$host\"| sed -e 's/.*[[0-9]]\\.//'`\n\tif test \"$sol2ver\" -ge 8; then\n\t\tAC_MSG_RESULT([yes])\n\t\tAC_DEFINE([DISABLE_UTMP])\n\t\tAC_DEFINE([DISABLE_WTMP], [1],\n\t\t\t[Define if you don't want to use wtmp])\n\telse\n\t\tAC_MSG_RESULT([no])\n\tfi\n\tAC_CHECK_FUNCS([setpflags])\n\tAC_CHECK_FUNCS([setppriv])\n\tAC_CHECK_FUNCS([priv_basicset])\n\tAC_CHECK_HEADERS([priv.h])\n\tAC_ARG_WITH([solaris-contracts],\n\t\t[  --with-solaris-contracts Enable Solaris process contracts (experimental)],\n\t\t[\n\t\tAC_CHECK_LIB([contract], [ct_tmpl_activate],\n\t\t\t[ AC_DEFINE([USE_SOLARIS_PROCESS_CONTRACTS], [1],\n\t\t\t\t[Define if you have Solaris process contracts])\n\t\t\t  LIBS=\"$LIBS -lcontract\"\n\t\t\t  SPC_MSG=\"yes\" ], )\n\t\t],\n\t)\n\tAC_ARG_WITH([solaris-projects],\n\t\t[  --with-solaris-projects Enable Solaris projects (experimental)],\n\t\t[\n\t\tAC_CHECK_LIB([project], [setproject],\n\t\t\t[ AC_DEFINE([USE_SOLARIS_PROJECTS], [1],\n\t\t\t\t[Define if you have Solaris projects])\n\t\t\tLIBS=\"$LIBS -lproject\"\n\t\t\tSP_MSG=\"yes\" ], )\n\t\t],\n\t)\n\tAC_ARG_WITH([solaris-privs],\n\t\t[  --with-solaris-privs    Enable Solaris/Illumos privileges (experimental)],\n\t\t[\n\t\tAC_MSG_CHECKING([for Solaris/Illumos privilege support])\n\t\tif test \"x$ac_cv_func_setppriv\" = \"xyes\" -a \\\n\t\t\t\"x$ac_cv_header_priv_h\" = \"xyes\" ; then\n\t\t\tSOLARIS_PRIVS=yes\n\t\t\tAC_MSG_RESULT([found])\n\t\t\tAC_DEFINE([NO_UID_RESTORATION_TEST], [1],\n\t\t\t\t[Define to disable UID restoration test])\n\t\t\tAC_DEFINE([USE_SOLARIS_PRIVS], [1],\n\t\t\t\t[Define if you have Solaris privileges])\n\t\t\tSPP_MSG=\"yes\"\n\t\telse\n\t\t\tAC_MSG_RESULT([not found])\n\t\t\tAC_MSG_ERROR([*** must have support for Solaris privileges to use --with-solaris-privs])\n\t\tfi\n\t\t],\n\t)\n\tTEST_SHELL=$SHELL\t# let configure find us a capable shell\n\t;;\n*-*-sunos4*)\n\tCPPFLAGS=\"$CPPFLAGS -DSUNOS4\"\n\tAC_CHECK_FUNCS([getpwanam])\n\tAC_DEFINE([PAM_SUN_CODEBASE])\n\tconf_utmp_location=/etc/utmp\n\tconf_wtmp_location=/var/adm/wtmp\n\tconf_lastlog_location=/var/adm/lastlog\n\tAC_DEFINE([USE_PIPES])\n\tAC_DEFINE([DISABLE_UTMPX], [1], [no utmpx])\n\t;;\n*-ncr-sysv*)\n\tLIBS=\"$LIBS -lc89\"\n\tAC_DEFINE([USE_PIPES])\n\tAC_DEFINE([SSHD_ACQUIRES_CTTY])\n\tAC_DEFINE([SETEUID_BREAKS_SETUID])\n\tAC_DEFINE([BROKEN_SETREUID])\n\tAC_DEFINE([BROKEN_SETREGID])\n\t;;\n*-sni-sysv*)\n\t# /usr/ucblib MUST NOT be searched on ReliantUNIX\n\tAC_CHECK_LIB([dl], [dlsym], ,)\n\t# -lresolv needs to be at the end of LIBS or DNS lookups break\n\tAC_CHECK_LIB([resolv], [res_query], [ LIBS=\"$LIBS -lresolv\" ])\n\tIPADDR_IN_DISPLAY=yes\n\tAC_DEFINE([USE_PIPES])\n\tAC_DEFINE([IP_TOS_IS_BROKEN])\n\tAC_DEFINE([SETEUID_BREAKS_SETUID])\n\tAC_DEFINE([BROKEN_SETREUID])\n\tAC_DEFINE([BROKEN_SETREGID])\n\tAC_DEFINE([SSHD_ACQUIRES_CTTY])\n\texternal_path_file=/etc/default/login\n\t# /usr/ucblib/libucb.a no longer needed on ReliantUNIX\n\t# Attention: always take care to bind libsocket and libnsl before libc,\n\t# otherwise you will find lots of \"SIOCGPGRP errno 22\" on syslog\n\t;;\n# UnixWare 1.x, UnixWare 2.x, and others based on code from Univel.\n*-*-sysv4.2*)\n\tAC_DEFINE([USE_PIPES])\n\tAC_DEFINE([SETEUID_BREAKS_SETUID])\n\tAC_DEFINE([BROKEN_SETREUID])\n\tAC_DEFINE([BROKEN_SETREGID])\n\tAC_DEFINE([PASSWD_NEEDS_USERNAME], [1], [must supply username to passwd])\n\tAC_DEFINE([LOCKED_PASSWD_STRING], [\"*LK*\"])\n\tTEST_SHELL=$SHELL\t# let configure find us a capable shell\n\t;;\n# UnixWare 7.x, OpenUNIX 8\n*-*-sysv5*)\n\tCPPFLAGS=\"$CPPFLAGS -Dvsnprintf=_xvsnprintf -Dsnprintf=_xsnprintf\"\n\tAC_DEFINE([UNIXWARE_LONG_PASSWORDS], [1], [Support passwords > 8 chars])\n\tAC_DEFINE([USE_PIPES])\n\tAC_DEFINE([SETEUID_BREAKS_SETUID])\n\tAC_DEFINE([BROKEN_GETADDRINFO])\n\tAC_DEFINE([BROKEN_SETREUID])\n\tAC_DEFINE([BROKEN_SETREGID])\n\tAC_DEFINE([PASSWD_NEEDS_USERNAME])\n\tAC_DEFINE([BROKEN_TCGETATTR_ICANON])\n\tTEST_SHELL=$SHELL\t# let configure find us a capable shell\n\tcheck_for_libcrypt_later=1\n\tcase \"$host\" in\n\t*-*-sysv5SCO_SV*)\t# SCO OpenServer 6.x\n\t\tmaildir=/var/spool/mail\n\t\tAC_DEFINE([BROKEN_UPDWTMPX])\n\t\tAC_CHECK_LIB([prot], [getluid], [ LIBS=\"$LIBS -lprot\"\n\t\t\tAC_CHECK_FUNCS([getluid setluid], , , [-lprot])\n\t\t\t], , )\n\t\t;;\n\t*)\tAC_DEFINE([LOCKED_PASSWD_STRING], [\"*LK*\"])\n\t\t;;\n\tesac\n\t;;\n*-*-sysv*)\n\t;;\n# SCO UNIX and OEM versions of SCO UNIX\n*-*-sco3.2v4*)\n\tAC_MSG_ERROR(\"This Platform is no longer supported.\")\n\t;;\n# SCO OpenServer 5.x\n*-*-sco3.2v5*)\n\tif test -z \"$GCC\"; then\n\t\tCFLAGS=\"$CFLAGS -belf\"\n\tfi\n\tLIBS=\"$LIBS -lprot -lx -ltinfo -lm\"\n\tno_dev_ptmx=1\n\tAC_DEFINE([USE_PIPES])\n\tAC_DEFINE([HAVE_SECUREWARE])\n\tAC_DEFINE([DISABLE_SHADOW])\n\tAC_DEFINE([DISABLE_FD_PASSING])\n\tAC_DEFINE([SETEUID_BREAKS_SETUID])\n\tAC_DEFINE([BROKEN_GETADDRINFO])\n\tAC_DEFINE([BROKEN_SETREUID])\n\tAC_DEFINE([BROKEN_SETREGID])\n\tAC_DEFINE([WITH_ABBREV_NO_TTY])\n\tAC_DEFINE([BROKEN_UPDWTMPX])\n\tAC_DEFINE([PASSWD_NEEDS_USERNAME])\n\tAC_CHECK_FUNCS([getluid setluid])\n\tMANTYPE=man\n\tTEST_SHELL=$SHELL\t# let configure find us a capable shell\n\tSKIP_DISABLE_LASTLOG_DEFINE=yes\n\t;;\n*-dec-osf*)\n\tAC_MSG_CHECKING([for Digital Unix SIA])\n\tno_osfsia=\"\"\n\tAC_ARG_WITH([osfsia],\n\t\t[  --with-osfsia           Enable Digital Unix SIA],\n\t\t[\n\t\t\tif test \"x$withval\" = \"xno\" ; then\n\t\t\t\tAC_MSG_RESULT([disabled])\n\t\t\t\tno_osfsia=1\n\t\t\tfi\n\t\t],\n\t)\n\tif test -z \"$no_osfsia\" ; then\n\t\tif test -f /etc/sia/matrix.conf; then\n\t\t\tAC_MSG_RESULT([yes])\n\t\t\tAC_DEFINE([HAVE_OSF_SIA], [1],\n\t\t\t\t[Define if you have Digital Unix Security\n\t\t\t\tIntegration Architecture])\n\t\t\tAC_DEFINE([DISABLE_LOGIN], [1],\n\t\t\t\t[Define if you don't want to use your\n\t\t\t\tsystem's login() call])\n\t\t\tAC_DEFINE([DISABLE_FD_PASSING])\n\t\t\tLIBS=\"$LIBS -lsecurity -ldb -lm -laud\"\n\t\t\tSIA_MSG=\"yes\"\n\t\telse\n\t\t\tAC_MSG_RESULT([no])\n\t\t\tAC_DEFINE([LOCKED_PASSWD_SUBSTR], [\"Nologin\"],\n\t\t\t  [String used in /etc/passwd to denote locked account])\n\t\tfi\n\tfi\n\tAC_DEFINE([BROKEN_GETADDRINFO])\n\tAC_DEFINE([SETEUID_BREAKS_SETUID])\n\tAC_DEFINE([BROKEN_SETREUID])\n\tAC_DEFINE([BROKEN_SETREGID])\n\tAC_DEFINE([BROKEN_READV_COMPARISON], [1], [Can't do comparisons on readv])\n\t;;\n\n*-*-nto-qnx*)\n\tAC_DEFINE([USE_PIPES])\n\tAC_DEFINE([NO_X11_UNIX_SOCKETS])\n\tAC_DEFINE([DISABLE_LASTLOG])\n\tAC_DEFINE([SSHD_ACQUIRES_CTTY])\n\tAC_DEFINE([BROKEN_SHADOW_EXPIRE], [1], [QNX shadow support is broken])\n\tenable_etc_default_login=no\t# has incompatible /etc/default/login\n\tcase \"$host\" in\n\t*-*-nto-qnx6*)\n\t\tAC_DEFINE([DISABLE_FD_PASSING])\n\t\t;;\n\tesac\n\t;;\n\n*-*-ultrix*)\n\tAC_DEFINE([BROKEN_GETGROUPS], [1], [getgroups(0,NULL) will return -1])\n\tAC_DEFINE([NEED_SETPGRP], [1], [Need setpgrp to for controlling tty])\n\tAC_DEFINE([HAVE_SYS_SYSLOG_H], [1], [Force use of sys/syslog.h on Ultrix])\n\tAC_DEFINE([DISABLE_UTMPX], [1], [Disable utmpx])\n\t# DISABLE_FD_PASSING so that we call setpgrp as root, otherwise we\n\t# don't get a controlling tty.\n\tAC_DEFINE([DISABLE_FD_PASSING], [1], [Need to call setpgrp as root])\n\t# On Ultrix some headers are not protected against multiple includes,\n\t# so we create wrappers and put it where the compiler will find it.\n\tAC_MSG_WARN([creating compat wrappers for headers])\n\tmkdir -p netinet\n\tfor header in netinet/ip.h netdb.h resolv.h; do\n\t\tname=`echo $header | tr 'a-z/.' 'A-Z__'`\n\t\tcat >$header <<EOD\n#ifndef _SSH_COMPAT_${name}\n#define _SSH_COMPAT_${name}\n#include \"/usr/include/${header}\"\n#endif\nEOD\n\tdone\n\t;;\n\n*-*-lynxos)\n\tCFLAGS=\"$CFLAGS -D__NO_INCLUDE_WARN__\"\n\tAC_DEFINE([BROKEN_SETVBUF], [1],\n\t    [LynxOS has broken setvbuf() implementation])\n\t;;\nesac\n\nAC_MSG_CHECKING([compiler and flags for sanity])\nAC_RUN_IFELSE([AC_LANG_PROGRAM([[ #include <stdlib.h> ]], [[ exit(0); ]])],\n\t[\tAC_MSG_RESULT([yes]) ],\n\t[\n\t\tAC_MSG_RESULT([no])\n\t\tAC_MSG_ERROR([*** compiler cannot create working executables, check config.log ***])\n\t],\n\t[\tAC_MSG_WARN([cross compiling: not checking compiler sanity]) ]\n)\n\ndnl Checks for header files.\n# Checks for libraries.\nAC_CHECK_FUNC([setsockopt], , [AC_CHECK_LIB([socket], [setsockopt])])\n\ndnl IRIX and Solaris 2.5.1 have dirname() in libgen\nAC_CHECK_FUNCS([dirname], [AC_CHECK_HEADERS([libgen.h])] , [\n\tAC_CHECK_LIB([gen], [dirname], [\n\t\tAC_CACHE_CHECK([for broken dirname],\n\t\t\tac_cv_have_broken_dirname, [\n\t\t\tsave_LIBS=\"$LIBS\"\n\t\t\tLIBS=\"$LIBS -lgen\"\n\t\t\tAC_RUN_IFELSE(\n\t\t\t\t[AC_LANG_SOURCE([[\n#include <libgen.h>\n#include <string.h>\n#include <stdlib.h>\n\nint main(int argc, char **argv) {\n    char *s, buf[32];\n\n    strncpy(buf,\"/etc\", 32);\n    s = dirname(buf);\n    if (!s || strncmp(s, \"/\", 32) != 0) {\n\texit(1);\n    } else {\n\texit(0);\n    }\n}\n\t\t\t\t]])],\n\t\t\t\t[ ac_cv_have_broken_dirname=\"no\" ],\n\t\t\t\t[ ac_cv_have_broken_dirname=\"yes\" ],\n\t\t\t\t[ ac_cv_have_broken_dirname=\"no\" ],\n\t\t\t)\n\t\t\tLIBS=\"$save_LIBS\"\n\t\t])\n\t\tif test \"x$ac_cv_have_broken_dirname\" = \"xno\" ; then\n\t\t\tLIBS=\"$LIBS -lgen\"\n\t\t\tAC_DEFINE([HAVE_DIRNAME])\n\t\t\tAC_CHECK_HEADERS([libgen.h])\n\t\tfi\n\t])\n])\n\nAC_CHECK_FUNC([getspnam], ,\n\t[AC_CHECK_LIB([gen], [getspnam], [LIBS=\"$LIBS -lgen\"])])\nAC_SEARCH_LIBS([basename], [gen], [AC_DEFINE([HAVE_BASENAME], [1],\n\t[Define if you have the basename function.])])\n\ndnl zlib defaults to enabled\nzlib=yes\nAC_ARG_WITH([zlib],\n\t[  --with-zlib=PATH        Use zlib in PATH],\n\t[ if test \"x$withval\" = \"xno\" ; then\n\t\tzlib=no\n\t  elif test \"x$withval\" != \"xyes\"; then\n\t\tif test -d \"$withval/lib\"; then\n\t\t\tif test -n \"${rpath_opt}\"; then\n\t\t\t\tLDFLAGS=\"-L${withval}/lib ${rpath_opt}${withval}/lib ${LDFLAGS}\"\n\t\t\telse\n\t\t\t\tLDFLAGS=\"-L${withval}/lib ${LDFLAGS}\"\n\t\t\tfi\n\t\telse\n\t\t\tif test -n \"${rpath_opt}\"; then\n\t\t\t\tLDFLAGS=\"-L${withval} ${rpath_opt}${withval} ${LDFLAGS}\"\n\t\t\telse\n\t\t\t\tLDFLAGS=\"-L${withval} ${LDFLAGS}\"\n\t\t\tfi\n\t\tfi\n\t\tif test -d \"$withval/include\"; then\n\t\t\tCPPFLAGS=\"-I${withval}/include ${CPPFLAGS}\"\n\t\telse\n\t\t\tCPPFLAGS=\"-I${withval} ${CPPFLAGS}\"\n\t\tfi\n\tfi ]\n)\n\nAC_MSG_CHECKING([for zlib])\nif test \"x${zlib}\" = \"xno\"; then\n\tAC_MSG_RESULT([no])\nelse\n\tAC_MSG_RESULT([yes])\n\tAC_DEFINE([WITH_ZLIB], [1], [Enable zlib])\n    AC_CHECK_HEADER([zlib.h], ,[AC_MSG_ERROR([*** zlib.h missing - please install first or check config.log ***])])\n    AC_CHECK_LIB([z], [deflate], ,\n\t[\n\t\tsaved_CPPFLAGS=\"$CPPFLAGS\"\n\t\tsaved_LDFLAGS=\"$LDFLAGS\"\n\t\tsave_LIBS=\"$LIBS\"\n\t\tdnl Check default zlib install dir\n\t\tif test -n \"${rpath_opt}\"; then\n\t\t\tLDFLAGS=\"-L/usr/local/lib ${rpath_opt}/usr/local/lib ${saved_LDFLAGS}\"\n\t\telse\n\t\t\tLDFLAGS=\"-L/usr/local/lib ${saved_LDFLAGS}\"\n\t\tfi\n\t\tCPPFLAGS=\"-I/usr/local/include ${saved_CPPFLAGS}\"\n\t\tLIBS=\"$LIBS -lz\"\n\t\tAC_TRY_LINK_FUNC([deflate], [AC_DEFINE([HAVE_LIBZ])],\n\t\t\t[\n\t\t\t\tAC_MSG_ERROR([*** zlib missing - please install first or check config.log ***])\n\t\t\t]\n\t\t)\n\t]\n    )\n\n    AC_ARG_WITH([zlib-version-check],\n\t[  --without-zlib-version-check Disable zlib version check],\n\t[  if test \"x$withval\" = \"xno\" ; then\n\t\tzlib_check_nonfatal=1\n\t   fi\n\t]\n    )\n\n    AC_MSG_CHECKING([for possibly buggy zlib])\n    AC_RUN_IFELSE([AC_LANG_PROGRAM([[\n#include <stdio.h>\n#include <stdlib.h>\n#include <zlib.h>\n\t]],\n\t[[\n\tint a=0, b=0, c=0, d=0, n, v;\n\tn = sscanf(ZLIB_VERSION, \"%d.%d.%d.%d\", &a, &b, &c, &d);\n\tif (n != 3 && n != 4)\n\t\texit(1);\n\tv = a*1000000 + b*10000 + c*100 + d;\n\tfprintf(stderr, \"found zlib version %s (%d)\\n\", ZLIB_VERSION, v);\n\n\t/* 1.1.4 is OK */\n\tif (a == 1 && b == 1 && c >= 4)\n\t\texit(0);\n\n\t/* 1.2.3 and up are OK */\n\tif (v >= 1020300)\n\t\texit(0);\n\n\texit(2);\n\t]])],\n\tAC_MSG_RESULT([no]),\n\t[ AC_MSG_RESULT([yes])\n\t  if test -z \"$zlib_check_nonfatal\" ; then\n\t\tAC_MSG_ERROR([*** zlib too old - check config.log ***\nYour reported zlib version has known security problems.  It's possible your\nvendor has fixed these problems without changing the version number.  If you\nare sure this is the case, you can disable the check by running\n\"./configure --without-zlib-version-check\".\nIf you are in doubt, upgrade zlib to version 1.2.3 or greater.\nSee http://www.gzip.org/zlib/ for details.])\n\t  else\n\t\tAC_MSG_WARN([zlib version may have security problems])\n\t  fi\n\t],\n\t[\tAC_MSG_WARN([cross compiling: not checking zlib version]) ]\n    )\nfi\n\ndnl UnixWare 2.x\nAC_CHECK_FUNC([strcasecmp],\n\t[], [ AC_CHECK_LIB([resolv], [strcasecmp], [LIBS=\"$LIBS -lresolv\"]) ]\n)\nAC_CHECK_FUNCS([utimes],\n\t[], [ AC_CHECK_LIB([c89], [utimes], [AC_DEFINE([HAVE_UTIMES])\n\t\t\t\t\tLIBS=\"$LIBS -lc89\"]) ]\n)\n\ndnl    Checks for libutil functions\nAC_CHECK_HEADERS([bsd/libutil.h libutil.h])\nAC_SEARCH_LIBS([fmt_scaled], [util bsd])\nAC_SEARCH_LIBS([scan_scaled], [util bsd])\nAC_SEARCH_LIBS([login], [util bsd])\nAC_SEARCH_LIBS([logout], [util bsd])\nAC_SEARCH_LIBS([logwtmp], [util bsd])\nAC_SEARCH_LIBS([openpty], [util bsd])\nAC_SEARCH_LIBS([updwtmp], [util bsd])\nAC_CHECK_FUNCS([fmt_scaled scan_scaled login logout openpty updwtmp logwtmp])\n\n# On some platforms, inet_ntop and gethostbyname may be found in libresolv\n# or libnsl.\nAC_SEARCH_LIBS([inet_ntop], [resolv nsl])\nAC_SEARCH_LIBS([gethostbyname], [resolv nsl])\n\n# \"Particular Function Checks\"\n# see https://www.gnu.org/software/autoconf/manual/autoconf-2.69/html_node/Particular-Functions.html\nAC_FUNC_STRFTIME\nAC_FUNC_MALLOC\nAC_FUNC_REALLOC\n# autoconf doesn't have AC_FUNC_CALLOC so fake it if malloc returns NULL;\nAC_MSG_CHECKING([if calloc(0, N) returns non-null])\nAC_RUN_IFELSE(\n\t[AC_LANG_PROGRAM(\n\t\t[[ #include <stdlib.h> ]],\n\t\t[[ void *p = calloc(0, 1); exit(p == NULL); ]]\n\t)],\n\t[ func_calloc_0_nonnull=yes ],\n\t[ func_calloc_0_nonnull=no ],\n\t[ AC_MSG_WARN([cross compiling: assuming same as malloc])\n\t  func_calloc_0_nonnull=\"$ac_cv_func_malloc_0_nonnull\"]\n)\nAC_MSG_RESULT([$func_calloc_0_nonnull])\n\nif test \"x$func_calloc_0_nonnull\" = \"xyes\"; then\n\tAC_DEFINE(HAVE_CALLOC, 1, [calloc(0, x) returns non-null])\nelse\n\tAC_DEFINE(HAVE_CALLOC, 0, [calloc(0, x) returns NULL])\n\tAC_DEFINE(calloc, rpl_calloc,\n\t    [Define to rpl_calloc if the replacement function should be used.])\nfi\n\n# Check for ALTDIRFUNC glob() extension\nAC_MSG_CHECKING([for GLOB_ALTDIRFUNC support])\nAC_EGREP_CPP([FOUNDIT],\n\t[\n\t\t#include <glob.h>\n\t\t#ifdef GLOB_ALTDIRFUNC\n\t\tFOUNDIT\n\t\t#endif\n\t],\n\t[\n\t\tAC_DEFINE([GLOB_HAS_ALTDIRFUNC], [1],\n\t\t\t[Define if your system glob() function has\n\t\t\tthe GLOB_ALTDIRFUNC extension])\n\t\tAC_MSG_RESULT([yes])\n\t],\n\t[\n\t\tAC_MSG_RESULT([no])\n\t]\n)\n\n# Check for g.gl_matchc glob() extension\nAC_MSG_CHECKING([for gl_matchc field in glob_t])\nAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[ #include <glob.h> ]],\n\t[[ glob_t g; g.gl_matchc = 1; ]])],\n\t[\n\t\tAC_DEFINE([GLOB_HAS_GL_MATCHC], [1],\n\t\t\t[Define if your system glob() function has\n\t\t\tgl_matchc options in glob_t])\n\t\tAC_MSG_RESULT([yes])\n\t], [\n\t\tAC_MSG_RESULT([no])\n])\n\n# Check for g.gl_statv glob() extension\nAC_MSG_CHECKING([for gl_statv and GLOB_KEEPSTAT extensions for glob])\nAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[ #include <glob.h> ]], [[\n#ifndef GLOB_KEEPSTAT\n#error \"glob does not support GLOB_KEEPSTAT extension\"\n#endif\nglob_t g;\ng.gl_statv = NULL;\n]])],\n\t[\n\t\tAC_DEFINE([GLOB_HAS_GL_STATV], [1],\n\t\t\t[Define if your system glob() function has\n\t\t\tgl_statv options in glob_t])\n\t\tAC_MSG_RESULT([yes])\n\t], [\n\t\tAC_MSG_RESULT([no])\n\n])\n\nAC_CHECK_DECLS([GLOB_NOMATCH], , , [#include <glob.h>])\n\nAC_CHECK_DECL([VIS_ALL], ,\n    AC_DEFINE(BROKEN_STRNVIS, 1, [missing VIS_ALL]), [#include <vis.h>])\n\nAC_MSG_CHECKING([whether struct dirent allocates space for d_name])\nAC_RUN_IFELSE(\n\t[AC_LANG_PROGRAM([[\n#include <sys/types.h>\n#include <dirent.h>\n#include <stdlib.h>\n\t]],\n\t[[\n\tstruct dirent d;\n\texit(sizeof(d.d_name)<=sizeof(char));\n\t]])],\n\t[AC_MSG_RESULT([yes])],\n\t[\n\t\tAC_MSG_RESULT([no])\n\t\tAC_DEFINE([BROKEN_ONE_BYTE_DIRENT_D_NAME], [1],\n\t\t\t[Define if your struct dirent expects you to\n\t\t\tallocate extra space for d_name])\n\t],\n\t[\n\t\tAC_MSG_WARN([cross compiling: assuming BROKEN_ONE_BYTE_DIRENT_D_NAME])\n\t\tAC_DEFINE([BROKEN_ONE_BYTE_DIRENT_D_NAME])\n\t]\n)\n\nAC_MSG_CHECKING([for /proc/pid/fd directory])\nif test -d \"/proc/$$/fd\" ; then\n\tAC_DEFINE([HAVE_PROC_PID], [1], [Define if you have /proc/$pid/fd])\n\tAC_MSG_RESULT([yes])\nelse\n\tAC_MSG_RESULT([no])\nfi\n\n# Check whether user wants to use ldns\nLDNS_MSG=\"no\"\nAC_ARG_WITH(ldns,\n\t[  --with-ldns[[=PATH]]      Use ldns for DNSSEC support (optionally in PATH)],\n\t[\n\tldns=\"\"\n\tif test \"x$withval\" = \"xyes\" ; then\n\t\tAC_PATH_TOOL([LDNSCONFIG], [ldns-config], [no])\n\t\tif test \"x$LDNSCONFIG\" = \"xno\"; then\n\t\t\tLIBS=\"-lldns $LIBS\"\n\t\t\tldns=yes\n\t\telse\n\t\t\tLIBS=\"$LIBS `$LDNSCONFIG --libs`\"\n\t\t\tCPPFLAGS=\"$CPPFLAGS `$LDNSCONFIG --cflags`\"\n\t\t\tldns=yes\n\t\tfi\n\telif test \"x$withval\" != \"xno\" ; then\n\t\t\tCPPFLAGS=\"$CPPFLAGS -I${withval}/include\"\n\t\t\tLDFLAGS=\"$LDFLAGS -L${withval}/lib\"\n\t\t\tLIBS=\"-lldns $LIBS\"\n\t\t\tldns=yes\n\tfi\n\n\t# Verify that it works.\n\tif test \"x$ldns\" = \"xyes\" ; then\n\t\tAC_DEFINE(HAVE_LDNS, 1, [Define if you want ldns support])\n\t\tLDNS_MSG=\"yes\"\n\t\tAC_MSG_CHECKING([for ldns support])\n\t\tAC_LINK_IFELSE(\n\t\t\t[AC_LANG_SOURCE([[\n#include <stdio.h>\n#include <stdlib.h>\n#ifdef HAVE_STDINT_H\n# include <stdint.h>\n#endif\n#include <ldns/ldns.h>\nint main() { ldns_status status = ldns_verify_trusted(NULL, NULL, NULL, NULL); status=LDNS_STATUS_OK; exit(0); }\n\t\t\t]])\n\t\t],\n\t\t\t[AC_MSG_RESULT(yes)],\n\t\t\t\t[\n\t\t\t\t\tAC_MSG_RESULT(no)\n\t\t\t\t\tAC_MSG_ERROR([** Incomplete or missing ldns libraries.])\n\t\t\t\t])\n\tfi\n])\n\n# Check whether user wants libedit support\nLIBEDIT_MSG=\"no\"\nAC_ARG_WITH([libedit],\n\t[  --with-libedit[[=PATH]]   Enable libedit support for sftp],\n\t[ if test \"x$withval\" != \"xno\" ; then\n\t\tif test \"x$withval\" = \"xyes\" ; then\n\t\t\tAC_PATH_TOOL([PKGCONFIG], [pkg-config], [no])\n\t\t\tif test \"x$PKGCONFIG\" != \"xno\"; then\n\t\t\t\tAC_MSG_CHECKING([if $PKGCONFIG knows about libedit])\n\t\t\t\tif \"$PKGCONFIG\" libedit; then\n\t\t\t\t\tAC_MSG_RESULT([yes])\n\t\t\t\t\tuse_pkgconfig_for_libedit=yes\n\t\t\t\telse\n\t\t\t\t\tAC_MSG_RESULT([no])\n\t\t\t\tfi\n\t\t\tfi\n\t\telse\n\t\t\tCPPFLAGS=\"$CPPFLAGS -I${withval}/include\"\n\t\t\tif test -n \"${rpath_opt}\"; then\n\t\t\t\tLDFLAGS=\"-L${withval}/lib ${rpath_opt}${withval}/lib ${LDFLAGS}\"\n\t\t\telse\n\t\t\t\tLDFLAGS=\"-L${withval}/lib ${LDFLAGS}\"\n\t\t\tfi\n\t\tfi\n\t\tif test \"x$use_pkgconfig_for_libedit\" = \"xyes\"; then\n\t\t\tLIBEDIT=`$PKGCONFIG --libs libedit`\n\t\t\tCPPFLAGS=\"$CPPFLAGS `$PKGCONFIG --cflags libedit`\"\n\t\telse\n\t\t\tLIBEDIT=\"-ledit -lcurses\"\n\t\tfi\n\t\tOTHERLIBS=`echo $LIBEDIT | sed 's/-ledit//'`\n\t\tAC_CHECK_LIB([edit], [el_init],\n\t\t\t[ AC_DEFINE([USE_LIBEDIT], [1], [Use libedit for sftp])\n\t\t\t  LIBEDIT_MSG=\"yes\"\n\t\t\t  AC_SUBST([LIBEDIT])\n\t\t\t],\n\t\t\t[ AC_MSG_ERROR([libedit not found]) ],\n\t\t\t[ $OTHERLIBS ]\n\t\t)\n\t\tAC_MSG_CHECKING([if libedit version is compatible])\n\t\tAC_COMPILE_IFELSE(\n\t\t    [AC_LANG_PROGRAM([[\n#include <histedit.h>\n#include <stdlib.h>\n\t\t    ]],\n\t\t    [[\n\tint i = H_SETSIZE;\n\tel_init(\"\", NULL, NULL, NULL);\n\texit(0);\n\t\t    ]])],\n\t\t    [ AC_MSG_RESULT([yes]) ],\n\t\t    [ AC_MSG_RESULT([no])\n\t\t      AC_MSG_ERROR([libedit version is not compatible]) ]\n\t\t)\n\tfi ]\n)\n\nAUDIT_MODULE=none\nAC_ARG_WITH([audit],\n\t[  --with-audit=module     Enable audit support (modules=debug,bsm,linux)],\n\t[\n\t  AC_MSG_CHECKING([for supported audit module])\n\t  case \"$withval\" in\n\t  bsm)\n\t\tAC_MSG_RESULT([bsm])\n\t\tAUDIT_MODULE=bsm\n\t\tdnl    Checks for headers, libs and functions\n\t\tAC_CHECK_HEADERS([bsm/audit.h], [],\n\t\t    [AC_MSG_ERROR([BSM enabled and bsm/audit.h not found])],\n\t\t    [\n#ifdef HAVE_TIME_H\n# include <time.h>\n#endif\n\t\t    ]\n)\n\t\tAC_CHECK_LIB([bsm], [getaudit], [],\n\t\t    [AC_MSG_ERROR([BSM enabled and required library not found])])\n\t\tAC_CHECK_FUNCS([getaudit], [],\n\t\t    [AC_MSG_ERROR([BSM enabled and required function not found])])\n\t\t# These are optional\n\t\tAC_CHECK_FUNCS([getaudit_addr aug_get_machine])\n\t\tAC_DEFINE([USE_BSM_AUDIT], [1], [Use BSM audit module])\n\t\tif test \"$sol2ver\" -ge 11; then\n\t\t\tSSHDLIBS=\"$SSHDLIBS -lscf\"\n\t\t\tAC_DEFINE([BROKEN_BSM_API], [1],\n\t\t\t\t[The system has incomplete BSM API])\n\t\tfi\n\t\t;;\n\t  linux)\n\t\tAC_MSG_RESULT([linux])\n\t\tAUDIT_MODULE=linux\n\t\tdnl    Checks for headers, libs and functions\n\t\tAC_CHECK_HEADERS([libaudit.h])\n\t\tSSHDLIBS=\"$SSHDLIBS -laudit\"\n\t\tAC_DEFINE([USE_LINUX_AUDIT], [1], [Use Linux audit module])\n\t\t;;\n\t  debug)\n\t\tAUDIT_MODULE=debug\n\t\tAC_MSG_RESULT([debug])\n\t\tAC_DEFINE([SSH_AUDIT_EVENTS], [1], [Use audit debugging module])\n\t\t;;\n\t  no)\n\t\tAC_MSG_RESULT([no])\n\t\t;;\n\t  *)\n\t\tAC_MSG_ERROR([Unknown audit module $withval])\n\t\t;;\n\tesac ]\n)\n\nAC_ARG_WITH([pie],\n    [  --with-pie              Build Position Independent Executables if possible], [\n\tif test \"x$withval\" = \"xno\"; then\n\t\tuse_pie=no\n\tfi\n\tif test \"x$withval\" = \"xyes\"; then\n\t\tuse_pie=yes\n\tfi\n    ]\n)\nif test \"x$use_pie\" = \"x\"; then\n\tuse_pie=no\nfi\nif test \"x$use_toolchain_hardening\" != \"x1\" && test \"x$use_pie\" = \"xauto\"; then\n\t# Turn off automatic PIE when toolchain hardening is off.\n\tuse_pie=no\nfi\nif test \"x$use_pie\" = \"xauto\"; then\n\t# Automatic PIE requires gcc >= 4.x\n\tAC_MSG_CHECKING([for gcc >= 4.x])\n\tAC_COMPILE_IFELSE([AC_LANG_SOURCE([[\n#if !defined(__GNUC__) || __GNUC__ < 4\n#error gcc is too old\n#endif\n]])],\n\t[ AC_MSG_RESULT([yes]) ],\n\t[ AC_MSG_RESULT([no])\n\t  use_pie=no ]\n)\nfi\nif test \"x$use_pie\" != \"xno\"; then\n\tSAVED_CFLAGS=\"$CFLAGS\"\n\tSAVED_LDFLAGS=\"$LDFLAGS\"\n\tOSSH_CHECK_CFLAG_COMPILE([-fPIE])\n\tOSSH_CHECK_LDFLAG_LINK([-pie])\n\t# We use both -fPIE and -pie or neither.\n\tAC_MSG_CHECKING([whether both -fPIE and -pie are supported])\n\tif echo \"x $CFLAGS\"  | grep ' -fPIE' >/dev/null 2>&1 && \\\n\t   echo \"x $LDFLAGS\" | grep ' -pie'  >/dev/null 2>&1 ; then\n\t\tAC_MSG_RESULT([yes])\n\telse\n\t\tAC_MSG_RESULT([no])\n\t\tCFLAGS=\"$SAVED_CFLAGS\"\n\t\tLDFLAGS=\"$SAVED_LDFLAGS\"\n\tfi\nfi\n\nAC_MSG_CHECKING([whether -fPIC is accepted])\nSAVED_CFLAGS=\"$CFLAGS\"\nCFLAGS=\"$CFLAGS -fPIC\"\nAC_COMPILE_IFELSE(\n\t[AC_LANG_PROGRAM( [[ #include <stdlib.h> ]], [[ exit(0); ]] )],\n   [AC_MSG_RESULT([yes])\n    PICFLAG=\"-fPIC\"; ],\n   [AC_MSG_RESULT([no])\n    PICFLAG=\"\"; ])\nCFLAGS=\"$SAVED_CFLAGS\"\nAC_SUBST([PICFLAG])\n\ndnl    Checks for library functions. Please keep in alphabetical order\nAC_CHECK_FUNCS([ \\\n\tBlowfish_initstate \\\n\tBlowfish_expandstate \\\n\tBlowfish_expand0state \\\n\tBlowfish_stream2word \\\n\tSHA256Update \\\n\tSHA384Update \\\n\tSHA512Update \\\n\tasprintf \\\n\tb64_ntop \\\n\t__b64_ntop \\\n\tb64_pton \\\n\t__b64_pton \\\n\tbcopy \\\n\tbcrypt_pbkdf \\\n\tbindresvport_sa \\\n\tblf_enc \\\n\tbzero \\\n\tcap_rights_limit \\\n\tclock \\\n\tclosefrom \\\n\tdirfd \\\n\tendgrent \\\n\terr \\\n\terrx \\\n\texplicit_bzero \\\n\tfchmod \\\n\tfchmodat \\\n\tfchown \\\n\tfchownat \\\n\tflock \\\n\tfnmatch \\\n\tfreeaddrinfo \\\n\tfreezero \\\n\tfstatfs \\\n\tfstatvfs \\\n\tfutimes \\\n\tgetaddrinfo \\\n\tgetcwd \\\n\tgetgrouplist \\\n\tgetline \\\n\tgetnameinfo \\\n\tgetopt \\\n\tgetpagesize \\\n\tgetpeereid \\\n\tgetpeerucred \\\n\tgetpgid \\\n\t_getpty \\\n\tgetrlimit \\\n\tgetrandom \\\n\tgetsid \\\n\tgetttyent \\\n\tglob \\\n\tgroup_from_gid \\\n\tinet_aton \\\n\tinet_ntoa \\\n\tinet_ntop \\\n\tinnetgr \\\n\tllabs \\\n\tlocaltime_r \\\n\tlogin_getcapbool \\\n\tmd5_crypt \\\n\tmemmem \\\n\tmemmove \\\n\tmemset_s \\\n\tmkdtemp \\\n\tngetaddrinfo \\\n\tnsleep \\\n\togetaddrinfo \\\n\topenlog_r \\\n\tpledge \\\n\tpoll \\\n\tprctl \\\n\tpstat \\\n\traise \\\n\treadpassphrase \\\n\treallocarray \\\n\trealpath \\\n\trecvmsg \\\n\trecallocarray \\\n\trresvport_af \\\n\tsendmsg \\\n\tsetdtablesize \\\n\tsetegid \\\n\tsetenv \\\n\tseteuid \\\n\tsetgroupent \\\n\tsetgroups \\\n\tsetlinebuf \\\n\tsetlogin \\\n\tsetpassent\\\n\tsetpcred \\\n\tsetproctitle \\\n\tsetregid \\\n\tsetreuid \\\n\tsetrlimit \\\n\tsetsid \\\n\tsetvbuf \\\n\tsigaction \\\n\tsigvec \\\n\tsnprintf \\\n\tsocketpair \\\n\tstatfs \\\n\tstatvfs \\\n\tstrcasestr \\\n\tstrdup \\\n\tstrerror \\\n\tstrlcat \\\n\tstrlcpy \\\n\tstrmode \\\n\tstrndup \\\n\tstrnlen \\\n\tstrnvis \\\n\tstrptime \\\n\tstrsignal \\\n\tstrtonum \\\n\tstrtoll \\\n\tstrtoul \\\n\tstrtoull \\\n\tswap32 \\\n\tsysconf \\\n\ttcgetpgrp \\\n\ttimingsafe_bcmp \\\n\ttruncate \\\n\tunsetenv \\\n\tupdwtmpx \\\n\tutimensat \\\n\tuser_from_uid \\\n\tusleep \\\n\tvasprintf \\\n\tvsnprintf \\\n\twaitpid \\\n\twarn \\\n])\n\nAC_CHECK_DECLS([bzero, memmem])\n\ndnl Wide character support.\nAC_CHECK_FUNCS([mblen mbtowc nl_langinfo wcwidth])\n\nTEST_SSH_UTF8=${TEST_SSH_UTF8:=yes}\nAC_MSG_CHECKING([for utf8 locale support])\nAC_RUN_IFELSE(\n\t[AC_LANG_PROGRAM([[\n#include <locale.h>\n#include <stdlib.h>\n\t]], [[\n\tchar *loc = setlocale(LC_CTYPE, \"en_US.UTF-8\");\n\tif (loc != NULL)\n\t\texit(0);\n\texit(1);\n\t]])],\n\tAC_MSG_RESULT(yes),\n\t[AC_MSG_RESULT(no)\n\t TEST_SSH_UTF8=no],\n\tAC_MSG_WARN([cross compiling: assuming yes])\n)\n\nAC_LINK_IFELSE(\n        [AC_LANG_PROGRAM(\n           [[ #include <ctype.h> ]],\n           [[ return (isblank('a')); ]])],\n\t[AC_DEFINE([HAVE_ISBLANK], [1], [Define if you have isblank(3C).])\n])\n\ndisable_pkcs11=\nAC_ARG_ENABLE([pkcs11],\n\t[  --disable-pkcs11        disable PKCS#11 support code [no]],\n\t[\n\t\tif test \"x$enableval\" = \"xno\" ; then\n\t\t\tdisable_pkcs11=1\n\t\tfi\n\t]\n)\n\ndisable_sk=\nAC_ARG_ENABLE([security-key],\n\t[  --disable-security-key  disable U2F/FIDO support code [no]],\n\t[\n\t\tif test \"x$enableval\" = \"xno\" ; then\n\t\t\tdisable_sk=1\n\t\tfi\n\t]\n)\nenable_sk_internal=\nAC_ARG_WITH([security-key-builtin],\n\t[  --with-security-key-builtin include builtin U2F/FIDO support],\n\t[\n\t\tif test \"x$withval\" != \"xno\" ; then\n\t\t\tenable_sk_internal=yes\n\t\tfi\n\t]\n)\ntest \"x$disable_sk\" != \"x\" && enable_sk_internal=\"\"\n\nAC_SEARCH_LIBS([dlopen], [dl])\nAC_CHECK_FUNCS([dlopen])\nAC_CHECK_DECL([RTLD_NOW], [], [], [#include <dlfcn.h>])\n\n# IRIX has a const char return value for gai_strerror()\nAC_CHECK_FUNCS([gai_strerror], [\n\tAC_DEFINE([HAVE_GAI_STRERROR])\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netdb.h>\n\nconst char *gai_strerror(int);\n\t\t\t]], [[\n\tchar *str;\n\tstr = gai_strerror(0);\n\t\t\t]])], [\n\t\tAC_DEFINE([HAVE_CONST_GAI_STRERROR_PROTO], [1],\n\t\t[Define if gai_strerror() returns const char *])], [])])\n\nAC_SEARCH_LIBS([nanosleep], [rt posix4], [AC_DEFINE([HAVE_NANOSLEEP], [1],\n\t[Some systems put nanosleep outside of libc])])\n\nAC_SEARCH_LIBS([clock_gettime], [rt],\n\t[AC_DEFINE([HAVE_CLOCK_GETTIME], [1], [Have clock_gettime])])\n\ndnl check if we need -D_REENTRANT for localtime_r declaration.\nAC_CHECK_DECL([localtime_r], [],\n\t[ saved_CPPFLAGS=\"$CFLAGS\"\n\t  CPPFLAGS=\"$CPPFLAGS -D_REENTRANT\"\n\t  unset ac_cv_have_decl_localtime_r\n\t  AC_CHECK_DECL([localtime_r], [],\n\t\t[ CPPFLAGS=\"$saved_CPPFLAGS\" ],\n\t\t[ #include <time.h> ]\n\t  )\n\t],\n\t[ #include <time.h> ]\n)\n\ndnl Make sure prototypes are defined for these before using them.\nAC_CHECK_DECL([strsep],\n\t[AC_CHECK_FUNCS([strsep])],\n\t[],\n\t[\n#ifdef HAVE_STRING_H\n# include <string.h>\n#endif\n\t])\n\ndnl tcsendbreak might be a macro\nAC_CHECK_DECL([tcsendbreak],\n\t[AC_DEFINE([HAVE_TCSENDBREAK])],\n\t[AC_CHECK_FUNCS([tcsendbreak])],\n\t[#include <termios.h>]\n)\n\nAC_CHECK_DECLS([h_errno], , ,[#include <netdb.h>])\n\nAC_CHECK_DECLS([SHUT_RD, getpeereid], , ,\n\t[\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <unistd.h>\n\t])\n\nAC_CHECK_DECLS([O_NONBLOCK], , ,\n\t[\n#include <sys/types.h>\n#ifdef HAVE_SYS_STAT_H\n# include <sys/stat.h>\n#endif\n#ifdef HAVE_FCNTL_H\n# include <fcntl.h>\n#endif\n\t])\n\nAC_CHECK_DECLS([readv, writev], , , [\n#include <sys/types.h>\n#include <sys/uio.h>\n#include <unistd.h>\n\t])\n\nAC_CHECK_DECLS([MAXSYMLINKS], , , [\n#include <sys/param.h>\n\t])\n\nAC_CHECK_DECLS([offsetof], , , [\n#include <stddef.h>\n\t])\n\n# extra bits for select(2)\nAC_CHECK_DECLS([howmany, NFDBITS], [], [], [[\n#include <sys/param.h>\n#include <sys/types.h>\n#ifdef HAVE_SYS_SYSMACROS_H\n#include <sys/sysmacros.h>\n#endif\n#ifdef HAVE_SYS_SELECT_H\n#include <sys/select.h>\n#endif\n#ifdef HAVE_SYS_TIME_H\n#include <sys/time.h>\n#endif\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n\t]])\nAC_CHECK_TYPES([fd_mask], [], [], [[\n#include <sys/param.h>\n#include <sys/types.h>\n#ifdef HAVE_SYS_SELECT_H\n#include <sys/select.h>\n#endif\n#ifdef HAVE_SYS_TIME_H\n#include <sys/time.h>\n#endif\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n\t]])\n\nAC_CHECK_FUNCS([setresuid], [\n\tdnl Some platorms have setresuid that isn't implemented, test for this\n\tAC_MSG_CHECKING([if setresuid seems to work])\n\tAC_RUN_IFELSE(\n\t\t[AC_LANG_PROGRAM([[\n#include <stdlib.h>\n#include <errno.h>\n\t\t]], [[\n\terrno=0;\n\tsetresuid(0,0,0);\n\tif (errno==ENOSYS)\n\t\texit(1);\n\telse\n\t\texit(0);\n\t\t]])],\n\t\t[AC_MSG_RESULT([yes])],\n\t\t[AC_DEFINE([BROKEN_SETRESUID], [1],\n\t\t\t[Define if your setresuid() is broken])\n\t\t AC_MSG_RESULT([not implemented])],\n\t\t[AC_MSG_WARN([cross compiling: not checking setresuid])]\n\t)\n])\n\nAC_CHECK_FUNCS([setresgid], [\n\tdnl Some platorms have setresgid that isn't implemented, test for this\n\tAC_MSG_CHECKING([if setresgid seems to work])\n\tAC_RUN_IFELSE(\n\t\t[AC_LANG_PROGRAM([[\n#include <stdlib.h>\n#include <errno.h>\n\t\t]], [[\n\terrno=0;\n\tsetresgid(0,0,0);\n\tif (errno==ENOSYS)\n\t\texit(1);\n\telse\n\t\texit(0);\n\t\t]])],\n\t\t[AC_MSG_RESULT([yes])],\n\t\t[AC_DEFINE([BROKEN_SETRESGID], [1],\n\t\t\t[Define if your setresgid() is broken])\n\t\t AC_MSG_RESULT([not implemented])],\n\t\t[AC_MSG_WARN([cross compiling: not checking setresuid])]\n\t)\n])\n\nAC_MSG_CHECKING([for working fflush(NULL)])\nAC_RUN_IFELSE(\n\t[AC_LANG_PROGRAM([[\n#include <stdio.h>\n#include <stdlib.h>\n\t]],\n\t[[fflush(NULL); exit(0);]])],\n\tAC_MSG_RESULT([yes]),\n\t[AC_MSG_RESULT([no])\n\t AC_DEFINE([FFLUSH_NULL_BUG], [1],\n\t    [define if fflush(NULL) does not work])],\n\tAC_MSG_WARN([cross compiling: assuming working])\n)\n\ndnl    Checks for time functions\nAC_CHECK_FUNCS([gettimeofday time])\ndnl    Checks for utmp functions\nAC_CHECK_FUNCS([endutent getutent getutid getutline pututline setutent])\nAC_CHECK_FUNCS([utmpname])\ndnl    Checks for utmpx functions\nAC_CHECK_FUNCS([endutxent getutxent getutxid getutxline getutxuser pututxline])\nAC_CHECK_FUNCS([setutxdb setutxent utmpxname])\ndnl    Checks for lastlog functions\nAC_CHECK_FUNCS([getlastlogxbyname])\n\nAC_CHECK_FUNC([daemon],\n\t[AC_DEFINE([HAVE_DAEMON], [1], [Define if your libraries define daemon()])],\n\t[AC_CHECK_LIB([bsd], [daemon],\n\t\t[LIBS=\"$LIBS -lbsd\"; AC_DEFINE([HAVE_DAEMON])])]\n)\n\nAC_CHECK_FUNC([getpagesize],\n\t[AC_DEFINE([HAVE_GETPAGESIZE], [1],\n\t\t[Define if your libraries define getpagesize()])],\n\t[AC_CHECK_LIB([ucb], [getpagesize],\n\t\t[LIBS=\"$LIBS -lucb\"; AC_DEFINE([HAVE_GETPAGESIZE])])]\n)\n\n# Check for broken snprintf\nif test \"x$ac_cv_func_snprintf\" = \"xyes\" ; then\n\tAC_MSG_CHECKING([whether snprintf correctly terminates long strings])\n\tAC_RUN_IFELSE(\n\t\t[AC_LANG_PROGRAM([[\n#include <stdio.h>\n#include <stdlib.h>\n\t\t]],\n\t\t[[\n\tchar b[5];\n\tsnprintf(b,5,\"123456789\");\n\texit(b[4]!='\\0');\n\t\t]])],\n\t\t[AC_MSG_RESULT([yes])],\n\t\t[\n\t\t\tAC_MSG_RESULT([no])\n\t\t\tAC_DEFINE([BROKEN_SNPRINTF], [1],\n\t\t\t\t[Define if your snprintf is busted])\n\t\t\tAC_MSG_WARN([****** Your snprintf() function is broken, complain to your vendor])\n\t\t],\n\t\t[ AC_MSG_WARN([cross compiling: Assuming working snprintf()]) ]\n\t)\nfi\n\nif test \"x$ac_cv_func_snprintf\" = \"xyes\" ; then\n\tAC_MSG_CHECKING([whether snprintf understands %zu])\n\tAC_RUN_IFELSE(\n\t\t[AC_LANG_PROGRAM([[\n#include <sys/types.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\t\t]],\n\t\t[[\n\tsize_t a = 1, b = 2;\n\tchar z[128];\n\tsnprintf(z, sizeof z, \"%zu%zu\", a, b);\n\texit(strcmp(z, \"12\"));\n\t\t]])],\n\t\t[AC_MSG_RESULT([yes])],\n\t\t[\n\t\t\tAC_MSG_RESULT([no])\n\t\t\tAC_DEFINE([BROKEN_SNPRINTF], [1],\n\t\t\t\t[snprintf does not understand %zu])\n\t\t],\n\t\t[ AC_MSG_WARN([cross compiling: Assuming working snprintf()]) ]\n\t)\nfi\n\n# We depend on vsnprintf returning the right thing on overflow: the\n# number of characters it tried to create (as per SUSv3)\nif test \"x$ac_cv_func_vsnprintf\" = \"xyes\" ; then\n\tAC_MSG_CHECKING([whether vsnprintf returns correct values on overflow])\n\tAC_RUN_IFELSE(\n\t\t[AC_LANG_PROGRAM([[\n#include <sys/types.h>\n#include <stdio.h>\n#include <stdarg.h>\n\nint x_snprintf(char *str, size_t count, const char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}\n\t\t]], [[\nchar x[1];\nif (x_snprintf(x, 1, \"%s %d\", \"hello\", 12345) != 11)\n\treturn 1;\nif (x_snprintf(NULL, 0, \"%s %d\", \"hello\", 12345) != 11)\n\treturn 1;\nreturn 0;\n\t\t]])],\n\t\t[AC_MSG_RESULT([yes])],\n\t\t[\n\t\t\tAC_MSG_RESULT([no])\n\t\t\tAC_DEFINE([BROKEN_SNPRINTF], [1],\n\t\t\t\t[Define if your snprintf is busted])\n\t\t\tAC_MSG_WARN([****** Your vsnprintf() function is broken, complain to your vendor])\n\t\t],\n\t\t[ AC_MSG_WARN([cross compiling: Assuming working vsnprintf()]) ]\n\t)\nfi\n\n# On systems where [v]snprintf is broken, but is declared in stdio,\n# check that the fmt argument is const char * or just char *.\n# This is only useful for when BROKEN_SNPRINTF\nAC_MSG_CHECKING([whether snprintf can declare const char *fmt])\nAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#include <stdio.h>\nint snprintf(char *a, size_t b, const char *c, ...) { return 0; }\n\t\t]], [[\n\tsnprintf(0, 0, 0);\n\t\t]])],\n   [AC_MSG_RESULT([yes])\n    AC_DEFINE([SNPRINTF_CONST], [const],\n              [Define as const if snprintf() can declare const char *fmt])],\n   [AC_MSG_RESULT([no])\n    AC_DEFINE([SNPRINTF_CONST], [/* not const */])])\n\n# Check for missing getpeereid (or equiv) support\nNO_PEERCHECK=\"\"\nif test \"x$ac_cv_func_getpeereid\" != \"xyes\" -a \"x$ac_cv_func_getpeerucred\" != \"xyes\"; then\n\tAC_MSG_CHECKING([whether system supports SO_PEERCRED getsockopt])\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#include <sys/types.h>\n#include <sys/socket.h>]], [[int i = SO_PEERCRED;]])],\n\t\t[ AC_MSG_RESULT([yes])\n\t\t  AC_DEFINE([HAVE_SO_PEERCRED], [1], [Have PEERCRED socket option])\n\t\t], [AC_MSG_RESULT([no])\n\t\tNO_PEERCHECK=1\n        ])\nfi\n\ndnl see whether mkstemp() requires XXXXXX\nif test \"x$ac_cv_func_mkdtemp\" = \"xyes\" ; then\nAC_MSG_CHECKING([for (overly) strict mkstemp])\nAC_RUN_IFELSE(\n\t[AC_LANG_PROGRAM([[\n#include <stdlib.h>\n#include <unistd.h>\n\t]], [[\n\tchar template[]=\"conftest.mkstemp-test\";\n\tif (mkstemp(template) == -1)\n\t\texit(1);\n\tunlink(template);\n\texit(0);\n\t]])],\n\t[\n\t\tAC_MSG_RESULT([no])\n\t],\n\t[\n\t\tAC_MSG_RESULT([yes])\n\t\tAC_DEFINE([HAVE_STRICT_MKSTEMP], [1], [Silly mkstemp()])\n\t],\n\t[\n\t\tAC_MSG_RESULT([yes])\n\t\tAC_DEFINE([HAVE_STRICT_MKSTEMP])\n\t]\n)\nfi\n\ndnl make sure that openpty does not reacquire controlling terminal\nif test ! -z \"$check_for_openpty_ctty_bug\"; then\n\tAC_MSG_CHECKING([if openpty correctly handles controlling tty])\n\tAC_RUN_IFELSE(\n\t\t[AC_LANG_PROGRAM([[\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/fcntl.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n\t\t]], [[\n\tpid_t pid;\n\tint fd, ptyfd, ttyfd, status;\n\n\tpid = fork();\n\tif (pid < 0) {\t\t/* failed */\n\t\texit(1);\n\t} else if (pid > 0) {\t/* parent */\n\t\twaitpid(pid, &status, 0);\n\t\tif (WIFEXITED(status))\n\t\t\texit(WEXITSTATUS(status));\n\t\telse\n\t\t\texit(2);\n\t} else {\t\t/* child */\n\t\tclose(0); close(1); close(2);\n\t\tsetsid();\n\t\topenpty(&ptyfd, &ttyfd, NULL, NULL, NULL);\n\t\tfd = open(\"/dev/tty\", O_RDWR | O_NOCTTY);\n\t\tif (fd >= 0)\n\t\t\texit(3);\t/* Acquired ctty: broken */\n\t\telse\n\t\t\texit(0);\t/* Did not acquire ctty: OK */\n\t}\n\t\t]])],\n\t\t[\n\t\t\tAC_MSG_RESULT([yes])\n\t\t],\n\t\t[\n\t\t\tAC_MSG_RESULT([no])\n\t\t\tAC_DEFINE([SSHD_ACQUIRES_CTTY])\n\t\t],\n\t\t[\n\t\t\tAC_MSG_RESULT([cross-compiling, assuming yes])\n\t\t]\n\t)\nfi\n\nif test \"x$ac_cv_func_getaddrinfo\" = \"xyes\" && \\\n    test \"x$check_for_hpux_broken_getaddrinfo\" = \"x1\"; then\n\tAC_MSG_CHECKING([if getaddrinfo seems to work])\n\tAC_RUN_IFELSE(\n\t\t[AC_LANG_PROGRAM([[\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <errno.h>\n#include <netinet/in.h>\n\n#define TEST_PORT \"2222\"\n\t\t]], [[\n\tint err, sock;\n\tstruct addrinfo *gai_ai, *ai, hints;\n\tchar ntop[NI_MAXHOST], strport[NI_MAXSERV], *name = NULL;\n\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = PF_UNSPEC;\n\thints.ai_socktype = SOCK_STREAM;\n\thints.ai_flags = AI_PASSIVE;\n\n\terr = getaddrinfo(name, TEST_PORT, &hints, &gai_ai);\n\tif (err != 0) {\n\t\tfprintf(stderr, \"getaddrinfo failed (%s)\", gai_strerror(err));\n\t\texit(1);\n\t}\n\n\tfor (ai = gai_ai; ai != NULL; ai = ai->ai_next) {\n\t\tif (ai->ai_family != AF_INET6)\n\t\t\tcontinue;\n\n\t\terr = getnameinfo(ai->ai_addr, ai->ai_addrlen, ntop,\n\t\t    sizeof(ntop), strport, sizeof(strport),\n\t\t    NI_NUMERICHOST|NI_NUMERICSERV);\n\n\t\tif (err != 0) {\n\t\t\tif (err == EAI_SYSTEM)\n\t\t\t\tperror(\"getnameinfo EAI_SYSTEM\");\n\t\t\telse\n\t\t\t\tfprintf(stderr, \"getnameinfo failed: %s\\n\",\n\t\t\t\t    gai_strerror(err));\n\t\t\texit(2);\n\t\t}\n\n\t\tsock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);\n\t\tif (sock < 0)\n\t\t\tperror(\"socket\");\n\t\tif (bind(sock, ai->ai_addr, ai->ai_addrlen) < 0) {\n\t\t\tif (errno == EBADF)\n\t\t\t\texit(3);\n\t\t}\n\t}\n\texit(0);\n\t\t]])],\n\t\t[\n\t\t\tAC_MSG_RESULT([yes])\n\t\t],\n\t\t[\n\t\t\tAC_MSG_RESULT([no])\n\t\t\tAC_DEFINE([BROKEN_GETADDRINFO])\n\t\t],\n\t\t[\n\t\t\tAC_MSG_RESULT([cross-compiling, assuming yes])\n\t\t]\n\t)\nfi\n\nif test \"x$ac_cv_func_getaddrinfo\" = \"xyes\" && \\\n    test \"x$check_for_aix_broken_getaddrinfo\" = \"x1\"; then\n\tAC_MSG_CHECKING([if getaddrinfo seems to work])\n\tAC_RUN_IFELSE(\n\t\t[AC_LANG_PROGRAM([[\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <errno.h>\n#include <netinet/in.h>\n\n#define TEST_PORT \"2222\"\n\t\t]], [[\n\tint err, sock;\n\tstruct addrinfo *gai_ai, *ai, hints;\n\tchar ntop[NI_MAXHOST], strport[NI_MAXSERV], *name = NULL;\n\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = PF_UNSPEC;\n\thints.ai_socktype = SOCK_STREAM;\n\thints.ai_flags = AI_PASSIVE;\n\n\terr = getaddrinfo(name, TEST_PORT, &hints, &gai_ai);\n\tif (err != 0) {\n\t\tfprintf(stderr, \"getaddrinfo failed (%s)\", gai_strerror(err));\n\t\texit(1);\n\t}\n\n\tfor (ai = gai_ai; ai != NULL; ai = ai->ai_next) {\n\t\tif (ai->ai_family != AF_INET && ai->ai_family != AF_INET6)\n\t\t\tcontinue;\n\n\t\terr = getnameinfo(ai->ai_addr, ai->ai_addrlen, ntop,\n\t\t    sizeof(ntop), strport, sizeof(strport),\n\t\t    NI_NUMERICHOST|NI_NUMERICSERV);\n\n\t\tif (ai->ai_family == AF_INET && err != 0) {\n\t\t\tperror(\"getnameinfo\");\n\t\t\texit(2);\n\t\t}\n\t}\n\texit(0);\n\t\t]])],\n\t\t[\n\t\t\tAC_MSG_RESULT([yes])\n\t\t\tAC_DEFINE([AIX_GETNAMEINFO_HACK], [1],\n\t\t\t\t[Define if you have a getaddrinfo that fails\n\t\t\t\tfor the all-zeros IPv6 address])\n\t\t],\n\t\t[\n\t\t\tAC_MSG_RESULT([no])\n\t\t\tAC_DEFINE([BROKEN_GETADDRINFO])\n\t\t],\n\t\t[\n\t\t\tAC_MSG_RESULT([cross-compiling, assuming no])\n\t\t]\n\t)\nfi\n\nif test \"x$ac_cv_func_getaddrinfo\" = \"xyes\"; then\n\tAC_CHECK_DECLS(AI_NUMERICSERV, , ,\n\t    [#include <sys/types.h>\n\t     #include <sys/socket.h>\n\t     #include <netdb.h>])\nfi\n\nif test \"x$check_for_conflicting_getspnam\" = \"x1\"; then\n\tAC_MSG_CHECKING([for conflicting getspnam in shadow.h])\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#include <shadow.h>\n#include <stdlib.h>\n\t\t]],\n\t\t[[ exit(0); ]])],\n\t\t[\n\t\t\tAC_MSG_RESULT([no])\n\t\t],\n\t\t[\n\t\t\tAC_MSG_RESULT([yes])\n\t\t\tAC_DEFINE([GETSPNAM_CONFLICTING_DEFS], [1],\n\t\t\t    [Conflicting defs for getspnam])\n\t\t]\n\t)\nfi\n\ndnl NetBSD added an strnvis and unfortunately made it incompatible with the\ndnl existing one in OpenBSD and Linux's libbsd (the former having existed\ndnl for over ten years). Despite this incompatibility being reported during\ndnl development (see http://gnats.netbsd.org/44977) they still shipped it.\ndnl Even more unfortunately FreeBSD and later MacOS picked up this incompatible\ndnl implementation.  Try to detect this mess, and assume the only safe option\ndnl if we're cross compiling.\ndnl\ndnl OpenBSD, 2001: strnvis(char *dst, const char *src, size_t dlen, int flag);\ndnl NetBSD: 2012,  strnvis(char *dst, size_t dlen, const char *src, int flag);\nif test \"x$ac_cv_func_strnvis\" = \"xyes\"; then\n\tAC_MSG_CHECKING([for working strnvis])\n\tAC_RUN_IFELSE(\n\t\t[AC_LANG_PROGRAM([[\n#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <vis.h>\nstatic void sighandler(int sig) { _exit(1); }\n\t\t]], [[\n\tchar dst[16];\n\n\tsignal(SIGSEGV, sighandler);\n\tif (strnvis(dst, \"src\", 4, 0) && strcmp(dst, \"src\") == 0)\n\t\texit(0);\n\texit(1)\n\t\t]])],\n\t\t[AC_MSG_RESULT([yes])],\n\t\t[AC_MSG_RESULT([no])\n\t\t AC_DEFINE([BROKEN_STRNVIS], [1], [strnvis detected broken])],\n\t\t[AC_MSG_WARN([cross compiling: assuming broken])\n\t\t AC_DEFINE([BROKEN_STRNVIS], [1], [strnvis assumed broken])]\n\t)\nfi\n\nAC_MSG_CHECKING([if SA_RESTARTed signals interrupt select()])\nAC_RUN_IFELSE(\n\t[AC_LANG_PROGRAM([[\n#ifdef HAVE_SYS_SELECT\n# include <sys/select.h>\n#endif\n#include <sys/types.h>\n#include <sys/time.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\nstatic void sighandler(int sig) { }\n\t\t]], [[\n\tint r;\n\tpid_t pid;\n\tstruct sigaction sa;\n\n\tsa.sa_handler = sighandler;\n\tsa.sa_flags = SA_RESTART;\n\t(void)sigaction(SIGTERM, &sa, NULL);\n\tif ((pid = fork()) == 0) { /* child */\n\t\tpid = getppid();\n\t\tsleep(1);\n\t\tkill(pid, SIGTERM);\n\t\tsleep(1);\n\t\tif (getppid() == pid) /* if parent did not exit, shoot it */\n\t\t\tkill(pid, SIGKILL);\n\t\texit(0);\n\t} else { /* parent */\n\t\tr = select(0, NULL, NULL, NULL, NULL);\n\t}\n\texit(r == -1 ? 0 : 1);\n\t]])],\n\t[AC_MSG_RESULT([yes])],\n\t[AC_MSG_RESULT([no])\n\t AC_DEFINE([NO_SA_RESTART], [1],\n\t    [SA_RESTARTed signals do no interrupt select])],\n\t[AC_MSG_WARN([cross compiling: assuming yes])]\n)\n\nAC_CHECK_FUNCS([getpgrp],[\n\tAC_MSG_CHECKING([if getpgrp accepts zero args])\n\tAC_COMPILE_IFELSE(\n\t\t[AC_LANG_PROGRAM([[$ac_includes_default]], [[ getpgrp(); ]])],\n\t\t[ AC_MSG_RESULT([yes])\n\t\t  AC_DEFINE([GETPGRP_VOID], [1], [getpgrp takes zero args])],\n\t\t[ AC_MSG_RESULT([no])\n\t\t  AC_DEFINE([GETPGRP_VOID], [0], [getpgrp takes one arg])]\n\t)\n])\n\n# Search for OpenSSL\nsaved_CPPFLAGS=\"$CPPFLAGS\"\nsaved_LDFLAGS=\"$LDFLAGS\"\nAC_ARG_WITH([ssl-dir],\n\t[  --with-ssl-dir=PATH     Specify path to OpenSSL installation ],\n\t[\n\t\tif test \"x$openssl\" = \"xno\" ; then\n\t\t\tAC_MSG_ERROR([cannot use --with-ssl-dir when OpenSSL disabled])\n\t\tfi\n\t\tif test \"x$withval\" != \"xno\" ; then\n\t\t\tcase \"$withval\" in\n\t\t\t\t# Relative paths\n\t\t\t\t./*|../*)\twithval=\"`pwd`/$withval\"\n\t\t\tesac\n\t\t\tif test -d \"$withval/lib\"; then\n\t\t\t\tif test -n \"${rpath_opt}\"; then\n\t\t\t\t\tLDFLAGS=\"-L${withval}/lib ${rpath_opt}${withval}/lib ${LDFLAGS}\"\n\t\t\t\telse\n\t\t\t\t\tLDFLAGS=\"-L${withval}/lib ${LDFLAGS}\"\n\t\t\t\tfi\n\t\t\telif test -d \"$withval/lib64\"; then\n\t\t\t\tif test -n \"${rpath_opt}\"; then\n\t\t\t\t\tLDFLAGS=\"-L${withval}/lib64 ${rpath_opt}${withval}/lib64 ${LDFLAGS}\"\n\t\t\t\telse\n\t\t\t\t\tLDFLAGS=\"-L${withval}/lib64 ${LDFLAGS}\"\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\tif test -n \"${rpath_opt}\"; then\n\t\t\t\t\tLDFLAGS=\"-L${withval} ${rpath_opt}${withval} ${LDFLAGS}\"\n\t\t\t\telse\n\t\t\t\t\tLDFLAGS=\"-L${withval} ${LDFLAGS}\"\n\t\t\t\tfi\n\t\t\tfi\n\t\t\tif test -d \"$withval/include\"; then\n\t\t\t\tCPPFLAGS=\"-I${withval}/include ${CPPFLAGS}\"\n\t\t\telse\n\t\t\t\tCPPFLAGS=\"-I${withval} ${CPPFLAGS}\"\n\t\t\tfi\n\t\tfi\n\t]\n)\n\nAC_ARG_WITH([openssl-header-check],\n\t[  --without-openssl-header-check Disable OpenSSL version consistency check],\n\t[\n\t\tif test \"x$withval\" = \"xno\" ; then\n\t\t\topenssl_check_nonfatal=1\n\t\tfi\n\t]\n)\n\nopenssl_engine=no\nAC_ARG_WITH([ssl-engine],\n\t[  --with-ssl-engine       Enable OpenSSL (hardware) ENGINE support ],\n\t[\n\t\tif test \"x$withval\" != \"xno\" ; then\n\t\t\tif test \"x$openssl\" = \"xno\" ; then\n\t\t\t\tAC_MSG_ERROR([cannot use --with-ssl-engine when OpenSSL disabled])\n\t\t\tfi\n\t\t\topenssl_engine=yes\n\t\tfi\n\t]\n)\n\nif test \"x$openssl\" = \"xyes\" ; then\n\tLIBS=\"-lcrypto $LIBS\"\n\tAC_TRY_LINK_FUNC([RAND_add], ,\n\t    [AC_MSG_ERROR([*** working libcrypto not found, check config.log])])\n\tAC_CHECK_HEADER([openssl/opensslv.h], ,\n\t    [AC_MSG_ERROR([*** OpenSSL headers missing - please install first or check config.log ***])])\n\n\t# Determine OpenSSL header version\n\tAC_MSG_CHECKING([OpenSSL header version])\n\tAC_RUN_IFELSE(\n\t\t[AC_LANG_PROGRAM([[\n\t#include <stdlib.h>\n\t#include <stdio.h>\n\t#include <string.h>\n\t#include <openssl/opensslv.h>\n\t#define DATA \"conftest.sslincver\"\n\t\t]], [[\n\t\tFILE *fd;\n\t\tint rc;\n\n\t\tfd = fopen(DATA,\"w\");\n\t\tif(fd == NULL)\n\t\t\texit(1);\n\n\t\tif ((rc = fprintf(fd, \"%08lx (%s)\\n\",\n\t\t    (unsigned long)OPENSSL_VERSION_NUMBER,\n\t\t     OPENSSL_VERSION_TEXT)) < 0)\n\t\t\texit(1);\n\n\t\texit(0);\n\t\t]])],\n\t\t[\n\t\t\tssl_header_ver=`cat conftest.sslincver`\n\t\t\tAC_MSG_RESULT([$ssl_header_ver])\n\t\t],\n\t\t[\n\t\t\tAC_MSG_RESULT([not found])\n\t\t\tAC_MSG_ERROR([OpenSSL version header not found.])\n\t\t],\n\t\t[\n\t\t\tAC_MSG_WARN([cross compiling: not checking])\n\t\t]\n\t)\n\n\t# Determining OpenSSL library version is version dependent.\n\tAC_CHECK_FUNCS([OpenSSL_version OpenSSL_version_num])\n\n\t# Determine OpenSSL library version\n\tAC_MSG_CHECKING([OpenSSL library version])\n\tAC_RUN_IFELSE(\n\t\t[AC_LANG_PROGRAM([[\n\t#include <stdio.h>\n\t#include <stdlib.h>\n\t#include <string.h>\n\t#include <openssl/opensslv.h>\n\t#include <openssl/crypto.h>\n\t#define DATA \"conftest.ssllibver\"\n\t\t]], [[\n\t\tFILE *fd;\n\t\tint rc;\n\n\t\tfd = fopen(DATA,\"w\");\n\t\tif(fd == NULL)\n\t\t\texit(1);\n#ifndef OPENSSL_VERSION\n# define OPENSSL_VERSION SSLEAY_VERSION\n#endif\n#ifndef HAVE_OPENSSL_VERSION\n# define OpenSSL_version\tSSLeay_version\n#endif\n#ifndef HAVE_OPENSSL_VERSION_NUM\n# define OpenSSL_version_num\tSSLeay\n#endif\n\t\tif ((rc = fprintf(fd, \"%08lx (%s)\\n\",\n\t\t    (unsigned long)OpenSSL_version_num(),\n\t\t    OpenSSL_version(OPENSSL_VERSION))) < 0)\n\t\t\texit(1);\n\n\t\texit(0);\n\t\t]])],\n\t\t[\n\t\t\tssl_library_ver=`cat conftest.ssllibver`\n\t\t\t# Check version is supported.\n\t\t\tcase \"$ssl_library_ver\" in\n\t\t\t10000*|0*)\n\t\t\t\tAC_MSG_ERROR([OpenSSL >= 1.0.1 required (have \"$ssl_library_ver\")])\n\t\t                ;;\n\t\t\t100*)   ;; # 1.0.x\n\t\t\t101000[[0123456]]*)\n\t\t\t\t# https://github.com/openssl/openssl/pull/4613\n\t\t\t\tAC_MSG_ERROR([OpenSSL 1.1.x versions prior to 1.1.0g have a bug that breaks their use with OpenSSH (have \"$ssl_library_ver\")])\n\t\t\t\t;;\n\t\t\t101*)   ;; # 1.1.x\n\t\t\t200*)   ;; # LibreSSL\n\t\t\t300*)   ;; # OpenSSL development branch.\n\t\t        *)\n\t\t\t\tAC_MSG_ERROR([Unknown/unsupported OpenSSL version (\"$ssl_library_ver\")])\n\t\t                ;;\n\t\t\tesac\n\t\t\tAC_MSG_RESULT([$ssl_library_ver])\n\t\t],\n\t\t[\n\t\t\tAC_MSG_RESULT([not found])\n\t\t\tAC_MSG_ERROR([OpenSSL library not found.])\n\t\t],\n\t\t[\n\t\t\tAC_MSG_WARN([cross compiling: not checking])\n\t\t]\n\t)\n\n\t# Sanity check OpenSSL headers\n\tAC_MSG_CHECKING([whether OpenSSL's headers match the library])\n\tAC_RUN_IFELSE(\n\t\t[AC_LANG_PROGRAM([[\n\t#include <stdlib.h>\n\t#include <string.h>\n\t#include <openssl/opensslv.h>\n\t#include <openssl/crypto.h>\n\t\t]], [[\n#ifndef HAVE_OPENSSL_VERSION_NUM\n# define OpenSSL_version_num\tSSLeay\n#endif\n\t\texit(OpenSSL_version_num() == OPENSSL_VERSION_NUMBER ? 0 : 1);\n\t\t]])],\n\t\t[\n\t\t\tAC_MSG_RESULT([yes])\n\t\t],\n\t\t[\n\t\t\tAC_MSG_RESULT([no])\n\t\t\tif test \"x$openssl_check_nonfatal\" = \"x\"; then\n\t\t\t\tAC_MSG_ERROR([Your OpenSSL headers do not match your\n\tlibrary. Check config.log for details.\n\tIf you are sure your installation is consistent, you can disable the check\n\tby running \"./configure --without-openssl-header-check\".\n\tAlso see contrib/findssl.sh for help identifying header/library mismatches.\n\t])\n\t\t\telse\n\t\t\t\tAC_MSG_WARN([Your OpenSSL headers do not match your\n\tlibrary. Check config.log for details.\n\tAlso see contrib/findssl.sh for help identifying header/library mismatches.])\n\t\t\tfi\n\t\t],\n\t\t[\n\t\t\tAC_MSG_WARN([cross compiling: not checking])\n\t\t]\n\t)\n\n\tAC_MSG_CHECKING([if programs using OpenSSL functions will link])\n\tAC_LINK_IFELSE(\n\t\t[AC_LANG_PROGRAM([[ #include <openssl/err.h> ]],\n\t\t[[ ERR_load_crypto_strings(); ]])],\n\t\t[\n\t\t\tAC_MSG_RESULT([yes])\n\t\t],\n\t\t[\n\t\t\tAC_MSG_RESULT([no])\n\t\t\tsaved_LIBS=\"$LIBS\"\n\t\t\tLIBS=\"$LIBS -ldl\"\n\t\t\tAC_MSG_CHECKING([if programs using OpenSSL need -ldl])\n\t\t\tAC_LINK_IFELSE(\n\t\t\t\t[AC_LANG_PROGRAM([[ #include <openssl/err.h> ]],\n\t\t\t\t[[ ERR_load_crypto_strings(); ]])],\n\t\t\t\t[\n\t\t\t\t\tAC_MSG_RESULT([yes])\n\t\t\t\t],\n\t\t\t\t[\n\t\t\t\t\tAC_MSG_RESULT([no])\n\t\t\t\t\tLIBS=\"$saved_LIBS\"\n\t\t\t\t]\n\t\t\t)\n\t\t]\n\t)\n\n\tAC_CHECK_FUNCS([ \\\n\t\tBN_is_prime_ex \\\n\t\tDSA_generate_parameters_ex \\\n\t\tEVP_CIPHER_CTX_ctrl \\\n\t\tEVP_DigestFinal_ex \\\n\t\tEVP_DigestInit_ex \\\n\t\tEVP_MD_CTX_cleanup \\\n\t\tEVP_MD_CTX_copy_ex \\\n\t\tEVP_MD_CTX_init \\\n\t\tHMAC_CTX_init \\\n\t\tRSA_generate_key_ex \\\n\t\tRSA_get_default_method \\\n\t])\n\n\t# OpenSSL_add_all_algorithms may be a macro.\n\tAC_CHECK_FUNC(OpenSSL_add_all_algorithms,\n\t    AC_DEFINE(HAVE_OPENSSL_ADD_ALL_ALGORITHMS, 1, [as a function]),\n\t    AC_CHECK_DECL(OpenSSL_add_all_algorithms,\n\t\tAC_DEFINE(HAVE_OPENSSL_ADD_ALL_ALGORITHMS, 1, [as a macro]), ,\n\t\t[[#include <openssl/evp.h>]]\n\t    )\n\t)\n\n\t# LibreSSL/OpenSSL 1.1x API\n\tAC_CHECK_FUNCS([ \\\n\t\tOPENSSL_init_crypto \\\n\t\tDH_get0_key \\\n\t\tDH_get0_pqg \\\n\t\tDH_set0_key \\\n\t\tDH_set_length \\\n\t\tDH_set0_pqg \\\n\t\tDSA_get0_key \\\n\t\tDSA_get0_pqg \\\n\t\tDSA_set0_key \\\n\t\tDSA_set0_pqg \\\n\t\tDSA_SIG_get0 \\\n\t\tDSA_SIG_set0 \\\n\t\tECDSA_SIG_get0 \\\n\t\tECDSA_SIG_set0 \\\n\t\tEVP_CIPHER_CTX_iv \\\n\t\tEVP_CIPHER_CTX_iv_noconst \\\n\t\tEVP_CIPHER_CTX_get_iv \\\n\t\tEVP_CIPHER_CTX_set_iv \\\n\t\tRSA_get0_crt_params \\\n\t\tRSA_get0_factors \\\n\t\tRSA_get0_key \\\n\t\tRSA_set0_crt_params \\\n\t\tRSA_set0_factors \\\n\t\tRSA_set0_key \\\n\t\tRSA_meth_free \\\n\t\tRSA_meth_dup \\\n\t\tRSA_meth_set1_name \\\n\t\tRSA_meth_get_finish \\\n\t\tRSA_meth_set_priv_enc \\\n\t\tRSA_meth_set_priv_dec \\\n\t\tRSA_meth_set_finish \\\n\t\tEVP_PKEY_get0_RSA \\\n\t\tEVP_MD_CTX_new \\\n\t\tEVP_MD_CTX_free \\\n\t\tEVP_chacha20 \\\n\t])\n\n\tif test \"x$openssl_engine\" = \"xyes\" ; then\n\t\tAC_MSG_CHECKING([for OpenSSL ENGINE support])\n\t\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n\t#include <openssl/engine.h>\n\t\t\t]], [[\n\t\t\t\tENGINE_load_builtin_engines();\n\t\t\t\tENGINE_register_all_complete();\n\t\t\t]])],\n\t\t\t[ AC_MSG_RESULT([yes])\n\t\t\t  AC_DEFINE([USE_OPENSSL_ENGINE], [1],\n\t\t\t     [Enable OpenSSL engine support])\n\t\t\t], [ AC_MSG_ERROR([OpenSSL ENGINE support not found])\n\t\t])\n\tfi\n\n\t# Check for OpenSSL without EVP_aes_{192,256}_cbc\n\tAC_MSG_CHECKING([whether OpenSSL has crippled AES support])\n\tAC_LINK_IFELSE(\n\t\t[AC_LANG_PROGRAM([[\n\t#include <stdlib.h>\n\t#include <string.h>\n\t#include <openssl/evp.h>\n\t\t]], [[\n\t\texit(EVP_aes_192_cbc() == NULL || EVP_aes_256_cbc() == NULL);\n\t\t]])],\n\t\t[\n\t\t\tAC_MSG_RESULT([no])\n\t\t],\n\t\t[\n\t\t\tAC_MSG_RESULT([yes])\n\t\t\tAC_DEFINE([OPENSSL_LOBOTOMISED_AES], [1],\n\t\t\t    [libcrypto is missing AES 192 and 256 bit functions])\n\t\t]\n\t)\n\n\t# Check for OpenSSL with EVP_aes_*ctr\n\tAC_MSG_CHECKING([whether OpenSSL has AES CTR via EVP])\n\tAC_LINK_IFELSE(\n\t\t[AC_LANG_PROGRAM([[\n\t#include <stdlib.h>\n\t#include <string.h>\n\t#include <openssl/evp.h>\n\t\t]], [[\n\t\texit(EVP_aes_128_ctr() == NULL ||\n\t\t    EVP_aes_192_cbc() == NULL ||\n\t\t    EVP_aes_256_cbc() == NULL);\n\t\t]])],\n\t\t[\n\t\t\tAC_MSG_RESULT([yes])\n\t\t\tAC_DEFINE([OPENSSL_HAVE_EVPCTR], [1],\n\t\t\t    [libcrypto has EVP AES CTR])\n\t\t],\n\t\t[\n\t\t\tAC_MSG_RESULT([no])\n\t\t]\n\t)\n\n\t# Check for OpenSSL with EVP_aes_*gcm\n\tAC_MSG_CHECKING([whether OpenSSL has AES GCM via EVP])\n\tAC_LINK_IFELSE(\n\t\t[AC_LANG_PROGRAM([[\n\t#include <stdlib.h>\n\t#include <string.h>\n\t#include <openssl/evp.h>\n\t\t]], [[\n\t\texit(EVP_aes_128_gcm() == NULL ||\n\t\t    EVP_aes_256_gcm() == NULL ||\n\t\t    EVP_CTRL_GCM_SET_IV_FIXED == 0 ||\n\t\t    EVP_CTRL_GCM_IV_GEN == 0 ||\n\t\t    EVP_CTRL_GCM_SET_TAG == 0 ||\n\t\t    EVP_CTRL_GCM_GET_TAG == 0 ||\n\t\t    EVP_CIPHER_CTX_ctrl(NULL, 0, 0, NULL) == 0);\n\t\t]])],\n\t\t[\n\t\t\tAC_MSG_RESULT([yes])\n\t\t\tAC_DEFINE([OPENSSL_HAVE_EVPGCM], [1],\n\t\t\t    [libcrypto has EVP AES GCM])\n\t\t],\n\t\t[\n\t\t\tAC_MSG_RESULT([no])\n\t\t\tunsupported_algorithms=\"$unsupported_cipers \\\n\t\t\t   aes128-gcm@openssh.com \\\n\t\t\t   aes256-gcm@openssh.com\"\n\t\t]\n\t)\n\n\tAC_MSG_CHECKING([if EVP_DigestUpdate returns an int])\n\tAC_LINK_IFELSE(\n\t\t[AC_LANG_PROGRAM([[\n\t#include <stdlib.h>\n\t#include <string.h>\n\t#include <openssl/evp.h>\n\t\t]], [[\n\t\tif(EVP_DigestUpdate(NULL, NULL,0))\n\t\t\texit(0);\n\t\t]])],\n\t\t[\n\t\t\tAC_MSG_RESULT([yes])\n\t\t],\n\t\t[\n\t\t\tAC_MSG_RESULT([no])\n\t\t\tAC_DEFINE([OPENSSL_EVP_DIGESTUPDATE_VOID], [1],\n\t\t\t    [Define if EVP_DigestUpdate returns void])\n\t\t]\n\t)\n\n\t# Some systems want crypt() from libcrypt, *not* the version in OpenSSL,\n\t# because the system crypt() is more featureful.\n\tif test \"x$check_for_libcrypt_before\" = \"x1\"; then\n\t\tAC_CHECK_LIB([crypt], [crypt])\n\tfi\n\n\t# Some Linux systems (Slackware) need crypt() from libcrypt, *not* the\n\t# version in OpenSSL.\n\tif test \"x$check_for_libcrypt_later\" = \"x1\"; then\n\t\tAC_CHECK_LIB([crypt], [crypt], [LIBS=\"$LIBS -lcrypt\"])\n\tfi\n\tAC_CHECK_FUNCS([crypt DES_crypt])\n\n\t# Check for SHA256, SHA384 and SHA512 support in OpenSSL\n\tAC_CHECK_FUNCS([EVP_sha256 EVP_sha384 EVP_sha512])\n\n\t# Check complete ECC support in OpenSSL\n\tAC_MSG_CHECKING([whether OpenSSL has NID_X9_62_prime256v1])\n\tAC_LINK_IFELSE(\n\t\t[AC_LANG_PROGRAM([[\n\t#include <openssl/ec.h>\n\t#include <openssl/ecdh.h>\n\t#include <openssl/ecdsa.h>\n\t#include <openssl/evp.h>\n\t#include <openssl/objects.h>\n\t#include <openssl/opensslv.h>\n\t\t]], [[\n\t\tEC_KEY *e = EC_KEY_new_by_curve_name(NID_X9_62_prime256v1);\n\t\tconst EVP_MD *m = EVP_sha256(); /* We need this too */\n\t\t]])],\n\t\t[ AC_MSG_RESULT([yes])\n\t\t  enable_nistp256=1 ],\n\t\t[ AC_MSG_RESULT([no]) ]\n\t)\n\n\tAC_MSG_CHECKING([whether OpenSSL has NID_secp384r1])\n\tAC_LINK_IFELSE(\n\t\t[AC_LANG_PROGRAM([[\n\t#include <openssl/ec.h>\n\t#include <openssl/ecdh.h>\n\t#include <openssl/ecdsa.h>\n\t#include <openssl/evp.h>\n\t#include <openssl/objects.h>\n\t#include <openssl/opensslv.h>\n\t\t]], [[\n\t\tEC_KEY *e = EC_KEY_new_by_curve_name(NID_secp384r1);\n\t\tconst EVP_MD *m = EVP_sha384(); /* We need this too */\n\t\t]])],\n\t\t[ AC_MSG_RESULT([yes])\n\t\t  enable_nistp384=1 ],\n\t\t[ AC_MSG_RESULT([no]) ]\n\t)\n\n\tAC_MSG_CHECKING([whether OpenSSL has NID_secp521r1])\n\tAC_LINK_IFELSE(\n\t\t[AC_LANG_PROGRAM([[\n\t#include <openssl/ec.h>\n\t#include <openssl/ecdh.h>\n\t#include <openssl/ecdsa.h>\n\t#include <openssl/evp.h>\n\t#include <openssl/objects.h>\n\t#include <openssl/opensslv.h>\n\t\t]], [[\n\t\tEC_KEY *e = EC_KEY_new_by_curve_name(NID_secp521r1);\n\t\tconst EVP_MD *m = EVP_sha512(); /* We need this too */\n\t\t]])],\n\t\t[ AC_MSG_RESULT([yes])\n\t\t  AC_MSG_CHECKING([if OpenSSL's NID_secp521r1 is functional])\n\t\t  AC_RUN_IFELSE(\n\t\t\t[AC_LANG_PROGRAM([[\n\t#include <stdlib.h>\n\t#include <openssl/ec.h>\n\t#include <openssl/ecdh.h>\n\t#include <openssl/ecdsa.h>\n\t#include <openssl/evp.h>\n\t#include <openssl/objects.h>\n\t#include <openssl/opensslv.h>\n\t\t\t]],[[\n\t\t\tEC_KEY *e = EC_KEY_new_by_curve_name(NID_secp521r1);\n\t\t\tconst EVP_MD *m = EVP_sha512(); /* We need this too */\n\t\t\texit(e == NULL || m == NULL);\n\t\t\t]])],\n\t\t\t[ AC_MSG_RESULT([yes])\n\t\t\t  enable_nistp521=1 ],\n\t\t\t[ AC_MSG_RESULT([no]) ],\n\t\t\t[ AC_MSG_WARN([cross-compiling: assuming yes])\n\t\t\t  enable_nistp521=1 ]\n\t\t  )],\n\t\tAC_MSG_RESULT([no])\n\t)\n\n\tCOMMENT_OUT_ECC=\"#no ecc#\"\n\tTEST_SSH_ECC=no\n\n\tif test x$enable_nistp256 = x1 || test x$enable_nistp384 = x1 || \\\n\t    test x$enable_nistp521 = x1; then\n\t\tAC_DEFINE(OPENSSL_HAS_ECC, [1], [OpenSSL has ECC])\n\t\tAC_CHECK_FUNCS([EC_KEY_METHOD_new])\n\t\topenssl_ecc=yes\n\telse\n\t\topenssl_ecc=no\n\tfi\n\tif test x$enable_nistp256 = x1; then\n\t\tAC_DEFINE([OPENSSL_HAS_NISTP256], [1],\n\t\t    [libcrypto has NID_X9_62_prime256v1])\n\t\tTEST_SSH_ECC=yes\n\t\tCOMMENT_OUT_ECC=\"\"\n\telse\n\t\tunsupported_algorithms=\"$unsupported_algorithms \\\n\t\t\tecdsa-sha2-nistp256 \\\n\t\t\tecdh-sha2-nistp256 \\\n\t\t\tecdsa-sha2-nistp256-cert-v01@openssh.com\"\n\tfi\n\tif test x$enable_nistp384 = x1; then\n\t\tAC_DEFINE([OPENSSL_HAS_NISTP384], [1], [libcrypto has NID_secp384r1])\n\t\tTEST_SSH_ECC=yes\n\t\tCOMMENT_OUT_ECC=\"\"\n\telse\n\t\tunsupported_algorithms=\"$unsupported_algorithms \\\n\t\t\tecdsa-sha2-nistp384 \\\n\t\t\tecdh-sha2-nistp384 \\\n\t\t\tecdsa-sha2-nistp384-cert-v01@openssh.com\"\n\tfi\n\tif test x$enable_nistp521 = x1; then\n\t\tAC_DEFINE([OPENSSL_HAS_NISTP521], [1], [libcrypto has NID_secp521r1])\n\t\tTEST_SSH_ECC=yes\n\t\tCOMMENT_OUT_ECC=\"\"\n\telse\n\t\tunsupported_algorithms=\"$unsupported_algorithms \\\n\t\t\tecdh-sha2-nistp521 \\\n\t\t\tecdsa-sha2-nistp521 \\\n\t\t\tecdsa-sha2-nistp521-cert-v01@openssh.com\"\n\tfi\n\n\tAC_SUBST([TEST_SSH_ECC])\n\tAC_SUBST([COMMENT_OUT_ECC])\nelse\n\tAC_CHECK_LIB([crypt], [crypt], [LIBS=\"$LIBS -lcrypt\"])\n\tAC_CHECK_FUNCS([crypt])\nfi\n\n# PKCS11/U2F depend on OpenSSL and dlopen().\nenable_pkcs11=yes\nenable_sk=yes\nif test \"x$openssl\" != \"xyes\" ; then\n\tenable_pkcs11=\"disabled; missing libcrypto\"\n\tenable_sk=\"disabled; missing libcrypto\"\nfi\nif test \"x$openssl_ecc\" != \"xyes\" ; then\n\tenable_sk=\"disabled; OpenSSL has no ECC support\"\nfi\nif test \"x$ac_cv_func_dlopen\" != \"xyes\" ; then\n\tenable_pkcs11=\"disabled; missing dlopen(3)\"\n\tenable_sk=\"disabled; missing dlopen(3)\"\nfi\nif test \"x$ac_cv_have_decl_RTLD_NOW\" != \"xyes\" ; then\n\tenable_pkcs11=\"disabled; missing RTLD_NOW\"\n\tenable_sk=\"disabled; missing RTLD_NOW\"\nfi\nif test ! -z \"$disable_pkcs11\" ; then\n\tenable_pkcs11=\"disabled by user\"\nfi\nif test ! -z \"$disable_sk\" ; then\n\tenable_sk=\"disabled by user\"\nfi\n\nAC_MSG_CHECKING([whether to enable PKCS11])\nif test \"x$enable_pkcs11\" = \"xyes\" ; then\n\tAC_DEFINE([ENABLE_PKCS11], [], [Enable for PKCS#11 support])\nfi\nAC_MSG_RESULT([$enable_pkcs11])\n\nAC_MSG_CHECKING([whether to enable U2F])\nif test \"x$enable_sk\" = \"xyes\" ; then\n\tAC_DEFINE([ENABLE_SK], [], [Enable for U2F/FIDO support])\n\tAC_SUBST(SK_DUMMY_LIBRARY, [regress/misc/sk-dummy/sk-dummy.so])\nelse\n\t# Do not try to build sk-dummy library.\n\tAC_SUBST(SK_DUMMY_LIBRARY, [\"\"])\nfi\nAC_MSG_RESULT([$enable_sk])\n\n# Now check for built-in security key support.\nif test \"x$enable_sk\" = \"xyes\" -a \"x$enable_sk_internal\" = \"xyes\" ; then\n\tAC_PATH_TOOL([PKGCONFIG], [pkg-config], [no])\n\tuse_pkgconfig_for_libfido2=\n\tif test \"x$PKGCONFIG\" != \"xno\"; then\n\t\tAC_MSG_CHECKING([if $PKGCONFIG knows about libfido2])\n\t\tif \"$PKGCONFIG\" libfido2; then\n\t\t\tAC_MSG_RESULT([yes])\n\t\t\tuse_pkgconfig_for_libfido2=yes\n\t\telse\n\t\t\tAC_MSG_RESULT([no])\n\t\tfi\n\tfi\n\tif test \"x$use_pkgconfig_for_libfido2\" = \"xyes\"; then\n\t\tLIBFIDO2=`$PKGCONFIG --libs libfido2`\n\t\tCPPFLAGS=\"$CPPFLAGS `$PKGCONFIG --cflags libfido2`\"\n\telse\n\t\tLIBFIDO2=\"-lfido2 -lcbor\"\n\tfi\n\tOTHERLIBS=`echo $LIBFIDO2 | sed 's/-lfido2//'`\n\tAC_CHECK_LIB([fido2], [fido_init],\n\t\t[\n\t\t\tAC_SUBST([LIBFIDO2])\n\t\t\tAC_DEFINE([ENABLE_SK_INTERNAL], [],\n\t\t\t    [Enable for built-in U2F/FIDO support])\n\t\t\tenable_sk=\"built-in\"\n\t\t], [ AC_MSG_ERROR([no usable libfido2 found]) ],\n\t\t[ $OTHERLIBS ]\n\t)\n\tsaved_LIBS=\"$LIBS\"\n\tLIBS=\"$LIBS $LIBFIDO2\"\n\tAC_CHECK_FUNCS([ \\\n\t\tfido_cred_prot \\\n\t\tfido_cred_set_prot \\\n\t\tfido_dev_get_touch_begin \\\n\t\tfido_dev_get_touch_status \\\n\t\tfido_dev_supports_cred_prot \\\n\t])\n\tLIBS=\"$saved_LIBS\"\n\tAC_CHECK_HEADER([fido.h], [],\n\t\tAC_MSG_ERROR([missing fido.h from libfido2]))\n\tAC_CHECK_HEADER([fido/credman.h], [],\n\t\tAC_MSG_ERROR([missing fido/credman.h from libfido2]),\n\t\t[#include <fido.h>]\n\t)\nfi\n\nAC_CHECK_FUNCS([ \\\n\tarc4random \\\n\tarc4random_buf \\\n\tarc4random_stir \\\n\tarc4random_uniform \\\n])\n\nsaved_LIBS=\"$LIBS\"\nAC_CHECK_LIB([iaf], [ia_openinfo], [\n\tLIBS=\"$LIBS -liaf\"\n\tAC_CHECK_FUNCS([set_id], [SSHDLIBS=\"$SSHDLIBS -liaf\"\n\t\t\t\tAC_DEFINE([HAVE_LIBIAF], [1],\n\t\t\t[Define if system has libiaf that supports set_id])\n\t\t\t\t])\n])\nLIBS=\"$saved_LIBS\"\n\n### Configure cryptographic random number support\n\n# Check whether OpenSSL seeds itself\nif test \"x$openssl\" = \"xyes\" ; then\n\tAC_MSG_CHECKING([whether OpenSSL's PRNG is internally seeded])\n\tAC_RUN_IFELSE(\n\t\t[AC_LANG_PROGRAM([[\n\t#include <stdlib.h>\n\t#include <string.h>\n\t#include <openssl/rand.h>\n\t\t]], [[\n\t\texit(RAND_status() == 1 ? 0 : 1);\n\t\t]])],\n\t\t[\n\t\t\tOPENSSL_SEEDS_ITSELF=yes\n\t\t\tAC_MSG_RESULT([yes])\n\t\t],\n\t\t[\n\t\t\tAC_MSG_RESULT([no])\n\t\t],\n\t\t[\n\t\t\tAC_MSG_WARN([cross compiling: assuming yes])\n\t\t\t# This is safe, since we will fatal() at runtime if\n\t\t\t# OpenSSL is not seeded correctly.\n\t\t\tOPENSSL_SEEDS_ITSELF=yes\n\t\t]\n\t)\nfi\n\n# PRNGD TCP socket\nAC_ARG_WITH([prngd-port],\n\t[  --with-prngd-port=PORT  read entropy from PRNGD/EGD TCP localhost:PORT],\n\t[\n\t\tcase \"$withval\" in\n\t\tno)\n\t\t\twithval=\"\"\n\t\t\t;;\n\t\t[[0-9]]*)\n\t\t\t;;\n\t\t*)\n\t\t\tAC_MSG_ERROR([You must specify a numeric port number for --with-prngd-port])\n\t\t\t;;\n\t\tesac\n\t\tif test ! -z \"$withval\" ; then\n\t\t\tPRNGD_PORT=\"$withval\"\n\t\t\tAC_DEFINE_UNQUOTED([PRNGD_PORT], [$PRNGD_PORT],\n\t\t\t\t[Port number of PRNGD/EGD random number socket])\n\t\tfi\n\t]\n)\n\n# PRNGD Unix domain socket\nAC_ARG_WITH([prngd-socket],\n\t[  --with-prngd-socket=FILE read entropy from PRNGD/EGD socket FILE (default=/var/run/egd-pool)],\n\t[\n\t\tcase \"$withval\" in\n\t\tyes)\n\t\t\twithval=\"/var/run/egd-pool\"\n\t\t\t;;\n\t\tno)\n\t\t\twithval=\"\"\n\t\t\t;;\n\t\t/*)\n\t\t\t;;\n\t\t*)\n\t\t\tAC_MSG_ERROR([You must specify an absolute path to the entropy socket])\n\t\t\t;;\n\t\tesac\n\n\t\tif test ! -z \"$withval\" ; then\n\t\t\tif test ! -z \"$PRNGD_PORT\" ; then\n\t\t\t\tAC_MSG_ERROR([You may not specify both a PRNGD/EGD port and socket])\n\t\t\tfi\n\t\t\tif test ! -r \"$withval\" ; then\n\t\t\t\tAC_MSG_WARN([Entropy socket is not readable])\n\t\t\tfi\n\t\t\tPRNGD_SOCKET=\"$withval\"\n\t\t\tAC_DEFINE_UNQUOTED([PRNGD_SOCKET], [\"$PRNGD_SOCKET\"],\n\t\t\t\t[Location of PRNGD/EGD random number socket])\n\t\tfi\n\t],\n\t[\n\t\t# Check for existing socket only if we don't have a random device already\n\t\tif test \"x$OPENSSL_SEEDS_ITSELF\" != \"xyes\" ; then\n\t\t\tAC_MSG_CHECKING([for PRNGD/EGD socket])\n\t\t\t# Insert other locations here\n\t\t\tfor sock in /var/run/egd-pool /dev/egd-pool /etc/entropy; do\n\t\t\t\tif test -r $sock && $TEST_MINUS_S_SH -c \"test -S $sock -o -p $sock\" ; then\n\t\t\t\t\tPRNGD_SOCKET=\"$sock\"\n\t\t\t\t\tAC_DEFINE_UNQUOTED([PRNGD_SOCKET], [\"$PRNGD_SOCKET\"])\n\t\t\t\t\tbreak;\n\t\t\t\tfi\n\t\t\tdone\n\t\t\tif test ! -z \"$PRNGD_SOCKET\" ; then\n\t\t\t\tAC_MSG_RESULT([$PRNGD_SOCKET])\n\t\t\telse\n\t\t\t\tAC_MSG_RESULT([not found])\n\t\t\tfi\n\t\tfi\n\t]\n)\n\n# Which randomness source do we use?\nif test ! -z \"$PRNGD_PORT\" ; then\n\tRAND_MSG=\"PRNGd port $PRNGD_PORT\"\nelif test ! -z \"$PRNGD_SOCKET\" ; then\n\tRAND_MSG=\"PRNGd socket $PRNGD_SOCKET\"\nelif test ! -z \"$OPENSSL_SEEDS_ITSELF\" ; then\n\tAC_DEFINE([OPENSSL_PRNG_ONLY], [1],\n\t\t[Define if you want the OpenSSL internally seeded PRNG only])\n\tRAND_MSG=\"OpenSSL internal ONLY\"\nelif test \"x$openssl\" = \"xno\" ; then\n\tAC_MSG_WARN([OpenSSH will use /dev/urandom as a source of random numbers. It will fail if this device is not supported or accessible])\nelse\n\tAC_MSG_ERROR([OpenSSH has no source of random numbers. Please configure OpenSSL with an entropy source or re-run configure using one of the --with-prngd-port or --with-prngd-socket options])\nfi\n\n# Check for PAM libs\nPAM_MSG=\"no\"\nAC_ARG_WITH([pam],\n\t[  --with-pam              Enable PAM support ],\n\t[\n\t\tif test \"x$withval\" != \"xno\" ; then\n\t\t\tif test \"x$ac_cv_header_security_pam_appl_h\" != \"xyes\" && \\\n\t\t\t   test \"x$ac_cv_header_pam_pam_appl_h\" != \"xyes\" ; then\n\t\t\t\tAC_MSG_ERROR([PAM headers not found])\n\t\t\tfi\n\n\t\t\tsaved_LIBS=\"$LIBS\"\n\t\t\tAC_CHECK_LIB([dl], [dlopen], , )\n\t\t\tAC_CHECK_LIB([pam], [pam_set_item], , [AC_MSG_ERROR([*** libpam missing])])\n\t\t\tAC_CHECK_FUNCS([pam_getenvlist])\n\t\t\tAC_CHECK_FUNCS([pam_putenv])\n\t\t\tLIBS=\"$saved_LIBS\"\n\n\t\t\tPAM_MSG=\"yes\"\n\n\t\t\tSSHDLIBS=\"$SSHDLIBS -lpam\"\n\t\t\tAC_DEFINE([USE_PAM], [1],\n\t\t\t\t[Define if you want to enable PAM support])\n\n\t\t\tif test $ac_cv_lib_dl_dlopen = yes; then\n\t\t\t\tcase \"$LIBS\" in\n\t\t\t\t*-ldl*)\n\t\t\t\t\t# libdl already in LIBS\n\t\t\t\t\t;;\n\t\t\t\t*)\n\t\t\t\t\tSSHDLIBS=\"$SSHDLIBS -ldl\"\n\t\t\t\t\t;;\n\t\t\t\tesac\n\t\t\tfi\n\t\tfi\n\t]\n)\n\nAC_ARG_WITH([pam-service],\n\t[  --with-pam-service=name Specify PAM service name ],\n\t[\n\t\tif test \"x$withval\" != \"xno\" && \\\n\t\t   test \"x$withval\" != \"xyes\" ; then\n\t\t\tAC_DEFINE_UNQUOTED([SSHD_PAM_SERVICE],\n\t\t\t\t[\"$withval\"], [sshd PAM service name])\n\t\tfi\n\t]\n)\n\n# Check for older PAM\nif test \"x$PAM_MSG\" = \"xyes\" ; then\n\t# Check PAM strerror arguments (old PAM)\n\tAC_MSG_CHECKING([whether pam_strerror takes only one argument])\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#include <stdlib.h>\n#if defined(HAVE_SECURITY_PAM_APPL_H)\n#include <security/pam_appl.h>\n#elif defined (HAVE_PAM_PAM_APPL_H)\n#include <pam/pam_appl.h>\n#endif\n\t\t]], [[\n(void)pam_strerror((pam_handle_t *)NULL, -1);\n\t\t]])], [AC_MSG_RESULT([no])], [\n\t\t\tAC_DEFINE([HAVE_OLD_PAM], [1],\n\t\t\t\t[Define if you have an old version of PAM\n\t\t\t\twhich takes only one argument to pam_strerror])\n\t\t\tAC_MSG_RESULT([yes])\n\t\t\tPAM_MSG=\"yes (old library)\"\n\n\t])\nfi\n\ncase \"$host\" in\n*-*-cygwin*)\n\tSSH_PRIVSEP_USER=CYGWIN_SSH_PRIVSEP_USER\n\t;;\n*)\n\tSSH_PRIVSEP_USER=sshd\n\t;;\nesac\nAC_ARG_WITH([privsep-user],\n\t[  --with-privsep-user=user Specify non-privileged user for privilege separation],\n\t[\n\t\tif test -n \"$withval\"  &&  test \"x$withval\" != \"xno\"  &&  \\\n\t\t    test \"x${withval}\" != \"xyes\"; then\n\t\t\tSSH_PRIVSEP_USER=$withval\n\t\tfi\n\t]\n)\nif test \"x$SSH_PRIVSEP_USER\" = \"xCYGWIN_SSH_PRIVSEP_USER\" ; then\n\tAC_DEFINE_UNQUOTED([SSH_PRIVSEP_USER], [CYGWIN_SSH_PRIVSEP_USER],\n\t\t[Cygwin function to fetch non-privileged user for privilege separation])\nelse\n\tAC_DEFINE_UNQUOTED([SSH_PRIVSEP_USER], [\"$SSH_PRIVSEP_USER\"],\n\t\t[non-privileged user for privilege separation])\nfi\nAC_SUBST([SSH_PRIVSEP_USER])\n\nif test \"x$have_linux_no_new_privs\" = \"x1\" ; then\nAC_CHECK_DECL([SECCOMP_MODE_FILTER], [have_seccomp_filter=1], , [\n\t#include <sys/types.h>\n\t#include <linux/seccomp.h>\n])\nfi\nif test \"x$have_seccomp_filter\" = \"x1\" ; then\nAC_MSG_CHECKING([kernel for seccomp_filter support])\nAC_LINK_IFELSE([AC_LANG_PROGRAM([[\n\t\t#include <errno.h>\n\t\t#include <elf.h>\n\t\t#include <linux/audit.h>\n\t\t#include <linux/seccomp.h>\n\t\t#include <stdlib.h>\n\t\t#include <sys/prctl.h>\n\t]],\n\t[[ int i = $seccomp_audit_arch;\n\t   errno = 0;\n\t   prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, NULL, 0, 0);\n\t   exit(errno == EFAULT ? 0 : 1); ]])],\n\t[ AC_MSG_RESULT([yes]) ], [\n\t\tAC_MSG_RESULT([no])\n\t\t# Disable seccomp filter as a target\n\t\thave_seccomp_filter=0\n\t]\n)\nfi\n\n# Decide which sandbox style to use\nsandbox_arg=\"\"\nAC_ARG_WITH([sandbox],\n\t[  --with-sandbox=style    Specify privilege separation sandbox (no, capsicum, darwin, rlimit, seccomp_filter, systrace, pledge)],\n\t[\n\t\tif test \"x$withval\" = \"xyes\" ; then\n\t\t\tsandbox_arg=\"\"\n\t\telse\n\t\t\tsandbox_arg=\"$withval\"\n\t\tfi\n\t]\n)\n\n# Some platforms (seems to be the ones that have a kernel poll(2)-type\n# function with which they implement select(2)) use an extra file descriptor\n# when calling select(2), which means we can't use the rlimit sandbox.\nAC_MSG_CHECKING([if select works with descriptor rlimit])\nAC_RUN_IFELSE(\n\t[AC_LANG_PROGRAM([[\n#include <sys/types.h>\n#ifdef HAVE_SYS_TIME_H\n# include <sys/time.h>\n#endif\n#include <sys/resource.h>\n#ifdef HAVE_SYS_SELECT_H\n# include <sys/select.h>\n#endif\n#include <errno.h>\n#include <fcntl.h>\n#include <stdlib.h>\n\t]],[[\n\tstruct rlimit rl_zero;\n\tint fd, r;\n\tfd_set fds;\n\tstruct timeval tv;\n\n\tfd = open(\"/dev/null\", O_RDONLY);\n\tFD_ZERO(&fds);\n\tFD_SET(fd, &fds);\n\trl_zero.rlim_cur = rl_zero.rlim_max = 0;\n\tsetrlimit(RLIMIT_FSIZE, &rl_zero);\n\tsetrlimit(RLIMIT_NOFILE, &rl_zero);\n\ttv.tv_sec = 1;\n\ttv.tv_usec = 0;\n\tr = select(fd+1, &fds, NULL, NULL, &tv);\n\texit (r == -1 ? 1 : 0);\n\t]])],\n\t[AC_MSG_RESULT([yes])\n\t select_works_with_rlimit=yes],\n\t[AC_MSG_RESULT([no])\n\t select_works_with_rlimit=no],\n\t[AC_MSG_WARN([cross compiling: assuming yes])\n\t select_works_with_rlimit=yes]\n)\n\nAC_MSG_CHECKING([if setrlimit(RLIMIT_NOFILE,{0,0}) works])\nAC_RUN_IFELSE(\n\t[AC_LANG_PROGRAM([[\n#include <sys/types.h>\n#ifdef HAVE_SYS_TIME_H\n# include <sys/time.h>\n#endif\n#include <sys/resource.h>\n#include <errno.h>\n#include <stdlib.h>\n\t]],[[\n\tstruct rlimit rl_zero;\n\tint r;\n\n\trl_zero.rlim_cur = rl_zero.rlim_max = 0;\n\tr = setrlimit(RLIMIT_NOFILE, &rl_zero);\n\texit (r == -1 ? 1 : 0);\n\t]])],\n\t[AC_MSG_RESULT([yes])\n\t rlimit_nofile_zero_works=yes],\n\t[AC_MSG_RESULT([no])\n\t rlimit_nofile_zero_works=no],\n\t[AC_MSG_WARN([cross compiling: assuming yes])\n\t rlimit_nofile_zero_works=yes]\n)\n\nAC_MSG_CHECKING([if setrlimit RLIMIT_FSIZE works])\nAC_RUN_IFELSE(\n\t[AC_LANG_PROGRAM([[\n#include <sys/types.h>\n#include <sys/resource.h>\n#include <stdlib.h>\n\t]],[[\n\t\tstruct rlimit rl_zero;\n\n\t\trl_zero.rlim_cur = rl_zero.rlim_max = 0;\n\t\texit(setrlimit(RLIMIT_FSIZE, &rl_zero) != 0);\n\t]])],\n\t[AC_MSG_RESULT([yes])],\n\t[AC_MSG_RESULT([no])\n\t AC_DEFINE(SANDBOX_SKIP_RLIMIT_FSIZE, 1,\n\t    [setrlimit RLIMIT_FSIZE works])],\n\t[AC_MSG_WARN([cross compiling: assuming yes])]\n)\n\nif test \"x$sandbox_arg\" = \"xpledge\" || \\\n   ( test -z \"$sandbox_arg\" && test \"x$ac_cv_func_pledge\" = \"xyes\" ) ; then\n\ttest \"x$ac_cv_func_pledge\" != \"xyes\" && \\\n\t\tAC_MSG_ERROR([pledge sandbox requires pledge(2) support])\n\tSANDBOX_STYLE=\"pledge\"\n\tAC_DEFINE([SANDBOX_PLEDGE], [1], [Sandbox using pledge(2)])\nelif test \"x$sandbox_arg\" = \"xsystrace\" || \\\n   ( test -z \"$sandbox_arg\" && test \"x$have_systr_policy_kill\" = \"x1\" ) ; then\n\ttest \"x$have_systr_policy_kill\" != \"x1\" && \\\n\t\tAC_MSG_ERROR([systrace sandbox requires systrace headers and SYSTR_POLICY_KILL support])\n\tSANDBOX_STYLE=\"systrace\"\n\tAC_DEFINE([SANDBOX_SYSTRACE], [1], [Sandbox using systrace(4)])\nelif test \"x$sandbox_arg\" = \"xdarwin\" || \\\n     ( test -z \"$sandbox_arg\" && test \"x$ac_cv_func_sandbox_init\" = \"xyes\" && \\\n       test \"x$ac_cv_header_sandbox_h\" = \"xyes\") ; then\n\ttest \"x$ac_cv_func_sandbox_init\" != \"xyes\" -o \\\n\t     \"x$ac_cv_header_sandbox_h\" != \"xyes\" && \\\n\t\tAC_MSG_ERROR([Darwin seatbelt sandbox requires sandbox.h and sandbox_init function])\n\tSANDBOX_STYLE=\"darwin\"\n\tAC_DEFINE([SANDBOX_DARWIN], [1], [Sandbox using Darwin sandbox_init(3)])\nelif test \"x$sandbox_arg\" = \"xseccomp_filter\" || \\\n     ( test -z \"$sandbox_arg\" && \\\n       test \"x$have_seccomp_filter\" = \"x1\" && \\\n       test \"x$ac_cv_header_elf_h\" = \"xyes\" && \\\n       test \"x$ac_cv_header_linux_audit_h\" = \"xyes\" && \\\n       test \"x$ac_cv_header_linux_filter_h\" = \"xyes\" && \\\n       test \"x$seccomp_audit_arch\" != \"x\" && \\\n       test \"x$have_linux_no_new_privs\" = \"x1\" && \\\n       test \"x$ac_cv_func_prctl\" = \"xyes\" ) ; then\n\ttest \"x$seccomp_audit_arch\" = \"x\" && \\\n\t\tAC_MSG_ERROR([seccomp_filter sandbox not supported on $host])\n\ttest \"x$have_linux_no_new_privs\" != \"x1\" && \\\n\t\tAC_MSG_ERROR([seccomp_filter sandbox requires PR_SET_NO_NEW_PRIVS])\n\ttest \"x$have_seccomp_filter\" != \"x1\" && \\\n\t\tAC_MSG_ERROR([seccomp_filter sandbox requires seccomp headers])\n\ttest \"x$ac_cv_func_prctl\" != \"xyes\" && \\\n\t\tAC_MSG_ERROR([seccomp_filter sandbox requires prctl function])\n\tSANDBOX_STYLE=\"seccomp_filter\"\n\tAC_DEFINE([SANDBOX_SECCOMP_FILTER], [1], [Sandbox using seccomp filter])\nelif test \"x$sandbox_arg\" = \"xcapsicum\" || \\\n     ( test -z \"$sandbox_arg\" && \\\n       test \"x$ac_cv_header_sys_capsicum_h\" = \"xyes\" && \\\n       test \"x$ac_cv_func_cap_rights_limit\" = \"xyes\") ; then\n       test \"x$ac_cv_header_sys_capsicum_h\" != \"xyes\" && \\\n\t\tAC_MSG_ERROR([capsicum sandbox requires sys/capsicum.h header])\n       test \"x$ac_cv_func_cap_rights_limit\" != \"xyes\" && \\\n\t\tAC_MSG_ERROR([capsicum sandbox requires cap_rights_limit function])\n       SANDBOX_STYLE=\"capsicum\"\n       AC_DEFINE([SANDBOX_CAPSICUM], [1], [Sandbox using capsicum])\nelif test \"x$sandbox_arg\" = \"xrlimit\" || \\\n     ( test -z \"$sandbox_arg\" && test \"x$ac_cv_func_setrlimit\" = \"xyes\" && \\\n       test \"x$select_works_with_rlimit\" = \"xyes\" && \\\n       test \"x$rlimit_nofile_zero_works\" = \"xyes\" ) ; then\n\ttest \"x$ac_cv_func_setrlimit\" != \"xyes\" && \\\n\t\tAC_MSG_ERROR([rlimit sandbox requires setrlimit function])\n\ttest \"x$select_works_with_rlimit\" != \"xyes\" && \\\n\t\tAC_MSG_ERROR([rlimit sandbox requires select to work with rlimit])\n\tSANDBOX_STYLE=\"rlimit\"\n\tAC_DEFINE([SANDBOX_RLIMIT], [1], [Sandbox using setrlimit(2)])\nelif test \"x$sandbox_arg\" = \"xsolaris\" || \\\n   ( test -z \"$sandbox_arg\" && test \"x$SOLARIS_PRIVS\" = \"xyes\" ) ; then\n\tSANDBOX_STYLE=\"solaris\"\n\tAC_DEFINE([SANDBOX_SOLARIS], [1], [Sandbox using Solaris/Illumos privileges])\nelif test -z \"$sandbox_arg\" || test \"x$sandbox_arg\" = \"xno\" || \\\n     test \"x$sandbox_arg\" = \"xnone\" || test \"x$sandbox_arg\" = \"xnull\" ; then\n\tSANDBOX_STYLE=\"none\"\n\tAC_DEFINE([SANDBOX_NULL], [1], [no privsep sandboxing])\nelse\n\tAC_MSG_ERROR([unsupported --with-sandbox])\nfi\n\n# Cheap hack to ensure NEWS-OS libraries are arranged right.\nif test ! -z \"$SONY\" ; then\n  LIBS=\"$LIBS -liberty\";\nfi\n\n# Check for  long long datatypes\nAC_CHECK_TYPES([long long, unsigned long long, long double])\n\n# Check datatype sizes\nAC_CHECK_SIZEOF([short int])\nAC_CHECK_SIZEOF([int])\nAC_CHECK_SIZEOF([long int])\nAC_CHECK_SIZEOF([long long int])\n\n# Sanity check long long for some platforms (AIX)\nif test \"x$ac_cv_sizeof_long_long_int\" = \"x4\" ; then\n\tac_cv_sizeof_long_long_int=0\nfi\n\n# compute LLONG_MIN and LLONG_MAX if we don't know them.\nif test -z \"$have_llong_max\" && test -z \"$have_long_long_max\"; then\n\tAC_MSG_CHECKING([for max value of long long])\n\tAC_RUN_IFELSE(\n\t\t[AC_LANG_PROGRAM([[\n#include <stdio.h>\n#include <stdlib.h>\n/* Why is this so damn hard? */\n#ifdef __GNUC__\n# undef __GNUC__\n#endif\n#define __USE_ISOC99\n#include <limits.h>\n#define DATA \"conftest.llminmax\"\n#define my_abs(a) ((a) < 0 ? ((a) * -1) : (a))\n\n/*\n * printf in libc on some platforms (eg old Tru64) does not understand %lld so\n * we do this the hard way.\n */\nstatic int\nfprint_ll(FILE *f, long long n)\n{\n\tunsigned int i;\n\tint l[sizeof(long long) * 8];\n\n\tif (n < 0)\n\t\tif (fprintf(f, \"-\") < 0)\n\t\t\treturn -1;\n\tfor (i = 0; n != 0; i++) {\n\t\tl[i] = my_abs(n % 10);\n\t\tn /= 10;\n\t}\n\tdo {\n\t\tif (fprintf(f, \"%d\", l[--i]) < 0)\n\t\t\treturn -1;\n\t} while (i != 0);\n\tif (fprintf(f, \" \") < 0)\n\t\treturn -1;\n\treturn 0;\n}\n\t\t]], [[\n\tFILE *f;\n\tlong long i, llmin, llmax = 0;\n\n\tif((f = fopen(DATA,\"w\")) == NULL)\n\t\texit(1);\n\n#if defined(LLONG_MIN) && defined(LLONG_MAX)\n\tfprintf(stderr, \"Using system header for LLONG_MIN and LLONG_MAX\\n\");\n\tllmin = LLONG_MIN;\n\tllmax = LLONG_MAX;\n#else\n\tfprintf(stderr, \"Calculating  LLONG_MIN and LLONG_MAX\\n\");\n\t/* This will work on one's complement and two's complement */\n\tfor (i = 1; i > llmax; i <<= 1, i++)\n\t\tllmax = i;\n\tllmin = llmax + 1LL;\t/* wrap */\n#endif\n\n\t/* Sanity check */\n\tif (llmin + 1 < llmin || llmin - 1 < llmin || llmax + 1 > llmax\n\t    || llmax - 1 > llmax || llmin == llmax || llmin == 0\n\t    || llmax == 0 || llmax < LONG_MAX || llmin > LONG_MIN) {\n\t\tfprintf(f, \"unknown unknown\\n\");\n\t\texit(2);\n\t}\n\n\tif (fprint_ll(f, llmin) < 0)\n\t\texit(3);\n\tif (fprint_ll(f, llmax) < 0)\n\t\texit(4);\n\tif (fclose(f) < 0)\n\t\texit(5);\n\texit(0);\n\t\t]])],\n\t\t[\n\t\t\tllong_min=`$AWK '{print $1}' conftest.llminmax`\n\t\t\tllong_max=`$AWK '{print $2}' conftest.llminmax`\n\n\t\t\tAC_MSG_RESULT([$llong_max])\n\t\t\tAC_DEFINE_UNQUOTED([LLONG_MAX], [${llong_max}LL],\n\t\t\t    [max value of long long calculated by configure])\n\t\t\tAC_MSG_CHECKING([for min value of long long])\n\t\t\tAC_MSG_RESULT([$llong_min])\n\t\t\tAC_DEFINE_UNQUOTED([LLONG_MIN], [${llong_min}LL],\n\t\t\t    [min value of long long calculated by configure])\n\t\t],\n\t\t[\n\t\t\tAC_MSG_RESULT([not found])\n\t\t],\n\t\t[\n\t\t\tAC_MSG_WARN([cross compiling: not checking])\n\t\t]\n\t)\nfi\n\nAC_CHECK_DECLS([UINT32_MAX], , , [[\n#ifdef HAVE_SYS_LIMITS_H\n# include <sys/limits.h>\n#endif\n#ifdef HAVE_LIMITS_H\n# include <limits.h>\n#endif\n#ifdef HAVE_STDINT_H\n# include <stdint.h>\n#endif\n]])\n\n# More checks for data types\nAC_CACHE_CHECK([for u_int type], ac_cv_have_u_int, [\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[ #include <sys/types.h> ]],\n\t[[ u_int a; a = 1;]])],\n\t[ ac_cv_have_u_int=\"yes\" ], [ ac_cv_have_u_int=\"no\"\n\t])\n])\nif test \"x$ac_cv_have_u_int\" = \"xyes\" ; then\n\tAC_DEFINE([HAVE_U_INT], [1], [define if you have u_int data type])\n\thave_u_int=1\nfi\n\nAC_CACHE_CHECK([for intXX_t types], ac_cv_have_intxx_t, [\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[ #include <sys/types.h> ]],\n\t[[ int8_t a; int16_t b; int32_t c; a = b = c = 1;]])],\n\t[ ac_cv_have_intxx_t=\"yes\" ], [ ac_cv_have_intxx_t=\"no\"\n\t])\n])\nif test \"x$ac_cv_have_intxx_t\" = \"xyes\" ; then\n\tAC_DEFINE([HAVE_INTXX_T], [1], [define if you have intxx_t data type])\n\thave_intxx_t=1\nfi\n\nif (test -z \"$have_intxx_t\" && \\\n\t   test \"x$ac_cv_header_stdint_h\" = \"xyes\")\nthen\n    AC_MSG_CHECKING([for intXX_t types in stdint.h])\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[ #include <stdint.h> ]],\n\t[[ int8_t a; int16_t b; int32_t c; a = b = c = 1;]])],\n\t\t[\n\t\t\tAC_DEFINE([HAVE_INTXX_T])\n\t\t\tAC_MSG_RESULT([yes])\n\t\t], [ AC_MSG_RESULT([no])\n\t])\nfi\n\nAC_CACHE_CHECK([for int64_t type], ac_cv_have_int64_t, [\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#include <sys/types.h>\n#ifdef HAVE_STDINT_H\n# include <stdint.h>\n#endif\n#include <sys/socket.h>\n#ifdef HAVE_SYS_BITYPES_H\n# include <sys/bitypes.h>\n#endif\n\t\t]], [[\nint64_t a; a = 1;\n\t\t]])],\n\t[ ac_cv_have_int64_t=\"yes\" ], [ ac_cv_have_int64_t=\"no\"\n\t])\n])\nif test \"x$ac_cv_have_int64_t\" = \"xyes\" ; then\n\tAC_DEFINE([HAVE_INT64_T], [1], [define if you have int64_t data type])\nfi\n\nAC_CACHE_CHECK([for u_intXX_t types], ac_cv_have_u_intxx_t, [\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[ #include <sys/types.h> ]],\n\t[[ u_int8_t a; u_int16_t b; u_int32_t c; a = b = c = 1;]])],\n\t[ ac_cv_have_u_intxx_t=\"yes\" ], [ ac_cv_have_u_intxx_t=\"no\"\n\t])\n])\nif test \"x$ac_cv_have_u_intxx_t\" = \"xyes\" ; then\n\tAC_DEFINE([HAVE_U_INTXX_T], [1], [define if you have u_intxx_t data type])\n\thave_u_intxx_t=1\nfi\n\nif test -z \"$have_u_intxx_t\" ; then\n    AC_MSG_CHECKING([for u_intXX_t types in sys/socket.h])\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[ #include <sys/socket.h> ]],\n\t[[ u_int8_t a; u_int16_t b; u_int32_t c; a = b = c = 1;]])],\n\t\t[\n\t\t\tAC_DEFINE([HAVE_U_INTXX_T])\n\t\t\tAC_MSG_RESULT([yes])\n\t\t], [ AC_MSG_RESULT([no])\n\t])\nfi\n\nAC_CACHE_CHECK([for u_int64_t types], ac_cv_have_u_int64_t, [\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[ #include <sys/types.h> ]],\n\t[[ u_int64_t a; a = 1;]])],\n\t[ ac_cv_have_u_int64_t=\"yes\" ], [ ac_cv_have_u_int64_t=\"no\"\n\t])\n])\nif test \"x$ac_cv_have_u_int64_t\" = \"xyes\" ; then\n\tAC_DEFINE([HAVE_U_INT64_T], [1], [define if you have u_int64_t data type])\n\thave_u_int64_t=1\nfi\n\nif (test -z \"$have_u_int64_t\" && \\\n\t   test \"x$ac_cv_header_sys_bitypes_h\" = \"xyes\")\nthen\n    AC_MSG_CHECKING([for u_int64_t type in sys/bitypes.h])\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[ #include <sys/bitypes.h> ]],\n\t[[ u_int64_t a; a = 1]])],\n\t\t[\n\t\t\tAC_DEFINE([HAVE_U_INT64_T])\n\t\t\tAC_MSG_RESULT([yes])\n\t\t], [ AC_MSG_RESULT([no])\n\t])\nfi\n\nif test -z \"$have_u_intxx_t\" ; then\n\tAC_CACHE_CHECK([for uintXX_t types], ac_cv_have_uintxx_t, [\n\t\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#include <sys/types.h>\n\t\t\t]], [[\n\tuint8_t a;\n\tuint16_t b;\n\tuint32_t c;\n\ta = b = c = 1;\n\t\t\t]])],\n\t\t[ ac_cv_have_uintxx_t=\"yes\" ], [ ac_cv_have_uintxx_t=\"no\"\n\t\t])\n\t])\n\tif test \"x$ac_cv_have_uintxx_t\" = \"xyes\" ; then\n\t\tAC_DEFINE([HAVE_UINTXX_T], [1],\n\t\t\t[define if you have uintxx_t data type])\n\tfi\nfi\n\nif (test -z \"$have_uintxx_t\" && \\\n\t   test \"x$ac_cv_header_stdint_h\" = \"xyes\")\nthen\n    AC_MSG_CHECKING([for uintXX_t types in stdint.h])\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[ #include <stdint.h> ]],\n\t[[ uint8_t a; uint16_t b; uint32_t c; a = b = c = 1;]])],\n\t\t[\n\t\t\tAC_DEFINE([HAVE_UINTXX_T])\n\t\t\tAC_MSG_RESULT([yes])\n\t\t], [ AC_MSG_RESULT([no])\n\t])\nfi\n\nif (test -z \"$have_uintxx_t\" && \\\n\t   test \"x$ac_cv_header_inttypes_h\" = \"xyes\")\nthen\n    AC_MSG_CHECKING([for uintXX_t types in inttypes.h])\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[ #include <inttypes.h> ]],\n\t[[ uint8_t a; uint16_t b; uint32_t c; a = b = c = 1;]])],\n\t\t[\n\t\t\tAC_DEFINE([HAVE_UINTXX_T])\n\t\t\tAC_MSG_RESULT([yes])\n\t\t], [ AC_MSG_RESULT([no])\n\t])\nfi\n\nif (test -z \"$have_u_intxx_t\" || test -z \"$have_intxx_t\" && \\\n\t   test \"x$ac_cv_header_sys_bitypes_h\" = \"xyes\")\nthen\n\tAC_MSG_CHECKING([for intXX_t and u_intXX_t types in sys/bitypes.h])\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#include <sys/bitypes.h>\n\t\t]], [[\n\t\t\tint8_t a; int16_t b; int32_t c;\n\t\t\tu_int8_t e; u_int16_t f; u_int32_t g;\n\t\t\ta = b = c = e = f = g = 1;\n\t\t]])],\n\t\t[\n\t\t\tAC_DEFINE([HAVE_U_INTXX_T])\n\t\t\tAC_DEFINE([HAVE_INTXX_T])\n\t\t\tAC_MSG_RESULT([yes])\n\t\t], [AC_MSG_RESULT([no])\n\t])\nfi\n\n\nAC_CACHE_CHECK([for u_char], ac_cv_have_u_char, [\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[ #include <sys/types.h> ]],\n\t[[ u_char foo; foo = 125; ]])],\n\t[ ac_cv_have_u_char=\"yes\" ], [ ac_cv_have_u_char=\"no\"\n\t])\n])\nif test \"x$ac_cv_have_u_char\" = \"xyes\" ; then\n\tAC_DEFINE([HAVE_U_CHAR], [1], [define if you have u_char data type])\nfi\n\nAC_CHECK_TYPES([intmax_t, uintmax_t], , , [\n#include <sys/types.h>\n#ifdef HAVE_STDINT_H\n# include <stdint.h>\n#endif\n])\n\nTYPE_SOCKLEN_T\n\nAC_CHECK_TYPES([sig_atomic_t], , , [#include <signal.h>])\nAC_CHECK_TYPES([fsblkcnt_t, fsfilcnt_t], , , [\n#include <sys/types.h>\n#ifdef HAVE_SYS_BITYPES_H\n#include <sys/bitypes.h>\n#endif\n#ifdef HAVE_SYS_STATFS_H\n#include <sys/statfs.h>\n#endif\n#ifdef HAVE_SYS_STATVFS_H\n#include <sys/statvfs.h>\n#endif\n])\n\nAC_CHECK_MEMBERS([struct statfs.f_files, struct statfs.f_flags], [], [], [[\n#include <sys/param.h>\n#include <sys/types.h>\n#ifdef HAVE_SYS_BITYPES_H\n#include <sys/bitypes.h>\n#endif\n#ifdef HAVE_SYS_STATFS_H\n#include <sys/statfs.h>\n#endif\n#ifdef HAVE_SYS_STATVFS_H\n#include <sys/statvfs.h>\n#endif\n#ifdef HAVE_SYS_VFS_H\n#include <sys/vfs.h>\n#endif\n#ifdef HAVE_SYS_MOUNT_H\n#include <sys/mount.h>\n#endif\n]])\n\n\nAC_CHECK_TYPES([in_addr_t, in_port_t], , ,\n[#include <sys/types.h>\n#include <netinet/in.h>])\n\nAC_CACHE_CHECK([for size_t], ac_cv_have_size_t, [\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[ #include <sys/types.h> ]],\n\t[[ size_t foo; foo = 1235; ]])],\n\t[ ac_cv_have_size_t=\"yes\" ], [ ac_cv_have_size_t=\"no\"\n\t])\n])\nif test \"x$ac_cv_have_size_t\" = \"xyes\" ; then\n\tAC_DEFINE([HAVE_SIZE_T], [1], [define if you have size_t data type])\nfi\n\nAC_CACHE_CHECK([for ssize_t], ac_cv_have_ssize_t, [\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[ #include <sys/types.h> ]],\n\t[[ ssize_t foo; foo = 1235; ]])],\n\t[ ac_cv_have_ssize_t=\"yes\" ], [ ac_cv_have_ssize_t=\"no\"\n\t])\n])\nif test \"x$ac_cv_have_ssize_t\" = \"xyes\" ; then\n\tAC_DEFINE([HAVE_SSIZE_T], [1], [define if you have ssize_t data type])\nfi\n\nAC_CACHE_CHECK([for clock_t], ac_cv_have_clock_t, [\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[ #include <time.h> ]],\n\t[[ clock_t foo; foo = 1235; ]])],\n\t[ ac_cv_have_clock_t=\"yes\" ], [ ac_cv_have_clock_t=\"no\"\n\t])\n])\nif test \"x$ac_cv_have_clock_t\" = \"xyes\" ; then\n\tAC_DEFINE([HAVE_CLOCK_T], [1], [define if you have clock_t data type])\nfi\n\nAC_CACHE_CHECK([for sa_family_t], ac_cv_have_sa_family_t, [\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#include <sys/types.h>\n#include <sys/socket.h>\n\t\t]], [[ sa_family_t foo; foo = 1235; ]])],\n\t[ ac_cv_have_sa_family_t=\"yes\" ],\n\t[ AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n\t\t]], [[ sa_family_t foo; foo = 1235; ]])],\n\t\t[ ac_cv_have_sa_family_t=\"yes\" ],\n\t\t[ ac_cv_have_sa_family_t=\"no\" ]\n\t)\n\t])\n])\nif test \"x$ac_cv_have_sa_family_t\" = \"xyes\" ; then\n\tAC_DEFINE([HAVE_SA_FAMILY_T], [1],\n\t\t[define if you have sa_family_t data type])\nfi\n\nAC_CACHE_CHECK([for pid_t], ac_cv_have_pid_t, [\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[ #include <sys/types.h> ]],\n\t[[ pid_t foo; foo = 1235; ]])],\n\t[ ac_cv_have_pid_t=\"yes\" ], [ ac_cv_have_pid_t=\"no\"\n\t])\n])\nif test \"x$ac_cv_have_pid_t\" = \"xyes\" ; then\n\tAC_DEFINE([HAVE_PID_T], [1], [define if you have pid_t data type])\nfi\n\nAC_CACHE_CHECK([for mode_t], ac_cv_have_mode_t, [\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[ #include <sys/types.h> ]],\n\t[[ mode_t foo; foo = 1235; ]])],\n\t[ ac_cv_have_mode_t=\"yes\" ], [ ac_cv_have_mode_t=\"no\"\n\t])\n])\nif test \"x$ac_cv_have_mode_t\" = \"xyes\" ; then\n\tAC_DEFINE([HAVE_MODE_T], [1], [define if you have mode_t data type])\nfi\n\n\nAC_CACHE_CHECK([for struct sockaddr_storage], ac_cv_have_struct_sockaddr_storage, [\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#include <sys/types.h>\n#include <sys/socket.h>\n\t\t]], [[ struct sockaddr_storage s; ]])],\n\t[ ac_cv_have_struct_sockaddr_storage=\"yes\" ],\n\t[ ac_cv_have_struct_sockaddr_storage=\"no\"\n\t])\n])\nif test \"x$ac_cv_have_struct_sockaddr_storage\" = \"xyes\" ; then\n\tAC_DEFINE([HAVE_STRUCT_SOCKADDR_STORAGE], [1],\n\t\t[define if you have struct sockaddr_storage data type])\nfi\n\nAC_CACHE_CHECK([for struct sockaddr_in6], ac_cv_have_struct_sockaddr_in6, [\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#include <sys/types.h>\n#include <netinet/in.h>\n\t\t]], [[ struct sockaddr_in6 s; s.sin6_family = 0; ]])],\n\t[ ac_cv_have_struct_sockaddr_in6=\"yes\" ],\n\t[ ac_cv_have_struct_sockaddr_in6=\"no\"\n\t])\n])\nif test \"x$ac_cv_have_struct_sockaddr_in6\" = \"xyes\" ; then\n\tAC_DEFINE([HAVE_STRUCT_SOCKADDR_IN6], [1],\n\t\t[define if you have struct sockaddr_in6 data type])\nfi\n\nAC_CACHE_CHECK([for struct in6_addr], ac_cv_have_struct_in6_addr, [\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#include <sys/types.h>\n#include <netinet/in.h>\n\t\t]], [[ struct in6_addr s; s.s6_addr[0] = 0; ]])],\n\t[ ac_cv_have_struct_in6_addr=\"yes\" ],\n\t[ ac_cv_have_struct_in6_addr=\"no\"\n\t])\n])\nif test \"x$ac_cv_have_struct_in6_addr\" = \"xyes\" ; then\n\tAC_DEFINE([HAVE_STRUCT_IN6_ADDR], [1],\n\t\t[define if you have struct in6_addr data type])\n\ndnl Now check for sin6_scope_id\n\tAC_CHECK_MEMBERS([struct sockaddr_in6.sin6_scope_id], , ,\n\t\t[\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n#include <netinet/in.h>\n\t\t])\nfi\n\nAC_CACHE_CHECK([for struct addrinfo], ac_cv_have_struct_addrinfo, [\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netdb.h>\n\t\t]], [[ struct addrinfo s; s.ai_flags = AI_PASSIVE; ]])],\n\t[ ac_cv_have_struct_addrinfo=\"yes\" ],\n\t[ ac_cv_have_struct_addrinfo=\"no\"\n\t])\n])\nif test \"x$ac_cv_have_struct_addrinfo\" = \"xyes\" ; then\n\tAC_DEFINE([HAVE_STRUCT_ADDRINFO], [1],\n\t\t[define if you have struct addrinfo data type])\nfi\n\nAC_HEADER_TIME\n\nAC_CACHE_CHECK([for struct timeval], ac_cv_have_struct_timeval, [\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[ #include <sys/time.h> ]],\n\t[[ struct timeval tv; tv.tv_sec = 1;]])],\n\t[ ac_cv_have_struct_timeval=\"yes\" ],\n\t[ ac_cv_have_struct_timeval=\"no\"\n\t])\n])\nif test \"x$ac_cv_have_struct_timeval\" = \"xyes\" ; then\n\tAC_DEFINE([HAVE_STRUCT_TIMEVAL], [1], [define if you have struct timeval])\n\thave_struct_timeval=1\nfi\n\nAC_CACHE_CHECK([for struct timespec], ac_cv_have_struct_timespec, [\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n    #ifdef TIME_WITH_SYS_TIME\n    # include <sys/time.h>\n    # include <time.h>\n    #else\n    # ifdef HAVE_SYS_TIME_H\n    #  include <sys/time.h>\n    # else\n    #  include <time.h>\n    # endif\n    #endif\n\t]],\n\t[[ struct timespec ts; ts.tv_sec = 1;]])],\n\t[ ac_cv_have_struct_timespec=\"yes\" ],\n\t[ ac_cv_have_struct_timespec=\"no\"\n\t])\n])\nif test \"x$ac_cv_have_struct_timespec\" = \"xyes\" ; then\n\tAC_DEFINE([HAVE_STRUCT_TIMESPEC], [1], [define if you have struct timespec])\n\thave_struct_timespec=1\nfi\n\n# We need int64_t or else certain parts of the compile will fail.\nif test \"x$ac_cv_have_int64_t\" = \"xno\" && \\\n\ttest \"x$ac_cv_sizeof_long_int\" != \"x8\" && \\\n\ttest \"x$ac_cv_sizeof_long_long_int\" = \"x0\" ; then\n\techo \"OpenSSH requires int64_t support.  Contact your vendor or install\"\n\techo \"an alternative compiler (I.E., GCC) before continuing.\"\n\techo \"\"\n\texit 1;\nelse\ndnl test snprintf (broken on SCO w/gcc)\n\tAC_RUN_IFELSE(\n\t\t[AC_LANG_SOURCE([[\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef HAVE_SNPRINTF\nmain()\n{\n\tchar buf[50];\n\tchar expected_out[50];\n\tint mazsize = 50 ;\n#if (SIZEOF_LONG_INT == 8)\n\tlong int num = 0x7fffffffffffffff;\n#else\n\tlong long num = 0x7fffffffffffffffll;\n#endif\n\tstrcpy(expected_out, \"9223372036854775807\");\n\tsnprintf(buf, mazsize, \"%lld\", num);\n\tif(strcmp(buf, expected_out) != 0)\n\t\texit(1);\n\texit(0);\n}\n#else\nmain() { exit(0); }\n#endif\n\t\t]])], [ true ], [ AC_DEFINE([BROKEN_SNPRINTF]) ],\n\t\tAC_MSG_WARN([cross compiling: Assuming working snprintf()])\n\t)\nfi\n\ndnl Checks for structure members\nOSSH_CHECK_HEADER_FOR_FIELD([ut_host], [utmp.h], [HAVE_HOST_IN_UTMP])\nOSSH_CHECK_HEADER_FOR_FIELD([ut_host], [utmpx.h], [HAVE_HOST_IN_UTMPX])\nOSSH_CHECK_HEADER_FOR_FIELD([syslen], [utmpx.h], [HAVE_SYSLEN_IN_UTMPX])\nOSSH_CHECK_HEADER_FOR_FIELD([ut_pid], [utmp.h], [HAVE_PID_IN_UTMP])\nOSSH_CHECK_HEADER_FOR_FIELD([ut_type], [utmp.h], [HAVE_TYPE_IN_UTMP])\nOSSH_CHECK_HEADER_FOR_FIELD([ut_type], [utmpx.h], [HAVE_TYPE_IN_UTMPX])\nOSSH_CHECK_HEADER_FOR_FIELD([ut_tv], [utmp.h], [HAVE_TV_IN_UTMP])\nOSSH_CHECK_HEADER_FOR_FIELD([ut_id], [utmp.h], [HAVE_ID_IN_UTMP])\nOSSH_CHECK_HEADER_FOR_FIELD([ut_id], [utmpx.h], [HAVE_ID_IN_UTMPX])\nOSSH_CHECK_HEADER_FOR_FIELD([ut_addr], [utmp.h], [HAVE_ADDR_IN_UTMP])\nOSSH_CHECK_HEADER_FOR_FIELD([ut_addr], [utmpx.h], [HAVE_ADDR_IN_UTMPX])\nOSSH_CHECK_HEADER_FOR_FIELD([ut_addr_v6], [utmp.h], [HAVE_ADDR_V6_IN_UTMP])\nOSSH_CHECK_HEADER_FOR_FIELD([ut_addr_v6], [utmpx.h], [HAVE_ADDR_V6_IN_UTMPX])\nOSSH_CHECK_HEADER_FOR_FIELD([ut_exit], [utmp.h], [HAVE_EXIT_IN_UTMP])\nOSSH_CHECK_HEADER_FOR_FIELD([ut_time], [utmp.h], [HAVE_TIME_IN_UTMP])\nOSSH_CHECK_HEADER_FOR_FIELD([ut_time], [utmpx.h], [HAVE_TIME_IN_UTMPX])\nOSSH_CHECK_HEADER_FOR_FIELD([ut_tv], [utmpx.h], [HAVE_TV_IN_UTMPX])\nOSSH_CHECK_HEADER_FOR_FIELD([ut_ss], [utmpx.h], [HAVE_SS_IN_UTMPX])\n\nAC_CHECK_MEMBERS([struct stat.st_blksize])\nAC_CHECK_MEMBERS([struct stat.st_mtim])\nAC_CHECK_MEMBERS([struct stat.st_mtime])\nAC_CHECK_MEMBERS([struct passwd.pw_gecos, struct passwd.pw_class,\nstruct passwd.pw_change, struct passwd.pw_expire],\n[], [], [[\n#include <sys/types.h>\n#include <pwd.h>\n]])\n\nAC_CHECK_MEMBER([struct __res_state.retrans], [], [AC_DEFINE([__res_state], [state],\n\t[Define if we don't have struct __res_state in resolv.h])],\n[[\n#include <stdio.h>\n#if HAVE_SYS_TYPES_H\n# include <sys/types.h>\n#endif\n#include <netinet/in.h>\n#include <arpa/nameser.h>\n#include <resolv.h>\n]])\n\nAC_CACHE_CHECK([for ss_family field in struct sockaddr_storage],\n\t\tac_cv_have_ss_family_in_struct_ss, [\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#include <sys/types.h>\n#include <sys/socket.h>\n\t\t]], [[ struct sockaddr_storage s; s.ss_family = 1; ]])],\n\t[ ac_cv_have_ss_family_in_struct_ss=\"yes\" ],\n\t[ ac_cv_have_ss_family_in_struct_ss=\"no\" ])\n])\nif test \"x$ac_cv_have_ss_family_in_struct_ss\" = \"xyes\" ; then\n\tAC_DEFINE([HAVE_SS_FAMILY_IN_SS], [1], [Fields in struct sockaddr_storage])\nfi\n\nAC_CACHE_CHECK([for __ss_family field in struct sockaddr_storage],\n\t\tac_cv_have___ss_family_in_struct_ss, [\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#include <sys/types.h>\n#include <sys/socket.h>\n\t\t]], [[ struct sockaddr_storage s; s.__ss_family = 1; ]])],\n\t[ ac_cv_have___ss_family_in_struct_ss=\"yes\" ],\n\t[ ac_cv_have___ss_family_in_struct_ss=\"no\"\n\t])\n])\nif test \"x$ac_cv_have___ss_family_in_struct_ss\" = \"xyes\" ; then\n\tAC_DEFINE([HAVE___SS_FAMILY_IN_SS], [1],\n\t\t[Fields in struct sockaddr_storage])\nfi\n\ndnl make sure we're using the real structure members and not defines\nAC_CACHE_CHECK([for msg_accrights field in struct msghdr],\n\t\tac_cv_have_accrights_in_msghdr, [\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/uio.h>\n#include <stdlib.h>\n\t\t]], [[\n#ifdef msg_accrights\n#error \"msg_accrights is a macro\"\nexit(1);\n#endif\nstruct msghdr m;\nm.msg_accrights = 0;\nexit(0);\n\t\t]])],\n\t\t[ ac_cv_have_accrights_in_msghdr=\"yes\" ],\n\t\t[ ac_cv_have_accrights_in_msghdr=\"no\" ]\n\t)\n])\nif test \"x$ac_cv_have_accrights_in_msghdr\" = \"xyes\" ; then\n\tAC_DEFINE([HAVE_ACCRIGHTS_IN_MSGHDR], [1],\n\t\t[Define if your system uses access rights style\n\t\tfile descriptor passing])\nfi\n\nAC_MSG_CHECKING([if struct statvfs.f_fsid is integral type])\nAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#include <sys/param.h>\n#include <sys/stat.h>\n#ifdef HAVE_SYS_TIME_H\n# include <sys/time.h>\n#endif\n#ifdef HAVE_SYS_MOUNT_H\n#include <sys/mount.h>\n#endif\n#ifdef HAVE_SYS_STATVFS_H\n#include <sys/statvfs.h>\n#endif\n\t]], [[ struct statvfs s; s.f_fsid = 0; ]])],\n\t[ AC_MSG_RESULT([yes]) ],\n\t[ AC_MSG_RESULT([no])\n\n\tAC_MSG_CHECKING([if fsid_t has member val])\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#include <sys/types.h>\n#include <sys/statvfs.h>\n\t]], [[ fsid_t t; t.val[0] = 0; ]])],\n\t[ AC_MSG_RESULT([yes])\n\t  AC_DEFINE([FSID_HAS_VAL], [1], [fsid_t has member val]) ],\n\t[ AC_MSG_RESULT([no]) ])\n\n\tAC_MSG_CHECKING([if f_fsid has member __val])\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#include <sys/types.h>\n#include <sys/statvfs.h>\n\t]], [[ fsid_t t; t.__val[0] = 0; ]])],\n\t[ AC_MSG_RESULT([yes])\n\t  AC_DEFINE([FSID_HAS___VAL], [1], [fsid_t has member __val]) ],\n\t[ AC_MSG_RESULT([no]) ])\n])\n\nAC_CACHE_CHECK([for msg_control field in struct msghdr],\n\t\tac_cv_have_control_in_msghdr, [\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/uio.h>\n#include <stdlib.h>\n\t\t]], [[\n#ifdef msg_control\n#error \"msg_control is a macro\"\nexit(1);\n#endif\nstruct msghdr m;\nm.msg_control = 0;\nexit(0);\n\t\t]])],\n\t\t[ ac_cv_have_control_in_msghdr=\"yes\" ],\n\t\t[ ac_cv_have_control_in_msghdr=\"no\" ]\n\t)\n])\nif test \"x$ac_cv_have_control_in_msghdr\" = \"xyes\" ; then\n\tAC_DEFINE([HAVE_CONTROL_IN_MSGHDR], [1],\n\t\t[Define if your system uses ancillary data style\n\t\tfile descriptor passing])\nfi\n\nAC_CACHE_CHECK([if libc defines __progname], ac_cv_libc_defines___progname, [\n\tAC_LINK_IFELSE([AC_LANG_PROGRAM([[ #include <stdio.h> ]],\n\t\t[[ extern char *__progname; printf(\"%s\", __progname); ]])],\n\t[ ac_cv_libc_defines___progname=\"yes\" ],\n\t[ ac_cv_libc_defines___progname=\"no\"\n\t])\n])\nif test \"x$ac_cv_libc_defines___progname\" = \"xyes\" ; then\n\tAC_DEFINE([HAVE___PROGNAME], [1], [Define if libc defines __progname])\nfi\n\nAC_CACHE_CHECK([whether $CC implements __FUNCTION__], ac_cv_cc_implements___FUNCTION__, [\n\tAC_LINK_IFELSE([AC_LANG_PROGRAM([[ #include <stdio.h> ]],\n\t\t[[ printf(\"%s\", __FUNCTION__); ]])],\n\t[ ac_cv_cc_implements___FUNCTION__=\"yes\" ],\n\t[ ac_cv_cc_implements___FUNCTION__=\"no\"\n\t])\n])\nif test \"x$ac_cv_cc_implements___FUNCTION__\" = \"xyes\" ; then\n\tAC_DEFINE([HAVE___FUNCTION__], [1],\n\t\t[Define if compiler implements __FUNCTION__])\nfi\n\nAC_CACHE_CHECK([whether $CC implements __func__], ac_cv_cc_implements___func__, [\n\tAC_LINK_IFELSE([AC_LANG_PROGRAM([[ #include <stdio.h> ]],\n\t\t[[ printf(\"%s\", __func__); ]])],\n\t[ ac_cv_cc_implements___func__=\"yes\" ],\n\t[ ac_cv_cc_implements___func__=\"no\"\n\t])\n])\nif test \"x$ac_cv_cc_implements___func__\" = \"xyes\" ; then\n\tAC_DEFINE([HAVE___func__], [1], [Define if compiler implements __func__])\nfi\n\nAC_CACHE_CHECK([whether va_copy exists], ac_cv_have_va_copy, [\n\tAC_LINK_IFELSE([AC_LANG_PROGRAM([[\n#include <stdarg.h>\nva_list x,y;\n\t\t]], [[ va_copy(x,y); ]])],\n\t[ ac_cv_have_va_copy=\"yes\" ],\n\t[ ac_cv_have_va_copy=\"no\"\n\t])\n])\nif test \"x$ac_cv_have_va_copy\" = \"xyes\" ; then\n\tAC_DEFINE([HAVE_VA_COPY], [1], [Define if va_copy exists])\nfi\n\nAC_CACHE_CHECK([whether __va_copy exists], ac_cv_have___va_copy, [\n\tAC_LINK_IFELSE([AC_LANG_PROGRAM([[\n#include <stdarg.h>\nva_list x,y;\n\t\t]], [[ __va_copy(x,y); ]])],\n\t[ ac_cv_have___va_copy=\"yes\" ], [ ac_cv_have___va_copy=\"no\"\n\t])\n])\nif test \"x$ac_cv_have___va_copy\" = \"xyes\" ; then\n\tAC_DEFINE([HAVE___VA_COPY], [1], [Define if __va_copy exists])\nfi\n\nAC_CACHE_CHECK([whether getopt has optreset support],\n\t\tac_cv_have_getopt_optreset, [\n\tAC_LINK_IFELSE([AC_LANG_PROGRAM([[ #include <getopt.h> ]],\n\t\t[[ extern int optreset; optreset = 0; ]])],\n\t[ ac_cv_have_getopt_optreset=\"yes\" ],\n\t[ ac_cv_have_getopt_optreset=\"no\"\n\t])\n])\nif test \"x$ac_cv_have_getopt_optreset\" = \"xyes\" ; then\n\tAC_DEFINE([HAVE_GETOPT_OPTRESET], [1],\n\t\t[Define if your getopt(3) defines and uses optreset])\nfi\n\nAC_CACHE_CHECK([if libc defines sys_errlist], ac_cv_libc_defines_sys_errlist, [\n\tAC_LINK_IFELSE([AC_LANG_PROGRAM([[ #include <stdio.h> ]],\n[[ extern const char *const sys_errlist[]; printf(\"%s\", sys_errlist[0]);]])],\n\t[ ac_cv_libc_defines_sys_errlist=\"yes\" ],\n\t[ ac_cv_libc_defines_sys_errlist=\"no\"\n\t])\n])\nif test \"x$ac_cv_libc_defines_sys_errlist\" = \"xyes\" ; then\n\tAC_DEFINE([HAVE_SYS_ERRLIST], [1],\n\t\t[Define if your system defines sys_errlist[]])\nfi\n\n\nAC_CACHE_CHECK([if libc defines sys_nerr], ac_cv_libc_defines_sys_nerr, [\n\tAC_LINK_IFELSE([AC_LANG_PROGRAM([[ #include <stdio.h> ]],\n[[ extern int sys_nerr; printf(\"%i\", sys_nerr);]])],\n\t[ ac_cv_libc_defines_sys_nerr=\"yes\" ],\n\t[ ac_cv_libc_defines_sys_nerr=\"no\"\n\t])\n])\nif test \"x$ac_cv_libc_defines_sys_nerr\" = \"xyes\" ; then\n\tAC_DEFINE([HAVE_SYS_NERR], [1], [Define if your system defines sys_nerr])\nfi\n\n# Check libraries needed by DNS fingerprint support\nAC_SEARCH_LIBS([getrrsetbyname], [resolv],\n\t[AC_DEFINE([HAVE_GETRRSETBYNAME], [1],\n\t\t[Define if getrrsetbyname() exists])],\n\t[\n\t\t# Needed by our getrrsetbyname()\n\t\tAC_SEARCH_LIBS([res_query], [resolv])\n\t\tAC_SEARCH_LIBS([dn_expand], [resolv])\n\t\tAC_MSG_CHECKING([if res_query will link])\n\t\tAC_LINK_IFELSE([AC_LANG_PROGRAM([[\n#include <sys/types.h>\n#include <netinet/in.h>\n#include <arpa/nameser.h>\n#include <netdb.h>\n#include <resolv.h>\n\t\t\t\t]], [[\n\tres_query (0, 0, 0, 0, 0);\n\t\t\t\t]])],\n\t\t    AC_MSG_RESULT([yes]),\n\t\t   [AC_MSG_RESULT([no])\n\t\t    saved_LIBS=\"$LIBS\"\n\t\t    LIBS=\"$LIBS -lresolv\"\n\t\t    AC_MSG_CHECKING([for res_query in -lresolv])\n\t\t    AC_LINK_IFELSE([AC_LANG_PROGRAM([[\n#include <sys/types.h>\n#include <netinet/in.h>\n#include <arpa/nameser.h>\n#include <netdb.h>\n#include <resolv.h>\n\t\t\t\t]], [[\n\tres_query (0, 0, 0, 0, 0);\n\t\t\t\t]])],\n\t\t\t[AC_MSG_RESULT([yes])],\n\t\t\t[LIBS=\"$saved_LIBS\"\n\t\t\t AC_MSG_RESULT([no])])\n\t\t    ])\n\t\tAC_CHECK_FUNCS([_getshort _getlong])\n\t\tAC_CHECK_DECLS([_getshort, _getlong], , ,\n\t\t    [#include <sys/types.h>\n\t\t    #include <arpa/nameser.h>])\n\t\tAC_CHECK_MEMBER([HEADER.ad],\n\t\t\t[AC_DEFINE([HAVE_HEADER_AD], [1],\n\t\t\t    [Define if HEADER.ad exists in arpa/nameser.h])], ,\n\t\t\t[#include <arpa/nameser.h>])\n\t])\n\nAC_MSG_CHECKING([if struct __res_state _res is an extern])\nAC_LINK_IFELSE([AC_LANG_PROGRAM([[\n#include <stdio.h>\n#if HAVE_SYS_TYPES_H\n# include <sys/types.h>\n#endif\n#include <netinet/in.h>\n#include <arpa/nameser.h>\n#include <resolv.h>\nextern struct __res_state _res;\n\t\t]], [[\nstruct __res_state *volatile p = &_res;  /* force resolution of _res */\nreturn 0;\n\t\t]],)],\n\t\t[AC_MSG_RESULT([yes])\n\t\t AC_DEFINE([HAVE__RES_EXTERN], [1],\n\t\t    [Define if you have struct __res_state _res as an extern])\n\t\t],\n\t\t[ AC_MSG_RESULT([no]) ]\n)\n\n# Check whether user wants SELinux support\nSELINUX_MSG=\"no\"\nLIBSELINUX=\"\"\nAC_ARG_WITH([selinux],\n\t[  --with-selinux          Enable SELinux support],\n\t[ if test \"x$withval\" != \"xno\" ; then\n\t\tsave_LIBS=\"$LIBS\"\n\t\tAC_DEFINE([WITH_SELINUX], [1],\n\t\t\t[Define if you want SELinux support.])\n\t\tSELINUX_MSG=\"yes\"\n\t\tAC_CHECK_HEADER([selinux/selinux.h], ,\n\t\t\tAC_MSG_ERROR([SELinux support requires selinux.h header]))\n\t\tAC_CHECK_LIB([selinux], [setexeccon],\n\t\t\t[ LIBSELINUX=\"-lselinux\"\n\t\t\t  LIBS=\"$LIBS -lselinux\"\n\t\t\t],\n\t\t\tAC_MSG_ERROR([SELinux support requires libselinux library]))\n\t\tAC_CHECK_FUNCS([getseuserbyname get_default_context_with_level])\n\t\tLIBS=\"$save_LIBS $LIBSELINUX\"\n\tfi ]\n)\nAC_SUBST([SSHDLIBS])\n\n# Check whether user wants Kerberos 5 support\nKRB5_MSG=\"no\"\nAC_ARG_WITH([kerberos5],\n\t[  --with-kerberos5=PATH   Enable Kerberos 5 support],\n\t[ if test \"x$withval\" != \"xno\" ; then\n\t\tif test \"x$withval\" = \"xyes\" ; then\n\t\t\tKRB5ROOT=\"/usr/local\"\n\t\telse\n\t\t\tKRB5ROOT=${withval}\n\t\tfi\n\n\t\tAC_DEFINE([KRB5], [1], [Define if you want Kerberos 5 support])\n\t\tKRB5_MSG=\"yes\"\n\n\t\tAC_PATH_TOOL([KRB5CONF], [krb5-config],\n\t\t\t     [$KRB5ROOT/bin/krb5-config],\n\t\t\t     [$KRB5ROOT/bin:$PATH])\n\t\tif test -x $KRB5CONF ; then\n\t\t\tK5CFLAGS=\"`$KRB5CONF --cflags`\"\n\t\t\tK5LIBS=\"`$KRB5CONF --libs`\"\n\t\t\tCPPFLAGS=\"$CPPFLAGS $K5CFLAGS\"\n\n\t\t\tAC_MSG_CHECKING([for gssapi support])\n\t\t\tif $KRB5CONF | grep gssapi >/dev/null ; then\n\t\t\t\tAC_MSG_RESULT([yes])\n\t\t\t\tAC_DEFINE([GSSAPI], [1],\n\t\t\t\t\t[Define this if you want GSSAPI\n\t\t\t\t\tsupport in the version 2 protocol])\n\t\t\t\tGSSCFLAGS=\"`$KRB5CONF --cflags gssapi`\"\n\t\t\t\tGSSLIBS=\"`$KRB5CONF --libs gssapi`\"\n\t\t\t\tCPPFLAGS=\"$CPPFLAGS $GSSCFLAGS\"\n\t\t\telse\n\t\t\t\tAC_MSG_RESULT([no])\n\t\t\tfi\n\t\t\tAC_MSG_CHECKING([whether we are using Heimdal])\n\t\t\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[ #include <krb5.h>\n\t\t\t\t]], [[ char *tmp = heimdal_version; ]])],\n\t\t\t\t[ AC_MSG_RESULT([yes])\n\t\t\t\tAC_DEFINE([HEIMDAL], [1],\n\t\t\t\t[Define this if you are using the Heimdal\n\t\t\t\tversion of Kerberos V5]) ],\n\t\t\t\t[AC_MSG_RESULT([no])\n\t\t\t])\n\t\telse\n\t\t\tCPPFLAGS=\"$CPPFLAGS -I${KRB5ROOT}/include\"\n\t\t\tLDFLAGS=\"$LDFLAGS -L${KRB5ROOT}/lib\"\n\t\t\tAC_MSG_CHECKING([whether we are using Heimdal])\n\t\t\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[ #include <krb5.h>\n\t\t\t\t]], [[ char *tmp = heimdal_version; ]])],\n\t\t\t\t\t[ AC_MSG_RESULT([yes])\n\t\t\t\t\t AC_DEFINE([HEIMDAL])\n\t\t\t\t\t K5LIBS=\"-lkrb5\"\n\t\t\t\t\t K5LIBS=\"$K5LIBS -lcom_err -lasn1\"\n\t\t\t\t\t AC_CHECK_LIB([roken], [net_write],\n\t\t\t\t\t   [K5LIBS=\"$K5LIBS -lroken\"])\n\t\t\t\t\t AC_CHECK_LIB([des], [des_cbc_encrypt],\n\t\t\t\t\t   [K5LIBS=\"$K5LIBS -ldes\"])\n\t\t\t\t       ], [ AC_MSG_RESULT([no])\n\t\t\t\t\t K5LIBS=\"-lkrb5 -lk5crypto -lcom_err\"\n\t\t\t])\n\t\t\tAC_SEARCH_LIBS([dn_expand], [resolv])\n\n\t\t\tAC_CHECK_LIB([gssapi_krb5], [gss_init_sec_context],\n\t\t\t\t[ AC_DEFINE([GSSAPI])\n\t\t\t\t  GSSLIBS=\"-lgssapi_krb5\" ],\n\t\t\t\t[ AC_CHECK_LIB([gssapi], [gss_init_sec_context],\n\t\t\t\t\t[ AC_DEFINE([GSSAPI])\n\t\t\t\t\t  GSSLIBS=\"-lgssapi\" ],\n\t\t\t\t\t[ AC_CHECK_LIB([gss], [gss_init_sec_context],\n\t\t\t\t\t\t[ AC_DEFINE([GSSAPI])\n\t\t\t\t\t\t  GSSLIBS=\"-lgss\" ],\n\t\t\t\t\t\tAC_MSG_WARN([Cannot find any suitable gss-api library - build may fail]))\n\t\t\t\t\t])\n\t\t\t\t])\n\n\t\t\tAC_CHECK_HEADER([gssapi.h], ,\n\t\t\t\t[ unset ac_cv_header_gssapi_h\n\t\t\t\t  CPPFLAGS=\"$CPPFLAGS -I${KRB5ROOT}/include/gssapi\"\n\t\t\t\t  AC_CHECK_HEADERS([gssapi.h], ,\n\t\t\t\t\tAC_MSG_WARN([Cannot find any suitable gss-api header - build may fail])\n\t\t\t\t  )\n\t\t\t\t]\n\t\t\t)\n\n\t\t\toldCPP=\"$CPPFLAGS\"\n\t\t\tCPPFLAGS=\"$CPPFLAGS -I${KRB5ROOT}/include/gssapi\"\n\t\t\tAC_CHECK_HEADER([gssapi_krb5.h], ,\n\t\t\t\t\t[ CPPFLAGS=\"$oldCPP\" ])\n\n\t\tfi\n\t\tif test -n \"${rpath_opt}\" ; then\n\t\t\tLDFLAGS=\"$LDFLAGS ${rpath_opt}${KRB5ROOT}/lib\"\n\t\tfi\n\t\tif test ! -z \"$blibpath\" ; then\n\t\t\tblibpath=\"$blibpath:${KRB5ROOT}/lib\"\n\t\tfi\n\n\t\tAC_CHECK_HEADERS([gssapi.h gssapi/gssapi.h])\n\t\tAC_CHECK_HEADERS([gssapi_krb5.h gssapi/gssapi_krb5.h])\n\t\tAC_CHECK_HEADERS([gssapi_generic.h gssapi/gssapi_generic.h])\n\n\t\tAC_SEARCH_LIBS([k_hasafs], [kafs], [AC_DEFINE([USE_AFS], [1],\n\t\t\t[Define this if you want to use libkafs' AFS support])])\n\n\t\tAC_CHECK_DECLS([GSS_C_NT_HOSTBASED_SERVICE], [], [], [[\n#ifdef HAVE_GSSAPI_H\n# include <gssapi.h>\n#elif defined(HAVE_GSSAPI_GSSAPI_H)\n# include <gssapi/gssapi.h>\n#endif\n\n#ifdef HAVE_GSSAPI_GENERIC_H\n# include <gssapi_generic.h>\n#elif defined(HAVE_GSSAPI_GSSAPI_GENERIC_H)\n# include <gssapi/gssapi_generic.h>\n#endif\n\t\t]])\n\t\tsaved_LIBS=\"$LIBS\"\n\t\tLIBS=\"$LIBS $K5LIBS\"\n\t\tAC_CHECK_FUNCS([krb5_cc_new_unique krb5_get_error_message krb5_free_error_message])\n\t\tLIBS=\"$saved_LIBS\"\n\n\tfi\n\t]\n)\nAC_SUBST([GSSLIBS])\nAC_SUBST([K5LIBS])\n\n# Looking for programs, paths and files\n\nPRIVSEP_PATH=/var/empty\nAC_ARG_WITH([privsep-path],\n\t[  --with-privsep-path=xxx Path for privilege separation chroot (default=/var/empty)],\n\t[\n\t\tif test -n \"$withval\"  &&  test \"x$withval\" != \"xno\"  &&  \\\n\t\t    test \"x${withval}\" != \"xyes\"; then\n\t\t\tPRIVSEP_PATH=$withval\n\t\tfi\n\t]\n)\nAC_SUBST([PRIVSEP_PATH])\n\nAC_ARG_WITH([xauth],\n\t[  --with-xauth=PATH       Specify path to xauth program ],\n\t[\n\t\tif test -n \"$withval\"  &&  test \"x$withval\" != \"xno\"  &&  \\\n\t\t    test \"x${withval}\" != \"xyes\"; then\n\t\t\txauth_path=$withval\n\t\tfi\n\t],\n\t[\n\t\tTestPath=\"$PATH\"\n\t\tTestPath=\"${TestPath}${PATH_SEPARATOR}/usr/X/bin\"\n\t\tTestPath=\"${TestPath}${PATH_SEPARATOR}/usr/bin/X11\"\n\t\tTestPath=\"${TestPath}${PATH_SEPARATOR}/usr/X11R6/bin\"\n\t\tTestPath=\"${TestPath}${PATH_SEPARATOR}/usr/openwin/bin\"\n\t\tAC_PATH_PROG([xauth_path], [xauth], , [$TestPath])\n\t\tif (test ! -z \"$xauth_path\" && test -x \"/usr/openwin/bin/xauth\") ; then\n\t\t\txauth_path=\"/usr/openwin/bin/xauth\"\n\t\tfi\n\t]\n)\n\nSTRIP_OPT=-s\nAC_ARG_ENABLE([strip],\n\t[  --disable-strip         Disable calling strip(1) on install],\n\t[\n\t\tif test \"x$enableval\" = \"xno\" ; then\n\t\t\tSTRIP_OPT=\n\t\tfi\n\t]\n)\nAC_SUBST([STRIP_OPT])\n\nif test -z \"$xauth_path\" ; then\n\tXAUTH_PATH=\"undefined\"\n\tAC_SUBST([XAUTH_PATH])\nelse\n\tAC_DEFINE_UNQUOTED([XAUTH_PATH], [\"$xauth_path\"],\n\t\t[Define if xauth is found in your path])\n\tXAUTH_PATH=$xauth_path\n\tAC_SUBST([XAUTH_PATH])\nfi\n\ndnl # --with-maildir=/path/to/mail gets top priority.\ndnl # if maildir is set in the platform case statement above we use that.\ndnl # Otherwise we run a program to get the dir from system headers.\ndnl # We first look for _PATH_MAILDIR then MAILDIR then _PATH_MAIL\ndnl # If we find _PATH_MAILDIR we do nothing because that is what\ndnl # session.c expects anyway. Otherwise we set to the value found\ndnl # stripping any trailing slash. If for some strage reason our program\ndnl # does not find what it needs, we default to /var/spool/mail.\n# Check for mail directory\nAC_ARG_WITH([maildir],\n    [  --with-maildir=/path/to/mail    Specify your system mail directory],\n    [\n\tif test \"X$withval\" != X  &&  test \"x$withval\" != xno  &&  \\\n\t    test \"x${withval}\" != xyes; then\n\t\tAC_DEFINE_UNQUOTED([MAIL_DIRECTORY], [\"$withval\"],\n            [Set this to your mail directory if you do not have _PATH_MAILDIR])\n\t    fi\n     ],[\n\tif test \"X$maildir\" != \"X\"; then\n\t    AC_DEFINE_UNQUOTED([MAIL_DIRECTORY], [\"$maildir\"])\n\telse\n\t    AC_MSG_CHECKING([Discovering system mail directory])\n\t    AC_RUN_IFELSE(\n\t\t[AC_LANG_PROGRAM([[\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef HAVE_PATHS_H\n#include <paths.h>\n#endif\n#ifdef HAVE_MAILLOCK_H\n#include <maillock.h>\n#endif\n#define DATA \"conftest.maildir\"\n\t]], [[\n\tFILE *fd;\n\tint rc;\n\n\tfd = fopen(DATA,\"w\");\n\tif(fd == NULL)\n\t\texit(1);\n\n#if defined (_PATH_MAILDIR)\n\tif ((rc = fprintf(fd ,\"_PATH_MAILDIR:%s\\n\", _PATH_MAILDIR)) <0)\n\t\texit(1);\n#elif defined (MAILDIR)\n\tif ((rc = fprintf(fd ,\"MAILDIR:%s\\n\", MAILDIR)) <0)\n\t\texit(1);\n#elif defined (_PATH_MAIL)\n\tif ((rc = fprintf(fd ,\"_PATH_MAIL:%s\\n\", _PATH_MAIL)) <0)\n\t\texit(1);\n#else\n\texit (2);\n#endif\n\n\texit(0);\n\t\t]])],\n\t\t[\n\t\t    maildir_what=`awk -F: '{print $1}' conftest.maildir`\n\t\t    maildir=`awk -F: '{print $2}' conftest.maildir \\\n\t\t\t| sed 's|/$||'`\n\t\t    AC_MSG_RESULT([Using: $maildir from $maildir_what])\n\t\t    if test \"x$maildir_what\" != \"x_PATH_MAILDIR\"; then\n\t\t\tAC_DEFINE_UNQUOTED([MAIL_DIRECTORY], [\"$maildir\"])\n\t\t    fi\n\t\t],\n\t\t[\n\t\t    if test \"X$ac_status\" = \"X2\";then\n# our test program didn't find it. Default to /var/spool/mail\n\t\t\tAC_MSG_RESULT([Using: default value of /var/spool/mail])\n\t\t\tAC_DEFINE_UNQUOTED([MAIL_DIRECTORY], [\"/var/spool/mail\"])\n\t\t     else\n\t\t\tAC_MSG_RESULT([*** not found ***])\n\t\t     fi\n\t\t],\n\t\t[\n\t\t\tAC_MSG_WARN([cross compiling: use --with-maildir=/path/to/mail])\n\t\t]\n\t    )\n\tfi\n    ]\n) # maildir\n\nif test ! -z \"$cross_compiling\" && test \"x$cross_compiling\" = \"xyes\"; then\n\tAC_MSG_WARN([cross compiling: Disabling /dev/ptmx test])\n\tdisable_ptmx_check=yes\nfi\nif test -z \"$no_dev_ptmx\" ; then\n\tif test \"x$disable_ptmx_check\" != \"xyes\" ; then\n\t\tAC_CHECK_FILE([\"/dev/ptmx\"],\n\t\t\t[\n\t\t\t\tAC_DEFINE_UNQUOTED([HAVE_DEV_PTMX], [1],\n\t\t\t\t\t[Define if you have /dev/ptmx])\n\t\t\t\thave_dev_ptmx=1\n\t\t\t]\n\t\t)\n\tfi\nfi\n\nif test ! -z \"$cross_compiling\" && test \"x$cross_compiling\" != \"xyes\"; then\n\tAC_CHECK_FILE([\"/dev/ptc\"],\n\t\t[\n\t\t\tAC_DEFINE_UNQUOTED([HAVE_DEV_PTS_AND_PTC], [1],\n\t\t\t\t[Define if you have /dev/ptc])\n\t\t\thave_dev_ptc=1\n\t\t]\n\t)\nelse\n\tAC_MSG_WARN([cross compiling: Disabling /dev/ptc test])\nfi\n\n# Options from here on. Some of these are preset by platform above\nAC_ARG_WITH([mantype],\n\t[  --with-mantype=man|cat|doc  Set man page type],\n\t[\n\t\tcase \"$withval\" in\n\t\tman|cat|doc)\n\t\t\tMANTYPE=$withval\n\t\t\t;;\n\t\t*)\n\t\t\tAC_MSG_ERROR([invalid man type: $withval])\n\t\t\t;;\n\t\tesac\n\t]\n)\nif test -z \"$MANTYPE\"; then\n\tif ${MANDOC} ${srcdir}/ssh.1 >/dev/null 2>&1; then\n\t\tMANTYPE=doc\n\telif ${NROFF} -mdoc ${srcdir}/ssh.1 >/dev/null 2>&1; then\n\t\tMANTYPE=doc\n\telif ${NROFF} -man ${srcdir}/ssh.1 >/dev/null 2>&1; then\n\t\tMANTYPE=man\n\telse\n\t\tMANTYPE=cat\n\tfi\nfi\nAC_SUBST([MANTYPE])\nif test \"$MANTYPE\" = \"doc\"; then\n\tmansubdir=man;\nelse\n\tmansubdir=$MANTYPE;\nfi\nAC_SUBST([mansubdir])\n\n# Check whether to enable MD5 passwords\nMD5_MSG=\"no\"\nAC_ARG_WITH([md5-passwords],\n\t[  --with-md5-passwords    Enable use of MD5 passwords],\n\t[\n\t\tif test \"x$withval\" != \"xno\" ; then\n\t\t\tAC_DEFINE([HAVE_MD5_PASSWORDS], [1],\n\t\t\t\t[Define if you want to allow MD5 passwords])\n\t\t\tMD5_MSG=\"yes\"\n\t\tfi\n\t]\n)\n\n# Whether to disable shadow password support\nAC_ARG_WITH([shadow],\n\t[  --without-shadow        Disable shadow password support],\n\t[\n\t\tif test \"x$withval\" = \"xno\" ; then\n\t\t\tAC_DEFINE([DISABLE_SHADOW])\n\t\t\tdisable_shadow=yes\n\t\tfi\n\t]\n)\n\nif test -z \"$disable_shadow\" ; then\n\tAC_MSG_CHECKING([if the systems has expire shadow information])\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#include <sys/types.h>\n#include <shadow.h>\nstruct spwd sp;\n\t\t]], [[ sp.sp_expire = sp.sp_lstchg = sp.sp_inact = 0; ]])],\n\t\t[ sp_expire_available=yes ], [\n\t])\n\n\tif test \"x$sp_expire_available\" = \"xyes\" ; then\n\t\tAC_MSG_RESULT([yes])\n\t\tAC_DEFINE([HAS_SHADOW_EXPIRE], [1],\n\t\t    [Define if you want to use shadow password expire field])\n\telse\n\t\tAC_MSG_RESULT([no])\n\tfi\nfi\n\n# Use ip address instead of hostname in $DISPLAY\nif test ! -z \"$IPADDR_IN_DISPLAY\" ; then\n\tDISPLAY_HACK_MSG=\"yes\"\n\tAC_DEFINE([IPADDR_IN_DISPLAY], [1],\n\t\t[Define if you need to use IP address\n\t\tinstead of hostname in $DISPLAY])\nelse\n\tDISPLAY_HACK_MSG=\"no\"\n\tAC_ARG_WITH([ipaddr-display],\n\t\t[  --with-ipaddr-display   Use ip address instead of hostname in $DISPLAY],\n\t\t[\n\t\t\tif test \"x$withval\" != \"xno\" ; then\n\t\t\t\tAC_DEFINE([IPADDR_IN_DISPLAY])\n\t\t\t\tDISPLAY_HACK_MSG=\"yes\"\n\t\t\tfi\n\t\t]\n\t)\nfi\n\n# check for /etc/default/login and use it if present.\nAC_ARG_ENABLE([etc-default-login],\n\t[  --disable-etc-default-login Disable using PATH from /etc/default/login [no]],\n\t[ if test \"x$enableval\" = \"xno\"; then\n\t\tAC_MSG_NOTICE([/etc/default/login handling disabled])\n\t\tetc_default_login=no\n\t  else\n\t\tetc_default_login=yes\n\t  fi ],\n\t[ if test ! -z \"$cross_compiling\" && test \"x$cross_compiling\" = \"xyes\";\n\t  then\n\t\tAC_MSG_WARN([cross compiling: not checking /etc/default/login])\n\t\tetc_default_login=no\n\t  else\n\t\tetc_default_login=yes\n\t  fi ]\n)\n\nif test \"x$etc_default_login\" != \"xno\"; then\n\tAC_CHECK_FILE([\"/etc/default/login\"],\n\t    [ external_path_file=/etc/default/login ])\n\tif test \"x$external_path_file\" = \"x/etc/default/login\"; then\n\t\tAC_DEFINE([HAVE_ETC_DEFAULT_LOGIN], [1],\n\t\t\t[Define if your system has /etc/default/login])\n\tfi\nfi\n\ndnl BSD systems use /etc/login.conf so --with-default-path= has no effect\nif test $ac_cv_func_login_getcapbool = \"yes\" && \\\n\ttest $ac_cv_header_login_cap_h = \"yes\" ; then\n\texternal_path_file=/etc/login.conf\nfi\n\n# Whether to mess with the default path\nSERVER_PATH_MSG=\"(default)\"\nAC_ARG_WITH([default-path],\n\t[  --with-default-path=    Specify default $PATH environment for server],\n\t[\n\t\tif test \"x$external_path_file\" = \"x/etc/login.conf\" ; then\n\t\t\tAC_MSG_WARN([\n--with-default-path=PATH has no effect on this system.\nEdit /etc/login.conf instead.])\n\t\telif test \"x$withval\" != \"xno\" ; then\n\t\t\tif test ! -z \"$external_path_file\" ; then\n\t\t\t\tAC_MSG_WARN([\n--with-default-path=PATH will only be used if PATH is not defined in\n$external_path_file .])\n\t\t\tfi\n\t\t\tuser_path=\"$withval\"\n\t\t\tSERVER_PATH_MSG=\"$withval\"\n\t\tfi\n\t],\n\t[ if test \"x$external_path_file\" = \"x/etc/login.conf\" ; then\n\t\tAC_MSG_WARN([Make sure the path to scp is in /etc/login.conf])\n\telse\n\t\tif test ! -z \"$external_path_file\" ; then\n\t\t\tAC_MSG_WARN([\nIf PATH is defined in $external_path_file, ensure the path to scp is included,\notherwise scp will not work.])\n\t\tfi\n\t\tAC_RUN_IFELSE(\n\t\t\t[AC_LANG_PROGRAM([[\n/* find out what STDPATH is */\n#include <stdio.h>\n#include <stdlib.h>\n#ifdef HAVE_PATHS_H\n# include <paths.h>\n#endif\n#ifndef _PATH_STDPATH\n# ifdef _PATH_USERPATH\t/* Irix */\n#  define _PATH_STDPATH _PATH_USERPATH\n# else\n#  define _PATH_STDPATH \"/usr/bin:/bin:/usr/sbin:/sbin\"\n# endif\n#endif\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#define DATA \"conftest.stdpath\"\n\t\t\t]], [[\n\tFILE *fd;\n\tint rc;\n\n\tfd = fopen(DATA,\"w\");\n\tif(fd == NULL)\n\t\texit(1);\n\n\tif ((rc = fprintf(fd,\"%s\", _PATH_STDPATH)) < 0)\n\t\texit(1);\n\n\texit(0);\n\t\t]])],\n\t\t[ user_path=`cat conftest.stdpath` ],\n\t\t[ user_path=\"/usr/bin:/bin:/usr/sbin:/sbin\" ],\n\t\t[ user_path=\"/usr/bin:/bin:/usr/sbin:/sbin\" ]\n\t)\n# make sure $bindir is in USER_PATH so scp will work\n\t\tt_bindir=\"${bindir}\"\n\t\twhile echo \"${t_bindir}\" | egrep '\\$\\{|NONE/' >/dev/null 2>&1; do\n\t\t\tt_bindir=`eval echo ${t_bindir}`\n\t\t\tcase $t_bindir in\n\t\t\t\tNONE/*) t_bindir=`echo $t_bindir | sed \"s~NONE~$prefix~\"` ;;\n\t\t\tesac\n\t\t\tcase $t_bindir in\n\t\t\t\tNONE/*) t_bindir=`echo $t_bindir | sed \"s~NONE~$ac_default_prefix~\"` ;;\n\t\t\tesac\n\t\tdone\n\t\techo $user_path | grep \":$t_bindir\"  > /dev/null 2>&1\n\t\tif test $? -ne 0  ; then\n\t\t\techo $user_path | grep \"^$t_bindir\"  > /dev/null 2>&1\n\t\t\tif test $? -ne 0  ; then\n\t\t\t\tuser_path=$user_path:$t_bindir\n\t\t\t\tAC_MSG_RESULT([Adding $t_bindir to USER_PATH so scp will work])\n\t\t\tfi\n\t\tfi\n\tfi ]\n)\nif test \"x$external_path_file\" != \"x/etc/login.conf\" ; then\n\tAC_DEFINE_UNQUOTED([USER_PATH], [\"$user_path\"], [Specify default $PATH])\n\tAC_SUBST([user_path])\nfi\n\n# Set superuser path separately to user path\nAC_ARG_WITH([superuser-path],\n\t[  --with-superuser-path=  Specify different path for super-user],\n\t[\n\t\tif test -n \"$withval\"  &&  test \"x$withval\" != \"xno\"  &&  \\\n\t\t    test \"x${withval}\" != \"xyes\"; then\n\t\t\tAC_DEFINE_UNQUOTED([SUPERUSER_PATH], [\"$withval\"],\n\t\t\t\t[Define if you want a different $PATH\n\t\t\t\tfor the superuser])\n\t\t\tsuperuser_path=$withval\n\t\tfi\n\t]\n)\n\n\nAC_MSG_CHECKING([if we need to convert IPv4 in IPv6-mapped addresses])\nIPV4_IN6_HACK_MSG=\"no\"\nAC_ARG_WITH(4in6,\n\t[  --with-4in6             Check for and convert IPv4 in IPv6 mapped addresses],\n\t[\n\t\tif test \"x$withval\" != \"xno\" ; then\n\t\t\tAC_MSG_RESULT([yes])\n\t\t\tAC_DEFINE([IPV4_IN_IPV6], [1],\n\t\t\t\t[Detect IPv4 in IPv6 mapped addresses\n\t\t\t\tand treat as IPv4])\n\t\t\tIPV4_IN6_HACK_MSG=\"yes\"\n\t\telse\n\t\t\tAC_MSG_RESULT([no])\n\t\tfi\n\t], [\n\t\tif test \"x$inet6_default_4in6\" = \"xyes\"; then\n\t\t\tAC_MSG_RESULT([yes (default)])\n\t\t\tAC_DEFINE([IPV4_IN_IPV6])\n\t\t\tIPV4_IN6_HACK_MSG=\"yes\"\n\t\telse\n\t\t\tAC_MSG_RESULT([no (default)])\n\t\tfi\n\t]\n)\n\n# Whether to enable BSD auth support\nBSD_AUTH_MSG=no\nAC_ARG_WITH([bsd-auth],\n\t[  --with-bsd-auth         Enable BSD auth support],\n\t[\n\t\tif test \"x$withval\" != \"xno\" ; then\n\t\t\tAC_DEFINE([BSD_AUTH], [1],\n\t\t\t\t[Define if you have BSD auth support])\n\t\t\tBSD_AUTH_MSG=yes\n\t\tfi\n\t]\n)\n\n# Where to place sshd.pid\npiddir=/var/run\n# make sure the directory exists\nif test ! -d $piddir ; then\n\tpiddir=`eval echo ${sysconfdir}`\n\tcase $piddir in\n\t\tNONE/*) piddir=`echo $piddir | sed \"s~NONE~$ac_default_prefix~\"` ;;\n\tesac\nfi\n\nAC_ARG_WITH([pid-dir],\n\t[  --with-pid-dir=PATH     Specify location of sshd.pid file],\n\t[\n\t\tif test -n \"$withval\"  &&  test \"x$withval\" != \"xno\"  &&  \\\n\t\t    test \"x${withval}\" != \"xyes\"; then\n\t\t\tpiddir=$withval\n\t\t\tif test ! -d $piddir ; then\n\t\t\tAC_MSG_WARN([** no $piddir directory on this system **])\n\t\t\tfi\n\t\tfi\n\t]\n)\n\nAC_DEFINE_UNQUOTED([_PATH_SSH_PIDDIR], [\"$piddir\"],\n\t[Specify location of ssh.pid])\nAC_SUBST([piddir])\n\ndnl allow user to disable some login recording features\nAC_ARG_ENABLE([lastlog],\n\t[  --disable-lastlog       disable use of lastlog even if detected [no]],\n\t[\n\t\tif test \"x$enableval\" = \"xno\" ; then\n\t\t\tAC_DEFINE([DISABLE_LASTLOG])\n\t\tfi\n\t]\n)\nAC_ARG_ENABLE([utmp],\n\t[  --disable-utmp          disable use of utmp even if detected [no]],\n\t[\n\t\tif test \"x$enableval\" = \"xno\" ; then\n\t\t\tAC_DEFINE([DISABLE_UTMP])\n\t\tfi\n\t]\n)\nAC_ARG_ENABLE([utmpx],\n\t[  --disable-utmpx         disable use of utmpx even if detected [no]],\n\t[\n\t\tif test \"x$enableval\" = \"xno\" ; then\n\t\t\tAC_DEFINE([DISABLE_UTMPX], [1],\n\t\t\t\t[Define if you don't want to use utmpx])\n\t\tfi\n\t]\n)\nAC_ARG_ENABLE([wtmp],\n\t[  --disable-wtmp          disable use of wtmp even if detected [no]],\n\t[\n\t\tif test \"x$enableval\" = \"xno\" ; then\n\t\t\tAC_DEFINE([DISABLE_WTMP])\n\t\tfi\n\t]\n)\nAC_ARG_ENABLE([wtmpx],\n\t[  --disable-wtmpx         disable use of wtmpx even if detected [no]],\n\t[\n\t\tif test \"x$enableval\" = \"xno\" ; then\n\t\t\tAC_DEFINE([DISABLE_WTMPX], [1],\n\t\t\t\t[Define if you don't want to use wtmpx])\n\t\tfi\n\t]\n)\nAC_ARG_ENABLE([libutil],\n\t[  --disable-libutil       disable use of libutil (login() etc.) [no]],\n\t[\n\t\tif test \"x$enableval\" = \"xno\" ; then\n\t\t\tAC_DEFINE([DISABLE_LOGIN])\n\t\tfi\n\t]\n)\nAC_ARG_ENABLE([pututline],\n\t[  --disable-pututline     disable use of pututline() etc. ([uw]tmp) [no]],\n\t[\n\t\tif test \"x$enableval\" = \"xno\" ; then\n\t\t\tAC_DEFINE([DISABLE_PUTUTLINE], [1],\n\t\t\t\t[Define if you don't want to use pututline()\n\t\t\t\tetc. to write [uw]tmp])\n\t\tfi\n\t]\n)\nAC_ARG_ENABLE([pututxline],\n\t[  --disable-pututxline    disable use of pututxline() etc. ([uw]tmpx) [no]],\n\t[\n\t\tif test \"x$enableval\" = \"xno\" ; then\n\t\t\tAC_DEFINE([DISABLE_PUTUTXLINE], [1],\n\t\t\t\t[Define if you don't want to use pututxline()\n\t\t\t\tetc. to write [uw]tmpx])\n\t\tfi\n\t]\n)\nAC_ARG_WITH([lastlog],\n  [  --with-lastlog=FILE|DIR specify lastlog location [common locations]],\n\t[\n\t\tif test \"x$withval\" = \"xno\" ; then\n\t\t\tAC_DEFINE([DISABLE_LASTLOG])\n\t\telif test -n \"$withval\"  &&  test \"x${withval}\" != \"xyes\"; then\n\t\t\tconf_lastlog_location=$withval\n\t\tfi\n\t]\n)\n\ndnl lastlog, [uw]tmpx? detection\ndnl  NOTE: set the paths in the platform section to avoid the\ndnl   need for command-line parameters\ndnl lastlog and [uw]tmp are subject to a file search if all else fails\n\ndnl lastlog detection\ndnl  NOTE: the code itself will detect if lastlog is a directory\nAC_MSG_CHECKING([if your system defines LASTLOG_FILE])\nAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#include <sys/types.h>\n#include <utmp.h>\n#ifdef HAVE_LASTLOG_H\n#  include <lastlog.h>\n#endif\n#ifdef HAVE_PATHS_H\n#  include <paths.h>\n#endif\n#ifdef HAVE_LOGIN_H\n# include <login.h>\n#endif\n\t]], [[ char *lastlog = LASTLOG_FILE; ]])],\n\t\t[ AC_MSG_RESULT([yes]) ],\n\t\t[\n\t\tAC_MSG_RESULT([no])\n\t\tAC_MSG_CHECKING([if your system defines _PATH_LASTLOG])\n\t\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#include <sys/types.h>\n#include <utmp.h>\n#ifdef HAVE_LASTLOG_H\n#  include <lastlog.h>\n#endif\n#ifdef HAVE_PATHS_H\n#  include <paths.h>\n#endif\n\t\t]], [[ char *lastlog = _PATH_LASTLOG; ]])],\n\t\t[ AC_MSG_RESULT([yes]) ],\n\t\t[\n\t\t\tAC_MSG_RESULT([no])\n\t\t\tsystem_lastlog_path=no\n\t\t])\n])\n\nif test -z \"$conf_lastlog_location\"; then\n\tif test x\"$system_lastlog_path\" = x\"no\" ; then\n\t\tfor f in /var/log/lastlog /usr/adm/lastlog /var/adm/lastlog /etc/security/lastlog ; do\n\t\t\t\tif (test -d \"$f\" || test -f \"$f\") ; then\n\t\t\t\t\tconf_lastlog_location=$f\n\t\t\t\tfi\n\t\tdone\n\t\tif test -z \"$conf_lastlog_location\"; then\n\t\t\tAC_MSG_WARN([** Cannot find lastlog **])\n\t\t\tdnl Don't define DISABLE_LASTLOG - that means we don't try wtmp/wtmpx\n\t\tfi\n\tfi\nfi\n\nif test -n \"$conf_lastlog_location\"; then\n\tAC_DEFINE_UNQUOTED([CONF_LASTLOG_FILE], [\"$conf_lastlog_location\"],\n\t\t[Define if you want to specify the path to your lastlog file])\nfi\n\ndnl utmp detection\nAC_MSG_CHECKING([if your system defines UTMP_FILE])\nAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#include <sys/types.h>\n#include <utmp.h>\n#ifdef HAVE_PATHS_H\n#  include <paths.h>\n#endif\n\t]], [[ char *utmp = UTMP_FILE; ]])],\n\t[ AC_MSG_RESULT([yes]) ],\n\t[ AC_MSG_RESULT([no])\n\t  system_utmp_path=no\n])\nif test -z \"$conf_utmp_location\"; then\n\tif test x\"$system_utmp_path\" = x\"no\" ; then\n\t\tfor f in /etc/utmp /usr/adm/utmp /var/run/utmp; do\n\t\t\tif test -f $f ; then\n\t\t\t\tconf_utmp_location=$f\n\t\t\tfi\n\t\tdone\n\t\tif test -z \"$conf_utmp_location\"; then\n\t\t\tAC_DEFINE([DISABLE_UTMP])\n\t\tfi\n\tfi\nfi\nif test -n \"$conf_utmp_location\"; then\n\tAC_DEFINE_UNQUOTED([CONF_UTMP_FILE], [\"$conf_utmp_location\"],\n\t\t[Define if you want to specify the path to your utmp file])\nfi\n\ndnl wtmp detection\nAC_MSG_CHECKING([if your system defines WTMP_FILE])\nAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#include <sys/types.h>\n#include <utmp.h>\n#ifdef HAVE_PATHS_H\n#  include <paths.h>\n#endif\n\t]], [[ char *wtmp = WTMP_FILE; ]])],\n\t[ AC_MSG_RESULT([yes]) ],\n\t[ AC_MSG_RESULT([no])\n\t  system_wtmp_path=no\n])\nif test -z \"$conf_wtmp_location\"; then\n\tif test x\"$system_wtmp_path\" = x\"no\" ; then\n\t\tfor f in /usr/adm/wtmp /var/log/wtmp; do\n\t\t\tif test -f $f ; then\n\t\t\t\tconf_wtmp_location=$f\n\t\t\tfi\n\t\tdone\n\t\tif test -z \"$conf_wtmp_location\"; then\n\t\t\tAC_DEFINE([DISABLE_WTMP])\n\t\tfi\n\tfi\nfi\nif test -n \"$conf_wtmp_location\"; then\n\tAC_DEFINE_UNQUOTED([CONF_WTMP_FILE], [\"$conf_wtmp_location\"],\n\t\t[Define if you want to specify the path to your wtmp file])\nfi\n\ndnl wtmpx detection\nAC_MSG_CHECKING([if your system defines WTMPX_FILE])\nAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#include <sys/types.h>\n#include <utmp.h>\n#ifdef HAVE_UTMPX_H\n#include <utmpx.h>\n#endif\n#ifdef HAVE_PATHS_H\n#  include <paths.h>\n#endif\n\t]], [[ char *wtmpx = WTMPX_FILE; ]])],\n\t[ AC_MSG_RESULT([yes]) ],\n\t[ AC_MSG_RESULT([no])\n\t  system_wtmpx_path=no\n])\nif test -z \"$conf_wtmpx_location\"; then\n\tif test x\"$system_wtmpx_path\" = x\"no\" ; then\n\t\tAC_DEFINE([DISABLE_WTMPX])\n\tfi\nelse\n\tAC_DEFINE_UNQUOTED([CONF_WTMPX_FILE], [\"$conf_wtmpx_location\"],\n\t\t[Define if you want to specify the path to your wtmpx file])\nfi\n\n\nif test ! -z \"$blibpath\" ; then\n\tLDFLAGS=\"$LDFLAGS $blibflags$blibpath\"\n\tAC_MSG_WARN([Please check and edit blibpath in LDFLAGS in Makefile])\nfi\n\nAC_CHECK_MEMBER([struct lastlog.ll_line], [], [\n    if test x$SKIP_DISABLE_LASTLOG_DEFINE != \"xyes\" ; then\n\tAC_DEFINE([DISABLE_LASTLOG])\n    fi\n\t], [\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n#ifdef HAVE_UTMP_H\n#include <utmp.h>\n#endif\n#ifdef HAVE_UTMPX_H\n#include <utmpx.h>\n#endif\n#ifdef HAVE_LASTLOG_H\n#include <lastlog.h>\n#endif\n\t])\n\nAC_CHECK_MEMBER([struct utmp.ut_line], [], [\n\tAC_DEFINE([DISABLE_UTMP])\n\tAC_DEFINE([DISABLE_WTMP])\n\t], [\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n#ifdef HAVE_UTMP_H\n#include <utmp.h>\n#endif\n#ifdef HAVE_UTMPX_H\n#include <utmpx.h>\n#endif\n#ifdef HAVE_LASTLOG_H\n#include <lastlog.h>\n#endif\n\t])\n\ndnl Adding -Werror to CFLAGS early prevents configure tests from running.\ndnl Add now.\nCFLAGS=\"$CFLAGS $werror_flags\"\n\nif test \"x$ac_cv_func_getaddrinfo\" != \"xyes\" ; then\n\tTEST_SSH_IPV6=no\nelse\n\tTEST_SSH_IPV6=yes\nfi\nAC_CHECK_DECL([BROKEN_GETADDRINFO],  [TEST_SSH_IPV6=no])\nAC_SUBST([TEST_SSH_IPV6], [$TEST_SSH_IPV6])\nAC_SUBST([TEST_SSH_UTF8], [$TEST_SSH_UTF8])\nAC_SUBST([TEST_MALLOC_OPTIONS], [$TEST_MALLOC_OPTIONS])\nAC_SUBST([UNSUPPORTED_ALGORITHMS], [$unsupported_algorithms])\nAC_SUBST([DEPEND], [$(cat $srcdir/.depend)])\n\nCFLAGS=\"${CFLAGS} ${CFLAGS_AFTER}\"\nLDFLAGS=\"${LDFLAGS} ${LDFLAGS_AFTER}\"\n\n# Make a copy of CFLAGS/LDFLAGS without PIE options.\nLDFLAGS_NOPIE=`echo \"$LDFLAGS\" | sed 's/ -pie//'`\nCFLAGS_NOPIE=`echo \"$CFLAGS\" | sed 's/ -fPIE//'`\nAC_SUBST([LDFLAGS_NOPIE])\nAC_SUBST([CFLAGS_NOPIE])\n\nAC_EXEEXT\nAC_CONFIG_FILES([Makefile buildpkg.sh opensshd.init openssh.xml \\\n\topenbsd-compat/Makefile openbsd-compat/regress/Makefile \\\n\tsurvey.sh])\nAC_OUTPUT\n\n# Print summary of options\n\n# Someone please show me a better way :)\nA=`eval echo ${prefix}` ; A=`eval echo ${A}`\nB=`eval echo ${bindir}` ; B=`eval echo ${B}`\nC=`eval echo ${sbindir}` ; C=`eval echo ${C}`\nD=`eval echo ${sysconfdir}` ; D=`eval echo ${D}`\nE=`eval echo ${libexecdir}/ssh-askpass` ; E=`eval echo ${E}`\nF=`eval echo ${mandir}/${mansubdir}X` ; F=`eval echo ${F}`\nG=`eval echo ${piddir}` ; G=`eval echo ${G}`\nH=`eval echo ${PRIVSEP_PATH}` ; H=`eval echo ${H}`\nI=`eval echo ${user_path}` ; I=`eval echo ${I}`\nJ=`eval echo ${superuser_path}` ; J=`eval echo ${J}`\n\necho \"\"\necho \"OpenSSH has been configured with the following options:\"\necho \"                     User binaries: $B\"\necho \"                   System binaries: $C\"\necho \"               Configuration files: $D\"\necho \"                   Askpass program: $E\"\necho \"                      Manual pages: $F\"\necho \"                          PID file: $G\"\necho \"  Privilege separation chroot path: $H\"\nif test \"x$external_path_file\" = \"x/etc/login.conf\" ; then\necho \"   At runtime, sshd will use the path defined in $external_path_file\"\necho \"   Make sure the path to scp is present, otherwise scp will not work\"\nelse\necho \"            sshd default user PATH: $I\"\n\tif test ! -z \"$external_path_file\"; then\necho \"   (If PATH is set in $external_path_file it will be used instead. If\"\necho \"   used, ensure the path to scp is present, otherwise scp will not work.)\"\n\tfi\nfi\nif test ! -z \"$superuser_path\" ; then\necho \"          sshd superuser user PATH: $J\"\nfi\necho \"                    Manpage format: $MANTYPE\"\necho \"                       PAM support: $PAM_MSG\"\necho \"                   OSF SIA support: $SIA_MSG\"\necho \"                 KerberosV support: $KRB5_MSG\"\necho \"                   SELinux support: $SELINUX_MSG\"\necho \"              MD5 password support: $MD5_MSG\"\necho \"                   libedit support: $LIBEDIT_MSG\"\necho \"                   libldns support: $LDNS_MSG\"\necho \"  Solaris process contract support: $SPC_MSG\"\necho \"           Solaris project support: $SP_MSG\"\necho \"         Solaris privilege support: $SPP_MSG\"\necho \"       IP address in \\$DISPLAY hack: $DISPLAY_HACK_MSG\"\necho \"           Translate v4 in v6 hack: $IPV4_IN6_HACK_MSG\"\necho \"                  BSD Auth support: $BSD_AUTH_MSG\"\necho \"              Random number source: $RAND_MSG\"\necho \"             Privsep sandbox style: $SANDBOX_STYLE\"\necho \"                   PKCS#11 support: $enable_pkcs11\"\necho \"                  U2F/FIDO support: $enable_sk\"\n\necho \"\"\n\necho \"              Host: ${host}\"\necho \"          Compiler: ${CC}\"\necho \"    Compiler flags: ${CFLAGS}\"\necho \"Preprocessor flags: ${CPPFLAGS}\"\necho \"      Linker flags: ${LDFLAGS}\"\necho \"         Libraries: ${LIBS}\"\nif test ! -z \"${SSHDLIBS}\"; then\necho \"         +for sshd: ${SSHDLIBS}\"\nfi\n\necho \"\"\n\nif test \"x$MAKE_PACKAGE_SUPPORTED\" = \"xyes\" ; then\n\techo \"SVR4 style packages are supported with \\\"make package\\\"\"\n\techo \"\"\nfi\n\nif test \"x$PAM_MSG\" = \"xyes\" ; then\n\techo \"PAM is enabled. You may need to install a PAM control file \"\n\techo \"for sshd, otherwise password authentication may fail. \"\n\techo \"Example PAM control files can be found in the contrib/ \"\n\techo \"subdirectory\"\n\techo \"\"\nfi\n\nif test ! -z \"$NO_PEERCHECK\" ; then\n\techo \"WARNING: the operating system that you are using does not\"\n\techo \"appear to support getpeereid(), getpeerucred() or the\"\n\techo \"SO_PEERCRED getsockopt() option. These facilities are used to\"\n\techo \"enforce security checks to prevent unauthorised connections to\"\n\techo \"ssh-agent. Their absence increases the risk that a malicious\"\n\techo \"user can connect to your agent.\"\n\techo \"\"\nfi\n\nif test \"$AUDIT_MODULE\" = \"bsm\" ; then\n\techo \"WARNING: BSM audit support is currently considered EXPERIMENTAL.\"\n\techo \"See the Solaris section in README.platform for details.\"\nfi\n",
        "/tmp/vanessa/spack-stage/spack-stage-openssh-8.4p1-gs222i4ctitv7fl27wgnurjoqoks3e7r/spack-src/ssh-pkcs11.c": "/* $OpenBSD: ssh-pkcs11.c,v 1.50 2020/05/29 03:14:02 djm Exp $ */\n/*\n * Copyright (c) 2010 Markus Friedl.  All rights reserved.\n * Copyright (c) 2014 Pedro Martelletto. All rights reserved.\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include \"includes.h\"\n\n#ifdef ENABLE_PKCS11\n\n#ifdef HAVE_SYS_TIME_H\n# include <sys/time.h>\n#endif\n\n#include <sys/types.h>\n#include <stdarg.h>\n#include <stdio.h>\n\n#include <ctype.h>\n#include <string.h>\n#include <dlfcn.h>\n\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n\n#include <openssl/ecdsa.h>\n#include <openssl/x509.h>\n#include <openssl/err.h>\n\n#define CRYPTOKI_COMPAT\n#include \"pkcs11.h\"\n\n#include \"log.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"ssh-pkcs11.h\"\n#include \"xmalloc.h\"\n\nstruct pkcs11_slotinfo {\n\tCK_TOKEN_INFO\t\ttoken;\n\tCK_SESSION_HANDLE\tsession;\n\tint\t\t\tlogged_in;\n};\n\nstruct pkcs11_provider {\n\tchar\t\t\t*name;\n\tvoid\t\t\t*handle;\n\tCK_FUNCTION_LIST\t*function_list;\n\tCK_INFO\t\t\tinfo;\n\tCK_ULONG\t\tnslots;\n\tCK_SLOT_ID\t\t*slotlist;\n\tstruct pkcs11_slotinfo\t*slotinfo;\n\tint\t\t\tvalid;\n\tint\t\t\trefcount;\n\tTAILQ_ENTRY(pkcs11_provider) next;\n};\n\nTAILQ_HEAD(, pkcs11_provider) pkcs11_providers;\n\nstruct pkcs11_key {\n\tstruct pkcs11_provider\t*provider;\n\tCK_ULONG\t\tslotidx;\n\tchar\t\t\t*keyid;\n\tint\t\t\tkeyid_len;\n};\n\nint pkcs11_interactive = 0;\n\n#ifdef HAVE_EC_KEY_METHOD_NEW\nstatic void\nossl_error(const char *msg)\n{\n\tunsigned long    e;\n\n\terror(\"%s: %s\", __func__, msg);\n\twhile ((e = ERR_get_error()) != 0)\n\t\terror(\"%s: libcrypto error: %.100s\", __func__,\n\t\t    ERR_error_string(e, NULL));\n}\n#endif /* HAVE_EC_KEY_METHOD_NEW */\n\nint\npkcs11_init(int interactive)\n{\n\tpkcs11_interactive = interactive;\n\tTAILQ_INIT(&pkcs11_providers);\n\treturn (0);\n}\n\n/*\n * finalize a provider shared library, it's no longer usable.\n * however, there might still be keys referencing this provider,\n * so the actual freeing of memory is handled by pkcs11_provider_unref().\n * this is called when a provider gets unregistered.\n */\nstatic void\npkcs11_provider_finalize(struct pkcs11_provider *p)\n{\n\tCK_RV rv;\n\tCK_ULONG i;\n\n\tdebug(\"pkcs11_provider_finalize: %p refcount %d valid %d\",\n\t    p, p->refcount, p->valid);\n\tif (!p->valid)\n\t\treturn;\n\tfor (i = 0; i < p->nslots; i++) {\n\t\tif (p->slotinfo[i].session &&\n\t\t    (rv = p->function_list->C_CloseSession(\n\t\t    p->slotinfo[i].session)) != CKR_OK)\n\t\t\terror(\"C_CloseSession failed: %lu\", rv);\n\t}\n\tif ((rv = p->function_list->C_Finalize(NULL)) != CKR_OK)\n\t\terror(\"C_Finalize failed: %lu\", rv);\n\tp->valid = 0;\n\tp->function_list = NULL;\n\tdlclose(p->handle);\n}\n\n/*\n * remove a reference to the provider.\n * called when a key gets destroyed or when the provider is unregistered.\n */\nstatic void\npkcs11_provider_unref(struct pkcs11_provider *p)\n{\n\tdebug(\"pkcs11_provider_unref: %p refcount %d\", p, p->refcount);\n\tif (--p->refcount <= 0) {\n\t\tif (p->valid)\n\t\t\terror(\"pkcs11_provider_unref: %p still valid\", p);\n\t\tfree(p->name);\n\t\tfree(p->slotlist);\n\t\tfree(p->slotinfo);\n\t\tfree(p);\n\t}\n}\n\n/* unregister all providers, keys might still point to the providers */\nvoid\npkcs11_terminate(void)\n{\n\tstruct pkcs11_provider *p;\n\n\twhile ((p = TAILQ_FIRST(&pkcs11_providers)) != NULL) {\n\t\tTAILQ_REMOVE(&pkcs11_providers, p, next);\n\t\tpkcs11_provider_finalize(p);\n\t\tpkcs11_provider_unref(p);\n\t}\n}\n\n/* lookup provider by name */\nstatic struct pkcs11_provider *\npkcs11_provider_lookup(char *provider_id)\n{\n\tstruct pkcs11_provider *p;\n\n\tTAILQ_FOREACH(p, &pkcs11_providers, next) {\n\t\tdebug(\"check %p %s\", p, p->name);\n\t\tif (!strcmp(provider_id, p->name))\n\t\t\treturn (p);\n\t}\n\treturn (NULL);\n}\n\n/* unregister provider by name */\nint\npkcs11_del_provider(char *provider_id)\n{\n\tstruct pkcs11_provider *p;\n\n\tif ((p = pkcs11_provider_lookup(provider_id)) != NULL) {\n\t\tTAILQ_REMOVE(&pkcs11_providers, p, next);\n\t\tpkcs11_provider_finalize(p);\n\t\tpkcs11_provider_unref(p);\n\t\treturn (0);\n\t}\n\treturn (-1);\n}\n\nstatic RSA_METHOD *rsa_method;\nstatic int rsa_idx = 0;\n#ifdef HAVE_EC_KEY_METHOD_NEW\nstatic EC_KEY_METHOD *ec_key_method;\nstatic int ec_key_idx = 0;\n#endif\n\n/* release a wrapped object */\nstatic void\npkcs11_k11_free(void *parent, void *ptr, CRYPTO_EX_DATA *ad, int idx,\n    long argl, void *argp)\n{\n\tstruct pkcs11_key\t*k11 = ptr;\n\n\tdebug(\"%s: parent %p ptr %p idx %d\", __func__, parent, ptr, idx);\n\tif (k11 == NULL)\n\t\treturn;\n\tif (k11->provider)\n\t\tpkcs11_provider_unref(k11->provider);\n\tfree(k11->keyid);\n\tfree(k11);\n}\n\n/* find a single 'obj' for given attributes */\nstatic int\npkcs11_find(struct pkcs11_provider *p, CK_ULONG slotidx, CK_ATTRIBUTE *attr,\n    CK_ULONG nattr, CK_OBJECT_HANDLE *obj)\n{\n\tCK_FUNCTION_LIST\t*f;\n\tCK_SESSION_HANDLE\tsession;\n\tCK_ULONG\t\tnfound = 0;\n\tCK_RV\t\t\trv;\n\tint\t\t\tret = -1;\n\n\tf = p->function_list;\n\tsession = p->slotinfo[slotidx].session;\n\tif ((rv = f->C_FindObjectsInit(session, attr, nattr)) != CKR_OK) {\n\t\terror(\"C_FindObjectsInit failed (nattr %lu): %lu\", nattr, rv);\n\t\treturn (-1);\n\t}\n\tif ((rv = f->C_FindObjects(session, obj, 1, &nfound)) != CKR_OK ||\n\t    nfound != 1) {\n\t\tdebug(\"C_FindObjects failed (nfound %lu nattr %lu): %lu\",\n\t\t    nfound, nattr, rv);\n\t} else\n\t\tret = 0;\n\tif ((rv = f->C_FindObjectsFinal(session)) != CKR_OK)\n\t\terror(\"C_FindObjectsFinal failed: %lu\", rv);\n\treturn (ret);\n}\n\nstatic int\npkcs11_login_slot(struct pkcs11_provider *provider, struct pkcs11_slotinfo *si,\n    CK_USER_TYPE type)\n{\n\tchar\t\t\t*pin = NULL, prompt[1024];\n\tCK_RV\t\t\t rv;\n\n\tif (provider == NULL || si == NULL || !provider->valid) {\n\t\terror(\"no pkcs11 (valid) provider found\");\n\t\treturn (-1);\n\t}\n\n\tif (!pkcs11_interactive) {\n\t\terror(\"need pin entry%s\",\n\t\t    (si->token.flags & CKF_PROTECTED_AUTHENTICATION_PATH) ?\n\t\t    \" on reader keypad\" : \"\");\n\t\treturn (-1);\n\t}\n\tif (si->token.flags & CKF_PROTECTED_AUTHENTICATION_PATH)\n\t\tverbose(\"Deferring PIN entry to reader keypad.\");\n\telse {\n\t\tsnprintf(prompt, sizeof(prompt), \"Enter PIN for '%s': \",\n\t\t    si->token.label);\n\t\tif ((pin = read_passphrase(prompt, RP_ALLOW_EOF)) == NULL) {\n\t\t\tdebug(\"%s: no pin specified\", __func__);\n\t\t\treturn (-1);\t/* bail out */\n\t\t}\n\t}\n\trv = provider->function_list->C_Login(si->session, type, (u_char *)pin,\n\t    (pin != NULL) ? strlen(pin) : 0);\n\tif (pin != NULL)\n\t\tfreezero(pin, strlen(pin));\n\n\tswitch (rv) {\n\tcase CKR_OK:\n\tcase CKR_USER_ALREADY_LOGGED_IN:\n\t\t/* success */\n\t\tbreak;\n\tcase CKR_PIN_LEN_RANGE:\n\t\terror(\"PKCS#11 login failed: PIN length out of range\");\n\t\treturn -1;\n\tcase CKR_PIN_INCORRECT:\n\t\terror(\"PKCS#11 login failed: PIN incorrect\");\n\t\treturn -1;\n\tcase CKR_PIN_LOCKED:\n\t\terror(\"PKCS#11 login failed: PIN locked\");\n\t\treturn -1;\n\tdefault:\n\t\terror(\"PKCS#11 login failed: error %lu\", rv);\n\t\treturn -1;\n\t}\n\tsi->logged_in = 1;\n\treturn (0);\n}\n\nstatic int\npkcs11_login(struct pkcs11_key *k11, CK_USER_TYPE type)\n{\n\tif (k11 == NULL || k11->provider == NULL || !k11->provider->valid) {\n\t\terror(\"no pkcs11 (valid) provider found\");\n\t\treturn (-1);\n\t}\n\n\treturn pkcs11_login_slot(k11->provider,\n\t    &k11->provider->slotinfo[k11->slotidx], type);\n}\n\n\nstatic int\npkcs11_check_obj_bool_attrib(struct pkcs11_key *k11, CK_OBJECT_HANDLE obj,\n    CK_ATTRIBUTE_TYPE type, int *val)\n{\n\tstruct pkcs11_slotinfo\t*si;\n\tCK_FUNCTION_LIST\t*f;\n\tCK_BBOOL\t\tflag = 0;\n\tCK_ATTRIBUTE\t\tattr;\n\tCK_RV\t\t\t rv;\n\n\t*val = 0;\n\n\tif (!k11->provider || !k11->provider->valid) {\n\t\terror(\"no pkcs11 (valid) provider found\");\n\t\treturn (-1);\n\t}\n\n\tf = k11->provider->function_list;\n\tsi = &k11->provider->slotinfo[k11->slotidx];\n\n\tattr.type = type;\n\tattr.pValue = &flag;\n\tattr.ulValueLen = sizeof(flag);\n\n\trv = f->C_GetAttributeValue(si->session, obj, &attr, 1);\n\tif (rv != CKR_OK) {\n\t\terror(\"C_GetAttributeValue failed: %lu\", rv);\n\t\treturn (-1);\n\t}\n\t*val = flag != 0;\n\tdebug(\"%s: provider %p slot %lu object %lu: attrib %lu = %d\",\n\t    __func__, k11->provider, k11->slotidx, obj, type, *val);\n\treturn (0);\n}\n\nstatic int\npkcs11_get_key(struct pkcs11_key *k11, CK_MECHANISM_TYPE mech_type)\n{\n\tstruct pkcs11_slotinfo\t*si;\n\tCK_FUNCTION_LIST\t*f;\n\tCK_OBJECT_HANDLE\t obj;\n\tCK_RV\t\t\t rv;\n\tCK_OBJECT_CLASS\t\t private_key_class;\n\tCK_BBOOL\t\t true_val;\n\tCK_MECHANISM\t\t mech;\n\tCK_ATTRIBUTE\t\t key_filter[3];\n\tint\t\t\t always_auth = 0;\n\tint\t\t\t did_login = 0;\n\n\tif (!k11->provider || !k11->provider->valid) {\n\t\terror(\"no pkcs11 (valid) provider found\");\n\t\treturn (-1);\n\t}\n\n\tf = k11->provider->function_list;\n\tsi = &k11->provider->slotinfo[k11->slotidx];\n\n\tif ((si->token.flags & CKF_LOGIN_REQUIRED) && !si->logged_in) {\n\t\tif (pkcs11_login(k11, CKU_USER) < 0) {\n\t\t\terror(\"login failed\");\n\t\t\treturn (-1);\n\t\t}\n\t\tdid_login = 1;\n\t}\n\n\tmemset(&key_filter, 0, sizeof(key_filter));\n\tprivate_key_class = CKO_PRIVATE_KEY;\n\tkey_filter[0].type = CKA_CLASS;\n\tkey_filter[0].pValue = &private_key_class;\n\tkey_filter[0].ulValueLen = sizeof(private_key_class);\n\n\tkey_filter[1].type = CKA_ID;\n\tkey_filter[1].pValue = k11->keyid;\n\tkey_filter[1].ulValueLen = k11->keyid_len;\n\n\ttrue_val = CK_TRUE;\n\tkey_filter[2].type = CKA_SIGN;\n\tkey_filter[2].pValue = &true_val;\n\tkey_filter[2].ulValueLen = sizeof(true_val);\n\n\t/* try to find object w/CKA_SIGN first, retry w/o */\n\tif (pkcs11_find(k11->provider, k11->slotidx, key_filter, 3, &obj) < 0 &&\n\t    pkcs11_find(k11->provider, k11->slotidx, key_filter, 2, &obj) < 0) {\n\t\terror(\"cannot find private key\");\n\t\treturn (-1);\n\t}\n\n\tmemset(&mech, 0, sizeof(mech));\n\tmech.mechanism = mech_type;\n\tmech.pParameter = NULL_PTR;\n\tmech.ulParameterLen = 0;\n\n\tif ((rv = f->C_SignInit(si->session, &mech, obj)) != CKR_OK) {\n\t\terror(\"C_SignInit failed: %lu\", rv);\n\t\treturn (-1);\n\t}\n\n\tpkcs11_check_obj_bool_attrib(k11, obj, CKA_ALWAYS_AUTHENTICATE,\n\t    &always_auth); /* ignore errors here */\n\tif (always_auth && !did_login) {\n\t\tdebug(\"%s: always-auth key\", __func__);\n\t\tif (pkcs11_login(k11, CKU_CONTEXT_SPECIFIC) < 0) {\n\t\t\terror(\"login failed for always-auth key\");\n\t\t\treturn (-1);\n\t\t}\n\t}\n\n\treturn (0);\n}\n\n/* openssl callback doing the actual signing operation */\nstatic int\npkcs11_rsa_private_encrypt(int flen, const u_char *from, u_char *to, RSA *rsa,\n    int padding)\n{\n\tstruct pkcs11_key\t*k11;\n\tstruct pkcs11_slotinfo\t*si;\n\tCK_FUNCTION_LIST\t*f;\n\tCK_ULONG\t\ttlen = 0;\n\tCK_RV\t\t\trv;\n\tint\t\t\trval = -1;\n\n\tif ((k11 = RSA_get_ex_data(rsa, rsa_idx)) == NULL) {\n\t\terror(\"RSA_get_ex_data failed for rsa %p\", rsa);\n\t\treturn (-1);\n\t}\n\n\tif (pkcs11_get_key(k11, CKM_RSA_PKCS) == -1) {\n\t\terror(\"pkcs11_get_key failed\");\n\t\treturn (-1);\n\t}\n\n\tf = k11->provider->function_list;\n\tsi = &k11->provider->slotinfo[k11->slotidx];\n\ttlen = RSA_size(rsa);\n\n\t/* XXX handle CKR_BUFFER_TOO_SMALL */\n\trv = f->C_Sign(si->session, (CK_BYTE *)from, flen, to, &tlen);\n\tif (rv == CKR_OK)\n\t\trval = tlen;\n\telse\n\t\terror(\"C_Sign failed: %lu\", rv);\n\n\treturn (rval);\n}\n\nstatic int\npkcs11_rsa_private_decrypt(int flen, const u_char *from, u_char *to, RSA *rsa,\n    int padding)\n{\n\treturn (-1);\n}\n\nstatic int\npkcs11_rsa_start_wrapper(void)\n{\n\tif (rsa_method != NULL)\n\t\treturn (0);\n\trsa_method = RSA_meth_dup(RSA_get_default_method());\n\tif (rsa_method == NULL)\n\t\treturn (-1);\n\trsa_idx = RSA_get_ex_new_index(0, \"ssh-pkcs11-rsa\",\n\t    NULL, NULL, pkcs11_k11_free);\n\tif (rsa_idx == -1)\n\t\treturn (-1);\n\tif (!RSA_meth_set1_name(rsa_method, \"pkcs11\") ||\n\t    !RSA_meth_set_priv_enc(rsa_method, pkcs11_rsa_private_encrypt) ||\n\t    !RSA_meth_set_priv_dec(rsa_method, pkcs11_rsa_private_decrypt)) {\n\t\terror(\"%s: setup pkcs11 method failed\", __func__);\n\t\treturn (-1);\n\t}\n\treturn (0);\n}\n\n/* redirect private key operations for rsa key to pkcs11 token */\nstatic int\npkcs11_rsa_wrap(struct pkcs11_provider *provider, CK_ULONG slotidx,\n    CK_ATTRIBUTE *keyid_attrib, RSA *rsa)\n{\n\tstruct pkcs11_key\t*k11;\n\n\tif (pkcs11_rsa_start_wrapper() == -1)\n\t\treturn (-1);\n\n\tk11 = xcalloc(1, sizeof(*k11));\n\tk11->provider = provider;\n\tprovider->refcount++;\t/* provider referenced by RSA key */\n\tk11->slotidx = slotidx;\n\t/* identify key object on smartcard */\n\tk11->keyid_len = keyid_attrib->ulValueLen;\n\tif (k11->keyid_len > 0) {\n\t\tk11->keyid = xmalloc(k11->keyid_len);\n\t\tmemcpy(k11->keyid, keyid_attrib->pValue, k11->keyid_len);\n\t}\n\n\tRSA_set_method(rsa, rsa_method);\n\tRSA_set_ex_data(rsa, rsa_idx, k11);\n\treturn (0);\n}\n\n#ifdef HAVE_EC_KEY_METHOD_NEW\n/* openssl callback doing the actual signing operation */\nstatic ECDSA_SIG *\necdsa_do_sign(const unsigned char *dgst, int dgst_len, const BIGNUM *inv,\n    const BIGNUM *rp, EC_KEY *ec)\n{\n\tstruct pkcs11_key\t*k11;\n\tstruct pkcs11_slotinfo\t*si;\n\tCK_FUNCTION_LIST\t*f;\n\tCK_ULONG\t\tsiglen = 0, bnlen;\n\tCK_RV\t\t\trv;\n\tECDSA_SIG\t\t*ret = NULL;\n\tu_char\t\t\t*sig;\n\tBIGNUM\t\t\t*r = NULL, *s = NULL;\n\n\tif ((k11 = EC_KEY_get_ex_data(ec, ec_key_idx)) == NULL) {\n\t\tossl_error(\"EC_KEY_get_key_method_data failed for ec\");\n\t\treturn (NULL);\n\t}\n\n\tif (pkcs11_get_key(k11, CKM_ECDSA) == -1) {\n\t\terror(\"pkcs11_get_key failed\");\n\t\treturn (NULL);\n\t}\n\n\tf = k11->provider->function_list;\n\tsi = &k11->provider->slotinfo[k11->slotidx];\n\n\tsiglen = ECDSA_size(ec);\n\tsig = xmalloc(siglen);\n\n\t/* XXX handle CKR_BUFFER_TOO_SMALL */\n\trv = f->C_Sign(si->session, (CK_BYTE *)dgst, dgst_len, sig, &siglen);\n\tif (rv != CKR_OK) {\n\t\terror(\"C_Sign failed: %lu\", rv);\n\t\tgoto done;\n\t}\n\tif (siglen < 64 || siglen > 132 || siglen % 2) {\n\t\tossl_error(\"d2i_ECDSA_SIG failed\");\n\t\tgoto done;\n\t}\n\tbnlen = siglen/2;\n\tif ((ret = ECDSA_SIG_new()) == NULL) {\n\t\terror(\"ECDSA_SIG_new failed\");\n\t\tgoto done;\n\t}\n\tif ((r = BN_bin2bn(sig, bnlen, NULL)) == NULL ||\n\t    (s = BN_bin2bn(sig+bnlen, bnlen, NULL)) == NULL) {\n\t\tossl_error(\"d2i_ECDSA_SIG failed\");\n\t\tECDSA_SIG_free(ret);\n\t\tret = NULL;\n\t\tgoto done;\n\t}\n\tif (!ECDSA_SIG_set0(ret, r, s)) {\n\t\terror(\"%s: ECDSA_SIG_set0 failed\", __func__);\n\t\tECDSA_SIG_free(ret);\n\t\tret = NULL;\n\t\tgoto done;\n\t}\n\tr = s = NULL; /* now owned by ret */\n\t/* success */\n done:\n\tBN_free(r);\n\tBN_free(s);\n\tfree(sig);\n\n\treturn (ret);\n}\n\nstatic int\npkcs11_ecdsa_start_wrapper(void)\n{\n\tint (*orig_sign)(int, const unsigned char *, int, unsigned char *,\n\t    unsigned int *, const BIGNUM *, const BIGNUM *, EC_KEY *) = NULL;\n\n\tif (ec_key_method != NULL)\n\t\treturn (0);\n\tec_key_idx = EC_KEY_get_ex_new_index(0, \"ssh-pkcs11-ecdsa\",\n\t    NULL, NULL, pkcs11_k11_free);\n\tif (ec_key_idx == -1)\n\t\treturn (-1);\n\tec_key_method = EC_KEY_METHOD_new(EC_KEY_OpenSSL());\n\tif (ec_key_method == NULL)\n\t\treturn (-1);\n\tEC_KEY_METHOD_get_sign(ec_key_method, &orig_sign, NULL, NULL);\n\tEC_KEY_METHOD_set_sign(ec_key_method, orig_sign, NULL, ecdsa_do_sign);\n\treturn (0);\n}\n\nstatic int\npkcs11_ecdsa_wrap(struct pkcs11_provider *provider, CK_ULONG slotidx,\n    CK_ATTRIBUTE *keyid_attrib, EC_KEY *ec)\n{\n\tstruct pkcs11_key\t*k11;\n\n\tif (pkcs11_ecdsa_start_wrapper() == -1)\n\t\treturn (-1);\n\n\tk11 = xcalloc(1, sizeof(*k11));\n\tk11->provider = provider;\n\tprovider->refcount++;\t/* provider referenced by ECDSA key */\n\tk11->slotidx = slotidx;\n\t/* identify key object on smartcard */\n\tk11->keyid_len = keyid_attrib->ulValueLen;\n\tk11->keyid = xmalloc(k11->keyid_len);\n\tmemcpy(k11->keyid, keyid_attrib->pValue, k11->keyid_len);\n\n\tEC_KEY_set_method(ec, ec_key_method);\n\tEC_KEY_set_ex_data(ec, ec_key_idx, k11);\n\n\treturn (0);\n}\n#endif /* HAVE_EC_KEY_METHOD_NEW */\n\n/* remove trailing spaces */\nstatic void\nrmspace(u_char *buf, size_t len)\n{\n\tsize_t i;\n\n\tif (!len)\n\t\treturn;\n\tfor (i = len - 1;  i > 0; i--)\n\t\tif (i == len - 1 || buf[i] == ' ')\n\t\t\tbuf[i] = '\\0';\n\t\telse\n\t\t\tbreak;\n}\n\n/*\n * open a pkcs11 session and login if required.\n * if pin == NULL we delay login until key use\n */\nstatic int\npkcs11_open_session(struct pkcs11_provider *p, CK_ULONG slotidx, char *pin,\n    CK_ULONG user)\n{\n\tstruct pkcs11_slotinfo\t*si;\n\tCK_FUNCTION_LIST\t*f;\n\tCK_RV\t\t\trv;\n\tCK_SESSION_HANDLE\tsession;\n\tint\t\t\tlogin_required, ret;\n\n\tf = p->function_list;\n\tsi = &p->slotinfo[slotidx];\n\n\tlogin_required = si->token.flags & CKF_LOGIN_REQUIRED;\n\n\t/* fail early before opening session */\n\tif (login_required && !pkcs11_interactive &&\n\t    (pin == NULL || strlen(pin) == 0)) {\n\t\terror(\"pin required\");\n\t\treturn (-SSH_PKCS11_ERR_PIN_REQUIRED);\n\t}\n\tif ((rv = f->C_OpenSession(p->slotlist[slotidx], CKF_RW_SESSION|\n\t    CKF_SERIAL_SESSION, NULL, NULL, &session)) != CKR_OK) {\n\t\terror(\"C_OpenSession failed: %lu\", rv);\n\t\treturn (-1);\n\t}\n\tif (login_required && pin != NULL && strlen(pin) != 0) {\n\t\trv = f->C_Login(session, user, (u_char *)pin, strlen(pin));\n\t\tif (rv != CKR_OK && rv != CKR_USER_ALREADY_LOGGED_IN) {\n\t\t\terror(\"C_Login failed: %lu\", rv);\n\t\t\tret = (rv == CKR_PIN_LOCKED) ?\n\t\t\t    -SSH_PKCS11_ERR_PIN_LOCKED :\n\t\t\t    -SSH_PKCS11_ERR_LOGIN_FAIL;\n\t\t\tif ((rv = f->C_CloseSession(session)) != CKR_OK)\n\t\t\t\terror(\"C_CloseSession failed: %lu\", rv);\n\t\t\treturn (ret);\n\t\t}\n\t\tsi->logged_in = 1;\n\t}\n\tsi->session = session;\n\treturn (0);\n}\n\nstatic int\npkcs11_key_included(struct sshkey ***keysp, int *nkeys, struct sshkey *key)\n{\n\tint i;\n\n\tfor (i = 0; i < *nkeys; i++)\n\t\tif (sshkey_equal(key, (*keysp)[i]))\n\t\t\treturn (1);\n\treturn (0);\n}\n\n#ifdef HAVE_EC_KEY_METHOD_NEW\nstatic struct sshkey *\npkcs11_fetch_ecdsa_pubkey(struct pkcs11_provider *p, CK_ULONG slotidx,\n    CK_OBJECT_HANDLE *obj)\n{\n\tCK_ATTRIBUTE\t\t key_attr[3];\n\tCK_SESSION_HANDLE\t session;\n\tCK_FUNCTION_LIST\t*f = NULL;\n\tCK_RV\t\t\t rv;\n\tASN1_OCTET_STRING\t*octet = NULL;\n\tEC_KEY\t\t\t*ec = NULL;\n\tEC_GROUP\t\t*group = NULL;\n\tstruct sshkey\t\t*key = NULL;\n\tconst unsigned char\t*attrp = NULL;\n\tint\t\t\t i;\n\tint\t\t\t nid;\n\n\tmemset(&key_attr, 0, sizeof(key_attr));\n\tkey_attr[0].type = CKA_ID;\n\tkey_attr[1].type = CKA_EC_POINT;\n\tkey_attr[2].type = CKA_EC_PARAMS;\n\n\tsession = p->slotinfo[slotidx].session;\n\tf = p->function_list;\n\n\t/* figure out size of the attributes */\n\trv = f->C_GetAttributeValue(session, *obj, key_attr, 3);\n\tif (rv != CKR_OK) {\n\t\terror(\"C_GetAttributeValue failed: %lu\", rv);\n\t\treturn (NULL);\n\t}\n\n\t/*\n\t * Allow CKA_ID (always first attribute) to be empty, but\n\t * ensure that none of the others are zero length.\n\t * XXX assumes CKA_ID is always first.\n\t */\n\tif (key_attr[1].ulValueLen == 0 ||\n\t    key_attr[2].ulValueLen == 0) {\n\t\terror(\"invalid attribute length\");\n\t\treturn (NULL);\n\t}\n\n\t/* allocate buffers for attributes */\n\tfor (i = 0; i < 3; i++)\n\t\tif (key_attr[i].ulValueLen > 0)\n\t\t\tkey_attr[i].pValue = xcalloc(1, key_attr[i].ulValueLen);\n\n\t/* retrieve ID, public point and curve parameters of EC key */\n\trv = f->C_GetAttributeValue(session, *obj, key_attr, 3);\n\tif (rv != CKR_OK) {\n\t\terror(\"C_GetAttributeValue failed: %lu\", rv);\n\t\tgoto fail;\n\t}\n\n\tec = EC_KEY_new();\n\tif (ec == NULL) {\n\t\terror(\"EC_KEY_new failed\");\n\t\tgoto fail;\n\t}\n\n\tattrp = key_attr[2].pValue;\n\tgroup = d2i_ECPKParameters(NULL, &attrp, key_attr[2].ulValueLen);\n\tif (group == NULL) {\n\t\tossl_error(\"d2i_ECPKParameters failed\");\n\t\tgoto fail;\n\t}\n\n\tif (EC_KEY_set_group(ec, group) == 0) {\n\t\tossl_error(\"EC_KEY_set_group failed\");\n\t\tgoto fail;\n\t}\n\n\tif (key_attr[1].ulValueLen <= 2) {\n\t\terror(\"CKA_EC_POINT too small\");\n\t\tgoto fail;\n\t}\n\n\tattrp = key_attr[1].pValue;\n\toctet = d2i_ASN1_OCTET_STRING(NULL, &attrp, key_attr[1].ulValueLen);\n\tif (octet == NULL) {\n\t\tossl_error(\"d2i_ASN1_OCTET_STRING failed\");\n\t\tgoto fail;\n\t}\n\tattrp = octet->data;\n\tif (o2i_ECPublicKey(&ec, &attrp, octet->length) == NULL) {\n\t\tossl_error(\"o2i_ECPublicKey failed\");\n\t\tgoto fail;\n\t}\n\n\tnid = sshkey_ecdsa_key_to_nid(ec);\n\tif (nid < 0) {\n\t\terror(\"couldn't get curve nid\");\n\t\tgoto fail;\n\t}\n\n\tif (pkcs11_ecdsa_wrap(p, slotidx, &key_attr[0], ec))\n\t\tgoto fail;\n\n\tkey = sshkey_new(KEY_UNSPEC);\n\tif (key == NULL) {\n\t\terror(\"sshkey_new failed\");\n\t\tgoto fail;\n\t}\n\n\tkey->ecdsa = ec;\n\tkey->ecdsa_nid = nid;\n\tkey->type = KEY_ECDSA;\n\tkey->flags |= SSHKEY_FLAG_EXT;\n\tec = NULL;\t/* now owned by key */\n\nfail:\n\tfor (i = 0; i < 3; i++)\n\t\tfree(key_attr[i].pValue);\n\tif (ec)\n\t\tEC_KEY_free(ec);\n\tif (group)\n\t\tEC_GROUP_free(group);\n\tif (octet)\n\t\tASN1_OCTET_STRING_free(octet);\n\n\treturn (key);\n}\n#endif /* HAVE_EC_KEY_METHOD_NEW */\n\nstatic struct sshkey *\npkcs11_fetch_rsa_pubkey(struct pkcs11_provider *p, CK_ULONG slotidx,\n    CK_OBJECT_HANDLE *obj)\n{\n\tCK_ATTRIBUTE\t\t key_attr[3];\n\tCK_SESSION_HANDLE\t session;\n\tCK_FUNCTION_LIST\t*f = NULL;\n\tCK_RV\t\t\t rv;\n\tRSA\t\t\t*rsa = NULL;\n\tBIGNUM\t\t\t*rsa_n, *rsa_e;\n\tstruct sshkey\t\t*key = NULL;\n\tint\t\t\t i;\n\n\tmemset(&key_attr, 0, sizeof(key_attr));\n\tkey_attr[0].type = CKA_ID;\n\tkey_attr[1].type = CKA_MODULUS;\n\tkey_attr[2].type = CKA_PUBLIC_EXPONENT;\n\n\tsession = p->slotinfo[slotidx].session;\n\tf = p->function_list;\n\n\t/* figure out size of the attributes */\n\trv = f->C_GetAttributeValue(session, *obj, key_attr, 3);\n\tif (rv != CKR_OK) {\n\t\terror(\"C_GetAttributeValue failed: %lu\", rv);\n\t\treturn (NULL);\n\t}\n\n\t/*\n\t * Allow CKA_ID (always first attribute) to be empty, but\n\t * ensure that none of the others are zero length.\n\t * XXX assumes CKA_ID is always first.\n\t */\n\tif (key_attr[1].ulValueLen == 0 ||\n\t    key_attr[2].ulValueLen == 0) {\n\t\terror(\"invalid attribute length\");\n\t\treturn (NULL);\n\t}\n\n\t/* allocate buffers for attributes */\n\tfor (i = 0; i < 3; i++)\n\t\tif (key_attr[i].ulValueLen > 0)\n\t\t\tkey_attr[i].pValue = xcalloc(1, key_attr[i].ulValueLen);\n\n\t/* retrieve ID, modulus and public exponent of RSA key */\n\trv = f->C_GetAttributeValue(session, *obj, key_attr, 3);\n\tif (rv != CKR_OK) {\n\t\terror(\"C_GetAttributeValue failed: %lu\", rv);\n\t\tgoto fail;\n\t}\n\n\trsa = RSA_new();\n\tif (rsa == NULL) {\n\t\terror(\"RSA_new failed\");\n\t\tgoto fail;\n\t}\n\n\trsa_n = BN_bin2bn(key_attr[1].pValue, key_attr[1].ulValueLen, NULL);\n\trsa_e = BN_bin2bn(key_attr[2].pValue, key_attr[2].ulValueLen, NULL);\n\tif (rsa_n == NULL || rsa_e == NULL) {\n\t\terror(\"BN_bin2bn failed\");\n\t\tgoto fail;\n\t}\n\tif (!RSA_set0_key(rsa, rsa_n, rsa_e, NULL))\n\t\tfatal(\"%s: set key\", __func__);\n\trsa_n = rsa_e = NULL; /* transferred */\n\n\tif (pkcs11_rsa_wrap(p, slotidx, &key_attr[0], rsa))\n\t\tgoto fail;\n\n\tkey = sshkey_new(KEY_UNSPEC);\n\tif (key == NULL) {\n\t\terror(\"sshkey_new failed\");\n\t\tgoto fail;\n\t}\n\n\tkey->rsa = rsa;\n\tkey->type = KEY_RSA;\n\tkey->flags |= SSHKEY_FLAG_EXT;\n\trsa = NULL;\t/* now owned by key */\n\nfail:\n\tfor (i = 0; i < 3; i++)\n\t\tfree(key_attr[i].pValue);\n\tRSA_free(rsa);\n\n\treturn (key);\n}\n\nstatic int\npkcs11_fetch_x509_pubkey(struct pkcs11_provider *p, CK_ULONG slotidx,\n    CK_OBJECT_HANDLE *obj, struct sshkey **keyp, char **labelp)\n{\n\tCK_ATTRIBUTE\t\t cert_attr[3];\n\tCK_SESSION_HANDLE\t session;\n\tCK_FUNCTION_LIST\t*f = NULL;\n\tCK_RV\t\t\t rv;\n\tX509\t\t\t*x509 = NULL;\n\tX509_NAME\t\t*x509_name = NULL;\n\tEVP_PKEY\t\t*evp;\n\tRSA\t\t\t*rsa = NULL;\n#ifdef OPENSSL_HAS_ECC\n\tEC_KEY\t\t\t*ec = NULL;\n#endif\n\tstruct sshkey\t\t*key = NULL;\n\tint\t\t\t i;\n#ifdef HAVE_EC_KEY_METHOD_NEW\n\tint\t\t\t nid;\n#endif\n\tconst u_char\t\t*cp;\n\tchar\t\t\t*subject = NULL;\n\n\t*keyp = NULL;\n\t*labelp = NULL;\n\n\tmemset(&cert_attr, 0, sizeof(cert_attr));\n\tcert_attr[0].type = CKA_ID;\n\tcert_attr[1].type = CKA_SUBJECT;\n\tcert_attr[2].type = CKA_VALUE;\n\n\tsession = p->slotinfo[slotidx].session;\n\tf = p->function_list;\n\n\t/* figure out size of the attributes */\n\trv = f->C_GetAttributeValue(session, *obj, cert_attr, 3);\n\tif (rv != CKR_OK) {\n\t\terror(\"C_GetAttributeValue failed: %lu\", rv);\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Allow CKA_ID (always first attribute) to be empty, but\n\t * ensure that none of the others are zero length.\n\t * XXX assumes CKA_ID is always first.\n\t */\n\tif (cert_attr[1].ulValueLen == 0 ||\n\t    cert_attr[2].ulValueLen == 0) {\n\t\terror(\"invalid attribute length\");\n\t\treturn -1;\n\t}\n\n\t/* allocate buffers for attributes */\n\tfor (i = 0; i < 3; i++)\n\t\tif (cert_attr[i].ulValueLen > 0)\n\t\t\tcert_attr[i].pValue = xcalloc(1, cert_attr[i].ulValueLen);\n\n\t/* retrieve ID, subject and value of certificate */\n\trv = f->C_GetAttributeValue(session, *obj, cert_attr, 3);\n\tif (rv != CKR_OK) {\n\t\terror(\"C_GetAttributeValue failed: %lu\", rv);\n\t\tgoto out;\n\t}\n\n\t/* Decode DER-encoded cert subject */\n\tcp = cert_attr[2].pValue;\n\tif ((x509_name = d2i_X509_NAME(NULL, &cp,\n\t    cert_attr[1].ulValueLen)) == NULL ||\n\t    (subject = X509_NAME_oneline(x509_name, NULL, 0)) == NULL)\n\t\tsubject = xstrdup(\"invalid subject\");\n\tX509_NAME_free(x509_name);\n\n\tcp = cert_attr[2].pValue;\n\tif ((x509 = d2i_X509(NULL, &cp, cert_attr[2].ulValueLen)) == NULL) {\n\t\terror(\"d2i_x509 failed\");\n\t\tgoto out;\n\t}\n\n\tif ((evp = X509_get_pubkey(x509)) == NULL) {\n\t\terror(\"X509_get_pubkey failed\");\n\t\tgoto out;\n\t}\n\n\tif (EVP_PKEY_base_id(evp) == EVP_PKEY_RSA) {\n\t\tif (EVP_PKEY_get0_RSA(evp) == NULL) {\n\t\t\terror(\"invalid x509; no rsa key\");\n\t\t\tgoto out;\n\t\t}\n\t\tif ((rsa = RSAPublicKey_dup(EVP_PKEY_get0_RSA(evp))) == NULL) {\n\t\t\terror(\"RSAPublicKey_dup failed\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (pkcs11_rsa_wrap(p, slotidx, &cert_attr[0], rsa))\n\t\t\tgoto out;\n\n\t\tkey = sshkey_new(KEY_UNSPEC);\n\t\tif (key == NULL) {\n\t\t\terror(\"sshkey_new failed\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tkey->rsa = rsa;\n\t\tkey->type = KEY_RSA;\n\t\tkey->flags |= SSHKEY_FLAG_EXT;\n\t\trsa = NULL;\t/* now owned by key */\n#ifdef HAVE_EC_KEY_METHOD_NEW\n\t} else if (EVP_PKEY_base_id(evp) == EVP_PKEY_EC) {\n\t\tif (EVP_PKEY_get0_EC_KEY(evp) == NULL) {\n\t\t\terror(\"invalid x509; no ec key\");\n\t\t\tgoto out;\n\t\t}\n\t\tif ((ec = EC_KEY_dup(EVP_PKEY_get0_EC_KEY(evp))) == NULL) {\n\t\t\terror(\"EC_KEY_dup failed\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tnid = sshkey_ecdsa_key_to_nid(ec);\n\t\tif (nid < 0) {\n\t\t\terror(\"couldn't get curve nid\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (pkcs11_ecdsa_wrap(p, slotidx, &cert_attr[0], ec))\n\t\t\tgoto out;\n\n\t\tkey = sshkey_new(KEY_UNSPEC);\n\t\tif (key == NULL) {\n\t\t\terror(\"sshkey_new failed\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tkey->ecdsa = ec;\n\t\tkey->ecdsa_nid = nid;\n\t\tkey->type = KEY_ECDSA;\n\t\tkey->flags |= SSHKEY_FLAG_EXT;\n\t\tec = NULL;\t/* now owned by key */\n#endif /* HAVE_EC_KEY_METHOD_NEW */\n\t} else {\n\t\terror(\"unknown certificate key type\");\n\t\tgoto out;\n\t}\n out:\n\tfor (i = 0; i < 3; i++)\n\t\tfree(cert_attr[i].pValue);\n\tX509_free(x509);\n\tRSA_free(rsa);\n#ifdef OPENSSL_HAS_ECC\n\tEC_KEY_free(ec);\n#endif\n\tif (key == NULL) {\n\t\tfree(subject);\n\t\treturn -1;\n\t}\n\t/* success */\n\t*keyp = key;\n\t*labelp = subject;\n\treturn 0;\n}\n\n#if 0\nstatic int\nhave_rsa_key(const RSA *rsa)\n{\n\tconst BIGNUM *rsa_n, *rsa_e;\n\n\tRSA_get0_key(rsa, &rsa_n, &rsa_e, NULL);\n\treturn rsa_n != NULL && rsa_e != NULL;\n}\n#endif\n\n/*\n * lookup certificates for token in slot identified by slotidx,\n * add 'wrapped' public keys to the 'keysp' array and increment nkeys.\n * keysp points to an (possibly empty) array with *nkeys keys.\n */\nstatic int\npkcs11_fetch_certs(struct pkcs11_provider *p, CK_ULONG slotidx,\n    struct sshkey ***keysp, char ***labelsp, int *nkeys)\n{\n\tstruct sshkey\t\t*key = NULL;\n\tCK_OBJECT_CLASS\t\t key_class;\n\tCK_ATTRIBUTE\t\t key_attr[1];\n\tCK_SESSION_HANDLE\t session;\n\tCK_FUNCTION_LIST\t*f = NULL;\n\tCK_RV\t\t\t rv;\n\tCK_OBJECT_HANDLE\t obj;\n\tCK_ULONG\t\t n = 0;\n\tint\t\t\t ret = -1;\n\tchar\t\t\t*label;\n\n\tmemset(&key_attr, 0, sizeof(key_attr));\n\tmemset(&obj, 0, sizeof(obj));\n\n\tkey_class = CKO_CERTIFICATE;\n\tkey_attr[0].type = CKA_CLASS;\n\tkey_attr[0].pValue = &key_class;\n\tkey_attr[0].ulValueLen = sizeof(key_class);\n\n\tsession = p->slotinfo[slotidx].session;\n\tf = p->function_list;\n\n\trv = f->C_FindObjectsInit(session, key_attr, 1);\n\tif (rv != CKR_OK) {\n\t\terror(\"C_FindObjectsInit failed: %lu\", rv);\n\t\tgoto fail;\n\t}\n\n\twhile (1) {\n\t\tCK_CERTIFICATE_TYPE\tck_cert_type;\n\n\t\trv = f->C_FindObjects(session, &obj, 1, &n);\n\t\tif (rv != CKR_OK) {\n\t\t\terror(\"C_FindObjects failed: %lu\", rv);\n\t\t\tgoto fail;\n\t\t}\n\t\tif (n == 0)\n\t\t\tbreak;\n\n\t\tmemset(&ck_cert_type, 0, sizeof(ck_cert_type));\n\t\tmemset(&key_attr, 0, sizeof(key_attr));\n\t\tkey_attr[0].type = CKA_CERTIFICATE_TYPE;\n\t\tkey_attr[0].pValue = &ck_cert_type;\n\t\tkey_attr[0].ulValueLen = sizeof(ck_cert_type);\n\n\t\trv = f->C_GetAttributeValue(session, obj, key_attr, 1);\n\t\tif (rv != CKR_OK) {\n\t\t\terror(\"C_GetAttributeValue failed: %lu\", rv);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tkey = NULL;\n\t\tlabel = NULL;\n\t\tswitch (ck_cert_type) {\n\t\tcase CKC_X_509:\n\t\t\tif (pkcs11_fetch_x509_pubkey(p, slotidx, &obj,\n\t\t\t    &key, &label) != 0) {\n\t\t\t\terror(\"failed to fetch key\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"skipping unsupported certificate type %lu\",\n\t\t\t    ck_cert_type);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pkcs11_key_included(keysp, nkeys, key)) {\n\t\t\tsshkey_free(key);\n\t\t} else {\n\t\t\t/* expand key array and add key */\n\t\t\t*keysp = xrecallocarray(*keysp, *nkeys,\n\t\t\t    *nkeys + 1, sizeof(struct sshkey *));\n\t\t\t(*keysp)[*nkeys] = key;\n\t\t\tif (labelsp != NULL) {\n\t\t\t\t*labelsp = xrecallocarray(*labelsp, *nkeys,\n\t\t\t\t    *nkeys + 1, sizeof(char *));\n\t\t\t\t(*labelsp)[*nkeys] = xstrdup((char *)label);\n\t\t\t}\n\t\t\t*nkeys = *nkeys + 1;\n\t\t\tdebug(\"have %d keys\", *nkeys);\n\t\t}\n\t}\n\n\tret = 0;\nfail:\n\trv = f->C_FindObjectsFinal(session);\n\tif (rv != CKR_OK) {\n\t\terror(\"C_FindObjectsFinal failed: %lu\", rv);\n\t\tret = -1;\n\t}\n\n\treturn (ret);\n}\n\n/*\n * lookup public keys for token in slot identified by slotidx,\n * add 'wrapped' public keys to the 'keysp' array and increment nkeys.\n * keysp points to an (possibly empty) array with *nkeys keys.\n */\nstatic int\npkcs11_fetch_keys(struct pkcs11_provider *p, CK_ULONG slotidx,\n    struct sshkey ***keysp, char ***labelsp, int *nkeys)\n{\n\tstruct sshkey\t\t*key = NULL;\n\tCK_OBJECT_CLASS\t\t key_class;\n\tCK_ATTRIBUTE\t\t key_attr[2];\n\tCK_SESSION_HANDLE\t session;\n\tCK_FUNCTION_LIST\t*f = NULL;\n\tCK_RV\t\t\t rv;\n\tCK_OBJECT_HANDLE\t obj;\n\tCK_ULONG\t\t n = 0;\n\tint\t\t\t ret = -1;\n\n\tmemset(&key_attr, 0, sizeof(key_attr));\n\tmemset(&obj, 0, sizeof(obj));\n\n\tkey_class = CKO_PUBLIC_KEY;\n\tkey_attr[0].type = CKA_CLASS;\n\tkey_attr[0].pValue = &key_class;\n\tkey_attr[0].ulValueLen = sizeof(key_class);\n\n\tsession = p->slotinfo[slotidx].session;\n\tf = p->function_list;\n\n\trv = f->C_FindObjectsInit(session, key_attr, 1);\n\tif (rv != CKR_OK) {\n\t\terror(\"C_FindObjectsInit failed: %lu\", rv);\n\t\tgoto fail;\n\t}\n\n\twhile (1) {\n\t\tCK_KEY_TYPE\tck_key_type;\n\t\tCK_UTF8CHAR\tlabel[256];\n\n\t\trv = f->C_FindObjects(session, &obj, 1, &n);\n\t\tif (rv != CKR_OK) {\n\t\t\terror(\"C_FindObjects failed: %lu\", rv);\n\t\t\tgoto fail;\n\t\t}\n\t\tif (n == 0)\n\t\t\tbreak;\n\n\t\tmemset(&ck_key_type, 0, sizeof(ck_key_type));\n\t\tmemset(&key_attr, 0, sizeof(key_attr));\n\t\tkey_attr[0].type = CKA_KEY_TYPE;\n\t\tkey_attr[0].pValue = &ck_key_type;\n\t\tkey_attr[0].ulValueLen = sizeof(ck_key_type);\n\t\tkey_attr[1].type = CKA_LABEL;\n\t\tkey_attr[1].pValue = &label;\n\t\tkey_attr[1].ulValueLen = sizeof(label) - 1;\n\n\t\trv = f->C_GetAttributeValue(session, obj, key_attr, 2);\n\t\tif (rv != CKR_OK) {\n\t\t\terror(\"C_GetAttributeValue failed: %lu\", rv);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tlabel[key_attr[1].ulValueLen] = '\\0';\n\n\t\tswitch (ck_key_type) {\n\t\tcase CKK_RSA:\n\t\t\tkey = pkcs11_fetch_rsa_pubkey(p, slotidx, &obj);\n\t\t\tbreak;\n#ifdef HAVE_EC_KEY_METHOD_NEW\n\t\tcase CKK_ECDSA:\n\t\t\tkey = pkcs11_fetch_ecdsa_pubkey(p, slotidx, &obj);\n\t\t\tbreak;\n#endif /* HAVE_EC_KEY_METHOD_NEW */\n\t\tdefault:\n\t\t\t/* XXX print key type? */\n\t\t\tkey = NULL;\n\t\t\terror(\"skipping unsupported key type\");\n\t\t}\n\n\t\tif (key == NULL) {\n\t\t\terror(\"failed to fetch key\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pkcs11_key_included(keysp, nkeys, key)) {\n\t\t\tsshkey_free(key);\n\t\t} else {\n\t\t\t/* expand key array and add key */\n\t\t\t*keysp = xrecallocarray(*keysp, *nkeys,\n\t\t\t    *nkeys + 1, sizeof(struct sshkey *));\n\t\t\t(*keysp)[*nkeys] = key;\n\t\t\tif (labelsp != NULL) {\n\t\t\t\t*labelsp = xrecallocarray(*labelsp, *nkeys,\n\t\t\t\t    *nkeys + 1, sizeof(char *));\n\t\t\t\t(*labelsp)[*nkeys] = xstrdup((char *)label);\n\t\t\t}\n\t\t\t*nkeys = *nkeys + 1;\n\t\t\tdebug(\"have %d keys\", *nkeys);\n\t\t}\n\t}\n\n\tret = 0;\nfail:\n\trv = f->C_FindObjectsFinal(session);\n\tif (rv != CKR_OK) {\n\t\terror(\"C_FindObjectsFinal failed: %lu\", rv);\n\t\tret = -1;\n\t}\n\n\treturn (ret);\n}\n\n#ifdef WITH_PKCS11_KEYGEN\n#define FILL_ATTR(attr, idx, typ, val, len) \\\n\t{ (attr[idx]).type=(typ); (attr[idx]).pValue=(val); (attr[idx]).ulValueLen=len; idx++; }\n\nstatic struct sshkey *\npkcs11_rsa_generate_private_key(struct pkcs11_provider *p, CK_ULONG slotidx,\n    char *label, CK_ULONG bits, CK_BYTE keyid, u_int32_t *err)\n{\n\tstruct pkcs11_slotinfo\t*si;\n\tchar\t\t\t*plabel = label ? label : \"\";\n\tint\t\t\t npub = 0, npriv = 0;\n\tCK_RV\t\t\t rv;\n\tCK_FUNCTION_LIST\t*f;\n\tCK_SESSION_HANDLE\t session;\n\tCK_BBOOL\t\t true_val = CK_TRUE, false_val = CK_FALSE;\n\tCK_OBJECT_HANDLE\t pubKey, privKey;\n\tCK_ATTRIBUTE\t\t tpub[16], tpriv[16];\n\tCK_MECHANISM\t\t mech = {\n\t    CKM_RSA_PKCS_KEY_PAIR_GEN, NULL_PTR, 0\n\t};\n\tCK_BYTE\t\t\t pubExponent[] = {\n\t    0x01, 0x00, 0x01 /* RSA_F4 in bytes */\n\t};\n\tpubkey_filter[0].pValue = &pubkey_class;\n\tcert_filter[0].pValue = &cert_class;\n\n\t*err = 0;\n\n\tFILL_ATTR(tpub, npub, CKA_TOKEN, &true_val, sizeof(true_val));\n\tFILL_ATTR(tpub, npub, CKA_LABEL, plabel, strlen(plabel));\n\tFILL_ATTR(tpub, npub, CKA_ENCRYPT, &false_val, sizeof(false_val));\n\tFILL_ATTR(tpub, npub, CKA_VERIFY, &true_val, sizeof(true_val));\n\tFILL_ATTR(tpub, npub, CKA_VERIFY_RECOVER, &false_val,\n\t    sizeof(false_val));\n\tFILL_ATTR(tpub, npub, CKA_WRAP, &false_val, sizeof(false_val));\n\tFILL_ATTR(tpub, npub, CKA_DERIVE, &false_val, sizeof(false_val));\n\tFILL_ATTR(tpub, npub, CKA_MODULUS_BITS, &bits, sizeof(bits));\n\tFILL_ATTR(tpub, npub, CKA_PUBLIC_EXPONENT, pubExponent,\n\t    sizeof(pubExponent));\n\tFILL_ATTR(tpub, npub, CKA_ID, &keyid, sizeof(keyid));\n\n\tFILL_ATTR(tpriv, npriv, CKA_TOKEN,  &true_val, sizeof(true_val));\n\tFILL_ATTR(tpriv, npriv, CKA_LABEL,  plabel, strlen(plabel));\n\tFILL_ATTR(tpriv, npriv, CKA_PRIVATE,  &true_val, sizeof(true_val));\n\tFILL_ATTR(tpriv, npriv, CKA_SENSITIVE,  &true_val, sizeof(true_val));\n\tFILL_ATTR(tpriv, npriv, CKA_DECRYPT,  &false_val, sizeof(false_val));\n\tFILL_ATTR(tpriv, npriv, CKA_SIGN,  &true_val, sizeof(true_val));\n\tFILL_ATTR(tpriv, npriv, CKA_SIGN_RECOVER,  &false_val,\n\t    sizeof(false_val));\n\tFILL_ATTR(tpriv, npriv, CKA_UNWRAP,  &false_val, sizeof(false_val));\n\tFILL_ATTR(tpriv, npriv, CKA_DERIVE,  &false_val, sizeof(false_val));\n\tFILL_ATTR(tpriv, npriv, CKA_ID, &keyid, sizeof(keyid));\n\n\tf = p->function_list;\n\tsi = &p->slotinfo[slotidx];\n\tsession = si->session;\n\n\tif ((rv = f->C_GenerateKeyPair(session, &mech, tpub, npub, tpriv, npriv,\n\t    &pubKey, &privKey)) != CKR_OK) {\n\t\terror(\"%s: key generation failed: error 0x%lx\", __func__, rv);\n\t\t*err = rv;\n\t\treturn NULL;\n\t}\n\n\treturn pkcs11_fetch_rsa_pubkey(p, slotidx, &pubKey);\n}\n\nstatic int\npkcs11_decode_hex(const char *hex, unsigned char **dest, size_t *rlen)\n{\n\tsize_t\ti, len;\n\tchar\tptr[3];\n\n\tif (dest)\n\t\t*dest = NULL;\n\tif (rlen)\n\t\t*rlen = 0;\n\n\tif ((len = strlen(hex)) % 2)\n\t\treturn -1;\n\tlen /= 2;\n\n\t*dest = xmalloc(len);\n\n\tptr[2] = '\\0';\n\tfor (i = 0; i < len; i++) {\n\t\tptr[0] = hex[2 * i];\n\t\tptr[1] = hex[(2 * i) + 1];\n\t\tif (!isxdigit(ptr[0]) || !isxdigit(ptr[1]))\n\t\t\treturn -1;\n\t\t(*dest)[i] = (unsigned char)strtoul(ptr, NULL, 16);\n\t}\n\n\tif (rlen)\n\t\t*rlen = len;\n\n\treturn 0;\n}\n\nstatic struct ec_curve_info {\n\tconst char\t*name;\n\tconst char\t*oid;\n\tconst char\t*oid_encoded;\n\tsize_t\t\t size;\n} ec_curve_infos[] = {\n\t{\"prime256v1\",\t\"1.2.840.10045.3.1.7\",\t\"06082A8648CE3D030107\", 256},\n\t{\"secp384r1\",\t\"1.3.132.0.34\",\t\t\"06052B81040022\",\t384},\n\t{\"secp521r1\",\t\"1.3.132.0.35\",\t\t\"06052B81040023\",\t521},\n\t{NULL,\t\tNULL,\t\t\tNULL,\t\t\t0},\n};\n\nstatic struct sshkey *\npkcs11_ecdsa_generate_private_key(struct pkcs11_provider *p, CK_ULONG slotidx,\n    char *label, CK_ULONG bits, CK_BYTE keyid, u_int32_t *err)\n{\n\tstruct pkcs11_slotinfo\t*si;\n\tchar\t\t\t*plabel = label ? label : \"\";\n\tint\t\t\t i;\n\tsize_t\t\t\t ecparams_size;\n\tunsigned char\t\t*ecparams = NULL;\n\tint\t\t\t npub = 0, npriv = 0;\n\tCK_RV\t\t\t rv;\n\tCK_FUNCTION_LIST\t*f;\n\tCK_SESSION_HANDLE\t session;\n\tCK_BBOOL\t\t true_val = CK_TRUE, false_val = CK_FALSE;\n\tCK_OBJECT_HANDLE\t pubKey, privKey;\n\tCK_MECHANISM\t\t mech = {\n\t    CKM_EC_KEY_PAIR_GEN, NULL_PTR, 0\n\t};\n\tCK_ATTRIBUTE\t\t tpub[16], tpriv[16];\n\n\t*err = 0;\n\n\tfor (i = 0; ec_curve_infos[i].name; i++) {\n\t\tif (ec_curve_infos[i].size == bits)\n\t\t\tbreak;\n\t}\n\tif (!ec_curve_infos[i].name) {\n\t\terror(\"%s: invalid key size %lu\", __func__, bits);\n\t\treturn NULL;\n\t}\n\tif (pkcs11_decode_hex(ec_curve_infos[i].oid_encoded, &ecparams,\n\t    &ecparams_size) == -1) {\n\t\terror(\"%s: invalid oid\", __func__);\n\t\treturn NULL;\n\t}\n\n\tFILL_ATTR(tpub, npub, CKA_TOKEN, &true_val, sizeof(true_val));\n\tFILL_ATTR(tpub, npub, CKA_LABEL, plabel, strlen(plabel));\n\tFILL_ATTR(tpub, npub, CKA_ENCRYPT, &false_val, sizeof(false_val));\n\tFILL_ATTR(tpub, npub, CKA_VERIFY, &true_val, sizeof(true_val));\n\tFILL_ATTR(tpub, npub, CKA_VERIFY_RECOVER, &false_val,\n\t    sizeof(false_val));\n\tFILL_ATTR(tpub, npub, CKA_WRAP, &false_val, sizeof(false_val));\n\tFILL_ATTR(tpub, npub, CKA_DERIVE, &false_val, sizeof(false_val));\n\tFILL_ATTR(tpub, npub, CKA_EC_PARAMS, ecparams, ecparams_size);\n\tFILL_ATTR(tpub, npub, CKA_ID, &keyid, sizeof(keyid));\n\n\tFILL_ATTR(tpriv, npriv, CKA_TOKEN, &true_val, sizeof(true_val));\n\tFILL_ATTR(tpriv, npriv, CKA_LABEL, plabel, strlen(plabel));\n\tFILL_ATTR(tpriv, npriv, CKA_PRIVATE, &true_val, sizeof(true_val));\n\tFILL_ATTR(tpriv, npriv, CKA_SENSITIVE, &true_val, sizeof(true_val));\n\tFILL_ATTR(tpriv, npriv, CKA_DECRYPT, &false_val, sizeof(false_val));\n\tFILL_ATTR(tpriv, npriv, CKA_SIGN, &true_val, sizeof(true_val));\n\tFILL_ATTR(tpriv, npriv, CKA_SIGN_RECOVER, &false_val,\n\t    sizeof(false_val));\n\tFILL_ATTR(tpriv, npriv, CKA_UNWRAP, &false_val, sizeof(false_val));\n\tFILL_ATTR(tpriv, npriv, CKA_DERIVE, &false_val, sizeof(false_val));\n\tFILL_ATTR(tpriv, npriv, CKA_ID, &keyid, sizeof(keyid));\n\n\tf = p->function_list;\n\tsi = &p->slotinfo[slotidx];\n\tsession = si->session;\n\n\tif ((rv = f->C_GenerateKeyPair(session, &mech, tpub, npub, tpriv, npriv,\n\t    &pubKey, &privKey)) != CKR_OK) {\n\t\terror(\"%s: key generation failed: error 0x%lx\", __func__, rv);\n\t\t*err = rv;\n\t\treturn NULL;\n\t}\n\n\treturn pkcs11_fetch_ecdsa_pubkey(p, slotidx, &pubKey);\n}\n#endif /* WITH_PKCS11_KEYGEN */\n\n/*\n * register a new provider, fails if provider already exists. if\n * keyp is provided, fetch keys.\n */\nstatic int\npkcs11_register_provider(char *provider_id, char *pin,\n    struct sshkey ***keyp, char ***labelsp,\n    struct pkcs11_provider **providerp, CK_ULONG user)\n{\n\tint nkeys, need_finalize = 0;\n\tint ret = -1;\n\tstruct pkcs11_provider *p = NULL;\n\tvoid *handle = NULL;\n\tCK_RV (*getfunctionlist)(CK_FUNCTION_LIST **);\n\tCK_RV rv;\n\tCK_FUNCTION_LIST *f = NULL;\n\tCK_TOKEN_INFO *token;\n\tCK_ULONG i;\n\n\tif (providerp == NULL)\n\t\tgoto fail;\n\t*providerp = NULL;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (labelsp != NULL)\n\t\t*labelsp = NULL;\n\n\tif (pkcs11_provider_lookup(provider_id) != NULL) {\n\t\tdebug(\"%s: provider already registered: %s\",\n\t\t    __func__, provider_id);\n\t\tgoto fail;\n\t}\n\t/* open shared pkcs11-library */\n\tif ((handle = dlopen(provider_id, RTLD_NOW)) == NULL) {\n\t\terror(\"dlopen %s failed: %s\", provider_id, dlerror());\n\t\tgoto fail;\n\t}\n\tif ((getfunctionlist = dlsym(handle, \"C_GetFunctionList\")) == NULL) {\n\t\terror(\"dlsym(C_GetFunctionList) failed: %s\", dlerror());\n\t\tgoto fail;\n\t}\n\tp = xcalloc(1, sizeof(*p));\n\tp->name = xstrdup(provider_id);\n\tp->handle = handle;\n\t/* setup the pkcs11 callbacks */\n\tif ((rv = (*getfunctionlist)(&f)) != CKR_OK) {\n\t\terror(\"C_GetFunctionList for provider %s failed: %lu\",\n\t\t    provider_id, rv);\n\t\tgoto fail;\n\t}\n\tp->function_list = f;\n\tif ((rv = f->C_Initialize(NULL)) != CKR_OK) {\n\t\terror(\"C_Initialize for provider %s failed: %lu\",\n\t\t    provider_id, rv);\n\t\tgoto fail;\n\t}\n\tneed_finalize = 1;\n\tif ((rv = f->C_GetInfo(&p->info)) != CKR_OK) {\n\t\terror(\"C_GetInfo for provider %s failed: %lu\",\n\t\t    provider_id, rv);\n\t\tgoto fail;\n\t}\n\trmspace(p->info.manufacturerID, sizeof(p->info.manufacturerID));\n\trmspace(p->info.libraryDescription, sizeof(p->info.libraryDescription));\n\tdebug(\"provider %s: manufacturerID <%s> cryptokiVersion %d.%d\"\n\t    \" libraryDescription <%s> libraryVersion %d.%d\",\n\t    provider_id,\n\t    p->info.manufacturerID,\n\t    p->info.cryptokiVersion.major,\n\t    p->info.cryptokiVersion.minor,\n\t    p->info.libraryDescription,\n\t    p->info.libraryVersion.major,\n\t    p->info.libraryVersion.minor);\n\tif ((rv = f->C_GetSlotList(CK_TRUE, NULL, &p->nslots)) != CKR_OK) {\n\t\terror(\"C_GetSlotList failed: %lu\", rv);\n\t\tgoto fail;\n\t}\n\tif (p->nslots == 0) {\n\t\tdebug(\"%s: provider %s returned no slots\", __func__,\n\t\t    provider_id);\n\t\tret = -SSH_PKCS11_ERR_NO_SLOTS;\n\t\tgoto fail;\n\t}\n\tp->slotlist = xcalloc(p->nslots, sizeof(CK_SLOT_ID));\n\tif ((rv = f->C_GetSlotList(CK_TRUE, p->slotlist, &p->nslots))\n\t    != CKR_OK) {\n\t\terror(\"C_GetSlotList for provider %s failed: %lu\",\n\t\t    provider_id, rv);\n\t\tgoto fail;\n\t}\n\tp->slotinfo = xcalloc(p->nslots, sizeof(struct pkcs11_slotinfo));\n\tp->valid = 1;\n\tnkeys = 0;\n\tfor (i = 0; i < p->nslots; i++) {\n\t\ttoken = &p->slotinfo[i].token;\n\t\tif ((rv = f->C_GetTokenInfo(p->slotlist[i], token))\n\t\t    != CKR_OK) {\n\t\t\terror(\"C_GetTokenInfo for provider %s slot %lu \"\n\t\t\t    \"failed: %lu\", provider_id, (unsigned long)i, rv);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((token->flags & CKF_TOKEN_INITIALIZED) == 0) {\n\t\t\tdebug2(\"%s: ignoring uninitialised token in \"\n\t\t\t    \"provider %s slot %lu\", __func__,\n\t\t\t    provider_id, (unsigned long)i);\n\t\t\tcontinue;\n\t\t}\n\t\trmspace(token->label, sizeof(token->label));\n\t\trmspace(token->manufacturerID, sizeof(token->manufacturerID));\n\t\trmspace(token->model, sizeof(token->model));\n\t\trmspace(token->serialNumber, sizeof(token->serialNumber));\n\t\tdebug(\"provider %s slot %lu: label <%s> manufacturerID <%s> \"\n\t\t    \"model <%s> serial <%s> flags 0x%lx\",\n\t\t    provider_id, (unsigned long)i,\n\t\t    token->label, token->manufacturerID, token->model,\n\t\t    token->serialNumber, token->flags);\n\t\t/*\n\t\t * open session, login with pin and retrieve public\n\t\t * keys (if keyp is provided)\n\t\t */\n\t\tif ((ret = pkcs11_open_session(p, i, pin, user)) != 0 ||\n\t\t    keyp == NULL)\n\t\t\tcontinue;\n\t\tpkcs11_fetch_keys(p, i, keyp, labelsp, &nkeys);\n\t\tpkcs11_fetch_certs(p, i, keyp, labelsp, &nkeys);\n\t\tif (nkeys == 0 && !p->slotinfo[i].logged_in &&\n\t\t    pkcs11_interactive) {\n\t\t\t/*\n\t\t\t * Some tokens require login before they will\n\t\t\t * expose keys.\n\t\t\t */\n\t\t\tif (pkcs11_login_slot(p, &p->slotinfo[i],\n\t\t\t    CKU_USER) < 0) {\n\t\t\t\terror(\"login failed\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tpkcs11_fetch_keys(p, i, keyp, labelsp, &nkeys);\n\t\t\tpkcs11_fetch_certs(p, i, keyp, labelsp, &nkeys);\n\t\t}\n\t}\n\n\t/* now owned by caller */\n\t*providerp = p;\n\n\tTAILQ_INSERT_TAIL(&pkcs11_providers, p, next);\n\tp->refcount++;\t/* add to provider list */\n\n\treturn (nkeys);\nfail:\n\tif (need_finalize && (rv = f->C_Finalize(NULL)) != CKR_OK)\n\t\terror(\"C_Finalize for provider %s failed: %lu\",\n\t\t    provider_id, rv);\n\tif (p) {\n\t\tfree(p->name);\n\t\tfree(p->slotlist);\n\t\tfree(p->slotinfo);\n\t\tfree(p);\n\t}\n\tif (handle)\n\t\tdlclose(handle);\n\tif (ret > 0)\n\t\tret = -1;\n\treturn (ret);\n}\n\n/*\n * register a new provider and get number of keys hold by the token,\n * fails if provider already exists\n */\nint\npkcs11_add_provider(char *provider_id, char *pin, struct sshkey ***keyp,\n    char ***labelsp)\n{\n\tstruct pkcs11_provider *p = NULL;\n\tint nkeys;\n\n\tnkeys = pkcs11_register_provider(provider_id, pin, keyp, labelsp,\n\t    &p, CKU_USER);\n\n\t/* no keys found or some other error, de-register provider */\n\tif (nkeys <= 0 && p != NULL) {\n\t\tTAILQ_REMOVE(&pkcs11_providers, p, next);\n\t\tpkcs11_provider_finalize(p);\n\t\tpkcs11_provider_unref(p);\n\t}\n\tif (nkeys == 0)\n\t\tdebug(\"%s: provider %s returned no keys\", __func__,\n\t\t    provider_id);\n\n\treturn (nkeys);\n}\n\n#ifdef WITH_PKCS11_KEYGEN\nstruct sshkey *\npkcs11_gakp(char *provider_id, char *pin, unsigned int slotidx, char *label,\n    unsigned int type, unsigned int bits, unsigned char keyid, u_int32_t *err)\n{\n\tstruct pkcs11_provider\t*p = NULL;\n\tstruct pkcs11_slotinfo\t*si;\n\tCK_FUNCTION_LIST\t*f;\n\tCK_SESSION_HANDLE\t session;\n\tstruct sshkey\t\t*k = NULL;\n\tint\t\t\t ret = -1, reset_pin = 0, reset_provider = 0;\n\tCK_RV\t\t\t rv;\n\n\t*err = 0;\n\n\tif ((p = pkcs11_provider_lookup(provider_id)) != NULL)\n\t\tdebug(\"%s: provider \\\"%s\\\" available\", __func__, provider_id);\n\telse if ((ret = pkcs11_register_provider(provider_id, pin, NULL, NULL,\n\t    &p, CKU_SO)) < 0) {\n\t\tdebug(\"%s: could not register provider %s\", __func__,\n\t\t    provider_id);\n\t\tgoto out;\n\t} else\n\t\treset_provider = 1;\n\n\tf = p->function_list;\n\tsi = &p->slotinfo[slotidx];\n\tsession = si->session;\n\n\tif ((rv = f->C_SetOperationState(session , pin, strlen(pin),\n\t    CK_INVALID_HANDLE, CK_INVALID_HANDLE)) != CKR_OK) {\n\t\tdebug(\"%s: could not supply SO pin: %lu\", __func__, rv);\n\t\treset_pin = 0;\n\t} else\n\t\treset_pin = 1;\n\n\tswitch (type) {\n\tcase KEY_RSA:\n\t\tif ((k = pkcs11_rsa_generate_private_key(p, slotidx, label,\n\t\t    bits, keyid, err)) == NULL) {\n\t\t\tdebug(\"%s: failed to generate RSA key\", __func__);\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase KEY_ECDSA:\n\t\tif ((k = pkcs11_ecdsa_generate_private_key(p, slotidx, label,\n\t\t    bits, keyid, err)) == NULL) {\n\t\t\tdebug(\"%s: failed to generate ECDSA key\", __func__);\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t*err = SSH_PKCS11_ERR_GENERIC;\n\t\tdebug(\"%s: unknown type %d\", __func__, type);\n\t\tgoto out;\n\t}\n\nout:\n\tif (reset_pin)\n\t\tf->C_SetOperationState(session , NULL, 0, CK_INVALID_HANDLE,\n\t\t    CK_INVALID_HANDLE);\n\n\tif (reset_provider)\n\t\tpkcs11_del_provider(provider_id);\n\n\treturn (k);\n}\n\nstruct sshkey *\npkcs11_destroy_keypair(char *provider_id, char *pin, unsigned long slotidx,\n    unsigned char keyid, u_int32_t *err)\n{\n\tstruct pkcs11_provider\t*p = NULL;\n\tstruct pkcs11_slotinfo\t*si;\n\tstruct sshkey\t\t*k = NULL;\n\tint\t\t\t reset_pin = 0, reset_provider = 0;\n\tCK_ULONG\t\t nattrs;\n\tCK_FUNCTION_LIST\t*f;\n\tCK_SESSION_HANDLE\t session;\n\tCK_ATTRIBUTE\t\t attrs[16];\n\tCK_OBJECT_CLASS\t\t key_class;\n\tCK_KEY_TYPE\t\t key_type;\n\tCK_OBJECT_HANDLE\t obj = CK_INVALID_HANDLE;\n\tCK_RV\t\t\t rv;\n\n\t*err = 0;\n\n\tif ((p = pkcs11_provider_lookup(provider_id)) != NULL) {\n\t\tdebug(\"%s: using provider \\\"%s\\\"\", __func__, provider_id);\n\t} else if (pkcs11_register_provider(provider_id, pin, NULL, NULL, &p,\n\t    CKU_SO) < 0) {\n\t\tdebug(\"%s: could not register provider %s\", __func__,\n\t\t    provider_id);\n\t\tgoto out;\n\t} else\n\t\treset_provider = 1;\n\n\tf = p->function_list;\n\tsi = &p->slotinfo[slotidx];\n\tsession = si->session;\n\n\tif ((rv = f->C_SetOperationState(session , pin, strlen(pin),\n\t    CK_INVALID_HANDLE, CK_INVALID_HANDLE)) != CKR_OK) {\n\t\tdebug(\"%s: could not supply SO pin: %lu\", __func__, rv);\n\t\treset_pin = 0;\n\t} else\n\t\treset_pin = 1;\n\n\t/* private key */\n\tnattrs = 0;\n\tkey_class = CKO_PRIVATE_KEY;\n\tFILL_ATTR(attrs, nattrs, CKA_CLASS, &key_class, sizeof(key_class));\n\tFILL_ATTR(attrs, nattrs, CKA_ID, &keyid, sizeof(keyid));\n\n\tif (pkcs11_find(p, slotidx, attrs, nattrs, &obj) == 0 &&\n\t    obj != CK_INVALID_HANDLE) {\n\t\tif ((rv = f->C_DestroyObject(session, obj)) != CKR_OK) {\n\t\t\tdebug(\"%s: could not destroy private key 0x%hhx\",\n\t\t\t    __func__, keyid);\n\t\t\t*err = rv;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* public key */\n\tnattrs = 0;\n\tkey_class = CKO_PUBLIC_KEY;\n\tFILL_ATTR(attrs, nattrs, CKA_CLASS, &key_class, sizeof(key_class));\n\tFILL_ATTR(attrs, nattrs, CKA_ID, &keyid, sizeof(keyid));\n\n\tif (pkcs11_find(p, slotidx, attrs, nattrs, &obj) == 0 &&\n\t    obj != CK_INVALID_HANDLE) {\n\n\t\t/* get key type */\n\t\tnattrs = 0;\n\t\tFILL_ATTR(attrs, nattrs, CKA_KEY_TYPE, &key_type,\n\t\t    sizeof(key_type));\n\t\trv = f->C_GetAttributeValue(session, obj, attrs, nattrs);\n\t\tif (rv != CKR_OK) {\n\t\t\tdebug(\"%s: could not get key type of public key 0x%hhx\",\n\t\t\t    __func__, keyid);\n\t\t\t*err = rv;\n\t\t\tkey_type = -1;\n\t\t}\n\t\tif (key_type == CKK_RSA)\n\t\t\tk = pkcs11_fetch_rsa_pubkey(p, slotidx, &obj);\n\t\telse if (key_type == CKK_ECDSA)\n\t\t\tk = pkcs11_fetch_ecdsa_pubkey(p, slotidx, &obj);\n\n\t\tif ((rv = f->C_DestroyObject(session, obj)) != CKR_OK) {\n\t\t\tdebug(\"%s: could not destroy public key 0x%hhx\",\n\t\t\t    __func__, keyid);\n\t\t\t*err = rv;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tif (reset_pin)\n\t\tf->C_SetOperationState(session , NULL, 0, CK_INVALID_HANDLE,\n\t\t    CK_INVALID_HANDLE);\n\n\tif (reset_provider)\n\t\tpkcs11_del_provider(provider_id);\n\n\treturn (k);\n}\n#endif /* WITH_PKCS11_KEYGEN */\n#else /* ENABLE_PKCS11 */\n\n#include <sys/types.h>\n#include <stdarg.h>\n#include <stdio.h>\n\n#include \"log.h\"\n#include \"sshkey.h\"\n\nint\npkcs11_init(int interactive)\n{\n\terror(\"%s: dlopen() not supported\", __func__);\n\treturn (-1);\n}\n\nint\npkcs11_add_provider(char *provider_id, char *pin, struct sshkey ***keyp,\n    char ***labelsp)\n{\n\terror(\"%s: dlopen() not supported\", __func__);\n\treturn (-1);\n}\n\nvoid\npkcs11_terminate(void)\n{\n\terror(\"%s: dlopen() not supported\", __func__);\n}\n#endif /* ENABLE_PKCS11 */\n",
        "/tmp/vanessa/spack-stage/spack-stage-openssh-8.4p1-gs222i4ctitv7fl27wgnurjoqoks3e7r/spack-src/ssh-sk.c": "/* $OpenBSD: ssh-sk.c,v 1.32 2020/09/09 03:08:02 djm Exp $ */\n/*\n * Copyright (c) 2019 Google LLC\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n/* #define DEBUG_SK 1 */\n\n#include \"includes.h\"\n\n#ifdef ENABLE_SK\n\n#include <dlfcn.h>\n#include <stddef.h>\n#ifdef HAVE_STDINT_H\n# include <stdint.h>\n#endif\n#include <string.h>\n#include <stdio.h>\n\n#ifdef WITH_OPENSSL\n#include <openssl/objects.h>\n#include <openssl/ec.h>\n#endif /* WITH_OPENSSL */\n\n#include \"log.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n\n#include \"ssh-sk.h\"\n#include \"sk-api.h\"\n#include \"crypto_api.h\"\n\nstruct sshsk_provider {\n\tchar *path;\n\tvoid *dlhandle;\n\n\t/* Return the version of the middleware API */\n\tuint32_t (*sk_api_version)(void);\n\n\t/* Enroll a U2F key (private key generation) */\n\tint (*sk_enroll)(int alg, const uint8_t *challenge,\n\t    size_t challenge_len, const char *application, uint8_t flags,\n\t    const char *pin, struct sk_option **opts,\n\t    struct sk_enroll_response **enroll_response);\n\n\t/* Sign a challenge */\n\tint (*sk_sign)(int alg, const uint8_t *message, size_t message_len,\n\t    const char *application,\n\t    const uint8_t *key_handle, size_t key_handle_len,\n\t    uint8_t flags, const char *pin, struct sk_option **opts,\n\t    struct sk_sign_response **sign_response);\n\n\t/* Enumerate resident keys */\n\tint (*sk_load_resident_keys)(const char *pin, struct sk_option **opts,\n\t    struct sk_resident_key ***rks, size_t *nrks);\n};\n\n/* Built-in version */\nint ssh_sk_enroll(int alg, const uint8_t *challenge,\n    size_t challenge_len, const char *application, uint8_t flags,\n    const char *pin, struct sk_option **opts,\n    struct sk_enroll_response **enroll_response);\nint ssh_sk_sign(int alg, const uint8_t *message, size_t message_len,\n    const char *application,\n    const uint8_t *key_handle, size_t key_handle_len,\n    uint8_t flags, const char *pin, struct sk_option **opts,\n    struct sk_sign_response **sign_response);\nint ssh_sk_load_resident_keys(const char *pin, struct sk_option **opts,\n    struct sk_resident_key ***rks, size_t *nrks);\n\nstatic void\nsshsk_free(struct sshsk_provider *p)\n{\n\tif (p == NULL)\n\t\treturn;\n\tfree(p->path);\n\tif (p->dlhandle != NULL)\n\t\tdlclose(p->dlhandle);\n\tfree(p);\n}\n\nstatic struct sshsk_provider *\nsshsk_open(const char *path)\n{\n\tstruct sshsk_provider *ret = NULL;\n\tuint32_t version;\n\n\tif (path == NULL || *path == '\\0') {\n\t\terror(\"No FIDO SecurityKeyProvider specified\");\n\t\treturn NULL;\n\t}\n\tif ((ret = calloc(1, sizeof(*ret))) == NULL) {\n\t\terror(\"%s: calloc failed\", __func__);\n\t\treturn NULL;\n\t}\n\tif ((ret->path = strdup(path)) == NULL) {\n\t\terror(\"%s: strdup failed\", __func__);\n\t\tgoto fail;\n\t}\n\t/* Skip the rest if we're using the linked in middleware */\n\tif (strcasecmp(ret->path, \"internal\") == 0) {\n#ifdef ENABLE_SK_INTERNAL\n\t\tret->sk_enroll = ssh_sk_enroll;\n\t\tret->sk_sign = ssh_sk_sign;\n\t\tret->sk_load_resident_keys = ssh_sk_load_resident_keys;\n#else\n\t\terror(\"internal security key support not enabled\");\n#endif\n\t\treturn ret;\n\t}\n\tif ((ret->dlhandle = dlopen(path, RTLD_NOW)) == NULL) {\n\t\terror(\"Provider \\\"%s\\\" dlopen failed: %s\", path, dlerror());\n\t\tgoto fail;\n\t}\n\tif ((ret->sk_api_version = dlsym(ret->dlhandle,\n\t    \"sk_api_version\")) == NULL) {\n\t\terror(\"Provider \\\"%s\\\" dlsym(sk_api_version) failed: %s\",\n\t\t    path, dlerror());\n\t\tgoto fail;\n\t}\n\tversion = ret->sk_api_version();\n\tdebug(\"%s: provider %s implements version 0x%08lx\", __func__,\n\t    ret->path, (u_long)version);\n\tif ((version & SSH_SK_VERSION_MAJOR_MASK) != SSH_SK_VERSION_MAJOR) {\n\t\terror(\"Provider \\\"%s\\\" implements unsupported \"\n\t\t    \"version 0x%08lx (supported: 0x%08lx)\",\n\t\t    path, (u_long)version, (u_long)SSH_SK_VERSION_MAJOR);\n\t\tgoto fail;\n\t}\n\tif ((ret->sk_enroll = dlsym(ret->dlhandle, \"sk_enroll\")) == NULL) {\n\t\terror(\"Provider %s dlsym(sk_enroll) failed: %s\",\n\t\t    path, dlerror());\n\t\tgoto fail;\n\t}\n\tif ((ret->sk_sign = dlsym(ret->dlhandle, \"sk_sign\")) == NULL) {\n\t\terror(\"Provider \\\"%s\\\" dlsym(sk_sign) failed: %s\",\n\t\t    path, dlerror());\n\t\tgoto fail;\n\t}\n\tif ((ret->sk_load_resident_keys = dlsym(ret->dlhandle,\n\t    \"sk_load_resident_keys\")) == NULL) {\n\t\terror(\"Provider \\\"%s\\\" dlsym(sk_load_resident_keys) \"\n\t\t    \"failed: %s\", path, dlerror());\n\t\tgoto fail;\n\t}\n\t/* success */\n\treturn ret;\nfail:\n\tsshsk_free(ret);\n\treturn NULL;\n}\n\nstatic void\nsshsk_free_enroll_response(struct sk_enroll_response *r)\n{\n\tif (r == NULL)\n\t\treturn;\n\tfreezero(r->key_handle, r->key_handle_len);\n\tfreezero(r->public_key, r->public_key_len);\n\tfreezero(r->signature, r->signature_len);\n\tfreezero(r->attestation_cert, r->attestation_cert_len);\n\tfreezero(r->authdata, r->authdata_len);\n\tfreezero(r, sizeof(*r));\n}\n\nstatic void\nsshsk_free_sign_response(struct sk_sign_response *r)\n{\n\tif (r == NULL)\n\t\treturn;\n\tfreezero(r->sig_r, r->sig_r_len);\n\tfreezero(r->sig_s, r->sig_s_len);\n\tfreezero(r, sizeof(*r));\n}\n\n#ifdef WITH_OPENSSL\n/* Assemble key from response */\nstatic int\nsshsk_ecdsa_assemble(struct sk_enroll_response *resp, struct sshkey **keyp)\n{\n\tstruct sshkey *key = NULL;\n\tstruct sshbuf *b = NULL;\n\tEC_POINT *q = NULL;\n\tint r;\n\n\t*keyp = NULL;\n\tif ((key = sshkey_new(KEY_ECDSA_SK)) == NULL) {\n\t\terror(\"%s: sshkey_new failed\", __func__);\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tkey->ecdsa_nid = NID_X9_62_prime256v1;\n\tif ((key->ecdsa = EC_KEY_new_by_curve_name(key->ecdsa_nid)) == NULL ||\n\t    (q = EC_POINT_new(EC_KEY_get0_group(key->ecdsa))) == NULL ||\n\t    (b = sshbuf_new()) == NULL) {\n\t\terror(\"%s: allocation failed\", __func__);\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_put_string(b,\n\t    resp->public_key, resp->public_key_len)) != 0) {\n\t\terror(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_get_ec(b, q, EC_KEY_get0_group(key->ecdsa))) != 0) {\n\t\terror(\"%s: parse key: %s\", __func__, ssh_err(r));\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif (sshkey_ec_validate_public(EC_KEY_get0_group(key->ecdsa), q) != 0) {\n\t\terror(\"Authenticator returned invalid ECDSA key\");\n\t\tr = SSH_ERR_KEY_INVALID_EC_VALUE;\n\t\tgoto out;\n\t}\n\tif (EC_KEY_set_public_key(key->ecdsa, q) != 1) {\n\t\t/* XXX assume it is a allocation error */\n\t\terror(\"%s: allocation failed\", __func__);\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\t/* success */\n\t*keyp = key;\n\tkey = NULL; /* transferred */\n\tr = 0;\n out:\n\tEC_POINT_free(q);\n\tsshkey_free(key);\n\tsshbuf_free(b);\n\treturn r;\n}\n#endif /* WITH_OPENSSL */\n\nstatic int\nsshsk_ed25519_assemble(struct sk_enroll_response *resp, struct sshkey **keyp)\n{\n\tstruct sshkey *key = NULL;\n\tint r;\n\n\t*keyp = NULL;\n\tif (resp->public_key_len != ED25519_PK_SZ) {\n\t\terror(\"%s: invalid size: %zu\", __func__, resp->public_key_len);\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif ((key = sshkey_new(KEY_ED25519_SK)) == NULL) {\n\t\terror(\"%s: sshkey_new failed\", __func__);\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((key->ed25519_pk = malloc(ED25519_PK_SZ)) == NULL) {\n\t\terror(\"%s: malloc failed\", __func__);\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tmemcpy(key->ed25519_pk, resp->public_key, ED25519_PK_SZ);\n\t/* success */\n\t*keyp = key;\n\tkey = NULL; /* transferred */\n\tr = 0;\n out:\n\tsshkey_free(key);\n\treturn r;\n}\n\nstatic int\nsshsk_key_from_response(int alg, const char *application, uint8_t flags,\n    struct sk_enroll_response *resp, struct sshkey **keyp)\n{\n\tstruct sshkey *key = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\t*keyp = NULL;\n\n\t/* Check response validity */\n\tif (resp->public_key == NULL || resp->key_handle == NULL) {\n\t\terror(\"%s: sk_enroll response invalid\", __func__);\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tswitch (alg) {\n#ifdef WITH_OPENSSL\n\tcase SSH_SK_ECDSA:\n\t\tif ((r = sshsk_ecdsa_assemble(resp, &key)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase SSH_SK_ED25519:\n\t\tif ((r = sshsk_ed25519_assemble(resp, &key)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tdefault:\n\t\terror(\"%s: unsupported algorithm %d\", __func__, alg);\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\tkey->sk_flags = flags;\n\tif ((key->sk_key_handle = sshbuf_new()) == NULL ||\n\t    (key->sk_reserved = sshbuf_new()) == NULL) {\n\t\terror(\"%s: allocation failed\", __func__);\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((key->sk_application = strdup(application)) == NULL) {\n\t\terror(\"%s: strdup application failed\", __func__);\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_put(key->sk_key_handle, resp->key_handle,\n\t    resp->key_handle_len)) != 0) {\n\t\terror(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\t/* success */\n\tr = 0;\n\t*keyp = key;\n\tkey = NULL;\n out:\n\tsshkey_free(key);\n\treturn r;\n}\n\nstatic int\nskerr_to_ssherr(int skerr)\n{\n\tswitch (skerr) {\n\tcase SSH_SK_ERR_UNSUPPORTED:\n\t\treturn SSH_ERR_FEATURE_UNSUPPORTED;\n\tcase SSH_SK_ERR_PIN_REQUIRED:\n\t\treturn SSH_ERR_KEY_WRONG_PASSPHRASE;\n\tcase SSH_SK_ERR_DEVICE_NOT_FOUND:\n\t\treturn SSH_ERR_DEVICE_NOT_FOUND;\n\tcase SSH_SK_ERR_GENERAL:\n\tdefault:\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n}\n\nstatic void\nsshsk_free_options(struct sk_option **opts)\n{\n\tsize_t i;\n\n\tif (opts == NULL)\n\t\treturn;\n\tfor (i = 0; opts[i] != NULL; i++) {\n\t\tfree(opts[i]->name);\n\t\tfree(opts[i]->value);\n\t\tfree(opts[i]);\n\t}\n\tfree(opts);\n}\n\nstatic int\nsshsk_add_option(struct sk_option ***optsp, size_t *noptsp,\n    const char *name, const char *value, uint8_t required)\n{\n\tstruct sk_option **opts = *optsp;\n\tsize_t nopts = *noptsp;\n\n\tif ((opts = recallocarray(opts, nopts, nopts + 2, /* extra for NULL */\n\t    sizeof(*opts))) == NULL) {\n\t\terror(\"%s: array alloc failed\", __func__);\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\t*optsp = opts;\n\t*noptsp = nopts + 1;\n\tif ((opts[nopts] = calloc(1, sizeof(**opts))) == NULL) {\n\t\terror(\"%s: alloc failed\", __func__);\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\tif ((opts[nopts]->name = strdup(name)) == NULL ||\n\t    (opts[nopts]->value = strdup(value)) == NULL) {\n\t\terror(\"%s: alloc failed\", __func__);\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\topts[nopts]->required = required;\n\treturn 0;\n}\n\nstatic int\nmake_options(const char *device, const char *user_id,\n    struct sk_option ***optsp)\n{\n\tstruct sk_option **opts = NULL;\n\tsize_t nopts = 0;\n\tint r, ret = SSH_ERR_INTERNAL_ERROR;\n\n\tif (device != NULL &&\n\t    (r = sshsk_add_option(&opts, &nopts, \"device\", device, 0)) != 0) {\n\t\tret = r;\n\t\tgoto out;\n\t}\n\tif (user_id != NULL &&\n\t    (r = sshsk_add_option(&opts, &nopts, \"user\", user_id, 0)) != 0) {\n\t\tret = r;\n\t\tgoto out;\n\t}\n\t/* success */\n\t*optsp = opts;\n\topts = NULL;\n\tnopts = 0;\n\tret = 0;\n out:\n\tsshsk_free_options(opts);\n\treturn ret;\n}\n\n\nstatic int\nfill_attestation_blob(const struct sk_enroll_response *resp,\n    struct sshbuf *attest)\n{\n\tint r;\n\n\tif (attest == NULL)\n\t\treturn 0; /* nothing to do */\n\tif ((r = sshbuf_put_cstring(attest, \"ssh-sk-attest-v01\")) != 0 ||\n\t    (r = sshbuf_put_string(attest,\n\t    resp->attestation_cert, resp->attestation_cert_len)) != 0 ||\n\t    (r = sshbuf_put_string(attest,\n\t    resp->signature, resp->signature_len)) != 0 ||\n\t    (r = sshbuf_put_string(attest,\n\t    resp->authdata, resp->authdata_len)) != 0 ||\n\t    (r = sshbuf_put_u32(attest, 0)) != 0 || /* resvd flags */\n\t    (r = sshbuf_put_string(attest, NULL, 0)) != 0 /* resvd */) {\n\t\terror(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\treturn r;\n\t}\n\t/* success */\n\treturn 0;\n}\n\nint\nsshsk_enroll(int type, const char *provider_path, const char *device,\n    const char *application, const char *userid, uint8_t flags,\n    const char *pin, struct sshbuf *challenge_buf,\n    struct sshkey **keyp, struct sshbuf *attest)\n{\n\tstruct sshsk_provider *skp = NULL;\n\tstruct sshkey *key = NULL;\n\tu_char randchall[32];\n\tconst u_char *challenge;\n\tsize_t challenge_len;\n\tstruct sk_enroll_response *resp = NULL;\n\tstruct sk_option **opts = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tint alg;\n\n\tdebug(\"%s: provider \\\"%s\\\", device \\\"%s\\\", application \\\"%s\\\", \"\n\t    \"userid \\\"%s\\\", flags 0x%02x, challenge len %zu%s\", __func__,\n\t    provider_path, device, application, userid, flags,\n\t    challenge_buf == NULL ? 0 : sshbuf_len(challenge_buf),\n\t    (pin != NULL && *pin != '\\0') ? \" with-pin\" : \"\");\n\n\t*keyp = NULL;\n\tif (attest)\n\t\tsshbuf_reset(attest);\n\n\tif ((r = make_options(device, userid, &opts)) != 0)\n\t\tgoto out;\n\n\tswitch (type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_ECDSA_SK:\n\t\talg = SSH_SK_ECDSA;\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519_SK:\n\t\talg = SSH_SK_ED25519;\n\t\tbreak;\n\tdefault:\n\t\terror(\"%s: unsupported key type\", __func__);\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\tif (provider_path == NULL) {\n\t\terror(\"%s: missing provider\", __func__);\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\tif (application == NULL || *application == '\\0') {\n\t\terror(\"%s: missing application\", __func__);\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\tif (challenge_buf == NULL) {\n\t\tdebug(\"%s: using random challenge\", __func__);\n\t\tarc4random_buf(randchall, sizeof(randchall));\n\t\tchallenge = randchall;\n\t\tchallenge_len = sizeof(randchall);\n\t} else if (sshbuf_len(challenge_buf) == 0) {\n\t\terror(\"Missing enrollment challenge\");\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t} else {\n\t\tchallenge = sshbuf_ptr(challenge_buf);\n\t\tchallenge_len = sshbuf_len(challenge_buf);\n\t\tdebug3(\"%s: using explicit challenge len=%zd\",\n\t\t    __func__, challenge_len);\n\t}\n\tif ((skp = sshsk_open(provider_path)) == NULL) {\n\t\tr = SSH_ERR_INVALID_FORMAT; /* XXX sshsk_open return code? */\n\t\tgoto out;\n\t}\n\t/* XXX validate flags? */\n\t/* enroll key */\n\tif ((r = skp->sk_enroll(alg, challenge, challenge_len, application,\n\t    flags, pin, opts, &resp)) != 0) {\n\t\tdebug(\"%s: provider \\\"%s\\\" returned failure %d\", __func__,\n\t\t    provider_path, r);\n\t\tr = skerr_to_ssherr(r);\n\t\tgoto out;\n\t}\n\n\tif ((r = sshsk_key_from_response(alg, application, flags,\n\t    resp, &key)) != 0)\n\t\tgoto out;\n\n\t/* Optionally fill in the attestation information */\n\tif ((r = fill_attestation_blob(resp, attest)) != 0)\n\t\tgoto out;\n\n\t/* success */\n\t*keyp = key;\n\tkey = NULL; /* transferred */\n\tr = 0;\n out:\n\tsshsk_free_options(opts);\n\tsshsk_free(skp);\n\tsshkey_free(key);\n\tsshsk_free_enroll_response(resp);\n\texplicit_bzero(randchall, sizeof(randchall));\n\treturn r;\n}\n\n#ifdef WITH_OPENSSL\nstatic int\nsshsk_ecdsa_sig(struct sk_sign_response *resp, struct sshbuf *sig)\n{\n\tstruct sshbuf *inner_sig = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\t/* Check response validity */\n\tif (resp->sig_r == NULL || resp->sig_s == NULL) {\n\t\terror(\"%s: sk_sign response invalid\", __func__);\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif ((inner_sig = sshbuf_new()) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\t/* Prepare and append inner signature object */\n\tif ((r = sshbuf_put_bignum2_bytes(inner_sig,\n\t    resp->sig_r, resp->sig_r_len)) != 0 ||\n\t    (r = sshbuf_put_bignum2_bytes(inner_sig,\n\t    resp->sig_s, resp->sig_s_len)) != 0) {\n\t\tdebug(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_put_stringb(sig, inner_sig)) != 0 ||\n\t    (r = sshbuf_put_u8(sig, resp->flags)) != 0 ||\n\t    (r = sshbuf_put_u32(sig, resp->counter)) != 0) {\n\t\tdebug(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n#ifdef DEBUG_SK\n\tfprintf(stderr, \"%s: sig_r:\\n\", __func__);\n\tsshbuf_dump_data(resp->sig_r, resp->sig_r_len, stderr);\n\tfprintf(stderr, \"%s: sig_s:\\n\", __func__);\n\tsshbuf_dump_data(resp->sig_s, resp->sig_s_len, stderr);\n\tfprintf(stderr, \"%s: inner:\\n\", __func__);\n\tsshbuf_dump(inner_sig, stderr);\n#endif\n\tr = 0;\n out:\n\tsshbuf_free(inner_sig);\n\treturn r;\n}\n#endif /* WITH_OPENSSL */\n\nstatic int\nsshsk_ed25519_sig(struct sk_sign_response *resp, struct sshbuf *sig)\n{\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\t/* Check response validity */\n\tif (resp->sig_r == NULL) {\n\t\terror(\"%s: sk_sign response invalid\", __func__);\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_put_string(sig,\n\t    resp->sig_r, resp->sig_r_len)) != 0 ||\n\t    (r = sshbuf_put_u8(sig, resp->flags)) != 0 ||\n\t    (r = sshbuf_put_u32(sig, resp->counter)) != 0) {\n\t\tdebug(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n#ifdef DEBUG_SK\n\tfprintf(stderr, \"%s: sig_r:\\n\", __func__);\n\tsshbuf_dump_data(resp->sig_r, resp->sig_r_len, stderr);\n#endif\n\tr = 0;\n out:\n\treturn r;\n}\n\nint\nsshsk_sign(const char *provider_path, struct sshkey *key,\n    u_char **sigp, size_t *lenp, const u_char *data, size_t datalen,\n    u_int compat, const char *pin)\n{\n\tstruct sshsk_provider *skp = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tint type, alg;\n\tstruct sk_sign_response *resp = NULL;\n\tstruct sshbuf *inner_sig = NULL, *sig = NULL;\n\tstruct sk_option **opts = NULL;\n\n\tdebug(\"%s: provider \\\"%s\\\", key %s, flags 0x%02x%s\", __func__,\n\t    provider_path, sshkey_type(key), key->sk_flags,\n\t    (pin != NULL && *pin != '\\0') ? \" with-pin\" : \"\");\n\n\tif (sigp != NULL)\n\t\t*sigp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\ttype = sshkey_type_plain(key->type);\n\tswitch (type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_ECDSA_SK:\n\t\talg = SSH_SK_ECDSA;\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519_SK:\n\t\talg = SSH_SK_ED25519;\n\t\tbreak;\n\tdefault:\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t}\n\tif (provider_path == NULL ||\n\t    key->sk_key_handle == NULL ||\n\t    key->sk_application == NULL || *key->sk_application == '\\0') {\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\tif ((skp = sshsk_open(provider_path)) == NULL) {\n\t\tr = SSH_ERR_INVALID_FORMAT; /* XXX sshsk_open return code? */\n\t\tgoto out;\n\t}\n\n\tif ((r = skp->sk_sign(alg, data, datalen, key->sk_application,\n\t    sshbuf_ptr(key->sk_key_handle), sshbuf_len(key->sk_key_handle),\n\t    key->sk_flags, pin, opts, &resp)) != 0) {\n\t\tdebug(\"%s: sk_sign failed with code %d\", __func__, r);\n\t\tr = skerr_to_ssherr(r);\n\t\tgoto out;\n\t}\n\t/* Assemble signature */\n\tif ((sig = sshbuf_new()) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_put_cstring(sig, sshkey_ssh_name_plain(key))) != 0) {\n\t\tdebug(\"%s: buffer error (outer): %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tswitch (type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_ECDSA_SK:\n\t\tif ((r = sshsk_ecdsa_sig(resp, sig)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519_SK:\n\t\tif ((r = sshsk_ed25519_sig(resp, sig)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\t}\n#ifdef DEBUG_SK\n\tfprintf(stderr, \"%s: sig_flags = 0x%02x, sig_counter = %u\\n\",\n\t    __func__, resp->flags, resp->counter);\n\tfprintf(stderr, \"%s: hashed message:\\n\", __func__);\n\tsshbuf_dump_data(message, sizeof(message), stderr);\n\tfprintf(stderr, \"%s: sigbuf:\\n\", __func__);\n\tsshbuf_dump(sig, stderr);\n#endif\n\tif (sigp != NULL) {\n\t\tif ((*sigp = malloc(sshbuf_len(sig))) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(*sigp, sshbuf_ptr(sig), sshbuf_len(sig));\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = sshbuf_len(sig);\n\t/* success */\n\tr = 0;\n out:\n\tsshsk_free_options(opts);\n\tsshsk_free(skp);\n\tsshsk_free_sign_response(resp);\n\tsshbuf_free(sig);\n\tsshbuf_free(inner_sig);\n\treturn r;\n}\n\nstatic void\nsshsk_free_sk_resident_keys(struct sk_resident_key **rks, size_t nrks)\n{\n\tsize_t i;\n\n\tif (nrks == 0 || rks == NULL)\n\t\treturn;\n\tfor (i = 0; i < nrks; i++) {\n\t\tfree(rks[i]->application);\n\t\tfreezero(rks[i]->key.key_handle, rks[i]->key.key_handle_len);\n\t\tfreezero(rks[i]->key.public_key, rks[i]->key.public_key_len);\n\t\tfreezero(rks[i]->key.signature, rks[i]->key.signature_len);\n\t\tfreezero(rks[i]->key.attestation_cert,\n\t\t    rks[i]->key.attestation_cert_len);\n\t\tfreezero(rks[i], sizeof(**rks));\n\t}\n\tfree(rks);\n}\n\nint\nsshsk_load_resident(const char *provider_path, const char *device,\n    const char *pin, struct sshkey ***keysp, size_t *nkeysp)\n{\n\tstruct sshsk_provider *skp = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tstruct sk_resident_key **rks = NULL;\n\tsize_t i, nrks = 0, nkeys = 0;\n\tstruct sshkey *key = NULL, **keys = NULL, **tmp;\n\tuint8_t flags;\n\tstruct sk_option **opts = NULL;\n\n\tdebug(\"%s: provider \\\"%s\\\"%s\", __func__, provider_path,\n\t    (pin != NULL && *pin != '\\0') ? \", have-pin\": \"\");\n\n\tif (keysp == NULL || nkeysp == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t*keysp = NULL;\n\t*nkeysp = 0;\n\n\tif ((r = make_options(device, NULL, &opts)) != 0)\n\t\tgoto out;\n\tif ((skp = sshsk_open(provider_path)) == NULL) {\n\t\tr = SSH_ERR_INVALID_FORMAT; /* XXX sshsk_open return code? */\n\t\tgoto out;\n\t}\n\tif ((r = skp->sk_load_resident_keys(pin, opts, &rks, &nrks)) != 0) {\n\t\terror(\"Provider \\\"%s\\\" returned failure %d\", provider_path, r);\n\t\tr = skerr_to_ssherr(r);\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < nrks; i++) {\n\t\tdebug3(\"%s: rk %zu: slot = %zu, alg = %d, application = \\\"%s\\\"\",\n\t\t    __func__, i, rks[i]->slot, rks[i]->alg,\n\t\t    rks[i]->application);\n\t\t/* XXX need better filter here */\n\t\tif (strncmp(rks[i]->application, \"ssh:\", 4) != 0)\n\t\t\tcontinue;\n\t\tswitch (rks[i]->alg) {\n\t\tcase SSH_SK_ECDSA:\n\t\tcase SSH_SK_ED25519:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t\tflags = SSH_SK_USER_PRESENCE_REQD|SSH_SK_RESIDENT_KEY;\n\t\tif ((rks[i]->flags & SSH_SK_USER_VERIFICATION_REQD))\n\t\t\tflags |= SSH_SK_USER_VERIFICATION_REQD;\n\t\tif ((r = sshsk_key_from_response(rks[i]->alg,\n\t\t    rks[i]->application, flags, &rks[i]->key, &key)) != 0)\n\t\t\tgoto out;\n\t\tif ((tmp = recallocarray(keys, nkeys, nkeys + 1,\n\t\t    sizeof(*tmp))) == NULL) {\n\t\t\terror(\"%s: recallocarray failed\", __func__);\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tkeys = tmp;\n\t\tkeys[nkeys++] = key;\n\t\tkey = NULL;\n\t\t/* XXX synthesise comment */\n\t}\n\t/* success */\n\t*keysp = keys;\n\t*nkeysp = nkeys;\n\tkeys = NULL;\n\tnkeys = 0;\n\tr = 0;\n out:\n\tsshsk_free_options(opts);\n\tsshsk_free(skp);\n\tsshsk_free_sk_resident_keys(rks, nrks);\n\tsshkey_free(key);\n\tif (nkeys != 0) {\n\t\tfor (i = 0; i < nkeys; i++)\n\t\t\tsshkey_free(keys[i]);\n\t\tfree(keys);\n\t}\n\treturn r;\n}\n\n#endif /* ENABLE_SK */\n"
    },
    "skipped": [],
    "total_files": 725
}