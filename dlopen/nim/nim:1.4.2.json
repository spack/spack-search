{
    "matches": {
        "/var/tmp/sochat1/spack-stage/spack-stage-nim-1.4.2-clhxocckl4vjqcsapqox2ghfzra4c4ma/spack-src/tests/misc/trunner.nim": "discard \"\"\"\n  targets: \"c cpp\"\n  joinable: false\n\"\"\"\n\n## tests that don't quite fit the mold and are easier to handle via `execCmdEx`\n## A few others could be added to here to simplify code.\n## Note: this test is a bit slow but tests a lot of things; please don't disable.\n\nimport std/[strformat,os,osproc,unittest]\nfrom std/sequtils import toSeq,mapIt\nfrom std/algorithm import sorted\nimport stdtest/[specialpaths, unittest_light]\nfrom std/private/globs import nativeToUnixPath\n\nimport \"$lib/../compiler/nimpaths\"\n\nconst\n  nim = getCurrentCompilerExe()\n  mode =\n    when defined(c): \"c\"\n    elif defined(cpp): \"cpp\"\n    else: static: doAssert false\n  nimcache = buildDir / \"nimcacheTrunner\"\n    # instead of `querySetting(nimcacheDir)`, avoids stomping on other parallel tests\n\nproc runCmd(file, options = \"\"): auto =\n  let fileabs = testsDir / file.unixToNativePath\n  doAssert fileabs.fileExists, fileabs\n  let cmd = fmt\"{nim} {mode} {options} --hints:off {fileabs}\"\n  result = execCmdEx(cmd)\n  when false:  echo result[0] & \"\\n\" & result[1] # for debugging\n\nwhen defined(nimTrunnerFfi):\n  block: # mevalffi\n    when defined(openbsd):\n      #[\n      openbsd defines `#define stderr (&__sF[2])` which makes it cumbersome\n      for dlopen'ing inside `importcSymbol`. Instead of adding special rules\n      inside `importcSymbol` to handle this, we disable just the part that's\n      not working and will provide a more general, clean fix in future PR.\n      ]#\n      var opt = \"-d:nimEvalffiStderrWorkaround\"\n      let prefix = \"\"\n    else:\n      var opt = \"\"\n      let prefix = \"\"\"\nhello world stderr\nhi stderr\n\"\"\"\n    let (output, exitCode) = runCmd(\"vm/mevalffi.nim\", fmt\"{opt} --experimental:compiletimeFFI\")\n    let expected = fmt\"\"\"\n{prefix}foo\nfoo:100\nfoo:101\nfoo:102:103\nfoo:102:103:104\nfoo:0.03:asdf:103:105\nret=[s1:foobar s2:foobar age:25 pi:3.14]\n\"\"\"\n    doAssert output == expected, output\n    doAssert exitCode == 0\n\nelse: # don't run twice the same test\n  import std/[strutils]\n  template check2(msg) = doAssert msg in output, output\n\n  block: # tests with various options `nim doc --project --index --docroot`\n    # regression tests for issues and PRS: #14376 #13223 #6583 ##13647\n    let file = testsDir / \"nimdoc/sub/mmain.nim\"\n    let mainFname = \"mmain.html\"\n    let htmldocsDirCustom = nimcache / \"htmldocsCustom\"\n    let docroot = testsDir / \"nimdoc\"\n    let options = [\n      0: \"--project\",\n      1: \"--project --docroot\",\n      2: \"\",\n      3: fmt\"--outDir:{htmldocsDirCustom}\",\n      4: fmt\"--docroot:{docroot}\",\n      5: \"--project --useNimcache\",\n      6: \"--index:off\",\n    ]\n\n    for i in 0..<options.len:\n      let htmldocsDir = case i\n      of 3: htmldocsDirCustom\n      of 5: nimcache / htmldocsDirname\n      else: file.parentDir / htmldocsDirname\n\n      var cmd = fmt\"{nim} doc --index:on --listFullPaths --hint:successX:on --nimcache:{nimcache} {options[i]} {file}\"\n      removeDir(htmldocsDir)\n      let (outp, exitCode) = execCmdEx(cmd)\n      check exitCode == 0\n      let ret = toSeq(walkDirRec(htmldocsDir, relative=true)).mapIt(it.nativeToUnixPath).sorted.join(\"\\n\")\n      let context = $(i, ret, cmd)\n      var expected = \"\"\n      case i\n      of 0,5:\n        let htmlFile = htmldocsDir/\"mmain.html\"\n        check htmlFile in outp # sanity check for `hintSuccessX`\n        assertEquals ret, fmt\"\"\"\n{dotdotMangle}/imp.html\n{dotdotMangle}/imp.idx\n{docHackJsFname}\nimp.html\nimp.idx\nimp2.html\nimp2.idx\nmmain.html\nmmain.idx\n{nimdocOutCss}\n{theindexFname}\"\"\", context\n      of 1: assertEquals ret, fmt\"\"\"\n{docHackJsFname}\n{nimdocOutCss}\ntests/nimdoc/imp.html\ntests/nimdoc/imp.idx\ntests/nimdoc/sub/imp.html\ntests/nimdoc/sub/imp.idx\ntests/nimdoc/sub/imp2.html\ntests/nimdoc/sub/imp2.idx\ntests/nimdoc/sub/mmain.html\ntests/nimdoc/sub/mmain.idx\n{theindexFname}\"\"\"\n      of 2, 3: assertEquals ret, fmt\"\"\"\n{docHackJsFname}\nmmain.html\nmmain.idx\n{nimdocOutCss}\"\"\", context\n      of 4: assertEquals ret, fmt\"\"\"\n{docHackJsFname}\n{nimdocOutCss}\nsub/mmain.html\nsub/mmain.idx\"\"\", context\n      of 6: assertEquals ret, fmt\"\"\"\nmmain.html\n{nimdocOutCss}\"\"\", context\n      else: doAssert false\n\n  block: # mstatic_assert\n    let (output, exitCode) = runCmd(\"ccgbugs/mstatic_assert.nim\", \"-d:caseBad\")\n    check2 \"sizeof(bool) == 2\"\n    check exitCode != 0\n\n  block: # ABI checks\n    let file = \"misc/msizeof5.nim\"\n    block:\n      let (output, exitCode) = runCmd(file, \"-d:checkAbi\")\n      doAssert exitCode == 0, output\n    block:\n      let (output, exitCode) = runCmd(file, \"-d:checkAbi -d:caseBad\")\n      # on platforms that support _StaticAssert natively, errors will show full context, e.g.:\n      # error: static_assert failed due to requirement 'sizeof(unsigned char) == 8'\n      # \"backend & Nim disagree on size for: BadImportcType{int64} [declared in mabi_check.nim(1, 6)]\"\n      check2 \"sizeof(unsigned char) == 8\"\n      check2 \"sizeof(struct Foo2) == 1\"\n      check2 \"sizeof(Foo5) == 16\"\n      check2 \"sizeof(Foo5) == 3\"\n      check2 \"sizeof(struct Foo6) == \"\n      check exitCode != 0\n\n  import streams\n  block: # stdin input\n    let nimcmd = fmt\"\"\"{nim} r --hints:off - -firstparam \"-second param\" \"\"\"\n    let expected = \"\"\"@[\"-firstparam\", \"-second param\"]\"\"\"\n    block:\n      let p = startProcess(nimcmd, options = {poEvalCommand})\n      p.inputStream.write(\"import os; echo commandLineParams()\")\n      p.inputStream.close\n      var output = p.outputStream.readAll\n      let error = p.errorStream.readAll\n      doAssert p.waitForExit == 0\n      doAssert error.len == 0, $error\n      output.stripLineEnd\n      check output == expected\n      p.errorStream.close\n      p.outputStream.close\n\n    block:\n      when defined posix:\n        # xxx on windows, `poEvalCommand` should imply `/cmd`, (which should\n        # make this work), but currently doesn't\n        let cmd = fmt\"\"\"echo \"import os; echo commandLineParams()\" | {nimcmd}\"\"\"\n        var (output, exitCode) = execCmdEx(cmd)\n        output.stripLineEnd\n        check output == expected\n        doAssert exitCode == 0\n\n  block: # nim doc --backend:$backend --doccmd:$cmd\n    # test for https://github.com/nim-lang/Nim/issues/13129\n    # test for https://github.com/nim-lang/Nim/issues/13891\n    let file = testsDir / \"nimdoc/m13129.nim\"\n    for backend in fmt\"{mode} js\".split:\n      # pending #14343 this fails on windows: --doccmd:\"-d:m13129Foo2 --hints:off\"\n      let cmd = fmt\"\"\"{nim} doc -b:{backend} --nimcache:{nimcache} -d:m13129Foo1 \"--doccmd:-d:m13129Foo2 --hints:off\" --usenimcache --hints:off {file}\"\"\"\n      check execCmdEx(cmd) == (&\"ok1:{backend}\\nok2: backend: {backend}\\n\", 0)\n    # checks that --usenimcache works with `nim doc`\n    check fileExists(nimcache / \"htmldocs/m13129.html\")\n\n    block: # mak sure --backend works with `nim r`\n      let cmd = fmt\"{nim} r --backend:{mode} --hints:off --nimcache:{nimcache} {file}\"\n      check execCmdEx(cmd) == (\"ok3\\n\", 0)\n\n  block: # further issues with `--backend`\n    let file = testsDir / \"misc/mbackend.nim\"\n    var cmd = fmt\"{nim} doc -b:cpp --hints:off --nimcache:{nimcache} {file}\"\n    check execCmdEx(cmd) == (\"\", 0)\n    cmd = fmt\"{nim} check -b:c -b:cpp --hints:off --nimcache:{nimcache} {file}\"\n    check execCmdEx(cmd) == (\"\", 0)\n    # issue https://github.com/timotheecour/Nim/issues/175\n    cmd = fmt\"{nim} c -b:js -b:cpp --hints:off --nimcache:{nimcache} {file}\"\n    check execCmdEx(cmd) == (\"\", 0)\n\n  block: # some importc tests\n    # issue #14314\n    let file = testsDir / \"misc/mimportc.nim\"\n    let cmd = fmt\"{nim} r -b:cpp --hints:off --nimcache:{nimcache} --warningAsError:ProveInit {file}\"\n    check execCmdEx(cmd) == (\"witness\\n\", 0)\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-nim-1.4.2-clhxocckl4vjqcsapqox2ghfzra4c4ma/spack-src/tests/realtimeGC/cmain.c": "#ifdef WIN\n#include <windows.h>\n#else\n#include <dlfcn.h>\n#include <unistd.h> /* for sleep(3) */\n#endif\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <time.h>\n\n#define RUNTIME (15*60)\n\n\ntypedef void (*pFunc)(void);\n\nint main(int argc, char* argv[])\n{\n    int i;\n    void* hndl;\n    pFunc status;\n    pFunc count;\n    pFunc checkOccupiedMem;\n\n#ifdef WIN\n    hndl = (void*) LoadLibrary((char const*)\"./tests/realtimeGC/shared.dll\");\n    status = (pFunc)GetProcAddress((HMODULE) hndl, (char const*)\"status\");\n    count = (pFunc)GetProcAddress((HMODULE) hndl, (char const*)\"count\");\n    checkOccupiedMem = (pFunc)GetProcAddress((HMODULE) hndl, (char const*)\"checkOccupiedMem\");\n#else /* OSX || NIX */\n    hndl = (void*) dlopen((char const*)\"./tests/realtimeGC/libshared.so\", RTLD_LAZY);\n    status = (pFunc) dlsym(hndl, (char const*)\"status\");\n    count = (pFunc) dlsym(hndl, (char const*)\"count\");\n    checkOccupiedMem = (pFunc) dlsym(hndl, (char const*)\"checkOccupiedMem\");\n#endif\n\n    assert(hndl);\n    assert(status);\n    assert(count);\n    assert(checkOccupiedMem);\n\n    time_t startTime = time((time_t*)0);\n    time_t runTime = (time_t)(RUNTIME);\n    time_t accumTime = 0;\n    while (accumTime < runTime) {\n        for (i = 0; i < 10; i++)\n            count();\n        /* printf(\"1. sleeping...\\n\"); */\n        sleep(1);\n        for (i = 0; i < 10; i++)\n            status();\n        /* printf(\"2. sleeping...\\n\"); */\n        sleep(1);\n        checkOccupiedMem();\n        accumTime = time((time_t*)0) - startTime;\n        /* printf(\"--- Minutes left to run: %d\\n\", (int)(runTime-accumTime)/60); */\n    }\n    printf(\"Cleaning up the shared object pointer...\\n\");\n#ifdef WIN\n    FreeLibrary((HMODULE)hndl);\n#else /* OSX || NIX */\n    dlclose(hndl);\n#endif\n    printf(\"Done\\n\");\n    return 0;\n}\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-nim-1.4.2-clhxocckl4vjqcsapqox2ghfzra4c4ma/spack-src/doc/backends.rst": "================================\n   Nim Backend Integration\n================================\n\n:Author: Puppet Master\n:Version: |nimversion|\n\n.. contents::\n  \"Heresy grows from idleness.\" -- Unknown.\n\n\nIntroduction\n============\n\nThe `Nim Compiler User Guide <nimc.html>`_ documents the typical\ncompiler invocation, using the ``compile`` or ``c`` command to transform a\n``.nim`` file into one or more ``.c`` files which are then compiled with the\nplatform's C compiler into a static binary. However, there are other commands\nto compile to C++, Objective-C, or JavaScript. This document tries to\nconcentrate in a single place all the backend and interfacing options.\n\nThe Nim compiler supports mainly two backend families: the C, C++ and\nObjective-C targets and the JavaScript target. `The C like targets\n<#backends-the-c-like-targets>`_ creates source files that can be compiled\ninto a library or a final executable. `The JavaScript target\n<#backends-the-javascript-target>`_ can generate a ``.js`` file which you\nreference from an HTML file or create a `standalone Node.js program\n<http://nodejs.org>`_.\n\nOn top of generating libraries or standalone applications, Nim offers\nbidirectional interfacing with the backend targets through generic and\nspecific pragmas.\n\n\nBackends\n========\n\nThe C like targets\n------------------\n\nThe commands to compile to either C, C++ or Objective-C are:\n\n  //compileToC, cc          compile project with C code generator\n  //compileToCpp, cpp       compile project to C++ code\n  //compileToOC, objc       compile project to Objective C code\n\nThe most significant difference between these commands is that if you look\ninto the ``nimcache`` directory you will find ``.c``, ``.cpp`` or ``.m``\nfiles, other than that all of them will produce a native binary for your\nproject.  This allows you to take the generated code and place it directly\ninto a project using any of these languages. Here are some typical command-\nline invocations::\n\n    $ nim c hallo.nim\n    $ nim cpp hallo.nim\n    $ nim objc hallo.nim\n\nThe compiler commands select the target backend, but if needed you can\n`specify additional switches for cross-compilation\n<nimc.html#crossminuscompilation>`_ to select the target CPU, operative system\nor compiler/linker commands.\n\n\nThe JavaScript target\n---------------------\n\nNim can also generate `JavaScript`:idx: code through the ``js`` command.\n\nNim targets JavaScript 1.5 which is supported by any widely used browser.\nSince JavaScript does not have a portable means to include another module,\nNim just generates a long ``.js`` file.\n\nFeatures or modules that the JavaScript platform does not support are not\navailable. This includes:\n\n* manual memory management (``alloc``, etc.)\n* casting and other unsafe operations (``cast`` operator, ``zeroMem``, etc.)\n* file management\n* OS-specific operations\n* threading, coroutines\n* some modules of the standard library\n* proper 64-bit integer arithmetic\n\nTo compensate, the standard library has modules `catered to the JS backend\n<lib.html#pure-libraries-modules-for-js-backend>`_\nand more support will come in the future (for instance, Node.js bindings\nto get OS info).\n\nTo compile a Nim module into a ``.js`` file use the ``js`` command; the\ndefault is a ``.js`` file that is supposed to be referenced in an ``.html``\nfile. However, you can also run the code with `nodejs`:idx:\n(`<http://nodejs.org>`_)::\n\n  nim js -d:nodejs -r examples/hallo.nim\n\n\nInterfacing\n===========\n\nNim offers bidirectional interfacing with the target backend. This means\nthat you can call backend code from Nim and Nim code can be called by\nthe backend code. Usually the direction of which calls which depends on your\nsoftware architecture (is Nim your main program or is Nim providing a\ncomponent?).\n\n\nNim code calling the backend\n----------------------------\n\nNim code can interface with the backend through the `Foreign function\ninterface <manual.html#foreign-function-interface>`_ mainly through the\n`importc pragma <manual.html#foreign-function-interface-importc-pragma>`_.\nThe ``importc`` pragma is the *generic* way of making backend symbols available\nin Nim and is available in all the target backends (JavaScript too).  The C++\nor Objective-C backends have their respective `ImportCpp\n<manual.html#implementation-specific-pragmas-importcpp-pragma>`_ and\n`ImportObjC <manual.html#implementation-specific-pragmas-importobjc-pragma>`_\npragmas to call methods from classes.\n\nWhenever you use any of these pragmas you need to integrate native code into\nyour final binary. In the case of JavaScript this is no problem at all, the\nsame HTML file which hosts the generated JavaScript will likely provide other\nJavaScript functions which you are importing with ``importc``.\n\nHowever, for the C like targets you need to link external code either\nstatically or dynamically. The preferred way of integrating native code is to\nuse dynamic linking because it allows you to compile Nim programs without\nthe need for having the related development libraries installed. This is done\nthrough the `dynlib pragma for import\n<manual.html#foreign-function-interface-dynlib-pragma-for-import>`_, though\nmore specific control can be gained using the `dynlib module <dynlib.html>`_.\n\nThe `dynlibOverride <nimc.html#dynliboverride>`_ command line switch allows\nto avoid dynamic linking if you need to statically link something instead.\nNim wrappers designed to statically link source files can use the `compile\npragma <manual.html#implementation-specific-pragmas-compile-pragma>`_ if\nthere are few sources or providing them along the Nim code is easier than using\na system library. Libraries installed on the host system can be linked in with\nthe `PassL pragma <manual.html#implementation-specific-pragmas-passl-pragma>`_.\n\nTo wrap native code, take a look at the `c2nim tool <https://github.com/nim-lang/c2nim/blob/master/doc/c2nim.rst>`_ which helps\nwith the process of scanning and transforming header files into a Nim\ninterface.\n\nC invocation example\n~~~~~~~~~~~~~~~~~~~~\n\nCreate a ``logic.c`` file with the following content:\n\n.. code-block:: c\n  int addTwoIntegers(int a, int b)\n  {\n    return a + b;\n  }\n\nCreate a ``calculator.nim`` file with the following content:\n\n.. code-block:: nim\n\n  {.compile: \"logic.c\".}\n  proc addTwoIntegers(a, b: cint): cint {.importc.}\n\n  when isMainModule:\n    echo addTwoIntegers(3, 7)\n\nWith these two files in place, you can run ``nim c -r calculator.nim`` and\nthe Nim compiler will compile the ``logic.c`` file in addition to\n``calculator.nim`` and link both into an executable, which outputs ``10`` when\nrun. Another way to link the C file statically and get the same effect would\nbe to remove the line with the ``compile`` pragma and run the following typical\nUnix commands::\n\n    $ gcc -c logic.c\n    $ ar rvs mylib.a logic.o\n    $ nim c --passL:mylib.a -r calculator.nim\n\nJust like in this example we pass the path to the ``mylib.a`` library (and we\ncould as well pass ``logic.o``) we could be passing switches to link any other\nstatic C library.\n\n\nJavaScript invocation example\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nCreate a ``host.html`` file with the following content:\n\n.. code-block::\n\n  <html><body>\n  <script type=\"text/javascript\">\n  function addTwoIntegers(a, b)\n  {\n    return a + b;\n  }\n  </script>\n  <script type=\"text/javascript\" src=\"calculator.js\"></script>\n  </body></html>\n\nCreate a ``calculator.nim`` file with the following content (or reuse the one\nfrom the previous section):\n\n.. code-block:: nim\n\n  proc addTwoIntegers(a, b: int): int {.importc.}\n\n  when isMainModule:\n    echo addTwoIntegers(3, 7)\n\nCompile the Nim code to JavaScript with ``nim js -o:calculator.js\ncalculator.nim`` and open ``host.html`` in a browser. If the browser supports\njavascript, you should see the value ``10`` in the browser's console. Use the\n`dom module <dom.html>`_ for specific DOM querying and modification procs\nor take a look at `karax <https://github.com/pragmagic/karax>`_ for how to\ndevelop browser-based applications.\n\n\nBackend code calling Nim\n------------------------\n\nBackend code can interface with Nim code exposed through the `exportc\npragma <manual.html#foreign-function-interface-exportc-pragma>`_. The\n``exportc`` pragma is the *generic* way of making Nim symbols available to\nthe backends. By default, the Nim compiler will mangle all the Nim symbols to\navoid any name collision, so the most significant thing the ``exportc`` pragma\ndoes is maintain the Nim symbol name, or if specified, use an alternative\nsymbol for the backend in case the symbol rules don't match.\n\nThe JavaScript target doesn't have any further interfacing considerations\nsince it also has garbage collection, but the C targets require you to\ninitialize Nim's internals, which is done calling a ``NimMain`` function.\nAlso, C code requires you to specify a forward declaration for functions or\nthe compiler will assume certain types for the return value and parameters\nwhich will likely make your program crash at runtime.\n\nThe Nim compiler can generate a C interface header through the ``--header``\ncommand-line switch. The generated header will contain all the exported\nsymbols and the ``NimMain`` proc which you need to call before any other\nNim code.\n\n\nNim invocation example from C\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nCreate a ``fib.nim`` file with the following content:\n\n.. code-block:: nim\n\n  proc fib(a: cint): cint {.exportc.} =\n    if a <= 2:\n      result = 1\n    else:\n      result = fib(a - 1) + fib(a - 2)\n\nCreate a ``maths.c`` file with the following content:\n\n.. code-block:: c\n\n  #include \"fib.h\"\n  #include <stdio.h>\n\n  int main(void)\n  {\n    NimMain();\n    for (int f = 0; f < 10; f++)\n      printf(\"Fib of %d is %d\\n\", f, fib(f));\n    return 0;\n  }\n\nNow you can run the following Unix like commands to first generate C sources\nfrom the Nim code, then link them into a static binary along your main C\nprogram::\n\n  $ nim c --noMain --noLinking --header:fib.h fib.nim\n  $ gcc -o m -I$HOME/.cache/nim/fib_d -Ipath/to/nim/lib $HOME/.cache/nim/fib_d/*.c maths.c\n\nThe first command runs the Nim compiler with three special options to avoid\ngenerating a ``main()`` function in the generated files, avoid linking the\nobject files into a final binary, and explicitly generate a header file for C\nintegration. All the generated files are placed into the ``nimcache``\ndirectory. That's why the next command compiles the ``maths.c`` source plus\nall the ``.c`` files from ``nimcache``. In addition to this path, you also\nhave to tell the C compiler where to find Nim's ``nimbase.h`` header file.\n\nInstead of depending on the generation of the individual ``.c`` files you can\nalso ask the Nim compiler to generate a statically linked library::\n\n  $ nim c --app:staticLib --noMain --header fib.nim\n  $ gcc -o m -Inimcache -Ipath/to/nim/lib libfib.nim.a maths.c\n\nThe Nim compiler will handle linking the source files generated in the\n``nimcache`` directory into the ``libfib.nim.a`` static library, which you can\nthen link into your C program.  Note that these commands are generic and will\nvary for each system. For instance, on Linux systems you will likely need to\nuse ``-ldl`` too to link in required dlopen functionality.\n\n\nNim invocation example from JavaScript\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nCreate a ``mhost.html`` file with the following content:\n\n.. code-block::\n\n  <html><body>\n  <script type=\"text/javascript\" src=\"fib.js\"></script>\n  <script type=\"text/javascript\">\n  alert(\"Fib for 9 is \" + fib(9));\n  </script>\n  </body></html>\n\nCreate a ``fib.nim`` file with the following content (or reuse the one\nfrom the previous section):\n\n.. code-block:: nim\n\n  proc fib(a: cint): cint {.exportc.} =\n    if a <= 2:\n      result = 1\n    else:\n      result = fib(a - 1) + fib(a - 2)\n\nCompile the Nim code to JavaScript with ``nim js -o:fib.js fib.nim`` and\nopen ``mhost.html`` in a browser. If the browser supports javascript, you\nshould see an alert box displaying the text ``Fib for 9 is 34``. As mentioned\nearlier, JavaScript doesn't require an initialization call to ``NimMain`` or\na similar function and you can call the exported Nim proc directly.\n\n\nNimcache naming logic\n---------------------\n\nThe `nimcache`:idx: directory is generated during compilation and will hold\neither temporary or final files depending on your backend target. The default\nname for the directory depends on the used backend and on your OS but you can\nuse the ``--nimcache`` `compiler switch\n<nimc.html#compiler-usage-commandminusline-switches>`_ to change it.\n\n\nMemory management\n=================\n\nIn the previous sections, the ``NimMain()`` function reared its head. Since\nJavaScript already provides automatic memory management, you can freely pass\nobjects between the two languages without problems. In C and derivate languages\nyou need to be careful about what you do and how you share memory. The\nprevious examples only dealt with simple scalar values, but passing a Nim\nstring to C, or reading back a C string in Nim already requires you to be\naware of who controls what to avoid crashing.\n\n\nStrings and C strings\n---------------------\n\nThe manual mentions that `Nim strings are implicitly convertible to\ncstrings <manual.html#types-cstring-type>`_ which makes interaction usually\npainless. Most C functions accepting a Nim string converted to a\n``cstring`` will likely not need to keep this string around and by the time\nthey return the string won't be needed anymore. However, for the rare cases\nwhere a Nim string has to be preserved and made available to the C backend\nas a ``cstring``, you will need to manually prevent the string data from being\nfreed with `GC_ref <system.html#GC_ref,string>`_ and `GC_unref\n<system.html#GC_unref,string>`_.\n\nA similar thing happens with C code invoking Nim code which returns a\n``cstring``. Consider the following proc:\n\n.. code-block:: nim\n\n  proc gimme(): cstring {.exportc.} =\n    result = \"Hey there C code! \" & $rand(100)\n\nSince Nim's garbage collector is not aware of the C code, once the\n``gimme`` proc has finished it can reclaim the memory of the ``cstring``.\nHowever, from a practical standpoint, the C code invoking the ``gimme``\nfunction directly will be able to use it since Nim's garbage collector has\nnot had a chance to run *yet*. This gives you enough time to make a copy for\nthe C side of the program, as calling any further Nim procs *might* trigger\ngarbage collection making the previously returned string garbage. Or maybe you\nare `yourself triggering the collection <gc.html>`_.\n\n\nCustom data types\n-----------------\n\nJust like strings, custom data types that are to be shared between Nim and\nthe backend will need careful consideration of who controls who. If you want\nto hand a Nim reference to C code, you will need to use `GC_ref\n<system.html#GC_ref,ref.T>`_ to mark the reference as used, so it does not get\nfreed. And for the C backend you will need to expose the `GC_unref\n<system.html#GC_unref,ref.T>`_ proc to clean up this memory when it is not\nrequired anymore.\n\nAgain, if you are wrapping a library which *mallocs* and *frees* data\nstructures, you need to expose the appropriate *free* function to Nim so\nyou can clean it up. And of course, once cleaned you should avoid accessing it\nfrom Nim (or C for that matter). Typically C data structures have their own\n``malloc_structure`` and ``free_structure`` specific functions, so wrapping\nthese for the Nim side should be enough.\n\n\nThread coordination\n-------------------\n\nWhen the ``NimMain()`` function is called Nim initializes the garbage\ncollector to the current thread, which is usually the main thread of your\napplication. If your C code later spawns a different thread and calls Nim\ncode, the garbage collector will fail to work properly and you will crash.\n\nAs long as you don't use the threadvar emulation Nim uses native thread\nvariables, of which you get a fresh version whenever you create a thread. You\ncan then attach a GC to this thread via\n\n.. code-block:: nim\n\n  system.setupForeignThreadGc()\n\nIt is **not** safe to disable the garbage collector and enable it after the\ncall from your background thread even if the code you are calling is short\nlived.\n\nBefore the thread exits, you should tear down the thread's GC to prevent memory\nleaks by calling\n\n.. code-block:: nim\n\n  system.tearDownForeignThreadGc()\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-nim-1.4.2-clhxocckl4vjqcsapqox2ghfzra4c4ma/spack-src/doc/nimc.rst": "===================================\n   Nim Compiler User Guide\n===================================\n\n:Author: Andreas Rumpf\n:Version: |nimversion|\n\n.. contents::\n\n  \"Look at you, hacker. A pathetic creature of meat and bone, panting and\n  sweating as you run through my corridors. How can you challenge a perfect,\n  immortal machine?\"\n\n\nIntroduction\n============\n\nThis document describes the usage of the *Nim compiler*\non the different supported platforms. It is not a definition of the Nim\nprogramming language (which is covered in the `manual <manual.html>`_).\n\nNim is free software; it is licensed under the\n`MIT License <http://www.opensource.org/licenses/mit-license.php>`_.\n\n\nCompiler Usage\n==============\n\nCommand-line switches\n---------------------\nBasic command-line switches are:\n\nUsage:\n\n.. include:: basicopt.txt\n\n----\n\nAdvanced command-line switches are:\n\n.. include:: advopt.txt\n\n\n\nList of warnings\n----------------\n\nEach warning can be activated individually with ``--warning[NAME]:on|off`` or\nin a ``push`` pragma.\n\n==========================       ============================================\nName                             Description\n==========================       ============================================\nCannotOpenFile                   Some file not essential for the compiler's\n                                 working could not be opened.\nOctalEscape                      The code contains an unsupported octal\n                                 sequence.\nDeprecated                       The code uses a deprecated symbol.\nConfigDeprecated                 The project makes use of a deprecated config\n                                 file.\nSmallLshouldNotBeUsed            The letter 'l' should not be used as an\n                                 identifier.\nEachIdentIsTuple                 The code contains a confusing ``var``\n                                 declaration.\nUser                             Some user-defined warning.\n==========================       ============================================\n\n\nList of hints\n-------------\n\nEach hint can be activated individually with ``--hint[NAME]:on|off`` or in a\n``push`` pragma.\n\n==========================       ============================================\nName                             Description\n==========================       ============================================\nCC                               Shows when the C compiler is called.\nCodeBegin\nCodeEnd\nCondTrue\nConf                             A config file was loaded.\nConvToBaseNotNeeded\nConvFromXtoItselfNotNeeded\nDependency\nExec                             Program is executed.\nExprAlwaysX\nExtendedContext\nGCStats                          Dumps statistics about the Garbage Collector.\nGlobalVar                        Shows global variables declarations.\nLineTooLong                      Line exceeds the maximum length.\nLink                             Linking phase.\nName\nPath                             Search paths modifications.\nPattern\nPerformance\nProcessing                       Artifact being compiled.\nQuitCalled\nSource                           The source line that triggered a diagnostic\n                                 message.\nStackTrace\nSuccess, SuccessX                Successful compilation of a library or a binary.\nUser\nUserRaw\nXDeclaredButNotUsed              Unused symbols in the code.\n==========================       ============================================\n\n\nVerbosity levels\n----------------\n\n=====  ============================================\nLevel  Description\n=====  ============================================\n0      Minimal output level for the compiler.\n1      Displays compilation of all the compiled files, including those imported\n       by other modules or through the `compile pragma\n       <manual.html#implementation-specific-pragmas-compile-pragma>`_.\n       This is the default level.\n2      Displays compilation statistics, enumerates the dynamic\n       libraries that will be loaded by the final binary, and dumps to\n       standard output the result of applying `a filter to the source code\n       <filters.html>`_ if any filter was used during compilation.\n3      In addition to the previous levels dumps a debug stack trace\n       for compiler developers.\n=====  ============================================\n\n\nCompile-time symbols\n--------------------\n\nThrough the ``-d:x`` or ``--define:x`` switch you can define compile-time\nsymbols for conditional compilation. The defined switches can be checked in\nsource code with the `when statement\n<manual.html#statements-and-expressions-when-statement>`_ and\n`defined proc <system.html#defined,untyped>`_. The typical use of this switch is\nto enable builds in release mode (``-d:release``) where optimizations are\nenabled for better performance. Another common use is the ``-d:ssl`` switch to\nactivate SSL sockets.\n\nAdditionally, you may pass a value along with the symbol: ``-d:x=y``\nwhich may be used in conjunction with the `compile-time define\npragmas<manual.html#implementation-specific-pragmas-compileminustime-define-pragmas>`_\nto override symbols during build time.\n\nCompile-time symbols are completely **case insensitive** and underscores are\nignored too. ``--define:FOO`` and ``--define:foo`` are identical.\n\nCompile-time symbols starting with the ``nim`` prefix are reserved for the\nimplementation and should not be used elsewhere.\n\n\nConfiguration files\n-------------------\n\n**Note:** The *project file name* is the name of the ``.nim`` file that is\npassed as a command-line argument to the compiler.\n\n\nThe ``nim`` executable processes configuration files in the following\ndirectories (in this order; later files overwrite previous settings):\n\n1) ``$nim/config/nim.cfg``, ``/etc/nim/nim.cfg`` (UNIX) or ``<Nim's installation directory>\\config\\nim.cfg`` (Windows). This file can be skipped with the ``--skipCfg`` command line option.\n2) If environment variable ``XDG_CONFIG_HOME`` is defined, ``$XDG_CONFIG_HOME/nim/nim.cfg`` or ``~/.config/nim/nim.cfg`` (POSIX) or ``%APPDATA%/nim/nim.cfg`` (Windows). This file can be skipped with the ``--skipUserCfg`` command line option.\n3) ``$parentDir/nim.cfg`` where ``$parentDir`` stands for any parent  directory of the project file's path. These files can be skipped with the ``--skipParentCfg`` command-line option.\n4) ``$projectDir/nim.cfg`` where ``$projectDir`` stands for the project  file's path. This file can be skipped with the ``--skipProjCfg`` command-line option.\n5) A project can also have a project-specific configuration file named ``$project.nim.cfg`` that resides in the same directory as ``$project.nim``. This file can be skipped with the ``--skipProjCfg`` command-line option.\n\n\nCommand-line settings have priority over configuration file settings.\n\nThe default build of a project is a `debug build`:idx:. To compile a\n`release build`:idx: define the ``release`` symbol::\n\n  nim c -d:release myproject.nim\n\n To compile a `dangerous release build`:idx: define the ``danger`` symbol::\n\n  nim c -d:danger myproject.nim\n\n\nSearch path handling\n--------------------\n\nNim has the concept of a global search path (PATH) that is queried to\ndetermine where to find imported modules or include files. If multiple files are\nfound an ambiguity error is produced.\n\n``nim dump`` shows the contents of the PATH.\n\nHowever before the PATH is used the current directory is checked for the\nfile's existence. So if PATH contains ``$lib`` and ``$lib/bar`` and the\ndirectory structure looks like this::\n\n  $lib/x.nim\n  $lib/bar/x.nim\n  foo/x.nim\n  foo/main.nim\n  other.nim\n\nAnd ``main`` imports ``x``, ``foo/x`` is imported. If ``other`` imports ``x``\nthen both ``$lib/x.nim`` and ``$lib/bar/x.nim`` match but ``$lib/x.nim`` is used\nas it is the first match.\n\n\nGenerated C code directory\n--------------------------\nThe generated files that Nim produces all go into a subdirectory called\n``nimcache``. Its full path is\n\n- ``$XDG_CACHE_HOME/nim/$projectname(_r|_d)`` or ``~/.cache/nim/$projectname(_r|_d)``\n  on Posix\n- ``$HOME/nimcache/$projectname(_r|_d)`` on Windows.\n\nThe ``_r`` suffix is used for release builds, ``_d`` is for debug builds.\n\nThis makes it easy to delete all generated files.\n\nThe ``--nimcache``\n`compiler switch <#compiler-usage-commandminusline-switches>`_ can be used to\nto change the ``nimcache`` directory.\n\nHowever, the generated C code is not platform-independent. C code generated for\nLinux does not compile on Windows, for instance. The comment on top of the\nC file lists the OS, CPU, and CC the file has been compiled for.\n\n\nCompiler Selection\n==================\n\nTo change the compiler from the default compiler (at the command line)::\n\n  nim c --cc:llvm_gcc --compile_only myfile.nim\n\nThis uses the configuration defined in ``config\\nim.cfg`` for ``lvm_gcc``.\n\nIf nimcache already contains compiled code from a different compiler for the same project,\nadd the ``-f`` flag to force all files to be recompiled.\n\nThe default compiler is defined at the top of ``config\\nim.cfg``.\nChanging this setting affects the compiler used by ``koch`` to (re)build Nim.\n\nTo use the ``CC`` environment variable, use ``nim c --cc:env myfile.nim``. To use the\n``CXX`` environment variable, use ``nim cpp --cc:env myfile.nim``. ``--cc:env`` is available\nsince Nim version 1.4.\n\n\nCross-compilation\n=================\n\nTo cross compile, use for example::\n\n  nim c --cpu:i386 --os:linux --compileOnly --genScript myproject.nim\n\nThen move the C code and the compile script ``compile_myproject.sh`` to your\nLinux i386 machine and run the script.\n\nAnother way is to make Nim invoke a cross compiler toolchain::\n\n  nim c --cpu:arm --os:linux myproject.nim\n\nFor cross compilation, the compiler invokes a C compiler named\nlike ``$cpu.$os.$cc`` (for example arm.linux.gcc) and the configuration\nsystem is used to provide meaningful defaults. For example for ``ARM`` your\nconfiguration file should contain something like::\n\n  arm.linux.gcc.path = \"/usr/bin\"\n  arm.linux.gcc.exe = \"arm-linux-gcc\"\n  arm.linux.gcc.linkerexe = \"arm-linux-gcc\"\n\nCross-compilation for Windows\n=============================\n\nTo cross-compile for Windows from Linux or macOS using the MinGW-w64 toolchain::\n\n  nim c -d:mingw myproject.nim\n\nUse ``--cpu:i386`` or ``--cpu:amd64`` to switch the CPU architecture.\n\nThe MinGW-w64 toolchain can be installed as follows::\n\n  Ubuntu: apt install mingw-w64\n  CentOS: yum install mingw32-gcc | mingw64-gcc - requires EPEL\n  OSX: brew install mingw-w64\n\n\nCross-compilation for Android\n=============================\n\nThere are two ways to compile for Android: terminal programs (Termux) and with\nthe NDK (Android Native Development Kit).\n\nThe first one is to treat Android as a simple Linux and use\n`Termux <https://wiki.termux.com>`_ to connect and run the Nim compiler\ndirectly on android as if it was Linux. These programs are console-only\nprograms that can't be distributed in the Play Store.\n\nUse regular ``nim c`` inside termux to make Android terminal programs.\n\nNormal Android apps are written in Java, to use Nim inside an Android app\nyou need a small Java stub that calls out to a native library written in\nNim using the `NDK <https://developer.android.com/ndk>`_. You can also use\n`native-activity <https://developer.android.com/ndk/samples/sample_na>`_\nto have the Java stub be auto-generated for you.\n\nUse ``nim c -c --cpu:arm --os:android -d:androidNDK --noMain:on`` to\ngenerate the C source files you need to include in your Android Studio\nproject. Add the generated C files to CMake build script in your Android\nproject. Then do the final compile with Android Studio which uses Gradle\nto call CMake to compile the project.\n\nBecause Nim is part of a library it can't have its own c style ``main()``\nso you would need to define your own ``android_main`` and init the Java\nenvironment, or use a library like SDL2 or GLFM to do it. After the Android\nstuff is done, it's very important to call ``NimMain()`` in order to\ninitialize Nim's garbage collector and to run the top level statements\nof your program.\n\n.. code-block:: Nim\n\n  proc NimMain() {.importc.}\n  proc glfmMain*(display: ptr GLFMDisplay) {.exportc.} =\n    NimMain() # initialize garbage collector memory, types and stack\n\n\nCross-compilation for iOS\n=========================\n\nTo cross-compile for iOS you need to be on a macOS computer and use XCode.\nNormal languages for iOS development are Swift and Objective C. Both of these\nuse LLVM and can be compiled into object files linked together with C, C++\nor Objective C code produced by Nim.\n\nUse ``nim c -c --os:ios --noMain:on`` to generate C files and include them in\nyour XCode project. Then you can use XCode to compile, link, package and\nsign everything.\n\nBecause Nim is part of a library it can't have its own c style ``main()`` so you\nwould need to define `main` that calls ``autoreleasepool`` and\n``UIApplicationMain`` to do it, or use a library like SDL2 or GLFM. After\nthe iOS setup is done, it's very important to call ``NimMain()`` to\ninitialize Nim's garbage collector and to run the top-level statements\nof your program.\n\n.. code-block:: Nim\n\n  proc NimMain() {.importc.}\n  proc glfmMain*(display: ptr GLFMDisplay) {.exportc.} =\n    NimMain() # initialize garbage collector memory, types and stack\n\nNote: XCode's \"make clean\" gets confused about the generated nim.c files,\nso you need to clean those files manually to do a clean build.\n\n\nCross-compilation for Nintendo Switch\n=====================================\n\nSimply add --os:nintendoswitch\nto your usual ``nim c`` or ``nim cpp`` command and set the ``passC``\nand ``passL`` command line switches to something like:\n\n.. code-block:: console\n  nim c ... --passC=\"-I$DEVKITPRO/libnx/include\" ...\n  --passL=\"-specs=$DEVKITPRO/libnx/switch.specs -L$DEVKITPRO/libnx/lib -lnx\"\n\nor setup a nim.cfg file like so:\n\n.. code-block:: Nim\n  #nim.cfg\n  --passC=\"-I$DEVKITPRO/libnx/include\"\n  --passL=\"-specs=$DEVKITPRO/libnx/switch.specs -L$DEVKITPRO/libnx/lib -lnx\"\n\nThe DevkitPro setup must be the same as the default with their new installer\n`here for Mac/Linux <https://github.com/devkitPro/pacman/releases>`_ or\n`here for Windows <https://github.com/devkitPro/installer/releases>`_.\n\nFor example, with the above-mentioned config::\n\n  nim c --os:nintendoswitch switchhomebrew.nim\n\nThis will generate a file called ``switchhomebrew.elf`` which can then be turned into\nan nro file with the ``elf2nro`` tool in the DevkitPro release. Examples can be found at\n`the nim-libnx github repo <https://github.com/jyapayne/nim-libnx.git>`_.\n\nThere are a few things that don't work because the DevkitPro libraries don't support them.\nThey are:\n\n1. Waiting for a subprocess to finish. A subprocess can be started, but right\n   now it can't be waited on, which sort of makes subprocesses a bit hard to use\n2. Dynamic calls. DevkitPro libraries have no dlopen/dlclose functions.\n3. Command line parameters. It doesn't make sense to have these for a console\n   anyways, so no big deal here.\n4. mqueue. Sadly there are no mqueue headers.\n5. ucontext. No headers for these either. No coroutines for now :(\n6. nl_types. No headers for this.\n\nDLL generation\n==============\n\nNim supports the generation of DLLs. However, there must be only one\ninstance of the GC per process/address space. This instance is contained in\n``nimrtl.dll``. This means that every generated Nim DLL depends\non ``nimrtl.dll``. To generate the \"nimrtl.dll\" file, use the command::\n\n  nim c -d:release lib/nimrtl.nim\n\nTo link against ``nimrtl.dll`` use the command::\n\n  nim c -d:useNimRtl myprog.nim\n\n**Note**: Currently the creation of ``nimrtl.dll`` with thread support has\nnever been tested and is unlikely to work!\n\n\nAdditional compilation switches\n===============================\n\nThe standard library supports a growing number of ``useX`` conditional defines\naffecting how some features are implemented. This section tries to give a\ncomplete list.\n\n======================   =========================================================\nDefine                   Effect\n======================   =========================================================\n``release``              Turns on the optimizer.\n                         More aggressive optimizations are possible, e.g.:\n                         ``--passC:-ffast-math`` (but see issue #10305)\n``danger``               Turns off all runtime checks and turns on the optimizer.\n``useFork``              Makes ``osproc`` use ``fork`` instead of ``posix_spawn``.\n``useNimRtl``            Compile and link against ``nimrtl.dll``.\n``useMalloc``            Makes Nim use C's `malloc`:idx: instead of Nim's\n                         own memory manager, albeit prefixing each allocation with\n                         its size to support clearing memory on reallocation.\n                         This only works with ``gc:none`` and\n                         with ``--newruntime``.\n``useRealtimeGC``        Enables support of Nim's GC for *soft* realtime\n                         systems. See the documentation of the `gc <gc.html>`_\n                         for further information.\n``logGC``                Enable GC logging to stdout.\n``nodejs``               The JS target is actually ``node.js``.\n``ssl``                  Enables OpenSSL support for the sockets module.\n``memProfiler``          Enables memory profiling for the native GC.\n``uClibc``               Use uClibc instead of libc. (Relevant for Unix-like OSes)\n``checkAbi``             When using types from C headers, add checks that compare\n                         what's in the Nim file with what's in the C header.\n                         This may become enabled by default in the future.\n``tempDir``              This symbol takes a string as its value, like\n                         ``--define:tempDir:/some/temp/path`` to override the\n                         temporary directory returned by ``os.getTempDir()``.\n                         The value **should** end with a directory separator\n                         character. (Relevant for the Android platform)\n``useShPath``            This symbol takes a string as its value, like\n                         ``--define:useShPath:/opt/sh/bin/sh`` to override the\n                         path for the ``sh`` binary, in cases where it is not\n                         located in the default location ``/bin/sh``.\n``noSignalHandler``      Disable the crash handler from ``system.nim``.\n``globalSymbols``        Load all ``{.dynlib.}`` libraries with the ``RTLD_GLOBAL``\n                         flag on Posix systems to resolve symbols in subsequently\n                         loaded libraries.\n======================   =========================================================\n\n\n\nAdditional Features\n===================\n\nThis section describes Nim's additional features that are not listed in the\nNim manual. Some of the features here only make sense for the C code\ngenerator and are subject to change.\n\n\nLineDir option\n--------------\nThe ``lineDir`` option can be turned on or off. If turned on the\ngenerated C code contains ``#line`` directives. This may be helpful for\ndebugging with GDB.\n\n\nStackTrace option\n-----------------\nIf the ``stackTrace`` option is turned on, the generated C contains code to\nensure that proper stack traces are given if the program crashes or some uncaught exception is raised.\n\n\nLineTrace option\n----------------\nThe ``lineTrace`` option implies the ``stackTrace`` option. If turned on,\nthe generated C contains code to ensure that proper stack traces with line\nnumber information are given if the program crashes or an uncaught exception\nis raised.\n\n\nDynlibOverride\n==============\n\nBy default Nim's ``dynlib`` pragma causes the compiler to generate\n``GetProcAddress`` (or their Unix counterparts)\ncalls to bind to a DLL. With the ``dynlibOverride`` command line switch this\ncan be prevented and then via ``--passL`` the static library can be linked\nagainst. For instance, to link statically against Lua this command might work\non Linux::\n\n  nim c --dynlibOverride:lua --passL:liblua.lib program.nim\n\n\nBackend language options\n========================\n\nThe typical compiler usage involves using the ``compile`` or ``c`` command to\ntransform a ``.nim`` file into one or more ``.c`` files which are then\ncompiled with the platform's C compiler into a static binary. However, there\nare other commands to compile to C++, Objective-C, or JavaScript. More details\ncan be read in the `Nim Backend Integration document <backends.html>`_.\n\n\nNim documentation tools\n=======================\n\nNim provides the `doc`:idx: command to generate HTML\ndocumentation from ``.nim`` source files. Only exported symbols will appear in\nthe output. For more details `see the docgen documentation <docgen.html>`_.\n\nNim idetools integration\n========================\n\nNim provides language integration with external IDEs through the\nidetools command. See the documentation of `idetools <idetools.html>`_\nfor further information.\n\n..\n  Nim interactive mode\n  ====================\n\n  The Nim compiler supports an interactive mode. This is also known as\n  a `REPL`:idx: (*read eval print loop*). If Nim has been built with the\n  ``-d:nimUseLinenoise`` switch, it uses the GNU readline library for terminal\n  input management. To start Nim in interactive mode use the command\n  ``nim secret``. To quit use the ``quit()`` command. To determine whether an input\n  line is an incomplete statement to be continued these rules are used:\n\n  1. The line ends with ``[-+*/\\\\<>!\\?\\|%&$@~,;:=#^]\\s*$`` (operator symbol followed by optional whitespace).\n  2. The line starts with a space (indentation).\n  3. The line is within a triple quoted string literal. However, the detection\n     does not work if the line contains more than one ``\"\"\"``.\n\n\nNim for embedded systems\n========================\n\nWhile the default Nim configuration is targeted for optimal performance on\nmodern PC hardware and operating systems with ample memory, it is very well\npossible to run Nim code and a good part of the Nim standard libraries on small\nembedded microprocessors with only a few kilobytes of memory.\n\nA good start is to use the ``any`` operating target together with the\n``malloc`` memory allocator and the ``arc`` garbage collector. For example:\n\n``nim c --os:any --gc:arc -d:useMalloc [...] x.nim``\n\n- ``--gc:arc`` will enable the reference counting memory management instead\n  of the default garbage collector. This enables Nim to use heap memory which\n  is required for strings and seqs, for example.\n\n- The ``--os:any`` target makes sure Nim does not depend on any specific\n  operating system primitives. Your platform should support only some basic\n  ANSI C library ``stdlib`` and ``stdio`` functions which should be available\n  on almost any platform.\n\n- The ``-d:useMalloc`` option configures Nim to use only the standard C memory\n  manage primitives ``malloc()``, ``free()``, ``realloc()``.\n\nIf your platform does not provide these functions it should be trivial to\nprovide an implementation for them and link these to your program.\n\nFor targets with very restricted memory, it might be beneficial to pass some\nadditional flags to both the Nim compiler and the C compiler and/or linker\nto optimize the build for size. For example, the following flags can be used\nwhen targeting a gcc compiler:\n\n``--opt:size --passC:-flto --passL:-flto``\n\nThe ``--opt:size`` flag instructs Nim to optimize code generation for small\nsize (with the help of the C compiler), the ``flto`` flags enable link-time\noptimization in the compiler and linker.\n\nCheck the `Cross-compilation` section for instructions on how to compile the\nprogram for your target.\n\nNim for realtime systems\n========================\n\nSee the documentation of Nim's soft realtime `GC <gc.html>`_ for further\ninformation.\n\n\nSignal handling in Nim\n======================\n\nThe Nim programming language has no concept of Posix's signal handling\nmechanisms. However, the standard library offers some rudimentary support\nfor signal handling, in particular, segmentation faults are turned into\nfatal errors that produce a stack trace. This can be disabled with the\n``-d:noSignalHandler`` switch.\n\n\nOptimizing for Nim\n==================\n\nNim has no separate optimizer, but the C code that is produced is very\nefficient. Most C compilers have excellent optimizers, so usually it is\nnot needed to optimize one's code. Nim has been designed to encourage\nefficient code: The most readable code in Nim is often the most efficient\ntoo.\n\nHowever, sometimes one has to optimize. Do it in the following order:\n\n1. switch off the embedded debugger (it is **slow**!)\n2. turn on the optimizer and turn off runtime checks\n3. profile your code to find where the bottlenecks are\n4. try to find a better algorithm\n5. do low-level optimizations\n\nThis section can only help you with the last item.\n\n\nOptimizing string handling\n--------------------------\n\nString assignments are sometimes expensive in Nim: They are required to\ncopy the whole string. However, the compiler is often smart enough to not copy\nstrings. Due to the argument passing semantics, strings are never copied when\npassed to subroutines. The compiler does not copy strings that are a result of\na procedure call, because the callee returns a new string anyway.\nThus it is efficient to do:\n\n.. code-block:: Nim\n  var s = procA() # assignment will not copy the string; procA allocates a new\n                  # string already\n\nHowever, it is not efficient to do:\n\n.. code-block:: Nim\n  var s = varA    # assignment has to copy the whole string into a new buffer!\n\nFor ``let`` symbols a copy is not always necessary:\n\n.. code-block:: Nim\n  let s = varA    # may only copy a pointer if it safe to do so\n\n\nIf you know what you're doing, you can also mark single-string (or sequence)\nobjects as `shallow`:idx:\\:\n\n.. code-block:: Nim\n  var s = \"abc\"\n  shallow(s) # mark 's' as a shallow string\n  var x = s  # now might not copy the string!\n\nUsage of ``shallow`` is always safe once you know the string won't be modified\nanymore, similar to Ruby's `freeze`:idx:.\n\n\nThe compiler optimizes string case statements: A hashing scheme is used for them\nif several different string constants are used. So code like this is reasonably\nefficient:\n\n.. code-block:: Nim\n  case normalize(k.key)\n  of \"name\": c.name = v\n  of \"displayname\": c.displayName = v\n  of \"version\": c.version = v\n  of \"os\": c.oses = split(v, {';'})\n  of \"cpu\": c.cpus = split(v, {';'})\n  of \"authors\": c.authors = split(v, {';'})\n  of \"description\": c.description = v\n  of \"app\":\n    case normalize(v)\n    of \"console\": c.app = appConsole\n    of \"gui\": c.app = appGUI\n    else: quit(errorStr(p, \"expected: console or gui\"))\n  of \"license\": c.license = UnixToNativePath(k.value)\n  else: quit(errorStr(p, \"unknown variable: \" & k.key))\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-nim-1.4.2-clhxocckl4vjqcsapqox2ghfzra4c4ma/spack-src/lib/pure/dynlib.nim": "#\n#\n#            Nim's Runtime Library\n#        (c) Copyright 2012 Andreas Rumpf\n#\n#    See the file \"copying.txt\", included in this\n#    distribution, for details about the copyright.\n#\n\n## This module implements the ability to access symbols from shared\n## libraries. On POSIX this uses the ``dlsym`` mechanism, on\n## Windows ``LoadLibrary``.\n##\n## Examples\n## ========\n##\n## Loading a simple C function\n## ---------------------------\n##\n## The following example demonstrates loading a function called 'greet'\n## from a library that is determined at runtime based upon a language choice.\n## If the library fails to load or the function 'greet' is not found,\n## it quits with a failure error code.\n##\n## .. code-block::nim\n##\n##   import dynlib\n##\n##   type\n##     greetFunction = proc(): cstring {.gcsafe, stdcall.}\n##\n##   let lang = stdin.readLine()\n##\n##   let lib = case lang\n##   of \"french\":\n##     loadLib(\"french.dll\")\n##   else:\n##     loadLib(\"english.dll\")\n##\n##   if lib == nil:\n##     echo \"Error loading library\"\n##     quit(QuitFailure)\n##\n##   let greet = cast[greetFunction](lib.symAddr(\"greet\"))\n##\n##   if greet == nil:\n##     echo \"Error loading 'greet' function from library\"\n##     quit(QuitFailure)\n##\n##   let greeting = greet()\n##\n##   echo greeting\n##\n##   unloadLib(lib)\n##\n\nimport strutils\n\ntype\n  LibHandle* = pointer ## a handle to a dynamically loaded library\n\nproc loadLib*(path: string, globalSymbols = false): LibHandle {.gcsafe.}\n  ## loads a library from `path`. Returns nil if the library could not\n  ## be loaded.\n\nproc loadLib*(): LibHandle {.gcsafe.}\n  ## gets the handle from the current executable. Returns nil if the\n  ## library could not be loaded.\n\nproc unloadLib*(lib: LibHandle) {.gcsafe.}\n  ## unloads the library `lib`\n\nproc raiseInvalidLibrary*(name: cstring) {.noinline, noreturn.} =\n  ## raises an `EInvalidLibrary` exception.\n  raise newException(LibraryError, \"could not find symbol: \" & $name)\n\nproc symAddr*(lib: LibHandle, name: cstring): pointer {.gcsafe.}\n  ## retrieves the address of a procedure/variable from `lib`. Returns nil\n  ## if the symbol could not be found.\n\nproc checkedSymAddr*(lib: LibHandle, name: cstring): pointer =\n  ## retrieves the address of a procedure/variable from `lib`. Raises\n  ## `EInvalidLibrary` if the symbol could not be found.\n  result = symAddr(lib, name)\n  if result == nil: raiseInvalidLibrary(name)\n\nproc libCandidates*(s: string, dest: var seq[string]) =\n  ## given a library name pattern `s` write possible library names to `dest`.\n  var le = strutils.find(s, '(')\n  var ri = strutils.find(s, ')', le+1)\n  if le >= 0 and ri > le:\n    var prefix = substr(s, 0, le - 1)\n    var suffix = substr(s, ri + 1)\n    for middle in split(substr(s, le + 1, ri - 1), '|'):\n      libCandidates(prefix & middle & suffix, dest)\n  else:\n    add(dest, s)\n\nproc loadLibPattern*(pattern: string, globalSymbols = false): LibHandle =\n  ## loads a library with name matching `pattern`, similar to what `dynlib`\n  ## pragma does. Returns nil if the library could not be loaded.\n  ## Warning: this proc uses the GC and so cannot be used to load the GC.\n  var candidates = newSeq[string]()\n  libCandidates(pattern, candidates)\n  for c in candidates:\n    result = loadLib(c, globalSymbols)\n    if not result.isNil: break\n\nwhen defined(posix) and not defined(nintendoswitch):\n  #\n  # =========================================================================\n  # This is an implementation based on the dlfcn interface.\n  # The dlfcn interface is available in Linux, SunOS, Solaris, IRIX, FreeBSD,\n  # NetBSD, AIX 4.2, HPUX 11, and probably most other Unix flavors, at least\n  # as an emulation layer on top of native functions.\n  # =========================================================================\n  #\n  import posix\n\n  proc loadLib(path: string, globalSymbols = false): LibHandle =\n    let flags =\n      if globalSymbols: RTLD_NOW or RTLD_GLOBAL\n      else: RTLD_NOW\n\n    dlopen(path, flags)\n\n  proc loadLib(): LibHandle = dlopen(nil, RTLD_NOW)\n  proc unloadLib(lib: LibHandle) = discard dlclose(lib)\n  proc symAddr(lib: LibHandle, name: cstring): pointer = dlsym(lib, name)\n\nelif defined(nintendoswitch):\n  #\n  # =========================================================================\n  # Nintendo switch DevkitPro sdk does not have these. Raise an error if called.\n  # =========================================================================\n  #\n\n  proc dlclose(lib: LibHandle) =\n    raise newException(OSError, \"dlclose not implemented on Nintendo Switch!\")\n  proc dlopen(path: cstring, mode: int): LibHandle =\n    raise newException(OSError, \"dlopen not implemented on Nintendo Switch!\")\n  proc dlsym(lib: LibHandle, name: cstring): pointer =\n    raise newException(OSError, \"dlsym not implemented on Nintendo Switch!\")\n  proc loadLib(path: string, global_symbols = false): LibHandle =\n    raise newException(OSError, \"loadLib not implemented on Nintendo Switch!\")\n  proc loadLib(): LibHandle =\n    raise newException(OSError, \"loadLib not implemented on Nintendo Switch!\")\n  proc unloadLib(lib: LibHandle) =\n    raise newException(OSError, \"unloadLib not implemented on Nintendo Switch!\")\n  proc symAddr(lib: LibHandle, name: cstring): pointer =\n    raise newException(OSError, \"symAddr not implemented on Nintendo Switch!\")\n\nelif defined(windows) or defined(dos):\n  #\n  # =======================================================================\n  # Native Windows Implementation\n  # =======================================================================\n  #\n  type\n    HMODULE {.importc: \"HMODULE\".} = pointer\n    FARPROC {.importc: \"FARPROC\".} = pointer\n\n  proc FreeLibrary(lib: HMODULE) {.importc, header: \"<windows.h>\", stdcall.}\n  proc winLoadLibrary(path: cstring): HMODULE {.\n      importc: \"LoadLibraryA\", header: \"<windows.h>\", stdcall.}\n  proc getProcAddress(lib: HMODULE, name: cstring): FARPROC {.\n      importc: \"GetProcAddress\", header: \"<windows.h>\", stdcall.}\n\n  proc loadLib(path: string, globalSymbols = false): LibHandle =\n    result = cast[LibHandle](winLoadLibrary(path))\n  proc loadLib(): LibHandle =\n    result = cast[LibHandle](winLoadLibrary(nil))\n  proc unloadLib(lib: LibHandle) = FreeLibrary(cast[HMODULE](lib))\n\n  proc symAddr(lib: LibHandle, name: cstring): pointer =\n    result = cast[pointer](getProcAddress(cast[HMODULE](lib), name))\n\nelse:\n  {.error: \"no implementation for dynlib\".}\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-nim-1.4.2-clhxocckl4vjqcsapqox2ghfzra4c4ma/spack-src/lib/posix/posix.nim": "#\n#\n#            Nim's Runtime Library\n#        (c) Copyright 2012 Andreas Rumpf\n#\n#    See the file \"copying.txt\", included in this\n#    distribution, for details about the copyright.\n#\n\n# Until std_arg!!\n# done: ipc, pwd, stat, semaphore, sys/types, sys/utsname, pthread, unistd,\n# statvfs, mman, time, wait, signal, nl_types, sched, spawn, select, ucontext,\n# net/if, sys/socket, sys/uio, netinet/in, netinet/tcp, netdb\n\n## This is a raw POSIX interface module. It does not not provide any\n## convenience: cstrings are used instead of proper Nim strings and\n## return codes indicate errors. If you want exceptions\n## and a proper Nim-like interface, use the OS module or write a wrapper.\n##\n## For high-level wrappers specialized for Linux and BSDs see:\n## `posix_utils <posix_utils.html>`_\n##\n## Coding conventions:\n## ALL types are named the same as in the POSIX standard except that they start\n## with 'T' or 'P' (if they are pointers) and without the '_t' suffix to be\n## consistent with Nim conventions. If an identifier is a Nim keyword\n## the \\`identifier\\` notation is used.\n##\n## This library relies on the header files of your C compiler. The\n## resulting C code will just ``#include <XYZ.h>`` and *not* define the\n## symbols declared here.\n\n# Dead code elimination ensures that we don't accidentally generate #includes\n# for files that might not exist on a specific platform! The user will get an\n# error only if they actually try to use the missing declaration\n\nwhen defined(nimHasStyleChecks):\n  {.push styleChecks: off.}\n\n# TODO these constants don't seem to be fetched from a header file for unknown\n#      platforms - where do they come from and why are they here?\nwhen false:\n  const\n    C_IRUSR = 0o000400 ## Read by owner.\n    C_IWUSR = 0o000200 ## Write by owner.\n    C_IXUSR = 0o000100 ## Execute by owner.\n    C_IRGRP = 0o000040 ## Read by group.\n    C_IWGRP = 0o000020 ## Write by group.\n    C_IXGRP = 0o000010 ## Execute by group.\n    C_IROTH = 0o000004 ## Read by others.\n    C_IWOTH = 0o000002 ## Write by others.\n    C_IXOTH = 0o000001 ## Execute by others.\n    C_ISUID = 0o004000 ## Set user ID.\n    C_ISGID = 0o002000 ## Set group ID.\n    C_ISVTX = 0o001000 ## On directories, restricted deletion flag.\n    C_ISDIR = 0o040000 ## Directory.\n    C_ISFIFO = 0o010000 ##FIFO.\n    C_ISREG = 0o100000 ## Regular file.\n    C_ISBLK = 0o060000 ## Block special.\n    C_ISCHR = 0o020000 ## Character special.\n    C_ISCTG = 0o110000 ## Reserved.\n    C_ISLNK = 0o120000 ## Symbolic link.</p>\n    C_ISSOCK = 0o140000 ## Socket.\n\nconst\n  MM_NULLLBL* = nil\n  MM_NULLSEV* = 0\n  MM_NULLMC* = 0\n  MM_NULLTXT* = nil\n  MM_NULLACT* = nil\n  MM_NULLTAG* = nil\n\n  STDERR_FILENO* = 2 ## File number of stderr;\n  STDIN_FILENO* = 0  ## File number of stdin;\n  STDOUT_FILENO* = 1 ## File number of stdout;\n\n  DT_UNKNOWN* = 0 ## Unknown file type.\n  DT_FIFO* = 1    ## Named pipe, or FIFO.\n  DT_CHR* = 2     ## Character device.\n  DT_DIR* = 4     ## Directory.\n  DT_BLK* = 6     ## Block device.\n  DT_REG* = 8     ## Regular file.\n  DT_LNK* = 10    ## Symbolic link.\n  DT_SOCK* = 12   ## UNIX domain socket.\n  DT_WHT* = 14\n\n# Special types\ntype Sighandler = proc (a: cint) {.noconv.}\n\nconst StatHasNanoseconds* = defined(linux) or defined(freebsd) or\n    defined(osx) or defined(openbsd) or defined(dragonfly) or defined(haiku) ## \\\n  ## Boolean flag that indicates if the system supports nanosecond time\n  ## resolution in the fields of ``Stat``. Note that the nanosecond based fields\n  ## (``Stat.st_atim``, ``Stat.st_mtim`` and ``Stat.st_ctim``) can be accessed\n  ## without checking this flag, because this module defines fallback procs\n  ## when they are not available.\n\n# Platform specific stuff\n\nwhen (defined(linux) and not defined(android)) and defined(amd64):\n  include posix_linux_amd64\nelif defined(openbsd) and defined(amd64):\n  include posix_openbsd_amd64\nelif (defined(macos) or defined(macosx) or defined(bsd)) and defined(cpu64):\n  include posix_macos_amd64\nelif defined(nintendoswitch):\n  include posix_nintendoswitch\nelif defined(haiku):\n  include posix_haiku\nelse:\n  include posix_other\n\n# There used to be this name in posix.nim a long time ago, not sure why!\n\nwhen StatHasNanoseconds:\n  proc st_atime*(s: Stat): Time {.inline.} =\n    ## Second-granularity time of last access.\n    result = s.st_atim.tv_sec\n  proc st_mtime*(s: Stat): Time {.inline.} =\n    ## Second-granularity time of last data modification.\n    result = s.st_mtim.tv_sec\n  proc st_ctime*(s: Stat): Time {.inline.} =\n    ## Second-granularity time of last status change.\n    result = s.st_ctim.tv_sec\nelse:\n  proc st_atim*(s: Stat): Timespec {.inline.} =\n    ## Nanosecond-granularity time of last access.\n    result.tv_sec = s.st_atime\n  proc st_mtim*(s: Stat): Timespec {.inline.} =\n    ## Nanosecond-granularity time of last data modification.\n    result.tv_sec = s.st_mtime\n  proc st_ctim*(s: Stat): Timespec {.inline.} =\n    ## Nanosecond-granularity time of last data modification.\n    result.tv_sec = s.st_ctime\n\nwhen hasAioH:\n  proc aio_cancel*(a1: cint, a2: ptr Taiocb): cint {.importc, header: \"<aio.h>\".}\n  proc aio_error*(a1: ptr Taiocb): cint {.importc, header: \"<aio.h>\".}\n  proc aio_fsync*(a1: cint, a2: ptr Taiocb): cint {.importc, header: \"<aio.h>\".}\n  proc aio_read*(a1: ptr Taiocb): cint {.importc, header: \"<aio.h>\".}\n  proc aio_return*(a1: ptr Taiocb): int {.importc, header: \"<aio.h>\".}\n  proc aio_suspend*(a1: ptr ptr Taiocb, a2: cint, a3: ptr Timespec): cint {.\n                   importc, header: \"<aio.h>\".}\n  proc aio_write*(a1: ptr Taiocb): cint {.importc, header: \"<aio.h>\".}\n  proc lio_listio*(a1: cint, a2: ptr ptr Taiocb, a3: cint,\n               a4: ptr SigEvent): cint {.importc, header: \"<aio.h>\".}\n\n# arpa/inet.h\nproc htonl*(a1: uint32): uint32 {.importc, header: \"<arpa/inet.h>\".}\nproc htons*(a1: uint16): uint16 {.importc, header: \"<arpa/inet.h>\".}\nproc ntohl*(a1: uint32): uint32 {.importc, header: \"<arpa/inet.h>\".}\nproc ntohs*(a1: uint16): uint16 {.importc, header: \"<arpa/inet.h>\".}\n\nproc inet_addr*(a1: cstring): InAddrT {.importc, header: \"<arpa/inet.h>\".}\nproc inet_ntoa*(a1: InAddr): cstring {.importc, header: \"<arpa/inet.h>\".}\nproc inet_ntop*(a1: cint, a2: pointer, a3: cstring, a4: int32): cstring {.\n  importc:\"(char *)$1\", header: \"<arpa/inet.h>\".}\nproc inet_pton*(a1: cint, a2: cstring, a3: pointer): cint {.\n  importc, header: \"<arpa/inet.h>\".}\n\nvar\n  in6addr_any* {.importc, header: \"<netinet/in.h>\".}: In6Addr\n  in6addr_loopback* {.importc, header: \"<netinet/in.h>\".}: In6Addr\n\nproc IN6ADDR_ANY_INIT* (): In6Addr {.importc, header: \"<netinet/in.h>\".}\nproc IN6ADDR_LOOPBACK_INIT* (): In6Addr {.importc, header: \"<netinet/in.h>\".}\n\n# dirent.h\nproc closedir*(a1: ptr DIR): cint  {.importc, header: \"<dirent.h>\".}\nproc opendir*(a1: cstring): ptr DIR {.importc, header: \"<dirent.h>\", sideEffect.}\nproc readdir*(a1: ptr DIR): ptr Dirent  {.importc, header: \"<dirent.h>\", sideEffect.}\nproc readdir_r*(a1: ptr DIR, a2: ptr Dirent, a3: ptr ptr Dirent): cint  {.\n                importc, header: \"<dirent.h>\", sideEffect.}\nproc rewinddir*(a1: ptr DIR)  {.importc, header: \"<dirent.h>\".}\nproc seekdir*(a1: ptr DIR, a2: int)  {.importc, header: \"<dirent.h>\".}\nproc telldir*(a1: ptr DIR): int {.importc, header: \"<dirent.h>\".}\n\n# dlfcn.h\nproc dlclose*(a1: pointer): cint {.importc, header: \"<dlfcn.h>\", sideEffect.}\nproc dlerror*(): cstring {.importc, header: \"<dlfcn.h>\", sideEffect.}\nproc dlopen*(a1: cstring, a2: cint): pointer {.importc, header: \"<dlfcn.h>\", sideEffect.}\nproc dlsym*(a1: pointer, a2: cstring): pointer {.importc, header: \"<dlfcn.h>\", sideEffect.}\n\nproc creat*(a1: cstring, a2: Mode): cint {.importc, header: \"<fcntl.h>\", sideEffect.}\nproc fcntl*(a1: cint | SocketHandle, a2: cint): cint {.varargs, importc, header: \"<fcntl.h>\", sideEffect.}\nproc open*(a1: cstring, a2: cint): cint {.varargs, importc, header: \"<fcntl.h>\", sideEffect.}\nproc posix_fadvise*(a1: cint, a2, a3: Off, a4: cint): cint {.\n  importc, header: \"<fcntl.h>\".}\nproc posix_fallocate*(a1: cint, a2, a3: Off): cint {.\n  importc, header: \"<fcntl.h>\".}\n\nwhen not defined(haiku) and not defined(OpenBSD):\n  proc fmtmsg*(a1: int, a2: cstring, a3: cint,\n              a4, a5, a6: cstring): cint {.importc, header: \"<fmtmsg.h>\".}\n\nproc fnmatch*(a1, a2: cstring, a3: cint): cint {.importc, header: \"<fnmatch.h>\".}\nproc ftw*(a1: cstring,\n         a2: proc (x1: cstring, x2: ptr Stat, x3: cint): cint {.noconv.},\n         a3: cint): cint {.importc, header: \"<ftw.h>\".}\nwhen not (defined(linux) and defined(amd64)) and not defined(nintendoswitch):\n  proc nftw*(a1: cstring,\n            a2: proc (x1: cstring, x2: ptr Stat,\n                      x3: cint, x4: ptr FTW): cint {.noconv.},\n            a3: cint,\n            a4: cint): cint {.importc, header: \"<ftw.h>\".}\n\nproc glob*(a1: cstring, a2: cint,\n          a3: proc (x1: cstring, x2: cint): cint {.noconv.},\n          a4: ptr Glob): cint {.importc, header: \"<glob.h>\", sideEffect.}\n  ## Filename globbing. Use `os.walkPattern() <os.html#glob_1>`_ and similar.\n\nproc globfree*(a1: ptr Glob) {.importc, header: \"<glob.h>\".}\n\nproc getgrgid*(a1: Gid): ptr Group {.importc, header: \"<grp.h>\".}\nproc getgrnam*(a1: cstring): ptr Group {.importc, header: \"<grp.h>\".}\nproc getgrgid_r*(a1: Gid, a2: ptr Group, a3: cstring, a4: int,\n                 a5: ptr ptr Group): cint {.importc, header: \"<grp.h>\".}\nproc getgrnam_r*(a1: cstring, a2: ptr Group, a3: cstring,\n                  a4: int, a5: ptr ptr Group): cint {.\n                 importc, header: \"<grp.h>\".}\nproc getgrent*(): ptr Group {.importc, header: \"<grp.h>\".}\nproc endgrent*() {.importc, header: \"<grp.h>\".}\nproc setgrent*() {.importc, header: \"<grp.h>\".}\n\n\nproc iconv_open*(a1, a2: cstring): Iconv {.importc, header: \"<iconv.h>\".}\nproc iconv*(a1: Iconv, a2: var cstring, a3: var int, a4: var cstring,\n            a5: var int): int {.importc, header: \"<iconv.h>\".}\nproc iconv_close*(a1: Iconv): cint {.importc, header: \"<iconv.h>\".}\n\nproc nl_langinfo*(a1: Nl_item): cstring {.importc, header: \"<langinfo.h>\".}\n\nproc basename*(a1: cstring): cstring {.importc, header: \"<libgen.h>\".}\nproc dirname*(a1: cstring): cstring {.importc, header: \"<libgen.h>\".}\n\nproc localeconv*(): ptr Lconv {.importc, header: \"<locale.h>\".}\nproc setlocale*(a1: cint, a2: cstring): cstring {.\n                importc, header: \"<locale.h>\", sideEffect.}\n\nproc strfmon*(a1: cstring, a2: int, a3: cstring): int {.varargs,\n   importc, header: \"<monetary.h>\".}\n\nwhen not defined(nintendoswitch):\n  proc mq_close*(a1: Mqd): cint {.importc, header: \"<mqueue.h>\".}\n  proc mq_getattr*(a1: Mqd, a2: ptr MqAttr): cint {.\n    importc, header: \"<mqueue.h>\".}\n  proc mq_notify*(a1: Mqd, a2: ptr SigEvent): cint {.\n    importc, header: \"<mqueue.h>\".}\n  proc mq_open*(a1: cstring, a2: cint): Mqd {.\n    varargs, importc, header: \"<mqueue.h>\".}\n  proc mq_receive*(a1: Mqd, a2: cstring, a3: int, a4: var int): int {.\n    importc, header: \"<mqueue.h>\".}\n  proc mq_send*(a1: Mqd, a2: cstring, a3: int, a4: int): cint {.\n    importc, header: \"<mqueue.h>\".}\n  proc mq_setattr*(a1: Mqd, a2, a3: ptr MqAttr): cint {.\n    importc, header: \"<mqueue.h>\".}\n\n  proc mq_timedreceive*(a1: Mqd, a2: cstring, a3: int, a4: int,\n                        a5: ptr Timespec): int {.importc, header: \"<mqueue.h>\".}\n  proc mq_timedsend*(a1: Mqd, a2: cstring, a3: int, a4: int,\n                     a5: ptr Timespec): cint {.importc, header: \"<mqueue.h>\".}\n  proc mq_unlink*(a1: cstring): cint {.importc, header: \"<mqueue.h>\".}\n\n\nproc getpwnam*(a1: cstring): ptr Passwd {.importc, header: \"<pwd.h>\".}\nproc getpwuid*(a1: Uid): ptr Passwd {.importc, header: \"<pwd.h>\".}\nproc getpwnam_r*(a1: cstring, a2: ptr Passwd, a3: cstring, a4: int,\n                 a5: ptr ptr Passwd): cint {.importc, header: \"<pwd.h>\".}\nproc getpwuid_r*(a1: Uid, a2: ptr Passwd, a3: cstring,\n      a4: int, a5: ptr ptr Passwd): cint {.importc, header: \"<pwd.h>\".}\nproc endpwent*() {.importc, header: \"<pwd.h>\".}\nproc getpwent*(): ptr Passwd {.importc, header: \"<pwd.h>\".}\nproc setpwent*() {.importc, header: \"<pwd.h>\".}\n\nproc uname*(a1: var Utsname): cint {.importc, header: \"<sys/utsname.h>\".}\n\nproc strerror*(errnum: cint): cstring {.importc, header: \"<string.h>\".}\n\nproc pthread_atfork*(a1, a2, a3: proc () {.noconv.}): cint {.\n  importc, header: \"<pthread.h>\".}\nproc pthread_attr_destroy*(a1: ptr Pthread_attr): cint {.\n  importc, header: \"<pthread.h>\".}\nproc pthread_attr_getdetachstate*(a1: ptr Pthread_attr, a2: cint): cint {.\n  importc, header: \"<pthread.h>\".}\nproc pthread_attr_getguardsize*(a1: ptr Pthread_attr, a2: var cint): cint {.\n  importc, header: \"<pthread.h>\".}\nproc pthread_attr_getinheritsched*(a1: ptr Pthread_attr,\n          a2: var cint): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_attr_getschedparam*(a1: ptr Pthread_attr,\n          a2: ptr Sched_param): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_attr_getschedpolicy*(a1: ptr Pthread_attr,\n          a2: var cint): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_attr_getscope*(a1: ptr Pthread_attr,\n          a2: var cint): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_attr_getstack*(a1: ptr Pthread_attr,\n         a2: var pointer, a3: var int): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_attr_getstackaddr*(a1: ptr Pthread_attr,\n          a2: var pointer): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_attr_getstacksize*(a1: ptr Pthread_attr,\n          a2: var int): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_attr_init*(a1: ptr Pthread_attr): cint {.\n  importc, header: \"<pthread.h>\".}\nproc pthread_attr_setdetachstate*(a1: ptr Pthread_attr, a2: cint): cint {.\n  importc, header: \"<pthread.h>\".}\nproc pthread_attr_setguardsize*(a1: ptr Pthread_attr, a2: int): cint {.\n  importc, header: \"<pthread.h>\".}\nproc pthread_attr_setinheritsched*(a1: ptr Pthread_attr, a2: cint): cint {.\n  importc, header: \"<pthread.h>\".}\nproc pthread_attr_setschedparam*(a1: ptr Pthread_attr,\n          a2: ptr Sched_param): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_attr_setschedpolicy*(a1: ptr Pthread_attr, a2: cint): cint {.\n  importc, header: \"<pthread.h>\".}\nproc pthread_attr_setscope*(a1: ptr Pthread_attr, a2: cint): cint {.importc,\n  header: \"<pthread.h>\".}\nproc pthread_attr_setstack*(a1: ptr Pthread_attr, a2: pointer, a3: int): cint {.\n  importc, header: \"<pthread.h>\".}\nproc pthread_attr_setstackaddr*(a1: ptr Pthread_attr, a2: pointer): cint {.\n  importc, header: \"<pthread.h>\".}\nproc pthread_attr_setstacksize*(a1: ptr Pthread_attr, a2: int): cint {.\n  importc, header: \"<pthread.h>\".}\nproc pthread_barrier_destroy*(a1: ptr Pthread_barrier): cint {.\n  importc, header: \"<pthread.h>\".}\nproc pthread_barrier_init*(a1: ptr Pthread_barrier,\n         a2: ptr Pthread_barrierattr, a3: cint): cint {.\n         importc, header: \"<pthread.h>\".}\nproc pthread_barrier_wait*(a1: ptr Pthread_barrier): cint {.\n  importc, header: \"<pthread.h>\".}\nproc pthread_barrierattr_destroy*(a1: ptr Pthread_barrierattr): cint {.\n  importc, header: \"<pthread.h>\".}\nproc pthread_barrierattr_getpshared*(\n          a1: ptr Pthread_barrierattr, a2: var cint): cint {.\n          importc, header: \"<pthread.h>\".}\nproc pthread_barrierattr_init*(a1: ptr Pthread_barrierattr): cint {.\n  importc, header: \"<pthread.h>\".}\nproc pthread_barrierattr_setpshared*(a1: ptr Pthread_barrierattr,\n  a2: cint): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_cancel*(a1: Pthread): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_cleanup_push*(a1: proc (x: pointer) {.noconv.}, a2: pointer) {.\n  importc, header: \"<pthread.h>\".}\nproc pthread_cleanup_pop*(a1: cint) {.importc, header: \"<pthread.h>\".}\nproc pthread_cond_broadcast*(a1: ptr Pthread_cond): cint {.\n  importc, header: \"<pthread.h>\".}\nproc pthread_cond_destroy*(a1: ptr Pthread_cond): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_cond_init*(a1: ptr Pthread_cond,\n          a2: ptr Pthread_condattr): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_cond_signal*(a1: ptr Pthread_cond): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_cond_timedwait*(a1: ptr Pthread_cond,\n          a2: ptr Pthread_mutex, a3: ptr Timespec): cint {.importc, header: \"<pthread.h>\".}\n\nproc pthread_cond_wait*(a1: ptr Pthread_cond,\n          a2: ptr Pthread_mutex): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_condattr_destroy*(a1: ptr Pthread_condattr): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_condattr_getclock*(a1: ptr Pthread_condattr,\n          a2: var ClockId): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_condattr_getpshared*(a1: ptr Pthread_condattr,\n          a2: var cint): cint {.importc, header: \"<pthread.h>\".}\n\nproc pthread_condattr_init*(a1: ptr Pthread_condattr): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_condattr_setclock*(a1: ptr Pthread_condattr,a2: ClockId): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_condattr_setpshared*(a1: ptr Pthread_condattr, a2: cint): cint {.importc, header: \"<pthread.h>\".}\n\nproc pthread_create*(a1: ptr Pthread, a2: ptr Pthread_attr,\n          a3: proc (x: pointer): pointer {.noconv.}, a4: pointer): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_detach*(a1: Pthread): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_equal*(a1, a2: Pthread): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_exit*(a1: pointer) {.importc, header: \"<pthread.h>\".}\nproc pthread_getconcurrency*(): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_getcpuclockid*(a1: Pthread, a2: var ClockId): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_getschedparam*(a1: Pthread,  a2: var cint,\n          a3: ptr Sched_param): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_getspecific*(a1: Pthread_key): pointer {.importc, header: \"<pthread.h>\".}\nproc pthread_join*(a1: Pthread, a2: ptr pointer): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_key_create*(a1: ptr Pthread_key, a2: proc (x: pointer) {.noconv.}): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_key_delete*(a1: Pthread_key): cint {.importc, header: \"<pthread.h>\".}\n\nproc pthread_mutex_destroy*(a1: ptr Pthread_mutex): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_mutex_getprioceiling*(a1: ptr Pthread_mutex,\n         a2: var cint): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_mutex_init*(a1: ptr Pthread_mutex,\n          a2: ptr Pthread_mutexattr): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_mutex_lock*(a1: ptr Pthread_mutex): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_mutex_setprioceiling*(a1: ptr Pthread_mutex,a2: cint,\n          a3: var cint): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_mutex_timedlock*(a1: ptr Pthread_mutex,\n          a2: ptr Timespec): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_mutex_trylock*(a1: ptr Pthread_mutex): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_mutex_unlock*(a1: ptr Pthread_mutex): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_mutexattr_destroy*(a1: ptr Pthread_mutexattr): cint {.importc, header: \"<pthread.h>\".}\n\nproc pthread_mutexattr_getprioceiling*(\n          a1: ptr Pthread_mutexattr, a2: var cint): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_mutexattr_getprotocol*(a1: ptr Pthread_mutexattr,\n          a2: var cint): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_mutexattr_getpshared*(a1: ptr Pthread_mutexattr,\n          a2: var cint): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_mutexattr_gettype*(a1: ptr Pthread_mutexattr,\n          a2: var cint): cint {.importc, header: \"<pthread.h>\".}\n\nproc pthread_mutexattr_init*(a1: ptr Pthread_mutexattr): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_mutexattr_setprioceiling*(a1: ptr Pthread_mutexattr, a2: cint): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_mutexattr_setprotocol*(a1: ptr Pthread_mutexattr, a2: cint): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_mutexattr_setpshared*(a1: ptr Pthread_mutexattr, a2: cint): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_mutexattr_settype*(a1: ptr Pthread_mutexattr, a2: cint): cint {.importc, header: \"<pthread.h>\".}\n\nproc pthread_once*(a1: ptr Pthread_once, a2: proc () {.noconv.}): cint {.importc, header: \"<pthread.h>\".}\n\nproc pthread_rwlock_destroy*(a1: ptr Pthread_rwlock): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_rwlock_init*(a1: ptr Pthread_rwlock,\n          a2: ptr Pthread_rwlockattr): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_rwlock_rdlock*(a1: ptr Pthread_rwlock): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_rwlock_timedrdlock*(a1: ptr Pthread_rwlock,\n          a2: ptr Timespec): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_rwlock_timedwrlock*(a1: ptr Pthread_rwlock,\n          a2: ptr Timespec): cint {.importc, header: \"<pthread.h>\".}\n\nproc pthread_rwlock_tryrdlock*(a1: ptr Pthread_rwlock): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_rwlock_trywrlock*(a1: ptr Pthread_rwlock): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_rwlock_unlock*(a1: ptr Pthread_rwlock): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_rwlock_wrlock*(a1: ptr Pthread_rwlock): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_rwlockattr_destroy*(a1: ptr Pthread_rwlockattr): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_rwlockattr_getpshared*(\n          a1: ptr Pthread_rwlockattr, a2: var cint): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_rwlockattr_init*(a1: ptr Pthread_rwlockattr): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_rwlockattr_setpshared*(a1: ptr Pthread_rwlockattr, a2: cint): cint {.importc, header: \"<pthread.h>\".}\n\nproc pthread_self*(): Pthread {.importc, header: \"<pthread.h>\".}\nproc pthread_setcancelstate*(a1: cint, a2: var cint): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_setcanceltype*(a1: cint, a2: var cint): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_setconcurrency*(a1: cint): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_setschedparam*(a1: Pthread, a2: cint,\n          a3: ptr Sched_param): cint {.importc, header: \"<pthread.h>\".}\n\nproc pthread_setschedprio*(a1: Pthread, a2: cint): cint {.\n  importc, header: \"<pthread.h>\".}\nproc pthread_setspecific*(a1: Pthread_key, a2: pointer): cint {.\n  importc, header: \"<pthread.h>\".}\nproc pthread_spin_destroy*(a1: ptr Pthread_spinlock): cint {.\n  importc, header: \"<pthread.h>\".}\nproc pthread_spin_init*(a1: ptr Pthread_spinlock, a2: cint): cint {.\n  importc, header: \"<pthread.h>\".}\nproc pthread_spin_lock*(a1: ptr Pthread_spinlock): cint {.\n  importc, header: \"<pthread.h>\".}\nproc pthread_spin_trylock*(a1: ptr Pthread_spinlock): cint{.\n  importc, header: \"<pthread.h>\".}\nproc pthread_spin_unlock*(a1: ptr Pthread_spinlock): cint {.\n  importc, header: \"<pthread.h>\".}\nproc pthread_testcancel*() {.importc, header: \"<pthread.h>\".}\n\n\nproc exitnow*(code: int): void {.importc: \"_exit\", header: \"<unistd.h>\".}\nproc access*(a1: cstring, a2: cint): cint {.importc, header: \"<unistd.h>\".}\nproc alarm*(a1: cint): cint {.importc, header: \"<unistd.h>\".}\nproc chdir*(a1: cstring): cint {.importc, header: \"<unistd.h>\".}\nproc chown*(a1: cstring, a2: Uid, a3: Gid): cint {.importc, header: \"<unistd.h>\".}\nproc close*(a1: cint | SocketHandle): cint {.importc, header: \"<unistd.h>\".}\nproc confstr*(a1: cint, a2: cstring, a3: int): int {.importc, header: \"<unistd.h>\".}\nproc crypt*(a1, a2: cstring): cstring {.importc, header: \"<unistd.h>\".}\nproc ctermid*(a1: cstring): cstring {.importc, header: \"<unistd.h>\".}\nproc dup*(a1: cint): cint {.importc, header: \"<unistd.h>\".}\nproc dup2*(a1, a2: cint): cint {.importc, header: \"<unistd.h>\".}\nproc encrypt*(a1: array[0..63, char], a2: cint) {.importc, header: \"<unistd.h>\".}\n\nproc execl*(a1, a2: cstring): cint {.varargs, importc, header: \"<unistd.h>\", sideEffect.}\nproc execle*(a1, a2: cstring): cint {.varargs, importc, header: \"<unistd.h>\", sideEffect.}\nproc execlp*(a1, a2: cstring): cint {.varargs, importc, header: \"<unistd.h>\", sideEffect.}\nproc execv*(a1: cstring, a2: cstringArray): cint {.importc, header: \"<unistd.h>\", sideEffect.}\nproc execve*(a1: cstring, a2, a3: cstringArray): cint {.\n  importc, header: \"<unistd.h>\", sideEffect.}\nproc execvp*(a1: cstring, a2: cstringArray): cint {.importc, header: \"<unistd.h>\", sideEffect.}\nproc execvpe*(a1: cstring, a2: cstringArray, a3: cstringArray): cint {.importc, header: \"<unistd.h>\", sideEffect.}\nproc fchown*(a1: cint, a2: Uid, a3: Gid): cint {.importc, header: \"<unistd.h>\", sideEffect.}\nproc fchdir*(a1: cint): cint {.importc, header: \"<unistd.h>\", sideEffect.}\nproc fdatasync*(a1: cint): cint {.importc, header: \"<unistd.h>\".}\nproc fork*(): Pid {.importc, header: \"<unistd.h>\", sideEffect.}\nproc fpathconf*(a1, a2: cint): int {.importc, header: \"<unistd.h>\".}\nproc fsync*(a1: cint): cint {.importc, header: \"<unistd.h>\".}\n ## synchronize a file's buffer cache to the storage device\n\nproc ftruncate*(a1: cint, a2: Off): cint {.importc, header: \"<unistd.h>\".}\nproc getcwd*(a1: cstring, a2: int): cstring {.importc, header: \"<unistd.h>\", sideEffect.}\nproc getuid*(): Uid {.importc, header: \"<unistd.h>\", sideEffect.}\n ## returns the real user ID of the calling process\n\nproc geteuid*(): Uid {.importc, header: \"<unistd.h>\", sideEffect.}\n ## returns the effective user ID of the calling process\n\nproc getgid*(): Gid {.importc, header: \"<unistd.h>\", sideEffect.}\n ## returns the real group ID of the calling process\n\nproc getegid*(): Gid {.importc, header: \"<unistd.h>\", sideEffect.}\n ## returns the effective group ID of the calling process\n\nproc getgroups*(a1: cint, a2: ptr array[0..255, Gid]): cint {.\n  importc, header: \"<unistd.h>\".}\nproc gethostid*(): int {.importc, header: \"<unistd.h>\", sideEffect.}\nproc gethostname*(a1: cstring, a2: int): cint {.importc, header: \"<unistd.h>\", sideEffect.}\nproc getlogin*(): cstring {.importc, header: \"<unistd.h>\", sideEffect.}\nproc getlogin_r*(a1: cstring, a2: int): cint {.importc, header: \"<unistd.h>\", sideEffect.}\n\nproc getopt*(a1: cint, a2: cstringArray, a3: cstring): cint {.\n  importc, header: \"<unistd.h>\".}\nproc getpgid*(a1: Pid): Pid {.importc, header: \"<unistd.h>\".}\nproc getpgrp*(): Pid {.importc, header: \"<unistd.h>\".}\nproc getpid*(): Pid {.importc, header: \"<unistd.h>\", sideEffect.}\n ## returns  the process ID (PID) of the calling process\n\nproc getppid*(): Pid {.importc, header: \"<unistd.h>\", sideEffect.}\n ## returns the process ID of the parent of the calling process\n\nproc getsid*(a1: Pid): Pid {.importc, header: \"<unistd.h>\", sideEffect.}\n ## returns the session ID of the calling process\n\nproc getwd*(a1: cstring): cstring {.importc, header: \"<unistd.h>\".}\nproc isatty*(a1: cint): cint {.importc, header: \"<unistd.h>\".}\nproc lchown*(a1: cstring, a2: Uid, a3: Gid): cint {.importc, header: \"<unistd.h>\".}\nproc link*(a1, a2: cstring): cint {.importc, header: \"<unistd.h>\".}\n\nproc lockf*(a1, a2: cint, a3: Off): cint {.importc, header: \"<unistd.h>\".}\nproc lseek*(a1: cint, a2: Off, a3: cint): Off {.importc, header: \"<unistd.h>\".}\nproc nice*(a1: cint): cint {.importc, header: \"<unistd.h>\".}\nproc pathconf*(a1: cstring, a2: cint): int {.importc, header: \"<unistd.h>\".}\n\nproc pause*(): cint {.importc, header: \"<unistd.h>\".}\nproc pclose*(a: File): cint {.importc, header: \"<stdio.h>\".}\nproc pipe*(a: array[0..1, cint]): cint {.importc, header: \"<unistd.h>\".}\nproc popen*(a1, a2: cstring): File {.importc, header: \"<stdio.h>\".}\nproc pread*(a1: cint, a2: pointer, a3: int, a4: Off): int {.\n  importc, header: \"<unistd.h>\".}\nproc pwrite*(a1: cint, a2: pointer, a3: int, a4: Off): int {.\n  importc, header: \"<unistd.h>\".}\nproc read*(a1: cint, a2: pointer, a3: int): int {.importc, header: \"<unistd.h>\".}\nproc readlink*(a1, a2: cstring, a3: int): int {.importc, header: \"<unistd.h>\".}\nproc ioctl*(f: FileHandle, device: uint): int {.importc: \"ioctl\",\n      header: \"<sys/ioctl.h>\", varargs, tags: [WriteIOEffect].}\n  ## A system call for device-specific input/output operations and other\n  ## operations which cannot be expressed by regular system calls\n\nproc rmdir*(a1: cstring): cint {.importc, header: \"<unistd.h>\".}\nproc setegid*(a1: Gid): cint {.importc, header: \"<unistd.h>\".}\nproc seteuid*(a1: Uid): cint {.importc, header: \"<unistd.h>\".}\nproc setgid*(a1: Gid): cint {.importc, header: \"<unistd.h>\".}\n\nproc setpgid*(a1, a2: Pid): cint {.importc, header: \"<unistd.h>\".}\nproc setpgrp*(): Pid {.importc, header: \"<unistd.h>\".}\nproc setregid*(a1, a2: Gid): cint {.importc, header: \"<unistd.h>\".}\nproc setreuid*(a1, a2: Uid): cint {.importc, header: \"<unistd.h>\".}\nproc setsid*(): Pid {.importc, header: \"<unistd.h>\".}\nproc setuid*(a1: Uid): cint {.importc, header: \"<unistd.h>\".}\nproc sleep*(a1: cint): cint {.importc, header: \"<unistd.h>\".}\nproc swab*(a1, a2: pointer, a3: int) {.importc, header: \"<unistd.h>\".}\nproc symlink*(a1, a2: cstring): cint {.importc, header: \"<unistd.h>\".}\nproc sync*() {.importc, header: \"<unistd.h>\".}\nproc sysconf*(a1: cint): int {.importc, header: \"<unistd.h>\".}\nproc tcgetpgrp*(a1: cint): Pid {.importc, header: \"<unistd.h>\".}\nproc tcsetpgrp*(a1: cint, a2: Pid): cint {.importc, header: \"<unistd.h>\".}\nproc truncate*(a1: cstring, a2: Off): cint {.importc, header: \"<unistd.h>\".}\nproc ttyname*(a1: cint): cstring {.importc, header: \"<unistd.h>\".}\nproc ttyname_r*(a1: cint, a2: cstring, a3: int): cint {.\n  importc, header: \"<unistd.h>\".}\nproc ualarm*(a1, a2: Useconds): Useconds {.importc, header: \"<unistd.h>\".}\nproc unlink*(a1: cstring): cint {.importc, header: \"<unistd.h>\".}\nproc usleep*(a1: Useconds): cint {.importc, header: \"<unistd.h>\".}\nproc vfork*(): Pid {.importc, header: \"<unistd.h>\".}\nproc write*(a1: cint, a2: pointer, a3: int): int {.importc, header: \"<unistd.h>\".}\n\nproc sem_close*(a1: ptr Sem): cint {.importc, header: \"<semaphore.h>\".}\nproc sem_destroy*(a1: ptr Sem): cint {.importc, header: \"<semaphore.h>\".}\nproc sem_getvalue*(a1: ptr Sem, a2: var cint): cint {.\n  importc, header: \"<semaphore.h>\".}\nproc sem_init*(a1: ptr Sem, a2: cint, a3: cint): cint {.\n  importc, header: \"<semaphore.h>\".}\nproc sem_open*(a1: cstring, a2: cint): ptr Sem {.\n  varargs, importc, header: \"<semaphore.h>\".}\nproc sem_post*(a1: ptr Sem): cint {.importc, header: \"<semaphore.h>\".}\nproc sem_timedwait*(a1: ptr Sem, a2: ptr Timespec): cint {.\n  importc, header: \"<semaphore.h>\".}\nproc sem_trywait*(a1: ptr Sem): cint {.importc, header: \"<semaphore.h>\".}\nproc sem_unlink*(a1: cstring): cint {.importc, header: \"<semaphore.h>\".}\nproc sem_wait*(a1: ptr Sem): cint {.importc, header: \"<semaphore.h>\".}\n\nproc ftok*(a1: cstring, a2: cint): Key {.importc, header: \"<sys/ipc.h>\".}\n\nproc statvfs*(a1: cstring, a2: var Statvfs): cint {.\n  importc, header: \"<sys/statvfs.h>\".}\nproc fstatvfs*(a1: cint, a2: var Statvfs): cint {.\n  importc, header: \"<sys/statvfs.h>\".}\n\nproc chmod*(a1: cstring, a2: Mode): cint {.importc, header: \"<sys/stat.h>\", sideEffect.}\nproc fchmod*(a1: cint, a2: Mode): cint {.importc, header: \"<sys/stat.h>\", sideEffect.}\nproc fstat*(a1: cint, a2: var Stat): cint {.importc, header: \"<sys/stat.h>\", sideEffect.}\nproc lstat*(a1: cstring, a2: var Stat): cint {.importc, header: \"<sys/stat.h>\", sideEffect.}\nproc mkdir*(a1: cstring, a2: Mode): cint {.importc, header: \"<sys/stat.h>\", sideEffect.}\n  ## Use `os.createDir() <os.html#createDir,string>`_ and similar.\n\nproc mkfifo*(a1: cstring, a2: Mode): cint {.importc, header: \"<sys/stat.h>\".}\nproc mknod*(a1: cstring, a2: Mode, a3: Dev): cint {.\n  importc, header: \"<sys/stat.h>\".}\nproc stat*(a1: cstring, a2: var Stat): cint {.importc, header: \"<sys/stat.h>\".}\nproc umask*(a1: Mode): Mode {.importc, header: \"<sys/stat.h>\".}\n\nproc S_ISBLK*(m: Mode): bool {.importc, header: \"<sys/stat.h>\".}\n  ## Test for a block special file.\nproc S_ISCHR*(m: Mode): bool {.importc, header: \"<sys/stat.h>\".}\n  ## Test for a character special file.\nproc S_ISDIR*(m: Mode): bool {.importc, header: \"<sys/stat.h>\".}\n  ## Test for a directory.\nproc S_ISFIFO*(m: Mode): bool {.importc, header: \"<sys/stat.h>\".}\n  ## Test for a pipe or FIFO special file.\nproc S_ISREG*(m: Mode): bool {.importc, header: \"<sys/stat.h>\".}\n  ## Test for a regular file.\nproc S_ISLNK*(m: Mode): bool {.importc, header: \"<sys/stat.h>\".}\n  ## Test for a symbolic link.\nproc S_ISSOCK*(m: Mode): bool {.importc, header: \"<sys/stat.h>\".}\n  ## Test for a socket.\n\nproc S_TYPEISMQ*(buf: var Stat): bool {.importc, header: \"<sys/stat.h>\".}\n  ## Test for a message queue.\nproc S_TYPEISSEM*(buf: var Stat): bool {.importc, header: \"<sys/stat.h>\".}\n  ## Test for a semaphore.\nproc S_TYPEISSHM*(buf: var Stat): bool {.importc, header: \"<sys/stat.h>\".}\n  ## Test for a shared memory object.\n\nproc S_TYPEISTMO*(buf: var Stat): bool {.importc, header: \"<sys/stat.h>\".}\n  ## Test macro for a typed memory object.\n\nproc mlock*(a1: pointer, a2: int): cint {.importc, header: \"<sys/mman.h>\".}\nproc mlockall*(a1: cint): cint {.importc, header: \"<sys/mman.h>\".}\nproc mmap*(a1: pointer, a2: int, a3, a4, a5: cint, a6: Off): pointer {.\n  importc, header: \"<sys/mman.h>\".}\nproc mprotect*(a1: pointer, a2: int, a3: cint): cint {.\n  importc, header: \"<sys/mman.h>\".}\nproc msync*(a1: pointer, a2: int, a3: cint): cint {.importc, header: \"<sys/mman.h>\".}\n\nproc munlock*(a1: pointer, a2: int): cint {.importc, header: \"<sys/mman.h>\".}\nproc munlockall*(): cint {.importc, header: \"<sys/mman.h>\".}\nproc munmap*(a1: pointer, a2: int): cint {.importc, header: \"<sys/mman.h>\".}\nproc posix_madvise*(a1: pointer, a2: int, a3: cint): cint {.\n  importc, header: \"<sys/mman.h>\".}\nproc posix_mem_offset*(a1: pointer, a2: int, a3: var Off,\n           a4: var int, a5: var cint): cint {.importc, header: \"<sys/mman.h>\".}\nwhen not (defined(linux) and defined(amd64)) and not defined(nintendoswitch) and\n     not defined(haiku):\n  proc posix_typed_mem_get_info*(a1: cint,\n    a2: var Posix_typed_mem_info): cint {.importc, header: \"<sys/mman.h>\".}\nproc posix_typed_mem_open*(a1: cstring, a2, a3: cint): cint {.\n  importc, header: \"<sys/mman.h>\".}\nproc shm_open*(a1: cstring, a2: cint, a3: Mode): cint {.\n  importc, header: \"<sys/mman.h>\".}\nproc shm_unlink*(a1: cstring): cint {.importc, header: \"<sys/mman.h>\".}\n\nproc asctime*(a1: var Tm): cstring{.importc, header: \"<time.h>\".}\n\nproc asctime_r*(a1: var Tm, a2: cstring): cstring {.importc, header: \"<time.h>\".}\nproc clock*(): Clock {.importc, header: \"<time.h>\", sideEffect.}\nproc clock_getcpuclockid*(a1: Pid, a2: var ClockId): cint {.\n  importc, header: \"<time.h>\", sideEffect.}\nproc clock_getres*(a1: ClockId, a2: var Timespec): cint {.\n  importc, header: \"<time.h>\", sideEffect.}\nproc clock_gettime*(a1: ClockId, a2: var Timespec): cint {.\n  importc, header: \"<time.h>\", sideEffect.}\nproc clock_nanosleep*(a1: ClockId, a2: cint, a3: var Timespec,\n               a4: var Timespec): cint {.importc, header: \"<time.h>\", sideEffect.}\nproc clock_settime*(a1: ClockId, a2: var Timespec): cint {.\n  importc, header: \"<time.h>\", sideEffect.}\n\nproc `==`*(a, b: Time): bool {.borrow.}\nproc `-`*(a, b: Time): Time {.borrow.}\nproc ctime*(a1: var Time): cstring {.importc, header: \"<time.h>\".}\nproc ctime_r*(a1: var Time, a2: cstring): cstring {.importc, header: \"<time.h>\".}\nproc difftime*(a1, a2: Time): cdouble {.importc, header: \"<time.h>\".}\nproc getdate*(a1: cstring): ptr Tm {.importc, header: \"<time.h>\".}\nproc gmtime*(a1: var Time): ptr Tm {.importc, header: \"<time.h>\".}\nproc gmtime_r*(a1: var Time, a2: var Tm): ptr Tm {.importc, header: \"<time.h>\".}\nproc localtime*(a1: var Time): ptr Tm {.importc, header: \"<time.h>\".}\nproc localtime_r*(a1: var Time, a2: var Tm): ptr Tm {.importc, header: \"<time.h>\".}\nproc mktime*(a1: var Tm): Time  {.importc, header: \"<time.h>\".}\nproc timegm*(a1: var Tm): Time  {.importc, header: \"<time.h>\".}\nproc nanosleep*(a1, a2: var Timespec): cint {.importc, header: \"<time.h>\", sideEffect.}\nproc strftime*(a1: cstring, a2: int, a3: cstring,\n           a4: var Tm): int {.importc, header: \"<time.h>\".}\nproc strptime*(a1, a2: cstring, a3: var Tm): cstring {.importc, header: \"<time.h>\".}\nproc time*(a1: var Time): Time {.importc, header: \"<time.h>\", sideEffect.}\nproc timer_create*(a1: ClockId, a2: var SigEvent,\n               a3: var Timer): cint {.importc, header: \"<time.h>\".}\nproc timer_delete*(a1: Timer): cint {.importc, header: \"<time.h>\".}\nproc timer_gettime*(a1: Timer, a2: var Itimerspec): cint {.\n  importc, header: \"<time.h>\".}\nproc timer_getoverrun*(a1: Timer): cint {.importc, header: \"<time.h>\".}\nproc timer_settime*(a1: Timer, a2: cint, a3: var Itimerspec,\n               a4: var Itimerspec): cint {.importc, header: \"<time.h>\".}\nproc tzset*() {.importc, header: \"<time.h>\".}\n\n\nproc wait*(a1: ptr cint): Pid {.importc, discardable, header: \"<sys/wait.h>\", sideEffect.}\nproc waitid*(a1: cint, a2: Id, a3: var SigInfo, a4: cint): cint {.\n  importc, header: \"<sys/wait.h>\", sideEffect.}\nproc waitpid*(a1: Pid, a2: var cint, a3: cint): Pid {.\n  importc, header: \"<sys/wait.h>\", sideEffect.}\n\ntype Rusage* {.importc: \"struct rusage\", header: \"<sys/resource.h>\",\n               bycopy.} = object\n  ru_utime*, ru_stime*: Timeval                       # User and system time\n  ru_maxrss*, ru_ixrss*, ru_idrss*, ru_isrss*,        # memory sizes\n    ru_minflt*, ru_majflt*, ru_nswap*,                # paging activity\n    ru_inblock*, ru_oublock*, ru_msgsnd*, ru_msgrcv*, # IO activity\n    ru_nsignals*, ru_nvcsw*, ru_nivcsw*: clong        # switching activity\n\nproc wait4*(pid: Pid, status: ptr cint, options: cint, rusage: ptr Rusage): Pid\n  {.importc, header: \"<sys/wait.h>\", sideEffect.}\n\nconst\n  RUSAGE_SELF* = cint(0)\n  RUSAGE_CHILDREN* = cint(-1)\n  RUSAGE_THREAD* = cint(1)    # This one is less std; Linux, BSD agree though.\n\n# This can only fail if `who` is invalid or `rusage` ptr is invalid.\nproc getrusage*(who: cint, rusage: ptr Rusage): cint\n  {.importc, header: \"<sys/resource.h>\", discardable.}\n\nproc bsd_signal*(a1: cint, a2: proc (x: pointer) {.noconv.}) {.\n  importc, header: \"<signal.h>\".}\nproc kill*(a1: Pid, a2: cint): cint {.importc, header: \"<signal.h>\", sideEffect.}\nproc killpg*(a1: Pid, a2: cint): cint {.importc, header: \"<signal.h>\", sideEffect.}\nproc pthread_kill*(a1: Pthread, a2: cint): cint {.importc, header: \"<signal.h>\".}\nproc pthread_sigmask*(a1: cint, a2, a3: var Sigset): cint {.\n  importc, header: \"<signal.h>\".}\nproc `raise`*(a1: cint): cint {.importc, header: \"<signal.h>\".}\nproc sigaction*(a1: cint, a2, a3: var Sigaction): cint {.\n  importc, header: \"<signal.h>\".}\n\nproc sigaction*(a1: cint, a2: var Sigaction; a3: ptr Sigaction = nil): cint {.\n  importc, header: \"<signal.h>\".}\n\nproc sigaddset*(a1: var Sigset, a2: cint): cint {.importc, header: \"<signal.h>\".}\nproc sigaltstack*(a1, a2: var Stack): cint {.importc, header: \"<signal.h>\".}\nproc sigdelset*(a1: var Sigset, a2: cint): cint {.importc, header: \"<signal.h>\".}\nproc sigemptyset*(a1: var Sigset): cint {.importc, header: \"<signal.h>\".}\nproc sigfillset*(a1: var Sigset): cint {.importc, header: \"<signal.h>\".}\nproc sighold*(a1: cint): cint {.importc, header: \"<signal.h>\".}\nproc sigignore*(a1: cint): cint {.importc, header: \"<signal.h>\".}\nproc siginterrupt*(a1, a2: cint): cint {.importc, header: \"<signal.h>\".}\nproc sigismember*(a1: var Sigset, a2: cint): cint {.importc, header: \"<signal.h>\".}\nproc signal*(a1: cint, a2: Sighandler) {.\n  importc, header: \"<signal.h>\".}\nproc sigpause*(a1: cint): cint {.importc, header: \"<signal.h>\".}\nproc sigpending*(a1: var Sigset): cint {.importc, header: \"<signal.h>\".}\nproc sigprocmask*(a1: cint, a2, a3: var Sigset): cint {.\n  importc, header: \"<signal.h>\".}\nproc sigqueue*(a1: Pid, a2: cint, a3: SigVal): cint {.\n  importc, header: \"<signal.h>\".}\nproc sigrelse*(a1: cint): cint {.importc, header: \"<signal.h>\".}\nproc sigset*(a1: int, a2: proc (x: cint) {.noconv.}) {.\n  importc, header: \"<signal.h>\".}\nproc sigsuspend*(a1: var Sigset): cint {.importc, header: \"<signal.h>\".}\n\nwhen defined(android):\n  proc syscall(arg: clong): clong {.varargs, importc: \"syscall\", header: \"<unistd.h>\".}\n  var NR_rt_sigtimedwait {.importc: \"__NR_rt_sigtimedwait\", header: \"<sys/syscall.h>\".}: clong\n  var NSIGMAX {.importc: \"NSIG\", header: \"<signal.h>\".}: clong\n\n  proc sigtimedwait*(a1: var Sigset, a2: var SigInfo, a3: var Timespec): cint =\n    result = cint(syscall(NR_rt_sigtimedwait, addr(a1), addr(a2), addr(a3), NSIGMAX div 8))\nelse:\n  proc sigtimedwait*(a1: var Sigset, a2: var SigInfo,\n                     a3: var Timespec): cint {.importc, header: \"<signal.h>\".}\n\nproc sigwait*(a1: var Sigset, a2: var cint): cint {.\n  importc, header: \"<signal.h>\".}\nproc sigwaitinfo*(a1: var Sigset, a2: var SigInfo): cint {.\n  importc, header: \"<signal.h>\".}\n\nwhen not defined(nintendoswitch):\n  proc catclose*(a1: Nl_catd): cint {.importc, header: \"<nl_types.h>\".}\n  proc catgets*(a1: Nl_catd, a2, a3: cint, a4: cstring): cstring {.\n    importc, header: \"<nl_types.h>\".}\n  proc catopen*(a1: cstring, a2: cint): Nl_catd {.\n    importc, header: \"<nl_types.h>\".}\n\nproc sched_get_priority_max*(a1: cint): cint {.importc, header: \"<sched.h>\".}\nproc sched_get_priority_min*(a1: cint): cint {.importc, header: \"<sched.h>\".}\nproc sched_getparam*(a1: Pid, a2: var Sched_param): cint {.\n  importc, header: \"<sched.h>\".}\nproc sched_getscheduler*(a1: Pid): cint {.importc, header: \"<sched.h>\".}\nproc sched_rr_get_interval*(a1: Pid, a2: var Timespec): cint {.\n  importc, header: \"<sched.h>\".}\nproc sched_setparam*(a1: Pid, a2: var Sched_param): cint {.\n  importc, header: \"<sched.h>\".}\nproc sched_setscheduler*(a1: Pid, a2: cint, a3: var Sched_param): cint {.\n  importc, header: \"<sched.h>\".}\nproc sched_yield*(): cint {.importc, header: \"<sched.h>\".}\n\nproc hstrerror*(herrnum: cint): cstring {.importc:\"(char *)$1\", header: \"<netdb.h>\".}\n\nproc FD_CLR*(a1: cint, a2: var TFdSet) {.importc, header: \"<sys/select.h>\".}\nproc FD_ISSET*(a1: cint | SocketHandle, a2: var TFdSet): cint {.\n  importc, header: \"<sys/select.h>\".}\nproc FD_SET*(a1: cint | SocketHandle, a2: var TFdSet) {.\n  importc: \"FD_SET\", header: \"<sys/select.h>\".}\nproc FD_ZERO*(a1: var TFdSet) {.importc, header: \"<sys/select.h>\".}\n\nproc pselect*(a1: cint, a2, a3, a4: ptr TFdSet, a5: ptr Timespec,\n         a6: var Sigset): cint  {.importc, header: \"<sys/select.h>\".}\nproc select*(a1: cint | SocketHandle, a2, a3, a4: ptr TFdSet, a5: ptr Timeval): cint {.\n             importc, header: \"<sys/select.h>\".}\n\nwhen hasSpawnH:\n  proc posix_spawn*(a1: var Pid, a2: cstring,\n            a3: var Tposix_spawn_file_actions,\n            a4: var Tposix_spawnattr,\n            a5, a6: cstringArray): cint {.importc, header: \"<spawn.h>\".}\n  proc posix_spawn_file_actions_addclose*(a1: var Tposix_spawn_file_actions,\n            a2: cint): cint {.importc, header: \"<spawn.h>\".}\n  proc posix_spawn_file_actions_adddup2*(a1: var Tposix_spawn_file_actions,\n            a2, a3: cint): cint {.importc, header: \"<spawn.h>\".}\n  proc posix_spawn_file_actions_addopen*(a1: var Tposix_spawn_file_actions,\n            a2: cint, a3: cstring, a4: cint, a5: Mode): cint {.\n            importc, header: \"<spawn.h>\".}\n  proc posix_spawn_file_actions_destroy*(\n    a1: var Tposix_spawn_file_actions): cint {.importc, header: \"<spawn.h>\".}\n  proc posix_spawn_file_actions_init*(\n    a1: var Tposix_spawn_file_actions): cint {.importc, header: \"<spawn.h>\".}\n  proc posix_spawnattr_destroy*(a1: var Tposix_spawnattr): cint {.\n    importc, header: \"<spawn.h>\".}\n  proc posix_spawnattr_getsigdefault*(a1: var Tposix_spawnattr,\n            a2: var Sigset): cint {.importc, header: \"<spawn.h>\".}\n  proc posix_spawnattr_getflags*(a1: var Tposix_spawnattr,\n            a2: var cshort): cint {.importc, header: \"<spawn.h>\".}\n  proc posix_spawnattr_getpgroup*(a1: var Tposix_spawnattr,\n            a2: var Pid): cint {.importc, header: \"<spawn.h>\".}\n  proc posix_spawnattr_getschedparam*(a1: var Tposix_spawnattr,\n            a2: var Sched_param): cint {.importc, header: \"<spawn.h>\".}\n  proc posix_spawnattr_getschedpolicy*(a1: var Tposix_spawnattr,\n            a2: var cint): cint {.importc, header: \"<spawn.h>\".}\n  proc posix_spawnattr_getsigmask*(a1: var Tposix_spawnattr,\n            a2: var Sigset): cint {.importc, header: \"<spawn.h>\".}\n\n  proc posix_spawnattr_init*(a1: var Tposix_spawnattr): cint {.\n    importc, header: \"<spawn.h>\".}\n  proc posix_spawnattr_setsigdefault*(a1: var Tposix_spawnattr,\n            a2: var Sigset): cint {.importc, header: \"<spawn.h>\".}\n  proc posix_spawnattr_setflags*(a1: var Tposix_spawnattr, a2: cint): cint {.\n    importc, header: \"<spawn.h>\".}\n  proc posix_spawnattr_setpgroup*(a1: var Tposix_spawnattr, a2: Pid): cint {.\n    importc, header: \"<spawn.h>\".}\n\n  proc posix_spawnattr_setschedparam*(a1: var Tposix_spawnattr,\n            a2: var Sched_param): cint {.importc, header: \"<spawn.h>\".}\n  proc posix_spawnattr_setschedpolicy*(a1: var Tposix_spawnattr,\n                                       a2: cint): cint {.\n                                       importc, header: \"<spawn.h>\".}\n  proc posix_spawnattr_setsigmask*(a1: var Tposix_spawnattr,\n            a2: var Sigset): cint {.importc, header: \"<spawn.h>\".}\n  proc posix_spawnp*(a1: var Pid, a2: cstring,\n            a3: var Tposix_spawn_file_actions,\n            a4: var Tposix_spawnattr,\n            a5, a6: cstringArray): cint {.importc, header: \"<spawn.h>\".}\n\nwhen not defined(nintendoswitch):\n  proc getcontext*(a1: var Ucontext): cint {.importc, header: \"<ucontext.h>\".}\n  proc makecontext*(a1: var Ucontext, a4: proc (){.noconv.}, a3: cint) {.\n    varargs, importc, header: \"<ucontext.h>\".}\n  proc setcontext*(a1: var Ucontext): cint {.importc, header: \"<ucontext.h>\".}\n  proc swapcontext*(a1, a2: var Ucontext): cint {.importc, header: \"<ucontext.h>\".}\n\nproc readv*(a1: cint, a2: ptr IOVec, a3: cint): int {.\n  importc, header: \"<sys/uio.h>\".}\nproc writev*(a1: cint, a2: ptr IOVec, a3: cint): int {.\n  importc, header: \"<sys/uio.h>\".}\n\nproc CMSG_DATA*(cmsg: ptr Tcmsghdr): cstring {.\n  importc, header: \"<sys/socket.h>\".}\n\nproc CMSG_NXTHDR*(mhdr: ptr Tmsghdr, cmsg: ptr Tcmsghdr): ptr Tcmsghdr {.\n  importc, header: \"<sys/socket.h>\".}\n\nproc CMSG_FIRSTHDR*(mhdr: ptr Tmsghdr): ptr Tcmsghdr {.\n  importc, header: \"<sys/socket.h>\".}\n\nproc CMSG_SPACE*(len: csize): csize {.\n  importc, header: \"<sys/socket.h>\", deprecated: \"argument `len` should be of type `csize_t`\".}\n\nproc CMSG_SPACE*(len: csize_t): csize_t {.\n  importc, header: \"<sys/socket.h>\".}\n\nproc CMSG_LEN*(len: csize): csize {.\n  importc, header: \"<sys/socket.h>\", deprecated: \"argument `len` should be of type `csize_t`\".}\n\nproc CMSG_LEN*(len: csize_t): csize_t {.\n  importc, header: \"<sys/socket.h>\".}\n\nconst\n  INVALID_SOCKET* = SocketHandle(-1)\n\nproc `==`*(x, y: SocketHandle): bool {.borrow.}\n\nproc accept*(a1: SocketHandle, a2: ptr SockAddr, a3: ptr SockLen): SocketHandle {.\n  importc, header: \"<sys/socket.h>\", sideEffect.}\n\nwhen defined(linux) or defined(bsd):\n  proc accept4*(a1: SocketHandle, a2: ptr SockAddr, a3: ptr SockLen,\n                flags: cint): SocketHandle {.importc, header: \"<sys/socket.h>\".}\n\nproc bindSocket*(a1: SocketHandle, a2: ptr SockAddr, a3: SockLen): cint {.\n  importc: \"bind\", header: \"<sys/socket.h>\".}\n  ## is Posix's ``bind``, because ``bind`` is a reserved word\n\nproc connect*(a1: SocketHandle, a2: ptr SockAddr, a3: SockLen): cint {.\n  importc, header: \"<sys/socket.h>\".}\nproc getpeername*(a1: SocketHandle, a2: ptr SockAddr, a3: ptr SockLen): cint {.\n  importc, header: \"<sys/socket.h>\".}\nproc getsockname*(a1: SocketHandle, a2: ptr SockAddr, a3: ptr SockLen): cint {.\n  importc, header: \"<sys/socket.h>\".}\n\nproc getsockopt*(a1: SocketHandle, a2, a3: cint, a4: pointer, a5: ptr SockLen): cint {.\n  importc, header: \"<sys/socket.h>\".}\n\nproc listen*(a1: SocketHandle, a2: cint): cint {.\n  importc, header: \"<sys/socket.h>\", sideEffect.}\nproc recv*(a1: SocketHandle, a2: pointer, a3: int, a4: cint): int {.\n  importc, header: \"<sys/socket.h>\", sideEffect.}\nproc recvfrom*(a1: SocketHandle, a2: pointer, a3: int, a4: cint,\n        a5: ptr SockAddr, a6: ptr SockLen): int {.\n  importc, header: \"<sys/socket.h>\", sideEffect.}\nproc recvmsg*(a1: SocketHandle, a2: ptr Tmsghdr, a3: cint): int {.\n  importc, header: \"<sys/socket.h>\", sideEffect.}\nproc send*(a1: SocketHandle, a2: pointer, a3: int, a4: cint): int {.\n  importc, header: \"<sys/socket.h>\", sideEffect.}\nproc sendmsg*(a1: SocketHandle, a2: ptr Tmsghdr, a3: cint): int {.\n  importc, header: \"<sys/socket.h>\", sideEffect.}\nproc sendto*(a1: SocketHandle, a2: pointer, a3: int, a4: cint, a5: ptr SockAddr,\n             a6: SockLen): int {.\n  importc, header: \"<sys/socket.h>\", sideEffect.}\nproc setsockopt*(a1: SocketHandle, a2, a3: cint, a4: pointer, a5: SockLen): cint {.\n  importc, header: \"<sys/socket.h>\".}\nproc shutdown*(a1: SocketHandle, a2: cint): cint {.\n  importc, header: \"<sys/socket.h>\".}\nproc socket*(a1, a2, a3: cint): SocketHandle {.\n  importc, header: \"<sys/socket.h>\".}\nproc sockatmark*(a1: cint): cint {.\n  importc, header: \"<sys/socket.h>\".}\nproc socketpair*(a1, a2, a3: cint, a4: var array[0..1, cint]): cint {.\n  importc, header: \"<sys/socket.h>\".}\n\nproc if_nametoindex*(a1: cstring): cint {.importc, header: \"<net/if.h>\".}\nproc if_indextoname*(a1: cint, a2: cstring): cstring {.\n  importc, header: \"<net/if.h>\".}\nproc if_nameindex*(): ptr Tif_nameindex {.importc, header: \"<net/if.h>\".}\nproc if_freenameindex*(a1: ptr Tif_nameindex) {.importc, header: \"<net/if.h>\".}\n\nproc IN6_IS_ADDR_UNSPECIFIED* (a1: ptr In6Addr): cint {.\n  importc, header: \"<netinet/in.h>\".}\n  ## Unspecified address.\nproc IN6_IS_ADDR_LOOPBACK* (a1: ptr In6Addr): cint {.\n  importc, header: \"<netinet/in.h>\".}\n  ## Loopback address.\nproc IN6_IS_ADDR_MULTICAST* (a1: ptr In6Addr): cint {.\n  importc, header: \"<netinet/in.h>\".}\n  ## Multicast address.\nproc IN6_IS_ADDR_LINKLOCAL* (a1: ptr In6Addr): cint {.\n  importc, header: \"<netinet/in.h>\".}\n  ## Unicast link-local address.\nproc IN6_IS_ADDR_SITELOCAL* (a1: ptr In6Addr): cint {.\n  importc, header: \"<netinet/in.h>\".}\n  ## Unicast site-local address.\nwhen defined(lwip):\n  proc IN6_IS_ADDR_V4MAPPED*(ipv6_address: ptr In6Addr): cint =\n    var bits32: ptr array[4, uint32] = cast[ptr array[4, uint32]](ipv6_address)\n    return (bits32[1] == 0'u32 and bits32[2] == htonl(0x0000FFFF)).cint\nelse:\n  proc IN6_IS_ADDR_V4MAPPED* (a1: ptr In6Addr): cint {.\n    importc, header: \"<netinet/in.h>\".}\n    ## IPv4 mapped address.\n\nproc IN6_IS_ADDR_V4COMPAT* (a1: ptr In6Addr): cint {.\n  importc, header: \"<netinet/in.h>\".}\n  ## IPv4-compatible address.\nproc IN6_IS_ADDR_MC_NODELOCAL* (a1: ptr In6Addr): cint {.\n  importc, header: \"<netinet/in.h>\".}\n  ## Multicast node-local address.\nproc IN6_IS_ADDR_MC_LINKLOCAL* (a1: ptr In6Addr): cint {.\n  importc, header: \"<netinet/in.h>\".}\n  ## Multicast link-local address.\nproc IN6_IS_ADDR_MC_SITELOCAL* (a1: ptr In6Addr): cint {.\n  importc, header: \"<netinet/in.h>\".}\n  ## Multicast site-local address.\nproc IN6_IS_ADDR_MC_ORGLOCAL* (a1: ptr In6Addr): cint {.\n  importc, header: \"<netinet/in.h>\".}\n  ## Multicast organization-local address.\nproc IN6_IS_ADDR_MC_GLOBAL* (a1: ptr In6Addr): cint {.\n  importc, header: \"<netinet/in.h>\".}\n  ## Multicast global address.\n\nproc endhostent*() {.importc, header: \"<netdb.h>\".}\nproc endnetent*() {.importc, header: \"<netdb.h>\".}\nproc endprotoent*() {.importc, header: \"<netdb.h>\".}\nproc endservent*() {.importc, header: \"<netdb.h>\".}\nproc freeaddrinfo*(a1: ptr AddrInfo) {.importc, header: \"<netdb.h>\".}\n\nproc gai_strerror*(a1: cint): cstring {.importc:\"(char *)$1\", header: \"<netdb.h>\".}\n\nproc getaddrinfo*(a1, a2: cstring, a3: ptr AddrInfo,\n                  a4: var ptr AddrInfo): cint {.importc, header: \"<netdb.h>\".}\n\nwhen not defined(android4):\n  proc gethostbyaddr*(a1: pointer, a2: SockLen, a3: cint): ptr Hostent {.\n                      importc, header: \"<netdb.h>\".}\nelse:\n  proc gethostbyaddr*(a1: cstring, a2: cint, a3: cint): ptr Hostent {.\n                      importc, header: \"<netdb.h>\".}\nproc gethostbyname*(a1: cstring): ptr Hostent {.importc, header: \"<netdb.h>\".}\nproc gethostent*(): ptr Hostent {.importc, header: \"<netdb.h>\".}\n\nproc getnameinfo*(a1: ptr SockAddr, a2: SockLen,\n                  a3: cstring, a4: SockLen, a5: cstring,\n                  a6: SockLen, a7: cint): cint {.importc, header: \"<netdb.h>\".}\n\nproc getnetbyaddr*(a1: int32, a2: cint): ptr Tnetent {.importc, header: \"<netdb.h>\".}\nproc getnetbyname*(a1: cstring): ptr Tnetent {.importc, header: \"<netdb.h>\".}\nproc getnetent*(): ptr Tnetent {.importc, header: \"<netdb.h>\".}\n\nproc getprotobyname*(a1: cstring): ptr Protoent {.importc, header: \"<netdb.h>\".}\nproc getprotobynumber*(a1: cint): ptr Protoent {.importc, header: \"<netdb.h>\".}\nproc getprotoent*(): ptr Protoent {.importc, header: \"<netdb.h>\".}\n\nproc getservbyname*(a1, a2: cstring): ptr Servent {.importc, header: \"<netdb.h>\".}\nproc getservbyport*(a1: cint, a2: cstring): ptr Servent {.\n  importc, header: \"<netdb.h>\".}\nproc getservent*(): ptr Servent {.importc, header: \"<netdb.h>\".}\n\nproc sethostent*(a1: cint) {.importc, header: \"<netdb.h>\".}\nproc setnetent*(a1: cint) {.importc, header: \"<netdb.h>\".}\nproc setprotoent*(a1: cint) {.importc, header: \"<netdb.h>\".}\nproc setservent*(a1: cint) {.importc, header: \"<netdb.h>\".}\n\nwhen not defined(lwip):\n  proc poll*(a1: ptr TPollfd, a2: Tnfds, a3: int): cint {.\n    importc, header: \"<poll.h>\", sideEffect.}\n\nproc realpath*(name, resolved: cstring): cstring {.\n  importc: \"realpath\", header: \"<stdlib.h>\".}\n\nproc mkstemp*(tmpl: cstring): cint {.importc, header: \"<stdlib.h>\", sideEffect.}\n  ## Creates a unique temporary file.\n  ##\n  ## **Warning**: The `tmpl` argument is written to by `mkstemp` and thus\n  ## can't be a string literal. If in doubt make a copy of the cstring before\n  ## passing it in.\n\nproc mkstemps*(tmpl: cstring, suffixlen: int): cint {.importc, header: \"<stdlib.h>\", sideEffect.}\n  ## Creates a unique temporary file.\n  ##\n  ## **Warning**: The `tmpl` argument is written to by `mkstemps` and thus\n  ## can't be a string literal. If in doubt make a copy of the cstring before\n  ## passing it in.\n\nproc mkdtemp*(tmpl: cstring): pointer {.importc, header: \"<stdlib.h>\", sideEffect.}\n\nwhen defined(linux) or defined(bsd) or defined(osx):\n  proc mkostemp*(tmpl: cstring, oflags: cint): cint {.importc, header: \"<stdlib.h>\", sideEffect.}\n  proc mkostemps*(tmpl: cstring, suffixlen: cint, oflags: cint): cint {.importc, header: \"<stdlib.h>\", sideEffect.}\n\n  proc posix_memalign*(memptr: pointer, alignment: csize_t, size: csize_t): cint {.importc, header: \"<stdlib.h>\".}\n\nproc utimes*(path: cstring, times: ptr array[2, Timeval]): int {.\n  importc: \"utimes\", header: \"<sys/time.h>\", sideEffect.}\n  ## Sets file access and modification times.\n  ##\n  ## Pass the filename and an array of times to set the access and modification\n  ## times respectively. If you pass nil as the array both attributes will be\n  ## set to the current time.\n  ##\n  ## Returns zero on success.\n  ##\n  ## For more information read http://www.unix.com/man-page/posix/3/utimes/.\n\nproc handle_signal(sig: cint, handler: proc (a: cint) {.noconv.}) {.importc: \"signal\", header: \"<signal.h>\".}\n\ntemplate onSignal*(signals: varargs[cint], body: untyped) =\n  ## Setup code to be executed when Unix signals are received. The\n  ## currently handled signal is injected as ``sig`` into the calling\n  ## scope.\n  ##\n  ## Example:\n  ##\n  ## .. code-block::\n  ##   from posix import SIGINT, SIGTERM, onSignal\n  ##   onSignal(SIGINT, SIGTERM):\n  ##     echo \"bye from signal \", sig\n\n  for s in signals:\n    handle_signal(s,\n      proc (signal: cint) {.noconv.} =\n        let sig {.inject.} = signal\n        body\n    )\n\ntype\n  RLimit* {.importc: \"struct rlimit\",\n            header: \"<sys/resource.h>\", pure, final.} = object\n    rlim_cur*: int\n    rlim_max*: int\n  ## The getrlimit() and setrlimit() system calls get and set resource limits respectively.\n  ## Each resource has an associated soft and hard limit, as defined by the RLimit structure\n\nproc setrlimit*(resource: cint, rlp: var RLimit): cint\n      {.importc: \"setrlimit\",header: \"<sys/resource.h>\".}\n  ## The setrlimit() system calls sets resource limits.\n\nproc getrlimit*(resource: cint, rlp: var RLimit): cint\n      {.importc: \"getrlimit\",header: \"<sys/resource.h>\".}\n  ## The getrlimit() system call gets resource limits.\n\nwhen defined(nimHasStyleChecks):\n  {.pop.} # {.push styleChecks: off.}\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-nim-1.4.2-clhxocckl4vjqcsapqox2ghfzra4c4ma/spack-src/lib/system/dyncalls.nim": "#\n#\n#            Nim's Runtime Library\n#        (c) Copyright 2012 Andreas Rumpf\n#\n#    See the file \"copying.txt\", included in this\n#    distribution, for details about the copyright.\n#\n\n# This file implements the ability to call native procs from libraries.\n# It is not possible to do this in a platform independent way, unfortunately.\n# However, the interface has been designed to take platform differences into\n# account and been ported to all major platforms.\n\n{.push stack_trace: off.}\n\nconst\n  NilLibHandle: LibHandle = nil\n\nproc nimLoadLibraryError(path: string) =\n  # carefully written to avoid memory allocation:\n  const prefix = \"could not load: \"\n  cstderr.rawWrite(prefix)\n  cstderr.rawWrite(path)\n  when not defined(nimDebugDlOpen) and not defined(windows):\n    cstderr.rawWrite(\"\\n(compile with -d:nimDebugDlOpen for more information)\")\n  when defined(windows):\n    const badExe = \"\\n(bad format; library may be wrong architecture)\"\n    let loadError = GetLastError()\n    if loadError == ERROR_BAD_EXE_FORMAT:\n      cstderr.rawWrite(badExe)\n    when defined(guiapp):\n      # Because console output is not shown in GUI apps, display the error as a\n      # message box instead:\n      var\n        msg: array[1000, char]\n        msgLeft = msg.len - 1 # leave (at least) one for nullchar\n        msgIdx = 0\n      copyMem(msg[msgIdx].addr, prefix.cstring, prefix.len)\n      msgLeft -= prefix.len\n      msgIdx += prefix.len\n      let pathLen = min(path.len, msgLeft)\n      copyMem(msg[msgIdx].addr, path.cstring, pathLen)\n      msgLeft -= pathLen\n      msgIdx += pathLen\n      if loadError == ERROR_BAD_EXE_FORMAT and msgLeft >= badExe.len:\n        copyMem(msg[msgIdx].addr, badExe.cstring, badExe.len)\n      discard MessageBoxA(nil, msg[0].addr, nil, 0)\n  cstderr.rawWrite(\"\\n\")\n  quit(1)\n\nproc procAddrError(name: cstring) {.compilerproc, nonReloadable, hcrInline.} =\n  # carefully written to avoid memory allocation:\n  cstderr.rawWrite(\"could not import: \")\n  cstderr.rawWrite(name)\n  cstderr.rawWrite(\"\\n\")\n  quit(1)\n\n# this code was inspired from Lua's source code:\n# Lua - An Extensible Extension Language\n# Tecgraf: Computer Graphics Technology Group, PUC-Rio, Brazil\n# http://www.lua.org\n# mailto:info@lua.org\n\nwhen defined(posix):\n  #\n  # =========================================================================\n  # This is an implementation based on the dlfcn interface.\n  # The dlfcn interface is available in Linux, SunOS, Solaris, IRIX, FreeBSD,\n  # NetBSD, AIX 4.2, HPUX 11, and probably most other Unix flavors, at least\n  # as an emulation layer on top of native functions.\n  # =========================================================================\n  #\n\n  # c stuff:\n  when defined(linux) or defined(macosx):\n    const RTLD_NOW = cint(2)\n  else:\n    var\n      RTLD_NOW {.importc: \"RTLD_NOW\", header: \"<dlfcn.h>\".}: cint\n\n  proc dlclose(lib: LibHandle) {.importc, header: \"<dlfcn.h>\".}\n  proc dlopen(path: cstring, mode: cint): LibHandle {.\n      importc, header: \"<dlfcn.h>\".}\n  proc dlsym(lib: LibHandle, name: cstring): ProcAddr {.\n      importc, header: \"<dlfcn.h>\".}\n\n  proc dlerror(): cstring {.importc, header: \"<dlfcn.h>\".}\n\n  proc nimUnloadLibrary(lib: LibHandle) =\n    dlclose(lib)\n\n  proc nimLoadLibrary(path: string): LibHandle =\n    let flags =\n      when defined(globalSymbols): RTLD_NOW or RTLD_GLOBAL\n      else: RTLD_NOW\n    result = dlopen(path, flags)\n    when defined(nimDebugDlOpen):\n      let error = dlerror()\n      if error != nil:\n        cstderr.rawWrite(error)\n        cstderr.rawWrite(\"\\n\")\n\n  proc nimGetProcAddr(lib: LibHandle, name: cstring): ProcAddr =\n    result = dlsym(lib, name)\n    if result == nil: procAddrError(name)\n\nelif defined(windows) or defined(dos):\n  #\n  # =======================================================================\n  # Native Windows Implementation\n  # =======================================================================\n  #\n  when defined(cpp):\n    type\n      THINSTANCE {.importc: \"HINSTANCE\".} = object\n        x: pointer\n    proc getProcAddress(lib: THINSTANCE, name: cstring): ProcAddr {.\n        importcpp: \"(void*)GetProcAddress(@)\", header: \"<windows.h>\", stdcall.}\n  else:\n    type\n      THINSTANCE {.importc: \"HINSTANCE\".} = pointer\n    proc getProcAddress(lib: THINSTANCE, name: cstring): ProcAddr {.\n        importc: \"GetProcAddress\", header: \"<windows.h>\", stdcall.}\n\n  proc freeLibrary(lib: THINSTANCE) {.\n      importc: \"FreeLibrary\", header: \"<windows.h>\", stdcall.}\n  proc winLoadLibrary(path: cstring): THINSTANCE {.\n      importc: \"LoadLibraryA\", header: \"<windows.h>\", stdcall.}\n\n  proc nimUnloadLibrary(lib: LibHandle) =\n    freeLibrary(cast[THINSTANCE](lib))\n\n  proc nimLoadLibrary(path: string): LibHandle =\n    result = cast[LibHandle](winLoadLibrary(path))\n\n  proc nimGetProcAddr(lib: LibHandle, name: cstring): ProcAddr =\n    result = getProcAddress(cast[THINSTANCE](lib), name)\n    if result != nil: return\n    const decoratedLength = 250\n    var decorated: array[decoratedLength, char]\n    decorated[0] = '_'\n    var m = 1\n    while m < (decoratedLength - 5):\n      if name[m - 1] == '\\x00': break\n      decorated[m] = name[m - 1]\n      inc(m)\n    decorated[m] = '@'\n    for i in countup(0, 50):\n      var k = i * 4\n      if k div 100 == 0:\n        if k div 10 == 0:\n          m = m + 1\n        else:\n          m = m + 2\n      else:\n        m = m + 3\n      decorated[m + 1] = '\\x00'\n      while true:\n        decorated[m] = chr(ord('0') + (k %% 10))\n        dec(m)\n        k = k div 10\n        if k == 0: break\n      when defined(nimNoArrayToCstringConversion):\n        result = getProcAddress(cast[THINSTANCE](lib), addr decorated)\n      else:\n        result = getProcAddress(cast[THINSTANCE](lib), decorated)\n      if result != nil: return\n    procAddrError(name)\n\nelif defined(genode):\n\n  proc nimUnloadLibrary(lib: LibHandle) {.\n    error: \"nimUnloadLibrary not implemented\".}\n\n  proc nimLoadLibrary(path: string): LibHandle {.\n    error: \"nimLoadLibrary not implemented\".}\n\n  proc nimGetProcAddr(lib: LibHandle, name: cstring): ProcAddr {.\n    error: \"nimGetProcAddr not implemented\".}\n\nelif defined(nintendoswitch) or defined(freertos):\n  proc nimUnloadLibrary(lib: LibHandle) =\n    cstderr.rawWrite(\"nimUnLoadLibrary not implemented\")\n    cstderr.rawWrite(\"\\n\")\n    quit(1)\n\n  proc nimLoadLibrary(path: string): LibHandle =\n    cstderr.rawWrite(\"nimLoadLibrary not implemented\")\n    cstderr.rawWrite(\"\\n\")\n    quit(1)\n\n\n  proc nimGetProcAddr(lib: LibHandle, name: cstring): ProcAddr =\n    cstderr.rawWrite(\"nimGetProAddr not implemented\")\n    cstderr.rawWrite(name)\n    cstderr.rawWrite(\"\\n\")\n    quit(1)\n\nelse:\n  {.error: \"no implementation for dyncalls\".}\n\n{.pop.}\n"
    },
    "skipped": [
        "/var/tmp/sochat1/spack-stage/spack-stage-nim-1.4.2-clhxocckl4vjqcsapqox2ghfzra4c4ma/spack-src/tests/stdlib/tjsontestsuite.nim",
        "/var/tmp/sochat1/spack-stage/spack-stage-nim-1.4.2-clhxocckl4vjqcsapqox2ghfzra4c4ma/spack-src/icons/nim_icon.o",
        "/var/tmp/sochat1/spack-stage/spack-stage-nim-1.4.2-clhxocckl4vjqcsapqox2ghfzra4c4ma/spack-src/icons/koch_icon.o",
        "/var/tmp/sochat1/spack-stage/spack-stage-nim-1.4.2-clhxocckl4vjqcsapqox2ghfzra4c4ma/spack-src/icons/nim.ico",
        "/var/tmp/sochat1/spack-stage/spack-stage-nim-1.4.2-clhxocckl4vjqcsapqox2ghfzra4c4ma/spack-src/icons/koch.res",
        "/var/tmp/sochat1/spack-stage/spack-stage-nim-1.4.2-clhxocckl4vjqcsapqox2ghfzra4c4ma/spack-src/icons/nim.res",
        "/var/tmp/sochat1/spack-stage/spack-stage-nim-1.4.2-clhxocckl4vjqcsapqox2ghfzra4c4ma/spack-src/icons/koch.ico"
    ],
    "total_files": 10915
}