{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-librdkafka-1.4.4-3ssj4ca5li7y4lpnk4u42eu35dqiqn3i/spack-src/CONFIGURATION.md": "# Configuration properties\n## Global configuration properties\n\nProperty                                 | C/P | Range           |       Default | Importance | Description              \n-----------------------------------------|-----|-----------------|--------------:|------------| --------------------------\nbuiltin.features                         |  *  |                 | gzip, snappy, ssl, sasl, regex, lz4, sasl_gssapi, sasl_plain, sasl_scram, plugins, zstd, sasl_oauthbearer | low        | Indicates the builtin features for this build of librdkafka. An application can either query this value or attempt to set it with its list of required features to check for library support. <br>*Type: CSV flags*\nclient.id                                |  *  |                 |       rdkafka | low        | Client identifier. <br>*Type: string*\nmetadata.broker.list                     |  *  |                 |               | high       | Initial list of brokers as a CSV list of broker host or host:port. The application may also use `rd_kafka_brokers_add()` to add brokers during runtime. <br>*Type: string*\nbootstrap.servers                        |  *  |                 |               | high       | Alias for `metadata.broker.list`: Initial list of brokers as a CSV list of broker host or host:port. The application may also use `rd_kafka_brokers_add()` to add brokers during runtime. <br>*Type: string*\nmessage.max.bytes                        |  *  | 1000 .. 1000000000 |       1000000 | medium     | Maximum Kafka protocol request message size. Due to differing framing overhead between protocol versions the producer is unable to reliably enforce a strict max message limit at produce time and may exceed the maximum size by one message in protocol ProduceRequests, the broker will enforce the the topic's `max.message.bytes` limit (see Apache Kafka documentation). <br>*Type: integer*\nmessage.copy.max.bytes                   |  *  | 0 .. 1000000000 |         65535 | low        | Maximum size for message to be copied to buffer. Messages larger than this will be passed by reference (zero-copy) at the expense of larger iovecs. <br>*Type: integer*\nreceive.message.max.bytes                |  *  | 1000 .. 2147483647 |     100000000 | medium     | Maximum Kafka protocol response message size. This serves as a safety precaution to avoid memory exhaustion in case of protocol hickups. This value must be at least `fetch.max.bytes`  + 512 to allow for protocol overhead; the value is adjusted automatically unless the configuration property is explicitly set. <br>*Type: integer*\nmax.in.flight.requests.per.connection    |  *  | 1 .. 1000000    |       1000000 | low        | Maximum number of in-flight requests per broker connection. This is a generic property applied to all broker communication, however it is primarily relevant to produce requests. In particular, note that other mechanisms limit the number of outstanding consumer fetch request per broker to one. <br>*Type: integer*\nmax.in.flight                            |  *  | 1 .. 1000000    |       1000000 | low        | Alias for `max.in.flight.requests.per.connection`: Maximum number of in-flight requests per broker connection. This is a generic property applied to all broker communication, however it is primarily relevant to produce requests. In particular, note that other mechanisms limit the number of outstanding consumer fetch request per broker to one. <br>*Type: integer*\nmetadata.request.timeout.ms              |  *  | 10 .. 900000    |         60000 | low        | Non-topic request timeout in milliseconds. This is for metadata requests, etc. <br>*Type: integer*\ntopic.metadata.refresh.interval.ms       |  *  | -1 .. 3600000   |        300000 | low        | Period of time in milliseconds at which topic and broker metadata is refreshed in order to proactively discover any new brokers, topics, partitions or partition leader changes. Use -1 to disable the intervalled refresh (not recommended). If there are no locally referenced topics (no topic objects created, no messages produced, no subscription or no assignment) then only the broker list will be refreshed every interval but no more often than every 10s. <br>*Type: integer*\nmetadata.max.age.ms                      |  *  | 1 .. 86400000   |        900000 | low        | Metadata cache max age. Defaults to topic.metadata.refresh.interval.ms * 3 <br>*Type: integer*\ntopic.metadata.refresh.fast.interval.ms  |  *  | 1 .. 60000      |           250 | low        | When a topic loses its leader a new metadata request will be enqueued with this initial interval, exponentially increasing until the topic metadata has been refreshed. This is used to recover quickly from transitioning leader brokers. <br>*Type: integer*\ntopic.metadata.refresh.fast.cnt          |  *  | 0 .. 1000       |            10 | low        | **DEPRECATED** No longer used. <br>*Type: integer*\ntopic.metadata.refresh.sparse            |  *  | true, false     |          true | low        | Sparse metadata requests (consumes less network bandwidth) <br>*Type: boolean*\ntopic.blacklist                          |  *  |                 |               | low        | Topic blacklist, a comma-separated list of regular expressions for matching topic names that should be ignored in broker metadata information as if the topics did not exist. <br>*Type: pattern list*\ndebug                                    |  *  | generic, broker, topic, metadata, feature, queue, msg, protocol, cgrp, security, fetch, interceptor, plugin, consumer, admin, eos, mock, all |               | medium     | A comma-separated list of debug contexts to enable. Detailed Producer debugging: broker,topic,msg. Consumer: consumer,cgrp,topic,fetch <br>*Type: CSV flags*\nsocket.timeout.ms                        |  *  | 10 .. 300000    |         60000 | low        | Default timeout for network requests. Producer: ProduceRequests will use the lesser value of `socket.timeout.ms` and remaining `message.timeout.ms` for the first message in the batch. Consumer: FetchRequests will use `fetch.wait.max.ms` + `socket.timeout.ms`. Admin: Admin requests will use `socket.timeout.ms` or explicitly set `rd_kafka_AdminOptions_set_operation_timeout()` value. <br>*Type: integer*\nsocket.blocking.max.ms                   |  *  | 1 .. 60000      |          1000 | low        | **DEPRECATED** No longer used. <br>*Type: integer*\nsocket.send.buffer.bytes                 |  *  | 0 .. 100000000  |             0 | low        | Broker socket send buffer size. System default is used if 0. <br>*Type: integer*\nsocket.receive.buffer.bytes              |  *  | 0 .. 100000000  |             0 | low        | Broker socket receive buffer size. System default is used if 0. <br>*Type: integer*\nsocket.keepalive.enable                  |  *  | true, false     |         false | low        | Enable TCP keep-alives (SO_KEEPALIVE) on broker sockets <br>*Type: boolean*\nsocket.nagle.disable                     |  *  | true, false     |         false | low        | Disable the Nagle algorithm (TCP_NODELAY) on broker sockets. <br>*Type: boolean*\nsocket.max.fails                         |  *  | 0 .. 1000000    |             1 | low        | Disconnect from broker when this number of send failures (e.g., timed out requests) is reached. Disable with 0. WARNING: It is highly recommended to leave this setting at its default value of 1 to avoid the client and broker to become desynchronized in case of request timeouts. NOTE: The connection is automatically re-established. <br>*Type: integer*\nbroker.address.ttl                       |  *  | 0 .. 86400000   |          1000 | low        | How long to cache the broker address resolving results (milliseconds). <br>*Type: integer*\nbroker.address.family                    |  *  | any, v4, v6     |           any | low        | Allowed broker IP address families: any, v4, v6 <br>*Type: enum value*\nreconnect.backoff.jitter.ms              |  *  | 0 .. 3600000    |             0 | low        | **DEPRECATED** No longer used. See `reconnect.backoff.ms` and `reconnect.backoff.max.ms`. <br>*Type: integer*\nreconnect.backoff.ms                     |  *  | 0 .. 3600000    |           100 | medium     | The initial time to wait before reconnecting to a broker after the connection has been closed. The time is increased exponentially until `reconnect.backoff.max.ms` is reached. -25% to +50% jitter is applied to each reconnect backoff. A value of 0 disables the backoff and reconnects immediately. <br>*Type: integer*\nreconnect.backoff.max.ms                 |  *  | 0 .. 3600000    |         10000 | medium     | The maximum time to wait before reconnecting to a broker after the connection has been closed. <br>*Type: integer*\nstatistics.interval.ms                   |  *  | 0 .. 86400000   |             0 | high       | librdkafka statistics emit interval. The application also needs to register a stats callback using `rd_kafka_conf_set_stats_cb()`. The granularity is 1000ms. A value of 0 disables statistics. <br>*Type: integer*\nenabled_events                           |  *  | 0 .. 2147483647 |             0 | low        | See `rd_kafka_conf_set_events()` <br>*Type: integer*\nerror_cb                                 |  *  |                 |               | low        | Error callback (set with rd_kafka_conf_set_error_cb()) <br>*Type: see dedicated API*\nthrottle_cb                              |  *  |                 |               | low        | Throttle callback (set with rd_kafka_conf_set_throttle_cb()) <br>*Type: see dedicated API*\nstats_cb                                 |  *  |                 |               | low        | Statistics callback (set with rd_kafka_conf_set_stats_cb()) <br>*Type: see dedicated API*\nlog_cb                                   |  *  |                 |               | low        | Log callback (set with rd_kafka_conf_set_log_cb()) <br>*Type: see dedicated API*\nlog_level                                |  *  | 0 .. 7          |             6 | low        | Logging level (syslog(3) levels) <br>*Type: integer*\nlog.queue                                |  *  | true, false     |         false | low        | Disable spontaneous log_cb from internal librdkafka threads, instead enqueue log messages on queue set with `rd_kafka_set_log_queue()` and serve log callbacks or events through the standard poll APIs. **NOTE**: Log messages will linger in a temporary queue until the log queue has been set. <br>*Type: boolean*\nlog.thread.name                          |  *  | true, false     |          true | low        | Print internal thread name in log messages (useful for debugging librdkafka internals) <br>*Type: boolean*\nenable.random.seed                       |  *  | true, false     |          true | low        | If enabled librdkafka will initialize the POSIX PRNG with srand(current_time.milliseconds) on the first invocation of rd_kafka_new(). If disabled the application must call srand() prior to calling rd_kafka_new(). <br>*Type: boolean*\nlog.connection.close                     |  *  | true, false     |          true | low        | Log broker disconnects. It might be useful to turn this off when interacting with 0.9 brokers with an aggressive `connection.max.idle.ms` value. <br>*Type: boolean*\nbackground_event_cb                      |  *  |                 |               | low        | Background queue event callback (set with rd_kafka_conf_set_background_event_cb()) <br>*Type: see dedicated API*\nsocket_cb                                |  *  |                 |               | low        | Socket creation callback to provide race-free CLOEXEC <br>*Type: see dedicated API*\nconnect_cb                               |  *  |                 |               | low        | Socket connect callback <br>*Type: see dedicated API*\nclosesocket_cb                           |  *  |                 |               | low        | Socket close callback <br>*Type: see dedicated API*\nopen_cb                                  |  *  |                 |               | low        | File open callback to provide race-free CLOEXEC <br>*Type: see dedicated API*\nopaque                                   |  *  |                 |               | low        | Application opaque (set with rd_kafka_conf_set_opaque()) <br>*Type: see dedicated API*\ndefault_topic_conf                       |  *  |                 |               | low        | Default topic configuration for automatically subscribed topics <br>*Type: see dedicated API*\ninternal.termination.signal              |  *  | 0 .. 128        |             0 | low        | Signal that librdkafka will use to quickly terminate on rd_kafka_destroy(). If this signal is not set then there will be a delay before rd_kafka_wait_destroyed() returns true as internal threads are timing out their system calls. If this signal is set however the delay will be minimal. The application should mask this signal as an internal signal handler is installed. <br>*Type: integer*\napi.version.request                      |  *  | true, false     |          true | high       | Request broker's supported API versions to adjust functionality to available protocol features. If set to false, or the ApiVersionRequest fails, the fallback version `broker.version.fallback` will be used. **NOTE**: Depends on broker version >=0.10.0. If the request is not supported by (an older) broker the `broker.version.fallback` fallback is used. <br>*Type: boolean*\napi.version.request.timeout.ms           |  *  | 1 .. 300000     |         10000 | low        | Timeout for broker API version requests. <br>*Type: integer*\napi.version.fallback.ms                  |  *  | 0 .. 604800000  |             0 | medium     | Dictates how long the `broker.version.fallback` fallback is used in the case the ApiVersionRequest fails. **NOTE**: The ApiVersionRequest is only issued when a new connection to the broker is made (such as after an upgrade). <br>*Type: integer*\nbroker.version.fallback                  |  *  |                 |        0.10.0 | medium     | Older broker versions (before 0.10.0) provide no way for a client to query for supported protocol features (ApiVersionRequest, see `api.version.request`) making it impossible for the client to know what features it may use. As a workaround a user may set this property to the expected broker version and the client will automatically adjust its feature set accordingly if the ApiVersionRequest fails (or is disabled). The fallback broker version will be used for `api.version.fallback.ms`. Valid values are: 0.9.0, 0.8.2, 0.8.1, 0.8.0. Any other value >= 0.10, such as 0.10.2.1, enables ApiVersionRequests. <br>*Type: string*\nsecurity.protocol                        |  *  | plaintext, ssl, sasl_plaintext, sasl_ssl |     plaintext | high       | Protocol used to communicate with brokers. <br>*Type: enum value*\nssl.cipher.suites                        |  *  |                 |               | low        | A cipher suite is a named combination of authentication, encryption, MAC and key exchange algorithm used to negotiate the security settings for a network connection using TLS or SSL network protocol. See manual page for `ciphers(1)` and `SSL_CTX_set_cipher_list(3). <br>*Type: string*\nssl.curves.list                          |  *  |                 |               | low        | The supported-curves extension in the TLS ClientHello message specifies the curves (standard/named, or 'explicit' GF(2^k) or GF(p)) the client is willing to have the server use. See manual page for `SSL_CTX_set1_curves_list(3)`. OpenSSL >= 1.0.2 required. <br>*Type: string*\nssl.sigalgs.list                         |  *  |                 |               | low        | The client uses the TLS ClientHello signature_algorithms extension to indicate to the server which signature/hash algorithm pairs may be used in digital signatures. See manual page for `SSL_CTX_set1_sigalgs_list(3)`. OpenSSL >= 1.0.2 required. <br>*Type: string*\nssl.key.location                         |  *  |                 |               | low        | Path to client's private key (PEM) used for authentication. <br>*Type: string*\nssl.key.password                         |  *  |                 |               | low        | Private key passphrase (for use with `ssl.key.location` and `set_ssl_cert()`) <br>*Type: string*\nssl.key.pem                              |  *  |                 |               | low        | Client's private key string (PEM format) used for authentication. <br>*Type: string*\nssl_key                                  |  *  |                 |               | low        | Client's private key as set by rd_kafka_conf_set_ssl_cert() <br>*Type: see dedicated API*\nssl.certificate.location                 |  *  |                 |               | low        | Path to client's public key (PEM) used for authentication. <br>*Type: string*\nssl.certificate.pem                      |  *  |                 |               | low        | Client's public key string (PEM format) used for authentication. <br>*Type: string*\nssl_certificate                          |  *  |                 |               | low        | Client's public key as set by rd_kafka_conf_set_ssl_cert() <br>*Type: see dedicated API*\nssl.ca.location                          |  *  |                 |               | low        | File or directory path to CA certificate(s) for verifying the broker's key. Defaults: On Windows the system's CA certificates are automatically looked up in the Windows Root certificate store. On Mac OSX it is recommended to install openssl using Homebrew, to provide CA certificates. On Linux install the distribution's ca-certificates package. If OpenSSL is statically linked or `ssl.ca.location` is set to `probe` a list of standard paths will be probed and the first one found will be used as the default CA certificate location path. If OpenSSL is dynamically linked the OpenSSL library's default path will be used (see `OPENSSLDIR` in `openssl version -a`). <br>*Type: string*\nssl_ca                                   |  *  |                 |               | low        | CA certificate as set by rd_kafka_conf_set_ssl_cert() <br>*Type: see dedicated API*\nssl.crl.location                         |  *  |                 |               | low        | Path to CRL for verifying broker's certificate validity. <br>*Type: string*\nssl.keystore.location                    |  *  |                 |               | low        | Path to client's keystore (PKCS#12) used for authentication. <br>*Type: string*\nssl.keystore.password                    |  *  |                 |               | low        | Client's keystore (PKCS#12) password. <br>*Type: string*\nenable.ssl.certificate.verification      |  *  | true, false     |          true | low        | Enable OpenSSL's builtin broker (server) certificate verification. This verification can be extended by the application by implementing a certificate_verify_cb. <br>*Type: boolean*\nssl.endpoint.identification.algorithm    |  *  | none, https     |          none | low        | Endpoint identification algorithm to validate broker hostname using broker certificate. https - Server (broker) hostname verification as specified in RFC2818. none - No endpoint verification. OpenSSL >= 1.0.2 required. <br>*Type: enum value*\nssl.certificate.verify_cb                |  *  |                 |               | low        | Callback to verify the broker certificate chain. <br>*Type: see dedicated API*\nsasl.mechanisms                          |  *  |                 |        GSSAPI | high       | SASL mechanism to use for authentication. Supported: GSSAPI, PLAIN, SCRAM-SHA-256, SCRAM-SHA-512, OAUTHBEARER. **NOTE**: Despite the name only one mechanism must be configured. <br>*Type: string*\nsasl.mechanism                           |  *  |                 |        GSSAPI | high       | Alias for `sasl.mechanisms`: SASL mechanism to use for authentication. Supported: GSSAPI, PLAIN, SCRAM-SHA-256, SCRAM-SHA-512, OAUTHBEARER. **NOTE**: Despite the name only one mechanism must be configured. <br>*Type: string*\nsasl.kerberos.service.name               |  *  |                 |         kafka | low        | Kerberos principal name that Kafka runs as, not including /hostname@REALM <br>*Type: string*\nsasl.kerberos.principal                  |  *  |                 |   kafkaclient | low        | This client's Kerberos principal name. (Not supported on Windows, will use the logon user's principal). <br>*Type: string*\nsasl.kerberos.kinit.cmd                  |  *  |                 | kinit -R -t \"%{sasl.kerberos.keytab}\" -k %{sasl.kerberos.principal} \\|\\| kinit -t \"%{sasl.kerberos.keytab}\" -k %{sasl.kerberos.principal} | low        | Shell command to refresh or acquire the client's Kerberos ticket. This command is executed on client creation and every sasl.kerberos.min.time.before.relogin (0=disable). %{config.prop.name} is replaced by corresponding config object value. <br>*Type: string*\nsasl.kerberos.keytab                     |  *  |                 |               | low        | Path to Kerberos keytab file. This configuration property is only used as a variable in `sasl.kerberos.kinit.cmd` as ` ... -t \"%{sasl.kerberos.keytab}\"`. <br>*Type: string*\nsasl.kerberos.min.time.before.relogin    |  *  | 0 .. 86400000   |         60000 | low        | Minimum time in milliseconds between key refresh attempts. Disable automatic key refresh by setting this property to 0. <br>*Type: integer*\nsasl.username                            |  *  |                 |               | high       | SASL username for use with the PLAIN and SASL-SCRAM-.. mechanisms <br>*Type: string*\nsasl.password                            |  *  |                 |               | high       | SASL password for use with the PLAIN and SASL-SCRAM-.. mechanism <br>*Type: string*\nsasl.oauthbearer.config                  |  *  |                 |               | low        | SASL/OAUTHBEARER configuration. The format is implementation-dependent and must be parsed accordingly. The default unsecured token implementation (see https://tools.ietf.org/html/rfc7515#appendix-A.5) recognizes space-separated name=value pairs with valid names including principalClaimName, principal, scopeClaimName, scope, and lifeSeconds. The default value for principalClaimName is \"sub\", the default value for scopeClaimName is \"scope\", and the default value for lifeSeconds is 3600. The scope value is CSV format with the default value being no/empty scope. For example: `principalClaimName=azp principal=admin scopeClaimName=roles scope=role1,role2 lifeSeconds=600`. In addition, SASL extensions can be communicated to the broker via `extension_NAME=value`. For example: `principal=admin extension_traceId=123` <br>*Type: string*\nenable.sasl.oauthbearer.unsecure.jwt     |  *  | true, false     |         false | low        | Enable the builtin unsecure JWT OAUTHBEARER token handler if no oauthbearer_refresh_cb has been set. This builtin handler should only be used for development or testing, and not in production. <br>*Type: boolean*\noauthbearer_token_refresh_cb             |  *  |                 |               | low        | SASL/OAUTHBEARER token refresh callback (set with rd_kafka_conf_set_oauthbearer_token_refresh_cb(), triggered by rd_kafka_poll(), et.al. This callback will be triggered when it is time to refresh the client's OAUTHBEARER token. <br>*Type: see dedicated API*\nplugin.library.paths                     |  *  |                 |               | low        | List of plugin libraries to load (; separated). The library search path is platform dependent (see dlopen(3) for Unix and LoadLibrary() for Windows). If no filename extension is specified the platform-specific extension (such as .dll or .so) will be appended automatically. <br>*Type: string*\ninterceptors                             |  *  |                 |               | low        | Interceptors added through rd_kafka_conf_interceptor_add_..() and any configuration handled by interceptors. <br>*Type: see dedicated API*\ngroup.id                                 |  C  |                 |               | high       | Client group id string. All clients sharing the same group.id belong to the same group. <br>*Type: string*\ngroup.instance.id                        |  C  |                 |               | medium     | Enable static group membership. Static group members are able to leave and rejoin a group within the configured `session.timeout.ms` without prompting a group rebalance. This should be used in combination with a larger `session.timeout.ms` to avoid group rebalances caused by transient unavailability (e.g. process restarts). Requires broker version >= 2.3.0. <br>*Type: string*\npartition.assignment.strategy            |  C  |                 | range,roundrobin | medium     | Name of partition assignment strategy to use when elected group leader assigns partitions to group members. <br>*Type: string*\nsession.timeout.ms                       |  C  | 1 .. 3600000    |         10000 | high       | Client group session and failure detection timeout. The consumer sends periodic heartbeats (heartbeat.interval.ms) to indicate its liveness to the broker. If no hearts are received by the broker for a group member within the session timeout, the broker will remove the consumer from the group and trigger a rebalance. The allowed range is configured with the **broker** configuration properties `group.min.session.timeout.ms` and `group.max.session.timeout.ms`. Also see `max.poll.interval.ms`. <br>*Type: integer*\nheartbeat.interval.ms                    |  C  | 1 .. 3600000    |          3000 | low        | Group session keepalive heartbeat interval. <br>*Type: integer*\ngroup.protocol.type                      |  C  |                 |      consumer | low        | Group protocol type <br>*Type: string*\ncoordinator.query.interval.ms            |  C  | 1 .. 3600000    |        600000 | low        | How often to query for the current client group coordinator. If the currently assigned coordinator is down the configured query interval will be divided by ten to more quickly recover in case of coordinator reassignment. <br>*Type: integer*\nmax.poll.interval.ms                     |  C  | 1 .. 86400000   |        300000 | high       | Maximum allowed time between calls to consume messages (e.g., rd_kafka_consumer_poll()) for high-level consumers. If this interval is exceeded the consumer is considered failed and the group will rebalance in order to reassign the partitions to another consumer group member. Warning: Offset commits may be not possible at this point. Note: It is recommended to set `enable.auto.offset.store=false` for long-time processing applications and then explicitly store offsets (using offsets_store()) *after* message processing, to make sure offsets are not auto-committed prior to processing has finished. The interval is checked two times per second. See KIP-62 for more information. <br>*Type: integer*\nenable.auto.commit                       |  C  | true, false     |          true | high       | Automatically and periodically commit offsets in the background. Note: setting this to false does not prevent the consumer from fetching previously committed start offsets. To circumvent this behaviour set specific start offsets per partition in the call to assign(). <br>*Type: boolean*\nauto.commit.interval.ms                  |  C  | 0 .. 86400000   |          5000 | medium     | The frequency in milliseconds that the consumer offsets are committed (written) to offset storage. (0 = disable). This setting is used by the high-level consumer. <br>*Type: integer*\nenable.auto.offset.store                 |  C  | true, false     |          true | high       | Automatically store offset of last message provided to application. The offset store is an in-memory store of the next offset to (auto-)commit for each partition. <br>*Type: boolean*\nqueued.min.messages                      |  C  | 1 .. 10000000   |        100000 | medium     | Minimum number of messages per topic+partition librdkafka tries to maintain in the local consumer queue. <br>*Type: integer*\nqueued.max.messages.kbytes               |  C  | 1 .. 2097151    |       1048576 | medium     | Maximum number of kilobytes per topic+partition in the local consumer queue. This value may be overshot by fetch.message.max.bytes. This property has higher priority than queued.min.messages. <br>*Type: integer*\nfetch.wait.max.ms                        |  C  | 0 .. 300000     |           100 | low        | Maximum time the broker may wait to fill the response with fetch.min.bytes. <br>*Type: integer*\nfetch.message.max.bytes                  |  C  | 1 .. 1000000000 |       1048576 | medium     | Initial maximum number of bytes per topic+partition to request when fetching messages from the broker. If the client encounters a message larger than this value it will gradually try to increase it until the entire message can be fetched. <br>*Type: integer*\nmax.partition.fetch.bytes                |  C  | 1 .. 1000000000 |       1048576 | medium     | Alias for `fetch.message.max.bytes`: Initial maximum number of bytes per topic+partition to request when fetching messages from the broker. If the client encounters a message larger than this value it will gradually try to increase it until the entire message can be fetched. <br>*Type: integer*\nfetch.max.bytes                          |  C  | 0 .. 2147483135 |      52428800 | medium     | Maximum amount of data the broker shall return for a Fetch request. Messages are fetched in batches by the consumer and if the first message batch in the first non-empty partition of the Fetch request is larger than this value, then the message batch will still be returned to ensure the consumer can make progress. The maximum message batch size accepted by the broker is defined via `message.max.bytes` (broker config) or `max.message.bytes` (broker topic config). `fetch.max.bytes` is automatically adjusted upwards to be at least `message.max.bytes` (consumer config). <br>*Type: integer*\nfetch.min.bytes                          |  C  | 1 .. 100000000  |             1 | low        | Minimum number of bytes the broker responds with. If fetch.wait.max.ms expires the accumulated data will be sent to the client regardless of this setting. <br>*Type: integer*\nfetch.error.backoff.ms                   |  C  | 0 .. 300000     |           500 | medium     | How long to postpone the next fetch request for a topic+partition in case of a fetch error. <br>*Type: integer*\noffset.store.method                      |  C  | none, file, broker |        broker | low        | **DEPRECATED** Offset commit store method: 'file' - DEPRECATED: local file store (offset.store.path, et.al), 'broker' - broker commit store (requires Apache Kafka 0.8.2 or later on the broker). <br>*Type: enum value*\nisolation.level                          |  C  | read_uncommitted, read_committed | read_committed | high       | Controls how to read messages written transactionally: `read_committed` - only return transactional messages which have been committed. `read_uncommitted` - return all messages, even transactional messages which have been aborted. <br>*Type: enum value*\nconsume_cb                               |  C  |                 |               | low        | Message consume callback (set with rd_kafka_conf_set_consume_cb()) <br>*Type: see dedicated API*\nrebalance_cb                             |  C  |                 |               | low        | Called after consumer group has been rebalanced (set with rd_kafka_conf_set_rebalance_cb()) <br>*Type: see dedicated API*\noffset_commit_cb                         |  C  |                 |               | low        | Offset commit result propagation callback. (set with rd_kafka_conf_set_offset_commit_cb()) <br>*Type: see dedicated API*\nenable.partition.eof                     |  C  | true, false     |         false | low        | Emit RD_KAFKA_RESP_ERR__PARTITION_EOF event whenever the consumer reaches the end of a partition. <br>*Type: boolean*\ncheck.crcs                               |  C  | true, false     |         false | medium     | Verify CRC32 of consumed messages, ensuring no on-the-wire or on-disk corruption to the messages occurred. This check comes at slightly increased CPU usage. <br>*Type: boolean*\nclient.rack                              |  *  |                 |               | low        | A rack identifier for this client. This can be any string value which indicates where this client is physically located. It corresponds with the broker config `broker.rack`. <br>*Type: string*\ntransactional.id                         |  P  |                 |               | high       | Enables the transactional producer. The transactional.id is used to identify the same transactional producer instance across process restarts. It allows the producer to guarantee that transactions corresponding to earlier instances of the same producer have been finalized prior to starting any new transactions, and that any zombie instances are fenced off. If no transactional.id is provided, then the producer is limited to idempotent delivery (if enable.idempotence is set). Requires broker version >= 0.11.0. <br>*Type: string*\ntransaction.timeout.ms                   |  P  | 1000 .. 2147483647 |         60000 | medium     | The maximum amount of time in milliseconds that the transaction coordinator will wait for a transaction status update from the producer before proactively aborting the ongoing transaction. If this value is larger than the `transaction.max.timeout.ms` setting in the broker, the init_transactions() call will fail with ERR_INVALID_TRANSACTION_TIMEOUT. The transaction timeout automatically adjusts `message.timeout.ms` and `socket.timeout.ms`, unless explicitly configured in which case they must not exceed the transaction timeout (`socket.timeout.ms` must be at least 100ms lower than `transaction.timeout.ms`). This is also the default timeout value if no timeout (-1) is supplied to the transactional API methods. <br>*Type: integer*\nenable.idempotence                       |  P  | true, false     |         false | high       | When set to `true`, the producer will ensure that messages are successfully produced exactly once and in the original produce order. The following configuration properties are adjusted automatically (if not modified by the user) when idempotence is enabled: `max.in.flight.requests.per.connection=5` (must be less than or equal to 5), `retries=INT32_MAX` (must be greater than 0), `acks=all`, `queuing.strategy=fifo`. Producer instantation will fail if user-supplied configuration is incompatible. <br>*Type: boolean*\nenable.gapless.guarantee                 |  P  | true, false     |         false | low        | **EXPERIMENTAL**: subject to change or removal. When set to `true`, any error that could result in a gap in the produced message series when a batch of messages fails, will raise a fatal error (ERR__GAPLESS_GUARANTEE) and stop the producer. Messages failing due to `message.timeout.ms` are not covered by this guarantee. Requires `enable.idempotence=true`. <br>*Type: boolean*\nqueue.buffering.max.messages             |  P  | 1 .. 10000000   |        100000 | high       | Maximum number of messages allowed on the producer queue. This queue is shared by all topics and partitions. <br>*Type: integer*\nqueue.buffering.max.kbytes               |  P  | 1 .. 2147483647 |       1048576 | high       | Maximum total message size sum allowed on the producer queue. This queue is shared by all topics and partitions. This property has higher priority than queue.buffering.max.messages. <br>*Type: integer*\nqueue.buffering.max.ms                   |  P  | 0 .. 900000     |           0.5 | high       | Delay in milliseconds to wait for messages in the producer queue to accumulate before constructing message batches (MessageSets) to transmit to brokers. A higher value allows larger and more effective (less overhead, improved compression) batches of messages to accumulate at the expense of increased message delivery latency. <br>*Type: float*\nlinger.ms                                |  P  | 0 .. 900000     |           0.5 | high       | Alias for `queue.buffering.max.ms`: Delay in milliseconds to wait for messages in the producer queue to accumulate before constructing message batches (MessageSets) to transmit to brokers. A higher value allows larger and more effective (less overhead, improved compression) batches of messages to accumulate at the expense of increased message delivery latency. <br>*Type: float*\nmessage.send.max.retries                 |  P  | 0 .. 10000000   |             2 | high       | How many times to retry sending a failing Message. **Note:** retrying may cause reordering unless `enable.idempotence` is set to true. <br>*Type: integer*\nretries                                  |  P  | 0 .. 10000000   |             2 | high       | Alias for `message.send.max.retries`: How many times to retry sending a failing Message. **Note:** retrying may cause reordering unless `enable.idempotence` is set to true. <br>*Type: integer*\nretry.backoff.ms                         |  P  | 1 .. 300000     |           100 | medium     | The backoff time in milliseconds before retrying a protocol request. <br>*Type: integer*\nqueue.buffering.backpressure.threshold   |  P  | 1 .. 1000000    |             1 | low        | The threshold of outstanding not yet transmitted broker requests needed to backpressure the producer's message accumulator. If the number of not yet transmitted requests equals or exceeds this number, produce request creation that would have otherwise been triggered (for example, in accordance with linger.ms) will be delayed. A lower number yields larger and more effective batches. A higher value can improve latency when using compression on slow machines. <br>*Type: integer*\ncompression.codec                        |  P  | none, gzip, snappy, lz4, zstd |          none | medium     | compression codec to use for compressing message sets. This is the default value for all topics, may be overridden by the topic configuration property `compression.codec`.  <br>*Type: enum value*\ncompression.type                         |  P  | none, gzip, snappy, lz4, zstd |          none | medium     | Alias for `compression.codec`: compression codec to use for compressing message sets. This is the default value for all topics, may be overridden by the topic configuration property `compression.codec`.  <br>*Type: enum value*\nbatch.num.messages                       |  P  | 1 .. 1000000    |         10000 | medium     | Maximum number of messages batched in one MessageSet. The total MessageSet size is also limited by message.max.bytes. <br>*Type: integer*\ndelivery.report.only.error               |  P  | true, false     |         false | low        | Only provide delivery reports for failed messages. <br>*Type: boolean*\ndr_cb                                    |  P  |                 |               | low        | Delivery report callback (set with rd_kafka_conf_set_dr_cb()) <br>*Type: see dedicated API*\ndr_msg_cb                                |  P  |                 |               | low        | Delivery report callback (set with rd_kafka_conf_set_dr_msg_cb()) <br>*Type: see dedicated API*\n\n\n## Topic configuration properties\n\nProperty                                 | C/P | Range           |       Default | Importance | Description              \n-----------------------------------------|-----|-----------------|--------------:|------------| --------------------------\nrequest.required.acks                    |  P  | -1 .. 1000      |            -1 | high       | This field indicates the number of acknowledgements the leader broker must receive from ISR brokers before responding to the request: *0*=Broker does not send any response/ack to client, *-1* or *all*=Broker will block until message is committed by all in sync replicas (ISRs). If there are less than `min.insync.replicas` (broker configuration) in the ISR set the produce request will fail. <br>*Type: integer*\nacks                                     |  P  | -1 .. 1000      |            -1 | high       | Alias for `request.required.acks`: This field indicates the number of acknowledgements the leader broker must receive from ISR brokers before responding to the request: *0*=Broker does not send any response/ack to client, *-1* or *all*=Broker will block until message is committed by all in sync replicas (ISRs). If there are less than `min.insync.replicas` (broker configuration) in the ISR set the produce request will fail. <br>*Type: integer*\nrequest.timeout.ms                       |  P  | 1 .. 900000     |          5000 | medium     | The ack timeout of the producer request in milliseconds. This value is only enforced by the broker and relies on `request.required.acks` being != 0. <br>*Type: integer*\nmessage.timeout.ms                       |  P  | 0 .. 2147483647 |        300000 | high       | Local message timeout. This value is only enforced locally and limits the time a produced message waits for successful delivery. A time of 0 is infinite. This is the maximum time librdkafka may use to deliver a message (including retries). Delivery error occurs when either the retry count or the message timeout are exceeded. The message timeout is automatically adjusted to `transaction.timeout.ms` if `transactional.id` is configured. <br>*Type: integer*\ndelivery.timeout.ms                      |  P  | 0 .. 2147483647 |        300000 | high       | Alias for `message.timeout.ms`: Local message timeout. This value is only enforced locally and limits the time a produced message waits for successful delivery. A time of 0 is infinite. This is the maximum time librdkafka may use to deliver a message (including retries). Delivery error occurs when either the retry count or the message timeout are exceeded. The message timeout is automatically adjusted to `transaction.timeout.ms` if `transactional.id` is configured. <br>*Type: integer*\nqueuing.strategy                         |  P  | fifo, lifo      |          fifo | low        | **EXPERIMENTAL**: subject to change or removal. **DEPRECATED** Producer queuing strategy. FIFO preserves produce ordering, while LIFO prioritizes new messages. <br>*Type: enum value*\nproduce.offset.report                    |  P  | true, false     |         false | low        | **DEPRECATED** No longer used. <br>*Type: boolean*\npartitioner                              |  P  |                 | consistent_random | high       | Partitioner: `random` - random distribution, `consistent` - CRC32 hash of key (Empty and NULL keys are mapped to single partition), `consistent_random` - CRC32 hash of key (Empty and NULL keys are randomly partitioned), `murmur2` - Java Producer compatible Murmur2 hash of key (NULL keys are mapped to single partition), `murmur2_random` - Java Producer compatible Murmur2 hash of key (NULL keys are randomly partitioned. This is functionally equivalent to the default partitioner in the Java Producer.), `fnv1a` - FNV-1a hash of key (NULL keys are mapped to single partition), `fnv1a_random` - FNV-1a hash of key (NULL keys are randomly partitioned). <br>*Type: string*\npartitioner_cb                           |  P  |                 |               | low        | Custom partitioner callback (set with rd_kafka_topic_conf_set_partitioner_cb()) <br>*Type: see dedicated API*\nmsg_order_cmp                            |  P  |                 |               | low        | **EXPERIMENTAL**: subject to change or removal. **DEPRECATED** Message queue ordering comparator (set with rd_kafka_topic_conf_set_msg_order_cmp()). Also see `queuing.strategy`. <br>*Type: see dedicated API*\nopaque                                   |  *  |                 |               | low        | Application opaque (set with rd_kafka_topic_conf_set_opaque()) <br>*Type: see dedicated API*\ncompression.codec                        |  P  | none, gzip, snappy, lz4, zstd, inherit |       inherit | high       | Compression codec to use for compressing message sets. inherit = inherit global compression.codec configuration. <br>*Type: enum value*\ncompression.type                         |  P  | none, gzip, snappy, lz4, zstd |          none | medium     | Alias for `compression.codec`: compression codec to use for compressing message sets. This is the default value for all topics, may be overridden by the topic configuration property `compression.codec`.  <br>*Type: enum value*\ncompression.level                        |  P  | -1 .. 12        |            -1 | medium     | Compression level parameter for algorithm selected by configuration property `compression.codec`. Higher values will result in better compression at the cost of more CPU usage. Usable range is algorithm-dependent: [0-9] for gzip; [0-12] for lz4; only 0 for snappy; -1 = codec-dependent default compression level. <br>*Type: integer*\nauto.commit.enable                       |  C  | true, false     |          true | low        | **DEPRECATED** [**LEGACY PROPERTY:** This property is used by the simple legacy consumer only. When using the high-level KafkaConsumer, the global `enable.auto.commit` property must be used instead]. If true, periodically commit offset of the last message handed to the application. This committed offset will be used when the process restarts to pick up where it left off. If false, the application will have to call `rd_kafka_offset_store()` to store an offset (optional). **NOTE:** There is currently no zookeeper integration, offsets will be written to broker or local file according to offset.store.method. <br>*Type: boolean*\nenable.auto.commit                       |  C  | true, false     |          true | low        | **DEPRECATED** Alias for `auto.commit.enable`: [**LEGACY PROPERTY:** This property is used by the simple legacy consumer only. When using the high-level KafkaConsumer, the global `enable.auto.commit` property must be used instead]. If true, periodically commit offset of the last message handed to the application. This committed offset will be used when the process restarts to pick up where it left off. If false, the application will have to call `rd_kafka_offset_store()` to store an offset (optional). **NOTE:** There is currently no zookeeper integration, offsets will be written to broker or local file according to offset.store.method. <br>*Type: boolean*\nauto.commit.interval.ms                  |  C  | 10 .. 86400000  |         60000 | high       | [**LEGACY PROPERTY:** This setting is used by the simple legacy consumer only. When using the high-level KafkaConsumer, the global `auto.commit.interval.ms` property must be used instead]. The frequency in milliseconds that the consumer offsets are committed (written) to offset storage. <br>*Type: integer*\nauto.offset.reset                        |  C  | smallest, earliest, beginning, largest, latest, end, error |       largest | high       | Action to take when there is no initial offset in offset store or the desired offset is out of range: 'smallest','earliest' - automatically reset the offset to the smallest offset, 'largest','latest' - automatically reset the offset to the largest offset, 'error' - trigger an error which is retrieved by consuming messages and checking 'message->err'. <br>*Type: enum value*\noffset.store.path                        |  C  |                 |             . | low        | **DEPRECATED** Path to local file for storing offsets. If the path is a directory a filename will be automatically generated in that directory based on the topic and partition. File-based offset storage will be removed in a future version. <br>*Type: string*\noffset.store.sync.interval.ms            |  C  | -1 .. 86400000  |            -1 | low        | **DEPRECATED** fsync() interval for the offset file, in milliseconds. Use -1 to disable syncing, and 0 for immediate sync after each write. File-based offset storage will be removed in a future version. <br>*Type: integer*\noffset.store.method                      |  C  | file, broker    |        broker | low        | **DEPRECATED** Offset commit store method: 'file' - DEPRECATED: local file store (offset.store.path, et.al), 'broker' - broker commit store (requires \"group.id\" to be configured and Apache Kafka 0.8.2 or later on the broker.). <br>*Type: enum value*\nconsume.callback.max.messages            |  C  | 0 .. 1000000    |             0 | low        | Maximum number of messages to dispatch in one `rd_kafka_consume_callback*()` call (0 = unlimited) <br>*Type: integer*\n\n### C/P legend: C = Consumer, P = Producer, * = both\n",
        "/tmp/vanessa/spack-stage/spack-stage-librdkafka-1.4.4-3ssj4ca5li7y4lpnk4u42eu35dqiqn3i/spack-src/CMakeLists.txt": "cmake_minimum_required(VERSION 3.2)\n\ninclude(\"packaging/cmake/parseversion.cmake\")\nparseversion(\"src/rdkafka.h\")\n\nproject(RdKafka VERSION ${RDKAFKA_VERSION})\n\nset(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} \"${CMAKE_SOURCE_DIR}/packaging/cmake/Modules/\")\n\n# Options. No 'RDKAFKA_' prefix to match old C++ code. {\n\n# This option doesn't affect build in fact, only C code\n# (see 'rd_kafka_version_str'). In CMake the build type feature usually used\n# (like Debug, Release, etc.).\noption(WITHOUT_OPTIMIZATION \"Disable optimization\" OFF)\n\noption(ENABLE_DEVEL \"Enable development asserts, checks, etc\" OFF)\noption(ENABLE_REFCNT_DEBUG \"Enable refcnt debugging\" OFF)\noption(ENABLE_SHAREDPTR_DEBUG \"Enable sharedptr debugging\" OFF)\nset(TRYCOMPILE_SRC_DIR \"${CMAKE_CURRENT_LIST_DIR}/packaging/cmake/try_compile\")\nset(BUILT_WITH \"CMAKE\")\n\n# Toolchain {\nlist(APPEND BUILT_WITH \"${CMAKE_C_COMPILER_ID}\")\nlist(APPEND BUILT_WITH \"${CMAKE_CXX_COMPILER_ID}\")\n# }\n\n# PkgConfig {\nfind_package(PkgConfig QUIET)\nif(PkgConfig_FOUND)\n  set(WITH_PKGCONFIG ON)\n  list(APPEND BUILT_WITH \"PKGCONFIG\")\nendif()\n# }\n\n# LIBM {\ninclude(CheckLibraryExists)\ncheck_library_exists(m pow \"\" WITH_HDRHISTOGRAM)\nif(WITH_HDRHISTOGRAM)\n    list(APPEND BUILT_WITH \"HDRHISTOGRAM\")\nendif()\n# }\n\n# ZLIB {\nfind_package(ZLIB QUIET)\nif(ZLIB_FOUND)\n  set(with_zlib_default ON)\nelse()\n  set(with_zlib_default OFF)\nendif()\noption(WITH_ZLIB \"With ZLIB\" ${with_zlib_default})\nif(WITH_ZLIB)\n  list(APPEND BUILT_WITH \"ZLIB\")\nendif()\n# }\n\n# ZSTD {\nfind_package(Zstd QUIET)\nif(ZSTD_FOUND)\n  set(with_zstd_default ON)\nelse()\n  set(with_zstd_default OFF)\nendif()\noption(WITH_ZSTD \"With ZSTD\" ${with_zstd_default})\nif(WITH_ZSTD)\n  list(APPEND BUILT_WITH \"ZSTD\")\nendif()\n# }\n\n# LibDL {\ntry_compile(\n    WITH_LIBDL\n    \"${CMAKE_CURRENT_BINARY_DIR}/try_compile\"\n    \"${TRYCOMPILE_SRC_DIR}/dlopen_test.c\"\n    LINK_LIBRARIES \"${CMAKE_DL_LIBS}\"\n)\nif(WITH_LIBDL)\n  list(APPEND BUILT_WITH \"LIBDL\")\nendif()\n# }\n\n# WITH_PLUGINS {\nif(WITH_LIBDL)\n  set(with_plugins_default ON)\nelse()\n  set(with_plugins_default OFF)\nendif()\noption(WITH_PLUGINS \"With plugin support\" ${with_plugins_default})\nif(WITH_PLUGINS)\n  list(APPEND BUILT_WITH \"PLUGINS\")\nendif()\n# }\n\n# OpenSSL {\nif(WITH_BUNDLED_SSL) # option from 'h2o' parent project\n  set(with_ssl_default ON)\nelse()\n  find_package(OpenSSL QUIET)\n  if(OpenSSL_FOUND)\n    set(with_ssl_default ON)\n  else()\n    set(with_ssl_default OFF)\n  endif()\nendif()\noption(WITH_SSL \"With SSL\" ${with_ssl_default})\nif(WITH_SSL)\n  list(APPEND BUILT_WITH \"SSL\")\nendif()\n# }\n\n# SASL {\nif(WIN32)\n  set(with_sasl_default ON)\nelse()\n  if(PkgConfig_FOUND)\n    pkg_check_modules(SASL libsasl2)\n    if(SASL_FOUND)\n      set(with_sasl_default ON)\n    else()\n      try_compile(\n          WITH_SASL_CYRUS_BOOL\n          \"${CMAKE_CURRENT_BINARY_DIR}/try_compile\"\n          \"${TRYCOMPILE_SRC_DIR}/libsasl2_test.c\"\n          LINK_LIBRARIES \"-lsasl2\"\n      )\n      if(WITH_SASL_CYRUS_BOOL)\n        set(with_sasl_default ON)\n        set(SASL_LIBRARIES \"-lsasl2\")\n      else()\n        set(with_sasl_default OFF)\n      endif()\n    endif()\n  endif()\nendif()\noption(WITH_SASL \"With SASL\" ${with_sasl_default})\nif(WITH_SASL)\n  if(WITH_SSL)\n    set(WITH_SASL_SCRAM ON)\n    set(WITH_SASL_OAUTHBEARER ON)\n    list(APPEND BUILT_WITH \"SASL_SCRAM SASL_OAUTHBEARER\")\n  endif()\n  if(NOT WIN32)\n    set(WITH_SASL_CYRUS ON)\n    list(APPEND BUILT_WITH \"SASL_CYRUS\")\n  endif()\nendif()\n# }\n\n# LZ4 {\noption(ENABLE_LZ4_EXT \"Enable external LZ4 library support\" ON)\nset(WITH_LZ4_EXT OFF)\nif(ENABLE_LZ4_EXT)\n  find_package(LZ4)\n  if(LZ4_FOUND)\n    set(WITH_LZ4_EXT ON)\n    list(APPEND BUILT_WITH \"LZ4_EXT\")\n  else()\n    message(STATUS \"Using bundled LZ4 implementation.\")\n  endif()\nendif()\n# }\n\noption(RDKAFKA_BUILD_STATIC \"Build static rdkafka library\" OFF)\noption(RDKAFKA_BUILD_EXAMPLES \"Build examples\" ON)\noption(RDKAFKA_BUILD_TESTS \"Build tests\" ON)\nif(WIN32)\n    option(WITHOUT_WIN32_CONFIG \"Avoid including win32_config.h on cmake builds\" ON)\nendif(WIN32)\n\n# In:\n# * TRYCOMPILE_SRC_DIR\n# Out:\n# * HAVE_ATOMICS_32\n# * HAVE_ATOMICS_32_SYNC\n# * HAVE_ATOMICS_64\n# * HAVE_ATOMICS_64_SYNC\n# * HAVE_REGEX\n# * HAVE_STRNDUP\n# * HAVE_PTHREAD_SETNAME_GNU\n# * HAVE_PTHREAD_SETNAME_DARWIN\n# * WITH_C11THREADS\n# * WITH_CRC32C_HW\n# * LINK_ATOMIC\ninclude(\"packaging/cmake/try_compile/rdkafka_setup.cmake\")\nif(WITH_C11THREADS)\n  list(APPEND BUILT_WITH \"C11THREADS\")\nendif()\nif(WITH_CRC32C_HW)\n  list(APPEND BUILT_WITH \"CRC32C_HW\")\nendif()\n\nset(GENERATED_DIR \"${CMAKE_CURRENT_BINARY_DIR}/generated\")\n\n# In:\n# * WITHOUT_OPTIMIZATION\n# * ENABLE_DEVEL\n# * ENABLE_REFCNT_DEBUG\n# * ENABLE_SHAREDPTR_DEBUG\n# * HAVE_ATOMICS_32\n# * HAVE_ATOMICS_32_SYNC\n# * HAVE_ATOMICS_64\n# * HAVE_ATOMICS_64_SYNC\n# * WITH_ZLIB\n# * WITH_SSL\n# * WITH_SASL\n# * HAVE_REGEX\n# * HAVE_STRNDUP\n# * HAVE_PTHREAD_SETNAME_GNU\n# * HAVE_PTHREAD_SETNAME_DARWIN\nlist(APPEND BUILT_WITH \"SNAPPY\")\nlist(APPEND BUILT_WITH \"SOCKEM\")\nstring(REPLACE \";\" \" \" BUILT_WITH \"${BUILT_WITH}\")\nconfigure_file(\"packaging/cmake/config.h.in\" \"${GENERATED_DIR}/config.h\")\n\n# Installation (https://github.com/forexample/package-example) {\n\ninclude(GNUInstallDirs)\n\nset(config_install_dir \"lib/cmake/${PROJECT_NAME}\")\n\nset(generated_dir \"${CMAKE_CURRENT_BINARY_DIR}/generated\")\n\nset(project_config \"${generated_dir}/${PROJECT_NAME}Config.cmake\")\nset(project_version \"${generated_dir}/${PROJECT_NAME}ConfigVersion.cmake\")\nset(targets_export_name \"${PROJECT_NAME}Targets\")\nset(namespace \"${PROJECT_NAME}::\")\n\ninclude(CMakePackageConfigHelpers)\n\n# In:\n#   * targets_export_name\n#   * PROJECT_NAME\nconfigure_package_config_file(\n    \"packaging/cmake/Config.cmake.in\"\n    \"${project_config}\"\n    INSTALL_DESTINATION \"${config_install_dir}\"\n)\n\nwrite_basic_package_version_file(\n    \"${project_version}\"\n    VERSION ${PROJECT_VERSION}\n    COMPATIBILITY AnyNewerVersion\n)\n\ninstall(\n    FILES \"${project_config}\" \"${project_version}\" \"packaging/cmake/Modules/FindLZ4.cmake\"\n    DESTINATION \"${config_install_dir}\"\n)\n\ninstall(\n    EXPORT \"${targets_export_name}\"\n    NAMESPACE \"${namespace}\"\n    DESTINATION \"${config_install_dir}\"\n)\n\ninstall(\n    FILES LICENSES.txt\n    DESTINATION \"share/licenses/librdkafka\"\n)\n\n# }\n\nadd_subdirectory(src)\nadd_subdirectory(src-cpp)\n\nif(RDKAFKA_BUILD_EXAMPLES)\n  add_subdirectory(examples)\nendif()\n\nif(RDKAFKA_BUILD_TESTS)\n  enable_testing()\n  add_subdirectory(tests)\nendif()\n",
        "/tmp/vanessa/spack-stage/spack-stage-librdkafka-1.4.4-3ssj4ca5li7y4lpnk4u42eu35dqiqn3i/spack-src/configure.self": "#!/bin/bash\n#\n\nmkl_meta_set \"description\" \"name\"      \"librdkafka\"\nmkl_meta_set \"description\" \"oneline\"   \"The Apache Kafka C/C++ library\"\nmkl_meta_set \"description\" \"long\"      \"Full Apache Kafka protocol support, including producer and consumer\"\nmkl_meta_set \"description\" \"copyright\" \"Copyright (c) 2012-2019 Magnus Edenhill\"\n\n# Enable generation of pkg-config .pc file\nmkl_mkvar_set \"\" GEN_PKG_CONFIG y\n\n\nmkl_require cxx\nmkl_require lib\nmkl_require pic\nmkl_require atomics\nmkl_require good_cflags\nmkl_require socket\nmkl_require zlib\nmkl_require libzstd\nmkl_require libssl\nmkl_require libsasl2\n\n# Generate version variables from rdkafka.h hex version define\n# so we can use it as string version when generating a pkg-config file.\n\nverdef=$(grep '^#define  *RD_KAFKA_VERSION  *0x' src/rdkafka.h | sed 's/^#define  *RD_KAFKA_VERSION  *\\(0x[a-f0-9]*\\)\\.*$/\\1/')\nmkl_require parseversion hex2str \"%d.%d.%d\" \"$verdef\" RDKAFKA_VERSION_STR\n\n\nmkl_toggle_option \"Development\" ENABLE_DEVEL \"--enable-devel\" \"Enable development asserts, checks, etc\" \"n\"\nmkl_toggle_option \"Development\" ENABLE_VALGRIND \"--enable-valgrind\" \"Enable in-code valgrind suppressions\" \"n\"\n\nmkl_toggle_option \"Development\" ENABLE_REFCNT_DEBUG \"--enable-refcnt-debug\" \"Enable refcnt debugging\" \"n\"\n\nmkl_toggle_option \"Development\" ENABLE_SHAREDPTR_DEBUG \"--enable-sharedptr-debug\" \"Enable sharedptr debugging\" \"n\"\n\nmkl_toggle_option \"Feature\" ENABLE_LZ4_EXT \"--enable-lz4-ext\" \"Enable external LZ4 library support (builtin version 1.9.2)\" \"y\"\nmkl_toggle_option \"Feature\" ENABLE_LZ4_EXT \"--enable-lz4\" \"Deprecated: alias for --enable-lz4-ext\" \"y\"\n\n# librdkafka with TSAN won't work with glibc C11 threads on Ubuntu 19.04.\n# This option allows disabling libc-based C11 threads and instead\n# use the builtin tinycthread alternative.\nmkl_toggle_option \"Feature\" ENABLE_C11THREADS \"--enable-c11threads\" \"Enable detection of C11 threads support in libc\" \"y\"\n\nmkl_toggle_option \"Feature\" ENABLE_SYSLOG \"--enable-syslog\" \"Enable logging to syslog\" \"y\"\n\n\nfunction checks {\n\n    # -lrt is needed on linux for clock_gettime: link it if it exists.\n    mkl_lib_check \"librt\" \"\" cont CC \"-lrt\"\n\n    # pthreads required (even if C11 threads available) for rwlocks.\n    mkl_lib_check \"libpthread\" \"\" fail CC \"-lpthread\" \\\n                  \"#include <pthread.h>\"\n\n    if [[ $ENABLE_C11THREADS == \"y\" ]]; then\n        # Use internal tinycthread if C11 threads not available.\n        # Requires -lpthread on glibc c11 threads, thus the use of $LIBS.\n        mkl_lib_check \"c11threads\" WITH_C11THREADS disable CC \"$LIBS\" \\\n                      \"\n#include <threads.h>\n\n\nstatic int start_func (void *arg) {\n   int iarg = *(int *)arg;\n   return iarg;\n}\n\nvoid foo (void) {\n    thrd_t thr;\n    int arg = 1;\n    if (thrd_create(&thr, start_func, (void *)&arg) != thrd_success) {\n      ;\n    }\n}\n\"\n    fi\n\n    # Check if dlopen() is available\n    mkl_lib_check \"libdl\" \"WITH_LIBDL\" disable CC \"-ldl\" \\\n\"\n#include <stdlib.h>\n#include <dlfcn.h>\nvoid foo (void) {\n   void *h = dlopen(\\\"__bad_lib\\\", 0);\n   void *p = dlsym(h, \\\"sym\\\");\n   if (p)\n     p = NULL;\n   dlclose(h);\n}\"\n\n    if [[ $WITH_LIBDL == \"y\" ]]; then\n        mkl_allvar_set WITH_PLUGINS WITH_PLUGINS y\n    fi\n\n    # optional libs\n    mkl_check \"zlib\" disable\n    mkl_check \"libssl\" disable\n    mkl_check \"libsasl2\" disable\n    mkl_check \"libzstd\" disable\n\n    if mkl_lib_check \"libm\" \"\" disable CC \"-lm\" \\\n                     \"#include <math.h>\"; then\n        mkl_allvar_set WITH_HDRHISTOGRAM WITH_HDRHISTOGRAM y\n    fi\n\n    # Use builtin lz4 if linking statically or if --disable-lz4-ext is used.\n    if [[ $MKL_SOURCE_DEPS_ONLY != y ]] && [[ $WITH_STATIC_LINKING != y ]] && [[ $ENABLE_LZ4_EXT == y ]]; then\n        mkl_meta_set \"liblz4\" \"static\" \"liblz4.a\"\n        mkl_lib_check \"liblz4\" \"WITH_LZ4_EXT\" disable CC \"-llz4\" \\\n                      \"#include <lz4frame.h>\"\n    fi\n\n    if [[ $ENABLE_SYSLOG == y ]]; then\n        mkl_compile_check \"syslog\" \"WITH_SYSLOG\" disable CC \"\" \\\n                          '\n#include <syslog.h>\nvoid foo (void) {\n    syslog(LOG_INFO, \"test\");\n}'\n    fi\n\n    # rapidjson (>=1.1.0) is used in tests to verify statistics data, not used\n    # by librdkafka itself.\n    mkl_compile_check \"rapidjson\" \"WITH_RAPIDJSON\" disable CXX \"\" \\\n                      \"#include <rapidjson/schema.h>\"\n\n    # Snappy support is built-in\n    mkl_allvar_set WITH_SNAPPY WITH_SNAPPY y\n\n    # Enable sockem (tests)\n    mkl_allvar_set WITH_SOCKEM WITH_SOCKEM y\n\n    if [[ \"$ENABLE_SASL\" == \"y\" ]]; then\n        mkl_meta_set \"libsasl2\" \"deb\" \"libsasl2-dev\"\n        mkl_meta_set \"libsasl2\" \"rpm\" \"cyrus-sasl\"\n        if ! mkl_lib_check \"libsasl2\" \"WITH_SASL_CYRUS\" disable CC \"-lsasl2\" \"#include <sasl/sasl.h>\" ; then\n            mkl_lib_check \"libsasl\" \"WITH_SASL_CYRUS\" disable CC \"-lsasl\" \\\n                          \"#include <sasl/sasl.h>\"\n        fi\n    fi\n\n    if [[ \"$WITH_SSL\" == \"y\" ]]; then\n        # SASL SCRAM requires base64 encoding from OpenSSL\n        mkl_allvar_set WITH_SASL_SCRAM WITH_SASL_SCRAM y\n        # SASL OAUTHBEARER's default unsecured JWS implementation\n        # requires base64 encoding from OpenSSL\n        mkl_allvar_set WITH_SASL_OAUTHBEARER WITH_SASL_OAUTHBEARER y\n    fi\n\n    # CRC32C: check for crc32 instruction support.\n    #         This is also checked during runtime using cpuid.\n    mkl_compile_check crc32chw WITH_CRC32C_HW disable CC \"\" \\\n                      \"\n#include <inttypes.h>\n#include <stdio.h>\n#define LONGx1 \\\"8192\\\"\n#define LONGx2 \\\"16384\\\"\nvoid foo (void) {\n   const char *n = \\\"abcdefghijklmnopqrstuvwxyz0123456789\\\";\n   uint64_t c0 = 0, c1 = 1, c2 = 2;\n   uint64_t s;\n   uint32_t eax = 1, ecx;\n   __asm__(\\\"cpuid\\\"\n           : \\\"=c\\\"(ecx)\n           : \\\"a\\\"(eax)\n           : \\\"%ebx\\\", \\\"%edx\\\");\n   __asm__(\\\"crc32b\\t\\\" \\\"(%1), %0\\\"\n           : \\\"=r\\\"(c0)\n           : \\\"r\\\"(n), \\\"0\\\"(c0));\n   __asm__(\\\"crc32q\\t\\\" \\\"(%3), %0\\n\\t\\\"\n           \\\"crc32q\\t\\\" LONGx1 \\\"(%3), %1\\n\\t\\\"\n           \\\"crc32q\\t\\\" LONGx2 \\\"(%3), %2\\\"\n           : \\\"=r\\\"(c0), \\\"=r\\\"(c1), \\\"=r\\\"(c2)\n           : \\\"r\\\"(n), \\\"0\\\"(c0), \\\"1\\\"(c1), \\\"2\\\"(c2));\n  s = c0 + c1 + c2;\n  printf(\\\"avoiding unused code removal by printing %d, %d, %d\\n\\\", (int)s, (int)eax, (int)ecx);\n}\n\"\n\n\n    # Check for libc regex\n    mkl_compile_check \"regex\" \"HAVE_REGEX\" disable CC \"\" \\\n\"\n#include <stddef.h>\n#include <regex.h>\nvoid foo (void) {\n   regcomp(NULL, NULL, 0);\n   regexec(NULL, NULL, 0, NULL, 0);\n   regerror(0, NULL, NULL, 0);\n   regfree(NULL);\n}\"\n\n\n    # Older g++ (<=4.1?) gives invalid warnings for the C++ code.\n    mkl_mkvar_append CXXFLAGS CXXFLAGS \"-Wno-non-virtual-dtor\"\n\n    # Required on SunOS\n    if [[ $MKL_DISTRO == \"sunos\" ]]; then\n\tmkl_mkvar_append CPPFLAGS CPPFLAGS \"-D_POSIX_PTHREAD_SEMANTICS -D_REENTRANT -D__EXTENSIONS__\"\n\t# Source defines _POSIX_C_SOURCE to 200809L for Solaris, and this is\n\t# incompatible on that platform with compilers < c99.\n\tmkl_mkvar_append CFLAGS CFLAGS \"-std=c99\"\n    fi\n\n    # Check if strndup() is available (isn't on Solaris 10)\n    mkl_compile_check \"strndup\" \"HAVE_STRNDUP\" disable CC \"\" \\\n\"#include <string.h>\nint foo (void) {\n   return strndup(\\\"hi\\\", 2) ? 0 : 1;\n}\"\n\n    # Check if strlcpy() is available\n    mkl_compile_check \"strlcpy\" \"HAVE_STRLCPY\" disable CC \"\" \\\n\"\n#define _DARWIN_C_SOURCE\n#include <string.h>\nint foo (void) {\n    char dest[4];\n   return strlcpy(dest, \\\"something\\\", sizeof(dest));\n}\"\n\n    # Check if strerror_r() is available.\n    # The check for GNU vs XSI is done in rdposix.h since\n    # we can't rely on all defines to be set here (_GNU_SOURCE).\n    mkl_compile_check \"strerror_r\" \"HAVE_STRERROR_R\" disable CC \"\" \\\n\"#include <string.h>\nconst char *foo (void) {\n   static char buf[64];\n   strerror_r(1, buf, sizeof(buf));\n   return buf;\n}\"\n\n\n    # See if GNU's pthread_setname_np() is available, and in what form.\n    mkl_compile_check \"pthread_setname_gnu\" \"HAVE_PTHREAD_SETNAME_GNU\" disable CC \"-D_GNU_SOURCE -lpthread\" \\\n'\n#include <pthread.h>\n\nvoid foo (void) {\n  pthread_setname_np(pthread_self(), \"abc\");\n}\n' || \\\n    mkl_compile_check \"pthread_setname_darwin\" \"HAVE_PTHREAD_SETNAME_DARWIN\" disable CC \"-D_DARWIN_C_SOURCE -lpthread\" \\\n'\n#include <pthread.h>\n\nvoid foo (void) {\n  pthread_setname_np(\"abc\");\n}\n'\n\n    # Figure out what tool to use for dumping public symbols.\n    # We rely on configure.cc setting up $NM if it exists.\n    if mkl_env_check \"nm\" \"\" cont \"NM\" ; then\n\t# nm by future mk var\n\tif [[ $MKL_DISTRO == \"osx\" || $MKL_DISTRO == \"aix\" ]]; then\n\t    mkl_mkvar_set SYMDUMPER SYMDUMPER '$(NM) -g'\n\telse\n\t    mkl_mkvar_set SYMDUMPER SYMDUMPER '$(NM) -D'\n\tfi\n    else\n\t# Fake symdumper\n\tmkl_mkvar_set SYMDUMPER SYMDUMPER 'echo'\n    fi\n\n    # The linker-script generator (lds-gen.py) requires python3\n    if [[ $WITH_LDS == y ]]; then\n        if ! mkl_command_check python3 \"HAVE_PYTHON\" \"disable\" \"python3 -V\"; then\n            mkl_err \"disabling linker-script since python3 is not available\"\n            mkl_mkvar_set WITH_LDS WITH_LDS \"n\"\n        fi\n    fi\n\n    if [[ \"$ENABLE_VALGRIND\" == \"y\" ]]; then\n\tmkl_compile_check valgrind WITH_VALGRIND disable CC \"\" \\\n\t\t\t  \"#include <valgrind/memcheck.h>\"\n    fi\n\n    # getrusage() is used by the test framework\n    mkl_compile_check \"getrusage\" \"HAVE_GETRUSAGE\" disable CC \"\" \\\n'\n#include <stdio.h>\n#include <sys/time.h>\n#include <sys/resource.h>\n\n\nvoid foo (void) {\n  struct rusage ru;\n  if (getrusage(RUSAGE_SELF, &ru) == -1)\n    return;\n  printf(\"ut %ld, st %ld, maxrss %ld, nvcsw %ld\\n\",\n         (long int)ru.ru_utime.tv_usec,\n         (long int)ru.ru_stime.tv_usec,\n         (long int)ru.ru_maxrss,\n         (long int)ru.ru_nvcsw);\n}'\n\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-librdkafka-1.4.4-3ssj4ca5li7y4lpnk4u42eu35dqiqn3i/spack-src/src/rddl.c": "/*\n * librdkafka - The Apache Kafka C/C++ library\n *\n * Copyright (c) 2017 Magnus Edenhill\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"rd.h\"\n#include \"rddl.h\"\n\n#if WITH_LIBDL\n#include <dlfcn.h>\n\n#elif defined( _MSC_VER)\n\n#else\n#error \"Dynamic library loading not supported on this platform\"\n#endif\n\n\n\n/**\n * @brief Latest thread-local dl error, normalized to suit our logging.\n * @returns a newly allocated string that must be freed\n */\nstatic char *rd_dl_error (void) {\n#if WITH_LIBDL\n        char *errstr;\n        char *s;\n        errstr = dlerror();\n        if (!errstr)\n                return rd_strdup(\"No error returned from dlerror()\");\n\n        errstr = rd_strdup(errstr);\n        /* Change newlines to separators. */\n        while ((s = strchr(errstr, '\\n')))\n                *s = '.';\n\n        return errstr;\n\n#elif defined(_MSC_VER)\n        char buf[1024];\n        rd_strerror_w32(GetLastError(), buf, sizeof(buf));\n        return rd_strdup(buf);\n#endif\n}\n\n/**\n * @brief Attempt to load library \\p path.\n * @returns the library handle (platform dependent, thus opaque) on success,\n *          else NULL.\n */\nstatic rd_dl_hnd_t *\nrd_dl_open0 (const char *path, char *errstr, size_t errstr_size) {\n        void *handle;\n        const char *loadfunc;\n#if WITH_LIBDL\n        loadfunc = \"dlopen()\";\n        handle = dlopen(path, RTLD_NOW | RTLD_LOCAL);\n#elif defined(_MSC_VER)\n        loadfunc = \"LoadLibrary()\";\n        handle = (void *)LoadLibraryA(path);\n#endif\n        if (!handle) {\n                char *dlerrstr = rd_dl_error();\n                rd_snprintf(errstr, errstr_size, \"%s failed: %s\",\n                            loadfunc, dlerrstr);\n                rd_free(dlerrstr);\n        }\n        return (rd_dl_hnd_t *)handle;\n}\n\n\n/**\n * @brief Attempt to load library \\p path, possibly with a filename extension\n *        which will be automatically resolved depending on platform.\n * @returns the library handle (platform dependent, thus opaque) on success,\n *          else NULL.\n */\nrd_dl_hnd_t *rd_dl_open (const char *path, char *errstr, size_t errstr_size) {\n        rd_dl_hnd_t *handle;\n        char *extpath;\n        size_t pathlen;\n        const char *td, *fname;\n        const char *solib_ext = SOLIB_EXT;\n\n        /* Try original path first. */\n        handle = rd_dl_open0(path, errstr, errstr_size);\n        if (handle)\n                return handle;\n\n        /* Original path not found, see if we can append the solib_ext\n         * filename extension. */\n\n        /* Get filename and filename extension.\n         * We can't rely on basename(3) since it is not portable */\n        fname = strrchr(path, '/');\n#ifdef _MSC_VER\n        td = strrchr(path, '\\\\');\n        if (td > fname)\n                fname = td;\n#endif\n        if (!fname)\n                fname = path;\n\n        td = strrchr(fname, '.');\n\n        /* If there is a filename extension ('.' within the last characters)\n         * then bail out, we will not append an extension in this case. */\n        if (td && td >= fname + strlen(fname) - strlen(SOLIB_EXT))\n                return NULL;\n\n        /* Append platform-specific library extension. */\n        pathlen = strlen(path);\n        extpath = rd_alloca(pathlen + strlen(solib_ext) + 1);\n        memcpy(extpath, path, pathlen);\n        memcpy(extpath+pathlen, solib_ext, strlen(solib_ext) + 1);\n\n        /* Try again with extension */\n        return rd_dl_open0(extpath, errstr, errstr_size);\n}\n\n\n/**\n * @brief Close handle previously returned by rd_dl_open()\n * @remark errors are ignored (what can we do anyway?)\n */\nvoid rd_dl_close (rd_dl_hnd_t *handle) {\n#if WITH_LIBDL\n        dlclose((void *)handle);\n#elif defined(_MSC_VER)\n        FreeLibrary((HMODULE)handle);\n#endif\n}\n\n/**\n * @brief look up address of \\p symbol in library handle \\p handle\n * @returns the function pointer on success or NULL on error.\n */\nvoid *\nrd_dl_sym (rd_dl_hnd_t *handle, const char *symbol,\n           char *errstr, size_t errstr_size) {\n        void *func;\n#if WITH_LIBDL\n        func = dlsym((void *)handle, symbol);\n#elif defined(_MSC_VER)\n        func = GetProcAddress((HMODULE)handle, symbol);\n#endif\n        if (!func) {\n                char *dlerrstr = rd_dl_error();\n                rd_snprintf(errstr, errstr_size,\n                            \"Failed to load symbol \\\"%s\\\": %s\",\n                            symbol, dlerrstr);\n                rd_free(dlerrstr);\n        }\n        return func;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-librdkafka-1.4.4-3ssj4ca5li7y4lpnk4u42eu35dqiqn3i/spack-src/src/rdkafka_conf.c": "/*\n * librdkafka - Apache Kafka C library\n *\n * Copyright (c) 2012,2013 Magnus Edenhill\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met: \n * \n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer. \n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution. \n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE \n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE \n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR \n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF \n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS \n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN \n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"rdkafka_int.h\"\n#include \"rd.h\"\n#include \"rdfloat.h\"\n\n#include <stdlib.h>\n#include <ctype.h>\n#include <stddef.h>\n\n#include \"rdkafka_int.h\"\n#include \"rdkafka_feature.h\"\n#include \"rdkafka_interceptor.h\"\n#include \"rdkafka_idempotence.h\"\n#include \"rdkafka_sasl_oauthbearer.h\"\n#if WITH_PLUGINS\n#include \"rdkafka_plugin.h\"\n#endif\n#include \"rdunittest.h\"\n\n#ifndef _MSC_VER\n#include <netinet/tcp.h>\n#else\n\n#ifndef WIN32_MEAN_AND_LEAN\n#define WIN32_MEAN_AND_LEAN\n#endif\n#include <windows.h>\n#endif\n\nstruct rd_kafka_property {\n\trd_kafka_conf_scope_t scope;\n\tconst char *name;\n\tenum {\n\t\t_RK_C_STR,\n\t\t_RK_C_INT,\n                _RK_C_DBL,  /* Double */\n\t\t_RK_C_S2I,  /* String to Integer mapping.\n\t\t\t     * Supports limited canonical str->int mappings\n\t\t\t     * using s2i[] */\n\t\t_RK_C_S2F,  /* CSV String to Integer flag mapping (OR:ed) */\n\t\t_RK_C_BOOL,\n\t\t_RK_C_PTR,  /* Only settable through special set functions */\n                _RK_C_PATLIST, /* Pattern list */\n                _RK_C_KSTR, /* Kafka string */\n                _RK_C_ALIAS, /* Alias: points to other property through .sdef */\n                _RK_C_INTERNAL, /* Internal, don't expose to application */\n                _RK_C_INVALID,  /* Invalid property, used to catch known\n                                 * but unsupported Java properties. */\n\t} type;\n\tint   offset;\n\tconst char *desc;\n\tint   vmin;\n\tint   vmax;\n\tint   vdef;        /* Default value (int) */\n\tconst char *sdef;  /* Default value (string) */\n        void  *pdef;       /* Default value (pointer) */\n        double ddef;       /* Default value (double) */\n        double dmin;\n        double dmax;\n\tstruct {\n\t\tint val;\n\t\tconst char *str;\n\t} s2i[20];  /* _RK_C_S2I and _RK_C_S2F */\n\n\t/* Value validator (STR) */\n\tint (*validate) (const struct rd_kafka_property *prop,\n\t\t\t const char *val, int ival);\n\n        /* Configuration object constructors and destructor for use when\n         * the property value itself is not used, or needs extra care. */\n        void (*ctor) (int scope, void *pconf);\n        void (*dtor) (int scope, void *pconf);\n        void (*copy) (int scope, void *pdst, const void *psrc,\n                      void *dstptr, const void *srcptr,\n                      size_t filter_cnt, const char **filter);\n\n        rd_kafka_conf_res_t (*set) (int scope, void *pconf,\n                                    const char *name, const char *value,\n                                    void *dstptr,\n                                    rd_kafka_conf_set_mode_t set_mode,\n                                    char *errstr, size_t errstr_size);\n};\n\n\n#define _RK(field)  offsetof(rd_kafka_conf_t, field)\n#define _RKT(field) offsetof(rd_kafka_topic_conf_t, field)\n\n\nstatic rd_kafka_conf_res_t\nrd_kafka_anyconf_get0 (const void *conf, const struct rd_kafka_property *prop,\n                       char *dest, size_t *dest_size);\n\n\n\n\n/**\n * @returns a unique index for property \\p prop, using the byte position\n *          of the field.\n */\nstatic RD_INLINE int rd_kafka_prop2idx (const struct rd_kafka_property *prop) {\n        return prop->offset;\n}\n\n\n\n/**\n * @brief Set the property as modified.\n *\n * We do this by mapping the property's conf struct field byte offset\n * to a bit in a bit vector.\n * If the bit is set the property has been modified, otherwise it is\n * at its default unmodified value.\n *\n * \\p is_modified 1: set as modified, 0: clear modified\n */\nstatic void rd_kafka_anyconf_set_modified (void *conf,\n                                           const struct rd_kafka_property *prop,\n                                           int is_modified) {\n        int idx = rd_kafka_prop2idx(prop);\n        int bkt = idx / 64;\n        uint64_t bit = (uint64_t)1 << (idx % 64);\n        struct rd_kafka_anyconf_hdr *confhdr = conf;\n\n        rd_assert(idx < RD_KAFKA_CONF_PROPS_IDX_MAX &&\n                  *\"Increase RD_KAFKA_CONF_PROPS_IDX_MAX\");\n\n        if (is_modified)\n                confhdr->modified[bkt] |= bit;\n        else\n                confhdr->modified[bkt] &= ~bit;\n}\n\n/**\n * @brief Clear is_modified for all properties.\n * @warning Does NOT clear/reset the value.\n */\nstatic void rd_kafka_anyconf_clear_all_is_modified (void *conf) {\n        struct rd_kafka_anyconf_hdr *confhdr = conf;\n\n        memset(confhdr, 0, sizeof(*confhdr));\n}\n\n\n/**\n * @returns true of the property has been set/modified, else false.\n */\nstatic rd_bool_t\nrd_kafka_anyconf_is_modified (const void *conf,\n                              const struct rd_kafka_property *prop) {\n        int idx = rd_kafka_prop2idx(prop);\n        int bkt = idx / 64;\n        uint64_t bit = (uint64_t)1 << (idx % 64);\n        const struct rd_kafka_anyconf_hdr *confhdr = conf;\n\n        return !!(confhdr->modified[bkt] & bit);\n}\n\n\n\n/**\n * @brief Validate \\p broker.version.fallback property.\n */\nstatic int\nrd_kafka_conf_validate_broker_version (const struct rd_kafka_property *prop,\n\t\t\t\t       const char *val, int ival) {\n\tstruct rd_kafka_ApiVersion *apis;\n\tsize_t api_cnt;\n\treturn rd_kafka_get_legacy_ApiVersions(val, &apis, &api_cnt, NULL);\n}\n\n/**\n * @brief Validate that string is a single item, without delimters (, space).\n */\nstatic RD_UNUSED int\nrd_kafka_conf_validate_single (const struct rd_kafka_property *prop,\n\t\t\t\tconst char *val, int ival) {\n\treturn !strchr(val, ',') && !strchr(val, ' ');\n}\n\n/**\n * @brief Validate builtin partitioner string\n */\nstatic RD_UNUSED int\nrd_kafka_conf_validate_partitioner (const struct rd_kafka_property *prop,\n                                    const char *val, int ival) {\n        return !strcmp(val, \"random\") ||\n                !strcmp(val, \"consistent\") ||\n                !strcmp(val, \"consistent_random\") ||\n                !strcmp(val, \"murmur2\") ||\n                !strcmp(val, \"murmur2_random\") ||\n                !strcmp(val, \"fnv1a\") ||\n                !strcmp(val, \"fnv1a_random\");\n}\n\n\n/**\n * librdkafka configuration property definitions.\n */\nstatic const struct rd_kafka_property rd_kafka_properties[] = {\n\t/* Global properties */\n\t{ _RK_GLOBAL, \"builtin.features\", _RK_C_S2F, _RK(builtin_features),\n\t\"Indicates the builtin features for this build of librdkafka. \"\n\t\"An application can either query this value or attempt to set it \"\n\t\"with its list of required features to check for library support.\",\n\t0, 0x7fffffff, 0xffff,\n\t.s2i = {\n#if WITH_ZLIB\n\t\t{ 0x1, \"gzip\" },\n#endif\n#if WITH_SNAPPY\n\t\t{ 0x2, \"snappy\" },\n#endif\n#if WITH_SSL\n\t\t{ 0x4, \"ssl\" },\n#endif\n                { 0x8, \"sasl\" },\n\t\t{ 0x10, \"regex\" },\n\t\t{ 0x20, \"lz4\" },\n#if defined(_MSC_VER) || WITH_SASL_CYRUS\n                { 0x40, \"sasl_gssapi\" },\n#endif\n                { 0x80, \"sasl_plain\" },\n#if WITH_SASL_SCRAM\n                { 0x100, \"sasl_scram\" },\n#endif\n#if WITH_PLUGINS\n                { 0x200, \"plugins\" },\n#endif\n#if WITH_ZSTD\n\t\t{ 0x400, \"zstd\" },\n#endif\n#if WITH_SASL_OAUTHBEARER\n                { 0x800, \"sasl_oauthbearer\" },\n#endif\n\t\t{ 0, NULL }\n\t\t}\n\t},\n\t{ _RK_GLOBAL, \"client.id\", _RK_C_STR, _RK(client_id_str),\n\t  \"Client identifier.\",\n\t  .sdef =  \"rdkafka\" },\n        { _RK_GLOBAL|_RK_HIDDEN, \"client.software.name\", _RK_C_STR,\n          _RK(sw_name),\n          \"Client software name as reported to broker version >= v2.4.0. \"\n          \"Broker-side character restrictions apply, as of broker version \"\n          \"v2.4.0 the allowed characters are `a-zA-Z0-9.-`. The local client \"\n          \"will replace any other character with `-` and strip leading and \"\n          \"trailing non-alphanumeric characters before tranmission to \"\n          \"the broker. \"\n          \"This property should only be set by high-level language \"\n          \"librdkafka client bindings.\",\n          .sdef = \"librdkafka\"\n        },\n        { _RK_GLOBAL|_RK_HIDDEN, \"client.software.version\", _RK_C_STR,\n          _RK(sw_version),\n          \"Client software version as reported to broker version >= v2.4.0. \"\n          \"Broker-side character restrictions apply, as of broker version \"\n          \"v2.4.0 the allowed characters are `a-zA-Z0-9.-`. The local client \"\n          \"will replace any other character with `-` and strip leading and \"\n          \"trailing non-alphanumeric characters before tranmission to \"\n          \"the broker. \"\n          \"This property should only be set by high-level language \"\n          \"librdkafka client bindings.\"\n          \"If changing this property it is highly recommended to append the \"\n          \"librdkafka version.\",\n        },\n\t{ _RK_GLOBAL|_RK_HIGH, \"metadata.broker.list\", _RK_C_STR,\n          _RK(brokerlist),\n\t  \"Initial list of brokers as a CSV list of broker host or host:port. \"\n\t  \"The application may also use `rd_kafka_brokers_add()` to add \"\n\t  \"brokers during runtime.\" },\n\t{ _RK_GLOBAL|_RK_HIGH, \"bootstrap.servers\", _RK_C_ALIAS, 0,\n\t  \"See metadata.broker.list\",\n\t  .sdef = \"metadata.broker.list\" },\n        { _RK_GLOBAL|_RK_MED, \"message.max.bytes\", _RK_C_INT, _RK(max_msg_size),\n          \"Maximum Kafka protocol request message size. \"\n          \"Due to differing framing overhead between protocol versions the \"\n          \"producer is unable to reliably enforce a strict max message limit \"\n          \"at produce time and may exceed the maximum size by one message in \"\n          \"protocol ProduceRequests, the broker will enforce the the topic's \"\n          \"`max.message.bytes` limit (see Apache Kafka documentation).\",\n          1000, 1000000000, 1000000 },\n\t{ _RK_GLOBAL, \"message.copy.max.bytes\", _RK_C_INT,\n\t  _RK(msg_copy_max_size),\n\t  \"Maximum size for message to be copied to buffer. \"\n\t  \"Messages larger than this will be passed by reference (zero-copy) \"\n\t  \"at the expense of larger iovecs.\",\n\t  0, 1000000000, 0xffff },\n\t{ _RK_GLOBAL|_RK_MED, \"receive.message.max.bytes\", _RK_C_INT,\n          _RK(recv_max_msg_size),\n          \"Maximum Kafka protocol response message size. \"\n          \"This serves as a safety precaution to avoid memory exhaustion in \"\n          \"case of protocol hickups. \"\n          \"This value must be at least `fetch.max.bytes`  + 512 to allow \"\n          \"for protocol overhead; the value is adjusted automatically \"\n          \"unless the configuration property is explicitly set.\",\n\t  1000, INT_MAX, 100000000 },\n\t{ _RK_GLOBAL, \"max.in.flight.requests.per.connection\", _RK_C_INT,\n\t  _RK(max_inflight),\n\t  \"Maximum number of in-flight requests per broker connection. \"\n\t  \"This is a generic property applied to all broker communication, \"\n\t  \"however it is primarily relevant to produce requests. \"\n\t  \"In particular, note that other mechanisms limit the number \"\n\t  \"of outstanding consumer fetch request per broker to one.\",\n\t  1, 1000000, 1000000 },\n        { _RK_GLOBAL, \"max.in.flight\", _RK_C_ALIAS,\n          .sdef = \"max.in.flight.requests.per.connection\" },\n\t{ _RK_GLOBAL, \"metadata.request.timeout.ms\", _RK_C_INT,\n\t  _RK(metadata_request_timeout_ms),\n\t  \"Non-topic request timeout in milliseconds. \"\n\t  \"This is for metadata requests, etc.\",\n\t  10, 900*1000, 60*1000},\n        { _RK_GLOBAL, \"topic.metadata.refresh.interval.ms\", _RK_C_INT,\n          _RK(metadata_refresh_interval_ms),\n          \"Period of time in milliseconds at which topic and broker \"\n          \"metadata is refreshed in order to proactively discover any new \"\n          \"brokers, topics, partitions or partition leader changes. \"\n          \"Use -1 to disable the intervalled refresh (not recommended). \"\n          \"If there are no locally referenced topics \"\n          \"(no topic objects created, no messages produced, \"\n          \"no subscription or no assignment) then only the broker list will \"\n          \"be refreshed every interval but no more often than every 10s.\",\n          -1, 3600*1000, 5*60*1000 },\n\t{ _RK_GLOBAL, \"metadata.max.age.ms\", _RK_C_INT,\n          _RK(metadata_max_age_ms),\n          \"Metadata cache max age. \"\n          \"Defaults to topic.metadata.refresh.interval.ms * 3\",\n          1, 24*3600*1000, 5*60*1000 * 3 },\n        { _RK_GLOBAL, \"topic.metadata.refresh.fast.interval.ms\", _RK_C_INT,\n          _RK(metadata_refresh_fast_interval_ms),\n          \"When a topic loses its leader a new metadata request will be \"\n          \"enqueued with this initial interval, exponentially increasing \"\n          \"until the topic metadata has been refreshed. \"\n          \"This is used to recover quickly from transitioning leader brokers.\",\n          1, 60*1000, 250 },\n        { _RK_GLOBAL|_RK_DEPRECATED,\n          \"topic.metadata.refresh.fast.cnt\", _RK_C_INT,\n          _RK(metadata_refresh_fast_cnt),\n          \"No longer used.\",\n          0, 1000, 10 },\n        { _RK_GLOBAL, \"topic.metadata.refresh.sparse\", _RK_C_BOOL,\n          _RK(metadata_refresh_sparse),\n          \"Sparse metadata requests (consumes less network bandwidth)\",\n          0, 1, 1 },\n        { _RK_GLOBAL, \"topic.blacklist\", _RK_C_PATLIST,\n          _RK(topic_blacklist),\n          \"Topic blacklist, a comma-separated list of regular expressions \"\n          \"for matching topic names that should be ignored in \"\n          \"broker metadata information as if the topics did not exist.\" },\n\t{ _RK_GLOBAL|_RK_MED, \"debug\", _RK_C_S2F, _RK(debug),\n\t  \"A comma-separated list of debug contexts to enable. \"\n          \"Detailed Producer debugging: broker,topic,msg. \"\n          \"Consumer: consumer,cgrp,topic,fetch\",\n\t  .s2i = {\n                        { RD_KAFKA_DBG_GENERIC,  \"generic\" },\n\t\t\t{ RD_KAFKA_DBG_BROKER,   \"broker\" },\n\t\t\t{ RD_KAFKA_DBG_TOPIC,    \"topic\" },\n\t\t\t{ RD_KAFKA_DBG_METADATA, \"metadata\" },\n                        { RD_KAFKA_DBG_FEATURE,  \"feature\" },\n\t\t\t{ RD_KAFKA_DBG_QUEUE,    \"queue\" },\n\t\t\t{ RD_KAFKA_DBG_MSG,      \"msg\" },\n\t\t\t{ RD_KAFKA_DBG_PROTOCOL, \"protocol\" },\n                        { RD_KAFKA_DBG_CGRP,     \"cgrp\" },\n\t\t\t{ RD_KAFKA_DBG_SECURITY, \"security\" },\n\t\t\t{ RD_KAFKA_DBG_FETCH,    \"fetch\" },\n                        { RD_KAFKA_DBG_INTERCEPTOR, \"interceptor\" },\n                        { RD_KAFKA_DBG_PLUGIN,   \"plugin\" },\n                        { RD_KAFKA_DBG_CONSUMER, \"consumer\" },\n                        { RD_KAFKA_DBG_ADMIN,    \"admin\" },\n                        { RD_KAFKA_DBG_EOS,      \"eos\" },\n                        { RD_KAFKA_DBG_MOCK,     \"mock\" },\n\t\t\t{ RD_KAFKA_DBG_ALL,      \"all\" }\n\t\t} },\n\t{ _RK_GLOBAL, \"socket.timeout.ms\", _RK_C_INT, _RK(socket_timeout_ms),\n\t  \"Default timeout for network requests. \"\n          \"Producer: ProduceRequests will use the lesser value of \"\n          \"`socket.timeout.ms` and remaining `message.timeout.ms` for the \"\n          \"first message in the batch. \"\n          \"Consumer: FetchRequests will use \"\n          \"`fetch.wait.max.ms` + `socket.timeout.ms`. \"\n          \"Admin: Admin requests will use `socket.timeout.ms` or explicitly \"\n          \"set `rd_kafka_AdminOptions_set_operation_timeout()` value.\",\n\t  10, 300*1000, 60*1000 },\n        { _RK_GLOBAL|_RK_DEPRECATED, \"socket.blocking.max.ms\", _RK_C_INT,\n          _RK(socket_blocking_max_ms),\n          \"No longer used.\",\n          1, 60*1000, 1000 },\n\t{ _RK_GLOBAL, \"socket.send.buffer.bytes\", _RK_C_INT,\n\t  _RK(socket_sndbuf_size),\n\t  \"Broker socket send buffer size. System default is used if 0.\",\n\t  0, 100000000, 0 },\n\t{ _RK_GLOBAL, \"socket.receive.buffer.bytes\", _RK_C_INT,\n\t  _RK(socket_rcvbuf_size),\n\t  \"Broker socket receive buffer size. System default is used if 0.\",\n\t  0, 100000000, 0 },\n#ifdef SO_KEEPALIVE\n\t{ _RK_GLOBAL, \"socket.keepalive.enable\", _RK_C_BOOL,\n\t  _RK(socket_keepalive),\n          \"Enable TCP keep-alives (SO_KEEPALIVE) on broker sockets\",\n          0, 1, 0 },\n#endif\n#ifdef TCP_NODELAY\n\t{ _RK_GLOBAL, \"socket.nagle.disable\", _RK_C_BOOL,\n\t  _RK(socket_nagle_disable),\n          \"Disable the Nagle algorithm (TCP_NODELAY) on broker sockets.\",\n          0, 1, 0 },\n#endif\n        { _RK_GLOBAL, \"socket.max.fails\", _RK_C_INT,\n          _RK(socket_max_fails),\n          \"Disconnect from broker when this number of send failures \"\n          \"(e.g., timed out requests) is reached. Disable with 0. \"\n          \"WARNING: It is highly recommended to leave this setting at \"\n          \"its default value of 1 to avoid the client and broker to \"\n          \"become desynchronized in case of request timeouts. \"\n          \"NOTE: The connection is automatically re-established.\",\n          0, 1000000, 1 },\n\t{ _RK_GLOBAL, \"broker.address.ttl\", _RK_C_INT,\n\t  _RK(broker_addr_ttl),\n\t  \"How long to cache the broker address resolving \"\n          \"results (milliseconds).\",\n\t  0, 86400*1000, 1*1000 },\n        { _RK_GLOBAL, \"broker.address.family\", _RK_C_S2I,\n          _RK(broker_addr_family),\n          \"Allowed broker IP address families: any, v4, v6\",\n          .vdef = AF_UNSPEC,\n          .s2i = {\n                        { AF_UNSPEC, \"any\" },\n                        { AF_INET, \"v4\" },\n                        { AF_INET6, \"v6\" },\n                } },\n        { _RK_GLOBAL|_RK_MED|_RK_HIDDEN, \"enable.sparse.connections\",\n          _RK_C_BOOL,\n          _RK(sparse_connections),\n          \"When enabled the client will only connect to brokers \"\n          \"it needs to communicate with. When disabled the client \"\n          \"will maintain connections to all brokers in the cluster.\",\n          0, 1, 1 },\n        { _RK_GLOBAL|_RK_DEPRECATED, \"reconnect.backoff.jitter.ms\", _RK_C_INT,\n          _RK(reconnect_jitter_ms),\n          \"No longer used. See `reconnect.backoff.ms` and \"\n          \"`reconnect.backoff.max.ms`.\",\n          0, 60*60*1000, 0 },\n        { _RK_GLOBAL|_RK_MED, \"reconnect.backoff.ms\", _RK_C_INT,\n          _RK(reconnect_backoff_ms),\n          \"The initial time to wait before reconnecting to a broker \"\n          \"after the connection has been closed. \"\n          \"The time is increased exponentially until \"\n          \"`reconnect.backoff.max.ms` is reached. \"\n          \"-25% to +50% jitter is applied to each reconnect backoff. \"\n          \"A value of 0 disables the backoff and reconnects immediately.\",\n          0, 60*60*1000, 100 },\n        { _RK_GLOBAL|_RK_MED, \"reconnect.backoff.max.ms\", _RK_C_INT,\n          _RK(reconnect_backoff_max_ms),\n          \"The maximum time to wait before reconnecting to a broker \"\n          \"after the connection has been closed.\",\n          0, 60*60*1000, 10*1000 },\n\t{ _RK_GLOBAL|_RK_HIGH, \"statistics.interval.ms\", _RK_C_INT,\n\t  _RK(stats_interval_ms),\n\t  \"librdkafka statistics emit interval. The application also needs to \"\n\t  \"register a stats callback using `rd_kafka_conf_set_stats_cb()`. \"\n\t  \"The granularity is 1000ms. A value of 0 disables statistics.\",\n\t  0, 86400*1000, 0 },\n\t{ _RK_GLOBAL, \"enabled_events\", _RK_C_INT,\n\t  _RK(enabled_events),\n\t  \"See `rd_kafka_conf_set_events()`\",\n\t  0, 0x7fffffff, 0 },\n\t{ _RK_GLOBAL, \"error_cb\", _RK_C_PTR,\n\t  _RK(error_cb),\n\t  \"Error callback (set with rd_kafka_conf_set_error_cb())\" },\n\t{ _RK_GLOBAL, \"throttle_cb\", _RK_C_PTR,\n\t  _RK(throttle_cb),\n\t  \"Throttle callback (set with rd_kafka_conf_set_throttle_cb())\" },\n\t{ _RK_GLOBAL, \"stats_cb\", _RK_C_PTR,\n\t  _RK(stats_cb),\n\t  \"Statistics callback (set with rd_kafka_conf_set_stats_cb())\" },\n\t{ _RK_GLOBAL, \"log_cb\", _RK_C_PTR,\n\t  _RK(log_cb),\n\t  \"Log callback (set with rd_kafka_conf_set_log_cb())\",\n          .pdef = rd_kafka_log_print },\n        { _RK_GLOBAL, \"log_level\", _RK_C_INT,\n          _RK(log_level),\n          \"Logging level (syslog(3) levels)\",\n          0, 7, 6 },\n        { _RK_GLOBAL, \"log.queue\", _RK_C_BOOL, _RK(log_queue),\n          \"Disable spontaneous log_cb from internal librdkafka \"\n          \"threads, instead enqueue log messages on queue set with \"\n          \"`rd_kafka_set_log_queue()` and serve log callbacks or \"\n          \"events through the standard poll APIs. \"\n          \"**NOTE**: Log messages will linger in a temporary queue \"\n          \"until the log queue has been set.\",\n          0, 1, 0 },\n\t{ _RK_GLOBAL, \"log.thread.name\", _RK_C_BOOL,\n\t  _RK(log_thread_name),\n\t  \"Print internal thread name in log messages \"\n\t  \"(useful for debugging librdkafka internals)\",\n\t  0, 1, 1 },\n        { _RK_GLOBAL, \"enable.random.seed\", _RK_C_BOOL,\n          _RK(enable_random_seed),\n          \"If enabled librdkafka will initialize the POSIX PRNG \"\n          \"with srand(current_time.milliseconds) on the first invocation of \"\n          \"rd_kafka_new(). If disabled the application must call srand() \"\n          \"prior to calling rd_kafka_new().\",\n          0, 1, 1 },\n\t{ _RK_GLOBAL, \"log.connection.close\", _RK_C_BOOL,\n\t  _RK(log_connection_close),\n\t  \"Log broker disconnects. \"\n          \"It might be useful to turn this off when interacting with \"\n          \"0.9 brokers with an aggressive `connection.max.idle.ms` value.\",\n\t  0, 1, 1 },\n        { _RK_GLOBAL, \"background_event_cb\", _RK_C_PTR,\n          _RK(background_event_cb),\n          \"Background queue event callback \"\n          \"(set with rd_kafka_conf_set_background_event_cb())\" },\n        { _RK_GLOBAL, \"socket_cb\", _RK_C_PTR,\n          _RK(socket_cb),\n          \"Socket creation callback to provide race-free CLOEXEC\",\n          .pdef =\n#ifdef __linux__\n          rd_kafka_socket_cb_linux\n#else\n          rd_kafka_socket_cb_generic\n#endif\n        },\n        { _RK_GLOBAL, \"connect_cb\", _RK_C_PTR,\n          _RK(connect_cb),\n          \"Socket connect callback\",\n        },\n        { _RK_GLOBAL, \"closesocket_cb\", _RK_C_PTR,\n          _RK(closesocket_cb),\n          \"Socket close callback\",\n        },\n        { _RK_GLOBAL, \"open_cb\", _RK_C_PTR,\n          _RK(open_cb),\n          \"File open callback to provide race-free CLOEXEC\",\n          .pdef =\n#ifdef __linux__\n          rd_kafka_open_cb_linux\n#else\n          rd_kafka_open_cb_generic\n#endif\n        },\n\t{ _RK_GLOBAL, \"opaque\", _RK_C_PTR,\n\t  _RK(opaque),\n\t  \"Application opaque (set with rd_kafka_conf_set_opaque())\" },\n        { _RK_GLOBAL, \"default_topic_conf\", _RK_C_PTR,\n          _RK(topic_conf),\n          \"Default topic configuration for automatically subscribed topics\" },\n\t{ _RK_GLOBAL, \"internal.termination.signal\", _RK_C_INT,\n\t  _RK(term_sig),\n\t  \"Signal that librdkafka will use to quickly terminate on \"\n\t  \"rd_kafka_destroy(). If this signal is not set then there will be a \"\n\t  \"delay before rd_kafka_wait_destroyed() returns true \"\n\t  \"as internal threads are timing out their system calls. \"\n\t  \"If this signal is set however the delay will be minimal. \"\n\t  \"The application should mask this signal as an internal \"\n\t  \"signal handler is installed.\",\n\t  0, 128, 0 },\n\t{ _RK_GLOBAL|_RK_HIGH, \"api.version.request\", _RK_C_BOOL,\n\t  _RK(api_version_request),\n\t  \"Request broker's supported API versions to adjust functionality to \"\n\t  \"available protocol features. If set to false, or the \"\n          \"ApiVersionRequest fails, the fallback version \"\n\t  \"`broker.version.fallback` will be used. \"\n\t  \"**NOTE**: Depends on broker version >=0.10.0. If the request is not \"\n\t  \"supported by (an older) broker the `broker.version.fallback` fallback is used.\",\n\t  0, 1, 1 },\n\t{ _RK_GLOBAL, \"api.version.request.timeout.ms\", _RK_C_INT,\n\t  _RK(api_version_request_timeout_ms),\n\t  \"Timeout for broker API version requests.\",\n\t  1, 5*60*1000, 10*1000 },\n\t{ _RK_GLOBAL|_RK_MED, \"api.version.fallback.ms\", _RK_C_INT,\n\t  _RK(api_version_fallback_ms),\n\t  \"Dictates how long the `broker.version.fallback` fallback is used \"\n\t  \"in the case the ApiVersionRequest fails. \"\n\t  \"**NOTE**: The ApiVersionRequest is only issued when a new connection \"\n\t  \"to the broker is made (such as after an upgrade).\",\n\t  0, 86400*7*1000, 0 },\n\n\t{ _RK_GLOBAL|_RK_MED, \"broker.version.fallback\", _RK_C_STR,\n\t  _RK(broker_version_fallback),\n\t  \"Older broker versions (before 0.10.0) provide no way for a client to query \"\n\t  \"for supported protocol features \"\n\t  \"(ApiVersionRequest, see `api.version.request`) making it impossible \"\n\t  \"for the client to know what features it may use. \"\n\t  \"As a workaround a user may set this property to the expected broker \"\n\t  \"version and the client will automatically adjust its feature set \"\n\t  \"accordingly if the ApiVersionRequest fails (or is disabled). \"\n\t  \"The fallback broker version will be used for `api.version.fallback.ms`. \"\n          \"Valid values are: 0.9.0, 0.8.2, 0.8.1, 0.8.0. \"\n          \"Any other value >= 0.10, such as 0.10.2.1, \"\n          \"enables ApiVersionRequests.\",\n          .sdef = \"0.10.0\",\n\t  .validate = rd_kafka_conf_validate_broker_version },\n\n\t/* Security related global properties */\n\t{ _RK_GLOBAL|_RK_HIGH, \"security.protocol\", _RK_C_S2I,\n\t  _RK(security_protocol),\n\t  \"Protocol used to communicate with brokers.\",\n\t  .vdef = RD_KAFKA_PROTO_PLAINTEXT,\n\t  .s2i = {\n\t\t\t{ RD_KAFKA_PROTO_PLAINTEXT, \"plaintext\" },\n#if WITH_SSL\n\t\t\t{ RD_KAFKA_PROTO_SSL, \"ssl\" },\n#endif\n\t\t\t{ RD_KAFKA_PROTO_SASL_PLAINTEXT, \"sasl_plaintext\" },\n#if WITH_SSL\n\t\t\t{ RD_KAFKA_PROTO_SASL_SSL, \"sasl_ssl\" },\n#endif\n\t\t\t{ 0, NULL }\n\t\t} },\n\n#if WITH_SSL\n\t{ _RK_GLOBAL, \"ssl.cipher.suites\", _RK_C_STR,\n\t  _RK(ssl.cipher_suites),\n\t  \"A cipher suite is a named combination of authentication, \"\n\t  \"encryption, MAC and key exchange algorithm used to negotiate the \"\n\t  \"security settings for a network connection using TLS or SSL network \"\n\t  \"protocol. See manual page for `ciphers(1)` and \"\n\t  \"`SSL_CTX_set_cipher_list(3).\"\n\t},\n#if OPENSSL_VERSION_NUMBER >= 0x1000200fL && !defined(LIBRESSL_VERSION_NUMBER)\n        { _RK_GLOBAL, \"ssl.curves.list\", _RK_C_STR,\n          _RK(ssl.curves_list),\n          \"The supported-curves extension in the TLS ClientHello message specifies \"\n          \"the curves (standard/named, or 'explicit' GF(2^k) or GF(p)) the client \"\n          \"is willing to have the server use. See manual page for \"\n          \"`SSL_CTX_set1_curves_list(3)`. OpenSSL >= 1.0.2 required.\"\n        },\n        { _RK_GLOBAL, \"ssl.sigalgs.list\", _RK_C_STR,\n          _RK(ssl.sigalgs_list),\n          \"The client uses the TLS ClientHello signature_algorithms extension \"\n          \"to indicate to the server which signature/hash algorithm pairs \"\n          \"may be used in digital signatures. See manual page for \"\n          \"`SSL_CTX_set1_sigalgs_list(3)`. OpenSSL >= 1.0.2 required.\"\n        },\n#endif\n        { _RK_GLOBAL, \"ssl.key.location\", _RK_C_STR,\n          _RK(ssl.key_location),\n          \"Path to client's private key (PEM) used for authentication.\"\n        },\n        { _RK_GLOBAL|_RK_SENSITIVE, \"ssl.key.password\", _RK_C_STR,\n          _RK(ssl.key_password),\n          \"Private key passphrase (for use with `ssl.key.location` \"\n          \"and `set_ssl_cert()`)\"\n        },\n        { _RK_GLOBAL|_RK_SENSITIVE, \"ssl.key.pem\", _RK_C_STR,\n          _RK(ssl.key_pem),\n          \"Client's private key string (PEM format) used for authentication.\"\n        },\n        { _RK_GLOBAL, \"ssl_key\", _RK_C_INTERNAL,\n          _RK(ssl.key),\n          \"Client's private key as set by rd_kafka_conf_set_ssl_cert()\",\n          .dtor = rd_kafka_conf_cert_dtor,\n          .copy = rd_kafka_conf_cert_copy\n        },\n        { _RK_GLOBAL, \"ssl.certificate.location\", _RK_C_STR,\n          _RK(ssl.cert_location),\n          \"Path to client's public key (PEM) used for authentication.\"\n        },\n        { _RK_GLOBAL, \"ssl.certificate.pem\", _RK_C_STR,\n          _RK(ssl.cert_pem),\n          \"Client's public key string (PEM format) used for authentication.\"\n        },\n        { _RK_GLOBAL, \"ssl_certificate\", _RK_C_INTERNAL,\n          _RK(ssl.key),\n          \"Client's public key as set by rd_kafka_conf_set_ssl_cert()\",\n          .dtor = rd_kafka_conf_cert_dtor,\n          .copy = rd_kafka_conf_cert_copy\n        },\n\n        { _RK_GLOBAL, \"ssl.ca.location\", _RK_C_STR,\n          _RK(ssl.ca_location),\n          \"File or directory path to CA certificate(s) for verifying \"\n          \"the broker's key. \"\n          \"Defaults: \"\n          \"On Windows the system's CA certificates are automatically looked \"\n          \"up in the Windows Root certificate store. \"\n          \"On Mac OSX it is recommended to install openssl using Homebrew, \"\n          \"to provide CA certificates. \"\n          \"On Linux install the distribution's ca-certificates package. \"\n          \"If OpenSSL is statically linked or `ssl.ca.location` is set to \"\n          \"`probe` a list of standard paths will be probed and the first one \"\n          \"found will be used as the default CA certificate location path. \"\n          \"If OpenSSL is dynamically linked the OpenSSL library's default \"\n          \"path will be used (see `OPENSSLDIR` in `openssl version -a`).\"\n        },\n        { _RK_GLOBAL, \"ssl_ca\", _RK_C_INTERNAL,\n          _RK(ssl.ca),\n          \"CA certificate as set by rd_kafka_conf_set_ssl_cert()\",\n          .dtor = rd_kafka_conf_cert_dtor,\n          .copy = rd_kafka_conf_cert_copy\n        },\n        { _RK_GLOBAL, \"ssl.crl.location\", _RK_C_STR,\n          _RK(ssl.crl_location),\n          \"Path to CRL for verifying broker's certificate validity.\"\n        },\n        { _RK_GLOBAL, \"ssl.keystore.location\", _RK_C_STR,\n          _RK(ssl.keystore_location),\n          \"Path to client's keystore (PKCS#12) used for authentication.\"\n        },\n        { _RK_GLOBAL|_RK_SENSITIVE, \"ssl.keystore.password\", _RK_C_STR,\n          _RK(ssl.keystore_password),\n          \"Client's keystore (PKCS#12) password.\"\n        },\n        { _RK_GLOBAL, \"enable.ssl.certificate.verification\", _RK_C_BOOL,\n          _RK(ssl.enable_verify),\n          \"Enable OpenSSL's builtin broker (server) certificate verification. \"\n          \"This verification can be extended by the application by \"\n          \"implementing a certificate_verify_cb.\",\n          0, 1, 1\n        },\n#if OPENSSL_VERSION_NUMBER >= 0x1000200fL\n        { _RK_GLOBAL, \"ssl.endpoint.identification.algorithm\", _RK_C_S2I,\n          _RK(ssl.endpoint_identification),\n          \"Endpoint identification algorithm to validate broker \"\n          \"hostname using broker certificate. \"\n          \"https - Server (broker) hostname verification as \"\n          \"specified in RFC2818. \"\n          \"none - No endpoint verification. \"\n          \"OpenSSL >= 1.0.2 required.\",\n          .vdef = RD_KAFKA_SSL_ENDPOINT_ID_NONE,\n          .s2i = {\n                        { RD_KAFKA_SSL_ENDPOINT_ID_NONE, \"none\" },\n                        { RD_KAFKA_SSL_ENDPOINT_ID_HTTPS, \"https\" }\n                }\n        },\n#endif\n        { _RK_GLOBAL, \"ssl.certificate.verify_cb\", _RK_C_PTR,\n          _RK(ssl.cert_verify_cb),\n          \"Callback to verify the broker certificate chain.\"\n        },\n#endif /* WITH_SSL */\n\n        /* Point user in the right direction if they try to apply\n         * Java client SSL / JAAS properties. */\n        { _RK_GLOBAL, \"ssl.truststore.location\", _RK_C_INVALID,\n          _RK(dummy),\n          \"Java TrustStores are not supported, use `ssl.ca.location` \"\n          \"and a certificate file instead. \"\n          \"See https://github.com/edenhill/librdkafka/wiki/Using-SSL-with-librdkafka for more information.\"\n        },\n        { _RK_GLOBAL, \"sasl.jaas.config\", _RK_C_INVALID,\n          _RK(dummy),\n          \"Java JAAS configuration is not supported, see \"\n          \"https://github.com/edenhill/librdkafka/wiki/Using-SASL-with-librdkafka \"\n          \"for more information.\"\n        },\n\n\t{_RK_GLOBAL|_RK_HIGH, \"sasl.mechanisms\", _RK_C_STR,\n\t _RK(sasl.mechanisms),\n\t \"SASL mechanism to use for authentication. \"\n\t \"Supported: GSSAPI, PLAIN, SCRAM-SHA-256, SCRAM-SHA-512, OAUTHBEARER. \"\n\t \"**NOTE**: Despite the name only one mechanism must be configured.\",\n\t .sdef = \"GSSAPI\",\n\t .validate = rd_kafka_conf_validate_single },\n        {_RK_GLOBAL|_RK_HIGH, \"sasl.mechanism\", _RK_C_ALIAS,\n         .sdef = \"sasl.mechanisms\" },\n\t{ _RK_GLOBAL, \"sasl.kerberos.service.name\", _RK_C_STR,\n\t  _RK(sasl.service_name),\n\t  \"Kerberos principal name that Kafka runs as, \"\n          \"not including /hostname@REALM\",\n\t  .sdef = \"kafka\" },\n\t{ _RK_GLOBAL, \"sasl.kerberos.principal\", _RK_C_STR,\n\t  _RK(sasl.principal),\n          \"This client's Kerberos principal name. \"\n          \"(Not supported on Windows, will use the logon user's principal).\",\n\t  .sdef = \"kafkaclient\" },\n#ifndef _MSC_VER\n        { _RK_GLOBAL, \"sasl.kerberos.kinit.cmd\", _RK_C_STR,\n          _RK(sasl.kinit_cmd),\n          \"Shell command to refresh or acquire the client's Kerberos ticket. \"\n          \"This command is executed on client creation and every \"\n          \"sasl.kerberos.min.time.before.relogin (0=disable). \"\n          \"%{config.prop.name} is replaced by corresponding config \"\n          \"object value.\",\n          .sdef =\n          /* First attempt to refresh, else acquire. */\n          \"kinit -R -t \\\"%{sasl.kerberos.keytab}\\\" \"\n          \"-k %{sasl.kerberos.principal} || \"\n          \"kinit -t \\\"%{sasl.kerberos.keytab}\\\" -k %{sasl.kerberos.principal}\"\n        },\n        { _RK_GLOBAL, \"sasl.kerberos.keytab\", _RK_C_STR,\n          _RK(sasl.keytab),\n          \"Path to Kerberos keytab file. \"\n          \"This configuration property is only used as a variable in \"\n          \"`sasl.kerberos.kinit.cmd` as \"\n          \"` ... -t \\\"%{sasl.kerberos.keytab}\\\"`.\" },\n        { _RK_GLOBAL, \"sasl.kerberos.min.time.before.relogin\", _RK_C_INT,\n          _RK(sasl.relogin_min_time),\n          \"Minimum time in milliseconds between key refresh attempts. \"\n          \"Disable automatic key refresh by setting this property to 0.\",\n          0, 86400*1000, 60*1000 },\n#endif\n\t{ _RK_GLOBAL|_RK_HIGH, \"sasl.username\", _RK_C_STR,\n\t  _RK(sasl.username),\n\t  \"SASL username for use with the PLAIN and SASL-SCRAM-.. mechanisms\" },\n\t{ _RK_GLOBAL|_RK_HIGH, \"sasl.password\", _RK_C_STR,\n\t  _RK(sasl.password),\n\t  \"SASL password for use with the PLAIN and SASL-SCRAM-.. mechanism\" },\n#if WITH_SASL_OAUTHBEARER\n        { _RK_GLOBAL, \"sasl.oauthbearer.config\", _RK_C_STR,\n          _RK(sasl.oauthbearer_config),\n          \"SASL/OAUTHBEARER configuration. The format is \"\n          \"implementation-dependent and must be parsed accordingly. The \"\n          \"default unsecured token implementation (see \"\n          \"https://tools.ietf.org/html/rfc7515#appendix-A.5) recognizes \"\n          \"space-separated name=value pairs with valid names including \"\n          \"principalClaimName, principal, scopeClaimName, scope, and \"\n          \"lifeSeconds. The default value for principalClaimName is \\\"sub\\\", \"\n          \"the default value for scopeClaimName is \\\"scope\\\", and the default \"\n          \"value for lifeSeconds is 3600. The scope value is CSV format with \"\n          \"the default value being no/empty scope. For example: \"\n          \"`principalClaimName=azp principal=admin scopeClaimName=roles \"\n          \"scope=role1,role2 lifeSeconds=600`. In addition, SASL extensions \"\n          \"can be communicated to the broker via \"\n          \"`extension_NAME=value`. For example: \"\n          \"`principal=admin extension_traceId=123`\" },\n        { _RK_GLOBAL, \"enable.sasl.oauthbearer.unsecure.jwt\", _RK_C_BOOL,\n          _RK(sasl.enable_oauthbearer_unsecure_jwt),\n          \"Enable the builtin unsecure JWT OAUTHBEARER token handler \"\n          \"if no oauthbearer_refresh_cb has been set. \"\n          \"This builtin handler should only be used for development \"\n          \"or testing, and not in production.\",\n          0, 1, 0 },\n        { _RK_GLOBAL, \"oauthbearer_token_refresh_cb\", _RK_C_PTR,\n          _RK(sasl.oauthbearer_token_refresh_cb),\n          \"SASL/OAUTHBEARER token refresh callback (set with \"\n          \"rd_kafka_conf_set_oauthbearer_token_refresh_cb(), triggered by \"\n          \"rd_kafka_poll(), et.al. \"\n          \"This callback will be triggered when it is time to refresh \"\n          \"the client's OAUTHBEARER token.\" },\n#endif\n\n#if WITH_PLUGINS\n        /* Plugins */\n        { _RK_GLOBAL, \"plugin.library.paths\", _RK_C_STR,\n          _RK(plugin_paths),\n          \"List of plugin libraries to load (; separated). \"\n          \"The library search path is platform dependent (see dlopen(3) for Unix and LoadLibrary() for Windows). If no filename extension is specified the \"\n          \"platform-specific extension (such as .dll or .so) will be appended automatically.\",\n          .set = rd_kafka_plugins_conf_set },\n#endif\n\n        /* Interceptors are added through specific API and not exposed\n         * as configuration properties.\n         * The interceptor property must be defined after plugin.library.paths\n         * so that the plugin libraries are properly loaded before\n         * interceptors are configured when duplicating configuration objects.*/\n        { _RK_GLOBAL, \"interceptors\", _RK_C_INTERNAL,\n          _RK(interceptors),\n          \"Interceptors added through rd_kafka_conf_interceptor_add_..() \"\n          \"and any configuration handled by interceptors.\",\n          .ctor = rd_kafka_conf_interceptor_ctor,\n          .dtor = rd_kafka_conf_interceptor_dtor,\n          .copy = rd_kafka_conf_interceptor_copy },\n\n        /* Test mocks. */\n        { _RK_GLOBAL|_RK_HIDDEN, \"test.mock.num.brokers\", _RK_C_INT,\n          _RK(mock.broker_cnt),\n          \"Number of mock brokers to create. \"\n          \"This will automatically overwrite `bootstrap.servers` with the \"\n          \"mock broker list.\",\n          0, 10000, 0 },\n\n        /* Unit test interfaces.\n         * These are not part of the public API and may change at any time.\n         * Only to be used by the librdkafka tests. */\n        { _RK_GLOBAL|_RK_HIDDEN, \"ut_handle_ProduceResponse\", _RK_C_PTR,\n          _RK(ut.handle_ProduceResponse),\n          \"ProduceResponse handler: \"\n          \"rd_kafka_resp_err_t (*cb) (rd_kafka_t *rk, \"\n          \"int32_t brokerid, uint64_t msgid, rd_kafka_resp_err_t err)\" },\n\n        /* Global consumer group properties */\n        { _RK_GLOBAL|_RK_CGRP|_RK_HIGH, \"group.id\", _RK_C_STR,\n          _RK(group_id_str),\n          \"Client group id string. All clients sharing the same group.id \"\n          \"belong to the same group.\" },\n        { _RK_GLOBAL|_RK_CGRP|_RK_MED,\n          \"group.instance.id\", _RK_C_STR,\n          _RK(group_instance_id),\n          \"Enable static group membership. \"\n          \"Static group members are able to leave and rejoin a group \"\n          \"within the configured `session.timeout.ms` without prompting a \"\n          \"group rebalance. This should be used in combination with a larger \"\n          \"`session.timeout.ms` to avoid group rebalances caused by transient \"\n          \"unavailability (e.g. process restarts). \"\n          \"Requires broker version >= 2.3.0.\"},\n        { _RK_GLOBAL|_RK_CGRP|_RK_MED, \"partition.assignment.strategy\",\n          _RK_C_STR,\n          _RK(partition_assignment_strategy),\n          \"Name of partition assignment strategy to use when elected \"\n          \"group leader assigns partitions to group members.\",\n\t  .sdef = \"range,roundrobin\" },\n        { _RK_GLOBAL|_RK_CGRP|_RK_HIGH, \"session.timeout.ms\", _RK_C_INT,\n          _RK(group_session_timeout_ms),\n          \"Client group session and failure detection timeout. \"\n          \"The consumer sends periodic heartbeats (heartbeat.interval.ms) \"\n          \"to indicate its liveness to the broker. If no hearts are \"\n          \"received by the broker for a group member within the \"\n          \"session timeout, the broker will remove the consumer from \"\n          \"the group and trigger a rebalance. \"\n          \"The allowed range is configured with the **broker** configuration \"\n          \"properties `group.min.session.timeout.ms` and \"\n          \"`group.max.session.timeout.ms`. \"\n          \"Also see `max.poll.interval.ms`.\",\n          1, 3600*1000, 10*1000 },\n        { _RK_GLOBAL|_RK_CGRP, \"heartbeat.interval.ms\", _RK_C_INT,\n          _RK(group_heartbeat_intvl_ms),\n          \"Group session keepalive heartbeat interval.\",\n          1, 3600*1000, 3*1000 },\n        { _RK_GLOBAL|_RK_CGRP, \"group.protocol.type\", _RK_C_KSTR,\n          _RK(group_protocol_type),\n          \"Group protocol type\",\n          .sdef = \"consumer\" },\n        { _RK_GLOBAL|_RK_CGRP, \"coordinator.query.interval.ms\", _RK_C_INT,\n          _RK(coord_query_intvl_ms),\n          \"How often to query for the current client group coordinator. \"\n          \"If the currently assigned coordinator is down the configured \"\n          \"query interval will be divided by ten to more quickly recover \"\n          \"in case of coordinator reassignment.\",\n          1, 3600*1000, 10*60*1000 },\n        { _RK_GLOBAL|_RK_CONSUMER|_RK_HIGH, \"max.poll.interval.ms\", _RK_C_INT,\n          _RK(max_poll_interval_ms),\n          \"Maximum allowed time between calls to consume messages \"\n          \"(e.g., rd_kafka_consumer_poll()) for high-level consumers. \"\n          \"If this interval is exceeded the consumer is considered failed \"\n          \"and the group will rebalance in order to reassign the \"\n          \"partitions to another consumer group member. \"\n          \"Warning: Offset commits may be not possible at this point. \"\n          \"Note: It is recommended to set `enable.auto.offset.store=false` \"\n          \"for long-time processing applications and then explicitly store \"\n          \"offsets (using offsets_store()) *after* message processing, to \"\n          \"make sure offsets are not auto-committed prior to processing \"\n          \"has finished. \"\n          \"The interval is checked two times per second. \"\n          \"See KIP-62 for more information.\",\n          1, 86400*1000, 300000\n        },\n\n        /* Global consumer properties */\n        { _RK_GLOBAL|_RK_CONSUMER|_RK_HIGH, \"enable.auto.commit\", _RK_C_BOOL,\n          _RK(enable_auto_commit),\n          \"Automatically and periodically commit offsets in the background. \"\n          \"Note: setting this to false does not prevent the consumer from \"\n          \"fetching previously committed start offsets. To circumvent this \"\n          \"behaviour set specific start offsets per partition in the call \"\n          \"to assign().\",\n          0, 1, 1 },\n        { _RK_GLOBAL|_RK_CONSUMER|_RK_MED, \"auto.commit.interval.ms\",\n          _RK_C_INT,\n\t  _RK(auto_commit_interval_ms),\n\t  \"The frequency in milliseconds that the consumer offsets \"\n\t  \"are committed (written) to offset storage. (0 = disable). \"\n          \"This setting is used by the high-level consumer.\",\n          0, 86400*1000, 5*1000 },\n        { _RK_GLOBAL|_RK_CONSUMER|_RK_HIGH, \"enable.auto.offset.store\",\n          _RK_C_BOOL,\n          _RK(enable_auto_offset_store),\n          \"Automatically store offset of last message provided to \"\n          \"application. \"\n          \"The offset store is an in-memory store of the next offset to \"\n          \"(auto-)commit for each partition.\",\n          0, 1, 1 },\n        { _RK_GLOBAL|_RK_CONSUMER|_RK_MED, \"queued.min.messages\", _RK_C_INT,\n\t  _RK(queued_min_msgs),\n\t  \"Minimum number of messages per topic+partition \"\n          \"librdkafka tries to maintain in the local consumer queue.\",\n\t  1, 10000000, 100000 },\n\t{ _RK_GLOBAL|_RK_CONSUMER|_RK_MED, \"queued.max.messages.kbytes\",\n          _RK_C_INT,\n\t  _RK(queued_max_msg_kbytes),\n          \"Maximum number of kilobytes per topic+partition in the \"\n          \"local consumer queue. \"\n\t  \"This value may be overshot by fetch.message.max.bytes. \"\n\t  \"This property has higher priority than queued.min.messages.\",\n          1, INT_MAX/1024, 0x100000/*1GB*/ },\n        { _RK_GLOBAL|_RK_CONSUMER, \"fetch.wait.max.ms\", _RK_C_INT,\n\t  _RK(fetch_wait_max_ms),\n\t  \"Maximum time the broker may wait to fill the response \"\n\t  \"with fetch.min.bytes.\",\n\t  0, 300*1000, 100 },\n        { _RK_GLOBAL|_RK_CONSUMER|_RK_MED, \"fetch.message.max.bytes\",\n          _RK_C_INT,\n          _RK(fetch_msg_max_bytes),\n          \"Initial maximum number of bytes per topic+partition to request when \"\n          \"fetching messages from the broker. \"\n\t  \"If the client encounters a message larger than this value \"\n\t  \"it will gradually try to increase it until the \"\n\t  \"entire message can be fetched.\",\n          1, 1000000000, 1024*1024 },\n        { _RK_GLOBAL|_RK_CONSUMER|_RK_MED, \"max.partition.fetch.bytes\",\n          _RK_C_ALIAS,\n\t  .sdef = \"fetch.message.max.bytes\" },\n        { _RK_GLOBAL|_RK_CONSUMER|_RK_MED, \"fetch.max.bytes\", _RK_C_INT,\n          _RK(fetch_max_bytes),\n          \"Maximum amount of data the broker shall return for a Fetch request. \"\n          \"Messages are fetched in batches by the consumer and if the first \"\n          \"message batch in the first non-empty partition of the Fetch request \"\n          \"is larger than this value, then the message batch will still be \"\n          \"returned to ensure the consumer can make progress. \"\n          \"The maximum message batch size accepted by the broker is defined \"\n          \"via `message.max.bytes` (broker config) or \"\n          \"`max.message.bytes` (broker topic config). \"\n          \"`fetch.max.bytes` is automatically adjusted upwards to be \"\n          \"at least `message.max.bytes` (consumer config).\",\n          0, INT_MAX-512, 50*1024*1024 /* 50MB */ },\n\t{ _RK_GLOBAL|_RK_CONSUMER, \"fetch.min.bytes\", _RK_C_INT,\n\t  _RK(fetch_min_bytes),\n\t  \"Minimum number of bytes the broker responds with. \"\n\t  \"If fetch.wait.max.ms expires the accumulated data will \"\n\t  \"be sent to the client regardless of this setting.\",\n\t  1, 100000000, 1 },\n        { _RK_GLOBAL|_RK_CONSUMER|_RK_MED, \"fetch.error.backoff.ms\", _RK_C_INT,\n\t  _RK(fetch_error_backoff_ms),\n\t  \"How long to postpone the next fetch request for a \"\n\t  \"topic+partition in case of a fetch error.\",\n\t  0, 300*1000, 500 },\n        { _RK_GLOBAL|_RK_CONSUMER|_RK_DEPRECATED, \"offset.store.method\",\n          _RK_C_S2I,\n          _RK(offset_store_method),\n          \"Offset commit store method: \"\n          \"'file' - DEPRECATED: local file store (offset.store.path, et.al), \"\n          \"'broker' - broker commit store \"\n          \"(requires Apache Kafka 0.8.2 or later on the broker).\",\n          .vdef = RD_KAFKA_OFFSET_METHOD_BROKER,\n          .s2i = {\n                        { RD_KAFKA_OFFSET_METHOD_NONE, \"none\" },\n                        { RD_KAFKA_OFFSET_METHOD_FILE, \"file\" },\n                        { RD_KAFKA_OFFSET_METHOD_BROKER, \"broker\" }\n                }\n        },\n        { _RK_GLOBAL|_RK_CONSUMER|_RK_HIGH, \"isolation.level\",\n          _RK_C_S2I,\n          _RK(isolation_level),\n          \"Controls how to read messages written transactionally: \"\n          \"`read_committed` - only return transactional messages which have \"\n          \"been committed. `read_uncommitted` - return all messages, even \"\n          \"transactional messages which have been aborted.\",\n          .vdef = RD_KAFKA_READ_COMMITTED,\n          .s2i = {\n                        { RD_KAFKA_READ_UNCOMMITTED, \"read_uncommitted\" },\n                        { RD_KAFKA_READ_COMMITTED, \"read_committed\" }\n                }\n        },\n        { _RK_GLOBAL|_RK_CONSUMER, \"consume_cb\", _RK_C_PTR,\n\t  _RK(consume_cb),\n\t  \"Message consume callback (set with rd_kafka_conf_set_consume_cb())\"},\n\t{ _RK_GLOBAL|_RK_CONSUMER, \"rebalance_cb\", _RK_C_PTR,\n\t  _RK(rebalance_cb),\n\t  \"Called after consumer group has been rebalanced \"\n          \"(set with rd_kafka_conf_set_rebalance_cb())\" },\n\t{ _RK_GLOBAL|_RK_CONSUMER, \"offset_commit_cb\", _RK_C_PTR,\n\t  _RK(offset_commit_cb),\n\t  \"Offset commit result propagation callback. \"\n          \"(set with rd_kafka_conf_set_offset_commit_cb())\" },\n\t{ _RK_GLOBAL|_RK_CONSUMER, \"enable.partition.eof\", _RK_C_BOOL,\n\t  _RK(enable_partition_eof),\n\t  \"Emit RD_KAFKA_RESP_ERR__PARTITION_EOF event whenever the \"\n\t  \"consumer reaches the end of a partition.\",\n\t  0, 1, 0 },\n        { _RK_GLOBAL|_RK_CONSUMER|_RK_MED, \"check.crcs\", _RK_C_BOOL,\n          _RK(check_crcs),\n          \"Verify CRC32 of consumed messages, ensuring no on-the-wire or \"\n          \"on-disk corruption to the messages occurred. This check comes \"\n          \"at slightly increased CPU usage.\",\n          0, 1, 0 },\n        { _RK_GLOBAL, \"client.rack\", _RK_C_KSTR,\n          _RK(client_rack),\n          \"A rack identifier for this client. This can be any string value \"\n          \"which indicates where this client is physically located. It \"\n          \"corresponds with the broker config `broker.rack`.\",\n          .sdef =  \"\" },\n\n        /* Global producer properties */\n        { _RK_GLOBAL|_RK_PRODUCER|_RK_HIGH, \"transactional.id\", _RK_C_STR,\n          _RK(eos.transactional_id),\n          \"Enables the transactional producer. \"\n          \"The transactional.id is used to identify the same transactional \"\n          \"producer instance across process restarts. \"\n          \"It allows the producer to guarantee that transactions corresponding \"\n          \"to earlier instances of the same producer have been finalized \"\n          \"prior to starting any new transactions, and that any \"\n          \"zombie instances are fenced off. \"\n          \"If no transactional.id is provided, then the producer is limited \"\n          \"to idempotent delivery (if enable.idempotence is set). \"\n          \"Requires broker version >= 0.11.0.\" },\n        { _RK_GLOBAL|_RK_PRODUCER|_RK_MED, \"transaction.timeout.ms\", _RK_C_INT,\n          _RK(eos.transaction_timeout_ms),\n          \"The maximum amount of time in milliseconds that the transaction \"\n          \"coordinator will wait for a transaction status update from the \"\n          \"producer before proactively aborting the ongoing transaction. \"\n          \"If this value is larger than the `transaction.max.timeout.ms` \"\n          \"setting in the broker, the init_transactions() call will fail with \"\n          \"ERR_INVALID_TRANSACTION_TIMEOUT. \"\n          \"The transaction timeout automatically adjusts \"\n          \"`message.timeout.ms` and `socket.timeout.ms`, unless explicitly \"\n          \"configured in which case they must not exceed the \"\n          \"transaction timeout (`socket.timeout.ms` must be at least 100ms \"\n          \"lower than `transaction.timeout.ms`). \"\n          \"This is also the default timeout value if no timeout (-1) is \"\n          \"supplied to the transactional API methods.\",\n          1000, INT_MAX, 60000 },\n        { _RK_GLOBAL|_RK_PRODUCER|_RK_HIGH, \"enable.idempotence\", _RK_C_BOOL,\n          _RK(eos.idempotence),\n          \"When set to `true`, the producer will ensure that messages are \"\n          \"successfully produced exactly once and in the original produce \"\n          \"order. \"\n          \"The following configuration properties are adjusted automatically \"\n          \"(if not modified by the user) when idempotence is enabled: \"\n          \"`max.in.flight.requests.per.connection=\"\n          RD_KAFKA_IDEMP_MAX_INFLIGHT_STR \"` (must be less than or \"\n          \"equal to \" RD_KAFKA_IDEMP_MAX_INFLIGHT_STR \"), `retries=INT32_MAX` \"\n          \"(must be greater than 0), `acks=all`, `queuing.strategy=fifo`. \"\n          \"Producer instantation will fail if user-supplied configuration \"\n          \"is incompatible.\",\n          0, 1, 0 },\n        { _RK_GLOBAL|_RK_PRODUCER|_RK_EXPERIMENTAL, \"enable.gapless.guarantee\",\n          _RK_C_BOOL,\n          _RK(eos.gapless),\n          \"When set to `true`, any error that could result in a gap \"\n          \"in the produced message series when a batch of messages fails, \"\n          \"will raise a fatal error (ERR__GAPLESS_GUARANTEE) and stop \"\n          \"the producer. \"\n          \"Messages failing due to `message.timeout.ms` are not covered \"\n          \"by this guarantee. \"\n          \"Requires `enable.idempotence=true`.\",\n          0, 1, 0 },\n        { _RK_GLOBAL|_RK_PRODUCER|_RK_HIGH, \"queue.buffering.max.messages\",\n          _RK_C_INT,\n\t  _RK(queue_buffering_max_msgs),\n\t  \"Maximum number of messages allowed on the producer queue. \"\n\t  \"This queue is shared by all topics and partitions.\",\n\t  1, 10000000, 100000 },\n        { _RK_GLOBAL|_RK_PRODUCER|_RK_HIGH, \"queue.buffering.max.kbytes\",\n          _RK_C_INT,\n\t  _RK(queue_buffering_max_kbytes),\n\t  \"Maximum total message size sum allowed on the producer queue. \"\n\t  \"This queue is shared by all topics and partitions. \"\n\t  \"This property has higher priority than queue.buffering.max.messages.\",\n\t  1, INT_MAX, 0x100000/*1GB*/ },\n        { _RK_GLOBAL|_RK_PRODUCER|_RK_HIGH, \"queue.buffering.max.ms\",\n          _RK_C_DBL,\n\t  _RK(buffering_max_ms_dbl),\n\t  \"Delay in milliseconds to wait for messages in the producer queue \"\n          \"to accumulate before constructing message batches (MessageSets) to \"\n          \"transmit to brokers. \"\n\t  \"A higher value allows larger and more effective \"\n          \"(less overhead, improved compression) batches of messages to \"\n          \"accumulate at the expense of increased message delivery latency.\",\n\t  .dmin = 0, .dmax = 900.0*1000.0, .ddef = 0.5 },\n        { _RK_GLOBAL|_RK_PRODUCER|_RK_HIGH, \"linger.ms\", _RK_C_ALIAS,\n          .sdef = \"queue.buffering.max.ms\" },\n        { _RK_GLOBAL|_RK_PRODUCER|_RK_HIGH, \"message.send.max.retries\",\n          _RK_C_INT,\n\t  _RK(max_retries),\n\t  \"How many times to retry sending a failing Message. \"\n          \"**Note:** retrying may cause reordering unless \"\n          \"`enable.idempotence` is set to true.\",\n          0, 10000000, 2 },\n          { _RK_GLOBAL | _RK_PRODUCER, \"retries\", _RK_C_ALIAS,\n                .sdef = \"message.send.max.retries\" },\n        { _RK_GLOBAL|_RK_PRODUCER|_RK_MED, \"retry.backoff.ms\", _RK_C_INT,\n\t  _RK(retry_backoff_ms),\n\t  \"The backoff time in milliseconds before retrying a protocol request.\",\n\t  1, 300*1000, 100 },\n\n\t{ _RK_GLOBAL|_RK_PRODUCER, \"queue.buffering.backpressure.threshold\",\n          _RK_C_INT, _RK(queue_backpressure_thres),\n          \"The threshold of outstanding not yet transmitted broker requests \"\n          \"needed to backpressure the producer's message accumulator. \"\n          \"If the number of not yet transmitted requests equals or exceeds \"\n          \"this number, produce request creation that would have otherwise \"\n          \"been triggered (for example, in accordance with linger.ms) will be \"\n          \"delayed. A lower number yields larger and more effective batches. \"\n          \"A higher value can improve latency when using compression on slow \"\n          \"machines.\",\n        1, 1000000, 1 },\n\n        { _RK_GLOBAL|_RK_PRODUCER|_RK_MED, \"compression.codec\", _RK_C_S2I,\n\t  _RK(compression_codec),\n\t  \"compression codec to use for compressing message sets. \"\n\t  \"This is the default value for all topics, may be overridden by \"\n\t  \"the topic configuration property `compression.codec`. \",\n\t  .vdef = RD_KAFKA_COMPRESSION_NONE,\n\t  .s2i = {\n\t\t\t{ RD_KAFKA_COMPRESSION_NONE,   \"none\" },\n#if WITH_ZLIB\n\t\t\t{ RD_KAFKA_COMPRESSION_GZIP,   \"gzip\" },\n#endif\n#if WITH_SNAPPY\n\t\t\t{ RD_KAFKA_COMPRESSION_SNAPPY, \"snappy\" },\n#endif\n\t\t\t{ RD_KAFKA_COMPRESSION_LZ4, \"lz4\" },\n#if WITH_ZSTD\n\t\t\t{ RD_KAFKA_COMPRESSION_ZSTD, \"zstd\" },\n#endif\n\t\t\t{ 0 }\n\t\t} },\n        { _RK_GLOBAL|_RK_PRODUCER|_RK_MED, \"compression.type\", _RK_C_ALIAS,\n          .sdef = \"compression.codec\" },\n        { _RK_GLOBAL|_RK_PRODUCER|_RK_MED, \"batch.num.messages\", _RK_C_INT,\n\t  _RK(batch_num_messages),\n\t  \"Maximum number of messages batched in one MessageSet. \"\n\t  \"The total MessageSet size is also limited by message.max.bytes.\",\n\t  1, 1000000, 10000 },\n\t{ _RK_GLOBAL|_RK_PRODUCER, \"delivery.report.only.error\", _RK_C_BOOL,\n\t  _RK(dr_err_only),\n\t  \"Only provide delivery reports for failed messages.\",\n\t  0, 1, 0 },\n\t{ _RK_GLOBAL|_RK_PRODUCER, \"dr_cb\", _RK_C_PTR,\n\t  _RK(dr_cb),\n\t  \"Delivery report callback (set with rd_kafka_conf_set_dr_cb())\" },\n\t{ _RK_GLOBAL|_RK_PRODUCER, \"dr_msg_cb\", _RK_C_PTR,\n\t  _RK(dr_msg_cb),\n\t  \"Delivery report callback (set with rd_kafka_conf_set_dr_msg_cb())\" },\n\n\n        /*\n         * Topic properties\n         */\n\n        /* Topic producer properties */\n        { _RK_TOPIC|_RK_PRODUCER|_RK_HIGH, \"request.required.acks\", _RK_C_INT,\n          _RKT(required_acks),\n          \"This field indicates the number of acknowledgements the leader \"\n          \"broker must receive from ISR brokers before responding to the \"\n          \"request: \"\n          \"*0*=Broker does not send any response/ack to client, \"\n          \"*-1* or *all*=Broker will block until message is committed by all \"\n          \"in sync replicas (ISRs). If there are less than \"\n          \"`min.insync.replicas` (broker configuration) in the ISR set the \"\n          \"produce request will fail.\",\n          -1, 1000, -1,\n          .s2i = {\n                        { -1, \"all\" },\n                }\n        },\n        { _RK_TOPIC|_RK_PRODUCER|_RK_HIGH, \"acks\", _RK_C_ALIAS,\n\t  .sdef = \"request.required.acks\" },\n\n        { _RK_TOPIC|_RK_PRODUCER|_RK_MED, \"request.timeout.ms\", _RK_C_INT,\n\t  _RKT(request_timeout_ms),\n\t  \"The ack timeout of the producer request in milliseconds. \"\n\t  \"This value is only enforced by the broker and relies \"\n\t  \"on `request.required.acks` being != 0.\",\n\t  1, 900*1000, 5*1000 },\n        { _RK_TOPIC|_RK_PRODUCER|_RK_HIGH, \"message.timeout.ms\", _RK_C_INT,\n\t  _RKT(message_timeout_ms),\n\t  \"Local message timeout. \"\n\t  \"This value is only enforced locally and limits the time a \"\n\t  \"produced message waits for successful delivery. \"\n\t  \"A time of 0 is infinite. \"\n\t  \"This is the maximum time librdkafka may use to deliver a message \"\n\t  \"(including retries). Delivery error occurs when either the retry \"\n\t  \"count or the message timeout are exceeded. \"\n          \"The message timeout is automatically adjusted to \"\n          \"`transaction.timeout.ms` if `transactional.id` is configured.\",\n\t  0, INT32_MAX, 300*1000 },\n        { _RK_TOPIC|_RK_PRODUCER|_RK_HIGH, \"delivery.timeout.ms\", _RK_C_ALIAS,\n          .sdef = \"message.timeout.ms\" },\n        { _RK_TOPIC|_RK_PRODUCER|_RK_DEPRECATED|_RK_EXPERIMENTAL,\n          \"queuing.strategy\", _RK_C_S2I,\n          _RKT(queuing_strategy),\n          \"Producer queuing strategy. FIFO preserves produce ordering, \"\n          \"while LIFO prioritizes new messages.\",\n          .vdef = 0,\n          .s2i = {\n                        { RD_KAFKA_QUEUE_FIFO, \"fifo\" },\n                        { RD_KAFKA_QUEUE_LIFO, \"lifo\" }\n                }\n        },\n        { _RK_TOPIC|_RK_PRODUCER|_RK_DEPRECATED,\n          \"produce.offset.report\", _RK_C_BOOL,\n          _RKT(produce_offset_report),\n          \"No longer used.\",\n          0, 1, 0 },\n        { _RK_TOPIC|_RK_PRODUCER|_RK_HIGH, \"partitioner\", _RK_C_STR,\n          _RKT(partitioner_str),\n          \"Partitioner: \"\n          \"`random` - random distribution, \"\n          \"`consistent` - CRC32 hash of key (Empty and NULL keys are mapped to single partition), \"\n          \"`consistent_random` - CRC32 hash of key (Empty and NULL keys are randomly partitioned), \"\n          \"`murmur2` - Java Producer compatible Murmur2 hash of key (NULL keys are mapped to single partition), \"\n          \"`murmur2_random` - Java Producer compatible Murmur2 hash of key \"\n          \"(NULL keys are randomly partitioned. This is functionally equivalent \"\n          \"to the default partitioner in the Java Producer.), \"\n          \"`fnv1a` - FNV-1a hash of key (NULL keys are mapped to single partition), \"\n          \"`fnv1a_random` - FNV-1a hash of key (NULL keys are randomly partitioned).\",\n          .sdef = \"consistent_random\",\n          .validate = rd_kafka_conf_validate_partitioner },\n\t{ _RK_TOPIC|_RK_PRODUCER, \"partitioner_cb\", _RK_C_PTR,\n\t  _RKT(partitioner),\n\t  \"Custom partitioner callback \"\n\t  \"(set with rd_kafka_topic_conf_set_partitioner_cb())\" },\n\t{ _RK_TOPIC|_RK_PRODUCER|_RK_DEPRECATED|_RK_EXPERIMENTAL,\n          \"msg_order_cmp\", _RK_C_PTR,\n\t  _RKT(msg_order_cmp),\n\t  \"Message queue ordering comparator \"\n\t  \"(set with rd_kafka_topic_conf_set_msg_order_cmp()). \"\n          \"Also see `queuing.strategy`.\" },\n\t{ _RK_TOPIC, \"opaque\", _RK_C_PTR,\n\t  _RKT(opaque),\n\t  \"Application opaque (set with rd_kafka_topic_conf_set_opaque())\" },\n        { _RK_TOPIC|_RK_PRODUCER|_RK_HIGH, \"compression.codec\", _RK_C_S2I,\n\t  _RKT(compression_codec),\n\t  \"Compression codec to use for compressing message sets. \"\n          \"inherit = inherit global compression.codec configuration.\",\n\t  .vdef = RD_KAFKA_COMPRESSION_INHERIT,\n\t  .s2i = {\n\t\t  { RD_KAFKA_COMPRESSION_NONE, \"none\" },\n#if WITH_ZLIB\n\t\t  { RD_KAFKA_COMPRESSION_GZIP, \"gzip\" },\n#endif\n#if WITH_SNAPPY\n\t\t  { RD_KAFKA_COMPRESSION_SNAPPY, \"snappy\" },\n#endif\n\t\t  { RD_KAFKA_COMPRESSION_LZ4, \"lz4\" },\n#if WITH_ZSTD\n\t\t  { RD_KAFKA_COMPRESSION_ZSTD, \"zstd\" },\n#endif\n\t\t  { RD_KAFKA_COMPRESSION_INHERIT, \"inherit\" },\n\t\t  { 0 }\n\t\t} },\n        { _RK_TOPIC|_RK_PRODUCER|_RK_HIGH, \"compression.type\", _RK_C_ALIAS,\n          .sdef = \"compression.codec\" },\n        { _RK_TOPIC|_RK_PRODUCER|_RK_MED, \"compression.level\", _RK_C_INT,\n\t  _RKT(compression_level),\n\t  \"Compression level parameter for algorithm selected by configuration \"\n\t  \"property `compression.codec`. Higher values will result in better \"\n\t  \"compression at the cost of more CPU usage. Usable range is \"\n\t  \"algorithm-dependent: [0-9] for gzip; [0-12] for lz4; only 0 for snappy; \"\n\t  \"-1 = codec-dependent default compression level.\",\n\t  RD_KAFKA_COMPLEVEL_MIN,\n\t  RD_KAFKA_COMPLEVEL_MAX,\n\t  RD_KAFKA_COMPLEVEL_DEFAULT },\n\n\n        /* Topic consumer properties */\n        { _RK_TOPIC|_RK_CONSUMER|_RK_DEPRECATED, \"auto.commit.enable\",\n          _RK_C_BOOL,\n\t  _RKT(auto_commit),\n\t  \"[**LEGACY PROPERTY:** This property is used by the simple legacy \"\n\t  \"consumer only. When using the high-level KafkaConsumer, the global \"\n\t  \"`enable.auto.commit` property must be used instead]. \"\n\t  \"If true, periodically commit offset of the last message handed \"\n\t  \"to the application. This committed offset will be used when the \"\n\t  \"process restarts to pick up where it left off. \"\n\t  \"If false, the application will have to call \"\n\t  \"`rd_kafka_offset_store()` to store an offset (optional). \"\n\t  \"**NOTE:** There is currently no zookeeper integration, offsets \"\n\t  \"will be written to broker or local file according to \"\n          \"offset.store.method.\",\n\t  0, 1, 1 },\n\t{ _RK_TOPIC|_RK_CONSUMER, \"enable.auto.commit\", _RK_C_ALIAS,\n\t  .sdef = \"auto.commit.enable\" },\n        { _RK_TOPIC|_RK_CONSUMER|_RK_HIGH, \"auto.commit.interval.ms\",\n          _RK_C_INT,\n\t  _RKT(auto_commit_interval_ms),\n\t  \"[**LEGACY PROPERTY:** This setting is used by the simple legacy \"\n\t  \"consumer only. When using the high-level KafkaConsumer, the \"\n\t  \"global `auto.commit.interval.ms` property must be used instead]. \"\n\t  \"The frequency in milliseconds that the consumer offsets \"\n\t  \"are committed (written) to offset storage.\",\n\t  10, 86400*1000, 60*1000 },\n        { _RK_TOPIC|_RK_CONSUMER|_RK_HIGH, \"auto.offset.reset\", _RK_C_S2I,\n\t  _RKT(auto_offset_reset),\n\t  \"Action to take when there is no initial offset in offset store \"\n\t  \"or the desired offset is out of range: \"\n\t  \"'smallest','earliest' - automatically reset the offset to the smallest offset, \"\n\t  \"'largest','latest' - automatically reset the offset to the largest offset, \"\n\t  \"'error' - trigger an error which is retrieved by consuming messages \"\n\t  \"and checking 'message->err'.\",\n\t  .vdef = RD_KAFKA_OFFSET_END,\n\t  .s2i = {\n\t\t\t{ RD_KAFKA_OFFSET_BEGINNING, \"smallest\" },\n\t\t\t{ RD_KAFKA_OFFSET_BEGINNING, \"earliest\" },\n\t\t\t{ RD_KAFKA_OFFSET_BEGINNING, \"beginning\" },\n\t\t\t{ RD_KAFKA_OFFSET_END, \"largest\" },\n\t\t\t{ RD_KAFKA_OFFSET_END, \"latest\" },\n\t\t\t{ RD_KAFKA_OFFSET_END, \"end\" },\n\t\t\t{ RD_KAFKA_OFFSET_INVALID, \"error\" },\n\t\t}\n\t},\n        { _RK_TOPIC|_RK_CONSUMER|_RK_DEPRECATED, \"offset.store.path\",\n          _RK_C_STR,\n\t  _RKT(offset_store_path),\n\t  \"Path to local file for storing offsets. If the path is a directory \"\n\t  \"a filename will be automatically generated in that directory based \"\n\t  \"on the topic and partition. \"\n          \"File-based offset storage will be removed in a future version.\",\n\t  .sdef = \".\" },\n\n        { _RK_TOPIC|_RK_CONSUMER|_RK_DEPRECATED,\n          \"offset.store.sync.interval.ms\", _RK_C_INT,\n\t  _RKT(offset_store_sync_interval_ms),\n\t  \"fsync() interval for the offset file, in milliseconds. \"\n\t  \"Use -1 to disable syncing, and 0 for immediate sync after \"\n\t  \"each write. \"\n          \"File-based offset storage will be removed in a future version.\",\n\t  -1, 86400*1000, -1 },\n\n        { _RK_TOPIC|_RK_CONSUMER|_RK_DEPRECATED, \"offset.store.method\",\n          _RK_C_S2I,\n          _RKT(offset_store_method),\n          \"Offset commit store method: \"\n          \"'file' - DEPRECATED: local file store (offset.store.path, et.al), \"\n          \"'broker' - broker commit store \"\n          \"(requires \\\"group.id\\\" to be configured and \"\n          \"Apache Kafka 0.8.2 or later on the broker.).\",\n          .vdef = RD_KAFKA_OFFSET_METHOD_BROKER,\n          .s2i = {\n                        { RD_KAFKA_OFFSET_METHOD_FILE, \"file\" },\n                        { RD_KAFKA_OFFSET_METHOD_BROKER, \"broker\" }\n                }\n        },\n\n        { _RK_TOPIC|_RK_CONSUMER, \"consume.callback.max.messages\", _RK_C_INT,\n          _RKT(consume_callback_max_msgs),\n          \"Maximum number of messages to dispatch in \"\n          \"one `rd_kafka_consume_callback*()` call (0 = unlimited)\",\n          0, 1000000, 0 },\n\n\t{ 0, /* End */ }\n};\n\n/**\n * @returns the property object for \\p name in \\p scope, or NULL if not found.\n * @remark does not work with interceptor configs.\n */\nconst struct rd_kafka_property *\nrd_kafka_conf_prop_find (int scope, const char *name) {\n        const struct rd_kafka_property *prop;\n\n restart:\n        for (prop = rd_kafka_properties ; prop->name ; prop++) {\n\n                if (!(prop->scope & scope))\n                        continue;\n\n                if (strcmp(prop->name, name))\n                        continue;\n\n                if (prop->type == _RK_C_ALIAS) {\n                        /* Caller supplied an alias, restart\n                         * search for real name. */\n                        name = prop->sdef;\n                        goto restart;\n                }\n\n                return prop;\n        }\n\n        return NULL;\n}\n\n/**\n * @returns rd_true if property has been set/modified, else rd_false.\n *          If \\p name is unknown 0 is returned.\n */\nstatic rd_bool_t rd_kafka_conf_is_modified (const rd_kafka_conf_t *conf,\n                                            const char *name) {\n        const struct rd_kafka_property *prop;\n\n        if (!(prop = rd_kafka_conf_prop_find(_RK_GLOBAL, name)))\n            return rd_false;\n\n        return rd_kafka_anyconf_is_modified(conf, prop);\n}\n\n\n/**\n * @returns true if property has been set/modified, else 0.\n *          If \\p name is unknown 0 is returned.\n */\nstatic\nrd_bool_t rd_kafka_topic_conf_is_modified (const rd_kafka_topic_conf_t *conf,\n                                           const char *name) {\n        const struct rd_kafka_property *prop;\n\n        if (!(prop = rd_kafka_conf_prop_find(_RK_TOPIC, name)))\n            return 0;\n\n        return rd_kafka_anyconf_is_modified(conf, prop);\n}\n\n\n\nstatic rd_kafka_conf_res_t\nrd_kafka_anyconf_set_prop0 (int scope, void *conf,\n\t\t\t    const struct rd_kafka_property *prop,\n\t\t\t    const char *istr, int ival, rd_kafka_conf_set_mode_t set_mode,\n                            char *errstr, size_t errstr_size) {\n        rd_kafka_conf_res_t res;\n\n#define _RK_PTR(TYPE,BASE,OFFSET)  (TYPE)(void *)(((char *)(BASE))+(OFFSET))\n\n        /* Try interceptors first (only for GLOBAL config) */\n        if (scope & _RK_GLOBAL) {\n                if (prop->type == _RK_C_PTR || prop->type == _RK_C_INTERNAL)\n                        res = RD_KAFKA_CONF_UNKNOWN;\n                else\n                        res = rd_kafka_interceptors_on_conf_set(conf,\n                                                                prop->name,\n                                                                istr,\n                                                                errstr,\n                                                                errstr_size);\n                if (res != RD_KAFKA_CONF_UNKNOWN)\n                        return res;\n        }\n\n\n        if (prop->set) {\n                /* Custom setter */\n                rd_kafka_conf_res_t res;\n\n                res = prop->set(scope, conf, prop->name, istr,\n                                _RK_PTR(void *, conf, prop->offset),\n                                set_mode, errstr, errstr_size);\n\n                if (res != RD_KAFKA_CONF_OK)\n                        return res;\n\n                /* FALLTHRU so that property value is set. */\n        }\n\n\tswitch (prop->type)\n\t{\n\tcase _RK_C_STR:\n\t{\n\t\tchar **str = _RK_PTR(char **, conf, prop->offset);\n\t\tif (*str)\n\t\t\trd_free(*str);\n\t\tif (istr)\n\t\t\t*str = rd_strdup(istr);\n\t\telse\n\t\t\t*str = prop->sdef ? rd_strdup(prop->sdef) : NULL;\n                break;\n\t}\n        case _RK_C_KSTR:\n        {\n                rd_kafkap_str_t **kstr = _RK_PTR(rd_kafkap_str_t **, conf,\n                                                 prop->offset);\n                if (*kstr)\n                        rd_kafkap_str_destroy(*kstr);\n                if (istr)\n                        *kstr = rd_kafkap_str_new(istr, -1);\n                else\n                        *kstr = prop->sdef ?\n\t\t\t\trd_kafkap_str_new(prop->sdef, -1) : NULL;\n                break;\n        }\n\tcase _RK_C_PTR:\n\t\t*_RK_PTR(const void **, conf, prop->offset) = istr;\n                break;\n\tcase _RK_C_BOOL:\n\tcase _RK_C_INT:\n\tcase _RK_C_S2I:\n\tcase _RK_C_S2F:\n\t{\n\t\tint *val = _RK_PTR(int *, conf, prop->offset);\n\n\t\tif (prop->type == _RK_C_S2F) {\n\t\t\tswitch (set_mode)\n\t\t\t{\n\t\t\tcase _RK_CONF_PROP_SET_REPLACE:\n\t\t\t\t*val = ival;\n\t\t\t\tbreak;\n\t\t\tcase _RK_CONF_PROP_SET_ADD:\n\t\t\t\t*val |= ival;\n\t\t\t\tbreak;\n\t\t\tcase _RK_CONF_PROP_SET_DEL:\n\t\t\t\t*val &= ~ival;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t/* Single assignment */\n\t\t\t*val = ival;\n\n\t\t}\n                break;\n\t}\n        case _RK_C_DBL:\n        {\n                double *val = _RK_PTR(double *, conf, prop->offset);\n                if (istr) {\n                        char *endptr;\n                        double new_val = strtod(istr, &endptr);\n                        /* This is verified in set_prop() */\n                        rd_assert(endptr != istr);\n                        *val = new_val;\n                } else\n                        *val = prop->ddef;\n                break;\n        }\n\n        case _RK_C_PATLIST:\n        {\n                /* Split comma-separated list into individual regex expressions\n                 * that are verified and then append to the provided list. */\n                rd_kafka_pattern_list_t **plist;\n\n                plist = _RK_PTR(rd_kafka_pattern_list_t **, conf, prop->offset);\n\n\t\tif (*plist)\n\t\t\trd_kafka_pattern_list_destroy(*plist);\n\n\t\tif (istr) {\n\t\t\tif (!(*plist =\n\t\t\t      rd_kafka_pattern_list_new(istr,\n\t\t\t\t\t\t\terrstr,\n\t\t\t\t\t\t\t(int)errstr_size)))\n\t\t\t\treturn RD_KAFKA_CONF_INVALID;\n\t\t} else\n\t\t\t*plist = NULL;\n\n                break;\n        }\n\n        case _RK_C_INTERNAL:\n                /* Probably handled by setter */\n                break;\n\n\tdefault:\n\t\trd_kafka_assert(NULL, !*\"unknown conf type\");\n\t}\n\n\n        rd_kafka_anyconf_set_modified(conf, prop, 1/*modified*/);\n        return RD_KAFKA_CONF_OK;\n}\n\n\n/**\n * @brief Find s2i (string-to-int mapping) entry and return its array index,\n *        or -1 on miss.\n */\nstatic int rd_kafka_conf_s2i_find (const struct rd_kafka_property *prop,\n\t\t\t\t   const char *value) {\n\tint j;\n\n\tfor (j = 0 ; j < (int)RD_ARRAYSIZE(prop->s2i); j++) {\n\t\tif (prop->s2i[j].str &&\n\t\t    !rd_strcasecmp(prop->s2i[j].str, value))\n\t\t\treturn j;\n\t}\n\n\treturn -1;\n}\n\n\n/**\n * @brief Set configuration property.\n *\n * @param allow_specific Allow rd_kafka_*conf_set_..() to be set,\n *        such as rd_kafka_conf_set_log_cb().\n *        Should not be allowed from the conf_set() string interface.\n */\nstatic rd_kafka_conf_res_t\nrd_kafka_anyconf_set_prop (int scope, void *conf,\n\t\t\t   const struct rd_kafka_property *prop,\n\t\t\t   const char *value,\n                           int allow_specific,\n\t\t\t   char *errstr, size_t errstr_size) {\n\tint ival;\n\n\tswitch (prop->type)\n\t{\n\tcase _RK_C_STR:\n        case _RK_C_KSTR:\n\t\tif (prop->s2i[0].str) {\n\t\t\tint match;\n\n\t\t\tif (!value ||\n\t\t\t    (match = rd_kafka_conf_s2i_find(prop, value)) == -1){\n\t\t\t\trd_snprintf(errstr, errstr_size,\n\t\t\t\t\t    \"Invalid value for \"\n\t\t\t\t\t    \"configuration property \\\"%s\\\": \"\n\t\t\t\t\t    \"%s\",\n\t\t\t\t\t    prop->name, value);\n\t\t\t\treturn RD_KAFKA_CONF_INVALID;\n\t\t\t}\n\n\t\t\t/* Replace value string with canonical form */\n\t\t\tvalue = prop->s2i[match].str;\n\t\t}\n\t\t/* FALLTHRU */\n        case _RK_C_PATLIST:\n\t\tif (prop->validate &&\n\t\t    (!value || !prop->validate(prop, value, -1))) {\n\t\t\trd_snprintf(errstr, errstr_size,\n\t\t\t\t    \"Invalid value for \"\n\t\t\t\t    \"configuration property \\\"%s\\\": %s\",\n\t\t\t\t    prop->name, value);\n\t\t\treturn RD_KAFKA_CONF_INVALID;\n\t\t}\n\n\t\treturn rd_kafka_anyconf_set_prop0(scope, conf, prop, value, 0,\n\t\t\t\t\t\t  _RK_CONF_PROP_SET_REPLACE,\n                                                  errstr, errstr_size);\n\n\tcase _RK_C_PTR:\n                /* Allow hidden internal unit test properties to\n                 * be set from generic conf_set() interface. */\n                if (!allow_specific && !(prop->scope & _RK_HIDDEN)) {\n                        rd_snprintf(errstr, errstr_size,\n                                    \"Property \\\"%s\\\" must be set through \"\n                                    \"dedicated .._set_..() function\",\n                                    prop->name);\n                        return RD_KAFKA_CONF_INVALID;\n                }\n                return rd_kafka_anyconf_set_prop0(scope, conf, prop, value, 0,\n                                                  _RK_CONF_PROP_SET_REPLACE,\n                                                  errstr, errstr_size);\n\n\tcase _RK_C_BOOL:\n\t\tif (!value) {\n\t\t\trd_snprintf(errstr, errstr_size,\n\t\t\t\t \"Bool configuration property \\\"%s\\\" cannot \"\n\t\t\t\t \"be set to empty value\", prop->name);\n\t\t\treturn RD_KAFKA_CONF_INVALID;\n\t\t}\n\n\n\t\tif (!rd_strcasecmp(value, \"true\") ||\n\t\t    !rd_strcasecmp(value, \"t\") ||\n\t\t    !strcmp(value, \"1\"))\n\t\t\tival = 1;\n\t\telse if (!rd_strcasecmp(value, \"false\") ||\n\t\t\t !rd_strcasecmp(value, \"f\") ||\n\t\t\t !strcmp(value, \"0\"))\n\t\t\tival = 0;\n\t\telse {\n\t\t\trd_snprintf(errstr, errstr_size,\n\t\t\t\t \"Expected bool value for \\\"%s\\\": \"\n\t\t\t\t \"true or false\", prop->name);\n\t\t\treturn RD_KAFKA_CONF_INVALID;\n\t\t}\n\n\t\trd_kafka_anyconf_set_prop0(scope, conf, prop, value, ival,\n\t\t\t\t\t   _RK_CONF_PROP_SET_REPLACE,\n                                           errstr, errstr_size);\n\t\treturn RD_KAFKA_CONF_OK;\n\n\tcase _RK_C_INT:\n\t{\n\t\tconst char *end;\n\n\t\tif (!value) {\n\t\t\trd_snprintf(errstr, errstr_size,\n\t\t\t\t \"Integer configuration \"\n\t\t\t\t \"property \\\"%s\\\" cannot be set \"\n\t\t\t\t \"to empty value\", prop->name);\n\t\t\treturn RD_KAFKA_CONF_INVALID;\n\t\t}\n\n\t\tival = (int)strtol(value, (char **)&end, 0);\n\t\tif (end == value) {\n\t\t\t/* Non numeric, check s2i for string mapping */\n\t\t\tint match = rd_kafka_conf_s2i_find(prop, value);\n\n\t\t\tif (match == -1) {\n\t\t\t\trd_snprintf(errstr, errstr_size,\n\t\t\t\t\t    \"Invalid value for \"\n\t\t\t\t\t    \"configuration property \\\"%s\\\"\",\n\t\t\t\t\t    prop->name);\n\t\t\t\treturn RD_KAFKA_CONF_INVALID;\n\t\t\t}\n\n\t\t\tival = prop->s2i[match].val;\n\t\t}\n\n\t\tif (ival < prop->vmin ||\n\t\t    ival > prop->vmax) {\n\t\t\trd_snprintf(errstr, errstr_size,\n\t\t\t\t \"Configuration property \\\"%s\\\" value \"\n\t\t\t\t \"%i is outside allowed range %i..%i\\n\",\n\t\t\t\t prop->name, ival,\n\t\t\t\t prop->vmin,\n\t\t\t\t prop->vmax);\n\t\t\treturn RD_KAFKA_CONF_INVALID;\n\t\t}\n\n\t\trd_kafka_anyconf_set_prop0(scope, conf, prop, value, ival,\n\t\t\t\t\t   _RK_CONF_PROP_SET_REPLACE,\n                                           errstr, errstr_size);\n\t\treturn RD_KAFKA_CONF_OK;\n\t}\n\n        case _RK_C_DBL:\n        {\n                const char *end;\n                double dval;\n\n                if (!value) {\n                        rd_snprintf(errstr, errstr_size,\n                                 \"Float configuration \"\n                                 \"property \\\"%s\\\" cannot be set \"\n                                 \"to empty value\", prop->name);\n                        return RD_KAFKA_CONF_INVALID;\n                }\n\n                dval = strtod(value, (char **)&end);\n                if (end == value) {\n                        rd_snprintf(errstr, errstr_size,\n                                    \"Invalid value for \"\n                                    \"configuration property \\\"%s\\\"\",\n                                    prop->name);\n                        return RD_KAFKA_CONF_INVALID;\n                }\n\n                if (dval < prop->dmin ||\n                    dval > prop->dmax) {\n                        rd_snprintf(errstr, errstr_size,\n                                 \"Configuration property \\\"%s\\\" value \"\n                                 \"%g is outside allowed range %g..%g\\n\",\n                                 prop->name, dval,\n                                 prop->dmin,\n                                 prop->dmax);\n                        return RD_KAFKA_CONF_INVALID;\n                }\n\n                rd_kafka_anyconf_set_prop0(scope, conf, prop, value, 0,\n                                           _RK_CONF_PROP_SET_REPLACE,\n                                           errstr, errstr_size);\n                return RD_KAFKA_CONF_OK;\n        }\n\n\tcase _RK_C_S2I:\n\tcase _RK_C_S2F:\n\t{\n\t\tint j;\n\t\tconst char *next;\n\n\t\tif (!value) {\n\t\t\trd_snprintf(errstr, errstr_size,\n\t\t\t\t \"Configuration \"\n\t\t\t\t \"property \\\"%s\\\" cannot be set \"\n\t\t\t\t \"to empty value\", prop->name);\n\t\t\treturn RD_KAFKA_CONF_INVALID;\n\t\t}\n\n\t\tnext = value;\n\t\twhile (next && *next) {\n\t\t\tconst char *s, *t;\n\t\t\trd_kafka_conf_set_mode_t set_mode = _RK_CONF_PROP_SET_ADD; /* S2F */\n\n\t\t\ts = next;\n\n\t\t\tif (prop->type == _RK_C_S2F &&\n\t\t\t    (t = strchr(s, ','))) {\n\t\t\t\t/* CSV flag field */\n\t\t\t\tnext = t+1;\n\t\t\t} else {\n\t\t\t\t/* Single string */\n\t\t\t\tt = s+strlen(s);\n\t\t\t\tnext = NULL;\n\t\t\t}\n\n\n\t\t\t/* Left trim */\n\t\t\twhile (s < t && isspace((int)*s))\n\t\t\t\ts++;\n\n\t\t\t/* Right trim */\n\t\t\twhile (t > s && isspace((int)*t))\n\t\t\t\tt--;\n\n\t\t\t/* S2F: +/- prefix */\n\t\t\tif (prop->type == _RK_C_S2F) {\n\t\t\t\tif (*s == '+') {\n\t\t\t\t\tset_mode = _RK_CONF_PROP_SET_ADD;\n\t\t\t\t\ts++;\n\t\t\t\t} else if (*s == '-') {\n\t\t\t\t\tset_mode = _RK_CONF_PROP_SET_DEL;\n\t\t\t\t\ts++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Empty string? */\n\t\t\tif (s == t)\n\t\t\t\tcontinue;\n\n\t\t\t/* Match string to s2i table entry */\n\t\t\tfor (j = 0 ; j < (int)RD_ARRAYSIZE(prop->s2i); j++) {\n\t\t\t\tint new_val;\n\n\t\t\t\tif (!prop->s2i[j].str)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (strlen(prop->s2i[j].str) == (size_t)(t-s) &&\n\t\t\t\t\t !rd_strncasecmp(prop->s2i[j].str, s,\n\t\t\t\t\t\t\t (int)(t-s)))\n\t\t\t\t\tnew_val = prop->s2i[j].val;\n\t\t\t\telse\n\t\t\t\t\tcontinue;\n\n\t\t\t\trd_kafka_anyconf_set_prop0(scope, conf, prop,\n                                                           value, new_val,\n                                                           set_mode,\n                                                           errstr, errstr_size);\n\n\t\t\t\tif (prop->type == _RK_C_S2F) {\n\t\t\t\t\t/* Flags: OR it in: do next */\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t/* Single assignment */\n\t\t\t\t\treturn RD_KAFKA_CONF_OK;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* S2F: Good match: continue with next */\n\t\t\tif (j < (int)RD_ARRAYSIZE(prop->s2i))\n\t\t\t\tcontinue;\n\n\t\t\t/* No match */\n\t\t\trd_snprintf(errstr, errstr_size,\n                                \"Invalid value \\\"%.*s\\\" for \"\n                                \"configuration property \\\"%s\\\"\",\n                                (int)(t-s), s, prop->name);\n\t\t\treturn RD_KAFKA_CONF_INVALID;\n\n\t\t}\n\t\treturn RD_KAFKA_CONF_OK;\n\t}\n\n        case _RK_C_INTERNAL:\n                rd_snprintf(errstr, errstr_size,\n                            \"Internal property \\\"%s\\\" not settable\",\n                            prop->name);\n                return RD_KAFKA_CONF_INVALID;\n\n        case _RK_C_INVALID:\n                rd_snprintf(errstr, errstr_size, \"%s\", prop->desc);\n                return RD_KAFKA_CONF_INVALID;\n\n\tdefault:\n                rd_kafka_assert(NULL, !*\"unknown conf type\");\n\t}\n\n\t/* not reachable */\n\treturn RD_KAFKA_CONF_INVALID;\n}\n\n\n\nstatic void rd_kafka_defaultconf_set (int scope, void *conf) {\n\tconst struct rd_kafka_property *prop;\n\n\tfor (prop = rd_kafka_properties ; prop->name ; prop++) {\n\t\tif (!(prop->scope & scope))\n\t\t\tcontinue;\n\n\t\tif (prop->type == _RK_C_ALIAS || prop->type == _RK_C_INVALID)\n\t\t\tcontinue;\n\n                if (prop->ctor)\n                        prop->ctor(scope, conf);\n\n                if (prop->sdef || prop->vdef || prop->pdef ||\n                    !rd_dbl_zero(prop->ddef))\n\t\t\trd_kafka_anyconf_set_prop0(scope, conf, prop,\n\t\t\t\t\t\t   prop->sdef ?\n                                                   prop->sdef : prop->pdef,\n                                                   prop->vdef,\n                                                   _RK_CONF_PROP_SET_REPLACE,\n                                                   NULL, 0);\n\t}\n}\n\nrd_kafka_conf_t *rd_kafka_conf_new (void) {\n\trd_kafka_conf_t *conf = rd_calloc(1, sizeof(*conf));\n        rd_assert(RD_KAFKA_CONF_PROPS_IDX_MAX > sizeof(*conf) &&\n                  *\"Increase RD_KAFKA_CONF_PROPS_IDX_MAX\");\n\trd_kafka_defaultconf_set(_RK_GLOBAL, conf);\n        rd_kafka_anyconf_clear_all_is_modified(conf);\n\treturn conf;\n}\n\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_new (void) {\n\trd_kafka_topic_conf_t *tconf = rd_calloc(1, sizeof(*tconf));\n        rd_assert(RD_KAFKA_CONF_PROPS_IDX_MAX > sizeof(*tconf) &&\n                  *\"Increase RD_KAFKA_CONF_PROPS_IDX_MAX\");\n\trd_kafka_defaultconf_set(_RK_TOPIC, tconf);\n        rd_kafka_anyconf_clear_all_is_modified(tconf);\n\treturn tconf;\n}\n\n\nstatic int rd_kafka_anyconf_set (int scope, void *conf,\n                                 const char *name, const char *value,\n                                 char *errstr, size_t errstr_size) {\n\tchar estmp[1];\n\tconst struct rd_kafka_property *prop;\n        rd_kafka_conf_res_t res;\n\n\tif (!errstr) {\n\t\terrstr = estmp;\n\t\terrstr_size = 0;\n\t}\n\n\tif (value && !*value)\n\t\tvalue = NULL;\n\n        /* Try interceptors first (only for GLOBAL config for now) */\n        if (scope & _RK_GLOBAL) {\n                res = rd_kafka_interceptors_on_conf_set(\n                        (rd_kafka_conf_t *)conf, name, value,\n                        errstr, errstr_size);\n                /* Handled (successfully or not) by interceptor. */\n                if (res != RD_KAFKA_CONF_UNKNOWN)\n                        return res;\n        }\n\n        /* Then global config */\n\n\n\tfor (prop = rd_kafka_properties ; prop->name ; prop++) {\n\n\t\tif (!(prop->scope & scope))\n\t\t\tcontinue;\n\n\t\tif (strcmp(prop->name, name))\n\t\t\tcontinue;\n\n\t\tif (prop->type == _RK_C_ALIAS)\n\t\t\treturn rd_kafka_anyconf_set(scope, conf,\n\t\t\t\t\t\t    prop->sdef, value,\n\t\t\t\t\t\t    errstr, errstr_size);\n\n                return rd_kafka_anyconf_set_prop(scope, conf, prop, value,\n                                                 0/*don't allow specifics*/,\n                                                 errstr, errstr_size);\n\t}\n\n\trd_snprintf(errstr, errstr_size,\n\t\t \"No such configuration property: \\\"%s\\\"\", name);\n\n\treturn RD_KAFKA_CONF_UNKNOWN;\n}\n\n\n/**\n * @brief Set a rd_kafka_*_conf_set_...() specific property, such as\n *        rd_kafka_conf_set_error_cb().\n *\n * @warning Will not call interceptor's on_conf_set.\n * @warning Asserts if \\p name is not known or value is incorrect.\n *\n * Implemented as a macro to have rd_assert() print the original function.\n */\n\n#define rd_kafka_anyconf_set_internal(SCOPE,CONF,NAME,VALUE) do {       \\\n        const struct rd_kafka_property *_prop;                          \\\n        rd_kafka_conf_res_t _res;                                       \\\n        _prop = rd_kafka_conf_prop_find(SCOPE, NAME);                   \\\n        rd_assert(_prop && *\"invalid property name\");                   \\\n        _res = rd_kafka_anyconf_set_prop(SCOPE, CONF, _prop,            \\\n                                         (const void *)VALUE,           \\\n                                         1/*allow-specifics*/,          \\\n                                         NULL, 0);                      \\\n        rd_assert(_res == RD_KAFKA_CONF_OK);                            \\\n        } while (0)\n\n\nrd_kafka_conf_res_t rd_kafka_conf_set (rd_kafka_conf_t *conf,\n                                       const char *name,\n                                       const char *value,\n                                       char *errstr, size_t errstr_size) {\n        rd_kafka_conf_res_t res;\n\n        res = rd_kafka_anyconf_set(_RK_GLOBAL, conf, name, value,\n                                   errstr, errstr_size);\n        if (res != RD_KAFKA_CONF_UNKNOWN)\n                return res;\n\n        /* Fallthru:\n         * If the global property was unknown, try setting it on the\n         * default topic config. */\n        if (!conf->topic_conf) {\n                /* Create topic config, might be over-written by application\n                 * later. */\n                rd_kafka_conf_set_default_topic_conf(conf,\n                                                     rd_kafka_topic_conf_new());\n        }\n\n        return rd_kafka_topic_conf_set(conf->topic_conf, name, value,\n                                       errstr, errstr_size);\n}\n\n\nrd_kafka_conf_res_t rd_kafka_topic_conf_set (rd_kafka_topic_conf_t *conf,\n\t\t\t\t\t     const char *name,\n\t\t\t\t\t     const char *value,\n\t\t\t\t\t     char *errstr, size_t errstr_size) {\n\tif (!strncmp(name, \"topic.\", strlen(\"topic.\")))\n\t\tname += strlen(\"topic.\");\n\n\treturn rd_kafka_anyconf_set(_RK_TOPIC, conf, name, value,\n\t\t\t\t    errstr, errstr_size);\n}\n\n\n/**\n * @brief Overwrites the contents of \\p str up until but not including\n *        the nul-term.\n */\nvoid rd_kafka_desensitize_str (char *str) {\n        size_t len;\n        static const char redacted[] = \"(REDACTED)\";\n\n#ifdef _MSC_VER\n        len = strlen(str);\n        SecureZeroMemory(str, len);\n#else\n        volatile char *volatile s;\n\n        for (s = str ; *s ; s++)\n                *s = '\\0';\n\n        len = (size_t)(s - str);\n#endif\n\n        if (len > sizeof(redacted))\n                memcpy(str, redacted, sizeof(redacted));\n}\n\n\n\n\n/**\n * @brief Overwrite the value of \\p prop, if sensitive.\n */\nstatic RD_INLINE void\nrd_kafka_anyconf_prop_desensitize (int scope, void *conf,\n                                   const struct rd_kafka_property *prop) {\n        if (likely(!(prop->scope & _RK_SENSITIVE)))\n                return;\n\n        switch (prop->type)\n        {\n        case _RK_C_STR:\n        {\n                char **str = _RK_PTR(char **, conf, prop->offset);\n                if (*str)\n                        rd_kafka_desensitize_str(*str);\n                break;\n        }\n\n        default:\n                rd_assert(!*\"BUG: Don't know how to desensitize prop type\");\n                break;\n        }\n}\n\n\n/**\n * @brief Desensitize all sensitive properties in \\p conf\n */\nstatic void rd_kafka_anyconf_desensitize (int scope, void *conf) {\n        const struct rd_kafka_property *prop;\n\n        for (prop = rd_kafka_properties; prop->name ; prop++) {\n                if (!(prop->scope & scope))\n                        continue;\n\n                rd_kafka_anyconf_prop_desensitize(scope, conf, prop);\n        }\n}\n\n/**\n * @brief Overwrite the values of sensitive properties\n */\nvoid rd_kafka_conf_desensitize (rd_kafka_conf_t *conf) {\n        if (conf->topic_conf)\n                rd_kafka_anyconf_desensitize(_RK_TOPIC,\n                                             conf->topic_conf);\n        rd_kafka_anyconf_desensitize(_RK_GLOBAL, conf);\n}\n\n/**\n * @brief Overwrite the values of sensitive properties\n */\nvoid rd_kafka_topic_conf_desensitize (rd_kafka_topic_conf_t *tconf) {\n        rd_kafka_anyconf_desensitize(_RK_TOPIC, tconf);\n}\n\n\nstatic void rd_kafka_anyconf_clear (int scope, void *conf,\n\t\t\t\t    const struct rd_kafka_property *prop) {\n\n        rd_kafka_anyconf_prop_desensitize(scope, conf, prop);\n\n\tswitch (prop->type)\n\t{\n\tcase _RK_C_STR:\n\t{\n\t\tchar **str = _RK_PTR(char **, conf, prop->offset);\n\n\t\tif (*str) {\n                        if (prop->set) {\n                                prop->set(scope, conf, prop->name, NULL, *str,\n                                          _RK_CONF_PROP_SET_DEL, NULL, 0);\n                                /* FALLTHRU */\n                        }\n                        rd_free(*str);\n\t\t\t*str = NULL;\n\t\t}\n\t}\n\tbreak;\n\n        case _RK_C_KSTR:\n        {\n                rd_kafkap_str_t **kstr = _RK_PTR(rd_kafkap_str_t **, conf,\n                                                 prop->offset);\n                if (*kstr) {\n                        rd_kafkap_str_destroy(*kstr);\n                        *kstr = NULL;\n                }\n        }\n        break;\n\n        case _RK_C_PATLIST:\n        {\n                rd_kafka_pattern_list_t **plist;\n                plist = _RK_PTR(rd_kafka_pattern_list_t **, conf, prop->offset);\n\t\tif (*plist) {\n\t\t\trd_kafka_pattern_list_destroy(*plist);\n\t\t\t*plist = NULL;\n\t\t}\n        }\n        break;\n\n        case _RK_C_PTR:\n                if (_RK_PTR(void *, conf, prop->offset) != NULL) {\n                        if (!strcmp(prop->name, \"default_topic_conf\")) {\n                                rd_kafka_topic_conf_t **tconf;\n\n                                tconf = _RK_PTR(rd_kafka_topic_conf_t **,\n                                                conf, prop->offset);\n                                if (*tconf) {\n                                        rd_kafka_topic_conf_destroy(*tconf);\n                                        *tconf = NULL;\n                                }\n                        }\n                }\n                break;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n        if (prop->dtor)\n                prop->dtor(scope, conf);\n\n}\n\nvoid rd_kafka_anyconf_destroy (int scope, void *conf) {\n\tconst struct rd_kafka_property *prop;\n\n        /* Call on_conf_destroy() interceptors */\n        if (scope == _RK_GLOBAL)\n                rd_kafka_interceptors_on_conf_destroy(conf);\n\n\tfor (prop = rd_kafka_properties; prop->name ; prop++) {\n\t\tif (!(prop->scope & scope))\n\t\t\tcontinue;\n\n\t\trd_kafka_anyconf_clear(scope, conf, prop);\n\t}\n}\n\n\nvoid rd_kafka_conf_destroy (rd_kafka_conf_t *conf) {\n\trd_kafka_anyconf_destroy(_RK_GLOBAL, conf);\n        //FIXME: partition_assignors\n\trd_free(conf);\n}\n\nvoid rd_kafka_topic_conf_destroy (rd_kafka_topic_conf_t *topic_conf) {\n\trd_kafka_anyconf_destroy(_RK_TOPIC, topic_conf);\n\trd_free(topic_conf);\n}\n\n\n\nstatic void rd_kafka_anyconf_copy (int scope, void *dst, const void *src,\n                                   size_t filter_cnt, const char **filter) {\n\tconst struct rd_kafka_property *prop;\n\n\tfor (prop = rd_kafka_properties ; prop->name ; prop++) {\n\t\tconst char *val = NULL;\n\t\tint ival = 0;\n                char *valstr;\n                size_t valsz;\n                size_t fi;\n                size_t nlen;\n\n\t\tif (!(prop->scope & scope))\n\t\t\tcontinue;\n\n\t\tif (prop->type == _RK_C_ALIAS || prop->type == _RK_C_INVALID)\n\t\t\tcontinue;\n\n                /* Skip properties that have not been set,\n                 * unless it is an internal one which requires\n                 * extra logic, such as the interceptors. */\n                if (!rd_kafka_anyconf_is_modified(src, prop) &&\n                    prop->type != _RK_C_INTERNAL)\n                        continue;\n\n                /* Apply filter, if any. */\n                nlen = strlen(prop->name);\n                for (fi = 0 ; fi < filter_cnt ; fi++) {\n                        size_t flen = strlen(filter[fi]);\n                        if (nlen >= flen &&\n                            !strncmp(filter[fi], prop->name, flen))\n                                break;\n                }\n                if (fi < filter_cnt)\n                        continue; /* Filter matched */\n\n\t\tswitch (prop->type)\n\t\t{\n\t\tcase _RK_C_STR:\n\t\tcase _RK_C_PTR:\n\t\t\tval = *_RK_PTR(const char **, src, prop->offset);\n\n                        if (!strcmp(prop->name, \"default_topic_conf\") && val)\n                                val = (void *)rd_kafka_topic_conf_dup(\n                                        (const rd_kafka_topic_conf_t *)\n                                        (void *)val);\n\t\t\tbreak;\n                case _RK_C_KSTR:\n                {\n                        rd_kafkap_str_t **kstr = _RK_PTR(rd_kafkap_str_t **,\n                                                         src, prop->offset);\n                        if (*kstr)\n                                val = (*kstr)->str;\n                        break;\n                }\n\n\t\tcase _RK_C_BOOL:\n\t\tcase _RK_C_INT:\n\t\tcase _RK_C_S2I:\n\t\tcase _RK_C_S2F:\n\t\t\tival = *_RK_PTR(const int *, src, prop->offset);\n\n                        /* Get string representation of configuration value. */\n                        valsz = 0;\n                        rd_kafka_anyconf_get0(src, prop, NULL, &valsz);\n                        valstr = rd_alloca(valsz);\n                        rd_kafka_anyconf_get0(src, prop, valstr, &valsz);\n                        val = valstr;\n\t\t\tbreak;\n                case _RK_C_DBL:\n                        /* Get string representation of configuration value. */\n                        valsz = 0;\n                        rd_kafka_anyconf_get0(src, prop, NULL, &valsz);\n                        valstr = rd_alloca(valsz);\n                        rd_kafka_anyconf_get0(src, prop, valstr, &valsz);\n                        val = valstr;\n                        break;\n                case _RK_C_PATLIST:\n                {\n                        const rd_kafka_pattern_list_t **plist;\n                        plist = _RK_PTR(const rd_kafka_pattern_list_t **,\n                                        src, prop->offset);\n\t\t\tif (*plist)\n\t\t\t\tval = (*plist)->rkpl_orig;\n                        break;\n                }\n                case _RK_C_INTERNAL:\n                        /* Handled by ->copy() below. */\n                        break;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\n                if (prop->copy)\n                        prop->copy(scope, dst, src,\n                                   _RK_PTR(void *, dst, prop->offset),\n                                   _RK_PTR(const void *, src, prop->offset),\n                                   filter_cnt, filter);\n\n                rd_kafka_anyconf_set_prop0(scope, dst, prop, val, ival,\n                                           _RK_CONF_PROP_SET_REPLACE, NULL, 0);\n\t}\n}\n\n\nrd_kafka_conf_t *rd_kafka_conf_dup (const rd_kafka_conf_t *conf) {\n\trd_kafka_conf_t *new = rd_kafka_conf_new();\n\n        rd_kafka_interceptors_on_conf_dup(new, conf, 0, NULL);\n\n        rd_kafka_anyconf_copy(_RK_GLOBAL, new, conf, 0, NULL);\n\n\treturn new;\n}\n\nrd_kafka_conf_t *rd_kafka_conf_dup_filter (const rd_kafka_conf_t *conf,\n                                           size_t filter_cnt,\n                                           const char **filter) {\n\trd_kafka_conf_t *new = rd_kafka_conf_new();\n\n        rd_kafka_interceptors_on_conf_dup(new, conf, filter_cnt, filter);\n\n        rd_kafka_anyconf_copy(_RK_GLOBAL, new, conf, filter_cnt, filter);\n\n\treturn new;\n}\n\n\nrd_kafka_topic_conf_t *rd_kafka_topic_conf_dup (const rd_kafka_topic_conf_t\n\t\t\t\t\t\t*conf) {\n\trd_kafka_topic_conf_t *new = rd_kafka_topic_conf_new();\n\n\trd_kafka_anyconf_copy(_RK_TOPIC, new, conf, 0, NULL);\n\n\treturn new;\n}\n\nrd_kafka_topic_conf_t *rd_kafka_default_topic_conf_dup (rd_kafka_t *rk) {\n        if (rk->rk_conf.topic_conf)\n                return rd_kafka_topic_conf_dup(rk->rk_conf.topic_conf);\n        else\n                return rd_kafka_topic_conf_new();\n}\n\nvoid rd_kafka_conf_set_events (rd_kafka_conf_t *conf, int events) {\n        char tmp[32];\n        rd_snprintf(tmp, sizeof(tmp), \"%d\", events);\n        rd_kafka_anyconf_set_internal(_RK_GLOBAL, conf, \"enabled_events\", tmp);\n}\n\nvoid\nrd_kafka_conf_set_background_event_cb (rd_kafka_conf_t *conf,\n                                       void (*event_cb) (rd_kafka_t *rk,\n                                                         rd_kafka_event_t *rkev,\n                                                         void *opaque)) {\n        rd_kafka_anyconf_set_internal(_RK_GLOBAL, conf, \"background_event_cb\",\n                                      event_cb);\n}\n\n\nvoid rd_kafka_conf_set_dr_cb (rd_kafka_conf_t *conf,\n\t\t\t      void (*dr_cb) (rd_kafka_t *rk,\n\t\t\t\t\t     void *payload, size_t len,\n\t\t\t\t\t     rd_kafka_resp_err_t err,\n\t\t\t\t\t     void *opaque, void *msg_opaque)) {\n        rd_kafka_anyconf_set_internal(_RK_GLOBAL, conf, \"dr_cb\", dr_cb);\n}\n\n\nvoid rd_kafka_conf_set_dr_msg_cb (rd_kafka_conf_t *conf,\n                                  void (*dr_msg_cb) (rd_kafka_t *rk,\n                                                     const rd_kafka_message_t *\n                                                     rkmessage,\n                                                     void *opaque)) {\n        rd_kafka_anyconf_set_internal(_RK_GLOBAL, conf, \"dr_msg_cb\", dr_msg_cb);\n}\n\n\nvoid rd_kafka_conf_set_consume_cb (rd_kafka_conf_t *conf,\n                                   void (*consume_cb) (rd_kafka_message_t *\n                                                       rkmessage,\n                                                       void *opaque)) {\n        rd_kafka_anyconf_set_internal(_RK_GLOBAL, conf, \"consume_cb\",\n                                      consume_cb);\n}\n\nvoid rd_kafka_conf_set_rebalance_cb (\n        rd_kafka_conf_t *conf,\n        void (*rebalance_cb) (rd_kafka_t *rk,\n                              rd_kafka_resp_err_t err,\n                              rd_kafka_topic_partition_list_t *partitions,\n                              void *opaque)) {\n        rd_kafka_anyconf_set_internal(_RK_GLOBAL, conf, \"rebalance_cb\",\n                                      rebalance_cb);\n}\n\nvoid rd_kafka_conf_set_offset_commit_cb (\n        rd_kafka_conf_t *conf,\n        void (*offset_commit_cb) (rd_kafka_t *rk,\n                                  rd_kafka_resp_err_t err,\n                                  rd_kafka_topic_partition_list_t *offsets,\n                                  void *opaque)) {\n        rd_kafka_anyconf_set_internal(_RK_GLOBAL, conf, \"offset_commit_cb\",\n                                      offset_commit_cb);\n}\n\n\n\nvoid rd_kafka_conf_set_error_cb (rd_kafka_conf_t *conf,\n\t\t\t\t void  (*error_cb) (rd_kafka_t *rk, int err,\n\t\t\t\t\t\t    const char *reason,\n\t\t\t\t\t\t    void *opaque)) {\n        rd_kafka_anyconf_set_internal(_RK_GLOBAL, conf, \"error_cb\", error_cb);\n}\n\n\nvoid rd_kafka_conf_set_throttle_cb (rd_kafka_conf_t *conf,\n\t\t\t\t    void (*throttle_cb) (\n\t\t\t\t\t    rd_kafka_t *rk,\n\t\t\t\t\t    const char *broker_name,\n\t\t\t\t\t    int32_t broker_id,\n\t\t\t\t\t    int throttle_time_ms,\n\t\t\t\t\t    void *opaque)) {\n        rd_kafka_anyconf_set_internal(_RK_GLOBAL, conf, \"throttle_cb\",\n                                      throttle_cb);\n}\n\n\nvoid rd_kafka_conf_set_log_cb (rd_kafka_conf_t *conf,\n\t\t\t  void (*log_cb) (const rd_kafka_t *rk, int level,\n                                          const char *fac, const char *buf)) {\n#if !WITH_SYSLOG\n        if (log_cb == rd_kafka_log_syslog)\n                rd_assert(!*\"syslog support not enabled in this build\");\n#endif\n        rd_kafka_anyconf_set_internal(_RK_GLOBAL, conf, \"log_cb\", log_cb);\n}\n\n\nvoid rd_kafka_conf_set_stats_cb (rd_kafka_conf_t *conf,\n\t\t\t\t int (*stats_cb) (rd_kafka_t *rk,\n\t\t\t\t\t\t  char *json,\n\t\t\t\t\t\t  size_t json_len,\n\t\t\t\t\t\t  void *opaque)) {\n        rd_kafka_anyconf_set_internal(_RK_GLOBAL, conf, \"stats_cb\", stats_cb);\n}\n\nvoid rd_kafka_conf_set_oauthbearer_token_refresh_cb(rd_kafka_conf_t *conf,\n                void (*oauthbearer_token_refresh_cb) (\n                        rd_kafka_t *rk,\n                        const char *oauthbearer_config,\n                        void *opaque)) {\n#if WITH_SASL_OAUTHBEARER\n        rd_kafka_anyconf_set_internal(_RK_GLOBAL, conf,\n                \"oauthbearer_token_refresh_cb\", oauthbearer_token_refresh_cb);\n#endif\n}\n\nvoid rd_kafka_conf_set_socket_cb (rd_kafka_conf_t *conf,\n                                  int (*socket_cb) (int domain, int type,\n                                                    int protocol,\n                                                    void *opaque)) {\n        rd_kafka_anyconf_set_internal(_RK_GLOBAL, conf, \"socket_cb\",\n                                      socket_cb);\n}\n\nvoid\nrd_kafka_conf_set_connect_cb (rd_kafka_conf_t *conf,\n                              int (*connect_cb) (int sockfd,\n                                                 const struct sockaddr *addr,\n                                                 int addrlen,\n                                                 const char *id,\n                                                 void *opaque)) {\n        rd_kafka_anyconf_set_internal(_RK_GLOBAL, conf, \"connect_cb\",\n                                      connect_cb);\n}\n\nvoid\nrd_kafka_conf_set_closesocket_cb (rd_kafka_conf_t *conf,\n                                  int (*closesocket_cb) (int sockfd,\n                                                         void *opaque)) {\n        rd_kafka_anyconf_set_internal(_RK_GLOBAL, conf, \"closesocket_cb\",\n                                      closesocket_cb);\n}\n\n\n\n#ifndef _MSC_VER\nvoid rd_kafka_conf_set_open_cb (rd_kafka_conf_t *conf,\n                                int (*open_cb) (const char *pathname,\n                                                int flags, mode_t mode,\n                                                void *opaque)) {\n        rd_kafka_anyconf_set_internal(_RK_GLOBAL, conf, \"open_cb\", open_cb);\n}\n#endif\n\n\nrd_kafka_conf_res_t\nrd_kafka_conf_set_ssl_cert_verify_cb (\n        rd_kafka_conf_t *conf,\n        int (*ssl_cert_verify_cb) (rd_kafka_t *rk,\n                                   const char *broker_name,\n                                   int32_t broker_id,\n                                   int *x509_set_error,\n                                   int depth,\n                                   const char *buf, size_t size,\n                                   char *errstr, size_t errstr_size,\n                                   void *opaque)) {\n#if !WITH_SSL\n        return RD_KAFKA_CONF_INVALID;\n#else\n        rd_kafka_anyconf_set_internal(_RK_GLOBAL, conf,\n                                      \"ssl.certificate.verify_cb\",\n                                      ssl_cert_verify_cb);\n        return RD_KAFKA_CONF_OK;\n#endif\n}\n\n\nvoid rd_kafka_conf_set_opaque (rd_kafka_conf_t *conf, void *opaque) {\n        rd_kafka_anyconf_set_internal(_RK_GLOBAL, conf, \"opaque\", opaque);\n}\n\n\nvoid rd_kafka_conf_set_default_topic_conf (rd_kafka_conf_t *conf,\n                                           rd_kafka_topic_conf_t *tconf) {\n        if (conf->topic_conf)\n                rd_kafka_topic_conf_destroy(conf->topic_conf);\n\n        rd_kafka_anyconf_set_internal(_RK_GLOBAL, conf, \"default_topic_conf\",\n                                      tconf);\n}\n\n\nvoid\nrd_kafka_topic_conf_set_partitioner_cb (rd_kafka_topic_conf_t *topic_conf,\n\t\t\t\t\tint32_t (*partitioner) (\n\t\t\t\t\t\tconst rd_kafka_topic_t *rkt,\n\t\t\t\t\t\tconst void *keydata,\n\t\t\t\t\t\tsize_t keylen,\n\t\t\t\t\t\tint32_t partition_cnt,\n\t\t\t\t\t\tvoid *rkt_opaque,\n\t\t\t\t\t\tvoid *msg_opaque)) {\n        rd_kafka_anyconf_set_internal(_RK_TOPIC, topic_conf, \"partitioner_cb\",\n                                      partitioner);\n}\n\nvoid\nrd_kafka_topic_conf_set_msg_order_cmp (rd_kafka_topic_conf_t *topic_conf,\n                                       int (*msg_order_cmp) (\n                                               const rd_kafka_message_t *a,\n                                               const rd_kafka_message_t *b)) {\n        rd_kafka_anyconf_set_internal(_RK_TOPIC, topic_conf, \"msg_order_cmp\",\n                                      msg_order_cmp);\n}\n\nvoid rd_kafka_topic_conf_set_opaque (rd_kafka_topic_conf_t *topic_conf,\n\t\t\t\t     void *opaque) {\n        rd_kafka_anyconf_set_internal(_RK_TOPIC, topic_conf, \"opaque\", opaque);\n}\n\n\n\n\n/**\n * @brief Convert flags \\p ival to csv-string using S2F property \\p prop.\n *\n * This function has two modes: size query and write.\n * To query for needed size call with dest==NULL,\n * to write to buffer of size dest_size call with dest!=NULL.\n *\n * An \\p ival of -1 means all.\n *\n * @returns the number of bytes written to \\p dest (if not NULL), else the\n *          total number of bytes needed.\n *\n */\nsize_t rd_kafka_conf_flags2str (char *dest, size_t dest_size, const char *delim,\n\t\t\t\tconst struct rd_kafka_property *prop,\n\t\t\t\tint ival) {\n\tsize_t of = 0;\n\tint j;\n\n\tif (dest && dest_size > 0)\n\t\t*dest = '\\0';\n\n\t/* Phase 1: scan for set flags, accumulate needed size.\n\t * Phase 2: write to dest */\n\tfor (j = 0 ; prop->s2i[j].str ; j++) {\n\t\tif (prop->type == _RK_C_S2F && ival != -1 &&\n\t\t    (ival & prop->s2i[j].val) != prop->s2i[j].val)\n\t\t\tcontinue;\n\t\telse if (prop->type == _RK_C_S2I &&\n\t\t\t   ival != -1 && prop->s2i[j].val != ival)\n\t\t\tcontinue;\n\n\t\tif (!dest)\n\t\t\tof += strlen(prop->s2i[j].str) + (of > 0 ? 1 : 0);\n\t\telse {\n\t\t\tsize_t r;\n\t\t\tr = rd_snprintf(dest+of, dest_size-of,\n\t\t\t\t\t\"%s%s\",\n\t\t\t\t\tof > 0 ? delim:\"\",\n\t\t\t\t\tprop->s2i[j].str);\n\t\t\tif (r > dest_size-of) {\n\t\t\t\tr = dest_size-of;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tof += r;\n\t\t}\n\t}\n\n\treturn of+1/*nul*/;\n}\n\n\n/**\n * Return \"original\"(re-created) configuration value string\n */\nstatic rd_kafka_conf_res_t\nrd_kafka_anyconf_get0 (const void *conf, const struct rd_kafka_property *prop,\n                       char *dest, size_t *dest_size) {\n        char tmp[22];\n        const char *val = NULL;\n        size_t val_len = 0;\n        int j;\n\n        switch (prop->type)\n        {\n        case _RK_C_STR:\n                val = *_RK_PTR(const char **, conf, prop->offset);\n                break;\n\n        case _RK_C_KSTR:\n        {\n                const rd_kafkap_str_t **kstr = _RK_PTR(const rd_kafkap_str_t **,\n                                                       conf, prop->offset);\n                if (*kstr)\n                        val = (*kstr)->str;\n                break;\n        }\n\n        case _RK_C_PTR:\n                val = *_RK_PTR(const void **, conf, prop->offset);\n                if (val) {\n                        rd_snprintf(tmp, sizeof(tmp), \"%p\", (void *)val);\n                        val = tmp;\n                }\n                break;\n\n        case _RK_C_BOOL:\n                val = (*_RK_PTR(int *, conf, prop->offset) ? \"true\" : \"false\");\n                break;\n\n        case _RK_C_INT:\n                rd_snprintf(tmp, sizeof(tmp), \"%i\",\n                            *_RK_PTR(int *, conf, prop->offset));\n                val = tmp;\n                break;\n\n        case _RK_C_DBL:\n                rd_snprintf(tmp, sizeof(tmp), \"%g\",\n                            *_RK_PTR(double *, conf, prop->offset));\n                val = tmp;\n                break;\n\n        case _RK_C_S2I:\n                for (j = 0 ; j < (int)RD_ARRAYSIZE(prop->s2i); j++) {\n                        if (prop->s2i[j].val ==\n                            *_RK_PTR(int *, conf, prop->offset)) {\n                                val = prop->s2i[j].str;\n                                break;\n                        }\n                }\n                break;\n\n        case _RK_C_S2F:\n        {\n                const int ival = *_RK_PTR(const int *, conf, prop->offset);\n\n\t\tval_len = rd_kafka_conf_flags2str(dest,\n                                                  dest ? *dest_size : 0, \",\",\n\t\t\t\t\t\t  prop, ival);\n\t\tif (dest) {\n\t\t\tval_len = 0;\n\t\t\tval = dest;\n\t\t\tdest = NULL;\n\t\t}\n\t\tbreak;\n\t}\n\n        case _RK_C_PATLIST:\n        {\n                const rd_kafka_pattern_list_t **plist;\n                plist = _RK_PTR(const rd_kafka_pattern_list_t **,\n                                conf, prop->offset);\n\t\tif (*plist)\n\t\t\tval = (*plist)->rkpl_orig;\n                break;\n        }\n\n        default:\n                break;\n        }\n\n        if (val_len) {\n                *dest_size = val_len+1;\n                return RD_KAFKA_CONF_OK;\n        }\n\n        if (!val)\n                return RD_KAFKA_CONF_INVALID;\n\n        val_len = strlen(val);\n\n        if (dest) {\n                size_t use_len = RD_MIN(val_len, (*dest_size)-1);\n                memcpy(dest, val, use_len);\n                dest[use_len] = '\\0';\n        }\n\n        /* Return needed size */\n        *dest_size = val_len+1;\n\n        return RD_KAFKA_CONF_OK;\n}\n\n\nstatic rd_kafka_conf_res_t rd_kafka_anyconf_get (int scope, const void *conf,\n                                                 const char *name,\n                                                 char *dest, size_t *dest_size){\n\tconst struct rd_kafka_property *prop;\n\n\tfor (prop = rd_kafka_properties; prop->name ; prop++) {\n\n\t\tif (!(prop->scope & scope) || strcmp(prop->name, name))\n\t\t\tcontinue;\n\n\t\tif (prop->type == _RK_C_ALIAS)\n\t\t\treturn rd_kafka_anyconf_get(scope, conf,\n\t\t\t\t\t\t    prop->sdef,\n\t\t\t\t\t\t    dest, dest_size);\n\n                if (rd_kafka_anyconf_get0(conf, prop, dest, dest_size) ==\n                    RD_KAFKA_CONF_OK)\n                        return RD_KAFKA_CONF_OK;\n        }\n\n        return RD_KAFKA_CONF_UNKNOWN;\n}\n\nrd_kafka_conf_res_t rd_kafka_topic_conf_get (const rd_kafka_topic_conf_t *conf,\n                                             const char *name,\n                                             char *dest, size_t *dest_size) {\n        return rd_kafka_anyconf_get(_RK_TOPIC, conf, name, dest, dest_size);\n}\n\nrd_kafka_conf_res_t rd_kafka_conf_get (const rd_kafka_conf_t *conf,\n                                       const char *name,\n                                       char *dest, size_t *dest_size) {\n        rd_kafka_conf_res_t res;\n        res = rd_kafka_anyconf_get(_RK_GLOBAL, conf, name, dest, dest_size);\n        if (res != RD_KAFKA_CONF_UNKNOWN || !conf->topic_conf)\n                return res;\n\n        /* Fallthru:\n         * If the global property was unknown, try getting it from the\n         * default topic config, if any. */\n        return rd_kafka_topic_conf_get(conf->topic_conf, name, dest, dest_size);\n}\n\n\nstatic const char **rd_kafka_anyconf_dump (int scope, const void *conf,\n\t\t\t\t\t   size_t *cntp) {\n\tconst struct rd_kafka_property *prop;\n\tchar **arr;\n\tint cnt = 0;\n\n\tarr = rd_calloc(sizeof(char *), RD_ARRAYSIZE(rd_kafka_properties)*2);\n\n\tfor (prop = rd_kafka_properties; prop->name ; prop++) {\n                char *val = NULL;\n                size_t val_size;\n\n\t\tif (!(prop->scope & scope))\n\t\t\tcontinue;\n\n\t\t/* Skip aliases, show original property instead.\n                 * Skip invalids. */\n\t\tif (prop->type == _RK_C_ALIAS || prop->type == _RK_C_INVALID)\n\t\t\tcontinue;\n\n                /* Query value size */\n                if (rd_kafka_anyconf_get0(conf, prop, NULL, &val_size) !=\n                    RD_KAFKA_CONF_OK)\n                        continue;\n\n                /* Get value */\n                val = malloc(val_size);\n                rd_kafka_anyconf_get0(conf, prop, val, &val_size);\n\n                arr[cnt++] = rd_strdup(prop->name);\n                arr[cnt++] = val;\n\t}\n\n\t*cntp = cnt;\n\n\treturn (const char **)arr;\n}\n\n\nconst char **rd_kafka_conf_dump (rd_kafka_conf_t *conf, size_t *cntp) {\n\treturn rd_kafka_anyconf_dump(_RK_GLOBAL, conf, cntp);\n}\n\nconst char **rd_kafka_topic_conf_dump (rd_kafka_topic_conf_t *conf,\n\t\t\t\t       size_t *cntp) {\n\treturn rd_kafka_anyconf_dump(_RK_TOPIC, conf, cntp);\n}\n\nvoid rd_kafka_conf_dump_free (const char **arr, size_t cnt) {\n\tchar **_arr = (char **)arr;\n\tunsigned int i;\n\n\tfor (i = 0 ; i < cnt ; i++)\n\t\tif (_arr[i])\n\t\t\trd_free(_arr[i]);\n\n\trd_free(_arr);\n}\n\nvoid rd_kafka_conf_properties_show (FILE *fp) {\n\tconst struct rd_kafka_property *prop0;\n\tint last = 0;\n\tint j;\n\tchar tmp[512];\n\tconst char *dash80 = \"----------------------------------------\"\n\t\t\"----------------------------------------\";\n\n\tfor (prop0 = rd_kafka_properties; prop0->name ; prop0++) {\n\t\tconst char *typeinfo = \"\";\n                const char *importance;\n                const struct rd_kafka_property *prop = prop0;\n\n                /* Skip hidden properties. */\n                if (prop->scope & _RK_HIDDEN)\n                        continue;\n\n                /* Skip invalid properties. */\n                if (prop->type == _RK_C_INVALID)\n                        continue;\n\n\t\tif (!(prop->scope & last)) {\n\t\t\tfprintf(fp,\n\t\t\t\t\"%s## %s configuration properties\\n\\n\",\n\t\t\t\tlast ? \"\\n\\n\":\"\",\n\t\t\t\tprop->scope == _RK_GLOBAL ? \"Global\": \"Topic\");\n\n\t\t\tfprintf(fp,\n\t\t\t\t\"%-40s | %3s | %-15s | %13s | %-10s | %-25s\\n\"\n\t\t\t\t\"%.*s-|-%.*s-|-%.*s-|-%.*s:|-%.*s-| -%.*s\\n\",\n\t\t\t\t\"Property\", \"C/P\", \"Range\",\n\t\t\t\t\"Default\", \"Importance\", \"Description\",\n\t\t\t\t40, dash80, 3, dash80, 15, dash80,\n\t\t\t\t13, dash80, 10, dash80, 25, dash80);\n\n\t\t\tlast = prop->scope & (_RK_GLOBAL|_RK_TOPIC);\n\n\t\t}\n\n\t\tfprintf(fp, \"%-40s | \", prop->name);\n\n                /* For aliases, use the aliased property from here on\n                 * so that the alias property shows up with proper\n                 * ranges, defaults, etc. */\n                if (prop->type == _RK_C_ALIAS) {\n                        prop = rd_kafka_conf_prop_find(prop->scope,\n                                                       prop->sdef);\n                        rd_assert(prop && *\"BUG: \"\n                                  \"alias points to unknown config property\");\n                }\n\n                fprintf(fp, \"%3s | \",\n                        (!(prop->scope & _RK_PRODUCER) ==\n                         !(prop->scope & _RK_CONSUMER) ? \" * \" :\n                         ((prop->scope & _RK_PRODUCER) ? \" P \" : \" C \")));\n\n\t\tswitch (prop->type)\n\t\t{\n\t\tcase _RK_C_STR:\n                case _RK_C_KSTR:\n\t\t\ttypeinfo = \"string\";\n                case _RK_C_PATLIST:\n\t\t\tif (prop->type == _RK_C_PATLIST)\n\t\t\t\ttypeinfo = \"pattern list\";\n\t\t\tif (prop->s2i[0].str) {\n\t\t\t\trd_kafka_conf_flags2str(tmp, sizeof(tmp), \", \",\n\t\t\t\t\t\t\tprop, -1);\n\t\t\t\tfprintf(fp, \"%-15s | %13s\",\n\t\t\t\t\ttmp, prop->sdef ? prop->sdef : \"\");\n\t\t\t} else {\n\t\t\t\tfprintf(fp, \"%-15s | %13s\",\n\t\t\t\t\t\"\", prop->sdef ? prop->sdef : \"\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase _RK_C_BOOL:\n\t\t\ttypeinfo = \"boolean\";\n\t\t\tfprintf(fp, \"%-15s | %13s\", \"true, false\",\n\t\t\t\tprop->vdef ? \"true\" : \"false\");\n\t\t\tbreak;\n\t\tcase _RK_C_INT:\n\t\t\ttypeinfo = \"integer\";\n\t\t\trd_snprintf(tmp, sizeof(tmp),\n\t\t\t\t    \"%d .. %d\", prop->vmin, prop->vmax);\n\t\t\tfprintf(fp, \"%-15s | %13i\", tmp, prop->vdef);\n\t\t\tbreak;\n                case _RK_C_DBL:\n                        typeinfo = \"float\"; /* more user-friendly than double */\n                        rd_snprintf(tmp, sizeof(tmp),\n                                    \"%g .. %g\", prop->dmin, prop->dmax);\n                        fprintf(fp, \"%-15s | %13g\", tmp, prop->ddef);\n                        break;\n\t\tcase _RK_C_S2I:\n\t\t\ttypeinfo = \"enum value\";\n\t\t\trd_kafka_conf_flags2str(tmp, sizeof(tmp), \", \",\n\t\t\t\t\t\tprop, -1);\n\t\t\tfprintf(fp, \"%-15s | \", tmp);\n\n\t\t\tfor (j = 0 ; j < (int)RD_ARRAYSIZE(prop->s2i); j++) {\n\t\t\t\tif (prop->s2i[j].val == prop->vdef) {\n\t\t\t\t\tfprintf(fp, \"%13s\", prop->s2i[j].str);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (j == RD_ARRAYSIZE(prop->s2i))\n\t\t\t\tfprintf(fp, \"%13s\", \" \");\n\t\t\tbreak;\n\n\t\tcase _RK_C_S2F:\n\t\t\ttypeinfo = \"CSV flags\";\n\t\t\t/* Dont duplicate builtin.features value in\n\t\t\t * both Range and Default */\n\t\t\tif (!strcmp(prop->name, \"builtin.features\"))\n\t\t\t\t*tmp = '\\0';\n\t\t\telse\n\t\t\t\trd_kafka_conf_flags2str(tmp, sizeof(tmp), \", \",\n\t\t\t\t\t\t\tprop, -1);\n\t\t\tfprintf(fp, \"%-15s | \", tmp);\n\t\t\trd_kafka_conf_flags2str(tmp, sizeof(tmp), \", \",\n\t\t\t\t\t\tprop, prop->vdef);\n\t\t\tfprintf(fp, \"%13s\", tmp);\n\n\t\t\tbreak;\n\t\tcase _RK_C_PTR:\n                case _RK_C_INTERNAL:\n                        typeinfo = \"see dedicated API\";\n                        /* FALLTHRU */\n\t\tdefault:\n\t\t\tfprintf(fp, \"%-15s | %-13s\", \"\", \" \");\n\t\t\tbreak;\n\t\t}\n\n                if (prop->scope & _RK_HIGH)\n                        importance = \"high\";\n                else if (prop->scope & _RK_MED)\n                        importance = \"medium\";\n                else\n                        importance = \"low\";\n\n                fprintf(fp, \" | %-10s | \", importance);\n\n                if (prop->scope & _RK_EXPERIMENTAL)\n                        fprintf(fp, \"**EXPERIMENTAL**: \"\n                                \"subject to change or removal. \");\n\n                if (prop->scope & _RK_DEPRECATED)\n                        fprintf(fp, \"**DEPRECATED** \");\n\n                /* If the original property is an alias, prefix the\n                 * description saying so. */\n                if (prop0->type == _RK_C_ALIAS)\n                        fprintf(fp, \"Alias for `%s`: \", prop0->sdef);\n\n                fprintf(fp, \"%s <br>*Type: %s*\\n\", prop->desc,\n                        typeinfo);\n        }\n        fprintf(fp, \"\\n\");\n        fprintf(fp, \"### C/P legend: C = Consumer, P = Producer, * = both\\n\");\n}\n\n\n\n\n/**\n * @name Configuration value methods\n *\n * @remark This generic interface will eventually replace the config property\n *         used above.\n * @{\n */\n\n\n/**\n * @brief Set up an INT confval.\n *\n * @oaram name Property name, must be a const static string (will not be copied)\n */\nvoid rd_kafka_confval_init_int (rd_kafka_confval_t *confval,\n                                const char *name,\n                                int vmin, int vmax, int vdef) {\n        confval->name = name;\n        confval->is_enabled = 1;\n        confval->valuetype = RD_KAFKA_CONFVAL_INT;\n        confval->u.INT.vmin = vmin;\n        confval->u.INT.vmax = vmax;\n        confval->u.INT.vdef = vdef;\n        confval->u.INT.v    = vdef;\n}\n\n/**\n * @brief Set up a PTR confval.\n *\n * @oaram name Property name, must be a const static string (will not be copied)\n */\nvoid rd_kafka_confval_init_ptr (rd_kafka_confval_t *confval,\n                                const char *name) {\n        confval->name = name;\n        confval->is_enabled = 1;\n        confval->valuetype = RD_KAFKA_CONFVAL_PTR;\n        confval->u.PTR = NULL;\n}\n\n/**\n * @brief Set up but disable an intval, attempt to set this confval will fail.\n *\n * @oaram name Property name, must be a const static string (will not be copied)\n */\nvoid rd_kafka_confval_disable (rd_kafka_confval_t *confval, const char *name) {\n        confval->name = name;\n        confval->is_enabled = 0;\n}\n\n/**\n * @brief Set confval's value to \\p valuep, verifying the passed\n *        \\p valuetype matches (or can be cast to) \\p confval's type.\n *\n * @param dispname is the display name for the configuration value and is\n *        included in error strings.\n * @param valuep is a pointer to the value, or NULL to revert to default.\n *\n * @returns RD_KAFKA_RESP_ERR_NO_ERROR if the new value was set, or\n *          RD_KAFKA_RESP_ERR__INVALID_ARG if the value was of incorrect type,\n *          out of range, or otherwise not a valid value.\n */\nrd_kafka_resp_err_t\nrd_kafka_confval_set_type (rd_kafka_confval_t *confval,\n                           rd_kafka_confval_type_t valuetype,\n                           const void *valuep,\n                           char *errstr, size_t errstr_size) {\n\n        if (!confval->is_enabled) {\n                rd_snprintf(errstr, errstr_size,\n                            \"\\\"%s\\\" is not supported for this operation\",\n                            confval->name);\n                return RD_KAFKA_RESP_ERR__INVALID_ARG;\n        }\n\n        switch (confval->valuetype)\n        {\n        case RD_KAFKA_CONFVAL_INT:\n        {\n                int v;\n                const char *end;\n\n                if (!valuep) {\n                        /* Revert to default */\n                        confval->u.INT.v = confval->u.INT.vdef;\n                        confval->is_set = 0;\n                        return RD_KAFKA_RESP_ERR_NO_ERROR;\n                }\n\n                switch (valuetype)\n                {\n                case RD_KAFKA_CONFVAL_INT:\n                        v = *(const int *)valuep;\n                        break;\n                case RD_KAFKA_CONFVAL_STR:\n                        v = (int)strtol((const char *)valuep, (char **)&end, 0);\n                        if (end == (const char *)valuep) {\n                                rd_snprintf(errstr, errstr_size,\n                                            \"Invalid value type for \\\"%s\\\": \"\n                                            \"expecting integer\",\n                                            confval->name);\n                                return RD_KAFKA_RESP_ERR__INVALID_TYPE;\n                        }\n                        break;\n                default:\n                        rd_snprintf(errstr, errstr_size,\n                                    \"Invalid value type for \\\"%s\\\": \"\n                                    \"expecting integer\", confval->name);\n                        return RD_KAFKA_RESP_ERR__INVALID_ARG;\n                }\n\n\n                if ((confval->u.INT.vmin || confval->u.INT.vmax) &&\n                    (v < confval->u.INT.vmin || v > confval->u.INT.vmax)) {\n                        rd_snprintf(errstr, errstr_size,\n                                    \"Invalid value type for \\\"%s\\\": \"\n                                    \"expecting integer in range %d..%d\",\n                                    confval->name,\n                                    confval->u.INT.vmin,\n                                    confval->u.INT.vmax);\n                        return RD_KAFKA_RESP_ERR__INVALID_ARG;\n                }\n\n                confval->u.INT.v = v;\n                confval->is_set = 1;\n        }\n        break;\n\n        case RD_KAFKA_CONFVAL_STR:\n        {\n                size_t vlen;\n                const char *v = (const char *)valuep;\n\n                if (!valuep) {\n                        confval->is_set = 0;\n                        if (confval->u.STR.vdef)\n                                confval->u.STR.v = rd_strdup(confval->u.STR.\n                                                             vdef);\n                        else\n                                confval->u.STR.v = NULL;\n                }\n\n                if (valuetype != RD_KAFKA_CONFVAL_STR) {\n                        rd_snprintf(errstr, errstr_size,\n                                    \"Invalid value type for \\\"%s\\\": \"\n                                    \"expecting string\", confval->name);\n                        return RD_KAFKA_RESP_ERR__INVALID_ARG;\n                }\n\n                vlen = strlen(v);\n                if ((confval->u.STR.minlen || confval->u.STR.maxlen) &&\n                    (vlen < confval->u.STR.minlen ||\n                     vlen > confval->u.STR.maxlen)) {\n                        rd_snprintf(errstr, errstr_size,\n                                    \"Invalid value for \\\"%s\\\": \"\n                                    \"expecting string with length \"\n                                    \"%\"PRIusz\"..%\"PRIusz,\n                                    confval->name,\n                                    confval->u.STR.minlen,\n                                    confval->u.STR.maxlen);\n                        return RD_KAFKA_RESP_ERR__INVALID_ARG;\n                }\n\n                if (confval->u.STR.v)\n                        rd_free(confval->u.STR.v);\n\n                confval->u.STR.v = rd_strdup(v);\n        }\n        break;\n\n        case RD_KAFKA_CONFVAL_PTR:\n                confval->u.PTR = (void *)valuep;\n                break;\n\n        default:\n                RD_NOTREACHED();\n                return RD_KAFKA_RESP_ERR__NOENT;\n        }\n\n        return RD_KAFKA_RESP_ERR_NO_ERROR;\n}\n\n\nint rd_kafka_confval_get_int (const rd_kafka_confval_t *confval) {\n        rd_assert(confval->valuetype == RD_KAFKA_CONFVAL_INT);\n        return confval->u.INT.v;\n}\n\n\nconst char *rd_kafka_confval_get_str (const rd_kafka_confval_t *confval) {\n        rd_assert(confval->valuetype == RD_KAFKA_CONFVAL_STR);\n        return confval->u.STR.v;\n}\n\nvoid *rd_kafka_confval_get_ptr (const rd_kafka_confval_t *confval) {\n        rd_assert(confval->valuetype == RD_KAFKA_CONFVAL_PTR);\n        return confval->u.PTR;\n}\n\n\n#define _is_alphanum(C) (                                       \\\n                ((C) >= 'a' && (C) <= 'z') ||                   \\\n                ((C) >= 'A' && (C) <= 'Z') ||                   \\\n                ((C) >= '0' && (C) <= '9'))\n\n/**\n * @returns true if the string is KIP-511 safe, else false.\n */\nstatic rd_bool_t rd_kafka_sw_str_is_safe (const char *str) {\n        const char *s;\n\n        if (!*str)\n                return rd_true;\n\n        for (s = str ; *s ; s++) {\n                int c = (int)*s;\n\n                if (unlikely(!(_is_alphanum(c) || c == '-' || c == '.')))\n                        return rd_false;\n        }\n\n        /* Verify that the string begins and ends with a-zA-Z0-9 */\n        if (!_is_alphanum(*str))\n                return rd_false;\n        if (!_is_alphanum(*(s-1)))\n                return rd_false;\n\n        return rd_true;\n}\n\n\n/**\n * @brief Sanitize KIP-511 software name/version strings in-place,\n *        replacing unaccepted characters with \"-\".\n *\n * @warning The \\p str is modified in-place.\n */\nstatic void rd_kafka_sw_str_sanitize_inplace (char *str) {\n        char *s = str, *d = str;\n\n        /* Strip any leading non-alphanums */\n        while (!_is_alphanum(*s))\n                s++;\n\n        for (; *s ; s++) {\n                int c = (int)*s;\n\n                if (unlikely(!(_is_alphanum(c) ||\n                               c == '-' || c == '.')))\n                        *d = '-';\n                else\n                        *d = *s;\n                d++;\n        }\n\n        *d = '\\0';\n\n        /* Strip any trailing non-alphanums */\n        for (d = d-1 ; d >= str && !_is_alphanum(*d) ; d--)\n                *d = '\\0';\n}\n\n#undef _is_alphanum\n\n\n/**\n * @brief Verify configuration \\p conf is\n *        correct/non-conflicting and finalize the configuration\n *        settings for use.\n *\n * @returns an error string if configuration is incorrect, else NULL.\n */\nconst char *rd_kafka_conf_finalize (rd_kafka_type_t cltype,\n                                    rd_kafka_conf_t *conf) {\n\n        if (!conf->sw_name)\n                rd_kafka_conf_set(conf, \"client.software.name\", \"librdkafka\",\n                                  NULL, 0);\n        if (!conf->sw_version)\n                rd_kafka_conf_set(conf, \"client.software.version\",\n                                  rd_kafka_version_str(),\n                                  NULL, 0);\n\n        /* The client.software.name and .version are sent to the broker\n         * with the ApiVersionRequest starting with AK 2.4.0 (KIP-511).\n         * These strings need to be sanitized or the broker will reject them,\n         * so modify them in-place here. */\n        rd_assert(conf->sw_name && conf->sw_version);\n        rd_kafka_sw_str_sanitize_inplace(conf->sw_name);\n        rd_kafka_sw_str_sanitize_inplace(conf->sw_version);\n\n        /* Verify mandatory configuration */\n        if (!conf->socket_cb)\n                return \"Mandatory config property `socket_cb` not set\";\n\n        if (!conf->open_cb)\n                return \"Mandatory config property `open_cb` not set\";\n\n#if WITH_SSL\n        if (conf->ssl.keystore_location && !conf->ssl.keystore_password)\n                return \"`ssl.keystore.password` is mandatory when \"\n                        \"`ssl.keystore.location` is set\";\n        if (conf->ssl.ca && conf->ssl.ca_location)\n                return \"`ssl.ca.location`, and memory-based \"\n                       \"set_ssl_cert(CERT_CA) are mutually exclusive.\";\n#endif\n\n#if WITH_SASL_OAUTHBEARER\n        if (conf->sasl.enable_oauthbearer_unsecure_jwt &&\n            conf->sasl.oauthbearer_token_refresh_cb)\n                return \"`enable.sasl.oauthbearer.unsecure.jwt` and \"\n                        \"`oauthbearer_token_refresh_cb` are mutually exclusive\";\n#endif\n\n        if (cltype == RD_KAFKA_CONSUMER) {\n                /* Automatically adjust `fetch.max.bytes` to be >=\n                 * `message.max.bytes` unless set by user. */\n                if (rd_kafka_conf_is_modified(conf, \"fetch.max.bytes\")) {\n                        if (conf->fetch_max_bytes < conf->max_msg_size)\n                                return \"`fetch.max.bytes` must be >= \"\n                                        \"`message.max.bytes`\";\n                } else {\n                        conf->fetch_max_bytes = RD_MAX(conf->fetch_max_bytes,\n                                                       conf->max_msg_size);\n                }\n\n                /* Automatically adjust 'receive.message.max.bytes' to\n                 * be 512 bytes larger than 'fetch.max.bytes' to have enough\n                 * room for protocol framing (including topic name), unless\n                 * set by user. */\n                if (rd_kafka_conf_is_modified(conf,\n                                              \"receive.message.max.bytes\")) {\n                        if (conf->fetch_max_bytes + 512 >\n                            conf->recv_max_msg_size)\n                                return \"`receive.message.max.bytes` must be >= \"\n                                        \"`fetch.max.bytes` + 512\";\n                } else {\n                        conf->recv_max_msg_size =\n                                RD_MAX(conf->recv_max_msg_size,\n                                       conf->fetch_max_bytes + 512);\n                }\n\n                if (conf->max_poll_interval_ms <\n                    conf->group_session_timeout_ms)\n                        return \"`max.poll.interval.ms`must be >= \"\n                                \"`session.timeout.ms`\";\n\n                /* Simplifies rd_kafka_is_idempotent() which is producer-only */\n                conf->eos.idempotence = 0;\n\n        } else if (cltype == RD_KAFKA_PRODUCER) {\n                if (conf->eos.transactional_id) {\n                        if (!conf->eos.idempotence) {\n                                /* Auto enable idempotence unless\n                                 * explicitly disabled */\n                                if (rd_kafka_conf_is_modified(\n                                            conf, \"enable.idempotence\"))\n                                        return \"`transactional.id` requires \"\n                                                \"`enable.idempotence=true`\";\n\n                                conf->eos.idempotence = rd_true;\n                        }\n\n                        /* Make sure at least one request can be sent\n                         * before the transaction times out. */\n                        if (!rd_kafka_conf_is_modified(conf,\n                                                       \"socket.timeout.ms\"))\n                                conf->socket_timeout_ms =\n                                        RD_MAX(conf->eos.\n                                               transaction_timeout_ms - 100,\n                                               900);\n                        else if (conf->eos.transaction_timeout_ms + 100 <\n                                 conf->socket_timeout_ms)\n                                return \"`socket.timeout.ms` must be set <= \"\n                                        \"`transaction.timeout.ms` + 100\";\n                }\n\n                if (conf->eos.idempotence) {\n                        /* Adjust configuration values for idempotent producer*/\n\n                        if (rd_kafka_conf_is_modified(conf, \"max.in.flight\")) {\n                                if (conf->max_inflight >\n                                    RD_KAFKA_IDEMP_MAX_INFLIGHT)\n                                        return \"`max.in.flight` must be \"\n                                                \"set <= \"\n                                                RD_KAFKA_IDEMP_MAX_INFLIGHT_STR\n                                                \" when `enable.idempotence` \"\n                                                \"is true\";\n                        } else {\n                                conf->max_inflight =\n                                        RD_MIN(conf->max_inflight,\n                                               RD_KAFKA_IDEMP_MAX_INFLIGHT);\n                        }\n\n\n                        if (rd_kafka_conf_is_modified(conf, \"retries\")) {\n                                if (conf->max_retries < 1)\n                                        return \"`retries` must be set >= 1 \"\n                                                \"when `enable.idempotence` is \"\n                                                \"true\";\n                        } else {\n                                conf->max_retries = INT32_MAX;\n                        }\n\n\n                        if (rd_kafka_conf_is_modified(\n                                    conf,\n                                    \"queue.buffering.backpressure.threshold\")\n                            && conf->queue_backpressure_thres > 1)\n                                return \"`queue.buffering.backpressure.threshold` \"\n                                        \"must be set to 1 when \"\n                                        \"`enable.idempotence` is true\";\n                        else\n                                conf->queue_backpressure_thres = 1;\n\n                        /* acks=all and queuing.strategy are set\n                         * in topic_conf_finalize() */\n\n                } else {\n                        if (conf->eos.gapless &&\n                            rd_kafka_conf_is_modified(\n                                    conf, \"enable.gapless.guarantee\"))\n                                return \"`enable.gapless.guarantee` requires \"\n                                        \"`enable.idempotence` to be enabled\";\n                }\n        }\n\n\n        if (!rd_kafka_conf_is_modified(conf, \"metadata.max.age.ms\") &&\n            conf->metadata_refresh_interval_ms > 0)\n                conf->metadata_max_age_ms =\n                        conf->metadata_refresh_interval_ms * 3;\n\n        if (conf->reconnect_backoff_max_ms < conf->reconnect_backoff_ms)\n                return \"`reconnect.backoff.max.ms` must be >= \"\n                        \"`reconnect.max.ms`\";\n\n        if (conf->sparse_connections) {\n                /* Set sparse connection random selection interval to\n                 * 10 < reconnect.backoff.ms / 2 < 1000. */\n                conf->sparse_connect_intvl =\n                        RD_MAX(11, RD_MIN(conf->reconnect_backoff_ms/2, 1000));\n        }\n\n        /* Finalize and verify the default.topic.config */\n        if (conf->topic_conf)\n                return rd_kafka_topic_conf_finalize(cltype, conf,\n                                                    conf->topic_conf);\n\n        return NULL;\n}\n\n\n/**\n * @brief Verify topic configuration \\p tconf is\n *        correct/non-conflicting and finalize the configuration\n *        settings for use.\n *\n * @returns an error string if configuration is incorrect, else NULL.\n */\nconst char *rd_kafka_topic_conf_finalize (rd_kafka_type_t cltype,\n                                          rd_kafka_conf_t *conf,\n                                          rd_kafka_topic_conf_t *tconf) {\n\n        if (conf->eos.idempotence) {\n                /* Ensure acks=all */\n                if (rd_kafka_topic_conf_is_modified(tconf, \"acks\")) {\n                        if (tconf->required_acks != -1)\n                                return \"`acks` must be set to `all` when \"\n                                        \"`enable.idempotence` is true\";\n                } else {\n                        tconf->required_acks = -1; /* all */\n                }\n\n                /* Ensure FIFO queueing */\n                if (rd_kafka_topic_conf_is_modified(tconf, \"queuing.strategy\")) {\n                        if (tconf->queuing_strategy != RD_KAFKA_QUEUE_FIFO)\n                                return \"`queuing.strategy` must be set to \"\n                                        \"`fifo` when `enable.idempotence` is \"\n                                        \"true\";\n                } else {\n                        tconf->queuing_strategy = RD_KAFKA_QUEUE_FIFO;\n                }\n\n                /* Ensure message.timeout.ms <= transaction.timeout.ms */\n                if (conf->eos.transactional_id) {\n                        if (!rd_kafka_topic_conf_is_modified(\n                                    tconf, \"message.timeout.ms\"))\n                                tconf->message_timeout_ms =\n                                        conf->eos.transaction_timeout_ms;\n                        else if (tconf->message_timeout_ms >\n                                 conf->eos.transaction_timeout_ms)\n                                return \"`message.timeout.ms` must be set <= \"\n                                        \"`transaction.timeout.ms`\";\n                 }\n        }\n\n\n        if (cltype == RD_KAFKA_PRODUCER) {\n                /* Convert double linger.ms to internal int microseconds */\n                conf->buffering_max_us = (rd_ts_t)(conf->buffering_max_ms_dbl *\n                                                   1000);\n\n                if (tconf->message_timeout_ms != 0 &&\n                    (rd_ts_t)tconf->message_timeout_ms * 1000 <=\n                    conf->buffering_max_us)\n                        return \"`message.timeout.ms` must be greater than \"\n                                \"`linger.ms`\";\n        }\n\n\n        return NULL;\n}\n\n\n/**\n * @brief Log warnings for set deprecated or experimental\n *        configuration properties.\n * @returns the number of warnings logged.\n */\nstatic int rd_kafka_anyconf_warn_deprecated (rd_kafka_t *rk,\n                                             rd_kafka_conf_scope_t scope,\n                                             const void *conf) {\n        const struct rd_kafka_property *prop;\n        const int warn_on = _RK_DEPRECATED|_RK_EXPERIMENTAL;\n        int cnt = 0;\n\n\n        for (prop = rd_kafka_properties; prop->name ; prop++) {\n                int match = prop->scope & warn_on;\n\n                if (likely(!(prop->scope & scope) || !match))\n                        continue;\n\n                if (likely(!rd_kafka_anyconf_is_modified(conf, prop)))\n                        continue;\n\n                rd_kafka_log(rk, LOG_WARNING, \"CONFWARN\",\n                             \"Configuration property %s is %s%s%s: %s\",\n                             prop->name,\n                             match & _RK_DEPRECATED ? \"deprecated\" : \"\",\n                             match == warn_on ? \" and \" : \"\",\n                             match & _RK_EXPERIMENTAL ? \"experimental\" : \"\",\n                             prop->desc);\n                cnt++;\n        }\n\n        return cnt;\n}\n\n\n/**\n * @brief Log configuration warnings (deprecated configuration properties,\n *        unrecommended combinations, etc).\n *\n * @returns the number of warnings logged.\n *\n * @locality any\n * @locks none\n */\nint rd_kafka_conf_warn (rd_kafka_t *rk) {\n        int cnt = 0;\n\n        cnt = rd_kafka_anyconf_warn_deprecated(rk, _RK_GLOBAL, &rk->rk_conf);\n        if (rk->rk_conf.topic_conf)\n                cnt += rd_kafka_anyconf_warn_deprecated(\n                        rk, _RK_TOPIC, rk->rk_conf.topic_conf);\n\n        /* Additional warnings */\n        if (rk->rk_type == RD_KAFKA_CONSUMER) {\n                if (rk->rk_conf.fetch_wait_max_ms + 1000 >\n                    rk->rk_conf.socket_timeout_ms)\n                        rd_kafka_log(rk, LOG_WARNING,\n                                     \"CONFWARN\",\n                                     \"Configuration property \"\n                                     \"`fetch.wait.max.ms` (%d) should be \"\n                                     \"set lower than `socket.timeout.ms` (%d) \"\n                                     \"by at least 1000ms to avoid blocking \"\n                                     \"and timing out sub-sequent requests\",\n                                     rk->rk_conf.fetch_wait_max_ms,\n                                     rk->rk_conf.socket_timeout_ms);\n        }\n\n        if (rd_kafka_conf_is_modified(&rk->rk_conf, \"sasl.mechanisms\") &&\n            !(rk->rk_conf.security_protocol == RD_KAFKA_PROTO_SASL_SSL ||\n              rk->rk_conf.security_protocol == RD_KAFKA_PROTO_SASL_PLAINTEXT)) {\n                rd_kafka_log(rk, LOG_WARNING, \"CONFWARN\",\n                             \"Configuration property `sasl.mechanism` set to \"\n                             \"`%s` but `security.protocol` is not configured \"\n                             \"for SASL: recommend setting \"\n                             \"`security.protocol` to SASL_SSL or \"\n                             \"SASL_PLAINTEXT\",\n                             rk->rk_conf.sasl.mechanisms);\n        }\n\n        if (rd_kafka_conf_is_modified(&rk->rk_conf, \"sasl.username\") &&\n            !(!strncmp(rk->rk_conf.sasl.mechanisms, \"SCRAM\", 5) ||\n              !strcmp(rk->rk_conf.sasl.mechanisms, \"PLAIN\")))\n                rd_kafka_log(rk, LOG_WARNING, \"CONFWARN\",\n                             \"Configuration property `sasl.username` only \"\n                             \"applies when `sasl.mechanism` is set to \"\n                             \"PLAIN or SCRAM-SHA-..\");\n\n        if (rd_kafka_conf_is_modified(&rk->rk_conf, \"client.software.name\") &&\n            !rd_kafka_sw_str_is_safe(rk->rk_conf.sw_name))\n                rd_kafka_log(rk, LOG_WARNING, \"CONFWARN\",\n                             \"Configuration property `client.software.name` \"\n                             \"may only contain 'a-zA-Z0-9.-', other characters \"\n                             \"will be replaced with '-'\");\n\n        if (rd_kafka_conf_is_modified(&rk->rk_conf, \"client.software.version\") &&\n            !rd_kafka_sw_str_is_safe(rk->rk_conf.sw_version))\n                rd_kafka_log(rk, LOG_WARNING, \"CONFWARN\",\n                             \"Configuration property `client.software.verison` \"\n                             \"may only contain 'a-zA-Z0-9.-', other characters \"\n                             \"will be replaced with '-'\");\n\n        return cnt;\n}\n\n\nconst rd_kafka_conf_t *rd_kafka_conf (rd_kafka_t *rk) {\n        return &rk->rk_conf;\n}\n\n\n/**\n * @brief Unittests\n */\nint unittest_conf (void) {\n        rd_kafka_conf_t *conf;\n        rd_kafka_topic_conf_t *tconf;\n        rd_kafka_conf_res_t res, res2;\n        char errstr[128];\n        int iteration;\n        const struct rd_kafka_property *prop;\n        char readval[512];\n        size_t readlen;\n        const char *errstr2;\n\n        conf = rd_kafka_conf_new();\n        tconf = rd_kafka_topic_conf_new();\n\n        res = rd_kafka_conf_set(conf, \"unknown.thing\", \"foo\",\n                                errstr, sizeof(errstr));\n        RD_UT_ASSERT(res == RD_KAFKA_CONF_UNKNOWN, \"fail\");\n        RD_UT_ASSERT(*errstr, \"fail\");\n\n        for (iteration = 0 ; iteration < 5 ; iteration++) {\n                int cnt;\n\n\n                /* Iterations:\n                 *  0 - Check is_modified\n                 *  1 - Set every other config property, read back and verify.\n                 *  2 - Check is_modified.\n                 *  3 - Set all config properties, read back and verify.\n                 *  4 - Check is_modified. */\n                for (prop = rd_kafka_properties, cnt = 0 ; prop->name ;\n                     prop++, cnt++) {\n                        const char *val;\n                        char tmp[64];\n                        int odd = cnt & 1;\n                        int do_set = iteration == 3 || (iteration == 1 && odd);\n                        rd_bool_t is_modified;\n                        int exp_is_modified = iteration >= 3 ||\n                                (iteration > 0 && (do_set || odd));\n\n                        readlen = sizeof(readval);\n\n                        /* Avoid some special configs */\n                        if (!strcmp(prop->name, \"plugin.library.paths\") ||\n                            !strcmp(prop->name, \"builtin.features\"))\n                                continue;\n\n                        switch (prop->type)\n                        {\n                        case _RK_C_STR:\n                        case _RK_C_KSTR:\n                        case _RK_C_PATLIST:\n                                if (prop->sdef)\n                                        val = prop->sdef;\n                                else\n                                        val = \"test\";\n                                break;\n\n                        case _RK_C_BOOL:\n                                val = \"true\";\n                                break;\n\n                        case _RK_C_INT:\n                                rd_snprintf(tmp, sizeof(tmp), \"%d\", prop->vdef);\n                                val = tmp;\n                                break;\n\n                        case _RK_C_DBL:\n                                rd_snprintf(tmp, sizeof(tmp), \"%g\", prop->ddef);\n                                val = tmp;\n                                break;\n\n                        case _RK_C_S2F:\n                        case _RK_C_S2I:\n                                val = prop->s2i[0].str;\n                                break;\n\n                        case _RK_C_PTR:\n                        case _RK_C_ALIAS:\n                        case _RK_C_INVALID:\n                        case _RK_C_INTERNAL:\n                        default:\n                                continue;\n                        }\n\n\n                        if (prop->scope & _RK_GLOBAL) {\n                                if (do_set)\n                                        res = rd_kafka_conf_set(conf,\n                                                                prop->name, val,\n                                                                errstr,\n                                                                sizeof(errstr));\n\n                                res2 = rd_kafka_conf_get(conf,\n                                                         prop->name,\n                                                         readval, &readlen);\n\n                                is_modified = rd_kafka_conf_is_modified(\n                                        conf, prop->name);\n\n\n                        } else if (prop->scope & _RK_TOPIC) {\n                                if  (do_set)\n                                        res = rd_kafka_topic_conf_set(\n                                                tconf,\n                                                prop->name, val,\n                                                errstr, sizeof(errstr));\n\n                                res2 = rd_kafka_topic_conf_get(tconf,\n                                                               prop->name,\n                                                               readval,\n                                                               &readlen);\n\n                                is_modified = rd_kafka_topic_conf_is_modified(\n                                        tconf, prop->name);\n\n                        } else {\n                                RD_NOTREACHED();\n                        }\n\n\n\n                        if (do_set) {\n                                RD_UT_ASSERT(res == RD_KAFKA_CONF_OK,\n                                             \"conf_set %s failed: %d: %s\",\n                                             prop->name, res, errstr);\n                                RD_UT_ASSERT(res2 == RD_KAFKA_CONF_OK,\n                                             \"conf_get %s failed: %d\",\n                                             prop->name, res2);\n\n                                RD_UT_ASSERT(!strcmp(readval, val),\n                                             \"conf_get %s \"\n                                             \"returned \\\"%s\\\": \"\n                                             \"expected \\\"%s\\\"\",\n                                             prop->name, readval, val);\n\n                                RD_UT_ASSERT(is_modified,\n                                             \"Property %s was set but \"\n                                             \"is_modified=%d\",\n                                             prop->name, is_modified);\n\n                        }\n\n                        assert(is_modified == exp_is_modified);\n                        RD_UT_ASSERT(is_modified == exp_is_modified,\n                                     \"Property %s is_modified=%d, \"\n                                     \"exp_is_modified=%d \"\n                                     \"(iter %d, odd %d, do_set %d)\",\n                                     prop->name, is_modified,\n                                     exp_is_modified,\n                                     iteration, odd, do_set);\n                }\n        }\n\n        /* Set an alias and make sure is_modified() works for it. */\n        res = rd_kafka_conf_set(conf, \"max.in.flight\", \"19\", NULL, 0);\n        RD_UT_ASSERT(res == RD_KAFKA_CONF_OK, \"%d\", res);\n\n        RD_UT_ASSERT(rd_kafka_conf_is_modified(conf, \"max.in.flight\") == rd_true,\n                     \"fail\");\n        RD_UT_ASSERT(rd_kafka_conf_is_modified(\n                             conf,\n                             \"max.in.flight.requests.per.connection\") == rd_true,\n                     \"fail\");\n\n        rd_kafka_conf_destroy(conf);\n        rd_kafka_topic_conf_destroy(tconf);\n\n\n        /* Verify that software.client.* string-safing works */\n        conf = rd_kafka_conf_new();\n        res = rd_kafka_conf_set(conf, \"client.software.name\",\n                                \" .~aba. va! !.~~\", NULL, 0);\n        RD_UT_ASSERT(res == RD_KAFKA_CONF_OK, \"%d\", res);\n        res = rd_kafka_conf_set(conf, \"client.software.version\",\n                                \"!1.2.3.4.5!!! a\", NULL, 0);\n        RD_UT_ASSERT(res == RD_KAFKA_CONF_OK, \"%d\", res);\n\n        errstr2 = rd_kafka_conf_finalize(RD_KAFKA_PRODUCER, conf);\n        RD_UT_ASSERT(!errstr2, \"conf_finalize() failed: %s\", errstr2);\n\n        readlen = sizeof(readval);\n        res2 = rd_kafka_conf_get(conf, \"client.software.name\",\n                                 readval, &readlen);\n        RD_UT_ASSERT(res == RD_KAFKA_CONF_OK, \"%d\", res2);\n        RD_UT_ASSERT(!strcmp(readval, \"aba.-va\"),\n                     \"client.software.* safification failed: \\\"%s\\\"\", readval);\n        RD_UT_SAY(\"Safified client.software.name=\\\"%s\\\"\", readval);\n\n        readlen = sizeof(readval);\n        res2 = rd_kafka_conf_get(conf, \"client.software.version\",\n                                 readval, &readlen);\n        RD_UT_ASSERT(res == RD_KAFKA_CONF_OK, \"%d\", res2);\n        RD_UT_ASSERT(!strcmp(readval, \"1.2.3.4.5----a\"),\n                     \"client.software.* safification failed: \\\"%s\\\"\", readval);\n        RD_UT_SAY(\"Safified client.software.version=\\\"%s\\\"\", readval);\n\n        rd_kafka_conf_destroy(conf);\n\n        RD_UT_PASS();\n}\n\n/**@}*/\n",
        "/tmp/vanessa/spack-stage/spack-stage-librdkafka-1.4.4-3ssj4ca5li7y4lpnk4u42eu35dqiqn3i/spack-src/src/rdkafka_plugin.c": "/*\n * librdkafka - The Apache Kafka C/C++ library\n *\n * Copyright (c) 2017 Magnus Edenhill\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"rdkafka_int.h\"\n#include \"rdkafka_plugin.h\"\n#include \"rddl.h\"\n\n\ntypedef struct rd_kafka_plugin_s {\n        char *rkplug_path;         /* Library path */\n        rd_kafka_t *rkplug_rk;     /* Backpointer to the rk handle */\n        void *rkplug_handle;       /* dlopen (or similar) handle */\n        void *rkplug_opaque;       /* Plugin's opaque */\n\n} rd_kafka_plugin_t;\n\n\n/**\n * @brief Plugin path comparator\n */\nstatic int rd_kafka_plugin_cmp (const void *_a, const void *_b) {\n        const rd_kafka_plugin_t *a = _a, *b = _b;\n\n        return strcmp(a->rkplug_path, b->rkplug_path);\n}\n\n\n/**\n * @brief Add plugin (by library path) and calls its conf_init() constructor\n *\n * @returns an error code on error.\n * @remark duplicate plugins are silently ignored.\n *\n * @remark Libraries are refcounted and thus not unloaded until all\n *         plugins referencing the library have been destroyed.\n *         (dlopen() and LoadLibrary() does this for us)\n */\nstatic rd_kafka_resp_err_t\nrd_kafka_plugin_new (rd_kafka_conf_t *conf, const char *path,\n                     char *errstr, size_t errstr_size) {\n        rd_kafka_plugin_t *rkplug;\n        const rd_kafka_plugin_t skel = { .rkplug_path = (char *)path };\n        rd_kafka_plugin_f_conf_init_t *conf_init;\n        rd_kafka_resp_err_t err;\n        void *handle;\n        void *plug_opaque = NULL;\n\n        /* Avoid duplicates */\n        if (rd_list_find(&conf->plugins, &skel, rd_kafka_plugin_cmp)) {\n                rd_snprintf(errstr, errstr_size,\n                            \"Ignoring duplicate plugin %s\", path);\n                return RD_KAFKA_RESP_ERR_NO_ERROR;\n        }\n\n        rd_kafka_dbg0(conf, PLUGIN, \"PLUGLOAD\",\n                      \"Loading plugin \\\"%s\\\"\", path);\n\n        /* Attempt to load library */\n        if (!(handle = rd_dl_open(path, errstr, errstr_size))) {\n                rd_kafka_dbg0(conf, PLUGIN, \"PLUGLOAD\",\n                              \"Failed to load plugin \\\"%s\\\": %s\",\n                              path, errstr);\n                return RD_KAFKA_RESP_ERR__FS;\n        }\n\n        /* Find conf_init() function */\n        if (!(conf_init = rd_dl_sym(handle, \"conf_init\",\n                                    errstr, errstr_size))) {\n                rd_dl_close(handle);\n                return RD_KAFKA_RESP_ERR__INVALID_ARG;\n        }\n\n        /* Call conf_init() */\n        rd_kafka_dbg0(conf, PLUGIN, \"PLUGINIT\",\n                      \"Calling plugin \\\"%s\\\" conf_init()\", path);\n\n        if ((err = conf_init(conf, &plug_opaque, errstr, errstr_size))) {\n                rd_dl_close(handle);\n                return err;\n        }\n\n        rkplug = rd_calloc(1, sizeof(*rkplug));\n        rkplug->rkplug_path        = rd_strdup(path);\n        rkplug->rkplug_handle      = handle;\n        rkplug->rkplug_opaque = plug_opaque;\n\n        rd_list_add(&conf->plugins, rkplug);\n\n        rd_kafka_dbg0(conf, PLUGIN, \"PLUGLOAD\",\n                      \"Plugin \\\"%s\\\" loaded\", path);\n\n        return RD_KAFKA_RESP_ERR_NO_ERROR;\n}\n\n\n/**\n * @brief Free the plugin, any conf_destroy() interceptors will have been\n *        called prior to this call.\n * @remark plugin is not removed from any list (caller's responsibility)\n * @remark this relies on the actual library loader to refcount libraries,\n *         especially in the config copy case.\n *         This is true for POSIX dlopen() and Win32 LoadLibrary().\n * @locality application thread\n */\nstatic void rd_kafka_plugin_destroy (rd_kafka_plugin_t *rkplug) {\n        rd_dl_close(rkplug->rkplug_handle);\n        rd_free(rkplug->rkplug_path);\n        rd_free(rkplug);\n}\n\n\n\n/**\n * @brief Initialize all configured plugins.\n *\n * @remark Any previously loaded plugins will be unloaded.\n *\n * @returns the error code of the first failing plugin.\n * @locality application thread calling rd_kafka_new().\n */\nstatic rd_kafka_conf_res_t\nrd_kafka_plugins_conf_set0 (rd_kafka_conf_t *conf, const char *paths,\n                            char *errstr, size_t errstr_size) {\n        char *s;\n\n        rd_list_destroy(&conf->plugins);\n        rd_list_init(&conf->plugins, 0, (void *)&rd_kafka_plugin_destroy);\n\n        if (!paths || !*paths)\n                return RD_KAFKA_CONF_OK;\n\n        /* Split paths by ; */\n        rd_strdupa(&s, paths);\n\n        rd_kafka_dbg0(conf, PLUGIN, \"PLUGLOAD\",\n                      \"Loading plugins from conf object %p: \\\"%s\\\"\",\n                      conf, paths);\n\n        while (s && *s) {\n                char *path = s;\n                char *t;\n                rd_kafka_resp_err_t err;\n\n                if ((t = strchr(s, ';'))) {\n                        *t = '\\0';\n                        s = t+1;\n                } else {\n                        s = NULL;\n                }\n\n                if ((err = rd_kafka_plugin_new(conf, path,\n                                               errstr, errstr_size))) {\n                        /* Failed to load plugin */\n                        size_t elen = errstr_size > 0 ? strlen(errstr) : 0;\n\n                        /* See if there is room for appending the\n                         * plugin path to the error message. */\n                        if (elen + strlen(\"(plugin )\") + strlen(path) <\n                            errstr_size)\n                                rd_snprintf(errstr+elen, errstr_size-elen,\n                                            \" (plugin %s)\", path);\n\n                        rd_list_destroy(&conf->plugins);\n                        return RD_KAFKA_CONF_INVALID;\n                }\n        }\n\n        return RD_KAFKA_CONF_OK;\n}\n\n\n/**\n * @brief Conf setter for \"plugin.library.paths\"\n */\nrd_kafka_conf_res_t rd_kafka_plugins_conf_set (\n        int scope, void *pconf, const char *name, const char *value,\n        void *dstptr, rd_kafka_conf_set_mode_t set_mode,\n        char *errstr, size_t errstr_size) {\n\n        assert(scope == _RK_GLOBAL);\n        return rd_kafka_plugins_conf_set0((rd_kafka_conf_t *)pconf,\n                                          set_mode == _RK_CONF_PROP_SET_DEL ?\n                                          NULL : value, errstr, errstr_size);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-librdkafka-1.4.4-3ssj4ca5li7y4lpnk4u42eu35dqiqn3i/spack-src/packaging/cmake/try_compile/dlopen_test.c": "#include <string.h>\n#include <dlfcn.h>\n\nint main() {\n        void *h;\n        /* Try loading anything, we don't care if it works */\n        h = dlopen(\"__nothing_rdkafka.so\", RTLD_NOW|RTLD_LOCAL);\n        if (h)\n                dlclose(h);\n        return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-librdkafka-1.4.4-3ssj4ca5li7y4lpnk4u42eu35dqiqn3i/spack-src/tests/librdkafka.suppressions": "# Valgrind suppression file for librdkafka\n{\n   allocate_tls_despite_detached_1\n   Memcheck:Leak\n   fun:calloc\n   fun:_dl_allocate_tls\n   fun:pthread_create@@GLIBC_2.2.5\n}\n\n{\n   helgrind---_dl_allocate_tls\n   Helgrind:Race\n   fun:mempcpy\n   fun:_dl_allocate_tls_init\n   ...\n   fun:pthread_create@@GLIBC_2.2*\n   fun:pthread_create_WRK\n   fun:pthread_create@*\n}\n{\n   drd_nss1\n   drd:ConflictingAccess\n   fun:pthread_mutex_lock\n   fun:_nss_files_gethostbyname4_r\n   fun:gaih_inet\n   fun:getaddrinfo\n   fun:rd_getaddrinfo\n   fun:rd_kafka_broker_resolve\n   fun:rd_kafka_broker_connect\n   fun:rd_kafka_broker_thread_main\n   fun:_thrd_wrapper_function\n   obj:/usr/lib/valgrind/vgpreload_drd-amd64-linux.so\n   fun:start_thread\n   fun:clone\n}\n\n{\n   drd_nss2\n   drd:ConflictingAccess\n   fun:strlen\n   fun:nss_load_library\n   fun:__nss_lookup_function\n   fun:gaih_inet\n   fun:getaddrinfo\n   fun:rd_getaddrinfo\n   fun:rd_kafka_broker_resolve\n   fun:rd_kafka_broker_connect\n   fun:rd_kafka_broker_thread_main\n   fun:_thrd_wrapper_function\n   obj:/usr/lib/valgrind/vgpreload_drd-amd64-linux.so\n   fun:start_thread\n   fun:clone\n}\n{\n   drd_nss3\n   drd:ConflictingAccess\n   fun:__GI_stpcpy\n   fun:nss_load_library\n   fun:__nss_lookup_function\n   fun:gaih_inet\n   fun:getaddrinfo\n   fun:rd_getaddrinfo\n   fun:rd_kafka_broker_resolve\n   fun:rd_kafka_broker_connect\n   fun:rd_kafka_broker_thread_main\n   fun:_thrd_wrapper_function\n   obj:/usr/lib/valgrind/vgpreload_drd-amd64-linux.so\n   fun:start_thread\n   fun:clone\n}\n{\n   drd_nss4\n   drd:ConflictingAccess\n   fun:strlen\n   fun:__nss_lookup_function\n   fun:gaih_inet\n   fun:getaddrinfo\n   fun:rd_getaddrinfo\n   fun:rd_kafka_broker_resolve\n   fun:rd_kafka_broker_connect\n   fun:rd_kafka_broker_thread_main\n   fun:_thrd_wrapper_function\n   obj:/usr/lib/valgrind/vgpreload_drd-amd64-linux.so\n   fun:start_thread\n   fun:clone\n}\n{\n   drd_nss5\n   drd:ConflictingAccess\n   fun:strlen\n   fun:__nss_lookup_function\n   fun:gaih_inet\n   fun:getaddrinfo\n   fun:rd_getaddrinfo\n   fun:rd_kafka_broker_resolve\n   fun:rd_kafka_broker_connect\n   fun:rd_kafka_broker_thread_main\n   fun:_thrd_wrapper_function\n   obj:/usr/lib/valgrind/vgpreload_drd-amd64-linux.so\n   fun:start_thread\n   fun:clone\n}\n{\n   drd_nss6\n   drd:ConflictingAccess\n   fun:internal_setent\n   fun:_nss_files_gethostbyname4_r\n   fun:gaih_inet\n   fun:getaddrinfo\n   fun:rd_getaddrinfo\n   fun:rd_kafka_broker_resolve\n   fun:rd_kafka_broker_connect\n   fun:rd_kafka_broker_thread_main\n   fun:_thrd_wrapper_function\n   obj:/usr/lib/valgrind/vgpreload_drd-amd64-linux.so\n   fun:start_thread\n   fun:clone\n}\n{\n   ssl_read\n   Memcheck:Cond\n   fun:ssl3_read_bytes\n   fun:ssl3_read_internal\n}\n\n\n\t\t    \n{\n   ssl_noterm_leak1\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   ...\n   fun:SSL_library_init\n}\n{\n   ssl_noterm_leak2\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   ...\n   fun:OPENSSL_add_all_algorithms_noconf\n}\n{\n   ssl_noterm_leak3\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   ...\n   fun:OpenSSL_add_all_digests\n}\n{\n   ssl_noterm_leak3b\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:realloc\n   ...\n   fun:OpenSSL_add_all_digests\n}\n{\n   ssl_noterm_leak4\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   ...\n   fun:EVP_add_digest\n}\n{\n   ssl_noterm_leak5\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   ...\n   fun:SSL_load_error_strings\n}\n{\n   ssl_noterm_leak6\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:realloc\n   ...\n   fun:OPENSSL_add_all_algorithms_noconf\n}\n{\n   ssl_noterm_leak7\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   ...\n   fun:ERR_load_SSL_strings\n}\n{\n   ssl_noterm_leak8\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   ...\n   fun:err_load_strings\n}\n{\n   ssl_noterm_leak8b\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   ...\n   fun:ERR_load_strings\n}\n{\n   ssl_noterm_leak8c\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:realloc\n   ...\n   fun:ERR_load_strings\n}\n{\n   ssl_noterm_leak9\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:realloc\n   ...\n   fun:ERR_load_SSL_strings\n}\n{\n   ssl_noterm_leak10\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   ...\n   fun:OPENSSL_init_library\n}\n{\n   ssl_noterm_leak10b\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:calloc\n   ...\n   fun:OPENSSL_init_library\n}\n{\n   ssl_noterm_leak11\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   ...\n   fun:EVP_SignFinal\n}\n{\n   ssl_noterm_leak12\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   ...\n   fun:FIPS_mode_set\n}\n{\n   thrd_tls_alloc_stack\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:calloc\n   fun:allocate_dtv\n   fun:_dl_allocate_tls\n   fun:allocate_stack\n   fun:pthread_create@@GLIBC_2.2.5\n   fun:thrd_create\n}\n{\n   more_tls1\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:calloc\n   fun:allocate_dtv\n   fun:_dl_allocate_tls\n   fun:allocate_stack\n}\n\n{\n   ssl_uninit1\n   Memcheck:Cond\n   fun:rd_kafka_metadata_handle\n   fun:rd_kafka_broker_metadata_reply\n}\n{\n   ssl_uninit2\n   Memcheck:Value8\n   fun:rd_kafka_metadata_handle\n   fun:rd_kafka_broker_metadata_reply\n}\n{\n   ssl_uninit3\n   Memcheck:Cond\n   fun:memcpy@@GLIBC_2.14\n   fun:rd_kafka_metadata_handle\n   fun:rd_kafka_broker_metadata_reply\n}\n\n{\n   log_races0\n   Helgrind:Race\n   fun:rd_kafka_log0\n}\n{\n   glibc_tls\n   Helgrind:Race\n   fun:mempcpy\n   fun:_dl_allocate_tls_init\n   fun:get_cached_stack\n   fun:allocate_stack\n   fun:pthread_create@@GLIBC_2.2.5\n}\n{\n   false_tls\n   Helgrind:Race\n   fun:thrd_detach\n}\n\n\n# cyrus libsasl2 global/once memory \"leaks\"\n{\n   leak_sasl_global_init1\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   ...\n   fun:sasl_client_init\n}\n{\n   leak_sasl_global_init6\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:calloc\n   ...\n   fun:sasl_client_init\n}\n\n{\n   leak_sasl_dlopen\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:?alloc\n   ...\n   fun:_dl_catch_error\n}\n{\n   leak_sasl_add_plugin\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   ...\n   fun:sasl_client_add_plugin\n}\n{\n   leak_sasl_add_plugin2\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:calloc\n   ...\n   fun:sasl_client_add_plugin\n}\n{\n   debian_testing_ld_uninitialized\n   Memcheck:Cond\n   fun:index\n   fun:expand_dynamic_string_token\n   ...\n   fun:_dl_start\n   ...\n}\n{\n   glibc_internals_nss_race1\n   Helgrind:Race\n   ...\n   fun:getaddrinfo\n   ...\n}\n{\n   nss_files\n   Helgrind:Race\n   ...\n   fun:_dl_runtime_resolve_avx\n   ...\n}\n{\n   cpp_glibc_globals\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   fun:pool\n   fun:__static_initialization_and_destruction_0\n   fun:_GLOBAL__sub_I_eh_alloc.cc\n}\n{\n   mtx_unlock_plus_destroy\n   Helgrind:Race\n   obj:/usr/lib/valgrind/vgpreload_helgrind-amd64-linux.so\n   obj:/usr/lib/valgrind/vgpreload_helgrind-amd64-linux.so\n   fun:rd_kafka_q_destroy_final\n}\n{\n   mtx_unlock_plus_destroy2\n   Helgrind:Race\n   obj:/usr/lib/valgrind/vgpreload_helgrind-amd64-linux.so\n   obj:/usr/lib/valgrind/vgpreload_helgrind-amd64-linux.so\n   fun:rd_refcnt_destroy\n}\n{\n   nss_dl_lookup\n   Helgrind:Race\n   ...\n   fun:do_lookup_x\n   fun:_dl_lookup_symbol_x\n   ...\n}\n{\n   dlopen1\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   ...\n   fun:_dl_open\n}\n\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-librdkafka-1.4.4-3ssj4ca5li7y4lpnk4u42eu35dqiqn3i/spack-src/src/librdkafka_cgrp_synch.png",
        "/tmp/vanessa/spack-stage/spack-stage-librdkafka-1.4.4-3ssj4ca5li7y4lpnk4u42eu35dqiqn3i/spack-src/packaging/nuget/common/p-common__plat-windows__arch-win32__bldtype-Release/msvcr120.zip",
        "/tmp/vanessa/spack-stage/spack-stage-librdkafka-1.4.4-3ssj4ca5li7y4lpnk4u42eu35dqiqn3i/spack-src/packaging/nuget/common/p-common__plat-windows__arch-x64__bldtype-Release/msvcr120.zip"
    ],
    "total_files": 505
}