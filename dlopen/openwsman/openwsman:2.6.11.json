{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-openwsman-2.6.11-urnjctbu3pjxgiqzjtqviczvlqse3qms/spack-src/src/lib/wsman-plugins.c": "/*******************************************************************************\n * Copyright (C) 2004-2006 Intel Corp. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *  - Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *\n *  - Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n *  - Neither the name of Intel Corp. nor the names of its\n *    contributors may be used to endorse or promote products derived from this\n *    software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL Intel Corp. OR THE CONTRIBUTORS\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *******************************************************************************/\n\n/**\n * @author Anas Nashif\n */\n\n\n#ifdef HAVE_CONFIG_H\n#include <wsman_config.h>\n#endif\n\n#include \"stdlib.h\"\n#include \"stdio.h\"\n#include <string.h>\n#ifdef HAVE_DIRENT_H\n#include <dirent.h>\n#endif\n\n#ifndef WIN32\n#include <dlfcn.h>\n#endif\n#include \"u/libu.h\"\n#include \"wsman-plugins.h\"\n\n\n\nstatic list_t*\nscan_files_in_dir ( const char *dir, int (*select)(const struct dirent *))\n{\n    struct dirent **namelist;\n    int n;\n    list_t *files = list_create(LISTCOUNT_T_MAX);\n\n    if (0 > (n = scandir (dir, &namelist, 0, alphasort)))\n    {\n        return files;\n    } else {\n        while (n--)\n        {\n\t\t\tlnode_t *node;\n            char *tmp = u_strdup(namelist[n]->d_name);\n            node = lnode_create(tmp);\n            list_append(files, node );\n            //debug(\"plugin file found: %s\", namelist[n]->d_name );\n            u_free(namelist[n]);\n        }\n        u_free(namelist);\n    }\n    return files;\n}\n\n\nstatic WsManPlugin*\nplugin_new(void)\n{\n    WsManPlugin *self = u_malloc(sizeof(WsManPlugin));\n    if (self) {\n        memset(self, 0, sizeof(WsManPlugin));\n    }\n    return self ;\n}\n\nstatic void\nplugin_free(WsManPlugin *self)\n{\n    message( \"Un-loading plugins: %s\", self->p_name );\n\n    if( self->p_handle && self->cleanup ) {\n        (*self->cleanup)( self->p_handle, self->data );\n    }\n    if(self->p_name)\n        u_free(self->p_name);\n    if( self->p_handle )\n        dlclose( self->p_handle );\n}\n\nstatic WsManPluginError\nplugin_init(WsManPlugin *self, const char *p_name)\n{\n    WsManPluginError PluginError = PLUGIN_ERROR_OK ;\n    self->p_name = u_strdup(p_name) ;\n    if (NULL != (self->p_handle = dlopen(p_name, RTLD_LAZY))) {\n        self->init = dlsym(self->p_handle, \"init\");\n        self->get_endpoints = dlsym(self->p_handle, \"get_endpoints\");\n        if ( ! self->get_endpoints\n                && ! self->init)\n        {\n            self->init\t\t\t        = 0 ;\n\t    PluginError = PLUGIN_ERROR_SYMBOLSNOTFOUND ;\n        }\n    } else {\n        PluginError = PLUGIN_ERROR_NOTLOADED ;\n    }\n    return PluginError ;\n}\n\nstatic int\nload_plugin(WsManPlugin *self, const char *p_name)\n{\n    int retv = -1;\n    WsManPluginError err = plugin_init(self, p_name);\n    const char\t*plugin_err = dlerror();\n    message(\"Loading plugin: %s\", p_name );\n\n\tif( NULL == plugin_err )\n        plugin_err = \"\";\n    switch( err )\n    {\n    default:\n        debug(  \"Unable to load plugin %s. Error: %s\", p_name, plugin_err );\n        break;\n    case PLUGIN_ERROR_NOTLOADED:\n        debug( \"Unable to load plugin %s. Error: %s\", p_name, plugin_err );\n        break;\n    case PLUGIN_ERROR_SYMBOLSNOTFOUND:\n        debug( \"Plugin protocol %s unknown Error:%s\", p_name, plugin_err );\n        break;\n    case PLUGIN_ERROR_INITFAILED:\n        debug(\"Unable to start plugin %s\", p_name );\n        break;\n    case PLUGIN_ERROR_BADPARMS:\n        debug( \"Bad parameters to plugin %s. Error: %s\", p_name, plugin_err );\n        break;\n    case PLUGIN_ERROR_OK:\n        retv = 0 ;\n        break;\n    }\n    if( retv < 0  )\n        debug(\"Unable to load plugin %s.Error: %s\", p_name, plugin_err);\n    return retv ;\n}\n\nstatic void\nfree_plugins(list_t * plugin_list)\n{\n\tlnode_t *p;\n    if (plugin_list == NULL) {\n        return;\n    }\n    if (list_isempty(plugin_list)) {\n        return;\n    }\n    p = list_first(plugin_list);\n    while (p) {\n         WsManPlugin *plugin = (WsManPlugin *)p->list_data;\n         plugin_free(plugin);\n         p = list_next(plugin_list, p);\n    }\n    list_destroy_nodes(plugin_list);\n    list_destroy(plugin_list);\n}\n\nstatic int\nselect_all_files (const struct dirent *e)\n{\n    return 1;\n}\n\nstatic void\nscan_plugins_in_directory ( WsManListenerH *listener,\n                            const char *dir_name)\n{\n\tlist_t *files = scan_files_in_dir ( dir_name, select_all_files);\n\tlnode_t *node = list_first(files);\n    listener->plugins = list_create(LISTCOUNT_T_MAX);\n\n    while (node != NULL)\n    {\n        const char* entry_name;\n        int retv = -1;\n        entry_name = (const char*) node->list_data;\n        node = list_next(files, node);\n\n        if ((NULL != entry_name) && strlen (entry_name) > strlen(PLUGIN_EXT)\n                && (0 == strcmp (&entry_name[strlen(entry_name)-strlen(PLUGIN_EXT)], PLUGIN_EXT)))\n        {\n            char *plugin_path = u_strdup_printf (\"%s/%s\", dir_name, entry_name);\n            WsManPlugin *plugin = plugin_new();\n\n            if ((NULL != plugin) && (NULL != plugin_path))\n            {\n                if (load_plugin(plugin, plugin_path) == 0 )\n                {\n                    lnode_t *plg = lnode_create (plugin);\n                    list_append (listener->plugins, plg);\n                    retv = 0 ;\n                }\n            } else {\n                error(\"Out of memory scanning for plugins.\");\n            }\n            if (plugin_path)\n            \tu_free (plugin_path);\n            if (retv != 0  && (NULL != plugin))\n                plugin_free(plugin);\n        }\n    }\n    list_destroy_nodes(files);\n    list_destroy(files);\n    return;\n}\n\nint\nwsman_plugins_load(WsManListenerH *listener)\n{\n    char *plugin_dir = iniparser_getstring(listener->config, \"server:plugin_dir\", PACKAGE_PLUGIN_DIR);\n    debug(\"using plugin directory: %s\", plugin_dir);\n    scan_plugins_in_directory(listener, plugin_dir);\n    return 0;\n}\n\nint\nwsman_plugins_unload(WsManListenerH *listener)\n{\n\n    free_plugins(listener->plugins);\n    // list_destroy(listener->plugins);\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-openwsman-2.6.11-urnjctbu3pjxgiqzjtqviczvlqse3qms/spack-src/src/lib/wsman-soap.c": "/*******************************************************************************\n * Copyright (C) 2004-2006 Intel Corp. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *  - Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *\n *  - Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n *  - Neither the name of Intel Corp. nor the names of its\n *    contributors may be used to endorse or promote products derived from this\n *    software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL Intel Corp. OR THE CONTRIBUTORS\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *******************************************************************************/\n\n/**\n * @author Anas Nashif\n * @author Eugene Yarmosh\n * @author Liang Hou\n */\n\n#ifdef HAVE_CONFIG_H\n#include <wsman_config.h>\n#endif\n\n#define _GNU_SOURCE\n\n#include \"u/libu.h\"\n#include \"wsman-xml-api.h\"\n#include \"wsman-soap.h\"\n#include \"wsman-xml.h\"\n#include \"wsman-dispatcher.h\"\n#include \"wsman-xml-serializer.h\"\n#include \"wsman-xml-serialize.h\"\n#include \"wsman-soap-envelope.h\"\n#include \"wsman-faults.h\"\n#include \"wsman-soap-message.h\"\n\n#include \"wsman-client-api.h\"\n#include \"wsman-client-transport.h\"\n\n/*    ENUMERATION  */\n#define ENUM_EXPIRED(enuminfo, mytime) \\\n\t((enumInfo->expires > 0) &&        \\\n\t(enumInfo->expires > mytime))\n\n\n\n/**\n * Calculate needed space for interface array with Endpoints\n * @param interfaces List of interfaces\n * @return Needed size of WsManDispatcherInfo\n */\nstatic int\ncalculate_map_count(list_t * interfaces)\n{\n\tint             count = 0;\n\tint             j;\n\n\tlnode_t        *node = list_first(interfaces);\n\twhile (node) {\n\t\tWsDispatchInterfaceInfo *ifc =\n\t\t\t(WsDispatchInterfaceInfo *) node->list_data;\n\t\tfor (j = 0; ifc->endPoints[j].serviceEndPoint != NULL; j++)\n\t\t\tcount++;\n\t\tnode = list_next(interfaces, node);\n\t}\n\n\treturn (list_count(interfaces) * sizeof(WsManDispatcherInfo))\n\t\t+ (count * sizeof(DispatchToEpMap));\n}\n\n/**\n * Register Dispatcher\n * @param cntx Context\n * @param proc Dispatcher Callback\n * @param data Callback data\n */\nstatic void\nws_register_dispatcher(WsContextH cntx, DispatcherCallback proc, void *data)\n{\n\tSoapH soap = ws_context_get_runtime(cntx);\n\tif (soap) {\n\t\tsoap->dispatcherProc = proc;\n\t\tsoap->dispatcherData = data;\n\t}\n\treturn;\n}\n\nstatic int\nset_context_val(WsContextH cntx,\n\t\tchar *name,\n\t\tvoid *val,\n\t\tint size,\n\t\tint no_dup,\n\t\tunsigned long type)\n{\n\tint retVal = 1;\n\tdebug(\"Setting context value: %s\", name);\n\tif (cntx && name) {\n\t\tvoid *ptr = val;\n\n\t\tif (!no_dup) {\n\t\t\tif (val && (ptr = u_malloc(size))) {\n\t\t\t\tmemcpy(ptr, val, size);\n\t\t\t}\n\t\t}\n\t\tif (ptr || val == NULL) {\n\t\t\tu_lock(cntx->soap);\n\t\t\tws_remove_context_val(cntx, name);\n\t\t\tif (create_context_entry(cntx->entries, name, ptr)) {\n\t\t\t\tretVal = 0;\n\t\t\t}\n\t\t\tu_unlock(cntx->soap);\n\t\t}\n\t} else {\n\t\terror(\"error setting context value.\");\n\t}\n\treturn retVal;\n}\n\n\nstatic void\nfree_hentry_func(hnode_t * n, void *arg)\n{\n\tu_free((void*)hnode_getkey(n));\n\tu_free(n);\n}\n\n\nstatic void\nremove_locked_enuminfo(WsContextH cntx,\n                       WsEnumerateInfo * enumInfo)\n{\n\tu_lock(cntx->soap);\n\tif (!(enumInfo->flags & WSMAN_ENUMINFO_INWORK_FLAG)) {\n\t\terror(\"locked enuminfo unlocked\");\n\t\tu_unlock(cntx->soap);\n\t\treturn;\n\t}\n\thash_delete_free(cntx->enuminfos,\n\t\thash_lookup(cntx->enuminfos, enumInfo->enumId));\n\tu_unlock(cntx->soap);\n}\n\n#ifdef ENABLE_EVENTING_SUPPORT\nstatic void wsman_expiretime2xmldatetime(unsigned long expire, char *str)\n{\n\ttime_t t = expire;\n\tstruct tm tm;\n\tlocaltime_r(&t, &tm);\n\tsnprintf(str, 30, \"%u-%u%u-%u%uT%u%u:%u%u:%u%u+%u%u:%u%u\",\n\t\t\ttm.tm_year + 1900, (tm.tm_mon + 1)/10, (tm.tm_mon + 1)%10,\n\t\t\ttm.tm_mday/10, tm.tm_mday%10, tm.tm_hour/10, tm.tm_hour%10,\n\t\t\ttm.tm_min/10, tm.tm_min%10, tm.tm_sec/10, tm.tm_sec%10,\n\t\t\t0, 0, 0,0);\n\n}\n\nstatic void delete_notification_info(WsNotificationInfoH notificationInfo) {\n\tif(notificationInfo) {\n\t\tws_xml_destroy_doc(notificationInfo->EventContent);\n\t\tws_xml_destroy_doc(notificationInfo->headerOpaqueData);\n\t\tu_free(notificationInfo->EventAction);\n\t\tu_free(notificationInfo);\n\t}\n}\n#endif\n\n\nstatic WsSubscribeInfo*\nsearch_pull_subs_info(SoapH soap, WsXmlDocH indoc)\n{\n\tWsSubscribeInfo *subsInfo = NULL;\n\tchar *uuid = NULL;\n\tlnode_t *lnode;\n\tWsContextH soapCntx = ws_get_soap_context(soap);\n\tWsXmlNodeH node = ws_xml_get_soap_body(indoc);\n\n\tnode = ws_xml_get_child(node, 0, XML_NS_ENUMERATION, WSENUM_PULL);\n\tif(node) {\n\t\tnode = ws_xml_get_child(node, 0, XML_NS_ENUMERATION, WSENUM_ENUMERATION_CONTEXT);\n\t\tuuid = ws_xml_get_node_text(node);\n\t}\n\tif(uuid == NULL) return subsInfo;\n\tif (pthread_mutex_lock(&soap->lockSubs))\n\t{\n\t\terror(\"Error: Can't lock soap->lockSubs\");\n\t\treturn NULL;\n\t}\n\tlnode = list_first(soapCntx->subscriptionMemList);\n\twhile(lnode) {\n\t\tsubsInfo = (WsSubscribeInfo *)lnode->list_data;\n\t\tif(!strcmp(subsInfo->subsId, uuid+5)) break;\n\t\tlnode = list_next(soapCntx->subscriptionMemList, lnode);\n\t}\n\tif (pthread_mutex_unlock(&soap->lockSubs))\n\t{\n\t\terror(\"Error: Can't unlock soap->lockSubs\");\n\t\treturn NULL;\n\t}\n\tif(lnode == NULL) return NULL;\n\treturn subsInfo;\n}\n\n\nstatic WsXmlDocH\ncreate_enum_info(SoapOpH op,\n\t\t WsContextH epcntx,\n              \t WsXmlDocH indoc,\n\t\t WsEnumerateInfo **eInfo)\n{\n\tWsXmlNodeH node = ws_xml_get_soap_body(indoc);\n\tWsXmlNodeH header = ws_xml_get_soap_header(indoc);\n\tWsXmlDocH outdoc = NULL;\n\tWsXmlNodeH enumnode = NULL;\n\tWsEnumerateInfo *enumInfo;\n\tWsmanMessage *msg = wsman_get_msg_from_op(op);\n\tWsmanFaultCodeType fault_code = WSMAN_RC_OK;\n\tWsmanFaultDetailType fault_detail_code = WSMAN_DETAIL_OK;\n\tchar *uri, *to;\n\n\tenumInfo = (WsEnumerateInfo *)u_zalloc(sizeof (WsEnumerateInfo));\n\tif (enumInfo == NULL) {\n\t\terror(\"No memory\");\n\t\tfault_code = WSMAN_INTERNAL_ERROR;\n\t\tgoto DONE;\n\t}\n\tenumInfo->encoding = u_strdup(msg->charset);\n\tenumInfo->maxsize = wsman_get_maxsize_from_op(op);\n\tif(enumInfo->maxsize == 0) {\n\t\tenumnode = ws_xml_get_child(node, 0, XML_NS_ENUMERATION, WSENUM_ENUMERATE);\n\t\tenumInfo->maxsize = ws_deserialize_uint32(NULL, enumnode,\n\t\t\t\t\t     0, XML_NS_ENUMERATION,\n\t\t\t\t\t     WSENUM_MAX_CHARACTERS);\n\t}\n\tenumInfo->releaseproc = wsman_get_release_endpoint(epcntx, indoc);\n\tto = ws_xml_get_node_text(\n\t\t\tws_xml_get_child(header, 0, XML_NS_ADDRESSING, WSA_TO));\n\turi =  ws_xml_get_node_text(\n\t\t\tws_xml_get_child(header, 0, XML_NS_WS_MAN, WSM_RESOURCE_URI));\n\n\tenumInfo->epr_to = u_strdup(to);\n\tenumInfo->epr_uri = u_strdup(uri);\n\tnode = ws_xml_get_child(node, 0, XML_NS_ENUMERATION, WSENUM_ENUMERATE);\n\tnode = ws_xml_get_child(node, 0, XML_NS_ENUMERATION, WSENUM_EXPIRES);\n\tif (node == NULL) {\n\t\tdebug(\"No wsen:Expires\");\n\t\tenumInfo->expires = 0;\n\t} else {\n\t\twsman_set_expiretime(node, &(enumInfo->expires), &fault_code);\n\t\tif (fault_code != WSMAN_RC_OK) {\n\t\t\tfault_detail_code = WSMAN_DETAIL_EXPIRATION_TIME;\n\t\t\tgoto DONE;\n\t\t}\n\t}\n\n\tif (msg->auth_data.username != NULL) {\n\t\tenumInfo->auth_data.username =\n\t\t\t\tu_strdup(msg->auth_data.username);\n\t\tenumInfo->auth_data.password =\n\t\t\t\tu_strdup(msg->auth_data.password);\n\t} else {\n\t\tenumInfo->auth_data.username = NULL;\n\t\tenumInfo->auth_data.password = NULL;\n\t}\n\tgenerate_uuid(enumInfo->enumId, EUIDLEN, 1);\n\nDONE:\n\tif (fault_code != WSMAN_RC_OK) {\n\t\toutdoc = wsman_generate_fault(indoc, fault_code, fault_detail_code, NULL);\n\t\tu_free(enumInfo);\n                *eInfo = NULL;\n\t} else {\n\t\t*eInfo = enumInfo;\n\t}\n\treturn outdoc;\n}\n\nstatic void\ndestroy_enuminfo(WsEnumerateInfo * enumInfo)\n{\n\tdebug(\"destroy enuminfo\");\n\tu_free(enumInfo->auth_data.username);\n\tu_free(enumInfo->auth_data.password);\n\tu_free(enumInfo->epr_to);\n\tu_free(enumInfo->epr_uri);\n\tu_free(enumInfo->encoding);\n\tif (enumInfo->filter)\n\t\tfilter_destroy(enumInfo->filter);\n\tu_free(enumInfo);\n}\n\nstatic int\nwsman_verify_enum_info(SoapOpH op,\n\t\t       WsEnumerateInfo * enumInfo,\n\t\t       WsXmlDocH doc,\n\t\t       WsmanStatus * status)\n{\n\n\tWsmanMessage *msg = wsman_get_msg_from_op(op);\n\tWsXmlNodeH header = ws_xml_get_soap_header(doc);\n\n\tchar *to = ws_xml_get_node_text(ws_xml_get_child(header, 0,\n\t\t\tXML_NS_ADDRESSING, WSA_TO));\n\tchar *uri= ws_xml_get_node_text(ws_xml_get_child(header, 0,\n\t\t\tXML_NS_WS_MAN, WSM_RESOURCE_URI));\n\n\tif (strcmp(enumInfo->epr_to, to) != 0 ||\n\t\t\tstrcmp(enumInfo->epr_uri, uri) != 0 ) {\n\t\tstatus->fault_code = WSA_MESSAGE_INFORMATION_HEADER_REQUIRED;\n\t\tstatus->fault_detail_code = 0;\n\t\tdebug(\"verifying enumeration context: ACTUAL  uri: %s, to: %s\", uri, to);\n\t\tdebug(\"verifying enumeration context: SHOULD uri: %s, to: %s\",\n\t\t\t\tenumInfo->epr_uri, enumInfo->epr_to);\n\t\treturn 0;\n\t}\n\n\tif (msg->auth_data.username && msg->auth_data.password) {\n\t\tif (strcmp(msg->auth_data.username,\n\t\t\t\tenumInfo->auth_data.username) != 0 &&\n\t\t\t\tstrcmp(msg->auth_data.password,\n\t\t\t\tenumInfo->auth_data.password) != 0) {\n\t\t\tstatus->fault_code = WSMAN_ACCESS_DENIED;\n\t\t\tstatus->fault_detail_code = 0;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\n\n\nstatic int\ninsert_enum_info(WsContextH cntx,\n\t\tWsEnumerateInfo *enumInfo)\n{\n\tstruct timeval tv;\n\tint retVal = 1;\n\n\tu_lock(cntx->soap);\n\tgettimeofday(&tv, NULL);\n\tenumInfo->timeStamp = tv.tv_sec;\n\tif (create_context_entry(cntx->enuminfos, enumInfo->enumId, enumInfo)) {\n\t\tretVal = 0;\n\t}\n\tu_unlock(cntx->soap);\n\treturn retVal;\n}\n\n\n\nstatic WsEnumerateInfo *\nget_locked_enuminfo(WsContextH cntx,\n                    WsXmlDocH doc,\n                    SoapOpH op,\n                    char *action,\n                    WsmanStatus *status)\n{\n\thnode_t *hn;\n\tWsEnumerateInfo *eInfo = NULL;\n\tchar *enumId = NULL;\n\tWsXmlNodeH node = ws_xml_get_soap_body(doc);\n\n\tif (node && (node = ws_xml_get_child(node,\n\t\t\t0, XML_NS_ENUMERATION, action))) {\n\t\tnode = ws_xml_get_child(node, 0,\n\t\t\tXML_NS_ENUMERATION, WSENUM_ENUMERATION_CONTEXT);\n\t\tif (node) {\n\t\t\tenumId = ws_xml_get_node_text(node);\n\t\t}\n\t}\n\tdebug(\"enum context: %s\", enumId);\n\n\tif (enumId == NULL) {\n\t\tstatus->fault_code = WSEN_INVALID_ENUMERATION_CONTEXT;\n\t\treturn NULL;\n\t}\n\tu_lock(cntx->soap);\n\thn = hash_lookup(cntx->enuminfos, enumId);\n\tif (hn) {\n\t\teInfo = (WsEnumerateInfo *)hnode_get(hn);\n\t\tif (strcmp(eInfo->enumId, enumId)) {\n\t\t\terror(\"enum context mismatch: %s == %s\",\n\t\t\t     eInfo->enumId, enumId);\n\t\t\tstatus->fault_code = WSMAN_INTERNAL_ERROR;\n\t\t} else if (wsman_verify_enum_info(op, eInfo, doc,status)) {\n\t\t\tif (eInfo->flags & WSMAN_ENUMINFO_INWORK_FLAG) {\n\t\t\t\tstatus->fault_code = WSMAN_CONCURRENCY;\n\t\t\t} else {\n\t\t\t\teInfo->flags |= WSMAN_ENUMINFO_INWORK_FLAG;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tstatus->fault_code = WSEN_INVALID_ENUMERATION_CONTEXT;\n\t}\n\n\tif (status->fault_code != WSMAN_RC_OK) {\n\t\teInfo = NULL;\n\t}\n\tu_unlock(cntx->soap);\n\treturn eInfo;\n}\n\nstatic void\nunlock_enuminfo(WsContextH cntx, WsEnumerateInfo *enumInfo)\n{\n\tstruct timeval tv;\n\tgettimeofday(&tv, NULL);\n\tu_lock(cntx->soap);\n\tif (!(enumInfo->flags & WSMAN_ENUMINFO_INWORK_FLAG)) {\n\t\terror(\"locked enuminfo unlocked\");\n\t\tu_unlock(cntx->soap);\n\t\treturn;\n\t}\n\tenumInfo->flags &= ~WSMAN_ENUMINFO_INWORK_FLAG;\n\tenumInfo->timeStamp = tv.tv_sec;\n\tu_unlock(cntx->soap);\n}\n\nstatic void\nws_clear_context_entries(WsContextH hCntx)\n{\n\thash_t *h;\n\tif (!hCntx) {\n\t\treturn;\n\t}\n\th = hCntx->entries;\n\thash_free(h);\n}\n\nstatic void\nws_clear_context_enuminfos(WsContextH hCntx)\n{\n\thash_t *h;\n\tif (!hCntx) {\n\t\treturn;\n\t}\n\th = hCntx->enuminfos;\n\thash_free(h);\n}\n\ncallback_t *\nmake_callback_entry(SoapServiceCallback proc,\n\t\t    void *data,\n\t\t    list_t * list_to_add)\n{\n\tcallback_t *entry = (callback_t *) u_malloc(sizeof(callback_t));\n\tdebug(\"make new callback entry\");\n\tif (entry) {\n\t\tlnode_init(&entry->node, data);\n\t\tentry->proc = proc;\n\t\tif (list_to_add || (list_to_add = list_create(LISTCOUNT_T_MAX))) {\n\t\t\tlist_append(list_to_add, &entry->node);\n\t\t} else {\n\t\t\tu_free(entry);\n\t\t\treturn NULL;\n\t\t}\n\t} else {\n\t\treturn NULL;\n\t}\n\treturn entry;\n}\n\n\n\nvoid\nws_initialize_context(WsContextH cntx, SoapH soap)\n{\n\tcntx->entries = hash_create(HASHCOUNT_T_MAX, NULL, NULL);\n\tif (cntx->entries) {\n\t\thash_set_allocator(cntx->entries, NULL, free_hentry_func, NULL);\n\t}\n\n\tcntx->enuminfos = hash_create(HASHCOUNT_T_MAX, NULL, NULL);\n\tcntx->subscriptionMemList = list_create(LISTCOUNT_T_MAX);\n\tif (cntx->enuminfos) {\n\t\thash_set_allocator(cntx->enuminfos, NULL, free_hentry_func, NULL);\n\t}\n\tcntx->owner = 1;\n\tcntx->soap = soap;\n\tcntx->serializercntx = ws_serializer_init();\n}\n\nWsContextH\nws_create_context(SoapH soap)\n{\n\tWsContextH cntx = (WsContextH) u_zalloc(sizeof (*cntx));\n\tif (cntx) {\n\t\tws_initialize_context(cntx, soap);\n\t}\n\treturn cntx;\n}\n\nSoapH\nws_soap_initialize()\n{\n\tSoapH soap = (SoapH) u_zalloc(sizeof(*soap));\n\n\tif (soap == NULL) {\n\t\terror(\"Could not alloc memory\");\n\t\treturn NULL;\n\t}\n\tsoap->cntx = ws_create_context(soap);\n\n\tsoap->inboundFilterList = NULL;\n\tsoap->outboundFilterList = NULL;\n\tsoap->dispatchList = NULL;\n\tsoap->processedMsgIdList = NULL;\n\n\tu_init_lock(soap);\n\tu_init_lock(&soap->lockSubs);\n\tws_xml_parser_initialize();\n\n\tsoap_add_filter(soap, outbound_addressing_filter, NULL, 0);\n\tsoap_add_filter(soap, outbound_control_header_filter, NULL, 0);\n\treturn soap;\n}\n\nvoid\nws_set_context_enumIdleTimeout(WsContextH cntx,\n                               unsigned long timeout)\n{\n\tcntx->enumIdleTimeout = timeout;\n}\n\n\n\nWsContextH\nws_create_runtime(list_t * interfaces)\n{\n\tSoapH soap = ws_soap_initialize();\n\tWsManDispatcherInfo *dispInfo;\n\tint size;\n\tlnode_t *node;\n\tif (soap == NULL) {\n\t\terror(\"Could not initialize soap\");\n\t\treturn NULL;\n\t}\n\n\tif (interfaces == NULL) {\n\t\treturn soap->cntx;\n\t}\n\n\tsize = calculate_map_count(interfaces);\n\tdispInfo = (WsManDispatcherInfo *) u_zalloc(size);\n\tif (dispInfo == NULL) {\n\t\terror(\"Could not allocate memory\");\n\t\tsoap_destroy(soap);\n\t\treturn NULL;\n\t}\n\tdebug(\"Registering %d plugins\", (int) list_count(interfaces));\n\tdispInfo->interfaceCount = list_count(interfaces);\n\tdispInfo->interfaces = interfaces;\n\tnode = list_first(interfaces);\n\twhile (node != NULL) {\n\t        WsDispatchInterfaceInfo *wdii = (WsDispatchInterfaceInfo *) node->list_data;\n\t\tif (wsman_register_interface(soap->cntx, wdii, dispInfo) != 0) {\n\t\t\terror(\"Interface registration failed for %s\", wdii->displayName);\n\t\t\tu_free(dispInfo);\n\t\t\tsoap_destroy(soap);\n\t\t\treturn NULL;\n\t\t}\n\t\tnode = list_next(interfaces, node);\n\t}\n\tws_register_dispatcher(soap->cntx, wsman_dispatcher, dispInfo);\n\treturn soap->cntx;\n}\n\n\n\n\n/**\n * Register Dispatcher Interfaces\n * @param cntx WS-Man Context\n * @param wsInterface Interface\n * @param dispinfo Dispatcher\n */\nint\nwsman_register_interface(WsContextH cntx,\n\t\t\t WsDispatchInterfaceInfo * wsInterface,\n\t\t\t WsManDispatcherInfo * dispInfo)\n{\n\tint i, retVal = 0;\n\tWsDispatchEndPointInfo *ep = wsInterface->endPoints;\n\n\tfor (i = 0; ep[i].serviceEndPoint != NULL; i++) {\n\t\tif ((retVal = wsman_register_endpoint(cntx, wsInterface,\n\t\t\t\t\t\t  &ep[i], dispInfo)) != 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn retVal;\n}\n\n\n/*\n * Register Endpoint\n * @param cntx Context\n * @param wsInterface Interface\n * @param ep Endpoint\n * @param dispInfo Dispatcher information\n */\nint\nwsman_register_endpoint(WsContextH cntx,\n\t\t\tWsDispatchInterfaceInfo *wsInterface,\n\t\t\tWsDispatchEndPointInfo *ep,\n\t\t\tWsManDispatcherInfo *dispInfo)\n{\n\tSoapDispatchH   disp = NULL;\n\tunsigned long   flags = SOAP_CUSTOM_DISPATCHER;\n\tSoapServiceCallback callbackProc = NULL;\n\tSoapH soap = ws_context_get_runtime(cntx);\n\tchar *action = NULL;\n\n\tdebug(\"Registering Endpoint: %s\", ep->inAction ? ep->inAction : \"<null>\");\n\tswitch (ep->flags & WS_DISP_TYPE_MASK) {\n\tcase WS_DISP_TYPE_IDENTIFY:\n\t\tdebug(\"Registering endpoint for Identify\");\n\t\taction = ep->inAction;\n\t\tcallbackProc = wsman_identify_stub;\n\t\tbreak;\n\tcase WS_DISP_TYPE_ENUMERATE:\n\t\tdebug(\"Registering endpoint for Enumerate\");\n\t\taction = ep->inAction;\n\t\tcallbackProc = wsenum_enumerate_stub;\n\t\tbreak;\n\tcase WS_DISP_TYPE_RELEASE:\n\t\tdebug(\"Registering endpoint for Release\");\n\t\taction = ep->inAction;\n\t\tcallbackProc = wsenum_release_stub;\n\t\tbreak;\n\tcase WS_DISP_TYPE_DELETE:\n\t\tdebug(\"Registering endpoint for Delete\");\n\t\taction = ep->inAction;\n\t\tcallbackProc = ws_transfer_delete_stub;\n\t\tbreak;\n\tcase WS_DISP_TYPE_PULL:\n\t\tdebug(\"Registering endpoint for Pull\");\n\t\taction = ep->inAction;\n\t\tcallbackProc = wsenum_pull_stub;\n\t\tbreak;\n\tcase WS_DISP_TYPE_DIRECT_PULL:\n\t\tdebug(\"Registering endpoint for direct Pull\");\n\t\taction = ep->inAction;\n\t\tcallbackProc = wsenum_pull_direct_stub;\n\t\tbreak;\n\tcase WS_DISP_TYPE_GET:\n\t\tdebug(\"Registering endpoint for Get\");\n\t\taction = ep->inAction;\n\t\tcallbackProc = ws_transfer_get_stub;\n\t\tbreak;\n\tcase WS_DISP_TYPE_DIRECT_GET:\n\t\tdebug(\"Registering endpoint for direct Get\");\n\t\taction = ep->inAction;\n\t\tcallbackProc = (SoapServiceCallback) ep->serviceEndPoint;\n\t\tbreak;\n\tcase WS_DISP_TYPE_DIRECT_DELETE:\n\t\tdebug(\"Registering endpoint for Delete\");\n\t\taction = ep->inAction;\n\t\tcallbackProc = (SoapServiceCallback) ep->serviceEndPoint;\n\t\tbreak;\n\tcase WS_DISP_TYPE_DIRECT_PUT:\n\t\tdebug(\"Registering endpoint for direct Put\");\n\t\taction = ep->inAction;\n\t\tcallbackProc = (SoapServiceCallback) ep->serviceEndPoint;\n\t\tbreak;\n\tcase WS_DISP_TYPE_DIRECT_CREATE:\n\t\tdebug(\"Registering endpoint for direct Create\");\n\t\taction = ep->inAction;\n\t\tcallbackProc = (SoapServiceCallback) ep->serviceEndPoint;\n\t\tbreak;\n\tcase WS_DISP_TYPE_PUT:\n\t\tdebug(\"Registering endpoint for Put\");\n\t\taction = ep->inAction;\n\t\tcallbackProc = ws_transfer_put_stub;\n\t\tbreak;\n#ifdef ENABLE_EVENTING_SUPPORT\n\tcase WS_DISP_TYPE_SUBSCRIBE:\n\t\tdebug(\"Registering endpoint for Subscribe\");\n\t\taction = ep->inAction;\n\t\tcallbackProc = wse_subscribe_stub;\n\t\tbreak;\n\tcase WS_DISP_TYPE_UNSUBSCRIBE:\n\t\tdebug(\"Registering endpoint for Unsubscribe\");\n\t\taction = ep->inAction;\n\t\tcallbackProc = wse_unsubscribe_stub;\n\t\tbreak;\n\tcase WS_DISP_TYPE_RENEW:\n\t\taction = ep->inAction;\n\t\tcallbackProc = wse_renew_stub;\n\t\tbreak;\n#endif\n\tcase WS_DISP_TYPE_RAW_DOC:\n\t\taction = ep->inAction;\n\t\tcallbackProc = (SoapServiceCallback) ep->serviceEndPoint;\n\t\tbreak;\n\tcase WS_DISP_TYPE_CUSTOM_METHOD:\n\t\tdebug(\"Registering endpoint for custom method\");\n\t\taction = ep->inAction;\n\t\tcallbackProc = (SoapServiceCallback) ep->serviceEndPoint;\n\t\tbreak;\n\n\tcase WS_DISP_TYPE_PRIVATE:\n\t\tdebug(\"Registering endpoint for private EndPoint\");\n\t\taction = ep->inAction;\n\t\tcallbackProc = (SoapServiceCallback) ep->serviceEndPoint;\n\t\tbreak;\n\n\tdefault:\n\t\tdebug(\"unknown dispatch type %lu\",\n\t\t\tep->flags & WS_DISP_TYPE_MASK);\n\t\tbreak;\n\t}\n\n\tif (callbackProc != NULL &&\n\t\t\t(disp = wsman_dispatch_create(soap, action, NULL, NULL, callbackProc, ep, flags))) {\n\t\tdispInfo->map[dispInfo->mapCount].ep = ep;\n\t\tdispInfo->map[dispInfo->mapCount].disp = disp;\n\t\tdispInfo->mapCount++;\n\t\twsman_dispatch_start(disp);\n\t}\n\tif (action && action != ep->inAction) {\n\t\tu_free(action);\n\t}\n\treturn (disp == NULL);\n}\n\n/*  ENDPOINTS STUBS */\n\nint\nwsman_identify_stub(SoapOpH op,\n\t\t    void *appData,\n\t\t\tvoid *opaqueData)\n{\n\tvoid           *data;\n\tWsXmlDocH       doc = NULL;\n\tWsContextH      cntx;\n\tWsDispatchEndPointInfo *info;\n\tXmlSerializerInfo *typeInfo;\n\tWsmanStatus    *status;\n\tSoapH           soap;\n\tWsEndPointGet   endPoint;\n\n\tsoap = soap_get_op_soap(op);\n\tif (soap == NULL) {\n\t\terror(\"soap_get_op_soap failed\");\n\t\treturn -1;\n\t}\n\n\tstatus = u_zalloc(sizeof(WsmanStatus *));\n\tcntx = ws_create_ep_context(soap, soap_get_op_doc(op, 1));\n\tif (cntx == NULL) {\n\t\terror(\"ws_create_ep_context failed\");\n\t\tu_free(status);\n\t\treturn -1;\n\t}\n\tinfo = (WsDispatchEndPointInfo *) appData;\n\ttypeInfo = info->serializationInfo;\n\tendPoint = (WsEndPointGet) info->serviceEndPoint;\n\tdebug(\"Identify called\");\n\n\tif ((data = endPoint(cntx, status, opaqueData)) == NULL) {\n\t\terror(\"Identify Fault\");\n\t\tdoc = wsman_generate_fault(soap_get_op_doc(op, 1), WSMAN_INTERNAL_ERROR, 0, NULL);\n\t} else {\n\t\tdoc = wsman_create_response_envelope(soap_get_op_doc(op, 1), NULL);\n\t\tws_serialize(cntx->serializercntx, ws_xml_get_soap_body(doc), data, typeInfo,\n\t\t\tWSMID_IDENTIFY_RESPONSE, (char *) info->data, NULL, 1);\n\t\tws_serializer_free_mem(cntx->serializercntx, data, typeInfo);\n                u_free(data);\n\t}\n\n\tif (doc) {\n\t\tsoap_set_op_doc(op, doc, 0);\n\t} else {\n\t\terror(\"Response doc invalid\");\n\t}\n\n\tws_destroy_context(cntx);\n\tu_free(status);\n\n\treturn 0;\n}\n\n\n\n\nint\nws_transfer_put_stub(SoapOpH op,\n\t\t     void *appData,\n\t\t\tvoid *opaqueData)\n{\n\tint             retVal = 0;\n\tWsXmlDocH       doc = NULL;\n\tvoid           *outData = NULL;\n\tWsmanStatus     status;\n\tSoapH           soap = soap_get_op_soap(op);\n\n\tif (soap == NULL) {\n\t\terror(\"soap_get_op_soap failed\");\n\t\treturn -1;\n\t}\n\n\tWsContextH   cntx = ws_create_ep_context(soap, soap_get_op_doc(op, 1));\n\tif (cntx == NULL) {\n\t\terror(\"ws_create_ep_context\");\n\t\treturn -1;\n\t}\n\tWsDispatchEndPointInfo *info = (WsDispatchEndPointInfo *) appData;\n\tXmlSerializerInfo *typeInfo = info->serializationInfo;\n\tWsEndPointPut   endPoint = (WsEndPointPut) info->serviceEndPoint;\n\n\tWsXmlDocH       _doc = soap_get_op_doc(op, 1);\n\tWsXmlNodeH      _body = ws_xml_get_soap_body(_doc);\n\tWsXmlNodeH      _r = ws_xml_get_child(_body, 0, NULL, NULL);\n\n\tvoid  *data = ws_deserialize(cntx->serializercntx, _body, typeInfo,\n\t\t\t\t\tws_xml_get_node_local_name(_r),\n\t\t\t    \t(char *) info->data, NULL, 0, 0);\n\n\tif ((retVal = endPoint(cntx, data, &outData, &status, opaqueData))) {\n\t\tdoc = wsman_generate_fault( _doc, status.fault_code,\n\t\t\t\t\t   status.fault_detail_code, NULL);\n\t} else {\n\t\tdoc = wsman_create_response_envelope(_doc, NULL);\n\t\tif (outData) {\n\t\t\tws_serialize(cntx->serializercntx, ws_xml_get_soap_body(doc), outData,\n\t\t\t\t     typeInfo, TRANSFER_PUT_RESP,\n                     (char *) info->data, NULL, 1);\n\t\t\tws_serializer_free_mem(cntx->serializercntx, outData, typeInfo);\n\t\t}\n\t}\n\n\tif (doc) {\n\t\tsoap_set_op_doc(op, doc, 0);\n\t}\n\tws_serializer_free_all(cntx->serializercntx);\n\tws_serializer_cleanup(cntx->serializercntx);\n\treturn retVal;\n}\n\n\n\n\nint\nws_transfer_delete_stub(SoapOpH op,\n\t\t     void *appData,\n\t\t\tvoid *opaqueData)\n{\n\tWsmanStatus     status;\n\tSoapH           soap = soap_get_op_soap(op);\n\n\tif (soap == NULL) {\n\t\terror(\"soap_get_op_soap failed\");\n\t\treturn -1;\n\t}\n\n\tWsContextH      cntx = ws_create_ep_context(soap,\n\t\t\t\t\tsoap_get_op_doc(op, 1));\n\n\tWsDispatchEndPointInfo *info = (WsDispatchEndPointInfo *) appData;\n\tWsEndPointGet   endPoint = (WsEndPointGet) info->serviceEndPoint;\n\n\tvoid           *data;\n\tWsXmlDocH       doc = NULL;\n\n\twsman_status_init(&status);\n\tif ((data = endPoint(cntx, &status, opaqueData)) == NULL) {\n\t\twarning(\"Transfer Delete fault\");\n\t\tdoc = wsman_generate_fault(soap_get_op_doc(op, 1),\n\t\t\t\t\t WSMAN_INVALID_SELECTORS, 0, NULL);\n\t} else {\n\t\tdebug(\"Creating Response doc\");\n\t\tdoc = wsman_create_response_envelope(soap_get_op_doc(op, 1), NULL);\n\t}\n\n\tif (doc) {\n\t\tsoap_set_op_doc(op, doc, 0);\n\t} else {\n\t\terror(\"Response doc invalid\");\n\t}\n\tws_destroy_context(cntx);\n\treturn 0;\n}\n\n\n\n\nint\nws_transfer_get_stub(SoapOpH op,\n\t\t     void *appData,\n\t\t\tvoid *opaqueData)\n{\n\tWsmanStatus     status;\n\n\n\tSoapH       soap = soap_get_op_soap(op);\n\n\tif (soap == NULL) {\n\t\terror(\"soap_get_op_soap failed\");\n\t\treturn -1;\n\t}\n\n\tWsContextH  cntx = ws_create_ep_context(soap, soap_get_op_doc(op, 1));\n\tif (cntx == NULL) {\n\t\terror(\"ws_create_ep_context failed\");\n\t\treturn -1;\n\t}\n\tWsDispatchEndPointInfo *info = (WsDispatchEndPointInfo *) appData;\n\tXmlSerializerInfo *typeInfo = info->serializationInfo;\n\tWsEndPointGet   endPoint = (WsEndPointGet) info->serviceEndPoint;\n\n\tvoid           *data;\n\tWsXmlDocH       doc = NULL;\n\n\twsman_status_init(&status);\n\tif ((data = endPoint(cntx, &status, opaqueData)) == NULL) {\n\t\twarning(\"Transfer Get fault\");\n\t\tdoc = wsman_generate_fault( soap_get_op_doc(op, 1),\n\t\t\t\t\t WSMAN_INVALID_SELECTORS, 0, NULL);\n\t} else {\n\t\tdebug(\"Creating Response doc\");\n\t\tdoc = wsman_create_response_envelope(soap_get_op_doc(op, 1), NULL);\n\n\t\tws_serialize(cntx->serializercntx, ws_xml_get_soap_body(doc), data, typeInfo,\n\t\t\t TRANSFER_GET_RESP, (char *) info->data, NULL, 1);\n\t\tws_serializer_free_mem(cntx->serializercntx, data, typeInfo);\n\t}\n\n\tif (doc) {\n\t\tdebug(\"Setting operation document\");\n\t\tsoap_set_op_doc(op, doc, 0);\n\t} else {\n\t\twarning(\"Response doc invalid\");\n\t}\n\n\tws_destroy_context(cntx);\n\treturn 0;\n}\n\n\n\nWsmanMessage *wsman_get_msg_from_op(SoapOpH op)\n{\n\top_t *_op = (op_t *)op;\n\tWsmanMessage *msg = (WsmanMessage *)_op->data;\n\treturn msg;\n}\n\nunsigned long wsman_get_maxsize_from_op(SoapOpH op)\n{\n\top_t *_op = (op_t *)op;\n\treturn _op->maxsize;\n}\n\nstatic\nunsigned long get_total_enum_context(WsContextH cntx){\n        hscan_t hs;\n        u_lock(cntx->soap);\n        hash_scan_begin(&hs, cntx->enuminfos);\n        unsigned long total = hash_count(hs.hash_table);\n        u_unlock(cntx->soap);\n        return total;\n}\n\n/**\n * The following extern methods are defined in wsmand-daemon.c,\n * which is compiled into openwsmand binary, which in turn links\n * to libwsman.la. So when a call is made to the following methods\n * from the openwsmand binary, they should be present.\n *\n * However, if they are dlopened from somewhere other than \n * openwsmand library or linked to some other\n * binary or shared object, then these methods may or may not be\n * preset, hence marking them as weak symbols and testing to see\n * if they are resolved before using them.\n */\n#pragma weak wsmand_options_get_max_threads\nextern int wsmand_options_get_max_threads(void);\n#pragma weak wsmand_options_get_max_connections_per_thread\nextern int wsmand_options_get_max_connections_per_thread(void);\n\n/**\n * Enumeration Stub for processing enumeration requests\n * @param op SOAP pperation handler\n * @param appData Application data\n * @return status\n */\nint\nwsenum_enumerate_stub(SoapOpH op,\n\t\t      void *appData,\n\t\t\tvoid *opaqueData)\n{\n\tWsXmlDocH       doc = NULL;\n\tint             retVal = 0;\n\tWsEnumerateInfo *enumInfo = NULL;\n\tWsmanStatus     status;\n\tWsXmlNodeH      resp_node, body;\n\tWsContextH      soapCntx;\n\tSoapH           soap = soap_get_op_soap(op);\n\n\tif (soap == NULL) {\n\t\terror(\"soap_get_op_soap failed\");\n\t\treturn -1;\n\t}\n\n\tWsDispatchEndPointInfo *ep = (WsDispatchEndPointInfo *) appData;\n\tWsEndPointEnumerate endPoint =\n\t\t\t(WsEndPointEnumerate)ep->serviceEndPoint;\n\n\tWsXmlDocH       _doc = soap_get_op_doc(op, 1);\n\tWsContextH      epcntx;\n\n        int max_threads = 0;\n        int max_connections_per_thread = 0;\n        int(* fptr)(void);\n        if((fptr = wsmand_options_get_max_threads) != 0){\n                max_threads = (* fptr)();\n                if((fptr = wsmand_options_get_max_connections_per_thread) != 0){\n                        max_connections_per_thread = (* fptr)();\n                }\n                else{\n                        debug(\"Could not resolve wsmand_options_get_max_connections_per_thread\");\n                        max_threads=0;\n                }\n        }\n        else{\n                debug(\"Could not resolve wsman_options_get_max_threads\");\n        }\n\n        if(max_threads){\n                if(get_total_enum_context(ws_get_soap_context(soap)) >= (max_threads * max_connections_per_thread)){\n                        debug(\"enum context queue is full, we wait till some expire or are cleared\");\n                        doc = wsman_generate_fault(_doc, WSMAN_QUOTA_LIMIT, OWSMAN_NO_DETAILS,\n                                    \"The service is busy servicing other requests. Try later.\");\n                        if(doc){\n                                soap_set_op_doc(op, doc, 0);\n                        }\n                        return 1;\n                }\n        }\n\n\tepcntx = ws_create_ep_context(soap, _doc);\n\tif (epcntx == NULL) {\n\t\tgoto DONE;\n\t}\n\twsman_status_init(&status);\n\tdoc = create_enum_info(op, epcntx, _doc, &enumInfo);\n\tif (doc != NULL) {\n\t\t/* wrong enum elements met. Fault message generated */\n\t\tgoto DONE;\n\t}\n\n\tif (endPoint && (retVal = endPoint(epcntx, enumInfo, &status, opaqueData))) {\n                debug(\"enumeration fault\");\n\t\tdoc = wsman_generate_fault( _doc, status.fault_code,\n\t\t\t\tstatus.fault_detail_code, status.fault_msg);\n\t\tgoto DONE;\n\t}\n\tif (enumInfo->pullResultPtr) {\n\t\tdoc = enumInfo->pullResultPtr;\n\t\tenumInfo->index++;\n\t} else {\n\t\tdoc = wsman_create_response_envelope( _doc, NULL);\n\t}\n\n\tif (!doc)\n\t\tgoto DONE;\n\n\twsman_set_estimated_total(_doc, doc, enumInfo);\n\tbody = ws_xml_get_soap_body(doc);\n\tif (!body) {\n\t\tgoto DONE;\n\t}\n\n\tif (enumInfo->pullResultPtr == NULL) {\n\t\tresp_node = ws_xml_add_child(body, XML_NS_ENUMERATION,\n\t\t\t\t\t     WSENUM_ENUMERATE_RESP, NULL);\n\t} else {\n\t\tresp_node = ws_xml_get_child(body, 0,\n\t\t\t\t XML_NS_ENUMERATION, WSENUM_ENUMERATE_RESP);\n\t}\n\tif (!resp_node) {\n\t\tgoto DONE;\n\t}\n\n\tsoapCntx = ws_get_soap_context(soap);\n\tif (( enumInfo->flags & WSMAN_ENUMINFO_OPT ) == WSMAN_ENUMINFO_OPT  &&\n\t\t(enumInfo->totalItems == 0 || enumInfo->index == enumInfo->totalItems)) {\n\t\tws_serialize_str(epcntx->serializercntx, resp_node, NULL,\n\t\t\t    XML_NS_ENUMERATION, WSENUM_ENUMERATION_CONTEXT, 0);\n\t\tws_serialize_str(epcntx->serializercntx, resp_node,\n\t\t\t       NULL, XML_NS_WS_MAN, WSENUM_END_OF_SEQUENCE, 0);\n\t} else {\n\t\tws_serialize_str(epcntx->serializercntx, resp_node, enumInfo->enumId,\n\t\t\t    XML_NS_ENUMERATION, WSENUM_ENUMERATION_CONTEXT, 0);\n\t\tinsert_enum_info(soapCntx, enumInfo);\n\t\tenumInfo = NULL;\n\t}\n\nDONE:\n\tif (doc) {\n\t\tsoap_set_op_doc(op, doc, 0);\n\t}\n\tws_destroy_context(epcntx);\n\tu_free(status.fault_msg);\n\tif (enumInfo) {\n\t\tdestroy_enuminfo(enumInfo);\n\t}\n\treturn retVal;\n}\n\n\n\nint\nwsenum_release_stub(SoapOpH op,\n\t\t    void *appData,\n\t\t\tvoid *opaqueData)\n{\n\tint             retVal = 0;\n\tWsXmlDocH       doc = NULL;\n\tWsmanStatus     status;\n\tSoapH           soap = soap_get_op_soap(op);\n\n\tif (soap == NULL) {\n\t\terror(\"soap_get_op_soap failed\");\n\t\treturn -1;\n\t}\n\n\tWsContextH      soapCntx = ws_get_soap_context(soap);\n\tWsDispatchEndPointInfo *ep = (WsDispatchEndPointInfo *) appData;\n\tWsEndPointRelease endPoint = (WsEndPointRelease) ep->serviceEndPoint;\n\tWsXmlDocH       _doc = soap_get_op_doc(op, 1);\n\tWsEnumerateInfo *enumInfo;\n\n\twsman_status_init(&status);\n\tenumInfo = get_locked_enuminfo(soapCntx, _doc,\n\t\top, WSENUM_RELEASE, &status);\n\n        ws_set_context_xml_doc_val(soapCntx, WSFW_INDOC, _doc);\n\n\tif (enumInfo == NULL) {\n\t\tdoc = wsman_generate_fault( _doc,\n\t\t\tstatus.fault_code, status.fault_detail_code, NULL);\n\n\t} else {\n\t\tif (endPoint && (retVal = endPoint(soapCntx,\n\t\t\t\t\t\tenumInfo, &status, opaqueData))) {\n\t\t\terror(\"endPoint error\");\n\t\t\tdoc = wsman_generate_fault( _doc,\n\t\t\t\tWSMAN_INTERNAL_ERROR,\n\t\t\t\tOWSMAN_DETAIL_ENDPOINT_ERROR, NULL);\n\t\t\tunlock_enuminfo(soapCntx, enumInfo);\n\t\t} else {\n\t\t\tdoc = wsman_create_response_envelope( _doc, NULL);\n\t\t\tdebug(\"Releasing context: %s\", enumInfo->enumId);\n\t\t\tremove_locked_enuminfo(soapCntx, enumInfo);\n\t\t\tdestroy_enuminfo(enumInfo);\n\t\t}\n\t}\n\tif (doc) {\n\t\tsoap_set_op_doc(op, doc, 0);\n\t}\n\treturn retVal;\n}\n\n\n\n\n\nint\nwsenum_pull_stub(SoapOpH op, void *appData,\n\t\t\tvoid *opaqueData)\n{\n\tWsXmlNodeH      node;\n\tWsmanStatus     status;\n\tSoapH           soap = soap_get_op_soap(op);\n\n\tif (soap == NULL) {\n\t\terror(\"soap_get_op_soap failed\");\n\t\treturn -1;\n\t}\n\n\tWsContextH      soapCntx = ws_get_soap_context(soap);\n\n\tWsDispatchEndPointInfo *ep = (WsDispatchEndPointInfo *) appData;\n\tXmlSerializerInfo *typeInfo = ep->serializationInfo;\n\tWsEndPointPull  endPoint = (WsEndPointPull) ep->serviceEndPoint;\n\n\tint retVal = 0, locked = 0;\n\tWsXmlDocH doc = NULL;\n\tchar *enumId = NULL;\n\n\tWsXmlDocH _doc = soap_get_op_doc(op, 1);\n\tWsEnumerateInfo *enumInfo;\n\tWsXmlNodeH body;\n\n\twsman_status_init(&status);\n\tenumInfo = get_locked_enuminfo(soapCntx, _doc,\n\t\top, WSENUM_PULL, &status);\n\n\tif (enumInfo == NULL) {\n\t\tdoc = wsman_generate_fault( _doc, status.fault_code, status.fault_detail_code, NULL);\n\t\tgoto DONE;\n\t}\n\tlocked = 1;\n\tif ((retVal = endPoint(ws_create_ep_context(soap, _doc),\n\t\t\t\t\t\tenumInfo, &status, opaqueData))) {\n\t\tdoc = wsman_generate_fault(_doc, status.fault_code, status.fault_detail_code, NULL);\n\t\tgoto DONE;\n\t}\n\tenumInfo->index++;\n\tdoc = wsman_create_response_envelope( _doc, NULL);\n\n\tif (!doc) {\n\t\tgoto DONE;\n\t}\n\n\twsman_set_estimated_total(_doc, doc, enumInfo);\n\tbody = ws_xml_get_soap_body(doc);\n\tif (!body) {\n\t\tgoto DONE;\n\t}\n\n\tnode = ws_xml_add_child(body, XML_NS_ENUMERATION, WSENUM_PULL_RESP, NULL);\n\tif (node == NULL) {\n\t\tgoto DONE;\n\t}\n\tif (enumInfo->pullResultPtr) {\n\t\tif (enumId) {\n\t\t\tws_serialize_str(soapCntx->serializercntx, node, enumId,\n\t\t\t    XML_NS_ENUMERATION, WSENUM_ENUMERATION_CONTEXT, 0);\n\t\t}\n\t\tWsXmlNodeH itemsNode = ws_xml_add_child(node,\n\t\t\t\t    XML_NS_ENUMERATION, WSENUM_ITEMS, NULL);\n\t\tws_serialize(soapCntx->serializercntx, itemsNode, enumInfo->pullResultPtr,\n\t\t\t typeInfo, ep->respName, (char *) ep->data, NULL, 1);\n\t\tws_serializer_free_mem(soapCntx->serializercntx,\n\t\t\tenumInfo->pullResultPtr, typeInfo);\n\t} else {\n\t\t/*\n\t\tws_serialize_str(soapCntx, node, NULL,\n\t\t\t    XML_NS_ENUMERATION, WSENUM_ENUMERATION_CONTEXT, 0);\n\t\t\t    */\n\t\tws_serialize_str(soapCntx->serializercntx,\n\t\t    node, NULL, XML_NS_ENUMERATION, WSENUM_END_OF_SEQUENCE, 0);\n\t\tremove_locked_enuminfo(soapCntx, enumInfo);\n\t\tlocked = 0;\n\t\tdestroy_enuminfo(enumInfo);\n\t}\n\nDONE:\n\tif (locked) {\n\t\tunlock_enuminfo(soapCntx, enumInfo);\n\t}\n\tif (doc) {\n\t\tsoap_set_op_doc(op, doc, 0);\n\t}\n\treturn retVal;\n}\n\n\nint\nwsenum_pull_direct_stub(SoapOpH op,\n\t\t     void *appData,\n\t\t\tvoid *opaqueData)\n{\n\tWsmanStatus     status;\n\tWsXmlDocH       doc = NULL;\n\tSoapH           soap = soap_get_op_soap(op);\n\n\tif (soap == NULL) {\n\t\terror(\"soap_get_op_soap failed\");\n\t\treturn -1;\n\t}\n\n\tWsContextH      soapCntx = ws_get_soap_context(soap);\n\tWsDispatchEndPointInfo *ep = (WsDispatchEndPointInfo *) appData;\n#ifdef ENABLE_EVENTING_SUPPORT\n\tWsNotificationInfoH notificationInfo = NULL;\n#endif\n\n\tWsEndPointPull  endPoint = (WsEndPointPull) ep->serviceEndPoint;\n\tint             retVal = 0;\n\tWsXmlDocH       _doc = soap_get_op_doc(op, 1);\n\tint locked = 0;\n\tWsEnumerateInfo *enumInfo;\n\tWsSubscribeInfo *subsInfo = NULL;\n\twsman_status_init(&status);\n\tenumInfo = get_locked_enuminfo(soapCntx,\n\t                               _doc, op, WSENUM_PULL, &status);\n\n\tif (enumInfo == NULL) {\n\t\tsubsInfo = search_pull_subs_info(soap, _doc);\n\t\tif(subsInfo == NULL) {\n\t\t\terror(\"Invalid enumeration context...\");\n\t\t\tdoc = wsman_generate_fault( _doc, status.fault_code, status.fault_detail_code, NULL);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\tif (enumInfo) { //pull things from \"enumerate\" results\n\t\tlocked = 1;\n\n\t\tif ((retVal = endPoint(ws_create_ep_context(soap, _doc),\n\t\t\t\t\t\tenumInfo, &status, opaqueData))) {\n\t\t\tdoc = wsman_generate_fault( _doc, status.fault_code, status.fault_detail_code, NULL);\n//\t\t\tws_remove_context_val(soapCntx, cntxName);\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tenumInfo->index++;\n\t\tif (enumInfo->pullResultPtr) {\n\t\t\tWsXmlNodeH      body;\n\t\t\tWsXmlNodeH      response, items;\n\t\t\tdoc = enumInfo->pullResultPtr;\n\t\t\twsman_set_estimated_total(_doc, doc, enumInfo);\n\n\t\t\tbody = ws_xml_get_soap_body(doc);\n\t\t\tresponse = ws_xml_get_child(body, 0,\n\t\t\t\t\tXML_NS_ENUMERATION, WSENUM_PULL_RESP);\n\t\t\titems = ws_xml_get_child(response, 0,\n                                        XML_NS_ENUMERATION, WSENUM_ITEMS);\n\t\t\tif (items == NULL) {\n\t\t\t\terror(\"Invalid enumeration items...\");\n\t\t\t\tdoc = wsman_generate_fault( _doc, WSMAN_INTERNAL_ERROR, WSMAN_DETAIL_INVALID, NULL);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tif (enumInfo->totalItems == 0 || enumInfo->index == enumInfo->totalItems) {\n\t\t\t\t/*\n\t\t\t\t   ws_serialize_str(soapCntx, response, NULL,\n\t\t\t\t   XML_NS_ENUMERATION, WSENUM_ENUMERATION_CONTEXT, 0);\n\t\t\t\t   */\n\t\t\t\tws_serialize_str(soapCntx->serializercntx, response, NULL,\n\t\t\t\t\t\tXML_NS_ENUMERATION, WSENUM_END_OF_SEQUENCE, 0);\n\t\t\t\tremove_locked_enuminfo(soapCntx, enumInfo);\n\t\t\t\tlocked = 0;\n\t\t\t\tdestroy_enuminfo(enumInfo);\n\t\t\t} else  {\n\t\t\t        /* add Context before Items to comply to WS-Enumeration xsd */\n\t\t\t\tws_xml_add_prev_sibling(items, XML_NS_ENUMERATION,\n\t\t\t\t\t\t\tWSENUM_ENUMERATION_CONTEXT, enumInfo->enumId);\n\t\t\t}\n\t\t}\n\t}\n#ifdef ENABLE_EVENTING_SUPPORT\n\telse { //pull things from notifications\n\t\tws_xml_destroy_doc(doc);\n\t\tpthread_mutex_lock(&subsInfo->notificationlock);\n\t\tint count = soap->eventpoolOpSet->count(subsInfo->subsId);\n\t\tint max_elements = 1;\n\t\tif(count > 0) {\n\t\t\tdoc = ws_xml_create_envelope();\n\t\t\tWsXmlNodeH docnode = ws_xml_get_soap_body(doc);\n\t\t\tWsXmlNodeH docheader = ws_xml_get_soap_header(doc);\n\t\t\tdocnode = ws_xml_add_child(docnode, XML_NS_ENUMERATION, WSENUM_PULL_RESP, NULL);\n\t\t\tif(docnode) {\n\t\t\t\tws_xml_add_child_format(docnode, XML_NS_ENUMERATION, WSENUM_ENUMERATION_CONTEXT,\n\t\t\t\t\t\"uuid:%s\", subsInfo->subsId);\n\t\t\t}\n\t\t\tWsXmlDocH notidoc = NULL;\n\t\t\tWsXmlNodeH header = ws_xml_get_soap_header(_doc);\n\t\t\tif (ws_xml_get_child(header, 0,XML_NS_WS_MAN, WSM_REQUEST_TOTAL) != NULL) {\n\t\t\t\tWsXmlNodeH response_header =ws_xml_get_soap_header(doc);\n\t\t\t\tresponse_header = ws_xml_add_child(response_header, XML_NS_WS_MAN,\n\t\t\t\t\tWSM_TOTAL_ESTIMATE, NULL);\n\t\t\t\tif(response_header)\n\t\t\t\t\tws_xml_add_node_attr(response_header, XML_NS_SCHEMA_INSTANCE, XML_SCHEMA_NIL, \"true\");\n\t\t\t}\n\t\t\theader = ws_xml_get_child(header, 0, XML_NS_ENUMERATION, WSENUM_MAX_ELEMENTS);\n\t\t\tif(header)\n\t\t\t\tmax_elements = atoi(ws_xml_get_node_text(header));\n\t\t\tif(max_elements > 1 && count > 1) {\n\t\t\t\tdocnode = ws_xml_add_child(docnode, XML_NS_ENUMERATION, WSENUM_ITEMS, NULL);\n\t\t\t}\n\t\t\twhile(max_elements > 0) {\n\t\t\t\tif(soap->eventpoolOpSet->remove(subsInfo->subsId, &notificationInfo))\n\t\t\t\t\tbreak;\n\t\t\t\tws_xml_add_child(docheader, XML_NS_ADDRESSING, WSA_ACTION, notificationInfo->EventAction);\n\t\t\t\tnotidoc = notificationInfo->EventContent;\n\t\t\t\tWsXmlNodeH tempnode = ws_xml_get_doc_root(notidoc);\n\t\t\t\tws_xml_duplicate_tree(docnode, tempnode);\n\t\t\t\tdelete_notification_info(notificationInfo);\n\t\t\t\tmax_elements--;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tstatus.fault_code = WSMAN_TIMED_OUT;\n\t\t\tdoc = wsman_generate_fault( _doc, status.fault_code, status.fault_detail_code, NULL);\n\t\t}\n\t\tpthread_mutex_unlock(&subsInfo->notificationlock);\n\t}\n#endif\ncleanup:\n\tif (locked) {\n\t\tunlock_enuminfo(soapCntx, enumInfo);\n\t}\n\tif (doc) {\n\t\tsoap_set_op_doc(op, doc, 0);\n\t} else {\n\t\terror(\"doc is null\");\n\t}\n\n\treturn retVal;\n}\n\nstatic list_t *\nwsman_get_expired_enuminfos(WsContextH cntx)\n{\n\tlist_t *list = NULL;\n\thnode_t        *hn;\n\thscan_t         hs;\n\tWsEnumerateInfo *enumInfo;\n\tstruct timeval tv;\n\tunsigned long mytime;\n\tunsigned long aeit = cntx->enumIdleTimeout;\n\n\tif (aeit == 0) {\n\t\treturn NULL;\n\t}\n\tgettimeofday(&tv, NULL);\n\tmytime = tv.tv_sec;\n\tu_lock(cntx->soap);\n\tif (hash_isempty(cntx->enuminfos)) {\n\t\tu_unlock(cntx->soap);\n\t\treturn NULL;\n\t}\n\thash_scan_begin(&hs, cntx->enuminfos);\n\twhile ((hn = hash_scan_next(&hs))) {\n\t\tenumInfo = (WsEnumerateInfo *)hnode_get(hn);\n\t\tif (enumInfo->flags & WSMAN_ENUMINFO_INWORK_FLAG) {\n\t\t\tdebug(\"Enum in work: %s\", enumInfo->enumId);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((enumInfo->timeStamp + aeit > mytime) &&\n\t\t\t\t((enumInfo->expires == 0) ||\n\t\t\t\t(enumInfo->expires > mytime))) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (list == NULL) {\n\t\t\tlist = list_create(LISTCOUNT_T_MAX);\n\t\t}\n\t\tif (list == NULL) {\n\t\t\tu_unlock(cntx->soap);\n\t\t\terror(\"could not create list\");\n\t\t\treturn NULL;\n\t\t}\n\t\thash_scan_delfree(cntx->enuminfos, hn);\n\t\tlist_append(list, lnode_create(enumInfo));\n\t\tdebug(\"Enum expired list appended: %s\", enumInfo->enumId);\n\t}\n\tu_unlock(cntx->soap);\n\treturn list;\n}\n\nvoid\nwsman_timeouts_manager(WsContextH cntx, void *opaqueData)\n{\n\tlist_t *list = wsman_get_expired_enuminfos(cntx);\n\tlnode_t *node;\n\tWsEnumerateInfo *enumInfo;\n\tWsmanStatus status;\n\n\tif (list == NULL) {\n\t\treturn;\n\t}\n\twhile ((node = list_del_first(list))) {\n\t\tenumInfo = (WsEnumerateInfo *)lnode_get(node);\n\t\tdebug(\"EnumContext expired : %s\", enumInfo->enumId);\n\t\tlnode_destroy(node);\n\t\tif (enumInfo->releaseproc) {\n\t\t\tif (enumInfo->releaseproc(cntx, enumInfo, &status, opaqueData)) {\n\t\t\t\tdebug(\"released with failure: %s\",\n\t\t\t\t\t\tenumInfo->enumId);\n\t\t\t} else {\n\t\t\t\tdebug(\"released: %s\", enumInfo->enumId);\n\t\t\t}\n\t\t} else {\n\t\t\tdebug(\"no release endpoint: %s\", enumInfo->enumId);\n\t\t}\n\t\tdestroy_enuminfo(enumInfo);\n\t\tif (list_isempty(list)) {\n\t\t\tlist_destroy(list);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn;\n}\n\n\n#ifdef ENABLE_EVENTING_SUPPORT\nstatic int destination_reachable(char *url)\n{\n\tint valid = 0;\n\tu_uri_t *uri = NULL;\n\tif(strstr(url, \"http\") == NULL)\n\t\treturn valid;\n\tif (u_uri_parse((const char *)url, &uri) == 0) {\n\t\tvalid = 1;\n\t}\n\tu_uri_free(uri);\n\treturn valid;\n}\n\nWsEventThreadContextH\nws_create_event_context(SoapH soap, WsSubscribeInfo *subsInfo, WsXmlDocH doc)\n{\n\tWsEventThreadContextH eventcntx = u_malloc(sizeof(*eventcntx));\n\teventcntx->soap = soap;\n\teventcntx->subsInfo = subsInfo;\n\teventcntx->outdoc = doc;\n\treturn eventcntx;\n}\n\nstatic void\ndestroy_subsinfo(WsSubscribeInfo * subsInfo)\n{\n\tif(subsInfo == NULL) return;\n\tu_free(subsInfo->uri);\n\tu_free(subsInfo->auth_data.username);\n\tu_free(subsInfo->auth_data.password);\n\tu_free(subsInfo->epr_notifyto);\n\tu_free(subsInfo->locale);\n\tu_free(subsInfo->soapNs);\n\tu_free(subsInfo->contentEncoding);\n\tu_free(subsInfo->cim_namespace);\n\tu_free(subsInfo->username);\n\tu_free(subsInfo->password);\n\tu_free(subsInfo->certificate_thumbprint);\n\tif (subsInfo->filter) {\n\t\tfilter_destroy(subsInfo->filter);\n\t}\n\tws_xml_destroy_doc(subsInfo->bookmarkDoc);\n\tws_xml_destroy_doc(subsInfo->templateDoc);\n\tws_xml_destroy_doc(subsInfo->heartbeatDoc);\n\tu_free(subsInfo);\n}\n\n\nstatic void\ncreate_notification_template(WsXmlDocH indoc, WsSubscribeInfo *subsInfo)\n{\n\tWsXmlDocH notificationDoc = ws_xml_create_envelope();\n\tWsXmlNodeH temp = NULL;\n\tWsXmlNodeH node = NULL;\n\tWsXmlNodeH header = NULL;\n\theader = ws_xml_get_soap_header(notificationDoc);\n\tws_xml_add_child(header, XML_NS_ADDRESSING, WSA_TO, subsInfo->epr_notifyto);\n\tif(subsInfo->deliveryMode == WS_EVENT_DELIVERY_MODE_EVENTS ||\n\t\tsubsInfo->deliveryMode == WS_EVENT_DELIVERY_MODE_PUSHWITHACK) {\n\t\tws_xml_add_child(header, XML_NS_WS_MAN, WSM_ACKREQUESTED, NULL);\n\t}\n\tnode = ws_xml_get_soap_body(indoc);\n\tnode = ws_xml_get_child(node, 0, XML_NS_EVENTING, WSEVENT_SUBSCRIBE);\n\tnode = ws_xml_get_child(node, 0, XML_NS_EVENTING, WSEVENT_DELIVERY);\n\tnode = ws_xml_get_child(node, 0, XML_NS_EVENTING, WSEVENT_NOTIFY_TO);\n\ttemp = ws_xml_get_child(node, 0, XML_NS_ADDRESSING, WSA_REFERENCE_PROPERTIES);\n\tif(temp == NULL)\n\t\tnode = ws_xml_get_child(node, 0, XML_NS_ADDRESSING, WSA_REFERENCE_PARAMETERS);\n\tif(node ) {\n\t\tws_xml_duplicate_children(header, node);\n\t}\n\tsubsInfo->templateDoc = ws_xml_duplicate_doc(notificationDoc);\n\tsubsInfo->heartbeatDoc = ws_xml_duplicate_doc( notificationDoc);\n\ttemp = ws_xml_get_soap_header(subsInfo->heartbeatDoc);\n\ttemp = ws_xml_add_child(temp, XML_NS_ADDRESSING, WSA_ACTION, WSMAN_ACTION_HEARTBEAT);\n\tws_xml_add_node_attr(temp, XML_NS_XML_SCHEMA, SOAP_MUST_UNDERSTAND, \"true\");\n\tws_xml_destroy_doc(notificationDoc);\n}\n\n\nstatic WsXmlDocH\ncreate_subs_info(SoapOpH op,\n\t\t \t\tWsContextH epcntx,\n              \tWsXmlDocH indoc,\n              \tWsSubscribeInfo**sInfo)\n{\n\tWsXmlNodeH  node = ws_xml_get_soap_body(indoc);\n\tWsXmlNodeH\tsubNode = ws_xml_get_child(node, 0, XML_NS_EVENTING, WSEVENT_SUBSCRIBE);\n\tWsXmlNodeH\ttemp;\n\tWsXmlDocH outdoc = NULL;\n\tWsSubscribeInfo *subsInfo;\n\tWsXmlAttrH attr = NULL;\n\top_t *_op = (op_t *) op;\n\tWsmanMessage   *msg = (WsmanMessage *) _op->data;\n\tWsmanFaultCodeType fault_code = WSMAN_RC_OK;\n\tWsmanFaultDetailType fault_detail_code = WSMAN_DETAIL_OK;\n\tchar *str = NULL;\n\ttime_t timeout;\n\tint r;\n\tchar *soapNs = NULL, *ntext = NULL;\n\n\n\t*sInfo = NULL;\n\tsubsInfo = (WsSubscribeInfo *)u_zalloc(sizeof (WsSubscribeInfo));\n\tif (subsInfo == NULL) {\n\t\terror(\"No memory\");\n\t\tfault_code = WSMAN_INTERNAL_ERROR;\n\t\tgoto DONE;\n\t}\n\tif((r = pthread_mutex_init(&subsInfo->notificationlock, NULL)) != 0) {\n\t\tfault_code = WSMAN_INTERNAL_ERROR;\n\t\tgoto DONE;\n\t}\n\tsubsInfo->uri = u_strdup(wsman_get_resource_uri(epcntx, indoc));\n\tif(!subNode) {\n\t\tmessage(\"No subsribe body\");\n\t\tfault_code = WSE_INVALID_MESSAGE;\n\t\tgoto DONE;\n\t}\n\tsoapNs = ws_xml_get_node_name_ns(ws_xml_get_doc_root(indoc));\n\tsubsInfo->soapNs = u_strdup(soapNs);\n\tnode = ws_xml_get_child(subNode, 0, XML_NS_WS_MAN, WSM_SENDBOOKMARKS);\n\tif(node) {\n\t\tsubsInfo->bookmarksFlag = 1;\n\t}\n\tnode = ws_xml_get_child(subNode, 0, XML_NS_WS_MAN, WSM_BOOKMARK);\n\tif(node) {\n\t\tif(ws_xml_get_node_text(node) &&\n\t\t\t!strcmp(ws_xml_get_node_text(node), WSM_DEFAULTBOOKMARK)){\n\t\t\tsubsInfo->flags |= WSMAN_SUBSCRIBEINFO_BOOKMARK_DEFAULT;\n\t\t}\n\t\telse {\n\t\t\tsubsInfo->bookmarkDoc = ws_xml_create_doc(XML_NS_WS_MAN, WSM_BOOKMARK);\n\t\t\ttemp = ws_xml_get_doc_root(subsInfo->bookmarkDoc);\n\t\t\tws_xml_duplicate_children(temp, node);\n\t\t}\n\t}\n\tnode = ws_xml_get_child(subNode, 0, XML_NS_EVENTING, WSEVENT_EXPIRES);\n\tif (node == NULL) {\n\t\tdebug(\"No wsen:Expires\");\n\t\tsubsInfo->expires = 0;\n\t}\n\telse {\n\t\twsman_set_expiretime(node, &subsInfo->expires, &fault_code);\n\t\tif (fault_code != WSMAN_RC_OK) {\n\t\t\tdebug(\"Invalid expiration time!\");\n\t\t\tgoto DONE;\n\t\t}\n\t\tif(time_expired(subsInfo->expires)) {\n\t\t\tfault_code = WSE_INVALID_EXPIRATION_TIME;\n\t\t\tdebug(\"Invalid expiration time!\");\n\t\t\tgoto DONE;\n\t\t}\n\t}\n\tnode = ws_xml_get_child(subNode, 0, XML_NS_EVENTING, WSEVENT_DELIVERY);\n\tattr = ws_xml_find_node_attr(node, NULL,WSEVENT_DELIVERY_MODE);\n\tif(attr) {\n\t\tstr = ws_xml_get_attr_value(attr);\n\t\tif (!strcasecmp(str, WSEVENT_DELIVERY_MODE_PUSH)) {\n\t\t\tsubsInfo->deliveryMode = WS_EVENT_DELIVERY_MODE_PUSH;\n\t\t}\n\t\telse if (!strcasecmp(str, WSEVENT_DELIVERY_MODE_PUSHWITHACK)) {\n\t\t\tsubsInfo->deliveryMode = WS_EVENT_DELIVERY_MODE_PUSHWITHACK;\n\t\t}\n\t\telse if (!strcasecmp(str, WSEVENT_DELIVERY_MODE_EVENTS))  {\n\t\t\tsubsInfo->deliveryMode = WS_EVENT_DELIVERY_MODE_EVENTS;\n\t\t}\n\t\telse {\n\t\t\tsubsInfo->deliveryMode = WS_EVENT_DELIVERY_MODE_PULL;\n\t\t}\n\t}\n\telse {\n\t\t//\"push\" is the default delivery mode\n\t\tsubsInfo->deliveryMode = WS_EVENT_DELIVERY_MODE_PUSH;\n\t}\n\ttemp = ws_xml_get_child(node, 0, XML_NS_WS_MAN, WSM_CONTENTCODING);\n\tif(temp){\n\t\tstr = ws_xml_get_node_text(temp);\n\t\tsubsInfo->contentEncoding = u_strdup(str);\n\t}\n\ttemp = ws_xml_get_child(node, 0, XML_NS_WS_MAN, WSM_LOCALE);\n\tif(temp) {\n\t\tattr = ws_xml_find_node_attr(temp, XML_NS_WS_MAN, WSM_LOCALE);\n\t\tif(attr)\n\t\t\tsubsInfo->locale = u_strdup(ws_xml_get_attr_value(attr));\n\t}\n\ttemp = ws_xml_get_child(node, 0, XML_NS_WS_MAN, WSM_HEARTBEATS);\n\tif(temp) {\n\t\tstr = ws_xml_get_node_text(temp);\n\t\tdebug(\"[heartbeat interval = %s]\",str);\n\t\tif(str[0]=='P') {\n\t\t\t//  xml duration\n\t\t\tif (ws_deserialize_duration(str, &timeout)) {\n\t\t\t\tfault_code = WSEN_INVALID_EXPIRATION_TIME;\n\t\t\t\tgoto DONE;\n\t\t\t}\n\t\t\tdebug(\"timeout = %d\", timeout);\n\t\t\tsubsInfo->heartbeatInterval = timeout * 1000;\n\t\t\tsubsInfo->heartbeatCountdown = subsInfo->heartbeatInterval;\n\t\t}\n\t}\n\tif(subsInfo->deliveryMode != WS_EVENT_DELIVERY_MODE_PULL) {\n\t\ttemp = ws_xml_get_child(node, 0, XML_NS_EVENTING, WSEVENT_NOTIFY_TO);\n\t\tif(temp == NULL) {\n\t\t\tmessage(\"No notification destination\");\n\t\t\tfault_code = WSE_INVALID_MESSAGE;\n\t\t\tgoto DONE;\n\t\t}\n\t\tstr = ws_xml_get_node_text(ws_xml_get_child(temp, 0, XML_NS_ADDRESSING, WSA_ADDRESS));\n\t\tdebug(\"event sink: %s\", str);\n\t\tif(str && strcmp(str, \"\")) {\n\t\t\tsubsInfo->epr_notifyto = u_strdup(str);\n\t\t\tif(destination_reachable(str) == 0) {\n\t\t\t\tfault_code = WSMAN_EVENT_DELIVER_TO_UNUSABLE;\n\t\t\t\tgoto DONE;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfault_code = WSE_INVALID_MESSAGE;\n\t\t\tgoto DONE;\n\t\t}\n\t\ttemp = ws_xml_get_child(node, 0, XML_NS_WS_MAN, WSM_AUTH);\n\t\tif(temp) {\n\t\t\tattr = ws_xml_find_node_attr(temp, NULL, WSM_PROFILE);\n\t\t\tif(attr) {\n\t\t\t\tstr = ws_xml_get_attr_value(attr);\n\t\t\t\tif(!strcasecmp(str, WSMAN_SECURITY_PROFILE_HTTP_BASIC))\n\t\t\t\t\tsubsInfo->deliveryAuthType = WSMAN_SECURITY_PROFILE_HTTP_BASIC_TYPE;\n\t\t\t\telse if(!strcasecmp(str, WSMAN_SECURITY_PROFILE_HTTP_DIGEST))\n\t\t\t\t\tsubsInfo->deliveryAuthType = WSMAN_SECURITY_PROFILE_HTTP_DIGEST_TYPE;\n\t\t\t\telse if(!strcasecmp(str, WSMAN_SECURITY_PROFILE_HTTPS_BASIC))\n\t\t\t\t\tsubsInfo->deliveryAuthType = WSMAN_SECURITY_PROFILE_HTTPS_BASIC_TYPE;\n\t\t\t\telse if(!strcasecmp(str, WSMAN_SECURITY_PROFILE_HTTPS_DIGEST))\n\t\t\t\t\tsubsInfo->deliveryAuthType = WSMAN_SECURITY_PROFILE_HTTPS_DIGEST_TYPE;\n\t\t\t\telse if(!strcasecmp(str, WSMAN_SECURITY_PROFILE_HTTPS_MUTUAL))\n\t\t\t\t\tsubsInfo->deliveryAuthType = WSMAN_SECURITY_PROFILE_HTTPS_MUTUAL_TYPE;\n\t\t\t\telse if(!strcasecmp(str, WSMAN_SECURITY_PROFILE_HTTPS_MUTUAL_BASIC))\n\t\t\t\t\tsubsInfo->deliveryAuthType = WSMAN_SECURITY_PROFILE_HTTPS_MUTUAL_BASIC_TYPE;\n\t\t\t\telse if(!strcasecmp(str, WSMAN_SECURITY_PROFILE_HTTPS_MUTUAL_DIGEST))\n\t\t\t\t\tsubsInfo->deliveryAuthType = WSMAN_SECURITY_PROFILE_HTTPS_MUTUAL_DIGEST_TYPE;\n\t\t\t\telse if(!strcasecmp(str, WSMAN_SECURITY_PROFILE_HTTPS_SPNEGO_KERBEROS))\n\t\t\t\t\tsubsInfo->deliveryAuthType = WSMAN_SECURITY_PROFILE_HTTPS_SPNEGO_KERBEROS_TYPE;\n\t\t\t\telse if(!strcasecmp(str, WSMAN_SECURITY_PROFILE_HTTPS_MUTUAL_SPNEGO_KERBEROS))\n\t\t\t\t\tsubsInfo->deliveryAuthType = WSMAN_SECURITY_PROFILE_HTTPS_MUTUAL_SPNEGO_KERBEROS_TYPE;\n\t\t\t\telse if(!strcasecmp(str, WSMAN_SECURITY_PROFILE_HTTP_SPNEGO_KERBEROS))\n\t\t\t\t\tsubsInfo->deliveryAuthType = WSMAN_SECURITY_PROFILE_HTTP_SPNEGO_KERBEROS_TYPE;\n\t\t\t\telse {\n\t\t\t\t\tfault_code = WSMAN_INVALID_OPTIONS;\n\t\t\t\t\tfault_detail_code = WSMAN_DETAIL_AUTHERIZATION_MODE;\n\t\t\t\t\tgoto DONE;\n\t\t\t\t}\n\t\t\t\tdebug(\"auth profile type = %d\", subsInfo->deliveryAuthType);\n\n\t\t\t}\n\t\t}\n\t}\n\tif(wsman_parse_credentials(indoc, subsInfo, &fault_code, &fault_detail_code)) {\n\t\tgoto DONE;\n\t}\n\tif(wsman_parse_event_request(indoc, subsInfo, &fault_code, &fault_detail_code)) {\n\t\tgoto DONE;\n\t}\n\tif (msg->auth_data.username != NULL) {\n\t\tsubsInfo->auth_data.username =\n\t\t\t\tu_strdup(msg->auth_data.username);\n\t\tsubsInfo->auth_data.password =\n\t\t\t\tu_strdup(msg->auth_data.password);\n\t} else {\n\t\tsubsInfo->auth_data.username = NULL;\n\t\tsubsInfo->auth_data.password = NULL;\n\t}\n\ttemp = ws_xml_get_soap_header(indoc);\n\ttemp = ws_xml_get_child(temp, 0, XML_NS_OPENWSMAN, \"FormerUID\");\n\tntext = ws_xml_get_node_text(temp);\n\tif(temp && ntext) { //it is a request from the saved reqeust. So we recover the former UUID\n\t\tstrncpy(subsInfo->subsId, ntext, EUIDLEN);\n\t\tdebug(\"Recover to uuid:%s\",subsInfo->subsId);\n\t}\n\telse\n\t\tgenerate_uuid(subsInfo->subsId, EUIDLEN, 1);\n\tif(subsInfo->deliveryMode != WS_EVENT_DELIVERY_MODE_PULL)\n\t\tcreate_notification_template(indoc, subsInfo);\nDONE:\n\tif (fault_code != WSMAN_RC_OK) {\n\t\toutdoc = wsman_generate_fault(indoc, fault_code, fault_detail_code, NULL);\n\t\tdestroy_subsinfo(subsInfo);\n\t} else {\n\t\t*sInfo = subsInfo;\n\t}\n\treturn outdoc;\n}\n\n\n/**\n * Subscribe Stub for processing subscription requests\n * @param op SOAP pperation handler\n * @param appData Application data\n * @return status\n */\nint\nwse_subscribe_stub(SoapOpH op, void *appData, void *opaqueData)\n{\n\tWsXmlDocH       doc = NULL;\n\tint             retVal = 0;\n\tWsSubscribeInfo *subsInfo = NULL;\n\tWsmanStatus     status;\n\tWsXmlNodeH      inNode, body, header, temp;\n\tSoapH           soap = soap_get_op_soap(op);\n\n\tif (soap == NULL) {\n\t\terror(\"soap_get_op_soap failed\");\n\t\treturn -1;\n\t}\n\n\tWsContextH soapCntx = ws_get_soap_context(soap);\n\tint i;\n\tWsDispatchEndPointInfo *ep = (WsDispatchEndPointInfo *) appData;\n\tWsEndPointSubscribe endPoint =\n\t\t\t(WsEndPointSubscribe)ep->serviceEndPoint;\n\n\tWsXmlDocH       _doc = soap_get_op_doc(op, 1);\n\tWsContextH      epcntx;\n\tchar *buf = NULL;\n\tchar *expiresstr = NULL;\n\tint len;\n\tepcntx = ws_create_ep_context(soap, _doc);\n\twsman_status_init(&status);\n\tdoc = create_subs_info(op, epcntx, _doc, &subsInfo);\n\tif (doc != NULL) {\n\t\tgoto DONE;\n\t}\n\tif (endPoint && (retVal = endPoint(epcntx, subsInfo, &status, opaqueData))) {\n                debug(\"Subscribe fault\");\n\t\tdoc = wsman_generate_fault( _doc, status.fault_code, status.fault_detail_code, status.fault_msg);\n\t\tdestroy_subsinfo(subsInfo);\n\t\tgoto DONE;\n\t}\n\tdoc = wsman_create_response_envelope(_doc, NULL);\n\tif (!doc)\n\t\tgoto DONE;\n\n\tchar str[30];\n\twsman_expiretime2xmldatetime(subsInfo->expires, str);\n\tif(soap->subscriptionOpSet) {\n\t\ttemp = ws_xml_get_child(ws_xml_get_soap_body(_doc), 0, XML_NS_EVENTING, WSEVENT_SUBSCRIBE);\n\t\ttemp = ws_xml_get_child(temp, 0, XML_NS_EVENTING, WSEVENT_EXPIRES);\n\t\tif(temp) {\n\t\t\texpiresstr = strdup(ws_xml_get_node_text(temp));\n\t\t\tws_xml_set_node_text(temp, str);\n\t\t}\n\t\ttemp = ws_xml_get_soap_header(_doc);\n\t\tinNode = ws_xml_get_child(temp, 0, XML_NS_OPENWSMAN, \"FormerUID\");\n\t\tif(inNode == NULL)\n\t\t\tws_xml_add_child(temp, XML_NS_OPENWSMAN, \"FormerUID\", subsInfo->subsId);\n\t\tws_xml_dump_memory_enc(_doc, &buf, &len, \"UTF-8\");\n\t\tif(buf) {\n\t\t\tsoap->subscriptionOpSet->save_subscritption(soap->uri_subsRepository, subsInfo->subsId, (unsigned char*)buf);\n\t\t\tu_free(buf);\n\t\t}\n\t}\n\tlnode_t * sinfo = lnode_create(subsInfo);\n\tpthread_mutex_lock(&soap->lockSubs);\n\tlist_append(soapCntx->subscriptionMemList, sinfo);\n\tpthread_mutex_unlock(&soap->lockSubs);\n\tdebug(\"subscription uuid:%s kept in the memory\", subsInfo->subsId);\n\theader = ws_xml_get_soap_header(doc);\n\tinNode = ws_xml_get_soap_header(_doc);\n\tinNode = ws_xml_get_child(inNode, 0, XML_NS_ADDRESSING, WSA_REPLY_TO);\n\tinNode = ws_xml_get_child(inNode, 0, XML_NS_ADDRESSING, WSA_REFERENCE_PROPERTIES);\n\tif(inNode == NULL)\n\t\tinNode = ws_xml_get_child(inNode, 0, XML_NS_ADDRESSING, WSA_REFERENCE_PARAMETERS);\n\tif(inNode) {\n\t\tfor (i = 0;\n\t\t     (temp =\n\t\t      ws_xml_get_child(inNode, i, NULL, NULL)) != NULL;\n\t\t     i++) {\n\t\t\tws_xml_duplicate_tree(header, temp);\n\t\t}\n\t}\n\tbody = ws_xml_get_soap_body(doc);\n\tinNode = ws_xml_add_child(body, XML_NS_EVENTING, WSEVENT_SUBSCRIBE_RESP, NULL);\n\ttemp = ws_xml_add_child(inNode, XML_NS_EVENTING, WSEVENT_SUBSCRIPTION_MANAGER, NULL);\n\tif(subsInfo->expires)\n\t\tws_xml_add_child(inNode, XML_NS_EVENTING, WSEVENT_EXPIRES, expiresstr);\n\tif(subsInfo->deliveryMode == WS_EVENT_DELIVERY_MODE_PULL)\n\t\tws_xml_add_child_format(inNode, XML_NS_ENUMERATION,\n\t\tWSENUM_ENUMERATION_CONTEXT, \"uuid:%s\", subsInfo->subsId);\n\tinNode = temp;\n\tif(inNode){\n\t\ttemp = ws_xml_get_soap_header(_doc);\n\t\ttemp = ws_xml_get_child(temp, 0, XML_NS_ADDRESSING, WSA_TO);\n\t\tws_xml_add_child(inNode,XML_NS_ADDRESSING,WSA_ADDRESS,ws_xml_get_node_text(temp));\n\t}\n\ttemp = ws_xml_add_child(inNode, XML_NS_ADDRESSING, WSA_REFERENCE_PARAMETERS, NULL);\n\tif(temp)\n\t\tws_xml_add_child_format(temp, XML_NS_EVENTING, WSEVENT_IDENTIFIER, \"uuid:%s\", subsInfo->subsId);\nDONE:\n\tif (doc) {\n\t\tsoap_set_op_doc(op, doc, 0);\n\t}\n\tu_free(expiresstr);\n\tws_serializer_free_all(epcntx->serializercntx);\n\tws_destroy_context(epcntx);\n\tu_free(status.fault_msg);\n\treturn retVal;\n}\n\n\n\n\n/**\n * Unsubscribe Stub for processing unsubscription requests\n * @param op SOAP pperation handler\n * @param appData Application data\n * @return status\n */\nint\nwse_unsubscribe_stub(SoapOpH op, void *appData, void *opaqueData)\n{\n\tWsXmlDocH       doc = NULL;\n\tint             retVal = 0;\n\tWsSubscribeInfo *subsInfo = NULL;\n\tWsmanStatus     status;\n\tWsXmlNodeH      inNode;\n\tWsXmlNodeH      header;\n\tSoapH           soap = soap_get_op_soap(op);\n\n\tif (soap == NULL) {\n\t\terror(\"soap_get_op_soap failed\");\n\t\treturn -1;\n\t}\n\n\tWsContextH soapCntx = ws_get_soap_context(soap);\n\tWsDispatchEndPointInfo *ep = (WsDispatchEndPointInfo *) appData;\n\tWsEndPointSubscribe endPoint =\n\t\t\t(WsEndPointSubscribe)ep->serviceEndPoint;\n\n\tWsXmlDocH       _doc = soap_get_op_doc(op, 1);\n\tWsContextH      epcntx;\n\n\tepcntx = ws_create_ep_context(soap, _doc);\n\twsman_status_init(&status);\n\theader = ws_xml_get_soap_header(_doc);\n\tinNode = ws_xml_get_child(header, 0, XML_NS_EVENTING, WSEVENT_IDENTIFIER);\n\tif(inNode == NULL) {\n\t\tstatus.fault_code = WSE_INVALID_MESSAGE;\n\t\tstatus.fault_detail_code = WSMAN_DETAIL_INVALID_VALUE;\n\t\tgoto DONE;\n\t}\n\tchar *uuid = ws_xml_get_node_text(inNode);\n\tlnode_t *t = NULL;\n\tpthread_mutex_lock(&soap->lockSubs);\n\tif(!list_isempty(soapCntx->subscriptionMemList)) {\n\t\tt = list_first(soapCntx->subscriptionMemList);\n\t\tsubsInfo = (WsSubscribeInfo *)t->list_data;\n\t\twhile(t && strcasecmp(subsInfo->subsId, uuid+5)) {\n\t\t\tt = list_next(soapCntx->subscriptionMemList, t);\n\t\t\tif(t)\n\t\t\t\tsubsInfo = (WsSubscribeInfo *)t->list_data;\n\t\t}\n\t}\n\tif(t == NULL) {\n\t\tstatus.fault_code = WSMAN_INVALID_PARAMETER;\n\t\tstatus.fault_detail_code = WSMAN_DETAIL_INVALID_VALUE;\n\t\tdoc = wsman_generate_fault( _doc,\n\t\t \tstatus.fault_code, status.fault_detail_code, NULL);\n\t\tpthread_mutex_unlock(&soap->lockSubs);\n\t\tgoto DONE;\n\t}\n\tpthread_mutex_unlock(&soap->lockSubs);\n\tif (endPoint && (retVal = endPoint(epcntx, subsInfo, &status, opaqueData))) {\n               debug(\"UnSubscribe fault\");\n\t\tdoc = wsman_generate_fault( _doc, status.fault_code, status.fault_detail_code, status.fault_msg);\n\t\tgoto DONE;\n\t}\n\tpthread_mutex_lock(&subsInfo->notificationlock);\n\tsubsInfo->flags |= WSMAN_SUBSCRIBEINFO_UNSUBSCRIBE;\n\tpthread_mutex_unlock(&subsInfo->notificationlock);\n\tdebug(\"subscription %s unsubscribed\", uuid);\n\tdoc = wsman_create_response_envelope( _doc, NULL);\n\tif (!doc)\n\t\tgoto DONE;\nDONE:\n\tif (doc) {\n\t\tsoap_set_op_doc(op, doc, 0);\n\t}\n\tws_serializer_free_all(epcntx->serializercntx);\n\tws_destroy_context(epcntx);\n\tu_free(status.fault_msg);\n\treturn retVal;\n}\n\n\n/**\n * Renew Stub for processing renew requests\n * @param op SOAP pperation handler\n * @param appData Application data\n * @return status\n */\nint\nwse_renew_stub(SoapOpH op, void *appData, void *opaqueData)\n{\n\tWsXmlDocH       doc = NULL;\n\tint             retVal = 0;\n\tWsSubscribeInfo *subsInfo;\n\tWsmanStatus     status;\n\tWsXmlNodeH      inNode;\n\tWsXmlNodeH      body;\n\tWsXmlNodeH      header;\n\tSoapH           soap = soap_get_op_soap(op);\n\n\tif (soap == NULL) {\n\t\terror(\"soap_get_op_soap failed\");\n\t\treturn -1;\n\t}\n\n\tWsContextH soapCntx = ws_get_soap_context(soap);\n\tchar * expirestr = NULL;\n\n\tWsDispatchEndPointInfo *ep = (WsDispatchEndPointInfo *) appData;\n\tWsEndPointSubscribe endPoint =\n\t\t\t(WsEndPointSubscribe)ep->serviceEndPoint;\n\n\tWsXmlDocH       _doc = soap_get_op_doc(op, 1);\n\tWsContextH      epcntx;\n\tepcntx = ws_create_ep_context(soap, _doc);\n\twsman_status_init(&status);\n\tbody = ws_xml_get_soap_body(_doc);\n\theader = ws_xml_get_soap_header(_doc);\n\tinNode = ws_xml_get_child(header, 0, XML_NS_EVENTING, WSEVENT_IDENTIFIER);\n\tchar *uuid = ws_xml_get_node_text(inNode);\n\tif(uuid == NULL) {\n\t\tstatus.fault_code = WSE_INVALID_MESSAGE;\n\t\tstatus.fault_detail_code = WSMAN_DETAIL_MISSING_VALUES;\n\t\tdoc = wsman_generate_fault( _doc, status.fault_code, status.fault_detail_code, NULL);\n\t\tgoto DONE;\n\t}\n\tpthread_mutex_lock(&soap->lockSubs);\n\tlnode_t *t = NULL;\n\tif(!list_isempty(soapCntx->subscriptionMemList)) {\n\t\tt = list_first(soapCntx->subscriptionMemList);\n\t\tsubsInfo = (WsSubscribeInfo *)t->list_data;\n\t\twhile(t && strcasecmp(subsInfo->subsId, uuid+5)) {\n\t\t\tt = list_next(soapCntx->subscriptionMemList, t);\n\t\t\tif(t)\n\t\t\t\tsubsInfo = (WsSubscribeInfo *)t->list_data;\n\t\t}\n\t}\n\tif(t == NULL) {\n\t\tstatus.fault_code = WSE_UNABLE_TO_RENEW;\n\t\tdoc = wsman_generate_fault( _doc, status.fault_code, status.fault_detail_code, NULL);\n\t\tpthread_mutex_unlock(&soap->lockSubs);\n\t\tgoto DONE;\n\t}\n\tpthread_mutex_unlock(&soap->lockSubs);\n\tinNode = ws_xml_get_child(body, 0, XML_NS_EVENTING, WSEVENT_RENEW);\n\tinNode = ws_xml_get_child(inNode, 0, XML_NS_EVENTING ,WSEVENT_EXPIRES);\n\tpthread_mutex_lock(&subsInfo->notificationlock);\n\twsman_set_expiretime(inNode, &subsInfo->expires, &status.fault_code);\n\texpirestr = ws_xml_get_node_text(inNode);\n\tpthread_mutex_unlock(&subsInfo->notificationlock);\n\tif (status.fault_code != WSMAN_RC_OK) {\n\t\tstatus.fault_detail_code = WSMAN_DETAIL_EXPIRATION_TIME;\n\t\tpthread_mutex_unlock(&subsInfo->notificationlock);\n\t\tgoto DONE;\n\t}\n\tchar str[30];\n\twsman_expiretime2xmldatetime(subsInfo->expires, str);\n\tif(soap->subscriptionOpSet) {\n\t\tsoap->subscriptionOpSet->update_subscription(soap->uri_subsRepository, uuid+5,\n\t\t\tstr);\n\t\tdebug(\"subscription %s updated!\", uuid);\n\t}\n\n\tif (endPoint && (retVal = endPoint(epcntx, subsInfo, &status, opaqueData))) {\n                debug(\"renew fault in plug-in\");\n\t\tdoc = wsman_generate_fault( _doc, status.fault_code, status.fault_detail_code, status.fault_msg);\n\t\tpthread_mutex_unlock(&subsInfo->notificationlock);\n\t\tgoto DONE;\n\t}\n\tdoc = wsman_create_response_envelope( _doc, NULL);\n\tif (!doc)\n\t\tgoto DONE;\n\tbody = ws_xml_get_soap_body(doc);\n\tbody = ws_xml_add_child(body, XML_NS_EVENTING, WSEVENT_RENEW_RESP, NULL);\n\tws_xml_add_child(body, XML_NS_EVENTING, WSEVENT_EXPIRES, expirestr);\nDONE:\n\tif (doc) {\n\t\tsoap_set_op_doc(op, doc, 0);\n\t}\n\tws_serializer_free_all(epcntx->serializercntx);\n\tws_destroy_context(epcntx);\n\tu_free(status.fault_msg);\n\treturn retVal;\n}\n\n\nvoid\nwsman_heartbeat_generator(WsContextH cntx, void *opaqueData)\n{\n\tSoapH soap = cntx->soap;\n\tWsSubscribeInfo *subsInfo = NULL;\n\tWsEventThreadContextH threadcntx = NULL;\n\tWsContextH soapCntx = ws_get_soap_context(soap);\n\tpthread_t eventsender;\n\tpthread_attr_t pattrs;\n\tint r;\n\tif ((r = pthread_attr_init(&pattrs)) != 0) {\n\t\tdebug(\"pthread_attr_init failed = %d\", r);\n\t\treturn;\n\t}\n\tif ((r = pthread_attr_setdetachstate(&pattrs,\n\t\t\t\t\t     PTHREAD_CREATE_DETACHED)) !=0) {\n\t\tdebug(\"pthread_attr_setdetachstate = %d\", r);\n\t\treturn;\n\t}\n\tpthread_mutex_lock(&soap->lockSubs);\n\tlnode_t *node = list_first(soapCntx->subscriptionMemList);\n\twhile(node) {\n\t\tsubsInfo = (WsSubscribeInfo *)node->list_data;\n\t\tpthread_mutex_lock(&subsInfo->notificationlock);\n#if 0\n\t\tdebug(\"subscription %s : event sent last time = %d, heartbeat= %ld, heartbeatcountdown = %ld, pending events = %d\",\n\t\t\tsubsInfo->subsId, \tsubsInfo->eventSentLastTime, subsInfo->heartbeatInterval, subsInfo->heartbeatCountdown, subsInfo->flags & WSMAN_SUBSCRIPTION_NOTIFICAITON_PENDING);\n#endif\n\t\tif(subsInfo->flags & WSMAN_SUBSCRIBEINFO_UNSUBSCRIBE) {\n\t\t\tgoto LOOP;\n\t\t}\n\t\tif(time_expired(subsInfo->expires)) {\n\n\t\t\tgoto LOOP;\n\n\t\t}\n\t\tif(subsInfo->heartbeatInterval == 0 || subsInfo->deliveryMode == WS_EVENT_DELIVERY_MODE_PULL) {\n\t\t\tgoto LOOP;\n\t\t}\n\t\tsubsInfo->heartbeatCountdown -= 1000;\n\t\tif(subsInfo->heartbeatCountdown > 0) {\n\t\t\tgoto LOOP;\n\t\t}\n\t\tif(subsInfo->eventSentLastTime) {\n\t\t\tsubsInfo->eventSentLastTime = 0;\n\t\t}\n\t\telse {\n\t\t\tdebug(\"one heartbeat document created for %s\", subsInfo->subsId);\n\t\t\tif((subsInfo->flags & WSMAN_SUBSCRIPTION_NOTIFICAITON_PENDING) == 0) {\n\t\t\t\tthreadcntx = ws_create_event_context(soap, subsInfo, NULL);\n\t\t\t\tif(pthread_create(&eventsender, &pattrs, wse_heartbeat_sender, threadcntx) == 0)\n\t\t\t\t\tsubsInfo->flags |= WSMAN_SUBSCRIPTION_NOTIFICAITON_PENDING;\n\t\t\t}\n\t\t}\n\t\tsubsInfo->heartbeatCountdown = subsInfo->heartbeatInterval;\nLOOP:\n\t\tpthread_mutex_unlock(&subsInfo->notificationlock);\n\t\tnode = list_next(soapCntx->subscriptionMemList, node);\n\t}\n\tpthread_mutex_unlock(&soap->lockSubs);\n}\n\nstatic int wse_send_notification(WsEventThreadContextH cntx, WsXmlDocH outdoc, WsSubscribeInfo *subsInfo, unsigned char acked)\n{\n\tint retVal = 0;\n\tWsManClient *notificationSender = wsmc_create_from_uri(subsInfo->epr_notifyto);\n\tif(subsInfo->contentEncoding)\n\t\twsmc_set_encoding(notificationSender, subsInfo->contentEncoding);\n\tif(subsInfo->username)\n\t\twsman_transport_set_userName(notificationSender, subsInfo->username);\n\tif(subsInfo->password)\n\t\twsman_transport_set_password(notificationSender, subsInfo->password);\n\tif(subsInfo->deliveryAuthType ==\n\t\tWSMAN_SECURITY_PROFILE_HTTP_BASIC_TYPE) {\n\t}\n\telse if(subsInfo->deliveryAuthType ==\n\t\tWSMAN_SECURITY_PROFILE_HTTP_DIGEST_TYPE) {\n\t}\n\telse if(subsInfo->deliveryAuthType ==\n\t\tWSMAN_SECURITY_PROFILE_HTTPS_BASIC_TYPE) {\n\t\twsman_transport_set_verify_peer(notificationSender, 0);\n\t}\n\telse if(subsInfo->deliveryAuthType ==\n\t\tWSMAN_SECURITY_PROFILE_HTTPS_DIGEST_TYPE) {\n\t\twsman_transport_set_verify_peer(notificationSender, 0);\n\t}\n\telse if(subsInfo->deliveryAuthType ==\n\t\tWSMAN_SECURITY_PROFILE_HTTPS_MUTUAL_TYPE) {\n\t\twsman_transport_set_verify_peer(notificationSender, 1);\n\t\twsman_transport_set_certhumbprint(notificationSender, subsInfo->certificate_thumbprint);\n\t}\n\telse if(subsInfo->deliveryAuthType ==\n\t\tWSMAN_SECURITY_PROFILE_HTTPS_MUTUAL_BASIC_TYPE) {\n\t\twsman_transport_set_verify_peer(notificationSender, 1);\n\t\twsman_transport_set_certhumbprint(notificationSender, subsInfo->certificate_thumbprint);\n\t}\n\telse if(subsInfo->deliveryAuthType ==\n\t\tWSMAN_SECURITY_PROFILE_HTTPS_MUTUAL_DIGEST_TYPE) {\n\t\twsman_transport_set_verify_peer(notificationSender, 1);\n\t\twsman_transport_set_certhumbprint(notificationSender, subsInfo->certificate_thumbprint);\n\t}\n\telse if(subsInfo->deliveryAuthType ==\n\t\tWSMAN_SECURITY_PROFILE_HTTPS_SPNEGO_KERBEROS_TYPE) {\n\t}\n\telse if(subsInfo->deliveryAuthType ==\n\t\tWSMAN_SECURITY_PROFILE_HTTPS_MUTUAL_SPNEGO_KERBEROS_TYPE) {\n\t}\n\telse { //WSMAN_SECURITY_PROFILE_HTTP_SPNEGO_KERBEROS_TYPE\n\t}\n\twsmc_transport_init(notificationSender, NULL);\n\tif (wsman_send_request(notificationSender, outdoc)) {\n                warning(\"wse_send_notification: wsman_send_request fails for endpoint %s\", subsInfo->epr_notifyto);\n                /* FIXME: retVal */\n        }\n\tif(acked) {\n\t\tretVal = WSE_NOTIFICATION_NOACK;\n\t\tWsXmlDocH ackdoc = wsmc_build_envelope_from_response(notificationSender);\n\t\tif(ackdoc) {\n\t\t\tWsXmlNodeH node = ws_xml_get_soap_header(ackdoc);\n\t\t\tWsXmlNodeH srcnode = ws_xml_get_soap_header(outdoc);\n\t\t\tWsXmlNodeH temp = NULL;\n\t\t\tsrcnode = ws_xml_get_child(srcnode, 0, XML_NS_ADDRESSING, WSA_MESSAGE_ID);\n\t\t\tif(node) {\n\t\t\t\ttemp = ws_xml_get_child(node, 0, XML_NS_ADDRESSING, WSA_RELATES_TO);\n\t\t\t\tif(temp) {\n\t\t\t\t\tif(!strcasecmp(ws_xml_get_node_text(srcnode),\n\t\t\t\t\t\tws_xml_get_node_text(temp))) {\n\t\t\t\t\t\tnode = ws_xml_get_child(node, 0, XML_NS_ADDRESSING, WSA_ACTION);\n\t\t\t\t\t\tif(!strcasecmp(ws_xml_get_node_text(node), WSMAN_ACTION_ACK))\n\t\t\t\t\t\t\tretVal = 0;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tws_xml_destroy_doc(ackdoc);\n\t\t}\n\t}\n\twsmc_release(notificationSender);\n\treturn retVal;\n}\n\n\nstatic void * wse_event_sender(void * thrdcntx, unsigned char flag)\n{\n\tchar uuidBuf[50];\n\tWsXmlNodeH header;\n\tif(thrdcntx == NULL) return NULL;\n\tWsEventThreadContextH threadcntx = (WsEventThreadContextH)thrdcntx;\n\tWsSubscribeInfo * subsInfo = threadcntx->subsInfo;\n\tif(flag == 1)\n\t\tdebug(\"wse_notification_sender for %s started\", subsInfo->subsId);\n\telse\n\t\tdebug(\"wse_heartbeat_sender for %s started\", subsInfo->subsId);\n\tWsXmlDocH notificationDoc = NULL;\n\tpthread_mutex_lock(&subsInfo->notificationlock);\n\tif(flag == 1)\n\t\tsubsInfo->eventSentLastTime = 1;\n\tif(!(subsInfo->flags & WSMAN_SUBSCRIBEINFO_UNSUBSCRIBE) &&\n\t\t!time_expired(subsInfo->expires)) {\n\t\tif(flag) {\n\t\t\tnotificationDoc = threadcntx->outdoc;\n\t\t}\n\t\telse {\n\t \t\tnotificationDoc = ws_xml_duplicate_doc(subsInfo->heartbeatDoc);\n\t\t\theader = ws_xml_get_soap_header(notificationDoc);\n\t\t\tgenerate_uuid(uuidBuf, sizeof(uuidBuf), 0);\n\t\t\tws_xml_add_child(header, XML_NS_ADDRESSING, WSA_MESSAGE_ID,uuidBuf);\n\t\t}\n\t\tif (subsInfo->deliveryMode == WS_EVENT_DELIVERY_MODE_EVENTS  ||\n\t\t\tsubsInfo->deliveryMode == WS_EVENT_DELIVERY_MODE_PUSHWITHACK){\n\t\t\tif(wse_send_notification(threadcntx, notificationDoc, subsInfo, 1) == WSE_NOTIFICATION_NOACK)\n\t\t\t\tsubsInfo->flags |= WSMAN_SUBSCRIPTION_CANCELLED;\n\t\t}\n\t\telse\n\t\t\twse_send_notification(threadcntx, notificationDoc, subsInfo, 0);\n\t}\n\tws_xml_destroy_doc(notificationDoc);\n\tsubsInfo->flags &= ~WSMAN_SUBSCRIPTION_NOTIFICAITON_PENDING;\n\tdebug(\"[ wse_notification_sender thread for %s quit! ]\",subsInfo->subsId);\n\tpthread_mutex_unlock(&subsInfo->notificationlock);\n\tu_free(thrdcntx);\n\treturn NULL;\n}\n\nvoid * wse_heartbeat_sender(void *thrdcntx)\n{\n\treturn wse_event_sender(thrdcntx, 0);\n}\n\nvoid *wse_notification_sender(void *thrdcntx)\n{\n\treturn wse_event_sender(thrdcntx, 1);\n}\n\nvoid wse_notification_manager(void * cntx)\n{\n\tint retVal;\n\tWsSubscribeInfo * subsInfo = NULL;\n\tWsXmlDocH notificationDoc =NULL;\n\tWsXmlNodeH header = NULL;\n\tWsXmlNodeH body = NULL;\n\tWsXmlNodeH node = NULL;\n\tWsXmlNodeH eventnode = NULL;\n\tWsXmlNodeH temp = NULL;\n\tlnode_t *subsnode = NULL;\n\tWsEventThreadContextH threadcntx = NULL;\n\tWsContextH contex = (WsContextH)cntx;\n\tSoapH soap = contex->soap;\n\tWsContextH soapCntx = ws_get_soap_context(soap);\n\tpthread_t eventsender;\n\tpthread_attr_t pattrs;\n\tchar uuidBuf[50];\n\tint r;\n\tif ((r = pthread_attr_init(&pattrs)) != 0) {\n\t\tdebug(\"pthread_attr_init failed = %d\", r);\n\t\treturn;\n\t}\n\tif ((r = pthread_attr_setdetachstate(&pattrs,\n\t\t\t\t\t     PTHREAD_CREATE_DETACHED)) !=0) {\n\t\tdebug(\"pthread_attr_setdetachstate = %d\", r);\n\t\treturn;\n\t}\n\tpthread_mutex_lock(&soap->lockSubs);\n\tsubsnode = list_first(soapCntx->subscriptionMemList);\n\twhile(subsnode) {\n\t\tsubsInfo = (WsSubscribeInfo *)subsnode->list_data;\n\t\tpthread_mutex_lock(&subsInfo->notificationlock);\n\t\tthreadcntx = ws_create_event_context(soap, subsInfo, NULL);\n\t\tif(((subsInfo->flags & WSMAN_SUBSCRIBEINFO_UNSUBSCRIBE) ||\n\t\t\tsubsInfo->flags & WSMAN_SUBSCRIPTION_CANCELLED ||\n\t\t\ttime_expired(subsInfo->expires)) &&\n\t\t\t((subsInfo->flags & WSMAN_SUBSCRIPTION_NOTIFICAITON_PENDING ) == 0)) {\n\t\t\tlnode_t *nodetemp = list_delete2(soapCntx->subscriptionMemList, subsnode);\n\t\t\tsoap->subscriptionOpSet->delete_subscription(soap->uri_subsRepository, subsInfo->subsId);\n\t\t\tsoap->eventpoolOpSet->clear(subsInfo->subsId, delete_notification_info);\n\t\t\tif(!(subsInfo->flags & WSMAN_SUBSCRIBEINFO_UNSUBSCRIBE) && subsInfo->cancel)\n\t\t\t\tsubsInfo->cancel(threadcntx);\n\t\t\tif(subsInfo->flags & WSMAN_SUBSCRIBEINFO_UNSUBSCRIBE)\n\t\t\t\tdebug(\"Unsubscribed!uuid:%s deleted\", subsInfo->subsId);\n\t\t\telse if(subsInfo->flags & WSMAN_SUBSCRIPTION_CANCELLED)\n\t\t\t\tdebug(\"Cancelled! uuid:%s deleted\", subsInfo->subsId);\n\t\t\telse\n\t\t\t\tdebug(\"Expired! uuid:%s deleted\", subsInfo->subsId);\n\t\t\tdestroy_subsinfo(subsInfo);\n\t\t\tlnode_destroy(subsnode);\n\t\t\tu_free(threadcntx);\n\t\t\tsubsnode = nodetemp;\n\t\t\tcontinue;\n\t\t}\n\t\tif(subsInfo->eventpoll) { //poll the events\n\t\t\tretVal = subsInfo->eventpoll(threadcntx);\n\t\t\tif(retVal == WSE_NOTIFICATION_EVENTS_PENDING) {\n\t\t\t\tgoto LOOP;\n\t\t\t}\n\t\t}\n\t\tif(subsInfo->deliveryMode == WS_EVENT_DELIVERY_MODE_PULL)\n\t\t\tgoto LOOP;\n\t\tWsNotificationInfoH notificationInfo = NULL;\n\t\tif(soap->eventpoolOpSet->remove(subsInfo->subsId, &notificationInfo) ) // to get the event and delete it from the event source\n\t\t\tgoto LOOP;\n\t\tif(subsInfo->deliveryMode == WS_EVENT_DELIVERY_MODE_PULL) goto LOOP;\n\t\tnotificationDoc = ws_xml_duplicate_doc(subsInfo->templateDoc);\n\t\theader = ws_xml_get_soap_header(notificationDoc);\n\t\tbody = ws_xml_get_soap_body(notificationDoc);\n\t\tif(notificationInfo->headerOpaqueData) {\n\t\t\ttemp = ws_xml_get_doc_root(notificationInfo->headerOpaqueData);\n\t\t\tws_xml_duplicate_tree(header, temp);\n\t\t}\n\t\tif(subsInfo->deliveryMode == WS_EVENT_DELIVERY_MODE_EVENTS) {\n\t\t\tws_xml_add_child(header, XML_NS_ADDRESSING, WSA_ACTION, WSEVENT_DELIVERY_MODE_EVENTS);\n\t\t\tgenerate_uuid(uuidBuf, sizeof(uuidBuf), 0);\n\t\t\tws_xml_add_child(header, XML_NS_ADDRESSING, WSA_MESSAGE_ID,uuidBuf);\n\t\t\teventnode = ws_xml_add_child(body, XML_NS_WS_MAN, WSM_EVENTS, NULL);\n\t\t\twhile(notificationInfo) {\n\t\t\t\ttemp = ws_xml_add_child(eventnode, XML_NS_WS_MAN, WSM_EVENT, NULL);\n\t\t\t\tif(notificationInfo->EventAction)  {\n\t\t\t\t\tws_xml_add_node_attr(temp, XML_NS_WS_MAN, WSM_ACTION, notificationInfo->EventAction);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tws_xml_add_node_attr(temp, XML_NS_WS_MAN, WSM_ACTION, WSMAN_ACTION_EVENT);\n\t\t\t\t}\n\t\t\t\tif(temp) {\n\t\t\t\t\tnode = ws_xml_get_doc_root(notificationInfo->EventContent);\n\t\t\t\t\tws_xml_duplicate_children(temp, node);\n\t\t\t\t}\n\t\t\t\tdelete_notification_info(notificationInfo);\n\t\t\t\tsoap->eventpoolOpSet->remove(subsInfo->subsId, &notificationInfo);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tgenerate_uuid(uuidBuf, sizeof(uuidBuf), 0);\n\t\t\tws_xml_add_child(header, XML_NS_ADDRESSING, WSA_MESSAGE_ID,uuidBuf);\n\t\t\tif(notificationInfo->EventAction)\n\t\t\t\tws_xml_add_child(header, XML_NS_WS_MAN, WSM_ACTION, notificationInfo->EventAction);\n\t\t\telse\n\t\t\t\tws_xml_add_child(header, XML_NS_WS_MAN, WSM_ACTION, WSMAN_ACTION_EVENT);\n\t\t\tnode = ws_xml_get_doc_root(notificationInfo->EventContent);\n\t\t\tws_xml_duplicate_children(body, node);\n\t\t\tdelete_notification_info(notificationInfo);\n\t\t}\n\t\tif(subsInfo->deliveryMode != WS_EVENT_DELIVERY_MODE_PULL) {\n\t\t\tif((subsInfo->flags & WSMAN_SUBSCRIPTION_NOTIFICAITON_PENDING) == 0) {\n\t\t\t\tWsEventThreadContextH threadcntx2 = ws_create_event_context(soap, subsInfo, notificationDoc);\n\t\t\t\tif(pthread_create(&eventsender, &pattrs, wse_notification_sender, threadcntx2) == 0) {\n\t\t\t\t\tsubsInfo->flags |= WSMAN_SUBSCRIPTION_NOTIFICAITON_PENDING;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdebug(\"thread created for %s failed![ %s ]\", subsInfo->subsId, strerror(errno));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\nLOOP:\n\t\tif(threadcntx)\n\t\t\tu_free(threadcntx);\n\t\tpthread_mutex_unlock(&subsInfo->notificationlock);\n\t\tsubsnode = list_next(soapCntx->subscriptionMemList, subsnode);\n\t}\n\tpthread_mutex_unlock(&soap->lockSubs);\n}\n\n\n\n#endif\n\n\nWsContextH\nws_get_soap_context(SoapH soap)\n{\n\treturn soap->cntx;\n}\n\n\nint\nws_remove_context_val(WsContextH cntx, char *name)\n{\n\tint retVal = 1;\n\tif (cntx && name) {\n\t\thnode_t        *hn;\n\t\tu_lock(cntx->soap);\n\t\thn = hash_lookup(cntx->entries, name);\n\t\tif (hn) {\n\t\t\tdebug(\"Found context entry: %s\", name);\n\t\t\thash_delete_free(cntx->entries, hn);\n\t\t\tretVal = 0;\n\t\t}\n\t\tu_unlock(cntx->soap);\n\t}\n\treturn retVal;\n}\n\nint\nws_set_context_ulong_val(WsContextH cntx,\n\t\t\t char *name,\n\t\t\t unsigned long val)\n{\n\tint retVal = set_context_val(cntx, name, &val, sizeof(unsigned long),\n\t\t\t0, WS_CONTEXT_TYPE_ULONG);\n\treturn retVal;\n}\n\n\nint\nws_set_context_xml_doc_val(WsContextH cntx,\n\t\t\t   char *name,\n\t\t\t   WsXmlDocH val)\n{\n\tcntx->indoc = val;\n\treturn 0;\n}\n\nWsContextH\nws_create_ep_context(SoapH soap,\n\t\t     WsXmlDocH doc)\n{\n\tWsContextH      cntx = ws_create_context(soap);\n\tif (cntx)\n\t\tws_set_context_xml_doc_val(cntx, WSFW_INDOC, doc);\n\treturn cntx;\n}\n\n\nint\nws_destroy_context(WsContextH cntx)\n{\n\tint             retVal = 1;\n\tif (cntx && cntx->owner) {\n\t\tws_clear_context_entries(cntx);\n\t\tws_clear_context_enuminfos(cntx);\n\t\tws_serializer_cleanup(cntx->serializercntx);\n\t\tif(cntx->subscriptionMemList) {\n\t\t\tlist_destroy_nodes(cntx->subscriptionMemList);\n\t\t\tlist_destroy(cntx->subscriptionMemList);\n\t\t}\n\t\tu_free(cntx);\n\t\tretVal = 0;\n\t}\n\treturn retVal;\n}\n\n\nhnode_t*\ncreate_context_entry(hash_t * h,\n\t\t     char *name,\n\t\t     void *val)\n{\n\tchar           *key = u_strdup(name);\n\thnode_t        *hn = hnode_create(val);\n\tif (!key || !hn) {\n\t\tu_free(key);\n\t\tu_free(hn);\n\t\treturn NULL;\n\t}\n\thash_insert(h, hn, (void *) key);\n\treturn hn;\n}\n\nSoapH\nws_context_get_runtime(WsContextH cntx)\n{\n\tSoapH soap = NULL;\n\tif (cntx)\n\t\tsoap = cntx->soap;\n\treturn soap;\n}\n\n\nconst void *\nget_context_val(WsContextH cntx, const char *name)\n{\n\tconst char *val = NULL;\n\tif (cntx && name) {\n\t\tu_lock(cntx->soap);\n\t\tif (cntx->entries) {\n\t\t\thnode_t *hn = hash_lookup(cntx->entries, name);\n\t\t\tif (hn)\n\t\t\t\tval = hnode_get(hn);\n\t\t}\n\t\tu_unlock(cntx->soap);\n\t}\n\treturn val;\n}\n\n\nconst void *\nws_get_context_val(WsContextH cntx, const char *name, int *size)\n{\n\treturn get_context_val(cntx, name);\n}\n\n\nunsigned long\nws_get_context_ulong_val(WsContextH cntx, char *name)\n{\n\tconst void *ptr = get_context_val(cntx, name);\n\tif (ptr != NULL)\n\t\treturn *((unsigned long *) ptr);\n\treturn 0;\n}\n\n\nSoapOpH\nsoap_create_op(SoapH soap,\n\t       char *inboundAction,\n\t       char *outboundAction, //optional\n\t       char *role,\n\t       SoapServiceCallback callbackProc,\n\t       void *callbackData,\n\t       unsigned long flags)\n{\n\tSoapDispatchH  disp = NULL;\n\top_t           *entry = NULL;\n\n\tif ((disp = wsman_dispatch_create(soap, inboundAction, outboundAction,\n\t\t\t      NULL, //reserved, must be NULL\n\t\t\t      callbackProc, callbackData, flags)) != NULL) {\n\t\tentry = create_op_entry(soap, disp, NULL);\n\t}\n\treturn (SoapOpH) entry;\n}\n\n\n\n/**\n * Get Operation Document\n * @param op Operation Handle\n * @param inbound Direction flag\n * @return XML Document\n */\nWsXmlDocH\nsoap_get_op_doc(SoapOpH op,\n\t\tint inbound)\n{\n\tWsXmlDocH       doc = NULL;\n\tif (op) {\n\t\top_t           *e = (op_t *) op;\n\t\tdoc = (!inbound) ? e->out_doc : e->in_doc;\n\t}\n\treturn doc;\n}\n\nWsXmlDocH\nsoap_detach_op_doc(SoapOpH op,\n\t\t   int inbound)\n{\n\tWsXmlDocH       doc = NULL;\n\tif (op) {\n\t\top_t           *e = (op_t *) op;\n\t\tif (!inbound) {\n\t\t\tdoc = e->out_doc;\n\t\t\te->out_doc = NULL;\n\t\t} else {\n\t\t\tdoc = e->in_doc;\n\t\t\te->in_doc = NULL;\n\t\t}\n\t}\n\treturn doc;\n}\n\nint\nsoap_set_op_doc(SoapOpH op,\n\t\tWsXmlDocH doc,\n\t\tint inbound)\n{\n\tint             retVal = 1;\n\tif (op) {\n\t\top_t           *e = (op_t *) op;\n\t\tif (!inbound)\n\t\t\te->out_doc = doc;\n\t\telse\n\t\t\te->in_doc = doc;\n\t\tretVal = 0;\n\t}\n\treturn retVal;\n}\n\n\nSoapH\nsoap_get_op_soap(SoapOpH op)\n{\n\tif (op)\n\t\treturn (SoapH) ((op_t *) op)->dispatch->soap;\n\n\treturn NULL;\n}\n\nvoid\nsoap_destroy_op(SoapOpH op)\n{\n\tdestroy_op_entry((op_t *) op);\n}\n\n\nop_t *\ncreate_op_entry(SoapH soap,\n\t\tSoapDispatchH dispatch,\n\t\tWsmanMessage * data)\n{\n\top_t *entry = (op_t *) u_zalloc(sizeof(op_t));\n\tif (entry) {\n\t\tentry->dispatch = dispatch;\n\t\tentry->cntx = ws_create_context(soap);\n\t\tentry->data = data;\n\t\t// entry->processed_headers = list_create(LISTCOUNT_T_MAX);\n\t}\n\treturn entry;\n}\n\n\nvoid\ndestroy_op_entry(op_t * entry)\n{\n\tSoapH           soap;\n\tdebug(\"destroy op\");\n\tif (!entry) {\n\t\tdebug(\"nothing to destroy...\");\n\t\treturn;\n\t}\n\tsoap = entry->dispatch->soap;\n\tif (soap == NULL) {\n\t\tgoto NULL_SOAP;\n\t}\n\tu_lock(soap);\n\tif (soap->dispatchList && list_contains(soap->dispatchList, &entry->dispatch->node)) {\n\t\tlist_delete(soap->dispatchList, &entry->dispatch->node);\n\t}\n\tu_unlock(soap);\n\nNULL_SOAP:\n\tdestroy_dispatch_entry(entry->dispatch);\n\tws_destroy_context(entry->cntx);\n#if 0\n\tlist_destroy_nodes(entry->processed_headers);\n\tlist_destroy(entry->processed_headers);\n#endif\n\tu_free(entry);\n}\n\nvoid\ndestroy_dispatch_entry(SoapDispatchH entry)\n{\n\tint usageCount;\n\tlist_t *dlist;\n\tif (!entry) {\n\t\treturn;\n\t}\n\n\tu_lock(entry->soap);\n\tentry->usageCount--;\n\tusageCount = entry->usageCount;\n\tdlist = entry->soap->dispatchList;\n\tif (!usageCount && dlist != NULL &&\n\t\t\tlist_contains(dlist, &entry->node)) {\n\t\tlnode_t *n = list_delete(dlist, &entry->node);\n\t\tlnode_destroy(n);\n\t}\n\tu_unlock(entry->soap);\n\n\tif (!usageCount) {\n\t\tif (entry->inboundFilterList) {\n\t\t\tlist_destroy_nodes(entry->inboundFilterList);\n\t\t\tlist_destroy(entry->inboundFilterList);\n\t\t}\n\t\tif (entry->outboundFilterList) {\n\t\t\tlist_destroy_nodes(entry->outboundFilterList);\n\t\t\tlist_destroy(entry->outboundFilterList);\n\t\t}\n\n\t\tu_free(entry->inboundAction);\n\t\tu_free(entry->outboundAction);\n\n\t\tu_free(entry);\n\t}\n}\n\n\nvoid\nsoap_destroy(SoapH soap)\n{\n\tif (soap == NULL )\n\t\treturn;\n\n\tif (soap->dispatcherProc)\n\t\tsoap->dispatcherProc(soap->cntx, soap->dispatcherData, NULL);\n\n\tif (soap->dispatchList) {\n\t\twhile (!list_isempty(soap->dispatchList)) {\n\t\t\tdestroy_dispatch_entry(\n\t\t\t\t(SoapDispatchH)list_first(soap->dispatchList));\n\t\t}\n\t\tlist_destroy(soap->dispatchList);\n\t}\n\n\tif (soap->processedMsgIdList) {\n\t\twhile (!list_isempty(soap->processedMsgIdList)) {\n\t\t\tlnode_t *node = list_del_first(soap->processedMsgIdList);\n\t\t\tu_free(node->list_data);\n\t\t\tlnode_destroy(node);\n\t\t}\n\t\tlist_destroy(soap->processedMsgIdList);\n\t}\n\n\n\tif (soap->inboundFilterList) {\n\t\tlist_destroy_nodes(soap->inboundFilterList);\n\t\tlist_destroy(soap->inboundFilterList);\n\t}\n\n\tif (soap->outboundFilterList) {\n\t\tlist_destroy_nodes(soap->outboundFilterList);\n\t\tlist_destroy(soap->outboundFilterList);\n\t}\n\tws_xml_parser_destroy();\n\n\tws_destroy_context(soap->cntx);\n\tu_free(soap);\n\n\treturn;\n}\n\n\nvoid\nwsman_status_init(WsmanStatus * status)\n{\n\tstatus->fault_code = 0;\n\tstatus->fault_detail_code = 0;\n\tstatus->fault_msg = NULL;\n}\n\nint\nwsman_check_status(WsmanStatus * status)\n{\n\treturn status->fault_code;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-openwsman-2.6.11-urnjctbu3pjxgiqzjtqviczvlqse3qms/spack-src/src/server/wsmand-listener.c": "/*******************************************************************************\n * Copyright (C) 2004-2006 Intel Corp. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *  - Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *\n *  - Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n *  - Neither the name of Intel Corp. nor the names of its\n *    contributors may be used to endorse or promote products derived from this\n *    software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL Intel Corp. OR THE CONTRIBUTORS\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *******************************************************************************/\n\n/**\n * @author Anas Nashif\n * @author Vadim Revyakin\n * @author Liang Hou\n */\n\n#define _GNU_SOURCE\n#ifdef HAVE_CONFIG_H\n#include \"wsman_config.h\"\n#endif\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <assert.h>\n\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n\n#ifndef WIN32\n#include <dlfcn.h>\n#endif\n\n#include \"u/libu.h\"\n#include \"wsman-xml-api.h\"\n#include \"wsman-soap.h\"\n#include \"wsman-soap-envelope.h\"\n\n#include \"wsman-xml.h\"\n#include \"wsman-xml-serializer.h\"\n#include \"wsman-dispatcher.h\"\n\n\n#include \"shttpd.h\"\n#include \"shttpd/adapter.h\" /* shttpd_get_credentials() */\n#include \"wsman-plugins.h\"\n#include \"wsmand-listener.h\"\n#include \"wsmand-daemon.h\"\n#include \"wsman-server.h\"\n#include \"wsman-server-api.h\"\n#include \"wsman-plugins.h\"\n#ifdef ENABLE_EVENTING_SUPPORT\n#include \"wsman-cimindication-processor.h\"\n#endif\n\n\n#ifdef HAVE_PTHREAD_H\n#include <pthread.h>\n#endif\n#include <sys/socket.h>\n\n\nstatic pthread_mutex_t shttpd_mutex;\nstatic pthread_cond_t shttpd_cond;\nint continue_working = 1;\nstatic int (*basic_callback) (char *, char *) = NULL;\n\nstruct thread {\n    struct thread       *next;\n    struct shttpd_ctx   *ctx;\n};\n\nstatic struct thread    *threads;   /* List of worker threads */\n\ntypedef struct {\n\tchar *response;\n\tint length;\n\tint ind;\n} ShttpMessage;\n\n#ifdef SHTTPD_GSS\nchar * gss_decrypt(struct shttpd_arg *arg, char *data, int len);\nint gss_encrypt(struct shttpd_arg *arg, char *input, int inlen, char **output, int *outlen);\n#endif\n\n/* Check HTTP headers */\nstatic\nint check_request_content_type(struct shttpd_arg *arg) {\n\tconst char *content_type;\n\tint status = WSMAN_STATUS_OK;\n\n\tcontent_type = shttpd_get_header(arg, \"Content-Type\");\n\tif (content_type && strncmp(content_type,\n\t\t\t\t    SOAP_CONTENT_TYPE,\n\t\t\t\t    strlen(SOAP_CONTENT_TYPE)) != 0) {\n\t\tstatus = WSMAN_STATUS_UNSUPPORTED_MEDIA_TYPE;\n\t}\n\treturn status;\n}\n\nstatic\nchar *get_request_encoding(struct shttpd_arg *arg) {\n\tconst char *content_type;\n\tchar *p;\n\tchar *encoding = \"UTF-8\";\n\n\tcontent_type = shttpd_get_header(arg, \"Content-Type\");\n\tif(content_type ) {\n\t\tif(( p = strstr(content_type, \"charset\")) != NULL ) {\n\t\t\tp += strlen(\"charset\");\n\t\t\tp++;\n\t\t\tencoding = p;\n\t\t}\n\t}\n\treturn encoding;\n}\n\nstatic\nvoid server_callback(struct shttpd_arg *arg)\n{\n\tchar *encoding = \"UTF-8\";\n\tconst char  *s;\n\tSoapH soap;\n\tint k;\n\tint status = WSMAN_STATUS_OK;\n\tchar *request_uri;\n\n\tchar *fault_reason = NULL;\n\tstruct state {\n        \tsize_t  cl;     /* Content-Length   */\n\t        size_t  nread;      /* Number of bytes read */\n\t \tu_buf_t *request;\n\t \tchar    *response;\n\t\tsize_t  len;\n\t\tint     index;\n\t\tint     type;\n\t} *state;\n\n\n\t/* If the connection was broken prematurely, cleanup */\n\tif ( (arg->flags & SHTTPD_CONNECTION_ERROR ) && arg->state) {\n        \tfree(arg->state);\n\t\treturn;\n\t} else if ((s = shttpd_get_header(arg, \"Content-Length\")) == NULL) {\n        \tshttpd_printf(arg, \"HTTP/1.0 411 Length Required\\n\\n\");\n\t        arg->flags |= SHTTPD_END_OF_OUTPUT;\n\t\treturn;\n\t} else if (arg->state == NULL) {\n        \t/* New request. Allocate a state structure */\n        \targ->state = state = calloc(1, sizeof(*state));\n\t        state->cl = strtoul(s, NULL, 10);\n\t\tu_buf_create(&(state->request));\n\t}\n\n\tstate = arg->state;\n\tif ( state->response ) {\n\t\tgoto CONTINUE;\n\t}\n\n\tif (state->nread>0 )\n\t\tu_buf_append(state->request, arg->in.buf, arg->in.len);\n\telse\n\t\tu_buf_set(state->request, arg->in.buf, arg->in.len);\n\n\tstate->nread += arg->in.len;\n\targ->in.num_bytes = arg->in.len;\n\tif (state->nread >= state->cl) {\n\t\tdebug(\"Done reading request\");\n\t} else {\n\t\treturn;\n\t}\n#ifdef SHTTPD_GSS\n\tconst char *ct = shttpd_get_header(arg, \"Content-Type\");\n\tchar *payload = 0; // used for gss encrypt\n\n\tif (ct && !memcmp(ct, \"multipart/encrypted\", 19)) {\n\t        // we have a encrypted payload. decrypt it \n        \tpayload = gss_decrypt(arg, u_buf_ptr(state->request), u_buf_len(state->request));\n\t}\n#endif\n\trequest_uri = (char *)shttpd_get_env(arg, \"REQUEST_URI\");\n\tif (strcmp(request_uri, \"/wsman\") == 0 ) {\n\n\t\t/* Here we must handle the initial request */\n\t\tWsmanMessage *wsman_msg = wsman_soap_message_new();\n#ifdef SHTTPD_GSS\n\t        if(payload == 0) {\n#endif\n\t\t\tif ( (status = check_request_content_type(arg) ) != WSMAN_STATUS_OK ) {\n\t\t\t\twsman_soap_message_destroy(wsman_msg);\n\t\t\t\tgoto DONE;\n\t\t\t}\n\t\t\tencoding = get_request_encoding(arg);\n\n\t\t\tu_buf_set(wsman_msg->request, u_buf_ptr(state->request), u_buf_len(state->request));\n#ifdef SHTTPD_GSS\n\t        }\n\t\telse {\n\t\t\tu_buf_set(wsman_msg->request, payload, strlen(payload));\n\t\t}\n#endif\n\t        wsman_msg->charset = u_strdup(encoding);\n\t\tsoap = (SoapH) arg->user_data;\n\t\twsman_msg->status.fault_code = WSMAN_RC_OK;\n\n\t\t/*\n\t\t * some plugins can use credentials for their own authentication\n\t\t * works only with basic authentication\n\t\t */\n\t\tshttpd_get_credentials(arg, &wsman_msg->auth_data.username,\n\t\t\t\t&wsman_msg->auth_data.password);\n\n\t\t/* Call dispatcher. Real request handling */\n\t\tif (status == WSMAN_STATUS_OK) {\n\t\t\t/* dispatch if we didn't find out any error */\n\t\t\tchar *idfile = wsmand_options_get_identify_file();\n\t\t\tif (idfile && wsman_check_identify(wsman_msg) == 1) {\n\t\t\t\tif (u_buf_load(wsman_msg->response, idfile)) {\n\t\t\t\t\tdispatch_inbound_call(soap, wsman_msg, NULL);\n\t\t\t\t\tstatus = wsman_msg->http_code;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatch_inbound_call(soap, wsman_msg, NULL);\n\t\t\t\tstatus = wsman_msg->http_code;\n\t\t\t}\n\t\t}\n\t\tif (wsman_msg->request) {\n#ifdef SHTTPD_GSS\n\t\t\tif (payload) {\n\t\t\t\tfree(payload);\n\t\t\t\t/* note that payload is stiil set - this is used as a flag later */\n\t\t\t}\n\t\t\telse {\n#endif\n\t\t\t\tu_buf_free(wsman_msg->request);\n#ifdef SHTTPD_GSS\n\t\t\t}\n#endif\n\t\t\twsman_msg->request = NULL;\n\t\t}\n\n\t\tstate->len =  u_buf_len(wsman_msg->response);;\n\t\tstate->response = u_buf_steal(wsman_msg->response);\n\t\tstate->index = 0;\n\t\tstate->type = 0;\n\n\t\twsman_soap_message_destroy(wsman_msg);\n#ifdef ENABLE_EVENTING_SUPPORT\n\t} else if (strncmp(request_uri, DEFAULT_CIMINDICATION_PATH, strlen(DEFAULT_CIMINDICATION_PATH)) == 0 ) {\n\t\tstatus = CIMXML_STATUS_OK;\n\t\tint cim_error_code = 0;\n\t\tchar *cim_error = NULL;\n\t\tchar *fault_reason = NULL;\n\t\tchar *uuid = NULL, *tmp, *end;\n\t\tcimxml_context *cntx = NULL;\n\t\tSoapH soap = NULL;\n\t\tCimxmlMessage *cimxml_msg = cimxml_message_new();\n\t\ttmp = (char *)shttpd_get_env(arg, \"REQUEST_URI\");\n\t\tif (tmp && ( end = strrchr(tmp, '/')) != NULL ) {\n\t\t\tuuid = &end[1];\n\t\t}\n\t        encoding = get_request_encoding(arg);\n\t\tcimxml_msg->charset = u_strdup(encoding);\n\t\tconst char *cimexport = shttpd_get_header(arg, \"CIMExport\");\n\t\tconst char *cimexportmethod = shttpd_get_header(arg, \"CIMExportMethod\");\n\t\tif ( cimexportmethod && cimexport ) {\n\t\t\tif(strncmp(cimexport, \"MethodRequest\", strlen(\"MethodRequest\")) ||\n\t\t\t\t\tstrncmp(cimexportmethod, \"ExportIndication\", strlen(\"ExportIndication\"))) {\n\t\t\t}\n\t\t} else {\n\t\t\tstatus = WSMAN_STATUS_FORBIDDEN;\n\t\t\tcim_error_code = CIMXML_STATUS_UNSUPPORTED_OPERATION;\n\t\t\tcim_error = \"unsupported-operation\";\n\t\t\tgoto DONE;\n\t\t}\n\t\tsoap = (SoapH) arg->user_data;\n\t\tu_buf_set(cimxml_msg->request, u_buf_ptr(state->request), u_buf_len(state->request));\n\t\tcntx = u_malloc(sizeof(cimxml_context));\n\t\tcntx->soap = soap;\n\t\tcntx->uuid = uuid;\n\t\tCIM_Indication_call(cntx, cimxml_msg, NULL);\n\t\tstatus = cimxml_msg->http_code;\n\t\tcim_error_code = cimxml_msg->status.code;\n\t\tcim_error = cimxml_msg->status.fault_msg;\n\t\tif (cim_error) {\n\t\t\tshttpd_printf(arg, \"HTTP/1.1 %d %s\\r\\n\", status, fault_reason);\n\t\t\tshttpd_printf(arg, \"CIMError:%d:%s\\r\\n\", cim_error_code, cim_error);\n\t\t\tcimxml_message_destroy(cimxml_msg);\n\t\t\tgoto CONTINUE;\n\t\t}\n\t\tstate->len =  u_buf_len(cimxml_msg->response);;\n\t\tstate->response = u_buf_steal(cimxml_msg->response);\n\t\tstate->index = 0;\n\t\tstate->type = 1;\n\t\tcimxml_message_destroy(cimxml_msg);\n#endif\n\n\t} else if (strcmp(request_uri, ANON_IDENTIFY_PATH) == 0 ) {\n\t\tchar *idfile = wsmand_options_get_anon_identify_file();\n\t\tu_buf_t *id;\n\t\tu_buf_create(&id);\n\t\tif (idfile && u_buf_load(id, idfile) == 0 ) {\n\t\t\tstate->len =  u_buf_len(id);;\n\t\t\tstate->response = u_buf_steal(id);\n\t\t\tstate->index = 0;\n\t\t\tu_buf_free(id);\n\t\t} else {\n\t\t\tshttpd_printf(arg, \"HTTP/1.0 404 Not foundn\\n\");\n\t\t\targ->flags |= SHTTPD_END_OF_OUTPUT;\n\t\t\tu_buf_free(id);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tshttpd_printf(arg, \"HTTP/1.0 404 Not foundn\\n\");\n\t\targ->flags |= SHTTPD_END_OF_OUTPUT;\n\t\treturn;\n\t}\n\nDONE:\n\n\tif (fault_reason == NULL) {\n\t\t// this is a way to segfault, investigate\n\t\t//fault_reason = shttpd_reason_phrase(status);\n\t}\n\tdebug(\"Response status=%d (%s)\", status, fault_reason);\n\n\t/*\n\t * Here we begin to create the http response.\n\t * Create the headers at first.\n\t */\n\n\tshttpd_printf(arg, \"HTTP/1.1 %d %s\\r\\n\", status, fault_reason);\n\tshttpd_printf(arg, \"Server: %s/%s\\r\\n\", PACKAGE_NAME, PACKAGE_VERSION);\n#ifdef SHTTPD_GSS\n\tif(payload) {\n\t\t// we had an encrypted message so now we have to encypt the reply\n\t\tchar *enc;\n\t\tint enclen;\n\t\tgss_encrypt(arg, state->response, state->len, &enc, &enclen);\n\t\tu_free(state->response);\n\t\tstate->response = enc;\n\t\tstate->len = enclen;\n\t\tpayload = 0; // and reset the indicator so that if we send in packates we dont do this again\n\t\tshttpd_printf(arg, \"Content-Type: multipart/encrypted;protocol=\\\"application/HTTP-Kerberos-session-encrypted\\\";boundary=\\\"Encrypted Boundary\\\"\\r\\n\");\n\t\tshttpd_printf(arg, \"Content-Length: %d\\r\\n\", state->len);\n\t}\n\telse {\n#endif\n\t\tif (state->type == 1) { /* eventing */\n\t\t\tshttpd_printf(arg, \"Content-Type: application/xml; charset=\\\"utf-8\\\"\\r\\n\");\n\t\t\tshttpd_printf(arg, \"CIMExport: MethodResponse\\r\\n\");\n\t\t} else {\n\t\t\tshttpd_printf(arg, \"Content-Type: application/soap+xml;charset=%s\\r\\n\", encoding);\n\t\t}\n    \t\tshttpd_printf(arg, \"Content-Length: %d\\r\\n\", state->len);\n#ifdef SHTTPD_GSS\n\t}\n#endif\n\tshttpd_printf(arg,\"Connection: Close\\r\\n\");\n  \n        /* separate header from message-body */\n\tshttpd_printf(arg, \"\\r\\n\");\n\n\t/* add response body to output buffer */\nCONTINUE:\n\n\n\tk = arg->out.len - arg->out.num_bytes;\n\tif (k <= state->len - state->index) {\n\t\t memcpy(arg->out.buf + arg->out.num_bytes, state->response + state->index, k );\n\t\t state->index += k ;\n\t\t arg->out.num_bytes += k;\n\t\t return;\n\t}\n\telse {\n\t         int l = state->len - state->index;\n\t\t memcpy(arg->out.buf + arg->out.num_bytes, state->response + state->index, l);\n\t\t state->index += l ;\n\t\t arg->out.num_bytes += l;\n\t}\n\n\tu_buf_free(state->request);\n\tu_free(state->response);\n\tu_free(state);\n\targ->flags |= SHTTPD_END_OF_OUTPUT;\n\treturn;\n}\n\nstatic void listener_shutdown_handler(void *p)\n{\n\tint *a = (int *) p;\n\tdebug(\"listener_shutdown_handler started\");\n\t*a = 0;\n}\n\nstatic void protect_uri(struct shttpd_ctx *ctx, char *uri)\n{\n\tif (wsmand_options_get_digest_password_file()) {\n\t\tshttpd_protect_uri(ctx, uri,\n                   wsmand_options_get_digest_password_file(),NULL, 1);\n\t\tdebug(\"Using Digest Authorization for %s:\", uri);\n\t}\n\tif (basic_callback) {\n\t\tshttpd_protect_uri(ctx, uri, wsmand_options_get_basic_password_file(),\n\t\t\t\t\t\tbasic_callback, 0);\n\t\tdebug(\"Using Basic Authorization %s for %s\",\n\t\t      wsmand_option_get_basic_authenticator()?\n\t\t      wsmand_option_get_basic_authenticator() :\n\t\t      wsmand_default_basic_authenticator(), uri);\n\t}\n}\n\nstatic struct shttpd_ctx *create_shttpd_context(SoapH soap, int port)\n{\n\tstruct shttpd_ctx *ctx;\n\tchar *tmps;\n\tint len;\n\n\tctx = shttpd_init(0, NULL);\n\tif (ctx == NULL) {\n\t\treturn NULL;\n\t}\n\tif (wsmand_options_get_use_ssl()) {\n\t\tmessage(\"ssl certificate: %s\", wsmand_options_get_ssl_cert_file());\n\t\tshttpd_set_option(ctx, \"ssl_cert\", wsmand_options_get_ssl_cert_file());\n\t}\n\tlen = snprintf(NULL, 0, \"%d%s\", port, wsmand_options_get_use_ssl() ? \"s\" : \"\");\n\ttmps = malloc((len+1) * sizeof(char));\n\tsnprintf(tmps, len+1, \"%d%s\", port, wsmand_options_get_use_ssl() ? \"s\" : \"\");\n\tshttpd_set_option(ctx, \"ports\", tmps);\n\tfree(tmps);\n\tshttpd_set_option(ctx, \"auth_realm\", AUTHENTICATION_REALM);\n\tshttpd_register_uri(ctx, wsmand_options_get_service_path(),\n\t\t\t    server_callback, (void *) soap);\n\tprotect_uri(ctx, wsmand_options_get_service_path());\n\tshttpd_register_uri(ctx, ANON_IDENTIFY_PATH,\n\t\t\t    server_callback, (void *) soap);\n\n#ifdef ENABLE_EVENTING_SUPPORT\n\tmessage(\"Registered CIM Indication Listener: %s\", DEFAULT_CIMINDICATION_PATH \"/*\");\n\tshttpd_register_uri(ctx, DEFAULT_CIMINDICATION_PATH \"/*\", server_callback,(void *)soap);\n\tprotect_uri( ctx, DEFAULT_CIMINDICATION_PATH );\n#endif\n\n\n\treturn ctx;\n}\n\n\nstatic int initialize_basic_authenticator(void)\n{\n\tchar *auth;\n\tchar *arg;\n\tvoid *hnd;\n\tint (*init) (char *);\n\tchar *name;\n\tint should_return = 0;\n\tint res = 0;\n\n\tif (wsmand_options_get_basic_password_file() != NULL) {\n\t\tif ((wsmand_option_get_basic_authenticator() &&\n\t\t     (strcmp(wsmand_default_basic_authenticator(),\n\t\t\t     wsmand_option_get_basic_authenticator()))) ||\n\t\t    wsmand_option_get_basic_authenticator_arg()) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"basic authentication is ambigious in config file\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\tauth = wsmand_default_basic_authenticator();\n\t\targ = wsmand_options_get_basic_password_file();\n\t} else {\n\t\tauth = wsmand_option_get_basic_authenticator();\n\t\targ = wsmand_option_get_basic_authenticator_arg();\n\t}\n\n\tif (auth == NULL) {\n\t\t/* No basic authenticationame */\n\t\treturn 0;\n\t}\n\n\tif (auth[0] == '/') {\n\t\tname = auth;\n\t} else {\n\t\tname = u_strdup_printf(\"%s/%s\", PACKAGE_AUTH_DIR, auth);\n\t\tshould_return = 1;\n\t}\n\n\thnd = dlopen(name, RTLD_LAZY | RTLD_GLOBAL);\n\tif (hnd == NULL) {\n\t\tfprintf(stderr, \"Could not dlopen %s\\n\", name);\n\t\tres = 1;\n\t\tgoto DONE;\n\t}\n\tbasic_callback = dlsym(hnd, \"authorize\");\n\tif (basic_callback == NULL) {\n\t\tfprintf(stderr, \"Could not resolve authorize() in %s\\n\",\n\t\t\tname);\n\t\tres = 1;\n\t\tgoto DONE;\n\t}\n\n\tinit = dlsym(hnd, \"initialize\");\n\tif (init != NULL) {\n\t\tres = init(arg);\n\t}\n      DONE:\n\tif (should_return) {\n\t\tu_free(name);\n\t}\n\treturn res;\n}\n\n\nstatic int get_server_auth(void) {\n\tif (initialize_basic_authenticator()) {\n\t\treturn 0;\n\t}\n\n\tif (wsmand_options_get_digest_password_file()) {\n\t\tmessage(\"Using Digest Authorization\");\n\t}\n\tif (basic_callback) {\n\t\tmessage(\"Using Basic Authorization %s\",\n\t\t\twsmand_option_get_basic_authenticator()?\n\t\t\twsmand_option_get_basic_authenticator() :\n\t\t\twsmand_default_basic_authenticator());\n\t}\n\n\tif ((wsmand_options_get_digest_password_file() == NULL) &&\n\t\t    (basic_callback == NULL)) {\n\t\terror(\"Server does not work without authentication\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic int get_server_port(void) {\n\tint port = 0;\n\tint use_ssl = wsmand_options_get_use_ssl();\n\tif (use_ssl) {\n\t\tmessage(\"Using SSL\");\n\t\tif (wsmand_options_get_ssl_cert_file() &&\n\t\t    wsmand_options_get_ssl_key_file() &&\n\t\t    (wsmand_options_get_server_ssl_port() > 0)) {\n\t\t\tport = wsmand_options_get_server_ssl_port();\n\t\t} else {\n\t\t\terror(\"Not enough data to use SSL port\");\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tport = wsmand_options_get_server_port();\n\t}\n\treturn port;\n}\n\n\nstatic int wsman_setup_thread(pthread_attr_t *pattrs) {\n\tint r;\n\tint ret = 0;\n\tif ((r = pthread_cond_init(&shttpd_cond, NULL)) != 0) {\n\t\tdebug(\"pthread_cond_init failed = %d\", r);\n\t\treturn ret;\n\t}\n\tif ((r = pthread_mutex_init(&shttpd_mutex, NULL)) != 0) {\n\t\tdebug(\"pthread_mutex_init failed = %d\", r);\n\t\treturn ret;\n\t}\n\n\tif ((r = pthread_attr_init(pattrs)) != 0) {\n\t\tdebug(\"pthread_attr_init failed = %d\", r);\n\t\treturn ret;\n\t}\n\n\tif ((r = pthread_attr_setdetachstate(pattrs, PTHREAD_CREATE_DETACHED)) != 0) {\n\t\tdebug(\"pthread_attr_setdetachstate = %d\", r);\n\t\treturn ret;\n\t}\n\treturn 1;\n        size_t thread_stack_size = wsmand_options_get_thread_stack_size();\n        if(thread_stack_size){\n                if(( r = pthread_attr_setstacksize(pattrs, thread_stack_size)) !=0) {\n                        debug(\"pthread_attr_setstacksize failed = %d\", r);\n                        return ret;\n                }\n        }\n}\n\n\nWsManListenerH *wsmand_start_server(dictionary * ini)\n{\n\tint lsn, port, sock;\n\tstruct thread       *thread;\n\tpthread_t tid;\n#ifdef ENABLE_EVENTING_SUPPORT\n\tpthread_t notificationManager_id;\n#endif\n\tpthread_attr_t pattrs;\n\tint use_ssl = wsmand_options_get_use_ssl();\n\tstruct shttpd_ctx   *httpd_ctx;\n\n\tWsManListenerH *listener = wsman_dispatch_list_new();\n\tlistener->config = ini;\n\tWsContextH cntx = wsman_init_plugins(listener);\n        int num_threads = 0;\n        int max_threads = wsmand_options_get_max_threads();\n        int max_connections_per_thread = wsmand_options_get_max_connections_per_thread();\n        if (max_threads && !max_connections_per_thread) {\n                error(\"max_threads: %d and max_connections_per_thread : %d\", max_threads, max_connections_per_thread);\n                return listener;\n        }\n\n\tif (cntx == NULL) {\n\t\treturn listener;\n\t}\n#ifdef ENABLE_EVENTING_SUPPORT\n\twsman_event_init(cntx->soap);\n#endif\n\n#ifndef HAVE_SSL\n\tif (use_ssl) {\n\t\terror(\"Server configured without SSL support\");\n\t\treturn listener;\n\t}\n#endif\n\tSoapH soap = ws_context_get_runtime(cntx);\n\tws_set_context_enumIdleTimeout(cntx,wsmand_options_get_enumIdleTimeout());\n\n\n\tif ((port = get_server_port()) == 0  )\n\t\treturn listener;\n#ifdef ENABLE_IPV6\n\tif (wsmand_options_get_use_ipv6()) {\n\t\tmessage(\"     Working on IPv6 port %d\", port);\n\t}\n\telse {\n#endif\n\t\tmessage(\"     Working on IPv4 port %d\", port);\n#ifdef ENABLE_IPV6\n\t}\n#endif\n\tif (!get_server_auth())\n\t\treturn listener;\n\n\twsmand_shutdown_add_handler(listener_shutdown_handler,\n\t\t\t\t    &continue_working);\n\n\thttpd_ctx = create_shttpd_context(soap, port);\n\n\tif (wsman_setup_thread(&pattrs) == 0 )\n\t\treturn listener;\n\tpthread_create(&tid, &pattrs, wsman_server_auxiliary_loop_thread, cntx);\n\n#ifdef ENABLE_EVENTING_SUPPORT\n\tpthread_create(&notificationManager_id, &pattrs, wsman_notification_manager, cntx);\n#endif\n\n\twhile (continue_working) {\n\t\tshttpd_poll(httpd_ctx, 1000);\n\t}\n\treturn listener;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-openwsman-2.6.11-urnjctbu3pjxgiqzjtqviczvlqse3qms/spack-src/src/server/shttpd/compat_win32.h": "/*\n * Copyright (c) 2004-2007 Sergey Lyubka <valenok@gmail.com>\n * All rights reserved\n *\n * \"THE BEER-WARE LICENSE\" (Revision 42):\n * Sergey Lyubka wrote this file.  As long as you retain this notice you\n * can do whatever you want with this stuff. If we meet some day, and you think\n * this stuff is worth it, you can buy me a beer in return.\n */\n\n/* Tip from Justin Maximilian, suppress errors from winsock2.h */\n#define _WINSOCKAPI_\n\n#include <windows.h>\n#include <winsock2.h>\n#include <commctrl.h>\n#include <winnls.h>\n#include <shlobj.h>\n#include <shellapi.h>\n\n#ifndef _WIN32_WCE\n\n#include <process.h>\n#include <direct.h>\n#include <io.h>\n\n#else /* _WIN32_WCE */\n\n/* Windows CE-specific definitions */\n#define NO_CGI\t/* WinCE has no pipes */\n#define NO_GUI\t/* temporarily until it is fixed */\n#pragma comment(lib,\"ws2\")\n/* WinCE has both Unicode and ANSI versions of GetProcAddress */\n#undef GetProcAddress\n#define GetProcAddress GetProcAddressA\n#include \"compat_wince.h\"\n\n#endif /* _WIN32_WCE */\n\n#define\tERRNO\t\t\tGetLastError()\n#define\tNO_SOCKLEN_T\n#define\tSSL_LIB\t\t\tL\"ssleay32.dll\"\n#define\tDIRSEP\t\t\t'\\\\'\n#define\tIS_DIRSEP_CHAR(c)\t((c) == '/' || (c) == '\\\\')\n#define\tO_NONBLOCK\t\t0\n#define\tEWOULDBLOCK\t\tWSAEWOULDBLOCK\n#define\tsnprintf\t\t_snprintf\n#define\tvsnprintf\t\t_vsnprintf\n#define\tmkdir(x,y)\t\t_mkdir(x)\n#define\tpopen(x,y)\t\t_popen(x, y)\n#define\tpclose(x)\t\t_pclose(x)\n#define\tdlopen(x,y)\t\tLoadLibraryW(x)\n#define\tdlsym(x,y)\t\t(void *) GetProcAddress(x,y)\n#define\t_POSIX_\n\n#ifdef __LCC__\n#include <stdint.h>\n#endif /* __LCC__ */\n\n#ifdef _MSC_VER /* MinGW already has these */\ntypedef unsigned int\t\tuint32_t;\ntypedef unsigned short\t\tuint16_t;\ntypedef __int64\t\t\tuint64_t;\n#define S_ISDIR(x)\t\t((x) & _S_IFDIR)\n#endif /* _MSC_VER */\n\n/*\n * POSIX dirent interface\n */\nstruct dirent {\n\tchar\td_name[FILENAME_MAX];\n};\n\ntypedef struct DIR {\n\tHANDLE\t\t\thandle;\n\tWIN32_FIND_DATAW\tinfo;\n\tstruct dirent\t\tresult;\n\tchar\t\t\t*name;\n} DIR;\n\nextern DIR *opendir(const char *name);\nextern int closedir(DIR *dir);\nextern struct dirent *readdir(DIR *dir);\n",
        "/tmp/vanessa/spack-stage/spack-stage-openwsman-2.6.11-urnjctbu3pjxgiqzjtqviczvlqse3qms/spack-src/src/server/shttpd/shttpd.c": "/*\n * Copyright (c) 2004-2005 Sergey Lyubka <valenok@gmail.com>\n * All rights reserved\n *\n * \"THE BEER-WARE LICENSE\" (Revision 42):\n * Sergey Lyubka wrote this file.  As long as you retain this notice you\n * can do whatever you want with this stuff. If we meet some day, and you think\n * this stuff is worth it, you can buy me a beer in return.\n */\n\n/*\n * Small and portable HTTP server, http://shttpd.sourceforge.net\n * $Id: shttpd.c,v 1.57 2008/08/23 21:00:38 drozd Exp $\n */\n\n#include \"defs.h\"\n#include \"wsmand-daemon.h\"\n\ntime_t\t_shttpd_current_time;\t/* Current UTC time\t\t*/\nint\t_shttpd_tz_offset;\t/* Time zone offset from UTC\t*/\nint\t_shttpd_exit_flag;\t/* Program exit flag\t\t*/\n\nconst struct vec _shttpd_known_http_methods[] = {\n\t{\"POST\",\t4},\n\t{NULL,\t\t0}\n};\n\n/*\n * This structure tells how HTTP headers must be parsed.\n * Used by parse_headers() function.\n */\n#define\tOFFSET(x)\toffsetof(struct headers, x)\nstatic const struct http_header http_headers[] = {\n\t{16, HDR_INT,\t OFFSET(cl),\t\t\"Content-Length: \"\t},\n\t{14, HDR_STRING, OFFSET(ct),\t\t\"Content-Type: \"\t},\n\t{12, HDR_STRING, OFFSET(useragent),\t\"User-Agent: \"\t\t},\n\t{19, HDR_DATE,\t OFFSET(ims),\t\t\"If-Modified-Since: \"\t},\n\t{15, HDR_STRING, OFFSET(auth),\t\t\"Authorization: \"\t},\n\t{9,  HDR_STRING, OFFSET(referer),\t\"Referer: \"\t\t},\n\t{8,  HDR_STRING, OFFSET(cookie),\t\"Cookie: \"\t\t},\n\t{10, HDR_STRING, OFFSET(location),\t\"Location: \"\t\t},\n\t{8,  HDR_INT,\t OFFSET(status),\t\"Status: \"\t\t},\n\t{7,  HDR_STRING, OFFSET(range),\t\t\"Range: \"\t\t},\n\t{12, HDR_STRING, OFFSET(connection),\t\"Connection: \"\t\t},\n\t{19, HDR_STRING, OFFSET(transenc),\t\"Transfer-Encoding: \"\t},\n\t{0,  HDR_INT,\t 0,\t\t\tNULL\t\t\t}\n};\n\nstruct shttpd_ctx *init_ctx(const char *config_file, int argc, char *argv[]);\nstatic void process_connection(struct conn *, int, int);\n\nint\n_shttpd_is_true(const char *str)\n{\n\tstatic const char\t*trues[] = {\"1\", \"yes\", \"true\", \"jawohl\", NULL};\n\tconst char\t\t**p;\n\n\tfor (p = trues; *p != NULL; p++)\n\t\tif (str && !strcmp(str, *p))\n\t\t\treturn (TRUE);\n\n\treturn (FALSE);\n}\n\nstatic void\nfree_list(struct llhead *head, void (*dtor)(struct llhead *))\n{\n\tstruct llhead\t*lp, *tmp;\n\n\tLL_FOREACH_SAFE(head, lp, tmp) {\n\t\tLL_DEL(lp);\n\t\tdtor(lp);\n\t}\n}\n\nstatic void\nlistener_destructor(struct llhead *lp)\n{\n\tstruct listener\t*listener = LL_ENTRY(lp, struct listener, link);\n\n\t(void) closesocket(listener->sock);\n\tfree(listener);\n}\n\nstatic void\nregistered_uri_destructor(struct llhead *lp)\n{\n\tstruct registered_uri *ruri = LL_ENTRY(lp, struct registered_uri, link);\n\n\tfree((void *) ruri->uri);\n\tfree(ruri);\n}\n\nstatic void\nacl_destructor(struct llhead *lp)\n{\n\tstruct acl\t*acl = LL_ENTRY(lp, struct acl, link);\n\tfree(acl);\n}\n\nint\n_shttpd_url_decode(const char *src, int src_len, char *dst, int dst_len)\n{\n\tint\ti, j, a, b;\n#define\tHEXTOI(x)  (isdigit(x) ? x - '0' : x - 'W')\n\n\tfor (i = j = 0; i < src_len && j < dst_len - 1; i++, j++)\n\t\tswitch (src[i]) {\n\t\tcase '%':\n\t\t\tif (isxdigit(((unsigned char *) src)[i + 1]) &&\n\t\t\t    isxdigit(((unsigned char *) src)[i + 2])) {\n\t\t\t\ta = tolower(((unsigned char *)src)[i + 1]);\n\t\t\t\tb = tolower(((unsigned char *)src)[i + 2]);\n\t\t\t\tdst[j] = (HEXTOI(a) << 4) | HEXTOI(b);\n\t\t\t\ti += 2;\n\t\t\t} else {\n\t\t\t\tdst[j] = '%';\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdst[j] = src[i];\n\t\t\tbreak;\n\t\t}\n\n\tdst[j] = '\\0';\t/* Null-terminate the destination */\n\n\treturn (j);\n}\n\nstatic const char *\nis_alias(struct shttpd_ctx *ctx, const char *uri,\n\t\tstruct vec *a_uri, struct vec *a_path)\n{\n\tconst char\t*p, *s = ctx->options[OPT_ALIASES];\n\tsize_t\t\tlen;\n\n\tDBG((\"is_alias: aliases [%s]\", s == NULL ? \"\" : s));\n\n\tFOR_EACH_WORD_IN_LIST(s, len) {\n\n\t\tif ((p = memchr(s, '=', len)) == NULL || p >= s + len || p == s)\n\t\t\tcontinue;\n\n\t\tif (memcmp(uri, s, p - s) == 0) {\n\t\t\ta_uri->ptr = s;\n\t\t\ta_uri->len = p - s;\n\t\t\ta_path->ptr = ++p;\n\t\t\ta_path->len = (s + len) - p;\n\t\t\treturn (s);\n\t\t}\n\t}\n\n\treturn (NULL);\n}\n\nvoid\n_shttpd_stop_stream(struct stream *stream)\n{\n\tif (stream->io_class != NULL && stream->io_class->close != NULL)\n\t\tstream->io_class->close(stream);\n\n\tstream->io_class= NULL;\n\tstream->flags |= FLAG_CLOSED;\n\tstream->flags &= ~(FLAG_R | FLAG_W | FLAG_ALWAYS_READY);\n\n\tDBG((\"%d %s stopped. %lu of content data, %d now in a buffer\",\n\t    stream->conn->rem.chan.sock,\n\t    stream->io_class ? stream->io_class->name : \"(null)\",\n\t    (unsigned long) stream->io.total, (int) io_data_len(&stream->io)));\n}\n\n/*\n * Setup listening socket on given port, return socket\n */\nstatic int\nshttpd_open_listening_port(int port)\n{\n\tint\t\tsock, on = 1;\n\tstruct usa\tsa;\n\n#ifdef _WIN32\n\t{WSADATA data;\tWSAStartup(MAKEWORD(2,2), &data);}\n#endif /* _WIN32 */\n\n\tsa.len\t\t\t\t= sizeof(sa.u.sin);\n\tsa.u.sin.sin_family\t\t= AF_INET;\n\tsa.u.sin.sin_port\t\t= htons((uint16_t) port);\n\tsa.u.sin.sin_addr.s_addr\t= htonl(INADDR_ANY);\n\n\tif ((sock = socket(PF_INET, SOCK_STREAM, 6)) == -1)\n\t\tgoto fail;\n\tif (_shttpd_set_non_blocking_mode(sock) != 0)\n\t\tgoto fail;\n\tif (setsockopt(sock, SOL_SOCKET,\n\t    SO_REUSEADDR,(char *) &on, sizeof(on)) != 0)\n\t\tgoto fail;\n\tif (bind(sock, &sa.u.sa, sa.len) < 0)\n\t\tgoto fail;\n\tif (listen(sock, 128) != 0)\n\t\tgoto fail;\n\n#ifndef _WIN32\n\t(void) fcntl(sock, F_SETFD, FD_CLOEXEC);\n#endif /* !_WIN32 */\n\n\treturn (sock);\nfail:\n\tif (sock != -1)\n\t\t(void) closesocket(sock);\n\t_shttpd_elog(E_LOG, NULL, \"open_listening_port(%d): %s\", port, strerror(errno));\n\treturn (-1);\n}\n\n/*\n * Check whether full request is buffered Return headers length, or 0\n */\nint\n_shttpd_get_headers_len(const char *buf, size_t buflen)\n{\n\tconst char\t*s, *e;\n\tint\t\tlen = 0;\n\n\tfor (s = buf, e = s + buflen - 1; len == 0 && s < e; s++)\n\t\t/* Control characters are not allowed but >=128 is. */\n\t\tif (!isprint(* (unsigned char *) s) && *s != '\\r' &&\n\t\t    *s != '\\n' && * (unsigned char *) s < 128)\n\t\t\tlen = -1;\n\t\telse if (s[0] == '\\n' && s[1] == '\\n')\n\t\t\tlen = s - buf + 2;\n\t\telse if (s[0] == '\\n' && &s[1] < e &&\n\t\t    s[1] == '\\r' && s[2] == '\\n')\n\t\t\tlen = s - buf + 3;\n\n\treturn (len);\n}\n\n/*\n * Send error message back to a client.\n */\nvoid\n_shttpd_send_server_error(struct conn *c, int status, const char *reason)\n{\n\tstruct llhead\t\t*lp;\n\tstruct error_handler\t*e;\n\n\tLL_FOREACH(&c->ctx->error_handlers, lp) {\n\t\te = LL_ENTRY(lp, struct error_handler, link);\n\n\t\tif (e->code == status) {\n\t\t\tif (c->loc.io_class != NULL &&\n\t\t\t    c->loc.io_class->close != NULL)\n\t\t\t\tc->loc.io_class->close(&c->loc);\n\t\t\tio_clear(&c->loc.io);\n\t\t\t_shttpd_setup_embedded_stream(c,\n\t\t\t    e->callback, e->callback_data);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tio_clear(&c->loc.io);\n\tc->loc.io.head = _shttpd_snprintf(c->loc.io.buf, c->loc.io.size,\n\t    \"HTTP/1.1 %d %s\\r\\n\"\n\t    \"Content-Type: text/plain\\r\\n\"\n\t    \"Content-Length: 12\\r\\n\"\n\t    \"\\r\\n\"\n\t    \"Error: %03d\\r\\n\",\n\t    status, reason, status);\n\tc->loc.content_len = 10;\n\tc->status = status;\n\t_shttpd_stop_stream(&c->loc);\n}\n\n/*\n * Convert month to the month number. Return -1 on error, or month number\n */\nstatic int\nmontoi(const char *s)\n{\n\tstatic const char *ar[] = {\n\t\t\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n\t\t\"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"\n\t};\n\tsize_t\ti;\n\n\tfor (i = 0; i < sizeof(ar) / sizeof(ar[0]); i++)\n\t\tif (!strcmp(s, ar[i]))\n\t\t\treturn (i);\n\n\treturn (-1);\n}\n\n/*\n * Parse date-time string, and return the corresponding time_t value\n */\nstatic time_t\ndate_to_epoch(const char *s)\n{\n\tstruct tm\ttm, *tmp;\n\tchar\t\tmon[32];\n\tint\t\tsec, min, hour, mday, month, year;\n\n\t(void) memset(&tm, 0, sizeof(tm));\n\tsec = min = hour = mday = month = year = 0;\n\n\tif (((sscanf(s, \"%d/%3s/%d %d:%d:%d\",\n\t    &mday, mon, &year, &hour, &min, &sec) == 6) ||\n\t    (sscanf(s, \"%d %3s %d %d:%d:%d\",\n\t    &mday, mon, &year, &hour, &min, &sec) == 6) ||\n\t    (sscanf(s, \"%*3s, %d %3s %d %d:%d:%d\",\n\t    &mday, mon, &year, &hour, &min, &sec) == 6) ||\n\t    (sscanf(s, \"%d-%3s-%d %d:%d:%d\",\n\t    &mday, mon, &year, &hour, &min, &sec) == 6)) &&\n\t    (month = montoi(mon)) != -1) {\n\t\ttm.tm_mday\t= mday;\n\t\ttm.tm_mon\t= month;\n\t\ttm.tm_year\t= year;\n\t\ttm.tm_hour\t= hour;\n\t\ttm.tm_min\t= min;\n\t\ttm.tm_sec\t= sec;\n\t}\n\n\tif (tm.tm_year > 1900)\n\t\ttm.tm_year -= 1900;\n\telse if (tm.tm_year < 70)\n\t\ttm.tm_year += 100;\n\n\t/* Set Daylight Saving Time field */\n\ttmp = localtime(&_shttpd_current_time);\n\ttm.tm_isdst = tmp->tm_isdst;\n\n\treturn (mktime(&tm));\n}\n\nstatic void\nremove_all_leading_and_double_dots(char *s)\n{\n\tchar\t*p = s;\n\n\twhile (*s != '\\0' && *s == '.') s++;\n\n\twhile (*s != '\\0') {\n\t\t*p++ = *s++;\n\t\tif (s[-1] == '/' || s[-1] == '\\\\')\n\t\t\twhile (*s == '.' || *s == '/' || *s == '\\\\')\n\t\t\t\ts++;\n\t}\n\t*p = '\\0';\n}\n\nvoid\n_shttpd_parse_headers(const char *s, int len, struct headers *parsed)\n{\n\tconst struct http_header\t*h;\n\tunion variant\t\t\t*v;\n\tconst char\t\t\t*p, *e = s + len;\n\n\tDBG((\"parsing headers (len %d): [%.*s]\", len, len, s));\n\n\t/* Loop through all headers in the request */\n\twhile (s < e) {\n\n\t\t/* Find where this header ends */\n\t\tfor (p = s; p < e && *p != '\\n'; ) p++;\n\n\t\t/* Is this header known to us ? */\n\t\tfor (h = http_headers; h->len != 0; h++)\n\t\t\tif (e - s > h->len &&\n\t\t\t    !_shttpd_strncasecmp(s, h->name, h->len))\n\t\t\t\tbreak;\n\n\t\t/* If the header is known to us, store its value */\n\t\tif (h->len != 0) {\n\n\t\t\t/* Shift to where value starts */\n\t\t\ts += h->len;\n\n\t\t\t/* Find place to store the value */\n\t\t\tv = (union variant *) ((char *) parsed + h->offset);\n\n\t\t\t/* Fetch header value into the connection structure */\n\t\t\tif (h->type == HDR_STRING) {\n\t\t\t\tv->v_vec.ptr = s;\n\t\t\t\tv->v_vec.len = p - s;\n\t\t\t\tif (p[-1] == '\\r' && v->v_vec.len > 0)\n\t\t\t\t\tv->v_vec.len--;\n\t\t\t} else if (h->type == HDR_INT) {\n\t\t\t\tv->v_big_int = strtoul(s, NULL, 10);\n\t\t\t} else if (h->type == HDR_DATE) {\n\t\t\t\tv->v_time = date_to_epoch(s);\n\t\t\t}\n\t\t}\n\n\t\ts = p + 1;\t/* Shift to the next header */\n\t}\n}\n\nstatic const struct {\n\tconst char\t*extension;\n\tint\t\text_len;\n\tconst char\t*mime_type;\n} builtin_mime_types[] = {\n\t{\"html\",\t4,\t\"text/html\"\t\t\t},\n\t{\"htm\",\t\t3,\t\"text/html\"\t\t\t},\n\t{\"txt\",\t\t3,\t\"text/plain\"\t\t\t},\n\t{\"css\",\t\t3,\t\"text/css\"\t\t\t},\n\t{\"ico\",\t\t3,\t\"image/x-icon\"\t\t\t},\n\t{\"gif\",\t\t3,\t\"image/gif\"\t\t\t},\n\t{\"jpg\",\t\t3,\t\"image/jpeg\"\t\t\t},\n\t{\"jpeg\",\t4,\t\"image/jpeg\"\t\t\t},\n\t{\"png\",\t\t3,\t\"image/png\"\t\t\t},\n\t{\"svg\",\t\t3,\t\"image/svg+xml\"\t\t\t},\n\t{\"torrent\",\t7,\t\"application/x-bittorrent\"\t},\n\t{\"wav\",\t\t3,\t\"audio/x-wav\"\t\t\t},\n\t{\"mp3\",\t\t3,\t\"audio/x-mp3\"\t\t\t},\n\t{\"mid\",\t\t3,\t\"audio/mid\"\t\t\t},\n\t{\"m3u\",\t\t3,\t\"audio/x-mpegurl\"\t\t},\n\t{\"ram\",\t\t3,\t\"audio/x-pn-realaudio\"\t\t},\n\t{\"ra\",\t\t2,\t\"audio/x-pn-realaudio\"\t\t},\n\t{\"doc\",\t\t3,\t\"application/msword\",\t\t},\n\t{\"exe\",\t\t3,\t\"application/octet-stream\"\t},\n\t{\"zip\",\t\t3,\t\"application/x-zip-compressed\"\t},\n\t{\"xls\",\t\t3,\t\"application/excel\"\t\t},\n\t{\"tgz\",\t\t3,\t\"application/x-tar-gz\"\t\t},\n\t{\"tar.gz\",\t6,\t\"application/x-tar-gz\"\t\t},\n\t{\"tar\",\t\t3,\t\"application/x-tar\"\t\t},\n\t{\"gz\",\t\t2,\t\"application/x-gunzip\"\t\t},\n\t{\"arj\",\t\t3,\t\"application/x-arj-compressed\"\t},\n\t{\"rar\",\t\t3,\t\"application/x-arj-compressed\"\t},\n\t{\"rtf\",\t\t3,\t\"application/rtf\"\t\t},\n\t{\"pdf\",\t\t3,\t\"application/pdf\"\t\t},\n\t{\"swf\",\t\t3,\t\"application/x-shockwave-flash\"\t},\n\t{\"mpg\",\t\t3,\t\"video/mpeg\"\t\t\t},\n\t{\"mpeg\",\t4,\t\"video/mpeg\"\t\t\t},\n\t{\"asf\",\t\t3,\t\"video/x-ms-asf\"\t\t},\n\t{\"avi\",\t\t3,\t\"video/x-msvideo\"\t\t},\n\t{\"bmp\",\t\t3,\t\"image/bmp\"\t\t\t},\n\t{NULL,\t\t0,\tNULL\t\t\t\t}\n};\n\nvoid\n_shttpd_get_mime_type(struct shttpd_ctx *ctx,\n\t\tconst char *uri, int len, struct vec *vec)\n{\n\tconst char\t*eq, *p = ctx->options[OPT_MIME_TYPES];\n\tint\t\ti, n, ext_len;\n\n\t/* Firt, loop through the custom mime types if any */\n\tFOR_EACH_WORD_IN_LIST(p, n) {\n\t\tif ((eq = memchr(p, '=', n)) == NULL || eq >= p + n || eq == p)\n\t\t\tcontinue;\n\t\text_len = eq - p;\n\t\tif (len > ext_len && uri[len - ext_len - 1] == '.' &&\n\t\t    !_shttpd_strncasecmp(p, &uri[len - ext_len], ext_len)) {\n\t\t\tvec->ptr = eq + 1;\n\t\t\tvec->len = p + n - vec->ptr;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* If no luck, try built-in mime types */\n\tfor (i = 0; builtin_mime_types[i].extension != NULL; i++) {\n\t\text_len = builtin_mime_types[i].ext_len;\n\t\tif (len > ext_len && uri[len - ext_len - 1] == '.' &&\n\t\t    !_shttpd_strncasecmp(builtin_mime_types[i].extension,\n\t\t\t    &uri[len - ext_len], ext_len)) {\n\t\t\tvec->ptr = builtin_mime_types[i].mime_type;\n\t\t\tvec->len = strlen(vec->ptr);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Oops. This extension is unknown to us. Fallback to text/plain */\n\tvec->ptr = \"text/plain\";\n\tvec->len = strlen(vec->ptr);\n}\n\n/*\n * For given directory path, substitute it to valid index file.\n * Return 0 if index file has been found, -1 if not found\n */\nstatic int\nfind_index_file(struct conn *c, char *path, size_t maxpath, struct stat *stp)\n{\n\tchar\t\tbuf[FILENAME_MAX];\n\tconst char\t*s = c->ctx->options[OPT_INDEX_FILES];\n\tsize_t\t\tlen;\n\n\tFOR_EACH_WORD_IN_LIST(s, len) {\n\t\t/* path must end with '/' character */\n\t\t_shttpd_snprintf(buf, sizeof(buf), \"%s%.*s\", path, len, s);\n\t\tif (_shttpd_stat(buf, stp) == 0) {\n\t\t\t_shttpd_strlcpy(path, buf, maxpath);\n\t\t\t_shttpd_get_mime_type(c->ctx, s, len, &c->mime_type);\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\treturn (-1);\n}\n\n/*\n * Try to open requested file, return 0 if OK, -1 if error.\n * If the file is given arguments using PATH_INFO mechanism,\n * initialize pathinfo pointer.\n */\nstatic int\nget_path_info(struct conn *c, char *path, struct stat *stp)\n{\n\tchar\t*p, *e;\n\n\tif (_shttpd_stat(path, stp) == 0)\n\t\treturn (0);\n\n\tp = path + strlen(path);\n\te = path + strlen(c->ctx->options[OPT_ROOT]) + 2;\n\n\t/* Strip directory parts of the path one by one */\n\tfor (; p > e; p--)\n\t\tif (*p == '/') {\n\t\t\t*p = '\\0';\n\t\t\tif (!_shttpd_stat(path, stp) && !S_ISDIR(stp->st_mode)) {\n\t\t\t\tc->path_info = p + 1;\n\t\t\t\treturn (0);\n\t\t\t} else {\n\t\t\t\t*p = '/';\n\t\t\t}\n\t\t}\n\n\treturn (-1);\n}\n\nstatic void\ndecide_what_to_do(struct conn *c)\n{\n\tchar\t\tpath[URI_MAX], buf[1024], *root;\n\tstruct vec\talias_uri, alias_path;\n\tstruct stat\tst;\n\tint\t\trc;\n\tstruct registered_uri\t*ruri;\n\n\tDBG((\"decide_what_to_do: [%s]\", c->uri));\n\n\tif ((c->query = strchr(c->uri, '?')) != NULL)\n\t\t*c->query++ = '\\0';\n\n\t_shttpd_url_decode(c->uri, strlen(c->uri), c->uri, strlen(c->uri) + 1);\n\tremove_all_leading_and_double_dots(c->uri);\n\n\troot = c->ctx->options[OPT_ROOT];\n\tif (strlen(c->uri) + strlen(root) >= sizeof(path)) {\n\t\t_shttpd_send_server_error(c, 400, \"URI is too long\");\n\t\treturn;\n\t}\n\n\t(void) _shttpd_snprintf(path, sizeof(path), \"%s%s\", root, c->uri);\n\n\tDBG((\"decide_what_to_do -> processed path: [%s]\", path));\n\t/* User may use the aliases - check URI for mount point */\n\tif (is_alias(c->ctx, c->uri, &alias_uri, &alias_path) != NULL) {\n\t\t(void) _shttpd_snprintf(path, sizeof(path), \"%.*s%s\",\n\t\t    alias_path.len, alias_path.ptr, c->uri + alias_uri.len);\n\t\tDBG((\"using alias %.*s -> %.*s\", alias_uri.len, alias_uri.ptr,\n\t\t    alias_path.len, alias_path.ptr));\n\t}\n\n#if !defined(NO_AUTH)\n\tif (_shttpd_check_authorization(c, path) != 1) {\n\t\t_shttpd_send_authorization_request(c);\n\t} else\n#endif /* NO_AUTH */\n\tif ((ruri = _shttpd_is_registered_uri(c->ctx, c->uri)) != NULL) {\n\t\t_shttpd_setup_embedded_stream(c,\n\t\t    ruri->callback, ruri->callback_data);\n\t} else {\n\t\t_shttpd_send_server_error(c, 403, \"Forbidden\");\n\t}\n#if 0\n\tif (strstr(path, HTPASSWD)) {\n\t\t/* Do not allow to view passwords files */\n\t\t_shttpd_send_server_error(c, 403, \"Forbidden\");\n\t} else\n#if !defined(NO_AUTH)\n\tif ((c->method == METHOD_PUT || c->method == METHOD_DELETE) &&\n\t    (c->ctx->options[OPT_AUTH_PUT] == NULL ||\n\t     !_shttpd_is_authorized_for_put(c))) {\n\t\t_shttpd_send_authorization_request(c);\n\t} else\n#endif /* NO_AUTH */\n\tif (c->method == METHOD_PUT) {\n\t\tc->status = _shttpd_stat(path, &st) == 0 ? 200 : 201;\n\n\t\tif (c->ch.range.v_vec.len > 0) {\n\t\t\t_shttpd_send_server_error(c, 501,\n\t\t\t    \"PUT Range Not Implemented\");\n\t\t} else if ((rc = _shttpd_put_dir(path)) == 0) {\n\t\t\t_shttpd_send_server_error(c, 200, \"OK\");\n\t\t} else if (rc == -1) {\n\t\t\t_shttpd_send_server_error(c, 500, \"PUT Directory Error\");\n\t\t} else if (c->rem.content_len == 0) {\n\t\t\t_shttpd_send_server_error(c, 411, \"Length Required\");\n\t\t} else if ((c->loc.chan.fd = _shttpd_open(path, O_WRONLY | O_BINARY |\n\t\t    O_CREAT | O_NONBLOCK | O_TRUNC, 0644)) == -1) {\n\t\t\t_shttpd_send_server_error(c, 500, \"PUT Error\");\n\t\t} else {\n\t\t\tDBG((\"PUT file [%s]\", c->uri));\n\t\t\tc->loc.io_class = &_shttpd_io_file;\n\t\t\tc->loc.flags |= FLAG_W | FLAG_ALWAYS_READY ;\n\t\t}\n\t} else if (c->method == METHOD_DELETE) {\n\t\tDBG((\"DELETE [%s]\", c->uri));\n\t\tif (_shttpd_remove(path) == 0)\n\t\t\t_shttpd_send_server_error(c, 200, \"OK\");\n\t\telse\n\t\t\t_shttpd_send_server_error(c, 500, \"DELETE Error\");\n\t} else if (get_path_info(c, path, &st) != 0) {\n\t\t_shttpd_send_server_error(c, 404, \"Not Found\");\n\t} else if (S_ISDIR(st.st_mode) && path[strlen(path) - 1] != '/') {\n\t\t(void) _shttpd_snprintf(buf, sizeof(buf),\n\t\t\t\"Moved Permanently\\r\\nLocation: %s/\", c->uri);\n\t\t_shttpd_send_server_error(c, 301, buf);\n\t} else if (S_ISDIR(st.st_mode) &&\n\t    find_index_file(c, path, sizeof(path) - 1, &st) == -1 &&\n\t    !IS_TRUE(c->ctx, OPT_DIR_LIST)) {\n\t\t_shttpd_send_server_error(c, 403, \"Directory Listing Denied\");\n\t} else if (S_ISDIR(st.st_mode) && IS_TRUE(c->ctx, OPT_DIR_LIST)) {\n\t\tif ((c->loc.chan.dir.path = _shttpd_strdup(path)) != NULL)\n\t\t\t_shttpd_get_dir(c);\n\t\telse\n\t\t\t_shttpd_send_server_error(c, 500, \"GET Directory Error\");\n\t} else if (S_ISDIR(st.st_mode) && !IS_TRUE(c->ctx, OPT_DIR_LIST)) {\n\t\t_shttpd_send_server_error(c, 403, \"Directory listing denied\");\n#if !defined(NO_CGI)\n\t} else if (_shttpd_match_extension(path,\n\t    c->ctx->options[OPT_CGI_EXTENSIONS])) {\n\t\tif (c->method != METHOD_POST && c->method != METHOD_GET) {\n\t\t\t_shttpd_send_server_error(c, 501, \"Bad method \");\n\t\t} else if ((_shttpd_run_cgi(c, path)) == -1) {\n\t\t\t_shttpd_send_server_error(c, 500, \"Cannot exec CGI\");\n\t\t} else {\n\t\t\t_shttpd_do_cgi(c);\n\t\t}\n#endif /* NO_CGI */\n#if !defined(NO_SSI)\n\t} else if (_shttpd_match_extension(path,\n\t    c->ctx->options[OPT_SSI_EXTENSIONS])) {\n\t\tif ((c->loc.chan.fd = _shttpd_open(path,\n\t\t    O_RDONLY | O_BINARY, 0644)) == -1) {\n\t\t\t_shttpd_send_server_error(c, 500, \"SSI open error\");\n\t\t} else {\n\t\t\t_shttpd_do_ssi(c);\n\t\t}\n#endif /* NO_CGI */\n\t} else if (c->ch.ims.v_time && st.st_mtime <= c->ch.ims.v_time) {\n\t\t_shttpd_send_server_error(c, 304, \"Not Modified\");\n\t} else if ((c->loc.chan.fd = _shttpd_open(path,\n\t    O_RDONLY | O_BINARY, 0644)) != -1) {\n\t\t_shttpd_get_file(c, &st);\n\t} else {\n\t\t_shttpd_send_server_error(c, 500, \"Internal Error\");\n\t}\n#endif //0\n  return;\n}\n\nstatic int\nset_request_method(struct conn *c)\n{\n\tconst struct vec\t*v;\n\n\t/* Set the request method */\n\tfor (v = _shttpd_known_http_methods; v->ptr != NULL; v++)\n\t\tif (!memcmp(c->rem.io.buf, v->ptr, v->len)) {\n\t\t\tc->method = v - _shttpd_known_http_methods;\n\t\t\tbreak;\n\t\t}\n\n\treturn (v->ptr == NULL);\n}\n\nstatic void\nparse_http_request(struct conn *c)\n{\n\tchar\t*s, *e, *p, *start;\n\tint\turi_len, req_len, n;\n\n\ts = io_data(&c->rem.io);;\n\treq_len = c->rem.headers_len =\n\t    _shttpd_get_headers_len(s, io_data_len(&c->rem.io));\n\n\tif (req_len == 0 && io_space_len(&c->rem.io) == 0) {\n\t\tio_clear(&c->rem.io);\n\t\t_shttpd_send_server_error(c, 400, \"Request is too big\");\n\t}\n\n\tif (req_len == 0) {\n\t\treturn;\n\t} else if (req_len < 16) {\t/* Minimal: \"GET / HTTP/1.0\\n\\n\" */\n\t\t_shttpd_send_server_error(c, 400, \"Bad request\");\n\t} else if (set_request_method(c)) {\n\t\t_shttpd_send_server_error(c, 501, \"Method Not Implemented\");\n\t} else if ((c->request = _shttpd_strndup(s, req_len)) == NULL) {\n\t\t_shttpd_send_server_error(c, 500, \"Cannot allocate request\");\n\t}\n\n\tio_inc_tail(&c->rem.io, req_len);\n\n\tif (c->loc.flags & FLAG_CLOSED)\n\t\treturn;\n\n\tDBG((\"Conn %d: parsing request: [%.*s]\", c->rem.chan.sock, req_len, s));\n\tc->rem.flags |= FLAG_HEADERS_PARSED;\n\n\t/* Set headers pointer. Headers follow the request line */\n\tc->headers = memchr(c->request, '\\n', req_len);\n\tassert(c->headers != NULL);\n\tassert(c->headers < c->request + req_len);\n\tif (c->headers > c->request && c->headers[-1] == '\\r')\n\t\tc->headers[-1] = '\\0';\n\t*c->headers++ = '\\0';\n\n\t/*\n\t * Now make a copy of the URI, because it will be URL-decoded,\n\t * and we need a copy of unmodified URI for the access log.\n\t * First, we skip the REQUEST_METHOD and shift to the URI.\n\t */\n\tfor (p = c->request, e = p + req_len; *p != ' ' && p < e; p++);\n\twhile (p < e && *p == ' ')\n\t\tp++;\n\n\t/* Now remember where URI starts, and shift to the end of URI */\n\tfor (start = p; p < e && !isspace((unsigned char)*p); ) p++;\n\turi_len = p - start;\n\n\t/* Skip space following the URI */\n\twhile (p < e && *p == ' ')\n\t\tp++;\n\n\t/* Now comes the HTTP-Version in the form HTTP/<major>.<minor> */\n\tif (sscanf(p, \"HTTP/%lu.%lu%n\",\n\t    &c->major_version, &c->minor_version, &n) != 2 || p[n] != '\\0') {\n\t\t_shttpd_send_server_error(c, 400, \"Bad HTTP version\");\n\t} else if (c->major_version > 1 ||\n\t    (c->major_version == 1 && c->minor_version > 1)) {\n\t\t_shttpd_send_server_error(c, 505, \"HTTP version not supported\");\n\t} else if (uri_len <= 0) {\n\t\t_shttpd_send_server_error(c, 400, \"Bad URI\");\n\t} else if ((c->uri = malloc(uri_len + 1)) == NULL) {\n\t\t_shttpd_send_server_error(c, 500, \"Cannot allocate URI\");\n\t} else {\n\t\t_shttpd_strlcpy(c->uri, (char *) start, uri_len + 1);\n\t\t_shttpd_parse_headers(c->headers,\n\t\t    (c->request + req_len) - c->headers, &c->ch);\n\n\t\t/* Remove the length of request from total, count only data */\n\t\tassert(c->rem.io.total >= (big_int_t) req_len);\n\t\tc->rem.io.total -= req_len;\n\t\tc->rem.content_len = c->ch.cl.v_big_int;\n\t\tdecide_what_to_do(c);\n\t}\n}\n\nstatic void\nadd_socket(struct worker *worker, int sock, int is_ssl)\n{\n\tstruct shttpd_ctx\t*ctx = worker->ctx;\n\tstruct conn\t\t*c;\n\tstruct usa\t\tsa;\n\tint\t\t\tl = IS_TRUE(ctx, OPT_INETD) ? E_FATAL : E_LOG;\n#if !defined(NO_SSL)\n\tSSL\t\t*ssl = NULL;\n#else\n\tis_ssl = is_ssl;\t/* supress warnings */\n#endif /* NO_SSL */\n\n\tsa.len = sizeof(sa.u.sin);\n\t(void) _shttpd_set_non_blocking_mode(sock);\n\n\tif (getpeername(sock, &sa.u.sa, &sa.len)) {\n\t\t_shttpd_elog(l, NULL, \"add_socket: %s\", strerror(errno));\n#if !defined(NO_SSL)\n\t} else if (is_ssl && (ssl = SSL_new(ctx->ssl_ctx)) == NULL) {\n\t\t_shttpd_elog(l, NULL, \"add_socket: SSL_new: %s\", strerror(ERRNO));\n\t\t(void) closesocket(sock);\n\t} else if (is_ssl && SSL_set_fd(ssl, sock) == 0) {\n\t\t_shttpd_elog(l, NULL, \"add_socket: SSL_set_fd: %s\", strerror(ERRNO));\n\t\t(void) closesocket(sock);\n\t\tSSL_free(ssl);\n#endif /* NO_SSL */\n\t} else if ((c = calloc(1, sizeof(*c) + 2 * URI_MAX)) == NULL) {\n#if !defined(NO_SSL)\n\t\tif (ssl)\n\t\t\tSSL_free(ssl);\n#endif /* NO_SSL */\n\t\t(void) closesocket(sock);\n\t\t_shttpd_elog(l, NULL, \"add_socket: calloc: %s\", strerror(ERRNO));\n\t} else {\n\t\tc->rem.conn\t= c->loc.conn = c;\n\t\tc->ctx\t\t= ctx;\n\t\tc->worker\t= worker;\n\t\tc->sa\t\t= sa;\n\t\tc->birth_time\t= _shttpd_current_time;\n\t\tc->expire_time\t= _shttpd_current_time + EXPIRE_TIME;\n\n\t\t(void) getsockname(sock, &sa.u.sa, &sa.len);\n\t\tc->loc_port = sa.u.sin.sin_port;\n\n\t\t_shttpd_set_close_on_exec(sock);\n\n\t\tc->loc.io_class\t= NULL;\n\n\t\tc->rem.io_class\t= &_shttpd_io_socket;\n\t\tc->rem.chan.sock = sock;\n\n\t\t/* Set IO buffers */\n\t\tc->loc.io.buf\t= (char *) (c + 1);\n\t\tc->rem.io.buf\t= c->loc.io.buf + URI_MAX;\n\t\tc->loc.io.size\t= c->rem.io.size = URI_MAX;\n\n#if !defined(NO_SSL)\n\t\tif (is_ssl) {\n\t\t\tc->rem.io_class\t= &_shttpd_io_ssl;\n\t\t\tc->rem.chan.ssl.sock = sock;\n\t\t\tc->rem.chan.ssl.ssl = ssl;\n\t\t\t_shttpd_ssl_handshake(&c->rem);\n\t\t}\n#endif /* NO_SSL */\n\n\t\tLL_TAIL(&worker->connections, &c->link);\n\t\tworker->num_conns++;\n\n\t\tDBG((\"%s:%hu connected (socket %d)\",\n\t\t    inet_ntoa(* (struct in_addr *) &sa.u.sin.sin_addr.s_addr),\n\t\t    ntohs(sa.u.sin.sin_port), sock));\n\t}\n}\n\nstatic struct worker *\nfirst_worker(struct shttpd_ctx *ctx)\n{\n\treturn (LL_ENTRY(ctx->workers.next, struct worker, link));\n}\n\nstatic void\npass_socket(struct shttpd_ctx *ctx, int sock, int is_ssl)\n{\n\tstruct llhead\t*lp;\n\tstruct worker\t*worker, *lazy;\n\tint\t\tbuf[3];\n\n\tlazy = first_worker(ctx);\n\n\t/* Find least busy worker */\n\tLL_FOREACH(&ctx->workers, lp) {\n\t\tworker = LL_ENTRY(lp, struct worker, link);\n\t\tif (worker->num_conns < lazy->num_conns)\n\t\t\tlazy = worker;\n\t}\n\n\tbuf[0] = CTL_PASS_SOCKET;\n\tbuf[1] = sock;\n\tbuf[2] = is_ssl;\n\n\t(void) send(lazy->ctl[1], (void *) buf, sizeof(buf), 0);\n}\n\nstatic int\nset_ports(struct shttpd_ctx *ctx, const char *p)\n{\n\tint\t\tsock, len, is_ssl, port;\n\tstruct listener\t*l;\n\n\n\tfree_list(&ctx->listeners, &listener_destructor);\n\n\tFOR_EACH_WORD_IN_LIST(p, len) {\n\n\t\tis_ssl\t= p[len - 1] == 's' ? 1 : 0;\n\t\tport\t= atoi(p);\n\n\t\tif ((sock = shttpd_open_listening_port(port)) == -1) {\n\t\t\t_shttpd_elog(E_LOG, NULL, \"cannot open port %d\", port);\n\t\t\tgoto fail;\n\t\t} else if (is_ssl && ctx->ssl_ctx == NULL) {\n\t\t\t(void) closesocket(sock);\n\t\t\t_shttpd_elog(E_LOG, NULL, \"cannot add SSL socket, \"\n\t\t\t    \"please specify certificate file\");\n\t\t\tgoto fail;\n\t\t} else if ((l = calloc(1, sizeof(*l))) == NULL) {\n\t\t\t(void) closesocket(sock);\n\t\t\t_shttpd_elog(E_LOG, NULL, \"cannot allocate listener\");\n\t\t\tgoto fail;\n\t\t} else {\n\t\t\tl->is_ssl = is_ssl;\n\t\t\tl->sock\t= sock;\n\t\t\tl->ctx\t= ctx;\n\t\t\tLL_TAIL(&ctx->listeners, &l->link);\n\t\t\tDBG((\"shttpd_listen: added socket %d\", sock));\n\t\t}\n\t}\n\n\treturn (TRUE);\nfail:\n\tfree_list(&ctx->listeners, &listener_destructor);\n\treturn (FALSE);\n}\n\nstatic void\nread_stream(struct stream *stream)\n{\n\tint\tn, len;\n\n\tlen = io_space_len(&stream->io);\n\tassert(len > 0);\n\n\t/* Do not read more that needed */\n\tif (stream->content_len > 0 &&\n\t    stream->io.total + len > stream->content_len)\n\t\tlen = stream->content_len - stream->io.total;\n\n\t/* Read from underlying channel */\n\tassert(stream->io_class != NULL);\n\tn = stream->io_class->read(stream, io_space(&stream->io), len);\n\n\tif (n > 0)\n\t\tio_inc_head(&stream->io, n);\n\telse if (n == -1 && (ERRNO == EINTR || ERRNO == EWOULDBLOCK))\n\t\tn = n;\t/* Ignore EINTR and EAGAIN */\n\telse if (!(stream->flags & FLAG_DONT_CLOSE))\n\t\t_shttpd_stop_stream(stream);\n\n\tDBG((\"read_stream (%d %s): read %d/%d/%lu bytes (errno %d)\",\n\t    stream->conn->rem.chan.sock,\n\t    stream->io_class ? stream->io_class->name : \"(null)\",\n\t    n, len, (unsigned long) stream->io.total, ERRNO));\n\n\t/*\n\t * Close the local stream if everything was read\n\t * XXX We do not close the remote stream though! It may be\n\t * a POST data completed transfer, we do not want the socket\n\t * to be closed.\n\t */\n\tif (stream->content_len > 0 && stream == &stream->conn->loc) {\n\t\tassert(stream->io.total <= stream->content_len);\n\t\tif (stream->io.total == stream->content_len)\n\t\t\t_shttpd_stop_stream(stream);\n\t}\n\n\tstream->conn->expire_time = _shttpd_current_time + EXPIRE_TIME;\n}\n\nstatic void\nwrite_stream(struct stream *from, struct stream *to)\n{\n\tint\tn, len;\n\n\tlen = io_data_len(&from->io);\n\tassert(len > 0);\n\n\t/* TODO: should be assert on CAN_WRITE flag */\n\tn = to->io_class->write(to, io_data(&from->io), len);\n\tto->conn->expire_time = _shttpd_current_time + EXPIRE_TIME;\n\tDBG((\"write_stream (%d %s): written %d/%d bytes (errno %d)\",\n\t    to->conn->rem.chan.sock,\n\t    to->io_class ? to->io_class->name : \"(null)\", n, len, ERRNO));\n\n\tif (n > 0)\n\t\tio_inc_tail(&from->io, n);\n\telse if (n == -1 && (ERRNO == EINTR || ERRNO == EWOULDBLOCK))\n\t\tn = n;\t/* Ignore EINTR and EAGAIN */\n\telse if (!(to->flags & FLAG_DONT_CLOSE))\n\t\t_shttpd_stop_stream(to);\n}\n\n\nstatic int\nconnection_desctructor(struct llhead *lp)\n{\n\tstruct conn\t\t*c = LL_ENTRY(lp, struct conn, link);\n\tstatic const struct vec\tvec = {\"close\", 5};\n\tint\t\t\tdo_close;\n\n\tDBG((\"Disconnecting %d (%.*s)\", c->rem.chan.sock,\n\t    c->ch.connection.v_vec.len, c->ch.connection.v_vec.ptr));\n\n\tif (c->request != NULL && c->ctx->access_log != NULL)\n\t\t_shttpd_log_access(c->ctx->access_log, c);\n\n\t/* In inetd mode, exit if request is finished. */\n\tif (IS_TRUE(c->ctx, OPT_INETD))\n\t\texit(0);\n\n\tif (c->loc.io_class != NULL && c->loc.io_class->close != NULL)\n\t\tc->loc.io_class->close(&c->loc);\n\n\t/*\n\t * Check the \"Connection: \" header before we free c->request\n\t * If it its 'keep-alive', then do not close the connection\n\t */\n\tdo_close = c->rem.flags & FLAG_CLOSED ||\n\t    (c->ch.connection.v_vec.len >= vec.len &&\n\t    !_shttpd_strncasecmp(vec.ptr,c->ch.connection.v_vec.ptr,vec.len)) ||\n\t    (c->major_version < 1 ||\n\t    (c->major_version >= 1 && c->minor_version < 1));\n\n\tif (c->request)\n\t\tfree(c->request);\n\tif (c->uri)\n\t\tfree(c->uri);\n\n\t/* Keep the connection open only if we have Content-Length set */\n\tif (!do_close && c->loc.content_len > 0) {\n\t\tc->loc.io_class = NULL;\n\t\tc->loc.flags = 0;\n\t\tc->loc.content_len = 0;\n\t\tc->rem.flags = FLAG_W | FLAG_R | FLAG_SSL_ACCEPTED;\n\t\tc->query = c->request = c->uri = c->path_info = NULL;\n\t\tc->mime_type.len = 0;\n\t\t(void) memset(&c->ch, 0, sizeof(c->ch));\n\t\tio_clear(&c->loc.io);\n\t\tc->birth_time = _shttpd_current_time;\n\t\tif (io_data_len(&c->rem.io) > 0)\n\t\t\treturn 1;\n\t} else {\n\t\tif (c->rem.io_class != NULL)\n\t\t\tc->rem.io_class->close(&c->rem);\n\n\t\tLL_DEL(&c->link);\n\t\tc->worker->num_conns--;\n\t\tassert(c->worker->num_conns >= 0);\n\n\t\tfree(c);\n\t}\n\n\treturn 0;\n}\n\nstatic void\nworker_destructor(struct llhead *lp)\n{\n\tstruct worker\t*worker = LL_ENTRY(lp, struct worker, link);\n\n\tfree_list(&worker->connections, (void (*)(struct llhead *))connection_desctructor);\n\tfree(worker);\n}\n\nstatic int\nis_allowed(const struct shttpd_ctx *ctx, const struct usa *usa)\n{\n\tconst struct acl\t*acl;\n\tconst struct llhead\t*lp;\n\tint\t\t\tallowed = '+';\n\tuint32_t\t\tip;\n\n\tLL_FOREACH(&ctx->acl, lp) {\n\t\tacl = LL_ENTRY(lp, struct acl, link);\n\t\t(void) memcpy(&ip, &usa->u.sin.sin_addr, sizeof(ip));\n\t\tif (acl->ip == (ntohl(ip) & acl->mask))\n\t\t\tallowed = acl->flag;\n\t}\n\n\treturn (allowed == '+');\n}\n\nstatic void\nadd_to_set(int fd, fd_set *set, int *max_fd)\n{\n\tFD_SET(fd, set);\n\tif (fd > *max_fd)\n\t\t*max_fd = fd;\n}\n\nstatic void\nprocess_connection(struct conn *c, int remote_ready, int local_ready)\n{\nagain:\n\t/* Read from remote end if it is ready */\n\tif (remote_ready && io_space_len(&c->rem.io))\n\t\tread_stream(&c->rem);\n\n\t/* If the request is not parsed yet, do so */\n\tif (!(c->rem.flags & FLAG_HEADERS_PARSED))\n\t\tparse_http_request(c);\n\n\tDBG((\"loc: %d [%.*s]\", (int) io_data_len(&c->loc.io),\n\t    (int) io_data_len(&c->loc.io), io_data(&c->loc.io)));\n\tDBG((\"rem: %d [%.*s]\", (int) io_data_len(&c->rem.io),\n\t    (int) io_data_len(&c->rem.io), io_data(&c->rem.io)));\n\n\t/* Read from the local end if it is ready */\n\tif (local_ready && io_space_len(&c->loc.io))\n\t\tread_stream(&c->loc);\n\n\tif (io_data_len(&c->rem.io) > 0 && (c->loc.flags & FLAG_W) &&\n\t    c->loc.io_class != NULL && c->loc.io_class->write != NULL)\n\t\twrite_stream(&c->rem, &c->loc);\n\n\tif (io_data_len(&c->loc.io) > 0 && c->rem.io_class != NULL)\n\t\twrite_stream(&c->loc, &c->rem);\n\n\t/* Check whether we should close this connection */\n\tif ((_shttpd_current_time > c->expire_time) ||\n\t    (c->rem.flags & FLAG_CLOSED) ||\n\t    ((c->loc.flags & FLAG_CLOSED) && !io_data_len(&c->loc.io)))\n\t\tif (connection_desctructor(&c->link)) {\n\t\t\t// More data to read and process ...\n\t\t\tremote_ready = 0;\n\t\t\tlocal_ready = 0;\n\t\t\tgoto again;\n\t\t}\n}\n\nstatic int\nnum_workers(const struct shttpd_ctx *ctx)\n{\n\tchar\t*p = ctx->options[OPT_THREADS];\n\treturn (p ? atoi(p) : 1);\n}\n\nstatic void\nhandle_connected_socket(struct shttpd_ctx *ctx,\n\t\tstruct usa *sap, int sock, int is_ssl)\n{\n#if !defined(_WIN32)\n\tif (sock >= (int) FD_SETSIZE) {\n\t\t_shttpd_elog(E_LOG, NULL, \"ctx %p: discarding \"\n\t\t    \"socket %d, too busy\", ctx, sock);\n\t\t(void) closesocket(sock);\n\t} else\n#endif /* !_WIN32 */\n\t\tif (!is_allowed(ctx, sap)) {\n\t\t_shttpd_elog(E_LOG, NULL, \"%s is not allowed to connect\",\n\t\t    inet_ntoa(sap->u.sin.sin_addr));\n\t\t(void) closesocket(sock);\n\t} else if (num_workers(ctx) > 1) {\n\t\tpass_socket(ctx, sock, is_ssl);\n\t} else {\n\t\tadd_socket(first_worker(ctx), sock, is_ssl);\n\t}\n}\n\nstatic int\ndo_select(int max_fd, fd_set *read_set, fd_set *write_set, int milliseconds)\n{\n\tstruct timeval\ttv;\n\tint\t\tn;\n\n\ttv.tv_sec = milliseconds / 1000;\n\ttv.tv_usec = (milliseconds % 1000) * 1000;\n\n\t/* Check IO readiness */\n\tif ((n = select(max_fd + 1, read_set, write_set, NULL, &tv)) < 0) {\n#ifdef _WIN32\n\t\t/*\n\t\t * On windows, if read_set and write_set are empty,\n\t\t * select() returns \"Invalid parameter\" error\n\t\t * (at least on my Windows XP Pro). So in this case,\n\t\t * we sleep here.\n\t\t */\n\t\tSleep(milliseconds);\n#endif /* _WIN32 */\n\t\tDBG((\"select: %d\", ERRNO));\n\t}\n\n\treturn (n);\n}\n\nstatic int\nmultiplex_worker_sockets(const struct worker *worker, int *max_fd,\n\t\tfd_set *read_set, fd_set *write_set)\n{\n\tstruct llhead\t*lp;\n\tstruct conn\t*c;\n\tint\t\tnowait = FALSE;\n\n\t/* Add control socket */\n\tadd_to_set(worker->ctl[0], read_set, max_fd);\n\n\t/* Multiplex streams */\n\tLL_FOREACH(&worker->connections, lp) {\n\t\tc = LL_ENTRY(lp, struct conn, link);\n\n\t\t/* If there is a space in remote IO, check remote socket */\n\t\tif (io_space_len(&c->rem.io))\n\t\t\tadd_to_set(c->rem.chan.fd, read_set, max_fd);\n\n#if !defined(NO_CGI)\n\t\t/*\n\t\t * If there is a space in local IO, and local endpoint is\n\t\t * CGI, check local socket for read availability\n\t\t */\n\t\tif (io_space_len(&c->loc.io) && (c->loc.flags & FLAG_R) &&\n\t\t    c->loc.io_class == &_shttpd_io_cgi)\n\t\t\tadd_to_set(c->loc.chan.fd, read_set, max_fd);\n\n\t\t/*\n\t\t * If there is some data read from remote socket, and\n\t\t * local endpoint is CGI, check local for write availability\n\t\t */\n\t\tif (io_data_len(&c->rem.io) && (c->loc.flags & FLAG_W) &&\n\t\t    c->loc.io_class == &_shttpd_io_cgi)\n\t\t\tadd_to_set(c->loc.chan.fd, write_set, max_fd);\n#endif /* NO_CGI */\n\n\t\t/*\n\t\t * If there is some data read from local endpoint, check the\n\t\t * remote socket for write availability\n\t\t */\n\t\tif (io_data_len(&c->loc.io) && !(c->loc.flags & FLAG_SUSPEND))\n\t\t\tadd_to_set(c->rem.chan.fd, write_set, max_fd);\n\n\t\t/*\n\t\t * Set select wait interval to zero if FLAG_ALWAYS_READY set\n\t\t */\n\t\tif (io_space_len(&c->loc.io) && (c->loc.flags & FLAG_R) &&\n\t\t    (c->loc.flags & FLAG_ALWAYS_READY))\n\t\t\tnowait = TRUE;\n\n\t\tif (io_data_len(&c->rem.io) && (c->loc.flags & FLAG_W) &&\n\t\t    (c->loc.flags & FLAG_ALWAYS_READY))\n\t\t\tnowait = TRUE;\n\t}\n\n\treturn (nowait);\n}\n\nint\nshttpd_join(struct shttpd_ctx *ctx,\n\t\tfd_set *read_set, fd_set *write_set, int *max_fd)\n{\n\tstruct llhead\t*lp;\n\tstruct listener\t*l;\n\tint\t\tnowait = FALSE;\n\n\t/* Add listening sockets to the read set */\n\tLL_FOREACH(&ctx->listeners, lp) {\n\t\tl = LL_ENTRY(lp, struct listener, link);\n\t\tadd_to_set(l->sock, read_set, max_fd);\n\t\tDBG((\"FD_SET(%d) (listening)\", l->sock));\n\t}\n\n\tif (num_workers(ctx) == 1)\n\t\tnowait = multiplex_worker_sockets(first_worker(ctx), max_fd,\n\t\t    read_set, write_set);\n\n\treturn (nowait);\n}\n\n\nstatic void\nprocess_worker_sockets(struct worker *worker, fd_set *read_set)\n{\n\tstruct llhead\t*lp, *tmp;\n\tint\t\tcmd, skt[2], sock = worker->ctl[0];\n\tstruct conn\t*c;\n\n\t/* Check if new socket is passed to us over the control socket */\n\tif (FD_ISSET(worker->ctl[0], read_set))\n\t\twhile (recv(sock, (void *) &cmd, sizeof(cmd), 0) == sizeof(cmd))\n\t\t\tswitch (cmd) {\n\t\t\tcase CTL_PASS_SOCKET:\n\t\t\t\t(void)recv(sock, (void *) &skt, sizeof(skt), 0);\n\t\t\t\tadd_socket(worker, skt[0], skt[1]);\n\t\t\t\tbreak;\n\t\t\tcase CTL_WAKEUP:\n\t\t\t\t(void)recv(sock, (void *) &c, sizeof(c), 0);\n\t\t\t\tc->loc.flags &= FLAG_SUSPEND;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t_shttpd_elog(E_FATAL, NULL, \"ctx %p: ctl cmd %d\",\n\t\t\t\t    worker->ctx, cmd);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t/* Process all connections */\n\tLL_FOREACH_SAFE(&worker->connections, lp, tmp) {\n\t\tc = LL_ENTRY(lp, struct conn, link);\n\t\tprocess_connection(c, FD_ISSET(c->rem.chan.sock, read_set),\n\t\t    c->loc.io_class != NULL &&\n\t\t    ((c->loc.flags & FLAG_ALWAYS_READY)\n#if !defined(NO_CGI)\n\t\t    || (c->loc.io_class == &_shttpd_io_cgi &&\n\t\t     FD_ISSET(c->loc.chan.fd, read_set))\n#endif /* NO_CGI */\n\t\t    ));\n\t}\n}\n\n/*\n * One iteration of server loop. This is the core of the data exchange.\n */\nvoid\nshttpd_poll(struct shttpd_ctx *ctx, int milliseconds)\n{\n\tstruct llhead\t*lp;\n\tstruct listener\t*l;\n\tfd_set\t\tread_set, write_set;\n\tint\t\tsock, max_fd = -1;\n\tstruct usa\tsa;\n\n\t_shttpd_current_time = time(0);\n\tFD_ZERO(&read_set);\n\tFD_ZERO(&write_set);\n\n\tif (shttpd_join(ctx, &read_set, &write_set, &max_fd))\n\t\tmilliseconds = 0;\n\n\tif (do_select(max_fd, &read_set, &write_set, milliseconds) < 0)\n\t\treturn;;\n\n\t/* Check for incoming connections on listener sockets */\n\tLL_FOREACH(&ctx->listeners, lp) {\n\t\tl = LL_ENTRY(lp, struct listener, link);\n\t\tif (!FD_ISSET(l->sock, &read_set))\n\t\t\tcontinue;\n\t\tdo {\n\t\t\tsa.len = sizeof(sa.u.sin);\n\t\t\tif ((sock = accept(l->sock, &sa.u.sa, &sa.len)) != -1)\n\t\t\t\thandle_connected_socket(ctx,&sa,sock,l->is_ssl);\n\t\t} while (sock != -1);\n\t}\n\n\tif (num_workers(ctx) == 1)\n\t\tprocess_worker_sockets(first_worker(ctx), &read_set);\n}\n\n/*\n * Deallocate shttpd object, free up the resources\n */\nvoid\nshttpd_fini(struct shttpd_ctx *ctx)\n{\n\tsize_t\ti;\n\n\tfree_list(&ctx->workers, worker_destructor);\n\tfree_list(&ctx->registered_uris, registered_uri_destructor);\n\tfree_list(&ctx->acl, acl_destructor);\n\tfree_list(&ctx->listeners, listener_destructor);\n#if !defined(NO_SSI)\n\tfree_list(&ctx->ssi_funcs, _shttpd_ssi_func_destructor);\n#endif /* !NO_SSI */\n\n\tfor (i = 0; i < NELEMS(ctx->options); i++)\n\t\tif (ctx->options[i] != NULL)\n\t\t\tfree(ctx->options[i]);\n\n\tif (ctx->access_log)\t\t(void) fclose(ctx->access_log);\n\tif (ctx->error_log)\t\t(void) fclose(ctx->error_log);\n\n\t/* TODO: free SSL context */\n\n\tfree(ctx);\n}\n\n/*\n * UNIX socketpair() implementation. Why? Because Windows does not have it.\n * Return 0 on success, -1 on error.\n */\nint\nshttpd_socketpair(int sp[2])\n{\n\tstruct sockaddr_in\tsa;\n\tint\t\t\tsock, ret = -1;\n\tsocklen_t\t\tlen = sizeof(sa);\n\n\tsp[0] = sp[1] = -1;\n\n\t(void) memset(&sa, 0, sizeof(sa));\n\tsa.sin_family \t\t= AF_INET;\n\tsa.sin_port\t\t= htons(0);\n\tsa.sin_addr.s_addr\t= htonl(INADDR_LOOPBACK);\n\n\tif ((sock = socket(AF_INET, SOCK_STREAM, 0)) != -1 &&\n\t    !bind(sock, (struct sockaddr *) &sa, len) &&\n\t    !listen(sock, 1) &&\n\t    !getsockname(sock, (struct sockaddr *) &sa, &len) &&\n\t    (sp[0] = socket(AF_INET, SOCK_STREAM, 6)) != -1 &&\n\t    !connect(sp[0], (struct sockaddr *) &sa, len) &&\n\t    (sp[1] = accept(sock,(struct sockaddr *) &sa, &len)) != -1) {\n\n\t\t/* Success */\n\t\tret = 0;\n\t} else {\n\n\t\t/* Failure, close descriptors */\n\t\tif (sp[0] != -1)\n\t\t\t(void) closesocket(sp[0]);\n\t\tif (sp[1] != -1)\n\t\t\t(void) closesocket(sp[1]);\n\t}\n\n\t(void) closesocket(sock);\n\t(void) _shttpd_set_non_blocking_mode(sp[0]);\n\t(void) _shttpd_set_non_blocking_mode(sp[1]);\n\n#ifndef _WIN32\n\t(void) fcntl(sp[0], F_SETFD, FD_CLOEXEC);\n\t(void) fcntl(sp[1], F_SETFD, FD_CLOEXEC);\n#endif /* _WIN32*/\n\n\treturn (ret);\n}\n\nstatic int isbyte(int n) { return (n >= 0 && n <= 255); }\n\nstatic int\nset_inetd(struct shttpd_ctx *ctx, const char *flag)\n{\n\tctx = NULL; /* Unused */\n\n\tif (_shttpd_is_true(flag)) {\n\t\tshttpd_set_option(ctx, \"ports\", NULL);\n\t\t(void) freopen(\"/dev/null\", \"a\", stderr);\n\t\tadd_socket(first_worker(ctx), 0, 0);\n\t}\n\n\treturn (TRUE);\n}\n\nstatic int\nset_uid(struct shttpd_ctx *ctx, const char *uid)\n{\n\tstruct passwd\t*pw;\n\n\tctx = NULL; /* Unused */\n\n#if !defined(_WIN32)\n\tif ((pw = getpwnam(uid)) == NULL)\n\t\t_shttpd_elog(E_FATAL, 0, \"%s: unknown user [%s]\", __func__, uid);\n\telse if (setgid(pw->pw_gid) == -1)\n\t\t_shttpd_elog(E_FATAL, NULL, \"%s: setgid(%s): %s\",\n\t\t    __func__, uid, strerror(errno));\n\telse if (setuid(pw->pw_uid) == -1)\n\t\t_shttpd_elog(E_FATAL, NULL, \"%s: setuid(%s): %s\",\n\t\t    __func__, uid, strerror(errno));\n#endif /* !_WIN32 */\n\treturn (TRUE);\n}\n\nstatic int\nset_acl(struct shttpd_ctx *ctx, const char *s)\n{\n\tstruct acl\t*acl = NULL;\n\tchar\t\tflag;\n\tint\t\tlen, a, b, c, d, n, mask;\n\n\t/* Delete the old ACLs if any */\n\tfree_list(&ctx->acl, acl_destructor);\n\n\tFOR_EACH_WORD_IN_LIST(s, len) {\n\n\t\tmask = 32;\n\n\t\tif (sscanf(s, \"%c%d.%d.%d.%d%n\",&flag,&a,&b,&c,&d,&n) != 5) {\n\t\t\t_shttpd_elog(E_FATAL, NULL, \"[%s]: subnet must be \"\n\t\t\t    \"[+|-]x.x.x.x[/x]\", s);\n\t\t} else if (flag != '+' && flag != '-') {\n\t\t\t_shttpd_elog(E_FATAL, NULL, \"flag must be + or -: [%s]\", s);\n\t\t} else if (!isbyte(a)||!isbyte(b)||!isbyte(c)||!isbyte(d)) {\n\t\t\t_shttpd_elog(E_FATAL, NULL, \"bad ip address: [%s]\", s);\n\t\t} else\tif ((acl = malloc(sizeof(*acl))) == NULL) {\n\t\t\t_shttpd_elog(E_FATAL, NULL, \"%s\", \"cannot malloc subnet\");\n\t\t} else if (sscanf(s + n, \"/%d\", &mask) == 0) {\n\t\t\t/* Do nothing, no mask specified */\n\t\t} else if (mask < 0 || mask > 32) {\n\t\t\t_shttpd_elog(E_FATAL, NULL, \"bad subnet mask: %d [%s]\", n, s);\n\t\t}\n\n\t\tacl->ip = (a << 24) | (b << 16) | (c << 8) | d;\n\t\tacl->mask = mask ? 0xffffffffU << (32 - mask) : 0;\n\t\tacl->flag = flag;\n\t\tLL_TAIL(&ctx->acl, &acl->link);\n\t}\n\n\treturn (TRUE);\n}\n\n#ifndef NO_SSL\n/*\n * Dynamically load SSL library. Set up ctx->ssl_ctx pointer.\n */\nstatic int\nset_ssl(struct shttpd_ctx *ctx, const char *pem)\n{\n\tSSL_CTX\t\t*CTX;\n\tvoid\t\t*lib;\n\tstruct ssl_func\t*fp;\n\tchar *ssl_disabled_protocols = wsmand_options_get_ssl_disabled_protocols();\n\tchar *ssl_cipher_list = wsmand_options_get_ssl_cipher_list();\n\tint\t\tretval = FALSE;\n\tEC_KEY*\t\tkey;\n\n\t/* Load SSL library dynamically */\n\tif ((lib = dlopen(SSL_LIB, RTLD_LAZY)) == NULL) {\n\t\t_shttpd_elog(E_LOG, NULL, \"set_ssl: cannot load %s\", SSL_LIB);\n\t\treturn (FALSE);\n\t}\n\n\tfor (fp = ssl_sw; fp->name != NULL; fp++)\n\t\tif ((fp->ptr.v_void = dlsym(lib, fp->name)) == NULL) {\n\t\t\t_shttpd_elog(E_LOG, NULL,\"set_ssl: cannot find %s\", fp->name);\n\t\t\treturn (FALSE);\n\t\t}\n\n\t/* Initialize SSL crap */\n\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n\tSSL_library_init();\n\tif ((CTX = SSL_CTX_new(SSLv23_server_method())) == NULL)\n#else\n        OPENSSL_init_ssl();\n\tif ((CTX = SSL_CTX_new(TLS_server_method())) == NULL)\n#endif\n\t\t_shttpd_elog(E_LOG, NULL, \"SSL_CTX_new error\");\n\telse if (SSL_CTX_use_certificate_file(CTX, wsmand_options_get_ssl_cert_file(), SSL_FILETYPE_PEM) != 1)\n\t\t_shttpd_elog(E_LOG, NULL, \"cannot open certificate file %s\", pem);\n\telse if (SSL_CTX_use_PrivateKey_file(CTX, wsmand_options_get_ssl_key_file(), SSL_FILETYPE_PEM) != 1)\n\t\t_shttpd_elog(E_LOG, NULL, \"cannot open PrivateKey %s\", pem);\n\telse\n\t\tretval = TRUE;\n\n\t/* This enables ECDH Perfect Forward secrecy. Currently with just the most generic p256 prime curve */\n\tkey = EC_KEY_new_by_curve_name(NID_X9_62_prime256v1);\n\tif (key != NULL) {\n\t\tSSL_CTX_set_tmp_ecdh(CTX, key);\n\t\tEC_KEY_free(key);\n\t}\n\n\twhile (ssl_disabled_protocols) {\n\t\tstruct ctx_opts_t {\n\t\t\tchar *name;\n\t\t\tlong opt;\n\t\t} protocols[] = {\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n\t\t\t{ \"SSLv2\", SSL_OP_NO_SSLv2 },\n#endif\n\t\t\t{ \"SSLv3\", SSL_OP_NO_SSLv3 },\n\t\t\t{ \"TLSv1\", SSL_OP_NO_TLSv1 },\n# if OPENSSL_VERSION_NUMBER >= 0x10001000L\n\t\t\t{ \"TLSv1_1\", SSL_OP_NO_TLSv1_1 },\n\t\t\t{ \"TLSv1_2\", SSL_OP_NO_TLSv1_2 },\n# endif\n\t\t\t{ NULL, 0 }\n\t\t};\n\t\tchar *blank_ptr;\n\t\tint idx;\n\t\tif (*ssl_disabled_protocols == 0)\n\t\t\tbreak;\n\t\tblank_ptr = strchr(ssl_disabled_protocols, ' ');\n\t\tif (blank_ptr == NULL)\n\t\t\tblank_ptr = ssl_disabled_protocols + strlen(ssl_disabled_protocols);\n\t\tfor (idx = 0; protocols[idx].name ; ++idx) {\n\t\t\tif (strncasecmp(protocols[idx].name, ssl_disabled_protocols, blank_ptr-ssl_disabled_protocols) == 0) {\n\t\t\t\t//_shttpd_elog(E_LOG, NULL, \"SSL: disable %s protocol\", protocols[idx].name);\n\t\t\t\tdebug(\"SSL: disable %s protocol\", protocols[idx].name);\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\t\t\t\tSSL_CTX_set_options(CTX, protocols[idx].opt);\n#else\n\t\t\t\tSSL_CTX_ctrl(CTX, SSL_CTRL_OPTIONS, protocols[idx].opt, NULL);\n#endif\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (*blank_ptr == 0)\n\t\t\tbreak;\n\t\tssl_disabled_protocols = blank_ptr + 1;\n\t}\n\n\tif (ssl_cipher_list) {\n          int rc = SSL_CTX_set_cipher_list(CTX, ssl_cipher_list);\n          if (rc != 1) {\n            _shttpd_elog(E_LOG, NULL, \"Failed to set SSL cipher list \\\"%s\\\"\", ssl_cipher_list);\n          }\n        }\n        else {\n          _shttpd_elog(E_LOG, NULL, \"Empty 'ssl_cipher_list' defaults to 'TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256'.\");\n          _shttpd_elog(E_LOG, NULL, \"Check openSSL documentation.\");\n        }\n\tctx->ssl_ctx = CTX;\n\n\treturn (retval);\n}\n#endif /* NO_SSL */\n\nstatic int\nopen_log_file(FILE **fpp, const char *path)\n{\n\tint\tretval = TRUE;\n\n\tif (*fpp != NULL)\n\t\t(void) fclose(*fpp);\n\n\tif (path == NULL) {\n\t\t*fpp = NULL;\n\t} else if ((*fpp = fopen(path, \"a\")) == NULL) {\n\t\t_shttpd_elog(E_LOG, NULL, \"cannot open log file %s: %s\",\n\t\t    path, strerror(errno));\n\t\tretval = FALSE;\n\t}\n\n\treturn (retval);\n}\n\nstatic int set_alog(struct shttpd_ctx *ctx, const char *path) {\n\treturn (open_log_file(&ctx->access_log, path));\n}\n\nstatic int set_elog(struct shttpd_ctx *ctx, const char *path) {\n\treturn (open_log_file(&ctx->error_log, path));\n}\n\nstatic void show_cfg_page(struct shttpd_arg *arg);\n\nstatic int\nset_cfg_uri(struct shttpd_ctx *ctx, const char *uri)\n{\n\tfree_list(&ctx->registered_uris, &registered_uri_destructor);\n\n\tif (uri != NULL)\n\t\tshttpd_register_uri(ctx, uri, &show_cfg_page, ctx);\n\n\treturn (TRUE);\n}\n\nstatic struct worker *\nadd_worker(struct shttpd_ctx *ctx)\n{\n\tstruct worker\t*worker;\n\n\tif ((worker = calloc(1, sizeof(*worker))) == NULL)\n\t\t_shttpd_elog(E_FATAL, NULL, \"Cannot allocate worker\");\n\tLL_INIT(&worker->connections);\n\tworker->ctx = ctx;\n\t(void) shttpd_socketpair(worker->ctl);\n\tLL_TAIL(&ctx->workers, &worker->link);\n\n\treturn (worker);\n}\n\n#if !defined(NO_THREADS)\nstatic void\npoll_worker(struct worker *worker, int milliseconds)\n{\n\tfd_set\t\tread_set, write_set;\n\tint\t\tmax_fd = -1;\n\n\tFD_ZERO(&read_set);\n\tFD_ZERO(&write_set);\n\n\tif (multiplex_worker_sockets(worker, &max_fd, &read_set, &write_set))\n\t\tmilliseconds = 0;\n\n\tif (do_select(max_fd, &read_set, &write_set, milliseconds) < 0)\n\t\treturn;;\n\n\tprocess_worker_sockets(worker, &read_set);\n}\n\nstatic void\nworker_function(void *param)\n{\n\tstruct worker *worker = param;\n\n\twhile (worker->exit_flag == 0)\n\t\tpoll_worker(worker, 1000 * 10);\n\n\tfree_list(&worker->connections, (void (*)(struct llhead *))connection_desctructor);\n\tfree(worker);\n}\n\nstatic int\nset_workers(struct shttpd_ctx *ctx, const char *value)\n{\n\tint\t\tnew_num, old_num;\n\tstruct llhead\t*lp, *tmp;\n\tstruct worker\t*worker;\n\n       \tnew_num = atoi(value);\n\told_num = 0;\n\tLL_FOREACH(&ctx->workers, lp)\n\t\told_num++;\n\n\tif (new_num == 1) {\n\t\tif (old_num > 1)\n\t\t\t/* Stop old threads */\n\t\t\tLL_FOREACH_SAFE(&ctx->workers, lp, tmp) {\n\t\t\t\tworker = LL_ENTRY(lp, struct worker, link);\n\t\t\t\tLL_DEL(&worker->link);\n\t\t\t\tworker = LL_ENTRY(lp, struct worker, link);\n\t\t\t\tworker->exit_flag = 1;\n\t\t\t}\n\t\t(void) add_worker(ctx);\n\t} else {\n\t\t/* FIXME: we cannot here reduce the number of threads */\n\t\twhile (new_num > 1 && new_num > old_num) {\n\t\t\tworker = add_worker(ctx);\n\t\t\t_beginthread(worker_function, 0, worker);\n\t\t\told_num++;\n\t\t}\n\t}\n\n\treturn (TRUE);\n}\n#endif /* NO_THREADS */\n\nstatic const struct opt {\n\tint\t\tindex;\t\t/* Index in shttpd_ctx\t\t*/\n\tconst char\t*name;\t\t/* Option name in config file\t*/\n\tconst char\t*description;\t/* Description\t\t\t*/\n\tconst char\t*default_value;\t/* Default option value\t\t*/\n\tint (*setter)(struct shttpd_ctx *, const char *);\n} known_options[] = {\n\t{OPT_ROOT, \"root\", \"\\tWeb root directory\", \".\", NULL},\n\t{OPT_INDEX_FILES, \"index_files\", \"Index files\", INDEX_FILES, NULL},\n#ifndef NO_SSL\n\t{OPT_SSL_CERTIFICATE, \"ssl_cert\", \"SSL certificate file\", NULL,set_ssl},\n#endif /* NO_SSL */\n\t{OPT_PORTS, \"ports\", \"Listening ports\", NULL, set_ports},\n\t{OPT_DIR_LIST, \"dir_list\", \"Directory listing\", \"no\", NULL},\n\t{OPT_CFG_URI, \"cfg_uri\", \"Config uri\", NULL, set_cfg_uri},\n\t{OPT_PROTECT, \"protect\", \"URI to htpasswd mapping\", NULL, NULL},\n#ifndef NO_CGI\n\t{OPT_CGI_EXTENSIONS, \"cgi_ext\", \"CGI extensions\", CGI_EXT, NULL},\n\t{OPT_CGI_INTERPRETER, \"cgi_interp\", \"CGI interpreter\", NULL, NULL},\n\t{OPT_CGI_ENVIRONMENT, \"cgi_env\", \"Additional CGI env vars\", NULL, NULL},\n#endif /* NO_CGI */\n\t{OPT_SSI_EXTENSIONS, \"ssi_ext\",\t\"SSI extensions\", SSI_EXT, NULL},\n#ifndef NO_AUTH\n\t{OPT_AUTH_REALM, \"auth_realm\", \"Authentication domain name\",REALM,NULL},\n\t{OPT_AUTH_GPASSWD, \"auth_gpass\", \"Global passwords file\", NULL, NULL},\n\t{OPT_AUTH_PUT, \"auth_PUT\", \"PUT,DELETE auth file\", NULL, NULL},\n#endif /* !NO_AUTH */\n#ifdef _WIN32\n\t{OPT_SERVICE, \"service\", \"Manage WinNNT service (install\"\n\t    \"|uninstall)\", NULL, _shttpd_set_nt_service},\n\t{OPT_HIDE, \"systray\", \"Hide console, show icon on systray\",\n\t\t\"no\", _shttpd_set_systray},\n#else\n\t{OPT_INETD, \"inetd\", \"Inetd mode\", \"no\", set_inetd},\n\t{OPT_UID, \"uid\", \"\\tRun as user\", NULL, set_uid},\n#endif /* _WIN32 */\n\t{OPT_ACCESS_LOG, \"access_log\", \"Access log file\", NULL, set_alog},\n\t{OPT_ERROR_LOG, \"error_log\", \"Error log file\", NULL, set_elog},\n\t{OPT_MIME_TYPES, \"mime_types\", \"Additional mime types list\", NULL,NULL},\n\t{OPT_ALIASES, \"aliases\", \"Path=URI mappings\", NULL, NULL},\n\t{OPT_ACL, \"acl\", \"\\tAllow/deny IP addresses/subnets\", NULL, set_acl},\n#if !defined(NO_THREADS)\n\t{OPT_THREADS, \"threads\", \"Number of worker threads\", \"1\", set_workers},\n#endif /* !NO_THREADS */\n\t{-1, NULL, NULL, NULL, NULL}\n};\n\nstatic const struct opt *\nfind_opt(const char *opt_name)\n{\n\tint\ti;\n\n\tfor (i = 0; known_options[i].name != NULL; i++)\n\t\tif (!strcmp(opt_name, known_options[i].name))\n\t\t\treturn (known_options + i);\n\n\t_shttpd_elog(E_FATAL, NULL, \"no such option: [%s]\", opt_name);\n\n\t/* UNREACHABLE */\n\treturn (NULL);\n}\n\nint\nshttpd_set_option(struct shttpd_ctx *ctx, const char *opt, const char *val)\n{\n\tconst struct opt\t*o = find_opt(opt);\n\tint\t\t\tretval = TRUE;\n\n\t/* Call option setter first, so it can use both new and old values */\n\tif (o->setter != NULL)\n\t\tretval = o->setter(ctx, val);\n\n\t/* Free old value if any */\n\tif (ctx->options[o->index] != NULL)\n\t\tfree(ctx->options[o->index]);\n\n\t/* Set new option value */\n\tctx->options[o->index] = val ? _shttpd_strdup(val) : NULL;\n\n\treturn (retval);\n}\n\nstatic void\nshow_cfg_page(struct shttpd_arg *arg)\n{\n\tstruct shttpd_ctx\t*ctx = arg->user_data;\n\tchar\t\t\topt_name[20], value[BUFSIZ];\n\tconst struct opt\t*o;\n\n\topt_name[0] = value[0] = '\\0';\n\n\tif (!strcmp(shttpd_get_env(arg, \"REQUEST_METHOD\"), \"POST\")) {\n\t\tif (arg->flags & SHTTPD_MORE_POST_DATA)\n\t\t\treturn;\n\t\t(void) shttpd_get_var(\"o\", arg->in.buf, arg->in.len,\n\t\t    opt_name, sizeof(opt_name));\n\t\t(void) shttpd_get_var(\"v\", arg->in.buf, arg->in.len,\n\t\t    value, sizeof(value));\n\t\tshttpd_set_option(ctx, opt_name, value[0] ? value : NULL);\n\t}\n\n\tshttpd_printf(arg, \"HTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n\"\n\t    \"<html><body><h1>SHTTPD v. %s</h1>\", shttpd_version());\n\n\tshttpd_printf(arg, \"%s\", \"<table border=1\"\n\t    \"<tr><th>Option</th><th>Description</th>\"\n\t    \"<th colspan=2>Value</th></tr>\");\n\n\tif (opt_name[0] != '\\0' && value[0] != '\\0')\n\t\tshttpd_printf(arg, \"<p style='color: green'>Saved: %s=%s</p>\",\n\t\t    opt_name, value[0] ? value : \"NULL\");\n\n\n\tfor (o = known_options; o->name != NULL; o++) {\n\t\tshttpd_printf(arg,\n\t\t    \"<form method=post><tr><td>%s</td><td>%s</td>\"\n\t\t    \"<input type=hidden name=o value='%s'>\"\n\t\t    \"<td><input type=text name=v value='%s'></td>\"\n\t\t    \"<td><input type=submit value=save></td></form></tr>\",\n\t\t    o->name, o->description, o->name,\n\t\t    ctx->options[o->index] ? ctx->options[o->index] : \"\");\n\t}\n\n\tshttpd_printf(arg, \"%s\", \"</table></body></html>\");\n\targ->flags |= SHTTPD_END_OF_OUTPUT;\n}\n\n/*\n * Show usage string and exit.\n */\nvoid\n_shttpd_usage(const char *prog)\n{\n\tconst struct opt\t*o;\n\n\t(void) fprintf(stderr,\n\t    \"SHTTPD version %s (c) Sergey Lyubka\\n\"\n\t    \"usage: %s [options] [config_file]\\n\", SHTTPD_VERSION, prog);\n\n#if !defined(NO_AUTH)\n\tfprintf(stderr, \"  -A <htpasswd_file> <realm> <user> <passwd>\\n\");\n#endif /* NO_AUTH */\n\n\tfor (o = known_options; o->name != NULL; o++) {\n\t\t(void) fprintf(stderr, \"  -%s\\t%s\", o->name, o->description);\n\t\tif (o->default_value != NULL)\n\t\t\tfprintf(stderr, \" (default: %s)\", o->default_value);\n\t\tfputc('\\n', stderr);\n\t}\n\n\texit(EXIT_FAILURE);\n}\n\nstatic void\nset_opt(struct shttpd_ctx *ctx, const char *opt, const char *value)\n{\n\tconst struct opt\t*o;\n\n\to = find_opt(opt);\n\tif (ctx->options[o->index] != NULL)\n\t\tfree(ctx->options[o->index]);\n\tctx->options[o->index] = _shttpd_strdup(value);\n}\n\nstatic void\nprocess_command_line_arguments(struct shttpd_ctx *ctx, char *argv[])\n{\n\tconst char\t\t*config_file = CONFIG_FILE;\n\tchar\t\t\tline[BUFSIZ], opt[BUFSIZ],\n\t\t\t\tval[BUFSIZ], path[FILENAME_MAX], *p;\n\tFILE\t\t\t*fp;\n\tsize_t\t\t\ti, line_no = 0;\n\n\t/* First find out, which config file to open */\n\tfor (i = 1; argv[i] != NULL && argv[i][0] == '-'; i += 2)\n\t\tif (argv[i + 1] == NULL)\n\t\t\t_shttpd_usage(argv[0]);\n\n\tif (argv[i] != NULL && argv[i + 1] != NULL) {\n\t\t/* More than one non-option arguments are given w*/\n\t\t_shttpd_usage(argv[0]);\n\t} else if (argv[i] != NULL) {\n\t\t/* Just one non-option argument is given, this is config file */\n\t\tconfig_file = argv[i];\n\t} else {\n\t\t/* No config file specified. Look for one where shttpd lives */\n\t\tif ((p = strrchr(argv[0], DIRSEP)) != 0) {\n\t\t\t_shttpd_snprintf(path, sizeof(path), \"%.*s%s\",\n\t\t\t    p - argv[0] + 1, argv[0], config_file);\n\t\t\tconfig_file = path;\n\t\t}\n\t}\n\n\tfp = fopen(config_file, \"r\");\n\n\t/* If config file was set in command line and open failed, exit */\n\tif (fp == NULL && argv[i] != NULL)\n\t\t_shttpd_elog(E_FATAL, NULL, \"cannot open config file %s: %s\",\n\t\t    config_file, strerror(errno));\n\n\tif (fp != NULL) {\n\n\t\t_shttpd_elog(E_LOG, NULL, \"Loading config file %s\", config_file);\n\n\t\t/* Loop over the lines in config file */\n\t\twhile (fgets(line, sizeof(line), fp) != NULL) {\n\n\t\t\tline_no++;\n\n\t\t\t/* Ignore empty lines and comments */\n\t\t\tif (line[0] == '#' || line[0] == '\\n')\n\t\t\t\tcontinue;\n\n\t\t\tif (sscanf(line, \"%s %[^\\n#]\", opt, val) != 2)\n\t\t\t\t_shttpd_elog(E_FATAL, NULL, \"line %d in %s is invalid\",\n\t\t\t\t    line_no, config_file);\n\n\t\t\tset_opt(ctx, opt, val);\n\t\t}\n\n\t\t(void) fclose(fp);\n\t}\n\n\t/* Now pass through the command line options */\n\tfor (i = 1; argv[i] != NULL && argv[i][0] == '-'; i += 2)\n\t\tset_opt(ctx, &argv[i][1], argv[i + 1]);\n}\n\nstruct shttpd_ctx *\nshttpd_init(int argc, char *argv[])\n{\n\tstruct shttpd_ctx\t*ctx;\n\tstruct tm\t\t*tm;\n\tconst struct opt\t*o;\n\n\tif ((ctx = calloc(1, sizeof(*ctx))) == NULL)\n\t\t_shttpd_elog(E_FATAL, NULL, \"cannot allocate shttpd context\");\n\n\tLL_INIT(&ctx->registered_uris);\n\tLL_INIT(&ctx->uri_auths);\n\tLL_INIT(&ctx->error_handlers);\n\tLL_INIT(&ctx->acl);\n\tLL_INIT(&ctx->ssi_funcs);\n\tLL_INIT(&ctx->listeners);\n\tLL_INIT(&ctx->workers);\n\n\t/* Initialize options. First pass: set default option values */\n\tfor (o = known_options; o->name != NULL; o++)\n\t\tctx->options[o->index] = o->default_value ?\n\t\t\t_shttpd_strdup(o->default_value) : NULL;\n\n\t/* Second and third passes: config file and argv */\n\tif (argc > 0 && argv != NULL)\n\t\tprocess_command_line_arguments(ctx, argv);\n\n\t/* Call setter functions */\n\tfor (o = known_options; o->name != NULL; o++)\n\t\tif (o->setter && ctx->options[o->index] != NULL)\n\t\t\tif (o->setter(ctx, ctx->options[o->index]) == FALSE) {\n\t\t\t\tshttpd_fini(ctx);\n\t\t\t\treturn (NULL);\n\t\t\t}\n\n\t_shttpd_current_time = time(NULL);\n\ttm = localtime(&_shttpd_current_time);\n\t_shttpd_tz_offset = 0;\n\n\tif (num_workers(ctx) == 1)\n\t\t(void) add_worker(ctx);\n#if 0\n\ttm->tm_gmtoff - 3600 * (tm->tm_isdst > 0 ? 1 : 0);\n#endif\n\n#ifdef _WIN32\n\t{WSADATA data;\tWSAStartup(MAKEWORD(2,2), &data);}\n#endif /* _WIN32 */\n\n\treturn (ctx);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-openwsman-2.6.11-urnjctbu3pjxgiqzjtqviczvlqse3qms/spack-src/src/plugins/swig/src/target_ruby.c": "/*\n * target_ruby.c\n *\n * Target language specific functions for openwsman swig plugins\n *\n * Here: Ruby\n */\n\n/*****************************************************************************\n* Copyright (C) 2008 Novell Inc. All rights reserved.\n* Copyright (C) 2008 SUSE Linux Products GmbH. All rights reserved.\n* \n* Redistribution and use in source and binary forms, with or without\n* modification, are permitted provided that the following conditions are met:\n* \n*   - Redistributions of source code must retain the above copyright notice,\n*     this list of conditions and the following disclaimer.\n* \n*   - Redistributions in binary form must reproduce the above copyright notice,\n*     this list of conditions and the following disclaimer in the documentation\n*     and/or other materials provided with the distribution.\n* \n*   - Neither the name of Novell Inc. nor of SUSE Linux Products GmbH nor the\n*     names of its contributors may be used to endorse or promote products\n*     derived from this software without specific prior written permission.\n* \n* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS IS''\n* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n* ARE DISCLAIMED. IN NO EVENT SHALL Novell Inc. OR SUSE Linux Products GmbH OR\n* THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, \n* PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; \n* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, \n* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR \n* OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF \n* ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*****************************************************************************/\n\n/* load <RB_PLUGIN_FILE>.rb */\n#define PLUGIN_FILE \"openwsmanplugin\"\n\n/* expect 'module <RB_PLUGIN_MODULE>' inside */\n#define PLUGIN_MODULE \"Openwsman\"\n\n/*\n * load_module\n * separate function for rb_require so it can be wrapped into rb_protect()\n */\n\nstatic VALUE\nload_module()\n{\n  ruby_script(PLUGIN_FILE);\n  return rb_require(PLUGIN_FILE);\n}\n\n\n/*\n * create_plugin (called from rb_protect)\n * load Ruby provider and create plugin instance\n * \n */\n\nstatic VALUE\ncreate_plugin(VALUE args)\n{\n  return rb_funcall2(_TARGET_MODULE, rb_intern(\"create_plugin\"), 0, NULL);\n}\n\n\n/*\n * call_plugin\n * call function of plugin instance\n * \n * I args: pointer to array of at least 3 values\n *         args[0] -> (VALUE) instance\n *         args[1] -> (VALUE) id of function\n *         args[2] -> (int) number of arguments\n *         args[3...n] -> (VALUE) arguments\n */\n\nstatic VALUE\ncall_plugin(VALUE args)\n{\n  VALUE *values = (VALUE *)args;\n  return rb_funcall3(values[0], values[1], (int)values[2], values+3);\n}\n\n\n\n/*\n * get Ruby exception trace -> char *\n * \n */\n\n#define TB_ERROR(str) {tbstr = str; goto cleanup;}\nstatic char *\nget_exc_trace()\n{\n    VALUE exception = rb_gv_get(\"$!\"); /* get last exception */\n    VALUE reason = rb_funcall(exception, rb_intern(\"to_s\"), 0 );\n    VALUE trace = rb_gv_get(\"$@\"); /* get last exception trace */\n    VALUE backtrace = rb_funcall(trace, rb_intern(\"join\"), 1, rb_str_new(\"\\n\\t\", 2));\n\n    return fmtstr(\"%s\\n\\t%s\", StringValuePtr(reason), StringValuePtr(backtrace)); \n}\n\n\n/*\n * Global Ruby initializer\n * loads the Ruby interpreter\n * init threads\n */\n\nstatic int\nRbGlobalInitialize( )\n{\n  int error;\n\n  if (_TARGET_INIT)\n    {\n      return 0; \n    }\n  _TARGET_INIT=1;//true\n  \n  debug(\"Ruby: Loading\");\n  \n  ruby_init();\n  ruby_init_loadpath();\n  ruby_script(PLUGIN_FILE);\n  extern void SWIG_init();\n  SWIG_init();\n\n  /* load module */\n  rb_protect(load_module, Qnil, &error);\n  if (error)\n    {\n      char *trace = get_exc_trace();\n\n      error(\"Ruby: import '%s' failed: %s\", PLUGIN_FILE, trace);\n      return -1;\n    }\n  _TARGET_MODULE = rb_const_get(rb_cModule, rb_intern(PLUGIN_MODULE));\n  if (NIL_P(_TARGET_MODULE))\n    {\n      error(\"Ruby: import '%s' doesn't define module '%s'\", PLUGIN_MODULE);\n      return -1;\n    }  \n  debug(\"RbGlobalInitialize() succeeded -> module %s @ %p\", PLUGIN_MODULE, _TARGET_MODULE); \n  return 0; \n}\n\n\n/*---------------------------------------------------------------*/\n\n/*\n * local (per plugin) Ruby initializer\n * keeps track of reference count\n * \n * self: handle (from dlopen)\n * data: user data return\n */\n\nstatic int\nTargetInitialize( void *self, void **data )\n{\n  VALUE args[2];\n  int error;\n\n  debug(\"TargetInitialize(Ruby)\");\n  /* Set _PLUGIN_INIT, protected by _PLUGIN_INIT_MUTEX\n   * so we call ruby_finalize() only once.\n   */\n  if (pthread_mutex_lock(&_PLUGIN_INIT_MUTEX))\n  {\n      perror(\"Can't lock _PLUGIN_INIT_MUTEX\");\n      abort();\n  }\n  error = RbGlobalInitialize( ); \n  pthread_mutex_unlock(&_PLUGIN_INIT_MUTEX);\n  if (error != 0)\n  {\n     goto exit;\n  }\n\n  debug(\"TargetInitialize(Ruby) called\");\n\n  *data = (void *)rb_protect(create_plugin, (VALUE)args, &error);\n  if (error)\n    {\n      char *trace = get_exc_trace();\n      error(\"Ruby: FAILED creating:\", trace);\n    }\n  debug(\"Created plugin: klass @ %p\", *data);\nexit:\n  debug(\"Initialize() %s\", (error == 0)? \"succeeded\":\"failed\");\n  return error;\n}\n\n\n/*\n * TargetCall\n * Call function 'opname' with nargs arguments within instance\n * \n * doc: in_doc from context, needed for fault generation\n * instance: module\n * opname: name of method to call\n * nargs: number of arguments\n * ...: arguments as varargs\n * \n */\n\nstatic int \nTargetCall(WsXmlDocH doc, VALUE instance, const char* opname, int nargs, ...)\n{\n  int i; \n  VALUE *args, result, op = rb_intern(opname);\n  va_list vargs; \n  WsmanStatus status;\n  wsman_status_init(&status);\n\n  debug(\"TargetCall(Ruby): %p.%s\", (void *)instance, opname);\n  \n  /* add instance, op and nargs to the args array, so rb_protect can be called */\n  nargs += 3;\n  args = (VALUE *)malloc(nargs * sizeof(VALUE));\n  if (args == NULL)\n    {\n      error(\"Out of memory\"); \n      abort();\n    }\n  args[0] = instance;\n  args[1] = op;\n  args[2] = (VALUE)(nargs-3);\n  if (nargs > 3)\n    {\n      va_start(vargs, nargs);\n      for (i = 3; i < nargs; ++i)\n\t{\n\t  args[i] = va_arg(vargs, VALUE);\n\t}\n      va_end(vargs);\n    }\n\n  \n  /* call the Ruby function\n   * possible results:\n   *   i nonzero: Exception raised\n   *   result == nil: not (or badly) implemented \n   *   result == true: success\n   *   result == Array: pair of CMPIStatus rc(int) and msg(string)\n   */\n  result = rb_protect(call_plugin, (VALUE)args, &i);\n  free( args );\n\n  if (i) /* exception ? */\n    {\n      char *trace = get_exc_trace();\n      status.fault_msg = fmtstr(\"Ruby: calling '%s' failed: %s\", opname, trace); \n      status.fault_code = WSMAN_INTERNAL_ERROR;\n      status.fault_detail_code = 0;\n      error(\"%s\", status.fault_msg);\n      return 1;\n    }\n  \n  if (NIL_P(result)) /* not or wrongly implemented */\n    {\n      status.fault_code = WSA_ENDPOINT_UNAVAILABLE;\n      status.fault_detail_code = 0;\n      return 1;\n    }\n\n  if (result != Qtrue)\n    {\n      int len;\n      VALUE resulta = rb_check_array_type(result);\n      \n      if (NIL_P(resulta))\n\t{\n\t  status.fault_msg = fmtstr(\"Ruby: calling '%s' returned unknown result\", opname);\n\t  status.fault_code = WSMAN_INTERNAL_ERROR;\n\t  status.fault_detail_code = 0;\n\t  return 1;\n\t}\n  \n      len = RARRAY_LEN(RARRAY(resulta));\n      if (len > 0) \n\t{\n\t  VALUE code = rb_ary_entry(resulta, 0);\n\t  if (!FIXNUM_P(code))\n\t    {\n\t      status.fault_msg = fmtstr(\"Ruby: calling '%s' returned non-numeric code\", opname);\n\t      status.fault_code = WSMAN_INTERNAL_ERROR;\n\t      status.fault_detail_code = 0;\n\t      return 1;\n\t    }\n\t  status.fault_code = FIX2LONG(code);\n\t}\n      \n      if (len > 1) \n\t{\n\t  VALUE detail = rb_ary_entry(resulta, 1);\n\t  if (!FIXNUM_P(detail))\n\t    {\n\t      status.fault_msg = fmtstr(\"Ruby: calling '%s' returned non-numeric detail\", opname);\n\t      status.fault_code = WSMAN_INTERNAL_ERROR;\n\t      status.fault_detail_code = 0;\n\t      return 1;\n\t    }\n\t  status.fault_detail_code = FIX2LONG(detail);\n\t}\n      if (len > 2)\n\t{\n\t  VALUE str = rb_ary_entry(resulta, 2);\n\t  status.fault_msg = StringValuePtr(str);\n\t}\n      wsman_generate_fault( doc, status.fault_code, status.fault_detail_code, status.fault_msg );\n    }\n  \n  /* all is fine */\n\n  return 0;\n}\n\n\n/*\n * TargetCleanup\n */\n\nstatic void\nTargetCleanup( void *self, void *data )\n{\n  debug(\"TargetCleanup(Ruby)\");\n  ruby_finalize();\n  _TARGET_MODULE = Qnil;   \n  return;\n}\n\n\nstatic VALUE\ncall_namespaces(VALUE klass)\n{\n  return rb_funcall( klass, rb_intern( \"namespaces\" ), 0 );\n}\n\n\n/*\n * TargetEndpoints\n */\n\nstatic list_t *\nTargetEndpoints( void *self, void *data )\n{\n    int error;\n    VALUE klass = (VALUE)data;\n    VALUE rbnamespaces, ary;\n    debug(\"TargetEndpoints(Ruby), data %p, klass %p\", data, klass);\n\n    /*\n     * Get namespaces\n     */\n  \n    list_t *namespaces = list_create(LISTCOUNT_T_MAX);\n    debug(\"TargetEndpoints(Ruby), calling namespaces\");\n    rbnamespaces = rb_protect(call_namespaces, klass, &error);\n    if (error) {\n      char *trace = get_exc_trace();\n\n      error(\"Ruby: 'namespaces' failed: %s\", PLUGIN_FILE, trace);\n      return NULL;\n    }\n    debug(\"TargetEndpoints(Ruby), called namespaces: %p\", rbnamespaces);\n    ary = rb_check_array_type( rbnamespaces );\n    if (NIL_P(ary)) {\n      rb_raise( rb_eArgError, \"namespaces is not array\");\n    }\n    int len = RARRAY_LEN(RARRAY(ary));\n    if (len <= 0) {\n      rb_raise( rb_eArgError, \"namespaces returned array with %d elements\", len);\n    }\n    int i;\n    for (i = 0; i < len; ++i) {\n      lnode_t *node;\n      VALUE elem = RARRAY_PTR(RARRAY(ary))[i];\n      VALUE pair = rb_check_array_type( elem );\n      if (NIL_P(pair)) {\n\trb_raise( rb_eArgError, \"namespaces must return array of arrays\");\n      }\n      if (RARRAY_LEN(RARRAY(pair)) != 2) {\n\trb_raise( rb_eArgError, \"namespaces must return array of ['<namespace>','<class_prefix>']\");\n      }\n      WsSupportedNamespaces *ns = (WsSupportedNamespaces *)u_malloc(sizeof(WsSupportedNamespaces));\n      ns->ns = StringValuePtr( RARRAY_PTR(RARRAY(pair))[0] );\n      ns->class_prefix = StringValuePtr( RARRAY_PTR(RARRAY(pair))[1] );\n      node = lnode_create(ns);\n      list_append(namespaces, node);\n    }\n\n  return namespaces;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-openwsman-2.6.11-urnjctbu3pjxgiqzjtqviczvlqse3qms/spack-src/src/authenticators/pam/pam_auth.c": "/*******************************************************************************\n * Copyright (C) 2004-2006 Intel Corp. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *  - Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *\n *  - Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n *  - Neither the name of Intel Corp. nor the names of its\n *    contributors may be used to endorse or promote products derived from this\n *    software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL Intel Corp. OR THE CONTRIBUTORS\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *******************************************************************************/\n\n/**\n * @author Vadim Revyakin\n */\n#ifdef HAVE_CONFIG_H\n#include <wsman_config.h>\n#endif\n\n#define NO_DLLOAD\n\n#include <string.h>\n#include <stdlib.h>\n\n#if defined(HAVE_PAM_PAM_APPL_H)\n#include <pam/pam_appl.h>\n#elif defined(HAVE_SECURITY_PAM_APPL_H)\n#include <security/pam_appl.h>\n#endif\n\n#if defined(HAVE_PAM_PAM_MISC_H)\n#include <pam/pam_misc.h>\n#elif defined(HAVE_SECURITY_PAM_MISC_H)\n#include <security/pam_misc.h>\n#endif\n\n\n#ifndef STANDALONE\n#include \"u/libu.h\"\nint initialize(void *arg);\nint authorize(char *username, const char *password);\n#endif\n\n\nstatic char *service = \"openwsman\";\n\n\n#define debug_dlsym(sym) \\\n\tdebug(\"Could not dlsym %s\", sym)\n\n#ifdef STANDALONE\n\n#include <stdio.h>\n\n#define debug(frmt, ...) \\\n\tprintf(frmt, __VA_ARGS__); printf(\"\\n\")\n\n#define PAM_start pam_start\n#define PAM_authenticate pam_authenticate\n#define PAM_acct_mgmt pam_acct_mgmt\n#define PAM_end pam_end\n#define PAM_strerror pam_strerror\n\n#else\n#ifdef NO_DLLOAD\n\n#define PAM_start pam_start\n#define PAM_authenticate pam_authenticate\n#define PAM_acct_mgmt pam_acct_mgmt\n#define PAM_end pam_end\n#define PAM_strerror pam_strerror\n\nint\ninitialize(void *arg)\n{\n\treturn 0;\n}\n\n#else // !STANDALONE && !NO_DLLOAD\n\n#include <dlfcn.h>\n\n#define LIBPAM   \"libpam.so\"\n\n\nstatic int (*PAM_start)(const char *service_name,\n\t\tconst char *user,\n\t\tconst struct pam_conv *pam_conversation,\n\t\tpam_handle_t **pamh);\nstatic int (*PAM_authenticate)(pam_handle_t *pamh, int flags);\nstatic int (*PAM_acct_mgmt)(pam_handle_t *pamh, int flags);\nstatic int (*PAM_end)(pam_handle_t *pamh, int pam_status);\nstatic int (*PAM_strerror)(pam_handle_t *pamh, int errnum);\n\n\n\nint\ninitialize(void *arg)\n{\n\tvoid *hnd;\n\n\thnd = dlopen(LIBPAM, RTLD_LAZY | RTLD_GLOBAL);\n\tif (hnd == NULL) {\n\t\tdebug(\"Could not dlopen %s\", LIBPAM);\n\t\treturn 1;\n\t}\n\tPAM_start = dlsym(hnd, \"pam_start\");\n\tif (PAM_start == NULL) {\n\t\tdebug_dlsym(\"pam_start\");\n\t\tdlclose(hnd);\n\t\treturn 1;\n\t}\n\tPAM_authenticate = dlsym(hnd, \"pam_authenticate\");\n\tif (PAM_authenticate == NULL) {\n\t\tdebug_dlsym(\"pam_authenticate\");\n\t\tdlclose(hnd);\n\t\treturn 1;\n\t}\n\tPAM_acct_mgmt = dlsym(hnd, \"pam_acct_mgmt\");\n\tif (PAM_acct_mgmt == NULL) {\n\t\tdebug_dlsym(\"pam_acct_mgmt\");\n\t\tdlclose(hnd);\n\t\treturn 1;\n\t}\n\tPAM_end = dlsym(hnd, \"pam_end\");\n\tif (PAM_end == NULL) {\n\t\tdebug_dlsym(\"pam_end\");\n\t\tdlclose(hnd);\n\t\treturn 1;\n\t}\n\tPAM_strerror = dlsym(hnd, \"pam_strerror\");\n\tif (PAM_strerror == NULL) {\n\t\tdebug_dlsym(\"pam_strerror\");\n\t\tdlclose(hnd);\n\t\treturn 1;\n\t}\n\n\n\tif (arg != NULL) {\n\t\tservice = (char *)arg;\n\t}\n\t//    debug_level = dbg_lvl;\n\n\treturn 0;\n}\n\n\n#endif // NO_DLLOAD\n#endif // STANDALONE\n\n\nstatic int\n#if defined (__SVR4) && defined (__sun)\npwd_conv(int num_msg, struct pam_message **msgm,\n#else\npwd_conv(int num_msg, const struct pam_message **msgm,\n#endif\n\t\tstruct pam_response **response, void *appdata_ptr)\n{\n\tchar *pwd = (char *)appdata_ptr;\n\tint n;\n\tstruct pam_response *reply;\n\treply = (struct pam_response *) calloc(num_msg,\n\t\t\tsizeof(struct pam_response));\n\tif (reply == NULL) {\n\t\tdebug(\"No %s\", \"memory\");\n\t\treturn PAM_CONV_ERR;\n\t}\n\n\tfor (n = 0; n < num_msg; n++) {\n\t\tswitch (msgm[n]->msg_style) {\n\t\tcase PAM_PROMPT_ECHO_OFF:\n\t\tcase PAM_PROMPT_ECHO_ON:\n\t\t\treply[n].resp = strdup(pwd);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t*response = reply;\n\treturn PAM_SUCCESS;\n}\n\n#ifdef STANDALONE\nstatic\n#endif\nint\nauthorize(char *username, const char *password)\n{\n\tstruct pam_conv conv = {\n\t\tpwd_conv,\n\t\t(void *)password\n\t};\n\tpam_handle_t   *pamh = NULL;\n\tint             r;\n\tint             res = 0;\n\t// printf(\"service = %s\\n\", service);\n\tr = PAM_start(service, username, &conv, &pamh);\n\tif (r != PAM_SUCCESS) {\n\t\tdebug(\"pam_start failed = %d(%s)\", r, PAM_strerror(pamh, r));\n\t\treturn 0;\n\t}\n\n\tr = PAM_authenticate(pamh, PAM_SILENT | PAM_DISALLOW_NULL_AUTHTOK);\n\tif (r != PAM_SUCCESS) {\n\t\tdebug(\"pam_authenticate failed = %d(%s)\", r, PAM_strerror(pamh, r));\n\t\tgoto DONE;\n\t}\n\tr = PAM_acct_mgmt(pamh, PAM_SILENT | PAM_DISALLOW_NULL_AUTHTOK);\n\tif (r != PAM_SUCCESS) {\n\t\tdebug(\"pam_ acct_mgmt failed = %d(%s)\", r, PAM_strerror(pamh, r));\n\t\tgoto DONE;\n\t}\n\tres = 1;\nDONE:\n\tr = PAM_end(pamh, r);\n\tif (r != PAM_SUCCESS) {\n\t\tdebug(\"pam_end failed = %d(%s)\", r, PAM_strerror(pamh, r));\n\t}\n\treturn res;\n}\n\n#ifdef STANDALONE\n\n/*\n *     run\n *   gcc -o wspam -DSTANDALONE wsmand_pam.c -lpam\n *     to build a program\n */\n\nint main(int argc, char **argv)\n{\n\tchar *user;\n\tchar *pwd;\n\tint res;\n\n\tif ((argc != 3) && (argc != 4)) {\n\t\tprintf(\"Usage: wsmand_pam <user> <password> [<service>]\\n\");\n\t\treturn 1;\n\t}\n\n\tif (argc == 4) {\n\t\tservice = argv[3];\n\t}\n\n\tif (authorize(argv[1], argv[2])) {\n\t\tprintf(\"Authenticated\\n\");\n\t} else {\n\t\tprintf(\"Not Authenticated\\n\");\n\t}\n\tif (authorize(argv[1], argv[2])) {\n\t\tprintf(\"Authenticated\\n\");\n\t} else {\n\t\tprintf(\"Not Authenticated\\n\");\n\t}\n\treturn 0;\n}\n\n#endif\n"
    },
    "skipped": [],
    "total_files": 490
}