{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/src/OSspecific/MSWindows/MSwindows.C": "/*---------------------------------------------------------------------------*\\\n  =========                 |\n  \\\\      /  F ield         | foam-extend: Open Source CFD\n   \\\\    /   O peration     | Version:     3.2\n    \\\\  /    A nd           | Web:         http://www.foam-extend.org\n     \\\\/     M anipulation  | For copyright notice see file Copyright\n-------------------------------------------------------------------------------\nLicense\n    This file is part of foam-extend.\n\n    foam-extend is free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your\n    option) any later version.\n\n    foam-extend is distributed in the hope that it will be useful, but\n    WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with foam-extend.  If not, see <http://www.gnu.org/licenses/>.\n\nDescription\n    MS Windows specific functions\n\n\\*---------------------------------------------------------------------------*/\n\n/*---------------------------------------------------------------------------*\\\n    Copyright            : (C) 2011 Symscape\n    Website              : www.symscape.com\n\\*---------------------------------------------------------------------------*/\n\n#include \"OSspecific.H\"\n#include \"MSwindows.H\"\n#include \"foamVersion.H\"\n#include \"fileName.H\"\n#include \"fileStat.H\"\n\n#include <cassert>\n#include <cstdlib>\n#include <fstream>\n#include <map>\n\n// Windows system header files\n#include <io.h> // _close\n#include <windows.h>\n#include <signal.h>\n\n\n// * * * * * * * * * * * * * * Static Data Members * * * * * * * * * * * * * //\n\ndefineTypeNameAndDebug(Foam::MSwindows, 0);\n\nnamespace Foam\n{\n\n// Don't abort under windows, causes abort dialog to\n// popup. Instead just exit with exitCode.\nstatic\nvoid sigAbortHandler(int exitCode)\n{\n  ::exit(exitCode);\n}\n\n\nstatic\nbool installAbortHandler()\n{\n  // If it didn't succeed there's not much we can do,\n  // so don't check result.\n  ::signal(SIGABRT, &sigAbortHandler);\n  return true;\n}\n\n\nstatic bool const abortHandlerInstalled = installAbortHandler();\n\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //\n\n\n//- Get last windows api error from GetLastError\nstd::string MSwindows::getLastError()\n{\n    // Based on an example at:\n    // http://msdn2.microsoft.com/en-us/library/ms680582(VS.85).aspx\n\n    LPVOID lpMsgBuf;\n    LPVOID lpDisplayBuf;\n    DWORD dw = GetLastError();\n\n    FormatMessage(\n        FORMAT_MESSAGE_ALLOCATE_BUFFER |\n        FORMAT_MESSAGE_FROM_SYSTEM |\n        FORMAT_MESSAGE_IGNORE_INSERTS,\n        NULL,\n        dw,\n        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n        (LPTSTR) &lpMsgBuf,\n        0, NULL );\n\n    lpDisplayBuf = LocalAlloc(LMEM_ZEROINIT,\n        (lstrlen(static_cast<LPCTSTR>(lpMsgBuf))+40)*sizeof(TCHAR));\n    sprintf(static_cast<LPTSTR>(lpDisplayBuf),\n            \"Error %d: %s\", int(dw), static_cast<LPCTSTR>(lpMsgBuf));\n\n    const std::string errorMessage = static_cast<LPTSTR>(lpDisplayBuf);\n\n    LocalFree(lpMsgBuf);\n    LocalFree(lpDisplayBuf);\n\n    return errorMessage;\n}\n\n\n//-Declared here to avoid polluting MSwindows.H with windows.h\nnamespace MSwindows\n{\n    //- Get windows user name\n    std::string getUserName();\n\n    //- Remove quotes, if any, from std::string\n    void removeQuotes(std::string & arg);\n\n    //- Convert windows directory slash (back-slash) to unix (forward-slash).\n    //- Windows is fine with unix like directory slashes.\n    //- Foam's file io (see src/OpenFOAM/db/IOstreams/Sstreams/OSwrite.C)\n    //- uses back-slash as escape character and continuation,\n    //- so not an option to have windows file paths with back-slashes\n    void toUnixSlash(string & arg);\n\n    //- Auto create and then delete array when this goes out of scope\n    template<class T>\n    class AutoArray\n    {\n      T* const array_;\n\n    public:\n      AutoArray(const unsigned long arrayLength);\n      ~AutoArray();\n\n      //- Access array\n      T* get();\n    }; // class AutoArray\n\n\n    //- Directory contents iterator\n    class DirectoryIterator\n    {\n      WIN32_FIND_DATA findData_;\n      HANDLE findHandle_;\n      fileName nextName_;\n      bool hasMore_;\n\n    public:\n      DirectoryIterator(const fileName & directory);\n      ~DirectoryIterator();\n\n      //- Initialization succeeded\n      bool isValid() const;\n\n      //- Has more?\n      bool hasNext() const;\n\n      //- Next item\n      const fileName & next();\n    }; // class DirectoryIterator\n} // namespace MSwindows\n\n\ninline\nvoid MSwindows::removeQuotes(std::string & arg)\n{\n    std::size_t pos;\n\n    while (std::string::npos != (pos = arg.find('\"')))\n    {\n        arg.erase(pos, 1);\n    }\n}\n\n\ninline\nvoid MSwindows::toUnixSlash(string & arg)\n{\n    arg.replaceAll(\"\\\\\", \"/\");\n\n    const std::string UNC(\"//\");\n\n    // Preserve UNC i.e., \\\\machine-name\\...\n    if (0 == arg.find(UNC))\n    {\n        arg.replace(UNC, \"\\\\\\\\\");\n    }\n}\n\n\nstd::string MSwindows::getUserName()\n{\n    const DWORD bufferSize = 256;\n    TCHAR buffer[bufferSize];\n    DWORD actualBufferSize = bufferSize;\n    std::string nameAsString;\n\n    bool success = ::GetUserName(buffer, &actualBufferSize);\n\n    if (success)\n    {\n        nameAsString = buffer;\n    }\n    else\n    {\n        if (ERROR_INSUFFICIENT_BUFFER == ::GetLastError() &&\n            32768 > actualBufferSize)\n        {\n            AutoArray<TCHAR> actualBuffer(actualBufferSize);\n            ::GetUserName(actualBuffer.get(), &actualBufferSize);\n            nameAsString = actualBuffer.get();\n        }\n    }\n\n    return nameAsString;\n}\n\n\ntemplate<class T>\ninline\nMSwindows::AutoArray<T>::AutoArray(const unsigned long arrayLength)\n    : array_(new T[arrayLength])\n{}\n\n\ntemplate<class T>\ninline\nMSwindows::AutoArray<T>::~AutoArray()\n{\n    delete [] array_;\n}\n\n\ntemplate<class T>\ninline\nT* MSwindows::AutoArray<T>::get()\n{\n    return array_;\n}\n\n\ninline\nbool MSwindows::DirectoryIterator::isValid() const\n{\n    const bool valid = (INVALID_HANDLE_VALUE != findHandle_);\n    return valid;\n}\n\n\nMSwindows::DirectoryIterator::DirectoryIterator(const fileName & directory)\n{\n    const fileName directoryContents = directory/\"*\";\n    findHandle_ = ::FindFirstFile(directoryContents.c_str(), &findData_);\n    hasMore_    = isValid();\n}\n\n\nMSwindows::DirectoryIterator::~DirectoryIterator()\n{\n    if (isValid())\n    {\n        ::FindClose(findHandle_);\n    }\n}\n\n\ninline\nbool MSwindows::DirectoryIterator::hasNext() const\n{\n    assert(isValid());\n\n    return hasMore_;\n}\n\n\ninline\nconst fileName & MSwindows::DirectoryIterator::next()\n{\n    assert(hasNext());\n\n    nextName_ = findData_.cFileName;\n    hasMore_  = ::FindNextFile(findHandle_, &findData_);\n\n    return nextName_;\n}\n\n\n//PID_T pid()\nint pid()\n{\n    const DWORD processId = ::GetCurrentProcessId();\n    return processId;\n}\n\n\n//PID_T ppid()\npid_t ppid()\n{\n    // No equivalent under windows.\n\n    if (MSwindows::debug)\n    {\n        Info<< \"ppid not supported under MSwindows\" << endl;\n    }\n\n    return 0;\n}\n\n\n//PID_T pgid()\npid_t pgid()\n{\n    // No equivalent under windows.\n\n    if (MSwindows::debug)\n    {\n        Info<< \"pgid not supported under MSwindows\" << endl;\n    }\n\n    return 0;\n}\n\nstd::string toUnixPath(const std::string & path)\n{\n    string unixPath(path);\n    MSwindows::toUnixSlash(unixPath);\n    MSwindows::removeQuotes(unixPath);\n\n    return unixPath;\n}\n\n\nbool env(const word& envName)\n{\n    const DWORD actualBufferSize =\n      ::GetEnvironmentVariable(envName.c_str(), NULL, 0);\n\n    const bool envExists = (0 < actualBufferSize);\n    return envExists;\n}\n\n\nstring getEnv(const word& envName)\n{\n    std::string envAsString;\n\n    const DWORD actualBufferSize =\n      ::GetEnvironmentVariable(envName.c_str(), NULL, 0);\n\n    if (0 < actualBufferSize)\n    {\n        MSwindows::AutoArray<TCHAR> actualBuffer(actualBufferSize);\n        ::GetEnvironmentVariable(envName.c_str(),\n                                 actualBuffer.get(),\n                                 actualBufferSize);\n        envAsString = actualBuffer.get();\n        toUnixPath(envAsString);\n    }\n\n    return envAsString;\n}\n\n\nbool setEnv\n(\n    const word& envName,\n    const string& value,\n    const bool overwrite\n)\n{\n    const bool success =\n      ::SetEnvironmentVariable(envName.c_str(), value.c_str());\n    return success;\n}\n\n\nword hostName()\n{\n    const bool full = true;\n    const DWORD bufferSize = MAX_COMPUTERNAME_LENGTH + 1;\n    TCHAR buffer[bufferSize];\n    DWORD actualBufferSize = bufferSize;\n\n    const bool success =\n      ::GetComputerName(buffer, &actualBufferSize);\n    const string computerName = success ? buffer : string::null;\n    return computerName;\n}\n\n\nstring domainName()\n{\n    // Could use ::gethostname and ::gethostbyname like POSIX.C, but would\n    // then need to link against ws_32. Prefer to minimize dependencies.\n\n    return string::null;\n}\n\n\nword userName()\n{\n    std::string name = getEnv(\"USERNAME\");\n\n    if (name.empty())\n    {\n        name = MSwindows::getUserName();\n    }\n\n    return name;\n}\n\n\nbool isAdministrator()\n{\n    // Not supported but assume worst case for Foam::dynamicCode::checkSecurity\n    return true;\n}\n\n\nfileName home()\n{\n    std::string homeDir = getEnv(\"HOME\");\n\n    if (homeDir.empty())\n    {\n        homeDir = getEnv(\"USERPROFILE\");\n    }\n\n    return homeDir;\n}\n\n\nfileName home(const word& userName)\n{\n    return home();\n}\n\n\nfileName cwd()\n{\n    string currentDirectory;\n\n    const DWORD actualBufferSize =\n      ::GetCurrentDirectory(0, NULL);\n\n    if (0 < actualBufferSize)\n    {\n        MSwindows::AutoArray<TCHAR> actualBuffer(actualBufferSize);\n        ::GetCurrentDirectory(actualBufferSize,\n                              actualBuffer.get());\n        currentDirectory = actualBuffer.get();\n        MSwindows::toUnixSlash(currentDirectory);\n    }\n    else\n    {\n        FatalErrorIn(\"cwd()\")\n            << \"Couldn't get the current working directory\"\n            << exit(FatalError);\n    }\n\n    return currentDirectory;\n}\n\n\nbool chDir(const fileName& dir)\n{\n    const bool success = ::SetCurrentDirectory(dir.c_str());\n    return success;\n}\n\n\nfileNameList findEtcFiles\n(\n    const fileName& name,\n    bool mandatory,\n    bool findFirst\n)\n{\n    fileNameList results;\n/*\n    // Search for user files in\n    // * ~/.OpenFOAM/VERSION\n    // * ~/.OpenFOAM\n    //\n    fileName searchDir = home()/\".OpenFOAM\";\n    if (isDir(searchDir))\n    {\n        fileName fullName = searchDir/FOAMversion/name;\n        if (isFile(fullName))\n        {\n            results.append(fullName);\n            if (findFirst)\n            {\n                return results;\n            }\n        }\n\n        fullName = searchDir/name;\n        if (isFile(fullName))\n        {\n            results.append(fullName);\n            if (findFirst)\n            {\n                return results;\n            }\n        }\n    }\n\n    // Search for group (site) files in\n    // * $WM_PROJECT_SITE/VERSION\n    // * $WM_PROJECT_SITE\n    //\n    searchDir = getEnv(\"WM_PROJECT_SITE\");\n    if (searchDir.size())\n    {\n        if (isDir(searchDir))\n        {\n            fileName fullName = searchDir/FOAMversion/name;\n            if (isFile(fullName))\n            {\n                results.append(fullName);\n                if (findFirst)\n                {\n                    return results;\n                }\n            }\n\n            fullName = searchDir/name;\n            if (isFile(fullName))\n            {\n                results.append(fullName);\n                if (findFirst)\n                {\n                    return results;\n                }\n            }\n        }\n    }\n    else\n    {\n        // OR search for group (site) files in\n        // * $WM_PROJECT_INST_DIR/site/VERSION\n        // * $WM_PROJECT_INST_DIR/site\n        //\n        searchDir = getEnv(\"WM_PROJECT_INST_DIR\");\n        if (isDir(searchDir))\n        {\n            fileName fullName = searchDir/\"site\"/FOAMversion/name;\n            if (isFile(fullName))\n            {\n                results.append(fullName);\n                if (findFirst)\n                {\n                    return results;\n                }\n            }\n\n            fullName = searchDir/\"site\"/name;\n            if (isFile(fullName))\n            {\n                results.append(fullName);\n                if (findFirst)\n                {\n                    return results;\n                }\n            }\n        }\n    }\n\n    // Search for other (shipped) files in\n    // * $WM_PROJECT_DIR/etc\n    //\n    searchDir = getEnv(\"WM_PROJECT_DIR\");\n    if (isDir(searchDir))\n    {\n        fileName fullName = searchDir/\"etc\"/name;\n        if (isFile(fullName))\n        {\n            results.append(fullName);\n            if (findFirst)\n            {\n                return results;\n            }\n        }\n    }\n\n    // Not found\n    if (results.empty())\n    {\n        // Abort if the file is mandatory, otherwise return null\n        if (mandatory)\n        {\n            std::cerr\n                << \"--> FOAM FATAL ERROR in Foam::findEtcFiles() :\"\n                   \" could not find mandatory file\\n    '\"\n                << name.c_str() << \"'\\n\\n\" << std::endl;\n            ::exit(1);\n        }\n    }\n*/\n    // Return list of matching paths or empty list if none found\n    return results;\n}\n\n\nfileName findEtcFile(const fileName& name, bool mandatory)\n{\n    // Search most likely location first\n    // Search installation files:\n    // ~~~~~~~~~~~~~~~~~~~~~~~~~~\n    fileName searchDir = getEnv(\"WM_PROJECT_DIR\");\n    if (isDir(searchDir))\n    {\n        // Check for shipped OpenFOAM file in $WM_PROJECT_DIR/etc\n        fileName fullName = searchDir/\"etc\"/name;\n        if (isFile(fullName))\n        {\n            return fullName;\n        }\n    }\n\n    // Search user files:\n    // ~~~~~~~~~~~~~~~~~~\n    searchDir = home()/\".OpenFOAM\";\n    if (isDir(searchDir))\n    {\n        // Check for user file in ~/.OpenFOAM/VERSION\n        fileName fullName = searchDir/FOAMversion/name;\n        if (isFile(fullName))\n        {\n            return fullName;\n        }\n\n        // Check for version-independent user file in ~/.OpenFOAM\n        fullName = searchDir/name;\n        if (isFile(fullName))\n        {\n            return fullName;\n        }\n    }\n\n\n    // Search site files:\n    // ~~~~~~~~~~~~~~~~~~\n    searchDir = getEnv(\"WM_PROJECT_INST_DIR\");\n    if (isDir(searchDir))\n    {\n        // Check for site file in $WM_PROJECT_INST_DIR/site/VERSION\n        fileName fullName = searchDir/\"site\"/FOAMversion/name;\n        if (isFile(fullName))\n        {\n            return fullName;\n        }\n\n        // Check for version-independent site file in $WM_PROJECT_INST_DIR/site\n        fullName = searchDir/\"site\"/name;\n        if (isFile(fullName))\n        {\n            return fullName;\n        }\n    }\n\n    // Not found\n    // abort if the file is mandatory, otherwise return null\n    if (mandatory)\n    {\n        cerr<< \"--> FOAM FATAL ERROR in Foam::findEtcFile() :\"\n               \" could not find mandatory file\\n    '\"\n            << name.c_str() << \"'\\n\\n\" << std::endl;\n        ::exit(1);\n    }\n\n    // Return null-constructed fileName rather than fileName::null\n    // to avoid cyclic dependencies in the construction of globals\n    return fileName();\n}\n\n\nbool mkDir(const fileName& pathName, const mode_t mode)\n{\n    if (pathName.empty())\n    {\n        return false;\n    }\n\n\n    bool success = ::CreateDirectory(pathName.c_str(), NULL);\n\n    if (success)\n    {\n        chMod(pathName, mode);\n    }\n    else\n    {\n        const DWORD error = ::GetLastError();\n\n        switch (error)\n        {\n            case ERROR_ALREADY_EXISTS:\n            {\n                success = true;\n                break;\n            }\n            case ERROR_PATH_NOT_FOUND:\n            {\n                // Part of the path does not exist so try to create it\n                const fileName& parentName = pathName.path();\n\n                if (parentName.size() && mkDir(parentName, mode))\n                {\n                    success = mkDir(pathName, mode);\n                }\n\n                break;\n            }\n        }\n\n        if (!success)\n        {\n            FatalErrorIn(\"mkDir(const fileName&, mode_t)\")\n              << \"Couldn't create directory: \" << pathName\n              << \" \" << MSwindows::getLastError()\n              << exit(FatalError);\n        }\n    }\n\n    return success;\n}\n\n\n// Set the file mode\nbool chMod(const fileName& name, const mode_t m)\n{\n    const int success = _chmod(name.c_str(), m);\n    return success;\n}\n\n\n// Return the file mode\nmode_t mode(const fileName& name)\n{\n    fileStat fileStatus(name);\n\n    const mode_t m = fileStatus.isValid() ?\n      fileStatus.status().st_mode : 0;\n    return m;\n}\n\n\n// Return the file type: FILE or DIRECTORY\nfileName::Type type(const fileName& name)\n{\n    fileName::Type fileType = fileName::UNDEFINED;\n    const DWORD attrs = ::GetFileAttributes(name.c_str());\n\n    if (attrs != INVALID_FILE_ATTRIBUTES)\n    {\n        fileType = (attrs & FILE_ATTRIBUTE_DIRECTORY) ?\n        fileName::DIRECTORY :\n        fileName::FILE;\n    }\n\n    return fileType;\n}\n\n\nstatic\nbool\nisGzFile(const fileName& name)\n{\n    std::string gzName(name);\n    gzName += \".gz\";\n    const DWORD attrs = ::GetFileAttributes(gzName.c_str());\n    const bool success = (attrs != INVALID_FILE_ATTRIBUTES);\n\n    return success;\n}\n\n\n// Does the name exist in the filing system?\nbool exists(const fileName& name, const bool checkGzip)\n{\n    const DWORD attrs = ::GetFileAttributes(name.c_str());\n    const bool success = (attrs != INVALID_FILE_ATTRIBUTES) ||\n                         (checkGzip && isGzFile(name));\n\n    return success;\n}\n\n\n// Does the directory exist\nbool isDir(const fileName& name)\n{\n    const DWORD attrs = ::GetFileAttributes(name.c_str());\n    bool success = (attrs != INVALID_FILE_ATTRIBUTES) &&\n                   (attrs & FILE_ATTRIBUTE_DIRECTORY);\n\n    return success;\n}\n\n\n// Does the file exist\nbool isFile(const fileName& name, const bool checkGzip)\n{\n    const DWORD attrs = ::GetFileAttributes(name.c_str());\n    const bool success = ((attrs != INVALID_FILE_ATTRIBUTES) &&\n                         !(attrs & FILE_ATTRIBUTE_DIRECTORY)) ||\n                         (checkGzip && isGzFile(name));\n\n    return success;\n}\n\n\n// Return size of file\noff_t fileSize(const fileName& name)\n{\n    fileStat fileStatus(name);\n\n    const off_t fileSize = fileStatus.isValid() ?\n      fileStatus.status().st_size : -1;\n    return fileSize;\n}\n\n\n// Return time of last file modification\ntime_t lastModified(const fileName& name)\n{\n    fileStat fileStatus(name);\n\n    const time_t modifiedTime = fileStatus.isValid() ?\n      fileStatus.status().st_mtime : 0;\n    return modifiedTime;\n}\n\n\n// Read a directory and return the entries as a string list\nfileNameList readDir\n(\n    const fileName& directory,\n    const fileName::Type type,\n    const bool filtergz\n)\n{\n    // Initial filename list size\n    // also used as increment if initial size found to be insufficient\n    const int maxNnames = 100;\n\n    if (MSwindows::debug)\n    {\n        Info<< \"readDir(const fileName&, const fileType, const bool filtergz)\"\n            << \" : reading directory \" << directory << endl;\n    }\n\n    // Setup empty string list MAXTVALUES long\n    fileNameList dirEntries(maxNnames);\n\n    // Temporary variables and counters\n    label nEntries = 0;\n\n    MSwindows::DirectoryIterator dirIt(directory);\n\n    if (dirIt.isValid())\n    {\n        while (dirIt.hasNext())\n        {\n            const fileName & fName = dirIt.next();\n\n            // ignore files begining with ., i.e. '.', '..' and '.*'\n            if (fName.size() > 0 && fName[size_t(0)] != '.')\n            {\n                word fileNameExt = fName.ext();\n\n                if\n                (\n                    (type == fileName::DIRECTORY)\n                 ||\n                    (\n                        type == fileName::FILE\n                        && fName[fName.size()-1] != '~'\n                        && fileNameExt != \"bak\"\n                        && fileNameExt != \"BAK\"\n                        && fileNameExt != \"old\"\n                        && fileNameExt != \"save\"\n                    )\n                )\n                {\n                    if ((directory/fName).type() == type)\n                    {\n                        if (nEntries >= dirEntries.size())\n                        {\n                            dirEntries.setSize(dirEntries.size() + maxNnames);\n                        }\n\n                        if (filtergz && fileNameExt == \"gz\")\n                        {\n                            dirEntries[nEntries++] = fName.lessExt();\n                        }\n                        else\n                        {\n                            dirEntries[nEntries++] = fName;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    else if (MSwindows::debug)\n    {\n        Info<< \"readDir(const fileName&, const fileType, \"\n               \"const bool filtergz) : cannot open directory \"\n            << directory << endl;\n    }\n\n    // Reset the length of the entries list\n    dirEntries.setSize(nEntries);\n\n    return dirEntries;\n}\n\n\n// Copy, recursively if necessary, the source top the destination\nbool cp(const fileName& src, const fileName& dest)\n{\n    // Make sure source exists.\n    if (!exists(src))\n    {\n        return false;\n    }\n\n    fileName destFile(dest);\n\n    // Check type of source file.\n    if (src.type() == fileName::FILE)\n    {\n        // If dest is a directory, create the destination file name.\n        if (destFile.type() == fileName::DIRECTORY)\n        {\n            destFile = destFile/src.name();\n        }\n\n        // Make sure the destination directory exists.\n        if (!isDir(destFile.path()) && !mkDir(destFile.path()))\n        {\n            return false;\n        }\n\n        // Open and check streams.\n        // Use binary mode in case we read binary.\n        // Causes windows reading to fail if we don't.\n        std::ifstream srcStream(src.c_str(),\n                                ios_base::in|ios_base::binary);\n        if (!srcStream)\n        {\n            return false;\n        }\n\n        // Use binary mode in case we write binary.\n        // Causes windows reading to fail if we don't.\n        std::ofstream destStream(destFile.c_str(),\n                                 ios_base::out|ios_base::binary);\n        if (!destStream)\n        {\n            return false;\n        }\n\n        // Copy character data.\n        char ch;\n        while (srcStream.get(ch))\n        {\n            destStream.put(ch);\n        }\n\n        // Final check.\n        if (!srcStream.eof() || !destStream)\n        {\n            return false;\n        }\n    }\n    else if (src.type() == fileName::DIRECTORY)\n    {\n        // If dest is a directory, create the destination file name.\n        if (destFile.type() == fileName::DIRECTORY)\n        {\n            destFile = destFile/src.component(src.components().size() -1);\n        }\n\n        // Make sure the destination directory extists.\n        if (!isDir(destFile) && !mkDir(destFile))\n        {\n            return false;\n        }\n\n        // Copy files\n        fileNameList contents = readDir(src, fileName::FILE, false);\n        forAll(contents, i)\n        {\n            if (MSwindows::debug)\n            {\n                Info<< \"Copying : \" << src/contents[i]\n                    << \" to \" << destFile/contents[i] << endl;\n            }\n\n            // File to file.\n            cp(src/contents[i], destFile/contents[i]);\n        }\n\n        // Copy sub directories.\n        fileNameList subdirs = readDir(src, fileName::DIRECTORY);\n        forAll(subdirs, i)\n        {\n            if (MSwindows::debug)\n            {\n                Info<< \"Copying : \" << src/subdirs[i]\n                    << \" to \" << destFile << endl;\n            }\n\n            // Dir to Dir.\n            cp(src/subdirs[i], destFile);\n        }\n    }\n\n    return true;\n}\n\n\n// Create a softlink. destFile should not exist. Returns true if successful.\nbool ln(const fileName& src, const fileName& dest)\n{\n    // Seems that prior to Vista softlinking was poorly supported.\n    // Vista does a better job, but requires adminstrator privileges.\n    // Skip for now.\n\n    if (MSwindows::debug)\n    {\n        Info<< \"MSwindows does not support ln - softlinking\" << endl;\n    }\n\n    return false;\n}\n\n\n// Rename srcFile destFile\nbool mv(const fileName& srcFile, const fileName& destFile)\n{\n    if (MSwindows::debug)\n    {\n        Info<< \"Move : \" << srcFile << \" to \" << destFile << endl;\n    }\n\n    const fileName destName =\n      ((destFile.type() == fileName::DIRECTORY)\n       && (srcFile.type() != fileName::DIRECTORY)) ?\n      destFile/srcFile.name() :\n      destFile;\n\n    const bool success =\n      (0 == std::rename(srcFile.c_str(), destName.c_str()));\n\n    return success;\n}\n\n\n//- Rename to a corresponding backup file\n//  If the backup file already exists, attempt with \"01\" .. \"99\" index\nbool mvBak(const fileName& src, const std::string& ext)\n{\n    if (MSwindows::debug)\n    {\n        Info<< \"mvBak : \" << src << \" to extension \" << ext << endl;\n    }\n\n    if (exists(src, false))\n    {\n        const int maxIndex = 99;\n        char index[3];\n\n        for (int n = 0; n <= maxIndex; n++)\n        {\n            fileName dstName(src + \".\" + ext);\n            if (n)\n            {\n                sprintf(index, \"%02d\", n);\n                dstName += index;\n            }\n\n            // avoid overwriting existing files, except for the last\n            // possible index where we have no choice\n            if (!exists(dstName, false) || n == maxIndex)\n            {\n                return (0 == std::rename(src.c_str(), dstName.c_str()));\n            }\n\n        }\n    }\n\n    // fall-through: nothing to do\n    return false;\n}\n\n\n// Remove a file returning true if successful otherwise false\nbool rm(const fileName& file)\n{\n    if (MSwindows::debug)\n    {\n        Info<< \"Removing : \" << file << endl;\n    }\n\n    bool success = (0 == std::remove(file.c_str()));\n\n    // If deleting plain file name failed try with .gz\n    if (!success)\n    {\n        const std::string fileGz = file + \".gz\";\n        success = (0 == std::remove(fileGz.c_str()));\n    }\n\n    return success;\n}\n\n\n// Remove a dirctory and it's contents\nbool rmDir(const fileName& directory)\n{\n    if (MSwindows::debug)\n    {\n        Info<< \"rmdir(const fileName&) : \"\n            << \"removing directory \" << directory << endl;\n    }\n\n    bool success = true;\n\n    // Need to destroy DirectorIterator prior to\n    // removing directory otherwise fails on Windows XP\n    {\n      MSwindows::DirectoryIterator dirIt(directory);\n\n      while (success && dirIt.hasNext())\n      {\n          const fileName & fName = dirIt.next();\n\n          if (fName != \".\" && fName != \"..\")\n          {\n              fileName path = directory/fName;\n\n              if (path.type() == fileName::DIRECTORY)\n              {\n                  success = rmDir(path);\n\n                  if (!success)\n                  {\n                      WarningIn(\"rmdir(const fileName&)\")\n                        << \"failed to remove directory \" << fName\n                        << \" while removing directory \" << directory\n                        << endl;\n                  }\n              }\n              else\n              {\n                  success = rm(path);\n\n                  if (!success)\n                  {\n                      WarningIn(\"rmdir(const fileName&)\")\n                        << \"failed to remove file \" << fName\n                        << \" while removing directory \" << directory\n                        << endl;\n                  }\n              }\n          }\n      }\n    }\n\n    if (success)\n    {\n        success = ::RemoveDirectory(directory.c_str());\n\n        if (!success)\n        {\n            WarningIn(\"rmdir(const fileName&)\")\n                << \"failed to remove directory \" << directory << endl;\n        }\n    }\n\n    return success;\n}\n\n\n//- Sleep for the specified number of seconds\nunsigned int sleep(const unsigned int s)\n{\n    const DWORD milliseconds = s * 1000;\n\n    ::Sleep(milliseconds);\n\n    return 0;\n}\n\n\nvoid fdClose(const int fd)\n{\n    const int result = ::_close(fd);\n\n    if (0 != result)\n    {\n        FatalErrorIn\n        (\n            \"Foam::fdClose(const int fd)\"\n        )   << \"close error on \" << fd << endl\n            << abort(FatalError);\n    }\n}\n\n\n//- Check if machine is up by pinging given port\nbool ping\n(\n    const word& destName,\n    const label destPort,\n    const label timeOut\n)\n{\n    // Appears that socket calls require adminstrator privileges.\n    // Skip for now.\n\n    if (MSwindows::debug)\n    {\n        Info<< \"MSwindows does not support ping\" << endl;\n    }\n\n    return false;\n}\n\n\n//- Check if machine is up by ping port 22 = ssh and 222 = rsh\nbool ping(const word& hostname, const label timeOut)\n{\n    return ping(hostname, 222, timeOut) || ping(hostname, 22, timeOut);\n}\n\n\nint system(const string& command)\n{\n    return std::system(command.c_str());\n}\n\n\n// Explicitly track loaded libraries, rather than use\n// EnumerateLoadedModules64 and have to link against\n// Dbghelp.dll\n// Details at http://msdn.microsoft.com/en-us/library/ms679316(v=vs.85).aspx\ntypedef std::map<void*, std::string> OfLoadedLibs;\n\nstatic\nOfLoadedLibs &\ngetLoadedLibs()\n{\n  static OfLoadedLibs loadedLibs;\n  return loadedLibs;\n}\n\n\n//- Open shared library\nvoid* dlOpen(const fileName& libName, const bool check)\n{\n    if (MSwindows::debug)\n    {\n        Info<< \"dlOpen(const fileName&)\"\n            << \" : LoadLibrary of \" << libName << endl;\n    }\n\n    const char* dllExt = \".dll\";\n\n    // Assume libName is of the form, lib<name>.so\n    string winLibName(libName);\n    winLibName.replace(\".so\", dllExt);\n    void* handle = ::LoadLibrary(winLibName.c_str());\n\n    if (NULL == handle)\n    {\n        // Assumes libName = name\n        winLibName = \"lib\";\n        winLibName += libName;\n        winLibName += dllExt;\n\n        handle = ::LoadLibrary(winLibName.c_str());\n    }\n\n    if (NULL != handle)\n    {\n        getLoadedLibs()[handle] = libName;\n    }\n    else if (check)\n    {\n        WarningIn(\"dlOpen(const fileName&, const bool)\")\n            << \"dlopen error : \" << MSwindows::getLastError()\n            << endl;\n    }\n\n    if (MSwindows::debug)\n    {\n        Info<< \"dlOpen(const fileName&)\"\n            << \" : LoadLibrary of \" << libName\n            << \" handle \" << handle << endl;\n    }\n\n    return handle;\n}\n\n\n//- Close shared library\nbool dlClose(void* const handle)\n{\n    if (MSwindows::debug)\n    {\n        Info<< \"dlClose(void*)\"\n            << \" : FreeLibrary of handle \" << handle << endl;\n    }\n\n    const bool success =\n      ::FreeLibrary(static_cast<HMODULE>(handle));\n\n    if (success)\n    {\n        getLoadedLibs().erase(handle);\n    }\n\n    return success;\n}\n\n\nvoid* dlSym(void* handle, const std::string& symbol)\n{\n    if (MSwindows::debug)\n    {\n        Info<< \"dlSym(void*, const std::string&)\"\n            << \" : GetProcAddress of \" << symbol << endl;\n    }\n    // get address of symbol\n    void* fun = (void*) ::GetProcAddress(static_cast<HMODULE>(handle), symbol.c_str());\n\n    if (NULL == fun)\n    {\n        WarningIn(\"dlSym(void*, const std::string&)\")\n            << \"Cannot lookup symbol \" << symbol << \" : \" << MSwindows::getLastError()\n            << endl;\n    }\n\n    return fun;\n}\n\n\nbool dlSymFound(void* handle, const std::string& symbol)\n{\n    if (handle && !symbol.empty())\n    {\n        if (MSwindows::debug)\n        {\n            Info<< \"dlSymFound(void*, const std::string&)\"\n                << \" : GetProcAddress of \" << symbol << endl;\n        }\n\n        // get address of symbol\n        void* fun = (void*) ::GetProcAddress(static_cast<HMODULE>(handle), symbol.c_str());\n\n        return (NULL != fun);\n    }\n    else\n    {\n        return false;\n    }\n}\n\n\nfileNameList dlLoaded()\n{\n    fileNameList libs;\n    int counter(0);\n    OfLoadedLibs & loadedLibs = getLoadedLibs();\n\n    for\n    (\n        OfLoadedLibs::const_iterator it = loadedLibs.begin();\n        it != loadedLibs.end();\n        ++it\n    )\n    {\n        libs.newElmt(counter++) = it->second;\n    }\n\n    if (MSwindows::debug)\n    {\n        Info<< \"dlLoaded()\"\n            << \" : determined loaded libraries :\" << libs.size() << endl;\n    }\n    return libs;\n}\n\n\nvoid osRandomSeed(const label seed)\n{\n  std::srand(seed);\n}\n\n\nlabel osRandomInteger()\n{\n  return std::rand();\n}\n\n\nscalar osRandomDouble()\n{\n  return scalar(std::rand())/RAND_MAX;\n}\n\n} // namespace Foam\n// ************************************************************************* //\n",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/src/foam/db/dlLibraryTable/dlLibraryTable.C": "/*---------------------------------------------------------------------------*\\\n  =========                 |\n  \\\\      /  F ield         | foam-extend: Open Source CFD\n   \\\\    /   O peration     | Version:     3.2\n    \\\\  /    A nd           | Web:         http://www.foam-extend.org\n     \\\\/     M anipulation  | For copyright notice see file Copyright\n-------------------------------------------------------------------------------\nLicense\n    This file is part of foam-extend.\n\n    foam-extend is free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your\n    option) any later version.\n\n    foam-extend is distributed in the hope that it will be useful, but\n    WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with foam-extend.  If not, see <http://www.gnu.org/licenses/>.\n\n\\*---------------------------------------------------------------------------*/\n\n#include \"dlLibraryTable.H\"\n#include \"OSspecific.H\"\n\n#include <dlfcn.h>\n\n// * * * * * * * * * * * * * * Static Data Members * * * * * * * * * * * * * //\n\nFoam::dlLibraryTable Foam::dlLibraryTable::loadedLibraries;\n\n\n// * * * * * * * * * * * * * * * * Constructors  * * * * * * * * * * * * * * //\n\nFoam::dlLibraryTable::dlLibraryTable()\n:\n    HashTable<fileName, void*, Hash<void*> >()\n{}\n\n\nFoam::dlLibraryTable::readDlLibrary::readDlLibrary\n(\n    const dictionary& dict,\n    const word& libsEntry\n)\n{\n    open(dict, libsEntry);\n}\n\n\n// * * * * * * * * * * * * * * * * Destructor  * * * * * * * * * * * * * * * //\n\nFoam::dlLibraryTable::~dlLibraryTable()\n{\n    forAllIter(dlLibraryTable, *this, iter)\n    {\n        dlclose(iter.key());\n    }\n}\n\n\n// * * * * * * * * * * * * * * * Member Functions  * * * * * * * * * * * * * //\n\nbool Foam::dlLibraryTable::open(const fileName& functionLibName)\n{\n    if (functionLibName.size())\n    {\n        void* functionLibPtr =\n            dlopen(functionLibName.c_str(), RTLD_LAZY|RTLD_GLOBAL);\n\n#ifdef darwin\n        // If failing to load under OS X, let's try some obvious variations\n        // before giving up completely\n        fileName osxFileName(functionLibName);\n\n        if(!functionLibPtr && functionLibName.ext()==\"so\")\n        {\n            osxFileName=functionLibName.lessExt()+\".dylib\";\n\n            functionLibPtr =\n                dlopen(osxFileName.c_str(), RTLD_LAZY|RTLD_GLOBAL);\n        }\n\n        // If unsuccessful, which might be the case under Mac OSX 10.11 (El\n        // Capitan) with System Integrity Protection (SIP) enabled, let's try\n        // building a full path using well-known environment variables. This is\n        // the last resort, unless you provide the full pathname yourself.\n\tif (!functionLibPtr)\n\t{\n            fileName l_LIBBIN_Name =\n                getEnv(\"FOAM_LIBBIN\")/osxFileName;\n            functionLibPtr =\n                dlopen(l_LIBBIN_Name.c_str(), RTLD_LAZY|RTLD_GLOBAL);\n\t}\n\tif (!functionLibPtr)\n\t{\n            fileName l_SITE_LIBBIN_Name =\n                getEnv(\"FOAM_SITE_LIBBIN\")/osxFileName;\n            functionLibPtr =\n                dlopen(l_SITE_LIBBIN_Name.c_str(), RTLD_LAZY|RTLD_GLOBAL);\n\t}\n\tif (!functionLibPtr)\n\t{\n            fileName l_USER_LIBBIN_Name =\n                getEnv(\"FOAM_USER_LIBBIN\")/osxFileName;\n            functionLibPtr =\n                dlopen(l_USER_LIBBIN_Name.c_str(), RTLD_LAZY|RTLD_GLOBAL);\n\t}\n#elif defined mingw\n        if(!functionLibPtr && functionLibName.ext()==\"so\") {\n            fileName lName=functionLibName.lessExt()+\".dll\";\n            functionLibPtr =\n                dlopen(lName.c_str(), RTLD_LAZY|RTLD_GLOBAL);\n        }\n#endif\n        if (!functionLibPtr)\n        {\n            WarningIn\n            (\n                \"dlLibraryTable::open(const fileName& functionLibName)\"\n            )   << \"could not load \" << dlerror()\n                << endl;\n\n            return false;\n        }\n        else\n        {\n            if (!loadedLibraries.found(functionLibPtr))\n            {\n                loadedLibraries.insert(functionLibPtr, functionLibName);\n                return true;\n            }\n            else\n            {\n                return false;\n            }\n        }\n    }\n    else\n    {\n        return false;\n    }\n}\n\n\nbool Foam::dlLibraryTable::open\n(\n    const dictionary& dict,\n    const word& libsEntry\n)\n{\n    if (dict.found(libsEntry))\n    {\n        fileNameList libNames(dict.lookup(libsEntry));\n\n        bool allOpened = (libNames.size() > 0);\n\n        forAll(libNames, i)\n        {\n            allOpened = dlLibraryTable::open(libNames[i]) && allOpened;\n        }\n\n        return allOpened;\n    }\n    else\n    {\n        return false;\n    }\n}\n\n\n// ************************************************************************* //\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/applications/utilities/mesh/conversion/gmshToFoam/piece-extr-rec.msh.gz",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/applications/utilities/mesh/conversion/kivaToFoam/kiva3v-valves.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/applications/utilities/postProcessing/dataConversion/foamToTecplot360/tecio2009.zip",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/applications/utilities/postProcessing/dataConversion/foamToTecplot360/tecio/examples/ij_ordered/ij_ordered.plt",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/applications/utilities/postProcessing/dataConversion/foamToTecplot360/tecio/examples/text/text.plt",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/applications/utilities/postProcessing/dataConversion/foamToTecplot360/tecio/examples/pyramid/pyramid.plt",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/applications/utilities/postProcessing/dataConversion/foamToTecplot360/tecio/examples/faceneighbors/FaceNeighbors.plt",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/applications/utilities/postProcessing/dataConversion/foamToTecplot360/tecio/examples/multiplefiles/file1.plt",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/applications/utilities/postProcessing/dataConversion/foamToTecplot360/tecio/examples/multiplefiles/file2.plt",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/applications/utilities/postProcessing/dataConversion/foamToTecplot360/tecio/examples/arrow/Arrow.plt",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/applications/utilities/postProcessing/dataConversion/foamToTecplot360/tecio/examples/arrow/arrow.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/applications/utilities/postProcessing/dataConversion/foamToTecplot360/tecio/examples/octagon/Octagon.plt",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/applications/utilities/postProcessing/dataConversion/foamToTecplot360/tecio/examples/multiplepolygons/HexagonsAndOctagon.plt",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/applications/utilities/postProcessing/dataConversion/foamToTecplot360/tecio/examples/multiplepolygons/multiplepolygons.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/applications/utilities/postProcessing/dataConversion/foamToTecplot360/tecio/examples/squares/squares.plt",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/applications/solvers/multiphase/twoPhaseEulerFoam/interfacialModels/dragModels/dragModel/dragModel.H",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/src/transportModels/viscoelastic/viscoelasticLaws/DCPP/DCPP.H",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/.git/objects/pack/pack-fb82e6cdb0fc557db97ae6b5f595979571b0cb48.pack",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/.git/objects/pack/pack-fb82e6cdb0fc557db97ae6b5f595979571b0cb48.idx",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/vagrantSandbox/skel/.zshrc.local",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/vagrantSandbox/skel/.zshrc",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/tutorials/incompressible/simpleFoam/mixingPlaneDomADomB/constant/polyMesh/neighbour.gz",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/tutorials/incompressible/simpleFoam/mixingPlaneDomADomB/constant/polyMesh/faces.gz",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/tutorials/incompressible/simpleFoam/mixingPlaneDomADomB/constant/polyMesh/points.gz",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/tutorials/incompressible/simpleFoam/mixingPlaneDomADomB/constant/polyMesh/owner.gz",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/tutorials/incompressible/channelFoam/channel395/0/nuSgs.gz",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/tutorials/incompressible/channelFoam/channel395/0/p.gz",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/tutorials/incompressible/channelFoam/channel395/0/B.gz",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/tutorials/incompressible/channelFoam/channel395/0/nuTilda.gz",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/tutorials/incompressible/channelFoam/channel395/0/U.gz",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/tutorials/incompressible/channelFoam/channel395/0/k.gz",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/tutorials/surfaceTracking/bubbleInterTrackFoam/bubble2D_r0.75mm/constant/polyMesh/neighbour.gz",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/tutorials/surfaceTracking/bubbleInterTrackFoam/bubble2D_r0.75mm/constant/polyMesh/faces.gz",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/tutorials/surfaceTracking/bubbleInterTrackFoam/bubble2D_r0.75mm/constant/polyMesh/points.gz",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/tutorials/surfaceTracking/bubbleInterTrackFoam/bubble2D_r0.75mm/constant/polyMesh/owner.gz",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/tutorials/surfaceTracking/interTrackFoam/hydrofoil/constant/polyMesh/cells.gz",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/tutorials/surfaceTracking/interTrackFoam/hydrofoil/constant/polyMesh/neighbour.gz",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/tutorials/surfaceTracking/interTrackFoam/hydrofoil/constant/polyMesh/faces.gz",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/tutorials/surfaceTracking/interTrackFoam/hydrofoil/constant/polyMesh/points.gz",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/tutorials/surfaceTracking/interTrackFoam/hydrofoil/constant/polyMesh/owner.gz",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/tutorials/surfaceTracking/interTrackFoam/sloshing2D/constant/polyMesh/neighbour.gz",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/tutorials/surfaceTracking/interTrackFoam/sloshing2D/constant/polyMesh/faces.gz",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/tutorials/surfaceTracking/interTrackFoam/sloshing2D/constant/polyMesh/points.gz",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/tutorials/surfaceTracking/interTrackFoam/sloshing2D/constant/polyMesh/owner.gz",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/tutorials/solidMechanics/viscoElasticSolidFoam/compressionRelaxationTest/constant/polyMesh/boundary.gz",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/tutorials/solidMechanics/viscoElasticSolidFoam/compressionRelaxationTest/constant/polyMesh/zoneToPatchName.gz",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/tutorials/solidMechanics/elasticNonLinULSolidFoam/rotateSphereUL/constant/polyMesh/zoneToPatchName.gz",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/tutorials/multiphase/settlingFoam/tank3D/constant/polyMesh/cells.gz",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/tutorials/multiphase/settlingFoam/tank3D/constant/polyMesh/neighbour.gz",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/tutorials/multiphase/settlingFoam/tank3D/constant/polyMesh/faces.gz",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/tutorials/multiphase/settlingFoam/tank3D/constant/polyMesh/points.gz",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/tutorials/multiphase/settlingFoam/tank3D/constant/polyMesh/owner.gz",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/tutorials/compressible/dbnsTurbFoam/naca0012/naca0012.cas.gz",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/tutorials/compressible/sonicFoam/ras/nacaAirfoil/prostar/nacaAirfoil.vrt.gz",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/tutorials/compressible/sonicFoam/ras/nacaAirfoil/prostar/nacaAirfoil.bnd.gz",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/tutorials/compressible/sonicFoam/ras/nacaAirfoil/prostar/nacaAirfoil.cel.gz",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/tutorials/basic/laplacianFoam/Case1.1_mixingPlane_sector_AB_60deg/constant/cellToRegion.gz",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/tutorials/basic/laplacianFoam/Case1.1_mixingPlane_sector_AB_60deg/postProcessing/plotResiduals.gplt",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/ThirdParty/rpmBuild/SOURCES/ParaView-3.14.1.patch_0_ParaView.git_0f43430",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/doc/Doxygen/OpenSourceToolbox.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/doc/Doxygen/OpenSourceToolkit.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/doc/Doxygen/OpenFOAMlogo.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/doc/cfMesh/User Guide - cfMesh v1.0.1.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/doc/Guides-a4/ProgrammersGuide.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-foam-extend-3.2-noecw2jgbsfy3acacw4p3efwrfrrsl4o/spack-src/doc/Guides-a4/UserGuide.pdf"
    ],
    "total_files": 9709
}