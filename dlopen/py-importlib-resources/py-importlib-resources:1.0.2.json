{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-py-importlib-resources-1.0.2-yhll2jsd7iswnwx5cfv3fkrhzdwr2wwz/spack-src/importlib_resources/docs/using.rst": ".. _using:\n\n===========================\n Using importlib_resources\n===========================\n\n``importlib_resources`` is a library that leverages Python's import system to\nprovide access to *resources* within *packages*.  Given that this library is\nbuilt on top of the import system, it is highly efficient and easy to use.\nThis library's philosophy is that, if you can import a package, you can access\nresources within that package.  Resources can be opened or read, in either\nbinary or text mode.\n\nWhat exactly do we mean by \"a resource\"?  It's easiest to think about the\nmetaphor of files and directories on the file system, though it's important to\nkeep in mind that this is just a metaphor.  Resources and packages **do not**\nhave to exist as physical files and directories on the file system.\n\nIf you have a file system layout such as::\n\n    data/\n        __init__.py\n        one/\n            __init__.py\n            resource1.txt\n        two/\n            __init__.py\n            resource2.txt\n\nthen the directories are ``data``, ``data/one``, and ``data/two``.  Each of\nthese are also Python packages by virtue of the fact that they all contain\n``__init__.py`` files [#fn1]_.  That means that in Python, all of these import\nstatements work::\n\n    import data\n    import data.one\n    from data import two\n\nEach import statement gives you a Python *module* corresponding to the\n``__init__.py`` file in each of the respective directories.  These modules are\npackages since packages are just special module instances that have an\nadditional attribute, namely a ``__path__`` [#fn2]_.\n\nIn this analogy then, resources are just files within a package directory, so\n``data/one/resource1.txt`` and ``data/two/resource2.txt`` are both resources,\nas are the ``__init__.py`` files in all the directories.  However the package\ndirectories themselves are *not* resources; anything that contains other\nthings (i.e. directories) are not themselves resources.\n\nResources are always accessed relative to the package that they live in.  You\ncannot access a resource within a subdirectory inside a package.  This means\nthat ``resource1.txt`` is a resource within the ``data.one`` package, but\nneither ``resource2.txt`` nor ``two/resource2.txt`` are resources within the\n``data`` package.  If a directory isn't a package, it can't be imported and\nthus can't contain resources.\n\nEven when this hierarchical structure isn't represented by physical files and\ndirectories, the model still holds.  So zip files can contain packages and\nresources, as could databases or other storage medium.  In fact, while\n``importlib_resources`` supports physical file systems and zip files by\ndefault, anything that can be loaded with a Python import system `loader`_ can\nprovide resources, as long as the loader implements the `ResourceReader`_\nabstract base class.\n\n\nExample\n=======\n\nLet's say you are writing an email parsing library and in your test suite you\nhave a sample email message in a file called ``message.eml``.  You would like\nto access the contents of this file for your tests, so you put this in your\nproject under the ``email/tests/data/message.eml`` path.  Let's say your unit\ntests live in ``email/tests/test_email.py``.\n\nYour test could read the data file by doing something like::\n\n    data_dir = os.path.join(os.path.dirname(__file__), 'tests', 'data')\n    data_path = os.path.join(data_dir, 'message.eml')\n    with open(data_path, encoding='utf-8') as fp:\n        eml = fp.read()\n\nBut there's a problem with this!  The use of ``__file__`` doesn't work if your\npackage lives inside a zip file, since in that case this code does not live on\nthe file system.\n\nYou could use the `pkg_resources API`_ like so::\n\n    # In Python 3, resource_string() actually returns bytes!\n    from pkg_resources import resource_string as resource_bytes\n    eml = resource_bytes('email.tests.data', 'message.eml').decode('utf-8')\n\nThis requires you to make Python packages of both ``email/tests`` and\n``email/tests/data``, by placing an empty ``__init__.py`` files in each of\nthose directories.\n\n**This is a requirement for importlib_resources too!**\n\nThe problem with the ``pkg_resources`` approach is that, depending on the\nstructure of your package, ``pkg_resources`` can be very inefficient even to\njust import.  ``pkg_resources`` is a sort of grab-bag of APIs and\nfunctionalities, and to support all of this, it sometimes has to do a ton of\nwork at import time, e.g. to scan every package on your ``sys.path``.  This\ncan have a serious negative impact on things like command line startup time\nfor Python implement commands.\n\n``importlib_resources`` solves this by being built entirely on the back of the\nstdlib :py:mod:`importlib`.  By taking advantage of all the efficiencies in\nPython's import system, and the fact that it's built into Python, using\n``importlib_resources`` can be much more performant.  The equivalent code\nusing ``importlib_resources`` would look like::\n\n    from importlib_resources import read_text\n    # Reads contents with UTF-8 encoding and returns str.\n    eml = read_text('email.tests.data', 'message.eml')\n\n\nPackages or package names\n=========================\n\nAll of the ``importlib_resources`` APIs take a *package* as their first\nparameter, but this can either be a package name (as a ``str``) or an actual\nmodule object, though the module *must* be a package [#fn3]_.  If a string is\npassed in, it must name an importable Python package, and this is first\nimported.  Thus the above example could also be written as::\n\n    import email.tests.data\n    eml = read_text(email.tests.data, 'message.eml')\n\n\nFile system or zip file\n=======================\n\nIn general you never have to worry whether your package is on the file system\nor in a zip file, as the ``importlib_resources`` APIs hide those details from\nyou.  Sometimes though, you need a path to an actual file on the file system.\nFor example, some SSL APIs require a certificate file to be specified by a\nreal file system path, and C's ``dlopen()`` function also requires a real file\nsystem path.\n\nTo support this, ``importlib_resources`` provides an API that will extract the\nresource from a zip file to a temporary file, and return the file system path\nto this temporary file as a :py:class:`pathlib.Path` object.  In order to\nproperly clean up this temporary file, what's actually returned is a context\nmanager that you can use in a ``with``-statement::\n\n    from importlib_resources import path\n    with path(email.tests.data, 'message.eml') as eml:\n        third_party_api_requiring_file_system_path(eml)\n\nYou can use all the standard :py:mod:`contextlib` APIs to manage this context\nmanager.\n\n.. attention::\n\n   There is an odd interaction with Python 3.4, 3.5, and 3.6 regarding adding\n   zip or wheel file paths to ``sys.path``.  Due to limitations in `zipimport\n   <https://docs.python.org/3/library/zipimport.html>`_, which can't be\n   changed without breaking backward compatibility, you **must** use an\n   absolute path to the zip/wheel file.  If you use a relative path, you will\n   not be able to find resources inside these zip files.  E.g.:\n\n   **No**::\n\n       sys.path.append('relative/path/to/foo.whl')\n       resource_bytes('foo/data.dat')  # This will fail!\n\n   **Yes**::\n\n       sys.path.append(os.path.abspath('relative/path/to/foo.whl'))\n       resource_bytes('foo/data.dat')\n\nBoth relative and absolute paths work for Python 3.7 and newer.\n\n\n.. rubric:: Footnotes\n\n.. [#fn1] We're ignoring `PEP 420\n          <https://www.python.org/dev/peps/pep-0420/>`_ style namespace\n          packages, since ``importlib_resources`` does not support resources\n          within namespace packages.  Also, the example assumes that the\n          parent directory containing ``data/`` is on ``sys.path``.\n\n.. [#fn2] As of `PEP 451 <https://www.python.org/dev/peps/pep-0451/>`_ this\n          information is also available on the module's\n          ``__spec__.submodule_search_locations`` attribute, which will not be\n          ``None`` for packages.\n\n.. [#fn3] Specifically, this means that in Python 2, the module object must\n          have an ``__path__`` attribute, while in Python 3, the module's\n          ``__spec__.submodule_search_locations`` must not be ``None``.\n          Otherwise a ``TypeError`` is raised.\n\n\n.. _`pkg_resources API`: http://setuptools.readthedocs.io/en/latest/pkg_resources.html#basic-resource-access\n.. _`loader`: https://docs.python.org/3/reference/import.html#finders-and-loaders\n.. _`ResourceReader`: https://docs.python.org/3.7/library/importlib.html#importlib.abc.ResourceReader\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-py-importlib-resources-1.0.2-yhll2jsd7iswnwx5cfv3fkrhzdwr2wwz/spack-src/importlib_resources/tests/zipdata02/ziptestdata.zip",
        "/tmp/vanessa/spack-stage/spack-stage-py-importlib-resources-1.0.2-yhll2jsd7iswnwx5cfv3fkrhzdwr2wwz/spack-src/importlib_resources/tests/zipdata01/ziptestdata.zip",
        "/tmp/vanessa/spack-stage/spack-stage-py-importlib-resources-1.0.2-yhll2jsd7iswnwx5cfv3fkrhzdwr2wwz/spack-src/importlib_resources/tests/data01/utf-16.file"
    ],
    "total_files": 48
}