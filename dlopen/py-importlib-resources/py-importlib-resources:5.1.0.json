{
    "matches": {
        "/var/tmp/sochat1/spack-stage/spack-stage-py-importlib-resources-5.1.0-os7tmzevlxad6zifo4liqufszz6ceyl6/spack-src/docs/using.rst": ".. _using:\n\n===========================\n Using importlib_resources\n===========================\n\n``importlib_resources`` is a library that leverages Python's import system to\nprovide access to *resources* within *packages*.  Given that this library is\nbuilt on top of the import system, it is highly efficient and easy to use.\nThis library's philosophy is that, if you can import a package, you can access\nresources within that package.  Resources can be opened or read, in either\nbinary or text mode.\n\nWhat exactly do we mean by \"a resource\"?  It's easiest to think about the\nmetaphor of files and directories on the file system, though it's important to\nkeep in mind that this is just a metaphor.  Resources and packages **do not**\nhave to exist as physical files and directories on the file system.\n\nIf you have a file system layout such as::\n\n    data/\n        __init__.py\n        one/\n            __init__.py\n            resource1.txt\n            resources1/\n                resource1.1.txt\n        two/\n            __init__.py\n            resource2.txt\n\nthen the directories are ``data``, ``data/one``, and ``data/two``.  Each of\nthese are also Python packages by virtue of the fact that they all contain\n``__init__.py`` files [#fn1]_.  That means that in Python, all of these import\nstatements work::\n\n    import data\n    import data.one\n    from data import two\n\nEach import statement gives you a Python *module* corresponding to the\n``__init__.py`` file in each of the respective directories.  These modules are\npackages since packages are just special module instances that have an\nadditional attribute, namely a ``__path__`` [#fn2]_.\n\nIn this analogy then, resources are just files or directories contained in a\npackage directory, so\n``data/one/resource1.txt`` and ``data/two/resource2.txt`` are both resources,\nas are the ``__init__.py`` files in all the directories.\n\nResources are always accessed relative to the package that they live in.\n``resource1.txt`` and ``resources1/resource1.1.txt`` are resources within\nthe ``data.one`` package, and\n``two/resource2.txt`` is a resource within the\n``data`` package.\n\n\nExample\n=======\n\nLet's say you are writing an email parsing library and in your test suite you\nhave a sample email message in a file called ``message.eml``.  You would like\nto access the contents of this file for your tests, so you put this in your\nproject under the ``email/tests/data/message.eml`` path.  Let's say your unit\ntests live in ``email/tests/test_email.py``.\n\nYour test could read the data file by doing something like::\n\n    data_dir = os.path.join(os.path.dirname(__file__), 'tests', 'data')\n    data_path = os.path.join(data_dir, 'message.eml')\n    with open(data_path, encoding='utf-8') as fp:\n        eml = fp.read()\n\nBut there's a problem with this!  The use of ``__file__`` doesn't work if your\npackage lives inside a zip file, since in that case this code does not live on\nthe file system.\n\nYou could use the `pkg_resources API`_ like so::\n\n    # In Python 3, resource_string() actually returns bytes!\n    from pkg_resources import resource_string as resource_bytes\n    eml = resource_bytes('email.tests.data', 'message.eml').decode('utf-8')\n\nThis requires you to make Python packages of both ``email/tests`` and\n``email/tests/data``, by placing an empty ``__init__.py`` files in each of\nthose directories.\n\nThe problem with the ``pkg_resources`` approach is that, depending on the\npackages in your environment, ``pkg_resources`` can be expensive\njust to import.  This behavior\ncan have a serious negative impact on things like command line startup time\nfor Python implement commands.\n\n``importlib_resources`` solves this performance challenge by being built\nentirely on the back of the\nstdlib :py:mod:`importlib`.  By taking advantage of all the efficiencies in\nPython's import system, and the fact that it's built into Python, using\n``importlib_resources`` can be much more performant.  The equivalent code\nusing ``importlib_resources`` would look like::\n\n    from importlib_resources import files\n    # Reads contents with UTF-8 encoding and returns str.\n    eml = files('email.tests.data').joinpath('message.eml').read_text()\n\n\nPackages or package names\n=========================\n\nAll of the ``importlib_resources`` APIs take a *package* as their first\nparameter, but this can either be a package name (as a ``str``) or an actual\nmodule object, though the module *must* be a package [#fn3]_.  If a string is\npassed in, it must name an importable Python package, and this is first\nimported.  Thus the above example could also be written as::\n\n    import email.tests.data\n    eml = files(email.tests.data).joinpath('message.eml').read_text()\n\n\nFile system or zip file\n=======================\n\nIn general you never have to worry whether your package is on the file system\nor in a zip file, as the ``importlib_resources`` APIs hide those details from\nyou.  Sometimes though, you need a path to an actual file on the file system.\nFor example, some SSL APIs require a certificate file to be specified by a\nreal file system path, and C's ``dlopen()`` function also requires a real file\nsystem path.\n\nTo support this, ``importlib_resources`` provides an API that will extract the\nresource from a zip file to a temporary file, and return the file system path\nto this temporary file as a :py:class:`pathlib.Path` object.  In order to\nproperly clean up this temporary file, what's actually returned is a context\nmanager that you can use in a ``with``-statement::\n\n    from importlib_resources import files, as_file\n\n    source = files(email.tests.data).joinpath('message.eml')\n    with as_file(source) as eml:\n        third_party_api_requiring_file_system_path(eml)\n\nYou can use all the standard :py:mod:`contextlib` APIs to manage this context\nmanager.\n\n.. attention::\n\n   There is an odd interaction with Python 3.4, 3.5, and 3.6 regarding adding\n   zip or wheel file paths to ``sys.path``.  Due to limitations in `zipimport\n   <https://docs.python.org/3/library/zipimport.html>`_, which can't be\n   changed without breaking backward compatibility, you **must** use an\n   absolute path to the zip/wheel file.  If you use a relative path, you will\n   not be able to find resources inside these zip files.  E.g.:\n\n   **No**::\n\n       sys.path.append('relative/path/to/foo.whl')\n       files('foo')  # This will fail!\n\n   **Yes**::\n\n       sys.path.append(os.path.abspath('relative/path/to/foo.whl'))\n       files('foo')\n\nBoth relative and absolute paths work for Python 3.7 and newer.\n\n\nExtending\n=========\n\nStarting with Python 3.9 and ``importlib_resources`` 2.0, this package\nprovides an interface for non-standard loaders, such as those used by\nexecutable bundlers, to supply resources. These loaders should supply a\n``get_resource_reader`` method, which is passed a module name and\nshould return a ``TraversableResources`` instance.\n\n\n.. rubric:: Footnotes\n\n.. [#fn1] We're ignoring `PEP 420\n          <https://www.python.org/dev/peps/pep-0420/>`_ style namespace\n          packages, since ``importlib_resources`` does not support resources\n          within namespace packages.  Also, the example assumes that the\n          parent directory containing ``data/`` is on ``sys.path``.\n\n.. [#fn2] As of `PEP 451 <https://www.python.org/dev/peps/pep-0451/>`_ this\n          information is also available on the module's\n          ``__spec__.submodule_search_locations`` attribute, which will not be\n          ``None`` for packages.\n\n.. [#fn3] Specifically, this means that in Python 2, the module object must\n          have an ``__path__`` attribute, while in Python 3, the module's\n          ``__spec__.submodule_search_locations`` must not be ``None``.\n          Otherwise a ``TypeError`` is raised.\n\n\n.. _`pkg_resources API`: http://setuptools.readthedocs.io/en/latest/pkg_resources.html#basic-resource-access\n.. _`loader`: https://docs.python.org/3/reference/import.html#finders-and-loaders\n.. _`ResourceReader`: https://docs.python.org/3.7/library/importlib.html#importlib.abc.ResourceReader\n"
    },
    "skipped": [
        "/var/tmp/sochat1/spack-stage/spack-stage-py-importlib-resources-5.1.0-os7tmzevlxad6zifo4liqufszz6ceyl6/spack-src/importlib_resources/tests/zipdata02/ziptestdata.zip",
        "/var/tmp/sochat1/spack-stage/spack-stage-py-importlib-resources-5.1.0-os7tmzevlxad6zifo4liqufszz6ceyl6/spack-src/importlib_resources/tests/zipdata01/ziptestdata.zip",
        "/var/tmp/sochat1/spack-stage/spack-stage-py-importlib-resources-5.1.0-os7tmzevlxad6zifo4liqufszz6ceyl6/spack-src/importlib_resources/tests/namespacedata01/utf-16.file",
        "/var/tmp/sochat1/spack-stage/spack-stage-py-importlib-resources-5.1.0-os7tmzevlxad6zifo4liqufszz6ceyl6/spack-src/importlib_resources/tests/data01/utf-16.file"
    ],
    "total_files": 63
}