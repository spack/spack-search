{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/wsutil/filesystem.c": "/* filesystem.c\n * Filesystem utility routines\n *\n * Wireshark - Network traffic analyzer\n * By Gerald Combs <gerald@wireshark.org>\n * Copyright 1998 Gerald Combs\n *\n * SPDX-License-Identifier: GPL-2.0-or-later\n */\n\n#include <config.h>\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n\n#include <glib.h>\n\n#ifdef _WIN32\n#include <windows.h>\n#include <tchar.h>\n#include <shlobj.h>\n#include <wsutil/unicode-utils.h>\n#else /* _WIN32 */\n#ifdef __APPLE__\n#include <mach-o/dyld.h>\n#endif\n#ifdef __linux__\n#include <sys/utsname.h>\n#endif\n#ifdef __FreeBSD__\n#include <sys/types.h>\n#include <sys/sysctl.h>\n#endif\n#ifdef HAVE_DLGET\n#include <dlfcn.h>\n#endif\n#include <pwd.h>\n#endif /* _WIN32 */\n\n#include \"filesystem.h\"\n#include <wsutil/report_message.h>\n#include <wsutil/privileges.h>\n#include <wsutil/file_util.h>\n#include <wsutil/utf8_entities.h>\n\n#include <wiretap/wtap.h>   /* for WTAP_ERR_SHORT_WRITE */\n\n#define PROFILES_DIR    \"profiles\"\n#define PLUGINS_DIR_NAME    \"plugins\"\n#define PROFILES_INFO_NAME  \"profile_files.txt\"\n\n#define ENV_CONFIG_PATH_VAR  \"WIRESHARK_CONFIG_DIR\"\n\nchar *persconffile_dir = NULL;\nchar *datafile_dir = NULL;\nchar *persdatafile_dir = NULL;\nchar *persconfprofile = NULL;\n\nstatic gboolean do_store_persconffiles = FALSE;\nstatic GHashTable *profile_files = NULL;\n\n/*\n * Given a pathname, return a pointer to the last pathname separator\n * character in the pathname, or NULL if the pathname contains no\n * separators.\n */\nchar *\nfind_last_pathname_separator(const char *path)\n{\n    char *separator;\n\n#ifdef _WIN32\n    char c;\n\n    /*\n     * We have to scan for '\\' or '/'.\n     * Get to the end of the string.\n     */\n    separator = strchr(path, '\\0');     /* points to ending '\\0' */\n    while (separator > path) {\n        c = *--separator;\n        if (c == '\\\\' || c == '/')\n            return separator;   /* found it */\n    }\n\n    /*\n     * OK, we didn't find any, so no directories - but there might\n     * be a drive letter....\n     */\n    return strchr(path, ':');\n#else\n    separator = strrchr(path, '/');\n    return separator;\n#endif\n}\n\n/*\n * Given a pathname, return the last component.\n */\nconst char *\nget_basename(const char *path)\n{\n    const char *filename;\n\n    g_assert(path != NULL);\n    filename = find_last_pathname_separator(path);\n    if (filename == NULL) {\n        /*\n         * There're no directories, drive letters, etc. in the\n         * name; the pathname *is* the file name.\n         */\n        filename = path;\n    } else {\n        /*\n         * Skip past the pathname or drive letter separator.\n         */\n        filename++;\n    }\n    return filename;\n}\n\n/*\n * Given a pathname, return a string containing everything but the\n * last component.  NOTE: this overwrites the pathname handed into\n * it....\n */\nchar *\nget_dirname(char *path)\n{\n    char *separator;\n\n    g_assert(path != NULL);\n    separator = find_last_pathname_separator(path);\n    if (separator == NULL) {\n        /*\n         * There're no directories, drive letters, etc. in the\n         * name; there is no directory path to return.\n         */\n        return NULL;\n    }\n\n    /*\n     * Get rid of the last pathname separator and the final file\n     * name following it.\n     */\n    *separator = '\\0';\n\n    /*\n     * \"path\" now contains the pathname of the directory containing\n     * the file/directory to which it referred.\n     */\n    return path;\n}\n\n/*\n * Given a pathname, return:\n *\n *  the errno, if an attempt to \"stat()\" the file fails;\n *\n *  EISDIR, if the attempt succeeded and the file turned out\n *  to be a directory;\n *\n *  0, if the attempt succeeded and the file turned out not\n *  to be a directory.\n */\n\nint\ntest_for_directory(const char *path)\n{\n    ws_statb64 statb;\n\n    if (ws_stat64(path, &statb) < 0)\n        return errno;\n\n    if (S_ISDIR(statb.st_mode))\n        return EISDIR;\n    else\n        return 0;\n}\n\nint\ntest_for_fifo(const char *path)\n{\n    ws_statb64 statb;\n\n    if (ws_stat64(path, &statb) < 0)\n        return errno;\n\n    if (S_ISFIFO(statb.st_mode))\n        return ESPIPE;\n    else\n        return 0;\n}\n\n/*\n * Directory from which the executable came.\n */\nstatic char *progfile_dir;\n\n#ifdef __APPLE__\n/*\n * Directory of the application bundle in which we're contained,\n * if we're contained in an application bundle.  Otherwise, NULL.\n *\n * Note: Table 2-5 \"Subdirectories of the Contents directory\" of\n *\n *    https://developer.apple.com/library/mac/documentation/CoreFoundation/Conceptual/CFBundles/BundleTypes/BundleTypes.html#//apple_ref/doc/uid/10000123i-CH101-SW1\n *\n * says that the \"Frameworks\" directory\n *\n *    Contains any private shared libraries and frameworks used by the\n *    executable.  The frameworks in this directory are revision-locked\n *    to the application and cannot be superseded by any other, even\n *    newer, versions that may be available to the operating system.  In\n *    other words, the frameworks included in this directory take precedence\n *    over any other similarly named frameworks found in other parts of\n *    the operating system.  For information on how to add private\n *    frameworks to your application bundle, see Framework Programming Guide.\n *\n * so if we were to ship with any frameworks (e.g. Qt) we should\n * perhaps put them in a Frameworks directory rather than under\n * Resources.\n *\n * It also says that the \"PlugIns\" directory\n *\n *    Contains loadable bundles that extend the basic features of your\n *    application. You use this directory to include code modules that\n *    must be loaded into your applicationbs process space in order to\n *    be used. You would not use this directory to store standalone\n *    executables.\n *\n * Our plugins are just raw .so/.dylib files; I don't know whether by\n * \"bundles\" they mean application bundles (i.e., directory hierarchies)\n * or just \"bundles\" in the Mach-O sense (which are an image type that\n * can be loaded with dlopen() but not linked as libraries; our plugins\n * are, I think, built as dylibs and can be loaded either way).\n *\n * And it says that the \"SharedSupport\" directory\n *\n *    Contains additional non-critical resources that do not impact the\n *    ability of the application to run. You might use this directory to\n *    include things like document templates, clip art, and tutorials\n *    that your application expects to be present but that do not affect\n *    the ability of your application to run.\n *\n * I don't think I'd put the files that currently go under Resources/share\n * into that category; they're not, for example, sample Lua scripts that\n * don't actually get run by Wireshark, they're configuration/data files\n * for Wireshark whose absence might not prevent Wireshark from running\n * but that would affect how it behaves when run.\n */\nstatic char *appbundle_dir;\n#endif\n\n/*\n * TRUE if we're running from the build directory and we aren't running\n * with special privileges.\n */\nstatic gboolean running_in_build_directory_flag = FALSE;\n\n#ifndef _WIN32\n/*\n * Get the pathname of the executable using various platform-\n * dependent mechanisms for various UN*Xes.\n *\n * These calls all should return something independent of the argv[0]\n * passed to the program, so it shouldn't be fooled by an argv[0]\n * that doesn't match the executable path.\n *\n * We don't use dladdr() because:\n *\n *   not all UN*Xes necessarily have dladdr();\n *\n *   those that do have it don't necessarily have dladdr(main)\n *   return information about the executable image;\n *\n *   those that do have a dladdr() where dladdr(main) returns\n *   information about the executable image don't necessarily\n *   have a mechanism by which the executable image can get\n *   its own path from the kernel (either by a call or by it\n *   being handed to it along with argv[] and the environment),\n *   so they just fall back on getting it from argv[0], which we\n *   already have code to do;\n *\n *   those that do have such a mechanism don't necessarily use\n *   it in dladdr(), and, instead, just fall back on getting it\n *   from argv[0];\n *\n * so the only places where it's worth bothering to use dladdr()\n * are platforms where dladdr(main) return information about the\n * executable image by getting it from the kernel rather than\n * by looking at argv[0], and where we can't get at that information\n * ourselves, and we haven't seen any indication that there are any\n * such platforms.\n *\n * In particular, some dynamic linkers supply a dladdr() such that\n * dladdr(main) just returns something derived from argv[0], so\n * just using dladdr(main) is the wrong thing to do if there's\n * another mechanism that can get you a more reliable version of\n * the executable path.\n *\n * So, on platforms where we know of a mechanism to get that path\n * (where getting that path doesn't involve argv[0], which is not\n * guaranteed to reflect the path to the binary), this routine\n * attempsts to use that platform's mechanism.  On other platforms,\n * it just returns NULL.\n *\n * This is not guaranteed to return an absolute path; if it doesn't,\n * our caller must prepend the current directory if it's a path.\n *\n * This is not guaranteed to return the \"real path\"; it might return\n * something with symbolic links in the path.  Our caller must\n * use realpath() if they want the real thing, but that's also true of\n * something obtained by looking at argv[0].\n */\nstatic const char *\nget_executable_path(void)\n{\n#if defined(__APPLE__)\n    char *executable_path;\n    uint32_t path_buf_size;\n\n    path_buf_size = PATH_MAX;\n    executable_path = (char *)g_malloc(path_buf_size);\n    if (_NSGetExecutablePath(executable_path, &path_buf_size) == -1) {\n        executable_path = (char *)g_realloc(executable_path, path_buf_size);\n        if (_NSGetExecutablePath(executable_path, &path_buf_size) == -1)\n            return NULL;\n    }\n    return executable_path;\n#elif defined(__linux__)\n    /*\n     * In older versions of GNU libc's dynamic linker, as used on Linux,\n     * dladdr(main) supplies a path based on argv[0], so we use\n     * /proc/self/exe instead; there are Linux distributions with\n     * kernels that support /proc/self/exe and those older versions\n     * of the dynamic linker, and this will get a better answer on\n     * those versions.\n     *\n     * It only works on Linux 2.2 or later, so we just give up on\n     * earlier versions.\n     *\n     * XXX - are there OS versions that support \"exe\" but not \"self\"?\n     */\n    struct utsname name;\n    static char executable_path[PATH_MAX + 1];\n    ssize_t r;\n\n    if (uname(&name) == -1)\n        return NULL;\n    if (strncmp(name.release, \"1.\", 2) == 0)\n        return NULL; /* Linux 1.x */\n    if (strcmp(name.release, \"2.0\") == 0 ||\n        strncmp(name.release, \"2.0.\", 4) == 0 ||\n        strcmp(name.release, \"2.1\") == 0 ||\n        strncmp(name.release, \"2.1.\", 4) == 0)\n        return NULL; /* Linux 2.0.x or 2.1.x */\n    if ((r = readlink(\"/proc/self/exe\", executable_path, PATH_MAX)) == -1)\n        return NULL;\n    executable_path[r] = '\\0';\n    return executable_path;\n#elif defined(__FreeBSD__) && defined(KERN_PROC_PATHNAME)\n    /*\n     * In older versions of FreeBSD's dynamic linker, dladdr(main)\n     * supplies a path based on argv[0], so we use the KERN_PROC_PATHNAME\n     * sysctl instead; there are, I think, versions of FreeBSD\n     * that support the sysctl that have and those older versions\n     * of the dynamic linker, and this will get a better answer on\n     * those versions.\n     */\n    int mib[4];\n    char *executable_path;\n    size_t path_buf_size;\n\n    mib[0] = CTL_KERN;\n    mib[1] = KERN_PROC;\n    mib[2] = KERN_PROC_PATHNAME;\n    mib[3] = -1;\n    path_buf_size = PATH_MAX;\n    executable_path = (char *)g_malloc(path_buf_size);\n    if (sysctl(mib, 4, executable_path, &path_buf_size, NULL, 0) == -1) {\n        if (errno != ENOMEM)\n            return NULL;\n        executable_path = (char *)g_realloc(executable_path, path_buf_size);\n        if (sysctl(mib, 4, executable_path, &path_buf_size, NULL, 0) == -1)\n            return NULL;\n    }\n    return executable_path;\n#elif defined(__NetBSD__)\n    /*\n     * In all versions of NetBSD's dynamic linker as of 2013-08-12,\n     * dladdr(main) supplies a path based on argv[0], so we use\n     * /proc/curproc/exe instead.\n     *\n     * XXX - are there OS versions that support \"exe\" but not \"curproc\"\n     * or \"self\"?  Are there any that support \"self\" but not \"curproc\"?\n     */\n    static char executable_path[PATH_MAX + 1];\n    ssize_t r;\n\n    if ((r = readlink(\"/proc/curproc/exe\", executable_path, PATH_MAX)) == -1)\n        return NULL;\n    executable_path[r] = '\\0';\n    return executable_path;\n#elif defined(__DragonFly__)\n    /*\n     * In older versions of DragonFly BSD's dynamic linker, dladdr(main)\n     * supplies a path based on argv[0], so we use /proc/curproc/file\n     * instead; it appears to be supported by all versions of DragonFly\n     * BSD.\n     */\n    static char executable_path[PATH_MAX + 1];\n    ssize_t r;\n\n    if ((r = readlink(\"/proc/curproc/file\", executable_path, PATH_MAX)) == -1)\n        return NULL;\n    executable_path[r] = '\\0';\n    return executable_path;\n#elif defined(HAVE_GETEXECNAME)\n    /*\n     * Solaris, with getexecname().\n     * It appears that getexecname() dates back to at least Solaris 8,\n     * but /proc/{pid}/path is first documented in the Solaris 10 documentation,\n     * so we use getexecname() if available, rather than /proc/self/path/a.out\n     * (which isn't documented, but appears to be a symlink to the\n     * executable image file).\n     */\n    return getexecname();\n#elif defined(HAVE_DLGET)\n    /*\n     * HP-UX 11, with dlget(); use dlget() and dlgetname().\n     * See\n     *\n     *  https://web.archive.org/web/20081025174755/http://h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801?ciid=88086d6e1de021106d6e1de02110275d6e10RCRD#two\n     */\n    struct load_module_desc desc;\n\n    if (dlget(-2, &desc, sizeof(desc)) != NULL)\n        return dlgetname(&desc, sizeof(desc), NULL, NULL, NULL);\n    else\n        return NULL;\n#else\n    /* Fill in your favorite UN*X's code here, if there is something */\n    return NULL;\n#endif\n}\n#endif /* _WIN32 */\n\n/*\n * Get the pathname of the directory from which the executable came,\n * and save it for future use.  Returns NULL on success, and a\n * g_mallocated string containing an error on failure.\n */\nchar *\ninit_progfile_dir(const char *arg0\n#ifdef _WIN32\n    _U_\n#endif\n)\n{\n#ifdef _WIN32\n    TCHAR prog_pathname_w[_MAX_PATH+2];\n    char *prog_pathname;\n    DWORD error;\n    TCHAR *msg_w;\n    guchar *msg;\n    size_t msglen;\n\n    /*\n     * Attempt to get the full pathname of the currently running\n     * program.\n     */\n    if (GetModuleFileName(NULL, prog_pathname_w, G_N_ELEMENTS(prog_pathname_w)) != 0 && GetLastError() != ERROR_INSUFFICIENT_BUFFER) {\n        /*\n         * XXX - Should we use g_utf16_to_utf8()?\n         */\n        prog_pathname = utf_16to8(prog_pathname_w);\n        /*\n         * We got it; strip off the last component, which would be\n         * the file name of the executable, giving us the pathname\n         * of the directory where the executable resides.\n         */\n        progfile_dir = g_path_get_dirname(prog_pathname);\n        if (progfile_dir != NULL) {\n            return NULL;    /* we succeeded */\n        } else {\n            /*\n             * OK, no. What do we do now?\n             */\n            return g_strdup_printf(\"No \\\\ in executable pathname \\\"%s\\\"\",\n                prog_pathname);\n        }\n    } else {\n        /*\n         * Oh, well.  Return an indication of the error.\n         */\n        error = GetLastError();\n        if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_SYSTEM|FORMAT_MESSAGE_IGNORE_INSERTS,\n            NULL, error, 0, (LPTSTR) &msg_w, 0, NULL) == 0) {\n            /*\n             * Gak.  We can't format the message.\n             */\n            return g_strdup_printf(\"GetModuleFileName failed: %u (FormatMessage failed: %u)\",\n                error, GetLastError());\n        }\n        msg = utf_16to8(msg_w);\n        LocalFree(msg_w);\n        /*\n         * \"FormatMessage()\" \"helpfully\" sticks CR/LF at the\n         * end of the message.  Get rid of it.\n         */\n        msglen = strlen(msg);\n        if (msglen >= 2) {\n            msg[msglen - 1] = '\\0';\n            msg[msglen - 2] = '\\0';\n        }\n        return g_strdup_printf(\"GetModuleFileName failed: %s (%u)\",\n            msg, error);\n    }\n#else\n    const char *execname;\n    char *prog_pathname;\n    char *curdir;\n    long path_max;\n    const char *pathstr;\n    const char *path_start, *path_end;\n    size_t path_component_len, path_len;\n    char *retstr;\n    char *path;\n    char *dir_end;\n\n    /*\n     * Check whether WIRESHARK_RUN_FROM_BUILD_DIRECTORY is set in the\n     * environment; if so, set running_in_build_directory_flag if we\n     * weren't started with special privileges.  (If we were started\n     * with special privileges, it's not safe to allow the user to point\n     * us to some other directory; running_in_build_directory_flag, when\n     * set, causes us to look for plugins and the like in the build\n     * directory.)\n     */\n    if (g_getenv(\"WIRESHARK_RUN_FROM_BUILD_DIRECTORY\") != NULL\n        && !started_with_special_privs())\n        running_in_build_directory_flag = TRUE;\n\n    execname = get_executable_path();\n    if (execname == NULL) {\n        /*\n         * OK, guess based on argv[0].\n         */\n        execname = arg0;\n    }\n\n    /*\n     * Try to figure out the directory in which the currently running\n     * program resides, given something purporting to be the executable\n     * name (from an OS mechanism or from the argv[0] it was started with).\n     * That might be the absolute path of the program, or a path relative\n     * to the current directory of the process that started it, or\n     * just a name for the program if it was started from the command\n     * line and was searched for in $PATH.  It's not guaranteed to be\n     * any of those, however, so there are no guarantees....\n     */\n    if (execname[0] == '/') {\n        /*\n         * It's an absolute path.\n         */\n        prog_pathname = g_strdup(execname);\n    } else if (strchr(execname, '/') != NULL) {\n        /*\n         * It's a relative path, with a directory in it.\n         * Get the current directory, and combine it\n         * with that directory.\n         */\n        path_max = pathconf(\".\", _PC_PATH_MAX);\n        if (path_max == -1) {\n            /*\n             * We have no idea how big a buffer to\n             * allocate for the current directory.\n             */\n            return g_strdup_printf(\"pathconf failed: %s\\n\",\n                g_strerror(errno));\n        }\n        curdir = (char *)g_malloc(path_max);\n        if (getcwd(curdir, path_max) == NULL) {\n            /*\n             * It failed - give up, and just stick\n             * with DATA_DIR.\n             */\n            g_free(curdir);\n            return g_strdup_printf(\"getcwd failed: %s\\n\",\n                g_strerror(errno));\n        }\n        path = g_strdup_printf(\"%s/%s\", curdir, execname);\n        g_free(curdir);\n        prog_pathname = path;\n    } else {\n        /*\n         * It's just a file name.\n         * Search the path for a file with that name\n         * that's executable.\n         */\n        prog_pathname = NULL;   /* haven't found it yet */\n        pathstr = g_getenv(\"PATH\");\n        path_start = pathstr;\n        if (path_start != NULL) {\n            while (*path_start != '\\0') {\n                path_end = strchr(path_start, ':');\n                if (path_end == NULL)\n                    path_end = path_start + strlen(path_start);\n                path_component_len = path_end - path_start;\n                path_len = path_component_len + 1\n                    + strlen(execname) + 1;\n                path = (char *)g_malloc(path_len);\n                memcpy(path, path_start, path_component_len);\n                path[path_component_len] = '\\0';\n                g_strlcat(path, \"/\", path_len);\n                g_strlcat(path, execname, path_len);\n                if (access(path, X_OK) == 0) {\n                    /*\n                     * Found it!\n                     */\n                    prog_pathname = path;\n                    break;\n                }\n\n                /*\n                 * That's not it.  If there are more\n                 * path components to test, try them.\n                 */\n                if (*path_end == ':')\n                    path_end++;\n                path_start = path_end;\n                g_free(path);\n            }\n            if (prog_pathname == NULL) {\n                /*\n                 * Program not found in path.\n                 */\n                return g_strdup_printf(\"\\\"%s\\\" not found in \\\"%s\\\"\",\n                    execname, pathstr);\n            }\n        } else {\n            /*\n             * PATH isn't set.\n             * XXX - should we pick a default?\n             */\n            return g_strdup(\"PATH isn't set\");\n        }\n    }\n\n    /*\n     * OK, we have what we think is the pathname\n     * of the program.\n     *\n     * First, find the last \"/\" in the directory,\n     * as that marks the end of the directory pathname.\n     */\n    dir_end = strrchr(prog_pathname, '/');\n    if (dir_end != NULL) {\n        /*\n         * Found it.  Strip off the last component,\n         * as that's the path of the program.\n         */\n        *dir_end = '\\0';\n\n        /*\n         * Is there a \"/run\" at the end?\n         */\n        dir_end = strrchr(prog_pathname, '/');\n        if (dir_end != NULL) {\n            if (!started_with_special_privs()) {\n                /*\n                 * Check for the CMake output directory. As people may name\n                 * their directories \"run\" (really?), also check for the\n                 * CMakeCache.txt file before assuming a CMake output dir.\n                 */\n                if (strcmp(dir_end, \"/run\") == 0) {\n                    gchar *cmake_file;\n                    cmake_file = g_strdup_printf(\"%.*s/CMakeCache.txt\",\n                                                 (int)(dir_end - prog_pathname),\n                                                 prog_pathname);\n                    if (file_exists(cmake_file))\n                        running_in_build_directory_flag = TRUE;\n                    g_free(cmake_file);\n                }\n#ifdef __APPLE__\n                {\n                    /*\n                     * Scan up the path looking for a component\n                     * named \"Contents\".  If we find it, we assume\n                     * we're in a bundle, and that the top-level\n                     * directory of the bundle is the one containing\n                     * \"Contents\".\n                     *\n                     * Not all executables are in the Contents/MacOS\n                     * directory, so we can't just check for those\n                     * in the path and strip them off.\n                     *\n                     * XXX - should we assume that it's either\n                     * Contents/MacOS or Resources/bin?\n                     */\n                    char *component_end, *p;\n\n                    component_end = strchr(prog_pathname, '\\0');\n                    p = component_end;\n                    for (;;) {\n                        while (p >= prog_pathname && *p != '/')\n                            p--;\n                        if (p == prog_pathname) {\n                            /*\n                             * We're looking at the first component of\n                             * the pathname now, so we're definitely\n                             * not in a bundle, even if we're in\n                             * \"/Contents\".\n                             */\n                            break;\n                        }\n                        if (strncmp(p, \"/Contents\", component_end - p) == 0) {\n                            /* Found it. */\n                            appbundle_dir = (char *)g_malloc(p - prog_pathname + 1);\n                            memcpy(appbundle_dir, prog_pathname, p - prog_pathname);\n                            appbundle_dir[p - prog_pathname] = '\\0';\n                            break;\n                        }\n                        component_end = p;\n                        p--;\n                    }\n                }\n#endif\n            }\n        }\n\n        /*\n         * OK, we have the path we want.\n         */\n        progfile_dir = prog_pathname;\n        return NULL;\n    } else {\n        /*\n         * This \"shouldn't happen\"; we apparently\n         * have no \"/\" in the pathname.\n         * Just free up prog_pathname.\n         */\n        retstr = g_strdup_printf(\"No / found in \\\"%s\\\"\", prog_pathname);\n        g_free(prog_pathname);\n        return retstr;\n    }\n#endif\n}\n\n/*\n * Get the directory in which the program resides.\n */\nconst char *\nget_progfile_dir(void)\n{\n    return progfile_dir;\n}\n\n/*\n * Get the directory in which the global configuration and data files are\n * stored.\n *\n * On Windows, we use the directory in which the executable for this\n * process resides.\n *\n * On macOS (when executed from an app bundle), use a directory within\n * that app bundle.\n *\n * Otherwise, if the program was executed from the build directory, use the\n * directory in which the executable for this process resides. In all other\n * cases, use the DATA_DIR value that was set at compile time.\n *\n * XXX - if we ever make libwireshark a real library, used by multiple\n * applications (more than just TShark and versions of Wireshark with\n * various UIs), should the configuration files belong to the library\n * (and be shared by all those applications) or to the applications?\n *\n * If they belong to the library, that could be done on UNIX by the\n * configure script, but it's trickier on Windows, as you can't just\n * use the pathname of the executable.\n *\n * If they belong to the application, that could be done on Windows\n * by using the pathname of the executable, but we'd have to have it\n * passed in as an argument, in some call, on UNIX.\n *\n * Note that some of those configuration files might be used by code in\n * libwireshark, some of them might be used by dissectors (would they\n * belong to libwireshark, the application, or a separate library?),\n * and some of them might be used by other code (the Wireshark preferences\n * file includes resolver preferences that control the behavior of code\n * in libwireshark, dissector preferences, and UI preferences, for\n * example).\n */\nconst char *\nget_datafile_dir(void)\n{\n    if (datafile_dir != NULL)\n        return datafile_dir;\n\n#ifdef _WIN32\n    /*\n     * Do we have the pathname of the program?  If so, assume we're\n     * running an installed version of the program.  If we fail,\n     * we don't change \"datafile_dir\", and thus end up using the\n     * default.\n     *\n     * XXX - does NSIS put the installation directory into\n     * \"\\HKEY_LOCAL_MACHINE\\SOFTWARE\\Wireshark\\InstallDir\"?\n     * If so, perhaps we should read that from the registry,\n     * instead.\n     */\n    if (progfile_dir != NULL) {\n        /*\n         * Yes, we do; use that.\n         */\n        datafile_dir = g_strdup(progfile_dir);\n    } else {\n        /*\n         * No, we don't.\n         * Fall back on the default installation directory.\n         */\n        datafile_dir = g_strdup(\"C:\\\\Program Files\\\\Wireshark\\\\\");\n    }\n#else\n\n    if (g_getenv(\"WIRESHARK_DATA_DIR\") && !started_with_special_privs()) {\n        /*\n         * The user specified a different directory for data files\n         * and we aren't running with special privileges.\n         * XXX - We might be able to dispense with the priv check\n         */\n        datafile_dir = g_strdup(g_getenv(\"WIRESHARK_DATA_DIR\"));\n    }\n#ifdef __APPLE__\n    /*\n     * If we're running from an app bundle and weren't started\n     * with special privileges, use the Contents/Resources/share/wireshark\n     * subdirectory of the app bundle.\n     *\n     * (appbundle_dir is not set to a non-null value if we're\n     * started with special privileges, so we need only check\n     * it; we don't need to call started_with_special_privs().)\n     */\n    else if (appbundle_dir != NULL) {\n        datafile_dir = g_strdup_printf(\"%s/Contents/Resources/share/wireshark\",\n                                       appbundle_dir);\n    }\n#endif\n    else if (running_in_build_directory_flag && progfile_dir != NULL) {\n        /*\n         * We're (probably) being run from the build directory and\n         * weren't started with special privileges.\n         *\n         * (running_in_build_directory_flag is never set to TRUE\n         * if we're started with special privileges, so we need\n         * only check it; we don't need to call started_with_special_privs().)\n         *\n         * Data files (console.lua, radius/, etc.) are copied to the build\n         * directory during the build which also contains executables. A special\n         * exception is macOS (when built with an app bundle).\n         */\n        datafile_dir = g_strdup(progfile_dir);\n    } else {\n        datafile_dir = g_strdup(DATA_DIR);\n    }\n\n#endif\n    return datafile_dir;\n}\n\n/*\n * Find the directory where the plugins are stored.\n *\n * On Windows, we use the plugin\\{VERSION} subdirectory of the datafile\n * directory, where {VERSION} is the version number of this version of\n * Wireshark.\n *\n * On UN*X:\n *\n *    if we appear to be run from the build directory, we use the\n *    \"plugin\" subdirectory of the datafile directory;\n *\n *    otherwise, if the WIRESHARK_PLUGIN_DIR environment variable is\n *    set and we aren't running with special privileges, we use the\n *    value of that environment variable;\n *\n *    otherwise, if we're running from an app bundle in macOS, we\n *    use the Contents/PlugIns/wireshark subdirectory of the app bundle;\n *\n *    otherwise, we use the PLUGIN_DIR value supplied by the\n *    configure script.\n */\nstatic char *plugin_dir = NULL;\nstatic char *plugin_dir_with_version = NULL;\nstatic char *plugin_pers_dir = NULL;\nstatic char *plugin_pers_dir_with_version = NULL;\n\nstatic void\ninit_plugin_dir(void)\n{\n#if defined(HAVE_PLUGINS) || defined(HAVE_LUA)\n#ifdef _WIN32\n    /*\n     * On Windows, the data file directory is the installation\n     * directory; the plugins are stored under it.\n     *\n     * Assume we're running the installed version of Wireshark;\n     * on Windows, the data file directory is the directory\n     * in which the Wireshark binary resides.\n     */\n    plugin_dir = g_build_filename(get_datafile_dir(), \"plugins\", (gchar *)NULL);\n\n    /*\n     * Make sure that pathname refers to a directory.\n     */\n    if (test_for_directory(plugin_dir) != EISDIR) {\n        /*\n         * Either it doesn't refer to a directory or it\n         * refers to something that doesn't exist.\n         *\n         * Assume that means we're running a version of\n         * Wireshark we've built in a build directory,\n         * in which case {datafile dir}\\plugins is the\n         * top-level plugins source directory, and use\n         * that directory and set the \"we're running in\n         * a build directory\" flag, so the plugin\n         * scanner will check all subdirectories of that\n         * directory for plugins.\n         */\n        g_free(plugin_dir);\n        plugin_dir = g_build_filename(get_datafile_dir(), \"plugins\", (gchar *)NULL);\n        running_in_build_directory_flag = TRUE;\n    }\n#else\n    if (running_in_build_directory_flag) {\n        /*\n         * We're (probably) being run from the build directory and\n         * weren't started with special privileges, so we'll use\n         * the \"plugins\" subdirectory of the directory where the program\n         * we're running is (that's the build directory).\n         */\n        plugin_dir = g_build_filename(get_progfile_dir(), \"plugins\", (gchar *)NULL);\n    } else {\n        if (g_getenv(\"WIRESHARK_PLUGIN_DIR\") && !started_with_special_privs()) {\n            /*\n             * The user specified a different directory for plugins\n             * and we aren't running with special privileges.\n             */\n            plugin_dir = g_strdup(g_getenv(\"WIRESHARK_PLUGIN_DIR\"));\n        }\n#ifdef __APPLE__\n        /*\n         * If we're running from an app bundle and weren't started\n         * with special privileges, use the Contents/PlugIns/wireshark\n         * subdirectory of the app bundle.\n         *\n         * (appbundle_dir is not set to a non-null value if we're\n         * started with special privileges, so we need only check\n         * it; we don't need to call started_with_special_privs().)\n         */\n        else if (appbundle_dir != NULL) {\n            plugin_dir = g_build_filename(appbundle_dir, \"Contents/PlugIns/wireshark\", (gchar *)NULL);\n        }\n#endif\n        else {\n            plugin_dir = g_strdup(PLUGIN_DIR);\n        }\n    }\n#endif\n#endif /* defined(HAVE_PLUGINS) || defined(HAVE_LUA) */\n}\n\nstatic void\ninit_plugin_pers_dir(void)\n{\n#if defined(HAVE_PLUGINS) || defined(HAVE_LUA)\n#ifdef _WIN32\n    plugin_pers_dir = get_persconffile_path(PLUGINS_DIR_NAME, FALSE);\n#else\n    plugin_pers_dir = g_build_filename(g_get_home_dir(), \".local/lib/wireshark/\" PLUGINS_DIR_NAME, (gchar *)NULL);\n#endif\n#endif /* defined(HAVE_PLUGINS) || defined(HAVE_LUA) */\n}\n\n/*\n * Get the directory in which the plugins are stored.\n */\nconst char *\nget_plugins_dir(void)\n{\n    if (!plugin_dir)\n        init_plugin_dir();\n    return plugin_dir;\n}\n\nconst char *\nget_plugins_dir_with_version(void)\n{\n    if (!plugin_dir)\n        init_plugin_dir();\n    if (plugin_dir && !plugin_dir_with_version)\n        plugin_dir_with_version = g_build_filename(plugin_dir, PLUGIN_PATH_ID, (gchar *)NULL);\n    return plugin_dir_with_version;\n}\n\n/* Get the personal plugin dir */\nconst char *\nget_plugins_pers_dir(void)\n{\n    if (!plugin_pers_dir)\n        init_plugin_pers_dir();\n    return plugin_pers_dir;\n}\n\nconst char *\nget_plugins_pers_dir_with_version(void)\n{\n    if (!plugin_pers_dir)\n        init_plugin_pers_dir();\n    if (plugin_pers_dir && !plugin_pers_dir_with_version)\n        plugin_pers_dir_with_version = g_build_filename(plugin_pers_dir, PLUGIN_PATH_ID, (gchar *)NULL);\n    return plugin_pers_dir_with_version;\n}\n\n/*\n * Find the directory where the extcap hooks are stored.\n *\n * On Windows, we use the \"extcap\" subdirectory of the datafile directory.\n *\n * On UN*X, we use the EXTCAP_DIR value supplied by the configure\n * script, unless we think we're being run from the build directory,\n * in which case we use the \"extcap\" subdirectory of the datafile directory.\n *\n * In both cases, we then use the subdirectory of that directory whose\n * name is the version number.\n *\n * XXX - if we think we're being run from the build directory, perhaps we\n * should have the extcap code not look in the version subdirectory\n * of the extcap directory, but look in all of the subdirectories\n * of the extcap directory, so it can just fetch the extcap hooks built\n * as part of the build process.\n */\nstatic char *extcap_dir = NULL;\n\nstatic void init_extcap_dir(void) {\n#ifdef _WIN32\n    const char *alt_extcap_path;\n\n    /*\n     * On Windows, the data file directory is the installation\n     * directory; the extcap hooks are stored under it.\n     *\n     * Assume we're running the installed version of Wireshark;\n     * on Windows, the data file directory is the directory\n     * in which the Wireshark binary resides.\n     */\n    alt_extcap_path = g_getenv(\"WIRESHARK_EXTCAP_DIR\");\n    if (alt_extcap_path) {\n        /*\n         * The user specified a different directory for extcap hooks.\n         */\n        extcap_dir = g_strdup(alt_extcap_path);\n    } else {\n        extcap_dir = g_build_filename(get_datafile_dir(), \"extcap\", (gchar *)NULL);\n    }\n#else\n    if (running_in_build_directory_flag) {\n        /*\n         * We're (probably) being run from the build directory and\n         * weren't started with special privileges, so we'll use\n         * the \"extcap hooks\" subdirectory of the directory where the program\n         * we're running is (that's the build directory).\n         */\n        extcap_dir = g_build_filename(get_progfile_dir(), \"extcap\", (gchar *)NULL);\n    } else {\n        if (g_getenv(\"WIRESHARK_EXTCAP_DIR\") && !started_with_special_privs()) {\n            /*\n             * The user specified a different directory for extcap hooks\n             * and we aren't running with special privileges.\n             */\n            extcap_dir = g_strdup(g_getenv(\"WIRESHARK_EXTCAP_DIR\"));\n        }\n#ifdef __APPLE__\n        /*\n         * If we're running from an app bundle and weren't started\n         * with special privileges, use the Contents/MacOS/extcap\n         * subdirectory of the app bundle.\n         *\n         * (appbundle_dir is not set to a non-null value if we're\n         * started with special privileges, so we need only check\n         * it; we don't need to call started_with_special_privs().)\n         */\n        else if (appbundle_dir != NULL) {\n            extcap_dir = g_build_filename(appbundle_dir, \"Contents/MacOS/extcap\", (gchar *)NULL);\n        }\n#endif\n        else {\n            extcap_dir = g_strdup(EXTCAP_DIR);\n        }\n    }\n#endif\n}\n\n/*\n * Get the directory in which the extcap hooks are stored.\n *\n */\nconst char *\nget_extcap_dir(void)\n{\n    if (!extcap_dir)\n        init_extcap_dir();\n    return extcap_dir;\n}\n\n/*\n * Get the flag indicating whether we're running from a build\n * directory.\n */\ngboolean\nrunning_in_build_directory(void)\n{\n    return running_in_build_directory_flag;\n}\n\n/*\n * Get the directory in which files that, at least on UNIX, are\n * system files (such as \"/etc/ethers\") are stored; on Windows,\n * there's no \"/etc\" directory, so we get them from the global\n * configuration and data file directory.\n */\nconst char *\nget_systemfile_dir(void)\n{\n#ifdef _WIN32\n    return get_datafile_dir();\n#else\n    return \"/etc\";\n#endif\n}\n\nvoid\nset_profile_name(const gchar *profilename)\n{\n    g_free (persconfprofile);\n\n    if (profilename && strlen(profilename) > 0 &&\n        strcmp(profilename, DEFAULT_PROFILE) != 0) {\n        persconfprofile = g_strdup (profilename);\n    } else {\n        /* Default Profile */\n        persconfprofile = NULL;\n    }\n}\n\nconst char *\nget_profile_name(void)\n{\n    if (persconfprofile) {\n        return persconfprofile;\n    } else {\n        return DEFAULT_PROFILE;\n    }\n}\n\ngboolean\nis_default_profile(void)\n{\n    return (!persconfprofile || strcmp(persconfprofile, DEFAULT_PROFILE) == 0) ? TRUE : FALSE;\n}\n\ngboolean\nhas_global_profiles(void)\n{\n    WS_DIR *dir;\n    WS_DIRENT *file;\n    gchar *global_dir = get_global_profiles_dir();\n    gchar *filename;\n    gboolean has_global = FALSE;\n\n    if ((test_for_directory(global_dir) == EISDIR) &&\n        ((dir = ws_dir_open(global_dir, 0, NULL)) != NULL))\n    {\n        while ((file = ws_dir_read_name(dir)) != NULL) {\n            filename = g_strdup_printf (\"%s%s%s\", global_dir, G_DIR_SEPARATOR_S,\n                            ws_dir_get_name(file));\n            if (test_for_directory(filename) == EISDIR) {\n                has_global = TRUE;\n                g_free (filename);\n                break;\n            }\n            g_free (filename);\n        }\n        ws_dir_close(dir);\n    }\n    g_free(global_dir);\n    return has_global;\n}\n\nvoid\nprofile_store_persconffiles(gboolean store)\n{\n    if (store) {\n        profile_files = g_hash_table_new (g_str_hash, g_str_equal);\n    }\n    do_store_persconffiles = store;\n}\n\n/*\n * Get the directory in which personal configuration files reside.\n *\n * On Windows, it's \"Wireshark\", under %APPDATA% or, if %APPDATA% isn't set,\n * it's \"%USERPROFILE%\\Application Data\" (which is what %APPDATA% normally\n * is on Windows 2000).\n *\n * On UNIX-compatible systems, we first look in XDG_CONFIG_HOME/wireshark\n * and, if that doesn't exist, ~/.wireshark, for backwards compatibility.\n * If neither exists, we use XDG_CONFIG_HOME/wireshark, so that the directory\n * is initially created as XDG_CONFIG_HOME/wireshark.  We use that regardless\n * of whether the user is running under an XDG desktop or not, so that\n * if the user's home directory is on a server and shared between\n * different desktop environments on different machines, they can all\n * share the same configuration file directory.\n *\n * XXX - what about stuff that shouldn't be shared between machines,\n * such as plugins in the form of shared loadable images?\n */\nstatic const char *\nget_persconffile_dir_no_profile(void)\n{\n    const char *env;\n\n    /* Return the cached value, if available */\n    if (persconffile_dir != NULL)\n        return persconffile_dir;\n\n    /*\n     * See if the user has selected an alternate environment.\n     */\n    env = g_getenv(ENV_CONFIG_PATH_VAR);\n#ifdef _WIN32\n    if (env == NULL) {\n        /* for backward compatibility */\n        env = g_getenv(\"WIRESHARK_APPDATA\");\n    }\n#endif\n    if (env != NULL) {\n        persconffile_dir = g_strdup(env);\n        return persconffile_dir;\n    }\n\n#ifdef _WIN32\n    /*\n     * Use %APPDATA% or %USERPROFILE%, so that configuration\n     * files are stored in the user profile, rather than in\n     * the home directory.  The Windows convention is to store\n     * configuration information in the user profile, and doing\n     * so means you can use Wireshark even if the home directory\n     * is an inaccessible network drive.\n     */\n    env = g_getenv(\"APPDATA\");\n    if (env != NULL) {\n        /*\n         * Concatenate %APPDATA% with \"\\Wireshark\".\n         */\n        persconffile_dir = g_build_filename(env, \"Wireshark\", NULL);\n        return persconffile_dir;\n    }\n\n    /*\n     * OK, %APPDATA% wasn't set, so use %USERPROFILE%\\Application Data.\n     */\n    env = g_getenv(\"USERPROFILE\");\n    if (env != NULL) {\n        persconffile_dir = g_build_filename(env, \"Application Data\", \"Wireshark\", NULL);\n        return persconffile_dir;\n    }\n\n    /*\n     * Give up and use \"C:\".\n     */\n    persconffile_dir = g_build_filename(\"C:\", \"Wireshark\", NULL);\n    return persconffile_dir;\n#else\n    char *xdg_path, *path;\n    struct passwd *pwd;\n    const char *homedir;\n\n    /*\n     * Check if XDG_CONFIG_HOME/wireshark exists and is a directory.\n     */\n    xdg_path = g_build_filename(g_get_user_config_dir(), \"wireshark\", NULL);\n    if (g_file_test(xdg_path, G_FILE_TEST_IS_DIR)) {\n        persconffile_dir = xdg_path;\n        return persconffile_dir;\n    }\n\n    /*\n     * It doesn't exist, or it does but isn't a directory, so try\n     * ~/.wireshark.\n     *\n     * If $HOME is set, use that for ~.\n     *\n     * (Note: before GLib 2.36, g_get_home_dir() didn't look at $HOME,\n     * but we always want to do so, so we don't use g_get_home_dir().)\n     */\n    homedir = g_getenv(\"HOME\");\n    if (homedir == NULL) {\n        /*\n         * It's not set.\n         *\n         * Get their home directory from the password file.\n         * If we can't even find a password file entry for them,\n         * use \"/tmp\".\n         */\n        pwd = getpwuid(getuid());\n        if (pwd != NULL) {\n            homedir = pwd->pw_dir;\n        } else {\n            homedir = \"/tmp\";\n        }\n    }\n    path = g_build_filename(homedir, \".wireshark\", NULL);\n    if (g_file_test(path, G_FILE_TEST_IS_DIR)) {\n        g_free(xdg_path);\n        persconffile_dir = path;\n        return persconffile_dir;\n    }\n\n    /*\n     * Neither are directories that exist; use the XDG path, so we'll\n     * create that as necessary.\n     */\n    g_free(path);\n    persconffile_dir = xdg_path;\n    return persconffile_dir;\n#endif\n}\n\nvoid\nset_persconffile_dir(const char *p)\n{\n    g_free(persconffile_dir);\n    persconffile_dir = g_strdup(p);\n}\n\nchar *\nget_profiles_dir(void)\n{\n    return g_strdup_printf (\"%s%s%s\", get_persconffile_dir_no_profile (),\n                    G_DIR_SEPARATOR_S, PROFILES_DIR);\n}\n\nint\ncreate_profiles_dir(char **pf_dir_path_return)\n{\n    char *pf_dir_path;\n    ws_statb64 s_buf;\n\n    /*\n     * Create the \"Default\" personal configuration files directory, if necessary.\n     */\n    if (create_persconffile_profile (NULL, pf_dir_path_return) == -1) {\n        return -1;\n    }\n\n    /*\n     * Check if profiles directory exists.\n     * If not then create it.\n     */\n    pf_dir_path = get_profiles_dir ();\n    if (ws_stat64(pf_dir_path, &s_buf) != 0) {\n        if (errno != ENOENT) {\n            /* Some other problem; give up now. */\n            *pf_dir_path_return = pf_dir_path;\n            return -1;\n        }\n\n        /*\n         * It doesn't exist; try to create it.\n         */\n        int ret = ws_mkdir(pf_dir_path, 0755);\n        if (ret == -1) {\n            *pf_dir_path_return = pf_dir_path;\n            return ret;\n        }\n    }\n    g_free(pf_dir_path);\n\n    return 0;\n}\n\nchar *\nget_global_profiles_dir(void)\n{\n    return g_strdup_printf (\"%s%s%s\", get_datafile_dir(),\n                               G_DIR_SEPARATOR_S, PROFILES_DIR);\n}\n\nstatic char *\nget_persconffile_dir(const gchar *profilename)\n{\n    char *persconffile_profile_dir = NULL, *profile_dir;\n\n    if (profilename && strlen(profilename) > 0 &&\n        strcmp(profilename, DEFAULT_PROFILE) != 0) {\n      profile_dir = get_profiles_dir();\n      persconffile_profile_dir = g_strdup_printf (\"%s%s%s\", profile_dir,\n                              G_DIR_SEPARATOR_S, profilename);\n      g_free(profile_dir);\n    } else {\n      persconffile_profile_dir = g_strdup (get_persconffile_dir_no_profile ());\n    }\n\n    return persconffile_profile_dir;\n}\n\nchar *\nget_profile_dir(const char *profilename, gboolean is_global)\n{\n    gchar *profile_dir;\n\n    if (is_global) {\n        if (profilename && strlen(profilename) > 0 &&\n            strcmp(profilename, DEFAULT_PROFILE) != 0)\n        {\n            gchar *global_path = get_global_profiles_dir();\n            profile_dir = g_build_filename(global_path, profilename, NULL);\n            g_free(global_path);\n        } else {\n            profile_dir = g_strdup(get_datafile_dir());\n        }\n    } else {\n        /*\n         * If we didn't supply a profile name, i.e. if profilename is\n         * null, get_persconffile_dir() returns the default profile.\n         */\n        profile_dir = get_persconffile_dir(profilename);\n    }\n\n    return profile_dir;\n}\n\ngboolean\nprofile_exists(const gchar *profilename, gboolean global)\n{\n    gchar *path = NULL;\n    gboolean exists;\n\n    /*\n     * If we're looking up a global profile, we must have a\n     * profile name.\n     */\n    if (global && !profilename)\n        return FALSE;\n\n    path = get_profile_dir(profilename, global);\n    exists = (test_for_directory(path) == EISDIR) ? TRUE : FALSE;\n\n    g_free(path);\n    return exists;\n}\n\nstatic int\ndelete_directory (const char *directory, char **pf_dir_path_return)\n{\n    WS_DIR *dir;\n    WS_DIRENT *file;\n    gchar *filename;\n    int ret = 0;\n\n    if ((dir = ws_dir_open(directory, 0, NULL)) != NULL) {\n        while ((file = ws_dir_read_name(dir)) != NULL) {\n            filename = g_strdup_printf (\"%s%s%s\", directory, G_DIR_SEPARATOR_S,\n                            ws_dir_get_name(file));\n            if (test_for_directory(filename) != EISDIR) {\n                ret = ws_remove(filename);\n#if 0\n            } else {\n                /* The user has manually created a directory in the profile directory */\n                /* I do not want to delete the directory recursively yet */\n                ret = delete_directory (filename, pf_dir_path_return);\n#endif\n            }\n            if (ret != 0) {\n                *pf_dir_path_return = filename;\n                break;\n            }\n            g_free (filename);\n        }\n        ws_dir_close(dir);\n    }\n\n    if (ret == 0 && (ret = ws_remove(directory)) != 0) {\n        *pf_dir_path_return = g_strdup (directory);\n    }\n\n    return ret;\n}\n\nstatic int\nreset_default_profile(char **pf_dir_path_return)\n{\n    char *profile_dir = get_persconffile_dir(NULL);\n    gchar *filename, *del_file;\n    GList *files, *file;\n    int ret = 0;\n\n    files = g_hash_table_get_keys(profile_files);\n    file = g_list_first(files);\n    while (file) {\n        filename = (gchar *)file->data;\n        del_file = g_strdup_printf(\"%s%s%s\", profile_dir, G_DIR_SEPARATOR_S, filename);\n\n        if (file_exists(del_file)) {\n            ret = ws_remove(del_file);\n            if (ret != 0) {\n                *pf_dir_path_return = profile_dir;\n                g_free(del_file);\n                return ret;\n            }\n        }\n\n        g_free(del_file);\n        file = g_list_next(file);\n    }\n    g_list_free(files);\n\n    g_free(profile_dir);\n    return 0;\n}\n\nint\ndelete_persconffile_profile(const char *profilename, char **pf_dir_path_return)\n{\n    if (strcmp(profilename, DEFAULT_PROFILE) == 0) {\n        return reset_default_profile(pf_dir_path_return);\n    }\n\n    char *profile_dir = get_persconffile_dir(profilename);\n    int ret = 0;\n\n    if (test_for_directory (profile_dir) == EISDIR) {\n        ret = delete_directory (profile_dir, pf_dir_path_return);\n    }\n\n    g_free(profile_dir);\n    return ret;\n}\n\nint\nrename_persconffile_profile(const char *fromname, const char *toname,\n                char **pf_from_dir_path_return, char **pf_to_dir_path_return)\n{\n    char *from_dir = get_persconffile_dir(fromname);\n    char *to_dir = get_persconffile_dir(toname);\n    int ret = 0;\n\n    ret = ws_rename (from_dir, to_dir);\n    if (ret != 0) {\n        *pf_from_dir_path_return = from_dir;\n        *pf_to_dir_path_return = to_dir;\n        return ret;\n    }\n\n    g_free (from_dir);\n    g_free (to_dir);\n\n    return 0;\n}\n\n/*\n * Create the directory that holds personal configuration files, if\n * necessary.  If we attempted to create it, and failed, return -1 and\n * set \"*pf_dir_path_return\" to the pathname of the directory we failed\n * to create (it's g_mallocated, so our caller should free it); otherwise,\n * return 0.\n */\nint\ncreate_persconffile_profile(const char *profilename, char **pf_dir_path_return)\n{\n    char *pf_dir_path;\n#ifdef _WIN32\n    char *pf_dir_path_copy, *pf_dir_parent_path;\n    size_t pf_dir_parent_path_len;\n    int save_errno;\n#endif\n    ws_statb64 s_buf;\n    int ret;\n\n    if (profilename) {\n        /*\n         * Create the personal profiles directory, if necessary.\n         */\n        if (create_profiles_dir(pf_dir_path_return) == -1) {\n            return -1;\n        }\n    }\n\n    pf_dir_path = get_persconffile_dir(profilename);\n    if (ws_stat64(pf_dir_path, &s_buf) != 0) {\n        if (errno != ENOENT) {\n            /* Some other problem; give up now. */\n            *pf_dir_path_return = pf_dir_path;\n            return -1;\n        }\n#ifdef _WIN32\n        /*\n         * Does the parent directory of that directory\n         * exist?  %APPDATA% may not exist even though\n         * %USERPROFILE% does.\n         *\n         * We check for the existence of the directory\n         * by first checking whether the parent directory\n         * is just a drive letter and, if it's not, by\n         * doing a \"stat()\" on it.  If it's a drive letter,\n         * or if the \"stat()\" succeeds, we assume it exists.\n         */\n        pf_dir_path_copy = g_strdup(pf_dir_path);\n        pf_dir_parent_path = get_dirname(pf_dir_path_copy);\n        pf_dir_parent_path_len = strlen(pf_dir_parent_path);\n        if (pf_dir_parent_path_len > 0\n            && pf_dir_parent_path[pf_dir_parent_path_len - 1] != ':'\n            && ws_stat64(pf_dir_parent_path, &s_buf) != 0) {\n            /*\n             * Not a drive letter and the stat() failed.\n             */\n            if (errno != ENOENT) {\n                /* Some other problem; give up now. */\n                *pf_dir_path_return = pf_dir_path;\n                save_errno = errno;\n                g_free(pf_dir_path_copy);\n                errno = save_errno;\n                return -1;\n            }\n            /*\n             * No, it doesn't exist - make it first.\n             */\n            ret = ws_mkdir(pf_dir_parent_path, 0755);\n            if (ret == -1) {\n                *pf_dir_path_return = pf_dir_parent_path;\n                save_errno = errno;\n                g_free(pf_dir_path);\n                errno = save_errno;\n                return -1;\n            }\n        }\n        g_free(pf_dir_path_copy);\n        ret = ws_mkdir(pf_dir_path, 0755);\n#else\n        ret = g_mkdir_with_parents(pf_dir_path, 0755);\n#endif\n    } else {\n        /*\n         * Something with that pathname exists; if it's not\n         * a directory, we'll get an error if we try to put\n         * something in it, so we don't fail here, we wait\n         * for that attempt fo fail.\n         */\n        ret = 0;\n    }\n    if (ret == -1)\n        *pf_dir_path_return = pf_dir_path;\n    else\n        g_free(pf_dir_path);\n\n    return ret;\n}\n\nint\ncreate_persconffile_dir(char **pf_dir_path_return)\n{\n    return create_persconffile_profile(persconfprofile, pf_dir_path_return);\n}\n\nint\ncopy_persconffile_profile(const char *toname, const char *fromname, gboolean from_global,\n              char **pf_filename_return, char **pf_to_dir_path_return, char **pf_from_dir_path_return)\n{\n    gchar *from_dir;\n    gchar *to_dir = get_persconffile_dir(toname);\n    gchar *filename, *from_file, *to_file;\n    GList *files, *file;\n\n    from_dir = get_profile_dir(fromname, from_global);\n\n    files = g_hash_table_get_keys(profile_files);\n    file = g_list_first(files);\n    while (file) {\n        filename = (gchar *)file->data;\n        from_file = g_strdup_printf (\"%s%s%s\", from_dir, G_DIR_SEPARATOR_S, filename);\n        to_file =  g_strdup_printf (\"%s%s%s\", to_dir, G_DIR_SEPARATOR_S, filename);\n\n        if (file_exists(from_file) && !copy_file_binary_mode(from_file, to_file)) {\n            *pf_filename_return = g_strdup(filename);\n            *pf_to_dir_path_return = to_dir;\n            *pf_from_dir_path_return = from_dir;\n            g_free (from_file);\n            g_free (to_file);\n            return -1;\n        }\n\n        g_free (from_file);\n        g_free (to_file);\n\n        file = g_list_next(file);\n    }\n\n    g_list_free (files);\n    g_free (from_dir);\n    g_free (to_dir);\n\n    return 0;\n}\n\n/*\n * Get the (default) directory in which personal data is stored.\n *\n * On Win32, this is the \"My Documents\" folder in the personal profile.\n * On UNIX this is simply the current directory.\n */\n/* XXX - should this and the get_home_dir() be merged? */\nextern const char *\nget_persdatafile_dir(void)\n{\n#ifdef _WIN32\n    TCHAR tszPath[MAX_PATH];\n\n    /* Return the cached value, if available */\n    if (persdatafile_dir != NULL)\n        return persdatafile_dir;\n\n    /*\n     * Hint: SHGetFolderPath is not available on MSVC 6 - without\n     * Platform SDK\n     */\n    if (SHGetSpecialFolderPath(NULL, tszPath, CSIDL_PERSONAL, FALSE)) {\n        persdatafile_dir = g_utf16_to_utf8(tszPath, -1, NULL, NULL, NULL);\n        return persdatafile_dir;\n    } else {\n        return \"\";\n    }\n#else\n    return \"\";\n#endif\n}\n\nvoid\nset_persdatafile_dir(const char *p)\n{\n    g_free(persdatafile_dir);\n    persdatafile_dir = g_strdup(p);\n}\n\n#ifdef _WIN32\n/*\n * Returns the user's home directory on Win32.\n */\nstatic const char *\nget_home_dir(void)\n{\n    static const char *home = NULL;\n    const char *homedrive, *homepath;\n    char *homestring;\n    char *lastsep;\n\n    /* Return the cached value, if available */\n    if (home)\n        return home;\n\n    /*\n     * XXX - should we use USERPROFILE anywhere in this process?\n     * Is there a chance that it might be set but one or more of\n     * HOMEDRIVE or HOMEPATH isn't set?\n     */\n    homedrive = g_getenv(\"HOMEDRIVE\");\n    if (homedrive != NULL) {\n        homepath = g_getenv(\"HOMEPATH\");\n        if (homepath != NULL) {\n            /*\n             * This is cached, so we don't need to worry about\n             * allocating multiple ones of them.\n             */\n            homestring = g_strdup_printf(\"%s%s\", homedrive, homepath);\n\n            /*\n             * Trim off any trailing slash or backslash.\n             */\n            lastsep = find_last_pathname_separator(homestring);\n            if (lastsep != NULL && *(lastsep + 1) == '\\0') {\n                /*\n                 * Last separator is the last character\n                 * in the string.  Nuke it.\n                 */\n                *lastsep = '\\0';\n            }\n            home = homestring;\n        } else\n            home = homedrive;\n    } else {\n        /*\n         * Give up and use C:.\n         */\n        home = \"C:\";\n    }\n\n    return home;\n}\n#endif\n\n/*\n * Construct the path name of a personal configuration file, given the\n * file name.\n *\n * On Win32, if \"for_writing\" is FALSE, we check whether the file exists\n * and, if not, construct a path name relative to the \".wireshark\"\n * subdirectory of the user's home directory, and check whether that\n * exists; if it does, we return that, so that configuration files\n * from earlier versions can be read.\n *\n * The returned file name was g_malloc()'d so it must be g_free()d when the\n * caller is done with it.\n */\nchar *\nget_persconffile_path(const char *filename, gboolean from_profile)\n{\n    char *path, *dir = NULL;\n\n    if (do_store_persconffiles && from_profile && !g_hash_table_lookup (profile_files, filename)) {\n        /* Store filenames so we know which filenames belongs to a configuration profile */\n        g_hash_table_insert (profile_files, g_strdup(filename), g_strdup(filename));\n    }\n\n    if (from_profile) {\n        dir = get_persconffile_dir(persconfprofile);\n    } else {\n        dir = get_persconffile_dir(NULL);\n    }\n    path = g_build_filename(dir, filename, NULL);\n\n    g_free(dir);\n    return path;\n}\n\n/*\n * Construct the path name of a global configuration file, given the\n * file name.\n *\n * The returned file name was g_malloc()'d so it must be g_free()d when the\n * caller is done with it.\n */\nchar *\nget_datafile_path(const char *filename)\n{\n    if (running_in_build_directory_flag &&\n        (!strcmp(filename, \"AUTHORS-SHORT\") ||\n         !strcmp(filename, \"hosts\"))) {\n        /* We're running in the build directory and the requested file is a\n         * generated (or a test) file.  Return the file name in the build\n         * directory (not in the source/data directory).\n         * (Oh the things we do to keep the source directory pristine...)\n         */\n        return g_build_filename(get_progfile_dir(), filename, (char *)NULL);\n    } else {\n        return g_build_filename(get_datafile_dir(), filename, (char *)NULL);\n    }\n}\n\n/*\n * Return an error message for UNIX-style errno indications on open or\n * create operations.\n */\nconst char *\nfile_open_error_message(int err, gboolean for_writing)\n{\n    const char *errmsg;\n    static char errmsg_errno[1024+1];\n\n    switch (err) {\n\n    case ENOENT:\n        if (for_writing)\n            errmsg = \"The path to the file \\\"%s\\\" doesn't exist.\";\n        else\n            errmsg = \"The file \\\"%s\\\" doesn't exist.\";\n        break;\n\n    case EACCES:\n        if (for_writing)\n            errmsg = \"You don't have permission to create or write to the file \\\"%s\\\".\";\n        else\n            errmsg = \"You don't have permission to read the file \\\"%s\\\".\";\n        break;\n\n    case EISDIR:\n        errmsg = \"\\\"%s\\\" is a directory (folder), not a file.\";\n        break;\n\n    case ENOSPC:\n        errmsg = \"The file \\\"%s\\\" could not be created because there is no space left on the file system.\";\n        break;\n\n#ifdef EDQUOT\n    case EDQUOT:\n        errmsg = \"The file \\\"%s\\\" could not be created because you are too close to, or over, your disk quota.\";\n        break;\n#endif\n\n    case EINVAL:\n        errmsg = \"The file \\\"%s\\\" could not be created because an invalid filename was specified.\";\n        break;\n\n#ifdef ENAMETOOLONG\n    case ENAMETOOLONG:\n        /* XXX Make sure we truncate on a character boundary. */\n        errmsg = \"The file name \\\"%.80s\" UTF8_HORIZONTAL_ELLIPSIS \"\\\" is too long.\";\n        break;\n#endif\n\n    case ENOMEM:\n        /*\n         * The problem probably has nothing to do with how much RAM the\n         * user has on their machine, so don't confuse them by saying\n         * \"memory\".  The problem is probably either virtual address\n         * space or swap space.\n         */\n#if GLIB_SIZEOF_VOID_P == 4\n        /*\n         * ILP32; we probably ran out of virtual address space.\n         */\n#define ENOMEM_REASON \"it can't be handled by a 32-bit application\"\n#else\n        /*\n         * LP64 or LLP64; we probably ran out of swap space.\n         */\n#if defined(_WIN32)\n        /*\n         * You need to make the pagefile bigger.\n         */\n#define ENOMEM_REASON \"the pagefile is too small\"\n#elif defined(__APPLE__)\n        /*\n         * dynamic_pager couldn't, or wouldn't, create more swap files.\n         */\n#define ENOMEM_REASON \"your system ran out of swap file space\"\n#else\n        /*\n         * Either you have a fixed swap partition or a fixed swap file,\n         * and it needs to be made bigger.\n         *\n         * This is UN*X, but it's not macOS, so we assume the user is\n         * *somewhat* nerdy.\n         */\n#define ENOMEM_REASON \"your system is out of swap space\"\n#endif\n#endif /* GLIB_SIZEOF_VOID_P == 4 */\n        if (for_writing)\n            errmsg = \"The file \\\"%s\\\" could not be created because \" ENOMEM_REASON \".\";\n        else\n            errmsg = \"The file \\\"%s\\\" could not be opened because \" ENOMEM_REASON \".\";\n        break;\n\n    default:\n        g_snprintf(errmsg_errno, sizeof(errmsg_errno),\n               \"The file \\\"%%s\\\" could not be %s: %s.\",\n               for_writing ? \"created\" : \"opened\",\n               g_strerror(err));\n        errmsg = errmsg_errno;\n        break;\n    }\n    return errmsg;\n}\n\n/*\n * Return an error message for UNIX-style errno indications on write\n * operations.\n */\nconst char *\nfile_write_error_message(int err)\n{\n    const char *errmsg;\n    static char errmsg_errno[1024+1];\n\n    switch (err) {\n\n    case ENOSPC:\n        errmsg = \"The file \\\"%s\\\" could not be saved because there is no space left on the file system.\";\n        break;\n\n#ifdef EDQUOT\n    case EDQUOT:\n        errmsg = \"The file \\\"%s\\\" could not be saved because you are too close to, or over, your disk quota.\";\n        break;\n#endif\n\n    default:\n        g_snprintf(errmsg_errno, sizeof(errmsg_errno),\n               \"An error occurred while writing to the file \\\"%%s\\\": %s.\",\n               g_strerror(err));\n        errmsg = errmsg_errno;\n        break;\n    }\n    return errmsg;\n}\n\n\ngboolean\nfile_exists(const char *fname)\n{\n    ws_statb64 file_stat;\n\n    if (!fname) {\n        return FALSE;\n    }\n\n    if (ws_stat64(fname, &file_stat) != 0 && errno == ENOENT) {\n        return FALSE;\n    } else {\n        return TRUE;\n    }\n}\n\ngboolean config_file_exists_with_entries(const char *fname, char comment_char)\n{\n    gboolean start_of_line = TRUE;\n    gboolean has_entries = FALSE;\n    FILE *file;\n    int c;\n\n    if (!fname) {\n        return FALSE;\n    }\n\n    if ((file = ws_fopen(fname, \"r\")) == NULL) {\n        return FALSE;\n    }\n\n    do {\n        c = ws_getc_unlocked(file);\n        if (start_of_line && c != comment_char && !g_ascii_isspace(c) && g_ascii_isprint(c)) {\n            has_entries = TRUE;\n            break;\n        }\n        if (c == '\\n' || !g_ascii_isspace(c)) {\n            start_of_line = (c == '\\n');\n        }\n    } while (c != EOF);\n\n    fclose(file);\n    return has_entries;\n}\n\n/*\n * Check that the from file is not the same as to file\n * We do it here so we catch all cases ...\n * Unfortunately, the file requester gives us an absolute file\n * name and the read file name may be relative (if supplied on\n * the command line), so we can't just compare paths. From Joerg Mayer.\n */\ngboolean\nfiles_identical(const char *fname1, const char *fname2)\n{\n    /* Two different implementations, because:\n     *\n     * - _fullpath is not available on UN*X, so we can't get full\n     *   paths and compare them (which wouldn't work with hard links\n     *   in any case);\n     *\n     * - st_ino isn't filled in with a meaningful value on Windows.\n     */\n#ifdef _WIN32\n    char full1[MAX_PATH], full2[MAX_PATH];\n\n    /*\n     * Get the absolute full paths of the file and compare them.\n     * That won't work if you have hard links, but those aren't\n     * much used on Windows, even though NTFS supports them.\n     *\n     * XXX - will _fullpath work with UNC?\n     */\n    if( _fullpath( full1, fname1, MAX_PATH ) == NULL ) {\n        return FALSE;\n    }\n\n    if( _fullpath( full2, fname2, MAX_PATH ) == NULL ) {\n        return FALSE;\n    }\n\n    if(strcmp(full1, full2) == 0) {\n        return TRUE;\n    } else {\n        return FALSE;\n    }\n#else\n    ws_statb64 filestat1, filestat2;\n\n    /*\n     * Compare st_dev and st_ino.\n     */\n    if (ws_stat64(fname1, &filestat1) == -1)\n        return FALSE;   /* can't get info about the first file */\n    if (ws_stat64(fname2, &filestat2) == -1)\n        return FALSE;   /* can't get info about the second file */\n    return (filestat1.st_dev == filestat2.st_dev &&\n        filestat1.st_ino == filestat2.st_ino);\n#endif\n}\n\ngboolean\nfile_needs_reopen(int fd, const char* filename)\n{\n#ifdef _WIN32\n    /* Windows handles st_dev in a way unsuitable here:\n     *   * _fstat() simply casts the file descriptor (ws_fileno(fp)) to unsigned\n     *     and assigns this value to st_dev and st_rdev\n     *   * _wstat() converts drive letter (eg. C) to number (A=0, B=1, C=2, ...)\n     *     and assigns such number to st_dev and st_rdev\n     *\n     * The st_ino parameter is simply zero as there is no specific assignment\n     * to it in the Universal CRT source code.\n     *\n     * Thus instead of using fstat(), use Windows specific API.\n     */\n\n    HANDLE open_handle = (HANDLE)_get_osfhandle(fd);\n    HANDLE current_handle = CreateFile(utf_8to16(filename), FILE_READ_ATTRIBUTES,\n                            FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,\n                            NULL, OPEN_EXISTING, 0, NULL);\n    BY_HANDLE_FILE_INFORMATION open_info, current_info;\n\n    if (current_handle == INVALID_HANDLE_VALUE) {\n        return TRUE;\n    }\n\n#if (_WIN32_WINNT >= _WIN32_WINNT_WIN8)\n    FILE_ID_INFO open_id, current_id;\n    if (GetFileInformationByHandleEx(open_handle, FileIdInfo, &open_id, sizeof(open_id)) &&\n        GetFileInformationByHandleEx(current_handle, FileIdInfo, &current_id, sizeof(current_id))) {\n        /* 128-bit identifier is available, use it */\n        CloseHandle(current_handle);\n        return open_id.VolumeSerialNumber != current_id.VolumeSerialNumber ||\n               memcmp(&open_id.FileId, &current_id.FileId, sizeof(open_id.FileId)) != 0;\n    }\n#endif /* _WIN32_WINNT >= _WIN32_WINNT_WIN8 */\n    if (GetFileInformationByHandle(open_handle, &open_info) &&\n        GetFileInformationByHandle(current_handle, &current_info)) {\n        /* Fallback to 64-bit identifier */\n        CloseHandle(current_handle);\n        guint64 open_size = (((guint64)open_info.nFileSizeHigh) << 32) | open_info.nFileSizeLow;\n        guint64 current_size = (((guint64)current_info.nFileSizeHigh) << 32) | current_info.nFileSizeLow;\n        return open_info.dwVolumeSerialNumber != current_info.dwVolumeSerialNumber ||\n               open_info.nFileIndexHigh != current_info.nFileIndexHigh ||\n               open_info.nFileIndexLow != current_info.nFileIndexLow ||\n               open_size > current_size;\n    }\n    CloseHandle(current_handle);\n    return TRUE;\n#else\n    ws_statb64 open_stat, current_stat;\n\n    /* consider a file deleted when stat fails for either file,\n     * or when the residing device / inode has changed. */\n    if (0 != ws_fstat64(fd, &open_stat))\n        return TRUE;\n    if (0 != ws_stat64(filename, &current_stat))\n        return TRUE;\n\n    return open_stat.st_dev != current_stat.st_dev ||\n           open_stat.st_ino != current_stat.st_ino ||\n           open_stat.st_size > current_stat.st_size;\n#endif\n}\n\n/*\n * Copy a file in binary mode, for those operating systems that care about\n * such things.  This should be OK for all files, even text files, as\n * we'll copy the raw bytes, and we don't look at the bytes as we copy\n * them.\n *\n * Returns TRUE on success, FALSE on failure. If a failure, it also\n * displays a simple dialog window with the error message.\n */\ngboolean\ncopy_file_binary_mode(const char *from_filename, const char *to_filename)\n{\n    int           from_fd, to_fd, err;\n    ssize_t       nread, nwritten;\n    guint8        *pd = NULL;\n\n    /* Copy the raw bytes of the file. */\n    from_fd = ws_open(from_filename, O_RDONLY | O_BINARY, 0000 /* no creation so don't matter */);\n    if (from_fd < 0) {\n        report_open_failure(from_filename, errno, FALSE);\n        goto done;\n    }\n\n    /* Use open() instead of creat() so that we can pass the O_BINARY\n       flag, which is relevant on Win32; it appears that \"creat()\"\n       may open the file in text mode, not binary mode, but we want\n       to copy the raw bytes of the file, so we need the output file\n       to be open in binary mode. */\n    to_fd = ws_open(to_filename, O_WRONLY | O_CREAT | O_TRUNC | O_BINARY, 0644);\n    if (to_fd < 0) {\n        report_open_failure(to_filename, errno, TRUE);\n        ws_close(from_fd);\n        goto done;\n    }\n\n#define FS_READ_SIZE 65536\n    pd = (guint8 *)g_malloc(FS_READ_SIZE);\n    while ((nread = ws_read(from_fd, pd, FS_READ_SIZE)) > 0) {\n        nwritten = ws_write(to_fd, pd, nread);\n        if (nwritten < nread) {\n            if (nwritten < 0)\n                err = errno;\n            else\n                err = WTAP_ERR_SHORT_WRITE;\n            report_write_failure(to_filename, err);\n            ws_close(from_fd);\n            ws_close(to_fd);\n            goto done;\n        }\n    }\n    if (nread < 0) {\n        err = errno;\n        report_read_failure(from_filename, err);\n        ws_close(from_fd);\n        ws_close(to_fd);\n        goto done;\n    }\n    ws_close(from_fd);\n    if (ws_close(to_fd) < 0) {\n        report_write_failure(to_filename, errno);\n        goto done;\n    }\n\n    g_free(pd);\n    pd = NULL;\n    return TRUE;\n\ndone:\n    g_free(pd);\n    return FALSE;\n}\n\ngchar *\ndata_file_url(const gchar *filename)\n{\n    gchar *file_path;\n    gchar *uri;\n\n    /* Absolute path? */\n    if(g_path_is_absolute(filename)) {\n        file_path = g_strdup(filename);\n    } else {\n        file_path = g_strdup_printf(\"%s/%s\", get_datafile_dir(), filename);\n    }\n\n    /* XXX - check, if the file is really existing, otherwise display a simple_dialog about the problem */\n\n    /* convert filename to uri */\n    uri = g_filename_to_uri(file_path, NULL, NULL);\n    g_free(file_path);\n    return uri;\n}\n\nvoid\nfree_progdirs(void)\n{\n    g_free(persconffile_dir);\n    persconffile_dir = NULL;\n    g_free(datafile_dir);\n    datafile_dir = NULL;\n    g_free(persdatafile_dir);\n    persdatafile_dir = NULL;\n    g_free(persconfprofile);\n    persconfprofile = NULL;\n    g_free(progfile_dir);\n    progfile_dir = NULL;\n#if defined(HAVE_PLUGINS) || defined(HAVE_LUA)\n    g_free(plugin_dir);\n    plugin_dir = NULL;\n    g_free(plugin_dir_with_version);\n    plugin_dir_with_version = NULL;\n    g_free(plugin_pers_dir);\n    plugin_pers_dir = NULL;\n    g_free(plugin_pers_dir_with_version);\n    plugin_pers_dir_with_version = NULL;\n#endif\n    g_free(extcap_dir);\n    extcap_dir = NULL;\n}\n\n/*\n * Editor modelines\n *\n * Local Variables:\n * c-basic-offset: 4\n * tab-width: 8\n * indent-tabs-mode: nil\n * End:\n *\n * ex: set shiftwidth=4 tabstop=8 expandtab:\n * :indentSize=4:tabSize=8:noTabs=true:\n */\n",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/caputils/capture-pcap-util-unix.c": "/* capture-pcap-util-unix.c\n * UN*X-specific utility routines for packet capture\n *\n * Wireshark - Network traffic analyzer\n * By Gerald Combs <gerald@wireshark.org>\n * Copyright 1998 Gerald Combs\n *\n * SPDX-License-Identifier: GPL-2.0-or-later\n */\n\n#include \"config.h\"\n\n#include <glib.h>\n\n#include <ws_attributes.h>\n\n#ifdef HAVE_LIBPCAP\n\n#include <wsutil/wspcap.h>\n\n#ifdef __APPLE__\n#include <dlfcn.h>\n#endif\n\n#ifndef HAVE_PCAP_FINDALLDEVS\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <errno.h>\n\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n\n#ifdef HAVE_SYS_SOCKET_H\n#include <sys/socket.h>\n#endif\n\n#ifdef HAVE_SYS_IOCTL_H\n#include <sys/ioctl.h>\n#endif\n\n/*\n * Keep Digital UNIX happy when including <net/if.h>.\n */\nstruct mbuf;\nstruct rtentry;\n#include <net/if.h>\n\n#ifdef HAVE_SYS_SOCKIO_H\n# include <sys/sockio.h>\n#endif\n\n#endif  /* HAVE_PCAP_FINDALLDEVS */\n\n#ifdef HAVE_LIBCAP\n# include <sys/capability.h>\n#endif\n\n#include \"caputils/capture_ifinfo.h\"\n#include \"caputils/capture-pcap-util.h\"\n#include \"caputils/capture-pcap-util-int.h\"\n\n#ifdef HAVE_PCAP_REMOTE\nGList *\nget_remote_interface_list(const char *hostname, const char *port,\n\t\t\t  int auth_type, const char *username,\n\t\t\t  const char *passwd, int *err, char **err_str)\n{\n\tstruct pcap_rmtauth auth;\n\tchar source[PCAP_BUF_SIZE];\n\tchar errbuf[PCAP_ERRBUF_SIZE];\n\tGList *result;\n\n\tif (pcap_createsrcstr(source, PCAP_SRC_IFREMOTE, hostname, port,\n\t\t\t      NULL, errbuf) == -1) {\n\t\t*err = CANT_GET_INTERFACE_LIST;\n\t\tif (err_str != NULL)\n\t\t\t*err_str = cant_get_if_list_error_message(errbuf);\n\t\treturn NULL;\n\t}\n\n\tauth.type = auth_type;\n\tauth.username = g_strdup(username);\n\tauth.password = g_strdup(passwd);\n\n\tresult = get_interface_list_findalldevs_ex(source, &auth, err, err_str);\n\tg_free(auth.username);\n\tg_free(auth.password);\n\n\treturn result;\n}\n#endif\n\n#ifdef HAVE_PCAP_FINDALLDEVS\nGList *\nget_interface_list(int *err, char **err_str)\n{\n\treturn get_interface_list_findalldevs(err, err_str);\n}\n#else /* HAVE_PCAP_FINDALLDEVS */\nstruct search_user_data {\n\tchar\t*name;\n\tif_info_t *if_info;\n};\n\nstatic void\nsearch_for_if_cb(gpointer data, gpointer user_data)\n{\n\tstruct search_user_data *search_user_data = (struct search_user_data*)user_data;\n\tif_info_t *if_info = (if_info_t *)data;\n\n\tif (strcmp(if_info->name, search_user_data->name) == 0)\n\t\tsearch_user_data->if_info = if_info;\n}\n\nGList *\nget_interface_list(cap_device_open_err *err, char **err_str)\n{\n\tGList  *il = NULL;\n\tgint    nonloopback_pos = 0;\n\tstruct  ifreq *ifr, *last;\n\tstruct  ifconf ifc;\n\tstruct  ifreq ifrflags;\n\tint     sock = socket(AF_INET, SOCK_DGRAM, 0);\n\tstruct search_user_data user_data;\n\tpcap_t *pch;\n\tint len, lastlen;\n\tchar *buf;\n\tif_info_t *if_info;\n\tchar errbuf[PCAP_ERRBUF_SIZE];\n\tgboolean loopback;\n\n\tif (sock < 0) {\n\t\t*err = CANT_GET_INTERFACE_LIST;\n\t\tif (err_str != NULL) {\n\t\t\t*err_str = g_strdup_printf(\n\t\t\t    \"Can't get list of interfaces: error opening socket: %s\",\n\t\t\t    g_strerror(errno));\n\t\t}\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * This code came from: W. Richard Stevens: \"UNIX Network Programming\",\n\t * Networking APIs: Sockets and XTI, Vol 1, page 434.\n\t */\n\tlastlen = 0;\n\tlen = 100 * sizeof(struct ifreq);\n\tfor ( ; ; ) {\n\t\tbuf = (char *)g_malloc0(len);\n\t\tifc.ifc_len = len;\n\t\tifc.ifc_buf = buf;\n\t\tif (ioctl(sock, SIOCGIFCONF, &ifc) < 0) {\n\t\t\tif (errno != EINVAL || lastlen != 0) {\n\t\t\t\tif (err_str != NULL) {\n\t\t\t\t\t*err_str = g_strdup_printf(\n\t\t\t\t\t    \"Can't get list of interfaces: SIOCGIFCONF ioctl error: %s\",\n\t\t\t\t\t    g_strerror(errno));\n\t\t\t\t}\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t} else {\n\t\t\tif ((unsigned int) ifc.ifc_len < sizeof(struct ifreq)) {\n\t\t\t\tif (err_str != NULL) {\n\t\t\t\t\t*err_str = g_strdup(\n\t\t\t\t\t    \"Can't get list of interfaces: SIOCGIFCONF ioctl gave too small return buffer\");\n\t\t\t\t}\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tif (ifc.ifc_len == lastlen)\n\t\t\t\tbreak;\t\t\t/* success, len has not changed */\n\t\t\tlastlen = ifc.ifc_len;\n\t\t}\n\t\tlen += 10 * sizeof(struct ifreq);\t/* increment */\n\t\tg_free(buf);\n\t}\n\tifr = (struct ifreq *) ifc.ifc_req;\n\tlast = (struct ifreq *) ((char *) ifr + ifc.ifc_len);\n\twhile (ifr < last) {\n\t\t/*\n\t\t * Skip entries that begin with \"dummy\", or that include\n\t\t * a \":\" (the latter are Solaris virtuals).\n\t\t */\n\t\tif (strncmp(ifr->ifr_name, \"dummy\", 5) == 0 ||\n\t\t    strchr(ifr->ifr_name, ':') != NULL)\n\t\t\tgoto next;\n\n\t\t/*\n\t\t * If we already have this interface name on the list,\n\t\t * don't add it, but, if we don't already have an IP\n\t\t * address for it, add that address (SIOCGIFCONF returns,\n\t\t * at least on BSD-flavored systems, one entry per\n\t\t * interface *address*; if an interface has multiple\n\t\t * addresses, we get multiple entries for it).\n\t\t */\n\t\tuser_data.name = ifr->ifr_name;\n\t\tuser_data.if_info = NULL;\n\t\tg_list_foreach(il, search_for_if_cb, &user_data);\n\t\tif (user_data.if_info != NULL) {\n\t\t\tif_info_add_address(user_data.if_info, &ifr->ifr_addr);\n\t\t\tif (user_data.if_info->addrs) {\n\t\t\t\tg_slist_reverse(user_data.if_info->addrs);\n\t\t\t}\n\t\t\tgoto next;\n\t\t}\n\n\t\t/*\n\t\t * Get the interface flags.\n\t\t */\n\t\tmemset(&ifrflags, 0, sizeof ifrflags);\n\t\tg_strlcpy(ifrflags.ifr_name, ifr->ifr_name,\n\t\t    sizeof ifrflags.ifr_name);\n\t\tif (ioctl(sock, SIOCGIFFLAGS, (char *)&ifrflags) < 0) {\n\t\t\tif (errno == ENXIO)\n\t\t\t\tgoto next;\n\t\t\tif (err_str != NULL) {\n\t\t\t\t*err_str = g_strdup_printf(\n\t\t\t\t    \"Can't get list of interfaces: SIOCGIFFLAGS error getting flags for interface %s: %s\",\n\t\t\t\t    ifr->ifr_name, g_strerror(errno));\n\t\t\t}\n\t\t\tgoto fail;\n\t\t}\n\n\t\t/*\n\t\t * Skip interfaces that aren't up.\n\t\t */\n\t\tif (!(ifrflags.ifr_flags & IFF_UP))\n\t\t\tgoto next;\n\n\t\t/*\n\t\t * Skip interfaces that we can't open with \"libpcap\".\n\t\t * Open with the minimum packet size - it appears that the\n\t\t * IRIX SIOCSNOOPLEN \"ioctl\" may fail if the capture length\n\t\t * supplied is too large, rather than just truncating it.\n\t\t */\n\t\tpch = pcap_open_live(ifr->ifr_name, MIN_PACKET_SIZE, 0, 0,\n\t\t    errbuf);\n\t\tif (pch == NULL)\n\t\t\tgoto next;\n\t\tpcap_close(pch);\n\n\t\t/*\n\t\t * If it's a loopback interface, add it at the end of the\n\t\t * list, otherwise add it after the last non-loopback\n\t\t * interface, so all loopback interfaces go at the end - we\n\t\t * don't want a loopback interface to be the default capture\n\t\t * device unless there are no non-loopback devices.\n\t\t */\n\t\tloopback = ((ifrflags.ifr_flags & IFF_LOOPBACK) ||\n\t\t    strncmp(ifr->ifr_name, \"lo\", 2) == 0);\n\t\tif_info = if_info_new(ifr->ifr_name, NULL, loopback);\n\t\tif_info_add_address(if_info, &ifr->ifr_addr);\n\t\tif (if_info->addrs) {\n\t\t\tg_slist_reverse(if_info->addrs);\n\t\t}\n\t\tif (loopback)\n\t\t\til = g_list_append(il, if_info);\n\t\telse {\n\t\t\til = g_list_insert(il, if_info, nonloopback_pos);\n\t\t\t/*\n\t\t\t * Insert the next non-loopback interface after this\n\t\t\t * one.\n\t\t\t */\n\t\t\tnonloopback_pos++;\n\t\t}\n\n\tnext:\n#ifdef HAVE_STRUCT_SOCKADDR_SA_LEN\n\t\tifr = (struct ifreq *) ((char *) ifr +\n\t\t    (ifr->ifr_addr.sa_len > sizeof(ifr->ifr_addr) ?\n\t\t\tifr->ifr_addr.sa_len : sizeof(ifr->ifr_addr)) +\n\t\t    IFNAMSIZ);\n#else\n\t\tifr = (struct ifreq *) ((char *) ifr + sizeof(struct ifreq));\n#endif\n\t}\n\n#ifdef linux\n\t/*\n\t * OK, maybe we have support for the \"any\" device, to do a cooked\n\t * capture on all interfaces at once.\n\t * Try opening it and, if that succeeds, add it to the end of\n\t * the list of interfaces.\n\t */\n\tpch = pcap_open_live(\"any\", MIN_PACKET_SIZE, 0, 0, errbuf);\n\tif (pch != NULL) {\n\t\t/*\n\t\t * It worked; we can use the \"any\" device.\n\t\t */\n\t\tif_info = if_info_new(\"any\",\n\t\t    \"Pseudo-device that captures on all interfaces\", FALSE);\n\t\til = g_list_insert(il, if_info, -1);\n\t\tpcap_close(pch);\n\t}\n#endif\n\n\tg_free(ifc.ifc_buf);\n\tclose(sock);\n\n\tif (il == NULL) {\n\t\t/*\n\t\t * No interfaces found.\n\t\t */\n\t\t*err = 0;\n\t\tif (err_str != NULL)\n\t\t\t*err_str = NULL;\n\t}\n\treturn il;\n\nfail:\n\tif (il != NULL)\n\t\tfree_interface_list(il);\n\tg_free(ifc.ifc_buf);\n\tclose(sock);\n\t*err = CANT_GET_INTERFACE_LIST;\n\treturn NULL;\n}\n#endif /* HAVE_PCAP_FINDALLDEVS */\n\n/*\n * Get an error message string for a CANT_GET_INTERFACE_LIST error from\n * \"get_interface_list()\".\n */\ngchar *\ncant_get_if_list_error_message(const char *err_str)\n{\n\treturn g_strdup_printf(\"Can't get list of interfaces: %s\", err_str);\n}\n\n#ifdef HAVE_PCAP_SET_TSTAMP_PRECISION\n/*\n * Request high-resolution time stamps.\n *\n * We don't check for errors - if this fails, we just live with boring old\n * microsecond-resolution time stamps. The only errors pcap_set_tstamp_precision()\n * is documenting as returning are PCAP_ERROR_TSTAMP_PRECISION_NOTSUP, which just\n * means we can't do nanosecond precision on this adapter, in which case we\n * just live with whatever resolution we get by default, and\n * PCAP_ERROR_ACTIVATED, which shouldn't happen as we shouldn't call this\n * after we've activated the pcap_t.\n */\nvoid\nrequest_high_resolution_timestamp(pcap_t *pcap_h)\n{\n#ifdef __APPLE__\n\t/*\n\t * On macOS, if you build with a newer SDK, pcap_set_tstamp_precision()\n\t * is available, so the code will be built with it.\n\t *\n\t * However, if you then try to run on an older release that\n\t * doesn't have pcap_set_tstamp_precision(), the dynamic linker\n\t * will fail, as it won't find pcap_set_tstamp_precision().\n\t *\n\t * libpcap doesn't use macOS \"weak linking\" for new routines,\n\t * so we can't just check whether a pointer to\n\t * pcap_set_tstamp_precision() is null and, if it is, not\n\t * call it.  We have to, instead, use dlopen() to load\n\t * libpcap, and dlsym() to find a pointer to pcap_set_tstamp_precision(),\n\t * and if we find the pointer, call it.\n\t */\n\tstatic gboolean initialized = FALSE;\n\tstatic int (*p_pcap_set_tstamp_precision)(pcap_t *, int);\n\n\tif (!initialized) {\n\t\tp_pcap_set_tstamp_precision =\n\t\t    (int (*)(pcap_t *, int))\n\t\t      dlsym(RTLD_NEXT, \"pcap_set_tstamp_precision\");\n\t\tinitialized = TRUE;\n\t}\n\tif (p_pcap_set_tstamp_precision != NULL)\n\t\t(*p_pcap_set_tstamp_precision)(pcap_h, PCAP_TSTAMP_PRECISION_NANO);\n#else /* __APPLE__ */\n\t/*\n\t * On other UN*Xes we require that we be run on an OS version\n\t * with a libpcap equal to or later than the version with which\n\t * we were built.\n\t */\n\tpcap_set_tstamp_precision(pcap_h, PCAP_TSTAMP_PRECISION_NANO);\n#endif /* __APPLE__ */\n}\n\n/*\n * Return TRUE if the pcap_t in question is set up for high-precision\n * time stamps, FALSE otherwise.\n */\ngboolean\nhave_high_resolution_timestamp(pcap_t *pcap_h)\n{\n#ifdef __APPLE__\n\t/*\n\t * See above.\n\t */\n\tstatic gboolean initialized = FALSE;\n\tstatic int (*p_pcap_get_tstamp_precision)(pcap_t *);\n\n\tif (!initialized) {\n\t\tp_pcap_get_tstamp_precision =\n\t\t    (int (*)(pcap_t *))\n\t\t      dlsym(RTLD_NEXT, \"pcap_get_tstamp_precision\");\n\t\tinitialized = TRUE;\n\t}\n\tif (p_pcap_get_tstamp_precision != NULL)\n\t\treturn (*p_pcap_get_tstamp_precision)(pcap_h) == PCAP_TSTAMP_PRECISION_NANO;\n\telse\n\t\treturn FALSE;\t/* Can't get implies couldn't set */\n#else /* __APPLE__ */\n\t/*\n\t * On other UN*Xes we require that we be run on an OS version\n\t * with a libpcap equal to or later than the version with which\n\t * we were built.\n\t */\n\treturn pcap_get_tstamp_precision(pcap_h) == PCAP_TSTAMP_PRECISION_NANO;\n#endif /* __APPLE__ */\n}\n\n#endif /* HAVE_PCAP_SET_TSTAMP_PRECISION */\n\nif_capabilities_t *\nget_if_capabilities_local(interface_options *interface_opts,\n    cap_device_open_err *err, char **err_str)\n{\n#ifdef HAVE_PCAP_CREATE\n\treturn get_if_capabilities_pcap_create(interface_opts, err, err_str);\n#else\n\treturn get_if_capabilities_pcap_open_live(interface_opts, err, err_str);\n#endif\n}\n\npcap_t *\nopen_capture_device_local(capture_options *capture_opts\n#ifndef HAVE_PCAP_CREATE\n\t_U_\n#endif\n\t,\n    interface_options *interface_opts, int timeout,\n    cap_device_open_err *open_err, char (*open_err_str)[PCAP_ERRBUF_SIZE])\n{\n\t/*\n\t * We're not opening a remote device; use pcap_create() and\n\t * pcap_activate() if we have them, so that we can set various\n\t * options, otherwise use pcap_open_live().\n\t */\n#ifdef HAVE_PCAP_CREATE\n\treturn open_capture_device_pcap_create(capture_opts,\n\t    interface_opts, timeout, open_err, open_err_str);\n#else\n\treturn open_capture_device_pcap_open_live(interface_opts, timeout,\n\t    open_err, open_err_str);\n#endif\n}\n\n/*\n * Get the versions of libpcap, libpcap, and libnl with which we were\n * compiled, and append them to a GString.\n */\nvoid\nget_compiled_caplibs_version(GString *str)\n{\n\t/*\n\t * NOTE: in *some* flavors of UN*X, the data from a shared\n\t * library might be linked into executable images that are\n\t * linked with that shared library, in which case you could\n\t * look at pcap_version[] to get the version with which\n\t * the program was compiled.\n\t *\n\t * In other flavors of UN*X, that doesn't happen, so\n\t * pcap_version[] gives you the version the program is\n\t * running with, not the version it was built with, and,\n\t * in at least some of them, if the length of a data item\n\t * referred to by the executable - such as the pcap_version[]\n\t * string - isn't the same in the version of the library\n\t * with which the program was built and the version with\n\t * which it was run, the run-time linker will complain,\n\t * which is Not Good.\n\t *\n\t * So, for now, we just give up on reporting the version\n\t * of libpcap with which we were compiled.\n\t */\n\tg_string_append(str, \"with libpcap\");\n#ifdef HAVE_PCAP_REMOTE\n\t/*\n\t * We have remote pcap support in libpcap.\n\t */\n\tg_string_append(str, \" (including remote capture support)\");\n#endif\n\n\t/*\n\t * XXX - these libraries are actually used only by dumpcap,\n\t * but we mention them here so that a user reporting a bug\n\t * can get information about dumpcap's libraries without\n\t * having to run dumpcap.\n\t */\n\t/* LIBCAP */\n\tg_string_append(str, \", \");\n#ifdef HAVE_LIBCAP\n\tg_string_append(str, \"with POSIX capabilities\");\n#ifdef _LINUX_CAPABILITY_VERSION\n\tg_string_append(str, \" (Linux)\");\n#endif /* _LINUX_CAPABILITY_VERSION */\n#else /* HAVE_LIBCAP */\n\tg_string_append(str, \"without POSIX capabilities\");\n#endif /* HAVE_LIBCAP */\n\n#ifdef __linux__\n\t/* This is a Linux-specific library. */\n\t/* LIBNL */\n\tg_string_append(str, \", \");\n#if defined(HAVE_LIBNL1)\n\tg_string_append(str, \"with libnl 1\");\n#elif defined(HAVE_LIBNL2)\n\tg_string_append(str, \"with libnl 2\");\n#elif defined(HAVE_LIBNL3)\n\tg_string_append(str, \"with libnl 3\");\n#else /* no libnl */\n\tg_string_append(str, \"without libnl\");\n#endif /* libnl version */\n#endif /* __linux__ */\n}\n\n/*\n * Append the version of libpcap with which we we're running to a GString.\n */\nvoid\nget_runtime_caplibs_version(GString *str)\n{\n\tg_string_append_printf(str, \"with \");\n#ifdef HAVE_PCAP_LIB_VERSION\n\tg_string_append(str, pcap_lib_version());\n#else\n\tg_string_append(str, \"libpcap (version unknown)\");\n#endif\n}\n\n#else /* HAVE_LIBPCAP */\n\n/*\n * Append an indication that we were not compiled with libpcap\n * to a GString.  Don't even bother mentioning the other\n * libraries.\n */\nvoid\nget_compiled_caplibs_version(GString *str)\n{\n\tg_string_append(str, \"without libpcap\");\n}\n\n/*\n * Don't append anything, as we weren't even compiled to use libpcap.\n */\nvoid\nget_runtime_caplibs_version(GString *str _U_)\n{\n}\n\n#endif /* HAVE_LIBPCAP */\n\n/*\n * Editor modelines  -  http://www.wireshark.org/tools/modelines.html\n *\n * Local variables:\n * c-basic-offset: 8\n * tab-width: 8\n * indent-tabs-mode: t\n * End:\n *\n * vi: set shiftwidth=8 tabstop=8 noexpandtab:\n * :indentSize=8:tabSize=8:noTabs=false:\n */\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsdg_graphics/ws-capture-sync.dia",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsdg_graphics/ws-logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsdg_graphics/ws-capture-sync.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsdg_graphics/ws-function-blocks.dia",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsdg_graphics/ws-capture_internals.dia",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsdg_graphics/ws-capture_internals.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsdg_graphics/ws-function-blocks.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-analyze-menu.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-list-pane.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-print.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-mate-gop_analysis.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-telephony-menu.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-capture-menu.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-mate-isup_over_mtp3_over_ip.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-bytes-pane-popup-menu.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-open-win32.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-stats-compare.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-capture-options-settings.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-time-reference.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-open-gtk24.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/related-other.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-export-selected.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-view-menu.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/related-first.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-choose-color-rule.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-statusbar-selected.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-capture-preferences.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-file-set-dialog.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-statusbar-filter.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-capture-options-manage-interfaces-pipes.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-packet-selected.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-capture-options-output.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-main.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-export-objects.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-printing-preferences.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/related-response.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/related-segment.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-capture-info.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-tcp-analysis.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-coloring-fields.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-file-import.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/captureOptions.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-file-menu.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-stats-lte-mac-traffic.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-bytes-pane.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-expert-infos.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-capture-options.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/related-dup-ack.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-enabled-protocols.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-display-filter-tcp.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-stats-http-requestsequences.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-tel-rtpstream-analysis.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-nameresolution-preferences.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-edit-menu.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-filters.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/related-ack.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-gui-columns-preferences.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-statistics-menu.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-main-toolbar.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-column-header-popup-menu.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-export-plain.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-wireless-menu.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-export-pdml.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-gui-font-preferences.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-decode-as.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-export-ps.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-gui-config-profiles.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-packet-pane-popup-menu.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/related-current.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-mate-pdu_analysis.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-capture-interfaces.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-capture-interfaces-win32.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-follow-stream.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-capture-options-remote-settings.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-find-packet.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-stats-srt-dcerpc-filter.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-capture-interface-details.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-export-psml.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-gui-preferences.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-tools-menu.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-mate-analysis.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-menu.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-gui-layout-preferences.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-merge-gtk24.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-details-pane.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/related-last.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-gui-interface-options.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-mate-dns_pdu.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-mate-ftp_over_gre.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-packet-range.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-filter-toolbar.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-capture-options-remote-interface.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-capture-options-manage-interfaces-remote.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-save-as-win32.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-mate-dns_pane.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-gui-colors-preferences.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-expert-column.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-stats-lte-rlc-traffic.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-stats-summary.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-packet-format.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-capture-options-compile-selected-bpfs.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-packet-sep-win.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-mate-transform.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/related-request.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-details-pane-popup-menu.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-bytes-pane-tabs.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-mate-mmse_over_http.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-help-menu.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-stats-wlan-traffic.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-statusbar-loaded.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-stats-hierarchy.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-filter-add-expression.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-goto-packet.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-merge-win32.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-expert-colored-tree.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-capture-options-manage-interfaces-remote-plus.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-capture-options-manage-interfaces-local.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-statusbar-profile.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-stats-endpoints.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-stats-iographs.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-go-menu.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-capture-options-manage-interfaces.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-stats-conversations.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-save-as-gtk24.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-coloring-rules-dialog.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-mate-tcp-output.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-stats-srt-dcerpc.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-capture-options-remote-capture.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/ws-statusbar-empty.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/toolbar/filter-toolbar-apply.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/toolbar/go-last.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/toolbar/document-open.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/toolbar/edit-find.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/toolbar/x-capture-stop.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/toolbar/x-capture-options.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/toolbar/x-capture-restart.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/toolbar/go-first.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/toolbar/go-next.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/toolbar/x-capture-start.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/toolbar/filter-toolbar-bookmark.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/toolbar/filter-toolbar-input.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/toolbar/x-colorize-packets.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/toolbar/go-previous.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/toolbar/zoom-in.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/toolbar/x-resize-columns.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/toolbar/go-jump.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/toolbar/filter-toolbar-recent.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/toolbar/x-capture-file-close.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/toolbar/x-capture-file-reload.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/toolbar/stock_apply_20.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/toolbar/zoom-original.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/toolbar/filter-toolbar-clear.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/toolbar/filter-toolbar-add.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/toolbar/zoom-out.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/toolbar/x-capture-file-save.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/wsug_graphics/toolbar/x-stay-last.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/docbook/examples/test.cap",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/idl/gias/uco.idl",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/packaging/wix/banner.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/packaging/wix/dialog.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/packaging/macosx/Wiresharkdoc.icns",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/packaging/macosx/dmg_background.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/packaging/macosx/Wireshark.icns",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/minus-8.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/wsiconinst256.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/wsicon128.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/wsicon16.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/wsiconcap48.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/wsiconcap256.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/wsiconinst48.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/wsicon1024.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/wsiconcap512.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/wsicon512.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/wsicon48.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/arrow_down.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/delete_list.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/wiresharkinst.ico",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/layout_3.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/wsicon24.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/wiresharkcapture.ico",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/wireshark.ico",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/wsiconcap128.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/wsiconcap1024.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/arrow_down@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/WiresharkDoc-24.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/arrow_up@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/capture_comment_disabled.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/plus-8.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/WiresharkDoc-256.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/wsicon-ask.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/WiresharkDoc-48.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/WiresharkDoc-128.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/wsiconinst32.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/copy-8.xcf",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/layout_2.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/wsiconinst64.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/layout_3@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/wsiconinst16.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/WiresharkDoc-32.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/layout_4.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/layout_1@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/wsiconinst512.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/layout_5.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/wsiconcap16.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/layout_4@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/wssplash.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/layout_5@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/layout_1.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/wsiconcap32.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/layout_6.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/arrow_up.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/wsiconinst24.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/layout_6@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/WiresharkDoc-64.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/wssplash_dev.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/wsiconcap64.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/WiresharkDoc-16.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/copy-8.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/wsicon32.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/wsicon64.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/wiresharkdoc.ico",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/wsiconinst1024.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/wsiconinst128.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/layout_2@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/wsiconcap24.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/delete_list@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/capture_comment_add.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/capture_comment_update.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/wsicon256.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/24x24/go-last.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/24x24/x-capture-file-reload@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/24x24/zoom-out@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/24x24/go-first@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/24x24/go-next@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/24x24/edit-find.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/24x24/x-colorize-packets@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/24x24/edit-find@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/24x24/x-capture-stop.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/24x24/x-capture-stop@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/24x24/x-capture-options.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/24x24/zoom-in@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/24x24/x-resize-columns@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/24x24/x-capture-restart.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/24x24/zoom-original@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/24x24/go-first.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/24x24/go-jump@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/24x24/x-capture-file-close@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/24x24/go-next.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/24x24/x-capture-start.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/24x24/x-capture-start.on@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/24x24/go-last@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/24x24/x-colorize-packets.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/24x24/go-previous.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/24x24/x-capture-restart@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/24x24/x-capture-options@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/24x24/x-stay-last@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/24x24/zoom-in.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/24x24/x-capture-start.on.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/24x24/x-resize-columns.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/24x24/go-jump.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/24x24/x-capture-file-save@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/24x24/x-capture-file-close.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/24x24/x-capture-file-reload.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/24x24/zoom-original.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/24x24/go-previous@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/24x24/zoom-out.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/24x24/x-capture-file-save.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/24x24/x-capture-start@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/24x24/x-stay-last.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/24x14/x-filter-apply.active.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/24x14/x-filter-apply.selected.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/24x14/x-filter-apply.active@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/24x14/x-filter-apply@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/24x14/x-filter-apply.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/24x14/x-filter-apply.selected@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/14x14/x-display-filter-bookmark.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/14x14/x-filter-deprecated@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/14x14/x-expert-note@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/14x14/x-expert-warn.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/14x14/x-capture-comment-update.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/14x14/x-capture-filter-bookmark.active.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/14x14/x-capture-filter-bookmark.selected.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/14x14/x-filter-clear@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/14x14/x-expert-chat@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/14x14/x-filter-clear.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/14x14/x-expert-error.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/14x14/x-filter-matching-bookmark.active@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/14x14/x-filter-matching-bookmark.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/14x14/x-filter-matching-bookmark@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/14x14/x-expert-note.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/14x14/x-capture-filter-bookmark.selected@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/14x14/x-filter-matching-bookmark.selected.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/14x14/x-display-filter-bookmark.active@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/14x14/x-filter-dropdown.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/14x14/x-filter-deprecated.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/14x14/x-filter-dropdown@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/14x14/x-capture-filter-bookmark.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/14x14/x-display-filter-bookmark.selected@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/14x14/x-expert-warn@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/14x14/x-filter-matching-bookmark.selected@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/14x14/x-filter-invalid@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/14x14/x-display-filter-bookmark.selected.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/14x14/x-capture-comment-update@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/14x14/x-filter-invalid.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/14x14/x-filter-clear.selected.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/14x14/x-filter-clear.active.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/14x14/x-expert-chat.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/14x14/x-filter-clear.selected@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/14x14/x-capture-filter-bookmark.active@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/14x14/x-display-filter-bookmark@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/14x14/x-expert-none@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/14x14/x-expert-none.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/14x14/x-display-filter-bookmark.active.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/14x14/x-expert-error@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/14x14/x-capture-filter-bookmark@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/14x14/x-filter-clear.active@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/14x14/x-filter-matching-bookmark.active.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/16x16/go-last.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/16x16/x-capture-file-reload@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/16x16/zoom-out@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/16x16/go-first@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/16x16/go-next@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/16x16/edit-find.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/16x16/x-colorize-packets@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/16x16/edit-find@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/16x16/x-capture-stop.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/16x16/x-capture-stop@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/16x16/x-capture-options.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/16x16/zoom-in@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/16x16/x-resize-columns@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/16x16/x-capture-restart.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/16x16/zoom-original@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/16x16/go-first.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/16x16/go-jump@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/16x16/x-capture-file-close@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/16x16/go-next.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/16x16/x-capture-start.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/16x16/x-capture-start.on@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/16x16/go-last@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/16x16/x-colorize-packets.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/16x16/go-previous.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/16x16/x-capture-restart@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/16x16/x-capture-options@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/16x16/x-stay-last@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/16x16/zoom-in.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/16x16/x-capture-start.on.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/16x16/x-resize-columns.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/16x16/go-jump.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/16x16/x-capture-file-save@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/16x16/x-capture-file-close.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/16x16/x-capture-file-reload.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/16x16/zoom-original.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/16x16/go-previous@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/16x16/zoom-out.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/16x16/x-capture-file-save.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/16x16/x-capture-start@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/image/stock_icons/16x16/x-stay-last.png",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/epan/dissectors/asn1/rnsap/RNSAP-IEs.asn",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/epan/dissectors/asn1/rnsap/RNSAP-Constants.asn",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/epan/dissectors/asn1/rnsap/RNSAP-PDU-Contents.asn",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/epan/dissectors/asn1/ranap/RANAP-PDU-Contents.asn",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/epan/dissectors/asn1/ranap/RANAP-IEs.asn",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/epan/dissectors/asn1/gsm_map/MAP-MS-DataTypes.asn",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/epan/dissectors/asn1/gsm_map/MAP-CommonDataTypes.asn",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/epan/dissectors/asn1/gsm_map/MAP-LCS-DataTypes.asn",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/keys/krb-816.keytab",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/keys/key.p12",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/lua/pcre_sets.lua",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/ikev2-decrypt-aes256gcm16.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/ikev2-decrypt-aes256gcm8.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/dns+icmp.pcapng.gz",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/tls12-chacha20poly1305.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/esp-bug-12671.pcapng.gz",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/tls13-20-chacha20poly1305.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/http-ooo2.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/http.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/ntp.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/rsa-p-lt-q.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/udt-dtls.pcapng.gz",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/ikev1-bug-12620.pcapng.gz",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/http-ooo.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/ikev2-decrypt-3des-sha1_160.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/dhe1.pcapng.gz",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/wpa-test-decode-tdls.pcap.gz",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/knxip_SecureWrapper.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/wpa-test-decode.pcap.gz",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/snakeoil-dtls.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/dtls12-aes128ccm8.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/dhcp.pcapng",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/wireguard-psk.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/knxip_DataSec.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/c1222_std_example8.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/ikev2-decrypt-aes192ctr.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/ikev1-bug-12610.pcapng.gz",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/dhcp-nanosecond.pcapng",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/wireguard-ping-tcp.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/empty.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/dns-ooo.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/dhcp.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/tls12-aes128ccm.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/retrans-tls.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/tls-renegotiation.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/ipv6.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/segmented_fpm.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/dhcp-nanosecond.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/icmp.pcapng.gz",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/http2-data-reassembly.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/wpa-eap-tls.pcap.gz",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/knxip_TimerNotify.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/dmgr.pcapng",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/ikev2-decrypt-aes256ccm16.pcapng",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/sample_control4_2012-03-24.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/many_interfaces.pcapng.3",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/many_interfaces.pcapng.2",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/ikev2-decrypt-aes256cbc.pcapng",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/ikev2-decrypt-aes128ccm12-2.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/nfs.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/dvb-ci_UV1_0000.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/wpa-test-decode-mgmt.pcap.gz",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/tcp-badsegments.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/rsasnakeoil2.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/smb300-aes-128-ccm.pcap.gz",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/ikev2-decrypt-aes128ccm12.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/packet-h2-14_headers.pcapng",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/ikev1-certs.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/tls12-aes256gcm.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/wpa-Induction.pcap.gz",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/ipx_rip.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/many_interfaces.pcapng.1",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/tls13-rfc8446.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/dtls12-aes128ccm8-dsb.pcapng",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/tftp.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/krb-816.pcap.gz",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/smb311-aes-128-ccm.pcap.gz",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/sip.pcapng",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/arp.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/tls12-dsb.pcapng",
        "/tmp/vanessa/spack-stage/spack-stage-wireshark-3.0.8-pkzmxjqo33f4sre6ynrwb6aux747cii4/spack-src/test/captures/dns_port.pcap"
    ],
    "total_files": 5835
}