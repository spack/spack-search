{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/gdk-pixbuf/gdk-pixbuf-io.c": "/* GdkPixbuf library - Main loading interface.\n *\n * Copyright (C) 1999 The Free Software Foundation\n *\n * Authors: Miguel de Icaza <miguel@gnu.org>\n *          Federico Mena-Quintero <federico@gimp.org>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"config.h\"\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n\n#include <glib.h>\n#include <gio/gio.h>\n\n#include \"gdk-pixbuf-private.h\"\n#include \"gdk-pixbuf-loader.h\"\n#include \"gdk-pixdata.h\"\n\n#include <glib/gstdio.h>\n\n#ifdef G_OS_WIN32\n#define STRICT\n#include <windows.h>\n#undef STRICT\n#endif\n#ifdef OS_DARWIN\n#include <mach-o/dyld.h>\n#endif\n\n/**\n * SECTION:file-loading\n * @Short_description: Loading a pixbuf from a file.\n * @Title: File Loading\n * @See_also: #GdkPixbufLoader.\n * \n * The GdkPixBuf library provides a simple mechanism for loading\n * an image from a file in synchronous fashion.  This means that the\n * library takes control of the application while the file is being\n * loaded; from the user's point of view, the application will block\n * until the image is done loading.\n * \n * \n * This interface can be used by applications in which blocking is\n * acceptable while an image is being loaded.  It can also be used to\n * load small images in general.  Applications that need progressive\n * loading can use the #GdkPixbufLoader functionality instead.\n */\n\n/**\n * SECTION:file-saving\n * @Short_description: Saving a pixbuf to a file.\n * @Title: File saving\n * \n * These functions allow to save a #GdkPixbuf in a number of \n * file formats. The formatted data can be written to a file\n * or to a memory buffer. GdkPixBuf can also call a user-defined\n * callback on the data, which allows to e.g. write the image \n * to a socket or store it in a database.\n */\n\n/**\n * SECTION:module_interface\n * @Short_description: Extending GdkPixBuf\n * @Title: Module Interface\n * \n * If GdkPixBuf has been compiled with GModule support, it can be extended by\n * modules which can load (and perhaps also save) new image and animation\n * formats. Each loadable module must export a\n * #GdkPixbufModuleFillInfoFunc function named `fill_info` and\n * a #GdkPixbufModuleFillVtableFunc function named\n * `fill_vtable`.\n * \n * In order to make format-checking work before actually loading the modules\n * (which may require dlopening image libraries), modules export their \n * signatures (and other information) via the `fill_info` function. An\n * external utility, gdk-pixbuf-query-loaders, uses this to create a text\n * file containing a list of all available loaders and  their signatures.\n * This file is then read at runtime by GdkPixBuf to obtain the list of\n * available loaders and their signatures. \n * \n * Modules may only implement a subset of the functionality available via\n * #GdkPixbufModule. If a particular functionality is not implemented, the\n * `fill_vtable` function will simply not set the corresponding\n * function pointers of the #GdkPixbufModule structure. If a module supports\n * incremental loading (i.e. provides #begin_load, #stop_load and\n * #load_increment), it doesn't have to implement #load, since GdkPixBuf can\n * supply a generic #load implementation wrapping the incremental loading. \n * \n * Installing a module is a two-step process:\n * - copy the module file(s) to the loader directory (normally\n *   `$libdir/gdk-pixbuf-2.0/$version/loaders`, unless overridden by the\n *   environment variable `GDK_PIXBUF_MODULEDIR`) \n * - call gdk-pixbuf-query-loaders to update the module file (normally\n *   `$libdir/gdk-pixbuf-2.0/$version/loaders.cache`, unless overridden by the\n *   environment variable `GDK_PIXBUF_MODULE_FILE`)\n * \n * The GdkPixBuf interfaces needed for implementing modules are contained in\n * `gdk-pixbuf-io.h` (and `gdk-pixbuf-animation.h` if the module supports\n * animations). They are not covered by the same stability guarantees as the\n * regular  GdkPixBuf API. To underline this fact, they are protected by\n * `#ifdef GDK_PIXBUF_ENABLE_BACKEND`.\n */\n\n\nstatic gint \nformat_check (GdkPixbufModule *module, guchar *buffer, int size)\n{\n        int i, j;\n        gchar m;\n        GdkPixbufModulePattern *pattern;\n        gboolean anchored;\n        guchar *prefix;\n        gchar *mask;\n\n        for (pattern = module->info->signature; pattern->prefix; pattern++) {\n                if (pattern->mask && pattern->mask[0] == '*') {\n                        prefix = (guchar *)pattern->prefix + 1;\n                        mask = pattern->mask + 1;\n                        anchored = FALSE;\n                }\n                else {\n                        prefix = (guchar *)pattern->prefix;\n                        mask = pattern->mask;\n                        anchored = TRUE;\n                }\n                for (i = 0; i < size; i++) {\n                        for (j = 0; i + j < size && prefix[j] != 0; j++) {\n                                m = mask ? mask[j] : ' ';\n                                if (m == ' ') {\n                                        if (buffer[i + j] != prefix[j])\n                                                break;\n                                }\n                                else if (m == '!') {\n                                        if (buffer[i + j] == prefix[j])\n                                                break;\n                                }\n                                else if (m == 'z') {\n                                        if (buffer[i + j] != 0)\n                                                break;\n                                }\n                                else if (m == 'n') {\n                                        if (buffer[i + j] == 0)\n                                                break;\n                                }\n                        } \n\n                        if (prefix[j] == 0) \n                                return pattern->relevance;\n\n                        if (anchored)\n                                break;\n                }\n        }\n        return 0;\n}\n\nG_LOCK_DEFINE_STATIC (init_lock);\n\nstatic gboolean file_formats_inited;\nstatic GSList *file_formats = NULL;\n\nstatic gboolean gdk_pixbuf_io_init (void);\n\nstatic GSList *\nget_file_formats (void)\n{\n        G_LOCK (init_lock);\n        if (file_formats == NULL ||\n            !file_formats_inited)\n                file_formats_inited = gdk_pixbuf_io_init ();\n        G_UNLOCK (init_lock);\n        \n        return file_formats;\n}\n\n#ifdef G_OS_WIN32\n\n/* DllMain function needed to tuck away the gdk-pixbuf DLL handle */\n\nstatic HMODULE gdk_pixbuf_dll;\n\nBOOL WINAPI\nDllMain (HINSTANCE hinstDLL,\n         DWORD     fdwReason,\n         LPVOID    lpvReserved)\n{\n        switch (fdwReason) {\n        case DLL_PROCESS_ATTACH:\n                gdk_pixbuf_dll = (HMODULE) hinstDLL;\n                break;\n        }\n\n  return TRUE;\n}\n#endif\n\n\n#ifdef GDK_PIXBUF_RELOCATABLE\n\ngchar *\ngdk_pixbuf_get_toplevel (void)\n{\n  static gchar *toplevel = NULL;\n\n  if (toplevel == NULL) {\n#if defined(G_OS_WIN32)\n    toplevel = g_win32_get_package_installation_directory_of_module (gdk_pixbuf_dll);\n#elif defined(OS_DARWIN)\n    char pathbuf[PATH_MAX + 1];\n    uint32_t  bufsize = sizeof(pathbuf);\n    gchar *bin_dir;\n\n    _NSGetExecutablePath(pathbuf, &bufsize);\n    bin_dir = g_dirname(pathbuf);\n    toplevel = g_build_path (G_DIR_SEPARATOR_S, bin_dir, \"..\", NULL);\n    g_free (bin_dir);\n#elif defined (OS_LINUX)\n    gchar *exe_path, *bin_dir;\n\n    exe_path = g_file_read_link (\"/proc/self/exe\", NULL);\n    bin_dir = g_dirname(exe_path);\n    toplevel = g_build_path (G_DIR_SEPARATOR_S, bin_dir, \"..\", NULL);\n    g_free (exe_path);\n    g_free (bin_dir);\n#else\n#error \"Relocations not supported for this platform\"\n#endif\n  }\n  return toplevel;\n}\n\n#endif  /* GDK_PIXBUF_RELOCATABLE */\n\n\n#ifdef USE_GMODULE \n\nstatic gboolean\nscan_string (const char **pos, GString *out)\n{\n        const char *p = *pos, *q = *pos;\n        char *tmp, *tmp2;\n        gboolean quoted;\n        \n        while (g_ascii_isspace (*p))\n                p++;\n        \n        if (!*p)\n                return FALSE;\n        else if (*p == '\"') {\n                p++;\n                quoted = FALSE;\n                for (q = p; (*q != '\"') || quoted; q++) {\n                        if (!*q)\n                                return FALSE;\n                        quoted = (*q == '\\\\') && !quoted;\n                }\n                \n                tmp = g_strndup (p, q - p);\n                tmp2 = g_strcompress (tmp);\n                g_string_truncate (out, 0);\n                g_string_append (out, tmp2);\n                g_free (tmp);\n                g_free (tmp2);\n        }\n        \n        q++;\n        *pos = q;\n        \n        return TRUE;\n}\n\nstatic gboolean\nscan_int (const char **pos, int *out)\n{\n        int i = 0;\n        char buf[32];\n        const char *p = *pos;\n        \n        while (g_ascii_isspace (*p))\n                p++;\n        \n        if (*p < '0' || *p > '9')\n                return FALSE;\n        \n        while ((*p >= '0') && (*p <= '9') && i < sizeof (buf)) {\n                buf[i] = *p;\n                i++;\n                p++;\n        }\n        \n        if (i == sizeof (buf))\n                return FALSE;\n        else\n                buf[i] = '\\0';\n        \n        *out = atoi (buf);\n        \n        *pos = p;\n\n        return TRUE;\n}\n\nstatic gboolean\nskip_space (const char **pos)\n{\n        const char *p = *pos;\n        \n        while (g_ascii_isspace (*p))\n                p++;\n  \n        *pos = p;\n        \n        return !(*p == '\\0');\n}\n\n#ifdef GDK_PIXBUF_RELOCATABLE\n\nstatic char *\nget_libdir (void)\n{\n  static char *libdir = NULL;\n\n  if (libdir == NULL)\n          libdir = g_build_filename (gdk_pixbuf_get_toplevel (), \"lib\", NULL);\n\n  return libdir;\n}\n\n#undef GDK_PIXBUF_LIBDIR\n#define GDK_PIXBUF_LIBDIR get_libdir()\n\n#endif  /* GDK_PIXBUF_RELOCATABLE */\n\n/* In case we have a relative module path in the loaders cache\n * prepend the toplevel dir */\nstatic gchar *\nbuild_module_path (const gchar *path)\n{\n#ifdef GDK_PIXBUF_RELOCATABLE\n        if (g_path_is_absolute (path)) {\n                return g_strdup (path);\n        } else {\n                return g_build_filename (gdk_pixbuf_get_toplevel (), path, NULL);\n        }\n#else\n        return g_strdup (path);\n#endif\n}\n\nstatic gchar *\ngdk_pixbuf_get_module_file (void)\n{\n  gchar *result = g_strdup (g_getenv (\"GDK_PIXBUF_MODULE_FILE\"));\n\n  if (!result)\n          result = g_build_filename (GDK_PIXBUF_LIBDIR, \"gdk-pixbuf-2.0\", GDK_PIXBUF_BINARY_VERSION, \"loaders.cache\", NULL);\n\n  return result;\n}\n\n#endif  /* USE_GMODULE */\n\n\nstatic gboolean\ngdk_pixbuf_load_module_unlocked (GdkPixbufModule *image_module,\n                                 GError         **error);\n\nstatic gboolean\ngdk_pixbuf_io_init_modules (const char  *filename,\n                            GError     **error)\n{\n#ifdef USE_GMODULE\n        GIOChannel *channel;\n        gchar *line_buf;\n        gsize term;\n        GString *tmp_buf = g_string_new (NULL);\n        gboolean have_error = FALSE;\n        GdkPixbufModule *module = NULL;\n        int flags;\n        int n_patterns = 0;\n        GdkPixbufModulePattern *pattern;\n        GError *local_error = NULL;\n        guint num_formats;\n\n        channel = g_io_channel_new_file (filename, \"r\",  &local_error);\n        if (!channel) {\n                g_set_error (error,\n                             G_IO_ERROR,\n                             G_IO_ERROR_INVALID_ARGUMENT,\n                             \"Cannot open pixbuf loader module file '%s': %s\\n\\n\"\n                             \"This likely means that your installation is broken.\\n\"\n                             \"Try running the command\\n\"\n                             \"  gdk-pixbuf-query-loaders > %s\\n\"\n                             \"to make things work again for the time being.\",\n                             filename, local_error->message, filename);\n                g_clear_error (&local_error);\n                g_string_free (tmp_buf, TRUE);\n                return FALSE;\n        }\n\n        num_formats = g_slist_length (file_formats);\n        \n        while (!have_error && g_io_channel_read_line (channel, &line_buf, NULL, &term, NULL) == G_IO_STATUS_NORMAL) {\n                const char *p;\n                \n                p = line_buf;\n\n                line_buf[term] = 0;\n\n                if (!skip_space (&p)) {\n                                /* Blank line marking the end of a module\n                                 */\n                        if (module && *p != '#') {\n                                file_formats = g_slist_prepend (file_formats, module);\n                                module = NULL;\n                        }\n                        \n                        goto next_line;\n                }\n\n                if (*p == '#') \n                        goto next_line;\n                \n                if (!module) {\n                                /* Read a module location\n                                 */\n                        module = g_new0 (GdkPixbufModule, 1);\n                        n_patterns = 0;\n                        \n                        if (!scan_string (&p, tmp_buf)) {\n                                g_warning (\"Error parsing loader info in '%s'\\n  %s\", \n                                           filename, line_buf);\n                                have_error = TRUE;\n                        }\n                        module->module_path = build_module_path (tmp_buf->str);\n                }\n                else if (!module->module_name) {\n                        module->info = g_new0 (GdkPixbufFormat, 1);\n                        if (!scan_string (&p, tmp_buf)) {\n                                g_warning (\"Error parsing loader info in '%s'\\n  %s\", \n                                           filename, line_buf);\n                                have_error = TRUE;\n                        }\n                        module->info->name =  g_strdup (tmp_buf->str);\n                        module->module_name = module->info->name;\n\n                        if (!scan_int (&p, &flags)) {\n                                g_warning (\"Error parsing loader info in '%s'\\n  %s\", \n                                           filename, line_buf);\n                                have_error = TRUE;\n                        }\n                        module->info->flags = flags;\n                        \n                        if (!scan_string (&p, tmp_buf)) {\n                                g_warning (\"Error parsing loader info in '%s'\\n  %s\", \n                                           filename, line_buf);\n                                have_error = TRUE;\n                        }                       \n                        if (tmp_buf->str[0] != 0)\n                                module->info->domain = g_strdup (tmp_buf->str);\n\n                        if (!scan_string (&p, tmp_buf)) {\n                                g_warning (\"Error parsing loader info in '%s'\\n  %s\", \n                                           filename, line_buf);\n                                have_error = TRUE;\n                        }                       \n                        module->info->description = g_strdup (tmp_buf->str);\n\n                        if (scan_string (&p, tmp_buf)) {\n                                module->info->license = g_strdup (tmp_buf->str);\n                        }\n                }\n                else if (!module->info->mime_types) {\n                        int n = 1;\n                        module->info->mime_types = g_new0 (gchar*, 1);\n                        while (scan_string (&p, tmp_buf)) {\n                                if (tmp_buf->str[0] != 0) {\n                                        module->info->mime_types =\n                                                g_realloc (module->info->mime_types, (n + 1) * sizeof (gchar*));\n                                        module->info->mime_types[n - 1] = g_strdup (tmp_buf->str);\n                                        module->info->mime_types[n] = NULL;\n                                        n++;\n                                }\n                        }\n                }\n                else if (!module->info->extensions) {\n                        int n = 1;\n                        module->info->extensions = g_new0 (gchar*, 1);\n                        while (scan_string (&p, tmp_buf)) {\n                                if (tmp_buf->str[0] != 0) {\n                                        module->info->extensions =\n                                                g_realloc (module->info->extensions, (n + 1) * sizeof (gchar*));\n                                        module->info->extensions[n - 1] = g_strdup (tmp_buf->str);\n                                        module->info->extensions[n] = NULL;\n                                        n++;\n                                }\n                        }\n                }\n                else {\n                        n_patterns++;\n                        module->info->signature = (GdkPixbufModulePattern *)\n                                g_realloc (module->info->signature, (n_patterns + 1) * sizeof (GdkPixbufModulePattern));\n                        pattern = module->info->signature + n_patterns;\n                        pattern->prefix = NULL;\n                        pattern->mask = NULL;\n                        pattern->relevance = 0;\n                        pattern--;\n                        if (!scan_string (&p, tmp_buf))\n                                goto context_error;\n                        pattern->prefix = g_strdup (tmp_buf->str);\n                        \n                        if (!scan_string (&p, tmp_buf))\n                                goto context_error;\n                        if (*tmp_buf->str)\n                                pattern->mask = g_strdup (tmp_buf->str);\n                        else\n                                pattern->mask = NULL;\n                        \n                        if (!scan_int (&p, &pattern->relevance))\n                                goto context_error;\n                        \n                        goto next_line;\n\n                context_error:\n                        g_free (pattern->prefix);\n                        g_free (pattern->mask);\n                        g_free (pattern);\n                        g_warning (\"Error parsing loader info in '%s'\\n  %s\", \n                                   filename, line_buf);\n                        have_error = TRUE;\n                }\n        next_line:\n                g_free (line_buf);\n        }\n        g_string_free (tmp_buf, TRUE);\n        g_io_channel_unref (channel);\n\n        if (g_slist_length (file_formats) <= num_formats) {\n                g_set_error (error,\n                             G_IO_ERROR,\n                             G_IO_ERROR_NOT_INITIALIZED,\n                             \"No new GdkPixbufModule loaded from '%s'\",\n                             filename);\n                return FALSE;\n        }\n#endif\n        return TRUE;\n}\n\n/**\n * gdk_pixbuf_init_modules:\n * @path: Path to directory where the loaders.cache is installed\n * @error: return location for a #GError\n *\n * Initalizes the gdk-pixbuf loader modules referenced by the loaders.cache\n * file present inside that directory.\n *\n * This is to be used by applications that want to ship certain loaders\n * in a different location from the system ones.\n *\n * This is needed when the OS or runtime ships a minimal number of loaders\n * so as to reduce the potential attack surface of carefully crafted image\n * files, especially for uncommon file types. Applications that require\n * broader image file types coverage, such as image viewers, would be\n * expected to ship the gdk-pixbuf modules in a separate location, bundled\n * with the application in a separate directory from the OS or runtime-\n * provided modules.\n *\n * Since: 2.40\n */\ngboolean\ngdk_pixbuf_init_modules (const char  *path,\n\t\t\t GError     **error)\n{\n\tchar *filename;\n\tgboolean ret;\n\n\tg_return_val_if_fail (path != NULL, FALSE);\n\tfilename = g_build_filename (path, \"loaders.cache\", NULL);\n\tret = gdk_pixbuf_io_init_modules (filename, error);\n\tg_free (filename);\n\treturn ret;\n}\n\nstatic void\ngdk_pixbuf_io_init_builtin (void)\n{\n#define load_one_builtin_module(format)                                 G_STMT_START { \\\n        GdkPixbufModule *__builtin_module = g_new0 (GdkPixbufModule, 1);               \\\n        __builtin_module->module_name = #format;                                       \\\n        if (gdk_pixbuf_load_module_unlocked (__builtin_module, NULL))                  \\\n                file_formats = g_slist_prepend (file_formats, __builtin_module);       \\\n        else                                                                           \\\n                g_free (__builtin_module);                              } G_STMT_END\n\n#ifdef INCLUDE_ani\n        load_one_builtin_module (ani);\n#endif\n#ifdef INCLUDE_png\n        load_one_builtin_module (png);\n#endif\n#ifdef INCLUDE_bmp\n        load_one_builtin_module (bmp);\n#endif\n#ifdef INCLUDE_gif\n        load_one_builtin_module (gif);\n#endif\n#ifdef INCLUDE_ico\n        load_one_builtin_module (ico);\n#endif\n#ifdef INCLUDE_jpeg\n        load_one_builtin_module (jpeg);\n#endif\n#ifdef INCLUDE_pnm\n        load_one_builtin_module (pnm);\n#endif\n#ifdef INCLUDE_tiff\n        load_one_builtin_module (tiff);\n#endif\n#ifdef INCLUDE_xpm\n        load_one_builtin_module (xpm);\n#endif\n#ifdef INCLUDE_xbm\n        load_one_builtin_module (xbm);\n#endif\n#ifdef INCLUDE_tga\n        load_one_builtin_module (tga);\n#endif\n#ifdef INCLUDE_icns\n        load_one_builtin_module (icns);\n#endif\n#ifdef INCLUDE_jasper\n        load_one_builtin_module (jasper);\n#endif\n#ifdef INCLUDE_qtif\n        load_one_builtin_module (qtif);\n#endif\n#ifdef INCLUDE_gdiplus\n        /* We don't bother having the GDI+ loaders individually selectable\n         * for building in or not.\n         */\n        load_one_builtin_module (ico);\n        load_one_builtin_module (wmf);\n        load_one_builtin_module (emf);\n        load_one_builtin_module (bmp);\n        load_one_builtin_module (gif);\n        load_one_builtin_module (jpeg);\n        load_one_builtin_module (tiff);\n#endif\n#ifdef INCLUDE_gdip_png\n        /* Except the gdip-png loader which normally isn't built at all even */\n        load_one_builtin_module (png);\n#endif\n\n#undef load_one_builtin_module\n}\n\nstatic gboolean\ngdk_pixbuf_io_init (void)\n{\n\tchar *module_file;\n\tgboolean ret;\n\n\tgdk_pixbuf_io_init_builtin ();\n\tmodule_file = gdk_pixbuf_get_module_file ();\n\tret = gdk_pixbuf_io_init_modules (module_file, NULL);\n\tg_free (module_file);\n\treturn ret;\n}\n\n#define module(type) \\\n  extern void _gdk_pixbuf__##type##_fill_info   (GdkPixbufFormat *info);   \\\n  extern void _gdk_pixbuf__##type##_fill_vtable (GdkPixbufModule *module)\n\nmodule (png);\nmodule (jpeg);\nmodule (gif);\nmodule (ico);\nmodule (ani);\nmodule (xpm);\nmodule (tiff);\nmodule (pnm);\nmodule (bmp);\nmodule (xbm);\nmodule (tga);\nmodule (icns);\nmodule (jasper);\nmodule (qtif);\nmodule (gdip_ico);\nmodule (gdip_wmf);\nmodule (gdip_emf);\nmodule (gdip_bmp);\nmodule (gdip_gif);\nmodule (gdip_jpeg);\nmodule (gdip_png);\nmodule (gdip_tiff);\n\n#undef module\n\n/* actually load the image handler - gdk_pixbuf_get_module only get a */\n/* reference to the module to load, it doesn't actually load it       */\n/* perhaps these actions should be combined in one function           */\nstatic gboolean\ngdk_pixbuf_load_module_unlocked (GdkPixbufModule *image_module,\n                                 GError         **error)\n{\n        GdkPixbufModuleFillInfoFunc fill_info = NULL;\n        GdkPixbufModuleFillVtableFunc fill_vtable = NULL;\n                \n        if (image_module->module != NULL)\n               return TRUE;\n\n#define try_module(format,id)                                           \\\n        if (fill_info == NULL &&                                        \\\n            strcmp (image_module->module_name, #format) == 0) {         \\\n                fill_info = _gdk_pixbuf__##id##_fill_info;              \\\n                fill_vtable = _gdk_pixbuf__##id##_fill_vtable;  \\\n        }\n\n#ifdef INCLUDE_gdiplus\n        try_module (ico,gdip_ico);\n        try_module (wmf,gdip_wmf);\n        try_module (emf,gdip_emf);\n        try_module (bmp,gdip_bmp);\n        try_module (gif,gdip_gif);\n        try_module (jpeg,gdip_jpeg);\n        try_module (tiff,gdip_tiff);\n#endif\n#ifdef INCLUDE_gdip_png\n        try_module (png,gdip_png);\n#endif\n#ifdef INCLUDE_png\n        try_module (png,png);\n#endif\n#ifdef INCLUDE_bmp\n        try_module (bmp,bmp);\n#endif\n#ifdef INCLUDE_gif\n        try_module (gif,gif);\n#endif\n#ifdef INCLUDE_ico\n        try_module (ico,ico);\n#endif\n#ifdef INCLUDE_ani\n        try_module (ani,ani);\n#endif\n#ifdef INCLUDE_jpeg\n        try_module (jpeg,jpeg);\n#endif\n#ifdef INCLUDE_pnm\n        try_module (pnm,pnm);\n#endif\n#ifdef INCLUDE_tiff\n        try_module (tiff,tiff);\n#endif\n#ifdef INCLUDE_xpm\n        try_module (xpm,xpm);\n#endif\n#ifdef INCLUDE_xbm\n        try_module (xbm,xbm);\n#endif\n#ifdef INCLUDE_tga\n        try_module (tga,tga);\n#endif\n#ifdef INCLUDE_icns\n        try_module (icns,icns);\n#endif\n#ifdef INCLUDE_jasper\n        try_module (jasper,jasper);\n#endif\n#ifdef INCLUDE_qtif\n        try_module (qtif,qtif);\n#endif\n\n#undef try_module\n        \n        if (fill_vtable) {\n                image_module->module = (void *) 1;\n                (* fill_vtable) (image_module);\n                if (image_module->info == NULL) {\n                        image_module->info = g_new0 (GdkPixbufFormat, 1);\n                        (* fill_info) (image_module->info);\n                }\n                return TRUE;\n        }\n        else \n#ifdef USE_GMODULE\n        {\n                char *path;\n                GModule *module;\n                gpointer sym;\n\n                path = image_module->module_path;\n                module = g_module_open (path, G_MODULE_BIND_LAZY | G_MODULE_BIND_LOCAL);\n\n                if (!module) {\n                        g_set_error (error,\n                                     GDK_PIXBUF_ERROR,\n                                     GDK_PIXBUF_ERROR_FAILED,\n                                     _(\"Unable to load image-loading module: %s: %s\"),\n                                     path, g_module_error ());\n                        return FALSE;\n                }\n\n                image_module->module = module;        \n        \n                if (g_module_symbol (module, \"fill_vtable\", &sym)) {\n                        fill_vtable = (GdkPixbufModuleFillVtableFunc) sym;\n                        (* fill_vtable) (image_module);\n                        return TRUE;\n                } else {\n                        g_set_error (error,\n                                     GDK_PIXBUF_ERROR,\n                                     GDK_PIXBUF_ERROR_FAILED,\n                                     _(\"Image-loading module %s does not export the proper interface; perhaps it\u2019s from a different gdk-pixbuf version?\"),\n                                     path);\n                        return FALSE;\n                }\n        }\n#else\n        g_set_error (error,\n                     GDK_PIXBUF_ERROR,\n                     GDK_PIXBUF_ERROR_UNKNOWN_TYPE,\n                     _(\"Image type \u201c%s\u201d is not supported\"),\n                     image_module->module_name);\n        return FALSE;\n#endif  /* !USE_GMODULE */\n}\n\n\ngboolean\n_gdk_pixbuf_load_module (GdkPixbufModule *image_module,\n                         GError         **error)\n{\n        gboolean ret;\n\n        G_LOCK (init_lock);\n\n        ret = gdk_pixbuf_load_module_unlocked (image_module, error);\n\n        G_UNLOCK (init_lock);\n\n        return ret;\n}\n\n\f\n\nGdkPixbufModule *\n_gdk_pixbuf_get_named_module (const char *name,\n                              GError **error)\n{\n        GSList *modules;\n\n        for (modules = get_file_formats (); modules; modules = g_slist_next (modules)) {\n                GdkPixbufModule *module = (GdkPixbufModule *)modules->data;\n\n                if (module->info->disabled)\n                        continue;\n\n                if (!strcmp (name, module->module_name))\n                        return module;\n        }\n\n        g_set_error (error,\n                     GDK_PIXBUF_ERROR,\n                     GDK_PIXBUF_ERROR_UNKNOWN_TYPE,\n                     _(\"Image type \u201c%s\u201d is not supported\"),\n                     name);\n        \n        return NULL;\n}\n\nGdkPixbufModule *\n_gdk_pixbuf_get_module (guchar *buffer, guint size,\n                        const gchar *filename,\n                        GError **error)\n{\n        GSList *modules;\n\n        GdkPixbufModule *selected = NULL;\n        gchar *display_name = NULL;\n#ifdef GDK_PIXBUF_USE_GIO_MIME\n        gchar *mime_type;\n        gchar **mimes;\n        gchar *type;\n        gint j;\n        gboolean uncertain;\n\n        mime_type = g_content_type_guess (NULL, buffer, size, &uncertain);\n        if ((uncertain || g_str_equal (mime_type, \"text/plain\") || g_str_equal (mime_type, \"application/gzip\")) && filename != NULL) {\n                g_free (mime_type);\n                mime_type = g_content_type_guess (filename, buffer, size, NULL);\n        }\n\n        for (modules = get_file_formats (); modules; modules = g_slist_next (modules)) {\n                GdkPixbufModule *module = (GdkPixbufModule *)modules->data;\n                GdkPixbufFormat *info = module->info;\n\n                if (info->disabled)\n                        continue;\n\n                mimes = info->mime_types;\n                for (j = 0; mimes[j] != NULL; j++) {\n                        type = g_content_type_from_mime_type (mimes[j]);\n                        if (g_content_type_equals (type, mime_type)) {\n                                g_free (type);\n                                selected = module;\n                                break;\n                        }\n                        g_free (type);\n                }\n\n                if (selected != NULL)\n                        break;\n\n\t\t/* Make sure the builtin GdkPixdata support works even without mime sniffing */\n\t\tif (strcmp (info->name, \"GdkPixdata\") == 0 &&\n\t\t    format_check (module, buffer, size) == 100) {\n\t\t\tselected = module;\n\t\t\tbreak;\n\t\t}\n        }\n        g_free (mime_type);\n#else\n        gint score, best = 0;\n\n        for (modules = get_file_formats (); modules; modules = g_slist_next (modules)) {\n                GdkPixbufModule *module = (GdkPixbufModule *)modules->data;\n\n                if (module->info->disabled)\n                        continue;\n\n                score = format_check (module, buffer, size);\n                if (score > best) {\n                        best = score; \n                        selected = module;\n                }\n                if (score >= 100) \n                        break;\n        }\n#endif\n\n        if (selected != NULL)\n                return selected;\n\n        if (filename)\n        {\n                display_name = g_filename_display_name (filename);\n                g_set_error (error,\n                             GDK_PIXBUF_ERROR,\n                             GDK_PIXBUF_ERROR_UNKNOWN_TYPE,\n                             _(\"Couldn\u2019t recognize the image file format for file \u201c%s\u201d\"),\n                             display_name);\n                g_free (display_name);\n        }\n        else\n                g_set_error_literal (error,\n                                     GDK_PIXBUF_ERROR,\n                                     GDK_PIXBUF_ERROR_UNKNOWN_TYPE,\n                                     _(\"Unrecognized image file format\"));\n\n\n        return NULL;\n}\n\nstatic\nGdkPixbufModule *\n_gdk_pixbuf_get_module_for_file (FILE *f, const gchar *filename, GError **error)\n{\n        guchar buffer[SNIFF_BUFFER_SIZE];\n        int size;\n\n        size = fread (&buffer, 1, sizeof (buffer), f);\n        if (size == 0) {\n\t\tgchar *display_name;\n        \tdisplay_name = g_filename_display_name (filename);      \n                g_set_error (error,\n                             GDK_PIXBUF_ERROR,\n                             GDK_PIXBUF_ERROR_CORRUPT_IMAGE,\n                             _(\"Image file \u201c%s\u201d contains no data\"),\n                             display_name);\n                g_free (display_name);\n                return NULL;\n        }\n\n\treturn _gdk_pixbuf_get_module (buffer, size, filename, error);\n}\n\nstatic void\nprepared_notify (GdkPixbuf *pixbuf, \n                 GdkPixbufAnimation *anim, \n                 gpointer user_data)\n{\n        if (pixbuf != NULL)\n                g_object_ref (pixbuf);\n        *((GdkPixbuf **)user_data) = pixbuf;\n}\n\nstatic GdkPixbuf *\ngeneric_load_incrementally (GdkPixbufModule *module, FILE *f, GError **error)\n{\n        GdkPixbuf *pixbuf = NULL;\n\tgpointer context;\n\n\tcontext = module->begin_load (NULL, prepared_notify, NULL, &pixbuf, error);\n        \n\tif (!context)\n\t\tgoto out;\n                \n\twhile (!feof (f) && !ferror (f)) {\n\t\tguchar buffer[LOAD_BUFFER_SIZE];\n\t\tsize_t length;\n\n\t\tlength = fread (buffer, 1, sizeof (buffer), f);\n\t\tif (length > 0) {\n\t\t\tif (!module->load_increment (context, buffer, length, error)) {\n\t\t\t\tmodule->stop_load (context, NULL);\n\t\t\t\tif (pixbuf != NULL) {\n\t\t\t\t\tg_object_unref (pixbuf);\n\t\t\t\t\tpixbuf = NULL;\n\t\t\t\t}\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!module->stop_load (context, error)) {\n\t\tif (pixbuf != NULL) {\n\t\t\tg_object_unref (pixbuf);\n\t\t\tpixbuf = NULL;\n\t\t}\n\t}\n\nout:\n\treturn pixbuf;\n}\n\nGdkPixbuf *\n_gdk_pixbuf_generic_image_load (GdkPixbufModule *module, FILE *f, GError **error)\n{\n        GdkPixbuf *pixbuf = NULL;\n\n        if (module->load != NULL) {\n                pixbuf = (* module->load) (f, error);\n        } else if (module->begin_load != NULL) {\n        \tpixbuf = generic_load_incrementally (module, f, error);\n        } else if (module->load_animation != NULL) {\n\t\tGdkPixbufAnimation *animation;\n\n                animation = (* module->load_animation) (f, error);\n                if (animation != NULL) {\n                        pixbuf = gdk_pixbuf_animation_get_static_image (animation);\n\n                        g_object_ref (pixbuf);\n                        g_object_unref (animation);\n                }\n        }\n\n        return pixbuf;\n}\n\n/**\n * gdk_pixbuf_new_from_file:\n * @filename: (type filename): Name of file to load, in the GLib file\n *     name encoding\n * @error: Return location for an error\n *\n * Creates a new pixbuf by loading an image from a file.  The file format is\n * detected automatically. If %NULL is returned, then @error will be set.\n * Possible errors are in the #GDK_PIXBUF_ERROR and #G_FILE_ERROR domains.\n *\n * Return value: A newly-created pixbuf with a reference count of 1, or %NULL if\n * any of several error conditions occurred:  the file could not be opened,\n * there was no loader for the file's format, there was not enough memory to\n * allocate the image buffer, or the image file contained invalid data.\n **/\nGdkPixbuf *\ngdk_pixbuf_new_from_file (const char *filename,\n                          GError    **error)\n{\n        GdkPixbuf *pixbuf;\n        FILE *f;\n        GdkPixbufModule *image_module;\n\n        g_return_val_if_fail (filename != NULL, NULL);\n        g_return_val_if_fail (error == NULL || *error == NULL, NULL);\n        \n        f = g_fopen (filename, \"rb\");\n        if (!f) {\n                gint save_errno = errno;\n\t\tgchar *display_name;\n        \tdisplay_name = g_filename_display_name (filename);      \n                g_set_error (error,\n                             G_FILE_ERROR,\n                             g_file_error_from_errno (save_errno),\n                             _(\"Failed to open file \u201c%s\u201d: %s\"),\n                             display_name,\n                             g_strerror (save_errno));\n                g_free (display_name);\n                return NULL;\n        }\n\n        image_module = _gdk_pixbuf_get_module_for_file (f, filename, error);\n        if (image_module == NULL) {\n                fclose (f);\n                return NULL;\n        }\n\n        if (!_gdk_pixbuf_load_module (image_module, error)) {\n                fclose (f);\n                return NULL;\n        }\n\n        fseek (f, 0, SEEK_SET);\n        pixbuf = _gdk_pixbuf_generic_image_load (image_module, f, error);\n        fclose (f);\n\n        if (pixbuf == NULL && error != NULL && *error == NULL) {\n\n                /* I don't trust these crufty longjmp()'ing image libs\n                 * to maintain proper error invariants, and I don't\n                 * want user code to segfault as a result. We need to maintain\n                 * the invariant that error gets set if NULL is returned.\n                 */\n\n\t\tgchar *display_name;\n        \tdisplay_name = g_filename_display_name (filename);      \n                g_warning (\"Bug! gdk-pixbuf loader '%s' didn't set an error on failure.\", image_module->module_name);\n                g_set_error (error,\n                             GDK_PIXBUF_ERROR,\n                             GDK_PIXBUF_ERROR_FAILED,\n                             _(\"Failed to load image \u201c%s\u201d: reason not known, probably a corrupt image file\"),\n                             display_name);\n\t\tg_free (display_name);\n        } else if (error != NULL && *error != NULL) {\n\t\t/* Add the filename to the error message */\n\t\tGError *e = *error;\n\t\tgchar  *old;\n\t\tgchar *display_name;\n\n        \tdisplay_name = g_filename_display_name (filename);      \n\t\told = e->message;\n\t\te->message = g_strdup_printf (_(\"Failed to load image \u201c%s\u201d: %s\"),\n\t\t\t\t\t      display_name,\n\t\t\t\t\t      old);\n\t\tg_free (old);\n\t\tg_free (display_name);\n        }\n\n        return pixbuf;\n}\n\n#ifdef G_OS_WIN32\n\n/**\n * gdk_pixbuf_new_from_file_utf8:\n * @filename: (type filename): Name of file to load, in the GLib file name encoding\n * @error: Return location for an error\n *\n * Same as gdk_pixbuf_new_from_file()\n *\n * Return value: A newly-created pixbuf with a reference count of 1, or %NULL if\n * any of several error conditions occurred:  the file could not be opened,\n * there was no loader for the file's format, there was not enough memory to\n * allocate the image buffer, or the image file contained invalid data.\n **/\nGdkPixbuf *\ngdk_pixbuf_new_from_file_utf8 (const char *filename,\n                                GError    **error)\n{\n    return gdk_pixbuf_new_from_file (filename, error);\n}\n\n#endif\n\n\n/**\n * gdk_pixbuf_new_from_file_at_size:\n * @filename: (type filename): Name of file to load, in the GLib file\n *     name encoding\n * @width: The width the image should have or -1 to not constrain the width\n * @height: The height the image should have or -1 to not constrain the height\n * @error: Return location for an error\n *\n * Creates a new pixbuf by loading an image from a file.  \n * The file format is detected automatically. If %NULL is returned, then \n * @error will be set. Possible errors are in the #GDK_PIXBUF_ERROR and \n * #G_FILE_ERROR domains.\n *\n * The image will be scaled to fit in the requested size, preserving\n * the image's aspect ratio. Note that the returned pixbuf may be smaller\n * than @width x @height, if the aspect ratio requires it. To load\n * and image at the requested size, regardless of aspect ratio, use\n * gdk_pixbuf_new_from_file_at_scale().\n *\n * Return value: A newly-created pixbuf with a reference count of 1, or \n * %NULL if any of several error conditions occurred:  the file could not \n * be opened, there was no loader for the file's format, there was not \n * enough memory to allocate the image buffer, or the image file contained \n * invalid data.\n *\n * Since: 2.4\n **/\nGdkPixbuf *\ngdk_pixbuf_new_from_file_at_size (const char *filename,\n                                  int         width, \n                                  int         height,\n                                  GError    **error)\n{\n        return gdk_pixbuf_new_from_file_at_scale (filename, \n                                                  width, height, \n                                                  TRUE, error);\n}\n\n#ifdef G_OS_WIN32\n\n/**\n * gdk_pixbuf_new_from_file_at_size_utf8:\n * @filename: (type filename): Name of file to load, in the GLib file name encoding\n * @width: The width the image should have or -1 to not constrain the width\n * @height: The height the image should have or -1 to not constrain the height\n * @error: Return location for an error\n *\n * Same as gdk_pixbuf_new_from_file_at_size()\n *\n * Return value: A newly-created pixbuf with a reference count of 1, or\n * %NULL if any of several error conditions occurred:  the file could not\n * be opened, there was no loader for the file's format, there was not\n * enough memory to allocate the image buffer, or the image file contained\n * invalid data.\n *\n * Since: 2.4\n **/\nGdkPixbuf *\ngdk_pixbuf_new_from_file_at_size_utf8 (const char *filename,\n                                       int         width,\n                                       int         height,\n                                       GError    **error)\n{\n    return gdk_pixbuf_new_from_file_at_size (filename, width, height, error);\n}\n\n#endif\n\ntypedef struct {\n        gint width;\n        gint height;\n        gboolean preserve_aspect_ratio;\n} AtScaleData; \n\nstatic void\nat_scale_data_async_data_free (AtScaleData *data)\n{\n\tg_slice_free (AtScaleData, data);\n}\n\nstatic void\nat_scale_size_prepared_cb (GdkPixbufLoader *loader, \n                           int              width,\n                           int              height,\n                           gpointer         data)\n{\n        AtScaleData *info = data;\n\n        g_return_if_fail (width > 0 && height > 0);\n\n        if (info->preserve_aspect_ratio && \n            (info->width > 0 || info->height > 0)) {\n                if (info->width < 0)\n                {\n                        width = width * (double)info->height/(double)height;\n                        height = info->height;\n                }\n                else if (info->height < 0)\n                {\n                        height = height * (double)info->width/(double)width;\n                        width = info->width;\n                }\n                else if ((double)height * (double)info->width >\n                         (double)width * (double)info->height) {\n                        width = 0.5 + (double)width * (double)info->height / (double)height;\n                        height = info->height;\n                } else {\n                        height = 0.5 + (double)height * (double)info->width / (double)width;\n                        width = info->width;\n                }\n        } else {\n                if (info->width > 0)\n                        width = info->width;\n                if (info->height > 0)\n                        height = info->height;\n        }\n        \n        width = MAX (width, 1);\n        height = MAX (height, 1);\n\n        gdk_pixbuf_loader_set_size (loader, width, height);\n}\n\n/**\n * gdk_pixbuf_new_from_file_at_scale:\n * @filename: (type filename): Name of file to load, in the GLib file\n *     name encoding\n * @width: The width the image should have or -1 to not constrain the width\n * @height: The height the image should have or -1 to not constrain the height\n * @preserve_aspect_ratio: %TRUE to preserve the image's aspect ratio\n * @error: Return location for an error\n *\n * Creates a new pixbuf by loading an image from a file.  The file format is\n * detected automatically. If %NULL is returned, then @error will be set.\n * Possible errors are in the #GDK_PIXBUF_ERROR and #G_FILE_ERROR domains.\n * The image will be scaled to fit in the requested size, optionally preserving\n * the image's aspect ratio. \n *\n * When preserving the aspect ratio, a @width of -1 will cause the image\n * to be scaled to the exact given height, and a @height of -1 will cause\n * the image to be scaled to the exact given width. When not preserving\n * aspect ratio, a @width or @height of -1 means to not scale the image \n * at all in that dimension. Negative values for @width and @height are \n * allowed since 2.8.\n *\n * Return value: A newly-created pixbuf with a reference count of 1, or %NULL \n * if any of several error conditions occurred:  the file could not be opened,\n * there was no loader for the file's format, there was not enough memory to\n * allocate the image buffer, or the image file contained invalid data.\n *\n * Since: 2.6\n **/\nGdkPixbuf *\ngdk_pixbuf_new_from_file_at_scale (const char *filename,\n                                   int         width, \n                                   int         height,\n                                   gboolean    preserve_aspect_ratio,\n                                   GError    **error)\n{\n\n        GdkPixbufLoader *loader;\n        GdkPixbuf       *pixbuf;\n        guchar buffer[LOAD_BUFFER_SIZE];\n        int length;\n        FILE *f;\n        AtScaleData info;\n        GdkPixbufAnimation *animation;\n        GdkPixbufAnimationIter *iter;\n        gboolean has_frame;\n\n        g_return_val_if_fail (filename != NULL, NULL);\n        g_return_val_if_fail (width > 0 || width == -1, NULL);\n        g_return_val_if_fail (height > 0 || height == -1, NULL);\n\n        f = g_fopen (filename, \"rb\");\n        if (!f) {\n                gint save_errno = errno;\n                gchar *display_name = g_filename_display_name (filename);\n                g_set_error (error,\n                             G_FILE_ERROR,\n                             g_file_error_from_errno (save_errno),\n                             _(\"Failed to open file \u201c%s\u201d: %s\"),\n                             display_name,\n                             g_strerror (save_errno));\n                g_free (display_name);\n                return NULL;\n        }\n\n        loader = _gdk_pixbuf_loader_new_with_filename (filename);\n\n        info.width = width;\n        info.height = height;\n        info.preserve_aspect_ratio = preserve_aspect_ratio;\n\n        g_signal_connect (loader, \"size-prepared\", \n                          G_CALLBACK (at_scale_size_prepared_cb), &info);\n\n        has_frame = FALSE;\n        while (!has_frame && !feof (f) && !ferror (f)) {\n                length = fread (buffer, 1, sizeof (buffer), f);\n                if (length > 0)\n                        if (!gdk_pixbuf_loader_write (loader, buffer, length, error)) {\n                                gdk_pixbuf_loader_close (loader, NULL);\n                                fclose (f);\n                                g_object_unref (loader);\n                                return NULL;\n                        }\n                \n                animation = gdk_pixbuf_loader_get_animation (loader);\n                if (animation) {\n                        iter = gdk_pixbuf_animation_get_iter (animation, NULL);\n                        if (!gdk_pixbuf_animation_iter_on_currently_loading_frame (iter)) {\n                                has_frame = TRUE;\n                        }\n                        g_object_unref (iter);\n                }\n        }\n\n        fclose (f);\n\n        if (!gdk_pixbuf_loader_close (loader, error) && !has_frame) {\n                g_object_unref (loader);\n                return NULL;\n        }\n\n        pixbuf = gdk_pixbuf_loader_get_pixbuf (loader);\n\n        if (!pixbuf) {\n                gchar *display_name = g_filename_display_name (filename);\n                g_object_unref (loader);\n                g_set_error (error,\n                             GDK_PIXBUF_ERROR,\n                             GDK_PIXBUF_ERROR_FAILED,\n                             _(\"Failed to load image \u201c%s\u201d: reason not known, probably a corrupt image file\"),\n                             display_name);\n                g_free (display_name);\n                return NULL;\n        }\n\n        g_object_ref (pixbuf);\n\n        g_object_unref (loader);\n\n        return pixbuf;\n}\n\n#ifdef G_OS_WIN32\n\n/**\n * gdk_pixbuf_new_from_file_at_scale_utf8:\n * @filename: (type filename): Name of file to load, in the GLib file name encoding\n * @width: The width the image should have or -1 to not constrain the width\n * @height: The height the image should have or -1 to not constrain the height\n * @preserve_aspect_ratio: %TRUE to preserve the image's aspect ratio\n * @error: Return location for an error\n *\n * Same as gdk_pixbuf_new_from_file_at_scale().\n *\n * Return value: A newly-created pixbuf with a reference count of 1, or %NULL\n * if any of several error conditions occurred:  the file could not be opened,\n * there was no loader for the file's format, there was not enough memory to\n * allocate the image buffer, or the image file contained invalid data.\n *\n * Since: 2.6\n **/\nGdkPixbuf *\ngdk_pixbuf_new_from_file_at_scale_utf8 (const char *filename,\n                                        int         width,\n                                        int         height,\n                                        gboolean    preserve_aspect_ratio,\n                                        GError    **error)\n{\n    return gdk_pixbuf_new_from_file_at_scale (filename, width, height,\n                                              preserve_aspect_ratio, error);\n}\n#endif\n\n\nstatic GdkPixbuf *\nload_from_stream (GdkPixbufLoader  *loader,\n                  GInputStream     *stream,\n                  GCancellable     *cancellable,\n                  GError          **error)\n{\n        GdkPixbuf *pixbuf;\n        gssize n_read;\n        guchar buffer[LOAD_BUFFER_SIZE];\n\n        while (1) { \n                n_read = g_input_stream_read (stream, \n                                              buffer, \n                                              sizeof (buffer), \n                                              cancellable, \n                                              error);\n                if (n_read < 0) {\n                        gdk_pixbuf_loader_close (loader, NULL);\n                        return NULL;\n                }\n\n                if (n_read == 0)\n                        break;\n\n                if (!gdk_pixbuf_loader_write (loader, \n                                              buffer, \n                                              n_read, \n                                              error)) {\n                        gdk_pixbuf_loader_close (loader, NULL);\n                        return NULL;\n                }\n        }\n\n        if (!gdk_pixbuf_loader_close (loader, error))\n                return NULL;\n\n        pixbuf = gdk_pixbuf_loader_get_pixbuf (loader);\n        if (pixbuf == NULL)\n                return NULL;\n\n        return g_object_ref (pixbuf);\n}\n\n\n/**\n * gdk_pixbuf_new_from_stream_at_scale:\n * @stream:  a #GInputStream to load the pixbuf from\n * @width: The width the image should have or -1 to not constrain the width\n * @height: The height the image should have or -1 to not constrain the height\n * @preserve_aspect_ratio: %TRUE to preserve the image's aspect ratio\n * @cancellable: (allow-none): optional #GCancellable object, %NULL to ignore\n * @error: Return location for an error\n *\n * Creates a new pixbuf by loading an image from an input stream.  \n *\n * The file format is detected automatically. If %NULL is returned, then \n * @error will be set. The @cancellable can be used to abort the operation\n * from another thread. If the operation was cancelled, the error \n * %G_IO_ERROR_CANCELLED will be returned. Other possible errors are in \n * the #GDK_PIXBUF_ERROR and %G_IO_ERROR domains. \n *\n * The image will be scaled to fit in the requested size, optionally \n * preserving the image's aspect ratio.\n *\n * When preserving the aspect ratio, a @width of -1 will cause the image to be\n * scaled to the exact given height, and a @height of -1 will cause the image\n * to be scaled to the exact given width. If both @width and @height are\n * given, this function will behave as if the smaller of the two values\n * is passed as -1.\n *\n * When not preserving aspect ratio, a @width or @height of -1 means to not\n * scale the image at all in that dimension.\n *\n * The stream is not closed.\n *\n * Return value: A newly-created pixbuf, or %NULL if any of several error \n * conditions occurred: the file could not be opened, the image format is \n * not supported, there was not enough memory to allocate the image buffer, \n * the stream contained invalid data, or the operation was cancelled.\n *\n * Since: 2.14\n */\nGdkPixbuf *\ngdk_pixbuf_new_from_stream_at_scale (GInputStream  *stream,\n                                     gint           width,\n                                     gint           height,\n                                     gboolean       preserve_aspect_ratio,\n                                     GCancellable  *cancellable,\n                                     GError       **error)\n{\n        GdkPixbufLoader *loader;\n        GdkPixbuf *pixbuf;\n        AtScaleData info;\n\n        loader = gdk_pixbuf_loader_new ();\n        info.width = width;\n        info.height = height;\n        info.preserve_aspect_ratio = preserve_aspect_ratio;\n\n        g_signal_connect (loader, \"size-prepared\", \n                          G_CALLBACK (at_scale_size_prepared_cb), &info);\n\n        pixbuf = load_from_stream (loader, stream, cancellable, error);\n        g_object_unref (loader);\n\n        return pixbuf;\n}\n\n\nstatic void\nload_from_stream_async_cb (GObject      *stream,\n                           GAsyncResult *res,\n                           gpointer      data)\n{\n        GTask *task = data;\n        GdkPixbufLoader *loader;\n        GdkPixbuf *pixbuf;\n        GError *error = NULL;\n        GBytes *bytes = NULL;\n\n        loader = g_task_get_task_data (task);\n\n        bytes = g_input_stream_read_bytes_finish (G_INPUT_STREAM (stream), res, &error);\n\n        if (bytes == NULL) {\n                gdk_pixbuf_loader_close (loader, NULL);\n                g_task_return_error (task, error);\n        } else if (g_bytes_get_size (bytes) > 0) {\n                if (!gdk_pixbuf_loader_write (loader, \n                                              g_bytes_get_data (bytes, NULL),\n                                              g_bytes_get_size (bytes),\n                                              &error)) {\n                        gdk_pixbuf_loader_close (loader, NULL);\n                        g_task_return_error (task, error);\n                        goto out;\n                }\n                g_input_stream_read_bytes_async (G_INPUT_STREAM (stream),\n                                                 LOAD_BUFFER_SIZE, \n                                                 G_PRIORITY_DEFAULT,\n                                                 g_task_get_cancellable (task),\n                                                 load_from_stream_async_cb,\n                                                 g_object_ref (task));\n\n        } else {\n                if (!gdk_pixbuf_loader_close (loader, &error)) {\n                        g_task_return_error (task, error);\n                        goto out;\n                }\n\n                pixbuf = gdk_pixbuf_loader_get_pixbuf (loader);\n                g_task_return_pointer (task, g_object_ref (pixbuf), g_object_unref);\n        }\n\nout:\n        g_bytes_unref (bytes);\n        g_object_unref (task);\n}\n\n\n/**\n * gdk_pixbuf_new_from_stream_at_scale_async:\n * @stream: a #GInputStream from which to load the pixbuf\n * @width: the width the image should have or -1 to not constrain the width\n * @height: the height the image should have or -1 to not constrain the height\n * @preserve_aspect_ratio: %TRUE to preserve the image's aspect ratio\n * @cancellable: (allow-none): optional #GCancellable object, %NULL to ignore\n * @callback: a #GAsyncReadyCallback to call when the pixbuf is loaded\n * @user_data: the data to pass to the callback function\n *\n * Creates a new pixbuf by asynchronously loading an image from an input stream.\n *\n * For more details see gdk_pixbuf_new_from_stream_at_scale(), which is the synchronous\n * version of this function.\n *\n * When the operation is finished, @callback will be called in the main thread.\n * You can then call gdk_pixbuf_new_from_stream_finish() to get the result of the operation.\n *\n * Since: 2.24\n **/\nvoid\ngdk_pixbuf_new_from_stream_at_scale_async (GInputStream        *stream,\n\t\t\t\t\t   gint                 width,\n\t\t\t\t\t   gint                 height,\n\t\t\t\t\t   gboolean             preserve_aspect_ratio,\n\t\t\t\t\t   GCancellable        *cancellable,\n\t\t\t\t\t   GAsyncReadyCallback  callback,\n\t\t\t\t\t   gpointer             user_data)\n{\n\tGTask *task;\n\tAtScaleData *data;\n        GdkPixbufLoader *loader;\n\n\tg_return_if_fail (G_IS_INPUT_STREAM (stream));\n\tg_return_if_fail (callback != NULL);\n\tg_return_if_fail (!cancellable || G_IS_CANCELLABLE (cancellable));\n\n\tdata = g_slice_new (AtScaleData);\n\tdata->width = width;\n\tdata->height = height;\n\tdata->preserve_aspect_ratio = preserve_aspect_ratio;\n\n        loader = gdk_pixbuf_loader_new ();\n        g_signal_connect (loader, \"size-prepared\", \n                          G_CALLBACK (at_scale_size_prepared_cb), data);\n        g_object_set_data_full (G_OBJECT (loader),\n                                \"gdk-pixbuf-please-kill-me-later\", \n                                data,\n                                (GDestroyNotify) at_scale_data_async_data_free);\n\n\ttask = g_task_new (stream, cancellable, callback, user_data);\n\tg_task_set_source_tag (task, gdk_pixbuf_new_from_stream_at_scale_async);\n\tg_task_set_task_data (task, loader, g_object_unref);\n\n        g_input_stream_read_bytes_async (stream,\n                                         LOAD_BUFFER_SIZE, \n                                         G_PRIORITY_DEFAULT,\n                                         cancellable,\n                                         load_from_stream_async_cb,\n                                         task);\n}\n\n/**\n * gdk_pixbuf_new_from_stream:\n * @stream:  a #GInputStream to load the pixbuf from\n * @cancellable: (allow-none): optional #GCancellable object, %NULL to ignore\n * @error: Return location for an error\n *\n * Creates a new pixbuf by loading an image from an input stream.  \n *\n * The file format is detected automatically. If %NULL is returned, then \n * @error will be set. The @cancellable can be used to abort the operation\n * from another thread. If the operation was cancelled, the error \n * %G_IO_ERROR_CANCELLED will be returned. Other possible errors are in \n * the #GDK_PIXBUF_ERROR and %G_IO_ERROR domains. \n *\n * The stream is not closed.\n *\n * Return value: A newly-created pixbuf, or %NULL if any of several error \n * conditions occurred: the file could not be opened, the image format is \n * not supported, there was not enough memory to allocate the image buffer, \n * the stream contained invalid data, or the operation was cancelled.\n *\n * Since: 2.14\n **/\nGdkPixbuf *\ngdk_pixbuf_new_from_stream (GInputStream  *stream,\n                            GCancellable  *cancellable,\n                            GError       **error)\n{\n        GdkPixbuf *pixbuf;\n        GdkPixbufLoader *loader;\n\n        loader = gdk_pixbuf_loader_new ();\n        pixbuf = load_from_stream (loader, stream, cancellable, error);\n        g_object_unref (loader);\n\n        return pixbuf;\n}\n\nGdkPixbuf *\n_gdk_pixbuf_new_from_resource_try_pixdata (const char *resource_path)\n{\n\tgsize data_size;\n\tGBytes *bytes;\n\nG_GNUC_BEGIN_IGNORE_DEPRECATIONS\n\t/* We specialize GdkPixdata files, making these a reference to the\n\t * compiled-in resource data, whether uncompressed and mmap'ed, or\n\t * compressed, and uncompressed on-the-fly.\n         */\n\tif (g_resources_get_info  (resource_path, 0, &data_size, NULL, NULL) &&\n\t    data_size > sizeof(guint32) &&\n\t    (bytes = g_resources_lookup_data (resource_path, 0, NULL)) != NULL) {\n\t\tGdkPixbuf*pixbuf = NULL;\n\t\tconst guint8 *stream = g_bytes_get_data (bytes, NULL);\n\t\tGdkPixdata pixdata;\n\t\tguint32 magic;\n\n\t\tmagic = (stream[0] << 24) + (stream[1] << 16) + (stream[2] << 8) + stream[3];\n\t\tif (magic == GDK_PIXBUF_MAGIC_NUMBER &&\n\t\t    gdk_pixdata_deserialize (&pixdata, data_size, stream, NULL)) {\n\t\t\tpixbuf = gdk_pixbuf_from_pixdata (&pixdata, FALSE, NULL);\n\t\t}\n\n\t\tif (pixbuf) {\n\t\t\t/* Free the GBytes with the pixbuf */\n\t\t\tg_object_set_data_full (G_OBJECT (pixbuf), \"gdk-pixbuf-resource-bytes\", bytes, (GDestroyNotify) g_bytes_unref);\n\t\t\treturn pixbuf;\n\t\t} else {\n\t\t\tg_bytes_unref (bytes);\n\t\t}\n\t}\nG_GNUC_END_IGNORE_DEPRECATIONS\n\n        return NULL;\n}\n\n/**\n * gdk_pixbuf_new_from_resource:\n * @resource_path: the path of the resource file\n * @error: Return location for an error\n *\n * Creates a new pixbuf by loading an image from an resource.\n *\n * The file format is detected automatically. If %NULL is returned, then\n * @error will be set.\n *\n * Return value: A newly-created pixbuf, or %NULL if any of several error\n * conditions occurred: the file could not be opened, the image format is\n * not supported, there was not enough memory to allocate the image buffer,\n * the stream contained invalid data, or the operation was cancelled.\n *\n * Since: 2.26\n **/\nGdkPixbuf *\ngdk_pixbuf_new_from_resource (const gchar  *resource_path,\n\t\t\t      GError      **error)\n{\n\tGInputStream *stream;\n\tGdkPixbuf *pixbuf;\n\n        pixbuf = _gdk_pixbuf_new_from_resource_try_pixdata (resource_path);\n        if (pixbuf)\n                return pixbuf;\n\n\tstream = g_resources_open_stream (resource_path, 0, error);\n\tif (stream == NULL)\n\t\treturn NULL;\n\n\tpixbuf = gdk_pixbuf_new_from_stream (stream, NULL, error);\n\tg_object_unref (stream);\n\treturn pixbuf;\n}\n\n/**\n * gdk_pixbuf_new_from_resource_at_scale:\n * @resource_path: the path of the resource file\n * @width: The width the image should have or -1 to not constrain the width\n * @height: The height the image should have or -1 to not constrain the height\n * @preserve_aspect_ratio: %TRUE to preserve the image's aspect ratio\n * @error: Return location for an error\n *\n * Creates a new pixbuf by loading an image from an resource.\n *\n * The file format is detected automatically. If %NULL is returned, then\n * @error will be set.\n *\n * The image will be scaled to fit in the requested size, optionally\n * preserving the image's aspect ratio. When preserving the aspect ratio,\n * a @width of -1 will cause the image to be scaled to the exact given\n * height, and a @height of -1 will cause the image to be scaled to the\n * exact given width. When not preserving aspect ratio, a @width or\n * @height of -1 means to not scale the image at all in that dimension.\n *\n * The stream is not closed.\n *\n * Return value: A newly-created pixbuf, or %NULL if any of several error\n * conditions occurred: the file could not be opened, the image format is\n * not supported, there was not enough memory to allocate the image buffer,\n * the stream contained invalid data, or the operation was cancelled.\n *\n * Since: 2.26\n */\nGdkPixbuf *\ngdk_pixbuf_new_from_resource_at_scale (const char *resource_path,\n\t\t\t\t       int         width,\n\t\t\t\t       int         height,\n\t\t\t\t       gboolean    preserve_aspect_ratio,\n\t\t\t\t       GError    **error)\n{\n\tGInputStream *stream;\n\tGdkPixbuf *pixbuf;\n\n\tstream = g_resources_open_stream (resource_path, 0, error);\n\tif (stream == NULL)\n\t\treturn NULL;\n\n\tpixbuf = gdk_pixbuf_new_from_stream_at_scale (stream, width, height, preserve_aspect_ratio, NULL, error);\n\tg_object_unref (stream);\n\treturn pixbuf;\n}\n\n/**\n * gdk_pixbuf_new_from_stream_async:\n * @stream: a #GInputStream from which to load the pixbuf\n * @cancellable: (allow-none): optional #GCancellable object, %NULL to ignore\n * @callback: a #GAsyncReadyCallback to call when the pixbuf is loaded\n * @user_data: the data to pass to the callback function\n *\n * Creates a new pixbuf by asynchronously loading an image from an input stream.\n *\n * For more details see gdk_pixbuf_new_from_stream(), which is the synchronous\n * version of this function.\n *\n * When the operation is finished, @callback will be called in the main thread.\n * You can then call gdk_pixbuf_new_from_stream_finish() to get the result of the operation.\n *\n * Since: 2.24\n **/\nvoid\ngdk_pixbuf_new_from_stream_async (GInputStream        *stream,\n\t\t\t\t  GCancellable        *cancellable,\n\t\t\t\t  GAsyncReadyCallback  callback,\n\t\t\t\t  gpointer             user_data)\n{\n\tGTask *task;\n\n\tg_return_if_fail (G_IS_INPUT_STREAM (stream));\n\tg_return_if_fail (callback != NULL);\n\tg_return_if_fail (!cancellable || G_IS_CANCELLABLE (cancellable));\n\n\ttask = g_task_new (stream, cancellable, callback, user_data);\n\tg_task_set_source_tag (task, gdk_pixbuf_new_from_stream_async);\n        g_task_set_task_data (task, gdk_pixbuf_loader_new (), g_object_unref);\n\n        g_input_stream_read_bytes_async (stream,\n                                         LOAD_BUFFER_SIZE, \n                                         G_PRIORITY_DEFAULT,\n                                         cancellable,\n                                         load_from_stream_async_cb,\n                                         task);\n}\n\n/**\n * gdk_pixbuf_new_from_stream_finish:\n * @async_result: a #GAsyncResult\n * @error: a #GError, or %NULL\n *\n * Finishes an asynchronous pixbuf creation operation started with\n * gdk_pixbuf_new_from_stream_async().\n *\n * Return value: a #GdkPixbuf or %NULL on error. Free the returned\n * object with g_object_unref().\n *\n * Since: 2.24\n **/\nGdkPixbuf *\ngdk_pixbuf_new_from_stream_finish (GAsyncResult  *async_result,\n\t\t\t\t   GError       **error)\n{\n\tGTask *task;\n\n\tg_return_val_if_fail (G_IS_TASK (async_result), NULL);\n\tg_return_val_if_fail (!error || (error && !*error), NULL);\n\n\ttask = G_TASK (async_result);\n\n\tg_warn_if_fail (g_task_get_source_tag (task) == gdk_pixbuf_new_from_stream_async ||\n\t\t\tg_task_get_source_tag (task) == gdk_pixbuf_new_from_stream_at_scale_async);\n\n\treturn g_task_propagate_pointer (task, error);\n}\n\nstatic void\ninfo_cb (GdkPixbufLoader *loader, \n         int              width,\n         int              height,\n         gpointer         data)\n{\n        struct {\n                GdkPixbufFormat *format;\n                int width;\n                int height;\n        } *info = data;\n\n        g_return_if_fail (width > 0 && height > 0);\n\n        info->format = gdk_pixbuf_loader_get_format (loader);\n        info->width = width;\n        info->height = height;\n\n        gdk_pixbuf_loader_set_size (loader, 0, 0);\n}\n\n/**\n * gdk_pixbuf_get_file_info:\n * @filename: (type filename): The name of the file to identify.\n * @width: (optional) (out): Return location for the width of the\n *     image, or %NULL\n * @height: (optional) (out): Return location for the height of the\n *     image, or %NULL\n * \n * Parses an image file far enough to determine its format and size.\n * \n * Returns: (nullable) (transfer none): A #GdkPixbufFormat describing\n *    the image format of the file or %NULL if the image format wasn't\n *    recognized. The return value is owned by #GdkPixbuf and should\n *    not be freed.\n *\n * Since: 2.4\n **/\nGdkPixbufFormat *\ngdk_pixbuf_get_file_info (const gchar  *filename,\n                          gint         *width, \n                          gint         *height)\n{\n        GdkPixbufLoader *loader;\n        guchar buffer[SNIFF_BUFFER_SIZE];\n        int length;\n        FILE *f;\n        struct {\n                GdkPixbufFormat *format;\n                gint width;\n                gint height;\n        } info;\n\n        g_return_val_if_fail (filename != NULL, NULL);\n\n        f = g_fopen (filename, \"rb\");\n        if (!f)\n                return NULL;\n\n        loader = _gdk_pixbuf_loader_new_with_filename (filename);\n\n        info.format = NULL;\n        info.width = -1;\n        info.height = -1;\n                \n        g_signal_connect (loader, \"size-prepared\", G_CALLBACK (info_cb), &info);\n\n        while (!feof (f) && !ferror (f)) {\n                length = fread (buffer, 1, sizeof (buffer), f);\n                if (length > 0) {\n                        if (!gdk_pixbuf_loader_write (loader, buffer, length, NULL))\n                                break;\n                }\n                if (info.format != NULL)\n                        break;\n        }\n\n        fclose (f);\n        gdk_pixbuf_loader_close (loader, NULL);\n        g_object_unref (loader);\n\n        if (width) \n                *width = info.width;\n        if (height) \n                *height = info.height;\n\n        return info.format;\n}\n\ntypedef struct {\n        gchar *filename;\n        gint width;\n        gint height;\n} GetFileInfoAsyncData;\n\nstatic void\nget_file_info_async_data_free (GetFileInfoAsyncData *data)\n{\n        g_free (data->filename);\n        g_slice_free (GetFileInfoAsyncData, data);\n}\n\nstatic void\nget_file_info_thread (GTask                *task,\n                      gpointer              source_object,\n                      GetFileInfoAsyncData *data,\n                      GCancellable         *cancellable)\n{\n        GdkPixbufFormat *format;\n\n        format = gdk_pixbuf_get_file_info (data->filename, &data->width, &data->height);\n        if (format == NULL) {\n                g_task_return_new_error (task,\n                                         GDK_PIXBUF_ERROR,\n                                         GDK_PIXBUF_ERROR_UNKNOWN_TYPE,\n                                         \"Failed to recognize image format\");\n        } else {\n                g_task_return_pointer (task,\n                                       gdk_pixbuf_format_copy (format),\n                                       (GDestroyNotify) gdk_pixbuf_format_free);\n        }\n}\n\n/**\n * gdk_pixbuf_get_file_info_async:\n * @filename: (type filename): The name of the file to identify\n * @cancellable: (allow-none): optional #GCancellable object, %NULL to ignore\n * @callback: a #GAsyncReadyCallback to call when the file info is available\n * @user_data: the data to pass to the callback function\n *\n * Asynchronously parses an image file far enough to determine its\n * format and size.\n *\n * For more details see gdk_pixbuf_get_file_info(), which is the synchronous\n * version of this function.\n *\n * When the operation is finished, @callback will be called in the\n * main thread. You can then call gdk_pixbuf_get_file_info_finish() to\n * get the result of the operation.\n *\n * Since: 2.32\n **/\nvoid\ngdk_pixbuf_get_file_info_async  (const gchar          *filename,\n                                 GCancellable         *cancellable,\n                                 GAsyncReadyCallback   callback,\n                                 gpointer              user_data)\n{\n        GetFileInfoAsyncData *data;\n        GTask *task;\n\n        g_return_if_fail (filename != NULL);\n        g_return_if_fail (callback != NULL);\n        g_return_if_fail (!cancellable || G_IS_CANCELLABLE (cancellable));\n\n        data = g_slice_new0 (GetFileInfoAsyncData);\n        data->filename = g_strdup (filename);\n\n        task = g_task_new (NULL, cancellable, callback, user_data);\n        g_task_set_return_on_cancel (task, TRUE);\n        g_task_set_source_tag (task, gdk_pixbuf_get_file_info_async);\n        g_task_set_task_data (task, data, (GDestroyNotify) get_file_info_async_data_free);\n        g_task_run_in_thread (task, (GTaskThreadFunc) get_file_info_thread);\n        g_object_unref (task);\n}\n\n/**\n * gdk_pixbuf_get_file_info_finish:\n * @async_result: a #GAsyncResult\n * @width: (out): Return location for the width of the image, or %NULL\n * @height: (out): Return location for the height of the image, or %NULL\n * @error: a #GError, or %NULL\n *\n * Finishes an asynchronous pixbuf parsing operation started with\n * gdk_pixbuf_get_file_info_async().\n *\n * Returns: (transfer none): A #GdkPixbufFormat describing the image\n *    format of the file or %NULL if the image format wasn't\n *    recognized. The return value is owned by GdkPixbuf and should\n *    not be freed.\n *\n * Since: 2.32\n **/\nGdkPixbufFormat *\ngdk_pixbuf_get_file_info_finish (GAsyncResult         *async_result,\n                                 gint                 *width,\n                                 gint                 *height,\n                                 GError              **error)\n{\n        GetFileInfoAsyncData *data;\n        GTask *task;\n\n        g_return_val_if_fail (g_task_is_valid (async_result, NULL), NULL);\n\n        task = G_TASK (async_result);\n\n        g_return_val_if_fail (!error || (error && !*error), NULL);\n        g_warn_if_fail (g_task_get_source_tag (task) == gdk_pixbuf_get_file_info_async);\n\n        data = g_task_get_task_data (task);\n\n        if (!g_task_had_error (task)) {\n                if (width)\n                        *width = data->width;\n                if (height)\n                        *height = data->height;\n        }\n\n        return g_task_propagate_pointer (task, error);\n}\n\n/**\n * gdk_pixbuf_new_from_xpm_data:\n * @data: (array zero-terminated=1): Pointer to inline XPM data.\n *\n * Creates a new pixbuf by parsing XPM data in memory.  This data is commonly\n * the result of including an XPM file into a program's C source.\n *\n * Return value: A newly-created pixbuf with a reference count of 1.\n **/\nGdkPixbuf *\ngdk_pixbuf_new_from_xpm_data (const char **data)\n{\n        GdkPixbuf *(* load_xpm_data) (const char **data);\n        GdkPixbuf *pixbuf;\n        GError *error = NULL;\n        GdkPixbufModule *xpm_module;\n\n        g_return_val_if_fail (data != NULL, NULL);\n\n        xpm_module = _gdk_pixbuf_get_named_module (\"xpm\", &error);\n        if (xpm_module == NULL) {\n                g_warning (\"Error loading XPM image loader: %s\", error->message);\n                g_error_free (error);\n                return NULL;\n        }\n\n        if (!_gdk_pixbuf_load_module (xpm_module, &error)) {\n                g_warning (\"Error loading XPM image loader: %s\", error->message);\n                g_error_free (error);\n                return NULL;\n        }\n\n        if (xpm_module->load_xpm_data == NULL) {\n                g_warning (\"gdk-pixbuf XPM module lacks XPM data capability\");\n                pixbuf = NULL;\n        } else {\n                load_xpm_data = xpm_module->load_xpm_data;\n                pixbuf = (* load_xpm_data) (data);\n        }\n\n        return pixbuf;\n}\n\nstatic void\ncollect_save_options (va_list   opts,\n                      gchar  ***keys,\n                      gchar  ***vals)\n{\n  gchar *key;\n  gchar *val;\n  gchar *next;\n  gint count;\n\n  count = 0;\n  *keys = NULL;\n  *vals = NULL;\n  \n  next = va_arg (opts, gchar*);\n  while (next)\n    {\n      key = next;\n      val = va_arg (opts, gchar*);\n\n      ++count;\n\n      /* woo, slow */\n      *keys = g_realloc (*keys, sizeof(gchar*) * (count + 1));\n      *vals = g_realloc (*vals, sizeof(gchar*) * (count + 1));\n      \n      (*keys)[count-1] = g_strdup (key);\n      (*vals)[count-1] = g_strdup (val);\n\n      (*keys)[count] = NULL;\n      (*vals)[count] = NULL;\n      \n      next = va_arg (opts, gchar*);\n    }\n}\n\nstatic gboolean\nsave_to_file_callback (const gchar *buf,\n                       gsize        count,\n                       GError     **error,\n                       gpointer     data)\n{\n        FILE *filehandle = data;\n        gsize n;\n\n        n = fwrite (buf, 1, count, filehandle);\n        if (n != count) {\n                gint save_errno = errno;\n                g_set_error (error,\n                             G_FILE_ERROR,\n                             g_file_error_from_errno (save_errno),\n                             _(\"Error writing to image file: %s\"),\n                             g_strerror (save_errno));\n                return FALSE;\n        }\n        return TRUE;\n}\n\nstatic gboolean\ngdk_pixbuf_real_save (GdkPixbuf     *pixbuf, \n                      FILE          *filehandle, \n                      const char    *type, \n                      gchar        **keys,\n                      gchar        **values,\n                      GError       **error)\n{\n        gboolean ret;\n        GdkPixbufModule *image_module = NULL;       \n\n        image_module = _gdk_pixbuf_get_named_module (type, error);\n\n        if (image_module == NULL)\n                return FALSE;\n       \n        if (!_gdk_pixbuf_load_module (image_module, error))\n                return FALSE;\n\n        if (image_module->save) {\n                /* save normally */\n                ret = (* image_module->save) (filehandle, pixbuf,\n                                              keys, values,\n                                              error);\n        } else if (image_module->save_to_callback) {\n                /* save with simple callback */\n                ret = (* image_module->save_to_callback) (save_to_file_callback,\n                                                          filehandle, pixbuf,\n                                                          keys, values,\n                                                          error);\n        } else {\n                /* can't save */\n                g_set_error (error,\n                             GDK_PIXBUF_ERROR,\n                             GDK_PIXBUF_ERROR_UNSUPPORTED_OPERATION,\n                             _(\"This build of gdk-pixbuf does not support saving the image format: %s\"),\n                             type);\n                ret = FALSE;\n        }\n\n        return ret;\n}\n\n#define TMP_FILE_BUF_SIZE 4096\n\nstatic gboolean\nsave_to_callback_with_tmp_file (GdkPixbufModule   *image_module,\n                                GdkPixbuf         *pixbuf,\n                                GdkPixbufSaveFunc  save_func,\n                                gpointer           user_data,\n                                gchar            **keys,\n                                gchar            **values,\n                                GError           **error)\n{\n        int fd;\n        FILE *f = NULL;\n        gboolean retval = FALSE;\n        gchar *buf = NULL;\n        gsize n;\n        gchar *filename = NULL;\n\n        buf = g_try_malloc (TMP_FILE_BUF_SIZE);\n        if (buf == NULL) {\n                g_set_error_literal (error,\n                                     GDK_PIXBUF_ERROR,\n                                     GDK_PIXBUF_ERROR_INSUFFICIENT_MEMORY,\n                                     _(\"Insufficient memory to save image to callback\"));\n                goto end;\n        }\n\n        fd = g_file_open_tmp (\"gdkpixbuf-save-tmp.XXXXXX\", &filename, error);\n        if (fd == -1)\n                goto end;\n        f = fdopen (fd, \"wb+\");\n        if (f == NULL) {\n                gint save_errno = errno;\n                g_set_error_literal (error,\n                                     G_FILE_ERROR,\n                                     g_file_error_from_errno (save_errno),\n                                     _(\"Failed to open temporary file\"));\n                goto end;\n        }\n\n        retval = (image_module->save) (f, pixbuf, keys, values, error);\n        if (!retval)\n                goto end;\n\n        rewind (f);\n        for (;;) {\n                n = fread (buf, 1, TMP_FILE_BUF_SIZE, f);\n                if (n > 0) {\n                        if (!save_func (buf, n, error, user_data))\n                                goto end;\n                }\n                if (n != TMP_FILE_BUF_SIZE) \n                        break;\n        }\n        if (ferror (f)) {\n                gint save_errno = errno;\n                g_set_error_literal (error,\n                                     G_FILE_ERROR,\n                                     g_file_error_from_errno (save_errno),\n                                     _(\"Failed to read from temporary file\"));\n                goto end;\n        }\n        retval = TRUE;\n\n end:\n        /* cleanup and return retval */\n        if (f)\n                fclose (f);\n        if (filename) {\n                g_unlink (filename);\n                g_free (filename);\n        }\n        g_free (buf);\n\n        return retval;\n}\n\nstatic gboolean\ngdk_pixbuf_real_save_to_callback (GdkPixbuf         *pixbuf,\n                                  GdkPixbufSaveFunc  save_func,\n                                  gpointer           user_data,\n                                  const char        *type, \n                                  gchar            **keys,\n                                  gchar            **values,\n                                  GError           **error)\n{\n        gboolean ret;\n        GdkPixbufModule *image_module = NULL;       \n\n        image_module = _gdk_pixbuf_get_named_module (type, error);\n\n        if (image_module == NULL)\n                return FALSE;\n       \n        if (!_gdk_pixbuf_load_module (image_module, error))\n                return FALSE;\n\n        if (image_module->save_to_callback) {\n                /* save normally */\n                ret = (* image_module->save_to_callback) (save_func, user_data, \n                                                          pixbuf, keys, values,\n                                                          error);\n        } else if (image_module->save) {\n                /* use a temporary file */\n                ret = save_to_callback_with_tmp_file (image_module, pixbuf,\n                                                      save_func, user_data, \n                                                      keys, values,\n                                                      error);\n        } else {\n                /* can't save */\n                g_set_error (error,\n                             GDK_PIXBUF_ERROR,\n                             GDK_PIXBUF_ERROR_UNSUPPORTED_OPERATION,\n                             _(\"This build of gdk-pixbuf does not support saving the image format: %s\"),\n                             type);\n                ret = FALSE;\n        }\n\n        return ret;\n}\n\n \n/**\n * gdk_pixbuf_save:\n * @pixbuf: a #GdkPixbuf.\n * @filename: (type filename): name of file to save.\n * @type: name of file format.\n * @error: (allow-none): return location for error, or %NULL\n * @...: list of key-value save options, followed by %NULL\n *\n * Saves pixbuf to a file in format @type. By default, \"jpeg\", \"png\", \"ico\" \n * and \"bmp\" are possible file formats to save in, but more formats may be\n * installed. The list of all writable formats can be determined in the \n * following way:\n *\n * |[\n * void add_if_writable (GdkPixbufFormat *data, GSList **list)\n * {\n *   if (gdk_pixbuf_format_is_writable (data))\n *     *list = g_slist_prepend (*list, data);\n * }\n * \n * GSList *formats = gdk_pixbuf_get_formats ();\n * GSList *writable_formats = NULL;\n * g_slist_foreach (formats, add_if_writable, &writable_formats);\n * g_slist_free (formats);\n * ]|\n *\n * If @error is set, %FALSE will be returned. Possible errors include \n * those in the #GDK_PIXBUF_ERROR domain and those in the #G_FILE_ERROR domain.\n *\n * The variable argument list should be %NULL-terminated; if not empty,\n * it should contain pairs of strings that modify the save\n * parameters. For example:\n * |[\n * gdk_pixbuf_save (pixbuf, handle, \"jpeg\", &error, \"quality\", \"100\", NULL);\n * ]|\n *\n * Currently only few parameters exist. JPEG images can be saved with a\n * \"quality\" parameter; its value should be in the range [0,100]. JPEG\n * and PNG density can be set by setting the \"x-dpi\" and \"y-dpi\" parameters\n * to the appropriate values in dots per inch.\n *\n * Text chunks can be attached to PNG images by specifying parameters of\n * the form \"tEXt::key\", where key is an ASCII string of length 1-79.\n * The values are UTF-8 encoded strings. The PNG compression level can\n * be specified using the \"compression\" parameter; it's value is in an\n * integer in the range of [0,9].\n *\n * ICC color profiles can also be embedded into PNG, JPEG and TIFF images.\n * The \"icc-profile\" value should be the complete ICC profile encoded\n * into base64.\n *\n * |[\n * gchar *contents;\n * gchar *contents_encode;\n * gsize length;\n * g_file_get_contents (\"/home/hughsie/.color/icc/L225W.icm\", &contents, &length, NULL);\n * contents_encode = g_base64_encode ((const guchar *) contents, length);\n * gdk_pixbuf_save (pixbuf, handle, \"png\", &error, \"icc-profile\", contents_encode, NULL);\n * ]|\n *\n * TIFF images recognize: (1) a \"bits-per-sample\" option (integer) which\n * can be either 1 for saving bi-level CCITTFAX4 images, or 8 for saving\n * 8-bits per sample; (2) a \"compression\" option (integer) which can be\n * 1 for no compression, 2 for Huffman, 5 for LZW, 7 for JPEG and 8 for\n * DEFLATE (see the libtiff documentation and tiff.h for all supported\n * codec values); (3) an \"icc-profile\" option (zero-terminated string)\n * containing a base64 encoded ICC color profile.\n *\n * ICO images can be saved in depth 16, 24, or 32, by using the \"depth\"\n * parameter. When the ICO saver is given \"x_hot\" and \"y_hot\" parameters,\n * it produces a CUR instead of an ICO.\n *\n * Return value: whether an error was set\n **/\ngboolean\ngdk_pixbuf_save (GdkPixbuf  *pixbuf, \n                 const char *filename, \n                 const char *type, \n                 GError    **error,\n                 ...)\n{\n        gchar **keys = NULL;\n        gchar **values = NULL;\n        va_list args;\n        gboolean result;\n\n        g_return_val_if_fail (error == NULL || *error == NULL, FALSE);\n        \n        va_start (args, error);\n        \n        collect_save_options (args, &keys, &values);\n        \n        va_end (args);\n\n        result = gdk_pixbuf_savev (pixbuf, filename, type,\n                                   keys, values,\n                                   error);\n\n        g_strfreev (keys);\n        g_strfreev (values);\n\n        return result;\n}\n\n/**\n * gdk_pixbuf_savev:\n * @pixbuf: a #GdkPixbuf.\n * @filename: (type filename): name of file to save.\n * @type: name of file format.\n * @option_keys: (array zero-terminated=1): name of options to set, %NULL-terminated\n * @option_values: (array zero-terminated=1): values for named options\n * @error: (allow-none): return location for error, or %NULL\n *\n * Saves pixbuf to a file in @type, which is currently \"jpeg\", \"png\", \"tiff\", \"ico\" or \"bmp\".\n * If @error is set, %FALSE will be returned. \n * See gdk_pixbuf_save () for more details.\n *\n * Return value: whether an error was set\n **/\n\ngboolean\ngdk_pixbuf_savev (GdkPixbuf  *pixbuf, \n                  const char *filename, \n                  const char *type,\n                  char      **option_keys,\n                  char      **option_values,\n                  GError    **error)\n{\n        FILE *f = NULL;\n        gboolean result;\n       \n        g_return_val_if_fail (GDK_IS_PIXBUF (pixbuf), FALSE);\n        g_return_val_if_fail (gdk_pixbuf_get_width (pixbuf) >= 0, FALSE);\n        g_return_val_if_fail (gdk_pixbuf_get_height (pixbuf) >= 0, FALSE);\n        g_return_val_if_fail (gdk_pixbuf_get_n_channels (pixbuf) >= 0, FALSE);\n        g_return_val_if_fail (filename != NULL, FALSE);\n        g_return_val_if_fail (type != NULL, FALSE);\n        g_return_val_if_fail (error == NULL || *error == NULL, FALSE);\n       \n        f = g_fopen (filename, \"wb\");\n        \n        if (f == NULL) {\n                gint save_errno = errno;\n                gchar *display_name = g_filename_display_name (filename);\n                g_set_error (error,\n                             G_FILE_ERROR,\n                             g_file_error_from_errno (save_errno),\n                             _(\"Failed to open \u201c%s\u201d for writing: %s\"),\n                             display_name,\n                             g_strerror (save_errno));\n                g_free (display_name);\n                return FALSE;\n        }\n\n       \n       result = gdk_pixbuf_real_save (pixbuf, f, type,\n                                      option_keys, option_values,\n                                      error);\n       \n       \n       if (!result) {\n               g_return_val_if_fail (error == NULL || *error != NULL, FALSE);\n               fclose (f);\n               g_unlink (filename);\n               return FALSE;\n       }\n\n       if (fclose (f) < 0) {\n               gint save_errno = errno;\n               gchar *display_name = g_filename_display_name (filename);\n               g_set_error (error,\n                            G_FILE_ERROR,\n                            g_file_error_from_errno (save_errno),\n                            _(\"Failed to close \u201c%s\u201d while writing image, all data may not have been saved: %s\"),\n                            display_name,\n                            g_strerror (save_errno));\n               g_free (display_name);\n               return FALSE;\n       }\n       \n       return TRUE;\n}\n\n#ifdef G_OS_WIN32\n\n/**\n * gdk_pixbuf_savev_utf8:\n * @pixbuf: a #GdkPixbuf.\n * @filename: name of file to save.\n * @type: name of file format.\n * @option_keys: (array zero-terminated=1): name of options to set, %NULL-terminated\n * @option_values: (array zero-terminated=1): values for named options\n * @error: (allow-none): return location for error, or %NULL\n *\n * Same as gdk_pixbuf_savev()\n *\n * Return value: whether an error was set\n **/\ngboolean\ngdk_pixbuf_savev_utf8 (GdkPixbuf  *pixbuf,\n                       const char *filename,\n                       const char *type,\n                       char      **option_keys,\n                       char      **option_values,\n                       GError    **error)\n{\n    return gdk_pixbuf_savev (pixbuf, filename, type, option_keys,\n                             option_values, error);\n}\n\n#endif\n\n/**\n * gdk_pixbuf_save_to_callback:\n * @pixbuf: a #GdkPixbuf.\n * @save_func: (scope call): a function that is called to save each block of data that\n *   the save routine generates.\n * @user_data: user data to pass to the save function.\n * @type: name of file format.\n * @error: (allow-none): return location for error, or %NULL\n * @...: list of key-value save options\n *\n * Saves pixbuf in format @type by feeding the produced data to a \n * callback. Can be used when you want to store the image to something \n * other than a file, such as an in-memory buffer or a socket.  \n * If @error is set, %FALSE will be returned. Possible errors\n * include those in the #GDK_PIXBUF_ERROR domain and whatever the save\n * function generates.\n *\n * See gdk_pixbuf_save() for more details.\n *\n * Return value: whether an error was set\n *\n * Since: 2.4\n **/\ngboolean\ngdk_pixbuf_save_to_callback    (GdkPixbuf  *pixbuf,\n                                GdkPixbufSaveFunc save_func,\n                                gpointer user_data,\n                                const char *type, \n                                GError    **error,\n                                ...)\n{\n        gchar **keys = NULL;\n        gchar **values = NULL;\n        va_list args;\n        gboolean result;\n        \n        g_return_val_if_fail (error == NULL || *error == NULL, FALSE);\n        \n        va_start (args, error);\n        \n        collect_save_options (args, &keys, &values);\n        \n        va_end (args);\n\n        result = gdk_pixbuf_save_to_callbackv (pixbuf, save_func, user_data,\n                                               type, keys, values,\n                                               error);\n\n        g_strfreev (keys);\n        g_strfreev (values);\n\n        return result;\n}\n\n/**\n * gdk_pixbuf_save_to_callbackv:\n * @pixbuf: a #GdkPixbuf.\n * @save_func: (scope call): a function that is called to save each block of data that\n *   the save routine generates.\n * @user_data: (closure): user data to pass to the save function.\n * @type: name of file format.\n * @option_keys: (array zero-terminated=1) (element-type utf8): name of options to set, %NULL-terminated\n * @option_values: (array zero-terminated=1) (element-type utf8): values for named options\n * @error: (allow-none): return location for error, or %NULL\n *\n * Saves pixbuf to a callback in format @type, which is currently \"jpeg\",\n * \"png\", \"tiff\", \"ico\" or \"bmp\".  If @error is set, %FALSE will be returned. See\n * gdk_pixbuf_save_to_callback () for more details.\n *\n * Return value: whether an error was set\n *\n * Since: 2.4\n **/\ngboolean\ngdk_pixbuf_save_to_callbackv   (GdkPixbuf  *pixbuf, \n                                GdkPixbufSaveFunc save_func,\n                                gpointer user_data,\n                                const char *type,\n                                char      **option_keys,\n                                char      **option_values,\n                                GError    **error)\n{\n        gboolean result;\n        \n        g_return_val_if_fail (GDK_IS_PIXBUF (pixbuf), FALSE);\n        g_return_val_if_fail (gdk_pixbuf_get_width (pixbuf) >= 0, FALSE);\n        g_return_val_if_fail (gdk_pixbuf_get_height (pixbuf) >= 0, FALSE);\n        g_return_val_if_fail (gdk_pixbuf_get_n_channels (pixbuf) >= 0, FALSE);\n        g_return_val_if_fail (save_func != NULL, FALSE);\n        g_return_val_if_fail (type != NULL, FALSE);\n        g_return_val_if_fail (error == NULL || *error == NULL, FALSE);\n       \n       result = gdk_pixbuf_real_save_to_callback (pixbuf,\n                                                  save_func, user_data, type,\n                                                  option_keys, option_values,\n                                                  error);\n       \n       if (!result) {\n               g_return_val_if_fail (error == NULL || *error != NULL, FALSE);\n               return FALSE;\n       }\n\n       return TRUE;\n}\n\n/**\n * gdk_pixbuf_save_to_buffer:\n * @pixbuf: a #GdkPixbuf.\n * @buffer: (array length=buffer_size) (out) (element-type guint8): location to receive a pointer\n *   to the new buffer.\n * @buffer_size: location to receive the size of the new buffer.\n * @type: name of file format.\n * @error: (allow-none): return location for error, or %NULL\n * @...: list of key-value save options\n *\n * Saves pixbuf to a new buffer in format @type, which is currently \"jpeg\",\n * \"png\", \"tiff\", \"ico\" or \"bmp\".  This is a convenience function that uses\n * gdk_pixbuf_save_to_callback() to do the real work. Note that the buffer \n * is not nul-terminated and may contain embedded  nuls.\n * If @error is set, %FALSE will be returned and @buffer will be set to\n * %NULL. Possible errors include those in the #GDK_PIXBUF_ERROR\n * domain.\n *\n * See gdk_pixbuf_save() for more details.\n *\n * Return value: whether an error was set\n *\n * Since: 2.4\n **/\ngboolean\ngdk_pixbuf_save_to_buffer      (GdkPixbuf  *pixbuf,\n                                gchar     **buffer,\n                                gsize      *buffer_size,\n                                const char *type, \n                                GError    **error,\n                                ...)\n{\n        gchar **keys = NULL;\n        gchar **values = NULL;\n        va_list args;\n        gboolean result;\n        \n        g_return_val_if_fail (error == NULL || *error == NULL, FALSE);\n        \n        va_start (args, error);\n        \n        collect_save_options (args, &keys, &values);\n        \n        va_end (args);\n\n        result = gdk_pixbuf_save_to_bufferv (pixbuf, buffer, buffer_size,\n                                             type, keys, values,\n                                             error);\n\n        g_strfreev (keys);\n        g_strfreev (values);\n\n        return result;\n}\n\nstruct SaveToBufferData {\n        gchar *buffer;\n        gsize len, max;\n};\n\nstatic gboolean\nsave_to_buffer_callback (const gchar *data,\n                         gsize count,\n                         GError **error,\n                         gpointer user_data)\n{\n        struct SaveToBufferData *sdata = user_data;\n        gchar *new_buffer;\n        gsize new_max;\n\n        if (sdata->len + count > sdata->max) {\n                new_max = MAX (sdata->max*2, sdata->len + count);\n                new_buffer = g_try_realloc (sdata->buffer, new_max);\n                if (!new_buffer) {\n                        g_set_error_literal (error,\n                                             GDK_PIXBUF_ERROR,\n                                             GDK_PIXBUF_ERROR_INSUFFICIENT_MEMORY,\n                                             _(\"Insufficient memory to save image into a buffer\"));\n                        return FALSE;\n                }\n                sdata->buffer = new_buffer;\n                sdata->max = new_max;\n        }\n        memcpy (sdata->buffer + sdata->len, data, count);\n        sdata->len += count;\n        return TRUE;\n}\n\n/**\n * gdk_pixbuf_save_to_bufferv:\n * @pixbuf: a #GdkPixbuf.\n * @buffer: (array length=buffer_size) (out) (element-type guint8):\n *   location to receive a pointer to the new buffer.\n * @buffer_size: location to receive the size of the new buffer.\n * @type: name of file format.\n * @option_keys: (array zero-terminated=1): name of options to set, %NULL-terminated\n * @option_values: (array zero-terminated=1): values for named options\n * @error: (allow-none): return location for error, or %NULL\n *\n * Saves pixbuf to a new buffer in format @type, which is currently \"jpeg\",\n * \"tiff\", \"png\", \"ico\" or \"bmp\".  See gdk_pixbuf_save_to_buffer() \n * for more details.\n *\n * Return value: whether an error was set\n *\n * Since: 2.4\n **/\ngboolean\ngdk_pixbuf_save_to_bufferv     (GdkPixbuf  *pixbuf,\n                                gchar     **buffer,\n                                gsize      *buffer_size,\n                                const char *type, \n                                char      **option_keys,\n                                char      **option_values,\n                                GError    **error)\n{\n        static const gint initial_max = 1024;\n        struct SaveToBufferData sdata;\n\n        *buffer = NULL;\n        *buffer_size = 0;\n\n        sdata.buffer = g_try_malloc (initial_max);\n        sdata.max = initial_max;\n        sdata.len = 0;\n        if (!sdata.buffer) {\n                g_set_error_literal (error,\n                                     GDK_PIXBUF_ERROR,\n                                     GDK_PIXBUF_ERROR_INSUFFICIENT_MEMORY,\n                                     _(\"Insufficient memory to save image into a buffer\"));\n                return FALSE;\n        }\n\n        if (!gdk_pixbuf_save_to_callbackv (pixbuf,\n                                           save_to_buffer_callback, &sdata,\n                                           type, option_keys, option_values,\n                                           error)) {\n                g_free (sdata.buffer);\n                return FALSE;\n        }\n\n        *buffer = sdata.buffer;\n        *buffer_size = sdata.len;\n        return TRUE;\n}\n\ntypedef struct {\n        GOutputStream *stream;\n        GCancellable  *cancellable;\n} SaveToStreamData;\n\nstatic gboolean\nsave_to_stream (const gchar  *buffer,\n                gsize         count,\n                GError      **error,\n                gpointer      data)\n{\n        SaveToStreamData *sdata = (SaveToStreamData *)data;\n        gsize remaining;\n        gssize written;\n        GError *my_error = NULL;\n\n        remaining = count;\n        written = 0;\n        while (remaining > 0) {\n                buffer += written;\n                remaining -= written;\n                written = g_output_stream_write (sdata->stream, \n                                                 buffer, remaining, \n                                                 sdata->cancellable, \n                                                 &my_error);\n                if (written < 0) {\n                        if (!my_error) {\n                                g_set_error_literal (error,\n                                                     G_IO_ERROR, 0,\n                                                     _(\"Error writing to image stream\"));\n                        }\n                        else {\n                                g_propagate_error (error, my_error);\n                        }\n                        return FALSE;\n                }\n        }\n\n        return TRUE;\n}\n\n/**\n * gdk_pixbuf_save_to_streamv:\n * @pixbuf: a #GdkPixbuf\n * @stream: a #GOutputStream to save the pixbuf to\n * @type: name of file format\n * @option_keys: (array zero-terminated=1): name of options to set, %NULL-terminated\n * @option_values: (array zero-terminated=1): values for named options\n * @cancellable: (allow-none): optional #GCancellable object, %NULL to ignore\n * @error: (allow-none): return location for error, or %NULL\n *\n * Saves @pixbuf to an output stream.\n *\n * Supported file formats are currently \"jpeg\", \"tiff\", \"png\", \"ico\" or\n * \"bmp\". See gdk_pixbuf_save_to_stream() for more details.\n *\n * Returns: %TRUE if the pixbuf was saved successfully, %FALSE if an\n *     error was set.\n *\n * Since: 2.36\n */\ngboolean\ngdk_pixbuf_save_to_streamv (GdkPixbuf      *pixbuf,\n                            GOutputStream  *stream,\n                            const char     *type,\n                            char          **option_keys,\n                            char          **option_values,\n                            GCancellable   *cancellable,\n                            GError        **error)\n{\n        SaveToStreamData data;\n\n        data.stream = stream;\n        data.cancellable = cancellable;\n\n        return gdk_pixbuf_save_to_callbackv (pixbuf, save_to_stream,\n                                             &data, type,\n                                             option_keys, option_values,\n                                             error);\n}\n\n/**\n * gdk_pixbuf_save_to_stream:\n * @pixbuf: a #GdkPixbuf\n * @stream: a #GOutputStream to save the pixbuf to\n * @type: name of file format\n * @cancellable: (allow-none): optional #GCancellable object, %NULL to ignore\n * @error: (allow-none): return location for error, or %NULL\n * @...: list of key-value save options\n *\n * Saves @pixbuf to an output stream.\n *\n * Supported file formats are currently \"jpeg\", \"tiff\", \"png\", \"ico\" or \n * \"bmp\". See gdk_pixbuf_save_to_buffer() for more details.\n *\n * The @cancellable can be used to abort the operation from another \n * thread. If the operation was cancelled, the error %G_IO_ERROR_CANCELLED \n * will be returned. Other possible errors are in the #GDK_PIXBUF_ERROR \n * and %G_IO_ERROR domains. \n *\n * The stream is not closed.\n *\n * Returns: %TRUE if the pixbuf was saved successfully, %FALSE if an\n *     error was set.\n *\n * Since: 2.14\n */\ngboolean\ngdk_pixbuf_save_to_stream (GdkPixbuf      *pixbuf,\n                           GOutputStream  *stream,\n                           const char     *type,\n                           GCancellable   *cancellable,\n                           GError        **error,\n                           ...)\n{\n        gboolean res;\n        gchar **keys = NULL;\n        gchar **values = NULL;\n        va_list args;\n\n        va_start (args, error);\n        collect_save_options (args, &keys, &values);\n        va_end (args);\n\n        res = gdk_pixbuf_save_to_streamv (pixbuf, stream, type,\n                                          keys, values,\n                                          cancellable, error);\n\n        g_strfreev (keys);\n        g_strfreev (values);\n\n        return res;\n}\n\ntypedef struct {\n\tGOutputStream *stream;\n\tgchar *type;\n\tgchar **keys;\n\tgchar **values;\n} SaveToStreamAsyncData;\n\nstatic void\nsave_to_stream_async_data_free (SaveToStreamAsyncData *data)\n{\n\tif (data->stream)\n\t\tg_object_unref (data->stream);\n\tg_strfreev (data->keys);\n\tg_strfreev (data->values);\n\tg_free (data->type);\n\tg_slice_free (SaveToStreamAsyncData, data);\n}\n\nstatic void\nsave_to_stream_thread (GTask                 *task,\n\t\t       GdkPixbuf             *pixbuf,\n\t\t       SaveToStreamAsyncData *data,\n\t\t       GCancellable          *cancellable)\n{\n\tSaveToStreamData sync_data;\n\tgboolean retval;\n\tGError *error = NULL;\n\n\tsync_data.stream = data->stream;\n\tsync_data.cancellable = cancellable;\n\n\tretval = gdk_pixbuf_save_to_callbackv (pixbuf, save_to_stream,\n\t\t\t\t\t       &sync_data, data->type,\n\t\t\t\t\t       data->keys, data->values,\n\t\t\t\t\t       &error);\n\n\tif (retval == FALSE) {\n\t\tg_task_return_error (task, error);\n\t} else {\n\t\tg_task_return_boolean (task, TRUE);\n\t}\n}\n\n/**\n * gdk_pixbuf_save_to_streamv_async:\n * @pixbuf: a #GdkPixbuf\n * @stream: a #GOutputStream to which to save the pixbuf\n * @type: name of file format\n * @option_keys: (array zero-terminated=1): name of options to set, %NULL-terminated\n * @option_values: (array zero-terminated=1): values for named options\n * @cancellable: (allow-none): optional #GCancellable object, %NULL to ignore\n * @callback: a #GAsyncReadyCallback to call when the pixbuf is saved\n * @user_data: the data to pass to the callback function\n *\n * Saves @pixbuf to an output stream asynchronously.\n *\n * For more details see gdk_pixbuf_save_to_streamv(), which is the synchronous\n * version of this function.\n *\n * When the operation is finished, @callback will be called in the main thread.\n * You can then call gdk_pixbuf_save_to_stream_finish() to get the result of the operation.\n *\n * Since: 2.36\n **/\nvoid\ngdk_pixbuf_save_to_streamv_async (GdkPixbuf           *pixbuf,\n                                  GOutputStream       *stream,\n                                  const gchar         *type,\n                                  gchar              **option_keys,\n                                  gchar              **option_values,\n                                  GCancellable        *cancellable,\n                                  GAsyncReadyCallback  callback,\n                                  gpointer             user_data)\n{\n        GTask *task;\n        SaveToStreamAsyncData *data;\n\n        g_return_if_fail (GDK_IS_PIXBUF (pixbuf));\n        g_return_if_fail (gdk_pixbuf_get_width (pixbuf) >= 0);\n        g_return_if_fail (gdk_pixbuf_get_height (pixbuf) >= 0);\n        g_return_if_fail (gdk_pixbuf_get_n_channels (pixbuf) >= 0);\n        g_return_if_fail (G_IS_OUTPUT_STREAM (stream));\n        g_return_if_fail (type != NULL);\n        g_return_if_fail (callback != NULL);\n        g_return_if_fail (!cancellable || G_IS_CANCELLABLE (cancellable));\n\n        data = g_slice_new (SaveToStreamAsyncData);\n        data->stream = g_object_ref (stream);\n        data->type = g_strdup (type);\n        data->keys = g_strdupv (option_keys);\n        data->values = g_strdupv (option_values);\n\n        task = g_task_new (pixbuf, cancellable, callback, user_data);\n        g_task_set_source_tag (task, gdk_pixbuf_save_to_streamv_async);\n        g_task_set_task_data (task, data, (GDestroyNotify) save_to_stream_async_data_free);\n        g_task_run_in_thread (task, (GTaskThreadFunc) save_to_stream_thread);\n        g_object_unref (task);\n}\n\n/**\n * gdk_pixbuf_save_to_stream_async:\n * @pixbuf: a #GdkPixbuf\n * @stream: a #GOutputStream to which to save the pixbuf\n * @type: name of file format\n * @cancellable: (allow-none): optional #GCancellable object, %NULL to ignore\n * @callback: a #GAsyncReadyCallback to call when the pixbuf is saved\n * @user_data: the data to pass to the callback function\n * @...: list of key-value save options\n *\n * Saves @pixbuf to an output stream asynchronously.\n *\n * For more details see gdk_pixbuf_save_to_stream(), which is the synchronous\n * version of this function.\n *\n * When the operation is finished, @callback will be called in the main thread.\n * You can then call gdk_pixbuf_save_to_stream_finish() to get the result of the operation.\n *\n * Since: 2.24\n **/\nvoid\ngdk_pixbuf_save_to_stream_async (GdkPixbuf           *pixbuf,\n\t\t\t\t GOutputStream       *stream,\n\t\t\t\t const gchar         *type,\n\t\t\t\t GCancellable        *cancellable,\n\t\t\t\t GAsyncReadyCallback  callback,\n\t\t\t\t gpointer             user_data,\n\t\t\t\t ...)\n{\n        gchar **keys = NULL;\n        gchar **values = NULL;\n        va_list args;\n\n        g_return_if_fail (GDK_IS_PIXBUF (pixbuf));\n        g_return_if_fail (gdk_pixbuf_get_width (pixbuf) >= 0);\n        g_return_if_fail (gdk_pixbuf_get_height (pixbuf) >= 0);\n        g_return_if_fail (gdk_pixbuf_get_n_channels (pixbuf) >= 0);\n        g_return_if_fail (G_IS_OUTPUT_STREAM (stream));\n        g_return_if_fail (type != NULL);\n        g_return_if_fail (callback != NULL);\n        g_return_if_fail (!cancellable || G_IS_CANCELLABLE (cancellable));\n\n        va_start (args, user_data);\n        collect_save_options (args, &keys, &values);\n        va_end (args);\n\n        gdk_pixbuf_save_to_streamv_async (pixbuf, stream, type,\n                                          keys, values,\n                                          cancellable, callback, user_data);\n        g_strfreev (keys);\n        g_strfreev (values);\n}\n\n/**\n * gdk_pixbuf_save_to_stream_finish:\n * @async_result: a #GAsyncResult\n * @error: a #GError, or %NULL\n *\n * Finishes an asynchronous pixbuf save operation started with\n * gdk_pixbuf_save_to_stream_async().\n *\n * Return value: %TRUE if the pixbuf was saved successfully, %FALSE if an error was set.\n *\n * Since: 2.24\n **/\ngboolean\ngdk_pixbuf_save_to_stream_finish (GAsyncResult  *async_result,\n\t\t\t\t  GError       **error)\n{\n\tGTask *task;\n\n\t/* Can not use g_task_is_valid because our GTask has a\n\t * source_object which is not available to us anymore.\n\t */\n\tg_return_val_if_fail (G_IS_TASK (async_result), FALSE);\n\n\ttask = G_TASK (async_result);\n\n\tg_return_val_if_fail (!error || (error && !*error), FALSE);\n\tg_warn_if_fail (g_task_get_source_tag (task) == gdk_pixbuf_save_to_stream_async ||\n\t\t\tg_task_get_source_tag (task) == gdk_pixbuf_save_to_streamv_async);\n\n\treturn g_task_propagate_boolean (task, error);\n}\n\n/**\n * gdk_pixbuf_format_get_name:\n * @format: a #GdkPixbufFormat\n *\n * Returns the name of the format.\n * \n * Return value: the name of the format. \n *\n * Since: 2.2\n */\ngchar *\ngdk_pixbuf_format_get_name (GdkPixbufFormat *format)\n{\n        g_return_val_if_fail (format != NULL, NULL);\n\n        return g_strdup (format->name);\n}\n\n/**\n * gdk_pixbuf_format_get_description:\n * @format: a #GdkPixbufFormat\n *\n * Returns a description of the format.\n * \n * Return value: a description of the format.\n *\n * Since: 2.2\n */\ngchar *\ngdk_pixbuf_format_get_description (GdkPixbufFormat *format)\n{\n        gchar *domain;\n        const gchar *description;\n        g_return_val_if_fail (format != NULL, NULL);\n\n        if (format->domain != NULL) \n                domain = format->domain;\n        else \n                domain = GETTEXT_PACKAGE;\n        description = g_dgettext (domain, format->description);\n\n        return g_strdup (description);\n}\n\n/**\n * gdk_pixbuf_format_get_mime_types:\n * @format: a #GdkPixbufFormat\n *\n * Returns the mime types supported by the format.\n * \n * Return value: (transfer full): a %NULL-terminated array of mime types which must be freed with \n * g_strfreev() when it is no longer needed.\n *\n * Since: 2.2\n */\ngchar **\ngdk_pixbuf_format_get_mime_types (GdkPixbufFormat *format)\n{\n        g_return_val_if_fail (format != NULL, NULL);\n\n        return g_strdupv (format->mime_types);\n}\n\n/**\n * gdk_pixbuf_format_get_extensions:\n * @format: a #GdkPixbufFormat\n *\n * Returns the filename extensions typically used for files in the \n * given format.\n * \n * Return value: (transfer full): a %NULL-terminated array of filename extensions which must be\n * freed with g_strfreev() when it is no longer needed.\n *\n * Since: 2.2\n */\ngchar **\ngdk_pixbuf_format_get_extensions (GdkPixbufFormat *format)\n{\n        g_return_val_if_fail (format != NULL, NULL);\n\n        return g_strdupv (format->extensions);\n}\n\n/**\n * gdk_pixbuf_format_is_writable:\n * @format: a #GdkPixbufFormat\n *\n * Returns whether pixbufs can be saved in the given format.\n * \n * Return value: whether pixbufs can be saved in the given format.\n *\n * Since: 2.2\n */\ngboolean\ngdk_pixbuf_format_is_writable (GdkPixbufFormat *format)\n{\n        g_return_val_if_fail (format != NULL, FALSE);\n\n        return (format->flags & GDK_PIXBUF_FORMAT_WRITABLE) != 0;\n}\n\n/**\n * gdk_pixbuf_format_is_scalable:\n * @format: a #GdkPixbufFormat\n *\n * Returns whether this image format is scalable. If a file is in a \n * scalable format, it is preferable to load it at the desired size, \n * rather than loading it at the default size and scaling the \n * resulting pixbuf to the desired size.\n * \n * Return value: whether this image format is scalable.\n *\n * Since: 2.6\n */\ngboolean\ngdk_pixbuf_format_is_scalable (GdkPixbufFormat *format)\n{\n        g_return_val_if_fail (format != NULL, FALSE);\n\n        return (format->flags & GDK_PIXBUF_FORMAT_SCALABLE) != 0;\n}\n\n/**\n * gdk_pixbuf_format_is_disabled:\n * @format: a #GdkPixbufFormat\n *\n * Returns whether this image format is disabled. See\n * gdk_pixbuf_format_set_disabled().\n * \n * Return value: whether this image format is disabled.\n *\n * Since: 2.6\n */\ngboolean   \ngdk_pixbuf_format_is_disabled (GdkPixbufFormat *format)\n{\n        g_return_val_if_fail (format != NULL, FALSE);\n\n        return format->disabled;        \n}\n\n/**\n * gdk_pixbuf_format_set_disabled:\n * @format: a #GdkPixbufFormat\n * @disabled: %TRUE to disable the format @format\n *\n * Disables or enables an image format. If a format is disabled, \n * gdk-pixbuf won't use the image loader for this format to load \n * images. Applications can use this to avoid using image loaders \n * with an inappropriate license, see gdk_pixbuf_format_get_license().\n *\n * Since: 2.6\n */\nvoid \ngdk_pixbuf_format_set_disabled (GdkPixbufFormat *format,\n                                gboolean         disabled)\n{\n        g_return_if_fail (format != NULL);\n        \n        format->disabled = disabled != FALSE;\n}\n\n/**\n * gdk_pixbuf_format_get_license:\n * @format: a #GdkPixbufFormat\n *\n * Returns information about the license of the image loader for the format. The\n * returned string should be a shorthand for a wellknown license, e.g. \"LGPL\",\n * \"GPL\", \"QPL\", \"GPL/QPL\", or \"other\" to indicate some other license.  This\n * string should be freed with g_free() when it's no longer needed.\n *\n * Returns: a string describing the license of @format. \n *\n * Since: 2.6\n */\ngchar*\ngdk_pixbuf_format_get_license (GdkPixbufFormat *format)\n{\n        g_return_val_if_fail (format != NULL, NULL);\n\n        return g_strdup (format->license);\n}\n\nGdkPixbufFormat *\n_gdk_pixbuf_get_format (GdkPixbufModule *module)\n{\n        g_return_val_if_fail (module != NULL, NULL);\n\n        return module->info;\n}\n\n/**\n * gdk_pixbuf_get_formats:\n *\n * Obtains the available information about the image formats supported\n * by GdkPixbuf.\n *\n * Returns: (transfer container) (element-type GdkPixbufFormat): A list of\n * #GdkPixbufFormats describing the supported image formats. The list should\n * be freed when it is no longer needed, but the structures themselves are\n * owned by #GdkPixbuf and should not be freed.\n *\n * Since: 2.2\n */\nGSList *\ngdk_pixbuf_get_formats (void)\n{\n        GSList *result = NULL;\n        GSList *modules;\n\n        for (modules = get_file_formats (); modules; modules = g_slist_next (modules)) {\n                GdkPixbufModule *module = (GdkPixbufModule *)modules->data;\n                GdkPixbufFormat *info = _gdk_pixbuf_get_format (module);\n                result = g_slist_prepend (result, info);\n        }\n\n        return result;\n}\n\n/**\n * gdk_pixbuf_format_copy:\n * @format: a #GdkPixbufFormat\n *\n * Creates a copy of @format\n *\n * Return value: the newly allocated copy of a #GdkPixbufFormat. Use\n *   gdk_pixbuf_format_free() to free the resources when done\n *\n * Since: 2.22\n */\nGdkPixbufFormat *\ngdk_pixbuf_format_copy (const GdkPixbufFormat *format)\n{\n        if (G_LIKELY (format != NULL))\n                return g_slice_dup (GdkPixbufFormat, format);\n\n        return NULL;\n}\n\n/**\n * gdk_pixbuf_format_free:\n * @format: a #GdkPixbufFormat\n *\n * Frees the resources allocated when copying a #GdkPixbufFormat\n * using gdk_pixbuf_format_copy()\n *\n * Since: 2.22\n */\nvoid\ngdk_pixbuf_format_free (GdkPixbufFormat *format)\n{\n        if (G_LIKELY (format != NULL))\n                g_slice_free (GdkPixbufFormat, format);\n}\n\n/**\n * gdk_pixbuf_format_is_save_option_supported:\n * @format: a #GdkPixbufFormat\n * @option_key: the name of an option\n *\n * Returns %TRUE if the save option specified by @option_key is supported when\n * saving a pixbuf using the module implementing @format.\n * See gdk_pixbuf_save() for more information about option keys.\n *\n * Returns: %TRUE if the specified option is supported\n *\n * Since: 2.36\n */\ngboolean\ngdk_pixbuf_format_is_save_option_supported (GdkPixbufFormat *format,\n                                            const gchar *option_key)\n{\n        GdkPixbufModule *module;\n\n        g_return_val_if_fail (format != NULL, FALSE);\n        g_return_val_if_fail (option_key != NULL, FALSE);\n\n        module = _gdk_pixbuf_get_named_module (format->name, NULL);\n        if (!module)\n                return FALSE;\n\n        if (!_gdk_pixbuf_load_module (module, NULL))\n                return FALSE;\n\n        if (!module->is_save_option_supported)\n                return FALSE;\n\n        return (* module->is_save_option_supported) (option_key);\n}\n\nG_DEFINE_BOXED_TYPE (GdkPixbufFormat, gdk_pixbuf_format,\n\t\t     gdk_pixbuf_format_copy,\n\t\t     gdk_pixbuf_format_free)\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/pixbuf-randomly-modified.c",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/icc-profile.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/bug143608-comment.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/dpi.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/cve-2015-4491.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/aero.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/circular-table.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/pixbuf-random.c",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/pixbuf-read.c",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-image-rle.pixdata",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/premature-end.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/icc-profile.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/dpi.tiff",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/premature-end.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/large.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/dpi.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/bug725582-testrotate.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/large.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-animation.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/bug775218.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-image.pixdata",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/bug775693.pixdata",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/pixbuf-lowmem.c",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/1_partyanimsm2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-animation.ani",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-image.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/bug753605-atsize.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/pixbuf-save-ref.c",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/bug775229.pixdata",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/bug725582-testrotate.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/randomly-modified/decodecolormap.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/randomly-modified/bug776040.ico",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/randomly-modified/bug775697.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/randomly-modified/valid.1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/randomly-modified/valid.1.tiff",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/randomly-modified/valid.1.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/randomly-modified/valid.2.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/randomly-modified/bmp-line-overflow.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/randomly-modified/valid.1.jp2",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/randomly-modified/bug775242.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/randomly-modified/valid.1.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/randomly-modified/invalid.2.ico",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/randomly-modified/valid.2.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/randomly-modified/bug775648.qtif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/randomly-modified/bug775232.pnm",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/randomly-modified/valid.1.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/randomly-modified/valid.1.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/rle-too-many-pixels-2.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/colormap-too-small.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/bug785447.ico",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/rle-too-many-pixels-2.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/rle-too-many-pixels.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/squares.ico.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/bug785447.ico.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/mandatory-bitmasks.bmp.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/bug696331.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/colormap-too-small.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/mandatory-bitmasks.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/bug696331.png.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/rle-too-many-pixels.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/cat.jpg.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/cat.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/squares.ico",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-cmap-rle-8bpp-bottom-left.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-rle-32bpp-top-right.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-gray.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-rle-16bpp-top-left.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-cmap-8bpp-top-right.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-16bpp-bottom-left.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-rle-24bpp-bottom-right.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-rle-8bpp-bottom-left.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-opaque.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-rle-32bpp-top-left.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-32bpp-top-right.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-16bpp-top-right.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-16bpp-top-left.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-cmap-8bpp-bottom-left.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-16bpp-bottom-right.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-8bpp-bottom-right.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-cmap-8bpp-top-left.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-rle-8bpp-top-left.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-32bpp-bottom-left.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-cmap-8bpp-bottom-left.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-16bpp.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-8bpp-top-left.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-8bpp-top-right.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-8bpp-bottom-left.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-16bpp-bottom-left.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-24bpp-top-right.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-rle-16bpp-top-left.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-rle-32bpp-top-left.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-cmap.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-rle-16bpp-bottom-right.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-16bpp-bottom-left.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-32bpp-top-left.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-24bpp-bottom-left.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-32bpp-top-left.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-rle-8bpp-bottom-left.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-rle-16bpp-bottom-right.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-cmap-rle-8bpp-top-right.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-cmap-rle-8bpp-top-left.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-rle-16bpp-bottom-left.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-rle-24bpp-top-right.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-16bpp-top-left.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-cmap-rle-8bpp-bottom-right.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-cmap-rle-8bpp-bottom-left.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-16bpp-top-right.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-cmap-8bpp-bottom-right.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-16bpp-top-right.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-rle-16bpp-bottom-left.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-rle-32bpp-bottom-left.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-8bpp-top-left.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-16bpp-top-right.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-rle-32bpp-bottom-right.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-16bpp-top-left.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-rle-32bpp-bottom-left.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-rle-24bpp-top-right.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-cmap-8bpp-top-right.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-rle-32bpp-bottom-right.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-cmap-rle-8bpp-top-left.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-8bpp-bottom-left.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-8bpp-top-right.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-8bpp-bottom-right.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-rle-8bpp-top-right.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-32bpp-top-right.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-rle-24bpp-bottom-left.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-rle-16bpp-top-right.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-24bpp-bottom-right.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-opaque.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-24bpp-top-right.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-24bpp-top-left.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-32bpp-bottom-left.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-rle-8bpp-bottom-right.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-16bpp-top-left.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-rle-8bpp-bottom-right.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-rle-24bpp-bottom-left.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-rle-24bpp-bottom-right.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-32bpp-bottom-right.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-16bpp-bottom-right.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-32bpp-bottom-right.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-rle-8bpp-top-right.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-rle-24bpp-top-left.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-cmap-8bpp-bottom-right.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-cmap-8bpp-top-left.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-16bpp-bottom-right.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-rle-16bpp-top-right.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-cmap-rle-8bpp-top-right.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-cmap-rle-8bpp-bottom-right.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-16bpp-bottom-left.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-rle-24bpp-top-left.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-24bpp-bottom-right.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-24bpp-bottom-left.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-16bpp-bottom-right.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-24bpp-top-left.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-rle-8bpp-top-left.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/reftests/tga/gtk-logo-rle-32bpp-top-right.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/max-height.rgba",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/missing-pixels.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/extra-data.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/animation-speed.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/disabled-transparent.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/loop-buffer.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/dispose-keep.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/animation-erase.3.rgba",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/depth7.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/large-codes.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/all-greens.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/animation-fill.1.rgba",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/all-reds.rgba",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/no-clear.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/xmp-data.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/depth2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/image-inside-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/invalid-utf8-comment.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/image-overlap-bg.rgba",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/nul-comment.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/animation-no-delays.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/no-data.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/animation-erase.1.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/unknown-extension.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/all-reds.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/white-dot.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/icc-color-profile.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/images-combine.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/missing-pixels.rgba",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/animation-erase.2.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/depth6.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/double-clears.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/max-height.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/nul-application-extension.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/image-inside-bg.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/loop-max.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/image-overlap-bg.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/depth8.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/animation-fill.0.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/dispose-none.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/high-color.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/large-comment.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/random-image.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/animation.1.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/checkerboard.rgba",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/dispose-restore-previous.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/many-clears.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/max-size.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/loop-animexts.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/max-width.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/invalid-transparent.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/four-colors.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/loop-once.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/sRGB.icc",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/image-outside-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/max-width.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/comment.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/transparent.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/invalid-ascii-comment.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/image-outside-bg.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/depth5.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/transparent-dot.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/four-colors.rgba",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/max-codes.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/animation-erase.0.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/animation-fill.2.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/loop-buffer_max.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/plain-text.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/gif87a.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/image-zero-height.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/255-codes.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/animation.1.rgba",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/animation-zero-delays.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/dispose-restore-background.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/animation-fill.0.rgba",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/no-eoi.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/xmp-data-empty.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/icc-color-profile-empty.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/animation-erase.0.rgba",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/no-global-color-table.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/unknown-application-extension.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/white-dot.rgba",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/depth1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/all-greens.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/four-colors.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/no-clear-and-eoi.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/max-height.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/four-colors-transparent.rgba",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/image-inside-bg.rgba",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/local-color-table.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/4095-codes.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/animation-multi-image-explicit-zero-delay.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/animation.0.rgba",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/checkerboard.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/depth4.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/all-greens.rgba",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/animation-fill.2.rgba",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/image-overlap-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/missing-pixels.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/white-hline2.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/zero-size.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/zero-width.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/animation-erase.3.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/image-zero-width.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/animation-fill.3.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/invalid-colors.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/all-reds.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/animation-erase.2.rgba",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/invalid-background.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/four-colors-transparent.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/animation.3.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/images-overlap.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/high-color.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/gif87a-animation.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/animation-fill.3.rgba",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/animation.2.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/4095-codes-clear.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/all-blues.rgba",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/extra-pixels.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/random_image.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/zero-height.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/high-color.rgba",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/white-hline2.rgba",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/max-width.rgba",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/all-blues.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/random-image.rgba",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/animation.2.rgba",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/all-blues.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/animation.3.rgba",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/interlace.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/loop-infinite.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/animation-multi-image.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/animation-fill.1.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/animation.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/animation-erase.1.rgba",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/image-zero-size.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/depth3.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/gif-test-suite/animation.0.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/fail/invalid.2.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/fail/bug784903-overflow-dimensions.tiff",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/fail/bug776694.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/fail/bug779012.ico",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/fail/bug779016-infinite.icns",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/fail/invalid.3.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/fail/file3.jp2",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/fail/invalid.1.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/fail/invalid.1.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/fail/CVE-2017-2862.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/fail/bug785973.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/fail/invalid.3.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/fail/invalid.3.ico",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/fail/bug778584.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/fail/invalid.2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/fail/invalid.4.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/fail/invalid.4.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/fail/overflow.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/fail/invalid.1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/fail/invalid.1.ico",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/fail/colormap-image-without-colormap.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/fail/bug780269.tif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/fail/bug793470-crasher.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/tests/test-images/fail/bug777315.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/docs/apple-red-1a.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/docs/gnome-gmush-1.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/docs/apple-red-2c.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/docs/composite.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-ixl52226fa5l4xc4bzxjbxxo4yixgli3/spack-src/docs/composite.dia"
    ],
    "total_files": 690
}