{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-dracut-050-nnqdpidcvez4k4kdc3og4k5gknuxmn75/spack-src/dracut.sh": "#!/bin/bash -p\n#\n# Generator script for a dracut initramfs\n# Tries to retain some degree of compatibility with the command line\n# of the various mkinitrd implementations out there\n#\n\n# Copyright 2005-2013 Red Hat, Inc.  All rights reserved.\n#\n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 2 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n#\n\n# store for logging\n\nunset BASH_ENV\n\n# Verify bash version, current minimum is 4\nif (( BASH_VERSINFO[0] < 4 )); then\n    printf -- 'You need at least Bash 4 to use dracut, sorry.' >&2\n    exit 1\nfi\n\ndracut_args=( \"$@\" )\nreadonly dracut_cmd=\"$(readlink -f $0)\"\n\nset -o pipefail\n\nusage() {\n\t[[ $sysroot_l ]] && dracutsysrootdir=\"$sysroot_l\"\n    [[ $dracutbasedir ]] || dracutbasedir=$dracutsysrootdir/usr/lib/dracut\n    if [[ -f $dracutbasedir/dracut-version.sh ]]; then\n        . $dracutbasedir/dracut-version.sh\n    fi\n\n#                                                       80x25 linebreak here ^\n    cat << EOF\nUsage: $dracut_cmd [OPTION]... [<initramfs> [<kernel-version>]]\n\nVersion: $DRACUT_VERSION\n\nCreates initial ramdisk images for preloading modules\n\n  -h, --help  Display all options\n\nIf a [LIST] has multiple arguments, then you have to put these in quotes.\n\nFor example:\n\n    # dracut --add-drivers \"module1 module2\"  ...\n\nEOF\n}\n\nlong_usage() {\n    [[ $dracutbasedir ]] || dracutbasedir=$dracutsysrootdir/usr/lib/dracut\n    if [[ -f $dracutbasedir/dracut-version.sh ]]; then\n        . $dracutbasedir/dracut-version.sh\n    fi\n\n#                                                       80x25 linebreak here ^\n    cat << EOF\nUsage: $dracut_cmd [OPTION]... [<initramfs> [<kernel-version>]]\n\nVersion: $DRACUT_VERSION\n\nCreates initial ramdisk images for preloading modules\n\n  --kver [VERSION]      Set kernel version to [VERSION].\n  -f, --force           Overwrite existing initramfs file.\n  -a, --add [LIST]      Add a space-separated list of dracut modules.\n  --rebuild         Append arguments to those of existing image and rebuild\n  -m, --modules [LIST]  Specify a space-separated list of dracut modules to\n                         call when building the initramfs. Modules are located\n                         in /usr/lib/dracut/modules.d.\n  -o, --omit [LIST]     Omit a space-separated list of dracut modules.\n  --force-add [LIST]    Force to add a space-separated list of dracut modules\n                         to the default set of modules, when -H is specified.\n  -d, --drivers [LIST]  Specify a space-separated list of kernel modules to\n                         exclusively include in the initramfs.\n  --add-drivers [LIST]  Specify a space-separated list of kernel\n                         modules to add to the initramfs.\n  --force-drivers [LIST] Specify a space-separated list of kernel\n                         modules to add to the initramfs and make sure they\n                         are tried to be loaded via modprobe same as passing\n                         rd.driver.pre=DRIVER kernel parameter.\n  --omit-drivers [LIST] Specify a space-separated list of kernel\n                         modules not to add to the initramfs.\n  --filesystems [LIST]  Specify a space-separated list of kernel filesystem\n                         modules to exclusively include in the generic\n                         initramfs.\n  -k, --kmoddir [DIR]   Specify the directory, where to look for kernel\n                         modules\n  --fwdir [DIR]         Specify additional directories, where to look for\n                         firmwares, separated by :\n  --kernel-only         Only install kernel drivers and firmware files\n  --no-kernel           Do not install kernel drivers and firmware files\n  --print-cmdline       Print the kernel command line for the given disk layout\n  --early-microcode     Combine early microcode with ramdisk\n  --no-early-microcode  Do not combine early microcode with ramdisk\n  --kernel-cmdline [PARAMETERS] Specify default kernel command line parameters\n  --strip               Strip binaries in the initramfs\n  --nostrip             Do not strip binaries in the initramfs\n  --hardlink            Hardlink files in the initramfs\n  --nohardlink          Do not hardlink files in the initramfs\n  --prefix [DIR]        Prefix initramfs files with [DIR]\n  --noprefix            Do not prefix initramfs files\n  --mdadmconf           Include local /etc/mdadm.conf\n  --nomdadmconf         Do not include local /etc/mdadm.conf\n  --lvmconf             Include local /etc/lvm/lvm.conf\n  --nolvmconf           Do not include local /etc/lvm/lvm.conf\n  --fscks [LIST]        Add a space-separated list of fsck helpers.\n  --nofscks             Inhibit installation of any fsck helpers.\n  --ro-mnt              Mount / and /usr read-only by default.\n  -h, --help            This message\n  --debug               Output debug information of the build process\n  --profile             Output profile information of the build process\n  -L, --stdlog [0-6]    Specify logging level (to standard error)\n                         0 - suppress any messages\n                         1 - only fatal errors\n                         2 - all errors\n                         3 - warnings\n                         4 - info\n                         5 - debug info (here starts lots of output)\n                         6 - trace info (and even more)\n  -v, --verbose         Increase verbosity level\n  -q, --quiet           Decrease verbosity level\n  -c, --conf [FILE]     Specify configuration file to use.\n                         Default: /etc/dracut.conf\n  --confdir [DIR]       Specify configuration directory to use *.conf files\n                         from. Default: /etc/dracut.conf.d\n  --tmpdir [DIR]        Temporary directory to be used instead of default\n                         /var/tmp.\n  -r, --sysroot [DIR]   Specify sysroot directory to collect files from.\n  -l, --local           Local mode. Use modules from the current working\n                         directory instead of the system-wide installed in\n                         /usr/lib/dracut/modules.d.\n                         Useful when running dracut from a git checkout.\n  -H, --hostonly        Host-Only mode: Install only what is needed for\n                        booting the local host instead of a generic host.\n  -N, --no-hostonly     Disables Host-Only mode\n  --hostonly-mode <mode>\n                        Specify the hostonly mode to use. <mode> could be\n                        one of \"sloppy\" or \"strict\". \"sloppy\" mode is used\n                        by default.\n                        In \"sloppy\" hostonly mode, extra drivers and modules\n                        will be installed, so minor hardware change won't make\n                        the image unbootable (eg. changed keyboard), and the\n                        image is still portable among similar hosts.\n                        With \"strict\" mode enabled, anything not necessary\n                        for booting the local host in its current state will\n                        not be included, and modules may do some extra job\n                        to save more space. Minor change of hardware or\n                        environment could make the image unbootable.\n                        DO NOT use \"strict\" mode unless you know what you\n                        are doing.\n  --hostonly-cmdline    Store kernel command line arguments needed\n                        in the initramfs\n  --no-hostonly-cmdline Do not store kernel command line arguments needed\n                        in the initramfs\n  --no-hostonly-default-device\n                        Do not generate implicit host devices like root,\n                        swap, fstab, etc. Use \"--mount\" or \"--add-device\"\n                        to explicitly add devices as needed.\n  --hostonly-i18n       Install only needed keyboard and font files according\n                        to the host configuration (default).\n  --no-hostonly-i18n    Install all keyboard and font files available.\n  --persistent-policy [POLICY]\n                        Use [POLICY] to address disks and partitions.\n                        POLICY can be any directory name found in /dev/disk.\n                        E.g. \"by-uuid\", \"by-label\"\n  --fstab               Use /etc/fstab to determine the root device.\n  --add-fstab [FILE]    Add file to the initramfs fstab\n  --mount \"[DEV] [MP] [FSTYPE] [FSOPTS]\"\n                        Mount device [DEV] on mountpoint [MP] with filesystem\n                        [FSTYPE] and options [FSOPTS] in the initramfs\n  --mount \"[MP]\"        Same as above, but [DEV], [FSTYPE] and [FSOPTS] are\n                        determined by looking at the current mounts.\n  --add-device \"[DEV]\"  Bring up [DEV] in initramfs\n  -i, --include [SOURCE] [TARGET]\n                        Include the files in the SOURCE directory into the\n                         Target directory in the final initramfs.\n                        If SOURCE is a file, it will be installed to TARGET\n                         in the final initramfs.\n  -I, --install [LIST]  Install the space separated list of files into the\n                         initramfs.\n  --install-optional [LIST]  Install the space separated list of files into the\n                         initramfs, if they exist.\n  --gzip                Compress the generated initramfs using gzip.\n                         This will be done by default, unless another\n                         compression option or --no-compress is passed.\n  --bzip2               Compress the generated initramfs using bzip2.\n                         Make sure your kernel has bzip2 decompression support\n                         compiled in, otherwise you will not be able to boot.\n  --lzma                Compress the generated initramfs using lzma.\n                         Make sure your kernel has lzma support compiled in,\n                         otherwise you will not be able to boot.\n  --xz                  Compress the generated initramfs using xz.\n                         Make sure that your kernel has xz support compiled\n                         in, otherwise you will not be able to boot.\n  --lzo                 Compress the generated initramfs using lzop.\n                         Make sure that your kernel has lzo support compiled\n                         in, otherwise you will not be able to boot.\n  --lz4                 Compress the generated initramfs using lz4.\n                         Make sure that your kernel has lz4 support compiled\n                         in, otherwise you will not be able to boot.\n  --zstd                Compress the generated initramfs using Zstandard.\n                         Make sure that your kernel has zstd support compiled\n                         in, otherwise you will not be able to boot.\n  --compress [COMPRESSION] Compress the generated initramfs with the\n                         passed compression program.  Make sure your kernel\n                         knows how to decompress the generated initramfs,\n                         otherwise you will not be able to boot.\n  --no-compress         Do not compress the generated initramfs.  This will\n                         override any other compression options.\n  --list-modules        List all available dracut modules.\n  -M, --show-modules    Print included module's name to standard output during\n                         build.\n  --keep                Keep the temporary initramfs for debugging purposes\n  --printsize           Print out the module install size\n  --sshkey [SSHKEY]     Add ssh key to initramfs (use with ssh-client module)\n  --logfile [FILE]      Logfile to use (overrides configuration setting)\n  --reproducible        Create reproducible images\n  --no-reproducible     Do not create reproducible images\n  --loginstall [DIR]    Log all files installed from the host to [DIR]\n  --uefi                Create an UEFI executable with the kernel cmdline and\n                        kernel combined\n  --uefi-stub [FILE]    Use the UEFI stub [FILE] to create an UEFI executable\n  --uefi-splash-image [FILE]\n                        Use [FILE] as a splash image when creating an UEFI\n                        executable\n  --kernel-image [FILE] location of the kernel image\n  --regenerate-all      Regenerate all initramfs images at the default location\n                        for the kernel versions found on the system\n\nIf [LIST] has multiple arguments, then you have to put these in quotes.\n\nFor example:\n\n    # dracut --add-drivers \"module1 module2\"  ...\n\nEOF\n}\n\n# Fills up host_devs stack variable and makes sure there are no duplicates\npush_host_devs() {\n    local _dev\n    for _dev in \"$@\"; do\n        [[ \" ${host_devs[@]} \" == *\" $_dev \"* ]] && return\n        host_devs+=( \"$_dev\" )\n    done\n}\n\n# Little helper function for reading args from the commandline.\n# it automatically handles -a b and -a=b variants, and returns 1 if\n# we need to shift $3.\nread_arg() {\n    # $1 = arg name\n    # $2 = arg value\n    # $3 = arg parameter\n    local rematch='^[^=]*=(.*)$'\n    if [[ $2 =~ $rematch ]]; then\n        read \"$1\" <<< \"${BASH_REMATCH[1]}\"\n    else\n        read \"$1\" <<< \"$3\"\n        # There is no way to shift our callers args, so\n        # return 1 to indicate they should do it instead.\n        return 1\n    fi\n}\n\ndropindirs_sort()\n{\n    local suffix=$1; shift\n    local -a files\n    local f d\n\n    for d in \"$@\"; do\n        for i in \"$d/\"*\"$suffix\"; do\n            if [[ -e \"$i\" ]]; then\n                printf \"%s\\n\" \"${i##*/}\"\n            fi\n        done\n    done | sort -Vu | {\n        readarray -t files\n\n        for f in \"${files[@]}\"; do\n            for d in \"$@\"; do\n                if [[ -e \"$d/$f\" ]]; then\n                    printf \"%s\\n\" \"$d/$f\"\n                    continue 2\n                fi\n            done\n        done\n    }\n}\n\nrearrange_params()\n{\n    # Workaround -i, --include taking 2 arguments\n    newat=()\n    for i in \"$@\"; do\n      if [[ $i == \"-i\" ]] || [[ $i == \"--include\" ]]; then\n            newat+=(\"++include\") # Replace --include by ++include\n        else\n            newat+=(\"$i\")\n        fi\n    done\n    set -- \"${newat[@]}\" # Set new $@\n\n    TEMP=$(unset POSIXLY_CORRECT; getopt \\\n        -o \"a:m:o:d:I:k:c:r:L:fvqlHhMN\" \\\n        --long kver: \\\n        --long add: \\\n        --long force-add: \\\n        --long add-drivers: \\\n        --long force-drivers: \\\n        --long omit-drivers: \\\n        --long modules: \\\n        --long omit: \\\n        --long drivers: \\\n        --long filesystems: \\\n        --long install: \\\n        --long install-optional: \\\n        --long fwdir: \\\n        --long libdirs: \\\n        --long fscks: \\\n        --long add-fstab: \\\n        --long mount: \\\n        --long device: \\\n        --long add-device: \\\n        --long nofscks \\\n        --long ro-mnt \\\n        --long kmoddir: \\\n        --long conf: \\\n        --long confdir: \\\n        --long tmpdir: \\\n        --long sysroot: \\\n        --long stdlog: \\\n        --long compress: \\\n        --long prefix: \\\n        --long rebuild: \\\n        --long force \\\n        --long kernel-only \\\n        --long no-kernel \\\n        --long print-cmdline \\\n        --long kernel-cmdline: \\\n        --long strip \\\n        --long nostrip \\\n        --long hardlink \\\n        --long nohardlink \\\n        --long noprefix \\\n        --long mdadmconf \\\n        --long nomdadmconf \\\n        --long lvmconf \\\n        --long nolvmconf \\\n        --long debug \\\n        --long profile \\\n        --long sshkey: \\\n        --long logfile: \\\n        --long verbose \\\n        --long quiet \\\n        --long local \\\n        --long hostonly \\\n        --long host-only \\\n        --long no-hostonly \\\n        --long no-host-only \\\n        --long hostonly-mode: \\\n        --long hostonly-cmdline \\\n        --long no-hostonly-cmdline \\\n        --long no-hostonly-default-device \\\n        --long persistent-policy: \\\n        --long fstab \\\n        --long help \\\n        --long bzip2 \\\n        --long lzma \\\n        --long xz \\\n        --long lzo \\\n        --long lz4 \\\n        --long zstd \\\n        --long no-compress \\\n        --long gzip \\\n        --long list-modules \\\n        --long show-modules \\\n        --long keep \\\n        --long printsize \\\n        --long regenerate-all \\\n        --long noimageifnotneeded \\\n        --long early-microcode \\\n        --long no-early-microcode \\\n        --long reproducible \\\n        --long no-reproducible \\\n        --long loginstall: \\\n        --long uefi \\\n        --long uefi-stub: \\\n        --long uefi-splash-image: \\\n        --long kernel-image: \\\n        --long no-hostonly-i18n \\\n        --long hostonly-i18n \\\n        --long no-machineid \\\n        -- \"$@\")\n\n    if (( $? != 0 )); then\n        usage\n        exit 1\n    fi\n}\n\nverbosity_mod_l=0\nunset kernel\nunset outfile\n\nrearrange_params \"$@\"\neval set -- \"$TEMP\"\n\n# parse command line args to check if '--rebuild' option is present\nunset append_args_l\nunset rebuild_file\nwhile :\ndo\n\tif [ \"$1\" == \"--\" ]; then\n\t    shift; break\n\tfi\n\tif [ \"$1\" == \"--rebuild\" ]; then\n\t    append_args_l=\"yes\"\n            rebuild_file=$2\n            if [ ! -e $rebuild_file ]; then\n                echo \"Image file '$rebuild_file', for rebuild, does not exist!\"\n                exit 1\n            fi\n            abs_rebuild_file=$(readlink -f \"$rebuild_file\") && rebuild_file=\"$abs_rebuild_file\"\n\t    shift; continue\n\tfi\n\tshift\ndone\n\n# get output file name and kernel version from command line arguments\nwhile (($# > 0)); do\n    case ${1%%=*} in\n        ++include)\n            shift 2;;\n        *)\n            if ! [[ ${outfile+x} ]]; then\n                outfile=$1\n            elif ! [[ ${kernel+x} ]]; then\n                kernel=$1\n            else\n                printf \"\\nUnknown arguments: %s\\n\\n\" \"$*\" >&2\n                usage; exit 1;\n            fi\n            ;;\n    esac\n    shift\ndone\n\n# extract input image file provided with rebuild option to get previous parameters, if any\nif [[ $append_args_l == \"yes\" ]]; then\n    unset rebuild_param\n\n    # determine resultant file\n    if ! [[ $outfile ]]; then\n        outfile=$rebuild_file\n    fi\n\n    if ! rebuild_param=$(lsinitrd $rebuild_file '*lib/dracut/build-parameter.txt'); then\n        echo \"Image '$rebuild_file' has no rebuild information stored\"\n        exit 1\n    fi\n\n    # prepend previous parameters to current command line args\n    if [[ $rebuild_param ]]; then\n        TEMP=\"$rebuild_param $TEMP\"\n        eval set -- \"$TEMP\"\n        rearrange_params \"$@\"\n    fi\nfi\n\nunset PARMS_TO_STORE\nPARMS_TO_STORE=\"\"\n\neval set -- \"$TEMP\"\n\nwhile :; do\n    if [ $1 != \"--\" ] && [ $1 != \"--rebuild\" ]; then\n        PARMS_TO_STORE+=\" $1\";\n    fi\n    case $1 in\n        --kver)        kernel=\"$2\";                           PARMS_TO_STORE+=\" '$2'\"; shift;;\n        -a|--add)      add_dracutmodules_l+=(\"$2\");           PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --force-add)   force_add_dracutmodules_l+=(\"$2\");     PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --add-drivers) add_drivers_l+=(\"$2\");                 PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --force-drivers) force_drivers_l+=(\"$2\");             PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --omit-drivers) omit_drivers_l+=(\"$2\");               PARMS_TO_STORE+=\" '$2'\"; shift;;\n        -m|--modules)  dracutmodules_l+=(\"$2\");               PARMS_TO_STORE+=\" '$2'\"; shift;;\n        -o|--omit)     omit_dracutmodules_l+=(\"$2\");          PARMS_TO_STORE+=\" '$2'\"; shift;;\n        -d|--drivers)  drivers_l+=(\"$2\");                     PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --filesystems) filesystems_l+=(\"$2\");                 PARMS_TO_STORE+=\" '$2'\"; shift;;\n        -I|--install)  install_items_l+=(\"$2\");               PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --install-optional) install_optional_items_l+=(\"$2\"); PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --fwdir)       fw_dir_l+=(\"$2\");                      PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --libdirs)     libdirs_l+=(\"$2\");                     PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --fscks)       fscks_l+=(\"$2\");                       PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --add-fstab)   add_fstab_l+=(\"$2\");                   PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --mount)       fstab_lines+=(\"$2\");                   PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --add-device|--device) add_device_l+=(\"$2\");          PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --kernel-cmdline) kernel_cmdline_l+=(\"$2\");           PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --nofscks)     nofscks_l=\"yes\";;\n        --ro-mnt)      ro_mnt_l=\"yes\";;\n        -k|--kmoddir)  drivers_dir_l=\"$2\";             PARMS_TO_STORE+=\" '$2'\"; shift;;\n        -c|--conf)     conffile=\"$2\";                  PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --confdir)     confdir=\"$2\";                   PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --tmpdir)      tmpdir_l=\"$2\";                  PARMS_TO_STORE+=\" '$2'\"; shift;;\n        -r|--sysroot)  sysroot_l=\"$2\";                 PARMS_TO_STORE+=\" '$2'\"; shift;;\n        -L|--stdlog)   stdloglvl_l=\"$2\";               PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --compress)    compress_l=\"$2\";                PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --prefix)      prefix_l=\"$2\";                  PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --loginstall)  loginstall_l=\"$2\";              PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --rebuild)     if [ $rebuild_file == $outfile ]; then\n                           force=yes\n                       fi\n                       shift\n                       ;;\n        -f|--force)    force=yes;;\n        --kernel-only) kernel_only=\"yes\"; no_kernel=\"no\";;\n        --no-kernel)   kernel_only=\"no\"; no_kernel=\"yes\";;\n        --print-cmdline)\n                       print_cmdline=\"yes\"; hostonly_l=\"yes\"; kernel_only=\"yes\"; no_kernel=\"yes\";;\n        --early-microcode)\n                       early_microcode_l=\"yes\";;\n        --no-early-microcode)\n                       early_microcode_l=\"no\";;\n        --strip)       do_strip_l=\"yes\";;\n        --nostrip)     do_strip_l=\"no\";;\n        --hardlink)    do_hardlink_l=\"yes\";;\n        --nohardlink)  do_hardlink_l=\"no\";;\n        --noprefix)    prefix_l=\"/\";;\n        --mdadmconf)   mdadmconf_l=\"yes\";;\n        --nomdadmconf) mdadmconf_l=\"no\";;\n        --lvmconf)     lvmconf_l=\"yes\";;\n        --nolvmconf)   lvmconf_l=\"no\";;\n        --debug)       debug=\"yes\";;\n        --profile)     profile=\"yes\";;\n        --sshkey)      sshkey=\"$2\";                    PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --logfile)     logfile_l=\"$2\"; shift;;\n        -v|--verbose)  ((verbosity_mod_l++));;\n        -q|--quiet)    ((verbosity_mod_l--));;\n        -l|--local)\n                       allowlocal=\"yes\"\n                       [[ -f \"$(readlink -f \"${0%/*}\")/dracut-init.sh\" ]] \\\n                           && dracutbasedir=\"$(readlink -f \"${0%/*}\")\"\n                       ;;\n        -H|--hostonly|--host-only)\n                       hostonly_l=\"yes\" ;;\n        -N|--no-hostonly|--no-host-only)\n                       hostonly_l=\"no\" ;;\n        --hostonly-mode)\n                       hostonly_mode_l=\"$2\";           PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --hostonly-cmdline)\n                       hostonly_cmdline_l=\"yes\" ;;\n        --hostonly-i18n)\n                       i18n_install_all_l=\"no\" ;;\n        --no-hostonly-i18n)\n                       i18n_install_all_l=\"yes\" ;;\n        --no-hostonly-cmdline)\n                       hostonly_cmdline_l=\"no\" ;;\n        --no-hostonly-default-device)\n                       hostonly_default_device=\"no\" ;;\n        --persistent-policy)\n                       persistent_policy_l=\"$2\";       PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --fstab)       use_fstab_l=\"yes\" ;;\n        -h|--help)     long_usage; exit 1 ;;\n        -i|--include)  include_src+=(\"$2\");          PARMS_TO_STORE+=\" '$2'\";\n                       shift;;\n        --bzip2)       compress_l=\"bzip2\";;\n        --lzma)        compress_l=\"lzma\";;\n        --xz)          compress_l=\"xz\";;\n        --lzo)         compress_l=\"lzo\";;\n        --lz4)         compress_l=\"lz4\";;\n        --zstd)        compress_l=\"zstd\";;\n        --no-compress) _no_compress_l=\"cat\";;\n        --gzip)        compress_l=\"gzip\";;\n        --list-modules) do_list=\"yes\";;\n        -M|--show-modules)\n                       show_modules_l=\"yes\"\n                       ;;\n        --keep)        keep=\"yes\";;\n        --printsize)   printsize=\"yes\";;\n        --regenerate-all) regenerate_all=\"yes\";;\n        --noimageifnotneeded) noimageifnotneeded=\"yes\";;\n        --reproducible) reproducible_l=\"yes\";;\n        --no-reproducible) reproducible_l=\"no\";;\n        --uefi)        uefi=\"yes\";;\n        --uefi-stub)\n                       uefi_stub_l=\"$2\";               PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --uefi-splash-image)\n                       uefi_splash_image_l=\"$2\";       PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --kernel-image)\n                       kernel_image_l=\"$2\";            PARMS_TO_STORE+=\" '$2'\"; shift;;\n        --no-machineid)\n                       machine_id_l=\"no\";;\n        --) shift; break;;\n\n        *)  # should not even reach this point\n            printf \"\\n!Unknown option: '%s'\\n\\n\" \"$1\" >&2; usage; exit 1;;\n    esac\n    shift\ndone\n\n# getopt cannot handle multiple arguments, so just handle \"-I,--include\"\n# the old fashioned way\n\nwhile (($# > 0)); do\n    if [ \"${1%%=*}\" == \"++include\" ]; then\n        include_src+=(\"$2\")\n        include_target+=(\"$3\")\n        PARMS_TO_STORE+=\" --include '$2' '$3'\"\n        shift 2\n    fi\n    shift\ndone\n\n[[ $sysroot_l ]] && dracutsysrootdir=\"$sysroot_l\"\n\nif [[ $regenerate_all == \"yes\" ]]; then\n    ret=0\n    if [[ $kernel ]]; then\n        printf -- \"--regenerate-all cannot be called with a kernel version\\n\" >&2\n        exit 1\n    fi\n\n    if [[ $outfile ]]; then\n        printf -- \"--regenerate-all cannot be called with a image file\\n\" >&2\n        exit 1\n    fi\n\n    ((len=${#dracut_args[@]}))\n    for ((i=0; i < len; i++)); do\n        [[ ${dracut_args[$i]} == \"--regenerate-all\" ]] && \\\n            unset dracut_args[$i]\n    done\n\n    cd $dracutsysrootdir/lib/modules\n    for i in *; do\n        [[ -f $i/modules.dep ]] || [[ -f $i/modules.dep.bin ]] || continue\n        \"$dracut_cmd\" --kver=\"$i\" \"${dracut_args[@]}\"\n        ((ret+=$?))\n    done\n    exit $ret\nfi\n\nif ! [[ $kernel ]]; then\n    kernel=$(uname -r)\nfi\n\nexport LC_ALL=C\nexport LANG=C\nunset LC_MESSAGES\nunset LC_CTYPE\nunset LD_LIBRARY_PATH\nunset LD_PRELOAD\nunset GREP_OPTIONS\n\nexport DRACUT_LOG_LEVEL=warning\n[[ $debug ]] && {\n    export DRACUT_LOG_LEVEL=debug\n    export PS4='${BASH_SOURCE}@${LINENO}(${FUNCNAME[0]}): ';\n    set -x\n}\n\n[[ $profile ]] && {\n    export PS4='+ $(date \"+%s.%N\") ${BASH_SOURCE}@${LINENO}: ';\n    set -x\n    debug=yes\n}\n\n[[ $dracutbasedir ]] || dracutbasedir=$dracutsysrootdir/usr/lib/dracut\n\n# if we were not passed a config file, try the default one\nif [[ ! -f $conffile ]]; then\n    if [[ $allowlocal ]]; then\n        conffile=\"$dracutbasedir/dracut.conf\"\n    else\n        conffile=\"$dracutsysrootdir/etc/dracut.conf\"\n    fi\nfi\n\nif [[ ! -d $confdir ]]; then\n    if [[ $allowlocal ]]; then\n        confdir=\"$dracutbasedir/dracut.conf.d\"\n    else\n        confdir=\"$dracutsysrootdir/etc/dracut.conf.d\"\n    fi\nfi\n\n# source our config file\n[[ -f $conffile ]] && . \"$conffile\"\n\n# source our config dir\nfor f in $(dropindirs_sort \".conf\" \"$confdir\" \"$dracutbasedir/dracut.conf.d\"); do\n    [[ -e $f ]] && . \"$f\"\ndone\n\nDRACUT_PATH=${DRACUT_PATH:-/sbin /bin /usr/sbin /usr/bin}\n\nfor i in $DRACUT_PATH; do\n    rl=$i\n    if [ -L \"$dracutsysrootdir$i\" ]; then\n        rl=$(readlink -f $dracutsysrootdir$i)\n    fi\n    if [[ \"$NPATH\" != *:$rl* ]] ; then\n        NPATH+=\":$rl\"\n    fi\ndone\nexport PATH=\"${NPATH#:}\"\nunset NPATH\n\n# these options add to the stuff in the config file\n(( ${#add_dracutmodules_l[@]} )) && add_dracutmodules+=\" ${add_dracutmodules_l[@]} \"\n(( ${#force_add_dracutmodules_l[@]} )) && force_add_dracutmodules+=\" ${force_add_dracutmodules_l[@]} \"\n(( ${#fscks_l[@]} )) && fscks+=\" ${fscks_l[@]} \"\n(( ${#add_fstab_l[@]} )) && add_fstab+=\" ${add_fstab_l[@]} \"\n(( ${#fstab_lines_l[@]} )) && fstab_lines+=( \"${fstab_lines_l[@]}\" )\n(( ${#install_items_l[@]} )) && install_items+=\" ${install_items_l[@]} \"\n(( ${#install_optional_items_l[@]} )) && install_optional_items+=\" ${install_optional_items_l[@]} \"\n\n# these options override the stuff in the config file\n(( ${#dracutmodules_l[@]} )) && dracutmodules=\"${dracutmodules_l[@]}\"\n(( ${#omit_dracutmodules_l[@]} )) && omit_dracutmodules=\"${omit_dracutmodules_l[@]}\"\n(( ${#filesystems_l[@]} )) && filesystems=\"${filesystems_l[@]}\"\n(( ${#fw_dir_l[@]} )) && fw_dir=\"${fw_dir_l[@]}\"\n(( ${#libdirs_l[@]} ))&& libdirs=\"${libdirs_l[@]}\"\n\n[[ $stdloglvl_l ]] && stdloglvl=$stdloglvl_l\n[[ ! $stdloglvl ]] && stdloglvl=4\nstdloglvl=$((stdloglvl + verbosity_mod_l))\n((stdloglvl > 6)) && stdloglvl=6\n((stdloglvl < 0)) && stdloglvl=0\n\n[[ $drivers_dir_l ]] && drivers_dir=$drivers_dir_l\n[[ $do_strip_l ]] && do_strip=$do_strip_l\n[[ $do_strip ]] || do_strip=yes\n[[ $do_hardlink_l ]] && do_hardlink=$do_hardlink_l\n[[ $do_hardlink ]] || do_hardlink=yes\n[[ $prefix_l ]] && prefix=$prefix_l\n[[ $prefix = \"/\" ]] && unset prefix\n[[ $hostonly_l ]] && hostonly=$hostonly_l\n[[ $hostonly_cmdline_l ]] && hostonly_cmdline=$hostonly_cmdline_l\n[[ $hostonly_mode_l ]] && hostonly_mode=$hostonly_mode_l\n[[ \"$hostonly\" == \"yes\" ]] && ! [[ $hostonly_cmdline ]] && hostonly_cmdline=\"yes\"\n[[ $i18n_install_all_l ]] && i18n_install_all=$i18n_install_all_l\n[[ $persistent_policy_l ]] && persistent_policy=$persistent_policy_l\n[[ $use_fstab_l ]] && use_fstab=$use_fstab_l\n[[ $mdadmconf_l ]] && mdadmconf=$mdadmconf_l\n[[ $lvmconf_l ]] && lvmconf=$lvmconf_l\n[[ $dracutbasedir ]] || dracutbasedir=$dracutsysrootdir/usr/lib/dracut\n[[ $fw_dir ]] || fw_dir=\"$dracutsysrootdir/lib/firmware/updates:$dracutsysrootdir/lib/firmware:$dracutsysrootdir/lib/firmware/$kernel\"\n[[ $tmpdir_l ]] && tmpdir=\"$tmpdir_l\"\n[[ $tmpdir ]] || tmpdir=$dracutsysrootdir/var/tmp\n[[ $INITRD_COMPRESS ]] && compress=$INITRD_COMPRESS\n[[ $compress_l ]] && compress=$compress_l\n[[ $show_modules_l ]] && show_modules=$show_modules_l\n[[ $nofscks_l ]] && nofscks=\"yes\"\n[[ $ro_mnt_l ]] && ro_mnt=\"yes\"\n[[ $early_microcode_l ]] && early_microcode=$early_microcode_l\n[[ $early_microcode ]] || early_microcode=yes\n[[ $early_microcode_image_dir ]] || early_microcode_image_dir=('/boot')\n[[ $early_microcode_image_name ]] || \\\n    early_microcode_image_name=('intel-uc.img' 'intel-ucode.img' 'amd-uc.img' 'amd-ucode.img' 'early_ucode.cpio' 'microcode.cpio')\n[[ $logfile_l ]] && logfile=\"$logfile_l\"\n[[ $reproducible_l ]] && reproducible=\"$reproducible_l\"\n[[ $loginstall_l ]] && loginstall=\"$loginstall_l\"\n[[ $uefi_stub_l ]] && uefi_stub=\"$uefi_stub_l\"\n[[ $uefi_splash_image_l ]] && uefi_splash_image=\"$uefi_splash_image_l\"\n[[ $kernel_image_l ]] && kernel_image=\"$kernel_image_l\"\n[[ $machine_id_l ]] && machine_id=\"$machine_id_l\"\n\nif ! [[ $outfile ]]; then\n    if [[ $machine_id != \"no\" ]]; then\n        [[ -f $dracutsysrootdir/etc/machine-id ]] && read MACHINE_ID < $dracutsysrootdir/etc/machine-id\n    fi\n\n    if [[ $uefi == \"yes\" ]]; then\n        if [[ -n \"$uefi_secureboot_key\" && -z \"$uefi_secureboot_cert\" ]] || [[ -z $uefi_secureboot_key && -n $uefi_secureboot_cert ]]; then\n            dfatal \"Need 'uefi_secureboot_key' and 'uefi_secureboot_cert' both to be set.\"\n            exit 1\n        fi\n\n        if [[ -n \"$uefi_secureboot_key\" && -n \"$uefi_secureboot_cert\" ]] && !command -v sbsign &>/dev/null; then\n            dfatal \"Need 'sbsign' to create a signed UEFI executable\"\n            exit 1\n        fi\n\n        BUILD_ID=$(cat $dracutsysrootdir/etc/os-release $dracutsysrootdir/usr/lib/os-release \\\n                       | while read -r line || [[ $line ]]; do \\\n                       [[ $line =~ BUILD_ID\\=* ]] && eval \"$line\" && echo \"$BUILD_ID\" && break; \\\n                   done)\n        if [[ -z $dracutsysrootdir ]]; then\n            if [[ -d /efi ]] && mountpoint -q /efi; then\n                efidir=/efi/EFI\n            else\n                efidir=/boot/EFI\n                if [[ -d $dracutsysrootdir/boot/efi/EFI ]]; then\n                    efidir=/boot/efi/EFI\n                fi\n            fi\n        else\n            efidir=/boot/EFI\n            if [[ -d $dracutsysrootdir/boot/efi/EFI ]]; then\n                efidir=/boot/efi/EFI\n            fi\n        fi\n        mkdir -p \"$dracutsysrootdir$efidir/Linux\"\n        outfile=\"$dracutsysrootdir$efidir/Linux/linux-$kernel${MACHINE_ID:+-${MACHINE_ID}}${BUILD_ID:+-${BUILD_ID}}.efi\"\n    else\n        if [[ -e \"$dracutsysrootdir/boot/vmlinuz-$kernel\" ]]; then\n            outfile=\"/boot/initramfs-$kernel.img\"\n        elif [[ $MACHINE_ID ]] && ( [[ -d $dracutsysrootdir/boot/${MACHINE_ID} ]] || [[ -L $dracutsysrootdir/boot/${MACHINE_ID} ]] ); then\n            outfile=\"$dracutsysrootdir/boot/${MACHINE_ID}/$kernel/initrd\"\n        else\n            outfile=\"$dracutsysrootdir/boot/initramfs-$kernel.img\"\n        fi\n    fi\nfi\n\n# eliminate IFS hackery when messing with fw_dir\nexport DRACUT_FIRMWARE_PATH=${fw_dir// /:}\nfw_dir=${fw_dir//:/ }\n\n# check for logfile and try to create one if it doesn't exist\nif [[ -n \"$logfile\" ]];then\n    if [[ ! -f \"$logfile\" ]];then\n        touch \"$logfile\"\n        if [ ! $? -eq 0 ] ;then\n            printf \"%s\\n\" \"dracut: touch $logfile failed.\" >&2\n        fi\n    fi\nfi\n\n# handle compression options.\nDRACUT_COMPRESS_BZIP2=${DRACUT_COMPRESS_BZIP2:-bzip2}\nDRACUT_COMPRESS_LBZIP2=${DRACUT_COMPRESS_LBZIP2:-lbzip2}\nDRACUT_COMPRESS_LZMA=${DRACUT_COMPRESS_LZMA:-lzma}\nDRACUT_COMPRESS_XZ=${DRACUT_COMPRESS_XZ:-xz}\nDRACUT_COMPRESS_GZIP=${DRACUT_COMPRESS_GZIP:-gzip}\nDRACUT_COMPRESS_PIGZ=${DRACUT_COMPRESS_PIGZ:-pigz}\nDRACUT_COMPRESS_LZOP=${DRACUT_COMPRESS_LZOP:-lzop}\nDRACUT_COMPRESS_ZSTD=${DRACUT_COMPRESS_ZSTD:-zstd}\nDRACUT_COMPRESS_LZ4=${DRACUT_COMPRESS_LZ4:-lz4}\nDRACUT_COMPRESS_CAT=${DRACUT_COMPRESS_CAT:-cat}\n\nif [[ $_no_compress_l = \"$DRACUT_COMPRESS_CAT\" ]]; then\n    compress=\"$DRACUT_COMPRESS_CAT\"\nfi\n\nif ! [[ $compress ]]; then\n    # check all known compressors, if none specified\n    for i in $DRACUT_COMPRESS_PIGZ $DRACUT_COMPRESS_GZIP $DRACUT_COMPRESS_LZ4 $DRACUT_COMPRESS_LZOP $ $DRACUT_COMPRESS_ZSTD $DRACUT_COMPRESS_LZMA $DRACUT_COMPRESS_XZ $DRACUT_COMPRESS_LBZIP2 $OMPRESS_BZIP2 $DRACUT_COMPRESS_CAT; do\n        command -v \"$i\" &>/dev/null || continue\n        compress=\"$i\"\n        break\n    done\n    if [[ $compress = cat ]]; then\n            printf \"%s\\n\" \"dracut: no compression tool available. Initramfs image is going to be big.\" >&2\n    fi\nfi\n\n# choose the right arguments for the compressor\ncase $compress in\n    bzip2|lbzip2)\n        if [[ \"$compress\" =  lbzip2 ]] || command -v $DRACUT_COMPRESS_LBZIP2 &>/dev/null; then\n            compress=\"$DRACUT_COMPRESS_LBZIP2 -9\"\n        else\n            compress=\"$DRACUT_COMPRESS_BZIP2 -9\"\n        fi\n        ;;\n    lzma)\n        compress=\"$DRACUT_COMPRESS_LZMA -9 -T0\"\n        ;;\n    xz)\n        compress=\"$DRACUT_COMPRESS_XZ --check=crc32 --lzma2=dict=1MiB -T0\"\n        ;;\n    gzip|pigz)\n        if [[ \"$compress\" = pigz ]] || command -v $DRACUT_COMPRESS_PIGZ &>/dev/null; then\n            compress=\"$DRACUT_COMPRESS_PIGZ -9 -n -T -R\"\n        elif command -v gzip &>/dev/null && $DRACUT_COMPRESS_GZIP --help 2>&1 | grep -q rsyncable; then\n            compress=\"$DRACUT_COMPRESS_GZIP -n -9 --rsyncable\"\n        else\n            compress=\"$DRACUT_COMPRESS_GZIP -n -9\"\n        fi\n        ;;\n    lzo|lzop)\n        compress=\"$DRACUT_COMPRESS_LZOP -9\"\n        ;;\n    lz4)\n        compress=\"$DRACUT_COMPRESS_LZ4 -l -9\"\n        ;;\n    zstd)\n       compress=\"$DRACUT_COMPRESS_ZSTD -15 -q -T0\"\n       ;;\nesac\n\n[[ $hostonly = yes ]] && hostonly=\"-h\"\n[[ $hostonly != \"-h\" ]] && unset hostonly\n\ncase $hostonly_mode in\n    '')\n        [[ $hostonly ]] && hostonly_mode=\"sloppy\" ;;\n    sloppy|strict)\n        if [[ ! $hostonly ]]; then\n            unset hostonly_mode\n        fi\n        ;;\n    *)\n        printf \"%s\\n\" \"dracut: Invalid hostonly mode '$hostonly_mode'.\" >&2\n        exit 1\nesac\n\n[[ $reproducible == yes ]] && DRACUT_REPRODUCIBLE=1\n\ncase \"${drivers_dir}\" in\n    ''|*lib/modules/${kernel}|*lib/modules/${kernel}/) ;;\n    *)\n        [[ \"$DRACUT_KMODDIR_OVERRIDE\" ]] || {\n\t    printf \"%s\\n\" \"dracut: -k/--kmoddir path must contain \\\"lib/modules\\\" as a parent of your kernel module directory,\"\n\t    printf \"%s\\n\" \"dracut: or modules may not be placed in the correct location inside the initramfs.\"\n\t    printf \"%s\\n\" \"dracut: was given: ${drivers_dir}\"\n\t    printf \"%s\\n\" \"dracut: expected: $(dirname ${drivers_dir})/lib/modules/${kernel}\"\n\t    printf \"%s\\n\" \"dracut: Please move your modules into the correct directory structure and pass the new location,\"\n\t    printf \"%s\\n\" \"dracut: or set DRACUT_KMODDIR_OVERRIDE=1 to ignore this check.\"\n\t    exit 1\n\t}\n\t;;\nesac\n\nreadonly TMPDIR=\"$(realpath -e \"$tmpdir\")\"\n[ -d \"$TMPDIR\" ] || {\n    printf \"%s\\n\" \"dracut: Invalid tmpdir '$tmpdir'.\" >&2\n    exit 1\n}\n\nif findmnt --raw -n --target \"$tmpdir\" --output=options | grep -q noexec; then\n    [[ $debug == yes ]] && printf \"%s\\n\" \"dracut: Tmpdir '$tmpdir' is mounted with 'noexec'.\"\n    noexec=1\nfi\n\nreadonly DRACUT_TMPDIR=\"$(mktemp -p \"$TMPDIR/\" -d -t dracut.XXXXXX)\"\n[ -d \"$DRACUT_TMPDIR\" ] || {\n    printf \"%s\\n\" \"dracut: mktemp -p '$TMPDIR/' -d -t dracut.XXXXXX failed.\" >&2\n    exit 1\n}\n\n# clean up after ourselves no matter how we die.\ntrap '\n    ret=$?;\n    [[ $keep ]] && echo \"Not removing $DRACUT_TMPDIR.\" >&2 || { [[ $DRACUT_TMPDIR ]] && rm -rf -- \"$DRACUT_TMPDIR\"; };\n    exit $ret;\n    ' EXIT\n\n# clean up after ourselves no matter how we die.\ntrap 'exit 1;' SIGINT\n\nreadonly initdir=\"${DRACUT_TMPDIR}/initramfs\"\nmkdir \"$initdir\"\n\nif [[ $early_microcode = yes ]] || ( [[ $acpi_override = yes ]] && [[ -d $acpi_table_dir ]] ); then\n    readonly early_cpio_dir=\"${DRACUT_TMPDIR}/earlycpio\"\n    mkdir \"$early_cpio_dir\"\nfi\n\n[[ -n \"$dracutsysrootdir\" || \"$noexec\" ]] || export DRACUT_RESOLVE_LAZY=\"1\"\n\nif [[ $print_cmdline ]]; then\n    stdloglvl=0\n    sysloglvl=0\n    fileloglvl=0\n    kmsgloglvl=0\nfi\n\nif [[ -f $dracutbasedir/dracut-version.sh ]]; then\n    . $dracutbasedir/dracut-version.sh\nfi\n\nif [[ -f $dracutbasedir/dracut-init.sh ]]; then\n    . $dracutbasedir/dracut-init.sh\nelse\n    printf \"%s\\n\" \"dracut: Cannot find $dracutbasedir/dracut-init.sh.\" >&2\n    printf \"%s\\n\" \"dracut: Are you running from a git checkout?\" >&2\n    printf \"%s\\n\" \"dracut: Try passing -l as an argument to $dracut_cmd\" >&2\n    exit 1\nfi\n\nif [[ $no_kernel != yes ]] && ! [[ -d $srcmods ]]; then\n    printf \"%s\\n\" \"dracut: Cannot find module directory $srcmods\" >&2\n    printf \"%s\\n\" \"dracut: and --no-kernel was not specified\" >&2\n    exit 1\nfi\n\nif ! [[ $print_cmdline ]]; then\n    inst $DRACUT_TESTBIN\n    if ! $DRACUT_INSTALL ${initdir:+-D \"$initdir\"} ${dracutsysrootdir:+-r \"$dracutsysrootdir\"} -R \"$DRACUT_TESTBIN\" &>/dev/null; then\n        unset DRACUT_RESOLVE_LAZY\n        export DRACUT_RESOLVE_DEPS=1\n    fi\n    rm -fr -- ${initdir}/*\nfi\n\ndracutfunctions=$dracutbasedir/dracut-functions.sh\nexport dracutfunctions\n\n(( ${#drivers_l[@]} )) && drivers=\"${drivers_l[@]}\"\ndrivers=${drivers/-/_}\n\n(( ${#add_drivers_l[@]} )) && add_drivers+=\" ${add_drivers_l[@]} \"\nadd_drivers=${add_drivers/-/_}\n\n(( ${#force_drivers_l[@]} )) && force_drivers+=\" ${force_drivers_l[@]} \"\nforce_drivers=${force_drivers/-/_}\n\n(( ${#omit_drivers_l[@]} )) && omit_drivers+=\" ${omit_drivers_l[@]} \"\nomit_drivers=${omit_drivers/-/_}\n\n(( ${#kernel_cmdline_l[@]} )) && kernel_cmdline+=\" ${kernel_cmdline_l[@]} \"\n\nomit_drivers_corrected=\"\"\nfor d in $omit_drivers; do\n    [[ \" $drivers $add_drivers \" == *\\ $d\\ * ]] && continue\n    [[ \" $drivers $force_drivers \" == *\\ $d\\ * ]] && continue\n    omit_drivers_corrected+=\"$d|\"\ndone\nomit_drivers=\"${omit_drivers_corrected%|}\"\nunset omit_drivers_corrected\n\n# prepare args for logging\nfor ((i=0; i < ${#dracut_args[@]}; i++)); do\n    [[ \"${dracut_args[$i]}\" == *\\ * ]] && \\\n        dracut_args[$i]=\"\\\"${dracut_args[$i]}\\\"\"\n        #\" keep vim happy\ndone\n\ndinfo \"Executing: $dracut_cmd ${dracut_args[@]}\"\n\n[[ $do_list = yes ]] && {\n    for mod in $dracutbasedir/modules.d/*; do\n        [[ -d $mod ]] || continue;\n        [[ -e $mod/install || -e $mod/installkernel || \\\n            -e $mod/module-setup.sh ]] || continue\n        printf \"%s\\n\" \"${mod##*/??}\"\n    done\n    exit 0\n}\n\n# This is kinda legacy -- eventually it should go away.\ncase $dracutmodules in\n    \"\"|auto) dracutmodules=\"all\" ;;\nesac\n\nabs_outfile=$(readlink -f \"$outfile\") && outfile=\"$abs_outfile\"\n\n\n[[ -d $dracutsysrootdir$systemdutildir ]] \\\n    || systemdutildir=$(pkg-config systemd --variable=systemdutildir 2>/dev/null)\n\nif ! [[ -d \"$dracutsysrootdir$systemdutildir\" ]]; then\n    [[ -e $dracutsysrootdir/lib/systemd/systemd-udevd ]] && systemdutildir=/lib/systemd\n    [[ -e $dracutsysrootdir/usr/lib/systemd/systemd-udevd ]] && systemdutildir=/usr/lib/systemd\nfi\n\n\nif [[ $no_kernel != yes ]] && [[ -d $srcmods ]]; then\n    if ! [[ -f $srcmods/modules.dep ]]; then\n        if [[ -n \"$(find \"$srcmods\" -name '*.ko*')\" ]]; then\n            dfatal \"$srcmods/modules.dep is missing. Did you run depmod?\"\n            exit 1\n        else\n            dwarn \"$srcmods/modules.dep is missing. Did you run depmod?\"\n        fi\n    elif ! ( command -v gzip &>/dev/null && command -v xz &>/dev/null); then\n        read _mod < $srcmods/modules.dep\n        _mod=${_mod%%:*}\n        if [[ -f $srcmods/\"$_mod\" ]]; then\n            # Check, if kernel modules are compressed, and if we can uncompress them\n            case \"$_mod\" in\n                *.ko.gz) kcompress=gzip;;\n                *.ko.xz) kcompress=xz;;\n            esac\n            if [[ $kcompress ]]; then\n                if ! command -v \"$kcompress\" &>/dev/null; then\n                    dfatal \"Kernel modules are compressed with $kcompress, but $kcompress is not available.\"\n                    exit 1\n                fi\n            fi\n        fi\n    fi\nfi\n\nif [[ ! $print_cmdline ]]; then\n    if [[ -f $outfile && ! $force ]]; then\n        dfatal \"Will not override existing initramfs ($outfile) without --force\"\n        exit 1\n    fi\n\n    outdir=${outfile%/*}\n    [[ $outdir ]] || outdir=\"/\"\n\n    if [[ ! -d \"$outdir\" ]]; then\n        dfatal \"Can't write to $outdir: Directory $outdir does not exist or is not accessible.\"\n        exit 1\n    elif [[ ! -w \"$outdir\" ]]; then\n        dfatal \"No permission to write to $outdir.\"\n        exit 1\n    elif [[ -f \"$outfile\" && ! -w \"$outfile\" ]]; then\n        dfatal \"No permission to write $outfile.\"\n        exit 1\n    fi\n\n    if [[ $loginstall ]]; then\n        if ! mkdir -p \"$loginstall\"; then\n            dfatal \"Could not create directory to log installed files to '$loginstall'.\"\n            exit 1\n        fi\n        loginstall=$(readlink -f \"$loginstall\")\n    fi\n\n    if [[ $uefi = yes ]]; then\n        if ! command -v objcopy &>/dev/null; then\n            dfatal \"Need 'objcopy' to create a UEFI executable\"\n            exit 1\n        fi\n        unset EFI_MACHINE_TYPE_NAME\n        case $(uname -m) in\n            x86_64)\n                EFI_MACHINE_TYPE_NAME=x64;;\n            ia32)\n                EFI_MACHINE_TYPE_NAME=ia32;;\n            *)\n                dfatal \"Architecture '$(uname -m)' not supported to create a UEFI executable\"\n                exit 1\n                ;;\n        esac\n\n        if ! [[ -s $uefi_stub ]]; then\n            for uefi_stub in \\\n                $dracutsysrootdir\"${systemdutildir}/boot/efi/linux${EFI_MACHINE_TYPE_NAME}.efi.stub\" \\\n                    \"$dracutsysrootdir/usr/lib/gummiboot/linux${EFI_MACHINE_TYPE_NAME}.efi.stub\"; do\n                [[ -s $uefi_stub ]] || continue\n                break\n            done\n        fi\n        if ! [[ -s $uefi_stub ]]; then\n            dfatal \"Can't find a uefi stub '$uefi_stub' to create a UEFI executable\"\n            exit 1\n        fi\n\n        if ! [[ $kernel_image ]]; then\n            for kernel_image in \"$dracutsysrootdir/lib/modules/$kernel/vmlinuz\" \"$dracutsysrootdir/boot/vmlinuz-$kernel\"; do\n                [[ -s \"$kernel_image\" ]] || continue\n                break\n            done\n        fi\n        if ! [[ -s $kernel_image ]]; then\n            dfatal \"Can't find a kernel image '$kernel_image' to create a UEFI executable\"\n            exit 1\n        fi\n    fi\nfi\n\nif [[ $acpi_override = yes ]] && ! ( check_kernel_config CONFIG_ACPI_TABLE_UPGRADE ||  check_kernel_config CONFIG_ACPI_INITRD_TABLE_OVERRIDE ); then\n    dwarn \"Disabling ACPI override, because kernel does not support it. CONFIG_ACPI_INITRD_TABLE_OVERRIDE!=y or CONFIG_ACPI_TABLE_UPGRADE!=y\"\n    unset acpi_override\nfi\n\nif [[ $early_microcode = yes ]]; then\n    if [[ $hostonly ]]; then\n        [[ $(get_cpu_vendor) == \"AMD\" ]] \\\n            && ! check_kernel_config CONFIG_MICROCODE_AMD \\\n            && unset early_microcode\n        [[ $(get_cpu_vendor) == \"Intel\" ]] \\\n            && ! check_kernel_config CONFIG_MICROCODE_INTEL \\\n            && unset early_microcode\n    else\n        ! check_kernel_config CONFIG_MICROCODE_AMD \\\n            && ! check_kernel_config CONFIG_MICROCODE_INTEL \\\n            && unset early_microcode\n    fi\n    [[ $early_microcode != yes ]] \\\n        && dwarn \"Disabling early microcode, because kernel does not support it. CONFIG_MICROCODE_[AMD|INTEL]!=y\"\nfi\n\n# Need to be able to have non-root users read stuff (rpcbind etc)\nchmod 755 \"$initdir\"\n\nif [[ $hostonly ]]; then\n    for i in /sys /proc /run /dev; do\n        if ! findmnt --target \"$i\" &>/dev/null; then\n            dwarning \"Turning off host-only mode: '$i' is not mounted!\"\n            unset hostonly\n        fi\n    done\nfi\n\ndeclare -A host_fs_types\n\nfor line in \"${fstab_lines[@]}\"; do\n    set -- $line\n    dev=\"$1\"\n    #dev mp fs fsopts\n    case \"$dev\" in\n        UUID=*)\n            dev=$(blkid -l -t UUID=${dev#UUID=} -o device)\n            ;;\n        LABEL=*)\n            dev=$(blkid -l -t LABEL=${dev#LABEL=} -o device)\n            ;;\n        PARTUUID=*)\n            dev=$(blkid -l -t PARTUUID=${dev#PARTUUID=} -o device)\n            ;;\n        PARTLABEL=*)\n            dev=$(blkid -l -t PARTLABEL=${dev#PARTLABEL=} -o device)\n            ;;\n    esac\n    [ -z \"$dev\" ] && dwarn \"Bad fstab entry $@\" && continue\n    if [[ \"$3\" == btrfs ]]; then\n        for i in $(btrfs_devs \"$2\"); do\n            push_host_devs \"$i\"\n        done\n    fi\n    push_host_devs \"$dev\"\n    host_fs_types[\"$dev\"]=\"$3\"\ndone\n\nfor f in $add_fstab; do\n    [[ -e $f ]] || continue\n    while read dev rest || [ -n \"$dev\" ]; do\n        push_host_devs \"$dev\"\n    done < \"$f\"\ndone\n\nfor dev in $add_device; do\n    push_host_devs \"$dev\"\ndone\n\nif (( ${#add_device_l[@]} )); then\n    add_device+=\" ${add_device_l[@]} \"\n    push_host_devs \"${add_device_l[@]}\"\nfi\n\nif [[ $hostonly ]] && [[ \"$hostonly_default_device\" != \"no\" ]]; then\n    # in hostonly mode, determine all devices, which have to be accessed\n    # and examine them for filesystem types\n\n    for mp in \\\n        \"/\" \\\n        \"/etc\" \\\n        \"/bin\" \\\n        \"/sbin\" \\\n        \"/lib\" \\\n        \"/lib64\" \\\n        \"/usr\" \\\n        \"/usr/bin\" \\\n        \"/usr/sbin\" \\\n        \"/usr/lib\" \\\n        \"/usr/lib64\" \\\n        \"/boot\" \\\n        \"/boot/efi\" \\\n        \"/boot/zipl\" \\\n        ;\n    do\n        mp=$(readlink -f \"$dracutsysrootdir$mp\")\n        mountpoint \"$mp\" >/dev/null 2>&1 || continue\n        _dev=$(find_block_device \"$mp\")\n        _bdev=$(readlink -f \"/dev/block/$_dev\")\n        [[ -b $_bdev ]] && _dev=$_bdev\n        [[ \"$mp\" == \"/\" ]] && root_devs+=(\"$_dev\")\n        push_host_devs \"$_dev\"\n        if [[ $(find_mp_fstype \"$mp\") == btrfs ]]; then\n            for i in $(btrfs_devs \"$mp\"); do\n                [[ \"$mp\" == \"/\" ]] && root_devs+=(\"$i\")\n                push_host_devs \"$i\"\n            done\n        fi\n    done\n\n    # TODO - with sysroot, /proc/swaps is not relevant\n    if [[ -f /proc/swaps ]] && [[ -f $dracutsysrootdir/etc/fstab ]]; then\n        while read dev type rest || [ -n \"$dev\" ]; do\n            [[ -b $dev ]] || continue\n            [[ \"$type\" == \"partition\" ]] || continue\n\n            while read _d _m _t _o _r || [ -n \"$_d\" ]; do\n                [[ \"$_d\" == \\#* ]] && continue\n                [[ $_d ]] || continue\n                [[ $_t != \"swap\" ]] && continue\n                [[ $_m != \"swap\" ]] && [[ $_m != \"none\" ]] && continue\n                [[ \"$_o\" == *noauto* ]] && continue\n                _d=$(expand_persistent_dev \"$_d\")\n                [[ \"$_d\" -ef \"$dev\" ]] || continue\n\n                if [[ -f $dracutsysrootdir/etc/crypttab ]]; then\n                    while read _mapper _a _p _o || [ -n \"$_mapper\" ]; do\n                        [[ $_mapper = \\#* ]] && continue\n                        [[ \"$_d\" -ef /dev/mapper/\"$_mapper\" ]] || continue\n                        [[ \"$_o\" ]] || _o=\"$_p\"\n                        # skip entries with password files\n                        [[ \"$_p\" == /* ]] && [[ -f $_p ]] && continue 2\n                        # skip mkswap swap\n                        [[ $_o == *swap* ]] && continue 2\n                    done < $dracutsysrootdir/etc/crypttab\n                fi\n\n                _dev=\"$(readlink -f \"$dev\")\"\n                push_host_devs \"$_dev\"\n                swap_devs+=(\"$_dev\")\n                break\n            done < $dracutsysrootdir/etc/fstab\n        done < /proc/swaps\n    fi\n\n    # collect all \"x-initrd.mount\" entries from /etc/fstab\n    if [[ -f $dracutsysrootdir/etc/fstab ]]; then\n        while read _d _m _t _o _r || [ -n \"$_d\" ]; do\n            [[ \"$_d\" == \\#* ]] && continue\n            [[ $_d ]] || continue\n            [[ \"$_o\" != *x-initrd.mount* ]] && continue\n            _dev=$(expand_persistent_dev \"$_d\")\n            _dev=\"$(readlink -f \"$_dev\")\"\n            [[ -b $_dev ]] || continue\n\n            push_host_devs \"$_dev\"\n            if [[ \"$_t\" == btrfs ]]; then\n                for i in $(btrfs_devs \"$_m\"); do\n                    push_host_devs \"$i\"\n                done\n            fi\n        done < $dracutsysrootdir/etc/fstab\n    fi\nfi\n\nunset m\nunset rest\n\n_get_fs_type() {\n    [[ $1 ]] || return\n    if [[ -b /dev/block/$1 ]]; then\n        ID_FS_TYPE=$(get_fs_env \"/dev/block/$1\") && host_fs_types[\"$(readlink -f \"/dev/block/$1\")\"]=\"$ID_FS_TYPE\"\n        return 1\n    fi\n    if [[ -b $1 ]]; then\n        ID_FS_TYPE=$(get_fs_env \"$1\") && host_fs_types[\"$(readlink -f \"$1\")\"]=\"$ID_FS_TYPE\"\n        return 1\n    fi\n    if fstype=$(find_dev_fstype \"$1\"); then\n        host_fs_types[\"$1\"]=\"$fstype\"\n        return 1\n    fi\n    return 1\n}\n\nfor dev in \"${host_devs[@]}\"; do\n    _get_fs_type \"$dev\"\n    check_block_and_slaves_all _get_fs_type \"$(get_maj_min \"$dev\")\"\ndone\n\nfor dev in \"${!host_fs_types[@]}\"; do\n    [[ ${host_fs_types[$dev]} = \"reiserfs\" ]] || [[ ${host_fs_types[$dev]} = \"xfs\" ]] || continue\n    rootopts=$(find_dev_fsopts \"$dev\")\n    if [[ ${host_fs_types[$dev]} = \"reiserfs\" ]]; then\n        journaldev=$(fs_get_option $rootopts \"jdev\")\n    elif [[ ${host_fs_types[$dev]} = \"xfs\" ]]; then\n        journaldev=$(fs_get_option $rootopts \"logdev\")\n    fi\n    if [[ $journaldev ]]; then\n        dev=\"$(readlink -f \"$dev\")\"\n        push_host_devs \"$dev\"\n        _get_fs_type \"$dev\"\n        check_block_and_slaves_all _get_fs_type \"$(get_maj_min \"$dev\")\"\n    fi\ndone\n\n[[ -d $dracutsysrootdir$udevdir ]] \\\n    || udevdir=\"$(pkg-config udev --variable=udevdir 2>/dev/null)\"\nif ! [[ -d \"$dracutsysrootdir$udevdir\" ]]; then\n    [[ -e $dracutsysrootdir/lib/udev/ata_id ]] && udevdir=/lib/udev\n    [[ -e $dracutsysrootdir/usr/lib/udev/ata_id ]] && udevdir=/usr/lib/udev\nfi\n\n[[ -d $dracutsysrootdir$systemdsystemunitdir ]] \\\n    || systemdsystemunitdir=$(pkg-config systemd --variable=systemdsystemunitdir 2>/dev/null)\n\n[[ -d \"$dracutsysrootdir$systemdsystemunitdir\" ]] || systemdsystemunitdir=${systemdutildir}/system\n\n[[ -d $dracutsysrootdir$systemdsystemconfdir ]] \\\n    || systemdsystemconfdir=$(pkg-config systemd --variable=systemdsystemconfdir 2>/dev/null)\n\n[[ -d \"$dracutsysrootdir$systemdsystemconfdir\" ]] || systemdsystemconfdir=/etc/systemd/system\n\n[[ -d $dracutsysrootdir$tmpfilesdir ]] \\\n    || tmpfilesdir=$(pkg-config systemd --variable=tmpfilesdir 2>/dev/null)\n\nif ! [[ -d \"$dracutsysrootdir$tmpfilesdir\" ]]; then\n    [[ -d $dracutsysrootdir/lib/tmpfiles.d ]] && tmpfilesdir=/lib/tmpfiles.d\n    [[ -d $dracutsysrootdir/usr/lib/tmpfiles.d ]] && tmpfilesdir=/usr/lib/tmpfiles.d\nfi\n\nexport initdir dracutbasedir \\\n    dracutmodules force_add_dracutmodules add_dracutmodules omit_dracutmodules \\\n    mods_to_load \\\n    fw_dir drivers_dir debug no_kernel kernel_only \\\n    omit_drivers mdadmconf lvmconf root_devs \\\n    use_fstab fstab_lines libdirs fscks nofscks ro_mnt \\\n    stdloglvl sysloglvl fileloglvl kmsgloglvl logfile \\\n    debug host_fs_types host_devs swap_devs sshkey add_fstab \\\n    DRACUT_VERSION udevdir prefix filesystems drivers \\\n    systemdutildir systemdsystemunitdir systemdsystemconfdir \\\n    hostonly_cmdline loginstall \\\n    tmpfilesdir\n\nmods_to_load=\"\"\n# check all our modules to see if they should be sourced.\n# This builds a list of modules that we will install next.\nfor_each_module_dir check_module\nfor_each_module_dir check_mount\n\ndracut_module_included \"fips\" && export DRACUT_FIPS_MODE=1\n\ndo_print_cmdline()\n{\n    local -A _mods_to_print\n    for i in $modules_loaded $mods_to_load; do\n        _mods_to_print[$i]=1\n    done\n\n    # source our modules.\n    for moddir in \"$dracutbasedir/modules.d\"/[0-9][0-9]*; do\n        _d_mod=${moddir##*/}; _d_mod=${_d_mod#[0-9][0-9]}\n        [[ ${_mods_to_print[$_d_mod]} ]] || continue\n        module_cmdline \"$_d_mod\" \"$moddir\"\n    done\n    unset moddir\n}\n\nif [[ $print_cmdline ]]; then\n    do_print_cmdline\n    printf \"\\n\"\n    exit 0\nfi\n\n# Create some directory structure first\n[[ $prefix ]] && mkdir -m 0755 -p \"${initdir}${prefix}\"\n\n[[ -h $dracutsysrootdir/lib ]] || mkdir -m 0755 -p \"${initdir}${prefix}/lib\"\n[[ $prefix ]] && ln -sfn \"${prefix#/}/lib\" \"$initdir/lib\"\n\nif [[ $prefix ]]; then\n    for d in bin etc lib sbin tmp usr var $libdirs; do\n        [[ \"$d\" == */* ]] && continue\n        ln -sfn \"${prefix#/}/${d#/}\" \"$initdir/$d\"\n    done\nfi\n\nif [[ $kernel_only != yes ]]; then\n    for d in usr/bin usr/sbin bin etc lib sbin tmp usr var var/tmp $libdirs; do\n        [[ -e \"${initdir}${prefix}/$d\" ]] && continue\n        if [ -L \"/$d\" ]; then\n            inst_symlink \"/$d\" \"${prefix}/$d\"\n        else\n            mkdir -m 0755 -p \"${initdir}${prefix}/$d\"\n        fi\n    done\n\n    for d in dev proc sys sysroot root run; do\n        if [ -L \"/$d\" ]; then\n            inst_symlink \"/$d\"\n        else\n            mkdir -m 0755 -p \"$initdir/$d\"\n        fi\n    done\n\n    ln -sfn ../run \"$initdir/var/run\"\n    ln -sfn ../run/lock \"$initdir/var/lock\"\nelse\n    for d in lib \"$libdir\"; do\n        [[ -e \"${initdir}${prefix}/$d\" ]] && continue\n        if [ -h \"/$d\" ]; then\n            inst \"/$d\" \"${prefix}/$d\"\n        else\n            mkdir -m 0755 -p \"${initdir}${prefix}/$d\"\n        fi\n    done\nfi\n\nif [[ $kernel_only != yes ]]; then\n    mkdir -p \"${initdir}/etc/cmdline.d\"\n    for _d in $hookdirs; do\n        mkdir -m 0755 -p ${initdir}/lib/dracut/hooks/$_d\n    done\n    if [[ \"$EUID\" = \"0\" ]]; then\n        [ -c ${initdir}/dev/null ] || mknod ${initdir}/dev/null c 1 3\n        [ -c ${initdir}/dev/kmsg ] || mknod ${initdir}/dev/kmsg c 1 11\n        [ -c ${initdir}/dev/console ] || mknod ${initdir}/dev/console c 5 1\n        [ -c ${initdir}/dev/random ] || mknod ${initdir}/dev/random c 1 8\n        [ -c ${initdir}/dev/urandom ] || mknod ${initdir}/dev/urandom c 1 9\n    fi\nfi\n\n_isize=0 #initramfs size\nmodules_loaded=\" \"\n# source our modules.\nfor moddir in \"$dracutbasedir/modules.d\"/[0-9][0-9]*; do\n    _d_mod=${moddir##*/}; _d_mod=${_d_mod#[0-9][0-9]}\n    [[ \"$mods_to_load\" == *\\ $_d_mod\\ * ]] || continue\n    if [[ $show_modules = yes ]]; then\n        printf \"%s\\n\" \"$_d_mod\"\n    else\n        dinfo \"*** Including module: $_d_mod ***\"\n    fi\n    if [[ $kernel_only == yes ]]; then\n        module_installkernel \"$_d_mod\" \"$moddir\" || {\n            dfatal \"installkernel failed in module $_d_mod\"\n            exit 1\n        }\n    else\n        module_install \"$_d_mod\" \"$moddir\"\n        if [[ $no_kernel != yes ]]; then\n            module_installkernel \"$_d_mod\" \"$moddir\" || {\n                dfatal \"installkernel failed in module $_d_mod\"\n                exit 1\n            }\n        fi\n    fi\n    mods_to_load=${mods_to_load// $_d_mod /}\n    modules_loaded+=\"$_d_mod \"\n\n    #print the module install size\n    if [ -n \"$printsize\" ]; then\n        _isize_new=$(du -sk ${initdir}|cut -f1)\n        _isize_delta=$((_isize_new - _isize))\n        printf \"%s\\n\" \"$_d_mod install size: ${_isize_delta}k\"\n        _isize=$_isize_new\n    fi\ndone\nunset moddir\n\nfor i in $modules_loaded; do\n    mkdir -p $initdir/lib/dracut\n    printf \"%s\\n\" \"$i\" >> $initdir/lib/dracut/modules.txt\ndone\n\ndinfo \"*** Including modules done ***\"\n\n## final stuff that has to happen\nif [[ $no_kernel != yes ]]; then\n    if [[ $hostonly_mode = \"strict\" ]]; then\n        cp \"$DRACUT_KERNEL_MODALIASES\" $initdir/lib/dracut/hostonly-kernel-modules.txt\n    fi\n\n    if [[ $drivers ]]; then\n        hostonly='' instmods $drivers\n    fi\n\n    if [[ -n \"${add_drivers// }\" ]]; then\n        hostonly='' instmods -c $add_drivers\n    fi\n    if [[ $force_drivers ]]; then\n        hostonly='' instmods -c $force_drivers\n        rm -f $initdir/etc/cmdline.d/20-force_driver.conf\n        for mod in $force_drivers; do\n            echo \"rd.driver.pre=$mod\" >>$initdir/etc/cmdline.d/20-force_drivers.conf\n        done\n    fi\n    if [[ $filesystems ]]; then\n        hostonly='' instmods -c $filesystems\n    fi\n\n    dinfo \"*** Installing kernel module dependencies ***\"\n    dracut_kernel_post\n    dinfo \"*** Installing kernel module dependencies done ***\"\n\n    if [[ $noimageifnotneeded == yes ]] && [[ $hostonly ]]; then\n        if [[ ! -f \"$initdir/lib/dracut/need-initqueue\" ]] && \\\n            [[ -f ${initdir}/lib/modules/$kernel/modules.dep && ! -s ${initdir}/lib/modules/$kernel/modules.dep ]]; then\n            for i in ${initdir}/etc/cmdline.d/*.conf; do\n                # We need no initramfs image and do not generate one.\n                [[ $i == \"${initdir}/etc/cmdline.d/*.conf\" ]] && exit 0\n            done\n        fi\n    fi\nfi\n\nif [[ $kernel_only != yes ]]; then\n    (( ${#install_items[@]} > 0 )) && inst_multiple ${install_items[@]}\n    (( ${#install_optional_items[@]} > 0 )) && inst_multiple -o ${install_optional_items[@]}\n\n    [[ $kernel_cmdline ]] && printf \"%s\\n\" \"$kernel_cmdline\" >> \"${initdir}/etc/cmdline.d/01-default.conf\"\n\n    for line in \"${fstab_lines[@]}\"; do\n        line=($line)\n\n        if [ -z \"${line[1]}\" ]; then\n            # Determine device and mount options from current system\n            mountpoint -q \"${line[0]}\" || derror \"${line[0]} is not a mount point!\"\n            line=($(findmnt --raw -n --target \"${line[0]}\" --output=source,target,fstype,options))\n            dinfo \"Line for ${line[1]}: ${line[@]}\"\n        else\n            # Use default options\n            [ -z \"${line[3]}\" ] && line[3]=\"defaults\"\n        fi\n\n        # Default options for freq and passno\n        [ -z \"${line[4]}\" ] && line[4]=\"0\"\n        [ -z \"${line[5]}\" ] && line[5]=\"2\"\n\n        strstr \"${line[2]}\" \"nfs\" && line[5]=\"0\"\n        echo \"${line[@]}\" >> \"${initdir}/etc/fstab\"\n    done\n\n    for f in $add_fstab; do\n        cat \"$f\" >> \"${initdir}/etc/fstab\"\n    done\n\n    if [[ $dracutsysrootdir$systemdutildir ]]; then\n        if [ -d ${initdir}/$systemdutildir ]; then\n            mkdir -p ${initdir}/etc/conf.d\n            {\n                printf \"%s\\n\" \"systemdutildir=\\\"$systemdutildir\\\"\"\n                printf \"%s\\n\" \"systemdsystemunitdir=\\\"$systemdsystemunitdir\\\"\"\n                printf \"%s\\n\" \"systemdsystemconfdir=\\\"$systemdsystemconfdir\\\"\"\n            } > ${initdir}/etc/conf.d/systemd.conf\n        fi\n    fi\n\n    if [[ $DRACUT_RESOLVE_LAZY ]] && [[ $DRACUT_INSTALL ]]; then\n        dinfo \"*** Resolving executable dependencies ***\"\n        find \"$initdir\" -type f -perm /0111 -not -path '*.ko' -print0 \\\n        | xargs -r -0 $DRACUT_INSTALL ${initdir:+-D \"$initdir\"} ${dracutsysrootdir:+-r \"$dracutsysrootdir\"} -R ${DRACUT_FIPS_MODE:+-f} --\n        dinfo \"*** Resolving executable dependencies done ***\"\n    fi\n\n    # Now we are done with lazy resolving, always install dependencies\n    unset DRACUT_RESOLVE_LAZY\n    export DRACUT_RESOLVE_DEPS=1\n\n    # libpthread workaround: pthread_cancel wants to dlopen libgcc_s.so\n    for _dir in $libdirs; do\n        for _f in \"$dracutsysrootdir$_dir/libpthread.so\"*; do\n            [[ -e \"$_f\" ]] || continue\n            inst_libdir_file \"libgcc_s.so*\"\n            break 2\n        done\n    done\nfi\n\nfor ((i=0; i < ${#include_src[@]}; i++)); do\n    src=\"${include_src[$i]}\"\n    target=\"${include_target[$i]}\"\n    if [[ $src && $target ]]; then\n        if [[ -f $src ]]; then\n            inst $src $target\n        elif [[ -d $src ]]; then\n            ddebug \"Including directory: $src\"\n            destdir=\"${initdir}/${target}\"\n            mkdir -p \"$destdir\"\n            # check for preexisting symlinks, so we can cope with the\n            # symlinks to $prefix\n            # Objectname is a file or a directory\n            for objectname in \"$src\"/*; do\n                [[ -e \"$objectname\" || -h \"$objectname\" ]] || continue\n                if [[ -d \"$objectname\" ]]; then\n                    # objectname is a directory, let's compute the final directory name\n                    object_destdir=${destdir}/${objectname#$src/}\n                    if ! [[ -e \"$object_destdir\" ]]; then\n                        mkdir -m 0755 -p \"$object_destdir\"\n                        chmod --reference=\"$objectname\" \"$object_destdir\"\n                    fi\n                    $DRACUT_CP -t \"$object_destdir\" \"$dracutsysrootdir$objectname\"/*\n                else\n                    $DRACUT_CP -t \"$destdir\" \"$dracutsysrootdir$objectname\"\n                fi\n            done\n        elif [[ -e $src ]]; then\n            derror \"$src is neither a directory nor a regular file\"\n        else\n            derror \"$src doesn't exist\"\n        fi\n    fi\ndone\n\nif [[ $kernel_only != yes ]]; then\n    # make sure that library links are correct and up to date\n    for f in $dracutsysrootdir/etc/ld.so.conf $dracutsysrootdir/etc/ld.so.conf.d/*; do\n        [[ -f $f ]] && inst_simple \"${f#$dracutsysrootdir}\"\n    done\n    if ! $DRACUT_LDCONFIG -r \"$initdir\" -f /etc/ld.so.conf; then\n        if [[ $EUID = 0 ]]; then\n            derror \"ldconfig exited ungracefully\"\n        else\n            derror \"ldconfig might need uid=0 (root) for chroot()\"\n        fi\n    fi\nfi\n\nif [[ $do_hardlink = yes ]] && command -v hardlink >/dev/null; then\n    dinfo \"*** Hardlinking files ***\"\n    hardlink \"$initdir\" 2>&1\n    dinfo \"*** Hardlinking files done ***\"\nfi\n\n# strip binaries\nif [[ $do_strip = yes ]] ; then\n    # Prefer strip from elfutils for package size\n    declare strip_cmd=$(command -v eu-strip)\n    test -z \"$strip_cmd\" && strip_cmd=\"strip\"\n\n    for p in $strip_cmd xargs find; do\n        if ! type -P $p >/dev/null; then\n            dinfo \"Could not find '$p'. Not stripping the initramfs.\"\n            do_strip=no\n        fi\n    done\nfi\n\n# cleanup empty ldconfig_paths directories\nfor d in $(ldconfig_paths); do\n    rmdir -p --ignore-fail-on-non-empty \"$initdir/$d\" >/dev/null 2>&1\ndone\n\nif [[ $early_microcode = yes ]]; then\n    dinfo \"*** Generating early-microcode cpio image ***\"\n    ucode_dir=(amd-ucode intel-ucode)\n    ucode_dest=(AuthenticAMD.bin GenuineIntel.bin)\n    _dest_dir=\"$early_cpio_dir/d/kernel/x86/microcode\"\n    _dest_idx=\"0 1\"\n    mkdir -p $_dest_dir\n    if [[ $hostonly ]]; then\n        [[ $(get_cpu_vendor) == \"AMD\" ]] && _dest_idx=\"0\"\n        [[ $(get_cpu_vendor) == \"Intel\" ]] && _dest_idx=\"1\"\n    fi\n    for idx in $_dest_idx; do\n        _fw=${ucode_dir[$idx]}\n        for _fwdir in $fw_dir; do\n            if [[ -d $_fwdir && -d $_fwdir/$_fw ]]; then\n                _src=\"*\"\n                dinfo \"*** Constructing ${ucode_dest[$idx]} ***\"\n                if [[ $hostonly ]]; then\n                    _src=$(get_ucode_file)\n                    [[ $_src ]] || break\n                    [[ -r $_fwdir/$_fw/$_src ]] || _src=\"${_src}.early\"\n                    [[ -r $_fwdir/$_fw/$_src ]] || break\n                fi\n\n                for i in $_fwdir/$_fw/$_src; do\n                    [ -e \"$i\" ] && break\n                    break 2\n                done\n                for i in $_fwdir/$_fw/$_src; do\n                    [[ -e \"$i\" ]] || continue\n                    # skip gpg files\n                    str_ends \"$i\" \".asc\" && continue\n                    cat \"$i\" >> $_dest_dir/${ucode_dest[$idx]}\n                done\n                create_early_cpio=\"yes\"\n            fi\n        done\n        if [[ ! -e \"$_dest_dir/${ucode_dest[$idx]}\" ]]; then\n            cd \"$early_cpio_dir/d\"\n            for _ucodedir in \"${early_microcode_image_dir[@]}\"; do\n                for _ucodename in \"${early_microcode_image_name[@]}\"; do\n                    [[ -e \"$_ucodedir/$_ucodename\" ]] && \\\n                    cpio --extract --file \"$_ucodedir/$_ucodename\" --quiet \\\n                         \"kernel/x86/microcode/${ucode_dest[$idx]}\"\n                    if [[ -e \"$_dest_dir/${ucode_dest[$idx]}\" ]]; then\n                        dinfo \"*** Using microcode found in '$_ucodedir/$_ucodename' ***\"\n                        create_early_cpio=\"yes\"\n                        break 2\n                    fi\n                done\n            done\n        fi\n    done\nfi\n\nif [[ $acpi_override = yes ]] && [[ -d $acpi_table_dir ]]; then\n    dinfo \"*** Packaging ACPI tables to override BIOS provided ones ***\"\n    _dest_dir=\"$early_cpio_dir/d/kernel/firmware/acpi\"\n    mkdir -p $_dest_dir\n    for table in $acpi_table_dir/*.aml; do\n        dinfo \"   Adding ACPI table: $table\"\n        $DRACUT_CP $table $_dest_dir\n        create_early_cpio=\"yes\"\n    done\nfi\n\ndinfo \"*** Store current command line parameters ***\"\nif ! ( echo $PARMS_TO_STORE > $initdir/lib/dracut/build-parameter.txt ); then\n    dfatal \"Could not store the current command line parameters\"\n    exit 1\nfi\n\nif [[ $hostonly_cmdline == \"yes\" ]] ; then\n    unset _stored_cmdline\n    if [ -d $initdir/etc/cmdline.d ];then\n        dinfo \"Stored kernel commandline:\"\n        for conf in $initdir/etc/cmdline.d/*.conf ; do\n            [ -e \"$conf\" ] || continue\n            dinfo \"$(< $conf)\"\n            _stored_cmdline=1\n        done\n    fi\n    if ! [[ $_stored_cmdline ]]; then\n        dinfo \"No dracut internal kernel commandline stored in the initramfs\"\n    fi\nfi\n\nif dracut_module_included \"squash\"; then\n    dinfo \"*** Install squash loader ***\"\n    if ! check_kernel_config CONFIG_SQUASHFS; then\n        dfatal \"CONFIG_SQUASHFS have to be enabled for dracut squash module to work\"\n        exit 1\n    fi\n    if ! check_kernel_config CONFIG_OVERLAY_FS; then\n        dfatal \"CONFIG_OVERLAY_FS have to be enabled for dracut squash module to work\"\n        exit 1\n    fi\n    if ! check_kernel_config CONFIG_DEVTMPFS; then\n        dfatal \"CONFIG_DEVTMPFS have to be enabled for dracut squash module to work\"\n        exit 1\n    fi\n\n    readonly squash_dir=\"$initdir/squash/root\"\n    readonly squash_img=$initdir/squash/root.img\n\n    # Currently only move \"usr\" \"etc\" to squashdir\n    readonly squash_candidate=( \"usr\" \"etc\" )\n\n    mkdir -m 0755 -p $squash_dir\n    for folder in \"${squash_candidate[@]}\"; do\n        mv $initdir/$folder $squash_dir/$folder\n    done\n\n    # Move some files out side of the squash image, including:\n    # - Files required to boot and mount the squashfs image\n    # - Files need to be accessible without mounting the squash image\n    required_in_root() {\n        local file=$1\n        local _sqsh_file=$squash_dir/$file\n        local _init_file=$initdir/$file\n\n        if [[ -e $_init_file ]]; then\n            return\n        fi\n\n        if [[ ! -e $_sqsh_file ]] && [[ ! -L $_sqsh_file ]]; then\n            derror \"$file is required to boot a squashed initramfs but it's not installed!\"\n            return\n        fi\n\n        if [[ ! -d $(dirname $_init_file) ]]; then\n            required_in_root $(dirname $file)\n        fi\n\n        if [[ -L $_sqsh_file ]]; then\n          cp --preserve=all -P $_sqsh_file $_init_file\n          _sqsh_file=$(realpath $_sqsh_file 2>/dev/null)\n          if [[ -e $_sqsh_file ]] && [[ \"$_sqsh_file\" == \"$squash_dir\"* ]]; then\n            # Relative symlink\n            required_in_root ${_sqsh_file#$squash_dir/}\n            return\n          fi\n          if [[ -e $squash_dir$_sqsh_file ]]; then\n            # Absolute symlink\n            required_in_root ${_sqsh_file#/}\n            return\n          fi\n          required_in_root ${module_spec#$squash_dir/}\n        else\n          if [[ -d $_sqsh_file ]]; then\n            mkdir $_init_file\n          else\n            mv $_sqsh_file $_init_file\n          fi\n        fi\n    }\n\n    required_in_root etc/initrd-release\n\n    for module_spec in $squash_dir/usr/lib/modules/*/modules.*;\n    do\n        required_in_root ${module_spec#$squash_dir/}\n    done\n\n    for dracut_spec in $squash_dir/usr/lib/dracut/*;\n    do\n        required_in_root ${dracut_spec#$squash_dir/}\n    done\n\n    mv $initdir/init $initdir/init.stock\n    ln -s squash/init.sh $initdir/init\n\n    # Reinstall required files for the squash image setup script.\n    # We have moved them inside the squashed image, but they need to be\n    # accessible before mounting the image.\n    inst_multiple \"echo\" \"sh\" \"mount\" \"modprobe\" \"mkdir\"\n    hostonly=\"\" instmods \"loop\" \"squashfs\" \"overlay\"\n\n    # Only keep systemctl outsite if we need switch root\n    if [[ ! -f \"$initdir/lib/dracut/no-switch-root\" ]]; then\n      inst \"systemctl\"\n    fi\n\n    for folder in \"${squash_candidate[@]}\"; do\n        # Remove duplicated files in squashfs image, save some more space\n        [[ ! -d $initdir/$folder/ ]] && continue\n        for file in $(find $initdir/$folder/ -not -type d);\n        do\n            if [[ -e $squash_dir${file#$initdir} ]]; then\n                mv $squash_dir${file#$initdir} $file\n            fi\n        done\n    done\nfi\n\nif [[ $do_strip = yes ]] && ! [[ $DRACUT_FIPS_MODE ]]; then\n    dinfo \"*** Stripping files ***\"\n    find \"$initdir\" -type f \\\n        -executable -not -path '*/lib/modules/*.ko' -print0 \\\n        | xargs -r -0 $strip_cmd -g -p 2>/dev/null\n\n    # strip kernel modules, but do not touch signed modules\n    find \"$initdir\" -type f -path '*/lib/modules/*.ko' -print0 \\\n        | while read -r -d $'\\0' f || [ -n \"$f\" ]; do\n        SIG=$(tail -c 28 \"$f\" | tr -d '\\000')\n        [[ $SIG == '~Module signature appended~' ]] || { printf \"%s\\000\" \"$f\"; }\n    done | xargs -r -0 $strip_cmd -g -p\n    dinfo \"*** Stripping files done ***\"\nfi\n\nif dracut_module_included \"squash\"; then\n    dinfo \"*** Squashing the files inside the initramfs ***\"\n    mksquashfs $squash_dir $squash_img -no-xattrs -no-exports -noappend -always-use-fragments -comp xz -Xdict-size 100% -no-progress 1> /dev/null\n\n    if [[ $? != 0 ]]; then\n        dfatal \"dracut: Failed making squash image\"\n        exit 1\n    fi\n\n    rm -rf $squash_dir\n    dinfo \"*** Squashing the files inside the initramfs done ***\"\nfi\n\ndinfo \"*** Creating image file '$outfile' ***\"\n\nif [[ $uefi = yes ]]; then\n    readonly uefi_outdir=\"$DRACUT_TMPDIR/uefi\"\n    mkdir \"$uefi_outdir\"\nfi\n\nif [[ $DRACUT_REPRODUCIBLE ]]; then\n    find \"$initdir\" -newer \"$dracutbasedir/dracut-functions.sh\" -print0 \\\n        | xargs -r -0 touch -h -m -c -r \"$dracutbasedir/dracut-functions.sh\"\n\n    if [[ \"$(cpio --help)\" == *--reproducible* ]]; then\n        CPIO_REPRODUCIBLE=1\n    else\n        dinfo \"cpio does not support '--reproducible'. Resulting image will not be reproducible.\"\n    fi\nfi\n\n[[ \"$EUID\" != 0 ]] && cpio_owner_root=\"-R 0:0\"\n\nif [[ $create_early_cpio = yes ]]; then\n    echo 1 > \"$early_cpio_dir/d/early_cpio\"\n\n    if [[ $DRACUT_REPRODUCIBLE ]]; then\n        find \"$early_cpio_dir/d\" -newer \"$dracutbasedir/dracut-functions.sh\" -print0 \\\n            | xargs -r -0 touch -h -m -c -r \"$dracutbasedir/dracut-functions.sh\"\n    fi\n\n    # The microcode blob is _before_ the initramfs blob, not after\n    if ! (\n            umask 077; cd \"$early_cpio_dir/d\"\n            find . -print0 | sort -z \\\n                | cpio ${CPIO_REPRODUCIBLE:+--reproducible} --null $cpio_owner_root -H newc -o --quiet > \"${DRACUT_TMPDIR}/initramfs.img\"\n        ); then\n        dfatal \"dracut: creation of $outfile failed\"\n        exit 1\n    fi\nfi\n\nif ! (\n        umask 077; cd \"$initdir\"\n        find . -print0 | sort -z \\\n            | cpio ${CPIO_REPRODUCIBLE:+--reproducible} --null $cpio_owner_root -H newc -o --quiet \\\n            | $compress >> \"${DRACUT_TMPDIR}/initramfs.img\"\n    ); then\n    dfatal \"dracut: creation of $outfile failed\"\n    exit 1\nfi\n\nif (( maxloglvl >= 5 )) && (( verbosity_mod_l >= 0 )); then\n    if [[ $allowlocal ]]; then\n\t\"$dracutbasedir/lsinitrd.sh\" \"${DRACUT_TMPDIR}/initramfs.img\"| ddebug\n    else\n        lsinitrd \"${DRACUT_TMPDIR}/initramfs.img\"| ddebug\n    fi\nfi\n\numask 077\n\nif [[ $uefi = yes ]]; then\n    if [[ $kernel_cmdline ]]; then\n        echo -n \"$kernel_cmdline\" > \"$uefi_outdir/cmdline.txt\"\n    elif [[ $hostonly_cmdline = yes ]] && [ -d $initdir/etc/cmdline.d ];then\n        for conf in $initdir/etc/cmdline.d/*.conf ; do\n            [ -e \"$conf\" ] || continue\n            printf \"%s \" \"$(< $conf)\" >> \"$uefi_outdir/cmdline.txt\"\n        done\n    else\n        do_print_cmdline > \"$uefi_outdir/cmdline.txt\"\n    fi\n    echo -ne \"\\x00\" >> \"$uefi_outdir/cmdline.txt\"\n\n    dinfo \"Using UEFI kernel cmdline:\"\n    dinfo $(tr -d '\\000' < \"$uefi_outdir/cmdline.txt\")\n\n    [[ -s $dracutsysrootdir/usr/lib/os-release ]] && uefi_osrelease=\"$dracutsysrootdir/usr/lib/os-release\"\n    [[ -s $dracutsysrootdir/etc/os-release ]] && uefi_osrelease=\"$dracutsysrootdir/etc/os-release\"\n    [[ -s \"${dracutsysrootdir}${uefi_splash_image}\" ]] && \\\n        uefi_splash_image=\"${dracutsysroot}${uefi_splash_image}\" || unset uefi_splash_image\n\n    if objcopy \\\n           ${uefi_osrelease:+--add-section .osrel=$uefi_osrelease --change-section-vma .osrel=0x20000} \\\n           --add-section .cmdline=\"${uefi_outdir}/cmdline.txt\" --change-section-vma .cmdline=0x30000 \\\n           ${uefi_splash_image:+--add-section .splash=\"$uefi_splash_image\" --change-section-vma .splash=0x40000} \\\n           --add-section .linux=\"$kernel_image\" --change-section-vma .linux=0x2000000 \\\n           --add-section .initrd=\"${DRACUT_TMPDIR}/initramfs.img\" --change-section-vma .initrd=0x3000000 \\\n           \"$uefi_stub\" \"${uefi_outdir}/linux.efi\"; then\n        if [[ -n \"${uefi_secureboot_key}\" && -n \"${uefi_secureboot_cert}\" ]]; then \\\n            if sbsign \\\n                    --key \"${uefi_secureboot_key}\" \\\n                    --cert \"${uefi_secureboot_cert}\" \\\n                    --output \"$outfile\" \"${uefi_outdir}/linux.efi\"; then\n                dinfo \"*** Creating signed UEFI image file '$outfile' done ***\"\n            else\n                dfatal \"*** Creating signed UEFI image file '$outfile' failed ***\"\n                exit 1\n            fi\n        else\n            if cp --reflink=auto \"${uefi_outdir}/linux.efi\" \"$outfile\"; then\n                dinfo \"*** Creating UEFI image file '$outfile' done ***\"\n            fi\n        fi\n    else\n        rm -f -- \"$outfile\"\n        dfatal \"*** Creating UEFI image file '$outfile' failed ***\"\n        exit 1\n    fi\nelse\n    if cp --reflink=auto \"${DRACUT_TMPDIR}/initramfs.img\" \"$outfile\"; then\n        dinfo \"*** Creating initramfs image file '$outfile' done ***\"\n    else\n        rm -f -- \"$outfile\"\n        dfatal \"dracut: creation of $outfile failed\"\n        exit 1\n    fi\nfi\n\ncommand -v restorecon &>/dev/null && restorecon -- \"$outfile\"\n\n# We sync/fsfreeze only if we're operating on a live booted system.\n# It's possible for e.g. `kernel` to be installed as an RPM BuildRequires or equivalent,\n# and there's no reason to sync, and *definitely* no reason to fsfreeze.\n# Another case where this happens is rpm-ostree, which performs its own sync/fsfreeze\n# globally.  See e.g. https://github.com/ostreedev/ostree/commit/8642ef5ab3fec3ac8eb8f193054852f83a8bc4d0\nif test -d $dracutsysrootdir/run/systemd/system; then\n    if ! sync \"$outfile\" 2> /dev/null; then\n        dinfo \"dracut: sync operation on newly created initramfs $outfile failed\"\n        exit 1\n    fi\n\n    # use fsfreeze only if we're not writing to /\n    if [[ \"$(stat -c %m -- \"$outfile\")\" != \"/\" && \"$(stat -f -c %T -- \"$outfile\")\" != \"msdos\" ]]; then\n        if ! $(fsfreeze -f $(dirname \"$outfile\") 2>/dev/null && fsfreeze -u $(dirname \"$outfile\") 2>/dev/null); then\n            dinfo \"dracut: warning: could not fsfreeze $(dirname \"$outfile\")\"\n        fi\n    fi\nfi\n\nexit 0\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-dracut-050-nnqdpidcvez4k4kdc3og4k5gknuxmn75/spack-src/dracut.png",
        "/tmp/vanessa/spack-stage/spack-stage-dracut-050-nnqdpidcvez4k4kdc3og4k5gknuxmn75/spack-src/test/TEST-30-ISCSI/ibft.table"
    ],
    "total_files": 506
}