{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-openloops-2.1.1-2pxb7uebklk56opjo3yqpykinay2r4n5/spack-src/lib_src/openloops/src/ol_interface.F90": "!******************************************************************************!\n! Copyright (C) 2014-2019 OpenLoops Collaboration. For authors see authors.txt !\n!                                                                              !\n! This file is part of OpenLoops.                                              !\n!                                                                              !\n! OpenLoops is free software: you can redistribute it and/or modify            !\n! it under the terms of the GNU General Public License as published by         !\n! the Free Software Foundation, either version 3 of the License, or            !\n! (at your option) any later version.                                          !\n!                                                                              !\n! OpenLoops is distributed in the hope that it will be useful,                 !\n! but WITHOUT ANY WARRANTY; without even the implied warranty of               !\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                !\n! GNU General Public License for more details.                                 !\n!                                                                              !\n! You should have received a copy of the GNU General Public License            !\n! along with OpenLoops.  If not, see <http://www.gnu.org/licenses/>.           !\n!******************************************************************************!\n\n\nmodule openloops\n  use KIND_TYPES, only: DREALKIND\n  use, intrinsic :: iso_c_binding, only: c_ptr, c_null_ptr, c_char, c_int, c_double, c_null_char\n  use ol_init, only: set_init_error_fatal, set_parameter, get_parameter, parameters_flush, &\n      & tree_parameters_flush, cleanup, set_if_modified\n  use ol_version, only: welcome, openloops_version_string\n  use ol_parameters_decl_/**/DREALKIND,  only: procname_length, max_parameter_length\n  use ol_external_decl_/**/DREALKIND, only: n_scatt\n  use ol_debug, only: get_error, ol_msg, ol_error, ol_fatal, ol_fatal_update, error\n  use ol_parameters_init_/**/DREALKIND, only: parameters_write\n  implicit none\n  private\n  ! from module init_iu\n  public :: set_init_error_fatal, get_error\n  public :: set_parameter, get_parameter, parameters_flush, tree_parameters_flush\n  ! from module use ol_version\n  public :: welcome, openloops_version_string\n  ! process interface\n  public :: n_external, amplitudetype, phase_space_point, start, finish\n  public :: tree_colbasis_dim, tree_colbasis, tree_colourflow\n  public :: register_process, register_process_id\n  public :: evaluate_tree\n  public :: evaluate_cc, evaluate_loopcc, evaluate_cc2\n  public :: evaluate_ccmatrix, evaluate_loopccmatrix, evaluate_ccmatrix2\n  public :: evaluate_ccewmatrix, evaluate_ccewmatrix2\n  public :: evaluate_sc, evaluate_loopsc, evaluate_sc2\n  public :: evaluate_sctensor, evaluate_sctensor2, evaluate_loopsctensor\n  public :: evaluate_scpowheg, evaluate_loopscpowheg, evaluate_scpowheg2\n  public :: evaluate_stensor, evaluate_loopstensor, evaluate_stensor2\n  public :: evaluate_tree_colvect, evaluate_tree_colvect2\n  public :: evaluate_full, evaluate_loop, evaluate_loop2\n  public :: evaluate_loopbare, evaluate_ct, evaluate_loopct, evaluate_r2\n  public :: evaluate_iop, evaluate_iop2\n  public :: evaluate_pt, evaluate_schsf\n  public :: evaluate_associated\n  public :: evaluate_poles\n  ! Print parameters\n  public :: ol_printparameter\n  ! used in BLHA interface\n  public :: rval_size, stop_invalid_id\n\n  interface register_process\n    module procedure register_process_string, register_process_id\n  end interface register_process\n\n  interface printparameter\n    module procedure ol_printparameter\n  end interface printparameter\n\n  interface evaluate_stensor\n    module procedure evaluate_scpowheg\n  end interface evaluate_stensor\n\n  interface evaluate_loopstensor\n    module procedure evaluate_loopscpowheg\n  end interface evaluate_loopstensor\n\n  interface evaluate_stensor2\n    module procedure evaluate_scpowheg2\n  end interface evaluate_stensor2\n\n\n  type process_handle\n    integer :: n_particles = 0\n    integer :: max_point = -1\n    integer :: tensor_rank = -1\n    integer :: qcd_powers(2)\n    ! allocatable length character members are not supported in gfortran (tested with 4.8.1)\n    character(len=procname_length) :: process_name\n    character(len=max_parameter_length) :: library_name\n    integer, allocatable :: permutation(:)\n    integer, allocatable :: pol(:)\n    integer, allocatable :: extid(:)\n    integer, allocatable :: photon_id(:)\n    type(c_ptr) :: library_handle = c_null_ptr\n    integer :: amplitude_type ! 1=Tree, 11=Loop, 12=LoopInduced\n    integer :: content = 0 ! bitwise: 2^0=tree, 2^1=loop, 2^2=loop2, 2^3=pt\n    integer :: n_in = 2 ! Phase-space for n_in -> n-n_in\n    integer :: associated_ew = 0\n    integer :: associated_born_1 = 0\n    integer :: associated_born_2 = 0\n    integer :: replace_loop = 0\n    integer :: stability_mode = -1\n    integer :: a_switch = -1\n    integer :: a_switch_rescue = -1\n    integer :: redlib_qp = -1\n    real(DREALKIND), allocatable :: masses(:)\n    real(DREALKIND), allocatable :: last_psp(:,:)\n    real(DREALKIND) :: last_muren\n    real(DREALKIND) :: last_alpha_QCD\n    integer :: loop_parameters_status\n    integer, allocatable :: last_perm(:)\n    integer, allocatable :: last_pol(:)\n    logical :: last_zero = .true.\n    procedure(), pointer, nopass :: set_permutation => null()\n    procedure(), pointer, nopass :: pol_init => null()\n    procedure(), pointer, nopass :: set_photons => null()\n    procedure(), pointer, nopass :: tree => null()\n    procedure(), pointer, nopass :: loop => null()\n    procedure(), pointer, nopass :: loopcr => null()\n    procedure(), pointer, nopass :: ct => null()\n    procedure(), pointer, nopass :: pt => null()\n    procedure(), pointer, nopass :: schsf => null()\n    procedure(), pointer, nopass :: rambo => null()\n    procedure(), pointer, nopass :: tree_colbasis_dim => null()\n    procedure(), pointer, nopass :: tree_colbasis => null()\n    procedure(), pointer, nopass :: tree_colvect => null()\n    procedure(), pointer, nopass :: iop => null()\n    procedure(), pointer, nopass :: loopcc => null()\n  end type process_handle\n\n  ! process handle array\n  integer, save :: last_process_id = 0\n  type(process_handle), save, allocatable :: process_handles(:)\n\n  type processinfos\n    integer :: EWorder(0:1)\n    integer :: QCDorder(0:1)\n    integer :: OLMode\n    integer :: API\n    integer :: LeadingColour\n    integer :: NF\n    integer :: NC\n    integer :: CKMORDER\n    integer :: POLSEL\n    character :: ME, MM, ML, MU, MD, MS, MC, MB\n    integer :: YE, YM, YL, YU, YD, YS, YC, YB, YT\n    character :: CC\n    character(len=max_parameter_length) :: LIBNAME\n    character(len=127) :: MODEL\n    character(len=127) :: PROC\n    character(len=127) :: MAP\n    character(len=127) :: MAPPERM\n    character(len=127) :: APPROX\n    character(len=4) :: ID\n    character(len=4) :: TYPE\n    character(len=4) :: LTYPE\n  end type processinfos\n  type(processinfos), save, allocatable :: process_infos(:)\n  type(processinfos), save, allocatable :: loaded_libs(:)\n\n  type extparticle\n    integer :: id\n    integer :: pol\n    logical :: is_initial\n  end type extparticle\n\n  ! array for shopping list\n  character(len=max_parameter_length), save, allocatable :: shopped_processes(:)\n  logical, save :: shopping_list_open = .false.\n  integer, parameter :: fh_shopping = 998\n  ! PDG IDs of particles which carry adjoint colour\n  integer :: pdgadjoint(1) = [21]\n\n#if __APPLE__\n  character(len=5), parameter :: dynlib_extension='dylib'\n#else\n  character(len=2), parameter :: dynlib_extension='so'\n#endif\n\n  character(len=4) :: loops_flags = \"tlsp\" ! used in this order to set content bits\n\n\n  contains\n\n\n  pure function rval_size(n_part, amp_type)\n    implicit none\n    integer :: rval_size\n    integer, intent(in) :: n_part, amp_type\n    select case (amp_type)\n      case  (1, 12) ! Tree, LoopInduced\n        rval_size = 1\n      case (11) ! Loop\n        rval_size = 4\n      case (2) ! ccTreeo\n        rval_size = (n_part*(n_part-1))/2\n      case (3) ! scTree\n        rval_size = 2*n_part*n_part\n      case (4) ! scTree_polvect\n        rval_size = n_part\n      case (0)\n        rval_size = 0\n      case default\n        ! unknown amp_type\n        rval_size = 0\n    end select\n  end function rval_size\n\n\n  function get_process_handle(lib, libname, proc, content, amptype, n_in, perm, pol, extid, photon_id, qcd_powers)\n    ! [in] lib: a shared library handle\n    ! [in] proc: a full process name, '<lib>_<subproc>_<id>'\n    ! [in] perm: integer array with the crossing\n    ! [in] content: integer with binary tags for tree, loop, loop2, pt\n    ! [in] amptype: integer to specify BLHA matrix element type\n    ! return process handle of type process_handle\n    ! note: error handling is done in dlsym\n    use KIND_TYPES, only: DREALKIND\n    use ol_dlfcn, only: dlsym\n    use ol_loop_parameters_decl_/**/DREALKIND, only: &\n         & stability_mode,a_switch,a_switch_rescue,redlib_qp,hel_mem_opt_switch\n    implicit none\n    type(c_ptr), intent(in) :: lib\n    character(len=*), intent(in) :: libname\n    character(len=*), intent(in) :: proc\n    integer, intent(in) :: content, amptype, n_in\n    integer, intent(in), optional :: perm(:)\n    integer, intent(in), optional :: pol(:)\n    integer, intent(in), optional :: extid(:)\n    integer, intent(in), optional :: photon_id(:)\n    integer, intent(in), optional :: qcd_powers(2)\n    type(process_handle) :: get_process_handle\n    integer :: k\n    procedure(), pointer :: tmp_fun\n\n    ! number of external particles\n    tmp_fun => dlsym(lib, \"ol_f_n_external_\" // trim(proc))\n\n    call tmp_fun(get_process_handle%n_particles)\n    get_process_handle%library_name = trim(libname)\n    get_process_handle%process_name = trim(proc)\n    allocate(get_process_handle%permutation(get_process_handle%n_particles))\n    if (present(perm)) then\n      ! check correct size of the permutation\n      if (get_process_handle%n_particles /= size(perm)) then\n        call ol_fatal('error: registered process with wrong size of particle permutation')\n        return\n      end if\n      get_process_handle%permutation = perm\n    else\n      get_process_handle%permutation = [(k, k=1, get_process_handle%n_particles)]\n    end if\n    get_process_handle%library_handle = lib\n    get_process_handle%set_permutation => dlsym(lib, \"ol_f_set_permutation_\" // trim(proc))\n    get_process_handle%rambo => dlsym(lib, \"ol_f_rambo_\" // trim(proc))\n    get_process_handle%amplitude_type = amptype\n    get_process_handle%tree => dlsym(lib, \"ol_f_amp2_\" // trim(proc))\n    get_process_handle%loop => dlsym(lib, \"ol_f_vamp2_\" // trim(proc))\n    get_process_handle%ct => dlsym(lib, \"ol_f_ctamp2_\" // trim(proc))\n    get_process_handle%pt => dlsym(lib, \"ol_f_ptamp2_\" // trim(proc))\n    get_process_handle%schsf => dlsym(lib, \"ol_f_schsfamp2_\" // trim(proc))\n    get_process_handle%content = content\n    get_process_handle%n_in = n_in\n    get_process_handle%qcd_powers = qcd_powers\n    ! loop correlators\n    get_process_handle%loopcr => dlsym(lib, \"ol_f_vampcr2_\" // trim(proc))\n    allocate(get_process_handle%last_psp(4,get_process_handle%n_particles))\n    get_process_handle%last_psp=0\n    allocate(get_process_handle%last_perm(get_process_handle%n_particles))\n    get_process_handle%last_perm=0\n    allocate(get_process_handle%last_pol(get_process_handle%n_particles))\n    get_process_handle%last_pol=0\n    get_process_handle%loop_parameters_status = -1\n    ! external masses and highest tensor rank\n    tmp_fun => dlsym(lib, \"ol_f_get_masses_\" // trim(proc))\n    allocate(get_process_handle%masses(get_process_handle%n_particles))\n    call tmp_fun(get_process_handle%masses)\n    allocate(get_process_handle%pol(get_process_handle%n_particles))\n    get_process_handle%pol_init => dlsym(lib, \"ol_f_pol_init_\" // trim(proc))\n    if (present(pol)) then\n      ! check correct size of the polarization vector\n      if (get_process_handle%n_particles /= size(pol)) then\n        call ol_fatal('error: registered process with wrong size of polarization vector')\n        return\n      end if\n      get_process_handle%pol = pol\n    else\n      get_process_handle%pol = 0\n    end if\n    allocate(get_process_handle%extid(get_process_handle%n_particles))\n    if (present(extid)) then\n      ! check correct size of the extid vector\n      if (get_process_handle%n_particles /= size(extid)) then\n        call ol_fatal('error: registered process with wrong size of extid')\n        return\n      end if\n      get_process_handle%extid = extid\n    else\n      get_process_handle%extid = 0\n    end if\n    allocate(get_process_handle%photon_id(get_process_handle%n_particles))\n    if (present(photon_id)) then\n      ! check correct size of the photon_id vector\n      if (get_process_handle%n_particles /= size(photon_id)) then\n        call ol_fatal('error: registered process with wrong size of extid')\n        return\n      end if\n      get_process_handle%photon_id = photon_id\n    else\n      get_process_handle%photon_id = 0\n    end if\n    get_process_handle%set_photons => dlsym(lib, \"ol_f_set_photons_\" // trim(proc))\n    if (btest(content, 1)) then\n      tmp_fun => dlsym(lib, \"ol_f_max_point_\" // trim(proc))\n      call tmp_fun(get_process_handle%max_point)\n      tmp_fun => dlsym(lib, \"ol_f_tensor_rank_\" // trim(proc))\n      call tmp_fun(get_process_handle%tensor_rank)\n    end if\n    ! colour basis\n    get_process_handle%tree_colbasis_dim => dlsym(lib, \"ol_tree_colbasis_dim_\" // trim(proc))\n    get_process_handle%tree_colbasis => dlsym(lib, \"ol_tree_colbasis_\" // trim(proc))\n    get_process_handle%tree_colvect => dlsym(lib, \"ol_tree_colvect_\" // trim(proc))\n    ! stability settings\n    get_process_handle%a_switch=a_switch\n    get_process_handle%a_switch_rescue=a_switch_rescue\n    get_process_handle%redlib_qp=redlib_qp\n    get_process_handle%stability_mode=stability_mode\n    ! optimized helicity bookkeeping\n    tmp_fun => dlsym(lib, \"ol_hel_mem_opt_\" // trim(proc))\n    if (associated(tmp_fun)) then\n      call tmp_fun(hel_mem_opt_switch)\n    else\n!      call ol_fatal_update()\n    end if\n    tmp_fun => dlsym(lib, \"ol_f_iopamp2_\" // trim(proc))\n    if (associated(tmp_fun)) then\n      get_process_handle%iop => tmp_fun\n    end if\n    get_process_handle%loopcc => dlsym(lib, \"ol_loopcc_\" // trim(proc))\n  end function get_process_handle\n\n  function register_process_lib(libname, proc, content, amptype, n_in, pol, perm, extid, photon_id, qcd_powers)\n    ! [in] libname: name of the process library\n    ! [in] proc: a full process name, '<lib>_<subproc>_<id>'\n    ! [in] perm: integer array with the crossing\n    ! [in] content: integer with binary tags for tree, loop, loop2, pt\n    ! [in] amptype: integer to specify BLHA matrix element type\n    ! return (integer) process id to be used in OLP_EvalSubProcess\n    use KIND_TYPES, only: DREALKIND\n    use ol_dlfcn, only: dlopen, RTLD_LAZY\n    use ol_loop_parameters_decl_/**/DREALKIND, only: maxpoint, maxrank, do_pole_checks\n    implicit none\n    character(len=*), intent(in) :: libname\n    character(len=*), intent(in) :: proc\n    integer, intent(in) :: content, amptype, n_in\n    integer, intent(in), optional :: pol(:)\n    integer, intent(in), optional :: perm(:)\n    integer, intent(in), optional :: extid(:)\n    integer, intent(in), optional :: photon_id(:)\n    integer, intent(in), optional :: qcd_powers(2)\n    type(c_ptr) :: lib\n    logical :: same_perm, same_pol, same_photon_id\n    integer :: register_process_lib\n    integer :: j, k\n    type(process_handle) :: prochandle\n    type(process_handle), allocatable :: process_handles_bak(:)\n\n    lib = dlopen(libname, RTLD_LAZY, 2)\n    prochandle = get_process_handle(lib, libname, proc, content, amptype, n_in, perm=perm, pol=pol, &\n                                                   & extid=extid, photon_id=photon_id, qcd_powers=qcd_powers)\n\n    if (error > 1) return\n    ! Check if the process was registered before with the same permutation, polarization and amptype.\n    ! If yes, return the previously assigned id\n    do k = 1, last_process_id\n      if ((trim(proc) /= trim(process_handles(k)%process_name)) .or. &\n        & (trim(libname) /= trim(process_handles(k)%library_name)) ) then\n        cycle\n      end if\n      if (present(perm)) then\n        same_perm = all(perm == process_handles(k)%permutation)\n      else\n        ! perm not present means 1,2,..,n\n        same_perm = all(process_handles(k)%permutation == [(j, j=1, process_handles(k)%n_particles)])\n      end if\n      if (present(pol)) then\n        same_pol = all(pol == process_handles(k)%pol)\n      else\n        same_pol = all(process_handles(k)%pol == 0)\n      end if\n      if (present(photon_id)) then\n        same_photon_id = all(photon_id == process_handles(k)%photon_id)\n      else\n        same_photon_id = all(process_handles(k)%photon_id == 0)\n      end if\n      if (same_perm .and. &\n        & same_pol .and. &\n        & same_photon_id .and. &\n        & (amptype == process_handles(k)%amplitude_type) ) then\n        register_process_lib = k\n        return\n      end if\n    end do\n    if (.not. allocated(process_handles)) then\n      allocate(process_handles(1))\n    end if\n    if (last_process_id == size(process_handles)) then\n      allocate(process_handles_bak(last_process_id))\n      process_handles_bak = process_handles\n      deallocate(process_handles)\n      allocate(process_handles(2*last_process_id))\n      process_handles(1:last_process_id) = process_handles_bak\n      deallocate(process_handles_bak)\n    end if\n    last_process_id = last_process_id + 1\n    process_handles(last_process_id) = prochandle\n    if (maxpoint < process_handles(last_process_id)%max_point) then\n      call set_parameter(\"maxpoint\",process_handles(last_process_id)%max_point)\n    end if\n    if (maxrank < process_handles(last_process_id)%tensor_rank) then\n      call set_parameter(\"maxrank\",process_handles(last_process_id)%tensor_rank)\n    end if\n    register_process_lib = last_process_id\n\n    if (do_pole_checks) call check_poles(register_process_lib)\n  end function register_process_lib\n\n\n  subroutine unregister_processes()\n    ! Close all process libraries and nullify process handles.\n    use ol_dlfcn, only: dlclose\n    implicit none\n    integer :: id\n    do id = 1, last_process_id\n      call dlclose(process_handles(id)%library_handle)\n      process_handles(id)%n_particles = 0\n      process_handles(id)%content = 0\n      if (allocated(process_handles(id)%permutation)) deallocate(process_handles(id)%permutation)\n      if (allocated(process_handles(id)%pol)) deallocate(process_handles(id)%pol)\n      if (allocated(process_handles(id)%extid)) deallocate(process_handles(id)%extid)\n      if (allocated(process_handles(id)%masses)) deallocate(process_handles(id)%masses)\n      process_handles(id)%library_handle = c_null_ptr\n      process_handles(id)%set_permutation => null()\n      process_handles(id)%tree => null()\n      process_handles(id)%loop => null()\n      process_handles(id)%ct => null()\n      process_handles(id)%pt => null()\n      process_handles(id)%schsf => null()\n    end do\n    if (allocated(process_handles)) deallocate(process_handles)\n    last_process_id = 0\n  end subroutine unregister_processes\n\n\n  function register_process_string(process_in, amptype)\n    ! process: string with format 2->n-2\n    ! amptype: integer 1,2,3,4,11,12\n    ! return (integer) process id to be used in evaluate_process\n    use KIND_TYPES, only: DREALKIND\n    use ol_generic, only: to_int, string_to_integerlist, count_substring, to_string, to_lowercase\n    use ol_parameters_decl_/**/DREALKIND, only: &\n      & install_path,flavour_mapping_on, coupling_qcd, coupling_ew, &\n      & write_shopping_list, add_associated_ew, loop_order_ew, loop_order_qcd, &\n      & check_collection, partial_normal_order\n    implicit none\n    character(len=*), intent(in) :: process_in\n    integer, intent(in) :: amptype\n    integer :: register_process_string\n    character(len=max_parameter_length) :: tmp\n    character(len=max_parameter_length) :: inp, outp\n    character(len=max_parameter_length) :: process, proc, libhandle, permstring\n    integer :: librarytype\n    integer:: check\n    integer :: n_in, n_out\n    type(extparticle), allocatable :: ext(:)\n    integer, allocatable :: perm(:)\n    integer, allocatable :: pol(:)\n    integer, allocatable :: extid(:)\n    integer, allocatable :: photon_id(:)\n    integer :: coupling_ew_bak(0:1), coupling_qcd_bak(0:1)\n    integer :: loop_order_ew_bak, loop_order_qcd_bak\n    logical :: check_collection_bak\n    integer :: associated_ew, replace_loop = 0\n    integer :: i\n    logical :: decay = .false.\n    character(len=max_parameter_length) :: outstring\n\n    call parameters_flush() ! make sure that pid_string is set\n    register_process_string = -1\n\n    call get_environment_variable(\"OpenLoopsPath\", tmp)\n    if (len_trim(tmp) /= 0) then\n      call set_parameter(\"install_path\", tmp, error)\n    end if\n\n    call ol_msg(3,\"registering process: \" // trim(process_in) )\n\n    ! process: in -> out\n    if (index(process_in, \">\") > 0) then\n\n      if (index(process_in, \"->\") > 0) then\n        inp = adjustl(trim(process_in(1:index(process_in, \"->\")-1)))\n        outp = adjustl(process_in(index(process_in, \"->\")+2:len(process_in)))\n      else\n        inp = adjustl(trim(process_in(1:index(process_in, \">\")-1)))\n        outp = adjustl(process_in(index(process_in, \">\")+1:len(process_in)))\n      end if\n\n      n_in = size(process_to_extparticlelist(inp))\n      n_out = size(process_to_extparticlelist(outp))\n      if (error > 0 .or. n_in == 0 .or. n_out == 0 .or. n_in+n_out < 3) then\n        call ol_error(\"register_process: invalid argument: \" // trim(process_in) )\n      end if\n      allocate (ext(n_in+n_out))\n      ext(1:n_in) = process_to_extparticlelist(inp, .true.)\n      ext(n_in+1:) = process_to_extparticlelist(outp, .false.)\n\n      ! check for unresolved/on-/off-shell photons\n      allocate (photon_id(size(ext)))\n      call check_photon_id(ext, photon_id)\n\n      ! charge conjugate final state particles\n      call charge_conj(ext)\n\n      ! flavour mapping\n      if (flavour_mapping_on > 0) then\n        call flavour_mapping(ext, flavour_mapping_on)\n      end if\n\n      ! determine normal ordering\n      allocate (perm(size(ext)))\n      allocate (extid(size(ext)))\n      proc=\"\"\n      if(partial_normal_order) then\n        call normal_order(ext(:n_in), perm(:n_in), extid(:n_in), proc)\n        call normal_order(ext(n_in+1:), perm(n_in+1:), extid(n_in+1:), proc)\n        perm(n_in+1:)=perm(n_in+1:)+n_in\n      else\n        call normal_order(ext, perm, extid, proc)\n      end if\n\n      if (proc == \"\") then\n        call ol_error(\"register_process: invalid argument: \" // trim(process_in))\n        return\n      end if\n\n      ! permute polarization states\n      allocate (pol(size(ext)))\n      do i=1, size(ext)\n        pol(perm(i)) = ext(i)%pol\n      end do\n\n      call ol_msg(3,\"check process library for: \" // trim(proc) // \", \" // to_string([(ext(i)%id,i=1,size(ext))]))\n\n      if (amptype == 99 .or. write_shopping_list ) then ! write shopping list\n        ! charge conjugate back final state particles to write shopping list\n        call charge_conj(ext)\n        register_process_string = write_shop_list(ext, proc)\n      else\n\n        ! find process\n        register_process_string = loop_over_libraries(proc, amptype, n_in, perm, pol, extid, process_in, photon_id)\n\n        coupling_ew_bak  = coupling_ew\n        coupling_qcd_bak  = coupling_qcd\n        loop_order_ew_bak = loop_order_ew\n        loop_order_qcd_bak = loop_order_qcd\n\n        ! for >4q processes: if not found directly try to load tree and loop\n        ! amplitudes from different libraries.\n        if (register_process_string < 0 .and.  nextpid(ext,[1,2,3,4,5,6]) .ge. 4) then\n         if (amptype > 10 .and. coupling_ew(0) /= -1 &\n                          .and. (coupling_ew(1) == -1 .or. coupling_ew(1) == 0) &\n                          .and. (coupling_qcd(1) == -1  .or. coupling_qcd(1) == 1)) then\n            replace_loop = loop_over_libraries(proc, 1, n_in, perm, pol, extid, process_in, photon_id)\n            if (replace_loop > 0) then\n              loop_order_ew = coupling_ew(0)\n              coupling_ew = -1\n              coupling_qcd = -1\n            end if\n          else if (amptype > 10 .and. coupling_qcd(0) /= -1 &\n                                .and. (coupling_qcd(1) == -1 .or. coupling_qcd(1) == 0) &\n                                .and. (coupling_ew(1) == -1  .or. coupling_ew(1) == 1)) then\n            replace_loop = loop_over_libraries(proc, 1, n_in, perm, pol, extid, process_in, photon_id)\n            if (replace_loop > 0) then\n              loop_order_qcd = coupling_qcd(0)\n              coupling_ew = -1\n              coupling_qcd = -1\n            end if\n          end if\n\n          ! interference born -> squared born (for 4q processes)\n          if (replace_loop > 0) then\n            register_process_string = loop_over_libraries(proc, amptype, n_in, perm, pol, extid, process_in, photon_id)\n            if (register_process_string /= -1) then\n              process_handles(replace_loop)%replace_loop=register_process_string\n              register_process_string = replace_loop\n            end if\n          end if\n        end if\n\n        ! register associate ew one-loop amplitude\n        if (register_process_string > 0 .and. abs(add_associated_ew) > 0 .and. coupling_ew(1) == 0 ) then\n          coupling_ew(1) = 1\n          coupling_qcd(1) = 0\n          associated_ew = loop_over_libraries(proc, amptype, n_in, perm, pol, extid, process_in, photon_id)\n          process_handles(register_process_string)%associated_ew = associated_ew\n        end if\n\n        ! register associate qcd-ew born amplitudes\n        if (register_process_string > 0 .and. abs(add_associated_ew) > 1) then\n          check_collection_bak = check_collection\n          check_collection=.false.\n          if (coupling_ew_bak(0) > -1) then\n            coupling_ew(0) = coupling_ew_bak(0)+1\n            coupling_qcd(0) = -1\n          else if (coupling_qcd_bak(0) > -1) then\n            coupling_ew(0) = -1\n            coupling_qcd(0) = coupling_qcd_bak(0)-1\n          else\n            call ol_error(\"associate ew order selection not valid.\")\n          end if\n          associated_ew = loop_over_libraries(proc, 1, n_in, perm, pol, extid, process_in, photon_id)\n          process_handles(register_process_string)%associated_born_1= associated_ew\n        end if\n\n        if (register_process_string > 0 .and. abs(add_associated_ew) > 2) then\n          if (coupling_ew_bak(0) > -1) then\n            coupling_ew(0) = coupling_ew_bak(0)+2\n            coupling_qcd(0) = -1\n          else if (coupling_qcd_bak(0) > -1) then\n            coupling_ew(0) = -1\n            coupling_qcd(0) = coupling_qcd_bak(0)-2\n          else\n            call ol_error(\"associate ew order selection not valid.\")\n          end if\n          associated_ew = loop_over_libraries(proc, 1, n_in, perm, pol, extid, process_in, photon_id)\n          process_handles(register_process_string)%associated_born_2= associated_ew\n        end if\n\n        loop_order_ew = loop_order_ew_bak\n        loop_order_qcd = loop_order_qcd_bak\n        coupling_ew  = coupling_ew_bak\n        coupling_qcd  = coupling_qcd_bak\n        check_collection=check_collection_bak\n\n     end if\n\n     if (register_process_string < 1) then ! process not found\n       outstring = adjustl(\"register_process: process \" // trim(process_in))\n       outstring = trim(outstring) // \" @\" // \" tree=\"\n       if (coupling_ew(0) > -1) then\n         outstring = trim(outstring) // trim(to_string(coupling_ew(0))) // \",\"\n       else\n         outstring = trim(outstring) // \"?,\"\n       end if\n       if (coupling_qcd(0) > -1) then\n         outstring = trim(outstring) // trim(to_string(coupling_qcd(0)))\n       else\n         outstring = trim(outstring) // \"?\"\n       end if\n       if (amptype > 10) then\n          outstring = trim(outstring) // \" loop=\"\n          if (coupling_ew(1) > -1) then\n            outstring = trim(outstring) // trim(to_string(coupling_ew(0)+coupling_ew(1))) // \",\"\n          else if (loop_order_ew > -1) then\n            outstring = trim(outstring) // trim(to_string(loop_order_ew)) // \",\"\n          else\n            outstring = trim(outstring) // \"?,\"\n          end if\n          if (coupling_qcd(1) > -1) then\n            outstring = trim(outstring) // trim(to_string(coupling_qcd(0)+coupling_qcd(1)))\n          else if (loop_order_qcd > -1) then\n            outstring = trim(outstring) // trim(to_string(loop_order_qcd))\n          else\n            outstring = trim(outstring) // \"?\"\n          end if\n       end if\n       outstring = trim(outstring) // \" (EW,QCD) not found!\"\n       call ol_msg(outstring)\n     end if\n\n    else ! direct library loader\n\n      ! read permutation\n      permstring =  process_in(index(process_in, '[')+1:index(process_in, ']')-1)\n      if (len_trim(permstring) /= 0) then\n        allocate(perm(size(string_to_integerlist(permstring))))\n        perm = string_to_integerlist(permstring)\n        libhandle = process_in(:index(process_in,\"[\")-1)\n      else\n        libhandle = trim(process_in)\n      end if\n\n      !register\n      librarytype = 0\n      do\n        if (allocated(perm)) then\n          register_process_string =  check_process(libhandle, amptype, librarytype, 2, perm_in=perm)\n          if (error > 1) return\n        else\n          register_process_string =  check_process(libhandle, amptype, librarytype, 2)\n          if (error > 1) return\n        end if\n        if (register_process_string > 0) then ! found & registered\n          exit\n        else if (register_process_string == 0) then ! look in next library type\n          librarytype = librarytype + 1\n        else\n          call ol_msg(\"register_process: library \" // trim(libhandle) // \" not found!\")\n          exit\n        end if\n      end do\n\n    end if\n\n    !deallocate\n    if (allocated(ext)) deallocate(ext)\n    if (allocated(perm)) deallocate(perm)\n    if (allocated(pol)) deallocate(pol)\n    if (allocated(photon_id)) deallocate(photon_id)\n  contains\n\n  subroutine charge_conj(x)\n    ! determine charge conjugate of array x(3:)\n    implicit none\n    type(extparticle), intent(inout)     :: x(:)\n    integer :: i\n\n    do i=1,size(x)\n      if (.not. x(i)%is_initial) then\n        select case(x(i)%id)\n        case(0, 21, 22, 23, 25, 35, 36)\n          x(i)%id  = x(i)%id\n        case default\n          x(i)%id = -x(i)%id\n        end select\n      end if\n    end do\n  end subroutine charge_conj\n\n  function nextpid(ext,pids)\n      use KIND_TYPES, only: DREALKIND\n      implicit none\n      type(extparticle), intent(in) :: ext(:)\n      integer, intent(in) :: pids(:)\n      integer nextpid, i, j\n      nextpid=0\n      do i=1,size(ext)\n        do j=1,size(pids)\n          if (abs(ext(i)%id) == abs(pids(j))) nextpid=nextpid+1\n        end do\n      end do\n  end function nextpid\n\n  subroutine check_photon_id(ext,photon_id)\n    implicit none\n    type(extparticle), intent(inout) :: ext(:)\n    integer, intent(out) :: photon_id(:)\n    integer i\n    photon_id=0\n    do i=1,size(ext)\n      if (abs(ext(i)%id) == 2002) then\n        if (ext(i)%id == 2002) then ! on-shell photon\n          if (ext(i)%is_initial) then\n            photon_id(i)=1  ! on-shell initial-state photon\n          else\n            photon_id(i)=2  ! on-shell final-state photon\n          end if\n        else\n          if (ext(i)%is_initial) then\n            photon_id(i)=-1  ! off-shell initial-state photon\n          else\n            photon_id(i)=-2  ! off-shell final-state photon\n          end if\n        end if\n        ext(i)%id = 22\n      end if\n    end do\n  end subroutine check_photon_id\n\n  subroutine normal_order(ext, perm, extid, proc)\n      use KIND_TYPES, only: DREALKIND\n      implicit none\n      type(extparticle), intent(in) :: ext(:)\n      integer, intent(out) :: perm(:)\n      integer, intent(out) :: extid(:)\n      character(len=*), intent(inout) :: proc\n      integer :: i,j, normal(35), pos\n      character(len=3) :: normalc(35)\n      logical :: do_normal_order = .true.\n\n      ! define normal ordering and corresponding characters\n\n      ! SM\n      normal(  1:10) = [ 12  ,-12  , 14  ,-14  , 16  ,-16  , 11  ,-11  , 13  ,-13  ]\n      normalc( 1:10) = [\"ne \",\"nex\",\"nm \",\"nmx\",\"nl \",\"nlx\",\"e  \",\"ex \",\"m  \",\"mx \"]\n\n      normal( 11:20) = [ 15  ,-15  ,  2  , -2  ,  4  , -4  ,  6  , -6  ,  1  , -1  ]\n      normalc(11:20) = [\"l  \",\"lx \",\"u  \",\"ux \",\"c  \",\"cx \",\"t  \",\"tx \",\"d  \",\"dx \"]\n\n      normal( 21:30) = [  3  , -3  ,  5  , -5  , 25  , 35  , 36  , 37  ,-37  , 22  ]\n      normalc(21:30) = [\"s  \",\"sx \",\"b  \",\"bx \",\"h  \",\"h0 \",\"a0 \",\"hp \",\"hpx\",\"a  \"]\n\n      normal( 31:35) = [ 23  , -24 , 24  , 21  ,  0  ]\n      normalc(31:35) = [\"z  \",\"w  \",\"wx \",\"g  \",\"g  \"]\n\n      perm = 0\n\n      if(do_normal_order) then\n        ! normal order, build string and store permutation\n        pos = 1\n        do i = 1, size(normal)\n          do j = 1, size(ext)\n            if (ext(j)%id == normal(i)) then\n              proc = trim(proc) // trim(normalc(i))\n              perm(j) = pos\n              extid(j) = ext(j)%id\n              pos = pos + 1\n            end if\n          end do\n        end do\n        if (pos-1 /= size(ext)) then\n          proc = \"\"\n        end if\n      else\n        ! build string, no normal ordering, no permutation\n        do j = 1, size(ext)\n          do i = 1, size(normal)\n            if (ext(j)%id == normal(i)) then\n              proc = trim(proc) // trim(normalc(i))\n              cycle\n            end if\n          end do\n          extid(j) = ext(j)%id\n          perm(j) = j\n        end do\n      end if\n\n  end subroutine normal_order\n\n  function loop_over_libraries(proc, amptype, n_in, perm, pol, extid, process_in, photon_id)\n  use ol_parameters_decl_/**/DREALKIND, only: check_collection\n  ! loop over library types\n    use KIND_TYPES, only: DREALKIND\n    use ol_parameters_decl_/**/DREALKIND, only: coupling_qcd, coupling_ew, OLMode\n    implicit none\n    character(len=max_parameter_length), intent(in) :: proc\n    integer, intent(in) :: amptype, n_in\n    integer, intent(in), optional :: perm(:)\n    integer, intent(in), optional :: pol(:)\n    integer, intent(in), optional :: extid(:)\n    character(len=*), intent(in), optional :: process_in\n    integer, intent(in), optional :: photon_id(:)\n    integer loop_over_libraries\n    integer librarytype, loop_olmode, check\n\n    loop_over_libraries = -1\n    librarytype = 0\n    LoopLibrarytype: do\n      if (OLMode == -1) then\n        LoopOLMode: do loop_olmode = 3, 0, -1\n          check = check_process(proc, amptype, librarytype, n_in, &\n                  olmode=loop_olmode, perm_in=perm, pol=pol, extid=extid, process_string=process_in, photon_id=photon_id)\n          if (error > 1) return\n          if (check > 0) exit LoopOLMode\n        end do LoopOLMode\n      else\n        check = check_process(proc, amptype, librarytype, n_in, &\n                olmode=OLMode, perm_in=perm, pol=pol, extid=extid, process_string=process_in, photon_id=photon_id)\n        if (error > 1) return\n      end if\n      if (check > 0) then ! found & registered\n        loop_over_libraries = check\n        exit Looplibrarytype\n      else if (check == 0) then ! look in next library type\n        librarytype = librarytype + 1\n      else\n        exit Looplibrarytype\n      end if\n    end do Looplibrarytype\n\n    if (check == -1 .and. check_collection) then  ! not found --> check collections\n      check = check_process(proc, 999, librarytype, n_in, perm_in=perm, pol=pol, extid=extid, process_string=process_in)\n      if (error > 1) return\n    end if\n\n  end function loop_over_libraries\n\n  end function register_process_string\n\n\n  function register_process_id(ext, amptype, n_in_in)\n    ! ext: array with format [in_1, .. , in_n_in, out_1, .. , out_n_out]\n    ! amptype: integer 1,2,3,4,11,12\n    ! (optional) n_in_in: number of initial state particles, default=2\n    ! return (integer) process id to be used in evaluate_process\n    use ol_generic, only: to_string\n    implicit none\n    integer, intent(in) :: ext(:)\n    integer, intent(in) :: amptype\n    integer, optional, intent(in) :: n_in_in\n    integer :: register_process_id\n    character(len=max_parameter_length) :: process\n    integer :: n_in, i\n    if (present(n_in_in)) then\n      n_in = n_in_in\n    else\n      n_in = 2\n    end if\n    process = to_string(ext(1:n_in),.false., \" \")\n    process = trim(process) //  \" -> \" // to_string(ext(n_in+1:),.false., \" \")\n    register_process_id = register_process_string(process, amptype)\n  end function register_process_id\n\n\n  function check_process(proc_in, amptype, librarytype, n_in, olmode, perm_in, pol, extid, process_string, photon_id)\n  ! 1: found, 0: not found, -1: abort\n    use KIND_TYPES, only: DREALKIND\n    use ol_parameters_decl_/**/DREALKIND, only: &\n      & install_path, rMB, rMC, &\n      & allowed_libs, tmp_dir, auto_preset, apicheck\n    use ol_generic, only: to_string, to_lowercase, count_substring, string_to_integerlist\n    use ol_loop_parameters_decl_/**/DREALKIND, only: stability_mode,a_switch,a_switch_rescue,redlib_qp, &\n    use_bubble_vertex\n    use ol_version, only: process_api\n    implicit none\n    character(len=max_parameter_length), intent(in) :: proc_in\n    integer, intent(in) :: amptype, librarytype, n_in\n    integer, intent(in), optional :: olmode\n    integer, intent(in), optional :: perm_in(:)\n    integer, intent(in), optional :: pol(:)\n    integer, intent(in), optional :: extid(:)\n    character(len=*), intent(in), optional :: process_string\n    integer, intent(in), optional :: photon_id(:)\n    integer, allocatable :: perm(:)\n    integer, allocatable :: select_pol(:)\n    integer check_process\n    integer :: lib_content\n    integer, save :: info_files_read = 0\n    integer :: readok, ierrg\n    integer :: i, j, p, p_unmapped\n    integer, save :: max_out_length = 35\n    logical :: found, found_condmap\n    logical :: is_already_loaded, only_loaded\n    character(len=4) :: loops_specification\n    character(len=4) :: lib_specification\n    character(len=max_parameter_length) :: proc, libfilename, libhandle, libname\n    character(len=max_parameter_length) :: map_libname\n    character(len=max_parameter_length) :: procunmapped, proclastmapped\n    character(len=max_parameter_length) :: mapping_str\n    character(len=max_parameter_length) :: outstring\n\n    check_process = -1\n    found = .false.\n    check_process = 0\n    map_libname = ' '\n    mapping_str = ' '\n    if (present(perm_in)) then\n      allocate(perm(size(perm_in)))\n      perm = perm_in\n    end if\n\n    if (.not. check_proclib_exists()) then\n      check_process = -2\n      return\n    end if\n\n    ! read all info files\n    if (info_files_read < 1) then\n      call readAllInfoFiles()\n      if (error /= 0)  then\n        check_process = -2\n        return\n      end if\n      info_files_read = 1\n    end if\n\n    only_loaded = .false.\n    ! set loops_specification\n    select case (amptype)\n      case (1,2,3,4) ! tree-like\n        loops_specification = \"t\"\n        if (librarytype == 0) then\n          lib_specification = \"lt\"\n          only_loaded = .true.\n        else if (librarytype == 1) then\n          lib_specification = \"t\"\n        else if (librarytype == 2) then\n          lib_specification = \"lt\"\n        else if (librarytype == 3) then\n          lib_specification = \"lpt\"\n        else if (librarytype == 4) then\n          lib_specification = \"lst\"\n        else if (librarytype == 5) then\n          lib_specification = \"lpst\"\n        else\n          check_process = -1\n          return\n        end if\n      case (11) ! loop\n        loops_specification = \"l\"\n        if (librarytype == 0) then\n          lib_specification = \"lt\"\n        else if (librarytype == 1) then\n          lib_specification = \"l\"\n        else if (librarytype == 2) then\n          lib_specification = \"lp\"\n        else if (librarytype == 3) then\n          lib_specification = \"lst\"\n        else if (librarytype == 4) then\n          lib_specification = \"lpt\"\n        else if (librarytype == 5) then\n          lib_specification = \"lpst\"\n        else\n          check_process = -1\n          return\n        end if\n      case (12) ! loop-induced\n        loops_specification = \"s\"\n        if (librarytype == 0) then\n          lib_specification = \"ls\"\n        else if (librarytype == 1) then\n          lib_specification = \"lst\"\n        else if (librarytype == 2) then\n          lib_specification = \"lps\"\n        else if (librarytype == 3) then\n          lib_specification = \"lpst\"\n        else\n          check_process = -1\n          return\n        end if\n      case (999) ! check libraries\n        lib_specification = \"lib\"\n        loops_specification = \"\"\n        if (info_files_read < 2) then\n          call readAllInfoFiles(.true.)\n            if (error /= 0)  then\n              check_process = -2\n              call ol_msg(\"Error: no process libraries installed.\")\n              return\n            end if\n            info_files_read = 2\n        end if\n      case default\n        call ol_msg(\"register_process: amplitude type not supported: \" // to_string(amptype))\n        check_process = -2\n    end select\n\n    ! find process\n      proc = proc_in\n      p = 0\n      p_unmapped = 0\n      procunmapped = proc\n      InfoLoop: do\n        p = p+1\n        if (p > size(process_infos)) then\n          if ( len_trim(map_libname) /= 0 ) then\n            map_libname = ' '\n            mapping_str = ' '\n            proc = procunmapped\n            p = p_unmapped\n            if (allocated(perm)) then\n              perm = perm_in\n            end if\n            cycle\n          else\n            exit\n          end if\n        end if\n\n         !process loader\n        if (index(proc_in,\"_\") == 0) then\n\n          libname = trim(process_infos(p)%LIBNAME)\n\n          !check if library is \"allowed\"\n          if (len_trim(allowed_libs) /= 0 &\n            .and. index(allowed_libs, \" \" // trim(libname) // \" \") == 0) cycle InfoLoop\n\n          !check if correct mappings\n          if (len_trim(map_libname) /= 0 &\n            .and. trim(map_libname) /= trim(libname)) cycle InfoLoop\n          p_unmapped = p\n\n          ! check correct process\n          if ( trim(proc) /= trim(process_infos(p)%PROC) &\n            & .or. trim(lib_specification) /= trim(process_infos(p)%LTYPE) &\n            & .or. index(trim(process_infos(p)%TYPE), trim(loops_specification)) == 0 &\n            & ) cycle InfoLoop\n\n          !follow mapping\n          if(len_trim(process_infos(p)%MAP) /= 0) then\n            !check for conditional mappings\n            call check_parameters_condmap(p, found_condmap)\n            if (found_condmap) then\n              proclastmapped = proc\n              proc = trim(process_infos(p)%MAP)\n              call ol_msg(2, \"Following info-file mapping: \" // trim(proclastmapped) // &\n                          \" --> \" // trim(process_infos(p)%MAP) // \"[\" // trim(process_infos(p)%MAPPERM) // \"].\")\n              !map permutation\n              if(len_trim(process_infos(p)%MAPPERM) /= 0) then\n                if (allocated(perm)) then\n                  call map_permutation(perm,string_to_integerlist(process_infos(p)%MAPPERM))\n                  if (error > 1) return\n                end if\n              end if\n              mapping_str = \" (mapped from \" // trim(procunmapped) // \")\"\n              map_libname = libname\n              p = 0\n              cycle InfoLoop\n            else\n              call ol_msg(2, \"Not following mapping \" // trim(proc) // \" --> \" // trim(process_infos(p)%MAP) // \".\")\n              cycle InfoLoop\n            end if\n          end if\n\n          ! get library filename\n          if (amptype == 999) then\n            libfilename = \"collection \" // trim(process_infos(p)%LIBNAME)\n          else\n            libfilename = 'libopenloops_' // trim(process_infos(p)%LIBNAME) // '_' // &\n                          & trim(process_infos(p)%LTYPE) // '.' // dynlib_extension\n          end if\n\n          if (allocated(select_pol)) deallocate(select_pol)\n          allocate(select_pol(size(pol)))\n          select_pol = pol\n\n          ! check OLmode\n          if (present(OLMode)) then\n            if (process_infos(p)%OLMode /= OLMode) cycle InfoLoop\n          end if\n\n          ! check parameters\n          call check_parameters(p,amptype,found)\n\n        ! direct library loader\n        else if (index(proc_in,\"_\") > 0) then\n          libhandle = proc_in\n          libname = proc_in(:index(proc_in(:index(proc_in,\"_\",.true.)-1),\"_\",.true.)-1)\n          proc = proc_in(index(proc_in(:index(proc_in,\"_\",.true.)-1),\"_\",.true.)+1:index(proc_in,\"_\",.true.)-1)\n          if ( trim(proc) /= trim(process_infos(p)%PROC) .or. &\n            &  trim(libname) /= trim(process_infos(p)%LIBNAME) .or. &\n            &  trim(lib_specification) /= trim(process_infos(p)%LTYPE) .or. &\n            &  index(trim(process_infos(p)%TYPE), trim(loops_specification)) == 0 .or. &\n            &  proc_in(index(proc_in,\"_\",.true.)+1:) /=  trim(process_infos(p)%ID) &\n            & ) cycle InfoLoop\n          if (apicheck .and. process_api /= process_infos(p)%API) cycle InfoLoop\n          libfilename = 'libopenloops_' // trim(libname) // '_' // &\n                           & trim(lib_specification) // '.' // dynlib_extension\n          found = .true.\n          exit InfoLoop\n        else\n          call ol_error(\"register_process: process format not supported.\")\n          check_process = -2\n          return\n        end if\n\n\n        !if required, check if library is already loaded\n        if (only_loaded) then\n          is_already_loaded = .false.\n          if (allocated(loaded_libs)) then\n            do j = 1, size(loaded_libs)\n              if (trim(loaded_libs(j)%LIBNAME) == trim(libname)  &\n                & .and. index(trim(loaded_libs(j)%TYPE), trim(loops_specification)) > 0 &\n                &  ) then\n                  is_already_loaded = .true.\n              end if\n            end do\n          end if\n          if (.not. is_already_loaded) found = .false.\n        end if\n\n        ! found correct library\n        if (found) then\n          call ol_msg(2, \"Parameters do match info-file for process \" // trim(proc) // \" in library \" // trim(libfilename))\n          if (amptype == 999) then\n            if (present(process_string)) then\n              call ol_msg(\"Library for \" // trim(process_string) // \" not installed but available in: \" // trim(libname))\n            else\n              call ol_msg(\"Library for \" // trim(proc) // \" not installed but available in: \" // trim(libname))\n            end if\n            call ol_msg(\"Note: this library can be downloaded and installed via\")\n            call ol_msg(\"$ cd \" // trim(install_path))\n            call ol_msg(\"$ ./openloops libinstall \" // trim(libname))\n            check_process = 1\n            return\n          end if\n          libhandle = trim(to_lowercase(libname)) // \"_\" // trim(proc) // \"_\" // trim(process_infos(p)%ID)\n          exit\n        else\n          call ol_msg(2,\"Parameters do not match info-file for process \" //  &\n                      trim(proc) // \"_\" // trim(process_infos(p)%ID) // \" in library \" // trim(libname))\n          check_process = 0\n        end if\n\n      end do InfoLoop\n\n    if (found) then\n        libfilename = trim(install_path) // '/proclib/' // libfilename\n        lib_content = 0\n        do i = 1, len(loops_flags)\n          if (index(trim(process_infos(p)%TYPE), loops_flags(i:i)) > 0) lib_content = ibset(lib_content, i-1)\n        end do\n\n        if(process_infos(p)%OLMode .le. 0) call set_if_modified(use_bubble_vertex, 0)\n\n        if(auto_preset) then\n          if (process_infos(p)%OLMode .ge. 2) then\n            call set_if_modified(a_switch,1)\n            call set_if_modified(stability_mode,11)\n          else\n            if (amptype == 12) then\n              call set_if_modified(a_switch,1)\n              call set_if_modified(a_switch_rescue,7)\n              call set_if_modified(stability_mode,21)\n            else\n               if(process_infos(p)%MODEL==\"heft\") then\n                 call set_if_modified(a_switch,5)\n                 call set_if_modified(redlib_qp,5)\n                 call set_if_modified(stability_mode,14)\n               else\n                 call set_if_modified(a_switch,1)\n                 call set_if_modified(a_switch_rescue,7)\n                 call set_if_modified(redlib_qp,5)\n                 call set_if_modified(stability_mode,23)\n               end if\n            end if\n          end if\n        end if\n\n        !register\n        check_process = register_process_lib(libfilename, libhandle, lib_content, amptype, &\n                              & n_in, perm=perm, pol=select_pol, extid=extid, photon_id=photon_id, &\n                              & qcd_powers=process_infos(p)%qcdorder)\n        if (error > 1) then\n          call ol_error(\"register_process_lib failed\")\n          check_process = -2\n          return\n        end if\n\n        if (present(process_string)) then\n          outstring = \"Library loaded: \" //  trim(process_string)\n        else\n          outstring = \"Library loaded: \" //  trim(proc)\n        end if\n        outstring = adjustl(outstring)\n        if (len_trim(outstring) > max_out_length) max_out_length = len_trim(outstring)\n        outstring = outstring(1:max_out_length) // \" @\" // &\n          & \" tree=\" // trim(to_string(process_infos(p)%EWorder(0)))  // \",\" // &\n          & trim(to_string(process_infos(p)%QCDorder(0)))\n        if (amptype > 10) then\n          outstring = trim(outstring) // &\n          & \" loop=\" // trim(to_string(process_infos(p)%EWorder(0)+process_infos(p)%EWorder(1))) // \",\" // &\n          & trim(to_string(process_infos(p)%QCDorder(0)+process_infos(p)%QCDorder(1)))\n        end if\n          outstring = trim(outstring) // \" (EW,QCD) >  \" // trim(libhandle)\n        if (allocated(perm)) then\n          outstring = trim(outstring) //  trim(to_string(perm,.true.))\n        end if\n        outstring = trim(outstring) // \" (id=\" // trim(to_string(check_process)) // \")\"\n        outstring = trim(outstring) // trim(mapping_str)\n        call ol_msg(1,outstring)\n\n        !add to list of loaded libraries\n        call add_loaded_library(process_infos(p))\n\n    end if\n\n\n    if (allocated(perm)) deallocate(perm)\n    if (allocated(select_pol)) deallocate(select_pol)\n\n  contains\n\n    subroutine map_permutation(perm, map)\n    !map permutation\n      implicit none\n      integer, intent(inout) :: perm(:)\n      integer, intent(in) :: map(:)\n      integer  :: perm_tmp(size(perm))\n      integer :: i, x\n      if (size(perm) /= size(map)) then\n        call ol_fatal(\"error in map_permutation\")\n        return\n      end if\n      do i = 1, size(map)\n        perm_tmp(i) = map(perm(i))\n      end do\n      perm = perm_tmp\n    end subroutine map_permutation\n\n\n\n  end function check_process\n\n\n\n  function check_proclib_exists()\n  ! checks that proclib folder exists within set install_path\n    use ol_parameters_decl_/**/DREALKIND, only: install_path\n    implicit none\n    logical check_proclib_exists\n    logical proclib_exists\n#ifdef USE_GFORTRAN\n    inquire(file=trim(install_path)//\"/proclib/.\", exist=proclib_exists)\n#endif\n#ifdef USE_IFORT\n    inquire(directory=trim(install_path)//\"/proclib\", exist=proclib_exists)\n#endif\n    if (.not. proclib_exists) then\n      call ol_fatal(\"register_process: proclib folder not found, check install_path or install libraries.\")\n      check_proclib_exists = .false.\n      return\n    else\n      check_proclib_exists = .true.\n      return\n    end if\n  end function check_proclib_exists\n\n\n  subroutine check_parameters(p,amptype,found)\n    use ol_parameters_decl_/**/DREALKIND, only: &\n      & rME, rMM, rML, rMU, rMD, rMC, rMS, rMB, rMT, &\n      & rYE, rYM, rYL, rYU, rYD, rYC, rYS, rYB, rYT, &\n      & leadingcolour, coupling_qcd, coupling_ew, &\n      & loop_order_ew, loop_order_qcd, &\n      & approximation, CKMORDER, model, allowed_libs, apicheck\n    use ol_loop_parameters_decl_/**/DREALKIND , only: nf, nc\n    use ol_version, only: process_api\n    implicit none\n    integer, intent(in) :: p\n    integer, intent(in) :: amptype\n    logical, intent(out) :: found\n\n    found = .false.\n    if (allocated(process_infos)) then\n      if (size(process_infos) < p) then\n        call ol_error(1,\"check_parameters: process not available\")\n        return\n      end if\n      found = .true.\n\n      if (apicheck) call check(process_infos(p)%API == process_api, found, \"API version not ok.\")\n      if (trim(model) /= \"heft\") then\n        call check(process_infos(p)%EWorder(0) == coupling_EW(0) .or. coupling_EW(0) == -1, found, \"EW tree coupling NOT ok.\")\n        call check(amptype == 1 .or. process_infos(p)%eworder(1) == coupling_ew(1) &\n                  .or. coupling_ew(1) == -1, found, \"EW loop not ok.\")\n      end if\n      call check(process_infos(p)%qcdorder(0) == coupling_qcd(0) .or. coupling_qcd(0) == -1, found, \"qcd tree coupling not ok.\")\n      call check(amptype == 1  .or. process_infos(p)%qcdorder(1) == coupling_qcd(1) &\n                  .or. coupling_qcd(1) == -1, found, \"qcd loop not ok.\")\n      call check(loop_order_ew == -1 .or. process_infos(p)%eworder(0)+process_infos(p)%eworder(1) == loop_order_ew, &\n                     found, \"absolute ew loop not ok.\")\n       call check(loop_order_qcd == -1 .or. process_infos(p)%qcdorder(0)+process_infos(p)%qcdorder(1) == loop_order_qcd, &\n                     found, \"absolute qcd loop not ok.\")\n      call check(process_infos(p)%LeadingColour == leadingcolour, found, \"LeadingColour OK.\")\n      call check(process_infos(p)%NC == nc, found, \"nc NOT ok.\")\n      call check(process_infos(p)%NF == nf, found, \"nf NOT ok.\")\n      call check(process_infos(p)%CKMorder == CKMORDER, found, \"CKM NOT ok.\")\n      call check(index(process_infos(p)%MODEL, trim(model)) == 1, found, \"model NOT ok.\")\n      call check((process_infos(p)%ME /= \"0\" .and. rME /= 0) .or. rME == 0, found, \"mass ME NOT ok.\")\n      call check((process_infos(p)%MM /= \"0\" .and. rMM /= 0) .or. rMM == 0, found, \"mass MM NOT ok.\")\n      call check((process_infos(p)%ML /= \"0\" .and. rML /= 0) .or. rML == 0, found, \"mass ML NOT ok.\")\n      call check((process_infos(p)%MU /= \"0\" .and. rMU /= 0) .or. rMU == 0, found, \"mass MU NOT ok.\")\n      call check((process_infos(p)%MD /= \"0\" .and. rMD /= 0) .or. rMD == 0, found, \"mass MD NOT ok.\")\n      call check((process_infos(p)%MS /= \"0\" .and. rMS /= 0) .or. rMS == 0, found, \"mass MS NOT ok.\")\n      call check((process_infos(p)%MC /= \"0\" .and. rMC /= 0) .or. rMC == 0, found, \"mass MC NOT ok.\")\n      call check((process_infos(p)%MB /= \"0\" .and. rMB /= 0) .or. rMB == 0, found, \"mass MB NOT ok.\")\n      call check(rME == rYE  .or. process_infos(p)%YE == 1, found, \"YukE /= ME NOT ok.\")\n      call check(rMM == rYM  .or. process_infos(p)%YM == 1, found, \"YukM /= MM NOT ok.\")\n      call check(rML == rYL  .or. process_infos(p)%YL == 1, found, \"YukL /= ML NOT ok.\")\n      call check(rMU == rYU  .or. process_infos(p)%YU == 1, found, \"YukU /= MU NOT ok.\")\n      call check(rMD == rYD  .or. process_infos(p)%YD == 1, found, \"YukD /= MD NOT ok.\")\n      call check(rMS == rYS  .or. process_infos(p)%YS == 1, found, \"YukS /= MS NOT ok.\")\n      call check(rMC == rYC  .or. process_infos(p)%YC == 1, found, \"YukC /= MC NOT ok.\")\n      call check(rMB == rYB  .or. process_infos(p)%YB == 1, found, \"YukB /= MB NOT ok.\")\n      call check(rMT == rYT  .or. process_infos(p)%YT == 1, found, \"YukT /= YT NOT ok.\")\n      call check(amptype == 1 .or. amptype > 10 .or. process_infos(p)%CC /= \"0\", found, \"CC NOT ok.\")\n      call check(trim(process_infos(p)%APPROX) == trim(approximation), found, \"APPROX NOT ok.\")\n    end if\n\n  end subroutine check_parameters\n\n  subroutine check_parameters_condmap(p,found)\n    use ol_parameters_decl_/**/DREALKIND, only: &\n      & rME, rMM, rML, rMU, rMD, rMC, rMS, rMB\n    implicit none\n    integer, intent(in) :: p\n    logical, intent(out) :: found\n\n    found = .false.\n    if (allocated(process_infos)) then\n      if (size(process_infos) < p) then\n        call ol_error(1,\"check_parameters_mapping: process not available\")\n        return\n      end if\n      found = .true.\n      call check(.not. (process_infos(p)%ME == \"0\" .and. rME /= 0), found, \"mass ME NOT ok.\")\n      call check(.not. (process_infos(p)%MM == \"0\" .and. rMM /= 0), found, \"mass MM NOT ok.\")\n      call check(.not. (process_infos(p)%ML == \"0\" .and. rML /= 0), found, \"mass ML NOT ok.\")\n      call check(.not. (process_infos(p)%MU == \"0\" .and. rMU /= 0), found, \"mass MU NOT ok.\")\n      call check(.not. (process_infos(p)%MD == \"0\" .and. rMD /= 0), found, \"mass MD NOT ok.\")\n      call check(.not. (process_infos(p)%MS == \"0\" .and. rMS /= 0), found, \"mass MS NOT ok.\")\n      call check(.not. (process_infos(p)%MC == \"0\" .and. rMC /= 0), found, \"mass MC NOT ok.\")\n      call check(.not. (process_infos(p)%MB == \"0\" .and. rMB /= 0), found, \"mass MB NOT ok.\")\n    end if\n\n  end subroutine check_parameters_condmap\n\n  subroutine check(test,found,message)\n    implicit none\n    logical, intent(in) :: test\n    logical, intent(inout) :: found\n    character(len=*), intent(in) :: message\n    if (.not. test) then\n      found = .false.\n      call ol_msg(3,\"Library does not match: \" // trim(message))\n    end if\n  end subroutine\n\n  subroutine readAllInfoFiles(load_channel_lib)\n    use ol_parameters_decl_/**/DREALKIND, only: install_path\n    use iso_fortran_env, only: iostat_end\n    use ol_cwrappers, only: opendir, readdir, closedir\n    implicit none\n    logical, optional, intent(in) :: load_channel_lib\n    integer :: readok\n    integer, parameter :: gf_info = 994\n    integer :: counter,API\n    character(len=500) :: infofilename\n    character(len=500) :: infoline\n    character(len=5) :: info_file_suffix = 'info'\n    logical :: iqopen\n    type(processinfos) infos\n    type(processinfos), allocatable :: process_infos_bak(:)\n\n    if (present(load_channel_lib)) then\n      call ol_msg(1, \"Requested library not installed. Checking collection...\")\n      if (load_channel_lib) then\n        info_file_suffix = 'rinfo'\n      end if\n    end if\n\n    ! open proclib folder\n    readok = opendir(trim(install_path) // '/proclib')\n    if (readok /= 0) then\n      call ol_error('opening proclib directory failed. Check install_path.')\n      return\n    end if\n\n    ProclibDirLoop: do\n      readok = readdir(infofilename)\n      if (readok /= 0) then\n        call ol_error(\"reading proclib directory content failed.\")\n        exit\n      end if\n      if (len(trim(infofilename)) == 0) exit\n      if (index(trim(infofilename),\".\"//trim(info_file_suffix)) == 0) then\n        cycle\n      else\n        infofilename = trim(install_path) // \"/proclib/\" // trim(infofilename)\n      end if\n\n      inquire(gf_info, opened=iqopen)\n      if(iqopen) close(unit=gf_info)\n      open(gf_info, file=trim(infofilename), status = \"old\", iostat=readok)\n      if (readok /= 0) then\n        call ol_error(\"in readAllInfoFiles can't open file: \" // trim(infofilename) )\n        exit\n      end if\n      counter = 0\n      API = 1\n      InfoFileLoop: do\n        read (gf_info, '(A)', iostat=readok )  infoline\n        if (readok /= 0) then ! EOF -> exit\n          if (readok == iostat_end) then\n            exit InfoFileLoop\n          else\n            call ol_error(\"in redAllInfoFiles error reading file: \" // trim(infofilename) )\n            exit ProclibDirLoop\n          end if\n        end if\n\n        ! strip empty lines\n        if (len_trim(infoline) == 0) then\n          cycle InfoFileLoop\n        end if\n\n        infoline = adjustl(infoline)\n        ! strip possible comment: start with #\n        if (infoline(1:1) == \"#\") then\n          cycle InfoFileLoop\n        end if\n\n        ! strip lines starting with OPTIONS=... (deprecated)\n        if (infoline(1:8) == \"options \") then\n          call readInfoInt(infoline, 'API', API)\n          cycle InfoFileLoop\n        end if\n\n        counter = counter+1\n        ! strip first line of collection files\n        if (info_file_suffix == 'rinfo' .and. counter == 1) then\n          cycle InfoFileLoop\n        end if\n\n        ! determine library type from name of info file\n        if (info_file_suffix == 'rinfo') then\n          infos%LTYPE = \"lib\"\n        else\n          infos%LTYPE = infofilename(index(infofilename,'_',.true.)+1:index(infofilename,'.info')-1)\n        end if\n\n        call readAllInfos(infoline, infos, API)\n        if (error > 1) then\n          call ol_error(\"reading infofile line: \" // trim(infoline))\n          exit ProclibDirLoop\n        end if\n\n        ! Add to array of infos\n        if (.not. allocated(process_infos)) then\n          allocate(process_infos(1))\n        else\n          allocate(process_infos_bak(size(process_infos)))\n          process_infos_bak = process_infos\n          deallocate(process_infos)\n          allocate(process_infos(size(process_infos_bak)+1))\n          process_infos(1:size(process_infos_bak)) = process_infos_bak\n          deallocate(process_infos_bak)\n        end if\n        process_infos(size(process_infos)) = infos\n      end do InfoFileLoop\n    end do ProclibDirLoop\n\n    ! close directory handle\n    call closedir()\n\n    ! close file handle\n    inquire(gf_info, opened=iqopen)\n    if(iqopen) close(unit=gf_info)\n\n    if (.not. allocated(process_infos)) then\n      call ol_error(\"no processes installed!\")\n    end if\n\n    contains\n\n    subroutine readAllInfos(lineinfo, infos, api)\n      implicit none\n      character(len=*), intent(in) :: lineinfo\n      integer,          intent(in) :: api\n      type(processinfos), intent(inout) :: infos\n      integer :: ccount\n\n      call readInfoCol(lineinfo, 1, infos%LIBNAME)\n      call readInfoCol(lineinfo, 2, infos%PROC)\n\n      if (index(lineinfo, 'map') > 0) then\n        if (index(lineinfo, ' map') > 0) then\n          call readInfo(lineinfo, 'map', infos%MAP)\n        else if (index(lineinfo, ' condmap') > 0) then\n          call readInfo(lineinfo, 'condmap', infos%MAP)\n        else\n          call ol_fatal(\"info-file mapping not supported!\")\n          return\n        end if\n        infos%MAPPERM =  infos%MAP(index(infos%MAP, '[')+1:index(infos%MAP, ']')-1)\n        if (len_trim(infos%MAPPERM) /= 0) then\n          infos%MAP = infos%MAP(1:index(infos%MAP,'[')-1)\n        end if\n        infos%ID = '0'\n      else\n        call readInfoCol(lineinfo, 3, infos%ID)\n        call readInfoCoupling(lineinfo, 'QCD', infos%QCDorder)\n        call readInfoCoupling(lineinfo, 'EW', infos%EWorder)\n        infos%MAP = ' '\n        infos%MAPPERM = ' '\n      end if\n      call readInfo(lineinfo, 'ME', infos%ME)\n      call readInfo(lineinfo, 'MM', infos%MM)\n      call readInfo(lineinfo, 'ML', infos%ML)\n      call readInfo(lineinfo, 'MU', infos%MU)\n      call readInfo(lineinfo, 'MD', infos%MD)\n      call readInfo(lineinfo, 'MS', infos%MS)\n      call readInfo(lineinfo, 'MC', infos%MC)\n      call readInfo(lineinfo, 'MB', infos%MB)\n      call readInfoInt(lineinfo, 'YukE', infos%YE)\n      call readInfoInt(lineinfo, 'YukM', infos%YM)\n      call readInfoInt(lineinfo, 'YukL', infos%YL)\n      call readInfoInt(lineinfo, 'YukU', infos%YU)\n      call readInfoInt(lineinfo, 'YukD', infos%YD)\n      call readInfoInt(lineinfo, 'YukS', infos%YS)\n      call readInfoInt(lineinfo, 'YukC', infos%YC)\n      call readInfoInt(lineinfo, 'YukB', infos%YB)\n      call readInfoInt(lineinfo, 'YukT', infos%YT)\n      call readInfo(lineinfo, 'APPROX', infos%APPROX)\n      call readInfoInt(lineinfo, 'CKMORDER', infos%CKMorder)\n      call readInfoInt(lineinfo, 'nc', infos%NC)\n      call readInfoInt(lineinfo, 'nf', infos%NF)\n      call readInfoInt(lineinfo, 'LeadingColour', infos%LeadingColour)\n      call readInfoInt(lineinfo, 'POLSEL', infos%POLSEL)\n      call readInfo(lineinfo, 'CC', infos%CC)\n      call readInfo(lineinfo, 'MODEL', infos%Model)\n      call readInfoInt(lineinfo, 'OLMode', infos%OLMode)\n      infos%API = api\n      if (len_trim(infos%Model) == 0) then\n        infos%Model = \"sm\"\n      end if\n      call readInfo(lineinfo, 'Type', infos%TYPE)\n      if (trim(infos%TYPE) == \"\") then\n        infos%TYPE = infos%LTYPE\n      end if\n    end subroutine readAllinfos\n\n    subroutine readInfo(lineinfo, var, res)\n      implicit none\n      character(len=*), intent(in) :: lineinfo\n      character(len=*), intent(in) :: var\n      character(len=*), intent(out) :: res\n      if (index(lineinfo, ' '//var//'=') /= 0) then\n        res = lineinfo(index(lineinfo, var//'=')+len_trim(var)+1: &\n              & index(lineinfo, var//'=')+index(lineinfo(index(lineinfo, var//'='):),' ')-1 )\n      else\n        res = \"\"\n      end if\n    end subroutine readInfo\n\n    subroutine readInfoCol(lineinfo, col, res)\n      implicit none\n      character(len=*), intent(in) :: lineinfo\n      integer, intent(in)  :: col\n      character(len=*), intent(out) :: res\n      integer sstart, send, i\n      sstart = 1\n      do i=1,col-1\n        sstart = sstart + index(lineinfo(sstart:), \" \")\n      end do\n      send = sstart + index(lineinfo(sstart:), \" \") - 2\n      res = trim(lineinfo(sstart:send))\n    end subroutine readInfoCol\n\n    subroutine readInfoColInt(lineinfo, col, res)\n      use ol_generic, only: to_int\n      implicit none\n      character(len=*), intent(in) :: lineinfo\n      integer, intent(in)  :: col\n      integer, intent(out) :: res\n      character(len=max_parameter_length) :: resc\n      integer sstart, send\n      call readInfoCol(lineinfo,col, resc)\n      res = to_int(trim(resc))\n      if (res == -huge(res)) then\n        call ol_msg(1, \"Warning: problem reading info line: \" // trim(lineinfo))\n      end if\n    end subroutine readInfoColInt\n\n    subroutine readInfoInt(lineinfo, var, res)\n      use ol_generic, only: to_int\n      implicit none\n      character(len=*), intent(in) :: lineinfo\n      character(len=*), intent(in) :: var\n      character(len=10) :: restemp\n      integer, intent(out) :: res\n      if (index(lineinfo, var//'=') /= 0) then\n        restemp = lineinfo(index(lineinfo, var//'=')+len_trim(var)+1: &\n            & index(lineinfo, var//'=')+index(lineinfo(index(lineinfo, var//'='):),' ')-1)\n      else\n        restemp = \"0\"\n      end if\n      res = to_int(restemp)\n      if (res == -huge(res)) then\n        call ol_msg(1, \"Warning: problem reading info line: \" // trim(lineinfo))\n      end if\n    end subroutine readInfoInt\n\n    subroutine readInfoCoupling(lineinfo, var, res)\n      use ol_generic, only: to_int\n      implicit none\n      character(len=*), intent(in) :: lineinfo\n      character(len=*), intent(in) :: var\n      integer ::  stat(0:1)\n      character(len=max_parameter_length) :: restempc\n      integer, intent(out) :: res(0:1)\n      if (index(lineinfo, var//'=') /= 0) then\n        call readInfo(lineinfo,var,restempc)\n        res(0) = to_int(trim(restempc(1:index(restempc,\",\")-1)))\n        res(1) = to_int(trim(restempc(index(restempc,\",\")+1:)))\n      else\n        res(0) = 0\n        res(1) = 0\n      end if\n      if (any(res == -huge(res))) then\n        call ol_msg(1,\"Warning: problem reading info line: \" // trim(lineinfo))\n      end if\n    end subroutine readInfoCoupling\n\n  end subroutine readAllInfoFiles\n\n\n   subroutine add_loaded_library(infos)\n   ! add infos of loaded library to the list of already loaded libraries.\n    implicit none\n    type(processinfos), intent(in) :: infos\n    type(processinfos), allocatable :: loaded_libs_bak(:)\n    integer :: i,loaded_libs_last\n    if (allocated(loaded_libs)) then\n      do i = 1, size(loaded_libs)\n        if ( trim(infos%LIBNAME) == trim(loaded_libs(i)%LIBNAME) .and.  &\n          &   trim(infos%TYPE) == trim(loaded_libs(i)%TYPE) ) return\n      end do\n      loaded_libs_last = size(loaded_libs)\n      allocate(loaded_libs_bak(loaded_libs_last))\n      loaded_libs_bak = loaded_libs\n      deallocate(loaded_libs)\n      allocate(loaded_libs(loaded_libs_last+1))\n      loaded_libs(1:loaded_libs_last) = loaded_libs_bak\n      deallocate(loaded_libs_bak)\n    else\n     loaded_libs_last = 0\n     allocate(loaded_libs(1))\n    end if\n    loaded_libs(loaded_libs_last+1) = infos\n   end subroutine\n\n\n  subroutine flavour_mapping(ext,switch_in)\n  ! ext: PDG coded integer array\n  ! switch: 0: no mapping, 1: quark & lepton mapping, 2: only lepton mapping, 3: only quark mapping\n  ! ==Lepton & quark flavour mapping==\n  !   Concept (taken from old Sherpa interface):\n  !   (1) Given a final state, determine the four (anti)lepton/neutrino\n  !       multiplicities in the given process:\n  !       a_nubar, a_nu, a_lbar, a_l\n  !   (2) Compute the discriminant N[i] as\n  !       N[i] = Ngen - i + Ngen*(a_nubar + a_nu*Nmax + a_lbar*Nmax^2 + a_l*Nmax^3)\n  !       where Nmax should be chosen such that a_...<=Nmax.\n  !       In practice one can safely set Nmax=10 and it will work for any\n  !       process with <= 20 final-state leptons.\n  !       It is also convenient to set Ngen=10, although i runs only from 1 to 3.\n  !   (3) Reassign the lepton generations with a permutation\n  !       p1 -> 1, p2 -> 2, p3 -> 3  such that  N[p1] > N[p2] > N[p3] */\n    use ol_generic, only: to_string\n    use ol_parameters_decl_/**/DREALKIND, only: rMC, rYC, rMM, rYM, rML, rYL\n    implicit none\n    type(extparticle), intent(inout) :: ext(:)\n    integer, optional, intent(in)    :: switch_in\n    type(extparticle), allocatable :: new_ext(:)\n    integer :: switch\n    integer :: i, j\n    integer :: Ngen, Nlgen, Nqgen, Nmax\n    integer :: l_gen, nu_gen, l_gen_new, nu_gen_new\n    integer :: d_gen, u_gen, d_gen_new, u_gen_new\n    integer :: a_nu, a_nubar, a_l, a_lbar\n    integer :: a_u, a_ubar, a_d, a_dbar\n    integer :: Nl(3,2), Nq(2,2)\n    integer :: perm(size(ext))\n\n    if (present(switch_in)) then\n      switch = switch_in\n    else\n      switch = 0\n    end if\n\n    if (switch < 0 .or. switch > 3) then\n      call ol_error(\"flavour_mapping: only options for switch=0,1,2,3\")\n    end if\n\n    Ngen=10\n    Nmax=10\n\n    call ol_msg(3,\"Flavour mapping. Original (all ingoing) process: \" // to_string([(ext(j)%id, j=1,size(ext))]) )\n\n    if (rML == 0 .and. rYL == 0 .and. rMM == 0 .and. rYM == 0) then\n      Nlgen = 3\n    else if ((rML /= 0. .or. rYL /= 0 ) .and. rMM == 0 .and. rYM == 0) then\n      Nlgen = 2\n    else\n      Nlgen = 1\n    end if\n\n    if (rMC == 0 .and. rYC == 0) then\n      Nqgen = 2\n    else\n      Nqgen = 1\n    end if\n\n    allocate(new_ext(size(ext)))\n    new_ext = ext\n\n    if (switch == 1 .or. switch == 2) then\n      !lepton flavour mapping\n      do i = 1, Nlgen\n        l_gen=9+2*i;\n        nu_gen=10+2*i;\n\n        a_nu=count_integer(ext,nu_gen);\n        a_nubar=count_integer(ext,-nu_gen);\n        a_l=count_integer(ext,l_gen);\n        a_lbar=count_integer(ext,-l_gen);\n\n        Nl(i,1)=Ngen-i+Ngen*(a_nubar+a_nu*Nmax+a_lbar*Nmax*Nmax+a_l*Nmax*Nmax*Nmax)\n        Nl(i,2)=i\n      end do\n\n      call sort_pair(Nl,Nlgen)\n\n      do i = 1, Nlgen\n        l_gen=9+2*Nl(i,2);\n        l_gen_new=9+2*i;\n        nu_gen=10+2*Nl(i,2);\n        nu_gen_new=10+2*i;\n\n        do j = 1, size(ext)\n          if (abs(ext(j)%id)==nu_gen) new_ext(j)%id=sign(nu_gen_new,ext(j)%id)\n          if (abs(ext(j)%id)==l_gen)  new_ext(j)%id=sign(l_gen_new,ext(j)%id)\n        end do\n      end do\n      ext = new_ext\n    end if\n\n    if (switch == 1 .or. switch == 3) then\n      !quark flavour mapping\n      do i = 1, Nqgen\n        d_gen=2*i-1;\n        u_gen=2*i;\n\n        a_d=count_integer(ext,d_gen);\n        a_dbar=count_integer(ext,-d_gen);\n        a_u=count_integer(ext,u_gen);\n        a_ubar=count_integer(ext,-u_gen);\n\n        Nq(i,1)=Ngen-(i+1) + Ngen*(a_ubar+a_u*Nmax+a_dbar*Nmax*Nmax+a_d*Nmax*Nmax*Nmax)\n        Nq(i,2)=i\n      end do\n\n      call sort_pair(Nq,Nqgen)\n\n      do i = 1, Nqgen\n        d_gen=2*Nq(i,2)-1;\n        d_gen_new=2*i-1;\n        u_gen=2*Nq(i,2);\n        u_gen_new=2*i;\n\n        do j = 1, size(ext)\n          if (abs(ext(j)%id)==u_gen) new_ext(j)%id=sign(u_gen_new,ext(j)%id)\n          if (abs(ext(j)%id)==d_gen) new_ext(j)%id=sign(d_gen_new,ext(j)%id)\n        end do\n      end do\n      ext = new_ext\n    end if\n\n    deallocate(new_ext)\n\n    call ol_msg(3, \"Flavour mapping. Mapped (all ingoing) process:   \" // to_string([(ext(j)%id, j=1,size(ext))]))\n\n    contains\n\n    subroutine sort_pair(a,n)\n    ! Simple insertion sort. Sorting descending on the first component of a 2-tuple of length n\n      integer, intent(in) :: n\n      integer, intent(inout), dimension(:,:) :: a\n      integer :: temp(2)\n      integer :: i, j\n\n      do i = 2, n\n        j = i - 1\n        temp(1) = a(i,1)\n        temp(2) = a(i,2)\n        do while (j>=1 .and. a(j,1)<temp(1))\n          a(j+1,1) = a(j,1)\n          a(j+1,2) = a(j,2)\n          j = j - 1\n          if (j==0) exit\n        end do\n        a(j+1,1) = temp(1)\n        a(j+1,2) = temp(2)\n      end do\n    end subroutine sort_pair\n\n    function count_integer(list, j)\n    ! count frequency of integer j in array ilist\n      implicit none\n      type(extparticle), intent(in) :: list(:)\n      integer, intent(in) :: j\n      integer :: count_integer\n      integer i\n      count_integer = 0\n      do i = 1, size(list)\n        if (list(i)%id == j) count_integer = count_integer+1\n      end do\n    end function count_integer\n\n  end subroutine\n\n\n  function write_shop_list(ext, proc)\n    use ol_parameters_decl_/**/DREALKIND, only: shopping_list, order_ew, order_qcd, &\n      & rMU, rMD, rMC, rMS, rMB, rME, rMM, rML\n    use ol_generic, only: to_string\n    implicit none\n    type(extparticle), intent(in) :: ext(:)\n    character(len=max_parameter_length), intent(in) :: proc\n    integer write_shop_list\n    character(len=500) :: output\n    character(len=max_parameter_length), allocatable :: shopped_processes_bak(:)\n    integer, save :: id = 1\n    integer ::  readok\n    integer :: i, already_shopped\n    integer :: oqcd, oew\n    logical :: set_masses = .false.\n    logical :: iqopen\n\n    write_shop_list = -1\n\n    if ( .not. (shopping_list_open) ) then\n      inquire(fh_shopping, opened=iqopen)\n      if(iqopen) close(unit=fh_shopping)\n      !open shopping list\n      open(fh_shopping, file=trim(shopping_list), status = \"unknown\", position='append', iostat=readok)\n      if (readok /= 0) then\n        call ol_msg(\"Error opening shopping list \" // trim(shopping_list))\n        return\n      end if\n      ! write header\n      write(fh_shopping,'(A)') \"\"\n      if (order_ew /= -1) then\n        oqcd = size(ext)-2-order_ew\n        write(fh_shopping,'(A)') \"SelectCoupling = (Exponent[#, gQCD] == \" // trim(to_string(oqcd)) // \" + 2 * #2 &);\"\n        write(fh_shopping,'(A)') \"SelectInterference = {eQED -> \" // trim(to_string(order_ew*2)) // \"};\"\n        write(fh_shopping,'(A)') \"UnitaryGauge = True;\"\n        write(fh_shopping,'(A)') \"\"\n      else if (order_qcd /= -1) then\n        oew = size(ext)-2-order_qcd\n        write(fh_shopping,'(A)') \"SelectCoupling = (Exponent[#, eQED] == \" // trim(to_string(oew)) // \" + 2 * #2 \" &\n          & // \" ||  Exponent[#1, eQED] == \" // trim(to_string(oew+2))  // \" - 2 * #2 &);\"\n        write(fh_shopping,'(A)') \"SelectInterference = {gQCD -> \" // trim(to_string(order_qcd*2)) // \"};\"\n        write(fh_shopping,'(A)') \"UnitaryGauge = False;\"\n        write(fh_shopping,'(A)') \"\"\n      end if\n      shopping_list_open = .true.\n    end if\n\n    if (allocated(shopped_processes)) then\n      do i = 1, size(shopped_processes)\n        if ( trim(proc) == trim(shopped_processes(i)) ) then\n          call ol_msg(2, \"Not written to shopping list. Already shopped as process \" &\n                    & // trim(to_string(i)) // \": \" //trim(proc) )\n          write_shop_list = i\n          return\n        end if\n      end do\n      already_shopped = size(shopped_processes)\n      allocate(shopped_processes_bak(already_shopped))\n      shopped_processes_bak = shopped_processes\n      deallocate(shopped_processes)\n      allocate(shopped_processes(already_shopped+1))\n      shopped_processes(1:already_shopped) = shopped_processes_bak\n      deallocate(shopped_processes_bak)\n    else\n      already_shopped = 0\n      allocate(shopped_processes(1))\n    end if\n    shopped_processes(already_shopped+1) = trim(proc)\n\n    ! process name and id\n    output = \"(* \" //trim(proc)// \" *) AddProcess[FeynArtsProcess -> \"\n    ! inital state\n    output = trim(output) // \" {\" // trim(PDGtoFA(ext(1)%id)) // \", \" // trim(PDGtoFA(ext(2)%id)) //  \"} -> {\"\n    ! final state\n    do i=3,size(ext)\n      output = trim(output) // trim(PDGtoFA(ext(i)%id))\n      if (i /= size(ext)) output = trim(output) // \", \"\n    end do\n    output = trim(output) // \"}\"\n\n    ! massive fermions\n    set_masses = .false.\n    if (rMU /= 0 .or. rMD /= 0 .or. rMC /= 0 .or. rMS /= 0 .or. rMB /= 0 .or. &\n      & rME /= 0 .or. rMM /= 0 .or. rML /= 0) then\n      output = trim(output) // \", SetParameters -> JoinOptions[{\"\n      if (rMU /= 0) then\n        output = trim(output) // \"MU -> MU\"\n        set_masses = .true.\n      end if\n      if (rMD /= 0) then\n        if (set_masses) output = trim(output) // \",\"\n        output = trim(output) // \"MD -> MD\"\n        set_masses = .true.\n      end if\n      if (rMC /= 0) then\n        if (set_masses) output = trim(output) // \",\"\n        output = trim(output) // \"MC -> MC\"\n        set_masses = .true.\n      end if\n      if (rMS /= 0) then\n        if (set_masses) output = trim(output) // \",\"\n        output = trim(output) // \"MS -> MS\"\n        set_masses = .true.\n      end if\n      if (rMB /= 0) then\n        if (set_masses) output = trim(output) // \",\"\n        output = trim(output) // \"MB -> MB\"\n        set_masses = .true.\n      end if\n      if (rME /= 0) then\n        if (set_masses) output = trim(output) // \",\"\n        output = trim(output) // \"ME -> ME\"\n        set_masses = .true.\n      end if\n      if (rMM /= 0) then\n        if (set_masses) output = trim(output) // \",\"\n        output = trim(output) // \"MM -> MM\"\n        set_masses = .true.\n      end if\n      if (rML /= 0) then\n        if (set_masses) output = trim(output) // \",\"\n        output = trim(output) // \"ML -> ML\"\n        set_masses = .true.\n      end if\n      output = trim(output) // \"}]\"\n    end if\n\n    output = trim(output) // \"];\"\n\n    call ol_msg(1,\" Write to shopping list \"// trim(shopping_list)  //\": \" // trim(output))\n\n    ! write process to shopping list\n    write(fh_shopping,'(A)') trim(output)\n\n    write_shop_list = id\n    id = id+1\n  end function write_shop_list\n\n\n\n  function PDGtoFA(pdg)\n  ! PDG number scheme -> FeynArts naming scheme\n    implicit none\n    integer, intent(in) :: pdg\n    character(len=10) :: PDGtoFA\n\n    if (pdg < 0 .and. pdg /= -24) then\n      PDGtoFA = \"-\"\n    else if (pdg == 24) then\n      PDGtoFA = \"-\"\n    else\n      PDGtoFA = \"\"\n    end if\n\n    select case (abs(pdg))\n      case  (1)\n        PDGtoFA = trim(PDGtoFA) // \"F[4,{1}]\"\n      case  (2)\n        PDGtoFA = trim(PDGtoFA) // \"F[3,{1}]\"\n      case  (3)\n        PDGtoFA = trim(PDGtoFA) // \"F[4,{2}]\"\n      case  (4)\n        PDGtoFA = trim(PDGtoFA) // \"F[3,{2}]\"\n      case  (5)\n        PDGtoFA = trim(PDGtoFA) // \"F[4,{3}]\"\n      case  (6)\n        PDGtoFA = trim(PDGtoFA) // \"F[3,{3}]\"\n      case  (11)\n        PDGtoFA = trim(PDGtoFA) // \"F[2,{1}]\"\n      case  (12)\n        PDGtoFA = trim(PDGtoFA) // \"F[1,{1}]\"\n      case  (13)\n        PDGtoFA = trim(PDGtoFA) // \"F[2,{2}]\"\n      case  (14)\n        PDGtoFA = trim(PDGtoFA) // \"F[1,{2}]\"\n      case  (15)\n        PDGtoFA = trim(PDGtoFA) // \"F[2,{3}]\"\n      case  (16)\n        PDGtoFA = trim(PDGtoFA) // \"F[1,{3}]\"\n      case  (21,9)\n        PDGtoFA = \"V[5]\"\n      case  (22)\n        PDGtoFA = \"V[1]\"\n      case  (23)\n        PDGtoFA = \"V[2]\"\n      case  (24)\n        PDGtoFA = trim(PDGtoFA) // \"V[3]\"\n      case  (25)\n        PDGtoFA = \"S[1]\"\n      case default\n        call ol_msg(\"Error: only SM particles are allowed!\")\n        PDGtoFA = \"?\"\n    end select\n\n  end function PDGtoFA\n\n\n  function ID_to_extparticle(id_in)\n    use KIND_TYPES, only: DREALKIND\n    use ol_generic, only: to_int, to_lowercase\n    use ol_parameters_decl_/**/DREALKIND, only: use_me_cache\n  ! MadGraph naming scheme -> PDG\n    implicit none\n    character(len=*), intent(in) :: id_in\n    character(len=len(id_in)) :: id\n    type(extparticle) :: ID_to_extparticle\n\n    if (index(id_in, \"(\") > 0 .and. index(id_in, \")\") > 0) then\n      ID_to_extparticle%pol = to_int(id_in(index(id_in,\"(\")+1:index(id_in,\")\")-1))\n      if (ID_to_extparticle%pol /= 0 .and. abs(ID_to_extparticle%pol) /= 1 .and. ID_to_extparticle%pol /= 2) then\n        call ol_error(\"polarization of external particles has to be: 0 (unpol.), -1 (left), 1 (right), 2 (long.)\")\n      end if\n      id = id_in(1:index(id_in,\"(\")-1)\n      ! deactive me_cache for polarized amplitudes\n      if (use_me_cache == 1) then\n        use_me_cache = 0\n        call ol_msg(2,\"Matrix element cache deactivated (not available for polarized amplitudes).\")\n      end if\n    else\n      ID_to_extparticle%pol = 0\n      id = id_in\n    end if\n\n    select case (trim(to_lowercase(id)))\n      case  ('d')\n        ID_to_extparticle%id = 1\n      case  ('d~')\n        ID_to_extparticle%id = -1\n      case  ('u')\n        ID_to_extparticle%id = 2\n      case  ('u~')\n        ID_to_extparticle%id = -2\n      case  ('s')\n        ID_to_extparticle%id = 3\n      case  ('s~')\n        ID_to_extparticle%id = -3\n      case  ('c')\n        ID_to_extparticle%id = 4\n      case  ('c~')\n        ID_to_extparticle%id = -4\n      case  ('b')\n        ID_to_extparticle%id = 5\n      case  ('b~')\n        ID_to_extparticle%id = -5\n      case  ('t')\n        ID_to_extparticle%id = 6\n      case  ('t~')\n        ID_to_extparticle%id = -6\n      case  ('e-')\n        ID_to_extparticle%id = 11\n      case  ('e+')\n        ID_to_extparticle%id = -11\n      case  ('ve', 'ne', 'nu_e')\n        ID_to_extparticle%id = 12\n      case  ('ve~', 'ne~', 'nu_e~')\n        ID_to_extparticle%id = -12\n      case  ('mu-', 'm-')\n        ID_to_extparticle%id = 13\n      case  ('mu+', 'm+')\n        ID_to_extparticle%id = -13\n      case  ('vm', 'vmu', 'nm', 'nmu', 'nu_mu')\n        ID_to_extparticle%id = 14\n      case  ('vm~', 'vmu~', 'nm~', 'nmu~', 'nu_mu~')\n        ID_to_extparticle%id = -14\n      case  ('ta-', 'tau-', 'l-')\n        ID_to_extparticle%id = 15\n      case  ('ta+', 'tau+', 'l+')\n        ID_to_extparticle%id = -15\n      case  ('vt', 'vta', 'vtau', 'nt', 'nta', 'ntau', 'nu_tau')\n        ID_to_extparticle%id = 16\n      case  ('vt~', 'vta~', 'vtau~', 'nt~', 'nta~', 'ntau~', 'nu_tau~')\n        ID_to_extparticle%id = -16\n      case  ('g')\n        ID_to_extparticle%id = 21\n      case  ('a') ! on-shell photon\n        ID_to_extparticle%id = 22\n      case  ('aon') ! off-shell photon\n        ID_to_extparticle%id = 2002\n      case  ('aoff') ! off-shell photon\n        ID_to_extparticle%id = -2002\n      case  ('z')\n        ID_to_extparticle%id = 23\n      case  ('w+')\n        ID_to_extparticle%id = 24\n      case  ('w-')\n        ID_to_extparticle%id = -24\n      case  ('h')\n        ID_to_extparticle%id = 25\n      case  ('h1')\n        ID_to_extparticle%id = 25\n      case  ('h2', 'h0')\n        ID_to_extparticle%id = 35\n      case  ('h3', 'a0')\n        ID_to_extparticle%id = 36\n      case  ('h-', 'hpx')\n        ID_to_extparticle%id = -37\n      case  ('h+', 'hp')\n        ID_to_extparticle%id = 37\n      case default\n        ID_to_extparticle%id = to_int(trim(id))\n        if (ID_to_extparticle%id == -huge(ID_to_extparticle%id)) then\n          call ol_error('unrecognised particle id: ' // trim(id))\n        end if\n    end select\n  end function ID_to_extparticle\n\n\n  function ewcharge(id)\n    use KIND_TYPES, only: DREALKIND\n    use ol_generic, only: to_string\n  ! PDG -> charge\n    implicit none\n    integer, intent(in) :: id\n    real(DREALKIND) :: ewcharge\n\n    select case (id)\n      case  (1,3,5)\n        ewcharge = -1./3\n      case  (-1,-3,-5)\n        ewcharge = +1./3\n      case  (2,4,6)\n        ewcharge = +2./3\n      case  (-2,-4,-6)\n        ewcharge = -2./3\n      case  (11,13,15,-24,-37)\n        ewcharge = -1\n      case  (-11,-13,-15,24,37)\n        ewcharge = +1\n      case  (12,14,16,-12,-14,-16,21,22,23,2002,-2002,25,35,36)\n       ewcharge = 0\n      case default\n          call ol_error('unrecognised particle id: ' // to_string(id))\n          ewcharge = 0\n    end select\n  end function ewcharge\n\n\n  function process_to_extparticlelist(c_in,is_initial)\n  ! convert a comma/space/slash separated string of MadGraph or PDG ids into an array of PDG integers\n    implicit none\n    character(len=*), intent(in) :: c_in\n    logical, optional, intent(in) :: is_initial\n    character(len(c_in)+1) :: c\n    type(extparticle), allocatable :: process_to_extparticlelist(:)\n    integer i, n, pos1\n    logical last_seperator\n\n    c = c_in // \" \"\n\n    n=0\n    pos1=0\n    last_seperator =  .false.\n    do i = 1, len(c)\n      if (c(i:i) == \"[\" .or. c(i:i) == \"]\") c(i:i) = \" \"\n\n      if (c(i:i) == ',' .or. c(i:i) == ' ' .or. c(i:i) == \"/\" ) then\n        if (last_seperator)  then\n          pos1 = i\n          cycle\n        end if\n        n = n+1\n        pos1 = i\n        last_seperator = .true.\n      else\n        last_seperator = .false.\n      end if\n    end do\n\n    allocate(process_to_extparticlelist(n))\n\n    n=0\n    pos1=0\n    last_seperator =  .false.\n    do i = 1, len(c)\n      if (c(i:i) == ',' .or. c(i:i) == ' ' .or. c(i:i) == \"/\") then\n        if (last_seperator)  then\n          pos1 = i\n          cycle\n        end if\n        n = n+1\n        process_to_extparticlelist(n) = ID_to_extparticle(c(pos1+1:i-1))\n        if (present(is_initial)) process_to_extparticlelist(n)%is_initial = is_initial\n        pos1 = i\n        last_seperator = .true.\n      else\n        last_seperator = .false.\n      end if\n    end do\n  end function process_to_extparticlelist\n\n\n  subroutine ol_printparameter(filename)\n    ! Write parameters to a file.\n    ! [in] filename\n    use ol_parameters_init_/**/DREALKIND, only: parameters_write\n    implicit none\n    character(len=*), intent(in) :: filename\n    call parameters_write(filename)\n  end subroutine ol_printparameter\n\n\n  subroutine ol_printparameter_c(filename) bind(c,name=\"ol_printparameter\")\n    ! C wrapper to ol_printparameter\n    ! [in] filename as C string\n    use ol_iso_c_utilities, only: c_f_string\n    implicit none\n    character(kind=c_char), dimension(*), intent(in) :: filename\n    character(len=max_parameter_length) :: f_filename\n    call c_f_string(filename, f_filename, max_parameter_length)\n    call ol_printparameter(trim(f_filename))\n  end subroutine ol_printparameter_c\n\n\n  function register_process_c(process, amptype) bind(c,name=\"ol_register_process\")\n    use ol_iso_c_utilities, only: c_f_string\n    use ol_parameters_decl_/**/DREALKIND,  only: max_parameter_length\n    implicit none\n    character(kind=c_char), dimension(*), intent(in) :: process\n    integer(c_int), value :: amptype\n    integer(c_int) :: register_process_c\n    character(len=max_parameter_length) :: f_process\n    integer :: f_amptype\n    f_amptype = amptype\n    call c_f_string(process, f_process, max_parameter_length)\n    register_process_c = register_process(f_process, f_amptype)\n  end function register_process_c\n\n\n  subroutine stop_invalid_id(id)\n    use ol_generic, only: to_string\n    implicit none\n    integer, intent(in) :: id\n    if (id <= 0 .or. id > last_process_id) then\n      call ol_fatal(\"Error: no registered process with id \" // to_string(id))\n      return\n    end if\n  end subroutine stop_invalid_id\n\n  pure function amplitudetype(id)\n    ! [in] id: a process id\n    ! return amptype of type integer\n    implicit none\n    integer, intent(in) :: id\n    integer amplitudetype\n    ! call stop_invalid_id(id) not possible here,\n    ! because 'print' and 'stop' are not allowed in pure functions.\n    if (id <= 0 .or. id > last_process_id) then\n      amplitudetype = 0\n    else\n      amplitudetype = process_handles(id)%amplitude_type\n    end if\n  end function amplitudetype\n\n\n  function amplitudetype_c(id) bind(c,name=\"ol_amplitudetype\")\n    ! [in] id: a process id\n    ! return amptype of type integer\n    implicit none\n    integer(c_int), value :: id\n    integer(c_int) :: amplitudetype_c\n    call stop_invalid_id(int(id))\n    if (error > 1) return\n    amplitudetype_c = process_handles(int(id))%amplitude_type\n  end function amplitudetype_c\n\n\n  function library_content_c(id) bind(c,name='ol_library_content')\n    implicit none\n    integer(c_int), value :: id\n    integer(c_int) :: library_content_c\n    call stop_invalid_id(int(id))\n    if (error > 1) return\n    library_content_c = process_handles(int(id))%content\n  end function library_content_c\n\n\n  pure function n_external(id)\n    implicit none\n    integer, intent(in) :: id\n    integer :: n_external\n    ! call stop_invalid_id(id) not possible here,\n    ! because 'print' and 'stop' are not allowed in pure functions.\n    if (id <= 0 .or. id > last_process_id) then\n      n_external = 0\n    else\n      n_external = process_handles(id)%n_particles\n    end if\n  end function n_external\n\n\n  function n_external_c(id) bind(c,name=\"ol_n_external\")\n    implicit none\n    integer(c_int), value :: id\n    integer(c_int) :: n_external_c\n    call stop_invalid_id(int(id))\n    if (error > 1) return\n    n_external_c = process_handles(int(id))%n_particles\n  end function n_external_c\n\n\n  subroutine phase_space_point(id, sqrt_s, psp)\n    implicit none\n    integer, intent(in) :: id\n    real(DREALKIND), intent(in) :: sqrt_s\n    real(DREALKIND), intent(out) :: psp(:,:)\n    type(process_handle) :: subprocess\n    call stop_invalid_id(id)\n    if (error > 1) return\n    subprocess = process_handles(id)\n    call subprocess%set_permutation(subprocess%permutation)\n    n_scatt = subprocess%n_in\n    call subprocess%rambo(sqrt_s, psp)\n  end subroutine phase_space_point\n\n\n  subroutine phase_space_point_c(id, sqrt_s, pp) bind(c,name=\"ol_phase_space_point\")\n    implicit none\n    integer(c_int), value :: id\n    real(c_double), value :: sqrt_s\n    real(c_double), intent(out) :: pp(5*n_external(int(id)))\n    type(process_handle) :: subprocess\n    integer :: i\n    real(DREALKIND) :: f_sqrt_s\n    real(DREALKIND) :: f_psp(0:3,n_external(int(id)))\n    ! call stop_invalid_id(id) not needed here\n    i = id\n    f_sqrt_s = sqrt_s\n    subprocess = process_handles(i)\n    call phase_space_point(i, f_sqrt_s, f_psp)\n    do i = 1, subprocess%n_particles\n      pp(5*(i-1)+1:5*(i-1)+4) = f_psp(0:3,i)\n      pp(5*i) = subprocess%masses(i)\n    end do\n  end subroutine phase_space_point_c\n\n\n  subroutine tree_colbasis_dim(id, ncolb, colelemsz, nhel)\n    ! for process with id 'id' return\n    ! ncolb = number of tree colour basis elements;\n    ! colelemsz = number of colour colour indices in a colour basis element\n    ! nhel = number of helicity configuration, including those which vanish\n    implicit none\n    integer, intent(in) :: id\n    integer, intent(out) :: ncolb, colelemsz, nhel\n    integer :: extcols(n_external(id)), ncoupl, maxpows, ncolext\n    call stop_invalid_id(id)\n    if (error > 1) return\n    if (.not. associated(process_handles(id)%tree_colbasis_dim)) then\n      call ol_msg(\"Error: colour basis information is not available\")\n      call ol_fatal(\"       for process \" // process_handles(id)%process_name)\n      return\n    end if\n    call process_handles(id)%tree_colbasis_dim(extcols, ncolb, ncoupl, maxpows, nhel)\n    ncolext = count(extcols /= 0)\n    colelemsz = ncolext/2 + ncolext - 1\n  end subroutine tree_colbasis_dim\n\n\n  subroutine tree_colbasis_dim_c(id, ncolb, colelemsz, nhel) bind(c,name=\"ol_tree_colbasis_dim\")\n    implicit none\n    integer(c_int), value :: id\n    integer(c_int), intent(out) :: ncolb, colelemsz, nhel\n    integer :: f_ncolb, f_colelemsz, f_nhel\n    ! call stop_invalid_id(id) not needed here\n    call tree_colbasis_dim(int(id), f_ncolb, f_colelemsz, f_nhel)\n    ncolb = f_ncolb\n    colelemsz = f_colelemsz\n    nhel = f_nhel\n  end subroutine tree_colbasis_dim_c\n\n\n  pure function get_tree_colbasis_dim(id)\n    ! number of tree colour basis elements; used to declare array sizes\n    implicit none\n    integer, intent(in) :: id\n    integer :: get_tree_colbasis_dim\n    integer :: extcols(n_external(id)), ncoupl, maxpows, nhel\n    ! call stop_invalid_id(id) not possible here,\n    ! because 'print' and 'stop' are not allowed in pure functions.\n    if (id <= 0 .or. id > last_process_id) then\n      get_tree_colbasis_dim = 0\n    else\n      call process_handles(id)%tree_colbasis_dim(extcols, get_tree_colbasis_dim, ncoupl, maxpows, nhel)\n    end if\n  end function get_tree_colbasis_dim\n\n\n  pure function tree_colbasis_elemsize(id)\n    ! number of coloured external particles; used to declare array sizes\n    implicit none\n    integer, intent(in) :: id\n    integer :: tree_colbasis_elemsize\n    integer :: extcols(n_external(id)), ncolb, ncoupl, maxpows, nhel, ncolext\n    ! call stop_invalid_id(id) not possible here,\n    ! because 'print' and 'stop' are not allowed in pure functions.\n    if (id <= 0 .or. id > last_process_id) then\n      tree_colbasis_elemsize = 0\n    else\n      call process_handles(id)%tree_colbasis_dim(extcols, ncolb, ncoupl, maxpows, nhel)\n      ncolext = count(extcols /= 0)\n      tree_colbasis_elemsize = ncolext/2+ncolext-1\n      if (ncolext == 0) tree_colbasis_elemsize = 0\n    end if\n  end function tree_colbasis_elemsize\n\n\n  pure function get_nhel(id)\n    ! number of helicity configurations (all, not just non-vanishing); used to declare array sizes\n    implicit none\n    integer, intent(in) :: id\n    integer :: get_nhel\n    integer :: extcols(n_external(id)), ncolb, ncoupl, maxpows\n    ! call stop_invalid_id(id) not possible here,\n    ! because 'print' and 'stop' are not allowed in pure functions.\n    if (id <= 0 .or. id > last_process_id) then\n      get_nhel = 0\n    else\n      call process_handles(id)%tree_colbasis_dim(extcols, ncolb, ncoupl, maxpows, get_nhel)\n    end if\n  end function get_nhel\n\n\n  subroutine tree_colbasis(id, basis, needed)\n    use ol_generic, only: compositions2, nth_permutation\n    implicit none\n    integer, intent(in) :: id\n    integer, intent(out) :: basis(:,:)\n    integer, intent(out) :: needed(:,:)\n    integer :: extcols(n_external(id)), ncolb, ncoupl, maxpows, nhel\n    integer, allocatable :: pbasis(:,:), selected_powers(:,:), perm(:), compos(:,:), compo(:), basiselem(:)\n    integer :: ncolext, i, j, k, m, needij\n    integer :: ncol2ext(n_external(id)), invextperm(n_external(id))\n    logical :: powok\n    call stop_invalid_id(id)\n    if (error > 1) return\n    call process_handles(id)%tree_colbasis_dim(extcols, ncolb, ncoupl, maxpows, nhel)\n    ! number of coloured external particles\n    ncolext = 0\n    do i = 1, size(extcols)\n      if (extcols(i) /= 0) then\n        ncolext = ncolext + 1\n        ncol2ext(ncolext) = i\n      end if\n    end do\n    do i = 1, size(invextperm)\n      invextperm(process_handles(id)%permutation(i)) = i\n    end do\n    allocate(pbasis(ncoupl+2,ncolb))\n    allocate(selected_powers(maxpows,ncoupl))\n    allocate(perm(ncolext))\n    call compositions2(compos, ncolext)\n    allocate(compo(size(compos,1)))\n    allocate(basiselem(ncolext/2+ncolext-1))\n    call process_handles(id)%tree_colbasis(pbasis, selected_powers)\n    do i = 1, ncolb\n      do j = i, ncolb\n        needij = 1\n        do k = 1, ncoupl\n          powok = .false.\n          do m = 1, maxpows\n            if (pbasis(2+k,i) + pbasis(2+k,j) == selected_powers(m,k)) then\n              powok = .true.\n              exit\n            end if\n          end do\n          if (.not. powok) then\n            needij = 0\n            exit\n          end if\n        end do\n        needed(i,j) = needij\n        needed(j,i) = needij\n      end do\n      ! TODO:\n      ! - apply crossing\n      compo = compos(:,pbasis(1,i))\n      perm = nth_permutation([(k, k=1, ncolext)], pbasis(2,i))\n      basiselem = 0\n      m = 1\n      do j = 1, count(compo > 0)\n        do k = 1, compo(j)\n          basiselem(m+j-1) = invextperm(ncol2ext(perm(m)))\n          m = m + 1\n        end do\n      end do\n      basis(:,i) = basiselem\n    end do\n    deallocate(pbasis)\n    deallocate(selected_powers)\n    deallocate(perm)\n    deallocate(compos)\n    deallocate(compo)\n    deallocate(basiselem)\n  end subroutine tree_colbasis\n\n\n  subroutine tree_colbasis_c(id, basis, needed) bind(c,name=\"ol_tree_colbasis\")\n    implicit none\n    integer(c_int), value :: id\n    integer(c_int), intent(out) :: basis(tree_colbasis_elemsize(id),get_tree_colbasis_dim(id))\n    integer(c_int), intent(out) :: needed(get_tree_colbasis_dim(id),get_tree_colbasis_dim(id))\n    integer :: f_basis(tree_colbasis_elemsize(id),get_tree_colbasis_dim(id))\n    integer :: f_needed(get_tree_colbasis_dim(id),get_tree_colbasis_dim(id))\n    ! call stop_invalid_id(id) not needed here\n    call tree_colbasis(int(id), f_basis, f_needed)\n    basis = f_basis\n    needed = f_needed\n  end subroutine tree_colbasis_c\n\n\n  subroutine tree_colourflow(id, flowbasis)\n    ! Convert the trace colour basis for tree amplitudes from tree_colbasis()\n    ! to a colour flow basis and return it as a rank 3 integer array\n    ! flowbasis(2,nexternal,basissize). For each basis element and each\n    ! external particle it contains a pair (i,j) with the incoming fundamental\n    ! colour i and outgoing colour j. A zero entry means uncoloured.\n    ! Incoming quark / outgoing antiquark: (i,0)\n    ! Incoming antiquark / outgoing quark: (0,i)\n    ! In T(a1,a2,...,an)_ij, j connects to the gluon 'an' and to an incoming quark.\n    implicit none\n    integer, intent(in) :: id\n    integer, intent(out) :: flowbasis(2,n_external(id),get_tree_colbasis_dim(id))\n    integer :: tracebasis(tree_colbasis_elemsize(id),get_tree_colbasis_dim(id))\n    integer :: neededdummy(get_tree_colbasis_dim(id),get_tree_colbasis_dim(id))\n    integer :: ncolb, colelemsz, i, k, lastcol, startmon, endmon\n    integer :: powersof2(n_external(id))\n\n    ncolb = size(tracebasis,2)\n    colelemsz = size(tracebasis,1)\n    flowbasis = 0\n    call tree_colbasis(id, tracebasis, neededdummy)\n\n    do k = 1, ncolb ! for each basis element\n      do lastcol = colelemsz, 1, -1\n        ! size of trace basis element with trailing zeroes dropped\n        if (tracebasis(lastcol,k) /= 0) exit\n      end do\n      if (lastcol == 0) then\n        ! no coloured external particles\n        return\n      end if\n      startmon = 1\n      do ! for each colour monomial\n        endmon = locateval(tracebasis(:lastcol,k), 0, startmon) - 1\n        if (endmon <= 0) endmon = lastcol\n        if (any(process_handles(id)%extid(tracebasis(endmon,k)) == pdgadjoint)) then\n          ! if the last index is adjoint (gluon),\n          ! the monomial is a trace\n          call tracetoflow(tracebasis(startmon:endmon,k), flowbasis(:,:,k))\n        else\n          ! the monomial is a chain\n          call chaintoflow(tracebasis(startmon:endmon,k), flowbasis(:,:,k))\n        end if\n        startmon = endmon + 2\n        if (startmon > lastcol) exit\n      end do\n    end do\n\n  contains\n\n    function locateval(arr, val, startpos)\n      ! Return the first position (starting from startpos if present) in the\n      ! array arr which holds the value val, or -1 if val is not in arr(startpos:).\n      implicit none\n      integer :: locateval\n      integer, intent(in) :: arr(:), val\n      integer, intent(in), optional :: startpos\n      integer :: sp, k\n      sp = 1\n      if (present(startpos)) sp = startpos\n      if (sp < 1) sp = 1\n      locateval = -1\n      do k = sp, size(arr)\n        if (arr(k) == val) then\n          locateval = k\n          return\n        end if\n      end do\n    end function locateval\n\n    subroutine chaintoflow(colmon, flowbasisel)\n      ! Add information from the colour chain colmon\n      ! to the colour flow basis element flowbasisel.\n      implicit none\n      integer, intent(in) :: colmon(:)\n      integer, intent(inout) :: flowbasisel(:,:)\n      integer :: k, ng, colin, colout\n      ! chain T(a1,a2,...,an)_ij\n      ! number of gluons\n      ng = size(colmon) - 2\n      colin = colmon(ng+1)\n      flowbasisel(:,colmon(ng+1)) = [0,colin] ! anti-quark (0,i)\n      do k = 1, ng\n        ! (i,a1)(a1,a2)...(an-1,an)\n        colout = colmon(k)\n        flowbasisel(:,colout) = [colin,colout]\n        colin = colout\n      end do\n      flowbasisel(:,colmon(ng+2)) = [colin,0] ! quark (an,0), j->an\n    end subroutine chaintoflow\n\n    subroutine tracetoflow(colmon, flowbasisel)\n      ! Add information from the colour trace colmon\n      ! to the colour flow basis element flowbasisel.\n      implicit none\n      integer, intent(in) :: colmon(:)\n      integer, intent(inout) :: flowbasisel(:,:)\n      integer :: k, ng, colin, colout\n      ! trace T(a1,a2,...,an)\n      ! number of gluons\n      ng = size(colmon)\n      colin = colmon(ng)\n      do k = 1, ng\n        ! (a1,an)(a2,a1)...(an,an-1)\n        colout = colmon(k)\n        flowbasisel(:,colout) = [colin,colout]\n        colin = colout\n      end do\n    end subroutine tracetoflow\n\n  end subroutine tree_colourflow\n\n\n  subroutine tree_colourflow_c(id, flowbasis) bind(c,name=\"ol_tree_colourflow\")\n    ! C interface to tree_colourflow(). Return flowbasis as\n    ! int flowbasis[ncolb][nex][2];\n    implicit none\n    integer(c_int), value :: id\n    integer(c_int), intent(out) :: flowbasis(2,n_external(int(id)),get_tree_colbasis_dim(int(id)))\n    integer :: f_flowbasis(2,n_external(int(id)),get_tree_colbasis_dim(int(id)))\n    call tree_colourflow(int(id), f_flowbasis)\n    flowbasis = f_flowbasis\n  end subroutine tree_colourflow_c\n\n\n  subroutine start() bind(c,name=\"ol_start\")\n    use ol_parameters_decl_/**/DREALKIND,  only: &\n      & write_params_at_start, stability_logdir_not_created, stability_log, stability_logdir, &\n      & write_psp, ti_monitor\n    use ol_parameters_init_/**/DREALKIND, only: parameters_write\n    use ol_cwrappers, only: mkdir\n    implicit none\n    integer :: mkdirerr\n    call parameters_flush()\n    if (stability_logdir_not_created .and. (stability_log > 0 .or. &\n      & write_psp > 0 .or. ti_monitor > 0)) then\n      stability_logdir_not_created = .false.\n      mkdirerr = mkdir(stability_logdir)\n    end if\n    if (write_params_at_start) call parameters_write()\n  end subroutine\n\n\n  subroutine finish() bind(c,name=\"ol_finish\")\n    implicit none\n    call cleanup()\n    call unregister_processes()\n    if (shopping_list_open) close(fh_shopping)\n  end subroutine finish\n\n\n  subroutine evaluate_tree(id, psp, res)\n   ! Tree matrix element.\n   ! [in] id: process id as set by register_process\n   ! [in] psp: phase space point\n   ! [out] res: squared tree matrix element\n    use ol_generic, only: to_string\n    implicit none\n    integer, intent(in) :: id\n    real(DREALKIND), intent(in) :: psp(:,:)\n    real(DREALKIND), intent(out) :: res\n    real(DREALKIND) :: m2cc(0:n_external(id)*(n_external(id)+1)/2+1)\n    real(DREALKIND) :: resmunu(4,4)\n    type(process_handle) :: subprocess\n    call stop_invalid_id(id)\n    if (error > 1) return\n    subprocess = process_handles(id)\n    if (.not. btest(subprocess%content, 0)) then\n      call ol_fatal(\"evaluate: tree routine not available for process \" // trim(to_string(id)))\n      return\n    end if\n    n_scatt = subprocess%n_in\n    call tree_parameters_flush()\n    call subprocess%set_permutation(subprocess%permutation)\n    call subprocess%pol_init(subprocess%pol)\n    if (any(subprocess%photon_id /= 0)) call subprocess%set_photons(subprocess%photon_id)\n    call subprocess%tree(psp, m2cc, 0, &\n      & [0._/**/DREALKIND, 0._/**/DREALKIND, 0._/**/DREALKIND, 0._/**/DREALKIND], &\n      & 1, [0], resmunu)\n    res = m2cc(0)\n  end subroutine evaluate_tree\n\n\n  subroutine evaluate_tree_c(id, pp, res) bind(c,name=\"ol_evaluate_tree\")\n    implicit none\n    integer(c_int), value :: id\n    real(c_double), intent(in) :: pp(5*n_external(id))\n    real(c_double), intent(out) :: res\n    integer :: f_id\n    real(DREALKIND) :: f_pp(0:4,n_external(id))\n    real(DREALKIND) :: f_res\n    f_id = id\n    call stop_invalid_id(f_id) ! needed because of reshape\n    if (error > 1) return\n    f_pp = reshape(pp, [5,process_handles(id)%n_particles])\n    call evaluate_tree(f_id, f_pp(0:3,:), f_res)\n    res = f_res\n  end subroutine evaluate_tree_c\n\n\n  subroutine evaluate_tree_colvect(id, psp, amp, nhel)\n    ! Tree amplitude as colour vectors for each helicity configuration.\n    ! [in] id: process id as set by register_process\n    ! [in] psp: phase space point\n    ! [out] amp: amp(:,h) is the colour vector for helicity configuration h\n    ! [out] nhel: number of non-zero helicity configurations,\n    !       amp(:,nhel+1:) contains no information\n    use ol_ew_renormalisation_/**/REALKIND, only: photon_factors\n    implicit none\n    integer, intent(in) :: id\n    real(DREALKIND), intent(in) :: psp(:,:)\n    complex(DREALKIND), intent(out) :: amp(:,:)\n    integer, intent(out) :: nhel\n    real(DREALKIND) :: res, bornphotonfactor\n    call evaluate_tree(id, psp, res) ! fill colour vector cache\n    call process_handles(id)%tree_colvect(amp, nhel)\n    call photon_factors(process_handles(id)%photon_id, 0, bornphotonfactor)\n    amp = amp * sqrt(bornphotonfactor)\n  end subroutine evaluate_tree_colvect\n\n\n  subroutine evaluate_tree_colvect_c(id, pp, amp, nhel) bind(c,name=\"ol_evaluate_tree_colvect\")\n    implicit none\n    integer(c_int), value :: id\n    real(c_double), intent(in) :: pp(5*n_external(id))\n    real(c_double), intent(out) :: amp(2*get_tree_colbasis_dim(id),get_nhel(id))\n    integer(c_int), intent(out) :: nhel\n    real(c_double) :: res\n    complex(DREALKIND) :: f_amp(get_tree_colbasis_dim(id),get_nhel(id))\n    integer :: f_nhel, k, h\n    call evaluate_tree_c(id, pp, res) ! fill colour vector cache\n    call process_handles(int(id))%tree_colvect(f_amp, f_nhel)\n    do h = 1, f_nhel\n      do k = 1, size(f_amp,1)\n        amp(2*k-1,h) = real(f_amp(k,h))\n        amp(2*k,h) = aimag(f_amp(k,h))\n      end do\n    end do\n    nhel = f_nhel\n  end subroutine evaluate_tree_colvect_c\n\n\n  subroutine evaluate_tree_colvect2(id, psp, m2arr)\n    ! Helicity summed squared tree colour vector.\n    ! Apart from the missing colour factor these are the squared matrix elements\n    ! for each colour flow.\n    ! [in] id: process id as set by register_process\n    ! [in] psp: phase space point\n    ! [out] m2arr: array of squared matrix elements per colour flow\n    use ol_ew_renormalisation_/**/REALKIND, only: photon_factors\n    implicit none\n    integer, intent(in) :: id\n    real(DREALKIND), intent(in) :: psp(:,:)\n    real(DREALKIND), intent(out) :: m2arr(:)\n    integer :: nhel\n    real(DREALKIND) :: res, bornphotonfactor\n    complex(DREALKIND) :: amp(get_tree_colbasis_dim(id),get_nhel(id))\n    call evaluate_tree(id, psp, res) ! fill colour vector cache\n    call process_handles(id)%tree_colvect(amp, nhel)\n    m2arr = sum(real(amp(:,1:nhel)*conjg(amp(:,1:nhel))), 2)\n    call photon_factors(process_handles(id)%photon_id, 0, bornphotonfactor)\n    m2arr = m2arr * bornphotonfactor\n  end subroutine evaluate_tree_colvect2\n\n\n  subroutine evaluate_tree_colvect2_c(id, pp, m2arr) bind(c,name=\"ol_evaluate_tree_colvect2\")\n    implicit none\n    integer(c_int), value :: id\n    real(c_double), intent(in) :: pp(5*n_external(id))\n    real(c_double), intent(out) :: m2arr(get_tree_colbasis_dim(id))\n    integer :: nhel\n    real(c_double) :: res\n    complex(DREALKIND) :: amp(get_tree_colbasis_dim(id),get_nhel(id))\n    call evaluate_tree_c(id, pp, res) ! fill colour vector cache\n    call process_handles(int(id))%tree_colvect(amp, nhel)\n    m2arr = sum(real(amp(:,1:nhel)*conjg(amp(:,1:nhel))), 2)\n  end subroutine evaluate_tree_colvect2_c\n\n\n  subroutine evaluate_cc(id, psp, tree, cc, ewcc)\n   ! Independent color correlated tree matrix elements.\n   ! [in] id: process id as set by register_process\n   ! [in] psp: phase space point\n   ! [out] tree: Born matrix element\n   ! [out] cc(n_external*(n_external-1)/2): array with the indepenent color correlated\n   !       tree amplitudes C_ij = <M|T_iT_j|M>\n   !       cc(i+j(j-1)/2+1) = C_ij with 0 <= i < j <= n_external-1\n   ! [out] ewcc: charge correlation for EW i-operator\n    use ol_generic, only: to_string\n    implicit none\n    integer, intent(in) :: id\n    real(DREALKIND), intent(in) :: psp(:,:)\n    real(DREALKIND), intent(out) :: tree, cc(:), ewcc\n    type(process_handle) :: subprocess\n    real(DREALKIND) :: m2cc(0:n_external(id)*(n_external(id)+1)/2+1) ! keep +1 for compatibility\n    real(DREALKIND) :: resmunu(4,4)\n    integer  :: n_cc, i, j\n    call stop_invalid_id(id)\n    if (error > 1) return\n    subprocess = process_handles(id)\n    if (.not. btest(subprocess%content, 0)) then\n      call ol_fatal('evaluate: cc routine not available for process ' // trim(to_string(id)))\n      return\n    end if\n    n_scatt = subprocess%n_in\n    call subprocess%set_permutation(subprocess%permutation)\n    call subprocess%pol_init(subprocess%pol)\n    if (any(subprocess%photon_id /= 0)) call subprocess%set_photons(subprocess%photon_id)\n    n_cc = subprocess%n_particles*(subprocess%n_particles+1)/2\n    call tree_parameters_flush()\n    call subprocess%tree(psp, m2cc, 0, &\n      & [0._/**/DREALKIND, 0._/**/DREALKIND, 0._/**/DREALKIND, 0._/**/DREALKIND], &\n      & n_cc, [(i, i = 0, n_cc)], resmunu)\n    tree = m2cc(0)\n    ewcc = m2cc(n_cc+1)\n    do j = 1, subprocess%n_particles - 1\n      do i = 0, j - 1\n        cc(i+j*(j-1)/2+1) = m2cc((j+1)*j/2+i+1)\n      end do\n    end do\n  end subroutine evaluate_cc\n\n\n  subroutine evaluate_cc_c(id, pp, tree, cc, ewcc) bind(c,name=\"ol_evaluate_cc\")\n    implicit none\n    integer(c_int), value :: id\n    real(c_double), intent(in) :: pp(5*n_external(id))\n    real(c_double), intent(out) :: tree, cc(rval_size(n_external(id),2)), ewcc\n    integer :: f_id\n    real(DREALKIND) :: f_pp(0:4,n_external(id))\n    real(DREALKIND) :: f_tree, f_cc(rval_size(n_external(id),2)), f_ewcc\n    f_id = id\n    call stop_invalid_id(f_id) ! needed because of reshape\n    if (error > 1) return\n    f_pp = reshape(pp, [5,process_handles(id)%n_particles])\n    call evaluate_cc(f_id, f_pp(0:3,:), f_tree, f_cc, f_ewcc)\n    tree = f_tree\n    cc = f_cc\n    ewcc = f_ewcc\n  end subroutine evaluate_cc_c\n\n\n  subroutine evaluate_cc2(id, psp, res, cc, ewcc)\n   ! Independent color correlated loop^2 matrix elements.\n   ! [in] id: process id as set by register_process\n   ! [in] psp: phase space point\n   ! [out] res: loop^2 matrix element\n   ! [out] cc(n_external*(n_external-1)/2): array with the indepenent color correlated\n   !       loop^2 amplitudes C_ij = <M1|T_iT_j|M1>\n   !       cc(i+j(j-1)/2+1) = C_ij with 0 <= i < j <= n_external-1\n   ! [out] ewcc: charge correlation for EW i-operator\n    use ol_generic, only: to_string\n    use ol_data_types_/**/DREALKIND, only: correlator\n    implicit none\n    integer, intent(in) :: id\n    real(DREALKIND), intent(in) :: psp(:,:)\n    real(DREALKIND), intent(out) :: res, cc(:), ewcc\n    type(process_handle) :: subprocess\n    integer  :: n_cc, i, j\n    real(DREALKIND) :: m2l0, m2l1(0:2), ir1(0:2), m2l2(0:4), ir2(0:4), acc\n    type(correlator) :: Lcc\n    call stop_invalid_id(id)\n    if (error > 1) return\n    subprocess = process_handles(id)\n    if (.not. btest(subprocess%content, 2)) then\n      call ol_fatal('evaluate: cc2 routine not available for process ' // trim(to_string(id)))\n      return\n    end if\n    n_scatt = subprocess%n_in\n    call subprocess%set_permutation(subprocess%permutation)\n    call subprocess%pol_init(subprocess%pol)\n    if (any(subprocess%photon_id /= 0)) call subprocess%set_photons(subprocess%photon_id)\n    n_cc = subprocess%n_particles*(subprocess%n_particles+1)/2\n    call parameters_flush()\n    Lcc%type=1\n    allocate(Lcc%rescc(0:n_external(id)*(n_external(id)+1)/2+1))\n    call evaluate_fullcr(id, psp, m2l0, m2l1, ir1, m2l2, ir2, Lcc, acc)\n    res = Lcc%rescc(0)\n    ewcc = Lcc%rescc(n_cc+1)\n    do j = 1, subprocess%n_particles - 1\n      do i = 0, j - 1\n        cc(i+j*(j-1)/2+1) = Lcc%rescc((j+1)*j/2+i+1)\n      end do\n    end do\n    deallocate(Lcc%rescc)\n  end subroutine evaluate_cc2\n\n\n  subroutine evaluate_cc2_c(id, pp, res, cc, ewcc) bind(c,name=\"ol_evaluate_cc2\")\n    implicit none\n    integer(c_int), value :: id\n    real(c_double), intent(in) :: pp(5*n_external(id))\n    real(c_double), intent(out) :: res, cc(rval_size(n_external(id),2)), ewcc\n    integer :: f_id\n    real(DREALKIND) :: f_pp(0:4,n_external(id))\n    real(DREALKIND) :: f_res, f_cc(rval_size(n_external(id),2)), f_ewcc\n    f_id = id\n    call stop_invalid_id(f_id) ! needed because of reshape\n    if (error > 1) return\n    f_pp = reshape(pp, [5,process_handles(id)%n_particles])\n    call evaluate_cc2(f_id, f_pp(0:3,:), f_res, f_cc, f_ewcc)\n    res = f_res\n    cc = f_cc\n    ewcc = f_ewcc\n  end subroutine evaluate_cc2_c\n\n\n  subroutine evaluate_loopcc(id, psp, m2l0, m2l1, cc, ewcc)\n   ! Independent color correlated born X loop matrix elements.\n   ! [in] id: process id as set by register_process\n   ! [in] psp: phase space point\n   ! [out] m2l0: born matrix element\n   ! [out] m2l1: born X loop matrix element\n   ! [out] cc(n_external*(n_external-1)/2): array with the indepenent color correlated\n   !       born X loop C_ij = <M0|T_iT_j|M1>\n   !       cc(i+j(j-1)/2+1) = C_ij with 0 <= i < j <= n_external-1\n   ! [out] ewcc: charge correlation for EW i-operator\n    use ol_generic, only: to_string\n    use ol_data_types_/**/DREALKIND, only: correlator\n    implicit none\n    integer, intent(in) :: id\n    real(DREALKIND), intent(in) :: psp(:,:)\n    real(DREALKIND), intent(out) :: m2l0, m2l1(0:2), cc(:), ewcc\n    type(process_handle) :: subprocess\n    integer  :: n_cc, i, j\n    real(DREALKIND) :: ir1(0:2), m2l2(0:4), ir2(0:4), acc\n    type(correlator) :: Lcc\n    call stop_invalid_id(id)\n    if (error > 1) return\n    subprocess = process_handles(id)\n    if (.not. btest(subprocess%content, 1)) then\n      call ol_fatal('evaluate: loopcc routine not available for process ' // trim(to_string(id)))\n      return\n    end if\n    if (.not. associated(subprocess%loopcr)) then\n      call ol_fatal('evaluate: loopcc routine not available for process ' // trim(to_string(id)))\n      return\n    end if\n    n_scatt = subprocess%n_in\n    call subprocess%set_permutation(subprocess%permutation)\n    call subprocess%pol_init(subprocess%pol)\n    if (any(subprocess%photon_id /= 0)) call subprocess%set_photons(subprocess%photon_id)\n    n_cc = subprocess%n_particles*(subprocess%n_particles+1)/2\n    call parameters_flush()\n    Lcc%type=11\n    allocate(Lcc%rescc(0:n_external(id)*(n_external(id)+1)/2+1))\n    call evaluate_fullcr(id, psp, m2l0, m2l1, ir1, m2l2, ir2, Lcc, acc)\n    ewcc = Lcc%rescc(n_cc+1)\n    do j = 1, subprocess%n_particles - 1\n      do i = 0, j - 1\n        cc(i+j*(j-1)/2+1) = Lcc%rescc((j+1)*j/2+i+1)\n      end do\n    end do\n    deallocate(Lcc%rescc)\n  end subroutine evaluate_loopcc\n\n\n  subroutine evaluate_loopcc_c(id, pp, m2l0, m2l1, cc, ewcc) bind(c,name=\"ol_evaluate_loopcc\")\n    implicit none\n    integer(c_int), value :: id\n    real(c_double), intent(in) :: pp(5*n_external(id))\n    real(c_double), intent(out) :: m2l0, m2l1(0:2), cc(rval_size(n_external(id),2)), ewcc\n    integer :: f_id\n    real(DREALKIND) :: f_pp(0:4,n_external(id))\n    real(DREALKIND) :: f_m2l0, f_m2l1(0:2), f_cc(rval_size(n_external(id),2)), f_ewcc\n    f_id = id\n    call stop_invalid_id(f_id) ! needed because of reshape\n    if (error > 1) return\n    f_pp = reshape(pp, [5,process_handles(id)%n_particles])\n    call evaluate_loopcc(f_id, f_pp(0:3,:), f_m2l0, f_m2l1, f_cc, f_ewcc)\n    m2l0 = f_m2l0\n    m2l1 = f_m2l1\n    cc = f_cc\n    ewcc = f_ewcc\n  end subroutine evaluate_loopcc_c\n\n\n  subroutine evaluate_ccmatrix(id, psp, tree, ccij, ewcc)\n   ! Color correlated tree matrix elements.\n   ! [in] id: process id as set by register_process\n   ! [in] psp: phase space point\n   ! [out] tree: squared born matrix element\n   ! [out] cc(n_external:n_external): array with the color correlated\n   !       tree amplitudes C_ij = <M|T_iT_j|M>\n   !       cc(i,j) = C_ij with i,j = 1 <= n_external\n   ! [out] ewcc: charge correlation for EW i-operator\n    use ol_generic, only: to_string\n    implicit none\n    integer, intent(in) :: id\n    real(DREALKIND), intent(in) :: psp(:,:)\n    real(DREALKIND), intent(out) :: tree, ccij(:,:), ewcc\n    type(process_handle) :: subprocess\n    real(DREALKIND) :: m2cc(0:n_external(id)*(n_external(id)+1)/2+1)\n    integer  :: n_cc, i, j\n    real(DREALKIND) :: resmunu(4,4)\n    call stop_invalid_id(id)\n    if (error > 1) return\n    subprocess = process_handles(id)\n    if (.not. btest(subprocess%content, 0)) then\n      call ol_fatal('evaluate: ccmatrix routine not available for process ' // trim(to_string(id)))\n      return\n    end if\n    n_scatt = subprocess%n_in\n    call subprocess%set_permutation(subprocess%permutation)\n    call subprocess%pol_init(subprocess%pol)\n    if (any(subprocess%photon_id /= 0)) call subprocess%set_photons(subprocess%photon_id)\n    n_cc = subprocess%n_particles*(subprocess%n_particles+1)/2+1\n    call tree_parameters_flush()\n    call subprocess%tree(psp, m2cc, 0, &\n      & [0._/**/DREALKIND, 0._/**/DREALKIND, 0._/**/DREALKIND, 0._/**/DREALKIND], &\n      & n_cc, [(i, i = 0, n_cc)], resmunu)\n    do i = 1, subprocess%n_particles\n      do j = 1, i\n        ccij(i,j) = m2cc(i*(i-1)/2+j)\n        if (i /= j) ccij(j,i) = ccij(i,j)\n      end do\n    end do\n    tree = m2cc(0)\n    ewcc = m2cc(n_cc)\n  end subroutine evaluate_ccmatrix\n\n\n  subroutine evaluate_ccmatrix_c(id, pp, tree, ccij, ewcc) bind(c,name=\"ol_evaluate_ccmatrix\")\n    implicit none\n    integer(c_int), value :: id\n    real(c_double), intent(in) :: pp(5*n_external(id))\n    real(c_double), intent(out) :: tree, ccij(n_external(id)*n_external(id)), ewcc\n    integer :: f_id\n    real(DREALKIND) :: f_pp(0:4,n_external(id))\n    real(DREALKIND) :: f_tree, f_ccij(n_external(id),n_external(id)), f_ewcc\n    f_id = id\n    call stop_invalid_id(f_id) ! needed because of reshape\n    if (error > 1) return\n    f_pp = reshape(pp, [5,process_handles(id)%n_particles])\n    call evaluate_ccmatrix(f_id, f_pp(0:3,:), f_tree, f_ccij, f_ewcc)\n    tree = f_tree\n    ccij = reshape(f_ccij,(/n_external(id)*n_external(id)/))\n    ewcc = f_ewcc\n  end subroutine evaluate_ccmatrix_c\n\n\n  subroutine evaluate_ccmatrix2(id, psp, res, ccij, ewcc)\n   ! Color correlated loop^2 matrix elements.\n   ! [in] id: process id as set by register_process\n   ! [in] psp: phase space point\n   ! [out] res: loop^2 matrix element\n   ! [out] cc(n_external:n_external): array with the color correlated\n   !       loop^2 amplitudes C_ij = <M|T_iT_j|M>\n   !       cc(i,j) = C_ij with i,j = 1 <= n_external\n   ! [out] ewcc: charge correlation for EW i-operator\n    use ol_generic, only: to_string\n    use ol_data_types_/**/DREALKIND, only: correlator\n    implicit none\n    integer, intent(in) :: id\n    real(DREALKIND), intent(in) :: psp(:,:)\n    real(DREALKIND), intent(out) :: res, ccij(:,:), ewcc\n    real(DREALKIND) :: m2l0, m2l1(0:2), ir1(0:2), m2l2(0:4), ir2(0:4), acc\n    type(process_handle) :: subprocess\n    integer  :: n_cc, i, j\n    type(correlator) :: Lcc\n    call stop_invalid_id(id)\n    if (error > 1) return\n    subprocess = process_handles(id)\n    if (.not. btest(subprocess%content, 2)) then\n      call ol_fatal('evaluate: ccmatrix2 routine not available for process ' // trim(to_string(id)))\n      return\n    end if\n    n_scatt = subprocess%n_in\n    call subprocess%set_permutation(subprocess%permutation)\n    call subprocess%pol_init(subprocess%pol)\n    if (any(subprocess%photon_id /= 0)) call subprocess%set_photons(subprocess%photon_id)\n    n_cc = subprocess%n_particles*(subprocess%n_particles+1)/2+1\n    call parameters_flush()\n    Lcc%type=1\n    allocate(Lcc%rescc(0:n_external(id)*(n_external(id)+1)/2+1))\n    call evaluate_fullcr(id, psp, m2l0, m2l1, ir1, m2l2, ir2, Lcc, acc)\n    do i = 1, subprocess%n_particles\n      do j = 1, i\n        ccij(i,j) = Lcc%rescc(i*(i-1)/2+j)\n        if (i /= j) ccij(j,i) = ccij(i,j)\n      end do\n    end do\n    res = Lcc%rescc(0)\n    ewcc = Lcc%rescc(n_cc)\n    deallocate(Lcc%rescc)\n  end subroutine evaluate_ccmatrix2\n\n\n  subroutine evaluate_ccmatrix2_c(id, pp, res, ccij, ewcc) bind(c,name=\"ol_evaluate_ccmatrix2\")\n    implicit none\n    integer(c_int), value :: id\n    real(c_double), intent(in) :: pp(5*n_external(id))\n    real(c_double), intent(out) :: res, ccij(n_external(id)*n_external(id)), ewcc\n    integer :: f_id\n    real(DREALKIND) :: f_pp(0:4,n_external(id))\n    real(DREALKIND) :: f_res, f_ccij(n_external(id),n_external(id)), f_ewcc\n    f_id = id\n    call stop_invalid_id(f_id) ! needed because of reshape\n    if (error > 1) return\n    f_pp = reshape(pp, [5,process_handles(id)%n_particles])\n    call evaluate_ccmatrix2(f_id, f_pp(0:3,:), f_res, f_ccij, f_ewcc)\n    res = f_res\n    ccij = reshape(f_ccij,(/n_external(id)*n_external(id)/))\n    ewcc = f_ewcc\n  end subroutine evaluate_ccmatrix2_c\n\n\n  subroutine evaluate_loopccmatrix(id, psp, m2l0, m2l1, ccij, ewcc)\n   ! Color correlated tree matrix elements.\n   ! [in] id: process id as set by register_process\n   ! [in] psp: phase space point\n   ! [out] tree: squared born matrix element\n   ! [out] cc(n_external:n_external): array with the color correlated\n   !       tree amplitudes C_ij = <M|T_iT_j|M>\n   !       cc(i,j) = C_ij with i,j = 1 <= n_external\n   ! [out] ewcc: charge correlation for EW i-operator\n    use ol_generic, only: to_string\n    use ol_data_types_/**/DREALKIND, only: correlator\n    implicit none\n    integer, intent(in) :: id\n    real(DREALKIND), intent(in) :: psp(:,:)\n    real(DREALKIND), intent(out) :: m2l0, m2l1(0:2), ccij(:,:), ewcc\n    type(process_handle) :: subprocess\n    real(DREALKIND) :: m2cc(0:n_external(id)*(n_external(id)+1)/2+1)\n    real(DREALKIND) :: ir1(0:2), m2l2(0:4), ir2(0:4), acc\n    integer  :: n_cc, i, j\n    type(correlator) :: Lcc\n    call stop_invalid_id(id)\n    if (error > 1) return\n    subprocess = process_handles(id)\n    if (.not. btest(subprocess%content, 1)) then\n      call ol_fatal('evaluate: loopccmatrix routine not available for process ' // trim(to_string(id)))\n      return\n    end if\n    n_scatt = subprocess%n_in\n    call subprocess%set_permutation(subprocess%permutation)\n    call subprocess%pol_init(subprocess%pol)\n    if (any(subprocess%photon_id /= 0)) call subprocess%set_photons(subprocess%photon_id)\n    n_cc = subprocess%n_particles*(subprocess%n_particles+1)/2\n    call parameters_flush()\n    Lcc%type=11\n    allocate(Lcc%rescc(0:n_cc+1))\n    call evaluate_fullcr(id, psp, m2l0, m2l1, ir1, m2l2, ir2, Lcc, acc)\n    ewcc = Lcc%rescc(n_cc+1)\n    do i = 1, subprocess%n_particles\n      do j = 1, i\n        ccij(i,j) = Lcc%rescc(i*(i-1)/2+j)\n        if (i /= j) ccij(j,i) = ccij(i,j)\n      end do\n    end do\n    deallocate(Lcc%rescc)\n  end subroutine evaluate_loopccmatrix\n\n\n  subroutine evaluate_loopccmatrix_c(id, pp, m2l0, m2l1, ccij, ewcc) bind(c,name=\"ol_evaluate_loopccmatrix\")\n    implicit none\n    integer(c_int), value :: id\n    real(c_double), intent(in) :: pp(5*n_external(id))\n    real(c_double), intent(out) :: m2l0, m2l1(0:2), ccij(n_external(id)*n_external(id)), ewcc\n    integer :: f_id\n    real(DREALKIND) :: f_pp(0:4,n_external(id))\n    real(DREALKIND) :: f_m2l0, f_m2l1(0:2), f_ccij(n_external(id),n_external(id)), f_ewcc\n    f_id = id\n    call stop_invalid_id(f_id) ! needed because of reshape\n    if (error > 1) return\n    f_pp = reshape(pp, [5,process_handles(id)%n_particles])\n    call evaluate_loopccmatrix(f_id, f_pp(0:3,:), f_m2l0, f_m2l1, f_ccij, f_ewcc)\n    m2l0 = f_m2l0\n    m2l1 = f_m2l1\n    ccij = reshape(f_ccij,(/n_external(id)*n_external(id)/))\n    ewcc = f_ewcc\n  end subroutine evaluate_loopccmatrix_c\n\n\n  subroutine evaluate_ccewmatrix(id, psp, tree, ccij)\n   ! Charge correlated tree matrix elements.\n   ! [in] id: process id as set by register_process\n   ! [in] psp: phase space point\n   ! [out] tree: squared born matrix element\n   ! [out] cc(n_external:n_external): array with the charge correlated\n   !       tree amplitudes C_ij = <M|Q_iQ_j|M>\n   !       cc(i,j) = C_ij with i,j = 1 <= n_external\n   ! [out] ewcc: charge correlation for EW i-operator\n    use ol_generic, only: to_string\n    implicit none\n    integer, intent(in) :: id\n    real(DREALKIND), intent(in) :: psp(:,:)\n    real(DREALKIND), intent(out) :: tree, ccij(:,:)\n    type(process_handle) :: subprocess\n    integer  :: i, j\n    call stop_invalid_id(id)\n    if (error > 1) return\n    subprocess = process_handles(id)\n    if (.not. btest(subprocess%content, 0)) then\n      call ol_fatal('evaluate: ccewmatrix routine not available for process ' // trim(to_string(id)))\n      return\n    end if\n    call evaluate_tree(id,psp,tree)\n    do i = 1, subprocess%n_particles\n      do j = 1, i\n        ccij(i,j) = tree*ewcharge(subprocess%extid(i))*ewcharge(subprocess%extid(j))\n        if (i /= j) ccij(j,i) = ccij(i,j)\n      end do\n    end do\n  end subroutine evaluate_ccewmatrix\n\n\n  subroutine evaluate_ccewmatrix_c(id, pp, tree, ccij) bind(c,name=\"ol_evaluate_ccewmatrix\")\n    implicit none\n    integer(c_int), value :: id\n    real(c_double), intent(in) :: pp(5*n_external(id))\n    real(c_double), intent(out) :: tree, ccij(n_external(id)*n_external(id))\n    integer :: f_id\n    real(DREALKIND) :: f_pp(0:4,n_external(id))\n    real(DREALKIND) :: f_tree, f_ccij(n_external(id),n_external(id))\n    f_id = id\n    call stop_invalid_id(f_id) ! needed because of reshape\n    if (error > 1) return\n    f_pp = reshape(pp, [5,process_handles(id)%n_particles])\n    call evaluate_ccewmatrix(f_id, f_pp(0:3,:), f_tree, f_ccij)\n    tree = f_tree\n    ccij = reshape(f_ccij,(/n_external(id)*n_external(id)/))\n  end subroutine evaluate_ccewmatrix_c\n\n\n  subroutine evaluate_ccewmatrix2(id, psp, res, ccij)\n   ! Charge correlated loop-squared matrix elements.\n   ! [in] id: process id as set by register_process\n   ! [in] psp: phase space point\n   ! [out] res: squared loop matrix element\n   ! [out] cc(n_external:n_external): array with the charge correlated\n   !       tree amplitudes C_ij = <M|Q_iQ_j|M>\n   !       cc(i,j) = C_ij with i,j = 1 <= n_external\n   ! [out] ewcc: charge correlation for EW i-operator\n    use ol_generic, only: to_string\n    implicit none\n    integer, intent(in) :: id\n    real(DREALKIND), intent(in) :: psp(:,:)\n    real(DREALKIND), intent(out) :: res, ccij(:,:)\n    real(DREALKIND) :: acc\n    type(process_handle) :: subprocess\n    integer  :: i, j\n    call stop_invalid_id(id)\n    if (error > 1) return\n    subprocess = process_handles(id)\n    if (.not. btest(subprocess%content, 2)) then\n      call ol_fatal('evaluate: ccewmatrix routine not available for process ' // trim(to_string(id)))\n      return\n    end if\n    call evaluate_loop2(id,psp,res,acc)\n    do i = 1, subprocess%n_particles\n      do j = 1, i\n        ccij(i,j) = res*ewcharge(subprocess%extid(i))*ewcharge(subprocess%extid(j))\n        if (i /= j) ccij(j,i) = ccij(i,j)\n      end do\n    end do\n  end subroutine evaluate_ccewmatrix2\n\n\n  subroutine evaluate_ccewmatrix2_c(id, pp, res, ccij) bind(c,name=\"ol_evaluate_ccewmatrix2\")\n    implicit none\n    integer(c_int), value :: id\n    real(c_double), intent(in) :: pp(5*n_external(id))\n    real(c_double), intent(out) :: res, ccij(n_external(id)*n_external(id))\n    integer :: f_id\n    real(DREALKIND) :: f_pp(0:4,n_external(id))\n    real(DREALKIND) :: f_res, f_ccij(n_external(id),n_external(id))\n    f_id = id\n    call stop_invalid_id(f_id) ! needed because of reshape\n    if (error > 1) return\n    f_pp = reshape(pp, [5,process_handles(id)%n_particles])\n    call evaluate_ccewmatrix2(f_id, f_pp(0:3,:), f_res, f_ccij)\n    res = f_res\n    ccij = reshape(f_ccij,(/n_external(id)*n_external(id)/))\n  end subroutine evaluate_ccewmatrix2_c\n\n\n  subroutine evaluate_sc(id, psp, emitter, polvect, res)\n    ! Spin correlated matrix elements.\n    ! [in] id: process id as set by register_process\n    ! [in] psp: phase space point\n    ! [in] int emitter: emitter\n    ! [in] polvect: polarisation vector\n    ! [out] res(n_external): array with results for each spectator j,\n    !       res(j) = 1/mom^2 * <emitter,mu|mom^mu cc_ij mom^nu|j,nu>\n    use ol_generic, only: to_string\n    implicit none\n    integer, intent(in) :: id, emitter\n    real(DREALKIND), intent(in) :: psp(:,:), polvect(4)\n    real(DREALKIND), intent(out) :: res(:)\n    type(process_handle) :: subprocess\n    integer :: j, extcombs(n_external(id)), nextcombs\n    real(DREALKIND) :: m2sc(0:n_external(id)*(n_external(id)+1)/2+1)\n    real(DREALKIND) :: resmunu(4,4)\n    call stop_invalid_id(id)\n    if (error > 1) return\n    subprocess = process_handles(id)\n    if (.not. btest(subprocess%content, 0)) then\n      call ol_fatal('evaluate: sc routine not available for process ' // trim(to_string(id)))\n      return\n    end if\n    if (subprocess%extid(emitter) == 21) then\n      do j = 1, subprocess%n_particles\n        if (j <= emitter) then\n          extcombs(j) = emitter*(emitter-1)/2 + j\n        else\n          extcombs(j) = j*(j-1)/2 + emitter\n        end if\n      end do\n      nextcombs = subprocess%n_particles\n    else if (subprocess%extid(emitter) == 22) then    ! no color insertions for photon emitter\n      extcombs = 0\n      nextcombs = 1\n    else\n      res = 0\n      return\n    end if\n    n_scatt = subprocess%n_in\n    call tree_parameters_flush()\n    call subprocess%set_permutation(subprocess%permutation)\n    call subprocess%pol_init(subprocess%pol)\n    if (any(subprocess%photon_id /= 0)) call subprocess%set_photons(subprocess%photon_id)\n    call subprocess%tree(psp, m2sc, emitter, polvect, nextcombs, extcombs, resmunu)\n    do j = 1, subprocess%n_particles\n      res(j) = m2sc(extcombs(j))\n    end do\n  end subroutine evaluate_sc\n\n\n  subroutine evaluate_sc_c(id, pp, emitter, polvect, res) bind(c,name=\"ol_evaluate_sc\")\n    implicit none\n    integer(c_int), value :: id, emitter\n    real(c_double), intent(in) :: pp(5*n_external(id)), polvect(4)\n    real(c_double), intent(out) :: res(n_external(id))\n    integer :: f_id, f_emitter\n    real(DREALKIND) :: f_pp(0:4,n_external(id)), f_polvect(4)\n    real(DREALKIND) :: f_res(n_external(id))\n    f_id = id\n    call stop_invalid_id(f_id) ! needed because of reshape\n    if (error > 1) return\n    f_pp = reshape(pp, [5,process_handles(id)%n_particles])\n    f_emitter = emitter\n    f_polvect = polvect\n    call evaluate_sc(f_id, f_pp(0:3,:), f_emitter, f_polvect, f_res)\n    res = f_res\n  end subroutine evaluate_sc_c\n\n\n  subroutine evaluate_sc2(id, psp, emitter, polvect, res)\n    ! Spin correlated loop^2 matrix elements.\n    ! [in] id: process id as set by register_process\n    ! [in] psp: phase space point\n    ! [in] int emitter: emitter\n    ! [in] polvect: polarisation vector\n    ! [out] res(n_external): array with results for each spectator j,\n    !       res(j) = 1/mom^2 * <emitter,mu|mom^mu cc_ij mom^nu|j,nu>\n    use ol_generic, only: to_string\n    use ol_data_types_/**/DREALKIND, only: correlator\n    implicit none\n    integer, intent(in) :: id, emitter\n    real(DREALKIND), intent(in) :: psp(:,:), polvect(4)\n    real(DREALKIND), intent(out) :: res(:)\n    type(process_handle) :: subprocess\n    integer :: j, extcombs(n_external(id)), nextcombs\n    real(DREALKIND) :: m2l0, m2l1(0:2), ir1(0:2), m2l2(0:4), ir2(0:4), acc\n    type(correlator) :: Lsc\n    call stop_invalid_id(id)\n    if (error > 1) return\n    subprocess = process_handles(id)\n    if (.not. btest(subprocess%content, 2)) then\n      call ol_fatal('evaluate: sc2 routine not available for process ' // trim(to_string(id)))\n      return\n    end if\n    if (subprocess%extid(emitter) == 21) then ! color insertions for gluon emitter\n      do j = 1, subprocess%n_particles\n        if (j <= emitter) then\n          extcombs(j) = emitter*(emitter-1)/2 + j\n        else\n          extcombs(j) = j*(j-1)/2 + emitter\n        end if\n      end do\n      nextcombs = subprocess%n_particles\n    else if (subprocess%extid(emitter) == 22) then    ! no color insertions for photon emitter\n      extcombs = 0\n      nextcombs = 1\n    else\n      res = 0\n      return\n    end if\n    n_scatt = subprocess%n_in\n    call subprocess%set_permutation(subprocess%permutation)\n    call subprocess%pol_init(subprocess%pol)\n    if (any(subprocess%photon_id /= 0)) call subprocess%set_photons(subprocess%photon_id)\n    call parameters_flush()\n    Lsc%type=2\n    Lsc%emitter=emitter\n    Lsc%mom=polvect\n    Lsc%nextcombs=nextcombs\n    allocate(Lsc%extcombs(nextcombs))\n    Lsc%extcombs = extcombs\n    allocate(Lsc%rescc(0:n_external(id)*(n_external(id)+1)/2+1))\n    call evaluate_fullcr(id, psp, m2l0, m2l1, ir1, m2l2, ir2, Lsc, acc)\n    do j = 1, subprocess%n_particles\n      res(j) = Lsc%rescc(extcombs(j))\n    end do\n    deallocate(Lsc%extcombs)\n    deallocate(Lsc%rescc)\n  end subroutine evaluate_sc2\n\n\n  subroutine evaluate_sc2_c(id, pp, emitter, polvect, res) bind(c,name=\"ol_evaluate_sc2\")\n    implicit none\n    integer(c_int), value :: id, emitter\n    real(c_double), intent(in) :: pp(5*n_external(id)), polvect(4)\n    real(c_double), intent(out) :: res(n_external(id))\n    integer :: f_id, f_emitter\n    real(DREALKIND) :: f_pp(0:4,n_external(id)), f_polvect(4)\n    real(DREALKIND) :: f_res(n_external(id))\n    f_id = id\n    call stop_invalid_id(f_id) ! needed because of reshape\n    if (error > 1) return\n    f_pp = reshape(pp, [5,process_handles(id)%n_particles])\n    f_emitter = emitter\n    f_polvect = polvect\n    call evaluate_sc2(f_id, f_pp(0:3,:), f_emitter, f_polvect, f_res)\n    res = f_res\n   end subroutine evaluate_sc2_c\n\n\n  subroutine evaluate_loopsc(id, psp, emitter, polvect, res)\n    ! Spin correlated boonXloop matrix elements.\n    ! [in] id: process id as set by register_process\n    ! [in] psp: phase space point\n    ! [in] int emitter: emitter\n    ! [in] polvect: polarisation vector\n    ! [out] res(n_external): array with results for each spectator j,\n    !       res(j) = 1/mom^2 * <emitter,mu|mom^mu cc_ij mom^nu|j,nu>\n    use ol_generic, only: to_string\n    use ol_data_types_/**/DREALKIND, only: correlator\n    implicit none\n    integer, intent(in) :: id, emitter\n    real(DREALKIND), intent(in) :: psp(:,:), polvect(4)\n    real(DREALKIND), intent(out) :: res(:)\n    type(process_handle) :: subprocess\n    integer :: j, extcombs(n_external(id)), nextcombs\n    real(DREALKIND) :: m2l0, m2l1(0:2), ir1(0:2), m2l2(0:4), ir2(0:4), acc\n    type(correlator) :: Lsc\n    call stop_invalid_id(id)\n    if (error > 1) return\n    subprocess = process_handles(id)\n    if (.not. btest(subprocess%content, 1)) then\n      call ol_fatal('evaluate: loopsc routine not available for process ' // trim(to_string(id)))\n      return\n    end if\n    if (subprocess%extid(emitter) == 21) then ! color insertions for gluon emitter\n      do j = 1, subprocess%n_particles\n        if (j <= emitter) then\n          extcombs(j) = emitter*(emitter-1)/2 + j\n        else\n          extcombs(j) = j*(j-1)/2 + emitter\n        end if\n      end do\n      nextcombs = subprocess%n_particles\n    else if (subprocess%extid(emitter) == 22) then    ! no color insertions for photon emitter\n      extcombs = 0\n      nextcombs = 1\n    else\n      res = 0\n      return\n    end if\n    n_scatt = subprocess%n_in\n    call subprocess%set_permutation(subprocess%permutation)\n    call subprocess%pol_init(subprocess%pol)\n    if (any(subprocess%photon_id /= 0)) call subprocess%set_photons(subprocess%photon_id)\n    call parameters_flush()\n    Lsc%type=12\n    Lsc%emitter=emitter\n    Lsc%mom=polvect\n    Lsc%nextcombs=nextcombs\n    allocate(Lsc%extcombs(nextcombs))\n    Lsc%extcombs = extcombs\n    allocate(Lsc%rescc(0:n_external(id)*(n_external(id)+1)/2+1))\n    call evaluate_fullcr(id, psp, m2l0, m2l1, ir1, m2l2, ir2, Lsc, acc)\n    do j = 1, subprocess%n_particles\n      res(j) = Lsc%rescc(extcombs(j))\n    end do\n    deallocate(Lsc%extcombs)\n    deallocate(Lsc%rescc)\n  end subroutine evaluate_loopsc\n\n\n  subroutine evaluate_loopsc_c(id, pp, emitter, polvect, res) bind(c,name=\"ol_evaluate_loopsc\")\n    implicit none\n    integer(c_int), value :: id, emitter\n    real(c_double), intent(in) :: pp(5*n_external(id)), polvect(4)\n    real(c_double), intent(out) :: res(n_external(id))\n    integer :: f_id, f_emitter\n    real(DREALKIND) :: f_pp(0:4,n_external(id)), f_polvect(4)\n    real(DREALKIND) :: f_res(n_external(id))\n    f_id = id\n    call stop_invalid_id(f_id) ! needed because of reshape\n    if (error > 1) return\n    f_pp = reshape(pp, [5,process_handles(id)%n_particles])\n    f_emitter = emitter\n    f_polvect = polvect\n    call evaluate_loopsc(f_id, f_pp(0:3,:), f_emitter, f_polvect, f_res)\n    res = f_res\n   end subroutine evaluate_loopsc_c\n\n\n\n  subroutine evaluate_scpowheg(id, psp, emitter, res, resmunu)\n   ! Spin correlated tree matrix elements in POWHEG convention\n   ! [in] id: process id as set by register_process\n   ! [in] psp: phase space point\n   ! [out] res: squared born matrix element\n   ! [out] res(4:4): array with the spin correlated born matrix element B^(mu,nu)\n   ! B^(mu,nu) = sum_l,k M(l)M(k) epsilon_l^mu* epsilon_k^nu\n    use ol_generic, only: to_string\n    implicit none\n    integer, intent(in) :: id, emitter\n    real(DREALKIND), intent(in) :: psp(:,:)\n    real(DREALKIND), intent(out) :: res, resmunu(4,4)\n    type(process_handle) :: subprocess\n    real(DREALKIND) :: m2cc(0:n_external(id)*(n_external(id)+1)/2+1)\n    call stop_invalid_id(id)\n    if (error > 1) return\n    subprocess = process_handles(id)\n    if (.not. btest(subprocess%content, 0)) then\n      call ol_fatal('evaluate: scpowheg routine not available for process ' // trim(to_string(id)))\n      return\n    end if\n    n_scatt = subprocess%n_in\n    call subprocess%set_permutation(subprocess%permutation)\n    call subprocess%pol_init(subprocess%pol)\n    if (any(subprocess%photon_id /= 0)) call subprocess%set_photons(subprocess%photon_id)\n    call tree_parameters_flush()\n    call subprocess%tree(psp, m2cc, -emitter, &\n      & [0._/**/DREALKIND, 0._/**/DREALKIND, 0._/**/DREALKIND, 0._/**/DREALKIND], &\n      &  1, [0], resmunu)\n    res = m2cc(0)\n  end subroutine evaluate_scpowheg\n\n\n  subroutine evaluate_scpowheg_c(id, pp, emitter, res, resmunu) bind(c,name=\"ol_evaluate_scpowheg\")\n    implicit none\n    integer(c_int), value :: id, emitter\n    real(c_double), intent(in) :: pp(5*n_external(id))\n    real(c_double), intent(out) :: res, resmunu(16)\n    integer :: f_id, f_emitter\n    real(DREALKIND) :: f_pp(0:4,n_external(id))\n    real(DREALKIND) :: f_res, f_resmunu(4,4)\n    f_id = id\n    call stop_invalid_id(f_id) ! needed because of reshape\n    if (error > 1) return\n    f_pp = reshape(pp, [5,process_handles(id)%n_particles])\n    f_emitter = emitter\n    call evaluate_scpowheg(f_id, f_pp(0:3,:), f_emitter, f_res, f_resmunu)\n    res = f_res\n    resmunu = reshape(f_resmunu,(/4*4/))\n  end subroutine evaluate_scpowheg_c\n\n\n  subroutine evaluate_stensor_c(id, pp, emitter, res, resmunu) bind(c,name=\"ol_evaluate_stensor\")\n    implicit none\n    integer(c_int), value :: id, emitter\n    real(c_double), intent(in) :: pp(5*n_external(id))\n    real(c_double), intent(out) :: res, resmunu(16)\n    integer :: f_id, f_emitter\n    real(DREALKIND) :: f_pp(0:4,n_external(id))\n    real(DREALKIND) :: f_res, f_resmunu(4,4)\n    f_id = id\n    call stop_invalid_id(f_id) ! needed because of reshape\n    if (error > 1) return\n    f_pp = reshape(pp, [5,process_handles(id)%n_particles])\n    f_emitter = emitter\n    call evaluate_scpowheg(f_id, f_pp(0:3,:), f_emitter, f_res, f_resmunu)\n    res = f_res\n    resmunu = reshape(f_resmunu,(/4*4/))\n  end subroutine evaluate_stensor_c\n\n\n  subroutine evaluate_sctensor(id, psp, emitter, res, resmunu)\n   ! Colour-Spin correlated tree tensors\n   ! [in] id: process id as set by register_process\n   ! [in] psp: phase space point\n   ! [in] emitter: j\n   ! [out] res: squared born matrix element\n   ! [out] res(N:4:4): array with the spin correlated born matrix element B^(jk)(mu,nu)\n    use ol_generic, only: to_string\n    implicit none\n    integer, intent(in) :: id, emitter\n    real(DREALKIND), intent(in) :: psp(:,:)\n    real(DREALKIND), intent(out) :: res, resmunu(n_external(id),4,4)\n    call stop_invalid_id(id)\n    call ol_fatal('evaluate: sctensor routine not available for process ' // trim(to_string(id)))\n  end subroutine evaluate_sctensor\n\n\n  subroutine evaluate_sctensor_c(id, pp, emitter, res, resmunu) bind(c,name=\"ol_evaluate_sctensor\")\n    implicit none\n    integer(c_int), value :: id, emitter\n    real(c_double), intent(in) :: pp(5*n_external(id))\n    real(c_double), intent(out) :: res, resmunu(n_external(id)*16)\n    integer :: f_id, f_emitter\n    real(DREALKIND) :: f_pp(0:4,n_external(id))\n    real(DREALKIND) :: f_res, f_resmunu(4,4)\n    f_id = id\n    call stop_invalid_id(f_id) ! needed because of reshape\n    if (error > 1) return\n    f_pp = reshape(pp, [5,process_handles(id)%n_particles])\n    f_emitter = emitter\n    call evaluate_sctensor(f_id, f_pp(0:3,:), f_emitter, f_res, f_resmunu)\n    res = f_res\n    resmunu = reshape(f_resmunu,(/n_external(id)*4*4/))\n  end subroutine evaluate_sctensor_c\n\n\n  subroutine evaluate_sctensor2(id, psp, emitter, res, resmunu)\n   ! Colour-Spin correlated tree tensors\n   ! [in] id: process id as set by register_process\n   ! [in] psp: phase space point\n   ! [in] emitter: j\n   ! [out] res: squared born matrix element\n   ! [out] res(N:4:4): array with the spin correlated born matrix element B^(jk)(mu,nu)\n    use ol_generic, only: to_string\n    implicit none\n    integer, intent(in) :: id, emitter\n    real(DREALKIND), intent(in) :: psp(:,:)\n    real(DREALKIND), intent(out) :: res, resmunu(n_external(id),4,4)\n    call stop_invalid_id(id)\n    call ol_fatal('evaluate: sctensor2 routine not available for process ' // trim(to_string(id)))\n  end subroutine evaluate_sctensor2\n\n\n  subroutine evaluate_sctensor2_c(id, pp, emitter, res, resmunu) bind(c,name=\"ol_evaluate_sctensor2\")\n    implicit none\n    integer(c_int), value :: id, emitter\n    real(c_double), intent(in) :: pp(5*n_external(id))\n    real(c_double), intent(out) :: res, resmunu(n_external(id)*16)\n    integer :: f_id, f_emitter\n    real(DREALKIND) :: f_pp(0:4,n_external(id))\n    real(DREALKIND) :: f_res, f_resmunu(4,4)\n    f_id = id\n    call stop_invalid_id(f_id) ! needed because of reshape\n    if (error > 1) return\n    f_pp = reshape(pp, [5,process_handles(id)%n_particles])\n    f_emitter = emitter\n    call evaluate_sctensor2(f_id, f_pp(0:3,:), f_emitter, f_res, f_resmunu)\n    res = f_res\n    resmunu = reshape(f_resmunu,(/n_external(id)*4*4/))\n  end subroutine evaluate_sctensor2_c\n\n\n  subroutine evaluate_loopsctensor(id, psp, emitter, m2l0, m2l1, resmunu)\n   ! Colour-Spin correlated tree tensors\n   ! [in] id: process id as set by register_process\n   ! [in] psp: phase space point\n   ! [in] emitter: j\n   ! [out] res: squared born matrix element\n   ! [out] res(N:4:4): array with the spin correlated born matrix element B^(jk)(mu,nu)\n    use ol_generic, only: to_string\n    implicit none\n    integer, intent(in) :: id, emitter\n    real(DREALKIND), intent(in) :: psp(:,:)\n    real(DREALKIND), intent(out) :: m2l0, m2l1(0:2), resmunu(n_external(id),4,4)\n    call stop_invalid_id(id)\n    call ol_fatal('evaluate: loopsctensor routine not available for process ' // trim(to_string(id)))\n  end subroutine evaluate_loopsctensor\n\n\n  subroutine evaluate_loopsctensor_c(id, pp, emitter, m2l0, m2l1, resmunu) bind(c,name=\"ol_evaluate_loopsctensor\")\n    implicit none\n    integer(c_int), value :: id, emitter\n    real(c_double), intent(in) :: pp(5*n_external(id))\n    real(c_double), intent(out) :: m2l0, m2l1(0:2), resmunu(n_external(id)*16)\n    integer :: f_id, f_emitter\n    real(DREALKIND) :: f_pp(0:4,n_external(id))\n    real(DREALKIND) :: f_m2l0, f_m2l1(0:2), f_resmunu(4,4)\n    f_id = id\n    call stop_invalid_id(f_id) ! needed because of reshape\n    if (error > 1) return\n    f_pp = reshape(pp, [5,process_handles(id)%n_particles])\n    f_emitter = emitter\n    call evaluate_loopsctensor(f_id, f_pp(0:3,:), f_emitter, f_m2l0, f_m2l1, f_resmunu)\n    m2l0 = f_m2l0\n    m2l1 = f_m2l1\n    resmunu = reshape(f_resmunu,(/n_external(id)*4*4/))\n  end subroutine evaluate_loopsctensor_c\n\n\n  subroutine evaluate_scpowheg2(id, psp, emitter, res, resmunu)\n   ! Spin correlated loop-squared matrix elements in POWHEG convention\n   ! [in] id: process id as set by register_process\n   ! [in] psp: phase space point\n   ! [out] res: squared loop-squared matrix element\n   ! [out] res(4:4): array with the spin correlated loop^2 matrix element L^(mu,nu)\n   ! L^(mu,nu) = sum_l,k Mloop(l)Mloop(k) epsilon_l^mu* epsilon_k^nu\n    use ol_generic, only: to_string\n    use ol_data_types_/**/DREALKIND, only: correlator\n    implicit none\n    integer, intent(in) :: id, emitter\n    real(DREALKIND), intent(in) :: psp(:,:)\n    real(DREALKIND), intent(out) :: res, resmunu(4,4)\n    real(DREALKIND) :: m2l0, m2l1(0:2), ir1(0:2), m2l2(0:4), ir2(0:4), acc\n    type(process_handle) :: subprocess\n    type(correlator) :: Lmunu\n    call stop_invalid_id(id)\n    if (error > 1) return\n    subprocess = process_handles(id)\n    if (.not. btest(subprocess%content, 2)) then\n      call ol_fatal('evaluate: scpowheg2 routine not available for process ' // trim(to_string(id)))\n      return\n    end if\n    n_scatt = subprocess%n_in\n    call subprocess%set_permutation(subprocess%permutation)\n    call subprocess%pol_init(subprocess%pol)\n    if (any(subprocess%photon_id /= 0)) call subprocess%set_photons(subprocess%photon_id)\n    call parameters_flush()\n    if (subprocess%extid(emitter) /= 21 .and. subprocess%extid(emitter) /= 22 .and. subprocess%extid(emitter) /= 0) then\n      Lmunu%type=0\n      call evaluate_fullcr(id, psp, m2l0, m2l1, ir1, m2l2, ir2, Lmunu, acc)\n      res = m2l2(0)\n      resmunu = 0\n      return\n    else\n      Lmunu%type=3\n      Lmunu%emitter=emitter\n      call evaluate_fullcr(id, psp, m2l0, m2l1, ir1, m2l2, ir2, Lmunu, acc)\n      res = m2l2(0)\n      resmunu = Lmunu%resmunu\n    end if\n  end subroutine evaluate_scpowheg2\n\n\n  subroutine evaluate_scpowheg2_c(id, pp, emitter, res, resmunu) bind(c,name=\"ol_evaluate_scpowheg2\")\n    implicit none\n    integer(c_int), value :: id, emitter\n    real(c_double), intent(in) :: pp(5*n_external(id))\n    real(c_double), intent(out) :: res, resmunu(16)\n    integer :: f_id, f_emitter\n    real(DREALKIND) :: f_pp(0:4,n_external(id))\n    real(DREALKIND) :: f_res, f_resmunu(4,4)\n    f_id = id\n    call stop_invalid_id(f_id) ! needed because of reshape\n    if (error > 1) return\n    f_pp = reshape(pp, [5,process_handles(id)%n_particles])\n    f_emitter = emitter\n    call evaluate_scpowheg2(f_id, f_pp(0:3,:), f_emitter, f_res, f_resmunu)\n    res = f_res\n    resmunu = reshape(f_resmunu,(/4*4/))\n  end subroutine evaluate_scpowheg2_c\n\n\n  subroutine evaluate_stensor2_c(id, pp, emitter, res, resmunu) bind(c,name=\"ol_evaluate_stensor2\")\n    implicit none\n    integer(c_int), value :: id, emitter\n    real(c_double), intent(in) :: pp(5*n_external(id))\n    real(c_double), intent(out) :: res, resmunu(16)\n    integer :: f_id, f_emitter\n    real(DREALKIND) :: f_pp(0:4,n_external(id))\n    real(DREALKIND) :: f_res, f_resmunu(4,4)\n    f_id = id\n    call stop_invalid_id(f_id) ! needed because of reshape\n    if (error > 1) return\n    f_pp = reshape(pp, [5,process_handles(id)%n_particles])\n    f_emitter = emitter\n    call evaluate_scpowheg2(f_id, f_pp(0:3,:), f_emitter, f_res, f_resmunu)\n    res = f_res\n    resmunu = reshape(f_resmunu,(/4*4/))\n  end subroutine evaluate_stensor2_c\n\n\n  subroutine evaluate_loopscpowheg(id, psp, emitter, m2l0, m2l1, resmunu)\n   ! Spin correlated loop x Born matrix elements in POWHEG convention\n   ! [in] id: process id as set by register_process\n   ! [in] psp: phase space point\n   ! [out] res: squared loop-squared matrix element\n   ! [out] res(4:4): array with the spin correlated loop^2 matrix element L^(mu,nu)\n   ! L^(mu,nu) = sum_l,k Mloop(l)Mborn(k) epsilon_l^mu* epsilon_k^nu\n    use ol_generic, only: to_string\n    use ol_data_types_/**/DREALKIND, only: correlator\n    implicit none\n    integer, intent(in) :: id, emitter\n    real(DREALKIND), intent(in) :: psp(:,:)\n    real(DREALKIND), intent(out) :: m2l0, m2l1(0:2), resmunu(4,4)\n    real(DREALKIND) :: ir1(0:2), m2l2(0:4), ir2(0:4), acc\n    type(process_handle) :: subprocess\n    type(correlator) :: Lmunu\n    call stop_invalid_id(id)\n    if (error > 1) return\n    subprocess = process_handles(id)\n    if (.not. btest(subprocess%content, 1)) then\n      call ol_fatal('evaluate: loopscpowheg routine not available for process ' // trim(to_string(id)))\n      return\n    end if\n    n_scatt = subprocess%n_in\n    call subprocess%set_permutation(subprocess%permutation)\n    call subprocess%pol_init(subprocess%pol)\n    if (any(subprocess%photon_id /= 0)) call subprocess%set_photons(subprocess%photon_id)\n    call parameters_flush()\n    if (subprocess%extid(emitter) /= 21 .and. subprocess%extid(emitter) /= 22 .and. subprocess%extid(emitter) /= 0) then\n      Lmunu%type=0\n      call evaluate_fullcr(id, psp, m2l0, m2l1, ir1, m2l2, ir2, Lmunu, acc)\n      resmunu = 0\n      return\n    else\n      Lmunu%type=13\n      Lmunu%emitter=emitter\n      call evaluate_fullcr(id, psp, m2l0, m2l1, ir1, m2l2, ir2, Lmunu, acc)\n      resmunu = Lmunu%resmunu\n    end if\n  end subroutine evaluate_loopscpowheg\n\n\n  subroutine evaluate_loopscpowheg_c(id, pp, emitter, m2l0, m2l1, resmunu) bind(c,name=\"ol_evaluate_loopscpowheg\")\n    implicit none\n    integer(c_int), value :: id, emitter\n    real(c_double), intent(in) :: pp(5*n_external(id))\n    real(c_double), intent(out) :: m2l0, m2l1(0:2), resmunu(16)\n    integer :: f_id, f_emitter\n    real(DREALKIND) :: f_pp(0:4,n_external(id))\n    real(DREALKIND) :: f_m2l0, f_m2l1(0:2), f_resmunu(4,4)\n    f_id = id\n    call stop_invalid_id(f_id) ! needed because of reshape\n    if (error > 1) return\n    f_pp = reshape(pp, [5,process_handles(id)%n_particles])\n    f_emitter = emitter\n    call evaluate_loopscpowheg(f_id, f_pp(0:3,:), f_emitter, f_m2l0, f_m2l1, f_resmunu)\n    m2l0 = f_m2l0\n    m2l1 = f_m2l1\n    resmunu = reshape(f_resmunu,(/4*4/))\n  end subroutine evaluate_loopscpowheg_c\n\n\n  subroutine evaluate_loopstensor_c(id, pp, emitter, m2l0, m2l1, resmunu) bind(c,name=\"ol_evaluate_loopstensor\")\n    implicit none\n    integer(c_int), value :: id, emitter\n    real(c_double), intent(in) :: pp(5*n_external(id))\n    real(c_double), intent(out) :: m2l0, m2l1(0:2), resmunu(16)\n    integer :: f_id, f_emitter\n    real(DREALKIND) :: f_pp(0:4,n_external(id))\n    real(DREALKIND) :: f_m2l0, f_m2l1(0:2), f_resmunu(4,4)\n    f_id = id\n    call stop_invalid_id(f_id) ! needed because of reshape\n    if (error > 1) return\n    f_pp = reshape(pp, [5,process_handles(id)%n_particles])\n    f_emitter = emitter\n    call evaluate_loopscpowheg(f_id, f_pp(0:3,:), f_emitter, f_m2l0, f_m2l1, f_resmunu)\n    m2l0 = f_m2l0\n    m2l1 = f_m2l1\n    resmunu = reshape(f_resmunu,(/4*4/))\n  end subroutine evaluate_loopstensor_c\n\n\n  recursive subroutine evaluate_full(id, psp, m2l0, m2l1, ir1, m2l2, ir2, acc)\n    use ol_stability\n    use ol_generic, only: to_string\n    use ol_parameters_decl_/**/DREALKIND, only: add_associated_ew, alpha_QCD\n    use ol_loop_parameters_decl_/**/DREALKIND, only: IR_is_on, loop_parameters_status, muren_unscaled, CT_is_on, R2_is_on, TP_is_on\n    use ol_loop_parameters_decl_/**/DREALKIND, only: stability_mode,a_switch,a_switch_rescue,redlib_qp,use_bubble_vertex\n    implicit none\n    integer, intent(in) :: id\n    real(DREALKIND), intent(in) :: psp(:,:)\n    real(DREALKIND), intent(out) :: m2l0, m2l1(0:2), ir1(0:2), m2l2(0:4), ir2(0:4)\n    real(DREALKIND), intent(out) :: acc\n    real(DREALKIND) :: m2l0ew, m2l1ew(0:2), ir1ew(0:2), m2l2ew(0:4), ir2ew(0:4), accew\n    real(DREALKIND) :: last_m2ct, new_m2ct, muren_bak\n    integer :: IR_is_on_bak\n    type(process_handle)  :: subprocess, subprocess_replace\n    call stop_invalid_id(id)\n    if (error > 1) return\n    subprocess = process_handles(id)\n    if (.not. btest(subprocess%content, 1) .and. subprocess%replace_loop==0) then\n      call ol_fatal('evaluate: loop routine not available for process ' // trim(to_string(id)))\n      return\n    end if\n    if (subprocess%stability_mode/=-1)  call set_if_modified(stability_mode,subprocess%stability_mode)\n    if (subprocess%a_switch/=-1)        call set_if_modified(a_switch,subprocess%a_switch)\n    if (subprocess%a_switch_rescue/=-1) call set_if_modified(a_switch_rescue,subprocess%a_switch_rescue)\n    if (subprocess%redlib_qp/=-1)       call set_if_modified(redlib_qp,subprocess%redlib_qp)\n    n_scatt = subprocess%n_in\n    call subprocess%set_permutation(subprocess%permutation)\n    call subprocess%pol_init(subprocess%pol)\n    if (any(subprocess%photon_id /= 0)) call subprocess%set_photons(subprocess%photon_id)\n    call parameters_flush()\n    if (IR_is_on == 5) then\n      ! Return Born (from tree amplitude) as vamp (for debug)\n      call evaluate_tree(id,psp,m2l0)\n      m2l1 = m2l0\n      m2l0 = 1.\n      return\n    else if (IR_is_on == 6) then\n      ! Return zero (for debug)\n      call evaluate_tree(id,psp,m2l0)\n      m2l1 = 0\n      return\n    end if\n\n    if (subprocess%replace_loop > 0) then\n      call evaluate_full(subprocess%replace_loop, psp, m2l0, m2l1, ir1, m2l2, ir2, acc)\n      call evaluate_tree(id,psp,m2l0)\n    else\n      call subprocess%loop(psp, m2l0, m2l1, ir1, m2l2, ir2)\n    end if\n    acc = last_relative_deviation\n\n    if (last_from_cache .and. alpha_QCD /= subprocess%last_alpha_QCD) then\n      call ol_msg(3, \"evaluate_full: same psp, alpha_QCD changed: rescale.\")\n      m2l0 = m2l0*(alpha_QCD/subprocess%last_alpha_QCD)**subprocess%qcd_powers(1)\n      m2l1 = m2l1*(alpha_QCD/subprocess%last_alpha_QCD)**(subprocess%qcd_powers(1)+subprocess%qcd_powers(2))\n      ir1  = ir1*(alpha_QCD/subprocess%last_alpha_QCD)**(subprocess%qcd_powers(1)+subprocess%qcd_powers(2))\n      m2l2 = m2l2*(alpha_QCD/subprocess%last_alpha_QCD)**subprocess%qcd_powers(1)\n      ir2  = ir2*(alpha_QCD/subprocess%last_alpha_QCD)**subprocess%qcd_powers(1)\n    end if\n\n\n    if (last_from_cache .and. muren_unscaled /= subprocess%last_muren) then\n      call ol_msg(3, \"evaluate_full: same psp, muren changed: shift counterterm.\")\n      muren_bak = muren_unscaled\n      call set_parameter(\"muren\",subprocess%last_muren)\n      call subprocess%ct(psp, m2l0, last_m2ct)\n      call set_parameter(\"muren\",muren_bak)\n      call subprocess%ct(psp, m2l0, new_m2ct)\n      m2l1(0) = m2l1(0)-last_m2ct+new_m2ct\n    end if\n\n\n    ! add associated one-loop ew\n    if (add_associated_ew > 0 .and. subprocess%associated_ew > 0) then\n      IR_is_on_bak = IR_is_on\n      IR_is_on = 2\n      call set_parameter(\"ew_renorm\", 1)\n      call evaluate_loop(subprocess%associated_ew, psp, m2l0ew, m2l1ew, accew)\n      m2l1 = m2l1+m2l1ew\n      acc = max(acc, accew)\n      IR_is_on = IR_is_on_bak\n      call set_parameter(\"ew_renorm\", 0)\n    else if (add_associated_ew > 0 .and. subprocess%associated_ew <= 0) then\n      call ol_msg(2, \"evaluate_full: associated EW loop library not loaded -> only QCD used.\")\n    end if\n\n    ! add associated born ew\n    if (add_associated_ew > 1 .and. subprocess%associated_born_1 > 0) then\n      call evaluate_tree(subprocess%associated_born_1,psp,m2l0ew)\n      m2l1(0) = m2l1(0)+m2l0ew\n    else if (add_associated_ew > 1 .and. subprocess%associated_born_1 <= 0) then\n      call ol_msg(2, \"evaluate_full: associated EW born library not loaded -> only V used.\")\n    end if\n\n    if (add_associated_ew > 2 .and. subprocess%associated_born_2 > 0) then\n      call evaluate_tree(subprocess%associated_born_2,psp,m2l0ew)\n      m2l1(0) = m2l1(0)+m2l0ew\n    else if (add_associated_ew > 2 .and. subprocess%associated_born_2 <= 0) then\n      call ol_msg(2, \"evaluate_full: associated EW born library not loaded -> only V used.\")\n    end if\n\n    if (IR_is_on == 3) then\n      m2l1 = ir1  ! Return I-Operator as vamp (for debug)\n    else if (IR_is_on == 4) then\n      m2l1 = m2l0 ! Return Born as vamp (for debug)\n    end if\n    if (.not. last_from_cache) then\n      process_handles(id)%last_psp = psp\n      process_handles(id)%last_perm = subprocess%permutation\n      process_handles(id)%last_pol = subprocess%pol\n      process_handles(id)%last_zero = (m2l1(0) == 0 .and. m2l2(0) == 0)\n      process_handles(id)%loop_parameters_status = loop_parameters_status\n      process_handles(id)%last_muren = muren_unscaled\n      process_handles(id)%last_alpha_QCD = alpha_QCD\n    end if\n    call ol_msg(5,\"evaluate_full: \" // trim(to_string(m2l0)) // \" \" // trim(to_string(m2l1(0))))\n  end subroutine evaluate_full\n\n\n  subroutine evaluate_full_c(id, pp, m2l0, m2l1, ir1, m2l2, ir2, acc) bind(c,name=\"ol_evaluate_full\")\n    implicit none\n    integer(c_int), value :: id\n    real(c_double), intent(in) :: pp(5*n_external(id))\n    real(c_double), intent(out) :: m2l0, m2l1(0:2), ir1(0:2), m2l2(0:4), ir2(0:4), acc\n    integer :: f_id\n    real(DREALKIND) :: f_pp(0:4,n_external(id))\n    real(DREALKIND) :: f_m2l0, f_m2l1(0:2), f_ir1(0:2), f_m2l2(0:4), f_ir2(0:4)\n    real(DREALKIND) :: f_acc\n    f_id = id\n    call stop_invalid_id(f_id) ! needed because of reshape\n    if (error > 1) return\n    f_pp = reshape(pp, [5,process_handles(id)%n_particles])\n    call evaluate_full(f_id, f_pp(0:3,:), f_m2l0, f_m2l1, f_ir1, f_m2l2, f_ir2, f_acc)\n    m2l0 = f_m2l0\n    m2l1 = f_m2l1\n    ir1  = f_ir1\n    m2l2 = f_m2l2\n    ir2  = f_ir2\n    acc  = f_acc\n  end subroutine evaluate_full_c\n\n\n  subroutine evaluate_fullcr(id, psp, m2l0, m2l1, ir1, m2l2, ir2, cr, acc)\n    use ol_stability\n    use ol_generic, only: to_string, to_string\n    use ol_data_types_/**/DREALKIND, only: correlator\n    use ol_loop_parameters_decl_/**/DREALKIND, only: loop_parameters_status\n    implicit none\n    integer, intent(in) :: id\n    real(DREALKIND), intent(in) :: psp(:,:)\n    real(DREALKIND), intent(out) :: m2l0, m2l1(0:2), ir1(0:2), m2l2(0:4), ir2(0:4)\n    real(DREALKIND), intent(out) :: acc\n    type(correlator) :: cr\n    type(process_handle)  :: subprocess\n    logical has_loopcc\n    call stop_invalid_id(id)\n    if (error > 1) return\n    subprocess = process_handles(id)\n    if (.not. btest(subprocess%content, 1)) then\n      call ol_fatal('evaluate: loop routine not available for process ' // trim(to_string(id)))\n      return\n    end if\n    m2l1=0\n    ir1=0\n    m2l2=0\n    ir2=0\n    n_scatt = subprocess%n_in\n    call subprocess%set_permutation(subprocess%permutation)\n    call subprocess%pol_init(subprocess%pol)\n    if (any(subprocess%photon_id /= 0)) call subprocess%set_photons(subprocess%photon_id)\n    call parameters_flush()\n    if (cr%type > 10) call subprocess%loopcc(.true., has_loopcc)\n    if (any(subprocess%last_psp /= psp) .or. &\n      & any(subprocess%last_perm /= subprocess%permutation) .or. &\n      & any(subprocess%last_pol /= subprocess%pol) .or. &\n      & subprocess%loop_parameters_status /= loop_parameters_status .or. &\n        .not. has_loopcc &\n      ) then\n      call ol_msg(3, \"me-cache for correlators: \" // trim(subprocess%process_name) &\n                 &  // trim(to_string(subprocess%permutation,.true.)) // ' reevaluate' )\n      call evaluate_full(id, psp, m2l0, m2l1, ir1, m2l2, ir2, acc)  ! fill colour/helicity vector cache\n      if (m2l1(0) == 0 .and. m2l2(0) == 0) then\n        cr%rescc = 0\n        cr%resmunu = 0\n        return\n      end if\n    else\n      call ol_msg(3, \"me-cache for correlators: \" // trim(subprocess%process_name) &\n                 &  // trim(to_string(subprocess%permutation,.true.)) // ' taken from the cache' )\n      if (subprocess%last_zero) then\n        cr%rescc = 0\n        cr%resmunu = 0\n        return ! return for unstable points\n      end if\n    end if\n    if (cr%type < 1) then\n      return\n    else if (cr%type < 14) then\n      call subprocess%loopcr(psp, m2l0, m2l1(0), m2l2(0), &\n            cr%type, cr%emitter, cr%nextcombs, cr%extcombs, cr%mom, cr%rescc, cr%resmunu)\n    else\n      call ol_fatal(\"evaluate_fullcr: correlator type not available.\")\n    end if\n    acc = last_relative_deviation\n  end subroutine evaluate_fullcr\n\n\n  subroutine evaluate_loop(id, psp, m2l0, m2l1, acc)\n    implicit none\n    integer, intent(in)  :: id\n    real(DREALKIND), intent(in)  :: psp(:,:)\n    real(DREALKIND), intent(out) :: m2l0, m2l1(0:2)\n    real(DREALKIND), intent(out) :: acc\n    real(DREALKIND) :: ir1(0:2), m2l2(0:4), ir2(0:4)\n    call evaluate_full(id, psp, m2l0, m2l1, ir1, m2l2, ir2, acc)\n  end subroutine evaluate_loop\n\n\n  subroutine evaluate_loop_c(id, pp, m2l0, m2l1, acc) bind(c,name=\"ol_evaluate_loop\")\n    implicit none\n    integer(c_int), value :: id\n    real(c_double), intent(in) :: pp(5*n_external(id))\n    real(c_double), intent(out) :: m2l0, m2l1(0:2), acc\n    integer :: f_id\n    real(DREALKIND) :: f_pp(0:4,n_external(id))\n    real(DREALKIND) :: f_m2l0, f_m2l1(0:2)\n    real(DREALKIND) :: f_acc\n    f_id = id\n    call stop_invalid_id(f_id) ! needed because of reshape\n    if (error > 1) return\n    f_pp = reshape(pp, [5,process_handles(id)%n_particles])\n    call evaluate_loop(f_id, f_pp(0:3,:), f_m2l0, f_m2l1, f_acc)\n    m2l0 = f_m2l0\n    m2l1 = f_m2l1\n    acc  = f_acc\n  end subroutine evaluate_loop_c\n\n\n  subroutine evaluate_loopbare(id, psp, m2l0, m2l1, acc)\n    use ol_loop_parameters_decl_/**/DREALKIND, only: CT_is_on, R2_is_on, IR_is_on, polecheck_is\n    implicit none\n    integer, intent(in)  :: id\n    real(DREALKIND), intent(in)  :: psp(:,:)\n    real(DREALKIND), intent(out) :: m2l0, m2l1(0:2)\n    real(DREALKIND), intent(out) :: acc\n    real(DREALKIND) :: ir1(0:2), m2l2(0:4), ir2(0:4), m2ct(0:2)\n    integer :: CT_is_on_bak, R2_is_on_bak, IR_is_on_bak\n    CT_is_on_bak = CT_is_on\n    R2_is_on_bak = R2_is_on\n    IR_is_on_bak = IR_is_on\n    call set_parameter(\"ct_on\", 1)\n    call set_parameter(\"ir_on\", 1)\n    call set_parameter(\"r2_on\", 0)\n    call evaluate_full(id, psp, m2l0, m2l1, ir1, m2l2, ir2, acc)\n    call evaluate_loopct(id, psp, m2l0, m2ct)\n    m2l1 = m2l1 - m2ct\n    call set_parameter(\"ct_on\", CT_is_on_bak)\n    call set_parameter(\"ir_on\", IR_is_on_bak)\n    call set_parameter(\"r2_on\", R2_is_on_bak)\n  end subroutine evaluate_loopbare\n\n\n  subroutine evaluate_loopbare_c(id, pp, m2l0, m2l1, acc) bind(c,name=\"ol_evaluate_loopbare\")\n    implicit none\n    integer(c_int), value :: id\n    real(c_double), intent(in) :: pp(5*n_external(id))\n    real(c_double), intent(out) :: m2l0, m2l1(0:2), acc\n    integer :: f_id\n    real(DREALKIND) :: f_pp(0:4,n_external(id))\n    real(DREALKIND) :: f_m2l0, f_m2l1(0:2)\n    real(DREALKIND) :: f_acc\n    f_id = id\n    call stop_invalid_id(f_id) ! needed because of reshape\n    if (error > 1) return\n    f_pp = reshape(pp, [5,process_handles(id)%n_particles])\n    call evaluate_loopbare(f_id, f_pp(0:3,:), f_m2l0, f_m2l1, f_acc)\n    m2l0 = f_m2l0\n    m2l1 = f_m2l1\n    acc  = f_acc\n  end subroutine evaluate_loopbare_c\n\n\n  subroutine evaluate_loop2(id, psp, res, acc)\n    use ol_generic, only: to_string\n    implicit none\n    integer, intent(in)  :: id\n    real(DREALKIND), intent(in)  :: psp(:,:)\n    real(DREALKIND), intent(out) :: res\n    real(DREALKIND), intent(out) :: acc\n    real(DREALKIND) :: m2l0, m2l1(0:2), ir1(0:2), m2l2(0:4), ir2(0:4)\n    if (.not. btest(process_handles(id)%content, 2)) then\n      call ol_fatal('evaluate: loop^2 routine not available for process ' // trim(to_string(id)))\n      return\n    end if\n    call evaluate_full(id, psp, m2l0, m2l1, ir1, m2l2, ir2, acc)\n    res = m2l2(0)\n  end subroutine evaluate_loop2\n\n\n  subroutine evaluate_loop2_c(id, pp, res, acc) bind(c,name=\"ol_evaluate_loop2\")\n    implicit none\n    integer(c_int), value :: id\n    real(c_double), intent(in) :: pp(5*n_external(id))\n    real(c_double), intent(out) :: res, acc\n    integer :: f_id\n    real(DREALKIND) :: f_pp(0:4,n_external(id))\n    real(DREALKIND) :: f_res, f_acc\n    f_id = id\n    call stop_invalid_id(f_id) ! needed because of reshape\n    if (error > 1) return\n    f_pp = reshape(pp, [5,process_handles(id)%n_particles])\n    call evaluate_loop2(f_id, f_pp(0:3,:), f_res, f_acc)\n    res = f_res\n    acc  = f_acc\n  end subroutine evaluate_loop2_c\n\n\n  subroutine evaluate_iop2(id, psp, res, resir, acc)\n    use ol_generic, only: to_string\n    implicit none\n    integer, intent(in)  :: id\n    real(DREALKIND), intent(in)  :: psp(:,:)\n    real(DREALKIND), intent(out) :: res, resir(0:2)\n    real(DREALKIND), intent(out) :: acc\n    real(DREALKIND) :: m2l0, m2l1(0:2), ir1(0:2), m2l2(0:4), ir2(0:4)\n    if (.not. btest(process_handles(id)%content, 2)) then\n      call ol_fatal('evaluate: loop^2 routine not available for process ' // trim(to_string(id)))\n      return\n    end if\n    call evaluate_full(id, psp, m2l0, m2l1, ir1, m2l2, ir2, acc)\n    res = m2l2(0)\n    resir(0) = ir2(0)\n    resir(1) = ir2(1)\n    resir(2) = ir2(2)\n  end subroutine evaluate_iop2\n\n\n  subroutine evaluate_iop2_c(id, pp, res, resir, acc) bind(c,name=\"ol_evaluate_iop2\")\n    implicit none\n    integer(c_int), value :: id\n    real(c_double), intent(in) :: pp(5*n_external(id))\n    real(c_double), intent(out) :: res, resir(0:2), acc\n    integer :: f_id\n    real(DREALKIND) :: f_pp(0:4,n_external(id))\n    real(DREALKIND) :: f_res, f_resir(0:2), f_acc\n    f_id = id\n    call stop_invalid_id(f_id) ! needed because of reshape\n    if (error > 1) return\n    f_pp = reshape(pp, [5,process_handles(id)%n_particles])\n    call evaluate_iop2(f_id, f_pp(0:3,:), f_res, f_resir, f_acc)\n    res = f_res\n    resir = f_resir\n    acc  = f_acc\n  end subroutine evaluate_iop2_c\n\n\n  subroutine evaluate_associated(id, psp, level, m2l0)\n    use ol_stability\n    use ol_generic, only: to_string\n    use ol_parameters_decl_/**/DREALKIND, only: add_associated_ew\n    use ol_loop_parameters_decl_/**/DREALKIND, only: IR_is_on\n    implicit none\n    integer, intent(in) :: id, level\n    real(DREALKIND), intent(in) :: psp(:,:)\n    real(DREALKIND), intent(out) :: m2l0\n    real(DREALKIND) :: m2l0ew, m2l1ew(0:2), ir1ew(0:2), m2l2ew(0:4), ir2ew(0:4), accew\n    integer :: IR_is_on_bak\n    type(process_handle)  :: subprocess, subprocessew\n    call stop_invalid_id(id)\n    if (error > 1) return\n    subprocess = process_handles(id)\n    if (.not. btest(subprocess%content, 1)) then\n      call ol_fatal('evaluate: loop routine not available for process ' // trim(to_string(id)))\n      return\n    end if\n    n_scatt = subprocess%n_in\n    call subprocess%set_permutation(subprocess%permutation)\n    call subprocess%pol_init(subprocess%pol)\n    if (any(subprocess%photon_id /= 0)) call subprocess%set_photons(subprocess%photon_id)\n    call parameters_flush()\n\n    m2l0 = 0\n    if (level .eq. 1 .and. subprocess%associated_ew > 0) then ! add associated one-loop ew\n      IR_is_on_bak = IR_is_on\n      IR_is_on = 2\n      call set_parameter(\"ew_renorm\", 1)\n      call evaluate_loop(subprocess%associated_ew, psp, m2l0ew, m2l1ew, accew)\n      m2l0 = m2l1ew(0)\n      IR_is_on = IR_is_on_bak\n      call set_parameter(\"ew_renorm\", 0)\n    else if (level .eq. 1 .and. subprocess%associated_ew <= 0) then\n      call ol_msg(2, \"evaluate_associated: associated EW loop library not loaded -> only QCD used.\")\n    else if (level .eq. 2 .and. subprocess%associated_born_1 > 0) then ! add associated born ew\n      call evaluate_tree(subprocess%associated_born_1,psp,m2l0ew)\n      m2l0 = m2l0ew\n    else if (level .eq. 2 .and. subprocess%associated_born_1 <= 0) then\n      call ol_msg(2, \"evaluate_associated: associated EW born library not loaded -> only V used.\")\n    else if (level .eq. 3 .and. subprocess%associated_born_2 > 0) then\n      call evaluate_tree(subprocess%associated_born_2,psp,m2l0ew)\n      m2l0 = m2l0ew\n    else if (level .eq. 3 .and. subprocess%associated_born_2 <= 0) then\n      call ol_msg(2, \"evaluate_associated: associated EW born library not loaded -> only V used.\")\n    end if\n\n    call ol_msg(5,\"evaluate_associated: \" // trim(to_string(m2l0)) )\n  end subroutine evaluate_associated\n\n\n  subroutine evaluate_associated_c(id, pp, level, res) bind(c,name=\"ol_evaluate_associated\")\n    implicit none\n    integer(c_int), value :: id, level\n    real(c_double), intent(in) :: pp(5*n_external(id))\n    real(c_double), intent(out) :: res\n    integer :: f_id, f_level\n    real(DREALKIND) :: f_pp(0:4,n_external(id))\n    real(DREALKIND) :: f_res\n    f_id = id\n    f_level = level\n    call stop_invalid_id(f_id) ! needed because of reshape\n    if (error > 1) return\n    f_pp = reshape(pp, [5,process_handles(id)%n_particles])\n    call evaluate_associated(f_id, f_pp(0:3,:), f_level, f_res)\n    res = f_res\n  end subroutine evaluate_associated_c\n\n\n  subroutine evaluate_ct(id, psp, m2l0, m2ct)\n    use ol_parameters_decl_/**/DREALKIND, only: add_associated_ew\n    use ol_loop_parameters_decl_/**/DREALKIND, only: CT_is_on, R2_is_on, TP_is_on, do_ew_renorm,use_bubble_vertex\n    use ol_init, only: set_if_modified, parameters_flush\n    use ol_stability\n    use ol_generic, only: to_string\n    implicit none\n    integer, intent(in)  :: id\n    real(DREALKIND), intent(in)  :: psp(:,:)\n    integer :: CT_on_bak, R2_on_bak, TP_on_bak, use_bubble_vertex_bak\n    real(DREALKIND), intent(out) :: m2l0, m2ct\n    real(DREALKIND) :: m2l0ew, m2ctew\n    type(process_handle)  :: subprocess, subprocessew\n    call stop_invalid_id(id)\n    if (error > 1) return\n    subprocess = process_handles(id)\n    if (.not. btest(subprocess%content, 1)) then\n      call ol_fatal('evaluate: ct routine not available for process ' // trim(to_string(id)))\n      return\n    end if\n    ! For compatibility: signal ctamp2 that this is the (new) interface (CT_is_on=2),\n    ! where CT_is_on is set here, not in ctamp2base.\n    ! If the old interface is used with a new process, the process will thus notice\n    ! that it has to set CT_is_on itself.\n    CT_on_bak = CT_is_on\n    R2_on_bak = R2_is_on\n    TP_on_bak = TP_is_on\n    use_bubble_vertex_bak = use_bubble_vertex\n    call set_if_modified(CT_is_on, 2)\n    call set_if_modified(R2_is_on, 0)\n    call set_if_modified(TP_is_on, 0)\n    call set_if_modified(use_bubble_vertex, 0)\n    ! call parameters_flush() is done in ctamp2base,\n    ! because only there we know if ew renormalisation needs to be activated.\n    n_scatt = subprocess%n_in\n    call subprocess%set_permutation(subprocess%permutation)\n    call subprocess%pol_init(subprocess%pol)\n    if (any(subprocess%photon_id /= 0)) call subprocess%set_photons(subprocess%photon_id)\n    call subprocess%ct(psp, m2l0, m2ct)\n    if (add_associated_ew == 1 .and. subprocess%associated_ew > 0) then\n      subprocessew = process_handles(subprocess%associated_ew)\n      if (.not. btest(subprocessew%content, 1)) then\n        call ol_fatal('evaluate: loop routine not available for associated process ' // trim(to_string(subprocess%associated_ew)))\n        call set_if_modified(CT_is_on, CT_on_bak)\n        call set_if_modified(R2_is_on, R2_on_bak)\n        call set_if_modified(TP_is_on, TP_on_bak)\n        call set_if_modified(use_bubble_vertex, use_bubble_vertex_bak)\n        call parameters_flush()\n        return\n      end if\n      n_scatt = subprocess%n_in\n      call subprocessew%set_permutation(subprocessew%permutation)\n      if (any(subprocessew%photon_id /= 0)) call subprocessew%set_photons(subprocessew%photon_id)\n      call set_if_modified(do_ew_renorm, 1)\n      call parameters_flush()\n      call subprocessew%ct(psp, m2l0ew, m2ctew)\n      m2ct = m2ct + m2ctew\n      call set_if_modified(do_ew_renorm, 0)\n    else if (add_associated_ew == 1 .and. subprocess%associated_ew <= 0) then\n      call ol_error(\"evaluate_ct: associated EW library not loaded -> only QCD used.\")\n    end if\n    call set_if_modified(CT_is_on, CT_on_bak)\n    call set_if_modified(R2_is_on, R2_on_bak)\n    call set_if_modified(TP_is_on, TP_on_bak)\n    call set_if_modified(use_bubble_vertex, use_bubble_vertex_bak)\n    call parameters_flush()\n  end subroutine evaluate_ct\n\n\n  subroutine evaluate_ct_c(id, pp, m2l0, m2ct) bind(c,name=\"ol_evaluate_ct\")\n    implicit none\n    integer(c_int), value :: id\n    real(c_double), intent(in) :: pp(5*n_external(id))\n    real(c_double), intent(out) :: m2l0, m2ct\n    integer :: f_id\n    real(DREALKIND) :: f_pp(0:4,n_external(id))\n    real(DREALKIND) :: f_m2l0, f_m2ct\n    f_id = id\n    call stop_invalid_id(f_id) ! needed because of reshape\n    if (error > 1) return\n    f_pp = reshape(pp, [5,process_handles(id)%n_particles])\n    call evaluate_ct(f_id, f_pp(0:3,:), f_m2l0, f_m2ct)\n    m2l0 = f_m2l0\n    m2ct = f_m2ct\n  end subroutine evaluate_ct_c\n\n\n  subroutine evaluate_loopct(id, psp, m2l0, m2ct)\n    use ol_loop_parameters_decl_/**/DREALKIND, only: CT_is_on, IR_is_on\n    use ol_loop_parameters_decl_/**/DREALKIND, only: de1_UV, de1_IR, de2_i_IR\n    use ol_stability\n    use ol_generic, only: to_string\n    implicit none\n    integer, intent(in)  :: id\n    real(DREALKIND), intent(in)  :: psp(:,:)\n    real(DREALKIND), intent(out) :: m2l0, m2ct(0:2)\n    real(DREALKIND) :: m2ct_000, m2ct_110, polescale\n    real(DREALKIND) :: poleUV1bak, poleIR1bak, poleIR2bak\n    integer CT_on_bak\n    call stop_invalid_id(id)\n    if (error > 1) return\n    ! remember original parameters\n    poleUV1bak = de1_UV\n    poleIR1bak = de1_IR\n    poleIR2bak = de2_i_IR\n    CT_on_bak = CT_is_on\n    call get_parameter(\"polescale\", polescale)\n\n    ! two calls to CT amplitude with different UV & IR poles\n    call set_parameter(\"ct_on\", 1)\n    call set_parameter(\"pole_uv\", polescale)\n    call set_parameter(\"pole_ir1\", polescale)\n    call set_parameter(\"pole_ir2\", 0)\n    call evaluate_ct(id, psp, m2l0, m2ct_110)\n    call set_parameter(\"pole_uv\", 0)\n    call set_parameter(\"pole_ir1\", 0)\n    call set_parameter(\"pole_ir2\", 0)\n    call evaluate_ct(id, psp, m2l0, m2ct_000)\n\n    m2ct(0)=m2ct_000\n    m2ct(1)=(m2ct_110-m2ct_000)/polescale\n    m2ct(2)=0\n\n    ! restore original parameters\n    call set_parameter(\"pole_uv\", poleUV1bak)\n    call set_parameter(\"pole_ir1\", poleIR1bak)\n    call set_parameter(\"pole_ir2\", poleIR2bak)\n    call set_parameter(\"ct_on\", CT_on_bak)\n  end subroutine evaluate_loopct\n\n\n  subroutine evaluate_loopct_c(id, pp, m2l0, m2ct) bind(c,name=\"ol_evaluate_loopct\")\n    implicit none\n    integer(c_int), value :: id\n    real(c_double), intent(in) :: pp(5*n_external(id))\n    real(c_double), intent(out) :: m2l0, m2ct(0:2)\n    integer :: f_id\n    real(DREALKIND) :: f_pp(0:4,n_external(id))\n    real(DREALKIND) :: f_m2l0, f_m2ct(0:2)\n    f_id = id\n    call stop_invalid_id(f_id) ! needed because of reshape\n    if (error > 1) return\n    f_pp = reshape(pp, [5,process_handles(id)%n_particles])\n    call evaluate_loopct(f_id, f_pp(0:3,:), f_m2l0, f_m2ct)\n    m2l0 = f_m2l0\n    m2ct = f_m2ct\n  end subroutine evaluate_loopct_c\n\n\n  subroutine evaluate_iop(id, psp, m2l0, m2iop)\n    use ol_generic, only: to_string\n    use ol_loop_parameters_decl_/**/DREALKIND, only: IR_is_on\n    implicit none\n    integer, intent(in)  :: id\n    real(DREALKIND), intent(in)  :: psp(:,:)\n    real(DREALKIND), intent(out) :: m2l0, m2iop(0:2)\n    real(DREALKIND) :: m2l1(0:2), ir1(0:2), m2l2(0:4), ir2(0:4), acc\n    type(process_handle)  :: subprocess\n    integer :: IR_is_on_bak\n    if (error > 1) return\n    subprocess = process_handles(id)\n    if (.not. btest(subprocess%content, 1) .or. subprocess%amplitude_type < 10) then\n      call ol_fatal(\"evaluate: iop routine not available for process \" // trim(to_string(id)))\n      return\n    end if\n    n_scatt = subprocess%n_in\n    call tree_parameters_flush()\n    call subprocess%set_permutation(subprocess%permutation)\n    call subprocess%pol_init(subprocess%pol)\n    if (any(subprocess%photon_id /= 0)) call subprocess%set_photons(subprocess%photon_id)\n    IR_is_on_bak = IR_is_on\n    call set_parameter(\"ir_on\", 1)\n    call subprocess%iop(psp, m2l0, m2iop)\n    call set_parameter(\"ir_on\", IR_is_on_bak)\n  end subroutine evaluate_iop\n\n\n  subroutine evaluate_iop_c(id, pp, m2l0, m2iop) bind(c,name=\"ol_evaluate_iop\")\n    implicit none\n    integer(c_int), value :: id\n    real(c_double), intent(in) :: pp(5*n_external(id))\n    real(c_double), intent(out) :: m2l0, m2iop(0:2)\n    integer :: f_id\n    real(DREALKIND) :: f_pp(0:4,n_external(id))\n    real(DREALKIND) :: f_m2l0, f_m2iop(0:2)\n    f_id = id\n    call stop_invalid_id(f_id) ! needed because of reshape\n    if (error > 1) return\n    f_pp = reshape(pp, [5,process_handles(id)%n_particles])\n    call evaluate_iop(f_id, f_pp(0:3,:), f_m2l0, f_m2iop)\n    m2l0 = f_m2l0\n    m2iop = f_m2iop\n  end subroutine evaluate_iop_c\n\n\n  subroutine evaluate_schsf(id, psp, m2l0, m2schsf) bind(c,name=\"ol_evaluate_schsf\")\n    use ol_stability\n    use ol_generic, only: to_string\n    implicit none\n    integer, intent(in)  :: id\n    real(DREALKIND), intent(in)  :: psp(:,:)\n    real(DREALKIND), intent(out) :: m2l0, m2schsf\n    type(process_handle)  :: subprocess\n    call stop_invalid_id(id)\n    if (error > 1) return\n    subprocess = process_handles(id)\n    if (.not. btest(subprocess%content, 1)) then\n      call ol_fatal('evaluate: Spin-correlated hard scattering factor not available for process ' // trim(to_string(id)))\n      return\n    end if\n    if(.not. associated(subprocess%schsf)) then\n      call ol_fatal('evaluate: Spin-correlated hard scattering factor not available for process ' // trim(to_string(id)))\n      return\n    end if\n    n_scatt = subprocess%n_in\n    call subprocess%set_permutation(subprocess%permutation)\n    call subprocess%pol_init(subprocess%pol)\n    if (any(subprocess%photon_id /= 0)) call subprocess%set_photons(subprocess%photon_id)\n    call subprocess%schsf(psp, m2l0, m2schsf)\n  end subroutine evaluate_schsf\n\n\n\n  subroutine evaluate_r2(id, psp, m2l0, m2ct)\n    use ol_parameters_decl_/**/DREALKIND, only: add_associated_ew\n    use ol_loop_parameters_decl_/**/DREALKIND, only: CT_is_on, R2_is_on, TP_is_on, do_ew_renorm, use_bubble_vertex\n    use ol_init, only: set_if_modified, parameters_flush\n    use ol_stability\n    use ol_generic, only: to_string\n    implicit none\n    integer, intent(in)  :: id\n    real(DREALKIND), intent(in)  :: psp(:,:)\n    integer :: CT_on_bak, R2_on_bak, TP_on_bak, use_bubble_vertex_bak\n    real(DREALKIND), intent(out) :: m2l0, m2ct\n    real(DREALKIND) :: m2l0ew, m2ctew\n    type(process_handle)  :: subprocess, subprocessew\n    call stop_invalid_id(id)\n    if (error > 1) return\n    subprocess = process_handles(id)\n    if (.not. btest(subprocess%content, 1)) then\n      call ol_fatal('evaluate: ct routine not available for process ' // trim(to_string(id)))\n      return\n    end if\n    ! For compatibility: signal ctamp2 that this is the (new) interface (CT_is_on=-1),\n    ! where CT_is_on is set here, not in ctamp2.\n    CT_on_bak = CT_is_on\n    R2_on_bak = R2_is_on\n    TP_on_bak = TP_is_on\n    use_bubble_vertex_bak = use_bubble_vertex\n    call set_if_modified(CT_is_on, -1)\n    call set_if_modified(R2_is_on, 1)\n    call set_if_modified(TP_is_on, 0)\n    call set_if_modified(use_bubble_vertex, 0)\n    ! call parameters_flush() is done in ctamp2base,\n    ! because only there we know if ew renormalisation needs to be activated.\n    n_scatt = subprocess%n_in\n    call subprocess%set_permutation(subprocess%permutation)\n    call subprocess%pol_init(subprocess%pol)\n    if (any(subprocess%photon_id /= 0)) call subprocess%set_photons(subprocess%photon_id)\n    call subprocess%ct(psp, m2l0, m2ct)\n    call set_if_modified(CT_is_on, CT_on_bak)\n    call set_if_modified(R2_is_on, R2_on_bak)\n    call set_if_modified(TP_is_on, TP_on_bak)\n    call set_if_modified(use_bubble_vertex, use_bubble_vertex_bak)\n    call parameters_flush()\n  end subroutine evaluate_r2\n\n\n  subroutine evaluate_r2_c(id, pp, m2l0, m2ct) bind(c,name=\"ol_evaluate_r2\")\n    implicit none\n    integer(c_int), value :: id\n    real(c_double), intent(in) :: pp(5*n_external(id))\n    real(c_double), intent(out) :: m2l0, m2ct\n    integer :: f_id\n    real(DREALKIND) :: f_pp(0:4,n_external(id))\n    real(DREALKIND) :: f_m2l0, f_m2ct\n    f_id = id\n    call stop_invalid_id(f_id) ! needed because of reshape\n    if (error > 1) return\n    f_pp = reshape(pp, [5,process_handles(id)%n_particles])\n    call evaluate_r2(f_id, f_pp(0:3,:), f_m2l0, f_m2ct)\n    m2l0 = f_m2l0\n    m2ct = f_m2ct\n  end subroutine evaluate_r2_c\n\n\n  subroutine evaluate_pt(id, psp, m2l0, m2pt, m2l1)\n    use ol_stability\n    use ol_generic, only: to_string\n    implicit none\n    integer, intent(in) :: id\n    real(DREALKIND), intent(in)  :: psp(:,:)\n    real(DREALKIND), intent(out) :: m2l0, m2pt, m2l1\n    type(process_handle)  :: subprocess\n    call stop_invalid_id(id)\n    if (error > 1) return\n    subprocess = process_handles(id)\n    if (.not. btest(subprocess%content, 3)) then\n      call ol_fatal('evaluate: pt routine not available for process ' // trim(to_string(id)))\n      return\n    end if\n    n_scatt = subprocess%n_in\n    call subprocess%set_permutation(subprocess%permutation)\n    if (any(subprocess%photon_id /= 0)) call subprocess%set_photons(subprocess%photon_id)\n    call parameters_flush()\n    call subprocess%pt(psp, m2l0, m2pt, m2l1)\n  end subroutine evaluate_pt\n\n\n  subroutine evaluate_pt_c(id, pp, m2l0, m2pt, m2l1) bind(c,name=\"ol_evaluate_pt\")\n    implicit none\n    integer(c_int), value :: id\n    real(c_double), intent(in) :: pp(5*n_external(id))\n    real(c_double), intent(out) :: m2l0, m2pt, m2l1\n    integer :: f_id\n    real(DREALKIND) :: f_pp(0:4,n_external(id))\n    real(DREALKIND) :: f_m2l0, f_m2pt, f_m2l1\n    f_id = id\n    call stop_invalid_id(f_id) ! needed because of reshape\n    if (error > 1) return\n    f_pp = reshape(pp, [5,process_handles(id)%n_particles])\n    call evaluate_pt(f_id, f_pp(0:3,:), f_m2l0, f_m2pt, f_m2l1)\n    m2l0 = f_m2l0\n    m2pt = f_m2pt\n    m2l1 = f_m2l1\n  end subroutine evaluate_pt_c\n\n\n  subroutine evaluate_poles(id, psp, m2l0, m2bare, m2ct, m2ir, m2sum)\n    use ol_init, only: set_if_modified, parameters_flush\n    use ol_generic, only: to_string\n    use ol_loop_parameters_decl_/**/DREALKIND, only: CT_is_on, IR_is_on\n    use ol_loop_parameters_decl_/**/DREALKIND, only: de1_UV, de1_IR, de2_i_IR\n    implicit none\n    integer, intent(in)  :: id\n    real(DREALKIND), intent(in)  :: psp(:,:)\n    real(DREALKIND), intent(out) :: m2l0, m2bare(0:2), m2ct(0:2), m2ir(0:2), m2sum(0:2)\n    real(DREALKIND) :: m2l1(0:2), ir1(0:2), m2l2(0:4), ir2(0:4)\n    real(DREALKIND) :: m2l1_100(0:2), m2l1_010(0:2), m2l1_001(0:2), m2l1_000(0:2)\n    real(DREALKIND) :: m2ct_100, m2ct_010, m2ct_000\n    real(DREALKIND) :: acc, polescale\n    real(DREALKIND) :: poleUV1bak, poleIR1bak, poleIR2bak\n    integer polecheck, CT_on_bak, IR_on_bak\n    call stop_invalid_id(id)\n    if (error > 1) return\n    ! remember original parameters\n    poleUV1bak = de1_UV\n    poleIR1bak = de1_IR\n    poleIR2bak = de2_i_IR\n    CT_on_bak = CT_is_on\n    IR_on_bak = IR_is_on\n    call get_parameter(\"polescale\", polescale)\n    call get_parameter(\"polecheck\", polecheck)\n    if (polecheck > 0) then\n      call ol_msg(\"evaluate_poles: truepoles>0 not allowed.\")\n      return\n    end if\n\n    ! four calls to bare amplitude with different UV & IR poles\n    call set_parameter(\"ct_on\", 0)\n    call set_parameter(\"pole_uv\", polescale)\n    call set_parameter(\"pole_ir1\", 0)\n    call set_parameter(\"pole_ir2\", 0)\n    call set_parameter(\"ir_on\", 0)\n    call evaluate_full(id, psp, m2l0, m2l1_100, ir1, m2l2, ir2, acc)\n    call set_parameter(\"pole_uv\", 0)\n    call set_parameter(\"pole_ir1\", polescale)\n    call set_parameter(\"pole_ir2\", 0)\n    call evaluate_full(id, psp, m2l0, m2l1_010, ir1, m2l2, ir2, acc)\n    call set_parameter(\"pole_uv\", 0)\n    call set_parameter(\"pole_ir1\", 0)\n    call set_parameter(\"pole_ir2\", polescale)\n    call evaluate_full(id, psp, m2l0, m2l1_001, ir1, m2l2, ir2, acc)\n    call set_parameter(\"pole_uv\", 0)\n    call set_parameter(\"pole_ir1\", 0)\n    call set_parameter(\"pole_ir2\", 0)\n    call set_parameter(\"ir_on\", 1)\n    call evaluate_full(id, psp, m2l0, m2l1_000, ir1, m2l2, ir2, acc)\n\n    m2bare(0)=(m2l1_100(0)-m2l1_000(0))/polescale\n    m2bare(1)=(m2l1_010(0)-m2l1_000(0))/polescale\n    m2bare(2)=(m2l1_001(0)-m2l1_000(0))/polescale\n\n    ! three calls to CT amplitude with different UV & IR poles\n    call set_parameter(\"ct_on\", 1)\n    call set_parameter(\"pole_uv\", polescale)\n    call set_parameter(\"pole_ir1\", 0)\n    call set_parameter(\"pole_ir2\", 0)\n    call evaluate_ct(id, psp, m2l0, m2ct_100)\n    call set_parameter(\"pole_uv\", 0)\n    call set_parameter(\"pole_ir1\", polescale)\n    call set_parameter(\"pole_ir2\", 0)\n    call evaluate_ct(id, psp, m2l0, m2ct_010)\n    call set_parameter(\"pole_uv\", 0)\n    call set_parameter(\"pole_ir1\", 0)\n    call set_parameter(\"pole_ir2\", 0)\n    call evaluate_ct(id, psp, m2l0, m2ct_000)\n\n    m2ct(0)=(m2ct_100-m2ct_000)/polescale\n    m2ct(1)=(m2ct_010-m2ct_000)/polescale\n    m2ct(2)=0\n\n    m2ir(0)=0\n    m2ir(1)=ir1(1)\n    m2ir(2)=ir1(2)\n\n    m2sum=m2bare+m2ct+m2ir\n\n    ! restore original parameters\n    call set_parameter(\"pole_uv\", poleUV1bak)\n    call set_parameter(\"pole_ir1\", poleIR1bak)\n    call set_parameter(\"pole_ir2\", poleIR2bak)\n    call set_parameter(\"ct_on\", CT_on_bak)\n    call set_parameter(\"ir_on\", IR_on_bak)\n  end subroutine evaluate_poles\n\n\n  subroutine evaluate_poles_c(id, pp, m2l0, m2bare, m2ct, m2ir, m2sum) bind(c,name=\"ol_evaluate_poles\")\n    implicit none\n    integer(c_int), value :: id\n    real(c_double), intent(in) :: pp(5*n_external(id))\n    real(c_double), intent(out) :: m2l0, m2bare(0:2), m2ct(0:2), m2ir(0:2), m2sum(0:2)\n    integer :: f_id\n    real(DREALKIND) :: f_pp(0:4,n_external(id))\n    real(DREALKIND) :: f_m2l0, f_m2bare(0:2), f_m2ct(0:2), f_m2ir(0:2), f_m2sum(0:2)\n    real(DREALKIND) :: f_acc\n    f_id = id\n    call stop_invalid_id(f_id) ! needed because of reshape\n    if (error > 1) return\n    f_pp = reshape(pp, [5,process_handles(id)%n_particles])\n    call evaluate_poles(f_id, f_pp(0:3,:), f_m2l0, f_m2bare, f_m2ct, f_m2ir, f_m2sum)\n    m2l0 = f_m2l0\n    m2bare = f_m2bare\n    m2ct   = f_m2ct\n    m2ir   = f_m2ir\n    m2sum  = f_m2sum\n  end subroutine evaluate_poles_c\n\n\n\n  subroutine check_poles(id, psp_in)\n    use ol_generic, only: to_string\n    implicit none\n    integer, intent(in)  :: id\n    real(DREALKIND), intent(in), optional  :: psp_in(:,:)\n    real(DREALKIND) :: psp(0:3,n_external(int(id)))\n    real(DREALKIND) :: m2l0, m2bare(0:2), m2ct(0:2), m2ir(0:2), m2sum(0:2)\n    real(DREALKIND) :: energy = 2000\n    character(len=150) :: output\n    type(process_handle)  :: subprocess\n    integer :: polecheck\n\n    subprocess = process_handles(id)\n    if (.not. btest(subprocess%content, 1) .and. subprocess%replace_loop==0) then\n      return\n    end if\n\n    call get_parameter(\"polecheck\", polecheck)\n    if (polecheck > 0) then\n      call ol_msg(\"check_poles: truepoles>0 not allowed.\")\n      return\n    end if\n\n    if(present(psp_in)) then\n      psp = psp_in\n    else\n      call phase_space_point(id, energy, psp)\n    end if\n\n    call evaluate_poles(id, psp, m2l0, m2bare, m2ct, m2ir, m2sum)\n2000 format(4e25.16, 4e25.16, 4e25.16)\n    call ol_msg(\"== UV and IR Poles for process: \" // trim(to_string(id)) // \" ==\")\n    write(output, 2000) m2l0\n    call ol_msg(\"Wtree       = \" // output)\n    call ol_msg(\"                 UVeps1                   IReps1                   IReps2\")\n    write(output, 2000) m2bare(0), m2bare(1), m2bare(2)\n    call ol_msg(\"Wbare       = \"// output)\n    write(output, 2000) m2ct(0), m2ct(1), m2ct(2)\n    call ol_msg(\"Wct         = \"// output)\n    write(output, 2000) m2ir(0), m2ir(1), m2ir(2)\n    call ol_msg(\"WI-operator = \"// output)\n    write(output, 2000) m2sum(0), m2sum(1), m2sum(2)\n    call ol_msg(\"W1-loop     = \"// output)\n\n\n  end subroutine check_poles\n\n\nend module openloops\n",
        "/tmp/vanessa/spack-stage/spack-stage-openloops-2.1.1-2pxb7uebklk56opjo3yqpykinay2r4n5/spack-src/lib_src/olcommon/src/common.F90": "!******************************************************************************!\n! Copyright (C) 2014-2019 OpenLoops Collaboration. For authors see authors.txt !\n!                                                                              !\n! This file is part of OpenLoops.                                              !\n!                                                                              !\n! OpenLoops is free software: you can redistribute it and/or modify            !\n! it under the terms of the GNU General Public License as published by         !\n! the Free Software Foundation, either version 3 of the License, or            !\n! (at your option) any later version.                                          !\n!                                                                              !\n! OpenLoops is distributed in the hope that it will be useful,                 !\n! but WITHOUT ANY WARRANTY; without even the implied warranty of               !\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                !\n! GNU General Public License for more details.                                 !\n!                                                                              !\n! You should have received a copy of the GNU General Public License            !\n! along with OpenLoops.  If not, see <http://www.gnu.org/licenses/>.           !\n!******************************************************************************!\n\n\n! ol_dilog configuration\n! stop series expansion when the result does not change anymore\n#define COMPARE\n! check expansion depth required to achieve full precision;\n! store the number of points which required n terms in bin(n)\n!#CHECK_DEPTH\n\n\n#ifdef PRECISION_dp\n\nmodule ol_generic\n  ! precision independent generic routines\n  implicit none\n\n  character(len=26), private, parameter :: lower_case = 'abcdefghijklmnopqrstuvwxyz'\n  character(len=26), private, parameter :: upper_case = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\n  interface to_string\n    module procedure integer_to_string, integer1_to_string, &\n          & double_to_string, complex_to_string, single_to_string, &\n          & integerlist_to_string, doublelist_to_string, complexlist_to_string, &\n          logical_to_string\n  end interface to_string\n\n  interface to_int\n    module procedure string_to_integer\n  end interface to_int\n\n  interface relative_deviation\n    module procedure relative_deviation_dp, relative_deviation_qp\n  end interface relative_deviation\n\n  contains\n\n  function integer_to_string(x)\n    implicit none\n    integer :: x\n    character(12) :: integer_to_string\n    write(integer_to_string,*) x\n    integer_to_string = adjustl(integer_to_string)\n  end function integer_to_string\n\n  function integer1_to_string(x)\n    use KIND_TYPES, only: intkind1\n    implicit none\n    integer(intkind1) :: x\n    character(12) :: integer1_to_string\n    write(integer1_to_string,*) x\n    integer1_to_string = adjustl(integer1_to_string)\n  end function integer1_to_string\n\n  function integer2_to_string(x)\n    use KIND_TYPES, only: intkind2\n    implicit none\n    integer(intkind2) :: x\n    character(12) :: integer2_to_string\n    write(integer2_to_string,*) x\n    integer2_to_string = adjustl(integer2_to_string)\n  end function integer2_to_string\n\n  function integerlist_to_string(x,del,sep)\n    implicit none\n    integer :: x(:)\n    character(13*size(x)+1) :: integerlist_to_string\n    logical, optional, intent(in) :: del\n    character(1), optional, intent(in) :: sep\n    character(1) :: seperator\n    integer :: k\n    if (present(sep)) then\n      seperator = sep\n    else\n      seperator = \",\"\n    end if\n    integerlist_to_string = \"\"\n    if (present(del)) then\n      if (del) integerlist_to_string = \"[\"\n    end if\n    if (size(x) /= 0) integerlist_to_string = trim(integerlist_to_string) // trim(integer_to_string(x(1)))\n    do k = 2, size(x)\n      integerlist_to_string = trim(integerlist_to_string) // seperator // trim(integer_to_string(x(k)))\n    end do\n    if (present(del)) then\n      if (del) integerlist_to_string = trim(integerlist_to_string) // \"]\"\n    end if\n  end function integerlist_to_string\n\n  function logical_to_string(x)\n    implicit none\n    logical :: x\n    character(5) :: logical_to_string\n    !write(integer_to_string,*) x\n    if (x .eqv. .true.) then\n      logical_to_string = \"True\"\n    else\n      logical_to_string = \"False\"\n    end if\n  end function logical_to_string\n\n  function doublelist_to_string(x,del,sep)\n    use KIND_TYPES, only: DREALKIND\n    implicit none\n    real(DREALKIND) :: x(:)\n    character(29*size(x)+1) :: doublelist_to_string\n    logical, optional, intent(in) :: del\n    character(1), optional, intent(in) :: sep\n    character(1) :: seperator\n    integer :: k\n    if (present(sep)) then\n      seperator = sep\n    else\n      seperator = \",\"\n    end if\n    doublelist_to_string = \"\"\n    if (present(del)) then\n      if (del) doublelist_to_string = \"[\"\n    end if\n    if (size(x) /= 0) doublelist_to_string = trim(doublelist_to_string) // trim(double_to_string(x(1)))\n    do k = 2, size(x)\n      doublelist_to_string = trim(doublelist_to_string) // seperator // trim(double_to_string(x(k)))\n    end do\n    if (present(del)) then\n      if (del) doublelist_to_string = trim(doublelist_to_string) // \"]\"\n    end if\n  end function doublelist_to_string\n\n  function complexlist_to_string(x,del,sep)\n    use KIND_TYPES, only: DREALKIND\n    implicit none\n    complex(DREALKIND) :: x(:)\n    character(60*size(x)+1) :: complexlist_to_string\n    logical, optional, intent(in) :: del\n    character(1), optional, intent(in) :: sep\n    character(1) :: seperator\n    integer :: k\n    if (present(sep)) then\n      seperator = sep\n    else\n      seperator = \",\"\n    end if\n    complexlist_to_string = \"\"\n    if (present(del)) then\n      if (del) complexlist_to_string = \"[\"\n    end if\n    if (size(x) /= 0) complexlist_to_string = trim(complexlist_to_string) // trim(complex_to_string(x(1)))\n    do k = 2, size(x)\n      complexlist_to_string = trim(complexlist_to_string) // seperator // trim(complex_to_string(x(k)))\n    end do\n    if (present(del)) then\n      if (del) complexlist_to_string = trim(complexlist_to_string) // \"]\"\n    end if\n  end function complexlist_to_string\n\n  function string_to_integerlist(c_in)\n  ! convert a comma/space/slash separated string of numbers into an array of integers\n    implicit none\n    character(len=*), intent(in) :: c_in\n    character(len(c_in)+1) :: c\n    integer, allocatable :: string_to_integerlist(:)\n    integer i, n, pos1\n    logical last_seperator\n\n    c = c_in // \" \"\n\n    n=0\n    pos1=0\n    last_seperator =  .false.\n    do i = 1, len(c)\n      if (c(i:i) == \"[\" .or. c(i:i) == \"]\") c(i:i) = \" \"\n\n      if (c(i:i) == ',' .or. c(i:i) == ' ' .or. c(i:i) == \"/\" ) then\n        if (last_seperator)  then\n          pos1 = i\n          cycle\n        end if\n        n = n+1\n        pos1 = i\n        last_seperator = .true.\n      else\n        last_seperator = .false.\n      end if\n    end do\n\n    allocate(string_to_integerlist(n))\n\n    n=0\n    pos1=0\n    last_seperator =  .false.\n    do i = 1, len(c)\n      if (c(i:i) == ',' .or. c(i:i) == ' ' .or. c(i:i) == \"/\") then\n        if (last_seperator)  then\n          pos1 = i\n          cycle\n        end if\n        n = n+1\n        string_to_integerlist(n) = string_to_integer(c(pos1+1:i-1))\n        pos1 = i\n        last_seperator = .true.\n      else\n        last_seperator = .false.\n      end if\n    end do\n  end function string_to_integerlist\n\n\n  function double_to_string(x)\n    use KIND_TYPES, only: DREALKIND\n    implicit none\n    real(DREALKIND) :: x\n    character(28) :: double_to_string\n    character(26) :: str\n    integer :: k, epos, mantissaendpos\n    logical :: leading0\n    write(str,*) x\n    str = adjustl(str)\n    epos = index(to_lowercase(str), \"e\")\n    if (epos == 0) then\n      mantissaendpos = len(trim(str))\n    else\n      mantissaendpos = epos-1\n    end if\n    double_to_string = str(1:mantissaendpos)\n    do k = mantissaendpos, 1, -1\n      if (double_to_string(k:k) == \"0\") then\n        double_to_string(k:k) = \" \"\n      else\n        exit\n      end if\n    end do\n    if (epos /= 0) then\n      double_to_string = trim(double_to_string) // \"e\"\n      if (str(epos+1:epos+1) == \"+\" .or. str(epos+1:epos+1) == \"-\") then\n        double_to_string = trim(double_to_string) // str(epos+1:epos+1)\n        epos = epos + 1\n      end if\n      leading0 = .true.\n      do k = epos+1, len(str)\n        if (str(k:k) == \"0\" .and. leading0) then\n          cycle\n        else\n          leading0 = .false.\n          double_to_string = trim(double_to_string) // str(k:k)\n        end if\n      end do\n    end if\n    double_to_string = trim(double_to_string) // \"_dp\"\n  end function double_to_string\n\n  function single_to_string(x)\n    implicit none\n    real(selected_real_kind(6)) :: x\n    character(20) :: single_to_string\n    character(18) :: str\n    integer :: k, epos, mantissaendpos\n    logical :: leading0\n    write(str,*) x\n    str = adjustl(str)\n    epos = index(to_lowercase(str), \"e\")\n    if (epos == 0) then\n      mantissaendpos = len(trim(str))\n    else\n      mantissaendpos = epos-1\n    end if\n    single_to_string = str(1:mantissaendpos)\n    do k = mantissaendpos, 1, -1\n      if (single_to_string(k:k) == \"0\") then\n        single_to_string(k:k) = \" \"\n      else\n        exit\n      end if\n    end do\n    if (epos /= 0) then\n      single_to_string = trim(single_to_string) // \"e\"\n      if (str(epos+1:epos+1) == \"+\" .or. str(epos+1:epos+1) == \"-\") then\n        single_to_string = trim(single_to_string) // str(epos+1:epos+1)\n        epos = epos + 1\n      end if\n      leading0 = .true.\n      do k = epos+1, len(str)\n        if (str(k:k) == \"0\" .and. leading0) then\n          cycle\n        else\n          leading0 = .false.\n          single_to_string = trim(single_to_string) // str(k:k)\n        end if\n      end do\n    end if\n    single_to_string = trim(single_to_string) // \"_sp\"\n  end function single_to_string\n\n\n\n  function complex_to_string(x)\n    use KIND_TYPES, only: DREALKIND\n    implicit none\n    complex(DREALKIND) :: x\n    character(59) :: complex_to_string\n    complex_to_string = \"(\" // trim(double_to_string(real(x))) // &\n                      & \",\" // trim(double_to_string(aimag(x))) // \")\"\n  end function complex_to_string\n\n\n  function string_to_integer(c)\n    implicit none\n    character(len=*), intent(in) :: c\n    integer :: string_to_integer\n    integer :: stat\n    read(c,*,iostat=stat) string_to_integer\n    if (stat /= 0) then\n!      print*, \"[OpenLoops] Error: string to integer conversion not possible for string: \", c\n      string_to_integer = -huge(string_to_integer)\n    end if\n  end function string_to_integer\n\n\n  pure function factorial(k)\n    implicit none\n    integer, intent(in) :: k\n    integer :: factorial, i\n    factorial = 1\n    do i = 1, k\n      factorial = factorial * i\n    end do\n  end function factorial\n\n\n  pure function binomial(n, k)\n    implicit none\n    integer :: binomial\n    integer, intent(in) :: n, k\n    integer :: i\n    if (k < 0 .or. k > n) then\n      binomial = 0\n    else\n      binomial = 1\n      do i = 1, min(k, n-k)\n        binomial = (binomial * (n-i+1)) / (i)\n      end do\n    end if\n  end function binomial\n\n\n  function nth_permutation(arr, n)\n    ! return the n-th permutation of arr, defined by the set of canonically\n    ! order permutations of [1,..,size(arr)] (same ordering as Mathematicas Permutation[]).\n    implicit none\n    integer, intent(in) :: arr(:), n\n    integer :: nth_permutation(size(arr))\n    integer :: arrcp(size(arr)), sz, nn, pos, ppos, fac\n    sz = size(arr)\n    arrcp = arr\n    ppos = n - 1\n    do nn = 1, size(arr)\n      fac = factorial(sz-nn)\n      pos = ppos/fac\n      ppos = ppos - pos*fac\n      nth_permutation(nn) = arrcp(pos+1)\n      arrcp(pos+1:sz-nn) = arrcp(pos+2:sz-nn+1)\n    end do\n  end function nth_permutation\n\n\n  function perm_pos(perm)\n    ! Unique mapping of a permutation perm(1:n) -> integer in [1..n!].\n    ! In a canonically ordered list of all permutations\n    ! (like Mathematicas Permutations[Range[n]]),\n    ! perm is at position perm_pos\n    implicit none\n    integer :: perm_pos\n    integer, intent(in) :: perm(:)\n    integer :: n, k, pos1, perm2(size(perm))\n    perm_pos = 1\n    perm2 = perm\n    do n = size(perm)-1, 1, -1\n      pos1 = perm2(1)\n      do k = 1, n\n        if (perm2(k+1) > pos1) then\n          perm2(k) = perm2(k+1)-1\n        else\n          perm2(k) = perm2(k+1)\n        end if\n      end do\n      perm_pos = perm_pos + (pos1-1)*factorial(n)\n    end do\n  end function perm_pos\n\n\n  recursive subroutine compositions2(compos, n, maxpart)\n    ! Store all unordered compositions of the integer n into integers >= 2\n    ! in the allocatable array compos. Each composition compos(:,k) is ordered\n    ! by constituents, larger first. The compositions array is ordered by\n    ! constituents at the beginning of the composition, smaller first,\n    ! independent of the composition length (i.e. not sorted by length).\n    ! The optional parameter maxpart sets the maximal allowed size of the constituents.\n    implicit none\n    integer, allocatable, intent(out) :: compos(:,:)\n    integer, intent(in) :: n\n    integer, intent(in), optional :: maxpart\n    integer :: maxp, j, k, next\n    integer, allocatable :: thisc(:,:), lowerc(:,:)\n    if (n == 0) then\n      allocate(compos(0,1))\n      return\n    else if (n == 1) then\n      allocate(thisc(1,10))\n    else\n      allocate(thisc(n/2,10))\n    end if\n    if (present(maxpart)) then\n      maxp = maxpart\n    else\n      maxp = n\n    end if\n    next = 1\n    do k = 2, min(n-2, maxp)\n      call compositions2(lowerc, n-k, k)\n      do j = 1, size(lowerc,2)\n        if (size(thisc,2) == next) then\n          allocate(compos(n/2,next))\n          compos = thisc\n          deallocate(thisc)\n          allocate(thisc(n/2,10*next))\n          thisc(:,1:next) = compos\n          deallocate(compos)\n        end if\n        thisc(:,next) = 0\n        thisc(1,next) = k\n        thisc(2:size(lowerc,1)+1,next) = lowerc(:,j)\n        next = next + 1\n      end do\n      deallocate(lowerc)\n    end do\n    next = next - 1\n    if (n <= maxp) then\n      next = next + 1\n      thisc(:,next) = 0\n      thisc(1,next) = n\n    end if\n    allocate(compos(size(thisc,1),next))\n    compos = thisc(:,1:next)\n    deallocate(thisc)\n  end subroutine compositions2\n\n\n  function compositions(n, k)\n    ! compositions of n into k parts.\n    ! compositions(1:k,j) for j=1:binomial(n+k-1,k-1)\n    ! are the canonically ordered compositions.\n    implicit none\n    integer, intent(in) :: n, k\n    integer :: compositions(k,binomial(n+k-1,k-1))\n    integer :: compos(k-1,binomial(n+k-1,k-1))\n    integer :: lowersz, pos, a, b, c, comp(k-1)\n    lowersz = 1\n    do a = 1, k-1\n      pos = 0\n      do b = 1, lowersz\n        comp(1:a-1) = compositions(1:a-1,b)\n        do c = 0, n-sum(comp(1:a-1))\n          pos = pos + 1\n          compos(1:a-1,pos) = comp(1:a-1)\n          compos(a,pos) = c\n        end do\n      end do\n      lowersz = pos\n      compositions(1:a,1:lowersz) = compos(1:a,1:lowersz)\n    end do\n    if (k > 0) then\n      do pos = 1, lowersz\n        compositions(k,pos) = n - sum(compositions(1:k-1,pos))\n      end do\n    end if\n  end function compositions\n\n\n  function relative_deviation_dp(a, b) result (relative_deviation)\n    use KIND_TYPES, only: DREALKIND\n    implicit none\n    real(DREALKIND), intent(in) :: a, b\n    real(DREALKIND) :: relative_deviation\n    if (a == b) then\n      relative_deviation = 0\n    else if ( a == 0 .or. b == 0) then\n      relative_deviation = huge(a)\n    else\n      relative_deviation = max(abs(a/b-1), abs(b/a-1))\n    end if\n  end function relative_deviation_dp\n\n\n  function relative_deviation_qp(a, b) result (relative_deviation)\n    use KIND_TYPES, only: QREALKIND\n    implicit none\n    real(QREALKIND), intent(in) :: a, b\n    real(QREALKIND) :: relative_deviation\n    if (a == b) then\n      relative_deviation = 0\n    else if ( a == 0 .or. b == 0) then\n      relative_deviation = huge(a)\n    else\n      relative_deviation = max(abs(a/b-1), abs(b/a-1))\n    end if\n  end function relative_deviation_qp\n\n\n  function digit_agreement(a, b)\n    use KIND_TYPES, only: DREALKIND\n    implicit none\n    real(DREALKIND), intent(in) :: a, b\n    real(DREALKIND) :: digit_agreement\n    if (a == b) then\n      digit_agreement = 16\n    else if (a == 0 .or. b == 0) then\n      digit_agreement = 0\n    else\n      digit_agreement = -log10(relative_deviation(a, b))\n    end if\n  end function digit_agreement\n\n\n  function random_string(n)\n    ! Return a printable random string of n 6-bit characters\n    ! from the set [0-9A-Za-z$_]\n    implicit none\n    integer, intent(in) :: n\n    integer :: j\n    integer(1) :: ran(n), i\n    character(len=n) :: random_string\n    open(42, file='/dev/urandom', access='stream', form='unformatted')\n    read(42) ran\n    close(42)\n    do j = 1, n\n      i = ishft(ran(j),-2) + 43 ! 43:     +     37+ 8=45\n      if (i > 43) i = i + 1     ! 45:     -     46+ 2=48\n      if (i > 45) i = i + 2     ! 48- 57: 0-9   58+ 7=65\n      if (i > 57) i = i + 7     ! 65- 90: A-Z   91+ 6=97\n      if (i > 90) i = i + 6     ! 97-122: a-z\n      random_string(j:j) = char(i)\n    end do\n  end function random_string\n\n\n  function to_lowercase(instr)\n    ! return instr with uppercase letters converted to lowercase\n    implicit none\n    character(*), intent(in) :: instr\n    character(len(instr)) :: to_lowercase\n    integer :: i, n\n    to_lowercase = instr\n    do i = 1, len(to_lowercase)\n      n = index(upper_case, to_lowercase(i:i))\n      if (n /= 0) to_lowercase(i:i) = lower_case(n:n)\n    end do\n  end function to_lowercase\n\n\n  function count_substring(s1, s2) result(c)\n  ! counts the occurance of string s2 in string s1\n    character(*), intent(in) :: s1, s2\n    integer :: c, p, posn\n\n    c = 0\n    if(len(s2) == 0) return\n    p = 1\n    do\n      posn = index(s1(p:), s2)\n      if(posn == 0) return\n      c = c + 1\n      p = p + posn + len(s2)\n    end do\n  end function count_substring\n\nend module ol_generic\n\n\n\nmodule ol_iso_c_utilities\n  ! function c_f_string_ptr(cptr)\n  !   type(c_ptr), intent(in) :: cptr\n  !   character(kind=c_char), pointer :: c_f_string_ptr(:)\n  !   - convert a null terminated C character array pointer to a Fortran string pointer;\n  ! subroutine c_f_string_static(c_str, f_str, maxlen):\n  !   character(kind=c_char), dimension(*), intent(in) :: c_str\n  !   integer, intent(in) :: maxlen\n  !   character(len=maxlen), intent(out) :: f_str\n  !   - convert a null terminated C character array to a Fortran string;\n  ! subroutine c_f_string_alloc(c_str, f_str):\n  !   character(kind=c_char), dimension(*), intent(in) :: c_str\n  !   character(len=:), allocatable, intent(out) :: f_str\n  !   - convert a null terminated C character array to a Fortran allocatable string;\n  use, intrinsic :: iso_c_binding, only: c_char, c_ptr, c_long, c_short\n  implicit none\n\n  character(kind=c_char), save, target, private :: dummy_string(1) = \"?\"\n\n  interface\n    function strlen(string) bind(c)\n      ! int strlen(char *string)\n      use, intrinsic :: iso_c_binding, only: c_int, c_ptr\n      implicit none\n      type(c_ptr), value :: string\n      integer(c_int) :: strlen\n    end function strlen\n  end interface\n\n  interface c_f_string\n    module procedure c_f_string_static!, c_f_string_alloc\n  end interface c_f_string\n\n  contains\n\n  function c_f_string_ptr(cptr)\n    use, intrinsic :: iso_c_binding, only: c_char, c_ptr, c_associated, c_f_pointer\n    implicit none\n    type(c_ptr), intent(in) :: cptr\n    character(kind=c_char), pointer :: c_f_string_ptr(:)\n    if (c_associated(cptr)) then\n      call c_f_pointer(cptr, c_f_string_ptr, shape = [strlen(cptr)])\n    else\n      ! if cptr is a null pointer, return 'dummy_string'\n      c_f_string_ptr => dummy_string\n    end if\n  end function c_f_string_ptr\n\n\n  subroutine c_f_string_static(c_str, f_str, maxlen)\n    use, intrinsic :: iso_c_binding, only: c_char, c_ptr, c_loc, c_f_pointer\n    implicit none\n    character(kind=c_char), dimension(*), intent(in), target :: c_str\n    integer, intent(in) :: maxlen\n    type(c_ptr) :: c_str_ptr\n    character(len=maxlen), intent(out) :: f_str\n    character(kind=c_char), pointer :: f_str_ptr(:)\n    integer :: slen, i\n    c_str_ptr = c_loc(c_str)\n    slen = strlen(c_str_ptr)\n    call c_f_pointer(c_str_ptr, f_str_ptr, shape = [slen])\n    f_str = \"\"\n    do i = 1, slen\n      f_str(i:i) = f_str_ptr(i)\n    end do\n  end subroutine c_f_string_static\n\n\n!   subroutine f_c_string_static(f_str, c_str, maxlen)\n!     use, intrinsic :: iso_c_binding, only: c_char, c_ptr, c_loc, c_f_pointer\n!     implicit none\n!     character(len=*), intent(in) :: f_str\n!     character(kind=c_char), dimension(size(f_str)), intent(out), target :: c_str\n!     type(c_ptr) :: c_str_ptr\n!     character(len=maxlen), intent(out) :: f_str\n!     character(kind=c_char), pointer :: f_str_ptr(:)\n!     integer :: slen, i\n!     c_str_ptr = c_loc(c_str)\n!     slen = strlen(c_str_ptr)\n!     call c_f_pointer(c_str_ptr, f_str_ptr, shape = [slen])\n!     f_str = \"\"\n!     do i = 1, slen\n!       f_str(i:i) = f_str_ptr(i)\n!     end do\n!   end subroutine c_f_string_static\n!\n\n! deactivate to circumvent a bug in certain gfortran versions.\n! Previously used in register_process_c, olp_setparameter_c, olp_printparameter_c, olp_start_c\n!   subroutine c_f_string_alloc(c_str, f_str)\n!     use, intrinsic :: iso_c_binding, only: c_char, c_ptr, c_loc, c_f_pointer\n!     implicit none\n!     character(kind=c_char), dimension(*), intent(in), target :: c_str\n!     type(c_ptr) :: c_str_ptr\n!     character(len=:), allocatable, intent(out) :: f_str\n!     character(kind=c_char), pointer :: f_str_ptr(:)\n!     integer :: slen, i\n!     c_str_ptr = c_loc(c_str)\n!     slen = strlen(c_str_ptr)\n!     call c_f_pointer(c_str_ptr, f_str_ptr, shape = [slen])\n!     if (allocated(f_str)) deallocate(f_str)\n!     allocate(character(len=size(f_str_ptr))::f_str) ! len=slen does not work\n!     do i = 1, slen\n!       f_str(i:i) = f_str_ptr(i)\n!     end do\n!   end subroutine c_f_string_alloc\n\n\nend module ol_iso_c_utilities\n\n\nmodule ol_cwrappers\n  ! err = opendir(dirname)\n  !   open directory; only one directory can be open at a time;\n  !   err=0 if successful\n  ! err = readdir(entryname)\n  !   read next entry from directory;\n  !   err=0 if successful; entryname=\"\" if all entries were retrieved;\n  ! closedir()\n  !   close directory\n  ! mkdir(dirname)\n  !   create directory\n  use, intrinsic :: iso_c_binding, only: c_char, c_null_char\n  use ol_iso_c_utilities, only: c_f_string\n  implicit none\n  private\n  public :: opendir, readdir, closedir, mkdir, direntry_length\n  public :: stdout_off, stdout_on\n  integer, parameter :: direntry_length = 256\n  interface\n    function c_opendir(dirname) bind(c,name=\"ol_c_opendir\")\n      ! int ol_c_opendir(const char *dirname)\n      use, intrinsic :: iso_c_binding, only: c_char, c_int\n      implicit none\n      character(kind=c_char), dimension(*), intent(in) :: dirname\n      integer(c_int) :: c_opendir\n    end function c_opendir\n    function c_readdir(entryname) bind(c,name=\"ol_c_readdir\")\n      ! int ol_c_readdir(char* entryname)\n      use, intrinsic :: iso_c_binding, only: c_char, c_int\n      implicit none\n      character(kind=c_char), intent(out) :: entryname(256) ! =direntry_length\n      integer(c_int) :: c_readdir\n    end function c_readdir\n    subroutine c_closedir() bind(c,name=\"ol_c_closedir\")\n      ! void ol_c_closedir()\n      implicit none\n    end subroutine c_closedir\n    function c_mkdir(dirname) bind(c,name=\"ol_c_mkdir\")\n      ! int ol_c_mkdir(char* dirname)\n      use, intrinsic :: iso_c_binding, only: c_char, c_int\n      implicit none\n      character(kind=c_char), dimension(*), intent(in) :: dirname\n      integer(c_int) :: c_mkdir\n    end function c_mkdir\n  end interface\n\n  interface\n    subroutine stdout_off() bind(c,name=\"ol_c_stdout_off\")\n      implicit none\n    end subroutine stdout_off\n    subroutine stdout_on() bind(c,name=\"ol_c_stdout_on\")\n      implicit none\n    end subroutine stdout_on\n  end interface\n\n  contains\n\n  function opendir(dirname)\n    implicit none\n    character(len=*), intent(in) :: dirname\n    integer :: opendir\n    opendir = c_opendir(trim(dirname) // c_null_char)\n    if (opendir == 127) then\n      print *, \"[OpenLoops] opendir: a directory is already open.\"\n    else if (opendir /= 0) then\n      print *, \"[OpenLoops] opendir: error\", opendir\n    end if\n  end function opendir\n\n  function readdir(entryname)\n    implicit none\n    character(*), intent(out) :: entryname\n    integer :: readdir\n    character(kind=c_char) :: c_entryname(direntry_length)\n    if (len(entryname) < 256) then\n      print *, \"[OpenLoops] readdir argument length <256.\"\n      readdir = 127\n      return\n    end if\n    readdir = c_readdir(c_entryname)\n    if (readdir /= 0) then\n      print *, \"[OpenLoops] readdir: error reading directory content.\"\n    end if\n    entryname = \"\"\n    call c_f_string(c_entryname, entryname, direntry_length)\n  end function readdir\n\n  subroutine closedir()\n    implicit none\n    call c_closedir()\n  end subroutine closedir\n\n  function mkdir(dirname)\n    implicit none\n    character(len=*), intent(in) :: dirname\n    integer :: mkdir\n    mkdir = c_mkdir(trim(dirname) // c_null_char)\n  end function mkdir\n\nend module ol_cwrappers\n\n\nmodule ol_dlfcn\n  use, intrinsic :: iso_c_binding, only: c_int, c_char, c_ptr, c_funptr, &\n    & c_null_char, c_associated, c_f_procpointer\n  implicit none\n  private\n  public :: RTLD_LAZY, RTLD_NOW, RTLD_GLOBAL, RTLD_LOCAL\n  public :: dlopen, dlsym, dlclose\n  ! dlopen modes:\n  integer(c_int), bind(c,name=\"ol_c_rtld_lazy\") :: RTLD_LAZY\n  integer(c_int), bind(c,name=\"ol_c_rtld_now\") :: RTLD_NOW\n  integer(c_int), bind(c,name=\"ol_c_rtld_global\") :: RTLD_GLOBAL\n  integer(c_int), bind(c,name=\"ol_c_rtld_local\") :: RTLD_LOCAL\n\n  interface\n    function c_dlopen(file, mode) bind(c,name=\"dlopen\")\n      ! void *dlopen(const char *file, int mode);\n      use, intrinsic :: iso_c_binding, only: c_char, c_int, c_ptr\n      implicit none\n      character(kind=c_char), dimension(*), intent(in) :: file\n      integer(c_int), value :: mode\n      type(c_ptr) :: c_dlopen\n    end function c_dlopen\n    function c_dlsym(lib, sym) bind(c,name=\"dlsym\")\n      ! void *dlsym(void *lib, const char *sym);\n      use, intrinsic :: iso_c_binding, only: c_ptr, c_char, c_funptr\n      implicit none\n      type(c_ptr), value :: lib\n      character(kind=c_char), dimension(*), intent(in) :: sym\n      type(c_funptr) :: c_dlsym\n    end function c_dlsym\n    function c_dlclose(lib) bind(c,name=\"dlclose\")\n      ! int dlclose(void *lib);\n      use, intrinsic :: iso_c_binding, only: c_ptr, c_int\n      implicit none\n      type(c_ptr), value :: lib\n      integer(c_int) :: c_dlclose ! status\n    end function c_dlclose\n    function c_dlerror() bind(c,name=\"dlerror\")\n      ! char *dlerror(void);\n      use, intrinsic :: iso_c_binding, only: c_ptr\n      implicit none\n      type(c_ptr) :: c_dlerror\n    end function c_dlerror\n  end interface\n\n  contains\n\n  function dlerror()\n    use ol_iso_c_utilities, only: c_f_string_ptr\n    implicit none\n    character(kind=c_char), dimension(:), pointer :: dlerror\n    dlerror => c_f_string_ptr(c_dlerror())\n  end function\n\n  function dlopen(file, mode, fatal)\n    ! fatal: 0=silent (default), 1=warning, 2=error\n    implicit none\n    character(len=*), intent(in) :: file\n    integer(c_int), intent(in) :: mode\n    integer, intent(in), optional :: fatal\n    type(c_ptr) :: dlopen\n    dlopen = c_dlopen(trim(file) // c_null_char, mode)\n    if (present(fatal)) then\n      if (fatal == 1 .and. .not. c_associated(dlopen)) then\n        print *, \"[OpenLoops] dlopen:\", dlerror()\n      else if (fatal == 2 .and. .not. c_associated(dlopen)) then\n        print *, \"[OpenLoops] error in dlopen:\", dlerror()\n        stop\n      end if\n    end if\n  end function dlopen\n\n  function dlsym(lib, sym, fatal) result(f_funp)\n    ! fatal: 0=silent (default), 1=warning, 2=error\n    implicit none\n    type(c_ptr), intent(in) :: lib\n    character(len=*), intent(in) :: sym\n    integer, intent(in), optional :: fatal\n    type(c_funptr) :: c_funp\n    procedure(), pointer :: f_funp\n    c_funp = c_dlsym(lib, trim(sym) // c_null_char)\n    if (present(fatal)) then\n      if (fatal == 1 .and. .not. c_associated(c_funp)) then\n        print *, \"[OpenLoops] dlsym:\", dlerror()\n      else if (fatal == 2 .and. .not. c_associated(c_funp)) then\n        print *, \"[OpenLoops] error in dlsym:\", dlerror()\n        stop\n      end if\n    end if\n    if (c_associated(c_funp)) then\n      call c_f_procpointer(c_funp, f_funp)\n    else\n      f_funp => null()\n    end if\n  end function dlsym\n\n  subroutine dlclose(lib, fatal)\n    ! fatal: 0=silent (default), 1=warning, 2=error\n    implicit none\n    type(c_ptr), intent(in) :: lib\n    integer, intent(in), optional :: fatal\n    integer(c_int) :: status\n    status = c_dlclose(lib)\n    if (present(fatal)) then\n      if (fatal == 1 .and. status /= 0) then\n        print *, \"[OpenLoops] dlclose:\", dlerror()\n      else if (fatal == 2 .and. status /= 0) then\n        print *, \"[OpenLoops] error in dlclose:\", dlerror()\n        stop\n      end if\n    end if\n  end subroutine dlclose\n\nend module ol_dlfcn\n\n#endif\n\n\n\nmodule ol_dilog_/**/REALKIND\n  use KIND_TYPES, only: REALKIND\n  implicit none\n  real(REALKIND), parameter :: pi2_6 = 8/3._/**/REALKIND*atan(1._/**/REALKIND)**2\n#ifdef PRECISION_sp\n  integer, parameter :: max_n = 15\n#else\n  integer, parameter :: max_n = 29\n#endif\n#ifdef CHECK_DEPTH\n  integer, save :: bin(max_n) = 0\n#endif\n  real(REALKIND), parameter :: G4  = 6,         G6  = G4 * 4* 5, G8  = G6 * 6* 7, G10 = G8 * 8* 9, G12 = G10*10*11\n  real(REALKIND), parameter :: G14 = G12*12*13, G16 = G14*14*15, G18 = G16*16*17, G20 = G18*18*19, G22 = G20*20*21\n  real(REALKIND), parameter :: G24 = G22*22*23, G26 = G24*24*25, G28 = G26*26*27, G30 = G28*28*29, G32 = G30*30*31\n#ifndef PRECISION_sp\n  real(REALKIND), parameter :: G34 = G32*32*33, G36 = G34*34*35, G38 = G36*36*37, G40 = G38*38*39, G42 = G40*40*41\n  real(REALKIND), parameter :: G44 = G42*42*43, G46 = G44*44*45, G48 = G46*46*47, G50 = G48*48*49, G52 = G50*50*51\n  real(REALKIND), parameter :: G54 = G52*52*53, G56 = G54*54*55, G58 = G56*56*57, G60 = G58*58*59, G62 = G60*60*61\n#endif\n  real(REALKIND), parameter :: B2n(max_n) = [ & ! BernoulliB[2*n]/Gamma[2*n+2]\n    &                                     1._/**/REALKIND / (      6 * G4 ) & !  1\n    & ,                                  -1._/**/REALKIND / (     30 * G6 ) & !  2\n    & ,                                   1._/**/REALKIND / (     42 * G8 ) & !  3\n    & ,                                  -1._/**/REALKIND / (     30 * G10) & !  4\n    & ,                                   5._/**/REALKIND / (     66 * G12) & !  5\n    & ,                                -691._/**/REALKIND / (   2730 * G14) & !  6\n    & ,                                   7._/**/REALKIND / (      6 * G16) & !  7\n    & ,                               -3617._/**/REALKIND / (    510 * G18) & !  8\n    & ,                               43867._/**/REALKIND / (    798 * G20) & !  9\n    & ,                             -174611._/**/REALKIND / (    330 * G22) & ! 10\n    & ,                              854513._/**/REALKIND / (    138 * G24) & ! 11\n    & ,                          -236364091._/**/REALKIND / (   2730 * G26) & ! 12\n    & ,                             8553103._/**/REALKIND / (      6 * G28) & ! 13\n    & ,                        -23749461029._/**/REALKIND / (    870 * G30) & ! 14\n    & ,                       8615841276005._/**/REALKIND / (  14322 * G32) & ! 15\n#ifndef PRECISION_sp\n    & ,                      -7709321041217._/**/REALKIND / (    510 * G34) & ! 16\n    & ,                       2577687858367._/**/REALKIND / (      6 * G36) & ! 17\n    & ,               -26315271553053477373._/**/REALKIND / (1919190 * G38) & ! 18\n    & ,                    2929993913841559._/**/REALKIND / (      6 * G40) & ! 19\n    & ,              -261082718496449122051._/**/REALKIND / (  13530 * G42) & ! 20\n    & ,              1520097643918070802691._/**/REALKIND / (   1806 * G44) & ! 21\n    & ,            -27833269579301024235023._/**/REALKIND / (    690 * G46) & ! 22\n    & ,            596451111593912163277961._/**/REALKIND / (    282 * G48) & ! 23\n    & ,       -5609403368997817686249127547._/**/REALKIND / (  46410 * G50) & ! 24\n    & ,         495057205241079648212477525._/**/REALKIND / (     66 * G52) & ! 25\n    & ,     -801165718135489957347924991853._/**/REALKIND / (   1590 * G54) & ! 26\n    & ,    29149963634884862421418123812691._/**/REALKIND / (    798 * G56) & ! 27\n    & , -2479392929313226753685415739663229._/**/REALKIND / (    870 * G58) & ! 28\n    & , 84483613348880041862046775994036021._/**/REALKIND / (    354 * G60) & ! 29\n#endif\n  & ]\n\n  contains\n\n! **********************************************************************\nfunction Li2conv(z)\n! Complex dilogarithm Li2(z) calculated from a series expansion in terms of Bernoulli numbers.\n! This is supposed to be used in the complex region |z| < 1 && Re(z) < 1/2.\n! In this region the expansion (max_n = 29) is deep enough to achieve quadruple precision.\n! Required expansion depths: sp:9, dp:13, ep:15, qp:24\n! **********************************************************************\n  use KIND_TYPES, only: REALKIND\n  implicit none\n  complex(REALKIND), intent(in) :: z\n  complex(REALKIND) :: Li2conv\n  complex(REALKIND) :: Lz2, Lz2n1, Li2conv_next\n  integer           :: n\n  Lz2n1   = -log(1-z)\n  Lz2     = Lz2n1*Lz2n1\n  Li2conv = Lz2n1 - 0.25_/**/REALKIND*Lz2\n  do n = 1, max_n\n    Lz2n1 = Lz2n1 * Lz2\n    Li2conv_next = Li2conv + Lz2n1 * B2n(n)\n#ifdef COMPARE\n    if (Li2conv_next == Li2conv) exit\n#endif\n    Li2conv = Li2conv_next\n  end do\n#ifdef CHECK_DEPTH\n  bin(n) = bin(n) + 1\n#endif\nend function Li2conv\n\n\n! **********************************************************************\nfunction Li2(z)\n! Complex dilogarithm Li2(z)\n! Map z to the complex region |z| < 1 && Re(z) < 1/2 and call the series expansion.\n! **********************************************************************\n  use KIND_TYPES, only: REALKIND\n  implicit none\n  complex(REALKIND), intent(in) :: z\n  complex(REALKIND) :: Li2\n  if (real(z) <= 0.5) then\n    if (abs(z) <= 1) then\n      Li2 =   Li2conv(z)\n    else\n      Li2 = - Li2conv(1/z)     -   pi2_6                   - .5_/**/REALKIND * log( -z)**2\n    end if\n  else\n    if (abs(1-z) <= 1) then\n      Li2 = - Li2conv(1-z)     +   pi2_6 - log(z)*log(1-z)\n    else\n      Li2 =   Li2conv(1/(1-z)) + 2*pi2_6 - log(z)*log(1-z) + .5_/**/REALKIND * log(z-1)**2\n    end if\n  end if\nend function Li2\n\nend module ol_dilog_/**/REALKIND\n",
        "/tmp/vanessa/spack-stage/spack-stage-openloops-2.1.1-2pxb7uebklk56opjo3yqpykinay2r4n5/spack-src/lib_src/olcommon/src/cwrappers.c": "//!******************************************************************************!\n//! Copyright (C) 2014-2019 OpenLoops Collaboration. For authors see authors.txt !\n//!                                                                              !\n//! This file is part of OpenLoops.                                              !\n//!                                                                              !\n//! OpenLoops is free software: you can redistribute it and/or modify            !\n//! it under the terms of the GNU General Public License as published by         !\n//! the Free Software Foundation, either version 3 of the License, or            !\n//! (at your option) any later version.                                          !\n//!                                                                              !\n//! OpenLoops is distributed in the hope that it will be useful,                 !\n//! but WITHOUT ANY WARRANTY; without even the implied warranty of               !\n//! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                !\n//! GNU General Public License for more details.                                 !\n//!                                                                              !\n//! You should have received a copy of the GNU General Public License            !\n//! along with OpenLoops.  If not, see http://www.gnu.org/licenses/.             !\n//!******************************************************************************!\n\n#include <stdio.h>\n#include <string.h>\n#include <dirent.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <dlfcn.h>\n\n#include <unistd.h>\n#include <fcntl.h>\n\n/* _______________ */\n/* dirent wrappers */\n\n// modes for dlopen (direct binding to Fortran doesn't work)\nint ol_c_rtld_lazy = RTLD_LAZY;\nint ol_c_rtld_now = RTLD_NOW;\nint ol_c_rtld_global = RTLD_GLOBAL;\nint ol_c_rtld_local = RTLD_LOCAL;\n\n// global variable to hold a directory stream:\n// only one directory can be open at a time.\nDIR *ol_c_dirstream = NULL;\n\nint ol_c_opendir(const char *dirname)\n{\n  if (ol_c_dirstream != NULL)\n  {\n    // printf(\"opendir failed: a directory is already open\\n\");\n    return 127;\n  };\n  errno = 0;\n  if ((ol_c_dirstream = opendir(dirname)) == NULL)\n  {\n    // printf(\"opendir: failed opening directory %s\\n\", dirname);\n    return errno;\n  };\n  return 0;\n}\n\nint ol_c_readdir(char* entryname)\n{\n  struct dirent *direntry;\n  entryname[0] = '\\0';\n  errno = 0;\n  direntry = readdir(ol_c_dirstream);\n  if (errno != 0)\n  {\n    // printf(\"readdir: reading directory content failed\\n\");\n    return errno;\n  };\n  if (direntry != NULL)\n  {\n    strncpy(entryname, direntry->d_name, 256);\n  };\n  return 0;\n}\n\nvoid ol_c_closedir()\n{\n  closedir(ol_c_dirstream);\n  ol_c_dirstream = NULL;\n  return;\n}\n\nint ol_c_mkdir(const char *dirname)\n{\n  int err;\n  err = mkdir(dirname, ACCESSPERMS);\n  return err;\n}\n\n/* __________________ */\n/* stdout redirection */\n\nint ol_c_stdout_bak;\n\nvoid ol_c_stdout_off()\n{\n  int devnull;\n  fflush(stdout);\n  ol_c_stdout_bak = dup(1);\n  devnull = open(\"/dev/null\", O_WRONLY);\n  dup2(devnull, 1);\n  close(devnull);\n}\n\nvoid ol_c_stdout_on()\n{\n  fflush(stdout);\n  dup2(ol_c_stdout_bak, 1);\n  close(ol_c_stdout_bak);\n}\n"
    },
    "skipped": [],
    "total_files": 730
}