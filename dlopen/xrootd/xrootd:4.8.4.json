{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-xrootd-4.8.4-t4rp3o5embz66ngclf6u6noewe4srpjk/spack-src/src/XrdApps/XrdCpy.cc": "/******************************************************************************/\n/*                                                                            */\n/*                             X r d C p y . c c                              */\n/*                                                                            */\n/* (c) 2012 by the Board of Trustees of the Leland Stanford, Jr., University  */\n/*                            All Rights Reserved                             */\n/* Author: Fabrizio Furano (INFN Padova, 2004)                                */\n/*            Modified by Andrew Hanushevsky (2012) under contract            */\n/*              DE-AC02-76-SFO0515 with the Department of Energy              */\n/*                                                                            */\n/* This file is part of the XRootD software suite.                            */\n/*                                                                            */\n/* XRootD is free software: you can redistribute it and/or modify it under    */\n/* the terms of the GNU Lesser General Public License as published by the     */\n/* Free Software Foundation, either version 3 of the License, or (at your     */\n/* option) any later version.                                                 */\n/*                                                                            */\n/* XRootD is distributed in the hope that it will be useful, but WITHOUT      */\n/* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or      */\n/* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public       */\n/* License for more details.                                                  */\n/*                                                                            */\n/* You should have received a copy of the GNU Lesser General Public License   */\n/* along with XRootD in a file called COPYING.LESSER (LGPL license) and file  */\n/* COPYING (GPL license).  If not, see <http://www.gnu.org/licenses/>.        */\n/*                                                                            */\n/* The copyright holder's institutional names and contributor's names may not */\n/* be used to endorse or promote products derived from this software without  */\n/* specific prior written permission of the institution or contributor.       */\n/* Author: Fabrizio Furano (INFN Padova, 2004)                                */\n/*            Modified by Andrew Hanushevsky (2012) under contract            */\n/*              DE-AC02-76-SFO0515 with the Department of Energy              */\n/******************************************************************************/\n  \n//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// A cp-like command line tool for xrootd environments                  //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n\n#include \"XrdClient/XrdClientUrlInfo.hh\"\n#include \"XrdClient/XrdClientReadCache.hh\"\n#include \"XrdSys/XrdSysPthread.hh\"\n#include \"XrdClient/XrdClient.hh\"\n#include \"XrdClient/XrdCpMthrQueue.hh\"\n#include \"XrdClient/XrdClientConn.hh\"\n#include \"XrdClient/XrdClientDebug.hh\"\n#include \"XrdClient/XrdCpWorkLst.hh\"\n#include \"XrdClient/XrdClientEnv.hh\"\n#include \"XrdSys/XrdSysPlatform.hh\"\n\n#include \"XrdClient/XrdClientAbsMonIntf.hh\"\n#include \"XrdClient/XrdcpXtremeRead.hh\"\n\n#include \"XrdCks/XrdCks.hh\"\n#include \"XrdCks/XrdCksCalc.hh\"\n#include \"XrdCks/XrdCksData.hh\"\n\n#include \"XrdApps/XrdCpConfig.hh\"\n#include \"XrdApps/XrdCpFile.hh\"\n\n#include \"XrdOuc/XrdOucTokenizer.hh\"\n#include \"XrdOuc/XrdOucTPC.hh\"\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <sstream>\n#ifndef WIN32\n#include <sys/time.h>\n#include <unistd.h>\n#include <dlfcn.h>\n#endif\n#include <stdarg.h>\n#include <stdio.h>\n#include <sstream>\n\n#ifdef HAVE_LIBZ\n#include <zlib.h>\n#endif\n\n/******************************************************************************/\n/*                  G l o b a l   C o n f i g u r a t i o n                   */\n/******************************************************************************/\n  \nnamespace XrdCopy\n{\nXrdCpConfig  Config(\"xrdcp\");\nXrdCksData   srcCksum, dstCksum;\nXrdCksCalc  *csObj;\nXrdClient   *tpcSrc;\nchar         tpcKey[32];\nlong long    tpcFileSize;\npthread_t    tpcTID;\nint          tpcPB;\nint          isSrv;\nint          isTPC;\nint          getCks;\nint          lenCks;\nint          prtCks;\nint          setCks;\nint          verCks;\nint          xeqCks;\nint          lclCks;\nstatic const int rwMode = kXR_ur | kXR_uw | kXR_gw | kXR_gr | kXR_or;\n}\n\nusing namespace XrdCopy;\n\n#define EMSG(x) {if (isSrv) cout <<Config.Pgm <<\": \" <<x <<endl;\\\n                    else    cerr <<Config.Pgm <<\": \" <<x <<endl;}\n\nextern \"C\" {\n/////////////////////////////////////////////////////////////////////\n// function + macro to allow formatted print via cout,cerr\n/////////////////////////////////////////////////////////////////////\n void cout_print(const char *format, ...)\n {\n    char cout_buff[4096];\n    va_list args;\n    va_start(args, format);\n    vsprintf(cout_buff, format,  args);\n    va_end(args);\n    cout << cout_buff;\n }\n\n   void cerr_print(const char *format, ...)\n   {\n      char cerr_buff[4096];\n      va_list args;\n      va_start(args, format);\n      vsprintf(cerr_buff, format,  args);\n      va_end(args);\n      cerr <<cerr_buff;\n   }\n\n#define COUT(s) do {\t\t\t\t\\\n      cout_print s;\t\t\t\t\\\n   } while (0)\n\n#define CERR(s) do {\t\t\t\t\\\n      cerr_print s;\t\t\t\t\\\n   } while (0)\n\n}\n//////////////////////////////////////////////////////////////////////\n\n\nstruct XrdCpInfo {\n   XrdClient                    *XrdCli;\n   int                          localfile;\n   long long                    len, bread, bwritten;\n   XrdCpMthrQueue               queue;\n   XrdClientAbsMonIntf          *mon;\n\n   XrdCpInfo() : XrdCli(0),localfile(0),len(0),bread(0),bwritten(0),mon(0) {}\n} cpnfo;\n\n#define XRDCP_BLOCKSIZE          (8*1024*1024)\n#define XRDCP_XRDRASIZE          (30*XRDCP_BLOCKSIZE)\n#define XRDCP_VERSION            \"(C) 2004-2011 by the XRootD collaboration. Version: \" XrdVSTRING\n\n///////////////////////////////////////////////////////////////////////\n// Coming from parameters on the cmd line\n\nbool summary=false;            // print summary\nbool progbar=true;             // print progbar\nbool Verbose=true;             // be verbose\n\nXrdOucString monlibname = \"libXrdCpMonitorClient.so\"; // Default name for the ext monitoring lib\n\n// Default open flags for opening a file (xrd)\nkXR_unt16 xrd_wr_flags=kXR_async | kXR_mkpath | kXR_open_updt | kXR_new;\n\n// Flags for open() to force overwriting or not. Default is not.\n#define LOC_WR_FLAGS_FORCE ( O_CREAT | O_WRONLY | O_TRUNC | O_BINARY );\n#define LOC_WR_FLAGS       ( O_CREAT | O_WRONLY | O_EXCL | O_BINARY );\nint loc_wr_flags = LOC_WR_FLAGS;\n\nbool recurse = false;\n\nbool doXtremeCp = false;\nXrdOucString XtremeCpRdr;\n\n///////////////////////\n\n// To compute throughput etc\nstruct timeval abs_start_time;\nstruct timeval abs_stop_time;\nstruct timezone tz;\n\n/******************************************************************************/\n/*                         p r i n t _ s u m m a r y                          */\n/******************************************************************************/\n  \nvoid print_summary(const char* src, const char* dst, unsigned long long bytesread)\n{\n   gettimeofday (&abs_stop_time, &tz);\n   float abs_time=((float)((abs_stop_time.tv_sec- abs_start_time.tv_sec)*1000 +\n                           (abs_stop_time.tv_usec-abs_start_time.tv_usec)/1000));\n\n\n   XrdOucString xsrc(src);\n   XrdOucString xdst(dst);\n   xsrc.erase(xsrc.rfind('?'));\n   xdst.erase(xdst.rfind('?'));\n\n   COUT((\"[xrdcp] #################################################################\\n\"));\n   COUT((\"[xrdcp] # Source Name              : %s\\n\",xsrc.c_str()));\n   COUT((\"[xrdcp] # Destination Name         : %s\\n\",xdst.c_str()));\n   COUT((\"[xrdcp] # Data Copied [bytes]      : %lld\\n\",bytesread));\n   COUT((\"[xrdcp] # Realtime [s]             : %f\\n\",abs_time/1000.0));\n   if (abs_time > 0) {\n      COUT((\"[xrdcp] # Eff.Copy. Rate[MB/s]     : %f\\n\",bytesread/abs_time/1000.0));\n   }\n   if (xeqCks)\n      {static const int Bsz = 64;\n       char Buff[Bsz];\n       dstCksum.Get(Buff,Bsz);\n       COUT((\"[xrdcp] # %8s                 : %s\\n\", dstCksum.Name, Buff));\n      }\n   COUT((\"[xrdcp] #################################################################\\n\"));\n}\n\n/******************************************************************************/\n/*                         p r i n t _ p r o g b a r                          */\n/******************************************************************************/\n  \nvoid print_progbar(unsigned long long bytesread, unsigned long long size) {\n   CERR((\"[xrootd] Total %.02f MB\\t|\",(float)size/1024/1024));\n   for (int l=0; l< 20;l++) {\n      if (l< ( (int)(20.0*bytesread/size)))\n\t CERR((\"=\"));\n      if (l==( (int)(20.0*bytesread/size)))\n\t CERR((\">\"));\n      if (l> ( (int)(20.0*bytesread/size)))\n\t CERR((\".\"));\n   }\n  \n   float abs_time=((float)((abs_stop_time.tv_sec - abs_start_time.tv_sec) *1000 +\n\t\t\t   (abs_stop_time.tv_usec - abs_start_time.tv_usec) / 1000));\n   CERR((\"| %.02f %% [%.01f MB/s]\\r\",100.0*bytesread/size,bytesread/abs_time/1000.0));\n}\n\n/******************************************************************************/\n/*                          p r i n t _ c h k s u m                           */\n/******************************************************************************/\n  \nvoid print_chksum(const char* src, unsigned long long bytesread)\n{\n   const char *csName;\n   char Buff[64];\n   int csLen;\n   XrdOucString xsrc(src);\n   xsrc.erase(xsrc.rfind('?'));\n\n   if (lclCks && csObj)\n      {const void *csVal  = csObj->Final();\n       csName = csObj->Type(csLen);\n       srcCksum.Set(csVal, csLen);\n       srcCksum.Get(Buff, sizeof(Buff));\n      } else {\n       dstCksum.Get(Buff, sizeof(Buff));\n       csName = dstCksum.Name;\n      }\n   cout <<csName <<\": \" <<Buff <<' ' <<xsrc <<' ' <<bytesread <<endl;\n}\n\n/******************************************************************************/\n/*                             d o P r o g B a r                              */\n/******************************************************************************/\n\nvoid *doProgBar(void *Parm)\n{\n   XrdClientUrlInfo *dUrl = (XrdClientUrlInfo *)Parm;\n   XrdClientAdmin Adm(dUrl->GetUrl().c_str());\n   const char *fName = dUrl->File.c_str();\n   long long fSize;\n   long id, flags, mtime;\n\n// Prevent cancelation as the admin client can't handle that\n//\n   pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, 0);\n   pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, 0);\n\n// Open a path to the destination\n//\n   if (!Adm.Connect()) return 0;\n\n// Print the progress bar until we are canceled\n//\n   while(Adm.Stat(fName, id, fSize, flags, mtime))\n        {gettimeofday(&abs_stop_time,&tz);\n         print_progbar(fSize, tpcFileSize);\n         pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, 0);\n         pthread_testcancel();\n         sleep(3);\n         pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, 0);\n        }\n\n// All done\n//\n   return 0;\n}\n  \n/******************************************************************************/\n/*                           u n d o P r o g B a r                            */\n/******************************************************************************/\n\nvoid undoProgBar(int isOK)\n{\n   void *thret;\n\n   if (tpcPB)\n      {tpcPB = 0;\n       pthread_cancel(tpcTID);\n       pthread_join(tpcTID, &thret);\t\n       if (isOK)\n        {gettimeofday(&abs_stop_time,&tz);\n         print_progbar(tpcFileSize, tpcFileSize);\n        }\n       cerr <<endl;\n      }\n}\n\n/******************************************************************************/\n/*                               c p F a t a l                                */\n/******************************************************************************/\n  \nint cpFatal(const char *Act, XrdClient *cSrc, XrdClient *cDst, const char *hn=0)\n{\n   XrdClient *cObj;\n   const char *Msg;\n\n   if (tpcPB) undoProgBar(0);\n\n   if (cSrc) {cObj = cSrc; Msg = \"Copy from \";}\n      else   {cObj = cDst; Msg = \"Copy to \";}\n\n   if (!hn) hn = cObj->GetCurrentUrl().Host.c_str();\n\n   EMSG(Msg <<hn <<\" failed on \" <<Act <<\"!\");\n   EMSG(ServerError(cObj));\n   return -1;\n}\n  \n/******************************************************************************/\n/*                              g e t F N a m e                               */\n/******************************************************************************/\n  \nconst char *getFName(const char *Url)\n{\n   static char fBuff[2048];\n   const char *Qmark = index(Url, '?');\n\n   if (!Qmark) return Url;\n\n   int n = (Qmark - Url);\n   if (n >= (int)sizeof(fBuff)) n = sizeof(fBuff)-1;\n   strncpy(fBuff, Url, n);\n   fBuff[n] = 0;\n   return fBuff;\n}\n\n/******************************************************************************/\n/*                      R e a d e r T h r e a d _ x r d                       */\n/******************************************************************************/\n\n// The body of a thread which reads from the global\n//  XrdClient and keeps the queue filled\n//____________________________________________________________________________\nvoid *ReaderThread_xrd(void *)\n{\n\n   Info(XrdClientDebug::kHIDEBUG,\n\t\"ReaderThread_xrd\",\n\t\"Reader Thread starting.\");\n   \n   pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, 0);\n   pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, 0);\n\n\n   void *buf;\n   long long offs = 0;\n   int nr = 1;\n   long long bread = 0, len = 0;\n   long blksize;\n\n   len = cpnfo.len;\n\n   while ((nr > 0) && (offs < len)) {\n      buf = malloc(XRDCP_BLOCKSIZE);\n      if (!buf) {\n   EMSG(\"Copy failed; out of memory.\");\n   _exit(13);\n      }\n\n      \n      blksize = xrdmin(XRDCP_BLOCKSIZE, len-offs);\n\n      if ( (nr = cpnfo.XrdCli->Read(buf, offs, blksize)) ) {\n         cpnfo.queue.PutBuffer(buf, offs, nr);\n         cpnfo.XrdCli->RemoveDataFromCache(offs, offs+nr-1, false);\n\t bread += nr;\n\t offs += nr;\n      }\n\n      pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, 0);\n      pthread_testcancel();\n      pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, 0);\n   }\n\n   cpnfo.bread = bread;\n\n   // This ends the transmission... bye bye\n   cpnfo.queue.PutBuffer(0, 0, 0);\n\n   return 0;\n}\n\n/******************************************************************************/\n/*               R e a d e r T h r e a d _ x r d _ x t r e m e                */\n/******************************************************************************/\n  \n// The body of a thread which reads from the global\n//  XrdClient and keeps the queue filled\n// This is the thread for extreme reads, in this case we may have multiple of these\n// threads, reading the same file from different server endpoints\n//____________________________________________________________________________\nstruct xtreme_threadnfo {\n   XrdXtRdFile *xtrdhandler;\n\n   // The client used by this thread\n   XrdClient *cli;\n\n   // A unique integer identifying the client instance\n   int clientidx;\n\n   // The block from which to start prefetching/reading\n   int startfromblk;\n\n   // Max convenient number of outstanding blks\n   int maxoutstanding;\n}; \nvoid *ReaderThread_xrd_xtreme(void *parm)\n{\n\n   Info(XrdClientDebug::kHIDEBUG,\n\t\"ReaderThread_xrd_xtreme\",\n\t\"Reader Thread starting.\");\n   \n   pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, 0);\n   pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, 0);\n\n   void *buf;\n\n   int nr = 1;\n   int noutstanding = 0;\n\n\n   // Which block to read\n   XrdXtRdBlkInfo *blknfo = 0;\n   xtreme_threadnfo *thrnfo = (xtreme_threadnfo *)parm;\n\n   // Block to prefetch\n   int lastprefetched = thrnfo->startfromblk;\n   int lastread = lastprefetched;\n\n   thrnfo->cli->Open(0, 0, true);\n\n   thrnfo->cli->SetCacheParameters(XRDCP_BLOCKSIZE*4*thrnfo->maxoutstanding*2, 0, XrdClientReadCache::kRmBlk_FIFO);\n   if (thrnfo->cli->IsOpen_wait())\n   while (nr > 0) {\n\n      // Keep always some blocks outstanding from the point of view of this reader\n      while (noutstanding < thrnfo->maxoutstanding) {\n         int lp;\n         lp = thrnfo->xtrdhandler->GetBlkToPrefetch(lastprefetched, thrnfo->clientidx, blknfo);\n         if (lp >= 0) {\n            //cout << \"cli: \" << thrnfo->clientidx << \" prefetch: \" << lp << \" offs: \" << blknfo->offs << \" len: \" << blknfo->len << endl;\n            if ( thrnfo->cli->Read_Async(blknfo->offs, blknfo->len) == kOK ) {  \n               lastprefetched = lp;\n               noutstanding++;\n            }\n            else break;\n         }\n         else break;\n      }\n\n      int lr = thrnfo->xtrdhandler->GetBlkToRead(lastread, thrnfo->clientidx, blknfo);\n      if (lr >= 0) {\n\n         buf = malloc(blknfo->len);\n         if (!buf) {\n            EMSG(\"Copy failed; out of memory.\");\n            _exit(13);\n         }\n\n         //cout << \"cli: \" << thrnfo->clientidx << \"     read: \" << lr << \" offs: \" << blknfo->offs << \" len: \" << blknfo->len << endl;\n\n         // It is very important that the search for a blk to read starts from the first block upwards\n         nr = thrnfo->cli->Read(buf, blknfo->offs, blknfo->len);\n         if ( nr >= 0 ) {\n            lastread = lr;\n            noutstanding--;\n\n            // If this block was stolen by somebody else then this client has to be penalized\n            // If this client stole the blk to some other client, then this client has to be rewarded\n            int reward = thrnfo->xtrdhandler->MarkBlkAsRead(lr);\n            if (reward >= 0) \n               // Enqueue the block only if it was not already read\n               cpnfo.queue.PutBuffer(buf, blknfo->offs, nr);\n\n            if (reward > 0) {\n               thrnfo->maxoutstanding++;\n               thrnfo->maxoutstanding = xrdmin(20, thrnfo->maxoutstanding);\n               thrnfo->cli->SetCacheParameters(XRDCP_BLOCKSIZE*4*thrnfo->maxoutstanding*2, 0, XrdClientReadCache::kRmBlk_FIFO);\n            }\n            if (reward < 0) {\n               thrnfo->maxoutstanding--;\n               free(buf);\n            }\n\n            if (thrnfo->maxoutstanding <= 0) {\n               sleep(1);\n               thrnfo->maxoutstanding = 1;\n            }\n\n         }\n\n         // It is very important that the search for a blk to read starts from the first block upwards\n         thrnfo->cli->RemoveDataFromCache(blknfo->offs, blknfo->offs+blknfo->len-1, false);\n      }\n      else {\n\n         if (thrnfo->xtrdhandler->AllDone()) break;\n         pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, 0);\n         sleep(1);\n      }\n\n\n      pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, 0);\n      pthread_testcancel();\n      pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, 0);\n   }\n\n   // We get here if there are no more blocks to read or to steal from other readers\n   // This ends the transmission... bye bye\n   cpnfo.queue.PutBuffer(0, 0, 0);\n\n   return 0;\n}\n\n/******************************************************************************/\n/*                      R e a d e r T h r e a d _ l o c                       */\n/******************************************************************************/\n\n// The body of a thread which reads from the global filehandle\n//  and keeps the queue filled\n//____________________________________________________________________________\nvoid *ReaderThread_loc(void *) {\n\n   Info(XrdClientDebug::kHIDEBUG,\n\t\"ReaderThread_loc\",\n\t\"Reader Thread starting.\");\n\n   pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, 0);\n   pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, 0);\n\n   void *buf;\n   long long offs = 0;\n   int nr = 1;\n   long long bread = 0;\n\n   while (nr > 0) {\n      buf = malloc(XRDCP_BLOCKSIZE);\n      if (!buf) {\n         EMSG(\"Copy failed; out of memory.\");\n         _exit(13);\n      }\n\n      //------------------------------------------------------------------------\n      // If this read fails it means that either the program logic is\n      // flawed, or there was a low level hardware failure. In either case\n      // continuing may cause more harm than good.\n      //------------------------------------------------------------------------\n      nr = read( cpnfo.localfile, buf, XRDCP_BLOCKSIZE );\n      if( nr < 0 )\n      {\n        EMSG(strerror( errno ) <<\" reading local file.\");\n        _exit(17);\n      }\n      if( nr > 0)\n      {\n        cpnfo.queue.PutBuffer(buf, offs, nr);\n        bread += nr;\n        offs += nr;\n      }\n   }\n\n   cpnfo.bread = bread;\n\n   // This ends the transmission... bye bye\n   cpnfo.queue.PutBuffer(0, 0, 0);\n\n   return 0;\n}\n\n/******************************************************************************/\n/*                    C r e a t e D e s t P a t h _ l o c                     */\n/******************************************************************************/\n\nint CreateDestPath_loc(XrdOucString path, bool isdir) {\n   // We need the path name without the file\n   if (!isdir) {\n      int pos = path.rfind('/');\n\n      if (pos != STR_NPOS)\n\t path.erase(pos);\n      else path = \"\";\n\n\n   }\n\n   if (path != \"\")\n      return ( MAKEDIR(\n\t\t     path.c_str(),\n\t\t     S_IRUSR | S_IWUSR | S_IXUSR |\n\t\t     S_IRGRP | S_IWGRP | S_IXGRP |\n\t\t     S_IROTH | S_IXOTH)\n\t       );\n   else\n      return 0;\n\n}\n\n/******************************************************************************/\n/*                              g e t C k s u m                               */\n/******************************************************************************/\n  \nint getCksum(XrdCksData &cksData, const char *Path)\n{\n   const char *Lfn;\n   char *csResp, *tP;\n\n// Point to absolute path\n//                    0123456\n   if (!strcmp(Path, \"root://\")) Lfn = Path + 7;\n      else Lfn = Path + 8;\n   if ((Lfn = index(Lfn, '/'))) Lfn++;\n      else Lfn = Path;\n\n// Get the checksum from the server\n//\n   XrdClientAdmin Adm(Path);\n   if (!(Adm.Connect()) || !(Adm.GetChecksum((kXR_char *)Lfn,(kXR_char **)&csResp)))\n      {EMSG(\"Unable to obtain checksum for '\"<< getFName(Path) <<\"'.\");\n       EMSG(Adm.LastServerError()->errmsg);\n       return 0;\n      }\n\n// Get checksum name and make sure it matches\n//\n   XrdOucTokenizer csData(csResp);\n   csData.GetLine();\n   if ((tP = csData.GetToken()) && strcmp(tP, Config.CksData.Name))\n      {EMSG(\"Only \" <<tP <<\" checksums supported by \"\n            <<Adm.GetCurrentUrl().Host.c_str());\n       free(csResp);\n       return 0;\n      }\n\n// Get the token value\n//\n   if (tP && (tP = csData.GetToken()) && !cksData.Set(tP, strlen(tP))) tP = 0;\n\n// Check that all went well\n//\n   if (!tP) EMSG(\"Invalid checksum returned for '\" <<getFName(Path) <<\"'.\");\n\n// Return result\n//\n   free(csResp);\n   return (tP ? 1 : 0);\n}\n\n/******************************************************************************/\n/*                                v a l T P C                                 */\n/******************************************************************************/\n  \nint valTPC(XrdClient *cObj, int isDest)\n{\n   kXR_char qArg[4];\n   kXR_char respBuff[128];\n\n// Ask the sever if it supports tpc\n//\n   strcpy((char *)qArg, \"tpc\");\n   if (cObj->Query(kXR_Qconfig, qArg, respBuff, sizeof(respBuff))\n   &&  isdigit(*respBuff) && atoi((const char *)respBuff) > 0) return 1;\n\n// Nope, we don't support this\n//\n   EMSG(\"Host \" <<cObj->GetCurrentUrl().Host.c_str()\n        <<\" does not support third party copies.\");\n\n// If we are the destination, unlink any partially created file\n//\n   if (isDest)\n      {XrdClientAdmin Adm(cObj->GetCurrentUrl().GetUrl().c_str());\n       if (Adm.Connect()) Adm.Rm(cObj->GetCurrentUrl().File.c_str());\n       // cerr <<cObj->GetCurrentUrl().GetUrl().c_str() <<endl;\n       // cerr <<cObj->GetCurrentUrl().File.c_str() <<endl;\n      }\n\n   return 0;\n}\n\n/******************************************************************************/\n/*                            g e n D e s t C g i                             */\n/******************************************************************************/\n  \nchar *genDestCgi(XrdClient *xrdsrc, const char *src)\n{\n   union {long long intP;\n          int  intV[2];\n         } iKey;\n   XrdClientStatInfo stat;\n   XrdOucString dCGI;\n   int myKey[3];\n   const char *Path, *cksVal, *cgiP;\n   char *qP, aszBuff[128], lfnBuff[1032], cgiBuff[2048];\n\n// Make sure that the source supports 3rd party copy\n//\n   if (!valTPC(xrdsrc, 0)) return 0;\n\n// Extract out the source lfn\n//\n   Path = src + (*src == 'x' ? 8 : 7);\n   if (!(Path = index(Path, '/')))\n      {EMSG(\"Unable to extract lfn from '\" <<getFName(src) <<\"'.\"); return 0;}\n   strncpy(lfnBuff, Path+1, sizeof(lfnBuff)-1);\n   lfnBuff[sizeof(lfnBuff)-1] = 0;\n   if ((qP = index(lfnBuff, '?'))) *qP = 0;\n\n// Generate a key\n//\n   gettimeofday(&abs_start_time,&tz);\n   myKey[0] = abs_start_time.tv_usec;\n   myKey[1] = getpid() | (getppid() << 16);\n   iKey.intP = (long long) &myKey[0];\n   myKey[2] = iKey.intV[0] ^ iKey.intV[1];\n   sprintf(tpcKey, \"%08x%08x%08x\", myKey[0], myKey[1], myKey[2]);\n\n// Check if we should add checksum information\n//\n   cksVal = (verCks ? Config.CksVal : 0);\n\n// Generate the cgi for the destination\n//\n   std::ostringstream o; o << xrdsrc->GetCurrentUrl().Host.c_str() << \":\";\n   o << xrdsrc->GetCurrentUrl().Port;\n   cgiP = XrdOucTPC::cgiC2Dst(tpcKey, o.str().c_str(),\n                              lfnBuff, cksVal, cgiBuff, sizeof(cgiBuff));\n   if (*cgiP == '!')\n      {EMSG(\"Unable to setup destination url. \" <<cgiP+1); return 0;}\n\n// Start the url with the size hint\n//\n   xrdsrc->Stat(&stat);\n   tpcFileSize = static_cast<long long>(stat.size);\n   sprintf(aszBuff, \"?oss.asize=%lld&\", tpcFileSize);\n   dCGI = aszBuff;\n\n// Add all other information\n//\n   if (Config.dstOpq) {dCGI += Config.dstOpq; dCGI += '&';}\n   dCGI += cgiBuff;\n// cerr <<\"Dest url: \" <<dCGI.c_str() <<endl;\n\n// All done\n//\n   return strdup(dCGI.c_str());\n}\n\n/******************************************************************************/\n/*                          d o C p _ x r d 3 x r d                           */\n/******************************************************************************/\n  \nint doCp_xrd3xrd(XrdClient *xrddest, const char *src, const char *dst)\n{\n   struct sdHelper\n         {XrdClient *Src;\n                     sdHelper() : Src(0) {}\n                    ~sdHelper() {if (Src) delete Src;}\n         } Client;\n   XrdClientUrlInfo dUrl;\n   XrdOucString sUrl(tpcSrc->GetCurrentUrl().GetUrl().c_str());\n   XrdOucString *rCGI, dstUrl;\n   int xTTL = -1;\n   const char *cgiP;\n   char cgiBuff[1024];\n\n// Append any redirection cgi information to our source spec\n//\n   rCGI = &(tpcSrc->GetClientConn()->fRedirCGI);\n   if (rCGI->length() > 0)\n      {if (sUrl.find(\"?\") == STR_NPOS) sUrl += '?';\n          else sUrl += '&';\n       sUrl += *rCGI;\n      }\n\n//cerr <<\"tpc: bfr src=\" <<src <<endl;\n//cerr <<\"tpc: bfr dst=\" <<dst <<endl;\n//cerr <<\"tpc: bfr scl=\" <<tpcSrc->GetCurrentUrl().GetUrl().c_str() <<endl;\n//cerr <<\"tpc: bfr dcl=\" <<xrddest->GetCurrentUrl().GetUrl().c_str() <<endl;\n\n// Verify that the destination supports 3rd party stuff\n//\n   if (!valTPC(xrddest, 1)) return 8;\n\n// Generate source cgi string\n//\n   cgiP = XrdOucTPC::cgiC2Src(tpcKey, xrddest->GetCurrentUrl().Host.c_str(),\n                              xTTL, cgiBuff, sizeof(cgiBuff));\n   if (*cgiP == '!')\n      {EMSG(\"Unable to setup source url. \" <<cgiP+1); return 8;}\n\n// Add the cgi string to the source\n//\n   if (sUrl.find(\"?\") == STR_NPOS) sUrl += '?';\n      else sUrl += '&';\n   sUrl += cgiBuff;\n//cerr <<\"tpc: aft scl=\" <<sUrl.c_str()<<endl;\n//cerr <<\"tpc: aft dcl=\" <<xrddest->GetCurrentUrl().GetUrl().c_str() <<endl;\n\n// Open the source\n//\n   Client.Src = new XrdClient(sUrl.c_str());\n   const char *hName = Client.Src->GetCurrentUrl().Host.c_str();\n   if ((!Client.Src->Open(0, kXR_async) ||\n      (Client.Src->LastServerResp()->status != kXR_ok)))\n      return cpFatal(\"open\", Client.Src, 0, hName);\n   \n// Start the progress bar if so wanted\n//\n   tpcPB = !Config.Want(XrdCpConfig::DoNoPbar);\n   if (tpcPB)\n//    {dUrl = xrddest->GetCurrentUrl();\n//cerr <<\"tpc: pbr dcl=\" <<dst<<endl;\n      {dstUrl = dst; dUrl = dstUrl;\n       tpcPB = !XrdSysThread::Run(&tpcTID, doProgBar, (void *)&dUrl,\n                                  XRDSYSTHREAD_HOLD);\n      }\n\n// Now do a sync operation on the destination\n//\n   if (!xrddest->Sync()) return cpFatal(\"rendezvous\", 0, xrddest);\n\n// One more sync will start the copy\n//\n   gettimeofday(&abs_start_time,&tz);\n   if (!xrddest->Sync()) return cpFatal(\"sync\", 0, xrddest);\n\n// Stop the progress bar\n//\n   if (tpcPB) undoProgBar(1);\n\n// Close the file\n//\n   if(!xrddest->Close()) return cpFatal(\"close\", 0, xrddest);\n\n// Do checksum processing\n//\n   if (xeqCks && prtCks)\n      {if (!getCksum(dstCksum, dst)) {EMSG(\"Unable to print checksum!\")}\n          else print_chksum(src, tpcFileSize);\n       if (summary) print_summary(src, dst, tpcFileSize);\n      }\n\n// All done\n//\n   return 0;\n}\n\n/******************************************************************************/\n/*                          d o C p _ x r d 2 x r d                           */\n/******************************************************************************/\n  \nint doCp_xrd2xrd(XrdClient **xrddest, const char *src, const char *dst) {\n   // ----------- xrd to xrd affair\n   pthread_t myTID;\n   XrdClientVector<pthread_t> myTIDVec;\n\n   void *thret;\n   XrdClientStatInfo stat;\n   int retvalue = 0;\n\n// If we need to verify checksums then we will need to get the checksum\n// from the source unless a specific checksum has been specified.\n//\n   if (lclCks) csObj = Config.CksObj;\n      else if (verCks && getCks && !getCksum(srcCksum, src)) return -ENOTSUP;\n\n   gettimeofday(&abs_start_time,&tz);\n\n   // Open the input file (xrdc)\n   // If Xrdcli is non-null, the correct src file has already been opened\n   if (!cpnfo.XrdCli)\n      {cpnfo.XrdCli = new XrdClient(src);\n       const char *hName = cpnfo.XrdCli->GetCurrentUrl().Host.c_str();\n       if ( ( !cpnfo.XrdCli->Open(0, kXR_async) ||\n          (cpnfo.XrdCli->LastServerResp()->status != kXR_ok) ) )\n          {cpFatal(\"open\", cpnfo.XrdCli, 0, hName);\n           delete cpnfo.XrdCli;\n           cpnfo.XrdCli = 0;\n           return 1;\n          }\n      }\n   \n   cpnfo.XrdCli->Stat(&stat);\n   cpnfo.len = stat.size;\n   \n   XrdOucString dest = AddSizeHint( dst, stat.size );\n\n   // if xrddest if nonzero, then the file is already opened for writing\n   if (!*xrddest) {\n      *xrddest = new XrdClient(dest.c_str());\n       const char *hName = (*xrddest)->GetCurrentUrl().Host.c_str();\n      \n      if (!PedanticOpen4Write(*xrddest, rwMode, xrd_wr_flags))\n         {cpFatal(\"open\", 0, *xrddest, hName);\n          delete cpnfo.XrdCli;\n          delete *xrddest;\n          *xrddest = 0;\n          cpnfo.XrdCli = 0;\n          return -1;\n         }\n      \n   }\n   \n   // If the Extreme Copy flag is set, we try to find more sources for this file\n   // Each source gets assigned to a different reader thread\n   XrdClientVector<XrdClient *> xtremeclients;\n   XrdXtRdFile *xrdxtrdfile = 0;\n   \n   if (doXtremeCp) \n      XrdXtRdFile::GetListOfSources(cpnfo.XrdCli, XtremeCpRdr,\n                                    xtremeclients, Config.nSrcs);\n   \n   // Start reader on xrdc\n   if (doXtremeCp && (xtremeclients.GetSize() > 1)) {\n      \n      // Beware... with the extreme copy the normal read ahead mechanism\n      // makes no sense at all.\n      //EnvPutInt(NAME_REMUSEDCACHEBLKS, 1);\n      xrdxtrdfile = new XrdXtRdFile(XRDCP_BLOCKSIZE*4, cpnfo.len);\n      \n      for (int iii = 0; iii < xtremeclients.GetSize(); iii++) {\n         xtreme_threadnfo *nfo = new(xtreme_threadnfo);\n         nfo->xtrdhandler = xrdxtrdfile;\n         nfo->cli = xtremeclients[iii];\n         nfo->clientidx = xrdxtrdfile->GimmeANewClientIdx();\n         nfo->startfromblk = iii*xrdxtrdfile->GetNBlks() / xtremeclients.GetSize();\n         nfo->maxoutstanding = xrdmin( 5, xrdxtrdfile->GetNBlks() / xtremeclients.GetSize() );\n         if (nfo->maxoutstanding < 1) nfo->maxoutstanding = 1;\n\n         XrdSysThread::Run(&myTID, ReaderThread_xrd_xtreme, \n                           (void *)nfo, XRDSYSTHREAD_HOLD);\n         myTIDVec.Push_back(myTID);\n      }\n      \n   }\n   else {\n      XrdSysThread::Run(&myTID,ReaderThread_xrd,(void *)&cpnfo,XRDSYSTHREAD_HOLD);\n      myTIDVec.Push_back(myTID);\n   }\n   \n   int len = 1;\n   void *buf;\n   long long offs = 0;\n   long long bytesread=0;\n   long long size = cpnfo.len;\n   bool draining = false;\n   \n   // Loop to write until ended or timeout err\n   while (1) {\n      \n      if (xrdxtrdfile && xrdxtrdfile->AllDone()) draining = true;\n      if (draining && !cpnfo.queue.GetLength()) break;\n\n      if ( cpnfo.queue.GetBuffer(&buf, offs, len) ) {\n\n         if (len && buf) {\n\n            bytesread+=len;\n            if (progbar) {\n               gettimeofday(&abs_stop_time,&tz);\n               print_progbar(bytesread,size);\n            }\n\n            if (csObj) csObj->Update((const char *)buf,len);\n\n            if (!(*xrddest)->Write(buf, offs, len)) {\n               cpFatal(\"write\", 0, *xrddest);\n               retvalue = 11;\n               break;\n            }\n\n            if (cpnfo.mon)\n               cpnfo.mon->PutProgressInfo(bytesread, cpnfo.len, (float)bytesread / cpnfo.len * 100.0);\n\n            free(buf);\n\n         }\n         else\n            if (!xrdxtrdfile && ( ((buf == 0) && (len == 0)) || (bytesread >= size))) {\n               if (buf) free(buf);\n               break;\n            }\n\n      }\n      else {\n         EMSG(\"Critical read timeout. Unable to read data from the source.\");\n         retvalue = 17;\n         break;\n      }\n\n      buf = 0;\n   }\n\n   if (cpnfo.mon)\n      cpnfo.mon->PutProgressInfo(bytesread, cpnfo.len, (float)bytesread / cpnfo.len * 100.0, 1);\n\n   if(progbar) {\n      cout << endl;\n   }\n\n   if (cpnfo.len != bytesread) {\n      EMSG(\"File length mismatch. Read:\" << bytesread << \" Length:\" << cpnfo.len);\n      retvalue = 13;\n   }\n      \n      for (int i = 0; i < myTIDVec.GetSize(); i++) {\n         pthread_cancel(myTIDVec[i]);\n         pthread_join(myTIDVec[i], &thret);\t \n      }\n\n      delete cpnfo.XrdCli;\n      cpnfo.XrdCli = 0;\n\n   if(!(*xrddest)->Close()) return cpFatal(\"close\", 0, *xrddest);\n\n   delete *xrddest;\n   *xrddest = 0;\n\n   if (!retvalue && xeqCks)\n      {if (!getCksum(dstCksum, dst)) retvalue = -ENOTSUP;\n          else if (verCks && srcCksum != dstCksum)\n                  {EMSG(getFName(dst) <<' ' <<srcCksum.Name <<\" is incorrect!\");\n                   retvalue = -1;\n                  }\n      }\n   if (!retvalue)\n      {if (prtCks) print_chksum(src, bytesread);\n       if (summary) print_summary(src, dst, bytesread);\n      }\n   return retvalue;\n}\n\n/******************************************************************************/\n/*                          d o C p _ x r d 2 l o c                           */\n/******************************************************************************/\n\nint doCp_xrd2loc(const char *src, const char *dst) {\n   // ----------- xrd to loc affair\n   pthread_t myTID;\n   XrdClientVector<pthread_t> myTIDVec;\n\n   void *thret;\n   XrdClientStatInfo stat;\n   int f;\n   int retvalue = 0;\n\n// If we need to verify checksums then we will need to get the checksum\n// from the source unless a specific checksum has been specified.\n//\n   if (xeqCks && getCks && !getCksum(srcCksum, src)) return -ENOTSUP;\n\n   gettimeofday(&abs_start_time,&tz);\n\n   // Open the input file (xrdc)\n   // If Xrdcli is non-null, the correct src file has already been opened\n   if (!cpnfo.XrdCli)\n      {cpnfo.XrdCli = new XrdClient(src);\n       const char *hName = cpnfo.XrdCli->GetCurrentUrl().Host.c_str();\n       if ( ( !cpnfo.XrdCli->Open(0, kXR_async) ||\n          (cpnfo.XrdCli->LastServerResp()->status != kXR_ok) ) )\n          {cpFatal(\"open\", cpnfo.XrdCli, 0, hName);\n           delete cpnfo.XrdCli;\n           cpnfo.XrdCli = 0;\n           return 1;\n          }\n      }\n\n   // Open the output file (loc)\n   cpnfo.XrdCli->Stat(&stat);\n   cpnfo.len = stat.size;\n\n   if (strcmp(dst, \"-\"))\n      // Copy to local fs\n      //unlink(dst);\n     {f = open(getFName(dst), loc_wr_flags,\n          S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH);\n      if (f < 0)\n         {EMSG(strerror(errno) <<\" creating '\" <<getFName(dst) <<\"'.\");\n          cpnfo.XrdCli->Close();\n          delete cpnfo.XrdCli;\n          cpnfo.XrdCli = 0;\n          return -1;\n         }\n      if (verCks || lclCks) csObj = Config.CksObj;\n     } else {\n      f = STDOUT_FILENO;  // Copy to stdout\n     }\n\n   // If the Extreme Copy flag is set, we try to find more sources for this file\n   // Each source gets assigned to a different reader thread\n   XrdClientVector<XrdClient *> xtremeclients;\n   XrdXtRdFile *xrdxtrdfile = 0;\n\n   if (doXtremeCp) \n      XrdXtRdFile::GetListOfSources(cpnfo.XrdCli, XtremeCpRdr,\n                                    xtremeclients, Config.nSrcs);\n\n   // Start reader on xrdc\n   if (doXtremeCp && (xtremeclients.GetSize() > 1)) {\n\n      // Beware... with the extreme copy the normal read ahead mechanism\n      // makes no sense at all.\n\n      xrdxtrdfile = new XrdXtRdFile(XRDCP_BLOCKSIZE*4, cpnfo.len);\n\n      for (int iii = 0; iii < xtremeclients.GetSize(); iii++) {\n         xtreme_threadnfo *nfo = new(xtreme_threadnfo);\n         nfo->xtrdhandler = xrdxtrdfile;\n         nfo->cli = xtremeclients[iii];\n         nfo->clientidx = xrdxtrdfile->GimmeANewClientIdx();\n         nfo->startfromblk = iii*xrdxtrdfile->GetNBlks() / xtremeclients.GetSize();\n         nfo->maxoutstanding = xrdmax(xrdmin( 3, xrdxtrdfile->GetNBlks() / xtremeclients.GetSize() ), 1);\n\n         XrdSysThread::Run(&myTID, ReaderThread_xrd_xtreme, \n                           (void *)nfo, XRDSYSTHREAD_HOLD);\n         myTIDVec.Push_back(myTID);\n      }\n\n   }\n   else {\n      doXtremeCp = false;\n      XrdSysThread::Run(&myTID,ReaderThread_xrd,(void *)&cpnfo,XRDSYSTHREAD_HOLD);\n      myTIDVec.Push_back(myTID);\n   }\n\n   int len = 1;\n   void *buf;\n   long long bytesread=0, offs = 0;\n   long long size = cpnfo.len;\n   bool draining = false;\n\n   // Loop to write until ended or timeout err\n   while (1) {\n\n      if (xrdxtrdfile && xrdxtrdfile->AllDone()) draining = true;\n      if (draining && !cpnfo.queue.GetLength()) break;\n\n      if ( cpnfo.queue.GetBuffer(&buf, offs, len) ) {\n\n\t if (len && buf) {\n\n\t    bytesread+=len;\n\t    if (progbar) {\n\t       gettimeofday(&abs_stop_time,&tz);\n\t       print_progbar(bytesread,size);\n\t    }\n\n     if (csObj) csObj->Update((const char *)buf,len);\n\n\t    if (doXtremeCp && (f != STDOUT_FILENO) && lseek(f, offs, SEEK_SET) < 0) {\n\t       EMSG(strerror(errno) <<\" while seeking in '\" << getFName(dst) <<\"'.\");\n\t       retvalue = 10;\n\t       break;\n\t    }\n\t    if (write(f, buf, len) <= 0) {\n\t       EMSG(strerror(errno) <<\" writing to '\" << getFName(dst) <<\"'.\");\n\t       retvalue = 10;\n\t       break;\n\t    }\n\n\t    if (cpnfo.mon)\n\t      cpnfo.mon->PutProgressInfo(bytesread, cpnfo.len, (float)bytesread / cpnfo.len * 100.0);\n\n\t    free(buf);\n\n\t }\n         else\n            if (!xrdxtrdfile && ( ((buf == 0) && (len == 0)) || (bytesread >= size)) ) {\n               if (buf) free(buf);\n               break;\n            }\n\n\n      }\n      else {\n\t EMSG(\"Critical read timeout. Unable to read data from the source.\");\n\t retvalue = 17;\n\t break;\n      }\n\t \n      buf = 0;\n\n   }\n\n   if (cpnfo.mon)\n     cpnfo.mon->PutProgressInfo(bytesread, cpnfo.len, (float)bytesread / cpnfo.len * 100.0, 1);\n\n   if(progbar) {\n      cout << endl;\n   }\n\n   if (cpnfo.len != bytesread)\n      {cpFatal(\"read\", cpnfo.XrdCli, 0);\n       retvalue = 13;\n      }\n\n   if (close(f))\n      {EMSG(strerror(errno) <<\" closing '\" <<getFName(dst) <<\"'.\");\n       retvalue = -1;\n      }\n\n      for (int i = 0; i < myTIDVec.GetSize(); i++) {\n         pthread_cancel(myTIDVec[i]);\n         pthread_join(myTIDVec[i], &thret);\t \n      }\n      delete cpnfo.XrdCli;\n      cpnfo.XrdCli = 0;\n\n   if (!retvalue && xeqCks)\n      {if (!csObj) retvalue = Config.CksMan->Calc(dst, dstCksum, setCks);\n          else {char *csVal = csObj->Final();\n                if (!dstCksum.Set((const void *)csVal, Config.CksLen))\n                   retvalue = -EINVAL;\n               }\n       if (retvalue)\n          {retvalue = (retvalue < 0 ? -retvalue : retvalue);\n           EMSG(strerror(retvalue) <<\" calculating \"\n                <<dstCksum.Name << \" checksum for \" << getFName(dst));\n          } else if (verCks && srcCksum != dstCksum)\n                    {EMSG(getFName(dst) <<' ' <<srcCksum.Name\n                          <<\" checksum is incorrect!\");\n                     retvalue = -1;\n                    }\n      }\n\n   if (!retvalue)\n      {if (prtCks)  print_chksum(src, bytesread);\n       if (summary) print_summary(src, dst, bytesread);\n      }\n\n   return retvalue;\n}\n\n/******************************************************************************/\n/*                          d o C p _ l o c 2 x r d                           */\n/******************************************************************************/\n\nint doCp_loc2xrd(XrdClient **xrddest, const char *src, const char * dst) {\n// ----------- loc to xrd affair\n   pthread_t myTID;\n   void * thret;\n   int retvalue = 0;\n   struct stat stat;\n\n   gettimeofday(&abs_start_time,&tz);\n\n   // Open the input file (loc)\n   cpnfo.localfile = open(src, O_RDONLY | O_BINARY);   \n   if (cpnfo.localfile < 0)\n      {EMSG(strerror(errno) << \" opening '\" << getFName(src) <<\"'.\");\n       cpnfo.localfile = 0;\n       return -1;\n      }\n\n   if (fstat(cpnfo.localfile, &stat))\n      {EMSG(strerror(errno) << \" stating '\" << getFName(src) <<\"'.\");\n       cpnfo.localfile = 0;\n       return -1;\n      }\n\n   XrdOucString dest = AddSizeHint( dst, stat.st_size );\n\n   // if xrddest if nonzero, then the file is already opened for writing\n   if (!*xrddest)\n      {*xrddest = new XrdClient(dest.c_str());\n       const char *hName = (*xrddest)->GetCurrentUrl().Host.c_str();\n       if (!PedanticOpen4Write(*xrddest, rwMode, xrd_wr_flags) )\n          {cpFatal(\"open\", 0 , *xrddest, hName);\n           close(cpnfo.localfile);\n           delete *xrddest;\n           *xrddest = 0;\n           cpnfo.localfile = 0;\n           return -1;\n          }\n      }\n      \n   // Start reader on loc\n   XrdSysThread::Run(&myTID,ReaderThread_loc,(void *)&cpnfo,XRDSYSTHREAD_HOLD);\n\n   int len = 1;\n   void *buf;\n   long long offs = 0;\n   unsigned long long bytesread=0;\n   unsigned long long size = stat.st_size;\n   int blkcnt = 0;\n\n// If we need to verify checksums then we will need to get the checksum\n// from the source unless a specific checksum has been specified.\n//\n   if ((xeqCks && verCks && getCks) || lclCks) csObj = Config.CksObj;\n\n   // Loop to write until ended or timeout err\n   while(len > 0)\n        {if ( cpnfo.queue.GetBuffer(&buf, offs, len) )\n            {if (len && buf)\n                {bytesread+=len;\n                 if (progbar)\n                    {gettimeofday(&abs_stop_time,&tz);\n                     print_progbar(bytesread,size);\n                    }\n                 if (csObj) csObj->Update((const char *)buf,len);\n                 if ( !(*xrddest)->Write(buf, offs, len) )\n                    {cpFatal(\"write\", 0 , *xrddest);\n                     retvalue = 12;\n                     break;\n                    }\n                 if (cpnfo.mon)\n                    cpnfo.mon->PutProgressInfo(bytesread, cpnfo.len, (float)bytesread / cpnfo.len * 100.0);\n                 free(buf);\n                } else {\n                 // If we get len == 0 then we have to stop\n                 if (buf) free(buf);\n                 break;\n                }\n            } else {\n             EMSG(\"Critical read timeout. Unable to read data from the source.\");\n             retvalue = 17;\n             break;\n            }\n         buf = 0; blkcnt++;\n        }\n\n   if (cpnfo.mon)\n     cpnfo.mon->PutProgressInfo(bytesread, cpnfo.len, (float)bytesread / cpnfo.len * 100.0, 1);\n\n   if(progbar) cout << endl;\n\n   if (size != bytesread) retvalue = 13;\n\n   pthread_cancel(myTID);\n   pthread_join(myTID, &thret);\n\n   if(!(*xrddest)->Close()) return cpFatal(\"close\", 0, *xrddest);\n\n   delete *xrddest;\n   *xrddest = 0;\n\n   close(cpnfo.localfile);\n   cpnfo.localfile = 0;\n\n   if (!retvalue && xeqCks)\n      {if (!getCksum(dstCksum, dst)) retvalue = -ENOTSUP;\n       if (csObj)\n          {char *csVal = csObj->Final();\n           if (!srcCksum.Set((const void *)csVal, Config.CksLen))\n              retvalue = -EINVAL;\n          }\n       if (retvalue)\n          {retvalue = (retvalue < 0 ? -retvalue : retvalue);\n           EMSG(strerror(retvalue) <<\" calculating \"\n                <<dstCksum.Name << \" checksum for \" <<getFName(dst));\n          } else if (verCks && srcCksum != dstCksum)\n                    {EMSG(getFName(dst) <<' ' <<srcCksum.Name\n                          <<\" checksum is incorrect!\");\n                     retvalue = -1;\n                    }\n      }\n\n   if (!retvalue)\n      {if (prtCks)  print_chksum(src, bytesread);\n       if (summary) print_summary(src, dst, bytesread);\n      }\n\n   return retvalue;\n}\n\n/******************************************************************************/\n/*                                  d o C p                                   */\n/******************************************************************************/\n  \nint doCp(XrdOucString &src, XrdOucString &dest, XrdClient *xrddest)\n{\n   int rmtSrc = (src.beginswith(\"root://\"))  || (src.beginswith(\"xroot://\"));\n   int rmtDst = (dest.beginswith(\"root://\")) || (dest.beginswith(\"xroot://\"));\n\n// Provide some debugging\n//\n   Info(XrdClientDebug::kUSERDEBUG, \"main\", src << \" --> \" << dest);\n      \n// Preprocess cksum calculation desires\n//\n   if (xeqCks)\n      {srcCksum = Config.CksData;\n       dstCksum = Config.CksData;\n       if (Config.CksObj) Config.CksObj->Init();\n      }\n   csObj = 0;\n\n// Handle when source is xrootd\n//\n   if (rmtSrc)\n      {if (Config.srcOpq) {src += \"?\"; src += Config.srcOpq;}\n       if (rmtDst)\n          {XrdOucString d = dest;\n           if (Config.dstOpq) {d += \"?\"; d += Config.dstOpq;}\n           if (isTPC) return doCp_xrd3xrd( xrddest, src.c_str(), d.c_str());\n              else    return doCp_xrd2xrd(&xrddest, src.c_str(), d.c_str());\n          }\n       return doCp_xrd2loc(src.c_str(), dest.c_str());\n      }\n\n// Handle when source is the local filesystem\n//\n   if (rmtDst)\n      {XrdOucString d = dest;\n       if (Config.dstOpq) {d += \"?\"; d += Config.dstOpq;}\n       return doCp_loc2xrd(&xrddest, src.c_str(), d.c_str());\n      }\n\n// We should never get here\n//\n   EMSG(\"Better to use cp for this copy.\");\n   return 2;\n}\n\n/******************************************************************************/\n/*                                  m a i n                                   */\n/******************************************************************************/\n  \nint main(int argc, char**argv)\n{\n   std::cerr << \"Note: this tool is DEPRECATED, use xrdcp instead.\" << std::endl;\n   Info(XrdClientDebug::kUSERDEBUG, \"Main\",\n        \"Note: this tool is DEPRECATED, use xrdcp instead.\");\n\n   const char *Opaque;\n   char *hName, *srcpath = 0, *destpath = 0;\n\n// Preset globals\n//\n   tpcPB = 0;\n\n#ifdef WIN32\n   WORD wVersionRequested;\n   WSADATA wsaData;\n   int err;\n   wVersionRequested = MAKEWORD( 2, 2 );\n   err = WSAStartup( wVersionRequested, &wsaData );\n#endif\n\n// Invoke config; it it returns then all went well.\n//\n   Config.Config(argc, argv, XrdCpConfig::opt1Src|XrdCpConfig::optNoStdIn\n                            |XrdCpConfig::optNoXtnd|XrdCpConfig::optNoLclCp);\n\n// Turn off any blab from the client\n//\n   DebugSetLevel(-1);\n\n// We want this tool to be able to copy from/to everywhere\n// Note that the side effect of these calls here is to initialize the\n// XrdClient environment.\n// This is crucial if we want to later override its default values\n//\n   EnvPutString( NAME_REDIRDOMAINALLOW_RE, \"*\" );\n   EnvPutString( NAME_CONNECTDOMAINALLOW_RE, \"*\" );\n   EnvPutString( NAME_REDIRDOMAINDENY_RE, \"\" );\n   EnvPutString( NAME_CONNECTDOMAINDENY_RE, \"\" );\n\n   EnvPutInt( NAME_READAHEADSIZE, XRDCP_XRDRASIZE);\n   EnvPutInt( NAME_READCACHESIZE, 2*XRDCP_XRDRASIZE );\n   EnvPutInt( NAME_READCACHEBLKREMPOLICY, XrdClientReadCache::kRmBlk_LeastOffs );\n   EnvPutInt( NAME_PURGEWRITTENBLOCKS, 1 );\n\n   EnvPutInt( NAME_DEBUG, -1);\n\n// Extract out config information and set global vars (that's how it was done)\n//\n   if ((Verbose = Config.Verbose))          summary = true;\n   if (Config.Want(XrdCpConfig::DoSilent )) summary = progbar = false;\n   if (Config.Want(XrdCpConfig::DoNoPbar )) progbar = false;\n   if (Config.Want(XrdCpConfig::DoRecurse)) recurse = true;\n   if (Config.Want(XrdCpConfig::DoCoerce )) xrd_wr_flags |=  kXR_force;\n   if (Config.Want(XrdCpConfig::DoPosc   )) xrd_wr_flags |=  kXR_posc;\n   if (Config.Want(XrdCpConfig::DoForce  )\n   ||  Config.Want(XrdCpConfig::DoServer ))\n      {xrd_wr_flags &= ~kXR_new;\n       xrd_wr_flags |=  kXR_delete;\n       loc_wr_flags = LOC_WR_FLAGS_FORCE; // Flags for the local fs\n      }\n   if (Config.Want(XrdCpConfig::DoRetry  ) && Config.Retry >= 0)\n      {EnvPutInt(NAME_CONNECTTIMEOUT , 60);\n       EnvPutInt(NAME_FIRSTCONNECTMAXCNT, Config.Retry);\n      }\n\n   if (Config.strDefs)\n      {XrdCpConfig::defVar *dvP = Config.strDefs;\n       do {EnvPutString(dvP->vName, dvP->strVal);}\n          while((dvP = dvP->Next));\n      }\n\n   if (Config.intDefs)\n      {XrdCpConfig::defVar *dvP = Config.intDefs;\n       do {EnvPutInt(dvP->vName, dvP->intVal);}\n          while((dvP = dvP->Next));\n      }\n\n   if (Config.Want(XrdCpConfig::DoProxy  ))\n      {EnvPutString(NAME_SOCKS4HOST, Config.pHost);\n       EnvPutInt(NAME_SOCKS4PORT, Config.pPort);\n      }\n\n   if (Config.Dlvl > 0) EnvPutInt( NAME_DEBUG, Config.Dlvl);\n\n   if (Config.Want(XrdCpConfig::DoStreams))\n      EnvPutInt(NAME_MULTISTREAMCNT, Config.nStrm);\n\n   isTPC = (Config.Want(XrdCpConfig::DoTpc) ? 1 : 0);\n\n   destpath = Config.dstFile->Path;\n   srcpath  = Config.srcFile->Path;\n\n// Do some debugging\n//\n   DebugSetLevel(EnvGetLong(NAME_DEBUG));\n   Info(XrdClientDebug::kUSERDEBUG, \"main\", XRDCP_VERSION);\n\n// Prehandle extreme copy\n//\n   if (Config.Want(XrdCpConfig::DoSources) && Config.nSrcs > 1)\n      {doXtremeCp = true;\n       XtremeCpRdr = srcpath;\n       if (Verbose) EMSG(\"Extreme Copy enabled.\");\n      }\n\n// Establish checksum processing\n//\n   setCks = 0;\n   lclCks = Config.Want(XrdCpConfig::DoCksrc);\n   xeqCks = Config.Want(XrdCpConfig::DoCksum);\n   prtCks =(xeqCks || lclCks) &&  Config.Want(XrdCpConfig::DoCkprt);\n   getCks = xeqCks && (Config.CksData.Length == 0);\n   verCks = xeqCks && !prtCks;\n\n// Force certain defaults when in server mode\n//\n   if (Config.Want(XrdCpConfig::DoServer))\n      {summary = progbar = false;\n       setCks = true;\n       isSrv  = true;\n      } else {\n       isSrv = false;\n //    if (dup2(STDOUT_FILENO, STDERR_FILENO)) cerr <<\"??? \" <<errno <<endl;\n      }\n\n// Extract source host if present\n//\n   if (strncmp(srcpath, \"root://\", 7) || strncmp(srcpath, \"xroot://\", 8) )\n      {XrdClientUrlInfo sUrl(srcpath);\n       hName = (sUrl.IsValid() ? strdup(sUrl.Host.c_str()) : 0);\n      } else hName = 0;\n\n// Prepare to generate a copy list\n//\n   XrdCpWorkLst *wklst = new XrdCpWorkLst();\n   XrdOucString src, dest;\n   XrdClient *xrddest = 0;\n   cpnfo.XrdCli = 0;\n  \n// Generate the sources\n//\n   if (wklst->SetSrc(&cpnfo.XrdCli, srcpath, Config.srcOpq, recurse, 1))\n      {cpFatal(\"open\", cpnfo.XrdCli, 0, hName);\n       exit(1);\n      }\n\n// Generate destination opaque data now\n//\n   if (!isTPC) Opaque = Config.dstOpq;\n      else {if (!(Opaque = genDestCgi(cpnfo.XrdCli, srcpath))) exit(4);\n            tpcSrc = cpnfo.XrdCli;\n           }\n\n// Extract source host if present\n//\n   if (hName) free(hName);\n   if (strncmp(destpath, \"root://\", 7) || strncmp(destpath, \"xroot://\", 8) )\n      {XrdClientUrlInfo dUrl(destpath);\n       hName = (dUrl.IsValid() ? strdup(dUrl.Host.c_str()) : 0);\n      } else hName = 0;\n\n// Verify the correctness of the destination\n//\n   if (wklst->SetDest(&xrddest, destpath, Opaque, xrd_wr_flags, 1))\n      {cpFatal(\"open\", 0, xrddest, hName);\n       exit(1);\n      }\n   if (hName) {free(hName); hName = 0;}\n\n      // Initialize monitoring client, if a plugin is present\n      cpnfo.mon = 0;\n#ifndef WIN32\n      void *monhandle = dlopen (monlibname.c_str(), RTLD_LAZY);\n\n      if (monhandle) {\n\tXrdClientMonIntfHook monlibhook = (XrdClientMonIntfHook)dlsym(monhandle, \"XrdClientgetMonIntf\");\n\n\tconst char *err = 0;\n\tif ((err = dlerror())) {\n   EMSG(err <<\" loading library \" << monhandle);\n\t  dlclose(monhandle);\n\t  monhandle = 0;\n\t}\n\telse\t\n\t  cpnfo.mon = (XrdClientAbsMonIntf *)monlibhook(src.c_str(), dest.c_str());\n      }\n#endif\n      \n      if (cpnfo.mon) {\n\n\tchar *name=0, *ver=0, *rem=0;\n\tif (!cpnfo.mon->GetMonLibInfo(&name, &ver, &rem)) {\n\t  Info(XrdClientDebug::kUSERDEBUG,\n\t       \"main\", \"Monitoring client plugin found. Name:'\" << name <<\n\t       \"' Ver:'\" << ver << \"' Remarks:'\" << rem << \"'\");\n\t}\n\telse {\n\t  delete cpnfo.mon;\n\t  cpnfo.mon = 0;\n\t}\n\n      }\n\n#ifndef WIN32\n      if (!cpnfo.mon && monhandle) {\n\tdlclose(monhandle);\n\tmonhandle = 0;\n      }\n#endif\n\n// From here, we will have:\n// the knowledge if the dest is a dir name or file name\n// an open instance of xrdclient if it's a file\n//\n   int retval = 0;\n   while(!retval && wklst->GetCpJob(src, dest))\n        {if (cpnfo.mon)\n            {cpnfo.mon->Init(src.c_str(), dest.c_str(), (DebugLevel() > 0) );\n             cpnfo.mon->PutProgressInfo(0, cpnfo.len, 0, 1);\n            }\n         retval = doCp(src, dest, xrddest);\n         if (cpnfo.mon) cpnfo.mon->DeInit();\n        }\n\n// Delete the monitor object\n//\n   delete cpnfo.mon;\n   cpnfo.mon = 0;\n#ifndef WIN32\n   if (monhandle) dlclose(monhandle);\n   monhandle = 0;\n#endif\n\n// All done\n//\n   if (retval < 0) retval = -retval;\n   _exit(retval);\n   return retval;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-xrootd-4.8.4-t4rp3o5embz66ngclf6u6noewe4srpjk/spack-src/src/XrdSys/XrdSysPlugin.cc": "/******************************************************************************/\n/*                                                                            */\n/*                       X r d S y s P l u g i n . c c                        */\n/*                                                                            */\n/* (c) 2005 by the Board of Trustees of the Leland Stanford, Jr., University  */\n/*                            All Rights Reserved                             */\n/*   Produced by Andrew Hanushevsky for Stanford University under contract    */\n/*              DE-AC02-76-SFO0515 with the Department of Energy              */\n/*                                                                            */\n/* This file is part of the XRootD software suite.                            */\n/*                                                                            */\n/* XRootD is free software: you can redistribute it and/or modify it under    */\n/* the terms of the GNU Lesser General Public License as published by the     */\n/* Free Software Foundation, either version 3 of the License, or (at your     */\n/* option) any later version.                                                 */\n/*                                                                            */\n/* XRootD is distributed in the hope that it will be useful, but WITHOUT      */\n/* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or      */\n/* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public       */\n/* License for more details.                                                  */\n/*                                                                            */\n/* You should have received a copy of the GNU Lesser General Public License   */\n/* along with XRootD in a file called COPYING.LESSER (LGPL license) and file  */\n/* COPYING (GPL license).  If not, see <http://www.gnu.org/licenses/>.        */\n/*                                                                            */\n/* The copyright holder's institutional names and contributor's names may not */\n/* be used to endorse or promote products derived from this software without  */\n/* specific prior written permission of the institution or contributor.       */\n/******************************************************************************/\n\n// Bypass Solaris ELF madness\n//\n#ifdef __solaris__\n#include <sys/isa_defs.h>\n#if defined(_ILP32) && (_FILE_OFFSET_BITS != 32)\n#undef  _FILE_OFFSET_BITS\n#define _FILE_OFFSET_BITS 32\n#undef  _LARGEFILE_SOURCE\n#endif\n#endif\n\n#ifndef WIN32\n#include <dlfcn.h>\n#if !defined(__APPLE__) && !defined(__CYGWIN__)\n#include <link.h>\n#endif\n#include <stdio.h>\n#include <strings.h>\n#include <sys/types.h>\n#include <errno.h>\n#else\n#include \"XrdSys/XrdWin32.hh\"\n#endif\n  \n#include \"XrdSys/XrdSysError.hh\"\n#include \"XrdSys/XrdSysHeaders.hh\"\n#include \"XrdSys/XrdSysPlugin.hh\"\n#include \"XrdVersion.hh\"\n#include \"XrdVersionPlugin.hh\"\n \n/******************************************************************************/\n/*                        S t a t i c   M e m b e r s                         */\n/******************************************************************************/\n\nstruct XrdSysPlugin::PLlist *XrdSysPlugin::plList = 0;\n\n/******************************************************************************/\n/*                            D e s t r u c t o r                             */\n/******************************************************************************/\n  \nXrdSysPlugin::~XrdSysPlugin()\n{\n   if (libHandle) dlclose(libHandle);\n   if (libPath)   free(libPath);\n}\n\n/******************************************************************************/\n/* Private:                   b a d V e r s i o n                             */\n/******************************************************************************/\n  \nXrdSysPlugin::cvResult XrdSysPlugin::badVersion(XrdVersionInfo &urInfo,\n                                                char mmv, int majv, int minv)\n{\n   const char *path;\n   char buff1[512], buff2[128];\n\n   if (minv > 99) minv = 99;\n   snprintf(buff1, sizeof(buff1), \"version %s is incompatible with %s \"\n                                  \"(must be %c= %d.%d.x)\",\n                                   myInfo->vStr, urInfo.vStr, mmv, majv, minv);\n\n   path = msgSuffix(\" in \", buff2, sizeof(buff2));\n\n   Inform(buff1, buff2, path, 0, 0, 1);\n\n   return cvBad;\n}\n  \n/******************************************************************************/\n/* Private:                   c h k V e r s i o n                             */\n/******************************************************************************/\n  \nXrdSysPlugin::cvResult XrdSysPlugin::chkVersion(XrdVersionInfo &urInfo,\n                                                const char     *pname,\n                                                void           *lHandle)\n{\n   static XrdVersionPlugin vInfo[] = {XrdVERSIONPLUGINRULES};\n   static XrdVersionPlugin vNote[] = {XrdVERSIONPLUGINMAXIMS};\n   XrdVersionPlugin *vinP;\n   char buff[1024], vName[256];\n   void *vP;\n   int  i, n=0, pMajor, vMajor, pMinor, vMinor;\n\n// If no version information supplied, skip version check\n//\n   if (!myInfo) return cvNone;\n\n// Check if we need to check the version here\n//\n   i = 0;\n   while(vInfo[i].pName && strcmp(vInfo[i].pName, pname)) i++;\n\n// If we didn't find it in the rules table then try to match the maxims\n//\n   if (!vInfo[i].pName)\n      {i = 0; n = strlen(pname);\n       while(vNote[i].pName)\n            {if ((vNote[i].vPfxLen + vNote[i].vSfxLen <= n)\n             &&  !strncmp(vNote[i].pName, pname, vNote[i].vPfxLen)\n             &&  !strncmp(vNote[i].pName+vNote[i].vPfxLen,\n                   pname + n - vNote[i].vSfxLen, vNote[i].vSfxLen)) break;\n             i++;\n            }\n             vinP = &vNote[i];\n      } else vinP = &vInfo[i];\n\n   if (!(vinP->pName)) return cvNone;\n   if ( vinP->vProcess == XrdVERSIONPLUGIN_DoNotChk) return cvDirty;\n\n// Construct the version entry point\n//\n   if (!n) n = strlen(pname);\n   if (n+sizeof(XrdVERSIONINFOSFX) > sizeof(vName))\n      return libMsg(\"Unable to generate version name for\", \"%s in \", pname);\n   strcpy(vName, pname); strcpy(vName+n, XrdVERSIONINFOSFX);\n\n// Find the version number\n//\n   if (!(vP = dlsym(lHandle, vName)))\n      {if (vinP->vProcess != XrdVERSIONPLUGIN_Required) return cvMissing;\n       return libMsg(dlerror(),\" required version information for %s in \",pname);\n      }\n\n// Extract the version number from the plugin and do a quick check. We use\n// memcpy to avoid instances where the symbol is wrongly defined. Make sure\n// the version string ends with a null by copying one less byte than need be.\n// The caller provided a struct that is gauranteed to end with nulls.\n//\n   memcpy(static_cast<void*>( &urInfo ), vP, sizeof(XrdVersionInfo)-1);\n\n// If version numbers are identical then we are done\n//\n   if (myInfo->vNum == urInfo.vNum)\n      if (myInfo->vNum != XrdVNUMUNK\n      ||  !strcmp(myInfo->vStr + (myInfo->vOpt & 0x0f)+1,\n                  urInfo. vStr + (urInfo. vOpt & 0x0f)+1)) return cvClean;\n\n// If the caller or plugin is unreleased, just issue a warning.\n//\n   if (myInfo->vNum == XrdVNUMUNK || urInfo.vNum == XrdVNUMUNK)\n      {if (eDest)\n          {char mBuff[128];\n           sprintf(buff, \"%s%s is using %s%s version\",\n                   (myInfo->vNum == XrdVNUMUNK ? \"unreleased \":\"\"),myInfo->vStr,\n                   (urInfo.vNum  == XrdVNUMUNK ? \"unreleased \":\"\"),urInfo.vStr);\n           msgSuffix(\" in \", mBuff, sizeof(mBuff));\n           Inform(buff, mBuff, libPath);\n          }\n       return cvDirty;\n      }\n\n// Extract version numbers\n//\n   vMajor = XrdMajorVNUM(myInfo->vNum);\n   vMinor = XrdMinorVNUM(myInfo->vNum);\n   pMajor = XrdMajorVNUM(urInfo. vNum);\n   pMinor = XrdMinorVNUM(urInfo. vNum);\n\n// The major version must always be compatible\n//\n   if ((vinP->vMajLow >= 0 && pMajor <  vinP->vMajLow)\n   ||  (vinP->vMajLow <  0 && pMajor != vMajor))\n      return badVersion(urInfo, '>', vinP->vMajLow, vinP->vMinLow);\n\n// The major version may not be greater than our versin\n//\n   if (pMajor > vMajor) return badVersion(urInfo, '<', vMajor, vMinor);\n\n// If we do not need to check minor versions then we are done\n//\n   if (vinP->vMinLow > 99) return cvClean;\n\n// In no case can the plug-in mnor version be greater than our version\n//\n   if (pMajor == vMajor && pMinor > vMinor)\n      return badVersion(urInfo, '<', vMajor, vMinor);\n\n// Verify compatible minor versions\n//\n   if ((vinP->vMinLow >= 0 && pMinor >= vinP->vMinLow)\n   ||  (vinP->vMinLow <  0 && pMinor == vMinor)) return cvClean;\n\n// Incompatible versions\n//\n   return badVersion(urInfo, '>', vinP->vMajLow, vinP->vMinLow);\n}\n\n/******************************************************************************/\n/* Private:                      D L F l a g s                                */\n/******************************************************************************/\n  \nint XrdSysPlugin::DLflags()\n{\n#if    defined(__APPLE__)\n       return RTLD_FIRST;\n#elif  defined(__linux__)\n       return RTLD_NOW;\n#else\n       return RTLD_NOW;\n#endif\n}\n\n/******************************************************************************/\n/* Private:                         F i n d                                   */\n/******************************************************************************/\n  \nvoid *XrdSysPlugin::Find(const char *libpath)\n{\n   struct PLlist *plP = plList;\n\n// Find the library in the preload list\n//\n   while(plP && strcmp(libpath, plP->libPath)) plP = plP->next;\n\n// Return result\n//\n  return (plP ? plP->libHandle : 0);\n}\n\n/******************************************************************************/\n/*                             g e t P l u g i n                              */\n/******************************************************************************/\n\nvoid *XrdSysPlugin::getPlugin(const char *pname, int optional)\n{\n   return getPlugin(pname, optional, false);\n}\n\nvoid *XrdSysPlugin::getPlugin(const char *pname, int optional, bool global)\n{\n   XrdVERSIONINFODEF(urInfo, unknown, XrdVNUMUNK, \"\");\n   void *ep, *myHandle;\n   cvResult cvRC;\n   int flags;\n\n// If no path is given then we want to just search the executable. This is easy\n// for some platforms and more difficult for others. So, we do the best we can.\n//\n   if (libPath) flags = DLflags();\n      else {    flags = RTLD_NOW;\n#ifndef WIN32\n                flags|= global ? RTLD_GLOBAL : RTLD_LOCAL;\n#else\n            if (global && eDest) eDest->Emsg(\"getPlugin\",\n               \"request for global symbols unsupported under Windows - ignored\");\n#endif\n      }\n\n// Check if we should use the preload list\n//\n   if (!(myHandle = libHandle) && plList) myHandle = Find(libPath);\n\n// Open whatever it is we need to open\n//\n   if (!myHandle)\n      {if ((myHandle = dlopen(libPath, flags))) libHandle = myHandle;\n          else {if (optional < 2) libMsg(dlerror(), \" loading \"); return 0;}\n      }\n\n// Get the symbol. In the environment we have defined, null values are not\n// allowed and we will issue an error.\n//\n   if (!(ep = dlsym(myHandle, pname)))\n      {if (optional < 2) libMsg(dlerror(), \" plugin %s in \", pname);\n       return 0;\n      }\n\n// Check if we need to verify version compatability\n//\n   if ((cvRC = chkVersion(urInfo, pname, myHandle)) == cvBad) return 0;\n\n// Print the loaded version unless message is suppressed or not needed\n//\n   if (libPath && optional < 2 && msgCnt\n   &&  (cvRC == cvClean || cvRC == cvMissing))\n      {char buff[128];\n       msgSuffix(\" from \", buff, sizeof(buff));\n       msgCnt--;\n            if (cvRC == cvClean)\n               {const char *wTxt=(urInfo.vNum == XrdVNUMUNK ? \"unreleased \":0);\n                Inform(\"loaded \", wTxt, urInfo.vStr, buff, libPath);\n               }\n       else if (cvRC == cvMissing)\n               {Inform(\"loaded unversioned \", pname, buff, libPath);}\n      }\n\n// All done\n//\n   return ep;\n}\n\n/******************************************************************************/\n/* Private:                       I n f o r m                                 */\n/******************************************************************************/\n\nvoid XrdSysPlugin::Inform(const char *txt1, const char *txt2, const char *txt3,\n                          const char *txt4, const char *txt5, int noHush)\n{\n   const char *eTxt[] = {\"Plugin \",txt1, txt2, txt3, txt4, txt5, 0};\n   char *bP;\n   int n, i, bL;\n\n// Check if we should hush this messages (largely for client-side usage)\n//\n   if (!noHush && getenv(\"XRDPIHUSH\")) return;\n\n// If we have a messaging object, use that\n//\n   if (eDest)\n      {char buff[2048];\n       i = 1; bP = buff; bL = sizeof(buff);\n       while(bL > 1 && eTxt[i])\n            {n = snprintf(bP, bL, \"%s\", eTxt[i]);\n             bP += n; bL -= n; i++;\n            }\n       eDest->Say(\"Plugin \", buff);\n       return;\n      }\n\n// If we have a buffer, set message in the buffer\n//\n   if ((bP = eBuff))\n      {i = 0; bL = eBLen;\n       while(bL > 1 && eTxt[i])\n            {n = snprintf(bP, bL, \"%s\", eTxt[i]);\n             bP += n; bL -= n; i++;\n            }\n      }\n}\n  \n/******************************************************************************/\n/* Private:                       l i b M s g                                 */\n/******************************************************************************/\n  \nXrdSysPlugin::cvResult XrdSysPlugin::libMsg(const char *txt1, const char *txt2,\n                                            const char *mSym)\n{\n   static const char fndg[] = \"Finding\";\n   static const int  flen   = sizeof(\"Finding\");\n   const char *path;\n   char mBuff[512], nBuff[512];\n\n// Check if this is a lookup or open issue. Trim message for the common case.\n//\n        if (mSym)\n           {if (!txt1 || strstr(txt1, \"undefined\"))\n               {txt1 = \"Unable to find \";\n                snprintf(nBuff, sizeof(nBuff), txt2, mSym);\n               } else {\n                strcpy(nBuff, fndg);\n                snprintf(nBuff+flen-1,sizeof(nBuff)-flen,txt2,mSym);\n               }\n            txt2 = nBuff;\n           }\n   else if (!txt1) txt1 = \"Unknown system error!\";\n   else if (strstr(txt1, \"No such file\")) txt1 = \"No such file or directory\";\n   else txt2 = \" \";\n\n// Spit out the message\n//\n   path = msgSuffix(txt2, mBuff, sizeof(mBuff));\n   Inform(txt1, mBuff, path, 0, 0, 1);\n   return cvBad;\n}\n\n/******************************************************************************/\n/* Private:                    m s g S u f f i x                              */\n/******************************************************************************/\n\nconst char *XrdSysPlugin::msgSuffix(const char *Word, char *buff, int bsz)\n{\n   if (libPath) snprintf(buff, bsz,\"%s%s \", Word, libName);\n      else      snprintf(buff, bsz,\"%sexecutable image\", Word);\n   return (libPath ? libPath : \"\");\n}\n  \n/******************************************************************************/\n/*                               P r e l o a d                                */\n/******************************************************************************/\n  \nbool XrdSysPlugin::Preload(const char *path,  char *ebuff, int eblen)\n{\n   struct PLlist *plP;\n   void *myHandle;\n\n// First see if this is already in the preload list\n//\n   if (Find(path)) return true;\n\n// Try to open the library\n//\n   if (!(myHandle = dlopen(path, DLflags())))\n      {if (ebuff && eblen > 0)\n          {const char *dlMsg = dlerror();\n           snprintf(ebuff, eblen, \"Plugin unable to load %s; %s\", path,\n                                  (dlMsg ? dlMsg : \"unknown system error\"));\n          }\n       return false;\n      }\n\n// Add the library handle\n//\n   plP = new PLlist;\n   plP->libHandle = myHandle;\n   plP->libPath   = strdup(path);\n   plP->next      = plList;\n   plList         = plP;\n\n// All done\n//\n   return true;\n}\n\n/******************************************************************************/\n/*                                V e r C m p                                 */\n/******************************************************************************/\n  \nbool XrdSysPlugin::VerCmp(XrdVersionInfo &vInfo1,\n                          XrdVersionInfo &vInfo2, bool noMsg)\n{\n   const char *mTxt;\n   char v1buff[128], v2buff[128];\n   int unRel;\n\n// Do a quick return if the version need not be checked or are equal\n//\n   if (vInfo1.vNum <= 0 || vInfo1.vNum == vInfo2.vNum) return true;\n\n// As it works out, many times two modules wind up in different shared\n// libraries. For consistency we require that both major.minor version be the\n// same unless either is unreleased (i.e. test). Issue warning if need be.\n//\n   mTxt = (vInfo1.vNum == XrdVNUMUNK ? \"unreleased \" : \"\");\n   sprintf(v1buff, \" %sversion %s\", mTxt, vInfo1.vStr);\n   unRel  = *mTxt;\n\n   mTxt = (vInfo2.vNum == XrdVNUMUNK ? \"unreleased \" : \"\");\n   sprintf(v2buff, \" %sversion %s\", mTxt, vInfo2.vStr);\n   unRel |= *mTxt;\n\n   if (unRel || vInfo1.vNum/100 == vInfo2.vNum/100) mTxt = \"\";\n      else mTxt = \" which is incompatible!\";\n\n   if (!noMsg)\n      cerr <<\"Plugin: \" <<v1buff <<\" is using \" <<v2buff <<mTxt <<endl;\n\n   return (*mTxt == 0);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-xrootd-4.8.4-t4rp3o5embz66ngclf6u6noewe4srpjk/spack-src/src/XrdCl/XrdClDefaultEnv.cc": "//------------------------------------------------------------------------------\n// Copyright (c) 2011-2012 by European Organization for Nuclear Research (CERN)\n// Author: Lukasz Janyst <ljanyst@cern.ch>\n//------------------------------------------------------------------------------\n// XRootD is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// XRootD is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with XRootD.  If not, see <http://www.gnu.org/licenses/>.\n//------------------------------------------------------------------------------\n\n#include \"XrdCl/XrdClDefaultEnv.hh\"\n#include \"XrdCl/XrdClConstants.hh\"\n#include \"XrdCl/XrdClPostMaster.hh\"\n#include \"XrdCl/XrdClLog.hh\"\n#include \"XrdCl/XrdClForkHandler.hh\"\n#include \"XrdCl/XrdClFileTimer.hh\"\n#include \"XrdCl/XrdClUtils.hh\"\n#include \"XrdCl/XrdClMonitor.hh\"\n#include \"XrdCl/XrdClCheckSumManager.hh\"\n#include \"XrdCl/XrdClTransportManager.hh\"\n#include \"XrdCl/XrdClPlugInManager.hh\"\n#include \"XrdCl/XrdClOptimizers.hh\"\n#include \"XrdOuc/XrdOucPreload.hh\"\n#include \"XrdSys/XrdSysAtomics.hh\"\n#include \"XrdSys/XrdSysUtils.hh\"\n#include \"XrdSys/XrdSysPwd.hh\"\n#include \"XrdVersion.hh\"\n\n#include <libgen.h>\n#include <cstring>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <cctype>\n#include <string>\n#include <pthread.h>\n#include <sys/types.h>\n#include <unistd.h>\n\nXrdVERSIONINFO( XrdCl, client );\n\n//------------------------------------------------------------------------------\n// Forking functions\n//------------------------------------------------------------------------------\nextern \"C\"\n{\n  //----------------------------------------------------------------------------\n  // Prepare for the forking\n  //----------------------------------------------------------------------------\n  static void prepare()\n  {\n    using namespace XrdCl;\n    Log         *log         = DefaultEnv::GetLog();\n    Env         *env         = DefaultEnv::GetEnv();\n    ForkHandler *forkHandler = DefaultEnv::GetForkHandler();\n\n    log->Debug( UtilityMsg, \"In the prepare fork handler for process %d\",\n                getpid() );\n\n    //--------------------------------------------------------------------------\n    // Run the fork handler if it's enabled\n    //--------------------------------------------------------------------------\n    int runForkHandler = DefaultRunForkHandler;\n    env->GetInt( \"RunForkHandler\", runForkHandler );\n    if( runForkHandler )\n      forkHandler->Prepare();\n    env->WriteLock();\n  }\n\n  //----------------------------------------------------------------------------\n  // Parent handler\n  //----------------------------------------------------------------------------\n  static void parent()\n  {\n    using namespace XrdCl;\n    Log         *log         = DefaultEnv::GetLog();\n    Env         *env         = DefaultEnv::GetEnv();\n    ForkHandler *forkHandler = DefaultEnv::GetForkHandler();\n    env->UnLock();\n\n    pid_t pid = getpid();\n    log->Debug( UtilityMsg, \"In the parent fork handler for process %d\", pid );\n\n    //--------------------------------------------------------------------------\n    // Run the fork handler if it's enabled\n    //--------------------------------------------------------------------------\n    int runForkHandler = DefaultRunForkHandler;\n    env->GetInt( \"RunForkHandler\", runForkHandler );\n    if( runForkHandler )\n    {\n      log->SetPid(pid);\n      forkHandler->Parent();\n    }\n  }\n\n  //----------------------------------------------------------------------------\n  // Child handler\n  //----------------------------------------------------------------------------\n  static void child()\n  {\n    using namespace XrdCl;\n    DefaultEnv::ReInitializeLogging();\n    Log         *log         = DefaultEnv::GetLog();\n    Env         *env         = DefaultEnv::GetEnv();\n    ForkHandler *forkHandler = DefaultEnv::GetForkHandler();\n    env->ReInitializeLock();\n\n    pid_t pid = getpid();\n    log->Debug( UtilityMsg, \"In the child fork handler for process %d\", pid );\n\n    //--------------------------------------------------------------------------\n    // Run the fork handler if it's enabled\n    //--------------------------------------------------------------------------\n    int runForkHandler = DefaultRunForkHandler;\n    env->GetInt( \"RunForkHandler\", runForkHandler );\n    if( runForkHandler )\n    {\n      log->SetPid(pid);\n      forkHandler->Child();\n    }\n  }\n}\n\nnamespace\n{\n  //----------------------------------------------------------------------------\n  // Translate a string into a topic mask\n  //----------------------------------------------------------------------------\n  struct MaskTranslator\n  {\n    //--------------------------------------------------------------------------\n    // Initialize the translation array\n    //--------------------------------------------------------------------------\n    MaskTranslator()\n    {\n      masks[\"AppMsg\"]             = XrdCl::AppMsg;\n      masks[\"UtilityMsg\"]         = XrdCl::UtilityMsg;\n      masks[\"FileMsg\"]            = XrdCl::FileMsg;\n      masks[\"PollerMsg\"]          = XrdCl::PollerMsg;\n      masks[\"PostMasterMsg\"]      = XrdCl::PostMasterMsg;\n      masks[\"XRootDTransportMsg\"] = XrdCl::XRootDTransportMsg;\n      masks[\"TaskMgrMsg\"]         = XrdCl::TaskMgrMsg;\n      masks[\"XRootDMsg\"]          = XrdCl::XRootDMsg;\n      masks[\"FileSystemMsg\"]      = XrdCl::FileSystemMsg;\n      masks[\"AsyncSockMsg\"]       = XrdCl::AsyncSockMsg;\n      masks[\"JobMgrMsg\"]          = XrdCl::JobMgrMsg;\n      masks[\"PlugInMgrMsg\"]       = XrdCl::PlugInMgrMsg;\n    }\n\n    //--------------------------------------------------------------------------\n    // Translate the mask\n    //--------------------------------------------------------------------------\n    uint64_t translateMask( const std::string mask )\n    {\n      if( mask == \"\" )\n        return 0xffffffffffffffffULL;\n\n      std::vector<std::string>           topics;\n      std::vector<std::string>::iterator it;\n      XrdCl::Utils::splitString( topics, mask, \"|\" );\n\n      uint64_t resultMask = 0;\n      std::map<std::string, uint64_t>::iterator maskIt;\n      for( it = topics.begin(); it != topics.end(); ++it )\n      {\n        //----------------------------------------------------------------------\n        // Check for resetting pseudo topics\n        //----------------------------------------------------------------------\n        if( *it == \"All\" )\n        {\n          resultMask = 0xffffffffffffffffULL;\n          continue;\n        }\n\n        if( *it == \"None\" )\n        {\n          resultMask = 0ULL;\n          continue;\n        }\n\n        //----------------------------------------------------------------------\n        // Check whether given topic should be disabled or enabled\n        //----------------------------------------------------------------------\n        std::string topic = *it;\n        bool disable      = false;\n        if( !topic.empty() && topic[0] == '^' )\n        {\n          disable = true;\n          topic   = topic.substr( 1, topic.length()-1 );\n        }\n\n        maskIt = masks.find( topic );\n        if( maskIt == masks.end() )\n          continue;\n\n        if( disable )\n          resultMask &= (0xffffffffffffffffULL ^ maskIt->second);\n        else\n          resultMask |= maskIt->second;\n      }\n\n      return resultMask;\n    }\n\n    std::map<std::string, uint64_t> masks;\n  };\n\n  //----------------------------------------------------------------------------\n  // Helper for handling environment variables\n  //----------------------------------------------------------------------------\n  template<typename Item>\n  struct EnvVarHolder\n  {\n    EnvVarHolder( const std::string &name_, const Item &def_ ):\n      name( name_ ), def( def_ ) {}\n    std::string name;\n    Item        def;\n  };\n}\n\n#define REGISTER_VAR_INT( array, name,  def ) \\\n    array.push_back( EnvVarHolder<int>( name, def ) )\n\n#define REGISTER_VAR_STR( array, name,  def ) \\\n    array.push_back( EnvVarHolder<std::string>( name, def ) )\n\nnamespace XrdCl\n{\n  //----------------------------------------------------------------------------\n  // Statics\n  //----------------------------------------------------------------------------\n  XrdSysMutex        DefaultEnv::sInitMutex;\n  Env               *DefaultEnv::sEnv                = 0;\n  PostMaster        *DefaultEnv::sPostMaster         = 0;\n  Log               *DefaultEnv::sLog                = 0;\n  ForkHandler       *DefaultEnv::sForkHandler        = 0;\n  FileTimer         *DefaultEnv::sFileTimer          = 0;\n  Monitor           *DefaultEnv::sMonitor            = 0;\n  XrdOucPinLoader   *DefaultEnv::sMonitorLibHandle   = 0;\n  bool               DefaultEnv::sMonitorInitialized = false;\n  CheckSumManager   *DefaultEnv::sCheckSumManager    = 0;\n  TransportManager  *DefaultEnv::sTransportManager   = 0;\n  PlugInManager     *DefaultEnv::sPlugInManager      = 0;\n\n  //----------------------------------------------------------------------------\n  // Constructor\n  //----------------------------------------------------------------------------\n  DefaultEnv::DefaultEnv()\n  {\n    Log *log = GetLog();\n\n    //--------------------------------------------------------------------------\n    // Declate the variables to be processed\n    //--------------------------------------------------------------------------\n    std::vector<EnvVarHolder<int> >         varsInt;\n    std::vector<EnvVarHolder<std::string> > varsStr;\n    REGISTER_VAR_INT( varsInt, \"ConnectionWindow\",     DefaultConnectionWindow     );\n    REGISTER_VAR_INT( varsInt, \"ConnectionRetry\",      DefaultConnectionRetry      );\n    REGISTER_VAR_INT( varsInt, \"RequestTimeout\",       DefaultRequestTimeout       );\n    REGISTER_VAR_INT( varsInt, \"StreamTimeout\",        DefaultStreamTimeout        );\n    REGISTER_VAR_INT( varsInt, \"SubStreamsPerChannel\", DefaultSubStreamsPerChannel );\n    REGISTER_VAR_INT( varsInt, \"TimeoutResolution\",    DefaultTimeoutResolution    );\n    REGISTER_VAR_INT( varsInt, \"StreamErrorWindow\",    DefaultStreamErrorWindow    );\n    REGISTER_VAR_INT( varsInt, \"RunForkHandler\",       DefaultRunForkHandler       );\n    REGISTER_VAR_INT( varsInt, \"RedirectLimit\",        DefaultRedirectLimit        );\n    REGISTER_VAR_INT( varsInt, \"WorkerThreads\",        DefaultWorkerThreads        );\n    REGISTER_VAR_INT( varsInt, \"CPChunkSize\",          DefaultCPChunkSize          );\n    REGISTER_VAR_INT( varsInt, \"CPParallelChunks\",     DefaultCPParallelChunks     );\n    REGISTER_VAR_INT( varsInt, \"DataServerTTL\",        DefaultDataServerTTL        );\n    REGISTER_VAR_INT( varsInt, \"LoadBalancerTTL\",      DefaultLoadBalancerTTL      );\n    REGISTER_VAR_INT( varsInt, \"CPInitTimeout\",        DefaultCPInitTimeout        );\n    REGISTER_VAR_INT( varsInt, \"CPTPCTimeout\",         DefaultCPTPCTimeout         );\n    REGISTER_VAR_INT( varsInt, \"TCPKeepAlive\",         DefaultTCPKeepAlive         );\n    REGISTER_VAR_INT( varsInt, \"TCPKeepAliveTime\",     DefaultTCPKeepAliveTime     );\n    REGISTER_VAR_INT( varsInt, \"TCPKeepAliveInterval\", DefaultTCPKeepAliveInterval );\n    REGISTER_VAR_INT( varsInt, \"TCPKeepProbes\",        DefaultTCPKeepAliveProbes   );\n    REGISTER_VAR_INT( varsInt, \"MultiProtocol\",        DefaultMultiProtocol        );\n    REGISTER_VAR_INT( varsInt, \"ParallelEvtLoop\",      DefaultParallelEvtLoop      );\n    REGISTER_VAR_INT( varsInt, \"MetalinkProcessing\",   DefaultMetalinkProcessing   );\n    REGISTER_VAR_INT( varsInt, \"LocalMetalinkFile\",    DefaultLocalMetalinkFile    );\n    REGISTER_VAR_INT( varsInt, \"XCpBlockSize\",         DefaultXCpBlockSize         );\n    REGISTER_VAR_INT( varsInt, \"NoDelay\",              DefaultNoDelay              );\n    REGISTER_VAR_INT( varsInt, \"PreferIPv4\",           DefaultPreferIPv4           );\n\n    REGISTER_VAR_STR( varsStr, \"PollerPreference\",     DefaultPollerPreference     );\n    REGISTER_VAR_STR( varsStr, \"ClientMonitor\",        DefaultClientMonitor        );\n    REGISTER_VAR_STR( varsStr, \"ClientMonitorParam\",   DefaultClientMonitorParam   );\n    REGISTER_VAR_STR( varsStr, \"NetworkStack\",         DefaultNetworkStack         );\n    REGISTER_VAR_STR( varsStr, \"PlugIn\",               DefaultPlugIn               );\n    REGISTER_VAR_STR( varsStr, \"PlugInConfDir\",        DefaultPlugInConfDir        );\n    REGISTER_VAR_STR( varsStr, \"ReadRecovery\",         DefaultReadRecovery         );\n    REGISTER_VAR_STR( varsStr, \"WriteRecovery\",        DefaultWriteRecovery        );\n    REGISTER_VAR_STR( varsStr, \"GlfnRedirector\",       DefaultGlfnRedirector       );\n\n    //--------------------------------------------------------------------------\n    // Process the configuration files\n    //--------------------------------------------------------------------------\n    std::map<std::string, std::string> config, userConfig;\n    Status st = Utils::ProcessConfig( config, \"/etc/xrootd/client.conf\" );\n\n    if( !st.IsOK() )\n      log->Warning( UtilityMsg, \"Unable to process global config file: %s\",\n                    st.ToString().c_str() );\n\n    XrdSysPwd pwdHandler;\n    passwd *pwd = pwdHandler.Get( getuid() );\n    if( pwd )\n    {\n      std::string userConfigFile = pwd->pw_dir;\n      userConfigFile += \"/.xrootd/client.conf\";\n\n      st = Utils::ProcessConfig( userConfig, userConfigFile );\n\n      if( !st.IsOK() )\n        log->Debug( UtilityMsg, \"Unable to process user config file: %s\",\n                    st.ToString().c_str() );\n    }\n    else\n      log->Debug( UtilityMsg, \"Unable to find user home directory.\" );\n\n    std::map<std::string, std::string>::iterator it;\n\n    for( it = config.begin(); it != config.end(); ++it )\n      log->Dump( UtilityMsg, \"[Global config] \\\"%s\\\" = \\\"%s\\\"\",\n                 it->first.c_str(), it->second.c_str() );\n\n    for( it = userConfig.begin(); it != userConfig.end(); ++it )\n    {\n      config[it->first] = it->second;\n      log->Dump( UtilityMsg, \"[User config] \\\"%s\\\" = \\\"%s\\\"\",\n                 it->first.c_str(), it->second.c_str() );\n    }\n\n    for( it = config.begin(); it != config.end(); ++it )\n      log->Debug( UtilityMsg, \"[Effective config] \\\"%s\\\" = \\\"%s\\\"\",\n                  it->first.c_str(), it->second.c_str() );\n\n    //--------------------------------------------------------------------------\n    // Monitoring settings\n    //--------------------------------------------------------------------------\n    char *tmp = strdup( XrdSysUtils::ExecName() );\n    char *appName = basename( tmp );\n    PutString( \"AppName\", appName );\n    free( tmp );\n    ImportString( \"AppName\", \"XRD_APPNAME\" );\n    PutString( \"MonInfo\", \"\" );\n    ImportString( \"MonInfo\", \"XRD_MONINFO\" );\n\n    //--------------------------------------------------------------------------\n    // Process ints\n    //--------------------------------------------------------------------------\n    for( size_t i = 0; i < varsInt.size(); ++i )\n    {\n      PutInt( varsInt[i].name, varsInt[i].def );\n\n      it = config.find( varsInt[i].name );\n      if( it != config.end() )\n      {\n        char *endPtr = 0;\n        int value = (int)strtol( it->second.c_str(), &endPtr, 0 );\n        if( *endPtr )\n          log->Warning( UtilityMsg, \"Unable to set %s to %s: not a proper \"\n                        \"integer\", varsInt[i].name.c_str(),\n                        it->second.c_str() );\n        else\n          PutInt( varsInt[i].name, value );\n      }\n\n      std::string name = \"XRD_\" + varsInt[i].name;\n      std::transform( name.begin(), name.end(), name.begin(), ::toupper );\n      ImportInt( varsInt[i].name, name );\n    }\n\n    //--------------------------------------------------------------------------\n    // Process strings\n    //--------------------------------------------------------------------------\n    for( size_t i = 0; i < varsStr.size(); ++i )\n    {\n      PutString( varsStr[i].name, varsStr[i].def );\n\n      it = config.find( varsStr[i].name );\n      if( it != config.end() )\n        PutString( varsStr[i].name, it->second );\n\n      std::string name = \"XRD_\" + varsStr[i].name;\n      std::transform( name.begin(), name.end(), name.begin(), ::toupper );\n      ImportString( varsStr[i].name, name );\n    }\n\n    //--------------------------------------------------------------------------\n    // Register fork handlers\n    //--------------------------------------------------------------------------\n    pthread_atfork( prepare, parent, child );\n  }\n\n  //----------------------------------------------------------------------------\n  // Get default client environment\n  //----------------------------------------------------------------------------\n  Env *DefaultEnv::GetEnv()\n  {\n    return sEnv;\n  }\n\n  //----------------------------------------------------------------------------\n  // Get default post master\n  //----------------------------------------------------------------------------\n  PostMaster *DefaultEnv::GetPostMaster()\n  {\n    PostMaster* postMaster = AtomicGet(sPostMaster);\n\n    if( unlikely( !postMaster ) )\n    {\n      XrdSysMutexHelper scopedLock( sInitMutex );\n      postMaster = AtomicGet(sPostMaster);\n\n      if( postMaster )\n        return postMaster;\n\n      postMaster = new PostMaster();\n\n      if( !postMaster->Initialize() )\n      {\n        delete postMaster;\n        postMaster = 0;\n        return 0;\n      }\n\n      if( !postMaster->Start() )\n      {\n        postMaster->Finalize();\n        delete postMaster;\n        postMaster = 0;\n        return 0;\n      }\n\n      sForkHandler->RegisterPostMaster( postMaster );\n      postMaster->GetTaskManager()->RegisterTask( sFileTimer, time(0), false );\n      AtomicCAS(sPostMaster, sPostMaster, postMaster);\n    }\n\n    return postMaster;\n  }\n\n  //----------------------------------------------------------------------------\n  // Get log\n  //----------------------------------------------------------------------------\n  Log *DefaultEnv::GetLog()\n  {\n    return sLog;\n  }\n\n  //----------------------------------------------------------------------------\n  // Set log level\n  //----------------------------------------------------------------------------\n  void DefaultEnv::SetLogLevel( const std::string &level )\n  {\n    Log *log = GetLog();\n    log->SetLevel( level );\n  }\n\n  //----------------------------------------------------------------------------\n  // Set log file\n  //----------------------------------------------------------------------------\n  bool DefaultEnv::SetLogFile( const std::string &filepath )\n  {\n    Log *log = GetLog();\n    LogOutFile *out = new LogOutFile();\n\n    if( out->Open( filepath ) )\n    {\n      log->SetOutput( out );\n      return true;\n    }\n\n    delete out;\n    return false;\n  }\n\n  //----------------------------------------------------------------------------\n  //! Set log mask.\n  //------------------------------------------------------------------------\n  void DefaultEnv::SetLogMask( const std::string &level,\n                               const std::string &mask )\n  {\n    Log *log = GetLog();\n    MaskTranslator translator;\n    uint64_t topicMask = translator.translateMask( mask );\n\n    if( level == \"All\" )\n    {\n      log->SetMask( Log::ErrorMsg,   topicMask );\n      log->SetMask( Log::WarningMsg, topicMask );\n      log->SetMask( Log::InfoMsg,    topicMask );\n      log->SetMask( Log::DebugMsg,   topicMask );\n      log->SetMask( Log::DumpMsg,    topicMask );\n      return;\n    }\n\n    log->SetMask( level, topicMask );\n  }\n\n  //----------------------------------------------------------------------------\n  // Get fork handler\n  //----------------------------------------------------------------------------\n  ForkHandler *DefaultEnv::GetForkHandler()\n  {\n    return sForkHandler;\n  }\n\n  //----------------------------------------------------------------------------\n  // Get fork handler\n  //----------------------------------------------------------------------------\n  FileTimer *DefaultEnv::GetFileTimer()\n  {\n    return sFileTimer;\n  }\n\n  //----------------------------------------------------------------------------\n  // Get the monitor object\n  //----------------------------------------------------------------------------\n  Monitor *DefaultEnv::GetMonitor()\n  {\n    if( unlikely( !sMonitorInitialized ) )\n    {\n      XrdSysMutexHelper scopedLock( sInitMutex );\n      if( !sMonitorInitialized )\n      {\n        //----------------------------------------------------------------------\n        // Check the environment settings\n        //----------------------------------------------------------------------\n        Env *env = GetEnv();\n        Log *log = GetLog();\n        sMonitorInitialized = true;\n        std::string monitorLib = DefaultClientMonitor;\n        env->GetString( \"ClientMonitor\", monitorLib );\n        if( monitorLib.empty() )\n        {\n          log->Debug( UtilityMsg, \"Monitor library name not set. No \"\n                      \"monitoring\" );\n          return 0;\n        }\n\n        std::string monitorParam = DefaultClientMonitorParam;\n        env->GetString( \"ClientMonitorParam\", monitorParam );\n\n        log->Debug( UtilityMsg, \"Initializing monitoring, lib: %s, param: %s\",\n                    monitorLib.c_str(), monitorParam.c_str() );\n\n        //----------------------------------------------------------------------\n        // Loading the plugin\n        //----------------------------------------------------------------------\n        char *errBuffer = new char[4000];\n        sMonitorLibHandle = new XrdOucPinLoader(\n                                 errBuffer, 4000, &XrdVERSIONINFOVAR( XrdCl ),\n                                 \"monitor\", monitorLib.c_str() );\n\n        typedef XrdCl::Monitor *(*MonLoader)(const char *, const char *);\n        MonLoader loader;\n        loader = (MonLoader)sMonitorLibHandle->Resolve( \"XrdClGetMonitor\", -1 );\n        if( !loader )\n        {\n          log->Error( UtilityMsg, \"Unable to initialize user monitoring: %s\",\n                      errBuffer );\n          delete [] errBuffer;\n          sMonitorLibHandle->Unload();\n          delete sMonitorLibHandle; sMonitorLibHandle = 0;\n          return 0;\n        }\n\n        //----------------------------------------------------------------------\n        // Instantiating the monitor object\n        //----------------------------------------------------------------------\n        const char *param = monitorParam.empty() ? 0 : monitorParam.c_str();\n        sMonitor = (*loader)( XrdSysUtils::ExecName(), param );\n\n        if( !sMonitor )\n        {\n          log->Error( UtilityMsg, \"Unable to initialize user monitoring: %s\",\n                      errBuffer );\n          delete [] errBuffer;\n          sMonitorLibHandle->Unload();\n          delete sMonitorLibHandle; sMonitorLibHandle = 0;\n          return 0;\n        }\n        log->Debug( UtilityMsg, \"Successfully initialized monitoring from: %s\",\n                    monitorLib.c_str() );\n        delete [] errBuffer;\n      }\n    }\n    return sMonitor;\n  }\n\n  //----------------------------------------------------------------------------\n  // Get checksum manager\n  //----------------------------------------------------------------------------\n  CheckSumManager *DefaultEnv::GetCheckSumManager()\n  {\n    if( unlikely( !sCheckSumManager ) )\n    {\n      XrdSysMutexHelper scopedLock( sInitMutex );\n      if( !sCheckSumManager )\n        sCheckSumManager = new CheckSumManager();\n    }\n    return sCheckSumManager;\n  }\n\n  //----------------------------------------------------------------------------\n  // Get transport manager\n  //----------------------------------------------------------------------------\n  TransportManager *DefaultEnv::GetTransportManager()\n  {\n    if( unlikely( !sTransportManager ) )\n    {\n      XrdSysMutexHelper scopedLock( sInitMutex );\n      if( !sTransportManager )\n        sTransportManager = new TransportManager();\n    }\n    return sTransportManager;\n  }\n\n  //----------------------------------------------------------------------------\n  // Get plug-in manager\n  //----------------------------------------------------------------------------\n  PlugInManager *DefaultEnv::GetPlugInManager()\n  {\n    return sPlugInManager;\n  }\n\n  //----------------------------------------------------------------------------\n  // Retrieve the plug-in factory for the given URL\n  //----------------------------------------------------------------------------\n  PlugInFactory *DefaultEnv::GetPlugInFactory( const std::string url )\n  {\n    return  sPlugInManager->GetFactory( url );\n  }\n\n  //----------------------------------------------------------------------------\n  // Initialize the environment\n  //----------------------------------------------------------------------------\n  void DefaultEnv::Initialize()\n  {\n    sLog           = new Log();\n    SetUpLog();\n\n    sEnv           = new DefaultEnv();\n    sForkHandler   = new ForkHandler();\n    sFileTimer     = new FileTimer();\n    sPlugInManager = new PlugInManager();\n\n    sPlugInManager->ProcessEnvironmentSettings();\n    sForkHandler->RegisterFileTimer( sFileTimer );\n\n    //--------------------------------------------------------------------------\n    // MacOSX library loading is completely moronic. We cannot dlopen a library\n    // from a thread other than a main thread, so we-pre dlopen all the\n    // libraries that we may potentially want.\n    //--------------------------------------------------------------------------\n#ifdef __APPLE__\n    char *errBuff = new char[1024];\n\n    const char *libs[] =\n    {\n      \"libXrdSeckrb5.so\",\n      \"libXrdSecgsi.so\",\n      \"libXrdSecgsiAuthzVO.so\",\n      \"libXrdSecgsiGMAPDN.so\",\n      \"libXrdSecpwd.so\",\n      \"libXrdSecsss.so\",\n      \"libXrdSecunix.so\",\n      0\n    };\n\n    for( int i = 0; libs[i]; ++i )\n    {\n      sLog->Debug( UtilityMsg, \"Attempting to pre-load: %s\", libs[i] );\n      bool ok = XrdOucPreload( libs[i], errBuff, 1024 );\n      if( !ok )\n        sLog->Error( UtilityMsg, \"Unable to pre-load %s: %s\", libs[i], errBuff );\n    }\n    delete [] errBuff;\n#endif\n  }\n\n  //----------------------------------------------------------------------------\n  // Finalize the environment\n  //----------------------------------------------------------------------------\n  void DefaultEnv::Finalize()\n  {\n    if( sPostMaster )\n    {\n      sPostMaster->Stop();\n      sPostMaster->Finalize();\n      delete sPostMaster;\n      sPostMaster = 0;\n    }\n\n    delete sTransportManager;\n    sTransportManager = 0;\n\n    delete sCheckSumManager;\n    sCheckSumManager = 0;\n\n    delete sMonitor;\n    sMonitor = 0;\n\n    if( sMonitorLibHandle )\n      sMonitorLibHandle->Unload();\n\n    delete sMonitorLibHandle;\n    sMonitorLibHandle = 0;\n\n    delete sForkHandler;\n    sForkHandler = 0;\n\n    delete sFileTimer;\n    sFileTimer = 0;\n\n    delete sPlugInManager;\n    sPlugInManager = 0;\n\n    delete sEnv;\n    sEnv = 0;\n\n    delete sLog;\n    sLog = 0;\n  }\n\n  //----------------------------------------------------------------------------\n  // Re-initialize the logging\n  //----------------------------------------------------------------------------\n  void DefaultEnv::ReInitializeLogging()\n  {\n    delete sLog;\n    sLog = new Log();\n    SetUpLog();\n  }\n\n  //----------------------------------------------------------------------------\n  // Set up the log\n  //----------------------------------------------------------------------------\n  void DefaultEnv::SetUpLog()\n  {\n    Log *log = GetLog();\n\n    //--------------------------------------------------------------------------\n    // Check if the log level has been defined in the environment\n    //--------------------------------------------------------------------------\n    char *level = getenv( \"XRD_LOGLEVEL\" );\n    if( level )\n      log->SetLevel( level );\n\n    //--------------------------------------------------------------------------\n    // Check if we need to log to a file\n    //--------------------------------------------------------------------------\n    char *file = getenv( \"XRD_LOGFILE\" );\n    if( file )\n    {\n      LogOutFile *out = new LogOutFile();\n      if( out->Open( file ) )\n        log->SetOutput( out );\n      else\n        delete out;\n    }\n\n    //--------------------------------------------------------------------------\n    // Log mask defaults\n    //--------------------------------------------------------------------------\n    MaskTranslator translator;\n    log->SetMask( Log::DumpMsg, translator.translateMask( \"All|^PollerMsg\" ) );\n\n    //--------------------------------------------------------------------------\n    // Initialize the topic mask\n    //--------------------------------------------------------------------------\n    char *logMask = getenv( \"XRD_LOGMASK\" );\n    if( logMask )\n    {\n      uint64_t mask = translator.translateMask( logMask );\n      log->SetMask( Log::ErrorMsg,   mask );\n      log->SetMask( Log::WarningMsg, mask );\n      log->SetMask( Log::InfoMsg,    mask );\n      log->SetMask( Log::DebugMsg,   mask );\n      log->SetMask( Log::DumpMsg,    mask );\n    }\n\n    logMask = getenv( \"XRD_LOGMASK_ERROR\" );\n    if( logMask ) log->SetMask( Log::ErrorMsg, translator.translateMask( logMask ) );\n\n    logMask = getenv( \"XRD_LOGMASK_WARNING\" );\n    if( logMask ) log->SetMask( Log::WarningMsg, translator.translateMask( logMask ) );\n\n    logMask = getenv( \"XRD_LOGMASK_INFO\" );\n    if( logMask ) log->SetMask( Log::InfoMsg, translator.translateMask( logMask ) );\n\n    logMask = getenv( \"XRD_LOGMASK_DEBUG\" );\n    if( logMask ) log->SetMask( Log::DebugMsg, translator.translateMask( logMask ) );\n\n    logMask = getenv( \"XRD_LOGMASK_DUMP\" );\n    if( logMask ) log->SetMask( Log::DumpMsg, translator.translateMask( logMask ) );\n\n    //--------------------------------------------------------------------------\n    // Set up the topic strings\n    //--------------------------------------------------------------------------\n    log->SetTopicName( AppMsg,             \"App\" );\n    log->SetTopicName( UtilityMsg,         \"Utility\" );\n    log->SetTopicName( FileMsg,            \"File\" );\n    log->SetTopicName( PollerMsg,          \"Poller\" );\n    log->SetTopicName( PostMasterMsg,      \"PostMaster\" );\n    log->SetTopicName( XRootDTransportMsg, \"XRootDTransport\" );\n    log->SetTopicName( TaskMgrMsg,         \"TaskMgr\" );\n    log->SetTopicName( XRootDMsg,          \"XRootD\" );\n    log->SetTopicName( FileSystemMsg,      \"FileSystem\" );\n    log->SetTopicName( AsyncSockMsg,       \"AsyncSock\" );\n    log->SetTopicName( JobMgrMsg,          \"JobMgr\" );\n    log->SetTopicName( PlugInMgrMsg,       \"PlugInMgr\" );\n  }\n}\n\n\n//------------------------------------------------------------------------------\n// Static initialization and finalization\n//------------------------------------------------------------------------------\nint EnvInitializer::counter = 0;\n\n//------------------------------------------------------------------------------\n// The constructor will be invoked in every translation unit\n// that includes XrdClDefaultEnv.hh, but the DefaultEnv will\n// be initialized only in the first one\n//------------------------------------------------------------------------------\nEnvInitializer::EnvInitializer ()\n{\n  if( counter++ == 0 ) XrdCl::DefaultEnv::Initialize();\n}\n\n//------------------------------------------------------------------------------\n// The destructor will be invoked in every translation unit\n// that includes XrdClDefaultEnv.hh, but the DefaultEnv will\n// be finalized only once in the last one\n//------------------------------------------------------------------------------\nEnvInitializer::~EnvInitializer ()\n{\n  if( --counter == 0 ) XrdCl::DefaultEnv::Finalize();\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-xrootd-4.8.4-t4rp3o5embz66ngclf6u6noewe4srpjk/spack-src/tests/common/TextRunner.cc": "//------------------------------------------------------------------------------\n// Copyright (c) 2011-2012 by European Organization for Nuclear Research (CERN)\n// Author: Lukasz Janyst <ljanyst@cern.ch>\n//------------------------------------------------------------------------------\n// XRootD is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// XRootD is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with XRootD.  If not, see <http://www.gnu.org/licenses/>.\n//------------------------------------------------------------------------------\n\n#include <cppunit/CompilerOutputter.h>\n#include <cppunit/ui/text/TestRunner.h>\n#include <cppunit/extensions/HelperMacros.h>\n#include <dlfcn.h>\n#include \"PathProcessor.hh\"\n\n//------------------------------------------------------------------------------\n// Print all the tests present in the test suite\n//------------------------------------------------------------------------------\nvoid printTests( const CppUnit::Test *t, std::string prefix = \"\" )\n{\n  if( t == 0 )\n    return;\n\n  const CppUnit::TestSuite *suite = dynamic_cast<const CppUnit::TestSuite*>( t );\n  std::cerr << prefix << t->getName();\n  if( suite )\n  {\n    std::cerr << \"/\" << std::endl;\n    std::string prefix1 = \"  \"; prefix1 += prefix;\n    prefix1 += t->getName(); prefix1 += \"/\";\n    const std::vector<CppUnit::Test*> &tests = suite->getTests();\n    std::vector<CppUnit::Test*>::const_iterator it;\n    for( it = tests.begin(); it != tests.end(); ++it )\n      printTests( *it, prefix1 );\n  }\n  else\n    std::cerr << std::endl;\n}\n\n//------------------------------------------------------------------------------\n// Find a test\n//------------------------------------------------------------------------------\nCppUnit::Test *findTest( CppUnit::Test *t, const std::string &test )\n{\n  //----------------------------------------------------------------------------\n  // Check the suit and the path\n  //----------------------------------------------------------------------------\n  std::vector<std::string> elements;\n  eos::PathProcessor::splitPath( elements, test );\n\n  if( t == 0 )\n    return 0;\n\n  if( elements.empty() )\n    return 0;\n\n  if( t->getName() != elements[0] )\n    return 0;\n\n  //----------------------------------------------------------------------------\n  // Look for the requested test\n  //----------------------------------------------------------------------------\n  CppUnit::Test *ret = t;\n  for( size_t i = 1; i < elements.size(); ++i )\n  {\n    CppUnit::TestSuite *suite = dynamic_cast<CppUnit::TestSuite*>( ret );\n    CppUnit::Test      *next  = 0;\n    const std::vector<CppUnit::Test*> &tests = suite->getTests();\n    std::vector<CppUnit::Test*>::const_iterator it;\n    for( it = tests.begin(); it != tests.end(); ++it )\n      if( (*it)->getName() == elements[i] )\n       next = *it;\n    if( !next )\n      return 0;\n    ret = next;\n  }\n\n  return ret;\n}\n\n//------------------------------------------------------------------------------\n// Start the show\n//------------------------------------------------------------------------------\nint main( int argc, char **argv)\n{\n  //----------------------------------------------------------------------------\n  // Load the test library\n  //----------------------------------------------------------------------------\n  if( argc < 2 )\n  {\n    std::cerr << \"Usage: \" << argv[0] << \" libname.so testname\" << std::endl;\n    return 1;\n  }\n  void *libHandle = dlopen( argv[1], RTLD_LAZY );\n  if( libHandle == 0 )\n  {\n    std::cerr << \"Unable to load the test library: \" << dlerror() << std::endl;\n    return 1;\n  }\n\n  //----------------------------------------------------------------------------\n  // Print help\n  //----------------------------------------------------------------------------\n  CppUnit::Test *all = CppUnit::TestFactoryRegistry::getRegistry().makeTest();\n  if( argc == 2 )\n  {\n    std::cerr << \"Select your tests:\" << std::endl << std::endl;\n    printTests( all );\n    std::cerr << std::endl;\n    return 1;\n  }\n\n  //----------------------------------------------------------------------------\n  // Build the test suite\n  //----------------------------------------------------------------------------\n  CppUnit::TestSuite *selected = new CppUnit::TestSuite( \"Selected tests\" );\n  for( int i = 2; i < argc; ++i )\n  {\n    CppUnit::Test *t = findTest( all, std::string( argv[i]) );\n    if( !t )\n    {\n      std::cerr << \"Unable to find: \" << argv[i] << std::endl;\n      return 2;\n    }\n    selected->addTest( t );\n  }\n\n  std::cerr << \"You have selected: \" << std::endl << std::endl;\n  printTests( selected );\n  std::cerr << std::endl;\n\n  //----------------------------------------------------------------------------\n  // Run the tests\n  //----------------------------------------------------------------------------\n  std::cerr << \"Running:\" << std::endl << std::endl;\n  CppUnit::TextUi::TestRunner runner;\n  runner.addTest( selected );\n\n  runner.setOutputter(\n    new CppUnit::CompilerOutputter( &runner.result(), std::cerr ) );\n\n  bool wasSuccessful = runner.run();\n  dlclose( libHandle );\n  return wasSuccessful ? 0 : 1;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-xrootd-4.8.4-t4rp3o5embz66ngclf6u6noewe4srpjk/spack-src/tests/XrdClTests/MonitorTestLib.cc": "//------------------------------------------------------------------------------\n// Copyright (c) 2012 by European Organization for Nuclear Research (CERN)\n// Author: Lukasz Janyst <ljanyst@cern.ch>\n//------------------------------------------------------------------------------\n// XRootD is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// XRootD is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with XRootD.  If not, see <http://www.gnu.org/licenses/>.\n//------------------------------------------------------------------------------\n\n#include \"XrdCl/XrdClMonitor.hh\"\n#include \"XrdCl/XrdClLog.hh\"\n#include \"XrdCl/XrdClUtils.hh\"\n#include \"XrdVersion.hh\"\n\n#include \"TestEnv.hh\"\n\nXrdVERSIONINFO( XrdClGetMonitor, MonitorTest );\n\nclass MonitorTest: public XrdCl::Monitor\n{\n  public:\n    //--------------------------------------------------------------------------\n    // Contructor\n    //--------------------------------------------------------------------------\n    MonitorTest( const std::string &exec, const std::string &param ):\n      pExec( exec ),\n      pParam( param ),\n      pInitialized(false)\n    {\n      XrdCl::Log *log = XrdClTests::TestEnv::GetLog();\n      log->Debug( 2, \"Constructed monitoring, exec %s, param %s\",\n                      exec.c_str(), param.c_str() );\n    }\n\n    //--------------------------------------------------------------------------\n    // Destructor\n    //--------------------------------------------------------------------------\n    virtual ~MonitorTest() {}\n\n    //--------------------------------------------------------------------------\n    // Event\n    //--------------------------------------------------------------------------\n    virtual void Event( EventCode evCode, void *evData )\n    {\n      using namespace XrdCl;\n      using namespace XrdClTests;\n\n      Log *log = TestEnv::GetLog();\n      switch( evCode )\n      {\n        //----------------------------------------------------------------------\n        // Got a connect event\n        //----------------------------------------------------------------------\n        case EvConnect:\n        {\n          ConnectInfo *i = (ConnectInfo*)evData;\n          std::string timeStarted = Utils::TimeToString( i->sTOD.tv_sec );\n          std::string timeDone    = Utils::TimeToString( i->sTOD.tv_sec );\n          log->Debug( 2, \"Successfully connected to: %s, started: %s, \"\n                      \"finished: %s, authentication: %s, streams: %d\",\n                      i->server.c_str(), timeStarted.c_str(), timeDone.c_str(),\n                      i->auth.empty() ? \"none\" : i->auth.c_str(),\n                      i->streams );\n          break;\n        }\n\n        //----------------------------------------------------------------------\n        // Got a disconnect event\n        //----------------------------------------------------------------------\n        case EvDisconnect:\n        {\n          DisconnectInfo *i = (DisconnectInfo*)evData;\n          log->Debug( 2, \"Disconnected from: %s, bytes sent: %ld, \"\n                      \"bytes received: %ld, connection time: %d, \"\n                      \"disconnection status: %s\",\n                      i->server.c_str(), i->sBytes, i->rBytes,\n                      i->cTime, i->status.ToString().c_str() );\n          break;\n        }\n\n        //----------------------------------------------------------------------\n        // Got an open event\n        //----------------------------------------------------------------------\n        case EvOpen:\n        {\n          OpenInfo *i = (OpenInfo*)evData;\n          log->Debug( 2, \"Successfully opened file %s at %s, size %ld\",\n                      i->file->GetURL().c_str(), i->dataServer.c_str(),\n                      i->fSize );\n          break;\n        }\n\n        //----------------------------------------------------------------------\n        // Got a close event\n        //----------------------------------------------------------------------\n        case EvClose:\n        {\n          CloseInfo *i = (CloseInfo*)evData;\n          std::string timeOpen   = Utils::TimeToString( i->oTOD.tv_sec );\n          std::string timeClosed = Utils::TimeToString( i->cTOD.tv_sec );\n          log->Debug( 2, \"Closed file %s, opened: %s, closed: %s, status: %s\",\n                      i->file->GetURL().c_str(), timeOpen.c_str(),\n                      timeClosed.c_str(), i->status->ToStr().c_str() );\n          log->Debug( 2, \"Closed file %s, bytes: read: %ld, readv: %ld, write:\"\n                      \" %ld\", i->file->GetURL().c_str(), i->rBytes, i->vBytes,\n                      i->wBytes );\n          log->Debug( 2, \"Closed file %s, count: read: %d, readv: %d/%d, \"\n                      \"write: %d\", i->file->GetURL().c_str(), i->rCount,\n                      i->vCount, i->vSegs, i->wCount );\n\n          break;\n        }\n\n        //----------------------------------------------------------------------\n        // Got an error event\n        //----------------------------------------------------------------------\n        case EvErrIO:\n        {\n          ErrorInfo *i = (ErrorInfo*)evData;\n          std::string op;\n          switch( i->opCode )\n          {\n            case ErrorInfo::ErrOpen:  op = \"Open\"; break;\n            case ErrorInfo::ErrRead:  op = \"Read\"; break;\n            case ErrorInfo::ErrReadV: op = \"ReadV\"; break;\n            case ErrorInfo::ErrWrite: op = \"Write\"; break;\n            case ErrorInfo::ErrUnc:   op = \"Unclassified\"; break;\n          };\n          log->Debug( 2, \"Operation on file %s encountered an error: %s \"\n                      \"while %s\", i->file->GetURL().c_str(),\n                      i->status->ToStr().c_str(), op.c_str() );\n          break;\n        }\n\n        //----------------------------------------------------------------------\n        // Got a copy begin event\n        //----------------------------------------------------------------------\n        case EvCopyBeg:\n        {\n          CopyBInfo *i = (CopyBInfo*)evData;\n          log->Debug( 2, \"Copy operation started: origin %s, target: %s \",\n                      i->transfer.origin->GetURL().c_str(),\n                      i->transfer.target->GetURL().c_str() );\n          break;\n        }\n\n        //----------------------------------------------------------------------\n        // Got a copy end event\n        //----------------------------------------------------------------------\n        case EvCopyEnd:\n        {\n          CopyEInfo *i = (CopyEInfo*)evData;\n          std::string timeStart = Utils::TimeToString( i->bTOD.tv_sec );\n          std::string timeEnd   = Utils::TimeToString( i->eTOD.tv_sec );\n          log->Debug( 2, \"Copy operation ended: origin: %s, target: %s, \"\n                      \"start time %s, end time: %s, status: %s\",\n                      i->transfer.origin->GetURL().c_str(),\n                      i->transfer.target->GetURL().c_str(),\n                      timeStart.c_str(), timeEnd.c_str(),\n                      i->status->ToStr().c_str() );\n          break;\n        }\n\n        //----------------------------------------------------------------------\n        // Got a copy end event\n        //----------------------------------------------------------------------\n        case EvCheckSum:\n        {\n          CheckSumInfo *i = (CheckSumInfo*)evData;\n          log->Debug( 2, \"Checksum for transfer: origin: %s, target: %s, \"\n                      \"checksum %s, is ok: %d\",\n                      i->transfer.origin->GetURL().c_str(),\n                      i->transfer.target->GetURL().c_str(),\n                      i->cksum.c_str(), (int)i->isOK );\n          log->Debug( 2, \"Checksum for transfer: origin: %s, target: %s, \"\n                      \"us elapsed at origin %ld, us leapsed at target: %ld\",\n                      i->transfer.origin->GetURL().c_str(),\n                      i->transfer.target->GetURL().c_str(),\n                      i->oTime, i->tTime );\n          break;\n        }\n      }\n    }\n\n  private:\n    std::string pExec;\n    std::string pParam;\n    bool        pInitialized;\n};\n\n//------------------------------------------------------------------------------\n// C-mangled symbol for dlopen\n//------------------------------------------------------------------------------\nextern \"C\"\n{\n  void *XrdClGetMonitor( const char *exec, const char *param )\n  {\n    XrdCl::Log *log = XrdClTests::TestEnv::GetLog();\n    log->Debug( 2, \"Constructing monitoring, exec %s, param %s\",\n                exec, param ? param : \"\" );\n    return new MonitorTest( exec, param ? param : \"\" );\n  }\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-xrootd-4.8.4-t4rp3o5embz66ngclf6u6noewe4srpjk/spack-src/src/XrdHttp/static/favicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-xrootd-4.8.4-t4rp3o5embz66ngclf6u6noewe4srpjk/spack-src/bindings/python/docs/source/.static/img/favicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-xrootd-4.8.4-t4rp3o5embz66ngclf6u6noewe4srpjk/spack-src/bindings/python/docs/source/.static/img/xrootd-200x68.png"
    ],
    "total_files": 1257
}