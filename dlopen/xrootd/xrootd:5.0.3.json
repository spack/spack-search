{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-xrootd-5.0.3-e62u7xynbx5qgsdavddvqlcwenldzuh5/spack-src/src/XrdSys/XrdSysPlugin.cc": "/******************************************************************************/\n/*                                                                            */\n/*                       X r d S y s P l u g i n . c c                        */\n/*                                                                            */\n/* (c) 2005 by the Board of Trustees of the Leland Stanford, Jr., University  */\n/*                            All Rights Reserved                             */\n/*   Produced by Andrew Hanushevsky for Stanford University under contract    */\n/*              DE-AC02-76-SFO0515 with the Department of Energy              */\n/*                                                                            */\n/* This file is part of the XRootD software suite.                            */\n/*                                                                            */\n/* XRootD is free software: you can redistribute it and/or modify it under    */\n/* the terms of the GNU Lesser General Public License as published by the     */\n/* Free Software Foundation, either version 3 of the License, or (at your     */\n/* option) any later version.                                                 */\n/*                                                                            */\n/* XRootD is distributed in the hope that it will be useful, but WITHOUT      */\n/* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or      */\n/* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public       */\n/* License for more details.                                                  */\n/*                                                                            */\n/* You should have received a copy of the GNU Lesser General Public License   */\n/* along with XRootD in a file called COPYING.LESSER (LGPL license) and file  */\n/* COPYING (GPL license).  If not, see <http://www.gnu.org/licenses/>.        */\n/*                                                                            */\n/* The copyright holder's institutional names and contributor's names may not */\n/* be used to endorse or promote products derived from this software without  */\n/* specific prior written permission of the institution or contributor.       */\n/******************************************************************************/\n\n// Bypass Solaris ELF madness\n//\n#ifdef __solaris__\n#include <sys/isa_defs.h>\n#if defined(_ILP32) && (_FILE_OFFSET_BITS != 32)\n#undef  _FILE_OFFSET_BITS\n#define _FILE_OFFSET_BITS 32\n#undef  _LARGEFILE_SOURCE\n#endif\n#endif\n\n#ifndef WIN32\n#include <dlfcn.h>\n#if !defined(__APPLE__) && !defined(__CYGWIN__)\n#include <link.h>\n#endif\n#include <stdio.h>\n#include <strings.h>\n#include <sys/types.h>\n#include <errno.h>\n#else\n#include \"XrdSys/XrdWin32.hh\"\n#endif\n  \n#include \"XrdSys/XrdSysError.hh\"\n#include \"XrdSys/XrdSysHeaders.hh\"\n#include \"XrdSys/XrdSysPlatform.hh\"\n#include \"XrdSys/XrdSysPlugin.hh\"\n#include \"XrdVersion.hh\"\n#include \"XrdVersionPlugin.hh\"\n \n/******************************************************************************/\n/*                        S t a t i c   M e m b e r s                         */\n/******************************************************************************/\n\nstruct XrdSysPlugin::PLlist *XrdSysPlugin::plList = 0;\n\n/******************************************************************************/\n/*                            D e s t r u c t o r                             */\n/******************************************************************************/\n  \nXrdSysPlugin::~XrdSysPlugin()\n{\n   if (libHandle) dlclose(libHandle);\n   if (libPath)   free(libPath);\n}\n\n/******************************************************************************/\n/* Private:                   b a d V e r s i o n                             */\n/******************************************************************************/\n  \nXrdSysPlugin::cvResult XrdSysPlugin::badVersion(XrdVersionInfo &urInfo,\n                                                char mmv, int majv, int minv)\n{\n   const char *path;\n   char buff1[512], buff2[128];\n\n   if (minv > 99) minv = 99;\n   snprintf(buff1, sizeof(buff1), \"version %s is incompatible with %s \"\n                                  \"(must be %c= %d.%d.x)\",\n                                   myInfo->vStr, urInfo.vStr, mmv, majv, minv);\n\n   path = msgSuffix(\" in \", buff2, sizeof(buff2));\n\n   Inform(buff1, buff2, path, 0, 0, 1);\n\n   return cvBad;\n}\n  \n/******************************************************************************/\n/* Private:                   c h k V e r s i o n                             */\n/******************************************************************************/\n  \nXrdSysPlugin::cvResult XrdSysPlugin::chkVersion(XrdVersionInfo &urInfo,\n                                                const char     *pname,\n                                                void           *lHandle)\n{\n   static XrdVersionPlugin vInfo[] = {XrdVERSIONPLUGINRULES};\n   static XrdVersionPlugin vNote[] = {XrdVERSIONPLUGINMAXIMS};\n   XrdVersionPlugin *vinP;\n   char buff[1024], vName[256];\n   void *vP;\n   int  i, n=0, pMajor, vMajor, pMinor, vMinor;\n\n// If no version information supplied, skip version check\n//\n   if (!myInfo) return cvNone;\n\n// Check if we need to check the version here\n//\n   i = 0;\n   while(vInfo[i].pName && strcmp(vInfo[i].pName, pname)) i++;\n\n// If we didn't find it in the rules table then try to match the maxims\n//\n   if (!vInfo[i].pName)\n      {i = 0; n = strlen(pname);\n       while(vNote[i].pName)\n            {if ((vNote[i].vPfxLen + vNote[i].vSfxLen <= n)\n             &&  !strncmp(vNote[i].pName, pname, vNote[i].vPfxLen)\n             &&  !strncmp(vNote[i].pName+vNote[i].vPfxLen,\n                   pname + n - vNote[i].vSfxLen, vNote[i].vSfxLen)) break;\n             i++;\n            }\n             vinP = &vNote[i];\n      } else vinP = &vInfo[i];\n\n   if (!(vinP->pName)) return cvNone;\n   if ( vinP->vProcess == XrdVERSIONPLUGIN_DoNotChk) return cvDirty;\n\n// Construct the version entry point\n//\n   if (!n) n = strlen(pname);\n   if (n+sizeof(XrdVERSIONINFOSFX) > sizeof(vName))\n      return libMsg(\"Unable to generate version name for\", \"%s in \", pname);\n   strcpy(vName, pname); strcpy(vName+n, XrdVERSIONINFOSFX);\n\n// Find the version number\n//\n   if (!(vP = dlsym(lHandle, vName)))\n      {if (vinP->vProcess != XrdVERSIONPLUGIN_Required) return cvMissing;\n       return libMsg(dlerror(),\" required version information for %s in \",pname);\n      }\n\n// Extract the version number from the plugin and do a quick check. We use\n// memcpy to avoid instances where the symbol is wrongly defined. Make sure\n// the version string ends with a null by copying one less byte than need be.\n// The caller provided a struct that is gauranteed to end with nulls.\n//\n   memcpy(static_cast<void*>( &urInfo ), vP, sizeof(XrdVersionInfo)-1);\n\n// If version numbers are identical then we are done\n//\n   if (myInfo->vNum == urInfo.vNum)\n      if (myInfo->vNum != XrdVNUMUNK\n      ||  !strcmp(myInfo->vStr + (myInfo->vOpt & 0x0f)+1,\n                  urInfo. vStr + (urInfo. vOpt & 0x0f)+1)) return cvClean;\n\n// If the caller or plugin is unreleased, just issue a warning.\n//\n   if (myInfo->vNum == XrdVNUMUNK || urInfo.vNum == XrdVNUMUNK)\n      {if (eDest)\n          {char mBuff[128];\n           snprintf(buff, sizeof(buff), \"%s%s is using %s%s version\",\n                   (myInfo->vNum == XrdVNUMUNK ? \"unreleased \":\"\"),myInfo->vStr,\n                   (urInfo.vNum  == XrdVNUMUNK ? \"unreleased \":\"\"),urInfo.vStr);\n           msgSuffix(\" in \", mBuff, sizeof(mBuff));\n           Inform(buff, mBuff, libPath);\n          }\n       return cvDirty;\n      }\n\n// Extract version numbers\n//\n   vMajor = XrdMajorVNUM(myInfo->vNum);\n   vMinor = XrdMinorVNUM(myInfo->vNum);\n   pMajor = XrdMajorVNUM(urInfo. vNum);\n   pMinor = XrdMinorVNUM(urInfo. vNum);\n\n// The major version must always be compatible\n//\n   if ((vinP->vMajLow >= 0 && pMajor <  vinP->vMajLow)\n   ||  (vinP->vMajLow <  0 && pMajor != vMajor))\n      return badVersion(urInfo, '>', vinP->vMajLow, vinP->vMinLow);\n\n// The major version may not be greater than our versin\n//\n   if (pMajor > vMajor) return badVersion(urInfo, '<', vMajor, vMinor);\n\n// If we do not need to check minor versions then we are done\n//\n   if (vinP->vMinLow > 99) return cvClean;\n\n// In no case can the plug-in mnor version be greater than our version\n//\n   if (pMajor == vMajor && pMinor > vMinor)\n      return badVersion(urInfo, '<', vMajor, vMinor);\n\n// Verify compatible minor versions\n//\n   if ((vinP->vMinLow >= 0 && pMinor >= vinP->vMinLow)\n   ||  (vinP->vMinLow <  0 && pMinor == vMinor)) return cvClean;\n\n// Incompatible versions\n//\n   return badVersion(urInfo, '>', vinP->vMajLow, vinP->vMinLow);\n}\n\n/******************************************************************************/\n/* Private:                      D L F l a g s                                */\n/******************************************************************************/\n  \nint XrdSysPlugin::DLflags()\n{\n#if    defined(__APPLE__)\n       return RTLD_FIRST;\n#elif  defined(__linux__)\n       return RTLD_NOW;\n#else\n       return RTLD_NOW;\n#endif\n}\n\n/******************************************************************************/\n/* Private:                         F i n d                                   */\n/******************************************************************************/\n  \nvoid *XrdSysPlugin::Find(const char *libpath)\n{\n   struct PLlist *plP = plList;\n\n// Find the library in the preload list\n//\n   while(plP && strcmp(libpath, plP->libPath)) plP = plP->next;\n\n// Return result\n//\n  return (plP ? plP->libHandle : 0);\n}\n\n/******************************************************************************/\n/*                            g e t L i b r a r y                             */\n/******************************************************************************/\n  \nvoid *XrdSysPlugin::getLibrary(bool allMsgs, bool global)\n{\n   void *myHandle;\n   int   flags;\n\n// Check if we should use the preload list\n//\n   if (!(myHandle = libHandle) && plList) myHandle = Find(libPath);\n\n// If already open, return the handle\n//\n   if (myHandle) return myHandle;\n\n// If no path is given then we want to just search the executable. This is easy\n// for some platforms and more difficult for others. So, we do the best we can.\n//\n   if (libPath) flags = DLflags();\n      else {    flags = RTLD_NOW;\n#ifndef WIN32\n                flags|= global ? RTLD_GLOBAL : RTLD_LOCAL;\n#else\n            if (global && eDest) eDest->Emsg(\"getPlugin\",\n               \"request for global symbols unsupported under Windows - ignored\");\n#endif\n      }\n\n// Try to open this library or the executable image\n//\n   if ((myHandle = dlopen(libPath, flags))) libHandle = myHandle;\n      else {const char *eTxt = dlerror();\n            if (strcasestr(eTxt, \"no such file\")) errno = ENOENT;\n               else errno = ENOEXEC;\n            if (allMsgs || errno != ENOENT) libMsg(eTxt, \" loading \");\n           }\n\n// All done\n//\n   return myHandle;\n}\n\n/******************************************************************************/\n/*                             g e t P l u g i n                              */\n/******************************************************************************/\n\nvoid *XrdSysPlugin::getPlugin(const char *pname, int optional)\n{\n   return getPlugin(pname, optional, false);\n}\n\nvoid *XrdSysPlugin::getPlugin(const char *pname, int optional, bool global)\n{\n   XrdVERSIONINFODEF(urInfo, unknown, XrdVNUMUNK, \"\");\n   void *ep, *myHandle;\n   cvResult cvRC;\n\n// Open whatever it is we need to open\n//\n   if (!(myHandle = getLibrary(optional < 2, global))) return 0;\n\n// Get the symbol. In the environment we have defined, null values are not\n// allowed and we will issue an error.\n//\n   if (!(ep = dlsym(myHandle, pname)))\n      {if (optional < 2) libMsg(dlerror(), \" symbol %s in \", pname);\n       return 0;\n      }\n\n// Check if we need to verify version compatability\n//\n   if ((cvRC = chkVersion(urInfo, pname, myHandle)) == cvBad) return 0;\n\n// Print the loaded version unless message is suppressed or not needed\n//\n   if (libPath && optional < 2 && msgCnt\n   &&  (cvRC == cvClean || cvRC == cvMissing))\n      {char buff[128];\n       msgSuffix(\" from \", buff, sizeof(buff));\n       msgCnt--;\n            if (cvRC == cvClean)\n               {const char *wTxt=(urInfo.vNum == XrdVNUMUNK ? \"unreleased \":0);\n                Inform(\"loaded \", wTxt, urInfo.vStr, buff, libPath);\n               }\n       else if (cvRC == cvMissing)\n               {Inform(\"loaded unversioned \", pname, buff, libPath);}\n      }\n\n// All done\n//\n   return ep;\n}\n\n/******************************************************************************/\n/* Private:                       I n f o r m                                 */\n/******************************************************************************/\n\nvoid XrdSysPlugin::Inform(const char *txt1, const char *txt2, const char *txt3,\n                          const char *txt4, const char *txt5, int noHush)\n{\n   const char *eTxt[] = {\"Plugin \",txt1, txt2, txt3, txt4, txt5, 0};\n   char *bP;\n   int n, i, bL;\n\n// Check if we should hush this messages (largely for client-side usage)\n//\n   if (!noHush && getenv(\"XRDPIHUSH\")) return;\n\n// If we have a messaging object, use that\n//\n   if (eDest)\n      {char buff[2048];\n       i = 1; bP = buff; bL = sizeof(buff);\n       while(bL > 1 && eTxt[i])\n            {n = snprintf(bP, bL, \"%s\", eTxt[i]);\n             bP += n; bL -= n; i++;\n            }\n       eDest->Say(\"Plugin \", buff);\n       return;\n      }\n\n// If we have a buffer, set message in the buffer\n//\n   if ((bP = eBuff))\n      {i = 0; bL = eBLen;\n       while(bL > 1 && eTxt[i])\n            {n = snprintf(bP, bL, \"%s\", eTxt[i]);\n             bP += n; bL -= n; i++;\n            }\n      }\n}\n  \n/******************************************************************************/\n/* Private:                       l i b M s g                                 */\n/******************************************************************************/\n  \nXrdSysPlugin::cvResult XrdSysPlugin::libMsg(const char *txt1, const char *txt2,\n                                            const char *mSym)\n{\n   static const char fndg[] = \"Finding\";\n   static const int  flen   = sizeof(\"Finding\");\n   const char *path;\n   char mBuff[512], nBuff[512];\n\n// Check if this is a lookup or open issue. Trim message for the common case.\n//\n        if (mSym)\n           {if (!txt1 || strstr(txt1, \"undefined\"))\n               {txt1 = \"Unable to find\";\n                snprintf(nBuff, sizeof(nBuff), txt2, mSym);\n               } else {\n                strcpy(nBuff, fndg);\n                snprintf(nBuff+flen-1,sizeof(nBuff)-flen,txt2,mSym);\n               }\n            txt2 = nBuff;\n           }\n   else if (!txt1) txt1 = \"Unknown system error!\";\n   else if (strstr(txt1, \"No such file\")) txt1 = \"No such file or directory\";\n   else txt2 = \" \";\n\n// Spit out the message\n//\n   path = msgSuffix(txt2, mBuff, sizeof(mBuff));\n   Inform(txt1, mBuff, path, 0, 0, 1);\n   return cvBad;\n}\n\n/******************************************************************************/\n/* Private:                    m s g S u f f i x                              */\n/******************************************************************************/\n\nconst char *XrdSysPlugin::msgSuffix(const char *Word, char *buff, int bsz)\n{\n   if (libPath) snprintf(buff, bsz,\"%s%s \", Word, libName);\n      else      snprintf(buff, bsz,\"%sexecutable image\", Word);\n   return (libPath ? libPath : \"\");\n}\n  \n/******************************************************************************/\n/*                               P r e l o a d                                */\n/******************************************************************************/\n  \nbool XrdSysPlugin::Preload(const char *path,  char *ebuff, int eblen)\n{\n   struct PLlist *plP;\n   void *myHandle;\n\n// First see if this is already in the preload list\n//\n   if (Find(path)) return true;\n\n// Try to open the library\n//\n   if (!(myHandle = dlopen(path, DLflags())))\n      {if (ebuff && eblen > 0)\n          {const char *dlMsg = dlerror();\n           snprintf(ebuff, eblen, \"Plugin unable to load %s; %s\", path,\n                                  (dlMsg ? dlMsg : \"unknown system error\"));\n          }\n       return false;\n      }\n\n// Add the library handle\n//\n   plP = new PLlist;\n   plP->libHandle = myHandle;\n   plP->libPath   = strdup(path);\n   plP->next      = plList;\n   plList         = plP;\n\n// All done\n//\n   return true;\n}\n\n/******************************************************************************/\n/*                                V e r C m p                                 */\n/******************************************************************************/\n  \nbool XrdSysPlugin::VerCmp(XrdVersionInfo &vInfo1,\n                          XrdVersionInfo &vInfo2, bool noMsg)\n{\n   const char *mTxt;\n   char v1buff[128], v2buff[128];\n   int unRel;\n\n// Do a quick return if the version need not be checked or are equal\n//\n   if (vInfo1.vNum <= 0 || vInfo1.vNum == vInfo2.vNum) return true;\n\n// As it works out, many times two modules wind up in different shared\n// libraries. For consistency we require that both major.minor version be the\n// same unless either is unreleased (i.e. test). Issue warning if need be.\n//\n   mTxt = (vInfo1.vNum == XrdVNUMUNK ? \"unreleased \" : \"\");\n   sprintf(v1buff, \" %sversion %s\", mTxt, vInfo1.vStr);\n   unRel  = *mTxt;\n\n   mTxt = (vInfo2.vNum == XrdVNUMUNK ? \"unreleased \" : \"\");\n   sprintf(v2buff, \" %sversion %s\", mTxt, vInfo2.vStr);\n   unRel |= *mTxt;\n\n   if (unRel || vInfo1.vNum/100 == vInfo2.vNum/100) mTxt = \"\";\n      else mTxt = \" which is incompatible!\";\n\n   if (!noMsg)\n      cerr <<\"Plugin: \" <<v1buff <<\" is using \" <<v2buff <<mTxt <<endl;\n\n   return (*mTxt == 0);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-xrootd-5.0.3-e62u7xynbx5qgsdavddvqlcwenldzuh5/spack-src/src/XrdCl/XrdClDefaultEnv.cc": "//------------------------------------------------------------------------------\n// Copyright (c) 2011-2012 by European Organization for Nuclear Research (CERN)\n// Author: Lukasz Janyst <ljanyst@cern.ch>\n//------------------------------------------------------------------------------\n// XRootD is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// XRootD is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with XRootD.  If not, see <http://www.gnu.org/licenses/>.\n//------------------------------------------------------------------------------\n\n#include \"XrdCl/XrdClDefaultEnv.hh\"\n#include \"XrdCl/XrdClConstants.hh\"\n#include \"XrdCl/XrdClPostMaster.hh\"\n#include \"XrdCl/XrdClLog.hh\"\n#include \"XrdCl/XrdClForkHandler.hh\"\n#include \"XrdCl/XrdClFileTimer.hh\"\n#include \"XrdCl/XrdClUtils.hh\"\n#include \"XrdCl/XrdClMonitor.hh\"\n#include \"XrdCl/XrdClCheckSumManager.hh\"\n#include \"XrdCl/XrdClTransportManager.hh\"\n#include \"XrdCl/XrdClPlugInManager.hh\"\n#include \"XrdCl/XrdClOptimizers.hh\"\n#include \"XrdOuc/XrdOucPreload.hh\"\n#include \"XrdSys/XrdSysAtomics.hh\"\n#include \"XrdSys/XrdSysUtils.hh\"\n#include \"XrdSys/XrdSysPwd.hh\"\n#include \"XrdVersion.hh\"\n\n#include <libgen.h>\n#include <cstring>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <cctype>\n#include <string>\n#include <pthread.h>\n#include <sys/types.h>\n#include <unistd.h>\n\nXrdVERSIONINFO( XrdCl, client );\n\n//------------------------------------------------------------------------------\n// Forking functions\n//------------------------------------------------------------------------------\nextern \"C\"\n{\n  //----------------------------------------------------------------------------\n  // Prepare for the forking\n  //----------------------------------------------------------------------------\n  static void prepare()\n  {\n    using namespace XrdCl;\n    Log         *log         = DefaultEnv::GetLog();\n    Env         *env         = DefaultEnv::GetEnv();\n    ForkHandler *forkHandler = DefaultEnv::GetForkHandler();\n\n    log->Debug( UtilityMsg, \"In the prepare fork handler for process %d\",\n                getpid() );\n\n    //--------------------------------------------------------------------------\n    // Run the fork handler if it's enabled\n    //--------------------------------------------------------------------------\n    int runForkHandler = DefaultRunForkHandler;\n    env->GetInt( \"RunForkHandler\", runForkHandler );\n    if( runForkHandler )\n      forkHandler->Prepare();\n  }\n\n  //----------------------------------------------------------------------------\n  // Parent handler\n  //----------------------------------------------------------------------------\n  static void parent()\n  {\n    using namespace XrdCl;\n    Log         *log         = DefaultEnv::GetLog();\n    Env         *env         = DefaultEnv::GetEnv();\n    ForkHandler *forkHandler = DefaultEnv::GetForkHandler();\n\n    pid_t pid = getpid();\n    log->Debug( UtilityMsg, \"In the parent fork handler for process %d\", pid );\n\n    //--------------------------------------------------------------------------\n    // Run the fork handler if it's enabled\n    //--------------------------------------------------------------------------\n    int runForkHandler = DefaultRunForkHandler;\n    env->GetInt( \"RunForkHandler\", runForkHandler );\n    if( runForkHandler )\n    {\n      log->SetPid(pid);\n      forkHandler->Parent();\n    }\n  }\n\n  //----------------------------------------------------------------------------\n  // Child handler\n  //----------------------------------------------------------------------------\n  static void child()\n  {\n    using namespace XrdCl;\n    DefaultEnv::ReInitializeLogging();\n    Log         *log         = DefaultEnv::GetLog();\n    Env         *env         = DefaultEnv::GetEnv();\n    ForkHandler *forkHandler = DefaultEnv::GetForkHandler();\n    env->RecreateLock();\n\n    pid_t pid = getpid();\n    log->Debug( UtilityMsg, \"In the child fork handler for process %d\", pid );\n\n    //--------------------------------------------------------------------------\n    // Run the fork handler if it's enabled\n    //--------------------------------------------------------------------------\n    int runForkHandler = DefaultRunForkHandler;\n    env->GetInt( \"RunForkHandler\", runForkHandler );\n    if( runForkHandler )\n    {\n      log->SetPid(pid);\n      forkHandler->Child();\n    }\n  }\n}\n\nnamespace\n{\n  //----------------------------------------------------------------------------\n  // Translate a string into a topic mask\n  //----------------------------------------------------------------------------\n  struct MaskTranslator\n  {\n    //--------------------------------------------------------------------------\n    // Initialize the translation array\n    //--------------------------------------------------------------------------\n    MaskTranslator()\n    {\n      masks[\"AppMsg\"]             = XrdCl::AppMsg;\n      masks[\"UtilityMsg\"]         = XrdCl::UtilityMsg;\n      masks[\"FileMsg\"]            = XrdCl::FileMsg;\n      masks[\"PollerMsg\"]          = XrdCl::PollerMsg;\n      masks[\"PostMasterMsg\"]      = XrdCl::PostMasterMsg;\n      masks[\"XRootDTransportMsg\"] = XrdCl::XRootDTransportMsg;\n      masks[\"TaskMgrMsg\"]         = XrdCl::TaskMgrMsg;\n      masks[\"XRootDMsg\"]          = XrdCl::XRootDMsg;\n      masks[\"FileSystemMsg\"]      = XrdCl::FileSystemMsg;\n      masks[\"AsyncSockMsg\"]       = XrdCl::AsyncSockMsg;\n      masks[\"JobMgrMsg\"]          = XrdCl::JobMgrMsg;\n      masks[\"PlugInMgrMsg\"]       = XrdCl::PlugInMgrMsg;\n      masks[\"ExDbgMsg\"]           = XrdCl::ExDbgMsg;\n    }\n\n    //--------------------------------------------------------------------------\n    // Translate the mask\n    //--------------------------------------------------------------------------\n    uint64_t translateMask( const std::string mask )\n    {\n      if( mask == \"\" )\n        return 0xffffffffffffffffULL;\n\n      std::vector<std::string>           topics;\n      std::vector<std::string>::iterator it;\n      XrdCl::Utils::splitString( topics, mask, \"|\" );\n\n      uint64_t resultMask = 0;\n      std::map<std::string, uint64_t>::iterator maskIt;\n      for( it = topics.begin(); it != topics.end(); ++it )\n      {\n        //----------------------------------------------------------------------\n        // Check for resetting pseudo topics\n        //----------------------------------------------------------------------\n        if( *it == \"All\" )\n        {\n          resultMask = 0xffffffffffffffffULL;\n          continue;\n        }\n\n        if( *it == \"None\" )\n        {\n          resultMask = 0ULL;\n          continue;\n        }\n\n        //----------------------------------------------------------------------\n        // Check whether given topic should be disabled or enabled\n        //----------------------------------------------------------------------\n        std::string topic = *it;\n        bool disable      = false;\n        if( !topic.empty() && topic[0] == '^' )\n        {\n          disable = true;\n          topic   = topic.substr( 1, topic.length()-1 );\n        }\n\n        maskIt = masks.find( topic );\n        if( maskIt == masks.end() )\n          continue;\n\n        if( disable )\n          resultMask &= (0xffffffffffffffffULL ^ maskIt->second);\n        else\n          resultMask |= maskIt->second;\n      }\n\n      return resultMask;\n    }\n\n    std::map<std::string, uint64_t> masks;\n  };\n\n  //----------------------------------------------------------------------------\n  // Helper for handling environment variables\n  //----------------------------------------------------------------------------\n  template<typename Item>\n  struct EnvVarHolder\n  {\n    EnvVarHolder( const std::string &name_, const Item &def_ ):\n      name( name_ ), def( def_ ) {}\n    std::string name;\n    Item        def;\n  };\n}\n\n#define REGISTER_VAR_INT( array, name,  def ) \\\n    array.push_back( EnvVarHolder<int>( name, def ) )\n\n#define REGISTER_VAR_STR( array, name,  def ) \\\n    array.push_back( EnvVarHolder<std::string>( name, def ) )\n\nnamespace XrdCl\n{\n  //----------------------------------------------------------------------------\n  // Statics\n  //----------------------------------------------------------------------------\n  XrdSysMutex        DefaultEnv::sInitMutex;\n  Env               *DefaultEnv::sEnv                = 0;\n  PostMaster        *DefaultEnv::sPostMaster         = 0;\n  Log               *DefaultEnv::sLog                = 0;\n  ForkHandler       *DefaultEnv::sForkHandler        = 0;\n  FileTimer         *DefaultEnv::sFileTimer          = 0;\n  Monitor           *DefaultEnv::sMonitor            = 0;\n  XrdOucPinLoader   *DefaultEnv::sMonitorLibHandle   = 0;\n  bool               DefaultEnv::sMonitorInitialized = false;\n  CheckSumManager   *DefaultEnv::sCheckSumManager    = 0;\n  TransportManager  *DefaultEnv::sTransportManager   = 0;\n  PlugInManager     *DefaultEnv::sPlugInManager      = 0;\n\n  //----------------------------------------------------------------------------\n  // Constructor\n  //----------------------------------------------------------------------------\n  DefaultEnv::DefaultEnv()\n  {\n    Log *log = GetLog();\n\n    //--------------------------------------------------------------------------\n    // Declate the variables to be processed\n    //--------------------------------------------------------------------------\n    std::vector<EnvVarHolder<int> >         varsInt;\n    std::vector<EnvVarHolder<std::string> > varsStr;\n    REGISTER_VAR_INT( varsInt, \"ConnectionWindow\",        DefaultConnectionWindow        );\n    REGISTER_VAR_INT( varsInt, \"ConnectionRetry\",         DefaultConnectionRetry         );\n    REGISTER_VAR_INT( varsInt, \"RequestTimeout\",          DefaultRequestTimeout          );\n    REGISTER_VAR_INT( varsInt, \"StreamTimeout\",           DefaultStreamTimeout           );\n    REGISTER_VAR_INT( varsInt, \"SubStreamsPerChannel\",    DefaultSubStreamsPerChannel    );\n    REGISTER_VAR_INT( varsInt, \"TimeoutResolution\",       DefaultTimeoutResolution       );\n    REGISTER_VAR_INT( varsInt, \"StreamErrorWindow\",       DefaultStreamErrorWindow       );\n    REGISTER_VAR_INT( varsInt, \"RunForkHandler\",          DefaultRunForkHandler          );\n    REGISTER_VAR_INT( varsInt, \"RedirectLimit\",           DefaultRedirectLimit           );\n    REGISTER_VAR_INT( varsInt, \"WorkerThreads\",           DefaultWorkerThreads           );\n    REGISTER_VAR_INT( varsInt, \"CPChunkSize\",             DefaultCPChunkSize             );\n    REGISTER_VAR_INT( varsInt, \"CPParallelChunks\",        DefaultCPParallelChunks        );\n    REGISTER_VAR_INT( varsInt, \"DataServerTTL\",           DefaultDataServerTTL           );\n    REGISTER_VAR_INT( varsInt, \"LoadBalancerTTL\",         DefaultLoadBalancerTTL         );\n    REGISTER_VAR_INT( varsInt, \"CPInitTimeout\",           DefaultCPInitTimeout           );\n    REGISTER_VAR_INT( varsInt, \"CPTPCTimeout\",            DefaultCPTPCTimeout            );\n    REGISTER_VAR_INT( varsInt, \"TCPKeepAlive\",            DefaultTCPKeepAlive            );\n    REGISTER_VAR_INT( varsInt, \"TCPKeepAliveTime\",        DefaultTCPKeepAliveTime        );\n    REGISTER_VAR_INT( varsInt, \"TCPKeepAliveInterval\",    DefaultTCPKeepAliveInterval    );\n    REGISTER_VAR_INT( varsInt, \"TCPKeepProbes\",           DefaultTCPKeepAliveProbes      );\n    REGISTER_VAR_INT( varsInt, \"MultiProtocol\",           DefaultMultiProtocol           );\n    REGISTER_VAR_INT( varsInt, \"ParallelEvtLoop\",         DefaultParallelEvtLoop         );\n    REGISTER_VAR_INT( varsInt, \"MetalinkProcessing\",      DefaultMetalinkProcessing      );\n    REGISTER_VAR_INT( varsInt, \"LocalMetalinkFile\",       DefaultLocalMetalinkFile       );\n    REGISTER_VAR_INT( varsInt, \"XCpBlockSize\",            DefaultXCpBlockSize            );\n    REGISTER_VAR_INT( varsInt, \"NoDelay\",                 DefaultNoDelay                 );\n    REGISTER_VAR_INT( varsInt, \"AioSignal\",               DefaultAioSignal               );\n    REGISTER_VAR_INT( varsInt, \"PreferIPv4\",              DefaultPreferIPv4              );\n    REGISTER_VAR_INT( varsInt, \"MaxMetalinkWait\",         DefaultMaxMetalinkWait         );\n    REGISTER_VAR_INT( varsInt, \"PreserveLocateTried\",     DefaultPreserveLocateTried     );\n    REGISTER_VAR_INT( varsInt, \"NotAuthorizedRetryLimit\", DefaultNotAuthorizedRetryLimit );\n    REGISTER_VAR_INT( varsInt, \"PreserveXAttrs\",          DefaultPreserveXAttrs          );\n    REGISTER_VAR_INT( varsInt, \"NoTlsOK\",                 DefaultNoTlsOK                 );\n    REGISTER_VAR_INT( varsInt, \"TlsNoData\",               DefaultTlsNoData               );\n    REGISTER_VAR_INT( varsInt, \"TlsMetalink\",             DefaultTlsMetalink             );\n    REGISTER_VAR_INT( varsInt, \"ZipMtlnCksum\",            DefaultZipMtlnCksum            );\n\n    REGISTER_VAR_STR( varsStr, \"ClientMonitor\",           DefaultClientMonitor           );\n    REGISTER_VAR_STR( varsStr, \"ClientMonitorParam\",      DefaultClientMonitorParam      );\n    REGISTER_VAR_STR( varsStr, \"NetworkStack\",            DefaultNetworkStack            );\n    REGISTER_VAR_STR( varsStr, \"PlugIn\",                  DefaultPlugIn                  );\n    REGISTER_VAR_STR( varsStr, \"PlugInConfDir\",           DefaultPlugInConfDir           );\n    REGISTER_VAR_STR( varsStr, \"ReadRecovery\",            DefaultReadRecovery            );\n    REGISTER_VAR_STR( varsStr, \"WriteRecovery\",           DefaultWriteRecovery           );\n    REGISTER_VAR_STR( varsStr, \"OpenRecovery\",            DefaultOpenRecovery            );\n    REGISTER_VAR_STR( varsStr, \"GlfnRedirector\",          DefaultGlfnRedirector          );\n    REGISTER_VAR_STR( varsStr, \"TlsDbgLvl\",               DefaultTlsDbgLvl               );\n\n    //--------------------------------------------------------------------------\n    // Process the configuration files\n    //--------------------------------------------------------------------------\n    std::map<std::string, std::string> config, userConfig;\n    Status st = Utils::ProcessConfig( config, \"/etc/xrootd/client.conf\" );\n\n    if( !st.IsOK() )\n      log->Warning( UtilityMsg, \"Unable to process global config file: %s\",\n                    st.ToString().c_str() );\n\n    XrdSysPwd pwdHandler;\n    passwd *pwd = pwdHandler.Get( getuid() );\n    if( pwd )\n    {\n      std::string userConfigFile = pwd->pw_dir;\n      userConfigFile += \"/.xrootd/client.conf\";\n\n      st = Utils::ProcessConfig( userConfig, userConfigFile );\n\n      if( !st.IsOK() )\n        log->Debug( UtilityMsg, \"Unable to process user config file: %s\",\n                    st.ToString().c_str() );\n    }\n    else\n      log->Debug( UtilityMsg, \"Unable to find user home directory.\" );\n\n    std::map<std::string, std::string>::iterator it;\n\n    for( it = config.begin(); it != config.end(); ++it )\n      log->Dump( UtilityMsg, \"[Global config] \\\"%s\\\" = \\\"%s\\\"\",\n                 it->first.c_str(), it->second.c_str() );\n\n    for( it = userConfig.begin(); it != userConfig.end(); ++it )\n    {\n      config[it->first] = it->second;\n      log->Dump( UtilityMsg, \"[User config] \\\"%s\\\" = \\\"%s\\\"\",\n                 it->first.c_str(), it->second.c_str() );\n    }\n\n    for( it = config.begin(); it != config.end(); ++it )\n      log->Debug( UtilityMsg, \"[Effective config] \\\"%s\\\" = \\\"%s\\\"\",\n                  it->first.c_str(), it->second.c_str() );\n\n    //--------------------------------------------------------------------------\n    // Monitoring settings\n    //--------------------------------------------------------------------------\n    char *tmp = strdup( XrdSysUtils::ExecName() );\n    char *appName = basename( tmp );\n    PutString( \"AppName\", appName );\n    free( tmp );\n    ImportString( \"AppName\", \"XRD_APPNAME\" );\n    PutString( \"MonInfo\", \"\" );\n    ImportString( \"MonInfo\", \"XRD_MONINFO\" );\n\n    //--------------------------------------------------------------------------\n    // Process ints\n    //--------------------------------------------------------------------------\n    for( size_t i = 0; i < varsInt.size(); ++i )\n    {\n      PutInt( varsInt[i].name, varsInt[i].def );\n\n      it = config.find( varsInt[i].name );\n      if( it != config.end() )\n      {\n        char *endPtr = 0;\n        int value = (int)strtol( it->second.c_str(), &endPtr, 0 );\n        if( *endPtr )\n          log->Warning( UtilityMsg, \"Unable to set %s to %s: not a proper \"\n                        \"integer\", varsInt[i].name.c_str(),\n                        it->second.c_str() );\n        else\n          PutInt( varsInt[i].name, value );\n      }\n\n      std::string name = \"XRD_\" + varsInt[i].name;\n      std::transform( name.begin(), name.end(), name.begin(), ::toupper );\n      ImportInt( varsInt[i].name, name );\n    }\n\n    //--------------------------------------------------------------------------\n    // Process strings\n    //--------------------------------------------------------------------------\n    for( size_t i = 0; i < varsStr.size(); ++i )\n    {\n      PutString( varsStr[i].name, varsStr[i].def );\n\n      it = config.find( varsStr[i].name );\n      if( it != config.end() )\n        PutString( varsStr[i].name, it->second );\n\n      std::string name = \"XRD_\" + varsStr[i].name;\n      std::transform( name.begin(), name.end(), name.begin(), ::toupper );\n      ImportString( varsStr[i].name, name );\n    }\n\n    //--------------------------------------------------------------------------\n    // Register fork handlers\n    //--------------------------------------------------------------------------\n    pthread_atfork( prepare, parent, child );\n  }\n\n  //----------------------------------------------------------------------------\n  // Get default client environment\n  //----------------------------------------------------------------------------\n  Env *DefaultEnv::GetEnv()\n  {\n    return sEnv;\n  }\n\n  //----------------------------------------------------------------------------\n  // Get default post master\n  //----------------------------------------------------------------------------\n  PostMaster *DefaultEnv::GetPostMaster()\n  {\n    PostMaster* postMaster = AtomicGet(sPostMaster);\n\n    if( unlikely( !postMaster ) )\n    {\n      XrdSysMutexHelper scopedLock( sInitMutex );\n      postMaster = AtomicGet(sPostMaster);\n\n      if( postMaster )\n        return postMaster;\n\n      postMaster = new PostMaster();\n\n      if( !postMaster->Initialize() )\n      {\n        delete postMaster;\n        postMaster = 0;\n        return 0;\n      }\n\n      if( !postMaster->Start() )\n      {\n        postMaster->Finalize();\n        delete postMaster;\n        postMaster = 0;\n        return 0;\n      }\n\n      sForkHandler->RegisterPostMaster( postMaster );\n      postMaster->GetTaskManager()->RegisterTask( sFileTimer, time(0), false );\n      AtomicCAS(sPostMaster, sPostMaster, postMaster);\n    }\n\n    return postMaster;\n  }\n\n  //----------------------------------------------------------------------------\n  // Get log\n  //----------------------------------------------------------------------------\n  Log *DefaultEnv::GetLog()\n  {\n    return sLog;\n  }\n\n  //----------------------------------------------------------------------------\n  // Set log level\n  //----------------------------------------------------------------------------\n  void DefaultEnv::SetLogLevel( const std::string &level )\n  {\n    Log *log = GetLog();\n    log->SetLevel( level );\n  }\n\n  //----------------------------------------------------------------------------\n  // Set log file\n  //----------------------------------------------------------------------------\n  bool DefaultEnv::SetLogFile( const std::string &filepath )\n  {\n    Log *log = GetLog();\n    LogOutFile *out = new LogOutFile();\n\n    if( out->Open( filepath ) )\n    {\n      log->SetOutput( out );\n      return true;\n    }\n\n    delete out;\n    return false;\n  }\n\n  //----------------------------------------------------------------------------\n  //! Set log mask.\n  //------------------------------------------------------------------------\n  void DefaultEnv::SetLogMask( const std::string &level,\n                               const std::string &mask )\n  {\n    Log *log = GetLog();\n    MaskTranslator translator;\n    uint64_t topicMask = translator.translateMask( mask );\n\n    if( level == \"All\" )\n    {\n      log->SetMask( Log::ErrorMsg,   topicMask );\n      log->SetMask( Log::WarningMsg, topicMask );\n      log->SetMask( Log::InfoMsg,    topicMask );\n      log->SetMask( Log::DebugMsg,   topicMask );\n      log->SetMask( Log::DumpMsg,    topicMask );\n      return;\n    }\n\n    log->SetMask( level, topicMask );\n  }\n\n  //----------------------------------------------------------------------------\n  // Get fork handler\n  //----------------------------------------------------------------------------\n  ForkHandler *DefaultEnv::GetForkHandler()\n  {\n    return sForkHandler;\n  }\n\n  //----------------------------------------------------------------------------\n  // Get fork handler\n  //----------------------------------------------------------------------------\n  FileTimer *DefaultEnv::GetFileTimer()\n  {\n    return sFileTimer;\n  }\n\n  //----------------------------------------------------------------------------\n  // Get the monitor object\n  //----------------------------------------------------------------------------\n  Monitor *DefaultEnv::GetMonitor()\n  {\n    if( unlikely( !sMonitorInitialized ) )\n    {\n      XrdSysMutexHelper scopedLock( sInitMutex );\n      if( !sMonitorInitialized )\n      {\n        //----------------------------------------------------------------------\n        // Check the environment settings\n        //----------------------------------------------------------------------\n        Env *env = GetEnv();\n        Log *log = GetLog();\n        sMonitorInitialized = true;\n        std::string monitorLib = DefaultClientMonitor;\n        env->GetString( \"ClientMonitor\", monitorLib );\n        if( monitorLib.empty() )\n        {\n          log->Debug( UtilityMsg, \"Monitor library name not set. No \"\n                      \"monitoring\" );\n          return 0;\n        }\n\n        std::string monitorParam = DefaultClientMonitorParam;\n        env->GetString( \"ClientMonitorParam\", monitorParam );\n\n        log->Debug( UtilityMsg, \"Initializing monitoring, lib: %s, param: %s\",\n                    monitorLib.c_str(), monitorParam.c_str() );\n\n        //----------------------------------------------------------------------\n        // Loading the plugin\n        //----------------------------------------------------------------------\n        char *errBuffer = new char[4000];\n        sMonitorLibHandle = new XrdOucPinLoader(\n                                 errBuffer, 4000, &XrdVERSIONINFOVAR( XrdCl ),\n                                 \"monitor\", monitorLib.c_str() );\n\n        typedef XrdCl::Monitor *(*MonLoader)(const char *, const char *);\n        MonLoader loader;\n        loader = (MonLoader)sMonitorLibHandle->Resolve( \"XrdClGetMonitor\", -1 );\n        if( !loader )\n        {\n          log->Error( UtilityMsg, \"Unable to initialize user monitoring: %s\",\n                      errBuffer );\n          delete [] errBuffer;\n          sMonitorLibHandle->Unload();\n          delete sMonitorLibHandle; sMonitorLibHandle = 0;\n          return 0;\n        }\n\n        //----------------------------------------------------------------------\n        // Instantiating the monitor object\n        //----------------------------------------------------------------------\n        const char *param = monitorParam.empty() ? 0 : monitorParam.c_str();\n        sMonitor = (*loader)( XrdSysUtils::ExecName(), param );\n\n        if( !sMonitor )\n        {\n          log->Error( UtilityMsg, \"Unable to initialize user monitoring: %s\",\n                      errBuffer );\n          delete [] errBuffer;\n          sMonitorLibHandle->Unload();\n          delete sMonitorLibHandle; sMonitorLibHandle = 0;\n          return 0;\n        }\n        log->Debug( UtilityMsg, \"Successfully initialized monitoring from: %s\",\n                    monitorLib.c_str() );\n        delete [] errBuffer;\n      }\n    }\n    return sMonitor;\n  }\n\n  //----------------------------------------------------------------------------\n  // Get checksum manager\n  //----------------------------------------------------------------------------\n  CheckSumManager *DefaultEnv::GetCheckSumManager()\n  {\n    if( unlikely( !sCheckSumManager ) )\n    {\n      XrdSysMutexHelper scopedLock( sInitMutex );\n      if( !sCheckSumManager )\n        sCheckSumManager = new CheckSumManager();\n    }\n    return sCheckSumManager;\n  }\n\n  //----------------------------------------------------------------------------\n  // Get transport manager\n  //----------------------------------------------------------------------------\n  TransportManager *DefaultEnv::GetTransportManager()\n  {\n    if( unlikely( !sTransportManager ) )\n    {\n      XrdSysMutexHelper scopedLock( sInitMutex );\n      if( !sTransportManager )\n        sTransportManager = new TransportManager();\n    }\n    return sTransportManager;\n  }\n\n  //----------------------------------------------------------------------------\n  // Get plug-in manager\n  //----------------------------------------------------------------------------\n  PlugInManager *DefaultEnv::GetPlugInManager()\n  {\n    return sPlugInManager;\n  }\n\n  //----------------------------------------------------------------------------\n  // Retrieve the plug-in factory for the given URL\n  //----------------------------------------------------------------------------\n  PlugInFactory *DefaultEnv::GetPlugInFactory( const std::string url )\n  {\n    return  sPlugInManager->GetFactory( url );\n  }\n\n  //----------------------------------------------------------------------------\n  // Initialize the environment\n  //----------------------------------------------------------------------------\n  void DefaultEnv::Initialize()\n  {\n    sLog           = new Log();\n    SetUpLog();\n\n    sEnv           = new DefaultEnv();\n    sForkHandler   = new ForkHandler();\n    sFileTimer     = new FileTimer();\n    sPlugInManager = new PlugInManager();\n\n    sPlugInManager->ProcessEnvironmentSettings();\n    sForkHandler->RegisterFileTimer( sFileTimer );\n\n    //--------------------------------------------------------------------------\n    // MacOSX library loading is completely moronic. We cannot dlopen a library\n    // from a thread other than a main thread, so we-pre dlopen all the\n    // libraries that we may potentially want.\n    //--------------------------------------------------------------------------\n#ifdef __APPLE__\n    char *errBuff = new char[1024];\n\n    const char *libs[] =\n    {\n      \"libXrdSeckrb5.so\",\n      \"libXrdSecgsi.so\",\n      \"libXrdSecgsiAuthzVO.so\",\n      \"libXrdSecgsiGMAPDN.so\",\n      \"libXrdSecpwd.so\",\n      \"libXrdSecsss.so\",\n      \"libXrdSecunix.so\",\n      0\n    };\n\n    for( int i = 0; libs[i]; ++i )\n    {\n      sLog->Debug( UtilityMsg, \"Attempting to pre-load: %s\", libs[i] );\n      bool ok = XrdOucPreload( libs[i], errBuff, 1024 );\n      if( !ok )\n        sLog->Error( UtilityMsg, \"Unable to pre-load %s: %s\", libs[i], errBuff );\n    }\n    delete [] errBuff;\n#endif\n  }\n\n  //----------------------------------------------------------------------------\n  // Finalize the environment\n  //----------------------------------------------------------------------------\n  void DefaultEnv::Finalize()\n  {\n    if( sPostMaster )\n    {\n      sPostMaster->Stop();\n      sPostMaster->Finalize();\n      delete sPostMaster;\n      sPostMaster = 0;\n    }\n\n    delete sTransportManager;\n    sTransportManager = 0;\n\n    delete sCheckSumManager;\n    sCheckSumManager = 0;\n\n    delete sMonitor;\n    sMonitor = 0;\n\n    if( sMonitorLibHandle )\n      sMonitorLibHandle->Unload();\n\n    delete sMonitorLibHandle;\n    sMonitorLibHandle = 0;\n\n    delete sForkHandler;\n    sForkHandler = 0;\n\n    delete sFileTimer;\n    sFileTimer = 0;\n\n    delete sPlugInManager;\n    sPlugInManager = 0;\n\n    delete sEnv;\n    sEnv = 0;\n\n    delete sLog;\n    sLog = 0;\n  }\n\n  //----------------------------------------------------------------------------\n  // Re-initialize the logging\n  //----------------------------------------------------------------------------\n  void DefaultEnv::ReInitializeLogging()\n  {\n    delete sLog;\n    sLog = new Log();\n    SetUpLog();\n  }\n\n  //----------------------------------------------------------------------------\n  // Set up the log\n  //----------------------------------------------------------------------------\n  void DefaultEnv::SetUpLog()\n  {\n    Log *log = GetLog();\n\n    //--------------------------------------------------------------------------\n    // Check if the log level has been defined in the environment\n    //--------------------------------------------------------------------------\n    char *level = getenv( \"XRD_LOGLEVEL\" );\n    if( level )\n      log->SetLevel( level );\n\n    //--------------------------------------------------------------------------\n    // Check if we need to log to a file\n    //--------------------------------------------------------------------------\n    char *file = getenv( \"XRD_LOGFILE\" );\n    if( file )\n    {\n      LogOutFile *out = new LogOutFile();\n      if( out->Open( file ) )\n        log->SetOutput( out );\n      else\n        delete out;\n    }\n\n    //--------------------------------------------------------------------------\n    // Log mask defaults\n    //--------------------------------------------------------------------------\n    MaskTranslator translator;\n    log->SetMask( Log::DumpMsg, translator.translateMask( \"All|^PollerMsg\" ) );\n\n    //--------------------------------------------------------------------------\n    // Initialize the topic mask\n    //--------------------------------------------------------------------------\n    char *logMask = getenv( \"XRD_LOGMASK\" );\n    if( logMask )\n    {\n      uint64_t mask = translator.translateMask( logMask );\n      log->SetMask( Log::ErrorMsg,   mask );\n      log->SetMask( Log::WarningMsg, mask );\n      log->SetMask( Log::InfoMsg,    mask );\n      log->SetMask( Log::DebugMsg,   mask );\n      log->SetMask( Log::DumpMsg,    mask );\n    }\n\n    logMask = getenv( \"XRD_LOGMASK_ERROR\" );\n    if( logMask ) log->SetMask( Log::ErrorMsg, translator.translateMask( logMask ) );\n\n    logMask = getenv( \"XRD_LOGMASK_WARNING\" );\n    if( logMask ) log->SetMask( Log::WarningMsg, translator.translateMask( logMask ) );\n\n    logMask = getenv( \"XRD_LOGMASK_INFO\" );\n    if( logMask ) log->SetMask( Log::InfoMsg, translator.translateMask( logMask ) );\n\n    logMask = getenv( \"XRD_LOGMASK_DEBUG\" );\n    if( logMask ) log->SetMask( Log::DebugMsg, translator.translateMask( logMask ) );\n\n    logMask = getenv( \"XRD_LOGMASK_DUMP\" );\n    if( logMask ) log->SetMask( Log::DumpMsg, translator.translateMask( logMask ) );\n\n    //--------------------------------------------------------------------------\n    // Set up the topic strings\n    //--------------------------------------------------------------------------\n    log->SetTopicName( AppMsg,             \"App\" );\n    log->SetTopicName( UtilityMsg,         \"Utility\" );\n    log->SetTopicName( FileMsg,            \"File\" );\n    log->SetTopicName( PollerMsg,          \"Poller\" );\n    log->SetTopicName( PostMasterMsg,      \"PostMaster\" );\n    log->SetTopicName( XRootDTransportMsg, \"XRootDTransport\" );\n    log->SetTopicName( TaskMgrMsg,         \"TaskMgr\" );\n    log->SetTopicName( XRootDMsg,          \"XRootD\" );\n    log->SetTopicName( FileSystemMsg,      \"FileSystem\" );\n    log->SetTopicName( AsyncSockMsg,       \"AsyncSock\" );\n    log->SetTopicName( JobMgrMsg,          \"JobMgr\" );\n    log->SetTopicName( PlugInMgrMsg,       \"PlugInMgr\" );\n    log->SetTopicName( ExDbgMsg,           \"ExDbgMsg\" );\n    log->SetTopicName( TlsMsg,             \"TlsMsg\" );\n  }\n\n}\n\n//------------------------------------------------------------------------------\n// Static initialization and finalization\n//------------------------------------------------------------------------------\nint EnvInitializer::counter = 0;\n\n//------------------------------------------------------------------------------\n// The constructor will be invoked in every translation unit\n// that includes XrdClDefaultEnv.hh, but the DefaultEnv will\n// be initialized only in the first one\n//------------------------------------------------------------------------------\nEnvInitializer::EnvInitializer ()\n{\n  if( counter++ == 0 ) XrdCl::DefaultEnv::Initialize();\n}\n\n//------------------------------------------------------------------------------\n// The destructor will be invoked in every translation unit\n// that includes XrdClDefaultEnv.hh, but the DefaultEnv will\n// be finalized only once in the last one\n//------------------------------------------------------------------------------\nEnvInitializer::~EnvInitializer ()\n{\n  if( --counter == 0 ) XrdCl::DefaultEnv::Finalize();\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-xrootd-5.0.3-e62u7xynbx5qgsdavddvqlcwenldzuh5/spack-src/src/XrdMacaroons/XrdMacaroons.cc": "\n#include <stdexcept>\n#include <dlfcn.h>\n\n#include \"XrdMacaroonsHandler.hh\"\n#include \"XrdMacaroonsAuthz.hh\"\n\n#include \"XrdOuc/XrdOucEnv.hh\"\n#include \"XrdOuc/XrdOucString.hh\"\n#include \"XrdOuc/XrdOucPinPath.hh\"\n#include \"XrdOuc/XrdOucEnv.hh\"\n#include \"XrdSys/XrdSysError.hh\"\n#include \"XrdSys/XrdSysLogger.hh\"\n#include \"XrdHttp/XrdHttpExtHandler.hh\"\n#include \"XrdAcc/XrdAccAuthorize.hh\"\n#include \"XrdVersion.hh\"\n\nXrdVERSIONINFO(XrdAccAuthorizeObject, XrdMacaroons);\nXrdVERSIONINFO(XrdAccAuthorizeObjAdd, XrdMacaroons);\nXrdVERSIONINFO(XrdHttpGetExtHandler,  XrdMacaroons);\n\n// Trick to access compiled version and directly call for the default object\n// is taken from xrootd-scitokens.\nstatic XrdVERSIONINFODEF(compiledVer, XrdAccTest, XrdVNUMBER, XrdVERSION);\nextern XrdAccAuthorize *XrdAccDefaultAuthorizeObject(XrdSysLogger   *lp,\n                                                     const char     *cfn,\n                                                     const char     *parm,\n                                                     XrdVersionInfo &myVer);\n\n\nextern \"C\" {\n\nXrdAccAuthorize *XrdAccAuthorizeObjAdd(XrdSysLogger *log,\n                                       const char   *config,\n                                       const char   *params,\n                                       XrdOucEnv    * /*not used*/,\n                                       XrdAccAuthorize * chain_authz)\n{\n    try\n    {\n        return new Macaroons::Authz(log, config, chain_authz);\n    }\n    catch (std::runtime_error &e)\n    {\n        XrdSysError err(log, \"macaroons\");\n        err.Emsg(\"Config\", \"Configuration of Macaroon authorization handler failed\", e.what());\n        return NULL;\n    }\n}\n\nXrdAccAuthorize *XrdAccAuthorizeObject(XrdSysLogger *log,\n                                       const char   *config,\n                                       const char   *parms)\n{\n    XrdAccAuthorize *chain_authz;\n\n    if (parms && parms[0]) {\n        XrdOucString parms_str(parms);\n        XrdOucString chained_lib;\n        XrdSysError *err = new XrdSysError(log, \"authlib\");\n        int from = parms_str.tokenize(chained_lib, 0, ' ');\n        const char *chained_parms = NULL;\n        err->Emsg(\"Config\", \"Will chain library\", chained_lib.c_str());\n        if (from > 0)\n        {\n            parms_str.erasefromstart(from);\n            if (parms_str.length())\n            {\n                err->Emsg(\"Config\", \"Will chain parameters\", parms_str.c_str());\n                chained_parms = parms_str.c_str();\n            }\n        }\n        char resolvePath[2048];\n        bool usedAltPath{true};\n        if (!XrdOucPinPath(chained_lib.c_str(), usedAltPath, resolvePath, 2048)) {\n            err->Emsg(\"Config\", \"Failed to locate appropriately versioned chained auth library:\", parms);\n            delete err;\n            return NULL;\n        }\n        void *handle_base = dlopen(resolvePath, RTLD_LOCAL|RTLD_NOW);\n        if (handle_base == NULL) {\n            err->Emsg(\"Config\", \"Failed to base plugin \", resolvePath, dlerror());\n            delete err;\n            return NULL;\n        }\n\n        XrdAccAuthorize *(*ep)(XrdSysLogger *, const char *, const char *);\n        ep = (XrdAccAuthorize *(*)(XrdSysLogger *, const char *, const char *))\n             (dlsym(handle_base, \"XrdAccAuthorizeObject\"));\n        if (!ep)\n        {\n            err->Emsg(\"Config\", \"Unable to chain second authlib after macaroons\", parms);\n            delete err;\n            return NULL;\n        }\n        chain_authz = (*ep)(log, config, chained_parms);\n    }\n    else\n    {\n        chain_authz = XrdAccDefaultAuthorizeObject(log, config, parms, compiledVer);\n    }\n    try\n    {\n        return new Macaroons::Authz(log, config, chain_authz);\n    }\n    catch (std::runtime_error &e)\n    {\n        XrdSysError err(log, \"macaroons\");\n        err.Emsg(\"Config\", \"Configuration of Macaroon authorization handler failed\", e.what());\n        return NULL;\n    }\n}\n\n\nXrdHttpExtHandler *XrdHttpGetExtHandler(\n    XrdSysError *log, const char * config,\n    const char * parms, XrdOucEnv *env)\n{\n    void *authz_raw = env->GetPtr(\"XrdAccAuthorize*\");\n    XrdAccAuthorize *def_authz = static_cast<XrdAccAuthorize *>(authz_raw);\n\n    log->Emsg(\"Initialize\", \"Creating new Macaroon handler object\");\n    try\n    {\n        return new Macaroons::Handler(log, config, env, def_authz);\n    }\n    catch (std::runtime_error &e)\n    {\n        log->Emsg(\"Config\", \"Generation of Macaroon handler failed\", e.what());\n        return NULL;\n    }\n}\n\n\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-xrootd-5.0.3-e62u7xynbx5qgsdavddvqlcwenldzuh5/spack-src/tests/common/TextRunner.cc": "//------------------------------------------------------------------------------\n// Copyright (c) 2011-2012 by European Organization for Nuclear Research (CERN)\n// Author: Lukasz Janyst <ljanyst@cern.ch>\n//------------------------------------------------------------------------------\n// XRootD is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// XRootD is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with XRootD.  If not, see <http://www.gnu.org/licenses/>.\n//------------------------------------------------------------------------------\n\n#include <cppunit/CompilerOutputter.h>\n#include <cppunit/ui/text/TestRunner.h>\n#include <cppunit/extensions/HelperMacros.h>\n#include <dlfcn.h>\n#include \"PathProcessor.hh\"\n\n//------------------------------------------------------------------------------\n// Print all the tests present in the test suite\n//------------------------------------------------------------------------------\nvoid printTests( const CppUnit::Test *t, std::string prefix = \"\" )\n{\n  if( t == 0 )\n    return;\n\n  const CppUnit::TestSuite *suite = dynamic_cast<const CppUnit::TestSuite*>( t );\n  std::cerr << prefix << t->getName();\n  if( suite )\n  {\n    std::cerr << \"/\" << std::endl;\n    std::string prefix1 = \"  \"; prefix1 += prefix;\n    prefix1 += t->getName(); prefix1 += \"/\";\n    const std::vector<CppUnit::Test*> &tests = suite->getTests();\n    std::vector<CppUnit::Test*>::const_iterator it;\n    for( it = tests.begin(); it != tests.end(); ++it )\n      printTests( *it, prefix1 );\n  }\n  else\n    std::cerr << std::endl;\n}\n\n//------------------------------------------------------------------------------\n// Find a test\n//------------------------------------------------------------------------------\nCppUnit::Test *findTest( CppUnit::Test *t, const std::string &test )\n{\n  //----------------------------------------------------------------------------\n  // Check the suit and the path\n  //----------------------------------------------------------------------------\n  std::vector<std::string> elements;\n  eos::PathProcessor::splitPath( elements, test );\n\n  if( t == 0 )\n    return 0;\n\n  if( elements.empty() )\n    return 0;\n\n  if( t->getName() != elements[0] )\n    return 0;\n\n  //----------------------------------------------------------------------------\n  // Look for the requested test\n  //----------------------------------------------------------------------------\n  CppUnit::Test *ret = t;\n  for( size_t i = 1; i < elements.size(); ++i )\n  {\n    CppUnit::TestSuite *suite = dynamic_cast<CppUnit::TestSuite*>( ret );\n    CppUnit::Test      *next  = 0;\n    const std::vector<CppUnit::Test*> &tests = suite->getTests();\n    std::vector<CppUnit::Test*>::const_iterator it;\n    for( it = tests.begin(); it != tests.end(); ++it )\n      if( (*it)->getName() == elements[i] )\n       next = *it;\n    if( !next )\n      return 0;\n    ret = next;\n  }\n\n  return ret;\n}\n\n//------------------------------------------------------------------------------\n// Start the show\n//------------------------------------------------------------------------------\nint main( int argc, char **argv)\n{\n  //----------------------------------------------------------------------------\n  // Load the test library\n  //----------------------------------------------------------------------------\n  if( argc < 2 )\n  {\n    std::cerr << \"Usage: \" << argv[0] << \" libname.so testname\" << std::endl;\n    return 1;\n  }\n  void *libHandle = dlopen( argv[1], RTLD_LAZY );\n  if( libHandle == 0 )\n  {\n    std::cerr << \"Unable to load the test library: \" << dlerror() << std::endl;\n    return 1;\n  }\n\n  //----------------------------------------------------------------------------\n  // Print help\n  //----------------------------------------------------------------------------\n  CppUnit::Test *all = CppUnit::TestFactoryRegistry::getRegistry().makeTest();\n  if( argc == 2 )\n  {\n    std::cerr << \"Select your tests:\" << std::endl << std::endl;\n    printTests( all );\n    std::cerr << std::endl;\n    return 1;\n  }\n\n  //----------------------------------------------------------------------------\n  // Build the test suite\n  //----------------------------------------------------------------------------\n  CppUnit::TestSuite *selected = new CppUnit::TestSuite( \"Selected tests\" );\n  for( int i = 2; i < argc; ++i )\n  {\n    CppUnit::Test *t = findTest( all, std::string( argv[i]) );\n    if( !t )\n    {\n      std::cerr << \"Unable to find: \" << argv[i] << std::endl;\n      return 2;\n    }\n    selected->addTest( t );\n  }\n\n  std::cerr << \"You have selected: \" << std::endl << std::endl;\n  printTests( selected );\n  std::cerr << std::endl;\n\n  //----------------------------------------------------------------------------\n  // Run the tests\n  //----------------------------------------------------------------------------\n  std::cerr << \"Running:\" << std::endl << std::endl;\n  CppUnit::TextUi::TestRunner runner;\n  runner.addTest( selected );\n\n  runner.setOutputter(\n    new CppUnit::CompilerOutputter( &runner.result(), std::cerr ) );\n\n  bool wasSuccessful = runner.run();\n  dlclose( libHandle );\n  return wasSuccessful ? 0 : 1;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-xrootd-5.0.3-e62u7xynbx5qgsdavddvqlcwenldzuh5/spack-src/tests/XrdClTests/MonitorTestLib.cc": "//------------------------------------------------------------------------------\n// Copyright (c) 2012 by European Organization for Nuclear Research (CERN)\n// Author: Lukasz Janyst <ljanyst@cern.ch>\n//------------------------------------------------------------------------------\n// XRootD is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// XRootD is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with XRootD.  If not, see <http://www.gnu.org/licenses/>.\n//------------------------------------------------------------------------------\n\n#include \"XrdCl/XrdClMonitor.hh\"\n#include \"XrdCl/XrdClLog.hh\"\n#include \"XrdCl/XrdClUtils.hh\"\n#include \"XrdVersion.hh\"\n\n#include \"TestEnv.hh\"\n\nXrdVERSIONINFO( XrdClGetMonitor, MonitorTest );\n\nclass MonitorTest: public XrdCl::Monitor\n{\n  public:\n    //--------------------------------------------------------------------------\n    // Contructor\n    //--------------------------------------------------------------------------\n    MonitorTest( const std::string &exec, const std::string &param ):\n      pExec( exec ),\n      pParam( param ),\n      pInitialized(false)\n    {\n      XrdCl::Log *log = XrdClTests::TestEnv::GetLog();\n      log->Debug( 2, \"Constructed monitoring, exec %s, param %s\",\n                      exec.c_str(), param.c_str() );\n    }\n\n    //--------------------------------------------------------------------------\n    // Destructor\n    //--------------------------------------------------------------------------\n    virtual ~MonitorTest() {}\n\n    //--------------------------------------------------------------------------\n    // Event\n    //--------------------------------------------------------------------------\n    virtual void Event( EventCode evCode, void *evData )\n    {\n      using namespace XrdCl;\n      using namespace XrdClTests;\n\n      Log *log = TestEnv::GetLog();\n      switch( evCode )\n      {\n        //----------------------------------------------------------------------\n        // Got a connect event\n        //----------------------------------------------------------------------\n        case EvConnect:\n        {\n          ConnectInfo *i = (ConnectInfo*)evData;\n          std::string timeStarted = Utils::TimeToString( i->sTOD.tv_sec );\n          std::string timeDone    = Utils::TimeToString( i->sTOD.tv_sec );\n          log->Debug( 2, \"Successfully connected to: %s, started: %s, \"\n                      \"finished: %s, authentication: %s, streams: %d\",\n                      i->server.c_str(), timeStarted.c_str(), timeDone.c_str(),\n                      i->auth.empty() ? \"none\" : i->auth.c_str(),\n                      i->streams );\n          break;\n        }\n\n        //----------------------------------------------------------------------\n        // Got a disconnect event\n        //----------------------------------------------------------------------\n        case EvDisconnect:\n        {\n          DisconnectInfo *i = (DisconnectInfo*)evData;\n          log->Debug( 2, \"Disconnected from: %s, bytes sent: %ld, \"\n                      \"bytes received: %ld, connection time: %d, \"\n                      \"disconnection status: %s\",\n                      i->server.c_str(), i->sBytes, i->rBytes,\n                      i->cTime, i->status.ToString().c_str() );\n          break;\n        }\n\n        //----------------------------------------------------------------------\n        // Got an open event\n        //----------------------------------------------------------------------\n        case EvOpen:\n        {\n          OpenInfo *i = (OpenInfo*)evData;\n          log->Debug( 2, \"Successfully opened file %s at %s, size %ld\",\n                      i->file->GetURL().c_str(), i->dataServer.c_str(),\n                      i->fSize );\n          break;\n        }\n\n        //----------------------------------------------------------------------\n        // Got a close event\n        //----------------------------------------------------------------------\n        case EvClose:\n        {\n          CloseInfo *i = (CloseInfo*)evData;\n          std::string timeOpen   = Utils::TimeToString( i->oTOD.tv_sec );\n          std::string timeClosed = Utils::TimeToString( i->cTOD.tv_sec );\n          log->Debug( 2, \"Closed file %s, opened: %s, closed: %s, status: %s\",\n                      i->file->GetURL().c_str(), timeOpen.c_str(),\n                      timeClosed.c_str(), i->status->ToStr().c_str() );\n          log->Debug( 2, \"Closed file %s, bytes: read: %ld, readv: %ld, write:\"\n                      \" %ld, writev: %ld\", i->file->GetURL().c_str(), i->rBytes, i->vrBytes,\n                      i->wBytes, i->vwBytes );\n          log->Debug( 2, \"Closed file %s, count: read: %d, readv: %d/%d, \"\n                      \"write: %d\", i->file->GetURL().c_str(), i->rCount,\n                      i->vCount, i->vSegs, i->wCount );\n\n          break;\n        }\n\n        //----------------------------------------------------------------------\n        // Got an error event\n        //----------------------------------------------------------------------\n        case EvErrIO:\n        {\n          ErrorInfo *i = (ErrorInfo*)evData;\n          std::string op;\n          switch( i->opCode )\n          {\n            case ErrorInfo::ErrOpen:   op = \"Open\"; break;\n            case ErrorInfo::ErrRead:   op = \"Read\"; break;\n            case ErrorInfo::ErrReadV:  op = \"ReadV\"; break;\n            case ErrorInfo::ErrWrite:  op = \"Write\"; break;\n            case ErrorInfo::ErrWriteV: op = \"WriteV\"; break;\n            case ErrorInfo::ErrUnc:    op = \"Unclassified\"; break;\n          };\n          log->Debug( 2, \"Operation on file %s encountered an error: %s \"\n                      \"while %s\", i->file->GetURL().c_str(),\n                      i->status->ToStr().c_str(), op.c_str() );\n          break;\n        }\n\n        //----------------------------------------------------------------------\n        // Got a copy begin event\n        //----------------------------------------------------------------------\n        case EvCopyBeg:\n        {\n          CopyBInfo *i = (CopyBInfo*)evData;\n          log->Debug( 2, \"Copy operation started: origin %s, target: %s \",\n                      i->transfer.origin->GetURL().c_str(),\n                      i->transfer.target->GetURL().c_str() );\n          break;\n        }\n\n        //----------------------------------------------------------------------\n        // Got a copy end event\n        //----------------------------------------------------------------------\n        case EvCopyEnd:\n        {\n          CopyEInfo *i = (CopyEInfo*)evData;\n          std::string timeStart = Utils::TimeToString( i->bTOD.tv_sec );\n          std::string timeEnd   = Utils::TimeToString( i->eTOD.tv_sec );\n          log->Debug( 2, \"Copy operation ended: origin: %s, target: %s, \"\n                      \"start time %s, end time: %s, status: %s\",\n                      i->transfer.origin->GetURL().c_str(),\n                      i->transfer.target->GetURL().c_str(),\n                      timeStart.c_str(), timeEnd.c_str(),\n                      i->status->ToStr().c_str() );\n          break;\n        }\n\n        //----------------------------------------------------------------------\n        // Got a copy end event\n        //----------------------------------------------------------------------\n        case EvCheckSum:\n        {\n          CheckSumInfo *i = (CheckSumInfo*)evData;\n          log->Debug( 2, \"Checksum for transfer: origin: %s, target: %s, \"\n                      \"checksum %s, is ok: %d\",\n                      i->transfer.origin->GetURL().c_str(),\n                      i->transfer.target->GetURL().c_str(),\n                      i->cksum.c_str(), (int)i->isOK );\n          log->Debug( 2, \"Checksum for transfer: origin: %s, target: %s, \"\n                      \"us elapsed at origin %ld, us leapsed at target: %ld\",\n                      i->transfer.origin->GetURL().c_str(),\n                      i->transfer.target->GetURL().c_str(),\n                      i->oTime, i->tTime );\n          break;\n        }\n      }\n    }\n\n  private:\n    std::string pExec;\n    std::string pParam;\n    bool        pInitialized;\n};\n\n//------------------------------------------------------------------------------\n// C-mangled symbol for dlopen\n//------------------------------------------------------------------------------\nextern \"C\"\n{\n  void *XrdClGetMonitor( const char *exec, const char *param )\n  {\n    XrdCl::Log *log = XrdClTests::TestEnv::GetLog();\n    log->Debug( 2, \"Constructing monitoring, exec %s, param %s\",\n                exec, param ? param : \"\" );\n    return new MonitorTest( exec, param ? param : \"\" );\n  }\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-xrootd-5.0.3-e62u7xynbx5qgsdavddvqlcwenldzuh5/spack-src/src/XrdHttp/static/favicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-xrootd-5.0.3-e62u7xynbx5qgsdavddvqlcwenldzuh5/spack-src/src/XrdOss/XrdOssApi.cc",
        "/tmp/vanessa/spack-stage/spack-stage-xrootd-5.0.3-e62u7xynbx5qgsdavddvqlcwenldzuh5/spack-src/src/XrdOfs/XrdOfsConfigPI.cc",
        "/tmp/vanessa/spack-stage/spack-stage-xrootd-5.0.3-e62u7xynbx5qgsdavddvqlcwenldzuh5/spack-src/bindings/python/docs/source/.static/img/favicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-xrootd-5.0.3-e62u7xynbx5qgsdavddvqlcwenldzuh5/spack-src/bindings/python/docs/source/.static/img/xrootd-200x68.png"
    ],
    "total_files": 1418
}