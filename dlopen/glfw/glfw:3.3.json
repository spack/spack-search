{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-glfw-3.3-2fza4cb74pcte44nu2vbzw4ag2osew7l/spack-src/src/egl_context.c": "//========================================================================\n// GLFW 3.3 EGL - www.glfw.org\n//------------------------------------------------------------------------\n// Copyright (c) 2002-2006 Marcus Geelnard\n// Copyright (c) 2006-2019 Camilla L\u00f6wy <elmindreda@glfw.org>\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would\n//    be appreciated but is not required.\n//\n// 2. Altered source versions must be plainly marked as such, and must not\n//    be misrepresented as being the original software.\n//\n// 3. This notice may not be removed or altered from any source\n//    distribution.\n//\n//========================================================================\n\n#include \"internal.h\"\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n\n\n// Return a description of the specified EGL error\n//\nstatic const char* getEGLErrorString(EGLint error)\n{\n    switch (error)\n    {\n        case EGL_SUCCESS:\n            return \"Success\";\n        case EGL_NOT_INITIALIZED:\n            return \"EGL is not or could not be initialized\";\n        case EGL_BAD_ACCESS:\n            return \"EGL cannot access a requested resource\";\n        case EGL_BAD_ALLOC:\n            return \"EGL failed to allocate resources for the requested operation\";\n        case EGL_BAD_ATTRIBUTE:\n            return \"An unrecognized attribute or attribute value was passed in the attribute list\";\n        case EGL_BAD_CONTEXT:\n            return \"An EGLContext argument does not name a valid EGL rendering context\";\n        case EGL_BAD_CONFIG:\n            return \"An EGLConfig argument does not name a valid EGL frame buffer configuration\";\n        case EGL_BAD_CURRENT_SURFACE:\n            return \"The current surface of the calling thread is a window, pixel buffer or pixmap that is no longer valid\";\n        case EGL_BAD_DISPLAY:\n            return \"An EGLDisplay argument does not name a valid EGL display connection\";\n        case EGL_BAD_SURFACE:\n            return \"An EGLSurface argument does not name a valid surface configured for GL rendering\";\n        case EGL_BAD_MATCH:\n            return \"Arguments are inconsistent\";\n        case EGL_BAD_PARAMETER:\n            return \"One or more argument values are invalid\";\n        case EGL_BAD_NATIVE_PIXMAP:\n            return \"A NativePixmapType argument does not refer to a valid native pixmap\";\n        case EGL_BAD_NATIVE_WINDOW:\n            return \"A NativeWindowType argument does not refer to a valid native window\";\n        case EGL_CONTEXT_LOST:\n            return \"The application must destroy all contexts and reinitialise\";\n        default:\n            return \"ERROR: UNKNOWN EGL ERROR\";\n    }\n}\n\n// Returns the specified attribute of the specified EGLConfig\n//\nstatic int getEGLConfigAttrib(EGLConfig config, int attrib)\n{\n    int value;\n    eglGetConfigAttrib(_glfw.egl.display, config, attrib, &value);\n    return value;\n}\n\n// Return the EGLConfig most closely matching the specified hints\n//\nstatic GLFWbool chooseEGLConfig(const _GLFWctxconfig* ctxconfig,\n                                const _GLFWfbconfig* desired,\n                                EGLConfig* result)\n{\n    EGLConfig* nativeConfigs;\n    _GLFWfbconfig* usableConfigs;\n    const _GLFWfbconfig* closest;\n    int i, nativeCount, usableCount;\n\n    eglGetConfigs(_glfw.egl.display, NULL, 0, &nativeCount);\n    if (!nativeCount)\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE, \"EGL: No EGLConfigs returned\");\n        return GLFW_FALSE;\n    }\n\n    nativeConfigs = calloc(nativeCount, sizeof(EGLConfig));\n    eglGetConfigs(_glfw.egl.display, nativeConfigs, nativeCount, &nativeCount);\n\n    usableConfigs = calloc(nativeCount, sizeof(_GLFWfbconfig));\n    usableCount = 0;\n\n    for (i = 0;  i < nativeCount;  i++)\n    {\n        const EGLConfig n = nativeConfigs[i];\n        _GLFWfbconfig* u = usableConfigs + usableCount;\n\n        // Only consider RGB(A) EGLConfigs\n        if (getEGLConfigAttrib(n, EGL_COLOR_BUFFER_TYPE) != EGL_RGB_BUFFER)\n            continue;\n\n        // Only consider window EGLConfigs\n        if (!(getEGLConfigAttrib(n, EGL_SURFACE_TYPE) & EGL_WINDOW_BIT))\n            continue;\n\n#if defined(_GLFW_X11)\n        XVisualInfo vi = {0};\n\n        // Only consider EGLConfigs with associated Visuals\n        vi.visualid = getEGLConfigAttrib(n, EGL_NATIVE_VISUAL_ID);\n        if (!vi.visualid)\n            continue;\n\n        if (desired->transparent)\n        {\n            int count;\n            XVisualInfo* vis = XGetVisualInfo(_glfw.x11.display,\n                                              VisualIDMask, &vi,\n                                              &count);\n            if (vis)\n            {\n                u->transparent = _glfwIsVisualTransparentX11(vis[0].visual);\n                XFree(vis);\n            }\n        }\n#endif // _GLFW_X11\n\n        if (ctxconfig->client == GLFW_OPENGL_ES_API)\n        {\n            if (ctxconfig->major == 1)\n            {\n                if (!(getEGLConfigAttrib(n, EGL_RENDERABLE_TYPE) & EGL_OPENGL_ES_BIT))\n                    continue;\n            }\n            else\n            {\n                if (!(getEGLConfigAttrib(n, EGL_RENDERABLE_TYPE) & EGL_OPENGL_ES2_BIT))\n                    continue;\n            }\n        }\n        else if (ctxconfig->client == GLFW_OPENGL_API)\n        {\n            if (!(getEGLConfigAttrib(n, EGL_RENDERABLE_TYPE) & EGL_OPENGL_BIT))\n                continue;\n        }\n\n        u->redBits = getEGLConfigAttrib(n, EGL_RED_SIZE);\n        u->greenBits = getEGLConfigAttrib(n, EGL_GREEN_SIZE);\n        u->blueBits = getEGLConfigAttrib(n, EGL_BLUE_SIZE);\n\n        u->alphaBits = getEGLConfigAttrib(n, EGL_ALPHA_SIZE);\n        u->depthBits = getEGLConfigAttrib(n, EGL_DEPTH_SIZE);\n        u->stencilBits = getEGLConfigAttrib(n, EGL_STENCIL_SIZE);\n\n        u->samples = getEGLConfigAttrib(n, EGL_SAMPLES);\n        u->doublebuffer = GLFW_TRUE;\n\n        u->handle = (uintptr_t) n;\n        usableCount++;\n    }\n\n    closest = _glfwChooseFBConfig(desired, usableConfigs, usableCount);\n    if (closest)\n        *result = (EGLConfig) closest->handle;\n\n    free(nativeConfigs);\n    free(usableConfigs);\n\n    return closest != NULL;\n}\n\nstatic void makeContextCurrentEGL(_GLFWwindow* window)\n{\n    if (window)\n    {\n        if (!eglMakeCurrent(_glfw.egl.display,\n                            window->context.egl.surface,\n                            window->context.egl.surface,\n                            window->context.egl.handle))\n        {\n            _glfwInputError(GLFW_PLATFORM_ERROR,\n                            \"EGL: Failed to make context current: %s\",\n                            getEGLErrorString(eglGetError()));\n            return;\n        }\n    }\n    else\n    {\n        if (!eglMakeCurrent(_glfw.egl.display,\n                            EGL_NO_SURFACE,\n                            EGL_NO_SURFACE,\n                            EGL_NO_CONTEXT))\n        {\n            _glfwInputError(GLFW_PLATFORM_ERROR,\n                            \"EGL: Failed to clear current context: %s\",\n                            getEGLErrorString(eglGetError()));\n            return;\n        }\n    }\n\n    _glfwPlatformSetTls(&_glfw.contextSlot, window);\n}\n\nstatic void swapBuffersEGL(_GLFWwindow* window)\n{\n    if (window != _glfwPlatformGetTls(&_glfw.contextSlot))\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"EGL: The context must be current on the calling thread when swapping buffers\");\n        return;\n    }\n\n    eglSwapBuffers(_glfw.egl.display, window->context.egl.surface);\n}\n\nstatic void swapIntervalEGL(int interval)\n{\n    eglSwapInterval(_glfw.egl.display, interval);\n}\n\nstatic int extensionSupportedEGL(const char* extension)\n{\n    const char* extensions = eglQueryString(_glfw.egl.display, EGL_EXTENSIONS);\n    if (extensions)\n    {\n        if (_glfwStringInExtensionString(extension, extensions))\n            return GLFW_TRUE;\n    }\n\n    return GLFW_FALSE;\n}\n\nstatic GLFWglproc getProcAddressEGL(const char* procname)\n{\n    _GLFWwindow* window = _glfwPlatformGetTls(&_glfw.contextSlot);\n\n    if (window->context.egl.client)\n    {\n        GLFWglproc proc = (GLFWglproc) _glfw_dlsym(window->context.egl.client,\n                                                   procname);\n        if (proc)\n            return proc;\n    }\n\n    return eglGetProcAddress(procname);\n}\n\nstatic void destroyContextEGL(_GLFWwindow* window)\n{\n#if defined(_GLFW_X11)\n    // NOTE: Do not unload libGL.so.1 while the X11 display is still open,\n    //       as it will make XCloseDisplay segfault\n    if (window->context.client != GLFW_OPENGL_API)\n#endif // _GLFW_X11\n    {\n        if (window->context.egl.client)\n        {\n            _glfw_dlclose(window->context.egl.client);\n            window->context.egl.client = NULL;\n        }\n    }\n\n    if (window->context.egl.surface)\n    {\n        eglDestroySurface(_glfw.egl.display, window->context.egl.surface);\n        window->context.egl.surface = EGL_NO_SURFACE;\n    }\n\n    if (window->context.egl.handle)\n    {\n        eglDestroyContext(_glfw.egl.display, window->context.egl.handle);\n        window->context.egl.handle = EGL_NO_CONTEXT;\n    }\n}\n\n\n//////////////////////////////////////////////////////////////////////////\n//////                       GLFW internal API                      //////\n//////////////////////////////////////////////////////////////////////////\n\n// Initialize EGL\n//\nGLFWbool _glfwInitEGL(void)\n{\n    int i;\n    const char* sonames[] =\n    {\n#if defined(_GLFW_EGL_LIBRARY)\n        _GLFW_EGL_LIBRARY,\n#elif defined(_GLFW_WIN32)\n        \"libEGL.dll\",\n        \"EGL.dll\",\n#elif defined(_GLFW_COCOA)\n        \"libEGL.dylib\",\n#elif defined(__CYGWIN__)\n        \"libEGL-1.so\",\n#else\n        \"libEGL.so.1\",\n#endif\n        NULL\n    };\n\n    if (_glfw.egl.handle)\n        return GLFW_TRUE;\n\n    for (i = 0;  sonames[i];  i++)\n    {\n        _glfw.egl.handle = _glfw_dlopen(sonames[i]);\n        if (_glfw.egl.handle)\n            break;\n    }\n\n    if (!_glfw.egl.handle)\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE, \"EGL: Library not found\");\n        return GLFW_FALSE;\n    }\n\n    _glfw.egl.prefix = (strncmp(sonames[i], \"lib\", 3) == 0);\n\n    _glfw.egl.GetConfigAttrib = (PFN_eglGetConfigAttrib)\n        _glfw_dlsym(_glfw.egl.handle, \"eglGetConfigAttrib\");\n    _glfw.egl.GetConfigs = (PFN_eglGetConfigs)\n        _glfw_dlsym(_glfw.egl.handle, \"eglGetConfigs\");\n    _glfw.egl.GetDisplay = (PFN_eglGetDisplay)\n        _glfw_dlsym(_glfw.egl.handle, \"eglGetDisplay\");\n    _glfw.egl.GetError = (PFN_eglGetError)\n        _glfw_dlsym(_glfw.egl.handle, \"eglGetError\");\n    _glfw.egl.Initialize = (PFN_eglInitialize)\n        _glfw_dlsym(_glfw.egl.handle, \"eglInitialize\");\n    _glfw.egl.Terminate = (PFN_eglTerminate)\n        _glfw_dlsym(_glfw.egl.handle, \"eglTerminate\");\n    _glfw.egl.BindAPI = (PFN_eglBindAPI)\n        _glfw_dlsym(_glfw.egl.handle, \"eglBindAPI\");\n    _glfw.egl.CreateContext = (PFN_eglCreateContext)\n        _glfw_dlsym(_glfw.egl.handle, \"eglCreateContext\");\n    _glfw.egl.DestroySurface = (PFN_eglDestroySurface)\n        _glfw_dlsym(_glfw.egl.handle, \"eglDestroySurface\");\n    _glfw.egl.DestroyContext = (PFN_eglDestroyContext)\n        _glfw_dlsym(_glfw.egl.handle, \"eglDestroyContext\");\n    _glfw.egl.CreateWindowSurface = (PFN_eglCreateWindowSurface)\n        _glfw_dlsym(_glfw.egl.handle, \"eglCreateWindowSurface\");\n    _glfw.egl.MakeCurrent = (PFN_eglMakeCurrent)\n        _glfw_dlsym(_glfw.egl.handle, \"eglMakeCurrent\");\n    _glfw.egl.SwapBuffers = (PFN_eglSwapBuffers)\n        _glfw_dlsym(_glfw.egl.handle, \"eglSwapBuffers\");\n    _glfw.egl.SwapInterval = (PFN_eglSwapInterval)\n        _glfw_dlsym(_glfw.egl.handle, \"eglSwapInterval\");\n    _glfw.egl.QueryString = (PFN_eglQueryString)\n        _glfw_dlsym(_glfw.egl.handle, \"eglQueryString\");\n    _glfw.egl.GetProcAddress = (PFN_eglGetProcAddress)\n        _glfw_dlsym(_glfw.egl.handle, \"eglGetProcAddress\");\n\n    if (!_glfw.egl.GetConfigAttrib ||\n        !_glfw.egl.GetConfigs ||\n        !_glfw.egl.GetDisplay ||\n        !_glfw.egl.GetError ||\n        !_glfw.egl.Initialize ||\n        !_glfw.egl.Terminate ||\n        !_glfw.egl.BindAPI ||\n        !_glfw.egl.CreateContext ||\n        !_glfw.egl.DestroySurface ||\n        !_glfw.egl.DestroyContext ||\n        !_glfw.egl.CreateWindowSurface ||\n        !_glfw.egl.MakeCurrent ||\n        !_glfw.egl.SwapBuffers ||\n        !_glfw.egl.SwapInterval ||\n        !_glfw.egl.QueryString ||\n        !_glfw.egl.GetProcAddress)\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"EGL: Failed to load required entry points\");\n\n        _glfwTerminateEGL();\n        return GLFW_FALSE;\n    }\n\n    _glfw.egl.display = eglGetDisplay(_GLFW_EGL_NATIVE_DISPLAY);\n    if (_glfw.egl.display == EGL_NO_DISPLAY)\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE,\n                        \"EGL: Failed to get EGL display: %s\",\n                        getEGLErrorString(eglGetError()));\n\n        _glfwTerminateEGL();\n        return GLFW_FALSE;\n    }\n\n    if (!eglInitialize(_glfw.egl.display, &_glfw.egl.major, &_glfw.egl.minor))\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE,\n                        \"EGL: Failed to initialize EGL: %s\",\n                        getEGLErrorString(eglGetError()));\n\n        _glfwTerminateEGL();\n        return GLFW_FALSE;\n    }\n\n    _glfw.egl.KHR_create_context =\n        extensionSupportedEGL(\"EGL_KHR_create_context\");\n    _glfw.egl.KHR_create_context_no_error =\n        extensionSupportedEGL(\"EGL_KHR_create_context_no_error\");\n    _glfw.egl.KHR_gl_colorspace =\n        extensionSupportedEGL(\"EGL_KHR_gl_colorspace\");\n    _glfw.egl.KHR_get_all_proc_addresses =\n        extensionSupportedEGL(\"EGL_KHR_get_all_proc_addresses\");\n    _glfw.egl.KHR_context_flush_control =\n        extensionSupportedEGL(\"EGL_KHR_context_flush_control\");\n\n    return GLFW_TRUE;\n}\n\n// Terminate EGL\n//\nvoid _glfwTerminateEGL(void)\n{\n    if (_glfw.egl.display)\n    {\n        eglTerminate(_glfw.egl.display);\n        _glfw.egl.display = EGL_NO_DISPLAY;\n    }\n\n    if (_glfw.egl.handle)\n    {\n        _glfw_dlclose(_glfw.egl.handle);\n        _glfw.egl.handle = NULL;\n    }\n}\n\n#define setAttrib(a, v) \\\n{ \\\n    assert(((size_t) index + 1) < sizeof(attribs) / sizeof(attribs[0])); \\\n    attribs[index++] = a; \\\n    attribs[index++] = v; \\\n}\n\n// Create the OpenGL or OpenGL ES context\n//\nGLFWbool _glfwCreateContextEGL(_GLFWwindow* window,\n                               const _GLFWctxconfig* ctxconfig,\n                               const _GLFWfbconfig* fbconfig)\n{\n    EGLint attribs[40];\n    EGLConfig config;\n    EGLContext share = NULL;\n    int index = 0;\n\n    if (!_glfw.egl.display)\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE, \"EGL: API not available\");\n        return GLFW_FALSE;\n    }\n\n    if (ctxconfig->share)\n        share = ctxconfig->share->context.egl.handle;\n\n    if (!chooseEGLConfig(ctxconfig, fbconfig, &config))\n    {\n        _glfwInputError(GLFW_FORMAT_UNAVAILABLE,\n                        \"EGL: Failed to find a suitable EGLConfig\");\n        return GLFW_FALSE;\n    }\n\n    if (ctxconfig->client == GLFW_OPENGL_ES_API)\n    {\n        if (!eglBindAPI(EGL_OPENGL_ES_API))\n        {\n            _glfwInputError(GLFW_API_UNAVAILABLE,\n                            \"EGL: Failed to bind OpenGL ES: %s\",\n                            getEGLErrorString(eglGetError()));\n            return GLFW_FALSE;\n        }\n    }\n    else\n    {\n        if (!eglBindAPI(EGL_OPENGL_API))\n        {\n            _glfwInputError(GLFW_API_UNAVAILABLE,\n                            \"EGL: Failed to bind OpenGL: %s\",\n                            getEGLErrorString(eglGetError()));\n            return GLFW_FALSE;\n        }\n    }\n\n    if (_glfw.egl.KHR_create_context)\n    {\n        int mask = 0, flags = 0;\n\n        if (ctxconfig->client == GLFW_OPENGL_API)\n        {\n            if (ctxconfig->forward)\n                flags |= EGL_CONTEXT_OPENGL_FORWARD_COMPATIBLE_BIT_KHR;\n\n            if (ctxconfig->profile == GLFW_OPENGL_CORE_PROFILE)\n                mask |= EGL_CONTEXT_OPENGL_CORE_PROFILE_BIT_KHR;\n            else if (ctxconfig->profile == GLFW_OPENGL_COMPAT_PROFILE)\n                mask |= EGL_CONTEXT_OPENGL_COMPATIBILITY_PROFILE_BIT_KHR;\n        }\n\n        if (ctxconfig->debug)\n            flags |= EGL_CONTEXT_OPENGL_DEBUG_BIT_KHR;\n\n        if (ctxconfig->robustness)\n        {\n            if (ctxconfig->robustness == GLFW_NO_RESET_NOTIFICATION)\n            {\n                setAttrib(EGL_CONTEXT_OPENGL_RESET_NOTIFICATION_STRATEGY_KHR,\n                          EGL_NO_RESET_NOTIFICATION_KHR);\n            }\n            else if (ctxconfig->robustness == GLFW_LOSE_CONTEXT_ON_RESET)\n            {\n                setAttrib(EGL_CONTEXT_OPENGL_RESET_NOTIFICATION_STRATEGY_KHR,\n                          EGL_LOSE_CONTEXT_ON_RESET_KHR);\n            }\n\n            flags |= EGL_CONTEXT_OPENGL_ROBUST_ACCESS_BIT_KHR;\n        }\n\n        if (ctxconfig->noerror)\n        {\n            if (_glfw.egl.KHR_create_context_no_error)\n                setAttrib(EGL_CONTEXT_OPENGL_NO_ERROR_KHR, GLFW_TRUE);\n        }\n\n        if (ctxconfig->major != 1 || ctxconfig->minor != 0)\n        {\n            setAttrib(EGL_CONTEXT_MAJOR_VERSION_KHR, ctxconfig->major);\n            setAttrib(EGL_CONTEXT_MINOR_VERSION_KHR, ctxconfig->minor);\n        }\n\n        if (mask)\n            setAttrib(EGL_CONTEXT_OPENGL_PROFILE_MASK_KHR, mask);\n\n        if (flags)\n            setAttrib(EGL_CONTEXT_FLAGS_KHR, flags);\n    }\n    else\n    {\n        if (ctxconfig->client == GLFW_OPENGL_ES_API)\n            setAttrib(EGL_CONTEXT_CLIENT_VERSION, ctxconfig->major);\n    }\n\n    if (_glfw.egl.KHR_context_flush_control)\n    {\n        if (ctxconfig->release == GLFW_RELEASE_BEHAVIOR_NONE)\n        {\n            setAttrib(EGL_CONTEXT_RELEASE_BEHAVIOR_KHR,\n                      EGL_CONTEXT_RELEASE_BEHAVIOR_NONE_KHR);\n        }\n        else if (ctxconfig->release == GLFW_RELEASE_BEHAVIOR_FLUSH)\n        {\n            setAttrib(EGL_CONTEXT_RELEASE_BEHAVIOR_KHR,\n                      EGL_CONTEXT_RELEASE_BEHAVIOR_FLUSH_KHR);\n        }\n    }\n\n    setAttrib(EGL_NONE, EGL_NONE);\n\n    window->context.egl.handle = eglCreateContext(_glfw.egl.display,\n                                                  config, share, attribs);\n\n    if (window->context.egl.handle == EGL_NO_CONTEXT)\n    {\n        _glfwInputError(GLFW_VERSION_UNAVAILABLE,\n                        \"EGL: Failed to create context: %s\",\n                        getEGLErrorString(eglGetError()));\n        return GLFW_FALSE;\n    }\n\n    // Set up attributes for surface creation\n    {\n        int index = 0;\n\n        if (fbconfig->sRGB)\n        {\n            if (_glfw.egl.KHR_gl_colorspace)\n                setAttrib(EGL_GL_COLORSPACE_KHR, EGL_GL_COLORSPACE_SRGB_KHR);\n        }\n\n        setAttrib(EGL_NONE, EGL_NONE);\n    }\n\n    window->context.egl.surface =\n        eglCreateWindowSurface(_glfw.egl.display,\n                               config,\n                               _GLFW_EGL_NATIVE_WINDOW,\n                               attribs);\n    if (window->context.egl.surface == EGL_NO_SURFACE)\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"EGL: Failed to create window surface: %s\",\n                        getEGLErrorString(eglGetError()));\n        return GLFW_FALSE;\n    }\n\n    window->context.egl.config = config;\n\n    // Load the appropriate client library\n    if (!_glfw.egl.KHR_get_all_proc_addresses)\n    {\n        int i;\n        const char** sonames;\n        const char* es1sonames[] =\n        {\n#if defined(_GLFW_GLESV1_LIBRARY)\n            _GLFW_GLESV1_LIBRARY,\n#elif defined(_GLFW_WIN32)\n            \"GLESv1_CM.dll\",\n            \"libGLES_CM.dll\",\n#elif defined(_GLFW_COCOA)\n            \"libGLESv1_CM.dylib\",\n#else\n            \"libGLESv1_CM.so.1\",\n            \"libGLES_CM.so.1\",\n#endif\n            NULL\n        };\n        const char* es2sonames[] =\n        {\n#if defined(_GLFW_GLESV2_LIBRARY)\n            _GLFW_GLESV2_LIBRARY,\n#elif defined(_GLFW_WIN32)\n            \"GLESv2.dll\",\n            \"libGLESv2.dll\",\n#elif defined(_GLFW_COCOA)\n            \"libGLESv2.dylib\",\n#elif defined(__CYGWIN__)\n            \"libGLESv2-2.so\",\n#else\n            \"libGLESv2.so.2\",\n#endif\n            NULL\n        };\n        const char* glsonames[] =\n        {\n#if defined(_GLFW_OPENGL_LIBRARY)\n            _GLFW_OPENGL_LIBRARY,\n#elif defined(_GLFW_WIN32)\n#elif defined(_GLFW_COCOA)\n#else\n            \"libGL.so.1\",\n#endif\n            NULL\n        };\n\n        if (ctxconfig->client == GLFW_OPENGL_ES_API)\n        {\n            if (ctxconfig->major == 1)\n                sonames = es1sonames;\n            else\n                sonames = es2sonames;\n        }\n        else\n            sonames = glsonames;\n\n        for (i = 0;  sonames[i];  i++)\n        {\n            // HACK: Match presence of lib prefix to increase chance of finding\n            //       a matching pair in the jungle that is Win32 EGL/GLES\n            if (_glfw.egl.prefix != (strncmp(sonames[i], \"lib\", 3) == 0))\n                continue;\n\n            window->context.egl.client = _glfw_dlopen(sonames[i]);\n            if (window->context.egl.client)\n                break;\n        }\n\n        if (!window->context.egl.client)\n        {\n            _glfwInputError(GLFW_API_UNAVAILABLE,\n                            \"EGL: Failed to load client library\");\n            return GLFW_FALSE;\n        }\n    }\n\n    window->context.makeCurrent = makeContextCurrentEGL;\n    window->context.swapBuffers = swapBuffersEGL;\n    window->context.swapInterval = swapIntervalEGL;\n    window->context.extensionSupported = extensionSupportedEGL;\n    window->context.getProcAddress = getProcAddressEGL;\n    window->context.destroy = destroyContextEGL;\n\n    return GLFW_TRUE;\n}\n\n#undef setAttrib\n\n// Returns the Visual and depth of the chosen EGLConfig\n//\n#if defined(_GLFW_X11)\nGLFWbool _glfwChooseVisualEGL(const _GLFWwndconfig* wndconfig,\n                              const _GLFWctxconfig* ctxconfig,\n                              const _GLFWfbconfig* fbconfig,\n                              Visual** visual, int* depth)\n{\n    XVisualInfo* result;\n    XVisualInfo desired;\n    EGLConfig native;\n    EGLint visualID = 0, count = 0;\n    const long vimask = VisualScreenMask | VisualIDMask;\n\n    if (!chooseEGLConfig(ctxconfig, fbconfig, &native))\n    {\n        _glfwInputError(GLFW_FORMAT_UNAVAILABLE,\n                        \"EGL: Failed to find a suitable EGLConfig\");\n        return GLFW_FALSE;\n    }\n\n    eglGetConfigAttrib(_glfw.egl.display, native,\n                       EGL_NATIVE_VISUAL_ID, &visualID);\n\n    desired.screen = _glfw.x11.screen;\n    desired.visualid = visualID;\n\n    result = XGetVisualInfo(_glfw.x11.display, vimask, &desired, &count);\n    if (!result)\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"EGL: Failed to retrieve Visual for EGLConfig\");\n        return GLFW_FALSE;\n    }\n\n    *visual = result->visual;\n    *depth = result->depth;\n\n    XFree(result);\n    return GLFW_TRUE;\n}\n#endif // _GLFW_X11\n\n\n//////////////////////////////////////////////////////////////////////////\n//////                        GLFW native API                       //////\n//////////////////////////////////////////////////////////////////////////\n\nGLFWAPI EGLDisplay glfwGetEGLDisplay(void)\n{\n    _GLFW_REQUIRE_INIT_OR_RETURN(EGL_NO_DISPLAY);\n    return _glfw.egl.display;\n}\n\nGLFWAPI EGLContext glfwGetEGLContext(GLFWwindow* handle)\n{\n    _GLFWwindow* window = (_GLFWwindow*) handle;\n    _GLFW_REQUIRE_INIT_OR_RETURN(EGL_NO_CONTEXT);\n\n    if (window->context.client == GLFW_NO_API)\n    {\n        _glfwInputError(GLFW_NO_WINDOW_CONTEXT, NULL);\n        return EGL_NO_CONTEXT;\n    }\n\n    return window->context.egl.handle;\n}\n\nGLFWAPI EGLSurface glfwGetEGLSurface(GLFWwindow* handle)\n{\n    _GLFWwindow* window = (_GLFWwindow*) handle;\n    _GLFW_REQUIRE_INIT_OR_RETURN(EGL_NO_SURFACE);\n\n    if (window->context.client == GLFW_NO_API)\n    {\n        _glfwInputError(GLFW_NO_WINDOW_CONTEXT, NULL);\n        return EGL_NO_SURFACE;\n    }\n\n    return window->context.egl.surface;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-glfw-3.3-2fza4cb74pcte44nu2vbzw4ag2osew7l/spack-src/src/x11_platform.h": "//========================================================================\n// GLFW 3.3 X11 - www.glfw.org\n//------------------------------------------------------------------------\n// Copyright (c) 2002-2006 Marcus Geelnard\n// Copyright (c) 2006-2019 Camilla L\u00f6wy <elmindreda@glfw.org>\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would\n//    be appreciated but is not required.\n//\n// 2. Altered source versions must be plainly marked as such, and must not\n//    be misrepresented as being the original software.\n//\n// 3. This notice may not be removed or altered from any source\n//    distribution.\n//\n//========================================================================\n\n#include <unistd.h>\n#include <signal.h>\n#include <stdint.h>\n#include <dlfcn.h>\n\n#include <X11/Xlib.h>\n#include <X11/keysym.h>\n#include <X11/Xatom.h>\n#include <X11/Xcursor/Xcursor.h>\n\n// The XRandR extension provides mode setting and gamma control\n#include <X11/extensions/Xrandr.h>\n\n// The Xkb extension provides improved keyboard support\n#include <X11/XKBlib.h>\n\n// The Xinerama extension provides legacy monitor indices\n#include <X11/extensions/Xinerama.h>\n\n// The XInput extension provides raw mouse motion input\n#include <X11/extensions/XInput2.h>\n\ntypedef XRRCrtcGamma* (* PFN_XRRAllocGamma)(int);\ntypedef void (* PFN_XRRFreeCrtcInfo)(XRRCrtcInfo*);\ntypedef void (* PFN_XRRFreeGamma)(XRRCrtcGamma*);\ntypedef void (* PFN_XRRFreeOutputInfo)(XRROutputInfo*);\ntypedef void (* PFN_XRRFreeScreenResources)(XRRScreenResources*);\ntypedef XRRCrtcGamma* (* PFN_XRRGetCrtcGamma)(Display*,RRCrtc);\ntypedef int (* PFN_XRRGetCrtcGammaSize)(Display*,RRCrtc);\ntypedef XRRCrtcInfo* (* PFN_XRRGetCrtcInfo) (Display*,XRRScreenResources*,RRCrtc);\ntypedef XRROutputInfo* (* PFN_XRRGetOutputInfo)(Display*,XRRScreenResources*,RROutput);\ntypedef RROutput (* PFN_XRRGetOutputPrimary)(Display*,Window);\ntypedef XRRScreenResources* (* PFN_XRRGetScreenResourcesCurrent)(Display*,Window);\ntypedef Bool (* PFN_XRRQueryExtension)(Display*,int*,int*);\ntypedef Status (* PFN_XRRQueryVersion)(Display*,int*,int*);\ntypedef void (* PFN_XRRSelectInput)(Display*,Window,int);\ntypedef Status (* PFN_XRRSetCrtcConfig)(Display*,XRRScreenResources*,RRCrtc,Time,int,int,RRMode,Rotation,RROutput*,int);\ntypedef void (* PFN_XRRSetCrtcGamma)(Display*,RRCrtc,XRRCrtcGamma*);\ntypedef int (* PFN_XRRUpdateConfiguration)(XEvent*);\n#define XRRAllocGamma _glfw.x11.randr.AllocGamma\n#define XRRFreeCrtcInfo _glfw.x11.randr.FreeCrtcInfo\n#define XRRFreeGamma _glfw.x11.randr.FreeGamma\n#define XRRFreeOutputInfo _glfw.x11.randr.FreeOutputInfo\n#define XRRFreeScreenResources _glfw.x11.randr.FreeScreenResources\n#define XRRGetCrtcGamma _glfw.x11.randr.GetCrtcGamma\n#define XRRGetCrtcGammaSize _glfw.x11.randr.GetCrtcGammaSize\n#define XRRGetCrtcInfo _glfw.x11.randr.GetCrtcInfo\n#define XRRGetOutputInfo _glfw.x11.randr.GetOutputInfo\n#define XRRGetOutputPrimary _glfw.x11.randr.GetOutputPrimary\n#define XRRGetScreenResourcesCurrent _glfw.x11.randr.GetScreenResourcesCurrent\n#define XRRQueryExtension _glfw.x11.randr.QueryExtension\n#define XRRQueryVersion _glfw.x11.randr.QueryVersion\n#define XRRSelectInput _glfw.x11.randr.SelectInput\n#define XRRSetCrtcConfig _glfw.x11.randr.SetCrtcConfig\n#define XRRSetCrtcGamma _glfw.x11.randr.SetCrtcGamma\n#define XRRUpdateConfiguration _glfw.x11.randr.UpdateConfiguration\n\ntypedef XcursorImage* (* PFN_XcursorImageCreate)(int,int);\ntypedef void (* PFN_XcursorImageDestroy)(XcursorImage*);\ntypedef Cursor (* PFN_XcursorImageLoadCursor)(Display*,const XcursorImage*);\n#define XcursorImageCreate _glfw.x11.xcursor.ImageCreate\n#define XcursorImageDestroy _glfw.x11.xcursor.ImageDestroy\n#define XcursorImageLoadCursor _glfw.x11.xcursor.ImageLoadCursor\n\ntypedef Bool (* PFN_XineramaIsActive)(Display*);\ntypedef Bool (* PFN_XineramaQueryExtension)(Display*,int*,int*);\ntypedef XineramaScreenInfo* (* PFN_XineramaQueryScreens)(Display*,int*);\n#define XineramaIsActive _glfw.x11.xinerama.IsActive\n#define XineramaQueryExtension _glfw.x11.xinerama.QueryExtension\n#define XineramaQueryScreens _glfw.x11.xinerama.QueryScreens\n\ntypedef XID xcb_window_t;\ntypedef XID xcb_visualid_t;\ntypedef struct xcb_connection_t xcb_connection_t;\ntypedef xcb_connection_t* (* PFN_XGetXCBConnection)(Display*);\n#define XGetXCBConnection _glfw.x11.x11xcb.GetXCBConnection\n\ntypedef Bool (* PFN_XF86VidModeQueryExtension)(Display*,int*,int*);\ntypedef Bool (* PFN_XF86VidModeGetGammaRamp)(Display*,int,int,unsigned short*,unsigned short*,unsigned short*);\ntypedef Bool (* PFN_XF86VidModeSetGammaRamp)(Display*,int,int,unsigned short*,unsigned short*,unsigned short*);\ntypedef Bool (* PFN_XF86VidModeGetGammaRampSize)(Display*,int,int*);\n#define XF86VidModeQueryExtension _glfw.x11.vidmode.QueryExtension\n#define XF86VidModeGetGammaRamp _glfw.x11.vidmode.GetGammaRamp\n#define XF86VidModeSetGammaRamp _glfw.x11.vidmode.SetGammaRamp\n#define XF86VidModeGetGammaRampSize _glfw.x11.vidmode.GetGammaRampSize\n\ntypedef Status (* PFN_XIQueryVersion)(Display*,int*,int*);\ntypedef int (* PFN_XISelectEvents)(Display*,Window,XIEventMask*,int);\n#define XIQueryVersion _glfw.x11.xi.QueryVersion\n#define XISelectEvents _glfw.x11.xi.SelectEvents\n\ntypedef Bool (* PFN_XRenderQueryExtension)(Display*,int*,int*);\ntypedef Status (* PFN_XRenderQueryVersion)(Display*dpy,int*,int*);\ntypedef XRenderPictFormat* (* PFN_XRenderFindVisualFormat)(Display*,Visual const*);\n#define XRenderQueryExtension _glfw.x11.xrender.QueryExtension\n#define XRenderQueryVersion _glfw.x11.xrender.QueryVersion\n#define XRenderFindVisualFormat _glfw.x11.xrender.FindVisualFormat\n\ntypedef VkFlags VkXlibSurfaceCreateFlagsKHR;\ntypedef VkFlags VkXcbSurfaceCreateFlagsKHR;\n\ntypedef struct VkXlibSurfaceCreateInfoKHR\n{\n    VkStructureType             sType;\n    const void*                 pNext;\n    VkXlibSurfaceCreateFlagsKHR flags;\n    Display*                    dpy;\n    Window                      window;\n} VkXlibSurfaceCreateInfoKHR;\n\ntypedef struct VkXcbSurfaceCreateInfoKHR\n{\n    VkStructureType             sType;\n    const void*                 pNext;\n    VkXcbSurfaceCreateFlagsKHR  flags;\n    xcb_connection_t*           connection;\n    xcb_window_t                window;\n} VkXcbSurfaceCreateInfoKHR;\n\ntypedef VkResult (APIENTRY *PFN_vkCreateXlibSurfaceKHR)(VkInstance,const VkXlibSurfaceCreateInfoKHR*,const VkAllocationCallbacks*,VkSurfaceKHR*);\ntypedef VkBool32 (APIENTRY *PFN_vkGetPhysicalDeviceXlibPresentationSupportKHR)(VkPhysicalDevice,uint32_t,Display*,VisualID);\ntypedef VkResult (APIENTRY *PFN_vkCreateXcbSurfaceKHR)(VkInstance,const VkXcbSurfaceCreateInfoKHR*,const VkAllocationCallbacks*,VkSurfaceKHR*);\ntypedef VkBool32 (APIENTRY *PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR)(VkPhysicalDevice,uint32_t,xcb_connection_t*,xcb_visualid_t);\n\n#include \"posix_thread.h\"\n#include \"posix_time.h\"\n#include \"xkb_unicode.h\"\n#include \"glx_context.h\"\n#include \"egl_context.h\"\n#include \"osmesa_context.h\"\n#if defined(__linux__)\n#include \"linux_joystick.h\"\n#else\n#include \"null_joystick.h\"\n#endif\n\n#define _glfw_dlopen(name) dlopen(name, RTLD_LAZY | RTLD_LOCAL)\n#define _glfw_dlclose(handle) dlclose(handle)\n#define _glfw_dlsym(handle, name) dlsym(handle, name)\n\n#define _GLFW_EGL_NATIVE_WINDOW  ((EGLNativeWindowType) window->x11.handle)\n#define _GLFW_EGL_NATIVE_DISPLAY ((EGLNativeDisplayType) _glfw.x11.display)\n\n#define _GLFW_PLATFORM_WINDOW_STATE         _GLFWwindowX11  x11\n#define _GLFW_PLATFORM_LIBRARY_WINDOW_STATE _GLFWlibraryX11 x11\n#define _GLFW_PLATFORM_MONITOR_STATE        _GLFWmonitorX11 x11\n#define _GLFW_PLATFORM_CURSOR_STATE         _GLFWcursorX11  x11\n\n\n// X11-specific per-window data\n//\ntypedef struct _GLFWwindowX11\n{\n    Colormap        colormap;\n    Window          handle;\n    XIC             ic;\n\n    GLFWbool        overrideRedirect;\n    GLFWbool        iconified;\n    GLFWbool        maximized;\n\n    // Whether the visual supports framebuffer transparency\n    GLFWbool        transparent;\n\n    // Cached position and size used to filter out duplicate events\n    int             width, height;\n    int             xpos, ypos;\n\n    // The last received cursor position, regardless of source\n    int             lastCursorPosX, lastCursorPosY;\n    // The last position the cursor was warped to by GLFW\n    int             warpCursorPosX, warpCursorPosY;\n\n    // The time of the last KeyPress event\n    Time            lastKeyTime;\n\n} _GLFWwindowX11;\n\n// X11-specific global data\n//\ntypedef struct _GLFWlibraryX11\n{\n    Display*        display;\n    int             screen;\n    Window          root;\n\n    // System content scale\n    float           contentScaleX, contentScaleY;\n    // Helper window for IPC\n    Window          helperWindowHandle;\n    // Invisible cursor for hidden cursor mode\n    Cursor          hiddenCursorHandle;\n    // Context for mapping window XIDs to _GLFWwindow pointers\n    XContext        context;\n    // XIM input method\n    XIM             im;\n    // Most recent error code received by X error handler\n    int             errorCode;\n    // Primary selection string (while the primary selection is owned)\n    char*           primarySelectionString;\n    // Clipboard string (while the selection is owned)\n    char*           clipboardString;\n    // Key name string\n    char            keyName[5];\n    // X11 keycode to GLFW key LUT\n    short int       keycodes[256];\n    // GLFW key to X11 keycode LUT\n    short int       scancodes[GLFW_KEY_LAST + 1];\n    // Where to place the cursor when re-enabled\n    double          restoreCursorPosX, restoreCursorPosY;\n    // The window whose disabled cursor mode is active\n    _GLFWwindow*    disabledCursorWindow;\n\n    // Window manager atoms\n    Atom            WM_PROTOCOLS;\n    Atom            WM_STATE;\n    Atom            WM_DELETE_WINDOW;\n    Atom            NET_WM_NAME;\n    Atom            NET_WM_ICON_NAME;\n    Atom            NET_WM_ICON;\n    Atom            NET_WM_PID;\n    Atom            NET_WM_PING;\n    Atom            NET_WM_WINDOW_TYPE;\n    Atom            NET_WM_WINDOW_TYPE_NORMAL;\n    Atom            NET_WM_STATE;\n    Atom            NET_WM_STATE_ABOVE;\n    Atom            NET_WM_STATE_FULLSCREEN;\n    Atom            NET_WM_STATE_MAXIMIZED_VERT;\n    Atom            NET_WM_STATE_MAXIMIZED_HORZ;\n    Atom            NET_WM_STATE_DEMANDS_ATTENTION;\n    Atom            NET_WM_BYPASS_COMPOSITOR;\n    Atom            NET_WM_FULLSCREEN_MONITORS;\n    Atom            NET_WM_WINDOW_OPACITY;\n    Atom            NET_WM_CM_Sx;\n    Atom            NET_WORKAREA;\n    Atom            NET_CURRENT_DESKTOP;\n    Atom            NET_ACTIVE_WINDOW;\n    Atom            NET_FRAME_EXTENTS;\n    Atom            NET_REQUEST_FRAME_EXTENTS;\n    Atom            MOTIF_WM_HINTS;\n\n    // Xdnd (drag and drop) atoms\n    Atom            XdndAware;\n    Atom            XdndEnter;\n    Atom            XdndPosition;\n    Atom            XdndStatus;\n    Atom            XdndActionCopy;\n    Atom            XdndDrop;\n    Atom            XdndFinished;\n    Atom            XdndSelection;\n    Atom            XdndTypeList;\n    Atom            text_uri_list;\n\n    // Selection (clipboard) atoms\n    Atom            TARGETS;\n    Atom            MULTIPLE;\n    Atom            INCR;\n    Atom            CLIPBOARD;\n    Atom            PRIMARY;\n    Atom            CLIPBOARD_MANAGER;\n    Atom            SAVE_TARGETS;\n    Atom            NULL_;\n    Atom            UTF8_STRING;\n    Atom            COMPOUND_STRING;\n    Atom            ATOM_PAIR;\n    Atom            GLFW_SELECTION;\n\n    struct {\n        GLFWbool    available;\n        void*       handle;\n        int         eventBase;\n        int         errorBase;\n        int         major;\n        int         minor;\n        GLFWbool    gammaBroken;\n        GLFWbool    monitorBroken;\n        PFN_XRRAllocGamma AllocGamma;\n        PFN_XRRFreeCrtcInfo FreeCrtcInfo;\n        PFN_XRRFreeGamma FreeGamma;\n        PFN_XRRFreeOutputInfo FreeOutputInfo;\n        PFN_XRRFreeScreenResources FreeScreenResources;\n        PFN_XRRGetCrtcGamma GetCrtcGamma;\n        PFN_XRRGetCrtcGammaSize GetCrtcGammaSize;\n        PFN_XRRGetCrtcInfo GetCrtcInfo;\n        PFN_XRRGetOutputInfo GetOutputInfo;\n        PFN_XRRGetOutputPrimary GetOutputPrimary;\n        PFN_XRRGetScreenResourcesCurrent GetScreenResourcesCurrent;\n        PFN_XRRQueryExtension QueryExtension;\n        PFN_XRRQueryVersion QueryVersion;\n        PFN_XRRSelectInput SelectInput;\n        PFN_XRRSetCrtcConfig SetCrtcConfig;\n        PFN_XRRSetCrtcGamma SetCrtcGamma;\n        PFN_XRRUpdateConfiguration UpdateConfiguration;\n    } randr;\n\n    struct {\n        GLFWbool    available;\n        GLFWbool    detectable;\n        int         majorOpcode;\n        int         eventBase;\n        int         errorBase;\n        int         major;\n        int         minor;\n    } xkb;\n\n    struct {\n        int         count;\n        int         timeout;\n        int         interval;\n        int         blanking;\n        int         exposure;\n    } saver;\n\n    struct {\n        int         version;\n        Window      source;\n        Atom        format;\n    } xdnd;\n\n    struct {\n        void*       handle;\n        PFN_XcursorImageCreate ImageCreate;\n        PFN_XcursorImageDestroy ImageDestroy;\n        PFN_XcursorImageLoadCursor ImageLoadCursor;\n    } xcursor;\n\n    struct {\n        GLFWbool    available;\n        void*       handle;\n        int         major;\n        int         minor;\n        PFN_XineramaIsActive IsActive;\n        PFN_XineramaQueryExtension QueryExtension;\n        PFN_XineramaQueryScreens QueryScreens;\n    } xinerama;\n\n    struct {\n        void*       handle;\n        PFN_XGetXCBConnection GetXCBConnection;\n    } x11xcb;\n\n    struct {\n        GLFWbool    available;\n        void*       handle;\n        int         eventBase;\n        int         errorBase;\n        PFN_XF86VidModeQueryExtension QueryExtension;\n        PFN_XF86VidModeGetGammaRamp GetGammaRamp;\n        PFN_XF86VidModeSetGammaRamp SetGammaRamp;\n        PFN_XF86VidModeGetGammaRampSize GetGammaRampSize;\n    } vidmode;\n\n    struct {\n        GLFWbool    available;\n        void*       handle;\n        int         majorOpcode;\n        int         eventBase;\n        int         errorBase;\n        int         major;\n        int         minor;\n        PFN_XIQueryVersion QueryVersion;\n        PFN_XISelectEvents SelectEvents;\n    } xi;\n\n    struct {\n        GLFWbool    available;\n        void*       handle;\n        int         major;\n        int         minor;\n        int         eventBase;\n        int         errorBase;\n        PFN_XRenderQueryExtension QueryExtension;\n        PFN_XRenderQueryVersion QueryVersion;\n        PFN_XRenderFindVisualFormat FindVisualFormat;\n    } xrender;\n\n} _GLFWlibraryX11;\n\n// X11-specific per-monitor data\n//\ntypedef struct _GLFWmonitorX11\n{\n    RROutput        output;\n    RRCrtc          crtc;\n    RRMode          oldMode;\n\n    // Index of corresponding Xinerama screen,\n    // for EWMH full screen window placement\n    int             index;\n\n} _GLFWmonitorX11;\n\n// X11-specific per-cursor data\n//\ntypedef struct _GLFWcursorX11\n{\n    Cursor handle;\n\n} _GLFWcursorX11;\n\n\nvoid _glfwPollMonitorsX11(void);\nvoid _glfwSetVideoModeX11(_GLFWmonitor* monitor, const GLFWvidmode* desired);\nvoid _glfwRestoreVideoModeX11(_GLFWmonitor* monitor);\n\nCursor _glfwCreateCursorX11(const GLFWimage* image, int xhot, int yhot);\n\nunsigned long _glfwGetWindowPropertyX11(Window window,\n                                        Atom property,\n                                        Atom type,\n                                        unsigned char** value);\nGLFWbool _glfwIsVisualTransparentX11(Visual* visual);\n\nvoid _glfwGrabErrorHandlerX11(void);\nvoid _glfwReleaseErrorHandlerX11(void);\nvoid _glfwInputErrorX11(int error, const char* message);\n\nvoid _glfwPushSelectionToManagerX11(void);\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-glfw-3.3-2fza4cb74pcte44nu2vbzw4ag2osew7l/spack-src/src/null_platform.h": "//========================================================================\n// GLFW 3.3 - www.glfw.org\n//------------------------------------------------------------------------\n// Copyright (c) 2016 Google Inc.\n// Copyright (c) 2016-2017 Camilla L\u00f6wy <elmindreda@glfw.org>\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would\n//    be appreciated but is not required.\n//\n// 2. Altered source versions must be plainly marked as such, and must not\n//    be misrepresented as being the original software.\n//\n// 3. This notice may not be removed or altered from any source\n//    distribution.\n//\n//========================================================================\n\n#include <dlfcn.h>\n\n#define _GLFW_PLATFORM_WINDOW_STATE _GLFWwindowNull null\n\n#define _GLFW_PLATFORM_CONTEXT_STATE\n#define _GLFW_PLATFORM_MONITOR_STATE\n#define _GLFW_PLATFORM_CURSOR_STATE\n#define _GLFW_PLATFORM_LIBRARY_WINDOW_STATE\n#define _GLFW_PLATFORM_LIBRARY_CONTEXT_STATE\n#define _GLFW_EGL_CONTEXT_STATE\n#define _GLFW_EGL_LIBRARY_CONTEXT_STATE\n\n#include \"osmesa_context.h\"\n#include \"posix_time.h\"\n#include \"posix_thread.h\"\n#include \"null_joystick.h\"\n\n#if defined(_GLFW_WIN32)\n #define _glfw_dlopen(name) LoadLibraryA(name)\n #define _glfw_dlclose(handle) FreeLibrary((HMODULE) handle)\n #define _glfw_dlsym(handle, name) GetProcAddress((HMODULE) handle, name)\n#else\n #define _glfw_dlopen(name) dlopen(name, RTLD_LAZY | RTLD_LOCAL)\n #define _glfw_dlclose(handle) dlclose(handle)\n #define _glfw_dlsym(handle, name) dlsym(handle, name)\n#endif\n\n// Null-specific per-window data\n//\ntypedef struct _GLFWwindowNull\n{\n    int width;\n    int height;\n} _GLFWwindowNull;\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-glfw-3.3-2fza4cb74pcte44nu2vbzw4ag2osew7l/spack-src/src/vulkan.c": "//========================================================================\n// GLFW 3.3 - www.glfw.org\n//------------------------------------------------------------------------\n// Copyright (c) 2002-2006 Marcus Geelnard\n// Copyright (c) 2006-2018 Camilla L\u00f6wy <elmindreda@glfw.org>\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would\n//    be appreciated but is not required.\n//\n// 2. Altered source versions must be plainly marked as such, and must not\n//    be misrepresented as being the original software.\n//\n// 3. This notice may not be removed or altered from any source\n//    distribution.\n//\n//========================================================================\n\n#include \"internal.h\"\n\n#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define _GLFW_FIND_LOADER    1\n#define _GLFW_REQUIRE_LOADER 2\n\n\n//////////////////////////////////////////////////////////////////////////\n//////                       GLFW internal API                      //////\n//////////////////////////////////////////////////////////////////////////\n\nGLFWbool _glfwInitVulkan(int mode)\n{\n    VkResult err;\n    VkExtensionProperties* ep;\n    uint32_t i, count;\n\n    if (_glfw.vk.available)\n        return GLFW_TRUE;\n\n#if !defined(_GLFW_VULKAN_STATIC)\n#if defined(_GLFW_VULKAN_LIBRARY)\n    _glfw.vk.handle = _glfw_dlopen(_GLFW_VULKAN_LIBRARY);\n#elif defined(_GLFW_WIN32)\n    _glfw.vk.handle = _glfw_dlopen(\"vulkan-1.dll\");\n#elif defined(_GLFW_COCOA)\n    _glfw.vk.handle = _glfw_dlopen(\"libvulkan.1.dylib\");\n#else\n    _glfw.vk.handle = _glfw_dlopen(\"libvulkan.so.1\");\n#endif\n    if (!_glfw.vk.handle)\n    {\n        if (mode == _GLFW_REQUIRE_LOADER)\n            _glfwInputError(GLFW_API_UNAVAILABLE, \"Vulkan: Loader not found\");\n\n        return GLFW_FALSE;\n    }\n\n    _glfw.vk.GetInstanceProcAddr = (PFN_vkGetInstanceProcAddr)\n        _glfw_dlsym(_glfw.vk.handle, \"vkGetInstanceProcAddr\");\n    if (!_glfw.vk.GetInstanceProcAddr)\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE,\n                        \"Vulkan: Loader does not export vkGetInstanceProcAddr\");\n\n        _glfwTerminateVulkan();\n        return GLFW_FALSE;\n    }\n\n    _glfw.vk.EnumerateInstanceExtensionProperties = (PFN_vkEnumerateInstanceExtensionProperties)\n        vkGetInstanceProcAddr(NULL, \"vkEnumerateInstanceExtensionProperties\");\n    if (!_glfw.vk.EnumerateInstanceExtensionProperties)\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE,\n                        \"Vulkan: Failed to retrieve vkEnumerateInstanceExtensionProperties\");\n\n        _glfwTerminateVulkan();\n        return GLFW_FALSE;\n    }\n#endif // _GLFW_VULKAN_STATIC\n\n    err = vkEnumerateInstanceExtensionProperties(NULL, &count, NULL);\n    if (err)\n    {\n        // NOTE: This happens on systems with a loader but without any Vulkan ICD\n        if (mode == _GLFW_REQUIRE_LOADER)\n        {\n            _glfwInputError(GLFW_API_UNAVAILABLE,\n                            \"Vulkan: Failed to query instance extension count: %s\",\n                            _glfwGetVulkanResultString(err));\n        }\n\n        _glfwTerminateVulkan();\n        return GLFW_FALSE;\n    }\n\n    ep = calloc(count, sizeof(VkExtensionProperties));\n\n    err = vkEnumerateInstanceExtensionProperties(NULL, &count, ep);\n    if (err)\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE,\n                        \"Vulkan: Failed to query instance extensions: %s\",\n                        _glfwGetVulkanResultString(err));\n\n        free(ep);\n        _glfwTerminateVulkan();\n        return GLFW_FALSE;\n    }\n\n    for (i = 0;  i < count;  i++)\n    {\n        if (strcmp(ep[i].extensionName, \"VK_KHR_surface\") == 0)\n            _glfw.vk.KHR_surface = GLFW_TRUE;\n#if defined(_GLFW_WIN32)\n        else if (strcmp(ep[i].extensionName, \"VK_KHR_win32_surface\") == 0)\n            _glfw.vk.KHR_win32_surface = GLFW_TRUE;\n#elif defined(_GLFW_COCOA)\n        else if (strcmp(ep[i].extensionName, \"VK_MVK_macos_surface\") == 0)\n            _glfw.vk.MVK_macos_surface = GLFW_TRUE;\n#elif defined(_GLFW_X11)\n        else if (strcmp(ep[i].extensionName, \"VK_KHR_xlib_surface\") == 0)\n            _glfw.vk.KHR_xlib_surface = GLFW_TRUE;\n        else if (strcmp(ep[i].extensionName, \"VK_KHR_xcb_surface\") == 0)\n            _glfw.vk.KHR_xcb_surface = GLFW_TRUE;\n#elif defined(_GLFW_WAYLAND)\n        else if (strcmp(ep[i].extensionName, \"VK_KHR_wayland_surface\") == 0)\n            _glfw.vk.KHR_wayland_surface = GLFW_TRUE;\n#endif\n    }\n\n    free(ep);\n\n    _glfw.vk.available = GLFW_TRUE;\n\n    _glfwPlatformGetRequiredInstanceExtensions(_glfw.vk.extensions);\n\n    return GLFW_TRUE;\n}\n\nvoid _glfwTerminateVulkan(void)\n{\n#if !defined(_GLFW_VULKAN_STATIC)\n    if (_glfw.vk.handle)\n        _glfw_dlclose(_glfw.vk.handle);\n#endif\n}\n\nconst char* _glfwGetVulkanResultString(VkResult result)\n{\n    switch (result)\n    {\n        case VK_SUCCESS:\n            return \"Success\";\n        case VK_NOT_READY:\n            return \"A fence or query has not yet completed\";\n        case VK_TIMEOUT:\n            return \"A wait operation has not completed in the specified time\";\n        case VK_EVENT_SET:\n            return \"An event is signaled\";\n        case VK_EVENT_RESET:\n            return \"An event is unsignaled\";\n        case VK_INCOMPLETE:\n            return \"A return array was too small for the result\";\n        case VK_ERROR_OUT_OF_HOST_MEMORY:\n            return \"A host memory allocation has failed\";\n        case VK_ERROR_OUT_OF_DEVICE_MEMORY:\n            return \"A device memory allocation has failed\";\n        case VK_ERROR_INITIALIZATION_FAILED:\n            return \"Initialization of an object could not be completed for implementation-specific reasons\";\n        case VK_ERROR_DEVICE_LOST:\n            return \"The logical or physical device has been lost\";\n        case VK_ERROR_MEMORY_MAP_FAILED:\n            return \"Mapping of a memory object has failed\";\n        case VK_ERROR_LAYER_NOT_PRESENT:\n            return \"A requested layer is not present or could not be loaded\";\n        case VK_ERROR_EXTENSION_NOT_PRESENT:\n            return \"A requested extension is not supported\";\n        case VK_ERROR_FEATURE_NOT_PRESENT:\n            return \"A requested feature is not supported\";\n        case VK_ERROR_INCOMPATIBLE_DRIVER:\n            return \"The requested version of Vulkan is not supported by the driver or is otherwise incompatible\";\n        case VK_ERROR_TOO_MANY_OBJECTS:\n            return \"Too many objects of the type have already been created\";\n        case VK_ERROR_FORMAT_NOT_SUPPORTED:\n            return \"A requested format is not supported on this device\";\n        case VK_ERROR_SURFACE_LOST_KHR:\n            return \"A surface is no longer available\";\n        case VK_SUBOPTIMAL_KHR:\n            return \"A swapchain no longer matches the surface properties exactly, but can still be used\";\n        case VK_ERROR_OUT_OF_DATE_KHR:\n            return \"A surface has changed in such a way that it is no longer compatible with the swapchain\";\n        case VK_ERROR_INCOMPATIBLE_DISPLAY_KHR:\n            return \"The display used by a swapchain does not use the same presentable image layout\";\n        case VK_ERROR_NATIVE_WINDOW_IN_USE_KHR:\n            return \"The requested window is already connected to a VkSurfaceKHR, or to some other non-Vulkan API\";\n        case VK_ERROR_VALIDATION_FAILED_EXT:\n            return \"A validation layer found an error\";\n        default:\n            return \"ERROR: UNKNOWN VULKAN ERROR\";\n    }\n}\n\n\n//////////////////////////////////////////////////////////////////////////\n//////                        GLFW public API                       //////\n//////////////////////////////////////////////////////////////////////////\n\nGLFWAPI int glfwVulkanSupported(void)\n{\n    _GLFW_REQUIRE_INIT_OR_RETURN(GLFW_FALSE);\n    return _glfwInitVulkan(_GLFW_FIND_LOADER);\n}\n\nGLFWAPI const char** glfwGetRequiredInstanceExtensions(uint32_t* count)\n{\n    assert(count != NULL);\n\n    *count = 0;\n\n    _GLFW_REQUIRE_INIT_OR_RETURN(NULL);\n\n    if (!_glfwInitVulkan(_GLFW_REQUIRE_LOADER))\n        return NULL;\n\n    if (!_glfw.vk.extensions[0])\n        return NULL;\n\n    *count = 2;\n    return (const char**) _glfw.vk.extensions;\n}\n\nGLFWAPI GLFWvkproc glfwGetInstanceProcAddress(VkInstance instance,\n                                              const char* procname)\n{\n    GLFWvkproc proc;\n    assert(procname != NULL);\n\n    _GLFW_REQUIRE_INIT_OR_RETURN(NULL);\n\n    if (!_glfwInitVulkan(_GLFW_REQUIRE_LOADER))\n        return NULL;\n\n    proc = (GLFWvkproc) vkGetInstanceProcAddr(instance, procname);\n#if defined(_GLFW_VULKAN_STATIC)\n    if (!proc)\n    {\n        if (strcmp(procname, \"vkGetInstanceProcAddr\") == 0)\n            return (GLFWvkproc) vkGetInstanceProcAddr;\n    }\n#else\n    if (!proc)\n        proc = (GLFWvkproc) _glfw_dlsym(_glfw.vk.handle, procname);\n#endif\n\n    return proc;\n}\n\nGLFWAPI int glfwGetPhysicalDevicePresentationSupport(VkInstance instance,\n                                                     VkPhysicalDevice device,\n                                                     uint32_t queuefamily)\n{\n    assert(instance != VK_NULL_HANDLE);\n    assert(device != VK_NULL_HANDLE);\n\n    _GLFW_REQUIRE_INIT_OR_RETURN(GLFW_FALSE);\n\n    if (!_glfwInitVulkan(_GLFW_REQUIRE_LOADER))\n        return GLFW_FALSE;\n\n    if (!_glfw.vk.extensions[0])\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE,\n                        \"Vulkan: Window surface creation extensions not found\");\n        return GLFW_FALSE;\n    }\n\n    return _glfwPlatformGetPhysicalDevicePresentationSupport(instance,\n                                                             device,\n                                                             queuefamily);\n}\n\nGLFWAPI VkResult glfwCreateWindowSurface(VkInstance instance,\n                                         GLFWwindow* handle,\n                                         const VkAllocationCallbacks* allocator,\n                                         VkSurfaceKHR* surface)\n{\n    _GLFWwindow* window = (_GLFWwindow*) handle;\n    assert(instance != VK_NULL_HANDLE);\n    assert(window != NULL);\n    assert(surface != NULL);\n\n    *surface = VK_NULL_HANDLE;\n\n    _GLFW_REQUIRE_INIT_OR_RETURN(VK_ERROR_INITIALIZATION_FAILED);\n\n    if (!_glfwInitVulkan(_GLFW_REQUIRE_LOADER))\n        return VK_ERROR_INITIALIZATION_FAILED;\n\n    if (!_glfw.vk.extensions[0])\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE,\n                        \"Vulkan: Window surface creation extensions not found\");\n        return VK_ERROR_EXTENSION_NOT_PRESENT;\n    }\n\n    if (window->context.client != GLFW_NO_API)\n    {\n        _glfwInputError(GLFW_INVALID_VALUE,\n                        \"Vulkan: Window surface creation requires the window to have the client API set to GLFW_NO_API\");\n        return VK_ERROR_NATIVE_WINDOW_IN_USE_KHR;\n    }\n\n    return _glfwPlatformCreateWindowSurface(instance, window, allocator, surface);\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-glfw-3.3-2fza4cb74pcte44nu2vbzw4ag2osew7l/spack-src/src/win32_platform.h": "//========================================================================\n// GLFW 3.3 Win32 - www.glfw.org\n//------------------------------------------------------------------------\n// Copyright (c) 2002-2006 Marcus Geelnard\n// Copyright (c) 2006-2019 Camilla L\u00f6wy <elmindreda@glfw.org>\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would\n//    be appreciated but is not required.\n//\n// 2. Altered source versions must be plainly marked as such, and must not\n//    be misrepresented as being the original software.\n//\n// 3. This notice may not be removed or altered from any source\n//    distribution.\n//\n//========================================================================\n\n// We don't need all the fancy stuff\n#ifndef NOMINMAX\n #define NOMINMAX\n#endif\n\n#ifndef VC_EXTRALEAN\n #define VC_EXTRALEAN\n#endif\n\n#ifndef WIN32_LEAN_AND_MEAN\n #define WIN32_LEAN_AND_MEAN\n#endif\n\n// This is a workaround for the fact that glfw3.h needs to export APIENTRY (for\n// example to allow applications to correctly declare a GL_ARB_debug_output\n// callback) but windows.h assumes no one will define APIENTRY before it does\n#undef APIENTRY\n\n// GLFW on Windows is Unicode only and does not work in MBCS mode\n#ifndef UNICODE\n #define UNICODE\n#endif\n\n// GLFW requires Windows XP or later\n#if WINVER < 0x0501\n #undef WINVER\n #define WINVER 0x0501\n#endif\n#if _WIN32_WINNT < 0x0501\n #undef _WIN32_WINNT\n #define _WIN32_WINNT 0x0501\n#endif\n\n// GLFW uses DirectInput8 interfaces\n#define DIRECTINPUT_VERSION 0x0800\n\n// GLFW uses OEM cursor resources\n#define OEMRESOURCE\n\n#include <wctype.h>\n#include <windows.h>\n#include <dinput.h>\n#include <xinput.h>\n#include <dbt.h>\n\n// HACK: Define macros that some windows.h variants don't\n#ifndef WM_MOUSEHWHEEL\n #define WM_MOUSEHWHEEL 0x020E\n#endif\n#ifndef WM_DWMCOMPOSITIONCHANGED\n #define WM_DWMCOMPOSITIONCHANGED 0x031E\n#endif\n#ifndef WM_COPYGLOBALDATA\n #define WM_COPYGLOBALDATA 0x0049\n#endif\n#ifndef WM_UNICHAR\n #define WM_UNICHAR 0x0109\n#endif\n#ifndef UNICODE_NOCHAR\n #define UNICODE_NOCHAR 0xFFFF\n#endif\n#ifndef WM_DPICHANGED\n #define WM_DPICHANGED 0x02E0\n#endif\n#ifndef GET_XBUTTON_WPARAM\n #define GET_XBUTTON_WPARAM(w) (HIWORD(w))\n#endif\n#ifndef EDS_ROTATEDMODE\n #define EDS_ROTATEDMODE 0x00000004\n#endif\n#ifndef DISPLAY_DEVICE_ACTIVE\n #define DISPLAY_DEVICE_ACTIVE 0x00000001\n#endif\n#ifndef _WIN32_WINNT_WINBLUE\n #define _WIN32_WINNT_WINBLUE 0x0602\n#endif\n#ifndef _WIN32_WINNT_WIN8\n #define _WIN32_WINNT_WIN8 0x0602\n#endif\n#ifndef WM_GETDPISCALEDSIZE\n #define WM_GETDPISCALEDSIZE 0x02e4\n#endif\n#ifndef USER_DEFAULT_SCREEN_DPI\n #define USER_DEFAULT_SCREEN_DPI 96\n#endif\n#ifndef OCR_HAND\n #define OCR_HAND 32649\n#endif\n\n#if WINVER < 0x0601\ntypedef struct\n{\n    DWORD cbSize;\n    DWORD ExtStatus;\n} CHANGEFILTERSTRUCT;\n#ifndef MSGFLT_ALLOW\n #define MSGFLT_ALLOW 1\n#endif\n#endif /*Windows 7*/\n\n#if WINVER < 0x0600\n#define DWM_BB_ENABLE 0x00000001\n#define DWM_BB_BLURREGION 0x00000002\ntypedef struct\n{\n    DWORD dwFlags;\n    BOOL fEnable;\n    HRGN hRgnBlur;\n    BOOL fTransitionOnMaximized;\n} DWM_BLURBEHIND;\n#else\n #include <dwmapi.h>\n#endif /*Windows Vista*/\n\n#ifndef DPI_ENUMS_DECLARED\ntypedef enum\n{\n    PROCESS_DPI_UNAWARE = 0,\n    PROCESS_SYSTEM_DPI_AWARE = 1,\n    PROCESS_PER_MONITOR_DPI_AWARE = 2\n} PROCESS_DPI_AWARENESS;\ntypedef enum\n{\n    MDT_EFFECTIVE_DPI = 0,\n    MDT_ANGULAR_DPI = 1,\n    MDT_RAW_DPI = 2,\n    MDT_DEFAULT = MDT_EFFECTIVE_DPI\n} MONITOR_DPI_TYPE;\n#endif /*DPI_ENUMS_DECLARED*/\n\n#ifndef DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2\n#define DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2 ((HANDLE) -4)\n#endif /*DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2*/\n\n// HACK: Define versionhelpers.h functions manually as MinGW lacks the header\n#define IsWindowsXPOrGreater()                                 \\\n    _glfwIsWindowsVersionOrGreaterWin32(HIBYTE(_WIN32_WINNT_WINXP),   \\\n                                        LOBYTE(_WIN32_WINNT_WINXP), 0)\n#define IsWindowsVistaOrGreater()                                     \\\n    _glfwIsWindowsVersionOrGreaterWin32(HIBYTE(_WIN32_WINNT_VISTA),   \\\n                                        LOBYTE(_WIN32_WINNT_VISTA), 0)\n#define IsWindows7OrGreater()                                         \\\n    _glfwIsWindowsVersionOrGreaterWin32(HIBYTE(_WIN32_WINNT_WIN7),    \\\n                                        LOBYTE(_WIN32_WINNT_WIN7), 0)\n#define IsWindows8OrGreater()                                         \\\n    _glfwIsWindowsVersionOrGreaterWin32(HIBYTE(_WIN32_WINNT_WIN8),    \\\n                                        LOBYTE(_WIN32_WINNT_WIN8), 0)\n#define IsWindows8Point1OrGreater()                                   \\\n    _glfwIsWindowsVersionOrGreaterWin32(HIBYTE(_WIN32_WINNT_WINBLUE), \\\n                                        LOBYTE(_WIN32_WINNT_WINBLUE), 0)\n\n#define _glfwIsWindows10AnniversaryUpdateOrGreaterWin32() \\\n    _glfwIsWindows10BuildOrGreaterWin32(14393)\n#define _glfwIsWindows10CreatorsUpdateOrGreaterWin32() \\\n    _glfwIsWindows10BuildOrGreaterWin32(15063)\n\n// HACK: Define macros that some xinput.h variants don't\n#ifndef XINPUT_CAPS_WIRELESS\n #define XINPUT_CAPS_WIRELESS 0x0002\n#endif\n#ifndef XINPUT_DEVSUBTYPE_WHEEL\n #define XINPUT_DEVSUBTYPE_WHEEL 0x02\n#endif\n#ifndef XINPUT_DEVSUBTYPE_ARCADE_STICK\n #define XINPUT_DEVSUBTYPE_ARCADE_STICK 0x03\n#endif\n#ifndef XINPUT_DEVSUBTYPE_FLIGHT_STICK\n #define XINPUT_DEVSUBTYPE_FLIGHT_STICK 0x04\n#endif\n#ifndef XINPUT_DEVSUBTYPE_DANCE_PAD\n #define XINPUT_DEVSUBTYPE_DANCE_PAD 0x05\n#endif\n#ifndef XINPUT_DEVSUBTYPE_GUITAR\n #define XINPUT_DEVSUBTYPE_GUITAR 0x06\n#endif\n#ifndef XINPUT_DEVSUBTYPE_DRUM_KIT\n #define XINPUT_DEVSUBTYPE_DRUM_KIT 0x08\n#endif\n#ifndef XINPUT_DEVSUBTYPE_ARCADE_PAD\n #define XINPUT_DEVSUBTYPE_ARCADE_PAD 0x13\n#endif\n#ifndef XUSER_MAX_COUNT\n #define XUSER_MAX_COUNT 4\n#endif\n\n// HACK: Define macros that some dinput.h variants don't\n#ifndef DIDFT_OPTIONAL\n #define DIDFT_OPTIONAL\t0x80000000\n#endif\n\n// winmm.dll function pointer typedefs\ntypedef DWORD (WINAPI * PFN_timeGetTime)(void);\n#define timeGetTime _glfw.win32.winmm.GetTime\n\n// xinput.dll function pointer typedefs\ntypedef DWORD (WINAPI * PFN_XInputGetCapabilities)(DWORD,DWORD,XINPUT_CAPABILITIES*);\ntypedef DWORD (WINAPI * PFN_XInputGetState)(DWORD,XINPUT_STATE*);\n#define XInputGetCapabilities _glfw.win32.xinput.GetCapabilities\n#define XInputGetState _glfw.win32.xinput.GetState\n\n// dinput8.dll function pointer typedefs\ntypedef HRESULT (WINAPI * PFN_DirectInput8Create)(HINSTANCE,DWORD,REFIID,LPVOID*,LPUNKNOWN);\n#define DirectInput8Create _glfw.win32.dinput8.Create\n\n// user32.dll function pointer typedefs\ntypedef BOOL (WINAPI * PFN_SetProcessDPIAware)(void);\ntypedef BOOL (WINAPI * PFN_ChangeWindowMessageFilterEx)(HWND,UINT,DWORD,CHANGEFILTERSTRUCT*);\ntypedef BOOL (WINAPI * PFN_EnableNonClientDpiScaling)(HWND);\ntypedef BOOL (WINAPI * PFN_SetProcessDpiAwarenessContext)(HANDLE);\ntypedef UINT (WINAPI * PFN_GetDpiForWindow)(HWND);\ntypedef BOOL (WINAPI * PFN_AdjustWindowRectExForDpi)(LPRECT,DWORD,BOOL,DWORD,UINT);\n#define SetProcessDPIAware _glfw.win32.user32.SetProcessDPIAware_\n#define ChangeWindowMessageFilterEx _glfw.win32.user32.ChangeWindowMessageFilterEx_\n#define EnableNonClientDpiScaling _glfw.win32.user32.EnableNonClientDpiScaling_\n#define SetProcessDpiAwarenessContext _glfw.win32.user32.SetProcessDpiAwarenessContext_\n#define GetDpiForWindow _glfw.win32.user32.GetDpiForWindow_\n#define AdjustWindowRectExForDpi _glfw.win32.user32.AdjustWindowRectExForDpi_\n\n// dwmapi.dll function pointer typedefs\ntypedef HRESULT (WINAPI * PFN_DwmIsCompositionEnabled)(BOOL*);\ntypedef HRESULT (WINAPI * PFN_DwmFlush)(VOID);\ntypedef HRESULT(WINAPI * PFN_DwmEnableBlurBehindWindow)(HWND,const DWM_BLURBEHIND*);\n#define DwmIsCompositionEnabled _glfw.win32.dwmapi.IsCompositionEnabled\n#define DwmFlush _glfw.win32.dwmapi.Flush\n#define DwmEnableBlurBehindWindow _glfw.win32.dwmapi.EnableBlurBehindWindow\n\n// shcore.dll function pointer typedefs\ntypedef HRESULT (WINAPI * PFN_SetProcessDpiAwareness)(PROCESS_DPI_AWARENESS);\ntypedef HRESULT (WINAPI * PFN_GetDpiForMonitor)(HMONITOR,MONITOR_DPI_TYPE,UINT*,UINT*);\n#define SetProcessDpiAwareness _glfw.win32.shcore.SetProcessDpiAwareness_\n#define GetDpiForMonitor _glfw.win32.shcore.GetDpiForMonitor_\n\n// ntdll.dll function pointer typedefs\ntypedef LONG (WINAPI * PFN_RtlVerifyVersionInfo)(OSVERSIONINFOEXW*,ULONG,ULONGLONG);\n#define RtlVerifyVersionInfo _glfw.win32.ntdll.RtlVerifyVersionInfo_\n\ntypedef VkFlags VkWin32SurfaceCreateFlagsKHR;\n\ntypedef struct VkWin32SurfaceCreateInfoKHR\n{\n    VkStructureType                 sType;\n    const void*                     pNext;\n    VkWin32SurfaceCreateFlagsKHR    flags;\n    HINSTANCE                       hinstance;\n    HWND                            hwnd;\n} VkWin32SurfaceCreateInfoKHR;\n\ntypedef VkResult (APIENTRY *PFN_vkCreateWin32SurfaceKHR)(VkInstance,const VkWin32SurfaceCreateInfoKHR*,const VkAllocationCallbacks*,VkSurfaceKHR*);\ntypedef VkBool32 (APIENTRY *PFN_vkGetPhysicalDeviceWin32PresentationSupportKHR)(VkPhysicalDevice,uint32_t);\n\n#include \"win32_joystick.h\"\n#include \"wgl_context.h\"\n#include \"egl_context.h\"\n#include \"osmesa_context.h\"\n\n#if !defined(_GLFW_WNDCLASSNAME)\n #define _GLFW_WNDCLASSNAME L\"GLFW30\"\n#endif\n\n#define _glfw_dlopen(name) LoadLibraryA(name)\n#define _glfw_dlclose(handle) FreeLibrary((HMODULE) handle)\n#define _glfw_dlsym(handle, name) GetProcAddress((HMODULE) handle, name)\n\n#define _GLFW_EGL_NATIVE_WINDOW  ((EGLNativeWindowType) window->win32.handle)\n#define _GLFW_EGL_NATIVE_DISPLAY EGL_DEFAULT_DISPLAY\n\n#define _GLFW_PLATFORM_WINDOW_STATE         _GLFWwindowWin32  win32\n#define _GLFW_PLATFORM_LIBRARY_WINDOW_STATE _GLFWlibraryWin32 win32\n#define _GLFW_PLATFORM_LIBRARY_TIMER_STATE  _GLFWtimerWin32   win32\n#define _GLFW_PLATFORM_MONITOR_STATE        _GLFWmonitorWin32 win32\n#define _GLFW_PLATFORM_CURSOR_STATE         _GLFWcursorWin32  win32\n#define _GLFW_PLATFORM_TLS_STATE            _GLFWtlsWin32     win32\n#define _GLFW_PLATFORM_MUTEX_STATE          _GLFWmutexWin32   win32\n\n\n// Win32-specific per-window data\n//\ntypedef struct _GLFWwindowWin32\n{\n    HWND                handle;\n    HICON               bigIcon;\n    HICON               smallIcon;\n\n    GLFWbool            cursorTracked;\n    GLFWbool            frameAction;\n    GLFWbool            iconified;\n    GLFWbool            maximized;\n    // Whether to enable framebuffer transparency on DWM\n    GLFWbool            transparent;\n    GLFWbool            scaleToMonitor;\n\n    // The last received cursor position, regardless of source\n    int                 lastCursorPosX, lastCursorPosY;\n\n} _GLFWwindowWin32;\n\n// Win32-specific global data\n//\ntypedef struct _GLFWlibraryWin32\n{\n    HWND                helperWindowHandle;\n    HDEVNOTIFY          deviceNotificationHandle;\n    DWORD               foregroundLockTimeout;\n    int                 acquiredMonitorCount;\n    char*               clipboardString;\n    short int           keycodes[512];\n    short int           scancodes[GLFW_KEY_LAST + 1];\n    char                keynames[GLFW_KEY_LAST + 1][5];\n    // Where to place the cursor when re-enabled\n    double              restoreCursorPosX, restoreCursorPosY;\n    // The window whose disabled cursor mode is active\n    _GLFWwindow*        disabledCursorWindow;\n    RAWINPUT*           rawInput;\n    int                 rawInputSize;\n    UINT                mouseTrailSize;\n\n    struct {\n        HINSTANCE                       instance;\n        PFN_timeGetTime                 GetTime;\n    } winmm;\n\n    struct {\n        HINSTANCE                       instance;\n        PFN_DirectInput8Create          Create;\n        IDirectInput8W*                 api;\n    } dinput8;\n\n    struct {\n        HINSTANCE                       instance;\n        PFN_XInputGetCapabilities       GetCapabilities;\n        PFN_XInputGetState              GetState;\n    } xinput;\n\n    struct {\n        HINSTANCE                       instance;\n        PFN_SetProcessDPIAware          SetProcessDPIAware_;\n        PFN_ChangeWindowMessageFilterEx ChangeWindowMessageFilterEx_;\n        PFN_EnableNonClientDpiScaling   EnableNonClientDpiScaling_;\n        PFN_SetProcessDpiAwarenessContext SetProcessDpiAwarenessContext_;\n        PFN_GetDpiForWindow             GetDpiForWindow_;\n        PFN_AdjustWindowRectExForDpi    AdjustWindowRectExForDpi_;\n    } user32;\n\n    struct {\n        HINSTANCE                       instance;\n        PFN_DwmIsCompositionEnabled     IsCompositionEnabled;\n        PFN_DwmFlush                    Flush;\n        PFN_DwmEnableBlurBehindWindow   EnableBlurBehindWindow;\n    } dwmapi;\n\n    struct {\n        HINSTANCE                       instance;\n        PFN_SetProcessDpiAwareness      SetProcessDpiAwareness_;\n        PFN_GetDpiForMonitor            GetDpiForMonitor_;\n    } shcore;\n\n    struct {\n        HINSTANCE                       instance;\n        PFN_RtlVerifyVersionInfo        RtlVerifyVersionInfo_;\n    } ntdll;\n\n} _GLFWlibraryWin32;\n\n// Win32-specific per-monitor data\n//\ntypedef struct _GLFWmonitorWin32\n{\n    HMONITOR            handle;\n    // This size matches the static size of DISPLAY_DEVICE.DeviceName\n    WCHAR               adapterName[32];\n    WCHAR               displayName[32];\n    char                publicAdapterName[32];\n    char                publicDisplayName[32];\n    GLFWbool            modesPruned;\n    GLFWbool            modeChanged;\n\n} _GLFWmonitorWin32;\n\n// Win32-specific per-cursor data\n//\ntypedef struct _GLFWcursorWin32\n{\n    HCURSOR             handle;\n\n} _GLFWcursorWin32;\n\n// Win32-specific global timer data\n//\ntypedef struct _GLFWtimerWin32\n{\n    GLFWbool            hasPC;\n    uint64_t            frequency;\n\n} _GLFWtimerWin32;\n\n// Win32-specific thread local storage data\n//\ntypedef struct _GLFWtlsWin32\n{\n    GLFWbool            allocated;\n    DWORD               index;\n\n} _GLFWtlsWin32;\n\n// Win32-specific mutex data\n//\ntypedef struct _GLFWmutexWin32\n{\n    GLFWbool            allocated;\n    CRITICAL_SECTION    section;\n\n} _GLFWmutexWin32;\n\n\nGLFWbool _glfwRegisterWindowClassWin32(void);\nvoid _glfwUnregisterWindowClassWin32(void);\n\nWCHAR* _glfwCreateWideStringFromUTF8Win32(const char* source);\nchar* _glfwCreateUTF8FromWideStringWin32(const WCHAR* source);\nBOOL _glfwIsWindowsVersionOrGreaterWin32(WORD major, WORD minor, WORD sp);\nBOOL _glfwIsWindows10BuildOrGreaterWin32(WORD build);\nvoid _glfwInputErrorWin32(int error, const char* description);\nvoid _glfwUpdateKeyNamesWin32(void);\n\nvoid _glfwInitTimerWin32(void);\n\nvoid _glfwPollMonitorsWin32(void);\nvoid _glfwSetVideoModeWin32(_GLFWmonitor* monitor, const GLFWvidmode* desired);\nvoid _glfwRestoreVideoModeWin32(_GLFWmonitor* monitor);\nvoid _glfwGetMonitorContentScaleWin32(HMONITOR handle, float* xscale, float* yscale);\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-glfw-3.3-2fza4cb74pcte44nu2vbzw4ag2osew7l/spack-src/src/glx_context.c": "//========================================================================\n// GLFW 3.3 GLX - www.glfw.org\n//------------------------------------------------------------------------\n// Copyright (c) 2002-2006 Marcus Geelnard\n// Copyright (c) 2006-2019 Camilla L\u00f6wy <elmindreda@glfw.org>\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would\n//    be appreciated but is not required.\n//\n// 2. Altered source versions must be plainly marked as such, and must not\n//    be misrepresented as being the original software.\n//\n// 3. This notice may not be removed or altered from any source\n//    distribution.\n//\n//========================================================================\n\n#include \"internal.h\"\n\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n\n#ifndef GLXBadProfileARB\n #define GLXBadProfileARB 13\n#endif\n\n\n// Returns the specified attribute of the specified GLXFBConfig\n//\nstatic int getGLXFBConfigAttrib(GLXFBConfig fbconfig, int attrib)\n{\n    int value;\n    glXGetFBConfigAttrib(_glfw.x11.display, fbconfig, attrib, &value);\n    return value;\n}\n\n// Return the GLXFBConfig most closely matching the specified hints\n//\nstatic GLFWbool chooseGLXFBConfig(const _GLFWfbconfig* desired,\n                                  GLXFBConfig* result)\n{\n    GLXFBConfig* nativeConfigs;\n    _GLFWfbconfig* usableConfigs;\n    const _GLFWfbconfig* closest;\n    int i, nativeCount, usableCount;\n    const char* vendor;\n    GLFWbool trustWindowBit = GLFW_TRUE;\n\n    // HACK: This is a (hopefully temporary) workaround for Chromium\n    //       (VirtualBox GL) not setting the window bit on any GLXFBConfigs\n    vendor = glXGetClientString(_glfw.x11.display, GLX_VENDOR);\n    if (vendor && strcmp(vendor, \"Chromium\") == 0)\n        trustWindowBit = GLFW_FALSE;\n\n    nativeConfigs =\n        glXGetFBConfigs(_glfw.x11.display, _glfw.x11.screen, &nativeCount);\n    if (!nativeConfigs || !nativeCount)\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE, \"GLX: No GLXFBConfigs returned\");\n        return GLFW_FALSE;\n    }\n\n    usableConfigs = calloc(nativeCount, sizeof(_GLFWfbconfig));\n    usableCount = 0;\n\n    for (i = 0;  i < nativeCount;  i++)\n    {\n        const GLXFBConfig n = nativeConfigs[i];\n        _GLFWfbconfig* u = usableConfigs + usableCount;\n\n        // Only consider RGBA GLXFBConfigs\n        if (!(getGLXFBConfigAttrib(n, GLX_RENDER_TYPE) & GLX_RGBA_BIT))\n            continue;\n\n        // Only consider window GLXFBConfigs\n        if (!(getGLXFBConfigAttrib(n, GLX_DRAWABLE_TYPE) & GLX_WINDOW_BIT))\n        {\n            if (trustWindowBit)\n                continue;\n        }\n\n        if (desired->transparent)\n        {\n            XVisualInfo* vi = glXGetVisualFromFBConfig(_glfw.x11.display, n);\n            if (vi)\n            {\n                u->transparent = _glfwIsVisualTransparentX11(vi->visual);\n                XFree(vi);\n            }\n        }\n\n        u->redBits = getGLXFBConfigAttrib(n, GLX_RED_SIZE);\n        u->greenBits = getGLXFBConfigAttrib(n, GLX_GREEN_SIZE);\n        u->blueBits = getGLXFBConfigAttrib(n, GLX_BLUE_SIZE);\n\n        u->alphaBits = getGLXFBConfigAttrib(n, GLX_ALPHA_SIZE);\n        u->depthBits = getGLXFBConfigAttrib(n, GLX_DEPTH_SIZE);\n        u->stencilBits = getGLXFBConfigAttrib(n, GLX_STENCIL_SIZE);\n\n        u->accumRedBits = getGLXFBConfigAttrib(n, GLX_ACCUM_RED_SIZE);\n        u->accumGreenBits = getGLXFBConfigAttrib(n, GLX_ACCUM_GREEN_SIZE);\n        u->accumBlueBits = getGLXFBConfigAttrib(n, GLX_ACCUM_BLUE_SIZE);\n        u->accumAlphaBits = getGLXFBConfigAttrib(n, GLX_ACCUM_ALPHA_SIZE);\n\n        u->auxBuffers = getGLXFBConfigAttrib(n, GLX_AUX_BUFFERS);\n\n        if (getGLXFBConfigAttrib(n, GLX_STEREO))\n            u->stereo = GLFW_TRUE;\n        if (getGLXFBConfigAttrib(n, GLX_DOUBLEBUFFER))\n            u->doublebuffer = GLFW_TRUE;\n\n        if (_glfw.glx.ARB_multisample)\n            u->samples = getGLXFBConfigAttrib(n, GLX_SAMPLES);\n\n        if (_glfw.glx.ARB_framebuffer_sRGB || _glfw.glx.EXT_framebuffer_sRGB)\n            u->sRGB = getGLXFBConfigAttrib(n, GLX_FRAMEBUFFER_SRGB_CAPABLE_ARB);\n\n        u->handle = (uintptr_t) n;\n        usableCount++;\n    }\n\n    closest = _glfwChooseFBConfig(desired, usableConfigs, usableCount);\n    if (closest)\n        *result = (GLXFBConfig) closest->handle;\n\n    XFree(nativeConfigs);\n    free(usableConfigs);\n\n    return closest != NULL;\n}\n\n// Create the OpenGL context using legacy API\n//\nstatic GLXContext createLegacyContextGLX(_GLFWwindow* window,\n                                         GLXFBConfig fbconfig,\n                                         GLXContext share)\n{\n    return glXCreateNewContext(_glfw.x11.display,\n                               fbconfig,\n                               GLX_RGBA_TYPE,\n                               share,\n                               True);\n}\n\nstatic void makeContextCurrentGLX(_GLFWwindow* window)\n{\n    if (window)\n    {\n        if (!glXMakeCurrent(_glfw.x11.display,\n                            window->context.glx.window,\n                            window->context.glx.handle))\n        {\n            _glfwInputError(GLFW_PLATFORM_ERROR,\n                            \"GLX: Failed to make context current\");\n            return;\n        }\n    }\n    else\n    {\n        if (!glXMakeCurrent(_glfw.x11.display, None, NULL))\n        {\n            _glfwInputError(GLFW_PLATFORM_ERROR,\n                            \"GLX: Failed to clear current context\");\n            return;\n        }\n    }\n\n    _glfwPlatformSetTls(&_glfw.contextSlot, window);\n}\n\nstatic void swapBuffersGLX(_GLFWwindow* window)\n{\n    glXSwapBuffers(_glfw.x11.display, window->context.glx.window);\n}\n\nstatic void swapIntervalGLX(int interval)\n{\n    _GLFWwindow* window = _glfwPlatformGetTls(&_glfw.contextSlot);\n\n    if (_glfw.glx.EXT_swap_control)\n    {\n        _glfw.glx.SwapIntervalEXT(_glfw.x11.display,\n                                  window->context.glx.window,\n                                  interval);\n    }\n    else if (_glfw.glx.MESA_swap_control)\n        _glfw.glx.SwapIntervalMESA(interval);\n    else if (_glfw.glx.SGI_swap_control)\n    {\n        if (interval > 0)\n            _glfw.glx.SwapIntervalSGI(interval);\n    }\n}\n\nstatic int extensionSupportedGLX(const char* extension)\n{\n    const char* extensions =\n        glXQueryExtensionsString(_glfw.x11.display, _glfw.x11.screen);\n    if (extensions)\n    {\n        if (_glfwStringInExtensionString(extension, extensions))\n            return GLFW_TRUE;\n    }\n\n    return GLFW_FALSE;\n}\n\nstatic GLFWglproc getProcAddressGLX(const char* procname)\n{\n    if (_glfw.glx.GetProcAddress)\n        return _glfw.glx.GetProcAddress((const GLubyte*) procname);\n    else if (_glfw.glx.GetProcAddressARB)\n        return _glfw.glx.GetProcAddressARB((const GLubyte*) procname);\n    else\n        return _glfw_dlsym(_glfw.glx.handle, procname);\n}\n\n// Destroy the OpenGL context\n//\nstatic void destroyContextGLX(_GLFWwindow* window)\n{\n    if (window->context.glx.window)\n    {\n        glXDestroyWindow(_glfw.x11.display, window->context.glx.window);\n        window->context.glx.window = None;\n    }\n\n    if (window->context.glx.handle)\n    {\n        glXDestroyContext(_glfw.x11.display, window->context.glx.handle);\n        window->context.glx.handle = NULL;\n    }\n}\n\n\n//////////////////////////////////////////////////////////////////////////\n//////                       GLFW internal API                      //////\n//////////////////////////////////////////////////////////////////////////\n\n// Initialize GLX\n//\nGLFWbool _glfwInitGLX(void)\n{\n    int i;\n    const char* sonames[] =\n    {\n#if defined(_GLFW_GLX_LIBRARY)\n        _GLFW_GLX_LIBRARY,\n#elif defined(__CYGWIN__)\n        \"libGL-1.so\",\n#else\n        \"libGL.so.1\",\n        \"libGL.so\",\n#endif\n        NULL\n    };\n\n    if (_glfw.glx.handle)\n        return GLFW_TRUE;\n\n    for (i = 0;  sonames[i];  i++)\n    {\n        _glfw.glx.handle = _glfw_dlopen(sonames[i]);\n        if (_glfw.glx.handle)\n            break;\n    }\n\n    if (!_glfw.glx.handle)\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE, \"GLX: Failed to load GLX\");\n        return GLFW_FALSE;\n    }\n\n    _glfw.glx.GetFBConfigs =\n        _glfw_dlsym(_glfw.glx.handle, \"glXGetFBConfigs\");\n    _glfw.glx.GetFBConfigAttrib =\n        _glfw_dlsym(_glfw.glx.handle, \"glXGetFBConfigAttrib\");\n    _glfw.glx.GetClientString =\n        _glfw_dlsym(_glfw.glx.handle, \"glXGetClientString\");\n    _glfw.glx.QueryExtension =\n        _glfw_dlsym(_glfw.glx.handle, \"glXQueryExtension\");\n    _glfw.glx.QueryVersion =\n        _glfw_dlsym(_glfw.glx.handle, \"glXQueryVersion\");\n    _glfw.glx.DestroyContext =\n        _glfw_dlsym(_glfw.glx.handle, \"glXDestroyContext\");\n    _glfw.glx.MakeCurrent =\n        _glfw_dlsym(_glfw.glx.handle, \"glXMakeCurrent\");\n    _glfw.glx.SwapBuffers =\n        _glfw_dlsym(_glfw.glx.handle, \"glXSwapBuffers\");\n    _glfw.glx.QueryExtensionsString =\n        _glfw_dlsym(_glfw.glx.handle, \"glXQueryExtensionsString\");\n    _glfw.glx.CreateNewContext =\n        _glfw_dlsym(_glfw.glx.handle, \"glXCreateNewContext\");\n    _glfw.glx.CreateWindow =\n        _glfw_dlsym(_glfw.glx.handle, \"glXCreateWindow\");\n    _glfw.glx.DestroyWindow =\n        _glfw_dlsym(_glfw.glx.handle, \"glXDestroyWindow\");\n    _glfw.glx.GetProcAddress =\n        _glfw_dlsym(_glfw.glx.handle, \"glXGetProcAddress\");\n    _glfw.glx.GetProcAddressARB =\n        _glfw_dlsym(_glfw.glx.handle, \"glXGetProcAddressARB\");\n    _glfw.glx.GetVisualFromFBConfig =\n        _glfw_dlsym(_glfw.glx.handle, \"glXGetVisualFromFBConfig\");\n\n    if (!_glfw.glx.GetFBConfigs ||\n        !_glfw.glx.GetFBConfigAttrib ||\n        !_glfw.glx.GetClientString ||\n        !_glfw.glx.QueryExtension ||\n        !_glfw.glx.QueryVersion ||\n        !_glfw.glx.DestroyContext ||\n        !_glfw.glx.MakeCurrent ||\n        !_glfw.glx.SwapBuffers ||\n        !_glfw.glx.QueryExtensionsString ||\n        !_glfw.glx.CreateNewContext ||\n        !_glfw.glx.CreateWindow ||\n        !_glfw.glx.DestroyWindow ||\n        !_glfw.glx.GetProcAddress ||\n        !_glfw.glx.GetProcAddressARB ||\n        !_glfw.glx.GetVisualFromFBConfig)\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"GLX: Failed to load required entry points\");\n        return GLFW_FALSE;\n    }\n\n    if (!glXQueryExtension(_glfw.x11.display,\n                           &_glfw.glx.errorBase,\n                           &_glfw.glx.eventBase))\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE, \"GLX: GLX extension not found\");\n        return GLFW_FALSE;\n    }\n\n    if (!glXQueryVersion(_glfw.x11.display, &_glfw.glx.major, &_glfw.glx.minor))\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE,\n                        \"GLX: Failed to query GLX version\");\n        return GLFW_FALSE;\n    }\n\n    if (_glfw.glx.major == 1 && _glfw.glx.minor < 3)\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE,\n                        \"GLX: GLX version 1.3 is required\");\n        return GLFW_FALSE;\n    }\n\n    if (extensionSupportedGLX(\"GLX_EXT_swap_control\"))\n    {\n        _glfw.glx.SwapIntervalEXT = (PFNGLXSWAPINTERVALEXTPROC)\n            getProcAddressGLX(\"glXSwapIntervalEXT\");\n\n        if (_glfw.glx.SwapIntervalEXT)\n            _glfw.glx.EXT_swap_control = GLFW_TRUE;\n    }\n\n    if (extensionSupportedGLX(\"GLX_SGI_swap_control\"))\n    {\n        _glfw.glx.SwapIntervalSGI = (PFNGLXSWAPINTERVALSGIPROC)\n            getProcAddressGLX(\"glXSwapIntervalSGI\");\n\n        if (_glfw.glx.SwapIntervalSGI)\n            _glfw.glx.SGI_swap_control = GLFW_TRUE;\n    }\n\n    if (extensionSupportedGLX(\"GLX_MESA_swap_control\"))\n    {\n        _glfw.glx.SwapIntervalMESA = (PFNGLXSWAPINTERVALMESAPROC)\n            getProcAddressGLX(\"glXSwapIntervalMESA\");\n\n        if (_glfw.glx.SwapIntervalMESA)\n            _glfw.glx.MESA_swap_control = GLFW_TRUE;\n    }\n\n    if (extensionSupportedGLX(\"GLX_ARB_multisample\"))\n        _glfw.glx.ARB_multisample = GLFW_TRUE;\n\n    if (extensionSupportedGLX(\"GLX_ARB_framebuffer_sRGB\"))\n        _glfw.glx.ARB_framebuffer_sRGB = GLFW_TRUE;\n\n    if (extensionSupportedGLX(\"GLX_EXT_framebuffer_sRGB\"))\n        _glfw.glx.EXT_framebuffer_sRGB = GLFW_TRUE;\n\n    if (extensionSupportedGLX(\"GLX_ARB_create_context\"))\n    {\n        _glfw.glx.CreateContextAttribsARB = (PFNGLXCREATECONTEXTATTRIBSARBPROC)\n            getProcAddressGLX(\"glXCreateContextAttribsARB\");\n\n        if (_glfw.glx.CreateContextAttribsARB)\n            _glfw.glx.ARB_create_context = GLFW_TRUE;\n    }\n\n    if (extensionSupportedGLX(\"GLX_ARB_create_context_robustness\"))\n        _glfw.glx.ARB_create_context_robustness = GLFW_TRUE;\n\n    if (extensionSupportedGLX(\"GLX_ARB_create_context_profile\"))\n        _glfw.glx.ARB_create_context_profile = GLFW_TRUE;\n\n    if (extensionSupportedGLX(\"GLX_EXT_create_context_es2_profile\"))\n        _glfw.glx.EXT_create_context_es2_profile = GLFW_TRUE;\n\n    if (extensionSupportedGLX(\"GLX_ARB_create_context_no_error\"))\n        _glfw.glx.ARB_create_context_no_error = GLFW_TRUE;\n\n    if (extensionSupportedGLX(\"GLX_ARB_context_flush_control\"))\n        _glfw.glx.ARB_context_flush_control = GLFW_TRUE;\n\n    return GLFW_TRUE;\n}\n\n// Terminate GLX\n//\nvoid _glfwTerminateGLX(void)\n{\n    // NOTE: This function must not call any X11 functions, as it is called\n    //       after XCloseDisplay (see _glfwPlatformTerminate for details)\n\n    if (_glfw.glx.handle)\n    {\n        _glfw_dlclose(_glfw.glx.handle);\n        _glfw.glx.handle = NULL;\n    }\n}\n\n#define setAttrib(a, v) \\\n{ \\\n    assert(((size_t) index + 1) < sizeof(attribs) / sizeof(attribs[0])); \\\n    attribs[index++] = a; \\\n    attribs[index++] = v; \\\n}\n\n// Create the OpenGL or OpenGL ES context\n//\nGLFWbool _glfwCreateContextGLX(_GLFWwindow* window,\n                               const _GLFWctxconfig* ctxconfig,\n                               const _GLFWfbconfig* fbconfig)\n{\n    int attribs[40];\n    GLXFBConfig native = NULL;\n    GLXContext share = NULL;\n\n    if (ctxconfig->share)\n        share = ctxconfig->share->context.glx.handle;\n\n    if (!chooseGLXFBConfig(fbconfig, &native))\n    {\n        _glfwInputError(GLFW_FORMAT_UNAVAILABLE,\n                        \"GLX: Failed to find a suitable GLXFBConfig\");\n        return GLFW_FALSE;\n    }\n\n    if (ctxconfig->client == GLFW_OPENGL_ES_API)\n    {\n        if (!_glfw.glx.ARB_create_context ||\n            !_glfw.glx.ARB_create_context_profile ||\n            !_glfw.glx.EXT_create_context_es2_profile)\n        {\n            _glfwInputError(GLFW_API_UNAVAILABLE,\n                            \"GLX: OpenGL ES requested but GLX_EXT_create_context_es2_profile is unavailable\");\n            return GLFW_FALSE;\n        }\n    }\n\n    if (ctxconfig->forward)\n    {\n        if (!_glfw.glx.ARB_create_context)\n        {\n            _glfwInputError(GLFW_VERSION_UNAVAILABLE,\n                            \"GLX: Forward compatibility requested but GLX_ARB_create_context_profile is unavailable\");\n            return GLFW_FALSE;\n        }\n    }\n\n    if (ctxconfig->profile)\n    {\n        if (!_glfw.glx.ARB_create_context ||\n            !_glfw.glx.ARB_create_context_profile)\n        {\n            _glfwInputError(GLFW_VERSION_UNAVAILABLE,\n                            \"GLX: An OpenGL profile requested but GLX_ARB_create_context_profile is unavailable\");\n            return GLFW_FALSE;\n        }\n    }\n\n    _glfwGrabErrorHandlerX11();\n\n    if (_glfw.glx.ARB_create_context)\n    {\n        int index = 0, mask = 0, flags = 0;\n\n        if (ctxconfig->client == GLFW_OPENGL_API)\n        {\n            if (ctxconfig->forward)\n                flags |= GLX_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB;\n\n            if (ctxconfig->profile == GLFW_OPENGL_CORE_PROFILE)\n                mask |= GLX_CONTEXT_CORE_PROFILE_BIT_ARB;\n            else if (ctxconfig->profile == GLFW_OPENGL_COMPAT_PROFILE)\n                mask |= GLX_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB;\n        }\n        else\n            mask |= GLX_CONTEXT_ES2_PROFILE_BIT_EXT;\n\n        if (ctxconfig->debug)\n            flags |= GLX_CONTEXT_DEBUG_BIT_ARB;\n\n        if (ctxconfig->robustness)\n        {\n            if (_glfw.glx.ARB_create_context_robustness)\n            {\n                if (ctxconfig->robustness == GLFW_NO_RESET_NOTIFICATION)\n                {\n                    setAttrib(GLX_CONTEXT_RESET_NOTIFICATION_STRATEGY_ARB,\n                              GLX_NO_RESET_NOTIFICATION_ARB);\n                }\n                else if (ctxconfig->robustness == GLFW_LOSE_CONTEXT_ON_RESET)\n                {\n                    setAttrib(GLX_CONTEXT_RESET_NOTIFICATION_STRATEGY_ARB,\n                              GLX_LOSE_CONTEXT_ON_RESET_ARB);\n                }\n\n                flags |= GLX_CONTEXT_ROBUST_ACCESS_BIT_ARB;\n            }\n        }\n\n        if (ctxconfig->release)\n        {\n            if (_glfw.glx.ARB_context_flush_control)\n            {\n                if (ctxconfig->release == GLFW_RELEASE_BEHAVIOR_NONE)\n                {\n                    setAttrib(GLX_CONTEXT_RELEASE_BEHAVIOR_ARB,\n                              GLX_CONTEXT_RELEASE_BEHAVIOR_NONE_ARB);\n                }\n                else if (ctxconfig->release == GLFW_RELEASE_BEHAVIOR_FLUSH)\n                {\n                    setAttrib(GLX_CONTEXT_RELEASE_BEHAVIOR_ARB,\n                              GLX_CONTEXT_RELEASE_BEHAVIOR_FLUSH_ARB);\n                }\n            }\n        }\n\n        if (ctxconfig->noerror)\n        {\n            if (_glfw.glx.ARB_create_context_no_error)\n                setAttrib(GLX_CONTEXT_OPENGL_NO_ERROR_ARB, GLFW_TRUE);\n        }\n\n        // NOTE: Only request an explicitly versioned context when necessary, as\n        //       explicitly requesting version 1.0 does not always return the\n        //       highest version supported by the driver\n        if (ctxconfig->major != 1 || ctxconfig->minor != 0)\n        {\n            setAttrib(GLX_CONTEXT_MAJOR_VERSION_ARB, ctxconfig->major);\n            setAttrib(GLX_CONTEXT_MINOR_VERSION_ARB, ctxconfig->minor);\n        }\n\n        if (mask)\n            setAttrib(GLX_CONTEXT_PROFILE_MASK_ARB, mask);\n\n        if (flags)\n            setAttrib(GLX_CONTEXT_FLAGS_ARB, flags);\n\n        setAttrib(None, None);\n\n        window->context.glx.handle =\n            _glfw.glx.CreateContextAttribsARB(_glfw.x11.display,\n                                              native,\n                                              share,\n                                              True,\n                                              attribs);\n\n        // HACK: This is a fallback for broken versions of the Mesa\n        //       implementation of GLX_ARB_create_context_profile that fail\n        //       default 1.0 context creation with a GLXBadProfileARB error in\n        //       violation of the extension spec\n        if (!window->context.glx.handle)\n        {\n            if (_glfw.x11.errorCode == _glfw.glx.errorBase + GLXBadProfileARB &&\n                ctxconfig->client == GLFW_OPENGL_API &&\n                ctxconfig->profile == GLFW_OPENGL_ANY_PROFILE &&\n                ctxconfig->forward == GLFW_FALSE)\n            {\n                window->context.glx.handle =\n                    createLegacyContextGLX(window, native, share);\n            }\n        }\n    }\n    else\n    {\n        window->context.glx.handle =\n            createLegacyContextGLX(window, native, share);\n    }\n\n    _glfwReleaseErrorHandlerX11();\n\n    if (!window->context.glx.handle)\n    {\n        _glfwInputErrorX11(GLFW_VERSION_UNAVAILABLE, \"GLX: Failed to create context\");\n        return GLFW_FALSE;\n    }\n\n    window->context.glx.window =\n        glXCreateWindow(_glfw.x11.display, native, window->x11.handle, NULL);\n    if (!window->context.glx.window)\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR, \"GLX: Failed to create window\");\n        return GLFW_FALSE;\n    }\n\n    window->context.makeCurrent = makeContextCurrentGLX;\n    window->context.swapBuffers = swapBuffersGLX;\n    window->context.swapInterval = swapIntervalGLX;\n    window->context.extensionSupported = extensionSupportedGLX;\n    window->context.getProcAddress = getProcAddressGLX;\n    window->context.destroy = destroyContextGLX;\n\n    return GLFW_TRUE;\n}\n\n#undef setAttrib\n\n// Returns the Visual and depth of the chosen GLXFBConfig\n//\nGLFWbool _glfwChooseVisualGLX(const _GLFWwndconfig* wndconfig,\n                              const _GLFWctxconfig* ctxconfig,\n                              const _GLFWfbconfig* fbconfig,\n                              Visual** visual, int* depth)\n{\n    GLXFBConfig native;\n    XVisualInfo* result;\n\n    if (!chooseGLXFBConfig(fbconfig, &native))\n    {\n        _glfwInputError(GLFW_FORMAT_UNAVAILABLE,\n                        \"GLX: Failed to find a suitable GLXFBConfig\");\n        return GLFW_FALSE;\n    }\n\n    result = glXGetVisualFromFBConfig(_glfw.x11.display, native);\n    if (!result)\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"GLX: Failed to retrieve Visual for GLXFBConfig\");\n        return GLFW_FALSE;\n    }\n\n    *visual = result->visual;\n    *depth  = result->depth;\n\n    XFree(result);\n    return GLFW_TRUE;\n}\n\n\n//////////////////////////////////////////////////////////////////////////\n//////                        GLFW native API                       //////\n//////////////////////////////////////////////////////////////////////////\n\nGLFWAPI GLXContext glfwGetGLXContext(GLFWwindow* handle)\n{\n    _GLFWwindow* window = (_GLFWwindow*) handle;\n    _GLFW_REQUIRE_INIT_OR_RETURN(NULL);\n\n    if (window->context.client == GLFW_NO_API)\n    {\n        _glfwInputError(GLFW_NO_WINDOW_CONTEXT, NULL);\n        return NULL;\n    }\n\n    return window->context.glx.handle;\n}\n\nGLFWAPI GLXWindow glfwGetGLXWindow(GLFWwindow* handle)\n{\n    _GLFWwindow* window = (_GLFWwindow*) handle;\n    _GLFW_REQUIRE_INIT_OR_RETURN(None);\n\n    if (window->context.client == GLFW_NO_API)\n    {\n        _glfwInputError(GLFW_NO_WINDOW_CONTEXT, NULL);\n        return None;\n    }\n\n    return window->context.glx.window;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-glfw-3.3-2fza4cb74pcte44nu2vbzw4ag2osew7l/spack-src/src/nsgl_context.h": "//========================================================================\n// GLFW 3.3 macOS - www.glfw.org\n//------------------------------------------------------------------------\n// Copyright (c) 2009-2019 Camilla L\u00f6wy <elmindreda@glfw.org>\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would\n//    be appreciated but is not required.\n//\n// 2. Altered source versions must be plainly marked as such, and must not\n//    be misrepresented as being the original software.\n//\n// 3. This notice may not be removed or altered from any source\n//    distribution.\n//\n//========================================================================\n\n#if MAC_OS_X_VERSION_MAX_ALLOWED < 101400\n #define NSOpenGLContextParameterSwapInterval NSOpenGLCPSwapInterval\n #define NSOpenGLContextParameterSurfaceOpacity NSOpenGLCPSurfaceOpacity\n#endif\n\n#define _GLFW_PLATFORM_CONTEXT_STATE            _GLFWcontextNSGL nsgl\n#define _GLFW_PLATFORM_LIBRARY_CONTEXT_STATE    _GLFWlibraryNSGL nsgl\n\n#include <stdatomic.h>\n\n\n// NSGL-specific per-context data\n//\ntypedef struct _GLFWcontextNSGL\n{\n    id                pixelFormat;\n    id                object;\n    CVDisplayLinkRef  displayLink;\n    atomic_int        swapInterval;\n    int               swapIntervalsPassed;\n    id                swapIntervalCond;\n\n} _GLFWcontextNSGL;\n\n// NSGL-specific global data\n//\ntypedef struct _GLFWlibraryNSGL\n{\n    // dlopen handle for OpenGL.framework (for glfwGetProcAddress)\n    CFBundleRef     framework;\n\n} _GLFWlibraryNSGL;\n\n\nGLFWbool _glfwInitNSGL(void);\nvoid _glfwTerminateNSGL(void);\nGLFWbool _glfwCreateContextNSGL(_GLFWwindow* window,\n                                const _GLFWctxconfig* ctxconfig,\n                                const _GLFWfbconfig* fbconfig);\nvoid _glfwDestroyContextNSGL(_GLFWwindow* window);\nvoid _glfwUpdateDisplayLinkDisplayNSGL(_GLFWwindow* window);\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-glfw-3.3-2fza4cb74pcte44nu2vbzw4ag2osew7l/spack-src/src/x11_init.c": "//========================================================================\n// GLFW 3.3 X11 - www.glfw.org\n//------------------------------------------------------------------------\n// Copyright (c) 2002-2006 Marcus Geelnard\n// Copyright (c) 2006-2019 Camilla L\u00f6wy <elmindreda@glfw.org>\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would\n//    be appreciated but is not required.\n//\n// 2. Altered source versions must be plainly marked as such, and must not\n//    be misrepresented as being the original software.\n//\n// 3. This notice may not be removed or altered from any source\n//    distribution.\n//\n//========================================================================\n\n#include \"internal.h\"\n\n#include <X11/Xresource.h>\n\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n#include <stdio.h>\n#include <locale.h>\n\n\n// Translate an X11 key code to a GLFW key code.\n//\nstatic int translateKeyCode(int scancode)\n{\n    int keySym;\n\n    // Valid key code range is  [8,255], according to the Xlib manual\n    if (scancode < 8 || scancode > 255)\n        return GLFW_KEY_UNKNOWN;\n\n    if (_glfw.x11.xkb.available)\n    {\n        // Try secondary keysym, for numeric keypad keys\n        // Note: This way we always force \"NumLock = ON\", which is intentional\n        // since the returned key code should correspond to a physical\n        // location.\n        keySym = XkbKeycodeToKeysym(_glfw.x11.display, scancode, 0, 1);\n        switch (keySym)\n        {\n            case XK_KP_0:           return GLFW_KEY_KP_0;\n            case XK_KP_1:           return GLFW_KEY_KP_1;\n            case XK_KP_2:           return GLFW_KEY_KP_2;\n            case XK_KP_3:           return GLFW_KEY_KP_3;\n            case XK_KP_4:           return GLFW_KEY_KP_4;\n            case XK_KP_5:           return GLFW_KEY_KP_5;\n            case XK_KP_6:           return GLFW_KEY_KP_6;\n            case XK_KP_7:           return GLFW_KEY_KP_7;\n            case XK_KP_8:           return GLFW_KEY_KP_8;\n            case XK_KP_9:           return GLFW_KEY_KP_9;\n            case XK_KP_Separator:\n            case XK_KP_Decimal:     return GLFW_KEY_KP_DECIMAL;\n            case XK_KP_Equal:       return GLFW_KEY_KP_EQUAL;\n            case XK_KP_Enter:       return GLFW_KEY_KP_ENTER;\n            default:                break;\n        }\n\n        // Now try primary keysym for function keys (non-printable keys)\n        // These should not depend on the current keyboard layout\n        keySym = XkbKeycodeToKeysym(_glfw.x11.display, scancode, 0, 0);\n    }\n    else\n    {\n        int dummy;\n        KeySym* keySyms;\n\n        keySyms = XGetKeyboardMapping(_glfw.x11.display, scancode, 1, &dummy);\n        keySym = keySyms[0];\n        XFree(keySyms);\n    }\n\n    switch (keySym)\n    {\n        case XK_Escape:         return GLFW_KEY_ESCAPE;\n        case XK_Tab:            return GLFW_KEY_TAB;\n        case XK_Shift_L:        return GLFW_KEY_LEFT_SHIFT;\n        case XK_Shift_R:        return GLFW_KEY_RIGHT_SHIFT;\n        case XK_Control_L:      return GLFW_KEY_LEFT_CONTROL;\n        case XK_Control_R:      return GLFW_KEY_RIGHT_CONTROL;\n        case XK_Meta_L:\n        case XK_Alt_L:          return GLFW_KEY_LEFT_ALT;\n        case XK_Mode_switch: // Mapped to Alt_R on many keyboards\n        case XK_ISO_Level3_Shift: // AltGr on at least some machines\n        case XK_Meta_R:\n        case XK_Alt_R:          return GLFW_KEY_RIGHT_ALT;\n        case XK_Super_L:        return GLFW_KEY_LEFT_SUPER;\n        case XK_Super_R:        return GLFW_KEY_RIGHT_SUPER;\n        case XK_Menu:           return GLFW_KEY_MENU;\n        case XK_Num_Lock:       return GLFW_KEY_NUM_LOCK;\n        case XK_Caps_Lock:      return GLFW_KEY_CAPS_LOCK;\n        case XK_Print:          return GLFW_KEY_PRINT_SCREEN;\n        case XK_Scroll_Lock:    return GLFW_KEY_SCROLL_LOCK;\n        case XK_Pause:          return GLFW_KEY_PAUSE;\n        case XK_Delete:         return GLFW_KEY_DELETE;\n        case XK_BackSpace:      return GLFW_KEY_BACKSPACE;\n        case XK_Return:         return GLFW_KEY_ENTER;\n        case XK_Home:           return GLFW_KEY_HOME;\n        case XK_End:            return GLFW_KEY_END;\n        case XK_Page_Up:        return GLFW_KEY_PAGE_UP;\n        case XK_Page_Down:      return GLFW_KEY_PAGE_DOWN;\n        case XK_Insert:         return GLFW_KEY_INSERT;\n        case XK_Left:           return GLFW_KEY_LEFT;\n        case XK_Right:          return GLFW_KEY_RIGHT;\n        case XK_Down:           return GLFW_KEY_DOWN;\n        case XK_Up:             return GLFW_KEY_UP;\n        case XK_F1:             return GLFW_KEY_F1;\n        case XK_F2:             return GLFW_KEY_F2;\n        case XK_F3:             return GLFW_KEY_F3;\n        case XK_F4:             return GLFW_KEY_F4;\n        case XK_F5:             return GLFW_KEY_F5;\n        case XK_F6:             return GLFW_KEY_F6;\n        case XK_F7:             return GLFW_KEY_F7;\n        case XK_F8:             return GLFW_KEY_F8;\n        case XK_F9:             return GLFW_KEY_F9;\n        case XK_F10:            return GLFW_KEY_F10;\n        case XK_F11:            return GLFW_KEY_F11;\n        case XK_F12:            return GLFW_KEY_F12;\n        case XK_F13:            return GLFW_KEY_F13;\n        case XK_F14:            return GLFW_KEY_F14;\n        case XK_F15:            return GLFW_KEY_F15;\n        case XK_F16:            return GLFW_KEY_F16;\n        case XK_F17:            return GLFW_KEY_F17;\n        case XK_F18:            return GLFW_KEY_F18;\n        case XK_F19:            return GLFW_KEY_F19;\n        case XK_F20:            return GLFW_KEY_F20;\n        case XK_F21:            return GLFW_KEY_F21;\n        case XK_F22:            return GLFW_KEY_F22;\n        case XK_F23:            return GLFW_KEY_F23;\n        case XK_F24:            return GLFW_KEY_F24;\n        case XK_F25:            return GLFW_KEY_F25;\n\n        // Numeric keypad\n        case XK_KP_Divide:      return GLFW_KEY_KP_DIVIDE;\n        case XK_KP_Multiply:    return GLFW_KEY_KP_MULTIPLY;\n        case XK_KP_Subtract:    return GLFW_KEY_KP_SUBTRACT;\n        case XK_KP_Add:         return GLFW_KEY_KP_ADD;\n\n        // These should have been detected in secondary keysym test above!\n        case XK_KP_Insert:      return GLFW_KEY_KP_0;\n        case XK_KP_End:         return GLFW_KEY_KP_1;\n        case XK_KP_Down:        return GLFW_KEY_KP_2;\n        case XK_KP_Page_Down:   return GLFW_KEY_KP_3;\n        case XK_KP_Left:        return GLFW_KEY_KP_4;\n        case XK_KP_Right:       return GLFW_KEY_KP_6;\n        case XK_KP_Home:        return GLFW_KEY_KP_7;\n        case XK_KP_Up:          return GLFW_KEY_KP_8;\n        case XK_KP_Page_Up:     return GLFW_KEY_KP_9;\n        case XK_KP_Delete:      return GLFW_KEY_KP_DECIMAL;\n        case XK_KP_Equal:       return GLFW_KEY_KP_EQUAL;\n        case XK_KP_Enter:       return GLFW_KEY_KP_ENTER;\n\n        // Last resort: Check for printable keys (should not happen if the XKB\n        // extension is available). This will give a layout dependent mapping\n        // (which is wrong, and we may miss some keys, especially on non-US\n        // keyboards), but it's better than nothing...\n        case XK_a:              return GLFW_KEY_A;\n        case XK_b:              return GLFW_KEY_B;\n        case XK_c:              return GLFW_KEY_C;\n        case XK_d:              return GLFW_KEY_D;\n        case XK_e:              return GLFW_KEY_E;\n        case XK_f:              return GLFW_KEY_F;\n        case XK_g:              return GLFW_KEY_G;\n        case XK_h:              return GLFW_KEY_H;\n        case XK_i:              return GLFW_KEY_I;\n        case XK_j:              return GLFW_KEY_J;\n        case XK_k:              return GLFW_KEY_K;\n        case XK_l:              return GLFW_KEY_L;\n        case XK_m:              return GLFW_KEY_M;\n        case XK_n:              return GLFW_KEY_N;\n        case XK_o:              return GLFW_KEY_O;\n        case XK_p:              return GLFW_KEY_P;\n        case XK_q:              return GLFW_KEY_Q;\n        case XK_r:              return GLFW_KEY_R;\n        case XK_s:              return GLFW_KEY_S;\n        case XK_t:              return GLFW_KEY_T;\n        case XK_u:              return GLFW_KEY_U;\n        case XK_v:              return GLFW_KEY_V;\n        case XK_w:              return GLFW_KEY_W;\n        case XK_x:              return GLFW_KEY_X;\n        case XK_y:              return GLFW_KEY_Y;\n        case XK_z:              return GLFW_KEY_Z;\n        case XK_1:              return GLFW_KEY_1;\n        case XK_2:              return GLFW_KEY_2;\n        case XK_3:              return GLFW_KEY_3;\n        case XK_4:              return GLFW_KEY_4;\n        case XK_5:              return GLFW_KEY_5;\n        case XK_6:              return GLFW_KEY_6;\n        case XK_7:              return GLFW_KEY_7;\n        case XK_8:              return GLFW_KEY_8;\n        case XK_9:              return GLFW_KEY_9;\n        case XK_0:              return GLFW_KEY_0;\n        case XK_space:          return GLFW_KEY_SPACE;\n        case XK_minus:          return GLFW_KEY_MINUS;\n        case XK_equal:          return GLFW_KEY_EQUAL;\n        case XK_bracketleft:    return GLFW_KEY_LEFT_BRACKET;\n        case XK_bracketright:   return GLFW_KEY_RIGHT_BRACKET;\n        case XK_backslash:      return GLFW_KEY_BACKSLASH;\n        case XK_semicolon:      return GLFW_KEY_SEMICOLON;\n        case XK_apostrophe:     return GLFW_KEY_APOSTROPHE;\n        case XK_grave:          return GLFW_KEY_GRAVE_ACCENT;\n        case XK_comma:          return GLFW_KEY_COMMA;\n        case XK_period:         return GLFW_KEY_PERIOD;\n        case XK_slash:          return GLFW_KEY_SLASH;\n        case XK_less:           return GLFW_KEY_WORLD_1; // At least in some layouts...\n        default:                break;\n    }\n\n    // No matching translation was found\n    return GLFW_KEY_UNKNOWN;\n}\n\n// Create key code translation tables\n//\nstatic void createKeyTables(void)\n{\n    int scancode, key;\n\n    memset(_glfw.x11.keycodes, -1, sizeof(_glfw.x11.keycodes));\n    memset(_glfw.x11.scancodes, -1, sizeof(_glfw.x11.scancodes));\n\n    if (_glfw.x11.xkb.available)\n    {\n        // Use XKB to determine physical key locations independently of the\n        // current keyboard layout\n\n        char name[XkbKeyNameLength + 1];\n        XkbDescPtr desc = XkbGetMap(_glfw.x11.display, 0, XkbUseCoreKbd);\n        XkbGetNames(_glfw.x11.display, XkbKeyNamesMask, desc);\n\n        // Find the X11 key code -> GLFW key code mapping\n        for (scancode = desc->min_key_code;  scancode <= desc->max_key_code;  scancode++)\n        {\n            memcpy(name, desc->names->keys[scancode].name, XkbKeyNameLength);\n            name[XkbKeyNameLength] = '\\0';\n\n            // Map the key name to a GLFW key code. Note: We only map printable\n            // keys here, and we use the US keyboard layout. The rest of the\n            // keys (function keys) are mapped using traditional KeySym\n            // translations.\n            if (strcmp(name, \"TLDE\") == 0) key = GLFW_KEY_GRAVE_ACCENT;\n            else if (strcmp(name, \"AE01\") == 0) key = GLFW_KEY_1;\n            else if (strcmp(name, \"AE02\") == 0) key = GLFW_KEY_2;\n            else if (strcmp(name, \"AE03\") == 0) key = GLFW_KEY_3;\n            else if (strcmp(name, \"AE04\") == 0) key = GLFW_KEY_4;\n            else if (strcmp(name, \"AE05\") == 0) key = GLFW_KEY_5;\n            else if (strcmp(name, \"AE06\") == 0) key = GLFW_KEY_6;\n            else if (strcmp(name, \"AE07\") == 0) key = GLFW_KEY_7;\n            else if (strcmp(name, \"AE08\") == 0) key = GLFW_KEY_8;\n            else if (strcmp(name, \"AE09\") == 0) key = GLFW_KEY_9;\n            else if (strcmp(name, \"AE10\") == 0) key = GLFW_KEY_0;\n            else if (strcmp(name, \"AE11\") == 0) key = GLFW_KEY_MINUS;\n            else if (strcmp(name, \"AE12\") == 0) key = GLFW_KEY_EQUAL;\n            else if (strcmp(name, \"AD01\") == 0) key = GLFW_KEY_Q;\n            else if (strcmp(name, \"AD02\") == 0) key = GLFW_KEY_W;\n            else if (strcmp(name, \"AD03\") == 0) key = GLFW_KEY_E;\n            else if (strcmp(name, \"AD04\") == 0) key = GLFW_KEY_R;\n            else if (strcmp(name, \"AD05\") == 0) key = GLFW_KEY_T;\n            else if (strcmp(name, \"AD06\") == 0) key = GLFW_KEY_Y;\n            else if (strcmp(name, \"AD07\") == 0) key = GLFW_KEY_U;\n            else if (strcmp(name, \"AD08\") == 0) key = GLFW_KEY_I;\n            else if (strcmp(name, \"AD09\") == 0) key = GLFW_KEY_O;\n            else if (strcmp(name, \"AD10\") == 0) key = GLFW_KEY_P;\n            else if (strcmp(name, \"AD11\") == 0) key = GLFW_KEY_LEFT_BRACKET;\n            else if (strcmp(name, \"AD12\") == 0) key = GLFW_KEY_RIGHT_BRACKET;\n            else if (strcmp(name, \"AC01\") == 0) key = GLFW_KEY_A;\n            else if (strcmp(name, \"AC02\") == 0) key = GLFW_KEY_S;\n            else if (strcmp(name, \"AC03\") == 0) key = GLFW_KEY_D;\n            else if (strcmp(name, \"AC04\") == 0) key = GLFW_KEY_F;\n            else if (strcmp(name, \"AC05\") == 0) key = GLFW_KEY_G;\n            else if (strcmp(name, \"AC06\") == 0) key = GLFW_KEY_H;\n            else if (strcmp(name, \"AC07\") == 0) key = GLFW_KEY_J;\n            else if (strcmp(name, \"AC08\") == 0) key = GLFW_KEY_K;\n            else if (strcmp(name, \"AC09\") == 0) key = GLFW_KEY_L;\n            else if (strcmp(name, \"AC10\") == 0) key = GLFW_KEY_SEMICOLON;\n            else if (strcmp(name, \"AC11\") == 0) key = GLFW_KEY_APOSTROPHE;\n            else if (strcmp(name, \"AB01\") == 0) key = GLFW_KEY_Z;\n            else if (strcmp(name, \"AB02\") == 0) key = GLFW_KEY_X;\n            else if (strcmp(name, \"AB03\") == 0) key = GLFW_KEY_C;\n            else if (strcmp(name, \"AB04\") == 0) key = GLFW_KEY_V;\n            else if (strcmp(name, \"AB05\") == 0) key = GLFW_KEY_B;\n            else if (strcmp(name, \"AB06\") == 0) key = GLFW_KEY_N;\n            else if (strcmp(name, \"AB07\") == 0) key = GLFW_KEY_M;\n            else if (strcmp(name, \"AB08\") == 0) key = GLFW_KEY_COMMA;\n            else if (strcmp(name, \"AB09\") == 0) key = GLFW_KEY_PERIOD;\n            else if (strcmp(name, \"AB10\") == 0) key = GLFW_KEY_SLASH;\n            else if (strcmp(name, \"BKSL\") == 0) key = GLFW_KEY_BACKSLASH;\n            else if (strcmp(name, \"LSGT\") == 0) key = GLFW_KEY_WORLD_1;\n            else key = GLFW_KEY_UNKNOWN;\n\n            if ((scancode >= 0) && (scancode < 256))\n                _glfw.x11.keycodes[scancode] = key;\n        }\n\n        XkbFreeNames(desc, XkbKeyNamesMask, True);\n        XkbFreeKeyboard(desc, 0, True);\n    }\n\n    for (scancode = 0;  scancode < 256;  scancode++)\n    {\n        // Translate the un-translated key codes using traditional X11 KeySym\n        // lookups\n        if (_glfw.x11.keycodes[scancode] < 0)\n            _glfw.x11.keycodes[scancode] = translateKeyCode(scancode);\n\n        // Store the reverse translation for faster key name lookup\n        if (_glfw.x11.keycodes[scancode] > 0)\n            _glfw.x11.scancodes[_glfw.x11.keycodes[scancode]] = scancode;\n    }\n}\n\n// Check whether the IM has a usable style\n//\nstatic GLFWbool hasUsableInputMethodStyle(void)\n{\n    unsigned int i;\n    GLFWbool found = GLFW_FALSE;\n    XIMStyles* styles = NULL;\n\n    if (XGetIMValues(_glfw.x11.im, XNQueryInputStyle, &styles, NULL) != NULL)\n        return GLFW_FALSE;\n\n    for (i = 0;  i < styles->count_styles;  i++)\n    {\n        if (styles->supported_styles[i] == (XIMPreeditNothing | XIMStatusNothing))\n        {\n            found = GLFW_TRUE;\n            break;\n        }\n    }\n\n    XFree(styles);\n    return found;\n}\n\n// Check whether the specified atom is supported\n//\nstatic Atom getSupportedAtom(Atom* supportedAtoms,\n                             unsigned long atomCount,\n                             const char* atomName)\n{\n    unsigned long i;\n    const Atom atom = XInternAtom(_glfw.x11.display, atomName, False);\n\n    for (i = 0;  i < atomCount;  i++)\n    {\n        if (supportedAtoms[i] == atom)\n            return atom;\n    }\n\n    return None;\n}\n\n// Check whether the running window manager is EWMH-compliant\n//\nstatic void detectEWMH(void)\n{\n    Window* windowFromRoot = NULL;\n    Window* windowFromChild = NULL;\n\n    // First we need a couple of atoms\n    const Atom supportingWmCheck =\n        XInternAtom(_glfw.x11.display, \"_NET_SUPPORTING_WM_CHECK\", False);\n    const Atom wmSupported =\n        XInternAtom(_glfw.x11.display, \"_NET_SUPPORTED\", False);\n\n    // Then we look for the _NET_SUPPORTING_WM_CHECK property of the root window\n    if (!_glfwGetWindowPropertyX11(_glfw.x11.root,\n                                   supportingWmCheck,\n                                   XA_WINDOW,\n                                   (unsigned char**) &windowFromRoot))\n    {\n        return;\n    }\n\n    _glfwGrabErrorHandlerX11();\n\n    // It should be the ID of a child window (of the root)\n    // Then we look for the same property on the child window\n    if (!_glfwGetWindowPropertyX11(*windowFromRoot,\n                                   supportingWmCheck,\n                                   XA_WINDOW,\n                                   (unsigned char**) &windowFromChild))\n    {\n        XFree(windowFromRoot);\n        return;\n    }\n\n    _glfwReleaseErrorHandlerX11();\n\n    // It should be the ID of that same child window\n    if (*windowFromRoot != *windowFromChild)\n    {\n        XFree(windowFromRoot);\n        XFree(windowFromChild);\n        return;\n    }\n\n    XFree(windowFromRoot);\n    XFree(windowFromChild);\n\n    // We are now fairly sure that an EWMH-compliant window manager is running\n\n    Atom* supportedAtoms;\n    unsigned long atomCount;\n\n    // Now we need to check the _NET_SUPPORTED property of the root window\n    // It should be a list of supported WM protocol and state atoms\n    atomCount = _glfwGetWindowPropertyX11(_glfw.x11.root,\n                                          wmSupported,\n                                          XA_ATOM,\n                                          (unsigned char**) &supportedAtoms);\n\n    // See which of the atoms we support that are supported by the WM\n    _glfw.x11.NET_WM_STATE =\n        getSupportedAtom(supportedAtoms, atomCount, \"_NET_WM_STATE\");\n    _glfw.x11.NET_WM_STATE_ABOVE =\n        getSupportedAtom(supportedAtoms, atomCount, \"_NET_WM_STATE_ABOVE\");\n    _glfw.x11.NET_WM_STATE_FULLSCREEN =\n        getSupportedAtom(supportedAtoms, atomCount, \"_NET_WM_STATE_FULLSCREEN\");\n    _glfw.x11.NET_WM_STATE_MAXIMIZED_VERT =\n        getSupportedAtom(supportedAtoms, atomCount, \"_NET_WM_STATE_MAXIMIZED_VERT\");\n    _glfw.x11.NET_WM_STATE_MAXIMIZED_HORZ =\n        getSupportedAtom(supportedAtoms, atomCount, \"_NET_WM_STATE_MAXIMIZED_HORZ\");\n    _glfw.x11.NET_WM_STATE_DEMANDS_ATTENTION =\n        getSupportedAtom(supportedAtoms, atomCount, \"_NET_WM_STATE_DEMANDS_ATTENTION\");\n    _glfw.x11.NET_WM_FULLSCREEN_MONITORS =\n        getSupportedAtom(supportedAtoms, atomCount, \"_NET_WM_FULLSCREEN_MONITORS\");\n    _glfw.x11.NET_WM_WINDOW_TYPE =\n        getSupportedAtom(supportedAtoms, atomCount, \"_NET_WM_WINDOW_TYPE\");\n    _glfw.x11.NET_WM_WINDOW_TYPE_NORMAL =\n        getSupportedAtom(supportedAtoms, atomCount, \"_NET_WM_WINDOW_TYPE_NORMAL\");\n    _glfw.x11.NET_WORKAREA =\n        getSupportedAtom(supportedAtoms, atomCount, \"_NET_WORKAREA\");\n    _glfw.x11.NET_CURRENT_DESKTOP =\n        getSupportedAtom(supportedAtoms, atomCount, \"_NET_CURRENT_DESKTOP\");\n    _glfw.x11.NET_ACTIVE_WINDOW =\n        getSupportedAtom(supportedAtoms, atomCount, \"_NET_ACTIVE_WINDOW\");\n    _glfw.x11.NET_FRAME_EXTENTS =\n        getSupportedAtom(supportedAtoms, atomCount, \"_NET_FRAME_EXTENTS\");\n    _glfw.x11.NET_REQUEST_FRAME_EXTENTS =\n        getSupportedAtom(supportedAtoms, atomCount, \"_NET_REQUEST_FRAME_EXTENTS\");\n\n    if (supportedAtoms)\n        XFree(supportedAtoms);\n}\n\n// Look for and initialize supported X11 extensions\n//\nstatic GLFWbool initExtensions(void)\n{\n    _glfw.x11.vidmode.handle = _glfw_dlopen(\"libXxf86vm.so.1\");\n    if (_glfw.x11.vidmode.handle)\n    {\n        _glfw.x11.vidmode.QueryExtension = (PFN_XF86VidModeQueryExtension)\n            _glfw_dlsym(_glfw.x11.vidmode.handle, \"XF86VidModeQueryExtension\");\n        _glfw.x11.vidmode.GetGammaRamp = (PFN_XF86VidModeGetGammaRamp)\n            _glfw_dlsym(_glfw.x11.vidmode.handle, \"XF86VidModeGetGammaRamp\");\n        _glfw.x11.vidmode.SetGammaRamp = (PFN_XF86VidModeSetGammaRamp)\n            _glfw_dlsym(_glfw.x11.vidmode.handle, \"XF86VidModeSetGammaRamp\");\n        _glfw.x11.vidmode.GetGammaRampSize = (PFN_XF86VidModeGetGammaRampSize)\n            _glfw_dlsym(_glfw.x11.vidmode.handle, \"XF86VidModeGetGammaRampSize\");\n\n        _glfw.x11.vidmode.available =\n            XF86VidModeQueryExtension(_glfw.x11.display,\n                                      &_glfw.x11.vidmode.eventBase,\n                                      &_glfw.x11.vidmode.errorBase);\n    }\n\n#if defined(__CYGWIN__)\n    _glfw.x11.xi.handle = _glfw_dlopen(\"libXi-6.so\");\n#else\n    _glfw.x11.xi.handle = _glfw_dlopen(\"libXi.so.6\");\n#endif\n    if (_glfw.x11.xi.handle)\n    {\n        _glfw.x11.xi.QueryVersion = (PFN_XIQueryVersion)\n            _glfw_dlsym(_glfw.x11.xi.handle, \"XIQueryVersion\");\n        _glfw.x11.xi.SelectEvents = (PFN_XISelectEvents)\n            _glfw_dlsym(_glfw.x11.xi.handle, \"XISelectEvents\");\n\n        if (XQueryExtension(_glfw.x11.display,\n                            \"XInputExtension\",\n                            &_glfw.x11.xi.majorOpcode,\n                            &_glfw.x11.xi.eventBase,\n                            &_glfw.x11.xi.errorBase))\n        {\n            _glfw.x11.xi.major = 2;\n            _glfw.x11.xi.minor = 0;\n\n            if (XIQueryVersion(_glfw.x11.display,\n                               &_glfw.x11.xi.major,\n                               &_glfw.x11.xi.minor) == Success)\n            {\n                _glfw.x11.xi.available = GLFW_TRUE;\n            }\n        }\n    }\n\n#if defined(__CYGWIN__)\n    _glfw.x11.randr.handle = _glfw_dlopen(\"libXrandr-2.so\");\n#else\n    _glfw.x11.randr.handle = _glfw_dlopen(\"libXrandr.so.2\");\n#endif\n    if (_glfw.x11.randr.handle)\n    {\n        _glfw.x11.randr.AllocGamma = (PFN_XRRAllocGamma)\n            _glfw_dlsym(_glfw.x11.randr.handle, \"XRRAllocGamma\");\n        _glfw.x11.randr.FreeGamma = (PFN_XRRFreeGamma)\n            _glfw_dlsym(_glfw.x11.randr.handle, \"XRRFreeGamma\");\n        _glfw.x11.randr.FreeCrtcInfo = (PFN_XRRFreeCrtcInfo)\n            _glfw_dlsym(_glfw.x11.randr.handle, \"XRRFreeCrtcInfo\");\n        _glfw.x11.randr.FreeGamma = (PFN_XRRFreeGamma)\n            _glfw_dlsym(_glfw.x11.randr.handle, \"XRRFreeGamma\");\n        _glfw.x11.randr.FreeOutputInfo = (PFN_XRRFreeOutputInfo)\n            _glfw_dlsym(_glfw.x11.randr.handle, \"XRRFreeOutputInfo\");\n        _glfw.x11.randr.FreeScreenResources = (PFN_XRRFreeScreenResources)\n            _glfw_dlsym(_glfw.x11.randr.handle, \"XRRFreeScreenResources\");\n        _glfw.x11.randr.GetCrtcGamma = (PFN_XRRGetCrtcGamma)\n            _glfw_dlsym(_glfw.x11.randr.handle, \"XRRGetCrtcGamma\");\n        _glfw.x11.randr.GetCrtcGammaSize = (PFN_XRRGetCrtcGammaSize)\n            _glfw_dlsym(_glfw.x11.randr.handle, \"XRRGetCrtcGammaSize\");\n        _glfw.x11.randr.GetCrtcInfo = (PFN_XRRGetCrtcInfo)\n            _glfw_dlsym(_glfw.x11.randr.handle, \"XRRGetCrtcInfo\");\n        _glfw.x11.randr.GetOutputInfo = (PFN_XRRGetOutputInfo)\n            _glfw_dlsym(_glfw.x11.randr.handle, \"XRRGetOutputInfo\");\n        _glfw.x11.randr.GetOutputPrimary = (PFN_XRRGetOutputPrimary)\n            _glfw_dlsym(_glfw.x11.randr.handle, \"XRRGetOutputPrimary\");\n        _glfw.x11.randr.GetScreenResourcesCurrent = (PFN_XRRGetScreenResourcesCurrent)\n            _glfw_dlsym(_glfw.x11.randr.handle, \"XRRGetScreenResourcesCurrent\");\n        _glfw.x11.randr.QueryExtension = (PFN_XRRQueryExtension)\n            _glfw_dlsym(_glfw.x11.randr.handle, \"XRRQueryExtension\");\n        _glfw.x11.randr.QueryVersion = (PFN_XRRQueryVersion)\n            _glfw_dlsym(_glfw.x11.randr.handle, \"XRRQueryVersion\");\n        _glfw.x11.randr.SelectInput = (PFN_XRRSelectInput)\n            _glfw_dlsym(_glfw.x11.randr.handle, \"XRRSelectInput\");\n        _glfw.x11.randr.SetCrtcConfig = (PFN_XRRSetCrtcConfig)\n            _glfw_dlsym(_glfw.x11.randr.handle, \"XRRSetCrtcConfig\");\n        _glfw.x11.randr.SetCrtcGamma = (PFN_XRRSetCrtcGamma)\n            _glfw_dlsym(_glfw.x11.randr.handle, \"XRRSetCrtcGamma\");\n        _glfw.x11.randr.UpdateConfiguration = (PFN_XRRUpdateConfiguration)\n            _glfw_dlsym(_glfw.x11.randr.handle, \"XRRUpdateConfiguration\");\n\n        if (XRRQueryExtension(_glfw.x11.display,\n                              &_glfw.x11.randr.eventBase,\n                              &_glfw.x11.randr.errorBase))\n        {\n            if (XRRQueryVersion(_glfw.x11.display,\n                                &_glfw.x11.randr.major,\n                                &_glfw.x11.randr.minor))\n            {\n                // The GLFW RandR path requires at least version 1.3\n                if (_glfw.x11.randr.major > 1 || _glfw.x11.randr.minor >= 3)\n                    _glfw.x11.randr.available = GLFW_TRUE;\n            }\n            else\n            {\n                _glfwInputError(GLFW_PLATFORM_ERROR,\n                                \"X11: Failed to query RandR version\");\n            }\n        }\n    }\n\n    if (_glfw.x11.randr.available)\n    {\n        XRRScreenResources* sr = XRRGetScreenResourcesCurrent(_glfw.x11.display,\n                                                              _glfw.x11.root);\n\n        if (!sr->ncrtc || !XRRGetCrtcGammaSize(_glfw.x11.display, sr->crtcs[0]))\n        {\n            // This is likely an older Nvidia driver with broken gamma support\n            // Flag it as useless and fall back to xf86vm gamma, if available\n            _glfw.x11.randr.gammaBroken = GLFW_TRUE;\n        }\n\n        if (!sr->ncrtc)\n        {\n            // A system without CRTCs is likely a system with broken RandR\n            // Disable the RandR monitor path and fall back to core functions\n            _glfw.x11.randr.monitorBroken = GLFW_TRUE;\n        }\n\n        XRRFreeScreenResources(sr);\n    }\n\n    if (_glfw.x11.randr.available && !_glfw.x11.randr.monitorBroken)\n    {\n        XRRSelectInput(_glfw.x11.display, _glfw.x11.root,\n                       RROutputChangeNotifyMask);\n    }\n\n#if defined(__CYGWIN__)\n    _glfw.x11.xcursor.handle = _glfw_dlopen(\"libXcursor-1.so\");\n#else\n    _glfw.x11.xcursor.handle = _glfw_dlopen(\"libXcursor.so.1\");\n#endif\n    if (_glfw.x11.xcursor.handle)\n    {\n        _glfw.x11.xcursor.ImageCreate = (PFN_XcursorImageCreate)\n            _glfw_dlsym(_glfw.x11.xcursor.handle, \"XcursorImageCreate\");\n        _glfw.x11.xcursor.ImageDestroy = (PFN_XcursorImageDestroy)\n            _glfw_dlsym(_glfw.x11.xcursor.handle, \"XcursorImageDestroy\");\n        _glfw.x11.xcursor.ImageLoadCursor = (PFN_XcursorImageLoadCursor)\n            _glfw_dlsym(_glfw.x11.xcursor.handle, \"XcursorImageLoadCursor\");\n    }\n\n#if defined(__CYGWIN__)\n    _glfw.x11.xinerama.handle = _glfw_dlopen(\"libXinerama-1.so\");\n#else\n    _glfw.x11.xinerama.handle = _glfw_dlopen(\"libXinerama.so.1\");\n#endif\n    if (_glfw.x11.xinerama.handle)\n    {\n        _glfw.x11.xinerama.IsActive = (PFN_XineramaIsActive)\n            _glfw_dlsym(_glfw.x11.xinerama.handle, \"XineramaIsActive\");\n        _glfw.x11.xinerama.QueryExtension = (PFN_XineramaQueryExtension)\n            _glfw_dlsym(_glfw.x11.xinerama.handle, \"XineramaQueryExtension\");\n        _glfw.x11.xinerama.QueryScreens = (PFN_XineramaQueryScreens)\n            _glfw_dlsym(_glfw.x11.xinerama.handle, \"XineramaQueryScreens\");\n\n        if (XineramaQueryExtension(_glfw.x11.display,\n                                   &_glfw.x11.xinerama.major,\n                                   &_glfw.x11.xinerama.minor))\n        {\n            if (XineramaIsActive(_glfw.x11.display))\n                _glfw.x11.xinerama.available = GLFW_TRUE;\n        }\n    }\n\n    _glfw.x11.xkb.major = 1;\n    _glfw.x11.xkb.minor = 0;\n    _glfw.x11.xkb.available =\n        XkbQueryExtension(_glfw.x11.display,\n                          &_glfw.x11.xkb.majorOpcode,\n                          &_glfw.x11.xkb.eventBase,\n                          &_glfw.x11.xkb.errorBase,\n                          &_glfw.x11.xkb.major,\n                          &_glfw.x11.xkb.minor);\n\n    if (_glfw.x11.xkb.available)\n    {\n        Bool supported;\n\n        if (XkbSetDetectableAutoRepeat(_glfw.x11.display, True, &supported))\n        {\n            if (supported)\n                _glfw.x11.xkb.detectable = GLFW_TRUE;\n        }\n    }\n\n#if defined(__CYGWIN__)\n    _glfw.x11.x11xcb.handle = _glfw_dlopen(\"libX11-xcb-1.so\");\n#else\n    _glfw.x11.x11xcb.handle = _glfw_dlopen(\"libX11-xcb.so.1\");\n#endif\n    if (_glfw.x11.x11xcb.handle)\n    {\n        _glfw.x11.x11xcb.GetXCBConnection = (PFN_XGetXCBConnection)\n            _glfw_dlsym(_glfw.x11.x11xcb.handle, \"XGetXCBConnection\");\n    }\n\n#if defined(__CYGWIN__)\n    _glfw.x11.xrender.handle = _glfw_dlopen(\"libXrender-1.so\");\n#else\n    _glfw.x11.xrender.handle = _glfw_dlopen(\"libXrender.so.1\");\n#endif\n    if (_glfw.x11.xrender.handle)\n    {\n        _glfw.x11.xrender.QueryExtension = (PFN_XRenderQueryExtension)\n            _glfw_dlsym(_glfw.x11.xrender.handle, \"XRenderQueryExtension\");\n        _glfw.x11.xrender.QueryVersion = (PFN_XRenderQueryVersion)\n            _glfw_dlsym(_glfw.x11.xrender.handle, \"XRenderQueryVersion\");\n        _glfw.x11.xrender.FindVisualFormat = (PFN_XRenderFindVisualFormat)\n            _glfw_dlsym(_glfw.x11.xrender.handle, \"XRenderFindVisualFormat\");\n\n        if (XRenderQueryExtension(_glfw.x11.display,\n                                  &_glfw.x11.xrender.errorBase,\n                                  &_glfw.x11.xrender.eventBase))\n        {\n            if (XRenderQueryVersion(_glfw.x11.display,\n                                    &_glfw.x11.xrender.major,\n                                    &_glfw.x11.xrender.minor))\n            {\n                _glfw.x11.xrender.available = GLFW_TRUE;\n            }\n        }\n    }\n\n    // Update the key code LUT\n    // FIXME: We should listen to XkbMapNotify events to track changes to\n    // the keyboard mapping.\n    createKeyTables();\n\n    // Detect whether an EWMH-conformant window manager is running\n    detectEWMH();\n\n    // String format atoms\n    _glfw.x11.NULL_ = XInternAtom(_glfw.x11.display, \"NULL\", False);\n    _glfw.x11.UTF8_STRING = XInternAtom(_glfw.x11.display, \"UTF8_STRING\", False);\n    _glfw.x11.ATOM_PAIR = XInternAtom(_glfw.x11.display, \"ATOM_PAIR\", False);\n\n    // Custom selection property atom\n    _glfw.x11.GLFW_SELECTION =\n        XInternAtom(_glfw.x11.display, \"GLFW_SELECTION\", False);\n\n    // ICCCM standard clipboard atoms\n    _glfw.x11.TARGETS = XInternAtom(_glfw.x11.display, \"TARGETS\", False);\n    _glfw.x11.MULTIPLE = XInternAtom(_glfw.x11.display, \"MULTIPLE\", False);\n    _glfw.x11.PRIMARY = XInternAtom(_glfw.x11.display, \"PRIMARY\", False);\n    _glfw.x11.INCR = XInternAtom(_glfw.x11.display, \"INCR\", False);\n    _glfw.x11.CLIPBOARD = XInternAtom(_glfw.x11.display, \"CLIPBOARD\", False);\n\n    // Clipboard manager atoms\n    _glfw.x11.CLIPBOARD_MANAGER =\n        XInternAtom(_glfw.x11.display, \"CLIPBOARD_MANAGER\", False);\n    _glfw.x11.SAVE_TARGETS =\n        XInternAtom(_glfw.x11.display, \"SAVE_TARGETS\", False);\n\n    // Xdnd (drag and drop) atoms\n    _glfw.x11.XdndAware = XInternAtom(_glfw.x11.display, \"XdndAware\", False);\n    _glfw.x11.XdndEnter = XInternAtom(_glfw.x11.display, \"XdndEnter\", False);\n    _glfw.x11.XdndPosition = XInternAtom(_glfw.x11.display, \"XdndPosition\", False);\n    _glfw.x11.XdndStatus = XInternAtom(_glfw.x11.display, \"XdndStatus\", False);\n    _glfw.x11.XdndActionCopy = XInternAtom(_glfw.x11.display, \"XdndActionCopy\", False);\n    _glfw.x11.XdndDrop = XInternAtom(_glfw.x11.display, \"XdndDrop\", False);\n    _glfw.x11.XdndFinished = XInternAtom(_glfw.x11.display, \"XdndFinished\", False);\n    _glfw.x11.XdndSelection = XInternAtom(_glfw.x11.display, \"XdndSelection\", False);\n    _glfw.x11.XdndTypeList = XInternAtom(_glfw.x11.display, \"XdndTypeList\", False);\n    _glfw.x11.text_uri_list = XInternAtom(_glfw.x11.display, \"text/uri-list\", False);\n\n    // ICCCM, EWMH and Motif window property atoms\n    // These can be set safely even without WM support\n    // The EWMH atoms that require WM support are handled in detectEWMH\n    _glfw.x11.WM_PROTOCOLS =\n        XInternAtom(_glfw.x11.display, \"WM_PROTOCOLS\", False);\n    _glfw.x11.WM_STATE =\n        XInternAtom(_glfw.x11.display, \"WM_STATE\", False);\n    _glfw.x11.WM_DELETE_WINDOW =\n        XInternAtom(_glfw.x11.display, \"WM_DELETE_WINDOW\", False);\n    _glfw.x11.NET_WM_ICON =\n        XInternAtom(_glfw.x11.display, \"_NET_WM_ICON\", False);\n    _glfw.x11.NET_WM_PING =\n        XInternAtom(_glfw.x11.display, \"_NET_WM_PING\", False);\n    _glfw.x11.NET_WM_PID =\n        XInternAtom(_glfw.x11.display, \"_NET_WM_PID\", False);\n    _glfw.x11.NET_WM_NAME =\n        XInternAtom(_glfw.x11.display, \"_NET_WM_NAME\", False);\n    _glfw.x11.NET_WM_ICON_NAME =\n        XInternAtom(_glfw.x11.display, \"_NET_WM_ICON_NAME\", False);\n    _glfw.x11.NET_WM_BYPASS_COMPOSITOR =\n        XInternAtom(_glfw.x11.display, \"_NET_WM_BYPASS_COMPOSITOR\", False);\n    _glfw.x11.NET_WM_WINDOW_OPACITY =\n        XInternAtom(_glfw.x11.display, \"_NET_WM_WINDOW_OPACITY\", False);\n    _glfw.x11.MOTIF_WM_HINTS =\n        XInternAtom(_glfw.x11.display, \"_MOTIF_WM_HINTS\", False);\n\n    // The compositing manager selection name contains the screen number\n    {\n        char name[32];\n        snprintf(name, sizeof(name), \"_NET_WM_CM_S%u\", _glfw.x11.screen);\n        _glfw.x11.NET_WM_CM_Sx = XInternAtom(_glfw.x11.display, name, False);\n    }\n\n    return GLFW_TRUE;\n}\n\n// Retrieve system content scale via folklore heuristics\n//\nstatic void getSystemContentScale(float* xscale, float* yscale)\n{\n    // NOTE: Fall back to the display-wide DPI instead of RandR monitor DPI if\n    //       Xft.dpi retrieval below fails as we don't currently have an exact\n    //       policy for which monitor a window is considered to \"be on\"\n    float xdpi = DisplayWidth(_glfw.x11.display, _glfw.x11.screen) *\n        25.4f / DisplayWidthMM(_glfw.x11.display, _glfw.x11.screen);\n    float ydpi = DisplayHeight(_glfw.x11.display, _glfw.x11.screen) *\n        25.4f / DisplayHeightMM(_glfw.x11.display, _glfw.x11.screen);\n\n    // NOTE: Basing the scale on Xft.dpi where available should provide the most\n    //       consistent user experience (matches Qt, Gtk, etc), although not\n    //       always the most accurate one\n    char* rms = XResourceManagerString(_glfw.x11.display);\n    if (rms)\n    {\n        XrmDatabase db = XrmGetStringDatabase(rms);\n        if (db)\n        {\n            XrmValue value;\n            char* type = NULL;\n\n            if (XrmGetResource(db, \"Xft.dpi\", \"Xft.Dpi\", &type, &value))\n            {\n                if (type && strcmp(type, \"String\") == 0)\n                    xdpi = ydpi = atof(value.addr);\n            }\n\n            XrmDestroyDatabase(db);\n        }\n    }\n\n    *xscale = xdpi / 96.f;\n    *yscale = ydpi / 96.f;\n}\n\n// Create a blank cursor for hidden and disabled cursor modes\n//\nstatic Cursor createHiddenCursor(void)\n{\n    unsigned char pixels[16 * 16 * 4] = { 0 };\n    GLFWimage image = { 16, 16, pixels };\n    return _glfwCreateCursorX11(&image, 0, 0);\n}\n\n// Create a helper window for IPC\n//\nstatic Window createHelperWindow(void)\n{\n    XSetWindowAttributes wa;\n    wa.event_mask = PropertyChangeMask;\n\n    return XCreateWindow(_glfw.x11.display, _glfw.x11.root,\n                         0, 0, 1, 1, 0, 0,\n                         InputOnly,\n                         DefaultVisual(_glfw.x11.display, _glfw.x11.screen),\n                         CWEventMask, &wa);\n}\n\n// X error handler\n//\nstatic int errorHandler(Display *display, XErrorEvent* event)\n{\n    _glfw.x11.errorCode = event->error_code;\n    return 0;\n}\n\n\n//////////////////////////////////////////////////////////////////////////\n//////                       GLFW internal API                      //////\n//////////////////////////////////////////////////////////////////////////\n\n// Sets the X error handler callback\n//\nvoid _glfwGrabErrorHandlerX11(void)\n{\n    _glfw.x11.errorCode = Success;\n    XSetErrorHandler(errorHandler);\n}\n\n// Clears the X error handler callback\n//\nvoid _glfwReleaseErrorHandlerX11(void)\n{\n    // Synchronize to make sure all commands are processed\n    XSync(_glfw.x11.display, False);\n    XSetErrorHandler(NULL);\n}\n\n// Reports the specified error, appending information about the last X error\n//\nvoid _glfwInputErrorX11(int error, const char* message)\n{\n    char buffer[_GLFW_MESSAGE_SIZE];\n    XGetErrorText(_glfw.x11.display, _glfw.x11.errorCode,\n                  buffer, sizeof(buffer));\n\n    _glfwInputError(error, \"%s: %s\", message, buffer);\n}\n\n// Creates a native cursor object from the specified image and hotspot\n//\nCursor _glfwCreateCursorX11(const GLFWimage* image, int xhot, int yhot)\n{\n    int i;\n    Cursor cursor;\n\n    if (!_glfw.x11.xcursor.handle)\n        return None;\n\n    XcursorImage* native = XcursorImageCreate(image->width, image->height);\n    if (native == NULL)\n        return None;\n\n    native->xhot = xhot;\n    native->yhot = yhot;\n\n    unsigned char* source = (unsigned char*) image->pixels;\n    XcursorPixel* target = native->pixels;\n\n    for (i = 0;  i < image->width * image->height;  i++, target++, source += 4)\n    {\n        unsigned int alpha = source[3];\n\n        *target = (alpha << 24) |\n                  ((unsigned char) ((source[0] * alpha) / 255) << 16) |\n                  ((unsigned char) ((source[1] * alpha) / 255) <<  8) |\n                  ((unsigned char) ((source[2] * alpha) / 255) <<  0);\n    }\n\n    cursor = XcursorImageLoadCursor(_glfw.x11.display, native);\n    XcursorImageDestroy(native);\n\n    return cursor;\n}\n\n\n//////////////////////////////////////////////////////////////////////////\n//////                       GLFW platform API                      //////\n//////////////////////////////////////////////////////////////////////////\n\nint _glfwPlatformInit(void)\n{\n#if !defined(X_HAVE_UTF8_STRING)\n    // HACK: If the current locale is \"C\" and the Xlib UTF-8 functions are\n    //       unavailable, apply the environment's locale in the hope that it's\n    //       both available and not \"C\"\n    //       This is done because the \"C\" locale breaks wide character input,\n    //       which is what we fall back on when UTF-8 support is missing\n    if (strcmp(setlocale(LC_CTYPE, NULL), \"C\") == 0)\n        setlocale(LC_CTYPE, \"\");\n#endif\n\n    XInitThreads();\n    XrmInitialize();\n\n    _glfw.x11.display = XOpenDisplay(NULL);\n    if (!_glfw.x11.display)\n    {\n        const char* display = getenv(\"DISPLAY\");\n        if (display)\n        {\n            _glfwInputError(GLFW_PLATFORM_ERROR,\n                            \"X11: Failed to open display %s\", display);\n        }\n        else\n        {\n            _glfwInputError(GLFW_PLATFORM_ERROR,\n                            \"X11: The DISPLAY environment variable is missing\");\n        }\n\n        return GLFW_FALSE;\n    }\n\n    _glfw.x11.screen = DefaultScreen(_glfw.x11.display);\n    _glfw.x11.root = RootWindow(_glfw.x11.display, _glfw.x11.screen);\n    _glfw.x11.context = XUniqueContext();\n\n    getSystemContentScale(&_glfw.x11.contentScaleX, &_glfw.x11.contentScaleY);\n\n    if (!initExtensions())\n        return GLFW_FALSE;\n\n    _glfw.x11.helperWindowHandle = createHelperWindow();\n    _glfw.x11.hiddenCursorHandle = createHiddenCursor();\n\n    if (XSupportsLocale())\n    {\n        XSetLocaleModifiers(\"\");\n\n        _glfw.x11.im = XOpenIM(_glfw.x11.display, 0, NULL, NULL);\n        if (_glfw.x11.im)\n        {\n            if (!hasUsableInputMethodStyle())\n            {\n                XCloseIM(_glfw.x11.im);\n                _glfw.x11.im = NULL;\n            }\n        }\n    }\n\n#if defined(__linux__)\n    if (!_glfwInitJoysticksLinux())\n        return GLFW_FALSE;\n#endif\n\n    _glfwInitTimerPOSIX();\n\n    _glfwPollMonitorsX11();\n    return GLFW_TRUE;\n}\n\nvoid _glfwPlatformTerminate(void)\n{\n    if (_glfw.x11.helperWindowHandle)\n    {\n        if (XGetSelectionOwner(_glfw.x11.display, _glfw.x11.CLIPBOARD) ==\n            _glfw.x11.helperWindowHandle)\n        {\n            _glfwPushSelectionToManagerX11();\n        }\n\n        XDestroyWindow(_glfw.x11.display, _glfw.x11.helperWindowHandle);\n        _glfw.x11.helperWindowHandle = None;\n    }\n\n    if (_glfw.x11.hiddenCursorHandle)\n    {\n        XFreeCursor(_glfw.x11.display, _glfw.x11.hiddenCursorHandle);\n        _glfw.x11.hiddenCursorHandle = (Cursor) 0;\n    }\n\n    free(_glfw.x11.primarySelectionString);\n    free(_glfw.x11.clipboardString);\n\n    if (_glfw.x11.im)\n    {\n        XCloseIM(_glfw.x11.im);\n        _glfw.x11.im = NULL;\n    }\n\n    if (_glfw.x11.display)\n    {\n        XCloseDisplay(_glfw.x11.display);\n        _glfw.x11.display = NULL;\n    }\n\n    if (_glfw.x11.x11xcb.handle)\n    {\n        _glfw_dlclose(_glfw.x11.x11xcb.handle);\n        _glfw.x11.x11xcb.handle = NULL;\n    }\n\n    if (_glfw.x11.xcursor.handle)\n    {\n        _glfw_dlclose(_glfw.x11.xcursor.handle);\n        _glfw.x11.xcursor.handle = NULL;\n    }\n\n    if (_glfw.x11.randr.handle)\n    {\n        _glfw_dlclose(_glfw.x11.randr.handle);\n        _glfw.x11.randr.handle = NULL;\n    }\n\n    if (_glfw.x11.xinerama.handle)\n    {\n        _glfw_dlclose(_glfw.x11.xinerama.handle);\n        _glfw.x11.xinerama.handle = NULL;\n    }\n\n    if (_glfw.x11.xrender.handle)\n    {\n        _glfw_dlclose(_glfw.x11.xrender.handle);\n        _glfw.x11.xrender.handle = NULL;\n    }\n\n    if (_glfw.x11.vidmode.handle)\n    {\n        _glfw_dlclose(_glfw.x11.vidmode.handle);\n        _glfw.x11.vidmode.handle = NULL;\n    }\n\n    if (_glfw.x11.xi.handle)\n    {\n        _glfw_dlclose(_glfw.x11.xi.handle);\n        _glfw.x11.xi.handle = NULL;\n    }\n\n    // NOTE: These need to be unloaded after XCloseDisplay, as they register\n    //       cleanup callbacks that get called by that function\n    _glfwTerminateEGL();\n    _glfwTerminateGLX();\n\n#if defined(__linux__)\n    _glfwTerminateJoysticksLinux();\n#endif\n}\n\nconst char* _glfwPlatformGetVersionString(void)\n{\n    return _GLFW_VERSION_NUMBER \" X11 GLX EGL OSMesa\"\n#if defined(_POSIX_TIMERS) && defined(_POSIX_MONOTONIC_CLOCK)\n        \" clock_gettime\"\n#else\n        \" gettimeofday\"\n#endif\n#if defined(__linux__)\n        \" evdev\"\n#endif\n#if defined(_GLFW_BUILD_DLL)\n        \" shared\"\n#endif\n        ;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-glfw-3.3-2fza4cb74pcte44nu2vbzw4ag2osew7l/spack-src/src/cocoa_platform.h": "//========================================================================\n// GLFW 3.3 macOS - www.glfw.org\n//------------------------------------------------------------------------\n// Copyright (c) 2009-2019 Camilla L\u00f6wy <elmindreda@glfw.org>\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would\n//    be appreciated but is not required.\n//\n// 2. Altered source versions must be plainly marked as such, and must not\n//    be misrepresented as being the original software.\n//\n// 3. This notice may not be removed or altered from any source\n//    distribution.\n//\n//========================================================================\n\n#include <stdint.h>\n#include <dlfcn.h>\n\n#include <Carbon/Carbon.h>\n#include <CoreVideo/CVBase.h>\n#include <CoreVideo/CVDisplayLink.h>\n\n// NOTE: All of NSGL was deprecated in the 10.14 SDK\n//       This disables the pointless warnings for every symbol we use\n#define GL_SILENCE_DEPRECATION\n\n#if defined(__OBJC__)\n#import <Cocoa/Cocoa.h>\n#else\ntypedef void* id;\n#endif\n\n#if MAC_OS_X_VERSION_MAX_ALLOWED < 101200\n #define NSBitmapFormatAlphaNonpremultiplied NSAlphaNonpremultipliedBitmapFormat\n #define NSEventMaskAny NSAnyEventMask\n #define NSEventMaskKeyUp NSKeyUpMask\n #define NSEventModifierFlagCapsLock NSAlphaShiftKeyMask\n #define NSEventModifierFlagCommand NSCommandKeyMask\n #define NSEventModifierFlagControl NSControlKeyMask\n #define NSEventModifierFlagDeviceIndependentFlagsMask NSDeviceIndependentModifierFlagsMask\n #define NSEventModifierFlagOption NSAlternateKeyMask\n #define NSEventModifierFlagShift NSShiftKeyMask\n #define NSEventTypeApplicationDefined NSApplicationDefined\n #define NSWindowStyleMaskBorderless NSBorderlessWindowMask\n #define NSWindowStyleMaskClosable NSClosableWindowMask\n #define NSWindowStyleMaskMiniaturizable NSMiniaturizableWindowMask\n #define NSWindowStyleMaskResizable NSResizableWindowMask\n #define NSWindowStyleMaskTitled NSTitledWindowMask\n#endif\n\ntypedef VkFlags VkMacOSSurfaceCreateFlagsMVK;\n\ntypedef struct VkMacOSSurfaceCreateInfoMVK\n{\n    VkStructureType                 sType;\n    const void*                     pNext;\n    VkMacOSSurfaceCreateFlagsMVK    flags;\n    const void*                     pView;\n} VkMacOSSurfaceCreateInfoMVK;\n\ntypedef VkResult (APIENTRY *PFN_vkCreateMacOSSurfaceMVK)(VkInstance,const VkMacOSSurfaceCreateInfoMVK*,const VkAllocationCallbacks*,VkSurfaceKHR*);\n\n#include \"posix_thread.h\"\n#include \"cocoa_joystick.h\"\n#include \"nsgl_context.h\"\n#include \"egl_context.h\"\n#include \"osmesa_context.h\"\n\n#define _glfw_dlopen(name) dlopen(name, RTLD_LAZY | RTLD_LOCAL)\n#define _glfw_dlclose(handle) dlclose(handle)\n#define _glfw_dlsym(handle, name) dlsym(handle, name)\n\n#define _GLFW_EGL_NATIVE_WINDOW  ((EGLNativeWindowType) window->ns.view)\n#define _GLFW_EGL_NATIVE_DISPLAY EGL_DEFAULT_DISPLAY\n\n#define _GLFW_PLATFORM_WINDOW_STATE         _GLFWwindowNS  ns\n#define _GLFW_PLATFORM_LIBRARY_WINDOW_STATE _GLFWlibraryNS ns\n#define _GLFW_PLATFORM_LIBRARY_TIMER_STATE  _GLFWtimerNS   ns\n#define _GLFW_PLATFORM_MONITOR_STATE        _GLFWmonitorNS ns\n#define _GLFW_PLATFORM_CURSOR_STATE         _GLFWcursorNS  ns\n\n// HIToolbox.framework pointer typedefs\n#define kTISPropertyUnicodeKeyLayoutData _glfw.ns.tis.kPropertyUnicodeKeyLayoutData\ntypedef TISInputSourceRef (*PFN_TISCopyCurrentKeyboardLayoutInputSource)(void);\n#define TISCopyCurrentKeyboardLayoutInputSource _glfw.ns.tis.CopyCurrentKeyboardLayoutInputSource\ntypedef void* (*PFN_TISGetInputSourceProperty)(TISInputSourceRef,CFStringRef);\n#define TISGetInputSourceProperty _glfw.ns.tis.GetInputSourceProperty\ntypedef UInt8 (*PFN_LMGetKbdType)(void);\n#define LMGetKbdType _glfw.ns.tis.GetKbdType\n\n\n// Cocoa-specific per-window data\n//\ntypedef struct _GLFWwindowNS\n{\n    id              object;\n    id              delegate;\n    id              view;\n    id              layer;\n\n    GLFWbool        maximized;\n    GLFWbool        retina;\n\n    // Cached window properties to filter out duplicate events\n    int             width, height;\n    int             fbWidth, fbHeight;\n    float           xscale, yscale;\n\n    // The total sum of the distances the cursor has been warped\n    // since the last cursor motion event was processed\n    // This is kept to counteract Cocoa doing the same internally\n    double          cursorWarpDeltaX, cursorWarpDeltaY;\n\n} _GLFWwindowNS;\n\n// Cocoa-specific global data\n//\ntypedef struct _GLFWlibraryNS\n{\n    CGEventSourceRef    eventSource;\n    id                  delegate;\n    GLFWbool            finishedLaunching;\n    GLFWbool            cursorHidden;\n    TISInputSourceRef   inputSource;\n    IOHIDManagerRef     hidManager;\n    id                  unicodeData;\n    id                  helper;\n    id                  keyUpMonitor;\n    id                  nibObjects;\n\n    char                keyName[64];\n    short int           keycodes[256];\n    short int           scancodes[GLFW_KEY_LAST + 1];\n    char*               clipboardString;\n    CGPoint             cascadePoint;\n    // Where to place the cursor when re-enabled\n    double              restoreCursorPosX, restoreCursorPosY;\n    // The window whose disabled cursor mode is active\n    _GLFWwindow*        disabledCursorWindow;\n\n    struct {\n        CFBundleRef     bundle;\n        PFN_TISCopyCurrentKeyboardLayoutInputSource CopyCurrentKeyboardLayoutInputSource;\n        PFN_TISGetInputSourceProperty GetInputSourceProperty;\n        PFN_LMGetKbdType GetKbdType;\n        CFStringRef     kPropertyUnicodeKeyLayoutData;\n    } tis;\n\n} _GLFWlibraryNS;\n\n// Cocoa-specific per-monitor data\n//\ntypedef struct _GLFWmonitorNS\n{\n    CGDirectDisplayID   displayID;\n    CGDisplayModeRef    previousMode;\n    uint32_t            unitNumber;\n    id                  screen;\n\n} _GLFWmonitorNS;\n\n// Cocoa-specific per-cursor data\n//\ntypedef struct _GLFWcursorNS\n{\n    id              object;\n\n} _GLFWcursorNS;\n\n// Cocoa-specific global timer data\n//\ntypedef struct _GLFWtimerNS\n{\n    uint64_t        frequency;\n\n} _GLFWtimerNS;\n\n\nvoid _glfwInitTimerNS(void);\n\nvoid _glfwPollMonitorsNS(void);\nvoid _glfwSetVideoModeNS(_GLFWmonitor* monitor, const GLFWvidmode* desired);\nvoid _glfwRestoreVideoModeNS(_GLFWmonitor* monitor);\n\nfloat _glfwTransformYNS(float y);\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-glfw-3.3-2fza4cb74pcte44nu2vbzw4ag2osew7l/spack-src/src/glx_context.h": "//========================================================================\n// GLFW 3.3 GLX - www.glfw.org\n//------------------------------------------------------------------------\n// Copyright (c) 2002-2006 Marcus Geelnard\n// Copyright (c) 2006-2017 Camilla L\u00f6wy <elmindreda@glfw.org>\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would\n//    be appreciated but is not required.\n//\n// 2. Altered source versions must be plainly marked as such, and must not\n//    be misrepresented as being the original software.\n//\n// 3. This notice may not be removed or altered from any source\n//    distribution.\n//\n//========================================================================\n\n#define GLX_VENDOR 1\n#define GLX_RGBA_BIT 0x00000001\n#define GLX_WINDOW_BIT 0x00000001\n#define GLX_DRAWABLE_TYPE 0x8010\n#define GLX_RENDER_TYPE\t0x8011\n#define GLX_RGBA_TYPE 0x8014\n#define GLX_DOUBLEBUFFER 5\n#define GLX_STEREO 6\n#define GLX_AUX_BUFFERS\t7\n#define GLX_RED_SIZE 8\n#define GLX_GREEN_SIZE 9\n#define GLX_BLUE_SIZE 10\n#define GLX_ALPHA_SIZE 11\n#define GLX_DEPTH_SIZE 12\n#define GLX_STENCIL_SIZE 13\n#define GLX_ACCUM_RED_SIZE 14\n#define GLX_ACCUM_GREEN_SIZE 15\n#define GLX_ACCUM_BLUE_SIZE\t16\n#define GLX_ACCUM_ALPHA_SIZE 17\n#define GLX_SAMPLES 0x186a1\n#define GLX_VISUAL_ID 0x800b\n\n#define GLX_FRAMEBUFFER_SRGB_CAPABLE_ARB 0x20b2\n#define GLX_CONTEXT_DEBUG_BIT_ARB 0x00000001\n#define GLX_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB 0x00000002\n#define GLX_CONTEXT_CORE_PROFILE_BIT_ARB 0x00000001\n#define GLX_CONTEXT_PROFILE_MASK_ARB 0x9126\n#define GLX_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB 0x00000002\n#define GLX_CONTEXT_MAJOR_VERSION_ARB 0x2091\n#define GLX_CONTEXT_MINOR_VERSION_ARB 0x2092\n#define GLX_CONTEXT_FLAGS_ARB 0x2094\n#define GLX_CONTEXT_ES2_PROFILE_BIT_EXT 0x00000004\n#define GLX_CONTEXT_ROBUST_ACCESS_BIT_ARB 0x00000004\n#define GLX_LOSE_CONTEXT_ON_RESET_ARB 0x8252\n#define GLX_CONTEXT_RESET_NOTIFICATION_STRATEGY_ARB 0x8256\n#define GLX_NO_RESET_NOTIFICATION_ARB 0x8261\n#define GLX_CONTEXT_RELEASE_BEHAVIOR_ARB 0x2097\n#define GLX_CONTEXT_RELEASE_BEHAVIOR_NONE_ARB 0\n#define GLX_CONTEXT_RELEASE_BEHAVIOR_FLUSH_ARB 0x2098\n#define GLX_CONTEXT_OPENGL_NO_ERROR_ARB 0x31b3\n\ntypedef XID GLXWindow;\ntypedef XID GLXDrawable;\ntypedef struct __GLXFBConfig* GLXFBConfig;\ntypedef struct __GLXcontext* GLXContext;\ntypedef void (*__GLXextproc)(void);\n\ntypedef int (*PFNGLXGETFBCONFIGATTRIBPROC)(Display*,GLXFBConfig,int,int*);\ntypedef const char* (*PFNGLXGETCLIENTSTRINGPROC)(Display*,int);\ntypedef Bool (*PFNGLXQUERYEXTENSIONPROC)(Display*,int*,int*);\ntypedef Bool (*PFNGLXQUERYVERSIONPROC)(Display*,int*,int*);\ntypedef void (*PFNGLXDESTROYCONTEXTPROC)(Display*,GLXContext);\ntypedef Bool (*PFNGLXMAKECURRENTPROC)(Display*,GLXDrawable,GLXContext);\ntypedef void (*PFNGLXSWAPBUFFERSPROC)(Display*,GLXDrawable);\ntypedef const char* (*PFNGLXQUERYEXTENSIONSSTRINGPROC)(Display*,int);\ntypedef GLXFBConfig* (*PFNGLXGETFBCONFIGSPROC)(Display*,int,int*);\ntypedef GLXContext (*PFNGLXCREATENEWCONTEXTPROC)(Display*,GLXFBConfig,int,GLXContext,Bool);\ntypedef __GLXextproc (* PFNGLXGETPROCADDRESSPROC)(const GLubyte *procName);\ntypedef void (*PFNGLXSWAPINTERVALEXTPROC)(Display*,GLXDrawable,int);\ntypedef XVisualInfo* (*PFNGLXGETVISUALFROMFBCONFIGPROC)(Display*,GLXFBConfig);\ntypedef GLXWindow (*PFNGLXCREATEWINDOWPROC)(Display*,GLXFBConfig,Window,const int*);\ntypedef void (*PFNGLXDESTROYWINDOWPROC)(Display*,GLXWindow);\n\ntypedef int (*PFNGLXSWAPINTERVALMESAPROC)(int);\ntypedef int (*PFNGLXSWAPINTERVALSGIPROC)(int);\ntypedef GLXContext (*PFNGLXCREATECONTEXTATTRIBSARBPROC)(Display*,GLXFBConfig,GLXContext,Bool,const int*);\n\n// libGL.so function pointer typedefs\n#define glXGetFBConfigs _glfw.glx.GetFBConfigs\n#define glXGetFBConfigAttrib _glfw.glx.GetFBConfigAttrib\n#define glXGetClientString _glfw.glx.GetClientString\n#define glXQueryExtension _glfw.glx.QueryExtension\n#define glXQueryVersion _glfw.glx.QueryVersion\n#define glXDestroyContext _glfw.glx.DestroyContext\n#define glXMakeCurrent _glfw.glx.MakeCurrent\n#define glXSwapBuffers _glfw.glx.SwapBuffers\n#define glXQueryExtensionsString _glfw.glx.QueryExtensionsString\n#define glXCreateNewContext _glfw.glx.CreateNewContext\n#define glXGetVisualFromFBConfig _glfw.glx.GetVisualFromFBConfig\n#define glXCreateWindow _glfw.glx.CreateWindow\n#define glXDestroyWindow _glfw.glx.DestroyWindow\n\n#define _GLFW_PLATFORM_CONTEXT_STATE            _GLFWcontextGLX glx\n#define _GLFW_PLATFORM_LIBRARY_CONTEXT_STATE    _GLFWlibraryGLX glx\n\n\n// GLX-specific per-context data\n//\ntypedef struct _GLFWcontextGLX\n{\n    GLXContext      handle;\n    GLXWindow       window;\n\n} _GLFWcontextGLX;\n\n// GLX-specific global data\n//\ntypedef struct _GLFWlibraryGLX\n{\n    int             major, minor;\n    int             eventBase;\n    int             errorBase;\n\n    // dlopen handle for libGL.so.1\n    void*           handle;\n\n    // GLX 1.3 functions\n    PFNGLXGETFBCONFIGSPROC              GetFBConfigs;\n    PFNGLXGETFBCONFIGATTRIBPROC         GetFBConfigAttrib;\n    PFNGLXGETCLIENTSTRINGPROC           GetClientString;\n    PFNGLXQUERYEXTENSIONPROC            QueryExtension;\n    PFNGLXQUERYVERSIONPROC              QueryVersion;\n    PFNGLXDESTROYCONTEXTPROC            DestroyContext;\n    PFNGLXMAKECURRENTPROC               MakeCurrent;\n    PFNGLXSWAPBUFFERSPROC               SwapBuffers;\n    PFNGLXQUERYEXTENSIONSSTRINGPROC     QueryExtensionsString;\n    PFNGLXCREATENEWCONTEXTPROC          CreateNewContext;\n    PFNGLXGETVISUALFROMFBCONFIGPROC     GetVisualFromFBConfig;\n    PFNGLXCREATEWINDOWPROC              CreateWindow;\n    PFNGLXDESTROYWINDOWPROC             DestroyWindow;\n\n    // GLX 1.4 and extension functions\n    PFNGLXGETPROCADDRESSPROC            GetProcAddress;\n    PFNGLXGETPROCADDRESSPROC            GetProcAddressARB;\n    PFNGLXSWAPINTERVALSGIPROC           SwapIntervalSGI;\n    PFNGLXSWAPINTERVALEXTPROC           SwapIntervalEXT;\n    PFNGLXSWAPINTERVALMESAPROC          SwapIntervalMESA;\n    PFNGLXCREATECONTEXTATTRIBSARBPROC   CreateContextAttribsARB;\n    GLFWbool        SGI_swap_control;\n    GLFWbool        EXT_swap_control;\n    GLFWbool        MESA_swap_control;\n    GLFWbool        ARB_multisample;\n    GLFWbool        ARB_framebuffer_sRGB;\n    GLFWbool        EXT_framebuffer_sRGB;\n    GLFWbool        ARB_create_context;\n    GLFWbool        ARB_create_context_profile;\n    GLFWbool        ARB_create_context_robustness;\n    GLFWbool        EXT_create_context_es2_profile;\n    GLFWbool        ARB_create_context_no_error;\n    GLFWbool        ARB_context_flush_control;\n\n} _GLFWlibraryGLX;\n\nGLFWbool _glfwInitGLX(void);\nvoid _glfwTerminateGLX(void);\nGLFWbool _glfwCreateContextGLX(_GLFWwindow* window,\n                               const _GLFWctxconfig* ctxconfig,\n                               const _GLFWfbconfig* fbconfig);\nvoid _glfwDestroyContextGLX(_GLFWwindow* window);\nGLFWbool _glfwChooseVisualGLX(const _GLFWwndconfig* wndconfig,\n                              const _GLFWctxconfig* ctxconfig,\n                              const _GLFWfbconfig* fbconfig,\n                              Visual** visual, int* depth);\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-glfw-3.3-2fza4cb74pcte44nu2vbzw4ag2osew7l/spack-src/src/osmesa_context.c": "//========================================================================\n// GLFW 3.3 OSMesa - www.glfw.org\n//------------------------------------------------------------------------\n// Copyright (c) 2016 Google Inc.\n// Copyright (c) 2016-2017 Camilla L\u00f6wy <elmindreda@glfw.org>\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would\n//    be appreciated but is not required.\n//\n// 2. Altered source versions must be plainly marked as such, and must not\n//    be misrepresented as being the original software.\n//\n// 3. This notice may not be removed or altered from any source\n//    distribution.\n//\n//========================================================================\n\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\n#include \"internal.h\"\n\n\nstatic void makeContextCurrentOSMesa(_GLFWwindow* window)\n{\n    if (window)\n    {\n        int width, height;\n        _glfwPlatformGetFramebufferSize(window, &width, &height);\n\n        // Check to see if we need to allocate a new buffer\n        if ((window->context.osmesa.buffer == NULL) ||\n            (width != window->context.osmesa.width) ||\n            (height != window->context.osmesa.height))\n        {\n            free(window->context.osmesa.buffer);\n\n            // Allocate the new buffer (width * height * 8-bit RGBA)\n            window->context.osmesa.buffer = calloc(4, (size_t) width * height);\n            window->context.osmesa.width  = width;\n            window->context.osmesa.height = height;\n        }\n\n        if (!OSMesaMakeCurrent(window->context.osmesa.handle,\n                               window->context.osmesa.buffer,\n                               GL_UNSIGNED_BYTE,\n                               width, height))\n        {\n            _glfwInputError(GLFW_PLATFORM_ERROR,\n                            \"OSMesa: Failed to make context current\");\n            return;\n        }\n    }\n\n    _glfwPlatformSetTls(&_glfw.contextSlot, window);\n}\n\nstatic GLFWglproc getProcAddressOSMesa(const char* procname)\n{\n    return (GLFWglproc) OSMesaGetProcAddress(procname);\n}\n\nstatic void destroyContextOSMesa(_GLFWwindow* window)\n{\n    if (window->context.osmesa.handle)\n    {\n        OSMesaDestroyContext(window->context.osmesa.handle);\n        window->context.osmesa.handle = NULL;\n    }\n\n    if (window->context.osmesa.buffer)\n    {\n        free(window->context.osmesa.buffer);\n        window->context.osmesa.width = 0;\n        window->context.osmesa.height = 0;\n    }\n}\n\nstatic void swapBuffersOSMesa(_GLFWwindow* window)\n{\n    // No double buffering on OSMesa\n}\n\nstatic void swapIntervalOSMesa(int interval)\n{\n    // No swap interval on OSMesa\n}\n\nstatic int extensionSupportedOSMesa(const char* extension)\n{\n    // OSMesa does not have extensions\n    return GLFW_FALSE;\n}\n\n\n//////////////////////////////////////////////////////////////////////////\n//////                       GLFW internal API                      //////\n//////////////////////////////////////////////////////////////////////////\n\nGLFWbool _glfwInitOSMesa(void)\n{\n    int i;\n    const char* sonames[] =\n    {\n#if defined(_GLFW_OSMESA_LIBRARY)\n        _GLFW_OSMESA_LIBRARY,\n#elif defined(_WIN32)\n        \"libOSMesa.dll\",\n        \"OSMesa.dll\",\n#elif defined(__APPLE__)\n        \"libOSMesa.8.dylib\",\n#elif defined(__CYGWIN__)\n        \"libOSMesa-8.so\",\n#else\n        \"libOSMesa.so.8\",\n        \"libOSMesa.so.6\",\n#endif\n        NULL\n    };\n\n    if (_glfw.osmesa.handle)\n        return GLFW_TRUE;\n\n    for (i = 0;  sonames[i];  i++)\n    {\n        _glfw.osmesa.handle = _glfw_dlopen(sonames[i]);\n        if (_glfw.osmesa.handle)\n            break;\n    }\n\n    if (!_glfw.osmesa.handle)\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE, \"OSMesa: Library not found\");\n        return GLFW_FALSE;\n    }\n\n    _glfw.osmesa.CreateContextExt = (PFN_OSMesaCreateContextExt)\n        _glfw_dlsym(_glfw.osmesa.handle, \"OSMesaCreateContextExt\");\n    _glfw.osmesa.CreateContextAttribs = (PFN_OSMesaCreateContextAttribs)\n        _glfw_dlsym(_glfw.osmesa.handle, \"OSMesaCreateContextAttribs\");\n    _glfw.osmesa.DestroyContext = (PFN_OSMesaDestroyContext)\n        _glfw_dlsym(_glfw.osmesa.handle, \"OSMesaDestroyContext\");\n    _glfw.osmesa.MakeCurrent = (PFN_OSMesaMakeCurrent)\n        _glfw_dlsym(_glfw.osmesa.handle, \"OSMesaMakeCurrent\");\n    _glfw.osmesa.GetColorBuffer = (PFN_OSMesaGetColorBuffer)\n        _glfw_dlsym(_glfw.osmesa.handle, \"OSMesaGetColorBuffer\");\n    _glfw.osmesa.GetDepthBuffer = (PFN_OSMesaGetDepthBuffer)\n        _glfw_dlsym(_glfw.osmesa.handle, \"OSMesaGetDepthBuffer\");\n    _glfw.osmesa.GetProcAddress = (PFN_OSMesaGetProcAddress)\n        _glfw_dlsym(_glfw.osmesa.handle, \"OSMesaGetProcAddress\");\n\n    if (!_glfw.osmesa.CreateContextExt ||\n        !_glfw.osmesa.DestroyContext ||\n        !_glfw.osmesa.MakeCurrent ||\n        !_glfw.osmesa.GetColorBuffer ||\n        !_glfw.osmesa.GetDepthBuffer ||\n        !_glfw.osmesa.GetProcAddress)\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"OSMesa: Failed to load required entry points\");\n\n        _glfwTerminateOSMesa();\n        return GLFW_FALSE;\n    }\n\n    return GLFW_TRUE;\n}\n\nvoid _glfwTerminateOSMesa(void)\n{\n    if (_glfw.osmesa.handle)\n    {\n        _glfw_dlclose(_glfw.osmesa.handle);\n        _glfw.osmesa.handle = NULL;\n    }\n}\n\n#define setAttrib(a, v) \\\n{ \\\n    assert(((size_t) index + 1) < sizeof(attribs) / sizeof(attribs[0])); \\\n    attribs[index++] = a; \\\n    attribs[index++] = v; \\\n}\n\nGLFWbool _glfwCreateContextOSMesa(_GLFWwindow* window,\n                                  const _GLFWctxconfig* ctxconfig,\n                                  const _GLFWfbconfig* fbconfig)\n{\n    OSMesaContext share = NULL;\n    const int accumBits = fbconfig->accumRedBits +\n                          fbconfig->accumGreenBits +\n                          fbconfig->accumBlueBits +\n                          fbconfig->accumAlphaBits;\n\n    if (ctxconfig->client == GLFW_OPENGL_ES_API)\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE,\n                        \"OSMesa: OpenGL ES is not available on OSMesa\");\n        return GLFW_FALSE;\n    }\n\n    if (ctxconfig->share)\n        share = ctxconfig->share->context.osmesa.handle;\n\n    if (OSMesaCreateContextAttribs)\n    {\n        int index = 0, attribs[40];\n\n        setAttrib(OSMESA_FORMAT, OSMESA_RGBA);\n        setAttrib(OSMESA_DEPTH_BITS, fbconfig->depthBits);\n        setAttrib(OSMESA_STENCIL_BITS, fbconfig->stencilBits);\n        setAttrib(OSMESA_ACCUM_BITS, accumBits);\n\n        if (ctxconfig->profile == GLFW_OPENGL_CORE_PROFILE)\n        {\n            setAttrib(OSMESA_PROFILE, OSMESA_CORE_PROFILE);\n        }\n        else if (ctxconfig->profile == GLFW_OPENGL_COMPAT_PROFILE)\n        {\n            setAttrib(OSMESA_PROFILE, OSMESA_COMPAT_PROFILE);\n        }\n\n        if (ctxconfig->major != 1 || ctxconfig->minor != 0)\n        {\n            setAttrib(OSMESA_CONTEXT_MAJOR_VERSION, ctxconfig->major);\n            setAttrib(OSMESA_CONTEXT_MINOR_VERSION, ctxconfig->minor);\n        }\n\n        if (ctxconfig->forward)\n        {\n            _glfwInputError(GLFW_VERSION_UNAVAILABLE,\n                            \"OSMesa: Forward-compatible contexts not supported\");\n            return GLFW_FALSE;\n        }\n\n        setAttrib(0, 0);\n\n        window->context.osmesa.handle =\n            OSMesaCreateContextAttribs(attribs, share);\n    }\n    else\n    {\n        if (ctxconfig->profile)\n        {\n            _glfwInputError(GLFW_VERSION_UNAVAILABLE,\n                            \"OSMesa: OpenGL profiles unavailable\");\n            return GLFW_FALSE;\n        }\n\n        window->context.osmesa.handle =\n            OSMesaCreateContextExt(OSMESA_RGBA,\n                                   fbconfig->depthBits,\n                                   fbconfig->stencilBits,\n                                   accumBits,\n                                   share);\n    }\n\n    if (window->context.osmesa.handle == NULL)\n    {\n        _glfwInputError(GLFW_VERSION_UNAVAILABLE,\n                        \"OSMesa: Failed to create context\");\n        return GLFW_FALSE;\n    }\n\n    window->context.makeCurrent = makeContextCurrentOSMesa;\n    window->context.swapBuffers = swapBuffersOSMesa;\n    window->context.swapInterval = swapIntervalOSMesa;\n    window->context.extensionSupported = extensionSupportedOSMesa;\n    window->context.getProcAddress = getProcAddressOSMesa;\n    window->context.destroy = destroyContextOSMesa;\n\n    return GLFW_TRUE;\n}\n\n#undef setAttrib\n\n\n//////////////////////////////////////////////////////////////////////////\n//////                        GLFW native API                       //////\n//////////////////////////////////////////////////////////////////////////\n\nGLFWAPI int glfwGetOSMesaColorBuffer(GLFWwindow* handle, int* width,\n                                     int* height, int* format, void** buffer)\n{\n    void* mesaBuffer;\n    GLint mesaWidth, mesaHeight, mesaFormat;\n    _GLFWwindow* window = (_GLFWwindow*) handle;\n    assert(window != NULL);\n\n    _GLFW_REQUIRE_INIT_OR_RETURN(GLFW_FALSE);\n\n    if (!OSMesaGetColorBuffer(window->context.osmesa.handle,\n                              &mesaWidth, &mesaHeight,\n                              &mesaFormat, &mesaBuffer))\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"OSMesa: Failed to retrieve color buffer\");\n        return GLFW_FALSE;\n    }\n\n    if (width)\n        *width = mesaWidth;\n    if (height)\n        *height = mesaHeight;\n    if (format)\n        *format = mesaFormat;\n    if (buffer)\n        *buffer = mesaBuffer;\n\n    return GLFW_TRUE;\n}\n\nGLFWAPI int glfwGetOSMesaDepthBuffer(GLFWwindow* handle,\n                                     int* width, int* height,\n                                     int* bytesPerValue,\n                                     void** buffer)\n{\n    void* mesaBuffer;\n    GLint mesaWidth, mesaHeight, mesaBytes;\n    _GLFWwindow* window = (_GLFWwindow*) handle;\n    assert(window != NULL);\n\n    _GLFW_REQUIRE_INIT_OR_RETURN(GLFW_FALSE);\n\n    if (!OSMesaGetDepthBuffer(window->context.osmesa.handle,\n                              &mesaWidth, &mesaHeight,\n                              &mesaBytes, &mesaBuffer))\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"OSMesa: Failed to retrieve depth buffer\");\n        return GLFW_FALSE;\n    }\n\n    if (width)\n        *width = mesaWidth;\n    if (height)\n        *height = mesaHeight;\n    if (bytesPerValue)\n        *bytesPerValue = mesaBytes;\n    if (buffer)\n        *buffer = mesaBuffer;\n\n    return GLFW_TRUE;\n}\n\nGLFWAPI OSMesaContext glfwGetOSMesaContext(GLFWwindow* handle)\n{\n    _GLFWwindow* window = (_GLFWwindow*) handle;\n    _GLFW_REQUIRE_INIT_OR_RETURN(NULL);\n\n    if (window->context.client == GLFW_NO_API)\n    {\n        _glfwInputError(GLFW_NO_WINDOW_CONTEXT, NULL);\n        return NULL;\n    }\n\n    return window->context.osmesa.handle;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-glfw-3.3-2fza4cb74pcte44nu2vbzw4ag2osew7l/spack-src/src/wl_platform.h": "//========================================================================\n// GLFW 3.3 Wayland - www.glfw.org\n//------------------------------------------------------------------------\n// Copyright (c) 2014 Jonas \u00c5dahl <jadahl@gmail.com>\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would\n//    be appreciated but is not required.\n//\n// 2. Altered source versions must be plainly marked as such, and must not\n//    be misrepresented as being the original software.\n//\n// 3. This notice may not be removed or altered from any source\n//    distribution.\n//\n//========================================================================\n\n#include <wayland-client.h>\n#include <xkbcommon/xkbcommon.h>\n#ifdef HAVE_XKBCOMMON_COMPOSE_H\n#include <xkbcommon/xkbcommon-compose.h>\n#endif\n#include <dlfcn.h>\n\ntypedef VkFlags VkWaylandSurfaceCreateFlagsKHR;\n\ntypedef struct VkWaylandSurfaceCreateInfoKHR\n{\n    VkStructureType                 sType;\n    const void*                     pNext;\n    VkWaylandSurfaceCreateFlagsKHR  flags;\n    struct wl_display*              display;\n    struct wl_surface*              surface;\n} VkWaylandSurfaceCreateInfoKHR;\n\ntypedef VkResult (APIENTRY *PFN_vkCreateWaylandSurfaceKHR)(VkInstance,const VkWaylandSurfaceCreateInfoKHR*,const VkAllocationCallbacks*,VkSurfaceKHR*);\ntypedef VkBool32 (APIENTRY *PFN_vkGetPhysicalDeviceWaylandPresentationSupportKHR)(VkPhysicalDevice,uint32_t,struct wl_display*);\n\n#include \"posix_thread.h\"\n#include \"posix_time.h\"\n#ifdef __linux__\n#include \"linux_joystick.h\"\n#else\n#include \"null_joystick.h\"\n#endif\n#include \"xkb_unicode.h\"\n#include \"egl_context.h\"\n#include \"osmesa_context.h\"\n\n#include \"wayland-xdg-shell-client-protocol.h\"\n#include \"wayland-xdg-decoration-client-protocol.h\"\n#include \"wayland-viewporter-client-protocol.h\"\n#include \"wayland-relative-pointer-unstable-v1-client-protocol.h\"\n#include \"wayland-pointer-constraints-unstable-v1-client-protocol.h\"\n#include \"wayland-idle-inhibit-unstable-v1-client-protocol.h\"\n\n#define _glfw_dlopen(name) dlopen(name, RTLD_LAZY | RTLD_LOCAL)\n#define _glfw_dlclose(handle) dlclose(handle)\n#define _glfw_dlsym(handle, name) dlsym(handle, name)\n\n#define _GLFW_EGL_NATIVE_WINDOW         ((EGLNativeWindowType) window->wl.native)\n#define _GLFW_EGL_NATIVE_DISPLAY        ((EGLNativeDisplayType) _glfw.wl.display)\n\n#define _GLFW_PLATFORM_WINDOW_STATE         _GLFWwindowWayland  wl\n#define _GLFW_PLATFORM_LIBRARY_WINDOW_STATE _GLFWlibraryWayland wl\n#define _GLFW_PLATFORM_MONITOR_STATE        _GLFWmonitorWayland wl\n#define _GLFW_PLATFORM_CURSOR_STATE         _GLFWcursorWayland  wl\n\n#define _GLFW_PLATFORM_CONTEXT_STATE\n#define _GLFW_PLATFORM_LIBRARY_CONTEXT_STATE\n\nstruct wl_cursor_image {\n    uint32_t width;\n    uint32_t height;\n    uint32_t hotspot_x;\n    uint32_t hotspot_y;\n    uint32_t delay;\n};\nstruct wl_cursor {\n    unsigned int image_count;\n    struct wl_cursor_image** images;\n    char* name;\n};\ntypedef struct wl_cursor_theme* (* PFN_wl_cursor_theme_load)(const char*, int, struct wl_shm*);\ntypedef void (* PFN_wl_cursor_theme_destroy)(struct wl_cursor_theme*);\ntypedef struct wl_cursor* (* PFN_wl_cursor_theme_get_cursor)(struct wl_cursor_theme*, const char*);\ntypedef struct wl_buffer* (* PFN_wl_cursor_image_get_buffer)(struct wl_cursor_image*);\n#define wl_cursor_theme_load _glfw.wl.cursor.theme_load\n#define wl_cursor_theme_destroy _glfw.wl.cursor.theme_destroy\n#define wl_cursor_theme_get_cursor _glfw.wl.cursor.theme_get_cursor\n#define wl_cursor_image_get_buffer _glfw.wl.cursor.image_get_buffer\n\ntypedef struct wl_egl_window* (* PFN_wl_egl_window_create)(struct wl_surface*, int, int);\ntypedef void (* PFN_wl_egl_window_destroy)(struct wl_egl_window*);\ntypedef void (* PFN_wl_egl_window_resize)(struct wl_egl_window*, int, int, int, int);\n#define wl_egl_window_create _glfw.wl.egl.window_create\n#define wl_egl_window_destroy _glfw.wl.egl.window_destroy\n#define wl_egl_window_resize _glfw.wl.egl.window_resize\n\ntypedef struct xkb_context* (* PFN_xkb_context_new)(enum xkb_context_flags);\ntypedef void (* PFN_xkb_context_unref)(struct xkb_context*);\ntypedef struct xkb_keymap* (* PFN_xkb_keymap_new_from_string)(struct xkb_context*, const char*, enum xkb_keymap_format, enum xkb_keymap_compile_flags);\ntypedef void (* PFN_xkb_keymap_unref)(struct xkb_keymap*);\ntypedef xkb_mod_index_t (* PFN_xkb_keymap_mod_get_index)(struct xkb_keymap*, const char*);\ntypedef int (* PFN_xkb_keymap_key_repeats)(struct xkb_keymap*, xkb_keycode_t);\ntypedef struct xkb_state* (* PFN_xkb_state_new)(struct xkb_keymap*);\ntypedef void (* PFN_xkb_state_unref)(struct xkb_state*);\ntypedef int (* PFN_xkb_state_key_get_syms)(struct xkb_state*, xkb_keycode_t, const xkb_keysym_t**);\ntypedef enum xkb_state_component (* PFN_xkb_state_update_mask)(struct xkb_state*, xkb_mod_mask_t, xkb_mod_mask_t, xkb_mod_mask_t, xkb_layout_index_t, xkb_layout_index_t, xkb_layout_index_t);\ntypedef xkb_mod_mask_t (* PFN_xkb_state_serialize_mods)(struct xkb_state*, enum xkb_state_component);\n#define xkb_context_new _glfw.wl.xkb.context_new\n#define xkb_context_unref _glfw.wl.xkb.context_unref\n#define xkb_keymap_new_from_string _glfw.wl.xkb.keymap_new_from_string\n#define xkb_keymap_unref _glfw.wl.xkb.keymap_unref\n#define xkb_keymap_mod_get_index _glfw.wl.xkb.keymap_mod_get_index\n#define xkb_keymap_key_repeats _glfw.wl.xkb.keymap_key_repeats\n#define xkb_state_new _glfw.wl.xkb.state_new\n#define xkb_state_unref _glfw.wl.xkb.state_unref\n#define xkb_state_key_get_syms _glfw.wl.xkb.state_key_get_syms\n#define xkb_state_update_mask _glfw.wl.xkb.state_update_mask\n#define xkb_state_serialize_mods _glfw.wl.xkb.state_serialize_mods\n\n#ifdef HAVE_XKBCOMMON_COMPOSE_H\ntypedef struct xkb_compose_table* (* PFN_xkb_compose_table_new_from_locale)(struct xkb_context*, const char*, enum xkb_compose_compile_flags);\ntypedef void (* PFN_xkb_compose_table_unref)(struct xkb_compose_table*);\ntypedef struct xkb_compose_state* (* PFN_xkb_compose_state_new)(struct xkb_compose_table*, enum xkb_compose_state_flags);\ntypedef void (* PFN_xkb_compose_state_unref)(struct xkb_compose_state*);\ntypedef enum xkb_compose_feed_result (* PFN_xkb_compose_state_feed)(struct xkb_compose_state*, xkb_keysym_t);\ntypedef enum xkb_compose_status (* PFN_xkb_compose_state_get_status)(struct xkb_compose_state*);\ntypedef xkb_keysym_t (* PFN_xkb_compose_state_get_one_sym)(struct xkb_compose_state*);\n#define xkb_compose_table_new_from_locale _glfw.wl.xkb.compose_table_new_from_locale\n#define xkb_compose_table_unref _glfw.wl.xkb.compose_table_unref\n#define xkb_compose_state_new _glfw.wl.xkb.compose_state_new\n#define xkb_compose_state_unref _glfw.wl.xkb.compose_state_unref\n#define xkb_compose_state_feed _glfw.wl.xkb.compose_state_feed\n#define xkb_compose_state_get_status _glfw.wl.xkb.compose_state_get_status\n#define xkb_compose_state_get_one_sym _glfw.wl.xkb.compose_state_get_one_sym\n#endif\n\n#define _GLFW_DECORATION_WIDTH 4\n#define _GLFW_DECORATION_TOP 24\n#define _GLFW_DECORATION_VERTICAL (_GLFW_DECORATION_TOP + _GLFW_DECORATION_WIDTH)\n#define _GLFW_DECORATION_HORIZONTAL (2 * _GLFW_DECORATION_WIDTH)\n\ntypedef enum _GLFWdecorationSideWayland\n{\n    mainWindow,\n    topDecoration,\n    leftDecoration,\n    rightDecoration,\n    bottomDecoration,\n\n} _GLFWdecorationSideWayland;\n\ntypedef struct _GLFWdecorationWayland\n{\n    struct wl_surface*          surface;\n    struct wl_subsurface*       subsurface;\n    struct wp_viewport*         viewport;\n\n} _GLFWdecorationWayland;\n\n// Wayland-specific per-window data\n//\ntypedef struct _GLFWwindowWayland\n{\n    int                         width, height;\n    GLFWbool                    visible;\n    GLFWbool                    maximized;\n    GLFWbool                    hovered;\n    GLFWbool                    transparent;\n    struct wl_surface*          surface;\n    struct wl_egl_window*       native;\n    struct wl_shell_surface*    shellSurface;\n    struct wl_callback*         callback;\n\n    struct {\n        struct xdg_surface*     surface;\n        struct xdg_toplevel*    toplevel;\n        struct zxdg_toplevel_decoration_v1* decoration;\n    } xdg;\n\n    _GLFWcursor*                currentCursor;\n    double                      cursorPosX, cursorPosY;\n\n    char*                       title;\n\n    // We need to track the monitors the window spans on to calculate the\n    // optimal scaling factor.\n    int                         scale;\n    _GLFWmonitor**              monitors;\n    int                         monitorsCount;\n    int                         monitorsSize;\n\n    struct {\n        struct zwp_relative_pointer_v1*    relativePointer;\n        struct zwp_locked_pointer_v1*      lockedPointer;\n    } pointerLock;\n\n    struct zwp_idle_inhibitor_v1*          idleInhibitor;\n\n    GLFWbool                    wasFullscreen;\n\n    struct {\n        GLFWbool                           serverSide;\n        struct wl_buffer*                  buffer;\n        _GLFWdecorationWayland             top, left, right, bottom;\n        int                                focus;\n    } decorations;\n\n} _GLFWwindowWayland;\n\n// Wayland-specific global data\n//\ntypedef struct _GLFWlibraryWayland\n{\n    struct wl_display*          display;\n    struct wl_registry*         registry;\n    struct wl_compositor*       compositor;\n    struct wl_subcompositor*    subcompositor;\n    struct wl_shell*            shell;\n    struct wl_shm*              shm;\n    struct wl_seat*             seat;\n    struct wl_pointer*          pointer;\n    struct wl_keyboard*         keyboard;\n    struct wl_data_device_manager*          dataDeviceManager;\n    struct wl_data_device*      dataDevice;\n    struct wl_data_offer*       dataOffer;\n    struct wl_data_source*      dataSource;\n    struct xdg_wm_base*         wmBase;\n    struct zxdg_decoration_manager_v1*      decorationManager;\n    struct wp_viewporter*       viewporter;\n    struct zwp_relative_pointer_manager_v1* relativePointerManager;\n    struct zwp_pointer_constraints_v1*      pointerConstraints;\n    struct zwp_idle_inhibit_manager_v1*     idleInhibitManager;\n\n    int                         compositorVersion;\n    int                         seatVersion;\n\n    struct wl_cursor_theme*     cursorTheme;\n    struct wl_cursor_theme*     cursorThemeHiDPI;\n    struct wl_surface*          cursorSurface;\n    int                         cursorTimerfd;\n    uint32_t                    serial;\n\n    int32_t                     keyboardRepeatRate;\n    int32_t                     keyboardRepeatDelay;\n    int                         keyboardLastKey;\n    int                         keyboardLastScancode;\n    char*                       clipboardString;\n    size_t                      clipboardSize;\n    char*                       clipboardSendString;\n    size_t                      clipboardSendSize;\n    int                         timerfd;\n    short int                   keycodes[256];\n    short int                   scancodes[GLFW_KEY_LAST + 1];\n\n    struct {\n        void*                   handle;\n        struct xkb_context*     context;\n        struct xkb_keymap*      keymap;\n        struct xkb_state*       state;\n\n#ifdef HAVE_XKBCOMMON_COMPOSE_H\n        struct xkb_compose_state* composeState;\n#endif\n\n        xkb_mod_mask_t          controlMask;\n        xkb_mod_mask_t          altMask;\n        xkb_mod_mask_t          shiftMask;\n        xkb_mod_mask_t          superMask;\n        xkb_mod_mask_t          capsLockMask;\n        xkb_mod_mask_t          numLockMask;\n        unsigned int            modifiers;\n\n        PFN_xkb_context_new context_new;\n        PFN_xkb_context_unref context_unref;\n        PFN_xkb_keymap_new_from_string keymap_new_from_string;\n        PFN_xkb_keymap_unref keymap_unref;\n        PFN_xkb_keymap_mod_get_index keymap_mod_get_index;\n        PFN_xkb_keymap_key_repeats keymap_key_repeats;\n        PFN_xkb_state_new state_new;\n        PFN_xkb_state_unref state_unref;\n        PFN_xkb_state_key_get_syms state_key_get_syms;\n        PFN_xkb_state_update_mask state_update_mask;\n        PFN_xkb_state_serialize_mods state_serialize_mods;\n\n#ifdef HAVE_XKBCOMMON_COMPOSE_H\n        PFN_xkb_compose_table_new_from_locale compose_table_new_from_locale;\n        PFN_xkb_compose_table_unref compose_table_unref;\n        PFN_xkb_compose_state_new compose_state_new;\n        PFN_xkb_compose_state_unref compose_state_unref;\n        PFN_xkb_compose_state_feed compose_state_feed;\n        PFN_xkb_compose_state_get_status compose_state_get_status;\n        PFN_xkb_compose_state_get_one_sym compose_state_get_one_sym;\n#endif\n    } xkb;\n\n    _GLFWwindow*                pointerFocus;\n    _GLFWwindow*                keyboardFocus;\n\n    struct {\n        void*                   handle;\n\n        PFN_wl_cursor_theme_load theme_load;\n        PFN_wl_cursor_theme_destroy theme_destroy;\n        PFN_wl_cursor_theme_get_cursor theme_get_cursor;\n        PFN_wl_cursor_image_get_buffer image_get_buffer;\n    } cursor;\n\n    struct {\n        void*                   handle;\n\n        PFN_wl_egl_window_create window_create;\n        PFN_wl_egl_window_destroy window_destroy;\n        PFN_wl_egl_window_resize window_resize;\n    } egl;\n\n} _GLFWlibraryWayland;\n\n// Wayland-specific per-monitor data\n//\ntypedef struct _GLFWmonitorWayland\n{\n    struct wl_output*           output;\n    int                         name;\n    int                         currentMode;\n\n    int                         x;\n    int                         y;\n    int                         scale;\n\n} _GLFWmonitorWayland;\n\n// Wayland-specific per-cursor data\n//\ntypedef struct _GLFWcursorWayland\n{\n    struct wl_cursor*           cursor;\n    struct wl_cursor*           cursorHiDPI;\n    struct wl_buffer*           buffer;\n    int                         width, height;\n    int                         xhot, yhot;\n    int                         currentImage;\n} _GLFWcursorWayland;\n\n\nvoid _glfwAddOutputWayland(uint32_t name, uint32_t version);\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-glfw-3.3-2fza4cb74pcte44nu2vbzw4ag2osew7l/spack-src/src/wl_init.c": "//========================================================================\n// GLFW 3.3 Wayland - www.glfw.org\n//------------------------------------------------------------------------\n// Copyright (c) 2014 Jonas \u00c5dahl <jadahl@gmail.com>\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would\n//    be appreciated but is not required.\n//\n// 2. Altered source versions must be plainly marked as such, and must not\n//    be misrepresented as being the original software.\n//\n// 3. This notice may not be removed or altered from any source\n//    distribution.\n//\n//========================================================================\n\n#include \"internal.h\"\n\n#include <assert.h>\n#include <errno.h>\n#include <limits.h>\n#include <linux/input.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <sys/timerfd.h>\n#include <unistd.h>\n#include <wayland-client.h>\n\n\nstatic inline int min(int n1, int n2)\n{\n    return n1 < n2 ? n1 : n2;\n}\n\nstatic _GLFWwindow* findWindowFromDecorationSurface(struct wl_surface* surface,\n                                                    int* which)\n{\n    int focus;\n    _GLFWwindow* window = _glfw.windowListHead;\n    if (!which)\n        which = &focus;\n    while (window)\n    {\n        if (surface == window->wl.decorations.top.surface)\n        {\n            *which = topDecoration;\n            break;\n        }\n        if (surface == window->wl.decorations.left.surface)\n        {\n            *which = leftDecoration;\n            break;\n        }\n        if (surface == window->wl.decorations.right.surface)\n        {\n            *which = rightDecoration;\n            break;\n        }\n        if (surface == window->wl.decorations.bottom.surface)\n        {\n            *which = bottomDecoration;\n            break;\n        }\n        window = window->next;\n    }\n    return window;\n}\n\nstatic void pointerHandleEnter(void* data,\n                               struct wl_pointer* pointer,\n                               uint32_t serial,\n                               struct wl_surface* surface,\n                               wl_fixed_t sx,\n                               wl_fixed_t sy)\n{\n    // Happens in the case we just destroyed the surface.\n    if (!surface)\n        return;\n\n    int focus = 0;\n    _GLFWwindow* window = wl_surface_get_user_data(surface);\n    if (!window)\n    {\n        window = findWindowFromDecorationSurface(surface, &focus);\n        if (!window)\n            return;\n    }\n\n    window->wl.decorations.focus = focus;\n    _glfw.wl.serial = serial;\n    _glfw.wl.pointerFocus = window;\n\n    window->wl.hovered = GLFW_TRUE;\n\n    _glfwPlatformSetCursor(window, window->wl.currentCursor);\n    _glfwInputCursorEnter(window, GLFW_TRUE);\n}\n\nstatic void pointerHandleLeave(void* data,\n                               struct wl_pointer* pointer,\n                               uint32_t serial,\n                               struct wl_surface* surface)\n{\n    _GLFWwindow* window = _glfw.wl.pointerFocus;\n\n    if (!window)\n        return;\n\n    window->wl.hovered = GLFW_FALSE;\n\n    _glfw.wl.serial = serial;\n    _glfw.wl.pointerFocus = NULL;\n    _glfwInputCursorEnter(window, GLFW_FALSE);\n}\n\nstatic void setCursor(_GLFWwindow* window, const char* name)\n{\n    struct wl_buffer* buffer;\n    struct wl_cursor* cursor;\n    struct wl_cursor_image* image;\n    struct wl_surface* surface = _glfw.wl.cursorSurface;\n    struct wl_cursor_theme* theme = _glfw.wl.cursorTheme;\n    int scale = 1;\n\n    if (window->wl.scale > 1 && _glfw.wl.cursorThemeHiDPI)\n    {\n        // We only support up to scale=2 for now, since libwayland-cursor\n        // requires us to load a different theme for each size.\n        scale = 2;\n        theme = _glfw.wl.cursorThemeHiDPI;\n    }\n\n    cursor = wl_cursor_theme_get_cursor(theme, name);\n    if (!cursor)\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"Wayland: Standard cursor not found\");\n        return;\n    }\n    // TODO: handle animated cursors too.\n    image = cursor->images[0];\n\n    if (!image)\n        return;\n\n    buffer = wl_cursor_image_get_buffer(image);\n    if (!buffer)\n        return;\n    wl_pointer_set_cursor(_glfw.wl.pointer, _glfw.wl.serial,\n                          surface,\n                          image->hotspot_x / scale,\n                          image->hotspot_y / scale);\n    wl_surface_set_buffer_scale(surface, scale);\n    wl_surface_attach(surface, buffer, 0, 0);\n    wl_surface_damage(surface, 0, 0,\n                      image->width, image->height);\n    wl_surface_commit(surface);\n}\n\nstatic void pointerHandleMotion(void* data,\n                                struct wl_pointer* pointer,\n                                uint32_t time,\n                                wl_fixed_t sx,\n                                wl_fixed_t sy)\n{\n    _GLFWwindow* window = _glfw.wl.pointerFocus;\n    const char* cursorName;\n\n    if (!window)\n        return;\n\n    if (window->cursorMode == GLFW_CURSOR_DISABLED)\n        return;\n    else\n    {\n        window->wl.cursorPosX = wl_fixed_to_double(sx);\n        window->wl.cursorPosY = wl_fixed_to_double(sy);\n    }\n\n    switch (window->wl.decorations.focus)\n    {\n        case mainWindow:\n            _glfwInputCursorPos(window,\n                                wl_fixed_to_double(sx),\n                                wl_fixed_to_double(sy));\n            return;\n        case topDecoration:\n            if (window->wl.cursorPosY < _GLFW_DECORATION_WIDTH)\n                cursorName = \"n-resize\";\n            else\n                cursorName = \"left_ptr\";\n            break;\n        case leftDecoration:\n            if (window->wl.cursorPosY < _GLFW_DECORATION_WIDTH)\n                cursorName = \"nw-resize\";\n            else\n                cursorName = \"w-resize\";\n            break;\n        case rightDecoration:\n            if (window->wl.cursorPosY < _GLFW_DECORATION_WIDTH)\n                cursorName = \"ne-resize\";\n            else\n                cursorName = \"e-resize\";\n            break;\n        case bottomDecoration:\n            if (window->wl.cursorPosX < _GLFW_DECORATION_WIDTH)\n                cursorName = \"sw-resize\";\n            else if (window->wl.cursorPosX > window->wl.width + _GLFW_DECORATION_WIDTH)\n                cursorName = \"se-resize\";\n            else\n                cursorName = \"s-resize\";\n            break;\n        default:\n            assert(0);\n    }\n    setCursor(window, cursorName);\n}\n\nstatic void pointerHandleButton(void* data,\n                                struct wl_pointer* pointer,\n                                uint32_t serial,\n                                uint32_t time,\n                                uint32_t button,\n                                uint32_t state)\n{\n    _GLFWwindow* window = _glfw.wl.pointerFocus;\n    int glfwButton;\n\n    // Both xdg-shell and wl_shell use the same values.\n    uint32_t edges = WL_SHELL_SURFACE_RESIZE_NONE;\n\n    if (!window)\n        return;\n    if (button == BTN_LEFT)\n    {\n        switch (window->wl.decorations.focus)\n        {\n            case mainWindow:\n                break;\n            case topDecoration:\n                if (window->wl.cursorPosY < _GLFW_DECORATION_WIDTH)\n                    edges = WL_SHELL_SURFACE_RESIZE_TOP;\n                else\n                {\n                    if (window->wl.xdg.toplevel)\n                        xdg_toplevel_move(window->wl.xdg.toplevel, _glfw.wl.seat, serial);\n                    else\n                        wl_shell_surface_move(window->wl.shellSurface, _glfw.wl.seat, serial);\n                }\n                break;\n            case leftDecoration:\n                if (window->wl.cursorPosY < _GLFW_DECORATION_WIDTH)\n                    edges = WL_SHELL_SURFACE_RESIZE_TOP_LEFT;\n                else\n                    edges = WL_SHELL_SURFACE_RESIZE_LEFT;\n                break;\n            case rightDecoration:\n                if (window->wl.cursorPosY < _GLFW_DECORATION_WIDTH)\n                    edges = WL_SHELL_SURFACE_RESIZE_TOP_RIGHT;\n                else\n                    edges = WL_SHELL_SURFACE_RESIZE_RIGHT;\n                break;\n            case bottomDecoration:\n                if (window->wl.cursorPosX < _GLFW_DECORATION_WIDTH)\n                    edges = WL_SHELL_SURFACE_RESIZE_BOTTOM_LEFT;\n                else if (window->wl.cursorPosX > window->wl.width + _GLFW_DECORATION_WIDTH)\n                    edges = WL_SHELL_SURFACE_RESIZE_BOTTOM_RIGHT;\n                else\n                    edges = WL_SHELL_SURFACE_RESIZE_BOTTOM;\n                break;\n            default:\n                assert(0);\n        }\n        if (edges != WL_SHELL_SURFACE_RESIZE_NONE)\n        {\n            if (window->wl.xdg.toplevel)\n                xdg_toplevel_resize(window->wl.xdg.toplevel, _glfw.wl.seat,\n                                    serial, edges);\n            else\n                wl_shell_surface_resize(window->wl.shellSurface, _glfw.wl.seat,\n                                        serial, edges);\n        }\n    }\n    else if (button == BTN_RIGHT)\n    {\n        if (window->wl.decorations.focus != mainWindow && window->wl.xdg.toplevel)\n        {\n            xdg_toplevel_show_window_menu(window->wl.xdg.toplevel,\n                                          _glfw.wl.seat, serial,\n                                          window->wl.cursorPosX,\n                                          window->wl.cursorPosY);\n            return;\n        }\n    }\n\n    // Don\u2019t pass the button to the user if it was related to a decoration.\n    if (window->wl.decorations.focus != mainWindow)\n        return;\n\n    _glfw.wl.serial = serial;\n\n    /* Makes left, right and middle 0, 1 and 2. Overall order follows evdev\n     * codes. */\n    glfwButton = button - BTN_LEFT;\n\n    _glfwInputMouseClick(window,\n                         glfwButton,\n                         state == WL_POINTER_BUTTON_STATE_PRESSED\n                                ? GLFW_PRESS\n                                : GLFW_RELEASE,\n                         _glfw.wl.xkb.modifiers);\n}\n\nstatic void pointerHandleAxis(void* data,\n                              struct wl_pointer* pointer,\n                              uint32_t time,\n                              uint32_t axis,\n                              wl_fixed_t value)\n{\n    _GLFWwindow* window = _glfw.wl.pointerFocus;\n    double x = 0.0, y = 0.0;\n    // Wayland scroll events are in pointer motion coordinate space (think two\n    // finger scroll).  The factor 10 is commonly used to convert to \"scroll\n    // step means 1.0.\n    const double scrollFactor = 1.0 / 10.0;\n\n    if (!window)\n        return;\n\n    assert(axis == WL_POINTER_AXIS_HORIZONTAL_SCROLL ||\n           axis == WL_POINTER_AXIS_VERTICAL_SCROLL);\n\n    if (axis == WL_POINTER_AXIS_HORIZONTAL_SCROLL)\n        x = wl_fixed_to_double(value) * scrollFactor;\n    else if (axis == WL_POINTER_AXIS_VERTICAL_SCROLL)\n        y = wl_fixed_to_double(value) * scrollFactor;\n\n    _glfwInputScroll(window, x, y);\n}\n\nstatic const struct wl_pointer_listener pointerListener = {\n    pointerHandleEnter,\n    pointerHandleLeave,\n    pointerHandleMotion,\n    pointerHandleButton,\n    pointerHandleAxis,\n};\n\nstatic void keyboardHandleKeymap(void* data,\n                                 struct wl_keyboard* keyboard,\n                                 uint32_t format,\n                                 int fd,\n                                 uint32_t size)\n{\n    struct xkb_keymap* keymap;\n    struct xkb_state* state;\n\n#ifdef HAVE_XKBCOMMON_COMPOSE_H\n    struct xkb_compose_table* composeTable;\n    struct xkb_compose_state* composeState;\n#endif\n\n    char* mapStr;\n    const char* locale;\n\n    if (format != WL_KEYBOARD_KEYMAP_FORMAT_XKB_V1)\n    {\n        close(fd);\n        return;\n    }\n\n    mapStr = mmap(NULL, size, PROT_READ, MAP_SHARED, fd, 0);\n    if (mapStr == MAP_FAILED) {\n        close(fd);\n        return;\n    }\n\n    keymap = xkb_keymap_new_from_string(_glfw.wl.xkb.context,\n                                        mapStr,\n                                        XKB_KEYMAP_FORMAT_TEXT_V1,\n                                        0);\n    munmap(mapStr, size);\n    close(fd);\n\n    if (!keymap)\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"Wayland: Failed to compile keymap\");\n        return;\n    }\n\n    state = xkb_state_new(keymap);\n    if (!state)\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"Wayland: Failed to create XKB state\");\n        xkb_keymap_unref(keymap);\n        return;\n    }\n\n    // Look up the preferred locale, falling back to \"C\" as default.\n    locale = getenv(\"LC_ALL\");\n    if (!locale)\n        locale = getenv(\"LC_CTYPE\");\n    if (!locale)\n        locale = getenv(\"LANG\");\n    if (!locale)\n        locale = \"C\";\n\n#ifdef HAVE_XKBCOMMON_COMPOSE_H\n    composeTable =\n        xkb_compose_table_new_from_locale(_glfw.wl.xkb.context, locale,\n                                          XKB_COMPOSE_COMPILE_NO_FLAGS);\n    if (composeTable)\n    {\n        composeState =\n            xkb_compose_state_new(composeTable, XKB_COMPOSE_STATE_NO_FLAGS);\n        xkb_compose_table_unref(composeTable);\n        if (composeState)\n            _glfw.wl.xkb.composeState = composeState;\n        else\n            _glfwInputError(GLFW_PLATFORM_ERROR,\n                            \"Wayland: Failed to create XKB compose state\");\n    }\n    else\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"Wayland: Failed to create XKB compose table\");\n    }\n#endif\n\n    xkb_keymap_unref(_glfw.wl.xkb.keymap);\n    xkb_state_unref(_glfw.wl.xkb.state);\n    _glfw.wl.xkb.keymap = keymap;\n    _glfw.wl.xkb.state = state;\n\n    _glfw.wl.xkb.controlMask =\n        1 << xkb_keymap_mod_get_index(_glfw.wl.xkb.keymap, \"Control\");\n    _glfw.wl.xkb.altMask =\n        1 << xkb_keymap_mod_get_index(_glfw.wl.xkb.keymap, \"Mod1\");\n    _glfw.wl.xkb.shiftMask =\n        1 << xkb_keymap_mod_get_index(_glfw.wl.xkb.keymap, \"Shift\");\n    _glfw.wl.xkb.superMask =\n        1 << xkb_keymap_mod_get_index(_glfw.wl.xkb.keymap, \"Mod4\");\n    _glfw.wl.xkb.capsLockMask =\n        1 << xkb_keymap_mod_get_index(_glfw.wl.xkb.keymap, \"Lock\");\n    _glfw.wl.xkb.numLockMask =\n        1 << xkb_keymap_mod_get_index(_glfw.wl.xkb.keymap, \"Mod2\");\n}\n\nstatic void keyboardHandleEnter(void* data,\n                                struct wl_keyboard* keyboard,\n                                uint32_t serial,\n                                struct wl_surface* surface,\n                                struct wl_array* keys)\n{\n    // Happens in the case we just destroyed the surface.\n    if (!surface)\n        return;\n\n    _GLFWwindow* window = wl_surface_get_user_data(surface);\n    if (!window)\n    {\n        window = findWindowFromDecorationSurface(surface, NULL);\n        if (!window)\n            return;\n    }\n\n    _glfw.wl.serial = serial;\n    _glfw.wl.keyboardFocus = window;\n    _glfwInputWindowFocus(window, GLFW_TRUE);\n}\n\nstatic void keyboardHandleLeave(void* data,\n                                struct wl_keyboard* keyboard,\n                                uint32_t serial,\n                                struct wl_surface* surface)\n{\n    _GLFWwindow* window = _glfw.wl.keyboardFocus;\n\n    if (!window)\n        return;\n\n    _glfw.wl.serial = serial;\n    _glfw.wl.keyboardFocus = NULL;\n    _glfwInputWindowFocus(window, GLFW_FALSE);\n}\n\nstatic int toGLFWKeyCode(uint32_t key)\n{\n    if (key < sizeof(_glfw.wl.keycodes) / sizeof(_glfw.wl.keycodes[0]))\n        return _glfw.wl.keycodes[key];\n\n    return GLFW_KEY_UNKNOWN;\n}\n\n#ifdef HAVE_XKBCOMMON_COMPOSE_H\nstatic xkb_keysym_t composeSymbol(xkb_keysym_t sym)\n{\n    if (sym == XKB_KEY_NoSymbol || !_glfw.wl.xkb.composeState)\n        return sym;\n    if (xkb_compose_state_feed(_glfw.wl.xkb.composeState, sym)\n            != XKB_COMPOSE_FEED_ACCEPTED)\n        return sym;\n    switch (xkb_compose_state_get_status(_glfw.wl.xkb.composeState))\n    {\n        case XKB_COMPOSE_COMPOSED:\n            return xkb_compose_state_get_one_sym(_glfw.wl.xkb.composeState);\n        case XKB_COMPOSE_COMPOSING:\n        case XKB_COMPOSE_CANCELLED:\n            return XKB_KEY_NoSymbol;\n        case XKB_COMPOSE_NOTHING:\n        default:\n            return sym;\n    }\n}\n#endif\n\nstatic GLFWbool inputChar(_GLFWwindow* window, uint32_t key)\n{\n    uint32_t code, numSyms;\n    long cp;\n    const xkb_keysym_t *syms;\n    xkb_keysym_t sym;\n\n    code = key + 8;\n    numSyms = xkb_state_key_get_syms(_glfw.wl.xkb.state, code, &syms);\n\n    if (numSyms == 1)\n    {\n#ifdef HAVE_XKBCOMMON_COMPOSE_H\n        sym = composeSymbol(syms[0]);\n#else\n        sym = syms[0];\n#endif\n        cp = _glfwKeySym2Unicode(sym);\n        if (cp != -1)\n        {\n            const int mods = _glfw.wl.xkb.modifiers;\n            const int plain = !(mods & (GLFW_MOD_CONTROL | GLFW_MOD_ALT));\n            _glfwInputChar(window, cp, mods, plain);\n        }\n    }\n\n    return xkb_keymap_key_repeats(_glfw.wl.xkb.keymap, syms[0]);\n}\n\nstatic void keyboardHandleKey(void* data,\n                              struct wl_keyboard* keyboard,\n                              uint32_t serial,\n                              uint32_t time,\n                              uint32_t key,\n                              uint32_t state)\n{\n    int keyCode;\n    int action;\n    _GLFWwindow* window = _glfw.wl.keyboardFocus;\n    GLFWbool shouldRepeat;\n    struct itimerspec timer = {};\n\n    if (!window)\n        return;\n\n    keyCode = toGLFWKeyCode(key);\n    action = state == WL_KEYBOARD_KEY_STATE_PRESSED\n            ? GLFW_PRESS : GLFW_RELEASE;\n\n    _glfw.wl.serial = serial;\n    _glfwInputKey(window, keyCode, key, action,\n                  _glfw.wl.xkb.modifiers);\n\n    if (action == GLFW_PRESS)\n    {\n        shouldRepeat = inputChar(window, key);\n\n        if (shouldRepeat && _glfw.wl.keyboardRepeatRate > 0)\n        {\n            _glfw.wl.keyboardLastKey = keyCode;\n            _glfw.wl.keyboardLastScancode = key;\n            if (_glfw.wl.keyboardRepeatRate > 1)\n                timer.it_interval.tv_nsec = 1000000000 / _glfw.wl.keyboardRepeatRate;\n            else\n                timer.it_interval.tv_sec = 1;\n            timer.it_value.tv_sec = _glfw.wl.keyboardRepeatDelay / 1000;\n            timer.it_value.tv_nsec = (_glfw.wl.keyboardRepeatDelay % 1000) * 1000000;\n        }\n    }\n    timerfd_settime(_glfw.wl.timerfd, 0, &timer, NULL);\n}\n\nstatic void keyboardHandleModifiers(void* data,\n                                    struct wl_keyboard* keyboard,\n                                    uint32_t serial,\n                                    uint32_t modsDepressed,\n                                    uint32_t modsLatched,\n                                    uint32_t modsLocked,\n                                    uint32_t group)\n{\n    xkb_mod_mask_t mask;\n    unsigned int modifiers = 0;\n\n    _glfw.wl.serial = serial;\n\n    if (!_glfw.wl.xkb.keymap)\n        return;\n\n    xkb_state_update_mask(_glfw.wl.xkb.state,\n                          modsDepressed,\n                          modsLatched,\n                          modsLocked,\n                          0,\n                          0,\n                          group);\n\n    mask = xkb_state_serialize_mods(_glfw.wl.xkb.state,\n                                    XKB_STATE_MODS_DEPRESSED |\n                                    XKB_STATE_LAYOUT_DEPRESSED |\n                                    XKB_STATE_MODS_LATCHED |\n                                    XKB_STATE_LAYOUT_LATCHED);\n    if (mask & _glfw.wl.xkb.controlMask)\n        modifiers |= GLFW_MOD_CONTROL;\n    if (mask & _glfw.wl.xkb.altMask)\n        modifiers |= GLFW_MOD_ALT;\n    if (mask & _glfw.wl.xkb.shiftMask)\n        modifiers |= GLFW_MOD_SHIFT;\n    if (mask & _glfw.wl.xkb.superMask)\n        modifiers |= GLFW_MOD_SUPER;\n    if (mask & _glfw.wl.xkb.capsLockMask)\n        modifiers |= GLFW_MOD_CAPS_LOCK;\n    if (mask & _glfw.wl.xkb.numLockMask)\n        modifiers |= GLFW_MOD_NUM_LOCK;\n    _glfw.wl.xkb.modifiers = modifiers;\n}\n\n#ifdef WL_KEYBOARD_REPEAT_INFO_SINCE_VERSION\nstatic void keyboardHandleRepeatInfo(void* data,\n                                     struct wl_keyboard* keyboard,\n                                     int32_t rate,\n                                     int32_t delay)\n{\n    if (keyboard != _glfw.wl.keyboard)\n        return;\n\n    _glfw.wl.keyboardRepeatRate = rate;\n    _glfw.wl.keyboardRepeatDelay = delay;\n}\n#endif\n\nstatic const struct wl_keyboard_listener keyboardListener = {\n    keyboardHandleKeymap,\n    keyboardHandleEnter,\n    keyboardHandleLeave,\n    keyboardHandleKey,\n    keyboardHandleModifiers,\n#ifdef WL_KEYBOARD_REPEAT_INFO_SINCE_VERSION\n    keyboardHandleRepeatInfo,\n#endif\n};\n\nstatic void seatHandleCapabilities(void* data,\n                                   struct wl_seat* seat,\n                                   enum wl_seat_capability caps)\n{\n    if ((caps & WL_SEAT_CAPABILITY_POINTER) && !_glfw.wl.pointer)\n    {\n        _glfw.wl.pointer = wl_seat_get_pointer(seat);\n        wl_pointer_add_listener(_glfw.wl.pointer, &pointerListener, NULL);\n    }\n    else if (!(caps & WL_SEAT_CAPABILITY_POINTER) && _glfw.wl.pointer)\n    {\n        wl_pointer_destroy(_glfw.wl.pointer);\n        _glfw.wl.pointer = NULL;\n    }\n\n    if ((caps & WL_SEAT_CAPABILITY_KEYBOARD) && !_glfw.wl.keyboard)\n    {\n        _glfw.wl.keyboard = wl_seat_get_keyboard(seat);\n        wl_keyboard_add_listener(_glfw.wl.keyboard, &keyboardListener, NULL);\n    }\n    else if (!(caps & WL_SEAT_CAPABILITY_KEYBOARD) && _glfw.wl.keyboard)\n    {\n        wl_keyboard_destroy(_glfw.wl.keyboard);\n        _glfw.wl.keyboard = NULL;\n    }\n}\n\nstatic void seatHandleName(void* data,\n                           struct wl_seat* seat,\n                           const char* name)\n{\n}\n\nstatic const struct wl_seat_listener seatListener = {\n    seatHandleCapabilities,\n    seatHandleName,\n};\n\nstatic void dataOfferHandleOffer(void* data,\n                                 struct wl_data_offer* dataOffer,\n                                 const char* mimeType)\n{\n}\n\nstatic const struct wl_data_offer_listener dataOfferListener = {\n    dataOfferHandleOffer,\n};\n\nstatic void dataDeviceHandleDataOffer(void* data,\n                                      struct wl_data_device* dataDevice,\n                                      struct wl_data_offer* id)\n{\n    if (_glfw.wl.dataOffer)\n        wl_data_offer_destroy(_glfw.wl.dataOffer);\n\n    _glfw.wl.dataOffer = id;\n    wl_data_offer_add_listener(_glfw.wl.dataOffer, &dataOfferListener, NULL);\n}\n\nstatic void dataDeviceHandleEnter(void* data,\n                                  struct wl_data_device* dataDevice,\n                                  uint32_t serial,\n                                  struct wl_surface *surface,\n                                  wl_fixed_t x,\n                                  wl_fixed_t y,\n                                  struct wl_data_offer *id)\n{\n}\n\nstatic void dataDeviceHandleLeave(void* data,\n                                  struct wl_data_device* dataDevice)\n{\n}\n\nstatic void dataDeviceHandleMotion(void* data,\n                                   struct wl_data_device* dataDevice,\n                                   uint32_t time,\n                                   wl_fixed_t x,\n                                   wl_fixed_t y)\n{\n}\n\nstatic void dataDeviceHandleDrop(void* data,\n                                 struct wl_data_device* dataDevice)\n{\n}\n\nstatic void dataDeviceHandleSelection(void* data,\n                                      struct wl_data_device* dataDevice,\n                                      struct wl_data_offer* id)\n{\n}\n\nstatic const struct wl_data_device_listener dataDeviceListener = {\n    dataDeviceHandleDataOffer,\n    dataDeviceHandleEnter,\n    dataDeviceHandleLeave,\n    dataDeviceHandleMotion,\n    dataDeviceHandleDrop,\n    dataDeviceHandleSelection,\n};\n\nstatic void wmBaseHandlePing(void* data,\n                             struct xdg_wm_base* wmBase,\n                             uint32_t serial)\n{\n    xdg_wm_base_pong(wmBase, serial);\n}\n\nstatic const struct xdg_wm_base_listener wmBaseListener = {\n    wmBaseHandlePing\n};\n\nstatic void registryHandleGlobal(void* data,\n                                 struct wl_registry* registry,\n                                 uint32_t name,\n                                 const char* interface,\n                                 uint32_t version)\n{\n    if (strcmp(interface, \"wl_compositor\") == 0)\n    {\n        _glfw.wl.compositorVersion = min(3, version);\n        _glfw.wl.compositor =\n            wl_registry_bind(registry, name, &wl_compositor_interface,\n                             _glfw.wl.compositorVersion);\n    }\n    else if (strcmp(interface, \"wl_subcompositor\") == 0)\n    {\n        _glfw.wl.subcompositor =\n            wl_registry_bind(registry, name, &wl_subcompositor_interface, 1);\n    }\n    else if (strcmp(interface, \"wl_shm\") == 0)\n    {\n        _glfw.wl.shm =\n            wl_registry_bind(registry, name, &wl_shm_interface, 1);\n    }\n    else if (strcmp(interface, \"wl_shell\") == 0)\n    {\n        _glfw.wl.shell =\n            wl_registry_bind(registry, name, &wl_shell_interface, 1);\n    }\n    else if (strcmp(interface, \"wl_output\") == 0)\n    {\n        _glfwAddOutputWayland(name, version);\n    }\n    else if (strcmp(interface, \"wl_seat\") == 0)\n    {\n        if (!_glfw.wl.seat)\n        {\n            _glfw.wl.seatVersion = min(4, version);\n            _glfw.wl.seat =\n                wl_registry_bind(registry, name, &wl_seat_interface,\n                                 _glfw.wl.seatVersion);\n            wl_seat_add_listener(_glfw.wl.seat, &seatListener, NULL);\n        }\n    }\n    else if (strcmp(interface, \"wl_data_device_manager\") == 0)\n    {\n        if (!_glfw.wl.dataDeviceManager)\n        {\n            _glfw.wl.dataDeviceManager =\n                wl_registry_bind(registry, name,\n                                 &wl_data_device_manager_interface, 1);\n        }\n    }\n    else if (strcmp(interface, \"xdg_wm_base\") == 0)\n    {\n        _glfw.wl.wmBase =\n            wl_registry_bind(registry, name, &xdg_wm_base_interface, 1);\n        xdg_wm_base_add_listener(_glfw.wl.wmBase, &wmBaseListener, NULL);\n    }\n    else if (strcmp(interface, \"zxdg_decoration_manager_v1\") == 0)\n    {\n        _glfw.wl.decorationManager =\n            wl_registry_bind(registry, name,\n                             &zxdg_decoration_manager_v1_interface,\n                             1);\n    }\n    else if (strcmp(interface, \"wp_viewporter\") == 0)\n    {\n        _glfw.wl.viewporter =\n            wl_registry_bind(registry, name, &wp_viewporter_interface, 1);\n    }\n    else if (strcmp(interface, \"zwp_relative_pointer_manager_v1\") == 0)\n    {\n        _glfw.wl.relativePointerManager =\n            wl_registry_bind(registry, name,\n                             &zwp_relative_pointer_manager_v1_interface,\n                             1);\n    }\n    else if (strcmp(interface, \"zwp_pointer_constraints_v1\") == 0)\n    {\n        _glfw.wl.pointerConstraints =\n            wl_registry_bind(registry, name,\n                             &zwp_pointer_constraints_v1_interface,\n                             1);\n    }\n    else if (strcmp(interface, \"zwp_idle_inhibit_manager_v1\") == 0)\n    {\n        _glfw.wl.idleInhibitManager =\n            wl_registry_bind(registry, name,\n                             &zwp_idle_inhibit_manager_v1_interface,\n                             1);\n    }\n}\n\nstatic void registryHandleGlobalRemove(void *data,\n                                       struct wl_registry *registry,\n                                       uint32_t name)\n{\n    int i;\n    _GLFWmonitor* monitor;\n\n    for (i = 0; i < _glfw.monitorCount; ++i)\n    {\n        monitor = _glfw.monitors[i];\n        if (monitor->wl.name == name)\n        {\n            _glfwInputMonitor(monitor, GLFW_DISCONNECTED, 0);\n            return;\n        }\n    }\n}\n\n\nstatic const struct wl_registry_listener registryListener = {\n    registryHandleGlobal,\n    registryHandleGlobalRemove\n};\n\n// Create key code translation tables\n//\nstatic void createKeyTables(void)\n{\n    int scancode;\n\n    memset(_glfw.wl.keycodes, -1, sizeof(_glfw.wl.keycodes));\n    memset(_glfw.wl.scancodes, -1, sizeof(_glfw.wl.scancodes));\n\n    _glfw.wl.keycodes[KEY_GRAVE]      = GLFW_KEY_GRAVE_ACCENT;\n    _glfw.wl.keycodes[KEY_1]          = GLFW_KEY_1;\n    _glfw.wl.keycodes[KEY_2]          = GLFW_KEY_2;\n    _glfw.wl.keycodes[KEY_3]          = GLFW_KEY_3;\n    _glfw.wl.keycodes[KEY_4]          = GLFW_KEY_4;\n    _glfw.wl.keycodes[KEY_5]          = GLFW_KEY_5;\n    _glfw.wl.keycodes[KEY_6]          = GLFW_KEY_6;\n    _glfw.wl.keycodes[KEY_7]          = GLFW_KEY_7;\n    _glfw.wl.keycodes[KEY_8]          = GLFW_KEY_8;\n    _glfw.wl.keycodes[KEY_9]          = GLFW_KEY_9;\n    _glfw.wl.keycodes[KEY_0]          = GLFW_KEY_0;\n    _glfw.wl.keycodes[KEY_SPACE]      = GLFW_KEY_SPACE;\n    _glfw.wl.keycodes[KEY_MINUS]      = GLFW_KEY_MINUS;\n    _glfw.wl.keycodes[KEY_EQUAL]      = GLFW_KEY_EQUAL;\n    _glfw.wl.keycodes[KEY_Q]          = GLFW_KEY_Q;\n    _glfw.wl.keycodes[KEY_W]          = GLFW_KEY_W;\n    _glfw.wl.keycodes[KEY_E]          = GLFW_KEY_E;\n    _glfw.wl.keycodes[KEY_R]          = GLFW_KEY_R;\n    _glfw.wl.keycodes[KEY_T]          = GLFW_KEY_T;\n    _glfw.wl.keycodes[KEY_Y]          = GLFW_KEY_Y;\n    _glfw.wl.keycodes[KEY_U]          = GLFW_KEY_U;\n    _glfw.wl.keycodes[KEY_I]          = GLFW_KEY_I;\n    _glfw.wl.keycodes[KEY_O]          = GLFW_KEY_O;\n    _glfw.wl.keycodes[KEY_P]          = GLFW_KEY_P;\n    _glfw.wl.keycodes[KEY_LEFTBRACE]  = GLFW_KEY_LEFT_BRACKET;\n    _glfw.wl.keycodes[KEY_RIGHTBRACE] = GLFW_KEY_RIGHT_BRACKET;\n    _glfw.wl.keycodes[KEY_A]          = GLFW_KEY_A;\n    _glfw.wl.keycodes[KEY_S]          = GLFW_KEY_S;\n    _glfw.wl.keycodes[KEY_D]          = GLFW_KEY_D;\n    _glfw.wl.keycodes[KEY_F]          = GLFW_KEY_F;\n    _glfw.wl.keycodes[KEY_G]          = GLFW_KEY_G;\n    _glfw.wl.keycodes[KEY_H]          = GLFW_KEY_H;\n    _glfw.wl.keycodes[KEY_J]          = GLFW_KEY_J;\n    _glfw.wl.keycodes[KEY_K]          = GLFW_KEY_K;\n    _glfw.wl.keycodes[KEY_L]          = GLFW_KEY_L;\n    _glfw.wl.keycodes[KEY_SEMICOLON]  = GLFW_KEY_SEMICOLON;\n    _glfw.wl.keycodes[KEY_APOSTROPHE] = GLFW_KEY_APOSTROPHE;\n    _glfw.wl.keycodes[KEY_Z]          = GLFW_KEY_Z;\n    _glfw.wl.keycodes[KEY_X]          = GLFW_KEY_X;\n    _glfw.wl.keycodes[KEY_C]          = GLFW_KEY_C;\n    _glfw.wl.keycodes[KEY_V]          = GLFW_KEY_V;\n    _glfw.wl.keycodes[KEY_B]          = GLFW_KEY_B;\n    _glfw.wl.keycodes[KEY_N]          = GLFW_KEY_N;\n    _glfw.wl.keycodes[KEY_M]          = GLFW_KEY_M;\n    _glfw.wl.keycodes[KEY_COMMA]      = GLFW_KEY_COMMA;\n    _glfw.wl.keycodes[KEY_DOT]        = GLFW_KEY_PERIOD;\n    _glfw.wl.keycodes[KEY_SLASH]      = GLFW_KEY_SLASH;\n    _glfw.wl.keycodes[KEY_BACKSLASH]  = GLFW_KEY_BACKSLASH;\n    _glfw.wl.keycodes[KEY_ESC]        = GLFW_KEY_ESCAPE;\n    _glfw.wl.keycodes[KEY_TAB]        = GLFW_KEY_TAB;\n    _glfw.wl.keycodes[KEY_LEFTSHIFT]  = GLFW_KEY_LEFT_SHIFT;\n    _glfw.wl.keycodes[KEY_RIGHTSHIFT] = GLFW_KEY_RIGHT_SHIFT;\n    _glfw.wl.keycodes[KEY_LEFTCTRL]   = GLFW_KEY_LEFT_CONTROL;\n    _glfw.wl.keycodes[KEY_RIGHTCTRL]  = GLFW_KEY_RIGHT_CONTROL;\n    _glfw.wl.keycodes[KEY_LEFTALT]    = GLFW_KEY_LEFT_ALT;\n    _glfw.wl.keycodes[KEY_RIGHTALT]   = GLFW_KEY_RIGHT_ALT;\n    _glfw.wl.keycodes[KEY_LEFTMETA]   = GLFW_KEY_LEFT_SUPER;\n    _glfw.wl.keycodes[KEY_RIGHTMETA]  = GLFW_KEY_RIGHT_SUPER;\n    _glfw.wl.keycodes[KEY_MENU]       = GLFW_KEY_MENU;\n    _glfw.wl.keycodes[KEY_NUMLOCK]    = GLFW_KEY_NUM_LOCK;\n    _glfw.wl.keycodes[KEY_CAPSLOCK]   = GLFW_KEY_CAPS_LOCK;\n    _glfw.wl.keycodes[KEY_PRINT]      = GLFW_KEY_PRINT_SCREEN;\n    _glfw.wl.keycodes[KEY_SCROLLLOCK] = GLFW_KEY_SCROLL_LOCK;\n    _glfw.wl.keycodes[KEY_PAUSE]      = GLFW_KEY_PAUSE;\n    _glfw.wl.keycodes[KEY_DELETE]     = GLFW_KEY_DELETE;\n    _glfw.wl.keycodes[KEY_BACKSPACE]  = GLFW_KEY_BACKSPACE;\n    _glfw.wl.keycodes[KEY_ENTER]      = GLFW_KEY_ENTER;\n    _glfw.wl.keycodes[KEY_HOME]       = GLFW_KEY_HOME;\n    _glfw.wl.keycodes[KEY_END]        = GLFW_KEY_END;\n    _glfw.wl.keycodes[KEY_PAGEUP]     = GLFW_KEY_PAGE_UP;\n    _glfw.wl.keycodes[KEY_PAGEDOWN]   = GLFW_KEY_PAGE_DOWN;\n    _glfw.wl.keycodes[KEY_INSERT]     = GLFW_KEY_INSERT;\n    _glfw.wl.keycodes[KEY_LEFT]       = GLFW_KEY_LEFT;\n    _glfw.wl.keycodes[KEY_RIGHT]      = GLFW_KEY_RIGHT;\n    _glfw.wl.keycodes[KEY_DOWN]       = GLFW_KEY_DOWN;\n    _glfw.wl.keycodes[KEY_UP]         = GLFW_KEY_UP;\n    _glfw.wl.keycodes[KEY_F1]         = GLFW_KEY_F1;\n    _glfw.wl.keycodes[KEY_F2]         = GLFW_KEY_F2;\n    _glfw.wl.keycodes[KEY_F3]         = GLFW_KEY_F3;\n    _glfw.wl.keycodes[KEY_F4]         = GLFW_KEY_F4;\n    _glfw.wl.keycodes[KEY_F5]         = GLFW_KEY_F5;\n    _glfw.wl.keycodes[KEY_F6]         = GLFW_KEY_F6;\n    _glfw.wl.keycodes[KEY_F7]         = GLFW_KEY_F7;\n    _glfw.wl.keycodes[KEY_F8]         = GLFW_KEY_F8;\n    _glfw.wl.keycodes[KEY_F9]         = GLFW_KEY_F9;\n    _glfw.wl.keycodes[KEY_F10]        = GLFW_KEY_F10;\n    _glfw.wl.keycodes[KEY_F11]        = GLFW_KEY_F11;\n    _glfw.wl.keycodes[KEY_F12]        = GLFW_KEY_F12;\n    _glfw.wl.keycodes[KEY_F13]        = GLFW_KEY_F13;\n    _glfw.wl.keycodes[KEY_F14]        = GLFW_KEY_F14;\n    _glfw.wl.keycodes[KEY_F15]        = GLFW_KEY_F15;\n    _glfw.wl.keycodes[KEY_F16]        = GLFW_KEY_F16;\n    _glfw.wl.keycodes[KEY_F17]        = GLFW_KEY_F17;\n    _glfw.wl.keycodes[KEY_F18]        = GLFW_KEY_F18;\n    _glfw.wl.keycodes[KEY_F19]        = GLFW_KEY_F19;\n    _glfw.wl.keycodes[KEY_F20]        = GLFW_KEY_F20;\n    _glfw.wl.keycodes[KEY_F21]        = GLFW_KEY_F21;\n    _glfw.wl.keycodes[KEY_F22]        = GLFW_KEY_F22;\n    _glfw.wl.keycodes[KEY_F23]        = GLFW_KEY_F23;\n    _glfw.wl.keycodes[KEY_F24]        = GLFW_KEY_F24;\n    _glfw.wl.keycodes[KEY_KPSLASH]    = GLFW_KEY_KP_DIVIDE;\n    _glfw.wl.keycodes[KEY_KPDOT]      = GLFW_KEY_KP_MULTIPLY;\n    _glfw.wl.keycodes[KEY_KPMINUS]    = GLFW_KEY_KP_SUBTRACT;\n    _glfw.wl.keycodes[KEY_KPPLUS]     = GLFW_KEY_KP_ADD;\n    _glfw.wl.keycodes[KEY_KP0]        = GLFW_KEY_KP_0;\n    _glfw.wl.keycodes[KEY_KP1]        = GLFW_KEY_KP_1;\n    _glfw.wl.keycodes[KEY_KP2]        = GLFW_KEY_KP_2;\n    _glfw.wl.keycodes[KEY_KP3]        = GLFW_KEY_KP_3;\n    _glfw.wl.keycodes[KEY_KP4]        = GLFW_KEY_KP_4;\n    _glfw.wl.keycodes[KEY_KP5]        = GLFW_KEY_KP_5;\n    _glfw.wl.keycodes[KEY_KP6]        = GLFW_KEY_KP_6;\n    _glfw.wl.keycodes[KEY_KP7]        = GLFW_KEY_KP_7;\n    _glfw.wl.keycodes[KEY_KP8]        = GLFW_KEY_KP_8;\n    _glfw.wl.keycodes[KEY_KP9]        = GLFW_KEY_KP_9;\n    _glfw.wl.keycodes[KEY_KPCOMMA]    = GLFW_KEY_KP_DECIMAL;\n    _glfw.wl.keycodes[KEY_KPEQUAL]    = GLFW_KEY_KP_EQUAL;\n    _glfw.wl.keycodes[KEY_KPENTER]    = GLFW_KEY_KP_ENTER;\n\n    for (scancode = 0;  scancode < 256;  scancode++)\n    {\n        if (_glfw.wl.keycodes[scancode] > 0)\n            _glfw.wl.scancodes[_glfw.wl.keycodes[scancode]] = scancode;\n    }\n}\n\n\n//////////////////////////////////////////////////////////////////////////\n//////                       GLFW platform API                      //////\n//////////////////////////////////////////////////////////////////////////\n\nint _glfwPlatformInit(void)\n{\n    const char *cursorTheme;\n    const char *cursorSizeStr;\n    char *cursorSizeEnd;\n    long cursorSizeLong;\n    int cursorSize;\n\n    _glfw.wl.cursor.handle = _glfw_dlopen(\"libwayland-cursor.so.0\");\n    if (!_glfw.wl.cursor.handle)\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"Wayland: Failed to open libwayland-cursor\");\n        return GLFW_FALSE;\n    }\n\n    _glfw.wl.cursor.theme_load = (PFN_wl_cursor_theme_load)\n        _glfw_dlsym(_glfw.wl.cursor.handle, \"wl_cursor_theme_load\");\n    _glfw.wl.cursor.theme_destroy = (PFN_wl_cursor_theme_destroy)\n        _glfw_dlsym(_glfw.wl.cursor.handle, \"wl_cursor_theme_destroy\");\n    _glfw.wl.cursor.theme_get_cursor = (PFN_wl_cursor_theme_get_cursor)\n        _glfw_dlsym(_glfw.wl.cursor.handle, \"wl_cursor_theme_get_cursor\");\n    _glfw.wl.cursor.image_get_buffer = (PFN_wl_cursor_image_get_buffer)\n        _glfw_dlsym(_glfw.wl.cursor.handle, \"wl_cursor_image_get_buffer\");\n\n    _glfw.wl.egl.handle = _glfw_dlopen(\"libwayland-egl.so.1\");\n    if (!_glfw.wl.egl.handle)\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"Wayland: Failed to open libwayland-egl\");\n        return GLFW_FALSE;\n    }\n\n    _glfw.wl.egl.window_create = (PFN_wl_egl_window_create)\n        _glfw_dlsym(_glfw.wl.egl.handle, \"wl_egl_window_create\");\n    _glfw.wl.egl.window_destroy = (PFN_wl_egl_window_destroy)\n        _glfw_dlsym(_glfw.wl.egl.handle, \"wl_egl_window_destroy\");\n    _glfw.wl.egl.window_resize = (PFN_wl_egl_window_resize)\n        _glfw_dlsym(_glfw.wl.egl.handle, \"wl_egl_window_resize\");\n\n    _glfw.wl.xkb.handle = _glfw_dlopen(\"libxkbcommon.so.0\");\n    if (!_glfw.wl.xkb.handle)\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"Wayland: Failed to open libxkbcommon\");\n        return GLFW_FALSE;\n    }\n\n    _glfw.wl.xkb.context_new = (PFN_xkb_context_new)\n        _glfw_dlsym(_glfw.wl.xkb.handle, \"xkb_context_new\");\n    _glfw.wl.xkb.context_unref = (PFN_xkb_context_unref)\n        _glfw_dlsym(_glfw.wl.xkb.handle, \"xkb_context_unref\");\n    _glfw.wl.xkb.keymap_new_from_string = (PFN_xkb_keymap_new_from_string)\n        _glfw_dlsym(_glfw.wl.xkb.handle, \"xkb_keymap_new_from_string\");\n    _glfw.wl.xkb.keymap_unref = (PFN_xkb_keymap_unref)\n        _glfw_dlsym(_glfw.wl.xkb.handle, \"xkb_keymap_unref\");\n    _glfw.wl.xkb.keymap_mod_get_index = (PFN_xkb_keymap_mod_get_index)\n        _glfw_dlsym(_glfw.wl.xkb.handle, \"xkb_keymap_mod_get_index\");\n    _glfw.wl.xkb.keymap_key_repeats = (PFN_xkb_keymap_key_repeats)\n        _glfw_dlsym(_glfw.wl.xkb.handle, \"xkb_keymap_key_repeats\");\n    _glfw.wl.xkb.state_new = (PFN_xkb_state_new)\n        _glfw_dlsym(_glfw.wl.xkb.handle, \"xkb_state_new\");\n    _glfw.wl.xkb.state_unref = (PFN_xkb_state_unref)\n        _glfw_dlsym(_glfw.wl.xkb.handle, \"xkb_state_unref\");\n    _glfw.wl.xkb.state_key_get_syms = (PFN_xkb_state_key_get_syms)\n        _glfw_dlsym(_glfw.wl.xkb.handle, \"xkb_state_key_get_syms\");\n    _glfw.wl.xkb.state_update_mask = (PFN_xkb_state_update_mask)\n        _glfw_dlsym(_glfw.wl.xkb.handle, \"xkb_state_update_mask\");\n    _glfw.wl.xkb.state_serialize_mods = (PFN_xkb_state_serialize_mods)\n        _glfw_dlsym(_glfw.wl.xkb.handle, \"xkb_state_serialize_mods\");\n\n#ifdef HAVE_XKBCOMMON_COMPOSE_H\n    _glfw.wl.xkb.compose_table_new_from_locale = (PFN_xkb_compose_table_new_from_locale)\n        _glfw_dlsym(_glfw.wl.xkb.handle, \"xkb_compose_table_new_from_locale\");\n    _glfw.wl.xkb.compose_table_unref = (PFN_xkb_compose_table_unref)\n        _glfw_dlsym(_glfw.wl.xkb.handle, \"xkb_compose_table_unref\");\n    _glfw.wl.xkb.compose_state_new = (PFN_xkb_compose_state_new)\n        _glfw_dlsym(_glfw.wl.xkb.handle, \"xkb_compose_state_new\");\n    _glfw.wl.xkb.compose_state_unref = (PFN_xkb_compose_state_unref)\n        _glfw_dlsym(_glfw.wl.xkb.handle, \"xkb_compose_state_unref\");\n    _glfw.wl.xkb.compose_state_feed = (PFN_xkb_compose_state_feed)\n        _glfw_dlsym(_glfw.wl.xkb.handle, \"xkb_compose_state_feed\");\n    _glfw.wl.xkb.compose_state_get_status = (PFN_xkb_compose_state_get_status)\n        _glfw_dlsym(_glfw.wl.xkb.handle, \"xkb_compose_state_get_status\");\n    _glfw.wl.xkb.compose_state_get_one_sym = (PFN_xkb_compose_state_get_one_sym)\n        _glfw_dlsym(_glfw.wl.xkb.handle, \"xkb_compose_state_get_one_sym\");\n#endif\n\n    _glfw.wl.display = wl_display_connect(NULL);\n    if (!_glfw.wl.display)\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"Wayland: Failed to connect to display\");\n        return GLFW_FALSE;\n    }\n\n    _glfw.wl.registry = wl_display_get_registry(_glfw.wl.display);\n    wl_registry_add_listener(_glfw.wl.registry, &registryListener, NULL);\n\n    createKeyTables();\n\n    _glfw.wl.xkb.context = xkb_context_new(0);\n    if (!_glfw.wl.xkb.context)\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"Wayland: Failed to initialize xkb context\");\n        return GLFW_FALSE;\n    }\n\n    // Sync so we got all registry objects\n    wl_display_roundtrip(_glfw.wl.display);\n\n    // Sync so we got all initial output events\n    wl_display_roundtrip(_glfw.wl.display);\n\n#ifdef __linux__\n    if (!_glfwInitJoysticksLinux())\n        return GLFW_FALSE;\n#endif\n\n    _glfwInitTimerPOSIX();\n\n    _glfw.wl.timerfd = -1;\n    if (_glfw.wl.seatVersion >= 4)\n        _glfw.wl.timerfd = timerfd_create(CLOCK_MONOTONIC, TFD_CLOEXEC);\n\n    if (_glfw.wl.pointer && _glfw.wl.shm)\n    {\n        cursorTheme = getenv(\"XCURSOR_THEME\");\n        cursorSizeStr = getenv(\"XCURSOR_SIZE\");\n        cursorSize = 32;\n        if (cursorSizeStr)\n        {\n            errno = 0;\n            cursorSizeLong = strtol(cursorSizeStr, &cursorSizeEnd, 10);\n            if (!*cursorSizeEnd && !errno && cursorSizeLong > 0 && cursorSizeLong <= INT_MAX)\n                cursorSize = (int)cursorSizeLong;\n        }\n        _glfw.wl.cursorTheme =\n            wl_cursor_theme_load(cursorTheme, cursorSize, _glfw.wl.shm);\n        if (!_glfw.wl.cursorTheme)\n        {\n            _glfwInputError(GLFW_PLATFORM_ERROR,\n                            \"Wayland: Unable to load default cursor theme\");\n            return GLFW_FALSE;\n        }\n        // If this happens to be NULL, we just fallback to the scale=1 version.\n        _glfw.wl.cursorThemeHiDPI =\n            wl_cursor_theme_load(cursorTheme, 2 * cursorSize, _glfw.wl.shm);\n        _glfw.wl.cursorSurface =\n            wl_compositor_create_surface(_glfw.wl.compositor);\n        _glfw.wl.cursorTimerfd = timerfd_create(CLOCK_MONOTONIC, TFD_CLOEXEC);\n    }\n\n    if (_glfw.wl.seat && _glfw.wl.dataDeviceManager)\n    {\n        _glfw.wl.dataDevice =\n            wl_data_device_manager_get_data_device(_glfw.wl.dataDeviceManager,\n                                                   _glfw.wl.seat);\n        wl_data_device_add_listener(_glfw.wl.dataDevice, &dataDeviceListener, NULL);\n        _glfw.wl.clipboardString = malloc(4096);\n        if (!_glfw.wl.clipboardString)\n        {\n            _glfwInputError(GLFW_PLATFORM_ERROR,\n                            \"Wayland: Unable to allocate clipboard memory\");\n            return GLFW_FALSE;\n        }\n        _glfw.wl.clipboardSize = 4096;\n    }\n\n    return GLFW_TRUE;\n}\n\nvoid _glfwPlatformTerminate(void)\n{\n#ifdef __linux__\n    _glfwTerminateJoysticksLinux();\n#endif\n    _glfwTerminateEGL();\n    if (_glfw.wl.egl.handle)\n    {\n        _glfw_dlclose(_glfw.wl.egl.handle);\n        _glfw.wl.egl.handle = NULL;\n    }\n\n#ifdef HAVE_XKBCOMMON_COMPOSE_H\n    if (_glfw.wl.xkb.composeState)\n        xkb_compose_state_unref(_glfw.wl.xkb.composeState);\n#endif\n    if (_glfw.wl.xkb.keymap)\n        xkb_keymap_unref(_glfw.wl.xkb.keymap);\n    if (_glfw.wl.xkb.state)\n        xkb_state_unref(_glfw.wl.xkb.state);\n    if (_glfw.wl.xkb.context)\n        xkb_context_unref(_glfw.wl.xkb.context);\n    if (_glfw.wl.xkb.handle)\n    {\n        _glfw_dlclose(_glfw.wl.xkb.handle);\n        _glfw.wl.xkb.handle = NULL;\n    }\n\n    if (_glfw.wl.cursorTheme)\n        wl_cursor_theme_destroy(_glfw.wl.cursorTheme);\n    if (_glfw.wl.cursorThemeHiDPI)\n        wl_cursor_theme_destroy(_glfw.wl.cursorThemeHiDPI);\n    if (_glfw.wl.cursor.handle)\n    {\n        _glfw_dlclose(_glfw.wl.cursor.handle);\n        _glfw.wl.cursor.handle = NULL;\n    }\n\n    if (_glfw.wl.cursorSurface)\n        wl_surface_destroy(_glfw.wl.cursorSurface);\n    if (_glfw.wl.subcompositor)\n        wl_subcompositor_destroy(_glfw.wl.subcompositor);\n    if (_glfw.wl.compositor)\n        wl_compositor_destroy(_glfw.wl.compositor);\n    if (_glfw.wl.shm)\n        wl_shm_destroy(_glfw.wl.shm);\n    if (_glfw.wl.shell)\n        wl_shell_destroy(_glfw.wl.shell);\n    if (_glfw.wl.viewporter)\n        wp_viewporter_destroy(_glfw.wl.viewporter);\n    if (_glfw.wl.decorationManager)\n        zxdg_decoration_manager_v1_destroy(_glfw.wl.decorationManager);\n    if (_glfw.wl.wmBase)\n        xdg_wm_base_destroy(_glfw.wl.wmBase);\n    if (_glfw.wl.dataSource)\n        wl_data_source_destroy(_glfw.wl.dataSource);\n    if (_glfw.wl.dataDevice)\n        wl_data_device_destroy(_glfw.wl.dataDevice);\n    if (_glfw.wl.dataOffer)\n        wl_data_offer_destroy(_glfw.wl.dataOffer);\n    if (_glfw.wl.dataDeviceManager)\n        wl_data_device_manager_destroy(_glfw.wl.dataDeviceManager);\n    if (_glfw.wl.pointer)\n        wl_pointer_destroy(_glfw.wl.pointer);\n    if (_glfw.wl.keyboard)\n        wl_keyboard_destroy(_glfw.wl.keyboard);\n    if (_glfw.wl.seat)\n        wl_seat_destroy(_glfw.wl.seat);\n    if (_glfw.wl.relativePointerManager)\n        zwp_relative_pointer_manager_v1_destroy(_glfw.wl.relativePointerManager);\n    if (_glfw.wl.pointerConstraints)\n        zwp_pointer_constraints_v1_destroy(_glfw.wl.pointerConstraints);\n    if (_glfw.wl.idleInhibitManager)\n        zwp_idle_inhibit_manager_v1_destroy(_glfw.wl.idleInhibitManager);\n    if (_glfw.wl.registry)\n        wl_registry_destroy(_glfw.wl.registry);\n    if (_glfw.wl.display)\n    {\n        wl_display_flush(_glfw.wl.display);\n        wl_display_disconnect(_glfw.wl.display);\n    }\n\n    if (_glfw.wl.timerfd >= 0)\n        close(_glfw.wl.timerfd);\n    if (_glfw.wl.cursorTimerfd >= 0)\n        close(_glfw.wl.cursorTimerfd);\n\n    if (_glfw.wl.clipboardString)\n        free(_glfw.wl.clipboardString);\n    if (_glfw.wl.clipboardSendString)\n        free(_glfw.wl.clipboardSendString);\n}\n\nconst char* _glfwPlatformGetVersionString(void)\n{\n    return _GLFW_VERSION_NUMBER \" Wayland EGL OSMesa\"\n#if defined(_POSIX_TIMERS) && defined(_POSIX_MONOTONIC_CLOCK)\n        \" clock_gettime\"\n#else\n        \" gettimeofday\"\n#endif\n        \" evdev\"\n#if defined(_GLFW_BUILD_DLL)\n        \" shared\"\n#endif\n        ;\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-glfw-3.3-2fza4cb74pcte44nu2vbzw4ag2osew7l/spack-src/examples/glfw.ico",
        "/tmp/vanessa/spack-stage/spack-stage-glfw-3.3-2fza4cb74pcte44nu2vbzw4ag2osew7l/spack-src/examples/glfw.icns"
    ],
    "total_files": 151
}