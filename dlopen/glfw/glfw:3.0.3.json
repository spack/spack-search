{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-glfw-3.0.3-oynij7sjlquvi4isxs32tj7bcnaztgr7/spack-src/CMakeLists.txt": "project(GLFW C)\n\ncmake_minimum_required(VERSION 2.8)\n\nset(GLFW_VERSION_MAJOR \"3\")\nset(GLFW_VERSION_MINOR \"0\")\nset(GLFW_VERSION_PATCH \"3\")\nset(GLFW_VERSION_EXTRA \"\")\nset(GLFW_VERSION \"${GLFW_VERSION_MAJOR}.${GLFW_VERSION_MINOR}\")\nset(GLFW_VERSION_FULL \"${GLFW_VERSION}.${GLFW_VERSION_PATCH}${GLFW_VERSION_EXTRA}\")\nset(LIB_SUFFIX \"\" CACHE STRING \"Takes an empty string or 64. Directory where lib will be installed: lib or lib64\")\n\noption(BUILD_SHARED_LIBS \"Build shared libraries\" OFF)\noption(GLFW_BUILD_EXAMPLES \"Build the GLFW example programs\" ON)\noption(GLFW_BUILD_TESTS \"Build the GLFW test programs\" ON)\noption(GLFW_INSTALL \"Generate installation target\" ON)\noption(GLFW_DOCUMENT_INTERNALS \"Include internals in documentation\" OFF)\n\nif (WIN32)\n    option(GLFW_USE_DWM_SWAP_INTERVAL \"Set swap interval even when DWM compositing is enabled\" OFF)\n    option(GLFW_USE_OPTIMUS_HPG \"Force use of high-performance GPU on Optimus systems\" OFF)\nendif()\n\nif (APPLE)\n    option(GLFW_BUILD_UNIVERSAL \"Build GLFW as a Universal Binary\" OFF)\n    option(GLFW_USE_CHDIR \"Make glfwInit chdir to Contents/Resources\" ON)\n    option(GLFW_USE_MENUBAR \"Populate the menu bar on first window creation\" ON)\nelse()\n    option(GLFW_USE_EGL \"Use EGL for context creation\" OFF)\nendif()\n\nif (MSVC)\n    option(USE_MSVC_RUNTIME_LIBRARY_DLL \"Use MSVC runtime library DLL\" ON)\nendif()\n\nif (BUILD_SHARED_LIBS)\n    set(_GLFW_BUILD_DLL 1)\nendif()\n\nif (GLFW_USE_EGL)\n    set(GLFW_CLIENT_LIBRARY \"opengl\" CACHE STRING\n        \"The client library to use; one of opengl, glesv1 or glesv2\")\n\n    if (${GLFW_CLIENT_LIBRARY} STREQUAL \"opengl\")\n        set(_GLFW_USE_OPENGL 1)\n    elseif (${GLFW_CLIENT_LIBRARY} STREQUAL \"glesv1\")\n        set(_GLFW_USE_GLESV1 1)\n    elseif (${GLFW_CLIENT_LIBRARY} STREQUAL \"glesv2\")\n        set(_GLFW_USE_GLESV2 1)\n    else()\n        message(FATAL_ERROR \"Unsupported client library\")\n    endif()\n\n    set(CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/CMake/modules)\n    find_package(EGL REQUIRED)\n\n    if (NOT _GLFW_USE_OPENGL)\n        set(GLFW_BUILD_EXAMPLES OFF)\n        set(GLFW_BUILD_TESTS OFF)\n        message(STATUS \"NOTE: Examples and tests require OpenGL\")\n    endif()\nelse()\n    set(_GLFW_USE_OPENGL 1)\nendif()\n\nif (_GLFW_USE_OPENGL)\n    find_package(OpenGL REQUIRED)\nelseif (_GLFW_USE_GLESV1)\n    find_package(GLESv1 REQUIRED)\nelseif (_GLFW_USE_GLESV2)\n    find_package(GLESv2 REQUIRED)\nendif()\n\nfind_package(Threads REQUIRED)\n\nset(DOXYGEN_SKIP_DOT TRUE)\nfind_package(Doxygen)\n\nif (GLFW_DOCUMENT_INTERNALS)\n    set(GLFW_INTERNAL_DOCS \"${GLFW_SOURCE_DIR}/src/internal.h ${GLFW_SOURCE_DIR}/docs/internal.dox\")\nendif()\n\n#--------------------------------------------------------------------\n# Set compiler specific flags\n#--------------------------------------------------------------------\nif (UNIX)\n    add_definitions(-Wall)\n\n    if (BUILD_SHARED_LIBS)\n        add_definitions(-fvisibility=hidden)\n    endif()\nendif()\n\nif (MSVC)\n    add_definitions(-D_CRT_SECURE_NO_WARNINGS)\n\n    if (NOT USE_MSVC_RUNTIME_LIBRARY_DLL)\n        foreach (flag CMAKE_C_FLAGS\n                        CMAKE_C_FLAGS_DEBUG\n                        CMAKE_C_FLAGS_RELEASE\n                        CMAKE_C_FLAGS_MINSIZEREL\n                        CMAKE_C_FLAGS_RELWITHDEBINFO)\n\n            if (${flag} MATCHES \"/MD\")\n                string(REGEX REPLACE \"/MD\" \"/MT\" ${flag} \"${${flag}}\")\n            endif()\n            if (${flag} MATCHES \"/MDd\")\n                string(REGEX REPLACE \"/MDd\" \"/MTd\" ${flag} \"${${flag}}\")\n            endif()\n\n        endforeach()\n    endif()\nendif()\n\n#--------------------------------------------------------------------\n# Detect and select backend APIs\n#--------------------------------------------------------------------\nif (WIN32)\n    set(_GLFW_WIN32 1)\n    message(STATUS \"Using Win32 for window creation\") \n\n    if (GLFW_USE_EGL)\n        set(_GLFW_EGL 1)\n        message(STATUS \"Using EGL for context creation\")\n    else()\n        set(_GLFW_WGL 1)\n        message(STATUS \"Using WGL for context creation\")\n    endif()\nelseif (APPLE)\n    set(_GLFW_COCOA 1)\n    message(STATUS \"Using Cocoa for window creation\")\n    set(_GLFW_NSGL 1)\n    message(STATUS \"Using NSGL for context creation\")\nelseif (UNIX)\n    set(_GLFW_X11 1)\n    message(STATUS \"Using X11 for window creation\") \n\n    if (GLFW_USE_EGL)\n        set(_GLFW_EGL 1)\n        message(STATUS \"Using EGL for context creation\")\n    else()\n        set(_GLFW_GLX 1)\n        message(STATUS \"Using GLX for context creation\")\n    endif()\nelse()\n    message(FATAL_ERROR \"No supported platform was detected\")\nendif()\n\n#--------------------------------------------------------------------\n# Use Win32 for window creation\n#--------------------------------------------------------------------\nif (_GLFW_WIN32)\n    # The DLL links against winmm; the static library loads it\n    # That way, both code paths receive testing\n    if (BUILD_SHARED_LIBS)\n        set(_GLFW_NO_DLOAD_WINMM 1)\n        list(APPEND glfw_LIBRARIES winmm)\n    endif()\n\n    if (GLFW_USE_DWM_SWAP_INTERVAL)\n        set(_GLFW_USE_DWM_SWAP_INTERVAL 1)\n    endif()\n    if (GLFW_USE_OPTIMUS_HPG)\n        set(_GLFW_USE_OPTIMUS_HPG 1)\n    endif()\n\n    # HACK: When building on MinGW, WINVER and UNICODE need to be defined before\n    # the inclusion of stddef.h (by glfw3.h), which is itself included before\n    # win32_platform.h.  We define them here until a saner solution can be found\n    # NOTE: MinGW-w64 and Visual C++ do /not/ need this hack.\n    add_definitions(-DUNICODE)\n    add_definitions(-DWINVER=0x0501)\nendif()\n\n#--------------------------------------------------------------------\n# Use WGL for context creation\n#--------------------------------------------------------------------\nif (_GLFW_WGL)\n    list(APPEND glfw_INCLUDE_DIRS ${OPENGL_INCLUDE_DIR})\n    list(APPEND glfw_LIBRARIES ${OPENGL_gl_LIBRARY})\nendif()\n\n#--------------------------------------------------------------------\n# Use X11 for window creation\n#--------------------------------------------------------------------\nif (_GLFW_X11)\n\n    find_package(X11 REQUIRED)\n\n    set(GLFW_PKG_DEPS \"${GLFW_PKG_DEPS} x11\")\n\n    # Set up library and include paths\n    list(APPEND glfw_INCLUDE_DIRS ${X11_X11_INCLUDE_PATH})\n    list(APPEND glfw_LIBRARIES ${X11_X11_LIB} ${CMAKE_THREAD_LIBS_INIT})\n    if (UNIX AND NOT APPLE)\n        list(APPEND glfw_LIBRARIES ${RT_LIBRARY})\n    endif()\n\n    # Check for XRandR (modern resolution switching and gamma control)\n    if (NOT X11_Xrandr_FOUND)\n        message(FATAL_ERROR \"The RandR library and headers were not found\")\n    endif()\n\n    list(APPEND glfw_INCLUDE_DIRS ${X11_Xrandr_INCLUDE_PATH})\n    list(APPEND glfw_LIBRARIES ${X11_Xrandr_LIB})\n    set(GLFW_PKG_DEPS \"${GLFW_PKG_DEPS} xrandr\")\n\n    # Check for XInput (high-resolution cursor motion)\n    if (NOT X11_Xinput_FOUND)\n        message(FATAL_ERROR \"The XInput library and headers were not found\")\n    endif()\n\n    list(APPEND glfw_INCLUDE_DIRS ${X11_Xinput_INCLUDE_PATH})\n\n    if (X11_Xinput_LIB)\n        list(APPEND glfw_LIBRARIES ${X11_Xinput_LIB})\n    else()\n        # Backwards compatibility (bug in CMake 2.8.7)\n        list(APPEND glfw_LIBRARIES Xi)\n    endif()\n    set(GLFW_PKG_DEPS \"${GLFW_PKG_DEPS} xi\")\n\n    # Check for Xf86VidMode (fallback gamma control)\n    if (NOT X11_xf86vmode_FOUND)\n        message(FATAL_ERROR \"The Xf86VidMode library and headers were not found\")\n    endif()\n\n    list(APPEND glfw_INCLUDE_DIRS ${X11_xf86vmode_INCLUDE_PATH})\n    set(GLFW_PKG_DEPS \"${GLFW_PKG_DEPS} xxf86vm\")\n\n    if (X11_Xxf86vm_LIB)\n        list(APPEND glfw_LIBRARIES ${X11_Xxf86vm_LIB})\n    else()\n        # Backwards compatibility (see CMake bug 0006976)\n        list(APPEND glfw_LIBRARIES Xxf86vm)\n    endif()\n\n    # Check for Xkb (X keyboard extension)\n    if (NOT X11_Xkb_FOUND)\n        message(FATAL_ERROR \"The X keyboard extension headers were not found\")\n    endif() \n\n    list(APPEND glfw_INCLUDE_DIR ${X11_Xkb_INCLUDE_PATH})\n\n    find_library(RT_LIBRARY rt)\n    mark_as_advanced(RT_LIBRARY)\n    if (RT_LIBRARY)\n        list(APPEND glfw_LIBRARIES ${RT_LIBRARY})\n        set(GLFW_PKG_LIBS \"${GLFW_PKG_LIBS} -lrt\")\n    endif()\n\n    find_library(MATH_LIBRARY m)\n    mark_as_advanced(MATH_LIBRARY)\n    if (MATH_LIBRARY)\n        list(APPEND glfw_LIBRARIES ${MATH_LIBRARY})\n        set(GLFW_PKG_LIBS \"${GLFW_PKG_LIBS} -lm\")\n    endif()\n\nendif()\n\n#--------------------------------------------------------------------\n# Use GLX for context creation\n#--------------------------------------------------------------------\nif (_GLFW_GLX)\n\n    list(APPEND glfw_INCLUDE_DIRS ${OPENGL_INCLUDE_DIR})\n    list(APPEND glfw_LIBRARIES ${OPENGL_gl_LIBRARY})\n\n    set(GLFW_PKG_DEPS \"${GLFW_PKG_DEPS} gl\")\n\n    include(CheckFunctionExists)\n\n    set(CMAKE_REQUIRED_LIBRARIES ${OPENGL_gl_LIBRARY})\n    check_function_exists(glXGetProcAddress _GLFW_HAS_GLXGETPROCADDRESS)\n    check_function_exists(glXGetProcAddressARB _GLFW_HAS_GLXGETPROCADDRESSARB)\n    check_function_exists(glXGetProcAddressEXT _GLFW_HAS_GLXGETPROCADDRESSEXT)\n\n    if (NOT _GLFW_HAS_GLXGETPROCADDRESS AND\n        NOT _GLFW_HAS_GLXGETPROCADDRESSARB AND\n        NOT _GLFW_HAS_GLXGETPROCADDRESSEXT)\n        message(WARNING \"No glXGetProcAddressXXX variant found\")\n\n        # Check for dlopen support as a fallback\n\n        find_library(DL_LIBRARY dl)\n        mark_as_advanced(DL_LIBRARY)\n        if (DL_LIBRARY)\n            set(CMAKE_REQUIRED_LIBRARIES ${DL_LIBRARY})\n        else()\n            set(CMAKE_REQUIRED_LIBRARIES \"\")\n        endif()\n\n        check_function_exists(dlopen _GLFW_HAS_DLOPEN)\n\n        if (NOT _GLFW_HAS_DLOPEN)\n            message(FATAL_ERROR \"No entry point retrieval mechanism found\")\n        endif()\n\n        if (DL_LIBRARY)\n            list(APPEND glfw_LIBRARIES ${DL_LIBRARY})\n            set(GLFW_PKG_LIBS \"${GLFW_PKG_LIBS} -ldl\")\n        endif()\n    endif()\n\nendif()\n\n#--------------------------------------------------------------------\n# Use EGL for context creation\n#--------------------------------------------------------------------\nif (_GLFW_EGL)\n\n    list(APPEND glfw_INCLUDE_DIRS ${EGL_INCLUDE_DIR})\n    list(APPEND glfw_LIBRARIES ${EGL_LIBRARY})\n\n    if (UNIX)\n        set(GLFW_PKG_DEPS \"${GLFW_PKG_DEPS} egl\")\n    endif()\n\n    if (_GLFW_USE_OPENGL)\n        list(APPEND glfw_LIBRARIES ${OPENGL_gl_LIBRARY})\n        list(APPEND glfw_INCLUDE_DIRS ${OPENGL_INCLUDE_DIR})\n        set(GLFW_PKG_DEPS \"${GLFW_PKG_DEPS} gl\")\n    elseif (_GLFW_USE_GLESV1)\n        list(APPEND glfw_LIBRARIES ${GLESv1_LIBRARY})\n        list(APPEND glfw_INCLUDE_DIRS ${GLESv1_INCLUDE_DIR})\n        set(GLFW_PKG_DEPS \"${GLFW_PKG_DEPS} glesv1_cm\")\n    elseif (_GLFW_USE_GLESV2)\n        list(APPEND glfw_LIBRARIES ${GLESv2_LIBRARY})\n        list(APPEND glfw_INCLUDE_DIRS ${GLESv2_INCLUDE_DIR})\n        set(GLFW_PKG_DEPS \"${GLFW_PKG_DEPS} glesv2\")\n    endif()\n\nendif()\n\n#--------------------------------------------------------------------\n# Use Cocoa for window creation and NSOpenGL for context creation\n#--------------------------------------------------------------------\nif (_GLFW_COCOA AND _GLFW_NSGL)\n        \n    if (GLFW_USE_MENUBAR)\n        set(_GLFW_USE_MENUBAR 1)\n    endif()\n\n    if (GLFW_USE_CHDIR)\n        set(_GLFW_USE_CHDIR 1)\n    endif()\n\n    if (GLFW_BUILD_UNIVERSAL)\n        message(STATUS \"Building GLFW as Universal Binaries\")\n        set(CMAKE_OSX_ARCHITECTURES i386;x86_64)\n    else()\n        message(STATUS \"Building GLFW only for the native architecture\")\n    endif()\n    \n    # Set up library and include paths\n    find_library(COCOA_FRAMEWORK Cocoa)\n    find_library(IOKIT_FRAMEWORK IOKit)\n    find_library(CORE_FOUNDATION_FRAMEWORK CoreFoundation)\n    list(APPEND glfw_LIBRARIES ${COCOA_FRAMEWORK}\n                               ${OPENGL_gl_LIBRARY}\n                               ${IOKIT_FRAMEWORK}\n                               ${CORE_FOUNDATION_FRAMEWORK})\n\n    set(GLFW_PKG_DEPS \"\")\n    set(GLFW_PKG_LIBS \"-framework Cocoa -framework OpenGL -framework IOKit -framework CoreFoundation\")\nendif()\n\n#--------------------------------------------------------------------\n# Export GLFW library dependencies\n#--------------------------------------------------------------------\nset(GLFW_LIBRARIES ${glfw_LIBRARIES} CACHE STRING \"Dependencies of GLFW\")\n\n#--------------------------------------------------------------------\n# Choose library output name\n#--------------------------------------------------------------------\nif (BUILD_SHARED_LIBS AND UNIX)\n    # On Unix-like systems, shared libraries can use the soname system.\n    set(GLFW_LIB_NAME glfw)\nelse()\n    set(GLFW_LIB_NAME glfw3)\nendif()\n\n#--------------------------------------------------------------------\n# Create generated files\n#--------------------------------------------------------------------\nconfigure_file(${GLFW_SOURCE_DIR}/docs/Doxyfile.in\n               ${GLFW_BINARY_DIR}/docs/Doxyfile @ONLY)\n\nconfigure_file(${GLFW_SOURCE_DIR}/src/config.h.in \n               ${GLFW_BINARY_DIR}/src/config.h @ONLY)\n\nconfigure_file(${GLFW_SOURCE_DIR}/src/glfwConfig.cmake.in\n               ${GLFW_BINARY_DIR}/src/glfwConfig.cmake @ONLY)\n\nconfigure_file(${GLFW_SOURCE_DIR}/src/glfwConfigVersion.cmake.in\n               ${GLFW_BINARY_DIR}/src/glfwConfigVersion.cmake @ONLY)\n\nif (UNIX)\n    configure_file(${GLFW_SOURCE_DIR}/src/glfw3.pc.in\n                   ${GLFW_BINARY_DIR}/src/glfw3.pc @ONLY)\nendif()\n\n#--------------------------------------------------------------------\n# Add subdirectories\n#--------------------------------------------------------------------\nadd_subdirectory(src)\n\nif (GLFW_BUILD_EXAMPLES)\n    add_subdirectory(examples)\nendif()\n\nif (GLFW_BUILD_TESTS)\n    add_subdirectory(tests)\nendif()\n\nif (DOXYGEN_FOUND)\n    add_subdirectory(docs)\nendif()\n\n#--------------------------------------------------------------------\n# Install files other than the library\n# The library is installed by src/CMakeLists.txt\n#--------------------------------------------------------------------\nif (GLFW_INSTALL)\n    install(DIRECTORY include/GLFW DESTINATION include \n            FILES_MATCHING PATTERN glfw3.h PATTERN glfw3native.h)\n\n    install(FILES ${GLFW_BINARY_DIR}/src/glfwConfig.cmake\n                  ${GLFW_BINARY_DIR}/src/glfwConfigVersion.cmake\n            DESTINATION lib${LIB_SUFFIX}/cmake/glfw)\n\n    if (UNIX)\n        install(EXPORT glfwTargets DESTINATION lib${LIB_SUFFIX}/cmake/glfw)\n        install(FILES ${GLFW_BINARY_DIR}/src/glfw3.pc\n                DESTINATION lib${LIB_SUFFIX}/pkgconfig)\n    endif()\n\n    # Only generate this target if no higher-level project already has\n    if (NOT TARGET uninstall)\n        configure_file(${GLFW_SOURCE_DIR}/cmake_uninstall.cmake.in\n                       ${GLFW_BINARY_DIR}/cmake_uninstall.cmake IMMEDIATE @ONLY)\n\n        add_custom_target(uninstall\n                          ${CMAKE_COMMAND} -P\n                          ${GLFW_BINARY_DIR}/cmake_uninstall.cmake)\n    endif()\nendif()\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-glfw-3.0.3-oynij7sjlquvi4isxs32tj7bcnaztgr7/spack-src/src/config.h.in": "//========================================================================\n// GLFW 3.0 - www.glfw.org\n//------------------------------------------------------------------------\n// Copyright (c) 2010 Camilla Berglund <elmindreda@elmindreda.org>\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would\n//    be appreciated but is not required.\n//\n// 2. Altered source versions must be plainly marked as such, and must not\n//    be misrepresented as being the original software.\n//\n// 3. This notice may not be removed or altered from any source\n//    distribution.\n//\n//========================================================================\n// As config.h.in, this file is used by CMake to produce the config.h shared\n// configuration header file.  If you are adding a feature requiring\n// conditional compilation, this is the proper place to add the macros.\n//========================================================================\n// As config.h, this file defines compile-time build options and macros for\n// all platforms supported by GLFW.  As this is a generated file, don't modify\n// it.  Instead, you should modify the config.h.in file.\n//========================================================================\n\n// Define this to 1 if building GLFW for X11\n#cmakedefine _GLFW_X11\n// Define this to 1 if building GLFW for Win32\n#cmakedefine _GLFW_WIN32\n// Define this to 1 if building GLFW for Cocoa\n#cmakedefine _GLFW_COCOA\n\n// Define this to 1 if building GLFW for EGL\n#cmakedefine _GLFW_EGL\n// Define this to 1 if building GLFW for GLX\n#cmakedefine _GLFW_GLX\n// Define this to 1 if building GLFW for WGL\n#cmakedefine _GLFW_WGL\n// Define this to 1 if building GLFW for NSGL\n#cmakedefine _GLFW_NSGL\n\n// Define this to 1 if building as a shared library / dynamic library / DLL\n#cmakedefine _GLFW_BUILD_DLL\n\n// Define this to 1 to disable dynamic loading of winmm\n#cmakedefine _GLFW_NO_DLOAD_WINMM\n// Define this to 1 if glfwSwapInterval should ignore DWM compositing status\n#cmakedefine _GLFW_USE_DWM_SWAP_INTERVAL\n// Define this to 1 to force use of high-performance GPU on Optimus systems\n#cmakedefine _GLFW_USE_OPTIMUS_HPG\n\n// Define this to 1 if glXGetProcAddress is available\n#cmakedefine _GLFW_HAS_GLXGETPROCADDRESS\n// Define this to 1 if glXGetProcAddressARB is available\n#cmakedefine _GLFW_HAS_GLXGETPROCADDRESSARB\n// Define this to 1 if glXGetProcAddressEXT is available\n#cmakedefine _GLFW_HAS_GLXGETPROCADDRESSEXT\n// Define this to 1 if dlopen is available\n#cmakedefine _GLFW_HAS_DLOPEN\n\n// Define this to 1 if glfwInit should change the current directory\n#cmakedefine _GLFW_USE_CHDIR\n// Define this to 1 if glfwCreateWindow should populate the menu bar\n#cmakedefine _GLFW_USE_MENUBAR\n\n// Define this to 1 if using OpenGL as the client library\n#cmakedefine _GLFW_USE_OPENGL\n// Define this to 1 if using OpenGL ES 1.1 as the client library\n#cmakedefine _GLFW_USE_GLESV1\n// Define this to 1 if using OpenGL ES 2.0 as the client library\n#cmakedefine _GLFW_USE_GLESV2\n\n// The GLFW version as used by glfwGetVersionString\n#define _GLFW_VERSION_FULL \"@GLFW_VERSION_FULL@\"\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-glfw-3.0.3-oynij7sjlquvi4isxs32tj7bcnaztgr7/spack-src/src/glx_context.c": "//========================================================================\n// GLFW 3.0 GLX - www.glfw.org\n//------------------------------------------------------------------------\n// Copyright (c) 2002-2006 Marcus Geelnard\n// Copyright (c) 2006-2010 Camilla Berglund <elmindreda@elmindreda.org>\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would\n//    be appreciated but is not required.\n//\n// 2. Altered source versions must be plainly marked as such, and must not\n//    be misrepresented as being the original software.\n//\n// 3. This notice may not be removed or altered from any source\n//    distribution.\n//\n//========================================================================\n\n#include \"internal.h\"\n\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <pthread.h>\n\n\n// This is the only glXGetProcAddress variant not declared by glxext.h\nvoid (*glXGetProcAddressEXT(const GLubyte* procName))();\n\n\n#ifndef GLXBadProfileARB\n #define GLXBadProfileARB 13\n#endif\n\n\n// Returns the specified attribute of the specified GLXFBConfig\n// NOTE: Do not call this unless we have found GLX 1.3+ or GLX_SGIX_fbconfig\n//\nstatic int getFBConfigAttrib(GLXFBConfig fbconfig, int attrib)\n{\n    int value;\n\n    if (_glfw.glx.SGIX_fbconfig)\n    {\n        _glfw.glx.GetFBConfigAttribSGIX(_glfw.x11.display,\n                                        fbconfig, attrib, &value);\n    }\n    else\n        glXGetFBConfigAttrib(_glfw.x11.display, fbconfig, attrib, &value);\n\n    return value;\n}\n\n// Return a list of available and usable framebuffer configs\n//\nstatic GLboolean chooseFBConfig(const _GLFWfbconfig* desired, GLXFBConfig* result)\n{\n    GLXFBConfig* nativeConfigs;\n    _GLFWfbconfig* usableConfigs;\n    const _GLFWfbconfig* closest;\n    int i, nativeCount, usableCount;\n    const char* vendor;\n    GLboolean trustWindowBit = GL_TRUE;\n\n    vendor = glXGetClientString(_glfw.x11.display, GLX_VENDOR);\n    if (strcmp(vendor, \"Chromium\") == 0)\n    {\n        // HACK: This is a (hopefully temporary) workaround for Chromium\n        // (VirtualBox GL) not setting the window bit on any GLXFBConfigs\n        trustWindowBit = GL_FALSE;\n    }\n\n    if (_glfw.glx.SGIX_fbconfig)\n    {\n        nativeConfigs = _glfw.glx.ChooseFBConfigSGIX(_glfw.x11.display,\n                                                     _glfw.x11.screen,\n                                                     NULL,\n                                                     &nativeCount);\n    }\n    else\n    {\n        nativeConfigs = glXGetFBConfigs(_glfw.x11.display,\n                                        _glfw.x11.screen,\n                                        &nativeCount);\n    }\n\n    if (!nativeCount)\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE,\n                        \"GLX: No GLXFBConfigs returned\");\n        return GL_FALSE;\n    }\n\n    usableConfigs = calloc(nativeCount, sizeof(_GLFWfbconfig));\n    usableCount = 0;\n\n    for (i = 0;  i < nativeCount;  i++)\n    {\n        const GLXFBConfig n = nativeConfigs[i];\n        _GLFWfbconfig* u = usableConfigs + usableCount;\n\n        if (!getFBConfigAttrib(n, GLX_DOUBLEBUFFER) ||\n            !getFBConfigAttrib(n, GLX_VISUAL_ID))\n        {\n            // Only consider double-buffered GLXFBConfigs with associated visuals\n            continue;\n        }\n\n        if (!(getFBConfigAttrib(n, GLX_RENDER_TYPE) & GLX_RGBA_BIT))\n        {\n            // Only consider RGBA GLXFBConfigs\n            continue;\n        }\n\n        if (!(getFBConfigAttrib(n, GLX_DRAWABLE_TYPE) & GLX_WINDOW_BIT))\n        {\n            if (trustWindowBit)\n            {\n                // Only consider window GLXFBConfigs\n                continue;\n            }\n        }\n\n        u->redBits = getFBConfigAttrib(n, GLX_RED_SIZE);\n        u->greenBits = getFBConfigAttrib(n, GLX_GREEN_SIZE);\n        u->blueBits = getFBConfigAttrib(n, GLX_BLUE_SIZE);\n\n        u->alphaBits = getFBConfigAttrib(n, GLX_ALPHA_SIZE);\n        u->depthBits = getFBConfigAttrib(n, GLX_DEPTH_SIZE);\n        u->stencilBits = getFBConfigAttrib(n, GLX_STENCIL_SIZE);\n\n        u->accumRedBits = getFBConfigAttrib(n, GLX_ACCUM_RED_SIZE);\n        u->accumGreenBits = getFBConfigAttrib(n, GLX_ACCUM_GREEN_SIZE);\n        u->accumBlueBits = getFBConfigAttrib(n, GLX_ACCUM_BLUE_SIZE);\n        u->accumAlphaBits = getFBConfigAttrib(n, GLX_ACCUM_ALPHA_SIZE);\n\n        u->auxBuffers = getFBConfigAttrib(n, GLX_AUX_BUFFERS);\n        u->stereo = getFBConfigAttrib(n, GLX_STEREO);\n\n        if (_glfw.glx.ARB_multisample)\n            u->samples = getFBConfigAttrib(n, GLX_SAMPLES);\n\n        if (_glfw.glx.ARB_framebuffer_sRGB)\n            u->sRGB = getFBConfigAttrib(n, GLX_FRAMEBUFFER_SRGB_CAPABLE_ARB);\n\n        u->glx = n;\n        usableCount++;\n    }\n\n    closest = _glfwChooseFBConfig(desired, usableConfigs, usableCount);\n    if (closest)\n        *result = closest->glx;\n\n    XFree(nativeConfigs);\n    free(usableConfigs);\n\n    return closest ? GL_TRUE : GL_FALSE;\n}\n\n// Create the OpenGL context using legacy API\n//\nstatic GLXContext createLegacyContext(_GLFWwindow* window,\n                                      GLXFBConfig fbconfig,\n                                      GLXContext share)\n{\n    if (_glfw.glx.SGIX_fbconfig)\n    {\n        return _glfw.glx.CreateContextWithConfigSGIX(_glfw.x11.display,\n                                                     fbconfig,\n                                                     GLX_RGBA_TYPE,\n                                                     share,\n                                                     True);\n    }\n\n    return glXCreateNewContext(_glfw.x11.display,\n                               fbconfig,\n                               GLX_RGBA_TYPE,\n                               share,\n                               True);\n}\n\n\n//////////////////////////////////////////////////////////////////////////\n//////                       GLFW internal API                      //////\n//////////////////////////////////////////////////////////////////////////\n\n// Initialize GLX\n//\nint _glfwInitContextAPI(void)\n{\n#ifdef _GLFW_DLOPEN_LIBGL\n    int i;\n    char* libGL_names[ ] =\n    {\n        \"libGL.so\",\n        \"libGL.so.1\",\n        \"/usr/lib/libGL.so\",\n        \"/usr/lib/libGL.so.1\",\n        NULL\n    };\n\n    for (i = 0;  libGL_names[i] != NULL;  i++)\n    {\n        _glfw.glx.libGL = dlopen(libGL_names[i], RTLD_LAZY | RTLD_GLOBAL);\n        if (_glfw.glx.libGL)\n            break;\n    }\n\n    if (!_glfw.glx.libGL)\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR, \"GLX: Failed to find libGL\");\n        return GL_FALSE;\n    }\n#endif\n\n    if (pthread_key_create(&_glfw.glx.current, NULL) != 0)\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"GLX: Failed to create context TLS\");\n        return GL_FALSE;\n    }\n\n    // Check if GLX is supported on this display\n    if (!glXQueryExtension(_glfw.x11.display,\n                           &_glfw.glx.errorBase,\n                           &_glfw.glx.eventBase))\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE, \"GLX: GLX support not found\");\n        return GL_FALSE;\n    }\n\n    if (!glXQueryVersion(_glfw.x11.display,\n                         &_glfw.glx.versionMajor,\n                         &_glfw.glx.versionMinor))\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE,\n                        \"GLX: Failed to query GLX version\");\n        return GL_FALSE;\n    }\n\n    if (_glfwPlatformExtensionSupported(\"GLX_EXT_swap_control\"))\n    {\n        _glfw.glx.SwapIntervalEXT = (PFNGLXSWAPINTERVALEXTPROC)\n            _glfwPlatformGetProcAddress(\"glXSwapIntervalEXT\");\n\n        if (_glfw.glx.SwapIntervalEXT)\n            _glfw.glx.EXT_swap_control = GL_TRUE;\n    }\n\n    if (_glfwPlatformExtensionSupported(\"GLX_SGI_swap_control\"))\n    {\n        _glfw.glx.SwapIntervalSGI = (PFNGLXSWAPINTERVALSGIPROC)\n            _glfwPlatformGetProcAddress(\"glXSwapIntervalSGI\");\n\n        if (_glfw.glx.SwapIntervalSGI)\n            _glfw.glx.SGI_swap_control = GL_TRUE;\n    }\n\n    if (_glfwPlatformExtensionSupported(\"GLX_MESA_swap_control\"))\n    {\n        _glfw.glx.SwapIntervalMESA = (PFNGLXSWAPINTERVALMESAPROC)\n            _glfwPlatformGetProcAddress(\"glXSwapIntervalMESA\");\n\n        if (_glfw.glx.SwapIntervalMESA)\n            _glfw.glx.MESA_swap_control = GL_TRUE;\n    }\n\n    if (_glfwPlatformExtensionSupported(\"GLX_SGIX_fbconfig\"))\n    {\n        _glfw.glx.GetFBConfigAttribSGIX = (PFNGLXGETFBCONFIGATTRIBSGIXPROC)\n            _glfwPlatformGetProcAddress(\"glXGetFBConfigAttribSGIX\");\n        _glfw.glx.ChooseFBConfigSGIX = (PFNGLXCHOOSEFBCONFIGSGIXPROC)\n            _glfwPlatformGetProcAddress(\"glXChooseFBConfigSGIX\");\n        _glfw.glx.CreateContextWithConfigSGIX = (PFNGLXCREATECONTEXTWITHCONFIGSGIXPROC)\n            _glfwPlatformGetProcAddress(\"glXCreateContextWithConfigSGIX\");\n        _glfw.glx.GetVisualFromFBConfigSGIX = (PFNGLXGETVISUALFROMFBCONFIGSGIXPROC)\n            _glfwPlatformGetProcAddress(\"glXGetVisualFromFBConfigSGIX\");\n\n        if (_glfw.glx.GetFBConfigAttribSGIX &&\n            _glfw.glx.ChooseFBConfigSGIX &&\n            _glfw.glx.CreateContextWithConfigSGIX &&\n            _glfw.glx.GetVisualFromFBConfigSGIX)\n        {\n            _glfw.glx.SGIX_fbconfig = GL_TRUE;\n        }\n    }\n\n    if (_glfwPlatformExtensionSupported(\"GLX_ARB_multisample\"))\n        _glfw.glx.ARB_multisample = GL_TRUE;\n\n    if (_glfwPlatformExtensionSupported(\"GLX_ARB_framebuffer_sRGB\"))\n        _glfw.glx.ARB_framebuffer_sRGB = GL_TRUE;\n\n    if (_glfwPlatformExtensionSupported(\"GLX_ARB_create_context\"))\n    {\n        _glfw.glx.CreateContextAttribsARB = (PFNGLXCREATECONTEXTATTRIBSARBPROC)\n            _glfwPlatformGetProcAddress(\"glXCreateContextAttribsARB\");\n\n        if (_glfw.glx.CreateContextAttribsARB)\n            _glfw.glx.ARB_create_context = GL_TRUE;\n    }\n\n    if (_glfwPlatformExtensionSupported(\"GLX_ARB_create_context_robustness\"))\n        _glfw.glx.ARB_create_context_robustness = GL_TRUE;\n\n    if (_glfwPlatformExtensionSupported(\"GLX_ARB_create_context_profile\"))\n        _glfw.glx.ARB_create_context_profile = GL_TRUE;\n\n    if (_glfwPlatformExtensionSupported(\"GLX_EXT_create_context_es2_profile\"))\n        _glfw.glx.EXT_create_context_es2_profile = GL_TRUE;\n\n    return GL_TRUE;\n}\n\n// Terminate GLX\n//\nvoid _glfwTerminateContextAPI(void)\n{\n    // Unload libGL.so if necessary\n#ifdef _GLFW_DLOPEN_LIBGL\n    if (_glfw.glx.libGL != NULL)\n    {\n        dlclose(_glfw.glx.libGL);\n        _glfw.glx.libGL = NULL;\n    }\n#endif\n\n    pthread_key_delete(_glfw.glx.current);\n}\n\n#define setGLXattrib(attribName, attribValue) \\\n{ \\\n    attribs[index++] = attribName; \\\n    attribs[index++] = attribValue; \\\n    assert((size_t) index < sizeof(attribs) / sizeof(attribs[0])); \\\n}\n\n// Prepare for creation of the OpenGL context\n//\nint _glfwCreateContext(_GLFWwindow* window,\n                       const _GLFWwndconfig* wndconfig,\n                       const _GLFWfbconfig* fbconfig)\n{\n    int attribs[40];\n    GLXFBConfig native;\n    GLXContext share = NULL;\n\n    if (wndconfig->share)\n        share = wndconfig->share->glx.context;\n\n    if (!chooseFBConfig(fbconfig, &native))\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"GLX: Failed to find a suitable GLXFBConfig\");\n        return GL_FALSE;\n    }\n\n    // Retrieve the corresponding visual\n    if (_glfw.glx.SGIX_fbconfig)\n    {\n        window->glx.visual =\n            _glfw.glx.GetVisualFromFBConfigSGIX(_glfw.x11.display, native);\n    }\n    else\n        window->glx.visual = glXGetVisualFromFBConfig(_glfw.x11.display, native);\n\n    if (window->glx.visual == NULL)\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"GLX: Failed to retrieve visual for GLXFBConfig\");\n        return GL_FALSE;\n    }\n\n    if (wndconfig->clientAPI == GLFW_OPENGL_ES_API)\n    {\n        if (!_glfw.glx.ARB_create_context ||\n            !_glfw.glx.ARB_create_context_profile ||\n            !_glfw.glx.EXT_create_context_es2_profile)\n        {\n            _glfwInputError(GLFW_API_UNAVAILABLE,\n                            \"GLX: OpenGL ES requested but \"\n                            \"GLX_EXT_create_context_es2_profile is unavailable\");\n            return GL_FALSE;\n        }\n    }\n\n    if (wndconfig->glForward)\n    {\n        if (!_glfw.glx.ARB_create_context)\n        {\n            _glfwInputError(GLFW_VERSION_UNAVAILABLE,\n                            \"GLX: Forward compatibility requested but \"\n                            \"GLX_ARB_create_context_profile is unavailable\");\n            return GL_FALSE;\n        }\n    }\n\n    if (wndconfig->glProfile)\n    {\n        if (!_glfw.glx.ARB_create_context ||\n            !_glfw.glx.ARB_create_context_profile)\n        {\n            _glfwInputError(GLFW_VERSION_UNAVAILABLE,\n                            \"GLX: An OpenGL profile requested but \"\n                            \"GLX_ARB_create_context_profile is unavailable\");\n            return GL_FALSE;\n        }\n    }\n\n    _glfwGrabXErrorHandler();\n\n    if (_glfw.glx.ARB_create_context)\n    {\n        int index = 0, mask = 0, flags = 0, strategy = 0;\n\n        if (wndconfig->clientAPI == GLFW_OPENGL_API)\n        {\n            if (wndconfig->glForward)\n                flags |= GLX_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB;\n\n            if (wndconfig->glDebug)\n                flags |= GLX_CONTEXT_DEBUG_BIT_ARB;\n\n            if (wndconfig->glProfile)\n            {\n                if (wndconfig->glProfile == GLFW_OPENGL_CORE_PROFILE)\n                    mask |= GLX_CONTEXT_CORE_PROFILE_BIT_ARB;\n                else if (wndconfig->glProfile == GLFW_OPENGL_COMPAT_PROFILE)\n                    mask |= GLX_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB;\n            }\n        }\n        else\n            mask |= GLX_CONTEXT_ES2_PROFILE_BIT_EXT;\n\n        if (wndconfig->glRobustness != GLFW_NO_ROBUSTNESS)\n        {\n            if (_glfw.glx.ARB_create_context_robustness)\n            {\n                if (wndconfig->glRobustness == GLFW_NO_RESET_NOTIFICATION)\n                    strategy = GLX_NO_RESET_NOTIFICATION_ARB;\n                else if (wndconfig->glRobustness == GLFW_LOSE_CONTEXT_ON_RESET)\n                    strategy = GLX_LOSE_CONTEXT_ON_RESET_ARB;\n\n                flags |= GLX_CONTEXT_ROBUST_ACCESS_BIT_ARB;\n            }\n        }\n\n        if (wndconfig->glMajor != 1 || wndconfig->glMinor != 0)\n        {\n            // NOTE: Only request an explicitly versioned context when\n            // necessary, as explicitly requesting version 1.0 does not always\n            // return the highest available version\n\n            setGLXattrib(GLX_CONTEXT_MAJOR_VERSION_ARB, wndconfig->glMajor);\n            setGLXattrib(GLX_CONTEXT_MINOR_VERSION_ARB, wndconfig->glMinor);\n        }\n\n        if (mask)\n            setGLXattrib(GLX_CONTEXT_PROFILE_MASK_ARB, mask);\n\n        if (flags)\n            setGLXattrib(GLX_CONTEXT_FLAGS_ARB, flags);\n\n        if (strategy)\n            setGLXattrib(GLX_CONTEXT_RESET_NOTIFICATION_STRATEGY_ARB, strategy);\n\n        setGLXattrib(None, None);\n\n        window->glx.context =\n            _glfw.glx.CreateContextAttribsARB(_glfw.x11.display,\n                                              native,\n                                              share,\n                                              True,\n                                              attribs);\n\n        if (window->glx.context == NULL)\n        {\n            // HACK: This is a fallback for the broken Mesa implementation of\n            // GLX_ARB_create_context_profile, which fails default 1.0 context\n            // creation with a GLXBadProfileARB error in violation of the spec\n            if (_glfw.x11.errorCode == _glfw.glx.errorBase + GLXBadProfileARB &&\n                wndconfig->clientAPI == GLFW_OPENGL_API &&\n                wndconfig->glProfile == GLFW_OPENGL_ANY_PROFILE &&\n                wndconfig->glForward == GL_FALSE)\n            {\n                window->glx.context = createLegacyContext(window, native, share);\n            }\n        }\n    }\n    else\n        window->glx.context = createLegacyContext(window, native, share);\n\n    _glfwReleaseXErrorHandler();\n\n    if (window->glx.context == NULL)\n    {\n        _glfwInputXError(GLFW_PLATFORM_ERROR, \"GLX: Failed to create context\");\n        return GL_FALSE;\n    }\n\n    return GL_TRUE;\n}\n\n#undef setGLXattrib\n\n// Destroy the OpenGL context\n//\nvoid _glfwDestroyContext(_GLFWwindow* window)\n{\n    if (window->glx.visual)\n    {\n        XFree(window->glx.visual);\n        window->glx.visual = NULL;\n    }\n\n    if (window->glx.context)\n    {\n        glXDestroyContext(_glfw.x11.display, window->glx.context);\n        window->glx.context = NULL;\n    }\n}\n\n\n//////////////////////////////////////////////////////////////////////////\n//////                       GLFW platform API                      //////\n//////////////////////////////////////////////////////////////////////////\n\nvoid _glfwPlatformMakeContextCurrent(_GLFWwindow* window)\n{\n    if (window)\n    {\n        glXMakeCurrent(_glfw.x11.display,\n                       window->x11.handle,\n                       window->glx.context);\n    }\n    else\n        glXMakeCurrent(_glfw.x11.display, None, NULL);\n\n    pthread_setspecific(_glfw.glx.current, window);\n}\n\n_GLFWwindow* _glfwPlatformGetCurrentContext(void)\n{\n    return (_GLFWwindow*) pthread_getspecific(_glfw.glx.current);\n}\n\nvoid _glfwPlatformSwapBuffers(_GLFWwindow* window)\n{\n    glXSwapBuffers(_glfw.x11.display, window->x11.handle);\n}\n\nvoid _glfwPlatformSwapInterval(int interval)\n{\n    _GLFWwindow* window = _glfwPlatformGetCurrentContext();\n\n    if (_glfw.glx.EXT_swap_control)\n    {\n        _glfw.glx.SwapIntervalEXT(_glfw.x11.display,\n                                  window->x11.handle,\n                                  interval);\n    }\n    else if (_glfw.glx.MESA_swap_control)\n        _glfw.glx.SwapIntervalMESA(interval);\n    else if (_glfw.glx.SGI_swap_control)\n    {\n        if (interval > 0)\n            _glfw.glx.SwapIntervalSGI(interval);\n    }\n}\n\nint _glfwPlatformExtensionSupported(const char* extension)\n{\n    const GLubyte* extensions;\n\n    // Get list of GLX extensions\n    extensions = (const GLubyte*) glXQueryExtensionsString(_glfw.x11.display,\n                                                           _glfw.x11.screen);\n    if (extensions != NULL)\n    {\n        if (_glfwStringInExtensionString(extension, extensions))\n            return GL_TRUE;\n    }\n\n    return GL_FALSE;\n}\n\nGLFWglproc _glfwPlatformGetProcAddress(const char* procname)\n{\n    return _glfw_glXGetProcAddress((const GLubyte*) procname);\n}\n\n\n//////////////////////////////////////////////////////////////////////////\n//////                        GLFW native API                       //////\n//////////////////////////////////////////////////////////////////////////\n\nGLFWAPI GLXContext glfwGetGLXContext(GLFWwindow* handle)\n{\n    _GLFWwindow* window = (_GLFWwindow*) handle;\n    _GLFW_REQUIRE_INIT_OR_RETURN(NULL);\n    return window->glx.context;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-glfw-3.0.3-oynij7sjlquvi4isxs32tj7bcnaztgr7/spack-src/src/egl_platform.h": "//========================================================================\n// GLFW 3.0 EGL - www.glfw.org\n//------------------------------------------------------------------------\n// Copyright (c) 2002-2006 Marcus Geelnard\n// Copyright (c) 2006-2010 Camilla Berglund <elmindreda@elmindreda.org>\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would\n//    be appreciated but is not required.\n//\n// 2. Altered source versions must be plainly marked as such, and must not\n//    be misrepresented as being the original software.\n//\n// 3. This notice may not be removed or altered from any source\n//    distribution.\n//\n//========================================================================\n\n#ifndef _egl_platform_h_\n#define _egl_platform_h_\n\n#include <EGL/egl.h>\n\n// This path may need to be changed if you build GLFW using your own setup\n// We ship and use our own copy of eglext.h since GLFW uses fairly new\n// extensions and not all operating systems come with an up-to-date version\n#include \"../deps/EGL/eglext.h\"\n\n// Do we have support for dlopen/dlsym?\n#if defined(_GLFW_HAS_DLOPEN)\n #include <dlfcn.h>\n#endif\n\n#define _GLFW_PLATFORM_FBCONFIG             EGLConfig       egl\n#define _GLFW_PLATFORM_CONTEXT_STATE        _GLFWcontextEGL egl\n#define _GLFW_PLATFORM_LIBRARY_OPENGL_STATE _GLFWlibraryEGL egl\n\n\n//========================================================================\n// GLFW platform specific types\n//========================================================================\n\n//------------------------------------------------------------------------\n// Platform-specific OpenGL context structure\n//------------------------------------------------------------------------\ntypedef struct _GLFWcontextEGL\n{\n   EGLConfig      config;\n   EGLContext     context;\n   EGLSurface     surface;\n\n#if defined(_GLFW_X11)\n   XVisualInfo*   visual;\n#endif\n} _GLFWcontextEGL;\n\n\n//------------------------------------------------------------------------\n// Platform-specific library global data for EGL\n//------------------------------------------------------------------------\ntypedef struct _GLFWlibraryEGL\n{\n    EGLDisplay      display;\n    EGLint          versionMajor, versionMinor;\n\n    GLboolean       KHR_create_context;\n\n} _GLFWlibraryEGL;\n\n\n#endif // _egl_platform_h_\n",
        "/tmp/vanessa/spack-stage/spack-stage-glfw-3.0.3-oynij7sjlquvi4isxs32tj7bcnaztgr7/spack-src/src/glx_platform.h": "//========================================================================\n// GLFW 3.0 GLX - www.glfw.org\n//------------------------------------------------------------------------\n// Copyright (c) 2002-2006 Marcus Geelnard\n// Copyright (c) 2006-2010 Camilla Berglund <elmindreda@elmindreda.org>\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would\n//    be appreciated but is not required.\n//\n// 2. Altered source versions must be plainly marked as such, and must not\n//    be misrepresented as being the original software.\n//\n// 3. This notice may not be removed or altered from any source\n//    distribution.\n//\n//========================================================================\n\n#ifndef _glx_platform_h_\n#define _glx_platform_h_\n\n#define GLX_GLXEXT_LEGACY\n#include <GL/glx.h>\n\n// This path may need to be changed if you build GLFW using your own setup\n// We ship and use our own copy of glxext.h since GLFW uses fairly new\n// extensions and not all operating systems come with an up-to-date version\n#include \"../deps/GL/glxext.h\"\n\n// Do we have support for dlopen/dlsym?\n#if defined(_GLFW_HAS_DLOPEN)\n #include <dlfcn.h>\n#endif\n\n// We support four different ways for getting addresses for GL/GLX\n// extension functions: glXGetProcAddress, glXGetProcAddressARB,\n// glXGetProcAddressEXT, and dlsym\n#if defined(_GLFW_HAS_GLXGETPROCADDRESSARB)\n #define _glfw_glXGetProcAddress(x) glXGetProcAddressARB(x)\n#elif defined(_GLFW_HAS_GLXGETPROCADDRESS)\n #define _glfw_glXGetProcAddress(x) glXGetProcAddress(x)\n#elif defined(_GLFW_HAS_GLXGETPROCADDRESSEXT)\n #define _glfw_glXGetProcAddress(x) glXGetProcAddressEXT(x)\n#elif defined(_GLFW_HAS_DLOPEN)\n #define _glfw_glXGetProcAddress(x) dlsym(_glfw.glx.libGL, x)\n #define _GLFW_DLOPEN_LIBGL\n#else\n #error \"No OpenGL entry point retrieval mechanism was enabled\"\n#endif\n\n#define _GLFW_PLATFORM_FBCONFIG             GLXFBConfig     glx\n#define _GLFW_PLATFORM_CONTEXT_STATE        _GLFWcontextGLX glx\n#define _GLFW_PLATFORM_LIBRARY_OPENGL_STATE _GLFWlibraryGLX glx\n\n#ifndef GLX_MESA_swap_control\ntypedef int (*PFNGLXSWAPINTERVALMESAPROC)(int);\n#endif\n\n\n//========================================================================\n// GLFW platform specific types\n//========================================================================\n\n//------------------------------------------------------------------------\n// Platform-specific OpenGL context structure\n//------------------------------------------------------------------------\ntypedef struct _GLFWcontextGLX\n{\n    GLXContext      context; // OpenGL rendering context\n    XVisualInfo*    visual;  // Visual for selected GLXFBConfig\n\n} _GLFWcontextGLX;\n\n\n//------------------------------------------------------------------------\n// Platform-specific library global data for GLX\n//------------------------------------------------------------------------\ntypedef struct _GLFWlibraryGLX\n{\n    // Server-side GLX version\n    int             versionMajor, versionMinor;\n    int             eventBase;\n    int             errorBase;\n\n    // TLS key for per-thread current context/window\n    pthread_key_t   current;\n\n    // GLX extensions\n    PFNGLXSWAPINTERVALSGIPROC             SwapIntervalSGI;\n    PFNGLXSWAPINTERVALEXTPROC             SwapIntervalEXT;\n    PFNGLXSWAPINTERVALMESAPROC            SwapIntervalMESA;\n    PFNGLXGETFBCONFIGATTRIBSGIXPROC       GetFBConfigAttribSGIX;\n    PFNGLXCHOOSEFBCONFIGSGIXPROC          ChooseFBConfigSGIX;\n    PFNGLXCREATECONTEXTWITHCONFIGSGIXPROC CreateContextWithConfigSGIX;\n    PFNGLXGETVISUALFROMFBCONFIGSGIXPROC   GetVisualFromFBConfigSGIX;\n    PFNGLXCREATECONTEXTATTRIBSARBPROC     CreateContextAttribsARB;\n    GLboolean       SGIX_fbconfig;\n    GLboolean       SGI_swap_control;\n    GLboolean       EXT_swap_control;\n    GLboolean       MESA_swap_control;\n    GLboolean       ARB_multisample;\n    GLboolean       ARB_framebuffer_sRGB;\n    GLboolean       ARB_create_context;\n    GLboolean       ARB_create_context_profile;\n    GLboolean       ARB_create_context_robustness;\n    GLboolean       EXT_create_context_es2_profile;\n\n#if defined(_GLFW_DLOPEN_LIBGL)\n    void*           libGL;  // dlopen handle for libGL.so\n#endif\n} _GLFWlibraryGLX;\n\n\n#endif // _glx_platform_h_\n",
        "/tmp/vanessa/spack-stage/spack-stage-glfw-3.0.3-oynij7sjlquvi4isxs32tj7bcnaztgr7/spack-src/src/nsgl_platform.h": "//========================================================================\n// GLFW 3.0 OS X - www.glfw.org\n//------------------------------------------------------------------------\n// Copyright (c) 2009-2010 Camilla Berglund <elmindreda@elmindreda.org>\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would\n//    be appreciated but is not required.\n//\n// 2. Altered source versions must be plainly marked as such, and must not\n//    be misrepresented as being the original software.\n//\n// 3. This notice may not be removed or altered from any source\n//    distribution.\n//\n//========================================================================\n\n#ifndef _nsgl_platform_h_\n#define _nsgl_platform_h_\n\n\n#define _GLFW_PLATFORM_FBCONFIG\n#define _GLFW_PLATFORM_CONTEXT_STATE        _GLFWcontextNSGL nsgl\n#define _GLFW_PLATFORM_LIBRARY_OPENGL_STATE _GLFWlibraryNSGL nsgl\n\n\n//========================================================================\n// GLFW platform specific types\n//========================================================================\n\n//------------------------------------------------------------------------\n// Platform-specific OpenGL context structure\n//------------------------------------------------------------------------\ntypedef struct _GLFWcontextNSGL\n{\n    id           pixelFormat;\n    id\t         context;\n} _GLFWcontextNSGL;\n\n\n//------------------------------------------------------------------------\n// Platform-specific library global data for NSGL\n//------------------------------------------------------------------------\ntypedef struct _GLFWlibraryNSGL\n{\n    // dlopen handle for dynamically loading OpenGL extension entry points\n    void*           framework;\n\n    // TLS key for per-thread current context/window\n    pthread_key_t   current;\n\n} _GLFWlibraryNSGL;\n\n\n#endif // _nsgl_platform_h_\n"
    },
    "skipped": [],
    "total_files": 108
}