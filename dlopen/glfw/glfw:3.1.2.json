{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-glfw-3.1.2-x6c6y6bid7i3cuhrzcx25eivkoimm5dy/spack-src/README.md": "# GLFW\n\n## Introduction\n\nGLFW is a free, Open Source, multi-platform library for OpenGL and OpenGL ES\napplication development.  It provides a simple, platform-independent API for\ncreating windows and contexts, reading input, handling events, etc.\n\nVersion 3.1.2 adds fixes for a large number of bugs that together affect all\nsupported platforms, as well as dynamic loading work that simplifies compilation\nand linking.\n\nIf you are new to GLFW, you may find the\n[introductory tutorial](http://www.glfw.org/docs/latest/quick.html) for GLFW\n3 useful.  If you have used GLFW 2 in the past, there is a\n[transition guide](http://www.glfw.org/docs/latest/moving.html) for moving to\nthe GLFW 3 API.\n\nNote that a number of source files have been added or renamed in 3.1, which may\nrequire you to update any custom build files you have.\n\n\n## Compiling GLFW\n\nSee the [Compiling GLFW](http://www.glfw.org/docs/latest/compile.html) guide in\nthe GLFW documentation.\n\n\n## Using GLFW\n\nSee the\n[Building programs that use GLFW](http://www.glfw.org/docs/latest/build.html)\nguide in the GLFW documentation.\n\n\n## Reporting bugs\n\nBugs are reported to our [issue tracker](https://github.com/glfw/glfw/issues).\nPlease always include the name and version of the OS where the bug occurs and\nthe version of GLFW used.  If you have cloned it, include the commit ID used.\n\nIf it's a build issue, please also include the build log and the name and\nversion of your development environment.\n\nIf it's a context creation issue, please also include the make and model of your\ngraphics card and the version of your driver.\n\nThis will help both us and other people experiencing the same bug.\n\n\n## Dependencies\n\nGLFW bundles a number of dependencies in the `deps/` directory.\n\n - [Khronos extension headers](https://www.opengl.org/registry/) for API\n   extension symbols used by GLFW\n - [getopt\\_port](https://github.com/kimgr/getopt_port/) for examples\n   with command-line options\n - [TinyCThread](https://github.com/tinycthread/tinycthread) for threaded\n   examples\n - An OpenGL 3.2 core loader generated by\n   [glad](https://github.com/Dav1dde/glad) for examples using modern OpenGL\n - [linmath.h](https://github.com/datenwolf/linmath.h) for linear algebra in\n   examples\n\n\n## Changelog\n\n - Made all client API functions dynamically loaded\n - Changed minimum required CMake version to 2.8.12\n - Replaced GLU with [linmath.h](https://github.com/datenwolf/linmath.h) in\n   example programs\n - Merged all cursor test programs into the `cursor` program\n - Removed all mention of GLU in examples, build files and package dependencies\n - Bugfix: Initialization failed on headless systems\n - Bugfix: The cached current context could get out of sync\n - Bugfix: `glfwIconifyWindow` did not restore the original video mode for full\n           screen windows created with `GLFW_AUTO_ICONIFY`\n - [Win32] Renamed hybrid GPU override compile-time option to\n           `_GLFW_USE_HYBRID_HPG` and added support for AMD PowerXpress systems\n - [Win32] Bugfix: `glfwGetVideoModes` included unusable modes on some systems\n - [Win32] Bugfix: `glfwWaitEvents` would return directly for focused windows in\n                   disabled cursor mode\n - [Cocoa] Bugfix: The cached `NSScreen` for a monitor could get out of sync\n - [Cocoa] Bugfix: The `GLFW_AUTO_ICONIFY` window hint was ignored\n - [Cocoa] Bugfix: Resizing a window to its minimum size would segfault\n - [Cocoa] Bugfix: Creating or showing a window would make its context current\n - [Cocoa] Bugfix: Joysticks connected after `glfwInit` were not detected\n - [Cocoa] Bugfix: Cursor creation failed unless a window had been created.\n - [Cocoa] Bugfix: Window refresh events were not generated by iconification or\n                   restoration\n - [Cocoa] Bugfix: The primary monitor would get reported as disconnected when\n                   entering full screen on a dual-GPU machine with automatic\n                   graphics switching\n - [Cocoa] Bugfix: The original video modes were not restored when the\n                   application was hidden\n - [X11] Bugfix: `glfwInit` would segfault on systems without RandR\n - [X11] Bugfix: The response to `_NET_WM_PING` was sent to the wrong window\n - [X11] Bugfix: Character input via XIM did not work in many cases\n - [X11] Bugfix: No fallback existed for missing `_NET_ACTIVE_WINDOW` support\n - [X11] Bugfix: Some significant window focus events were ignored\n - [X11] Bugfix: The `GLFW_AUTO_ICONIFY` window hint was ignored\n - [X11] Bugfix: The original video mode was not restored on iconification of\n                 full screen windows\n - [X11] Bugfix: `GLFW_ARROW_CURSOR` selected the wrong cursor image\n - [X11] Bugfix: The `GLFW_DECORATED` hint was not ignored for full screen\n - [X11] Bugfix: `glfwWaitEvents` did not handle `EINTR` for `select`\n - [X11] Bugfix: `glfwWaitEvents` could return when no events were available\n - [X11] Bugfix: `XkbGetKeyboard` fails on XWayland\n - [X11] Bugfix: Character input did not work correctly for non-UTF-8 locales\n - [X11] Bugfix: Long input sequences generated by IMEs were discarded\n - [WGL] Made all WGL functions dynamically loaded\n - [WGL] Removed `GLFW_USE_DWM_SWAP_INTERVAL` compile-time option\n - [WGL] Bugfix: Swap interval was ignored when DWM was enabled\n - [WGL] Bugfix: Failure to find a pixel format was reported incorrectly\n - [GLX] Added dependency on `libdl` on systems where it provides `dlopen`\n - [GLX] Made all GLX functions dynamically loaded\n - [GLX] Removed `_GLFW_HAS_GLXGETPROCADDRESS*` and `_GLFW_HAS_DLOPEN`\n         compile-time options\n - [GLX] Bugfix: Failure to find a `GLXFBConfig` was reported incorrectly\n - [EGL] Made all EGL functions dynamically loaded\n - [EGL] Bugfix: `glfwGetProcAddress` did not return the addresses of core\n                 functions\n - [EGL] Bugfix: Failure to find an `EGLConfig` was reported incorrectly\n - [NSGL] Bugfix: Failure to find a pixel format was reported incorrectly\n\n\n## Contact\n\nThe official website for GLFW is [glfw.org](http://www.glfw.org/).  There you\ncan find the latest version of GLFW, as well as news, documentation and other\ninformation about the project.\n\nIf you have questions related to the use of GLFW, we have a\n[support forum](https://sourceforge.net/p/glfw/discussion/247562/), and the IRC\nchannel `#glfw` on [Freenode](http://freenode.net/).\n\nIf you have a bug to report, a patch to submit or a feature you'd like to\nrequest, please file it in the\n[issue tracker](https://github.com/glfw/glfw/issues) on GitHub.\n\nFinally, if you're interested in helping out with the development of GLFW or\nporting it to your favorite platform, join us on GitHub or IRC.\n\n\n## Acknowledgements\n\nGLFW exists because people around the world donated their time and lent their\nskills.\n\n - Bobyshev Alexander\n - artblanc\n - arturo\n - Matt Arsenault\n - Keith Bauer\n - John Bartholomew\n - Niklas Behrens\n - Niklas Bergstr\u00f6m\n - Doug Binks\n - blanco\n - Martin Capitanio\n - Chi-kwan Chan\n - Lambert Clara\n - Andrew Corrigan\n - Noel Cower\n - Jarrod Davis\n - Olivier Delannoy\n - Paul R. Deppe\n - Michael Dickens\n - Jonathan Dummer\n - Ralph Eastwood\n - Siavash Eliasi\n - Michael Fogleman\n - Gerald Franz\n - GeO4d\n - Marcus Geelnard\n - Eloi Mar\u00edn Gratac\u00f3s\n - Stefan Gustavson\n - Sylvain Hellegouarch\n - Matthew Henry\n - heromyth\n - Lucas Hinderberger\n - Paul Holden\n - Aaron Jacobs\n - Toni Jovanoski\n - Arseny Kapoulkine\n - Osman Keskin\n - Cameron King\n - Peter Knut\n - Eric Larson\n - Robin Leffmann\n - Glenn Lewis\n - Shane Liesegang\n - Eyal Lotem\n - \u0414\u043c\u0438\u0442\u0440\u0438 \u041c\u0430\u043b\u044b\u0448\u0435\u0432\n - Martins Mozeiko\n - Tristam MacDonald\n - Hans Mackowiak\n - Kyle McDonald\n - David Medlock\n - Bryce Mehring\n - Jonathan Mercier\n - Marcel Metz\n - Jonathan Miller\n - Kenneth Miller\n - Bruce Mitchener\n - Jack Moffitt\n - Jeff Molofee\n - Jon Morton\n - Pierre Moulon\n - Julian M\u00f8ller\n - Kamil Nowakowski\n - Ozzy\n - Andri P\u00e1lsson\n - Peoro\n - Braden Pellett\n - Arturo J. P\u00e9rez\n - Emmanuel Gil Peyrot\n - Cyril Pichard\n - Pieroman\n - Jorge Rodriguez\n - Ed Ropple\n - Aleksey Rybalkin\n - Riku Salminen\n - Brandon Schaefer\n - Sebastian Schuberth\n - Matt Sealey\n - SephiRok\n - Steve Sexton\n - Systemcluster\n - Dmitri Shuralyov\n - Daniel Skorupski\n - Bradley Smith\n - Julian Squires\n - Johannes Stein\n - Justin Stoecker\n - Elviss Strazdins\n - Nathan Sweet\n - TTK-Bandit\n - Sergey Tikhomirov\n - A. Tombs\n - Samuli Tuomola\n - urraka\n - Jari Vetoniemi\n - Ricardo Vieira\n - Simon Voordouw\n - Torsten Walluhn\n - Patrick Walton\n - Jay Weisskopf\n - Frank Wille\n - yuriks\n - Santi Zupancic\n - Jonas \u00c5dahl\n - Lasse \u00d6\u00f6rni\n - All the unmentioned and anonymous contributors in the GLFW community, for bug\n   reports, patches, feedback, testing and encouragement\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-glfw-3.1.2-x6c6y6bid7i3cuhrzcx25eivkoimm5dy/spack-src/src/egl_context.c": "//========================================================================\n// GLFW 3.1 EGL - www.glfw.org\n//------------------------------------------------------------------------\n// Copyright (c) 2002-2006 Marcus Geelnard\n// Copyright (c) 2006-2010 Camilla Berglund <elmindreda@elmindreda.org>\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would\n//    be appreciated but is not required.\n//\n// 2. Altered source versions must be plainly marked as such, and must not\n//    be misrepresented as being the original software.\n//\n// 3. This notice may not be removed or altered from any source\n//    distribution.\n//\n//========================================================================\n\n#include \"internal.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\n\n// Return a description of the specified EGL error\n//\nstatic const char* getErrorString(EGLint error)\n{\n    switch (error)\n    {\n        case EGL_SUCCESS:\n            return \"Success\";\n        case EGL_NOT_INITIALIZED:\n            return \"EGL is not or could not be initialized\";\n        case EGL_BAD_ACCESS:\n            return \"EGL cannot access a requested resource\";\n        case EGL_BAD_ALLOC:\n            return \"EGL failed to allocate resources for the requested operation\";\n        case EGL_BAD_ATTRIBUTE:\n            return \"An unrecognized attribute or attribute value was passed in the attribute list\";\n        case EGL_BAD_CONTEXT:\n            return \"An EGLContext argument does not name a valid EGL rendering context\";\n        case EGL_BAD_CONFIG:\n            return \"An EGLConfig argument does not name a valid EGL frame buffer configuration\";\n        case EGL_BAD_CURRENT_SURFACE:\n            return \"The current surface of the calling thread is a window, pixel buffer or pixmap that is no longer valid\";\n        case EGL_BAD_DISPLAY:\n            return \"An EGLDisplay argument does not name a valid EGL display connection\";\n        case EGL_BAD_SURFACE:\n            return \"An EGLSurface argument does not name a valid surface configured for GL rendering\";\n        case EGL_BAD_MATCH:\n            return \"Arguments are inconsistent\";\n        case EGL_BAD_PARAMETER:\n            return \"One or more argument values are invalid\";\n        case EGL_BAD_NATIVE_PIXMAP:\n            return \"A NativePixmapType argument does not refer to a valid native pixmap\";\n        case EGL_BAD_NATIVE_WINDOW:\n            return \"A NativeWindowType argument does not refer to a valid native window\";\n        case EGL_CONTEXT_LOST:\n            return \"The application must destroy all contexts and reinitialise\";\n    }\n\n    return \"UNKNOWN EGL ERROR\";\n}\n\n// Returns the specified attribute of the specified EGLConfig\n//\nstatic int getConfigAttrib(EGLConfig config, int attrib)\n{\n    int value;\n    _glfw_eglGetConfigAttrib(_glfw.egl.display, config, attrib, &value);\n    return value;\n}\n\n// Return a list of available and usable framebuffer configs\n//\nstatic GLboolean chooseFBConfigs(const _GLFWctxconfig* ctxconfig,\n                                 const _GLFWfbconfig* desired,\n                                 EGLConfig* result)\n{\n    EGLConfig* nativeConfigs;\n    _GLFWfbconfig* usableConfigs;\n    const _GLFWfbconfig* closest;\n    int i, nativeCount, usableCount;\n\n    _glfw_eglGetConfigs(_glfw.egl.display, NULL, 0, &nativeCount);\n    if (!nativeCount)\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE, \"EGL: No EGLConfigs returned\");\n        return GL_FALSE;\n    }\n\n    nativeConfigs = calloc(nativeCount, sizeof(EGLConfig));\n    _glfw_eglGetConfigs(_glfw.egl.display, nativeConfigs,\n                        nativeCount, &nativeCount);\n\n    usableConfigs = calloc(nativeCount, sizeof(_GLFWfbconfig));\n    usableCount = 0;\n\n    for (i = 0;  i < nativeCount;  i++)\n    {\n        const EGLConfig n = nativeConfigs[i];\n        _GLFWfbconfig* u = usableConfigs + usableCount;\n\n#if defined(_GLFW_X11)\n        // Only consider EGLConfigs with associated visuals\n        if (!getConfigAttrib(n, EGL_NATIVE_VISUAL_ID))\n            continue;\n#endif // _GLFW_X11\n\n        // Only consider RGB(A) EGLConfigs\n        if (!(getConfigAttrib(n, EGL_COLOR_BUFFER_TYPE) & EGL_RGB_BUFFER))\n            continue;\n\n        // Only consider window EGLConfigs\n        if (!(getConfigAttrib(n, EGL_SURFACE_TYPE) & EGL_WINDOW_BIT))\n            continue;\n\n        if (ctxconfig->api == GLFW_OPENGL_ES_API)\n        {\n            if (ctxconfig->major == 1)\n            {\n                if (!(getConfigAttrib(n, EGL_RENDERABLE_TYPE) & EGL_OPENGL_ES_BIT))\n                    continue;\n            }\n            else\n            {\n                if (!(getConfigAttrib(n, EGL_RENDERABLE_TYPE) & EGL_OPENGL_ES2_BIT))\n                    continue;\n            }\n        }\n        else if (ctxconfig->api == GLFW_OPENGL_API)\n        {\n            if (!(getConfigAttrib(n, EGL_RENDERABLE_TYPE) & EGL_OPENGL_BIT))\n                continue;\n        }\n\n        u->redBits = getConfigAttrib(n, EGL_RED_SIZE);\n        u->greenBits = getConfigAttrib(n, EGL_GREEN_SIZE);\n        u->blueBits = getConfigAttrib(n, EGL_BLUE_SIZE);\n\n        u->alphaBits = getConfigAttrib(n, EGL_ALPHA_SIZE);\n        u->depthBits = getConfigAttrib(n, EGL_DEPTH_SIZE);\n        u->stencilBits = getConfigAttrib(n, EGL_STENCIL_SIZE);\n\n        u->samples = getConfigAttrib(n, EGL_SAMPLES);\n        u->doublebuffer = GL_TRUE;\n\n        u->egl = n;\n        usableCount++;\n    }\n\n    closest = _glfwChooseFBConfig(desired, usableConfigs, usableCount);\n    if (closest)\n        *result = closest->egl;\n\n    free(nativeConfigs);\n    free(usableConfigs);\n\n    return closest ? GL_TRUE : GL_FALSE;\n}\n\n\n//////////////////////////////////////////////////////////////////////////\n//////                       GLFW internal API                      //////\n//////////////////////////////////////////////////////////////////////////\n\n// Initialize EGL\n//\nint _glfwInitContextAPI(void)\n{\n    int i;\n    const char* sonames[] =\n    {\n#if defined(_GLFW_WIN32)\n        \"libEGL.dll\",\n        \"EGL.dll\",\n#elif defined(_GLFW_COCOA)\n        \"libEGL.dylib\",\n#else\n        \"libEGL.so.1\",\n#endif\n        NULL\n    };\n\n    if (!_glfwCreateContextTLS())\n        return GL_FALSE;\n\n    for (i = 0;  sonames[i];  i++)\n    {\n        _glfw.egl.handle = _glfw_dlopen(sonames[i]);\n        if (_glfw.egl.handle)\n            break;\n    }\n\n    if (!_glfw.egl.handle)\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE, \"EGL: Failed to load EGL\");\n        return GL_FALSE;\n    }\n\n    _glfw.egl.GetConfigAttrib =\n        _glfw_dlsym(_glfw.egl.handle, \"eglGetConfigAttrib\");\n    _glfw.egl.GetConfigs =\n        _glfw_dlsym(_glfw.egl.handle, \"eglGetConfigs\");\n    _glfw.egl.GetDisplay =\n        _glfw_dlsym(_glfw.egl.handle, \"eglGetDisplay\");\n    _glfw.egl.GetError =\n        _glfw_dlsym(_glfw.egl.handle, \"eglGetError\");\n    _glfw.egl.Initialize =\n        _glfw_dlsym(_glfw.egl.handle, \"eglInitialize\");\n    _glfw.egl.Terminate =\n        _glfw_dlsym(_glfw.egl.handle, \"eglTerminate\");\n    _glfw.egl.BindAPI =\n        _glfw_dlsym(_glfw.egl.handle, \"eglBindAPI\");\n    _glfw.egl.CreateContext =\n        _glfw_dlsym(_glfw.egl.handle, \"eglCreateContext\");\n    _glfw.egl.DestroySurface =\n        _glfw_dlsym(_glfw.egl.handle, \"eglDestroySurface\");\n    _glfw.egl.DestroyContext =\n        _glfw_dlsym(_glfw.egl.handle, \"eglDestroyContext\");\n    _glfw.egl.CreateWindowSurface =\n        _glfw_dlsym(_glfw.egl.handle, \"eglCreateWindowSurface\");\n    _glfw.egl.MakeCurrent =\n        _glfw_dlsym(_glfw.egl.handle, \"eglMakeCurrent\");\n    _glfw.egl.SwapBuffers =\n        _glfw_dlsym(_glfw.egl.handle, \"eglSwapBuffers\");\n    _glfw.egl.SwapInterval =\n        _glfw_dlsym(_glfw.egl.handle, \"eglSwapInterval\");\n    _glfw.egl.QueryString =\n        _glfw_dlsym(_glfw.egl.handle, \"eglQueryString\");\n    _glfw.egl.GetProcAddress =\n        _glfw_dlsym(_glfw.egl.handle, \"eglGetProcAddress\");\n\n    _glfw.egl.display =\n        _glfw_eglGetDisplay((EGLNativeDisplayType)_GLFW_EGL_NATIVE_DISPLAY);\n    if (_glfw.egl.display == EGL_NO_DISPLAY)\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE,\n                        \"EGL: Failed to get EGL display: %s\",\n                        getErrorString(_glfw_eglGetError()));\n        return GL_FALSE;\n    }\n\n    if (!_glfw_eglInitialize(_glfw.egl.display,\n                             &_glfw.egl.major,\n                             &_glfw.egl.minor))\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE,\n                        \"EGL: Failed to initialize EGL: %s\",\n                        getErrorString(_glfw_eglGetError()));\n        return GL_FALSE;\n    }\n\n    _glfw.egl.KHR_create_context =\n        _glfwPlatformExtensionSupported(\"EGL_KHR_create_context\");\n\n    return GL_TRUE;\n}\n\n// Terminate EGL\n//\nvoid _glfwTerminateContextAPI(void)\n{\n    if (_glfw_eglTerminate)\n        _glfw_eglTerminate(_glfw.egl.display);\n\n    if (_glfw.egl.handle)\n    {\n        _glfw_dlclose(_glfw.egl.handle);\n        _glfw.egl.handle = NULL;\n    }\n\n    _glfwDestroyContextTLS();\n}\n\n#define setEGLattrib(attribName, attribValue) \\\n{ \\\n    attribs[index++] = attribName; \\\n    attribs[index++] = attribValue; \\\n    assert((size_t) index < sizeof(attribs) / sizeof(attribs[0])); \\\n}\n\n// Create the OpenGL or OpenGL ES context\n//\nint _glfwCreateContext(_GLFWwindow* window,\n                       const _GLFWctxconfig* ctxconfig,\n                       const _GLFWfbconfig* fbconfig)\n{\n    int attribs[40];\n    EGLConfig config;\n    EGLContext share = NULL;\n\n    if (ctxconfig->share)\n        share = ctxconfig->share->egl.context;\n\n    if (!chooseFBConfigs(ctxconfig, fbconfig, &config))\n    {\n        _glfwInputError(GLFW_FORMAT_UNAVAILABLE,\n                        \"EGL: Failed to find a suitable EGLConfig\");\n        return GL_FALSE;\n    }\n\n#if defined(_GLFW_X11)\n    // Retrieve the visual corresponding to the chosen EGL config\n    {\n        EGLint count = 0;\n        int mask;\n        EGLint redBits, greenBits, blueBits, alphaBits, visualID = 0;\n        XVisualInfo info;\n\n        _glfw_eglGetConfigAttrib(_glfw.egl.display, config,\n                                 EGL_NATIVE_VISUAL_ID, &visualID);\n\n        info.screen = _glfw.x11.screen;\n        mask = VisualScreenMask;\n\n        if (visualID)\n        {\n            // The X window visual must match the EGL config\n            info.visualid = visualID;\n            mask |= VisualIDMask;\n        }\n        else\n        {\n            // Some EGL drivers do not implement the EGL_NATIVE_VISUAL_ID\n            // attribute, so attempt to find the closest match\n\n            _glfw_eglGetConfigAttrib(_glfw.egl.display, config,\n                                     EGL_RED_SIZE, &redBits);\n            _glfw_eglGetConfigAttrib(_glfw.egl.display, config,\n                                     EGL_GREEN_SIZE, &greenBits);\n            _glfw_eglGetConfigAttrib(_glfw.egl.display, config,\n                                     EGL_BLUE_SIZE, &blueBits);\n            _glfw_eglGetConfigAttrib(_glfw.egl.display, config,\n                                     EGL_ALPHA_SIZE, &alphaBits);\n\n            info.depth = redBits + greenBits + blueBits + alphaBits;\n            mask |= VisualDepthMask;\n        }\n\n        window->egl.visual = XGetVisualInfo(_glfw.x11.display,\n                                            mask, &info, &count);\n        if (!window->egl.visual)\n        {\n            _glfwInputError(GLFW_PLATFORM_ERROR,\n                            \"EGL: Failed to retrieve visual for EGLConfig\");\n            return GL_FALSE;\n        }\n    }\n#endif // _GLFW_X11\n\n    if (ctxconfig->api == GLFW_OPENGL_ES_API)\n    {\n        if (!_glfw_eglBindAPI(EGL_OPENGL_ES_API))\n        {\n            _glfwInputError(GLFW_API_UNAVAILABLE,\n                            \"EGL: Failed to bind OpenGL ES: %s\",\n                            getErrorString(_glfw_eglGetError()));\n            return GL_FALSE;\n        }\n    }\n    else\n    {\n        if (!_glfw_eglBindAPI(EGL_OPENGL_API))\n        {\n            _glfwInputError(GLFW_API_UNAVAILABLE,\n                            \"EGL: Failed to bind OpenGL: %s\",\n                            getErrorString(_glfw_eglGetError()));\n            return GL_FALSE;\n        }\n    }\n\n    if (_glfw.egl.KHR_create_context)\n    {\n        int index = 0, mask = 0, flags = 0;\n\n        if (ctxconfig->api == GLFW_OPENGL_API)\n        {\n            if (ctxconfig->forward)\n                flags |= EGL_CONTEXT_OPENGL_FORWARD_COMPATIBLE_BIT_KHR;\n\n            if (ctxconfig->profile == GLFW_OPENGL_CORE_PROFILE)\n                mask |= EGL_CONTEXT_OPENGL_CORE_PROFILE_BIT_KHR;\n            else if (ctxconfig->profile == GLFW_OPENGL_COMPAT_PROFILE)\n                mask |= EGL_CONTEXT_OPENGL_COMPATIBILITY_PROFILE_BIT_KHR;\n        }\n\n        if (ctxconfig->debug)\n            flags |= EGL_CONTEXT_OPENGL_DEBUG_BIT_KHR;\n\n        if (ctxconfig->robustness)\n        {\n            if (ctxconfig->robustness == GLFW_NO_RESET_NOTIFICATION)\n            {\n                setEGLattrib(EGL_CONTEXT_OPENGL_RESET_NOTIFICATION_STRATEGY_KHR,\n                             EGL_NO_RESET_NOTIFICATION_KHR);\n            }\n            else if (ctxconfig->robustness == GLFW_LOSE_CONTEXT_ON_RESET)\n            {\n                setEGLattrib(EGL_CONTEXT_OPENGL_RESET_NOTIFICATION_STRATEGY_KHR,\n                             EGL_LOSE_CONTEXT_ON_RESET_KHR);\n            }\n\n            flags |= EGL_CONTEXT_OPENGL_ROBUST_ACCESS_BIT_KHR;\n        }\n\n        if (ctxconfig->major != 1 || ctxconfig->minor != 0)\n        {\n            setEGLattrib(EGL_CONTEXT_MAJOR_VERSION_KHR, ctxconfig->major);\n            setEGLattrib(EGL_CONTEXT_MINOR_VERSION_KHR, ctxconfig->minor);\n        }\n\n        if (mask)\n            setEGLattrib(EGL_CONTEXT_OPENGL_PROFILE_MASK_KHR, mask);\n\n        if (flags)\n            setEGLattrib(EGL_CONTEXT_FLAGS_KHR, flags);\n\n        setEGLattrib(EGL_NONE, EGL_NONE);\n    }\n    else\n    {\n        int index = 0;\n\n        if (ctxconfig->api == GLFW_OPENGL_ES_API)\n            setEGLattrib(EGL_CONTEXT_CLIENT_VERSION, ctxconfig->major);\n\n        setEGLattrib(EGL_NONE, EGL_NONE);\n    }\n\n    // Context release behaviors (GL_KHR_context_flush_control) are not yet\n    // supported on EGL but are not a hard constraint, so ignore and continue\n\n    window->egl.context = _glfw_eglCreateContext(_glfw.egl.display,\n                                                 config, share, attribs);\n\n    if (window->egl.context == EGL_NO_CONTEXT)\n    {\n        _glfwInputError(GLFW_VERSION_UNAVAILABLE,\n                        \"EGL: Failed to create context: %s\",\n                        getErrorString(_glfw_eglGetError()));\n        return GL_FALSE;\n    }\n\n    window->egl.config = config;\n\n    // Load the appropriate client library\n    {\n        int i;\n        const char** sonames;\n        const char* es1sonames[] =\n        {\n#if defined(_GLFW_WIN32)\n            \"GLESv1_CM.dll\",\n            \"libGLES_CM.dll\",\n#elif defined(_GLFW_COCOA)\n            \"libGLESv1_CM.dylib\",\n#else\n            \"libGLESv1_CM.so.1\",\n            \"libGLES_CM.so.1\",\n#endif\n            NULL\n        };\n        const char* es2sonames[] =\n        {\n#if defined(_GLFW_WIN32)\n            \"GLESv2.dll\",\n            \"libGLESv2.dll\",\n#elif defined(_GLFW_COCOA)\n            \"libGLESv2.dylib\",\n#else\n            \"libGLESv2.so.2\",\n#endif\n            NULL\n        };\n        const char* glsonames[] =\n        {\n#if defined(_GLFW_WIN32)\n#elif defined(_GLFW_COCOA)\n#else\n            \"libGL.so.1\",\n#endif\n            NULL\n        };\n\n        if (ctxconfig->api == GLFW_OPENGL_ES_API)\n        {\n            if (ctxconfig->major == 1)\n                sonames = es1sonames;\n            else\n                sonames = es2sonames;\n        }\n        else\n            sonames = glsonames;\n\n        for (i = 0;  sonames[i];  i++)\n        {\n            window->egl.client = _glfw_dlopen(sonames[i]);\n            if (window->egl.client)\n                break;\n        }\n\n        if (!window->egl.client)\n        {\n            _glfwInputError(GLFW_API_UNAVAILABLE,\n                            \"EGL: Failed to load client library\");\n            return GL_FALSE;\n        }\n    }\n\n    return GL_TRUE;\n}\n\n#undef setEGLattrib\n\n// Destroy the OpenGL context\n//\nvoid _glfwDestroyContext(_GLFWwindow* window)\n{\n#if defined(_GLFW_X11)\n    // NOTE: Do not unload libGL.so.1 while the X11 display is still open,\n    //       as it will make XCloseDisplay segfault\n    if (window->context.api != GLFW_OPENGL_API)\n#endif // _GLFW_X11\n    {\n        if (window->egl.client)\n        {\n            _glfw_dlclose(window->egl.client);\n            window->egl.client = NULL;\n        }\n    }\n\n#if defined(_GLFW_X11)\n    if (window->egl.visual)\n    {\n       XFree(window->egl.visual);\n       window->egl.visual = NULL;\n    }\n#endif // _GLFW_X11\n\n    if (window->egl.surface)\n    {\n        _glfw_eglDestroySurface(_glfw.egl.display, window->egl.surface);\n        window->egl.surface = EGL_NO_SURFACE;\n    }\n\n    if (window->egl.context)\n    {\n        _glfw_eglDestroyContext(_glfw.egl.display, window->egl.context);\n        window->egl.context = EGL_NO_CONTEXT;\n    }\n}\n\n// Analyzes the specified context for possible recreation\n//\nint _glfwAnalyzeContext(const _GLFWwindow* window,\n                        const _GLFWctxconfig* ctxconfig,\n                        const _GLFWfbconfig* fbconfig)\n{\n#if defined(_GLFW_WIN32)\n    return _GLFW_RECREATION_NOT_NEEDED;\n#else\n    return 0;\n#endif\n}\n\n\n//////////////////////////////////////////////////////////////////////////\n//////                       GLFW platform API                      //////\n//////////////////////////////////////////////////////////////////////////\n\nvoid _glfwPlatformMakeContextCurrent(_GLFWwindow* window)\n{\n    if (window)\n    {\n        if (window->egl.surface == EGL_NO_SURFACE)\n        {\n            window->egl.surface =\n                _glfw_eglCreateWindowSurface(_glfw.egl.display,\n                                             window->egl.config,\n                                             (EGLNativeWindowType)_GLFW_EGL_NATIVE_WINDOW,\n                                             NULL);\n            if (window->egl.surface == EGL_NO_SURFACE)\n            {\n                _glfwInputError(GLFW_PLATFORM_ERROR,\n                                \"EGL: Failed to create window surface: %s\",\n                                getErrorString(_glfw_eglGetError()));\n            }\n        }\n\n        _glfw_eglMakeCurrent(_glfw.egl.display,\n                             window->egl.surface,\n                             window->egl.surface,\n                             window->egl.context);\n    }\n    else\n    {\n        _glfw_eglMakeCurrent(_glfw.egl.display,\n                             EGL_NO_SURFACE,\n                             EGL_NO_SURFACE,\n                             EGL_NO_CONTEXT);\n    }\n\n    _glfwSetContextTLS(window);\n}\n\nvoid _glfwPlatformSwapBuffers(_GLFWwindow* window)\n{\n    _glfw_eglSwapBuffers(_glfw.egl.display, window->egl.surface);\n}\n\nvoid _glfwPlatformSwapInterval(int interval)\n{\n    _glfw_eglSwapInterval(_glfw.egl.display, interval);\n}\n\nint _glfwPlatformExtensionSupported(const char* extension)\n{\n    const char* extensions = _glfw_eglQueryString(_glfw.egl.display,\n                                                  EGL_EXTENSIONS);\n    if (extensions)\n    {\n        if (_glfwStringInExtensionString(extension, extensions))\n            return GL_TRUE;\n    }\n\n    return GL_FALSE;\n}\n\nGLFWglproc _glfwPlatformGetProcAddress(const char* procname)\n{\n    _GLFWwindow* window = _glfwPlatformGetCurrentContext();\n\n    if (window->egl.client)\n    {\n        GLFWglproc proc = (GLFWglproc) _glfw_dlsym(window->egl.client, procname);\n        if (proc)\n            return proc;\n    }\n\n    return _glfw_eglGetProcAddress(procname);\n}\n\n\n//////////////////////////////////////////////////////////////////////////\n//////                        GLFW native API                       //////\n//////////////////////////////////////////////////////////////////////////\n\nGLFWAPI EGLDisplay glfwGetEGLDisplay(void)\n{\n    _GLFW_REQUIRE_INIT_OR_RETURN(EGL_NO_DISPLAY);\n    return _glfw.egl.display;\n}\n\nGLFWAPI EGLContext glfwGetEGLContext(GLFWwindow* handle)\n{\n    _GLFWwindow* window = (_GLFWwindow*) handle;\n    _GLFW_REQUIRE_INIT_OR_RETURN(EGL_NO_CONTEXT);\n    return window->egl.context;\n}\n\nGLFWAPI EGLSurface glfwGetEGLSurface(GLFWwindow* handle)\n{\n    _GLFWwindow* window = (_GLFWwindow*) handle;\n    _GLFW_REQUIRE_INIT_OR_RETURN(EGL_NO_SURFACE);\n    return window->egl.surface;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-glfw-3.1.2-x6c6y6bid7i3cuhrzcx25eivkoimm5dy/spack-src/src/glx_context.c": "//========================================================================\n// GLFW 3.1 GLX - www.glfw.org\n//------------------------------------------------------------------------\n// Copyright (c) 2002-2006 Marcus Geelnard\n// Copyright (c) 2006-2010 Camilla Berglund <elmindreda@elmindreda.org>\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would\n//    be appreciated but is not required.\n//\n// 2. Altered source versions must be plainly marked as such, and must not\n//    be misrepresented as being the original software.\n//\n// 3. This notice may not be removed or altered from any source\n//    distribution.\n//\n//========================================================================\n\n#include \"internal.h\"\n\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <dlfcn.h>\n\n#ifndef GLXBadProfileARB\n #define GLXBadProfileARB 13\n#endif\n\n\n// Returns the specified attribute of the specified GLXFBConfig\n//\nstatic int getFBConfigAttrib(GLXFBConfig fbconfig, int attrib)\n{\n    int value;\n    _glfw_glXGetFBConfigAttrib(_glfw.x11.display, fbconfig, attrib, &value);\n    return value;\n}\n\n// Return a list of available and usable framebuffer configs\n//\nstatic GLboolean chooseFBConfig(const _GLFWfbconfig* desired, GLXFBConfig* result)\n{\n    GLXFBConfig* nativeConfigs;\n    _GLFWfbconfig* usableConfigs;\n    const _GLFWfbconfig* closest;\n    int i, nativeCount, usableCount;\n    const char* vendor;\n    GLboolean trustWindowBit = GL_TRUE;\n\n    // HACK: This is a (hopefully temporary) workaround for Chromium\n    //       (VirtualBox GL) not setting the window bit on any GLXFBConfigs\n    vendor = _glfw_glXGetClientString(_glfw.x11.display, GLX_VENDOR);\n    if (strcmp(vendor, \"Chromium\") == 0)\n        trustWindowBit = GL_FALSE;\n\n    nativeConfigs = _glfw_glXGetFBConfigs(_glfw.x11.display, _glfw.x11.screen,\n                                          &nativeCount);\n    if (!nativeCount)\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE, \"GLX: No GLXFBConfigs returned\");\n        return GL_FALSE;\n    }\n\n    usableConfigs = calloc(nativeCount, sizeof(_GLFWfbconfig));\n    usableCount = 0;\n\n    for (i = 0;  i < nativeCount;  i++)\n    {\n        const GLXFBConfig n = nativeConfigs[i];\n        _GLFWfbconfig* u = usableConfigs + usableCount;\n\n        // Only consider GLXFBConfigs with associated visuals\n        if (!getFBConfigAttrib(n, GLX_VISUAL_ID))\n            continue;\n\n        // Only consider RGBA GLXFBConfigs\n        if (!(getFBConfigAttrib(n, GLX_RENDER_TYPE) & GLX_RGBA_BIT))\n            continue;\n\n        // Only consider window GLXFBConfigs\n        if (!(getFBConfigAttrib(n, GLX_DRAWABLE_TYPE) & GLX_WINDOW_BIT))\n        {\n            if (trustWindowBit)\n                continue;\n        }\n\n        u->redBits = getFBConfigAttrib(n, GLX_RED_SIZE);\n        u->greenBits = getFBConfigAttrib(n, GLX_GREEN_SIZE);\n        u->blueBits = getFBConfigAttrib(n, GLX_BLUE_SIZE);\n\n        u->alphaBits = getFBConfigAttrib(n, GLX_ALPHA_SIZE);\n        u->depthBits = getFBConfigAttrib(n, GLX_DEPTH_SIZE);\n        u->stencilBits = getFBConfigAttrib(n, GLX_STENCIL_SIZE);\n\n        u->accumRedBits = getFBConfigAttrib(n, GLX_ACCUM_RED_SIZE);\n        u->accumGreenBits = getFBConfigAttrib(n, GLX_ACCUM_GREEN_SIZE);\n        u->accumBlueBits = getFBConfigAttrib(n, GLX_ACCUM_BLUE_SIZE);\n        u->accumAlphaBits = getFBConfigAttrib(n, GLX_ACCUM_ALPHA_SIZE);\n\n        u->auxBuffers = getFBConfigAttrib(n, GLX_AUX_BUFFERS);\n\n        if (getFBConfigAttrib(n, GLX_STEREO))\n            u->stereo = GL_TRUE;\n        if (getFBConfigAttrib(n, GLX_DOUBLEBUFFER))\n            u->doublebuffer = GL_TRUE;\n\n        if (_glfw.glx.ARB_multisample)\n            u->samples = getFBConfigAttrib(n, GLX_SAMPLES);\n\n        if (_glfw.glx.ARB_framebuffer_sRGB || _glfw.glx.EXT_framebuffer_sRGB)\n            u->sRGB = getFBConfigAttrib(n, GLX_FRAMEBUFFER_SRGB_CAPABLE_ARB);\n\n        u->glx = n;\n        usableCount++;\n    }\n\n    closest = _glfwChooseFBConfig(desired, usableConfigs, usableCount);\n    if (closest)\n        *result = closest->glx;\n\n    XFree(nativeConfigs);\n    free(usableConfigs);\n\n    return closest ? GL_TRUE : GL_FALSE;\n}\n\n// Create the OpenGL context using legacy API\n//\nstatic GLXContext createLegacyContext(_GLFWwindow* window,\n                                      GLXFBConfig fbconfig,\n                                      GLXContext share)\n{\n    return _glfw_glXCreateNewContext(_glfw.x11.display,\n                                     fbconfig,\n                                     GLX_RGBA_TYPE,\n                                     share,\n                                     True);\n}\n\n\n//////////////////////////////////////////////////////////////////////////\n//////                       GLFW internal API                      //////\n//////////////////////////////////////////////////////////////////////////\n\n// Initialize GLX\n//\nint _glfwInitContextAPI(void)\n{\n#if defined(__CYGWIN__)\n    const char* soname = \"libGL-1.so\";\n#else\n    const char* soname = \"libGL.so.1\";\n#endif\n\n    if (!_glfwCreateContextTLS())\n        return GL_FALSE;\n\n    _glfw.glx.handle = dlopen(soname, RTLD_LAZY | RTLD_GLOBAL);\n    if (!_glfw.glx.handle)\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE, \"GLX: %s\", dlerror());\n        return GL_FALSE;\n    }\n\n    _glfw.glx.GetFBConfigs =\n        dlsym(_glfw.glx.handle, \"glXGetFBConfigs\");\n    _glfw.glx.GetFBConfigAttrib =\n        dlsym(_glfw.glx.handle, \"glXGetFBConfigAttrib\");\n    _glfw.glx.GetClientString =\n        dlsym(_glfw.glx.handle, \"glXGetClientString\");\n    _glfw.glx.QueryExtension =\n        dlsym(_glfw.glx.handle, \"glXQueryExtension\");\n    _glfw.glx.QueryVersion =\n        dlsym(_glfw.glx.handle, \"glXQueryVersion\");\n    _glfw.glx.DestroyContext =\n        dlsym(_glfw.glx.handle, \"glXDestroyContext\");\n    _glfw.glx.MakeCurrent =\n        dlsym(_glfw.glx.handle, \"glXMakeCurrent\");\n    _glfw.glx.SwapBuffers =\n        dlsym(_glfw.glx.handle, \"glXSwapBuffers\");\n    _glfw.glx.QueryExtensionsString =\n        dlsym(_glfw.glx.handle, \"glXQueryExtensionsString\");\n    _glfw.glx.CreateNewContext =\n        dlsym(_glfw.glx.handle, \"glXCreateNewContext\");\n    _glfw.glx.GetVisualFromFBConfig =\n        dlsym(_glfw.glx.handle, \"glXGetVisualFromFBConfig\");\n    _glfw.glx.GetProcAddress =\n        dlsym(_glfw.glx.handle, \"glXGetProcAddress\");\n    _glfw.glx.GetProcAddressARB =\n        dlsym(_glfw.glx.handle, \"glXGetProcAddressARB\");\n\n    if (!_glfw_glXQueryExtension(_glfw.x11.display,\n                                 &_glfw.glx.errorBase,\n                                 &_glfw.glx.eventBase))\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE, \"GLX: GLX extension not found\");\n        return GL_FALSE;\n    }\n\n    if (!_glfw_glXQueryVersion(_glfw.x11.display,\n                               &_glfw.glx.major,\n                               &_glfw.glx.minor))\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE,\n                        \"GLX: Failed to query GLX version\");\n        return GL_FALSE;\n    }\n\n    if (_glfw.glx.major == 1 && _glfw.glx.minor < 3)\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE,\n                        \"GLX: GLX version 1.3 is required\");\n        return GL_FALSE;\n    }\n\n    if (_glfwPlatformExtensionSupported(\"GLX_EXT_swap_control\"))\n    {\n        _glfw.glx.SwapIntervalEXT = (PFNGLXSWAPINTERVALEXTPROC)\n            _glfwPlatformGetProcAddress(\"glXSwapIntervalEXT\");\n\n        if (_glfw.glx.SwapIntervalEXT)\n            _glfw.glx.EXT_swap_control = GL_TRUE;\n    }\n\n    if (_glfwPlatformExtensionSupported(\"GLX_SGI_swap_control\"))\n    {\n        _glfw.glx.SwapIntervalSGI = (PFNGLXSWAPINTERVALSGIPROC)\n            _glfwPlatformGetProcAddress(\"glXSwapIntervalSGI\");\n\n        if (_glfw.glx.SwapIntervalSGI)\n            _glfw.glx.SGI_swap_control = GL_TRUE;\n    }\n\n    if (_glfwPlatformExtensionSupported(\"GLX_MESA_swap_control\"))\n    {\n        _glfw.glx.SwapIntervalMESA = (PFNGLXSWAPINTERVALMESAPROC)\n            _glfwPlatformGetProcAddress(\"glXSwapIntervalMESA\");\n\n        if (_glfw.glx.SwapIntervalMESA)\n            _glfw.glx.MESA_swap_control = GL_TRUE;\n    }\n\n    if (_glfwPlatformExtensionSupported(\"GLX_ARB_multisample\"))\n        _glfw.glx.ARB_multisample = GL_TRUE;\n\n    if (_glfwPlatformExtensionSupported(\"GLX_ARB_framebuffer_sRGB\"))\n        _glfw.glx.ARB_framebuffer_sRGB = GL_TRUE;\n\n    if (_glfwPlatformExtensionSupported(\"GLX_EXT_framebuffer_sRGB\"))\n        _glfw.glx.EXT_framebuffer_sRGB = GL_TRUE;\n\n    if (_glfwPlatformExtensionSupported(\"GLX_ARB_create_context\"))\n    {\n        _glfw.glx.CreateContextAttribsARB = (PFNGLXCREATECONTEXTATTRIBSARBPROC)\n            _glfwPlatformGetProcAddress(\"glXCreateContextAttribsARB\");\n\n        if (_glfw.glx.CreateContextAttribsARB)\n            _glfw.glx.ARB_create_context = GL_TRUE;\n    }\n\n    if (_glfwPlatformExtensionSupported(\"GLX_ARB_create_context_robustness\"))\n        _glfw.glx.ARB_create_context_robustness = GL_TRUE;\n\n    if (_glfwPlatformExtensionSupported(\"GLX_ARB_create_context_profile\"))\n        _glfw.glx.ARB_create_context_profile = GL_TRUE;\n\n    if (_glfwPlatformExtensionSupported(\"GLX_EXT_create_context_es2_profile\"))\n        _glfw.glx.EXT_create_context_es2_profile = GL_TRUE;\n\n    if (_glfwPlatformExtensionSupported(\"GLX_ARB_context_flush_control\"))\n        _glfw.glx.ARB_context_flush_control = GL_TRUE;\n\n    return GL_TRUE;\n}\n\n// Terminate GLX\n//\nvoid _glfwTerminateContextAPI(void)\n{\n    // NOTE: This function may not call any X11 functions, as it is called after\n    //       XCloseDisplay (see _glfwPlatformTerminate for details)\n\n    if (_glfw.glx.handle)\n    {\n        dlclose(_glfw.glx.handle);\n        _glfw.glx.handle = NULL;\n    }\n\n    _glfwDestroyContextTLS();\n}\n\n#define setGLXattrib(attribName, attribValue) \\\n{ \\\n    attribs[index++] = attribName; \\\n    attribs[index++] = attribValue; \\\n    assert((size_t) index < sizeof(attribs) / sizeof(attribs[0])); \\\n}\n\n// Create the OpenGL or OpenGL ES context\n//\nint _glfwCreateContext(_GLFWwindow* window,\n                       const _GLFWctxconfig* ctxconfig,\n                       const _GLFWfbconfig* fbconfig)\n{\n    int attribs[40];\n    GLXFBConfig native = NULL;\n    GLXContext share = NULL;\n\n    if (ctxconfig->share)\n        share = ctxconfig->share->glx.context;\n\n    if (!chooseFBConfig(fbconfig, &native))\n    {\n        _glfwInputError(GLFW_FORMAT_UNAVAILABLE,\n                        \"GLX: Failed to find a suitable GLXFBConfig\");\n        return GL_FALSE;\n    }\n\n    window->glx.visual = _glfw_glXGetVisualFromFBConfig(_glfw.x11.display,\n                                                        native);\n    if (!window->glx.visual)\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"GLX: Failed to retrieve visual for GLXFBConfig\");\n        return GL_FALSE;\n    }\n\n    if (ctxconfig->api == GLFW_OPENGL_ES_API)\n    {\n        if (!_glfw.glx.ARB_create_context ||\n            !_glfw.glx.ARB_create_context_profile ||\n            !_glfw.glx.EXT_create_context_es2_profile)\n        {\n            _glfwInputError(GLFW_API_UNAVAILABLE,\n                            \"GLX: OpenGL ES requested but GLX_EXT_create_context_es2_profile is unavailable\");\n            return GL_FALSE;\n        }\n    }\n\n    if (ctxconfig->forward)\n    {\n        if (!_glfw.glx.ARB_create_context)\n        {\n            _glfwInputError(GLFW_VERSION_UNAVAILABLE,\n                            \"GLX: Forward compatibility requested but GLX_ARB_create_context_profile is unavailable\");\n            return GL_FALSE;\n        }\n    }\n\n    if (ctxconfig->profile)\n    {\n        if (!_glfw.glx.ARB_create_context ||\n            !_glfw.glx.ARB_create_context_profile)\n        {\n            _glfwInputError(GLFW_VERSION_UNAVAILABLE,\n                            \"GLX: An OpenGL profile requested but GLX_ARB_create_context_profile is unavailable\");\n            return GL_FALSE;\n        }\n    }\n\n    _glfwGrabXErrorHandler();\n\n    if (_glfw.glx.ARB_create_context)\n    {\n        int index = 0, mask = 0, flags = 0;\n\n        if (ctxconfig->api == GLFW_OPENGL_API)\n        {\n            if (ctxconfig->forward)\n                flags |= GLX_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB;\n\n            if (ctxconfig->profile == GLFW_OPENGL_CORE_PROFILE)\n                mask |= GLX_CONTEXT_CORE_PROFILE_BIT_ARB;\n            else if (ctxconfig->profile == GLFW_OPENGL_COMPAT_PROFILE)\n                mask |= GLX_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB;\n        }\n        else\n            mask |= GLX_CONTEXT_ES2_PROFILE_BIT_EXT;\n\n        if (ctxconfig->debug)\n            flags |= GLX_CONTEXT_DEBUG_BIT_ARB;\n\n        if (ctxconfig->robustness)\n        {\n            if (_glfw.glx.ARB_create_context_robustness)\n            {\n                if (ctxconfig->robustness == GLFW_NO_RESET_NOTIFICATION)\n                {\n                    setGLXattrib(GLX_CONTEXT_RESET_NOTIFICATION_STRATEGY_ARB,\n                                 GLX_NO_RESET_NOTIFICATION_ARB);\n                }\n                else if (ctxconfig->robustness == GLFW_LOSE_CONTEXT_ON_RESET)\n                {\n                    setGLXattrib(GLX_CONTEXT_RESET_NOTIFICATION_STRATEGY_ARB,\n                                 GLX_LOSE_CONTEXT_ON_RESET_ARB);\n                }\n\n                flags |= GLX_CONTEXT_ROBUST_ACCESS_BIT_ARB;\n            }\n        }\n\n        if (ctxconfig->release)\n        {\n            if (_glfw.glx.ARB_context_flush_control)\n            {\n                if (ctxconfig->release == GLFW_RELEASE_BEHAVIOR_NONE)\n                {\n                    setGLXattrib(GLX_CONTEXT_RELEASE_BEHAVIOR_ARB,\n                                 GLX_CONTEXT_RELEASE_BEHAVIOR_NONE_ARB);\n                }\n                else if (ctxconfig->release == GLFW_RELEASE_BEHAVIOR_FLUSH)\n                {\n                    setGLXattrib(GLX_CONTEXT_RELEASE_BEHAVIOR_ARB,\n                                 GLX_CONTEXT_RELEASE_BEHAVIOR_FLUSH_ARB);\n                }\n            }\n        }\n\n        // NOTE: Only request an explicitly versioned context when necessary, as\n        //       explicitly requesting version 1.0 does not always return the\n        //       highest version supported by the driver\n        if (ctxconfig->major != 1 || ctxconfig->minor != 0)\n        {\n            setGLXattrib(GLX_CONTEXT_MAJOR_VERSION_ARB, ctxconfig->major);\n            setGLXattrib(GLX_CONTEXT_MINOR_VERSION_ARB, ctxconfig->minor);\n        }\n\n        if (mask)\n            setGLXattrib(GLX_CONTEXT_PROFILE_MASK_ARB, mask);\n\n        if (flags)\n            setGLXattrib(GLX_CONTEXT_FLAGS_ARB, flags);\n\n        setGLXattrib(None, None);\n\n        window->glx.context =\n            _glfw.glx.CreateContextAttribsARB(_glfw.x11.display,\n                                              native,\n                                              share,\n                                              True,\n                                              attribs);\n\n        // HACK: This is a fallback for broken versions of the Mesa\n        //       implementation of GLX_ARB_create_context_profile that fail\n        //       default 1.0 context creation with a GLXBadProfileARB error in\n        //       violation of the extension spec\n        if (!window->glx.context)\n        {\n            if (_glfw.x11.errorCode == _glfw.glx.errorBase + GLXBadProfileARB &&\n                ctxconfig->api == GLFW_OPENGL_API &&\n                ctxconfig->profile == GLFW_OPENGL_ANY_PROFILE &&\n                ctxconfig->forward == GL_FALSE)\n            {\n                window->glx.context = createLegacyContext(window, native, share);\n            }\n        }\n    }\n    else\n        window->glx.context = createLegacyContext(window, native, share);\n\n    _glfwReleaseXErrorHandler();\n\n    if (!window->glx.context)\n    {\n        _glfwInputXError(GLFW_VERSION_UNAVAILABLE, \"GLX: Failed to create context\");\n        return GL_FALSE;\n    }\n\n    return GL_TRUE;\n}\n\n#undef setGLXattrib\n\n// Destroy the OpenGL context\n//\nvoid _glfwDestroyContext(_GLFWwindow* window)\n{\n    if (window->glx.visual)\n    {\n        XFree(window->glx.visual);\n        window->glx.visual = NULL;\n    }\n\n    if (window->glx.context)\n    {\n        _glfw_glXDestroyContext(_glfw.x11.display, window->glx.context);\n        window->glx.context = NULL;\n    }\n}\n\n\n//////////////////////////////////////////////////////////////////////////\n//////                       GLFW platform API                      //////\n//////////////////////////////////////////////////////////////////////////\n\nvoid _glfwPlatformMakeContextCurrent(_GLFWwindow* window)\n{\n    if (window)\n    {\n        _glfw_glXMakeCurrent(_glfw.x11.display,\n                             window->x11.handle,\n                             window->glx.context);\n    }\n    else\n        _glfw_glXMakeCurrent(_glfw.x11.display, None, NULL);\n\n    _glfwSetContextTLS(window);\n}\n\nvoid _glfwPlatformSwapBuffers(_GLFWwindow* window)\n{\n    _glfw_glXSwapBuffers(_glfw.x11.display, window->x11.handle);\n}\n\nvoid _glfwPlatformSwapInterval(int interval)\n{\n    _GLFWwindow* window = _glfwPlatformGetCurrentContext();\n\n    if (_glfw.glx.EXT_swap_control)\n    {\n        _glfw.glx.SwapIntervalEXT(_glfw.x11.display,\n                                  window->x11.handle,\n                                  interval);\n    }\n    else if (_glfw.glx.MESA_swap_control)\n        _glfw.glx.SwapIntervalMESA(interval);\n    else if (_glfw.glx.SGI_swap_control)\n    {\n        if (interval > 0)\n            _glfw.glx.SwapIntervalSGI(interval);\n    }\n}\n\nint _glfwPlatformExtensionSupported(const char* extension)\n{\n    const char* extensions =\n        _glfw_glXQueryExtensionsString(_glfw.x11.display, _glfw.x11.screen);\n    if (extensions)\n    {\n        if (_glfwStringInExtensionString(extension, extensions))\n            return GL_TRUE;\n    }\n\n    return GL_FALSE;\n}\n\nGLFWglproc _glfwPlatformGetProcAddress(const char* procname)\n{\n    if (_glfw.glx.GetProcAddress)\n        return _glfw.glx.GetProcAddress((const GLubyte*) procname);\n    else if (_glfw.glx.GetProcAddressARB)\n        return _glfw.glx.GetProcAddressARB((const GLubyte*) procname);\n    else\n        return dlsym(_glfw.glx.handle, procname);\n}\n\n\n//////////////////////////////////////////////////////////////////////////\n//////                        GLFW native API                       //////\n//////////////////////////////////////////////////////////////////////////\n\nGLFWAPI GLXContext glfwGetGLXContext(GLFWwindow* handle)\n{\n    _GLFWwindow* window = (_GLFWwindow*) handle;\n    _GLFW_REQUIRE_INIT_OR_RETURN(NULL);\n    return window->glx.context;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-glfw-3.1.2-x6c6y6bid7i3cuhrzcx25eivkoimm5dy/spack-src/src/nsgl_context.h": "//========================================================================\n// GLFW 3.1 OS X - www.glfw.org\n//------------------------------------------------------------------------\n// Copyright (c) 2009-2010 Camilla Berglund <elmindreda@elmindreda.org>\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would\n//    be appreciated but is not required.\n//\n// 2. Altered source versions must be plainly marked as such, and must not\n//    be misrepresented as being the original software.\n//\n// 3. This notice may not be removed or altered from any source\n//    distribution.\n//\n//========================================================================\n\n#ifndef _glfw3_nsgl_context_h_\n#define _glfw3_nsgl_context_h_\n\n#define _GLFW_PLATFORM_FBCONFIG\n#define _GLFW_PLATFORM_CONTEXT_STATE            _GLFWcontextNSGL nsgl\n#define _GLFW_PLATFORM_LIBRARY_CONTEXT_STATE    _GLFWlibraryNSGL nsgl\n\n\n// NSGL-specific per-context data\n//\ntypedef struct _GLFWcontextNSGL\n{\n    id           pixelFormat;\n    id\t         context;\n\n} _GLFWcontextNSGL;\n\n\n// NSGL-specific global data\n//\ntypedef struct _GLFWlibraryNSGL\n{\n    // dlopen handle for OpenGL.framework (for glfwGetProcAddress)\n    void*           framework;\n\n} _GLFWlibraryNSGL;\n\n\nint _glfwInitContextAPI(void);\nvoid _glfwTerminateContextAPI(void);\nint _glfwCreateContext(_GLFWwindow* window,\n                       const _GLFWctxconfig* ctxconfig,\n                       const _GLFWfbconfig* fbconfig);\nvoid _glfwDestroyContext(_GLFWwindow* window);\n\n#endif // _glfw3_nsgl_context_h_\n",
        "/tmp/vanessa/spack-stage/spack-stage-glfw-3.1.2-x6c6y6bid7i3cuhrzcx25eivkoimm5dy/spack-src/src/glx_context.h": "//========================================================================\n// GLFW 3.1 GLX - www.glfw.org\n//------------------------------------------------------------------------\n// Copyright (c) 2002-2006 Marcus Geelnard\n// Copyright (c) 2006-2010 Camilla Berglund <elmindreda@elmindreda.org>\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would\n//    be appreciated but is not required.\n//\n// 2. Altered source versions must be plainly marked as such, and must not\n//    be misrepresented as being the original software.\n//\n// 3. This notice may not be removed or altered from any source\n//    distribution.\n//\n//========================================================================\n\n#ifndef _glfw3_glx_context_h_\n#define _glfw3_glx_context_h_\n\n#define GLX_GLXEXT_LEGACY\n#include <GL/glx.h>\n\n// This path may need to be changed if you build GLFW using your own setup\n// We ship and use our own copy of glxext.h since GLFW uses fairly new\n// extensions and not all operating systems come with an up-to-date version\n#define GLX_GLXEXT_PROTOTYPES\n#include \"../deps/GL/glxext.h\"\n\n// libGL.so function pointer typedefs\ntypedef int (*PFNGLXGETFBCONFIGATTRIBPROC)(Display*,GLXFBConfig,int,int*);\ntypedef const char* (*PFNGLXGETCLIENTSTRINGPROC)(Display*,int);\ntypedef Bool (*PFNGLXQUERYEXTENSIONPROC)(Display*,int*,int*);\ntypedef Bool (*PFNGLXQUERYVERSIONPROC)(Display*,int*,int*);\ntypedef void (*PFNGLXDESTROYCONTEXTPROC)(Display*,GLXContext);\ntypedef Bool (*PFNGLXMAKECURRENTPROC)(Display*,GLXDrawable,GLXContext);\ntypedef void (*PFNGLXSWAPBUFFERSPROC)(Display*,GLXDrawable);\ntypedef const char* (*PFNGLXQUERYEXTENSIONSSTRINGPROC)(Display*,int);\n#define _glfw_glXGetFBConfigs _glfw.glx.GetFBConfigs\n#define _glfw_glXGetFBConfigAttrib _glfw.glx.GetFBConfigAttrib\n#define _glfw_glXGetClientString _glfw.glx.GetClientString\n#define _glfw_glXQueryExtension _glfw.glx.QueryExtension\n#define _glfw_glXQueryVersion _glfw.glx.QueryVersion\n#define _glfw_glXDestroyContext _glfw.glx.DestroyContext\n#define _glfw_glXMakeCurrent _glfw.glx.MakeCurrent\n#define _glfw_glXSwapBuffers _glfw.glx.SwapBuffers\n#define _glfw_glXQueryExtensionsString _glfw.glx.QueryExtensionsString\n#define _glfw_glXCreateNewContext _glfw.glx.CreateNewContext\n#define _glfw_glXGetVisualFromFBConfig _glfw.glx.GetVisualFromFBConfig\n\n#define _GLFW_PLATFORM_FBCONFIG                 GLXFBConfig     glx\n#define _GLFW_PLATFORM_CONTEXT_STATE            _GLFWcontextGLX glx\n#define _GLFW_PLATFORM_LIBRARY_CONTEXT_STATE    _GLFWlibraryGLX glx\n\n#ifndef GLX_MESA_swap_control\ntypedef int (*PFNGLXSWAPINTERVALMESAPROC)(int);\n#endif\n\n\n// GLX-specific per-context data\n//\ntypedef struct _GLFWcontextGLX\n{\n    // Rendering context\n    GLXContext      context;\n    // Visual of selected GLXFBConfig\n    XVisualInfo*    visual;\n\n} _GLFWcontextGLX;\n\n\n// GLX-specific global data\n//\ntypedef struct _GLFWlibraryGLX\n{\n    int             major, minor;\n    int             eventBase;\n    int             errorBase;\n\n    // dlopen handle for libGL.so.1\n    void*           handle;\n\n    // GLX 1.3 functions\n    PFNGLXGETFBCONFIGSPROC              GetFBConfigs;\n    PFNGLXGETFBCONFIGATTRIBPROC         GetFBConfigAttrib;\n    PFNGLXGETCLIENTSTRINGPROC           GetClientString;\n    PFNGLXQUERYEXTENSIONPROC            QueryExtension;\n    PFNGLXQUERYVERSIONPROC              QueryVersion;\n    PFNGLXDESTROYCONTEXTPROC            DestroyContext;\n    PFNGLXMAKECURRENTPROC               MakeCurrent;\n    PFNGLXSWAPBUFFERSPROC               SwapBuffers;\n    PFNGLXQUERYEXTENSIONSSTRINGPROC     QueryExtensionsString;\n    PFNGLXCREATENEWCONTEXTPROC          CreateNewContext;\n    PFNGLXGETVISUALFROMFBCONFIGPROC     GetVisualFromFBConfig;\n\n    // GLX 1.4 and extension functions\n    PFNGLXGETPROCADDRESSPROC            GetProcAddress;\n    PFNGLXGETPROCADDRESSPROC            GetProcAddressARB;\n    PFNGLXSWAPINTERVALSGIPROC           SwapIntervalSGI;\n    PFNGLXSWAPINTERVALEXTPROC           SwapIntervalEXT;\n    PFNGLXSWAPINTERVALMESAPROC          SwapIntervalMESA;\n    PFNGLXCREATECONTEXTATTRIBSARBPROC   CreateContextAttribsARB;\n    GLboolean       SGI_swap_control;\n    GLboolean       EXT_swap_control;\n    GLboolean       MESA_swap_control;\n    GLboolean       ARB_multisample;\n    GLboolean       ARB_framebuffer_sRGB;\n    GLboolean       EXT_framebuffer_sRGB;\n    GLboolean       ARB_create_context;\n    GLboolean       ARB_create_context_profile;\n    GLboolean       ARB_create_context_robustness;\n    GLboolean       EXT_create_context_es2_profile;\n    GLboolean       ARB_context_flush_control;\n\n} _GLFWlibraryGLX;\n\n\nint _glfwInitContextAPI(void);\nvoid _glfwTerminateContextAPI(void);\nint _glfwCreateContext(_GLFWwindow* window,\n                       const _GLFWctxconfig* ctxconfig,\n                       const _GLFWfbconfig* fbconfig);\nvoid _glfwDestroyContext(_GLFWwindow* window);\n\n#endif // _glfw3_glx_context_h_\n",
        "/tmp/vanessa/spack-stage/spack-stage-glfw-3.1.2-x6c6y6bid7i3cuhrzcx25eivkoimm5dy/spack-src/src/egl_context.h": "//========================================================================\n// GLFW 3.1 EGL - www.glfw.org\n//------------------------------------------------------------------------\n// Copyright (c) 2002-2006 Marcus Geelnard\n// Copyright (c) 2006-2010 Camilla Berglund <elmindreda@elmindreda.org>\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would\n//    be appreciated but is not required.\n//\n// 2. Altered source versions must be plainly marked as such, and must not\n//    be misrepresented as being the original software.\n//\n// 3. This notice may not be removed or altered from any source\n//    distribution.\n//\n//========================================================================\n\n#ifndef _glfw3_egl_context_h_\n#define _glfw3_egl_context_h_\n\n#if defined(_GLFW_WIN32)\n #define _glfw_dlopen(name) LoadLibraryA(name)\n #define _glfw_dlclose(handle) FreeLibrary((HMODULE) handle)\n #define _glfw_dlsym(handle, name) GetProcAddress((HMODULE) handle, name)\n#else\n #include <dlfcn.h>\n #define _glfw_dlopen(name) dlopen(name, RTLD_LAZY | RTLD_LOCAL)\n #define _glfw_dlclose(handle) dlclose(handle)\n #define _glfw_dlsym(handle, name) dlsym(handle, name)\n#endif\n\n#include <EGL/egl.h>\n\n// This path may need to be changed if you build GLFW using your own setup\n// We ship and use our own copy of eglext.h since GLFW uses fairly new\n// extensions and not all operating systems come with an up-to-date version\n#include \"../deps/EGL/eglext.h\"\n\n// EGL function pointer typedefs\ntypedef EGLBoolean (EGLAPIENTRY * PFNEGLGETCONFIGATTRIBPROC)(EGLDisplay,EGLConfig,EGLint,EGLint*);\ntypedef EGLBoolean (EGLAPIENTRY * PFNEGLGETCONFIGSPROC)(EGLDisplay,EGLConfig*,EGLint,EGLint*);\ntypedef EGLDisplay (EGLAPIENTRY * PFNEGLGETDISPLAYPROC)(EGLNativeDisplayType);\ntypedef EGLint (EGLAPIENTRY * PFNEGLGETERRORPROC)(void);\ntypedef EGLBoolean (EGLAPIENTRY * PFNEGLINITIALIZEPROC)(EGLDisplay,EGLint*,EGLint*);\ntypedef EGLBoolean (EGLAPIENTRY * PFNEGLTERMINATEPROC)(EGLDisplay);\ntypedef EGLBoolean (EGLAPIENTRY * PFNEGLBINDAPIPROC)(EGLenum);\ntypedef EGLContext (EGLAPIENTRY * PFNEGLCREATECONTEXTPROC)(EGLDisplay,EGLConfig,EGLContext,const EGLint*);\ntypedef EGLBoolean (EGLAPIENTRY * PFNEGLDESTROYSURFACEPROC)(EGLDisplay,EGLSurface);\ntypedef EGLBoolean (EGLAPIENTRY * PFNEGLDESTROYCONTEXTPROC)(EGLDisplay,EGLContext);\ntypedef EGLSurface (EGLAPIENTRY * PFNEGLCREATEWINDOWSURFACEPROC)(EGLDisplay,EGLConfig,EGLNativeWindowType,const EGLint*);\ntypedef EGLBoolean (EGLAPIENTRY * PFNEGLMAKECURRENTPROC)(EGLDisplay,EGLSurface,EGLSurface,EGLContext);\ntypedef EGLBoolean (EGLAPIENTRY * PFNEGLSWAPBUFFERSPROC)(EGLDisplay,EGLSurface);\ntypedef EGLBoolean (EGLAPIENTRY * PFNEGLSWAPINTERVALPROC)(EGLDisplay,EGLint);\ntypedef const char* (EGLAPIENTRY * PFNEGLQUERYSTRINGPROC)(EGLDisplay,EGLint);\ntypedef GLFWglproc (EGLAPIENTRY * PFNEGLGETPROCADDRESSPROC)(const char*);\n#define _glfw_eglGetConfigAttrib _glfw.egl.GetConfigAttrib\n#define _glfw_eglGetConfigs _glfw.egl.GetConfigs\n#define _glfw_eglGetDisplay _glfw.egl.GetDisplay\n#define _glfw_eglGetError _glfw.egl.GetError\n#define _glfw_eglInitialize _glfw.egl.Initialize\n#define _glfw_eglTerminate _glfw.egl.Terminate\n#define _glfw_eglBindAPI _glfw.egl.BindAPI\n#define _glfw_eglCreateContext _glfw.egl.CreateContext\n#define _glfw_eglDestroySurface _glfw.egl.DestroySurface\n#define _glfw_eglDestroyContext _glfw.egl.DestroyContext\n#define _glfw_eglCreateWindowSurface _glfw.egl.CreateWindowSurface\n#define _glfw_eglMakeCurrent _glfw.egl.MakeCurrent\n#define _glfw_eglSwapBuffers _glfw.egl.SwapBuffers\n#define _glfw_eglSwapInterval _glfw.egl.SwapInterval\n#define _glfw_eglQueryString _glfw.egl.QueryString\n#define _glfw_eglGetProcAddress _glfw.egl.GetProcAddress\n\n#define _GLFW_PLATFORM_FBCONFIG                 EGLConfig       egl\n#define _GLFW_PLATFORM_CONTEXT_STATE            _GLFWcontextEGL egl\n#define _GLFW_PLATFORM_LIBRARY_CONTEXT_STATE    _GLFWlibraryEGL egl\n\n\n// EGL-specific per-context data\n//\ntypedef struct _GLFWcontextEGL\n{\n   EGLConfig        config;\n   EGLContext       context;\n   EGLSurface       surface;\n\n#if defined(_GLFW_X11)\n   XVisualInfo*     visual;\n#endif\n\n   void*            client;\n\n} _GLFWcontextEGL;\n\n\n// EGL-specific global data\n//\ntypedef struct _GLFWlibraryEGL\n{\n    EGLDisplay      display;\n    EGLint          major, minor;\n\n    GLboolean       KHR_create_context;\n\n    void*           handle;\n\n    PFNEGLGETCONFIGATTRIBPROC       GetConfigAttrib;\n    PFNEGLGETCONFIGSPROC            GetConfigs;\n    PFNEGLGETDISPLAYPROC            GetDisplay;\n    PFNEGLGETERRORPROC              GetError;\n    PFNEGLINITIALIZEPROC            Initialize;\n    PFNEGLTERMINATEPROC             Terminate;\n    PFNEGLBINDAPIPROC               BindAPI;\n    PFNEGLCREATECONTEXTPROC         CreateContext;\n    PFNEGLDESTROYSURFACEPROC        DestroySurface;\n    PFNEGLDESTROYCONTEXTPROC        DestroyContext;\n    PFNEGLCREATEWINDOWSURFACEPROC   CreateWindowSurface;\n    PFNEGLMAKECURRENTPROC           MakeCurrent;\n    PFNEGLSWAPBUFFERSPROC           SwapBuffers;\n    PFNEGLSWAPINTERVALPROC          SwapInterval;\n    PFNEGLQUERYSTRINGPROC           QueryString;\n    PFNEGLGETPROCADDRESSPROC        GetProcAddress;\n\n} _GLFWlibraryEGL;\n\n\nint _glfwInitContextAPI(void);\nvoid _glfwTerminateContextAPI(void);\nint _glfwCreateContext(_GLFWwindow* window,\n                       const _GLFWctxconfig* ctxconfig,\n                       const _GLFWfbconfig* fbconfig);\nvoid _glfwDestroyContext(_GLFWwindow* window);\nint _glfwAnalyzeContext(const _GLFWwindow* window,\n                        const _GLFWctxconfig* ctxconfig,\n                        const _GLFWfbconfig* fbconfig);\n\n#endif // _glfw3_egl_context_h_\n"
    },
    "skipped": [],
    "total_files": 132
}