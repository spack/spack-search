{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-glfw-3.1.1-vdjqhn35kmytrs37763btj7r4qzvf3wi/spack-src/CMakeLists.txt": "project(GLFW C)\n\ncmake_minimum_required(VERSION 2.8.9)\n\nif (CMAKE_VERSION VERSION_EQUAL \"3.0\" OR CMAKE_VERSION VERSION_GREATER \"3.0\")\n    # Until all major package systems have moved to CMake 3,\n    # we stick with the older INSTALL_NAME_DIR mechanism\n    cmake_policy(SET CMP0042 OLD)\nendif()\n\nset(GLFW_VERSION_MAJOR \"3\")\nset(GLFW_VERSION_MINOR \"1\")\nset(GLFW_VERSION_PATCH \"1\")\nset(GLFW_VERSION_EXTRA \"\")\nset(GLFW_VERSION \"${GLFW_VERSION_MAJOR}.${GLFW_VERSION_MINOR}\")\nset(GLFW_VERSION_FULL \"${GLFW_VERSION}.${GLFW_VERSION_PATCH}${GLFW_VERSION_EXTRA}\")\nset(LIB_SUFFIX \"\" CACHE STRING \"Takes an empty string or 64. Directory where lib will be installed: lib or lib64\")\n\nset_property(GLOBAL PROPERTY USE_FOLDERS ON)\n\noption(BUILD_SHARED_LIBS \"Build shared libraries\" OFF)\noption(GLFW_BUILD_EXAMPLES \"Build the GLFW example programs\" ON)\noption(GLFW_BUILD_TESTS \"Build the GLFW test programs\" ON)\noption(GLFW_BUILD_DOCS \"Build the GLFW documentation\" ON)\noption(GLFW_INSTALL \"Generate installation target\" ON)\noption(GLFW_DOCUMENT_INTERNALS \"Include internals in documentation\" OFF)\n\nif (WIN32)\n    option(GLFW_USE_DWM_SWAP_INTERVAL \"Set swap interval even when DWM compositing is enabled\" OFF)\n    option(GLFW_USE_OPTIMUS_HPG \"Force use of high-performance GPU on Optimus systems\" OFF)\nendif()\n\nif (APPLE)\n    option(GLFW_BUILD_UNIVERSAL \"Build GLFW as a Universal Binary\" OFF)\n    option(GLFW_USE_CHDIR \"Make glfwInit chdir to Contents/Resources\" ON)\n    option(GLFW_USE_MENUBAR \"Populate the menu bar on first window creation\" ON)\n    option(GLFW_USE_RETINA \"Use the full resolution of Retina displays\" ON)\nelse()\n    option(GLFW_USE_EGL \"Use EGL for context creation\" OFF)\nendif()\n\nif (UNIX AND NOT APPLE)\n    option(GLFW_USE_WAYLAND \"Use Wayland for context creation (implies EGL as well)\" OFF)\n    option(GLFW_USE_MIR     \"Use Mir for context creation (implies EGL as well)\" OFF)\nendif()\n\nif (MSVC)\n    option(USE_MSVC_RUNTIME_LIBRARY_DLL \"Use MSVC runtime library DLL\" ON)\nendif()\n\nif (BUILD_SHARED_LIBS)\n    set(_GLFW_BUILD_DLL 1)\nendif()\n\nif (GLFW_USE_WAYLAND)\n    set(GLFW_USE_EGL ON)\nelseif (GLFW_USE_MIR)\n    set(GLFW_USE_EGL ON)\nendif()\n\nif (GLFW_USE_EGL)\n    set(GLFW_CLIENT_LIBRARY \"opengl\" CACHE STRING\n        \"The client library to use; one of opengl, glesv1 or glesv2\")\n\n    if (${GLFW_CLIENT_LIBRARY} STREQUAL \"opengl\")\n        set(_GLFW_USE_OPENGL 1)\n    elseif (${GLFW_CLIENT_LIBRARY} STREQUAL \"glesv1\")\n        set(_GLFW_USE_GLESV1 1)\n    elseif (${GLFW_CLIENT_LIBRARY} STREQUAL \"glesv2\")\n        set(_GLFW_USE_GLESV2 1)\n    else()\n        message(FATAL_ERROR \"Unsupported client library\")\n    endif()\n\n    set(CMAKE_MODULE_PATH \"${PROJECT_SOURCE_DIR}/CMake/modules\")\n    find_package(EGL REQUIRED)\n\n    if (NOT _GLFW_USE_OPENGL)\n        set(GLFW_BUILD_EXAMPLES OFF)\n        set(GLFW_BUILD_TESTS OFF)\n        message(STATUS \"NOTE: Examples and tests require OpenGL\")\n    endif()\nelse()\n    set(_GLFW_USE_OPENGL 1)\nendif()\n\nif (_GLFW_USE_OPENGL)\n    find_package(OpenGL REQUIRED)\nelseif (_GLFW_USE_GLESV1)\n    find_package(GLESv1 REQUIRED)\nelseif (_GLFW_USE_GLESV2)\n    find_package(GLESv2 REQUIRED)\nendif()\n\nfind_package(Threads REQUIRED)\n\nif (GLFW_BUILD_DOCS)\n    set(DOXYGEN_SKIP_DOT TRUE)\n    find_package(Doxygen)\n\n    if (GLFW_DOCUMENT_INTERNALS)\n        set(GLFW_INTERNAL_DOCS \"${GLFW_SOURCE_DIR}/src/internal.h ${GLFW_SOURCE_DIR}/docs/internal.dox\")\n    endif()\nendif()\n\n#--------------------------------------------------------------------\n# Set compiler specific flags\n#--------------------------------------------------------------------\nif (UNIX)\n    add_definitions(-Wall)\n\n    if (BUILD_SHARED_LIBS)\n        add_definitions(-fvisibility=hidden)\n    endif()\nendif()\n\nif (MSVC)\n    add_definitions(-D_CRT_SECURE_NO_WARNINGS)\n\n    if (NOT USE_MSVC_RUNTIME_LIBRARY_DLL)\n        foreach (flag CMAKE_C_FLAGS\n                        CMAKE_C_FLAGS_DEBUG\n                        CMAKE_C_FLAGS_RELEASE\n                        CMAKE_C_FLAGS_MINSIZEREL\n                        CMAKE_C_FLAGS_RELWITHDEBINFO)\n\n            if (${flag} MATCHES \"/MD\")\n                string(REGEX REPLACE \"/MD\" \"/MT\" ${flag} \"${${flag}}\")\n            endif()\n            if (${flag} MATCHES \"/MDd\")\n                string(REGEX REPLACE \"/MDd\" \"/MTd\" ${flag} \"${${flag}}\")\n            endif()\n\n        endforeach()\n    endif()\nendif()\n\nif (MINGW)\n    # Enable link-time exploit mitigation features enabled by default on MSVC\n\n    include(CheckCCompilerFlag)\n\n    # Compatibility with data execution prevention (DEP)\n    set(CMAKE_REQUIRED_FLAGS \"-Wl,--nxcompat\")\n    check_c_compiler_flag(\"\" _GLFW_HAS_DEP)\n    if (_GLFW_HAS_DEP)\n        set(CMAKE_SHARED_LINKER_FLAGS \"-Wl,--nxcompat ${CMAKE_SHARED_LINKER_FLAGS}\")\n    endif()\n\n    # Compatibility with address space layout randomization (ASLR)\n    set(CMAKE_REQUIRED_FLAGS \"-Wl,--dynamicbase\")\n    check_c_compiler_flag(\"\" _GLFW_HAS_ASLR)\n    if (_GLFW_HAS_ASLR)\n        set(CMAKE_SHARED_LINKER_FLAGS \"-Wl,--dynamicbase ${CMAKE_SHARED_LINKER_FLAGS}\")\n    endif()\n\n    # Compatibility with 64-bit address space layout randomization (ASLR)\n    set(CMAKE_REQUIRED_FLAGS \"-Wl,--high-entropy-va\")\n    check_c_compiler_flag(\"\" _GLFW_HAS_64ASLR)\n    if (_GLFW_HAS_64ASLR)\n        set(CMAKE_SHARED_LINKER_FLAGS \"-Wl,--high-entropy-va ${CMAKE_SHARED_LINKER_FLAGS}\")\n    endif()\nendif()\n\n#--------------------------------------------------------------------\n# Detect and select backend APIs\n#--------------------------------------------------------------------\nif (WIN32)\n    set(_GLFW_WIN32 1)\n    message(STATUS \"Using Win32 for window creation\")\n\n    if (GLFW_USE_EGL)\n        set(_GLFW_EGL 1)\n        message(STATUS \"Using EGL for context creation\")\n    else()\n        set(_GLFW_WGL 1)\n        message(STATUS \"Using WGL for context creation\")\n    endif()\nelseif (APPLE)\n    set(_GLFW_COCOA 1)\n    message(STATUS \"Using Cocoa for window creation\")\n    set(_GLFW_NSGL 1)\n    message(STATUS \"Using NSGL for context creation\")\nelseif (UNIX)\n    if (GLFW_USE_WAYLAND)\n        set(_GLFW_WAYLAND 1)\n        message(STATUS \"Using Wayland for window creation\")\n    elseif (GLFW_USE_MIR)\n        set(_GLFW_MIR 1)\n        message(STATUS \"Using Mir for window creation\")\n    else()\n        set(_GLFW_X11 1)\n        message(STATUS \"Using X11 for window creation\")\n    endif()\n\n    if (GLFW_USE_EGL)\n        set(_GLFW_EGL 1)\n        message(STATUS \"Using EGL for context creation\")\n    else()\n        set(_GLFW_GLX 1)\n        message(STATUS \"Using GLX for context creation\")\n    endif()\nelse()\n    message(FATAL_ERROR \"No supported platform was detected\")\nendif()\n\n#--------------------------------------------------------------------\n# Use Win32 for window creation\n#--------------------------------------------------------------------\nif (_GLFW_WIN32)\n\n    list(APPEND glfw_PKG_LIBS \"-lgdi32\")\n\n    if (GLFW_USE_DWM_SWAP_INTERVAL)\n        set(_GLFW_USE_DWM_SWAP_INTERVAL 1)\n    endif()\n    if (GLFW_USE_OPTIMUS_HPG)\n        set(_GLFW_USE_OPTIMUS_HPG 1)\n    endif()\n\n    # HACK: When building on MinGW, WINVER and UNICODE need to be defined before\n    # the inclusion of stddef.h (by glfw3.h), which is itself included before\n    # win32_platform.h.  We define them here until a saner solution can be found\n    # NOTE: MinGW-w64 and Visual C++ do /not/ need this hack.\n    if (${CMAKE_C_COMPILER_ID} STREQUAL \"GNU\")\n        add_definitions(-DUNICODE -DWINVER=0x0501)\n    endif()\nendif()\n\n#--------------------------------------------------------------------\n# Use WGL for context creation\n#--------------------------------------------------------------------\nif (_GLFW_WGL)\n\n    list(APPEND glfw_PKG_LIBS \"-lopengl32\")\n\n    list(APPEND glfw_INCLUDE_DIRS \"${OPENGL_INCLUDE_DIR}\")\n    list(APPEND glfw_LIBRARIES \"${OPENGL_gl_LIBRARY}\")\nendif()\n\n#--------------------------------------------------------------------\n# Use X11 for window creation\n#--------------------------------------------------------------------\nif (_GLFW_X11)\n\n    find_package(X11 REQUIRED)\n\n    list(APPEND glfw_PKG_DEPS \"x11\")\n\n    # Set up library and include paths\n    list(APPEND glfw_INCLUDE_DIRS \"${X11_X11_INCLUDE_PATH}\")\n    list(APPEND glfw_LIBRARIES \"${X11_X11_LIB}\" \"${CMAKE_THREAD_LIBS_INIT}\")\n    if (UNIX AND NOT APPLE)\n        list(APPEND glfw_LIBRARIES \"${RT_LIBRARY}\")\n    endif()\n\n    # Check for XRandR (modern resolution switching and gamma control)\n    if (NOT X11_Xrandr_FOUND)\n        message(FATAL_ERROR \"The RandR library and headers were not found\")\n    endif()\n\n    list(APPEND glfw_INCLUDE_DIRS \"${X11_Xrandr_INCLUDE_PATH}\")\n    list(APPEND glfw_LIBRARIES \"${X11_Xrandr_LIB}\")\n    list(APPEND glfw_PKG_DEPS \"xrandr\")\n\n    # Check for Xinerama (legacy multi-monitor support)\n    if (NOT X11_Xinerama_FOUND)\n        message(FATAL_ERROR \"The Xinerama library and headers were not found\")\n    endif()\n\n    list(APPEND glfw_INCLUDE_DIRS \"${X11_Xinerama_INCLUDE_PATH}\")\n    list(APPEND glfw_LIBRARIES \"${X11_Xinerama_LIB}\")\n    list(APPEND glfw_PKG_DEPS \"xinerama\")\n\n    # Check for XInput (high-resolution cursor motion)\n    if (X11_Xinput_FOUND)\n        list(APPEND glfw_INCLUDE_DIRS \"${X11_Xinput_INCLUDE_PATH}\")\n        list(APPEND glfw_PKG_DEPS \"xi\")\n\n        if (X11_Xinput_LIB)\n            list(APPEND glfw_LIBRARIES \"${X11_Xinput_LIB}\")\n        else()\n            # Backwards compatibility (bug in CMake 2.8.7)\n            list(APPEND glfw_LIBRARIES Xi)\n        endif()\n\n        set(_GLFW_HAS_XINPUT TRUE)\n    endif()\n\n    # Check for Xf86VidMode (fallback gamma control)\n    if (X11_xf86vmode_FOUND)\n        list(APPEND glfw_INCLUDE_DIRS \"${X11_xf86vmode_INCLUDE_PATH}\")\n        list(APPEND glfw_PKG_DEPS \"xxf86vm\")\n\n        if (X11_Xxf86vm_LIB)\n            list(APPEND glfw_LIBRARIES \"${X11_Xxf86vm_LIB}\")\n        else()\n            # Backwards compatibility (see CMake bug 0006976)\n            list(APPEND glfw_LIBRARIES Xxf86vm)\n        endif()\n\n        set(_GLFW_HAS_XF86VM TRUE)\n    endif()\n\n    # Check for Xkb (X keyboard extension)\n    if (NOT X11_Xkb_FOUND)\n        message(FATAL_ERROR \"The X keyboard extension headers were not found\")\n    endif()\n\n    list(APPEND glfw_INCLUDE_DIR \"${X11_Xkb_INCLUDE_PATH}\")\n\n    find_library(RT_LIBRARY rt)\n    mark_as_advanced(RT_LIBRARY)\n    if (RT_LIBRARY)\n        list(APPEND glfw_LIBRARIES \"${RT_LIBRARY}\")\n        list(APPEND glfw_PKG_LIBS \"-lrt\")\n    endif()\n\n    find_library(MATH_LIBRARY m)\n    mark_as_advanced(MATH_LIBRARY)\n    if (MATH_LIBRARY)\n        list(APPEND glfw_LIBRARIES \"${MATH_LIBRARY}\")\n        list(APPEND glfw_PKG_LIBS \"-lm\")\n    endif()\n\n    # Check for Xcursor\n    if (NOT X11_Xcursor_FOUND)\n        message(FATAL_ERROR \"The Xcursor libraries and headers were not found\")\n    endif()\n\n    list(APPEND glfw_INCLUDE_DIR \"${X11_Xcursor_INCLUDE_PATH}\")\n    list(APPEND glfw_LIBRARIES \"${X11_Xcursor_LIB}\")\n    list(APPEND glfw_PKG_DEPS \"xcursor\")\n\nendif()\n\n#--------------------------------------------------------------------\n# Use Wayland for window creation\n#--------------------------------------------------------------------\nif (_GLFW_WAYLAND)\n    find_package(Wayland REQUIRED)\n    list(APPEND glfw_PKG_DEPS \"wayland-egl\")\n\n    list(APPEND glfw_INCLUDE_DIRS \"${WAYLAND_INCLUDE_DIR}\")\n    list(APPEND glfw_LIBRARIES \"${WAYLAND_LIBRARIES}\" \"${CMAKE_THREAD_LIBS_INIT}\")\n\n    find_package(XKBCommon REQUIRED)\n    list(APPEND glfw_PKG_DEPS \"xkbcommon\")\n    list(APPEND glfw_INCLUDE_DIRS \"${XKBCOMMON_INCLUDE_DIRS}\")\n    list(APPEND glfw_LIBRARIES \"${XKBCOMMON_LIBRARY}\")\n\n    find_library(MATH_LIBRARY m)\n    mark_as_advanced(MATH_LIBRARY)\n    if (MATH_LIBRARY)\n        list(APPEND glfw_LIBRARIES \"${MATH_LIBRARY}\")\n        list(APPEND glfw_PKG_LIBS \"-lm\")\n    endif()\nendif()\n\n#--------------------------------------------------------------------\n# Use Mir for window creation\n#--------------------------------------------------------------------\nif (_GLFW_MIR)\n    find_package(Mir REQUIRED)\n    list(APPEND glfw_PKG_DEPS \"mirclient\")\n\n    list(APPEND glfw_INCLUDE_DIRS \"${MIR_INCLUDE_DIR}\")\n    list(APPEND glfw_LIBRARIES \"${MIR_LIBRARIES}\" \"${CMAKE_THREAD_LIBS_INIT}\")\n\n    find_package(XKBCommon REQUIRED)\n    list(APPEND glfw_PKG_DEPS \"xkbcommon\")\n    list(APPEND glfw_INCLUDE_DIRS \"${XKBCOMMON_INCLUDE_DIRS}\")\n    list(APPEND glfw_LIBRARIES \"${XKBCOMMON_LIBRARY}\")\n\n    find_library(MATH_LIBRARY m)\n    mark_as_advanced(MATH_LIBRARY)\n    if (MATH_LIBRARY)\n        list(APPEND glfw_LIBRARIES \"${MATH_LIBRARY}\")\n        list(APPEND glfw_PKG_LIBS \"-lm\")\n    endif()\nendif()\n\n#--------------------------------------------------------------------\n# Use GLX for context creation\n#--------------------------------------------------------------------\nif (_GLFW_GLX)\n\n    list(APPEND glfw_INCLUDE_DIRS \"${OPENGL_INCLUDE_DIR}\")\n    list(APPEND glfw_LIBRARIES \"${OPENGL_gl_LIBRARY}\")\n\n    list(APPEND glfw_PKG_DEPS \"gl\")\n\n    include(CheckFunctionExists)\n\n    set(CMAKE_REQUIRED_LIBRARIES \"${OPENGL_gl_LIBRARY}\")\n    check_function_exists(glXGetProcAddress _GLFW_HAS_GLXGETPROCADDRESS)\n    check_function_exists(glXGetProcAddressARB _GLFW_HAS_GLXGETPROCADDRESSARB)\n    check_function_exists(glXGetProcAddressEXT _GLFW_HAS_GLXGETPROCADDRESSEXT)\n\n    if (NOT _GLFW_HAS_GLXGETPROCADDRESS AND\n        NOT _GLFW_HAS_GLXGETPROCADDRESSARB AND\n        NOT _GLFW_HAS_GLXGETPROCADDRESSEXT)\n        message(WARNING \"No glXGetProcAddressXXX variant found\")\n\n        # Check for dlopen support as a fallback\n\n        set(CMAKE_REQUIRED_LIBRARIES \"${CMAKE_DL_LIBS}\")\n        check_function_exists(dlopen _GLFW_HAS_DLOPEN)\n        if (NOT _GLFW_HAS_DLOPEN)\n            message(FATAL_ERROR \"No entry point retrieval mechanism found\")\n        endif()\n\n        if (CMAKE_DL_LIBS)\n            list(APPEND glfw_LIBRARIES \"${CMAKE_DL_LIBS}\")\n            list(APPEND glfw_PKG_LIBS \"-l${CMAKE_DL_LIBS}\")\n        endif()\n    endif()\n\nendif()\n\n#--------------------------------------------------------------------\n# Use EGL for context creation\n#--------------------------------------------------------------------\nif (_GLFW_EGL)\n\n    list(APPEND glfw_INCLUDE_DIRS \"${EGL_INCLUDE_DIR}\")\n    list(APPEND glfw_LIBRARIES \"${EGL_LIBRARY}\")\n\n    list(APPEND glfw_PKG_DEPS \"egl\")\n\n    if (_GLFW_USE_OPENGL)\n        list(APPEND glfw_LIBRARIES \"${OPENGL_gl_LIBRARY}\")\n        list(APPEND glfw_INCLUDE_DIRS \"${OPENGL_INCLUDE_DIR}\")\n        list(APPEND glfw_PKG_DEPS \"gl\")\n    elseif (_GLFW_USE_GLESV1)\n        list(APPEND glfw_LIBRARIES \"${GLESv1_LIBRARY}\")\n        list(APPEND glfw_INCLUDE_DIRS \"${GLESv1_INCLUDE_DIR}\")\n        list(APPEND glfw_PKG_DEPS \"glesv1_cm\")\n    elseif (_GLFW_USE_GLESV2)\n        list(APPEND glfw_LIBRARIES \"${GLESv2_LIBRARY}\")\n        list(APPEND glfw_INCLUDE_DIRS \"${GLESv2_INCLUDE_DIR}\")\n        list(APPEND glfw_PKG_DEPS \"glesv2\")\n    endif()\n\nendif()\n\n#--------------------------------------------------------------------\n# Use Cocoa for window creation and NSOpenGL for context creation\n#--------------------------------------------------------------------\nif (_GLFW_COCOA AND _GLFW_NSGL)\n\n    if (GLFW_USE_MENUBAR)\n        set(_GLFW_USE_MENUBAR 1)\n    endif()\n\n    if (GLFW_USE_CHDIR)\n        set(_GLFW_USE_CHDIR 1)\n    endif()\n\n    if (GLFW_USE_RETINA)\n        set(_GLFW_USE_RETINA 1)\n    endif()\n\n    if (GLFW_BUILD_UNIVERSAL)\n        message(STATUS \"Building GLFW as Universal Binaries\")\n        set(CMAKE_OSX_ARCHITECTURES i386;x86_64)\n    else()\n        message(STATUS \"Building GLFW only for the native architecture\")\n    endif()\n\n    # Set up library and include paths\n    find_library(COCOA_FRAMEWORK Cocoa)\n    find_library(IOKIT_FRAMEWORK IOKit)\n    find_library(CORE_FOUNDATION_FRAMEWORK CoreFoundation)\n    find_library(CORE_VIDEO_FRAMEWORK CoreVideo)\n    mark_as_advanced(COCOA_FRAMEWORK\n                     IOKIT_FRAMEWORK\n                     CORE_FOUNDATION_FRAMEWORK\n                     CORE_VIDEO_FRAMEWORK)\n    list(APPEND glfw_LIBRARIES \"${COCOA_FRAMEWORK}\"\n                               \"${OPENGL_gl_LIBRARY}\"\n                               \"${IOKIT_FRAMEWORK}\"\n                               \"${CORE_FOUNDATION_FRAMEWORK}\"\n                               \"${CORE_VIDEO_FRAMEWORK}\")\n\n    set(glfw_PKG_DEPS \"\")\n    set(glfw_PKG_LIBS \"-framework Cocoa -framework OpenGL -framework IOKit -framework CoreFoundation -framework CoreVideo\")\nendif()\n\n#--------------------------------------------------------------------\n# Export GLFW library dependencies\n#--------------------------------------------------------------------\nset(GLFW_LIBRARIES ${glfw_LIBRARIES} CACHE STRING \"Dependencies of GLFW\")\nforeach(arg ${glfw_PKG_DEPS})\n    set(GLFW_PKG_DEPS \"${GLFW_PKG_DEPS} ${arg}\")\nendforeach()\nforeach(arg ${glfw_PKG_LIBS})\n    set(GLFW_PKG_LIBS \"${GLFW_PKG_LIBS} ${arg}\")\nendforeach()\n\n#--------------------------------------------------------------------\n# Choose library output name\n#--------------------------------------------------------------------\nif (BUILD_SHARED_LIBS AND UNIX)\n    # On Unix-like systems, shared libraries can use the soname system.\n    set(GLFW_LIB_NAME glfw)\nelse()\n    set(GLFW_LIB_NAME glfw3)\nendif()\n\n#--------------------------------------------------------------------\n# Create generated files\n#--------------------------------------------------------------------\ninclude(CMakePackageConfigHelpers)\n\nif (UNIX)\n    set(GLFW_CONFIG_PATH \"${CMAKE_INSTALL_PREFIX}/lib/cmake/glfw3/\")\nelse()\n    set(GLFW_CONFIG_PATH \"${CMAKE_INSTALL_PREFIX}/\")\nendif()\n\nconfigure_package_config_file(\"${GLFW_SOURCE_DIR}/src/glfw3Config.cmake.in\"\n                              \"${GLFW_BINARY_DIR}/src/glfw3Config.cmake\"\n                              INSTALL_DESTINATION \"${GLFW_CONFIG_PATH}\"\n                              PATH_VARS CMAKE_INSTALL_PREFIX\n                              NO_CHECK_REQUIRED_COMPONENTS_MACRO)\n\nwrite_basic_package_version_file(\"${GLFW_BINARY_DIR}/src/glfw3ConfigVersion.cmake\" \n                                 VERSION ${GLFW_VERSION_FULL}\n                                 COMPATIBILITY SameMajorVersion)\n\nif (GLFW_BUILD_DOCS)\n    configure_file(\"${GLFW_SOURCE_DIR}/docs/Doxyfile.in\"\n                   \"${GLFW_BINARY_DIR}/docs/Doxyfile\" @ONLY)\nendif()\n\nconfigure_file(\"${GLFW_SOURCE_DIR}/src/glfw_config.h.in\"\n               \"${GLFW_BINARY_DIR}/src/glfw_config.h\" @ONLY)\n\nconfigure_file(\"${GLFW_SOURCE_DIR}/src/glfw3.pc.in\"\n               \"${GLFW_BINARY_DIR}/src/glfw3.pc\" @ONLY)\n\n#--------------------------------------------------------------------\n# Add subdirectories\n#--------------------------------------------------------------------\nadd_subdirectory(src)\n\nif (GLFW_BUILD_EXAMPLES)\n    add_subdirectory(examples)\nendif()\n\nif (GLFW_BUILD_TESTS)\n    add_subdirectory(tests)\nendif()\n\nif (DOXYGEN_FOUND AND GLFW_BUILD_DOCS)\n    add_subdirectory(docs)\nendif()\n\n#--------------------------------------------------------------------\n# Install files other than the library\n# The library is installed by src/CMakeLists.txt\n#--------------------------------------------------------------------\nif (GLFW_INSTALL)\n    install(DIRECTORY include/GLFW DESTINATION include\n            FILES_MATCHING PATTERN glfw3.h PATTERN glfw3native.h)\n\n    install(FILES \"${GLFW_BINARY_DIR}/src/glfw3Config.cmake\"\n                  \"${GLFW_BINARY_DIR}/src/glfw3ConfigVersion.cmake\"\n            DESTINATION lib${LIB_SUFFIX}/cmake/glfw)\n\n    install(EXPORT glfwTargets DESTINATION lib${LIB_SUFFIX}/cmake/glfw)\n    install(FILES \"${GLFW_BINARY_DIR}/src/glfw3.pc\"\n            DESTINATION lib${LIB_SUFFIX}/pkgconfig)\n\n    # Only generate this target if no higher-level project already has\n    if (NOT TARGET uninstall)\n        configure_file(\"${GLFW_SOURCE_DIR}/cmake_uninstall.cmake.in\"\n                       \"${GLFW_BINARY_DIR}/cmake_uninstall.cmake\" IMMEDIATE @ONLY)\n\n        add_custom_target(uninstall\n                          \"${CMAKE_COMMAND}\" -P\n                          \"${GLFW_BINARY_DIR}/cmake_uninstall.cmake\")\n    endif()\nendif()\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-glfw-3.1.1-vdjqhn35kmytrs37763btj7r4qzvf3wi/spack-src/src/glx_context.c": "//========================================================================\n// GLFW 3.1 GLX - www.glfw.org\n//------------------------------------------------------------------------\n// Copyright (c) 2002-2006 Marcus Geelnard\n// Copyright (c) 2006-2010 Camilla Berglund <elmindreda@elmindreda.org>\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would\n//    be appreciated but is not required.\n//\n// 2. Altered source versions must be plainly marked as such, and must not\n//    be misrepresented as being the original software.\n//\n// 3. This notice may not be removed or altered from any source\n//    distribution.\n//\n//========================================================================\n\n#include \"internal.h\"\n\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n\n\n// This is the only glXGetProcAddress variant not declared by glxext.h\nvoid (*glXGetProcAddressEXT(const GLubyte* procName))();\n\n\n#ifndef GLXBadProfileARB\n #define GLXBadProfileARB 13\n#endif\n\n\n// Returns the specified attribute of the specified GLXFBConfig\n//\nstatic int getFBConfigAttrib(GLXFBConfig fbconfig, int attrib)\n{\n    int value;\n    glXGetFBConfigAttrib(_glfw.x11.display, fbconfig, attrib, &value);\n    return value;\n}\n\n// Return a list of available and usable framebuffer configs\n//\nstatic GLboolean chooseFBConfig(const _GLFWfbconfig* desired, GLXFBConfig* result)\n{\n    GLXFBConfig* nativeConfigs;\n    _GLFWfbconfig* usableConfigs;\n    const _GLFWfbconfig* closest;\n    int i, nativeCount, usableCount;\n    const char* vendor;\n    GLboolean trustWindowBit = GL_TRUE;\n\n    vendor = glXGetClientString(_glfw.x11.display, GLX_VENDOR);\n    if (strcmp(vendor, \"Chromium\") == 0)\n    {\n        // HACK: This is a (hopefully temporary) workaround for Chromium\n        //       (VirtualBox GL) not setting the window bit on any GLXFBConfigs\n        trustWindowBit = GL_FALSE;\n    }\n\n    nativeConfigs = glXGetFBConfigs(_glfw.x11.display, _glfw.x11.screen,\n                                    &nativeCount);\n    if (!nativeCount)\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE, \"GLX: No GLXFBConfigs returned\");\n        return GL_FALSE;\n    }\n\n    usableConfigs = calloc(nativeCount, sizeof(_GLFWfbconfig));\n    usableCount = 0;\n\n    for (i = 0;  i < nativeCount;  i++)\n    {\n        const GLXFBConfig n = nativeConfigs[i];\n        _GLFWfbconfig* u = usableConfigs + usableCount;\n\n        if (!getFBConfigAttrib(n, GLX_VISUAL_ID))\n        {\n            // Only consider GLXFBConfigs with associated visuals\n            continue;\n        }\n\n        if (!(getFBConfigAttrib(n, GLX_RENDER_TYPE) & GLX_RGBA_BIT))\n        {\n            // Only consider RGBA GLXFBConfigs\n            continue;\n        }\n\n        if (!(getFBConfigAttrib(n, GLX_DRAWABLE_TYPE) & GLX_WINDOW_BIT))\n        {\n            if (trustWindowBit)\n            {\n                // Only consider window GLXFBConfigs\n                continue;\n            }\n        }\n\n        u->redBits = getFBConfigAttrib(n, GLX_RED_SIZE);\n        u->greenBits = getFBConfigAttrib(n, GLX_GREEN_SIZE);\n        u->blueBits = getFBConfigAttrib(n, GLX_BLUE_SIZE);\n\n        u->alphaBits = getFBConfigAttrib(n, GLX_ALPHA_SIZE);\n        u->depthBits = getFBConfigAttrib(n, GLX_DEPTH_SIZE);\n        u->stencilBits = getFBConfigAttrib(n, GLX_STENCIL_SIZE);\n\n        u->accumRedBits = getFBConfigAttrib(n, GLX_ACCUM_RED_SIZE);\n        u->accumGreenBits = getFBConfigAttrib(n, GLX_ACCUM_GREEN_SIZE);\n        u->accumBlueBits = getFBConfigAttrib(n, GLX_ACCUM_BLUE_SIZE);\n        u->accumAlphaBits = getFBConfigAttrib(n, GLX_ACCUM_ALPHA_SIZE);\n\n        u->auxBuffers = getFBConfigAttrib(n, GLX_AUX_BUFFERS);\n\n        if (getFBConfigAttrib(n, GLX_STEREO))\n            u->stereo = GL_TRUE;\n        if (getFBConfigAttrib(n, GLX_DOUBLEBUFFER))\n            u->doublebuffer = GL_TRUE;\n\n        if (_glfw.glx.ARB_multisample)\n            u->samples = getFBConfigAttrib(n, GLX_SAMPLES);\n\n        if (_glfw.glx.ARB_framebuffer_sRGB)\n            u->sRGB = getFBConfigAttrib(n, GLX_FRAMEBUFFER_SRGB_CAPABLE_ARB);\n\n        u->glx = n;\n        usableCount++;\n    }\n\n    closest = _glfwChooseFBConfig(desired, usableConfigs, usableCount);\n    if (closest)\n        *result = closest->glx;\n\n    XFree(nativeConfigs);\n    free(usableConfigs);\n\n    return closest ? GL_TRUE : GL_FALSE;\n}\n\n// Create the OpenGL context using legacy API\n//\nstatic GLXContext createLegacyContext(_GLFWwindow* window,\n                                      GLXFBConfig fbconfig,\n                                      GLXContext share)\n{\n    return glXCreateNewContext(_glfw.x11.display,\n                               fbconfig,\n                               GLX_RGBA_TYPE,\n                               share,\n                               True);\n}\n\n\n//////////////////////////////////////////////////////////////////////////\n//////                       GLFW internal API                      //////\n//////////////////////////////////////////////////////////////////////////\n\n// Initialize GLX\n//\nint _glfwInitContextAPI(void)\n{\n    if (!_glfwInitTLS())\n        return GL_FALSE;\n\n#ifdef _GLFW_DLOPEN_LIBGL\n    _glfw.glx.libGL = dlopen(\"libGL.so.1\", RTLD_LAZY | RTLD_GLOBAL);\n    if (!_glfw.glx.libGL)\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE, \"GLX: Failed to find libGL\");\n        return GL_FALSE;\n    }\n#endif\n\n    if (!glXQueryExtension(_glfw.x11.display,\n                           &_glfw.glx.errorBase,\n                           &_glfw.glx.eventBase))\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE, \"GLX: GLX extension not found\");\n        return GL_FALSE;\n    }\n\n    if (!glXQueryVersion(_glfw.x11.display,\n                         &_glfw.glx.versionMajor,\n                         &_glfw.glx.versionMinor))\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE,\n                        \"GLX: Failed to query GLX version\");\n        return GL_FALSE;\n    }\n\n    if (_glfw.glx.versionMajor == 1 && _glfw.glx.versionMinor < 3)\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE,\n                        \"GLX: GLX version 1.3 is required\");\n        return GL_FALSE;\n    }\n\n    if (_glfwPlatformExtensionSupported(\"GLX_EXT_swap_control\"))\n    {\n        _glfw.glx.SwapIntervalEXT = (PFNGLXSWAPINTERVALEXTPROC)\n            _glfwPlatformGetProcAddress(\"glXSwapIntervalEXT\");\n\n        if (_glfw.glx.SwapIntervalEXT)\n            _glfw.glx.EXT_swap_control = GL_TRUE;\n    }\n\n    if (_glfwPlatformExtensionSupported(\"GLX_SGI_swap_control\"))\n    {\n        _glfw.glx.SwapIntervalSGI = (PFNGLXSWAPINTERVALSGIPROC)\n            _glfwPlatformGetProcAddress(\"glXSwapIntervalSGI\");\n\n        if (_glfw.glx.SwapIntervalSGI)\n            _glfw.glx.SGI_swap_control = GL_TRUE;\n    }\n\n    if (_glfwPlatformExtensionSupported(\"GLX_MESA_swap_control\"))\n    {\n        _glfw.glx.SwapIntervalMESA = (PFNGLXSWAPINTERVALMESAPROC)\n            _glfwPlatformGetProcAddress(\"glXSwapIntervalMESA\");\n\n        if (_glfw.glx.SwapIntervalMESA)\n            _glfw.glx.MESA_swap_control = GL_TRUE;\n    }\n\n    if (_glfwPlatformExtensionSupported(\"GLX_ARB_multisample\"))\n        _glfw.glx.ARB_multisample = GL_TRUE;\n\n    if (_glfwPlatformExtensionSupported(\"GLX_ARB_framebuffer_sRGB\"))\n        _glfw.glx.ARB_framebuffer_sRGB = GL_TRUE;\n\n    if (_glfwPlatformExtensionSupported(\"GLX_ARB_create_context\"))\n    {\n        _glfw.glx.CreateContextAttribsARB = (PFNGLXCREATECONTEXTATTRIBSARBPROC)\n            _glfwPlatformGetProcAddress(\"glXCreateContextAttribsARB\");\n\n        if (_glfw.glx.CreateContextAttribsARB)\n            _glfw.glx.ARB_create_context = GL_TRUE;\n    }\n\n    if (_glfwPlatformExtensionSupported(\"GLX_ARB_create_context_robustness\"))\n        _glfw.glx.ARB_create_context_robustness = GL_TRUE;\n\n    if (_glfwPlatformExtensionSupported(\"GLX_ARB_create_context_profile\"))\n        _glfw.glx.ARB_create_context_profile = GL_TRUE;\n\n    if (_glfwPlatformExtensionSupported(\"GLX_EXT_create_context_es2_profile\"))\n        _glfw.glx.EXT_create_context_es2_profile = GL_TRUE;\n\n    if (_glfwPlatformExtensionSupported(\"GLX_ARB_context_flush_control\"))\n        _glfw.glx.ARB_context_flush_control = GL_TRUE;\n\n    return GL_TRUE;\n}\n\n// Terminate GLX\n//\nvoid _glfwTerminateContextAPI(void)\n{\n    // Unload libGL.so if necessary\n#ifdef _GLFW_DLOPEN_LIBGL\n    if (_glfw.glx.libGL != NULL)\n    {\n        dlclose(_glfw.glx.libGL);\n        _glfw.glx.libGL = NULL;\n    }\n#endif\n\n    _glfwTerminateTLS();\n}\n\n#define setGLXattrib(attribName, attribValue) \\\n{ \\\n    attribs[index++] = attribName; \\\n    attribs[index++] = attribValue; \\\n    assert((size_t) index < sizeof(attribs) / sizeof(attribs[0])); \\\n}\n\n// Create the OpenGL or OpenGL ES context\n//\nint _glfwCreateContext(_GLFWwindow* window,\n                       const _GLFWctxconfig* ctxconfig,\n                       const _GLFWfbconfig* fbconfig)\n{\n    int attribs[40];\n    GLXFBConfig native;\n    GLXContext share = NULL;\n\n    if (ctxconfig->share)\n        share = ctxconfig->share->glx.context;\n\n    if (!chooseFBConfig(fbconfig, &native))\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"GLX: Failed to find a suitable GLXFBConfig\");\n        return GL_FALSE;\n    }\n\n    // Retrieve the corresponding visual\n    window->glx.visual = glXGetVisualFromFBConfig(_glfw.x11.display, native);\n    if (!window->glx.visual)\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"GLX: Failed to retrieve visual for GLXFBConfig\");\n        return GL_FALSE;\n    }\n\n    if (ctxconfig->api == GLFW_OPENGL_ES_API)\n    {\n        if (!_glfw.glx.ARB_create_context ||\n            !_glfw.glx.ARB_create_context_profile ||\n            !_glfw.glx.EXT_create_context_es2_profile)\n        {\n            _glfwInputError(GLFW_API_UNAVAILABLE,\n                            \"GLX: OpenGL ES requested but GLX_EXT_create_context_es2_profile is unavailable\");\n            return GL_FALSE;\n        }\n    }\n\n    if (ctxconfig->forward)\n    {\n        if (!_glfw.glx.ARB_create_context)\n        {\n            _glfwInputError(GLFW_VERSION_UNAVAILABLE,\n                            \"GLX: Forward compatibility requested but GLX_ARB_create_context_profile is unavailable\");\n            return GL_FALSE;\n        }\n    }\n\n    if (ctxconfig->profile)\n    {\n        if (!_glfw.glx.ARB_create_context ||\n            !_glfw.glx.ARB_create_context_profile)\n        {\n            _glfwInputError(GLFW_VERSION_UNAVAILABLE,\n                            \"GLX: An OpenGL profile requested but GLX_ARB_create_context_profile is unavailable\");\n            return GL_FALSE;\n        }\n    }\n\n    _glfwGrabXErrorHandler();\n\n    if (_glfw.glx.ARB_create_context)\n    {\n        int index = 0, mask = 0, flags = 0, strategy = 0;\n\n        if (ctxconfig->api == GLFW_OPENGL_API)\n        {\n            if (ctxconfig->forward)\n                flags |= GLX_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB;\n\n            if (ctxconfig->profile)\n            {\n                if (ctxconfig->profile == GLFW_OPENGL_CORE_PROFILE)\n                    mask |= GLX_CONTEXT_CORE_PROFILE_BIT_ARB;\n                else if (ctxconfig->profile == GLFW_OPENGL_COMPAT_PROFILE)\n                    mask |= GLX_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB;\n            }\n        }\n        else\n            mask |= GLX_CONTEXT_ES2_PROFILE_BIT_EXT;\n\n        if (ctxconfig->debug)\n            flags |= GLX_CONTEXT_DEBUG_BIT_ARB;\n\n        if (ctxconfig->robustness)\n        {\n            if (_glfw.glx.ARB_create_context_robustness)\n            {\n                if (ctxconfig->robustness == GLFW_NO_RESET_NOTIFICATION)\n                    strategy = GLX_NO_RESET_NOTIFICATION_ARB;\n                else if (ctxconfig->robustness == GLFW_LOSE_CONTEXT_ON_RESET)\n                    strategy = GLX_LOSE_CONTEXT_ON_RESET_ARB;\n\n                flags |= GLX_CONTEXT_ROBUST_ACCESS_BIT_ARB;\n            }\n        }\n\n        if (ctxconfig->release)\n        {\n            if (_glfw.glx.ARB_context_flush_control)\n            {\n                if (ctxconfig->release == GLFW_RELEASE_BEHAVIOR_NONE)\n                {\n                    setGLXattrib(GLX_CONTEXT_RELEASE_BEHAVIOR_ARB,\n                                 GLX_CONTEXT_RELEASE_BEHAVIOR_NONE_ARB);\n                }\n                else if (ctxconfig->release == GLFW_RELEASE_BEHAVIOR_FLUSH)\n                {\n                    setGLXattrib(GLX_CONTEXT_RELEASE_BEHAVIOR_ARB,\n                                 GLX_CONTEXT_RELEASE_BEHAVIOR_FLUSH_ARB);\n                }\n            }\n        }\n\n        if (ctxconfig->major != 1 || ctxconfig->minor != 0)\n        {\n            // NOTE: Only request an explicitly versioned context when\n            //       necessary, as explicitly requesting version 1.0 does not\n            //       always return the highest available version\n\n            setGLXattrib(GLX_CONTEXT_MAJOR_VERSION_ARB, ctxconfig->major);\n            setGLXattrib(GLX_CONTEXT_MINOR_VERSION_ARB, ctxconfig->minor);\n        }\n\n        if (mask)\n            setGLXattrib(GLX_CONTEXT_PROFILE_MASK_ARB, mask);\n\n        if (flags)\n            setGLXattrib(GLX_CONTEXT_FLAGS_ARB, flags);\n\n        if (strategy)\n            setGLXattrib(GLX_CONTEXT_RESET_NOTIFICATION_STRATEGY_ARB, strategy);\n\n        setGLXattrib(None, None);\n\n        window->glx.context =\n            _glfw.glx.CreateContextAttribsARB(_glfw.x11.display,\n                                              native,\n                                              share,\n                                              True,\n                                              attribs);\n\n        if (!window->glx.context)\n        {\n            // HACK: This is a fallback for the broken Mesa implementation of\n            //       GLX_ARB_create_context_profile, which fails default 1.0\n            //       context creation with a GLXBadProfileARB error in violation\n            //       of the extension spec\n            if (_glfw.x11.errorCode == _glfw.glx.errorBase + GLXBadProfileARB &&\n                ctxconfig->api == GLFW_OPENGL_API &&\n                ctxconfig->profile == GLFW_OPENGL_ANY_PROFILE &&\n                ctxconfig->forward == GL_FALSE)\n            {\n                window->glx.context = createLegacyContext(window, native, share);\n            }\n        }\n    }\n    else\n        window->glx.context = createLegacyContext(window, native, share);\n\n    _glfwReleaseXErrorHandler();\n\n    if (!window->glx.context)\n    {\n        _glfwInputXError(GLFW_VERSION_UNAVAILABLE, \"GLX: Failed to create context\");\n        return GL_FALSE;\n    }\n\n    return GL_TRUE;\n}\n\n#undef setGLXattrib\n\n// Destroy the OpenGL context\n//\nvoid _glfwDestroyContext(_GLFWwindow* window)\n{\n    if (window->glx.visual)\n    {\n        XFree(window->glx.visual);\n        window->glx.visual = NULL;\n    }\n\n    if (window->glx.context)\n    {\n        glXDestroyContext(_glfw.x11.display, window->glx.context);\n        window->glx.context = NULL;\n    }\n}\n\n\n//////////////////////////////////////////////////////////////////////////\n//////                       GLFW platform API                      //////\n//////////////////////////////////////////////////////////////////////////\n\nvoid _glfwPlatformMakeContextCurrent(_GLFWwindow* window)\n{\n    if (window)\n    {\n        glXMakeCurrent(_glfw.x11.display,\n                       window->x11.handle,\n                       window->glx.context);\n    }\n    else\n        glXMakeCurrent(_glfw.x11.display, None, NULL);\n\n    _glfwSetCurrentContext(window);\n}\n\nvoid _glfwPlatformSwapBuffers(_GLFWwindow* window)\n{\n    glXSwapBuffers(_glfw.x11.display, window->x11.handle);\n}\n\nvoid _glfwPlatformSwapInterval(int interval)\n{\n    _GLFWwindow* window = _glfwPlatformGetCurrentContext();\n\n    if (_glfw.glx.EXT_swap_control)\n    {\n        _glfw.glx.SwapIntervalEXT(_glfw.x11.display,\n                                  window->x11.handle,\n                                  interval);\n    }\n    else if (_glfw.glx.MESA_swap_control)\n        _glfw.glx.SwapIntervalMESA(interval);\n    else if (_glfw.glx.SGI_swap_control)\n    {\n        if (interval > 0)\n            _glfw.glx.SwapIntervalSGI(interval);\n    }\n}\n\nint _glfwPlatformExtensionSupported(const char* extension)\n{\n    const GLubyte* extensions;\n\n    // Get list of GLX extensions\n    extensions = (const GLubyte*) glXQueryExtensionsString(_glfw.x11.display,\n                                                           _glfw.x11.screen);\n    if (extensions != NULL)\n    {\n        if (_glfwStringInExtensionString(extension, extensions))\n            return GL_TRUE;\n    }\n\n    return GL_FALSE;\n}\n\nGLFWglproc _glfwPlatformGetProcAddress(const char* procname)\n{\n    return _glfw_glXGetProcAddress((const GLubyte*) procname);\n}\n\n\n//////////////////////////////////////////////////////////////////////////\n//////                        GLFW native API                       //////\n//////////////////////////////////////////////////////////////////////////\n\nGLFWAPI GLXContext glfwGetGLXContext(GLFWwindow* handle)\n{\n    _GLFWwindow* window = (_GLFWwindow*) handle;\n    _GLFW_REQUIRE_INIT_OR_RETURN(NULL);\n    return window->glx.context;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-glfw-3.1.1-vdjqhn35kmytrs37763btj7r4qzvf3wi/spack-src/src/nsgl_context.h": "//========================================================================\n// GLFW 3.1 OS X - www.glfw.org\n//------------------------------------------------------------------------\n// Copyright (c) 2009-2010 Camilla Berglund <elmindreda@elmindreda.org>\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would\n//    be appreciated but is not required.\n//\n// 2. Altered source versions must be plainly marked as such, and must not\n//    be misrepresented as being the original software.\n//\n// 3. This notice may not be removed or altered from any source\n//    distribution.\n//\n//========================================================================\n\n#ifndef _nsgl_context_h_\n#define _nsgl_context_h_\n\n#define _GLFW_PLATFORM_FBCONFIG\n#define _GLFW_PLATFORM_CONTEXT_STATE            _GLFWcontextNSGL nsgl\n#define _GLFW_PLATFORM_LIBRARY_CONTEXT_STATE    _GLFWlibraryNSGL nsgl\n\n\n// NSGL-specific per-context data\n//\ntypedef struct _GLFWcontextNSGL\n{\n    id           pixelFormat;\n    id\t         context;\n\n} _GLFWcontextNSGL;\n\n\n// NSGL-specific global data\n//\ntypedef struct _GLFWlibraryNSGL\n{\n    // dlopen handle for OpenGL.framework (for glfwGetProcAddress)\n    void*           framework;\n\n} _GLFWlibraryNSGL;\n\n\nint _glfwInitContextAPI(void);\nvoid _glfwTerminateContextAPI(void);\nint _glfwCreateContext(_GLFWwindow* window,\n                       const _GLFWctxconfig* ctxconfig,\n                       const _GLFWfbconfig* fbconfig);\nvoid _glfwDestroyContext(_GLFWwindow* window);\n\n#endif // _nsgl_context_h_\n",
        "/tmp/vanessa/spack-stage/spack-stage-glfw-3.1.1-vdjqhn35kmytrs37763btj7r4qzvf3wi/spack-src/src/glfw_config.h.in": "//========================================================================\n// GLFW 3.1 - www.glfw.org\n//------------------------------------------------------------------------\n// Copyright (c) 2010 Camilla Berglund <elmindreda@elmindreda.org>\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would\n//    be appreciated but is not required.\n//\n// 2. Altered source versions must be plainly marked as such, and must not\n//    be misrepresented as being the original software.\n//\n// 3. This notice may not be removed or altered from any source\n//    distribution.\n//\n//========================================================================\n// As glfw_config.h.in, this file is used by CMake to produce the\n// glfw_config.h configuration header file.  If you are adding a feature\n// requiring conditional compilation, this is where to add the macro.\n//========================================================================\n// As glfw_config.h, this file defines compile-time option macros for a\n// specific platform and development environment.  If you are using the\n// GLFW CMake files, modify glfw_config.h.in instead of this file.  If you\n// are using your own build system, make this file define the appropriate\n// macros in whatever way is suitable.\n//========================================================================\n\n// Define this to 1 if building GLFW for X11\n#cmakedefine _GLFW_X11\n// Define this to 1 if building GLFW for Win32\n#cmakedefine _GLFW_WIN32\n// Define this to 1 if building GLFW for Cocoa\n#cmakedefine _GLFW_COCOA\n// Define this to 1 if building GLFW for Wayland\n#cmakedefine _GLFW_WAYLAND\n// Define this to 1 if building GLFW for Mir\n#cmakedefine _GLFW_MIR\n\n// Define this to 1 if building GLFW for EGL\n#cmakedefine _GLFW_EGL\n// Define this to 1 if building GLFW for GLX\n#cmakedefine _GLFW_GLX\n// Define this to 1 if building GLFW for WGL\n#cmakedefine _GLFW_WGL\n// Define this to 1 if building GLFW for NSGL\n#cmakedefine _GLFW_NSGL\n\n// Define this to 1 if building as a shared library / dynamic library / DLL\n#cmakedefine _GLFW_BUILD_DLL\n\n// Define this to 1 if glfwSwapInterval should ignore DWM compositing status\n#cmakedefine _GLFW_USE_DWM_SWAP_INTERVAL\n// Define this to 1 to force use of high-performance GPU on Optimus systems\n#cmakedefine _GLFW_USE_OPTIMUS_HPG\n\n// Define this to 1 if the XInput X11 extension is available\n#cmakedefine _GLFW_HAS_XINPUT\n// Define this to 1 if the Xxf86vm X11 extension is available\n#cmakedefine _GLFW_HAS_XF86VM\n// Define this to 1 if glXGetProcAddress is available\n#cmakedefine _GLFW_HAS_GLXGETPROCADDRESS\n// Define this to 1 if glXGetProcAddressARB is available\n#cmakedefine _GLFW_HAS_GLXGETPROCADDRESSARB\n// Define this to 1 if glXGetProcAddressEXT is available\n#cmakedefine _GLFW_HAS_GLXGETPROCADDRESSEXT\n// Define this to 1 if dlopen is available\n#cmakedefine _GLFW_HAS_DLOPEN\n\n// Define this to 1 if glfwInit should change the current directory\n#cmakedefine _GLFW_USE_CHDIR\n// Define this to 1 if glfwCreateWindow should populate the menu bar\n#cmakedefine _GLFW_USE_MENUBAR\n// Define this to 1 if windows should use full resolution on Retina displays\n#cmakedefine _GLFW_USE_RETINA\n\n// Define this to 1 if using OpenGL as the client library\n#cmakedefine _GLFW_USE_OPENGL\n// Define this to 1 if using OpenGL ES 1.1 as the client library\n#cmakedefine _GLFW_USE_GLESV1\n// Define this to 1 if using OpenGL ES 2.0 as the client library\n#cmakedefine _GLFW_USE_GLESV2\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-glfw-3.1.1-vdjqhn35kmytrs37763btj7r4qzvf3wi/spack-src/src/glx_context.h": "//========================================================================\n// GLFW 3.1 GLX - www.glfw.org\n//------------------------------------------------------------------------\n// Copyright (c) 2002-2006 Marcus Geelnard\n// Copyright (c) 2006-2010 Camilla Berglund <elmindreda@elmindreda.org>\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would\n//    be appreciated but is not required.\n//\n// 2. Altered source versions must be plainly marked as such, and must not\n//    be misrepresented as being the original software.\n//\n// 3. This notice may not be removed or altered from any source\n//    distribution.\n//\n//========================================================================\n\n#ifndef _glx_context_h_\n#define _glx_context_h_\n\n#define GLX_GLXEXT_LEGACY\n#include <GL/glx.h>\n\n// This path may need to be changed if you build GLFW using your own setup\n// We ship and use our own copy of glxext.h since GLFW uses fairly new\n// extensions and not all operating systems come with an up-to-date version\n#include \"../deps/GL/glxext.h\"\n\n// Do we have support for dlopen/dlsym?\n#if defined(_GLFW_HAS_DLOPEN)\n #include <dlfcn.h>\n#endif\n\n// We support four different ways for getting addresses for GL/GLX\n// extension functions: glXGetProcAddress, glXGetProcAddressARB,\n// glXGetProcAddressEXT, and dlsym\n#if defined(_GLFW_HAS_GLXGETPROCADDRESSARB)\n #define _glfw_glXGetProcAddress(x) glXGetProcAddressARB(x)\n#elif defined(_GLFW_HAS_GLXGETPROCADDRESS)\n #define _glfw_glXGetProcAddress(x) glXGetProcAddress(x)\n#elif defined(_GLFW_HAS_GLXGETPROCADDRESSEXT)\n #define _glfw_glXGetProcAddress(x) glXGetProcAddressEXT(x)\n#elif defined(_GLFW_HAS_DLOPEN)\n #define _glfw_glXGetProcAddress(x) dlsym(_glfw.glx.libGL, x)\n #define _GLFW_DLOPEN_LIBGL\n#else\n #error \"No OpenGL entry point retrieval mechanism was enabled\"\n#endif\n\n#define _GLFW_PLATFORM_FBCONFIG                 GLXFBConfig     glx\n#define _GLFW_PLATFORM_CONTEXT_STATE            _GLFWcontextGLX glx\n#define _GLFW_PLATFORM_LIBRARY_CONTEXT_STATE    _GLFWlibraryGLX glx\n\n#ifndef GLX_MESA_swap_control\ntypedef int (*PFNGLXSWAPINTERVALMESAPROC)(int);\n#endif\n\n\n// GLX-specific per-context data\n//\ntypedef struct _GLFWcontextGLX\n{\n    // Rendering context\n    GLXContext      context;\n    // Visual of selected GLXFBConfig\n    XVisualInfo*    visual;\n\n} _GLFWcontextGLX;\n\n\n// GLX-specific global data\n//\ntypedef struct _GLFWlibraryGLX\n{\n    int             versionMajor, versionMinor;\n    int             eventBase;\n    int             errorBase;\n\n    // GLX extensions\n    PFNGLXSWAPINTERVALSGIPROC             SwapIntervalSGI;\n    PFNGLXSWAPINTERVALEXTPROC             SwapIntervalEXT;\n    PFNGLXSWAPINTERVALMESAPROC            SwapIntervalMESA;\n    PFNGLXCREATECONTEXTATTRIBSARBPROC     CreateContextAttribsARB;\n    GLboolean       SGI_swap_control;\n    GLboolean       EXT_swap_control;\n    GLboolean       MESA_swap_control;\n    GLboolean       ARB_multisample;\n    GLboolean       ARB_framebuffer_sRGB;\n    GLboolean       ARB_create_context;\n    GLboolean       ARB_create_context_profile;\n    GLboolean       ARB_create_context_robustness;\n    GLboolean       EXT_create_context_es2_profile;\n    GLboolean       ARB_context_flush_control;\n\n#if defined(_GLFW_DLOPEN_LIBGL)\n    // dlopen handle for libGL.so (for glfwGetProcAddress)\n    void*           libGL;\n#endif\n\n} _GLFWlibraryGLX;\n\n\nint _glfwInitContextAPI(void);\nvoid _glfwTerminateContextAPI(void);\nint _glfwCreateContext(_GLFWwindow* window,\n                       const _GLFWctxconfig* ctxconfig,\n                       const _GLFWfbconfig* fbconfig);\nvoid _glfwDestroyContext(_GLFWwindow* window);\n\n#endif // _glx_context_h_\n",
        "/tmp/vanessa/spack-stage/spack-stage-glfw-3.1.1-vdjqhn35kmytrs37763btj7r4qzvf3wi/spack-src/src/egl_context.h": "//========================================================================\n// GLFW 3.1 EGL - www.glfw.org\n//------------------------------------------------------------------------\n// Copyright (c) 2002-2006 Marcus Geelnard\n// Copyright (c) 2006-2010 Camilla Berglund <elmindreda@elmindreda.org>\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would\n//    be appreciated but is not required.\n//\n// 2. Altered source versions must be plainly marked as such, and must not\n//    be misrepresented as being the original software.\n//\n// 3. This notice may not be removed or altered from any source\n//    distribution.\n//\n//========================================================================\n\n#ifndef _egl_context_h_\n#define _egl_context_h_\n\n#include <EGL/egl.h>\n\n// This path may need to be changed if you build GLFW using your own setup\n// We ship and use our own copy of eglext.h since GLFW uses fairly new\n// extensions and not all operating systems come with an up-to-date version\n#include \"../deps/EGL/eglext.h\"\n\n// Do we have support for dlopen/dlsym?\n#if defined(_GLFW_HAS_DLOPEN)\n #include <dlfcn.h>\n#endif\n\n#define _GLFW_PLATFORM_FBCONFIG                 EGLConfig       egl\n#define _GLFW_PLATFORM_CONTEXT_STATE            _GLFWcontextEGL egl\n#define _GLFW_PLATFORM_LIBRARY_CONTEXT_STATE    _GLFWlibraryEGL egl\n\n\n// EGL-specific per-context data\n//\ntypedef struct _GLFWcontextEGL\n{\n   EGLConfig      config;\n   EGLContext     context;\n   EGLSurface     surface;\n\n#if defined(_GLFW_X11)\n   XVisualInfo*   visual;\n#endif\n\n} _GLFWcontextEGL;\n\n\n// EGL-specific global data\n//\ntypedef struct _GLFWlibraryEGL\n{\n    EGLDisplay      display;\n    EGLint          versionMajor, versionMinor;\n\n    GLboolean       KHR_create_context;\n\n} _GLFWlibraryEGL;\n\n\nint _glfwInitContextAPI(void);\nvoid _glfwTerminateContextAPI(void);\nint _glfwCreateContext(_GLFWwindow* window,\n                       const _GLFWctxconfig* ctxconfig,\n                       const _GLFWfbconfig* fbconfig);\nvoid _glfwDestroyContext(_GLFWwindow* window);\nint _glfwAnalyzeContext(const _GLFWwindow* window,\n                        const _GLFWctxconfig* ctxconfig,\n                        const _GLFWfbconfig* fbconfig);\n\n#endif // _egl_context_h_\n",
        "/tmp/vanessa/spack-stage/spack-stage-glfw-3.1.1-vdjqhn35kmytrs37763btj7r4qzvf3wi/spack-src/docs/compile.dox": "/*!\n\n@page compile Compiling GLFW\n\n@tableofcontents\n\nThis is about compiling the GLFW library itself.  For information on how to\nbuild applications that use GLFW, see the @ref build guide.\n\n\n@section compile_cmake Using CMake\n\nGLFW uses [CMake](http://www.cmake.org/) to generate project files or makefiles\nfor a particular development environment.  If you are on a Unix-like system such\nas Linux or FreeBSD or have a package system like Fink, MacPorts, Cygwin or\nHomebrew, you can simply install its CMake package.  If not, you can download\ninstallers for Windows and OS X from the [CMake website](http://www.cmake.org/).\n\n@note CMake only generates project files or makefiles.  It does not compile the\nactual GLFW library.  To compile GLFW, first generate these files and then use\nthem in your chosen development environment to compile the actual GLFW library.\n\n\n@subsection compile_deps Dependencies\n\nOnce you have installed CMake, make sure that all other dependencies are\navailable.  On some platforms, GLFW needs a few additional packages to be\ninstalled.  See the section for your chosen platform and development environment\nbelow.\n\n\n@subsubsection compile_deps_msvc Dependencies for Visual C++ on Windows\n\nThe Microsoft Platform SDK that is installed along with Visual C++ already\ncontains all the necessary headers, link libraries and tools except for CMake.\nMove on to @ref compile_generate.\n\n\n@subsubsection compile_deps_mingw Dependencies for MinGW or MinGW-w64 on Windows\n\nBoth the MinGW and the MinGW-w64 packages already contain all the necessary\nheaders, link libraries and tools except for CMake.  Move on to @ref\ncompile_generate.\n\n\n@subsubsection compile_deps_mingw_cross Dependencies for MinGW or MinGW-w64 cross-compilation\n\nBoth Cygwin and many Linux distributions have MinGW or MinGW-w64 packages.  For\nexample, Cygwin has the `mingw64-i686-gcc` and `mingw64-x86_64-gcc` packages\nfor 32- and 64-bit version of MinGW-w64, while Debian GNU/Linux and derivatives\nlike Ubuntu have the `mingw-w64` package for both.\n\nGLFW has CMake toolchain files in the `CMake/` directory that allow for easy\ncross-compilation of Windows binaries.  To use these files you need to add a\nspecial parameter when generating the project files or makefiles:\n\n@code{.sh}\ncmake -DCMAKE_TOOLCHAIN_FILE=<toolchain-file> .\n@endcode\n\nThe exact toolchain file to use depends on the prefix used by the MinGW or\nMinGW-w64 binaries on your system.  You can usually see this in the /usr\ndirectory.  For example, both the Debian/Ubuntu and Cygwin MinGW-w64 packages\nhave `/usr/x86_64-w64-mingw32` for the 64-bit compilers, so the correct\ninvocation would be:\n\n@code{.sh}\ncmake -DCMAKE_TOOLCHAIN_FILE=CMake/x86_64-w64-mingw32.cmake .\n@endcode\n\nFor more details see the article\n[CMake Cross Compiling](http://www.paraview.org/Wiki/CMake_Cross_Compiling) on\nthe CMake wiki.\n\nOnce you have this set up, move on to @ref compile_generate.\n\n\n@subsubsection compile_deps_xcode Dependencies for Xcode on OS X\n\nXcode comes with all necessary tools except for CMake.  The required headers\nand libraries are included in the core OS X frameworks.  Xcode can be downloaded\nfrom the Mac App Store or from the ADC Member Center.\n\nOnce you have Xcode installed, move on to @ref compile_generate.\n\n\n@subsubsection compile_deps_x11 Dependencies for Linux and X11\n\nTo compile GLFW for X11, you need to have the X11 and OpenGL header packages\ninstalled, as well as the basic development tools like GCC and make.  For\nexample, on Ubuntu and other distributions based on Debian GNU/Linux, you need\nto install the `xorg-dev` and `libglu1-mesa-dev` packages.  The former pulls in\nall X.org header packages and the latter pulls in the Mesa OpenGL and GLU\npackages.  GLFW itself doesn't need or use GLU, but some of the examples do.\nNote that using header files and libraries from Mesa during compilation\n_will not_ tie your binaries to the Mesa implementation of OpenGL.\n\nOnce you have installed the necessary packages, move on to @ref\ncompile_generate.\n\n\n@subsection compile_generate Generating build files with CMake\n\nOnce you have all necessary dependencies it is time to generate the project\nfiles or makefiles for your development environment.  CMake needs to know two\npaths for this: the path to the _root_ directory of the GLFW source tree (i.e.\n_not_ the `src` subdirectory) and the target path for the generated files and\ncompiled binaries.  If these are the same, it is called an in-tree build,\notherwise it is called an out-of-tree build.\n\nOne of several advantages of out-of-tree builds is that you can generate files\nand compile for different development environments using a single source tree.\n\n@note This section is about generating the project files or makefiles necessary\nto compile the GLFW library, not about compiling the actual library.\n\n\n@subsubsection compile_generate_cli Generating files with the CMake command-line tool\n\nTo make an in-tree build, enter the _root_ directory of the GLFW source tree\n(i.e. _not_ the `src` subdirectory) and run CMake.  The current directory is\nused as target path, while the path provided as an argument is used to find the\nsource tree.\n\n@code{.sh}\ncd <glfw-root-dir>\ncmake .\n@endcode\n\nTo make an out-of-tree build, make another directory, enter it and run CMake\nwith the (relative or absolute) path to the root of the source tree as an\nargument.\n\n@code{.sh}\ncd <glfw-root-dir>\nmkdir build\ncd build\ncmake ..\n@endcode\n\nOnce you have generated the project files or makefiles for your chosen\ndevelopment environment, move on to @ref compile_compile.\n\n\n@subsubsection compile_generate_gui Generating files with the CMake GUI\n\nIf you are using the GUI version, choose the root of the GLFW source tree as\nsource location and the same directory or another, empty directory as the\ndestination for binaries.  Choose _Configure_, change any options you wish to,\n_Configure_ again to let the changes take effect and then _Generate_.\n\nOnce you have generated the project files or makefiles for your chosen\ndevelopment environment, move on to @ref compile_compile.\n\n\n@subsection compile_compile Compiling the library\n\nYou should now have all required dependencies and the project files or makefiles\nnecessary to compile GLFW.  Go ahead and compile the actual GLFW library with\nthese files, as you would with any other project.\n\nOnce the GLFW library is compiled, you are ready to build your applications,\nlinking it to the GLFW library.  See the @ref build guide for more information.\n\n\n@subsection compile_options CMake options\n\nThe CMake files for GLFW provide a number of options, although not all are\navailable on all supported platforms.  Some of these are de facto standards\namong projects using CMake and so have no `GLFW_` prefix.\n\nIf you are using the GUI version of CMake, these are listed and can be changed\nfrom there.  If you are using the command-line version, use the `ccmake` tool.\nSome package systems like Ubuntu and other distributions based on Debian\nGNU/Linux have this tool in a separate `cmake-curses-gui` package.\n\n\n@subsubsection compile_options_shared Shared CMake options\n\n`BUILD_SHARED_LIBS` determines whether GLFW is built as a static\nlibrary or as a DLL / shared library / dynamic library.\n\n`LIB_SUFFIX` affects where the GLFW shared /dynamic library is installed.  If it\nis empty, it is installed to `${CMAKE_INSTALL_PREFIX}/lib`.  If it is set to\n`64`, it is installed to `${CMAKE_INSTALL_PREFIX}/lib64`.\n\n`GLFW_CLIENT_LIBRARY` determines which client API library to use.  If set to\n`opengl` the OpenGL library is used, if set to `glesv1` for the OpenGL ES 1.x\nlibrary is used, or if set to `glesv2` the OpenGL ES 2.0 library is used.  The\nselected library and its header files must be present on the system for this to\nwork.\n\n`GLFW_BUILD_EXAMPLES` determines whether the GLFW examples are built\nalong with the library.\n\n`GLFW_BUILD_TESTS` determines whether the GLFW test programs are\nbuilt along with the library.\n\n`GLFW_BUILD_DOCS` determines whether the GLFW documentation is built along with\nthe library.\n\n\n@subsubsection compile_options_osx OS X specific CMake options\n\n`GLFW_USE_CHDIR` determines whether `glfwInit` changes the current\ndirectory of bundled applications to the `Contents/Resources` directory.\n\n`GLFW_USE_MENUBAR` determines whether the first call to\n`glfwCreateWindow` sets up a minimal menu bar.\n\n`GLFW_USE_RETINA` determines whether windows will use the full resolution of\nRetina displays.\n\n`GLFW_BUILD_UNIVERSAL` determines whether to build Universal Binaries.\n\n\n@subsubsection compile_options_win32 Windows specific CMake options\n\n`USE_MSVC_RUNTIME_LIBRARY_DLL` determines whether to use the DLL version or the\nstatic library version of the Visual C++ runtime library.  If set to `ON`, the\nDLL version of the Visual C++ library is used.  It is recommended to set this to\n`ON`, as this keeps the executable smaller and benefits from security and bug\nfix updates of the Visual C++ runtime.\n\n`GLFW_USE_DWM_SWAP_INTERVAL` determines whether the swap interval is set even\nwhen DWM compositing is enabled.  If this is `ON`, the swap interval is set even\nif DWM is enabled.  It is recommended to set this to `OFF`, as doing otherwise\ncan lead to severe jitter.\n\n`GLFW_USE_OPTIMUS_HPG` determines whether to export the `NvOptimusEnablement`\nsymbol, which forces the use of the high-performance GPU on Nvidia Optimus\nsystems.  This symbol needs to be exported by the EXE to be detected by the\ndriver, so the override will not work if GLFW is built as a DLL.  See _Enabling\nHigh Performance Graphics Rendering on Optimus Systems_ for more details.\n\n\n@subsubsection compile_options_egl EGL specific CMake options\n\n`GLFW_USE_EGL` determines whether to use EGL instead of the platform-specific\ncontext creation API.  Note that EGL is not yet provided on all supported\nplatforms.\n\n\n@section compile_manual Compiling GLFW manually\n\nIf you wish to compile GLFW without its CMake build environment then you will\nhave to do at least some of the platform detection yourself.  GLFW needs\na number of configuration macros to be defined in order to know what it's being\ncompiled for and has many optional, platform-specific ones for various features.\n\nWhen building with CMake, the `glfw_config.h` configuration header is generated\nbased on the current platform and CMake options.  The GLFW CMake environment\ndefines `_GLFW_USE_CONFIG_H`, which causes this header to be included by\n`internal.h`.  Without this macro, GLFW will expect the necessary configuration\nmacros to be defined on the command-line.\n\nThree macros _must_ be defined when compiling GLFW: one selecting the window\ncreation API, one selecting the context creation API and one client library.\nExactly one of each kind must be defined for GLFW to compile and link.\n\nThe window creation API is used to create windows, handle input, monitors, gamma\nramps and clipboard.  The options are:\n\n - `_GLFW_COCOA` to use the Cocoa frameworks\n - `_GLFW_WIN32` to use the Win32 API\n - `_GLFW_X11` to use the X Window System\n - `_GLFW_WAYLAND` to use the Wayland API (experimental and incomplete)\n - `_GLFW_MIR` to use the Mir API (experimental and incomplete)\n\nThe context creation API is used to enumerate pixel formats / framebuffer\nconfigurations and to create contexts.  The options are:\n\n - `_GLFW_NSGL` to use the Cocoa OpenGL framework\n - `_GLFW_WGL` to use the Win32 WGL API\n - `_GLFW_GLX` to use the X11 GLX API\n - `_GLFW_EGL` to use the EGL API\n\nWayland and Mir both require the EGL backend.\n\nThe client library is the one providing the OpenGL or OpenGL ES API, which is\nused by GLFW to probe the created context.  This is not the same thing as the\nclient API, as many desktop OpenGL client libraries now expose the OpenGL ES API\nthrough extensions.  The options are:\n\n - `_GLFW_USE_OPENGL` for the desktop OpenGL (opengl32.dll, libGL.so or\n   OpenGL.framework)\n - `_GLFW_USE_GLESV1` for OpenGL ES 1.x (experimental)\n - `_GLFW_USE_GLESV2` for OpenGL ES 2.x (experimental)\n\nNote that `_GLFW_USE_GLESV1` and `_GLFW_USE_GLESV2` may only be used with EGL,\nas the other context creation APIs do not interface with OpenGL ES client\nlibraries.\n\nIf you are building GLFW as a shared library / dynamic library / DLL then you\nmust also define `_GLFW_BUILD_DLL`.  Otherwise, you may not define it.\n\nIf you are using the X11 window creation API then you _must_ also select an entry\npoint retrieval mechanism.\n\n - `_GLFW_HAS_GLXGETPROCADDRESS` to use `glXGetProcAddress` (recommended)\n - `_GLFW_HAS_GLXGETPROCADDRESSARB` to use `glXGetProcAddressARB` (legacy)\n - `_GLFW_HAS_GLXGETPROCADDRESSEXT` to use `glXGetProcAddressEXT` (legacy)\n - `_GLFW_HAS_DLOPEN` to do manual retrieval with `dlopen` (fallback)\n\nIn addition, support for the following X11 extensions can be enabled:\n\n - `_GLFW_HAS_XINPUT` to use XInput2 for high-resolution cursor motion\n (recommended)\n\nIf you are using the Cocoa window creation API, the following options are\navailable:\n\n - `_GLFW_USE_CHDIR` to `chdir` to the `Resources` subdirectory of the\n   application bundle during @ref glfwInit (recommended)\n - `_GLFW_USE_MENUBAR` to create and populate the menu bar when the first window\n   is created (recommended)\n - `_GLFW_USE_RETINA` to have windows use the full resolution of Retina displays\n   (recommended)\n\n@note None of the @ref build_macros may be defined during the compilation of\nGLFW.  If you define any of these in your build files, make sure they are not\napplied to the GLFW sources.\n\n*/\n"
    },
    "skipped": [],
    "total_files": 135
}