{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-glfw-3.2.1-gkd54tstzvk3vujbh27j3m4waeirf4if/spack-src/src/egl_context.c": "//========================================================================\n// GLFW 3.2 EGL - www.glfw.org\n//------------------------------------------------------------------------\n// Copyright (c) 2002-2006 Marcus Geelnard\n// Copyright (c) 2006-2016 Camilla Berglund <elmindreda@glfw.org>\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would\n//    be appreciated but is not required.\n//\n// 2. Altered source versions must be plainly marked as such, and must not\n//    be misrepresented as being the original software.\n//\n// 3. This notice may not be removed or altered from any source\n//    distribution.\n//\n//========================================================================\n\n#include \"internal.h\"\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n\n\n// Return a description of the specified EGL error\n//\nstatic const char* getEGLErrorString(EGLint error)\n{\n    switch (error)\n    {\n        case EGL_SUCCESS:\n            return \"Success\";\n        case EGL_NOT_INITIALIZED:\n            return \"EGL is not or could not be initialized\";\n        case EGL_BAD_ACCESS:\n            return \"EGL cannot access a requested resource\";\n        case EGL_BAD_ALLOC:\n            return \"EGL failed to allocate resources for the requested operation\";\n        case EGL_BAD_ATTRIBUTE:\n            return \"An unrecognized attribute or attribute value was passed in the attribute list\";\n        case EGL_BAD_CONTEXT:\n            return \"An EGLContext argument does not name a valid EGL rendering context\";\n        case EGL_BAD_CONFIG:\n            return \"An EGLConfig argument does not name a valid EGL frame buffer configuration\";\n        case EGL_BAD_CURRENT_SURFACE:\n            return \"The current surface of the calling thread is a window, pixel buffer or pixmap that is no longer valid\";\n        case EGL_BAD_DISPLAY:\n            return \"An EGLDisplay argument does not name a valid EGL display connection\";\n        case EGL_BAD_SURFACE:\n            return \"An EGLSurface argument does not name a valid surface configured for GL rendering\";\n        case EGL_BAD_MATCH:\n            return \"Arguments are inconsistent\";\n        case EGL_BAD_PARAMETER:\n            return \"One or more argument values are invalid\";\n        case EGL_BAD_NATIVE_PIXMAP:\n            return \"A NativePixmapType argument does not refer to a valid native pixmap\";\n        case EGL_BAD_NATIVE_WINDOW:\n            return \"A NativeWindowType argument does not refer to a valid native window\";\n        case EGL_CONTEXT_LOST:\n            return \"The application must destroy all contexts and reinitialise\";\n        default:\n            return \"ERROR: UNKNOWN EGL ERROR\";\n    }\n}\n\n// Returns the specified attribute of the specified EGLConfig\n//\nstatic int getEGLConfigAttrib(EGLConfig config, int attrib)\n{\n    int value;\n    eglGetConfigAttrib(_glfw.egl.display, config, attrib, &value);\n    return value;\n}\n\n// Return the EGLConfig most closely matching the specified hints\n//\nstatic GLFWbool chooseEGLConfig(const _GLFWctxconfig* ctxconfig,\n                                const _GLFWfbconfig* desired,\n                                EGLConfig* result)\n{\n    EGLConfig* nativeConfigs;\n    _GLFWfbconfig* usableConfigs;\n    const _GLFWfbconfig* closest;\n    int i, nativeCount, usableCount;\n\n    eglGetConfigs(_glfw.egl.display, NULL, 0, &nativeCount);\n    if (!nativeCount)\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE, \"EGL: No EGLConfigs returned\");\n        return GLFW_FALSE;\n    }\n\n    nativeConfigs = calloc(nativeCount, sizeof(EGLConfig));\n    eglGetConfigs(_glfw.egl.display, nativeConfigs, nativeCount, &nativeCount);\n\n    usableConfigs = calloc(nativeCount, sizeof(_GLFWfbconfig));\n    usableCount = 0;\n\n    for (i = 0;  i < nativeCount;  i++)\n    {\n        const EGLConfig n = nativeConfigs[i];\n        _GLFWfbconfig* u = usableConfigs + usableCount;\n\n        // Only consider RGB(A) EGLConfigs\n        if (!(getEGLConfigAttrib(n, EGL_COLOR_BUFFER_TYPE) & EGL_RGB_BUFFER))\n            continue;\n\n        // Only consider window EGLConfigs\n        if (!(getEGLConfigAttrib(n, EGL_SURFACE_TYPE) & EGL_WINDOW_BIT))\n            continue;\n\n#if defined(_GLFW_X11)\n        // Only consider EGLConfigs with associated Visuals\n        if (!getEGLConfigAttrib(n, EGL_NATIVE_VISUAL_ID))\n            continue;\n#endif // _GLFW_X11\n\n        if (ctxconfig->client == GLFW_OPENGL_ES_API)\n        {\n            if (ctxconfig->major == 1)\n            {\n                if (!(getEGLConfigAttrib(n, EGL_RENDERABLE_TYPE) & EGL_OPENGL_ES_BIT))\n                    continue;\n            }\n            else\n            {\n                if (!(getEGLConfigAttrib(n, EGL_RENDERABLE_TYPE) & EGL_OPENGL_ES2_BIT))\n                    continue;\n            }\n        }\n        else if (ctxconfig->client == GLFW_OPENGL_API)\n        {\n            if (!(getEGLConfigAttrib(n, EGL_RENDERABLE_TYPE) & EGL_OPENGL_BIT))\n                continue;\n        }\n\n        u->redBits = getEGLConfigAttrib(n, EGL_RED_SIZE);\n        u->greenBits = getEGLConfigAttrib(n, EGL_GREEN_SIZE);\n        u->blueBits = getEGLConfigAttrib(n, EGL_BLUE_SIZE);\n\n        u->alphaBits = getEGLConfigAttrib(n, EGL_ALPHA_SIZE);\n        u->depthBits = getEGLConfigAttrib(n, EGL_DEPTH_SIZE);\n        u->stencilBits = getEGLConfigAttrib(n, EGL_STENCIL_SIZE);\n\n        u->samples = getEGLConfigAttrib(n, EGL_SAMPLES);\n        u->doublebuffer = GLFW_TRUE;\n\n        u->handle = (uintptr_t) n;\n        usableCount++;\n    }\n\n    closest = _glfwChooseFBConfig(desired, usableConfigs, usableCount);\n    if (closest)\n        *result = (EGLConfig) closest->handle;\n\n    free(nativeConfigs);\n    free(usableConfigs);\n\n    return closest != NULL;\n}\n\nstatic void makeContextCurrentEGL(_GLFWwindow* window)\n{\n    if (window)\n    {\n        if (!eglMakeCurrent(_glfw.egl.display,\n                            window->context.egl.surface,\n                            window->context.egl.surface,\n                            window->context.egl.handle))\n        {\n            _glfwInputError(GLFW_PLATFORM_ERROR,\n                            \"EGL: Failed to make context current: %s\",\n                            getEGLErrorString(eglGetError()));\n            return;\n        }\n    }\n    else\n    {\n        if (!eglMakeCurrent(_glfw.egl.display,\n                            EGL_NO_SURFACE,\n                            EGL_NO_SURFACE,\n                            EGL_NO_CONTEXT))\n        {\n            _glfwInputError(GLFW_PLATFORM_ERROR,\n                            \"EGL: Failed to clear current context: %s\",\n                            getEGLErrorString(eglGetError()));\n            return;\n        }\n    }\n\n    _glfwPlatformSetCurrentContext(window);\n}\n\nstatic void swapBuffersEGL(_GLFWwindow* window)\n{\n    if (window != _glfwPlatformGetCurrentContext())\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"EGL: The context must be current on the calling thread when swapping buffers\");\n        return;\n    }\n\n    eglSwapBuffers(_glfw.egl.display, window->context.egl.surface);\n}\n\nstatic void swapIntervalEGL(int interval)\n{\n    eglSwapInterval(_glfw.egl.display, interval);\n}\n\nstatic int extensionSupportedEGL(const char* extension)\n{\n    const char* extensions = eglQueryString(_glfw.egl.display, EGL_EXTENSIONS);\n    if (extensions)\n    {\n        if (_glfwStringInExtensionString(extension, extensions))\n            return GLFW_TRUE;\n    }\n\n    return GLFW_FALSE;\n}\n\nstatic GLFWglproc getProcAddressEGL(const char* procname)\n{\n    _GLFWwindow* window = _glfwPlatformGetCurrentContext();\n\n    if (window->context.egl.client)\n    {\n        GLFWglproc proc = (GLFWglproc) _glfw_dlsym(window->context.egl.client,\n                                                   procname);\n        if (proc)\n            return proc;\n    }\n\n    return eglGetProcAddress(procname);\n}\n\nstatic void destroyContextEGL(_GLFWwindow* window)\n{\n#if defined(_GLFW_X11)\n    // NOTE: Do not unload libGL.so.1 while the X11 display is still open,\n    //       as it will make XCloseDisplay segfault\n    if (window->context.client != GLFW_OPENGL_API)\n#endif // _GLFW_X11\n    {\n        if (window->context.egl.client)\n        {\n            _glfw_dlclose(window->context.egl.client);\n            window->context.egl.client = NULL;\n        }\n    }\n\n    if (window->context.egl.surface)\n    {\n        eglDestroySurface(_glfw.egl.display, window->context.egl.surface);\n        window->context.egl.surface = EGL_NO_SURFACE;\n    }\n\n    if (window->context.egl.handle)\n    {\n        eglDestroyContext(_glfw.egl.display, window->context.egl.handle);\n        window->context.egl.handle = EGL_NO_CONTEXT;\n    }\n}\n\n\n//////////////////////////////////////////////////////////////////////////\n//////                       GLFW internal API                      //////\n//////////////////////////////////////////////////////////////////////////\n\n// Initialize EGL\n//\nGLFWbool _glfwInitEGL(void)\n{\n    int i;\n    const char* sonames[] =\n    {\n#if defined(_GLFW_WIN32)\n        \"libEGL.dll\",\n        \"EGL.dll\",\n#elif defined(_GLFW_COCOA)\n        \"libEGL.dylib\",\n#else\n        \"libEGL.so.1\",\n#endif\n        NULL\n    };\n\n    if (_glfw.egl.handle)\n        return GLFW_TRUE;\n\n    for (i = 0;  sonames[i];  i++)\n    {\n        _glfw.egl.handle = _glfw_dlopen(sonames[i]);\n        if (_glfw.egl.handle)\n            break;\n    }\n\n    if (!_glfw.egl.handle)\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE, \"EGL: Library not found\");\n        return GLFW_FALSE;\n    }\n\n    _glfw.egl.prefix = (strncmp(sonames[i], \"lib\", 3) == 0);\n\n    _glfw.egl.GetConfigAttrib = (PFNEGLGETCONFIGATTRIBPROC)\n        _glfw_dlsym(_glfw.egl.handle, \"eglGetConfigAttrib\");\n    _glfw.egl.GetConfigs = (PFNEGLGETCONFIGSPROC)\n        _glfw_dlsym(_glfw.egl.handle, \"eglGetConfigs\");\n    _glfw.egl.GetDisplay = (PFNEGLGETDISPLAYPROC)\n        _glfw_dlsym(_glfw.egl.handle, \"eglGetDisplay\");\n    _glfw.egl.GetError = (PFNEGLGETERRORPROC)\n        _glfw_dlsym(_glfw.egl.handle, \"eglGetError\");\n    _glfw.egl.Initialize = (PFNEGLINITIALIZEPROC)\n        _glfw_dlsym(_glfw.egl.handle, \"eglInitialize\");\n    _glfw.egl.Terminate = (PFNEGLTERMINATEPROC)\n        _glfw_dlsym(_glfw.egl.handle, \"eglTerminate\");\n    _glfw.egl.BindAPI = (PFNEGLBINDAPIPROC)\n        _glfw_dlsym(_glfw.egl.handle, \"eglBindAPI\");\n    _glfw.egl.CreateContext = (PFNEGLCREATECONTEXTPROC)\n        _glfw_dlsym(_glfw.egl.handle, \"eglCreateContext\");\n    _glfw.egl.DestroySurface = (PFNEGLDESTROYSURFACEPROC)\n        _glfw_dlsym(_glfw.egl.handle, \"eglDestroySurface\");\n    _glfw.egl.DestroyContext = (PFNEGLDESTROYCONTEXTPROC)\n        _glfw_dlsym(_glfw.egl.handle, \"eglDestroyContext\");\n    _glfw.egl.CreateWindowSurface = (PFNEGLCREATEWINDOWSURFACEPROC)\n        _glfw_dlsym(_glfw.egl.handle, \"eglCreateWindowSurface\");\n    _glfw.egl.MakeCurrent = (PFNEGLMAKECURRENTPROC)\n        _glfw_dlsym(_glfw.egl.handle, \"eglMakeCurrent\");\n    _glfw.egl.SwapBuffers = (PFNEGLSWAPBUFFERSPROC)\n        _glfw_dlsym(_glfw.egl.handle, \"eglSwapBuffers\");\n    _glfw.egl.SwapInterval = (PFNEGLSWAPINTERVALPROC)\n        _glfw_dlsym(_glfw.egl.handle, \"eglSwapInterval\");\n    _glfw.egl.QueryString = (PFNEGLQUERYSTRINGPROC)\n        _glfw_dlsym(_glfw.egl.handle, \"eglQueryString\");\n    _glfw.egl.GetProcAddress = (PFNEGLGETPROCADDRESSPROC)\n        _glfw_dlsym(_glfw.egl.handle, \"eglGetProcAddress\");\n\n    if (!_glfw.egl.GetConfigAttrib ||\n        !_glfw.egl.GetConfigs ||\n        !_glfw.egl.GetDisplay ||\n        !_glfw.egl.GetError ||\n        !_glfw.egl.Initialize ||\n        !_glfw.egl.Terminate ||\n        !_glfw.egl.BindAPI ||\n        !_glfw.egl.CreateContext ||\n        !_glfw.egl.DestroySurface ||\n        !_glfw.egl.DestroyContext ||\n        !_glfw.egl.CreateWindowSurface ||\n        !_glfw.egl.MakeCurrent ||\n        !_glfw.egl.SwapBuffers ||\n        !_glfw.egl.SwapInterval ||\n        !_glfw.egl.QueryString ||\n        !_glfw.egl.GetProcAddress)\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"EGL: Failed to load required entry points\");\n\n        _glfwTerminateEGL();\n        return GLFW_FALSE;\n    }\n\n    _glfw.egl.display = eglGetDisplay(_GLFW_EGL_NATIVE_DISPLAY);\n    if (_glfw.egl.display == EGL_NO_DISPLAY)\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE,\n                        \"EGL: Failed to get EGL display: %s\",\n                        getEGLErrorString(eglGetError()));\n\n        _glfwTerminateEGL();\n        return GLFW_FALSE;\n    }\n\n    if (!eglInitialize(_glfw.egl.display, &_glfw.egl.major, &_glfw.egl.minor))\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE,\n                        \"EGL: Failed to initialize EGL: %s\",\n                        getEGLErrorString(eglGetError()));\n\n        _glfwTerminateEGL();\n        return GLFW_FALSE;\n    }\n\n    _glfw.egl.KHR_create_context =\n        extensionSupportedEGL(\"EGL_KHR_create_context\");\n    _glfw.egl.KHR_create_context_no_error =\n        extensionSupportedEGL(\"EGL_KHR_create_context_no_error\");\n    _glfw.egl.KHR_gl_colorspace =\n        extensionSupportedEGL(\"EGL_KHR_gl_colorspace\");\n\n    return GLFW_TRUE;\n}\n\n// Terminate EGL\n//\nvoid _glfwTerminateEGL(void)\n{\n    if (_glfw.egl.display)\n    {\n        eglTerminate(_glfw.egl.display);\n        _glfw.egl.display = EGL_NO_DISPLAY;\n    }\n\n    if (_glfw.egl.handle)\n    {\n        _glfw_dlclose(_glfw.egl.handle);\n        _glfw.egl.handle = NULL;\n    }\n}\n\n#define setEGLattrib(attribName, attribValue) \\\n{ \\\n    attribs[index++] = attribName; \\\n    attribs[index++] = attribValue; \\\n    assert((size_t) index < sizeof(attribs) / sizeof(attribs[0])); \\\n}\n\n// Create the OpenGL or OpenGL ES context\n//\nGLFWbool _glfwCreateContextEGL(_GLFWwindow* window,\n                               const _GLFWctxconfig* ctxconfig,\n                               const _GLFWfbconfig* fbconfig)\n{\n    EGLint attribs[40];\n    EGLConfig config;\n    EGLContext share = NULL;\n\n    if (!_glfw.egl.display)\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE, \"EGL: API not available\");\n        return GLFW_FALSE;\n    }\n\n    if (ctxconfig->share)\n        share = ctxconfig->share->context.egl.handle;\n\n    if (!chooseEGLConfig(ctxconfig, fbconfig, &config))\n    {\n        _glfwInputError(GLFW_FORMAT_UNAVAILABLE,\n                        \"EGL: Failed to find a suitable EGLConfig\");\n        return GLFW_FALSE;\n    }\n\n    if (ctxconfig->client == GLFW_OPENGL_ES_API)\n    {\n        if (!eglBindAPI(EGL_OPENGL_ES_API))\n        {\n            _glfwInputError(GLFW_API_UNAVAILABLE,\n                            \"EGL: Failed to bind OpenGL ES: %s\",\n                            getEGLErrorString(eglGetError()));\n            return GLFW_FALSE;\n        }\n    }\n    else\n    {\n        if (!eglBindAPI(EGL_OPENGL_API))\n        {\n            _glfwInputError(GLFW_API_UNAVAILABLE,\n                            \"EGL: Failed to bind OpenGL: %s\",\n                            getEGLErrorString(eglGetError()));\n            return GLFW_FALSE;\n        }\n    }\n\n    if (_glfw.egl.KHR_create_context)\n    {\n        int index = 0, mask = 0, flags = 0;\n\n        if (ctxconfig->client == GLFW_OPENGL_API)\n        {\n            if (ctxconfig->forward)\n                flags |= EGL_CONTEXT_OPENGL_FORWARD_COMPATIBLE_BIT_KHR;\n\n            if (ctxconfig->profile == GLFW_OPENGL_CORE_PROFILE)\n                mask |= EGL_CONTEXT_OPENGL_CORE_PROFILE_BIT_KHR;\n            else if (ctxconfig->profile == GLFW_OPENGL_COMPAT_PROFILE)\n                mask |= EGL_CONTEXT_OPENGL_COMPATIBILITY_PROFILE_BIT_KHR;\n\n            if (_glfw.egl.KHR_create_context_no_error)\n            {\n                if (ctxconfig->noerror)\n                    flags |= EGL_CONTEXT_OPENGL_NO_ERROR_KHR;\n            }\n        }\n\n        if (ctxconfig->debug)\n            flags |= EGL_CONTEXT_OPENGL_DEBUG_BIT_KHR;\n\n        if (ctxconfig->robustness)\n        {\n            if (ctxconfig->robustness == GLFW_NO_RESET_NOTIFICATION)\n            {\n                setEGLattrib(EGL_CONTEXT_OPENGL_RESET_NOTIFICATION_STRATEGY_KHR,\n                             EGL_NO_RESET_NOTIFICATION_KHR);\n            }\n            else if (ctxconfig->robustness == GLFW_LOSE_CONTEXT_ON_RESET)\n            {\n                setEGLattrib(EGL_CONTEXT_OPENGL_RESET_NOTIFICATION_STRATEGY_KHR,\n                             EGL_LOSE_CONTEXT_ON_RESET_KHR);\n            }\n\n            flags |= EGL_CONTEXT_OPENGL_ROBUST_ACCESS_BIT_KHR;\n        }\n\n        if (ctxconfig->major != 1 || ctxconfig->minor != 0)\n        {\n            setEGLattrib(EGL_CONTEXT_MAJOR_VERSION_KHR, ctxconfig->major);\n            setEGLattrib(EGL_CONTEXT_MINOR_VERSION_KHR, ctxconfig->minor);\n        }\n\n        if (mask)\n            setEGLattrib(EGL_CONTEXT_OPENGL_PROFILE_MASK_KHR, mask);\n\n        if (flags)\n            setEGLattrib(EGL_CONTEXT_FLAGS_KHR, flags);\n\n        setEGLattrib(EGL_NONE, EGL_NONE);\n    }\n    else\n    {\n        int index = 0;\n\n        if (ctxconfig->client == GLFW_OPENGL_ES_API)\n            setEGLattrib(EGL_CONTEXT_CLIENT_VERSION, ctxconfig->major);\n\n        setEGLattrib(EGL_NONE, EGL_NONE);\n    }\n\n    // Context release behaviors (GL_KHR_context_flush_control) are not yet\n    // supported on EGL but are not a hard constraint, so ignore and continue\n\n    window->context.egl.handle = eglCreateContext(_glfw.egl.display,\n                                                  config, share, attribs);\n\n    if (window->context.egl.handle == EGL_NO_CONTEXT)\n    {\n        _glfwInputError(GLFW_VERSION_UNAVAILABLE,\n                        \"EGL: Failed to create context: %s\",\n                        getEGLErrorString(eglGetError()));\n        return GLFW_FALSE;\n    }\n\n    // Set up attributes for surface creation\n    {\n        int index = 0;\n\n        if (fbconfig->sRGB)\n        {\n            if (_glfw.egl.KHR_gl_colorspace)\n            {\n                setEGLattrib(EGL_GL_COLORSPACE_KHR, EGL_GL_COLORSPACE_SRGB_KHR);\n            }\n        }\n\n        setEGLattrib(EGL_NONE, EGL_NONE);\n    }\n\n    window->context.egl.surface =\n        eglCreateWindowSurface(_glfw.egl.display,\n                               config,\n                               _GLFW_EGL_NATIVE_WINDOW,\n                               attribs);\n    if (window->context.egl.surface == EGL_NO_SURFACE)\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"EGL: Failed to create window surface: %s\",\n                        getEGLErrorString(eglGetError()));\n        return GLFW_FALSE;\n    }\n\n    window->context.egl.config = config;\n\n    // Load the appropriate client library\n    {\n        int i;\n        const char** sonames;\n        const char* es1sonames[] =\n        {\n#if defined(_GLFW_WIN32)\n            \"GLESv1_CM.dll\",\n            \"libGLES_CM.dll\",\n#elif defined(_GLFW_COCOA)\n            \"libGLESv1_CM.dylib\",\n#else\n            \"libGLESv1_CM.so.1\",\n            \"libGLES_CM.so.1\",\n#endif\n            NULL\n        };\n        const char* es2sonames[] =\n        {\n#if defined(_GLFW_WIN32)\n            \"GLESv2.dll\",\n            \"libGLESv2.dll\",\n#elif defined(_GLFW_COCOA)\n            \"libGLESv2.dylib\",\n#else\n            \"libGLESv2.so.2\",\n#endif\n            NULL\n        };\n        const char* glsonames[] =\n        {\n#if defined(_GLFW_WIN32)\n#elif defined(_GLFW_COCOA)\n#else\n            \"libGL.so.1\",\n#endif\n            NULL\n        };\n\n        if (ctxconfig->client == GLFW_OPENGL_ES_API)\n        {\n            if (ctxconfig->major == 1)\n                sonames = es1sonames;\n            else\n                sonames = es2sonames;\n        }\n        else\n            sonames = glsonames;\n\n        for (i = 0;  sonames[i];  i++)\n        {\n            // HACK: Match presence of lib prefix to increase chance of finding\n            //       a matching pair in the jungle that is Win32 EGL/GLES\n            if (_glfw.egl.prefix != (strncmp(sonames[i], \"lib\", 3) == 0))\n                continue;\n\n            window->context.egl.client = _glfw_dlopen(sonames[i]);\n            if (window->context.egl.client)\n                break;\n        }\n\n        if (!window->context.egl.client)\n        {\n            _glfwInputError(GLFW_API_UNAVAILABLE,\n                            \"EGL: Failed to load client library\");\n            return GLFW_FALSE;\n        }\n    }\n\n    window->context.makeCurrent = makeContextCurrentEGL;\n    window->context.swapBuffers = swapBuffersEGL;\n    window->context.swapInterval = swapIntervalEGL;\n    window->context.extensionSupported = extensionSupportedEGL;\n    window->context.getProcAddress = getProcAddressEGL;\n    window->context.destroy = destroyContextEGL;\n\n    return GLFW_TRUE;\n}\n\n#undef setEGLattrib\n\n// Returns the Visual and depth of the chosen EGLConfig\n//\n#if defined(_GLFW_X11)\nGLFWbool _glfwChooseVisualEGL(const _GLFWctxconfig* ctxconfig,\n                              const _GLFWfbconfig* fbconfig,\n                              Visual** visual, int* depth)\n{\n    XVisualInfo* result;\n    XVisualInfo desired;\n    EGLConfig native;\n    EGLint visualID = 0, count = 0;\n    const long vimask = VisualScreenMask | VisualIDMask;\n\n    if (!chooseEGLConfig(ctxconfig, fbconfig, &native))\n    {\n        _glfwInputError(GLFW_FORMAT_UNAVAILABLE,\n                        \"EGL: Failed to find a suitable EGLConfig\");\n        return GLFW_FALSE;\n    }\n\n    eglGetConfigAttrib(_glfw.egl.display, native,\n                       EGL_NATIVE_VISUAL_ID, &visualID);\n\n    desired.screen = _glfw.x11.screen;\n    desired.visualid = visualID;\n\n    result = XGetVisualInfo(_glfw.x11.display, vimask, &desired, &count);\n    if (!result)\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"EGL: Failed to retrieve Visual for EGLConfig\");\n        return GLFW_FALSE;\n    }\n\n    *visual = result->visual;\n    *depth = result->depth;\n\n    XFree(result);\n    return GLFW_TRUE;\n}\n#endif // _GLFW_X11\n\n\n//////////////////////////////////////////////////////////////////////////\n//////                        GLFW native API                       //////\n//////////////////////////////////////////////////////////////////////////\n\nGLFWAPI EGLDisplay glfwGetEGLDisplay(void)\n{\n    _GLFW_REQUIRE_INIT_OR_RETURN(EGL_NO_DISPLAY);\n    return _glfw.egl.display;\n}\n\nGLFWAPI EGLContext glfwGetEGLContext(GLFWwindow* handle)\n{\n    _GLFWwindow* window = (_GLFWwindow*) handle;\n    _GLFW_REQUIRE_INIT_OR_RETURN(EGL_NO_CONTEXT);\n\n    if (window->context.client == GLFW_NO_API)\n    {\n        _glfwInputError(GLFW_NO_WINDOW_CONTEXT, NULL);\n        return EGL_NO_CONTEXT;\n    }\n\n    return window->context.egl.handle;\n}\n\nGLFWAPI EGLSurface glfwGetEGLSurface(GLFWwindow* handle)\n{\n    _GLFWwindow* window = (_GLFWwindow*) handle;\n    _GLFW_REQUIRE_INIT_OR_RETURN(EGL_NO_SURFACE);\n\n    if (window->context.client == GLFW_NO_API)\n    {\n        _glfwInputError(GLFW_NO_WINDOW_CONTEXT, NULL);\n        return EGL_NO_SURFACE;\n    }\n\n    return window->context.egl.surface;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-glfw-3.2.1-gkd54tstzvk3vujbh27j3m4waeirf4if/spack-src/src/x11_platform.h": "//========================================================================\n// GLFW 3.2 X11 - www.glfw.org\n//------------------------------------------------------------------------\n// Copyright (c) 2002-2006 Marcus Geelnard\n// Copyright (c) 2006-2016 Camilla Berglund <elmindreda@glfw.org>\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would\n//    be appreciated but is not required.\n//\n// 2. Altered source versions must be plainly marked as such, and must not\n//    be misrepresented as being the original software.\n//\n// 3. This notice may not be removed or altered from any source\n//    distribution.\n//\n//========================================================================\n\n#ifndef _glfw3_x11_platform_h_\n#define _glfw3_x11_platform_h_\n\n#include <unistd.h>\n#include <signal.h>\n#include <stdint.h>\n#include <dlfcn.h>\n\n#include <X11/Xlib.h>\n#include <X11/keysym.h>\n#include <X11/Xatom.h>\n#include <X11/Xcursor/Xcursor.h>\n\n// The XRandR extension provides mode setting and gamma control\n#include <X11/extensions/Xrandr.h>\n\n// The Xkb extension provides improved keyboard support\n#include <X11/XKBlib.h>\n\n// The Xinerama extension provides legacy monitor indices\n#include <X11/extensions/Xinerama.h>\n\n#if defined(_GLFW_HAS_XF86VM)\n // The Xf86VidMode extension provides fallback gamma control\n #include <X11/extensions/xf86vmode.h>\n#endif\n\ntypedef XID xcb_window_t;\ntypedef XID xcb_visualid_t;\ntypedef struct xcb_connection_t xcb_connection_t;\ntypedef xcb_connection_t* (* XGETXCBCONNECTION_T)(Display*);\n\ntypedef VkFlags VkXlibSurfaceCreateFlagsKHR;\ntypedef VkFlags VkXcbSurfaceCreateFlagsKHR;\n\ntypedef struct VkXlibSurfaceCreateInfoKHR\n{\n    VkStructureType             sType;\n    const void*                 pNext;\n    VkXlibSurfaceCreateFlagsKHR flags;\n    Display*                    dpy;\n    Window                      window;\n} VkXlibSurfaceCreateInfoKHR;\n\ntypedef struct VkXcbSurfaceCreateInfoKHR\n{\n    VkStructureType             sType;\n    const void*                 pNext;\n    VkXcbSurfaceCreateFlagsKHR  flags;\n    xcb_connection_t*           connection;\n    xcb_window_t                window;\n} VkXcbSurfaceCreateInfoKHR;\n\ntypedef VkResult (APIENTRY *PFN_vkCreateXlibSurfaceKHR)(VkInstance,const VkXlibSurfaceCreateInfoKHR*,const VkAllocationCallbacks*,VkSurfaceKHR*);\ntypedef VkBool32 (APIENTRY *PFN_vkGetPhysicalDeviceXlibPresentationSupportKHR)(VkPhysicalDevice,uint32_t,Display*,VisualID);\ntypedef VkResult (APIENTRY *PFN_vkCreateXcbSurfaceKHR)(VkInstance,const VkXcbSurfaceCreateInfoKHR*,const VkAllocationCallbacks*,VkSurfaceKHR*);\ntypedef VkBool32 (APIENTRY *PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR)(VkPhysicalDevice,uint32_t,xcb_connection_t*,xcb_visualid_t);\n\n#include \"posix_tls.h\"\n#include \"posix_time.h\"\n#include \"linux_joystick.h\"\n#include \"xkb_unicode.h\"\n#include \"glx_context.h\"\n#include \"egl_context.h\"\n\n#define _glfw_dlopen(name) dlopen(name, RTLD_LAZY | RTLD_LOCAL)\n#define _glfw_dlclose(handle) dlclose(handle)\n#define _glfw_dlsym(handle, name) dlsym(handle, name)\n\n#define _GLFW_EGL_NATIVE_WINDOW  ((EGLNativeWindowType) window->x11.handle)\n#define _GLFW_EGL_NATIVE_DISPLAY ((EGLNativeDisplayType) _glfw.x11.display)\n\n#define _GLFW_PLATFORM_WINDOW_STATE         _GLFWwindowX11  x11\n#define _GLFW_PLATFORM_LIBRARY_WINDOW_STATE _GLFWlibraryX11 x11\n#define _GLFW_PLATFORM_MONITOR_STATE        _GLFWmonitorX11 x11\n#define _GLFW_PLATFORM_CURSOR_STATE         _GLFWcursorX11  x11\n\n\n// X11-specific per-window data\n//\ntypedef struct _GLFWwindowX11\n{\n    Colormap        colormap;\n    Window          handle;\n    XIC             ic;\n\n    GLFWbool        overrideRedirect;\n\n    // Cached position and size used to filter out duplicate events\n    int             width, height;\n    int             xpos, ypos;\n\n    // The last received cursor position, regardless of source\n    int             lastCursorPosX, lastCursorPosY;\n    // The last position the cursor was warped to by GLFW\n    int             warpCursorPosX, warpCursorPosY;\n\n    // The information from the last KeyPress event\n    unsigned int    lastKeyCode;\n    Time            lastKeyTime;\n\n} _GLFWwindowX11;\n\n// X11-specific global data\n//\ntypedef struct _GLFWlibraryX11\n{\n    Display*        display;\n    int             screen;\n    Window          root;\n\n    // Invisible cursor for hidden cursor mode\n    Cursor          cursor;\n    // Context for mapping window XIDs to _GLFWwindow pointers\n    XContext        context;\n    // XIM input method\n    XIM             im;\n    // Most recent error code received by X error handler\n    int             errorCode;\n    // Clipboard string (while the selection is owned)\n    char*           clipboardString;\n    // Key name string\n    char            keyName[64];\n    // X11 keycode to GLFW key LUT\n    short int       publicKeys[256];\n    // GLFW key to X11 keycode LUT\n    short int       nativeKeys[GLFW_KEY_LAST + 1];\n    // Where to place the cursor when re-enabled\n    double          restoreCursorPosX, restoreCursorPosY;\n    // The window whose disabled cursor mode is active\n    _GLFWwindow*    disabledCursorWindow;\n\n    // Window manager atoms\n    Atom            WM_PROTOCOLS;\n    Atom            WM_STATE;\n    Atom            WM_DELETE_WINDOW;\n    Atom            NET_WM_NAME;\n    Atom            NET_WM_ICON_NAME;\n    Atom            NET_WM_ICON;\n    Atom            NET_WM_PID;\n    Atom            NET_WM_PING;\n    Atom            NET_WM_WINDOW_TYPE;\n    Atom            NET_WM_WINDOW_TYPE_NORMAL;\n    Atom            NET_WM_STATE;\n    Atom            NET_WM_STATE_ABOVE;\n    Atom            NET_WM_STATE_FULLSCREEN;\n    Atom            NET_WM_STATE_MAXIMIZED_VERT;\n    Atom            NET_WM_STATE_MAXIMIZED_HORZ;\n    Atom            NET_WM_BYPASS_COMPOSITOR;\n    Atom            NET_WM_FULLSCREEN_MONITORS;\n    Atom            NET_ACTIVE_WINDOW;\n    Atom            NET_FRAME_EXTENTS;\n    Atom            NET_REQUEST_FRAME_EXTENTS;\n    Atom            MOTIF_WM_HINTS;\n\n    // Xdnd (drag and drop) atoms\n    Atom            XdndAware;\n    Atom            XdndEnter;\n    Atom            XdndPosition;\n    Atom            XdndStatus;\n    Atom            XdndActionCopy;\n    Atom            XdndDrop;\n    Atom            XdndLeave;\n    Atom            XdndFinished;\n    Atom            XdndSelection;\n\n    // Selection (clipboard) atoms\n    Atom            TARGETS;\n    Atom            MULTIPLE;\n    Atom            CLIPBOARD;\n    Atom            CLIPBOARD_MANAGER;\n    Atom            SAVE_TARGETS;\n    Atom            NULL_;\n    Atom            UTF8_STRING;\n    Atom            COMPOUND_STRING;\n    Atom            ATOM_PAIR;\n    Atom            GLFW_SELECTION;\n\n    struct {\n        GLFWbool    available;\n        int         eventBase;\n        int         errorBase;\n        int         major;\n        int         minor;\n        GLFWbool    gammaBroken;\n        GLFWbool    monitorBroken;\n    } randr;\n\n    struct {\n        GLFWbool    available;\n        GLFWbool    detectable;\n        int         majorOpcode;\n        int         eventBase;\n        int         errorBase;\n        int         major;\n        int         minor;\n    } xkb;\n\n    struct {\n        int         count;\n        int         timeout;\n        int         interval;\n        int         blanking;\n        int         exposure;\n    } saver;\n\n    struct {\n        Window      source;\n    } xdnd;\n\n    struct {\n        GLFWbool    available;\n        int         major;\n        int         minor;\n    } xinerama;\n\n    struct {\n        void*       handle;\n        XGETXCBCONNECTION_T XGetXCBConnection;\n    } x11xcb;\n\n#if defined(_GLFW_HAS_XF86VM)\n    struct {\n        GLFWbool    available;\n        int         eventBase;\n        int         errorBase;\n    } vidmode;\n#endif /*_GLFW_HAS_XF86VM*/\n\n} _GLFWlibraryX11;\n\n// X11-specific per-monitor data\n//\ntypedef struct _GLFWmonitorX11\n{\n    RROutput        output;\n    RRCrtc          crtc;\n    RRMode          oldMode;\n\n    // Index of corresponding Xinerama screen,\n    // for EWMH full screen window placement\n    int             index;\n\n} _GLFWmonitorX11;\n\n// X11-specific per-cursor data\n//\ntypedef struct _GLFWcursorX11\n{\n    Cursor handle;\n\n} _GLFWcursorX11;\n\n\nGLFWbool _glfwSetVideoModeX11(_GLFWmonitor* monitor, const GLFWvidmode* desired);\nvoid _glfwRestoreVideoModeX11(_GLFWmonitor* monitor);\n\nCursor _glfwCreateCursorX11(const GLFWimage* image, int xhot, int yhot);\n\nunsigned long _glfwGetWindowPropertyX11(Window window,\n                                        Atom property,\n                                        Atom type,\n                                        unsigned char** value);\n\nvoid _glfwGrabErrorHandlerX11(void);\nvoid _glfwReleaseErrorHandlerX11(void);\nvoid _glfwInputErrorX11(int error, const char* message);\n\n#endif // _glfw3_x11_platform_h_\n",
        "/tmp/vanessa/spack-stage/spack-stage-glfw-3.2.1-gkd54tstzvk3vujbh27j3m4waeirf4if/spack-src/src/mir_platform.h": "//========================================================================\n// GLFW 3.2 Mir - www.glfw.org\n//------------------------------------------------------------------------\n// Copyright (c) 2014-2015 Brandon Schaefer <brandon.schaefer@canonical.com>\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would\n//    be appreciated but is not required.\n//\n// 2. Altered source versions must be plainly marked as such, and must not\n//    be misrepresented as being the original software.\n//\n// 3. This notice may not be removed or altered from any source\n//    distribution.\n//\n//========================================================================\n\n#ifndef _glfw3_mir_platform_h_\n#define _glfw3_mir_platform_h_\n\n#include <sys/queue.h>\n#include <pthread.h>\n#include <dlfcn.h>\n\n#include <mir_toolkit/mir_client_library.h>\n\ntypedef VkFlags VkMirSurfaceCreateFlagsKHR;\n\ntypedef struct VkMirSurfaceCreateInfoKHR\n{\n    VkStructureType             sType;\n    const void*                 pNext;\n    VkMirSurfaceCreateFlagsKHR  flags;\n    MirConnection*              connection;\n    MirSurface*                 mirSurface;\n} VkMirSurfaceCreateInfoKHR;\n\ntypedef VkResult (APIENTRY *PFN_vkCreateMirSurfaceKHR)(VkInstance,const VkMirSurfaceCreateInfoKHR*,const VkAllocationCallbacks*,VkSurfaceKHR*);\ntypedef VkBool32 (APIENTRY *PFN_vkGetPhysicalDeviceMirPresentationSupportKHR)(VkPhysicalDevice,uint32_t,MirConnection*);\n\n#include \"posix_tls.h\"\n#include \"posix_time.h\"\n#include \"linux_joystick.h\"\n#include \"xkb_unicode.h\"\n#include \"egl_context.h\"\n\n#define _glfw_dlopen(name) dlopen(name, RTLD_LAZY | RTLD_LOCAL)\n#define _glfw_dlclose(handle) dlclose(handle)\n#define _glfw_dlsym(handle, name) dlsym(handle, name)\n\n#define _GLFW_EGL_NATIVE_WINDOW  ((EGLNativeWindowType) window->mir.window)\n#define _GLFW_EGL_NATIVE_DISPLAY ((EGLNativeDisplayType) _glfw.mir.display)\n\n#define _GLFW_PLATFORM_WINDOW_STATE         _GLFWwindowMir  mir\n#define _GLFW_PLATFORM_MONITOR_STATE        _GLFWmonitorMir mir\n#define _GLFW_PLATFORM_LIBRARY_WINDOW_STATE _GLFWlibraryMir mir\n#define _GLFW_PLATFORM_CURSOR_STATE         _GLFWcursorMir  mir\n\n#define _GLFW_PLATFORM_CONTEXT_STATE\n#define _GLFW_PLATFORM_LIBRARY_CONTEXT_STATE\n\n\n// Mir-specific Event Queue\n//\ntypedef struct EventQueue\n{\n    TAILQ_HEAD(, EventNode) head;\n} EventQueue;\n\n// Mir-specific per-window data\n//\ntypedef struct _GLFWwindowMir\n{\n    MirSurface*             surface;\n    int                     width;\n    int                     height;\n    MirEGLNativeWindowType  window;\n\n} _GLFWwindowMir;\n\n// Mir-specific per-monitor data\n//\ntypedef struct _GLFWmonitorMir\n{\n    int cur_mode;\n    int output_id;\n    int x;\n    int y;\n\n} _GLFWmonitorMir;\n\n// Mir-specific global data\n//\ntypedef struct _GLFWlibraryMir\n{\n    MirConnection*          connection;\n    MirEGLNativeDisplayType display;\n    MirCursorConfiguration* default_conf;\n    EventQueue* event_queue;\n\n    short int       publicKeys[256];\n\n    pthread_mutex_t event_mutex;\n    pthread_cond_t  event_cond;\n\n} _GLFWlibraryMir;\n\n// Mir-specific per-cursor data\n// TODO: Only system cursors are implemented in Mir atm. Need to wait for support.\n//\ntypedef struct _GLFWcursorMir\n{\n    MirCursorConfiguration* conf;\n    MirBufferStream*        custom_cursor;\n} _GLFWcursorMir;\n\n\nextern void _glfwInitEventQueueMir(EventQueue* queue);\nextern void _glfwDeleteEventQueueMir(EventQueue* queue);\n\n#endif // _glfw3_mir_platform_h_\n",
        "/tmp/vanessa/spack-stage/spack-stage-glfw-3.2.1-gkd54tstzvk3vujbh27j3m4waeirf4if/spack-src/src/vulkan.c": "//========================================================================\n// GLFW 3.2 - www.glfw.org\n//------------------------------------------------------------------------\n// Copyright (c) 2002-2006 Marcus Geelnard\n// Copyright (c) 2006-2016 Camilla Berglund <elmindreda@glfw.org>\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would\n//    be appreciated but is not required.\n//\n// 2. Altered source versions must be plainly marked as such, and must not\n//    be misrepresented as being the original software.\n//\n// 3. This notice may not be removed or altered from any source\n//    distribution.\n//\n//========================================================================\n\n#include \"internal.h\"\n\n#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n\n\n//////////////////////////////////////////////////////////////////////////\n//////                       GLFW internal API                      //////\n//////////////////////////////////////////////////////////////////////////\n\nGLFWbool _glfwInitVulkan(void)\n{\n    VkResult err;\n    VkExtensionProperties* ep;\n    uint32_t i, count;\n\n#if !defined(_GLFW_VULKAN_STATIC)\n#if defined(_GLFW_WIN32)\n    const char* name = \"vulkan-1.dll\";\n#else\n    const char* name = \"libvulkan.so.1\";\n#endif\n\n    if (_glfw.vk.available)\n        return GLFW_TRUE;\n\n    _glfw.vk.handle = _glfw_dlopen(name);\n    if (!_glfw.vk.handle)\n        return GLFW_FALSE;\n\n    _glfw.vk.GetInstanceProcAddr = (PFN_vkGetInstanceProcAddr)\n        _glfw_dlsym(_glfw.vk.handle, \"vkGetInstanceProcAddr\");\n    if (!_glfw.vk.GetInstanceProcAddr)\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE,\n                        \"Vulkan: Loader does not export vkGetInstanceProcAddr\");\n\n        _glfwTerminateVulkan();\n        return GLFW_FALSE;\n    }\n\n    _glfw.vk.EnumerateInstanceExtensionProperties = (PFN_vkEnumerateInstanceExtensionProperties)\n        vkGetInstanceProcAddr(NULL, \"vkEnumerateInstanceExtensionProperties\");\n    if (!_glfw.vk.EnumerateInstanceExtensionProperties)\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE,\n                        \"Vulkan: Failed to retrieve vkEnumerateInstanceExtensionProperties\");\n\n        _glfwTerminateVulkan();\n        return GLFW_FALSE;\n    }\n#endif // _GLFW_VULKAN_STATIC\n\n    err = vkEnumerateInstanceExtensionProperties(NULL, &count, NULL);\n    if (err)\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"Vulkan: Failed to query instance extension count: %s\",\n                        _glfwGetVulkanResultString(err));\n\n        _glfwTerminateVulkan();\n        return GLFW_FALSE;\n    }\n\n    ep = calloc(count, sizeof(VkExtensionProperties));\n\n    err = vkEnumerateInstanceExtensionProperties(NULL, &count, ep);\n    if (err)\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"Vulkan: Failed to query instance extensions: %s\",\n                        _glfwGetVulkanResultString(err));\n\n        free(ep);\n        _glfwTerminateVulkan();\n        return GLFW_FALSE;\n    }\n\n    for (i = 0;  i < count;  i++)\n    {\n        if (strcmp(ep[i].extensionName, \"VK_KHR_surface\") == 0)\n            _glfw.vk.KHR_surface = GLFW_TRUE;\n        if (strcmp(ep[i].extensionName, \"VK_KHR_win32_surface\") == 0)\n            _glfw.vk.KHR_win32_surface = GLFW_TRUE;\n        if (strcmp(ep[i].extensionName, \"VK_KHR_xlib_surface\") == 0)\n            _glfw.vk.KHR_xlib_surface = GLFW_TRUE;\n        if (strcmp(ep[i].extensionName, \"VK_KHR_xcb_surface\") == 0)\n            _glfw.vk.KHR_xcb_surface = GLFW_TRUE;\n        if (strcmp(ep[i].extensionName, \"VK_KHR_wayland_surface\") == 0)\n            _glfw.vk.KHR_wayland_surface = GLFW_TRUE;\n        if (strcmp(ep[i].extensionName, \"VK_KHR_mir_surface\") == 0)\n            _glfw.vk.KHR_mir_surface = GLFW_TRUE;\n    }\n\n    free(ep);\n\n    _glfw.vk.available = GLFW_TRUE;\n\n    if (_glfw.vk.KHR_surface)\n    {\n        _glfw.vk.extensions =\n            _glfwPlatformGetRequiredInstanceExtensions(&_glfw.vk.extensionCount);\n    }\n\n    return GLFW_TRUE;\n}\n\nvoid _glfwTerminateVulkan(void)\n{\n    uint32_t i;\n\n    for (i = 0;  i < _glfw.vk.extensionCount;  i++)\n        free(_glfw.vk.extensions[i]);\n    free(_glfw.vk.extensions);\n\n    if (_glfw.vk.handle)\n        _glfw_dlclose(_glfw.vk.handle);\n}\n\nconst char* _glfwGetVulkanResultString(VkResult result)\n{\n    switch (result)\n    {\n        case VK_SUCCESS:\n            return \"Success\";\n        case VK_NOT_READY:\n            return \"A fence or query has not yet completed\";\n        case VK_TIMEOUT:\n            return \"A wait operation has not completed in the specified time\";\n        case VK_EVENT_SET:\n            return \"An event is signaled\";\n        case VK_EVENT_RESET:\n            return \"An event is unsignaled\";\n        case VK_INCOMPLETE:\n            return \"A return array was too small for the result\";\n        case VK_ERROR_OUT_OF_HOST_MEMORY:\n            return \"A host memory allocation has failed\";\n        case VK_ERROR_OUT_OF_DEVICE_MEMORY:\n            return \"A device memory allocation has failed\";\n        case VK_ERROR_INITIALIZATION_FAILED:\n            return \"Initialization of an object could not be completed for implementation-specific reasons\";\n        case VK_ERROR_DEVICE_LOST:\n            return \"The logical or physical device has been lost\";\n        case VK_ERROR_MEMORY_MAP_FAILED:\n            return \"Mapping of a memory object has failed\";\n        case VK_ERROR_LAYER_NOT_PRESENT:\n            return \"A requested layer is not present or could not be loaded\";\n        case VK_ERROR_EXTENSION_NOT_PRESENT:\n            return \"A requested extension is not supported\";\n        case VK_ERROR_FEATURE_NOT_PRESENT:\n            return \"A requested feature is not supported\";\n        case VK_ERROR_INCOMPATIBLE_DRIVER:\n            return \"The requested version of Vulkan is not supported by the driver or is otherwise incompatible\";\n        case VK_ERROR_TOO_MANY_OBJECTS:\n            return \"Too many objects of the type have already been created\";\n        case VK_ERROR_FORMAT_NOT_SUPPORTED:\n            return \"A requested format is not supported on this device\";\n        case VK_ERROR_SURFACE_LOST_KHR:\n            return \"A surface is no longer available\";\n        case VK_SUBOPTIMAL_KHR:\n            return \"A swapchain no longer matches the surface properties exactly, but can still be used\";\n        case VK_ERROR_OUT_OF_DATE_KHR:\n            return \"A surface has changed in such a way that it is no longer compatible with the swapchain\";\n        case VK_ERROR_INCOMPATIBLE_DISPLAY_KHR:\n            return \"The display used by a swapchain does not use the same presentable image layout\";\n        case VK_ERROR_NATIVE_WINDOW_IN_USE_KHR:\n            return \"The requested window is already connected to a VkSurfaceKHR, or to some other non-Vulkan API\";\n        case VK_ERROR_VALIDATION_FAILED_EXT:\n            return \"A validation layer found an error\";\n        default:\n            return \"ERROR: UNKNOWN VULKAN ERROR\";\n    }\n}\n\n\n//////////////////////////////////////////////////////////////////////////\n//////                        GLFW public API                       //////\n//////////////////////////////////////////////////////////////////////////\n\nGLFWAPI int glfwVulkanSupported(void)\n{\n    _GLFW_REQUIRE_INIT_OR_RETURN(GLFW_FALSE);\n    return _glfwInitVulkan();\n}\n\nGLFWAPI const char** glfwGetRequiredInstanceExtensions(uint32_t* count)\n{\n    *count = 0;\n\n    _GLFW_REQUIRE_INIT_OR_RETURN(NULL);\n\n    if (!_glfwInitVulkan())\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE, \"Vulkan: API not available\");\n        return NULL;\n    }\n\n    *count = _glfw.vk.extensionCount;\n    return (const char**) _glfw.vk.extensions;\n}\n\nGLFWAPI GLFWvkproc glfwGetInstanceProcAddress(VkInstance instance,\n                                              const char* procname)\n{\n    GLFWvkproc proc;\n\n    _GLFW_REQUIRE_INIT_OR_RETURN(NULL);\n\n    if (!_glfwInitVulkan())\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE, \"Vulkan: API not available\");\n        return NULL;\n    }\n\n    proc = (GLFWvkproc) vkGetInstanceProcAddr(instance, procname);\n    if (!proc)\n        proc = (GLFWvkproc) _glfw_dlsym(_glfw.vk.handle, procname);\n\n    return proc;\n}\n\nGLFWAPI int glfwGetPhysicalDevicePresentationSupport(VkInstance instance,\n                                                     VkPhysicalDevice device,\n                                                     uint32_t queuefamily)\n{\n    _GLFW_REQUIRE_INIT_OR_RETURN(GLFW_FALSE);\n\n    if (!_glfwInitVulkan())\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE, \"Vulkan: API not available\");\n        return GLFW_FALSE;\n    }\n\n    if (!_glfw.vk.extensions)\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE,\n                        \"Vulkan: Window surface creation extensions not found\");\n        return GLFW_FALSE;\n    }\n\n    return _glfwPlatformGetPhysicalDevicePresentationSupport(instance,\n                                                             device,\n                                                             queuefamily);\n}\n\nGLFWAPI VkResult glfwCreateWindowSurface(VkInstance instance,\n                                         GLFWwindow* handle,\n                                         const VkAllocationCallbacks* allocator,\n                                         VkSurfaceKHR* surface)\n{\n    _GLFWwindow* window = (_GLFWwindow*) handle;\n    assert(window != NULL);\n    assert(surface != NULL);\n\n    *surface = VK_NULL_HANDLE;\n\n    _GLFW_REQUIRE_INIT_OR_RETURN(VK_ERROR_INITIALIZATION_FAILED);\n\n    if (!_glfwInitVulkan())\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE, \"Vulkan: API not available\");\n        return VK_ERROR_INITIALIZATION_FAILED;\n    }\n\n    if (!_glfw.vk.extensions)\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE,\n                        \"Vulkan: Window surface creation extensions not found\");\n        return VK_ERROR_EXTENSION_NOT_PRESENT;\n    }\n\n    return _glfwPlatformCreateWindowSurface(instance, window, allocator, surface);\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-glfw-3.2.1-gkd54tstzvk3vujbh27j3m4waeirf4if/spack-src/src/win32_platform.h": "//========================================================================\n// GLFW 3.2 Win32 - www.glfw.org\n//------------------------------------------------------------------------\n// Copyright (c) 2002-2006 Marcus Geelnard\n// Copyright (c) 2006-2016 Camilla Berglund <elmindreda@glfw.org>\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would\n//    be appreciated but is not required.\n//\n// 2. Altered source versions must be plainly marked as such, and must not\n//    be misrepresented as being the original software.\n//\n// 3. This notice may not be removed or altered from any source\n//    distribution.\n//\n//========================================================================\n\n#ifndef _glfw3_win32_platform_h_\n#define _glfw3_win32_platform_h_\n\n// We don't need all the fancy stuff\n#ifndef NOMINMAX\n #define NOMINMAX\n#endif\n\n#ifndef VC_EXTRALEAN\n #define VC_EXTRALEAN\n#endif\n\n#ifndef WIN32_LEAN_AND_MEAN\n #define WIN32_LEAN_AND_MEAN\n#endif\n\n// This is a workaround for the fact that glfw3.h needs to export APIENTRY (for\n// example to allow applications to correctly declare a GL_ARB_debug_output\n// callback) but windows.h assumes no one will define APIENTRY before it does\n#undef APIENTRY\n\n// GLFW on Windows is Unicode only and does not work in MBCS mode\n#ifndef UNICODE\n #define UNICODE\n#endif\n\n// GLFW requires Windows XP or later\n#if WINVER < 0x0501\n #undef WINVER\n #define WINVER 0x0501\n#endif\n#if _WIN32_WINNT < 0x0501\n #undef _WIN32_WINNT\n #define _WIN32_WINNT 0x0501\n#endif\n\n// GLFW uses DirectInput8 interfaces\n#define DIRECTINPUT_VERSION 0x0800\n\n#include <wctype.h>\n#include <windows.h>\n#include <mmsystem.h>\n#include <dinput.h>\n#include <xinput.h>\n#include <dbt.h>\n\n#if defined(_MSC_VER)\n #include <malloc.h>\n #define strdup _strdup\n#endif\n\n// HACK: Define macros that some windows.h variants don't\n#ifndef WM_MOUSEHWHEEL\n #define WM_MOUSEHWHEEL 0x020E\n#endif\n#ifndef WM_DWMCOMPOSITIONCHANGED\n #define WM_DWMCOMPOSITIONCHANGED 0x031E\n#endif\n#ifndef WM_COPYGLOBALDATA\n #define WM_COPYGLOBALDATA 0x0049\n#endif\n#ifndef WM_UNICHAR\n #define WM_UNICHAR 0x0109\n#endif\n#ifndef UNICODE_NOCHAR\n #define UNICODE_NOCHAR 0xFFFF\n#endif\n#ifndef WM_DPICHANGED\n #define WM_DPICHANGED 0x02E0\n#endif\n#ifndef GET_XBUTTON_WPARAM\n #define GET_XBUTTON_WPARAM(w) (HIWORD(w))\n#endif\n#ifndef EDS_ROTATEDMODE\n #define EDS_ROTATEDMODE 0x00000004\n#endif\n#ifndef DISPLAY_DEVICE_ACTIVE\n #define DISPLAY_DEVICE_ACTIVE 0x00000001\n#endif\n\n#if WINVER < 0x0601\ntypedef struct tagCHANGEFILTERSTRUCT\n{\n    DWORD cbSize;\n    DWORD ExtStatus;\n\n} CHANGEFILTERSTRUCT, *PCHANGEFILTERSTRUCT;\n#ifndef MSGFLT_ALLOW\n #define MSGFLT_ALLOW 1\n#endif\n#endif /*Windows 7*/\n\n#ifndef DPI_ENUMS_DECLARED\ntypedef enum PROCESS_DPI_AWARENESS\n{\n    PROCESS_DPI_UNAWARE = 0,\n    PROCESS_SYSTEM_DPI_AWARE = 1,\n    PROCESS_PER_MONITOR_DPI_AWARE = 2\n} PROCESS_DPI_AWARENESS;\n#endif /*DPI_ENUMS_DECLARED*/\n\n// HACK: Define macros that some xinput.h variants don't\n#ifndef XINPUT_CAPS_WIRELESS\n #define XINPUT_CAPS_WIRELESS 0x0002\n#endif\n#ifndef XINPUT_DEVSUBTYPE_WHEEL\n #define XINPUT_DEVSUBTYPE_WHEEL 0x02\n#endif\n#ifndef XINPUT_DEVSUBTYPE_ARCADE_STICK\n #define XINPUT_DEVSUBTYPE_ARCADE_STICK 0x03\n#endif\n#ifndef XINPUT_DEVSUBTYPE_FLIGHT_STICK\n #define XINPUT_DEVSUBTYPE_FLIGHT_STICK 0x04\n#endif\n#ifndef XINPUT_DEVSUBTYPE_DANCE_PAD\n #define XINPUT_DEVSUBTYPE_DANCE_PAD 0x05\n#endif\n#ifndef XINPUT_DEVSUBTYPE_GUITAR\n #define XINPUT_DEVSUBTYPE_GUITAR 0x06\n#endif\n#ifndef XINPUT_DEVSUBTYPE_DRUM_KIT\n #define XINPUT_DEVSUBTYPE_DRUM_KIT 0x08\n#endif\n#ifndef XINPUT_DEVSUBTYPE_ARCADE_PAD\n #define XINPUT_DEVSUBTYPE_ARCADE_PAD 0x13\n#endif\n#ifndef XUSER_MAX_COUNT\n #define XUSER_MAX_COUNT 4\n#endif\n\n// HACK: Define macros that some dinput.h variants don't\n#ifndef DIDFT_OPTIONAL\n #define DIDFT_OPTIONAL\t0x80000000\n#endif\n\n// winmm.dll function pointer typedefs\ntypedef DWORD (WINAPI * TIMEGETTIME_T)(void);\n#define _glfw_timeGetTime _glfw.win32.winmm.timeGetTime\n\n// xinput.dll function pointer typedefs\ntypedef DWORD (WINAPI * XINPUTGETCAPABILITIES_T)(DWORD,DWORD,XINPUT_CAPABILITIES*);\ntypedef DWORD (WINAPI * XINPUTGETSTATE_T)(DWORD,XINPUT_STATE*);\n#define _glfw_XInputGetCapabilities _glfw.win32.xinput.XInputGetCapabilities\n#define _glfw_XInputGetState _glfw.win32.xinput.XInputGetState\n\n// dinput8.dll function pointer typedefs\ntypedef HRESULT (WINAPI * DIRECTINPUT8CREATE_T)(HINSTANCE,DWORD,REFIID,LPVOID*,LPUNKNOWN);\n#define _glfw_DirectInput8Create _glfw.win32.dinput8.DirectInput8Create\n\n// user32.dll function pointer typedefs\ntypedef BOOL (WINAPI * SETPROCESSDPIAWARE_T)(void);\ntypedef BOOL (WINAPI * CHANGEWINDOWMESSAGEFILTEREX_T)(HWND,UINT,DWORD,PCHANGEFILTERSTRUCT);\n#define _glfw_SetProcessDPIAware _glfw.win32.user32.SetProcessDPIAware\n#define _glfw_ChangeWindowMessageFilterEx _glfw.win32.user32.ChangeWindowMessageFilterEx\n\n// dwmapi.dll function pointer typedefs\ntypedef HRESULT (WINAPI * DWMISCOMPOSITIONENABLED_T)(BOOL*);\ntypedef HRESULT (WINAPI * DWMFLUSH_T)(VOID);\n#define _glfw_DwmIsCompositionEnabled _glfw.win32.dwmapi.DwmIsCompositionEnabled\n#define _glfw_DwmFlush _glfw.win32.dwmapi.DwmFlush\n\n// shcore.dll function pointer typedefs\ntypedef HRESULT (WINAPI * SETPROCESSDPIAWARENESS_T)(PROCESS_DPI_AWARENESS);\n#define _glfw_SetProcessDpiAwareness _glfw.win32.shcore.SetProcessDpiAwareness\n\ntypedef VkFlags VkWin32SurfaceCreateFlagsKHR;\n\ntypedef struct VkWin32SurfaceCreateInfoKHR\n{\n    VkStructureType                 sType;\n    const void*                     pNext;\n    VkWin32SurfaceCreateFlagsKHR    flags;\n    HINSTANCE                       hinstance;\n    HWND                            hwnd;\n} VkWin32SurfaceCreateInfoKHR;\n\ntypedef VkResult (APIENTRY *PFN_vkCreateWin32SurfaceKHR)(VkInstance,const VkWin32SurfaceCreateInfoKHR*,const VkAllocationCallbacks*,VkSurfaceKHR*);\ntypedef VkBool32 (APIENTRY *PFN_vkGetPhysicalDeviceWin32PresentationSupportKHR)(VkPhysicalDevice,uint32_t);\n\n#include \"win32_joystick.h\"\n#include \"wgl_context.h\"\n#include \"egl_context.h\"\n\n#define _GLFW_WNDCLASSNAME L\"GLFW30\"\n\n#define _glfw_dlopen(name) LoadLibraryA(name)\n#define _glfw_dlclose(handle) FreeLibrary((HMODULE) handle)\n#define _glfw_dlsym(handle, name) GetProcAddress((HMODULE) handle, name)\n\n#define _GLFW_EGL_NATIVE_WINDOW  ((EGLNativeWindowType) window->win32.handle)\n#define _GLFW_EGL_NATIVE_DISPLAY EGL_DEFAULT_DISPLAY\n\n#define _GLFW_PLATFORM_WINDOW_STATE         _GLFWwindowWin32  win32\n#define _GLFW_PLATFORM_LIBRARY_WINDOW_STATE _GLFWlibraryWin32 win32\n#define _GLFW_PLATFORM_LIBRARY_TIME_STATE   _GLFWtimeWin32    win32_time\n#define _GLFW_PLATFORM_LIBRARY_TLS_STATE    _GLFWtlsWin32     win32_tls\n#define _GLFW_PLATFORM_MONITOR_STATE        _GLFWmonitorWin32 win32\n#define _GLFW_PLATFORM_CURSOR_STATE         _GLFWcursorWin32  win32\n\n\n// Win32-specific per-window data\n//\ntypedef struct _GLFWwindowWin32\n{\n    HWND                handle;\n    HICON               bigIcon;\n    HICON               smallIcon;\n\n    GLFWbool            cursorTracked;\n    GLFWbool            iconified;\n\n    // The last received cursor position, regardless of source\n    int                 lastCursorPosX, lastCursorPosY;\n\n} _GLFWwindowWin32;\n\n// Win32-specific global data\n//\ntypedef struct _GLFWlibraryWin32\n{\n    HWND                helperWindowHandle;\n    DWORD               foregroundLockTimeout;\n    char*               clipboardString;\n    char                keyName[64];\n    short int           publicKeys[512];\n    short int           nativeKeys[GLFW_KEY_LAST + 1];\n    // Where to place the cursor when re-enabled\n    double              restoreCursorPosX, restoreCursorPosY;\n    // The window whose disabled cursor mode is active\n    _GLFWwindow*        disabledCursorWindow;\n\n    struct {\n        HINSTANCE       instance;\n        TIMEGETTIME_T   timeGetTime;\n    } winmm;\n\n    struct {\n        HINSTANCE            instance;\n        DIRECTINPUT8CREATE_T DirectInput8Create;\n        IDirectInput8W*      api;\n    } dinput8;\n\n    struct {\n        HINSTANCE               instance;\n        XINPUTGETCAPABILITIES_T XInputGetCapabilities;\n        XINPUTGETSTATE_T        XInputGetState;\n    } xinput;\n\n    struct {\n        HINSTANCE                     instance;\n        SETPROCESSDPIAWARE_T          SetProcessDPIAware;\n        CHANGEWINDOWMESSAGEFILTEREX_T ChangeWindowMessageFilterEx;\n    } user32;\n\n    struct {\n        HINSTANCE       instance;\n        DWMISCOMPOSITIONENABLED_T DwmIsCompositionEnabled;\n        DWMFLUSH_T      DwmFlush;\n    } dwmapi;\n\n    struct {\n        HINSTANCE       instance;\n        SETPROCESSDPIAWARENESS_T SetProcessDpiAwareness;\n    } shcore;\n\n} _GLFWlibraryWin32;\n\n// Win32-specific per-monitor data\n//\ntypedef struct _GLFWmonitorWin32\n{\n    // This size matches the static size of DISPLAY_DEVICE.DeviceName\n    WCHAR               adapterName[32];\n    WCHAR               displayName[32];\n    char                publicAdapterName[64];\n    char                publicDisplayName[64];\n    GLFWbool            modesPruned;\n    GLFWbool            modeChanged;\n\n} _GLFWmonitorWin32;\n\n// Win32-specific per-cursor data\n//\ntypedef struct _GLFWcursorWin32\n{\n    HCURSOR handle;\n\n} _GLFWcursorWin32;\n\n// Win32-specific global timer data\n//\ntypedef struct _GLFWtimeWin32\n{\n    GLFWbool            hasPC;\n    uint64_t            frequency;\n\n} _GLFWtimeWin32;\n\n// Win32-specific global TLS data\n//\ntypedef struct _GLFWtlsWin32\n{\n    GLFWbool        allocated;\n    DWORD           context;\n\n} _GLFWtlsWin32;\n\n\nGLFWbool _glfwRegisterWindowClassWin32(void);\nvoid _glfwUnregisterWindowClassWin32(void);\n\nGLFWbool _glfwInitThreadLocalStorageWin32(void);\nvoid _glfwTerminateThreadLocalStorageWin32(void);\n\nWCHAR* _glfwCreateWideStringFromUTF8Win32(const char* source);\nchar* _glfwCreateUTF8FromWideStringWin32(const WCHAR* source);\n\nvoid _glfwInitTimerWin32(void);\n\nGLFWbool _glfwSetVideoModeWin32(_GLFWmonitor* monitor, const GLFWvidmode* desired);\nvoid _glfwRestoreVideoModeWin32(_GLFWmonitor* monitor);\n\n#endif // _glfw3_win32_platform_h_\n",
        "/tmp/vanessa/spack-stage/spack-stage-glfw-3.2.1-gkd54tstzvk3vujbh27j3m4waeirf4if/spack-src/src/glx_context.c": "//========================================================================\n// GLFW 3.2 GLX - www.glfw.org\n//------------------------------------------------------------------------\n// Copyright (c) 2002-2006 Marcus Geelnard\n// Copyright (c) 2006-2016 Camilla Berglund <elmindreda@glfw.org>\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would\n//    be appreciated but is not required.\n//\n// 2. Altered source versions must be plainly marked as such, and must not\n//    be misrepresented as being the original software.\n//\n// 3. This notice may not be removed or altered from any source\n//    distribution.\n//\n//========================================================================\n\n#include \"internal.h\"\n\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n\n#ifndef GLXBadProfileARB\n #define GLXBadProfileARB 13\n#endif\n\n\n// Returns the specified attribute of the specified GLXFBConfig\n//\nstatic int getGLXFBConfigAttrib(GLXFBConfig fbconfig, int attrib)\n{\n    int value;\n    glXGetFBConfigAttrib(_glfw.x11.display, fbconfig, attrib, &value);\n    return value;\n}\n\n// Return the GLXFBConfig most closely matching the specified hints\n//\nstatic GLFWbool chooseGLXFBConfig(const _GLFWfbconfig* desired, GLXFBConfig* result)\n{\n    GLXFBConfig* nativeConfigs;\n    _GLFWfbconfig* usableConfigs;\n    const _GLFWfbconfig* closest;\n    int i, nativeCount, usableCount;\n    const char* vendor;\n    GLFWbool trustWindowBit = GLFW_TRUE;\n\n    // HACK: This is a (hopefully temporary) workaround for Chromium\n    //       (VirtualBox GL) not setting the window bit on any GLXFBConfigs\n    vendor = glXGetClientString(_glfw.x11.display, GLX_VENDOR);\n    if (strcmp(vendor, \"Chromium\") == 0)\n        trustWindowBit = GLFW_FALSE;\n\n    nativeConfigs =\n        glXGetFBConfigs(_glfw.x11.display, _glfw.x11.screen, &nativeCount);\n    if (!nativeCount)\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE, \"GLX: No GLXFBConfigs returned\");\n        return GLFW_FALSE;\n    }\n\n    usableConfigs = calloc(nativeCount, sizeof(_GLFWfbconfig));\n    usableCount = 0;\n\n    for (i = 0;  i < nativeCount;  i++)\n    {\n        const GLXFBConfig n = nativeConfigs[i];\n        _GLFWfbconfig* u = usableConfigs + usableCount;\n\n        // Only consider RGBA GLXFBConfigs\n        if (!(getGLXFBConfigAttrib(n, GLX_RENDER_TYPE) & GLX_RGBA_BIT))\n            continue;\n\n        // Only consider window GLXFBConfigs\n        if (!(getGLXFBConfigAttrib(n, GLX_DRAWABLE_TYPE) & GLX_WINDOW_BIT))\n        {\n            if (trustWindowBit)\n                continue;\n        }\n\n        u->redBits = getGLXFBConfigAttrib(n, GLX_RED_SIZE);\n        u->greenBits = getGLXFBConfigAttrib(n, GLX_GREEN_SIZE);\n        u->blueBits = getGLXFBConfigAttrib(n, GLX_BLUE_SIZE);\n\n        u->alphaBits = getGLXFBConfigAttrib(n, GLX_ALPHA_SIZE);\n        u->depthBits = getGLXFBConfigAttrib(n, GLX_DEPTH_SIZE);\n        u->stencilBits = getGLXFBConfigAttrib(n, GLX_STENCIL_SIZE);\n\n        u->accumRedBits = getGLXFBConfigAttrib(n, GLX_ACCUM_RED_SIZE);\n        u->accumGreenBits = getGLXFBConfigAttrib(n, GLX_ACCUM_GREEN_SIZE);\n        u->accumBlueBits = getGLXFBConfigAttrib(n, GLX_ACCUM_BLUE_SIZE);\n        u->accumAlphaBits = getGLXFBConfigAttrib(n, GLX_ACCUM_ALPHA_SIZE);\n\n        u->auxBuffers = getGLXFBConfigAttrib(n, GLX_AUX_BUFFERS);\n\n        if (getGLXFBConfigAttrib(n, GLX_STEREO))\n            u->stereo = GLFW_TRUE;\n        if (getGLXFBConfigAttrib(n, GLX_DOUBLEBUFFER))\n            u->doublebuffer = GLFW_TRUE;\n\n        if (_glfw.glx.ARB_multisample)\n            u->samples = getGLXFBConfigAttrib(n, GLX_SAMPLES);\n\n        if (_glfw.glx.ARB_framebuffer_sRGB || _glfw.glx.EXT_framebuffer_sRGB)\n            u->sRGB = getGLXFBConfigAttrib(n, GLX_FRAMEBUFFER_SRGB_CAPABLE_ARB);\n\n        u->handle = (uintptr_t) n;\n        usableCount++;\n    }\n\n    closest = _glfwChooseFBConfig(desired, usableConfigs, usableCount);\n    if (closest)\n        *result = (GLXFBConfig) closest->handle;\n\n    XFree(nativeConfigs);\n    free(usableConfigs);\n\n    return closest != NULL;\n}\n\n// Create the OpenGL context using legacy API\n//\nstatic GLXContext createLegacyContextGLX(_GLFWwindow* window,\n                                         GLXFBConfig fbconfig,\n                                         GLXContext share)\n{\n    return glXCreateNewContext(_glfw.x11.display,\n                               fbconfig,\n                               GLX_RGBA_TYPE,\n                               share,\n                               True);\n}\n\nstatic void makeContextCurrentGLX(_GLFWwindow* window)\n{\n    if (window)\n    {\n        if (!glXMakeCurrent(_glfw.x11.display,\n                            window->context.glx.window,\n                            window->context.glx.handle))\n        {\n            _glfwInputError(GLFW_PLATFORM_ERROR,\n                            \"GLX: Failed to make context current\");\n            return;\n        }\n    }\n    else\n    {\n        if (!glXMakeCurrent(_glfw.x11.display, None, NULL))\n        {\n            _glfwInputError(GLFW_PLATFORM_ERROR,\n                            \"GLX: Failed to clear current context\");\n            return;\n        }\n    }\n\n    _glfwPlatformSetCurrentContext(window);\n}\n\nstatic void swapBuffersGLX(_GLFWwindow* window)\n{\n    glXSwapBuffers(_glfw.x11.display, window->context.glx.window);\n}\n\nstatic void swapIntervalGLX(int interval)\n{\n    _GLFWwindow* window = _glfwPlatformGetCurrentContext();\n\n    if (_glfw.glx.EXT_swap_control)\n    {\n        _glfw.glx.SwapIntervalEXT(_glfw.x11.display,\n                                  window->context.glx.window,\n                                  interval);\n    }\n    else if (_glfw.glx.MESA_swap_control)\n        _glfw.glx.SwapIntervalMESA(interval);\n    else if (_glfw.glx.SGI_swap_control)\n    {\n        if (interval > 0)\n            _glfw.glx.SwapIntervalSGI(interval);\n    }\n}\n\nstatic int extensionSupportedGLX(const char* extension)\n{\n    const char* extensions =\n        glXQueryExtensionsString(_glfw.x11.display, _glfw.x11.screen);\n    if (extensions)\n    {\n        if (_glfwStringInExtensionString(extension, extensions))\n            return GLFW_TRUE;\n    }\n\n    return GLFW_FALSE;\n}\n\nstatic GLFWglproc getProcAddressGLX(const char* procname)\n{\n    if (_glfw.glx.GetProcAddress)\n        return _glfw.glx.GetProcAddress((const GLubyte*) procname);\n    else if (_glfw.glx.GetProcAddressARB)\n        return _glfw.glx.GetProcAddressARB((const GLubyte*) procname);\n    else\n        return dlsym(_glfw.glx.handle, procname);\n}\n\n// Destroy the OpenGL context\n//\nstatic void destroyContextGLX(_GLFWwindow* window)\n{\n    if (window->context.glx.window)\n    {\n        glXDestroyWindow(_glfw.x11.display, window->context.glx.window);\n        window->context.glx.window = None;\n    }\n\n    if (window->context.glx.handle)\n    {\n        glXDestroyContext(_glfw.x11.display, window->context.glx.handle);\n        window->context.glx.handle = NULL;\n    }\n}\n\n\n//////////////////////////////////////////////////////////////////////////\n//////                       GLFW internal API                      //////\n//////////////////////////////////////////////////////////////////////////\n\n// Initialize GLX\n//\nGLFWbool _glfwInitGLX(void)\n{\n    int i;\n    const char* sonames[] =\n    {\n#if defined(__CYGWIN__)\n        \"libGL-1.so\",\n#else\n        \"libGL.so.1\",\n        \"libGL.so\",\n#endif\n        NULL\n    };\n\n    if (_glfw.glx.handle)\n        return GLFW_TRUE;\n\n    for (i = 0;  sonames[i];  i++)\n    {\n        _glfw.glx.handle = dlopen(sonames[i], RTLD_LAZY | RTLD_GLOBAL);\n        if (_glfw.glx.handle)\n            break;\n    }\n\n    if (!_glfw.glx.handle)\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE, \"GLX: Failed to load GLX\");\n        return GLFW_FALSE;\n    }\n\n    _glfw.glx.GetFBConfigs =\n        dlsym(_glfw.glx.handle, \"glXGetFBConfigs\");\n    _glfw.glx.GetFBConfigAttrib =\n        dlsym(_glfw.glx.handle, \"glXGetFBConfigAttrib\");\n    _glfw.glx.GetClientString =\n        dlsym(_glfw.glx.handle, \"glXGetClientString\");\n    _glfw.glx.QueryExtension =\n        dlsym(_glfw.glx.handle, \"glXQueryExtension\");\n    _glfw.glx.QueryVersion =\n        dlsym(_glfw.glx.handle, \"glXQueryVersion\");\n    _glfw.glx.DestroyContext =\n        dlsym(_glfw.glx.handle, \"glXDestroyContext\");\n    _glfw.glx.MakeCurrent =\n        dlsym(_glfw.glx.handle, \"glXMakeCurrent\");\n    _glfw.glx.SwapBuffers =\n        dlsym(_glfw.glx.handle, \"glXSwapBuffers\");\n    _glfw.glx.QueryExtensionsString =\n        dlsym(_glfw.glx.handle, \"glXQueryExtensionsString\");\n    _glfw.glx.CreateNewContext =\n        dlsym(_glfw.glx.handle, \"glXCreateNewContext\");\n    _glfw.glx.CreateWindow =\n        dlsym(_glfw.glx.handle, \"glXCreateWindow\");\n    _glfw.glx.DestroyWindow =\n        dlsym(_glfw.glx.handle, \"glXDestroyWindow\");\n    _glfw.glx.GetProcAddress =\n        dlsym(_glfw.glx.handle, \"glXGetProcAddress\");\n    _glfw.glx.GetProcAddressARB =\n        dlsym(_glfw.glx.handle, \"glXGetProcAddressARB\");\n    _glfw.glx.GetVisualFromFBConfig =\n        dlsym(_glfw.glx.handle, \"glXGetVisualFromFBConfig\");\n\n    if (!_glfw.glx.GetFBConfigs ||\n        !_glfw.glx.GetFBConfigAttrib ||\n        !_glfw.glx.GetClientString ||\n        !_glfw.glx.QueryExtension ||\n        !_glfw.glx.QueryVersion ||\n        !_glfw.glx.DestroyContext ||\n        !_glfw.glx.MakeCurrent ||\n        !_glfw.glx.SwapBuffers ||\n        !_glfw.glx.QueryExtensionsString ||\n        !_glfw.glx.CreateNewContext ||\n        !_glfw.glx.CreateWindow ||\n        !_glfw.glx.DestroyWindow ||\n        !_glfw.glx.GetProcAddress ||\n        !_glfw.glx.GetProcAddressARB ||\n        !_glfw.glx.GetVisualFromFBConfig)\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"GLX: Failed to load required entry points\");\n        return GLFW_FALSE;\n    }\n\n    if (!glXQueryExtension(_glfw.x11.display,\n                           &_glfw.glx.errorBase,\n                           &_glfw.glx.eventBase))\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE, \"GLX: GLX extension not found\");\n        return GLFW_FALSE;\n    }\n\n    if (!glXQueryVersion(_glfw.x11.display, &_glfw.glx.major, &_glfw.glx.minor))\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE,\n                        \"GLX: Failed to query GLX version\");\n        return GLFW_FALSE;\n    }\n\n    if (_glfw.glx.major == 1 && _glfw.glx.minor < 3)\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE,\n                        \"GLX: GLX version 1.3 is required\");\n        return GLFW_FALSE;\n    }\n\n    if (extensionSupportedGLX(\"GLX_EXT_swap_control\"))\n    {\n        _glfw.glx.SwapIntervalEXT = (PFNGLXSWAPINTERVALEXTPROC)\n            getProcAddressGLX(\"glXSwapIntervalEXT\");\n\n        if (_glfw.glx.SwapIntervalEXT)\n            _glfw.glx.EXT_swap_control = GLFW_TRUE;\n    }\n\n    if (extensionSupportedGLX(\"GLX_SGI_swap_control\"))\n    {\n        _glfw.glx.SwapIntervalSGI = (PFNGLXSWAPINTERVALSGIPROC)\n            getProcAddressGLX(\"glXSwapIntervalSGI\");\n\n        if (_glfw.glx.SwapIntervalSGI)\n            _glfw.glx.SGI_swap_control = GLFW_TRUE;\n    }\n\n    if (extensionSupportedGLX(\"GLX_MESA_swap_control\"))\n    {\n        _glfw.glx.SwapIntervalMESA = (PFNGLXSWAPINTERVALMESAPROC)\n            getProcAddressGLX(\"glXSwapIntervalMESA\");\n\n        if (_glfw.glx.SwapIntervalMESA)\n            _glfw.glx.MESA_swap_control = GLFW_TRUE;\n    }\n\n    if (extensionSupportedGLX(\"GLX_ARB_multisample\"))\n        _glfw.glx.ARB_multisample = GLFW_TRUE;\n\n    if (extensionSupportedGLX(\"GLX_ARB_framebuffer_sRGB\"))\n        _glfw.glx.ARB_framebuffer_sRGB = GLFW_TRUE;\n\n    if (extensionSupportedGLX(\"GLX_EXT_framebuffer_sRGB\"))\n        _glfw.glx.EXT_framebuffer_sRGB = GLFW_TRUE;\n\n    if (extensionSupportedGLX(\"GLX_ARB_create_context\"))\n    {\n        _glfw.glx.CreateContextAttribsARB = (PFNGLXCREATECONTEXTATTRIBSARBPROC)\n            getProcAddressGLX(\"glXCreateContextAttribsARB\");\n\n        if (_glfw.glx.CreateContextAttribsARB)\n            _glfw.glx.ARB_create_context = GLFW_TRUE;\n    }\n\n    if (extensionSupportedGLX(\"GLX_ARB_create_context_robustness\"))\n        _glfw.glx.ARB_create_context_robustness = GLFW_TRUE;\n\n    if (extensionSupportedGLX(\"GLX_ARB_create_context_profile\"))\n        _glfw.glx.ARB_create_context_profile = GLFW_TRUE;\n\n    if (extensionSupportedGLX(\"GLX_EXT_create_context_es2_profile\"))\n        _glfw.glx.EXT_create_context_es2_profile = GLFW_TRUE;\n\n    if (extensionSupportedGLX(\"GLX_ARB_context_flush_control\"))\n        _glfw.glx.ARB_context_flush_control = GLFW_TRUE;\n\n    return GLFW_TRUE;\n}\n\n// Terminate GLX\n//\nvoid _glfwTerminateGLX(void)\n{\n    // NOTE: This function must not call any X11 functions, as it is called\n    //       after XCloseDisplay (see _glfwPlatformTerminate for details)\n\n    if (_glfw.glx.handle)\n    {\n        dlclose(_glfw.glx.handle);\n        _glfw.glx.handle = NULL;\n    }\n}\n\n#define setGLXattrib(attribName, attribValue) \\\n{ \\\n    attribs[index++] = attribName; \\\n    attribs[index++] = attribValue; \\\n    assert((size_t) index < sizeof(attribs) / sizeof(attribs[0])); \\\n}\n\n// Create the OpenGL or OpenGL ES context\n//\nGLFWbool _glfwCreateContextGLX(_GLFWwindow* window,\n                               const _GLFWctxconfig* ctxconfig,\n                               const _GLFWfbconfig* fbconfig)\n{\n    int attribs[40];\n    GLXFBConfig native = NULL;\n    GLXContext share = NULL;\n\n    if (ctxconfig->share)\n        share = ctxconfig->share->context.glx.handle;\n\n    if (!chooseGLXFBConfig(fbconfig, &native))\n    {\n        _glfwInputError(GLFW_FORMAT_UNAVAILABLE,\n                        \"GLX: Failed to find a suitable GLXFBConfig\");\n        return GLFW_FALSE;\n    }\n\n    if (ctxconfig->client == GLFW_OPENGL_ES_API)\n    {\n        if (!_glfw.glx.ARB_create_context ||\n            !_glfw.glx.ARB_create_context_profile ||\n            !_glfw.glx.EXT_create_context_es2_profile)\n        {\n            _glfwInputError(GLFW_API_UNAVAILABLE,\n                            \"GLX: OpenGL ES requested but GLX_EXT_create_context_es2_profile is unavailable\");\n            return GLFW_FALSE;\n        }\n    }\n\n    if (ctxconfig->forward)\n    {\n        if (!_glfw.glx.ARB_create_context)\n        {\n            _glfwInputError(GLFW_VERSION_UNAVAILABLE,\n                            \"GLX: Forward compatibility requested but GLX_ARB_create_context_profile is unavailable\");\n            return GLFW_FALSE;\n        }\n    }\n\n    if (ctxconfig->profile)\n    {\n        if (!_glfw.glx.ARB_create_context ||\n            !_glfw.glx.ARB_create_context_profile)\n        {\n            _glfwInputError(GLFW_VERSION_UNAVAILABLE,\n                            \"GLX: An OpenGL profile requested but GLX_ARB_create_context_profile is unavailable\");\n            return GLFW_FALSE;\n        }\n    }\n\n    _glfwGrabErrorHandlerX11();\n\n    if (_glfw.glx.ARB_create_context)\n    {\n        int index = 0, mask = 0, flags = 0;\n\n        if (ctxconfig->client == GLFW_OPENGL_API)\n        {\n            if (ctxconfig->forward)\n                flags |= GLX_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB;\n\n            if (ctxconfig->profile == GLFW_OPENGL_CORE_PROFILE)\n                mask |= GLX_CONTEXT_CORE_PROFILE_BIT_ARB;\n            else if (ctxconfig->profile == GLFW_OPENGL_COMPAT_PROFILE)\n                mask |= GLX_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB;\n        }\n        else\n            mask |= GLX_CONTEXT_ES2_PROFILE_BIT_EXT;\n\n        if (ctxconfig->debug)\n            flags |= GLX_CONTEXT_DEBUG_BIT_ARB;\n        if (ctxconfig->noerror)\n            flags |= GL_CONTEXT_FLAG_NO_ERROR_BIT_KHR;\n\n        if (ctxconfig->robustness)\n        {\n            if (_glfw.glx.ARB_create_context_robustness)\n            {\n                if (ctxconfig->robustness == GLFW_NO_RESET_NOTIFICATION)\n                {\n                    setGLXattrib(GLX_CONTEXT_RESET_NOTIFICATION_STRATEGY_ARB,\n                                 GLX_NO_RESET_NOTIFICATION_ARB);\n                }\n                else if (ctxconfig->robustness == GLFW_LOSE_CONTEXT_ON_RESET)\n                {\n                    setGLXattrib(GLX_CONTEXT_RESET_NOTIFICATION_STRATEGY_ARB,\n                                 GLX_LOSE_CONTEXT_ON_RESET_ARB);\n                }\n\n                flags |= GLX_CONTEXT_ROBUST_ACCESS_BIT_ARB;\n            }\n        }\n\n        if (ctxconfig->release)\n        {\n            if (_glfw.glx.ARB_context_flush_control)\n            {\n                if (ctxconfig->release == GLFW_RELEASE_BEHAVIOR_NONE)\n                {\n                    setGLXattrib(GLX_CONTEXT_RELEASE_BEHAVIOR_ARB,\n                                 GLX_CONTEXT_RELEASE_BEHAVIOR_NONE_ARB);\n                }\n                else if (ctxconfig->release == GLFW_RELEASE_BEHAVIOR_FLUSH)\n                {\n                    setGLXattrib(GLX_CONTEXT_RELEASE_BEHAVIOR_ARB,\n                                 GLX_CONTEXT_RELEASE_BEHAVIOR_FLUSH_ARB);\n                }\n            }\n        }\n\n        // NOTE: Only request an explicitly versioned context when necessary, as\n        //       explicitly requesting version 1.0 does not always return the\n        //       highest version supported by the driver\n        if (ctxconfig->major != 1 || ctxconfig->minor != 0)\n        {\n            setGLXattrib(GLX_CONTEXT_MAJOR_VERSION_ARB, ctxconfig->major);\n            setGLXattrib(GLX_CONTEXT_MINOR_VERSION_ARB, ctxconfig->minor);\n        }\n\n        if (mask)\n            setGLXattrib(GLX_CONTEXT_PROFILE_MASK_ARB, mask);\n\n        if (flags)\n            setGLXattrib(GLX_CONTEXT_FLAGS_ARB, flags);\n\n        setGLXattrib(None, None);\n\n        window->context.glx.handle =\n            _glfw.glx.CreateContextAttribsARB(_glfw.x11.display,\n                                              native,\n                                              share,\n                                              True,\n                                              attribs);\n\n        // HACK: This is a fallback for broken versions of the Mesa\n        //       implementation of GLX_ARB_create_context_profile that fail\n        //       default 1.0 context creation with a GLXBadProfileARB error in\n        //       violation of the extension spec\n        if (!window->context.glx.handle)\n        {\n            if (_glfw.x11.errorCode == _glfw.glx.errorBase + GLXBadProfileARB &&\n                ctxconfig->client == GLFW_OPENGL_API &&\n                ctxconfig->profile == GLFW_OPENGL_ANY_PROFILE &&\n                ctxconfig->forward == GLFW_FALSE)\n            {\n                window->context.glx.handle =\n                    createLegacyContextGLX(window, native, share);\n            }\n        }\n    }\n    else\n    {\n        window->context.glx.handle =\n            createLegacyContextGLX(window, native, share);\n    }\n\n    _glfwReleaseErrorHandlerX11();\n\n    if (!window->context.glx.handle)\n    {\n        _glfwInputErrorX11(GLFW_VERSION_UNAVAILABLE, \"GLX: Failed to create context\");\n        return GLFW_FALSE;\n    }\n\n    window->context.glx.window =\n        glXCreateWindow(_glfw.x11.display, native, window->x11.handle, NULL);\n    if (!window->context.glx.window)\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR, \"GLX: Failed to create window\");\n        return GLFW_FALSE;\n    }\n\n    window->context.makeCurrent = makeContextCurrentGLX;\n    window->context.swapBuffers = swapBuffersGLX;\n    window->context.swapInterval = swapIntervalGLX;\n    window->context.extensionSupported = extensionSupportedGLX;\n    window->context.getProcAddress = getProcAddressGLX;\n    window->context.destroy = destroyContextGLX;\n\n    return GLFW_TRUE;\n}\n\n#undef setGLXattrib\n\n// Returns the Visual and depth of the chosen GLXFBConfig\n//\nGLFWbool _glfwChooseVisualGLX(const _GLFWctxconfig* ctxconfig,\n                              const _GLFWfbconfig* fbconfig,\n                              Visual** visual, int* depth)\n{\n    GLXFBConfig native;\n    XVisualInfo* result;\n\n    if (!chooseGLXFBConfig(fbconfig, &native))\n    {\n        _glfwInputError(GLFW_FORMAT_UNAVAILABLE,\n                        \"GLX: Failed to find a suitable GLXFBConfig\");\n        return GLFW_FALSE;\n    }\n\n    result = glXGetVisualFromFBConfig(_glfw.x11.display, native);\n    if (!result)\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"GLX: Failed to retrieve Visual for GLXFBConfig\");\n        return GLFW_FALSE;\n    }\n\n    *visual = result->visual;\n    *depth = result->depth;\n\n    XFree(result);\n    return GLFW_TRUE;\n}\n\n\n//////////////////////////////////////////////////////////////////////////\n//////                        GLFW native API                       //////\n//////////////////////////////////////////////////////////////////////////\n\nGLFWAPI GLXContext glfwGetGLXContext(GLFWwindow* handle)\n{\n    _GLFWwindow* window = (_GLFWwindow*) handle;\n    _GLFW_REQUIRE_INIT_OR_RETURN(NULL);\n\n    if (window->context.client == GLFW_NO_API)\n    {\n        _glfwInputError(GLFW_NO_WINDOW_CONTEXT, NULL);\n        return NULL;\n    }\n\n    return window->context.glx.handle;\n}\n\nGLFWAPI GLXWindow glfwGetGLXWindow(GLFWwindow* handle)\n{\n    _GLFWwindow* window = (_GLFWwindow*) handle;\n    _GLFW_REQUIRE_INIT_OR_RETURN(None);\n\n    if (window->context.client == GLFW_NO_API)\n    {\n        _glfwInputError(GLFW_NO_WINDOW_CONTEXT, NULL);\n        return None;\n    }\n\n    return window->context.glx.window;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-glfw-3.2.1-gkd54tstzvk3vujbh27j3m4waeirf4if/spack-src/src/nsgl_context.h": "//========================================================================\n// GLFW 3.2 OS X - www.glfw.org\n//------------------------------------------------------------------------\n// Copyright (c) 2009-2016 Camilla Berglund <elmindreda@glfw.org>\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would\n//    be appreciated but is not required.\n//\n// 2. Altered source versions must be plainly marked as such, and must not\n//    be misrepresented as being the original software.\n//\n// 3. This notice may not be removed or altered from any source\n//    distribution.\n//\n//========================================================================\n\n#ifndef _glfw3_nsgl_context_h_\n#define _glfw3_nsgl_context_h_\n\n#define _GLFW_PLATFORM_CONTEXT_STATE            _GLFWcontextNSGL nsgl\n#define _GLFW_PLATFORM_LIBRARY_CONTEXT_STATE    _GLFWlibraryNSGL nsgl\n\n\n// NSGL-specific per-context data\n//\ntypedef struct _GLFWcontextNSGL\n{\n    id           pixelFormat;\n    id\t         object;\n\n} _GLFWcontextNSGL;\n\n// NSGL-specific global data\n//\ntypedef struct _GLFWlibraryNSGL\n{\n    // dlopen handle for OpenGL.framework (for glfwGetProcAddress)\n    CFBundleRef     framework;\n\n} _GLFWlibraryNSGL;\n\n\nGLFWbool _glfwInitNSGL(void);\nvoid _glfwTerminateNSGL(void);\nGLFWbool _glfwCreateContextNSGL(_GLFWwindow* window,\n                                const _GLFWctxconfig* ctxconfig,\n                                const _GLFWfbconfig* fbconfig);\nvoid _glfwDestroyContextNSGL(_GLFWwindow* window);\n\n#endif // _glfw3_nsgl_context_h_\n",
        "/tmp/vanessa/spack-stage/spack-stage-glfw-3.2.1-gkd54tstzvk3vujbh27j3m4waeirf4if/spack-src/src/x11_init.c": "//========================================================================\n// GLFW 3.2 X11 - www.glfw.org\n//------------------------------------------------------------------------\n// Copyright (c) 2002-2006 Marcus Geelnard\n// Copyright (c) 2006-2016 Camilla Berglund <elmindreda@glfw.org>\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would\n//    be appreciated but is not required.\n//\n// 2. Altered source versions must be plainly marked as such, and must not\n//    be misrepresented as being the original software.\n//\n// 3. This notice may not be removed or altered from any source\n//    distribution.\n//\n//========================================================================\n\n#include \"internal.h\"\n\n#include <X11/Xresource.h>\n\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n#include <stdio.h>\n#include <locale.h>\n\n\n// Translate an X11 key code to a GLFW key code.\n//\nstatic int translateKeyCode(int scancode)\n{\n    int keySym;\n\n    // Valid key code range is  [8,255], according to the Xlib manual\n    if (scancode < 8 || scancode > 255)\n        return GLFW_KEY_UNKNOWN;\n\n    if (_glfw.x11.xkb.available)\n    {\n        // Try secondary keysym, for numeric keypad keys\n        // Note: This way we always force \"NumLock = ON\", which is intentional\n        // since the returned key code should correspond to a physical\n        // location.\n        keySym = XkbKeycodeToKeysym(_glfw.x11.display, scancode, 0, 1);\n        switch (keySym)\n        {\n            case XK_KP_0:           return GLFW_KEY_KP_0;\n            case XK_KP_1:           return GLFW_KEY_KP_1;\n            case XK_KP_2:           return GLFW_KEY_KP_2;\n            case XK_KP_3:           return GLFW_KEY_KP_3;\n            case XK_KP_4:           return GLFW_KEY_KP_4;\n            case XK_KP_5:           return GLFW_KEY_KP_5;\n            case XK_KP_6:           return GLFW_KEY_KP_6;\n            case XK_KP_7:           return GLFW_KEY_KP_7;\n            case XK_KP_8:           return GLFW_KEY_KP_8;\n            case XK_KP_9:           return GLFW_KEY_KP_9;\n            case XK_KP_Separator:\n            case XK_KP_Decimal:     return GLFW_KEY_KP_DECIMAL;\n            case XK_KP_Equal:       return GLFW_KEY_KP_EQUAL;\n            case XK_KP_Enter:       return GLFW_KEY_KP_ENTER;\n            default:                break;\n        }\n\n        // Now try primary keysym for function keys (non-printable keys)\n        // These should not depend on the current keyboard layout\n        keySym = XkbKeycodeToKeysym(_glfw.x11.display, scancode, 0, 0);\n    }\n    else\n    {\n        int dummy;\n        KeySym* keySyms;\n\n        keySyms = XGetKeyboardMapping(_glfw.x11.display, scancode, 1, &dummy);\n        keySym = keySyms[0];\n        XFree(keySyms);\n    }\n\n    switch (keySym)\n    {\n        case XK_Escape:         return GLFW_KEY_ESCAPE;\n        case XK_Tab:            return GLFW_KEY_TAB;\n        case XK_Shift_L:        return GLFW_KEY_LEFT_SHIFT;\n        case XK_Shift_R:        return GLFW_KEY_RIGHT_SHIFT;\n        case XK_Control_L:      return GLFW_KEY_LEFT_CONTROL;\n        case XK_Control_R:      return GLFW_KEY_RIGHT_CONTROL;\n        case XK_Meta_L:\n        case XK_Alt_L:          return GLFW_KEY_LEFT_ALT;\n        case XK_Mode_switch: // Mapped to Alt_R on many keyboards\n        case XK_ISO_Level3_Shift: // AltGr on at least some machines\n        case XK_Meta_R:\n        case XK_Alt_R:          return GLFW_KEY_RIGHT_ALT;\n        case XK_Super_L:        return GLFW_KEY_LEFT_SUPER;\n        case XK_Super_R:        return GLFW_KEY_RIGHT_SUPER;\n        case XK_Menu:           return GLFW_KEY_MENU;\n        case XK_Num_Lock:       return GLFW_KEY_NUM_LOCK;\n        case XK_Caps_Lock:      return GLFW_KEY_CAPS_LOCK;\n        case XK_Print:          return GLFW_KEY_PRINT_SCREEN;\n        case XK_Scroll_Lock:    return GLFW_KEY_SCROLL_LOCK;\n        case XK_Pause:          return GLFW_KEY_PAUSE;\n        case XK_Delete:         return GLFW_KEY_DELETE;\n        case XK_BackSpace:      return GLFW_KEY_BACKSPACE;\n        case XK_Return:         return GLFW_KEY_ENTER;\n        case XK_Home:           return GLFW_KEY_HOME;\n        case XK_End:            return GLFW_KEY_END;\n        case XK_Page_Up:        return GLFW_KEY_PAGE_UP;\n        case XK_Page_Down:      return GLFW_KEY_PAGE_DOWN;\n        case XK_Insert:         return GLFW_KEY_INSERT;\n        case XK_Left:           return GLFW_KEY_LEFT;\n        case XK_Right:          return GLFW_KEY_RIGHT;\n        case XK_Down:           return GLFW_KEY_DOWN;\n        case XK_Up:             return GLFW_KEY_UP;\n        case XK_F1:             return GLFW_KEY_F1;\n        case XK_F2:             return GLFW_KEY_F2;\n        case XK_F3:             return GLFW_KEY_F3;\n        case XK_F4:             return GLFW_KEY_F4;\n        case XK_F5:             return GLFW_KEY_F5;\n        case XK_F6:             return GLFW_KEY_F6;\n        case XK_F7:             return GLFW_KEY_F7;\n        case XK_F8:             return GLFW_KEY_F8;\n        case XK_F9:             return GLFW_KEY_F9;\n        case XK_F10:            return GLFW_KEY_F10;\n        case XK_F11:            return GLFW_KEY_F11;\n        case XK_F12:            return GLFW_KEY_F12;\n        case XK_F13:            return GLFW_KEY_F13;\n        case XK_F14:            return GLFW_KEY_F14;\n        case XK_F15:            return GLFW_KEY_F15;\n        case XK_F16:            return GLFW_KEY_F16;\n        case XK_F17:            return GLFW_KEY_F17;\n        case XK_F18:            return GLFW_KEY_F18;\n        case XK_F19:            return GLFW_KEY_F19;\n        case XK_F20:            return GLFW_KEY_F20;\n        case XK_F21:            return GLFW_KEY_F21;\n        case XK_F22:            return GLFW_KEY_F22;\n        case XK_F23:            return GLFW_KEY_F23;\n        case XK_F24:            return GLFW_KEY_F24;\n        case XK_F25:            return GLFW_KEY_F25;\n\n        // Numeric keypad\n        case XK_KP_Divide:      return GLFW_KEY_KP_DIVIDE;\n        case XK_KP_Multiply:    return GLFW_KEY_KP_MULTIPLY;\n        case XK_KP_Subtract:    return GLFW_KEY_KP_SUBTRACT;\n        case XK_KP_Add:         return GLFW_KEY_KP_ADD;\n\n        // These should have been detected in secondary keysym test above!\n        case XK_KP_Insert:      return GLFW_KEY_KP_0;\n        case XK_KP_End:         return GLFW_KEY_KP_1;\n        case XK_KP_Down:        return GLFW_KEY_KP_2;\n        case XK_KP_Page_Down:   return GLFW_KEY_KP_3;\n        case XK_KP_Left:        return GLFW_KEY_KP_4;\n        case XK_KP_Right:       return GLFW_KEY_KP_6;\n        case XK_KP_Home:        return GLFW_KEY_KP_7;\n        case XK_KP_Up:          return GLFW_KEY_KP_8;\n        case XK_KP_Page_Up:     return GLFW_KEY_KP_9;\n        case XK_KP_Delete:      return GLFW_KEY_KP_DECIMAL;\n        case XK_KP_Equal:       return GLFW_KEY_KP_EQUAL;\n        case XK_KP_Enter:       return GLFW_KEY_KP_ENTER;\n\n        // Last resort: Check for printable keys (should not happen if the XKB\n        // extension is available). This will give a layout dependent mapping\n        // (which is wrong, and we may miss some keys, especially on non-US\n        // keyboards), but it's better than nothing...\n        case XK_a:              return GLFW_KEY_A;\n        case XK_b:              return GLFW_KEY_B;\n        case XK_c:              return GLFW_KEY_C;\n        case XK_d:              return GLFW_KEY_D;\n        case XK_e:              return GLFW_KEY_E;\n        case XK_f:              return GLFW_KEY_F;\n        case XK_g:              return GLFW_KEY_G;\n        case XK_h:              return GLFW_KEY_H;\n        case XK_i:              return GLFW_KEY_I;\n        case XK_j:              return GLFW_KEY_J;\n        case XK_k:              return GLFW_KEY_K;\n        case XK_l:              return GLFW_KEY_L;\n        case XK_m:              return GLFW_KEY_M;\n        case XK_n:              return GLFW_KEY_N;\n        case XK_o:              return GLFW_KEY_O;\n        case XK_p:              return GLFW_KEY_P;\n        case XK_q:              return GLFW_KEY_Q;\n        case XK_r:              return GLFW_KEY_R;\n        case XK_s:              return GLFW_KEY_S;\n        case XK_t:              return GLFW_KEY_T;\n        case XK_u:              return GLFW_KEY_U;\n        case XK_v:              return GLFW_KEY_V;\n        case XK_w:              return GLFW_KEY_W;\n        case XK_x:              return GLFW_KEY_X;\n        case XK_y:              return GLFW_KEY_Y;\n        case XK_z:              return GLFW_KEY_Z;\n        case XK_1:              return GLFW_KEY_1;\n        case XK_2:              return GLFW_KEY_2;\n        case XK_3:              return GLFW_KEY_3;\n        case XK_4:              return GLFW_KEY_4;\n        case XK_5:              return GLFW_KEY_5;\n        case XK_6:              return GLFW_KEY_6;\n        case XK_7:              return GLFW_KEY_7;\n        case XK_8:              return GLFW_KEY_8;\n        case XK_9:              return GLFW_KEY_9;\n        case XK_0:              return GLFW_KEY_0;\n        case XK_space:          return GLFW_KEY_SPACE;\n        case XK_minus:          return GLFW_KEY_MINUS;\n        case XK_equal:          return GLFW_KEY_EQUAL;\n        case XK_bracketleft:    return GLFW_KEY_LEFT_BRACKET;\n        case XK_bracketright:   return GLFW_KEY_RIGHT_BRACKET;\n        case XK_backslash:      return GLFW_KEY_BACKSLASH;\n        case XK_semicolon:      return GLFW_KEY_SEMICOLON;\n        case XK_apostrophe:     return GLFW_KEY_APOSTROPHE;\n        case XK_grave:          return GLFW_KEY_GRAVE_ACCENT;\n        case XK_comma:          return GLFW_KEY_COMMA;\n        case XK_period:         return GLFW_KEY_PERIOD;\n        case XK_slash:          return GLFW_KEY_SLASH;\n        case XK_less:           return GLFW_KEY_WORLD_1; // At least in some layouts...\n        default:                break;\n    }\n\n    // No matching translation was found\n    return GLFW_KEY_UNKNOWN;\n}\n\n// Create key code translation tables\n//\nstatic void createKeyTables(void)\n{\n    int scancode, key;\n\n    memset(_glfw.x11.publicKeys, -1, sizeof(_glfw.x11.publicKeys));\n    memset(_glfw.x11.nativeKeys, -1, sizeof(_glfw.x11.nativeKeys));\n\n    if (_glfw.x11.xkb.available)\n    {\n        // Use XKB to determine physical key locations independently of the current\n        // keyboard layout\n\n        char name[XkbKeyNameLength + 1];\n        XkbDescPtr desc = XkbGetMap(_glfw.x11.display, 0, XkbUseCoreKbd);\n        XkbGetNames(_glfw.x11.display, XkbKeyNamesMask, desc);\n\n        // Find the X11 key code -> GLFW key code mapping\n        for (scancode = desc->min_key_code;  scancode <= desc->max_key_code;  scancode++)\n        {\n            memcpy(name, desc->names->keys[scancode].name, XkbKeyNameLength);\n            name[XkbKeyNameLength] = '\\0';\n\n            // Map the key name to a GLFW key code. Note: We only map printable\n            // keys here, and we use the US keyboard layout. The rest of the\n            // keys (function keys) are mapped using traditional KeySym\n            // translations.\n            if (strcmp(name, \"TLDE\") == 0) key = GLFW_KEY_GRAVE_ACCENT;\n            else if (strcmp(name, \"AE01\") == 0) key = GLFW_KEY_1;\n            else if (strcmp(name, \"AE02\") == 0) key = GLFW_KEY_2;\n            else if (strcmp(name, \"AE03\") == 0) key = GLFW_KEY_3;\n            else if (strcmp(name, \"AE04\") == 0) key = GLFW_KEY_4;\n            else if (strcmp(name, \"AE05\") == 0) key = GLFW_KEY_5;\n            else if (strcmp(name, \"AE06\") == 0) key = GLFW_KEY_6;\n            else if (strcmp(name, \"AE07\") == 0) key = GLFW_KEY_7;\n            else if (strcmp(name, \"AE08\") == 0) key = GLFW_KEY_8;\n            else if (strcmp(name, \"AE09\") == 0) key = GLFW_KEY_9;\n            else if (strcmp(name, \"AE10\") == 0) key = GLFW_KEY_0;\n            else if (strcmp(name, \"AE11\") == 0) key = GLFW_KEY_MINUS;\n            else if (strcmp(name, \"AE12\") == 0) key = GLFW_KEY_EQUAL;\n            else if (strcmp(name, \"AD01\") == 0) key = GLFW_KEY_Q;\n            else if (strcmp(name, \"AD02\") == 0) key = GLFW_KEY_W;\n            else if (strcmp(name, \"AD03\") == 0) key = GLFW_KEY_E;\n            else if (strcmp(name, \"AD04\") == 0) key = GLFW_KEY_R;\n            else if (strcmp(name, \"AD05\") == 0) key = GLFW_KEY_T;\n            else if (strcmp(name, \"AD06\") == 0) key = GLFW_KEY_Y;\n            else if (strcmp(name, \"AD07\") == 0) key = GLFW_KEY_U;\n            else if (strcmp(name, \"AD08\") == 0) key = GLFW_KEY_I;\n            else if (strcmp(name, \"AD09\") == 0) key = GLFW_KEY_O;\n            else if (strcmp(name, \"AD10\") == 0) key = GLFW_KEY_P;\n            else if (strcmp(name, \"AD11\") == 0) key = GLFW_KEY_LEFT_BRACKET;\n            else if (strcmp(name, \"AD12\") == 0) key = GLFW_KEY_RIGHT_BRACKET;\n            else if (strcmp(name, \"AC01\") == 0) key = GLFW_KEY_A;\n            else if (strcmp(name, \"AC02\") == 0) key = GLFW_KEY_S;\n            else if (strcmp(name, \"AC03\") == 0) key = GLFW_KEY_D;\n            else if (strcmp(name, \"AC04\") == 0) key = GLFW_KEY_F;\n            else if (strcmp(name, \"AC05\") == 0) key = GLFW_KEY_G;\n            else if (strcmp(name, \"AC06\") == 0) key = GLFW_KEY_H;\n            else if (strcmp(name, \"AC07\") == 0) key = GLFW_KEY_J;\n            else if (strcmp(name, \"AC08\") == 0) key = GLFW_KEY_K;\n            else if (strcmp(name, \"AC09\") == 0) key = GLFW_KEY_L;\n            else if (strcmp(name, \"AC10\") == 0) key = GLFW_KEY_SEMICOLON;\n            else if (strcmp(name, \"AC11\") == 0) key = GLFW_KEY_APOSTROPHE;\n            else if (strcmp(name, \"AB01\") == 0) key = GLFW_KEY_Z;\n            else if (strcmp(name, \"AB02\") == 0) key = GLFW_KEY_X;\n            else if (strcmp(name, \"AB03\") == 0) key = GLFW_KEY_C;\n            else if (strcmp(name, \"AB04\") == 0) key = GLFW_KEY_V;\n            else if (strcmp(name, \"AB05\") == 0) key = GLFW_KEY_B;\n            else if (strcmp(name, \"AB06\") == 0) key = GLFW_KEY_N;\n            else if (strcmp(name, \"AB07\") == 0) key = GLFW_KEY_M;\n            else if (strcmp(name, \"AB08\") == 0) key = GLFW_KEY_COMMA;\n            else if (strcmp(name, \"AB09\") == 0) key = GLFW_KEY_PERIOD;\n            else if (strcmp(name, \"AB10\") == 0) key = GLFW_KEY_SLASH;\n            else if (strcmp(name, \"BKSL\") == 0) key = GLFW_KEY_BACKSLASH;\n            else if (strcmp(name, \"LSGT\") == 0) key = GLFW_KEY_WORLD_1;\n            else key = GLFW_KEY_UNKNOWN;\n\n            if ((scancode >= 0) && (scancode < 256))\n                _glfw.x11.publicKeys[scancode] = key;\n        }\n\n        XkbFreeNames(desc, XkbKeyNamesMask, True);\n        XkbFreeKeyboard(desc, 0, True);\n    }\n\n    for (scancode = 0;  scancode < 256;  scancode++)\n    {\n        // Translate the un-translated key codes using traditional X11 KeySym\n        // lookups\n        if (_glfw.x11.publicKeys[scancode] < 0)\n            _glfw.x11.publicKeys[scancode] = translateKeyCode(scancode);\n\n        // Store the reverse translation for faster key name lookup\n        if (_glfw.x11.publicKeys[scancode] > 0)\n            _glfw.x11.nativeKeys[_glfw.x11.publicKeys[scancode]] = scancode;\n    }\n}\n\n// Check whether the IM has a usable style\n//\nstatic GLFWbool hasUsableInputMethodStyle(void)\n{\n    unsigned int i;\n    GLFWbool found = GLFW_FALSE;\n    XIMStyles* styles = NULL;\n\n    if (XGetIMValues(_glfw.x11.im, XNQueryInputStyle, &styles, NULL) != NULL)\n        return GLFW_FALSE;\n\n    for (i = 0;  i < styles->count_styles;  i++)\n    {\n        if (styles->supported_styles[i] == (XIMPreeditNothing | XIMStatusNothing))\n        {\n            found = GLFW_TRUE;\n            break;\n        }\n    }\n\n    XFree(styles);\n    return found;\n}\n\n// Check whether the specified atom is supported\n//\nstatic Atom getSupportedAtom(Atom* supportedAtoms,\n                             unsigned long atomCount,\n                             const char* atomName)\n{\n    unsigned long i;\n    const Atom atom = XInternAtom(_glfw.x11.display, atomName, False);\n\n    for (i = 0;  i < atomCount;  i++)\n    {\n        if (supportedAtoms[i] == atom)\n            return atom;\n    }\n\n    return None;\n}\n\n// Check whether the running window manager is EWMH-compliant\n//\nstatic void detectEWMH(void)\n{\n    Window* windowFromRoot = NULL;\n    Window* windowFromChild = NULL;\n\n    // First we need a couple of atoms\n    const Atom supportingWmCheck =\n        XInternAtom(_glfw.x11.display, \"_NET_SUPPORTING_WM_CHECK\", False);\n    const Atom wmSupported =\n        XInternAtom(_glfw.x11.display, \"_NET_SUPPORTED\", False);\n\n    // Then we look for the _NET_SUPPORTING_WM_CHECK property of the root window\n    if (_glfwGetWindowPropertyX11(_glfw.x11.root,\n                                  supportingWmCheck,\n                                  XA_WINDOW,\n                                  (unsigned char**) &windowFromRoot) != 1)\n    {\n        if (windowFromRoot)\n            XFree(windowFromRoot);\n        return;\n    }\n\n    _glfwGrabErrorHandlerX11();\n\n    // It should be the ID of a child window (of the root)\n    // Then we look for the same property on the child window\n    if (_glfwGetWindowPropertyX11(*windowFromRoot,\n                                  supportingWmCheck,\n                                  XA_WINDOW,\n                                  (unsigned char**) &windowFromChild) != 1)\n    {\n        XFree(windowFromRoot);\n        if (windowFromChild)\n            XFree(windowFromChild);\n        return;\n    }\n\n    _glfwReleaseErrorHandlerX11();\n\n    // It should be the ID of that same child window\n    if (*windowFromRoot != *windowFromChild)\n    {\n        XFree(windowFromRoot);\n        XFree(windowFromChild);\n        return;\n    }\n\n    XFree(windowFromRoot);\n    XFree(windowFromChild);\n\n    // We are now fairly sure that an EWMH-compliant window manager is running\n\n    Atom* supportedAtoms;\n    unsigned long atomCount;\n\n    // Now we need to check the _NET_SUPPORTED property of the root window\n    // It should be a list of supported WM protocol and state atoms\n    atomCount = _glfwGetWindowPropertyX11(_glfw.x11.root,\n                                          wmSupported,\n                                          XA_ATOM,\n                                          (unsigned char**) &supportedAtoms);\n\n    // See which of the atoms we support that are supported by the WM\n    _glfw.x11.NET_WM_STATE =\n        getSupportedAtom(supportedAtoms, atomCount, \"_NET_WM_STATE\");\n    _glfw.x11.NET_WM_STATE_ABOVE =\n        getSupportedAtom(supportedAtoms, atomCount, \"_NET_WM_STATE_ABOVE\");\n    _glfw.x11.NET_WM_STATE_FULLSCREEN =\n        getSupportedAtom(supportedAtoms, atomCount, \"_NET_WM_STATE_FULLSCREEN\");\n    _glfw.x11.NET_WM_STATE_MAXIMIZED_VERT =\n        getSupportedAtom(supportedAtoms, atomCount, \"_NET_WM_STATE_MAXIMIZED_VERT\");\n    _glfw.x11.NET_WM_STATE_MAXIMIZED_HORZ =\n        getSupportedAtom(supportedAtoms, atomCount, \"_NET_WM_STATE_MAXIMIZED_HORZ\");\n    _glfw.x11.NET_WM_FULLSCREEN_MONITORS =\n        getSupportedAtom(supportedAtoms, atomCount, \"_NET_WM_FULLSCREEN_MONITORS\");\n    _glfw.x11.NET_WM_WINDOW_TYPE =\n        getSupportedAtom(supportedAtoms, atomCount, \"_NET_WM_WINDOW_TYPE\");\n    _glfw.x11.NET_WM_WINDOW_TYPE_NORMAL =\n        getSupportedAtom(supportedAtoms, atomCount, \"_NET_WM_WINDOW_TYPE_NORMAL\");\n    _glfw.x11.NET_ACTIVE_WINDOW =\n        getSupportedAtom(supportedAtoms, atomCount, \"_NET_ACTIVE_WINDOW\");\n    _glfw.x11.NET_FRAME_EXTENTS =\n        getSupportedAtom(supportedAtoms, atomCount, \"_NET_FRAME_EXTENTS\");\n    _glfw.x11.NET_REQUEST_FRAME_EXTENTS =\n        getSupportedAtom(supportedAtoms, atomCount, \"_NET_REQUEST_FRAME_EXTENTS\");\n\n    XFree(supportedAtoms);\n}\n\n// Initialize X11 display and look for supported X11 extensions\n//\nstatic GLFWbool initExtensions(void)\n{\n#if defined(_GLFW_HAS_XF86VM)\n    // Check for XF86VidMode extension\n    _glfw.x11.vidmode.available =\n        XF86VidModeQueryExtension(_glfw.x11.display,\n                                  &_glfw.x11.vidmode.eventBase,\n                                  &_glfw.x11.vidmode.errorBase);\n#endif /*_GLFW_HAS_XF86VM*/\n\n    // Check for RandR extension\n    if (XRRQueryExtension(_glfw.x11.display,\n                          &_glfw.x11.randr.eventBase,\n                          &_glfw.x11.randr.errorBase))\n    {\n        if (XRRQueryVersion(_glfw.x11.display,\n                            &_glfw.x11.randr.major,\n                            &_glfw.x11.randr.minor))\n        {\n            // The GLFW RandR path requires at least version 1.3\n            if (_glfw.x11.randr.major > 1 || _glfw.x11.randr.minor >= 3)\n                _glfw.x11.randr.available = GLFW_TRUE;\n        }\n        else\n        {\n            _glfwInputError(GLFW_PLATFORM_ERROR,\n                            \"X11: Failed to query RandR version\");\n        }\n    }\n\n    if (_glfw.x11.randr.available)\n    {\n        XRRScreenResources* sr = XRRGetScreenResources(_glfw.x11.display,\n                                                       _glfw.x11.root);\n\n        if (!sr->ncrtc || !XRRGetCrtcGammaSize(_glfw.x11.display, sr->crtcs[0]))\n        {\n            // This is either a headless system or an older Nvidia binary driver\n            // with broken gamma support\n            // Flag it as useless and fall back to Xf86VidMode gamma, if\n            // available\n            _glfwInputError(GLFW_PLATFORM_ERROR,\n                            \"X11: RandR gamma ramp support seems broken\");\n            _glfw.x11.randr.gammaBroken = GLFW_TRUE;\n        }\n\n        XRRFreeScreenResources(sr);\n\n        XRRSelectInput(_glfw.x11.display, _glfw.x11.root,\n                       RROutputChangeNotifyMask);\n    }\n\n    if (XineramaQueryExtension(_glfw.x11.display,\n                               &_glfw.x11.xinerama.major,\n                               &_glfw.x11.xinerama.minor))\n    {\n        if (XineramaIsActive(_glfw.x11.display))\n            _glfw.x11.xinerama.available = GLFW_TRUE;\n    }\n\n    // Check if Xkb is supported on this display\n    _glfw.x11.xkb.major = 1;\n    _glfw.x11.xkb.minor = 0;\n    _glfw.x11.xkb.available =\n        XkbQueryExtension(_glfw.x11.display,\n                          &_glfw.x11.xkb.majorOpcode,\n                          &_glfw.x11.xkb.eventBase,\n                          &_glfw.x11.xkb.errorBase,\n                          &_glfw.x11.xkb.major,\n                          &_glfw.x11.xkb.minor);\n\n    if (_glfw.x11.xkb.available)\n    {\n        Bool supported;\n\n        if (XkbSetDetectableAutoRepeat(_glfw.x11.display, True, &supported))\n        {\n            if (supported)\n                _glfw.x11.xkb.detectable = GLFW_TRUE;\n        }\n    }\n\n    _glfw.x11.x11xcb.handle = dlopen(\"libX11-xcb.so\", RTLD_LAZY | RTLD_GLOBAL);\n    if (_glfw.x11.x11xcb.handle)\n    {\n        _glfw.x11.x11xcb.XGetXCBConnection = (XGETXCBCONNECTION_T)\n            dlsym(_glfw.x11.x11xcb.handle, \"XGetXCBConnection\");\n    }\n\n    // Update the key code LUT\n    // FIXME: We should listen to XkbMapNotify events to track changes to\n    // the keyboard mapping.\n    createKeyTables();\n\n    // Detect whether an EWMH-conformant window manager is running\n    detectEWMH();\n\n    // String format atoms\n    _glfw.x11.NULL_ = XInternAtom(_glfw.x11.display, \"NULL\", False);\n    _glfw.x11.UTF8_STRING =\n        XInternAtom(_glfw.x11.display, \"UTF8_STRING\", False);\n    _glfw.x11.COMPOUND_STRING =\n        XInternAtom(_glfw.x11.display, \"COMPOUND_STRING\", False);\n    _glfw.x11.ATOM_PAIR = XInternAtom(_glfw.x11.display, \"ATOM_PAIR\", False);\n\n    // Custom selection property atom\n    _glfw.x11.GLFW_SELECTION =\n        XInternAtom(_glfw.x11.display, \"GLFW_SELECTION\", False);\n\n    // ICCCM standard clipboard atoms\n    _glfw.x11.TARGETS = XInternAtom(_glfw.x11.display, \"TARGETS\", False);\n    _glfw.x11.MULTIPLE = XInternAtom(_glfw.x11.display, \"MULTIPLE\", False);\n    _glfw.x11.CLIPBOARD = XInternAtom(_glfw.x11.display, \"CLIPBOARD\", False);\n\n    // Clipboard manager atoms\n    _glfw.x11.CLIPBOARD_MANAGER =\n        XInternAtom(_glfw.x11.display, \"CLIPBOARD_MANAGER\", False);\n    _glfw.x11.SAVE_TARGETS =\n        XInternAtom(_glfw.x11.display, \"SAVE_TARGETS\", False);\n\n    // Xdnd (drag and drop) atoms\n    _glfw.x11.XdndAware = XInternAtom(_glfw.x11.display, \"XdndAware\", False);\n    _glfw.x11.XdndEnter = XInternAtom(_glfw.x11.display, \"XdndEnter\", False);\n    _glfw.x11.XdndPosition = XInternAtom(_glfw.x11.display, \"XdndPosition\", False);\n    _glfw.x11.XdndStatus = XInternAtom(_glfw.x11.display, \"XdndStatus\", False);\n    _glfw.x11.XdndActionCopy = XInternAtom(_glfw.x11.display, \"XdndActionCopy\", False);\n    _glfw.x11.XdndDrop = XInternAtom(_glfw.x11.display, \"XdndDrop\", False);\n    _glfw.x11.XdndLeave = XInternAtom(_glfw.x11.display, \"XdndLeave\", False);\n    _glfw.x11.XdndFinished = XInternAtom(_glfw.x11.display, \"XdndFinished\", False);\n    _glfw.x11.XdndSelection = XInternAtom(_glfw.x11.display, \"XdndSelection\", False);\n\n    // ICCCM, EWMH and Motif window property atoms\n    // These can be set safely even without WM support\n    // The EWMH atoms that require WM support are handled in detectEWMH\n    _glfw.x11.WM_PROTOCOLS =\n        XInternAtom(_glfw.x11.display, \"WM_PROTOCOLS\", False);\n    _glfw.x11.WM_STATE =\n        XInternAtom(_glfw.x11.display, \"WM_STATE\", False);\n    _glfw.x11.WM_DELETE_WINDOW =\n        XInternAtom(_glfw.x11.display, \"WM_DELETE_WINDOW\", False);\n    _glfw.x11.NET_WM_ICON =\n        XInternAtom(_glfw.x11.display, \"_NET_WM_ICON\", False);\n    _glfw.x11.NET_WM_PING =\n        XInternAtom(_glfw.x11.display, \"_NET_WM_PING\", False);\n    _glfw.x11.NET_WM_PID =\n        XInternAtom(_glfw.x11.display, \"_NET_WM_PID\", False);\n    _glfw.x11.NET_WM_NAME =\n        XInternAtom(_glfw.x11.display, \"_NET_WM_NAME\", False);\n    _glfw.x11.NET_WM_ICON_NAME =\n        XInternAtom(_glfw.x11.display, \"_NET_WM_ICON_NAME\", False);\n    _glfw.x11.NET_WM_BYPASS_COMPOSITOR =\n        XInternAtom(_glfw.x11.display, \"_NET_WM_BYPASS_COMPOSITOR\", False);\n    _glfw.x11.MOTIF_WM_HINTS =\n        XInternAtom(_glfw.x11.display, \"_MOTIF_WM_HINTS\", False);\n\n    return GLFW_TRUE;\n}\n\n// Create a blank cursor for hidden and disabled cursor modes\n//\nstatic Cursor createHiddenCursor(void)\n{\n    unsigned char pixels[16 * 16 * 4];\n    GLFWimage image = { 16, 16, pixels };\n\n    memset(pixels, 0, sizeof(pixels));\n\n    return _glfwCreateCursorX11(&image, 0, 0);\n}\n\n// X error handler\n//\nstatic int errorHandler(Display *display, XErrorEvent* event)\n{\n    _glfw.x11.errorCode = event->error_code;\n    return 0;\n}\n\n\n//////////////////////////////////////////////////////////////////////////\n//////                       GLFW internal API                      //////\n//////////////////////////////////////////////////////////////////////////\n\n// Sets the X error handler callback\n//\nvoid _glfwGrabErrorHandlerX11(void)\n{\n    _glfw.x11.errorCode = Success;\n    XSetErrorHandler(errorHandler);\n}\n\n// Clears the X error handler callback\n//\nvoid _glfwReleaseErrorHandlerX11(void)\n{\n    // Synchronize to make sure all commands are processed\n    XSync(_glfw.x11.display, False);\n    XSetErrorHandler(NULL);\n}\n\n// Reports the specified error, appending information about the last X error\n//\nvoid _glfwInputErrorX11(int error, const char* message)\n{\n    char buffer[8192];\n    XGetErrorText(_glfw.x11.display, _glfw.x11.errorCode,\n                  buffer, sizeof(buffer));\n\n    _glfwInputError(error, \"%s: %s\", message, buffer);\n}\n\n// Creates a native cursor object from the specified image and hotspot\n//\nCursor _glfwCreateCursorX11(const GLFWimage* image, int xhot, int yhot)\n{\n    int i;\n    Cursor cursor;\n\n    XcursorImage* native = XcursorImageCreate(image->width, image->height);\n    if (native == NULL)\n        return None;\n\n    native->xhot = xhot;\n    native->yhot = yhot;\n\n    unsigned char* source = (unsigned char*) image->pixels;\n    XcursorPixel* target = native->pixels;\n\n    for (i = 0;  i < image->width * image->height;  i++, target++, source += 4)\n    {\n        unsigned int alpha = source[3];\n\n        *target = (alpha << 24) |\n                  ((unsigned char) ((source[0] * alpha) / 255) << 16) |\n                  ((unsigned char) ((source[1] * alpha) / 255) <<  8) |\n                  ((unsigned char) ((source[2] * alpha) / 255) <<  0);\n    }\n\n    cursor = XcursorImageLoadCursor(_glfw.x11.display, native);\n    XcursorImageDestroy(native);\n\n    return cursor;\n}\n\n\n//////////////////////////////////////////////////////////////////////////\n//////                       GLFW platform API                      //////\n//////////////////////////////////////////////////////////////////////////\n\nint _glfwPlatformInit(void)\n{\n#if !defined(X_HAVE_UTF8_STRING)\n    // HACK: If the current locale is C, apply the environment's locale\n    //       This is done because the C locale breaks wide character input\n    if (strcmp(setlocale(LC_CTYPE, NULL), \"C\") == 0)\n        setlocale(LC_CTYPE, \"\");\n#endif\n\n    XInitThreads();\n\n    _glfw.x11.display = XOpenDisplay(NULL);\n    if (!_glfw.x11.display)\n    {\n        const char* display = getenv(\"DISPLAY\");\n        if (display)\n        {\n            _glfwInputError(GLFW_PLATFORM_ERROR,\n                            \"X11: Failed to open display %s\", display);\n        }\n        else\n        {\n            _glfwInputError(GLFW_PLATFORM_ERROR,\n                            \"X11: The DISPLAY environment variable is missing\");\n        }\n\n        return GLFW_FALSE;\n    }\n\n    _glfw.x11.screen = DefaultScreen(_glfw.x11.display);\n    _glfw.x11.root = RootWindow(_glfw.x11.display, _glfw.x11.screen);\n    _glfw.x11.context = XUniqueContext();\n\n    if (!initExtensions())\n        return GLFW_FALSE;\n\n    _glfw.x11.cursor = createHiddenCursor();\n\n    if (XSupportsLocale())\n    {\n        XSetLocaleModifiers(\"\");\n\n        _glfw.x11.im = XOpenIM(_glfw.x11.display, 0, NULL, NULL);\n        if (_glfw.x11.im)\n        {\n            if (!hasUsableInputMethodStyle())\n            {\n                XCloseIM(_glfw.x11.im);\n                _glfw.x11.im = NULL;\n            }\n        }\n    }\n\n    if (!_glfwInitThreadLocalStoragePOSIX())\n        return GLFW_FALSE;\n\n    if (!_glfwInitJoysticksLinux())\n        return GLFW_FALSE;\n\n    _glfwInitTimerPOSIX();\n\n    return GLFW_TRUE;\n}\n\nvoid _glfwPlatformTerminate(void)\n{\n    if (_glfw.x11.x11xcb.handle)\n    {\n        dlclose(_glfw.x11.x11xcb.handle);\n        _glfw.x11.x11xcb.handle = NULL;\n    }\n\n    if (_glfw.x11.cursor)\n    {\n        XFreeCursor(_glfw.x11.display, _glfw.x11.cursor);\n        _glfw.x11.cursor = (Cursor) 0;\n    }\n\n    free(_glfw.x11.clipboardString);\n\n    if (_glfw.x11.im)\n    {\n        XCloseIM(_glfw.x11.im);\n        _glfw.x11.im = NULL;\n    }\n\n    _glfwTerminateEGL();\n\n    if (_glfw.x11.display)\n    {\n        XCloseDisplay(_glfw.x11.display);\n        _glfw.x11.display = NULL;\n    }\n\n    // NOTE: This needs to be done after XCloseDisplay, as libGL registers\n    //       cleanup callbacks that get called by it\n    _glfwTerminateGLX();\n\n    _glfwTerminateJoysticksLinux();\n    _glfwTerminateThreadLocalStoragePOSIX();\n}\n\nconst char* _glfwPlatformGetVersionString(void)\n{\n    return _GLFW_VERSION_NUMBER \" X11 GLX EGL\"\n#if defined(_POSIX_TIMERS) && defined(_POSIX_MONOTONIC_CLOCK)\n        \" clock_gettime\"\n#else\n        \" gettimeofday\"\n#endif\n#if defined(__linux__)\n        \" /dev/js\"\n#endif\n#if defined(_GLFW_HAS_XF86VM)\n        \" Xf86vm\"\n#endif\n#if defined(_GLFW_BUILD_DLL)\n        \" shared\"\n#endif\n        ;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-glfw-3.2.1-gkd54tstzvk3vujbh27j3m4waeirf4if/spack-src/src/cocoa_platform.h": "//========================================================================\n// GLFW 3.2 OS X - www.glfw.org\n//------------------------------------------------------------------------\n// Copyright (c) 2009-2016 Camilla Berglund <elmindreda@glfw.org>\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would\n//    be appreciated but is not required.\n//\n// 2. Altered source versions must be plainly marked as such, and must not\n//    be misrepresented as being the original software.\n//\n// 3. This notice may not be removed or altered from any source\n//    distribution.\n//\n//========================================================================\n\n#ifndef _glfw3_cocoa_platform_h_\n#define _glfw3_cocoa_platform_h_\n\n#include <stdint.h>\n#include <dlfcn.h>\n\n#if defined(__OBJC__)\n#import <Carbon/Carbon.h>\n#import <Cocoa/Cocoa.h>\n#else\n#include <Carbon/Carbon.h>\n#include <ApplicationServices/ApplicationServices.h>\ntypedef void* id;\n#endif\n\n#include \"posix_tls.h\"\n#include \"cocoa_joystick.h\"\n#include \"nsgl_context.h\"\n\n#define _glfw_dlopen(name) dlopen(name, RTLD_LAZY | RTLD_LOCAL)\n#define _glfw_dlclose(handle) dlclose(handle)\n#define _glfw_dlsym(handle, name) dlsym(handle, name)\n\n#define _GLFW_PLATFORM_WINDOW_STATE         _GLFWwindowNS  ns\n#define _GLFW_PLATFORM_LIBRARY_WINDOW_STATE _GLFWlibraryNS ns\n#define _GLFW_PLATFORM_LIBRARY_TIME_STATE   _GLFWtimeNS    ns_time\n#define _GLFW_PLATFORM_MONITOR_STATE        _GLFWmonitorNS ns\n#define _GLFW_PLATFORM_CURSOR_STATE         _GLFWcursorNS  ns\n\n#define _GLFW_EGL_CONTEXT_STATE\n#define _GLFW_EGL_LIBRARY_CONTEXT_STATE\n\n// HIToolbox.framework pointer typedefs\n#define kTISPropertyUnicodeKeyLayoutData _glfw.ns.tis.kPropertyUnicodeKeyLayoutData\n#define kTISNotifySelectedKeyboardInputSourceChanged _glfw.ns.tis.kNotifySelectedKeyboardInputSourceChanged\ntypedef TISInputSourceRef (*PFN_TISCopyCurrentKeyboardLayoutInputSource)(void);\n#define TISCopyCurrentKeyboardLayoutInputSource _glfw.ns.tis.CopyCurrentKeyboardLayoutInputSource\ntypedef void* (*PFN_TISGetInputSourceProperty)(TISInputSourceRef,CFStringRef);\n#define TISGetInputSourceProperty _glfw.ns.tis.GetInputSourceProperty\ntypedef UInt8 (*PFN_LMGetKbdType)(void);\n#define LMGetKbdType _glfw.ns.tis.GetKbdType\n\n\n// Cocoa-specific per-window data\n//\ntypedef struct _GLFWwindowNS\n{\n    id              object;\n    id              delegate;\n    id              view;\n\n    // The total sum of the distances the cursor has been warped\n    // since the last cursor motion event was processed\n    // This is kept to counteract Cocoa doing the same internally\n    double          cursorWarpDeltaX, cursorWarpDeltaY;\n\n} _GLFWwindowNS;\n\n// Cocoa-specific global data\n//\ntypedef struct _GLFWlibraryNS\n{\n    CGEventSourceRef    eventSource;\n    id                  delegate;\n    id                  autoreleasePool;\n    id                  cursor;\n    TISInputSourceRef   inputSource;\n    IOHIDManagerRef     hidManager;\n    id                  unicodeData;\n    id                  listener;\n\n    char                keyName[64];\n    short int           publicKeys[256];\n    short int           nativeKeys[GLFW_KEY_LAST + 1];\n    char*               clipboardString;\n    // Where to place the cursor when re-enabled\n    double              restoreCursorPosX, restoreCursorPosY;\n    // The window whose disabled cursor mode is active\n    _GLFWwindow*        disabledCursorWindow;\n\n    struct {\n        CFBundleRef     bundle;\n        PFN_TISCopyCurrentKeyboardLayoutInputSource CopyCurrentKeyboardLayoutInputSource;\n        PFN_TISGetInputSourceProperty GetInputSourceProperty;\n        PFN_LMGetKbdType GetKbdType;\n        CFStringRef     kPropertyUnicodeKeyLayoutData;\n        CFStringRef     kNotifySelectedKeyboardInputSourceChanged;\n    } tis;\n\n} _GLFWlibraryNS;\n\n// Cocoa-specific per-monitor data\n//\ntypedef struct _GLFWmonitorNS\n{\n    CGDirectDisplayID   displayID;\n    CGDisplayModeRef    previousMode;\n    uint32_t            unitNumber;\n\n} _GLFWmonitorNS;\n\n// Cocoa-specific per-cursor data\n//\ntypedef struct _GLFWcursorNS\n{\n    id              object;\n\n} _GLFWcursorNS;\n\n// Cocoa-specific global timer data\n//\ntypedef struct _GLFWtimeNS\n{\n    uint64_t        frequency;\n\n} _GLFWtimeNS;\n\n\nvoid _glfwInitTimerNS(void);\n\nGLFWbool _glfwSetVideoModeNS(_GLFWmonitor* monitor, const GLFWvidmode* desired);\nvoid _glfwRestoreVideoModeNS(_GLFWmonitor* monitor);\n\n#endif // _glfw3_cocoa_platform_h_\n",
        "/tmp/vanessa/spack-stage/spack-stage-glfw-3.2.1-gkd54tstzvk3vujbh27j3m4waeirf4if/spack-src/src/glx_context.h": "//========================================================================\n// GLFW 3.2 GLX - www.glfw.org\n//------------------------------------------------------------------------\n// Copyright (c) 2002-2006 Marcus Geelnard\n// Copyright (c) 2006-2016 Camilla Berglund <elmindreda@glfw.org>\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would\n//    be appreciated but is not required.\n//\n// 2. Altered source versions must be plainly marked as such, and must not\n//    be misrepresented as being the original software.\n//\n// 3. This notice may not be removed or altered from any source\n//    distribution.\n//\n//========================================================================\n\n#ifndef _glfw3_glx_context_h_\n#define _glfw3_glx_context_h_\n\n#define GLX_VENDOR 1\n#define GLX_RGBA_BIT 0x00000001\n#define GLX_WINDOW_BIT 0x00000001\n#define GLX_DRAWABLE_TYPE 0x8010\n#define GLX_RENDER_TYPE\t0x8011\n#define GLX_RGBA_TYPE 0x8014\n#define GLX_DOUBLEBUFFER 5\n#define GLX_STEREO 6\n#define GLX_AUX_BUFFERS\t7\n#define GLX_RED_SIZE 8\n#define GLX_GREEN_SIZE 9\n#define GLX_BLUE_SIZE 10\n#define GLX_ALPHA_SIZE 11\n#define GLX_DEPTH_SIZE 12\n#define GLX_STENCIL_SIZE 13\n#define GLX_ACCUM_RED_SIZE 14\n#define GLX_ACCUM_GREEN_SIZE 15\n#define GLX_ACCUM_BLUE_SIZE\t16\n#define GLX_ACCUM_ALPHA_SIZE 17\n#define GLX_SAMPLES 0x186a1\n#define GLX_VISUAL_ID 0x800b\n\n#define GLX_FRAMEBUFFER_SRGB_CAPABLE_ARB 0x20b2\n#define GLX_CONTEXT_DEBUG_BIT_ARB 0x00000001\n#define GLX_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB 0x00000002\n#define GLX_CONTEXT_CORE_PROFILE_BIT_ARB 0x00000001\n#define GLX_CONTEXT_PROFILE_MASK_ARB 0x9126\n#define GLX_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB 0x00000002\n#define GLX_CONTEXT_MAJOR_VERSION_ARB 0x2091\n#define GLX_CONTEXT_MINOR_VERSION_ARB 0x2092\n#define GLX_CONTEXT_FLAGS_ARB 0x2094\n#define GLX_CONTEXT_ES2_PROFILE_BIT_EXT 0x00000004\n#define GLX_CONTEXT_ROBUST_ACCESS_BIT_ARB 0x00000004\n#define GLX_LOSE_CONTEXT_ON_RESET_ARB 0x8252\n#define GLX_CONTEXT_RESET_NOTIFICATION_STRATEGY_ARB 0x8256\n#define GLX_NO_RESET_NOTIFICATION_ARB 0x8261\n#define GLX_CONTEXT_RELEASE_BEHAVIOR_ARB 0x2097\n#define GLX_CONTEXT_RELEASE_BEHAVIOR_NONE_ARB 0\n#define GLX_CONTEXT_RELEASE_BEHAVIOR_FLUSH_ARB 0x2098\n\ntypedef XID GLXWindow;\ntypedef XID GLXDrawable;\ntypedef struct __GLXFBConfig* GLXFBConfig;\ntypedef struct __GLXcontext* GLXContext;\ntypedef void (*__GLXextproc)(void);\n\ntypedef int (*PFNGLXGETFBCONFIGATTRIBPROC)(Display*,GLXFBConfig,int,int*);\ntypedef const char* (*PFNGLXGETCLIENTSTRINGPROC)(Display*,int);\ntypedef Bool (*PFNGLXQUERYEXTENSIONPROC)(Display*,int*,int*);\ntypedef Bool (*PFNGLXQUERYVERSIONPROC)(Display*,int*,int*);\ntypedef void (*PFNGLXDESTROYCONTEXTPROC)(Display*,GLXContext);\ntypedef Bool (*PFNGLXMAKECURRENTPROC)(Display*,GLXDrawable,GLXContext);\ntypedef void (*PFNGLXSWAPBUFFERSPROC)(Display*,GLXDrawable);\ntypedef const char* (*PFNGLXQUERYEXTENSIONSSTRINGPROC)(Display*,int);\ntypedef GLXFBConfig* (*PFNGLXGETFBCONFIGSPROC)(Display*,int,int*);\ntypedef GLXContext (*PFNGLXCREATENEWCONTEXTPROC)(Display*,GLXFBConfig,int,GLXContext,Bool);\ntypedef __GLXextproc (* PFNGLXGETPROCADDRESSPROC)(const GLubyte *procName);\ntypedef int (*PFNGLXSWAPINTERVALMESAPROC)(int);\ntypedef int (*PFNGLXSWAPINTERVALSGIPROC)(int);\ntypedef void (*PFNGLXSWAPINTERVALEXTPROC)(Display*,GLXDrawable,int);\ntypedef GLXContext (*PFNGLXCREATECONTEXTATTRIBSARBPROC)(Display*,GLXFBConfig,GLXContext,Bool,const int*);\ntypedef XVisualInfo* (*PFNGLXGETVISUALFROMFBCONFIGPROC)(Display*,GLXFBConfig);\ntypedef GLXWindow (*PFNGLXCREATEWINDOWPROC)(Display*,GLXFBConfig,Window,const int*);\ntypedef void (*PFNGLXDESTROYWINDOWPROC)(Display*,GLXWindow);\n\n// libGL.so function pointer typedefs\n#define glXGetFBConfigs _glfw.glx.GetFBConfigs\n#define glXGetFBConfigAttrib _glfw.glx.GetFBConfigAttrib\n#define glXGetClientString _glfw.glx.GetClientString\n#define glXQueryExtension _glfw.glx.QueryExtension\n#define glXQueryVersion _glfw.glx.QueryVersion\n#define glXDestroyContext _glfw.glx.DestroyContext\n#define glXMakeCurrent _glfw.glx.MakeCurrent\n#define glXSwapBuffers _glfw.glx.SwapBuffers\n#define glXQueryExtensionsString _glfw.glx.QueryExtensionsString\n#define glXCreateNewContext _glfw.glx.CreateNewContext\n#define glXGetVisualFromFBConfig _glfw.glx.GetVisualFromFBConfig\n#define glXCreateWindow _glfw.glx.CreateWindow\n#define glXDestroyWindow _glfw.glx.DestroyWindow\n\n#define _GLFW_PLATFORM_CONTEXT_STATE            _GLFWcontextGLX glx\n#define _GLFW_PLATFORM_LIBRARY_CONTEXT_STATE    _GLFWlibraryGLX glx\n\n\n// GLX-specific per-context data\n//\ntypedef struct _GLFWcontextGLX\n{\n    GLXContext      handle;\n    GLXWindow       window;\n\n} _GLFWcontextGLX;\n\n// GLX-specific global data\n//\ntypedef struct _GLFWlibraryGLX\n{\n    int             major, minor;\n    int             eventBase;\n    int             errorBase;\n\n    // dlopen handle for libGL.so.1\n    void*           handle;\n\n    // GLX 1.3 functions\n    PFNGLXGETFBCONFIGSPROC              GetFBConfigs;\n    PFNGLXGETFBCONFIGATTRIBPROC         GetFBConfigAttrib;\n    PFNGLXGETCLIENTSTRINGPROC           GetClientString;\n    PFNGLXQUERYEXTENSIONPROC            QueryExtension;\n    PFNGLXQUERYVERSIONPROC              QueryVersion;\n    PFNGLXDESTROYCONTEXTPROC            DestroyContext;\n    PFNGLXMAKECURRENTPROC               MakeCurrent;\n    PFNGLXSWAPBUFFERSPROC               SwapBuffers;\n    PFNGLXQUERYEXTENSIONSSTRINGPROC     QueryExtensionsString;\n    PFNGLXCREATENEWCONTEXTPROC          CreateNewContext;\n    PFNGLXGETVISUALFROMFBCONFIGPROC     GetVisualFromFBConfig;\n    PFNGLXCREATEWINDOWPROC              CreateWindow;\n    PFNGLXDESTROYWINDOWPROC             DestroyWindow;\n\n    // GLX 1.4 and extension functions\n    PFNGLXGETPROCADDRESSPROC            GetProcAddress;\n    PFNGLXGETPROCADDRESSPROC            GetProcAddressARB;\n    PFNGLXSWAPINTERVALSGIPROC           SwapIntervalSGI;\n    PFNGLXSWAPINTERVALEXTPROC           SwapIntervalEXT;\n    PFNGLXSWAPINTERVALMESAPROC          SwapIntervalMESA;\n    PFNGLXCREATECONTEXTATTRIBSARBPROC   CreateContextAttribsARB;\n    GLFWbool        SGI_swap_control;\n    GLFWbool        EXT_swap_control;\n    GLFWbool        MESA_swap_control;\n    GLFWbool        ARB_multisample;\n    GLFWbool        ARB_framebuffer_sRGB;\n    GLFWbool        EXT_framebuffer_sRGB;\n    GLFWbool        ARB_create_context;\n    GLFWbool        ARB_create_context_profile;\n    GLFWbool        ARB_create_context_robustness;\n    GLFWbool        EXT_create_context_es2_profile;\n    GLFWbool        ARB_context_flush_control;\n\n} _GLFWlibraryGLX;\n\n\nGLFWbool _glfwInitGLX(void);\nvoid _glfwTerminateGLX(void);\nGLFWbool _glfwCreateContextGLX(_GLFWwindow* window,\n                               const _GLFWctxconfig* ctxconfig,\n                               const _GLFWfbconfig* fbconfig);\nvoid _glfwDestroyContextGLX(_GLFWwindow* window);\nGLFWbool _glfwChooseVisualGLX(const _GLFWctxconfig* ctxconfig,\n                              const _GLFWfbconfig* fbconfig,\n                              Visual** visual, int* depth);\n\n#endif // _glfw3_glx_context_h_\n",
        "/tmp/vanessa/spack-stage/spack-stage-glfw-3.2.1-gkd54tstzvk3vujbh27j3m4waeirf4if/spack-src/src/wl_platform.h": "//========================================================================\n// GLFW 3.2 Wayland - www.glfw.org\n//------------------------------------------------------------------------\n// Copyright (c) 2014 Jonas \u00c5dahl <jadahl@gmail.com>\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would\n//    be appreciated but is not required.\n//\n// 2. Altered source versions must be plainly marked as such, and must not\n//    be misrepresented as being the original software.\n//\n// 3. This notice may not be removed or altered from any source\n//    distribution.\n//\n//========================================================================\n\n#ifndef _glfw3_wayland_platform_h_\n#define _glfw3_wayland_platform_h_\n\n#include <wayland-client.h>\n#include <xkbcommon/xkbcommon.h>\n#include <dlfcn.h>\n\ntypedef VkFlags VkWaylandSurfaceCreateFlagsKHR;\n\ntypedef struct VkWaylandSurfaceCreateInfoKHR\n{\n    VkStructureType                 sType;\n    const void*                     pNext;\n    VkWaylandSurfaceCreateFlagsKHR  flags;\n    struct wl_display*              display;\n    struct wl_surface*              surface;\n} VkWaylandSurfaceCreateInfoKHR;\n\ntypedef VkResult (APIENTRY *PFN_vkCreateWaylandSurfaceKHR)(VkInstance,const VkWaylandSurfaceCreateInfoKHR*,const VkAllocationCallbacks*,VkSurfaceKHR*);\ntypedef VkBool32 (APIENTRY *PFN_vkGetPhysicalDeviceWaylandPresentationSupportKHR)(VkPhysicalDevice,uint32_t,struct wl_display*);\n\n#include \"posix_tls.h\"\n#include \"posix_time.h\"\n#include \"linux_joystick.h\"\n#include \"xkb_unicode.h\"\n#include \"egl_context.h\"\n\n#include \"wayland-relative-pointer-unstable-v1-client-protocol.h\"\n#include \"wayland-pointer-constraints-unstable-v1-client-protocol.h\"\n\n#define _glfw_dlopen(name) dlopen(name, RTLD_LAZY | RTLD_LOCAL)\n#define _glfw_dlclose(handle) dlclose(handle)\n#define _glfw_dlsym(handle, name) dlsym(handle, name)\n\n#define _GLFW_EGL_NATIVE_WINDOW         ((EGLNativeWindowType) window->wl.native)\n#define _GLFW_EGL_NATIVE_DISPLAY        ((EGLNativeDisplayType) _glfw.wl.display)\n\n#define _GLFW_PLATFORM_WINDOW_STATE         _GLFWwindowWayland  wl\n#define _GLFW_PLATFORM_LIBRARY_WINDOW_STATE _GLFWlibraryWayland wl\n#define _GLFW_PLATFORM_MONITOR_STATE        _GLFWmonitorWayland wl\n#define _GLFW_PLATFORM_CURSOR_STATE         _GLFWcursorWayland  wl\n\n#define _GLFW_PLATFORM_CONTEXT_STATE\n#define _GLFW_PLATFORM_LIBRARY_CONTEXT_STATE\n\n\n// Wayland-specific video mode data\n//\ntypedef struct _GLFWvidmodeWayland _GLFWvidmodeWayland;\n\n// Wayland-specific per-window data\n//\ntypedef struct _GLFWwindowWayland\n{\n    int                         width, height;\n    GLFWbool                    visible;\n    GLFWbool                    maximized;\n    struct wl_surface*          surface;\n    struct wl_egl_window*       native;\n    struct wl_shell_surface*    shell_surface;\n    struct wl_callback*         callback;\n\n    _GLFWcursor*                currentCursor;\n    double                      cursorPosX, cursorPosY;\n\n    char*                       title;\n\n    // We need to track the monitors the window spans on to calculate the\n    // optimal scaling factor.\n    int                         scale;\n    _GLFWmonitor**              monitors;\n    int                         monitorsCount;\n    int                         monitorsSize;\n\n    struct {\n        struct zwp_relative_pointer_v1*    relativePointer;\n        struct zwp_locked_pointer_v1*      lockedPointer;\n    } pointerLock;\n} _GLFWwindowWayland;\n\n// Wayland-specific global data\n//\ntypedef struct _GLFWlibraryWayland\n{\n    struct wl_display*          display;\n    struct wl_registry*         registry;\n    struct wl_compositor*       compositor;\n    struct wl_shell*            shell;\n    struct wl_shm*              shm;\n    struct wl_seat*             seat;\n    struct wl_pointer*          pointer;\n    struct wl_keyboard*         keyboard;\n    struct zwp_relative_pointer_manager_v1* relativePointerManager;\n    struct zwp_pointer_constraints_v1*      pointerConstraints;\n\n    int                         wl_compositor_version;\n\n    struct wl_cursor_theme*     cursorTheme;\n    struct wl_surface*          cursorSurface;\n    uint32_t                    pointerSerial;\n\n    _GLFWmonitor**              monitors;\n    int                         monitorsCount;\n    int                         monitorsSize;\n\n    short int                   publicKeys[256];\n\n    struct {\n        struct xkb_context*     context;\n        struct xkb_keymap*      keymap;\n        struct xkb_state*       state;\n        xkb_mod_mask_t          control_mask;\n        xkb_mod_mask_t          alt_mask;\n        xkb_mod_mask_t          shift_mask;\n        xkb_mod_mask_t          super_mask;\n        unsigned int            modifiers;\n    } xkb;\n\n    _GLFWwindow*                pointerFocus;\n    _GLFWwindow*                keyboardFocus;\n\n} _GLFWlibraryWayland;\n\n// Wayland-specific per-monitor data\n//\ntypedef struct _GLFWmonitorWayland\n{\n    struct wl_output*           output;\n\n    _GLFWvidmodeWayland*        modes;\n    int                         modesCount;\n    int                         modesSize;\n    GLFWbool                    done;\n\n    int                         x;\n    int                         y;\n    int                         scale;\n} _GLFWmonitorWayland;\n\n// Wayland-specific per-cursor data\n//\ntypedef struct _GLFWcursorWayland\n{\n    struct wl_cursor_image*     image;\n    struct wl_buffer*           buffer;\n    int                         width, height;\n    int                         xhot, yhot;\n} _GLFWcursorWayland;\n\n\nvoid _glfwAddOutputWayland(uint32_t name, uint32_t version);\n\n#endif // _glfw3_wayland_platform_h_\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-glfw-3.2.1-gkd54tstzvk3vujbh27j3m4waeirf4if/spack-src/examples/glfw.ico",
        "/tmp/vanessa/spack-stage/spack-stage-glfw-3.2.1-gkd54tstzvk3vujbh27j3m4waeirf4if/spack-src/examples/glfw.icns"
    ],
    "total_files": 140
}