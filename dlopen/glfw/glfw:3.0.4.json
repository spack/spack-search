{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-glfw-3.0.4-5nzclnqicbr5l5hudpxlnfip73vfrttz/spack-src/CMakeLists.txt": "project(GLFW C)\n\ncmake_minimum_required(VERSION 2.8)\n\nset(GLFW_VERSION_MAJOR \"3\")\nset(GLFW_VERSION_MINOR \"0\")\nset(GLFW_VERSION_PATCH \"4\")\nset(GLFW_VERSION_EXTRA \"\")\nset(GLFW_VERSION \"${GLFW_VERSION_MAJOR}.${GLFW_VERSION_MINOR}\")\nset(GLFW_VERSION_FULL \"${GLFW_VERSION}.${GLFW_VERSION_PATCH}${GLFW_VERSION_EXTRA}\")\nset(LIB_SUFFIX \"\" CACHE STRING \"Takes an empty string or 64. Directory where lib will be installed: lib or lib64\")\n\noption(BUILD_SHARED_LIBS \"Build shared libraries\" OFF)\noption(GLFW_BUILD_EXAMPLES \"Build the GLFW example programs\" ON)\noption(GLFW_BUILD_TESTS \"Build the GLFW test programs\" ON)\noption(GLFW_BUILD_DOCS \"Build the GLFW documentation\" ON)\noption(GLFW_INSTALL \"Generate installation target\" ON)\noption(GLFW_DOCUMENT_INTERNALS \"Include internals in documentation\" OFF)\n\nif (WIN32)\n    option(GLFW_USE_DWM_SWAP_INTERVAL \"Set swap interval even when DWM compositing is enabled\" OFF)\n    option(GLFW_USE_OPTIMUS_HPG \"Force use of high-performance GPU on Optimus systems\" OFF)\nendif()\n\nif (APPLE)\n    option(GLFW_BUILD_UNIVERSAL \"Build GLFW as a Universal Binary\" OFF)\n    option(GLFW_USE_CHDIR \"Make glfwInit chdir to Contents/Resources\" ON)\n    option(GLFW_USE_MENUBAR \"Populate the menu bar on first window creation\" ON)\nelse()\n    option(GLFW_USE_EGL \"Use EGL for context creation\" OFF)\nendif()\n\nif (MSVC)\n    option(USE_MSVC_RUNTIME_LIBRARY_DLL \"Use MSVC runtime library DLL\" ON)\nendif()\n\nif (BUILD_SHARED_LIBS)\n    set(_GLFW_BUILD_DLL 1)\nendif()\n\nif (GLFW_USE_EGL)\n    set(GLFW_CLIENT_LIBRARY \"opengl\" CACHE STRING\n        \"The client library to use; one of opengl, glesv1 or glesv2\")\n\n    if (${GLFW_CLIENT_LIBRARY} STREQUAL \"opengl\")\n        set(_GLFW_USE_OPENGL 1)\n    elseif (${GLFW_CLIENT_LIBRARY} STREQUAL \"glesv1\")\n        set(_GLFW_USE_GLESV1 1)\n    elseif (${GLFW_CLIENT_LIBRARY} STREQUAL \"glesv2\")\n        set(_GLFW_USE_GLESV2 1)\n    else()\n        message(FATAL_ERROR \"Unsupported client library\")\n    endif()\n\n    set(CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/CMake/modules)\n    find_package(EGL REQUIRED)\n\n    if (NOT _GLFW_USE_OPENGL)\n        set(GLFW_BUILD_EXAMPLES OFF)\n        set(GLFW_BUILD_TESTS OFF)\n        message(STATUS \"NOTE: Examples and tests require OpenGL\")\n    endif()\nelse()\n    set(_GLFW_USE_OPENGL 1)\nendif()\n\nif (_GLFW_USE_OPENGL)\n    find_package(OpenGL REQUIRED)\nelseif (_GLFW_USE_GLESV1)\n    find_package(GLESv1 REQUIRED)\nelseif (_GLFW_USE_GLESV2)\n    find_package(GLESv2 REQUIRED)\nendif()\n\nfind_package(Threads REQUIRED)\n\nif (GLFW_BUILD_DOCS)\n    set(DOXYGEN_SKIP_DOT TRUE)\n    find_package(Doxygen)\n\n    if (GLFW_DOCUMENT_INTERNALS)\n        set(GLFW_INTERNAL_DOCS \"${GLFW_SOURCE_DIR}/src/internal.h ${GLFW_SOURCE_DIR}/docs/internal.dox\")\n    endif()\nendif()\n\n#--------------------------------------------------------------------\n# Set compiler specific flags\n#--------------------------------------------------------------------\nif (UNIX)\n    add_definitions(-Wall)\n\n    if (BUILD_SHARED_LIBS)\n        add_definitions(-fvisibility=hidden)\n    endif()\nendif()\n\nif (MSVC)\n    add_definitions(-D_CRT_SECURE_NO_WARNINGS)\n\n    if (NOT USE_MSVC_RUNTIME_LIBRARY_DLL)\n        foreach (flag CMAKE_C_FLAGS\n                        CMAKE_C_FLAGS_DEBUG\n                        CMAKE_C_FLAGS_RELEASE\n                        CMAKE_C_FLAGS_MINSIZEREL\n                        CMAKE_C_FLAGS_RELWITHDEBINFO)\n\n            if (${flag} MATCHES \"/MD\")\n                string(REGEX REPLACE \"/MD\" \"/MT\" ${flag} \"${${flag}}\")\n            endif()\n            if (${flag} MATCHES \"/MDd\")\n                string(REGEX REPLACE \"/MDd\" \"/MTd\" ${flag} \"${${flag}}\")\n            endif()\n\n        endforeach()\n    endif()\nendif()\n\n#--------------------------------------------------------------------\n# Detect and select backend APIs\n#--------------------------------------------------------------------\nif (WIN32)\n    set(_GLFW_WIN32 1)\n    message(STATUS \"Using Win32 for window creation\") \n\n    if (GLFW_USE_EGL)\n        set(_GLFW_EGL 1)\n        message(STATUS \"Using EGL for context creation\")\n    else()\n        set(_GLFW_WGL 1)\n        message(STATUS \"Using WGL for context creation\")\n    endif()\nelseif (APPLE)\n    set(_GLFW_COCOA 1)\n    message(STATUS \"Using Cocoa for window creation\")\n    set(_GLFW_NSGL 1)\n    message(STATUS \"Using NSGL for context creation\")\nelseif (UNIX)\n    set(_GLFW_X11 1)\n    message(STATUS \"Using X11 for window creation\") \n\n    if (GLFW_USE_EGL)\n        set(_GLFW_EGL 1)\n        message(STATUS \"Using EGL for context creation\")\n    else()\n        set(_GLFW_GLX 1)\n        message(STATUS \"Using GLX for context creation\")\n    endif()\nelse()\n    message(FATAL_ERROR \"No supported platform was detected\")\nendif()\n\n#--------------------------------------------------------------------\n# Use Win32 for window creation\n#--------------------------------------------------------------------\nif (_GLFW_WIN32)\n    # The DLL links against winmm; the static library loads it\n    # That way, both code paths receive testing\n    if (BUILD_SHARED_LIBS)\n        set(_GLFW_NO_DLOAD_WINMM 1)\n        list(APPEND glfw_LIBRARIES winmm)\n    endif()\n\n    if (GLFW_USE_DWM_SWAP_INTERVAL)\n        set(_GLFW_USE_DWM_SWAP_INTERVAL 1)\n    endif()\n    if (GLFW_USE_OPTIMUS_HPG)\n        set(_GLFW_USE_OPTIMUS_HPG 1)\n    endif()\n\n    # HACK: When building on MinGW, WINVER and UNICODE need to be defined before\n    # the inclusion of stddef.h (by glfw3.h), which is itself included before\n    # win32_platform.h.  We define them here until a saner solution can be found\n    # NOTE: MinGW-w64 and Visual C++ do /not/ need this hack.\n    add_definitions(-DUNICODE)\n    add_definitions(-DWINVER=0x0501)\nendif()\n\n#--------------------------------------------------------------------\n# Use WGL for context creation\n#--------------------------------------------------------------------\nif (_GLFW_WGL)\n    list(APPEND glfw_INCLUDE_DIRS ${OPENGL_INCLUDE_DIR})\n    list(APPEND glfw_LIBRARIES ${OPENGL_gl_LIBRARY})\nendif()\n\n#--------------------------------------------------------------------\n# Use X11 for window creation\n#--------------------------------------------------------------------\nif (_GLFW_X11)\n\n    find_package(X11 REQUIRED)\n\n    set(GLFW_PKG_DEPS \"${GLFW_PKG_DEPS} x11\")\n\n    # Set up library and include paths\n    list(APPEND glfw_INCLUDE_DIRS ${X11_X11_INCLUDE_PATH})\n    list(APPEND glfw_LIBRARIES ${X11_X11_LIB} ${CMAKE_THREAD_LIBS_INIT})\n    if (UNIX AND NOT APPLE)\n        list(APPEND glfw_LIBRARIES ${RT_LIBRARY})\n    endif()\n\n    # Check for XRandR (modern resolution switching and gamma control)\n    if (NOT X11_Xrandr_FOUND)\n        message(FATAL_ERROR \"The RandR library and headers were not found\")\n    endif()\n\n    list(APPEND glfw_INCLUDE_DIRS ${X11_Xrandr_INCLUDE_PATH})\n    list(APPEND glfw_LIBRARIES ${X11_Xrandr_LIB})\n    set(GLFW_PKG_DEPS \"${GLFW_PKG_DEPS} xrandr\")\n\n    # Check for XInput (high-resolution cursor motion)\n    if (NOT X11_Xinput_FOUND)\n        message(FATAL_ERROR \"The XInput library and headers were not found\")\n    endif()\n\n    list(APPEND glfw_INCLUDE_DIRS ${X11_Xinput_INCLUDE_PATH})\n\n    if (X11_Xinput_LIB)\n        list(APPEND glfw_LIBRARIES ${X11_Xinput_LIB})\n    else()\n        # Backwards compatibility (bug in CMake 2.8.7)\n        list(APPEND glfw_LIBRARIES Xi)\n    endif()\n    set(GLFW_PKG_DEPS \"${GLFW_PKG_DEPS} xi\")\n\n    # Check for Xf86VidMode (fallback gamma control)\n    if (NOT X11_xf86vmode_FOUND)\n        message(FATAL_ERROR \"The Xf86VidMode library and headers were not found\")\n    endif()\n\n    list(APPEND glfw_INCLUDE_DIRS ${X11_xf86vmode_INCLUDE_PATH})\n    set(GLFW_PKG_DEPS \"${GLFW_PKG_DEPS} xxf86vm\")\n\n    if (X11_Xxf86vm_LIB)\n        list(APPEND glfw_LIBRARIES ${X11_Xxf86vm_LIB})\n    else()\n        # Backwards compatibility (see CMake bug 0006976)\n        list(APPEND glfw_LIBRARIES Xxf86vm)\n    endif()\n\n    # Check for Xkb (X keyboard extension)\n    if (NOT X11_Xkb_FOUND)\n        message(FATAL_ERROR \"The X keyboard extension headers were not found\")\n    endif() \n\n    list(APPEND glfw_INCLUDE_DIR ${X11_Xkb_INCLUDE_PATH})\n\n    find_library(RT_LIBRARY rt)\n    mark_as_advanced(RT_LIBRARY)\n    if (RT_LIBRARY)\n        list(APPEND glfw_LIBRARIES ${RT_LIBRARY})\n        set(GLFW_PKG_LIBS \"${GLFW_PKG_LIBS} -lrt\")\n    endif()\n\n    find_library(MATH_LIBRARY m)\n    mark_as_advanced(MATH_LIBRARY)\n    if (MATH_LIBRARY)\n        list(APPEND glfw_LIBRARIES ${MATH_LIBRARY})\n        set(GLFW_PKG_LIBS \"${GLFW_PKG_LIBS} -lm\")\n    endif()\n\nendif()\n\n#--------------------------------------------------------------------\n# Use GLX for context creation\n#--------------------------------------------------------------------\nif (_GLFW_GLX)\n\n    list(APPEND glfw_INCLUDE_DIRS ${OPENGL_INCLUDE_DIR})\n    list(APPEND glfw_LIBRARIES ${OPENGL_gl_LIBRARY})\n\n    set(GLFW_PKG_DEPS \"${GLFW_PKG_DEPS} gl\")\n\n    include(CheckFunctionExists)\n\n    set(CMAKE_REQUIRED_LIBRARIES ${OPENGL_gl_LIBRARY})\n    check_function_exists(glXGetProcAddress _GLFW_HAS_GLXGETPROCADDRESS)\n    check_function_exists(glXGetProcAddressARB _GLFW_HAS_GLXGETPROCADDRESSARB)\n    check_function_exists(glXGetProcAddressEXT _GLFW_HAS_GLXGETPROCADDRESSEXT)\n\n    if (NOT _GLFW_HAS_GLXGETPROCADDRESS AND\n        NOT _GLFW_HAS_GLXGETPROCADDRESSARB AND\n        NOT _GLFW_HAS_GLXGETPROCADDRESSEXT)\n        message(WARNING \"No glXGetProcAddressXXX variant found\")\n\n        # Check for dlopen support as a fallback\n\n        set(CMAKE_REQUIRED_LIBRARIES ${CMAKE_DL_LIBS})\n        check_function_exists(dlopen _GLFW_HAS_DLOPEN)\n        if (NOT _GLFW_HAS_DLOPEN)\n            message(FATAL_ERROR \"No entry point retrieval mechanism found\")\n        endif()\n\n        if (CMAKE_DL_LIBS)\n            list(APPEND glfw_LIBRARIES ${CMAKE_DL_LIBS})\n            set(GLFW_PKG_LIBS \"${GLFW_PKG_LIBS} -l${CMAKE_DL_LIBS}\")\n        endif()\n    endif()\n\nendif()\n\n#--------------------------------------------------------------------\n# Use EGL for context creation\n#--------------------------------------------------------------------\nif (_GLFW_EGL)\n\n    list(APPEND glfw_INCLUDE_DIRS ${EGL_INCLUDE_DIR})\n    list(APPEND glfw_LIBRARIES ${EGL_LIBRARY})\n\n    if (UNIX)\n        set(GLFW_PKG_DEPS \"${GLFW_PKG_DEPS} egl\")\n    endif()\n\n    if (_GLFW_USE_OPENGL)\n        list(APPEND glfw_LIBRARIES ${OPENGL_gl_LIBRARY})\n        list(APPEND glfw_INCLUDE_DIRS ${OPENGL_INCLUDE_DIR})\n        set(GLFW_PKG_DEPS \"${GLFW_PKG_DEPS} gl\")\n    elseif (_GLFW_USE_GLESV1)\n        list(APPEND glfw_LIBRARIES ${GLESv1_LIBRARY})\n        list(APPEND glfw_INCLUDE_DIRS ${GLESv1_INCLUDE_DIR})\n        set(GLFW_PKG_DEPS \"${GLFW_PKG_DEPS} glesv1_cm\")\n    elseif (_GLFW_USE_GLESV2)\n        list(APPEND glfw_LIBRARIES ${GLESv2_LIBRARY})\n        list(APPEND glfw_INCLUDE_DIRS ${GLESv2_INCLUDE_DIR})\n        set(GLFW_PKG_DEPS \"${GLFW_PKG_DEPS} glesv2\")\n    endif()\n\nendif()\n\n#--------------------------------------------------------------------\n# Use Cocoa for window creation and NSOpenGL for context creation\n#--------------------------------------------------------------------\nif (_GLFW_COCOA AND _GLFW_NSGL)\n        \n    if (GLFW_USE_MENUBAR)\n        set(_GLFW_USE_MENUBAR 1)\n    endif()\n\n    if (GLFW_USE_CHDIR)\n        set(_GLFW_USE_CHDIR 1)\n    endif()\n\n    if (GLFW_BUILD_UNIVERSAL)\n        message(STATUS \"Building GLFW as Universal Binaries\")\n        set(CMAKE_OSX_ARCHITECTURES i386;x86_64)\n    else()\n        message(STATUS \"Building GLFW only for the native architecture\")\n    endif()\n    \n    # Set up library and include paths\n    find_library(COCOA_FRAMEWORK Cocoa)\n    find_library(IOKIT_FRAMEWORK IOKit)\n    find_library(CORE_FOUNDATION_FRAMEWORK CoreFoundation)\n    find_library(CORE_VIDEO_FRAMEWORK CoreVideo)\n    list(APPEND glfw_LIBRARIES ${COCOA_FRAMEWORK}\n                               ${OPENGL_gl_LIBRARY}\n                               ${IOKIT_FRAMEWORK}\n                               ${CORE_FOUNDATION_FRAMEWORK}\n                               ${CORE_VIDEO_FRAMEWORK})\n\n    set(GLFW_PKG_DEPS \"\")\n    set(GLFW_PKG_LIBS \"-framework Cocoa -framework OpenGL -framework IOKit -framework CoreFoundation -framework CoreVideo\")\nendif()\n\n#--------------------------------------------------------------------\n# Export GLFW library dependencies\n#--------------------------------------------------------------------\nset(GLFW_LIBRARIES ${glfw_LIBRARIES} CACHE STRING \"Dependencies of GLFW\")\n\n#--------------------------------------------------------------------\n# Choose library output name\n#--------------------------------------------------------------------\nif (BUILD_SHARED_LIBS AND UNIX)\n    # On Unix-like systems, shared libraries can use the soname system.\n    set(GLFW_LIB_NAME glfw)\nelse()\n    set(GLFW_LIB_NAME glfw3)\nendif()\n\n#--------------------------------------------------------------------\n# Create generated files\n#--------------------------------------------------------------------\nconfigure_file(${GLFW_SOURCE_DIR}/docs/Doxyfile.in\n               ${GLFW_BINARY_DIR}/docs/Doxyfile @ONLY)\n\nconfigure_file(${GLFW_SOURCE_DIR}/src/glfw_config.h.in \n               ${GLFW_BINARY_DIR}/src/glfw_config.h @ONLY)\n\nconfigure_file(${GLFW_SOURCE_DIR}/src/glfwConfig.cmake.in\n               ${GLFW_BINARY_DIR}/src/glfwConfig.cmake @ONLY)\n\nconfigure_file(${GLFW_SOURCE_DIR}/src/glfwConfigVersion.cmake.in\n               ${GLFW_BINARY_DIR}/src/glfwConfigVersion.cmake @ONLY)\n\nif (UNIX)\n    configure_file(${GLFW_SOURCE_DIR}/src/glfw3.pc.in\n                   ${GLFW_BINARY_DIR}/src/glfw3.pc @ONLY)\nendif()\n\n#--------------------------------------------------------------------\n# Add subdirectories\n#--------------------------------------------------------------------\nadd_subdirectory(src)\n\nif (GLFW_BUILD_EXAMPLES)\n    add_subdirectory(examples)\nendif()\n\nif (GLFW_BUILD_TESTS)\n    add_subdirectory(tests)\nendif()\n\nif (DOXYGEN_FOUND AND GLFW_BUILD_DOCS)\n    add_subdirectory(docs)\nendif()\n\n#--------------------------------------------------------------------\n# Install files other than the library\n# The library is installed by src/CMakeLists.txt\n#--------------------------------------------------------------------\nif (GLFW_INSTALL)\n    install(DIRECTORY include/GLFW DESTINATION include \n            FILES_MATCHING PATTERN glfw3.h PATTERN glfw3native.h)\n\n    install(FILES ${GLFW_BINARY_DIR}/src/glfwConfig.cmake\n                  ${GLFW_BINARY_DIR}/src/glfwConfigVersion.cmake\n            DESTINATION lib${LIB_SUFFIX}/cmake/glfw)\n\n    if (UNIX)\n        install(EXPORT glfwTargets DESTINATION lib${LIB_SUFFIX}/cmake/glfw)\n        install(FILES ${GLFW_BINARY_DIR}/src/glfw3.pc\n                DESTINATION lib${LIB_SUFFIX}/pkgconfig)\n    endif()\n\n    # Only generate this target if no higher-level project already has\n    if (NOT TARGET uninstall)\n        configure_file(${GLFW_SOURCE_DIR}/cmake_uninstall.cmake.in\n                       ${GLFW_BINARY_DIR}/cmake_uninstall.cmake IMMEDIATE @ONLY)\n\n        add_custom_target(uninstall\n                          ${CMAKE_COMMAND} -P\n                          ${GLFW_BINARY_DIR}/cmake_uninstall.cmake)\n    endif()\nendif()\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-glfw-3.0.4-5nzclnqicbr5l5hudpxlnfip73vfrttz/spack-src/src/glx_context.c": "//========================================================================\n// GLFW 3.0 GLX - www.glfw.org\n//------------------------------------------------------------------------\n// Copyright (c) 2002-2006 Marcus Geelnard\n// Copyright (c) 2006-2010 Camilla Berglund <elmindreda@elmindreda.org>\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would\n//    be appreciated but is not required.\n//\n// 2. Altered source versions must be plainly marked as such, and must not\n//    be misrepresented as being the original software.\n//\n// 3. This notice may not be removed or altered from any source\n//    distribution.\n//\n//========================================================================\n\n#include \"internal.h\"\n\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n\n\n// This is the only glXGetProcAddress variant not declared by glxext.h\nvoid (*glXGetProcAddressEXT(const GLubyte* procName))();\n\n\n#ifndef GLXBadProfileARB\n #define GLXBadProfileARB 13\n#endif\n\n\n// Returns the specified attribute of the specified GLXFBConfig\n// NOTE: Do not call this unless we have found GLX 1.3+ or GLX_SGIX_fbconfig\n//\nstatic int getFBConfigAttrib(GLXFBConfig fbconfig, int attrib)\n{\n    int value;\n\n    if (_glfw.glx.SGIX_fbconfig)\n    {\n        _glfw.glx.GetFBConfigAttribSGIX(_glfw.x11.display,\n                                        fbconfig, attrib, &value);\n    }\n    else\n        glXGetFBConfigAttrib(_glfw.x11.display, fbconfig, attrib, &value);\n\n    return value;\n}\n\n// Return a list of available and usable framebuffer configs\n//\nstatic GLboolean chooseFBConfig(const _GLFWfbconfig* desired, GLXFBConfig* result)\n{\n    GLXFBConfig* nativeConfigs;\n    _GLFWfbconfig* usableConfigs;\n    const _GLFWfbconfig* closest;\n    int i, nativeCount, usableCount;\n    const char* vendor;\n    GLboolean trustWindowBit = GL_TRUE;\n\n    vendor = glXGetClientString(_glfw.x11.display, GLX_VENDOR);\n    if (strcmp(vendor, \"Chromium\") == 0)\n    {\n        // HACK: This is a (hopefully temporary) workaround for Chromium\n        //       (VirtualBox GL) not setting the window bit on any GLXFBConfigs\n        trustWindowBit = GL_FALSE;\n    }\n\n    if (_glfw.glx.SGIX_fbconfig)\n    {\n        nativeConfigs = _glfw.glx.ChooseFBConfigSGIX(_glfw.x11.display,\n                                                     _glfw.x11.screen,\n                                                     NULL,\n                                                     &nativeCount);\n    }\n    else\n    {\n        nativeConfigs = glXGetFBConfigs(_glfw.x11.display,\n                                        _glfw.x11.screen,\n                                        &nativeCount);\n    }\n\n    if (!nativeCount)\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE,\n                        \"GLX: No GLXFBConfigs returned\");\n        return GL_FALSE;\n    }\n\n    usableConfigs = calloc(nativeCount, sizeof(_GLFWfbconfig));\n    usableCount = 0;\n\n    for (i = 0;  i < nativeCount;  i++)\n    {\n        const GLXFBConfig n = nativeConfigs[i];\n        _GLFWfbconfig* u = usableConfigs + usableCount;\n\n        if (!getFBConfigAttrib(n, GLX_DOUBLEBUFFER) ||\n            !getFBConfigAttrib(n, GLX_VISUAL_ID))\n        {\n            // Only consider double-buffered GLXFBConfigs with associated visuals\n            continue;\n        }\n\n        if (!(getFBConfigAttrib(n, GLX_RENDER_TYPE) & GLX_RGBA_BIT))\n        {\n            // Only consider RGBA GLXFBConfigs\n            continue;\n        }\n\n        if (!(getFBConfigAttrib(n, GLX_DRAWABLE_TYPE) & GLX_WINDOW_BIT))\n        {\n            if (trustWindowBit)\n            {\n                // Only consider window GLXFBConfigs\n                continue;\n            }\n        }\n\n        u->redBits = getFBConfigAttrib(n, GLX_RED_SIZE);\n        u->greenBits = getFBConfigAttrib(n, GLX_GREEN_SIZE);\n        u->blueBits = getFBConfigAttrib(n, GLX_BLUE_SIZE);\n\n        u->alphaBits = getFBConfigAttrib(n, GLX_ALPHA_SIZE);\n        u->depthBits = getFBConfigAttrib(n, GLX_DEPTH_SIZE);\n        u->stencilBits = getFBConfigAttrib(n, GLX_STENCIL_SIZE);\n\n        u->accumRedBits = getFBConfigAttrib(n, GLX_ACCUM_RED_SIZE);\n        u->accumGreenBits = getFBConfigAttrib(n, GLX_ACCUM_GREEN_SIZE);\n        u->accumBlueBits = getFBConfigAttrib(n, GLX_ACCUM_BLUE_SIZE);\n        u->accumAlphaBits = getFBConfigAttrib(n, GLX_ACCUM_ALPHA_SIZE);\n\n        u->auxBuffers = getFBConfigAttrib(n, GLX_AUX_BUFFERS);\n        u->stereo = getFBConfigAttrib(n, GLX_STEREO);\n\n        if (_glfw.glx.ARB_multisample)\n            u->samples = getFBConfigAttrib(n, GLX_SAMPLES);\n\n        if (_glfw.glx.ARB_framebuffer_sRGB)\n            u->sRGB = getFBConfigAttrib(n, GLX_FRAMEBUFFER_SRGB_CAPABLE_ARB);\n\n        u->glx = n;\n        usableCount++;\n    }\n\n    closest = _glfwChooseFBConfig(desired, usableConfigs, usableCount);\n    if (closest)\n        *result = closest->glx;\n\n    XFree(nativeConfigs);\n    free(usableConfigs);\n\n    return closest ? GL_TRUE : GL_FALSE;\n}\n\n// Create the OpenGL context using legacy API\n//\nstatic GLXContext createLegacyContext(_GLFWwindow* window,\n                                      GLXFBConfig fbconfig,\n                                      GLXContext share)\n{\n    if (_glfw.glx.SGIX_fbconfig)\n    {\n        return _glfw.glx.CreateContextWithConfigSGIX(_glfw.x11.display,\n                                                     fbconfig,\n                                                     GLX_RGBA_TYPE,\n                                                     share,\n                                                     True);\n    }\n\n    return glXCreateNewContext(_glfw.x11.display,\n                               fbconfig,\n                               GLX_RGBA_TYPE,\n                               share,\n                               True);\n}\n\n\n//////////////////////////////////////////////////////////////////////////\n//////                       GLFW internal API                      //////\n//////////////////////////////////////////////////////////////////////////\n\n// Initialize GLX\n//\nint _glfwInitContextAPI(void)\n{\n#ifdef _GLFW_DLOPEN_LIBGL\n    int i;\n    char* libGL_names[ ] =\n    {\n        \"libGL.so\",\n        \"libGL.so.1\",\n        \"/usr/lib/libGL.so\",\n        \"/usr/lib/libGL.so.1\",\n        NULL\n    };\n\n    for (i = 0;  libGL_names[i] != NULL;  i++)\n    {\n        _glfw.glx.libGL = dlopen(libGL_names[i], RTLD_LAZY | RTLD_GLOBAL);\n        if (_glfw.glx.libGL)\n            break;\n    }\n\n    if (!_glfw.glx.libGL)\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR, \"GLX: Failed to find libGL\");\n        return GL_FALSE;\n    }\n#endif\n\n    if (pthread_key_create(&_glfw.glx.current, NULL) != 0)\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"GLX: Failed to create context TLS\");\n        return GL_FALSE;\n    }\n\n    // Check if GLX is supported on this display\n    if (!glXQueryExtension(_glfw.x11.display,\n                           &_glfw.glx.errorBase,\n                           &_glfw.glx.eventBase))\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE, \"GLX: GLX support not found\");\n        return GL_FALSE;\n    }\n\n    if (!glXQueryVersion(_glfw.x11.display,\n                         &_glfw.glx.versionMajor,\n                         &_glfw.glx.versionMinor))\n    {\n        _glfwInputError(GLFW_API_UNAVAILABLE,\n                        \"GLX: Failed to query GLX version\");\n        return GL_FALSE;\n    }\n\n    if (_glfwPlatformExtensionSupported(\"GLX_EXT_swap_control\"))\n    {\n        _glfw.glx.SwapIntervalEXT = (PFNGLXSWAPINTERVALEXTPROC)\n            _glfwPlatformGetProcAddress(\"glXSwapIntervalEXT\");\n\n        if (_glfw.glx.SwapIntervalEXT)\n            _glfw.glx.EXT_swap_control = GL_TRUE;\n    }\n\n    if (_glfwPlatformExtensionSupported(\"GLX_SGI_swap_control\"))\n    {\n        _glfw.glx.SwapIntervalSGI = (PFNGLXSWAPINTERVALSGIPROC)\n            _glfwPlatformGetProcAddress(\"glXSwapIntervalSGI\");\n\n        if (_glfw.glx.SwapIntervalSGI)\n            _glfw.glx.SGI_swap_control = GL_TRUE;\n    }\n\n    if (_glfwPlatformExtensionSupported(\"GLX_MESA_swap_control\"))\n    {\n        _glfw.glx.SwapIntervalMESA = (PFNGLXSWAPINTERVALMESAPROC)\n            _glfwPlatformGetProcAddress(\"glXSwapIntervalMESA\");\n\n        if (_glfw.glx.SwapIntervalMESA)\n            _glfw.glx.MESA_swap_control = GL_TRUE;\n    }\n\n    if (_glfwPlatformExtensionSupported(\"GLX_SGIX_fbconfig\"))\n    {\n        _glfw.glx.GetFBConfigAttribSGIX = (PFNGLXGETFBCONFIGATTRIBSGIXPROC)\n            _glfwPlatformGetProcAddress(\"glXGetFBConfigAttribSGIX\");\n        _glfw.glx.ChooseFBConfigSGIX = (PFNGLXCHOOSEFBCONFIGSGIXPROC)\n            _glfwPlatformGetProcAddress(\"glXChooseFBConfigSGIX\");\n        _glfw.glx.CreateContextWithConfigSGIX = (PFNGLXCREATECONTEXTWITHCONFIGSGIXPROC)\n            _glfwPlatformGetProcAddress(\"glXCreateContextWithConfigSGIX\");\n        _glfw.glx.GetVisualFromFBConfigSGIX = (PFNGLXGETVISUALFROMFBCONFIGSGIXPROC)\n            _glfwPlatformGetProcAddress(\"glXGetVisualFromFBConfigSGIX\");\n\n        if (_glfw.glx.GetFBConfigAttribSGIX &&\n            _glfw.glx.ChooseFBConfigSGIX &&\n            _glfw.glx.CreateContextWithConfigSGIX &&\n            _glfw.glx.GetVisualFromFBConfigSGIX)\n        {\n            _glfw.glx.SGIX_fbconfig = GL_TRUE;\n        }\n    }\n\n    if (_glfwPlatformExtensionSupported(\"GLX_ARB_multisample\"))\n        _glfw.glx.ARB_multisample = GL_TRUE;\n\n    if (_glfwPlatformExtensionSupported(\"GLX_ARB_framebuffer_sRGB\"))\n        _glfw.glx.ARB_framebuffer_sRGB = GL_TRUE;\n\n    if (_glfwPlatformExtensionSupported(\"GLX_ARB_create_context\"))\n    {\n        _glfw.glx.CreateContextAttribsARB = (PFNGLXCREATECONTEXTATTRIBSARBPROC)\n            _glfwPlatformGetProcAddress(\"glXCreateContextAttribsARB\");\n\n        if (_glfw.glx.CreateContextAttribsARB)\n            _glfw.glx.ARB_create_context = GL_TRUE;\n    }\n\n    if (_glfwPlatformExtensionSupported(\"GLX_ARB_create_context_robustness\"))\n        _glfw.glx.ARB_create_context_robustness = GL_TRUE;\n\n    if (_glfwPlatformExtensionSupported(\"GLX_ARB_create_context_profile\"))\n        _glfw.glx.ARB_create_context_profile = GL_TRUE;\n\n    if (_glfwPlatformExtensionSupported(\"GLX_EXT_create_context_es2_profile\"))\n        _glfw.glx.EXT_create_context_es2_profile = GL_TRUE;\n\n    return GL_TRUE;\n}\n\n// Terminate GLX\n//\nvoid _glfwTerminateContextAPI(void)\n{\n    // Unload libGL.so if necessary\n#ifdef _GLFW_DLOPEN_LIBGL\n    if (_glfw.glx.libGL != NULL)\n    {\n        dlclose(_glfw.glx.libGL);\n        _glfw.glx.libGL = NULL;\n    }\n#endif\n\n    pthread_key_delete(_glfw.glx.current);\n}\n\n#define setGLXattrib(attribName, attribValue) \\\n{ \\\n    attribs[index++] = attribName; \\\n    attribs[index++] = attribValue; \\\n    assert((size_t) index < sizeof(attribs) / sizeof(attribs[0])); \\\n}\n\n// Prepare for creation of the OpenGL context\n//\nint _glfwCreateContext(_GLFWwindow* window,\n                       const _GLFWwndconfig* wndconfig,\n                       const _GLFWfbconfig* fbconfig)\n{\n    int attribs[40];\n    GLXFBConfig native;\n    GLXContext share = NULL;\n\n    if (wndconfig->share)\n        share = wndconfig->share->glx.context;\n\n    if (!chooseFBConfig(fbconfig, &native))\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"GLX: Failed to find a suitable GLXFBConfig\");\n        return GL_FALSE;\n    }\n\n    // Retrieve the corresponding visual\n    if (_glfw.glx.SGIX_fbconfig)\n    {\n        window->glx.visual =\n            _glfw.glx.GetVisualFromFBConfigSGIX(_glfw.x11.display, native);\n    }\n    else\n        window->glx.visual = glXGetVisualFromFBConfig(_glfw.x11.display, native);\n\n    if (window->glx.visual == NULL)\n    {\n        _glfwInputError(GLFW_PLATFORM_ERROR,\n                        \"GLX: Failed to retrieve visual for GLXFBConfig\");\n        return GL_FALSE;\n    }\n\n    if (wndconfig->clientAPI == GLFW_OPENGL_ES_API)\n    {\n        if (!_glfw.glx.ARB_create_context ||\n            !_glfw.glx.ARB_create_context_profile ||\n            !_glfw.glx.EXT_create_context_es2_profile)\n        {\n            _glfwInputError(GLFW_API_UNAVAILABLE,\n                            \"GLX: OpenGL ES requested but \"\n                            \"GLX_EXT_create_context_es2_profile is unavailable\");\n            return GL_FALSE;\n        }\n    }\n\n    if (wndconfig->glForward)\n    {\n        if (!_glfw.glx.ARB_create_context)\n        {\n            _glfwInputError(GLFW_VERSION_UNAVAILABLE,\n                            \"GLX: Forward compatibility requested but \"\n                            \"GLX_ARB_create_context_profile is unavailable\");\n            return GL_FALSE;\n        }\n    }\n\n    if (wndconfig->glProfile)\n    {\n        if (!_glfw.glx.ARB_create_context ||\n            !_glfw.glx.ARB_create_context_profile)\n        {\n            _glfwInputError(GLFW_VERSION_UNAVAILABLE,\n                            \"GLX: An OpenGL profile requested but \"\n                            \"GLX_ARB_create_context_profile is unavailable\");\n            return GL_FALSE;\n        }\n    }\n\n    _glfwGrabXErrorHandler();\n\n    if (_glfw.glx.ARB_create_context)\n    {\n        int index = 0, mask = 0, flags = 0, strategy = 0;\n\n        if (wndconfig->clientAPI == GLFW_OPENGL_API)\n        {\n            if (wndconfig->glForward)\n                flags |= GLX_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB;\n\n            if (wndconfig->glDebug)\n                flags |= GLX_CONTEXT_DEBUG_BIT_ARB;\n\n            if (wndconfig->glProfile)\n            {\n                if (wndconfig->glProfile == GLFW_OPENGL_CORE_PROFILE)\n                    mask |= GLX_CONTEXT_CORE_PROFILE_BIT_ARB;\n                else if (wndconfig->glProfile == GLFW_OPENGL_COMPAT_PROFILE)\n                    mask |= GLX_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB;\n            }\n        }\n        else\n            mask |= GLX_CONTEXT_ES2_PROFILE_BIT_EXT;\n\n        if (wndconfig->glRobustness != GLFW_NO_ROBUSTNESS)\n        {\n            if (_glfw.glx.ARB_create_context_robustness)\n            {\n                if (wndconfig->glRobustness == GLFW_NO_RESET_NOTIFICATION)\n                    strategy = GLX_NO_RESET_NOTIFICATION_ARB;\n                else if (wndconfig->glRobustness == GLFW_LOSE_CONTEXT_ON_RESET)\n                    strategy = GLX_LOSE_CONTEXT_ON_RESET_ARB;\n\n                flags |= GLX_CONTEXT_ROBUST_ACCESS_BIT_ARB;\n            }\n        }\n\n        if (wndconfig->glMajor != 1 || wndconfig->glMinor != 0)\n        {\n            // NOTE: Only request an explicitly versioned context when\n            //       necessary, as explicitly requesting version 1.0 does not\n            //       always return the highest available version\n\n            setGLXattrib(GLX_CONTEXT_MAJOR_VERSION_ARB, wndconfig->glMajor);\n            setGLXattrib(GLX_CONTEXT_MINOR_VERSION_ARB, wndconfig->glMinor);\n        }\n\n        if (mask)\n            setGLXattrib(GLX_CONTEXT_PROFILE_MASK_ARB, mask);\n\n        if (flags)\n            setGLXattrib(GLX_CONTEXT_FLAGS_ARB, flags);\n\n        if (strategy)\n            setGLXattrib(GLX_CONTEXT_RESET_NOTIFICATION_STRATEGY_ARB, strategy);\n\n        setGLXattrib(None, None);\n\n        window->glx.context =\n            _glfw.glx.CreateContextAttribsARB(_glfw.x11.display,\n                                              native,\n                                              share,\n                                              True,\n                                              attribs);\n\n        if (window->glx.context == NULL)\n        {\n            // HACK: This is a fallback for the broken Mesa implementation of\n            //       GLX_ARB_create_context_profile, which fails default 1.0\n            //       context creation with a GLXBadProfileARB error in violation\n            //       of the extension spec\n            if (_glfw.x11.errorCode == _glfw.glx.errorBase + GLXBadProfileARB &&\n                wndconfig->clientAPI == GLFW_OPENGL_API &&\n                wndconfig->glProfile == GLFW_OPENGL_ANY_PROFILE &&\n                wndconfig->glForward == GL_FALSE)\n            {\n                window->glx.context = createLegacyContext(window, native, share);\n            }\n        }\n    }\n    else\n        window->glx.context = createLegacyContext(window, native, share);\n\n    _glfwReleaseXErrorHandler();\n\n    if (window->glx.context == NULL)\n    {\n        _glfwInputXError(GLFW_PLATFORM_ERROR, \"GLX: Failed to create context\");\n        return GL_FALSE;\n    }\n\n    return GL_TRUE;\n}\n\n#undef setGLXattrib\n\n// Destroy the OpenGL context\n//\nvoid _glfwDestroyContext(_GLFWwindow* window)\n{\n    if (window->glx.visual)\n    {\n        XFree(window->glx.visual);\n        window->glx.visual = NULL;\n    }\n\n    if (window->glx.context)\n    {\n        glXDestroyContext(_glfw.x11.display, window->glx.context);\n        window->glx.context = NULL;\n    }\n}\n\n\n//////////////////////////////////////////////////////////////////////////\n//////                       GLFW platform API                      //////\n//////////////////////////////////////////////////////////////////////////\n\nvoid _glfwPlatformMakeContextCurrent(_GLFWwindow* window)\n{\n    if (window)\n    {\n        glXMakeCurrent(_glfw.x11.display,\n                       window->x11.handle,\n                       window->glx.context);\n    }\n    else\n        glXMakeCurrent(_glfw.x11.display, None, NULL);\n\n    pthread_setspecific(_glfw.glx.current, window);\n}\n\n_GLFWwindow* _glfwPlatformGetCurrentContext(void)\n{\n    return (_GLFWwindow*) pthread_getspecific(_glfw.glx.current);\n}\n\nvoid _glfwPlatformSwapBuffers(_GLFWwindow* window)\n{\n    glXSwapBuffers(_glfw.x11.display, window->x11.handle);\n}\n\nvoid _glfwPlatformSwapInterval(int interval)\n{\n    _GLFWwindow* window = _glfwPlatformGetCurrentContext();\n\n    if (_glfw.glx.EXT_swap_control)\n    {\n        _glfw.glx.SwapIntervalEXT(_glfw.x11.display,\n                                  window->x11.handle,\n                                  interval);\n    }\n    else if (_glfw.glx.MESA_swap_control)\n        _glfw.glx.SwapIntervalMESA(interval);\n    else if (_glfw.glx.SGI_swap_control)\n    {\n        if (interval > 0)\n            _glfw.glx.SwapIntervalSGI(interval);\n    }\n}\n\nint _glfwPlatformExtensionSupported(const char* extension)\n{\n    const GLubyte* extensions;\n\n    // Get list of GLX extensions\n    extensions = (const GLubyte*) glXQueryExtensionsString(_glfw.x11.display,\n                                                           _glfw.x11.screen);\n    if (extensions != NULL)\n    {\n        if (_glfwStringInExtensionString(extension, extensions))\n            return GL_TRUE;\n    }\n\n    return GL_FALSE;\n}\n\nGLFWglproc _glfwPlatformGetProcAddress(const char* procname)\n{\n    return _glfw_glXGetProcAddress((const GLubyte*) procname);\n}\n\n\n//////////////////////////////////////////////////////////////////////////\n//////                        GLFW native API                       //////\n//////////////////////////////////////////////////////////////////////////\n\nGLFWAPI GLXContext glfwGetGLXContext(GLFWwindow* handle)\n{\n    _GLFWwindow* window = (_GLFWwindow*) handle;\n    _GLFW_REQUIRE_INIT_OR_RETURN(NULL);\n    return window->glx.context;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-glfw-3.0.4-5nzclnqicbr5l5hudpxlnfip73vfrttz/spack-src/src/glfw_config.h.in": "//========================================================================\n// GLFW 3.0 - www.glfw.org\n//------------------------------------------------------------------------\n// Copyright (c) 2010 Camilla Berglund <elmindreda@elmindreda.org>\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would\n//    be appreciated but is not required.\n//\n// 2. Altered source versions must be plainly marked as such, and must not\n//    be misrepresented as being the original software.\n//\n// 3. This notice may not be removed or altered from any source\n//    distribution.\n//\n//========================================================================\n// As glfw_config.h.in, this file is used by CMake to produce the\n// glfw_config.h configuration header file.  If you are adding a feature\n// requiring conditional compilation, this is where to add the macro.\n//========================================================================\n// As glfw_config.h, this file defines compile-time option macros for a\n// specific platform and development environment.  If you are using the\n// GLFW CMake files, modify glfw_config.h.in instead of this file.  If you\n// are using your own build system, make this file define the appropriate\n// macros in whatever way is suitable.\n//========================================================================\n\n// Define this to 1 if building GLFW for X11\n#cmakedefine _GLFW_X11\n// Define this to 1 if building GLFW for Win32\n#cmakedefine _GLFW_WIN32\n// Define this to 1 if building GLFW for Cocoa\n#cmakedefine _GLFW_COCOA\n\n// Define this to 1 if building GLFW for EGL\n#cmakedefine _GLFW_EGL\n// Define this to 1 if building GLFW for GLX\n#cmakedefine _GLFW_GLX\n// Define this to 1 if building GLFW for WGL\n#cmakedefine _GLFW_WGL\n// Define this to 1 if building GLFW for NSGL\n#cmakedefine _GLFW_NSGL\n\n// Define this to 1 if building as a shared library / dynamic library / DLL\n#cmakedefine _GLFW_BUILD_DLL\n\n// Define this to 1 to disable dynamic loading of winmm\n#cmakedefine _GLFW_NO_DLOAD_WINMM\n// Define this to 1 if glfwSwapInterval should ignore DWM compositing status\n#cmakedefine _GLFW_USE_DWM_SWAP_INTERVAL\n// Define this to 1 to force use of high-performance GPU on Optimus systems\n#cmakedefine _GLFW_USE_OPTIMUS_HPG\n\n// Define this to 1 if glXGetProcAddress is available\n#cmakedefine _GLFW_HAS_GLXGETPROCADDRESS\n// Define this to 1 if glXGetProcAddressARB is available\n#cmakedefine _GLFW_HAS_GLXGETPROCADDRESSARB\n// Define this to 1 if glXGetProcAddressEXT is available\n#cmakedefine _GLFW_HAS_GLXGETPROCADDRESSEXT\n// Define this to 1 if dlopen is available\n#cmakedefine _GLFW_HAS_DLOPEN\n\n// Define this to 1 if glfwInit should change the current directory\n#cmakedefine _GLFW_USE_CHDIR\n// Define this to 1 if glfwCreateWindow should populate the menu bar\n#cmakedefine _GLFW_USE_MENUBAR\n\n// Define this to 1 if using OpenGL as the client library\n#cmakedefine _GLFW_USE_OPENGL\n// Define this to 1 if using OpenGL ES 1.1 as the client library\n#cmakedefine _GLFW_USE_GLESV1\n// Define this to 1 if using OpenGL ES 2.0 as the client library\n#cmakedefine _GLFW_USE_GLESV2\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-glfw-3.0.4-5nzclnqicbr5l5hudpxlnfip73vfrttz/spack-src/src/egl_platform.h": "//========================================================================\n// GLFW 3.0 EGL - www.glfw.org\n//------------------------------------------------------------------------\n// Copyright (c) 2002-2006 Marcus Geelnard\n// Copyright (c) 2006-2010 Camilla Berglund <elmindreda@elmindreda.org>\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would\n//    be appreciated but is not required.\n//\n// 2. Altered source versions must be plainly marked as such, and must not\n//    be misrepresented as being the original software.\n//\n// 3. This notice may not be removed or altered from any source\n//    distribution.\n//\n//========================================================================\n\n#ifndef _egl_platform_h_\n#define _egl_platform_h_\n\n#include <EGL/egl.h>\n\n// This path may need to be changed if you build GLFW using your own setup\n// We ship and use our own copy of eglext.h since GLFW uses fairly new\n// extensions and not all operating systems come with an up-to-date version\n#include \"../deps/EGL/eglext.h\"\n\n// Do we have support for dlopen/dlsym?\n#if defined(_GLFW_HAS_DLOPEN)\n #include <dlfcn.h>\n#endif\n\n#define _GLFW_PLATFORM_FBCONFIG             EGLConfig       egl\n#define _GLFW_PLATFORM_CONTEXT_STATE        _GLFWcontextEGL egl\n#define _GLFW_PLATFORM_LIBRARY_OPENGL_STATE _GLFWlibraryEGL egl\n\n\n//========================================================================\n// GLFW platform specific types\n//========================================================================\n\n//------------------------------------------------------------------------\n// Platform-specific OpenGL context structure\n//------------------------------------------------------------------------\ntypedef struct _GLFWcontextEGL\n{\n   EGLConfig      config;\n   EGLContext     context;\n   EGLSurface     surface;\n\n#if defined(_GLFW_X11)\n   XVisualInfo*   visual;\n#endif\n} _GLFWcontextEGL;\n\n\n//------------------------------------------------------------------------\n// Platform-specific library global data for EGL\n//------------------------------------------------------------------------\ntypedef struct _GLFWlibraryEGL\n{\n    EGLDisplay      display;\n    EGLint          versionMajor, versionMinor;\n\n    GLboolean       KHR_create_context;\n\n} _GLFWlibraryEGL;\n\n\n#endif // _egl_platform_h_\n",
        "/tmp/vanessa/spack-stage/spack-stage-glfw-3.0.4-5nzclnqicbr5l5hudpxlnfip73vfrttz/spack-src/src/glx_platform.h": "//========================================================================\n// GLFW 3.0 GLX - www.glfw.org\n//------------------------------------------------------------------------\n// Copyright (c) 2002-2006 Marcus Geelnard\n// Copyright (c) 2006-2010 Camilla Berglund <elmindreda@elmindreda.org>\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would\n//    be appreciated but is not required.\n//\n// 2. Altered source versions must be plainly marked as such, and must not\n//    be misrepresented as being the original software.\n//\n// 3. This notice may not be removed or altered from any source\n//    distribution.\n//\n//========================================================================\n\n#ifndef _glx_platform_h_\n#define _glx_platform_h_\n\n#define GLX_GLXEXT_LEGACY\n#include <GL/glx.h>\n\n// This path may need to be changed if you build GLFW using your own setup\n// We ship and use our own copy of glxext.h since GLFW uses fairly new\n// extensions and not all operating systems come with an up-to-date version\n#include \"../deps/GL/glxext.h\"\n\n// Do we have support for dlopen/dlsym?\n#if defined(_GLFW_HAS_DLOPEN)\n #include <dlfcn.h>\n#endif\n\n#include <pthread.h>\n\n// We support four different ways for getting addresses for GL/GLX\n// extension functions: glXGetProcAddress, glXGetProcAddressARB,\n// glXGetProcAddressEXT, and dlsym\n#if defined(_GLFW_HAS_GLXGETPROCADDRESSARB)\n #define _glfw_glXGetProcAddress(x) glXGetProcAddressARB(x)\n#elif defined(_GLFW_HAS_GLXGETPROCADDRESS)\n #define _glfw_glXGetProcAddress(x) glXGetProcAddress(x)\n#elif defined(_GLFW_HAS_GLXGETPROCADDRESSEXT)\n #define _glfw_glXGetProcAddress(x) glXGetProcAddressEXT(x)\n#elif defined(_GLFW_HAS_DLOPEN)\n #define _glfw_glXGetProcAddress(x) dlsym(_glfw.glx.libGL, x)\n #define _GLFW_DLOPEN_LIBGL\n#else\n #error \"No OpenGL entry point retrieval mechanism was enabled\"\n#endif\n\n#define _GLFW_PLATFORM_FBCONFIG             GLXFBConfig     glx\n#define _GLFW_PLATFORM_CONTEXT_STATE        _GLFWcontextGLX glx\n#define _GLFW_PLATFORM_LIBRARY_OPENGL_STATE _GLFWlibraryGLX glx\n\n#ifndef GLX_MESA_swap_control\ntypedef int (*PFNGLXSWAPINTERVALMESAPROC)(int);\n#endif\n\n\n//========================================================================\n// GLFW platform specific types\n//========================================================================\n\n//------------------------------------------------------------------------\n// Platform-specific OpenGL context structure\n//------------------------------------------------------------------------\ntypedef struct _GLFWcontextGLX\n{\n    GLXContext      context; // OpenGL rendering context\n    XVisualInfo*    visual;  // Visual for selected GLXFBConfig\n\n} _GLFWcontextGLX;\n\n\n//------------------------------------------------------------------------\n// Platform-specific library global data for GLX\n//------------------------------------------------------------------------\ntypedef struct _GLFWlibraryGLX\n{\n    // Server-side GLX version\n    int             versionMajor, versionMinor;\n    int             eventBase;\n    int             errorBase;\n\n    // TLS key for per-thread current context/window\n    pthread_key_t   current;\n\n    // GLX extensions\n    PFNGLXSWAPINTERVALSGIPROC             SwapIntervalSGI;\n    PFNGLXSWAPINTERVALEXTPROC             SwapIntervalEXT;\n    PFNGLXSWAPINTERVALMESAPROC            SwapIntervalMESA;\n    PFNGLXGETFBCONFIGATTRIBSGIXPROC       GetFBConfigAttribSGIX;\n    PFNGLXCHOOSEFBCONFIGSGIXPROC          ChooseFBConfigSGIX;\n    PFNGLXCREATECONTEXTWITHCONFIGSGIXPROC CreateContextWithConfigSGIX;\n    PFNGLXGETVISUALFROMFBCONFIGSGIXPROC   GetVisualFromFBConfigSGIX;\n    PFNGLXCREATECONTEXTATTRIBSARBPROC     CreateContextAttribsARB;\n    GLboolean       SGIX_fbconfig;\n    GLboolean       SGI_swap_control;\n    GLboolean       EXT_swap_control;\n    GLboolean       MESA_swap_control;\n    GLboolean       ARB_multisample;\n    GLboolean       ARB_framebuffer_sRGB;\n    GLboolean       ARB_create_context;\n    GLboolean       ARB_create_context_profile;\n    GLboolean       ARB_create_context_robustness;\n    GLboolean       EXT_create_context_es2_profile;\n\n#if defined(_GLFW_DLOPEN_LIBGL)\n    void*           libGL;  // dlopen handle for libGL.so\n#endif\n} _GLFWlibraryGLX;\n\n\n#endif // _glx_platform_h_\n",
        "/tmp/vanessa/spack-stage/spack-stage-glfw-3.0.4-5nzclnqicbr5l5hudpxlnfip73vfrttz/spack-src/src/nsgl_platform.h": "//========================================================================\n// GLFW 3.0 OS X - www.glfw.org\n//------------------------------------------------------------------------\n// Copyright (c) 2009-2010 Camilla Berglund <elmindreda@elmindreda.org>\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would\n//    be appreciated but is not required.\n//\n// 2. Altered source versions must be plainly marked as such, and must not\n//    be misrepresented as being the original software.\n//\n// 3. This notice may not be removed or altered from any source\n//    distribution.\n//\n//========================================================================\n\n#ifndef _nsgl_platform_h_\n#define _nsgl_platform_h_\n\n\n#define _GLFW_PLATFORM_FBCONFIG\n#define _GLFW_PLATFORM_CONTEXT_STATE        _GLFWcontextNSGL nsgl\n#define _GLFW_PLATFORM_LIBRARY_OPENGL_STATE _GLFWlibraryNSGL nsgl\n\n\n//========================================================================\n// GLFW platform specific types\n//========================================================================\n\n//------------------------------------------------------------------------\n// Platform-specific OpenGL context structure\n//------------------------------------------------------------------------\ntypedef struct _GLFWcontextNSGL\n{\n    id           pixelFormat;\n    id\t         context;\n} _GLFWcontextNSGL;\n\n\n//------------------------------------------------------------------------\n// Platform-specific library global data for NSGL\n//------------------------------------------------------------------------\ntypedef struct _GLFWlibraryNSGL\n{\n    // dlopen handle for dynamically loading OpenGL extension entry points\n    void*           framework;\n\n    // TLS key for per-thread current context/window\n    pthread_key_t   current;\n\n} _GLFWlibraryNSGL;\n\n\n#endif // _nsgl_platform_h_\n",
        "/tmp/vanessa/spack-stage/spack-stage-glfw-3.0.4-5nzclnqicbr5l5hudpxlnfip73vfrttz/spack-src/docs/compile.dox": "/*!\n\n@page compile Compiling GLFW\n\n@tableofcontents\n\nThis is about compiling the GLFW library itself.  For information on how to\nbuild programs that use GLFW, see the @ref build guide.\n\n\n@section compile_deps Dependencies\n\nTo compile GLFW and the accompanying example programs, you will need **CMake**,\nwhich will generate the project files or makefiles for your particular\ndevelopment environment.  If you are on a Unix-like system such as Linux or\nFreeBSD or have a package system like Fink, MacPorts, Cygwin or Homebrew, you\ncan simply install its CMake package.  If not, you can get installers for\nWindows and OS X from the [CMake website](http://www.cmake.org/).\n\nAdditional dependencies are listed below.\n\nIf you wish to compile GLFW without CMake, see @ref compile_manual.\n\n\n@subsection compile_deps_msvc Dependencies using Visual C++ on Windows\n\nThe Microsoft Platform SDK that is installed along with Visual C++ contains all\nthe necessary headers, link libraries and tools except for CMake.\n\n\n@subsection compile_deps_mingw Dependencies with MinGW or MinGW-w64 on Windows\n\nBoth the MinGW and the MinGW-w64 packages contain all the necessary headers,\nlink libraries and tools except for CMake.\n\n\n@subsection compile_deps_mingw_cross Dependencies using MinGW or MinGW-w64 cross-compilation\n\nBoth Cygwin and many Linux distributions have MinGW or MinGW-w64 packages.  For\nexample, Cygwin has the `mingw64-i686-gcc` and `mingw64-x86_64-gcc` packages\nfor 32- and 64-bit version of MinGW-w64, while Debian GNU/Linux and derivatives\nlike Ubuntu have the `mingw-w64` package for both.\n\nGLFW has CMake toolchain files in the `CMake/` directory that allow for easy\ncross-compilation of Windows binaries.  To use these files you need to add a\nspecial parameter when generating the project files or makefiles:\n\n    cmake -DCMAKE_TOOLCHAIN_FILE=<toolchain-file> .\n\nThe exact toolchain file to use depends on the prefix used by the MinGW or\nMinGW-w64 binaries on your system.  You can usually see this in the /usr\ndirectory.  For example, both the Debian/Ubuntu and Cygwin MinGW-w64 packages\nhave `/usr/x86_64-w64-mingw32` for the 64-bit compilers, so the correct\ninvocation would be:\n\n    cmake -DCMAKE_TOOLCHAIN_FILE=CMake/x86_64-w64-mingw32.cmake .\n\nFor more details see the article\n[CMake Cross Compiling](http://www.paraview.org/Wiki/CMake_Cross_Compiling) on\nthe CMake wiki.\n\n\n@subsection compile_deps_xcode Dependencies using Xcode on OS X\n\nXcode contains all necessary tools except for CMake.  The necessary headers and\nlibraries are included in the core OS frameworks.  Xcode can be downloaded from\nthe Mac App Store or from the ADC Member Center.\n\n\n@subsection compile_deps_x11 Dependencies using Linux and X11\n\nTo compile GLFW for X11, you need to have the X11 and OpenGL header packages\ninstalled, as well as the basic development tools like GCC and make.  For\nexample, on Ubuntu and other distributions based on Debian GNU/Linux, you need\nto install the `xorg-dev` and `libglu1-mesa-dev` packages.  The former pulls in\nall X.org header packages and the latter pulls in the Mesa OpenGL and GLU\npackages.  GLFW itself doesn't need or use GLU, but some of the examples do.\nNote that using header files and libraries from Mesa during compilation *will\nnot* tie your binaries to the Mesa implementation of OpenGL.\n\n\n@section compile_cmake Generating files with CMake\n\nOnce you have all necessary dependencies it is time to generate the project\nfiles or makefiles for your development environment.  CMake needs to know two\npaths for this: the path to the *root* directory of the GLFW source tree (i.e.\n*not* the `src` subdirectory) and the target path for the generated files and\ncompiled binaries.  If these are the same, it is called an in-tree build,\notherwise it is called an out-of-tree build.\n\nOne of several advantages of out-of-tree builds is that you can generate files\nand compile for different development environments using a single source tree.\n\n\n@subsection compile_cmake_cli Generating files with the CMake command-line tool\n\nTo make an in-tree build, enter the *root* directory of the GLFW source tree\n(i.e. *not* the `src` subdirectory) and run CMake.  The current directory is\nused as target path, while the path provided as an argument is used to find the\nsource tree.\n\n    cd <glfw-root-dir>\n    cmake .\n\nTo make an out-of-tree build, make another directory, enter it and run CMake\nwith the (relative or absolute) path to the root of the source tree as an\nargument.\n\n    cd <glfw-root-dir>\n    mkdir build\n    cd build\n    cmake ..\n\n\n@subsection compile_cmake_gui Generating files with the CMake GUI\n\nIf you are using the GUI version, choose the root of the GLFW source tree as\nsource location and the same directory or another, empty directory as the\ndestination for binaries.  Choose *Configure*, change any options you wish to,\n*Configure* again to let the changes take effect and then *Generate*.\n\n\n@section compile_options CMake options\n\nThe CMake files for GLFW provide a number of options, although not all are\navailable on all supported platforms.  Some of these are de facto standards\namong CMake users and so have no `GLFW_` prefix.\n\nIf you are using the GUI version of CMake, these are listed and can be changed\nfrom there.  If you are using the command-line version, use the `ccmake` tool.\nSome package systems like Ubuntu and other distributions based on Debian\nGNU/Linux have this tool in a separate `cmake-curses-gui` package.\n\n\n@subsection compile_options_shared Shared CMake options\n\n`BUILD_SHARED_LIBS` determines whether GLFW is built as a static\nlibrary or as a DLL / shared library / dynamic library.\n\n`LIB_SUFFIX` affects where the GLFW shared /dynamic library is installed.  If it\nis empty, it is installed to `${CMAKE_INSTALL_PREFIX}/lib`.  If it is set to\n`64`, it is installed to `${CMAKE_INSTALL_PREFIX}/lib64`.\n\n`GLFW_CLIENT_LIBRARY` determines which client API library to use.  If set to\n`opengl` the OpenGL library is used, if set to `glesv1` for the OpenGL ES 1.x\nlibrary is used, or if set to `glesv2` the OpenGL ES 2.0 library is used.  The\nselected library and its header files must be present on the system for this to\nwork.\n\n`GLFW_BUILD_EXAMPLES` determines whether the GLFW examples are built\nalong with the library.\n\n`GLFW_BUILD_TESTS` determines whether the GLFW test programs are\nbuilt along with the library.\n\n`GLFW_BUILD_DOCS` determines whether the GLFW documentation is built along with\nthe library.\n\n\n@subsection compile_options_osx OS X specific CMake options\n\n`GLFW_USE_CHDIR` determines whether `glfwInit` changes the current\ndirectory of bundled applications to the `Contents/Resources` directory.\n\n`GLFW_USE_MENUBAR` determines whether the first call to\n`glfwCreateWindow` sets up a minimal menu bar.\n\n`GLFW_BUILD_UNIVERSAL` determines whether to build Universal Binaries.\n\n\n@subsection compile_options_win32 Windows specific CMake options\n\n`USE_MSVC_RUNTIME_LIBRARY_DLL` determines whether to use the DLL version or the\nstatic library version of the Visual C++ runtime library.  If set to `ON`, the\nDLL version of the Visual C++ library is used.  It is recommended to set this to\n`ON`, as this keeps the executable smaller and benefits from security and bug\nfix updates of the Visual C++ runtime.\n\n`GLFW_USE_DWM_SWAP_INTERVAL` determines whether the swap interval is set even\nwhen DWM compositing is enabled.  If this is `ON`, the swap interval is set even\nif DWM is enabled.  It is recommended to set this to `OFF`, as doing otherwise\ncan lead to severe jitter.\n\n`GLFW_USE_OPTIMUS_HPG` determines whether to export the `NvOptimusEnablement`\nsymbol, which forces the use of the high-performance GPU on nVidia Optimus\nsystems.\n\n\n@subsection compile_options_egl EGL specific CMake options\n\n`GLFW_USE_EGL` determines whether to use EGL instead of the platform-specific\ncontext creation API.  Note that EGL is not yet provided on all supported\nplatforms.\n\n\n@section compile_manual Compiling GLFW manually\n\nIf you wish to compile GLFW without its CMake build environment then you will\nhave to do at least some of the platform detection yourself.  GLFW needs\na number of configuration macros to be defined in order to know what it's being\ncompiled for and has many optional, platform-specific ones for various features.\n\nWhen building with CMake, the `glfw_config.h` configuration header is generated\nbased on the current platform and CMake options.  The GLFW CMake environment\ndefines `_GLFW_USE_CONFIG_H`, which causes this header to be included by\n`internal.h`.  Without this macro, GLFW will expect the necessary configuration\nmacros to be defined on the command-line.\n\nThree macros *must* be defined when compiling GLFW: one for selecting the window\ncreation API, one selecting the context creation API and one client library.\nExactly one of each kind must be defined for GLFW to compile and link.\n\nThe window creation API is used to create windows, handle input, monitors, gamma\nramps and clipboard.  The options are:\n\n - `_GLFW_COCOA` to use the Cocoa frameworks\n - `_GLFW_WIN32` to use the Win32 API\n - `_GLFW_X11` to use the X Window System\n\nThe context creation API is used to enumerate pixel formats / framebuffer\nconfigurations and to create contexts.  The options are:\n\n - `_GLFW_NSGL` to use the Cocoa OpenGL framework\n - `_GLFW_WGL` to use the Win32 WGL API\n - `_GLFW_GLX` to use the X11 GLX API\n - `_GLFW_EGL` to use the EGL API (experimental)\n\nThe client library is the one providing the OpenGL or OpenGL ES API, which is\nused by GLFW to probe the created context.  This is not the same thing as the\nclient API, as many desktop OpenGL client libraries now expose the OpenGL ES API\nthrough extensions.  The options are:\n\n - `_GLFW_USE_OPENGL` for the desktop OpenGL (opengl32.dll, libGL.so or\n   OpenGL.framework)\n - `_GLFW_USE_GLESV1` for OpenGL ES 1.x (experimental)\n - `_GLFW_USE_GLESV2` for OpenGL ES 2.x (experimental)\n\nNote that `_GLFW_USE_GLESV1` and `_GLFW_USE_GLESV2` may only be used with EGL,\nas the other context creation APIs do not interface with OpenGL ES client\nlibraries.\n\nIf you are building GLFW as a shared library / dynamic library / DLL then you\nmust also define `_GLFW_BUILD_DLL`.  Otherwise, you may not define it.\n\nIf you are using the X11 window creation API then you *must* also select an entry\npoint retrieval mechanism.\n\n - `_GLFW_HAS_GLXGETPROCADDRESS` to use `glXGetProcAddress` (recommended)\n - `_GLFW_HAS_GLXGETPROCADDRESSARB` to use `glXGetProcAddressARB` (legacy)\n - `_GLFW_HAS_GLXGETPROCADDRESSEXT` to use `glXGetProcAddressEXT` (legacy)\n - `_GLFW_HAS_DLOPEN` to do manual retrieval with `dlopen` (fallback)\n\nIf you are using the Cocoa window creation API, the following options are\navailable:\n\n - `_GLFW_USE_CHDIR` to `chdir` to the `Resources` subdirectory of the\n   application bundle during @ref glfwInit (recommended)\n - `_GLFW_USE_MENUBAR` to create and populate the menu bar when the first window\n   is created (recommended)\n\n*/\n"
    },
    "skipped": [],
    "total_files": 112
}