{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-libhbaapi-3.10-ejzbem6dsngp26lf2o2uwomfkph4manv/spack-src/hbaapilib.c": "/*************************************************************************\n * Description\n *\tHBAAPILIB.c - Implements a sample common (wrapper) HBA API library\n *\n * License:\n *\tThe contents of this file are subject to the SNIA Public License\n *\tVersion 1.0 (the \"License\"); you may not use this file except in\n *\tcompliance with the License. You may obtain a copy of the License at\n *\n *\t/http://www.snia.org/English/Resources/Code/OpenSource.html\n *\n *\tSoftware distributed under the License is distributed on an \"AS IS\"\n *\tbasis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See\n *\tthe License for the specific language governing rights and limitations\n *\tunder the License.\n *\n * The Original Code is  SNIA HBA API Wrapper Library\n *\n * The Initial Developer of the Original Code is:\n *\tBenjamin F. Kuo, Troika Networks, Inc. (benk@troikanetworks.com)\n *\n * Contributor(s):\n *\tTuan Lam, QLogic Corp. (t_lam@qlc.com)\n *\tDan Willie, Emulex Corp. (Dan.Willie@emulex.com)\n *\tDixon Hutchinson, Legato Systems, Inc. (dhutchin@legato.com)\n *\tDavid Dillard, VERITAS Software Corp. (david.dillard@veritas.com)\n *\n *************************************************************************\n */\n\n#include <stddef.h>\n#include <dlfcn.h>\n#include <stdlib.h>\n#include <strings.h>\n#include <string.h>\n#define __USE_XOPEN\n\n#include <stdio.h>\n#include <time.h>\n#include \"hbaapi.h\"\n#include \"vendorhbaapi.h\"\n#include <stdlib.h>\n#ifdef USESYSLOG\n#include <syslog.h>\n#endif\n\n/*\n * LIBRARY_NUM is a shortcut to figure out which library we need to call.\n *  The top 16 bits of handle are the library index\n */\n#define LIBRARY_NUM(handle)\t((handle)>>16)\n\n/*\n * VENDOR_HANDLE turns a global library handle into a vendor specific handle,\n * with all upper 16 bits set to 0\n */\n#define VENDOR_HANDLE(handle)\t((handle)&0xFFFF)\n\n#define HBA_HANDLE_FROM_LOCAL(library, vendor) \\\n\t\t\t\t(((library)<<16) | ((vendor)&0x0000FFFF))\n\nint _hbaapi_debuglevel = 0;\n#define DEBUG(L, STR, A1, A2, A3)\n\n#if defined(USESYSLOG) && defined(USELOGFILE)\nFILE *_hbaapi_debug_fd = NULL;\nint _hbaapi_sysloginit = 0;\n#undef DEBUG\n#define DEBUG(L, STR, A1, A2, A3)\\\n    if ((L) <= _hbaapi_debuglevel) {\\\n\tif(_hbaapi_sysloginit == 0) {\\\n\t    openlog(\"HBAAPI\", LOG_PID|LOG_ODELAY ,LOG_USER);\\\n\t    _hbaapi_sysloginit = 1;\\\n\t}\\\n\tsyslog (LOG_INFO, (STR), (A1), (A2), (A3));\\\n\tif(_hbaapi_debug_fd == NULL) {\\\n\t    _hbaapi_debug_fd = fopen(\"/tmp/HBAAPI.log\", \"a\");\\\n\t}\\\n        if(_hbaapi_debug_fd != NULL) {\\\n\t    fprintf(_hbaapi_debug_fd, #STR  \"\\n\", (A1), (A2), (A3));\\\n\t}\\\n    }\n#else /* Not both USESYSLOG and USELOGFILE */\n#if defined(USESYSLOG)\nint _hbaapi_sysloginit = 0;\n#undef DEBUG\n#define DEBUG(L, STR, A1, A2, A3) \\\n    if ((L) <= _hbaapi_debuglevel) {\\\n\tif(_hbaapi_sysloginit == 0) {\\\n\t    openlog(\"HBAAPI\", LOG_PID|LOG_ODELAY ,LOG_USER);\\\n\t    _hbaapi_sysloginit = 1;\\\n\t}\\\n\tsyslog (LOG_INFO, (STR), (A1), (A2), (A3));\\\n    }\n#endif /* USESYSLOG */\n#if defined(USELOGFILE)\nFILE *_hbaapi_debug_fd = NULL;\n#undef DEBUG\n#define DEBUG(L, STR, A1, A2, A3) \\\n    if((L) <= _hbaapi_debuglevel) {\\\n\tif(_hbaapi_debug_fd == NULL) {\\\n\t    _hbaapi_debug_fd = fopen(\"/tmp/HBAAPI.log\", \"a\");\\\n\t}\\\n\tif(_hbaapi_debug_fd != NULL) { \\\n\t    fprintf(_hbaapi_debug_fd, #STR \"\\n\", (A1), (A2), (A3));\\\n\t}\\\n    }\n#endif /* USELOGFILE */\n#endif /* Not both USELOGFILE and USESYSLOG */\n\n#ifdef POSIX_THREADS\n#include <pthread.h>\n/*\n * When multiple mutex's are grabed, they must be always be grabbed in\n * the same order, or deadlock can result.  There are three levels\n * of mutex's involved in this API.  If LL_mutex is grabbed, always grap\n * it first.  If AL_mutex is grabbed, it may not be grabbed before\n * LL_mutex.  If grabbed in a multi grab sequence, the mutex's protecting\n * the callback lists must always be grabbed last and release before calling\n * a vendor specific library function that might invoke a callback function\n * on the same thread.\n */\n#define GRAB_MUTEX(M)\t\t\tgrab_mutex(M)\n#define RELEASE_MUTEX(M)\t\trelease_mutex(M)\n#define RELEASE_MUTEX_RETURN(M,RET)\trelease_mutex(M); return(RET)\n#else\n#define GRAB_MUTEX(M)\n#define RELEASE_MUTEX(M)\n#define RELEASE_MUTEX_RETURN(M,RET)\treturn(RET)\n#endif\n\n/*\n * Vendor library information\n */\ntypedef enum {\n    HBA_LIBRARY_UNKNOWN,\n    HBA_LIBRARY_LOADED,\n    HBA_LIBRARY_NOT_LOADED\n} HBA_LIBRARY_STATUS;\n\ntypedef struct hba_library_info {\n    struct hba_library_info\n\t\t\t*next;\n    char\t\t*LibraryName;\n    void*\t\thLibrary;\t\t/* Handle to a loaded DLL */\n    char\t\t*LibraryPath;\n    HBA_ENTRYPOINTSV2\tfunctionTable;\t\t/* Function pointers */\n    HBA_LIBRARY_STATUS\tstatus;\t\t\t/* info on this library */\n    HBA_UINT32\t\tindex;\n} HBA_LIBRARY_INFO, *PHBA_LIBRARY_INFO;\n\n#define ARE_WE_INITED() \\\n\tif (_hbaapi_librarylist == NULL) { \\\n\t\treturn(HBA_STATUS_ERROR); \\\n\t}\nHBA_LIBRARY_INFO *_hbaapi_librarylist = NULL;\nHBA_UINT32 _hbaapi_total_library_count = 0;\n#ifdef POSIX_THREADS\npthread_mutex_t _hbaapi_LL_mutex = PTHREAD_MUTEX_INITIALIZER;\n#endif /* POSIX_THREADS */\n\n/*\n * Individual adapter (hba) information\n */\ntypedef struct hba_adapter_info {\n    struct hba_adapter_info\n\t\t\t*next;\n    HBA_STATUS\t\tGNstatus;\t/* status from GetAdapterNameFunc */\n    char\t\t*name;\n    HBA_WWN\t\tnodeWWN;\n    HBA_LIBRARY_INFO\t*library;\n    HBA_UINT32\t\tindex;\n} HBA_ADAPTER_INFO;\n\nHBA_ADAPTER_INFO *_hbaapi_adapterlist = NULL;\nHBA_UINT32 _hbaapi_total_adapter_count = 0;\n#ifdef POSIX_THREADS\npthread_mutex_t _hbaapi_AL_mutex = PTHREAD_MUTEX_INITIALIZER;\n#endif /* POSIX_THREADS */\n\n/*\n * Call back registration\n */\ntypedef struct hba_vendorcallback_elem {\n    struct hba_vendorcallback_elem\n\t\t\t\t*next;\n    HBA_CALLBACKHANDLE\t\tvendorcbhandle;\n    HBA_LIBRARY_INFO\t\t*lib_info;\n} HBA_VENDORCALLBACK_ELEM;\n\n/*\n * Each instance of HBA_ADAPTERCALLBACK_ELEM represents a call to one of\n * \"register\" functions that apply to a particular adapter.\n * HBA_ALLADAPTERSCALLBACK_ELEM is used just for HBA_RegisterForAdapterAddEvents\n */\ntypedef struct hba_adaptercallback_elem {\n    struct hba_adaptercallback_elem\n\t\t\t*next;\n    HBA_LIBRARY_INFO\t*lib_info;\n    void\t\t*userdata;\n    HBA_CALLBACKHANDLE\tvendorcbhandle;\n    void\t\t(*callback)();\n} HBA_ADAPTERCALLBACK_ELEM;\n\ntypedef struct hba_alladapterscallback_elem {\n    struct hba_alladapterscallback_elem\n\t\t\t\t*next;\n    void\t\t\t*userdata;\n    HBA_VENDORCALLBACK_ELEM\t*vendorhandlelist;\n    void\t\t\t(*callback)();\n} HBA_ALLADAPTERSCALLBACK_ELEM;\n\nHBA_ALLADAPTERSCALLBACK_ELEM *_hbaapi_adapteraddevents_callback_list = NULL;\nHBA_ADAPTERCALLBACK_ELEM *_hbaapi_adapterevents_callback_list = NULL;\nHBA_ADAPTERCALLBACK_ELEM *_hbaapi_adapterportevents_callback_list = NULL;\nHBA_ADAPTERCALLBACK_ELEM *_hbaapi_adapterportstatevents_callback_list = NULL;\nHBA_ADAPTERCALLBACK_ELEM *_hbaapi_targetevents_callback_list = NULL;\nHBA_ADAPTERCALLBACK_ELEM *_hbaapi_linkevents_callback_list = NULL;\n#ifdef POSIX_THREADS\n/* mutex's to protect each list */\npthread_mutex_t _hbaapi_AAE_mutex = PTHREAD_MUTEX_INITIALIZER;\npthread_mutex_t _hbaapi_AE_mutex = PTHREAD_MUTEX_INITIALIZER;\npthread_mutex_t _hbaapi_APE_mutex = PTHREAD_MUTEX_INITIALIZER;\npthread_mutex_t _hbaapi_APSE_mutex = PTHREAD_MUTEX_INITIALIZER;\npthread_mutex_t _hbaapi_TE_mutex = PTHREAD_MUTEX_INITIALIZER;\npthread_mutex_t _hbaapi_LE_mutex = PTHREAD_MUTEX_INITIALIZER;\n#endif /* POSIX_THREADS */\n\nHBA_ADAPTERCALLBACK_ELEM **cb_lists_array[] = {\n    &_hbaapi_adapterevents_callback_list,\n    &_hbaapi_adapterportevents_callback_list,\n    &_hbaapi_adapterportstatevents_callback_list,\n    &_hbaapi_targetevents_callback_list,\n    &_hbaapi_linkevents_callback_list,\n    NULL};\n\f\n/*\n * Common library internal. Mutex handling\n */\n#ifdef POSIX_THREADS\nstatic void\ngrab_mutex(pthread_mutex_t *mp) {\n    int ret;\n    if((ret = pthread_mutex_lock(mp)) != 0) {\n\tperror(\"pthread_mutex_lock - HBAAPI:\");\n\tDEBUG(0, \"pthread_mutex_lock returned %d\", ret, 0, 0);\n    }\n}\n\nstatic void\nrelease_mutex(pthread_mutex_t *mp) {\n    int ret;\n    if((ret = pthread_mutex_unlock(mp)) != 0) {\n\tperror(\"pthread_mutex_unlock - HBAAPI:\");\n\tDEBUG(0, \"pthread_mutex_unlock returned %d\", ret, 0, 0);\n    }\n}\n#endif\n\n/*\n * Common library internal. Check library and return vendorhandle\n */\nstatic HBA_STATUS\nHBA_CheckLibrary(HBA_HANDLE handle,\n\t\t HBA_LIBRARY_INFO **lib_infopp,\n\t\t HBA_HANDLE *vendorhandle) {\n\n    HBA_UINT32\t\tlibraryIndex;\n    HBA_LIBRARY_INFO\t*lib_infop;\n\n    if(_hbaapi_librarylist == NULL) {\n\treturn(HBA_STATUS_ERROR);\n    }\n    libraryIndex = LIBRARY_NUM(handle);\n\n    GRAB_MUTEX(&_hbaapi_LL_mutex);\n    for(lib_infop = _hbaapi_librarylist;\n\tlib_infop != NULL;\n\tlib_infop = lib_infop->next) {\n\tif(lib_infop->index == libraryIndex) {\n\t    if(lib_infop->status != HBA_LIBRARY_LOADED) {\n\t\treturn HBA_STATUS_ERROR;\n\t    }\n\t    *lib_infopp = lib_infop;\n\t    *vendorhandle = VENDOR_HANDLE(handle);\n\t    /* caller will release the mutex */\n\t    return HBA_STATUS_OK;\n\t}\n    }\n    RELEASE_MUTEX_RETURN(&_hbaapi_LL_mutex, HBA_STATUS_ERROR_INVALID_HANDLE);\n}\n#define CHECKLIBRARY() \\\n\tstatus = HBA_CheckLibrary(handle, &lib_infop, &vendorHandle);\\\n\tif(status != HBA_STATUS_OK) { \\\n\t    return(status); \\\n\t}\n\n/*\n *freevendorhandlelist is called with _hbaapi_LL_mutex already held\n */\nstatic void\nfreevendorhandlelist(HBA_VENDORCALLBACK_ELEM *vhlist) {\n    HBA_VENDORCALLBACK_ELEM\t*vhlp;\n    HBA_VENDORCALLBACK_ELEM\t*vnext;\n    HBARemoveCallbackFunc\tregisteredfunc;\n\n    for(vhlp = vhlist; vhlp != NULL; vhlp = vnext) {\n\tvnext = vhlp->next;\n\tregisteredfunc =\n\t    vhlp->lib_info->functionTable.RemoveCallbackHandler;\n\tif(registeredfunc == NULL) {\n\t    continue;\n\t}\n\t(registeredfunc)(vhlp->vendorcbhandle);\n\tfree(vhlp);\n    }\n}\n\nstatic\nHBA_STATUS\nlocal_remove_callback(HBA_CALLBACKHANDLE cbhandle) {\n    HBA_ADAPTERCALLBACK_ELEM\t\t***listp;\n    HBA_ADAPTERCALLBACK_ELEM\t\t**lastp;\n    HBA_ALLADAPTERSCALLBACK_ELEM\t**lap;\n    HBA_ALLADAPTERSCALLBACK_ELEM\t*allcbp;\n    HBA_ADAPTERCALLBACK_ELEM\t\t*cbp;\n    HBARemoveCallbackFunc\t\tregisteredfunc = NULL;\n    HBA_VENDORCALLBACK_ELEM\t\t*vhlp;\n    HBA_VENDORCALLBACK_ELEM\t\t*vnext;\n    int\t\t\t\t\tfound;\n    HBA_STATUS\t\t\t\tstatus = HBA_STATUS_ERROR_INVALID_HANDLE;\n\n\n    /* search through the simple lists first */\n    GRAB_MUTEX(&_hbaapi_AAE_mutex);\n    GRAB_MUTEX(&_hbaapi_AE_mutex);\n    GRAB_MUTEX(&_hbaapi_APE_mutex);\n    GRAB_MUTEX(&_hbaapi_APSE_mutex);\n    GRAB_MUTEX(&_hbaapi_TE_mutex);\n    GRAB_MUTEX(&_hbaapi_LE_mutex);\n    for(listp = cb_lists_array, found = 0; *listp != NULL; listp++) {\n\tlastp = *listp;\n\tfor(cbp=**listp; cbp != NULL; cbp = cbp->next) {\n\t    if(cbhandle != (HBA_CALLBACKHANDLE)cbp) {\n\t\tlastp = &(cbp->next);\n\t\tcontinue;\n\t    }\n\t    found = 1;\n\t    registeredfunc = cbp->lib_info->functionTable.RemoveCallbackHandler;\n\t    if(registeredfunc == NULL) {\n\t\tbreak;\n\t    }\n\t    (registeredfunc)(cbp->vendorcbhandle);\n\t    *lastp = cbp->next;\n\t    free(cbp);\n\t    break;\n\t}\n    }\n    RELEASE_MUTEX(&_hbaapi_LE_mutex);\n    RELEASE_MUTEX(&_hbaapi_TE_mutex);\n    RELEASE_MUTEX(&_hbaapi_APSE_mutex);\n    RELEASE_MUTEX(&_hbaapi_APE_mutex);\n    RELEASE_MUTEX(&_hbaapi_AE_mutex);\n    RELEASE_MUTEX(&_hbaapi_AAE_mutex);\n    if(found != 0) {\n\tif(registeredfunc == NULL) {\n\t    return HBA_STATUS_ERROR_NOT_SUPPORTED;\n\t}\n\treturn HBA_STATUS_OK;\n    }\n\n    GRAB_MUTEX(&_hbaapi_AAE_mutex);\n    /* if it wasnt in the simple lists, look in the list for adapteraddevents */\n    lap = &_hbaapi_adapteraddevents_callback_list;\n    for(allcbp = _hbaapi_adapteraddevents_callback_list;\n\tallcbp != NULL;\n\tallcbp = allcbp->next) {\n\tif(cbhandle != (HBA_CALLBACKHANDLE)allcbp) {\n\t    lap = &allcbp->next;\n\t    continue;\n\t}\n\tfor(vhlp = allcbp->vendorhandlelist; vhlp != NULL; vhlp = vnext) {\n\t    vnext = vhlp->next;\n\t    registeredfunc =\n\t\tvhlp->lib_info->functionTable.RemoveCallbackHandler;\n\t    if(registeredfunc == NULL) {\n\t\tcontinue;\n\t    }\n\t    (registeredfunc)(vhlp->vendorcbhandle);\n\t    free(vhlp);\n\t}\n\t*lap = allcbp->next;\n\tfree(allcbp);\n\tstatus = HBA_STATUS_OK;\n\tbreak;\n    }\n    RELEASE_MUTEX(&_hbaapi_AAE_mutex);\n    return(status);\n}\n\n#if defined(USESYSLOG) || defined(USELOGFILE)\nstatic char wwn_str1[17];\nstatic char wwn_str2[17];\nstatic char wwn_str3[17];\n#define WWN2STR1(wwn) WWN2str(wwn_str1, (wwn))\n#define WWN2STR2(wwn) WWN2str(wwn_str2, (wwn))\n#define WWN2STR3(wwn) WWN2str(wwn_str3, (wwn))\nstatic char *\nWWN2str(char *buf, HBA_WWN *wwn) {\n    int j;\n    unsigned char *pc = (unsigned char *)&(wwn->wwn[0]);\n    buf[0] = '\\0';\n    for (j=0; j<16; j+=2) {\n        sprintf(&buf[j], \"%02X\", (int)*pc++);\n    }\n    return(buf);\n}\n#endif\n\n/*\n * Read in the config file and load all the specified vendor specific\n * libraries and perform the function registration exercise\n */\nHBA_STATUS\nHBA_LoadLibrary() {\n    HBARegisterLibraryFunc\n\t\t\tRegisterFunc;\n    HBARegisterLibraryV2Func\n\t\t\tRegisterV2Func;\n    HBALoadLibraryFunc\tLoadLibraryFunc;\n    HBAGetVersionFunc\tGetVersionFunc;\n#ifdef POSIX_THREADS\n    int\t\t\tret;\n#endif\n    HBA_STATUS\t\tstatus;\n    HBA_UINT32\t\tlibversion;\n\n    /* Open configuration file from known location */\n    FILE\t\t*hbaconf;\n    char\t\tfullline[512];\t\t/* line read from HBA.conf */\n    char\t\t*libraryname;\t\t/* Read in from file HBA.conf */\n    char\t\t*librarypath;\t\t/* Read in from file HBA.conf */\n    char\t\thbaConfFilePath[256];\n    char\t\t*charPtr;\n    HBA_LIBRARY_INFO\t*lib_infop;\n    int\t\t\tduplicate = 0;\n\n    if(_hbaapi_librarylist != NULL) {\n\tfprintf(stderr,\n\t\t\"HBA_LoadLibrary: previously unfreed \"\n\t\t\"libraries exist, call HBA_FreeLibrary().\\n\");\n\treturn HBA_STATUS_ERROR;\n    }\n\n    strcpy(hbaConfFilePath, \"/etc/hba.conf\");\n\n    if ((hbaconf = fopen(hbaConfFilePath, \"r\")) == NULL) {\n\tprintf(\"Cannot open %s\\n\", hbaConfFilePath);\n\treturn HBA_STATUS_ERROR;\n    }\n\n    /* Read in each line and load library */\n    while ((hbaconf != NULL) && (fgets(fullline, sizeof(fullline), hbaconf))) {\n\t/* Skip the comments... */\n\tif ((fullline[0] == '#') || (fullline[0] == '\\n')) {\n\t    continue;\n\t}\n\n\t/* grab first 'thing' in line (if its there)*/\n\tif((libraryname = strtok(fullline, \" \\t\\n\")) != NULL) {\n\t    if(strlen(libraryname) >= 64) {\n\t\tfprintf(stderr, \"Library name(%s) in %s is > 64 characters\\n\",\n\t\t\tlibraryname, hbaConfFilePath);\n\t    }\n\t}\n\t/* grab second 'thing' in line (if its there)*/\n\tif((librarypath = strtok(NULL, \" \\t\\n\")) != NULL) {\n\t    if(strlen(librarypath) >= 256) {\n\t\tfprintf(stderr, \"Library path(%s) in %s is > 256 characters\\n\",\n\t\t\tlibrarypath, hbaConfFilePath);\n\t    }\n\t}\n\n\t/* there should be no more 'things' in the line */\n\tif((charPtr = strtok(NULL, \" \\n\\t\")) != NULL) {\n\t    fprintf(stderr, \"Extraneous characters (\\\"%s\\\") in %s\\n\",\n\t\t    charPtr, hbaConfFilePath);\n\t}\n\n\t/* Continue to the next line if library name or path is invalid */\n\tif (libraryname == NULL ||\n\t    strlen(libraryname) == 0 ||\n\t    librarypath == NULL ||\n\t    (strlen(librarypath) == 0)) {\n\t    continue;\n\t}\n\n\t/* Skip over duplicate library entries */\n\tduplicate = 0;\n\tfor(lib_infop = _hbaapi_librarylist;\n\t    lib_infop != NULL;\n\t    lib_infop = lib_infop->next) {\n\t\tif (strcmp(lib_infop->LibraryName, libraryname) == 0) {\n\t\t\tfprintf(stderr, \"Skipping duplicate entry for Library \"\n\t\t\t\t\"name (%s) in %s\\n\",\n\t\t\t\tlibraryname, hbaConfFilePath);\n\t\t\tduplicate = 1;\n\t\t\tbreak;\n\t\t} else if (strcmp(lib_infop->LibraryPath, librarypath) == 0) {\n\t\t\tfprintf(stderr, \"Skipping duplicate entry for Library \"\n\t\t\t\t\"path (%s) in %s\\n\",\n\t\t\t\tlibrarypath, hbaConfFilePath);\n\t\t\tduplicate = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\t/* Duplicate found move to next */\n\tif (duplicate)\n\t\tcontinue;\n\n\t/*\n\t * Special case....\n\t * Look for loglevel\n\t */\n\tif(strcmp(libraryname, \"debuglevel\") == 0) {\n\t    _hbaapi_debuglevel = strtol(librarypath, NULL, 10);\n\t    /* error handling does the right thing automagically */\n\t    continue;\n\t}\n\n\tlib_infop = (HBA_LIBRARY_INFO *)calloc(1, sizeof(HBA_LIBRARY_INFO));\n\tif(lib_infop == NULL) {\n\t    fprintf(stderr, \"HBA_LoadLibrary: out of memeory\\n\");\n\t    return(HBA_STATUS_ERROR);\n\t}\n\tlib_infop->status = HBA_LIBRARY_NOT_LOADED;\n\tlib_infop->LibraryName = strdup(libraryname);\n\tlib_infop->LibraryPath = strdup(librarypath);\n\tlib_infop->index = _hbaapi_total_library_count;\n\t_hbaapi_total_library_count++;\n\tlib_infop->next = _hbaapi_librarylist;\n\t_hbaapi_librarylist = lib_infop;\n\n\t/* Load the DLL now */\n\tif((lib_infop->hLibrary = dlopen(librarypath,RTLD_LAZY)) == NULL) {\n\t    /*printf(\"unable to load library %s\\n\", librarypath); */\n\t    continue;\n\t}\n\t/* Call the registration function to get the list of pointers */\n\tRegisterV2Func = (HBARegisterLibraryV2Func)\n\t    dlsym(lib_infop->hLibrary, \"HBA_RegisterLibraryV2\");\n\tif (RegisterV2Func != NULL) {\n\t    /* Load the function points directly into\n\t     * the table of functions */\n\t    status = ((RegisterV2Func)(&lib_infop->functionTable));\n\t    if (status != HBA_STATUS_OK) {\n\t\t/* library not loaded */\n\t\tcontinue;\n\t    }\n\t} else {\n\t    /* Maybe the vendor library is only Rev1 */\n\t    RegisterFunc = (HBARegisterLibraryFunc)\n\t\tdlsym(lib_infop->hLibrary, \"HBA_RegisterLibrary\");\n\t    if(RegisterFunc == NULL) {\n\t\t/* This function is required */\n\t\tfprintf(stderr,\n\t\t\t\"HBA_LoadLibrary: vendor specific RegisterLibrary function not found.  lib: %s\\n\", librarypath);\n\t\tDEBUG(0, \"HBA_LoadLibrary: vendor specific RegisterLibrary \"\n\t\t      \"function not found.  lib: %s\\n\", librarypath, 0, 0);\n\t\tcontinue;\n\t    }\n\t    /* Load the function points directly into\n\t     * the table of functions */\n\t    status = ((RegisterFunc)\n\t\t      ((HBA_ENTRYPOINTS *)(&lib_infop->functionTable)));\n\t    if (status != HBA_STATUS_OK) {\n\t\t/* library not loaded */\n\t\tfprintf(stderr,\n\t\t\t\"HBA_LoadLibrary: vendor specific RegisterLibrary \"\n\t\t\t\"function encountered an error.  lib: %s\\n\", librarypath);\n\t\tDEBUG(0, \"HBA_LoadLibrary: vendor specific RegisterLibrary \"\n\t\t      \"function encountered an error. lib: %s\\n\", librarypath, 0, 0);\n\t\tcontinue;\n\t    }\n\t}\n\n\t/* successfully loaded library */\n\tif((GetVersionFunc = lib_infop->functionTable.GetVersionHandler)\n\t   == NULL) {\n\t    continue;\n\t}\n\tlibversion = ((GetVersionFunc)());\n\t/* Check the version of this library before loading */\n\t/* Actually... This wrapper is compatible with version 1 */\n#ifdef NOTDEF /* save for a later time... when it matters */\n\tif(libversion < HBA_LIBVERSION) {\n\t    printf(\"Library version mismatch. Got %d expected %d.\\n\",\n\t\t   libversion, HBA_LIBVERSION);\n\t    continue;\n\t}\n#endif\n\tDEBUG(1, \"%s libversion = %d\", librarypath, libversion, 0);\n\tLoadLibraryFunc = lib_infop->functionTable.LoadLibraryHandler;\n\tif (LoadLibraryFunc == NULL) {\n\t    /* this function is required */\n\t    fprintf(stderr,\n\t\t    \"HBA_LoadLibrary: vendor specific LoadLibrary \"\n\t\t    \"function not found.  lib: %s\\n\", librarypath);\n\t    DEBUG(0, \"HBA_LoadLibrary: vendor specific LoadLibrary \"\n\t\t    \"function not found.  lib: %s\\n\", librarypath, 0, 0);\n\t    continue;\n\t}\n\t/* Initialize this library */\n\tif((status = ((LoadLibraryFunc)())) != HBA_STATUS_OK) {\n\t    /* maybe this should be a printf so that we CANNOT miss it */\n\t    fprintf(stderr,\n\t\t    \"HBA_LoadLibrary: Encounterd and error loading: %s\",\n\t\t    librarypath);\n\t    DEBUG(0, \"Encounterd and error loading: %s\", librarypath, 0, 0);\n\t    DEBUG(0, \"  HBA_STATUS: %d\", status, 0, 0);\n\t    continue;\n\t}\n\t/* successfully loaded library */\n\tlib_infop->status = HBA_LIBRARY_LOADED;\n    }\n\n    fclose(hbaconf);\n\n#ifdef POSIX_THREADS\n    ret = pthread_mutex_init(&_hbaapi_LL_mutex, NULL);\n    if(ret == 0) {\n\tret = pthread_mutex_init(&_hbaapi_AL_mutex, NULL);\n    }\n    if(ret == 0) {\n\tret = pthread_mutex_init(&_hbaapi_AAE_mutex, NULL);\n    }\n    if(ret == 0) {\n\tret = pthread_mutex_init(&_hbaapi_AE_mutex, NULL);\n    }\n    if(ret == 0) {\n\tret = pthread_mutex_init(&_hbaapi_APE_mutex, NULL);\n    }\n    if(ret == 0) {\n\tret = pthread_mutex_init(&_hbaapi_APSE_mutex, NULL);\n    }\n    if(ret == 0) {\n\tret = pthread_mutex_init(&_hbaapi_TE_mutex, NULL);\n    }\n    if(ret == 0) {\n\tret = pthread_mutex_init(&_hbaapi_LE_mutex, NULL);\n    }\n    if(ret != 0) {\n\tperror(\"pthread_mutec_init - HBA_LoadLibrary\");\n\treturn(HBA_STATUS_ERROR);\n    }\n#endif\n\n    /* At least one lib must be loaded */\n    status = HBA_STATUS_ERROR;\n    for(lib_infop = _hbaapi_librarylist; lib_infop != NULL; lib_infop = lib_infop->next) {\n        if (lib_infop->status == HBA_LIBRARY_LOADED) {\n            status = HBA_STATUS_OK;\n            break;\n        }\n    }\n    return status;\n}\n\nHBA_STATUS\nHBA_FreeLibrary() {\n    HBAFreeLibraryFunc\tFreeLibraryFunc;\n    HBA_STATUS\t\tstatus;\n    HBA_LIBRARY_INFO\t*lib_infop;\n    HBA_LIBRARY_INFO\t*lib_next;\n    HBA_ADAPTERCALLBACK_ELEM\n\t\t\t***listp;\n    HBA_ADAPTER_INFO\t*adapt_infop;\n    HBA_ADAPTER_INFO\t*adapt_next;\n\n    ARE_WE_INITED();\n    GRAB_MUTEX(&_hbaapi_LL_mutex);\n    GRAB_MUTEX(&_hbaapi_AL_mutex);\n\n    DEBUG(1, \"HBA_FreeLibrary()\", 0, 0, 0);\n    for(lib_infop = _hbaapi_librarylist; lib_infop != NULL; lib_infop = lib_next) {\n\tlib_next = lib_infop->next;\n\tif (lib_infop->status == HBA_LIBRARY_LOADED) {\n\t    FreeLibraryFunc = lib_infop->functionTable.FreeLibraryHandler;\n\t    if (FreeLibraryFunc != NULL) {\n\t\t/* Free this library */\n\t\tstatus = ((FreeLibraryFunc)());\n\t    }\n\t    dlclose(lib_infop->hLibrary);\t/* Unload DLL from memory */\n\t}\n\tfree(lib_infop->LibraryName);\n\tfree(lib_infop->LibraryPath);\n\tfree(lib_infop);\n\n    }\n    _hbaapi_librarylist = NULL;\n    /* OK, now all functions are disabled except for LoadLibrary,\n     * Hope no other thread calls it before we have returned */\n    _hbaapi_total_library_count = 0;\n\n    for(adapt_infop = _hbaapi_adapterlist;\n\tadapt_infop != NULL;\n\tadapt_infop = adapt_next) {\n\tadapt_next = adapt_infop->next;\n\tfree(adapt_infop->name);\n\tfree(adapt_infop);\n    }\n    _hbaapi_adapterlist = NULL;\n    _hbaapi_total_adapter_count = 0;\n\n    /* Free up the callbacks, this is not the most efficient, but it works */\n    while((volatile HBA_ADAPTERCALLBACK_ELEM *)\n\t  _hbaapi_adapteraddevents_callback_list\n\t  != NULL) {\n\tlocal_remove_callback((HBA_CALLBACKHANDLE)\n\t\t\t   _hbaapi_adapteraddevents_callback_list);\n    }\n    for(listp = cb_lists_array; *listp != NULL; listp++) {\n\twhile((volatile HBA_ADAPTERCALLBACK_ELEM ***)**listp != NULL) {\n\t    local_remove_callback((HBA_CALLBACKHANDLE)**listp);\n\t}\n    }\n\n    RELEASE_MUTEX(&_hbaapi_AL_mutex);\n    RELEASE_MUTEX(&_hbaapi_LL_mutex);\n\n#ifdef USESYSLOG\n    closelog();\n#endif\n#ifdef USELOGFILE\n    if(_hbaapi_debug_fd != NULL) {\n\tfclose(_hbaapi_debug_fd);\n    }\n    _hbaapi_debug_fd = NULL;\n#endif\n#ifdef POSIX_THREADS\n    /* this will unlock them as well, but who cares */\n    pthread_mutex_destroy(&_hbaapi_LE_mutex);\n    pthread_mutex_destroy(&_hbaapi_TE_mutex);\n    pthread_mutex_destroy(&_hbaapi_APSE_mutex);\n    pthread_mutex_destroy(&_hbaapi_APE_mutex);\n    pthread_mutex_destroy(&_hbaapi_AE_mutex);\n    pthread_mutex_destroy(&_hbaapi_AAE_mutex);\n    pthread_mutex_destroy(&_hbaapi_AL_mutex);\n    pthread_mutex_destroy(&_hbaapi_LL_mutex);\n#endif\n\n    return HBA_STATUS_OK;\n}\n\f\n/*\n * The API used to use fixed size tables as its primary data structure.\n * Indexing from 1 to N identified each adapters.  Now the adapters are\n * on a linked list.  There is a unique \"index\" foreach each adapter.\n * Adapters always keep their index, even if they are removed from the\n * hardware.  The only time the indexing is reset is on HBA_FreeLibrary\n */\nHBA_UINT32\nHBA_GetNumberOfAdapters() {\n    int j=0;\n    HBA_LIBRARY_INFO\t*lib_infop;\n    HBAGetNumberOfAdaptersFunc\n\t\t\tGetNumberOfAdaptersFunc;\n    HBAGetAdapterNameFunc\n\t\t\tGetAdapterNameFunc;\n    HBA_BOOLEAN\t\tfound_name;\n    HBA_ADAPTER_INFO\t*adapt_infop;\n    HBA_STATUS\t\tstatus;\n\n    char adaptername[256];\n    int num_adapters; /* local */\n\n    if(_hbaapi_librarylist == NULL) {\n\treturn (0);\n    }\n    GRAB_MUTEX(&_hbaapi_LL_mutex); /* pay attention to order */\n    GRAB_MUTEX(&_hbaapi_AL_mutex);\n\n    for (lib_infop = _hbaapi_librarylist;\n\t lib_infop != NULL;\n\t lib_infop = lib_infop->next) {\n\n\tif (lib_infop->status != HBA_LIBRARY_LOADED) {\n\t    continue;\n\t}\n\n\tGetNumberOfAdaptersFunc =\n\t    lib_infop->functionTable.GetNumberOfAdaptersHandler;\n\tif (GetNumberOfAdaptersFunc == NULL)  {\n\t    continue;\n\t}\n\tnum_adapters = ((GetNumberOfAdaptersFunc)());\n\tDEBUG(1, \"HBAAPI: num_adapters for %s = %d\\n\",\n\t      lib_infop->LibraryName, num_adapters, 0);\n\n\t/* Also get the names of all the adapters here and cache */\n\tGetAdapterNameFunc = lib_infop->functionTable.GetAdapterNameHandler;\n\tif(GetAdapterNameFunc == NULL) {\n\t    continue;\n\t}\n\n\tfor (j = 0; j < num_adapters; j++) {\n\t    found_name = 0;\n\t    status = (GetAdapterNameFunc)(j, (char *)&adaptername);\n\t    if(status == HBA_STATUS_OK) {\n\t\tfor(adapt_infop = _hbaapi_adapterlist;\n\t\t    adapt_infop != NULL;\n\t\t    adapt_infop = adapt_infop->next) {\n\t\t    /*\n\t\t     * check for duplicates, really, this may just be a second\n\t\t     * call to this function\n\t\t     * ??? how do we know when a name becomes stale?\n\t\t     */\n\t\t    if(strcmp(adaptername, adapt_infop->name) == 0) {\n\t\t\t/* already got this one */\n\t\t\tfound_name++;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tif(found_name != 0) {\n\t\t    continue;\n\t\t}\n\t    }\n\n\t    adapt_infop = (HBA_ADAPTER_INFO *)\n\t\tcalloc(1, sizeof(HBA_ADAPTER_INFO));\n\t    if(adapt_infop == NULL) {\n\t\tfprintf(stderr,\n\t\t\t\"HBA_GetNumberOfAdapters: calloc failed on sizeof:%ld\\n\",\n\t\t\tsizeof(HBA_ADAPTER_INFO));\n\t\tRELEASE_MUTEX(&_hbaapi_AL_mutex);\n\t\tRELEASE_MUTEX_RETURN(&_hbaapi_LL_mutex,\n\t\t\t\t     _hbaapi_total_adapter_count);\n\t    }\n\t    if((adapt_infop->GNstatus = status) == HBA_STATUS_OK) {\n\t\tadapt_infop->name = strdup(adaptername);\n\t    } else {\n\t\tchar dummyname[512];\n\t\tsprintf(dummyname, \"NULLADAPTER-%s-%03d\",\n\t\t\tlib_infop->LibraryPath, _hbaapi_total_adapter_count);\n\t\tdummyname[255] = '\\0';\n\t\tadapt_infop->name = strdup(dummyname);\n\t    }\n\t    adapt_infop->library = lib_infop;\n\t    adapt_infop->next = _hbaapi_adapterlist;\n\t    adapt_infop->index = _hbaapi_total_adapter_count;\n\t    _hbaapi_adapterlist = adapt_infop;\n\t    _hbaapi_total_adapter_count++;\n\t}\n    }\n    RELEASE_MUTEX(&_hbaapi_AL_mutex);\n    RELEASE_MUTEX_RETURN(&_hbaapi_LL_mutex, _hbaapi_total_adapter_count);\n}\n\nHBA_STATUS\nHBA_GetAdapterName(\n    HBA_UINT32 adapterindex,\n    char *adaptername)\n{\n    HBA_ADAPTER_INFO\t*adapt_infop;\n    HBA_STATUS\t\tret = HBA_STATUS_ERROR_ILLEGAL_INDEX;\n\n    /*\n     * The adapter index is from old code, but we have\n     * to support it.  Go down the list looking for\n     * the adapter\n     */\n    ARE_WE_INITED();\n    GRAB_MUTEX(&_hbaapi_AL_mutex);\n    *adaptername = '\\0';\n    for(adapt_infop = _hbaapi_adapterlist;\n\tadapt_infop != NULL;\n\tadapt_infop = adapt_infop->next) {\n\n\tif(adapt_infop->index == adapterindex) {\n\t    if(adapt_infop->name != NULL &&\n\t       adapt_infop->GNstatus == HBA_STATUS_OK) {\n\t\tstrcpy(adaptername, adapt_infop->name);\n\t    } else {\n\t\t*adaptername = '\\0';\n\t    }\n\t    ret = adapt_infop->GNstatus;\n\t    break;\n\t}\n    }\n    DEBUG(2, \"GetAdapterName for index:%d ->%s\", adapterindex, adaptername, 0);\n    RELEASE_MUTEX_RETURN(&_hbaapi_AL_mutex, ret);\n}\n\nHBA_HANDLE\nHBA_OpenAdapter(char* adaptername) {\n    HBA_HANDLE\t\thandle;\n    HBAOpenAdapterFunc\tOpenAdapterFunc;\n    HBA_ADAPTER_INFO\t*adapt_infop;\n    HBA_LIBRARY_INFO\t*lib_infop;\n\n    DEBUG(2, \"OpenAdapter: %s\", adaptername, 0, 0);\n\n    if(_hbaapi_librarylist == NULL) {\n\treturn(HBA_HANDLE_INVALID);\n    }\n    handle = HBA_HANDLE_INVALID;\n    GRAB_MUTEX(&_hbaapi_AL_mutex);\n    for(adapt_infop = _hbaapi_adapterlist;\n\tadapt_infop != NULL;\n\tadapt_infop = adapt_infop->next) {\n\tif (strcmp(adaptername, adapt_infop->name) != 0) {\n\t    continue;\n\t}\n\tlib_infop = adapt_infop->library;\n\tOpenAdapterFunc =\n\t    lib_infop->functionTable.OpenAdapterHandler;\n\tif (OpenAdapterFunc != NULL) {\n\t    /* retrieve the vendor handle */\n\t    handle = (OpenAdapterFunc)(adaptername);\n\t    if(handle != 0) {\n\t\t/* or this with the library index to get the common handle */\n\t\thandle = HBA_HANDLE_FROM_LOCAL(lib_infop->index, handle);\n\t    }\n\t}\n\tbreak;\n    }\n    RELEASE_MUTEX_RETURN(&_hbaapi_AL_mutex, handle);\n}\n/*\n * This function ignores the list of known adapters and instead tries\n * each vendors open function to see if one of them\n * can open an adapter when referenced with a particular WWN\n */\nHBA_STATUS\nHBA_OpenAdapterByWWN(HBA_HANDLE *phandle, HBA_WWN nodeWWN) {\n    HBA_HANDLE\t\thandle;\n    HBA_LIBRARY_INFO\t*lib_infop;\n    HBAGetNumberOfAdaptersFunc\n\t\t\tGetNumberOfAdaptersFunc;\n    HBAOpenAdapterByWWNFunc\n\t\t\tOpenAdapterFunc;\n    HBA_STATUS\t\tstatus;\n\n    DEBUG(2, \"OpenAdapterByWWN: %s\", WWN2STR1(&nodeWWN), 0, 0);\n    ARE_WE_INITED();\n\n    *phandle = HBA_HANDLE_INVALID;\n\n    GRAB_MUTEX(&_hbaapi_LL_mutex);\n    for (lib_infop = _hbaapi_librarylist;\n\t lib_infop != NULL;\n\t lib_infop = lib_infop->next) {\n\n\tstatus = HBA_STATUS_ERROR_ILLEGAL_WWN;\n\n\tif (lib_infop->status != HBA_LIBRARY_LOADED) {\n\t    continue;\n\t}\n\n\tGetNumberOfAdaptersFunc =\n\t    lib_infop->functionTable.GetNumberOfAdaptersHandler;\n\tif (GetNumberOfAdaptersFunc == NULL)  {\n\t    continue;\n\t}\n\n\t/* look for new hardware */\n\t(void) ((GetNumberOfAdaptersFunc)());\n\n\tOpenAdapterFunc = lib_infop->functionTable.OpenAdapterByWWNHandler;\n\tif (OpenAdapterFunc == NULL) {\n\t    continue;\n\t}\n\t/*\n\t * We do not know if the WWN is known by this vendor,\n\t * just try it\n\t */\n\tif((status = (OpenAdapterFunc)(&handle, nodeWWN)) != HBA_STATUS_OK) {\n\t    continue;\n\t}\n\t/* OK, make a vendor non-specific handle */\n\t*phandle = HBA_HANDLE_FROM_LOCAL(lib_infop->index, handle);\n\tstatus = HBA_STATUS_OK;\n\tbreak;\n    }\n    RELEASE_MUTEX_RETURN(&_hbaapi_LL_mutex, status);\n}\n\f\nvoid\nHBA_RefreshAdapterConfiguration() {\n    DEBUG(2, \"HBA_RefreshAdapterConfiguration\", 0, 0, 0);\n    (void)HBA_GetNumberOfAdapters();\n    return;\n}\n\nHBA_UINT32\nHBA_GetVersion() {\n    DEBUG(2, \"HBA_GetVersion\", 0, 0, 0);\n    return HBA_LIBVERSION;\n}\n\n/*\n * This function is VERY OS dependent.  Wing it as best you can.\n */\nHBA_UINT32\nHBA_GetWrapperLibraryAttributes (\n    HBA_LIBRARYATTRIBUTES *attributes)\n{\n\n    DEBUG(2, \"HBA_GetWrapperLibraryAttributes\", 0, 0, 0);\n\n    memset(attributes, 0, sizeof(HBA_LIBRARYATTRIBUTES));\n\n#if defined(SOLARIS)\n    if((handle = dlopen(\"libHBAAPI.so\", RTLD_NOW)) != NULL) {\n\tif(dlinfo(handle, RTLD_DI_LINKMAP, &map) >= 0) {\n\t    for(mp = map; mp != NULL; mp = mp->l_next) {\n\t\tif(strlen(map->l_name) < 256) {\n\t\t    strcpy(attributes->LibPath, map->l_lname);\n\t\t}\n\t    }\n\t}\n    }\n#endif\n#if defined(VENDOR)\n    strcpy(attributes->VName, VENDOR);\n#else\n    attributes->VName[0] = '\\0';\n#endif\n#if defined(VERSION)\n    strcpy(attributes->VVersion, VERSION);\n#else\n    attributes->VVersion[0] = '\\0';\n#endif\n#if defined(BUILD_DATE)\n    if(strptime(BUILD_DATE, \"%Y/%m/%d %T %Z\", &(attributes->build_date)) == NULL) {\n\tmemset(&attributes->build_date, 0, sizeof(struct tm));\n    }\n#else\n    memset(&attributes->build_date, 0, sizeof(struct tm));\n#endif\n    return 2;\n}\n\f\n/*\n * Callback registation and handling\n */\nHBA_STATUS\nHBA_RemoveCallback (HBA_CALLBACKHANDLE cbhandle) {\n    HBA_STATUS\tstatus;\n\n    DEBUG(2, \"HBA_RemoveCallback\", 0, 0, 0);\n    ARE_WE_INITED();\n\n    GRAB_MUTEX(&_hbaapi_LL_mutex);\n    status = local_remove_callback(cbhandle);\n    RELEASE_MUTEX_RETURN(&_hbaapi_LL_mutex, status);\n}\n\n/* Adapter Add Events *********************************************************/\nstatic void\nadapteraddevents_callback (void *data, HBA_WWN PortWWN, HBA_UINT32 eventType) {\n    HBA_ALLADAPTERSCALLBACK_ELEM\t*cbp;\n\n    DEBUG(3, \"AddAdapterEvent, port:%s\", WWN2STR1(&PortWWN), 0, 0);\n\n    GRAB_MUTEX(&_hbaapi_AAE_mutex);\n    for(cbp = _hbaapi_adapteraddevents_callback_list;\n\tcbp != NULL;\n\tcbp = cbp->next) {\n\t(*cbp->callback)(data, PortWWN, HBA_EVENT_ADAPTER_ADD);\n    }\n    RELEASE_MUTEX(&_hbaapi_AAE_mutex);\n\n}\nHBA_STATUS\nHBA_RegisterForAdapterAddEvents (\n    void\t\t(*callback) (\n\tvoid\t\t*data,\n\tHBA_WWN\t\tPortWWN,\n\tHBA_UINT32\teventType\n\t),\n    void\t\t*userData,\n    HBA_CALLBACKHANDLE *callbackHandle) {\n\n    HBA_ALLADAPTERSCALLBACK_ELEM\t*cbp;\n    HBA_VENDORCALLBACK_ELEM\t\t*vcbp;\n    HBA_VENDORCALLBACK_ELEM\t\t*vendorhandlelist;\n    HBARegisterForAdapterAddEventsFunc\tregisteredfunc;\n    HBA_STATUS\t\t\t\tstatus = HBA_STATUS_OK;\n    HBA_STATUS\t\t\t\tfailure = HBA_STATUS_OK;\n    HBA_LIBRARY_INFO\t\t\t*lib_infop;\n    int\t\t\t\t\tregistered_cnt = 0;\n    int\t\t\t\t\tvendor_cnt = 0;\n    int\t\t\t\t\tnot_supported_cnt = 0;\n    int\t\t\t\t\tstatus_OK_bar_cnt = 0;\n    int\t\t\t\t\tstatus_OK_cnt = 0;\n\n    DEBUG(2, \"HBA_RegisterForAdapterAddEvents\", 0, 0, 0);\n    ARE_WE_INITED();\n\n    cbp = (HBA_ALLADAPTERSCALLBACK_ELEM *)\n\tcalloc(1, sizeof(HBA_ALLADAPTERSCALLBACK_ELEM));\n    *callbackHandle = (HBA_CALLBACKHANDLE) cbp;\n    if(cbp == NULL) {\n\tfprintf(stderr,\n\t\t\"HBA_RegisterForAdapterAddEvents: calloc failed for %ld bytes\\n\",\n\t\tsizeof(HBA_ALLADAPTERSCALLBACK_ELEM));\n\treturn HBA_STATUS_ERROR;\n    }\n\n    GRAB_MUTEX(&_hbaapi_LL_mutex);\n    GRAB_MUTEX(&_hbaapi_AAE_mutex);\n    cbp->callback = callback;\n    cbp->next = _hbaapi_adapteraddevents_callback_list;\n    _hbaapi_adapteraddevents_callback_list = cbp;\n    /* Need to release the mutex now incase the vendor function invokes the\n     * callback.  We will grap the mutex later to attach the vendor handle list\n     * to the callback structure */\n    RELEASE_MUTEX(&_hbaapi_AAE_mutex);\n\n\n    /*\n     * now create a list of vendors (vendor libraryies, NOT ADAPTERS) that have\n     * successfully registerred\n     */\n    vendorhandlelist = NULL;\n    for(lib_infop = _hbaapi_librarylist;\n\tlib_infop != NULL;\n\tlib_infop = lib_infop->next) {\n\n\tvendor_cnt++;\n\n\tregisteredfunc =\n\t    lib_infop->functionTable.RegisterForAdapterAddEventsHandler;\n\tif(registeredfunc == NULL) {\n\t    continue;\n\t}\n\n\tvcbp = (HBA_VENDORCALLBACK_ELEM *)\n\t    calloc(1, sizeof(HBA_VENDORCALLBACK_ELEM));\n\tif(vcbp == NULL) {\n\t    fprintf(stderr,\n\t\t    \"HBA_RegisterForAdapterAddEvents: \"\n\t\t    \"calloc failed for %ld bytes\\n\",\n\t\t    sizeof(HBA_VENDORCALLBACK_ELEM));\n\t    freevendorhandlelist(vendorhandlelist);\n\t    status = HBA_STATUS_ERROR;\n\t    break;\n\t}\n\n\tregistered_cnt++;\n\tstatus = (registeredfunc)(adapteraddevents_callback,\n\t\t\t\t  userData, &vcbp->vendorcbhandle);\n\tif(status == HBA_STATUS_ERROR_NOT_SUPPORTED) {\n\t    not_supported_cnt++;\n\t    free(vcbp);\n\t    continue;\n\t} else if (status != HBA_STATUS_OK) {\n\t    status_OK_bar_cnt++;\n\t    DEBUG(0,\n\t\t  \"HBA_RegisterForAdapterAddEvents: Library->%s, Error->%d\",\n\t\t  lib_infop->LibraryPath, status, 0);\n\t    fprintf(stderr,\n\t\t    \"HBA_RegisterForAdapterAddEvents: Library->%s, Error->%d\",\n\t\t    lib_infop->LibraryPath, status);\n\t    failure = status;\n\t    free(vcbp);\n\t    continue;\n\t} else {\n\t    status_OK_cnt++;\n\t}\n\tvcbp->lib_info = lib_infop;\n\tvcbp->next = vendorhandlelist;\n\tvendorhandlelist = vcbp;\n    }\n    if(registered_cnt == 0) {\n\tstatus = HBA_STATUS_ERROR_NOT_SUPPORTED;\n\tfreevendorhandlelist(vendorhandlelist);\n\tlocal_remove_callback((HBA_CALLBACKHANDLE) cbp);\n    } else if (status_OK_cnt == 0 && not_supported_cnt != 0) {\n\tstatus = HBA_STATUS_ERROR_NOT_SUPPORTED;\n    } else if (status_OK_cnt == 0) {\n\t/* At least one vendor library registered this function, but no\n\t * vendor call succeeded */\n\tlocal_remove_callback((HBA_CALLBACKHANDLE) cbp);\n\tstatus = failure;\n    } else {\n\t/* we have had atleast some success, now finish up */\n\tGRAB_MUTEX(&_hbaapi_AAE_mutex);\n\t/* this seems silly, but what if another thread called\n\t * the callback remove */\n\tfor(cbp = _hbaapi_adapteraddevents_callback_list;\n\t    cbp != NULL; cbp = cbp->next) {\n\t    if((HBA_CALLBACKHANDLE)cbp == *callbackHandle) {\n\t\t/* yup, its still there, hooray */\n\t\tcbp->vendorhandlelist = vendorhandlelist;\n\t\tvendorhandlelist = NULL;\n\t\tbreak;\n\t    }\n\t}\n\tRELEASE_MUTEX(&_hbaapi_AAE_mutex);\n\tif(vendorhandlelist != NULL) {\n\t    /* bummer, somebody removed the callback before we finished\n\t     * registration, probably will never happen */\n\t    freevendorhandlelist(vendorhandlelist);\n\t    DEBUG(0,\n\t\t  \"HBA_RegisterForAdapterAddEvents: HBA_RemoveCallback was \"\n\t\t  \"called for a handle before registration was finished.\",\n\t\t  0, 0, 0);\n\t    status = HBA_STATUS_ERROR;\n\t} else {\n\t    status = HBA_STATUS_OK;\n\t}\n    }\n    RELEASE_MUTEX_RETURN(&_hbaapi_LL_mutex, status);\n}\n\n/* Adapter Events (other than add) ********************************************/\nstatic void\nadapterevents_callback (void *data,\n\t\t\tHBA_WWN PortWWN,\n\t\t\tHBA_UINT32 eventType) {\n    HBA_ADAPTERCALLBACK_ELEM\t*acbp;\n\n    DEBUG(3, \"AdapterEvent, port:%s, eventType:%d\", WWN2STR1(&PortWWN),\n\t  eventType, 0);\n\n    GRAB_MUTEX(&_hbaapi_AE_mutex);\n    for(acbp = _hbaapi_adapterevents_callback_list;\n\tacbp != NULL;\n\tacbp = acbp->next) {\n\tif(data == (void *)acbp) {\n\t    (*acbp->callback)(acbp->userdata, PortWWN, eventType);\n\t    break;\n\t}\n    }\n    RELEASE_MUTEX(&_hbaapi_AE_mutex);\n}\nHBA_STATUS\nHBA_RegisterForAdapterEvents (\n    void\t\t(*callback) (\n\tvoid\t\t*data,\n\tHBA_WWN\t\tPortWWN,\n\tHBA_UINT32\teventType\n\t),\n    void\t\t*userData,\n    HBA_HANDLE\t\thandle,\n    HBA_CALLBACKHANDLE\t*callbackHandle) {\n\n    HBA_ADAPTERCALLBACK_ELEM\t\t*acbp;\n    HBARegisterForAdapterEventsFunc\tregisteredfunc;\n    HBA_STATUS\t\t\t\tstatus;\n    HBA_LIBRARY_INFO\t\t\t*lib_infop;\n    HBA_HANDLE\t\t\t\tvendorHandle;\n\n    DEBUG(2, \"HBA_RegisterForAdapterEvents\", 0, 0, 0);\n\n    CHECKLIBRARY();\n\n    /* we now have the _hbaapi_LL_mutex */\n\n    registeredfunc = lib_infop->functionTable.RegisterForAdapterEventsHandler;\n    if(registeredfunc == NULL) {\n\tRELEASE_MUTEX_RETURN(&_hbaapi_LL_mutex, HBA_STATUS_ERROR_NOT_SUPPORTED);\n    }\n\n    /*\n     * that allocated memory is used both as the handle for the\n     * caller, and as userdata to the vendor call so that on\n     * callback the specific registration may be recalled\n     */\n    acbp = (HBA_ADAPTERCALLBACK_ELEM *)\n\tcalloc(1, sizeof(HBA_ADAPTERCALLBACK_ELEM));\n    if(acbp == NULL) {\n\tfprintf(stderr,\n\t\t\"HBA_RegisterForAdapterEvents: calloc failed for %ld bytes\\n\",\n\t\tsizeof(HBA_ADAPTERCALLBACK_ELEM));\n\tRELEASE_MUTEX_RETURN(&_hbaapi_LL_mutex, HBA_STATUS_ERROR);\n    }\n    *callbackHandle = (HBA_CALLBACKHANDLE) acbp;\n    acbp->callback = callback;\n    acbp->userdata = userData;\n    acbp->lib_info = lib_infop;\n\n    status = (registeredfunc)(adapterevents_callback,\n\t\t\t      (void *)acbp,\n\t\t\t      vendorHandle,\n\t\t\t      &acbp->vendorcbhandle);\n    if(status != HBA_STATUS_OK) {\n\tfree(acbp);\n\tRELEASE_MUTEX_RETURN(&_hbaapi_LL_mutex, status);\n    }\n\n    GRAB_MUTEX(&_hbaapi_AE_mutex);\n    acbp->next = _hbaapi_adapterevents_callback_list;\n    _hbaapi_adapterevents_callback_list = acbp;\n    RELEASE_MUTEX(&_hbaapi_AE_mutex);\n\n    RELEASE_MUTEX_RETURN(&_hbaapi_LL_mutex, HBA_STATUS_OK);\n}\n\n/* Adapter Port Events ********************************************************/\nstatic void\nadapterportevents_callback (void *data,\n\t\t\t    HBA_WWN PortWWN,\n\t\t\t    HBA_UINT32 eventType,\n\t\t\t    HBA_UINT32 fabricPortID) {\n    HBA_ADAPTERCALLBACK_ELEM\t*acbp;\n\n    DEBUG(3, \"AdapterPortEvent, port:%s, eventType:%d fabricPortID:0X%06x\",\n\t  WWN2STR1(&PortWWN), eventType, fabricPortID);\n\n    GRAB_MUTEX(&_hbaapi_APE_mutex);\n\n    for(acbp = _hbaapi_adapterportevents_callback_list;\n\tacbp != NULL;\n\tacbp = acbp->next) {\n\tif(data == (void *)acbp) {\n\t    (*acbp->callback)(acbp->userdata, PortWWN, eventType, fabricPortID);\n\t    break;\n\t}\n    }\n    RELEASE_MUTEX(&_hbaapi_APE_mutex);\n}\nHBA_STATUS\nHBA_RegisterForAdapterPortEvents (\n    void\t\t(*callback) (\n\tvoid\t\t*data,\n\tHBA_WWN\t\tPortWWN,\n\tHBA_UINT32\teventType,\n\tHBA_UINT32\tfabricPortID\n\t),\n    void\t\t*userData,\n    HBA_HANDLE\t\thandle,\n    HBA_WWN\t\tPortWWN,\n    HBA_CALLBACKHANDLE\t*callbackHandle) {\n\n    HBA_ADAPTERCALLBACK_ELEM\t\t*acbp;\n    HBARegisterForAdapterPortEventsFunc\tregisteredfunc;\n    HBA_STATUS\t\t\t\tstatus;\n    HBA_LIBRARY_INFO\t\t\t*lib_infop;\n    HBA_HANDLE\t\t\t\tvendorHandle;\n\n    DEBUG(2, \"HBA_RegisterForAdapterPortEvents for port: %s\",\n\t  WWN2STR1(&PortWWN), 0, 0);\n\n    CHECKLIBRARY();\n    /* we now have the _hbaapi_LL_mutex */\n\n    registeredfunc =\n\tlib_infop->functionTable.RegisterForAdapterPortEventsHandler;\n    if(registeredfunc == NULL) {\n\tRELEASE_MUTEX_RETURN(&_hbaapi_LL_mutex, HBA_STATUS_ERROR_NOT_SUPPORTED);\n    }\n\n    /*\n     * that allocated memory is used both as the handle for the\n     * caller, and as userdata to the vendor call so that on\n     * callback the specific registration may be recalled\n     */\n    acbp = (HBA_ADAPTERCALLBACK_ELEM *)\n\tcalloc(1, sizeof(HBA_ADAPTERCALLBACK_ELEM));\n    if(acbp == NULL) {\n\tfprintf(stderr,\n\t\t\"HBA_RegisterForAdapterPortEvents: \"\n\t\t\"calloc failed for %ld bytes\\n\",\n\t\tsizeof(HBA_ADAPTERCALLBACK_ELEM));\n\tRELEASE_MUTEX_RETURN(&_hbaapi_LL_mutex, HBA_STATUS_ERROR);\n\n    }\n    *callbackHandle = (HBA_CALLBACKHANDLE) acbp;\n    acbp->callback = callback;\n    acbp->userdata = userData;\n    acbp->lib_info = lib_infop;\n\n    status = (registeredfunc)(adapterportevents_callback,\n\t\t\t      (void *)acbp,\n\t\t\t      vendorHandle,\n\t\t\t      PortWWN,\n\t\t\t      &acbp->vendorcbhandle);\n    if(status != HBA_STATUS_OK) {\n\tfree(acbp);\n\tRELEASE_MUTEX_RETURN(&_hbaapi_LL_mutex, status);\n    }\n\n    GRAB_MUTEX(&_hbaapi_APE_mutex);\n    acbp->next = _hbaapi_adapterportevents_callback_list;\n    _hbaapi_adapterportevents_callback_list = acbp;\n    RELEASE_MUTEX(&_hbaapi_APE_mutex);\n\n    RELEASE_MUTEX_RETURN(&_hbaapi_LL_mutex, HBA_STATUS_OK);\n}\n\n/* Adapter State Events *******************************************************/\nstatic void\nadapterportstatevents_callback (void *data,\n\t\t\t\tHBA_WWN PortWWN,\n\t\t\t\tHBA_UINT32 eventType) {\n    HBA_ADAPTERCALLBACK_ELEM\t*acbp;\n\n    DEBUG(3, \"AdapterPortStateEvent, port:%s, eventType:%d\", WWN2STR1(&PortWWN),\n\t  eventType, 0);\n\n    GRAB_MUTEX(&_hbaapi_APSE_mutex);\n    for(acbp = _hbaapi_adapterportstatevents_callback_list;\n\tacbp != NULL;\n\tacbp = acbp->next) {\n\tif(data == (void *)acbp) {\n\t    (*acbp->callback)(acbp->userdata, PortWWN, eventType);\n\t    return;\n\t}\n    }\n}\nHBA_STATUS\nHBA_RegisterForAdapterPortStatEvents (\n    void\t\t(*callback) (\n\tvoid\t\t*data,\n\tHBA_WWN\t\tPortWWN,\n\tHBA_UINT32\teventType\n\t),\n    void\t\t*userData,\n    HBA_HANDLE\t\thandle,\n    HBA_WWN\t\tPortWWN,\n    HBA_PORTSTATISTICS\tstats,\n    HBA_UINT32\t\tstatType,\n    HBA_CALLBACKHANDLE\t*callbackHandle) {\n\n    HBA_ADAPTERCALLBACK_ELEM\t*acbp;\n    HBARegisterForAdapterPortStatEventsFunc\n\t\t\t\tregisteredfunc;\n    HBA_STATUS\t\t\tstatus;\n    HBA_LIBRARY_INFO\t\t*lib_infop;\n    HBA_HANDLE\t\t\tvendorHandle;\n\n    DEBUG(2, \"HBA_RegisterForAdapterPortStatEvents for port: %s\",\n\t  WWN2STR1(&PortWWN), 0, 0);\n\n    CHECKLIBRARY();\n    /* we now have the _hbaapi_LL_mutex */\n\n    registeredfunc =\n\tlib_infop->functionTable.RegisterForAdapterPortStatEventsHandler;\n    if(registeredfunc == NULL) {\n\tRELEASE_MUTEX_RETURN(&_hbaapi_LL_mutex, HBA_STATUS_ERROR_NOT_SUPPORTED);\n    }\n\n    /*\n     * that allocated memory is used both as the handle for the\n     * caller, and as userdata to the vendor call so that on\n     * callback the specific registration may be recalled\n     */\n    acbp = (HBA_ADAPTERCALLBACK_ELEM *)\n\tcalloc(1, sizeof(HBA_ADAPTERCALLBACK_ELEM));\n    if(acbp == NULL) {\n\tfprintf(stderr,\n\t\t\"HBA_RegisterForAdapterPortStatEvents: \"\n\t\t\"calloc failed for %ld bytes\\n\",\n\t\tsizeof(HBA_ADAPTERCALLBACK_ELEM));\n\tRELEASE_MUTEX_RETURN(&_hbaapi_LL_mutex, HBA_STATUS_ERROR);\n    }\n    *callbackHandle = (HBA_CALLBACKHANDLE) acbp;\n    acbp->callback = callback;\n    acbp->userdata = userData;\n    acbp->lib_info = lib_infop;\n\n    status = (registeredfunc)(adapterportstatevents_callback,\n\t\t\t      (void *)acbp,\n\t\t\t      vendorHandle,\n\t\t\t      PortWWN,\n\t\t\t      stats,\n\t\t\t      statType,\n\t\t\t      &acbp->vendorcbhandle);\n    if(status != HBA_STATUS_OK) {\n\tfree(acbp);\n\tRELEASE_MUTEX_RETURN(&_hbaapi_LL_mutex, status);\n    }\n\n    GRAB_MUTEX(&_hbaapi_APSE_mutex);\n    acbp->next = _hbaapi_adapterportstatevents_callback_list;\n    _hbaapi_adapterportstatevents_callback_list = acbp;\n    RELEASE_MUTEX(&_hbaapi_APSE_mutex);\n\n    RELEASE_MUTEX_RETURN(&_hbaapi_LL_mutex, HBA_STATUS_OK);\n}\n\n/* Target Events **************************************************************/\nstatic void\ntargetevents_callback (void *data,\n\t\t       HBA_WWN hbaPortWWN,\n\t\t       HBA_WWN discoveredPortWWN,\n\t\t       HBA_UINT32 eventType) {\n    HBA_ADAPTERCALLBACK_ELEM\t*acbp;\n\n    DEBUG(3, \"TargetEvent, hbaPort:%s, discoveredPort:%s eventType:%d\",\n\t  WWN2STR1(&hbaPortWWN), WWN2STR2(&discoveredPortWWN), eventType);\n\n    GRAB_MUTEX(&_hbaapi_TE_mutex);\n    for(acbp = _hbaapi_targetevents_callback_list;\n\tacbp != NULL;\n\tacbp = acbp->next) {\n\tif(data == (void *)acbp) {\n\t    (*acbp->callback)(acbp->userdata, hbaPortWWN,\n\t\t\t      discoveredPortWWN, eventType);\n\t    break;\n\t}\n    }\n    RELEASE_MUTEX(&_hbaapi_TE_mutex);\n}\nHBA_STATUS\nHBA_RegisterForTargetEvents (\n    void\t\t(*callback) (\n\tvoid\t\t*data,\n\tHBA_WWN\t\thbaPortWWN,\n\tHBA_WWN\t\tdiscoveredPortWWN,\n\tHBA_UINT32\teventType\n\t),\n    void\t\t*userData,\n    HBA_HANDLE\t\thandle,\n    HBA_WWN\t\thbaPortWWN,\n    HBA_WWN\t\tdiscoveredPortWWN,\n    HBA_CALLBACKHANDLE\t*callbackHandle,\n    HBA_UINT32\t\tallTargets) {\n\n    HBA_ADAPTERCALLBACK_ELEM\n\t\t\t*acbp;\n    HBARegisterForTargetEventsFunc\n\t\t\tregisteredfunc;\n    HBA_STATUS\t\tstatus;\n    HBA_LIBRARY_INFO\t*lib_infop;\n    HBA_HANDLE\t\tvendorHandle;\n\n    DEBUG(2, \"HBA_RegisterForTargetEvents, hbaPort: %s, discoveredPort: %s\",\n\t  WWN2STR1(&hbaPortWWN), WWN2STR2(&discoveredPortWWN), 0);\n\n    CHECKLIBRARY();\n    /* we now have the _hbaapi_LL_mutex */\n\n    registeredfunc = lib_infop->functionTable.RegisterForTargetEventsHandler;\n    if(registeredfunc == NULL) {\n\tRELEASE_MUTEX_RETURN(&_hbaapi_LL_mutex, HBA_STATUS_ERROR_NOT_SUPPORTED);\n    }\n\n    /*\n     * that allocated memory is used both as the handle for the\n     * caller, and as userdata to the vendor call so that on\n     * callback the specific registration may be recalled\n     */\n    acbp = (HBA_ADAPTERCALLBACK_ELEM *)\n\tcalloc(1, sizeof(HBA_ADAPTERCALLBACK_ELEM));\n    if(acbp == NULL) {\n\tfprintf(stderr,\n\t\t\"HBA_RegisterForTargetEvents: calloc failed for %ld bytes\\n\",\n\t\tsizeof(HBA_ADAPTERCALLBACK_ELEM));\n\tRELEASE_MUTEX_RETURN(&_hbaapi_LL_mutex, HBA_STATUS_ERROR);\n    }\n    *callbackHandle = (HBA_CALLBACKHANDLE) acbp;\n    acbp->callback = callback;\n    acbp->userdata = userData;\n    acbp->lib_info = lib_infop;\n\n    status = (registeredfunc)(targetevents_callback,\n\t\t\t      (void *)acbp,\n\t\t\t      vendorHandle,\n\t\t\t      hbaPortWWN,\n\t\t\t      discoveredPortWWN,\n\t\t\t      &acbp->vendorcbhandle,\n\t\t\t      allTargets);\n    if(status != HBA_STATUS_OK) {\n\tfree(acbp);\n\tRELEASE_MUTEX_RETURN(&_hbaapi_LL_mutex, status);\n    }\n\n    GRAB_MUTEX(&_hbaapi_TE_mutex);\n    acbp->next = _hbaapi_targetevents_callback_list;\n    _hbaapi_targetevents_callback_list = acbp;\n    RELEASE_MUTEX(&_hbaapi_TE_mutex);\n\n    RELEASE_MUTEX_RETURN(&_hbaapi_LL_mutex, HBA_STATUS_OK);\n}\n\n/* Link Events ****************************************************************/\nstatic void\nlinkevents_callback (void *data,\n\t\t     HBA_WWN adapterWWN,\n\t\t     HBA_UINT32 eventType,\n\t\t     void *pRLIRBuffer,\n\t\t     HBA_UINT32 RLIRBufferSize) {\n    HBA_ADAPTERCALLBACK_ELEM\t*acbp;\n\n    DEBUG(3, \"LinkEvent, hbaWWN:%s, eventType:%d\",\n\t  WWN2STR1(&adapterWWN), eventType, 0);\n\n    GRAB_MUTEX(&_hbaapi_LE_mutex);\n    for(acbp = _hbaapi_linkevents_callback_list;\n\tacbp != NULL;\n\tacbp = acbp->next) {\n\tif(data == (void *)acbp) {\n\t    (*acbp->callback)(acbp->userdata, adapterWWN,\n\t\t\t      eventType, pRLIRBuffer, RLIRBufferSize);\n\t    break;\n\t}\n    }\n    RELEASE_MUTEX(&_hbaapi_LE_mutex);\n}\nHBA_STATUS\nHBA_RegisterForLinkEvents (\n    void\t\t(*callback) (\n\tvoid\t\t*data,\n\tHBA_WWN\t\tadapterWWN,\n\tHBA_UINT32\teventType,\n\tvoid\t\t*pRLIRBuffer,\n\tHBA_UINT32\tRLIRBufferSize),\n    void\t\t*userData,\n    void\t\t*pRLIRBuffer,\n    HBA_UINT32\t\tRLIRBufferSize,\n    HBA_HANDLE\t\thandle,\n    HBA_CALLBACKHANDLE\t*callbackHandle) {\n\n    HBA_ADAPTERCALLBACK_ELEM\t*acbp;\n    HBARegisterForLinkEventsFunc\n\t\t\t\tregisteredfunc;\n    HBA_STATUS\t\t\tstatus;\n    HBA_LIBRARY_INFO\t\t*lib_infop;\n    HBA_HANDLE\t\t\tvendorHandle;\n\n    DEBUG(2, \"HBA_RegisterForLinkEvents\", 0, 0, 0);\n\n    CHECKLIBRARY();\n    /* we now have the _hbaapi_LL_mutex */\n\n    registeredfunc = lib_infop->functionTable.RegisterForLinkEventsHandler;\n    if(registeredfunc == NULL) {\n\tRELEASE_MUTEX_RETURN(&_hbaapi_LL_mutex, HBA_STATUS_ERROR_NOT_SUPPORTED);\n    }\n\n    /*\n     * that allocated memory is used both as the handle for the\n     * caller, and as userdata to the vendor call so that on\n     * callback the specific registration may be recalled\n     */\n    acbp = (HBA_ADAPTERCALLBACK_ELEM *)\n\tcalloc(1, sizeof(HBA_ADAPTERCALLBACK_ELEM));\n    if(acbp == NULL) {\n\tfprintf(stderr,\n\t\t\"HBA_RegisterForLinkEvents: calloc failed for %ld bytes\\n\",\n\t\tsizeof(HBA_ADAPTERCALLBACK_ELEM));\n\tRELEASE_MUTEX_RETURN(&_hbaapi_LL_mutex, HBA_STATUS_ERROR);\n    }\n    *callbackHandle = (HBA_CALLBACKHANDLE) acbp;\n    acbp->callback = callback;\n    acbp->userdata = userData;\n    acbp->lib_info = lib_infop;\n\n    status = (registeredfunc)(linkevents_callback,\n\t\t\t      (void *)acbp,\n\t\t\t      pRLIRBuffer,\n\t\t\t      RLIRBufferSize,\n\t\t\t      vendorHandle,\n\t\t\t      &acbp->vendorcbhandle);\n    if(status != HBA_STATUS_OK) {\n\tfree(acbp);\n\tRELEASE_MUTEX_RETURN(&_hbaapi_LL_mutex, status);\n    }\n\n    GRAB_MUTEX(&_hbaapi_LE_mutex);\n    acbp->next = _hbaapi_linkevents_callback_list;\n    _hbaapi_linkevents_callback_list = acbp;\n    RELEASE_MUTEX(&_hbaapi_LE_mutex);\n\n    RELEASE_MUTEX_RETURN(&_hbaapi_LL_mutex, HBA_STATUS_OK);\n}\n\n\f\n/*\n * All of the functions below are almost passthru functions to the\n * vendor specific function\n */\n\nvoid\nHBA_CloseAdapter(HBA_HANDLE handle) {\n    HBA_STATUS\t\tstatus;\n    HBA_LIBRARY_INFO\t*lib_infop;\n    HBA_HANDLE\t\tvendorHandle;\n    HBACloseAdapterFunc CloseAdapterFunc;\n\n    DEBUG(2, \"HBA_CloseAdapter\", 0, 0, 0);\n\n    status = HBA_CheckLibrary(handle, &lib_infop, &vendorHandle);\n    if (status == HBA_STATUS_OK) {\n\tCloseAdapterFunc = lib_infop->functionTable.CloseAdapterHandler;\n\tif (CloseAdapterFunc != NULL) {\n\t    ((CloseAdapterFunc)(vendorHandle));\n\t}\n\tRELEASE_MUTEX(&_hbaapi_LL_mutex);\n    }\n}\n\nHBA_STATUS\nHBA_GetAdapterAttributes (\n    HBA_HANDLE\t\thandle,\n    HBA_ADAPTERATTRIBUTES\n\t\t\t*hbaattributes)\n{\n    HBA_STATUS\t\tstatus;\n    HBA_LIBRARY_INFO\t*lib_infop;\n    HBA_HANDLE\t\tvendorHandle;\n    HBAGetAdapterAttributesFunc GetAdapterAttributesFunc;\n\n    DEBUG(2, \"HBA_GetAdapterAttributes\", 0, 0, 0);\n\n    CHECKLIBRARY();\n    GetAdapterAttributesFunc =\n\tlib_infop->functionTable.GetAdapterAttributesHandler;\n    if (GetAdapterAttributesFunc != NULL) {\n\tstatus = ((GetAdapterAttributesFunc)(vendorHandle, hbaattributes));\n    } else {\n\tstatus = HBA_STATUS_ERROR_NOT_SUPPORTED;\n    }\n    RELEASE_MUTEX_RETURN(&_hbaapi_LL_mutex, status);\n}\n\nHBA_STATUS\nHBA_GetAdapterPortAttributes (\n    HBA_HANDLE\t\thandle,\n    HBA_UINT32\t\tportindex,\n    HBA_PORTATTRIBUTES\t*portattributes)\n{\n    HBA_STATUS\t\tstatus;\n    HBA_LIBRARY_INFO\t*lib_infop;\n    HBA_HANDLE\t\tvendorHandle;\n    HBAGetAdapterPortAttributesFunc\n\t\t\tGetAdapterPortAttributesFunc;\n\n    DEBUG(2, \"HBA_GetAdapterPortAttributes\", 0, 0, 0);\n\n    CHECKLIBRARY();\n    GetAdapterPortAttributesFunc =\n\tlib_infop->functionTable.GetAdapterPortAttributesHandler;\n    if (GetAdapterPortAttributesFunc != NULL) {\n\tstatus = ((GetAdapterPortAttributesFunc)\n\t\t  (vendorHandle, portindex, portattributes));\n    } else {\n\tstatus = HBA_STATUS_ERROR_NOT_SUPPORTED;\n    }\n    RELEASE_MUTEX_RETURN(&_hbaapi_LL_mutex, status);\n}\n\nHBA_STATUS\nHBA_GetPortStatistics (\n    HBA_HANDLE\t\thandle,\n    HBA_UINT32\t\tportindex,\n    HBA_PORTSTATISTICS\t*portstatistics)\n{\n    HBA_STATUS\t\tstatus;\n    HBA_LIBRARY_INFO\t*lib_infop;\n    HBA_HANDLE\t\tvendorHandle;\n    HBAGetPortStatisticsFunc\n\t\t\tGetPortStatisticsFunc;\n\n    DEBUG(2, \"HBA_GetPortStatistics\", 0, 0, 0);\n\n    CHECKLIBRARY();\n    GetPortStatisticsFunc =\n\tlib_infop->functionTable.GetPortStatisticsHandler;\n    if (GetPortStatisticsFunc != NULL) {\n\tstatus = ((GetPortStatisticsFunc)\n\t\t  (vendorHandle, portindex, portstatistics));\n    } else {\n\tstatus = HBA_STATUS_ERROR_NOT_SUPPORTED;\n    }\n    RELEASE_MUTEX_RETURN(&_hbaapi_LL_mutex, status);\n}\n\nHBA_STATUS\nHBA_GetDiscoveredPortAttributes (\n    HBA_HANDLE\t\thandle,\n    HBA_UINT32\t\tportindex,\n    HBA_UINT32\t\tdiscoveredportindex,\n    HBA_PORTATTRIBUTES\t*portattributes)\n{\n    HBA_STATUS\t\tstatus;\n    HBA_LIBRARY_INFO\t*lib_infop;\n    HBA_HANDLE\t\tvendorHandle;\n    HBAGetDiscoveredPortAttributesFunc\n\t\t\tGetDiscoveredPortAttributesFunc;\n\n    DEBUG(2, \"HBA_GetDiscoveredPortAttributes\", 0, 0, 0);\n\n    CHECKLIBRARY();\n    GetDiscoveredPortAttributesFunc =\n\tlib_infop->functionTable.GetDiscoveredPortAttributesHandler;\n    if (GetDiscoveredPortAttributesFunc != NULL)  {\n\tstatus = ((GetDiscoveredPortAttributesFunc)\n\t\t  (vendorHandle, portindex, discoveredportindex,\n\t\t   portattributes));\n    } else {\n\tstatus = HBA_STATUS_ERROR_NOT_SUPPORTED;\n    }\n    RELEASE_MUTEX_RETURN(&_hbaapi_LL_mutex, status);\n}\n\nHBA_STATUS\nHBA_GetPortAttributesByWWN (\n    HBA_HANDLE\t\thandle,\n    HBA_WWN\t\tPortWWN,\n    HBA_PORTATTRIBUTES\t*portattributes)\n{\n    HBA_STATUS\t\tstatus;\n    HBA_LIBRARY_INFO\t*lib_infop;\n    HBA_HANDLE\t\tvendorHandle;\n    HBAGetPortAttributesByWWNFunc\n\t\t\tGetPortAttributesByWWNFunc;\n\n    DEBUG(2, \"HBA_GetPortAttributesByWWN: %s\", WWN2STR1(&PortWWN), 0, 0);\n\n    CHECKLIBRARY();\n    GetPortAttributesByWWNFunc =\n\tlib_infop->functionTable.GetPortAttributesByWWNHandler;\n    if (GetPortAttributesByWWNFunc != NULL) {\n\tstatus = ((GetPortAttributesByWWNFunc)\n\t\t  (vendorHandle, PortWWN, portattributes));\n    } else {\n\tstatus = HBA_STATUS_ERROR_NOT_SUPPORTED;\n    }\n    RELEASE_MUTEX_RETURN(&_hbaapi_LL_mutex, status);\n}\n\nHBA_STATUS\nHBA_SendCTPassThru (\n    HBA_HANDLE\t\thandle,\n    void\t\t*pReqBuffer,\n    HBA_UINT32\t\tReqBufferSize,\n    void\t\t*pRspBuffer,\n    HBA_UINT32\t\tRspBufferSize)\n{\n    HBA_STATUS\t\tstatus;\n    HBA_LIBRARY_INFO\t*lib_infop;\n    HBA_HANDLE\t\tvendorHandle;\n    HBASendCTPassThruFunc\n\t\t\tSendCTPassThruFunc;\n\n    DEBUG(2, \"HBA_SendCTPassThru\", 0, 0, 0);\n\n    CHECKLIBRARY();\n    SendCTPassThruFunc = lib_infop->functionTable.SendCTPassThruHandler;\n    if (SendCTPassThruFunc != NULL) {\n\tstatus = (SendCTPassThruFunc)\n\t    (vendorHandle,\n\t     pReqBuffer, ReqBufferSize,\n\t     pRspBuffer, RspBufferSize);\n    } else {\n\tstatus = HBA_STATUS_ERROR_NOT_SUPPORTED;\n    }\n    RELEASE_MUTEX_RETURN(&_hbaapi_LL_mutex, status);\n}\n\nHBA_STATUS\nHBA_SendCTPassThruV2 (\n    HBA_HANDLE\t\thandle,\n    HBA_WWN\t\thbaPortWWN,\n    void\t\t*pReqBuffer,\n    HBA_UINT32\t\tReqBufferSize,\n    void\t\t*pRspBuffer,\n    HBA_UINT32\t\t*pRspBufferSize)\n{\n    HBA_STATUS\t\tstatus;\n    HBA_LIBRARY_INFO\t*lib_infop;\n    HBA_HANDLE\t\tvendorHandle;\n    HBASendCTPassThruV2Func\n\t\t\tregisteredfunc;\n\n    DEBUG(2, \"HBA_SendCTPassThruV2m hbaPortWWN: %s\", WWN2STR1(&hbaPortWWN), 0, 0);\n\n    CHECKLIBRARY();\n    registeredfunc = lib_infop->functionTable.SendCTPassThruV2Handler;\n    if (registeredfunc != NULL) {\n\tstatus = (registeredfunc)\n\t    (vendorHandle, hbaPortWWN,\n\t     pReqBuffer, ReqBufferSize,\n\t     pRspBuffer, pRspBufferSize);\n    } else {\n\tstatus = HBA_STATUS_ERROR_NOT_SUPPORTED;\n    }\n    RELEASE_MUTEX_RETURN(&_hbaapi_LL_mutex, status);\n}\n\nHBA_STATUS\nHBA_GetEventBuffer (\n    HBA_HANDLE\t\thandle,\n    PHBA_EVENTINFO\tEventBuffer,\n    HBA_UINT32\t\t*EventBufferCount)\n{\n    HBA_STATUS\t\tstatus;\n    HBA_LIBRARY_INFO\t*lib_infop;\n    HBA_HANDLE\t\tvendorHandle;\n    HBAGetEventBufferFunc\n\t\t\tGetEventBufferFunc;\n\n    DEBUG(2, \"HBA_GetEventBuffer\", 0, 0, 0);\n\n    CHECKLIBRARY();\n    GetEventBufferFunc = lib_infop->functionTable.GetEventBufferHandler;\n    if (GetEventBufferFunc != NULL) {\n\tstatus = (GetEventBufferFunc)\n\t    (vendorHandle, EventBuffer, EventBufferCount);\n    } else {\n\tstatus = HBA_STATUS_ERROR_NOT_SUPPORTED;\n    }\n    RELEASE_MUTEX_RETURN(&_hbaapi_LL_mutex, status);\n}\n\nHBA_STATUS\nHBA_SetRNIDMgmtInfo (HBA_HANDLE handle, HBA_MGMTINFO *pInfo) {\n    HBA_STATUS\t\tstatus;\n    HBA_LIBRARY_INFO\t*lib_infop;\n    HBA_HANDLE\t\tvendorHandle;\n    HBASetRNIDMgmtInfoFunc\n\t\t\tSetRNIDMgmtInfoFunc;\n\n    DEBUG(2, \"HBA_SetRNIDMgmtInfo\", 0, 0, 0);\n\n    CHECKLIBRARY();\n    SetRNIDMgmtInfoFunc = lib_infop->functionTable.SetRNIDMgmtInfoHandler;\n    if (SetRNIDMgmtInfoFunc != NULL) {\n\tstatus = (SetRNIDMgmtInfoFunc)(vendorHandle, pInfo);\n    } else {\n\tstatus = HBA_STATUS_ERROR_NOT_SUPPORTED;\n    }\n    RELEASE_MUTEX_RETURN(&_hbaapi_LL_mutex, status);\n}\n\nHBA_STATUS\nHBA_GetRNIDMgmtInfo (HBA_HANDLE handle, HBA_MGMTINFO *pInfo) {\n    HBA_STATUS\t\tstatus;\n    HBA_LIBRARY_INFO\t*lib_infop;\n    HBA_HANDLE\t\tvendorHandle;\n    HBASetRNIDMgmtInfoFunc\n\t\t\t GetRNIDMgmtInfoFunc;\n\n    DEBUG(2, \"HBA_GetRNIDMgmtInfo\", 0, 0, 0);\n\n    CHECKLIBRARY();\n    GetRNIDMgmtInfoFunc = lib_infop->functionTable.GetRNIDMgmtInfoHandler;\n    if (GetRNIDMgmtInfoFunc != NULL) {\n\tstatus = (GetRNIDMgmtInfoFunc)(vendorHandle, pInfo);\n    } else {\n\tstatus = HBA_STATUS_ERROR_NOT_SUPPORTED;\n    }\n    RELEASE_MUTEX_RETURN(&_hbaapi_LL_mutex, status);\n}\n\nHBA_STATUS\nHBA_SendRNID (\n    HBA_HANDLE\t\thandle,\n    HBA_WWN\t\twwn,\n    HBA_WWNTYPE\t\twwntype,\n    void\t\t*pRspBuffer,\n    HBA_UINT32\t\t*pRspBufferSize)\n{\n    HBA_STATUS\t\tstatus;\n    HBA_LIBRARY_INFO\t*lib_infop;\n    HBA_HANDLE\t\tvendorHandle;\n    HBASendRNIDFunc\tSendRNIDFunc;\n\n    DEBUG(2, \"HBA_SendRNID for wwn: %s\", WWN2STR1(&wwn), 0, 0);\n\n    CHECKLIBRARY();\n    SendRNIDFunc = lib_infop->functionTable.SendRNIDHandler;\n    if (SendRNIDFunc != NULL) {\n\tstatus = ((SendRNIDFunc)(vendorHandle, wwn, wwntype,\n\t\t\t\t pRspBuffer, pRspBufferSize));\n    } else {\n\tstatus = HBA_STATUS_ERROR_NOT_SUPPORTED;\n    }\n    RELEASE_MUTEX_RETURN(&_hbaapi_LL_mutex, status);\n}\n\nHBA_STATUS\nHBA_SendRNIDV2(\n    HBA_HANDLE\t\thandle,\n    HBA_WWN\t\thbaPortWWN,\n    HBA_WWN\t\tdestWWN,\n    HBA_UINT32\t\tdestFCID,\n    HBA_UINT32\t\tNodeIdDataFormat,\n    void\t\t*pRspBuffer,\n    HBA_UINT32\t\t*pRspBufferSize)\n{\n    HBA_STATUS\t\tstatus;\n    HBA_LIBRARY_INFO\t*lib_infop;\n    HBA_HANDLE\t\tvendorHandle;\n    HBASendRNIDV2Func\tregisteredfunc;\n\n    DEBUG(2, \"HBA_SendRNIDV2, hbaPortWWN: %s\", WWN2STR1(&hbaPortWWN), 0, 0);\n\n    CHECKLIBRARY();\n    registeredfunc = lib_infop->functionTable.SendRNIDV2Handler;\n    if (registeredfunc != NULL) {\n\tstatus = (registeredfunc)\n\t    (vendorHandle, hbaPortWWN, destWWN, destFCID, NodeIdDataFormat,\n\t     pRspBuffer, pRspBufferSize);\n    } else {\n\tstatus = HBA_STATUS_ERROR_NOT_SUPPORTED;\n    }\n    RELEASE_MUTEX_RETURN(&_hbaapi_LL_mutex, status);\n}\n\nvoid\nHBA_RefreshInformation (HBA_HANDLE handle) {\n    HBA_STATUS\t\tstatus;\n    HBA_LIBRARY_INFO\t*lib_infop;\n    HBA_HANDLE\t\tvendorHandle;\n    HBARefreshInformationFunc\n\t\t\tRefreshInformationFunc;\n\n    DEBUG(2, \"HBA_RefreshInformation\", 0, 0, 0);\n\n    status = HBA_CheckLibrary(handle, &lib_infop, &vendorHandle);\n    if(status == HBA_STATUS_OK) {\n\tRefreshInformationFunc =\n\t    lib_infop->functionTable.RefreshInformationHandler;\n\tif (RefreshInformationFunc != NULL) {\n\t    ((RefreshInformationFunc)(vendorHandle));\n\t}\n\tRELEASE_MUTEX(&_hbaapi_LL_mutex);\n    }\n}\n\nvoid\nHBA_ResetStatistics (HBA_HANDLE handle, HBA_UINT32 portindex) {\n    HBA_STATUS\t\tstatus;\n    HBA_LIBRARY_INFO\t*lib_infop;\n    HBA_HANDLE\t\tvendorHandle;\n    HBAResetStatisticsFunc\n\t\t\tResetStatisticsFunc;\n\n    DEBUG(2, \"HBA_ResetStatistics\", 0, 0, 0);\n\n    status = HBA_CheckLibrary(handle, &lib_infop, &vendorHandle);\n    if(status == HBA_STATUS_OK) {\n\tResetStatisticsFunc = lib_infop->functionTable.ResetStatisticsHandler;\n\tif (ResetStatisticsFunc != NULL) {\n\t    ((ResetStatisticsFunc)(vendorHandle, portindex));\n\t}\n\tRELEASE_MUTEX(&_hbaapi_LL_mutex);\n    }\n}\n\nHBA_STATUS\nHBA_GetFcpTargetMapping (HBA_HANDLE handle, PHBA_FCPTARGETMAPPING mapping) {\n    HBA_STATUS\t\tstatus;\n    HBA_LIBRARY_INFO\t*lib_infop;\n    HBA_HANDLE\t\tvendorHandle;\n    HBAGetFcpTargetMappingFunc GetFcpTargetMappingFunc;\n\n    DEBUG(2, \"HBA_GetFcpTargetMapping\", 0, 0, 0);\n\n    CHECKLIBRARY();\n    GetFcpTargetMappingFunc =\n\tlib_infop->functionTable.GetFcpTargetMappingHandler;\n    if (GetFcpTargetMappingFunc != NULL) {\n\tstatus = ((GetFcpTargetMappingFunc)(vendorHandle, mapping));\n    } else {\n\tstatus = HBA_STATUS_ERROR_NOT_SUPPORTED;\n    }\n    RELEASE_MUTEX_RETURN(&_hbaapi_LL_mutex, status);\n}\n\nHBA_STATUS\nHBA_GetFcpTargetMappingV2 (\n    HBA_HANDLE\t\thandle,\n    HBA_WWN\t\thbaPortWWN,\n    HBA_FCPTARGETMAPPINGV2\n\t\t\t*pmapping)\n{\n    HBA_STATUS\t\tstatus;\n    HBA_LIBRARY_INFO\t*lib_infop;\n    HBA_HANDLE\t\tvendorHandle;\n    HBAGetFcpTargetMappingV2Func\n\t\t\tregisteredfunc;\n\n    DEBUG(2, \"HBA_GetFcpTargetMapping\", 0, 0, 0);\n\n    CHECKLIBRARY();\n    registeredfunc =\n\tlib_infop->functionTable.GetFcpTargetMappingV2Handler;\n    if (registeredfunc != NULL) {\n\tstatus = ((registeredfunc)(vendorHandle, hbaPortWWN, pmapping));\n    } else {\n\tstatus = HBA_STATUS_ERROR_NOT_SUPPORTED;\n    }\n    RELEASE_MUTEX_RETURN(&_hbaapi_LL_mutex, status);\n}\n\nHBA_STATUS\nHBA_GetFcpPersistentBinding (HBA_HANDLE handle, PHBA_FCPBINDING binding) {\n    HBA_STATUS\t\tstatus;\n    HBA_LIBRARY_INFO\t*lib_infop;\n    HBA_HANDLE\t\tvendorHandle;\n    HBAGetFcpPersistentBindingFunc\n\t\t\tGetFcpPersistentBindingFunc;\n\n    DEBUG(2, \"HBA_GetFcpPersistentBinding\", 0, 0, 0);\n\n    CHECKLIBRARY();\n    GetFcpPersistentBindingFunc =\n\tlib_infop->functionTable.GetFcpPersistentBindingHandler;\n    if (GetFcpPersistentBindingFunc != NULL) {\n\tstatus = ((GetFcpPersistentBindingFunc)(vendorHandle, binding));\n    } else {\n\tstatus = HBA_STATUS_ERROR_NOT_SUPPORTED;\n    }\n    RELEASE_MUTEX_RETURN(&_hbaapi_LL_mutex, status);\n}\n\nHBA_STATUS\nHBA_ScsiInquiryV2 (\n    HBA_HANDLE\thandle,\n    HBA_WWN\thbaPortWWN,\n    HBA_WWN\tdiscoveredPortWWN,\n    HBA_UINT64\tfcLUN,\n    HBA_UINT8\tCDB_Byte1,\n    HBA_UINT8\tCDB_Byte2,\n    void\t*pRspBuffer,\n    HBA_UINT32\t*pRspBufferSize,\n    HBA_UINT8\t*pScsiStatus,\n    void\t*pSenseBuffer,\n    HBA_UINT32\t*pSenseBufferSize)\n{\n    HBA_STATUS\t\tstatus;\n    HBA_LIBRARY_INFO\t*lib_infop;\n    HBA_HANDLE\t\tvendorHandle;\n    HBAScsiInquiryV2Func ScsiInquiryV2Func;\n\n    DEBUG(2, \"HBA_ScsiInquiryV2 to discoveredPortWWN: %s\",\n\t  WWN2STR1(&discoveredPortWWN), 0, 0);\n\n    CHECKLIBRARY();\n    ScsiInquiryV2Func =\n\tlib_infop->functionTable.ScsiInquiryV2Handler;\n    if (ScsiInquiryV2Func != NULL) {\n\tstatus =((ScsiInquiryV2Func)(\n\t    vendorHandle, hbaPortWWN, discoveredPortWWN, fcLUN, CDB_Byte1,\n\t    CDB_Byte2, pRspBuffer, pRspBufferSize, pScsiStatus,\n\t    pSenseBuffer, pSenseBufferSize));\n    } else {\n\tstatus = HBA_STATUS_ERROR_NOT_SUPPORTED;\n    }\n    RELEASE_MUTEX_RETURN(&_hbaapi_LL_mutex, status);\n}\n\nHBA_STATUS\nHBA_SendScsiInquiry (\n    HBA_HANDLE\thandle,\n    HBA_WWN\tPortWWN,\n    HBA_UINT64\tfcLUN,\n    HBA_UINT8\tEVPD,\n    HBA_UINT32\tPageCode,\n    void\t*pRspBuffer,\n    HBA_UINT32\tRspBufferSize,\n    void\t*pSenseBuffer,\n    HBA_UINT32\tSenseBufferSize)\n{\n    HBA_STATUS\t\tstatus;\n    HBA_LIBRARY_INFO\t*lib_infop;\n    HBA_HANDLE\t\tvendorHandle;\n    HBASendScsiInquiryFunc SendScsiInquiryFunc;\n\n    DEBUG(2, \"HBA_SendScsiInquiry to PortWWN: %s\", WWN2STR1(&PortWWN), 0, 0);\n\n    CHECKLIBRARY();\n    SendScsiInquiryFunc = lib_infop->functionTable.ScsiInquiryHandler;\n    if (SendScsiInquiryFunc != NULL) {\n\tstatus =((SendScsiInquiryFunc)(\n\t    vendorHandle, PortWWN, fcLUN, EVPD, PageCode, pRspBuffer,\n\t    RspBufferSize, pSenseBuffer, SenseBufferSize));\n    } else {\n\tstatus = HBA_STATUS_ERROR_NOT_SUPPORTED;\n    }\n    RELEASE_MUTEX_RETURN(&_hbaapi_LL_mutex, status);\n}\n\nHBA_STATUS\nHBA_ScsiReportLUNsV2 (\n    HBA_HANDLE\t\thandle,\n    HBA_WWN\t\thbaPortWWN,\n    HBA_WWN\t\tdiscoveredPortWWN,\n    void\t\t*pRespBuffer,\n    HBA_UINT32\t\t*pRespBufferSize,\n    HBA_UINT8\t\t*pScsiStatus,\n    void\t\t*pSenseBuffer,\n    HBA_UINT32\t\t*pSenseBufferSize)\n{\n    HBA_STATUS\t\tstatus;\n    HBA_LIBRARY_INFO\t*lib_infop;\n    HBA_HANDLE\t\tvendorHandle;\n    HBAScsiReportLUNsV2Func ScsiReportLUNsV2Func;\n\n    DEBUG(2, \"HBA_ScsiReportLUNsV2 to discoveredPortWWN: %s\",\n\t  WWN2STR1(&discoveredPortWWN), 0, 0);\n\n    CHECKLIBRARY();\n    ScsiReportLUNsV2Func = lib_infop->functionTable.ScsiReportLUNsV2Handler;\n    if (ScsiReportLUNsV2Func != NULL) {\n\tstatus = ((ScsiReportLUNsV2Func)(\n\t    vendorHandle, hbaPortWWN, discoveredPortWWN,\n\t    pRespBuffer, pRespBufferSize,\n\t    pScsiStatus,\n\t    pSenseBuffer, pSenseBufferSize));\n    } else {\n\tstatus = HBA_STATUS_ERROR_NOT_SUPPORTED;\n    }\n    RELEASE_MUTEX_RETURN(&_hbaapi_LL_mutex, status);\n}\n\nHBA_STATUS\nHBA_SendReportLUNs (\n    HBA_HANDLE handle,\n    HBA_WWN portWWN,\n    void *pRspBuffer,\n    HBA_UINT32 RspBufferSize,\n    void *pSenseBuffer,\n    HBA_UINT32 SenseBufferSize)\n{\n    HBA_STATUS\t\tstatus;\n    HBA_LIBRARY_INFO\t*lib_infop;\n    HBA_HANDLE\t\tvendorHandle;\n    HBASendReportLUNsFunc SendReportLUNsFunc;\n\n    DEBUG(2, \"HBA_SendReportLUNs to PortWWN: %s\", WWN2STR1(&portWWN), 0, 0);\n\n    CHECKLIBRARY();\n    SendReportLUNsFunc = lib_infop->functionTable.ReportLUNsHandler;\n    if (SendReportLUNsFunc != NULL) {\n\tstatus = ((SendReportLUNsFunc)(\n\t    vendorHandle, portWWN, pRspBuffer,\n\t    RspBufferSize, pSenseBuffer, SenseBufferSize));\n    } else {\n\tstatus = HBA_STATUS_ERROR_NOT_SUPPORTED;\n    }\n    RELEASE_MUTEX_RETURN(&_hbaapi_LL_mutex, status);\n}\n\nHBA_STATUS\nHBA_ScsiReadCapacityV2 (\n    HBA_HANDLE\t\thandle,\n    HBA_WWN\t\thbaPortWWN,\n    HBA_WWN\t\tdiscoveredPortWWN,\n    HBA_UINT64\t\tfcLUN,\n    void\t\t*pRspBuffer,\n    HBA_UINT32\t\t*pRspBufferSize,\n    HBA_UINT8\t\t*pScsiStatus,\n    void\t\t*pSenseBuffer,\n    HBA_UINT32\t\t*SenseBufferSize)\n{\n    HBA_STATUS\t\tstatus;\n    HBA_LIBRARY_INFO\t*lib_infop;\n    HBA_HANDLE\t\tvendorHandle;\n    HBAScsiReadCapacityV2Func ScsiReadCapacityV2Func;\n\n    DEBUG(2, \"HBA_ScsiReadCapacityV2 to discoveredPortWWN: %s\",\n\t  WWN2STR1(&discoveredPortWWN), 0, 0);\n\n    CHECKLIBRARY();\n    ScsiReadCapacityV2Func =\n\tlib_infop->functionTable.ScsiReadCapacityV2Handler;\n    if (ScsiReadCapacityV2Func != NULL) {\n\tstatus =((ScsiReadCapacityV2Func)(\n\t    vendorHandle, hbaPortWWN, discoveredPortWWN, fcLUN,\n\t    pRspBuffer, pRspBufferSize,\n\t    pScsiStatus,\n\t    pSenseBuffer, SenseBufferSize));\n    } else {\n\tstatus = HBA_STATUS_ERROR_NOT_SUPPORTED;\n    }\n    RELEASE_MUTEX_RETURN(&_hbaapi_LL_mutex, status);\n}\n\nHBA_STATUS\nHBA_SendReadCapacity (\n    HBA_HANDLE handle,\n    HBA_WWN portWWN,\n    HBA_UINT64 fcLUN,\n    void *pRspBuffer,\n    HBA_UINT32 RspBufferSize,\n    void *pSenseBuffer,\n    HBA_UINT32 SenseBufferSize)\n{\n    HBA_STATUS\t\tstatus;\n    HBA_LIBRARY_INFO\t*lib_infop;\n    HBA_HANDLE\t\tvendorHandle;\n    HBASendReadCapacityFunc SendReadCapacityFunc;\n\n    DEBUG(2, \"HBA_SendReadCapacity to portWWN: %s\", WWN2STR1(&portWWN), 0, 0);\n\n    CHECKLIBRARY();\n    SendReadCapacityFunc = lib_infop->functionTable.ReadCapacityHandler;\n    if (SendReadCapacityFunc != NULL) {\n\tstatus =((SendReadCapacityFunc)\n\t\t (vendorHandle, portWWN, fcLUN, pRspBuffer,\n\t\t  RspBufferSize, pSenseBuffer, SenseBufferSize));\n    } else {\n\tstatus = HBA_STATUS_ERROR_NOT_SUPPORTED;\n    }\n    RELEASE_MUTEX_RETURN(&_hbaapi_LL_mutex, status);\n}\n\nHBA_STATUS\nHBA_SendRPL (\n    HBA_HANDLE\t\thandle,\n    HBA_WWN\t\thbaPortWWN,\n    HBA_WWN\t\tagent_wwn,\n    HBA_UINT32\t\tagent_domain,\n    HBA_UINT32\t\tportindex,\n    void\t\t*pRspBuffer,\n    HBA_UINT32\t\t*pRspBufferSize)\n{\n    HBA_STATUS\t\tstatus;\n    HBA_LIBRARY_INFO\t*lib_infop;\n    HBA_HANDLE\t\tvendorHandle;\n    HBASendRPLFunc registeredfunc;\n\n    DEBUG(2, \"HBA_SendRPL to agent_wwn: %s:%d\",\n\t  WWN2STR1(&agent_wwn), agent_domain, 0);\n\n    CHECKLIBRARY();\n    registeredfunc = lib_infop->functionTable.SendRPLHandler;\n    if (registeredfunc != NULL) {\n\tstatus =(registeredfunc)(\n\t    vendorHandle, hbaPortWWN, agent_wwn, agent_domain, portindex,\n\t    pRspBuffer, pRspBufferSize);\n    } else {\n\tstatus = HBA_STATUS_ERROR_NOT_SUPPORTED;\n    }\n    RELEASE_MUTEX_RETURN(&_hbaapi_LL_mutex, status);\n}\n\nHBA_STATUS\nHBA_SendRPS (\n    HBA_HANDLE\t\thandle,\n    HBA_WWN\t\thbaPortWWN,\n    HBA_WWN\t\tagent_wwn,\n    HBA_UINT32\t\tagent_domain,\n    HBA_WWN\t\tobject_wwn,\n    HBA_UINT32\t\tobject_port_number,\n    void\t\t*pRspBuffer,\n    HBA_UINT32\t\t*pRspBufferSize)\n{\n    HBA_STATUS\t\tstatus;\n    HBA_LIBRARY_INFO\t*lib_infop;\n    HBA_HANDLE\t\tvendorHandle;\n    HBASendRPSFunc registeredfunc;\n\n    DEBUG(2, \"HBA_SendRPS  to agent_wwn: %s:%d\",\n\t  WWN2STR1(&agent_wwn), agent_domain, 0);\n\n    CHECKLIBRARY();\n    registeredfunc = lib_infop->functionTable.SendRPSHandler;\n    if (registeredfunc != NULL) {\n\tstatus =(registeredfunc)(\n\t    vendorHandle, hbaPortWWN, agent_wwn, agent_domain,\n\t    object_wwn, object_port_number,\n\t    pRspBuffer, pRspBufferSize);\n    } else {\n\tstatus = HBA_STATUS_ERROR_NOT_SUPPORTED;\n    }\n    RELEASE_MUTEX_RETURN(&_hbaapi_LL_mutex, status);\n}\n\nHBA_STATUS\nHBA_SendSRL (\n    HBA_HANDLE\t\thandle,\n    HBA_WWN\t\thbaPortWWN,\n    HBA_WWN\t\twwn,\n    HBA_UINT32\t\tdomain,\n    void\t\t*pRspBuffer,\n    HBA_UINT32\t\t*pRspBufferSize)\n{\n    HBA_STATUS\t\tstatus;\n    HBA_LIBRARY_INFO\t*lib_infop;\n    HBA_HANDLE\t\tvendorHandle;\n    HBASendSRLFunc registeredfunc;\n\n    DEBUG(2, \"HBA_SendSRL to wwn:%s domain:%d\", WWN2STR1(&wwn), domain, 0);\n\n    CHECKLIBRARY();\n    registeredfunc = lib_infop->functionTable.SendSRLHandler;\n    if (registeredfunc != NULL) {\n\tstatus =(registeredfunc)(\n\t    vendorHandle, hbaPortWWN, wwn, domain,\n\t    pRspBuffer, pRspBufferSize);\n    } else {\n\tstatus = HBA_STATUS_ERROR_NOT_SUPPORTED;\n    }\n    RELEASE_MUTEX_RETURN(&_hbaapi_LL_mutex, status);\n}\nHBA_STATUS\nHBA_SendRLS (\n    HBA_HANDLE\t\thandle,\n    HBA_WWN\t\thbaPortWWN,\n    HBA_WWN\t\tdestWWN,\n    void\t\t*pRspBuffer,\n    HBA_UINT32\t\t*pRspBufferSize)\n{\n    HBA_STATUS\t\tstatus;\n    HBA_LIBRARY_INFO\t*lib_infop;\n    HBA_HANDLE\t\tvendorHandle;\n    HBASendRLSFunc registeredfunc;\n\n    DEBUG(2, \"HBA_SendRLS dest_wwn: %s\",\n\t  WWN2STR(&destWWN), 0, 0);\n\n    CHECKLIBRARY();\n    registeredfunc = lib_infop->functionTable.SendRLSHandler;\n    if (registeredfunc != NULL) {\n\tstatus =(registeredfunc)(\n\t    vendorHandle, hbaPortWWN, destWWN,\n\t    pRspBuffer, pRspBufferSize);\n    } else {\n\tstatus = HBA_STATUS_ERROR_NOT_SUPPORTED;\n    }\n    RELEASE_MUTEX_RETURN(&_hbaapi_LL_mutex, status);\n}\n\nHBA_STATUS\nHBA_SendLIRR (\n    HBA_HANDLE\t\thandle,\n    HBA_WWN\t\tsourceWWN,\n    HBA_WWN\t\tdestWWN,\n    HBA_UINT8\t\tfunction,\n    HBA_UINT8\t\ttype,\n    void\t\t*pRspBuffer,\n    HBA_UINT32\t\t*pRspBufferSize)\n{\n    HBA_STATUS\t\tstatus;\n    HBA_LIBRARY_INFO\t*lib_infop;\n    HBA_HANDLE\t\tvendorHandle;\n    HBASendLIRRFunc registeredfunc;\n\n    DEBUG(2, \"HBA_SendLIRR destWWN:%s\", WWN2STR1(&destWWN), 0, 0);\n\n    CHECKLIBRARY();\n    registeredfunc = lib_infop->functionTable.SendLIRRHandler;\n    if (registeredfunc != NULL) {\n\tstatus =(registeredfunc)(\n\t    vendorHandle, sourceWWN, destWWN, function, type,\n\t    pRspBuffer, pRspBufferSize);\n    } else {\n\tstatus = HBA_STATUS_ERROR_NOT_SUPPORTED;\n    }\n    RELEASE_MUTEX_RETURN(&_hbaapi_LL_mutex, status);\n}\n\nHBA_STATUS\nHBA_GetBindingCapability(\n    HBA_HANDLE\t\thandle,\n    HBA_WWN\t\thbaPortWWN,\n    HBA_BIND_CAPABILITY *pcapability)\n{\n    HBA_STATUS\t\tstatus;\n    HBA_LIBRARY_INFO\t*lib_infop;\n    HBA_HANDLE\t\tvendorHandle;\n    HBAGetBindingCapabilityFunc\n\t\t\tregisteredfunc;\n\n    DEBUG(2, \"HBA_GetBindingCapability\", 0, 0, 0);\n\n    CHECKLIBRARY();\n    registeredfunc = lib_infop->functionTable.GetBindingCapabilityHandler;\n    if (registeredfunc != NULL) {\n\tstatus =(registeredfunc)(vendorHandle, hbaPortWWN, pcapability);\n    } else {\n\tstatus = HBA_STATUS_ERROR_NOT_SUPPORTED;\n    }\n    RELEASE_MUTEX_RETURN(&_hbaapi_LL_mutex, status);\n}\n\nHBA_STATUS\nHBA_GetBindingSupport (\n    HBA_HANDLE\t\thandle,\n    HBA_WWN\t\thbaPortWWN,\n    HBA_BIND_CAPABILITY *pcapability)\n{\n    HBA_STATUS\t\tstatus;\n    HBA_LIBRARY_INFO\t*lib_infop;\n    HBA_HANDLE\t\tvendorHandle;\n    HBAGetBindingSupportFunc\n\t\t\tregisteredfunc;\n\n    DEBUG(2, \"HBA_GetBindingSupport\", 0, 0, 0);\n\n    CHECKLIBRARY();\n    registeredfunc = lib_infop->functionTable.GetBindingSupportHandler;\n    if (registeredfunc != NULL) {\n\tstatus =(registeredfunc)(vendorHandle, hbaPortWWN, pcapability);\n    } else {\n\tstatus = HBA_STATUS_ERROR_NOT_SUPPORTED;\n    }\n    RELEASE_MUTEX_RETURN(&_hbaapi_LL_mutex, status);\n}\n\nHBA_STATUS\nHBA_SetBindingSupport(\n    HBA_HANDLE\t\thandle,\n    HBA_WWN\t\thbaPortWWN,\n    HBA_BIND_CAPABILITY capability)\n{\n    HBA_STATUS\t\tstatus;\n    HBA_LIBRARY_INFO\t*lib_infop;\n    HBA_HANDLE\t\tvendorHandle;\n    HBASetBindingSupportFunc\n\t\t\tregisteredfunc;\n\n    DEBUG(2, \"HBA_SetBindingSupport\", 0, 0, 0);\n\n    CHECKLIBRARY();\n    registeredfunc = lib_infop->functionTable.SetBindingSupportHandler;\n    if (registeredfunc != NULL) {\n\tstatus =(registeredfunc)(vendorHandle, hbaPortWWN, capability);\n    } else {\n\tstatus = HBA_STATUS_ERROR_NOT_SUPPORTED;\n    }\n    RELEASE_MUTEX_RETURN(&_hbaapi_LL_mutex, status);\n}\n\nHBA_STATUS\nHBA_SetPersistentBindingV2 (\n    HBA_HANDLE\t\thandle,\n    HBA_WWN\t\thbaPortWWN,\n    const HBA_FCPBINDING2\n\t\t\t*pbinding)\n{\n    HBA_STATUS\t\tstatus;\n    HBA_LIBRARY_INFO\t*lib_infop;\n    HBA_HANDLE\t\tvendorHandle;\n    HBASetPersistentBindingV2Func\n\t\t\tregisteredfunc;\n\n    DEBUG(2, \"HBA_SetPersistentBindingV2 port: %s\", WWN2STR1(&hbaPortWWN), 0, 0);\n\n    CHECKLIBRARY();\n    registeredfunc = lib_infop->functionTable.SetPersistentBindingV2Handler;\n    if (registeredfunc != NULL) {\n\tstatus =(registeredfunc)(vendorHandle, hbaPortWWN, pbinding);\n    } else {\n\tstatus = HBA_STATUS_ERROR_NOT_SUPPORTED;\n    }\n    RELEASE_MUTEX_RETURN(&_hbaapi_LL_mutex, status);\n}\n\nHBA_STATUS\nHBA_GetPersistentBindingV2 (\n    HBA_HANDLE\t\thandle,\n    HBA_WWN\t\thbaPortWWN,\n    HBA_FCPBINDING2\t*pbinding)\n{\n    HBA_STATUS\t\tstatus;\n    HBA_LIBRARY_INFO\t*lib_infop;\n    HBA_HANDLE\t\tvendorHandle;\n    HBAGetPersistentBindingV2Func\n\t\t\tregisteredfunc;\n\n    DEBUG(2, \"HBA_GetPersistentBindingV2 port: %s\", WWN2STR1(&hbaPortWWN), 0, 0);\n\n    CHECKLIBRARY();\n    registeredfunc = lib_infop->functionTable.GetPersistentBindingV2Handler;\n    if (registeredfunc != NULL) {\n\tstatus =(registeredfunc)(vendorHandle, hbaPortWWN, pbinding);\n    } else {\n\tstatus = HBA_STATUS_ERROR_NOT_SUPPORTED;\n    }\n    RELEASE_MUTEX_RETURN(&_hbaapi_LL_mutex, status);\n}\n\nHBA_STATUS\nHBA_RemovePersistentBinding (\n    HBA_HANDLE\t\thandle,\n    HBA_WWN\t\thbaPortWWN,\n    const HBA_FCPBINDING2\n\t\t\t*pbinding)\n{\n    HBA_STATUS\t\tstatus;\n    HBA_LIBRARY_INFO\t*lib_infop;\n    HBA_HANDLE\t\tvendorHandle;\n    HBARemovePersistentBindingFunc\n\t\t\tregisteredfunc;\n\n    DEBUG(2, \"HBA_RemovePersistentBinding\", 0, 0, 0);\n\n    CHECKLIBRARY();\n    registeredfunc =\n\tlib_infop->functionTable.RemovePersistentBindingHandler;\n    if (registeredfunc != NULL) {\n\tstatus =(registeredfunc)(vendorHandle, hbaPortWWN, pbinding);\n    } else {\n\tstatus = HBA_STATUS_ERROR_NOT_SUPPORTED;\n    }\n    RELEASE_MUTEX_RETURN(&_hbaapi_LL_mutex, status);\n}\n\nHBA_STATUS\nHBA_RemoveAllPersistentBindings (\n    HBA_HANDLE\t\thandle,\n    HBA_WWN\t\thbaPortWWN)\n{\n    HBA_STATUS\t\tstatus;\n    HBA_LIBRARY_INFO\t*lib_infop;\n    HBA_HANDLE\t\tvendorHandle;\n    HBARemoveAllPersistentBindingsFunc\n\t\t\tregisteredfunc;\n\n    DEBUG(2, \"HBA_RemoveAllPersistentBindings\", 0, 0, 0);\n\n    CHECKLIBRARY();\n    registeredfunc =\n\tlib_infop->functionTable.RemoveAllPersistentBindingsHandler;\n    if (registeredfunc != NULL) {\n\tstatus =(registeredfunc)(vendorHandle, hbaPortWWN);\n    } else {\n\tstatus = HBA_STATUS_ERROR_NOT_SUPPORTED;\n    }\n    RELEASE_MUTEX_RETURN(&_hbaapi_LL_mutex, status);\n}\n\nHBA_STATUS\nHBA_GetFC4Statistics (\n    HBA_HANDLE\t\thandle,\n    HBA_WWN\t\tportWWN,\n    HBA_UINT8\t\tFC4type,\n    HBA_FC4STATISTICS\t*pstatistics)\n{\n    HBA_STATUS\t\tstatus;\n    HBA_LIBRARY_INFO\t*lib_infop;\n    HBA_HANDLE\t\tvendorHandle;\n    HBAGetFC4StatisticsFunc\n\t\t\tregisteredfunc;\n\n    DEBUG(2, \"HBA_GetFC4Statistics port: %s\", WWN2STR1(&portWWN), 0, 0);\n\n    CHECKLIBRARY();\n    registeredfunc =\n\tlib_infop->functionTable.GetFC4StatisticsHandler;\n    if (registeredfunc != NULL) {\n\tstatus =(registeredfunc)\n\t    (vendorHandle, portWWN, FC4type, pstatistics);\n    } else {\n\tstatus = HBA_STATUS_ERROR_NOT_SUPPORTED;\n    }\n    RELEASE_MUTEX_RETURN(&_hbaapi_LL_mutex, status);\n}\n\nHBA_STATUS\nHBA_GetFCPStatistics (\n    HBA_HANDLE\t\thandle,\n    const HBA_SCSIID\t*lunit,\n    HBA_FC4STATISTICS\t*pstatistics)\n{\n    HBA_STATUS\t\tstatus;\n    HBA_LIBRARY_INFO\t*lib_infop;\n    HBA_HANDLE\t\tvendorHandle;\n    HBAGetFCPStatisticsFunc\n\t\t\tregisteredfunc;\n\n    DEBUG(2, \"HBA_GetFCPStatistics\", 0, 0, 0);\n\n    CHECKLIBRARY();\n    registeredfunc =\n\tlib_infop->functionTable.GetFCPStatisticsHandler;\n    if (registeredfunc != NULL) {\n\tstatus =(registeredfunc)(vendorHandle, lunit, pstatistics);\n    } else {\n\tstatus = HBA_STATUS_ERROR_NOT_SUPPORTED;\n    }\n    RELEASE_MUTEX_RETURN(&_hbaapi_LL_mutex, status);\n}\n\nHBA_UINT32\nHBA_GetVendorLibraryAttributes (\n    HBA_UINT32 adapter_index,\n    HBA_LIBRARYATTRIBUTES *attributes)\n{\n    HBA_ADAPTER_INFO\t*adapt_infop;\n    HBAGetVendorLibraryAttributesFunc\n\t\t\tregisteredfunc;\n    HBA_UINT32\t\tret = 0;\n\n    DEBUG(2, \"HBA_GetVendorLibraryAttributes adapterindex:%d\",\n\t  adapter_index, 0, 0);\n    if(_hbaapi_librarylist == NULL) {\n\tDEBUG(1, \"HBAAPI not loaded yet.\", 0, 0, 0);\n\treturn(0);\n    }\n\n    memset(attributes, 0, sizeof(HBA_LIBRARYATTRIBUTES));\n\n    GRAB_MUTEX(&_hbaapi_LL_mutex);\n    GRAB_MUTEX(&_hbaapi_AL_mutex);\n    for(adapt_infop = _hbaapi_adapterlist;\n\tadapt_infop != NULL;\n\tadapt_infop = adapt_infop->next) {\n\n\tif(adapt_infop->index == adapter_index) {\n\t    registeredfunc = adapt_infop->library->\n\t\tfunctionTable.GetVendorLibraryAttributesHandler;\n\t    if(registeredfunc != NULL) {\n\t\tret = (registeredfunc)(attributes);\n\t    } else {\n\t\t/* Version 1 libary? */\n\t\tHBAGetVersionFunc\tGetVersionFunc;\n\t\tGetVersionFunc = adapt_infop->library->\n\t\t    functionTable.GetVersionHandler;\n\t\tif(GetVersionFunc != NULL) {\n\t\t    ret = ((GetVersionFunc)());\n\t\t}\n#ifdef NOTDEF\n\t\telse {\n\t\t    /* This should not happen, dont think its going to */\n\t\t}\n#endif\n\t    }\n\t    if (attributes->LibPath[0] == '\\0') {\n\t\tif(strlen(adapt_infop->library->LibraryPath) < 256) {\n\t\t    strcpy(attributes->LibPath,\n\t\t\t   adapt_infop->library->LibraryPath);\n\t\t}\n\t    }\n\t    break;\n\t}\n    }\n    RELEASE_MUTEX(&_hbaapi_AL_mutex);\n    RELEASE_MUTEX_RETURN(&_hbaapi_LL_mutex, ret);\n}\n"
    },
    "skipped": [],
    "total_files": 13
}