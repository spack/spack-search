{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-perfstubs-master-j4trizokldngjffj5xt7fwz4tmp7cvna/spack-src/perfstubs_api/README.md": "# Profiling Interface for ADIOS2\n\nCopyright (c) 2019-2020 University of Oregon\nDistributed under the BSD Software License\n(See accompanying file LICENSE.txt)\n\n_Note:_ This library was originally written as a stub library wrapper in ADIOS.\nThis is a generic design and implementation for other libraries and tools.\n\n## Todo Items\n- [x] Make the interface generic.\n    - [x] Replace ADIOST-specific symbols with generic versions that will be\n      implemented by interested measurement libraries (i.e. Score-P). \n    - ~~[ ] New environment variable specifying location of library containing\n      function implementations.~~\n    - [x] Remove dynamic-linking specific approach (checking ```LD_PRELOAD```)\n      If the symbol isn't loaded, don't search for it.  We have to support\n      static linking, too - and if we ```dlopen()``` a library with pthread in\n      it, the application will crash because of initialization of thread-local\n      static globals.\n\n- [x] Add a CMake option to disable the API entirely.\n\n- [x] Add CMake support for linking in measurement libraries when static\n  linking.\n\n- [x] Investigate API call to trigger writing of performance data to the ADIOS2\n  archive (performance data stored with the science data).\n\n## Overview\n\nThese files contain a thin stub interface for instrumenting library or\napplication code.  The interface can be compiled away entirely.  The function\ncalls are \"stubs\" in the form of function pointers, initialized to\n```nullptr```. The functions are optionally assigned at runtime using dlsym()\ncalls, as is typical with plugin implementations.  If static linking is used, a\n*weak symbol* technique is used instead.  If the function pointers have the\nvalue ```nullptr```, then this library is a few more instructions than a no-op.\nIf the function pointers are assigned, the measurement library functions are\ncalled to perform the timing measurement.  The symbols are made available to\nthe environment either through ```LD_PRELOAD``` settings or by linking in the\nmeasurement library.\n\nConvenience macros are provided for constructing descriptive timer names using\npre-processor definitions such as ```__FILE__```, ```__LINE__```, and\n```__func__```.  For C++ codes, there are also scoped timers to minimize\ninstrumentation text and ensure timers are stopped in functions with multiple\nreturn locations or exceptions that throw outside of scope.\n\n## Known Issues\n\nBecause the implementation uses ```libdl.so``` there will be linker warnings\nwhen linking static executables.  It is known that static executables that load\nshared-object measurement libraries with pthread support will crash, because of\na known issue with thread local storage at program startup.  However, both\ndynamic and static implementations and examples are provided.\n\n## How to instrument with the C API\n\nFor C code, you have the option of specifying the timer name or letting the API\ngenerate it based on source code location data.\n\n### Timers\n\nOption 1, explicit timer name:\n\n```C\n#include \"perfstubs_api/timer.h\"\n\nvoid function_to_time(void) {\n    PERFSTUBS_TIMER_START(\"interesting loop\");\n    ...\n    PERFSTUBS_TIMER_STOP(\"interesting loop\");\n}\n```\n\nOption 2, generated timer name:\n\n```C\n#include \"perfstubs_api/timer.h\"\n\nvoid function_to_time(void) {\n    /* Will generate something like:\n     * \"void function_to_time(void) [{filename.c} {123,0}]\"\n     */\n    PERFSTUBS_TIMER_START_FUNC();\n    ...\n    PERFSTUBS_TIMER_STOP_FUNC();\n}\n```\n\n### Counters\n\nThe interface can be used to capture interesting counter values, too:\n\n```C\nPERFSTUBS_SAMPLE_COUNTER(\"Bytes Written\", 1024);\n```\n\n### Metadata\n\nThe interface can be used to capture interesting metadata:\n\n```C\nPERFSTUBS_METADATA(\"ADIOS Method\", \"POSIX\");\n```\n\n## How to instrument with the C++ API\n\nThe C++ API adds additional scoped timers for convenience:\n\n```C++\n#include \"perfstubs_api/timer.h\"\n\nvoid function_to_time(void) {\n    /* Will generate something like:\n     * \"void function_to_time(void) [{filename.cpp} {123,0}]\"\n     */\n    PERFSTUBS_SCOPED_TIMER_FUNC();\n    ...\n}\n```\n\n```C++\ndo {\n    PERFSTUBS_SCOPED_TIMER(\"While Loop\");\n    ...\n} while (!done);\n```\n\n## How to use at runtime\n\nTo use the API with an application or library, the executable can be linked\ndynamically or statically.  Dynamic applications can be observed with an\nexternal tool such as TAU by using the ```tau_exec``` program wrapper:\n\n```bash\nmpirun -np 4 tau_exec -T mpi,papi,pthread ./executable\n```\n\nThe example above will use a TAU configuration with PAPI, MPI and Pthread\nsupport.\n\n## How to integrate into your project\n\n### Option 1: build/install perfstubs as a library\nJust like it sounds, you would build the library and link to it at link time.  This would be useful if multiple libraries in the executable are using instrumentation, so that there aren't multiple implementations (although that should work fine, there would just be code duplication).\n\n### Option 2: Add timer.c, tool.h and timer.h (and optionally timer_f.h for Fortran support) to your source code\nThis is probably the easiest solution.  Include header paths might have to be modified inside the source files if you don't want to have `perfstubs_api` in your include directory tree.  The line: `#include perfstubs_api/config.h` can be removed from `perfstubs_api/timer.h` unless you have a project need for it.\n"
    },
    "skipped": [],
    "total_files": 48
}