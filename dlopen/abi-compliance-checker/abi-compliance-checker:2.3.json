{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-abi-compliance-checker-2.3-n4yl5ygpdt5uppbv3qhtrfmsep4rpevl/spack-src/modules/Internals/ABIDump.pm": "###########################################################################\n# A module to create ABI dump from AST tree\n#\n# Copyright (C) 2015-2018 Andrey Ponomarenko's ABI Laboratory\n#\n# Written by Andrey Ponomarenko\n#\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n#\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n# MA  02110-1301 USA\n###########################################################################\nuse strict;\n\nloadModule(\"ElfTools\");\nloadModule(\"TUDump\");\nloadModule(\"GccAst\");\n\nmy %Cache;\n\nmy %RegisteredObj;\nmy %RegisteredObj_Short;\nmy %RegisteredSoname;\nmy %RegisteredObj_Dir;\nmy %CheckedDyLib;\nmy %KnownLibs;\nmy %CheckedArch;\nmy @RecurLib;\n\nsub createABIDump($)\n{\n    my $LVer = $_[0];\n    \n    if($In::Opt{\"CheckHeadersOnly\"}) {\n        $In::ABI{$LVer}{\"Language\"} = \"C++\";\n    }\n    else\n    {\n        readLibs($LVer);\n        \n        if(not keys(%{$In::ABI{$LVer}{\"SymLib\"}})) {\n            exitStatus(\"Error\", \"the set of public symbols in library(ies) is empty\");\n        }\n    }\n    \n    if($In::Opt{\"TargetArch\"}) {\n        $In::ABI{$LVer}{\"Arch\"} = $In::Opt{\"TargetArch\"};\n    }\n    else {\n        $In::ABI{$LVer}{\"Arch\"} = getArch_GCC($LVer);\n    }\n    \n    $In::ABI{$LVer}{\"WordSize\"} = detectWordSize($LVer);\n    \n    $In::ABI{$LVer}{\"LibraryVersion\"} = $In::Desc{$LVer}{\"Version\"};\n    $In::ABI{$LVer}{\"LibraryName\"} = $In::Opt{\"TargetLib\"};\n    \n    if(not $In::ABI{$LVer}{\"Language\"}) {\n        $In::ABI{$LVer}{\"Language\"} = \"C\";\n    }\n    \n    if($In::Opt{\"UserLang\"}) {\n        $In::ABI{$LVer}{\"Language\"} = $In::Opt{\"UserLang\"};\n    }\n    \n    $In::ABI{$LVer}{\"GccVersion\"} = $In::Opt{\"GccVer\"};\n    \n    printMsg(\"INFO\", \"Checking header(s) \".$In::Desc{$LVer}{\"Version\"}.\" ...\");\n    my $TUDump = createTUDump($LVer);\n    \n    if($In::Opt{\"Debug\"})\n    { # debug mode\n        copy($TUDump, getDebugDir($LVer).\"/translation-unit-dump.txt\");\n    }\n    \n    readGccAst($LVer, $TUDump);\n    \n    if($In::Opt{\"DebugMangling\"})\n    {\n        if($In::ABI{$LVer}{\"Language\"} eq \"C++\")\n        {\n            debugMangling($LVer);\n        }\n    }\n    \n    delete($In::ABI{$LVer}{\"EnumConstants\"});\n    delete($In::ABI{$LVer}{\"ClassVTable_Content\"});\n    delete($In::ABI{$LVer}{\"WeakSymbols\"});\n    \n    cleanDump($LVer);\n    \n    if(not keys(%{$In::ABI{$LVer}{\"SymbolInfo\"}}))\n    { # check if created dump is valid\n        if(not $In::Opt{\"ExtendedCheck\"})\n        {\n            if($In::Opt{\"CheckHeadersOnly\"}) {\n                exitStatus(\"Empty_Set\", \"the set of public symbols is empty\");\n            }\n            else {\n                exitStatus(\"Empty_Intersection\", \"the sets of public symbols in headers and libraries have empty intersection\");\n            }\n        }\n    }\n    \n    foreach my $HPath (keys(%{$In::Desc{$LVer}{\"RegHeader\"}})) {\n        $In::ABI{$LVer}{\"Headers\"}{getFilename($HPath)} = 1;\n    }\n    \n    foreach my $InfoId (keys(%{$In::ABI{$LVer}{\"SymbolInfo\"}}))\n    {\n        if(my $MnglName = $In::ABI{$LVer}{\"SymbolInfo\"}{$InfoId}{\"MnglName\"})\n        {\n            if(my $Unmangled = getUnmangled($MnglName, $LVer)) {\n                $In::ABI{$LVer}{\"SymbolInfo\"}{$InfoId}{\"Unmangled\"} = $Unmangled;\n            }\n        }\n    }\n    \n    my %CompilerConstants = (); # built-in GCC constants\n    my $CRef = $In::ABI{$LVer}{\"Constants\"};\n    foreach my $Name (keys(%{$CRef}))\n    {\n        if(not defined $CRef->{$Name}{\"Header\"})\n        {\n            $CompilerConstants{$Name} = $CRef->{$Name}{\"Value\"};\n            delete($CRef->{$Name});\n        }\n    }\n    $In::ABI{$LVer}{\"CompilerConstants\"} = \\%CompilerConstants;\n    \n    if($In::Opt{\"ExtendedCheck\"})\n    { # --ext option\n        $In::ABI{$LVer}{\"Mode\"} = \"Extended\";\n    }\n    if($In::Opt{\"BinOnly\"})\n    { # --binary\n        $In::ABI{$LVer}{\"BinOnly\"} = 1;\n    }\n    if($In::Opt{\"ExtraDump\"})\n    { # --extra-dump\n        $In::ABI{$LVer}{\"Extra\"} = 1;\n    }\n    \n    $In::ABI{$LVer}{\"Target\"} = $In::Opt{\"Target\"};\n}\n\nsub readSymbols($)\n{\n    my $LVer = $_[0];\n    \n    my @LibPaths = getSOPaths($LVer);\n    if($#LibPaths==-1) {\n        exitStatus(\"Error\", \"library objects are not found\");\n    }\n    \n    foreach my $LibPath (@LibPaths) {\n        readSymbols_Lib($LVer, $LibPath, 0, \"+Weak\", 1, 1);\n    }\n    \n    if($In::Opt{\"CheckUndefined\"})\n    {\n        my %UndefinedLibs = ();\n        \n        my @Libs = (keys(%{$In::ABI{$LVer}{\"Symbols\"}}), keys(%{$In::ABI{$LVer}{\"DepSymbols\"}}));\n        \n        foreach my $LibName (sort @Libs)\n        {\n            if(defined $In::ABI{$LVer}{\"UndefinedSymbols\"}{$LibName})\n            {\n                foreach my $Symbol (keys(%{$In::ABI{$LVer}{\"UndefinedSymbols\"}{$LibName}}))\n                {\n                    if($In::ABI{$LVer}{\"SymLib\"}{$Symbol}\n                    or $In::ABI{$LVer}{\"DepSymLib\"}{$Symbol})\n                    { # exported by target library\n                        next;\n                    }\n                    if(index($Symbol, '@')!=-1)\n                    { # exported default symbol version (@@)\n                        $Symbol=~s/\\@/\\@\\@/;\n                        if($In::ABI{$LVer}{\"SymLib\"}{$Symbol}\n                        or $In::ABI{$LVer}{\"DepSymLib\"}{$Symbol}) {\n                            next;\n                        }\n                    }\n                    foreach my $Path (find_SymbolLibs($LVer, $Symbol)) {\n                        $UndefinedLibs{$Path} = 1;\n                    }\n                }\n            }\n        }\n        \n        if(my @Paths = sort keys(%UndefinedLibs))\n        {\n            my $LibString = \"\";\n            my %Dirs = ();\n            foreach (@Paths)\n            {\n                $KnownLibs{$_} = 1;\n                my ($Dir, $Name) = sepPath($_);\n                \n                if(not grep {$Dir eq $_} (@{$In::Opt{\"SysPaths\"}{\"lib\"}})) {\n                    $Dirs{escapeArg($Dir)} = 1;\n                }\n                \n                $Name = libPart($Name, \"name\");\n                $Name=~s/\\Alib//;\n                \n                $LibString .= \" -l$Name\";\n            }\n            \n            foreach my $Dir (sort {$b cmp $a} keys(%Dirs))\n            {\n                $LibString = \" -L\".escapeArg($Dir).$LibString;\n            }\n            \n            if($In::Opt{\"ExtraInfo\"}) {\n                writeFile($In::Opt{\"ExtraInfo\"}.\"/libs-string\", $LibString);\n            }\n        }\n    }\n    \n    if($In::Opt{\"ExtraInfo\"}) {\n        writeFile($In::Opt{\"ExtraInfo\"}.\"/lib-paths\", join(\"\\n\", sort keys(%KnownLibs)));\n    }\n}\n\nsub readSymbols_Lib($$$$$$)\n{\n    my ($LVer, $Lib_Path, $IsNeededLib, $Weak, $Deps, $Vers) = @_;\n    \n    my $Real_Path = realpath_F($Lib_Path);\n    \n    if(not $Real_Path)\n    { # broken link\n        return ();\n    }\n    \n    my $Lib_Name = getFilename($Real_Path);\n    my $LExt = $In::Opt{\"Ext\"};\n    \n    if($In::Opt{\"ExtraInfo\"})\n    {\n        $KnownLibs{$Real_Path} = 1;\n        $KnownLibs{$Lib_Path} = 1; # links\n    }\n    \n    if($IsNeededLib)\n    {\n        if($CheckedDyLib{$LVer}{$Lib_Name}) {\n            return ();\n        }\n    }\n    if($#RecurLib>=1 or isCyclical(\\@RecurLib, $Lib_Name)) {\n        return ();\n    }\n    $CheckedDyLib{$LVer}{$Lib_Name} = 1;\n    \n    my $TmpDir = $In::Opt{\"Tmp\"};\n    \n    push(@RecurLib, $Lib_Name);\n    my (%Value_Interface, %Interface_Value, %NeededLib) = ();\n    my $Lib_ShortName = libPart($Lib_Name, \"name+ext\");\n    \n    if(not $IsNeededLib)\n    { # special cases: libstdc++ and libc\n        if(my $ShortName = libPart($Lib_Name, \"short\"))\n        {\n            if($ShortName eq \"libstdc++\"\n            or $ShortName eq \"libc++\")\n            { # libstdc++.so.6\n                $In::Opt{\"StdcxxTesting\"} = 1;\n            }\n            elsif($ShortName eq \"libc\")\n            { # libc-2.11.3.so\n                $In::Opt{\"GlibcTesting\"} = 1;\n            }\n        }\n    }\n    my $DebugPath = \"\";\n    if($In::Opt{\"Debug\"} and not $In::Opt{\"DumpSystem\"})\n    { # debug mode\n        $DebugPath = getDebugDir($LVer).\"/libs/\".getFilename($Lib_Path).\".txt\";\n        mkpath(getDirname($DebugPath));\n    }\n    if($In::Opt{\"Target\"} eq \"macos\")\n    { # Mac OS X: *.dylib, *.a\n        my $NM = getCmdPath(\"nm\");\n        if(not $NM) {\n            exitStatus(\"Not_Found\", \"can't find \\\"nm\\\"\");\n        }\n        $NM .= \" -g \\\"$Lib_Path\\\" 2>\\\"$TmpDir/null\\\"\";\n        if($DebugPath)\n        { # debug mode\n          # write to file\n            system($NM.\" >\\\"$DebugPath\\\"\");\n            open(LIB, $DebugPath);\n        }\n        else\n        { # write to pipe\n            open(LIB, $NM.\" |\");\n        }\n        while(<LIB>)\n        {\n            if($In::Opt{\"CheckUndefined\"})\n            {\n                if(not $IsNeededLib)\n                {\n                    if(/ U _([\\w\\$]+)\\s*\\Z/)\n                    {\n                        $In::ABI{$LVer}{\"UndefinedSymbols\"}{$Lib_Name}{$1} = 0;\n                        next;\n                    }\n                }\n            }\n            \n            if(/ [STD] _([\\w\\$]+)\\s*\\Z/)\n            {\n                my $Symbol = $1;\n                if($IsNeededLib)\n                {\n                    if(not defined $RegisteredObj_Short{$LVer}{$Lib_ShortName})\n                    {\n                        $In::ABI{$LVer}{\"DepSymLib\"}{$Symbol} = $Lib_Name;\n                        $In::ABI{$LVer}{\"DepSymbols\"}{$Lib_Name}{$Symbol} = 1;\n                    }\n                }\n                else\n                {\n                    $In::ABI{$LVer}{\"SymLib\"}{$Symbol} = $Lib_Name;\n                    $In::ABI{$LVer}{\"Symbols\"}{$Lib_Name}{$Symbol} = 1;\n                    if($In::ABI{$LVer}{\"Language\"} ne \"C++\")\n                    {\n                        if(index($Symbol, \"_Z\")==0 or index($Symbol, \"?\")==0) {\n                            $In::ABI{$LVer}{\"Language\"} = \"C++\";\n                        }\n                    }\n                }\n            }\n        }\n        close(LIB);\n        \n        if($Deps)\n        {\n            if(not $In::Opt{\"UseStaticLibs\"})\n            { # dependencies\n                my $OtoolCmd = getCmdPath(\"otool\");\n                if(not $OtoolCmd) {\n                    exitStatus(\"Not_Found\", \"can't find \\\"otool\\\"\");\n                }\n                \n                open(LIB, \"$OtoolCmd -L \\\"$Lib_Path\\\" 2>\\\"$TmpDir/null\\\" |\");\n                while(<LIB>)\n                {\n                    if(/\\s*([\\/\\\\].+\\.$LExt)\\s*/\n                    and $1 ne $Lib_Path) {\n                        $NeededLib{$1} = 1;\n                    }\n                }\n                close(LIB);\n            }\n        }\n    }\n    elsif($In::Opt{\"Target\"} eq \"windows\")\n    { # Windows *.dll, *.lib\n        my $DumpBinCmd = getCmdPath(\"dumpbin\");\n        if(not $DumpBinCmd) {\n            exitStatus(\"Not_Found\", \"can't find \\\"dumpbin\\\"\");\n        }\n        $DumpBinCmd .= \" /EXPORTS \\\"\".$Lib_Path.\"\\\" 2>$TmpDir/null\";\n        if($DebugPath)\n        { # debug mode\n          # write to file\n            system($DumpBinCmd.\" >\\\"$DebugPath\\\"\");\n            open(LIB, $DebugPath);\n        }\n        else\n        { # write to pipe\n            open(LIB, $DumpBinCmd.\" |\");\n        }\n        while(<LIB>)\n        {\n            my $Symbol = undef;\n            if($In::Opt{\"UseStaticLibs\"})\n            {\n                if(/\\A\\s{10,}(\\d+\\s+|)([_\\w\\?\\@]+)(\\s*\\Z|\\s+)/i)\n                {\n                    # 16 IID_ISecurityInformation\n                    # ??_7TestBaseClass@api@@6B@ (const api::TestBaseClass::`vftable')\n                    $Symbol = $2;\n                }\n            }\n            else\n            { # Dll\n                # 1197 4AC 0000A620 SetThreadStackGuarantee\n                # 1198 4AD          SetThreadToken (forwarded to ...)\n                # 3368 _o2i_ECPublicKey\n                # 1 0 00005B30 ??0?N = ... (with pdb)\n                if(/\\A\\s*\\d+\\s+[a-f\\d]+\\s+[a-f\\d]+\\s+([\\w\\?\\@]+)\\s*(?:=.+)?\\Z/i\n                or /\\A\\s*\\d+\\s+[a-f\\d]+\\s+([\\w\\?\\@]+)\\s*\\(\\s*forwarded\\s+/\n                or /\\A\\s*\\d+\\s+_([\\w\\?\\@]+)\\s*(?:=.+)?\\Z/)\n                { # dynamic, static and forwarded symbols\n                    $Symbol = $1;\n                }\n            }\n            \n            if($Symbol)\n            {\n                if($IsNeededLib)\n                {\n                    if(not defined $RegisteredObj_Short{$LVer}{$Lib_ShortName})\n                    {\n                        $In::ABI{$LVer}{\"DepSymLib\"}{$Symbol} = $Lib_Name;\n                        $In::ABI{$LVer}{\"DepSymbols\"}{$Lib_Name}{$Symbol} = 1;\n                    }\n                }\n                else\n                {\n                    $In::ABI{$LVer}{\"SymLib\"}{$Symbol} = $Lib_Name;\n                    $In::ABI{$LVer}{\"Symbols\"}{$Lib_Name}{$Symbol} = 1;\n                    if($In::ABI{$LVer}{\"Language\"} ne \"C++\")\n                    {\n                        if(index($Symbol, \"_Z\")==0 or index($Symbol, \"?\")==0) {\n                            $In::ABI{$LVer}{\"Language\"} = \"C++\";\n                        }\n                    }\n                }\n            }\n        }\n        close(LIB);\n        \n        if($Deps)\n        {\n            if(not $In::Opt{\"UseStaticLibs\"})\n            { # dependencies\n                open(LIB, \"$DumpBinCmd /DEPENDENTS \\\"$Lib_Path\\\" 2>\\\"$TmpDir/null\\\" |\");\n                while(<LIB>)\n                {\n                    if(/\\s*([^\\s]+?\\.$LExt)\\s*/i\n                    and $1 ne $Lib_Path) {\n                        $NeededLib{pathFmt($1)} = 1;\n                    }\n                }\n                close(LIB);\n            }\n        }\n    }\n    else\n    { # Unix; *.so, *.a\n      # Symbian: *.dso, *.lib\n        my $ReadelfCmd = getCmdPath(\"readelf\");\n        if(not $ReadelfCmd) {\n            exitStatus(\"Not_Found\", \"can't find \\\"readelf\\\"\");\n        }\n        my $Cmd = $ReadelfCmd.\" -Ws \\\"$Lib_Path\\\" 2>\\\"$TmpDir/null\\\"\";\n        if($DebugPath)\n        { # debug mode\n          # write to file\n            system($Cmd.\" >\\\"$DebugPath\\\"\");\n            open(LIB, $DebugPath);\n        }\n        else\n        { # write to pipe\n            open(LIB, $Cmd.\" |\");\n        }\n        my $symtab = undef; # indicates that we are processing 'symtab' section of 'readelf' output\n        while(<LIB>)\n        {\n            if(not $In::Opt{\"UseStaticLibs\"})\n            { # dynamic library specifics\n                if(defined $symtab)\n                {\n                    if(index($_, \"'.dynsym'\")!=-1)\n                    { # dynamic table\n                        $symtab = undef;\n                    }\n                    # do nothing with symtab\n                    next;\n                }\n                elsif(index($_, \"'.symtab'\")!=-1)\n                { # symbol table\n                    $symtab = 1;\n                    next;\n                }\n            }\n            if(my ($Value, $Size, $Type, $Bind, $Vis, $Ndx, $Symbol) = readline_ELF($_))\n            { # read ELF entry\n                if($Ndx eq \"UND\")\n                { # ignore interfaces that are imported from somewhere else\n                    if($In::Opt{\"CheckUndefined\"})\n                    {\n                        if(not $IsNeededLib) {\n                            $In::ABI{$LVer}{\"UndefinedSymbols\"}{$Lib_Name}{$Symbol} = 0;\n                        }\n                    }\n                    next;\n                }\n                if($Bind eq \"WEAK\")\n                {\n                    $In::ABI{$LVer}{\"WeakSymbols\"}{$Symbol} = 1;\n                    if($Weak eq \"-Weak\")\n                    { # skip WEAK symbols\n                        next;\n                    }\n                }\n                if($IsNeededLib)\n                {\n                    if(not defined $RegisteredObj_Short{$LVer}{$Lib_ShortName})\n                    {\n                        $In::ABI{$LVer}{\"DepSymLib\"}{$Symbol} = $Lib_Name;\n                        $In::ABI{$LVer}{\"DepSymbols\"}{$Lib_Name}{$Symbol} = ($Type eq \"OBJECT\")?-$Size:1;\n                    }\n                }\n                else\n                {\n                    $In::ABI{$LVer}{\"SymLib\"}{$Symbol} = $Lib_Name;\n                    $In::ABI{$LVer}{\"Symbols\"}{$Lib_Name}{$Symbol} = ($Type eq \"OBJECT\")?-$Size:1;\n                    if($Vers)\n                    {\n                        if($LExt eq \"so\")\n                        { # value\n                            $Interface_Value{$LVer}{$Symbol} = $Value;\n                            $Value_Interface{$LVer}{$Value}{$Symbol} = 1;\n                        }\n                    }\n                    if($In::ABI{$LVer}{\"Language\"} ne \"C++\")\n                    {\n                        if(index($Symbol, \"_Z\")==0 or index($Symbol, \"?\")==0) {\n                            $In::ABI{$LVer}{\"Language\"} = \"C++\";\n                        }\n                    }\n                }\n            }\n        }\n        close(LIB);\n        \n        if($Deps and not $In::Opt{\"UseStaticLibs\"})\n        { # dynamic library specifics\n            $Cmd = $ReadelfCmd.\" -Wd \\\"$Lib_Path\\\" 2>\\\"$TmpDir/null\\\"\";\n            open(LIB, $Cmd.\" |\");\n            \n            while(<LIB>)\n            {\n                if(/NEEDED.+\\[([^\\[\\]]+)\\]/)\n                { # dependencies:\n                  # 0x00000001 (NEEDED) Shared library: [libc.so.6]\n                    $NeededLib{$1} = 1;\n                }\n            }\n            \n            close(LIB);\n        }\n    }\n    if($Vers)\n    {\n        if(not $IsNeededLib and $LExt eq \"so\")\n        { # get symbol versions\n            my %Found = ();\n            \n            # by value\n            foreach my $Symbol (sort keys(%{$In::ABI{$LVer}{\"Symbols\"}{$Lib_Name}}))\n            {\n                next if(index($Symbol, '@')==-1);\n                if(my $Value = $Interface_Value{$LVer}{$Symbol})\n                {\n                    foreach my $Symbol_SameValue (sort keys(%{$Value_Interface{$LVer}{$Value}}))\n                    {\n                        if($Symbol_SameValue ne $Symbol\n                        and index($Symbol_SameValue, '@')==-1)\n                        {\n                            $In::ABI{$LVer}{\"SymbolVersion\"}{$Symbol_SameValue} = $Symbol;\n                            $Found{$Symbol} = 1;\n                            \n                            if(index($Symbol, '@@')==-1) {\n                                last;\n                            }\n                        }\n                    }\n                }\n            }\n            \n            # default\n            foreach my $Symbol (keys(%{$In::ABI{$LVer}{\"Symbols\"}{$Lib_Name}}))\n            {\n                next if(defined $Found{$Symbol});\n                next if(index($Symbol, '@@')==-1);\n                \n                if($Symbol=~/\\A([^\\@]*)\\@\\@/\n                and not $In::ABI{$LVer}{\"SymbolVersion\"}{$1})\n                {\n                    $In::ABI{$LVer}{\"SymbolVersion\"}{$1} = $Symbol;\n                    $Found{$Symbol} = 1;\n                }\n            }\n            \n            # non-default\n            foreach my $Symbol (keys(%{$In::ABI{$LVer}{\"Symbols\"}{$Lib_Name}}))\n            {\n                next if(defined $Found{$Symbol});\n                next if(index($Symbol, '@')==-1);\n                \n                if($Symbol=~/\\A([^\\@]*)\\@([^\\@]*)/\n                and not $In::ABI{$LVer}{\"SymbolVersion\"}{$1})\n                {\n                    $In::ABI{$LVer}{\"SymbolVersion\"}{$1} = $Symbol;\n                    $Found{$Symbol} = 1;\n                }\n            }\n        }\n    }\n    if($Deps)\n    {\n        foreach my $DyLib (sort keys(%NeededLib))\n        {\n            if($In::Opt{\"ExtraDump\"}) {\n                $In::ABI{$LVer}{\"Needed\"}{$Lib_Name}{getFilename($DyLib)} = 1;\n            }\n            \n            if(my $DepPath = getLibPath($LVer, $DyLib))\n            {\n                if(not $CheckedDyLib{$LVer}{getFilename($DepPath)}) {\n                    readSymbols_Lib($LVer, $DepPath, 1, \"+Weak\", $Deps, $Vers);\n                }\n            }\n        }\n    }\n    pop(@RecurLib);\n    return $In::ABI{$LVer}{\"Symbols\"};\n}\n\nsub readSymbols_App($)\n{\n    my $Path = $_[0];\n    \n    my $TmpDir = $In::Opt{\"Tmp\"};\n    \n    my @Imported = ();\n    if($In::Opt{\"Target\"} eq \"macos\")\n    {\n        my $NM = getCmdPath(\"nm\");\n        if(not $NM) {\n            exitStatus(\"Not_Found\", \"can't find \\\"nm\\\"\");\n        }\n        open(APP, \"$NM -g \\\"$Path\\\" 2>\\\"$TmpDir/null\\\" |\");\n        while(<APP>)\n        {\n            if(/ U _([\\w\\$]+)\\s*\\Z/) {\n                push(@Imported, $1);\n            }\n        }\n        close(APP);\n    }\n    elsif($In::Opt{\"Target\"} eq \"windows\")\n    {\n        my $DumpBinCmd = getCmdPath(\"dumpbin\");\n        if(not $DumpBinCmd) {\n            exitStatus(\"Not_Found\", \"can't find \\\"dumpbin.exe\\\"\");\n        }\n        open(APP, \"$DumpBinCmd /IMPORTS \\\"$Path\\\" 2>\\\"$TmpDir/null\\\" |\");\n        while(<APP>)\n        {\n            if(/\\s*\\w+\\s+\\w+\\s+\\w+\\s+([\\w\\?\\@]+)\\s*/) {\n                push(@Imported, $1);\n            }\n        }\n        close(APP);\n    }\n    else\n    {\n        my $ReadelfCmd = getCmdPath(\"readelf\");\n        if(not $ReadelfCmd) {\n            exitStatus(\"Not_Found\", \"can't find \\\"readelf\\\"\");\n        }\n        open(APP, \"$ReadelfCmd -Ws \\\"$Path\\\" 2>\\\"$TmpDir/null\\\" |\");\n        my $symtab = undef; # indicates that we are processing 'symtab' section of 'readelf' output\n        while(<APP>)\n        {\n            if(defined $symtab)\n            { # do nothing with symtab\n                if(index($_, \"'.dynsym'\")!=-1)\n                { # dynamic table\n                    $symtab = undef;\n                }\n            }\n            elsif(index($_, \"'.symtab'\")!=-1)\n            { # symbol table\n                $symtab = 1;\n            }\n            elsif(my @Info = readline_ELF($_))\n            {\n                my ($Ndx, $Symbol) = ($Info[5], $Info[6]);\n                if($Ndx eq \"UND\")\n                { # only imported symbols\n                    push(@Imported, $Symbol);\n                }\n            }\n        }\n        close(APP);\n    }\n    return @Imported;\n}\n\nsub cleanDump($)\n{ # clean data\n    my $LVer = $_[0];\n    foreach my $InfoId (keys(%{$In::ABI{$LVer}{\"SymbolInfo\"}}))\n    {\n        if(not keys(%{$In::ABI{$LVer}{\"SymbolInfo\"}{$InfoId}}))\n        {\n            delete($In::ABI{$LVer}{\"SymbolInfo\"}{$InfoId});\n            next;\n        }\n        my $MnglName = $In::ABI{$LVer}{\"SymbolInfo\"}{$InfoId}{\"MnglName\"};\n        if(not $MnglName)\n        {\n            delete($In::ABI{$LVer}{\"SymbolInfo\"}{$InfoId});\n            next;\n        }\n        my $ShortName = $In::ABI{$LVer}{\"SymbolInfo\"}{$InfoId}{\"ShortName\"};\n        if(not $ShortName)\n        {\n            delete($In::ABI{$LVer}{\"SymbolInfo\"}{$InfoId});\n            next;\n        }\n        if($MnglName eq $ShortName)\n        { # remove duplicate data\n            delete($In::ABI{$LVer}{\"SymbolInfo\"}{$InfoId}{\"MnglName\"});\n        }\n        if(not keys(%{$In::ABI{$LVer}{\"SymbolInfo\"}{$InfoId}{\"Param\"}})) {\n            delete($In::ABI{$LVer}{\"SymbolInfo\"}{$InfoId}{\"Param\"});\n        }\n        if(not keys(%{$In::ABI{$LVer}{\"SymbolInfo\"}{$InfoId}{\"TParam\"}})) {\n            delete($In::ABI{$LVer}{\"SymbolInfo\"}{$InfoId}{\"TParam\"});\n        }\n        delete($In::ABI{$LVer}{\"SymbolInfo\"}{$InfoId}{\"Type\"});\n    }\n    foreach my $Tid (keys(%{$In::ABI{$LVer}{\"TypeInfo\"}}))\n    {\n        if(not keys(%{$In::ABI{$LVer}{\"TypeInfo\"}{$Tid}}))\n        {\n            delete($In::ABI{$LVer}{\"TypeInfo\"}{$Tid});\n            next;\n        }\n        delete($In::ABI{$LVer}{\"TypeInfo\"}{$Tid}{\"Tid\"});\n        foreach my $Attr (\"Header\", \"Line\", \"Size\", \"NameSpace\")\n        {\n            if(not $In::ABI{$LVer}{\"TypeInfo\"}{$Tid}{$Attr}) {\n                delete($In::ABI{$LVer}{\"TypeInfo\"}{$Tid}{$Attr});\n            }\n        }\n        if(not keys(%{$In::ABI{$LVer}{\"TypeInfo\"}{$Tid}{\"TParam\"}})) {\n            delete($In::ABI{$LVer}{\"TypeInfo\"}{$Tid}{\"TParam\"});\n        }\n    }\n}\n\nsub readLibs($)\n{\n    my $LVer = $_[0];\n    \n    if($In::Opt{\"Target\"} eq \"windows\")\n    { # dumpbin.exe will crash\n        # without VS Environment\n        checkWin32Env();\n    }\n    \n    readSymbols($LVer);\n    \n    translateSymbols(keys(%{$In::ABI{$LVer}{\"SymLib\"}}), $LVer);\n    translateSymbols(keys(%{$In::ABI{$LVer}{\"DepSymLib\"}}), $LVer);\n}\n\nsub getSOPaths($)\n{\n    my $LVer = $_[0];\n    my @Paths = ();\n    foreach my $P (keys(%{$In::Desc{$LVer}{\"Libs\"}}))\n    {\n        my @Found = getSOPaths_Dir(getAbsPath($P), $LVer);\n        foreach (@Found) {\n            push(@Paths, $_);\n        }\n    }\n    return sort @Paths;\n}\n\nsub getSOPaths_Dir($$)\n{\n    my ($Path, $LVer) = @_;\n    if(skipLib($Path, $LVer)) {\n        return ();\n    }\n    \n    my $LExt = $In::Opt{\"Ext\"};\n    \n    if(-f $Path)\n    {\n        if(not libPart($Path, \"name\")) {\n            exitStatus(\"Error\", \"incorrect format of library (should be *.$LExt): \\'$Path\\'\");\n        }\n        registerObject($Path, $LVer);\n        registerObject_Dir(getDirname($Path), $LVer);\n        return ($Path);\n    }\n    elsif(-d $Path)\n    {\n        $Path=~s/[\\/\\\\]+\\Z//g;\n        my %Libs = ();\n        if(my $TN = $In::Opt{\"TargetLib\"}\n        and grep { $Path eq $_ } @{$In::Opt{\"SysPaths\"}{\"lib\"}})\n        { # you have specified /usr/lib as the search directory (<libs>) in the XML descriptor\n          # and the real name of the library by -l option (bz2, stdc++, Xaw, ...)\n            foreach my $P (cmdFind($Path,\"\",\"*\".escapeArg($TN).\"*.$LExt*\",2))\n            { # all files and symlinks that match the name of a library\n                if(getFilename($P)=~/\\A(|lib)\\Q$TN\\E[\\d\\-]*\\.$LExt[\\d\\.]*\\Z/i)\n                {\n                    registerObject($P, $LVer);\n                    $Libs{realpath_F($P)} = 1;\n                }\n            }\n        }\n        else\n        { # search for all files and symlinks\n            foreach my $P (findLibs($Path,\"\",\"\"))\n            {\n                next if(ignorePath($P));\n                next if(skipLib($P, $LVer));\n                registerObject($P, $LVer);\n                $Libs{realpath_F($P)} = 1;\n            }\n            if($In::Opt{\"OS\"} eq \"macos\")\n            { # shared libraries on MacOS X may have no extension\n                foreach my $P (cmdFind($Path,\"f\"))\n                {\n                    next if(ignorePath($P));\n                    next if(skipLib($P, $LVer));\n                    if(getFilename($P)!~/\\./ and -B $P\n                    and cmdFile($P)=~/(shared|dynamic)\\s+library/i)\n                    {\n                        registerObject($P, $LVer);\n                        $Libs{realpath_F($P)} = 1;\n                    }\n                }\n            }\n        }\n        return keys(%Libs);\n    }\n    \n    return ();\n}\n\nsub registerObject_Dir($$)\n{\n    my ($Dir, $LVer) = @_;\n    if(grep {$_ eq $Dir} @{$In::Opt{\"SysPaths\"}{\"lib\"}})\n    { # system directory\n        return;\n    }\n    if($RegisteredObj_Dir{$LVer}{$Dir})\n    { # already registered\n        return;\n    }\n    foreach my $Path (findLibs($Dir,\"\",1))\n    {\n        if(ignorePath($Path)) {\n            next;\n        }\n        if(skipLib($Path, $LVer)) {\n            next;\n        }\n        registerObject($Path, $LVer);\n    }\n    $RegisteredObj_Dir{$LVer}{$Dir} = 1;\n}\n\nsub registerObject($$)\n{\n    my ($Path, $LVer) = @_;\n    \n    my $Name = getFilename($Path);\n    $RegisteredObj{$LVer}{$Name} = $Path;\n    if($In::Opt{\"Target\"}=~/linux|bsd|gnu|solaris/i)\n    {\n        if(my $SONAME = getSONAME($Path)) {\n            $RegisteredSoname{$LVer}{$SONAME} = $Path;\n        }\n    }\n    if(my $Short = libPart($Name, \"name+ext\")) {\n        $RegisteredObj_Short{$LVer}{$Short} = $Path;\n    }\n    \n    if(not $CheckedArch{$LVer} and -f $Path)\n    {\n        if(my $ObjArch = getArch_Object($Path))\n        {\n            if($ObjArch ne getArch_GCC($LVer))\n            { # translation unit dump generated by the GCC compiler should correspond to input objects\n                $CheckedArch{$LVer} = 1;\n                printMsg(\"WARNING\", \"the architectures of input objects and the used GCC compiler are not equal, please change the compiler by --gcc-path=PATH option.\");\n            }\n        }\n    }\n}\n\nsub remove_Unused($$)\n{ # remove unused data types from the ABI dump\n    my ($LVer, $Kind) = @_;\n    \n    my %UsedType = ();\n    \n    foreach my $InfoId (sort {$a<=>$b} keys(%{$In::ABI{$LVer}{\"SymbolInfo\"}}))\n    {\n        registerSymbolUsage($InfoId, \\%UsedType, $LVer);\n    }\n    foreach my $Tid (sort {$a<=>$b} keys(%{$In::ABI{$LVer}{\"TypeInfo\"}}))\n    {\n        if($UsedType{$Tid})\n        { # All & Extended\n            next;\n        }\n        \n        if($Kind eq \"Extended\")\n        {\n            if(pickType($Tid, $LVer))\n            {\n                my %Tree = ();\n                registerTypeUsage($Tid, \\%Tree, $LVer);\n                \n                my $Tmpl = 0;\n                foreach (sort {$a<=>$b} keys(%Tree))\n                {\n                    if(defined $In::ABI{$LVer}{\"TypeInfo\"}{$_}{\"Template\"}\n                    or $In::ABI{$LVer}{\"TypeInfo\"}{$_}{\"Type\"} eq \"TemplateParam\")\n                    {\n                        $Tmpl = 1;\n                        last;\n                    }\n                }\n                if(not $Tmpl)\n                {\n                    foreach (keys(%Tree)) {\n                        $UsedType{$_} = 1;\n                    }\n                }\n            }\n        }\n    }\n    \n    my %Delete = ();\n    \n    foreach my $Tid (sort {$a<=>$b} keys(%{$In::ABI{$LVer}{\"TypeInfo\"}}))\n    { # remove unused types\n        if($UsedType{$Tid})\n        { # All & Extended\n            next;\n        }\n        \n        if($Kind eq \"Extra\")\n        {\n            my %Tree = ();\n            registerTypeUsage($Tid, \\%Tree, $LVer);\n            \n            foreach (sort {$a<=>$b} keys(%Tree))\n            {\n                if(defined $In::ABI{$LVer}{\"TypeInfo\"}{$_}{\"Template\"}\n                or $In::ABI{$LVer}{\"TypeInfo\"}{$_}{\"Type\"} eq \"TemplateParam\")\n                {\n                    $Delete{$Tid} = 1;\n                    last;\n                }\n            }\n        }\n        else\n        {\n            # remove type\n            delete($In::ABI{$LVer}{\"TypeInfo\"}{$Tid});\n        }\n    }\n    \n    if($Kind eq \"Extra\")\n    { # remove duplicates\n        foreach my $Tid (sort {$a<=>$b} keys(%{$In::ABI{$LVer}{\"TypeInfo\"}}))\n        {\n            if($UsedType{$Tid})\n            { # All & Extended\n                next;\n            }\n            \n            my $Name = $In::ABI{$LVer}{\"TypeInfo\"}{$Tid}{\"Name\"};\n            \n            if($In::ABI{$LVer}{\"TName_Tid\"}{$Name} ne $Tid) {\n                delete($In::ABI{$LVer}{\"TypeInfo\"}{$Tid});\n            }\n        }\n    }\n    \n    foreach my $Tid (keys(%Delete))\n    {\n        delete($In::ABI{$LVer}{\"TypeInfo\"}{$Tid});\n    }\n}\n\nsub getFirst($$)\n{\n    my ($Tid, $LVer) = @_;\n    if(not $Tid) {\n        return $Tid;\n    }\n    \n    if(my $Name = $In::ABI{$LVer}{\"TypeInfo\"}{$Tid}{\"Name\"})\n    {\n        if($In::ABI{$LVer}{\"TName_Tid\"}{$Name}) {\n            return $In::ABI{$LVer}{\"TName_Tid\"}{$Name};\n        }\n    }\n    \n    return $Tid;\n}\n\nsub registerSymbolUsage($$$)\n{\n    my ($InfoId, $UsedType, $LVer) = @_;\n    \n    my %FuncInfo = %{$In::ABI{$LVer}{\"SymbolInfo\"}{$InfoId}};\n    if(my $RTid = getFirst($FuncInfo{\"Return\"}, $LVer))\n    {\n        registerTypeUsage($RTid, $UsedType, $LVer);\n        $In::ABI{$LVer}{\"SymbolInfo\"}{$InfoId}{\"Return\"} = $RTid;\n    }\n    if(my $FCid = getFirst($FuncInfo{\"Class\"}, $LVer))\n    {\n        registerTypeUsage($FCid, $UsedType, $LVer);\n        $In::ABI{$LVer}{\"SymbolInfo\"}{$InfoId}{\"Class\"} = $FCid;\n        \n        if(my $ThisId = getTypeIdByName($In::ABI{$LVer}{\"TypeInfo\"}{$FCid}{\"Name\"}.\"*const\", $LVer))\n        { # register \"this\" pointer\n            registerTypeUsage($ThisId, $UsedType, $LVer);\n        }\n        if(my $ThisId_C = getTypeIdByName($In::ABI{$LVer}{\"TypeInfo\"}{$FCid}{\"Name\"}.\" const*const\", $LVer))\n        { # register \"this\" pointer (const method)\n            registerTypeUsage($ThisId_C, $UsedType, $LVer);\n        }\n    }\n    foreach my $PPos (sort {$a<=>$b} keys(%{$FuncInfo{\"Param\"}}))\n    {\n        if(my $PTid = getFirst($FuncInfo{\"Param\"}{$PPos}{\"type\"}, $LVer))\n        {\n            registerTypeUsage($PTid, $UsedType, $LVer);\n            $FuncInfo{\"Param\"}{$PPos}{\"type\"} = $PTid;\n        }\n    }\n    foreach my $TPos (sort {$a<=>$b} keys(%{$FuncInfo{\"TParam\"}}))\n    {\n        my $TPName = $FuncInfo{\"TParam\"}{$TPos}{\"name\"};\n        if(my $TTid = $In::ABI{$LVer}{\"TName_Tid\"}{$TPName}) {\n            registerTypeUsage($TTid, $UsedType, $LVer);\n        }\n    }\n}\n\nsub registerTypeUsage($$$)\n{\n    my ($TypeId, $UsedType, $LVer) = @_;\n    if(not $TypeId) {\n        return;\n    }\n    if($UsedType->{$TypeId})\n    { # already registered\n        return;\n    }\n    \n    my %TInfo = getType($TypeId, $LVer);\n    if($TInfo{\"Type\"})\n    {\n        if(my $NS = $TInfo{\"NameSpace\"})\n        {\n            if(my $NSTid = $In::ABI{$LVer}{\"TName_Tid\"}{$NS}) {\n                registerTypeUsage($NSTid, $UsedType, $LVer);\n            }\n        }\n        \n        if($TInfo{\"Type\"}=~/\\A(Struct|Union|Class|FuncPtr|Func|MethodPtr|FieldPtr|Enum)\\Z/)\n        {\n            $UsedType->{$TypeId} = 1;\n            if($TInfo{\"Type\"}=~/\\A(Struct|Class)\\Z/)\n            {\n                foreach my $BaseId (sort {$a<=>$b} keys(%{$TInfo{\"Base\"}})) {\n                    registerTypeUsage($BaseId, $UsedType, $LVer);\n                }\n                foreach my $TPos (sort {$a<=>$b} keys(%{$TInfo{\"TParam\"}}))\n                {\n                    my $TPName = $TInfo{\"TParam\"}{$TPos}{\"name\"};\n                    if(my $TTid = $In::ABI{$LVer}{\"TName_Tid\"}{$TPName}) {\n                        registerTypeUsage($TTid, $UsedType, $LVer);\n                    }\n                }\n            }\n            foreach my $Memb_Pos (sort {$a<=>$b} keys(%{$TInfo{\"Memb\"}}))\n            {\n                if(my $MTid = getFirst($TInfo{\"Memb\"}{$Memb_Pos}{\"type\"}, $LVer))\n                {\n                    registerTypeUsage($MTid, $UsedType, $LVer);\n                    $TInfo{\"Memb\"}{$Memb_Pos}{\"type\"} = $MTid;\n                }\n            }\n            if($TInfo{\"Type\"} eq \"FuncPtr\"\n            or $TInfo{\"Type\"} eq \"MethodPtr\"\n            or $TInfo{\"Type\"} eq \"Func\")\n            {\n                if(my $RTid = $TInfo{\"Return\"}) {\n                    registerTypeUsage($RTid, $UsedType, $LVer);\n                }\n                foreach my $PPos (sort {$a<=>$b} keys(%{$TInfo{\"Param\"}}))\n                {\n                    if(my $PTid = $TInfo{\"Param\"}{$PPos}{\"type\"}) {\n                        registerTypeUsage($PTid, $UsedType, $LVer);\n                    }\n                }\n            }\n            if($TInfo{\"Type\"} eq \"FieldPtr\")\n            {\n                if(my $RTid = $TInfo{\"Return\"}) {\n                    registerTypeUsage($RTid, $UsedType, $LVer);\n                }\n                if(my $CTid = $TInfo{\"Class\"}) {\n                    registerTypeUsage($CTid, $UsedType, $LVer);\n                }\n            }\n            if($TInfo{\"Type\"} eq \"MethodPtr\")\n            {\n                if(my $CTid = $TInfo{\"Class\"}) {\n                    registerTypeUsage($CTid, $UsedType, $LVer);\n                }\n            }\n        }\n        elsif($TInfo{\"Type\"}=~/\\A(Const|ConstVolatile|Volatile|Pointer|Ref|Restrict|Array|Typedef)\\Z/)\n        {\n            $UsedType->{$TypeId} = 1;\n            if(my $BTid = getFirst($TInfo{\"BaseType\"}, $LVer))\n            {\n                registerTypeUsage($BTid, $UsedType, $LVer);\n                $In::ABI{$LVer}{\"TypeInfo\"}{$TypeId}{\"BaseType\"} = $BTid;\n            }\n        }\n        else\n        { # Intrinsic, TemplateParam, TypeName, SizeOf, etc.\n            $UsedType->{$TypeId} = 1;\n        }\n    }\n}\n\nsub detectWordSize($)\n{\n    my $LVer = $_[0];\n    \n    my $Size = undef;\n    \n    # speed up detection\n    if(my $Arch = $In::ABI{$LVer}{\"Arch\"})\n    {\n        if($Arch=~/\\A(x86_64|s390x|ppc64|ia64|alpha)\\Z/) {\n            $Size = \"8\";\n        }\n        elsif($Arch=~/\\A(x86|s390|ppc32)\\Z/) {\n            $Size = \"4\";\n        }\n    }\n    \n    if(my $GccPath = $In::Opt{\"GccPath\"})\n    {\n        my $TmpDir = $In::Opt{\"Tmp\"};\n        writeFile(\"$TmpDir/empty.h\", \"\");\n        \n        my $Cmd = $GccPath.\" -E -dD empty.h\";\n        if(my $Opts = getGccOptions($LVer))\n        { # user-defined options\n            $Cmd .= \" \".$Opts;\n        }\n        \n        chdir($TmpDir);\n        my $Defines = `$Cmd`;\n        chdir($In::Opt{\"OrigDir\"});\n        \n        unlink(\"$TmpDir/empty.h\");\n        \n        if($Defines=~/ __SIZEOF_POINTER__\\s+(\\d+)/)\n        { # GCC 4\n            $Size = $1;\n        }\n        elsif($Defines=~/ __PTRDIFF_TYPE__\\s+(\\w+)/)\n        { # GCC 3\n            my $PTRDIFF = $1;\n            if($PTRDIFF=~/long/) {\n                $Size = \"8\";\n            }\n            else {\n                $Size = \"4\";\n            }\n        }\n    }\n    \n    if(not $Size) {\n        exitStatus(\"Error\", \"can't check WORD size\");\n    }\n    \n    return $Size;\n}\n\nsub getLibPath($$)\n{\n    my ($LVer, $Name) = @_;\n    if(defined $Cache{\"getLibPath\"}{$LVer}{$Name}) {\n        return $Cache{\"getLibPath\"}{$LVer}{$Name};\n    }\n    return ($Cache{\"getLibPath\"}{$LVer}{$Name} = getLibPath_I($LVer, $Name));\n}\n\nsub getLibPath_I($$)\n{\n    my ($LVer, $Name) = @_;\n    if(isAbsPath($Name))\n    {\n        if(-f $Name)\n        { # absolute path\n            return $Name;\n        }\n        else\n        { # broken\n            return \"\";\n        }\n    }\n    if(defined $RegisteredObj{$LVer}{$Name})\n    { # registered paths\n        return $RegisteredObj{$LVer}{$Name};\n    }\n    if(defined $RegisteredSoname{$LVer}{$Name})\n    { # registered paths\n        return $RegisteredSoname{$LVer}{$Name};\n    }\n    if(my $DefaultPath = $In::Opt{\"LibDefaultPath\"}{$Name})\n    { # ldconfig default paths\n        return $DefaultPath;\n    }\n    foreach my $Dir (@{$In::Opt{\"DefaultLibPaths\"}}, @{$In::Opt{\"SysPaths\"}{\"lib\"}})\n    { # search in default linker directories\n      # and then in all system paths\n        if(-f $Dir.\"/\".$Name) {\n            return join_P($Dir,$Name);\n        }\n    }\n    \n    checkSystemFiles();\n    \n    if(my @AllObjects = keys(%{$In::Opt{\"SystemObjects\"}{$Name}})) {\n        return $AllObjects[0];\n    }\n    if(my $ShortName = libPart($Name, \"name+ext\"))\n    {\n        if($ShortName ne $Name)\n        { # FIXME: check this case\n            if(my $Path = getLibPath($LVer, $ShortName)) {\n                return $Path;\n            }\n        }\n    }\n    # can't find\n    return \"\";\n}\n\nmy %Prefix_Lib_Map=(\n # symbols for autodetecting library dependencies (by prefix)\n    \"pthread_\" => [\"libpthread\"],\n    \"g_\" => [\"libglib-2.0\", \"libgobject-2.0\", \"libgio-2.0\"],\n    \"cairo_\" => [\"libcairo\"],\n    \"gtk_\" => [\"libgtk-x11-2.0\"],\n    \"atk_\" => [\"libatk-1.0\"],\n    \"gdk_\" => [\"libgdk-x11-2.0\"],\n    \"gl\" => [\"libGL\"],\n    \"glu\" => [\"libGLU\"],\n    \"popt\" => [\"libpopt\"],\n    \"Py\" => [\"libpython\"],\n    \"jpeg_\" => [\"libjpeg\"],\n    \"BZ2_\" => [\"libbz2\"],\n    \"Fc\" => [\"libfontconfig\"],\n    \"Xft\" => [\"libXft\"],\n    \"SSL_\" => [\"libssl\"],\n    \"sem_\" => [\"libpthread\"],\n    \"snd_\" => [\"libasound\"],\n    \"art_\" => [\"libart_lgpl_2\"],\n    \"dbus_g\" => [\"libdbus-glib-1\"],\n    \"GOMP_\" => [\"libgomp\"],\n    \"omp_\" => [\"libgomp\"],\n    \"cms\" => [\"liblcms\"]\n);\n\nmy %Pattern_Lib_Map=(\n    \"SL[a-z]\" => [\"libslang\"]\n);\n\nmy %Symbol_Lib_Map=(\n # symbols for autodetecting library dependencies (by name)\n    \"pow\" => \"libm\",\n    \"fmod\" => \"libm\",\n    \"sin\" => \"libm\",\n    \"floor\" => \"libm\",\n    \"cos\" => \"libm\",\n    \"dlopen\" => \"libdl\",\n    \"deflate\" => \"libz\",\n    \"inflate\" => \"libz\",\n    \"move_panel\" => \"libpanel\",\n    \"XOpenDisplay\" => \"libX11\",\n    \"resize_term\" => \"libncurses\",\n    \"clock_gettime\" => \"librt\",\n    \"crypt\" => \"libcrypt\"\n);\n\nsub find_SymbolLibs($$)\n{\n    my ($LVer, $Symbol) = @_;\n    \n    if(index($Symbol, \"g_\")==0 and $Symbol=~/[A-Z]/)\n    { # debug symbols\n        return ();\n    }\n    \n    my $LibExt = $In::Opt{\"Ext\"};\n    \n    my %Paths = ();\n    \n    if(my $LibName = $Symbol_Lib_Map{$Symbol})\n    {\n        if(my $Path = getLibPath($LVer, $LibName.\".\".$LibExt)) {\n            $Paths{$Path} = 1;\n        }\n    }\n    \n    if(my $SymbolPrefix = getPrefix($Symbol))\n    {\n        if(defined $Cache{\"find_SymbolLibs\"}{$SymbolPrefix}) {\n            return @{$Cache{\"find_SymbolLibs\"}{$SymbolPrefix}};\n        }\n    \n        if(not keys(%Paths))\n        {\n            if(defined $Prefix_Lib_Map{$SymbolPrefix})\n            {\n                foreach my $LibName (@{$Prefix_Lib_Map{$SymbolPrefix}})\n                {\n                    if(my $Path = getLibPath($LVer, $LibName.\".\".$LibExt)) {\n                        $Paths{$Path} = 1;\n                    }\n                }\n            }\n        }\n        \n        if(not keys(%Paths))\n        {\n            foreach my $Prefix (sort keys(%Pattern_Lib_Map))\n            {\n                if($Symbol=~/\\A$Prefix/)\n                {\n                    foreach my $LibName (@{$Pattern_Lib_Map{$Prefix}})\n                    {\n                        if(my $Path = getLibPath($LVer, $LibName.\".\".$LibExt)) {\n                            $Paths{$Path} = 1;\n                        }\n                    }\n                }\n            }\n        }\n    \n        if(not keys(%Paths))\n        {\n            if($SymbolPrefix)\n            { # try to find a library by symbol prefix\n                if($SymbolPrefix eq \"inotify\" and\n                index($Symbol, \"\\@GLIBC\")!=-1)\n                {\n                    if(my $Path = getLibPath($LVer, \"libc.$LibExt\")) {\n                        $Paths{$Path} = 1;\n                    }\n                }\n                else\n                {\n                    if(my $Path = getLibPathPrefix($LVer, $SymbolPrefix)) {\n                        $Paths{$Path} = 1;\n                    }\n                }\n            }\n        }\n        \n        if(my @Paths = keys(%Paths)) {\n            $Cache{\"find_SymbolLibs\"}{$SymbolPrefix} = \\@Paths;\n        }\n    }\n    return keys(%Paths);\n}\n\nsub getLibPathPrefix($$)\n{\n    my ($LVer, $Prefix) = @_;\n    my $LibExt = $In::Opt{\"Ext\"};\n    \n    $Prefix = lc($Prefix);\n    $Prefix=~s/[_]+\\Z//g;\n    \n    foreach (\"-2\", \"2\", \"-1\", \"1\", \"\")\n    { # libgnome-2.so\n      # libxml2.so\n      # libdbus-1.so\n        if(my $Path = getLibPath($LVer, \"lib\".$Prefix.$_.\".\".$LibExt)) {\n            return $Path;\n        }\n    }\n    return \"\";\n}\n\nreturn 1;\n"
    },
    "skipped": [],
    "total_files": 33
}