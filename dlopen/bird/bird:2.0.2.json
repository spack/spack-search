{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-bird-2.0.2-4sidiaz4csadxe2tk4puepydsf2fmllw/spack-src/proto/rpki/rpki.c": "/*\n *\tBIRD -- The Resource Public Key Infrastructure (RPKI) to Router Protocol\n *\n *\t(c) 2015 CZ.NIC\n *\t(c) 2015 Pavel Tvrdik <pawel.tvrdik@gmail.com>\n *\n *\tUsing RTRlib: http://rpki.realmv6.org/\n *\n *\tCan be freely distributed and used under the terms of the GNU GPL.\n */\n\n/**\n * DOC: RPKI To Router (RPKI-RTR)\n *\n * The RPKI-RTR protocol is implemented in several files: |rpki.c| containing\n * the routes handling, protocol logic, timer events, cache connection,\n * reconfiguration, configuration and protocol glue with BIRD core, |packets.c|\n * containing the RPKI packets handling and finally all transports files:\n * |transport.c|, |tcp_transport.c| and |ssh_transport.c|.\n *\n * The |transport.c| is a middle layer and interface for each specific\n * transport. Transport is a way how to wrap a communication with a cache\n * server. There is supported an unprotected TCP transport and an encrypted\n * SSHv2 transport. The SSH transport requires LibSSH library. LibSSH is\n * loading dynamically using |dlopen()| function. SSH support is integrated in\n * |sysdep/unix/io.c|. Each transport must implement an initialization\n * function, an open function and a socket identification function. That's all.\n *\n * This implementation is based on the RTRlib (http://rpki.realmv6.org/). The\n * BIRD takes over files |packets.c|, |rtr.c| (inside |rpki.c|), |transport.c|,\n * |tcp_transport.c| and |ssh_transport.c| from RTRlib.\n *\n * A RPKI-RTR connection is described by a structure &rpki_cache. The main\n * logic is located in |rpki_cache_change_state()| function. There is a state\n * machine. The standard starting state flow looks like |Down| ~> |Connecting|\n * ~> |Sync-Start| ~> |Sync-Running| ~> |Established| and then the last three\n * states are periodically repeated.\n *\n * |Connecting| state establishes the transport connection. The state from a\n * call |rpki_cache_change_state(CONNECTING)| to a call |rpki_connected_hook()|\n *\n * |Sync-Start| state starts with sending |Reset Query| or |Serial Query| and\n * then waits for |Cache Response|. The state from |rpki_connected_hook()| to\n * |rpki_handle_cache_response_pdu()|\n *\n * During |Sync-Running| BIRD receives data with IPv4/IPv6 Prefixes from cache\n * server. The state starts from |rpki_handle_cache_response_pdu()| and ends\n * in |rpki_handle_end_of_data_pdu()|.\n *\n * |Established| state means that BIRD has synced all data with cache server.\n * Schedules a refresh timer event that invokes |Sync-Start|. Schedules Expire\n * timer event and stops a Retry timer event.\n *\n * |Transport Error| state means that we have some troubles with a network\n * connection. We cannot connect to a cache server or we wait too long for some\n * expected PDU for received - |Cache Response| or |End of Data|. It closes\n * current connection and schedules a Retry timer event.\n *\n * |Fatal Protocol Error| is occurred e.g. by received a bad Session ID. We\n * restart a protocol, so all ROAs are flushed immediately.\n *\n * The RPKI-RTR protocol (RFC 6810 bis) defines configurable refresh, retry and\n * expire intervals. For maintaining a connection are used timer events that\n * are scheduled by |rpki_schedule_next_refresh()|,\n * |rpki_schedule_next_retry()| and |rpki_schedule_next_expire()| functions.\n *\n * A Refresh timer event performs a sync of |Established| connection. So it\n * shifts state to |Sync-Start|. If at the beginning of second call of a\n * refresh event is connection in |Sync-Start| state then we didn't receive a\n * |Cache Response| from a cache server and we invoke |Transport Error| state.\n *\n * A Retry timer event attempts to connect cache server. It is activated after\n * |Transport Error| state and terminated by reaching |Established| state.\n * If cache connection is still connecting to the cache server at the beginning\n * of an event call then the Retry timer event invokes |Transport Error| state.\n *\n * An Expire timer event checks expiration of ROAs. If a last successful sync\n * was more ago than the expire interval then the Expire timer event invokes a\n * protocol restart thereby removes all ROAs learned from that cache server and\n * continue trying to connect to cache server. The Expire event is activated\n * by initial successful loading of ROAs, receiving End of Data PDU.\n *\n * A reconfiguration of cache connection works well without restarting when we\n * change only intervals values.\n *\n * Supported standards:\n * - RFC 6810 - main RPKI-RTR standard\n * - RFC 6810 bis - an explicit timing parameters and protocol version number negotiation\n */\n\n#include <stdlib.h>\n#include <netdb.h>\n\n#undef LOCAL_DEBUG\n\n#include \"rpki.h\"\n#include \"lib/string.h\"\n#include \"nest/cli.h\"\n\n/* Return values for reconfiguration functions */\n#define NEED_RESTART \t\t0\n#define SUCCESSFUL_RECONF \t1\n\nstatic int rpki_open_connection(struct rpki_cache *cache);\nstatic void rpki_close_connection(struct rpki_cache *cache);\nstatic void rpki_schedule_next_refresh(struct rpki_cache *cache);\nstatic void rpki_schedule_next_retry(struct rpki_cache *cache);\nstatic void rpki_schedule_next_expire_check(struct rpki_cache *cache);\nstatic void rpki_stop_refresh_timer_event(struct rpki_cache *cache);\nstatic void rpki_stop_retry_timer_event(struct rpki_cache *cache);\nstatic void rpki_stop_expire_timer_event(struct rpki_cache *cache);\n\n\n/*\n * \tRoutes handling\n */\n\nvoid\nrpki_table_add_roa(struct rpki_cache *cache, struct channel *channel, const net_addr_union *pfxr)\n{\n  struct rpki_proto *p = cache->p;\n\n  rta a0 = {\n    .src = p->p.main_source,\n    .source = RTS_RPKI,\n    .scope = SCOPE_UNIVERSE,\n    .dest = RTD_NONE,\n  };\n\n  rta *a = rta_lookup(&a0);\n  rte *e = rte_get_temp(a);\n\n  e->pflags = 0;\n\n  rte_update2(channel, &pfxr->n, e, a0.src);\n}\n\nvoid\nrpki_table_remove_roa(struct rpki_cache *cache, struct channel *channel, const net_addr_union *pfxr)\n{\n  struct rpki_proto *p = cache->p;\n  rte_update2(channel, &pfxr->n, NULL, p->p.main_source);\n}\n\n\n/*\n *\tRPKI Protocol Logic\n */\n\nstatic const char *str_cache_states[] = {\n  [RPKI_CS_CONNECTING] \t\t= \"Connecting\",\n  [RPKI_CS_ESTABLISHED] \t= \"Established\",\n  [RPKI_CS_RESET] \t\t= \"Reseting\",\n  [RPKI_CS_SYNC_START] \t\t= \"Sync-Start\",\n  [RPKI_CS_SYNC_RUNNING] \t= \"Sync-Running\",\n  [RPKI_CS_FAST_RECONNECT] \t= \"Fast-Reconnect\",\n  [RPKI_CS_NO_INCR_UPDATE_AVAIL]= \"No-Increment-Update-Available\",\n  [RPKI_CS_ERROR_NO_DATA_AVAIL] = \"Cache-Error-No-Data-Available\",\n  [RPKI_CS_ERROR_FATAL] \t= \"Fatal-Protocol-Error\",\n  [RPKI_CS_ERROR_TRANSPORT] \t= \"Transport-Error\",\n  [RPKI_CS_SHUTDOWN] \t\t= \"Down\"\n};\n\n/**\n * rpki_cache_state_to_str - give a text representation of cache state\n * @state: A cache state\n *\n * The function converts logic cache state into string.\n */\nconst char *\nrpki_cache_state_to_str(enum rpki_cache_state state)\n{\n  return str_cache_states[state];\n}\n\n/**\n * rpki_start_cache - connect to a cache server\n * @cache: RPKI connection instance\n *\n * This function is a high level method to kick up a connection to a cache server.\n */\nstatic void\nrpki_start_cache(struct rpki_cache *cache)\n{\n  rpki_cache_change_state(cache, RPKI_CS_CONNECTING);\n}\n\n/**\n * rpki_force_restart_proto - force shutdown and start protocol again\n * @p: RPKI protocol instance\n *\n * This function calls shutdown and frees all protocol resources as well.\n * After calling this function should be no operations with protocol data,\n * they could be freed already.\n */\nstatic void\nrpki_force_restart_proto(struct rpki_proto *p)\n{\n  if (p->cache)\n  {\n    CACHE_DBG(p->cache, \"Connection object destroying\");\n  }\n\n  /* Sign as freed */\n  p->cache = NULL;\n\n  proto_notify_state(&p->p, PS_DOWN);\n}\n\n/**\n * rpki_cache_change_state - check and change cache state\n * @cache: RPKI cache instance\n * @new_state: suggested new state\n *\n * This function makes transitions between internal states.\n * It represents the core of logic management of RPKI protocol.\n * Cannot transit into the same state as cache is in already.\n */\nvoid\nrpki_cache_change_state(struct rpki_cache *cache, const enum rpki_cache_state new_state)\n{\n  const enum rpki_cache_state old_state = cache->state;\n\n  if (old_state == new_state)\n    return;\n\n  cache->state = new_state;\n  CACHE_TRACE(D_EVENTS, cache, \"Changing from %s to %s state\", rpki_cache_state_to_str(old_state), rpki_cache_state_to_str(new_state));\n\n  switch (new_state)\n  {\n  case RPKI_CS_CONNECTING:\n  {\n    sock *sk = cache->tr_sock->sk;\n\n    if (sk == NULL || sk->fd < 0)\n      rpki_open_connection(cache);\n    else\n      rpki_cache_change_state(cache, RPKI_CS_SYNC_START);\n\n    rpki_schedule_next_retry(cache);\n    break;\n  }\n\n  case RPKI_CS_ESTABLISHED:\n    rpki_schedule_next_refresh(cache);\n    rpki_schedule_next_expire_check(cache);\n    rpki_stop_retry_timer_event(cache);\n    break;\n\n  case RPKI_CS_RESET:\n    /* Resetting cache connection. */\n    cache->request_session_id = 1;\n    cache->serial_num = 0;\n    rpki_cache_change_state(cache, RPKI_CS_SYNC_START);\n    break;\n\n  case RPKI_CS_SYNC_START:\n    /* Requesting for receive ROAs from a cache server. */\n    if (cache->request_session_id)\n    {\n      /* Send request for Session ID */\n      if (rpki_send_reset_query(cache) != RPKI_SUCCESS)\n\trpki_cache_change_state(cache, RPKI_CS_ERROR_TRANSPORT);\n    }\n    else\n    {\n      /* We have already a session_id. So send a Serial Query and start an incremental sync */\n      if (rpki_send_serial_query(cache) != RPKI_SUCCESS)\n\trpki_cache_change_state(cache, RPKI_CS_ERROR_TRANSPORT);\n    }\n    break;\n\n  case RPKI_CS_SYNC_RUNNING:\n    /* The state between Cache Response and End of Data. Only waiting for\n     * receiving all IP Prefix PDUs and finally a End of Data PDU. */\n    break;\n\n  case RPKI_CS_NO_INCR_UPDATE_AVAIL:\n    /* Server was unable to answer the last Serial Query and sent Cache Reset. */\n    rpki_cache_change_state(cache, RPKI_CS_RESET);\n    break;\n\n  case RPKI_CS_ERROR_NO_DATA_AVAIL:\n    /* No validation records are available on the cache server. */\n    rpki_cache_change_state(cache, RPKI_CS_RESET);\n    break;\n\n  case RPKI_CS_ERROR_FATAL:\n    /* Fatal protocol error occurred. */\n    rpki_force_restart_proto(cache->p);\n    break;\n\n  case RPKI_CS_ERROR_TRANSPORT:\n    /* Error on the transport socket occurred. */\n    rpki_close_connection(cache);\n    rpki_schedule_next_retry(cache);\n    rpki_stop_refresh_timer_event(cache);\n    break;\n\n  case RPKI_CS_FAST_RECONNECT:\n    /* Reconnect without any waiting period */\n    rpki_close_connection(cache);\n    rpki_cache_change_state(cache, RPKI_CS_CONNECTING);\n    break;\n\n  case RPKI_CS_SHUTDOWN:\n    bug(\"This isn't never really called.\");\n    break;\n  };\n}\n\n\n/*\n * \tRPKI Timer Events\n */\n\nstatic void\nrpki_schedule_next_refresh(struct rpki_cache *cache)\n{\n  btime t = cache->refresh_interval S;\n\n  CACHE_DBG(cache, \"after %t s\", t);\n  tm_start(cache->refresh_timer, t);\n}\n\nstatic void\nrpki_schedule_next_retry(struct rpki_cache *cache)\n{\n  btime t = cache->retry_interval S;\n\n  CACHE_DBG(cache, \"after %t s\", t);\n  tm_start(cache->retry_timer, t);\n}\n\nstatic void\nrpki_schedule_next_expire_check(struct rpki_cache *cache)\n{\n  /* A minimum time to wait is 1 second */\n  btime t = cache->last_update + cache->expire_interval S - current_time();\n  t = MAX(t, 1 S);\n\n  CACHE_DBG(cache, \"after %t s\", t);\n  tm_start(cache->expire_timer, t);\n}\n\nstatic void\nrpki_stop_refresh_timer_event(struct rpki_cache *cache)\n{\n  CACHE_DBG(cache, \"Stop\");\n  tm_stop(cache->refresh_timer);\n}\n\nstatic void\nrpki_stop_retry_timer_event(struct rpki_cache *cache)\n{\n  CACHE_DBG(cache, \"Stop\");\n  tm_stop(cache->retry_timer);\n}\n\nstatic void UNUSED\nrpki_stop_expire_timer_event(struct rpki_cache *cache)\n{\n  CACHE_DBG(cache, \"Stop\");\n  tm_stop(cache->expire_timer);\n}\n\nstatic int\nrpki_do_we_recv_prefix_pdu_in_last_seconds(struct rpki_cache *cache)\n{\n  if (!cache->last_rx_prefix)\n    return 0;\n\n  return ((current_time() - cache->last_rx_prefix) <= 2 S);\n}\n\n/**\n * rpki_refresh_hook - control a scheduling of downloading data from cache server\n * @tm: refresh timer with cache connection instance in data\n *\n * This function is periodically called during &ESTABLISHED or &SYNC* state\n * cache connection.  The first refresh schedule is invoked after receiving a\n * |End of Data| PDU and has run by some &ERROR is occurred.\n */\nstatic void\nrpki_refresh_hook(timer *tm)\n{\n  struct rpki_cache *cache = tm->data;\n\n  CACHE_DBG(cache, \"%s\", rpki_cache_state_to_str(cache->state));\n\n  switch (cache->state)\n  {\n  case RPKI_CS_ESTABLISHED:\n    rpki_cache_change_state(cache, RPKI_CS_SYNC_START);\n    break;\n\n  case RPKI_CS_SYNC_START:\n    /* We sent Serial/Reset Query in last refresh hook call\n     * and didn't receive Cache Response yet. It is probably\n     * troubles with network. */\n  case RPKI_CS_SYNC_RUNNING:\n    /* We sent Serial/Reset Query in last refresh hook call\n     * and we got Cache Response but didn't get End-Of-Data yet.\n     * It could be a trouble with network or only too long synchronization. */\n    if (!rpki_do_we_recv_prefix_pdu_in_last_seconds(cache))\n    {\n      CACHE_TRACE(D_EVENTS, cache, \"Sync takes more time than refresh interval %us, resetting connection\", cache->refresh_interval);\n      rpki_cache_change_state(cache, RPKI_CS_ERROR_TRANSPORT);\n    }\n    break;\n\n  default:\n    break;\n  }\n\n  if (cache->state != RPKI_CS_SHUTDOWN && cache->state != RPKI_CS_ERROR_TRANSPORT)\n    rpki_schedule_next_refresh(cache);\n  else\n    rpki_stop_refresh_timer_event(cache);\n}\n\n/**\n * rpki_retry_hook - control a scheduling of retrying connection to cache server\n * @tm: retry timer with cache connection instance in data\n *\n * This function is periodically called during &ERROR* state cache connection.\n * The first retry schedule is invoked after any &ERROR* state occurred and\n * ends by reaching of &ESTABLISHED state again.\n */\nstatic void\nrpki_retry_hook(timer *tm)\n{\n  struct rpki_cache *cache = tm->data;\n\n  CACHE_DBG(cache, \"%s\", rpki_cache_state_to_str(cache->state));\n\n  switch (cache->state)\n  {\n  case RPKI_CS_ESTABLISHED:\n  case RPKI_CS_SHUTDOWN:\n    break;\n\n  case RPKI_CS_CONNECTING:\n  case RPKI_CS_SYNC_START:\n  case RPKI_CS_SYNC_RUNNING:\n    if (!rpki_do_we_recv_prefix_pdu_in_last_seconds(cache))\n    {\n      /* We tried to establish a connection in last retry hook call and haven't done\n       * yet. It looks like troubles with network. We are aggressive here. */\n      CACHE_TRACE(D_EVENTS, cache, \"Sync takes more time than retry interval %us, resetting connection.\", cache->retry_interval);\n      rpki_cache_change_state(cache, RPKI_CS_ERROR_TRANSPORT);\n    }\n    break;\n\n  default:\n    rpki_cache_change_state(cache, RPKI_CS_CONNECTING);\n    break;\n  }\n\n  if (cache->state != RPKI_CS_ESTABLISHED)\n    rpki_schedule_next_retry(cache);\n  else\n    rpki_stop_retry_timer_event(cache);\n}\n\n/**\n * rpki_expire_hook - control a expiration of ROA entries\n * @tm: expire timer with cache connection instance in data\n *\n * This function is scheduled after received a |End of Data| PDU.\n * A waiting interval is calculated dynamically by last update.\n * If we reach an expiration time then we invoke a restarting\n * of the protocol.\n */\nstatic void\nrpki_expire_hook(timer *tm)\n{\n  struct rpki_cache *cache = tm->data;\n\n  if (!cache->last_update)\n    return;\n\n  CACHE_DBG(cache, \"%s\", rpki_cache_state_to_str(cache->state));\n\n  btime t = cache->last_update + cache->expire_interval S - current_time();\n  if (t <= 0)\n  {\n    CACHE_TRACE(D_EVENTS, cache, \"All ROAs expired\");\n    rpki_force_restart_proto(cache->p);\n  }\n  else\n  {\n    CACHE_DBG(cache, \"Remains %t seconds to become ROAs obsolete\", t);\n    rpki_schedule_next_expire_check(cache);\n  }\n}\n\n/**\n * rpki_check_refresh_interval - check validity of refresh interval value\n * @seconds: suggested value\n *\n * This function validates value and should return |NULL|.\n * If the check doesn't pass then returns error message.\n */\nconst char *\nrpki_check_refresh_interval(uint seconds)\n{\n  if (seconds < 1)\n    return \"Minimum allowed refresh interval is 1 second\";\n  if (seconds > 86400)\n    return \"Maximum allowed refresh interval is 86400 seconds\";\n  return NULL;\n}\n\n/**\n * rpki_check_retry_interval - check validity of retry interval value\n * @seconds: suggested value\n *\n * This function validates value and should return |NULL|.\n * If the check doesn't pass then returns error message.\n */\nconst char *\nrpki_check_retry_interval(uint seconds)\n{\n  if (seconds < 1)\n    return \"Minimum allowed retry interval is 1 second\";\n  if (seconds > 7200)\n    return \"Maximum allowed retry interval is 7200 seconds\";\n  return NULL;\n}\n\n/**\n * rpki_check_expire_interval - check validity of expire interval value\n * @seconds: suggested value\n *\n * This function validates value and should return |NULL|.\n * If the check doesn't pass then returns error message.\n */\nconst char *\nrpki_check_expire_interval(uint seconds)\n{\n  if (seconds < 600)\n    return \"Minimum allowed expire interval is 600 seconds\";\n  if (seconds > 172800)\n    return \"Maximum allowed expire interval is 172800 seconds\";\n  return NULL;\n}\n\n\n/*\n * \tRPKI Cache\n */\n\nstatic struct rpki_cache *\nrpki_init_cache(struct rpki_proto *p, struct rpki_config *cf)\n{\n  pool *pool = rp_new(p->p.pool, cf->hostname);\n\n  struct rpki_cache *cache = mb_allocz(pool, sizeof(struct rpki_cache));\n\n  cache->pool = pool;\n  cache->p = p;\n\n  cache->state = RPKI_CS_SHUTDOWN;\n  cache->request_session_id = 1;\n  cache->version = RPKI_MAX_VERSION;\n\n  cache->refresh_interval = cf->refresh_interval;\n  cache->retry_interval = cf->retry_interval;\n  cache->expire_interval = cf->expire_interval;\n  cache->refresh_timer = tm_new_init(pool, &rpki_refresh_hook, cache, 0, 0);\n  cache->retry_timer = tm_new_init(pool, &rpki_retry_hook, cache, 0, 0);\n  cache->expire_timer = tm_new_init(pool, &rpki_expire_hook, cache, 0, 0);\n\n  cache->tr_sock = mb_allocz(pool, sizeof(struct rpki_tr_sock));\n  cache->tr_sock->cache = cache;\n\n  switch (cf->tr_config.type)\n  {\n  case RPKI_TR_TCP: rpki_tr_tcp_init(cache->tr_sock); break;\n  case RPKI_TR_SSH: rpki_tr_ssh_init(cache->tr_sock); break;\n  };\n\n  CACHE_DBG(cache, \"Connection object created\");\n\n  return cache;\n}\n\n/**\n * rpki_get_cache_ident - give a text representation of cache server name\n * @cache: RPKI connection instance\n *\n * The function converts cache connection into string.\n */\nconst char *\nrpki_get_cache_ident(struct rpki_cache *cache)\n{\n  return rpki_tr_ident(cache->tr_sock);\n}\n\nstatic int\nrpki_open_connection(struct rpki_cache *cache)\n{\n  CACHE_TRACE(D_EVENTS, cache, \"Opening a connection\");\n\n  if (rpki_tr_open(cache->tr_sock) == RPKI_TR_ERROR)\n  {\n    rpki_cache_change_state(cache, RPKI_CS_ERROR_TRANSPORT);\n    return RPKI_TR_ERROR;\n  }\n\n  return RPKI_TR_SUCCESS;\n}\n\nstatic void\nrpki_close_connection(struct rpki_cache *cache)\n{\n  CACHE_TRACE(D_EVENTS, cache, \"Closing a connection\");\n  rpki_tr_close(cache->tr_sock);\n  proto_notify_state(&cache->p->p, PS_START);\n}\n\nstatic int\nrpki_shutdown(struct proto *P)\n{\n  struct rpki_proto *p = (void *) P;\n\n  rpki_force_restart_proto(p);\n\n  /* Protocol memory pool will be automatically freed */\n  return PS_DOWN;\n}\n\n\n/*\n * \tRPKI Reconfiguration\n */\n\nstatic int\nrpki_try_fast_reconnect(struct rpki_cache *cache)\n{\n  if (cache->state == RPKI_CS_ESTABLISHED)\n  {\n    rpki_cache_change_state(cache, RPKI_CS_FAST_RECONNECT);\n    return SUCCESSFUL_RECONF;\n  }\n\n  return NEED_RESTART;\n}\n\n/**\n * rpki_reconfigure_cache - a cache reconfiguration\n * @p: RPKI protocol instance\n * @cache: a cache connection\n * @new: new RPKI configuration\n * @old: old RPKI configuration\n *\n * This function reconfigures existing single cache server connection with new\n * existing configuration.  Generally, a change of time intervals could be\n * reconfigured without restarting and all others changes requires a restart of\n * protocol.  Returns |NEED_TO_RESTART| or |SUCCESSFUL_RECONF|.\n */\nstatic int\nrpki_reconfigure_cache(struct rpki_proto *p UNUSED, struct rpki_cache *cache, struct rpki_config *new, struct rpki_config *old)\n{\n  u8 try_fast_reconnect = 0;\n\n  if (strcmp(old->hostname, new->hostname) != 0)\n  {\n    CACHE_TRACE(D_EVENTS, cache, \"Cache server address changed to %s\", new->hostname);\n    return NEED_RESTART;\n  }\n\n  if (old->port != new->port)\n  {\n    CACHE_TRACE(D_EVENTS, cache, \"Cache server port changed to %u\", new->port);\n    return NEED_RESTART;\n  }\n\n  if (old->tr_config.type != new->tr_config.type)\n  {\n    CACHE_TRACE(D_EVENTS, cache, \"Transport type changed\");\n    return NEED_RESTART;\n  }\n  else if (new->tr_config.type == RPKI_TR_SSH)\n  {\n    struct rpki_tr_ssh_config *ssh_old = (void *) old->tr_config.spec;\n    struct rpki_tr_ssh_config *ssh_new = (void *) new->tr_config.spec;\n    if ((strcmp(ssh_old->bird_private_key, ssh_new->bird_private_key) != 0) ||\n\t(strcmp(ssh_old->cache_public_key, ssh_new->cache_public_key) != 0) ||\n\t(strcmp(ssh_old->user, ssh_new->user) != 0))\n    {\n      CACHE_TRACE(D_EVENTS, cache, \"Settings of SSH transport configuration changed\");\n      try_fast_reconnect = 1;\n    }\n  }\n\n#define TEST_INTERVAL(name, Name) \t\t\t\t\t\t\\\n    if (cache->name##_interval != new->name##_interval ||\t\t\t\\\n\told->keep_##name##_interval != new->keep_##name##_interval) \t\t\\\n    { \t\t\t\t\t\t\t\t\t\t\\\n      cache->name##_interval = new->name##_interval;\t\t\t\t\\\n      CACHE_TRACE(D_EVENTS, cache, #Name \" interval changed to %u seconds %s\", cache->name##_interval, (new->keep_##name##_interval ? \"and keep it\" : \"\")); \\\n      try_fast_reconnect = 1; \t\t\t\t\t\t\t\\\n    }\n  TEST_INTERVAL(refresh, Refresh);\n  TEST_INTERVAL(retry, Retry);\n  TEST_INTERVAL(expire, Expire);\n#undef TEST_INTERVAL\n\n  if (try_fast_reconnect)\n    return rpki_try_fast_reconnect(cache);\n\n  return SUCCESSFUL_RECONF;\n}\n\n/**\n * rpki_reconfigure - a protocol reconfiguration hook\n * @P: a protocol instance\n * @CF: a new protocol configuration\n *\n * This function reconfigures whole protocol.\n * It sets new protocol configuration into a protocol structure.\n * Returns |NEED_TO_RESTART| or |SUCCESSFUL_RECONF|.\n */\nstatic int\nrpki_reconfigure(struct proto *P, struct proto_config *CF)\n{\n  struct rpki_proto *p = (void *) P;\n  struct rpki_config *new = (void *) CF;\n  struct rpki_config *old = (void *) p->p.cf;\n  struct rpki_cache *cache = p->cache;\n\n  if (!proto_configure_channel(&p->p, &p->roa4_channel, proto_cf_find_channel(CF, NET_ROA4)) ||\n      !proto_configure_channel(&p->p, &p->roa6_channel, proto_cf_find_channel(CF, NET_ROA6)))\n    return NEED_RESTART;\n\n  if (rpki_reconfigure_cache(p, cache, new, old) != SUCCESSFUL_RECONF)\n    return NEED_RESTART;\n\n  return SUCCESSFUL_RECONF;\n}\n\n\n/*\n * \tRPKI Protocol Glue\n */\n\nstatic struct proto *\nrpki_init(struct proto_config *CF)\n{\n  struct proto *P = proto_new(CF);\n  struct rpki_proto *p = (void *) P;\n\n  proto_configure_channel(&p->p, &p->roa4_channel, proto_cf_find_channel(CF, NET_ROA4));\n  proto_configure_channel(&p->p, &p->roa6_channel, proto_cf_find_channel(CF, NET_ROA6));\n\n  return P;\n}\n\nstatic int\nrpki_start(struct proto *P)\n{\n  struct rpki_proto *p = (void *) P;\n  struct rpki_config *cf = (void *) P->cf;\n\n  p->cache = rpki_init_cache(p, cf);\n  rpki_start_cache(p->cache);\n\n  return PS_START;\n}\n\nstatic void\nrpki_get_status(struct proto *P, byte *buf)\n{\n  struct rpki_proto *p = (struct rpki_proto *) P;\n\n  if (P->proto_state == PS_DOWN)\n  {\n    *buf = 0;\n    return;\n  }\n\n  if (p->cache)\n    bsprintf(buf, \"%s\", rpki_cache_state_to_str(p->cache->state));\n  else\n    bsprintf(buf, \"No cache server configured\");\n}\n\nstatic void\nrpki_show_proto_info_timer(const char *name, uint num, timer *t)\n{\n  if (tm_active(t))\n    cli_msg(-1006, \"  %-16s: %t/%u\", name, tm_remains(t), num);\n  else\n    cli_msg(-1006, \"  %-16s: ---\", name);\n}\n\nstatic void\nrpki_show_proto_info(struct proto *P)\n{\n  struct rpki_proto *p = (struct rpki_proto *) P;\n  struct rpki_config *cf = (void *) p->p.cf;\n  struct rpki_cache *cache = p->cache;\n\n  if (P->proto_state == PS_DOWN)\n    return;\n\n  if (cache)\n  {\n    const char *transport_name = \"---\";\n\n    switch (cf->tr_config.type)\n    {\n    case RPKI_TR_SSH: transport_name = \"SSHv2\"; break;\n    case RPKI_TR_TCP: transport_name = \"Unprotected over TCP\"; break;\n    };\n\n    cli_msg(-1006, \"  Cache server:     %s\", rpki_get_cache_ident(cache));\n    cli_msg(-1006, \"  Status:           %s\", rpki_cache_state_to_str(cache->state));\n    cli_msg(-1006, \"  Transport:        %s\", transport_name);\n    cli_msg(-1006, \"  Protocol version: %u\", cache->version);\n\n    if (cache->request_session_id)\n      cli_msg(-1006, \"  Session ID:       ---\");\n    else\n      cli_msg(-1006, \"  Session ID:       %u\", cache->session_id);\n\n    if (cache->last_update)\n    {\n      cli_msg(-1006, \"  Serial number:    %u\", cache->serial_num);\n      cli_msg(-1006, \"  Last update:      before %t s\", current_time() - cache->last_update);\n    }\n    else\n    {\n      cli_msg(-1006, \"  Serial number:    ---\");\n      cli_msg(-1006, \"  Last update:      ---\");\n    }\n\n    rpki_show_proto_info_timer(\"Refresh timer\", cache->refresh_interval, cache->refresh_timer);\n    rpki_show_proto_info_timer(\"Retry timer\", cache->retry_interval, cache->retry_timer);\n    rpki_show_proto_info_timer(\"Expire timer\", cache->expire_interval, cache->expire_timer);\n\n    if (p->roa4_channel)\n      channel_show_info(p->roa4_channel);\n    else\n      cli_msg(-1006, \"  No roa4 channel\");\n\n    if (p->roa6_channel)\n      channel_show_info(p->roa6_channel);\n    else\n      cli_msg(-1006, \"  No roa6 channel\");\n  }\n}\n\n\n/*\n * \tRPKI Protocol Configuration\n */\n\n/**\n * rpki_check_config - check and complete configuration of RPKI protocol\n * @cf: RPKI configuration\n *\n * This function is called at the end of parsing RPKI protocol configuration.\n */\nvoid\nrpki_check_config(struct rpki_config *cf)\n{\n  /* Do not check templates at all */\n  if (cf->c.class == SYM_TEMPLATE)\n    return;\n\n  if (ipa_zero(cf->ip) && cf->hostname == NULL)\n    cf_error(\"IP address or hostname of cache server must be set\");\n\n  /* Set default transport type */\n  if (cf->tr_config.spec == NULL)\n  {\n    cf->tr_config.spec = cfg_allocz(sizeof(struct rpki_tr_tcp_config));\n    cf->tr_config.type = RPKI_TR_TCP;\n  }\n\n  if (cf->port == 0)\n  {\n    /* Set default port numbers */\n    switch (cf->tr_config.type)\n    {\n    case RPKI_TR_SSH:\n      cf->port = RPKI_SSH_PORT;\n      break;\n    default:\n      cf->port = RPKI_TCP_PORT;\n    }\n  }\n}\n\nstatic void\nrpki_postconfig(struct proto_config *CF)\n{\n  /* Define default channel */\n  if (EMPTY_LIST(CF->channels))\n    channel_config_new(NULL, net_label[CF->net_type], CF->net_type, CF);\n}\n\nstatic void\nrpki_copy_config(struct proto_config *dest UNUSED, struct proto_config *src UNUSED)\n{\n  /* FIXME: Should copy transport */\n}\n\nstruct protocol proto_rpki = {\n  .name = \t\t\"RPKI\",\n  .template = \t\t\"rpki%d\",\n  .preference = \tDEF_PREF_RPKI,\n  .proto_size = \tsizeof(struct rpki_proto),\n  .config_size =\tsizeof(struct rpki_config),\n  .init = \t\trpki_init,\n  .start = \t\trpki_start,\n  .postconfig = \trpki_postconfig,\n  .channel_mask =\t(NB_ROA4 | NB_ROA6),\n  .show_proto_info =\trpki_show_proto_info,\n  .shutdown = \t\trpki_shutdown,\n  .copy_config = \trpki_copy_config,\n  .reconfigure = \trpki_reconfigure,\n  .get_status = \trpki_get_status,\n};\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-bird-2.0.2-4sidiaz4csadxe2tk4puepydsf2fmllw/spack-src/doc/LinuxDocTools.pm",
        "/tmp/vanessa/spack-stage/spack-stage-bird-2.0.2-4sidiaz4csadxe2tk4puepydsf2fmllw/spack-src/doc/slt2001/slt.tex",
        "/tmp/vanessa/spack-stage/spack-stage-bird-2.0.2-4sidiaz4csadxe2tk4puepydsf2fmllw/spack-src/doc/sbase/dist/fmt_latex2e.pl",
        "/tmp/vanessa/spack-stage/spack-stage-bird-2.0.2-4sidiaz4csadxe2tk4puepydsf2fmllw/spack-src/doc/sbase/dist/fmt_txt.pl",
        "/tmp/vanessa/spack-stage/spack-stage-bird-2.0.2-4sidiaz4csadxe2tk4puepydsf2fmllw/spack-src/doc/sbase/dist/fmt_html.pl",
        "/tmp/vanessa/spack-stage/spack-stage-bird-2.0.2-4sidiaz4csadxe2tk4puepydsf2fmllw/spack-src/doc/slides/slides.tex",
        "/tmp/vanessa/spack-stage/spack-stage-bird-2.0.2-4sidiaz4csadxe2tk4puepydsf2fmllw/spack-src/doc/slides/logo.eps",
        "/tmp/vanessa/spack-stage/spack-stage-bird-2.0.2-4sidiaz4csadxe2tk4puepydsf2fmllw/spack-src/doc/old/banner.tex",
        "/tmp/vanessa/spack-stage/spack-stage-bird-2.0.2-4sidiaz4csadxe2tk4puepydsf2fmllw/spack-src/doc/old/status.tex"
    ],
    "total_files": 238
}