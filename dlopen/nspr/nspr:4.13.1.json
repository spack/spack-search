{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-nspr-4.13.1-vntc7ai7kqzc4riwwqstomskyuugrvqz/spack-src/nspr/configure.in": "dnl -*- Mode: Autoconf; tab-width: 4; indent-tabs-mode: nil; -*-\ndnl \ndnl This Source Code Form is subject to the terms of the Mozilla Public\ndnl License, v. 2.0. If a copy of the MPL was not distributed with this\ndnl file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\nAC_PREREQ(2.61)\nAC_INIT\nAC_CONFIG_SRCDIR([pr/include/nspr.h])\n\nAC_CONFIG_AUX_DIR(${srcdir}/build/autoconf)\nAC_CANONICAL_TARGET\n\ndnl ========================================================\ndnl = Defaults\ndnl ========================================================\nMOD_MAJOR_VERSION=4\nMOD_MINOR_VERSION=13\nMOD_PATCH_VERSION=1\nNSPR_MODNAME=nspr20\n_HAVE_PTHREADS=\nUSE_PTHREADS=\nUSE_USER_PTHREADS=\nUSE_NSPR_THREADS=\nUSE_N32=\nUSE_X32=\nUSE_64=\nUSE_CPLUS=\nUSE_IPV6=\nUSE_MDUPDATE=\n_MACOSX_DEPLOYMENT_TARGET=\n_OPTIMIZE_FLAGS=-O\n_DEBUG_FLAGS=-g\nMOZ_DEBUG=1\nMOZ_OPTIMIZE=\nOBJDIR='$(OBJDIR_NAME)'\nOBJDIR_NAME=.\nOBJDIR_SUFFIX=OBJ\nNSINSTALL='$(MOD_DEPTH)/config/$(OBJDIR_NAME)/nsinstall'\nNOSUCHFILE=/no-such-file\nLIBNSPR='-L$(dist_libdir) -lnspr$(MOD_MAJOR_VERSION)'\nLIBPLC='-L$(dist_libdir) -lplc$(MOD_MAJOR_VERSION)'\nCYGWIN_WRAPPER=\nMACOS_SDK_DIR=\nNEXT_ROOT=\nMT=\nMOZ_OS2_HIGH_MEMORY=1\nPROFILE_GEN_CFLAGS=\nPROFILE_GEN_LDFLAGS=\nPROFILE_USE_CFLAGS=\nPROFILE_USE_LDFLAGS=\n\ndnl Link in libraries necessary to resolve all symbols for shared libs\nRESOLVE_LINK_SYMBOLS=\n\ndnl ========================================================\ndnl =\ndnl = Dont change the following lines.  Doing so breaks:\ndnl =\ndnl = CFLAGS=\"-foo\" ./configure\ndnl =\ndnl ========================================================\nCFLAGS=\"${CFLAGS=}\"\nCXXFLAGS=\"${CXXFLAGS=}\"\nLDFLAGS=\"${LDFLAGS=}\"\nDLLFLAGS=\"${DLLFLAGS=}\"\nHOST_CFLAGS=\"${HOST_CFLAGS=}\"\nHOST_LDFLAGS=\"${HOST_LDFLAGS=}\"\n\ncase \"$target\" in\n*-cygwin*|*-mingw*|*-msys*)\n    # Check to see if we are really running in a msvc environemnt\n    _WIN32_MSVC=\n    AC_CHECK_PROGS(CC, cl)\n    cat > conftest.c <<EOF\n#ifdef _MSC_VER\nCOMPILER IS MSVC\n#endif\nEOF\n    read dummy <<EOF\n$($CC -E conftest.c 2>/dev/null | grep COMPILER)\nEOF\n    if test -n \"$dummy\"; then\n        _WIN32_MSVC=1\n        CXX=$CC\n    fi\n    rm -f conftest.c\n    ;;\n*-mks*)\n    _WIN32_MSVC=1\n    ;;\nesac\n\nif test -n \"$_WIN32_MSVC\"; then\n    SKIP_PATH_CHECKS=1\n    SKIP_COMPILER_CHECKS=1\n    SKIP_LIBRARY_CHECKS=1\nfi\n\ndnl ========================================================\ndnl = Android uses a very custom (hacky) toolchain; we need to do this\ndnl = here, so that the compiler checks can succeed\ndnl ========================================================\n\nAC_ARG_WITH(android-ndk,\n[  --with-android-ndk=DIR\n                          location where the Android NDK can be found],\n    android_ndk=$withval)\n\nAC_ARG_WITH(android-toolchain,\n[  --with-android-toolchain=DIR\n                          location of the Android toolchain],\n    android_toolchain=$withval)\n\ndnl The default android_version is different for each target cpu.\ncase \"$target_cpu\" in\narm)\n    android_version=5\n    ;;\ni?86|mipsel)\n    android_version=9\n    ;;\nesac\n\nAC_ARG_WITH(android-version,\n[  --with-android-version=VER\n                          Android platform version, default 5 for arm, 9 for x86/mips],\n    android_version=$withval)\n\nAC_ARG_WITH(android-platform,\n[  --with-android-platform=DIR\n                          location of platform dir],\n    android_platform=$withval)\n\ncase \"$target\" in\narm-linux*-android*|*-linuxandroid*)\n    android_tool_prefix=\"arm-linux-androideabi\"\n    ;;\ni?86-*android*)\n    android_tool_prefix=\"i686-linux-android\"\n    ;;\nmipsel-*android*)\n    android_tool_prefix=\"mipsel-linux-android\"\n    ;;\n*)\n    android_tool_prefix=\"$target_os\"\n    ;;\nesac\n\ndnl ========================================================\ndnl = Gonk is a fork of Android used for Mozilla's B2G project.\ndnl = Configuration is done largely by the top level config\ndnl = and the specified gonk directory doesn't matter here.\ndnl ========================================================\n\nAC_ARG_WITH(gonk,\n[  --with-gonk=DIR         location of gonk dir],\n    gonkdir=$withval)\n\nif test -n \"$gonkdir\" ; then\n    dnl Most things are directly configured by env vars when building for gonk\n\n    AC_DEFINE(ANDROID)\nelse\ncase \"$target\" in\n*-android*|*-linuxandroid*)\n    if test -z \"$android_ndk\" ; then\n       AC_MSG_ERROR([You must specify --with-android-ndk=/path/to/ndk when targeting Android.])\n    fi\n\n    if test -z \"$android_toolchain\" ; then\n        AC_MSG_CHECKING([for android toolchain directory])\n\n        kernel_name=`uname -s | tr \"[[:upper:]]\" \"[[:lower:]]\"`\n\n        case \"$target_cpu\" in\n        arm)\n            target_name=arm-linux-androideabi-4.4.3\n            ;;\n        i?86)\n            target_name=x86-4.4.3\n            ;;\n        mipsel)\n            target_name=mipsel-linux-android-4.4.3\n            ;;\n        esac\n        android_toolchain=\"$android_ndk\"/toolchains/$target_name/prebuilt/$kernel_name-x86\n\n        if test -d \"$android_toolchain\" ; then\n            AC_MSG_RESULT([$android_toolchain])\n        else\n            AC_MSG_ERROR([not found. You have to specify --with-android-toolchain=/path/to/ndk/toolchain.])\n        fi\n    fi\n\n    if test -z \"$android_platform\" ; then\n        AC_MSG_CHECKING([for android platform directory])\n\n        case \"$target_cpu\" in\n        arm)\n            target_name=arm\n            ;;\n        i?86)\n            target_name=x86\n            ;;\n        mipsel)\n            target_name=mips\n            ;;\n        esac\n\n        android_platform=\"$android_ndk\"/platforms/android-\"$android_version\"/arch-\"$target_name\"\n\n        if test -d \"$android_platform\" ; then\n            AC_MSG_RESULT([$android_platform])\n        else\n            AC_MSG_ERROR([not found. You have to specify --with-android-platform=/path/to/ndk/platform.])\n        fi\n    fi\n\n    dnl Old NDK support. If minimum requirement is changed to NDK r8b,\n    dnl please remove this.\n    case \"$target_cpu\" in\n    i?86)\n        if ! test -e \"$android_toolchain\"/bin/\"$android_tool_prefix\"-gcc; then\n            dnl Old NDK toolchain name\n            android_tool_prefix=\"i686-android-linux\"\n        fi\n        ;;\n    esac\n\n    dnl set up compilers\n    AS=\"$android_toolchain\"/bin/\"$android_tool_prefix\"-as\n    CC=\"$android_toolchain\"/bin/\"$android_tool_prefix\"-gcc\n    CXX=\"$android_toolchain\"/bin/\"$android_tool_prefix\"-g++\n    CPP=\"$android_toolchain\"/bin/\"$android_tool_prefix\"-cpp\n    LD=\"$android_toolchain\"/bin/\"$android_tool_prefix\"-ld\n    AR=\"$android_toolchain\"/bin/\"$android_tool_prefix\"-ar\n    RANLIB=\"$android_toolchain\"/bin/\"$android_tool_prefix\"-ranlib\n    STRIP=\"$android_toolchain\"/bin/\"$android_tool_prefix\"-strip\n\n    CPPFLAGS=\"-I$android_platform/usr/include $CPPFLAGS\"\n    CFLAGS=\"-mandroid -I$android_platform/usr/include -fno-short-enums -fno-exceptions $CFLAGS\"\n    CXXFLAGS=\"-mandroid -I$android_platform/usr/include -fpic -fno-short-enums -fno-exceptions $CXXFLAGS\"\n    LDFLAGS=\"-mandroid -L$android_platform/usr/lib -Wl,-rpath-link=$android_platform/usr/lib --sysroot=$android_platform $LDFLAGS\"\n\n    AC_DEFINE(ANDROID)\n    ;;\nesac\nfi\n\ndnl ========================================================\ndnl =\ndnl = Check options that may affect the compiler\ndnl =\ndnl ========================================================\ndist_prefix='${MOD_DEPTH}/dist'\ndist_bindir='${dist_prefix}/bin'\ndist_includedir='${dist_prefix}/include/nspr'\ndist_libdir='${dist_prefix}/lib'\ndnl If the --includedir option was not specified, add '/nspr' to autoconf's\ndnl default value of includedir.\nif test \"${includedir}\" = '${prefix}/include'; then\n    includedir='${prefix}/include/nspr'\nfi\n\nAC_ARG_WITH(dist-prefix,\n    [  --with-dist-prefix=DIST_PREFIX\n                          place build files in DIST_PREFIX [dist]],\n    dist_prefix=$withval)\n\nAC_ARG_WITH(dist-bindir,\n    [  --with-dist-bindir=DIR  build execuatables in DIR [DIST_PREFIX/bin]],\n    dist_bindir=$withval)\n\nAC_ARG_WITH(dist-includedir,\n    [  --with-dist-includedir=DIR\n                          build include files in DIR [DIST_PREFIX/include/nspr]],\n    dist_includedir=$withval)\n\nAC_ARG_WITH(dist-libdir,\n    [  --with-dist-libdir=DIR  build library files in DIR [DIST_PREFIX/lib]],\n    dist_libdir=$withval)\n\nAC_SUBST(dist_prefix)\nAC_SUBST(dist_bindir)\nAC_SUBST(dist_includedir)\nAC_SUBST(dist_libdir)\n\ndnl Check if NSPR is being compiled for Mozilla\ndnl Let --with-arg override environment setting\ndnl\nAC_ARG_WITH(mozilla,\n    [  --with-mozilla          Compile NSPR with Mozilla support],\n    [   if test \"$withval\" = \"yes\"; then\n            AC_DEFINE(MOZILLA_CLIENT)\n            MOZILLA_CLIENT=1\n\t    else\n\t        MOZILLA_CLIENT=\n\t    fi],\n    [\tif test -n \"$MOZILLA_CLIENT\"; then\n\t        AC_DEFINE(MOZILLA_CLIENT)\n\t    fi])\n\nAC_ARG_ENABLE(optimize,\n    [  --enable-optimize[=OPT] Enable code optimizations (ie. -O2) ],\n    [ if test \"$enableval\" != \"no\"; then\n          MOZ_OPTIMIZE=1\n          if test -n \"$enableval\" -a \"$enableval\" != \"yes\"; then\n            _OPTIMIZE_FLAGS=`echo $enableval | sed -e 's|\\\\\\ | |g'`\n            _SAVE_OPTIMIZE_FLAGS=$_OPTIMIZE_FLAGS\n          fi\n      else\n          MOZ_OPTIMIZE=\n      fi ])\n\nAC_ARG_ENABLE(debug,\n    [  --enable-debug[=DBG]    Enable debugging (using compiler flags DBG)],\n    [ if test \"$enableval\" != \"no\"; then\n          MOZ_DEBUG=1\n          MOZ_DEBUG_SYMBOLS=1\n          if test -n \"$enableval\" -a \"$enableval\" != \"yes\"; then\n              _DEBUG_FLAGS=`echo $enableval | sed -e 's|\\\\\\ | |g'`\n              _SAVE_DEBUG_FLAGS=$_DEBUG_FLAGS\n          fi\n      else\n          MOZ_DEBUG=\n      fi ],\n      MOZ_DEBUG_SYMBOLS=1)\n\nAC_ARG_ENABLE(debug-symbols,\n    [  --enable-debug-symbols[=DBG]    Enable debugging symbols\n                                       (using compiler flags DBG)],\n    [ if test \"$enableval\" != \"no\"; then\n          MOZ_DEBUG_SYMBOLS=1\n          if test -n \"$enableval\" -a \"$enableval\" != \"yes\"; then\n              if test -z \"$_SAVE_DEBUG_FLAGS\"; then\n                  _DEBUG_FLAGS=`echo $enableval | sed -e 's|\\\\\\ | |g'`\n                  _SAVE_DEBUG_FLAGS=$_DEBUG_FLAGS\n              else\n                  AC_MSG_ERROR([--enable-debug-symbols flags cannot be used with --enable-debug flags])\n              fi\n          fi\n      else\n          MOZ_DEBUG_SYMBOLS=\n      fi ])\n\nAC_ARG_ENABLE(win32-target,\n    [  --enable-win32-target=\\$t\n                          Specify win32 flavor. (WIN95 or WINNT)],\n    OS_TARGET=`echo $enableval | tr a-z A-Z`)\n\nAC_ARG_ENABLE(symbian-target,\n    [  --enable-symbian-target=\\$t\n                          Specify symbian flavor. (WINSCW or GCCE)],\n    OS_TARGET=`echo $enableval | tr a-z A-Z`)\n\nAC_ARG_ENABLE(debug-rtl,\n    [  --enable-debug-rtl      Use the MSVC debug runtime library],\n    [ if test \"$enableval\" = \"yes\"; then\n\t    USE_DEBUG_RTL=1\n      else\n\t    USE_DEBUG_RTL=0\n      fi ])\n\nAC_ARG_ENABLE(static-rtl,\n    [  --enable-static-rtl     Use the MSVC static runtime library],\n    [ if test \"$enableval\" = \"yes\"; then\n\t    USE_STATIC_RTL=1\n      fi ])\n\nAC_ARG_ENABLE(n32,\n    [  --enable-n32            Enable n32 ABI support (IRIX only)],\n    [ if test \"$enableval\" = \"yes\"; then\n\tUSE_N32=1\n      else if test \"$enableval\" = \"no\"; then\n\tUSE_N32=\n      fi\n    fi ])\n\nAC_ARG_ENABLE(x32,\n    [  --enable-x32            Enable x32 ABI support (x86_64 only)],\n    [ if test \"$enableval\" = \"yes\"; then\n        USE_X32=1\n      else if test \"$enableval\" = \"no\"; then\n        USE_X32=\n      fi\n    fi ])\n\nAC_ARG_ENABLE(64bit,\n    [  --enable-64bit          Enable 64-bit support (on certain platforms)],\n    [ if test \"$enableval\" = \"yes\"; then\n\t    USE_64=1\n      fi ])\n\nAC_ARG_ENABLE(mdupdate,\n    [  --enable-mdupdate       Enable use of certain compilers' mdupdate feature],\n    [ if test \"$enableval\" = \"yes\"; then\n\t    USE_MDUPDATE=1\n      fi ])\n\nAC_ARG_ENABLE(cplus,\n    [  --enable-cplus          Enable some c++ api routines],\n    [ if test \"$enableval\" = \"yes\"; then\n\t    USE_CPLUS=1\n      fi]) \n\nAC_ARG_WITH(arm-kuser,\n    [  --with-arm-kuser        Use kuser helpers (Linux/ARM only)\n                          (Requires kernel 2.6.13 or later)],\n    [ if test \"$withval\" = \"yes\"; then\n\t    AC_DEFINE(_PR_ARM_KUSER)\n      fi ])\n\ndnl ========================================================\ndnl = Mac OS X SDK support\ndnl ========================================================\nAC_ARG_WITH(macos-sdk,\n    [  --with-macos-sdk=dir    Location of platform SDK to use (Mac OS X only)],\n    MACOS_SDK_DIR=$withval)\n\nAC_ARG_ENABLE(macos-target,\n             [  --enable-macos-target=VER\n                          Set the minimum MacOS version needed at runtime\n                          [10.2 for ppc, 10.4 for x86]],\n             [_MACOSX_DEPLOYMENT_TARGET=$enableval])\n\ndnl ========================================================\ndnl =\ndnl = Set the threading model\ndnl =\ndnl ========================================================\ncase \"$target\" in\n\n*-aix*)\n    case \"${target_os}\" in\n    aix3.2*)\n        USE_NSPR_THREADS=1\n        ;;\n    *)\n        USE_PTHREADS=1\n        ;;\n    esac\n    ;;\n\nesac\n\ndnl ========================================================\ndnl =\ndnl = Set the default C compiler\ndnl =\ndnl ========================================================\nif test -z \"$CC\"; then\n    case \"$target\" in\n\n    *-aix*)\n        if test -z \"$USE_NSPR_THREADS\"; then\n            CC=xlc_r\n        else\n            CC=xlc\n        fi\n    ;;\n\n    *-hpux*)\n        CC=cc\n    ;;\n\n    *-irix*)\n        CC=cc\n    ;;\n\n    *-osf*)\n        CC=cc\n    ;;\n\n    *-solaris*)\n        CC=cc\n    ;;\n\n    esac\nfi\n\ndnl ========================================================\ndnl =\ndnl = Set the default C++ compiler\ndnl =\ndnl ========================================================\nif test -z \"$CXX\"; then\n    case \"$target\" in\n\n    *-aix*)\n        if test -z \"$USE_NSPR_THREADS\"; then\n            CXX=xlC_r\n        else\n            CXX=xlC\n        fi\n    ;;\n\n    *-hpux*)\n        case \"${target_os}\" in\n        hpux10.30)\n            CXX=aCC\n            ;;\n        hpux11.*)\n            CXX=aCC\n            ;;\n        *)\n            CXX=CC\n            ;;\n        esac\n    ;;\n\n    *-irix*)\n        CXX=CC\n    ;;\n\n    *-osf*)\n        CXX=cxx\n    ;;\n\n    *-solaris*)\n        CXX=CC\n    ;;\n\n    esac\nfi\n\nif test -z \"$SKIP_PATH_CHECKS\"; then\n    AC_PATH_PROG(WHOAMI, $WHOAMI whoami, echo not_whoami)\nfi\n\nif test -n \"$MOZ_DEBUG\"; then\n    AC_DEFINE(DEBUG)\n    DEFINES=\"$DEFINES -UNDEBUG\"\n\n    case \"${target_os}\" in\n    beos*)\n        DEFINES=\"$DEFINES -DDEBUG_${USER}\"\n        ;;\n    mks*|cygwin*|mingw*|msys*|os2*)\n        DEFINES=\"$DEFINES -DDEBUG_`echo ${USERNAME} | sed -e 's| |_|g'`\"\n        ;;\n    *)\n        DEFINES=\"$DEFINES -DDEBUG_`$WHOAMI`\"\n        ;;\n    esac\nelse\n    AC_DEFINE(NDEBUG)\n    DEFINES=\"$DEFINES -UDEBUG\"\nfi\n\nif test -z \"$SKIP_COMPILER_CHECKS\"; then\ndnl ========================================================\ndnl Checks for compilers.\ndnl ========================================================\nif test \"$target\" != \"$host\"; then\n    echo \"cross compiling from $host to $target\"\n    cross_compiling=yes\n\n    case \"$build:$target\" in\n      powerpc-apple-darwin8*:i?86-apple-darwin*)\n        dnl The Darwin cross compiler doesn't necessarily point itself at a\n        dnl root that has libraries for the proper architecture, it defaults\n        dnl to the system root.  The libraries in the system root on current\n        dnl versions of PPC OS X 10.4 aren't fat, so these target compiler\n        dnl checks will fail.  Fake a working SDK in that case.\n        _SAVE_CFLAGS=$CFLAGS\n        _SAVE_CXXFLAGS=$CXXFLAGS\n        CFLAGS=\"-isysroot /Developer/SDKs/MacOSX10.4u.sdk $CFLAGS\"\n        CXXFLAGS=\"-isysroot /Developer/SDKs/MacOSX10.4u.sdk $CXXFLAGS\"\n        ;;\n    esac\n\n    AC_CHECK_PROGS(CC, $CC \"${target_alias}-gcc\" \"${target}-gcc\", echo)\n    unset ac_cv_prog_CC\n    dnl Now exit the conditional block to invoke AC_PROG_CC.\nfi\n\ndnl In the latest versions of autoconf, AC_PROG_CC is a one-shot macro,\ndnl declared with AC_DEFUN_ONCE. So it must not be expanded inside a\ndnl conditional block. Invoke AC_PROG_CC outside any conditional block\ndnl and before invoking AC_TRY_COMPILE (which requires AC_PROG_CC).\nAC_PROG_CC\n\ndnl Reenter the conditional blocks after invoking AC_PROG_CC.\nif test \"$target\" != \"$host\"; then\n    if test -n \"$USE_CPLUS\"; then\n        AC_CHECK_PROGS(CXX, $CXX \"${target_alias}-g++\" \"${target}-g++\", echo)\n        unset ac_cv_prog_CXX\n        AC_PROG_CXX\n    fi\n\n    case \"$build:$target\" in\n      powerpc-apple-darwin8*:i?86-apple-darwin*|*:arm*-apple-darwin*)\n        dnl Revert the changes made above.  From this point on, the target\n        dnl compiler will never be used without applying the SDK to CFLAGS\n        dnl (see --with-macos-sdk below).\n        CFLAGS=$_SAVE_CFLAGS\n        CXXFLAGS=$_SAVE_CXXFLAGS\n        ;;\n    esac\n\n    AC_CHECK_PROGS(RANLIB, $RANLIB \"${target_alias}-ranlib\" \"${target}-ranlib\", echo)\n    AC_CHECK_PROGS(AR, $AR \"${target_alias}-ar\" \"${target}-ar\", echo)\n    AC_CHECK_PROGS(AS, $AS \"${target_alias}-as\" \"${target}-as\", echo)\n    AC_CHECK_PROGS(LD, $LD \"${target_alias}-ld\" \"${target}-ld\", echo)\n    AC_CHECK_PROGS(STRIP, $STRIP \"${target_alias}-strip\" \"${target}-strip\", echo)\n    AC_CHECK_PROGS(WINDRES, $WINDRES \"${target_alias}-windres\" \"${target}-windres\", echo)\n\n    _SAVE_CC=\"$CC\"\n    _SAVE_CFLAGS=\"$CFLAGS\"\n    _SAVE_LDFLAGS=\"$LDFLAGS\"\n\n    AC_MSG_CHECKING([for $host compiler])\n    AC_CHECK_PROGS(HOST_CC, $HOST_CC gcc cc /usr/ucb/cc, \"\")\n    if test -z \"$HOST_CC\"; then\n        AC_MSG_ERROR([no acceptable cc found in \\$PATH])\n    fi\n    AC_MSG_RESULT([$HOST_CC])\n\n    CC=\"$HOST_CC\"\n    CFLAGS=\"$HOST_CFLAGS\"\n    LDFLAGS=\"$HOST_LDFLAGS\"\n\n    AC_MSG_CHECKING([whether the $host compiler ($HOST_CC $HOST_CFLAGS $HOST_LDFLAGS) works])\n    AC_TRY_COMPILE([], [return 0;],\n        [AC_MSG_RESULT([yes])],\n        [AC_MSG_ERROR([installation or configuration problem: $host compiler $HOST_CC cannot create executables.])] )\n\n    CC=$_SAVE_CC\n    CFLAGS=$_SAVE_CFLAGS\n    LDFLAGS=$_SAVE_LDFLAGS\nelse\n    if test -n \"$USE_CPLUS\"; then\n        if test \"$CC\" = \"cl\" -a -z \"$CXX\"; then\n            CXX=$CC\n        else\n            AC_PROG_CXX\n        fi\n    fi\n    AC_PROG_RANLIB\n    AC_PATH_PROGS(AS, as, $CC)\n    AC_PATH_PROGS(AR, ar, echo not_ar)\n    AC_PATH_PROGS(LD, ld link, echo not_ld)\n    AC_PATH_PROGS(STRIP, strip, echo not_strip)\n    AC_PATH_PROGS(WINDRES, windres, echo not_windres)\n    if test -z \"$HOST_CC\"; then\n        HOST_CC=\"$CC\"\n    fi\n    if test -z \"$HOST_CFLAGS\"; then\n        HOST_CFLAGS=\"$CFLAGS\"\n    fi\nfi\n\nAC_PROG_CPP\n\nif test \"$GCC\" = \"yes\"; then\n    GNU_CC=1\nfi\nif test \"$GXX\" = \"yes\"; then\n    GNU_CXX=1\nfi\nif test \"`echo | $AS -v 2>&1 | grep -c GNU`\" != \"0\"; then\n    GNU_AS=1\nfi\nrm -f a.out\n\ncase \"$build:$target\" in\n    i?86-apple-darwin*:powerpc-apple-darwin*)\n        dnl cross_compiling will have erroneously been set to \"no\" in this\n        dnl case, because the x86 build host is able to run ppc code in a\n        dnl translated environment, making a cross compiler appear native.\n        cross_compiling=yes\n        ;;\nesac\n\nif test \"$cross_compiling\"  = \"yes\"; then\n    CROSS_COMPILE=1\nelse\n    CROSS_COMPILE=\nfi\n\ndnl ========================================================\ndnl Check for gcc -pipe support\ndnl ========================================================\nAC_MSG_CHECKING([for gcc -pipe support])\nif test -n \"$GNU_CC\" && test -n \"$GNU_CXX\" && test -n \"$GNU_AS\"; then\n    echo '#include <stdio.h>' > dummy-hello.c\n    echo 'int main() { printf(\"Hello World\\n\"); return 0; }' >> dummy-hello.c\n    ${CC} -S dummy-hello.c -o dummy-hello.s 2>&5\n    cat dummy-hello.s | ${AS} -o dummy-hello.S - 2>&5\n    if test $? = 0; then\n        _res_as_stdin=\"yes\"\n    else\n        _res_as_stdin=\"no\"\n    fi\n    if test \"$_res_as_stdin\" = \"yes\"; then\n        _SAVE_CFLAGS=$CFLAGS\n        CFLAGS=\"$CFLAGS -pipe\"\n        AC_TRY_COMPILE( [ #include <stdio.h> ],\n            [printf(\"Hello World\\n\");],\n            [_res_gcc_pipe=\"yes\"],\n            [_res_gcc_pipe=\"no\"] )\n        CFLAGS=$_SAVE_CFLAGS\n    fi\n    if test \"$_res_as_stdin\" = \"yes\" && test \"$_res_gcc_pipe\" = \"yes\"; then\n        _res=\"yes\";\n        CFLAGS=\"$CFLAGS -pipe\"\n        CXXFLAGS=\"$CXXFLAGS -pipe\"\n    else\n        _res=\"no\"\n    fi\n    rm -f dummy-hello.c dummy-hello.s dummy-hello.S dummy-hello a.out\n    AC_MSG_RESULT([$_res])\nelse\n    AC_MSG_RESULT([no])\nfi\n\ndnl ========================================================\ndnl Profile guided optimization\ndnl ========================================================\ndnl Test for profiling options\ndnl Under gcc 3.4+, use -fprofile-generate/-fprofile-use\n\n_SAVE_CFLAGS=\"$CFLAGS\"\nCFLAGS=\"$CFLAGS -fprofile-generate -fprofile-correction\"\n\nAC_MSG_CHECKING([whether C compiler supports -fprofile-generate])\nAC_TRY_COMPILE([], [return 0;],\n               [ PROFILE_GEN_CFLAGS=\"-fprofile-generate\"\n                 result=\"yes\" ], result=\"no\")\nAC_MSG_RESULT([$result])\n\nif test $result = \"yes\"; then\n   PROFILE_GEN_LDFLAGS=\"-fprofile-generate\"\n   PROFILE_USE_CFLAGS=\"-fprofile-use -fprofile-correction -Wcoverage-mismatch\"\n   PROFILE_USE_LDFLAGS=\"-fprofile-use\"\nfi\n\nCFLAGS=\"$_SAVE_CFLAGS\"\n\ndnl ===============================================================\ndnl Check for .hidden assembler directive and visibility attribute.\ndnl Borrowed from glibc configure.in\ndnl ===============================================================\nif test \"$GNU_CC\"; then\n    AC_CACHE_CHECK(for visibility(hidden) attribute,\n        ac_cv_visibility_hidden,\n        [cat > conftest.c <<EOF\n        int foo __attribute__ ((visibility (\"hidden\"))) = 1;\nEOF\n        ac_cv_visibility_hidden=no\n        if ${CC-cc} -Werror -S conftest.c -o conftest.s >/dev/null 2>&1; then\n            if grep '\\.hidden.*foo' conftest.s >/dev/null; then\n                ac_cv_visibility_hidden=yes\n            fi\n        fi\n        rm -f conftest.[cs]\n        ])\n    if test \"$ac_cv_visibility_hidden\" = \"yes\"; then\n        AC_DEFINE(HAVE_VISIBILITY_HIDDEN_ATTRIBUTE)\n        AC_CACHE_CHECK(for visibility pragma support,\n            ac_cv_visibility_pragma,\n            [cat > conftest.c <<EOF\n#pragma GCC visibility push(hidden)\n            int foo_hidden = 1;\n#pragma GCC visibility push(default)\n            int foo_default = 1;\nEOF\n            ac_cv_visibility_pragma=no\n            if ${CC-cc} -Werror -S conftest.c -o conftest.s >/dev/null 2>&1; then\n                if grep '\\.hidden.*foo_hidden' conftest.s >/dev/null; then\n                    if ! grep '\\.hidden.*foo_default' conftest.s > /dev/null; then\n                        ac_cv_visibility_pragma=yes\n                    fi\n                fi\n            fi\n            rm -f conftest.[cs]\n            ])\n        if test \"$ac_cv_visibility_pragma\" = \"yes\"; then\n            AC_DEFINE(HAVE_VISIBILITY_PRAGMA)\n            # To work around a build problem on Linux x86-64 (Bugzilla bug\n            # 293438), we use the -fvisibility=hidden flag.  This flag is less\n            # optimal than #pragma GCC visibility push(hidden) because the flag\n            # assumes that symbols defined outside the current source file have\n            # the default visibility.  This has the advantage that we don't need\n            # to wrap system header files, but has the disadvantage that calls\n            # to hidden symbols defined in other source files cannot be\n            # optimized by the compiler.  The -fvisibility=hidden flag does\n            # hide and export symbols correctly.\n            #VISIBILITY_FLAGS='-I$(dist_includedir)/system_wrappers -include $(topsrcdir)/config/gcc_hidden.h'\n            #WRAP_SYSTEM_INCLUDES=1\n            VISIBILITY_FLAGS=\"-fvisibility=hidden\"\n            WRAP_SYSTEM_INCLUDES=\n        fi\n    fi\nfi # GNU_CC\n\nfi # SKIP_COMPILER_CHECKS\n\ndnl ========================================================\ndnl Checks for programs.\ndnl ========================================================\nif test -z \"$SKIP_PATH_CHECKS\"; then\n    AC_PATH_PROGS(PERL, perl5 perl, echo not_perl)\nelif test -z \"$PERL\"; then\n    PERL=perl\nfi\n\ndnl ========================================================\ndnl Default platform specific options\ndnl ========================================================\nOBJ_SUFFIX=o\nLIB_SUFFIX=a\nDLL_SUFFIX=so\nASM_SUFFIX=s\nMKSHLIB='$(LD) $(DSO_LDOPTS) -o $@'\nPR_MD_ASFILES=\nPR_MD_CSRCS=\nPR_MD_ARCH_DIR=unix\nAR_FLAGS='cr $@'\nAS='$(CC)'\nASFLAGS='$(CFLAGS)'\n\nif test -n \"$CROSS_COMPILE\"; then\n    OS_ARCH=`echo $target_os | sed -e 's|/|_|g'`\n    OS_RELEASE=\n    OS_TEST=\"${target_cpu}\"\n    case \"${target_os}\" in\n        linux*)       OS_ARCH=Linux ;;\n        solaris*)     OS_ARCH=SunOS OS_RELEASE=5 ;;\n        mingw*)       OS_ARCH=WINNT CPU_ARCH=x86 ;;\n        darwin*)      OS_ARCH=Darwin ;;\n        riscos*)      OS_ARCH=RISCOS ;;\n    esac\nelse\n    OS_ARCH=`uname -s | sed -e 's|/|_|g'`\n    OS_RELEASE=`uname -r`\n    OS_TEST=`uname -m`\nfi\n\nif test \"$OS_ARCH\" = \"IRIX64\"; then\n    OS_ARCH=IRIX\nfi\n\nif test \"$OS_ARCH\" = \"AIX\"; then\n    OS_RELEASE=`uname -v`.`uname -r`\nfi\n\nif test \"$OS_ARCH\" = \"FreeBSD\"; then\n    OS_RELEASE=`echo $OS_RELEASE | sed 's/-.*//'`\nfi\n\nif test \"$OS_ARCH\" = \"Linux\"; then\n    OS_RELEASE=`echo $OS_RELEASE | sed 's/-.*//'`\n    OS_RELEASE=`echo $OS_RELEASE | awk -F\\. '{ print $1 \".\" $2 }'`\nfi\n\n#######################################################################\n# Master \"Core Components\" macros for getting the OS target           #\n#######################################################################\n\n#\n# Note: OS_TARGET should be specified on the command line for gmake.\n# When OS_TARGET=WIN95 is specified, then a Windows 95 target is built.\n# The difference between the Win95 target and the WinNT target is that\n# the WinNT target uses Windows NT specific features not available\n# in Windows 95. The Win95 target will run on Windows NT, but (supposedly)\n# at lesser performance (the Win95 target uses threads; the WinNT target\n# uses fibers).\n#\n# If OS_TARGET is not specified, it defaults to $(OS_ARCH), i.e., no\n# cross-compilation.\n#\n\n#\n# The following hack allows one to build on a WIN95 machine (as if\n# s/he were cross-compiling on a WINNT host for a WIN95 target).\n# It also accomodates for MKS's uname.exe.  If you never intend\n# to do development on a WIN95 machine, you don't need this hack.\n#\ncase \"$OS_ARCH\" in\nWindows_95)\n    OS_ARCH=Windows_NT\n    OS_TARGET=WIN95\n    ;;\nWindows_98)\n    OS_ARCH=Windows_NT\n    OS_TARGET=WIN95\n    ;;\nCYGWIN_9*|CYGWIN_ME*)\n    OS_ARCH='CYGWIN_NT-4.0'\n    OS_TARGET=WIN95\n    ;;\nOS_2)\n    OS_ARCH=OS2\n    OS_TARGET=OS2\n    ;;\nesac\n\n#\n# On WIN32, we also define the variable CPU_ARCH.\n#\n\ncase \"$OS_ARCH\" in\nWindows_NT)\n#\n# If uname -s returns \"Windows_NT\", we assume that we are using\n# the uname.exe in MKS toolkit.\n#\n# The -r option of MKS uname only returns the major version number.\n# So we need to use its -v option to get the minor version number.\n# Moreover, it doesn't have the -p option, so we need to use uname -m.\n#\n    OS_ARCH=WINNT\n    OS_MINOR_RELEASE=`uname -v`\n    if test \"$OS_MINOR_RELEASE\" = \"00\"; then\n        OS_MINOR_RELEASE=0\n    fi\n    OS_RELEASE=\"${OS_RELEASE}.${OS_MINOR_RELEASE}\"\n    CPU_ARCH=`uname -m`\n    #\n    # MKS's uname -m returns \"586\" on a Pentium machine.\n    #\n    if echo \"$CPU_ARCH\" | grep -c 86 >/dev/null; then\n        CPU_ARCH=x86\n    fi\n    ;;\nCYGWIN_NT*|MINGW*_NT*|MSYS_NT*)\n#\n# If uname -s returns \"CYGWIN_NT-4.0\", we assume that we are using\n# the uname.exe in the Cygwin tools.\n# If uname -s returns \"MINGW32_NT-5.1\", we assume that we are using\n# the uname.exe in the MSYS tools.\n# If uname -s returns \"MSYS_NT-6.3\", we assume that we are using\n# the uname.exe in the MSYS2 tools.\n#\n    OS_RELEASE=`expr $OS_ARCH : '.*NT-\\(.*\\)'`\n    OS_ARCH=WINNT\n    CPU_ARCH=`uname -m`\n    #\n    # Cygwin's uname -m returns \"i686\" on a Pentium Pro machine.\n    #\n    if echo \"$CPU_ARCH\" | grep -c 86 >/dev/null; then\n        CPU_ARCH=x86\n    fi\n    ;;\nesac\n\nif test -n \"$MOZILLA_CLIENT\" && test \"$OS_ARCH\" = \"WINNT\"; then\n    OS_TARGET=WIN95\n    if test -n \"$MOZ_DEBUG\" -a -z \"$USE_DEBUG_RTL\"; then\n        USE_DEBUG_RTL=1\n    fi\nfi\nif test -z \"$OS_TARGET\"; then\n    OS_TARGET=$OS_ARCH\nfi\nif test \"$OS_TARGET\" = \"WIN95\"; then\n    OS_RELEASE=\"4.0\"\nfi\nOS_CONFIG=\"${OS_TARGET}${OS_RELEASE}\"\n\ndnl ========================================================\ndnl Enable high-memory support on OS/2 by default.\ndnl ========================================================\nAC_ARG_ENABLE(os2-high-mem,\n    [  --disable-os2-high-mem  Disable high-memory support on OS/2],\n    [ if test \"$enableval\" = \"no\"; then\n        MOZ_OS2_HIGH_MEMORY=\n      else\n        MOZ_OS2_HIGH_MEMORY=1\n      fi ])\n\ndnl ========================================================\ndnl = ARM toolchain tweaks\ndnl ========================================================\n\ndnl Defaults\nMOZ_ALIGN=toolchain-default\n\ncase \"$target\" in\narm*-android*|arm*-linuxandroid*)\n    MOZ_THUMB=yes\n    MOZ_ARCH=armv7-a\n    MOZ_FPU=vfp\n    MOZ_FLOAT_ABI=softfp\n    MOZ_SOFT_FLOAT=yes\n    MOZ_ALIGN=no\n    ;;\narm*-*)\n    if test -n \"$MOZ_PLATFORM_MAEMO\"; then\n        MOZ_THUMB=no\n        MOZ_ARCH=armv7-a\n        MOZ_FLOAT_ABI=softfp\n    fi\n    if test \"$MOZ_PLATFORM_MAEMO\" = 6; then\n        MOZ_THUMB=yes\n    fi\n    ;;\nesac\n\ndnl Kept for compatibility with some buildbot mozconfig\nAC_ARG_ENABLE(thumb2, [], MOZ_THUMB=$enableval)\n\nAC_ARG_WITH(thumb,\n[  --with-thumb[[=yes|no|toolchain-default]]]\n[                          Use Thumb instruction set (-mthumb)],\n    if test -z \"$GNU_CC\"; then\n        AC_MSG_ERROR([--with-thumb is not supported on non-GNU toolchain-defaults])\n    fi\n    MOZ_THUMB=$withval)\n\nAC_ARG_WITH(thumb-interwork,\n[  --with-thumb-interwork[[=yes|no|toolchain-default]]\n                           Use Thumb/ARM instuctions interwork (-mthumb-interwork)],\n    if test -z \"$GNU_CC\"; then\n        AC_MSG_ERROR([--with-thumb-interwork is not supported on non-GNU toolchain-defaults])\n    fi\n    MOZ_THUMB_INTERWORK=$withval)\n\nAC_ARG_WITH(arch,\n[  --with-arch=[[type|toolchain-default]]\n                           Use specific CPU features (-march=type)],\n    if test -z \"$GNU_CC\"; then\n        AC_MSG_ERROR([--with-arch is not supported on non-GNU toolchain-defaults])\n    fi\n    MOZ_ARCH=$withval)\n\nAC_ARG_WITH(fpu,\n[  --with-fpu=[[type|toolchain-default]]\n                           Use specific FPU type (-mfpu=type)],\n    if test -z \"$GNU_CC\"; then\n        AC_MSG_ERROR([--with-fpu is not supported on non-GNU toolchain-defaults])\n    fi\n    MOZ_FPU=$withval)\n\nAC_ARG_WITH(float-abi,\n[  --with-float-abi=[[type|toolchain-default]]\n                           Use specific arm float ABI (-mfloat-abi=type)],\n    if test -z \"$GNU_CC\"; then\n        AC_MSG_ERROR([--with-float-abi is not supported on non-GNU toolchain-defaults])\n    fi\n    MOZ_FLOAT_ABI=$withval)\n\nAC_ARG_WITH(soft-float,\n[  --with-soft-float[[=yes|no|toolchain-default]]\n                           Use soft float library (-msoft-float)],\n    if test -z \"$GNU_CC\"; then\n        AC_MSG_ERROR([--with-soft-float is not supported on non-GNU toolchain-defaults])\n    fi\n    MOZ_SOFT_FLOAT=$withval)\n\ncase \"$MOZ_ARCH\" in\ntoolchain-default|\"\")\n    arch_flag=\"\"\n    ;;\n*)\n    arch_flag=\"-march=$MOZ_ARCH\"\n    ;;\nesac\n\ncase \"$MOZ_THUMB\" in\nyes)\n    MOZ_THUMB2=1\n    thumb_flag=\"-mthumb\"\n    ;;\nno)\n    MOZ_THUMB2=\n    thumb_flag=\"-marm\"\n    ;;\n*)\n    _SAVE_CFLAGS=\"$CFLAGS\"\n    CFLAGS=\"$arch_flag\"\n    AC_TRY_COMPILE([],[return sizeof(__thumb2__);],\n        MOZ_THUMB2=1,\n        MOZ_THUMB2=)\n    CFLAGS=\"$_SAVE_CFLAGS\"\n    thumb_flag=\"\"\n    ;;\nesac\n\ncase \"$MOZ_THUMB_INTERWORK\" in\nyes)\n    thumb_interwork_flag=\"-mthumb-interwork\"\n    ;;\nno)\n    thumb_interwork_flag=\"-mno-thumb-interwork\"\n    ;;\n*) # toolchain-default\n    thumb_interwork_flag=\"\"\n    ;;\nesac\n\ncase \"$MOZ_FPU\" in\ntoolchain-default|\"\")\n    fpu_flag=\"\"\n    ;;\n*)\n    fpu_flag=\"-mfpu=$MOZ_FPU\"\n    ;;\nesac\n\ncase \"$MOZ_FLOAT_ABI\" in\ntoolchain-default|\"\")\n    float_abi_flag=\"\"\n    ;;\n*)\n    float_abi_flag=\"-mfloat-abi=$MOZ_FLOAT_ABI\"\n    ;;\nesac\n\ncase \"$MOZ_SOFT_FLOAT\" in\nyes)\n    soft_float_flag=\"-msoft-float\"\n    ;;\nno)\n    soft_float_flag=\"-mno-soft-float\"\n    ;;\n*) # toolchain-default\n    soft_float_flag=\"\"\n    ;;\nesac\n\ncase \"$MOZ_ALIGN\" in\ntoolchain-default|\"\")\n    align_flag=\"\"\n    ;;\nno)\n    align_flag=\"-mno-unaligned-access\"\n    ;;\nyes)\n    align_flag=\"-munaligned-access\"\n    ;;\n*)\n    align_flag=\"\"\n    ;;\nesac\n\nif test -n \"$align_flag\"; then\n  _SAVE_CFLAGS=\"$CFLAGS\"\n  CFLAGS=\"$CFLAGS $align_flag\"\n  AC_MSG_CHECKING(whether alignment flag ($align_flag) is supported)\n  AC_TRY_COMPILE([],[],,align_flag=\"\")\n  CFLAGS=\"$_SAVE_CFLAGS\"\nfi\n\ndnl Use echo to avoid accumulating space characters\nall_flags=`echo $arch_flag $thumb_flag $thumb_interwork_flag $fpu_flag $float_abi_flag $soft_float_flag $align_flag`\nif test -n \"$all_flags\"; then\n    _SAVE_CFLAGS=\"$CFLAGS\"\n    CFLAGS=\"$all_flags\"\n    AC_MSG_CHECKING(whether the chosen combination of compiler flags ($all_flags) works)\n    AC_TRY_COMPILE([],[return 0;],\n        AC_MSG_RESULT([yes]),\n        AC_MSG_ERROR([no]))\n\n    CFLAGS=\"$_SAVE_CFLAGS $all_flags\"\n    CXXFLAGS=\"$CXXFLAGS $all_flags\"\n    ASFLAGS=\"$ASFLAGS $all_flags\"\n    if test -n \"$thumb_flag\"; then\n        LDFLAGS=\"$LDFLAGS $thumb_flag\"\n    fi\nfi\n\ndnl ========================================================\ndnl Override of system specific host options\ndnl ========================================================\ncase \"$host\" in\n*-mingw*|*-msys*)\n    NSINSTALL=nsinstall\n    ;;\n*-cygwin*|*-mks*)\n    NSINSTALL='$(CYGWIN_WRAPPER) nsinstall'\n    if test `echo \"${PATH}\" | grep -c \\;` = 0; then\n        CYGWIN_WRAPPER='sh $(topsrcdir)/build/cygwin-wrapper'\n    fi\n    ;;\n*-beos*)\n    HOST_CFLAGS=\"$HOST_CFLAGS -DXP_BEOS -DBeOS -DBEOS -D_POSIX_SOURCE\"\n    ;;\n*os2*)\n    ;;\n*)\n    HOST_CFLAGS=\"$HOST_CFLAGS -DXP_UNIX\"\n    ;;\nesac\n\ndnl ========================================================\ndnl Override of system specific target options\ndnl ========================================================\ncase \"$target\" in\n\n*-aix*)\n    AC_DEFINE(XP_UNIX)\n    AC_DEFINE(AIX)\n    AC_DEFINE(SYSV)\n    DSO_LDOPTS='-brtl -bnortllib -bM:SRE -bnoentry -bexpall -blibpath:/usr/lib:/lib'\n    AC_CHECK_HEADER(sys/atomic_op.h, AC_DEFINE(AIX_HAVE_ATOMIC_OP_H))\n    case \"${target_os}\" in\n    aix3.2*)\n        AC_DEFINE(AIX_RENAME_SELECT)\n        AC_DEFINE(_PR_NO_LARGE_FILES)\n        AIX_LINK_OPTS='-bnso -berok'\n        PR_MD_ASFILES=os_AIX.s\n        ;;\n    aix4.1*)\n        AC_DEFINE(AIX_TIMERS)\n        AC_DEFINE(_PR_NO_LARGE_FILES)\n        AC_DEFINE(AIX4_1)\n        MKSHLIB=\n        DSO_LDOPTS=\n        AIX_LINK_OPTS='-bnso -berok'\n        LIBNSPR='-L$(dist_libdir) -lnspr$(MOD_MAJOR_VERSION)_shr'\n        LIBPLC='-L$(dist_libdir) -lplc$(MOD_MAJOR_VERSION)_shr'\n        ;;\n    aix4.2*)\n        AC_DEFINE(AIX_TIMERS)\n        AC_DEFINE(_PR_HAVE_OFF64_T)\n        AIX_LINK_OPTS='-brtl -bnso -berok'\n        ;;\n    aix4.3*)\n        AC_DEFINE(AIX_TIMERS)\n        AC_DEFINE(_PR_HAVE_OFF64_T)\n        AC_DEFINE(AIX4_3_PLUS)\n        AC_DEFINE(HAVE_SOCKLEN_T)\n        AC_DEFINE(HAVE_FCNTL_FILE_LOCKING)\n        USE_IPV6=1\n        AIX_LINK_OPTS='-brtl -bnso -berok'\n        ;;\n    *)\n        AC_DEFINE(AIX_TIMERS)\n        AC_DEFINE(_PR_HAVE_OFF64_T)\n        AC_DEFINE(AIX4_3_PLUS)\n        AC_DEFINE(HAVE_SOCKLEN_T)\n        AC_DEFINE(HAVE_FCNTL_FILE_LOCKING)\n        USE_IPV6=1\n        AIX_LINK_OPTS='-brtl -bnso -berok'\n        ;;\n    esac\n    CFLAGS=\"$CFLAGS -qro -qroconst\"\n    AIX_WRAP='$(DIST)/lib/aixwrap.o'\n    AIX_TMP='./_aix_tmp.o'\n    if test -n \"$USE_64\"; then\n        MDCPUCFG_H=_aix64.cfg\n        OBJECT_MODE=64\n    else\n        MDCPUCFG_H=_aix32.cfg\n    fi\n    PR_MD_CSRCS=aix.c\n    RESOLVE_LINK_SYMBOLS=1\n    ;;\n        \n*-beos*)\n    AC_DEFINE(XP_BEOS)\n    AC_DEFINE(BeOS)\n    AC_DEFINE(BEOS)\n    AC_DEFINE(_POSIX_SOURCE)\n    DSO_LDOPTS=-nostart\n    MDCPUCFG_H=_beos.cfg\n    USE_BTHREADS=1\n    PR_MD_ARCH_DIR=beos\n    RESOLVE_LINK_SYMBOLS=1\n    case \"${target_cpu}\" in\n    i*86)\n        _OPTIMIZE_FLAGS=-O2\n        _DEBUG_FLAGS='-gdwarf-2 -O0'\n        MKSHLIB='$(CCC) $(DSO_LDOPTS) -o $@'\n        AC_CHECK_LIB(bind, gethostbyaddr, [OS_LIBS=\"$OS_LIBS -lbind -lsocket\"])\n        ;;\n    powerpc)\n        CC=mwcc\n        CCC=mwcc\n        LD=mwld\n        DSO_LDOPTS='-xms -export pragma -init _init_routine_ -term _term_routine_ -lroot -lnet /boot/develop/lib/ppc/glue-noinit.a /boot/develop/lib/ppc/init_term_dyn.o /boot/develop/lib/ppc/start_dyn.o'\n        _OPTIMIZE_FLAGS=-O2    \n        _DEBUG_FLAGS='-g -O0'\n        ;;\n    esac\n    ;;\n\n*-bsdi*)\n    AC_DEFINE(XP_UNIX)\n    AC_DEFINE(BSDI)\n    AC_DEFINE(NEED_BSDREGEX)\n\n    CFLAGS=\"$CFLAGS -Wall -Wno-format\"\n    CXXFLAGS=\"$CXXFLAGS -Wall -Wno-format\"\n\n    if echo \"$OS_TEST\" | grep -c 86 >/dev/null; then\n        CPU_ARCH=x86\n    elif echo \"$OS_TEST\" | grep -c sparc >/dev/null; then \n        CPU_ARCH=sparc\n    fi\n\n    MDCPUCFG_H=_bsdi.cfg\n    PR_MD_CSRCS=bsdi.c\n\n    DSO_LDOPTS=-r\n\n    case \"$target_os\" in\n    bsdi1.1*)\n        AC_DEFINE(_PR_BSDI_JMPBUF_IS_ARRAY)\n        AC_DEFINE(_PR_STAT_HAS_ONLY_ST_ATIME)\n        AC_DEFINE(_PR_NEED_H_ERRNO)\n        MKSHLIB=\n        DSO_CFLAGS=\n        DSO_LDOPTS=\n        ;;\n\n    bsdi2.1*)\n        AC_DEFINE(_PR_TIMESPEC_HAS_TS_SEC)\n        AC_DEFINE(_PR_BSDI_JMPBUF_IS_ARRAY)\n        AC_DEFINE(HAVE_DLL)\n        AC_DEFINE(USE_DLFCN)\n        AC_DEFINE(_PR_STAT_HAS_ST_ATIMESPEC)\n        PR_MD_ASFILES=os_BSD_OS_386_2.s\n        ;;\n\n    bsdi4.* | bsdi5.*)\n        AC_DEFINE(_PR_SELECT_CONST_TIMEVAL)\n        AC_DEFINE(_PR_BSDI_JMPBUF_IS_STRUCT)\n        AC_DEFINE(HAVE_DLL)\n        AC_DEFINE(USE_DLFCN)\n        AC_DEFINE(_PR_STAT_HAS_ST_ATIMESPEC)\n        MKSHLIB='$(CC) -o $@ $(DSO_LDOPTS)'\n        DSO_CFLAGS=-fPIC\n        DSO_LDOPTS='-shared -Wl,-soname,$(@:$(OBJDIR)/%.so=%.so)'\n        STRIP=\"$STRIP -d\"\n        case \"$target_os\" in\n        bsdi4.2* | bsdi4.3* | bsdi5.*)\n            AC_DEFINE(_PR_HAVE_GETPROTO_R)\n            AC_DEFINE(_PR_HAVE_GETPROTO_R_POINTER)\n            ;;\n        esac\n        ;;\n    *)\n        AC_DEFINE(_PR_SELECT_CONST_TIMEVAL)\n        AC_DEFINE(_PR_BSDI_JMPBUF_IS_STRUCT)\n        AC_DEFINE(HAVE_DLL)\n        AC_DEFINE(USE_DLFCN)\n        AC_DEFINE(_PR_STAT_HAS_ST_ATIMESPEC)\n        ;;\n    esac\n\n    ;;\n\n*-darwin*)\n    AC_DEFINE(XP_UNIX)\n    AC_DEFINE(DARWIN)\n    AC_DEFINE(HAVE_BSD_FLOCK)\n    AC_DEFINE(HAVE_SOCKLEN_T)\n    AS='$(CC) -x assembler-with-cpp'\n    CFLAGS=\"$CFLAGS -Wall -fno-common\"\n    case \"${target_cpu}\" in\n        arm*)\n            CPU_ARCH=arm\n            ;;\n        i*86*|x86_64)\n            if test -n \"$USE_64\"; then\n                CPU_ARCH=x86_64\n            else        \n                CPU_ARCH=i386\n            fi\n            ;;\n        *)\n            CPU_ARCH=ppc\n            ;;\n    esac\n    if test \"`echo $CC | grep -c '\\-arch '`\" = \"0\"; then\n        CC=\"$CC -arch $CPU_ARCH\"\n    fi\n    AC_CHECK_HEADER(crt_externs.h, AC_DEFINE(HAVE_CRT_EXTERNS_H))\n    DSO_CFLAGS=-fPIC\n    DSO_LDOPTS='-dynamiclib -compatibility_version 1 -current_version 1 -all_load -install_name @executable_path/$@ -headerpad_max_install_names'\n    _OPTIMIZE_FLAGS=-O2\n    MKSHLIB='$(CC) $(DSO_LDOPTS) -o $@'\n    STRIP=\"$STRIP -x -S\"\n    DLL_SUFFIX=dylib\n    USE_PTHREADS=1\n    MDCPUCFG_H=_darwin.cfg\n    PR_MD_CSRCS=darwin.c\n    PR_MD_ASFILES=os_Darwin.s\n\n    # Add Mac OS X support for loading CFM & CFBundle plugins\n    if test -f \"${MACOS_SDK_DIR}/System/Library/Frameworks/Carbon.framework/Carbon\"; then\n        AC_DEFINE(XP_MACOSX)\n        OS_TARGET=MacOSX\n\n        if test -n \"$_MACOSX_DEPLOYMENT_TARGET\" ; then\n            dnl Use the specified value\n            export MACOSX_DEPLOYMENT_TARGET=$_MACOSX_DEPLOYMENT_TARGET\n        elif test -z \"$MACOSX_DEPLOYMENT_TARGET\" ; then\n            dnl No value specified on the command line or in the environment,\n            dnl use the lesser of the library's minimum or the architecture's\n            dnl minimum.\n            case \"${target_cpu}\" in\n                powerpc*)\n                    dnl Architecture minimum 10.2\n                    export MACOSX_DEPLOYMENT_TARGET=10.2\n                    ;;\n                i*86*)\n                    dnl Architecture minimum 10.4\n                    export MACOSX_DEPLOYMENT_TARGET=10.4\n                    ;;\n            esac\n        fi\n\n        dnl MACOS_SDK_DIR will be set to the SDK location whenever one is\n        dnl in use.  NEXT_ROOT will be set and exported if it's needed for\n        dnl ld.\n\n        if test \"$MACOS_SDK_DIR\"; then\n            dnl Sync this section with the one in Mozilla's top level.\n\n            if test ! -d \"$MACOS_SDK_DIR\"; then\n                AC_MSG_ERROR([SDK not found.  When using --with-macos-sdk, you must\nspecify a valid SDK.  SDKs are installed when the optional cross-development\ntools are selected during the Xcode/Developer Tools installation.])\n            fi\n\n            changequote(,)\n            CC_VERSION=`$CC -v 2>&1 | grep 'gcc version'`\n            GCC_VERSION_FULL=`echo $CC_VERSION | $PERL -pe 's/^.*gcc version ([^ ]*).*/$1/'`\n            GCC_VERSION=`echo $GCC_VERSION_FULL | $PERL -pe '(split(/\\./))[0]>=4&&s/(^\\d*\\.\\d*).*/$1/;'`\n            changequote([,])\n            GCC_VERSION_MAJOR=`echo $GCC_VERSION_FULL | $PERL -pe 's/(^\\d*).*/$1/;'`\n            if test \"$GCC_VERSION_MAJOR\" -lt \"4\" ; then\n                SDK_C_FRAMEWORK=\"-F${MACOS_SDK_DIR}/System/Library/Frameworks\"\n                if test -d \"${MACOS_SDK_DIR}/Library/Frameworks\" ; then\n                    SDK_C_FRAMEWORK=\"$SDK_C_FRAMEWORK -F${MACOS_SDK_DIR}/Library/Frameworks\"\n                fi\n\n                SDK_C_INCLUDE=\"-isystem ${MACOS_SDK_DIR}/usr/include/gcc/darwin/${GCC_VERSION} -isystem ${MACOS_SDK_DIR}/usr/include ${SDK_C_FRAMEWORK}\"\n\n                CFLAGS=\"$CFLAGS -nostdinc ${SDK_C_INCLUDE}\"\n\n                dnl CPP needs to be set for AC_CHECK_HEADER.\n                CPP=\"$CPP -nostdinc ${SDK_C_INCLUDE}\"\n\n                changequote(,)\n                HOST_DARWIN_MAJOR=`echo \"$build_os\" | sed -E -e 's/^darwin([0-9]+).*$/\\1/'`\n                changequote([,])\n                if test \"$HOST_DARWIN_MAJOR\" -lt 9 ; then\n                    dnl The build host is running Tiger (10.4) or earlier.\n                    dnl ld support for -syslibroot is compiler-agnostic, but\n                    dnl only available on Tiger and later.  On Tiger and\n                    dnl earlier build hosts, just rely on NEXT_ROOT, because\n                    dnl it's not been shown to cause any problems.\n                    MACOS_SDK_LIBS=\"-L${MACOS_SDK_DIR}/usr/lib/gcc/darwin -L${MACOS_SDK_DIR}/usr/lib/gcc/darwin/${GCC_VERSION_FULL} -L${MACOS_SDK_DIR}/usr/lib ${SDK_C_FRAMEWORK}\"\n                else\n                    dnl The build host is running Leopard (10.5) or later.\n                    dnl With NEXT_ROOT set, the linker will still not apply\n                    dnl it when resolving dependencies.  This causes problems\n                    dnl on Leopard, where an SDK depends on frameworks which\n                    dnl were present in earlier OS releases (and the associated\n                    dnl SDK) but not in Leopard.  -syslibroot does not have\n                    dnl this problem, but it results in harmless warnings when\n                    dnl NEXT_ROOT is set.  NEXT_ROOT needs to remain set even\n                    dnl on Leopard because the compiler uses it too.\n                    MACOS_SDK_LIBS=\"-Wl,-syslibroot,${MACOS_SDK_DIR}\"\n                fi\n\n                LDFLAGS=\"${MACOS_SDK_LIBS} $LDFLAGS\"\n                export NEXT_ROOT=$MACOS_SDK_DIR\n\n                if test -n \"$CROSS_COMPILE\" ; then\n                    dnl NEXT_ROOT will be in the environment, but it\n                    dnl shouldn't be set for the build host.  HOST_CXX is\n                    dnl presently unused.\n                    HOST_CC=\"NEXT_ROOT= $HOST_CC\"\n                    HOST_CXX=\"NEXT_ROOT= $HOST_CXX\"\n                fi\n            else\n                dnl gcc >= 4.0 uses different paths than above, but knows\n                dnl how to find them itself.\n                CFLAGS=\"$CFLAGS -isysroot ${MACOS_SDK_DIR}\"\n\n                dnl CPP needs to be set for AC_CHECK_HEADER.\n                CPP=\"$CPP -isysroot ${MACOS_SDK_DIR}\"\n\n                dnl If gcc >= 4.0.0, we're guaranteed to be on Tiger, which\n                dnl has an ld that supports -syslibroot.  Don't set\n                dnl NEXT_ROOT because it will be ignored and cause\n                dnl warnings when -syslibroot is specified.\n                if test \"$GCC_VERSION_FULL\" != \"4.0.0\" ; then\n                    dnl gcc > 4.0.0 will pass -syslibroot to ld automatically\n                    dnl based on the -isysroot it receives.\n                    LDFLAGS=\"$LDFLAGS -isysroot ${MACOS_SDK_DIR}\"\n                else\n                    dnl gcc 4.0.0 doesn't pass -syslibroot to ld, it needs\n                    dnl to be explicit.\n                    LDFLAGS=\"$LDFLAGS -Wl,-syslibroot,${MACOS_SDK_DIR}\"\n                fi\n            fi\n        fi\n    fi\n    ;;\n\n*-dgux*)\n    AC_DEFINE(XP_UNIX)\n    AC_DEFINE(_PR_LOCAL_THREADS_ONLY)\n    AC_DEFINE(SVR4)\n    AC_DEFINE(SYSV)\n    AC_DEFINE(DGUX)\n    AC_DEFINE(_DGUX_SOURCE)\n    AC_DEFINE(_POSIX4A_DRAFT6_SOURCE)\n    DSO_LDOPTS=-G\n    _OPTIMIZE_FLAGS=-O2\n    _DEBUG_FLAGS=\n    MDCPUCFG_H=_dgux.cfg\n    PR_MD_CSRCS=dgux.c\n    ;;\n\n*-freebsd*)\n    if test -z \"$USE_NSPR_THREADS\"; then\n        USE_PTHREADS=1\n    fi\n    AC_DEFINE(XP_UNIX)\n    AC_DEFINE(FREEBSD)\n    AC_DEFINE(HAVE_BSD_FLOCK)\n    AC_DEFINE(HAVE_SOCKLEN_T)\n    CFLAGS=\"$CFLAGS $(DSO_CFLAGS) -ansi -Wall\"\n    MOZ_OBJFORMAT=`test -x /usr/bin/objformat && /usr/bin/objformat || echo elf`\n    if test \"$MOZ_OBJFORMAT\" = \"elf\"; then\n        DLL_SUFFIX=so\n    else\n        DLL_SUFFIX=so.1.0\n    fi\n    MKSHLIB='$(CC) $(DSO_LDOPTS) -o $@'\n    DSO_CFLAGS=-fPIC\n    DSO_LDOPTS='-shared -Wl,-soname -Wl,$(notdir $@)'\n    MDCPUCFG_H=_freebsd.cfg\n    PR_MD_CSRCS=freebsd.c\n    ;;\n\n*-hpux*)\n    AC_DEFINE(XP_UNIX)\n    AC_DEFINE(HPUX)\n    AC_DEFINE(_HPUX_SOURCE)\n    # OSF1 and HPUX report the POLLHUP event for a socket when the\n    # shutdown(SHUT_WR) operation is called for the remote end, even though\n    # the socket is still writeable. Use select(), instead of poll(), to\n    # workaround this problem.\n    AC_DEFINE(_PR_POLL_WITH_SELECT)\n    AC_DEFINE(_USE_BIG_FDS)\n    DSO_LDOPTS='-b +h $(notdir $@)'\n    PR_MD_CSRCS=hpux.c\n    if test \"$OS_TEST\" = \"ia64\"; then\n        DLL_SUFFIX=so\n        DSO_LDOPTS=\"$DSO_LDOPTS +b '\\$\\$ORIGIN'\"\n        CPU_ARCH_TAG=_$OS_TEST \n        if test -z \"$USE_64\"; then\n            COMPILER_TAG=_32\n        fi\n        PR_MD_ASFILES=os_HPUX_ia64.s\n    else\n        AC_DEFINE(hppa)\n        DLL_SUFFIX=sl\n        PR_MD_ASFILES=os_HPUX.s\n    fi\n    if test -n \"$USE_64\"; then\n        MDCPUCFG_H=_hpux64.cfg\n    else\n        MDCPUCFG_H=_hpux32.cfg\n    fi\n    if test -z \"$GNU_CC\"; then\n        CC=\"$CC -Ae\"\n        CXX=\"$CXX -ext\"\n        DSO_CFLAGS=+Z\n    else\n        DSO_CFLAGS=-fPIC\n        ASFLAGS=\"$ASFLAGS -x assembler-with-cpp\"\n    fi\n\n    if test -n \"$MOZILLA_CLIENT\"; then\n        DEFAULT_IMPL_STRATEGY=_EMU\n    fi\n\n    if echo \"$OS_RELEASE\" | grep ^A.09 >/dev/null; then\n        AC_DEFINE(_PR_NEED_H_ERRNO)\n        AC_DEFINE(HPUX9)\n        DEFAULT_IMPL_STRATEGY=_EMU\n    \tUSE_NSPR_THREADS=1\n    fi\n\n    if echo \"$OS_RELEASE\" | egrep '^(A.09|B.10)' >/dev/null; then\n        AC_DEFINE(_PR_NO_LARGE_FILES)\n    fi\n\n    if echo \"$OS_RELEASE\" | egrep '^(B.10.10|B.10.20)' >/dev/null; then\n        AC_DEFINE(_PR_NEED_H_ERRNO)\n    fi\n\n    if echo \"$OS_RELEASE\" | egrep '^(B.10.10|B.10.20)' >/dev/null; then\n        AC_DEFINE(HAVE_INT_LOCALTIME_R)\n    fi\n\n    if echo \"$OS_RELEASE\" | egrep '^(B.10.30|B.11)' >/dev/null; then\n        AC_DEFINE(HAVE_POINTER_LOCALTIME_R)\n    fi\n\n    # HP-UX 11i v2 (B.11.23) or higher\n    changequote(<<,>>)\n    case \"$OS_RELEASE\" in\n    [C-Z]*|B.[2-9]*|B.1[2-9]*|B.11.[3-9]*|B.11.2[3-9]*)\n        USE_IPV6=1\n        ;;\n    esac\n    changequote([,])\n\n    if test \"$OS_RELEASE\" = \"B.10.01\"; then\n        AC_DEFINE(HPUX10)\n        DEFAULT_IMPL_STRATEGY=_EMU\n    fi\n\n    if test \"$OS_RELEASE\" = \"B.10.10\"; then\n        AC_DEFINE(HPUX10)\n        AC_DEFINE(HPUX10_10)\n        DEFAULT_IMPL_STRATEGY=_PTH\n    fi\n\n    if test \"$OS_RELEASE\" = \"B.10.20\"; then\n        AC_DEFINE(HPUX10)\n        AC_DEFINE(HPUX10_20)\n        if test -z \"$GNU_CC\"; then\n            CFLAGS=\"$CFLAGS +DAportable +DS1.1\"\n            CXXFLAGS=\"$CXXFLAGS +DAportable +DS1.1\"\n        fi\n        DEFAULT_IMPL_STRATEGY=_PTH\n    fi\n\n    if test \"$OS_RELEASE\" = \"B.10.30\"; then\n        AC_DEFINE(HPUX10)\n        AC_DEFINE(HPUX10_30)\n        if test -z \"$GNU_CC\"; then\n            CFLAGS=\"$CFLAGS +DAportable +DS1.1\"\n            CXXFLAGS=\"$CXXFLAGS +DAportable +DS1.1\"\n        fi\n        DEFAULT_IMPL_STRATEGY=_PTH\n    fi\n\n    if echo \"$OS_RELEASE\" | grep ^B.11 >/dev/null; then\n        AC_DEFINE(HPUX10)\n        AC_DEFINE(HPUX11)\n        AC_DEFINE(_LARGEFILE64_SOURCE)\n        AC_DEFINE(_PR_HAVE_OFF64_T)\n        AC_DEFINE(HAVE_FCNTL_FILE_LOCKING)\n        if test -z \"$GNU_CC\"; then\n            if test -z \"$USE_64\"; then\n                if test \"$OS_TEST\" = \"ia64\"; then\n                    CFLAGS=\"$CFLAGS +DD32\"\n                    CXXFLAGS=\"$CXXFLAGS +DD32\"\n                else\n                    CFLAGS=\"$CFLAGS +DAportable +DS2.0\"\n                    CXXFLAGS=\"$CXXFLAGS +DAportable +DS2.0\"\n                fi\n            else\n                if test \"$OS_TEST\" = \"ia64\"; then\n                    CFLAGS=\"$CFLAGS +DD64\"\n                    CXXFLAGS=\"$CXXFLAGS +DD64\"\n                else\n                    CFLAGS=\"$CFLAGS +DA2.0W +DS2.0\"\n                    CXXFLAGS=\"$CXXFLAGS +DA2.0W +DS2.0\"\n                fi\n            fi\n        fi\n        DEFAULT_IMPL_STRATEGY=_PTH\n    fi\n\n    if test \"$DEFAULT_IMPL_STRATEGY\" = \"_EMU\"; then\n        USE_NSPR_THREADS=1\n        USE_PTHREADS=\n        USE_USER_PTHREADS=\n    elif test \"$DEFAULT_IMPL_STRATEGY\" = \"_PTH\"; then\n        USE_PTHREADS=1\n        if test \"$USE_NSPR_THREADS\"; then\n            USE_PTHREADS=\n        fi\n        if test \"$USE_USER_PTHREADS\"; then\n            USE_PTHREADS=\n        fi\n    fi\n    ;;\n\n*-irix*)\n    AC_DEFINE(XP_UNIX)\n    AC_DEFINE(IRIX)\n    AC_DEFINE(SVR4)\n    AC_DEFINE(_SGI_MP_SOURCE)\n    AC_DEFINE(HAVE_FCNTL_FILE_LOCKING)\n    PR_MD_CSRCS=irix.c\n    PR_MD_ASFILES=os_Irix.s\n    MKSHLIB='$(LD) $(DSO_LDOPTS) -rdata_shared -shared -soname $(notdir $@) -o $@'\n    STRIP=\"$STRIP -f\"\n    RESOLVE_LINK_SYMBOLS=1\n    if test -n \"$USE_64\"; then\n        MDCPUCFG_H=_irix64.cfg\n    else\n        MDCPUCFG_H=_irix32.cfg\n    fi\n    case \"${target_os}\" in\n    irix6*)\n        AC_DEFINE(IRIX6)\n        USE_PTHREADS=1\n        USE_N32=1\n        COMPILER_TAG=_n32\n        IMPL_STRATEGY=_PTH\n        ;;\n    irix5*)\n        AC_DEFINE(IRIX5)\n        USE_NSPR_THREADS=1\n        ;;\n    *)\n        USE_PTHREADS=1\n        USE_N32=1\n        ;;\n    esac\n    if test \"$GNU_CC\"; then\n        dnl\n        dnl If we are using gcc with native binutils, we need to\n        dnl suppress the\n        dnl #lineno \"filename\" num num\n        dnl lines, which confuse IRIX native as.  Add -Wp,-P to the\n        dnl gcc command line, which passes -P to the preprocessor.\n        dnl\n\t    AS='$(CC) -Wp,-P -x assembler-with-cpp -D_ASM -mips2 $(INCLUDES)'\n\t    CFLAGS=\"$CFLAGS -Wall -Wno-format\"\n\t    _OPTIMIZE_FLAGS=\"-O6\"\n    else\n\t    if test -n \"$USE_N32\"; then\n\t\tAS='as -D_ASM $(INCLUDES) -n32'\n\t    else\n\t\tAS='as -D_ASM $(INCLUDES)'\n\t    fi\n\t    CFLAGS=\"$CFLAGS -fullwarn -xansi\"\n\t    if test \"$USE_N32\"; then\n\t        _OPTIMIZE_FLAGS=\"-O -OPT:Olimit=4000\"\n\t    else\n\t        _OPTIMIZE_FLAGS=\"-O -Olimit 4000\"\n\t    fi\n\t    if test \"$USE_MDUPDATE\"; then\n                CFLAGS=\"$CFLAGS -MDupdate \\$(DEPENDENCIES)\"\n\t    fi\n\t    case \"${target}\" in\n\t    *-irix6.*)\n\t        CFLAGS=\"$CFLAGS -multigot\"\n\t        DSO_LDOPTS=\"-no_unresolved\"\n\t        if test \"$USE_N32\"; then\n\t\t        CFLAGS=\"$CFLAGS -n32 -woff 1209\"\n\t\t        DSO_LDOPTS=\"$DSO_LDOPTS -n32\"\n\t        else\n\t\t        if test \"$USE_64\"; then\n\t\t            CFLAGS=\"$CFLAGS -64\"\n\t\t        else\n\t\t            CFLAGS=\"$CFLAGS -32\"\n\t\t        fi\n\t        fi\n\t        ;;\n\t    *)\n\t        CFLAGS=\"$CFLAGS -xgot\"\n\t        ;;\n\t    esac\n    fi\n    if test \"${target_os}\" = \"irix5.3\"; then\n\t    AC_DEFINE(IRIX5_3)\n    fi\n    case \"${target_os}\" in\n\tirix6.5)\n\t    if test -z \"$GNU_CC\"; then\n\t\t    CFLAGS=\"$CFLAGS -mips3\"\n\t    fi\n\t    AC_DEFINE(_PR_HAVE_GETPROTO_R)\n\t    AC_DEFINE(_PR_HAVE_GETPROTO_R_POINTER)\n\t    AC_DEFINE(_PR_HAVE_SGI_PRDA_PROCMASK)\n\t    ;;\n\tirix5*)\n\t    ;;\n\t*)\n\t    AC_DEFINE(_PR_HAVE_SGI_PRDA_PROCMASK)\n\t    ;;\n\tesac\n    ;;\n\n*-linux*|*-gnu*|*-k*bsd*-gnu|*-android*|*-linuxandroid*)\n    if test -z \"$USE_NSPR_THREADS\"; then\n        USE_PTHREADS=1\n        IMPL_STRATEGY=_PTH\n    fi\n    AC_DEFINE(XP_UNIX)\n    AC_DEFINE(_GNU_SOURCE)\n    AC_DEFINE(HAVE_FCNTL_FILE_LOCKING)\n    case \"${target}\" in\n    *-android*|*-linuxandroid*)\n        OS_TARGET=Android\n        AC_DEFINE(LINUX)\n        ;;\n    *-linux*)\n        AC_DEFINE(LINUX)\n        ;;\n    esac\n    CFLAGS=\"$CFLAGS -Wall\"\n    CXXFLAGS=\"$CXXFLAGS -Wall\"\n    MDCPUCFG_H=_linux.cfg\n    PR_MD_CSRCS=linux.c\n    MKSHLIB='$(CC) $(DSO_LDOPTS) -o $@'\n    DSO_CFLAGS=-fPIC\n    DSO_LDOPTS='-shared -Wl,-soname -Wl,$(notdir $@)'\n    _OPTIMIZE_FLAGS=-O2\n    _DEBUG_FLAGS=\"-g -fno-inline\"  # most people on linux use gcc/gdb, and that\n                                   # combo is not yet good at debugging inlined\n                                   # functions (even when using DWARF2 as the\n                                   # debugging format)\n    COMPILER_TAG=_glibc\n    if echo \"$OS_TEST\" | grep -c 86 >/dev/null; then\n        CPU_ARCH=x86\n    else\n        CPU_ARCH=$OS_TEST\n    fi\n    CPU_ARCH_TAG=_${CPU_ARCH}\n    case \"${target_cpu}\" in\n    alpha)\n        AC_DEFINE(_ALPHA_)\n        AC_DEFINE(__alpha)\n        CFLAGS=\"$CFLAGS -mieee\"\n        CXXFLAGS=\"$CXXFLAGS -mieee\"\n        ;;\n    i*86)\n        AC_DEFINE(i386)\n        PR_MD_ASFILES=os_Linux_x86.s\n        ;;\n    ia64)\n        PR_MD_ASFILES=os_Linux_ia64.s\n        ;;\n    x86_64)\n        if test -n \"$USE_64\"; then\n            PR_MD_ASFILES=os_Linux_x86_64.s\n        elif test -n \"$USE_X32\"; then\n            PR_MD_ASFILES=os_Linux_x86_64.s\n            CC=\"$CC -mx32\"\n            CXX=\"$CXX -mx32\"\n        else\n            AC_DEFINE(i386)\n            PR_MD_ASFILES=os_Linux_x86.s\n            CC=\"$CC -m32\"\n            CXX=\"$CXX -m32\"\n        fi\n        ;;\n    ppc|powerpc)\n        PR_MD_ASFILES=os_Linux_ppc.s\n        ;;\n    powerpc64)\n        if test -n \"$USE_64\"; then\n            CC=\"$CC -m64\"\n            CXX=\"$CXX -m64\"\n        else\n            PR_MD_ASFILES=os_Linux_ppc.s\n        fi\n        ;;\n    esac    \n    ;;\n\n*-mingw*|*-msys*|*-cygwin*|*-mks*)\n    AC_DEFINE(XP_PC)\n    AC_DEFINE(WIN32)\n    PR_MD_ARCH_DIR=windows\n    RESOLVE_LINK_SYMBOLS=1\n\n    if test -n \"$GNU_CC\"; then\n        CC=\"$CC -mwindows\"\n        CXX=\"$CXX -mwindows\"\n        DLL_SUFFIX=dll\n        MKSHLIB='$(CC) -shared -Wl,--export-all-symbols -Wl,--out-implib -Wl,$(IMPORT_LIBRARY) $(DLLBASE) -o $(subst $(OBJDIR)/,,$(SHARED_LIBRARY))'\n        RC=$WINDRES\n        # Use temp file for windres (bug 213281)\n        RCFLAGS='-O coff --use-temp-file'\n    else\n        LD=link\n        AR='lib -NOLOGO -OUT:\"$@\"'\n        AR_FLAGS=\n        RANLIB='echo not_ranlib'\n        STRIP='echo not_strip'\n        RC=rc.exe\n        GARBAGE='$(OBJDIR)/vc20.pdb $(OBJDIR)/vc40.pdb'\n        OBJ_SUFFIX=obj\n        LIB_SUFFIX=lib\n        DLL_SUFFIX=dll\n\n        # Determine compiler version\n        changequote(,)\n        _MSVC_VER_FILTER='s|.* \\([0-9]\\+\\.[0-9]\\+\\.[0-9]\\+\\(\\.[0-9]\\+\\)\\?\\).*|\\1|p'\n        changequote([,])\n        CC_VERSION=`${CC} -v 2>&1 | sed -ne \"$_MSVC_VER_FILTER\"`\n        if test -z \"$CC_VERSION\"; then\n            AC_MSG_ERROR([Could not determine MSC version.])\n        fi\n\n        _CC_MAJOR_VERSION=`echo ${CC_VERSION} | awk -F\\. '{ print $1 }'`\n        _CC_MINOR_VERSION=`echo ${CC_VERSION} | awk -F\\. '{ print $2 }'`\n        _CC_RELEASE=`echo ${CC_VERSION} | awk -F\\. '{ print $3 }'`\n        _CC_BUILD=`echo ${CC_VERSION} | awk -F\\. '{ print $4 }'`\n        MSC_VER=${_CC_MAJOR_VERSION}${_CC_MINOR_VERSION}\n\n        if test \"$_CC_MAJOR_VERSION\" -eq \"14\"; then\n           dnl -DYNAMICBASE is only supported on VC8SP1 or newer,\n           dnl so be very specific here!\n           dnl VC8 is 14.00.50727.42, VC8SP1 is 14.00.50727.762\n           if test $_CC_RELEASE -gt 50727; then\n              _USE_DYNAMICBASE=1\n           elif test $_CC_BUILD -ge 762; then\n              _USE_DYNAMICBASE=1\n           fi\n           AC_DEFINE(_CRT_SECURE_NO_DEPRECATE)\n           AC_DEFINE(_CRT_NONSTDC_NO_DEPRECATE)\n        elif test $_CC_MAJOR_VERSION -ge 15; then\n           _USE_DYNAMICBASE=1    \n           AC_DEFINE(_CRT_SECURE_NO_WARNINGS)\n           AC_DEFINE(_CRT_NONSTDC_NO_WARNINGS)\n        fi\n\n        if test -n \"$_USE_DYNAMICBASE\"; then\n           DLLFLAGS=\"$DLLFLAGS -DYNAMICBASE\"\n        fi\n\n        # Ensure that mt is Microsoft (R) Manifest Tool and not magnetic\n        # tape manipulation utility (or something else)\n        if test \"$MSC_VER\" -ge \"1400\"; then\n            changequote(,)\n            _MSMT_VER_FILTER='s|.* \\([0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\.[0-9][0-9]*\\).*|\\1|p'\n            changequote([,])\n\n            MSMT_TOOL=`mt 2>&1|grep 'Microsoft (R) Manifest Tool'`\n            if test -n \"$MSMT_TOOL\"; then\n                MSMANIFEST_TOOL_VERSION=`echo ${MSMT_TOOL}|sed -ne \"$_MSMT_VER_FILTER\"`\n                if test -z \"$MSMANIFEST_TOOL_VERSION\"; then\n                    AC_MSG_WARN([Unknown version of the Microsoft (R) Manifest Tool.])\n                fi\n                MT=mt\n                unset MSMT_TOOL\n            else\n                AC_MSG_ERROR([Microsoft (R) Manifest Tool must be in your \\$PATH.])\n            fi\n        fi\n        \n        CFLAGS=\"$CFLAGS -W3 -nologo -GF -Gy\"\n        DLLFLAGS=\"$DLLFLAGS -OUT:\\\"\\$@\\\"\"\n        _DEBUG_FLAGS=-Zi\n        _OPTIMIZE_FLAGS=-O2\n\n        PROFILE_GEN_CFLAGS=\"-GL\"\n        PROFILE_GEN_LDFLAGS=\"-LTCG:PGINSTRUMENT\"\n        PROFILE_USE_CFLAGS=\"-GL -wd4624 -wd4952\"\n        PROFILE_USE_LDFLAGS=\"-LTCG:PGUPDATE\"\n\n        if test \"$MSC_VER\" -ge \"1800\"; then\n            dnl Visual C++ 2013 requires -FS when parallel building with\n            dnl make -jN. If not specified, compiler sometimes emits C1041\n            dnl error.\n            CFLAGS=\"$CFLAGS -FS\"\n            dnl -Gw can benefit when using linker optimization on PGO.\n            dnl http://blogs.msdn.com/b/vcblog/archive/2013/09/11/introducing-gw-compiler-switch.aspx\n            PROFILE_GEN_CFLAGS=\"$PROFILE_GEN_CFLAGS -Gw\"\n            PROFILE_USE_CFLAGS=\"$PROFILE_USE_CFLAGS -Gw\"\n        fi\n\n        if test -z \"$MOZ_OPTIMIZE\"; then\n            CFLAGS=\"$CFLAGS -Od\"\n        fi\n\n        if test \"$USE_DEBUG_RTL\" = 1; then\n            if test -n \"$USE_STATIC_RTL\"; then\n                CFLAGS=\"$CFLAGS -MTd\"\n            else\n                CFLAGS=\"$CFLAGS -MDd\"\n            fi\n        else\n            if test -n \"$USE_STATIC_RTL\"; then\n                CFLAGS=\"$CFLAGS -MT\"\n            else\n                CFLAGS=\"$CFLAGS -MD\"\n            fi\n        fi\n\n        if test -n \"$MOZ_DEBUG\"; then\n            AC_DEFINE(_DEBUG)\n        else\n            DEFINES=\"$DEFINES -U_DEBUG\"\n        fi\n\n        if test -n \"$MOZ_DEBUG_SYMBOLS\"; then\n            if test -n \"$MOZ_OPTIMIZE\"; then\n                DLLFLAGS=\"$DLLFLAGS -DEBUG -OPT:REF\"\n                LDFLAGS=\"$LDFLAGS -DEBUG -OPT:REF\"\n            else\n                DLLFLAGS=\"$DLLFLAGS -DEBUG\"\n                LDFLAGS=\"$LDFLAGS -DEBUG\"\n            fi\n        fi\n\n        OS_DLLFLAGS=\"-nologo -DLL -SUBSYSTEM:WINDOWS\"\n        if test \"$MSC_VER\" -le \"1200\" -a -z \"$MOZ_DEBUG_SYMBOLS\"; then\n            OS_DLLFLAGS=\"$OS_DLLFLAGS -PDB:NONE\"\n        fi\n        \n        if test \"$OS_TARGET\" = \"WINNT\"; then\n            CFLAGS=\"$CFLAGS -GT\"\n            LIBNSPR='$(dist_libdir)/libnspr$(MOD_MAJOR_VERSION).$(LIB_SUFFIX)'\n            LIBPLC='$(dist_libdir)/libplc$(MOD_MAJOR_VERSION).$(LIB_SUFFIX)'\n        else\n            LIBNSPR='$(dist_libdir)/nspr$(MOD_MAJOR_VERSION).$(LIB_SUFFIX)'\n            LIBPLC='$(dist_libdir)/plc$(MOD_MAJOR_VERSION).$(LIB_SUFFIX)'\n        fi\n    fi # GNU_CC\n\n    if test -n \"$USE_STATIC_TLS\"; then\n        AC_DEFINE(_PR_USE_STATIC_TLS)\n    fi\n\n    if test \"$OS_TARGET\" = \"WINNT\"; then\n        AC_DEFINE(WINNT)\n    else\n        AC_DEFINE(WIN95)\n        # undefine WINNT as some versions of mingw gcc define it by default\n        DEFINES=\"$DEFINES -UWINNT\"\n        AC_DEFINE(_PR_GLOBAL_THREADS_ONLY)\n    fi\n\n    if test \"$CPU_ARCH\" = \"x86\"; then\n        CPU_ARCH_TAG=\n    else\n        CPU_ARCH_TAG=$CPU_ARCH\n    fi\n\n    if test \"$USE_DEBUG_RTL\" = 1; then\n        OBJDIR_SUFFIX=OBJD\n    fi\n\n    case \"$OS_TARGET\" in\n    WINNT)\n\t    MDCPUCFG_H=_winnt.cfg\n\t    ;;\n    WIN95)\n\t    MDCPUCFG_H=_win95.cfg\n\t    ;;\n    *)\n\t    AC_MSG_ERROR([Missing OS_TARGET for ${target}.  Use --enable-win32-target to set.])\n   \t;;\n    esac\n\n    case \"$target_cpu\" in\n    i*86)\n\tif test -n \"$USE_64\"; then\n\t    AC_DEFINE(_AMD64_)\n\telse\t\t\n\t    AC_DEFINE(_X86_)\n            if test -z \"$GNU_CC\" -a \"$MSC_VER\" -ge \"1700\"; then\n                dnl Visual C++ 2012 defaults to -arch:SSE2. Use -arch:IA32\n                dnl to avoid requiring SSE2.\n                CFLAGS=\"$CFLAGS -arch:IA32\"\n            fi\n\tfi\n        ;;\n    x86_64)\n\t    AC_DEFINE(_AMD64_)\n\t    USE_64=1\n\t    ;;\n    ia64)\n\t    AC_DEFINE(_IA64_)\n\t    USE_64=1\n\t    ;;\n    *)\n\t    AC_DEFINE(_CPU_ARCH_NOT_DEFINED)\n\t    ;;\n    esac\n    ;;\n\n*-netbsd*)\n    AC_DEFINE(XP_UNIX)\n    AC_DEFINE(NETBSD)\n    AC_DEFINE(HAVE_BSD_FLOCK)\n    AC_DEFINE(HAVE_SOCKLEN_T)\n    if test -z \"$USE_NSPR_THREADS\"; then\n        USE_PTHREADS=1\n    fi\n    MDCPUCFG_H=_netbsd.cfg\n    PR_MD_CSRCS=netbsd.c\n\n    DSO_CFLAGS='-fPIC -DPIC'\n    CFLAGS=\"$CFLAGS -ansi -Wall\"\n    CXXFLAGS=\"$CXXFLAGS -ansi -Wall\"\n    MKSHLIB='$(CC) -o $@ $(DSO_LDOPTS)'\n\n    if test -z \"$OBJECT_FMT\"; then\n        if echo __ELF__ | ${CC-cc} -E - | grep -q __ELF__ 2>/dev/null; then\n            OBJECT_FMT=a.out\n            DLL_SUFFIX=so.1.0\n            DSO_LDOPTS='-shared'\n        else\n            OBJECT_FMT=ELF\n            DLL_SUFFIX=so\n            DSO_LDOPTS='-shared -Wl,-soname,$(notdir $@)'\n        fi\n    fi\n\n    if test \"$LIBRUNPATH\"; then\n        DSO_LDOPTS=\"$DSO_LDOPTS -Wl,-R$LIBRUNPATH\"\n    fi\n    ;;\n\n*-nto*)\n    AC_DEFINE(XP_UNIX)\n    AC_DEFINE(NTO)\n    AC_DEFINE(_QNX_SOURCE)\n    AC_DEFINE(HAVE_POINTER_LOCALTIME_R)\n    MDCPUCFG_H=_nto.cfg\n    PR_MD_CSRCS=nto.c\n    MKSHLIB='$(CC) $(DSO_LDOPTS) -Wl,-soname -Wl,$(notdir $@) -o $@'\n    DSO_CFLAGS=-fPIC\n    DSO_LDOPTS=-shared\n    OS_LIBS=\"$OS_LIBS -lsocket\"\n    _OPTIMIZE_FLAGS=\"-O1\"\n    _DEBUG_FLAGS=\"-gstabs\"\n\t;;\n\n*-openbsd*)\n    AC_DEFINE(XP_UNIX)\n    AC_DEFINE(OPENBSD)\n    AC_DEFINE(HAVE_BSD_FLOCK)\n    AC_DEFINE(HAVE_SOCKLEN_T)\n    CFLAGS=\"$CFLAGS -ansi -Wall\"\n    CXXFLAGS=\"$CXXFLAGS -ansi -Wall\"\n    DLL_SUFFIX=so.1.0\n    DSO_CFLAGS=-fPIC\n    MDCPUCFG_H=_openbsd.cfg\n    PR_MD_CSRCS=openbsd.c\n    OS_LIBS=\"-lc\"\n    if test -z \"$USE_NSPR_THREADS\"; then\n        USE_PTHREADS=1\n    fi\n    DSO_LDOPTS='-shared -fPIC -Wl,-soname,$(notdir $@)'\n    MKSHLIB='$(CC) $(DSO_LDOPTS) -o $@'\n    ;;\n\n*-osf*)\n    SHELL_OVERRIDE=\"SHELL\t\t= /usr/bin/ksh\"\n    AC_DEFINE(XP_UNIX)\n    AC_DEFINE(OSF1)\n    AC_DEFINE(_REENTRANT)\n    # OSF1 and HPUX report the POLLHUP event for a socket when the\n    # shutdown(SHUT_WR) operation is called for the remote end, even though\n    # the socket is still writeable. Use select(), instead of poll(), to\n    # workaround this problem.\n    AC_DEFINE(_PR_POLL_WITH_SELECT)\n\n    if echo \"$OS_RELEASE\" | egrep -c '(V2.0|V3.2)' 2>/dev/null ; then\n        USE_NSPR_THREADS=1\n    fi\n\n    if test -z \"$GNU_CC\"; then\n        CC=\"$CC -std1 -ieee_with_inexact\"\n        if test \"$OS_RELEASE\" != \"V2.0\"; then\n            CC=\"$CC -readonly_strings\"\n        fi\n        _OPTIMIZE_FLAGS=\"$_OPTIMIZE_FLAGS -Olimit 4000\"\n        AC_CHECK_HEADER(machine/builtins.h, AC_DEFINE(OSF1_HAVE_MACHINE_BUILTINS_H))\n    else\n        CFLAGS=\"$CFLAGS -mieee\"\n        CXXFLAGS=\"$CXXFLAGS -mieee\"\n    fi\n\n    if echo $OS_RELEASE | egrep -c '(V2.0|V3.2)' 2>/dev/null; then\n        AC_DEFINE(HAVE_INT_LOCALTIME_R)\n    else\n        AC_DEFINE(HAVE_FCNTL_FILE_LOCKING)\n        AC_DEFINE(HAVE_POINTER_LOCALTIME_R)\n    fi\n    if echo $OS_RELEASE | grep -c V4.0 >/dev/null; then\n        AC_DEFINE(OSF1V4_MAP_PRIVATE_BUG)\n    fi\n    DSO_LDOPTS='-shared -all -expect_unresolved \"*\" -soname $(notdir $@)'\n    MDCPUCFG_H=_osf1.cfg\n    PR_MD_CSRCS=osf1.c\n    ;;\n\n*-qnx*)\n    AC_DEFINE(XP_UNIX)\n    AC_DEFINE(QNX)\n    AC_DEFINE(_PR_NEED_H_ERRNO)\n    USE_NSPR_THREADS=1\n    MDCPUCFG_H=_qnx.cfg\n    PR_MD_CSRCS=qnx.c\n    ;;\n\n*-riscos*)\n    AC_DEFINE(XP_UNIX)\n    AC_DEFINE(RISCOS)\n    AC_DEFINE(_PR_NEED_H_ERRNO)\n    USE_PTHREADS=1\n    MDCPUCFG_H=_riscos.cfg\n    PR_MD_CSRCS=riscos.c\n    DSO_CFLAGS=-fPIC\n    DSO_LDOPTS='-shared -Wl,-soname -Wl,$(notdir $@)'\n    MKSHLIB='$(CC) $(DSO_LDOPTS) -o $@'\n    ;;\n\n*-*-sco*)\n    AC_DEFINE(XP_UNIX)\n    AC_DEFINE(SCO)\n    AC_DEFINE(sco)\n    AC_DEFINE(SYSV)\n    AC_DEFINE(_SVID3)\n    AC_DEFINE(_PR_NEED_H_ERRNO)\n    CC='cc -b elf -KPIC'\n    CXX='$(NSDEPTH)/build/hcpp CC +.cpp +w'\n    USE_NSPR_THREADS=1\n    CPU_ARCH=x86\n    DSO_LDOPTS='-b elf -G'\n    MDCPUCFG_H=_scoos.cfg\n    PR_MD_SRCS=scoos.c\n    ;;\n\n*-solaris*)\n    if test -z \"$USE_NSPR_THREADS\"; then\n        USE_PTHREADS=1\n    fi\n    AC_DEFINE(XP_UNIX)\n    AC_DEFINE(SVR4)\n    AC_DEFINE(SYSV)\n    AC_DEFINE(__svr4)\n    AC_DEFINE(__svr4__)\n    AC_DEFINE(SOLARIS)\n    AC_DEFINE(HAVE_FCNTL_FILE_LOCKING)\n    CPU_ARCH=`uname -p`\n    MDCPUCFG_H=_solaris.cfg\n    PR_MD_CSRCS=solaris.c\n    LD=/usr/ccs/bin/ld\n    MKSHLIB='$(CC) $(DSO_LDOPTS) -o $@'\n    RESOLVE_LINK_SYMBOLS=1\n    case \"${OS_RELEASE}\" in\n    5.8|5.9)\n        ;;\n    *)\n        # It is safe to use the -Bdirect linker flag on Solaris 10 or later.\n        USE_B_DIRECT=1\n        ;;\n    esac\n    if test -n \"$GNU_CC\"; then\n        DSO_CFLAGS=-fPIC\n        if `$CC -print-prog-name=ld` -v 2>&1 | grep -c GNU >/dev/null; then\n            GCC_USE_GNU_LD=1\n        fi\n        DSO_LDOPTS='-shared -Wl,-h,$(notdir $@),-z,combreloc,-z,defs,-z,ignore' \n        if test -n \"$USE_B_DIRECT\"; then\n            DSO_LDOPTS=\"$DSO_LDOPTS,-Bdirect\"\n        fi\n    else\n        DSO_CFLAGS=-KPIC\n        DSO_LDOPTS='-G -h $(notdir $@) -z combreloc -z defs -z ignore'\n        if test -n \"$USE_B_DIRECT\"; then\n            DSO_LDOPTS=\"$DSO_LDOPTS -Bdirect\"\n        fi\n    fi\n    if test -n \"$GNU_CC\"; then\n        CFLAGS=\"$CFLAGS -Wall\"\n        CXXFLAGS=\"$CXXFLAGS -Wall\"\n        if test -n \"$USE_MDUPDATE\"; then\n            CFLAGS=\"$CFLAGS -MDupdate \\$(DEPENDENCIES)\"\n            CXXFLAGS=\"$CXXFLAGS -MDupdate \\$(DEPENDENCIES)\"\n        fi\n        GCC_AS=`$CC -print-prog-name=as`\n        if test \"`echo | $GCC_AS -v 2>&1 | grep -c GNU`\" != \"0\"; then\n            GNU_AS=1\n        fi\n    else\n        CFLAGS=\"$CFLAGS -xstrconst\"\n        CXXFLAGS=\"$CXXFLAGS -Qoption cg -xstrconst -features=tmplife\"\n        if test -z \"$MOZ_OPTIMIZE\"; then\n            CFLAGS=\"$CFLAGS -xs\"\n            CXXFLAGS=\"$CXXFLAGS -xs\"\n        fi\n        _OPTIMIZE_FLAGS=-xO4\n    fi\n    if test -z \"$GNU_AS\"; then\n        ASFLAGS=\"$ASFLAGS -Wa,-P\"\n    fi\n    if test -n \"$USE_64\"; then\n        if test -n \"$GNU_CC\"; then\n            CC=\"$CC -m64\"\n            CXX=\"$CXX -m64\"\n        else\n            if test \"$OS_TEST\" = \"i86pc\"; then\n                CC=\"$CC -xarch=amd64\"\n                CXX=\"$CXX -xarch=amd64\"\n            else\n                CC=\"$CC -xarch=v9\"\n                CXX=\"$CXX -xarch=v9\"\n            fi\n        fi\n    fi\n    if test \"$OS_TEST\" = \"i86pc\"; then\n        if test -z \"$USE_64\"; then\n            AC_DEFINE(i386)\n        fi\n        CPU_ARCH_TAG=_$OS_TEST\n        # The default debug format, DWARF (-g), is not supported by gcc\n        # on i386-ANY-sysv4/solaris, but the stabs format is.  It is\n        # assumed that the Solaris assembler /usr/ccs/bin/as is used.\n        # If your gcc uses GNU as, you do not need the -Wa,-s option.\n        if test -n \"$MOZ_DEBUG\" && test -n \"$GNU_CC\"; then\n            _DEBUG_FLAGS=-gstabs\n            if test -z \"$GNU_AS\"; then\n                _DEBUG_FLAGS=\"$_DEBUG_FLAGS -Wa,-s\"\n            fi\n        fi\n    fi\n    case \"${target_os}\" in\n    solaris2.3*)\n        AC_DEFINE(_PR_NO_LARGE_FILES)\n        ;;\n    solaris2.4*)\n        AC_DEFINE(_PR_NO_LARGE_FILES)\n        ;;\n    solaris2.5*)\n        AC_DEFINE(SOLARIS2_5)    \n        ;;\n    *)\n        AC_DEFINE(_PR_HAVE_OFF64_T)\n        # The lfcompile64(5) man page on Solaris 2.6 says:\n        #     For applications that do not wish to conform to the POSIX or\n        #     X/Open  specifications,  the  64-bit transitional interfaces\n        #     are available by default.  No compile-time flags need to  be\n        #     set.\n        # But gcc 2.7.2.x fails to define _LARGEFILE64_SOURCE by default.\n        # The native compiler, gcc 2.8.x, and egcs don't have this problem.\n        if test -n \"$GNU_CC\"; then\n            AC_DEFINE(_LARGEFILE64_SOURCE)\n        fi\n        ;;\n    esac\n    case \"${target_os}\" in\n    solaris2.3*)\n        ;;\n    solaris2.4*)\n        ;;\n    solaris2.5*)\n        ;;\n    solaris2.6*)\n        ;;\n    solaris2.7*)\n        ;;\n    *)\n        # Solaris 8 or higher has IPv6.\n        AC_DEFINE(_PR_INET6)\n        ;;\n    esac\n    if test \"$CPU_ARCH\" = \"sparc\"; then\n        # 64-bit Solaris SPARC requires V9 architecture, so the following\n        # is not needed.\n        if test -z \"$USE_64\"; then\n            ULTRASPARC_LIBRARY=nspr_flt\n        fi\n    fi\n    # Purify requires that binaries linked against nspr also\n    # be linked against -lrt (or -lposix4) so add it to OS_LIBS\n    _rev=`uname -r`\n    _librt=`echo $_rev 5.6 | awk '{ if ($1 > $2) print \"-lrt\"; else print \"-lposix4\" }'`\n    OS_LIBS=\"$OS_LIBS $_librt\"\n    ;;\n\n*-sco-sysv5*)\n    AC_DEFINE(XP_UNIX)\n    AC_DEFINE(UNIXWARE)\n    AC_DEFINE(SVR4)\n    AC_DEFINE(SYSV)\n    USE_NSPR_THREADS=1\n    if echo $OS_RELEASE | grep -c 2.1 2>/dev/null; then\n        AC_DEFINE(_PR_NO_LARGE_FILES)\n        CC='$(NSDEPTH)/build/hcc cc'\n        CXX='$(NSDEPTH)/build/hcpp CC'\n        MDCPUCFG_H=_unixware.cfg\n    else\n        AC_DEFINE(_LARGEFILE64_SOURCE)\n        AC_DEFINE(_PR_HAVE_OFF64_T)\n        AC_DEFINE(_PR_HAVE_SOCKADDR_LEN)\n        MDCPUCFG_H=_unixware7.cfg\n    fi\n    PR_MD_CSRCS=unixware.c\n    DSO_LDOPTS=-G\n    CPU_ARCH=x86\n    ;;\n\n*-symbian*)\n    AC_ARG_WITH(symbian-sdk,\n    [  --with-symbian-sdk=SYMBIAN_SDK_DIR\n                          The path to the Symbian SDK],\n    SYMBIAN_SDK_DIR=$withval)\n\n    echo -----------------------------------------------------------------------------\n    echo Building with Symbian SDK in: $SYMBIAN_SDK_DIR\n    echo -----------------------------------------------------------------------------\n\n    AC_DEFINE(XP_UNIX)\n    AC_DEFINE(SYMBIAN)\n    AC_DEFINE(__arm__)\n    AC_DEFINE(__SYMBIAN32__)\n    AC_DEFINE(_UNICODE)\n    AC_DEFINE(NDEBUG)\n    AC_DEFINE(__SUPPORT_CPP_EXCEPTIONS__)\n    AC_DEFINE(MOZ_STDERR_TO_STDOUT)\n    AC_DEFINE(HAVE_FCNTL_FILE_LOCKING)\n    AC_DEFINE(HAVE_SOCKLEN_T)\n    USE_PTHREADS=1\n    LIB_SUFFIX=lib\n    DLL_SUFFIX=dll\n    MKSHLIB=\n    DSO_LDOPTS=\n    DSO_CFLAGS=\n    VISIBILITY_FLAGS=\n    MDCPUCFG_H=_symbian.cfg\n    PR_MD_CSRCS=symbian.c\n    NSINSTALL=nsinstall\n    RANLIB='echo no ranlib '\n    CPU_ARCH=ARM\n    OS_ARCH=SYMBIAN\n    OS_EXE_CFLAGS=\"$OS_EXE_CFLAGS -D__EXE__\"\n    CFLAGS=\"$CFLAGS -MD -nostdinc\"\n    SYMBIAN_SYS_INCLUDE=\"-I$SYMBIAN_SDK_DIR/Epoc32/include/variant -I$SYMBIAN_SDK_DIR/Epoc32/include -I$SYMBIAN_SDK_DIR/Epoc32/include/stdapis\"\n    echo -------------------------------------------------------\n    echo SYMBIAN_SYS_INCLUDE is: $SYMBIAN_SYS_INCLUDE\n    echo -------------------------------------------------------\n    case \"$OS_TARGET\" in\n    WINSCW)\n        CC=mwccsym2.exe\n        CXX=mwccsym2.exe\n        LD=mwldsym2.exe\n        AR=mwldsym2.exe\n        WINSCW_LD_DIR=\"\\$(SYMBIAN_SDK_DIR)/EPOC32/RELEASE/WINSCW/UDEB\"\n        CFLAGS=\"$CFLAGS -O0 -inline off -wchar_t off -align 4 -warnings on -w nohidevirtual,nounusedexpr -msgstyle gcc -enum int -str pool -exc ms -trigraphs on -nostderr -gccdep -cwd source -i- -I\\$(VPATH)\"\n        SYMBIAN_SYS_INCLUDE=\"$SYMBIAN_SYS_INCLUDE -include Symbian_OS_v9.2.hrh\"\n        AR_FLAGS=\"-library -msgstyle gcc -stdlib -subsystem windows -noimplib -o \\$@\"\n        AC_DEFINE(_DEBUG)\n        AC_DEFINE(__CW32__)\n        AC_DEFINE(__WINS__)\n        AC_DEFINE(__WINSCW__)\n        DEFINES=\"$DEFINES -U_WIN32\"\n\t    ;;\n    GCCE)\n        CFLAGS=\"$CFLAGS -Wall -Wno-unknown-pragmas -fexceptions -march=armv5t -mapcs -pipe -x c -msoft-float\"\n        CXXFLAGS=\"$CXXFLAGS $CFLAGS -Wno-ctor-dtor-privacy\"\n        SYMBIAN_SYS_INCLUDE=\"$SYMBIAN_SYS_INCLUDE -include $SYMBIAN_SDK_DIR/EPOC32/INCLUDE/GCCE/GCCE.h\"\n        AC_DEFINE(__GCCE__)\n        AC_DEFINE(__EABI__)\n        DEFINES=\"$DEFINES -D__PRODUCT_INCLUDE__=$SYMBIAN_SDK_DIR/Epoc32/include/variant/Symbian_OS_v9.2.hrh\"\n\t    ;;\n    *)\n\t    AC_MSG_ERROR([Missing OS_TARGET for ${target}. Set --enable-symbian-target to with 'WINSCW' or 'GCCE'.])\n   \t;;\n    esac\n    CFLAGS=\"$CFLAGS ${SYMBIAN_SYS_INCLUDE}\"\n    ;;\n\n*-os2*)\n    AC_DEFINE(XP_OS2)\n    AC_DEFINE(XP_PC)\n    AC_DEFINE(BSD_SELECT)\n    AC_DEFINE(TCPV40HDRS)\n    LIB_SUFFIX=lib\n    DLL_SUFFIX=dll\n    RC=rc.exe\n    PR_MD_ARCH_DIR=os2\n    PROG_SUFFIX=.exe\n    NSINSTALL=nsinstall\n    MDCPUCFG_H=_os2.cfg\n    RESOLVE_LINK_SYMBOLS=1\n\n    AC_DEFINE(OS2)\n    AR=emxomfar\n    AR_FLAGS='r $@'\n    CFLAGS=\"$CFLAGS -Wall -Zomf\"\n    CXXFLAGS=\"$CFLAGS -Wall -Zomf\"\n    MKSHLIB='$(CC) $(DSO_LDOPTS) -o $@'\n    DSO_CFLAGS=\n    DSO_LDOPTS='-Zomf -Zdll'\n    LDFLAGS='-Zmap'\n    _OPTIMIZE_FLAGS=\"-O2 -s\"\n    _DEBUG_FLAGS=\"-g -fno-inline\"\n    if test -n \"$MOZ_OPTIMIZE\"; then\n      DSO_LDOPTS=\"$DSO_LDOPTS -Zlinker /EXEPACK:2 -Zlinker /PACKCODE -Zlinker /PACKDATA\"\n    fi\n    IMPLIB='emximp -o'\n    FILTER='emxexp -o'\n    if test -n \"$MOZ_OS2_HIGH_MEMORY\"; then\n      LDFLAGS=\"$LDFLAGS -Zhigh-mem\"\n      AC_DEFINE(MOZ_OS2_HIGH_MEMORY)\n    fi\n\n    # GCC for OS/2 currently predefines these, but we don't want them\n    DEFINES=\"$DEFINES -Uunix -U__unix -U__unix__\"\n    ;;\n\n*)\n    AC_DEFINE(XP_UNIX)\n    ;;\n   \nesac\n\nif test -z \"$SKIP_LIBRARY_CHECKS\"; then\ndnl ========================================================\ndnl Check for system libraries\ndnl ========================================================\n\n\ndnl We don't want anything to link with libdl even if it's present on OS X, \ndnl since it's not used and not part of the default installation.\ndnl The same goes for BeOS.\ndnl OS/2 has dlfcn in libc.\n\ncase $target in\n*-darwin*|*-beos*|*-os2*)\n    ;;\n*)\n    AC_CHECK_LIB(dl, dlopen,\n        [AC_CHECK_HEADER(dlfcn.h,\n            OS_LIBS=\"-ldl $OS_LIBS\")])\n    ;;\nesac\n\n\ndnl ========================================================\ndnl Check for system header files.\ndnl ========================================================\n\ndnl ========================================================\ndnl Check for typedefs and structs\ndnl ========================================================\n\ndnl ========================================================\ndnl Checks for library functions.\ndnl ========================================================\nAC_PROG_GCC_TRADITIONAL\n_SAVE_LIBS=\"$LIBS\"\nLIBS=\"$LIBS $OS_LIBS\"\nAC_CHECK_FUNCS(dladdr gettid lchown setpriority strerror syscall dnl\n secure_getenv __secure_getenv)\nLIBS=\"$_SAVE_LIBS\"\n\ndnl ========================================================\ndnl Check options\ndnl ========================================================\n\ndnl ======================================================\ndnl = Enable compiling with ccache\ndnl ======================================================\nAC_ARG_WITH(ccache,\n[  --with-ccache[=path/to/ccache]\n                          Enable compiling with ccache],\n    CCACHE=$withval, CCACHE=\"no\")\n\nif test \"$CCACHE\" != \"no\"; then\n    if test -n \"$CCACHE\"; then\n        if test \"$CCACHE\" = \"yes\"; then\n            CCACHE=\n        else\n            if test ! -e \"$CCACHE\"; then\n                AC_MSG_ERROR([$CCACHE not found])\n            fi\n        fi\n    fi\n    AC_PATH_PROGS(CCACHE, $CCACHE ccache)\n    if test -z \"$CCACHE\" -o \"$CCACHE\" = \":\"; then\n        AC_MSG_ERROR([ccache not found])\n    elif test -x \"$CCACHE\"; then\n        CC=\"$CCACHE $CC\"\n        CXX=\"$CCACHE $CXX\"\n    else\n        AC_MSG_ERROR([$CCACHE is not executable])\n    fi\nfi\n\ndnl ========================================================\ndnl =\ndnl = --enable-strip\ndnl = \ndnl = Enable stripping of libs and executables\ndnl = \ndnl ========================================================\nAC_ARG_ENABLE(strip,\n    [  --enable-strip          Enable stripping of shared libs and programs],\n    [ if test \"$enableval\" = \"yes\"; then\n\t    ENABLE_STRIP=1\n      fi ])\n\ndnl Check for hpux options\ncase \"${target_os}\" in\nhpux*)\nif test -z \"$GNU_CC\"; then\n\n    AC_CACHE_CHECK(for +Olit support,\n        ac_cv_hpux_usable_olit_option,\n        dnl since aCC doesn't throw an error on invalid options,\n        dnl we have to test this the hard way\n        [ac_cv_hpux_usable_olit_option=no\n        rm -f conftest*\n        echo 'int main() { return 0; }' | cat > conftest.c\n        ${CC-cc} ${CFLAGS} +Olit=all -o conftest conftest.c > conftest.out 2>&1\n        if test $? -eq 0; then\n            if test -z \"`egrep -i '(unrecognize|unknown)' conftest.out`\"; then\n                ac_cv_hpux_usable_olit_option=yes\n            fi\n        fi\n        rm -f conftest*\n        ])\n\n    if test \"$ac_cv_hpux_usable_olit_option\" = \"yes\"; then\n        CFLAGS=\"$CFLAGS +Olit=all\"\n        CXXFLAGS=\"$CXXFLAGS +Olit=all\"\n    else\n        CFLAGS=\"$CFLAGS +ESlit\"\n        CXXFLAGS=\"$CXXFLAGS +ESlit\"\n    fi\nfi\n;;\nesac\n\ncase \"$target_os\" in\ndarwin*)\n    _HAVE_PTHREADS=1\n    ;;\n*)\n    AC_CHECK_LIB(pthreads, pthread_create,\n        _HAVE_PTHREADS=1 _PTHREAD_LDFLAGS=\"-lpthreads\",\n        AC_CHECK_LIB(pthread, pthread_create,\n            _HAVE_PTHREADS=1 _PTHREAD_LDFLAGS=\"-lpthread\",\n            AC_CHECK_LIB(c_r, pthread_create,\n                _HAVE_PTHREADS=1 _PTHREAD_LDFLAGS=\"-lc_r\",\n                AC_CHECK_LIB(c, pthread_create,\n                    _HAVE_PTHREADS=1\n                )\n            )\n        )\n    )\n    ;;\nesac\n\nAC_ARG_WITH(pthreads,\n    [  --with-pthreads         Use system pthreads library as thread subsystem],\n    [ if test \"$withval\" = \"yes\"; then\n\t    if test -n \"$_HAVE_PTHREADS\"; then\n\t\t    USE_PTHREADS=1 \n\t\t    USE_USER_PTHREADS=\n\t\t    USE_NSPR_THREADS=\n\t    else\n\t\t    AC_MSG_ERROR([ --with-pthreads specified for a system without pthread support ]);\n\t    fi\n\t  else\n\t    USE_PTHREADS=\n\t    _PTHREAD_LDFLAGS=\n\t  fi],\n\t[ if test -n \"$_HAVE_PTHREADS\" && test -z \"$USE_USER_PTHREADS\" && test -z \"$USE_NSPR_THREADS\"; then\n\t    USE_PTHREADS=1\n\t    USE_USER_PTHREADS=\n\t    USE_NSPR_THREADS=\n\t  fi])\n\nAC_ARG_ENABLE(user-pthreads,\n    [  --enable-user-pthreads  Build using userland pthreads],\n    [ if test \"$enableval\" = \"yes\"; then\n        if test -n \"$_HAVE_PTHREADS\"; then\n\t\t    USE_PTHREADS=\n\t\t    USE_USER_PTHREADS=1\n\t\t    USE_NSPR_THREADS=\n\t    else\n\t\t    AC_MSG_ERROR([ --enable-user-pthreads specified for a system without pthread support ]);\n\t    fi\n\t  fi])\n\nAC_ARG_ENABLE(nspr-threads,\n    [  --enable-nspr-threads   Build using classic nspr threads],\n    [ if test \"$enableval\" = \"yes\"; then\n\t    USE_PTHREADS=\n\t    USE_USER_PTHREADS=\n\t    USE_NSPR_THREADS=1\n\t  fi])\n\ncase \"$target\" in\n*-beos*)\n    AC_ARG_WITH(bthreads,\n    [  --with-bthreads         Use system bthreads library as thread subsystem\n                          (BeOS only)],\n    [\tif test \"$withval\" = \"yes\"; then\n    \t    USE_BTHREADS=1\n\t        USE_USER_PTHREADS=\n\t        USE_PTHREADS=\n\t    fi])\n    ;;\nesac\n\nfi # SKIP_LIBRARY_CHECKS\n\nAC_ARG_ENABLE(ipv6,\n    [  --enable-ipv6           Compile ipv6 support],\n    [ if test \"$enableval\" = \"yes\"; then\n\t    USE_IPV6=1\n      else\n\t    USE_IPV6=\n      fi])\n\nif test -n \"$USE_PTHREADS\"; then\n   dnl See if -pthread is supported.\n   rm -f conftest*\n   ac_cv_have_dash_pthread=no\n   AC_MSG_CHECKING(whether ${CC-cc} accepts -pthread)\n   echo 'int main() { return 0; }' | cat > conftest.c\n   ${CC-cc} -pthread -o conftest conftest.c > conftest.out 2>&1\n   if test $? -eq 0; then\n\tif test -z \"`egrep -i '(unrecognize|unknown)' conftest.out | grep pthread`\" && test -z \"`egrep -i '(error|incorrect)' conftest.out`\" ; then\n\t    ac_cv_have_dash_pthread=yes\n\t\tcase \"$target_os\" in\n\t    freebsd*)\n# Freebsd doesn't use -pthread for compiles, it uses them for linking\n            ;;\n\t    *)\n            CFLAGS=\"$CFLAGS -pthread\"\n            CXXFLAGS=\"$CXXFLAGS -pthread\"\n            ;;\n        esac\n\tfi\n    fi\n    rm -f conftest*\n    AC_MSG_RESULT($ac_cv_have_dash_pthread)\n\n\tdnl\n\tdnl See if -pthreads is supported.\n\tdnl\n    ac_cv_have_dash_pthreads=no\n    if test \"$ac_cv_have_dash_pthread\" = \"no\"; then\n\t    AC_MSG_CHECKING(whether ${CC-cc} accepts -pthreads)\n    \techo 'int main() { return 0; }' | cat > conftest.c\n\t    ${CC-cc} -pthreads -o conftest conftest.c > conftest.out 2>&1\n    \tif test $? -eq 0; then\n\t    \tif test -z \"`egrep -i '(unrecognize|unknown)' conftest.out | grep pthreads`\" && test -z \"`egrep -i '(error|incorrect)' conftest.out`\" ; then\n\t\t\t    ac_cv_have_dash_pthreads=yes\n\t\t\t    CFLAGS=\"$CFLAGS -pthreads\"\n\t\t\t    CXXFLAGS=\"$CXXFLAGS -pthreads\"\n\t\t    fi\n\t    fi\n\t    rm -f conftest*\n    \tAC_MSG_RESULT($ac_cv_have_dash_pthreads)\n    fi\n\n    case \"$target\" in\n    *-solaris*)\n        if test \"$ac_cv_have_dash_pthreads\" = \"yes\"; then\n            _PTHREAD_LDFLAGS=\n        fi\n\t    ;;\n    *-freebsd*)\n\t    AC_DEFINE(_REENTRANT)\n\t    AC_DEFINE(_THREAD_SAFE)\n\t    dnl -pthread links in -lc_r, so don't specify it explicitly.\n\t    if test \"$ac_cv_have_dash_pthread\" = \"yes\"; then\n\t        _PTHREAD_LDFLAGS=\"-pthread\"\n\t    else\n\t        _PTHREAD_LDFLAGS=\"-lc_r\"\n\t    fi\n\t    ;;\n    *-netbsd*)\n\t    if test \"$ac_cv_have_dash_pthread\" = \"yes\"; then\n\t        _PTHREAD_LDFLAGS=\"-pthread\"\n\t    fi\n\t    ;;\n    *-bsdi*)\n\t    AC_DEFINE(_THREAD_SAFE)\n\t    dnl -pthread links in -lc_r, so don't specify it explicitly.\n\t    if test \"$ac_cv_have_dash_pthread\" = \"yes\"; then\n\t        _PTHREAD_LDFLAGS=\n\t    fi\n\t    ;;\n    *-openbsd*)\n        if test \"$ac_cv_have_dash_pthread\" = \"yes\"; then\n            _PTHREAD_LDFLAGS=-pthread\n        fi\n        ;;\n    *-linux*|*-gnu*|*-k*bsd*-gnu)\n        AC_DEFINE(_REENTRANT)\n        ;;\n    esac\n\nelse \n    if test -n \"$USE_USER_PTHREADS\"; then\n\t    USE_PTHREADS=\n\t    USE_NSPR_THREADS=\n    else\n        _PTHREAD_LDFLAGS=\n    fi\nfi\ndnl Special thread exceptions\n\ncase \"$target\" in\n*-aix*)\n    if test -n \"$USE_NSPR_THREADS\"; then\n        AC_DEFINE(_PR_LOCAL_THREADS_ONLY)\n    fi\n    case \"$target_os\" in\n    aix4.1*)\n        if test -z \"$USE_PTHREADS\"; then\n            AC_DEFINE(AIX_RENAME_SELECT)\n        fi\n        ;;\n    aix4.2*)\n        if test -z \"$USE_NSPR_THREADS\"; then\n            AC_DEFINE(HAVE_POINTER_LOCALTIME_R)\n        fi\n        ;;\n    aix4.3*)\n        if test -z \"$USE_NSPR_THREADS\"; then\n            AC_DEFINE(HAVE_POINTER_LOCALTIME_R)\n        fi\n        if test -n \"$USE_PTHREADS\"; then\n            AC_DEFINE(_PR_HAVE_THREADSAFE_GETHOST)\n        fi\n        ;;\n    *)\n        if test -z \"$USE_NSPR_THREADS\"; then\n            AC_DEFINE(HAVE_POINTER_LOCALTIME_R)\n        fi\n        if test -n \"$USE_PTHREADS\"; then\n            AC_DEFINE(_PR_HAVE_THREADSAFE_GETHOST)\n        fi\n        ;;\n    esac\n    ;;\n*-bsdi*)\n    if test -n \"$USE_PTHREADS\"; then\n        AC_DEFINE(_PR_NEED_PTHREAD_INIT)\n    fi\n    ;;\n*-freebsd*)\n    if test -n \"$USE_NSPR_THREADS\"; then\n        AC_DEFINE(_PR_LOCAL_THREADS_ONLY)\n    fi\n    ;;\n*-hpux*)\n    if test -n \"$USE_NSPR_THREADS\"; then\n        AC_DEFINE(_PR_LOCAL_THREADS_ONLY)\n    fi \n    if test \"$USE_PTHREADS\"; then\n        if echo \"$OS_RELEASE\" | egrep '^(B.10.10|B.10.20)' >/dev/null; then\n            AC_DEFINE(_REENTRANT)\n            AC_DEFINE(_PR_DCETHREADS)\n        else\n            AC_DEFINE_UNQUOTED(_POSIX_C_SOURCE,199506L)\n            AC_DEFINE(_PR_HAVE_THREADSAFE_GETHOST)\n        fi\n    fi\n    if test \"$USE_USER_PTHREADS\"; then\n        AC_DEFINE_UNQUOTED(_POSIX_C_SOURCE,199506L)\n    fi\n    ;;\n*-irix*)\n    if test \"${target_os}\" = \"irix6.5\"; then\n        if test -n \"$USE_PTHREADS\"; then\n            AC_DEFINE(_PR_HAVE_GETHOST_R)\n            AC_DEFINE(_PR_HAVE_GETHOST_R_POINTER)\n        fi\n    fi\n    ;;\n*-linux*|*-gnu*|*-k*bsd*-gnu)\n    if test -n \"$USE_NSPR_THREADS\"; then\n        AC_DEFINE(_PR_LOCAL_THREADS_ONLY)\n    fi\n    ;;\n*-mingw*|*-msys*|*-cygwin*|*-mks*|*-os2*|*-beos*)\n    dnl win32, os2 & beos cannot use pthreads\n    USE_PTHREADS=\n    _PTHREAD_LDFLAGS=\n    USE_USER_PTHREADS=\n    ;;\n*-netbsd*|*-openbsd*)\n    if test -n \"$USE_NSPR_THREADS\"; then\n        AC_DEFINE(_PR_LOCAL_THREADS_ONLY)\n    fi\n    ;;\n*-osf*)\n    if test -n \"$USE_NSPR_THREADS\"; then\n        AC_DEFINE(_PR_LOCAL_THREADS_ONLY)\n    fi\n    if test -n \"$USE_PTHREADS\"; then\n        if echo $OS_RELEASE | egrep -c '(V2.0|V3.2)' 2>/dev/null; then\n            :\n        else\n            AC_DEFINE(_PR_HAVE_THREADSAFE_GETHOST)\n        fi\n    fi\n    ;;\n*-solaris*)\n    if test -n \"$USE_NSPR_THREADS\"; then\n        AC_DEFINE(_PR_LOCAL_THREADS_ONLY)\n    fi\n    if test -n \"$USE_PTHREADS\"; then\n        AC_DEFINE(_REENTRANT)\n        AC_DEFINE(HAVE_POINTER_LOCALTIME_R)\n        if test \"$OS_TEST\" = \"i86pc\"; then\n            if test -n \"$USE_64\"; then\n               PR_MD_ASFILES=os_SunOS_x86_64.s\n            else\n               PR_MD_ASFILES=os_SunOS_x86.s\n            fi\n        else\n            if test -n \"$USE_64\"; then\n                PR_MD_ASFILES=os_SunOS_sparcv9.s\n            fi\n        fi\n    fi\n    ;;\n*-nto*)\n    if test -n \"$USE_PTHREADS\"; then\n        AC_DEFINE(_PR_HAVE_GETHOST_R)\n        AC_DEFINE(_PR_HAVE_GETHOST_R_POINTER)\n    fi\n    ;;\nesac\n\nOS_LIBS=\"$_PTHREAD_LDFLAGS $OS_LIBS\"\n\ndnl If the user passed in arg to --enable-optimize or --enable-debug,\ndnl make sure that we use it.\nif test -n \"$_SAVE_OPTIMIZE_FLAGS\"; then\n    _OPTIMIZE_FLAGS=\"$_SAVE_OPTIMIZE_FLAGS\"\nfi\n\nif test -n \"$_SAVE_DEBUG_FLAGS\"; then\n    _DEBUG_FLAGS=\"$_SAVE_DEBUG_FLAGS\"\nfi\n\nif test -n \"$MOZ_OPTIMIZE\"; then\n    CFLAGS=\"$CFLAGS $_OPTIMIZE_FLAGS\"\n    CXXFLAGS=\"$CXXFLAGS $_OPTIMIZE_FLAGS\"\nfi\n\nif test -n \"$MOZ_DEBUG_SYMBOLS\"; then\n    CFLAGS=\"$CFLAGS $_DEBUG_FLAGS\"\n    CXXFLAGS=\"$CXXFLAGS $_DEBUG_FLAGS\"\nfi\n\nif test -n \"$MOZ_OPTIMIZE\"; then\n    OBJDIR_TAG=_OPT\nelse\n    OBJDIR_TAG=_DBG\nfi\n\nif test -n \"$USE_64\"; then\n    COMPILER_TAG=_64\nfi\n\nRELEASE_OBJDIR_NAME=\"${OS_CONFIG}${CPU_ARCH_TAG}${COMPILER_TAG}${IMPL_STRATEGY}${OBJDIR_TAG}.${OBJDIR_SUFFIX}\"\n\ndnl ========================================================\ndnl Use cygwin wrapper for win32 builds, except MSYS/MinGW\ndnl ========================================================\ncase \"$target_os\" in\ncygwin*|mks*)\n    CC=\"\\$(CYGWIN_WRAPPER) $CC\"\n    CXX=\"\\$(CYGWIN_WRAPPER) $CXX\"\n    RC=\"\\$(CYGWIN_WRAPPER) $RC\"\n    ;;\nesac\n\ndnl ========================================================\ndnl = Use malloc wrapper lib\ndnl ========================================================\nAC_ARG_ENABLE(wrap-malloc,\n[  --enable-wrap-malloc    Wrap malloc calls (gnu linker only)],\n[     if test \"$enableval\" = \"yes\"; then\n\t    _WRAP_MALLOC=1\n      fi ])\n\nif test -n \"$_WRAP_MALLOC\"; then\n    if test -n \"$GNU_CC\"; then\n        WRAP_LDFLAGS=\"${WRAP_LDFLAGS} -Wl,--wrap=malloc,--wrap=calloc,--wrap=valloc,--wrap=free,--wrap=realloc,--wrap=memalign\"\n        WRAP_LDFLAGS=\"${WRAP_LDFLAGS} -Wl,--wrap=__builtin_new,--wrap=__builtin_vec_new,--wrap=__builtin_delete,--wrap=__builtin_vec_delete\"\n        WRAP_LDFLAGS=\"${WRAP_LDFLAGS} -Wl,--wrap=strdup,--wrap=strndup\"\n        WRAP_LDFLAGS=\"${WRAP_LDFLAGS} -Wl,--wrap=posix_memalign,--wrap=malloc_usable_size\"\n    else\n        AC_MSG_ERROR([--enable-wrap-malloc is not supported for non-GNU toolchains])\n    fi\nfi\n\ndnl ========================================================\ndnl = Location of malloc wrapper lib\ndnl ========================================================\nAC_ARG_WITH(wrap-malloc,\n[  --with-wrap-malloc=SHAREDLIB  Location of malloc wrapper library],\n    WRAP_LDFLAGS=\"${WRAP_LDFLAGS} $withval\")\n\ndnl ========================================================\ndnl Substitution of found variables.\ndnl ========================================================\nAC_SUBST(SHELL_OVERRIDE)\n\nAC_SUBST(MOZILLA_CLIENT)\nAC_SUBST(CC)\nAC_SUBST(CXX)\nAC_SUBST(CFLAGS)\nAC_SUBST(CXXFLAGS)\nAC_SUBST(CPPFLAGS)\nAC_SUBST(HOST_CC)\nAC_SUBST(HOST_CFLAGS)\nAC_SUBST(LDFLAGS)\nAC_SUBST(HOST_LDFLAGS)\nAC_SUBST(GNU_CC)\nAC_SUBST(GCC_USE_GNU_LD)\nAC_SUBST(MSC_VER)\nAC_SUBST(CROSS_COMPILE)\n\nAC_SUBST(MOZ_OPTIMIZE)\nAC_SUBST(MOZ_DEBUG)\nAC_SUBST(MOZ_DEBUG_SYMBOLS)\n\nAC_SUBST(USE_CPLUS)\nAC_SUBST(USE_IPV6)\nAC_SUBST(USE_N32)\nAC_SUBST(USE_X32)\nAC_SUBST(USE_64)\nAC_SUBST(OBJECT_MODE)\nAC_SUBST(ENABLE_STRIP)\n\nAC_SUBST(USE_PTHREADS)\nAC_SUBST(USE_BTHREADS)\nAC_SUBST(USE_USER_PTHREADS)\nAC_SUBST(USE_NSPR_THREADS)\n\nAC_SUBST(LIBNSPR)\nAC_SUBST(LIBPLC)\n\nAC_SUBST(MOD_MAJOR_VERSION)\nAC_SUBST(MOD_MINOR_VERSION)\nAC_SUBST(MOD_PATCH_VERSION)\nAC_SUBST(NSPR_MODNAME)\nAC_SUBST(MDCPUCFG_H)\nAC_SUBST(PR_MD_CSRCS)\nAC_SUBST(PR_MD_ASFILES)\nAC_SUBST(PR_MD_ARCH_DIR)\nAC_SUBST(CPU_ARCH)\n\nAC_SUBST(OBJ_SUFFIX)\nAC_SUBST(LIB_SUFFIX)\nAC_SUBST(DLL_SUFFIX)\nAC_SUBST(ASM_SUFFIX)\nAC_SUBST(WRAP_LDFLAGS)\nAC_SUBST(MKSHLIB)\nAC_SUBST(DSO_CFLAGS)\nAC_SUBST(DSO_LDOPTS)\n\nAC_SUBST(OS_TARGET)\nAC_SUBST(OS_ARCH)\nAC_SUBST(OS_RELEASE)\nAC_SUBST(OS_TEST)\nAC_SUBST(MACOSX_DEPLOYMENT_TARGET)\n\nAC_SUBST(DEFINES)\nAC_SUBST(DEFS)\nAC_SUBST(AR)\nAC_SUBST(AR_FLAGS)\nAC_SUBST(AS)\nAC_SUBST(ASFLAGS)\nAC_SUBST(LD)\nAC_SUBST(RANLIB)\nAC_SUBST(PERL)\nAC_SUBST(STRIP)\nAC_SUBST(FILTER)\nAC_SUBST(IMPLIB)\n\nAC_SUBST(PROFILE_GEN_CFLAGS)\nAC_SUBST(PROFILE_GEN_LDFLAGS)\nAC_SUBST(PROFILE_USE_CFLAGS)\nAC_SUBST(PROFILE_USE_LDFLAGS)\n\nAC_SUBST(OS_LIBS)\nAC_SUBST(RESOLVE_LINK_SYMBOLS)\nAC_SUBST(AIX_LINK_OPTS)\nAC_SUBST(NOSUCHFILE)\nAC_SUBST(MOZ_OBJFORMAT)\nAC_SUBST(ULTRASPARC_LIBRARY)\n\nAC_SUBST(OBJDIR)\nAC_SUBST(OBJDIR_NAME)\nAC_SUBST(RELEASE_OBJDIR_NAME)\nAC_SUBST(NSINSTALL)\nAC_SUBST(OPTIMIZER)\nAC_SUBST(RC)\nAC_SUBST(RCFLAGS)\nAC_SUBST(DLLFLAGS)\nAC_SUBST(EXEFLAGS)\nAC_SUBST(OS_DLLFLAGS)\nAC_SUBST(CYGWIN_WRAPPER)\nAC_SUBST(VISIBILITY_FLAGS)\nAC_SUBST(WRAP_SYSTEM_INCLUDES)\nAC_SUBST(MACOS_SDK_DIR)\nAC_SUBST(SYMBIAN_SDK_DIR)\nAC_SUBST(NEXT_ROOT)\nAC_SUBST(MT)\n\ndnl ========================================================\ndnl Generate output files.\ndnl ========================================================\nMAKEFILES=\"\n    Makefile\n    config/Makefile\n    config/autoconf.mk\n    config/nsprincl.mk\n    config/nsprincl.sh\n    config/nspr-config\n    config/nspr.pc\n    lib/Makefile\n    lib/ds/Makefile\n    lib/libc/Makefile\n    lib/libc/include/Makefile\n    lib/libc/src/Makefile\n    lib/tests/Makefile\n    pkg/Makefile\n    pr/Makefile\n    pr/include/Makefile\n    pr/include/md/Makefile\n    pr/include/obsolete/Makefile\n    pr/include/private/Makefile\n    pr/src/Makefile\n    pr/src/io/Makefile\n    pr/src/linking/Makefile\n    pr/src/malloc/Makefile\n    pr/src/md/Makefile\n    pr/src/md/${PR_MD_ARCH_DIR}/Makefile\n    pr/src/memory/Makefile\n    pr/src/misc/Makefile\n    pr/src/threads/Makefile\n    pr/tests/Makefile\n    pr/tests/dll/Makefile\n\"\n\nif test \"$OS_TARGET\" = \"Linux\"; then\n    MAKEFILES=\"$MAKEFILES\n        pkg/linux/Makefile\n    \"\nelif test \"$OS_TARGET\" = \"SunOS\"; then\n    MAKEFILES=\"$MAKEFILES\n        pkg/solaris/Makefile\n        pkg/solaris/SUNWpr/Makefile\n        pkg/solaris/SUNWprd/Makefile\n    \"\nfi\n\nif test -z \"$USE_PTHREADS\" && test -z \"$USE_BTHREADS\"; then\n    MAKEFILES=\"$MAKEFILES\n        pr/src/threads/combined/Makefile\n    \"\nelif test -n \"$USE_PTHREADS\"; then\n    MAKEFILES=\"$MAKEFILES\n        pr/src/pthreads/Makefile\n    \"\nelif test -n \"$USE_BTHREADS\"; then\n    MAKEFILES=\"$MAKEFILES\n        pr/src/bthreads/Makefile\n    \"\nfi\n\nif test -n \"$USE_CPLUS\"; then\n    MAKEFILES=\"$MAKEFILES\n        pr/src/cplus/Makefile\n        pr/src/cplus/tests/Makefile\n    \"\nfi\n\necho $MAKEFILES > unallmakefiles\n\nAC_CONFIG_FILES([$MAKEFILES])\nAC_CONFIG_COMMANDS([default], [chmod +x config/nspr-config])\nAC_OUTPUT\n",
        "/tmp/vanessa/spack-stage/spack-stage-nspr-4.13.1-vntc7ai7kqzc4riwwqstomskyuugrvqz/spack-src/nspr/pr/src/linking/prlink.c": "/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n#include \"primpl.h\"\n\n#include <string.h>\n\n#ifdef XP_BEOS\n#include <image.h>\n#endif\n\n#if defined(XP_MACOSX) && defined(USE_MACH_DYLD)\n#include <Carbon/Carbon.h>\n#include <CoreFoundation/CoreFoundation.h>\n#endif\n\n#ifdef XP_UNIX\n#ifdef USE_DLFCN\n#include <dlfcn.h>\n/* Define these on systems that don't have them. */\n#ifndef RTLD_NOW\n#define RTLD_NOW 0\n#endif\n#ifndef RTLD_LAZY\n#define RTLD_LAZY RTLD_NOW\n#endif\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL 0\n#endif\n#ifndef RTLD_LOCAL\n#define RTLD_LOCAL 0\n#endif\n#ifdef AIX\n#include <sys/ldr.h>\n#ifndef L_IGNOREUNLOAD /* AIX 4.3.3 does not have L_IGNOREUNLOAD. */\n#define L_IGNOREUNLOAD 0x10000000\n#endif\n#endif\n#ifdef OSF1\n#include <loader.h>\n#include <rld_interface.h>\n#endif\n#elif defined(USE_HPSHL)\n#include <dl.h>\n#elif defined(USE_MACH_DYLD)\n#include <mach-o/dyld.h>\n#endif\n#endif /* XP_UNIX */\n\n#define _PR_DEFAULT_LD_FLAGS PR_LD_LAZY\n\n/*\n * On these platforms, symbols have a leading '_'.\n */\n#if (defined(DARWIN) && defined(USE_MACH_DYLD)) \\\n    || defined(XP_OS2) \\\n    || ((defined(OPENBSD) || defined(NETBSD)) && !defined(__ELF__))\n#define NEED_LEADING_UNDERSCORE\n#endif\n\n#define PR_LD_PATHW 0x8000  /* for PR_LibSpec_PathnameU */\n\n/************************************************************************/\n\nstruct PRLibrary {\n    char*                       name;  /* Our own copy of the name string */\n    PRLibrary*                  next;\n    int                         refCount;\n    const PRStaticLinkTable*    staticTable;\n\n#ifdef XP_PC\n#ifdef XP_OS2\n    HMODULE                     dlh;\n#else\n    HINSTANCE                   dlh;\n#endif\n#endif\n\n#if defined(XP_MACOSX) && defined(USE_MACH_DYLD)\n    CFragConnectionID           connection;\n    CFBundleRef                 bundle;\n    Ptr                         main;\n    CFMutableDictionaryRef      wrappers;\n    const struct mach_header*   image;\n#endif\n\n#ifdef XP_UNIX\n#if defined(USE_HPSHL)\n    shl_t                       dlh;\n#elif defined(USE_MACH_DYLD)\n    NSModule                    dlh;\n#else\n    void*                       dlh;\n#endif \n#endif \n\n#ifdef XP_BEOS\n    void*                       dlh;\n    void*                       stub_dlh;\n#endif\n};\n\nstatic PRLibrary *pr_loadmap;\nstatic PRLibrary *pr_exe_loadmap;\nstatic PRMonitor *pr_linker_lock;\nstatic char* _pr_currentLibPath = NULL;\n\nstatic PRLibrary *pr_LoadLibraryByPathname(const char *name, PRIntn flags);\n\n/************************************************************************/\n\n#if !defined(USE_DLFCN) && !defined(HAVE_STRERROR)\n#define ERR_STR_BUF_LENGTH    20\n#endif\n\nstatic void DLLErrorInternal(PRIntn oserr)\n/*\n** This whole function, and most of the code in this file, are run\n** with a big hairy lock wrapped around it. Not the best of situations,\n** but will eventually come up with the right answer.\n*/\n{\n    const char *error = NULL;\n#ifdef USE_DLFCN\n    error = dlerror();  /* $$$ That'll be wrong some of the time - AOF */\n#elif defined(HAVE_STRERROR)\n    error = strerror(oserr);  /* this should be okay */\n#else\n    char errStrBuf[ERR_STR_BUF_LENGTH];\n    PR_snprintf(errStrBuf, sizeof(errStrBuf), \"error %d\", oserr);\n    error = errStrBuf;\n#endif\n    if (NULL != error)\n        PR_SetErrorText(strlen(error), error);\n}  /* DLLErrorInternal */\n\nvoid _PR_InitLinker(void)\n{\n    PRLibrary *lm = NULL;\n#if defined(XP_UNIX)\n    void *h;\n#endif\n\n    if (!pr_linker_lock) {\n        pr_linker_lock = PR_NewNamedMonitor(\"linker-lock\");\n    }\n    PR_EnterMonitor(pr_linker_lock);\n\n#if defined(XP_PC)\n    lm = PR_NEWZAP(PRLibrary);\n    lm->name = strdup(\"Executable\");\n#if defined(XP_OS2)\n    lm->dlh = NULLHANDLE;\n#else\n    /* A module handle for the executable. */\n    lm->dlh = GetModuleHandle(NULL);\n#endif /* ! XP_OS2 */\n\n    lm->refCount    = 1;\n    lm->staticTable = NULL;\n    pr_exe_loadmap  = lm;\n    pr_loadmap      = lm;\n\n#elif defined(XP_UNIX)\n#ifdef HAVE_DLL\n#if defined(USE_DLFCN) && !defined(NO_DLOPEN_NULL)\n    h = dlopen(0, RTLD_LAZY);\n    if (!h) {\n        char *error;\n        \n        DLLErrorInternal(_MD_ERRNO());\n        error = (char*)PR_MALLOC(PR_GetErrorTextLength());\n        (void) PR_GetErrorText(error);\n        fprintf(stderr, \"failed to initialize shared libraries [%s]\\n\",\n            error);\n        PR_DELETE(error);\n        abort();/* XXX */\n    }\n#elif defined(USE_HPSHL)\n    h = NULL;\n    /* don't abort with this NULL */\n#elif defined(USE_MACH_DYLD) || defined(NO_DLOPEN_NULL)\n    h = NULL; /* XXXX  toshok */ /* XXXX  vlad */\n#else\n#error no dll strategy\n#endif /* USE_DLFCN */\n\n    lm = PR_NEWZAP(PRLibrary);\n    if (lm) {\n        lm->name = strdup(\"a.out\");\n        lm->refCount = 1;\n        lm->dlh = h;\n        lm->staticTable = NULL;\n    }\n    pr_exe_loadmap = lm;\n    pr_loadmap = lm;\n#endif /* HAVE_DLL */\n#endif /* XP_UNIX */\n\n    if (lm) {\n        PR_LOG(_pr_linker_lm, PR_LOG_MIN,\n            (\"Loaded library %s (init)\", lm->name));\n    }\n\n    PR_ExitMonitor(pr_linker_lock);\n}\n\n/*\n * _PR_ShutdownLinker does not unload the dlls loaded by the application\n * via calls to PR_LoadLibrary.  Any dlls that still remain on the\n * pr_loadmap list when NSPR shuts down are application programming errors.\n * The only exception is pr_exe_loadmap, which was added to the list by\n * NSPR and hence should be cleaned up by NSPR.\n */\nvoid _PR_ShutdownLinker(void)\n{\n    /* FIXME: pr_exe_loadmap should be destroyed. */\n    \n    PR_DestroyMonitor(pr_linker_lock);\n    pr_linker_lock = NULL;\n\n    if (_pr_currentLibPath) {\n        free(_pr_currentLibPath);\n        _pr_currentLibPath = NULL;\n    }\n}\n\n/******************************************************************************/\n\nPR_IMPLEMENT(PRStatus) PR_SetLibraryPath(const char *path)\n{\n    PRStatus rv = PR_SUCCESS;\n\n    if (!_pr_initialized) _PR_ImplicitInitialization();\n    PR_EnterMonitor(pr_linker_lock);\n    if (_pr_currentLibPath) {\n        free(_pr_currentLibPath);\n    }\n    if (path) {\n        _pr_currentLibPath = strdup(path);\n        if (!_pr_currentLibPath) {\n            PR_SetError(PR_OUT_OF_MEMORY_ERROR, 0);\n        rv = PR_FAILURE;\n        }\n    } else {\n        _pr_currentLibPath = 0;\n    }\n    PR_ExitMonitor(pr_linker_lock);\n    return rv;\n}\n\n/*\n** Return the library path for finding shared libraries.\n*/\nPR_IMPLEMENT(char *) \nPR_GetLibraryPath(void)\n{\n    char *ev;\n    char *copy = NULL;  /* a copy of _pr_currentLibPath */\n\n    if (!_pr_initialized) _PR_ImplicitInitialization();\n    PR_EnterMonitor(pr_linker_lock);\n    if (_pr_currentLibPath != NULL) {\n        goto exit;\n    }\n\n    /* initialize pr_currentLibPath */\n\n#ifdef XP_PC\n    ev = getenv(\"LD_LIBRARY_PATH\");\n    if (!ev) {\n    ev = \".;\\\\lib\";\n    }\n    ev = strdup(ev);\n#endif\n\n#if defined(XP_UNIX) || defined(XP_BEOS)\n#if defined(USE_DLFCN) || defined(USE_MACH_DYLD) || defined(XP_BEOS)\n    {\n    char *p=NULL;\n    int len;\n\n#ifdef XP_BEOS\n    ev = getenv(\"LIBRARY_PATH\");\n    if (!ev) {\n        ev = \"%A/lib:/boot/home/config/lib:/boot/beos/system/lib\";\n    }\n#else\n    ev = getenv(\"LD_LIBRARY_PATH\");\n    if (!ev) {\n        ev = \"/usr/lib:/lib\";\n    }\n#endif\n    len = strlen(ev) + 1;        /* +1 for the null */\n\n    p = (char*) malloc(len);\n    if (p) {\n        strcpy(p, ev);\n    }   /* if (p)  */\n    ev = p;\n    PR_LOG(_pr_io_lm, PR_LOG_NOTICE, (\"linker path '%s'\", ev));\n\n    }\n#else\n    /* AFAIK there isn't a library path with the HP SHL interface --Rob */\n    ev = strdup(\"\");\n#endif\n#endif\n\n    /*\n     * If ev is NULL, we have run out of memory\n     */\n    _pr_currentLibPath = ev;\n\n  exit:\n    if (_pr_currentLibPath) {\n        copy = strdup(_pr_currentLibPath);\n    }\n    PR_ExitMonitor(pr_linker_lock);\n    if (!copy) {\n        PR_SetError(PR_OUT_OF_MEMORY_ERROR, 0);\n    }\n    return copy;\n}\n\n/*\n** Build library name from path, lib and extensions\n*/\nPR_IMPLEMENT(char*) \nPR_GetLibraryName(const char *path, const char *lib)\n{\n    char *fullname;\n\n#ifdef XP_PC\n    if (strstr(lib, PR_DLL_SUFFIX) == NULL)\n    {\n        if (path) {\n            fullname = PR_smprintf(\"%s\\\\%s%s\", path, lib, PR_DLL_SUFFIX);\n        } else {\n            fullname = PR_smprintf(\"%s%s\", lib, PR_DLL_SUFFIX);\n        }\n    } else {\n        if (path) {\n            fullname = PR_smprintf(\"%s\\\\%s\", path, lib);\n        } else {\n            fullname = PR_smprintf(\"%s\", lib);\n        }\n    }\n#endif /* XP_PC */\n#if defined(XP_UNIX) || defined(XP_BEOS)\n    if (strstr(lib, PR_DLL_SUFFIX) == NULL)\n    {\n        if (path) {\n            fullname = PR_smprintf(\"%s/lib%s%s\", path, lib, PR_DLL_SUFFIX);\n        } else {\n            fullname = PR_smprintf(\"lib%s%s\", lib, PR_DLL_SUFFIX);\n        }\n    } else {\n        if (path) {\n            fullname = PR_smprintf(\"%s/%s\", path, lib);\n        } else {\n            fullname = PR_smprintf(\"%s\", lib);\n        }\n    }\n#endif /* XP_UNIX || XP_BEOS */\n    return fullname;\n}\n\n/*\n** Free the memory allocated, for the caller, by PR_GetLibraryName\n*/\nPR_IMPLEMENT(void) \nPR_FreeLibraryName(char *mem)\n{\n    PR_smprintf_free(mem);\n}\n\nstatic PRLibrary* \npr_UnlockedFindLibrary(const char *name)\n{\n    PRLibrary* lm = pr_loadmap;\n    const char* np = strrchr(name, PR_DIRECTORY_SEPARATOR);\n    np = np ? np + 1 : name;\n    while (lm) {\n    const char* cp = strrchr(lm->name, PR_DIRECTORY_SEPARATOR);\n    cp = cp ? cp + 1 : lm->name;\n#ifdef WIN32\n        /* Windows DLL names are case insensitive... */\n    if (strcmpi(np, cp) == 0) \n#elif defined(XP_OS2)\n    if (stricmp(np, cp) == 0)\n#else\n    if (strcmp(np, cp)  == 0) \n#endif\n    {\n        /* found */\n        lm->refCount++;\n        PR_LOG(_pr_linker_lm, PR_LOG_MIN,\n           (\"%s incr => %d (find lib)\",\n            lm->name, lm->refCount));\n        return lm;\n    }\n    lm = lm->next;\n    }\n    return NULL;\n}\n\nPR_IMPLEMENT(PRLibrary*)\nPR_LoadLibraryWithFlags(PRLibSpec libSpec, PRIntn flags)\n{\n    if (flags == 0) {\n        flags = _PR_DEFAULT_LD_FLAGS;\n    }\n    switch (libSpec.type) {\n        case PR_LibSpec_Pathname:\n            return pr_LoadLibraryByPathname(libSpec.value.pathname, flags);\n#ifdef WIN32\n        case PR_LibSpec_PathnameU:\n            /*\n             * cast to |char *| and set PR_LD_PATHW flag so that\n             * it can be cast back to PRUnichar* in the callee.\n             */\n            return pr_LoadLibraryByPathname((const char*) \n                                            libSpec.value.pathname_u, \n                                            flags | PR_LD_PATHW);\n#endif\n        default:\n            PR_SetError(PR_INVALID_ARGUMENT_ERROR, 0);\n            return NULL;\n    }\n}\n            \nPR_IMPLEMENT(PRLibrary*) \nPR_LoadLibrary(const char *name)\n{\n    PRLibSpec libSpec;\n\n    libSpec.type = PR_LibSpec_Pathname;\n    libSpec.value.pathname = name;\n    return PR_LoadLibraryWithFlags(libSpec, 0);\n}\n\n#if defined(USE_MACH_DYLD)\nstatic NSModule\npr_LoadMachDyldModule(const char *name)\n{\n    NSObjectFileImage ofi;\n    NSModule h = NULL;\n    if (NSCreateObjectFileImageFromFile(name, &ofi)\n            == NSObjectFileImageSuccess) {\n        h = NSLinkModule(ofi, name, NSLINKMODULE_OPTION_PRIVATE\n                         | NSLINKMODULE_OPTION_RETURN_ON_ERROR);\n        if (h == NULL) {\n            NSLinkEditErrors linkEditError;\n            int errorNum;\n            const char *fileName;\n            const char *errorString;\n            NSLinkEditError(&linkEditError, &errorNum, &fileName, &errorString);\n            PR_LOG(_pr_linker_lm, PR_LOG_MIN, \n                   (\"LoadMachDyldModule error %d:%d for file %s:\\n%s\",\n                    linkEditError, errorNum, fileName, errorString));\n        }\n        if (NSDestroyObjectFileImage(ofi) == FALSE) {\n            if (h) {\n                (void)NSUnLinkModule(h, NSUNLINKMODULE_OPTION_NONE);\n                h = NULL;\n            }\n        }\n    }\n    return h;\n}\n#endif\n\n#if defined(XP_MACOSX) && defined(USE_MACH_DYLD)\n\n/*\n** macLibraryLoadProc is a function definition for a Mac shared library\n** loading method. The \"name\" param is the same full or partial pathname\n** that was passed to pr_LoadLibraryByPathName. The function must fill\n** in the fields of \"lm\" which apply to its library type. Returns\n** PR_SUCCESS if successful.\n*/\n\ntypedef PRStatus (*macLibraryLoadProc)(const char *name, PRLibrary *lm);\n\n#ifdef __ppc__\n\n/*\n** CFM and its TVectors only exist on PowerPC.  Other OS X architectures\n** only use Mach-O as a native binary format.\n*/\n\nstatic void* TV2FP(CFMutableDictionaryRef dict, const char* name, void *tvp)\n{\n    static uint32 glue[6] = { 0x3D800000, 0x618C0000, 0x800C0000, 0x804C0004, 0x7C0903A6, 0x4E800420 };\n    uint32* newGlue = NULL;\n\n    if (tvp != NULL) {\n        CFStringRef nameRef = CFStringCreateWithCString(NULL, name, kCFStringEncodingASCII);\n        if (nameRef) {\n            CFMutableDataRef glueData = (CFMutableDataRef) CFDictionaryGetValue(dict, nameRef);\n            if (glueData == NULL) {\n                glueData = CFDataCreateMutable(NULL, sizeof(glue));\n                if (glueData != NULL) {\n                    newGlue = (uint32*) CFDataGetMutableBytePtr(glueData);\n                    memcpy(newGlue, glue, sizeof(glue));\n                    newGlue[0] |= ((UInt32)tvp >> 16);\n                    newGlue[1] |= ((UInt32)tvp & 0xFFFF);\n                    MakeDataExecutable(newGlue, sizeof(glue));\n                    CFDictionaryAddValue(dict, nameRef, glueData);\n                    CFRelease(glueData);\n\n                    PR_LOG(_pr_linker_lm, PR_LOG_MIN, (\"TV2FP: created wrapper for CFM function %s().\", name));\n                }\n            } else {\n                PR_LOG(_pr_linker_lm, PR_LOG_MIN, (\"TV2FP: found wrapper for CFM function %s().\", name));\n\n                newGlue = (uint32*) CFDataGetMutableBytePtr(glueData);\n            }\n            CFRelease(nameRef);\n        }\n    }\n    \n    return newGlue;\n}\n\nstatic PRStatus\npr_LoadViaCFM(const char *name, PRLibrary *lm)\n{\n    OSErr err;\n    Str255 errName;\n    FSRef ref;\n    FSSpec fileSpec;\n    Boolean tempUnusedBool;\n\n    /*\n     * Make an FSSpec from the path name and call GetDiskFragment.\n     */\n\n    /* Use direct conversion of POSIX path to FSRef to FSSpec. */\n    err = FSPathMakeRef((const UInt8*)name, &ref, NULL);\n    if (err != noErr)\n        return PR_FAILURE;\n    err = FSGetCatalogInfo(&ref, kFSCatInfoNone, NULL, NULL,\n                           &fileSpec, NULL);\n    if (err != noErr)\n        return PR_FAILURE;\n\n    /* Resolve an alias if this was one */\n    err = ResolveAliasFile(&fileSpec, true, &tempUnusedBool,\n                           &tempUnusedBool);\n    if (err != noErr)\n        return PR_FAILURE;\n\n    /* Finally, try to load the library */\n    err = GetDiskFragment(&fileSpec, 0, kCFragGoesToEOF, fileSpec.name,\n                          kLoadCFrag, &lm->connection, &lm->main, errName);\n\n    if (err == noErr && lm->connection) {\n        /*\n         * if we're a mach-o binary, need to wrap all CFM function\n         * pointers. need a hash-table of already seen function\n         * pointers, etc.\n         */\n        lm->wrappers = CFDictionaryCreateMutable(NULL, 16,\n                       &kCFTypeDictionaryKeyCallBacks,\n                       &kCFTypeDictionaryValueCallBacks);\n        if (lm->wrappers) {\n            lm->main = TV2FP(lm->wrappers, \"main\", lm->main);\n        } else\n            err = memFullErr;\n    }\n    return (err == noErr) ? PR_SUCCESS : PR_FAILURE;\n}\n#endif /* __ppc__ */\n\n/*\n** Creates a CFBundleRef if the pathname refers to a Mac OS X bundle\n** directory. The caller is responsible for calling CFRelease() to\n** deallocate.\n*/\n\nstatic PRStatus\npr_LoadCFBundle(const char *name, PRLibrary *lm)\n{\n    CFURLRef bundleURL;\n    CFBundleRef bundle = NULL;\n    char pathBuf[PATH_MAX];\n    const char *resolvedPath;\n    CFStringRef pathRef;\n\n    /* Takes care of relative paths and symlinks */\n    resolvedPath = realpath(name, pathBuf);\n    if (!resolvedPath)\n        return PR_FAILURE;\n        \n    pathRef = CFStringCreateWithCString(NULL, pathBuf, kCFStringEncodingUTF8);\n    if (pathRef) {\n        bundleURL = CFURLCreateWithFileSystemPath(NULL, pathRef,\n                                                  kCFURLPOSIXPathStyle, true);\n        if (bundleURL) {\n            bundle = CFBundleCreate(NULL, bundleURL);\n            CFRelease(bundleURL);\n        }\n        CFRelease(pathRef);\n    }\n\n    lm->bundle = bundle;\n    return (bundle != NULL) ? PR_SUCCESS : PR_FAILURE;\n}\n\nstatic PRStatus\npr_LoadViaDyld(const char *name, PRLibrary *lm)\n{\n    lm->dlh = pr_LoadMachDyldModule(name);\n    if (lm->dlh == NULL) {\n        lm->image = NSAddImage(name, NSADDIMAGE_OPTION_RETURN_ON_ERROR\n                               | NSADDIMAGE_OPTION_WITH_SEARCHING);\n        if (lm->image == NULL) {\n            NSLinkEditErrors linkEditError;\n            int errorNum;\n            const char *fileName;\n            const char *errorString;\n            NSLinkEditError(&linkEditError, &errorNum, &fileName, &errorString);\n            PR_LOG(_pr_linker_lm, PR_LOG_MIN, \n                   (\"LoadMachDyldModule error %d:%d for file %s:\\n%s\",\n                    linkEditError, errorNum, fileName, errorString));\n        }\n    }\n    return (lm->dlh != NULL || lm->image != NULL) ? PR_SUCCESS : PR_FAILURE;\n}\n\n#endif /* XP_MACOSX && USE_MACH_DYLD */\n\n/*\n** Dynamically load a library. Only load libraries once, so scan the load\n** map first.\n*/\nstatic PRLibrary*\npr_LoadLibraryByPathname(const char *name, PRIntn flags)\n{\n    PRLibrary *lm;\n    PRLibrary* result = NULL;\n    PRInt32 oserr;\n#ifdef WIN32\n    char utf8name_stack[MAX_PATH];\n    char *utf8name_malloc = NULL;\n    char *utf8name = utf8name_stack;\n    PRUnichar wname_stack[MAX_PATH];\n    PRUnichar *wname_malloc = NULL;\n    PRUnichar *wname = wname_stack;\n    int len;\n#endif\n\n    if (!_pr_initialized) _PR_ImplicitInitialization();\n\n    /* See if library is already loaded */\n    PR_EnterMonitor(pr_linker_lock);\n\n#ifdef WIN32\n    if (flags & PR_LD_PATHW) {\n        /* cast back what's cast to |char *| for the argument passing. */\n        wname = (LPWSTR) name;\n    } else {\n        int wlen = MultiByteToWideChar(CP_ACP, 0, name, -1, NULL, 0);\n        if (wlen > MAX_PATH)\n            wname = wname_malloc = PR_Malloc(wlen * sizeof(PRUnichar));\n        if (wname == NULL ||\n            !MultiByteToWideChar(CP_ACP, 0,  name, -1, wname, wlen)) {\n            oserr = _MD_ERRNO();\n            goto unlock;\n        }\n    }\n    len = WideCharToMultiByte(CP_UTF8, 0, wname, -1, NULL, 0, NULL, NULL);\n    if (len > MAX_PATH)\n        utf8name = utf8name_malloc = PR_Malloc(len);\n    if (utf8name == NULL ||\n        !WideCharToMultiByte(CP_UTF8, 0, wname, -1,\n                             utf8name, len, NULL, NULL)) {\n        oserr = _MD_ERRNO();\n        goto unlock;\n    }\n    /* the list of loaded library names are always kept in UTF-8 \n     * on Win32 platforms */\n    result = pr_UnlockedFindLibrary(utf8name);\n#else\n    result = pr_UnlockedFindLibrary(name);\n#endif\n\n    if (result != NULL) goto unlock;\n\n    lm = PR_NEWZAP(PRLibrary);\n    if (lm == NULL) {\n        oserr = _MD_ERRNO();\n        goto unlock;\n    }\n    lm->staticTable = NULL;\n\n#ifdef XP_OS2  /* Why isn't all this stuff in MD code?! */\n    {\n        HMODULE h;\n        UCHAR pszError[_MAX_PATH];\n        ULONG ulRc = NO_ERROR;\n\n          ulRc = DosLoadModule(pszError, _MAX_PATH, (PSZ) name, &h);\n          if (ulRc != NO_ERROR) {\n              oserr = ulRc;\n              PR_DELETE(lm);\n              goto unlock;\n          }\n          lm->name = strdup(name);\n          lm->dlh  = h;\n          lm->next = pr_loadmap;\n          pr_loadmap = lm;\n    }\n#endif /* XP_OS2 */\n\n#ifdef WIN32\n    {\n    HINSTANCE h;\n\n    h = LoadLibraryExW(wname, NULL,\n                       (flags & PR_LD_ALT_SEARCH_PATH) ?\n                       LOAD_WITH_ALTERED_SEARCH_PATH : 0);\n    if (h == NULL) {\n        oserr = _MD_ERRNO();\n        PR_DELETE(lm);\n        goto unlock;\n    }\n    lm->name = strdup(utf8name);\n    lm->dlh = h;\n    lm->next = pr_loadmap;\n    pr_loadmap = lm;\n    }\n#endif /* WIN32 */\n\n#if defined(XP_MACOSX) && defined(USE_MACH_DYLD)\n    {\n    int     i;\n    PRStatus status;\n\n    static const macLibraryLoadProc loadProcs[] = {\n#ifdef __ppc__\n        pr_LoadViaDyld, pr_LoadCFBundle, pr_LoadViaCFM\n#else  /* __ppc__ */\n        pr_LoadViaDyld, pr_LoadCFBundle\n#endif /* __ppc__ */\n    };\n\n    for (i = 0; i < sizeof(loadProcs) / sizeof(loadProcs[0]); i++) {\n        if ((status = loadProcs[i](name, lm)) == PR_SUCCESS)\n            break;\n    }\n    if (status != PR_SUCCESS) {\n        oserr = cfragNoLibraryErr;\n        PR_DELETE(lm);\n        goto unlock;        \n    }\n    lm->name = strdup(name);\n    lm->next = pr_loadmap;\n    pr_loadmap = lm;\n    }\n#endif\n\n#if defined(XP_UNIX) && !(defined(XP_MACOSX) && defined(USE_MACH_DYLD))\n#ifdef HAVE_DLL\n    {\n#if defined(USE_DLFCN)\n#ifdef NTO\n    /* Neutrino needs RTLD_GROUP to load Netscape plugins. (bug 71179) */\n    int dl_flags = RTLD_GROUP;\n#elif defined(AIX)\n    /* AIX needs RTLD_MEMBER to load an archive member.  (bug 228899) */\n    int dl_flags = RTLD_MEMBER;\n#else\n    int dl_flags = 0;\n#endif\n    void *h = NULL;\n\n    if (flags & PR_LD_LAZY) {\n        dl_flags |= RTLD_LAZY;\n    }\n    if (flags & PR_LD_NOW) {\n        dl_flags |= RTLD_NOW;\n    }\n    if (flags & PR_LD_GLOBAL) {\n        dl_flags |= RTLD_GLOBAL;\n    }\n    if (flags & PR_LD_LOCAL) {\n        dl_flags |= RTLD_LOCAL;\n    }\n#if defined(DARWIN)\n    /* ensure the file exists if it contains a slash character i.e. path */\n    /* DARWIN's dlopen ignores the provided path and checks for the */\n    /* plain filename in DYLD_LIBRARY_PATH */\n    if (strchr(name, PR_DIRECTORY_SEPARATOR) == NULL ||\n        PR_Access(name, PR_ACCESS_EXISTS) == PR_SUCCESS) {\n            h = dlopen(name, dl_flags);\n        }\n#else\n    h = dlopen(name, dl_flags);\n#endif\n#elif defined(USE_HPSHL)\n    int shl_flags = 0;\n    shl_t h;\n\n    /*\n     * Use the DYNAMIC_PATH flag only if 'name' is a plain file\n     * name (containing no directory) to match the behavior of\n     * dlopen().\n     */\n    if (strchr(name, PR_DIRECTORY_SEPARATOR) == NULL) {\n        shl_flags |= DYNAMIC_PATH;\n    }\n    if (flags & PR_LD_LAZY) {\n        shl_flags |= BIND_DEFERRED;\n    }\n    if (flags & PR_LD_NOW) {\n        shl_flags |= BIND_IMMEDIATE;\n    }\n    /* No equivalent of PR_LD_GLOBAL and PR_LD_LOCAL. */\n    h = shl_load(name, shl_flags, 0L);\n#elif defined(USE_MACH_DYLD)\n    NSModule h = pr_LoadMachDyldModule(name);\n#else\n#error Configuration error\n#endif\n    if (!h) {\n        oserr = _MD_ERRNO();\n        PR_DELETE(lm);\n        goto unlock;\n    }\n    lm->name = strdup(name);\n    lm->dlh = h;\n    lm->next = pr_loadmap;\n    pr_loadmap = lm;\n    }\n#endif /* HAVE_DLL */\n#endif /* XP_UNIX && !(XP_MACOSX && USE_MACH_DYLD) */\n\n    lm->refCount = 1;\n\n#ifdef XP_BEOS\n    {\n        image_info info;\n        int32 cookie = 0;\n        image_id imageid = B_ERROR;\n        image_id stubid = B_ERROR;\n        PRLibrary *p;\n\n        for (p = pr_loadmap; p != NULL; p = p->next) {\n            /* hopefully, our caller will always use the same string\n               to refer to the same library */\n            if (strcmp(name, p->name) == 0) {\n                /* we've already loaded this library */\n                imageid = info.id;\n                lm->refCount++;\n                break;\n            }\n        }\n\n        if(imageid == B_ERROR) {\n            /* it appears the library isn't yet loaded - load it now */\n            char stubName [B_PATH_NAME_LENGTH + 1];\n\n            /* the following is a work-around to a \"bug\" in the beos -\n               the beos system loader allows only 32M (system-wide)\n               to be used by code loaded as \"add-ons\" (code loaded\n               through the 'load_add_on()' system call, which includes\n               mozilla components), but allows 256M to be used by\n               shared libraries.\n               \n               unfortunately, mozilla is too large to fit into the\n               \"add-on\" space, so we must trick the loader into\n               loading some of the components as shared libraries.  this\n               is accomplished by creating a \"stub\" add-on (an empty\n               shared object), and linking it with the component\n               (the actual .so file generated by the build process,\n               without any modifications).  when this stub is loaded\n               by load_add_on(), the loader will automatically load the\n               component into the shared library space.\n            */\n\n            strcpy(stubName, name);\n            strcat(stubName, \".stub\");\n\n            /* first, attempt to load the stub (thereby loading the\n               component as a shared library */\n            if ((stubid = load_add_on(stubName)) > B_ERROR) {\n                /* the stub was loaded successfully. */\n                imageid = B_FILE_NOT_FOUND;\n\n                cookie = 0;\n                while (get_next_image_info(0, &cookie, &info) == B_OK) {\n                    const char *endOfSystemName = strrchr(info.name, '/');\n                    const char *endOfPassedName = strrchr(name, '/');\n                    if( 0 == endOfSystemName ) \n                        endOfSystemName = info.name;\n                    else\n                        endOfSystemName++;\n                    if( 0 == endOfPassedName )\n                        endOfPassedName = name;\n                    else\n                        endOfPassedName++;\n                    if (strcmp(endOfSystemName, endOfPassedName) == 0) {\n                        /* this is the actual component - remember it */\n                        imageid = info.id;\n                        break;\n                    }\n                }\n\n            } else {\n                /* we failed to load the \"stub\" - try to load the\n                   component directly as an add-on */\n                stubid = B_ERROR;\n                imageid = load_add_on(name);\n            }\n        }\n\n        if (imageid <= B_ERROR) {\n            oserr = imageid;\n            PR_DELETE( lm );\n            goto unlock;\n        }\n        lm->name = strdup(name);\n        lm->dlh = (void*)imageid;\n        lm->stub_dlh = (void*)stubid;\n        lm->next = pr_loadmap;\n        pr_loadmap = lm;\n    }\n#endif\n\n    result = lm;    /* success */\n    PR_LOG(_pr_linker_lm, PR_LOG_MIN, (\"Loaded library %s (load lib)\", lm->name));\n\n  unlock:\n    if (result == NULL) {\n        PR_SetError(PR_LOAD_LIBRARY_ERROR, oserr);\n        DLLErrorInternal(oserr);  /* sets error text */\n    }\n#ifdef WIN32\n    if (utf8name_malloc) \n        PR_Free(utf8name_malloc);\n    if (wname_malloc)\n        PR_Free(wname_malloc);\n#endif\n    PR_ExitMonitor(pr_linker_lock);\n    return result;\n}\n\n/*\n** Unload a shared library which was loaded via PR_LoadLibrary\n*/\nPR_IMPLEMENT(PRStatus) \nPR_UnloadLibrary(PRLibrary *lib)\n{\n    int result = 0;\n    PRStatus status = PR_SUCCESS;\n\n    if (lib == 0) {\n        PR_SetError(PR_INVALID_ARGUMENT_ERROR, 0);\n        return PR_FAILURE;\n    }\n\n    PR_EnterMonitor(pr_linker_lock);\n\n    if (lib->refCount <= 0) {\n        PR_ExitMonitor(pr_linker_lock);\n        PR_SetError(PR_INVALID_ARGUMENT_ERROR, 0);\n        return PR_FAILURE;\n    }\n\n    if (--lib->refCount > 0) {\n    PR_LOG(_pr_linker_lm, PR_LOG_MIN,\n           (\"%s decr => %d\",\n        lib->name, lib->refCount));\n    goto done;\n    }\n\n#ifdef XP_BEOS\n    if(((image_id)lib->stub_dlh) == B_ERROR)\n        unload_add_on( (image_id) lib->dlh );\n    else\n        unload_add_on( (image_id) lib->stub_dlh);\n#endif\n\n#ifdef XP_UNIX\n#ifdef HAVE_DLL\n#ifdef USE_DLFCN\n    result = dlclose(lib->dlh);\n#elif defined(USE_HPSHL)\n    result = shl_unload(lib->dlh);\n#elif defined(USE_MACH_DYLD)\n    if (lib->dlh)\n        result = NSUnLinkModule(lib->dlh, NSUNLINKMODULE_OPTION_NONE) ? 0 : -1;\n#else\n#error Configuration error\n#endif\n#endif /* HAVE_DLL */\n#endif /* XP_UNIX */\n#ifdef XP_PC\n    if (lib->dlh) {\n        FreeLibrary((HINSTANCE)(lib->dlh));\n        lib->dlh = (HINSTANCE)NULL;\n    }\n#endif  /* XP_PC */\n\n#if defined(XP_MACOSX) && defined(USE_MACH_DYLD)\n    /* Close the connection */\n    if (lib->connection)\n        CloseConnection(&(lib->connection));\n    if (lib->bundle)\n        CFRelease(lib->bundle);\n    if (lib->wrappers)\n        CFRelease(lib->wrappers);\n    /* No way to unload an image (lib->image) */\n#endif\n\n    /* unlink from library search list */\n    if (pr_loadmap == lib)\n        pr_loadmap = pr_loadmap->next;\n    else if (pr_loadmap != NULL) {\n        PRLibrary* prev = pr_loadmap;\n        PRLibrary* next = pr_loadmap->next;\n        while (next != NULL) {\n            if (next == lib) {\n                prev->next = next->next;\n                goto freeLib;\n            }\n            prev = next;\n            next = next->next;\n        }\n        /*\n         * fail (the library is not on the _pr_loadmap list),\n         * but don't wipe out an error from dlclose/shl_unload.\n         */\n        PR_NOT_REACHED(\"_pr_loadmap and lib->refCount inconsistent\");\n        if (result == 0) {\n            PR_SetError(PR_INVALID_ARGUMENT_ERROR, 0);\n            status = PR_FAILURE;\n        }\n    }\n    /*\n     * We free the PRLibrary structure whether dlclose/shl_unload\n     * succeeds or not.\n     */\n\n  freeLib:\n    PR_LOG(_pr_linker_lm, PR_LOG_MIN, (\"Unloaded library %s\", lib->name));\n    free(lib->name);\n    lib->name = NULL;\n    PR_DELETE(lib);\n    if (result != 0) {\n        PR_SetError(PR_UNLOAD_LIBRARY_ERROR, _MD_ERRNO());\n        DLLErrorInternal(_MD_ERRNO());\n        status = PR_FAILURE;\n    }\n\ndone:\n    PR_ExitMonitor(pr_linker_lock);\n    return status;\n}\n\nstatic void* \npr_FindSymbolInLib(PRLibrary *lm, const char *name)\n{\n    void *f = NULL;\n#ifdef XP_OS2\n    int rc;\n#endif\n\n    if (lm->staticTable != NULL) {\n        const PRStaticLinkTable* tp;\n        for (tp = lm->staticTable; tp->name; tp++) {\n            if (strcmp(name, tp->name) == 0) {\n                return (void*) tp->fp;\n            }\n        }\n        /* \n        ** If the symbol was not found in the static table then check if\n        ** the symbol was exported in the DLL... Win16 only!!\n        */\n#if !defined(WIN16) && !defined(XP_BEOS)\n        PR_SetError(PR_FIND_SYMBOL_ERROR, 0);\n        return (void*)NULL;\n#endif\n    }\n    \n#ifdef XP_OS2\n    rc = DosQueryProcAddr(lm->dlh, 0, (PSZ) name, (PFN *) &f);\n#if defined(NEED_LEADING_UNDERSCORE)\n    /*\n     * Older plugins (not built using GCC) will have symbols that are not\n     * underscore prefixed.  We check for that here.\n     */\n    if (rc != NO_ERROR) {\n        name++;\n        DosQueryProcAddr(lm->dlh, 0, (PSZ) name, (PFN *) &f);\n    }\n#endif\n#endif  /* XP_OS2 */\n\n#ifdef WIN32\n    f = GetProcAddress(lm->dlh, name);\n#endif  /* WIN32 */\n\n#if defined(XP_MACOSX) && defined(USE_MACH_DYLD)\n/* add this offset to skip the leading underscore in name */\n#define SYM_OFFSET 1\n    if (lm->bundle) {\n        CFStringRef nameRef = CFStringCreateWithCString(NULL, name + SYM_OFFSET, kCFStringEncodingASCII);\n        if (nameRef) {\n            f = CFBundleGetFunctionPointerForName(lm->bundle, nameRef);\n            CFRelease(nameRef);\n        }\n    }\n    if (lm->connection) {\n        Ptr                 symAddr;\n        CFragSymbolClass    symClass;\n        Str255              pName;\n        \n        PR_LOG(_pr_linker_lm, PR_LOG_MIN, (\"Looking up symbol: %s\", name + SYM_OFFSET));\n        \n        c2pstrcpy(pName, name + SYM_OFFSET);\n        \n        f = (FindSymbol(lm->connection, pName, &symAddr, &symClass) == noErr) ? symAddr : NULL;\n        \n#ifdef __ppc__\n        /* callers expect mach-o function pointers, so must wrap tvectors with glue. */\n        if (f && symClass == kTVectorCFragSymbol) {\n            f = TV2FP(lm->wrappers, name + SYM_OFFSET, f);\n        }\n#endif /* __ppc__ */\n        \n        if (f == NULL && strcmp(name + SYM_OFFSET, \"main\") == 0) f = lm->main;\n    }\n    if (lm->image) {\n        NSSymbol symbol;\n        symbol = NSLookupSymbolInImage(lm->image, name,\n                 NSLOOKUPSYMBOLINIMAGE_OPTION_BIND\n                 | NSLOOKUPSYMBOLINIMAGE_OPTION_RETURN_ON_ERROR);\n        if (symbol != NULL)\n            f = NSAddressOfSymbol(symbol);\n        else\n            f = NULL;\n    }\n#undef SYM_OFFSET\n#endif /* XP_MACOSX && USE_MACH_DYLD */\n\n#ifdef XP_BEOS\n    if( B_NO_ERROR != get_image_symbol( (image_id)lm->dlh, name, B_SYMBOL_TYPE_TEXT, &f ) ) {\n        f = NULL;\n    }\n#endif\n\n#ifdef XP_UNIX\n#ifdef HAVE_DLL\n#ifdef USE_DLFCN\n    f = dlsym(lm->dlh, name);\n#elif defined(USE_HPSHL)\n    if (shl_findsym(&lm->dlh, name, TYPE_PROCEDURE, &f) == -1) {\n        f = NULL;\n    }\n#elif defined(USE_MACH_DYLD)\n    if (lm->dlh) {\n        NSSymbol symbol;\n        symbol = NSLookupSymbolInModule(lm->dlh, name);\n        if (symbol != NULL)\n            f = NSAddressOfSymbol(symbol);\n        else\n            f = NULL;\n    }\n#endif\n#endif /* HAVE_DLL */\n#endif /* XP_UNIX */\n    if (f == NULL) {\n        PR_SetError(PR_FIND_SYMBOL_ERROR, _MD_ERRNO());\n        DLLErrorInternal(_MD_ERRNO());\n    }\n    return f;\n}\n\n/*\n** Called by class loader to resolve missing native's\n*/\nPR_IMPLEMENT(void*) \nPR_FindSymbol(PRLibrary *lib, const char *raw_name)\n{\n    void *f = NULL;\n#if defined(NEED_LEADING_UNDERSCORE)\n    char *name;\n#else\n    const char *name;\n#endif\n    /*\n    ** Mangle the raw symbol name in any way that is platform specific.\n    */\n#if defined(NEED_LEADING_UNDERSCORE)\n    /* Need a leading _ */\n    name = PR_smprintf(\"_%s\", raw_name);\n#elif defined(AIX)\n    /*\n    ** AIX with the normal linker put's a \".\" in front of the symbol\n    ** name.  When use \"svcc\" and \"svld\" then the \".\" disappears. Go\n    ** figure.\n    */\n    name = raw_name;\n#else\n    name = raw_name;\n#endif\n\n    PR_EnterMonitor(pr_linker_lock);\n    PR_ASSERT(lib != NULL);\n    f = pr_FindSymbolInLib(lib, name);\n\n#if defined(NEED_LEADING_UNDERSCORE)\n    PR_smprintf_free(name);\n#endif\n\n    PR_ExitMonitor(pr_linker_lock);\n    return f;\n}\n\n/*\n** Return the address of the function 'raw_name' in the library 'lib'\n*/\nPR_IMPLEMENT(PRFuncPtr) \nPR_FindFunctionSymbol(PRLibrary *lib, const char *raw_name)\n{\n    return ((PRFuncPtr) PR_FindSymbol(lib, raw_name));\n}\n\nPR_IMPLEMENT(void*) \nPR_FindSymbolAndLibrary(const char *raw_name, PRLibrary* *lib)\n{\n    void *f = NULL;\n#if defined(NEED_LEADING_UNDERSCORE)\n    char *name;\n#else\n    const char *name;\n#endif\n    PRLibrary* lm;\n\n    if (!_pr_initialized) _PR_ImplicitInitialization();\n    /*\n    ** Mangle the raw symbol name in any way that is platform specific.\n    */\n#if defined(NEED_LEADING_UNDERSCORE)\n    /* Need a leading _ */\n    name = PR_smprintf(\"_%s\", raw_name);\n#elif defined(AIX)\n    /*\n    ** AIX with the normal linker put's a \".\" in front of the symbol\n    ** name.  When use \"svcc\" and \"svld\" then the \".\" disappears. Go\n    ** figure.\n    */\n    name = raw_name;\n#else\n    name = raw_name;\n#endif\n\n    PR_EnterMonitor(pr_linker_lock);\n\n    /* search all libraries */\n    for (lm = pr_loadmap; lm != NULL; lm = lm->next) {\n        f = pr_FindSymbolInLib(lm, name);\n        if (f != NULL) {\n            *lib = lm;\n            lm->refCount++;\n            PR_LOG(_pr_linker_lm, PR_LOG_MIN,\n                       (\"%s incr => %d (for %s)\",\n                    lm->name, lm->refCount, name));\n            break;\n        }\n    }\n#if defined(NEED_LEADING_UNDERSCORE)\n    PR_smprintf_free(name);\n#endif\n\n    PR_ExitMonitor(pr_linker_lock);\n    return f;\n}\n\nPR_IMPLEMENT(PRFuncPtr) \nPR_FindFunctionSymbolAndLibrary(const char *raw_name, PRLibrary* *lib)\n{\n    return ((PRFuncPtr) PR_FindSymbolAndLibrary(raw_name, lib));\n}\n\n/*\n** Add a static library to the list of loaded libraries. If LoadLibrary\n** is called with the name then we will pretend it was already loaded\n*/\nPR_IMPLEMENT(PRLibrary*) \nPR_LoadStaticLibrary(const char *name, const PRStaticLinkTable *slt)\n{\n    PRLibrary *lm=NULL;\n    PRLibrary* result = NULL;\n\n    if (!_pr_initialized) _PR_ImplicitInitialization();\n\n    /* See if library is already loaded */\n    PR_EnterMonitor(pr_linker_lock);\n\n    /* If the lbrary is already loaded, then add the static table information... */\n    result = pr_UnlockedFindLibrary(name);\n    if (result != NULL) {\n        PR_ASSERT( (result->staticTable == NULL) || (result->staticTable == slt) );\n        result->staticTable = slt;\n        goto unlock;\n    }\n\n    /* Add library to list...Mark it static */\n    lm = PR_NEWZAP(PRLibrary);\n    if (lm == NULL) goto unlock;\n\n    lm->name = strdup(name);\n    lm->refCount    = 1;\n    lm->dlh         = pr_exe_loadmap ? pr_exe_loadmap->dlh : 0;\n    lm->staticTable = slt;\n    lm->next        = pr_loadmap;\n    pr_loadmap      = lm;\n\n    result = lm;    /* success */\n    PR_ASSERT(lm->refCount == 1);\n    PR_LOG(_pr_linker_lm, PR_LOG_MIN, (\"Loaded library %s (static lib)\", lm->name));\n  unlock:\n    PR_ExitMonitor(pr_linker_lock);\n    return result;\n}\n\nPR_IMPLEMENT(char *)\nPR_GetLibraryFilePathname(const char *name, PRFuncPtr addr)\n{\n#if defined(USE_DLFCN) && defined(HAVE_DLADDR)\n    Dl_info dli;\n    char *result;\n\n    if (dladdr((void *)addr, &dli) == 0) {\n        PR_SetError(PR_LIBRARY_NOT_LOADED_ERROR, _MD_ERRNO());\n        DLLErrorInternal(_MD_ERRNO());\n        return NULL;\n    }\n    result = PR_Malloc(strlen(dli.dli_fname)+1);\n    if (result != NULL) {\n        strcpy(result, dli.dli_fname);\n    }\n    return result;\n#elif defined(USE_MACH_DYLD)\n    char *result;\n    const char *image_name;\n    int i, count = _dyld_image_count();\n\n    for (i = 0; i < count; i++) {\n        image_name = _dyld_get_image_name(i);\n        if (strstr(image_name, name) != NULL) {\n            result = PR_Malloc(strlen(image_name)+1);\n            if (result != NULL) {\n                strcpy(result, image_name);\n            }\n            return result;\n        }\n    }\n    PR_SetError(PR_LIBRARY_NOT_LOADED_ERROR, 0);\n    return NULL;\n#elif defined(AIX)\n    char *result;\n#define LD_INFO_INCREMENT 64\n    struct ld_info *info;\n    unsigned int info_length = LD_INFO_INCREMENT * sizeof(struct ld_info);\n    struct ld_info *infop;\n    int loadflags = L_GETINFO | L_IGNOREUNLOAD;\n\n    for (;;) {\n        info = PR_Malloc(info_length);\n        if (info == NULL) {\n            return NULL;\n        }\n        /* If buffer is too small, loadquery fails with ENOMEM. */\n        if (loadquery(loadflags, info, info_length) != -1) {\n            break;\n        }\n        /*\n         * Calling loadquery when compiled for 64-bit with the\n         * L_IGNOREUNLOAD flag can cause an invalid argument error\n         * on AIX 5.1. Detect this error the first time that\n         * loadquery is called, and try calling it again without\n         * this flag set.\n         */\n        if (errno == EINVAL && (loadflags & L_IGNOREUNLOAD)) {\n            loadflags &= ~L_IGNOREUNLOAD;\n            if (loadquery(loadflags, info, info_length) != -1) {\n                break;\n            }\n        }\n        PR_Free(info);\n        if (errno != ENOMEM) {\n            /* should not happen */\n            _PR_MD_MAP_DEFAULT_ERROR(_MD_ERRNO());\n            return NULL;\n        }\n        /* retry with a larger buffer */\n        info_length += LD_INFO_INCREMENT * sizeof(struct ld_info);\n    }\n\n    for (infop = info;\n         ;\n         infop = (struct ld_info *)((char *)infop + infop->ldinfo_next)) {\n        unsigned long start = (unsigned long)infop->ldinfo_dataorg;\n        unsigned long end = start + infop->ldinfo_datasize;\n        if (start <= (unsigned long)addr && end > (unsigned long)addr) {\n            result = PR_Malloc(strlen(infop->ldinfo_filename)+1);\n            if (result != NULL) {\n                strcpy(result, infop->ldinfo_filename);\n            }\n            break;\n        }\n        if (!infop->ldinfo_next) {\n            PR_SetError(PR_LIBRARY_NOT_LOADED_ERROR, 0);\n            result = NULL;\n            break;\n        }\n    }\n    PR_Free(info);\n    return result;\n#elif defined(OSF1)\n    /* Contributed by Steve Streeter of HP */\n    ldr_process_t process, ldr_my_process();\n    ldr_module_t mod_id;\n    ldr_module_info_t info;\n    ldr_region_t regno;\n    ldr_region_info_t reginfo;\n    size_t retsize;\n    int rv;\n    char *result;\n\n    /* Get process for which dynamic modules will be listed */\n\n    process = ldr_my_process();\n\n    /* Attach to process */\n\n    rv = ldr_xattach(process);\n    if (rv) {\n        /* should not happen */\n        _PR_MD_MAP_DEFAULT_ERROR(_MD_ERRNO());\n        return NULL;\n    }\n\n    /* Print information for list of modules */\n\n    mod_id = LDR_NULL_MODULE;\n\n    for (;;) {\n\n        /* Get information for the next module in the module list. */\n\n        ldr_next_module(process, &mod_id);\n        if (ldr_inq_module(process, mod_id, &info, sizeof(info),\n                           &retsize) != 0) {\n            /* No more modules */\n            break;\n        }\n        if (retsize < sizeof(info)) {\n            continue;\n        }\n\n        /*\n         * Get information for each region in the module and check if any\n         * contain the address of this function.\n         */\n\n        for (regno = 0; ; regno++) {\n            if (ldr_inq_region(process, mod_id, regno, &reginfo,\n                               sizeof(reginfo), &retsize) != 0) {\n                /* No more regions */\n                break;\n            }\n            if (((unsigned long)reginfo.lri_mapaddr <=\n                (unsigned long)addr) &&\n                (((unsigned long)reginfo.lri_mapaddr + reginfo.lri_size) >\n                (unsigned long)addr)) {\n                /* Found it. */\n                result = PR_Malloc(strlen(info.lmi_name)+1);\n                if (result != NULL) {\n                    strcpy(result, info.lmi_name);\n                }\n                return result;\n            }\n        }\n    }\n    PR_SetError(PR_LIBRARY_NOT_LOADED_ERROR, 0);\n    return NULL;\n#elif defined(HPUX) && defined(USE_HPSHL)\n    int index;\n    struct shl_descriptor desc;\n    char *result;\n\n    for (index = 0; shl_get_r(index, &desc) == 0; index++) {\n        if (strstr(desc.filename, name) != NULL) {\n            result = PR_Malloc(strlen(desc.filename)+1);\n            if (result != NULL) {\n                strcpy(result, desc.filename);\n            }\n            return result;\n        }\n    }\n    /*\n     * Since the index value of a library is decremented if\n     * a library preceding it in the shared library search\n     * list was unloaded, it is possible that we missed some\n     * libraries as we went up the list.  So we should go\n     * down the list to be sure that we not miss anything.\n     */\n    for (index--; index >= 0; index--) {\n        if ((shl_get_r(index, &desc) == 0)\n                && (strstr(desc.filename, name) != NULL)) {\n            result = PR_Malloc(strlen(desc.filename)+1);\n            if (result != NULL) {\n                strcpy(result, desc.filename);\n            }\n            return result;\n        }\n    }\n    PR_SetError(PR_LIBRARY_NOT_LOADED_ERROR, 0);\n    return NULL;\n#elif defined(HPUX) && defined(USE_DLFCN)\n    struct load_module_desc desc;\n    char *result;\n    const char *module_name;\n\n    if (dlmodinfo((unsigned long)addr, &desc, sizeof desc, NULL, 0, 0) == 0) {\n        PR_SetError(PR_LIBRARY_NOT_LOADED_ERROR, _MD_ERRNO());\n        DLLErrorInternal(_MD_ERRNO());\n        return NULL;\n    }\n    module_name = dlgetname(&desc, sizeof desc, NULL, 0, 0);\n    if (module_name == NULL) {\n        /* should not happen */\n        _PR_MD_MAP_DEFAULT_ERROR(_MD_ERRNO());\n        DLLErrorInternal(_MD_ERRNO());\n        return NULL;\n    }\n    result = PR_Malloc(strlen(module_name)+1);\n    if (result != NULL) {\n        strcpy(result, module_name);\n    }\n    return result;\n#elif defined(WIN32)\n    PRUnichar wname[MAX_PATH];\n    HMODULE handle = NULL;\n    PRUnichar module_name[MAX_PATH];\n    int len;\n    char *result;\n\n    if (MultiByteToWideChar(CP_ACP, 0, name, -1, wname, MAX_PATH)) {\n        handle = GetModuleHandleW(wname);\n    }\n    if (handle == NULL) {\n        PR_SetError(PR_LIBRARY_NOT_LOADED_ERROR, _MD_ERRNO());\n        DLLErrorInternal(_MD_ERRNO());\n        return NULL;\n    }\n    if (GetModuleFileNameW(handle, module_name, MAX_PATH) == 0) {\n        /* should not happen */\n        _PR_MD_MAP_DEFAULT_ERROR(_MD_ERRNO());\n        return NULL;\n    }\n    len = WideCharToMultiByte(CP_ACP, 0, module_name, -1,\n                              NULL, 0, NULL, NULL);\n    if (len == 0) {\n        _PR_MD_MAP_DEFAULT_ERROR(_MD_ERRNO());\n        return NULL;\n    }\n    result = PR_Malloc(len * sizeof(PRUnichar));\n    if (result != NULL) {\n        WideCharToMultiByte(CP_ACP, 0, module_name, -1,\n                            result, len, NULL, NULL);\n    }\n    return result;\n#elif defined(XP_OS2)\n    HMODULE module = NULL;\n    char module_name[_MAX_PATH];\n    char *result;\n    APIRET ulrc = DosQueryModFromEIP(&module, NULL, 0, NULL, NULL, (ULONG) addr);\n    if ((NO_ERROR != ulrc) || (NULL == module) ) {\n        PR_SetError(PR_LIBRARY_NOT_LOADED_ERROR, _MD_ERRNO());\n        DLLErrorInternal(_MD_ERRNO());\n        return NULL;\n    }\n    ulrc = DosQueryModuleName(module, sizeof module_name, module_name);\n    if (NO_ERROR != ulrc) {\n        /* should not happen */\n        _PR_MD_MAP_DEFAULT_ERROR(_MD_ERRNO());\n        return NULL;\n    }\n    result = PR_Malloc(strlen(module_name)+1);\n    if (result != NULL) {\n        strcpy(result, module_name);\n    }\n    return result;\n#else\n    PR_SetError(PR_NOT_IMPLEMENTED_ERROR, 0);\n    return NULL;\n#endif\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-nspr-4.13.1-vntc7ai7kqzc4riwwqstomskyuugrvqz/spack-src/nspr/pr/src/malloc/prmem.c": "/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n/*\n** Thread safe versions of malloc, free, realloc, calloc and cfree.\n*/\n\n#include \"primpl.h\"\n\n#ifdef _PR_ZONE_ALLOCATOR\n\n/*\n** The zone allocator code must use native mutexes and cannot\n** use PRLocks because PR_NewLock calls PR_Calloc, resulting\n** in cyclic dependency of initialization.\n*/\n\n#include <string.h>\t\n\nunion memBlkHdrUn;\n\ntypedef struct MemoryZoneStr {\n    union memBlkHdrUn    *head;         /* free list */\n    pthread_mutex_t       lock;\n    size_t                blockSize;    /* size of blocks on this free list */\n    PRUint32              locked;       /* current state of lock */\n    PRUint32              contention;   /* counter: had to wait for lock */\n    PRUint32              hits;         /* allocated from free list */\n    PRUint32              misses;       /* had to call malloc */\n    PRUint32              elements;     /* on free list */\n} MemoryZone;\n\ntypedef union memBlkHdrUn {\n    unsigned char filler[48];  /* fix the size of this beast */\n    struct memBlkHdrStr {\n        union memBlkHdrUn    *next;\n        MemoryZone           *zone;\n        size_t                blockSize;\n        size_t                requestedSize;\n        PRUint32              magic;\n    } s;\n} MemBlockHdr;\n\n#define MEM_ZONES     7\n#define THREAD_POOLS 11  /* prime number for modulus */\n#define ZONE_MAGIC  0x0BADC0DE\n\nstatic MemoryZone zones[MEM_ZONES][THREAD_POOLS];\n\nstatic PRBool use_zone_allocator = PR_FALSE;\n\nstatic void pr_ZoneFree(void *ptr);\n\nvoid\n_PR_DestroyZones(void)\n{   \n    int i, j;\n\n    if (!use_zone_allocator)\n        return;\n    \n    for (j = 0; j < THREAD_POOLS; j++) {\n        for (i = 0; i < MEM_ZONES; i++) {\n            MemoryZone *mz = &zones[i][j];\n            pthread_mutex_destroy(&mz->lock);\n            while (mz->head) {\n                MemBlockHdr *hdr = mz->head;\n                mz->head = hdr->s.next;  /* unlink it */\n                free(hdr);\n                mz->elements--;\n            }\n        }\n    } \n    use_zone_allocator = PR_FALSE;\n} \n\n/*\n** pr_FindSymbolInProg\n**\n** Find the specified data symbol in the program and return\n** its address.\n*/\n\n#ifdef HAVE_DLL\n\n#if defined(USE_DLFCN) && !defined(NO_DLOPEN_NULL)\n\n#include <dlfcn.h>\n\nstatic void *\npr_FindSymbolInProg(const char *name)\n{\n    void *h;\n    void *sym;\n\n    h = dlopen(0, RTLD_LAZY);\n    if (h == NULL)\n        return NULL;\n    sym = dlsym(h, name);\n    (void)dlclose(h);\n    return sym;\n}\n\n#elif defined(USE_HPSHL)\n\n#include <dl.h>\n\nstatic void *\npr_FindSymbolInProg(const char *name)\n{\n    shl_t h = NULL;\n    void *sym;\n\n    if (shl_findsym(&h, name, TYPE_DATA, &sym) == -1)\n        return NULL;\n    return sym;\n}\n\n#elif defined(USE_MACH_DYLD) || defined(NO_DLOPEN_NULL)\n\nstatic void *\npr_FindSymbolInProg(const char *name)\n{\n    /* FIXME: not implemented */\n    return NULL;\n}\n\n#else\n\n#error \"The zone allocator is not supported on this platform\"\n\n#endif\n\n#else /* !defined(HAVE_DLL) */\n\nstatic void *\npr_FindSymbolInProg(const char *name)\n{\n    /* can't be implemented */\n    return NULL;\n}\n\n#endif /* HAVE_DLL */\n\nvoid\n_PR_InitZones(void)\n{\n    int i, j;\n    char *envp;\n    PRBool *sym;\n\n    if ((sym = (PRBool *)pr_FindSymbolInProg(\"nspr_use_zone_allocator\")) != NULL) {\n        use_zone_allocator = *sym;\n    } else if ((envp = getenv(\"NSPR_USE_ZONE_ALLOCATOR\")) != NULL) {\n        use_zone_allocator = (atoi(envp) == 1);\n    }\n\n    if (!use_zone_allocator)\n        return;\n\n    for (j = 0; j < THREAD_POOLS; j++) { \n        for (i = 0; i < MEM_ZONES; i++) {\n            MemoryZone *mz = &zones[i][j];\n            int rv = pthread_mutex_init(&mz->lock, NULL);\n            PR_ASSERT(0 == rv);\n            if (rv != 0) {\n                goto loser;\n            } \n            mz->blockSize = 16 << ( 2 * i);\n        }\n    }\n    return;\n\nloser:\n    _PR_DestroyZones();\n    return;\n}\n\nPR_IMPLEMENT(void)\nPR_FPrintZoneStats(PRFileDesc *debug_out)\n{\n    int i, j;\n\n    for (j = 0; j < THREAD_POOLS; j++) {\n        for (i = 0; i < MEM_ZONES; i++) {\n            MemoryZone   *mz   = &zones[i][j];\n            MemoryZone    zone = *mz;\n            if (zone.elements || zone.misses || zone.hits) {\n                PR_fprintf(debug_out,\n\"pool: %d, zone: %d, size: %d, free: %d, hit: %d, miss: %d, contend: %d\\n\",\n                    j, i, zone.blockSize, zone.elements,\n                    zone.hits, zone.misses, zone.contention);\n            }\n\t}\n    }\n}\n\nstatic void *\npr_ZoneMalloc(PRUint32 size)\n{\n    void         *rv;\n    unsigned int  zone;\n    size_t        blockSize;\n    MemBlockHdr  *mb, *mt;\n    MemoryZone   *mz;\n\n    /* Always allocate a non-zero amount of bytes */\n    if (size < 1) {\n        size = 1;\n    }\n    for (zone = 0, blockSize = 16; zone < MEM_ZONES; ++zone, blockSize <<= 2) {\n        if (size <= blockSize) {\n            break;\n        }\n    }\n    if (zone < MEM_ZONES) {\n        pthread_t me = pthread_self();\n        unsigned int pool = (PRUptrdiff)me % THREAD_POOLS;\n        PRUint32     wasLocked;\n        mz = &zones[zone][pool];\n        wasLocked = mz->locked;\n        pthread_mutex_lock(&mz->lock);\n        mz->locked = 1;\n        if (wasLocked)\n            mz->contention++;\n        if (mz->head) {\n            mb = mz->head;\n            PR_ASSERT(mb->s.magic == ZONE_MAGIC);\n            PR_ASSERT(mb->s.zone  == mz);\n            PR_ASSERT(mb->s.blockSize == blockSize);\n            PR_ASSERT(mz->blockSize == blockSize);\n\n            mt = (MemBlockHdr *)(((char *)(mb + 1)) + blockSize);\n            PR_ASSERT(mt->s.magic == ZONE_MAGIC);\n            PR_ASSERT(mt->s.zone  == mz);\n            PR_ASSERT(mt->s.blockSize == blockSize);\n\n            mz->hits++;\n            mz->elements--;\n            mz->head = mb->s.next;    /* take off free list */\n            mz->locked = 0;\n            pthread_mutex_unlock(&mz->lock);\n\n            mt->s.next          = mb->s.next          = NULL;\n            mt->s.requestedSize = mb->s.requestedSize = size;\n\n            rv = (void *)(mb + 1);\n            return rv;\n        }\n\n        mz->misses++;\n        mz->locked = 0;\n        pthread_mutex_unlock(&mz->lock);\n\n        mb = (MemBlockHdr *)malloc(blockSize + 2 * (sizeof *mb));\n        if (!mb) {\n            PR_SetError(PR_OUT_OF_MEMORY_ERROR, 0);\n            return NULL;\n        }\n        mb->s.next          = NULL;\n        mb->s.zone          = mz;\n        mb->s.magic         = ZONE_MAGIC;\n        mb->s.blockSize     = blockSize;\n        mb->s.requestedSize = size;\n\n        mt = (MemBlockHdr *)(((char *)(mb + 1)) + blockSize);\n        memcpy(mt, mb, sizeof *mb);\n\n        rv = (void *)(mb + 1);\n        return rv;\n    }\n\n    /* size was too big.  Create a block with no zone */\n    blockSize = (size & 15) ? size + 16 - (size & 15) : size;\n    mb = (MemBlockHdr *)malloc(blockSize + 2 * (sizeof *mb));\n    if (!mb) {\n        PR_SetError(PR_OUT_OF_MEMORY_ERROR, 0);\n        return NULL;\n    }\n    mb->s.next          = NULL;\n    mb->s.zone          = NULL;\n    mb->s.magic         = ZONE_MAGIC;\n    mb->s.blockSize     = blockSize;\n    mb->s.requestedSize = size;\n\n    mt = (MemBlockHdr *)(((char *)(mb + 1)) + blockSize);\n    memcpy(mt, mb, sizeof *mb);\n\n    rv = (void *)(mb + 1);\n    return rv;\n}\n\n\nstatic void *\npr_ZoneCalloc(PRUint32 nelem, PRUint32 elsize)\n{\n    PRUint32 size = nelem * elsize;\n    void *p = pr_ZoneMalloc(size);\n    if (p) {\n        memset(p, 0, size);\n    }\n    return p;\n}\n\nstatic void *\npr_ZoneRealloc(void *oldptr, PRUint32 bytes)\n{\n    void         *rv;\n    MemBlockHdr  *mb;\n    int           ours;\n    MemBlockHdr   phony;\n\n    if (!oldptr)\n        return pr_ZoneMalloc(bytes);\n    mb = (MemBlockHdr *)((char *)oldptr - (sizeof *mb));\n    if (mb->s.magic != ZONE_MAGIC) {\n        /* Maybe this just came from ordinary malloc */\n#ifdef DEBUG\n        fprintf(stderr,\n            \"Warning: reallocing memory block %p from ordinary malloc\\n\",\n            oldptr);\n#endif\n        /*\n         * We are going to realloc oldptr.  If realloc succeeds, the\n         * original value of oldptr will point to freed memory.  So this\n         * function must not fail after a successfull realloc call.  We\n         * must perform any operation that may fail before the realloc\n         * call.\n         */\n        rv = pr_ZoneMalloc(bytes);  /* this may fail */\n        if (!rv) {\n            return rv;\n        }\n\n        /* We don't know how big it is.  But we can fix that. */\n        oldptr = realloc(oldptr, bytes);\n        /*\n         * If realloc returns NULL, this function loses the original\n         * value of oldptr.  This isn't a leak because the caller of\n         * this function still has the original value of oldptr.\n         */\n        if (!oldptr) {\n            if (bytes) {\n                PR_SetError(PR_OUT_OF_MEMORY_ERROR, 0);\n                pr_ZoneFree(rv);\n                return oldptr;\n            }\n        }\n        phony.s.requestedSize = bytes;\n        mb = &phony;\n        ours = 0;\n    } else {\n        size_t blockSize = mb->s.blockSize;\n        MemBlockHdr *mt = (MemBlockHdr *)(((char *)(mb + 1)) + blockSize);\n\n        PR_ASSERT(mt->s.magic == ZONE_MAGIC);\n        PR_ASSERT(mt->s.zone  == mb->s.zone);\n        PR_ASSERT(mt->s.blockSize == blockSize);\n\t\n        if (bytes <= blockSize) {\n            /* The block is already big enough. */\n            mt->s.requestedSize = mb->s.requestedSize = bytes;\n            return oldptr;\n        }\n        ours = 1;\n        rv = pr_ZoneMalloc(bytes);\n        if (!rv) {\n            return rv;\n        }\n    }\n    \n    if (oldptr && mb->s.requestedSize)\n        memcpy(rv, oldptr, mb->s.requestedSize);\n    if (ours)\n        pr_ZoneFree(oldptr);\n    else if (oldptr)\n        free(oldptr);\n    return rv;\n}\n\nstatic void\npr_ZoneFree(void *ptr)\n{\n    MemBlockHdr  *mb, *mt;\n    MemoryZone   *mz;\n    size_t        blockSize;\n    PRUint32      wasLocked;\n\n    if (!ptr)\n        return;\n\n    mb = (MemBlockHdr *)((char *)ptr - (sizeof *mb));\n\n    if (mb->s.magic != ZONE_MAGIC) {\n        /* maybe this came from ordinary malloc */\n#ifdef DEBUG\n        fprintf(stderr,\n            \"Warning: freeing memory block %p from ordinary malloc\\n\", ptr);\n#endif\n        free(ptr);\n        return;\n    }\n\n    blockSize = mb->s.blockSize;\n    mz        = mb->s.zone;\n    mt = (MemBlockHdr *)(((char *)(mb + 1)) + blockSize);\n    PR_ASSERT(mt->s.magic == ZONE_MAGIC);\n    PR_ASSERT(mt->s.zone  == mz);\n    PR_ASSERT(mt->s.blockSize == blockSize);\n    if (!mz) {\n        PR_ASSERT(blockSize > 65536);\n        /* This block was not in any zone.  Just free it. */\n        free(mb);\n        return;\n    }\n    PR_ASSERT(mz->blockSize == blockSize);\n    wasLocked = mz->locked;\n    pthread_mutex_lock(&mz->lock);\n    mz->locked = 1;\n    if (wasLocked)\n        mz->contention++;\n    mt->s.next = mb->s.next = mz->head;        /* put on head of list */\n    mz->head = mb;\n    mz->elements++;\n    mz->locked = 0;\n    pthread_mutex_unlock(&mz->lock);\n}\n\nPR_IMPLEMENT(void *) PR_Malloc(PRUint32 size)\n{\n    if (!_pr_initialized) _PR_ImplicitInitialization();\n\n    return use_zone_allocator ? pr_ZoneMalloc(size) : malloc(size);\n}\n\nPR_IMPLEMENT(void *) PR_Calloc(PRUint32 nelem, PRUint32 elsize)\n{\n    if (!_pr_initialized) _PR_ImplicitInitialization();\n\n    return use_zone_allocator ?\n        pr_ZoneCalloc(nelem, elsize) : calloc(nelem, elsize);\n}\n\nPR_IMPLEMENT(void *) PR_Realloc(void *ptr, PRUint32 size)\n{\n    if (!_pr_initialized) _PR_ImplicitInitialization();\n\n    return use_zone_allocator ? pr_ZoneRealloc(ptr, size) : realloc(ptr, size);\n}\n\nPR_IMPLEMENT(void) PR_Free(void *ptr)\n{\n    if (use_zone_allocator)\n        pr_ZoneFree(ptr);\n    else\n        free(ptr);\n}\n\n#else /* !defined(_PR_ZONE_ALLOCATOR) */\n\n/*\n** The PR_Malloc, PR_Calloc, PR_Realloc, and PR_Free functions simply\n** call their libc equivalents now.  This may seem redundant, but it\n** ensures that we are calling into the same runtime library.  On\n** Win32, it is possible to have multiple runtime libraries (e.g.,\n** objects compiled with /MD and /MDd) in the same process, and\n** they maintain separate heaps, which cannot be mixed.\n*/\nPR_IMPLEMENT(void *) PR_Malloc(PRUint32 size)\n{\n#if defined (WIN16)\n    return PR_MD_malloc( (size_t) size);\n#else\n    return malloc(size);\n#endif\n}\n\nPR_IMPLEMENT(void *) PR_Calloc(PRUint32 nelem, PRUint32 elsize)\n{\n#if defined (WIN16)\n    return PR_MD_calloc( (size_t)nelem, (size_t)elsize );\n    \n#else\n    return calloc(nelem, elsize);\n#endif\n}\n\nPR_IMPLEMENT(void *) PR_Realloc(void *ptr, PRUint32 size)\n{\n#if defined (WIN16)\n    return PR_MD_realloc( ptr, (size_t) size);\n#else\n    return realloc(ptr, size);\n#endif\n}\n\nPR_IMPLEMENT(void) PR_Free(void *ptr)\n{\n#if defined (WIN16)\n    PR_MD_free( ptr );\n#else\n    free(ptr);\n#endif\n}\n\n#endif /* _PR_ZONE_ALLOCATOR */\n\n/*\n** Complexity alert!\n**\n** If malloc/calloc/free (etc.) were implemented to use pr lock's then\n** the entry points could block when called if some other thread had the\n** lock.\n**\n** Most of the time this isn't a problem. However, in the case that we\n** are using the thread safe malloc code after PR_Init but before\n** PR_AttachThread has been called (on a native thread that nspr has yet\n** to be told about) we could get royally screwed if the lock was busy\n** and we tried to context switch the thread away. In this scenario\n** \tPR_CURRENT_THREAD() == NULL\n**\n** To avoid this unfortunate case, we use the low level locking\n** facilities for malloc protection instead of the slightly higher level\n** locking. This makes malloc somewhat faster so maybe it's a good thing\n** anyway.\n*/\n#ifdef _PR_OVERRIDE_MALLOC\n\n/* Imports */\nextern void *_PR_UnlockedMalloc(size_t size);\nextern void *_PR_UnlockedMemalign(size_t alignment, size_t size);\nextern void _PR_UnlockedFree(void *ptr);\nextern void *_PR_UnlockedRealloc(void *ptr, size_t size);\nextern void *_PR_UnlockedCalloc(size_t n, size_t elsize);\n\nstatic PRBool _PR_malloc_initialised = PR_FALSE;\n\n#ifdef _PR_PTHREADS\nstatic pthread_mutex_t _PR_MD_malloc_crustylock;\n\n#define _PR_Lock_Malloc() {\t\t\t\t\t\t\\\n    \t\t\t\tif(PR_TRUE == _PR_malloc_initialised) { \\\n\t\t\t\t\tPRStatus rv;\t\t\t\\\n\t\t\t\t\trv = pthread_mutex_lock(&_PR_MD_malloc_crustylock); \\\n\t\t\t\t\tPR_ASSERT(0 == rv);\t\t\\\n\t\t\t\t}\n\n#define _PR_Unlock_Malloc() \tif(PR_TRUE == _PR_malloc_initialised) { \\\n\t\t\t\t\tPRStatus rv;\t\t\t\\\n\t\t\t\t\trv = pthread_mutex_unlock(&_PR_MD_malloc_crustylock); \\\n\t\t\t\t\tPR_ASSERT(0 == rv);\t\t\\\n\t\t\t\t}\t\t\t\t\t\\\n\t\t\t  }\n#else /* _PR_PTHREADS */\nstatic _MDLock _PR_MD_malloc_crustylock;\n\n#ifdef IRIX\n#define _PR_Lock_Malloc() {\t\t\t\t\t\t\\\n\t\t\t   PRIntn _is;\t\t\t\t\t\\\n    \t\t\t\tif(PR_TRUE == _PR_malloc_initialised) { \\\n\t\t\t\tif (_PR_MD_GET_ATTACHED_THREAD() && \t\t\\\n\t\t\t\t\t!_PR_IS_NATIVE_THREAD( \t\t\\\n\t\t\t\t\t_PR_MD_GET_ATTACHED_THREAD()))\t\\\n\t\t\t\t\t\t_PR_INTSOFF(_is); \t\\\n\t\t\t\t\t_PR_MD_LOCK(&_PR_MD_malloc_crustylock); \\\n\t\t\t\t}\n\n#define _PR_Unlock_Malloc() \tif(PR_TRUE == _PR_malloc_initialised) { \\\n\t\t\t\t\t_PR_MD_UNLOCK(&_PR_MD_malloc_crustylock); \\\n\t\t\t\tif (_PR_MD_GET_ATTACHED_THREAD() && \t\t\\\n\t\t\t\t\t!_PR_IS_NATIVE_THREAD( \t\t\\\n\t\t\t\t\t_PR_MD_GET_ATTACHED_THREAD()))\t\\\n\t\t\t\t\t\t_PR_INTSON(_is);\t\\\n\t\t\t\t}\t\t\t\t\t\\\n\t\t\t  }\n#else\t/* IRIX */\n#define _PR_Lock_Malloc() {\t\t\t\t\t\t\\\n\t\t\t   PRIntn _is;\t\t\t\t\t\\\n    \t\t\t\tif(PR_TRUE == _PR_malloc_initialised) { \\\n\t\t\t\tif (_PR_MD_CURRENT_THREAD() && \t\t\\\n\t\t\t\t\t!_PR_IS_NATIVE_THREAD( \t\t\\\n\t\t\t\t\t_PR_MD_CURRENT_THREAD()))\t\\\n\t\t\t\t\t\t_PR_INTSOFF(_is); \t\\\n\t\t\t\t\t_PR_MD_LOCK(&_PR_MD_malloc_crustylock); \\\n\t\t\t\t}\n\n#define _PR_Unlock_Malloc() \tif(PR_TRUE == _PR_malloc_initialised) { \\\n\t\t\t\t\t_PR_MD_UNLOCK(&_PR_MD_malloc_crustylock); \\\n\t\t\t\tif (_PR_MD_CURRENT_THREAD() && \t\t\\\n\t\t\t\t\t!_PR_IS_NATIVE_THREAD( \t\t\\\n\t\t\t\t\t_PR_MD_CURRENT_THREAD()))\t\\\n\t\t\t\t\t\t_PR_INTSON(_is);\t\\\n\t\t\t\t}\t\t\t\t\t\\\n\t\t\t  }\n#endif\t/* IRIX\t*/\n#endif /* _PR_PTHREADS */\n\nPR_IMPLEMENT(PRStatus) _PR_MallocInit(void)\n{\n    PRStatus rv = PR_SUCCESS;\n\n    if( PR_TRUE == _PR_malloc_initialised ) return PR_SUCCESS;\n\n#ifdef _PR_PTHREADS\n    {\n\tint status;\n\tpthread_mutexattr_t mattr;\n\n\tstatus = _PT_PTHREAD_MUTEXATTR_INIT(&mattr);\n\tPR_ASSERT(0 == status);\n\tstatus = _PT_PTHREAD_MUTEX_INIT(_PR_MD_malloc_crustylock, mattr);\n\tPR_ASSERT(0 == status);\n\tstatus = _PT_PTHREAD_MUTEXATTR_DESTROY(&mattr);\n\tPR_ASSERT(0 == status);\n    }\n#else /* _PR_PTHREADS */\n    _MD_NEW_LOCK(&_PR_MD_malloc_crustylock);\n#endif /* _PR_PTHREADS */\n\n    if( PR_SUCCESS == rv )\n    {\n        _PR_malloc_initialised = PR_TRUE;\n    }\n\n    return rv;\n}\n\nvoid *malloc(size_t size)\n{\n    void *p;\n    _PR_Lock_Malloc();\n    p = _PR_UnlockedMalloc(size);\n    _PR_Unlock_Malloc();\n    return p;\n}\n\n#if defined(IRIX)\nvoid *memalign(size_t alignment, size_t size)\n{\n    void *p;\n    _PR_Lock_Malloc();\n    p = _PR_UnlockedMemalign(alignment, size);\n    _PR_Unlock_Malloc();\n    return p;\n}\n\nvoid *valloc(size_t size)\n{\n    return(memalign(sysconf(_SC_PAGESIZE),size));\n}\n#endif\t/* IRIX */\n\nvoid free(void *ptr)\n{\n    _PR_Lock_Malloc();\n    _PR_UnlockedFree(ptr);\n    _PR_Unlock_Malloc();\n}\n\nvoid *realloc(void *ptr, size_t size)\n{\n    void *p;\n    _PR_Lock_Malloc();\n    p = _PR_UnlockedRealloc(ptr, size);\n    _PR_Unlock_Malloc();\n    return p;\n}\n\nvoid *calloc(size_t n, size_t elsize)\n{\n    void *p;\n    _PR_Lock_Malloc();\n    p = _PR_UnlockedCalloc(n, elsize);\n    _PR_Unlock_Malloc();\n    return p;\n}\n\nvoid cfree(void *p)\n{\n    _PR_Lock_Malloc();\n    _PR_UnlockedFree(p);\n    _PR_Unlock_Malloc();\n}\n\nvoid _PR_InitMem(void)\n{\n    PRStatus rv;\n    rv = _PR_MallocInit();\n    PR_ASSERT(PR_SUCCESS == rv);\n}\n\n#endif /* _PR_OVERRIDE_MALLOC */\n",
        "/tmp/vanessa/spack-stage/spack-stage-nspr-4.13.1-vntc7ai7kqzc4riwwqstomskyuugrvqz/spack-src/nspr/pr/src/pthreads/ptio.c": "/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n/*\n** File:   ptio.c\n** Descritpion:  Implemenation of I/O methods for pthreads\n*/\n\n#if defined(_PR_PTHREADS)\n\n#if defined(_PR_POLL_WITH_SELECT)\n#if !(defined(HPUX) && defined(_USE_BIG_FDS))\n/* set fd limit for select(), before including system header files */\n#define FD_SETSIZE (16 * 1024)\n#endif\n#endif\n\n#include <pthread.h>\n#include <string.h>  /* for memset() */\n#include <sys/types.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/uio.h>\n#include <sys/file.h>\n#include <sys/ioctl.h>\n#if defined(DARWIN)\n#include <sys/utsname.h> /* for uname */\n#endif\n#if defined(SOLARIS) || defined(UNIXWARE)\n#include <sys/filio.h>  /* to pick up FIONREAD */\n#endif\n#ifdef _PR_POLL_AVAILABLE\n#include <poll.h>\n#endif\n#ifdef AIX\n/* To pick up sysconf() */\n#include <unistd.h>\n#include <dlfcn.h>  /* for dlopen */\n#else\n/* To pick up getrlimit() etc. */\n#include <sys/time.h>\n#include <sys/resource.h>\n#endif\n\n#ifdef SOLARIS\n/*\n * Define HAVE_SENDFILEV if the system has the sendfilev() system call.\n * Code built this way won't run on a system without sendfilev().\n * We can define HAVE_SENDFILEV by default when the minimum release\n * of Solaris that NSPR supports has sendfilev().\n */\n#ifdef HAVE_SENDFILEV\n\n#include <sys/sendfile.h>\n\n#define SOLARIS_SENDFILEV(a, b, c, d) sendfilev((a), (b), (c), (d))\n\n#else\n\n#include <dlfcn.h>  /* for dlopen */\n\n/*\n * Match the definitions in <sys/sendfile.h>.\n */\ntypedef struct sendfilevec {\n    int sfv_fd;       /* input fd */\n    uint_t sfv_flag;  /* flags */\n    off_t sfv_off;    /* offset to start reading from */\n    size_t sfv_len;   /* amount of data */\n} sendfilevec_t;\n\n#define SFV_FD_SELF (-2)\n\n/*\n * extern ssize_t sendfilev(int, const struct sendfilevec *, int, size_t *);\n */\nstatic ssize_t (*pt_solaris_sendfilev_fptr)() = NULL;\n\n#define SOLARIS_SENDFILEV(a, b, c, d) \\\n        (*pt_solaris_sendfilev_fptr)((a), (b), (c), (d))\n\n#endif /* HAVE_SENDFILEV */\n#endif /* SOLARIS */\n\n/*\n * The send_file() system call is available in AIX 4.3.2 or later.\n * If this file is compiled on an older AIX system, it attempts to\n * look up the send_file symbol at run time to determine whether\n * we can use the faster PR_SendFile/PR_TransmitFile implementation based on\n * send_file().  On AIX 4.3.2 or later, we can safely skip this\n * runtime function dispatching and just use the send_file based\n * implementation.\n */\n#ifdef AIX\n#ifdef SF_CLOSE\n#define HAVE_SEND_FILE\n#endif\n\n#ifdef HAVE_SEND_FILE\n\n#define AIX_SEND_FILE(a, b, c) send_file(a, b, c)\n\n#else /* HAVE_SEND_FILE */\n\n/*\n * The following definitions match those in <sys/socket.h>\n * on AIX 4.3.2.\n */\n\n/*\n * Structure for the send_file() system call\n */\nstruct sf_parms {\n    /* --------- header parms ---------- */\n    void      *header_data;         /* Input/Output. Points to header buf */\n    uint_t    header_length;        /* Input/Output. Length of the header */\n    /* --------- file parms ------------ */\n    int       file_descriptor;      /* Input. File descriptor of the file */\n    unsigned long long file_size;   /* Output. Size of the file */\n    unsigned long long file_offset; /* Input/Output. Starting offset */\n    long long file_bytes;           /* Input/Output. no. of bytes to send */\n    /* --------- trailer parms --------- */\n    void      *trailer_data;        /* Input/Output. Points to trailer buf */\n    uint_t    trailer_length;       /* Input/Output. Length of the trailer */\n    /* --------- return info ----------- */\n    unsigned long long bytes_sent;  /* Output. no. of bytes sent */\n};\n\n/*\n * Flags for the send_file() system call\n */\n#define SF_CLOSE        0x00000001      /* close the socket after completion */\n#define SF_REUSE        0x00000002      /* reuse socket. not supported */\n#define SF_DONT_CACHE   0x00000004      /* don't apply network buffer cache */\n#define SF_SYNC_CACHE   0x00000008      /* sync/update network buffer cache */\n\n/*\n * prototype: size_t send_file(int *, struct sf_parms *, uint_t);\n */\nstatic ssize_t (*pt_aix_sendfile_fptr)() = NULL;\n\n#define AIX_SEND_FILE(a, b, c) (*pt_aix_sendfile_fptr)(a, b, c)\n\n#endif /* HAVE_SEND_FILE */\n#endif /* AIX */\n\n#ifdef LINUX\n#include <sys/sendfile.h>\n#endif\n\n#include \"primpl.h\"\n\n#ifdef HAVE_NETINET_TCP_H\n#include <netinet/tcp.h>  /* TCP_NODELAY, TCP_MAXSEG */\n#endif\n\n#ifdef LINUX\n/* TCP_CORK is not defined in <netinet/tcp.h> on Red Hat Linux 6.0 */\n#ifndef TCP_CORK\n#define TCP_CORK 3\n#endif\n#endif\n\n#ifdef _PR_IPV6_V6ONLY_PROBE\nstatic PRBool _pr_ipv6_v6only_on_by_default;\n#endif\n\n#if (defined(HPUX) && !defined(HPUX10_30) && !defined(HPUX11))\n#define _PRSelectFdSetArg_t int *\n#elif defined(AIX4_1)\n#define _PRSelectFdSetArg_t void *\n#elif defined(IRIX) || (defined(AIX) && !defined(AIX4_1)) \\\n    || defined(OSF1) || defined(SOLARIS) \\\n    || defined(HPUX10_30) || defined(HPUX11) \\\n    || defined(LINUX) || defined(__GNU__) || defined(__GLIBC__) \\\n    || defined(FREEBSD) || defined(NETBSD) || defined(OPENBSD) \\\n    || defined(BSDI) || defined(NTO) || defined(DARWIN) \\\n    || defined(UNIXWARE) || defined(RISCOS) || defined(SYMBIAN)\n#define _PRSelectFdSetArg_t fd_set *\n#else\n#error \"Cannot determine architecture\"\n#endif\n\n#if defined(SOLARIS)            \n#ifndef PROTO_SDP\n/* on solaris, SDP is a new type of protocol */\n#define PROTO_SDP   257\n#endif \n#define _PR_HAVE_SDP\n#elif defined(LINUX)\n#ifndef AF_INET_SDP\n/* on linux, SDP is a new type of address family */\n#define AF_INET_SDP 27\n#endif\n#define _PR_HAVE_SDP\n#endif /* LINUX */\n\nstatic PRFileDesc *pt_SetMethods(\n    PRIntn osfd, PRDescType type, PRBool isAcceptedSocket, PRBool imported);\n\nstatic PRLock *_pr_flock_lock;  /* For PR_LockFile() etc. */\nstatic PRCondVar *_pr_flock_cv;  /* For PR_LockFile() etc. */\nstatic PRLock *_pr_rename_lock;  /* For PR_Rename() */\n\n/**************************************************************************/\n\n/* These two functions are only used in assertions. */\n#if defined(DEBUG)\n\nPRBool IsValidNetAddr(const PRNetAddr *addr)\n{\n    if ((addr != NULL)\n            && (addr->raw.family != AF_UNIX)\n            && (addr->raw.family != PR_AF_INET6)\n            && (addr->raw.family != AF_INET)) {\n        return PR_FALSE;\n    }\n    return PR_TRUE;\n}\n\nstatic PRBool IsValidNetAddrLen(const PRNetAddr *addr, PRInt32 addr_len)\n{\n    /*\n     * The definition of the length of a Unix domain socket address\n     * is not uniform, so we don't check it.\n     */\n    if ((addr != NULL)\n            && (addr->raw.family != AF_UNIX)\n            && (PR_NETADDR_SIZE(addr) != addr_len)) {\n#if defined(LINUX) && __GLIBC__ == 2 && __GLIBC_MINOR__ == 1\n        /*\n         * In glibc 2.1, struct sockaddr_in6 is 24 bytes.  In glibc 2.2\n         * and in the 2.4 kernel, struct sockaddr_in6 has the scope_id\n         * field and is 28 bytes.  It is possible for socket functions\n         * to return an addr_len greater than sizeof(struct sockaddr_in6).\n         * We need to allow that.  (Bugzilla bug #77264)\n         */\n        if ((PR_AF_INET6 == addr->raw.family)\n                && (sizeof(addr->ipv6) == addr_len)) {\n            return PR_TRUE;\n        }\n#endif\n        return PR_FALSE;\n    }\n    return PR_TRUE;\n}\n\n#endif /* DEBUG */\n\n/*****************************************************************************/\n/************************* I/O Continuation machinery ************************/\n/*****************************************************************************/\n\n/*\n * The polling interval defines the maximum amount of time that a thread\n * might hang up before an interrupt is noticed.\n */\n#define PT_DEFAULT_POLL_MSEC 5000\n#if defined(_PR_POLL_WITH_SELECT)\n#define PT_DEFAULT_SELECT_SEC (PT_DEFAULT_POLL_MSEC/PR_MSEC_PER_SEC)\n#define PT_DEFAULT_SELECT_USEC\t\t\t\t\t\t\t\\\n\t\t((PT_DEFAULT_POLL_MSEC % PR_MSEC_PER_SEC) * PR_USEC_PER_MSEC)\n#endif\n\n/*\n * pt_SockLen is the type for the length of a socket address\n * structure, used in the address length argument to bind,\n * connect, accept, getsockname, getpeername, etc.  Posix.1g\n * defines this type as socklen_t.  It is size_t or int on\n * most current systems.\n */\n#if defined(HAVE_SOCKLEN_T) \\\n    || (defined(__GLIBC__) && __GLIBC__ >= 2)\ntypedef socklen_t pt_SockLen;\n#elif (defined(AIX) && !defined(AIX4_1)) \ntypedef PRSize pt_SockLen;\n#else\ntypedef PRIntn pt_SockLen;\n#endif\n\ntypedef struct pt_Continuation pt_Continuation;\ntypedef PRBool (*ContinuationFn)(pt_Continuation *op, PRInt16 revents);\n\ntypedef enum pr_ContuationStatus\n{\n    pt_continuation_pending,\n    pt_continuation_done\n} pr_ContuationStatus;\n\nstruct pt_Continuation\n{\n    /* The building of the continuation operation */\n    ContinuationFn function;                /* what function to continue */\n    union { PRIntn osfd; } arg1;            /* #1 - the op's fd */\n    union { void* buffer; } arg2;           /* #2 - primary transfer buffer */\n    union {\n        PRSize amount;                      /* #3 - size of 'buffer', or */\n        pt_SockLen *addr_len;                  /*    - length of address */\n#ifdef HPUX11\n        /*\n         * For sendfile()\n         */\n\t\tstruct file_spec {\t\t\n        \toff_t offset;                       /* offset in file to send */\n        \tsize_t nbytes;                      /* length of file data to send */\n        \tsize_t st_size;                     /* file size */\n\t\t} file_spec;\n#endif\n    } arg3;\n    union { PRIntn flags; } arg4;           /* #4 - read/write flags */\n    union { PRNetAddr *addr; } arg5;        /* #5 - send/recv address */\n\n#ifdef HPUX11\n    /*\n     * For sendfile()\n     */\n    int filedesc;                           /* descriptor of file to send */\n    int nbytes_to_send;                     /* size of header and file */\n#endif  /* HPUX11 */\n    \n#ifdef SOLARIS\n    /*\n     * For sendfilev()\n     */\n    int nbytes_to_send;                     /* size of header and file */\n#endif  /* SOLARIS */\n\n#ifdef LINUX\n    /*\n     * For sendfile()\n     */\n    int in_fd;                              /* descriptor of file to send */\n    off_t offset;\n    size_t count;\n#endif  /* LINUX */\n \n    PRIntervalTime timeout;                 /* client (relative) timeout */\n\n    PRInt16 event;                           /* flags for poll()'s events */\n\n    /*\n    ** The representation and notification of the results of the operation.\n    ** These function can either return an int return code or a pointer to\n    ** some object.\n    */\n    union { PRSize code; void *object; } result;\n\n    PRIntn syserrno;                        /* in case it failed, why (errno) */\n    pr_ContuationStatus status;             /* the status of the operation */\n};\n\n#if defined(DEBUG)\n\nPTDebug pt_debug;  /* this is shared between several modules */\n\nPR_IMPLEMENT(void) PT_FPrintStats(PRFileDesc *debug_out, const char *msg)\n{\n    PTDebug stats;\n    char buffer[100];\n    PRExplodedTime tod;\n    PRInt64 elapsed, aMil;\n    stats = pt_debug;  /* a copy */\n    PR_ExplodeTime(stats.timeStarted, PR_LocalTimeParameters, &tod);\n    (void)PR_FormatTime(buffer, sizeof(buffer), \"%T\", &tod);\n\n    LL_SUB(elapsed, PR_Now(), stats.timeStarted);\n    LL_I2L(aMil, 1000000);\n    LL_DIV(elapsed, elapsed, aMil);\n    \n    if (NULL != msg) PR_fprintf(debug_out, \"%s\", msg);\n    PR_fprintf(\n        debug_out, \"\\tstarted: %s[%lld]\\n\", buffer, elapsed);\n    PR_fprintf(\n        debug_out, \"\\tlocks [created: %u, destroyed: %u]\\n\",\n        stats.locks_created, stats.locks_destroyed);\n    PR_fprintf(\n        debug_out, \"\\tlocks [acquired: %u, released: %u]\\n\",\n        stats.locks_acquired, stats.locks_released);\n    PR_fprintf(\n        debug_out, \"\\tcvars [created: %u, destroyed: %u]\\n\",\n        stats.cvars_created, stats.cvars_destroyed);\n    PR_fprintf(\n        debug_out, \"\\tcvars [notified: %u, delayed_delete: %u]\\n\",\n        stats.cvars_notified, stats.delayed_cv_deletes);\n}  /* PT_FPrintStats */\n\n#else\n\nPR_IMPLEMENT(void) PT_FPrintStats(PRFileDesc *debug_out, const char *msg)\n{\n    /* do nothing */\n}  /* PT_FPrintStats */\n\n#endif  /* DEBUG */\n\n#if defined(_PR_POLL_WITH_SELECT)\n/*\n * OSF1 and HPUX report the POLLHUP event for a socket when the\n * shutdown(SHUT_WR) operation is called for the remote end, even though\n * the socket is still writeable. Use select(), instead of poll(), to\n * workaround this problem.\n */\nstatic void pt_poll_now_with_select(pt_Continuation *op)\n{\n    PRInt32 msecs;\n\tfd_set rd, wr, *rdp, *wrp;\n\tstruct timeval tv;\n\tPRIntervalTime epoch, now, elapsed, remaining;\n\tPRBool wait_for_remaining;\n    PRThread *self = PR_GetCurrentThread();\n    \n\tPR_ASSERT(PR_INTERVAL_NO_WAIT != op->timeout);\n\tPR_ASSERT(op->arg1.osfd < FD_SETSIZE);\n\n    switch (op->timeout) {\n        case PR_INTERVAL_NO_TIMEOUT:\n\t\t\ttv.tv_sec = PT_DEFAULT_SELECT_SEC;\n\t\t\ttv.tv_usec = PT_DEFAULT_SELECT_USEC;\n\t\t\tdo\n\t\t\t{\n\t\t\t\tPRIntn rv;\n\n\t\t\t\tif (op->event & POLLIN) {\n\t\t\t\t\tFD_ZERO(&rd);\n\t\t\t\t\tFD_SET(op->arg1.osfd, &rd);\n\t\t\t\t\trdp = &rd;\n\t\t\t\t} else\n\t\t\t\t\trdp = NULL;\n\t\t\t\tif (op->event & POLLOUT) {\n\t\t\t\t\tFD_ZERO(&wr);\n\t\t\t\t\tFD_SET(op->arg1.osfd, &wr);\n\t\t\t\t\twrp = &wr;\n\t\t\t\t} else\n\t\t\t\t\twrp = NULL;\n\n\t\t\t\trv = select(op->arg1.osfd + 1, rdp, wrp, NULL, &tv);\n\n\t\t\t\tif (_PT_THREAD_INTERRUPTED(self))\n\t\t\t\t{\n\t\t\t\t\tself->state &= ~PT_THREAD_ABORTED;\n\t\t\t\t\top->result.code = -1;\n\t\t\t\t\top->syserrno = EINTR;\n\t\t\t\t\top->status = pt_continuation_done;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif ((-1 == rv) && ((errno == EINTR) || (errno == EAGAIN)))\n\t\t\t\t\tcontinue; /* go around the loop again */\n\n\t\t\t\tif (rv > 0)\n\t\t\t\t{\n\t\t\t\t\tPRInt16 revents = 0;\n\n\t\t\t\t\tif ((op->event & POLLIN) && FD_ISSET(op->arg1.osfd, &rd))\n\t\t\t\t\t\trevents |= POLLIN;\n\t\t\t\t\tif ((op->event & POLLOUT) && FD_ISSET(op->arg1.osfd, &wr))\n\t\t\t\t\t\trevents |= POLLOUT;\n\t\t\t\t\t\t\n\t\t\t\t\tif (op->function(op, revents))\n\t\t\t\t\t\top->status = pt_continuation_done;\n\t\t\t\t} else if (rv == -1) {\n\t\t\t\t\top->result.code = -1;\n\t\t\t\t\top->syserrno = errno;\n\t\t\t\t\top->status = pt_continuation_done;\n\t\t\t\t}\n\t\t\t\t/* else, select timed out */\n\t\t\t} while (pt_continuation_done != op->status);\n\t\t\tbreak;\n        default:\n            now = epoch = PR_IntervalNow();\n            remaining = op->timeout;\n\t\t\tdo\n\t\t\t{\n\t\t\t\tPRIntn rv;\n\n\t\t\t\tif (op->event & POLLIN) {\n\t\t\t\t\tFD_ZERO(&rd);\n\t\t\t\t\tFD_SET(op->arg1.osfd, &rd);\n\t\t\t\t\trdp = &rd;\n\t\t\t\t} else\n\t\t\t\t\trdp = NULL;\n\t\t\t\tif (op->event & POLLOUT) {\n\t\t\t\t\tFD_ZERO(&wr);\n\t\t\t\t\tFD_SET(op->arg1.osfd, &wr);\n\t\t\t\t\twrp = &wr;\n\t\t\t\t} else\n\t\t\t\t\twrp = NULL;\n\n    \t\t\twait_for_remaining = PR_TRUE;\n    \t\t\tmsecs = (PRInt32)PR_IntervalToMilliseconds(remaining);\n\t\t\t\tif (msecs > PT_DEFAULT_POLL_MSEC) {\n\t\t\t\t\twait_for_remaining = PR_FALSE;\n\t\t\t\t\tmsecs = PT_DEFAULT_POLL_MSEC;\n\t\t\t\t}\n\t\t\t\ttv.tv_sec = msecs/PR_MSEC_PER_SEC;\n\t\t\t\ttv.tv_usec = (msecs % PR_MSEC_PER_SEC) * PR_USEC_PER_MSEC;\n\t\t\t\trv = select(op->arg1.osfd + 1, rdp, wrp, NULL, &tv);\n\n\t\t\t\tif (_PT_THREAD_INTERRUPTED(self))\n\t\t\t\t{\n\t\t\t\t\tself->state &= ~PT_THREAD_ABORTED;\n\t\t\t\t\top->result.code = -1;\n\t\t\t\t\top->syserrno = EINTR;\n\t\t\t\t\top->status = pt_continuation_done;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (rv > 0) {\n\t\t\t\t\tPRInt16 revents = 0;\n\n\t\t\t\t\tif ((op->event & POLLIN) && FD_ISSET(op->arg1.osfd, &rd))\n\t\t\t\t\t\trevents |= POLLIN;\n\t\t\t\t\tif ((op->event & POLLOUT) && FD_ISSET(op->arg1.osfd, &wr))\n\t\t\t\t\t\trevents |= POLLOUT;\n\t\t\t\t\t\t\n\t\t\t\t\tif (op->function(op, revents))\n\t\t\t\t\t\top->status = pt_continuation_done;\n\n\t\t\t\t} else if ((rv == 0) ||\n\t\t\t\t\t\t((errno == EINTR) || (errno == EAGAIN))) {\n\t\t\t\t\tif (rv == 0) {\t/* select timed out */\n\t\t\t\t\t\tif (wait_for_remaining)\n\t\t\t\t\t\t\tnow += remaining;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tnow += PR_MillisecondsToInterval(msecs);\n\t\t\t\t\t} else\n\t\t\t\t\t\tnow = PR_IntervalNow();\n\t\t\t\t\telapsed = (PRIntervalTime) (now - epoch);\n\t\t\t\t\tif (elapsed >= op->timeout) {\n\t\t\t\t\t\top->result.code = -1;\n\t\t\t\t\t\top->syserrno = ETIMEDOUT;\n\t\t\t\t\t\top->status = pt_continuation_done;\n\t\t\t\t\t} else\n\t\t\t\t\t\tremaining = op->timeout - elapsed;\n\t\t\t\t} else {\n\t\t\t\t\top->result.code = -1;\n\t\t\t\t\top->syserrno = errno;\n\t\t\t\t\top->status = pt_continuation_done;\n\t\t\t\t}\n\t\t\t} while (pt_continuation_done != op->status);\n            break;\n    }\n\n}  /* pt_poll_now_with_select */\n\n#endif\t/* _PR_POLL_WITH_SELECT */\n\nstatic void pt_poll_now(pt_Continuation *op)\n{\n    PRInt32 msecs;\n\tPRIntervalTime epoch, now, elapsed, remaining;\n\tPRBool wait_for_remaining;\n    PRThread *self = PR_GetCurrentThread();\n    \n\tPR_ASSERT(PR_INTERVAL_NO_WAIT != op->timeout);\n#if defined (_PR_POLL_WITH_SELECT)\n\t/*\n \t * If the fd is small enough call the select-based poll operation\n\t */\n\tif (op->arg1.osfd < FD_SETSIZE) {\n\t\tpt_poll_now_with_select(op);\n\t\treturn;\n\t}\n#endif\n\n    switch (op->timeout) {\n        case PR_INTERVAL_NO_TIMEOUT:\n\t\t\tmsecs = PT_DEFAULT_POLL_MSEC;\n\t\t\tdo\n\t\t\t{\n\t\t\t\tPRIntn rv;\n\t\t\t\tstruct pollfd tmp_pfd;\n\n\t\t\t\ttmp_pfd.revents = 0;\n\t\t\t\ttmp_pfd.fd = op->arg1.osfd;\n\t\t\t\ttmp_pfd.events = op->event;\n\n\t\t\t\trv = poll(&tmp_pfd, 1, msecs);\n\t\t\t\t\n\t\t\t\tif (_PT_THREAD_INTERRUPTED(self))\n\t\t\t\t{\n\t\t\t\t\tself->state &= ~PT_THREAD_ABORTED;\n\t\t\t\t\top->result.code = -1;\n\t\t\t\t\top->syserrno = EINTR;\n\t\t\t\t\top->status = pt_continuation_done;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif ((-1 == rv) && ((errno == EINTR) || (errno == EAGAIN)))\n\t\t\t\t\tcontinue; /* go around the loop again */\n\n\t\t\t\tif (rv > 0)\n\t\t\t\t{\n\t\t\t\t\tPRInt16 events = tmp_pfd.events;\n\t\t\t\t\tPRInt16 revents = tmp_pfd.revents;\n\n\t\t\t\t\tif ((revents & POLLNVAL)  /* busted in all cases */\n\t\t\t\t\t|| ((events & POLLOUT) && (revents & POLLHUP)))\n\t\t\t\t\t\t/* write op & hup */\n\t\t\t\t\t{\n\t\t\t\t\t\top->result.code = -1;\n\t\t\t\t\t\tif (POLLNVAL & revents) op->syserrno = EBADF;\n\t\t\t\t\t\telse if (POLLHUP & revents) op->syserrno = EPIPE;\n\t\t\t\t\t\top->status = pt_continuation_done;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (op->function(op, revents))\n\t\t\t\t\t\t\top->status = pt_continuation_done;\n\t\t\t\t\t}\n\t\t\t\t} else if (rv == -1) {\n\t\t\t\t\top->result.code = -1;\n\t\t\t\t\top->syserrno = errno;\n\t\t\t\t\top->status = pt_continuation_done;\n\t\t\t\t}\n\t\t\t\t/* else, poll timed out */\n\t\t\t} while (pt_continuation_done != op->status);\n\t\t\tbreak;\n        default:\n            now = epoch = PR_IntervalNow();\n            remaining = op->timeout;\n\t\t\tdo\n\t\t\t{\n\t\t\t\tPRIntn rv;\n\t\t\t\tstruct pollfd tmp_pfd;\n\n\t\t\t\ttmp_pfd.revents = 0;\n\t\t\t\ttmp_pfd.fd = op->arg1.osfd;\n\t\t\t\ttmp_pfd.events = op->event;\n\n    \t\t\twait_for_remaining = PR_TRUE;\n    \t\t\tmsecs = (PRInt32)PR_IntervalToMilliseconds(remaining);\n\t\t\t\tif (msecs > PT_DEFAULT_POLL_MSEC)\n\t\t\t\t{\n\t\t\t\t\twait_for_remaining = PR_FALSE;\n\t\t\t\t\tmsecs = PT_DEFAULT_POLL_MSEC;\n\t\t\t\t}\n\t\t\t\trv = poll(&tmp_pfd, 1, msecs);\n\t\t\t\t\n\t\t\t\tif (_PT_THREAD_INTERRUPTED(self))\n\t\t\t\t{\n\t\t\t\t\tself->state &= ~PT_THREAD_ABORTED;\n\t\t\t\t\top->result.code = -1;\n\t\t\t\t\top->syserrno = EINTR;\n\t\t\t\t\top->status = pt_continuation_done;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (rv > 0)\n\t\t\t\t{\n\t\t\t\t\tPRInt16 events = tmp_pfd.events;\n\t\t\t\t\tPRInt16 revents = tmp_pfd.revents;\n\n\t\t\t\t\tif ((revents & POLLNVAL)  /* busted in all cases */\n\t\t\t\t\t\t|| ((events & POLLOUT) && (revents & POLLHUP))) \n\t\t\t\t\t\t\t\t\t\t\t/* write op & hup */\n\t\t\t\t\t{\n\t\t\t\t\t\top->result.code = -1;\n\t\t\t\t\t\tif (POLLNVAL & revents) op->syserrno = EBADF;\n\t\t\t\t\t\telse if (POLLHUP & revents) op->syserrno = EPIPE;\n\t\t\t\t\t\top->status = pt_continuation_done;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (op->function(op, revents))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\top->status = pt_continuation_done;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if ((rv == 0) ||\n\t\t\t\t\t\t((errno == EINTR) || (errno == EAGAIN))) {\n\t\t\t\t\tif (rv == 0)\t/* poll timed out */\n\t\t\t\t\t{\n\t\t\t\t\t\tif (wait_for_remaining)\n\t\t\t\t\t\t\tnow += remaining;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tnow += PR_MillisecondsToInterval(msecs);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tnow = PR_IntervalNow();\n\t\t\t\t\telapsed = (PRIntervalTime) (now - epoch);\n\t\t\t\t\tif (elapsed >= op->timeout) {\n\t\t\t\t\t\top->result.code = -1;\n\t\t\t\t\t\top->syserrno = ETIMEDOUT;\n\t\t\t\t\t\top->status = pt_continuation_done;\n\t\t\t\t\t} else\n\t\t\t\t\t\tremaining = op->timeout - elapsed;\n\t\t\t\t} else {\n\t\t\t\t\top->result.code = -1;\n\t\t\t\t\top->syserrno = errno;\n\t\t\t\t\top->status = pt_continuation_done;\n\t\t\t\t}\n\t\t\t} while (pt_continuation_done != op->status);\n            break;\n    }\n\n}  /* pt_poll_now */\n\nstatic PRIntn pt_Continue(pt_Continuation *op)\n{\n    op->status = pt_continuation_pending;  /* set default value */\n\t/*\n\t * let each thread call poll directly\n\t */\n\tpt_poll_now(op);\n\tPR_ASSERT(pt_continuation_done == op->status);\n    return op->result.code;\n}  /* pt_Continue */\n\n/*****************************************************************************/\n/*********************** specific continuation functions *********************/\n/*****************************************************************************/\nstatic PRBool pt_connect_cont(pt_Continuation *op, PRInt16 revents)\n{\n    op->syserrno = _MD_unix_get_nonblocking_connect_error(op->arg1.osfd);\n    if (op->syserrno != 0) {\n        op->result.code = -1;\n    } else {\n        op->result.code = 0;\n    }\n    return PR_TRUE; /* this one is cooked */\n}  /* pt_connect_cont */\n\nstatic PRBool pt_accept_cont(pt_Continuation *op, PRInt16 revents)\n{\n    op->syserrno = 0;\n    op->result.code = accept(\n        op->arg1.osfd, op->arg2.buffer, op->arg3.addr_len);\n    if (-1 == op->result.code)\n    {\n        op->syserrno = errno;\n        if (EWOULDBLOCK == errno || EAGAIN == errno || ECONNABORTED == errno)\n            return PR_FALSE;  /* do nothing - this one ain't finished */\n    }\n    return PR_TRUE;\n}  /* pt_accept_cont */\n\nstatic PRBool pt_read_cont(pt_Continuation *op, PRInt16 revents)\n{\n    /*\n     * Any number of bytes will complete the operation. It need\n     * not (and probably will not) satisfy the request. The only\n     * error we continue is EWOULDBLOCK|EAGAIN.\n     */\n    op->result.code = read(\n        op->arg1.osfd, op->arg2.buffer, op->arg3.amount);\n    op->syserrno = errno;\n    return ((-1 == op->result.code) && \n            (EWOULDBLOCK == op->syserrno || EAGAIN == op->syserrno)) ?\n        PR_FALSE : PR_TRUE;\n}  /* pt_read_cont */\n\nstatic PRBool pt_recv_cont(pt_Continuation *op, PRInt16 revents)\n{\n    /*\n     * Any number of bytes will complete the operation. It need\n     * not (and probably will not) satisfy the request. The only\n     * error we continue is EWOULDBLOCK|EAGAIN.\n     */\n#if defined(SOLARIS)\n    if (0 == op->arg4.flags)\n        op->result.code = read(\n            op->arg1.osfd, op->arg2.buffer, op->arg3.amount);\n    else\n        op->result.code = recv(\n            op->arg1.osfd, op->arg2.buffer, op->arg3.amount, op->arg4.flags);\n#else\n    op->result.code = recv(\n        op->arg1.osfd, op->arg2.buffer, op->arg3.amount, op->arg4.flags);\n#endif\n    op->syserrno = errno;\n    return ((-1 == op->result.code) && \n            (EWOULDBLOCK == op->syserrno || EAGAIN == op->syserrno)) ?\n        PR_FALSE : PR_TRUE;\n}  /* pt_recv_cont */\n\nstatic PRBool pt_send_cont(pt_Continuation *op, PRInt16 revents)\n{\n    PRIntn bytes;\n#if defined(SOLARIS)\n    PRInt32 tmp_amount = op->arg3.amount;\n#endif\n    /*\n     * We want to write the entire amount out, no matter how many\n     * tries it takes. Keep advancing the buffer and the decrementing\n     * the amount until the amount goes away. Return the total bytes\n     * (which should be the original amount) when finished (or an\n     * error).\n     */\n#if defined(SOLARIS)\nretry:\n    bytes = write(op->arg1.osfd, op->arg2.buffer, tmp_amount);\n#else\n    bytes = send(\n        op->arg1.osfd, op->arg2.buffer, op->arg3.amount, op->arg4.flags);\n#endif\n    op->syserrno = errno;\n\n#if defined(SOLARIS)\n    /*\n     * The write system call has been reported to return the ERANGE error\n     * on occasion. Try to write in smaller chunks to workaround this bug.\n     */\n    if ((bytes == -1) && (op->syserrno == ERANGE))\n    {\n        if (tmp_amount > 1)\n        {\n            tmp_amount = tmp_amount/2;  /* half the bytes */\n            goto retry;\n        }\n    }\n#endif\n\n    if (bytes >= 0)  /* this is progress */\n    {\n        char *bp = (char*)op->arg2.buffer;\n        bp += bytes;  /* adjust the buffer pointer */\n        op->arg2.buffer = bp;\n        op->result.code += bytes;  /* accumulate the number sent */\n        op->arg3.amount -= bytes;  /* and reduce the required count */\n        return (0 == op->arg3.amount) ? PR_TRUE : PR_FALSE;\n    }\n    else if ((EWOULDBLOCK != op->syserrno) && (EAGAIN != op->syserrno))\n    {\n        op->result.code = -1;\n        return PR_TRUE;\n    }\n    else return PR_FALSE;\n}  /* pt_send_cont */\n\nstatic PRBool pt_write_cont(pt_Continuation *op, PRInt16 revents)\n{\n    PRIntn bytes;\n    /*\n     * We want to write the entire amount out, no matter how many\n     * tries it takes. Keep advancing the buffer and the decrementing\n     * the amount until the amount goes away. Return the total bytes\n     * (which should be the original amount) when finished (or an\n     * error).\n     */\n    bytes = write(op->arg1.osfd, op->arg2.buffer, op->arg3.amount);\n    op->syserrno = errno;\n    if (bytes >= 0)  /* this is progress */\n    {\n        char *bp = (char*)op->arg2.buffer;\n        bp += bytes;  /* adjust the buffer pointer */\n        op->arg2.buffer = bp;\n        op->result.code += bytes;  /* accumulate the number sent */\n        op->arg3.amount -= bytes;  /* and reduce the required count */\n        return (0 == op->arg3.amount) ? PR_TRUE : PR_FALSE;\n    }\n    else if ((EWOULDBLOCK != op->syserrno) && (EAGAIN != op->syserrno))\n    {\n        op->result.code = -1;\n        return PR_TRUE;\n    }\n    else return PR_FALSE;\n}  /* pt_write_cont */\n\nstatic PRBool pt_writev_cont(pt_Continuation *op, PRInt16 revents)\n{\n    PRIntn bytes;\n    struct iovec *iov = (struct iovec*)op->arg2.buffer;\n    /*\n     * Same rules as write, but continuing seems to be a bit more\n     * complicated. As the number of bytes sent grows, we have to\n     * redefine the vector we're pointing at. We might have to\n     * modify an individual vector parms or we might have to eliminate\n     * a pair altogether.\n     */\n    bytes = writev(op->arg1.osfd, iov, op->arg3.amount);\n    op->syserrno = errno;\n    if (bytes >= 0)  /* this is progress */\n    {\n        PRIntn iov_index;\n        op->result.code += bytes;  /* accumulate the number sent */\n        for (iov_index = 0; iov_index < op->arg3.amount; ++iov_index)\n        {\n            /* how much progress did we make in the i/o vector? */\n            if (bytes < iov[iov_index].iov_len)\n            {\n                /* this element's not done yet */\n                char **bp = (char**)&(iov[iov_index].iov_base);\n                iov[iov_index].iov_len -= bytes;  /* there's that much left */\n                *bp += bytes;  /* starting there */\n                break;  /* go off and do that */\n            }\n            bytes -= iov[iov_index].iov_len;  /* that element's consumed */\n        }\n        op->arg2.buffer = &iov[iov_index];  /* new start of array */\n        op->arg3.amount -= iov_index;  /* and array length */\n        return (0 == op->arg3.amount) ? PR_TRUE : PR_FALSE;\n    }\n    else if ((EWOULDBLOCK != op->syserrno) && (EAGAIN != op->syserrno))\n    {\n        op->result.code = -1;\n        return PR_TRUE;\n    }\n    else return PR_FALSE;\n}  /* pt_writev_cont */\n\nstatic PRBool pt_sendto_cont(pt_Continuation *op, PRInt16 revents)\n{\n    PRIntn bytes = sendto(\n        op->arg1.osfd, op->arg2.buffer, op->arg3.amount, op->arg4.flags,\n        (struct sockaddr*)op->arg5.addr, PR_NETADDR_SIZE(op->arg5.addr));\n    op->syserrno = errno;\n    if (bytes >= 0)  /* this is progress */\n    {\n        char *bp = (char*)op->arg2.buffer;\n        bp += bytes;  /* adjust the buffer pointer */\n        op->arg2.buffer = bp;\n        op->result.code += bytes;  /* accumulate the number sent */\n        op->arg3.amount -= bytes;  /* and reduce the required count */\n        return (0 == op->arg3.amount) ? PR_TRUE : PR_FALSE;\n    }\n    else if ((EWOULDBLOCK != op->syserrno) && (EAGAIN != op->syserrno))\n    {\n        op->result.code = -1;\n        return PR_TRUE;\n    }\n    else return PR_FALSE;\n}  /* pt_sendto_cont */\n\nstatic PRBool pt_recvfrom_cont(pt_Continuation *op, PRInt16 revents)\n{\n    pt_SockLen addr_len = sizeof(PRNetAddr);\n    op->result.code = recvfrom(\n        op->arg1.osfd, op->arg2.buffer, op->arg3.amount,\n        op->arg4.flags, (struct sockaddr*)op->arg5.addr, &addr_len);\n    op->syserrno = errno;\n    return ((-1 == op->result.code) && \n            (EWOULDBLOCK == op->syserrno || EAGAIN == op->syserrno)) ?\n        PR_FALSE : PR_TRUE;\n}  /* pt_recvfrom_cont */\n\n#ifdef AIX\nstatic PRBool pt_aix_sendfile_cont(pt_Continuation *op, PRInt16 revents)\n{\n    struct sf_parms *sf_struct = (struct sf_parms *) op->arg2.buffer;\n    ssize_t rv;\n\tunsigned long long saved_file_offset;\n\tlong long saved_file_bytes;\n\n\tsaved_file_offset = sf_struct->file_offset;\n\tsaved_file_bytes = sf_struct->file_bytes;\n\tsf_struct->bytes_sent = 0;\n\n\tif ((sf_struct->file_bytes > 0) && (sf_struct->file_size > 0))\n\tPR_ASSERT((sf_struct->file_bytes + sf_struct->file_offset) <=\n\t\t\t\t\t\t\t\t\tsf_struct->file_size);\n    rv = AIX_SEND_FILE(&op->arg1.osfd, sf_struct, op->arg4.flags);\n    op->syserrno = errno;\n\n    if (rv != -1) {\n        op->result.code += sf_struct->bytes_sent;\n\t\t/*\n\t\t * A bug in AIX 4.3.2 prevents the 'file_bytes' field from\n\t\t * being updated. So, 'file_bytes' is maintained by NSPR to\n\t\t * avoid conflict when this bug is fixed in AIX, in the future.\n\t\t */\n\t\tif (saved_file_bytes != -1)\n\t\t\tsaved_file_bytes -= (sf_struct->file_offset - saved_file_offset);\n\t\tsf_struct->file_bytes = saved_file_bytes;\n    } else if (op->syserrno != EWOULDBLOCK && op->syserrno != EAGAIN) {\n        op->result.code = -1;\n    } else {\n        return PR_FALSE;\n    }\n\n    if (rv == 1) {    /* more data to send */\n        return PR_FALSE;\n    }\n\n    return PR_TRUE;\n}\n#endif  /* AIX */\n\n#ifdef HPUX11\nstatic PRBool pt_hpux_sendfile_cont(pt_Continuation *op, PRInt16 revents)\n{\n    struct iovec *hdtrl = (struct iovec *) op->arg2.buffer;\n    int count;\n\n    count = sendfile(op->arg1.osfd, op->filedesc, op->arg3.file_spec.offset,\n\t\t\top->arg3.file_spec.nbytes, hdtrl, op->arg4.flags);\n    PR_ASSERT(count <= op->nbytes_to_send);\n    op->syserrno = errno;\n\n    if (count != -1) {\n        op->result.code += count;\n    } else if (op->syserrno != EWOULDBLOCK && op->syserrno != EAGAIN) {\n        op->result.code = -1;\n    } else {\n        return PR_FALSE;\n    }\n    if (count != -1 && count < op->nbytes_to_send) {\n        if (count < hdtrl[0].iov_len) {\n\t\t\t/* header not sent */\n\n            hdtrl[0].iov_base = ((char *) hdtrl[0].iov_base) + count;\n            hdtrl[0].iov_len -= count;\n\n        } else if (count < (hdtrl[0].iov_len + op->arg3.file_spec.nbytes)) {\n\t\t\t/* header sent, file not sent */\n            PRUint32 file_nbytes_sent = count - hdtrl[0].iov_len;\n\n            hdtrl[0].iov_base = NULL;\n            hdtrl[0].iov_len = 0;\n\n            op->arg3.file_spec.offset += file_nbytes_sent;\n            op->arg3.file_spec.nbytes -= file_nbytes_sent;\n        } else if (count < (hdtrl[0].iov_len + op->arg3.file_spec.nbytes +\n\t\t\t\t\t\t\t\t\t\t\thdtrl[1].iov_len)) {\n            PRUint32 trailer_nbytes_sent = count - (hdtrl[0].iov_len +\n                                         op->arg3.file_spec.nbytes);\n\n\t\t\t/* header sent, file sent, trailer not sent */\n\n            hdtrl[0].iov_base = NULL;\n            hdtrl[0].iov_len = 0;\n\t\t\t/*\n\t\t\t * set file offset and len so that no more file data is\n\t\t\t * sent\n\t\t\t */\n            op->arg3.file_spec.offset = op->arg3.file_spec.st_size;\n            op->arg3.file_spec.nbytes = 0;\n\n            hdtrl[1].iov_base =((char *) hdtrl[1].iov_base)+ trailer_nbytes_sent;\n            hdtrl[1].iov_len -= trailer_nbytes_sent;\n\t\t}\n        op->nbytes_to_send -= count;\n        return PR_FALSE;\n    }\n\n    return PR_TRUE;\n}\n#endif  /* HPUX11 */\n\n#ifdef SOLARIS  \nstatic PRBool pt_solaris_sendfile_cont(pt_Continuation *op, PRInt16 revents)\n{\n    struct sendfilevec *vec = (struct sendfilevec *) op->arg2.buffer;\n    size_t xferred;\n    ssize_t count;\n\n    count = SOLARIS_SENDFILEV(op->arg1.osfd, vec, op->arg3.amount, &xferred);\n    op->syserrno = errno;\n    PR_ASSERT((count == -1) || (count == xferred));\n\n    if (count == -1) {\n        if (op->syserrno != EWOULDBLOCK && op->syserrno != EAGAIN\n                && op->syserrno != EINTR) {\n            op->result.code = -1;\n            return PR_TRUE;\n        }\n        count = xferred;\n    } else if (count == 0) {\n        /* \n         * We are now at EOF. The file was truncated. Solaris sendfile is\n         * supposed to return 0 and no error in this case, though some versions\n         * may return -1 and EINVAL .\n         */\n        op->result.code = -1;\n        op->syserrno = 0; /* will be treated as EOF */\n        return PR_TRUE;\n    }\n    PR_ASSERT(count <= op->nbytes_to_send);\n    \n    op->result.code += count;\n    if (count < op->nbytes_to_send) {\n        op->nbytes_to_send -= count;\n\n        while (count >= vec->sfv_len) {\n            count -= vec->sfv_len;\n            vec++;\n            op->arg3.amount--;\n        }\n        PR_ASSERT(op->arg3.amount > 0);\n\n        vec->sfv_off += count;\n        vec->sfv_len -= count;\n        PR_ASSERT(vec->sfv_len > 0);\n        op->arg2.buffer = vec;\n\n        return PR_FALSE;\n    }\n\n    return PR_TRUE;\n}\n#endif  /* SOLARIS */\n\n#ifdef LINUX \nstatic PRBool pt_linux_sendfile_cont(pt_Continuation *op, PRInt16 revents)\n{\n    ssize_t rv;\n    off_t oldoffset;\n\n    oldoffset = op->offset;\n    rv = sendfile(op->arg1.osfd, op->in_fd, &op->offset, op->count);\n    op->syserrno = errno;\n\n    if (rv == -1) {\n        if (op->syserrno != EWOULDBLOCK && op->syserrno != EAGAIN) {\n            op->result.code = -1;\n            return PR_TRUE;\n        }\n        rv = 0;\n    }\n    PR_ASSERT(rv == op->offset - oldoffset);\n    op->result.code += rv;\n    if (rv < op->count) {\n        op->count -= rv;\n        return PR_FALSE;\n    }\n    return PR_TRUE;\n}\n#endif  /* LINUX */\n\nvoid _PR_InitIO(void)\n{\n#if defined(DEBUG)\n    memset(&pt_debug, 0, sizeof(PTDebug));\n    pt_debug.timeStarted = PR_Now();\n#endif\n\n    _pr_flock_lock = PR_NewLock();\n    PR_ASSERT(NULL != _pr_flock_lock);\n    _pr_flock_cv = PR_NewCondVar(_pr_flock_lock);\n    PR_ASSERT(NULL != _pr_flock_cv);\n    _pr_rename_lock = PR_NewLock();\n    PR_ASSERT(NULL != _pr_rename_lock); \n\n    _PR_InitFdCache();  /* do that */   \n\n    _pr_stdin = pt_SetMethods(0, PR_DESC_FILE, PR_FALSE, PR_TRUE);\n    _pr_stdout = pt_SetMethods(1, PR_DESC_FILE, PR_FALSE, PR_TRUE);\n    _pr_stderr = pt_SetMethods(2, PR_DESC_FILE, PR_FALSE, PR_TRUE);\n    PR_ASSERT(_pr_stdin && _pr_stdout && _pr_stderr);\n\n#ifdef _PR_IPV6_V6ONLY_PROBE\n    /* In Mac OS X v10.3 Panther Beta the IPV6_V6ONLY socket option\n     * is turned on by default, contrary to what RFC 3493, Section\n     * 5.3 says.  So we have to turn it off.  Find out whether we\n     * are running on such a system.\n     */\n    {\n        int osfd;\n        osfd = socket(AF_INET6, SOCK_STREAM, 0);\n        if (osfd != -1) {\n            int on;\n            socklen_t optlen = sizeof(on);\n            if (getsockopt(osfd, IPPROTO_IPV6, IPV6_V6ONLY,\n                    &on, &optlen) == 0) {\n                _pr_ipv6_v6only_on_by_default = on;\n            }\n            close(osfd);\n        }\n    }\n#endif\n}  /* _PR_InitIO */\n\nvoid _PR_CleanupIO(void)\n{\n    _PR_Putfd(_pr_stdin);\n    _pr_stdin = NULL;\n    _PR_Putfd(_pr_stdout);\n    _pr_stdout = NULL;\n    _PR_Putfd(_pr_stderr); \n    _pr_stderr = NULL;\n\n    _PR_CleanupFdCache();\n    \n    if (_pr_flock_cv)\n    {\n        PR_DestroyCondVar(_pr_flock_cv);\n        _pr_flock_cv = NULL;\n    }\n    if (_pr_flock_lock)\n    {\n        PR_DestroyLock(_pr_flock_lock);\n        _pr_flock_lock = NULL;\n    }\n    if (_pr_rename_lock)\n    {\n        PR_DestroyLock(_pr_rename_lock);\n        _pr_rename_lock = NULL;\n    }\n}  /* _PR_CleanupIO */\n\nPR_IMPLEMENT(PRFileDesc*) PR_GetSpecialFD(PRSpecialFD osfd)\n{\n    PRFileDesc *result = NULL;\n    PR_ASSERT(osfd >= PR_StandardInput && osfd <= PR_StandardError);\n\n    if (!_pr_initialized) _PR_ImplicitInitialization();\n    \n    switch (osfd)\n    {\n        case PR_StandardInput: result = _pr_stdin; break;\n        case PR_StandardOutput: result = _pr_stdout; break;\n        case PR_StandardError: result = _pr_stderr; break;\n        default:\n            (void)PR_SetError(PR_INVALID_ARGUMENT_ERROR, 0);\n    }\n    return result;\n}  /* PR_GetSpecialFD */\n\n/*****************************************************************************/\n/***************************** I/O private methods ***************************/\n/*****************************************************************************/\n\nstatic PRBool pt_TestAbort(void)\n{\n    PRThread *me = PR_GetCurrentThread();\n    if(_PT_THREAD_INTERRUPTED(me))\n    {\n        PR_SetError(PR_PENDING_INTERRUPT_ERROR, 0);\n        me->state &= ~PT_THREAD_ABORTED;\n        return PR_TRUE;\n    }\n    return PR_FALSE;\n}  /* pt_TestAbort */\n\nstatic void pt_MapError(void (*mapper)(PRIntn), PRIntn syserrno)\n{\n    switch (syserrno)\n    {\n        case EINTR:\n            PR_SetError(PR_PENDING_INTERRUPT_ERROR, 0); break;\n        case ETIMEDOUT:\n            PR_SetError(PR_IO_TIMEOUT_ERROR, 0); break;\n        default:\n            mapper(syserrno);\n    }\n}  /* pt_MapError */\n\nstatic PRStatus pt_Close(PRFileDesc *fd)\n{\n    if ((NULL == fd) || (NULL == fd->secret)\n        || ((_PR_FILEDESC_OPEN != fd->secret->state)\n        && (_PR_FILEDESC_CLOSED != fd->secret->state)))\n    {\n        PR_SetError(PR_BAD_DESCRIPTOR_ERROR, 0);\n        return PR_FAILURE;\n    }\n    if (pt_TestAbort()) return PR_FAILURE;\n\n    if (_PR_FILEDESC_OPEN == fd->secret->state)\n    {\n        if (-1 == close(fd->secret->md.osfd))\n        {\n#ifdef OSF1\n            /*\n             * Bug 86941: On Tru64 UNIX V5.0A and V5.1, the close()\n             * system call, when called to close a TCP socket, may\n             * return -1 with errno set to EINVAL but the system call\n             * does close the socket successfully.  An application\n             * may safely ignore the EINVAL error.  This bug is fixed\n             * on Tru64 UNIX V5.1A and later.  The defect tracking\n             * number is QAR 81431.\n             */\n            if (PR_DESC_SOCKET_TCP != fd->methods->file_type\n            || EINVAL != errno)\n            {\n                pt_MapError(_PR_MD_MAP_CLOSE_ERROR, errno);\n                return PR_FAILURE;\n            }\n#else\n            pt_MapError(_PR_MD_MAP_CLOSE_ERROR, errno);\n            return PR_FAILURE;\n#endif\n        }\n        fd->secret->state = _PR_FILEDESC_CLOSED;\n    }\n    _PR_Putfd(fd);\n    return PR_SUCCESS;\n}  /* pt_Close */\n\nstatic PRInt32 pt_Read(PRFileDesc *fd, void *buf, PRInt32 amount)\n{\n    PRInt32 syserrno, bytes = -1;\n\n    if (pt_TestAbort()) return bytes;\n\n    bytes = read(fd->secret->md.osfd, buf, amount);\n    syserrno = errno;\n\n    if ((bytes == -1) && (syserrno == EWOULDBLOCK || syserrno == EAGAIN)\n        && (!fd->secret->nonblocking))\n    {\n        pt_Continuation op;\n        op.arg1.osfd = fd->secret->md.osfd;\n        op.arg2.buffer = buf;\n        op.arg3.amount = amount;\n        op.timeout = PR_INTERVAL_NO_TIMEOUT;\n        op.function = pt_read_cont;\n        op.event = POLLIN | POLLPRI;\n        bytes = pt_Continue(&op);\n        syserrno = op.syserrno;\n    }\n    if (bytes < 0)\n        pt_MapError(_PR_MD_MAP_READ_ERROR, syserrno);\n    return bytes;\n}  /* pt_Read */\n\nstatic PRInt32 pt_Write(PRFileDesc *fd, const void *buf, PRInt32 amount)\n{\n    PRInt32 syserrno, bytes = -1;\n    PRBool fNeedContinue = PR_FALSE;\n\n    if (pt_TestAbort()) return bytes;\n\n    bytes = write(fd->secret->md.osfd, buf, amount);\n    syserrno = errno;\n\n    if ( (bytes >= 0) && (bytes < amount) && (!fd->secret->nonblocking) )\n    {\n        buf = (char *) buf + bytes;\n        amount -= bytes;\n        fNeedContinue = PR_TRUE;\n    }\n    if ( (bytes == -1) && (syserrno == EWOULDBLOCK || syserrno == EAGAIN)\n        && (!fd->secret->nonblocking) )\n    {\n        bytes = 0;\n        fNeedContinue = PR_TRUE;\n    }\n\n    if (fNeedContinue == PR_TRUE)\n    {\n        pt_Continuation op;\n        op.arg1.osfd = fd->secret->md.osfd;\n        op.arg2.buffer = (void*)buf;\n        op.arg3.amount = amount;\n        op.timeout = PR_INTERVAL_NO_TIMEOUT;\n        op.result.code = bytes;  /* initialize the number sent */\n        op.function = pt_write_cont;\n        op.event = POLLOUT | POLLPRI;\n        bytes = pt_Continue(&op);\n        syserrno = op.syserrno;\n    }\n    if (bytes == -1)\n        pt_MapError(_PR_MD_MAP_WRITE_ERROR, syserrno);\n    return bytes;\n}  /* pt_Write */\n\nstatic PRInt32 pt_Writev(\n    PRFileDesc *fd, const PRIOVec *iov, PRInt32 iov_len, PRIntervalTime timeout)\n{\n    PRIntn iov_index;\n    PRBool fNeedContinue = PR_FALSE;\n    PRInt32 syserrno, bytes, rv = -1;\n    struct iovec osiov_local[PR_MAX_IOVECTOR_SIZE], *osiov;\n    int osiov_len;\n\n    if (pt_TestAbort()) return rv;\n\n    /* Ensured by PR_Writev */\n    PR_ASSERT(iov_len <= PR_MAX_IOVECTOR_SIZE);\n\n    /*\n     * We can't pass iov to writev because PRIOVec and struct iovec\n     * may not be binary compatible.  Make osiov a copy of iov and\n     * pass osiov to writev.  We can modify osiov if we need to\n     * continue the operation.\n     */\n    osiov = osiov_local;\n    osiov_len = iov_len;\n    for (iov_index = 0; iov_index < osiov_len; iov_index++)\n    {\n        osiov[iov_index].iov_base = iov[iov_index].iov_base;\n        osiov[iov_index].iov_len = iov[iov_index].iov_len;\n    }\n\n    rv = bytes = writev(fd->secret->md.osfd, osiov, osiov_len);\n    syserrno = errno;\n\n    if (!fd->secret->nonblocking)\n    {\n        if (bytes >= 0)\n        {\n            /*\n             * If we moved some bytes, how does that implicate the\n             * i/o vector list?  In other words, exactly where are\n             * we within that array?  What are the parameters for\n             * resumption?  Maybe we're done!\n             */\n            for ( ;osiov_len > 0; osiov++, osiov_len--)\n            {\n                if (bytes < osiov->iov_len)\n                {\n                    /* this one's not done yet */\n                    osiov->iov_base = (char*)osiov->iov_base + bytes;\n                    osiov->iov_len -= bytes;\n                    break;  /* go off and do that */\n                }\n                bytes -= osiov->iov_len;  /* this one's done cooked */\n            }\n            PR_ASSERT(osiov_len > 0 || bytes == 0);\n            if (osiov_len > 0)\n            {\n                if (PR_INTERVAL_NO_WAIT == timeout)\n                {\n                    rv = -1;\n                    syserrno = ETIMEDOUT;\n                }\n                else fNeedContinue = PR_TRUE;\n            }\n        }\n        else if (syserrno == EWOULDBLOCK || syserrno == EAGAIN)\n        {\n            if (PR_INTERVAL_NO_WAIT == timeout) syserrno = ETIMEDOUT;\n            else\n            {\n                rv = 0;\n                fNeedContinue = PR_TRUE;\n            }\n        }\n    }\n\n    if (fNeedContinue == PR_TRUE)\n    {\n        pt_Continuation op;\n\n        op.arg1.osfd = fd->secret->md.osfd;\n        op.arg2.buffer = (void*)osiov;\n        op.arg3.amount = osiov_len;\n        op.timeout = timeout;\n        op.result.code = rv;\n        op.function = pt_writev_cont;\n        op.event = POLLOUT | POLLPRI;\n        rv = pt_Continue(&op);\n        syserrno = op.syserrno;\n    }\n    if (rv == -1) pt_MapError(_PR_MD_MAP_WRITEV_ERROR, syserrno);\n    return rv;\n}  /* pt_Writev */\n\nstatic PRInt32 pt_Seek(PRFileDesc *fd, PRInt32 offset, PRSeekWhence whence)\n{\n    return _PR_MD_LSEEK(fd, offset, whence);\n}  /* pt_Seek */\n\nstatic PRInt64 pt_Seek64(PRFileDesc *fd, PRInt64 offset, PRSeekWhence whence)\n{\n    return _PR_MD_LSEEK64(fd, offset, whence);\n}  /* pt_Seek64 */\n\nstatic PRInt32 pt_Available_f(PRFileDesc *fd)\n{\n    PRInt32 result, cur, end;\n\n    cur = _PR_MD_LSEEK(fd, 0, PR_SEEK_CUR);\n\n    if (cur >= 0)\n        end = _PR_MD_LSEEK(fd, 0, PR_SEEK_END);\n\n    if ((cur < 0) || (end < 0)) {\n        return -1;\n    }\n\n    result = end - cur;\n    _PR_MD_LSEEK(fd, cur, PR_SEEK_SET);\n\n    return result;\n}  /* pt_Available_f */\n\nstatic PRInt64 pt_Available64_f(PRFileDesc *fd)\n{\n    PRInt64 result, cur, end;\n    PRInt64 minus_one;\n\n    LL_I2L(minus_one, -1);\n    cur = _PR_MD_LSEEK64(fd, LL_ZERO, PR_SEEK_CUR);\n\n    if (LL_GE_ZERO(cur))\n        end = _PR_MD_LSEEK64(fd, LL_ZERO, PR_SEEK_END);\n\n    if (!LL_GE_ZERO(cur) || !LL_GE_ZERO(end)) return minus_one;\n\n    LL_SUB(result, end, cur);\n    (void)_PR_MD_LSEEK64(fd, cur, PR_SEEK_SET);\n\n    return result;\n}  /* pt_Available64_f */\n\nstatic PRInt32 pt_Available_s(PRFileDesc *fd)\n{\n    PRInt32 rv, bytes = -1;\n    if (pt_TestAbort()) return bytes;\n\n    rv = ioctl(fd->secret->md.osfd, FIONREAD, &bytes);\n\n    if (rv == -1)\n        pt_MapError(_PR_MD_MAP_SOCKETAVAILABLE_ERROR, errno);\n    return bytes;\n}  /* pt_Available_s */\n\nstatic PRInt64 pt_Available64_s(PRFileDesc *fd)\n{\n    PRInt64 rv;\n    LL_I2L(rv, pt_Available_s(fd));\n    return rv;\n}  /* pt_Available64_s */\n\nstatic PRStatus pt_FileInfo(PRFileDesc *fd, PRFileInfo *info)\n{\n    PRInt32 rv = _PR_MD_GETOPENFILEINFO(fd, info);\n    return (-1 == rv) ? PR_FAILURE : PR_SUCCESS;\n}  /* pt_FileInfo */\n\nstatic PRStatus pt_FileInfo64(PRFileDesc *fd, PRFileInfo64 *info)\n{\n    PRInt32 rv = _PR_MD_GETOPENFILEINFO64(fd, info);\n    return (-1 == rv) ? PR_FAILURE : PR_SUCCESS;\n}  /* pt_FileInfo64 */\n\nstatic PRStatus pt_Synch(PRFileDesc *fd)\n{\n    return (NULL == fd) ? PR_FAILURE : PR_SUCCESS;\n} /* pt_Synch */\n\nstatic PRStatus pt_Fsync(PRFileDesc *fd)\n{\n    PRIntn rv = -1;\n    if (pt_TestAbort()) return PR_FAILURE;\n\n    rv = fsync(fd->secret->md.osfd);\n    if (rv < 0) {\n        pt_MapError(_PR_MD_MAP_FSYNC_ERROR, errno);\n        return PR_FAILURE;\n    }\n    return PR_SUCCESS;\n}  /* pt_Fsync */\n\nstatic PRStatus pt_Connect(\n    PRFileDesc *fd, const PRNetAddr *addr, PRIntervalTime timeout)\n{\n    PRIntn rv = -1, syserrno;\n    pt_SockLen addr_len;\n\tconst PRNetAddr *addrp = addr;\n#if defined(_PR_HAVE_SOCKADDR_LEN) || defined(_PR_INET6)\n\tPRUint16 md_af = addr->raw.family;\n    PRNetAddr addrCopy;\n#endif\n\n    if (pt_TestAbort()) return PR_FAILURE;\n\n    PR_ASSERT(IsValidNetAddr(addr) == PR_TRUE);\n    addr_len = PR_NETADDR_SIZE(addr);\n#if defined(_PR_INET6)\n\tif (addr->raw.family == PR_AF_INET6) {\n\t\tmd_af = AF_INET6;\n#ifndef _PR_HAVE_SOCKADDR_LEN\n\t\taddrCopy = *addr;\n\t\taddrCopy.raw.family = AF_INET6;\n\t\taddrp = &addrCopy;\n#endif\n\t}\n#endif\n\n#ifdef _PR_HAVE_SOCKADDR_LEN\n    addrCopy = *addr;\n    ((struct sockaddr*)&addrCopy)->sa_len = addr_len;\n    ((struct sockaddr*)&addrCopy)->sa_family = md_af;\n    addrp = &addrCopy;\n#endif\n    rv = connect(fd->secret->md.osfd, (struct sockaddr*)addrp, addr_len);\n    syserrno = errno;\n    if ((-1 == rv) && (EINPROGRESS == syserrno) && (!fd->secret->nonblocking))\n    {\n        if (PR_INTERVAL_NO_WAIT == timeout) syserrno = ETIMEDOUT;\n        else\n        {\n            pt_Continuation op;\n            op.arg1.osfd = fd->secret->md.osfd;\n            op.arg2.buffer = (void*)addrp;\n            op.arg3.amount = addr_len;\n            op.timeout = timeout;\n            op.function = pt_connect_cont;\n            op.event = POLLOUT | POLLPRI;\n            rv = pt_Continue(&op);\n            syserrno = op.syserrno;\n        }\n    }\n    if (-1 == rv) {\n        pt_MapError(_PR_MD_MAP_CONNECT_ERROR, syserrno);\n        return PR_FAILURE;\n    }\n    return PR_SUCCESS;\n}  /* pt_Connect */\n\nstatic PRStatus pt_ConnectContinue(\n    PRFileDesc *fd, PRInt16 out_flags)\n{\n    int err;\n    PRInt32 osfd;\n\n    if (out_flags & PR_POLL_NVAL)\n    {\n        PR_SetError(PR_BAD_DESCRIPTOR_ERROR, 0);\n        return PR_FAILURE;\n    }\n    if ((out_flags & (PR_POLL_WRITE | PR_POLL_EXCEPT | PR_POLL_ERR\n        | PR_POLL_HUP)) == 0)\n    {\n        PR_ASSERT(out_flags == 0);\n        PR_SetError(PR_IN_PROGRESS_ERROR, 0);\n        return PR_FAILURE;\n    }\n\n    osfd = fd->secret->md.osfd;\n\n    err = _MD_unix_get_nonblocking_connect_error(osfd);\n    if (err != 0)\n    {\n        _PR_MD_MAP_CONNECT_ERROR(err);\n        return PR_FAILURE;\n    }\n    return PR_SUCCESS;\n}  /* pt_ConnectContinue */\n\nPR_IMPLEMENT(PRStatus) PR_GetConnectStatus(const PRPollDesc *pd)\n{\n    /* Find the NSPR layer and invoke its connectcontinue method */\n    PRFileDesc *bottom = PR_GetIdentitiesLayer(pd->fd, PR_NSPR_IO_LAYER);\n\n    if (NULL == bottom)\n    {\n        PR_SetError(PR_INVALID_ARGUMENT_ERROR, 0);\n        return PR_FAILURE;\n    }\n    return pt_ConnectContinue(bottom, pd->out_flags);\n}  /* PR_GetConnectStatus */\n\nstatic PRFileDesc* pt_Accept(\n    PRFileDesc *fd, PRNetAddr *addr, PRIntervalTime timeout)\n{\n    PRFileDesc *newfd = NULL;\n    PRIntn syserrno, osfd = -1;\n    pt_SockLen addr_len = sizeof(PRNetAddr);\n#ifdef SYMBIAN\n    PRNetAddr dummy_addr;\n#endif\n\n    if (pt_TestAbort()) return newfd;\n\n#ifdef SYMBIAN\n    /* On Symbian OS, accept crashes if addr is NULL. */\n    if (!addr)\n        addr = &dummy_addr;\n#endif\n\n#ifdef _PR_STRICT_ADDR_LEN\n    if (addr)\n    {\n        /*\n         * Set addr->raw.family just so that we can use the\n         * PR_NETADDR_SIZE macro.\n         */\n        addr->raw.family = fd->secret->af;\n        addr_len = PR_NETADDR_SIZE(addr);\n    }\n#endif\n\n    osfd = accept(fd->secret->md.osfd, (struct sockaddr*)addr, &addr_len);\n    syserrno = errno;\n\n    if (osfd == -1)\n    {\n        if (fd->secret->nonblocking) goto failed;\n\n        if (EWOULDBLOCK != syserrno && EAGAIN != syserrno\n        && ECONNABORTED != syserrno)\n            goto failed;\n        else\n        {\n            if (PR_INTERVAL_NO_WAIT == timeout) syserrno = ETIMEDOUT;\n            else\n            {\n                pt_Continuation op;\n                op.arg1.osfd = fd->secret->md.osfd;\n                op.arg2.buffer = addr;\n                op.arg3.addr_len = &addr_len;\n                op.timeout = timeout;\n                op.function = pt_accept_cont;\n                op.event = POLLIN | POLLPRI;\n                osfd = pt_Continue(&op);\n                syserrno = op.syserrno;\n            }\n            if (osfd < 0) goto failed;\n        }\n    }\n#ifdef _PR_HAVE_SOCKADDR_LEN\n    /* ignore the sa_len field of struct sockaddr */\n    if (addr)\n    {\n        addr->raw.family = ((struct sockaddr*)addr)->sa_family;\n    }\n#endif /* _PR_HAVE_SOCKADDR_LEN */\n#ifdef _PR_INET6\n\tif (addr && (AF_INET6 == addr->raw.family))\n        addr->raw.family = PR_AF_INET6;\n#endif\n    newfd = pt_SetMethods(osfd, PR_DESC_SOCKET_TCP, PR_TRUE, PR_FALSE);\n    if (newfd == NULL) close(osfd);  /* $$$ whoops! this doesn't work $$$ */\n    else\n    {\n        PR_ASSERT(IsValidNetAddr(addr) == PR_TRUE);\n        PR_ASSERT(IsValidNetAddrLen(addr, addr_len) == PR_TRUE);\n#ifdef LINUX\n        /*\n         * On Linux, experiments showed that the accepted sockets\n         * inherit the TCP_NODELAY socket option of the listening\n         * socket.\n         */\n        newfd->secret->md.tcp_nodelay = fd->secret->md.tcp_nodelay;\n#endif\n    }\n    return newfd;\n\nfailed:\n    pt_MapError(_PR_MD_MAP_ACCEPT_ERROR, syserrno);\n    return NULL;\n}  /* pt_Accept */\n\nstatic PRStatus pt_Bind(PRFileDesc *fd, const PRNetAddr *addr)\n{\n    PRIntn rv;\n    pt_SockLen addr_len;\n\tconst PRNetAddr *addrp = addr;\n#if defined(_PR_HAVE_SOCKADDR_LEN) || defined(_PR_INET6)\n\tPRUint16 md_af = addr->raw.family;\n    PRNetAddr addrCopy;\n#endif\n\n    if (pt_TestAbort()) return PR_FAILURE;\n\n    PR_ASSERT(IsValidNetAddr(addr) == PR_TRUE);\n    if (addr->raw.family == AF_UNIX)\n    {\n        /* Disallow relative pathnames */\n        if (addr->local.path[0] != '/')\n        {\n            PR_SetError(PR_INVALID_ARGUMENT_ERROR, 0);\n            return PR_FAILURE;\n        }\n    }\n\n#if defined(_PR_INET6)\n\tif (addr->raw.family == PR_AF_INET6) {\n\t\tmd_af = AF_INET6;\n#ifndef _PR_HAVE_SOCKADDR_LEN\n\t\taddrCopy = *addr;\n\t\taddrCopy.raw.family = AF_INET6;\n\t\taddrp = &addrCopy;\n#endif\n\t}\n#endif\n\n    addr_len = PR_NETADDR_SIZE(addr);\n#ifdef _PR_HAVE_SOCKADDR_LEN\n    addrCopy = *addr;\n    ((struct sockaddr*)&addrCopy)->sa_len = addr_len;\n    ((struct sockaddr*)&addrCopy)->sa_family = md_af;\n    addrp = &addrCopy;\n#endif\n    rv = bind(fd->secret->md.osfd, (struct sockaddr*)addrp, addr_len);\n\n    if (rv == -1) {\n        pt_MapError(_PR_MD_MAP_BIND_ERROR, errno);\n        return PR_FAILURE;\n    }\n    return PR_SUCCESS;\n}  /* pt_Bind */\n\nstatic PRStatus pt_Listen(PRFileDesc *fd, PRIntn backlog)\n{\n    PRIntn rv;\n\n    if (pt_TestAbort()) return PR_FAILURE;\n\n    rv = listen(fd->secret->md.osfd, backlog);\n    if (rv == -1) {\n        pt_MapError(_PR_MD_MAP_LISTEN_ERROR, errno);\n        return PR_FAILURE;\n    }\n    return PR_SUCCESS;\n}  /* pt_Listen */\n\nstatic PRStatus pt_Shutdown(PRFileDesc *fd, PRIntn how)\n{\n    PRIntn rv = -1;\n    if (pt_TestAbort()) return PR_FAILURE;\n\n    rv = shutdown(fd->secret->md.osfd, how);\n\n    if (rv == -1) {\n        pt_MapError(_PR_MD_MAP_SHUTDOWN_ERROR, errno);\n        return PR_FAILURE;\n    }\n    return PR_SUCCESS;\n}  /* pt_Shutdown */\n\nstatic PRInt16 pt_Poll(PRFileDesc *fd, PRInt16 in_flags, PRInt16 *out_flags)\n{\n    *out_flags = 0;\n    return in_flags;\n}  /* pt_Poll */\n\nstatic PRInt32 pt_Recv(\n    PRFileDesc *fd, void *buf, PRInt32 amount,\n    PRIntn flags, PRIntervalTime timeout)\n{\n    PRInt32 syserrno, bytes = -1;\n    PRIntn osflags;\n\n    if (0 == flags)\n        osflags = 0;\n    else if (PR_MSG_PEEK == flags)\n    {\n#ifdef SYMBIAN\n        /* MSG_PEEK doesn't work as expected. */\n        PR_SetError(PR_NOT_IMPLEMENTED_ERROR, 0);\n        return bytes;\n#else\n        osflags = MSG_PEEK;\n#endif\n    }\n    else\n    {\n        PR_SetError(PR_INVALID_ARGUMENT_ERROR, 0);\n        return bytes;\n    }\n\n    if (pt_TestAbort()) return bytes;\n\n    /* recv() is a much slower call on pre-2.6 Solaris than read(). */\n#if defined(SOLARIS)\n    if (0 == osflags)\n        bytes = read(fd->secret->md.osfd, buf, amount);\n    else\n        bytes = recv(fd->secret->md.osfd, buf, amount, osflags);\n#else\n    bytes = recv(fd->secret->md.osfd, buf, amount, osflags);\n#endif\n    syserrno = errno;\n\n    if ((bytes == -1) && (syserrno == EWOULDBLOCK || syserrno == EAGAIN)\n        && (!fd->secret->nonblocking))\n    {\n        if (PR_INTERVAL_NO_WAIT == timeout) syserrno = ETIMEDOUT;\n        else\n        {\n            pt_Continuation op;\n            op.arg1.osfd = fd->secret->md.osfd;\n            op.arg2.buffer = buf;\n            op.arg3.amount = amount;\n            op.arg4.flags = osflags;\n            op.timeout = timeout;\n            op.function = pt_recv_cont;\n            op.event = POLLIN | POLLPRI;\n            bytes = pt_Continue(&op);\n            syserrno = op.syserrno;\n        }\n    }\n    if (bytes < 0)\n        pt_MapError(_PR_MD_MAP_RECV_ERROR, syserrno);\n    return bytes;\n}  /* pt_Recv */\n\nstatic PRInt32 pt_SocketRead(PRFileDesc *fd, void *buf, PRInt32 amount)\n{\n    return pt_Recv(fd, buf, amount, 0, PR_INTERVAL_NO_TIMEOUT);\n}  /* pt_SocketRead */\n\nstatic PRInt32 pt_Send(\n    PRFileDesc *fd, const void *buf, PRInt32 amount,\n    PRIntn flags, PRIntervalTime timeout)\n{\n    PRInt32 syserrno, bytes = -1;\n    PRBool fNeedContinue = PR_FALSE;\n#if defined(SOLARIS)\n\tPRInt32 tmp_amount = amount;\n#endif\n\n    /*\n     * Under HP-UX DCE threads, pthread.h includes dce/cma_ux.h,\n     * which has the following:\n     *     #  define send        cma_send\n     *     extern int  cma_send (int , void *, int, int );\n     * So we need to cast away the 'const' of argument #2 for send().\n     */\n#if defined (HPUX) && defined(_PR_DCETHREADS)\n#define PT_SENDBUF_CAST (void *)\n#else\n#define PT_SENDBUF_CAST\n#endif\n\n    if (pt_TestAbort()) return bytes;\n\n    /*\n     * On pre-2.6 Solaris, send() is much slower than write().\n     * On 2.6 and beyond, with in-kernel sockets, send() and\n     * write() are fairly equivalent in performance.\n     */\n#if defined(SOLARIS)\n    PR_ASSERT(0 == flags);\nretry:\n    bytes = write(fd->secret->md.osfd, PT_SENDBUF_CAST buf, tmp_amount);\n#else\n    bytes = send(fd->secret->md.osfd, PT_SENDBUF_CAST buf, amount, flags);\n#endif\n    syserrno = errno;\n\n#if defined(SOLARIS)\n    /*\n     * The write system call has been reported to return the ERANGE error\n     * on occasion. Try to write in smaller chunks to workaround this bug.\n     */\n    if ((bytes == -1) && (syserrno == ERANGE))\n    {\n        if (tmp_amount > 1)\n        {\n            tmp_amount = tmp_amount/2;  /* half the bytes */\n            goto retry;\n        }\n    }\n#endif\n\n    if ( (bytes >= 0) && (bytes < amount) && (!fd->secret->nonblocking) )\n    {\n        if (PR_INTERVAL_NO_WAIT == timeout)\n        {\n            bytes = -1;\n            syserrno = ETIMEDOUT;\n        }\n        else\n        {\n            buf = (char *) buf + bytes;\n            amount -= bytes;\n            fNeedContinue = PR_TRUE;\n        }\n    }\n    if ( (bytes == -1) && (syserrno == EWOULDBLOCK || syserrno == EAGAIN)\n        && (!fd->secret->nonblocking) )\n    {\n        if (PR_INTERVAL_NO_WAIT == timeout) syserrno = ETIMEDOUT;\n        else\n        {\n            bytes = 0;\n            fNeedContinue = PR_TRUE;\n        }\n    }\n\n    if (fNeedContinue == PR_TRUE)\n    {\n        pt_Continuation op;\n        op.arg1.osfd = fd->secret->md.osfd;\n        op.arg2.buffer = (void*)buf;\n        op.arg3.amount = amount;\n        op.arg4.flags = flags;\n        op.timeout = timeout;\n        op.result.code = bytes;  /* initialize the number sent */\n        op.function = pt_send_cont;\n        op.event = POLLOUT | POLLPRI;\n        bytes = pt_Continue(&op);\n        syserrno = op.syserrno;\n    }\n    if (bytes == -1)\n        pt_MapError(_PR_MD_MAP_SEND_ERROR, syserrno);\n    return bytes;\n}  /* pt_Send */\n\nstatic PRInt32 pt_SocketWrite(PRFileDesc *fd, const void *buf, PRInt32 amount)\n{\n    return pt_Send(fd, buf, amount, 0, PR_INTERVAL_NO_TIMEOUT);\n}  /* pt_SocketWrite */\n\nstatic PRInt32 pt_SendTo(\n    PRFileDesc *fd, const void *buf,\n    PRInt32 amount, PRIntn flags, const PRNetAddr *addr,\n    PRIntervalTime timeout)\n{\n    PRInt32 syserrno, bytes = -1;\n    PRBool fNeedContinue = PR_FALSE;\n    pt_SockLen addr_len;\n\tconst PRNetAddr *addrp = addr;\n#if defined(_PR_HAVE_SOCKADDR_LEN) || defined(_PR_INET6)\n\tPRUint16 md_af = addr->raw.family;\n    PRNetAddr addrCopy;\n#endif\n\n    if (pt_TestAbort()) return bytes;\n\n    PR_ASSERT(IsValidNetAddr(addr) == PR_TRUE);\n#if defined(_PR_INET6)\n\tif (addr->raw.family == PR_AF_INET6) {\n\t\tmd_af = AF_INET6;\n#ifndef _PR_HAVE_SOCKADDR_LEN\n\t\taddrCopy = *addr;\n\t\taddrCopy.raw.family = AF_INET6;\n\t\taddrp = &addrCopy;\n#endif\n\t}\n#endif\n\n    addr_len = PR_NETADDR_SIZE(addr);\n#ifdef _PR_HAVE_SOCKADDR_LEN\n    addrCopy = *addr;\n    ((struct sockaddr*)&addrCopy)->sa_len = addr_len;\n    ((struct sockaddr*)&addrCopy)->sa_family = md_af;\n    addrp = &addrCopy;\n#endif\n    bytes = sendto(\n        fd->secret->md.osfd, buf, amount, flags,\n        (struct sockaddr*)addrp, addr_len);\n    syserrno = errno;\n    if ( (bytes == -1) && (syserrno == EWOULDBLOCK || syserrno == EAGAIN)\n        && (!fd->secret->nonblocking) )\n    {\n        if (PR_INTERVAL_NO_WAIT == timeout) syserrno = ETIMEDOUT;\n        else fNeedContinue = PR_TRUE;\n    }\n    if (fNeedContinue == PR_TRUE)\n    {\n        pt_Continuation op;\n        op.arg1.osfd = fd->secret->md.osfd;\n        op.arg2.buffer = (void*)buf;\n        op.arg3.amount = amount;\n        op.arg4.flags = flags;\n        op.arg5.addr = (PRNetAddr*)addrp;\n        op.timeout = timeout;\n        op.result.code = 0;  /* initialize the number sent */\n        op.function = pt_sendto_cont;\n        op.event = POLLOUT | POLLPRI;\n        bytes = pt_Continue(&op);\n        syserrno = op.syserrno;\n    }\n    if (bytes < 0)\n        pt_MapError(_PR_MD_MAP_SENDTO_ERROR, syserrno);\n    return bytes;\n}  /* pt_SendTo */\n\nstatic PRInt32 pt_RecvFrom(PRFileDesc *fd, void *buf, PRInt32 amount,\n    PRIntn flags, PRNetAddr *addr, PRIntervalTime timeout)\n{\n    PRBool fNeedContinue = PR_FALSE;\n    PRInt32 syserrno, bytes = -1;\n    pt_SockLen addr_len = sizeof(PRNetAddr);\n\n    if (pt_TestAbort()) return bytes;\n\n    bytes = recvfrom(\n        fd->secret->md.osfd, buf, amount, flags,\n        (struct sockaddr*)addr, &addr_len);\n    syserrno = errno;\n\n    if ( (bytes == -1) && (syserrno == EWOULDBLOCK || syserrno == EAGAIN)\n        && (!fd->secret->nonblocking) )\n    {\n        if (PR_INTERVAL_NO_WAIT == timeout) syserrno = ETIMEDOUT;\n        else fNeedContinue = PR_TRUE;\n    }\n\n    if (fNeedContinue == PR_TRUE)\n    {\n        pt_Continuation op;\n        op.arg1.osfd = fd->secret->md.osfd;\n        op.arg2.buffer = buf;\n        op.arg3.amount = amount;\n        op.arg4.flags = flags;\n        op.arg5.addr = addr;\n        op.timeout = timeout;\n        op.function = pt_recvfrom_cont;\n        op.event = POLLIN | POLLPRI;\n        bytes = pt_Continue(&op);\n        syserrno = op.syserrno;\n    }\n    if (bytes >= 0)\n    {\n#ifdef _PR_HAVE_SOCKADDR_LEN\n        /* ignore the sa_len field of struct sockaddr */\n        if (addr)\n        {\n            addr->raw.family = ((struct sockaddr*)addr)->sa_family;\n        }\n#endif /* _PR_HAVE_SOCKADDR_LEN */\n#ifdef _PR_INET6\n        if (addr && (AF_INET6 == addr->raw.family))\n            addr->raw.family = PR_AF_INET6;\n#endif\n    }\n    else\n        pt_MapError(_PR_MD_MAP_RECVFROM_ERROR, syserrno);\n    return bytes;\n}  /* pt_RecvFrom */\n\n#ifdef AIX\n#ifndef HAVE_SEND_FILE\nstatic pthread_once_t pt_aix_sendfile_once_block = PTHREAD_ONCE_INIT;\n\nstatic void pt_aix_sendfile_init_routine(void)\n{\n    void *handle = dlopen(NULL, RTLD_NOW | RTLD_GLOBAL);\n    pt_aix_sendfile_fptr = (ssize_t (*)()) dlsym(handle, \"send_file\");\n    dlclose(handle);\n}\n\n/* \n * pt_AIXDispatchSendFile\n */\nstatic PRInt32 pt_AIXDispatchSendFile(PRFileDesc *sd, PRSendFileData *sfd,\n\t  PRTransmitFileFlags flags, PRIntervalTime timeout)\n{\n    int rv;\n\n    rv = pthread_once(&pt_aix_sendfile_once_block,\n            pt_aix_sendfile_init_routine);\n    PR_ASSERT(0 == rv);\n    if (pt_aix_sendfile_fptr) {\n        return pt_AIXSendFile(sd, sfd, flags, timeout);\n    } else {\n        return PR_EmulateSendFile(sd, sfd, flags, timeout);\n    }\n}\n#endif /* !HAVE_SEND_FILE */\n\n\n/*\n * pt_AIXSendFile\n *\n *    Send file sfd->fd across socket sd. If specified, header and trailer\n *    buffers are sent before and after the file, respectively. \n *\n *    PR_TRANSMITFILE_CLOSE_SOCKET flag - close socket after sending file\n *    \n *    return number of bytes sent or -1 on error\n *\n *      This implementation takes advantage of the send_file() system\n *      call available in AIX 4.3.2.\n */\n\nstatic PRInt32 pt_AIXSendFile(PRFileDesc *sd, PRSendFileData *sfd, \n\t\tPRTransmitFileFlags flags, PRIntervalTime timeout)\n{\n    struct sf_parms sf_struct;\n    uint_t send_flags;\n    ssize_t rv;\n    int syserrno;\n    PRInt32 count;\n\tunsigned long long saved_file_offset;\n\tlong long saved_file_bytes;\n\n    sf_struct.header_data = (void *) sfd->header;  /* cast away the 'const' */\n    sf_struct.header_length = sfd->hlen;\n    sf_struct.file_descriptor = sfd->fd->secret->md.osfd;\n    sf_struct.file_size = 0;\n    sf_struct.file_offset = sfd->file_offset;\n    if (sfd->file_nbytes == 0)\n    \tsf_struct.file_bytes = -1;\n\telse\n    \tsf_struct.file_bytes = sfd->file_nbytes;\n    sf_struct.trailer_data = (void *) sfd->trailer;\n    sf_struct.trailer_length = sfd->tlen;\n    sf_struct.bytes_sent = 0;\n\n\tsaved_file_offset = sf_struct.file_offset;\n    saved_file_bytes = sf_struct.file_bytes;\n\n    send_flags = 0;\t\t\t/* flags processed at the end */\n\n    /* The first argument to send_file() is int*. */\n    PR_ASSERT(sizeof(int) == sizeof(sd->secret->md.osfd));\n    do {\n        rv = AIX_SEND_FILE(&sd->secret->md.osfd, &sf_struct, send_flags);\n    } while (rv == -1 && (syserrno = errno) == EINTR);\n\n    if (rv == -1) {\n        if (syserrno == EAGAIN || syserrno == EWOULDBLOCK) {\n            count = 0; /* Not a real error.  Need to continue. */\n        } else {\n            count = -1;\n        }\n    } else {\n        count = sf_struct.bytes_sent;\n\t\t/*\n\t\t * A bug in AIX 4.3.2 prevents the 'file_bytes' field from\n\t\t * being updated. So, 'file_bytes' is maintained by NSPR to\n\t\t * avoid conflict when this bug is fixed in AIX, in the future.\n\t\t */\n\t\tif (saved_file_bytes != -1)\n\t\t\tsaved_file_bytes -= (sf_struct.file_offset - saved_file_offset);\n\t\tsf_struct.file_bytes = saved_file_bytes;\n    }\n\n    if ((rv == 1) || ((rv == -1) && (count == 0))) {\n        pt_Continuation op;\n\n        op.arg1.osfd = sd->secret->md.osfd;\n        op.arg2.buffer = &sf_struct;\n        op.arg4.flags = send_flags;\n        op.result.code = count;\n        op.timeout = timeout;\n        op.function = pt_aix_sendfile_cont;\n        op.event = POLLOUT | POLLPRI;\n        count = pt_Continue(&op);\n        syserrno = op.syserrno;\n    }\n\n    if (count == -1) {\n        pt_MapError(_MD_aix_map_sendfile_error, syserrno);\n        return -1;\n    }\n    if (flags & PR_TRANSMITFILE_CLOSE_SOCKET) {\n        PR_Close(sd);\n    }\n\tPR_ASSERT(count == (sfd->hlen + sfd->tlen +\n\t\t\t\t\t\t((sfd->file_nbytes ==  0) ?\n\t\t\t\t\t\tsf_struct.file_size - sfd->file_offset :\n\t\t\t\t\t\tsfd->file_nbytes)));\n    return count;\n}\n#endif /* AIX */\n\n#ifdef HPUX11\n/*\n * pt_HPUXSendFile\n *\n *    Send file sfd->fd across socket sd. If specified, header and trailer\n *    buffers are sent before and after the file, respectively.\n *\n *    PR_TRANSMITFILE_CLOSE_SOCKET flag - close socket after sending file\n *    \n *    return number of bytes sent or -1 on error\n *\n *      This implementation takes advantage of the sendfile() system\n *      call available in HP-UX B.11.00.\n */\n\nstatic PRInt32 pt_HPUXSendFile(PRFileDesc *sd, PRSendFileData *sfd, \n\t\tPRTransmitFileFlags flags, PRIntervalTime timeout)\n{\n    struct stat statbuf;\n    size_t nbytes_to_send, file_nbytes_to_send;\n    struct iovec hdtrl[2];  /* optional header and trailer buffers */\n    int send_flags;\n    PRInt32 count;\n    int syserrno;\n\n    if (sfd->file_nbytes == 0) {\n        /* Get file size */\n        if (fstat(sfd->fd->secret->md.osfd, &statbuf) == -1) {\n            _PR_MD_MAP_FSTAT_ERROR(errno);\n            return -1;\n        } \t\t\n        file_nbytes_to_send = statbuf.st_size - sfd->file_offset;\n    } else {\n        file_nbytes_to_send = sfd->file_nbytes;\n    }\n    nbytes_to_send = sfd->hlen + sfd->tlen + file_nbytes_to_send;\n\n    hdtrl[0].iov_base = (void *) sfd->header;  /* cast away the 'const' */\n    hdtrl[0].iov_len = sfd->hlen;\n    hdtrl[1].iov_base = (void *) sfd->trailer;\n    hdtrl[1].iov_len = sfd->tlen;\n    /*\n     * SF_DISCONNECT seems to close the socket even if sendfile()\n     * only does a partial send on a nonblocking socket.  This\n     * would prevent the subsequent sendfile() calls on that socket\n     * from working.  So we don't use the SD_DISCONNECT flag.\n     */\n    send_flags = 0;\n\n    do {\n        count = sendfile(sd->secret->md.osfd, sfd->fd->secret->md.osfd,\n                sfd->file_offset, file_nbytes_to_send, hdtrl, send_flags);\n    } while (count == -1 && (syserrno = errno) == EINTR);\n\n    if (count == -1 && (syserrno == EAGAIN || syserrno == EWOULDBLOCK)) {\n        count = 0;\n    }\n    if (count != -1 && count < nbytes_to_send) {\n        pt_Continuation op;\n\n        if (count < sfd->hlen) {\n\t\t\t/* header not sent */\n\n            hdtrl[0].iov_base = ((char *) sfd->header) + count;\n            hdtrl[0].iov_len = sfd->hlen - count;\n            op.arg3.file_spec.offset = sfd->file_offset;\n            op.arg3.file_spec.nbytes = file_nbytes_to_send;\n        } else if (count < (sfd->hlen + file_nbytes_to_send)) {\n\t\t\t/* header sent, file not sent */\n\n            hdtrl[0].iov_base = NULL;\n            hdtrl[0].iov_len = 0;\n\n            op.arg3.file_spec.offset = sfd->file_offset + count - sfd->hlen;\n            op.arg3.file_spec.nbytes = file_nbytes_to_send - (count - sfd->hlen);\n        } else if (count < (sfd->hlen + file_nbytes_to_send + sfd->tlen)) {\n\t\t\tPRUint32 trailer_nbytes_sent;\n\n\t\t\t/* header sent, file sent, trailer not sent */\n\n            hdtrl[0].iov_base = NULL;\n            hdtrl[0].iov_len = 0;\n\t\t\t/*\n\t\t\t * set file offset and len so that no more file data is\n\t\t\t * sent\n\t\t\t */\n            op.arg3.file_spec.offset = statbuf.st_size;\n            op.arg3.file_spec.nbytes = 0;\n\n\t\t\ttrailer_nbytes_sent = count - sfd->hlen - file_nbytes_to_send;\n            hdtrl[1].iov_base = ((char *) sfd->trailer) + trailer_nbytes_sent;\n            hdtrl[1].iov_len = sfd->tlen - trailer_nbytes_sent;\n\t\t}\n\n        op.arg1.osfd = sd->secret->md.osfd;\n        op.filedesc = sfd->fd->secret->md.osfd;\n        op.arg2.buffer = hdtrl;\n        op.arg3.file_spec.st_size = statbuf.st_size;\n        op.arg4.flags = send_flags;\n        op.nbytes_to_send = nbytes_to_send - count;\n        op.result.code = count;\n        op.timeout = timeout;\n        op.function = pt_hpux_sendfile_cont;\n        op.event = POLLOUT | POLLPRI;\n        count = pt_Continue(&op);\n        syserrno = op.syserrno;\n    }\n\n    if (count == -1) {\n        pt_MapError(_MD_hpux_map_sendfile_error, syserrno);\n        return -1;\n    }\n    if (flags & PR_TRANSMITFILE_CLOSE_SOCKET) {\n        PR_Close(sd);\n    }\n    PR_ASSERT(count == nbytes_to_send);\n    return count;\n}\n\n#endif  /* HPUX11 */\n\n#ifdef SOLARIS \n\n/*\n *    pt_SolarisSendFile\n *\n *    Send file sfd->fd across socket sd. If specified, header and trailer\n *    buffers are sent before and after the file, respectively.\n *\n *    PR_TRANSMITFILE_CLOSE_SOCKET flag - close socket after sending file\n *\n *    return number of bytes sent or -1 on error\n *\n *    This implementation takes advantage of the sendfilev() system\n *    call available in Solaris 8.\n */\n\nstatic PRInt32 pt_SolarisSendFile(PRFileDesc *sd, PRSendFileData *sfd,\n                PRTransmitFileFlags flags, PRIntervalTime timeout)\n{\n    struct stat statbuf;\n    size_t nbytes_to_send, file_nbytes_to_send;\t\n    struct sendfilevec sfv_struct[3];  \n    int sfvcnt = 0;\t\n    size_t xferred;\n    PRInt32 count;\n    int syserrno;\n\n    if (sfd->file_nbytes == 0) {\n        /* Get file size */\n        if (fstat(sfd->fd->secret->md.osfd, &statbuf) == -1) {\n            _PR_MD_MAP_FSTAT_ERROR(errno);\n            return -1;\n        } \t\t\n        file_nbytes_to_send = statbuf.st_size - sfd->file_offset;\n    } else {\n        file_nbytes_to_send = sfd->file_nbytes;\n    }\n\n    nbytes_to_send = sfd->hlen + sfd->tlen + file_nbytes_to_send;\n\n    if (sfd->hlen != 0) {\n        sfv_struct[sfvcnt].sfv_fd = SFV_FD_SELF;\n        sfv_struct[sfvcnt].sfv_flag = 0;\n        sfv_struct[sfvcnt].sfv_off = (off_t) sfd->header; \n        sfv_struct[sfvcnt].sfv_len = sfd->hlen;\n        sfvcnt++;\n    }\n\n    if (file_nbytes_to_send != 0) {\n        sfv_struct[sfvcnt].sfv_fd = sfd->fd->secret->md.osfd;\n        sfv_struct[sfvcnt].sfv_flag = 0;\n        sfv_struct[sfvcnt].sfv_off = sfd->file_offset;\n        sfv_struct[sfvcnt].sfv_len = file_nbytes_to_send;\n        sfvcnt++;\n    }\n\n    if (sfd->tlen != 0) {\n        sfv_struct[sfvcnt].sfv_fd = SFV_FD_SELF;\n        sfv_struct[sfvcnt].sfv_flag = 0;\n        sfv_struct[sfvcnt].sfv_off = (off_t) sfd->trailer; \n        sfv_struct[sfvcnt].sfv_len = sfd->tlen;\n        sfvcnt++;\n    }\n\n    if (0 == sfvcnt) {\n        count = 0;\n        goto done;\n    }\n   \t   \n    /*\n     * Strictly speaking, we may have sent some bytes when the\n     * sendfilev() is interrupted and we should retry it from an\n     * updated offset.  We are not doing that here.\n     */\n    count = SOLARIS_SENDFILEV(sd->secret->md.osfd, sfv_struct,\n            sfvcnt, &xferred);\n\n    PR_ASSERT((count == -1) || (count == xferred));\n\n    if (count == -1) {\n        syserrno = errno;\n        if (syserrno == EINTR\n                || syserrno == EAGAIN || syserrno == EWOULDBLOCK) {\n            count = xferred;\n        }\n    } else if (count == 0) {\n        /*\n         * We are now at EOF. The file was truncated. Solaris sendfile is\n         * supposed to return 0 and no error in this case, though some versions\n         * may return -1 and EINVAL .\n         */\n        count = -1;\n        syserrno = 0;  /* will be treated as EOF */\n    }\n\n    if (count != -1 && count < nbytes_to_send) {\n        pt_Continuation op;\n        struct sendfilevec *vec = sfv_struct;\n        PRInt32 rem = count;\n\n        while (rem >= vec->sfv_len) {\n            rem -= vec->sfv_len;\n            vec++;\n            sfvcnt--;\n        }\n        PR_ASSERT(sfvcnt > 0);\n\n        vec->sfv_off += rem;\n        vec->sfv_len -= rem;\n        PR_ASSERT(vec->sfv_len > 0);\n\n        op.arg1.osfd = sd->secret->md.osfd;\n        op.arg2.buffer = vec;\n        op.arg3.amount = sfvcnt;\n        op.arg4.flags = 0;\n        op.nbytes_to_send = nbytes_to_send - count;\n        op.result.code = count;\n        op.timeout = timeout;\n        op.function = pt_solaris_sendfile_cont;\n        op.event = POLLOUT | POLLPRI;\n        count = pt_Continue(&op);\n        syserrno = op.syserrno;\n    }\n\ndone:\n    if (count == -1) {\n        pt_MapError(_MD_solaris_map_sendfile_error, syserrno);\n        return -1;\n    }\n    if (flags & PR_TRANSMITFILE_CLOSE_SOCKET) {\n        PR_Close(sd);\n    }\n    PR_ASSERT(count == nbytes_to_send);\n    return count;\n}\n\n#ifndef HAVE_SENDFILEV\nstatic pthread_once_t pt_solaris_sendfilev_once_block = PTHREAD_ONCE_INIT;\n\nstatic void pt_solaris_sendfilev_init_routine(void)\n{\n    void *handle;\n    PRBool close_it = PR_FALSE;\n \n    /*\n     * We do not want to unload libsendfile.so.  This handle is leaked\n     * intentionally.\n     */\n    handle = dlopen(\"libsendfile.so\", RTLD_LAZY | RTLD_GLOBAL);\n    PR_LOG(_pr_io_lm, PR_LOG_DEBUG,\n        (\"dlopen(libsendfile.so) returns %p\", handle));\n\n    if (NULL == handle) {\n        /*\n         * The dlopen(0, mode) call is to allow for the possibility that\n         * sendfilev() may become part of a standard system library in a\n         * future Solaris release.\n         */\n        handle = dlopen(0, RTLD_LAZY | RTLD_GLOBAL);\n        PR_LOG(_pr_io_lm, PR_LOG_DEBUG,\n            (\"dlopen(0) returns %p\", handle));\n        close_it = PR_TRUE;\n    }\n    pt_solaris_sendfilev_fptr = (ssize_t (*)()) dlsym(handle, \"sendfilev\");\n    PR_LOG(_pr_io_lm, PR_LOG_DEBUG,\n        (\"dlsym(sendfilev) returns %p\", pt_solaris_sendfilev_fptr));\n    \n    if (close_it) {\n        dlclose(handle);\n    }\n}\n\n/* \n * pt_SolarisDispatchSendFile\n */\nstatic PRInt32 pt_SolarisDispatchSendFile(PRFileDesc *sd, PRSendFileData *sfd,\n\t  PRTransmitFileFlags flags, PRIntervalTime timeout)\n{\n    int rv;\n\n    rv = pthread_once(&pt_solaris_sendfilev_once_block,\n            pt_solaris_sendfilev_init_routine);\n    PR_ASSERT(0 == rv);\n    if (pt_solaris_sendfilev_fptr) {\n        return pt_SolarisSendFile(sd, sfd, flags, timeout);\n    } else {\n        return PR_EmulateSendFile(sd, sfd, flags, timeout);\n    }\n}\n#endif /* !HAVE_SENDFILEV */\n\n#endif  /* SOLARIS */\n\n#ifdef LINUX\n/*\n * pt_LinuxSendFile\n *\n *    Send file sfd->fd across socket sd. If specified, header and trailer\n *    buffers are sent before and after the file, respectively.\n *\n *    PR_TRANSMITFILE_CLOSE_SOCKET flag - close socket after sending file\n *    \n *    return number of bytes sent or -1 on error\n *\n *      This implementation takes advantage of the sendfile() system\n *      call available in Linux kernel 2.2 or higher.\n */\n\nstatic PRInt32 pt_LinuxSendFile(PRFileDesc *sd, PRSendFileData *sfd,\n                PRTransmitFileFlags flags, PRIntervalTime timeout)\n{\n    struct stat statbuf;\n    size_t file_nbytes_to_send;\t\n    PRInt32 count = 0;\n    ssize_t rv;\n    int syserrno;\n    off_t offset;\n    PRBool tcp_cork_enabled = PR_FALSE;\n    int tcp_cork;\n\n    if (sfd->file_nbytes == 0) {\n        /* Get file size */\n        if (fstat(sfd->fd->secret->md.osfd, &statbuf) == -1) {\n            _PR_MD_MAP_FSTAT_ERROR(errno);\n            return -1;\n        } \t\t\n        file_nbytes_to_send = statbuf.st_size - sfd->file_offset;\n    } else {\n        file_nbytes_to_send = sfd->file_nbytes;\n    }\n\n    if ((sfd->hlen != 0 || sfd->tlen != 0)\n            && sd->secret->md.tcp_nodelay == 0) {\n        tcp_cork = 1;\n        if (setsockopt(sd->secret->md.osfd, SOL_TCP, TCP_CORK,\n                &tcp_cork, sizeof tcp_cork) == 0) {\n            tcp_cork_enabled = PR_TRUE;\n        } else {\n            syserrno = errno;\n            if (syserrno != EINVAL) {\n                _PR_MD_MAP_SETSOCKOPT_ERROR(syserrno);\n                return -1;\n            }\n            /*\n             * The most likely reason for the EINVAL error is that\n             * TCP_NODELAY is set (with a function other than\n             * PR_SetSocketOption).  This is not fatal, so we keep\n             * on going.\n             */\n            PR_LOG(_pr_io_lm, PR_LOG_WARNING,\n                (\"pt_LinuxSendFile: \"\n                \"setsockopt(TCP_CORK) failed with EINVAL\\n\"));\n        }\n    }\n\n    if (sfd->hlen != 0) {\n        count = PR_Send(sd, sfd->header, sfd->hlen, 0, timeout);\n        if (count == -1) {\n            goto failed;\n        }\n    }\n\n    if (file_nbytes_to_send != 0) {\n        offset = sfd->file_offset;\n        do {\n            rv = sendfile(sd->secret->md.osfd, sfd->fd->secret->md.osfd,\n                &offset, file_nbytes_to_send);\n        } while (rv == -1 && (syserrno = errno) == EINTR);\n        if (rv == -1) {\n            if (syserrno != EAGAIN && syserrno != EWOULDBLOCK) {\n                _MD_linux_map_sendfile_error(syserrno);\n                count = -1;\n                goto failed;\n            }\n            rv = 0;\n        }\n        PR_ASSERT(rv == offset - sfd->file_offset);\n        count += rv;\n\n        if (rv < file_nbytes_to_send) {\n            pt_Continuation op;\n\n            op.arg1.osfd = sd->secret->md.osfd;\n            op.in_fd = sfd->fd->secret->md.osfd;\n            op.offset = offset;\n            op.count = file_nbytes_to_send - rv;\n            op.result.code = count;\n            op.timeout = timeout;\n            op.function = pt_linux_sendfile_cont;\n            op.event = POLLOUT | POLLPRI;\n            count = pt_Continue(&op);\n            syserrno = op.syserrno;\n            if (count == -1) {\n                pt_MapError(_MD_linux_map_sendfile_error, syserrno);\n                goto failed;\n            }\n        }\n    }\n\n    if (sfd->tlen != 0) {\n        rv = PR_Send(sd, sfd->trailer, sfd->tlen, 0, timeout);\n        if (rv == -1) {\n            count = -1;\n            goto failed;\n        }\n        count += rv;\n    }\n\nfailed:\n    if (tcp_cork_enabled) {\n        tcp_cork = 0;\n        if (setsockopt(sd->secret->md.osfd, SOL_TCP, TCP_CORK,\n                &tcp_cork, sizeof tcp_cork) == -1 && count != -1) {\n            _PR_MD_MAP_SETSOCKOPT_ERROR(errno);\n            count = -1;\n        }\n    }\n    if (count != -1) {\n        if (flags & PR_TRANSMITFILE_CLOSE_SOCKET) {\n            PR_Close(sd);\n        }\n        PR_ASSERT(count == sfd->hlen + sfd->tlen + file_nbytes_to_send);\n    }\n    return count;\n}\n#endif  /* LINUX */\n\n#ifdef AIX\nextern\tint _pr_aix_send_file_use_disabled;\n#endif\n\nstatic PRInt32 pt_SendFile(\n    PRFileDesc *sd, PRSendFileData *sfd,\n    PRTransmitFileFlags flags, PRIntervalTime timeout)\n{\n    if (pt_TestAbort()) return -1;\n    /* The socket must be in blocking mode. */\n    if (sd->secret->nonblocking)\n    {\n        PR_SetError(PR_INVALID_ARGUMENT_ERROR, 0);\n        return -1;\n    }\n#ifdef HPUX11\n    return(pt_HPUXSendFile(sd, sfd, flags, timeout));\n#elif defined(AIX)\n#ifdef HAVE_SEND_FILE\n\t/*\n\t * A bug in AIX 4.3.2 results in corruption of data transferred by\n\t * send_file(); AIX patch PTF U463956 contains the fix.  A user can\n\t * disable the use of send_file function in NSPR, when this patch is\n\t * not installed on the system, by setting the envionment variable\n\t * NSPR_AIX_SEND_FILE_USE_DISABLED to 1.\n\t */\n\tif (_pr_aix_send_file_use_disabled)\n\t\treturn(PR_EmulateSendFile(sd, sfd, flags, timeout));\n\telse\n    \treturn(pt_AIXSendFile(sd, sfd, flags, timeout));\n#else\n\treturn(PR_EmulateSendFile(sd, sfd, flags, timeout));\n    /* return(pt_AIXDispatchSendFile(sd, sfd, flags, timeout));*/\n#endif /* HAVE_SEND_FILE */\n#elif defined(SOLARIS)\n#ifdef HAVE_SENDFILEV\n    \treturn(pt_SolarisSendFile(sd, sfd, flags, timeout));\n#else\n\treturn(pt_SolarisDispatchSendFile(sd, sfd, flags, timeout));\n#endif /* HAVE_SENDFILEV */\n#elif defined(LINUX)\n    \treturn(pt_LinuxSendFile(sd, sfd, flags, timeout));\n#else\n\treturn(PR_EmulateSendFile(sd, sfd, flags, timeout));\n#endif\n}\n\nstatic PRInt32 pt_TransmitFile(\n    PRFileDesc *sd, PRFileDesc *fd, const void *headers,\n    PRInt32 hlen, PRTransmitFileFlags flags, PRIntervalTime timeout)\n{\n\tPRSendFileData sfd;\n\n\tsfd.fd = fd;\n\tsfd.file_offset = 0;\n\tsfd.file_nbytes = 0;\n\tsfd.header = headers;\n\tsfd.hlen = hlen;\n\tsfd.trailer = NULL;\n\tsfd.tlen = 0;\n\n\treturn(pt_SendFile(sd, &sfd, flags, timeout));\n}  /* pt_TransmitFile */\n\nstatic PRInt32 pt_AcceptRead(\n    PRFileDesc *sd, PRFileDesc **nd, PRNetAddr **raddr,\n    void *buf, PRInt32 amount, PRIntervalTime timeout)\n{\n    PRInt32 rv = -1;\n\n    if (pt_TestAbort()) return rv;\n    /* The socket must be in blocking mode. */\n    if (sd->secret->nonblocking)\n    {\n        PR_SetError(PR_INVALID_ARGUMENT_ERROR, 0);\n        return rv;\n    }\n\n    rv = PR_EmulateAcceptRead(sd, nd, raddr, buf, amount, timeout);\n    return rv;\n}  /* pt_AcceptRead */\n\nstatic PRStatus pt_GetSockName(PRFileDesc *fd, PRNetAddr *addr)\n{\n    PRIntn rv = -1;\n    pt_SockLen addr_len = sizeof(PRNetAddr);\n\n    if (pt_TestAbort()) return PR_FAILURE;\n\n    rv = getsockname(\n        fd->secret->md.osfd, (struct sockaddr*)addr, &addr_len);\n    if (rv == -1) {\n        pt_MapError(_PR_MD_MAP_GETSOCKNAME_ERROR, errno);\n        return PR_FAILURE;\n    } else {\n#ifdef _PR_HAVE_SOCKADDR_LEN\n        /* ignore the sa_len field of struct sockaddr */\n        if (addr)\n        {\n            addr->raw.family = ((struct sockaddr*)addr)->sa_family;\n        }\n#endif /* _PR_HAVE_SOCKADDR_LEN */\n#ifdef _PR_INET6\n\t\tif (AF_INET6 == addr->raw.family)\n\t\t\taddr->raw.family = PR_AF_INET6;\n#endif\n        PR_ASSERT(IsValidNetAddr(addr) == PR_TRUE);\n        PR_ASSERT(IsValidNetAddrLen(addr, addr_len) == PR_TRUE);\n        return PR_SUCCESS;\n    }\n}  /* pt_GetSockName */\n\nstatic PRStatus pt_GetPeerName(PRFileDesc *fd, PRNetAddr *addr)\n{\n    PRIntn rv = -1;\n    pt_SockLen addr_len = sizeof(PRNetAddr);\n\n    if (pt_TestAbort()) return PR_FAILURE;\n\n    rv = getpeername(\n        fd->secret->md.osfd, (struct sockaddr*)addr, &addr_len);\n\n    if (rv == -1) {\n        pt_MapError(_PR_MD_MAP_GETPEERNAME_ERROR, errno);\n        return PR_FAILURE;\n    } else {\n#ifdef _PR_HAVE_SOCKADDR_LEN\n        /* ignore the sa_len field of struct sockaddr */\n        if (addr)\n        {\n            addr->raw.family = ((struct sockaddr*)addr)->sa_family;\n        }\n#endif /* _PR_HAVE_SOCKADDR_LEN */\n#ifdef _PR_INET6\n\t\tif (AF_INET6 == addr->raw.family)\n        \taddr->raw.family = PR_AF_INET6;\n#endif\n        PR_ASSERT(IsValidNetAddr(addr) == PR_TRUE);\n        PR_ASSERT(IsValidNetAddrLen(addr, addr_len) == PR_TRUE);\n        return PR_SUCCESS;\n    }\n}  /* pt_GetPeerName */\n\nstatic PRStatus pt_GetSocketOption(PRFileDesc *fd, PRSocketOptionData *data)\n{\n    PRIntn rv;\n    pt_SockLen length;\n    PRInt32 level, name;\n\n    /*\n     * PR_SockOpt_Nonblocking is a special case that does not\n     * translate to a getsockopt() call\n     */\n    if (PR_SockOpt_Nonblocking == data->option)\n    {\n        data->value.non_blocking = fd->secret->nonblocking;\n        return PR_SUCCESS;\n    }\n\n    rv = _PR_MapOptionName(data->option, &level, &name);\n    if (PR_SUCCESS == rv)\n    {\n        switch (data->option)\n        {\n            case PR_SockOpt_Linger:\n            {\n                struct linger linger;\n                length = sizeof(linger);\n                rv = getsockopt(\n                    fd->secret->md.osfd, level, name, (char *) &linger, &length);\n                PR_ASSERT((-1 == rv) || (sizeof(linger) == length));\n                data->value.linger.polarity =\n                    (linger.l_onoff) ? PR_TRUE : PR_FALSE;\n                data->value.linger.linger =\n                    PR_SecondsToInterval(linger.l_linger);\n                break;\n            }\n            case PR_SockOpt_Reuseaddr:\n            case PR_SockOpt_Keepalive:\n            case PR_SockOpt_NoDelay:\n            case PR_SockOpt_Broadcast:\n            case PR_SockOpt_Reuseport:\n            {\n                PRIntn value;\n                length = sizeof(PRIntn);\n                rv = getsockopt(\n                    fd->secret->md.osfd, level, name, (char*)&value, &length);\n                PR_ASSERT((-1 == rv) || (sizeof(PRIntn) == length));\n                data->value.reuse_addr = (0 == value) ? PR_FALSE : PR_TRUE;\n                break;\n            }\n            case PR_SockOpt_McastLoopback:\n            {\n                PRUint8 xbool;\n                length = sizeof(xbool);\n                rv = getsockopt(\n                    fd->secret->md.osfd, level, name,\n                    (char*)&xbool, &length);\n                PR_ASSERT((-1 == rv) || (sizeof(xbool) == length));\n                data->value.mcast_loopback = (0 == xbool) ? PR_FALSE : PR_TRUE;\n                break;\n            }\n            case PR_SockOpt_RecvBufferSize:\n            case PR_SockOpt_SendBufferSize:\n            case PR_SockOpt_MaxSegment:\n            {\n                PRIntn value;\n                length = sizeof(PRIntn);\n                rv = getsockopt(\n                    fd->secret->md.osfd, level, name, (char*)&value, &length);\n                PR_ASSERT((-1 == rv) || (sizeof(PRIntn) == length));\n                data->value.recv_buffer_size = value;\n                break;\n            }\n            case PR_SockOpt_IpTimeToLive:\n            case PR_SockOpt_IpTypeOfService:\n            {\n                length = sizeof(PRUintn);\n                rv = getsockopt(\n                    fd->secret->md.osfd, level, name,\n                    (char*)&data->value.ip_ttl, &length);\n                PR_ASSERT((-1 == rv) || (sizeof(PRIntn) == length));\n                break;\n            }\n            case PR_SockOpt_McastTimeToLive:\n            {\n                PRUint8 ttl;\n                length = sizeof(ttl);\n                rv = getsockopt(\n                    fd->secret->md.osfd, level, name,\n                    (char*)&ttl, &length);\n                PR_ASSERT((-1 == rv) || (sizeof(ttl) == length));\n                data->value.mcast_ttl = ttl;\n                break;\n            }\n            case PR_SockOpt_AddMember:\n            case PR_SockOpt_DropMember:\n            {\n                struct ip_mreq mreq;\n                length = sizeof(mreq);\n                rv = getsockopt(\n                    fd->secret->md.osfd, level, name, (char*)&mreq, &length);\n                PR_ASSERT((-1 == rv) || (sizeof(mreq) == length));\n                data->value.add_member.mcaddr.inet.ip =\n                    mreq.imr_multiaddr.s_addr;\n                data->value.add_member.ifaddr.inet.ip =\n                    mreq.imr_interface.s_addr;\n                break;\n            }\n            case PR_SockOpt_McastInterface:\n            {\n                length = sizeof(data->value.mcast_if.inet.ip);\n                rv = getsockopt(\n                    fd->secret->md.osfd, level, name,\n                    (char*)&data->value.mcast_if.inet.ip, &length);\n                PR_ASSERT((-1 == rv)\n                    || (sizeof(data->value.mcast_if.inet.ip) == length));\n                break;\n            }\n            default:\n                PR_NOT_REACHED(\"Unknown socket option\");\n                break;\n        }\n        if (-1 == rv) _PR_MD_MAP_GETSOCKOPT_ERROR(errno);\n    }\n    return (-1 == rv) ? PR_FAILURE : PR_SUCCESS;\n}  /* pt_GetSocketOption */\n\nstatic PRStatus pt_SetSocketOption(PRFileDesc *fd, const PRSocketOptionData *data)\n{\n    PRIntn rv;\n    PRInt32 level, name;\n\n    /*\n     * PR_SockOpt_Nonblocking is a special case that does not\n     * translate to a setsockopt call.\n     */\n    if (PR_SockOpt_Nonblocking == data->option)\n    {\n        fd->secret->nonblocking = data->value.non_blocking;\n        return PR_SUCCESS;\n    }\n\n    rv = _PR_MapOptionName(data->option, &level, &name);\n    if (PR_SUCCESS == rv)\n    {\n        switch (data->option)\n        {\n            case PR_SockOpt_Linger:\n            {\n                struct linger linger;\n                linger.l_onoff = data->value.linger.polarity;\n                linger.l_linger = PR_IntervalToSeconds(data->value.linger.linger);\n                rv = setsockopt(\n                    fd->secret->md.osfd, level, name, (char*)&linger, sizeof(linger));\n                break;\n            }\n            case PR_SockOpt_Reuseaddr:\n            case PR_SockOpt_Keepalive:\n            case PR_SockOpt_NoDelay:\n            case PR_SockOpt_Broadcast:\n            case PR_SockOpt_Reuseport:\n            {\n                PRIntn value = (data->value.reuse_addr) ? 1 : 0;\n                rv = setsockopt(\n                    fd->secret->md.osfd, level, name,\n                    (char*)&value, sizeof(PRIntn));\n#ifdef LINUX\n                /* for pt_LinuxSendFile */\n                if (name == TCP_NODELAY && rv == 0) {\n                    fd->secret->md.tcp_nodelay = value;\n                }\n#endif\n                break;\n            }\n            case PR_SockOpt_McastLoopback:\n            {\n                PRUint8 xbool = data->value.mcast_loopback ? 1 : 0;\n                rv = setsockopt(\n                    fd->secret->md.osfd, level, name,\n                    (char*)&xbool, sizeof(xbool));\n                break;\n            }\n            case PR_SockOpt_RecvBufferSize:\n            case PR_SockOpt_SendBufferSize:\n            case PR_SockOpt_MaxSegment:\n            {\n                PRIntn value = data->value.recv_buffer_size;\n                rv = setsockopt(\n                    fd->secret->md.osfd, level, name,\n                    (char*)&value, sizeof(PRIntn));\n                break;\n            }\n            case PR_SockOpt_IpTimeToLive:\n            case PR_SockOpt_IpTypeOfService:\n            {\n                rv = setsockopt(\n                    fd->secret->md.osfd, level, name,\n                    (char*)&data->value.ip_ttl, sizeof(PRUintn));\n                break;\n            }\n            case PR_SockOpt_McastTimeToLive:\n            {\n                PRUint8 ttl = data->value.mcast_ttl;\n                rv = setsockopt(\n                    fd->secret->md.osfd, level, name,\n                    (char*)&ttl, sizeof(ttl));\n                break;\n            }\n            case PR_SockOpt_AddMember:\n            case PR_SockOpt_DropMember:\n            {\n                struct ip_mreq mreq;\n                mreq.imr_multiaddr.s_addr =\n                    data->value.add_member.mcaddr.inet.ip;\n                mreq.imr_interface.s_addr =\n                    data->value.add_member.ifaddr.inet.ip;\n                rv = setsockopt(\n                    fd->secret->md.osfd, level, name,\n                    (char*)&mreq, sizeof(mreq));\n                break;\n            }\n            case PR_SockOpt_McastInterface:\n            {\n                rv = setsockopt(\n                    fd->secret->md.osfd, level, name,\n                    (char*)&data->value.mcast_if.inet.ip,\n                    sizeof(data->value.mcast_if.inet.ip));\n                break;\n            }\n            default:\n                PR_NOT_REACHED(\"Unknown socket option\");\n                break;\n        }\n        if (-1 == rv) _PR_MD_MAP_SETSOCKOPT_ERROR(errno);\n    }\n    return (-1 == rv) ? PR_FAILURE : PR_SUCCESS;\n}  /* pt_SetSocketOption */\n\n/*****************************************************************************/\n/****************************** I/O method objects ***************************/\n/*****************************************************************************/\n\nstatic PRIOMethods _pr_file_methods = {\n    PR_DESC_FILE,\n    pt_Close,\n    pt_Read,\n    pt_Write,\n    pt_Available_f,\n    pt_Available64_f,\n    pt_Fsync,\n    pt_Seek,\n    pt_Seek64,\n    pt_FileInfo,\n    pt_FileInfo64,\n    (PRWritevFN)_PR_InvalidInt,        \n    (PRConnectFN)_PR_InvalidStatus,        \n    (PRAcceptFN)_PR_InvalidDesc,        \n    (PRBindFN)_PR_InvalidStatus,        \n    (PRListenFN)_PR_InvalidStatus,        \n    (PRShutdownFN)_PR_InvalidStatus,    \n    (PRRecvFN)_PR_InvalidInt,        \n    (PRSendFN)_PR_InvalidInt,        \n    (PRRecvfromFN)_PR_InvalidInt,    \n    (PRSendtoFN)_PR_InvalidInt,        \n    pt_Poll,\n    (PRAcceptreadFN)_PR_InvalidInt,   \n    (PRTransmitfileFN)_PR_InvalidInt, \n    (PRGetsocknameFN)_PR_InvalidStatus,    \n    (PRGetpeernameFN)_PR_InvalidStatus,    \n    (PRReservedFN)_PR_InvalidInt,    \n    (PRReservedFN)_PR_InvalidInt,    \n    (PRGetsocketoptionFN)_PR_InvalidStatus,\n    (PRSetsocketoptionFN)_PR_InvalidStatus,\n    (PRSendfileFN)_PR_InvalidInt, \n    (PRConnectcontinueFN)_PR_InvalidStatus, \n    (PRReservedFN)_PR_InvalidInt, \n    (PRReservedFN)_PR_InvalidInt, \n    (PRReservedFN)_PR_InvalidInt, \n    (PRReservedFN)_PR_InvalidInt\n};\n\nstatic PRIOMethods _pr_pipe_methods = {\n    PR_DESC_PIPE,\n    pt_Close,\n    pt_Read,\n    pt_Write,\n    pt_Available_s,\n    pt_Available64_s,\n    pt_Synch,\n    (PRSeekFN)_PR_InvalidInt,\n    (PRSeek64FN)_PR_InvalidInt64,\n    (PRFileInfoFN)_PR_InvalidStatus,\n    (PRFileInfo64FN)_PR_InvalidStatus,\n    (PRWritevFN)_PR_InvalidInt,        \n    (PRConnectFN)_PR_InvalidStatus,        \n    (PRAcceptFN)_PR_InvalidDesc,        \n    (PRBindFN)_PR_InvalidStatus,        \n    (PRListenFN)_PR_InvalidStatus,        \n    (PRShutdownFN)_PR_InvalidStatus,    \n    (PRRecvFN)_PR_InvalidInt,        \n    (PRSendFN)_PR_InvalidInt,        \n    (PRRecvfromFN)_PR_InvalidInt,    \n    (PRSendtoFN)_PR_InvalidInt,        \n    pt_Poll,\n    (PRAcceptreadFN)_PR_InvalidInt,   \n    (PRTransmitfileFN)_PR_InvalidInt, \n    (PRGetsocknameFN)_PR_InvalidStatus,    \n    (PRGetpeernameFN)_PR_InvalidStatus,    \n    (PRReservedFN)_PR_InvalidInt,    \n    (PRReservedFN)_PR_InvalidInt,    \n    (PRGetsocketoptionFN)_PR_InvalidStatus,\n    (PRSetsocketoptionFN)_PR_InvalidStatus,\n    (PRSendfileFN)_PR_InvalidInt, \n    (PRConnectcontinueFN)_PR_InvalidStatus, \n    (PRReservedFN)_PR_InvalidInt, \n    (PRReservedFN)_PR_InvalidInt, \n    (PRReservedFN)_PR_InvalidInt, \n    (PRReservedFN)_PR_InvalidInt\n};\n\nstatic PRIOMethods _pr_tcp_methods = {\n    PR_DESC_SOCKET_TCP,\n    pt_Close,\n    pt_SocketRead,\n    pt_SocketWrite,\n    pt_Available_s,\n    pt_Available64_s,\n    pt_Synch,\n    (PRSeekFN)_PR_InvalidInt,\n    (PRSeek64FN)_PR_InvalidInt64,\n    (PRFileInfoFN)_PR_InvalidStatus,\n    (PRFileInfo64FN)_PR_InvalidStatus,\n    pt_Writev,\n    pt_Connect,\n    pt_Accept,\n    pt_Bind,\n    pt_Listen,\n    pt_Shutdown,\n    pt_Recv,\n    pt_Send,\n    (PRRecvfromFN)_PR_InvalidInt,\n    (PRSendtoFN)_PR_InvalidInt,\n    pt_Poll,\n    pt_AcceptRead,\n    pt_TransmitFile,\n    pt_GetSockName,\n    pt_GetPeerName,\n    (PRReservedFN)_PR_InvalidInt,\n    (PRReservedFN)_PR_InvalidInt,\n    pt_GetSocketOption,\n    pt_SetSocketOption,\n    pt_SendFile, \n    pt_ConnectContinue,\n    (PRReservedFN)_PR_InvalidInt, \n    (PRReservedFN)_PR_InvalidInt, \n    (PRReservedFN)_PR_InvalidInt, \n    (PRReservedFN)_PR_InvalidInt\n};\n\nstatic PRIOMethods _pr_udp_methods = {\n    PR_DESC_SOCKET_UDP,\n    pt_Close,\n    pt_SocketRead,\n    pt_SocketWrite,\n    pt_Available_s,\n    pt_Available64_s,\n    pt_Synch,\n    (PRSeekFN)_PR_InvalidInt,\n    (PRSeek64FN)_PR_InvalidInt64,\n    (PRFileInfoFN)_PR_InvalidStatus,\n    (PRFileInfo64FN)_PR_InvalidStatus,\n    pt_Writev,\n    pt_Connect,\n    (PRAcceptFN)_PR_InvalidDesc,\n    pt_Bind,\n    pt_Listen,\n    pt_Shutdown,\n    pt_Recv,\n    pt_Send,\n    pt_RecvFrom,\n    pt_SendTo,\n    pt_Poll,\n    (PRAcceptreadFN)_PR_InvalidInt,\n    (PRTransmitfileFN)_PR_InvalidInt,\n    pt_GetSockName,\n    pt_GetPeerName,\n    (PRReservedFN)_PR_InvalidInt,\n    (PRReservedFN)_PR_InvalidInt,\n    pt_GetSocketOption,\n    pt_SetSocketOption,\n    (PRSendfileFN)_PR_InvalidInt, \n    (PRConnectcontinueFN)_PR_InvalidStatus, \n    (PRReservedFN)_PR_InvalidInt, \n    (PRReservedFN)_PR_InvalidInt, \n    (PRReservedFN)_PR_InvalidInt, \n    (PRReservedFN)_PR_InvalidInt\n};\n\nstatic PRIOMethods _pr_socketpollfd_methods = {\n    (PRDescType) 0,\n    (PRCloseFN)_PR_InvalidStatus,\n    (PRReadFN)_PR_InvalidInt,\n    (PRWriteFN)_PR_InvalidInt,\n    (PRAvailableFN)_PR_InvalidInt,\n    (PRAvailable64FN)_PR_InvalidInt64,\n    (PRFsyncFN)_PR_InvalidStatus,\n    (PRSeekFN)_PR_InvalidInt,\n    (PRSeek64FN)_PR_InvalidInt64,\n    (PRFileInfoFN)_PR_InvalidStatus,\n    (PRFileInfo64FN)_PR_InvalidStatus,\n    (PRWritevFN)_PR_InvalidInt,        \n    (PRConnectFN)_PR_InvalidStatus,        \n    (PRAcceptFN)_PR_InvalidDesc,        \n    (PRBindFN)_PR_InvalidStatus,        \n    (PRListenFN)_PR_InvalidStatus,        \n    (PRShutdownFN)_PR_InvalidStatus,    \n    (PRRecvFN)_PR_InvalidInt,        \n    (PRSendFN)_PR_InvalidInt,        \n    (PRRecvfromFN)_PR_InvalidInt,    \n    (PRSendtoFN)_PR_InvalidInt,        \n\tpt_Poll,\n    (PRAcceptreadFN)_PR_InvalidInt,   \n    (PRTransmitfileFN)_PR_InvalidInt, \n    (PRGetsocknameFN)_PR_InvalidStatus,    \n    (PRGetpeernameFN)_PR_InvalidStatus,    \n    (PRReservedFN)_PR_InvalidInt,    \n    (PRReservedFN)_PR_InvalidInt,    \n    (PRGetsocketoptionFN)_PR_InvalidStatus,\n    (PRSetsocketoptionFN)_PR_InvalidStatus,\n    (PRSendfileFN)_PR_InvalidInt, \n    (PRConnectcontinueFN)_PR_InvalidStatus, \n    (PRReservedFN)_PR_InvalidInt, \n    (PRReservedFN)_PR_InvalidInt, \n    (PRReservedFN)_PR_InvalidInt, \n    (PRReservedFN)_PR_InvalidInt\n};\n\n#if defined(HPUX) || defined(OSF1) || defined(SOLARIS) || defined (IRIX) \\\n    || defined(LINUX) || defined(__GNU__) || defined(__GLIBC__) \\\n    || defined(AIX) || defined(FREEBSD) || defined(NETBSD) \\\n    || defined(OPENBSD) || defined(BSDI) || defined(NTO) \\\n    || defined(DARWIN) || defined(UNIXWARE) || defined(RISCOS) \\\n    || defined(SYMBIAN)\n#define _PR_FCNTL_FLAGS O_NONBLOCK\n#else\n#error \"Can't determine architecture\"\n#endif\n\n/*\n * Put a Unix file descriptor in non-blocking mode.\n */\nstatic void pt_MakeFdNonblock(PRIntn osfd)\n{\n    PRIntn flags;\n    flags = fcntl(osfd, F_GETFL, 0);\n    flags |= _PR_FCNTL_FLAGS;\n    (void)fcntl(osfd, F_SETFL, flags);\n}\n\n/*\n * Put a Unix socket fd in non-blocking mode that can\n * ideally be inherited by an accepted socket.\n *\n * Why doesn't pt_MakeFdNonblock do?  This is to deal with\n * the special case of HP-UX.  HP-UX has three kinds of\n * non-blocking modes for sockets: the fcntl() O_NONBLOCK\n * and O_NDELAY flags and ioctl() FIOSNBIO request.  Only\n * the ioctl() FIOSNBIO form of non-blocking mode is\n * inherited by an accepted socket.\n *\n * Other platforms just use the generic pt_MakeFdNonblock\n * to put a socket in non-blocking mode.\n */\n#ifdef HPUX\nstatic void pt_MakeSocketNonblock(PRIntn osfd)\n{\n    PRIntn one = 1;\n    (void)ioctl(osfd, FIOSNBIO, &one);\n}\n#else\n#define pt_MakeSocketNonblock pt_MakeFdNonblock\n#endif\n\nstatic PRFileDesc *pt_SetMethods(\n    PRIntn osfd, PRDescType type, PRBool isAcceptedSocket, PRBool imported)\n{\n    PRFileDesc *fd = _PR_Getfd();\n    \n    if (fd == NULL) PR_SetError(PR_OUT_OF_MEMORY_ERROR, 0);\n    else\n    {\n        fd->secret->md.osfd = osfd;\n        fd->secret->state = _PR_FILEDESC_OPEN;\n        if (imported) fd->secret->inheritable = _PR_TRI_UNKNOWN;\n        else\n        {\n            /* By default, a Unix fd is not closed on exec. */\n#ifdef DEBUG\n            PRIntn flags;\n            flags = fcntl(osfd, F_GETFD, 0);\n            PR_ASSERT(0 == flags);\n#endif\n            fd->secret->inheritable = _PR_TRI_TRUE;\n        }\n        switch (type)\n        {\n            case PR_DESC_FILE:\n                fd->methods = PR_GetFileMethods();\n                break;\n            case PR_DESC_SOCKET_TCP:\n                fd->methods = PR_GetTCPMethods();\n#ifdef _PR_ACCEPT_INHERIT_NONBLOCK\n                if (!isAcceptedSocket) pt_MakeSocketNonblock(osfd);\n#else\n                pt_MakeSocketNonblock(osfd);\n#endif\n                break;\n            case PR_DESC_SOCKET_UDP:\n                fd->methods = PR_GetUDPMethods();\n                pt_MakeFdNonblock(osfd);\n                break;\n            case PR_DESC_PIPE:\n                fd->methods = PR_GetPipeMethods();\n                pt_MakeFdNonblock(osfd);\n                break;\n            default:\n                break;\n        }\n    }\n    return fd;\n}  /* pt_SetMethods */\n\nPR_IMPLEMENT(const PRIOMethods*) PR_GetFileMethods(void)\n{\n    return &_pr_file_methods;\n}  /* PR_GetFileMethods */\n\nPR_IMPLEMENT(const PRIOMethods*) PR_GetPipeMethods(void)\n{\n    return &_pr_pipe_methods;\n}  /* PR_GetPipeMethods */\n\nPR_IMPLEMENT(const PRIOMethods*) PR_GetTCPMethods(void)\n{\n    return &_pr_tcp_methods;\n}  /* PR_GetTCPMethods */\n\nPR_IMPLEMENT(const PRIOMethods*) PR_GetUDPMethods(void)\n{\n    return &_pr_udp_methods;\n}  /* PR_GetUDPMethods */\n\nstatic const PRIOMethods* PR_GetSocketPollFdMethods(void)\n{\n    return &_pr_socketpollfd_methods;\n}  /* PR_GetSocketPollFdMethods */\n\nPR_IMPLEMENT(PRFileDesc*) PR_AllocFileDesc(\n    PRInt32 osfd, const PRIOMethods *methods)\n{\n    PRFileDesc *fd = _PR_Getfd();\n\n    if (NULL == fd) goto failed;\n\n    fd->methods = methods;\n    fd->secret->md.osfd = osfd;\n    /* Make fd non-blocking */\n    if (osfd > 2)\n    {\n        /* Don't mess around with stdin, stdout or stderr */\n        if (&_pr_tcp_methods == methods) pt_MakeSocketNonblock(osfd);\n        else pt_MakeFdNonblock(osfd);\n    }\n    fd->secret->state = _PR_FILEDESC_OPEN;\n    fd->secret->inheritable = _PR_TRI_UNKNOWN;\n    return fd;\n    \nfailed:\n    PR_SetError(PR_OUT_OF_MEMORY_ERROR, 0);\n    return fd;\n}  /* PR_AllocFileDesc */\n\n#if !defined(_PR_INET6) || defined(_PR_INET6_PROBE)\nPR_EXTERN(PRStatus) _pr_push_ipv6toipv4_layer(PRFileDesc *fd);\n#if defined(_PR_INET6_PROBE)\nextern PRBool _pr_ipv6_is_present(void);\nPR_IMPLEMENT(PRBool) _pr_test_ipv6_socket()\n{\n    int osfd;\n\n#if defined(DARWIN)\n    /*\n     * Disable IPv6 if Darwin version is less than 7.0.0 (OS X 10.3).  IPv6 on\n     * lesser versions is not ready for general use (see bug 222031).\n     */\n    {\n        struct utsname u;\n        if (uname(&u) != 0 || atoi(u.release) < 7)\n            return PR_FALSE;\n    }\n#endif\n\n    /*\n     * HP-UX only: HP-UX IPv6 Porting Guide (dated February 2001)\n     * suggests that we call open(\"/dev/ip6\", O_RDWR) to determine\n     * whether IPv6 APIs and the IPv6 stack are on the system.\n     * Our portable test below seems to work fine, so I am using it.\n     */\n    osfd = socket(AF_INET6, SOCK_STREAM, 0);\n    if (osfd != -1) {\n        close(osfd);\n        return PR_TRUE;\n    }\n    return PR_FALSE;\n}\n#endif\t/* _PR_INET6_PROBE */\n#endif\n\nPR_IMPLEMENT(PRFileDesc*) PR_Socket(PRInt32 domain, PRInt32 type, PRInt32 proto)\n{\n    PRIntn osfd;\n    PRDescType ftype;\n    PRFileDesc *fd = NULL;\n#if defined(_PR_INET6_PROBE) || !defined(_PR_INET6)\n    PRInt32 tmp_domain = domain;\n#endif\n\n    if (!_pr_initialized) _PR_ImplicitInitialization();\n\n    if (pt_TestAbort()) return NULL;\n\n    if (PF_INET != domain\n        && PR_AF_INET6 != domain\n#if defined(_PR_HAVE_SDP)\n        && PR_AF_INET_SDP != domain\n#if defined(SOLARIS)\n        && PR_AF_INET6_SDP != domain\n#endif /* SOLARIS */\n#endif /* _PR_HAVE_SDP */\n        && PF_UNIX != domain)\n    {\n        PR_SetError(PR_ADDRESS_NOT_SUPPORTED_ERROR, 0);\n        return fd;\n    }\n\tif (type == SOCK_STREAM) ftype = PR_DESC_SOCKET_TCP;\n\telse if (type == SOCK_DGRAM) ftype = PR_DESC_SOCKET_UDP;\n\telse\n\t{\n\t\t(void)PR_SetError(PR_ADDRESS_NOT_SUPPORTED_ERROR, 0);\n\t\treturn fd;\n\t}\n#if defined(_PR_HAVE_SDP)\n#if defined(LINUX)\n    if (PR_AF_INET_SDP == domain)\n        domain = AF_INET_SDP;\n#elif defined(SOLARIS)\n    if (PR_AF_INET_SDP == domain) {\n        domain = AF_INET;\n        proto = PROTO_SDP;\n    } else if(PR_AF_INET6_SDP == domain) {\n        domain = AF_INET6;\n        proto = PROTO_SDP;\n    }\n#endif /* SOLARIS */\n#endif /* _PR_HAVE_SDP */\n#if defined(_PR_INET6_PROBE)\n\tif (PR_AF_INET6 == domain)\n\t\tdomain = _pr_ipv6_is_present() ? AF_INET6 : AF_INET;\n#elif defined(_PR_INET6) \n\tif (PR_AF_INET6 == domain)\n\t\tdomain = AF_INET6;\n#else\n\tif (PR_AF_INET6 == domain)\n\t\tdomain = AF_INET;\n#endif\n\n    osfd = socket(domain, type, proto);\n    if (osfd == -1) pt_MapError(_PR_MD_MAP_SOCKET_ERROR, errno);\n    else\n    {\n#ifdef _PR_IPV6_V6ONLY_PROBE\n        if ((domain == AF_INET6) && _pr_ipv6_v6only_on_by_default)\n        {\n            int on = 0;\n            (void)setsockopt(osfd, IPPROTO_IPV6, IPV6_V6ONLY,\n                    &on, sizeof(on));\n        }\n#endif\n        fd = pt_SetMethods(osfd, ftype, PR_FALSE, PR_FALSE);\n        if (fd == NULL) close(osfd);\n    }\n#ifdef _PR_NEED_SECRET_AF\n    if (fd != NULL) fd->secret->af = domain;\n#endif\n#if defined(_PR_INET6_PROBE) || !defined(_PR_INET6)\n\tif (fd != NULL) {\n\t\t/*\n\t\t * For platforms with no support for IPv6 \n\t\t * create layered socket for IPv4-mapped IPv6 addresses\n\t\t */\n\t\tif (PR_AF_INET6 == tmp_domain && PR_AF_INET == domain) {\n\t\t\tif (PR_FAILURE == _pr_push_ipv6toipv4_layer(fd)) {\n\t\t\t\tPR_Close(fd);\n\t\t\t\tfd = NULL;\n\t\t\t}\n\t\t}\n\t}\n#endif\n    return fd;\n}  /* PR_Socket */\n\n/*****************************************************************************/\n/****************************** I/O public methods ***************************/\n/*****************************************************************************/\n\nPR_IMPLEMENT(PRFileDesc*) PR_OpenFile(\n    const char *name, PRIntn flags, PRIntn mode)\n{\n    PRFileDesc *fd = NULL;\n    PRIntn syserrno, osfd = -1, osflags = 0;;\n\n    if (!_pr_initialized) _PR_ImplicitInitialization();\n\n    if (pt_TestAbort()) return NULL;\n\n    if (flags & PR_RDONLY) osflags |= O_RDONLY;\n    if (flags & PR_WRONLY) osflags |= O_WRONLY;\n    if (flags & PR_RDWR) osflags |= O_RDWR;\n    if (flags & PR_APPEND) osflags |= O_APPEND;\n    if (flags & PR_TRUNCATE) osflags |= O_TRUNC;\n    if (flags & PR_EXCL) osflags |= O_EXCL;\n    if (flags & PR_SYNC)\n    {\n#if defined(O_SYNC)\n        osflags |= O_SYNC;\n#elif defined(O_FSYNC)\n        osflags |= O_FSYNC;\n#else\n#error \"Neither O_SYNC nor O_FSYNC is defined on this platform\"\n#endif\n    }\n\n    /*\n    ** We have to hold the lock across the creation in order to\n    ** enforce the sematics of PR_Rename(). (see the latter for\n    ** more details)\n    */\n    if (flags & PR_CREATE_FILE)\n    {\n        osflags |= O_CREAT;\n        if (NULL !=_pr_rename_lock)\n            PR_Lock(_pr_rename_lock);\n    }\n\n    osfd = _md_iovector._open64(name, osflags, mode);\n    syserrno = errno;\n\n    if ((flags & PR_CREATE_FILE) && (NULL !=_pr_rename_lock))\n        PR_Unlock(_pr_rename_lock);\n\n    if (osfd == -1)\n        pt_MapError(_PR_MD_MAP_OPEN_ERROR, syserrno);\n    else\n    {\n        fd = pt_SetMethods(osfd, PR_DESC_FILE, PR_FALSE, PR_FALSE);\n        if (fd == NULL) close(osfd);  /* $$$ whoops! this is bad $$$ */\n    }\n    return fd;\n}  /* PR_OpenFile */\n\nPR_IMPLEMENT(PRFileDesc*) PR_Open(const char *name, PRIntn flags, PRIntn mode)\n{\n    return PR_OpenFile(name, flags, mode);\n}  /* PR_Open */\n\nPR_IMPLEMENT(PRStatus) PR_Delete(const char *name)\n{\n    PRIntn rv = -1;\n\n    if (!_pr_initialized) _PR_ImplicitInitialization();\n\n    if (pt_TestAbort()) return PR_FAILURE;\n\n    rv = unlink(name);\n\n    if (rv == -1) {\n        pt_MapError(_PR_MD_MAP_UNLINK_ERROR, errno);\n        return PR_FAILURE;\n    } else\n        return PR_SUCCESS;\n}  /* PR_Delete */\n\nPR_IMPLEMENT(PRStatus) PR_Access(const char *name, PRAccessHow how)\n{\n    PRIntn rv;\n\n    if (pt_TestAbort()) return PR_FAILURE;\n\n    switch (how)\n    {\n    case PR_ACCESS_READ_OK:\n        rv =  access(name, R_OK);\n        break;\n    case PR_ACCESS_WRITE_OK:\n        rv = access(name, W_OK);\n        break;\n    case PR_ACCESS_EXISTS:\n    default:\n        rv = access(name, F_OK);\n    }\n    if (0 == rv) return PR_SUCCESS;\n    pt_MapError(_PR_MD_MAP_ACCESS_ERROR, errno);\n    return PR_FAILURE;\n    \n}  /* PR_Access */\n\nPR_IMPLEMENT(PRStatus) PR_GetFileInfo(const char *fn, PRFileInfo *info)\n{\n    PRInt32 rv = _PR_MD_GETFILEINFO(fn, info);\n    return (0 == rv) ? PR_SUCCESS : PR_FAILURE;\n}  /* PR_GetFileInfo */\n\nPR_IMPLEMENT(PRStatus) PR_GetFileInfo64(const char *fn, PRFileInfo64 *info)\n{\n    PRInt32 rv;\n\n    if (!_pr_initialized) _PR_ImplicitInitialization();\n    rv = _PR_MD_GETFILEINFO64(fn, info);\n    return (0 == rv) ? PR_SUCCESS : PR_FAILURE;\n}  /* PR_GetFileInfo64 */\n\nPR_IMPLEMENT(PRStatus) PR_Rename(const char *from, const char *to)\n{\n    PRIntn rv = -1;\n\n    if (pt_TestAbort()) return PR_FAILURE;\n\n    /*\n    ** We have to acquire a lock here to stiffle anybody trying to create\n    ** a new file at the same time. And we have to hold that lock while we\n    ** test to see if the file exists and do the rename. The other place\n    ** where the lock is held is in PR_Open() when possibly creating a \n    ** new file.\n    */\n\n    PR_Lock(_pr_rename_lock);\n    rv = access(to, F_OK);\n    if (0 == rv)\n    {\n        PR_SetError(PR_FILE_EXISTS_ERROR, 0);\n        rv = -1;\n    }\n    else\n    {\n        rv = rename(from, to);\n        if (rv == -1)\n            pt_MapError(_PR_MD_MAP_RENAME_ERROR, errno);\n    }\n    PR_Unlock(_pr_rename_lock);\n    return (-1 == rv) ? PR_FAILURE : PR_SUCCESS;\n}  /* PR_Rename */\n\nPR_IMPLEMENT(PRStatus) PR_CloseDir(PRDir *dir)\n{\n    if (pt_TestAbort()) return PR_FAILURE;\n\n    if (NULL != dir->md.d)\n    {\n        if (closedir(dir->md.d) == -1)\n        {\n            _PR_MD_MAP_CLOSEDIR_ERROR(errno);\n            return PR_FAILURE;\n        }\n        dir->md.d = NULL;\n        PR_DELETE(dir);\n    }\n    return PR_SUCCESS;\n}  /* PR_CloseDir */\n\nPR_IMPLEMENT(PRStatus) PR_MakeDir(const char *name, PRIntn mode)\n{\n    PRInt32 rv = -1;\n\n    if (pt_TestAbort()) return PR_FAILURE;\n\n    /*\n    ** This lock is used to enforce rename semantics as described\n    ** in PR_Rename.\n    */\n    if (NULL !=_pr_rename_lock)\n        PR_Lock(_pr_rename_lock);\n    rv = mkdir(name, mode);\n    if (-1 == rv)\n        pt_MapError(_PR_MD_MAP_MKDIR_ERROR, errno);\n    if (NULL !=_pr_rename_lock)\n        PR_Unlock(_pr_rename_lock);\n\n    return (-1 == rv) ? PR_FAILURE : PR_SUCCESS;\n}  /* PR_Makedir */\n\nPR_IMPLEMENT(PRStatus) PR_MkDir(const char *name, PRIntn mode)\n{\n    return PR_MakeDir(name, mode);\n}  /* PR_Mkdir */\n\nPR_IMPLEMENT(PRStatus) PR_RmDir(const char *name)\n{\n    PRInt32 rv;\n\n    if (pt_TestAbort()) return PR_FAILURE;\n\n    rv = rmdir(name);\n    if (0 == rv) {\n    return PR_SUCCESS;\n    } else {\n    pt_MapError(_PR_MD_MAP_RMDIR_ERROR, errno);\n    return PR_FAILURE;\n    }\n}  /* PR_Rmdir */\n\n\nPR_IMPLEMENT(PRDir*) PR_OpenDir(const char *name)\n{\n    DIR *osdir;\n    PRDir *dir = NULL;\n\n    if (pt_TestAbort()) return dir;\n\n    osdir = opendir(name);\n    if (osdir == NULL)\n        pt_MapError(_PR_MD_MAP_OPENDIR_ERROR, errno);\n    else\n    {\n        dir = PR_NEWZAP(PRDir);\n        if (dir)\n            dir->md.d = osdir;\n        else\n            (void)closedir(osdir);\n    }\n    return dir;\n}  /* PR_OpenDir */\n\nstatic PRInt32 _pr_poll_with_poll(\n    PRPollDesc *pds, PRIntn npds, PRIntervalTime timeout)\n{\n    PRInt32 ready = 0;\n    /*\n     * For restarting poll() if it is interrupted by a signal.\n     * We use these variables to figure out how much time has\n     * elapsed and how much of the timeout still remains.\n     */\n    PRIntervalTime start = 0, elapsed, remaining;\n\n    if (pt_TestAbort()) return -1;\n\n    if (0 == npds) PR_Sleep(timeout);\n    else\n    {\n#define STACK_POLL_DESC_COUNT 64\n        struct pollfd stack_syspoll[STACK_POLL_DESC_COUNT];\n        struct pollfd *syspoll;\n        PRIntn index, msecs;\n\n        if (npds <= STACK_POLL_DESC_COUNT)\n        {\n            syspoll = stack_syspoll;\n        }\n        else\n        {\n            PRThread *me = PR_GetCurrentThread();\n            if (npds > me->syspoll_count)\n            {\n                PR_Free(me->syspoll_list);\n                me->syspoll_list =\n                    (struct pollfd*)PR_MALLOC(npds * sizeof(struct pollfd));\n                if (NULL == me->syspoll_list)\n                {\n                    me->syspoll_count = 0;\n                    PR_SetError(PR_OUT_OF_MEMORY_ERROR, 0);\n                    return -1;\n                }\n                me->syspoll_count = npds;\n            }\n            syspoll = me->syspoll_list;\n        }\n\n        for (index = 0; index < npds; ++index)\n        {\n            PRInt16 in_flags_read = 0, in_flags_write = 0;\n            PRInt16 out_flags_read = 0, out_flags_write = 0;\n\n            if ((NULL != pds[index].fd) && (0 != pds[index].in_flags))\n            {\n                if (pds[index].in_flags & PR_POLL_READ)\n                {\n                    in_flags_read = (pds[index].fd->methods->poll)(\n                        pds[index].fd,\n                        pds[index].in_flags & ~PR_POLL_WRITE,\n                        &out_flags_read);\n                }\n                if (pds[index].in_flags & PR_POLL_WRITE)\n                {\n                    in_flags_write = (pds[index].fd->methods->poll)(\n                        pds[index].fd,\n                        pds[index].in_flags & ~PR_POLL_READ,\n                        &out_flags_write);\n                }\n                if ((0 != (in_flags_read & out_flags_read))\n                || (0 != (in_flags_write & out_flags_write)))\n                {\n                    /* this one is ready right now */\n                    if (0 == ready)\n                    {\n                        /*\n                         * We will return without calling the system\n                         * poll function.  So zero the out_flags\n                         * fields of all the poll descriptors before\n                         * this one.\n                         */\n                        int i;\n                        for (i = 0; i < index; i++)\n                        {\n                            pds[i].out_flags = 0;\n                        }\n                    }\n                    ready += 1;\n                    pds[index].out_flags = out_flags_read | out_flags_write;\n                }\n                else\n                {\n                    /* now locate the NSPR layer at the bottom of the stack */\n                    PRFileDesc *bottom = PR_GetIdentitiesLayer(\n                        pds[index].fd, PR_NSPR_IO_LAYER);\n                    PR_ASSERT(NULL != bottom);  /* what to do about that? */\n                    pds[index].out_flags = 0;  /* pre-condition */\n                    if ((NULL != bottom)\n                    && (_PR_FILEDESC_OPEN == bottom->secret->state))\n                    {\n                        if (0 == ready)\n                        {\n                            syspoll[index].fd = bottom->secret->md.osfd;\n                            syspoll[index].events = 0;\n                            if (in_flags_read & PR_POLL_READ)\n                            {\n                                pds[index].out_flags |=\n                                    _PR_POLL_READ_SYS_READ;\n                                syspoll[index].events |= POLLIN;\n                            }\n                            if (in_flags_read & PR_POLL_WRITE)\n                            {\n                                pds[index].out_flags |=\n                                    _PR_POLL_READ_SYS_WRITE;\n                                syspoll[index].events |= POLLOUT;\n                            }\n                            if (in_flags_write & PR_POLL_READ)\n                            {\n                                pds[index].out_flags |=\n                                    _PR_POLL_WRITE_SYS_READ;\n                                syspoll[index].events |= POLLIN;\n                            }\n                            if (in_flags_write & PR_POLL_WRITE)\n                            {\n                                pds[index].out_flags |=\n                                    _PR_POLL_WRITE_SYS_WRITE;\n                                syspoll[index].events |= POLLOUT;\n                            }\n                            if (pds[index].in_flags & PR_POLL_EXCEPT)\n                                syspoll[index].events |= POLLPRI;\n                        }\n                    }\n                    else\n                    {\n                        if (0 == ready)\n                        {\n                            int i;\n                            for (i = 0; i < index; i++)\n                            {\n                                pds[i].out_flags = 0;\n                            }\n                        }\n                        ready += 1;  /* this will cause an abrupt return */\n                        pds[index].out_flags = PR_POLL_NVAL;  /* bogii */\n                    }\n                }\n            }\n            else\n            {\n                /* make poll() ignore this entry */\n                syspoll[index].fd = -1;\n                syspoll[index].events = 0;\n                pds[index].out_flags = 0;\n            }\n        }\n        if (0 == ready)\n        {\n            switch (timeout)\n            {\n            case PR_INTERVAL_NO_WAIT: msecs = 0; break;\n            case PR_INTERVAL_NO_TIMEOUT: msecs = -1; break;\n            default:\n                msecs = PR_IntervalToMilliseconds(timeout);\n                start = PR_IntervalNow();\n            }\n\nretry:\n            ready = poll(syspoll, npds, msecs);\n            if (-1 == ready)\n            {\n                PRIntn oserror = errno;\n\n                if (EINTR == oserror)\n                {\n                    if (timeout == PR_INTERVAL_NO_TIMEOUT)\n                        goto retry;\n                    else if (timeout == PR_INTERVAL_NO_WAIT)\n                        ready = 0;  /* don't retry, just time out */\n                    else\n                    {\n                        elapsed = (PRIntervalTime) (PR_IntervalNow()\n                                - start);\n                        if (elapsed > timeout)\n                            ready = 0;  /* timed out */\n                        else\n                        {\n                            remaining = timeout - elapsed;\n                            msecs = PR_IntervalToMilliseconds(remaining);\n                            goto retry;\n                        }\n                    }\n                }\n                else\n                {\n                    _PR_MD_MAP_POLL_ERROR(oserror);\n                }\n            }\n            else if (ready > 0)\n            {\n                for (index = 0; index < npds; ++index)\n                {\n                    PRInt16 out_flags = 0;\n                    if ((NULL != pds[index].fd) && (0 != pds[index].in_flags))\n                    {\n                        if (0 != syspoll[index].revents)\n                        {\n                            if (syspoll[index].revents & POLLIN)\n                            {\n                                if (pds[index].out_flags\n                                & _PR_POLL_READ_SYS_READ)\n                                {\n                                    out_flags |= PR_POLL_READ;\n                                }\n                                if (pds[index].out_flags\n                                & _PR_POLL_WRITE_SYS_READ)\n                                {\n                                    out_flags |= PR_POLL_WRITE;\n                                }\n                            }\n                            if (syspoll[index].revents & POLLOUT)\n                            {\n                                if (pds[index].out_flags\n                                & _PR_POLL_READ_SYS_WRITE)\n                                {\n                                    out_flags |= PR_POLL_READ;\n                                }\n                                if (pds[index].out_flags\n                                & _PR_POLL_WRITE_SYS_WRITE)\n                                {\n                                    out_flags |= PR_POLL_WRITE;\n                                }\n                            }\n                            if (syspoll[index].revents & POLLPRI)\n                                out_flags |= PR_POLL_EXCEPT;\n                            if (syspoll[index].revents & POLLERR)\n                                out_flags |= PR_POLL_ERR;\n                            if (syspoll[index].revents & POLLNVAL)\n                                out_flags |= PR_POLL_NVAL;\n                            if (syspoll[index].revents & POLLHUP)\n                                out_flags |= PR_POLL_HUP;\n                        }\n                    }\n                    pds[index].out_flags = out_flags;\n                }\n            }\n        }\n    }\n    return ready;\n\n} /* _pr_poll_with_poll */\n\n#if defined(_PR_POLL_WITH_SELECT)\n/*\n * OSF1 and HPUX report the POLLHUP event for a socket when the\n * shutdown(SHUT_WR) operation is called for the remote end, even though\n * the socket is still writeable. Use select(), instead of poll(), to\n * workaround this problem.\n */\nstatic PRInt32 _pr_poll_with_select(\n    PRPollDesc *pds, PRIntn npds, PRIntervalTime timeout)\n{\n    PRInt32 ready = 0;\n    /*\n     * For restarting select() if it is interrupted by a signal.\n     * We use these variables to figure out how much time has\n     * elapsed and how much of the timeout still remains.\n     */\n    PRIntervalTime start = 0, elapsed, remaining;\n\n    if (pt_TestAbort()) return -1;\n\n    if (0 == npds) PR_Sleep(timeout);\n    else\n    {\n#define STACK_POLL_DESC_COUNT 64\n        int stack_selectfd[STACK_POLL_DESC_COUNT];\n        int *selectfd;\n\t\tfd_set rd, wr, ex, *rdp = NULL, *wrp = NULL, *exp = NULL;\n\t\tstruct timeval tv, *tvp;\n        PRIntn index, msecs, maxfd = 0;\n\n        if (npds <= STACK_POLL_DESC_COUNT)\n        {\n            selectfd = stack_selectfd;\n        }\n        else\n        {\n            PRThread *me = PR_GetCurrentThread();\n            if (npds > me->selectfd_count)\n            {\n                PR_Free(me->selectfd_list);\n                me->selectfd_list = (int *)PR_MALLOC(npds * sizeof(int));\n                if (NULL == me->selectfd_list)\n                {\n                    me->selectfd_count = 0;\n                    PR_SetError(PR_OUT_OF_MEMORY_ERROR, 0);\n                    return -1;\n                }\n                me->selectfd_count = npds;\n            }\n            selectfd = me->selectfd_list;\n        }\n\t\tFD_ZERO(&rd);\n\t\tFD_ZERO(&wr);\n\t\tFD_ZERO(&ex);\n\n        for (index = 0; index < npds; ++index)\n        {\n            PRInt16 in_flags_read = 0, in_flags_write = 0;\n            PRInt16 out_flags_read = 0, out_flags_write = 0;\n\n            if ((NULL != pds[index].fd) && (0 != pds[index].in_flags))\n            {\n                if (pds[index].in_flags & PR_POLL_READ)\n                {\n                    in_flags_read = (pds[index].fd->methods->poll)(\n                        pds[index].fd,\n                        pds[index].in_flags & ~PR_POLL_WRITE,\n                        &out_flags_read);\n                }\n                if (pds[index].in_flags & PR_POLL_WRITE)\n                {\n                    in_flags_write = (pds[index].fd->methods->poll)(\n                        pds[index].fd,\n                        pds[index].in_flags & ~PR_POLL_READ,\n                        &out_flags_write);\n                }\n                if ((0 != (in_flags_read & out_flags_read))\n                || (0 != (in_flags_write & out_flags_write)))\n                {\n                    /* this one is ready right now */\n                    if (0 == ready)\n                    {\n                        /*\n                         * We will return without calling the system\n                         * poll function.  So zero the out_flags\n                         * fields of all the poll descriptors before\n                         * this one.\n                         */\n                        int i;\n                        for (i = 0; i < index; i++)\n                        {\n                            pds[i].out_flags = 0;\n                        }\n                    }\n                    ready += 1;\n                    pds[index].out_flags = out_flags_read | out_flags_write;\n                }\n                else\n                {\n                    /* now locate the NSPR layer at the bottom of the stack */\n                    PRFileDesc *bottom = PR_GetIdentitiesLayer(\n                        pds[index].fd, PR_NSPR_IO_LAYER);\n                    PR_ASSERT(NULL != bottom);  /* what to do about that? */\n                    pds[index].out_flags = 0;  /* pre-condition */\n                    if ((NULL != bottom)\n                    && (_PR_FILEDESC_OPEN == bottom->secret->state))\n                    {\n                        if (0 == ready)\n                        {\n                            PRBool add_to_rd = PR_FALSE;\n                            PRBool add_to_wr = PR_FALSE;\n                            PRBool add_to_ex = PR_FALSE;\n\n                            selectfd[index] = bottom->secret->md.osfd;\n                            if (in_flags_read & PR_POLL_READ)\n                            {\n                                pds[index].out_flags |=\n                                    _PR_POLL_READ_SYS_READ;\n                                add_to_rd = PR_TRUE;\n                            }\n                            if (in_flags_read & PR_POLL_WRITE)\n                            {\n                                pds[index].out_flags |=\n                                    _PR_POLL_READ_SYS_WRITE;\n                                add_to_wr = PR_TRUE;\n                            }\n                            if (in_flags_write & PR_POLL_READ)\n                            {\n                                pds[index].out_flags |=\n                                    _PR_POLL_WRITE_SYS_READ;\n                                add_to_rd = PR_TRUE;\n                            }\n                            if (in_flags_write & PR_POLL_WRITE)\n                            {\n                                pds[index].out_flags |=\n                                    _PR_POLL_WRITE_SYS_WRITE;\n                                add_to_wr = PR_TRUE;\n                            }\n                            if (pds[index].in_flags & PR_POLL_EXCEPT)\n                            {\n                                add_to_ex = PR_TRUE;\n                            }\n                            if ((selectfd[index] > maxfd) &&\n                                    (add_to_rd || add_to_wr || add_to_ex))\n                            {\n                                maxfd = selectfd[index];\n                                /*\n                                 * If maxfd is too large to be used with\n                                 * select, fall back to calling poll.\n                                 */\n                                if (maxfd >= FD_SETSIZE)\n                                    break;\n                            }\n                            if (add_to_rd)\n                            {\n                                FD_SET(bottom->secret->md.osfd, &rd);\n                                rdp = &rd;\n                            }\n                            if (add_to_wr)\n                            {\n                                FD_SET(bottom->secret->md.osfd, &wr);\n                                wrp = &wr;\n                            }\n                            if (add_to_ex)\n                            {\n                                FD_SET(bottom->secret->md.osfd, &ex);\n                                exp = &ex;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        if (0 == ready)\n                        {\n                            int i;\n                            for (i = 0; i < index; i++)\n                            {\n                                pds[i].out_flags = 0;\n                            }\n                        }\n                        ready += 1;  /* this will cause an abrupt return */\n                        pds[index].out_flags = PR_POLL_NVAL;  /* bogii */\n                    }\n                }\n            }\n            else\n            {\n                pds[index].out_flags = 0;\n            }\n        }\n        if (0 == ready)\n        {\n\t\t\tif (maxfd >= FD_SETSIZE)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * maxfd too large to be used with select, fall back to\n\t\t\t\t * calling poll\n\t\t\t\t */\n\t\t\t\treturn(_pr_poll_with_poll(pds, npds, timeout));\n\t\t\t}\n            switch (timeout)\n            {\n            case PR_INTERVAL_NO_WAIT:\n\t\t\t\ttv.tv_sec = 0;\n\t\t\t\ttv.tv_usec = 0;\n\t\t\t\ttvp = &tv;\n\t\t\t\tbreak;\n            case PR_INTERVAL_NO_TIMEOUT:\n\t\t\t\ttvp = NULL;\n\t\t\t\tbreak;\n            default:\n                msecs = PR_IntervalToMilliseconds(timeout);\n\t\t\t\ttv.tv_sec = msecs/PR_MSEC_PER_SEC;\n\t\t\t\ttv.tv_usec = (msecs % PR_MSEC_PER_SEC) * PR_USEC_PER_MSEC;\n\t\t\t\ttvp = &tv;\n                start = PR_IntervalNow();\n            }\n\nretry:\n            ready = select(maxfd + 1, rdp, wrp, exp, tvp);\n            if (-1 == ready)\n            {\n                PRIntn oserror = errno;\n\n                if ((EINTR == oserror) || (EAGAIN == oserror))\n                {\n                    if (timeout == PR_INTERVAL_NO_TIMEOUT)\n                        goto retry;\n                    else if (timeout == PR_INTERVAL_NO_WAIT)\n                        ready = 0;  /* don't retry, just time out */\n                    else\n                    {\n                        elapsed = (PRIntervalTime) (PR_IntervalNow()\n                                - start);\n                        if (elapsed > timeout)\n                            ready = 0;  /* timed out */\n                        else\n                        {\n                            remaining = timeout - elapsed;\n                            msecs = PR_IntervalToMilliseconds(remaining);\n\t\t\t\t\t\t\ttv.tv_sec = msecs/PR_MSEC_PER_SEC;\n\t\t\t\t\t\t\ttv.tv_usec = (msecs % PR_MSEC_PER_SEC) *\n\t\t\t\t\t\t\t\t\t\t\t\t\tPR_USEC_PER_MSEC;\n                            goto retry;\n                        }\n                    }\n                } else if (EBADF == oserror)\n                {\n\t\t\t\t\t/* find all the bad fds */\n\t\t\t\t\tready = 0;\n                \tfor (index = 0; index < npds; ++index)\n\t\t\t\t\t{\n                    \tpds[index].out_flags = 0;\n            \t\t\tif ((NULL != pds[index].fd) &&\n\t\t\t\t\t\t\t\t\t\t\t(0 != pds[index].in_flags))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (fcntl(selectfd[index], F_GETFL, 0) == -1)\n\t\t\t\t\t\t\t{\n                    \t\t\tpds[index].out_flags = PR_POLL_NVAL;\n\t\t\t\t\t\t\t\tready++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n                } else \n                    _PR_MD_MAP_SELECT_ERROR(oserror);\n            }\n            else if (ready > 0)\n            {\n                for (index = 0; index < npds; ++index)\n                {\n                    PRInt16 out_flags = 0;\n                    if ((NULL != pds[index].fd) && (0 != pds[index].in_flags))\n                    {\n\t\t\t\t\t\tif (FD_ISSET(selectfd[index], &rd))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (pds[index].out_flags\n\t\t\t\t\t\t\t& _PR_POLL_READ_SYS_READ)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tout_flags |= PR_POLL_READ;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (pds[index].out_flags\n\t\t\t\t\t\t\t& _PR_POLL_WRITE_SYS_READ)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tout_flags |= PR_POLL_WRITE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (FD_ISSET(selectfd[index], &wr))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (pds[index].out_flags\n\t\t\t\t\t\t\t& _PR_POLL_READ_SYS_WRITE)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tout_flags |= PR_POLL_READ;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (pds[index].out_flags\n\t\t\t\t\t\t\t& _PR_POLL_WRITE_SYS_WRITE)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tout_flags |= PR_POLL_WRITE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (FD_ISSET(selectfd[index], &ex))\n\t\t\t\t\t\t\tout_flags |= PR_POLL_EXCEPT;\n                    }\n                    pds[index].out_flags = out_flags;\n                }\n            }\n        }\n    }\n    return ready;\n\n} /* _pr_poll_with_select */\n#endif\t/* _PR_POLL_WITH_SELECT */\n\nPR_IMPLEMENT(PRInt32) PR_Poll(\n    PRPollDesc *pds, PRIntn npds, PRIntervalTime timeout)\n{\n#if defined(_PR_POLL_WITH_SELECT)\n\treturn(_pr_poll_with_select(pds, npds, timeout));\n#else\n\treturn(_pr_poll_with_poll(pds, npds, timeout));\n#endif\n}\n\nPR_IMPLEMENT(PRDirEntry*) PR_ReadDir(PRDir *dir, PRDirFlags flags)\n{\n    struct dirent *dp;\n\n    if (pt_TestAbort()) return NULL;\n\n    for (;;)\n    {\n        errno = 0;\n        dp = readdir(dir->md.d);\n        if (NULL == dp)\n        {\n            pt_MapError(_PR_MD_MAP_READDIR_ERROR, errno);\n            return NULL;\n        }\n        if ((flags & PR_SKIP_DOT)\n            && ('.' == dp->d_name[0])\n            && (0 == dp->d_name[1])) continue;\n        if ((flags & PR_SKIP_DOT_DOT)\n            && ('.' == dp->d_name[0])\n            && ('.' == dp->d_name[1])\n            && (0 == dp->d_name[2])) continue;\n        if ((flags & PR_SKIP_HIDDEN) && ('.' == dp->d_name[0]))\n            continue;\n        break;\n    }\n    dir->d.name = dp->d_name;\n    return &dir->d;\n}  /* PR_ReadDir */\n\nPR_IMPLEMENT(PRFileDesc*) PR_NewUDPSocket(void)\n{\n    PRIntn domain = PF_INET;\n\n    return PR_Socket(domain, SOCK_DGRAM, 0);\n}  /* PR_NewUDPSocket */\n\nPR_IMPLEMENT(PRFileDesc*) PR_NewTCPSocket(void)\n{\n    PRIntn domain = PF_INET;\n\n    return PR_Socket(domain, SOCK_STREAM, 0);\n}  /* PR_NewTCPSocket */\n\nPR_IMPLEMENT(PRFileDesc*) PR_OpenUDPSocket(PRIntn af)\n{\n    return PR_Socket(af, SOCK_DGRAM, 0);\n}  /* PR_NewUDPSocket */\n\nPR_IMPLEMENT(PRFileDesc*) PR_OpenTCPSocket(PRIntn af)\n{\n    return PR_Socket(af, SOCK_STREAM, 0);\n}  /* PR_NewTCPSocket */\n\nPR_IMPLEMENT(PRStatus) PR_NewTCPSocketPair(PRFileDesc *fds[2])\n{\n#ifdef SYMBIAN\n    /*\n     * For the platforms that don't have socketpair.\n     *\n     * Copied from prsocket.c, with the parameter f[] renamed fds[] and the\n     * _PR_CONNECT_DOES_NOT_BIND code removed.\n     */\n    PRFileDesc *listenSock;\n    PRNetAddr selfAddr, peerAddr;\n    PRUint16 port;\n\n    fds[0] = fds[1] = NULL;\n    listenSock = PR_NewTCPSocket();\n    if (listenSock == NULL) {\n        goto failed;\n    }\n    PR_InitializeNetAddr(PR_IpAddrLoopback, 0, &selfAddr); /* BugZilla: 35408 */\n    if (PR_Bind(listenSock, &selfAddr) == PR_FAILURE) {\n        goto failed;\n    }\n    if (PR_GetSockName(listenSock, &selfAddr) == PR_FAILURE) {\n        goto failed;\n    }\n    port = ntohs(selfAddr.inet.port);\n    if (PR_Listen(listenSock, 5) == PR_FAILURE) {\n        goto failed;\n    }\n    fds[0] = PR_NewTCPSocket();\n    if (fds[0] == NULL) {\n        goto failed;\n    }\n    PR_InitializeNetAddr(PR_IpAddrLoopback, port, &selfAddr);\n\n    /*\n     * Only a thread is used to do the connect and accept.\n     * I am relying on the fact that PR_Connect returns\n     * successfully as soon as the connect request is put\n     * into the listen queue (but before PR_Accept is called).\n     * This is the behavior of the BSD socket code.  If\n     * connect does not return until accept is called, we\n     * will need to create another thread to call connect.\n     */\n    if (PR_Connect(fds[0], &selfAddr, PR_INTERVAL_NO_TIMEOUT)\n            == PR_FAILURE) {\n        goto failed;\n    }\n    /*\n     * A malicious local process may connect to the listening\n     * socket, so we need to verify that the accepted connection\n     * is made from our own socket fds[0].\n     */\n    if (PR_GetSockName(fds[0], &selfAddr) == PR_FAILURE) {\n        goto failed;\n    }\n    fds[1] = PR_Accept(listenSock, &peerAddr, PR_INTERVAL_NO_TIMEOUT);\n    if (fds[1] == NULL) {\n        goto failed;\n    }\n    if (peerAddr.inet.port != selfAddr.inet.port) {\n        /* the connection we accepted is not from fds[0] */\n        PR_SetError(PR_INSUFFICIENT_RESOURCES_ERROR, 0);\n        goto failed;\n    }\n    PR_Close(listenSock);\n    return PR_SUCCESS;\n\nfailed:\n    if (listenSock) {\n        PR_Close(listenSock);\n    }\n    if (fds[0]) {\n        PR_Close(fds[0]);\n    }\n    if (fds[1]) {\n        PR_Close(fds[1]);\n    }\n    return PR_FAILURE;\n#else\n    PRInt32 osfd[2];\n\n    if (pt_TestAbort()) return PR_FAILURE;\n\n    if (socketpair(AF_UNIX, SOCK_STREAM, 0, osfd) == -1) {\n        pt_MapError(_PR_MD_MAP_SOCKETPAIR_ERROR, errno);\n        return PR_FAILURE;\n    }\n\n    fds[0] = pt_SetMethods(osfd[0], PR_DESC_SOCKET_TCP, PR_FALSE, PR_FALSE);\n    if (fds[0] == NULL) {\n        close(osfd[0]);\n        close(osfd[1]);\n        return PR_FAILURE;\n    }\n    fds[1] = pt_SetMethods(osfd[1], PR_DESC_SOCKET_TCP, PR_FALSE, PR_FALSE);\n    if (fds[1] == NULL) {\n        PR_Close(fds[0]);\n        close(osfd[1]);\n        return PR_FAILURE;\n    }\n    return PR_SUCCESS;\n#endif\n}  /* PR_NewTCPSocketPair */\n\nPR_IMPLEMENT(PRStatus) PR_CreatePipe(\n    PRFileDesc **readPipe,\n    PRFileDesc **writePipe\n)\n{\n    int pipefd[2];\n\n    if (pt_TestAbort()) return PR_FAILURE;\n\n    if (pipe(pipefd) == -1)\n    {\n    /* XXX map pipe error */\n        PR_SetError(PR_UNKNOWN_ERROR, errno);\n        return PR_FAILURE;\n    }\n    *readPipe = pt_SetMethods(pipefd[0], PR_DESC_PIPE, PR_FALSE, PR_FALSE);\n    if (NULL == *readPipe)\n    {\n        close(pipefd[0]);\n        close(pipefd[1]);\n        return PR_FAILURE;\n    }\n    *writePipe = pt_SetMethods(pipefd[1], PR_DESC_PIPE, PR_FALSE, PR_FALSE);\n    if (NULL == *writePipe)\n    {\n        PR_Close(*readPipe);\n        close(pipefd[1]);\n        return PR_FAILURE;\n    }\n    return PR_SUCCESS;\n}\n\n/*\n** Set the inheritance attribute of a file descriptor.\n*/\nPR_IMPLEMENT(PRStatus) PR_SetFDInheritable(\n    PRFileDesc *fd,\n    PRBool inheritable)\n{\n    /*\n     * Only a non-layered, NSPR file descriptor can be inherited\n     * by a child process.\n     */\n    if (fd->identity != PR_NSPR_IO_LAYER)\n    {\n        PR_SetError(PR_INVALID_ARGUMENT_ERROR, 0);\n        return PR_FAILURE;\n    }\n    if (fd->secret->inheritable != inheritable)\n    {\n        if (fcntl(fd->secret->md.osfd, F_SETFD,\n        inheritable ? 0 : FD_CLOEXEC) == -1)\n        {\n            _PR_MD_MAP_DEFAULT_ERROR(errno);\n            return PR_FAILURE;\n        }\n        fd->secret->inheritable = (_PRTriStateBool) inheritable;\n    }\n    return PR_SUCCESS;\n}\n\n/*****************************************************************************/\n/***************************** I/O friends methods ***************************/\n/*****************************************************************************/\n\nPR_IMPLEMENT(PRFileDesc*) PR_ImportFile(PRInt32 osfd)\n{\n    PRFileDesc *fd;\n\n    if (!_pr_initialized) _PR_ImplicitInitialization();\n    fd = pt_SetMethods(osfd, PR_DESC_FILE, PR_FALSE, PR_TRUE);\n    if (NULL == fd) close(osfd);\n    return fd;\n}  /* PR_ImportFile */\n\nPR_IMPLEMENT(PRFileDesc*) PR_ImportPipe(PRInt32 osfd)\n{\n    PRFileDesc *fd;\n\n    if (!_pr_initialized) _PR_ImplicitInitialization();\n    fd = pt_SetMethods(osfd, PR_DESC_PIPE, PR_FALSE, PR_TRUE);\n    if (NULL == fd) close(osfd);\n    return fd;\n}  /* PR_ImportPipe */\n\nPR_IMPLEMENT(PRFileDesc*) PR_ImportTCPSocket(PRInt32 osfd)\n{\n    PRFileDesc *fd;\n\n    if (!_pr_initialized) _PR_ImplicitInitialization();\n    fd = pt_SetMethods(osfd, PR_DESC_SOCKET_TCP, PR_FALSE, PR_TRUE);\n    if (NULL == fd) close(osfd);\n#ifdef _PR_NEED_SECRET_AF\n    if (NULL != fd) fd->secret->af = PF_INET;\n#endif\n    return fd;\n}  /* PR_ImportTCPSocket */\n\nPR_IMPLEMENT(PRFileDesc*) PR_ImportUDPSocket(PRInt32 osfd)\n{\n    PRFileDesc *fd;\n\n    if (!_pr_initialized) _PR_ImplicitInitialization();\n    fd = pt_SetMethods(osfd, PR_DESC_SOCKET_UDP, PR_FALSE, PR_TRUE);\n    if (NULL == fd) close(osfd);\n    return fd;\n}  /* PR_ImportUDPSocket */\n\nPR_IMPLEMENT(PRFileDesc*) PR_CreateSocketPollFd(PRInt32 osfd)\n{\n    PRFileDesc *fd;\n\n    if (!_pr_initialized) _PR_ImplicitInitialization();\n\n    fd = _PR_Getfd();\n\n    if (fd == NULL) PR_SetError(PR_OUT_OF_MEMORY_ERROR, 0);\n    else\n    {\n        fd->secret->md.osfd = osfd;\n        fd->secret->inheritable = _PR_TRI_FALSE;\n    \tfd->secret->state = _PR_FILEDESC_OPEN;\n        fd->methods = PR_GetSocketPollFdMethods();\n    }\n\n    return fd;\n}  /* PR_CreateSocketPollFD */\n\nPR_IMPLEMENT(PRStatus) PR_DestroySocketPollFd(PRFileDesc *fd)\n{\n    if (NULL == fd)\n    {\n        PR_SetError(PR_BAD_DESCRIPTOR_ERROR, 0);\n        return PR_FAILURE;\n    }\n    fd->secret->state = _PR_FILEDESC_CLOSED;\n    _PR_Putfd(fd);\n    return PR_SUCCESS;\n}  /* PR_DestroySocketPollFd */\n\nPR_IMPLEMENT(PRInt32) PR_FileDesc2NativeHandle(PRFileDesc *bottom)\n{\n    PRInt32 osfd = -1;\n    bottom = (NULL == bottom) ?\n        NULL : PR_GetIdentitiesLayer(bottom, PR_NSPR_IO_LAYER);\n    if (NULL == bottom) PR_SetError(PR_INVALID_ARGUMENT_ERROR, 0);\n    else osfd = bottom->secret->md.osfd;\n    return osfd;\n}  /* PR_FileDesc2NativeHandle */\n\nPR_IMPLEMENT(void) PR_ChangeFileDescNativeHandle(PRFileDesc *fd,\n    PRInt32 handle)\n{\n    if (fd) fd->secret->md.osfd = handle;\n}  /*  PR_ChangeFileDescNativeHandle*/\n\nPR_IMPLEMENT(PRStatus) PR_LockFile(PRFileDesc *fd)\n{\n    PRStatus status = PR_SUCCESS;\n\n    if (pt_TestAbort()) return PR_FAILURE;\n\n    PR_Lock(_pr_flock_lock);\n    while (-1 == fd->secret->lockCount)\n        PR_WaitCondVar(_pr_flock_cv, PR_INTERVAL_NO_TIMEOUT);\n    if (0 == fd->secret->lockCount)\n    {\n        fd->secret->lockCount = -1;\n        PR_Unlock(_pr_flock_lock);\n        status = _PR_MD_LOCKFILE(fd->secret->md.osfd);\n        PR_Lock(_pr_flock_lock);\n        fd->secret->lockCount = (PR_SUCCESS == status) ? 1 : 0;\n        PR_NotifyAllCondVar(_pr_flock_cv);\n    }\n    else\n    {\n        fd->secret->lockCount += 1;\n    }\n    PR_Unlock(_pr_flock_lock);\n \n    return status;\n}  /* PR_LockFile */\n\nPR_IMPLEMENT(PRStatus) PR_TLockFile(PRFileDesc *fd)\n{\n    PRStatus status = PR_SUCCESS;\n\n    if (pt_TestAbort()) return PR_FAILURE;\n\n    PR_Lock(_pr_flock_lock);\n    if (0 == fd->secret->lockCount)\n    {\n        status = _PR_MD_TLOCKFILE(fd->secret->md.osfd);\n        if (PR_SUCCESS == status) fd->secret->lockCount = 1;\n    }\n    else fd->secret->lockCount += 1;\n    PR_Unlock(_pr_flock_lock);\n \n    return status;\n}  /* PR_TLockFile */\n\nPR_IMPLEMENT(PRStatus) PR_UnlockFile(PRFileDesc *fd)\n{\n    PRStatus status = PR_SUCCESS;\n\n    if (pt_TestAbort()) return PR_FAILURE;\n\n    PR_Lock(_pr_flock_lock);\n    if (fd->secret->lockCount == 1)\n    {\n        status = _PR_MD_UNLOCKFILE(fd->secret->md.osfd);\n        if (PR_SUCCESS == status) fd->secret->lockCount = 0;\n    }\n    else fd->secret->lockCount -= 1;\n    PR_Unlock(_pr_flock_lock);\n\n    return status;\n}\n\n/*\n * The next two entry points should not be in the API, but they are\n * defined here for historical (or hysterical) reasons.\n */\n\nPR_IMPLEMENT(PRInt32) PR_GetSysfdTableMax(void)\n{\n#if defined(AIX) || defined(SYMBIAN)\n    return sysconf(_SC_OPEN_MAX);\n#else\n    struct rlimit rlim;\n\n    if ( getrlimit(RLIMIT_NOFILE, &rlim) < 0) \n       return -1;\n\n    return rlim.rlim_max;\n#endif\n}\n\nPR_IMPLEMENT(PRInt32) PR_SetSysfdTableSize(PRIntn table_size)\n{\n#if defined(AIX) || defined(SYMBIAN)\n    return -1;\n#else\n    struct rlimit rlim;\n    PRInt32 tableMax = PR_GetSysfdTableMax();\n\n    if (tableMax < 0) return -1;\n    rlim.rlim_max = tableMax;\n\n    /* Grow as much as we can; even if too big */\n    if ( rlim.rlim_max < table_size )\n        rlim.rlim_cur = rlim.rlim_max;\n    else\n        rlim.rlim_cur = table_size;\n\n    if ( setrlimit(RLIMIT_NOFILE, &rlim) < 0) \n        return -1;\n\n    return rlim.rlim_cur;\n#endif\n}\n\n/*\n * PR_Stat is supported for backward compatibility; some existing Java\n * code uses it.  New code should use PR_GetFileInfo.\n */\n\n#ifndef NO_NSPR_10_SUPPORT\nPR_IMPLEMENT(PRInt32) PR_Stat(const char *name, struct stat *buf)\n{\n    static PRBool unwarned = PR_TRUE;\n    if (unwarned) unwarned = _PR_Obsolete(\"PR_Stat\", \"PR_GetFileInfo\");\n\n    if (pt_TestAbort()) return -1;\n\n    if (-1 == stat(name, buf)) {\n        pt_MapError(_PR_MD_MAP_STAT_ERROR, errno);\n        return -1;\n    } else {\n        return 0;\n    }\n}\n#endif /* ! NO_NSPR_10_SUPPORT */\n\n\nPR_IMPLEMENT(void) PR_FD_ZERO(PR_fd_set *set)\n{\n    static PRBool unwarned = PR_TRUE;\n    if (unwarned) unwarned = _PR_Obsolete(\"PR_FD_ZERO (PR_Select)\", \"PR_Poll\");\n    memset(set, 0, sizeof(PR_fd_set));\n}\n\nPR_IMPLEMENT(void) PR_FD_SET(PRFileDesc *fh, PR_fd_set *set)\n{\n    static PRBool unwarned = PR_TRUE;\n    if (unwarned) unwarned = _PR_Obsolete(\"PR_FD_SET (PR_Select)\", \"PR_Poll\");\n    PR_ASSERT( set->hsize < PR_MAX_SELECT_DESC );\n\n    set->harray[set->hsize++] = fh;\n}\n\nPR_IMPLEMENT(void) PR_FD_CLR(PRFileDesc *fh, PR_fd_set *set)\n{\n    PRUint32 index, index2;\n    static PRBool unwarned = PR_TRUE;\n    if (unwarned) unwarned = _PR_Obsolete(\"PR_FD_CLR (PR_Select)\", \"PR_Poll\");\n\n    for (index = 0; index<set->hsize; index++)\n       if (set->harray[index] == fh) {\n           for (index2=index; index2 < (set->hsize-1); index2++) {\n               set->harray[index2] = set->harray[index2+1];\n           }\n           set->hsize--;\n           break;\n       }\n}\n\nPR_IMPLEMENT(PRInt32) PR_FD_ISSET(PRFileDesc *fh, PR_fd_set *set)\n{\n    PRUint32 index;\n    static PRBool unwarned = PR_TRUE;\n    if (unwarned) unwarned = _PR_Obsolete(\"PR_FD_ISSET (PR_Select)\", \"PR_Poll\");\n    for (index = 0; index<set->hsize; index++)\n       if (set->harray[index] == fh) {\n           return 1;\n       }\n    return 0;\n}\n\nPR_IMPLEMENT(void) PR_FD_NSET(PRInt32 fd, PR_fd_set *set)\n{\n    static PRBool unwarned = PR_TRUE;\n    if (unwarned) unwarned = _PR_Obsolete(\"PR_FD_NSET (PR_Select)\", \"PR_Poll\");\n    PR_ASSERT( set->nsize < PR_MAX_SELECT_DESC );\n\n    set->narray[set->nsize++] = fd;\n}\n\nPR_IMPLEMENT(void) PR_FD_NCLR(PRInt32 fd, PR_fd_set *set)\n{\n    PRUint32 index, index2;\n    static PRBool unwarned = PR_TRUE;\n    if (unwarned) unwarned = _PR_Obsolete(\"PR_FD_NCLR (PR_Select)\", \"PR_Poll\");\n\n    for (index = 0; index<set->nsize; index++)\n       if (set->narray[index] == fd) {\n           for (index2=index; index2 < (set->nsize-1); index2++) {\n               set->narray[index2] = set->narray[index2+1];\n           }\n           set->nsize--;\n           break;\n       }\n}\n\nPR_IMPLEMENT(PRInt32) PR_FD_NISSET(PRInt32 fd, PR_fd_set *set)\n{\n    PRUint32 index;\n    static PRBool unwarned = PR_TRUE;\n    if (unwarned) unwarned = _PR_Obsolete(\"PR_FD_NISSET (PR_Select)\", \"PR_Poll\");\n    for (index = 0; index<set->nsize; index++)\n       if (set->narray[index] == fd) {\n           return 1;\n       }\n    return 0;\n}\n\n#include <sys/types.h>\n#include <sys/time.h>\n#if !defined(HPUX) \\\n    && !defined(LINUX) && !defined(__GNU__) && !defined(__GLIBC__)\n#include <sys/select.h>\n#endif\n\nstatic PRInt32\n_PR_getset(PR_fd_set *pr_set, fd_set *set)\n{\n    PRUint32 index;\n    PRInt32 max = 0;\n\n    if (!pr_set)\n        return 0;\n   \n    FD_ZERO(set);\n\n    /* First set the pr file handle osfds */\n    for (index=0; index<pr_set->hsize; index++) {\n        FD_SET(pr_set->harray[index]->secret->md.osfd, set);\n        if (pr_set->harray[index]->secret->md.osfd > max)\n            max = pr_set->harray[index]->secret->md.osfd;\n    }\n    /* Second set the native osfds */\n    for (index=0; index<pr_set->nsize; index++) {\n        FD_SET(pr_set->narray[index], set);\n        if (pr_set->narray[index] > max)\n            max = pr_set->narray[index];\n    }\n    return max;\n}\n\nstatic void\n_PR_setset(PR_fd_set *pr_set, fd_set *set)\n{\n    PRUint32 index, last_used;\n\n    if (!pr_set)\n        return;\n\n    for (last_used=0, index=0; index<pr_set->hsize; index++) {\n        if ( FD_ISSET(pr_set->harray[index]->secret->md.osfd, set) ) {\n            pr_set->harray[last_used++] = pr_set->harray[index];\n        }\n    }\n    pr_set->hsize = last_used;\n\n    for (last_used=0, index=0; index<pr_set->nsize; index++) {\n        if ( FD_ISSET(pr_set->narray[index], set) ) {\n            pr_set->narray[last_used++] = pr_set->narray[index];\n        }\n    }\n    pr_set->nsize = last_used;\n}\n\nPR_IMPLEMENT(PRInt32) PR_Select(\n    PRInt32 unused, PR_fd_set *pr_rd, PR_fd_set *pr_wr, \n    PR_fd_set *pr_ex, PRIntervalTime timeout)\n{\n    fd_set rd, wr, ex;\n    struct timeval tv, *tvp;\n    PRInt32 max, max_fd;\n    PRInt32 rv;\n    /*\n     * For restarting select() if it is interrupted by a Unix signal.\n     * We use these variables to figure out how much time has elapsed\n     * and how much of the timeout still remains.\n     */\n    PRIntervalTime start = 0, elapsed, remaining;\n\n    static PRBool unwarned = PR_TRUE;\n    if (unwarned) unwarned = _PR_Obsolete( \"PR_Select\", \"PR_Poll\");\n\n    FD_ZERO(&rd);\n    FD_ZERO(&wr);\n    FD_ZERO(&ex);\n\n    max_fd = _PR_getset(pr_rd, &rd);\n    max_fd = (max = _PR_getset(pr_wr, &wr))>max_fd?max:max_fd;\n    max_fd = (max = _PR_getset(pr_ex, &ex))>max_fd?max:max_fd;\n\n    if (timeout == PR_INTERVAL_NO_TIMEOUT) {\n        tvp = NULL;\n    } else {\n        tv.tv_sec = (PRInt32)PR_IntervalToSeconds(timeout);\n        tv.tv_usec = (PRInt32)PR_IntervalToMicroseconds(\n                timeout - PR_SecondsToInterval(tv.tv_sec));\n        tvp = &tv;\n        start = PR_IntervalNow();\n    }\n\nretry:\n    rv = select(max_fd + 1, (_PRSelectFdSetArg_t) &rd,\n        (_PRSelectFdSetArg_t) &wr, (_PRSelectFdSetArg_t) &ex, tvp);\n\n    if (rv == -1 && errno == EINTR) {\n        if (timeout == PR_INTERVAL_NO_TIMEOUT) {\n            goto retry;\n        } else {\n            elapsed = (PRIntervalTime) (PR_IntervalNow() - start);\n            if (elapsed > timeout) {\n                rv = 0;  /* timed out */\n            } else {\n                remaining = timeout - elapsed;\n                tv.tv_sec = (PRInt32)PR_IntervalToSeconds(remaining);\n                tv.tv_usec = (PRInt32)PR_IntervalToMicroseconds(\n                        remaining - PR_SecondsToInterval(tv.tv_sec));\n                goto retry;\n            }\n        }\n    }\n\n    if (rv > 0) {\n        _PR_setset(pr_rd, &rd);\n        _PR_setset(pr_wr, &wr);\n        _PR_setset(pr_ex, &ex);\n    } else if (rv == -1) {\n        pt_MapError(_PR_MD_MAP_SELECT_ERROR, errno);\n    }\n    return rv;\n}\n#endif /* defined(_PR_PTHREADS) */\n\n#ifdef MOZ_UNICODE \n/* ================ UTF16 Interfaces ================================ */\nPR_IMPLEMENT(PRFileDesc*) PR_OpenFileUTF16(\n    const PRUnichar *name, PRIntn flags, PRIntn mode)\n{\n    PR_SetError(PR_NOT_IMPLEMENTED_ERROR, 0);\n    return NULL;\n}\n\nPR_IMPLEMENT(PRStatus) PR_CloseDirUTF16(PRDir *dir)\n{\n    PR_SetError(PR_NOT_IMPLEMENTED_ERROR, 0);\n    return PR_FAILURE;\n}\n\nPR_IMPLEMENT(PRDirUTF16*) PR_OpenDirUTF16(const PRUnichar *name)\n{\n    PR_SetError(PR_NOT_IMPLEMENTED_ERROR, 0);\n    return NULL;\n}\n\nPR_IMPLEMENT(PRDirEntryUTF16*) PR_ReadDirUTF16(PRDirUTF16 *dir, PRDirFlags flags)\n{\n    PR_SetError(PR_NOT_IMPLEMENTED_ERROR, 0);\n    return NULL;\n}\n\nPR_IMPLEMENT(PRStatus) PR_GetFileInfo64UTF16(const PRUnichar *fn, PRFileInfo64 *info)\n{\n    PR_SetError(PR_NOT_IMPLEMENTED_ERROR, 0);\n    return PR_FAILURE;\n}\n/* ================ UTF16 Interfaces ================================ */\n#endif /* MOZ_UNICODE */\n\n/* ptio.c */\n",
        "/tmp/vanessa/spack-stage/spack-stage-nspr-4.13.1-vntc7ai7kqzc4riwwqstomskyuugrvqz/spack-src/nspr/pr/src/md/unix/aix.c": "/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n#include \"primpl.h\"\n\n#ifdef AIX_HAVE_ATOMIC_OP_H\n#include <sys/atomic_op.h>\n\nPRInt32 _AIX_AtomicSet(PRInt32 *val, PRInt32 newval)\n{\n    PRIntn oldval;\n    boolean_t stored;\n    oldval = fetch_and_add((atomic_p)val, 0);\n    do\n    {\n        stored = compare_and_swap((atomic_p)val, &oldval, newval);\n    } while (!stored);\n    return oldval;\n}  /* _AIX_AtomicSet */\n#endif /* AIX_HAVE_ATOMIC_OP_H */\n\n#if defined(AIX_TIMERS)\n\n#include <sys/time.h>\n\nstatic PRUint32 _aix_baseline_epoch;\n\nstatic void _MD_AixIntervalInit(void)\n{\n    timebasestruct_t real_time;\n    read_real_time(&real_time, TIMEBASE_SZ);\n    (void)time_base_to_time(&real_time, TIMEBASE_SZ);\n    _aix_baseline_epoch = real_time.tb_high;\n}  /* _MD_AixIntervalInit */\n\nPRIntervalTime _MD_AixGetInterval(void)\n{\n    PRIntn rv;\n    PRUint64 temp;\n    timebasestruct_t real_time;\n    read_real_time(&real_time, TIMEBASE_SZ);\n    (void)time_base_to_time(&real_time, TIMEBASE_SZ);\n    /* tb_high is in seconds, tb_low in 10(-9)seconds */\n    temp = 1000000000ULL * (PRUint64)(real_time.tb_high - _aix_baseline_epoch);\n    temp += (PRUint64)real_time.tb_low;  /* everything's 10(-9) seconds */\n    temp >>= 16;  /* now it's something way different */\n    return (PRIntervalTime)temp;\n}  /* _MD_AixGetInterval */\n\nPRIntervalTime _MD_AixIntervalPerSec(void)\n{\n    return 1000000000ULL >> 16;  /* that's 15258, I think */\n}  /* _MD_AixIntervalPerSec */\n\n#endif /* defined(AIX_TIMERS) */\n\n#if !defined(PTHREADS_USER)\n\n#if defined(_PR_PTHREADS)\n\n/*\n * AIX 4.3 has sched_yield().  AIX 4.2 has pthread_yield().\n * So we look up the appropriate function pointer at run time.\n */\n\n#include <dlfcn.h>\n\nint (*_PT_aix_yield_fcn)() = NULL;\nint _pr_aix_send_file_use_disabled = 0;\n\nvoid _MD_EarlyInit(void)\n{\n    void *main_app_handle;\n\tchar *evp;\n\n    main_app_handle = dlopen(NULL, RTLD_NOW);\n    PR_ASSERT(NULL != main_app_handle);\n\n    _PT_aix_yield_fcn = (int(*)())dlsym(main_app_handle, \"sched_yield\");\n    if (!_PT_aix_yield_fcn) {\n        _PT_aix_yield_fcn = (int(*)())dlsym(main_app_handle,\"pthread_yield\");\n        PR_ASSERT(NULL != _PT_aix_yield_fcn);\n    }\n    dlclose(main_app_handle);\n\n\tif (evp = getenv(\"NSPR_AIX_SEND_FILE_USE_DISABLED\")) {\n\t\tif (1 == atoi(evp))\n\t\t\t_pr_aix_send_file_use_disabled = 1;\n\t}\n\n#if defined(AIX_TIMERS)\n    _MD_AixIntervalInit();\n#endif\n}\n\n#else /* _PR_PTHREADS */\n\nvoid _MD_EarlyInit(void)\n{\n#if defined(AIX_TIMERS)\n    _MD_AixIntervalInit();\n#endif\n}\n\n#endif /* _PR_PTHREADS */\n\nPRWord *_MD_HomeGCRegisters(PRThread *t, int isCurrent, int *np)\n{\n#ifndef _PR_PTHREADS\n    if (isCurrent) {\n\t(void) setjmp(CONTEXT(t));\n    }\n    *np = sizeof(CONTEXT(t)) / sizeof(PRWord);\n    return (PRWord *) CONTEXT(t);\n#else\n\t*np = 0;\n\treturn NULL;\n#endif\n}\n\n#ifndef _PR_PTHREADS\nPR_IMPLEMENT(void)\n_MD_SET_PRIORITY(_MDThread *thread, PRUintn newPri)\n{\n    return;\n}\n\nPR_IMPLEMENT(PRStatus)\n_MD_InitializeThread(PRThread *thread)\n{\n\treturn PR_SUCCESS;\n}\n\nPR_IMPLEMENT(PRStatus)\n_MD_WAIT(PRThread *thread, PRIntervalTime ticks)\n{\n    PR_ASSERT(!(thread->flags & _PR_GLOBAL_SCOPE));\n    _PR_MD_SWITCH_CONTEXT(thread);\n    return PR_SUCCESS;\n}\n\nPR_IMPLEMENT(PRStatus)\n_MD_WAKEUP_WAITER(PRThread *thread)\n{\n    if (thread) {\n\tPR_ASSERT(!(thread->flags & _PR_GLOBAL_SCOPE));\n    }\n    return PR_SUCCESS;\n}\n\n/* These functions should not be called for AIX */\nPR_IMPLEMENT(void)\n_MD_YIELD(void)\n{\n    PR_NOT_REACHED(\"_MD_YIELD should not be called for AIX.\");\n}\n\nPR_IMPLEMENT(PRStatus)\n_MD_CREATE_THREAD(\n    PRThread *thread,\n    void (*start) (void *),\n    PRThreadPriority priority,\n    PRThreadScope scope,\n    PRThreadState state,\n    PRUint32 stackSize)\n{\n    PR_NOT_REACHED(\"_MD_CREATE_THREAD should not be called for AIX.\");\n}\n#endif /* _PR_PTHREADS */\n#endif /* PTHREADS_USER */\n\n/*\n * NSPR 2.0 overrides the system select() and poll() functions.\n * On AIX 4.2, we use dlopen(\"/unix\", RTLD_NOW) and dlsym() to get\n * at the original system select() and poll() functions.\n */\n\n#if !defined(AIX_RENAME_SELECT)\n\n#include <sys/select.h>\n#include <sys/poll.h>\n#include <dlfcn.h>\n\nstatic int (*aix_select_fcn)() = NULL;\nstatic int (*aix_poll_fcn)() = NULL;\n\nint _MD_SELECT(int width, fd_set *r, fd_set *w, fd_set *e, struct timeval *t)\n{\n    int rv;\n\n    if (!aix_select_fcn) {\n        void *aix_handle;\n\n\taix_handle = dlopen(\"/unix\", RTLD_NOW);\n\tif (!aix_handle) {\n\t    PR_SetError(PR_UNKNOWN_ERROR, 0);\n\t    return -1;\n\t}\n\taix_select_fcn = (int(*)())dlsym(aix_handle,\"select\");\n        dlclose(aix_handle);\n\tif (!aix_select_fcn) {\n\t    PR_SetError(PR_UNKNOWN_ERROR, 0);\n\t    return -1;\n\t}\n    }\n    rv = (*aix_select_fcn)(width, r, w, e, t);\n    return rv;\n}\n\nint _MD_POLL(void *listptr, unsigned long nfds, long timeout)\n{\n    int rv;\n\n    if (!aix_poll_fcn) {\n        void *aix_handle;\n\n\taix_handle = dlopen(\"/unix\", RTLD_NOW);\n\tif (!aix_handle) {\n\t    PR_SetError(PR_UNKNOWN_ERROR, 0);\n\t    return -1;\n\t}\n\taix_poll_fcn = (int(*)())dlsym(aix_handle,\"poll\");\n        dlclose(aix_handle);\n\tif (!aix_poll_fcn) {\n\t    PR_SetError(PR_UNKNOWN_ERROR, 0);\n\t    return -1;\n\t}\n    }\n    rv = (*aix_poll_fcn)(listptr, nfds, timeout);\n    return rv;\n}\n\n#else\n\n/*\n * In AIX versions prior to 4.2, we use the two-step rename/link trick.\n * The binary must contain at least one \"poll\" symbol for linker's rename\n * to work.  So we must have this dummy function that references poll().\n */\n#include <sys/poll.h>\nvoid _pr_aix_dummy()\n{\n    poll(0,0,0);\n}\n\n#endif /* !defined(AIX_RENAME_SELECT) */\n\n#ifdef _PR_HAVE_ATOMIC_CAS\n\n#include \"pratom.h\"\n\n#define _PR_AIX_ATOMIC_LOCK\t-1\n\nPR_IMPLEMENT(void)\nPR_StackPush(PRStack *stack, PRStackElem *stack_elem)\n{\nPRStackElem *addr;\nboolean_t locked = TRUE;\n\n\t/* Is it safe to cast a pointer to an int? */\n\tPR_ASSERT(sizeof(int) == sizeof(PRStackElem *));\n\tdo {\n\t\twhile ((addr = stack->prstk_head.prstk_elem_next) ==\n\t\t\t\t\t\t\t\t\t\t\t(PRStackElem *)_PR_AIX_ATOMIC_LOCK)\n\t\t\t;\n\t\tlocked = _check_lock((atomic_p) &stack->prstk_head.prstk_elem_next,\n\t\t\t\t\t\t\t(int) addr, _PR_AIX_ATOMIC_LOCK);\n\t} while (locked == TRUE);\n\tstack_elem->prstk_elem_next = addr;\n\t_clear_lock((atomic_p)&stack->prstk_head.prstk_elem_next, (int)stack_elem);\n    return;\n}\n\nPR_IMPLEMENT(PRStackElem *)\nPR_StackPop(PRStack *stack)\n{\nPRStackElem *element;\nboolean_t locked = TRUE;\n\n\t/* Is it safe to cast a pointer to an int? */\n\tPR_ASSERT(sizeof(int) == sizeof(PRStackElem *));\n\tdo {\n\t\twhile ((element = stack->prstk_head.prstk_elem_next) ==\n\t\t\t\t\t\t\t\t\t\t(PRStackElem *) _PR_AIX_ATOMIC_LOCK)\n\t\t\t;\n\t\tlocked = _check_lock((atomic_p) &stack->prstk_head.prstk_elem_next,\n\t\t\t\t\t\t\t(int)element, _PR_AIX_ATOMIC_LOCK);\n\t} while (locked == TRUE);\n\n\tif (element == NULL) {\n\t\t_clear_lock((atomic_p) &stack->prstk_head.prstk_elem_next, NULL);\n\t} else {\n\t\t_clear_lock((atomic_p) &stack->prstk_head.prstk_elem_next,\n\t\t\t\t\t\t\t\t\t\t(int) element->prstk_elem_next);\n\t}\n\treturn element;\n}\n\n#endif\t/* _PR_HAVE_ATOMIC_CAS */\n",
        "/tmp/vanessa/spack-stage/spack-stage-nspr-4.13.1-vntc7ai7kqzc4riwwqstomskyuugrvqz/spack-src/nspr/pr/src/md/unix/irix.c": "/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n#include \"primpl.h\"\n\n#include <signal.h>\n\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <sys/syssgi.h>\n#include <sys/time.h>\n#include <sys/immu.h>\n#include <sys/utsname.h>\n#include <sys/sysmp.h>\n#include <sys/pda.h>\n#include <sys/prctl.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/procfs.h>\n#include <task.h>\n#include <dlfcn.h>\n\nstatic void _MD_IrixIntervalInit(void);\n\n#if defined(_PR_PTHREADS)\n/*\n * for compatibility with classic nspr\n */\nvoid _PR_IRIX_CHILD_PROCESS()\n{\n}\n#else  /* defined(_PR_PTHREADS) */\n\nstatic void irix_detach_sproc(void);\nchar *_nspr_sproc_private;    /* ptr. to private region in every sproc */\n\nextern PRUintn    _pr_numCPU;\n\ntypedef struct nspr_arena {\n\tPRCList links;\n\tusptr_t *usarena;\n} nspr_arena;\n\n#define ARENA_PTR(qp) \\\n\t((nspr_arena *) ((char*) (qp) - offsetof(nspr_arena , links)))\n\nstatic usptr_t *alloc_new_arena(void);\n\nPRCList arena_list = PR_INIT_STATIC_CLIST(&arena_list);\nulock_t arena_list_lock;\nnspr_arena first_arena;\nint\t_nspr_irix_arena_cnt = 1;\n\nPRCList sproc_list = PR_INIT_STATIC_CLIST(&sproc_list);\nulock_t sproc_list_lock;\n\ntypedef struct sproc_data {\n\tvoid (*entry) (void *, size_t);\n\tunsigned inh;\n\tvoid *arg;\n\tcaddr_t sp;\n\tsize_t len;\n\tint *pid;\n\tint creator_pid;\n} sproc_data;\n\ntypedef struct sproc_params {\n\tPRCList links;\n\tsproc_data sd;\n} sproc_params;\n\n#define SPROC_PARAMS_PTR(qp) \\\n\t((sproc_params *) ((char*) (qp) - offsetof(sproc_params , links)))\n\nlong\t_nspr_irix_lock_cnt = 0;\nlong\t_nspr_irix_sem_cnt = 0;\nlong\t_nspr_irix_pollsem_cnt = 0;\n\nusptr_t *_pr_usArena;\nulock_t _pr_heapLock;\n\nusema_t *_pr_irix_exit_sem;\nPRInt32 _pr_irix_exit_now = 0;\nPRInt32 _pr_irix_process_exit_code = 0;\t/* exit code for PR_ProcessExit */\nPRInt32 _pr_irix_process_exit = 0; /* process exiting due to call to\n\t\t\t\t\t\t\t\t\t\t   PR_ProcessExit */\n\nint _pr_irix_primoridal_cpu_fd[2] = { -1, -1 };\nstatic void (*libc_exit)(int) = NULL;\nstatic void *libc_handle = NULL;\n\n#define _NSPR_DEF_INITUSERS\t\t100\t/* default value of CONF_INITUSERS */\n#define _NSPR_DEF_INITSIZE\t\t(4 * 1024 * 1024)\t/* 4 MB */\n\nint _irix_initusers = _NSPR_DEF_INITUSERS;\nint _irix_initsize = _NSPR_DEF_INITSIZE;\n\nPRIntn _pr_io_in_progress, _pr_clock_in_progress;\n\nPRInt32 _pr_md_irix_sprocs_created, _pr_md_irix_sprocs_failed;\nPRInt32 _pr_md_irix_sprocs = 1;\nPRCList _pr_md_irix_sproc_list =\nPR_INIT_STATIC_CLIST(&_pr_md_irix_sproc_list);\n\nsigset_t ints_off;\nextern sigset_t timer_set;\n\n#if !defined(PR_SETABORTSIG)\n#define PR_SETABORTSIG 18\n#endif\n/*\n * terminate the entire application if any sproc exits abnormally\n */\nPRBool _nspr_terminate_on_error = PR_TRUE;\n\n/*\n * exported interface to set the shared arena parameters\n */\nvoid _PR_Irix_Set_Arena_Params(PRInt32 initusers, PRInt32 initsize)\n{\n    _irix_initusers = initusers;\n    _irix_initsize = initsize;\n}\n\nstatic usptr_t *alloc_new_arena()\n{\n    return(usinit(\"/dev/zero\"));\n}\n\nstatic PRStatus new_poll_sem(struct _MDThread *mdthr, int val)\n{\nPRIntn _is;\nPRStatus rv = PR_SUCCESS;\nusema_t *sem = NULL;\nPRCList *qp;\nnspr_arena *arena;\nusptr_t *irix_arena;\nPRThread *me = _MD_GET_ATTACHED_THREAD();\t\n\n\tif (me && !_PR_IS_NATIVE_THREAD(me))\n\t\t_PR_INTSOFF(_is); \n\t_PR_LOCK(arena_list_lock);\n\tfor (qp = arena_list.next; qp != &arena_list; qp = qp->next) {\n\t\tarena = ARENA_PTR(qp);\n\t\tsem = usnewpollsema(arena->usarena, val);\n\t\tif (sem != NULL) {\n\t\t\tmdthr->cvar_pollsem = sem;\n\t\t\tmdthr->pollsem_arena = arena->usarena;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (sem == NULL) {\n\t\t/*\n\t\t * If no space left in the arena allocate a new one.\n\t\t */\n\t\tif (errno == ENOMEM) {\n\t\t\tarena = PR_NEWZAP(nspr_arena);\n\t\t\tif (arena != NULL) {\n\t\t\t\tirix_arena = alloc_new_arena();\n\t\t\t\tif (irix_arena) {\n\t\t\t\t\tPR_APPEND_LINK(&arena->links, &arena_list);\n\t\t\t\t\t_nspr_irix_arena_cnt++;\n\t\t\t\t\tarena->usarena = irix_arena;\n\t\t\t\t\tsem = usnewpollsema(arena->usarena, val);\n\t\t\t\t\tif (sem != NULL) {\n\t\t\t\t\t\tmdthr->cvar_pollsem = sem;\n\t\t\t\t\t\tmdthr->pollsem_arena = arena->usarena;\n\t\t\t\t\t} else\n\t\t\t\t\t\trv = PR_FAILURE;\n\t\t\t\t} else {\n\t\t\t\t\tPR_DELETE(arena);\n\t\t\t\t\trv = PR_FAILURE;\n\t\t\t\t}\n\n\t\t\t} else\n\t\t\t\trv = PR_FAILURE;\n\t\t} else\n\t\t\trv = PR_FAILURE;\n\t}\n\t_PR_UNLOCK(arena_list_lock);\n\tif (me && !_PR_IS_NATIVE_THREAD(me))\n\t\t_PR_FAST_INTSON(_is);\n\tif (rv == PR_SUCCESS)\n\t\t_MD_ATOMIC_INCREMENT(&_nspr_irix_pollsem_cnt);\n\treturn rv;\n}\n\nstatic void free_poll_sem(struct _MDThread *mdthr)\n{\nPRIntn _is;\nPRThread *me = _MD_GET_ATTACHED_THREAD();\t\n\n\tif (me && !_PR_IS_NATIVE_THREAD(me))\n\t\t_PR_INTSOFF(_is); \n\tusfreepollsema(mdthr->cvar_pollsem, mdthr->pollsem_arena);\n\tif (me && !_PR_IS_NATIVE_THREAD(me))\n\t\t_PR_FAST_INTSON(_is);\n\t_MD_ATOMIC_DECREMENT(&_nspr_irix_pollsem_cnt);\n}\n\nstatic PRStatus new_lock(struct _MDLock *lockp)\n{\nPRIntn _is;\nPRStatus rv = PR_SUCCESS;\nulock_t lock = NULL;\nPRCList *qp;\nnspr_arena *arena;\nusptr_t *irix_arena;\nPRThread *me = _MD_GET_ATTACHED_THREAD();\t\n\n\tif (me && !_PR_IS_NATIVE_THREAD(me))\n\t\t_PR_INTSOFF(_is); \n\t_PR_LOCK(arena_list_lock);\n\tfor (qp = arena_list.next; qp != &arena_list; qp = qp->next) {\n\t\tarena = ARENA_PTR(qp);\n\t\tlock = usnewlock(arena->usarena);\n\t\tif (lock != NULL) {\n\t\t\tlockp->lock = lock;\n\t\t\tlockp->arena = arena->usarena;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (lock == NULL) {\n\t\t/*\n\t\t * If no space left in the arena allocate a new one.\n\t\t */\n\t\tif (errno == ENOMEM) {\n\t\t\tarena = PR_NEWZAP(nspr_arena);\n\t\t\tif (arena != NULL) {\n\t\t\t\tirix_arena = alloc_new_arena();\n\t\t\t\tif (irix_arena) {\n\t\t\t\t\tPR_APPEND_LINK(&arena->links, &arena_list);\n\t\t\t\t\t_nspr_irix_arena_cnt++;\n\t\t\t\t\tarena->usarena = irix_arena;\n\t\t\t\t\tlock = usnewlock(irix_arena);\n\t\t\t\t\tif (lock != NULL) {\n\t\t\t\t\t\tlockp->lock = lock;\n\t\t\t\t\t\tlockp->arena = arena->usarena;\n\t\t\t\t\t} else\n\t\t\t\t\t\trv = PR_FAILURE;\n\t\t\t\t} else {\n\t\t\t\t\tPR_DELETE(arena);\n\t\t\t\t\trv = PR_FAILURE;\n\t\t\t\t}\n\n\t\t\t} else\n\t\t\t\trv = PR_FAILURE;\n\t\t} else\n\t\t\trv = PR_FAILURE;\n\t}\n\t_PR_UNLOCK(arena_list_lock);\n\tif (me && !_PR_IS_NATIVE_THREAD(me))\n\t\t_PR_FAST_INTSON(_is);\n\tif (rv == PR_SUCCESS)\n\t\t_MD_ATOMIC_INCREMENT(&_nspr_irix_lock_cnt);\n\treturn rv;\n}\n\nstatic void free_lock(struct _MDLock *lockp)\n{\nPRIntn _is;\nPRThread *me = _MD_GET_ATTACHED_THREAD();\t\n\n\tif (me && !_PR_IS_NATIVE_THREAD(me))\n\t\t_PR_INTSOFF(_is); \n\tusfreelock(lockp->lock, lockp->arena);\n\tif (me && !_PR_IS_NATIVE_THREAD(me))\n\t\t_PR_FAST_INTSON(_is);\n\t_MD_ATOMIC_DECREMENT(&_nspr_irix_lock_cnt);\n}\n\nvoid _MD_FREE_LOCK(struct _MDLock *lockp)\n{\n\tPRIntn _is;\n\tPRThread *me = _MD_GET_ATTACHED_THREAD();\t\n\n\tif (me && !_PR_IS_NATIVE_THREAD(me))\n\t\t_PR_INTSOFF(_is); \n\tfree_lock(lockp);\n\tif (me && !_PR_IS_NATIVE_THREAD(me))\n\t\t_PR_FAST_INTSON(_is);\n}\n\n/*\n * _MD_get_attached_thread\n *\t\tReturn the thread pointer of the current thread if it is attached.\n *\n *\t\tThis function is needed for Irix because the thread-local-storage is\n *\t\timplemented by mmapin'g a page with the MAP_LOCAL flag. This causes the\n *\t\tsproc-private page to inherit contents of the page of the caller of sproc().\n */\nPRThread *_MD_get_attached_thread(void)\n{\n\n\tif (_MD_GET_SPROC_PID() == get_pid())\n\t\treturn _MD_THIS_THREAD();\n\telse\n\t\treturn 0;\n}\n\n/*\n * _MD_get_current_thread\n *\t\tReturn the thread pointer of the current thread (attaching it if\n *\t\tnecessary)\n */\nPRThread *_MD_get_current_thread(void)\n{\nPRThread *me;\n\n\tme = _MD_GET_ATTACHED_THREAD();\n    if (NULL == me) {\n        me = _PRI_AttachThread(\n            PR_USER_THREAD, PR_PRIORITY_NORMAL, NULL, 0);\n    }\n    PR_ASSERT(me != NULL);\n\treturn(me);\n}\n\n/*\n * irix_detach_sproc\n *\t\tauto-detach a sproc when it exits\n */\nvoid irix_detach_sproc(void)\n{\nPRThread *me;\n\n\tme = _MD_GET_ATTACHED_THREAD();\n\tif ((me != NULL) && (me->flags & _PR_ATTACHED)) {\n\t\t_PRI_DetachThread();\n\t}\n}\n\n\nPRStatus _MD_NEW_LOCK(struct _MDLock *lockp)\n{\n    PRStatus rv;\n    PRIntn is;\n    PRThread *me = _MD_GET_ATTACHED_THREAD();\t\n\n\tif (me && !_PR_IS_NATIVE_THREAD(me))\n\t\t_PR_INTSOFF(is);\n\trv = new_lock(lockp);\n\tif (me && !_PR_IS_NATIVE_THREAD(me))\n\t\t_PR_FAST_INTSON(is);\n\treturn rv;\n}\n\nstatic void\nsigchld_handler(int sig)\n{\n    pid_t pid;\n    int status;\n\n    /*\n     * If an sproc exited abnormally send a SIGKILL signal to all the\n     * sprocs in the process to terminate the application\n     */\n    while ((pid = waitpid(0, &status, WNOHANG)) > 0) {\n        if (WIFSIGNALED(status) && ((WTERMSIG(status) == SIGSEGV) ||\n            (WTERMSIG(status) == SIGBUS) ||\n            (WTERMSIG(status) == SIGABRT) ||\n            (WTERMSIG(status) == SIGILL))) {\n\n\t\t\t\tprctl(PR_SETEXITSIG, SIGKILL);\n\t\t\t\t_exit(status);\n\t\t\t}\n    }\n}\n\nstatic void save_context_and_block(int sig)\n{\nPRThread *me = _PR_MD_CURRENT_THREAD();\n_PRCPU *cpu = _PR_MD_CURRENT_CPU();\n\n\t/*\n\t * save context\n\t */\n\t(void) setjmp(me->md.jb);\n\t/*\n\t * unblock the suspending thread\n\t */\n\tif (me->cpu) {\n\t\t/*\n\t\t * I am a cpu thread, not a user-created GLOBAL thread\n\t\t */\n\t\tunblockproc(cpu->md.suspending_id);\t\n\t} else {\n\t\tunblockproc(me->md.suspending_id);\t\n\t}\n\t/*\n\t * now, block current thread\n\t */\n\tblockproc(getpid());\n}\n\n/*\n** The irix kernel has a bug in it which causes async connect's which are\n** interrupted by a signal to fail terribly (EADDRINUSE is returned). \n** We work around the bug by blocking signals during the async connect\n** attempt.\n*/\nPRInt32 _MD_irix_connect(\n    PRInt32 osfd, const PRNetAddr *addr, PRInt32 addrlen, PRIntervalTime timeout)\n{\n    PRInt32 rv;\n    sigset_t oldset;\n\n    sigprocmask(SIG_BLOCK, &ints_off, &oldset);\n    rv = connect(osfd, addr, addrlen);\n    sigprocmask(SIG_SETMASK, &oldset, 0);\n\n    return(rv);\n}\n\n#include \"prprf.h\"\n\n/********************************************************************/\n/********************************************************************/\n/*************** Various thread like things for IRIX ****************/\n/********************************************************************/\n/********************************************************************/\n\nvoid *_MD_GetSP(PRThread *t)\n{\n    PRThread *me = _PR_MD_CURRENT_THREAD();\n    void *sp;\n\n    if (me == t)\n        (void) setjmp(t->md.jb);\n\n    sp = (void *)(t->md.jb[JB_SP]);\n    PR_ASSERT((sp >= (void *) t->stack->stackBottom) &&\n        (sp <= (void *) (t->stack->stackBottom + t->stack->stackSize)));\n    return(sp);\n}\n\nvoid _MD_InitLocks()\n{\n    char buf[200];\n    char *init_users, *init_size;\n\n    PR_snprintf(buf, sizeof(buf), \"/dev/zero\");\n\n    if (init_users = getenv(\"_NSPR_IRIX_INITUSERS\"))\n        _irix_initusers = atoi(init_users);\n\n    if (init_size = getenv(\"_NSPR_IRIX_INITSIZE\"))\n        _irix_initsize = atoi(init_size);\n\n    usconfig(CONF_INITUSERS, _irix_initusers);\n    usconfig(CONF_INITSIZE, _irix_initsize);\n    usconfig(CONF_AUTOGROW, 1);\n    usconfig(CONF_AUTORESV, 1);\n\tif (usconfig(CONF_ARENATYPE, US_SHAREDONLY) < 0) {\n\t\tperror(\"PR_Init: unable to config mutex arena\");\n\t\texit(-1);\n\t}\n\n    _pr_usArena = usinit(buf);\n    if (!_pr_usArena) {\n        fprintf(stderr,\n            \"PR_Init: Error - unable to create lock/monitor arena\\n\");\n        exit(-1);\n    }\n    _pr_heapLock = usnewlock(_pr_usArena);\n\t_nspr_irix_lock_cnt++;\n\n    arena_list_lock = usnewlock(_pr_usArena);\n\t_nspr_irix_lock_cnt++;\n\n    sproc_list_lock = usnewlock(_pr_usArena);\n\t_nspr_irix_lock_cnt++;\n\n\t_pr_irix_exit_sem = usnewsema(_pr_usArena, 0);\n\t_nspr_irix_sem_cnt = 1;\n\n\tfirst_arena.usarena = _pr_usArena;\n\tPR_INIT_CLIST(&first_arena.links);\n\tPR_APPEND_LINK(&first_arena.links, &arena_list);\n}\n\n/* _PR_IRIX_CHILD_PROCESS is a private API for Server group */\nvoid _PR_IRIX_CHILD_PROCESS()\n{\nextern PRUint32 _pr_global_threads;\n\n    PR_ASSERT(_PR_MD_CURRENT_CPU() == _pr_primordialCPU);\n    PR_ASSERT(_pr_numCPU == 1);\n    PR_ASSERT(_pr_global_threads == 0);\n    /*\n     * save the new pid\n     */\n    _pr_primordialCPU->md.id = getpid();\n\t_MD_SET_SPROC_PID(getpid());\t\n}\n\nstatic PRStatus pr_cvar_wait_sem(PRThread *thread, PRIntervalTime timeout)\n{\n    int rv;\n\n#ifdef _PR_USE_POLL\n\tstruct pollfd pfd;\n\tint msecs;\n\n\tif (timeout == PR_INTERVAL_NO_TIMEOUT)\n\t\tmsecs = -1;\n\telse\n\t\tmsecs  = PR_IntervalToMilliseconds(timeout);\n#else\n    struct timeval tv, *tvp;\n    fd_set rd;\n\n\tif(timeout == PR_INTERVAL_NO_TIMEOUT)\n\t\ttvp = NULL;\n\telse {\n\t\ttv.tv_sec = PR_IntervalToSeconds(timeout);\n\t\ttv.tv_usec = PR_IntervalToMicroseconds(\n\t\ttimeout - PR_SecondsToInterval(tv.tv_sec));\n\t\ttvp = &tv;\n\t}\n\tFD_ZERO(&rd);\n\tFD_SET(thread->md.cvar_pollsemfd, &rd);\n#endif\n\n    /*\n     * call uspsema only if a previous select call on this semaphore\n     * did not timeout\n     */\n    if (!thread->md.cvar_pollsem_select) {\n        rv = _PR_WAIT_SEM(thread->md.cvar_pollsem);\n\t\tPR_ASSERT(rv >= 0);\n\t} else\n        rv = 0;\nagain:\n    if(!rv) {\n#ifdef _PR_USE_POLL\n\t\tpfd.events = POLLIN;\n\t\tpfd.fd = thread->md.cvar_pollsemfd;\n\t\trv = _MD_POLL(&pfd, 1, msecs);\n#else\n\t\trv = _MD_SELECT(thread->md.cvar_pollsemfd + 1, &rd, NULL,NULL,tvp);\n#endif\n        if ((rv == -1) && (errno == EINTR)) {\n\t\t\trv = 0;\n\t\t\tgoto again;\n\t\t}\n\t\tPR_ASSERT(rv >= 0);\n\t}\n\n    if (rv > 0) {\n        /*\n         * acquired the semaphore, call uspsema next time\n         */\n        thread->md.cvar_pollsem_select = 0;\n        return PR_SUCCESS;\n    } else {\n        /*\n         * select timed out; must call select, not uspsema, when trying\n         * to acquire the semaphore the next time\n         */\n        thread->md.cvar_pollsem_select = 1;\n        return PR_FAILURE;\n    }\n}\n\nPRStatus _MD_wait(PRThread *thread, PRIntervalTime ticks)\n{\n    if ( thread->flags & _PR_GLOBAL_SCOPE ) {\n\t_MD_CHECK_FOR_EXIT();\n        if (pr_cvar_wait_sem(thread, ticks) == PR_FAILURE) {\n\t    _MD_CHECK_FOR_EXIT();\n            /*\n             * wait timed out\n             */\n            _PR_THREAD_LOCK(thread);\n            if (thread->wait.cvar) {\n                /*\n                 * The thread will remove itself from the waitQ\n                 * of the cvar in _PR_WaitCondVar\n                 */\n                thread->wait.cvar = NULL;\n                thread->state =  _PR_RUNNING;\n                _PR_THREAD_UNLOCK(thread);\n            }  else {\n                _PR_THREAD_UNLOCK(thread);\n                /*\n             * This thread was woken up by a notifying thread\n             * at the same time as a timeout; so, consume the\n             * extra post operation on the semaphore\n             */\n\t        _MD_CHECK_FOR_EXIT();\n            pr_cvar_wait_sem(thread, PR_INTERVAL_NO_TIMEOUT);\n            }\n\t    _MD_CHECK_FOR_EXIT();\n        }\n    } else {\n        _PR_MD_SWITCH_CONTEXT(thread);\n    }\n    return PR_SUCCESS;\n}\n\nPRStatus _MD_WakeupWaiter(PRThread *thread)\n{\n    PRThread *me = _PR_MD_CURRENT_THREAD();\n    PRIntn is;\n\n\tPR_ASSERT(_pr_md_idle_cpus >= 0);\n    if (thread == NULL) {\n\t\tif (_pr_md_idle_cpus)\n        \t_MD_Wakeup_CPUs();\n    } else if (!_PR_IS_NATIVE_THREAD(thread)) {\n\t\tif (_pr_md_idle_cpus)\n       \t\t_MD_Wakeup_CPUs();\n    } else {\n\t\tPR_ASSERT(_PR_IS_NATIVE_THREAD(thread));\n\t\tif (!_PR_IS_NATIVE_THREAD(me))\n\t\t\t_PR_INTSOFF(is);\n\t\t_MD_CVAR_POST_SEM(thread);\n\t\tif (!_PR_IS_NATIVE_THREAD(me))\n\t\t\t_PR_FAST_INTSON(is);\n    } \n    return PR_SUCCESS;\n}\n\nvoid create_sproc (void (*entry) (void *, size_t), unsigned inh,\n\t\t\t\t\tvoid *arg, caddr_t sp, size_t len, int *pid)\n{\nsproc_params sparams;\nchar data;\nint rv;\nPRThread *me = _PR_MD_CURRENT_THREAD();\n\n\tif (!_PR_IS_NATIVE_THREAD(me) && (_PR_MD_CURRENT_CPU()->id == 0)) {\n\t\t*pid = sprocsp(entry,\t\t/* startup func\t\t*/\n\t\t\t\t\t\tinh,        /* attribute flags\t*/\n\t\t\t\t\t\targ,     \t/* thread param\t\t*/\n\t\t\t\t\t\tsp,         /* stack address\t*/\n\t\t\t\t\t\tlen);       /* stack size\t\t*/\n\t} else {\n\t\tsparams.sd.entry = entry;\n\t\tsparams.sd.inh = inh;\n\t\tsparams.sd.arg = arg;\n\t\tsparams.sd.sp = sp;\n\t\tsparams.sd.len = len;\n\t\tsparams.sd.pid = pid;\n\t\tsparams.sd.creator_pid = getpid();\n\t\t_PR_LOCK(sproc_list_lock);\n\t\tPR_APPEND_LINK(&sparams.links, &sproc_list);\n\t\trv = write(_pr_irix_primoridal_cpu_fd[1], &data, 1);\n\t\tPR_ASSERT(rv == 1);\n\t\t_PR_UNLOCK(sproc_list_lock);\n\t\tblockproc(getpid());\n\t}\n}\n\n/*\n * _PR_MD_WAKEUP_PRIMORDIAL_CPU\n *\n *\t\twakeup cpu 0\n */\n\nvoid _PR_MD_WAKEUP_PRIMORDIAL_CPU()\n{\nchar data = '0';\nint rv;\n\n\trv = write(_pr_irix_primoridal_cpu_fd[1], &data, 1);\n\tPR_ASSERT(rv == 1);\n}\n\n/*\n * _PR_MD_primordial_cpu\n *\n *\t\tprocess events that need to executed by the primordial cpu on each\n *\t\titeration through the idle loop\n */\n\nvoid _PR_MD_primordial_cpu()\n{\nPRCList *qp;\nsproc_params *sp;\nint pid;\n\n\t_PR_LOCK(sproc_list_lock);\n\twhile ((qp = sproc_list.next) != &sproc_list) {\n\t\tsp = SPROC_PARAMS_PTR(qp);\n\t\tPR_REMOVE_LINK(&sp->links);\n\t\tpid = sp->sd.creator_pid;\n\t\t(*(sp->sd.pid)) = sprocsp(sp->sd.entry,\t\t/* startup func    */\n\t\t\t\t\t\t\tsp->sd.inh,            \t/* attribute flags     */\n\t\t\t\t\t\t\tsp->sd.arg,     \t\t/* thread param     */\n\t\t\t\t\t\t\tsp->sd.sp,             \t/* stack address    */\n\t\t\t\t\t\t\tsp->sd.len);         \t/* stack size     */\n\t\tunblockproc(pid);\n\t}\n\t_PR_UNLOCK(sproc_list_lock);\n}\n\nPRStatus _MD_CreateThread(PRThread *thread, \nvoid (*start)(void *), \nPRThreadPriority priority, \nPRThreadScope scope, \nPRThreadState state, \nPRUint32 stackSize)\n{\n    typedef void (*SprocEntry) (void *, size_t);\n    SprocEntry spentry = (SprocEntry)start;\n    PRIntn is;\n\tPRThread *me = _PR_MD_CURRENT_THREAD();\t\n\tPRInt32 pid;\n\tPRStatus rv;\n\n\tif (!_PR_IS_NATIVE_THREAD(me))\n\t\t_PR_INTSOFF(is);\n    thread->md.cvar_pollsem_select = 0;\n    thread->flags |= _PR_GLOBAL_SCOPE;\n\n\tthread->md.cvar_pollsemfd = -1;\n\tif (new_poll_sem(&thread->md,0) == PR_FAILURE) {\n\t\tif (!_PR_IS_NATIVE_THREAD(me))\n\t\t\t_PR_FAST_INTSON(is);\n\t\treturn PR_FAILURE;\n\t}\n\tthread->md.cvar_pollsemfd =\n\t\t_PR_OPEN_POLL_SEM(thread->md.cvar_pollsem);\n\tif ((thread->md.cvar_pollsemfd < 0)) {\n\t\tfree_poll_sem(&thread->md);\n\t\tif (!_PR_IS_NATIVE_THREAD(me))\n\t\t\t_PR_FAST_INTSON(is);\n\t\treturn PR_FAILURE;\n\t}\n\n    create_sproc(spentry,            /* startup func    */\n    \t\t\tPR_SALL,            /* attribute flags     */\n    \t\t\t(void *)thread,     /* thread param     */\n    \t\t\tNULL,               /* stack address    */\n    \t\t\tstackSize, &pid);         /* stack size     */\n    if (pid > 0) {\n        _MD_ATOMIC_INCREMENT(&_pr_md_irix_sprocs_created);\n        _MD_ATOMIC_INCREMENT(&_pr_md_irix_sprocs);\n\t\trv = PR_SUCCESS;\n\t\tif (!_PR_IS_NATIVE_THREAD(me))\n\t\t\t_PR_FAST_INTSON(is);\n        return rv;\n    } else {\n        close(thread->md.cvar_pollsemfd);\n        thread->md.cvar_pollsemfd = -1;\n\t\tfree_poll_sem(&thread->md);\n        thread->md.cvar_pollsem = NULL;\n        _MD_ATOMIC_INCREMENT(&_pr_md_irix_sprocs_failed);\n\t\tif (!_PR_IS_NATIVE_THREAD(me))\n\t\t\t_PR_FAST_INTSON(is);\n        return PR_FAILURE;\n    }\n}\n\nvoid _MD_CleanThread(PRThread *thread)\n{\n    if (thread->flags & _PR_GLOBAL_SCOPE) {\n        close(thread->md.cvar_pollsemfd);\n        thread->md.cvar_pollsemfd = -1;\n\t\tfree_poll_sem(&thread->md);\n        thread->md.cvar_pollsem = NULL;\n    }\n}\n\nvoid _MD_SetPriority(_MDThread *thread, PRThreadPriority newPri)\n{\n    return;\n}\n\nextern void _MD_unix_terminate_waitpid_daemon(void);\n\nvoid\n_MD_CleanupBeforeExit(void)\n{\n    extern PRInt32    _pr_cpus_exit;\n\n    _MD_unix_terminate_waitpid_daemon();\n\n\t_pr_irix_exit_now = 1;\n    if (_pr_numCPU > 1) {\n        /*\n         * Set a global flag, and wakeup all cpus which will notice the flag\n         * and exit.\n         */\n        _pr_cpus_exit = getpid();\n        _MD_Wakeup_CPUs();\n        while(_pr_numCPU > 1) {\n            _PR_WAIT_SEM(_pr_irix_exit_sem);\n            _pr_numCPU--;\n        }\n    }\n    /*\n     * cause global threads on the recycle list to exit\n     */\n     _PR_DEADQ_LOCK;\n     if (_PR_NUM_DEADNATIVE != 0) {\n\tPRThread *thread;\n    \tPRCList *ptr;\n\n        ptr = _PR_DEADNATIVEQ.next;\n        while( ptr != &_PR_DEADNATIVEQ ) {\n        \tthread = _PR_THREAD_PTR(ptr);\n\t\t_MD_CVAR_POST_SEM(thread);\n                ptr = ptr->next;\n        } \n     }\n     _PR_DEADQ_UNLOCK;\n     while(_PR_NUM_DEADNATIVE > 1) {\n\t_PR_WAIT_SEM(_pr_irix_exit_sem);\n\t_PR_DEC_DEADNATIVE;\n     }\n}\n\n#ifdef _PR_HAVE_SGI_PRDA_PROCMASK\nextern void __sgi_prda_procmask(int);\n#endif\n\nPRStatus\n_MD_InitAttachedThread(PRThread *thread, PRBool wakeup_parent)\n{\n\tPRStatus rv = PR_SUCCESS;\n\n    if (thread->flags & _PR_GLOBAL_SCOPE) {\n\t\tif (new_poll_sem(&thread->md,0) == PR_FAILURE) {\n\t\t\treturn PR_FAILURE;\n\t\t}\n\t\tthread->md.cvar_pollsemfd =\n\t\t\t_PR_OPEN_POLL_SEM(thread->md.cvar_pollsem);\n\t\tif ((thread->md.cvar_pollsemfd < 0)) {\n\t\t\tfree_poll_sem(&thread->md);\n\t\t\treturn PR_FAILURE;\n\t\t}\n\t\tif (_MD_InitThread(thread, PR_FALSE) == PR_FAILURE) {\n\t\t\tclose(thread->md.cvar_pollsemfd);\n\t\t\tthread->md.cvar_pollsemfd = -1;\n\t\t\tfree_poll_sem(&thread->md);\n\t\t\tthread->md.cvar_pollsem = NULL;\n\t\t\treturn PR_FAILURE;\n\t\t}\n    }\n\treturn rv;\n}\n\nPRStatus\n_MD_InitThread(PRThread *thread, PRBool wakeup_parent)\n{\n    struct sigaction sigact;\n\tPRStatus rv = PR_SUCCESS;\n\n    if (thread->flags & _PR_GLOBAL_SCOPE) {\n\t\tthread->md.id = getpid();\n        setblockproccnt(thread->md.id, 0);\n\t\t_MD_SET_SPROC_PID(getpid());\t\n#ifdef _PR_HAVE_SGI_PRDA_PROCMASK\n\t\t/*\n\t\t * enable user-level processing of sigprocmask(); this is an\n\t\t * undocumented feature available in Irix 6.2, 6.3, 6.4 and 6.5\n\t\t */\n\t\t__sgi_prda_procmask(USER_LEVEL);\n#endif\n\t\t/*\n\t\t * set up SIGUSR1 handler; this is used to save state\n\t\t */\n\t\tsigact.sa_handler = save_context_and_block;\n\t\tsigact.sa_flags = SA_RESTART;\n\t\t/*\n\t\t * Must mask clock interrupts\n\t\t */\n\t\tsigact.sa_mask = timer_set;\n\t\tsigaction(SIGUSR1, &sigact, 0);\n\n\n\t\t/*\n\t\t * PR_SETABORTSIG is a new command implemented in a patch to\n\t\t * Irix 6.2, 6.3 and 6.4. This causes a signal to be sent to all\n\t\t * sprocs in the process when one of them terminates abnormally\n\t\t *\n\t\t */\n\t\tif (prctl(PR_SETABORTSIG, SIGKILL) < 0) {\n\t\t\t/*\n\t\t\t *  if (errno == EINVAL)\n\t\t\t *\n\t\t\t *\tPR_SETABORTSIG not supported under this OS.\n\t\t\t *\tYou may want to get a recent kernel rollup patch that\n\t\t\t *\tsupports this feature.\n\t\t\t */\n\t\t}\n\t\t/*\n\t\t * SIGCLD handler for detecting abormally-terminating\n\t\t * sprocs and for reaping sprocs\n\t\t */\n\t\tsigact.sa_handler = sigchld_handler;\n\t\tsigact.sa_flags = SA_RESTART;\n\t\tsigact.sa_mask = ints_off;\n\t\tsigaction(SIGCLD, &sigact, NULL);\n    }\n\treturn rv;\n}\n\n/*\n * PR_Cleanup should be executed on the primordial sproc; migrate the thread\n * to the primordial cpu\n */\n\nvoid _PR_MD_PRE_CLEANUP(PRThread *me)\n{\nPRIntn is;\n_PRCPU *cpu = _pr_primordialCPU;\n\n\tPR_ASSERT(cpu);\n\n\tme->flags |= _PR_BOUND_THREAD;\t\n\n\tif (me->cpu->id != 0) {\n\t\t_PR_INTSOFF(is);\n\t\t_PR_RUNQ_LOCK(cpu);\n\t\tme->cpu = cpu;\n\t\tme->state = _PR_RUNNABLE;\n\t\t_PR_ADD_RUNQ(me, cpu, me->priority);\n\t\t_PR_RUNQ_UNLOCK(cpu);\n\t\t_MD_Wakeup_CPUs();\n\n\t\t_PR_MD_SWITCH_CONTEXT(me);\n\n\t\t_PR_FAST_INTSON(is);\n\t\tPR_ASSERT(me->cpu->id == 0);\n\t}\n}\n\n/*\n * process exiting\n */\nPR_EXTERN(void ) _MD_exit(PRIntn status)\n{\nPRThread *me = _PR_MD_CURRENT_THREAD();\n\n\t/*\n\t * the exit code of the process is the exit code of the primordial\n\t * sproc\n\t */\n\tif (!_PR_IS_NATIVE_THREAD(me) && (_PR_MD_CURRENT_CPU()->id == 0)) {\n\t\t/*\n\t\t * primordial sproc case: call _exit directly\n\t\t * Cause SIGKILL to be sent to other sprocs\n\t\t */\n\t\tprctl(PR_SETEXITSIG, SIGKILL);\n\t\t_exit(status);\n\t} else {\n\t\tint rv;\n\t\tchar data;\n\t\tsigset_t set;\n\n\t\t/*\n\t\t * non-primordial sproc case: cause the primordial sproc, cpu 0,\n\t\t * to wakeup and call _exit\n\t\t */\n\t\t_pr_irix_process_exit = 1;\n\t\t_pr_irix_process_exit_code = status;\n\t\trv = write(_pr_irix_primoridal_cpu_fd[1], &data, 1);\n\t\tPR_ASSERT(rv == 1);\n\t\t/*\n\t\t * block all signals and wait for SIGKILL to terminate this sproc\n\t\t */\n\t\tsigfillset(&set);\n\t\tsigsuspend(&set);\n\t\t/*\n\t\t * this code doesn't (shouldn't) execute\n\t\t */\n\t\tprctl(PR_SETEXITSIG, SIGKILL);\n\t\t_exit(status);\n\t}\n}\n\n/*\n * Override the exit() function in libc to cause the process to exit\n * when the primodial/main nspr thread calls exit. Calls to exit by any\n * other thread simply result in a call to the exit function in libc.\n * The exit code of the process is the exit code of the primordial\n * sproc.\n */\n\nvoid exit(int status)\n{\nPRThread *me, *thr;\nPRCList *qp;\n\n\tif (!_pr_initialized)  {\n\t\tif (!libc_exit) {\n\n\t\t\tif (!libc_handle)\n\t\t\t\tlibc_handle = dlopen(\"libc.so\",RTLD_NOW);\n\t\t\tif (libc_handle)\n\t\t\t\tlibc_exit = (void (*)(int)) dlsym(libc_handle, \"exit\");\n\t\t}\n\t\tif (libc_exit)\n\t\t\t(*libc_exit)(status);\n\t\telse\n\t\t\t_exit(status);\n\t}\n\n\tme = _PR_MD_CURRENT_THREAD();\n\n\tif (me == NULL) \t\t/* detached thread */\n\t\t(*libc_exit)(status);\n\n\tPR_ASSERT(_PR_IS_NATIVE_THREAD(me) ||\n\t\t\t\t\t\t(_PR_MD_CURRENT_CPU())->id == me->cpu->id);\n\n\tif (me->flags & _PR_PRIMORDIAL) {\n\n\t\tme->flags |= _PR_BOUND_THREAD;\t\n\n\t\tPR_ASSERT((_PR_MD_CURRENT_CPU())->id == me->cpu->id);\n\t\tif (me->cpu->id != 0) {\n\t\t\t_PRCPU *cpu = _pr_primordialCPU;\n\t\t\tPRIntn is;\n\n\t\t\t_PR_INTSOFF(is);\n\t\t\t_PR_RUNQ_LOCK(cpu);\n\t\t\tme->cpu = cpu;\n\t\t\tme->state = _PR_RUNNABLE;\n\t\t\t_PR_ADD_RUNQ(me, cpu, me->priority);\n\t\t\t_PR_RUNQ_UNLOCK(cpu);\n\t\t\t_MD_Wakeup_CPUs();\n\n\t\t\t_PR_MD_SWITCH_CONTEXT(me);\n\n\t\t\t_PR_FAST_INTSON(is);\n\t\t}\n\n\t\tPR_ASSERT((_PR_MD_CURRENT_CPU())->id == 0);\n\n\t\tif (prctl(PR_GETNSHARE) > 1) {\n#define SPROC_EXIT_WAIT_TIME 5\n\t\t\tint sleep_cnt = SPROC_EXIT_WAIT_TIME;\n\n\t\t\t/*\n\t\t\t * sprocs still running; caue cpus and recycled global threads\n\t\t\t * to exit\n\t\t\t */\n\t\t\t_pr_irix_exit_now = 1;\n\t\t\tif (_pr_numCPU > 1) {\n\t\t\t\t_MD_Wakeup_CPUs();\n\t\t\t}\n\t\t\t _PR_DEADQ_LOCK;\n\t\t\t if (_PR_NUM_DEADNATIVE != 0) {\n\t\t\t\tPRThread *thread;\n\t\t\t\tPRCList *ptr;\n\n\t\t\t\tptr = _PR_DEADNATIVEQ.next;\n\t\t\t\twhile( ptr != &_PR_DEADNATIVEQ ) {\n\t\t\t\t\tthread = _PR_THREAD_PTR(ptr);\n\t\t\t\t\t_MD_CVAR_POST_SEM(thread);\n\t\t\t\t\tptr = ptr->next;\n\t\t\t\t} \n\t\t\t }\n\n\t\t\twhile (sleep_cnt-- > 0) {\n\t\t\t\tif (waitpid(0, NULL, WNOHANG) >= 0) \n\t\t\t\t\tsleep(1);\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tprctl(PR_SETEXITSIG, SIGKILL);\n\t\t}\n\t\t(*libc_exit)(status);\n\t} else {\n\t\t/*\n\t\t * non-primordial thread; simply call exit in libc.\n\t\t */\n\t\t(*libc_exit)(status);\n\t}\n}\n\n\nvoid\n_MD_InitRunningCPU(_PRCPU *cpu)\n{\n    extern int _pr_md_pipefd[2];\n\n    _MD_unix_init_running_cpu(cpu);\n    cpu->md.id = getpid();\n\t_MD_SET_SPROC_PID(getpid());\t\n\tif (_pr_md_pipefd[0] >= 0) {\n    \t_PR_IOQ_MAX_OSFD(cpu) = _pr_md_pipefd[0];\n#ifndef _PR_USE_POLL\n    \tFD_SET(_pr_md_pipefd[0], &_PR_FD_READ_SET(cpu));\n#endif\n\t}\n}\n\nvoid\n_MD_ExitThread(PRThread *thread)\n{\n    if (thread->flags & _PR_GLOBAL_SCOPE) {\n        _MD_ATOMIC_DECREMENT(&_pr_md_irix_sprocs);\n        _MD_CLEAN_THREAD(thread);\n        _MD_SET_CURRENT_THREAD(NULL);\n    }\n}\n\nvoid\n_MD_SuspendCPU(_PRCPU *cpu)\n{\n    PRInt32 rv;\n\n\tcpu->md.suspending_id = getpid();\n\trv = kill(cpu->md.id, SIGUSR1);\n\tPR_ASSERT(rv == 0);\n\t/*\n\t * now, block the current thread/cpu until woken up by the suspended\n\t * thread from it's SIGUSR1 signal handler\n\t */\n\tblockproc(getpid());\n\n}\n\nvoid\n_MD_ResumeCPU(_PRCPU *cpu)\n{\n    unblockproc(cpu->md.id);\n}\n\n#if 0\n/*\n * save the register context of a suspended sproc\n */\nvoid get_context(PRThread *thr)\n{\n    int len, fd;\n    char pidstr[24];\n    char path[24];\n\n    /*\n     * open the file corresponding to this process in procfs\n     */\n    sprintf(path,\"/proc/%s\",\"00000\");\n    len = strlen(path);\n    sprintf(pidstr,\"%d\",thr->md.id);\n    len -= strlen(pidstr);\n    sprintf(path + len,\"%s\",pidstr);\n    fd = open(path,O_RDONLY);\n    if (fd >= 0) {\n        (void) ioctl(fd, PIOCGREG, thr->md.gregs);\n        close(fd);\n    }\n    return;\n}\n#endif\t/* 0 */\n\nvoid\n_MD_SuspendThread(PRThread *thread)\n{\n    PRInt32 rv;\n\n    PR_ASSERT((thread->flags & _PR_GLOBAL_SCOPE) &&\n        _PR_IS_GCABLE_THREAD(thread));\n\n\tthread->md.suspending_id = getpid();\n\trv = kill(thread->md.id, SIGUSR1);\n\tPR_ASSERT(rv == 0);\n\t/*\n\t * now, block the current thread/cpu until woken up by the suspended\n\t * thread from it's SIGUSR1 signal handler\n\t */\n\tblockproc(getpid());\n}\n\nvoid\n_MD_ResumeThread(PRThread *thread)\n{\n    PR_ASSERT((thread->flags & _PR_GLOBAL_SCOPE) &&\n        _PR_IS_GCABLE_THREAD(thread));\n    (void)unblockproc(thread->md.id);\n}\n\n/*\n * return the set of processors available for scheduling procs in the\n * \"mask\" argument\n */\nPRInt32 _MD_GetThreadAffinityMask(PRThread *unused, PRUint32 *mask)\n{\n    PRInt32 nprocs, rv;\n    struct pda_stat *pstat;\n#define MAX_PROCESSORS    32\n\n    nprocs = sysmp(MP_NPROCS);\n    if (nprocs < 0)\n        return(-1);\n    pstat = (struct pda_stat*)PR_MALLOC(sizeof(struct pda_stat) * nprocs);\n    if (pstat == NULL)\n        return(-1);\n    rv = sysmp(MP_STAT, pstat);\n    if (rv < 0) {\n        PR_DELETE(pstat);\n        return(-1);\n    }\n    /*\n     * look at the first 32 cpus\n     */\n    nprocs = (nprocs > MAX_PROCESSORS) ? MAX_PROCESSORS : nprocs;\n    *mask = 0;\n    while (nprocs) {\n        if ((pstat->p_flags & PDAF_ENABLED) &&\n            !(pstat->p_flags & PDAF_ISOLATED)) {\n            *mask |= (1 << pstat->p_cpuid);\n        }\n        nprocs--;\n        pstat++;\n    }\n    return 0;\n}\n\nstatic char *_thr_state[] = {\n    \"UNBORN\",\n    \"RUNNABLE\",\n    \"RUNNING\",\n    \"LOCK_WAIT\",\n    \"COND_WAIT\",\n    \"JOIN_WAIT\",\n    \"IO_WAIT\",\n    \"SUSPENDED\",\n    \"DEAD\"\n};\n\nvoid _PR_List_Threads()\n{\n    PRThread *thr;\n    void *handle;\n    struct _PRCPU *cpu;\n    PRCList *qp;\n    int len, fd;\n    char pidstr[24];\n    char path[24];\n    prpsinfo_t pinfo;\n\n\n    printf(\"\\n%s %-s\\n\",\" \",\"LOCAL Threads\");\n    printf(\"%s %-s\\n\",\" \",\"----- -------\");\n    printf(\"%s %-14s %-10s %-12s %-3s %-10s %-10s %-12s\\n\\n\",\" \",\n        \"Thread\", \"State\", \"Wait-Handle\",\n        \"Cpu\",\"Stk-Base\",\"Stk-Sz\",\"SP\");\n    for (qp = _PR_ACTIVE_LOCAL_THREADQ().next;\n        qp != &_PR_ACTIVE_LOCAL_THREADQ(); qp = qp->next) {\n        thr = _PR_ACTIVE_THREAD_PTR(qp);\n        printf(\"%s 0x%-12x %-10s \",\" \",thr,_thr_state[thr->state]);\n        if (thr->state == _PR_LOCK_WAIT)\n            handle = thr->wait.lock;\n        else if (thr->state == _PR_COND_WAIT)\n            handle = thr->wait.cvar;\n        else\n            handle = NULL;\n        if (handle)\n            printf(\"0x%-10x \",handle);\n        else\n            printf(\"%-12s \",\" \");\n        printf(\"%-3d \",thr->cpu->id);\n        printf(\"0x%-8x \",thr->stack->stackBottom);\n        printf(\"0x%-8x \",thr->stack->stackSize);\n        printf(\"0x%-10x\\n\",thr->md.jb[JB_SP]);\n    }\n\n    printf(\"\\n%s %-s\\n\",\" \",\"GLOBAL Threads\");\n    printf(\"%s %-s\\n\",\" \",\"------ -------\");\n    printf(\"%s %-14s %-6s %-12s %-12s %-12s %-12s\\n\\n\",\" \",\"Thread\",\n        \"Pid\",\"State\",\"Wait-Handle\",\n        \"Stk-Base\",\"Stk-Sz\");\n\n    for (qp = _PR_ACTIVE_GLOBAL_THREADQ().next;\n        qp != &_PR_ACTIVE_GLOBAL_THREADQ(); qp = qp->next) {\n        thr = _PR_ACTIVE_THREAD_PTR(qp);\n        if (thr->cpu != NULL)\n            continue;        /* it is a cpu thread */\n        printf(\"%s 0x%-12x %-6d \",\" \",thr,thr->md.id);\n        /*\n         * check if the sproc is still running\n         * first call prctl(PR_GETSHMASK,pid) to check if\n         * the process is part of the share group (the pid\n         * could have been recycled by the OS)\n         */\n        if (prctl(PR_GETSHMASK,thr->md.id) < 0) {\n            printf(\"%-12s\\n\",\"TERMINATED\");\n            continue;\n        }\n        /*\n         * Now, check if the sproc terminated and is in zombie\n         * state\n         */\n        sprintf(path,\"/proc/pinfo/%s\",\"00000\");\n        len = strlen(path);\n        sprintf(pidstr,\"%d\",thr->md.id);\n        len -= strlen(pidstr);\n        sprintf(path + len,\"%s\",pidstr);\n        fd = open(path,O_RDONLY);\n        if (fd >= 0) {\n            if (ioctl(fd, PIOCPSINFO, &pinfo) < 0)\n                printf(\"%-12s \",\"TERMINATED\");\n            else if (pinfo.pr_zomb)\n                printf(\"%-12s \",\"TERMINATED\");\n            else\n                printf(\"%-12s \",_thr_state[thr->state]);\n            close(fd);\n        } else {\n            printf(\"%-12s \",\"TERMINATED\");\n        }\n\n        if (thr->state == _PR_LOCK_WAIT)\n            handle = thr->wait.lock;\n        else if (thr->state == _PR_COND_WAIT)\n            handle = thr->wait.cvar;\n        else\n            handle = NULL;\n        if (handle)\n            printf(\"%-12x \",handle);\n        else\n            printf(\"%-12s \",\" \");\n        printf(\"0x%-10x \",thr->stack->stackBottom);\n        printf(\"0x%-10x\\n\",thr->stack->stackSize);\n    }\n\n    printf(\"\\n%s %-s\\n\",\" \",\"CPUs\");\n    printf(\"%s %-s\\n\",\" \",\"----\");\n    printf(\"%s %-14s %-6s %-12s \\n\\n\",\" \",\"Id\",\"Pid\",\"State\");\n\n\n    for (qp = _PR_CPUQ().next; qp != &_PR_CPUQ(); qp = qp->next) {\n        cpu = _PR_CPU_PTR(qp);\n        printf(\"%s %-14d %-6d \",\" \",cpu->id,cpu->md.id);\n        /*\n         * check if the sproc is still running\n         * first call prctl(PR_GETSHMASK,pid) to check if\n         * the process is part of the share group (the pid\n         * could have been recycled by the OS)\n         */\n        if (prctl(PR_GETSHMASK,cpu->md.id) < 0) {\n            printf(\"%-12s\\n\",\"TERMINATED\");\n            continue;\n        }\n        /*\n         * Now, check if the sproc terminated and is in zombie\n         * state\n         */\n        sprintf(path,\"/proc/pinfo/%s\",\"00000\");\n        len = strlen(path);\n        sprintf(pidstr,\"%d\",cpu->md.id);\n        len -= strlen(pidstr);\n        sprintf(path + len,\"%s\",pidstr);\n        fd = open(path,O_RDONLY);\n        if (fd >= 0) {\n            if (ioctl(fd, PIOCPSINFO, &pinfo) < 0)\n                printf(\"%-12s\\n\",\"TERMINATED\");\n            else if (pinfo.pr_zomb)\n                printf(\"%-12s\\n\",\"TERMINATED\");\n            else\n                printf(\"%-12s\\n\",\"RUNNING\");\n            close(fd);\n        } else {\n            printf(\"%-12s\\n\",\"TERMINATED\");\n        }\n\n    }\n    fflush(stdout);\n}\n#endif /* defined(_PR_PTHREADS) */ \n\nPRWord *_MD_HomeGCRegisters(PRThread *t, int isCurrent, int *np)\n{\n#if !defined(_PR_PTHREADS)\n    if (isCurrent) {\n        (void) setjmp(t->md.jb);\n    }\n    *np = sizeof(t->md.jb) / sizeof(PRWord);\n    return (PRWord *) (t->md.jb);\n#else\n\t*np = 0;\n\treturn NULL;\n#endif\n}\n\nvoid _MD_EarlyInit(void)\n{\n#if !defined(_PR_PTHREADS)\n    char *eval;\n    int fd;\n\textern int __ateachexit(void (*func)(void));\n\n    sigemptyset(&ints_off);\n    sigaddset(&ints_off, SIGALRM);\n    sigaddset(&ints_off, SIGIO);\n    sigaddset(&ints_off, SIGCLD);\n\n    if (eval = getenv(\"_NSPR_TERMINATE_ON_ERROR\"))\n        _nspr_terminate_on_error = (0 == atoi(eval) == 0) ? PR_FALSE : PR_TRUE;\n\n    fd = open(\"/dev/zero\",O_RDWR , 0);\n    if (fd < 0) {\n        perror(\"open /dev/zero failed\");\n        exit(1);\n    }\n    /*\n     * Set up the sproc private data area.\n     * This region exists at the same address, _nspr_sproc_private, for\n     * every sproc, but each sproc gets a private copy of the region.\n     */\n    _nspr_sproc_private = (char*)mmap(0, _pr_pageSize, PROT_READ | PROT_WRITE,\n        MAP_PRIVATE| MAP_LOCAL, fd, 0);\n    if (_nspr_sproc_private == (void*)-1) {\n        perror(\"mmap /dev/zero failed\");\n        exit(1);\n    }\n\t_MD_SET_SPROC_PID(getpid());\t\n    close(fd);\n\t__ateachexit(irix_detach_sproc);\n#endif\n    _MD_IrixIntervalInit();\n}  /* _MD_EarlyInit */\n\nvoid _MD_IrixInit(void)\n{\n#if !defined(_PR_PTHREADS)\n    struct sigaction sigact;\n    PRThread *me = _PR_MD_CURRENT_THREAD();\n\tint rv;\n\n#ifdef _PR_HAVE_SGI_PRDA_PROCMASK\n\t/*\n\t * enable user-level processing of sigprocmask(); this is an undocumented\n\t * feature available in Irix 6.2, 6.3, 6.4 and 6.5\n\t */\n\t__sgi_prda_procmask(USER_LEVEL);\n#endif\n\n\t/*\n\t * set up SIGUSR1 handler; this is used to save state\n\t * during PR_SuspendAll\n\t */\n\tsigact.sa_handler = save_context_and_block;\n\tsigact.sa_flags = SA_RESTART;\n\tsigact.sa_mask = ints_off;\n\tsigaction(SIGUSR1, &sigact, 0);\n\n    /*\n     * Change the name of the core file from core to core.pid,\n     * This is inherited by the sprocs created by this process\n     */\n#ifdef PR_COREPID\n    prctl(PR_COREPID, 0, 1);\n#endif\n    /*\n     * Irix-specific terminate on error processing\n     */\n\t/*\n\t * PR_SETABORTSIG is a new command implemented in a patch to\n\t * Irix 6.2, 6.3 and 6.4. This causes a signal to be sent to all\n\t * sprocs in the process when one of them terminates abnormally\n\t *\n\t */\n\tif (prctl(PR_SETABORTSIG, SIGKILL) < 0) {\n\t\t/*\n\t\t *  if (errno == EINVAL)\n\t\t *\n\t\t *\tPR_SETABORTSIG not supported under this OS.\n\t\t *\tYou may want to get a recent kernel rollup patch that\n\t\t *\tsupports this feature.\n\t\t *\n\t\t */\n\t}\n\t/*\n\t * PR_SETEXITSIG -  send the SIGCLD signal to the parent\n\t *            sproc when any sproc terminates\n\t *\n\t *    This is used to cause the entire application to\n\t *    terminate when    any sproc terminates abnormally by\n\t *     receipt of a SIGSEGV, SIGBUS or SIGABRT signal.\n\t *    If this is not done, the application may seem\n\t *     \"hung\" to the user because the other sprocs may be\n\t *    waiting for resources held by the\n\t *    abnormally-terminating sproc.\n\t */\n\tprctl(PR_SETEXITSIG, 0);\n\n\tsigact.sa_handler = sigchld_handler;\n\tsigact.sa_flags = SA_RESTART;\n\tsigact.sa_mask = ints_off;\n\tsigaction(SIGCLD, &sigact, NULL);\n\n    /*\n     * setup stack fields for the primordial thread\n     */\n    me->stack->stackSize = prctl(PR_GETSTACKSIZE);\n    me->stack->stackBottom = me->stack->stackTop - me->stack->stackSize;\n\n    rv = pipe(_pr_irix_primoridal_cpu_fd);\n    PR_ASSERT(rv == 0);\n#ifndef _PR_USE_POLL\n    _PR_IOQ_MAX_OSFD(me->cpu) = _pr_irix_primoridal_cpu_fd[0];\n    FD_SET(_pr_irix_primoridal_cpu_fd[0], &_PR_FD_READ_SET(me->cpu));\n#endif\n\n\tlibc_handle = dlopen(\"libc.so\",RTLD_NOW);\n\tPR_ASSERT(libc_handle != NULL);\n\tlibc_exit = (void (*)(int)) dlsym(libc_handle, \"exit\");\n\tPR_ASSERT(libc_exit != NULL);\n\t/* dlclose(libc_handle); */\n\n#endif /* _PR_PTHREADS */\n\n    _PR_UnixInit();\n}\n\n/**************************************************************************/\n/************** code and such for NSPR 2.0's interval times ***************/\n/**************************************************************************/\n\n#define PR_PSEC_PER_SEC 1000000000000ULL  /* 10^12 */\n\n#ifndef SGI_CYCLECNTR_SIZE\n#define SGI_CYCLECNTR_SIZE      165     /* Size user needs to use to read CC */\n#endif\n\nstatic PRIntn mmem_fd = -1;\nstatic PRIntn clock_width = 0;\nstatic void *iotimer_addr = NULL;\nstatic PRUint32 pr_clock_mask = 0;\nstatic PRUint32 pr_clock_shift = 0;\nstatic PRIntervalTime pr_ticks = 0;\nstatic PRUint32 pr_clock_granularity = 1;\nstatic PRUint32 pr_previous = 0, pr_residual = 0;\nstatic PRUint32 pr_ticks_per_second = 0;\n\nextern PRIntervalTime _PR_UNIX_GetInterval(void);\nextern PRIntervalTime _PR_UNIX_TicksPerSecond(void);\n\nstatic void _MD_IrixIntervalInit(void)\n{\n    /*\n     * As much as I would like, the service available through this\n     * interface on R3000's (aka, IP12) just isn't going to make it.\n     * The register is only 24 bits wide, and rolls over at a verocious\n     * rate.\n     */\n    PRUint32 one_tick = 0;\n    struct utsname utsinfo;\n    uname(&utsinfo);\n    if ((strncmp(\"IP12\", utsinfo.machine, 4) != 0)\n        && ((mmem_fd = open(\"/dev/mmem\", O_RDONLY)) != -1))\n    {\n        int poffmask = getpagesize() - 1;\n        __psunsigned_t phys_addr, raddr, cycleval;\n\n        phys_addr = syssgi(SGI_QUERY_CYCLECNTR, &cycleval);\n        raddr = phys_addr & ~poffmask;\n        iotimer_addr = mmap(\n            0, poffmask, PROT_READ, MAP_PRIVATE, mmem_fd, (__psint_t)raddr);\n\n        clock_width = syssgi(SGI_CYCLECNTR_SIZE);\n        if (clock_width < 0)\n        {\n            /* \n             * We must be executing on a 6.0 or earlier system, since the\n             * SGI_CYCLECNTR_SIZE call is not supported.\n             * \n             * The only pre-6.1 platforms with 64-bit counters are\n             * IP19 and IP21 (Challenge, PowerChallenge, Onyx).\n             */\n            if (!strncmp(utsinfo.machine, \"IP19\", 4) ||\n                !strncmp(utsinfo.machine, \"IP21\", 4))\n                clock_width = 64;\n            else\n                clock_width = 32;\n        }\n\n        /*\n         * 'cycleval' is picoseconds / increment of the counter.\n         * I'm pushing for a tick to be 100 microseconds, 10^(-4).\n         * That leaves 10^(-8) left over, or 10^8 / cycleval.\n         * Did I do that right?\n         */\n\n        one_tick =  100000000UL / cycleval ;  /* 100 microseconds */\n\n        while (0 != one_tick)\n        {\n            pr_clock_shift += 1;\n            one_tick = one_tick >> 1;\n            pr_clock_granularity = pr_clock_granularity << 1;\n        }\n        pr_clock_mask = pr_clock_granularity - 1;  /* to make a mask out of it */\n        pr_ticks_per_second = PR_PSEC_PER_SEC\n                / ((PRUint64)pr_clock_granularity * (PRUint64)cycleval);\n            \n        iotimer_addr = (void*)\n            ((__psunsigned_t)iotimer_addr + (phys_addr & poffmask));\n    }\n    else\n    {\n        pr_ticks_per_second = _PR_UNIX_TicksPerSecond();\n    }\n}  /* _MD_IrixIntervalInit */\n\nPRIntervalTime _MD_IrixIntervalPerSec(void)\n{\n    return pr_ticks_per_second;\n}\n\nPRIntervalTime _MD_IrixGetInterval(void)\n{\n    if (mmem_fd != -1)\n    {\n        if (64 == clock_width)\n        {\n            PRUint64 temp = *(PRUint64*)iotimer_addr;\n            pr_ticks = (PRIntervalTime)(temp >> pr_clock_shift);\n        }\n        else\n        {\n            PRIntervalTime ticks = pr_ticks;\n            PRUint32 now = *(PRUint32*)iotimer_addr, temp;\n            PRUint32 residual = pr_residual, previous = pr_previous;\n\n            temp = now - previous + residual;\n            residual = temp & pr_clock_mask;\n            ticks += temp >> pr_clock_shift;\n\n            pr_previous = now;\n            pr_residual = residual;\n            pr_ticks = ticks;\n        }\n    }\n    else\n    {\n        /*\n         * No fast access. Use the time of day clock. This isn't the\n         * right answer since this clock can get set back, tick at odd\n         * rates, and it's expensive to acqurie.\n         */\n        pr_ticks = _PR_UNIX_GetInterval();\n    }\n    return pr_ticks;\n}  /* _MD_IrixGetInterval */\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-nspr-4.13.1-vntc7ai7kqzc4riwwqstomskyuugrvqz/spack-src/nspr/pr/src/md/unix/uxproces.c": "/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n#include \"primpl.h\"\n\n#include <sys/types.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <sys/wait.h>\n#include <string.h>\n#if defined(AIX)\n#include <dlfcn.h>  /* For dlopen, dlsym, dlclose */\n#endif\n\n#if defined(DARWIN)\n#if defined(HAVE_CRT_EXTERNS_H)\n#include <crt_externs.h>\n#endif\n#else\nPR_IMPORT_DATA(char **) environ;\n#endif\n\n/*\n * HP-UX 9 doesn't have the SA_RESTART flag.\n */\n#ifndef SA_RESTART\n#define SA_RESTART 0\n#endif\n\n/*\n **********************************************************************\n *\n * The Unix process routines\n *\n **********************************************************************\n */\n\n#define _PR_SIGNALED_EXITSTATUS 256\n\ntypedef enum pr_PidState {\n    _PR_PID_DETACHED,\n    _PR_PID_REAPED,\n    _PR_PID_WAITING\n} pr_PidState;\n\ntypedef struct pr_PidRecord {\n    pid_t pid;\n    int exitStatus;\n    pr_PidState state;\n    PRCondVar *reapedCV;\n    struct pr_PidRecord *next;\n} pr_PidRecord;\n\n/*\n * Irix sprocs and LinuxThreads are actually a kind of processes\n * that can share the virtual address space and file descriptors.\n */\n#if (defined(IRIX) && !defined(_PR_PTHREADS)) \\\n        || ((defined(LINUX) || defined(__GNU__) || defined(__GLIBC__)) \\\n        && defined(_PR_PTHREADS))\n#define _PR_SHARE_CLONES\n#endif\n\n/*\n * The macro _PR_NATIVE_THREADS indicates that we are\n * using native threads only, so waitpid() blocks just the\n * calling thread, not the process.  In this case, the waitpid\n * daemon thread can safely block in waitpid().  So we don't\n * need to catch SIGCHLD, and the pipe to unblock PR_Poll() is\n * also not necessary.\n */\n\n#if defined(_PR_GLOBAL_THREADS_ONLY) \\\n\t|| (defined(_PR_PTHREADS) \\\n\t&& !defined(LINUX) && !defined(__GNU__) && !defined(__GLIBC__))\n#define _PR_NATIVE_THREADS\n#endif\n\n/*\n * All the static variables used by the Unix process routines are\n * collected in this structure.\n */\n\nstatic struct {\n    PRCallOnceType once;\n    PRThread *thread;\n    PRLock *ml;\n#if defined(_PR_NATIVE_THREADS)\n    PRInt32 numProcs;\n    PRCondVar *cv;\n#else\n    int pipefd[2];\n#endif\n    pr_PidRecord **pidTable;\n\n#ifdef _PR_SHARE_CLONES\n    struct pr_CreateProcOp *opHead, *opTail;\n#endif\n\n#ifdef AIX\n    pid_t (*forkptr)(void);  /* Newer versions of AIX (starting in 4.3.2)\n                              * have f_fork, which is faster than the\n                              * regular fork in a multithreaded process\n                              * because it skips calling the fork handlers.\n                              * So we look up the f_fork symbol to see if\n                              * it's available and fall back on fork.\n                              */\n#endif /* AIX */\n} pr_wp;\n\n#ifdef _PR_SHARE_CLONES\nstatic int pr_waitpid_daemon_exit;\n\nvoid\n_MD_unix_terminate_waitpid_daemon(void)\n{\n    if (pr_wp.thread) {\n        pr_waitpid_daemon_exit = 1;\n        write(pr_wp.pipefd[1], \"\", 1);\n        PR_JoinThread(pr_wp.thread);\n    }\n}\n#endif\n\nstatic PRStatus _MD_InitProcesses(void);\n#if !defined(_PR_NATIVE_THREADS)\nstatic void pr_InstallSigchldHandler(void);\n#endif\n\nstatic PRProcess *\nForkAndExec(\n    const char *path,\n    char *const *argv,\n    char *const *envp,\n    const PRProcessAttr *attr)\n{\n    PRProcess *process;\n    int nEnv, idx;\n    char *const *childEnvp;\n    char **newEnvp = NULL;\n    int flags;\n\n    process = PR_NEW(PRProcess);\n    if (!process) {\n        PR_SetError(PR_OUT_OF_MEMORY_ERROR, 0);\n        return NULL;\n    }\n\n    childEnvp = envp;\n    if (attr && attr->fdInheritBuffer) {\n        PRBool found = PR_FALSE;\n\n        if (NULL == childEnvp) {\n#ifdef DARWIN\n#ifdef HAVE_CRT_EXTERNS_H\n            childEnvp = *(_NSGetEnviron());\n#else\n            /* _NSGetEnviron() is not available on iOS. */\n            PR_DELETE(process);\n            PR_SetError(PR_NOT_IMPLEMENTED_ERROR, 0);\n            return NULL;\n#endif\n#else\n            childEnvp = environ;\n#endif\n        }\n\n        for (nEnv = 0; childEnvp[nEnv]; nEnv++) {\n        }\n        newEnvp = (char **) PR_MALLOC((nEnv + 2) * sizeof(char *));\n        if (NULL == newEnvp) {\n            PR_DELETE(process);\n            PR_SetError(PR_OUT_OF_MEMORY_ERROR, 0);\n            return NULL;\n        }\n        for (idx = 0; idx < nEnv; idx++) {\n            newEnvp[idx] = childEnvp[idx];\n            if (!found && !strncmp(newEnvp[idx], \"NSPR_INHERIT_FDS=\", 17)) {\n                newEnvp[idx] = attr->fdInheritBuffer;\n                found = PR_TRUE;\n            }\n        }\n        if (!found) {\n            newEnvp[idx++] = attr->fdInheritBuffer;\n        }\n        newEnvp[idx] = NULL;\n        childEnvp = newEnvp;\n    }\n\n#ifdef AIX\n    process->md.pid = (*pr_wp.forkptr)();\n#elif defined(NTO) || defined(SYMBIAN)\n    /*\n     * fork() & exec() does not work in a multithreaded process.\n     * Use spawn() instead.\n     */\n    {\n        int fd_map[3] = { 0, 1, 2 };\n\n        if (attr) {\n            if (attr->stdinFd && attr->stdinFd->secret->md.osfd != 0) {\n                fd_map[0] = dup(attr->stdinFd->secret->md.osfd);\n                flags = fcntl(fd_map[0], F_GETFL, 0);\n                if (flags & O_NONBLOCK)\n                    fcntl(fd_map[0], F_SETFL, flags & ~O_NONBLOCK);\n            }\n            if (attr->stdoutFd && attr->stdoutFd->secret->md.osfd != 1) {\n                fd_map[1] = dup(attr->stdoutFd->secret->md.osfd);\n                flags = fcntl(fd_map[1], F_GETFL, 0);\n                if (flags & O_NONBLOCK)\n                    fcntl(fd_map[1], F_SETFL, flags & ~O_NONBLOCK);\n            }\n            if (attr->stderrFd && attr->stderrFd->secret->md.osfd != 2) {\n                fd_map[2] = dup(attr->stderrFd->secret->md.osfd);\n                flags = fcntl(fd_map[2], F_GETFL, 0);\n                if (flags & O_NONBLOCK)\n                    fcntl(fd_map[2], F_SETFL, flags & ~O_NONBLOCK);\n            }\n\n            PR_ASSERT(attr->currentDirectory == NULL);  /* not implemented */\n        }\n\n#ifdef SYMBIAN\n        /* In Symbian OS, we use posix_spawn instead of fork() and exec() */\n        posix_spawn(&(process->md.pid), path, NULL, NULL, argv, childEnvp);\n#else\n        process->md.pid = spawn(path, 3, fd_map, NULL, argv, childEnvp);\n#endif\n\n        if (fd_map[0] != 0)\n            close(fd_map[0]);\n        if (fd_map[1] != 1)\n            close(fd_map[1]);\n        if (fd_map[2] != 2)\n            close(fd_map[2]);\n    }\n#else\n    process->md.pid = fork();\n#endif\n    if ((pid_t) -1 == process->md.pid) {\n        PR_SetError(PR_INSUFFICIENT_RESOURCES_ERROR, errno);\n        PR_DELETE(process);\n        if (newEnvp) {\n            PR_DELETE(newEnvp);\n        }\n        return NULL;\n    } else if (0 == process->md.pid) {  /* the child process */\n        /*\n         * If the child process needs to exit, it must call _exit().\n         * Do not call exit(), because exit() will flush and close\n         * the standard I/O file descriptors, and hence corrupt\n         * the parent process's standard I/O data structures.\n         */\n\n#if !defined(NTO) && !defined(SYMBIAN)\n        if (attr) {\n            /* the osfd's to redirect stdin, stdout, and stderr to */\n            int in_osfd = -1, out_osfd = -1, err_osfd = -1;\n\n            if (attr->stdinFd\n                    && attr->stdinFd->secret->md.osfd != 0) {\n                in_osfd = attr->stdinFd->secret->md.osfd;\n                if (dup2(in_osfd, 0) != 0) {\n                    _exit(1);  /* failed */\n                }\n                flags = fcntl(0, F_GETFL, 0);\n                if (flags & O_NONBLOCK) {\n                    fcntl(0, F_SETFL, flags & ~O_NONBLOCK);\n                }\n            }\n            if (attr->stdoutFd\n                    && attr->stdoutFd->secret->md.osfd != 1) {\n                out_osfd = attr->stdoutFd->secret->md.osfd;\n                if (dup2(out_osfd, 1) != 1) {\n                    _exit(1);  /* failed */\n                }\n                flags = fcntl(1, F_GETFL, 0);\n                if (flags & O_NONBLOCK) {\n                    fcntl(1, F_SETFL, flags & ~O_NONBLOCK);\n                }\n            }\n            if (attr->stderrFd\n                    && attr->stderrFd->secret->md.osfd != 2) {\n                err_osfd = attr->stderrFd->secret->md.osfd;\n                if (dup2(err_osfd, 2) != 2) {\n                    _exit(1);  /* failed */\n                }\n                flags = fcntl(2, F_GETFL, 0);\n                if (flags & O_NONBLOCK) {\n                    fcntl(2, F_SETFL, flags & ~O_NONBLOCK);\n                }\n            }\n            if (in_osfd != -1) {\n                close(in_osfd);\n            }\n            if (out_osfd != -1 && out_osfd != in_osfd) {\n                close(out_osfd);\n            }\n            if (err_osfd != -1 && err_osfd != in_osfd\n                    && err_osfd != out_osfd) {\n                close(err_osfd);\n            }\n            if (attr->currentDirectory) {\n                if (chdir(attr->currentDirectory) < 0) {\n                    _exit(1);  /* failed */\n                }\n            }\n        }\n\n        if (childEnvp) {\n            (void)execve(path, argv, childEnvp);\n        } else {\n            /* Inherit the environment of the parent. */\n            (void)execv(path, argv);\n        }\n        /* Whoops! It returned. That's a bad sign. */\n        _exit(1);\n#endif /* !NTO */\n    }\n\n    if (newEnvp) {\n        PR_DELETE(newEnvp);\n    }\n\n#if defined(_PR_NATIVE_THREADS)\n    PR_Lock(pr_wp.ml);\n    if (0 == pr_wp.numProcs++) {\n        PR_NotifyCondVar(pr_wp.cv);\n    }\n    PR_Unlock(pr_wp.ml);\n#endif\n    return process;\n}\n\n#ifdef _PR_SHARE_CLONES\n\nstruct pr_CreateProcOp {\n    const char *path;\n    char *const *argv;\n    char *const *envp;\n    const PRProcessAttr *attr;\n    PRProcess *process;\n    PRErrorCode prerror;\n    PRInt32 oserror;\n    PRBool done;\n    PRCondVar *doneCV;\n    struct pr_CreateProcOp *next;\n};\n\nPRProcess *\n_MD_CreateUnixProcess(\n    const char *path,\n    char *const *argv,\n    char *const *envp,\n    const PRProcessAttr *attr)\n{\n    struct pr_CreateProcOp *op;\n    PRProcess *proc;\n    int rv;\n\n    if (PR_CallOnce(&pr_wp.once, _MD_InitProcesses) == PR_FAILURE) {\n\treturn NULL;\n    }\n\n    op = PR_NEW(struct pr_CreateProcOp);\n    if (NULL == op) {\n\tPR_SetError(PR_OUT_OF_MEMORY_ERROR, 0);\n\treturn NULL;\n    }\n    op->path = path;\n    op->argv = argv;\n    op->envp = envp;\n    op->attr = attr;\n    op->done = PR_FALSE;\n    op->doneCV = PR_NewCondVar(pr_wp.ml);\n    if (NULL == op->doneCV) {\n\tPR_DELETE(op);\n\treturn NULL;\n    }\n    PR_Lock(pr_wp.ml);\n\n    /* add to the tail of op queue */\n    op->next = NULL;\n    if (pr_wp.opTail) {\n\tpr_wp.opTail->next = op;\n\tpr_wp.opTail = op;\n    } else {\n\tPR_ASSERT(NULL == pr_wp.opHead);\n\tpr_wp.opHead = pr_wp.opTail = op;\n    }\n\n    /* wake up the daemon thread */\n    do {\n        rv = write(pr_wp.pipefd[1], \"\", 1);\n    } while (-1 == rv && EINTR == errno);\n\n    while (op->done == PR_FALSE) {\n\tPR_WaitCondVar(op->doneCV, PR_INTERVAL_NO_TIMEOUT);\n    }\n    PR_Unlock(pr_wp.ml);\n    PR_DestroyCondVar(op->doneCV);\n    proc = op->process;\n    if (!proc) {\n\tPR_SetError(op->prerror, op->oserror);\n    }\n    PR_DELETE(op);\n    return proc;\n}\n\n#else  /* ! _PR_SHARE_CLONES */\n\nPRProcess *\n_MD_CreateUnixProcess(\n    const char *path,\n    char *const *argv,\n    char *const *envp,\n    const PRProcessAttr *attr)\n{\n    if (PR_CallOnce(&pr_wp.once, _MD_InitProcesses) == PR_FAILURE) {\n\treturn NULL;\n    }\n    return ForkAndExec(path, argv, envp, attr);\n}  /* _MD_CreateUnixProcess */\n\n#endif  /* _PR_SHARE_CLONES */\n\n/*\n * The pid table is a hashtable.\n *\n * The number of buckets in the hashtable (NBUCKETS) must be a power of 2.\n */\n#define NBUCKETS_LOG2 6\n#define NBUCKETS (1 << NBUCKETS_LOG2)\n#define PID_HASH_MASK ((pid_t) (NBUCKETS - 1))\n\nstatic pr_PidRecord *\nFindPidTable(pid_t pid)\n{\n    pr_PidRecord *pRec;\n    int keyHash = (int) (pid & PID_HASH_MASK);\n\n    pRec =  pr_wp.pidTable[keyHash];\n    while (pRec) {\n\tif (pRec->pid == pid) {\n\t    break;\n\t}\n\tpRec = pRec->next;\n    }\n    return pRec;\n}\n\nstatic void\nInsertPidTable(pr_PidRecord *pRec)\n{\n    int keyHash = (int) (pRec->pid & PID_HASH_MASK);\n\n    pRec->next = pr_wp.pidTable[keyHash];\n    pr_wp.pidTable[keyHash] = pRec;\n}\n\nstatic void\nDeletePidTable(pr_PidRecord *pRec)\n{\n    int keyHash = (int) (pRec->pid & PID_HASH_MASK);\n\n    if (pr_wp.pidTable[keyHash] == pRec) {\n\tpr_wp.pidTable[keyHash] = pRec->next;\n    } else {\n\tpr_PidRecord *pred, *cur;  /* predecessor and current */\n\n\tpred = pr_wp.pidTable[keyHash];\n\tcur = pred->next;\n\twhile (cur) {\n\t    if (cur == pRec) {\n\t\tpred->next = cur->next;\n\t\tbreak;\n            }\n\t    pred = cur;\n\t    cur = cur->next;\n        }\n\tPR_ASSERT(cur != NULL);\n    }\n}\n\nstatic int\nExtractExitStatus(int rawExitStatus)\n{\n    /*\n     * We did not specify the WCONTINUED and WUNTRACED options\n     * for waitpid, so these two events should not be reported.\n     */\n    PR_ASSERT(!WIFSTOPPED(rawExitStatus));\n#ifdef WIFCONTINUED\n    PR_ASSERT(!WIFCONTINUED(rawExitStatus));\n#endif\n    if (WIFEXITED(rawExitStatus)) {\n\treturn WEXITSTATUS(rawExitStatus);\n    } else {\n\tPR_ASSERT(WIFSIGNALED(rawExitStatus));\n\treturn _PR_SIGNALED_EXITSTATUS;\n    }\n}\n\nstatic void\nProcessReapedChildInternal(pid_t pid, int status)\n{\n    pr_PidRecord *pRec;\n\n    pRec = FindPidTable(pid);\n    if (NULL == pRec) {\n        pRec = PR_NEW(pr_PidRecord);\n        pRec->pid = pid;\n        pRec->state = _PR_PID_REAPED;\n        pRec->exitStatus = ExtractExitStatus(status);\n        pRec->reapedCV = NULL;\n        InsertPidTable(pRec);\n    } else {\n        PR_ASSERT(pRec->state != _PR_PID_REAPED);\n        if (_PR_PID_DETACHED == pRec->state) {\n            PR_ASSERT(NULL == pRec->reapedCV);\n            DeletePidTable(pRec);\n            PR_DELETE(pRec);\n        } else {\n            PR_ASSERT(_PR_PID_WAITING == pRec->state);\n            PR_ASSERT(NULL != pRec->reapedCV);\n            pRec->exitStatus = ExtractExitStatus(status);\n            pRec->state = _PR_PID_REAPED;\n            PR_NotifyCondVar(pRec->reapedCV);\n        }\n    }\n}\n\n#if defined(_PR_NATIVE_THREADS)\n\n/*\n * If all the threads are native threads, the daemon thread is\n * simpler.  We don't need to catch the SIGCHLD signal.  We can\n * just have the daemon thread block in waitpid().\n */\n\nstatic void WaitPidDaemonThread(void *unused)\n{\n    pid_t pid;\n    int status;\n\n    while (1) {\n        PR_Lock(pr_wp.ml);\n        while (0 == pr_wp.numProcs) {\n            PR_WaitCondVar(pr_wp.cv, PR_INTERVAL_NO_TIMEOUT);\n        }\n        PR_Unlock(pr_wp.ml);\n\n\twhile (1) {\n\t    do {\n\t        pid = waitpid((pid_t) -1, &status, 0);\n\t    } while ((pid_t) -1 == pid && EINTR == errno);\n\n            /*\n             * waitpid() cannot return 0 because we did not invoke it\n             * with the WNOHANG option.\n             */ \n\t    PR_ASSERT(0 != pid);\n\n            /*\n             * The only possible error code is ECHILD.  But if we do\n             * our accounting correctly, we should only call waitpid()\n             * when there is a child process to wait for.\n             */\n            PR_ASSERT((pid_t) -1 != pid);\n\t    if ((pid_t) -1 == pid) {\n                break;\n            }\n\n\t    PR_Lock(pr_wp.ml);\n            ProcessReapedChildInternal(pid, status);\n            pr_wp.numProcs--;\n            while (0 == pr_wp.numProcs) {\n                PR_WaitCondVar(pr_wp.cv, PR_INTERVAL_NO_TIMEOUT);\n            }\n\t    PR_Unlock(pr_wp.ml);\n\t}\n    }\n}\n\n#else /* _PR_NATIVE_THREADS */\n\nstatic void WaitPidDaemonThread(void *unused)\n{\n    PRPollDesc pd;\n    PRFileDesc *fd;\n    int rv;\n    char buf[128];\n    pid_t pid;\n    int status;\n#ifdef _PR_SHARE_CLONES\n    struct pr_CreateProcOp *op;\n#endif\n\n#ifdef _PR_SHARE_CLONES\n    pr_InstallSigchldHandler();\n#endif\n\n    fd = PR_ImportFile(pr_wp.pipefd[0]);\n    PR_ASSERT(NULL != fd);\n    pd.fd = fd;\n    pd.in_flags = PR_POLL_READ;\n\n    while (1) {\n        rv = PR_Poll(&pd, 1, PR_INTERVAL_NO_TIMEOUT);\n        PR_ASSERT(1 == rv);\n\n#ifdef _PR_SHARE_CLONES\n        if (pr_waitpid_daemon_exit) {\n            return;\n        }\n\tPR_Lock(pr_wp.ml);\n#endif\n\t    \n        do {\n            rv = read(pr_wp.pipefd[0], buf, sizeof(buf));\n        } while (sizeof(buf) == rv || (-1 == rv && EINTR == errno));\n\n#ifdef _PR_SHARE_CLONES\n\tPR_Unlock(pr_wp.ml);\n\twhile ((op = pr_wp.opHead) != NULL) {\n\t    op->process = ForkAndExec(op->path, op->argv,\n\t\t    op->envp, op->attr);\n\t    if (NULL == op->process) {\n\t\top->prerror = PR_GetError();\n\t\top->oserror = PR_GetOSError();\n\t    }\n\t    PR_Lock(pr_wp.ml);\n\t    pr_wp.opHead = op->next;\n\t    if (NULL == pr_wp.opHead) {\n\t\tpr_wp.opTail = NULL;\n\t    }\n\t    op->done = PR_TRUE;\n\t    PR_NotifyCondVar(op->doneCV);\n\t    PR_Unlock(pr_wp.ml);\n\t}\n#endif\n\n\twhile (1) {\n\t    do {\n\t        pid = waitpid((pid_t) -1, &status, WNOHANG);\n\t    } while ((pid_t) -1 == pid && EINTR == errno);\n\t    if (0 == pid) break;\n\t    if ((pid_t) -1 == pid) {\n\t\t/* must be because we have no child processes */\n\t\tPR_ASSERT(ECHILD == errno);\n\t\tbreak;\n            }\n\n\t    PR_Lock(pr_wp.ml);\n            ProcessReapedChildInternal(pid, status);\n\t    PR_Unlock(pr_wp.ml);\n\t}\n    }\n}\n\nstatic void pr_SigchldHandler(int sig)\n{\n    int errnoCopy;\n    int rv;\n\n    errnoCopy = errno;\n\n    do {\n        rv = write(pr_wp.pipefd[1], \"\", 1);\n    } while (-1 == rv && EINTR == errno);\n\n#ifdef DEBUG\n    if (-1 == rv && EAGAIN != errno && EWOULDBLOCK != errno) {\n        char *msg = \"cannot write to pipe\\n\";\n        write(2, msg, strlen(msg) + 1);\n        _exit(1);\n    }\n#endif\n\n    errno = errnoCopy;\n}\n\nstatic void pr_InstallSigchldHandler()\n{\n#if defined(HPUX) && defined(_PR_DCETHREADS)\n#error \"HP-UX DCE threads have their own SIGCHLD handler\"\n#endif\n\n    struct sigaction act, oact;\n    int rv;\n\n    act.sa_handler = pr_SigchldHandler;\n    sigemptyset(&act.sa_mask);\n    act.sa_flags = SA_NOCLDSTOP | SA_RESTART;\n    rv = sigaction(SIGCHLD, &act, &oact);\n    PR_ASSERT(0 == rv);\n    /* Make sure we are not overriding someone else's SIGCHLD handler */\n#ifndef _PR_SHARE_CLONES\n    PR_ASSERT(oact.sa_handler == SIG_DFL);\n#endif\n}\n\n#endif  /* !defined(_PR_NATIVE_THREADS) */\n\nstatic PRStatus _MD_InitProcesses(void)\n{\n#if !defined(_PR_NATIVE_THREADS)\n    int rv;\n    int flags;\n#endif\n\n#ifdef AIX\n    {\n        void *handle = dlopen(NULL, RTLD_NOW | RTLD_GLOBAL);\n        pr_wp.forkptr = (pid_t (*)(void)) dlsym(handle, \"f_fork\");\n        if (!pr_wp.forkptr) {\n            pr_wp.forkptr = fork;\n        }\n        dlclose(handle);\n    }\n#endif /* AIX */\n\n    pr_wp.ml = PR_NewLock();\n    PR_ASSERT(NULL != pr_wp.ml);\n\n#if defined(_PR_NATIVE_THREADS)\n    pr_wp.numProcs = 0;\n    pr_wp.cv = PR_NewCondVar(pr_wp.ml);\n    PR_ASSERT(NULL != pr_wp.cv);\n#else\n    rv = pipe(pr_wp.pipefd);\n    PR_ASSERT(0 == rv);\n    flags = fcntl(pr_wp.pipefd[0], F_GETFL, 0);\n    fcntl(pr_wp.pipefd[0], F_SETFL, flags | O_NONBLOCK);\n    flags = fcntl(pr_wp.pipefd[1], F_GETFL, 0);\n    fcntl(pr_wp.pipefd[1], F_SETFL, flags | O_NONBLOCK);\n\n#ifndef _PR_SHARE_CLONES\n    pr_InstallSigchldHandler();\n#endif\n#endif  /* !_PR_NATIVE_THREADS */\n\n    pr_wp.thread = PR_CreateThread(PR_SYSTEM_THREAD,\n\t    WaitPidDaemonThread, NULL, PR_PRIORITY_NORMAL,\n#ifdef _PR_SHARE_CLONES\n            PR_GLOBAL_THREAD,\n#else\n\t    PR_LOCAL_THREAD,\n#endif\n\t    PR_JOINABLE_THREAD, 0);\n    PR_ASSERT(NULL != pr_wp.thread);\n\n    pr_wp.pidTable = (pr_PidRecord**)PR_CALLOC(NBUCKETS * sizeof(pr_PidRecord *));\n    PR_ASSERT(NULL != pr_wp.pidTable);\n    return PR_SUCCESS;\n}\n\nPRStatus _MD_DetachUnixProcess(PRProcess *process)\n{\n    PRStatus retVal = PR_SUCCESS;\n    pr_PidRecord *pRec;\n\n    PR_Lock(pr_wp.ml);\n    pRec = FindPidTable(process->md.pid);\n    if (NULL == pRec) {\n\tpRec = PR_NEW(pr_PidRecord);\n\tif (NULL == pRec) {\n\t    PR_SetError(PR_OUT_OF_MEMORY_ERROR, 0);\n\t    retVal = PR_FAILURE;\n\t    goto done;\n\t}\n\tpRec->pid = process->md.pid;\n\tpRec->state = _PR_PID_DETACHED;\n\tpRec->reapedCV = NULL;\n\tInsertPidTable(pRec);\n    } else {\n\tPR_ASSERT(_PR_PID_REAPED == pRec->state);\n\tif (_PR_PID_REAPED != pRec->state) {\n\t    PR_SetError(PR_INVALID_ARGUMENT_ERROR, 0);\n\t    retVal = PR_FAILURE;\n\t} else {\n\t    DeletePidTable(pRec);\n\t    PR_ASSERT(NULL == pRec->reapedCV);\n\t    PR_DELETE(pRec);\n\t}\n    }\n    PR_DELETE(process);\n\ndone:\n    PR_Unlock(pr_wp.ml);\n    return retVal;\n}\n\nPRStatus _MD_WaitUnixProcess(\n    PRProcess *process,\n    PRInt32 *exitCode)\n{\n    pr_PidRecord *pRec;\n    PRStatus retVal = PR_SUCCESS;\n    PRBool interrupted = PR_FALSE;\n\n    PR_Lock(pr_wp.ml);\n    pRec = FindPidTable(process->md.pid);\n    if (NULL == pRec) {\n\tpRec = PR_NEW(pr_PidRecord);\n\tif (NULL == pRec) {\n\t    PR_SetError(PR_OUT_OF_MEMORY_ERROR, 0);\n\t    retVal = PR_FAILURE;\n\t    goto done;\n\t}\n\tpRec->pid = process->md.pid;\n\tpRec->state = _PR_PID_WAITING;\n\tpRec->reapedCV = PR_NewCondVar(pr_wp.ml);\n\tif (NULL == pRec->reapedCV) {\n\t    PR_DELETE(pRec);\n\t    retVal = PR_FAILURE;\n\t    goto done;\n\t}\n\tInsertPidTable(pRec);\n\twhile (!interrupted && _PR_PID_REAPED != pRec->state) {\n\t    if (PR_WaitCondVar(pRec->reapedCV,\n\t\t    PR_INTERVAL_NO_TIMEOUT) == PR_FAILURE\n\t\t    && PR_GetError() == PR_PENDING_INTERRUPT_ERROR) {\n\t\tinterrupted = PR_TRUE;\n            }\n\t}\n\tif (_PR_PID_REAPED == pRec->state) {\n            if (exitCode) {\n                *exitCode = pRec->exitStatus;\n            }\n\t} else {\n\t    PR_ASSERT(interrupted);\n\t    retVal = PR_FAILURE;\n\t}\n\tDeletePidTable(pRec);\n\tPR_DestroyCondVar(pRec->reapedCV);\n\tPR_DELETE(pRec);\n    } else {\n\tPR_ASSERT(_PR_PID_REAPED == pRec->state);\n\tPR_ASSERT(NULL == pRec->reapedCV);\n\tDeletePidTable(pRec);\n        if (exitCode) {\n            *exitCode = pRec->exitStatus;\n        }\n\tPR_DELETE(pRec);\n    }\n    PR_DELETE(process);\n\ndone:\n    PR_Unlock(pr_wp.ml);\n    return retVal;\n}  /* _MD_WaitUnixProcess */\n\nPRStatus _MD_KillUnixProcess(PRProcess *process)\n{\n    PRErrorCode prerror;\n    PRInt32 oserror;\n\n#ifdef SYMBIAN\n    /* In Symbian OS, we can not kill other process with Open C */\n    PR_SetError(PR_OPERATION_NOT_SUPPORTED_ERROR, oserror);\n    return PR_FAILURE;\n#else\n    if (kill(process->md.pid, SIGKILL) == 0) {\n\treturn PR_SUCCESS;\n    }\n    oserror = errno;\n    switch (oserror) {\n        case EPERM:\n\t    prerror = PR_NO_ACCESS_RIGHTS_ERROR;\n\t    break;\n        case ESRCH:\n\t    prerror = PR_INVALID_ARGUMENT_ERROR;\n\t    break;\n        default:\n\t    prerror = PR_UNKNOWN_ERROR;\n\t    break;\n    }\n    PR_SetError(prerror, oserror);\n    return PR_FAILURE;\n#endif\n}  /* _MD_KillUnixProcess */\n"
    },
    "skipped": [],
    "total_files": 635
}