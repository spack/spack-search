{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-nccl-2.3.5-5-naybqvojxe5avbgrcfvu2idw6tif3rnt/spack-src/src/misc/ibvwrap.cu": "/*************************************************************************\n * Copyright (c) 2015-2018, NVIDIA CORPORATION. All rights reserved.\n *\n * See LICENSE.txt for license information\n ************************************************************************/\n\n#include \"ibvwrap.h\"\n#include <sys/types.h>\n#include <unistd.h>\n\n#include <dlfcn.h>\n#include \"core.h\"\n\nstatic enum { ibvUninitialized, ibvInitializing, ibvInitialized, ibvError } ibvState = ibvUninitialized;\n\n/*Function Pointers*/\nint (*ibv_internal_fork_init)(void);\nstruct ibv_device** (*ibv_internal_get_device_list)(int *num_devices);\nvoid (*ibv_internal_free_device_list)(struct ibv_device **list);\nconst char * (*ibv_internal_get_device_name)(struct ibv_device *device);\nstruct ibv_context* (*ibv_internal_open_device)(struct ibv_device* device);\nint (*ibv_internal_close_device)(struct ibv_context *context);\nint (*ibv_internal_get_async_event)(struct ibv_context *context, struct ibv_async_event *event);\nvoid (*ibv_internal_ack_async_event)(struct ibv_async_event *event);\nint (*ibv_internal_query_device)(struct ibv_context *context, struct ibv_device_attr *device_attr);\nint (*ibv_internal_query_port)(struct ibv_context *context, uint8_t port_num, struct ibv_port_attr *port_attr);\nint (*ibv_internal_query_gid)(struct ibv_context *context, uint8_t port_num, int index, union ibv_gid *gid);\nint (*ibv_internal_query_qp)(struct ibv_qp *qp, struct ibv_qp_attr *attr, int attr_mask, struct ibv_qp_init_attr *init_attr);\nstruct ibv_pd * (*ibv_internal_alloc_pd)(struct ibv_context *context);\nint (*ibv_internal_dealloc_pd)(struct ibv_pd *pd);\nstruct ibv_mr * (*ibv_internal_reg_mr)(struct ibv_pd *pd, void *addr, size_t length, int access);\nint (*ibv_internal_dereg_mr)(struct ibv_mr *mr);\nstruct ibv_cq * (*ibv_internal_create_cq)(struct ibv_context *context, int cqe, void *cq_context, struct ibv_comp_channel *channel, int comp_vector);\nint (*ibv_internal_destroy_cq)(struct ibv_cq *cq);\nstruct ibv_qp * (*ibv_internal_create_qp)(struct ibv_pd *pd, struct ibv_qp_init_attr *qp_init_attr);\nint (*ibv_internal_modify_qp)(struct ibv_qp *qp, struct ibv_qp_attr *attr, int attr_mask);\nint (*ibv_internal_destroy_qp)(struct ibv_qp *qp);\nconst char * (*ibv_internal_event_type_str)(enum ibv_event_type event);\n\n// IBVERBS Library versioning\n#define IBVERBS_VERSION \"IBVERBS_1.1\"\n\nncclResult_t wrap_ibv_symbols(void) {\n  if (ibvState == ibvInitialized)\n    return ncclSuccess;\n  if (ibvState == ibvError)\n    return ncclSystemError;\n\n  if (__sync_bool_compare_and_swap(&ibvState, ibvUninitialized, ibvInitializing) == false) {\n    // Another thread raced in front of us. Wait for it to be done.\n    while (ibvState == ibvInitializing) pthread_yield();\n    return (ibvState == ibvInitialized) ? ncclSuccess : ncclSystemError;\n  }\n\n  static void* ibvhandle = NULL;\n  void* tmp;\n  void** cast;\n\n  ibvhandle=dlopen(\"libibverbs.so\", RTLD_NOW);\n  if (!ibvhandle) {\n    ibvhandle=dlopen(\"libibverbs.so.1\", RTLD_NOW);\n    if (!ibvhandle) {\n      WARN(\"Failed to open libibverbs.so[.1]\");\n      goto teardown;\n    }\n  }\n\n#define LOAD_SYM(handle, symbol, funcptr) do {         \\\n    cast = (void**)&funcptr;                             \\\n    tmp = dlvsym(handle, symbol, IBVERBS_VERSION);       \\\n    if (tmp == NULL) {                                   \\\n      WARN(\"dlvsym failed on %s - %s version %s\", symbol, dlerror(), IBVERBS_VERSION);  \\\n      goto teardown;                                     \\\n    }                                                    \\\n    *cast = tmp;                                         \\\n  } while (0)\n\n  LOAD_SYM(ibvhandle, \"ibv_get_device_list\", ibv_internal_get_device_list);\n  LOAD_SYM(ibvhandle, \"ibv_free_device_list\", ibv_internal_free_device_list);\n  LOAD_SYM(ibvhandle, \"ibv_get_device_name\", ibv_internal_get_device_name);\n  LOAD_SYM(ibvhandle, \"ibv_open_device\", ibv_internal_open_device);\n  LOAD_SYM(ibvhandle, \"ibv_close_device\", ibv_internal_close_device);\n  LOAD_SYM(ibvhandle, \"ibv_get_async_event\", ibv_internal_get_async_event);\n  LOAD_SYM(ibvhandle, \"ibv_ack_async_event\", ibv_internal_ack_async_event);\n  LOAD_SYM(ibvhandle, \"ibv_query_device\", ibv_internal_query_device);\n  LOAD_SYM(ibvhandle, \"ibv_query_port\", ibv_internal_query_port);\n  LOAD_SYM(ibvhandle, \"ibv_query_gid\", ibv_internal_query_gid);\n  LOAD_SYM(ibvhandle, \"ibv_query_qp\", ibv_internal_query_qp);\n  LOAD_SYM(ibvhandle, \"ibv_alloc_pd\", ibv_internal_alloc_pd);\n  LOAD_SYM(ibvhandle, \"ibv_dealloc_pd\", ibv_internal_dealloc_pd);\n  LOAD_SYM(ibvhandle, \"ibv_reg_mr\", ibv_internal_reg_mr);\n  LOAD_SYM(ibvhandle, \"ibv_dereg_mr\", ibv_internal_dereg_mr);\n  LOAD_SYM(ibvhandle, \"ibv_create_cq\", ibv_internal_create_cq);\n  LOAD_SYM(ibvhandle, \"ibv_destroy_cq\", ibv_internal_destroy_cq);\n  LOAD_SYM(ibvhandle, \"ibv_create_qp\", ibv_internal_create_qp);\n  LOAD_SYM(ibvhandle, \"ibv_modify_qp\", ibv_internal_modify_qp);\n  LOAD_SYM(ibvhandle, \"ibv_destroy_qp\", ibv_internal_destroy_qp);\n  LOAD_SYM(ibvhandle, \"ibv_fork_init\", ibv_internal_fork_init);\n  LOAD_SYM(ibvhandle, \"ibv_event_type_str\", ibv_internal_event_type_str);\n\n  ibvState = ibvInitialized;\n  return ncclSuccess;\n\nteardown:\n  ibv_internal_get_device_list = NULL;\n  ibv_internal_free_device_list = NULL;\n  ibv_internal_get_device_name = NULL;\n  ibv_internal_open_device = NULL;\n  ibv_internal_close_device = NULL;\n  ibv_internal_get_async_event = NULL;\n  ibv_internal_ack_async_event = NULL;\n  ibv_internal_query_device = NULL;\n  ibv_internal_query_port = NULL;\n  ibv_internal_query_gid = NULL;\n  ibv_internal_query_qp = NULL;\n  ibv_internal_alloc_pd = NULL;\n  ibv_internal_dealloc_pd = NULL;\n  ibv_internal_reg_mr = NULL;\n  ibv_internal_dereg_mr = NULL;\n  ibv_internal_create_cq = NULL;\n  ibv_internal_destroy_cq = NULL;\n  ibv_internal_create_qp = NULL;\n  ibv_internal_modify_qp = NULL;\n  ibv_internal_destroy_qp = NULL;\n  ibv_internal_fork_init = NULL;\n  ibv_internal_event_type_str = NULL;\n\n  if (ibvhandle != NULL) dlclose(ibvhandle);\n  ibvState = ibvError;\n  return ncclSystemError;\n}\n\n#define IBV_PTR_CHECK_ERRNO(name_internal, call, retval, error_retval, name) \\\n  if (name_internal == NULL) { \\\n     WARN(\"lib wrapper not initialized.\"); \\\n     return ncclInternalError; \\\n  } \\\n  retval = call; \\\n  if (retval == error_retval) { \\\n    WARN(\"Call to \" name \" failed with error %s\", strerror(errno)); \\\n    return ncclSystemError; \\\n  } \\\n  return ncclSuccess;\n\n#define IBV_PTR_CHECK(name_internal, call, retval, error_retval, name) \\\n  if (name_internal == NULL) { \\\n     WARN(\"lib wrapper not initialized.\"); \\\n     return ncclInternalError; \\\n  } \\\n  retval = call; \\\n  if (retval == error_retval) { \\\n    WARN(\"Call to \" name \" failed\"); \\\n    return ncclSystemError; \\\n  } \\\n  return ncclSuccess;\n\n#define IBV_INT_CHECK_RET_ERRNO(name_internal, call, success_retval, name) \\\n  if (name_internal == NULL) { \\\n     WARN(\"lib wrapper not initialized.\"); \\\n     return ncclInternalError; \\\n  } \\\n  int ret = call; \\\n  if (ret != success_retval) { \\\n    WARN(\"Call to \" name \" failed with error %s\", strerror(ret)); \\\n    return ncclSystemError; \\\n  } \\\n  return ncclSuccess;\n\n#define IBV_INT_CHECK(name_internal, call, error_retval, name) \\\n  if (name_internal == NULL) { \\\n     WARN(\"lib wrapper not initialized.\"); \\\n     return ncclInternalError; \\\n  } \\\n  int ret = call; \\\n  if (ret == error_retval) { \\\n    WARN(\"Call to \" name \" failed\"); \\\n    return ncclSystemError; \\\n  } \\\n  return ncclSuccess;\n\n#define IBV_PASSTHRU(name_internal, call) \\\n  if (name_internal == NULL) { \\\n     WARN(\"lib wrapper not initialized.\"); \\\n     return ncclInternalError; \\\n  } \\\n  call; \\\n  return ncclSuccess;\n\nncclResult_t wrap_ibv_fork_init() {\n  IBV_INT_CHECK(ibv_internal_fork_init, ibv_internal_fork_init(), -1, \"ibv_fork_init\");\n}\n\nncclResult_t wrap_ibv_get_device_list(struct ibv_device ***ret, int *num_devices) {\n  *ret = ibv_internal_get_device_list(num_devices);\n  if (*ret == NULL) *num_devices = 0;\n  return ncclSuccess;\n}\n\nncclResult_t wrap_ibv_free_device_list(struct ibv_device **list) {\n  IBV_PASSTHRU(ibv_internal_free_device_list, ibv_internal_free_device_list(list));\n}\n\nconst char *wrap_ibv_get_device_name(struct ibv_device *device) {\n  if (ibv_internal_get_device_name == NULL) {\n    WARN(\"lib wrapper not initialized.\");\n    exit(-1);\n  }\n  return ibv_internal_get_device_name(device);\n}\n\nncclResult_t wrap_ibv_open_device(struct ibv_context **ret, struct ibv_device *device) { /*returns 0 on success, -1 on failure*/\n  IBV_PTR_CHECK(ibv_internal_open_device, ibv_internal_open_device(device), *ret, NULL, \"ibv_open_device\");\n}\n\nncclResult_t wrap_ibv_close_device(struct ibv_context *context) { /*returns 0 on success, -1 on failure*/\n  IBV_INT_CHECK(ibv_internal_close_device, ibv_internal_close_device(context), -1, \"ibv_close_device\");\n}\n\nncclResult_t wrap_ibv_get_async_event(struct ibv_context *context, struct ibv_async_event *event) { /*returns 0 on success, and -1 on error*/\n  IBV_INT_CHECK(ibv_internal_get_async_event, ibv_internal_get_async_event(context, event), -1, \"ibv_get_async_event\");\n}\n\nncclResult_t wrap_ibv_ack_async_event(struct ibv_async_event *event) {\n  IBV_PASSTHRU(ibv_internal_ack_async_event, ibv_internal_ack_async_event(event));\n}\n\nncclResult_t wrap_ibv_query_device(struct ibv_context *context, struct ibv_device_attr *device_attr) { /*returns 0 on success, or the value of errno on failure (which indicates the failure reason)*/\n  IBV_INT_CHECK_RET_ERRNO(ibv_internal_query_device, ibv_internal_query_device(context, device_attr), 0, \"ibv_query_device\");\n}\n\nncclResult_t wrap_ibv_query_port(struct ibv_context *context, uint8_t port_num, struct ibv_port_attr *port_attr) { /*returns 0 on success, or the value of errno on failure (which indicates the failure reason)*/\n  IBV_INT_CHECK_RET_ERRNO(ibv_internal_query_port, ibv_internal_query_port(context, port_num, port_attr), 0, \"ibv_query_port\");\n}\n\nncclResult_t wrap_ibv_query_gid(struct ibv_context *context, uint8_t port_num, int index, union ibv_gid *gid) {\n  IBV_INT_CHECK_RET_ERRNO(ibv_internal_query_gid, ibv_internal_query_gid(context, port_num, index, gid), 0, \"ibv_query_gid\");\n}\n\nncclResult_t wrap_ibv_query_qp(struct ibv_qp *qp, struct ibv_qp_attr *attr, int attr_mask, struct ibv_qp_init_attr *init_attr) {\n  IBV_INT_CHECK_RET_ERRNO(ibv_internal_query_qp, ibv_internal_query_qp(qp, attr, attr_mask, init_attr), 0, \"ibv_query_qp\");\n}\n\nncclResult_t wrap_ibv_alloc_pd(struct ibv_pd **ret, struct ibv_context *context) {\n  IBV_PTR_CHECK(ibv_internal_alloc_pd, ibv_internal_alloc_pd(context), *ret, NULL, \"ibv_alloc_pd\");\n}\n\nncclResult_t wrap_ibv_dealloc_pd(struct ibv_pd *pd) { /*returns 0 on success, or the value of errno on failure (which indicates the failure reason)*/\n  IBV_INT_CHECK_RET_ERRNO(ibv_internal_dealloc_pd, ibv_internal_dealloc_pd(pd), 0, \"ibv_dealloc_pd\");\n}\n\nncclResult_t wrap_ibv_reg_mr(struct ibv_mr **ret, struct ibv_pd *pd, void *addr, size_t length, int access) {\n  IBV_PTR_CHECK(ibv_internal_reg_mr, ibv_internal_reg_mr(pd, addr, length, access), *ret, NULL, \"ibv_reg_mr\");\n}\n\nstruct ibv_mr * wrap_direct_ibv_reg_mr(struct ibv_pd *pd, void *addr, size_t length, int access) {\n  if (ibv_internal_reg_mr == NULL) {\n    WARN(\"lib wrapper not initialized.\");\n    return NULL;\n  }\n  return ibv_internal_reg_mr(pd, addr, length, access);\n}\n\nncclResult_t wrap_ibv_dereg_mr(struct ibv_mr *mr) { /*returns 0 on success, or the value of errno on failure (which indicates the failure reason)*/\n  IBV_INT_CHECK_RET_ERRNO(ibv_internal_dereg_mr, ibv_internal_dereg_mr(mr), 0, \"ibv_dereg_mr\");\n}\n\nncclResult_t wrap_ibv_create_cq(struct ibv_cq **ret, struct ibv_context *context, int cqe, void *cq_context, struct ibv_comp_channel *channel, int comp_vector) {\n  IBV_PTR_CHECK(ibv_internal_create_cq, ibv_internal_create_cq(context, cqe, cq_context, channel, comp_vector), *ret, NULL, \"ibv_create_cq\");\n}\n\nncclResult_t wrap_ibv_destroy_cq(struct ibv_cq *cq) {\n  IBV_INT_CHECK_RET_ERRNO(ibv_internal_destroy_cq, ibv_internal_destroy_cq(cq), 0, \"ibv_destroy_cq\");\n}\n\nncclResult_t wrap_ibv_destroy_qp(struct ibv_qp *qp) {\n  IBV_INT_CHECK_RET_ERRNO(ibv_internal_destroy_qp, ibv_internal_destroy_qp(qp), 0, \"ibv_destroy_qp\");\n}\n\nncclResult_t wrap_ibv_create_qp(struct ibv_qp **ret, struct ibv_pd *pd, struct ibv_qp_init_attr *qp_init_attr) {\n  IBV_PTR_CHECK(ibv_internal_create_qp, ibv_internal_create_qp(pd, qp_init_attr), *ret, NULL, \"ibv_create_qp\");\n}\n\nncclResult_t wrap_ibv_modify_qp(struct ibv_qp *qp, struct ibv_qp_attr *attr, int attr_mask) { /*returns 0 on success, or the value of errno on failure (which indicates the failure reason)*/\n  IBV_INT_CHECK_RET_ERRNO(ibv_internal_modify_qp, ibv_internal_modify_qp(qp, attr, attr_mask), 0, \"ibv_modify_qp\");\n}\n\nncclResult_t wrap_ibv_event_type_str(char **ret, enum ibv_event_type event) {\n  *ret = (char *) ibv_internal_event_type_str(event);\n  return ncclSuccess;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-nccl-2.3.5-5-naybqvojxe5avbgrcfvu2idw6tif3rnt/spack-src/src/misc/nvmlwrap.cu": "/*************************************************************************\n * Copyright (c) 2015-2018, NVIDIA CORPORATION. All rights reserved.\n *\n * See LICENSE.txt for license information\n ************************************************************************/\n\n#include \"nvmlwrap.h\"\n\n#ifndef NVML_DIRECT\n#include <dlfcn.h>\n#include \"core.h\"\n\nstatic enum { nvmlUninitialized, nvmlInitializing, nvmlInitialized, nvmlError } nvmlState = nvmlUninitialized;\n\nstatic nvmlReturn_t (*nvmlInternalInit)(void);\nstatic nvmlReturn_t (*nvmlInternalShutdown)(void);\nstatic nvmlReturn_t (*nvmlInternalDeviceGetHandleByPciBusId)(const char* pciBusId, nvmlDevice_t* device);\nstatic nvmlReturn_t (*nvmlInternalDeviceGetIndex)(nvmlDevice_t device, unsigned* index);\nstatic nvmlReturn_t (*nvmlInternalDeviceSetCpuAffinity)(nvmlDevice_t device);\nstatic nvmlReturn_t (*nvmlInternalDeviceClearCpuAffinity)(nvmlDevice_t device);\nstatic const char* (*nvmlInternalErrorString)(nvmlReturn_t r);\nstatic nvmlReturn_t (*nvmlInternalDeviceGetNvLinkState)(nvmlDevice_t device, unsigned int link, nvmlEnableState_t *isActive);\nstatic nvmlReturn_t (*nvmlInternalDeviceGetPciInfo)(nvmlDevice_t device, nvmlPciInfo_t* pci);\nstatic nvmlReturn_t (*nvmlInternalDeviceGetNvLinkRemotePciInfo)(nvmlDevice_t device, unsigned int link, nvmlPciInfo_t *pci);\nstatic nvmlReturn_t (*nvmlInternalDeviceGetNvLinkCapability)(nvmlDevice_t device, unsigned int link,\n    nvmlNvLinkCapability_t capability, unsigned int *capResult);\n\nncclResult_t wrapNvmlSymbols(void) {\n  if (nvmlState == nvmlInitialized)\n    return ncclSuccess;\n  if (nvmlState == nvmlError)\n    return ncclSystemError;\n\n  if (__sync_bool_compare_and_swap(&nvmlState, nvmlUninitialized, nvmlInitializing) == false) {\n    // Another thread raced in front of us. Wait for it to be done.\n    while (nvmlState == nvmlInitializing) pthread_yield();\n    return (nvmlState == nvmlInitialized) ? ncclSuccess : ncclSystemError;\n  }\n\n  static void* nvmlhandle = NULL;\n  void* tmp;\n  void** cast;\n\n  nvmlhandle=dlopen(\"libnvidia-ml.so.1\", RTLD_NOW);\n  if (!nvmlhandle) {\n    WARN(\"Failed to open libnvidia-ml.so.1\");\n    goto teardown;\n  }\n\n#define LOAD_SYM(handle, symbol, funcptr) do {         \\\n    cast = (void**)&funcptr;                             \\\n    tmp = dlsym(handle, symbol);                         \\\n    if (tmp == NULL) {                                   \\\n      WARN(\"dlsym failed on %s - %s\", symbol, dlerror());\\\n      goto teardown;                                     \\\n    }                                                    \\\n    *cast = tmp;                                         \\\n  } while (0)\n\n#define LOAD_SYM_OPTIONAL(handle, symbol, funcptr) do {\\\n    cast = (void**)&funcptr;                             \\\n    tmp = dlsym(handle, symbol);                         \\\n    if (tmp == NULL) {                                   \\\n      INFO(INIT,\"dlsym failed on %s, ignoring\", symbol); \\\n    }                                                    \\\n    *cast = tmp;                                         \\\n  } while (0)\n\n  LOAD_SYM(nvmlhandle, \"nvmlInit\", nvmlInternalInit);\n  LOAD_SYM(nvmlhandle, \"nvmlShutdown\", nvmlInternalShutdown);\n  LOAD_SYM(nvmlhandle, \"nvmlDeviceGetHandleByPciBusId\", nvmlInternalDeviceGetHandleByPciBusId);\n  LOAD_SYM(nvmlhandle, \"nvmlDeviceGetIndex\", nvmlInternalDeviceGetIndex);\n  LOAD_SYM(nvmlhandle, \"nvmlDeviceSetCpuAffinity\", nvmlInternalDeviceSetCpuAffinity);\n  LOAD_SYM(nvmlhandle, \"nvmlDeviceClearCpuAffinity\", nvmlInternalDeviceClearCpuAffinity);\n  LOAD_SYM(nvmlhandle, \"nvmlErrorString\", nvmlInternalErrorString);\n  LOAD_SYM(nvmlhandle, \"nvmlDeviceGetPciInfo\", nvmlInternalDeviceGetPciInfo);\n  LOAD_SYM_OPTIONAL(nvmlhandle, \"nvmlDeviceGetNvLinkState\", nvmlInternalDeviceGetNvLinkState);\n  LOAD_SYM_OPTIONAL(nvmlhandle, \"nvmlDeviceGetNvLinkRemotePciInfo\", nvmlInternalDeviceGetNvLinkRemotePciInfo);\n  LOAD_SYM_OPTIONAL(nvmlhandle, \"nvmlDeviceGetNvLinkCapability\", nvmlInternalDeviceGetNvLinkCapability);\n\n  nvmlState = nvmlInitialized;\n  return ncclSuccess;\n\nteardown:\n  nvmlInternalInit = NULL;\n  nvmlInternalShutdown = NULL;\n  nvmlInternalDeviceGetHandleByPciBusId = NULL;\n  nvmlInternalDeviceGetIndex = NULL;\n  nvmlInternalDeviceSetCpuAffinity = NULL;\n  nvmlInternalDeviceClearCpuAffinity = NULL;\n  nvmlInternalDeviceGetPciInfo = NULL;\n  nvmlInternalDeviceGetNvLinkState = NULL;\n  nvmlInternalDeviceGetNvLinkRemotePciInfo = NULL;\n  nvmlInternalDeviceGetNvLinkCapability = NULL;\n\n  if (nvmlhandle != NULL) dlclose(nvmlhandle);\n  nvmlState = nvmlError;\n  return ncclSystemError;\n}\n\n\nncclResult_t wrapNvmlInit(void) {\n  if (nvmlInternalInit == NULL) {\n    WARN(\"lib wrapper not initialized.\");\n    return ncclInternalError;\n  }\n  nvmlReturn_t ret = nvmlInternalInit();\n  if (ret != NVML_SUCCESS) {\n    WARN(\"nvmlInit() failed: %s\",\n        nvmlInternalErrorString(ret));\n    return ncclSystemError;\n  }\n  return ncclSuccess;\n}\n\nncclResult_t wrapNvmlShutdown(void) {\n  if (nvmlInternalShutdown == NULL) {\n    WARN(\"lib wrapper not initialized.\");\n    return ncclInternalError;\n  }\n  nvmlReturn_t ret = nvmlInternalShutdown();\n  if (ret != NVML_SUCCESS) {\n    WARN(\"nvmlShutdown() failed: %s \",\n        nvmlInternalErrorString(ret));\n    return ncclSystemError;\n  }\n  return ncclSuccess;\n}\n\nncclResult_t wrapNvmlDeviceGetHandleByPciBusId(const char* pciBusId, nvmlDevice_t* device) {\n  if (nvmlInternalDeviceGetHandleByPciBusId == NULL) {\n    WARN(\"lib wrapper not initialized.\");\n    return ncclInternalError;\n  }\n  nvmlReturn_t ret = nvmlInternalDeviceGetHandleByPciBusId(pciBusId, device);\n  if (ret != NVML_SUCCESS) {\n    WARN(\"nvmlDeviceGetHandleByPciBusId() failed: %s \",\n        nvmlInternalErrorString(ret));\n    return ncclSystemError;\n  }\n  return ncclSuccess;\n}\n\nncclResult_t wrapNvmlDeviceGetIndex(nvmlDevice_t device, unsigned* index) {\n  if (nvmlInternalDeviceGetIndex == NULL) {\n    WARN(\"lib wrapper not initialized.\");\n    return ncclInternalError;\n  }\n  nvmlReturn_t ret = nvmlInternalDeviceGetIndex(device, index);\n  if (ret != NVML_SUCCESS) {\n    WARN(\"nvmlDeviceGetIndex() failed: %s \",\n        nvmlInternalErrorString(ret));\n    return ncclSystemError;\n  }\n  return ncclSuccess;\n}\n\nncclResult_t wrapNvmlDeviceSetCpuAffinity(nvmlDevice_t device) {\n  if (nvmlInternalDeviceSetCpuAffinity == NULL) {\n    WARN(\"lib wrapper not initialized.\");\n    return ncclInternalError;\n  }\n  // Workaround : it seems SetCpuAffinity is not thread safe.\n  static pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;\n  pthread_mutex_lock(&lock);\n  nvmlReturn_t ret = nvmlInternalDeviceSetCpuAffinity(device);\n  pthread_mutex_unlock(&lock);\n  if (ret != NVML_SUCCESS) {\n    WARN(\"nvmlDeviceSetCpuAffinity() failed: %s \",\n        nvmlInternalErrorString(ret));\n    return ncclSystemError;\n  }\n  return ncclSuccess;\n}\n\nncclResult_t wrapNvmlDeviceClearCpuAffinity(nvmlDevice_t device) {\n  if (nvmlInternalInit == NULL) {\n    WARN(\"lib wrapper not initialized.\");\n    return ncclInternalError;\n  }\n  nvmlReturn_t ret = nvmlInternalDeviceClearCpuAffinity(device);\n  if (ret != NVML_SUCCESS) {\n    WARN(\"nvmlDeviceClearCpuAffinity() failed: %s \",\n        nvmlInternalErrorString(ret));\n    return ncclSystemError;\n  }\n  return ncclSuccess;\n}\n\nncclResult_t wrapNvmlDeviceGetPciInfo(nvmlDevice_t device, nvmlPciInfo_t* pci) {\n  if (nvmlInternalDeviceGetPciInfo == NULL) {\n    WARN(\"lib wrapper not initialized.\");\n    return ncclInternalError;\n  }\n  nvmlReturn_t ret = nvmlInternalDeviceGetPciInfo(device, pci);\n  if (ret != NVML_SUCCESS) {\n    WARN(\"nvmlDeviceGetPciInfo() failed: %s \",\n        nvmlInternalErrorString(ret));\n    return ncclSystemError;\n  }\n  return ncclSuccess;\n}\n\nncclResult_t wrapNvmlDeviceGetNvLinkState(nvmlDevice_t device, unsigned int link, nvmlEnableState_t *isActive) {\n  if (nvmlInternalDeviceGetNvLinkState == NULL) {\n    /* Do not warn, this symbol is optional. */\n    return ncclInternalError;\n  }\n  nvmlReturn_t ret = nvmlInternalDeviceGetNvLinkState(device, link, isActive);\n  if (ret != NVML_SUCCESS) {\n    INFO(INIT,\"nvmlDeviceGetNvLinkState() failed: %s \",\n        nvmlInternalErrorString(ret));\n    return ncclSystemError;\n  }\n  return ncclSuccess;\n}\n\nncclResult_t wrapNvmlDeviceGetNvLinkRemotePciInfo(nvmlDevice_t device, unsigned int link, nvmlPciInfo_t *pci) {\n  if (nvmlInternalDeviceGetNvLinkRemotePciInfo == NULL) {\n    /* Do not warn, this symbol is optional. */\n    return ncclInternalError;\n  }\n  nvmlReturn_t ret = nvmlInternalDeviceGetNvLinkRemotePciInfo(device, link, pci);\n  if (ret != NVML_SUCCESS) {\n    if (ret != NVML_ERROR_NOT_SUPPORTED)\n      INFO(INIT,\"nvmlDeviceGetNvLinkRemotePciInfo() failed: %s \",\n          nvmlInternalErrorString(ret));\n    return ncclSystemError;\n  }\n  return ncclSuccess;\n}\n\nncclResult_t wrapNvmlDeviceGetNvLinkCapability(nvmlDevice_t device, unsigned int link,\n    nvmlNvLinkCapability_t capability, unsigned int *capResult) {\n  if (nvmlInternalDeviceGetNvLinkCapability == NULL) {\n    /* Do not warn, this symbol is optional. */\n    return ncclInternalError;\n  }\n  nvmlReturn_t ret = nvmlInternalDeviceGetNvLinkCapability(device, link, capability, capResult);\n  if (ret != NVML_SUCCESS) {\n    if (ret != NVML_ERROR_NOT_SUPPORTED)\n      INFO(INIT,\"nvmlDeviceGetNvLinkCapability() failed: %s \",\n          nvmlInternalErrorString(ret));\n    return ncclSystemError;\n  }\n  return ncclSuccess;\n}\n#endif\n"
    },
    "skipped": [],
    "total_files": 72
}