{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-libfabric-master-7qyp67ncottp7it3zyzdyxcucafartnj/spack-src/configure.ac": "dnl\ndnl Copyright (c) 2016 Cisco Systems, Inc.  All rights reserved.\ndnl Copyright (c) 2019 Intel, Inc.  All rights reserved.\ndnl Copyright (c) 2019-2020 Amazon.com, Inc. or its affiliates. All rights reserved.\ndnl (C) Copyright 2020 Hewlett Packard Enterprise Development LP\ndnl\ndnl Process this file with autoconf to produce a configure script.\n\nAC_PREREQ([2.60])\nAC_INIT([libfabric], [1.12.0rc1], [ofiwg@lists.openfabrics.org])\nAC_CONFIG_SRCDIR([src/fabric.c])\nAC_CONFIG_AUX_DIR(config)\nAC_CONFIG_MACRO_DIR(config)\nAC_CONFIG_HEADERS(config.h)\nAM_INIT_AUTOMAKE([1.11 dist-bzip2 foreign -Wall -Werror subdir-objects parallel-tests tar-pax])\nm4_ifdef([AM_SILENT_RULES], [AM_SILENT_RULES([yes])])\nm4_include(config/fi_check_package.m4)\n\nAC_CANONICAL_HOST\n\nmacos=0\nlinux=0\nfreebsd=0\n\ncase $host_os in\n*darwin*)\n\tmacos=1\n\t;;\n*linux*)\n\tlinux=1\n\t;;\n*freebsd*)\n\tfreebsd=1\n\t;;\n*)\n\tAC_MSG_ERROR([libfabric only builds on Linux, OS X, and FreeBSD])\n\t;;\nesac\n\nAM_CONDITIONAL([MACOS], [test \"x$macos\" = \"x1\"])\nAM_CONDITIONAL([LINUX], [test \"x$linux\" = \"x1\"])\nAM_CONDITIONAL([FREEBSD], [test \"x$freebsd\" = \"x1\"])\n\nbase_c_warn_flags=\"-Wall -Wundef -Wpointer-arith\"\ndebug_c_warn_flags=\"-Wextra -Wno-unused-parameter -Wno-sign-compare -Wno-missing-field-initializers\"\ndebug_c_other_flags=\"-fstack-protector-strong\"\npicky_c_warn_flags=\"-Wno-long-long -Wmissing-prototypes -Wstrict-prototypes -Wcomment -pedantic\"\n\nAC_ARG_WITH([build_id],\n\t    [AC_HELP_STRING([--with-build_id],\n\t\t\t    [Enable build_id annotation @<:@default=no@:>@])],\n\t    [], [with_build_id=no])\nAS_IF([test x\"$with_build_id\" = x\"no\"], [with_build_id=\"\"])\nAC_DEFINE_UNQUOTED([BUILD_ID],[\"$with_build_id\"],\n                   [adds build_id to version if it was defined])\n\n# Override autoconf default CFLAG settings (e.g. \"-g -O2\") while still\n# allowing the user to explicitly set CFLAGS=\"\"\n: ${CFLAGS=\"-fvisibility=hidden ${base_c_warn_flags}\"}\n\n# AM_PROG_AS would set CFLAGS=\"-g -O2\" by default if not set already so it\n# should not be called earlier\nAM_PROG_AS()\n\n# AM PROG_AR did not exist pre AM 1.11.x (where x is somewhere >0 and\n# <3), but it is necessary in AM 1.12.x.\nm4_ifdef([AM_PROG_AR], [AM_PROG_AR])\n\nAC_ARG_WITH([valgrind],\n    AC_HELP_STRING([--with-valgrind],\n\t\t   [Enable valgrind annotations @<:@default=no@:>@]))\n\nif test \"$with_valgrind\" != \"\" && test \"$with_valgrind\" != \"no\"; then\n\tAC_DEFINE([INCLUDE_VALGRIND], 1,\n\t\t  [Define to 1 to enable valgrind annotations])\n\tif test -d $with_valgrind; then\n\t\tCPPFLAGS=\"$CPPFLAGS -I$with_valgrind/include\"\n\tfi\nfi\n\nAC_ARG_ENABLE([direct],\n\t[AS_HELP_STRING([--enable-direct=@<:@provider@:>@],\n\t\t[Enable direct calls to a fabric provider @<:@default=no@:>@])\n\t],\n\t[],\n\t[enable_direct=no])\n\n\nAC_ARG_ENABLE([atomics],\n\t[AS_HELP_STRING([--enable-atomics],\n\t\t[Enable atomics support @<:@default=yes@:>@])\n\t],\n\t[],\n\t[enable_atomics=yes])\n\ndnl Checks for programs\nAC_PROG_CC_C99\nAS_IF([test \"$ac_cv_prog_cc_c99\" = \"no\"],\n      [AC_MSG_WARN([Libfabric requires a C99-compliant compiler])\n       AC_MSG_ERROR([Cannot continue])])\nAM_PROG_CC_C_O\nAC_PROG_CPP\n\nAC_ARG_ENABLE([debug],\n\t      [AS_HELP_STRING([--enable-debug],\n\t\t\t      [Enable debugging @<:@default=no@:>@])\n\t      ],\n\t      [],\n\t      [enable_debug=no])\n\nAS_IF([test x\"$enable_debug\" != x\"no\"],\n      [dbg=1\n       # See if all the flags in $debug_c_other_flags work\n       good_flags=\n       CFLAGS_save=\"$CFLAGS\"\n       for flag in $debug_c_other_flags; do\n           AC_MSG_CHECKING([to see if compiler supports $flag])\n           CFLAGS=\"$flag $CFLAGS_save\"\n           AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[]], [[int i = 3;]])],\n\t                     [AC_MSG_RESULT([yes])\n\t\t\t      good_flags=\"$flag $good_flags\"],\n\t\t\t     [AC_MSG_RESULT([no])])\n       done\n       debug_c_other_flags=$good_flags\n       unset good_flags\n\n       CFLAGS=\"-g -O0 ${base_c_warn_flags} ${debug_c_warn_flags} ${debug_c_other_flags} ${CFLAGS_save}\"\n       unset CFLAGS_save],\n      [dbg=0\n       CFLAGS=\"-O2 -DNDEBUG $CFLAGS\"])\n\nAC_DEFINE_UNQUOTED([ENABLE_DEBUG],[$dbg],\n                   [defined to 1 if libfabric was configured with --enable-debug, 0 otherwise])\n\ndnl Checks for header files.\nAC_HEADER_STDC\n\ndnl Check for compiler features\nAC_C_TYPEOF\n\nLT_INIT\nLT_OUTPUT\n\ndnl dlopen support is optional\nAC_ARG_WITH([dlopen],\n\tAC_HELP_STRING([--with-dlopen],\n\t\t       [dl-loadable provider support @<:@default=yes@:>@]),\n\t)\n\nif test \"$freebsd\" == \"0\"; then\nAS_IF([test x\"$with_dlopen\" != x\"no\"], [\nAC_CHECK_LIB(dl, dlopen, [],\n    AC_MSG_ERROR([dlopen not found.  libfabric requires libdl.]))\n])\nfi\n\ndnl handle picky option\nAC_ARG_ENABLE([picky],\n    [AC_HELP_STRING([--enable-picky],\n                    [Enable developer-level compiler pickyness when building @<:@default=no@:>@])])\nAS_IF([test x\"$enable_picky\" = x\"yes\" && test x\"$GCC\" = x\"yes\"],\n      [AS_IF([test x\"$enable_debug\" = x\"no\"],\n             [CFLAGS=\"${base_c_warn_flags} ${debug_c_warn_flags}\n\t\t      ${debug_c_other_flags} ${picky_c_warn_flags} $CFLAGS\"],\n             [CFLAGS=\"${picky_c_warn_flags} $CFLAGS\"])\n      ])\n\ndnl Checks for libraries\nAC_CHECK_LIB(pthread, pthread_mutex_init, [],\n    AC_MSG_ERROR([pthread_mutex_init() not found.  libfabric requires libpthread.]))\n\nAC_CHECK_FUNC([pthread_spin_init],\n\t[have_spinlock=1],\n\t[have_spinlock=0])\n\ndnl shm_open not used in the common code on os-x\n\nif test \"$macos\" -eq 0; then\nAC_CHECK_FUNC([shm_open],\n\t[],\n\t[AC_SEARCH_LIBS([shm_open],[rt],[],\n\t [AC_MSG_ERROR([shm_open() not found.  libfabric requires shm_open.])])])\nfi\n\nAC_DEFINE_UNQUOTED([PT_LOCK_SPIN], [$have_spinlock],\n\t[Define to 1 if pthread_spin_init is available.])\n\nAC_ARG_ENABLE([epoll],\n    [AS_HELP_STRING([--disable-epoll],\n        [Disable epoll if available@<:@default=no@:>@])],\n    [],\n    [enable_epoll=auto]\n)\n\nAS_IF([test x\"$enable_epoll\" != x\"no\"],\n    [AC_CHECK_FUNCS([epoll_create])\n     if test \"$ac_cv_func_epoll_create\" = yes; then\n        AC_DEFINE([HAVE_EPOLL], [1], [Define if you have epoll support.])\n     fi]\n)\n\nAC_CHECK_HEADER([linux/perf_event.h],\n    [AC_CHECK_DECL([__builtin_ia32_rdpmc],\n        [\n            AC_TRY_LINK([#include <linux/perf_event.h>],\n                [__builtin_ia32_rdpmc(0);],\n                [linux_perf_rdpmc=1],\n                [linux_perf_rdpmc=0])\n\t],\n        [linux_perf_rdpmc=0],\n        [#include <linux/perf_event.h>])],\n    [linux_perf_rdpmc=0])\nAC_DEFINE_UNQUOTED(HAVE_LINUX_PERF_RDPMC, [$linux_perf_rdpmc],\n    [Whether we have __builtin_ia32_rdpmc() and linux/perf_event.h file or not])\nAM_CONDITIONAL([HAVE_LINUX_PERF_RDPMC], [test \"x$linux_perf_rdpmc\" = \"x1\"])\n\ndnl Check for gcc atomic intrinsics\nAS_IF([test x\"$enable_atomics\" != x\"no\"],\n    AC_MSG_CHECKING(compiler support for c11 atomics)\n    AC_TRY_LINK([#include <stdatomic.h>],\n        [atomic_int a;\n         atomic_init(&a, 0);\n         #ifdef __STDC_NO_ATOMICS__\n           #error c11 atomics are not supported\n         #else\n           return 0;\n         #endif\n        ],\n        [\n        AC_MSG_RESULT(yes)\n            AC_DEFINE(HAVE_ATOMICS, 1, [Set to 1 to use c11 atomic functions])\n        ],\n        [AC_MSG_RESULT(no)])\n\n\n    AC_MSG_CHECKING(compiler support for c11 atomic `least` types)\n    AC_TRY_LINK([#include <stdatomic.h>],\n        [atomic_int_least32_t a;\n         atomic_int_least64_t b;\n        ],\n        [\n            AC_MSG_RESULT(yes)\n            AC_DEFINE(HAVE_ATOMICS_LEAST_TYPES, 1,\n                      [Set to 1 to use c11 atomic `least` types])\n        ],\n        [\n            AC_MSG_RESULT(no)\n        ]),\n[\n    AC_MSG_RESULT(configure: atomics support for c11 is disabled)\n])\n\ndnl Check for gcc built-in atomics\nAS_IF([test x\"$enable_atomics\" != x\"no\"],\n    AC_MSG_CHECKING(compiler support for built-in atomics)\n    AC_TRY_LINK([#include <stdint.h>],\n        [int32_t a;\n         __sync_add_and_fetch(&a, 0);\n         __sync_sub_and_fetch(&a, 0);\n         #if defined(__PPC__) && !defined(__PPC64__)\n           #error compiler built-in atomics are not supported on PowerPC 32-bit\n         #else\n           return 0;\n         #endif\n        ],\n        [\n        AC_MSG_RESULT(yes)\n            AC_DEFINE(HAVE_BUILTIN_ATOMICS, 1, [Set to 1 to use built-in intrincics atomics])\n        ],\n        [AC_MSG_RESULT(no)]),\n[\n    AC_MSG_RESULT(configure: atomics support built-in is disabled)\n])\n\ndnl Check for gcc memory model aware built-in atomics\ndnl If supported check to see if not internal to compiler\nLIBS_save=$LIBS\nAC_SEARCH_LIBS([__atomic_load_8], [atomic])\nAS_IF([test x\"$enable_atomics\" != x\"no\"],\n    AC_MSG_CHECKING(compiler support for built-in memory model aware atomics)\n    AC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <stdint.h>]],\n        [[uint64_t d;\n         uint64_t s;\n         uint64_t c;\n         uint64_t r;\n          r = __atomic_fetch_add(&d, s, __ATOMIC_SEQ_CST);\n          r = __atomic_load_8(&d, __ATOMIC_SEQ_CST);\n          __atomic_exchange(&d, &s, &r, __ATOMIC_SEQ_CST);\n          __atomic_compare_exchange(&d,&c,&s,0, __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST);\n         #if defined(__PPC__) && !defined(__PPC64__)\n           #error compiler built-in memory model aware atomics are not supported on PowerPC 32-bit\n         #else\n           return 0;\n         #endif\n        ]])],\n        [\n            AC_MSG_RESULT(yes)\n            AC_DEFINE(HAVE_BUILTIN_MM_ATOMICS, 1, [Set to 1 to use built-in intrinsics memory model aware atomics])\n        ],\n        [\n            AC_MSG_RESULT(no)\n            LIBS=$LIBS_save\n        ]),\n[\n    AC_MSG_RESULT(configure: -latomic key is disabled)\n    LIBS=$LIBS_save\n])\nunset LIBS_save\n\ndnl Check for gcc cpuid intrinsics\nAC_MSG_CHECKING(compiler support for cpuid)\nAC_TRY_LINK([\n     #include <stddef.h>\n     #include <cpuid.h>],\n    [\n     int a, b, c, d;\n     __cpuid_count(0, 0, a, b, c, d);\n    ],\n    [\n\tAC_MSG_RESULT(yes)\n        AC_DEFINE(HAVE_CPUID, 1, [Set to 1 to use cpuid])\n    ],\n    [AC_MSG_RESULT(no)])\n\nif test \"$with_valgrind\" != \"\" && test \"$with_valgrind\" != \"no\"; then\nAC_CHECK_HEADER(valgrind/memcheck.h, [],\n    AC_MSG_ERROR([valgrind requested but <valgrind/memcheck.h> not found.]))\nfi\n\nAC_CACHE_CHECK(whether ld accepts --version-script, ac_cv_version_script,\n    [if test -n \"`$LD --help < /dev/null 2>/dev/null | grep version-script`\"; then\n        ac_cv_version_script=yes\n    else\n        ac_cv_version_script=no\n    fi])\n\nAC_ARG_ENABLE([embedded],\n\t      [AS_HELP_STRING([--enable-embedded],\n\t\t\t      [Enable embedded support (turns off symbol versioning) @<:@default=no@:>@])\n\t      ],\n\t      [ac_asm_symver_support=0\n               icc_symver_hack=1],\n\t      [enable_embedded=no])\nAM_CONDITIONAL([EMBEDDED], [test x\"$enable_embedded\" = x\"yes\"])\n\nAM_CONDITIONAL(HAVE_LD_VERSION_SCRIPT, test \"$ac_cv_version_script\" = \"yes\")\n\ndnl Disable symbol versioning when -ipo is in CFLAGS or ipo is disabled by icc.\ndnl The gcc equivalent ipo (-fwhole-program) seems to work fine.\nAS_CASE([$CFLAGS],\n\t[*-ipo*],[\n\t\tAC_MSG_NOTICE([disabling symbol versioning support with -ipo CFLAG])\n\t\ticc_symver_hack=1\n\t\tac_asm_symver_support=0\n\t],\n\t[]\n)\n\ndnl Check for symbol versioning compiler + linker support.\ndnl If icc + ipo, then print disabled and skip check\nAC_MSG_CHECKING(for .symver assembler support)\nAS_IF([test \"$icc_symver_hack\"],\n\t[AC_MSG_RESULT(disabled)],\n[\n\nAC_TRY_LINK([__asm__(\".symver main_, main@ABIVER_1.0\");],\n\t[],\n\t[\n\t\tAC_MSG_RESULT(yes)\n\t\tac_asm_symver_support=1\n\t],\n\t[\n\t\tAC_MSG_RESULT(no)\n\t\tac_asm_symver_support=0\n\t])\n\n]) dnl AS_IF icc_symver_hack\n\nAC_DEFINE_UNQUOTED([HAVE_SYMVER_SUPPORT], [$ac_asm_symver_support],\n\t  \t   [Define to 1 if compiler/linker support symbol versioning.])\n\nAC_MSG_CHECKING(for __alias__ attribute support)\nAC_TRY_LINK(\n\t[\n\t\tint foo(int arg);\n\t\tint foo(int arg) { return arg + 3; };\n\t\tint foo2(int arg) __attribute__ (( __alias__(\"foo\")));\n\t],\n\t[ foo2(1); ],\n\t[\n\t\tAC_MSG_RESULT(yes)\n\t\tac_prog_cc_alias_symbols=1\n\t],\n\t[\n\t\tAC_MSG_RESULT(no)\n\t\tac_prog_cc_alias_symbols=0\n\t])\n\nAC_DEFINE_UNQUOTED([HAVE_ALIAS_ATTRIBUTE], [$ac_prog_cc_alias_symbols],\n\t  \t   [Define to 1 if the linker supports alias attribute.])\nAC_CHECK_FUNCS([getifaddrs])\n\ndnl Check for ethtool support\nAC_MSG_CHECKING(ethtool support)\nAC_TRY_LINK([\n    #include <net/if.h>\n    #include <sys/types.h>\n    #include <linux/ethtool.h>\n    #include <linux/sockios.h>\n    #include <sys/ioctl.h>],\n    [\n        unsigned long ioctl_req = SIOCETHTOOL;\n        struct ethtool_cmd cmd = {\n            .cmd = ETHTOOL_GSET,\n        };\n        long speed = cmd.speed;\n    ],\n    [\n\tAC_MSG_RESULT(yes)\n        AC_DEFINE(HAVE_ETHTOOL, 1, [Set to 1 to use ethtool])\n\n    ],\n    [AC_MSG_RESULT(no)])\n\ndnl Check for ethtool SPEED_UNKNOWN macro (suppoirted in the linux\ndnl kernel >= 3.2) and ethtool_cmd_speed function declarations\ndnl supported in the linux kernel >= 2.6.26\nAC_CHECK_DECLS([ethtool_cmd_speed, SPEED_UNKNOWN], [], [],\n               [#include <linux/ethtool.h>])\n\ndnl Check for userfault fd support\nhave_uffd=0\nAC_CHECK_HEADERS([linux/userfaultfd.h],\n\t[AC_CHECK_DECL([__NR_userfaultfd],\n\t\t[have_uffd=1],\n\t\t[],\n\t\t[[#include <sys/syscall.h>]])],\n\t[], [])\n\nAS_IF([test $have_uffd -eq 1],\n\t[AC_MSG_CHECKING([for userfaultfd unmap support])\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n\t\t\t#include <sys/types.h>\n\t\t\t#include <linux/userfaultfd.h>\n\t\t\t#include <unistd.h>\n\t\t\t#include <sys/syscall.h>\n\t\t\t#include <fcntl.h>\n\t\t\t#include <sys/ioctl.h>\n\t\t]],\n\t\t[[\n\t\t\tint fd;\n\t\t\tstruct uffdio_api api_obj;\n\t\t\tapi_obj.api = UFFD_API;\n\t\t\tapi_obj.features = UFFD_FEATURE_EVENT_UNMAP |\n\t\t\t\t\tUFFD_FEATURE_EVENT_REMOVE |\n\t\t\t\t\tUFFD_FEATURE_EVENT_REMAP;\n\t\t\tfd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);\n\t\t\treturn ioctl(fd, UFFDIO_API, &api_obj);\n\t\t]])\n\t],\n\t[AC_MSG_RESULT([yes])],\n\t[AC_MSG_RESULT([no])\n\t\thave_uffd=0])])\n\nAC_DEFINE_UNQUOTED([HAVE_UFFD_UNMAP], [$have_uffd],\n\t[Define to 1 if platform supports userfault fd unmap])\n\ndnl Check support to intercept syscalls\nAC_CHECK_HEADERS_ONCE(elf.h sys/auxv.h)\n\ndnl Check support to clock_gettime\nhave_clock_gettime=0\n\nAC_SEARCH_LIBS([clock_gettime],[rt],\n         [have_clock_gettime=1],\n         [])\n\nAC_DEFINE_UNQUOTED(HAVE_CLOCK_GETTIME, [$have_clock_gettime],\n       [Define to 1 if clock_gettime is available.])\nAM_CONDITIONAL(HAVE_CLOCK_GETTIME, [test $have_clock_gettime -eq 1])\n\ndnl Check for CUDA runtime libraries.\nAC_ARG_WITH([cuda],\n\t    [AC_HELP_STRING([--with-cuda=DIR],\n\t\t\t    [Provide path to where the CUDA development\n\t\t\t    and runtime libraries are installed.])],\n\t    [], [])\n\nhave_libcuda=0\nAS_IF([test x\"$with_cuda\" != x\"no\"],\n\t    [FI_CHECK_PACKAGE([cuda],\n\t\t\t      [cuda_runtime.h],\n\t\t\t      [cudart],\n\t\t\t      [cudaMemcpy],\n\t\t\t      [-lcuda],\n\t\t\t      [$with_cuda],\n\t\t\t      [],\n\t\t\t      [have_libcuda=1],\n\t\t\t      [],\n\t\t\t      [])],\n\t    [])\n\nAS_IF([test x\"$with_cuda\" != x\"no\" && test -n \"$with_cuda\" && test \"$have_libcuda\" = \"0\" ],\n\t[AC_MSG_ERROR([CUDA support requested but CUDA runtime not available.])],\n\t[])\nAC_DEFINE_UNQUOTED([HAVE_LIBCUDA], [$have_libcuda], [Whether we have CUDA runtime or not])\n\nAC_ARG_ENABLE([cuda-dlopen],\n    [AS_HELP_STRING([--enable-cuda-dlopen],\n        [Enable dlopen of CUDA libraries @<:@default=no@:>@])\n    ],\n    [\n        AS_IF([test \"$freebsd\" == \"0\"], [\n            AC_CHECK_LIB(dl, dlopen, [],\n                [AC_MSG_ERROR([dlopen not found.  libfabric requires libdl.])])\n        ])\n        AC_DEFINE([ENABLE_CUDA_DLOPEN], [1], [dlopen CUDA libraries])\n    ],\n    [enable_cuda_dlopen=no])\n\nAC_ARG_WITH([ze],\n\tAC_HELP_STRING([--with-ze=DIR], [Provide path to where the ZE\n\t\t\t\t\t libraries and headers are installed.]),\n\t[], [])\n\nAS_IF([test x\"$with_ze\" != x\"no\"],\n      [FI_CHECK_PACKAGE([ze],\n\t\t\t[level_zero/ze_api.h],\n\t\t\t[ze_loader],\n\t\t\t[zeInit],\n\t\t\t[],\n\t\t\t[$with_ze],\n\t\t\t[],\n\t\t\t[AC_DEFINE([HAVE_LIBZE], [1],[ZE support])],\n\t\t\t[], [])\n       CPPFLAGS=\"$CPPFLAGS $ze_CPPFLAGS\"\n       LDFLAGS=\"$LDFLAGS $ze_LDFLAGS\"\n       LIBS=\"$LIBS $ze_LIBS\"],\n      [])\n\nenable_memhooks=1\nAC_ARG_ENABLE([memhooks-monitor],\n              [AC_HELP_STRING([--disable-memhooks-monitor],\n                              [Determine whether memhooks memory monitor is disabled.])],\n              [enable_memhooks=0],\n              [])\n\nAC_DEFINE_UNQUOTED(ENABLE_MEMHOOKS_MONITOR, [$enable_memhooks],\n\t[Define to 1 to enable memhooks memory monitor])\n\nAS_IF([test \"$enable_memhooks\" == \"1\"], [\n\tAC_CHECK_FUNCS([__curbrk __clear_cache])\n\tAC_CHECK_HEADERS([linux/mman.h sys/syscall.h])\n\tAC_CHECK_DECLS([__syscall], [], [], [#include <sys/syscall.h>])\n\tAC_CHECK_FUNCS([__syscall])\n\t], [])\n\nenable_uffd=1\nAC_ARG_ENABLE([uffd-monitor],\n              [AC_HELP_STRING([--disable-uffd-monitor],\n                              [Determine whether uffd memory monitor is disabled.])],\n              [enable_uffd=0],\n              [])\n\nAC_DEFINE_UNQUOTED(ENABLE_UFFD_MONITOR, [$enable_uffd],\n\t[Define to 1 to enable uffd memory monitor])\n\n\nAH_BOTTOM([\n#if defined(__linux__) && (defined(__x86_64__) || defined(__amd64__) || defined(__aarch64__)) && ENABLE_MEMHOOKS_MONITOR\n#define HAVE_MEMHOOKS_MONITOR 1\n#else\n#define HAVE_MEMHOOKS_MONITOR 0\n#endif\n\n#if HAVE_UFFD_UNMAP && ENABLE_UFFD_MONITOR\n#define HAVE_UFFD_MONITOR 1\n#else\n#define HAVE_UFFD_MONITOR 0\n#endif\n])\n\nCPPFLAGS=\"$CPPFLAGS $cuda_CPPFLAGS\"\nLDFLAGS=\"$LDFLAGS $cuda_LDFLAGS\"\n\nAS_IF([test x\"$enable_cuda_dlopen\" != x\"yes\"], [LIBS=\"$LIBS $cuda_LIBS\"])\n\n#gdrcopy related configs\nAC_ARG_WITH([gdrcopy],\n\t    [AC_HELP_STRING([--with-gdrcopy=DIR],\n\t\t\t    [Provide path to where the gdrcopy development\n\t\t\t    and runtime libraries are installed.])],\n\t    [], [])\n\nFI_CHECK_PACKAGE([gdrcopy],\n\t\t [gdrapi.h],\n\t\t [gdrapi],\n\t\t [gdr_open],\n\t\t [-lgdrapi],\n\t\t [$with_gdrcopy],\n\t\t [],\n\t\t [AC_DEFINE([HAVE_GDRCOPY], [1],[gdrcopy support])],\n\t\t [], [])\n\nAC_ARG_ENABLE([gdrcopy-dlopen],\n    [AS_HELP_STRING([--enable-gdrcopy-dlopen],\n        [Enable dlopen of gdrcopy libraries @<:@default=no@:>@])\n    ],\n    [\n        AS_IF([test \"$freebsd\" == \"0\"], [\n            AC_CHECK_LIB(dl, dlopen, [],\n                [AC_MSG_ERROR([dlopen not found.  libfabric requires libdl.])])\n        ])\n        AC_DEFINE([ENABLE_GDRCOPY_DLOPEN], [1], [dlopen CUDA libraries])\n    ],\n    [enable_gdrcopy_dlopen=no])\n\nCPPFLAGS=\"$CPPFLAGS $gdrcopy_CPPFLAGS\"\nLDFLAGS=\"$LDFLAGS $gdrcopy_LDFLAGS\"\nAS_IF([test x\"$enable_gdrcopy_dlopen\" != x\"yes\"], [LIBS=\"$LIBS $gdrcopy_LIBS\"])\n#end gdrcopy configures\n\ndnl Check for ROCR runtime libraries.\nAC_ARG_WITH([rocr],\n\t    [AC_HELP_STRING([--with-rocr=DIR],\n\t\t\t    [Provide path to where the ROCR/HSA development\n\t\t\t    and runtime libraries are installed.])],\n\t    [], [])\n\nAC_ARG_ENABLE([rocr-dlopen],\n    [AS_HELP_STRING([--enable-rocr-dlopen],\n        [Enable dlopen of ROCR libraries @<:@default=no@:>@])\n    ],\n    [\n        AS_IF([test \"$freebsd\" == \"0\"], [\n            AC_CHECK_LIB(dl, dlopen, [],\n                [AC_MSG_ERROR([dlopen not found.  libfabric requires libdl.])])\n        ])\n        AC_DEFINE([ENABLE_ROCR_DLOPEN], [1], [dlopen ROCR libraries])\n    ],\n    [enable_rocr_dlopen=no])\n\nFI_CHECK_PACKAGE([rocr],\n\t\t [hsa/hsa_ext_amd.h],\n\t\t [hsa-runtime64],\n\t\t [hsa_amd_pointer_info],\n\t\t [],\n\t\t [$with_rocr],\n\t\t [$with_rocr/lib],\n\t\t [AC_DEFINE([HAVE_ROCR], [1], [ROCR HSA support])],\n\t\t [], [])\n\nCPPFLAGS=\"$CPPFLAGS $rocr_CPPFLAGS\"\nLDFLAGS=\"$LDFLAGS $rocr_LDFLAGS\"\n\nAS_IF([test x\"$enable_rocr_dlopen\" != x\"yes\"], [LIBS=\"$LIBS $rocr_LIBS\"])\n\ndnl Provider-specific checks\nFI_PROVIDER_INIT\nFI_PROVIDER_SETUP([psm])\nFI_PROVIDER_SETUP([psm2])\nFI_PROVIDER_SETUP([sockets])\nFI_PROVIDER_SETUP([verbs])\nFI_PROVIDER_SETUP([efa])\ndnl The usnic provider must be setup after the verbs provider.  See\ndnl prov/usnic/configure.m4 for details.\nFI_PROVIDER_SETUP([usnic])\nFI_PROVIDER_SETUP([gni])\nFI_PROVIDER_SETUP([udp])\nFI_PROVIDER_SETUP([tcp])\nFI_PROVIDER_SETUP([rxm])\nFI_PROVIDER_SETUP([mrail])\nFI_PROVIDER_SETUP([rxd])\nFI_PROVIDER_SETUP([bgq])\nFI_PROVIDER_SETUP([shm])\nFI_PROVIDER_SETUP([rstream])\nFI_PROVIDER_SETUP([perf])\nFI_PROVIDER_SETUP([hook_debug])\nFI_PROVIDER_FINI\ndnl Configure the .pc file\nFI_PROVIDER_SETUP_PC\n\n# If the user requested to build in direct mode, but\n# we have more than one provider, error.\nPROVIDER_DIRECT=no\nFI_DIRECT_PROVIDER_API_10=/dev/null\nAS_IF([test x\"$enable_direct\" != x\"no\"],\n      [AS_IF([test \"$PROVIDERS_COUNT\" -gt 1],\n\t     [AC_MSG_WARN([Only one provider can be chosen when using --enable-direct])\n\t      AC_MSG_ERROR(Cannot continue)])\n\n       PROVIDER_DIRECT=$enable_direct\n       AC_DEFINE_UNQUOTED([FABRIC_DIRECT_ENABLED], [1], [define when building with FABRIC_DIRECT support])\n       FI_DIRECT_PROVIDER_API_10=\"$srcdir/prov/$enable_direct/provider_FABRIC_1.0.map\"\n       AS_IF([test ! -r \"$FI_DIRECT_PROVIDER_API_10\"],\n\t     [AC_MSG_WARN([--enable-direct=$enable_direct specified, but $FI_DIRECT_PROVIDER_API_10 does not exist])\n\t      AC_MSG_ERROR([Cannot continue])])])\n\nAC_SUBST(PROVIDER_DIRECT)\nAC_SUBST_FILE(FI_DIRECT_PROVIDER_API_10)\nAM_CONDITIONAL([HAVE_DIRECT], [test x\"$enable_direct\" != x\"no\"])\n\nAC_CONFIG_FILES([Makefile libfabric.spec libfabric.map])\nAC_OUTPUT\n\ndnl helpful output\nif test \"$PROVIDERS_TO_BUILD\" = \"\"; then\n\techo \"***\"\n\techo \"*** No providers were configured. This may not be what you wanted.\"\n\techo \"***\"\n\texit 1\nfi\n\nfor i in $PROVIDERS_TO_BUILD; do\n\tv=${i}_dl\n\tif test `eval echo \\\\$${v}` == \"1\"; then\n\t\tdso=\"$i ${dso}\"\n\telse\n\t\tbuiltin=\"$i ${builtin}\"\n\tfi\ndone\ncat <<EOF\n***\n*** Built-in providers:\t${builtin}\n*** DSO providers:\t${dso}\n***\nEOF\n",
        "/tmp/vanessa/spack-stage/spack-stage-libfabric-master-7qyp67ncottp7it3zyzdyxcucafartnj/spack-src/src/hmem_cuda.c": "/*\n * (C) Copyright 2020 Hewlett Packard Enterprise Development LP\n *\n * This software is available to you under a choice of one of two\n * licenses.  You may choose to be licensed under the terms of the GNU\n * General Public License (GPL) Version 2, available from the file\n * COPYING in the main directory of this source tree, or the\n * BSD license below:\n *\n *     Redistribution and use in source and binary forms, with or\n *     without modification, are permitted provided that the following\n *     conditions are met:\n *\n *      - Redistributions of source code must retain the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer.\n *\n *      - Redistributions in binary form must reproduce the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer in the documentation and/or other materials\n *        provided with the distribution.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n#if HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#include \"ofi_hmem.h\"\n#include \"ofi.h\"\n\n#if HAVE_LIBCUDA\n\n#include <cuda.h>\n#include <cuda_runtime.h>\n\nstruct cuda_ops {\n\tcudaError_t (*cudaMemcpy)(void *dst, const void *src, size_t count,\n\t\t\t\t  enum cudaMemcpyKind kind);\n\tconst char *(*cudaGetErrorName)(cudaError_t error);\n\tconst char *(*cudaGetErrorString)(cudaError_t error);\n\tCUresult (*cuPointerGetAttribute)(void *data,\n\t\t\t\t\t  CUpointer_attribute attribute,\n\t\t\t\t\t  CUdeviceptr ptr);\n\tcudaError_t (*cudaHostRegister)(void *ptr, size_t size,\n\t\t\t\t\tunsigned int flags);\n\tcudaError_t (*cudaHostUnregister)(void *ptr);\n\tcudaError_t (*cudaGetDeviceCount)(int *count);\n};\n\nstatic int hmem_cuda_use_gdrcopy;\n\n#ifdef ENABLE_CUDA_DLOPEN\n\n#include <dlfcn.h>\n\nstatic void *cudart_handle;\nstatic void *cuda_handle;\nstatic struct cuda_ops cuda_ops;\n\n#else\n\nstatic struct cuda_ops cuda_ops = {\n\t.cudaMemcpy = cudaMemcpy,\n\t.cudaGetErrorName = cudaGetErrorName,\n\t.cudaGetErrorString = cudaGetErrorString,\n\t.cuPointerGetAttribute = cuPointerGetAttribute,\n\t.cudaHostRegister = cudaHostRegister,\n\t.cudaHostUnregister = cudaHostUnregister,\n\t.cudaGetDeviceCount = cudaGetDeviceCount,\n};\n\n#endif /* ENABLE_CUDA_DLOPEN */\n\ncudaError_t ofi_cudaMemcpy(void *dst, const void *src, size_t count,\n\t\t\t   enum cudaMemcpyKind kind)\n{\n\treturn cuda_ops.cudaMemcpy(dst, src, count, kind);\n}\n\nconst char *ofi_cudaGetErrorName(cudaError_t error)\n{\n\treturn cuda_ops.cudaGetErrorName(error);\n}\n\nconst char *ofi_cudaGetErrorString(cudaError_t error)\n{\n\treturn cuda_ops.cudaGetErrorString(error);\n}\n\nCUresult ofi_cuPointerGetAttribute(void *data, CUpointer_attribute attribute,\n\t\t\t\t   CUdeviceptr ptr)\n{\n\treturn cuda_ops.cuPointerGetAttribute(data, attribute, ptr);\n}\n\ncudaError_t ofi_cudaHostRegister(void *ptr, size_t size, unsigned int flags)\n{\n\treturn cuda_ops.cudaHostRegister(ptr, size, flags);\n}\n\ncudaError_t ofi_cudaHostUnregister(void *ptr)\n{\n\treturn cuda_ops.cudaHostUnregister(ptr);\n}\n\nstatic cudaError_t ofi_cudaGetDeviceCount(int *count)\n{\n\treturn cuda_ops.cudaGetDeviceCount(count);\n}\n\nint cuda_copy_to_dev(uint64_t device, void *dev, const void *host, size_t size)\n{\n\tif (hmem_cuda_use_gdrcopy) {\n\t\tcuda_gdrcopy_to_dev(device, dev, host, size);\n\t\treturn FI_SUCCESS;\n\t}\n\n\tcudaError_t cuda_ret;\n\n\tcuda_ret = ofi_cudaMemcpy(dev, host, size, cudaMemcpyHostToDevice);\n\tif (cuda_ret == cudaSuccess)\n\t\treturn 0;\n\n\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\"Failed to perform cudaMemcpy: %s:%s\\n\",\n\t\tofi_cudaGetErrorName(cuda_ret),\n\t\tofi_cudaGetErrorString(cuda_ret));\n\n\treturn -FI_EIO;\n}\n\nint cuda_copy_from_dev(uint64_t device, void *host, const void *dev, size_t size)\n{\n\tif (hmem_cuda_use_gdrcopy) {\n\t\tcuda_gdrcopy_from_dev(device, host, dev, size);\n\t\treturn FI_SUCCESS;\n\t}\n\n\tcudaError_t cuda_ret;\n\n\tcuda_ret = ofi_cudaMemcpy(host, dev, size, cudaMemcpyDeviceToHost);\n\tif (cuda_ret == cudaSuccess)\n\t\treturn 0;\n\n\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\"Failed to perform cudaMemcpy: %s:%s\\n\",\n\t\tofi_cudaGetErrorName(cuda_ret),\n\t\tofi_cudaGetErrorString(cuda_ret));\n\n\treturn -FI_EIO;\n}\n\nint cuda_dev_register(struct fi_mr_attr *mr_attr, uint64_t *handle)\n{\n\tif (hmem_cuda_use_gdrcopy)\n\t\treturn cuda_gdrcopy_dev_register(mr_attr, handle);\n\n\t*handle = mr_attr->device.cuda;\n\treturn FI_SUCCESS;\n}\n\nint cuda_dev_unregister(uint64_t handle)\n{\n\tif (hmem_cuda_use_gdrcopy)\n\t\treturn cuda_gdrcopy_dev_unregister(handle);\n\n\treturn FI_SUCCESS;\n}\n\nstatic int cuda_hmem_dl_init(void)\n{\n#ifdef ENABLE_CUDA_DLOPEN\n\t/* Assume failure to dlopen CUDA runtime is caused by the library not\n\t * being found. Thus, CUDA is not supported.\n\t */\n\tcudart_handle = dlopen(\"libcudart.so\", RTLD_NOW);\n\tif (!cudart_handle) {\n\t\tFI_INFO(&core_prov, FI_LOG_CORE,\n\t\t\t\"Failed to dlopen libcudart.so\\n\");\n\t\treturn -FI_ENOSYS;\n\t}\n\n\tcuda_handle = dlopen(\"libcuda.so\", RTLD_NOW);\n\tif (!cuda_handle) {\n\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\"Failed to dlopen libcuda.so\\n\");\n\t\tgoto err_dlclose_cudart;\n\t}\n\n\tcuda_ops.cudaMemcpy = dlsym(cudart_handle, \"cudaMemcpy\");\n\tif (!cuda_ops.cudaMemcpy) {\n\t\tFI_WARN(&core_prov, FI_LOG_CORE, \"Failed to find cudaMemcpy\\n\");\n\t\tgoto err_dlclose_cuda;\n\t}\n\n\tcuda_ops.cudaGetErrorName = dlsym(cudart_handle, \"cudaGetErrorName\");\n\tif (!cuda_ops.cudaGetErrorName) {\n\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\"Failed to find cudaGetErrorName\\n\");\n\t\tgoto err_dlclose_cuda;\n\t}\n\n\tcuda_ops.cudaGetErrorString = dlsym(cudart_handle,\n\t\t\t\t\t    \"cudaGetErrorString\");\n\tif (!cuda_ops.cudaGetErrorString) {\n\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\"Failed to find cudaGetErrorString\\n\");\n\t\tgoto err_dlclose_cuda;\n\t}\n\n\tcuda_ops.cuPointerGetAttribute = dlsym(cuda_handle,\n\t\t\t\t\t       \"cuPointerGetAttribute\");\n\tif (!cuda_ops.cuPointerGetAttribute) {\n\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\"Failed to find cuPointerGetAttribute\\n\");\n\t\tgoto err_dlclose_cuda;\n\t}\n\n\tcuda_ops.cudaHostRegister = dlsym(cudart_handle, \"cudaHostRegister\");\n\tif (!cuda_ops.cudaHostRegister) {\n\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\"Failed to find cudaHostRegister\\n\");\n\t\tgoto err_dlclose_cuda;\n\t}\n\n\tcuda_ops.cudaHostUnregister = dlsym(cudart_handle,\n\t\t\t\t\t    \"cudaHostUnregister\");\n\tif (!cuda_ops.cudaHostUnregister) {\n\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\"Failed to find cudaHostUnregister\\n\");\n\t\tgoto err_dlclose_cuda;\n\t}\n\n\tcuda_ops.cudaGetDeviceCount = dlsym(cudart_handle,\n\t\t\t\t\t    \"cudaGetDeviceCount\");\n\tif (!cuda_ops.cudaGetDeviceCount) {\n\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\"Failed to find cudaGetDeviceCount\\n\");\n\t\tgoto err_dlclose_cuda;\n\t}\n\n\treturn FI_SUCCESS;\n\nerr_dlclose_cuda:\n\tdlclose(cuda_handle);\nerr_dlclose_cudart:\n\tdlclose(cudart_handle);\n\n\treturn -FI_ENODATA;\n#else\n\treturn FI_SUCCESS;\n#endif /* ENABLE_CUDA_DLOPEN */\n}\n\nstatic void cuda_hmem_dl_cleanup(void)\n{\n#ifdef ENABLE_CUDA_DLOPEN\n\tdlclose(cuda_handle);\n\tdlclose(cudart_handle);\n#endif\n}\n\nstatic int cuda_hmem_verify_devices(void)\n{\n\tint device_count;\n\tcudaError_t cuda_ret;\n\n\t/* Verify CUDA compute-capable devices are present on the host. */\n\tcuda_ret = ofi_cudaGetDeviceCount(&device_count);\n\tswitch (cuda_ret) {\n\tcase cudaSuccess:\n\t\tbreak;\n\n\tcase cudaErrorNoDevice:\n\t\treturn -FI_ENOSYS;\n\n\tdefault:\n\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\"Failed to perform cudaGetDeviceCount: %s:%s\\n\",\n\t\t\tofi_cudaGetErrorName(cuda_ret),\n\t\t\tofi_cudaGetErrorString(cuda_ret));\n\t\treturn -FI_EIO;\n\t}\n\n\tif (device_count == 0)\n\t\treturn -FI_ENOSYS;\n\n\treturn FI_SUCCESS;\n}\n\nint cuda_hmem_init(void)\n{\n\tint ret;\n\n\tret = cuda_hmem_dl_init();\n\tif (ret != FI_SUCCESS)\n\t\treturn ret;\n\n\tret = cuda_hmem_verify_devices();\n\tif (ret != FI_SUCCESS)\n\t\tgoto dl_cleanup;\n\n\tret = cuda_gdrcopy_hmem_init();\n\tif (ret == FI_SUCCESS) {\n\t\thmem_cuda_use_gdrcopy = 1;\n\t\tfi_param_define(NULL, \"hmem_cuda_use_gdrcopy\", FI_PARAM_BOOL,\n\t\t\t\t\"Use gdrcopy to copy data to/from GPU memory\");\n\t\tfi_param_get_bool(NULL, \"hmem_cuda_use_gdrcopy\",\n\t\t\t\t  &hmem_cuda_use_gdrcopy);\n\t} else {\n\t\thmem_cuda_use_gdrcopy = 0;\n\t\tif (ret != -FI_ENOSYS)\n\t\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\t\"gdrcopy initialization failed! gdrcopy will not be used.\\n\");\n\t}\n\n\treturn ret;\n\ndl_cleanup:\n\tcuda_hmem_dl_cleanup();\n\n\treturn ret;\n}\n\nint cuda_hmem_cleanup(void)\n{\n\tcuda_hmem_dl_cleanup();\n\tcuda_gdrcopy_hmem_cleanup();\n\treturn FI_SUCCESS;\n}\n\nbool cuda_is_addr_valid(const void *addr)\n{\n\tCUresult cuda_ret;\n\tunsigned int data;\n\n\tcuda_ret = ofi_cuPointerGetAttribute(&data,\n\t\t\t\t\t     CU_POINTER_ATTRIBUTE_MEMORY_TYPE,\n\t\t\t\t\t     (CUdeviceptr)addr);\n\tswitch (cuda_ret) {\n\tcase CUDA_SUCCESS:\n\t\tif (data == CU_MEMORYTYPE_DEVICE)\n\t\t\treturn true;\n\t\tbreak;\n\n\t/* Returned if the buffer is not associated with the CUcontext support\n\t * unified virtual addressing. Since host buffers may fall into this\n\t * category, this is not treated as an error.\n\t */\n\tcase CUDA_ERROR_INVALID_VALUE:\n\t\tbreak;\n\n\t/* Returned if cuInit() has not been called. This can happen if support\n\t * for CUDA is enabled but the user has not made a CUDA call. This is\n\t * not treated as an error.\n\t */\n\tcase CUDA_ERROR_NOT_INITIALIZED:\n\t\tbreak;\n\n\t/* Returned if the CUcontext does not support unified virtual\n\t * addressing.\n\t */\n\tcase CUDA_ERROR_INVALID_CONTEXT:\n\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\"CUcontext does not support unified virtual addressining\\n\");\n\t\tbreak;\n\n\tdefault:\n\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\"Unhandle cuPointerGetAttribute return code: ret=%d\\n\",\n\t\t\tcuda_ret);\n\t\tbreak;\n\t}\n\n\treturn false;\n}\n\nint cuda_host_register(void *ptr, size_t size)\n{\n\tcudaError_t cuda_ret;\n\n\tcuda_ret = ofi_cudaHostRegister(ptr, size, cudaHostRegisterDefault);\n\tif (cuda_ret == cudaSuccess)\n\t\treturn FI_SUCCESS;\n\n\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\"Failed to perform cudaMemcpy: %s:%s\\n\",\n\t\tofi_cudaGetErrorName(cuda_ret),\n\t\tofi_cudaGetErrorString(cuda_ret));\n\n\treturn -FI_EIO;\n}\n\nint cuda_host_unregister(void *ptr)\n{\n\tcudaError_t cuda_ret;\n\n\tcuda_ret = ofi_cudaHostUnregister(ptr);\n\tif (cuda_ret == cudaSuccess)\n\t\treturn FI_SUCCESS;\n\n\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\"Failed to perform cudaMemcpy: %s:%s\\n\",\n\t\tofi_cudaGetErrorName(cuda_ret),\n\t\tofi_cudaGetErrorString(cuda_ret));\n\n\treturn -FI_EIO;\n}\n\n#else\n\nint cuda_copy_to_dev(uint64_t device, void *dev, const void *host, size_t size)\n{\n\treturn -FI_ENOSYS;\n}\n\nint cuda_copy_from_dev(uint64_t device, void *host, const void *dev, size_t size)\n{\n\treturn -FI_ENOSYS;\n}\n\nint cuda_hmem_init(void)\n{\n\treturn -FI_ENOSYS;\n}\n\nint cuda_hmem_cleanup(void)\n{\n\treturn -FI_ENOSYS;\n}\n\nbool cuda_is_addr_valid(const void *addr)\n{\n\treturn false;\n}\n\nint cuda_host_register(void *ptr, size_t size)\n{\n\treturn -FI_ENOSYS;\n}\n\nint cuda_host_unregister(void *ptr)\n{\n\treturn -FI_ENOSYS;\n}\n\nint cuda_dev_register(struct fi_mr_attr *mr_attr, uint64_t *handle)\n{\n\treturn FI_SUCCESS;\n}\n\nint cuda_dev_unregister(uint64_t handle)\n{\n\treturn FI_SUCCESS;\n}\n\n#endif /* HAVE_LIBCUDA */\n",
        "/tmp/vanessa/spack-stage/spack-stage-libfabric-master-7qyp67ncottp7it3zyzdyxcucafartnj/spack-src/src/hmem_cuda_gdrcopy.c": "/*\n * Copyright (c) 2020 Amazon.com, Inc. or its affiliates.\n * All rights reserved.\n *\n * This software is available to you under a choice of one of two\n * licenses.  You may choose to be licensed under the terms of the GNU\n * General Public License (GPL) Version 2, available from the file\n * COPYING in the main directory of this source tree, or the\n * BSD license below:\n *\n *     Redistribution and use in source and binary forms, with or\n *     without modification, are permitted provided that the following\n *     conditions are met:\n *\n *      - Redistributions of source code must retain the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer.\n *\n *      - Redistributions in binary form must reproduce the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer in the documentation and/or other materials\n *        provided with the distribution.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n#if HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#include \"ofi_hmem.h\"\n#include \"ofi.h\"\n\n#ifdef HAVE_GDRCOPY\n\n#include <pthread.h>\n#include <gdrapi.h>\n\nstruct gdrcopy_handle {\n\tgdr_mh_t mh; /* memory handler */\n\tvoid *cuda_ptr; /* page aligned gpu pointer */\n\tvoid *user_ptr; /* user space ptr mapped to GPU memory */\n\tsize_t length; /* page aligned length */\n};\n\nstruct gdrcopy_ops {\n\tgdr_t (*gdr_open)();\n\tint (*gdr_close)(gdr_t g);\n\tint (*gdr_pin_buffer)(gdr_t g, unsigned long addr, size_t size,\n\t\t\t      uint64_t p2p_token, uint32_t va_space,\n\t\t\t      gdr_mh_t *handle);\n\tint (*gdr_unpin_buffer)(gdr_t g, gdr_mh_t handle);\n\tint (*gdr_map)(gdr_t g, gdr_mh_t handle, void **va, size_t size);\n\tint (*gdr_unmap)(gdr_t g, gdr_mh_t handle, void *va, size_t size);\n\tint (*gdr_copy_to_mapping)(gdr_mh_t handle, void *map_d_ptr,\n\t\t\t\t   const void *h_ptr, size_t size);\n\tint (*gdr_copy_from_mapping)(gdr_mh_t handle, void *map_d_ptr,\n\t\t\t\t     const void *h_ptr, size_t size);\n};\n\nenum gdrcopy_dir {\n\tGDRCOPY_TO_DEVICE,\n\tGDRCOPY_FROM_DEVICE,\n};\n\nstatic gdr_t global_gdr;\nstatic pthread_spinlock_t global_gdr_lock;\n\n#ifdef ENABLE_GDRCOPY_DLOPEN\n\n#include <dlfcn.h>\n\nstatic void *gdrapi_handle;\nstatic struct gdrcopy_ops global_gdrcopy_ops;\n\nstatic int cuda_gdrcopy_dl_hmem_init(void)\n{\n\tgdrapi_handle = dlopen(\"libgdrapi.so\", RTLD_NOW);\n\tif (!gdrapi_handle) {\n\t\tFI_INFO(&core_prov, FI_LOG_CORE,\n\t\t\t\"Failed to dlopen libgdrapi.so\\n\");\n\t\treturn -FI_ENOSYS;\n\t}\n\n\tglobal_gdrcopy_ops.gdr_open = dlsym(gdrapi_handle, \"gdr_open\");\n\tif (!global_gdrcopy_ops.gdr_open) {\n\t\tFI_WARN(&core_prov, FI_LOG_CORE, \"Failed to find gdr_open\\n\");\n\t\tgoto err_dlclose_gdrapi;\n\t}\n\n\tglobal_gdrcopy_ops.gdr_close = dlsym(gdrapi_handle, \"gdr_close\");\n\tif (!global_gdrcopy_ops.gdr_close) {\n\t\tFI_WARN(&core_prov, FI_LOG_CORE, \"Failed to find gdr_close\\n\");\n\t\tgoto err_dlclose_gdrapi;\n\t}\n\n\tglobal_gdrcopy_ops.gdr_pin_buffer = dlsym(gdrapi_handle, \"gdr_pin_buffer\");\n\tif (!global_gdrcopy_ops.gdr_pin_buffer) {\n\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\"Failed to find gdr_pin_buffer\\n\");\n\t\tgoto err_dlclose_gdrapi;\n\t}\n\n\tglobal_gdrcopy_ops.gdr_unpin_buffer = dlsym(gdrapi_handle, \"gdr_unpin_buffer\");\n\tif (!global_gdrcopy_ops.gdr_unpin_buffer) {\n\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\"Failed to find gdr_unpin_buffer\\n\");\n\t\tgoto err_dlclose_gdrapi;\n\t}\n\n\tglobal_gdrcopy_ops.gdr_map = dlsym(gdrapi_handle, \"gdr_map\");\n\tif (!global_gdrcopy_ops.gdr_map) {\n\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\"Failed to find gdr_map\\n\");\n\t\tgoto err_dlclose_gdrapi;\n\t}\n\n\tglobal_gdrcopy_ops.gdr_unmap = dlsym(gdrapi_handle, \"gdr_unmap\");\n\tif (!global_gdrcopy_ops.gdr_unmap) {\n\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\"Failed to find gdr_unmap\\n\");\n\t\tgoto err_dlclose_gdrapi;\n\t}\n\n\tglobal_gdrcopy_ops.gdr_copy_to_mapping = dlsym(gdrapi_handle, \"gdr_copy_to_mapping\");\n\tif (!global_gdrcopy_ops.gdr_copy_to_mapping) {\n\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\"Failed to find gdr_copy_to_mapping\\n\");\n\t\tgoto err_dlclose_gdrapi;\n\t}\n\n\tglobal_gdrcopy_ops.gdr_copy_from_mapping = dlsym(gdrapi_handle, \"gdr_copy_from_mapping\");\n\tif (!global_gdrcopy_ops.gdr_copy_from_mapping) {\n\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\"Failed to find gdr_copy_from_mapping\\n\");\n\t\tgoto err_dlclose_gdrapi;\n\t}\n\n\treturn FI_SUCCESS;\n\nerr_dlclose_gdrapi:\n\tmemset(&global_gdrcopy_ops, 0, sizeof(global_gdrcopy_ops));\n\tdlclose(gdrapi_handle);\n\treturn -FI_ENODATA;\n}\n\nstatic int cuda_gdrcopy_dl_hmem_cleanup(void)\n{\n\tdlclose(gdrapi_handle);\n\treturn FI_SUCCESS;\n}\n\n#else\n\nstatic struct gdrcopy_ops global_gdrcopy_ops = {\n\t.gdr_open = gdr_open,\n\t.gdr_close = gdr_close,\n\t.gdr_pin_buffer = gdr_pin_buffer,\n\t.gdr_unpin_buffer = gdr_unpin_buffer,\n\t.gdr_map = gdr_map,\n\t.gdr_unmap = gdr_unmap,\n\t.gdr_copy_to_mapping = gdr_copy_to_mapping,\n\t.gdr_copy_from_mapping = gdr_copy_from_mapping\n};\n\nstatic int cuda_gdrcopy_dl_hmem_init(void)\n{\n\treturn FI_SUCCESS;\n}\n\nstatic int cuda_gdrcopy_dl_hmem_cleanup(void)\n{\n\treturn FI_SUCCESS;\n}\n\n#endif /* ENABLE_CUDA_DLOPEN */\n\nint cuda_gdrcopy_hmem_init(void)\n{\n\tint err, ret = 0;\n\n\terr = cuda_gdrcopy_dl_hmem_init();\n\tif (err) {\n\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\"gdrcopy_dl_hmem_init failed!\\n\");\n\t\treturn -FI_ENOSYS;\n\t}\n\n\tassert(global_gdrcopy_ops.gdr_open);\n\n\tglobal_gdr = global_gdrcopy_ops.gdr_open();\n\tif (!global_gdr) {\n\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\"gdr_open failed!\\n\");\n\t\tret = -FI_ENOMEM;\n\t\tgoto exit;\n\t}\n\n\terr = pthread_spin_init(&global_gdr_lock, 0);\n\tif (err) {\n\t\tassert(global_gdrcopy_ops.gdr_close);\n\t\tglobal_gdrcopy_ops.gdr_close(global_gdr);\n\t\tret = -err;\n\t}\n\nexit:\n\tcuda_gdrcopy_dl_hmem_cleanup();\n\treturn ret;\n}\n\nint cuda_gdrcopy_hmem_cleanup(void)\n{\n\tint err, ret = 0;\n\n\terr = pthread_spin_destroy(&global_gdr_lock);\n\tif (err) {\n\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\"destroy global_gdr_lock failed! err: %s\\n\",\n\t\t\tstrerror(err));\n\t\tret = err;\n\t}\n\n\tassert(global_gdrcopy_ops.gdr_close);\n\terr = global_gdrcopy_ops.gdr_close(global_gdr);\n\tif (err) {\n\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\"close global_gdr failed! err: %s\\n\",\n\t\t\tstrerror(err));\n\t\tret = err;\n\t}\n\n\terr = cuda_gdrcopy_dl_hmem_cleanup();\n\tif (err) {\n\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\"cuda_gdrcopy_dl_hmem_cleaup() failed! err: %s\\n\",\n\t\t\tstrerror(err));\n\t\tret = err;\n\t}\n\n\treturn ret;\n}\n\nvoid cuda_gdrcopy_impl(uint64_t handle, void *devptr,\n\t\t       void *hostptr, size_t len,\n\t\t       enum gdrcopy_dir dir)\n{\n\tssize_t off;\n\tstruct gdrcopy_handle *gdrcopy;\n\tvoid *gdrcopy_user_ptr;\n\n\tassert(global_gdrcopy_ops.gdr_copy_to_mapping);\n\tassert(handle);\n\n\tgdrcopy = (struct gdrcopy_handle *)handle;\n\toff = (char *)devptr - (char *)gdrcopy->cuda_ptr;\n\tassert(off >= 0 && off + len <= gdrcopy->length);\n\tgdrcopy_user_ptr = (char *)gdrcopy->user_ptr + off;\n\tif (dir == GDRCOPY_TO_DEVICE) {\n\t\tglobal_gdrcopy_ops.gdr_copy_to_mapping(gdrcopy->mh,\n\t\t\t\t\t\t       gdrcopy_user_ptr,\n\t\t\t\t\t\t       hostptr, len);\n\t} else {\n\t\tassert(dir == GDRCOPY_FROM_DEVICE);\n\t\tglobal_gdrcopy_ops.gdr_copy_from_mapping(gdrcopy->mh,\n\t\t\t\t\t\t\t gdrcopy_user_ptr,\n\t\t\t\t\t\t\t hostptr, len);\n\t}\n}\n\nvoid cuda_gdrcopy_to_dev(uint64_t handle, void *devptr,\n\t\t\t const void *hostptr, size_t len)\n{\n\tcuda_gdrcopy_impl(handle, devptr, (void *)hostptr, len,\n\t\t\t  GDRCOPY_TO_DEVICE);\n}\n\nvoid cuda_gdrcopy_from_dev(uint64_t handle, void *hostptr,\n\t\t\t   const void *devptr, size_t len)\n{\n\tcuda_gdrcopy_impl(handle, (void *)devptr, hostptr, len,\n\t\t\t  GDRCOPY_FROM_DEVICE);\n}\n\nint cuda_gdrcopy_dev_register(struct fi_mr_attr *mr_attr, uint64_t *handle)\n{\n\tint err;\n\tuintptr_t regbgn, regend;\n\tsize_t reglen;\n\tstruct gdrcopy_handle *gdrcopy;\n\n\tassert(global_gdr);\n\tassert(global_gdrcopy_ops.gdr_pin_buffer);\n\tassert(global_gdrcopy_ops.gdr_map);\n\n\tregbgn = (uintptr_t)mr_attr->mr_iov->iov_base;\n\tregend = (uintptr_t)mr_attr->mr_iov->iov_base + mr_attr->mr_iov->iov_len;\n\tregbgn = regbgn & GPU_PAGE_MASK;\n\tregend = (regend & GPU_PAGE_MASK) + GPU_PAGE_SIZE;\n\treglen = regend - regbgn;\n\n\tgdrcopy = malloc(sizeof(struct gdrcopy_handle));\n\tif (!gdrcopy)\n\t\treturn -FI_ENOMEM;\n\n\tassert(global_gdr);\n\tpthread_spin_lock(&global_gdr_lock);\n\terr = global_gdrcopy_ops.gdr_pin_buffer(global_gdr, regbgn,\n\t\t\t\t\t reglen, 0, 0, &gdrcopy->mh);\n\tif (err) {\n\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\"gdr_pin_buffer failed! error: %s\",\n\t\t\tstrerror(err));\n\t\tfree(gdrcopy);\n\t\tgoto exit;\n\t}\n\n\tgdrcopy->cuda_ptr = (void *)regbgn;\n\tgdrcopy->length = reglen;\n\n\terr = global_gdrcopy_ops.gdr_map(global_gdr, gdrcopy->mh,\n\t\t\t\t\t &gdrcopy->user_ptr, gdrcopy->length);\n\tif (err) {\n\t\tFI_WARN(&core_prov, FI_LOG_CORE, \"gdr_map failed! error: %s\\n\",\n\t\t\tstrerror(err));\n\t\tglobal_gdrcopy_ops.gdr_unpin_buffer(global_gdr, gdrcopy->mh);\n\t\tfree(gdrcopy);\n\t\tgoto exit;\n\t}\n\n\t*handle = (uint64_t)gdrcopy;\nexit:\n\tpthread_spin_unlock(&global_gdr_lock);\n\treturn err;\n}\n\nint cuda_gdrcopy_dev_unregister(uint64_t handle)\n{\n\tint err;\n\tstruct gdrcopy_handle *gdrcopy;\n\n\tassert(global_gdr);\n\tassert(global_gdrcopy_ops.gdr_unmap);\n\tassert(global_gdrcopy_ops.gdr_unpin_buffer);\n\n\tgdrcopy = (struct gdrcopy_handle *)handle;\n\tassert(gdrcopy);\n\n\tpthread_spin_lock(&global_gdr_lock);\n\terr = global_gdrcopy_ops.gdr_unmap(global_gdr, gdrcopy->mh,\n\t\t\t\t\t   gdrcopy->user_ptr, gdrcopy->length);\n\tif (err) {\n\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\"gdr_unmap failed! error: %s\\n\",\n\t\t\tstrerror(err));\n\t\tgoto exit;\n\t}\n\n\terr = global_gdrcopy_ops.gdr_unpin_buffer(global_gdr, gdrcopy->mh);\n\tif (err) {\n\t\tFI_WARN(&core_prov, FI_LOG_MR,\n\t\t\t\"gdr_unmap failed! error: %s\\n\",\n\t\t\tstrerror(err));\n\t\tgoto exit;\n\t}\n\nexit:\n\tpthread_spin_unlock(&global_gdr_lock);\n\tfree(gdrcopy);\n\treturn err;\n}\n\n#else\n\nint cuda_gdrcopy_hmem_init(void)\n{\n\treturn -FI_ENOSYS;\n}\n\nint cuda_gdrcopy_hmem_cleanup(void)\n{\n\treturn FI_SUCCESS;\n}\n\nvoid cuda_gdrcopy_to_dev(uint64_t devhandle, void *devptr,\n\t\t\t const void *hostptr, size_t len)\n{\n}\n\nvoid cuda_gdrcopy_from_dev(uint64_t devhandle, void *hostptr,\n\t\t\t   const void *devptr, size_t len)\n{\n}\n\nint cuda_gdrcopy_dev_register(struct fi_mr_attr *mr_attr, uint64_t *handle)\n{\n\treturn FI_SUCCESS;\n}\n\nint cuda_gdrcopy_dev_unregister(uint64_t handle)\n{\n\treturn FI_SUCCESS;\n}\n\n#endif /* HAVE_GDRCOPY */\n",
        "/tmp/vanessa/spack-stage/spack-stage-libfabric-master-7qyp67ncottp7it3zyzdyxcucafartnj/spack-src/src/fabric.c": "/*\n * Copyright (c) 2004, 2005 Topspin Communications.  All rights reserved.\n * Copyright (c) 2006-2016 Cisco Systems, Inc.  All rights reserved.\n * Copyright (c) 2013-2017 Intel Corp., Inc.  All rights reserved.\n * (C) Copyright 2020 Hewlett Packard Enterprise Development LP\n *\n * This software is available to you under a choice of one of two\n * licenses.  You may choose to be licensed under the terms of the GNU\n * General Public License (GPL) Version 2, available from the file\n * COPYING in the main directory of this source tree, or the\n * BSD license below:\n *\n *     Redistribution and use in source and binary forms, with or\n *     without modification, are permitted provided that the following\n *     conditions are met:\n *\n *      - Redistributions of source code must retain the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer.\n *\n *      - Redistributions in binary form must reproduce the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer in the documentation and/or other materials\n *        provided with the distribution.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n#include \"config.h\"\n\n#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <dirent.h>\n#include <ctype.h>\n\n#include <rdma/fi_errno.h>\n#include \"ofi_util.h\"\n#include \"ofi.h\"\n#include \"shared/ofi_str.h\"\n#include \"ofi_prov.h\"\n#include \"ofi_perf.h\"\n#include \"ofi_hmem.h\"\n\n#ifdef HAVE_LIBDL\n#include <dlfcn.h>\n#endif\n\nstruct ofi_prov {\n\tstruct ofi_prov\t\t*next;\n\tchar\t\t\t*prov_name;\n\tstruct fi_provider\t*provider;\n\tvoid\t\t\t*dlhandle;\n\tbool\t\t\thidden;\n};\n\nstatic struct ofi_prov *prov_head, *prov_tail;\nint ofi_init = 0;\nextern struct ofi_common_locks common_locks;\n\nstatic struct fi_filter prov_filter;\n\nstatic int ofi_find_name(char **names, const char *name)\n{\n\tint i;\n\n\tfor (i = 0; names[i]; i++) {\n\t\tif (!strcasecmp(name, names[i]))\n\t\t\treturn i;\n\t}\n\treturn -1;\n}\n\n/* matches if names[i] == \"xxx;yyy\" and name == \"xxx\" */\nstatic int ofi_find_layered_name(char **names, const char *name)\n{\n\tint i, len;\n\n\tlen = strlen(name);\n\tfor (i = 0; names[i]; i++) {\n\t\tif (!strncasecmp(name, names[i], len) && names[i][len] == ';' )\n\t\t\treturn i;\n\t}\n\treturn -1;\n}\n\n/* matches if names[i] == \"xxx\" and name == \"xxx;yyy\" */\nstatic int ofi_find_core_name(char **names, const char *name)\n{\n\tint i, len;\n\n\tfor (i = 0; names[i]; i++) {\n\t\tlen = strlen(names[i]);\n\t\tif (!strncasecmp(name, names[i], len) && name[len] == ';' )\n\t\t\treturn i;\n\t}\n\treturn -1;\n}\n\nstatic void ofi_closest_prov_names(char *prov_name, char* miss_prov_name, int n)\n{\n\tif (strncasecmp( prov_name, miss_prov_name, n ) == 0 ) {\n\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\"Instead misspelled provider: %s, you may want: %s?\\n\",\n\t\t\tmiss_prov_name, prov_name);\n\t}\n}\n\nstatic void ofi_suggest_prov_names(char *name_to_match)\n{\n\tstruct ofi_prov *prov;\n\tfor (prov = prov_head; prov; prov = prov->next) {\n\t\tif (strlen(prov->prov_name) != strlen(name_to_match)\n\t\t    && !strncasecmp(prov->prov_name, name_to_match,\n\t\t\t\t    strlen(name_to_match))) {\n\t\t\tif (strlen(name_to_match) > 5)\n\t\t\t\tofi_closest_prov_names(prov->prov_name,\n\t\t\t\t\t\t       name_to_match, 5);\n\t\t\telse\n\t\t\t\tofi_closest_prov_names(prov->prov_name,\n\t\t\t\t\t\t       name_to_match, 2);\n\t\t}\n\t}\n}\n\nstatic enum ofi_prov_type ofi_prov_type(const struct fi_provider *provider)\n{\n\tconst struct fi_prov_context *ctx;\n\tctx = (const struct fi_prov_context *) &provider->context;\n\treturn ctx->type;\n}\n\nstatic int ofi_disable_util_layering(const struct fi_provider *provider) {\n\tconst struct fi_prov_context *ctx;\n\n\tctx = (const struct fi_prov_context *) &provider->context;\n\treturn ctx->disable_layering;\n}\n\nstatic int ofi_is_util_prov(const struct fi_provider *provider)\n{\n\treturn ofi_prov_type(provider) == OFI_PROV_UTIL;\n}\n\nstatic int ofi_is_core_prov(const struct fi_provider *provider)\n{\n\treturn ofi_prov_type(provider) == OFI_PROV_CORE;\n}\n\nstatic int ofi_is_hook_prov(const struct fi_provider *provider)\n{\n\treturn ofi_prov_type(provider) == OFI_PROV_HOOK;\n}\n\nint ofi_apply_filter(struct fi_filter *filter, const char *name)\n{\n\tif (!filter->names)\n\t\treturn 0;\n\n\tif (ofi_find_name(filter->names, name) >= 0)\n\t\treturn filter->negated ? 1 : 0;\n\n\treturn filter->negated ? 0 : 1;\n}\n\n/*\n * The provider init filter is used to filter out unnecessary core providers\n * at the initialization time. Utility providers are not concerned.\n *\n * Special handling is needed for layered provider names:\n *\n * If the filter is not negated, a name \"xxx;yyy\" in the filter should match\n * input \"xxx\" to ensure that the core provider \"xxx\" is included.\n *\n * If the filter is negated, a name \"xxx;yyy\" in the filter should not match\n * input \"xxx\" otherwise the core provider \"xxx\" may be incorrectly filtered\n * out.\n */\nint ofi_apply_prov_init_filter(struct fi_filter *filter, const char *name)\n{\n\tif (!filter->names)\n\t\treturn 0;\n\n\tif (ofi_find_name(filter->names, name) >= 0)\n\t\treturn filter->negated ? 1 : 0;\n\n\tif (filter->negated)\n\t\treturn 0;\n\n\tif (ofi_find_layered_name(filter->names, name) >= 0)\n\t\treturn 0;\n\n\treturn 1;\n}\n\n/*\n * The provider post filter is used to remove unwanted entries from the fi_info\n * list before returning from fi_getinfo().\n *\n * Layered provider names are handled in the same way as non-layered provider\n * names -- requiring full match.\n *\n * In addition, a name \"xxx\" in the filter should be able to match an input\n * \"xxx;yyy\" to allow extra layering on top of what is requested by the user.\n */\nint ofi_apply_prov_post_filter(struct fi_filter *filter, const char *name)\n{\n\tif (!filter->names)\n\t\treturn 0;\n\n\tif (ofi_find_name(filter->names, name) >= 0 ||\n\t    ofi_find_core_name(filter->names, name) >= 0)\n\t\treturn filter->negated ? 1 : 0;\n\n\treturn filter->negated ? 0 : 1;\n}\n\nstatic int ofi_getinfo_filter(const struct fi_provider *provider)\n{\n\t/* Positive filters only apply to core providers.  They must be\n\t * explicitly enabled by the filter.  Other providers (i.e. utility)\n\t * are automatically enabled in this case, so that they can work\n\t * over any enabled core filter.  Negative filters may be used\n\t * to disable any provider.\n\t */\n\tif (!prov_filter.negated && !ofi_is_core_prov(provider))\n\t\treturn 0;\n\n\treturn ofi_apply_prov_init_filter(&prov_filter, provider->name);\n}\n\nstatic void ofi_filter_info(struct fi_info **info)\n{\n\tstruct fi_info *cur, *prev, *tmp;\n\n\tif (!prov_filter.names)\n\t\treturn;\n\n\tprev = NULL;\n\tcur = *info;\n\twhile (cur) {\n\t\tassert(cur->fabric_attr && cur->fabric_attr->prov_name);\n\n\t\tif (ofi_apply_prov_post_filter(&prov_filter, cur->fabric_attr->prov_name)) {\n\t\t\ttmp = cur;\n\t\t\tcur = cur->next;\n\t\t\tif (prev)\n\t\t\t\tprev->next = cur;\n\t\t\telse\n\t\t\t\t*info = cur;\n\t\t\ttmp->next = NULL;\n\t\t\tfi_freeinfo(tmp);\n\t\t} else {\n\t\t\tprev = cur;\n\t\t\tcur = cur->next;\n\t\t}\n\t}\n}\n\nstatic struct ofi_prov *ofi_getprov(const char *prov_name, size_t len)\n{\n\tstruct ofi_prov *prov;\n\n\tfor (prov = prov_head; prov; prov = prov->next) {\n\t\tif ((strlen(prov->prov_name) == len) &&\n\t\t    !strncasecmp(prov->prov_name, prov_name, len))\n\t\t\treturn prov;\n\t}\n\n\treturn NULL;\n}\n\nstruct fi_provider *ofi_get_hook(const char *name)\n{\n\tstruct ofi_prov *prov;\n\tstruct fi_provider *provider = NULL;\n\tchar *try_name = NULL;\n\tint ret;\n\n\tprov = ofi_getprov(name, strlen(name));\n\tif (!prov) {\n\t\tret = asprintf(&try_name, \"ofi_hook_%s\", name);\n\t\tif (ret > 0)\n\t\t\tprov = ofi_getprov(try_name, ret);\n\t\telse\n\t\t\ttry_name = NULL;\n\t}\n\n\tif (prov) {\n\t\tif (prov->provider && ofi_is_hook_prov(prov->provider)) {\n\t\t\tprovider = prov->provider;\n\t\t} else {\n\t\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\t\"Specified provider is not a hook: %s\\n\", name);\n\t\t}\n\t} else {\n\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\"No hook found for: %s\\n\", name);\n\t}\n\n\tfree(try_name);\n\treturn provider;\n}\n\nstatic void cleanup_provider(struct fi_provider *provider, void *dlhandle)\n{\n\tOFI_UNUSED(dlhandle);\n\n\tif (provider) {\n\t\tfi_param_undefine(provider);\n\n\t\tif (provider->cleanup)\n\t\t\tprovider->cleanup();\n\t}\n\n#ifdef HAVE_LIBDL\n\tif (dlhandle)\n\t\tdlclose(dlhandle);\n#endif\n}\n\nstatic struct ofi_prov *ofi_create_prov_entry(const char *prov_name)\n{\n\tstruct ofi_prov *prov = NULL;\n\tprov = calloc(sizeof *prov, 1);\n\tif (!prov) {\n\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\"Not enough memory to allocate provider registry\\n\");\n\t\treturn NULL;\n\t}\n\n\tprov->prov_name = strdup(prov_name);\n\tif (!prov->prov_name) {\n\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\"Failed to init pre-registered provider name\\n\");\n\t\tfree(prov);\n\t\treturn NULL;\n\t}\n\tif (prov_tail)\n\t\tprov_tail->next = prov;\n\telse\n\t\tprov_head = prov;\n\tprov_tail = prov;\n\n\tprov->hidden = false;\n\n\treturn prov;\n}\n\n/* This is the default order that providers will be reported when a provider\n * is available.  Initialize the socket(s) provider last.  This will result in\n * it being the least preferred provider.\n */\nstatic void ofi_ordered_provs_init(void)\n{\n\tchar *ordered_prov_names[] = {\n\t\t\"psm2\", \"psm\", \"efa\", \"usnic\", \"gni\", \"bgq\", \"verbs\",\n\t\t\"netdir\", \"ofi_rxm\", \"ofi_rxd\", \"shm\",\n\t\t/* Initialize the socket based providers last of the\n\t\t * standard providers.  This will result in them being\n\t\t * the least preferred providers.\n\t\t */\n\n\t\t/* Before you add ANYTHING here, read the comment above!!! */\n\t\t\"udp\", \"tcp\", \"sockets\", /* NOTHING GOES HERE! */\n\t\t/* Seriously, read it! */\n\n\t\t/* These are hooking providers only.  Their order\n\t\t * doesn't matter\n\t\t */\n\t\t\"ofi_hook_perf\", \"ofi_hook_debug\", \"ofi_hook_noop\",\n\t};\n\tint num_provs = sizeof(ordered_prov_names)/sizeof(ordered_prov_names[0]), i;\n\n\tfor (i = 0; i < num_provs; i++)\n\t\tofi_create_prov_entry(ordered_prov_names[i]);\n}\n\nstatic void ofi_set_prov_type(struct fi_prov_context *ctx,\n\t\t\t      struct fi_provider *provider)\n{\n\tif (!provider->getinfo)\n\t\tctx->type = OFI_PROV_HOOK;\n\telse if (ofi_has_util_prefix(provider->name))\n\t\tctx->type = OFI_PROV_UTIL;\n\telse\n\t\tctx->type = OFI_PROV_CORE;\n}\n\nstatic void ofi_register_provider(struct fi_provider *provider, void *dlhandle)\n{\n\tstruct fi_prov_context *ctx;\n\tstruct ofi_prov *prov = NULL;\n\tbool hidden = false;\n\n\tif (!provider || !provider->name) {\n\t\tFI_DBG(&core_prov, FI_LOG_CORE,\n\t\t       \"no provider structure or name\\n\");\n\t\tgoto cleanup;\n\t}\n\n\tFI_INFO(&core_prov, FI_LOG_CORE,\n\t       \"registering provider: %s (%d.%d)\\n\", provider->name,\n\t       FI_MAJOR(provider->version), FI_MINOR(provider->version));\n\n\tif (!provider->fabric) {\n\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\"provider missing mandatory entry points\\n\");\n\t\tgoto cleanup;\n\t}\n\n\t/* The current core implementation is not backward compatible\n\t * with providers that support a release earlier than v1.3.\n\t * See commit 0f4b6651.\n\t */\n\tif (provider->fi_version < FI_VERSION(1, 3)) {\n\t\tFI_INFO(&core_prov, FI_LOG_CORE,\n\t\t\t\"provider has unsupported FI version \"\n\t\t\t\"(provider %d.%d != libfabric %d.%d); ignoring\\n\",\n\t\t\tFI_MAJOR(provider->fi_version),\n\t\t\tFI_MINOR(provider->fi_version), FI_MAJOR_VERSION,\n\t\t\tFI_MINOR_VERSION);\n\t\tgoto cleanup;\n\t}\n\n\tctx = (struct fi_prov_context *) &provider->context;\n\tofi_set_prov_type(ctx, provider);\n\n\tif (ofi_getinfo_filter(provider)) {\n\t\tFI_INFO(&core_prov, FI_LOG_CORE,\n\t\t\t\"\\\"%s\\\" filtered by provider include/exclude \"\n\t\t\t\"list, skipping\\n\", provider->name);\n\t\thidden = true;\n\t}\n\n\tif (ofi_apply_filter(&prov_log_filter, provider->name))\n\t\tctx->disable_logging = 1;\n\n\t/*\n\t * Prevent utility providers from layering on these core providers\n\t * unless explicitly requested.\n\t */\n\tif (!strcasecmp(provider->name, \"sockets\") ||\n\t    !strcasecmp(provider->name, \"shm\") ||\n\t    !strcasecmp(provider->name, \"efa\") || ofi_is_util_prov(provider))\n\t\tctx->disable_layering = 1;\n\n\tprov = ofi_getprov(provider->name, strlen(provider->name));\n\tif (prov) {\n\t\t/* If this provider has not been init yet, then we add the\n\t\t * provider and dlhandle to the struct and exit.\n\t\t */\n\t\tif (prov->provider == NULL)\n\t\t\tgoto update_prov_registry;\n\n\t\t/* If this provider is older than an already-loaded\n\t\t * provider of the same name, then discard this one.\n\t\t */\n\t\tif (FI_VERSION_GE(prov->provider->version, provider->version)) {\n\t\t\tFI_INFO(&core_prov, FI_LOG_CORE,\n\t\t\t\t\"a newer %s provider was already loaded; \"\n\t\t\t\t\"ignoring this one\\n\", provider->name);\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* This provider is newer than an already-loaded\n\t\t * provider of the same name, so discard the\n\t\t * already-loaded one.\n\t\t */\n\t\tFI_INFO(&core_prov, FI_LOG_CORE,\n\t\t\t\"an older %s provider was already loaded; \"\n\t\t\t\"keeping this one and ignoring the older one\\n\",\n\t\t\tprovider->name);\n\t\tcleanup_provider(prov->provider, prov->dlhandle);\n\t} else {\n\t\tprov = ofi_create_prov_entry(provider->name);\n\t\tif (!prov)\n\t\t\tgoto cleanup;\n\t}\n\n\tif (hidden)\n\t\tprov->hidden = true;\n\nupdate_prov_registry:\n\tprov->dlhandle = dlhandle;\n\tprov->provider = provider;\n\treturn;\n\ncleanup:\n\tcleanup_provider(provider, dlhandle);\n}\n\n#ifdef HAVE_LIBDL\nstatic int lib_filter(const struct dirent *entry)\n{\n\tsize_t l = strlen(entry->d_name);\n\tsize_t sfx = sizeof (FI_LIB_SUFFIX) - 1;\n\n\tif (l > sfx)\n\t\treturn !strcmp(&(entry->d_name[l-sfx]), FI_LIB_SUFFIX);\n\telse\n\t\treturn 0;\n}\n#endif\n\nstatic int verify_filter_names(char **names)\n{\n\tint i, j;\n\tchar** split_names;\n\tfor (i = 0; names[i]; i++) {\n\t\tsplit_names = ofi_split_and_alloc(names[i], \";\", NULL);\n\t\tif (!split_names) {\n\t\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\t\"unable to parse given filter string\\n\");\n\t\t\treturn -FI_ENODATA;\n\t\t}\n\n\t\tfor(j = 0; split_names[j]; j++) {\n\t\t\tif(!ofi_getprov(split_names[j], strlen(split_names[j]))) {\n\t\t\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\t\t\"provider %s is unknown, misspelled\"\n\t\t\t\t\t\" or DL provider?\\n\", split_names[j]);\n\t\t\t\tofi_suggest_prov_names(split_names[j]);\n\t\t\t}\n\t\t}\n\t\tofi_free_string_array(split_names);\n\t}\n\n\treturn FI_SUCCESS;\n}\n\nvoid ofi_free_filter(struct fi_filter *filter)\n{\n\tofi_free_string_array(filter->names);\n}\n\nvoid ofi_create_filter(struct fi_filter *filter, const char *raw_filter)\n{\n\tmemset(filter, 0, sizeof *filter);\n\tif (raw_filter == NULL)\n\t\treturn;\n\n\tif (*raw_filter == '^') {\n\t\tfilter->negated = 1;\n\t\t++raw_filter;\n\t}\n\n\tfilter->names = ofi_split_and_alloc(raw_filter, \",\", NULL);\n\tif (!filter->names) {\n\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\"unable to parse filter from: %s\\n\", raw_filter);\n\t\treturn;\n\t}\n\n\tif (verify_filter_names(filter->names))\n\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t        \"unable to verify filter name\\n\");\n}\n\n#ifdef HAVE_LIBDL\nstatic void ofi_reg_dl_prov(const char *lib)\n{\n\tvoid *dlhandle;\n\tstruct fi_provider* (*inif)(void);\n\n\tFI_DBG(&core_prov, FI_LOG_CORE, \"opening provider lib %s\\n\", lib);\n\n\tdlhandle = dlopen(lib, RTLD_NOW);\n\tif (dlhandle == NULL) {\n\t\tFI_DBG(&core_prov, FI_LOG_CORE,\n\t\t\t\"dlopen(%s): %s\\n\", lib, dlerror());\n\t\treturn;\n\t}\n\n\tinif = dlsym(dlhandle, \"fi_prov_ini\");\n\tif (inif == NULL) {\n\t\tFI_WARN(&core_prov, FI_LOG_CORE, \"dlsym: %s\\n\", dlerror());\n\t\tdlclose(dlhandle);\n\t} else {\n\t\tofi_register_provider((inif)(), dlhandle);\n\t}\n}\n\nstatic void ofi_ini_dir(const char *dir)\n{\n\tint n = 0;\n\tchar *lib;\n\tstruct dirent **liblist = NULL;\n\n\tn = scandir(dir, &liblist, lib_filter, NULL);\n\tif (n < 0)\n\t\tgoto libdl_done;\n\n\twhile (n--) {\n\t\tif (asprintf(&lib, \"%s/%s\", dir, liblist[n]->d_name) < 0) {\n\t\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t       \"asprintf failed to allocate memory\\n\");\n\t\t\tgoto libdl_done;\n\t\t}\n\t\tofi_reg_dl_prov(lib);\n\n\t\tfree(liblist[n]);\n\t\tfree(lib);\n\t}\n\nlibdl_done:\n\twhile (n-- > 0)\n\t\tfree(liblist[n]);\n\tfree(liblist);\n}\n\n/* Search standard system library paths (i.e. LD_LIBRARY_PATH) for known DL provider\n * libraries.\n */\nstatic void ofi_find_prov_libs(void)\n{\n\tconst char* lib_prefix = \"lib\";\n\tstruct ofi_prov *prov;\n\tchar* lib;\n\tchar* short_prov_name;\n\n\tfor (prov = prov_head; prov; prov = prov->next) {\n\n\t\tif (!prov->prov_name)\n\t\t\tcontinue;\n\n\t\tif (ofi_has_util_prefix(prov->prov_name)) {\n\t\t\tshort_prov_name = prov->prov_name + strlen(OFI_UTIL_PREFIX);\n\t\t} else {\n\t\t\tshort_prov_name = prov->prov_name;\n\t\t}\n\n\t\tif (asprintf(&lib, \"%s%s%s%s\", lib_prefix,\n\t\t\tshort_prov_name, \"-\", FI_LIB_SUFFIX) < 0) {\n\t\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\t\"asprintf failed to allocate memory\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tofi_reg_dl_prov(lib);\n\t\tfree(lib);\n\t}\n}\n#endif\n\nvoid fi_ini(void)\n{\n\tchar *param_val = NULL;\n\n\tpthread_mutex_lock(&common_locks.ini_lock);\n\n\tif (ofi_init)\n\t\tgoto unlock;\n\n\tofi_ordered_provs_init();\n\tfi_param_init();\n\tfi_log_init();\n\tofi_osd_init();\n\tofi_mem_init();\n\tofi_pmem_init();\n\tofi_perf_init();\n\tofi_hook_init();\n\tofi_hmem_init();\n\tofi_monitors_init();\n\n\tfi_param_define(NULL, \"provider\", FI_PARAM_STRING,\n\t\t\t\"Only use specified provider (default: all available)\");\n\tfi_param_define(NULL, \"fork_unsafe\", FI_PARAM_BOOL,\n\t\t\t\"Whether use of fork() may be unsafe for some providers\"\n\t\t\t\" (default: no). Setting this to yes could improve\"\n\t\t\t\" performance at the expense of making fork() potentially\"\n\t\t\t\" unsafe\");\n\tfi_param_define(NULL, \"universe_size\", FI_PARAM_SIZE_T,\n\t\t\t\"Defines the maximum number of processes that will be\"\n\t\t\t\" used by distribute OFI application. The provider uses\"\n\t\t\t\" this to optimize resource allocations\"\n\t\t\t\" (default: provider specific)\");\n\tfi_param_get_size_t(NULL, \"universe_size\", &ofi_universe_size);\n\tfi_param_get_str(NULL, \"provider\", &param_val);\n\tofi_create_filter(&prov_filter, param_val);\n\n#ifdef HAVE_LIBDL\n\tint n = 0;\n\tchar **dirs;\n\tchar *provdir = NULL;\n\tvoid *dlhandle;\n\n\t/* If dlopen fails, assume static linking and just return\n\t   without error */\n\tdlhandle = dlopen(NULL, RTLD_NOW);\n\tif (dlhandle == NULL) {\n\t\tgoto libdl_done;\n\t}\n\tdlclose(dlhandle);\n\n\tfi_param_define(NULL, \"provider_path\", FI_PARAM_STRING,\n\t\t\t\"Search for providers in specific path (default: \"\n\t\t\tPROVDLDIR \")\");\n\tfi_param_get_str(NULL, \"provider_path\", &provdir);\n\tif (!provdir) {\n\t\tprovdir = PROVDLDIR;\n\t\tofi_find_prov_libs();\n\t}\n\tdirs = ofi_split_and_alloc(provdir, \":\", NULL);\n\tif (dirs) {\n\t\tfor (n = 0; dirs[n]; ++n) {\n\t\t\tofi_ini_dir(dirs[n]);\n\t\t}\n\t\tofi_free_string_array(dirs);\n\t}\nlibdl_done:\n#endif\n\n\tofi_register_provider(PSM2_INIT, NULL);\n\tofi_register_provider(PSM_INIT, NULL);\n\tofi_register_provider(USNIC_INIT, NULL);\n\tofi_register_provider(GNI_INIT, NULL);\n\tofi_register_provider(BGQ_INIT, NULL);\n\tofi_register_provider(NETDIR_INIT, NULL);\n\tofi_register_provider(SHM_INIT, NULL);\n\tofi_register_provider(RXM_INIT, NULL);\n\tofi_register_provider(VERBS_INIT, NULL);\n\t/* ofi_register_provider(RSTREAM_INIT, NULL); - no support */\n\tofi_register_provider(MRAIL_INIT, NULL);\n\tofi_register_provider(RXD_INIT, NULL);\n\tofi_register_provider(EFA_INIT, NULL);\n\tofi_register_provider(UDP_INIT, NULL);\n\tofi_register_provider(SOCKETS_INIT, NULL);\n\tofi_register_provider(TCP_INIT, NULL);\n\n\tofi_register_provider(HOOK_PERF_INIT, NULL);\n\tofi_register_provider(HOOK_DEBUG_INIT, NULL);\n\tofi_register_provider(HOOK_NOOP_INIT, NULL);\n\n\tofi_init = 1;\n\nunlock:\n\tpthread_mutex_unlock(&common_locks.ini_lock);\n}\n\nFI_DESTRUCTOR(fi_fini(void))\n{\n\tstruct ofi_prov *prov;\n\n\tif (!ofi_init)\n\t\treturn;\n\n\twhile (prov_head) {\n\t\tprov = prov_head;\n\t\tprov_head = prov->next;\n\t\tcleanup_provider(prov->provider, prov->dlhandle);\n\t\tfree(prov->prov_name);\n\t\tfree(prov);\n\t}\n\n\tofi_free_filter(&prov_filter);\n\tofi_monitors_cleanup();\n\tofi_hmem_cleanup();\n\tofi_mem_fini();\n\tfi_log_fini();\n\tfi_param_fini();\n\tofi_osd_fini();\n}\n\n__attribute__((visibility (\"default\"),EXTERNALLY_VISIBLE))\nvoid DEFAULT_SYMVER_PRE(fi_freeinfo)(struct fi_info *info)\n{\n\tstruct fi_info *next;\n\n\tfor (; info; info = next) {\n\t\tnext = info->next;\n\n\t\tfree(info->src_addr);\n\t\tfree(info->dest_addr);\n\t\tfree(info->tx_attr);\n\t\tfree(info->rx_attr);\n\t\tif (info->ep_attr) {\n\t\t\tfree(info->ep_attr->auth_key);\n\t\t\tfree(info->ep_attr);\n\t\t}\n\t\tif (info->domain_attr) {\n\t\t\tfree(info->domain_attr->auth_key);\n\t\t\tfree(info->domain_attr->name);\n\t\t\tfree(info->domain_attr);\n\t\t}\n\t\tif (info->fabric_attr) {\n\t\t\tfree(info->fabric_attr->name);\n\t\t\tfree(info->fabric_attr->prov_name);\n\t\t\tfree(info->fabric_attr);\n\t\t}\n\t\tif (info->nic &&\n\t\t    FI_CHECK_OP(info->nic->fid.ops, struct fi_ops, close)) {\n\t\t\tfi_close(&info->nic->fid);\n\t\t}\n\t\tfree(info);\n\t}\n}\nDEFAULT_SYMVER(fi_freeinfo_, fi_freeinfo, FABRIC_1.3);\n\n/*\n * Make a dummy info object for each provider, and copy in the\n * provider name and version.  We report utility providers directly\n * to export their version.\n */\nstatic int ofi_getprovinfo(struct fi_info **info)\n{\n\tstruct ofi_prov *prov;\n\tstruct fi_info *tail, *cur;\n\tint ret = -FI_ENODATA;\n\n\t*info = tail = NULL;\n\tfor (prov = prov_head; prov; prov = prov->next) {\n\t\tif (!prov->provider)\n\t\t\tcontinue;\n\n\t\tcur = fi_allocinfo();\n\t\tif (!cur) {\n\t\t\tret = -FI_ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\tcur->fabric_attr->prov_name = strdup(prov->provider->name);\n\t\tcur->fabric_attr->prov_version = prov->provider->version;\n\n\t\tif (!*info) {\n\t\t\t*info = tail = cur;\n\t\t} else {\n\t\t\ttail->next = cur;\n\t\t}\n\t\ttail = cur;\n\n\t\tret = 0;\n\t}\n\n\treturn ret;\n\nerr:\n\twhile (tail) {\n\t\tcur = tail->next;\n\t\tfi_freeinfo(tail);\n\t\ttail = cur;\n\t}\n\treturn ret;\n}\n\nstatic void ofi_set_prov_attr(struct fi_fabric_attr *attr,\n\t\t\t      struct fi_provider *prov)\n{\n\tchar *core_name;\n\n\tcore_name = attr->prov_name;\n\tif (core_name) {\n\t\tassert(ofi_is_util_prov(prov));\n\t\tattr->prov_name = ofi_strdup_append(core_name, prov->name);\n\t\tfree(core_name);\n\t} else {\n\t\tassert(ofi_is_core_prov(prov));\n\t\tattr->prov_name = strdup(prov->name);\n\t}\n\tattr->prov_version = prov->version;\n}\n\n/*\n * The layering of utility providers over core providers follows these rules.\n * 0. Provider names are delimited by \";\"\n * 1. Rules when # of providers <= 2:\n *    1a. If both are specified, then only return that layering\n *    1b. If a utility provider is specified, return it over any* core provider.\n *    1c. If a core provider is specified, return any utility provider that can\n *        layer over it, plus the core provider itself, if possible.\n *    1d. A utility provider will not layer over a provider that has disabled\n *        utility provider layering unless the user explicitly requests that\n *        combination.\n *    1e. OFI_CORE_PROV_ONLY flag prevents utility providers layering over other\n *        utility providers.\n * 2. If both the providers are utility providers or if more than two providers\n *    are specified, the rightmost provider would be compared.\n * 3. If any provider has a caret symbol \"^\" is prefixed before any provider\n *    name it would be excluded (internal use only). These excluded providers\n *    should be listed only at the end.\n */\nstatic int ofi_layering_ok(const struct fi_provider *provider,\n\t\t\t   char **prov_vec, size_t count,\n\t\t\t   uint64_t flags)\n{\n\tchar *prov_name;\n\tstruct ofi_prov *core_ofi_prov;\n\tint i;\n\n\t/* Excluded providers must be at the end */\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tif (prov_vec[i][0] != '^')\n\t\t    break;\n\n\t\tif (!strcasecmp(&prov_vec[i][1], provider->name))\n\t\t\treturn 0;\n\t}\n\tcount = i + 1;\n\n\tif (flags & OFI_CORE_PROV_ONLY) {\n\t\tassert((count == 1) || (count == 0));\n\t\tif (!ofi_is_core_prov(provider)) {\n\t\t\tFI_INFO(&core_prov, FI_LOG_CORE,\n\t\t\t\t\"Need core provider, skipping %s\\n\",\n\t\t\t\tprovider->name);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif ((count == 0) && ofi_disable_util_layering(provider)) {\n\t\t\tFI_INFO(&core_prov, FI_LOG_CORE,\n\t\t\t\t\"Skipping util;%s layering\\n\", provider->name);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (!count)\n\t\treturn 1;\n\n\t/* To maintain backward compatibility with the previous behavior of\n\t * ofi_layering_ok we need to check if the # of providers is two or\n\t * fewer. In such a case, we have to be agnostic to the ordering of\n\t * core and utility providers */\n\n\tif ((count == 1) && ofi_is_util_prov(provider) &&\n\t    !ofi_has_util_prefix(prov_vec[0])) {\n\t\tcore_ofi_prov = ofi_getprov(prov_vec[0], strlen(prov_vec[0]));\n\t\tif (core_ofi_prov && core_ofi_prov->provider &&\n\t\t    ofi_disable_util_layering(core_ofi_prov->provider)) {\n\t\t\tFI_INFO(&core_prov, FI_LOG_CORE,\n\t\t\t\t\"Skipping %s;%s layering\\n\", prov_vec[0],\n\t\t\t\tprovider->name);\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}\n\n\tif ((count == 2) && ofi_has_util_prefix(prov_vec[0]) &&\n\t    !ofi_has_util_prefix(prov_vec[1]))\n\t\tprov_name = prov_vec[0];\n\telse\n\t\tprov_name = prov_vec[count - 1];\n\n\treturn !strcasecmp(provider->name, prov_name);\n}\n\n__attribute__((visibility (\"default\"),EXTERNALLY_VISIBLE))\nint DEFAULT_SYMVER_PRE(fi_getinfo)(uint32_t version, const char *node,\n\t\tconst char *service, uint64_t flags,\n\t\tconst struct fi_info *hints, struct fi_info **info)\n{\n\tstruct ofi_prov *prov;\n\tstruct fi_info *tail, *cur;\n\tchar **prov_vec = NULL;\n\tsize_t count = 0;\n\tenum fi_log_level level;\n\tint ret;\n\n\tif (!ofi_init)\n\t\tfi_ini();\n\n\tif (FI_VERSION_LT(fi_version(), version)) {\n\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\"Requested version is newer than library\\n\");\n\t\treturn -FI_ENOSYS;\n\t}\n\n\tif (flags == FI_PROV_ATTR_ONLY) {\n\t\treturn ofi_getprovinfo(info);\n\t}\n\n\tif (hints && hints->fabric_attr && hints->fabric_attr->prov_name) {\n\t\tprov_vec = ofi_split_and_alloc(hints->fabric_attr->prov_name,\n\t\t\t\t\t       \";\", &count);\n\t\tif (!prov_vec)\n\t\t\treturn -FI_ENOMEM;\n\t\tFI_DBG(&core_prov, FI_LOG_CORE, \"hints prov_name: %s\\n\",\n\t\t       hints->fabric_attr->prov_name);\n\t}\n\n\t*info = tail = NULL;\n\tfor (prov = prov_head; prov; prov = prov->next) {\n\t\tif (!prov->provider || !prov->provider->getinfo)\n\t\t\tcontinue;\n\n\t\tif (prov->hidden && !(flags & OFI_GETINFO_HIDDEN))\n\t\t\tcontinue;\n\n\t\tif (!ofi_layering_ok(prov->provider, prov_vec, count, flags))\n\t\t\tcontinue;\n\n\t\tif (FI_VERSION_LT(prov->provider->fi_version, version)) {\n\t\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\t\"Provider %s fi_version %d.%d < requested %d.%d\\n\",\n\t\t\t\tprov->provider->name,\n\t\t\t\tFI_MAJOR(prov->provider->fi_version),\n\t\t\t\tFI_MINOR(prov->provider->fi_version),\n\t\t\t\tFI_MAJOR(version), FI_MINOR(version));\n\t\t\tcontinue;\n\t\t}\n\n\t\tcur = NULL;\n\t\tret = prov->provider->getinfo(version, node, service, flags,\n\t\t\t\t\t      hints, &cur);\n\t\tif (ret) {\n\t\t\tlevel = ((hints && hints->fabric_attr &&\n\t\t\t\t  hints->fabric_attr->prov_name) ?\n\t\t\t\t FI_LOG_WARN : FI_LOG_INFO);\n\n\t\t\tFI_LOG(&core_prov, level, FI_LOG_CORE,\n\t\t\t       \"fi_getinfo: provider %s returned -%d (%s)\\n\",\n\t\t\t       prov->provider->name, -ret, fi_strerror(-ret));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!cur) {\n\t\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\t\"fi_getinfo: provider %s output empty list\\n\",\n\t\t\t\tprov->provider->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tFI_DBG(&core_prov, FI_LOG_CORE, \"fi_getinfo: provider %s \"\n\t\t       \"returned success\\n\", prov->provider->name);\n\n\t\tif (!*info)\n\t\t\t*info = cur;\n\t\telse\n\t\t\ttail->next = cur;\n\n\t\tfor (tail = cur; tail->next; tail = tail->next) {\n\t\t\tofi_set_prov_attr(tail->fabric_attr, prov->provider);\n\t\t\ttail->fabric_attr->api_version = version;\n\t\t}\n\t\tofi_set_prov_attr(tail->fabric_attr, prov->provider);\n\t\ttail->fabric_attr->api_version = version;\n\t}\n\tofi_free_string_array(prov_vec);\n\n\tif (!(flags & (OFI_CORE_PROV_ONLY | OFI_GETINFO_INTERNAL |\n\t               OFI_GETINFO_HIDDEN)))\n\t\tofi_filter_info(info);\n\n\treturn *info ? 0 : -FI_ENODATA;\n}\nDEFAULT_SYMVER(fi_getinfo_, fi_getinfo, FABRIC_1.3);\n\nstruct fi_info *ofi_allocinfo_internal(void)\n{\n\tstruct fi_info *info;\n\n\tinfo = calloc(1, sizeof(*info));\n\tif (!info)\n\t\treturn NULL;\n\n\tinfo->tx_attr = calloc(1, sizeof(*info->tx_attr));\n\tinfo->rx_attr = calloc(1, sizeof(*info->rx_attr));\n\tinfo->ep_attr = calloc(1, sizeof(*info->ep_attr));\n\tinfo->domain_attr = calloc(1, sizeof(*info->domain_attr));\n\tinfo->fabric_attr = calloc(1, sizeof(*info->fabric_attr));\n\tif (!info->tx_attr|| !info->rx_attr || !info->ep_attr ||\n\t    !info->domain_attr || !info->fabric_attr)\n\t\tgoto err;\n\n\treturn info;\nerr:\n\tfi_freeinfo(info);\n\treturn NULL;\n}\n\n\n__attribute__((visibility (\"default\"),EXTERNALLY_VISIBLE))\nstruct fi_info *DEFAULT_SYMVER_PRE(fi_dupinfo)(const struct fi_info *info)\n{\n\tstruct fi_info *dup;\n\tint ret;\n\n\tif (!info)\n\t\treturn ofi_allocinfo_internal();\n\n\tdup = mem_dup(info, sizeof(*dup));\n\tif (dup == NULL) {\n\t\treturn NULL;\n\t}\n\tdup->src_addr = NULL;\n\tdup->dest_addr = NULL;\n\tdup->tx_attr = NULL;\n\tdup->rx_attr = NULL;\n\tdup->ep_attr = NULL;\n\tdup->domain_attr = NULL;\n\tdup->fabric_attr = NULL;\n\tdup->next = NULL;\n\n\tif (info->src_addr != NULL) {\n\t\tdup->src_addr = mem_dup(info->src_addr, info->src_addrlen);\n\t\tif (dup->src_addr == NULL)\n\t\t\tgoto fail;\n\t}\n\tif (info->dest_addr != NULL) {\n\t\tdup->dest_addr = mem_dup(info->dest_addr, info->dest_addrlen);\n\t\tif (dup->dest_addr == NULL)\n\t\t\tgoto fail;\n\t}\n\tif (info->tx_attr != NULL) {\n\t\tdup->tx_attr = mem_dup(info->tx_attr, sizeof(*info->tx_attr));\n\t\tif (dup->tx_attr == NULL)\n\t\t\tgoto fail;\n\t}\n\tif (info->rx_attr != NULL) {\n\t\tdup->rx_attr = mem_dup(info->rx_attr, sizeof(*info->rx_attr));\n\t\tif (dup->rx_attr == NULL)\n\t\t\tgoto fail;\n\t}\n\tif (info->ep_attr != NULL) {\n\t\tdup->ep_attr = mem_dup(info->ep_attr, sizeof(*info->ep_attr));\n\t\tif (dup->ep_attr == NULL)\n\t\t\tgoto fail;\n\t\tif (info->ep_attr->auth_key != NULL) {\n\t\t\tdup->ep_attr->auth_key =\n\t\t\t\tmem_dup(info->ep_attr->auth_key,\n\t\t\t\t\tinfo->ep_attr->auth_key_size);\n\t\t\tif (dup->ep_attr->auth_key == NULL)\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\tif (info->domain_attr) {\n\t\tdup->domain_attr = mem_dup(info->domain_attr,\n\t\t\t\t\t   sizeof(*info->domain_attr));\n\t\tif (dup->domain_attr == NULL)\n\t\t\tgoto fail;\n\t\tdup->domain_attr->name = NULL;\n\t\tdup->domain_attr->auth_key = NULL;\n\t\tif (info->domain_attr->name != NULL) {\n\t\t\tdup->domain_attr->name = strdup(info->domain_attr->name);\n\t\t\tif (dup->domain_attr->name == NULL)\n\t\t\t\tgoto fail;\n\t\t}\n\t\tif (info->domain_attr->auth_key != NULL) {\n\t\t\tdup->domain_attr->auth_key =\n\t\t\t\tmem_dup(info->domain_attr->auth_key,\n\t\t\t\t\tinfo->domain_attr->auth_key_size);\n\t\t\tif (dup->domain_attr->auth_key == NULL)\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\tif (info->fabric_attr) {\n\t\tdup->fabric_attr = mem_dup(info->fabric_attr,\n\t\t\t\t\t   sizeof(*info->fabric_attr));\n\t\tif (dup->fabric_attr == NULL)\n\t\t\tgoto fail;\n\t\tdup->fabric_attr->name = NULL;\n\t\tdup->fabric_attr->prov_name = NULL;\n\t\tif (info->fabric_attr->name != NULL) {\n\t\t\tdup->fabric_attr->name = strdup(info->fabric_attr->name);\n\t\t\tif (dup->fabric_attr->name == NULL)\n\t\t\t\tgoto fail;\n\t\t}\n\t\tif (info->fabric_attr->prov_name != NULL) {\n\t\t\tdup->fabric_attr->prov_name = strdup(info->fabric_attr->prov_name);\n\t\t\tif (dup->fabric_attr->prov_name == NULL)\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tif (info->nic) {\n\t\tret = fi_control(&info->nic->fid, FI_DUP, &dup->nic);\n\t\tif (ret && ret != -FI_ENOSYS)\n\t\t\tgoto fail;\n\t}\n\n\treturn dup;\n\nfail:\n\tfi_freeinfo(dup);\n\treturn NULL;\n}\nDEFAULT_SYMVER(fi_dupinfo_, fi_dupinfo, FABRIC_1.3);\n\n__attribute__((visibility (\"default\"),EXTERNALLY_VISIBLE))\nint DEFAULT_SYMVER_PRE(fi_fabric)(struct fi_fabric_attr *attr,\n\t\tstruct fid_fabric **fabric, void *context)\n{\n\tstruct ofi_prov *prov;\n\tconst char *top_name;\n\tint ret;\n\n\tif (!attr || !attr->prov_name || !attr->name)\n\t\treturn -FI_EINVAL;\n\n\tif (!ofi_init)\n\t\tfi_ini();\n\n\ttop_name = strrchr(attr->prov_name, OFI_NAME_DELIM);\n\tif (top_name)\n\t\ttop_name++;\n\telse\n\t\ttop_name = attr->prov_name;\n\n\tif (!top_name)\n\t\treturn -FI_EINVAL;\n\n\tprov = ofi_getprov(top_name, strlen(top_name));\n\tif (!prov || !prov->provider || !prov->provider->fabric)\n\t\treturn -FI_ENODEV;\n\n\tret = prov->provider->fabric(attr, fabric, context);\n\tif (!ret) {\n\t\tif (FI_VERSION_GE(prov->provider->fi_version, FI_VERSION(1, 5)))\n\t\t\t(*fabric)->api_version = attr->api_version;\n\t\tFI_INFO(&core_prov, FI_LOG_CORE, \"Opened fabric: %s\\n\",\n\t\t\tattr->name);\n\n\t\tofi_hook_install(*fabric, fabric, prov->provider);\n\t}\n\n\treturn ret;\n}\nDEFAULT_SYMVER(fi_fabric_, fi_fabric, FABRIC_1.1);\n\n__attribute__((visibility (\"default\"),EXTERNALLY_VISIBLE))\nuint32_t DEFAULT_SYMVER_PRE(fi_version)(void)\n{\n\treturn FI_VERSION(FI_MAJOR_VERSION, FI_MINOR_VERSION);\n}\nDEFAULT_SYMVER(fi_version_, fi_version, FABRIC_1.0);\n\nstatic const char *const errstr[] = {\n\t[FI_EOTHER - FI_ERRNO_OFFSET] = \"Unspecified error\",\n\t[FI_ETOOSMALL - FI_ERRNO_OFFSET] = \"Provided buffer is too small\",\n\t[FI_EOPBADSTATE - FI_ERRNO_OFFSET] = \"Operation not permitted in current state\",\n\t[FI_EAVAIL - FI_ERRNO_OFFSET]  = \"Error available\",\n\t[FI_EBADFLAGS - FI_ERRNO_OFFSET] = \"Flags not supported\",\n\t[FI_ENOEQ - FI_ERRNO_OFFSET] = \"Missing or unavailable event queue\",\n\t[FI_EDOMAIN - FI_ERRNO_OFFSET] = \"Invalid resource domain\",\n\t[FI_ENOCQ - FI_ERRNO_OFFSET] = \"Missing or unavailable completion queue\",\n\t[FI_ECRC - FI_ERRNO_OFFSET] = \"CRC error\",\n\t[FI_ETRUNC - FI_ERRNO_OFFSET] = \"Truncation error\",\n\t[FI_ENOKEY - FI_ERRNO_OFFSET] = \"Required key not available\",\n\t[FI_ENOAV - FI_ERRNO_OFFSET] = \"Missing or unavailable address vector\",\n\t[FI_EOVERRUN - FI_ERRNO_OFFSET] = \"Queue has been overrun\",\n};\n\n__attribute__((visibility (\"default\"),EXTERNALLY_VISIBLE))\nconst char *DEFAULT_SYMVER_PRE(fi_strerror)(int errnum)\n{\n\tif (errnum < FI_ERRNO_OFFSET)\n\t\treturn strerror(errnum);\n\telse if (errnum < FI_ERRNO_MAX)\n\t\treturn errstr[errnum - FI_ERRNO_OFFSET];\n\telse\n\t\treturn errstr[FI_EOTHER - FI_ERRNO_OFFSET];\n}\nDEFAULT_SYMVER(fi_strerror_, fi_strerror, FABRIC_1.0);\n",
        "/tmp/vanessa/spack-stage/spack-stage-libfabric-master-7qyp67ncottp7it3zyzdyxcucafartnj/spack-src/src/hmem_rocr.c": "/*\n * (C) Copyright 2020 Hewlett Packard Enterprise Development LP\n *\n * This software is available to you under a choice of one of two\n * licenses.  You may choose to be licensed under the terms of the GNU\n * General Public License (GPL) Version 2, available from the file\n * COPYING in the main directory of this source tree, or the\n * BSD license below:\n *\n *     Redistribution and use in source and binary forms, with or\n *     without modification, are permitted provided that the following\n *     conditions are met:\n *\n *      - Redistributions of source code must retain the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer.\n *\n *      - Redistributions in binary form must reproduce the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer in the documentation and/or other materials\n *        provided with the distribution.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n#if HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#include \"ofi_hmem.h\"\n#include \"ofi.h\"\n\n#ifdef HAVE_ROCR\n\n#include <hsa/hsa_ext_amd.h>\n\nstruct rocr_ops {\n\thsa_status_t (*hsa_memory_copy)(void *dst, const void *src,\n\t\t\t\t\tsize_t size);\n\thsa_status_t (*hsa_amd_pointer_info)(void *ptr,\n\t\t\t\t\t     hsa_amd_pointer_info_t *info,\n\t\t\t\t\t     void *(*alloc)(size_t),\n\t\t\t\t\t     uint32_t *num_agents_accessible,\n\t\t\t\t\t     hsa_agent_t **accessible);\n\thsa_status_t (*hsa_init)(void);\n\thsa_status_t (*hsa_shut_down)(void);\n\thsa_status_t (*hsa_status_string)(hsa_status_t status,\n\t\t\t\t\t  const char **status_string);\n\thsa_status_t (*hsa_amd_dereg_dealloc_cb)(void *ptr,\n\t\t\t\t\t\t hsa_amd_deallocation_callback_t cb);\n\thsa_status_t (*hsa_amd_reg_dealloc_cb)(void *ptr,\n\t\t\t\t\t       hsa_amd_deallocation_callback_t cb,\n\t\t\t\t\t       void *user_data);\n\thsa_status_t (*hsa_amd_memory_lock)(void *host_ptr, size_t size,\n\t\t\t\t\t    hsa_agent_t *agents, int num_agents,\n\t\t\t\t\t    void **agent_ptr);\n\thsa_status_t (*hsa_amd_memory_unlock)(void *host_ptr);\n};\n\n#ifdef ENABLE_ROCR_DLOPEN\n\n#include <dlfcn.h>\n\nstatic void *rocr_handle;\nstatic struct rocr_ops rocr_ops;\n\n#else\n\nstatic struct rocr_ops rocr_ops = {\n\t.hsa_memory_copy = hsa_memory_copy,\n\t.hsa_amd_pointer_info = hsa_amd_pointer_info,\n\t.hsa_init = hsa_init,\n\t.hsa_shut_down = hsa_shut_down,\n\t.hsa_status_string = hsa_status_string,\n\t.hsa_amd_dereg_dealloc_cb =\n\t\thsa_amd_deregister_deallocation_callback,\n\t.hsa_amd_reg_dealloc_cb =\n\t\thsa_amd_register_deallocation_callback,\n\t.hsa_amd_memory_lock = hsa_amd_memory_lock,\n\t.hsa_amd_memory_unlock = hsa_amd_memory_unlock,\n};\n\n#endif /* ENABLE_ROCR_DLOPEN */\n\nhsa_status_t ofi_hsa_amd_memory_lock(void *host_ptr, size_t size,\n\t\t\t\t     hsa_agent_t *agents, int num_agents,\n\t\t\t\t     void **agent_ptr)\n{\n\treturn rocr_ops.hsa_amd_memory_lock(host_ptr, size, agents, num_agents,\n\t\t\t\t\t    agent_ptr);\n}\n\nhsa_status_t ofi_hsa_amd_memory_unlock(void *host_ptr)\n{\n\treturn rocr_ops.hsa_amd_memory_unlock(host_ptr);\n}\n\nhsa_status_t ofi_hsa_memory_copy(void *dst, const void *src, size_t size)\n{\n\treturn rocr_ops.hsa_memory_copy(dst, src, size);\n}\n\nhsa_status_t ofi_hsa_amd_pointer_info(void *ptr, hsa_amd_pointer_info_t *info,\n\t\t\t\t      void *(*alloc)(size_t),\n\t\t\t\t      uint32_t *num_agents_accessible,\n\t\t\t\t      hsa_agent_t **accessible)\n{\n\treturn rocr_ops.hsa_amd_pointer_info(ptr, info, alloc,\n\t\t\t\t\t     num_agents_accessible, accessible);\n}\n\nhsa_status_t ofi_hsa_init(void)\n{\n\treturn rocr_ops.hsa_init();\n}\n\nhsa_status_t ofi_hsa_shut_down(void)\n{\n\treturn rocr_ops.hsa_shut_down();\n}\n\nhsa_status_t ofi_hsa_status_string(hsa_status_t status,\n\t\t\t\t   const char **status_string)\n{\n\treturn rocr_ops.hsa_status_string(status, status_string);\n}\n\nconst char *ofi_hsa_status_to_string(hsa_status_t status)\n{\n\tconst char *str;\n\thsa_status_t hsa_ret;\n\n\thsa_ret = ofi_hsa_status_string(status, &str);\n\tif (hsa_ret != HSA_STATUS_SUCCESS)\n\t\treturn \"unknown error\";\n\n\treturn str;\n}\n\nhsa_status_t ofi_hsa_amd_dereg_dealloc_cb(void *ptr,\n\t\t\t\t\t  hsa_amd_deallocation_callback_t cb)\n{\n\treturn rocr_ops.hsa_amd_dereg_dealloc_cb(ptr, cb);\n}\n\nhsa_status_t ofi_hsa_amd_reg_dealloc_cb(void *ptr,\n\t\t\t\t\thsa_amd_deallocation_callback_t cb,\n\t\t\t\t\tvoid *user_data)\n{\n\treturn rocr_ops.hsa_amd_reg_dealloc_cb(ptr, cb, user_data);\n}\n\nstatic int rocr_memcpy(void *dest, const void *src, size_t size)\n{\n\thsa_status_t hsa_ret;\n\n\thsa_ret = ofi_hsa_memory_copy(dest, src, size);\n\tif (hsa_ret == HSA_STATUS_SUCCESS)\n\t\treturn 0;\n\n\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\"Failed to perform hsa_memory_copy: %s\\n\",\n\t\tofi_hsa_status_to_string(hsa_ret));\n\n\treturn -FI_EIO;\n}\n\nstatic int rocr_host_memory_ptr(void *host_ptr, void **ptr)\n{\n\thsa_amd_pointer_info_t info = {\n\t\t.size = sizeof(info),\n\t};\n\thsa_status_t hsa_ret;\n\n\thsa_ret = ofi_hsa_amd_pointer_info((void *)host_ptr, &info, NULL, NULL,\n\t\t\t\t\t   NULL);\n\tif (hsa_ret != HSA_STATUS_SUCCESS) {\n\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\"Failed to perform hsa_amd_pointer_info: %s\\n\",\n\t\t\tofi_hsa_status_to_string(hsa_ret));\n\n\t\treturn -FI_EIO;\n\t}\n\n\tif (info.type != HSA_EXT_POINTER_TYPE_LOCKED)\n\t\t*ptr = host_ptr;\n\telse\n\t\t*ptr = (void *) ((uintptr_t) info.agentBaseAddress +\n\t\t\t\t (uintptr_t) host_ptr -\n\t\t\t\t (uintptr_t) info.hostBaseAddress);\n\n\treturn FI_SUCCESS;\n}\n\nint rocr_copy_from_dev(uint64_t device, void *dest, const void *src,\n\t\t       size_t size)\n{\n\tint ret;\n\tvoid *dest_memcpy_ptr;\n\n\tret = rocr_host_memory_ptr(dest, &dest_memcpy_ptr);\n\tif (ret != FI_SUCCESS)\n\t\treturn ret;\n\n\tret = rocr_memcpy(dest_memcpy_ptr, src, size);\n\n\treturn ret;\n}\n\nint rocr_copy_to_dev(uint64_t device, void *dest, const void *src,\n\t\t     size_t size)\n{\n\tint ret;\n\tvoid *src_memcpy_ptr;\n\n\tret = rocr_host_memory_ptr((void *) src, &src_memcpy_ptr);\n\tif (ret != FI_SUCCESS)\n\t\treturn ret;\n\n\tret = rocr_memcpy(dest, src_memcpy_ptr, size);\n\n\treturn ret;\n}\n\nbool rocr_is_addr_valid(const void *addr)\n{\n\thsa_amd_pointer_info_t hsa_info = {\n\t\t.size = sizeof(hsa_info),\n\t};\n\thsa_status_t hsa_ret;\n\n\thsa_ret = ofi_hsa_amd_pointer_info((void *)addr, &hsa_info, NULL, NULL,\n\t\t\t\t\t   NULL);\n\tif (hsa_ret == HSA_STATUS_SUCCESS) {\n\t\tif (hsa_info.type == HSA_EXT_POINTER_TYPE_HSA)\n\t\t\treturn true;\n\t} else {\n\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\"Failed to perform hsa_amd_pointer_info: %s\\n\",\n\t\t\tofi_hsa_status_to_string(hsa_ret));\n\t}\n\n\treturn false;\n}\n\nstatic int rocr_hmem_dl_init(void)\n{\n#ifdef ENABLE_ROCR_DLOPEN\n\t/* Assume if dlopen fails, the ROCR library could not be found. Do not\n\t * treat this as an error.\n\t */\n\trocr_handle = dlopen(\"libhsa-runtime64.so\", RTLD_NOW);\n\tif (!rocr_handle) {\n\t\tFI_INFO(&core_prov, FI_LOG_CORE,\n\t\t\t\"Unable to dlopen libhsa-runtime64.so\\n\");\n\t\treturn -FI_ENOSYS;\n\t}\n\n\trocr_ops.hsa_memory_copy = dlsym(rocr_handle, \"hsa_memory_copy\");\n\tif (!rocr_ops.hsa_memory_copy) {\n\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\"Failed to find hsa_memory_copy\\n\");\n\t\tgoto err;\n\t}\n\n\trocr_ops.hsa_amd_pointer_info = dlsym(rocr_handle,\n\t\t\t\t\t      \"hsa_amd_pointer_info\");\n\tif (!rocr_ops.hsa_amd_pointer_info) {\n\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\"Failed to find hsa_amd_pointer_info\\n\");\n\t\tgoto err;\n\t}\n\n\trocr_ops.hsa_init = dlsym(rocr_handle, \"hsa_init\");\n\tif (!rocr_ops.hsa_init) {\n\t\tFI_WARN(&core_prov, FI_LOG_CORE, \"Failed to find hsa_init\\n\");\n\t\tgoto err;\n\t}\n\n\trocr_ops.hsa_shut_down = dlsym(rocr_handle, \"hsa_shut_down\");\n\tif (!rocr_ops.hsa_shut_down) {\n\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\"Failed to find hsa_shut_down\\n\");\n\t\tgoto err;\n\t}\n\n\trocr_ops.hsa_status_string = dlsym(rocr_handle, \"hsa_status_string\");\n\tif (!rocr_ops.hsa_status_string) {\n\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\"Failed to find hsa_status_string\\n\");\n\t\tgoto err;\n\t}\n\n\trocr_ops.hsa_amd_dereg_dealloc_cb =\n\t\tdlsym(rocr_handle, \"hsa_amd_deregister_deallocation_callback\");\n\tif (!rocr_ops.hsa_amd_dereg_dealloc_cb) {\n\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\"Failed to find hsa_amd_deregister_deallocation_callback\\n\");\n\t\tgoto err;\n\t}\n\n\trocr_ops.hsa_amd_reg_dealloc_cb =\n\t\tdlsym(rocr_handle, \"hsa_amd_register_deallocation_callback\");\n\tif (!rocr_ops.hsa_amd_reg_dealloc_cb) {\n\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\"Failed to find hsa_amd_register_deallocation_callback\\n\");\n\t\tgoto err;\n\t}\n\n\trocr_ops.hsa_amd_memory_lock = dlsym(rocr_handle,\n\t\t\t\t\t     \"hsa_amd_memory_lock\");\n\tif (!rocr_ops.hsa_amd_memory_lock) {\n\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\"Failed to find hsa_amd_memory_lock\\n\");\n\t\tgoto err;\n\t}\n\n\trocr_ops.hsa_amd_memory_unlock = dlsym(rocr_handle,\n\t\t\t\t\t       \"hsa_amd_memory_unlock\");\n\tif (!rocr_ops.hsa_amd_memory_lock) {\n\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\"Failed to find hsa_amd_memory_unlock\\n\");\n\t\tgoto err;\n\t}\n\n\treturn FI_SUCCESS;\n\nerr:\n\tdlclose(rocr_handle);\n\n\treturn -FI_ENODATA;\n#else\n\treturn FI_SUCCESS;\n#endif /* ENABLE_ROCR_DLOPEN */\n}\n\nstatic void rocr_hmem_dl_cleanup(void)\n{\n#ifdef ENABLE_ROCR_DLOPEN\n\tdlclose(rocr_handle);\n#endif\n}\n\nint rocr_hmem_init(void)\n{\n\thsa_status_t hsa_ret;\n\tint ret;\n\tint log_level;\n\n\tret = rocr_hmem_dl_init();\n\tif (ret != FI_SUCCESS)\n\t\treturn ret;\n\n\thsa_ret = ofi_hsa_init();\n\tif (hsa_ret == HSA_STATUS_SUCCESS)\n\t\treturn FI_SUCCESS;\n\n\t/* Treat HSA_STATUS_ERROR_OUT_OF_RESOURCES as ROCR not being supported\n\t * instead of an error. This ROCR error is typically returned if no\n\t * devices are supported.\n\t */\n\tif (hsa_ret == HSA_STATUS_ERROR_OUT_OF_RESOURCES) {\n\t\tlog_level = FI_LOG_INFO;\n\t\tret = -FI_ENOSYS;\n\t} else {\n\t\tlog_level = FI_LOG_WARN;\n\t\tret = -FI_EIO;\n\t}\n\n\tFI_LOG(&core_prov, log_level, FI_LOG_CORE,\n\t       \"Failed to perform hsa_init: %s\\n\",\n\t       ofi_hsa_status_to_string(hsa_ret));\n\n\trocr_hmem_dl_cleanup();\n\n\treturn ret;\n}\n\nint rocr_hmem_cleanup(void)\n{\n\thsa_status_t hsa_ret;\n\n\thsa_ret = ofi_hsa_shut_down();\n\tif (hsa_ret != HSA_STATUS_SUCCESS) {\n\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\"Failed to perform hsa_shut_down: %s\\n\",\n\t\t\tofi_hsa_status_to_string(hsa_ret));\n\t\treturn -FI_ENODATA;\n\t}\n\n\trocr_hmem_dl_cleanup();\n\n\treturn FI_SUCCESS;\n}\n\nint rocr_host_register(void *ptr, size_t size)\n{\n\thsa_status_t hsa_ret;\n\tvoid *tmp;\n\n\thsa_ret = ofi_hsa_amd_memory_lock(ptr, size, NULL, 0, &tmp);\n\tif (hsa_ret == HSA_STATUS_SUCCESS)\n\t\treturn FI_SUCCESS;\n\n\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\"Failed to perform hsa_amd_memory_lock: %s\\n\",\n\t\tofi_hsa_status_to_string(hsa_ret));\n\n\treturn -FI_EIO;\n}\n\nint rocr_host_unregister(void *ptr)\n{\n\thsa_status_t hsa_ret;\n\n\thsa_ret = ofi_hsa_amd_memory_unlock(ptr);\n\tif (hsa_ret == HSA_STATUS_SUCCESS)\n\t\treturn FI_SUCCESS;\n\n\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\"Failed to perform hsa_amd_memory_unlock: %s\\n\",\n\t\tofi_hsa_status_to_string(hsa_ret));\n\n\treturn -FI_EIO;\n}\n\n#else\n\nint rocr_copy_from_dev(uint64_t device, void *dest, const void *src,\n\t\t       size_t size)\n{\n\treturn -FI_ENOSYS;\n}\n\nint rocr_copy_to_dev(uint64_t device, void *dest, const void *src,\n\t\t     size_t size)\n{\n\treturn -FI_ENOSYS;\n}\n\nint rocr_hmem_init(void)\n{\n\treturn -FI_ENOSYS;\n}\n\nint rocr_hmem_cleanup(void)\n{\n\treturn -FI_ENOSYS;\n}\n\nbool rocr_is_addr_valid(const void *addr)\n{\n\treturn false;\n}\n\nint rocr_host_register(void *ptr, size_t size)\n{\n\treturn -FI_ENOSYS;\n}\n\nint rocr_host_unregister(void *ptr)\n{\n\treturn -FI_ENOSYS;\n}\n\n#endif /* HAVE_ROCR */\n",
        "/tmp/vanessa/spack-stage/spack-stage-libfabric-master-7qyp67ncottp7it3zyzdyxcucafartnj/spack-src/fabtests/configure.ac": "dnl\ndnl Copyright (c) 2016-2017 Cisco Systems, Inc.  All rights reserved.\ndnl Copyright (c) 2018-2020 Intel Corporation, Inc.  All rights reserved.\ndnl\ndnl Process this file with autoconf to produce a configure script.\n\nAC_PREREQ(2.57)\nAC_INIT([fabtests], [1.12.0rc1], [ofiwg@lists.openfabrics.org])\nAC_CONFIG_AUX_DIR(config)\nAC_CONFIG_MACRO_DIR(config)\nAC_CONFIG_HEADERS(config.h)\nAM_INIT_AUTOMAKE([1.11 dist-bzip2 foreign -Wall -Werror subdir-objects tar-pax])\nm4_ifdef([AM_SILENT_RULES], [AM_SILENT_RULES([yes])])\n\nAC_CANONICAL_HOST\n\nmacos=0\nlinux=0\nfreebsd=0\n\ncase $host_os in\n*darwin*)\n\tmacos=1\n\t;;\n*linux*)\n\tlinux=1\n\t;;\n*freebsd*)\n\tfreebsd=1\n\t;;\n*)\n\tAC_MSG_ERROR([libfabric only builds on Linux & OS X])\n\t;;\nesac\n\nAM_CONDITIONAL([MACOS], [test $macos -eq 1])\nAM_CONDITIONAL([LINUX], [test $linux -eq 1])\nAM_CONDITIONAL([FREEBSD], [test $freebsd -eq 1])\n\nbase_c_warn_flags=\"-Wall -Wundef -Wpointer-arith\"\ndebug_c_warn_flags=\"-Wextra -Wno-unused-parameter -Wno-sign-compare -Wno-missing-field-initializers\"\ndebug_c_other_flags=\"-fstack-protector-strong\"\n\nAC_ARG_ENABLE([debug],\n\t[AS_HELP_STRING([--enable-debug],\n\t\t\t[Enable debugging - default NO])],\n\t[CFLAGS=\"-g -O0 ${base_c_warn_flags} ${debug_c_warn_flags} ${debug_c_other_flags} $CFLAGS\"\n\t dbg=1],\n\t[dbg=0])\n\nAC_DEFINE_UNQUOTED([ENABLE_DEBUG], [$dbg],\n\t[defined to 1 if configured with --enable-debug])\n\ndnl Fix autoconf's habit of adding -g -O2 by default\nAS_IF([test -z \"$CFLAGS\"],\n      [CFLAGS=\"-O2 -DNDEBUG ${base_c_warn_flags}\"])\n\n# AM PROG_AR did not exist pre AM 1.11.x (where x is somewhere >0 and\n# <3), but it is necessary in AM 1.12.x.\nm4_ifdef([AM_PROG_AR], [AM_PROG_AR])\n\nAM_PROG_LIBTOOL\n\nAC_ARG_WITH([valgrind],\n    AC_HELP_STRING([--with-valgrind],\n\t\t   [Enable valgrind annotations - default NO]))\n\nif test \"$with_valgrind\" != \"\" && test \"$with_valgrind\" != \"no\"; then\n\tAC_DEFINE([INCLUDE_VALGRIND], 1,\n\t\t  [Define to 1 to enable valgrind annotations])\n\tif test -d $with_valgrind; then\n\t\tCPPFLAGS=\"$CPPLFAGS -I$with_valgrind/include\"\n\tfi\nfi\n\ndnl Checks for programs\nAC_PROG_CC\nAM_PROG_CC_C_O\n\nLT_INIT\n\nhave_clock_gettime=0\n\nAC_SEARCH_LIBS([clock_gettime],[rt],\n\t       [have_clock_gettime=1],\n\t       [])\n\nAC_DEFINE_UNQUOTED(HAVE_CLOCK_GETTIME, [$have_clock_gettime],\n\t\t   [Define to 1 if clock_gettime is available.])\nAM_CONDITIONAL(HAVE_CLOCK_GETTIME, [test $have_clock_gettime -eq 1])\n\nAC_ARG_WITH([libfabric],\n            AC_HELP_STRING([--with-libfabric], [Use non-default libfabric location - default NO]),\n            [AS_IF([test -d $withval/lib64], [fab_libdir=\"lib64\"], [fab_libdir=\"lib\"])\n             CPPFLAGS=\"-I$withval/include $CPPFLAGS\"\n             LDFLAGS=\"-L$withval/$fab_libdir $LDFLAGS\"],\n            [])\n\ndnl Check for CUDA support. Require fabtests to dlopen CUDA runtime.\nAC_ARG_WITH([cuda],\n            [AC_HELP_STRING([--with-cuda=DIR],\n                            [Provide path to where the CUDA development\n                             and runtime libraries are installed.])],\n            [AS_IF([test \"$freebsd\" == \"0\"],\n                   [AC_CHECK_LIB(dl, dlopen, [], [AC_MSG_ERROR([dlopen not found.])])],\n                   [])\n             CPPFLAGS=\"-I$withval/include $CPPFLAGS\"\n             AC_CHECK_HEADER([cuda_runtime.h],\n                             [AC_DEFINE([HAVE_CUDA_RUNTIME_H], [1],\n                                        [Define to 1 if you have <cuda_runtime.h>])],\n                             [AC_MSG_ERROR([<cuda_runtime.h> not found])])],\n            [])\n\ndnl Check for ROCR support. Require fabtests to dlopen ROCR.\nAC_ARG_WITH([rocr],\n            [AC_HELP_STRING([--with-rocr=DIR],\n                            [Provide path to where the ROCR development\n                             and runtime libraries are installed.])],\n            [AS_IF([test \"$freebsd\" == \"0\"],\n                   [AC_CHECK_LIB(dl, dlopen, [], [AC_MSG_ERROR([dlopen not found.])])],\n                   [])\n             CPPFLAGS=\"-I$withval/include $CPPFLAGS\"\n             AC_CHECK_HEADER([hsa/hsa.h],\n                             [AC_DEFINE([HAVE_ROCR_RUNTIME_H], [1],\n                                        [Define to 1 if you have <hsa/hsa.h>])],\n                             [AC_MSG_ERROR([<hsa/hsa.h> not found])])],\n            [])\n\ndnl Checks for libraries\nAC_CHECK_LIB([fabric], fi_getinfo, [],\n    AC_MSG_ERROR([fi_getinfo() not found.  fabtests requires libfabric.]))\n\ndnl Checks for header files.\nAC_HEADER_STDC\nAC_CHECK_HEADER([rdma/fabric.h], [],\n    [AC_MSG_ERROR([<rdma/fabric.h> not found.  fabtests requires libfabric.])])\n\nAC_ARG_WITH([ze],\n            AC_HELP_STRING([--with-ze], [Use non-default ZE location - default NO]),\n            [CPPFLAGS=\"-I$withval/include $CPPFLAGS\"\n             LDFLAGS=\"-L$withval/$lib $LDFLAGS\"],\n            [])\n\ndnl Checks for ZE libraries\nAS_IF([test x\"$with_ze\" != x\"no\"],\n      [AC_CHECK_LIB([ze_loader], zeInit,\n       AC_CHECK_HEADER([level_zero/ze_api.h],\n\t\t\tAC_DEFINE([HAVE_LIBZE], 1, [ZE support])),\n\t\t\t[])]\n      [])\n\nAC_MSG_CHECKING([for fi_trywait support])\nAC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <rdma/fi_eq.h>]],\n\t       [[fi_trywait(NULL, NULL, 0);]])],\n\t       [AC_MSG_RESULT([yes])],\n\t       [AC_MSG_RESULT([no])\n\t        AC_MSG_ERROR([fabtests requires fi_trywait support. Cannot continue])])\n\nif test \"$with_valgrind\" != \"\" && test \"$with_valgrind\" != \"no\"; then\nAC_CHECK_HEADER(valgrind/memcheck.h, [],\n    AC_MSG_ERROR([valgrind requested but <valgrind/memcheck.h> not found.]))\nfi\n\nAC_CHECK_FUNC([epoll_create1], [have_epoll=1], [have_epoll=0])\nAC_DEFINE_UNQUOTED([HAVE_EPOLL], [$have_epoll],\n\t\t   [Defined to 1 if Linux epoll is available])\n\nAC_CONFIG_FILES([Makefile fabtests.spec])\n\nAC_OUTPUT\n",
        "/tmp/vanessa/spack-stage/spack-stage-libfabric-master-7qyp67ncottp7it3zyzdyxcucafartnj/spack-src/fabtests/common/hmem_cuda.c": "/*\n * (C) Copyright 2020 Hewlett Packard Enterprise Development LP\n *\n * This software is available to you under a choice of one of two\n * licenses.  You may choose to be licensed under the terms of the GNU\n * General Public License (GPL) Version 2, available from the file\n * COPYING in the main directory of this source tree, or the\n * BSD license below:\n *\n *     Redistribution and use in source and binary forms, with or\n *     without modification, are permitted provided that the following\n *     conditions are met:\n *\n *      - Redistributions of source code must retain the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer.\n *\n *      - Redistributions in binary form must reproduce the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer in the documentation and/or other materials\n *        provided with the distribution.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n#include \"hmem.h\"\n#include \"shared.h\"\n\n#ifdef HAVE_CUDA_RUNTIME_H\n\n#include <dlfcn.h>\n#include <stdio.h>\n#include <cuda_runtime.h>\n\nstruct cuda_ops {\n\tcudaError_t (*cudaMemcpy)(void *dst, const void *src, size_t count,\n\t\t\t\t  enum cudaMemcpyKind kind);\n\tcudaError_t (*cudaMalloc)(void **ptr, size_t size);\n\tcudaError_t (*cudaFree)(void *ptr);\n\tcudaError_t (*cudaMemset)(void *ptr, int value, size_t count);\n\tconst char *(*cudaGetErrorName)(cudaError_t error);\n\tconst char *(*cudaGetErrorString)(cudaError_t error);\n};\n\nstatic struct cuda_ops cuda_ops;\nstatic void *cudart_handle;\n\n#define CUDA_ERR(err, fmt, ...) \\\n\tFT_ERR(fmt \": %s %s\", ##__VA_ARGS__, cuda_ops.cudaGetErrorName(err), \\\n\t       cuda_ops.cudaGetErrorString(err))\n\nint ft_cuda_init(void)\n{\n\tcudart_handle = dlopen(\"libcudart.so\", RTLD_NOW);\n\tif (!cudart_handle) {\n\t\tFT_ERR(\"Failed to dlopen libcudart.so\");\n\t\tgoto err;\n\t}\n\n\tcuda_ops.cudaMemcpy = dlsym(cudart_handle, \"cudaMemcpy\");\n\tif (!cuda_ops.cudaMemcpy) {\n\t\tFT_ERR(\"Failed to find cudaMemcpy\");\n\t\tgoto err_dlclose_cuda;\n\t}\n\n\tcuda_ops.cudaMalloc = dlsym(cudart_handle, \"cudaMalloc\");\n\tif (!cuda_ops.cudaMalloc) {\n\t\tFT_ERR(\"Failed to find cudaMalloc\");\n\t\tgoto err_dlclose_cuda;\n\t}\n\n\tcuda_ops.cudaFree = dlsym(cudart_handle, \"cudaFree\");\n\tif (!cuda_ops.cudaFree) {\n\t\tFT_ERR(\"Failed to find cudaFree\");\n\t\tgoto err_dlclose_cuda;\n\t}\n\n\tcuda_ops.cudaMemset = dlsym(cudart_handle, \"cudaMemset\");\n\tif (!cuda_ops.cudaMemset) {\n\t\tFT_ERR(\"Failed to find cudaMemset\");\n\t\tgoto err_dlclose_cuda;\n\t}\n\n\tcuda_ops.cudaGetErrorName = dlsym(cudart_handle, \"cudaGetErrorName\");\n\tif (!cuda_ops.cudaGetErrorName) {\n\t\tFT_ERR(\"Failed to find cudaGetErrorName\");\n\t\tgoto err_dlclose_cuda;\n\t}\n\n\tcuda_ops.cudaGetErrorString = dlsym(cudart_handle,\n\t\t\t\t\t    \"cudaGetErrorString\");\n\tif (!cuda_ops.cudaGetErrorString) {\n\t\tFT_ERR(\"Failed to find cudaGetErrorString\");\n\t\tgoto err_dlclose_cuda;\n\t}\n\n\treturn FI_SUCCESS;\n\nerr_dlclose_cuda:\n\tdlclose(cudart_handle);\nerr:\n\treturn -FI_ENODATA;\n}\n\nint ft_cuda_cleanup(void)\n{\n\tdlclose(cudart_handle);\n\treturn FI_SUCCESS;\n}\n\nint ft_cuda_alloc(uint64_t device, void **buf, size_t size)\n{\n\tcudaError_t cuda_ret;\n\n\tcuda_ret = cuda_ops.cudaMalloc(buf, size);\n\tif (cuda_ret == cudaSuccess)\n\t\treturn FI_SUCCESS;\n\n\tCUDA_ERR(cuda_ret, \"cudaMalloc failed\");\n\n\treturn -FI_ENOMEM;\n}\n\nint ft_cuda_free(void *buf)\n{\n\tcudaError_t cuda_ret;\n\n\tcuda_ret = cuda_ops.cudaFree(buf);\n\tif (cuda_ret == cudaSuccess)\n\t\treturn FI_SUCCESS;\n\n\tCUDA_ERR(cuda_ret, \"cudaFree failed\");\n\n\treturn -FI_EIO;\n}\n\nint ft_cuda_memset(uint64_t device, void *buf, int value, size_t size)\n{\n\tcudaError_t cuda_ret;\n\n\tcuda_ret = cuda_ops.cudaMemset(buf, value, size);\n\tif (cuda_ret == cudaSuccess)\n\t\treturn FI_SUCCESS;\n\n\tCUDA_ERR(cuda_ret, \"cudaMemset failed\");\n\n\treturn -FI_EIO;\n}\n\nint ft_cuda_copy_to_hmem(uint64_t device, void *dst, const void *src,\n\t\t\t size_t size)\n{\n\tcudaError_t cuda_ret;\n\n\tcuda_ret = cuda_ops.cudaMemcpy(dst, src, size, cudaMemcpyHostToDevice);\n\tif (cuda_ret == cudaSuccess)\n\t\treturn FI_SUCCESS;\n\n\tCUDA_ERR(cuda_ret, \"cudaMemcpy failed\");\n\n\treturn -FI_EIO;\n}\n\nint ft_cuda_copy_from_hmem(uint64_t device, void *dst, const void *src,\n\t\t\t   size_t size)\n{\n\tcudaError_t cuda_ret;\n\n\tcuda_ret = cuda_ops.cudaMemcpy(dst, src, size, cudaMemcpyDeviceToHost);\n\tif (cuda_ret == cudaSuccess)\n\t\treturn FI_SUCCESS;\n\n\tCUDA_ERR(cuda_ret, \"cudaMemcpy failed\");\n\n\treturn -FI_EIO;\n}\n\n#else\n\nint ft_cuda_init(void)\n{\n\treturn -FI_ENOSYS;\n}\n\nint ft_cuda_cleanup(void)\n{\n\treturn -FI_ENOSYS;\n}\n\nint ft_cuda_alloc(uint64_t device, void **buf, size_t size)\n{\n\treturn -FI_ENOSYS;\n}\n\nint ft_cuda_free(void *buf)\n{\n\treturn -FI_ENOSYS;\n}\n\nint ft_cuda_memset(uint64_t device, void *buf, int value, size_t size)\n{\n\treturn -FI_ENOSYS;\n}\n\nint ft_cuda_copy_to_hmem(uint64_t device, void *dst, const void *src,\n\t\t\t size_t size)\n{\n\treturn -FI_ENOSYS;\n}\n\nint ft_cuda_copy_from_hmem(uint64_t device, void *dst, const void *src,\n\t\t\t   size_t size)\n{\n\treturn -FI_ENOSYS;\n}\n\n#endif /* HAVE_CUDA_RUNTIME_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-libfabric-master-7qyp67ncottp7it3zyzdyxcucafartnj/spack-src/fabtests/common/hmem_rocr.c": "/*\n * (C) Copyright 2020 Hewlett Packard Enterprise Development LP\n *\n * This software is available to you under a choice of one of two\n * licenses.  You may choose to be licensed under the terms of the GNU\n * General Public License (GPL) Version 2, available from the file\n * COPYING in the main directory of this source tree, or the\n * BSD license below:\n *\n *     Redistribution and use in source and binary forms, with or\n *     without modification, are permitted provided that the following\n *     conditions are met:\n *\n *      - Redistributions of source code must retain the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer.\n *\n *      - Redistributions in binary form must reproduce the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer in the documentation and/or other materials\n *        provided with the distribution.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n#include \"hmem.h\"\n#include \"shared.h\"\n\n#ifdef HAVE_ROCR_RUNTIME_H\n\n#include <dlfcn.h>\n#include <stdio.h>\n#include <hsa/hsa.h>\n\nstruct rocr_ops {\n\thsa_status_t (*hsa_memory_copy)(void *dst, const void *src,\n\t\t\t\t\tsize_t size);\n\thsa_status_t (*hsa_init)(void);\n\thsa_status_t (*hsa_shut_down)(void);\n\thsa_status_t (*hsa_status_string)(hsa_status_t status,\n\t\t\t\t\t  const char **status_string);\n\thsa_status_t (*hsa_agent_get_info)(hsa_agent_t agent,\n\t\t\t\t\t   hsa_agent_info_t attribute,\n\t\t\t\t\t   void *value);\n\thsa_status_t (*hsa_region_get_info)(hsa_region_t region,\n\t\t\t\t\t    hsa_region_info_t attribute,\n\t\t\t\t\t    void *value);\n\thsa_status_t (*hsa_iterate_agents)\n\t\t(hsa_status_t (*cb)(hsa_agent_t agent, void* data), void *data);\n\thsa_status_t (*hsa_agent_iterate_regions)\n\t\t(hsa_agent_t agent,\n\t\t hsa_status_t (*cb)(hsa_region_t region, void* data),\n\t\t void *data);\n\thsa_status_t (*hsa_memory_allocate)(hsa_region_t region, size_t size,\n\t\t\t\t\t    void **ptr);\n\thsa_status_t (*hsa_memory_free)(void *ptr);\n\thsa_status_t (*hsa_amd_memory_fill)(void* ptr, uint32_t value,\n\t\t\t\t\t    size_t count);\n};\n\nstatic struct rocr_ops rocr_ops;\nstatic void *rocr_handle;\n\nstatic const char *hsa_status_to_string(hsa_status_t status)\n{\n\tconst char *str;\n\thsa_status_t hsa_ret;\n\n\thsa_ret = rocr_ops.hsa_status_string(status, &str);\n\tif (hsa_ret != HSA_STATUS_SUCCESS)\n\t\treturn \"unknown error\";\n\n\treturn str;\n}\n\n#define ROCR_ERR(err, fmt, ...) \\\n\tFT_ERR(fmt \": %s\", ##__VA_ARGS__, hsa_status_to_string(err))\n\nstatic hsa_agent_t gpu_agent;\nstatic hsa_region_t gpu_region;\n\nstatic hsa_status_t agent_cb(hsa_agent_t agent, void *data)\n{\n\thsa_status_t hsa_ret;\n\thsa_device_type_t hsa_dev_type;\n\n\thsa_ret = rocr_ops.hsa_agent_get_info(agent, HSA_AGENT_INFO_DEVICE,\n\t\t\t\t\t      (void *) &hsa_dev_type);\n\n\tif (hsa_ret == HSA_STATUS_SUCCESS &&\n\t    hsa_dev_type == HSA_DEVICE_TYPE_GPU) {\n\t\tgpu_agent = agent;\n\t\treturn HSA_STATUS_INFO_BREAK;\n\t}\n\n\treturn hsa_ret;\n}\n\nstatic hsa_status_t region_cb(hsa_region_t region, void *data)\n{\n\thsa_status_t hsa_ret;\n\thsa_region_segment_t hsa_segment;\n\n\thsa_ret = rocr_ops.hsa_region_get_info(region, HSA_REGION_INFO_SEGMENT,\n\t\t\t\t\t       &hsa_segment);\n\n\tif (hsa_ret == HSA_STATUS_SUCCESS &&\n\t    hsa_segment == HSA_REGION_SEGMENT_GLOBAL) {\n\t\tgpu_region = region;\n\t\treturn HSA_STATUS_INFO_BREAK;\n\t}\n\n\treturn hsa_ret;\n}\n\nint ft_rocr_init(void)\n{\n\thsa_status_t hsa_ret;\n\n\trocr_handle = dlopen(\"libhsa-runtime64.so\", RTLD_NOW);\n\tif (!rocr_handle) {\n\t\tFT_ERR(\"Failed to dlopen libhsa-runtime64.so\");\n\t\tgoto err;\n\t}\n\n\trocr_ops.hsa_memory_copy = dlsym(rocr_handle, \"hsa_memory_copy\");\n\tif (!rocr_ops.hsa_memory_copy) {\n\t\tFT_ERR(\"Failed to find hsa_memory_copy\");\n\t\tgoto err_dlclose_rocr;\n\t}\n\n\trocr_ops.hsa_init = dlsym(rocr_handle, \"hsa_init\");\n\tif (!rocr_ops.hsa_init) {\n\t\tFT_ERR(\"Failed to find hsa_init\");\n\t\tgoto err_dlclose_rocr;\n\t}\n\n\trocr_ops.hsa_shut_down = dlsym(rocr_handle, \"hsa_shut_down\");\n\tif (!rocr_ops.hsa_shut_down) {\n\t\tFT_ERR(\"Failed to find hsa_shut_down\");\n\t\tgoto err_dlclose_rocr;\n\t}\n\n\trocr_ops.hsa_status_string = dlsym(rocr_handle, \"hsa_status_string\");\n\tif (!rocr_ops.hsa_status_string) {\n\t\tFT_ERR(\"Failed to find hsa_status_string\");\n\t\tgoto err_dlclose_rocr;\n\t}\n\n\trocr_ops.hsa_agent_get_info = dlsym(rocr_handle, \"hsa_agent_get_info\");\n\tif (!rocr_ops.hsa_agent_get_info) {\n\t\tFT_ERR(\"Failed to find hsa_agent_get_info\");\n\t\tgoto err_dlclose_rocr;\n\t}\n\n\trocr_ops.hsa_region_get_info = dlsym(rocr_handle,\n\t\t\t\t\t     \"hsa_region_get_info\");\n\tif (!rocr_ops.hsa_region_get_info) {\n\t\tFT_ERR(\"Failed to find hsa_region_get_info\");\n\t\tgoto err_dlclose_rocr;\n\t}\n\n\trocr_ops.hsa_iterate_agents = dlsym(rocr_handle, \"hsa_iterate_agents\");\n\tif (!rocr_ops.hsa_iterate_agents) {\n\t\tFT_ERR(\"Failed to find hsa_iterate_agents\");\n\t\tgoto err_dlclose_rocr;\n\t}\n\n\trocr_ops.hsa_agent_iterate_regions =\n\t\tdlsym(rocr_handle, \"hsa_agent_iterate_regions\");\n\tif (!rocr_ops.hsa_agent_iterate_regions) {\n\t\tFT_ERR(\"Failed to find hsa_agent_iterate_regions\");\n\t\tgoto err_dlclose_rocr;\n\t}\n\n\trocr_ops.hsa_memory_allocate =\n\t\tdlsym(rocr_handle, \"hsa_memory_allocate\");\n\tif (!rocr_ops.hsa_memory_allocate) {\n\t\tFT_ERR(\"Failed to find hsa_memory_allocate\");\n\t\tgoto err_dlclose_rocr;\n\t}\n\n\trocr_ops.hsa_memory_free = dlsym(rocr_handle, \"hsa_memory_free\");\n\tif (!rocr_ops.hsa_memory_free) {\n\t\tFT_ERR(\"Failed to find hsa_memory_free\");\n\t\tgoto err_dlclose_rocr;\n\t}\n\n\trocr_ops.hsa_amd_memory_fill = dlsym(rocr_handle,\n\t\t\t\t\t     \"hsa_amd_memory_fill\");\n\tif (!rocr_ops.hsa_amd_memory_fill) {\n\t\tFT_ERR(\"Failed to find hsa_amd_memory_fill\");\n\t\tgoto err_dlclose_rocr;\n\t}\n\n\thsa_ret = rocr_ops.hsa_init();\n\tif (hsa_ret != HSA_STATUS_SUCCESS) {\n\t\tROCR_ERR(hsa_ret, \"hsa_init failed\");\n\t\tgoto err_dlclose_rocr;\n\t}\n\n\thsa_ret = rocr_ops.hsa_iterate_agents(agent_cb, NULL);\n\tif (hsa_ret != HSA_STATUS_INFO_BREAK) {\n\t\tFT_ERR(\"Failed to find GPU agent\");\n\t\tgoto err_dlclose_rocr;\n\t}\n\n\thsa_ret = rocr_ops.hsa_agent_iterate_regions(gpu_agent, region_cb,\n\t\t\t\t\t\t     NULL);\n\tif (hsa_ret != HSA_STATUS_INFO_BREAK) {\n\t\tFT_ERR(\"Failed to find GPU region\");\n\t\tgoto err_dlclose_rocr;\n\t}\n\n\treturn FI_SUCCESS;\n\nerr_dlclose_rocr:\n\tdlclose(rocr_handle);\nerr:\n\treturn -FI_ENODATA;\n}\n\nint ft_rocr_cleanup(void)\n{\n\thsa_status_t hsa_ret;\n\n\thsa_ret = rocr_ops.hsa_shut_down();\n\tif (hsa_ret != HSA_STATUS_SUCCESS) {\n\t\tROCR_ERR(hsa_ret, \"hsa_init failed\");\n\t\treturn -FI_ENODATA;\n\t}\n\n\tdlclose(rocr_handle);\n\n\treturn FI_SUCCESS;\n}\n\nint ft_rocr_alloc(uint64_t device, void **buf, size_t size)\n{\n\thsa_status_t hsa_ret;\n\n\thsa_ret = rocr_ops.hsa_memory_allocate(gpu_region, size, buf);\n\tif (hsa_ret == HSA_STATUS_SUCCESS)\n\t\treturn FI_SUCCESS;\n\n\tROCR_ERR(hsa_ret, \"hsa_memory_allocate failed\");\n\n\treturn -FI_ENOMEM;\n}\n\nint ft_rocr_free(void *buf)\n{\n\thsa_status_t hsa_ret;\n\n\thsa_ret = rocr_ops.hsa_memory_free(buf);\n\tif (hsa_ret == HSA_STATUS_SUCCESS)\n\t\treturn FI_SUCCESS;\n\n\tROCR_ERR(hsa_ret, \"hsa_memory_free failed\");\n\n\treturn -FI_EIO;\n}\n\n#define ROCR_MEM_FILL_BYTE_ALIGNMENT 4U\n\nint ft_rocr_memset(uint64_t device, void *buf, int value, size_t size)\n{\n\tunsigned char set_value = value;\n\tvoid *mem_fill_ptr;\n\tsize_t mem_fill_size;\n\tuint32_t mem_fill_value;\n\thsa_status_t hsa_ret;\n\tunsigned char *ptr = buf;\n\tint ret;\n\n\t/* Determine if ROCR memory fill can be used to set device memory. ROCR\n\t * memory fill requires 4-byte alignment.\n\t */\n\tmem_fill_ptr = (void *) ALIGN((uintptr_t) buf,\n\t\t\t\t      ROCR_MEM_FILL_BYTE_ALIGNMENT);\n\n\t/* Use ROCR memory copy to fill the start of the buffer until the buffer\n\t * is correctly aligned.\n\t */\n\twhile (ptr != mem_fill_ptr && size > 0) {\n\t\tret = ft_rocr_memcpy(device, ptr, &set_value, sizeof(*ptr));\n\t\tif (ret != FI_SUCCESS)\n\t\t\treturn ret;\n\n\t\tsize--;\n\t\tptr++;\n\t}\n\n\t/* Use ROCR memory fill to fill the middle of the buffer. */\n\tif (size >= ROCR_MEM_FILL_BYTE_ALIGNMENT) {\n\t\tmem_fill_size = ALIGN_DOWN(size, ROCR_MEM_FILL_BYTE_ALIGNMENT);\n\n\t\tmemset(&mem_fill_value, set_value, sizeof(mem_fill_value));\n\n\t\thsa_ret = rocr_ops.hsa_amd_memory_fill(mem_fill_ptr,\n\t\t\t\t\t\t       mem_fill_value,\n\t\t\t\t\t\t       mem_fill_size /\n\t\t\t\t\t\t       ROCR_MEM_FILL_BYTE_ALIGNMENT);\n\t\tif (hsa_ret != HSA_STATUS_SUCCESS) {\n\t\t\tROCR_ERR(hsa_ret, \"hsa_amd_memory_fill failed\");\n\t\t\treturn -FI_EIO;\n\t\t}\n\n\t\tsize -= mem_fill_size;\n\t\tptr += mem_fill_size;\n\t}\n\n\t/* Use ROCR memory copy to fill the end of the buffer. */\n\twhile (size > 0) {\n\t\tret = ft_rocr_memcpy(device, ptr, &set_value, sizeof(*ptr));\n\t\tif (ret != FI_SUCCESS)\n\t\t\treturn ret;\n\n\t\tsize--;\n\t\tptr++;\n\t}\n\n\treturn FI_SUCCESS;\n}\n\nint ft_rocr_memcpy(uint64_t device, void *dst, const void *src, size_t size)\n{\n\thsa_status_t hsa_ret;\n\n\thsa_ret = rocr_ops.hsa_memory_copy(dst, src, size);\n\tif (hsa_ret == HSA_STATUS_SUCCESS)\n\t\treturn FI_SUCCESS;\n\n\tROCR_ERR(hsa_ret, \"hsa_memory_copy failed\");\n\n\treturn -FI_EIO;\n}\n\n#else\n\nint ft_rocr_init(void)\n{\n\treturn -FI_ENOSYS;\n}\n\nint ft_rocr_cleanup(void)\n{\n\treturn -FI_ENOSYS;\n}\n\nint ft_rocr_alloc(uint64_t device, void **buf, size_t size)\n{\n\treturn -FI_ENOSYS;\n}\n\nint ft_rocr_free(void *buf)\n{\n\treturn -FI_ENOSYS;\n}\n\nint ft_rocr_memset(uint64_t device, void *buf, int value, size_t size)\n{\n\treturn -FI_ENOSYS;\n}\n\nint ft_rocr_memcpy(uint64_t device, void *dst, const void *src, size_t size)\n{\n\treturn -FI_ENOSYS;\n}\n\n#endif /* HAVE_ROCR_RUNTIME_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-libfabric-master-7qyp67ncottp7it3zyzdyxcucafartnj/spack-src/contrib/cray/Jenkinsfile.verbs": "// Copyright (c) 2018. Cray Inc. All rights reserved.\n// Libfabric Verbs provider Jenkins Pipeline file\n\n@Library(['CrayNetworkCI@master', 'dst-shared@master']) _\n\nif (!isBuildable()) {\n    echo \"build request is not valid, skipping build\"\n    currentBuild.result = 'SUCCESS'\n    return\n}\n\npipeline {\n    options {\n        // Generic build options\n        timeout (time: 30, unit: 'MINUTES')\n        buildDiscarder(logRotator(numToKeepStr: '15'))\n\n        // Build options\n        disableConcurrentBuilds()\n        timestamps()\n        skipStagesAfterUnstable()\n    }\n    agent {\n        node {\n            label 'wham'\n        }\n    }\n    stages {\n        stage('Prologue') {\n            steps {\n                // creating git short hash\n                script {\n                    GIT_DESCRIPTION = sh(returnStdout: true, script: \"git describe --tags\").trim()\n                    LIBFABRIC_INSTALL = pwd tmp: true\n                    if (changeRequest()) {\n                        SFT_PR_ENV_VAR = 'SFT_PR=1'\n                    }\n                }\n\n                dir ('contrib/cray/bin') {\n                    // verify requirements\n                    sh './verify_requirements.sh'\n\n                    // install python environment if necessary\n                    sh './setup.sh'\n                }\n            }\n        }\n        stage('Build CUDA and ROCR') {\n            options {\n                timeout (time: 5, unit: 'MINUTES')\n            }\n            environment {\n                LD_LIBRARY_PATH = \"$ROCR_INSTALL_PATH/lib:$CUDA_INSTALL_PATH/lib64:$LD_LIBRARY_PATH\"\n            }\n            steps {\n                sh './autogen.sh'\n                sh \"\"\"./configure --prefix=$LIBFABRIC_INSTALL --disable-memhooks-monitor \\\n                   --with-cuda=$CUDA_INSTALL_PATH --with-rocr=$ROCR_INSTALL_PATH\"\"\"\n                sh \"make -j 12\"\n                sh \"make install\"\n                dir (\"fabtests\") {\n                    sh './autogen.sh'\n                    sh \"./configure --with-libfabric=$LIBFABRIC_INSTALL --prefix=$FABTEST_PATH\"\n                    sh \"make -j12\"\n                    sh \"make -j12 install\"\n                }\n            }\n        }\n        stage(\"Verify CUDA and ROCR Build\") {\n            steps {\n                script {\n                    cuda_link_count = sh(returnStdout: true,\n                                         script: \"\"\"objdump -a -x $LIBFABRIC_INSTALL/lib/libfabric.so |\n                                                 grep NEED | grep cuda | wc -l\"\"\").trim()\n                    if (cuda_link_count != \"2\") {\n                        error(\"libfabric failed to link to CUDA\")\n                    }\n                    rocr_link_count = sh(returnStdout: true,\n                                         script: \"\"\"objdump -a -x $LIBFABRIC_INSTALL/lib/libfabric.so |\n                                                 grep NEED | grep hsa | wc -l\"\"\").trim()\n                    if (rocr_link_count != \"1\") {\n                        error(\"libfabric failed to link to ROCR\")\n                    }\n                }\n            }\n        }\n        stage('Build CUDA and ROCR dlopen') {\n            options {\n                timeout (time: 5, unit: 'MINUTES')\n            }\n            steps {\n                sh './autogen.sh'\n                sh \"\"\"./configure --prefix=$LIBFABRIC_INSTALL --disable-memhooks-monitor \\\n                   --with-cuda=$CUDA_INSTALL_PATH --enable-cuda-dlopen \\\n                   --with-rocr=$ROCR_INSTALL_PATH --enable-rocr-dlopen\"\"\"\n                sh \"make -j 12\"\n                sh \"make install\"\n                dir (\"fabtests\") {\n                    sh './autogen.sh'\n                    sh \"./configure --with-libfabric=$LIBFABRIC_INSTALL --prefix=$FABTEST_PATH\"\n                    sh \"make -j12\"\n                    sh \"make -j12 install\"\n                }\n            }\n        }\n        stage(\"Verify CUDA and ROCR Build dlopen\") {\n            steps {\n                script {\n                    cuda_link_count = sh(returnStdout: true,\n                                         script: \"\"\"objdump -a -x $LIBFABRIC_INSTALL/lib/libfabric.so |\n                                                 grep NEED | grep cuda | wc -l\"\"\").trim()\n                    if (cuda_link_count != \"0\") {\n                        error(\"libfabric failed to link to CUDA\")\n                    }\n                    rocr_link_count = sh(returnStdout: true,\n                                         script: \"\"\"objdump -a -x $LIBFABRIC_INSTALL/lib/libfabric.so |\n                                                 grep NEED | grep hsa | wc -l\"\"\").trim()\n                    if (rocr_link_count != \"0\") {\n                        error(\"libfabric failed to link to ROCR\")\n                    }\n                }\n            }\n        }\n        stage('Build LTU') {\n            options {\n                timeout (time: 5, unit: 'MINUTES')\n            }\n            steps {\n                dir ('libfabric-test-utils') {\n                    deleteDir ()\n                }\n                dir ('libfabric-test-utils') {\n                    git url: \"ssh://${env.LTU_GIT_REPO}\", credentialsId: 'jenkins-nw-cje2-sshkey', branch: \"${env.SRC_GIT_BRANCH}\"\n                    sh \"git remote -v\"\n                    script {\n                        LTU_VERSION = sh(returnStdout: true, script: \"cat .version\").trim()\n                        GIT_SHORT_COMMIT = sh(returnStdout: true, script: \"git log -n 1 --pretty=format:'%h'\").trim()\n                        LTU_VERSION = \"${LTU_VERSION}\" + \"_${GIT_SHORT_COMMIT}\"\n                    }\n                    echo \"*** Building libfabric-test-utils, Version: ${LTU_VERSION} ***\"\n                    sh \"./autogen.sh\"\n                    sh \"\"\"./configure --prefix=${LIBFABRIC_INSTALL} --with-libfabric=${LIBFABRIC_INSTALL} \\\n                                      --with-nvidia=${CUDA_INSTALL_PATH} --with-amd=${ROCR_INSTALL_PATH} \\\n                                      --with-pmi=${PMI_INSTALL_PATH} --with-pmi_include=${PMI_INCLUDE_PATH} \\\n                                      --with-ltu-build-string=\\\"libfabric-test-utils-${LTU_VERSION}\\\"\"\"\"\n                    sh \"make -j 10\"\n                    sh \"make install\"\n                }\n            }\n        }\n        stage('Build SFT') {\n            options {\n                timeout (time: 5, unit: 'MINUTES')\n            }\n            steps {\n                dir ('libfabric-sft') {\n                    deleteDir ()\n                }\n                dir ('libfabric-sft') {\n                    git url: \"ssh://${env.SFT_GIT_REPO}\", credentialsId: 'jenkins-nw-cje2-sshkey', branch: \"${env.SRC_GIT_BRANCH}\"\n                    sh \"git remote -v\"\n                    script {\n                        SFT_VERSION = sh(returnStdout: true, script: \"cat .version\").trim()\n                        GIT_SHORT_COMMIT = sh(returnStdout: true, script: \"git log -n 1 --pretty=format:'%h'\").trim()\n                        SFT_VERSION = \"${SFT_VERSION}\" + \"_${GIT_SHORT_COMMIT}\"\n                    }\n                    echo \"*** Building libfabric-sft, Version: ${SFT_VERSION} ***\"\n                    sh \"./autogen.sh\"\n                    sh \"\"\"./configure --prefix=${LIBFABRIC_INSTALL} --with-libfabric=${LIBFABRIC_INSTALL} \\\n                                      --with-libltu=${LIBFABRIC_INSTALL} \\\n                                      --with-sft-build-string=\\\"libfabric-sft-${LTU_VERSION}\\\"\"\"\"\n                    sh \"make -j 10\"\n                    sh \"make install\"\n                }\n            }\n        }\n        stage('Test') {\n            environment {\n                LD_LIBRARY_PATH = \"$LIBFABRIC_INSTALL/lib:$LD_LIBRARY_PATH\"\n                MPIR_CVAR_OFI_USE_PROVIDER = 'verbs;ofi_rxm'\n                LIBFABRIC_INSTALL_PATH = \"$LIBFABRIC_INSTALL\"\n                SFT_BIN = \"${LIBFABRIC_INSTALL + '/bin'}\"\n                SFT_MAX_JOB_TIME = '3'\n                SFT_NUM_JOBS = '6'\n                SFT_PROVIDER = 'verbs;ofi_rxm'\n                SFT_BASELINE_DIR = \"contrib/cray\"\n                SFT_BASELINE_RESULTS_FILE = 'sft_test_results_baseline.txt'\n                SFT_PREVIOUS_BASELINE_RESULTS = 'sft_test_results_baseline.txt'\n                SFT_TEST_CMDS = 'sft_test_commands'\n                SFT_TEST_RESULTS = '_test_results.xml'\n                SFT_TEST_RESULTS_EXPECTED = 'expected_'\n                SFT_TEST_RESULTS_PREFIX = 'BUILD_'\n                SFT_TEST_RESULTS_CI = 'sft_ci_results.yaml'\n                FI_VERBS_MIN_RNR_TIMER= '4'\n            }\n            options {\n                timeout (time: 22, unit: 'MINUTES')\n            }\n            parallel {\n                stage('Unit tests') {\n                    steps {\n                        echo 'placeholder'\n                    }\n                }\n                stage('Smoke tests') {\n                    steps {\n                        tee ('smoketests.tap') {\n                            sh '${BATS_INSTALL_PATH}/bats -t contrib/cray/bats/smoketests.bats'\n                        }\n                    }\n                    post {\n                        always {\n                            sh \"\"\"contrib/cray/bin/parse_logfiles.sh \\\\\n                                    -r smoketests.tap \\\\\n                                    -w smoketests.xml \\\\\n                                    tap simple.smoketests simple\"\"\"\n                        }\n                    }\n                }\n                stage('Functional Tests: RC') {\n                    steps {\n                        tee ('fabtests-rc.log') {\n                            sh 'srun -n 2 --ntasks-per-node=1 contrib/cray/bin/fabtest_wrapper.sh -p ${FABTEST_PATH}/bin -v -T 120'\n                        }\n                        tee ('ubertests-rc.log') {\n                            sh 'srun -n 2 --ntasks-per-node=1 contrib/cray/bin/fabtest_wrapper.sh -p ${FABTEST_PATH}/bin -vvv -T 120 -t complex -u all'\n                        }\n                    }\n                    post {\n                        always {\n                            sh \"\"\"contrib/cray/bin/parse_logfiles.sh \\\\\n                                    -r fabtests-rc.log \\\\\n                                    -w fabtests-rc.xml \\\\\n                                    fabtests \\\\\n                                    functional.fabtests.rc.quick \\\\\n                                    functional\"\"\"\n\n                            sh \"\"\"contrib/cray/bin/parse_logfiles.sh \\\\\n                                    -r ubertests-rc.log \\\\\n                                    -w ubertests-rc.xml \\\\\n                                    fabtests \\\\\n                                    functional.fabtests.rc.uber \\\\\n                                    functional\"\"\"\n                        }\n                    }\n\t\t}\n                stage('Functional Tests: XRC') {\n                    steps {\n                        tee ('fabtests-xrc.log') {\n                            sh 'srun -n 2 --ntasks-per-node=1 contrib/cray/bin/fabtest_wrapper.sh -p ${FABTEST_PATH}/bin -v -T 120 -e FI_VERBS_PREFER_XRC=1 -e FI_OFI_RXM_USE_SRX=1'\n                        }\n                        tee ('ubertests-xrc.log') {\n                            sh 'srun -n 2 --ntasks-per-node=1 contrib/cray/bin/fabtest_wrapper.sh -p ${FABTEST_PATH}/bin -vvv -T 120 -t complex -u all -e FI_VERBS_PREFER_XRC=1 -e FI_OFI_RXM_USE_SRX=1'\n                        }\n                    }\n                    post {\n                        always {\n                            sh \"\"\"contrib/cray/bin/parse_logfiles.sh \\\\\n                                    -r fabtests-xrc.log \\\\\n                                    -w fabtests-xrc.xml \\\\\n                                    fabtests \\\\\n                                    functional.fabtests.xrc.quick \\\\\n                                    functional\"\"\"\n\n                            sh \"\"\"contrib/cray/bin/parse_logfiles.sh \\\\\n                                    -r ubertests-xrc.log \\\\\n                                    -w ubertests-xrc.xml \\\\\n                                    fabtests \\\\\n                                    functional.fabtests.xrc.uber \\\\\n                                    functional\"\"\"\n                        }\n                    }\n                }\n                stage('SFT tests: RC') {\n                    environment {\n                        SFT_ADD_ARGS = \"--additional-args ' '\"\n                        SFT_TEST_RESULTS_SUBDIR = \"sft_test_results/RC\"\n                        SFT_TEST_RESULTS_DIR = \"${env.WORKSPACE}\" + \"/\" + \"${env.SFT_TEST_RESULTS_SUBDIR}\"\n                    }\n                    steps {\n                        sh \"mkdir -p ${SFT_TEST_RESULTS_DIR}\"\n                        timeout (time: 20, unit: 'MINUTES') {\n                            // run the test\n                            script {\n                                try {\n                                    dir (\"${SFT_BIN}\") {\n                                        sh \"\"\"\n                                            ${SFT_PR_ENV_VAR} ./ci-all.sh \\\\\n                                                --provider '${SFT_PROVIDER}' \\\\\n                                                -L ${SFT_TEST_RESULTS_DIR} \\\\\n                                                --num-jobs ${SFT_NUM_JOBS} \\\\\n                                                --max-job-time ${SFT_MAX_JOB_TIME} \\\\\n                                                --output-cmds ${SFT_TEST_RESULTS_DIR}/${SFT_TEST_CMDS} \\\\\n                                                --results-file ${SFT_TEST_RESULTS_DIR}/${SFT_TEST_RESULTS_CI} \\\\\n                                                ${SFT_ADD_ARGS}\n                                        \"\"\"\n                                    }\n                                } catch (exc) {\n                                    echo 'failed test, ignore result for now'\n                                }\n                            }\n                        }\n                    }\n                    post {\n                        always {\n                            sh \"\"\"\n                                cp  ./${SFT_BASELINE_DIR}/${SFT_BASELINE_RESULTS_FILE} ${SFT_TEST_RESULTS_DIR}/${SFT_TEST_RESULTS_EXPECTED}${SFT_BASELINE_RESULTS_FILE}\n                                ${SFT_BIN}/sft_parse_test_results.pm -b ${SFT_TEST_RESULTS_EXPECTED}${SFT_BASELINE_RESULTS_FILE} -d ${SFT_TEST_RESULTS_DIR} -o sft_RMA${SFT_TEST_RESULTS} -p \"TR_RMA\"\n                                ${SFT_BIN}/sft_parse_test_results.pm -b ${SFT_TEST_RESULTS_EXPECTED}${SFT_BASELINE_RESULTS_FILE} -d ${SFT_TEST_RESULTS_DIR} -o sft_TAGGED${SFT_TEST_RESULTS} -p \"TR_TAGGED\"\n                                ${SFT_BIN}/sft_parse_test_results.pm -b ${SFT_TEST_RESULTS_EXPECTED}${SFT_BASELINE_RESULTS_FILE} -d ${SFT_TEST_RESULTS_DIR} -o sft_MESSAGE${SFT_TEST_RESULTS} -p \"TR_MESSAGE\"\n                                ${SFT_BIN}/sft_parse_test_results.pm -b ${SFT_TEST_RESULTS_EXPECTED}${SFT_BASELINE_RESULTS_FILE} -d ${SFT_TEST_RESULTS_DIR} -o sft_AMO${SFT_TEST_RESULTS} -p \"TR_AMO\"\n                                gzip -r ${SFT_TEST_RESULTS_DIR}\n                                gunzip ${SFT_TEST_RESULTS_DIR}/sft_*${SFT_TEST_RESULTS}.gz\n                                gunzip ${SFT_TEST_RESULTS_DIR}/${SFT_TEST_RESULTS_EXPECTED}${SFT_BASELINE_RESULTS_FILE}\n                            \"\"\"\n                            // archive the results\n                            archiveArtifacts artifacts: \"${env.SFT_TEST_RESULTS_SUBDIR}/*\"\n                        }\n                    }\n                }\n                stage('SFT tests: XRC') {\n                    environment {\n                        SFT_ADD_ARGS = \"--additional-args '--use-xrc'\"\n                        SFT_TEST_RESULTS_SUBDIR = \"sft_test_results/XRC\"\n                        SFT_TEST_RESULTS_DIR = \"${env.WORKSPACE}\" + \"/\" + \"${env.SFT_TEST_RESULTS_SUBDIR}\"\n                    }\n                    steps {\n                        sh \"mkdir -p ${SFT_TEST_RESULTS_DIR}\"\n                        timeout (time: 20, unit: 'MINUTES') {\n                            // run the test\n                            script {\n                                try {\n                                    dir (\"${SFT_BIN}\") {\n                                        sh \"\"\"\n                                            ${SFT_PR_ENV_VAR} ./ci-all.sh \\\\\n                                                --provider '${SFT_PROVIDER}' \\\\\n                                                -L ${SFT_TEST_RESULTS_DIR} \\\\\n                                                --num-jobs ${SFT_NUM_JOBS} \\\\\n                                                --max-job-time ${SFT_MAX_JOB_TIME} \\\\\n                                                --output-cmds ${SFT_TEST_RESULTS_DIR}/${SFT_TEST_CMDS} \\\\\n                                                --results-file ${SFT_TEST_RESULTS_DIR}/${SFT_TEST_RESULTS_CI} \\\\\n                                                ${SFT_ADD_ARGS}\n                                        \"\"\"\n                                    }\n                                } catch (exc) {\n                                    echo 'failed test, ignore result for now'\n                                }\n                            }\n                        }\n                    }\n                    post {\n                        always {\n                            sh \"\"\"\n                                cp  ./${SFT_BASELINE_DIR}/${SFT_BASELINE_RESULTS_FILE} ${SFT_TEST_RESULTS_DIR}/${SFT_TEST_RESULTS_EXPECTED}${SFT_BASELINE_RESULTS_FILE}\n                                ${SFT_BIN}/sft_parse_test_results.pm -b ${SFT_TEST_RESULTS_EXPECTED}${SFT_BASELINE_RESULTS_FILE} -d ${SFT_TEST_RESULTS_DIR} -o sft_RMA${SFT_TEST_RESULTS} -p \"TR_RMA\"\n                                ${SFT_BIN}/sft_parse_test_results.pm -b ${SFT_TEST_RESULTS_EXPECTED}${SFT_BASELINE_RESULTS_FILE} -d ${SFT_TEST_RESULTS_DIR} -o sft_TAGGED${SFT_TEST_RESULTS}  -p \"TR_TAGGED\"\n                                ${SFT_BIN}/sft_parse_test_results.pm -b ${SFT_TEST_RESULTS_EXPECTED}${SFT_BASELINE_RESULTS_FILE} -d ${SFT_TEST_RESULTS_DIR} -o sft_MESSAGE${SFT_TEST_RESULTS} -p \"TR_MESSAGE\"\n                                ${SFT_BIN}/sft_parse_test_results.pm -b ${SFT_TEST_RESULTS_EXPECTED}${SFT_BASELINE_RESULTS_FILE} -d ${SFT_TEST_RESULTS_DIR} -o sft_AMO${SFT_TEST_RESULTS} -p \"TR_AMO\"\n                                gzip -r ${SFT_TEST_RESULTS_DIR}\n                                gunzip ${SFT_TEST_RESULTS_DIR}/sft_*${SFT_TEST_RESULTS}.gz\n                                gunzip ${SFT_TEST_RESULTS_DIR}/${SFT_TEST_RESULTS_EXPECTED}${SFT_BASELINE_RESULTS_FILE}\n                            \"\"\"\n                            // archive the results\n                            archiveArtifacts artifacts: \"${env.SFT_TEST_RESULTS_SUBDIR}/*\"\n                        }\n                    }\n                }\n                stage(\"System tests\") {\n                    steps {\n                        echo 'placeholder'\n                    }\n                }\n                stage(\"Applications\") {\n                    steps {\n                        tee ('omb.tap') {\n                            timeout(time: 10, unit: 'MINUTES') {\n                                sh '${BATS_INSTALL_PATH}/bats -t contrib/cray/bats/omb.bats'\n                            }\n                        }\n                        tee ('imb.tap') {\n                            timeout(time: 20, unit: 'MINUTES') {\n                                sh '${BATS_INSTALL_PATH}/bats -t contrib/cray/bats/imb.bats'\n\t\t\t    }\n\t\t\t}\n                    }\n                    post {\n                        always {\n                            sh \"\"\"contrib/cray/bin/parse_logfiles.sh \\\\\n                                    -r omb.tap \\\\\n                                    -w omb.xml \\\\\n                                    tap applications.mpi applications\"\"\"\n\n                            sh \"\"\"contrib/cray/bin/parse_logfiles.sh \\\\\n                                    -r imb.tap \\\\\n                                    -w imb.xml \\\\\n                                    tap applications.mpi applications\"\"\"\n                        }\n                    }\n                }\n            }\n            post {\n                always {\n                    step ([$class: 'XUnitPublisher',\n                       thresholds: [\n                            [$class: 'FailedThreshold', unstableThreshold: '0']],\n                            tools: [[$class: 'JUnitType', pattern: \"smoketests.xml\"]]])\n                    step ([$class: 'XUnitPublisher',\n                       thresholds: [\n                            [$class: 'FailedThreshold', unstableThreshold: '0']],\n                            tools: [[$class: 'JUnitType', pattern: \"*-rc.xml\"]]])\n                    step ([$class: 'XUnitPublisher',\n                       thresholds: [\n                            [$class: 'FailedThreshold', unstableThreshold: '0']],\n                            tools: [[$class: 'JUnitType', pattern: \"*-xrc.xml\"]]])\n                    step ([$class: 'XUnitPublisher',\n                       thresholds: [\n                            [$class: 'FailedThreshold', unstableThreshold: '0']],\n                            tools: [[$class: 'JUnitType', pattern: \"sft_test_results/RC/sft_*_test_results.xml\"]]])\n                    step ([$class: 'XUnitPublisher',\n                       thresholds: [\n                            [$class: 'FailedThreshold', unstableThreshold: '0']],\n                            tools: [[$class: 'JUnitType', pattern: \"sft_test_results/XRC/sft_*_test_results.xml\"]]])\n                    step ([$class: 'XUnitPublisher',\n                       thresholds: [\n                            [$class: 'FailedThreshold', unstableThreshold: '0']],\n                            tools: [[$class: 'JUnitType', pattern: \"omb.xml\"]]])\n                    step ([$class: 'XUnitPublisher',\n                       thresholds: [\n                            [$class: 'FailedThreshold', unstableThreshold: '0']],\n                            tools: [[$class: 'JUnitType', pattern: \"imb.xml\"]]])\n                }\n                cleanup {\n                    echo \"*** Test: Post: Cleanup: env.BRANCH_NAME: ${env.BRANCH_NAME} ***\"\n                    echo \"*** Test: Post: Cleanup: isOfiwgBuild: \" + isOfiwgBuild() + \" ***\"\n                    script {\n                        if ( isInternalBuild() ) {\n                            echo \"*** Test: Post: Cleanup: isInternalBuild: TRUE ***\"\n                        } else {\n                            echo \"*** Test: Post: Cleanup: isInternalBuild: FALSE ***\"\n                        }\n                    }\n                    echo \"*** Test: Post: Cleanup: currentBuild.currentResult: ${currentBuild.currentResult} ***\"\n                }\n            }\n        }\n        stage(\"Install Libfabric Build\") {\n            when {\n                allOf {\n                    expression { currentBuild.currentResult == 'SUCCESS' } ;\n                }\n            }\n            environment {\n                LIBFABRIC_INSTALL_PATH=\"${LIBFABRIC_BUILD_PATH + '/' + GIT_DESCRIPTION}\"\n            }\n            steps {\n                script {\n                    BUILD_LIBFABRIC = 'false'\n                    if ( isInternalBuild &&\n                        (( env.BRANCH_NAME == 'master' ) || buildingTag())) {\n                        BUILD_LIBFABRIC = 'true'\n                    } else if ( isOfiwgBuild() && ( env.BRANCH_NAME == 'master' )) {\n                        LIBFABRIC_INSTALL_PATH=\"${LIBFABRIC_BUILD_PATH + '/' + 'OFIWG_' + GIT_DESCRIPTION}\"\n                        BUILD_LIBFABRIC = 'true'\n                    }\n                    echo \"*** Install Libfabric Build: BUILD_LIBFABRIC: $BUILD_LIBFABRIC ***\"\n                    if ( BUILD_LIBFABRIC == 'true' ) {\n                        sh \"./autogen.sh\"\n                        sh \"./configure --prefix=$LIBFABRIC_INSTALL_PATH --disable-memhooks-monitor\"\n                        sh \"make -j 12\"\n                        sh \"make install\"\n                    }\n                }\n            }\n        }\n        stage(\"Deploy\") {\n            when {\n                allOf {\n                    expression { currentBuild.currentResult == 'SUCCESS' } ;\n                }\n            }\n            options {\n                timeout (time: 5, unit: 'MINUTES')\n            }\n            environment {\n                TAG_DIRECTORY = \"${LIBFABRIC_BUILD_PATH + '/tags'}\"\n            }\n            failFast true\n            parallel {\n                stage(\"Create nightly link\") {\n                    when {\n                        allOf {\n                            expression { isInternalBuild() } ;\n                            expression { env.BRANCH_NAME == 'master' }\n                        }\n                    }\n                    steps {\n                        dir (env.TAG_DIRECTORY) {\n                            sh \"rm -f nightly || true\"\n                            sh \"ln -s ../$GIT_DESCRIPTION nightly\"\n                        }\n                    }\n                }\n                stage(\"Create tagged link\") {\n                    when {\n                        allOf {\n                            expression { isInternalBuild() } ;\n                            buildingTag()\n                        }\n                    }\n                    steps {\n                        dir (env.TAG_DIRECTORY) {\n                            sh \"rm -f $BRANCH_NAME || true\"\n                            sh \"ln -s ../$GIT_DESCRIPTION $BRANCH_NAME\"\n                        }\n                    }\n                }\n                stage(\"Create upstream link\") {\n                    when {\n                        allOf {\n                            expression { isOfiwgBuild() } ;\n                            expression { env.BRANCH_NAME == 'master' }\n                        }\n                    }\n                    steps {\n                        dir (env.TAG_DIRECTORY) {\n                            sh \"rm -f upstream || true\"\n                            sh \"ln -s ../OFIWG_$GIT_DESCRIPTION upstream\"\n                        }\n                    }\n                }\n            }\n        }\n    }\n    post {\n        changed {\n            script {\n                // send email when the state of the pipeline changes\n                // only sends email to @cray.com\n\n                def emailBody = createEmail(build : currentBuild)\n                def providers = []\n                def defaultMailer = ''\n\n                if (env.BRANCH_NAME == 'master') {\n                    defaultMailer = mailingList()\n                } else {\n                    providers.add ( [$class: 'CulpritsRecipientProvider'] )\n                    providers.add ( [$class: 'RequesterRecipientProvider'] )\n                    providers.add ( [$class: 'DevelopersRecipientProvider'] )\n                }\n                emailext subject: '$DEFAULT_SUBJECT',\n                    body: emailBody,\n                    mimeType: 'text/html',\n                    recipientProviders: providers,\n                    replyTo: '$DEFAULT_REPLYTO',\n                    to: defaultMailer\n             }\n        }\n    }\n    environment {\n        ROOT_BUILD_PATH = \"/scratch/jenkins/builds\"\n        FABTEST_PATH = \"${WORKSPACE + '/installs/fabtests'}\"\n        LIBFABRIC_BUILD_PATH = \"${ROOT_BUILD_PATH + '/libfabric'}\"\n        OMB_BUILD_PATH = \"${ROOT_BUILD_PATH + '/osu-micro-benchmarks/stable/libexec/osu-micro-benchmarks/mpi'}\"\n        IMB_BUILD_PATH = \"${ROOT_BUILD_PATH + '/imb/v2019.6'}\"\n        MPICH_PATH = \"${ROOT_BUILD_PATH + '/mpich/stable'}\"\n        SFT_INSTALL_PATH = \"${ROOT_BUILD_PATH + '/libfabric-sft/stable'}\"\n        SFT_PR_ENV_VAR = 'SFT_PR=0'\n        BATS_INSTALL_PATH = \"${ROOT_BUILD_PATH + '/bats/stable/bin'}\"\n        CUDA_INSTALL_PATH = \"/scratch/opt/cuda\"\n        ROCR_INSTALL_PATH = \"/opt/rocm\"\n        PMI_INCLUDE_PATH = \"/usr/include/slurm\"\n        PMI_INSTALL_PATH = \"/usr/lib64\"\n        LTU_VERSION = \"0.0.0\"\n        SFT_VERSION = \"0.0.0\"\n        LTU_GIT_REPO = 'git@stash.us.cray.com:7999/ofi-cray/libfabric-test-utils.git'\n        SFT_GIT_REPO = 'git@stash.us.cray.com:7999/ofi-cray/libfabric-sft.git'\n        SRC_GIT_BRANCH = 'master'\n    }\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-libfabric-master-7qyp67ncottp7it3zyzdyxcucafartnj/spack-src/.git/objects/pack/pack-2227a3b943b12fe89c430d7d34f6c4ce50403286.pack",
        "/tmp/vanessa/spack-stage/spack-stage-libfabric-master-7qyp67ncottp7it3zyzdyxcucafartnj/spack-src/.git/objects/pack/pack-2227a3b943b12fe89c430d7d34f6c4ce50403286.idx"
    ],
    "total_files": 1206
}