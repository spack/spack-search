{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-libuv-1.10.0-tvkoat5vslbctz2afzq2jzqjvgrpibgh/spack-src/configure.ac": "# Copyright (c) 2013, Ben Noordhuis <info@bnoordhuis.nl>\n#\n# Permission to use, copy, modify, and/or distribute this software for any\n# purpose with or without fee is hereby granted, provided that the above\n# copyright notice and this permission notice appear in all copies.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\nAC_PREREQ(2.57)\nAC_INIT([libuv], [1.10.0], [https://github.com/libuv/libuv/issues])\nAC_CONFIG_MACRO_DIR([m4])\nm4_include([m4/libuv-extra-automake-flags.m4])\nm4_include([m4/as_case.m4])\nm4_include([m4/libuv-check-flags.m4])\nAM_INIT_AUTOMAKE([-Wall -Werror foreign subdir-objects] UV_EXTRA_AUTOMAKE_FLAGS)\nAC_CANONICAL_HOST\nAC_ENABLE_SHARED\nAC_ENABLE_STATIC\nAC_PROG_CC\nAM_PROG_CC_C_O\nAS_IF([AS_CASE([$host_os],[openedition*],  [false], [true])], [\n  CC_CHECK_CFLAGS_APPEND([-pedantic])\n])\nCC_FLAG_VISIBILITY #[-fvisibility=hidden]\nCC_CHECK_CFLAGS_APPEND([-g])\nCC_CHECK_CFLAGS_APPEND([-std=gnu89])\nCC_CHECK_CFLAGS_APPEND([-Wall])\nCC_CHECK_CFLAGS_APPEND([-Wextra])\nCC_CHECK_CFLAGS_APPEND([-Wno-unused-parameter])\n# AM_PROG_AR is not available in automake v0.11 but it's essential in v0.12.\nm4_ifdef([AM_PROG_AR], [AM_PROG_AR])\n# autoconf complains if AC_PROG_LIBTOOL precedes AM_PROG_AR.\nAC_PROG_LIBTOOL\nm4_ifdef([AM_SILENT_RULES], [AM_SILENT_RULES([yes])])\nLT_INIT\n# TODO(bnoordhuis) Check for -pthread vs. -pthreads\nAC_CHECK_LIB([dl], [dlopen])\nAC_CHECK_LIB([kstat], [kstat_lookup])\nAC_CHECK_LIB([kvm], [kvm_open])\nAC_CHECK_LIB([nsl], [gethostbyname])\nAC_CHECK_LIB([perfstat], [perfstat_cpu])\nAC_CHECK_LIB([pthread], [pthread_mutex_init])\nAC_CHECK_LIB([rt], [clock_gettime])\nAC_CHECK_LIB([sendfile], [sendfile])\nAC_CHECK_LIB([socket], [socket])\nAC_SYS_LARGEFILE\nAM_CONDITIONAL([AIX],      [AS_CASE([$host_os],[aix*],          [true], [false])])\nAM_CONDITIONAL([ANDROID],  [AS_CASE([$host_os],[linux-android*],[true], [false])])\nAM_CONDITIONAL([DARWIN],   [AS_CASE([$host_os],[darwin*],       [true], [false])])\nAM_CONDITIONAL([DRAGONFLY],[AS_CASE([$host_os],[dragonfly*],    [true], [false])])\nAM_CONDITIONAL([FREEBSD],  [AS_CASE([$host_os],[*freebsd*],     [true], [false])])\nAM_CONDITIONAL([LINUX],    [AS_CASE([$host_os],[linux*],        [true], [false])])\nAM_CONDITIONAL([NETBSD],   [AS_CASE([$host_os],[netbsd*],       [true], [false])])\nAM_CONDITIONAL([OPENBSD],  [AS_CASE([$host_os],[openbsd*],      [true], [false])])\nAM_CONDITIONAL([OS390],    [AS_CASE([$host_os],[openedition*],  [true], [false])])\nAM_CONDITIONAL([SUNOS],    [AS_CASE([$host_os],[solaris*],      [true], [false])])\nAM_CONDITIONAL([WINNT],    [AS_CASE([$host_os],[mingw*],        [true], [false])])\nAS_CASE([$host_os],[mingw*], [\n    LIBS=\"$LIBS -lws2_32 -lpsapi -liphlpapi -lshell32 -luserenv -luser32\"\n])\nAC_CHECK_HEADERS([sys/ahafs_evProds.h])\nAC_CHECK_PROG(PKG_CONFIG, pkg-config, yes)\nAM_CONDITIONAL([HAVE_PKG_CONFIG], [test \"x$PKG_CONFIG\" != \"x\"])\nAS_IF([test \"x$PKG_CONFIG\" != \"x\"], [\n    AC_CONFIG_FILES([libuv.pc])\n])\nAC_CONFIG_FILES([Makefile])\nAC_OUTPUT\n",
        "/tmp/vanessa/spack-stage/spack-stage-libuv-1.10.0-tvkoat5vslbctz2afzq2jzqjvgrpibgh/spack-src/src/win/dl.c": "/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\n#include \"uv.h\"\n#include \"internal.h\"\n\nstatic int uv__dlerror(uv_lib_t* lib, int errorno);\n\n\nint uv_dlopen(const char* filename, uv_lib_t* lib) {\n  WCHAR filename_w[32768];\n\n  lib->handle = NULL;\n  lib->errmsg = NULL;\n\n  if (!MultiByteToWideChar(CP_UTF8,\n                           0,\n                           filename,\n                           -1,\n                           filename_w,\n                           ARRAY_SIZE(filename_w))) {\n    return uv__dlerror(lib, GetLastError());\n  }\n\n  lib->handle = LoadLibraryExW(filename_w, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);\n  if (lib->handle == NULL) {\n    return uv__dlerror(lib, GetLastError());\n  }\n\n  return 0;\n}\n\n\nvoid uv_dlclose(uv_lib_t* lib) {\n  if (lib->errmsg) {\n    LocalFree((void*)lib->errmsg);\n    lib->errmsg = NULL;\n  }\n\n  if (lib->handle) {\n    /* Ignore errors. No good way to signal them without leaking memory. */\n    FreeLibrary(lib->handle);\n    lib->handle = NULL;\n  }\n}\n\n\nint uv_dlsym(uv_lib_t* lib, const char* name, void** ptr) {\n  *ptr = (void*) GetProcAddress(lib->handle, name);\n  return uv__dlerror(lib, *ptr ? 0 : GetLastError());\n}\n\n\nconst char* uv_dlerror(const uv_lib_t* lib) {\n  return lib->errmsg ? lib->errmsg : \"no error\";\n}\n\n\nstatic void uv__format_fallback_error(uv_lib_t* lib, int errorno){\n  DWORD_PTR args[1] = { (DWORD_PTR) errorno };\n  LPSTR fallback_error = \"error: %1!d!\";\n\n  FormatMessageA(FORMAT_MESSAGE_FROM_STRING |\n                 FORMAT_MESSAGE_ARGUMENT_ARRAY |\n                 FORMAT_MESSAGE_ALLOCATE_BUFFER,\n                 fallback_error, 0, 0,\n                 (LPSTR) &lib->errmsg,\n                 0, (va_list*) args);\n}\n\n\n\nstatic int uv__dlerror(uv_lib_t* lib, int errorno) {\n  DWORD res;\n\n  if (lib->errmsg) {\n    LocalFree((void*)lib->errmsg);\n    lib->errmsg = NULL;\n  }\n\n  if (errorno) {\n    res = FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER |\n                         FORMAT_MESSAGE_FROM_SYSTEM |\n                         FORMAT_MESSAGE_IGNORE_INSERTS, NULL, errorno,\n                         MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),\n                         (LPSTR) &lib->errmsg, 0, NULL);\n    if (!res && GetLastError() == ERROR_MUI_FILE_NOT_FOUND) {\n      res = FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER |\n                           FORMAT_MESSAGE_FROM_SYSTEM |\n                           FORMAT_MESSAGE_IGNORE_INSERTS, NULL, errorno,\n                           0, (LPSTR) &lib->errmsg, 0, NULL);\n    }\n\n    if (!res) {\n      uv__format_fallback_error(lib, errorno);\n    }\n  }\n\n  return errorno ? -1 : 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-libuv-1.10.0-tvkoat5vslbctz2afzq2jzqjvgrpibgh/spack-src/src/unix/darwin-proctitle.c": "/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\n#include <dlfcn.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <TargetConditionals.h>\n\n#if !TARGET_OS_IPHONE\n# include <CoreFoundation/CoreFoundation.h>\n# include <ApplicationServices/ApplicationServices.h>\n#endif\n\n\nstatic int uv__pthread_setname_np(const char* name) {\n  int (*dynamic_pthread_setname_np)(const char* name);\n  char namebuf[64];  /* MAXTHREADNAMESIZE */\n  int err;\n\n  /* pthread_setname_np() first appeared in OS X 10.6 and iOS 3.2. */\n  *(void **)(&dynamic_pthread_setname_np) =\n      dlsym(RTLD_DEFAULT, \"pthread_setname_np\");\n\n  if (dynamic_pthread_setname_np == NULL)\n    return -ENOSYS;\n\n  strncpy(namebuf, name, sizeof(namebuf) - 1);\n  namebuf[sizeof(namebuf) - 1] = '\\0';\n\n  err = dynamic_pthread_setname_np(namebuf);\n  if (err)\n    return -err;\n\n  return 0;\n}\n\n\nint uv__set_process_title(const char* title) {\n#if TARGET_OS_IPHONE\n  return uv__pthread_setname_np(title);\n#else\n  CFStringRef (*pCFStringCreateWithCString)(CFAllocatorRef,\n                                            const char*,\n                                            CFStringEncoding);\n  CFBundleRef (*pCFBundleGetBundleWithIdentifier)(CFStringRef);\n  void *(*pCFBundleGetDataPointerForName)(CFBundleRef, CFStringRef);\n  void *(*pCFBundleGetFunctionPointerForName)(CFBundleRef, CFStringRef);\n  CFTypeRef (*pLSGetCurrentApplicationASN)(void);\n  OSStatus (*pLSSetApplicationInformationItem)(int,\n                                               CFTypeRef,\n                                               CFStringRef,\n                                               CFStringRef,\n                                               CFDictionaryRef*);\n  void* application_services_handle;\n  void* core_foundation_handle;\n  CFBundleRef launch_services_bundle;\n  CFStringRef* display_name_key;\n  CFDictionaryRef (*pCFBundleGetInfoDictionary)(CFBundleRef);\n  CFBundleRef (*pCFBundleGetMainBundle)(void);\n  CFBundleRef hi_services_bundle;\n  OSStatus (*pSetApplicationIsDaemon)(int);\n  CFDictionaryRef (*pLSApplicationCheckIn)(int, CFDictionaryRef);\n  void (*pLSSetApplicationLaunchServicesServerConnectionStatus)(uint64_t,\n                                                                void*);\n  CFTypeRef asn;\n  int err;\n\n  err = -ENOENT;\n  application_services_handle = dlopen(\"/System/Library/Frameworks/\"\n                                       \"ApplicationServices.framework/\"\n                                       \"Versions/A/ApplicationServices\",\n                                       RTLD_LAZY | RTLD_LOCAL);\n  core_foundation_handle = dlopen(\"/System/Library/Frameworks/\"\n                                  \"CoreFoundation.framework/\"\n                                  \"Versions/A/CoreFoundation\",\n                                  RTLD_LAZY | RTLD_LOCAL);\n\n  if (application_services_handle == NULL || core_foundation_handle == NULL)\n    goto out;\n\n  *(void **)(&pCFStringCreateWithCString) =\n      dlsym(core_foundation_handle, \"CFStringCreateWithCString\");\n  *(void **)(&pCFBundleGetBundleWithIdentifier) =\n      dlsym(core_foundation_handle, \"CFBundleGetBundleWithIdentifier\");\n  *(void **)(&pCFBundleGetDataPointerForName) =\n      dlsym(core_foundation_handle, \"CFBundleGetDataPointerForName\");\n  *(void **)(&pCFBundleGetFunctionPointerForName) =\n      dlsym(core_foundation_handle, \"CFBundleGetFunctionPointerForName\");\n\n  if (pCFStringCreateWithCString == NULL ||\n      pCFBundleGetBundleWithIdentifier == NULL ||\n      pCFBundleGetDataPointerForName == NULL ||\n      pCFBundleGetFunctionPointerForName == NULL) {\n    goto out;\n  }\n\n#define S(s) pCFStringCreateWithCString(NULL, (s), kCFStringEncodingUTF8)\n\n  launch_services_bundle =\n      pCFBundleGetBundleWithIdentifier(S(\"com.apple.LaunchServices\"));\n\n  if (launch_services_bundle == NULL)\n    goto out;\n\n  *(void **)(&pLSGetCurrentApplicationASN) =\n      pCFBundleGetFunctionPointerForName(launch_services_bundle,\n                                         S(\"_LSGetCurrentApplicationASN\"));\n\n  if (pLSGetCurrentApplicationASN == NULL)\n    goto out;\n\n  *(void **)(&pLSSetApplicationInformationItem) =\n      pCFBundleGetFunctionPointerForName(launch_services_bundle,\n                                         S(\"_LSSetApplicationInformationItem\"));\n\n  if (pLSSetApplicationInformationItem == NULL)\n    goto out;\n\n  display_name_key = pCFBundleGetDataPointerForName(launch_services_bundle,\n                                                    S(\"_kLSDisplayNameKey\"));\n\n  if (display_name_key == NULL || *display_name_key == NULL)\n    goto out;\n\n  *(void **)(&pCFBundleGetInfoDictionary) = dlsym(core_foundation_handle,\n                                     \"CFBundleGetInfoDictionary\");\n  *(void **)(&pCFBundleGetMainBundle) = dlsym(core_foundation_handle,\n                                 \"CFBundleGetMainBundle\");\n  if (pCFBundleGetInfoDictionary == NULL || pCFBundleGetMainBundle == NULL)\n    goto out;\n\n  /* Black 10.9 magic, to remove (Not responding) mark in Activity Monitor */\n  hi_services_bundle =\n      pCFBundleGetBundleWithIdentifier(S(\"com.apple.HIServices\"));\n  err = -ENOENT;\n  if (hi_services_bundle == NULL)\n    goto out;\n\n  *(void **)(&pSetApplicationIsDaemon) = pCFBundleGetFunctionPointerForName(\n      hi_services_bundle,\n      S(\"SetApplicationIsDaemon\"));\n  *(void **)(&pLSApplicationCheckIn) = pCFBundleGetFunctionPointerForName(\n      launch_services_bundle,\n      S(\"_LSApplicationCheckIn\"));\n  *(void **)(&pLSSetApplicationLaunchServicesServerConnectionStatus) =\n      pCFBundleGetFunctionPointerForName(\n          launch_services_bundle,\n          S(\"_LSSetApplicationLaunchServicesServerConnectionStatus\"));\n  if (pSetApplicationIsDaemon == NULL ||\n      pLSApplicationCheckIn == NULL ||\n      pLSSetApplicationLaunchServicesServerConnectionStatus == NULL) {\n    goto out;\n  }\n\n  if (pSetApplicationIsDaemon(1) != noErr)\n    goto out;\n\n  pLSSetApplicationLaunchServicesServerConnectionStatus(0, NULL);\n\n  /* Check into process manager?! */\n  pLSApplicationCheckIn(-2,\n                        pCFBundleGetInfoDictionary(pCFBundleGetMainBundle()));\n\n  asn = pLSGetCurrentApplicationASN();\n\n  err = -EINVAL;\n  if (pLSSetApplicationInformationItem(-2,  /* Magic value. */\n                                       asn,\n                                       *display_name_key,\n                                       S(title),\n                                       NULL) != noErr) {\n    goto out;\n  }\n\n  uv__pthread_setname_np(title);  /* Don't care if it fails. */\n  err = 0;\n\nout:\n  if (core_foundation_handle != NULL)\n    dlclose(core_foundation_handle);\n\n  if (application_services_handle != NULL)\n    dlclose(application_services_handle);\n\n  return err;\n#endif  /* !TARGET_OS_IPHONE */\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-libuv-1.10.0-tvkoat5vslbctz2afzq2jzqjvgrpibgh/spack-src/src/unix/fsevents.c": "/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\n#include \"uv.h\"\n#include \"internal.h\"\n\n#if TARGET_OS_IPHONE\n\n/* iOS (currently) doesn't provide the FSEvents-API (nor CoreServices) */\n\nint uv__fsevents_init(uv_fs_event_t* handle) {\n  return 0;\n}\n\n\nint uv__fsevents_close(uv_fs_event_t* handle) {\n  return 0;\n}\n\n\nvoid uv__fsevents_loop_delete(uv_loop_t* loop) {\n}\n\n#else /* TARGET_OS_IPHONE */\n\n#include <dlfcn.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <pthread.h>\n\n#include <CoreFoundation/CFRunLoop.h>\n#include <CoreServices/CoreServices.h>\n\n/* These are macros to avoid \"initializer element is not constant\" errors\n * with old versions of gcc.\n */\n#define kFSEventsModified (kFSEventStreamEventFlagItemFinderInfoMod |         \\\n                           kFSEventStreamEventFlagItemModified |              \\\n                           kFSEventStreamEventFlagItemInodeMetaMod |          \\\n                           kFSEventStreamEventFlagItemChangeOwner |           \\\n                           kFSEventStreamEventFlagItemXattrMod)\n\n#define kFSEventsRenamed  (kFSEventStreamEventFlagItemCreated |               \\\n                           kFSEventStreamEventFlagItemRemoved |               \\\n                           kFSEventStreamEventFlagItemRenamed)\n\n#define kFSEventsSystem   (kFSEventStreamEventFlagUserDropped |               \\\n                           kFSEventStreamEventFlagKernelDropped |             \\\n                           kFSEventStreamEventFlagEventIdsWrapped |           \\\n                           kFSEventStreamEventFlagHistoryDone |               \\\n                           kFSEventStreamEventFlagMount |                     \\\n                           kFSEventStreamEventFlagUnmount |                   \\\n                           kFSEventStreamEventFlagRootChanged)\n\ntypedef struct uv__fsevents_event_s uv__fsevents_event_t;\ntypedef struct uv__cf_loop_signal_s uv__cf_loop_signal_t;\ntypedef struct uv__cf_loop_state_s uv__cf_loop_state_t;\n\nenum uv__cf_loop_signal_type_e {\n  kUVCFLoopSignalRegular,\n  kUVCFLoopSignalClosing\n};\ntypedef enum uv__cf_loop_signal_type_e uv__cf_loop_signal_type_t;\n\nstruct uv__cf_loop_signal_s {\n  QUEUE member;\n  uv_fs_event_t* handle;\n  uv__cf_loop_signal_type_t type;\n};\n\nstruct uv__fsevents_event_s {\n  QUEUE member;\n  int events;\n  char path[1];\n};\n\nstruct uv__cf_loop_state_s {\n  CFRunLoopRef loop;\n  CFRunLoopSourceRef signal_source;\n  int fsevent_need_reschedule;\n  FSEventStreamRef fsevent_stream;\n  uv_sem_t fsevent_sem;\n  uv_mutex_t fsevent_mutex;\n  void* fsevent_handles[2];\n  unsigned int fsevent_handle_count;\n};\n\n/* Forward declarations */\nstatic void uv__cf_loop_cb(void* arg);\nstatic void* uv__cf_loop_runner(void* arg);\nstatic int uv__cf_loop_signal(uv_loop_t* loop,\n                              uv_fs_event_t* handle,\n                              uv__cf_loop_signal_type_t type);\n\n/* Lazy-loaded by uv__fsevents_global_init(). */\nstatic CFArrayRef (*pCFArrayCreate)(CFAllocatorRef,\n                                    const void**,\n                                    CFIndex,\n                                    const CFArrayCallBacks*);\nstatic void (*pCFRelease)(CFTypeRef);\nstatic void (*pCFRunLoopAddSource)(CFRunLoopRef,\n                                   CFRunLoopSourceRef,\n                                   CFStringRef);\nstatic CFRunLoopRef (*pCFRunLoopGetCurrent)(void);\nstatic void (*pCFRunLoopRemoveSource)(CFRunLoopRef,\n                                      CFRunLoopSourceRef,\n                                      CFStringRef);\nstatic void (*pCFRunLoopRun)(void);\nstatic CFRunLoopSourceRef (*pCFRunLoopSourceCreate)(CFAllocatorRef,\n                                                    CFIndex,\n                                                    CFRunLoopSourceContext*);\nstatic void (*pCFRunLoopSourceSignal)(CFRunLoopSourceRef);\nstatic void (*pCFRunLoopStop)(CFRunLoopRef);\nstatic void (*pCFRunLoopWakeUp)(CFRunLoopRef);\nstatic CFStringRef (*pCFStringCreateWithFileSystemRepresentation)(\n    CFAllocatorRef,\n    const char*);\nstatic CFStringEncoding (*pCFStringGetSystemEncoding)(void);\nstatic CFStringRef (*pkCFRunLoopDefaultMode);\nstatic FSEventStreamRef (*pFSEventStreamCreate)(CFAllocatorRef,\n                                                FSEventStreamCallback,\n                                                FSEventStreamContext*,\n                                                CFArrayRef,\n                                                FSEventStreamEventId,\n                                                CFTimeInterval,\n                                                FSEventStreamCreateFlags);\nstatic void (*pFSEventStreamFlushSync)(FSEventStreamRef);\nstatic void (*pFSEventStreamInvalidate)(FSEventStreamRef);\nstatic void (*pFSEventStreamRelease)(FSEventStreamRef);\nstatic void (*pFSEventStreamScheduleWithRunLoop)(FSEventStreamRef,\n                                                 CFRunLoopRef,\n                                                 CFStringRef);\nstatic Boolean (*pFSEventStreamStart)(FSEventStreamRef);\nstatic void (*pFSEventStreamStop)(FSEventStreamRef);\n\n#define UV__FSEVENTS_PROCESS(handle, block)                                   \\\n    do {                                                                      \\\n      QUEUE events;                                                           \\\n      QUEUE* q;                                                               \\\n      uv__fsevents_event_t* event;                                            \\\n      int err;                                                                \\\n      uv_mutex_lock(&(handle)->cf_mutex);                                     \\\n      /* Split-off all events and empty original queue */                     \\\n      QUEUE_MOVE(&(handle)->cf_events, &events);                              \\\n      /* Get error (if any) and zero original one */                          \\\n      err = (handle)->cf_error;                                               \\\n      (handle)->cf_error = 0;                                                 \\\n      uv_mutex_unlock(&(handle)->cf_mutex);                                   \\\n      /* Loop through events, deallocating each after processing */           \\\n      while (!QUEUE_EMPTY(&events)) {                                         \\\n        q = QUEUE_HEAD(&events);                                              \\\n        event = QUEUE_DATA(q, uv__fsevents_event_t, member);                  \\\n        QUEUE_REMOVE(q);                                                      \\\n        /* NOTE: Checking uv__is_active() is required here, because handle    \\\n         * callback may close handle and invoking it after it will lead to    \\\n         * incorrect behaviour */                                             \\\n        if (!uv__is_closing((handle)) && uv__is_active((handle)))             \\\n          block                                                               \\\n        /* Free allocated data */                                             \\\n        uv__free(event);                                                      \\\n      }                                                                       \\\n      if (err != 0 && !uv__is_closing((handle)) && uv__is_active((handle)))   \\\n        (handle)->cb((handle), NULL, 0, err);                                 \\\n    } while (0)\n\n\n/* Runs in UV loop's thread, when there're events to report to handle */\nstatic void uv__fsevents_cb(uv_async_t* cb) {\n  uv_fs_event_t* handle;\n\n  handle = cb->data;\n\n  UV__FSEVENTS_PROCESS(handle, {\n    handle->cb(handle, event->path[0] ? event->path : NULL, event->events, 0);\n  });\n}\n\n\n/* Runs in CF thread, pushed event into handle's event list */\nstatic void uv__fsevents_push_event(uv_fs_event_t* handle,\n                                    QUEUE* events,\n                                    int err) {\n  assert(events != NULL || err != 0);\n  uv_mutex_lock(&handle->cf_mutex);\n\n  /* Concatenate two queues */\n  if (events != NULL)\n    QUEUE_ADD(&handle->cf_events, events);\n\n  /* Propagate error */\n  if (err != 0)\n    handle->cf_error = err;\n  uv_mutex_unlock(&handle->cf_mutex);\n\n  uv_async_send(handle->cf_cb);\n}\n\n\n/* Runs in CF thread, when there're events in FSEventStream */\nstatic void uv__fsevents_event_cb(ConstFSEventStreamRef streamRef,\n                                  void* info,\n                                  size_t numEvents,\n                                  void* eventPaths,\n                                  const FSEventStreamEventFlags eventFlags[],\n                                  const FSEventStreamEventId eventIds[]) {\n  size_t i;\n  int len;\n  char** paths;\n  char* path;\n  char* pos;\n  uv_fs_event_t* handle;\n  QUEUE* q;\n  uv_loop_t* loop;\n  uv__cf_loop_state_t* state;\n  uv__fsevents_event_t* event;\n  QUEUE head;\n\n  loop = info;\n  state = loop->cf_state;\n  assert(state != NULL);\n  paths = eventPaths;\n\n  /* For each handle */\n  uv_mutex_lock(&state->fsevent_mutex);\n  QUEUE_FOREACH(q, &state->fsevent_handles) {\n    handle = QUEUE_DATA(q, uv_fs_event_t, cf_member);\n    QUEUE_INIT(&head);\n\n    /* Process and filter out events */\n    for (i = 0; i < numEvents; i++) {\n      /* Ignore system events */\n      if (eventFlags[i] & kFSEventsSystem)\n        continue;\n\n      path = paths[i];\n      len = strlen(path);\n\n      /* Filter out paths that are outside handle's request */\n      if (strncmp(path, handle->realpath, handle->realpath_len) != 0)\n        continue;\n\n      if (handle->realpath_len > 1 || *handle->realpath != '/') {\n        path += handle->realpath_len;\n        len -= handle->realpath_len;\n\n        /* Skip forward slash */\n        if (*path != '\\0') {\n          path++;\n          len--;\n        }\n      }\n\n#ifdef MAC_OS_X_VERSION_10_7\n      /* Ignore events with path equal to directory itself */\n      if (len == 0)\n        continue;\n#endif /* MAC_OS_X_VERSION_10_7 */\n\n      /* Do not emit events from subdirectories (without option set) */\n      if ((handle->cf_flags & UV_FS_EVENT_RECURSIVE) == 0 && *path != 0) {\n        pos = strchr(path + 1, '/');\n        if (pos != NULL)\n          continue;\n      }\n\n#ifndef MAC_OS_X_VERSION_10_7\n      path = \"\";\n      len = 0;\n#endif /* MAC_OS_X_VERSION_10_7 */\n\n      event = uv__malloc(sizeof(*event) + len);\n      if (event == NULL)\n        break;\n\n      memset(event, 0, sizeof(*event));\n      memcpy(event->path, path, len + 1);\n\n      if ((eventFlags[i] & kFSEventsModified) != 0 &&\n          (eventFlags[i] & kFSEventsRenamed) == 0)\n        event->events = UV_CHANGE;\n      else\n        event->events = UV_RENAME;\n\n      QUEUE_INSERT_TAIL(&head, &event->member);\n    }\n\n    if (!QUEUE_EMPTY(&head))\n      uv__fsevents_push_event(handle, &head, 0);\n  }\n  uv_mutex_unlock(&state->fsevent_mutex);\n}\n\n\n/* Runs in CF thread */\nstatic int uv__fsevents_create_stream(uv_loop_t* loop, CFArrayRef paths) {\n  uv__cf_loop_state_t* state;\n  FSEventStreamContext ctx;\n  FSEventStreamRef ref;\n  CFAbsoluteTime latency;\n  FSEventStreamCreateFlags flags;\n\n  /* Initialize context */\n  ctx.version = 0;\n  ctx.info = loop;\n  ctx.retain = NULL;\n  ctx.release = NULL;\n  ctx.copyDescription = NULL;\n\n  latency = 0.05;\n\n  /* Explanation of selected flags:\n   * 1. NoDefer - without this flag, events that are happening continuously\n   *    (i.e. each event is happening after time interval less than `latency`,\n   *    counted from previous event), will be deferred and passed to callback\n   *    once they'll either fill whole OS buffer, or when this continuous stream\n   *    will stop (i.e. there'll be delay between events, bigger than\n   *    `latency`).\n   *    Specifying this flag will invoke callback after `latency` time passed\n   *    since event.\n   * 2. FileEvents - fire callback for file changes too (by default it is firing\n   *    it only for directory changes).\n   */\n  flags = kFSEventStreamCreateFlagNoDefer | kFSEventStreamCreateFlagFileEvents;\n\n  /*\n   * NOTE: It might sound like a good idea to remember last seen StreamEventId,\n   * but in reality one dir might have last StreamEventId less than, the other,\n   * that is being watched now. Which will cause FSEventStream API to report\n   * changes to files from the past.\n   */\n  ref = pFSEventStreamCreate(NULL,\n                             &uv__fsevents_event_cb,\n                             &ctx,\n                             paths,\n                             kFSEventStreamEventIdSinceNow,\n                             latency,\n                             flags);\n  assert(ref != NULL);\n\n  state = loop->cf_state;\n  pFSEventStreamScheduleWithRunLoop(ref,\n                                    state->loop,\n                                    *pkCFRunLoopDefaultMode);\n  if (!pFSEventStreamStart(ref)) {\n    pFSEventStreamInvalidate(ref);\n    pFSEventStreamRelease(ref);\n    return -EMFILE;\n  }\n\n  state->fsevent_stream = ref;\n  return 0;\n}\n\n\n/* Runs in CF thread */\nstatic void uv__fsevents_destroy_stream(uv_loop_t* loop) {\n  uv__cf_loop_state_t* state;\n\n  state = loop->cf_state;\n\n  if (state->fsevent_stream == NULL)\n    return;\n\n  /* Flush all accumulated events */\n  pFSEventStreamFlushSync(state->fsevent_stream);\n\n  /* Stop emitting events */\n  pFSEventStreamStop(state->fsevent_stream);\n\n  /* Release stream */\n  pFSEventStreamInvalidate(state->fsevent_stream);\n  pFSEventStreamRelease(state->fsevent_stream);\n  state->fsevent_stream = NULL;\n}\n\n\n/* Runs in CF thread, when there're new fsevent handles to add to stream */\nstatic void uv__fsevents_reschedule(uv_fs_event_t* handle,\n                                    uv__cf_loop_signal_type_t type) {\n  uv__cf_loop_state_t* state;\n  QUEUE* q;\n  uv_fs_event_t* curr;\n  CFArrayRef cf_paths;\n  CFStringRef* paths;\n  unsigned int i;\n  int err;\n  unsigned int path_count;\n\n  state = handle->loop->cf_state;\n  paths = NULL;\n  cf_paths = NULL;\n  err = 0;\n  /* NOTE: `i` is used in deallocation loop below */\n  i = 0;\n\n  /* Optimization to prevent O(n^2) time spent when starting to watch\n   * many files simultaneously\n   */\n  uv_mutex_lock(&state->fsevent_mutex);\n  if (state->fsevent_need_reschedule == 0) {\n    uv_mutex_unlock(&state->fsevent_mutex);\n    goto final;\n  }\n  state->fsevent_need_reschedule = 0;\n  uv_mutex_unlock(&state->fsevent_mutex);\n\n  /* Destroy previous FSEventStream */\n  uv__fsevents_destroy_stream(handle->loop);\n\n  /* Any failure below will be a memory failure */\n  err = -ENOMEM;\n\n  /* Create list of all watched paths */\n  uv_mutex_lock(&state->fsevent_mutex);\n  path_count = state->fsevent_handle_count;\n  if (path_count != 0) {\n    paths = uv__malloc(sizeof(*paths) * path_count);\n    if (paths == NULL) {\n      uv_mutex_unlock(&state->fsevent_mutex);\n      goto final;\n    }\n\n    q = &state->fsevent_handles;\n    for (; i < path_count; i++) {\n      q = QUEUE_NEXT(q);\n      assert(q != &state->fsevent_handles);\n      curr = QUEUE_DATA(q, uv_fs_event_t, cf_member);\n\n      assert(curr->realpath != NULL);\n      paths[i] =\n          pCFStringCreateWithFileSystemRepresentation(NULL, curr->realpath);\n      if (paths[i] == NULL) {\n        uv_mutex_unlock(&state->fsevent_mutex);\n        goto final;\n      }\n    }\n  }\n  uv_mutex_unlock(&state->fsevent_mutex);\n  err = 0;\n\n  if (path_count != 0) {\n    /* Create new FSEventStream */\n    cf_paths = pCFArrayCreate(NULL, (const void**) paths, path_count, NULL);\n    if (cf_paths == NULL) {\n      err = -ENOMEM;\n      goto final;\n    }\n    err = uv__fsevents_create_stream(handle->loop, cf_paths);\n  }\n\nfinal:\n  /* Deallocate all paths in case of failure */\n  if (err != 0) {\n    if (cf_paths == NULL) {\n      while (i != 0)\n        pCFRelease(paths[--i]);\n      uv__free(paths);\n    } else {\n      /* CFArray takes ownership of both strings and original C-array */\n      pCFRelease(cf_paths);\n    }\n\n    /* Broadcast error to all handles */\n    uv_mutex_lock(&state->fsevent_mutex);\n    QUEUE_FOREACH(q, &state->fsevent_handles) {\n      curr = QUEUE_DATA(q, uv_fs_event_t, cf_member);\n      uv__fsevents_push_event(curr, NULL, err);\n    }\n    uv_mutex_unlock(&state->fsevent_mutex);\n  }\n\n  /*\n   * Main thread will block until the removal of handle from the list,\n   * we must tell it when we're ready.\n   *\n   * NOTE: This is coupled with `uv_sem_wait()` in `uv__fsevents_close`\n   */\n  if (type == kUVCFLoopSignalClosing)\n    uv_sem_post(&state->fsevent_sem);\n}\n\n\nstatic int uv__fsevents_global_init(void) {\n  static pthread_mutex_t global_init_mutex = PTHREAD_MUTEX_INITIALIZER;\n  static void* core_foundation_handle;\n  static void* core_services_handle;\n  int err;\n\n  err = 0;\n  pthread_mutex_lock(&global_init_mutex);\n  if (core_foundation_handle != NULL)\n    goto out;\n\n  /* The libraries are never unloaded because we currently don't have a good\n   * mechanism for keeping a reference count. It's unlikely to be an issue\n   * but if it ever becomes one, we can turn the dynamic library handles into\n   * per-event loop properties and have the dynamic linker keep track for us.\n   */\n  err = -ENOSYS;\n  core_foundation_handle = dlopen(\"/System/Library/Frameworks/\"\n                                  \"CoreFoundation.framework/\"\n                                  \"Versions/A/CoreFoundation\",\n                                  RTLD_LAZY | RTLD_LOCAL);\n  if (core_foundation_handle == NULL)\n    goto out;\n\n  core_services_handle = dlopen(\"/System/Library/Frameworks/\"\n                                \"CoreServices.framework/\"\n                                \"Versions/A/CoreServices\",\n                                RTLD_LAZY | RTLD_LOCAL);\n  if (core_services_handle == NULL)\n    goto out;\n\n  err = -ENOENT;\n#define V(handle, symbol)                                                     \\\n  do {                                                                        \\\n    *(void **)(&p ## symbol) = dlsym((handle), #symbol);                      \\\n    if (p ## symbol == NULL)                                                  \\\n      goto out;                                                               \\\n  }                                                                           \\\n  while (0)\n  V(core_foundation_handle, CFArrayCreate);\n  V(core_foundation_handle, CFRelease);\n  V(core_foundation_handle, CFRunLoopAddSource);\n  V(core_foundation_handle, CFRunLoopGetCurrent);\n  V(core_foundation_handle, CFRunLoopRemoveSource);\n  V(core_foundation_handle, CFRunLoopRun);\n  V(core_foundation_handle, CFRunLoopSourceCreate);\n  V(core_foundation_handle, CFRunLoopSourceSignal);\n  V(core_foundation_handle, CFRunLoopStop);\n  V(core_foundation_handle, CFRunLoopWakeUp);\n  V(core_foundation_handle, CFStringCreateWithFileSystemRepresentation);\n  V(core_foundation_handle, CFStringGetSystemEncoding);\n  V(core_foundation_handle, kCFRunLoopDefaultMode);\n  V(core_services_handle, FSEventStreamCreate);\n  V(core_services_handle, FSEventStreamFlushSync);\n  V(core_services_handle, FSEventStreamInvalidate);\n  V(core_services_handle, FSEventStreamRelease);\n  V(core_services_handle, FSEventStreamScheduleWithRunLoop);\n  V(core_services_handle, FSEventStreamStart);\n  V(core_services_handle, FSEventStreamStop);\n#undef V\n  err = 0;\n\nout:\n  if (err && core_services_handle != NULL) {\n    dlclose(core_services_handle);\n    core_services_handle = NULL;\n  }\n\n  if (err && core_foundation_handle != NULL) {\n    dlclose(core_foundation_handle);\n    core_foundation_handle = NULL;\n  }\n\n  pthread_mutex_unlock(&global_init_mutex);\n  return err;\n}\n\n\n/* Runs in UV loop */\nstatic int uv__fsevents_loop_init(uv_loop_t* loop) {\n  CFRunLoopSourceContext ctx;\n  uv__cf_loop_state_t* state;\n  pthread_attr_t attr_storage;\n  pthread_attr_t* attr;\n  int err;\n\n  if (loop->cf_state != NULL)\n    return 0;\n\n  err = uv__fsevents_global_init();\n  if (err)\n    return err;\n\n  state = uv__calloc(1, sizeof(*state));\n  if (state == NULL)\n    return -ENOMEM;\n\n  err = uv_mutex_init(&loop->cf_mutex);\n  if (err)\n    goto fail_mutex_init;\n\n  err = uv_sem_init(&loop->cf_sem, 0);\n  if (err)\n    goto fail_sem_init;\n\n  QUEUE_INIT(&loop->cf_signals);\n\n  err = uv_sem_init(&state->fsevent_sem, 0);\n  if (err)\n    goto fail_fsevent_sem_init;\n\n  err = uv_mutex_init(&state->fsevent_mutex);\n  if (err)\n    goto fail_fsevent_mutex_init;\n\n  QUEUE_INIT(&state->fsevent_handles);\n  state->fsevent_need_reschedule = 0;\n  state->fsevent_handle_count = 0;\n\n  memset(&ctx, 0, sizeof(ctx));\n  ctx.info = loop;\n  ctx.perform = uv__cf_loop_cb;\n  state->signal_source = pCFRunLoopSourceCreate(NULL, 0, &ctx);\n  if (state->signal_source == NULL) {\n    err = -ENOMEM;\n    goto fail_signal_source_create;\n  }\n\n  /* In the unlikely event that pthread_attr_init() fails, create the thread\n   * with the default stack size. We'll use a little more address space but\n   * that in itself is not a fatal error.\n   */\n  attr = &attr_storage;\n  if (pthread_attr_init(attr))\n    attr = NULL;\n\n  if (attr != NULL)\n    if (pthread_attr_setstacksize(attr, 4 * PTHREAD_STACK_MIN))\n      abort();\n\n  loop->cf_state = state;\n\n  /* uv_thread_t is an alias for pthread_t. */\n  err = -pthread_create(&loop->cf_thread, attr, uv__cf_loop_runner, loop);\n\n  if (attr != NULL)\n    pthread_attr_destroy(attr);\n\n  if (err)\n    goto fail_thread_create;\n\n  /* Synchronize threads */\n  uv_sem_wait(&loop->cf_sem);\n  return 0;\n\nfail_thread_create:\n  loop->cf_state = NULL;\n\nfail_signal_source_create:\n  uv_mutex_destroy(&state->fsevent_mutex);\n\nfail_fsevent_mutex_init:\n  uv_sem_destroy(&state->fsevent_sem);\n\nfail_fsevent_sem_init:\n  uv_sem_destroy(&loop->cf_sem);\n\nfail_sem_init:\n  uv_mutex_destroy(&loop->cf_mutex);\n\nfail_mutex_init:\n  uv__free(state);\n  return err;\n}\n\n\n/* Runs in UV loop */\nvoid uv__fsevents_loop_delete(uv_loop_t* loop) {\n  uv__cf_loop_signal_t* s;\n  uv__cf_loop_state_t* state;\n  QUEUE* q;\n\n  if (loop->cf_state == NULL)\n    return;\n\n  if (uv__cf_loop_signal(loop, NULL, kUVCFLoopSignalRegular) != 0)\n    abort();\n\n  uv_thread_join(&loop->cf_thread);\n  uv_sem_destroy(&loop->cf_sem);\n  uv_mutex_destroy(&loop->cf_mutex);\n\n  /* Free any remaining data */\n  while (!QUEUE_EMPTY(&loop->cf_signals)) {\n    q = QUEUE_HEAD(&loop->cf_signals);\n    s = QUEUE_DATA(q, uv__cf_loop_signal_t, member);\n    QUEUE_REMOVE(q);\n    uv__free(s);\n  }\n\n  /* Destroy state */\n  state = loop->cf_state;\n  uv_sem_destroy(&state->fsevent_sem);\n  uv_mutex_destroy(&state->fsevent_mutex);\n  pCFRelease(state->signal_source);\n  uv__free(state);\n  loop->cf_state = NULL;\n}\n\n\n/* Runs in CF thread. This is the CF loop's body */\nstatic void* uv__cf_loop_runner(void* arg) {\n  uv_loop_t* loop;\n  uv__cf_loop_state_t* state;\n\n  loop = arg;\n  state = loop->cf_state;\n  state->loop = pCFRunLoopGetCurrent();\n\n  pCFRunLoopAddSource(state->loop,\n                      state->signal_source,\n                      *pkCFRunLoopDefaultMode);\n\n  uv_sem_post(&loop->cf_sem);\n\n  pCFRunLoopRun();\n  pCFRunLoopRemoveSource(state->loop,\n                         state->signal_source,\n                         *pkCFRunLoopDefaultMode);\n\n  return NULL;\n}\n\n\n/* Runs in CF thread, executed after `uv__cf_loop_signal()` */\nstatic void uv__cf_loop_cb(void* arg) {\n  uv_loop_t* loop;\n  uv__cf_loop_state_t* state;\n  QUEUE* item;\n  QUEUE split_head;\n  uv__cf_loop_signal_t* s;\n\n  loop = arg;\n  state = loop->cf_state;\n\n  uv_mutex_lock(&loop->cf_mutex);\n  QUEUE_MOVE(&loop->cf_signals, &split_head);\n  uv_mutex_unlock(&loop->cf_mutex);\n\n  while (!QUEUE_EMPTY(&split_head)) {\n    item = QUEUE_HEAD(&split_head);\n    QUEUE_REMOVE(item);\n\n    s = QUEUE_DATA(item, uv__cf_loop_signal_t, member);\n\n    /* This was a termination signal */\n    if (s->handle == NULL)\n      pCFRunLoopStop(state->loop);\n    else\n      uv__fsevents_reschedule(s->handle, s->type);\n\n    uv__free(s);\n  }\n}\n\n\n/* Runs in UV loop to notify CF thread */\nint uv__cf_loop_signal(uv_loop_t* loop,\n                       uv_fs_event_t* handle,\n                       uv__cf_loop_signal_type_t type) {\n  uv__cf_loop_signal_t* item;\n  uv__cf_loop_state_t* state;\n\n  item = uv__malloc(sizeof(*item));\n  if (item == NULL)\n    return -ENOMEM;\n\n  item->handle = handle;\n  item->type = type;\n\n  uv_mutex_lock(&loop->cf_mutex);\n  QUEUE_INSERT_TAIL(&loop->cf_signals, &item->member);\n  uv_mutex_unlock(&loop->cf_mutex);\n\n  state = loop->cf_state;\n  assert(state != NULL);\n  pCFRunLoopSourceSignal(state->signal_source);\n  pCFRunLoopWakeUp(state->loop);\n\n  return 0;\n}\n\n\n/* Runs in UV loop to initialize handle */\nint uv__fsevents_init(uv_fs_event_t* handle) {\n  int err;\n  uv__cf_loop_state_t* state;\n\n  err = uv__fsevents_loop_init(handle->loop);\n  if (err)\n    return err;\n\n  /* Get absolute path to file */\n  handle->realpath = realpath(handle->path, NULL);\n  if (handle->realpath == NULL)\n    return -errno;\n  handle->realpath_len = strlen(handle->realpath);\n\n  /* Initialize event queue */\n  QUEUE_INIT(&handle->cf_events);\n  handle->cf_error = 0;\n\n  /*\n   * Events will occur in other thread.\n   * Initialize callback for getting them back into event loop's thread\n   */\n  handle->cf_cb = uv__malloc(sizeof(*handle->cf_cb));\n  if (handle->cf_cb == NULL) {\n    err = -ENOMEM;\n    goto fail_cf_cb_malloc;\n  }\n\n  handle->cf_cb->data = handle;\n  uv_async_init(handle->loop, handle->cf_cb, uv__fsevents_cb);\n  handle->cf_cb->flags |= UV__HANDLE_INTERNAL;\n  uv_unref((uv_handle_t*) handle->cf_cb);\n\n  err = uv_mutex_init(&handle->cf_mutex);\n  if (err)\n    goto fail_cf_mutex_init;\n\n  /* Insert handle into the list */\n  state = handle->loop->cf_state;\n  uv_mutex_lock(&state->fsevent_mutex);\n  QUEUE_INSERT_TAIL(&state->fsevent_handles, &handle->cf_member);\n  state->fsevent_handle_count++;\n  state->fsevent_need_reschedule = 1;\n  uv_mutex_unlock(&state->fsevent_mutex);\n\n  /* Reschedule FSEventStream */\n  assert(handle != NULL);\n  err = uv__cf_loop_signal(handle->loop, handle, kUVCFLoopSignalRegular);\n  if (err)\n    goto fail_loop_signal;\n\n  return 0;\n\nfail_loop_signal:\n  uv_mutex_destroy(&handle->cf_mutex);\n\nfail_cf_mutex_init:\n  uv__free(handle->cf_cb);\n  handle->cf_cb = NULL;\n\nfail_cf_cb_malloc:\n  uv__free(handle->realpath);\n  handle->realpath = NULL;\n  handle->realpath_len = 0;\n\n  return err;\n}\n\n\n/* Runs in UV loop to de-initialize handle */\nint uv__fsevents_close(uv_fs_event_t* handle) {\n  int err;\n  uv__cf_loop_state_t* state;\n\n  if (handle->cf_cb == NULL)\n    return -EINVAL;\n\n  /* Remove handle from  the list */\n  state = handle->loop->cf_state;\n  uv_mutex_lock(&state->fsevent_mutex);\n  QUEUE_REMOVE(&handle->cf_member);\n  state->fsevent_handle_count--;\n  state->fsevent_need_reschedule = 1;\n  uv_mutex_unlock(&state->fsevent_mutex);\n\n  /* Reschedule FSEventStream */\n  assert(handle != NULL);\n  err = uv__cf_loop_signal(handle->loop, handle, kUVCFLoopSignalClosing);\n  if (err)\n    return -err;\n\n  /* Wait for deinitialization */\n  uv_sem_wait(&state->fsevent_sem);\n\n  uv_close((uv_handle_t*) handle->cf_cb, (uv_close_cb) uv__free);\n  handle->cf_cb = NULL;\n\n  /* Free data in queue */\n  UV__FSEVENTS_PROCESS(handle, {\n    /* NOP */\n  });\n\n  uv_mutex_destroy(&handle->cf_mutex);\n  uv__free(handle->realpath);\n  handle->realpath = NULL;\n  handle->realpath_len = 0;\n\n  return 0;\n}\n\n#endif /* TARGET_OS_IPHONE */\n",
        "/tmp/vanessa/spack-stage/spack-stage-libuv-1.10.0-tvkoat5vslbctz2afzq2jzqjvgrpibgh/spack-src/src/unix/dl.c": "/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\n#include \"uv.h\"\n#include \"internal.h\"\n\n#include <dlfcn.h>\n#include <errno.h>\n#include <string.h>\n#include <locale.h>\n\nstatic int uv__dlerror(uv_lib_t* lib);\n\n\nint uv_dlopen(const char* filename, uv_lib_t* lib) {\n  dlerror(); /* Reset error status. */\n  lib->errmsg = NULL;\n  lib->handle = dlopen(filename, RTLD_LAZY);\n  return lib->handle ? 0 : uv__dlerror(lib);\n}\n\n\nvoid uv_dlclose(uv_lib_t* lib) {\n  uv__free(lib->errmsg);\n  lib->errmsg = NULL;\n\n  if (lib->handle) {\n    /* Ignore errors. No good way to signal them without leaking memory. */\n    dlclose(lib->handle);\n    lib->handle = NULL;\n  }\n}\n\n\nint uv_dlsym(uv_lib_t* lib, const char* name, void** ptr) {\n  dlerror(); /* Reset error status. */\n  *ptr = dlsym(lib->handle, name);\n  return uv__dlerror(lib);\n}\n\n\nconst char* uv_dlerror(const uv_lib_t* lib) {\n  return lib->errmsg ? lib->errmsg : \"no error\";\n}\n\n\nstatic int uv__dlerror(uv_lib_t* lib) {\n  const char* errmsg;\n\n  uv__free(lib->errmsg);\n\n  errmsg = dlerror();\n\n  if (errmsg) {\n    lib->errmsg = uv__strdup(errmsg);\n    return -1;\n  }\n  else {\n    lib->errmsg = NULL;\n    return 0;\n  }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-libuv-1.10.0-tvkoat5vslbctz2afzq2jzqjvgrpibgh/spack-src/include/uv-win.h": "/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\n#ifndef _WIN32_WINNT\n# define _WIN32_WINNT   0x0502\n#endif\n\n#if !defined(_SSIZE_T_) && !defined(_SSIZE_T_DEFINED)\ntypedef intptr_t ssize_t;\n# define _SSIZE_T_\n# define _SSIZE_T_DEFINED\n#endif\n\n#include <winsock2.h>\n\n#if defined(__MINGW32__) && !defined(__MINGW64_VERSION_MAJOR)\ntypedef struct pollfd {\n  SOCKET fd;\n  short  events;\n  short  revents;\n} WSAPOLLFD, *PWSAPOLLFD, *LPWSAPOLLFD;\n#endif\n\n#ifndef LOCALE_INVARIANT\n# define LOCALE_INVARIANT 0x007f\n#endif\n\n#include <mswsock.h>\n#include <ws2tcpip.h>\n#include <windows.h>\n\n#include <process.h>\n#include <signal.h>\n#include <sys/stat.h>\n\n#if defined(_MSC_VER) && _MSC_VER < 1600\n# include \"stdint-msvc2008.h\"\n#else\n# include <stdint.h>\n#endif\n\n#include \"tree.h\"\n#include \"uv-threadpool.h\"\n\n#define MAX_PIPENAME_LEN 256\n\n#ifndef S_IFLNK\n# define S_IFLNK 0xA000\n#endif\n\n/* Additional signals supported by uv_signal and or uv_kill. The CRT defines\n * the following signals already:\n *\n *   #define SIGINT           2\n *   #define SIGILL           4\n *   #define SIGABRT_COMPAT   6\n *   #define SIGFPE           8\n *   #define SIGSEGV         11\n *   #define SIGTERM         15\n *   #define SIGBREAK        21\n *   #define SIGABRT         22\n *\n * The additional signals have values that are common on other Unix\n * variants (Linux and Darwin)\n */\n#define SIGHUP                1\n#define SIGKILL               9\n#define SIGWINCH             28\n\n/* The CRT defines SIGABRT_COMPAT as 6, which equals SIGABRT on many */\n/* unix-like platforms. However MinGW doesn't define it, so we do. */\n#ifndef SIGABRT_COMPAT\n# define SIGABRT_COMPAT       6\n#endif\n\n/*\n * Guids and typedefs for winsock extension functions\n * Mingw32 doesn't have these :-(\n */\n#ifndef WSAID_ACCEPTEX\n# define WSAID_ACCEPTEX                                                       \\\n         {0xb5367df1, 0xcbac, 0x11cf,                                         \\\n         {0x95, 0xca, 0x00, 0x80, 0x5f, 0x48, 0xa1, 0x92}}\n\n# define WSAID_CONNECTEX                                                      \\\n         {0x25a207b9, 0xddf3, 0x4660,                                         \\\n         {0x8e, 0xe9, 0x76, 0xe5, 0x8c, 0x74, 0x06, 0x3e}}\n\n# define WSAID_GETACCEPTEXSOCKADDRS                                           \\\n         {0xb5367df2, 0xcbac, 0x11cf,                                         \\\n         {0x95, 0xca, 0x00, 0x80, 0x5f, 0x48, 0xa1, 0x92}}\n\n# define WSAID_DISCONNECTEX                                                   \\\n         {0x7fda2e11, 0x8630, 0x436f,                                         \\\n         {0xa0, 0x31, 0xf5, 0x36, 0xa6, 0xee, 0xc1, 0x57}}\n\n# define WSAID_TRANSMITFILE                                                   \\\n         {0xb5367df0, 0xcbac, 0x11cf,                                         \\\n         {0x95, 0xca, 0x00, 0x80, 0x5f, 0x48, 0xa1, 0x92}}\n\n  typedef BOOL (PASCAL *LPFN_ACCEPTEX)\n                      (SOCKET sListenSocket,\n                       SOCKET sAcceptSocket,\n                       PVOID lpOutputBuffer,\n                       DWORD dwReceiveDataLength,\n                       DWORD dwLocalAddressLength,\n                       DWORD dwRemoteAddressLength,\n                       LPDWORD lpdwBytesReceived,\n                       LPOVERLAPPED lpOverlapped);\n\n  typedef BOOL (PASCAL *LPFN_CONNECTEX)\n                      (SOCKET s,\n                       const struct sockaddr* name,\n                       int namelen,\n                       PVOID lpSendBuffer,\n                       DWORD dwSendDataLength,\n                       LPDWORD lpdwBytesSent,\n                       LPOVERLAPPED lpOverlapped);\n\n  typedef void (PASCAL *LPFN_GETACCEPTEXSOCKADDRS)\n                      (PVOID lpOutputBuffer,\n                       DWORD dwReceiveDataLength,\n                       DWORD dwLocalAddressLength,\n                       DWORD dwRemoteAddressLength,\n                       LPSOCKADDR* LocalSockaddr,\n                       LPINT LocalSockaddrLength,\n                       LPSOCKADDR* RemoteSockaddr,\n                       LPINT RemoteSockaddrLength);\n\n  typedef BOOL (PASCAL *LPFN_DISCONNECTEX)\n                      (SOCKET hSocket,\n                       LPOVERLAPPED lpOverlapped,\n                       DWORD dwFlags,\n                       DWORD reserved);\n\n  typedef BOOL (PASCAL *LPFN_TRANSMITFILE)\n                      (SOCKET hSocket,\n                       HANDLE hFile,\n                       DWORD nNumberOfBytesToWrite,\n                       DWORD nNumberOfBytesPerSend,\n                       LPOVERLAPPED lpOverlapped,\n                       LPTRANSMIT_FILE_BUFFERS lpTransmitBuffers,\n                       DWORD dwFlags);\n\n  typedef PVOID RTL_SRWLOCK;\n  typedef RTL_SRWLOCK SRWLOCK, *PSRWLOCK;\n#endif\n\ntypedef int (WSAAPI* LPFN_WSARECV)\n            (SOCKET socket,\n             LPWSABUF buffers,\n             DWORD buffer_count,\n             LPDWORD bytes,\n             LPDWORD flags,\n             LPWSAOVERLAPPED overlapped,\n             LPWSAOVERLAPPED_COMPLETION_ROUTINE completion_routine);\n\ntypedef int (WSAAPI* LPFN_WSARECVFROM)\n            (SOCKET socket,\n             LPWSABUF buffers,\n             DWORD buffer_count,\n             LPDWORD bytes,\n             LPDWORD flags,\n             struct sockaddr* addr,\n             LPINT addr_len,\n             LPWSAOVERLAPPED overlapped,\n             LPWSAOVERLAPPED_COMPLETION_ROUTINE completion_routine);\n\n#ifndef _NTDEF_\n  typedef LONG NTSTATUS;\n  typedef NTSTATUS *PNTSTATUS;\n#endif\n\n#ifndef RTL_CONDITION_VARIABLE_INIT\n  typedef PVOID CONDITION_VARIABLE, *PCONDITION_VARIABLE;\n#endif\n\ntypedef struct _AFD_POLL_HANDLE_INFO {\n  HANDLE Handle;\n  ULONG Events;\n  NTSTATUS Status;\n} AFD_POLL_HANDLE_INFO, *PAFD_POLL_HANDLE_INFO;\n\ntypedef struct _AFD_POLL_INFO {\n  LARGE_INTEGER Timeout;\n  ULONG NumberOfHandles;\n  ULONG Exclusive;\n  AFD_POLL_HANDLE_INFO Handles[1];\n} AFD_POLL_INFO, *PAFD_POLL_INFO;\n\n#define UV_MSAFD_PROVIDER_COUNT 3\n\n\n/**\n * It should be possible to cast uv_buf_t[] to WSABUF[]\n * see http://msdn.microsoft.com/en-us/library/ms741542(v=vs.85).aspx\n */\ntypedef struct uv_buf_t {\n  ULONG len;\n  char* base;\n} uv_buf_t;\n\ntypedef int uv_file;\ntypedef SOCKET uv_os_sock_t;\ntypedef HANDLE uv_os_fd_t;\n\ntypedef HANDLE uv_thread_t;\n\ntypedef HANDLE uv_sem_t;\n\ntypedef CRITICAL_SECTION uv_mutex_t;\n\n/* This condition variable implementation is based on the SetEvent solution\n * (section 3.2) at http://www.cs.wustl.edu/~schmidt/win32-cv-1.html\n * We could not use the SignalObjectAndWait solution (section 3.4) because\n * it want the 2nd argument (type uv_mutex_t) of uv_cond_wait() and\n * uv_cond_timedwait() to be HANDLEs, but we use CRITICAL_SECTIONs.\n */\n\ntypedef union {\n  CONDITION_VARIABLE cond_var;\n  struct {\n    unsigned int waiters_count;\n    CRITICAL_SECTION waiters_count_lock;\n    HANDLE signal_event;\n    HANDLE broadcast_event;\n  } fallback;\n} uv_cond_t;\n\ntypedef union {\n  struct {\n    unsigned int num_readers_;\n    CRITICAL_SECTION num_readers_lock_;\n    HANDLE write_semaphore_;\n  } state_;\n  /* TODO: remove me in v2.x. */\n  struct {\n    SRWLOCK unused_;\n  } unused1_;\n  /* TODO: remove me in v2.x. */\n  struct {\n    uv_mutex_t unused1_;\n    uv_mutex_t unused2_;\n  } unused2_;\n} uv_rwlock_t;\n\ntypedef struct {\n  unsigned int n;\n  unsigned int count;\n  uv_mutex_t mutex;\n  uv_sem_t turnstile1;\n  uv_sem_t turnstile2;\n} uv_barrier_t;\n\ntypedef struct {\n  DWORD tls_index;\n} uv_key_t;\n\n#define UV_ONCE_INIT { 0, NULL }\n\ntypedef struct uv_once_s {\n  unsigned char ran;\n  HANDLE event;\n} uv_once_t;\n\n/* Platform-specific definitions for uv_spawn support. */\ntypedef unsigned char uv_uid_t;\ntypedef unsigned char uv_gid_t;\n\ntypedef struct uv__dirent_s {\n  int d_type;\n  char d_name[1];\n} uv__dirent_t;\n\n#define HAVE_DIRENT_TYPES\n#define UV__DT_DIR     UV_DIRENT_DIR\n#define UV__DT_FILE    UV_DIRENT_FILE\n#define UV__DT_LINK    UV_DIRENT_LINK\n#define UV__DT_FIFO    UV_DIRENT_FIFO\n#define UV__DT_SOCKET  UV_DIRENT_SOCKET\n#define UV__DT_CHAR    UV_DIRENT_CHAR\n#define UV__DT_BLOCK   UV_DIRENT_BLOCK\n\n/* Platform-specific definitions for uv_dlopen support. */\n#define UV_DYNAMIC FAR WINAPI\ntypedef struct {\n  HMODULE handle;\n  char* errmsg;\n} uv_lib_t;\n\nRB_HEAD(uv_timer_tree_s, uv_timer_s);\n\n#define UV_LOOP_PRIVATE_FIELDS                                                \\\n    /* The loop's I/O completion port */                                      \\\n  HANDLE iocp;                                                                \\\n  /* The current time according to the event loop. in msecs. */               \\\n  uint64_t time;                                                              \\\n  /* Tail of a single-linked circular queue of pending reqs. If the queue */  \\\n  /* is empty, tail_ is NULL. If there is only one item, */                   \\\n  /* tail_->next_req == tail_ */                                              \\\n  uv_req_t* pending_reqs_tail;                                                \\\n  /* Head of a single-linked list of closed handles */                        \\\n  uv_handle_t* endgame_handles;                                               \\\n  /* The head of the timers tree */                                           \\\n  struct uv_timer_tree_s timers;                                              \\\n    /* Lists of active loop (prepare / check / idle) watchers */              \\\n  uv_prepare_t* prepare_handles;                                              \\\n  uv_check_t* check_handles;                                                  \\\n  uv_idle_t* idle_handles;                                                    \\\n  /* This pointer will refer to the prepare/check/idle handle whose */        \\\n  /* callback is scheduled to be called next. This is needed to allow */      \\\n  /* safe removal from one of the lists above while that list being */        \\\n  /* iterated over. */                                                        \\\n  uv_prepare_t* next_prepare_handle;                                          \\\n  uv_check_t* next_check_handle;                                              \\\n  uv_idle_t* next_idle_handle;                                                \\\n  /* This handle holds the peer sockets for the fast variant of uv_poll_t */  \\\n  SOCKET poll_peer_sockets[UV_MSAFD_PROVIDER_COUNT];                          \\\n  /* Counter to keep track of active tcp streams */                           \\\n  unsigned int active_tcp_streams;                                            \\\n  /* Counter to keep track of active udp streams */                           \\\n  unsigned int active_udp_streams;                                            \\\n  /* Counter to started timer */                                              \\\n  uint64_t timer_counter;                                                     \\\n  /* Threadpool */                                                            \\\n  void* wq[2];                                                                \\\n  uv_mutex_t wq_mutex;                                                        \\\n  uv_async_t wq_async;\n\n#define UV_REQ_TYPE_PRIVATE                                                   \\\n  /* TODO: remove the req suffix */                                           \\\n  UV_ACCEPT,                                                                  \\\n  UV_FS_EVENT_REQ,                                                            \\\n  UV_POLL_REQ,                                                                \\\n  UV_PROCESS_EXIT,                                                            \\\n  UV_READ,                                                                    \\\n  UV_UDP_RECV,                                                                \\\n  UV_WAKEUP,                                                                  \\\n  UV_SIGNAL_REQ,\n\n#define UV_REQ_PRIVATE_FIELDS                                                 \\\n  union {                                                                     \\\n    /* Used by I/O operations */                                              \\\n    struct {                                                                  \\\n      OVERLAPPED overlapped;                                                  \\\n      size_t queued_bytes;                                                    \\\n    } io;                                                                     \\\n  } u;                                                                        \\\n  struct uv_req_s* next_req;\n\n#define UV_WRITE_PRIVATE_FIELDS                                               \\\n  int ipc_header;                                                             \\\n  uv_buf_t write_buffer;                                                      \\\n  HANDLE event_handle;                                                        \\\n  HANDLE wait_handle;\n\n#define UV_CONNECT_PRIVATE_FIELDS                                             \\\n  /* empty */\n\n#define UV_SHUTDOWN_PRIVATE_FIELDS                                            \\\n  /* empty */\n\n#define UV_UDP_SEND_PRIVATE_FIELDS                                            \\\n  /* empty */\n\n#define UV_PRIVATE_REQ_TYPES                                                  \\\n  typedef struct uv_pipe_accept_s {                                           \\\n    UV_REQ_FIELDS                                                             \\\n    HANDLE pipeHandle;                                                        \\\n    struct uv_pipe_accept_s* next_pending;                                    \\\n  } uv_pipe_accept_t;                                                         \\\n                                                                              \\\n  typedef struct uv_tcp_accept_s {                                            \\\n    UV_REQ_FIELDS                                                             \\\n    SOCKET accept_socket;                                                     \\\n    char accept_buffer[sizeof(struct sockaddr_storage) * 2 + 32];             \\\n    HANDLE event_handle;                                                      \\\n    HANDLE wait_handle;                                                       \\\n    struct uv_tcp_accept_s* next_pending;                                     \\\n  } uv_tcp_accept_t;                                                          \\\n                                                                              \\\n  typedef struct uv_read_s {                                                  \\\n    UV_REQ_FIELDS                                                             \\\n    HANDLE event_handle;                                                      \\\n    HANDLE wait_handle;                                                       \\\n  } uv_read_t;\n\n#define uv_stream_connection_fields                                           \\\n  unsigned int write_reqs_pending;                                            \\\n  uv_shutdown_t* shutdown_req;\n\n#define uv_stream_server_fields                                               \\\n  uv_connection_cb connection_cb;\n\n#define UV_STREAM_PRIVATE_FIELDS                                              \\\n  unsigned int reqs_pending;                                                  \\\n  int activecnt;                                                              \\\n  uv_read_t read_req;                                                         \\\n  union {                                                                     \\\n    struct { uv_stream_connection_fields } conn;                              \\\n    struct { uv_stream_server_fields     } serv;                              \\\n  } stream;\n\n#define uv_tcp_server_fields                                                  \\\n  uv_tcp_accept_t* accept_reqs;                                               \\\n  unsigned int processed_accepts;                                             \\\n  uv_tcp_accept_t* pending_accepts;                                           \\\n  LPFN_ACCEPTEX func_acceptex;\n\n#define uv_tcp_connection_fields                                              \\\n  uv_buf_t read_buffer;                                                       \\\n  LPFN_CONNECTEX func_connectex;\n\n#define UV_TCP_PRIVATE_FIELDS                                                 \\\n  SOCKET socket;                                                              \\\n  int delayed_error;                                                          \\\n  union {                                                                     \\\n    struct { uv_tcp_server_fields } serv;                                     \\\n    struct { uv_tcp_connection_fields } conn;                                 \\\n  } tcp;\n\n#define UV_UDP_PRIVATE_FIELDS                                                 \\\n  SOCKET socket;                                                              \\\n  unsigned int reqs_pending;                                                  \\\n  int activecnt;                                                              \\\n  uv_req_t recv_req;                                                          \\\n  uv_buf_t recv_buffer;                                                       \\\n  struct sockaddr_storage recv_from;                                          \\\n  int recv_from_len;                                                          \\\n  uv_udp_recv_cb recv_cb;                                                     \\\n  uv_alloc_cb alloc_cb;                                                       \\\n  LPFN_WSARECV func_wsarecv;                                                  \\\n  LPFN_WSARECVFROM func_wsarecvfrom;\n\n#define uv_pipe_server_fields                                                 \\\n  int pending_instances;                                                      \\\n  uv_pipe_accept_t* accept_reqs;                                              \\\n  uv_pipe_accept_t* pending_accepts;\n\n#define uv_pipe_connection_fields                                             \\\n  uv_timer_t* eof_timer;                                                      \\\n  uv_write_t ipc_header_write_req;                                            \\\n  int ipc_pid;                                                                \\\n  uint64_t remaining_ipc_rawdata_bytes;                                       \\\n  struct {                                                                    \\\n    void* queue[2];                                                           \\\n    int queue_len;                                                            \\\n  } pending_ipc_info;                                                         \\\n  uv_write_t* non_overlapped_writes_tail;                                     \\\n  uv_mutex_t readfile_mutex;                                                  \\\n  volatile HANDLE readfile_thread;\n\n#define UV_PIPE_PRIVATE_FIELDS                                                \\\n  HANDLE handle;                                                              \\\n  WCHAR* name;                                                                \\\n  union {                                                                     \\\n    struct { uv_pipe_server_fields } serv;                                    \\\n    struct { uv_pipe_connection_fields } conn;                                \\\n  } pipe;\n\n/* TODO: put the parser states in an union - TTY handles are always */\n/* half-duplex so read-state can safely overlap write-state. */\n#define UV_TTY_PRIVATE_FIELDS                                                 \\\n  HANDLE handle;                                                              \\\n  union {                                                                     \\\n    struct {                                                                  \\\n      /* Used for readable TTY handles */                                     \\\n      /* TODO: remove me in v2.x. */                                          \\\n      HANDLE unused_;                                                         \\\n      uv_buf_t read_line_buffer;                                              \\\n      HANDLE read_raw_wait;                                                   \\\n      /* Fields used for translating win keystrokes into vt100 characters */  \\\n      char last_key[8];                                                       \\\n      unsigned char last_key_offset;                                          \\\n      unsigned char last_key_len;                                             \\\n      WCHAR last_utf16_high_surrogate;                                        \\\n      INPUT_RECORD last_input_record;                                         \\\n    } rd;                                                                     \\\n    struct {                                                                  \\\n      /* Used for writable TTY handles */                                     \\\n      /* utf8-to-utf16 conversion state */                                    \\\n      unsigned int utf8_codepoint;                                            \\\n      unsigned char utf8_bytes_left;                                          \\\n      /* eol conversion state */                                              \\\n      unsigned char previous_eol;                                             \\\n      /* ansi parser state */                                                 \\\n      unsigned char ansi_parser_state;                                        \\\n      unsigned char ansi_csi_argc;                                            \\\n      unsigned short ansi_csi_argv[4];                                        \\\n      COORD saved_position;                                                   \\\n      WORD saved_attributes;                                                  \\\n    } wr;                                                                     \\\n  } tty;\n\n#define UV_POLL_PRIVATE_FIELDS                                                \\\n  SOCKET socket;                                                              \\\n  /* Used in fast mode */                                                     \\\n  SOCKET peer_socket;                                                         \\\n  AFD_POLL_INFO afd_poll_info_1;                                              \\\n  AFD_POLL_INFO afd_poll_info_2;                                              \\\n  /* Used in fast and slow mode. */                                           \\\n  uv_req_t poll_req_1;                                                        \\\n  uv_req_t poll_req_2;                                                        \\\n  unsigned char submitted_events_1;                                           \\\n  unsigned char submitted_events_2;                                           \\\n  unsigned char mask_events_1;                                                \\\n  unsigned char mask_events_2;                                                \\\n  unsigned char events;\n\n#define UV_TIMER_PRIVATE_FIELDS                                               \\\n  RB_ENTRY(uv_timer_s) tree_entry;                                            \\\n  uint64_t due;                                                               \\\n  uint64_t repeat;                                                            \\\n  uint64_t start_id;                                                          \\\n  uv_timer_cb timer_cb;\n\n#define UV_ASYNC_PRIVATE_FIELDS                                               \\\n  struct uv_req_s async_req;                                                  \\\n  uv_async_cb async_cb;                                                       \\\n  /* char to avoid alignment issues */                                        \\\n  char volatile async_sent;\n\n#define UV_PREPARE_PRIVATE_FIELDS                                             \\\n  uv_prepare_t* prepare_prev;                                                 \\\n  uv_prepare_t* prepare_next;                                                 \\\n  uv_prepare_cb prepare_cb;\n\n#define UV_CHECK_PRIVATE_FIELDS                                               \\\n  uv_check_t* check_prev;                                                     \\\n  uv_check_t* check_next;                                                     \\\n  uv_check_cb check_cb;\n\n#define UV_IDLE_PRIVATE_FIELDS                                                \\\n  uv_idle_t* idle_prev;                                                       \\\n  uv_idle_t* idle_next;                                                       \\\n  uv_idle_cb idle_cb;\n\n#define UV_HANDLE_PRIVATE_FIELDS                                              \\\n  uv_handle_t* endgame_next;                                                  \\\n  unsigned int flags;\n\n#define UV_GETADDRINFO_PRIVATE_FIELDS                                         \\\n  struct uv__work work_req;                                                   \\\n  uv_getaddrinfo_cb getaddrinfo_cb;                                           \\\n  void* alloc;                                                                \\\n  WCHAR* node;                                                                \\\n  WCHAR* service;                                                             \\\n  /* The addrinfoW field is used to store a pointer to the hints, and    */   \\\n  /* later on to store the result of GetAddrInfoW. The final result will */   \\\n  /* be converted to struct addrinfo* and stored in the addrinfo field.  */   \\\n  struct addrinfoW* addrinfow;                                                \\\n  struct addrinfo* addrinfo;                                                  \\\n  int retcode;\n\n#define UV_GETNAMEINFO_PRIVATE_FIELDS                                         \\\n  struct uv__work work_req;                                                   \\\n  uv_getnameinfo_cb getnameinfo_cb;                                           \\\n  struct sockaddr_storage storage;                                            \\\n  int flags;                                                                  \\\n  char host[NI_MAXHOST];                                                      \\\n  char service[NI_MAXSERV];                                                   \\\n  int retcode;\n\n#define UV_PROCESS_PRIVATE_FIELDS                                             \\\n  struct uv_process_exit_s {                                                  \\\n    UV_REQ_FIELDS                                                             \\\n  } exit_req;                                                                 \\\n  BYTE* child_stdio_buffer;                                                   \\\n  int exit_signal;                                                            \\\n  HANDLE wait_handle;                                                         \\\n  HANDLE process_handle;                                                      \\\n  volatile char exit_cb_pending;\n\n#define UV_FS_PRIVATE_FIELDS                                                  \\\n  struct uv__work work_req;                                                   \\\n  int flags;                                                                  \\\n  DWORD sys_errno_;                                                           \\\n  union {                                                                     \\\n    /* TODO: remove me in 0.9. */                                             \\\n    WCHAR* pathw;                                                             \\\n    int fd;                                                                   \\\n  } file;                                                                     \\\n  union {                                                                     \\\n    struct {                                                                  \\\n      int mode;                                                               \\\n      WCHAR* new_pathw;                                                       \\\n      int file_flags;                                                         \\\n      int fd_out;                                                             \\\n      unsigned int nbufs;                                                     \\\n      uv_buf_t* bufs;                                                         \\\n      int64_t offset;                                                         \\\n      uv_buf_t bufsml[4];                                                     \\\n    } info;                                                                   \\\n    struct {                                                                  \\\n      double atime;                                                           \\\n      double mtime;                                                           \\\n    } time;                                                                   \\\n  } fs;\n\n#define UV_WORK_PRIVATE_FIELDS                                                \\\n  struct uv__work work_req;\n\n#define UV_FS_EVENT_PRIVATE_FIELDS                                            \\\n  struct uv_fs_event_req_s {                                                  \\\n    UV_REQ_FIELDS                                                             \\\n  } req;                                                                      \\\n  HANDLE dir_handle;                                                          \\\n  int req_pending;                                                            \\\n  uv_fs_event_cb cb;                                                          \\\n  WCHAR* filew;                                                               \\\n  WCHAR* short_filew;                                                         \\\n  WCHAR* dirw;                                                                \\\n  char* buffer;\n\n#define UV_SIGNAL_PRIVATE_FIELDS                                              \\\n  RB_ENTRY(uv_signal_s) tree_entry;                                           \\\n  struct uv_req_s signal_req;                                                 \\\n  unsigned long pending_signum;\n\n#ifndef F_OK\n#define F_OK 0\n#endif\n#ifndef R_OK\n#define R_OK 4\n#endif\n#ifndef W_OK\n#define W_OK 2\n#endif\n#ifndef X_OK\n#define X_OK 1\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-libuv-1.10.0-tvkoat5vslbctz2afzq2jzqjvgrpibgh/spack-src/include/uv.h": "/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\n/* See https://github.com/libuv/libuv#documentation for documentation. */\n\n#ifndef UV_H\n#define UV_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#ifdef _WIN32\n  /* Windows - set up dll import/export decorators. */\n# if defined(BUILDING_UV_SHARED)\n    /* Building shared library. */\n#   define UV_EXTERN __declspec(dllexport)\n# elif defined(USING_UV_SHARED)\n    /* Using shared library. */\n#   define UV_EXTERN __declspec(dllimport)\n# else\n    /* Building static library. */\n#   define UV_EXTERN /* nothing */\n# endif\n#elif __GNUC__ >= 4\n# define UV_EXTERN __attribute__((visibility(\"default\")))\n#else\n# define UV_EXTERN /* nothing */\n#endif\n\n#include \"uv-errno.h\"\n#include \"uv-version.h\"\n#include <stddef.h>\n#include <stdio.h>\n\n#if defined(_MSC_VER) && _MSC_VER < 1600\n# include \"stdint-msvc2008.h\"\n#else\n# include <stdint.h>\n#endif\n\n#if defined(_WIN32)\n# include \"uv-win.h\"\n#else\n# include \"uv-unix.h\"\n#endif\n\n/* Expand this list if necessary. */\n#define UV_ERRNO_MAP(XX)                                                      \\\n  XX(E2BIG, \"argument list too long\")                                         \\\n  XX(EACCES, \"permission denied\")                                             \\\n  XX(EADDRINUSE, \"address already in use\")                                    \\\n  XX(EADDRNOTAVAIL, \"address not available\")                                  \\\n  XX(EAFNOSUPPORT, \"address family not supported\")                            \\\n  XX(EAGAIN, \"resource temporarily unavailable\")                              \\\n  XX(EAI_ADDRFAMILY, \"address family not supported\")                          \\\n  XX(EAI_AGAIN, \"temporary failure\")                                          \\\n  XX(EAI_BADFLAGS, \"bad ai_flags value\")                                      \\\n  XX(EAI_BADHINTS, \"invalid value for hints\")                                 \\\n  XX(EAI_CANCELED, \"request canceled\")                                        \\\n  XX(EAI_FAIL, \"permanent failure\")                                           \\\n  XX(EAI_FAMILY, \"ai_family not supported\")                                   \\\n  XX(EAI_MEMORY, \"out of memory\")                                             \\\n  XX(EAI_NODATA, \"no address\")                                                \\\n  XX(EAI_NONAME, \"unknown node or service\")                                   \\\n  XX(EAI_OVERFLOW, \"argument buffer overflow\")                                \\\n  XX(EAI_PROTOCOL, \"resolved protocol is unknown\")                            \\\n  XX(EAI_SERVICE, \"service not available for socket type\")                    \\\n  XX(EAI_SOCKTYPE, \"socket type not supported\")                               \\\n  XX(EALREADY, \"connection already in progress\")                              \\\n  XX(EBADF, \"bad file descriptor\")                                            \\\n  XX(EBUSY, \"resource busy or locked\")                                        \\\n  XX(ECANCELED, \"operation canceled\")                                         \\\n  XX(ECHARSET, \"invalid Unicode character\")                                   \\\n  XX(ECONNABORTED, \"software caused connection abort\")                        \\\n  XX(ECONNREFUSED, \"connection refused\")                                      \\\n  XX(ECONNRESET, \"connection reset by peer\")                                  \\\n  XX(EDESTADDRREQ, \"destination address required\")                            \\\n  XX(EEXIST, \"file already exists\")                                           \\\n  XX(EFAULT, \"bad address in system call argument\")                           \\\n  XX(EFBIG, \"file too large\")                                                 \\\n  XX(EHOSTUNREACH, \"host is unreachable\")                                     \\\n  XX(EINTR, \"interrupted system call\")                                        \\\n  XX(EINVAL, \"invalid argument\")                                              \\\n  XX(EIO, \"i/o error\")                                                        \\\n  XX(EISCONN, \"socket is already connected\")                                  \\\n  XX(EISDIR, \"illegal operation on a directory\")                              \\\n  XX(ELOOP, \"too many symbolic links encountered\")                            \\\n  XX(EMFILE, \"too many open files\")                                           \\\n  XX(EMSGSIZE, \"message too long\")                                            \\\n  XX(ENAMETOOLONG, \"name too long\")                                           \\\n  XX(ENETDOWN, \"network is down\")                                             \\\n  XX(ENETUNREACH, \"network is unreachable\")                                   \\\n  XX(ENFILE, \"file table overflow\")                                           \\\n  XX(ENOBUFS, \"no buffer space available\")                                    \\\n  XX(ENODEV, \"no such device\")                                                \\\n  XX(ENOENT, \"no such file or directory\")                                     \\\n  XX(ENOMEM, \"not enough memory\")                                             \\\n  XX(ENONET, \"machine is not on the network\")                                 \\\n  XX(ENOPROTOOPT, \"protocol not available\")                                   \\\n  XX(ENOSPC, \"no space left on device\")                                       \\\n  XX(ENOSYS, \"function not implemented\")                                      \\\n  XX(ENOTCONN, \"socket is not connected\")                                     \\\n  XX(ENOTDIR, \"not a directory\")                                              \\\n  XX(ENOTEMPTY, \"directory not empty\")                                        \\\n  XX(ENOTSOCK, \"socket operation on non-socket\")                              \\\n  XX(ENOTSUP, \"operation not supported on socket\")                            \\\n  XX(EPERM, \"operation not permitted\")                                        \\\n  XX(EPIPE, \"broken pipe\")                                                    \\\n  XX(EPROTO, \"protocol error\")                                                \\\n  XX(EPROTONOSUPPORT, \"protocol not supported\")                               \\\n  XX(EPROTOTYPE, \"protocol wrong type for socket\")                            \\\n  XX(ERANGE, \"result too large\")                                              \\\n  XX(EROFS, \"read-only file system\")                                          \\\n  XX(ESHUTDOWN, \"cannot send after transport endpoint shutdown\")              \\\n  XX(ESPIPE, \"invalid seek\")                                                  \\\n  XX(ESRCH, \"no such process\")                                                \\\n  XX(ETIMEDOUT, \"connection timed out\")                                       \\\n  XX(ETXTBSY, \"text file is busy\")                                            \\\n  XX(EXDEV, \"cross-device link not permitted\")                                \\\n  XX(UNKNOWN, \"unknown error\")                                                \\\n  XX(EOF, \"end of file\")                                                      \\\n  XX(ENXIO, \"no such device or address\")                                      \\\n  XX(EMLINK, \"too many links\")                                                \\\n  XX(EHOSTDOWN, \"host is down\")                                               \\\n\n#define UV_HANDLE_TYPE_MAP(XX)                                                \\\n  XX(ASYNC, async)                                                            \\\n  XX(CHECK, check)                                                            \\\n  XX(FS_EVENT, fs_event)                                                      \\\n  XX(FS_POLL, fs_poll)                                                        \\\n  XX(HANDLE, handle)                                                          \\\n  XX(IDLE, idle)                                                              \\\n  XX(NAMED_PIPE, pipe)                                                        \\\n  XX(POLL, poll)                                                              \\\n  XX(PREPARE, prepare)                                                        \\\n  XX(PROCESS, process)                                                        \\\n  XX(STREAM, stream)                                                          \\\n  XX(TCP, tcp)                                                                \\\n  XX(TIMER, timer)                                                            \\\n  XX(TTY, tty)                                                                \\\n  XX(UDP, udp)                                                                \\\n  XX(SIGNAL, signal)                                                          \\\n\n#define UV_REQ_TYPE_MAP(XX)                                                   \\\n  XX(REQ, req)                                                                \\\n  XX(CONNECT, connect)                                                        \\\n  XX(WRITE, write)                                                            \\\n  XX(SHUTDOWN, shutdown)                                                      \\\n  XX(UDP_SEND, udp_send)                                                      \\\n  XX(FS, fs)                                                                  \\\n  XX(WORK, work)                                                              \\\n  XX(GETADDRINFO, getaddrinfo)                                                \\\n  XX(GETNAMEINFO, getnameinfo)                                                \\\n\ntypedef enum {\n#define XX(code, _) UV_ ## code = UV__ ## code,\n  UV_ERRNO_MAP(XX)\n#undef XX\n  UV_ERRNO_MAX = UV__EOF - 1\n} uv_errno_t;\n\ntypedef enum {\n  UV_UNKNOWN_HANDLE = 0,\n#define XX(uc, lc) UV_##uc,\n  UV_HANDLE_TYPE_MAP(XX)\n#undef XX\n  UV_FILE,\n  UV_HANDLE_TYPE_MAX\n} uv_handle_type;\n\ntypedef enum {\n  UV_UNKNOWN_REQ = 0,\n#define XX(uc, lc) UV_##uc,\n  UV_REQ_TYPE_MAP(XX)\n#undef XX\n  UV_REQ_TYPE_PRIVATE\n  UV_REQ_TYPE_MAX\n} uv_req_type;\n\n\n/* Handle types. */\ntypedef struct uv_loop_s uv_loop_t;\ntypedef struct uv_handle_s uv_handle_t;\ntypedef struct uv_stream_s uv_stream_t;\ntypedef struct uv_tcp_s uv_tcp_t;\ntypedef struct uv_udp_s uv_udp_t;\ntypedef struct uv_pipe_s uv_pipe_t;\ntypedef struct uv_tty_s uv_tty_t;\ntypedef struct uv_poll_s uv_poll_t;\ntypedef struct uv_timer_s uv_timer_t;\ntypedef struct uv_prepare_s uv_prepare_t;\ntypedef struct uv_check_s uv_check_t;\ntypedef struct uv_idle_s uv_idle_t;\ntypedef struct uv_async_s uv_async_t;\ntypedef struct uv_process_s uv_process_t;\ntypedef struct uv_fs_event_s uv_fs_event_t;\ntypedef struct uv_fs_poll_s uv_fs_poll_t;\ntypedef struct uv_signal_s uv_signal_t;\n\n/* Request types. */\ntypedef struct uv_req_s uv_req_t;\ntypedef struct uv_getaddrinfo_s uv_getaddrinfo_t;\ntypedef struct uv_getnameinfo_s uv_getnameinfo_t;\ntypedef struct uv_shutdown_s uv_shutdown_t;\ntypedef struct uv_write_s uv_write_t;\ntypedef struct uv_connect_s uv_connect_t;\ntypedef struct uv_udp_send_s uv_udp_send_t;\ntypedef struct uv_fs_s uv_fs_t;\ntypedef struct uv_work_s uv_work_t;\n\n/* None of the above. */\ntypedef struct uv_cpu_info_s uv_cpu_info_t;\ntypedef struct uv_interface_address_s uv_interface_address_t;\ntypedef struct uv_dirent_s uv_dirent_t;\ntypedef struct uv_passwd_s uv_passwd_t;\n\ntypedef enum {\n  UV_LOOP_BLOCK_SIGNAL\n} uv_loop_option;\n\ntypedef enum {\n  UV_RUN_DEFAULT = 0,\n  UV_RUN_ONCE,\n  UV_RUN_NOWAIT\n} uv_run_mode;\n\n\nUV_EXTERN unsigned int uv_version(void);\nUV_EXTERN const char* uv_version_string(void);\n\ntypedef void* (*uv_malloc_func)(size_t size);\ntypedef void* (*uv_realloc_func)(void* ptr, size_t size);\ntypedef void* (*uv_calloc_func)(size_t count, size_t size);\ntypedef void (*uv_free_func)(void* ptr);\n\nUV_EXTERN int uv_replace_allocator(uv_malloc_func malloc_func,\n                                   uv_realloc_func realloc_func,\n                                   uv_calloc_func calloc_func,\n                                   uv_free_func free_func);\n\nUV_EXTERN uv_loop_t* uv_default_loop(void);\nUV_EXTERN int uv_loop_init(uv_loop_t* loop);\nUV_EXTERN int uv_loop_close(uv_loop_t* loop);\n/*\n * NOTE:\n *  This function is DEPRECATED (to be removed after 0.12), users should\n *  allocate the loop manually and use uv_loop_init instead.\n */\nUV_EXTERN uv_loop_t* uv_loop_new(void);\n/*\n * NOTE:\n *  This function is DEPRECATED (to be removed after 0.12). Users should use\n *  uv_loop_close and free the memory manually instead.\n */\nUV_EXTERN void uv_loop_delete(uv_loop_t*);\nUV_EXTERN size_t uv_loop_size(void);\nUV_EXTERN int uv_loop_alive(const uv_loop_t* loop);\nUV_EXTERN int uv_loop_configure(uv_loop_t* loop, uv_loop_option option, ...);\n\nUV_EXTERN int uv_run(uv_loop_t*, uv_run_mode mode);\nUV_EXTERN void uv_stop(uv_loop_t*);\n\nUV_EXTERN void uv_ref(uv_handle_t*);\nUV_EXTERN void uv_unref(uv_handle_t*);\nUV_EXTERN int uv_has_ref(const uv_handle_t*);\n\nUV_EXTERN void uv_update_time(uv_loop_t*);\nUV_EXTERN uint64_t uv_now(const uv_loop_t*);\n\nUV_EXTERN int uv_backend_fd(const uv_loop_t*);\nUV_EXTERN int uv_backend_timeout(const uv_loop_t*);\n\ntypedef void (*uv_alloc_cb)(uv_handle_t* handle,\n                            size_t suggested_size,\n                            uv_buf_t* buf);\ntypedef void (*uv_read_cb)(uv_stream_t* stream,\n                           ssize_t nread,\n                           const uv_buf_t* buf);\ntypedef void (*uv_write_cb)(uv_write_t* req, int status);\ntypedef void (*uv_connect_cb)(uv_connect_t* req, int status);\ntypedef void (*uv_shutdown_cb)(uv_shutdown_t* req, int status);\ntypedef void (*uv_connection_cb)(uv_stream_t* server, int status);\ntypedef void (*uv_close_cb)(uv_handle_t* handle);\ntypedef void (*uv_poll_cb)(uv_poll_t* handle, int status, int events);\ntypedef void (*uv_timer_cb)(uv_timer_t* handle);\ntypedef void (*uv_async_cb)(uv_async_t* handle);\ntypedef void (*uv_prepare_cb)(uv_prepare_t* handle);\ntypedef void (*uv_check_cb)(uv_check_t* handle);\ntypedef void (*uv_idle_cb)(uv_idle_t* handle);\ntypedef void (*uv_exit_cb)(uv_process_t*, int64_t exit_status, int term_signal);\ntypedef void (*uv_walk_cb)(uv_handle_t* handle, void* arg);\ntypedef void (*uv_fs_cb)(uv_fs_t* req);\ntypedef void (*uv_work_cb)(uv_work_t* req);\ntypedef void (*uv_after_work_cb)(uv_work_t* req, int status);\ntypedef void (*uv_getaddrinfo_cb)(uv_getaddrinfo_t* req,\n                                  int status,\n                                  struct addrinfo* res);\ntypedef void (*uv_getnameinfo_cb)(uv_getnameinfo_t* req,\n                                  int status,\n                                  const char* hostname,\n                                  const char* service);\n\ntypedef struct {\n  long tv_sec;\n  long tv_nsec;\n} uv_timespec_t;\n\n\ntypedef struct {\n  uint64_t st_dev;\n  uint64_t st_mode;\n  uint64_t st_nlink;\n  uint64_t st_uid;\n  uint64_t st_gid;\n  uint64_t st_rdev;\n  uint64_t st_ino;\n  uint64_t st_size;\n  uint64_t st_blksize;\n  uint64_t st_blocks;\n  uint64_t st_flags;\n  uint64_t st_gen;\n  uv_timespec_t st_atim;\n  uv_timespec_t st_mtim;\n  uv_timespec_t st_ctim;\n  uv_timespec_t st_birthtim;\n} uv_stat_t;\n\n\ntypedef void (*uv_fs_event_cb)(uv_fs_event_t* handle,\n                               const char* filename,\n                               int events,\n                               int status);\n\ntypedef void (*uv_fs_poll_cb)(uv_fs_poll_t* handle,\n                              int status,\n                              const uv_stat_t* prev,\n                              const uv_stat_t* curr);\n\ntypedef void (*uv_signal_cb)(uv_signal_t* handle, int signum);\n\n\ntypedef enum {\n  UV_LEAVE_GROUP = 0,\n  UV_JOIN_GROUP\n} uv_membership;\n\n\nUV_EXTERN int uv_translate_sys_error(int sys_errno);\n\nUV_EXTERN const char* uv_strerror(int err);\nUV_EXTERN const char* uv_err_name(int err);\n\n\n#define UV_REQ_FIELDS                                                         \\\n  /* public */                                                                \\\n  void* data;                                                                 \\\n  /* read-only */                                                             \\\n  uv_req_type type;                                                           \\\n  /* private */                                                               \\\n  void* active_queue[2];                                                      \\\n  void* reserved[4];                                                          \\\n  UV_REQ_PRIVATE_FIELDS                                                       \\\n\n/* Abstract base class of all requests. */\nstruct uv_req_s {\n  UV_REQ_FIELDS\n};\n\n\n/* Platform-specific request types. */\nUV_PRIVATE_REQ_TYPES\n\n\nUV_EXTERN int uv_shutdown(uv_shutdown_t* req,\n                          uv_stream_t* handle,\n                          uv_shutdown_cb cb);\n\nstruct uv_shutdown_s {\n  UV_REQ_FIELDS\n  uv_stream_t* handle;\n  uv_shutdown_cb cb;\n  UV_SHUTDOWN_PRIVATE_FIELDS\n};\n\n\n#define UV_HANDLE_FIELDS                                                      \\\n  /* public */                                                                \\\n  void* data;                                                                 \\\n  /* read-only */                                                             \\\n  uv_loop_t* loop;                                                            \\\n  uv_handle_type type;                                                        \\\n  /* private */                                                               \\\n  uv_close_cb close_cb;                                                       \\\n  void* handle_queue[2];                                                      \\\n  union {                                                                     \\\n    int fd;                                                                   \\\n    void* reserved[4];                                                        \\\n  } u;                                                                        \\\n  UV_HANDLE_PRIVATE_FIELDS                                                    \\\n\n/* The abstract base class of all handles. */\nstruct uv_handle_s {\n  UV_HANDLE_FIELDS\n};\n\nUV_EXTERN size_t uv_handle_size(uv_handle_type type);\nUV_EXTERN size_t uv_req_size(uv_req_type type);\n\nUV_EXTERN int uv_is_active(const uv_handle_t* handle);\n\nUV_EXTERN void uv_walk(uv_loop_t* loop, uv_walk_cb walk_cb, void* arg);\n\n/* Helpers for ad hoc debugging, no API/ABI stability guaranteed. */\nUV_EXTERN void uv_print_all_handles(uv_loop_t* loop, FILE* stream);\nUV_EXTERN void uv_print_active_handles(uv_loop_t* loop, FILE* stream);\n\nUV_EXTERN void uv_close(uv_handle_t* handle, uv_close_cb close_cb);\n\nUV_EXTERN int uv_send_buffer_size(uv_handle_t* handle, int* value);\nUV_EXTERN int uv_recv_buffer_size(uv_handle_t* handle, int* value);\n\nUV_EXTERN int uv_fileno(const uv_handle_t* handle, uv_os_fd_t* fd);\n\nUV_EXTERN uv_buf_t uv_buf_init(char* base, unsigned int len);\n\n\n#define UV_STREAM_FIELDS                                                      \\\n  /* number of bytes queued for writing */                                    \\\n  size_t write_queue_size;                                                    \\\n  uv_alloc_cb alloc_cb;                                                       \\\n  uv_read_cb read_cb;                                                         \\\n  /* private */                                                               \\\n  UV_STREAM_PRIVATE_FIELDS\n\n/*\n * uv_stream_t is a subclass of uv_handle_t.\n *\n * uv_stream is an abstract class.\n *\n * uv_stream_t is the parent class of uv_tcp_t, uv_pipe_t and uv_tty_t.\n */\nstruct uv_stream_s {\n  UV_HANDLE_FIELDS\n  UV_STREAM_FIELDS\n};\n\nUV_EXTERN int uv_listen(uv_stream_t* stream, int backlog, uv_connection_cb cb);\nUV_EXTERN int uv_accept(uv_stream_t* server, uv_stream_t* client);\n\nUV_EXTERN int uv_read_start(uv_stream_t*,\n                            uv_alloc_cb alloc_cb,\n                            uv_read_cb read_cb);\nUV_EXTERN int uv_read_stop(uv_stream_t*);\n\nUV_EXTERN int uv_write(uv_write_t* req,\n                       uv_stream_t* handle,\n                       const uv_buf_t bufs[],\n                       unsigned int nbufs,\n                       uv_write_cb cb);\nUV_EXTERN int uv_write2(uv_write_t* req,\n                        uv_stream_t* handle,\n                        const uv_buf_t bufs[],\n                        unsigned int nbufs,\n                        uv_stream_t* send_handle,\n                        uv_write_cb cb);\nUV_EXTERN int uv_try_write(uv_stream_t* handle,\n                           const uv_buf_t bufs[],\n                           unsigned int nbufs);\n\n/* uv_write_t is a subclass of uv_req_t. */\nstruct uv_write_s {\n  UV_REQ_FIELDS\n  uv_write_cb cb;\n  uv_stream_t* send_handle;\n  uv_stream_t* handle;\n  UV_WRITE_PRIVATE_FIELDS\n};\n\n\nUV_EXTERN int uv_is_readable(const uv_stream_t* handle);\nUV_EXTERN int uv_is_writable(const uv_stream_t* handle);\n\nUV_EXTERN int uv_stream_set_blocking(uv_stream_t* handle, int blocking);\n\nUV_EXTERN int uv_is_closing(const uv_handle_t* handle);\n\n\n/*\n * uv_tcp_t is a subclass of uv_stream_t.\n *\n * Represents a TCP stream or TCP server.\n */\nstruct uv_tcp_s {\n  UV_HANDLE_FIELDS\n  UV_STREAM_FIELDS\n  UV_TCP_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_tcp_init(uv_loop_t*, uv_tcp_t* handle);\nUV_EXTERN int uv_tcp_init_ex(uv_loop_t*, uv_tcp_t* handle, unsigned int flags);\nUV_EXTERN int uv_tcp_open(uv_tcp_t* handle, uv_os_sock_t sock);\nUV_EXTERN int uv_tcp_nodelay(uv_tcp_t* handle, int enable);\nUV_EXTERN int uv_tcp_keepalive(uv_tcp_t* handle,\n                               int enable,\n                               unsigned int delay);\nUV_EXTERN int uv_tcp_simultaneous_accepts(uv_tcp_t* handle, int enable);\n\nenum uv_tcp_flags {\n  /* Used with uv_tcp_bind, when an IPv6 address is used. */\n  UV_TCP_IPV6ONLY = 1\n};\n\nUV_EXTERN int uv_tcp_bind(uv_tcp_t* handle,\n                          const struct sockaddr* addr,\n                          unsigned int flags);\nUV_EXTERN int uv_tcp_getsockname(const uv_tcp_t* handle,\n                                 struct sockaddr* name,\n                                 int* namelen);\nUV_EXTERN int uv_tcp_getpeername(const uv_tcp_t* handle,\n                                 struct sockaddr* name,\n                                 int* namelen);\nUV_EXTERN int uv_tcp_connect(uv_connect_t* req,\n                             uv_tcp_t* handle,\n                             const struct sockaddr* addr,\n                             uv_connect_cb cb);\n\n/* uv_connect_t is a subclass of uv_req_t. */\nstruct uv_connect_s {\n  UV_REQ_FIELDS\n  uv_connect_cb cb;\n  uv_stream_t* handle;\n  UV_CONNECT_PRIVATE_FIELDS\n};\n\n\n/*\n * UDP support.\n */\n\nenum uv_udp_flags {\n  /* Disables dual stack mode. */\n  UV_UDP_IPV6ONLY = 1,\n  /*\n   * Indicates message was truncated because read buffer was too small. The\n   * remainder was discarded by the OS. Used in uv_udp_recv_cb.\n   */\n  UV_UDP_PARTIAL = 2,\n  /*\n   * Indicates if SO_REUSEADDR will be set when binding the handle.\n   * This sets the SO_REUSEPORT socket flag on the BSDs and OS X. On other\n   * Unix platforms, it sets the SO_REUSEADDR flag.  What that means is that\n   * multiple threads or processes can bind to the same address without error\n   * (provided they all set the flag) but only the last one to bind will receive\n   * any traffic, in effect \"stealing\" the port from the previous listener.\n   */\n  UV_UDP_REUSEADDR = 4\n};\n\ntypedef void (*uv_udp_send_cb)(uv_udp_send_t* req, int status);\ntypedef void (*uv_udp_recv_cb)(uv_udp_t* handle,\n                               ssize_t nread,\n                               const uv_buf_t* buf,\n                               const struct sockaddr* addr,\n                               unsigned flags);\n\n/* uv_udp_t is a subclass of uv_handle_t. */\nstruct uv_udp_s {\n  UV_HANDLE_FIELDS\n  /* read-only */\n  /*\n   * Number of bytes queued for sending. This field strictly shows how much\n   * information is currently queued.\n   */\n  size_t send_queue_size;\n  /*\n   * Number of send requests currently in the queue awaiting to be processed.\n   */\n  size_t send_queue_count;\n  UV_UDP_PRIVATE_FIELDS\n};\n\n/* uv_udp_send_t is a subclass of uv_req_t. */\nstruct uv_udp_send_s {\n  UV_REQ_FIELDS\n  uv_udp_t* handle;\n  uv_udp_send_cb cb;\n  UV_UDP_SEND_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_udp_init(uv_loop_t*, uv_udp_t* handle);\nUV_EXTERN int uv_udp_init_ex(uv_loop_t*, uv_udp_t* handle, unsigned int flags);\nUV_EXTERN int uv_udp_open(uv_udp_t* handle, uv_os_sock_t sock);\nUV_EXTERN int uv_udp_bind(uv_udp_t* handle,\n                          const struct sockaddr* addr,\n                          unsigned int flags);\n\nUV_EXTERN int uv_udp_getsockname(const uv_udp_t* handle,\n                                 struct sockaddr* name,\n                                 int* namelen);\nUV_EXTERN int uv_udp_set_membership(uv_udp_t* handle,\n                                    const char* multicast_addr,\n                                    const char* interface_addr,\n                                    uv_membership membership);\nUV_EXTERN int uv_udp_set_multicast_loop(uv_udp_t* handle, int on);\nUV_EXTERN int uv_udp_set_multicast_ttl(uv_udp_t* handle, int ttl);\nUV_EXTERN int uv_udp_set_multicast_interface(uv_udp_t* handle,\n                                             const char* interface_addr);\nUV_EXTERN int uv_udp_set_broadcast(uv_udp_t* handle, int on);\nUV_EXTERN int uv_udp_set_ttl(uv_udp_t* handle, int ttl);\nUV_EXTERN int uv_udp_send(uv_udp_send_t* req,\n                          uv_udp_t* handle,\n                          const uv_buf_t bufs[],\n                          unsigned int nbufs,\n                          const struct sockaddr* addr,\n                          uv_udp_send_cb send_cb);\nUV_EXTERN int uv_udp_try_send(uv_udp_t* handle,\n                              const uv_buf_t bufs[],\n                              unsigned int nbufs,\n                              const struct sockaddr* addr);\nUV_EXTERN int uv_udp_recv_start(uv_udp_t* handle,\n                                uv_alloc_cb alloc_cb,\n                                uv_udp_recv_cb recv_cb);\nUV_EXTERN int uv_udp_recv_stop(uv_udp_t* handle);\n\n\n/*\n * uv_tty_t is a subclass of uv_stream_t.\n *\n * Representing a stream for the console.\n */\nstruct uv_tty_s {\n  UV_HANDLE_FIELDS\n  UV_STREAM_FIELDS\n  UV_TTY_PRIVATE_FIELDS\n};\n\ntypedef enum {\n  /* Initial/normal terminal mode */\n  UV_TTY_MODE_NORMAL,\n  /* Raw input mode (On Windows, ENABLE_WINDOW_INPUT is also enabled) */\n  UV_TTY_MODE_RAW,\n  /* Binary-safe I/O mode for IPC (Unix-only) */\n  UV_TTY_MODE_IO\n} uv_tty_mode_t;\n\nUV_EXTERN int uv_tty_init(uv_loop_t*, uv_tty_t*, uv_file fd, int readable);\nUV_EXTERN int uv_tty_set_mode(uv_tty_t*, uv_tty_mode_t mode);\nUV_EXTERN int uv_tty_reset_mode(void);\nUV_EXTERN int uv_tty_get_winsize(uv_tty_t*, int* width, int* height);\n\n#ifdef __cplusplus\nextern \"C++\" {\n\ninline int uv_tty_set_mode(uv_tty_t* handle, int mode) {\n  return uv_tty_set_mode(handle, static_cast<uv_tty_mode_t>(mode));\n}\n\n}\n#endif\n\nUV_EXTERN uv_handle_type uv_guess_handle(uv_file file);\n\n/*\n * uv_pipe_t is a subclass of uv_stream_t.\n *\n * Representing a pipe stream or pipe server. On Windows this is a Named\n * Pipe. On Unix this is a Unix domain socket.\n */\nstruct uv_pipe_s {\n  UV_HANDLE_FIELDS\n  UV_STREAM_FIELDS\n  int ipc; /* non-zero if this pipe is used for passing handles */\n  UV_PIPE_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_pipe_init(uv_loop_t*, uv_pipe_t* handle, int ipc);\nUV_EXTERN int uv_pipe_open(uv_pipe_t*, uv_file file);\nUV_EXTERN int uv_pipe_bind(uv_pipe_t* handle, const char* name);\nUV_EXTERN void uv_pipe_connect(uv_connect_t* req,\n                               uv_pipe_t* handle,\n                               const char* name,\n                               uv_connect_cb cb);\nUV_EXTERN int uv_pipe_getsockname(const uv_pipe_t* handle,\n                                  char* buffer,\n                                  size_t* size);\nUV_EXTERN int uv_pipe_getpeername(const uv_pipe_t* handle,\n                                  char* buffer,\n                                  size_t* size);\nUV_EXTERN void uv_pipe_pending_instances(uv_pipe_t* handle, int count);\nUV_EXTERN int uv_pipe_pending_count(uv_pipe_t* handle);\nUV_EXTERN uv_handle_type uv_pipe_pending_type(uv_pipe_t* handle);\n\n\nstruct uv_poll_s {\n  UV_HANDLE_FIELDS\n  uv_poll_cb poll_cb;\n  UV_POLL_PRIVATE_FIELDS\n};\n\nenum uv_poll_event {\n  UV_READABLE = 1,\n  UV_WRITABLE = 2,\n  UV_DISCONNECT = 4\n};\n\nUV_EXTERN int uv_poll_init(uv_loop_t* loop, uv_poll_t* handle, int fd);\nUV_EXTERN int uv_poll_init_socket(uv_loop_t* loop,\n                                  uv_poll_t* handle,\n                                  uv_os_sock_t socket);\nUV_EXTERN int uv_poll_start(uv_poll_t* handle, int events, uv_poll_cb cb);\nUV_EXTERN int uv_poll_stop(uv_poll_t* handle);\n\n\nstruct uv_prepare_s {\n  UV_HANDLE_FIELDS\n  UV_PREPARE_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_prepare_init(uv_loop_t*, uv_prepare_t* prepare);\nUV_EXTERN int uv_prepare_start(uv_prepare_t* prepare, uv_prepare_cb cb);\nUV_EXTERN int uv_prepare_stop(uv_prepare_t* prepare);\n\n\nstruct uv_check_s {\n  UV_HANDLE_FIELDS\n  UV_CHECK_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_check_init(uv_loop_t*, uv_check_t* check);\nUV_EXTERN int uv_check_start(uv_check_t* check, uv_check_cb cb);\nUV_EXTERN int uv_check_stop(uv_check_t* check);\n\n\nstruct uv_idle_s {\n  UV_HANDLE_FIELDS\n  UV_IDLE_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_idle_init(uv_loop_t*, uv_idle_t* idle);\nUV_EXTERN int uv_idle_start(uv_idle_t* idle, uv_idle_cb cb);\nUV_EXTERN int uv_idle_stop(uv_idle_t* idle);\n\n\nstruct uv_async_s {\n  UV_HANDLE_FIELDS\n  UV_ASYNC_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_async_init(uv_loop_t*,\n                            uv_async_t* async,\n                            uv_async_cb async_cb);\nUV_EXTERN int uv_async_send(uv_async_t* async);\n\n\n/*\n * uv_timer_t is a subclass of uv_handle_t.\n *\n * Used to get woken up at a specified time in the future.\n */\nstruct uv_timer_s {\n  UV_HANDLE_FIELDS\n  UV_TIMER_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_timer_init(uv_loop_t*, uv_timer_t* handle);\nUV_EXTERN int uv_timer_start(uv_timer_t* handle,\n                             uv_timer_cb cb,\n                             uint64_t timeout,\n                             uint64_t repeat);\nUV_EXTERN int uv_timer_stop(uv_timer_t* handle);\nUV_EXTERN int uv_timer_again(uv_timer_t* handle);\nUV_EXTERN void uv_timer_set_repeat(uv_timer_t* handle, uint64_t repeat);\nUV_EXTERN uint64_t uv_timer_get_repeat(const uv_timer_t* handle);\n\n\n/*\n * uv_getaddrinfo_t is a subclass of uv_req_t.\n *\n * Request object for uv_getaddrinfo.\n */\nstruct uv_getaddrinfo_s {\n  UV_REQ_FIELDS\n  /* read-only */\n  uv_loop_t* loop;\n  /* struct addrinfo* addrinfo is marked as private, but it really isn't. */\n  UV_GETADDRINFO_PRIVATE_FIELDS\n};\n\n\nUV_EXTERN int uv_getaddrinfo(uv_loop_t* loop,\n                             uv_getaddrinfo_t* req,\n                             uv_getaddrinfo_cb getaddrinfo_cb,\n                             const char* node,\n                             const char* service,\n                             const struct addrinfo* hints);\nUV_EXTERN void uv_freeaddrinfo(struct addrinfo* ai);\n\n\n/*\n* uv_getnameinfo_t is a subclass of uv_req_t.\n*\n* Request object for uv_getnameinfo.\n*/\nstruct uv_getnameinfo_s {\n  UV_REQ_FIELDS\n  /* read-only */\n  uv_loop_t* loop;\n  /* host and service are marked as private, but they really aren't. */\n  UV_GETNAMEINFO_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_getnameinfo(uv_loop_t* loop,\n                             uv_getnameinfo_t* req,\n                             uv_getnameinfo_cb getnameinfo_cb,\n                             const struct sockaddr* addr,\n                             int flags);\n\n\n/* uv_spawn() options. */\ntypedef enum {\n  UV_IGNORE         = 0x00,\n  UV_CREATE_PIPE    = 0x01,\n  UV_INHERIT_FD     = 0x02,\n  UV_INHERIT_STREAM = 0x04,\n\n  /*\n   * When UV_CREATE_PIPE is specified, UV_READABLE_PIPE and UV_WRITABLE_PIPE\n   * determine the direction of flow, from the child process' perspective. Both\n   * flags may be specified to create a duplex data stream.\n   */\n  UV_READABLE_PIPE  = 0x10,\n  UV_WRITABLE_PIPE  = 0x20\n} uv_stdio_flags;\n\ntypedef struct uv_stdio_container_s {\n  uv_stdio_flags flags;\n\n  union {\n    uv_stream_t* stream;\n    int fd;\n  } data;\n} uv_stdio_container_t;\n\ntypedef struct uv_process_options_s {\n  uv_exit_cb exit_cb; /* Called after the process exits. */\n  const char* file;   /* Path to program to execute. */\n  /*\n   * Command line arguments. args[0] should be the path to the program. On\n   * Windows this uses CreateProcess which concatenates the arguments into a\n   * string this can cause some strange errors. See the note at\n   * windows_verbatim_arguments.\n   */\n  char** args;\n  /*\n   * This will be set as the environ variable in the subprocess. If this is\n   * NULL then the parents environ will be used.\n   */\n  char** env;\n  /*\n   * If non-null this represents a directory the subprocess should execute\n   * in. Stands for current working directory.\n   */\n  const char* cwd;\n  /*\n   * Various flags that control how uv_spawn() behaves. See the definition of\n   * `enum uv_process_flags` below.\n   */\n  unsigned int flags;\n  /*\n   * The `stdio` field points to an array of uv_stdio_container_t structs that\n   * describe the file descriptors that will be made available to the child\n   * process. The convention is that stdio[0] points to stdin, fd 1 is used for\n   * stdout, and fd 2 is stderr.\n   *\n   * Note that on windows file descriptors greater than 2 are available to the\n   * child process only if the child processes uses the MSVCRT runtime.\n   */\n  int stdio_count;\n  uv_stdio_container_t* stdio;\n  /*\n   * Libuv can change the child process' user/group id. This happens only when\n   * the appropriate bits are set in the flags fields. This is not supported on\n   * windows; uv_spawn() will fail and set the error to UV_ENOTSUP.\n   */\n  uv_uid_t uid;\n  uv_gid_t gid;\n} uv_process_options_t;\n\n/*\n * These are the flags that can be used for the uv_process_options.flags field.\n */\nenum uv_process_flags {\n  /*\n   * Set the child process' user id. The user id is supplied in the `uid` field\n   * of the options struct. This does not work on windows; setting this flag\n   * will cause uv_spawn() to fail.\n   */\n  UV_PROCESS_SETUID = (1 << 0),\n  /*\n   * Set the child process' group id. The user id is supplied in the `gid`\n   * field of the options struct. This does not work on windows; setting this\n   * flag will cause uv_spawn() to fail.\n   */\n  UV_PROCESS_SETGID = (1 << 1),\n  /*\n   * Do not wrap any arguments in quotes, or perform any other escaping, when\n   * converting the argument list into a command line string. This option is\n   * only meaningful on Windows systems. On Unix it is silently ignored.\n   */\n  UV_PROCESS_WINDOWS_VERBATIM_ARGUMENTS = (1 << 2),\n  /*\n   * Spawn the child process in a detached state - this will make it a process\n   * group leader, and will effectively enable the child to keep running after\n   * the parent exits.  Note that the child process will still keep the\n   * parent's event loop alive unless the parent process calls uv_unref() on\n   * the child's process handle.\n   */\n  UV_PROCESS_DETACHED = (1 << 3),\n  /*\n   * Hide the subprocess console window that would normally be created. This\n   * option is only meaningful on Windows systems. On Unix it is silently\n   * ignored.\n   */\n  UV_PROCESS_WINDOWS_HIDE = (1 << 4)\n};\n\n/*\n * uv_process_t is a subclass of uv_handle_t.\n */\nstruct uv_process_s {\n  UV_HANDLE_FIELDS\n  uv_exit_cb exit_cb;\n  int pid;\n  UV_PROCESS_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_spawn(uv_loop_t* loop,\n                       uv_process_t* handle,\n                       const uv_process_options_t* options);\nUV_EXTERN int uv_process_kill(uv_process_t*, int signum);\nUV_EXTERN int uv_kill(int pid, int signum);\n\n\n/*\n * uv_work_t is a subclass of uv_req_t.\n */\nstruct uv_work_s {\n  UV_REQ_FIELDS\n  uv_loop_t* loop;\n  uv_work_cb work_cb;\n  uv_after_work_cb after_work_cb;\n  UV_WORK_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_queue_work(uv_loop_t* loop,\n                            uv_work_t* req,\n                            uv_work_cb work_cb,\n                            uv_after_work_cb after_work_cb);\n\nUV_EXTERN int uv_cancel(uv_req_t* req);\n\n\nstruct uv_cpu_info_s {\n  char* model;\n  int speed;\n  struct uv_cpu_times_s {\n    uint64_t user;\n    uint64_t nice;\n    uint64_t sys;\n    uint64_t idle;\n    uint64_t irq;\n  } cpu_times;\n};\n\nstruct uv_interface_address_s {\n  char* name;\n  char phys_addr[6];\n  int is_internal;\n  union {\n    struct sockaddr_in address4;\n    struct sockaddr_in6 address6;\n  } address;\n  union {\n    struct sockaddr_in netmask4;\n    struct sockaddr_in6 netmask6;\n  } netmask;\n};\n\nstruct uv_passwd_s {\n  char* username;\n  long uid;\n  long gid;\n  char* shell;\n  char* homedir;\n};\n\ntypedef enum {\n  UV_DIRENT_UNKNOWN,\n  UV_DIRENT_FILE,\n  UV_DIRENT_DIR,\n  UV_DIRENT_LINK,\n  UV_DIRENT_FIFO,\n  UV_DIRENT_SOCKET,\n  UV_DIRENT_CHAR,\n  UV_DIRENT_BLOCK\n} uv_dirent_type_t;\n\nstruct uv_dirent_s {\n  const char* name;\n  uv_dirent_type_t type;\n};\n\nUV_EXTERN char** uv_setup_args(int argc, char** argv);\nUV_EXTERN int uv_get_process_title(char* buffer, size_t size);\nUV_EXTERN int uv_set_process_title(const char* title);\nUV_EXTERN int uv_resident_set_memory(size_t* rss);\nUV_EXTERN int uv_uptime(double* uptime);\n\ntypedef struct {\n  long tv_sec;\n  long tv_usec;\n} uv_timeval_t;\n\ntypedef struct {\n   uv_timeval_t ru_utime; /* user CPU time used */\n   uv_timeval_t ru_stime; /* system CPU time used */\n   uint64_t ru_maxrss;    /* maximum resident set size */\n   uint64_t ru_ixrss;     /* integral shared memory size */\n   uint64_t ru_idrss;     /* integral unshared data size */\n   uint64_t ru_isrss;     /* integral unshared stack size */\n   uint64_t ru_minflt;    /* page reclaims (soft page faults) */\n   uint64_t ru_majflt;    /* page faults (hard page faults) */\n   uint64_t ru_nswap;     /* swaps */\n   uint64_t ru_inblock;   /* block input operations */\n   uint64_t ru_oublock;   /* block output operations */\n   uint64_t ru_msgsnd;    /* IPC messages sent */\n   uint64_t ru_msgrcv;    /* IPC messages received */\n   uint64_t ru_nsignals;  /* signals received */\n   uint64_t ru_nvcsw;     /* voluntary context switches */\n   uint64_t ru_nivcsw;    /* involuntary context switches */\n} uv_rusage_t;\n\nUV_EXTERN int uv_getrusage(uv_rusage_t* rusage);\n\nUV_EXTERN int uv_os_homedir(char* buffer, size_t* size);\nUV_EXTERN int uv_os_tmpdir(char* buffer, size_t* size);\nUV_EXTERN int uv_os_get_passwd(uv_passwd_t* pwd);\nUV_EXTERN void uv_os_free_passwd(uv_passwd_t* pwd);\n\nUV_EXTERN int uv_cpu_info(uv_cpu_info_t** cpu_infos, int* count);\nUV_EXTERN void uv_free_cpu_info(uv_cpu_info_t* cpu_infos, int count);\n\nUV_EXTERN int uv_interface_addresses(uv_interface_address_t** addresses,\n                                     int* count);\nUV_EXTERN void uv_free_interface_addresses(uv_interface_address_t* addresses,\n                                           int count);\n\n\ntypedef enum {\n  UV_FS_UNKNOWN = -1,\n  UV_FS_CUSTOM,\n  UV_FS_OPEN,\n  UV_FS_CLOSE,\n  UV_FS_READ,\n  UV_FS_WRITE,\n  UV_FS_SENDFILE,\n  UV_FS_STAT,\n  UV_FS_LSTAT,\n  UV_FS_FSTAT,\n  UV_FS_FTRUNCATE,\n  UV_FS_UTIME,\n  UV_FS_FUTIME,\n  UV_FS_ACCESS,\n  UV_FS_CHMOD,\n  UV_FS_FCHMOD,\n  UV_FS_FSYNC,\n  UV_FS_FDATASYNC,\n  UV_FS_UNLINK,\n  UV_FS_RMDIR,\n  UV_FS_MKDIR,\n  UV_FS_MKDTEMP,\n  UV_FS_RENAME,\n  UV_FS_SCANDIR,\n  UV_FS_LINK,\n  UV_FS_SYMLINK,\n  UV_FS_READLINK,\n  UV_FS_CHOWN,\n  UV_FS_FCHOWN,\n  UV_FS_REALPATH\n} uv_fs_type;\n\n/* uv_fs_t is a subclass of uv_req_t. */\nstruct uv_fs_s {\n  UV_REQ_FIELDS\n  uv_fs_type fs_type;\n  uv_loop_t* loop;\n  uv_fs_cb cb;\n  ssize_t result;\n  void* ptr;\n  const char* path;\n  uv_stat_t statbuf;  /* Stores the result of uv_fs_stat() and uv_fs_fstat(). */\n  UV_FS_PRIVATE_FIELDS\n};\n\nUV_EXTERN void uv_fs_req_cleanup(uv_fs_t* req);\nUV_EXTERN int uv_fs_close(uv_loop_t* loop,\n                          uv_fs_t* req,\n                          uv_file file,\n                          uv_fs_cb cb);\nUV_EXTERN int uv_fs_open(uv_loop_t* loop,\n                         uv_fs_t* req,\n                         const char* path,\n                         int flags,\n                         int mode,\n                         uv_fs_cb cb);\nUV_EXTERN int uv_fs_read(uv_loop_t* loop,\n                         uv_fs_t* req,\n                         uv_file file,\n                         const uv_buf_t bufs[],\n                         unsigned int nbufs,\n                         int64_t offset,\n                         uv_fs_cb cb);\nUV_EXTERN int uv_fs_unlink(uv_loop_t* loop,\n                           uv_fs_t* req,\n                           const char* path,\n                           uv_fs_cb cb);\nUV_EXTERN int uv_fs_write(uv_loop_t* loop,\n                          uv_fs_t* req,\n                          uv_file file,\n                          const uv_buf_t bufs[],\n                          unsigned int nbufs,\n                          int64_t offset,\n                          uv_fs_cb cb);\nUV_EXTERN int uv_fs_mkdir(uv_loop_t* loop,\n                          uv_fs_t* req,\n                          const char* path,\n                          int mode,\n                          uv_fs_cb cb);\nUV_EXTERN int uv_fs_mkdtemp(uv_loop_t* loop,\n                            uv_fs_t* req,\n                            const char* tpl,\n                            uv_fs_cb cb);\nUV_EXTERN int uv_fs_rmdir(uv_loop_t* loop,\n                          uv_fs_t* req,\n                          const char* path,\n                          uv_fs_cb cb);\nUV_EXTERN int uv_fs_scandir(uv_loop_t* loop,\n                            uv_fs_t* req,\n                            const char* path,\n                            int flags,\n                            uv_fs_cb cb);\nUV_EXTERN int uv_fs_scandir_next(uv_fs_t* req,\n                                 uv_dirent_t* ent);\nUV_EXTERN int uv_fs_stat(uv_loop_t* loop,\n                         uv_fs_t* req,\n                         const char* path,\n                         uv_fs_cb cb);\nUV_EXTERN int uv_fs_fstat(uv_loop_t* loop,\n                          uv_fs_t* req,\n                          uv_file file,\n                          uv_fs_cb cb);\nUV_EXTERN int uv_fs_rename(uv_loop_t* loop,\n                           uv_fs_t* req,\n                           const char* path,\n                           const char* new_path,\n                           uv_fs_cb cb);\nUV_EXTERN int uv_fs_fsync(uv_loop_t* loop,\n                          uv_fs_t* req,\n                          uv_file file,\n                          uv_fs_cb cb);\nUV_EXTERN int uv_fs_fdatasync(uv_loop_t* loop,\n                              uv_fs_t* req,\n                              uv_file file,\n                              uv_fs_cb cb);\nUV_EXTERN int uv_fs_ftruncate(uv_loop_t* loop,\n                              uv_fs_t* req,\n                              uv_file file,\n                              int64_t offset,\n                              uv_fs_cb cb);\nUV_EXTERN int uv_fs_sendfile(uv_loop_t* loop,\n                             uv_fs_t* req,\n                             uv_file out_fd,\n                             uv_file in_fd,\n                             int64_t in_offset,\n                             size_t length,\n                             uv_fs_cb cb);\nUV_EXTERN int uv_fs_access(uv_loop_t* loop,\n                           uv_fs_t* req,\n                           const char* path,\n                           int mode,\n                           uv_fs_cb cb);\nUV_EXTERN int uv_fs_chmod(uv_loop_t* loop,\n                          uv_fs_t* req,\n                          const char* path,\n                          int mode,\n                          uv_fs_cb cb);\nUV_EXTERN int uv_fs_utime(uv_loop_t* loop,\n                          uv_fs_t* req,\n                          const char* path,\n                          double atime,\n                          double mtime,\n                          uv_fs_cb cb);\nUV_EXTERN int uv_fs_futime(uv_loop_t* loop,\n                           uv_fs_t* req,\n                           uv_file file,\n                           double atime,\n                           double mtime,\n                           uv_fs_cb cb);\nUV_EXTERN int uv_fs_lstat(uv_loop_t* loop,\n                          uv_fs_t* req,\n                          const char* path,\n                          uv_fs_cb cb);\nUV_EXTERN int uv_fs_link(uv_loop_t* loop,\n                         uv_fs_t* req,\n                         const char* path,\n                         const char* new_path,\n                         uv_fs_cb cb);\n\n/*\n * This flag can be used with uv_fs_symlink() on Windows to specify whether\n * path argument points to a directory.\n */\n#define UV_FS_SYMLINK_DIR          0x0001\n\n/*\n * This flag can be used with uv_fs_symlink() on Windows to specify whether\n * the symlink is to be created using junction points.\n */\n#define UV_FS_SYMLINK_JUNCTION     0x0002\n\nUV_EXTERN int uv_fs_symlink(uv_loop_t* loop,\n                            uv_fs_t* req,\n                            const char* path,\n                            const char* new_path,\n                            int flags,\n                            uv_fs_cb cb);\nUV_EXTERN int uv_fs_readlink(uv_loop_t* loop,\n                             uv_fs_t* req,\n                             const char* path,\n                             uv_fs_cb cb);\nUV_EXTERN int uv_fs_realpath(uv_loop_t* loop,\n                             uv_fs_t* req,\n                             const char* path,\n                             uv_fs_cb cb);\nUV_EXTERN int uv_fs_fchmod(uv_loop_t* loop,\n                           uv_fs_t* req,\n                           uv_file file,\n                           int mode,\n                           uv_fs_cb cb);\nUV_EXTERN int uv_fs_chown(uv_loop_t* loop,\n                          uv_fs_t* req,\n                          const char* path,\n                          uv_uid_t uid,\n                          uv_gid_t gid,\n                          uv_fs_cb cb);\nUV_EXTERN int uv_fs_fchown(uv_loop_t* loop,\n                           uv_fs_t* req,\n                           uv_file file,\n                           uv_uid_t uid,\n                           uv_gid_t gid,\n                           uv_fs_cb cb);\n\n\nenum uv_fs_event {\n  UV_RENAME = 1,\n  UV_CHANGE = 2\n};\n\n\nstruct uv_fs_event_s {\n  UV_HANDLE_FIELDS\n  /* private */\n  char* path;\n  UV_FS_EVENT_PRIVATE_FIELDS\n};\n\n\n/*\n * uv_fs_stat() based polling file watcher.\n */\nstruct uv_fs_poll_s {\n  UV_HANDLE_FIELDS\n  /* Private, don't touch. */\n  void* poll_ctx;\n};\n\nUV_EXTERN int uv_fs_poll_init(uv_loop_t* loop, uv_fs_poll_t* handle);\nUV_EXTERN int uv_fs_poll_start(uv_fs_poll_t* handle,\n                               uv_fs_poll_cb poll_cb,\n                               const char* path,\n                               unsigned int interval);\nUV_EXTERN int uv_fs_poll_stop(uv_fs_poll_t* handle);\nUV_EXTERN int uv_fs_poll_getpath(uv_fs_poll_t* handle,\n                                 char* buffer,\n                                 size_t* size);\n\n\nstruct uv_signal_s {\n  UV_HANDLE_FIELDS\n  uv_signal_cb signal_cb;\n  int signum;\n  UV_SIGNAL_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_signal_init(uv_loop_t* loop, uv_signal_t* handle);\nUV_EXTERN int uv_signal_start(uv_signal_t* handle,\n                              uv_signal_cb signal_cb,\n                              int signum);\nUV_EXTERN int uv_signal_stop(uv_signal_t* handle);\n\nUV_EXTERN void uv_loadavg(double avg[3]);\n\n\n/*\n * Flags to be passed to uv_fs_event_start().\n */\nenum uv_fs_event_flags {\n  /*\n   * By default, if the fs event watcher is given a directory name, we will\n   * watch for all events in that directory. This flags overrides this behavior\n   * and makes fs_event report only changes to the directory entry itself. This\n   * flag does not affect individual files watched.\n   * This flag is currently not implemented yet on any backend.\n   */\n  UV_FS_EVENT_WATCH_ENTRY = 1,\n\n  /*\n   * By default uv_fs_event will try to use a kernel interface such as inotify\n   * or kqueue to detect events. This may not work on remote filesystems such\n   * as NFS mounts. This flag makes fs_event fall back to calling stat() on a\n   * regular interval.\n   * This flag is currently not implemented yet on any backend.\n   */\n  UV_FS_EVENT_STAT = 2,\n\n  /*\n   * By default, event watcher, when watching directory, is not registering\n   * (is ignoring) changes in it's subdirectories.\n   * This flag will override this behaviour on platforms that support it.\n   */\n  UV_FS_EVENT_RECURSIVE = 4\n};\n\n\nUV_EXTERN int uv_fs_event_init(uv_loop_t* loop, uv_fs_event_t* handle);\nUV_EXTERN int uv_fs_event_start(uv_fs_event_t* handle,\n                                uv_fs_event_cb cb,\n                                const char* path,\n                                unsigned int flags);\nUV_EXTERN int uv_fs_event_stop(uv_fs_event_t* handle);\nUV_EXTERN int uv_fs_event_getpath(uv_fs_event_t* handle,\n                                  char* buffer,\n                                  size_t* size);\n\nUV_EXTERN int uv_ip4_addr(const char* ip, int port, struct sockaddr_in* addr);\nUV_EXTERN int uv_ip6_addr(const char* ip, int port, struct sockaddr_in6* addr);\n\nUV_EXTERN int uv_ip4_name(const struct sockaddr_in* src, char* dst, size_t size);\nUV_EXTERN int uv_ip6_name(const struct sockaddr_in6* src, char* dst, size_t size);\n\nUV_EXTERN int uv_inet_ntop(int af, const void* src, char* dst, size_t size);\nUV_EXTERN int uv_inet_pton(int af, const char* src, void* dst);\n\nUV_EXTERN int uv_exepath(char* buffer, size_t* size);\n\nUV_EXTERN int uv_cwd(char* buffer, size_t* size);\n\nUV_EXTERN int uv_chdir(const char* dir);\n\nUV_EXTERN uint64_t uv_get_free_memory(void);\nUV_EXTERN uint64_t uv_get_total_memory(void);\n\nUV_EXTERN uint64_t uv_hrtime(void);\n\nUV_EXTERN void uv_disable_stdio_inheritance(void);\n\nUV_EXTERN int uv_dlopen(const char* filename, uv_lib_t* lib);\nUV_EXTERN void uv_dlclose(uv_lib_t* lib);\nUV_EXTERN int uv_dlsym(uv_lib_t* lib, const char* name, void** ptr);\nUV_EXTERN const char* uv_dlerror(const uv_lib_t* lib);\n\nUV_EXTERN int uv_mutex_init(uv_mutex_t* handle);\nUV_EXTERN void uv_mutex_destroy(uv_mutex_t* handle);\nUV_EXTERN void uv_mutex_lock(uv_mutex_t* handle);\nUV_EXTERN int uv_mutex_trylock(uv_mutex_t* handle);\nUV_EXTERN void uv_mutex_unlock(uv_mutex_t* handle);\n\nUV_EXTERN int uv_rwlock_init(uv_rwlock_t* rwlock);\nUV_EXTERN void uv_rwlock_destroy(uv_rwlock_t* rwlock);\nUV_EXTERN void uv_rwlock_rdlock(uv_rwlock_t* rwlock);\nUV_EXTERN int uv_rwlock_tryrdlock(uv_rwlock_t* rwlock);\nUV_EXTERN void uv_rwlock_rdunlock(uv_rwlock_t* rwlock);\nUV_EXTERN void uv_rwlock_wrlock(uv_rwlock_t* rwlock);\nUV_EXTERN int uv_rwlock_trywrlock(uv_rwlock_t* rwlock);\nUV_EXTERN void uv_rwlock_wrunlock(uv_rwlock_t* rwlock);\n\nUV_EXTERN int uv_sem_init(uv_sem_t* sem, unsigned int value);\nUV_EXTERN void uv_sem_destroy(uv_sem_t* sem);\nUV_EXTERN void uv_sem_post(uv_sem_t* sem);\nUV_EXTERN void uv_sem_wait(uv_sem_t* sem);\nUV_EXTERN int uv_sem_trywait(uv_sem_t* sem);\n\nUV_EXTERN int uv_cond_init(uv_cond_t* cond);\nUV_EXTERN void uv_cond_destroy(uv_cond_t* cond);\nUV_EXTERN void uv_cond_signal(uv_cond_t* cond);\nUV_EXTERN void uv_cond_broadcast(uv_cond_t* cond);\n\nUV_EXTERN int uv_barrier_init(uv_barrier_t* barrier, unsigned int count);\nUV_EXTERN void uv_barrier_destroy(uv_barrier_t* barrier);\nUV_EXTERN int uv_barrier_wait(uv_barrier_t* barrier);\n\nUV_EXTERN void uv_cond_wait(uv_cond_t* cond, uv_mutex_t* mutex);\nUV_EXTERN int uv_cond_timedwait(uv_cond_t* cond,\n                                uv_mutex_t* mutex,\n                                uint64_t timeout);\n\nUV_EXTERN void uv_once(uv_once_t* guard, void (*callback)(void));\n\nUV_EXTERN int uv_key_create(uv_key_t* key);\nUV_EXTERN void uv_key_delete(uv_key_t* key);\nUV_EXTERN void* uv_key_get(uv_key_t* key);\nUV_EXTERN void uv_key_set(uv_key_t* key, void* value);\n\ntypedef void (*uv_thread_cb)(void* arg);\n\nUV_EXTERN int uv_thread_create(uv_thread_t* tid, uv_thread_cb entry, void* arg);\nUV_EXTERN uv_thread_t uv_thread_self(void);\nUV_EXTERN int uv_thread_join(uv_thread_t *tid);\nUV_EXTERN int uv_thread_equal(const uv_thread_t* t1, const uv_thread_t* t2);\n\n/* The presence of these unions force similar struct layout. */\n#define XX(_, name) uv_ ## name ## _t name;\nunion uv_any_handle {\n  UV_HANDLE_TYPE_MAP(XX)\n};\n\nunion uv_any_req {\n  UV_REQ_TYPE_MAP(XX)\n};\n#undef XX\n\n\nstruct uv_loop_s {\n  /* User data - use this for whatever. */\n  void* data;\n  /* Loop reference counting. */\n  unsigned int active_handles;\n  void* handle_queue[2];\n  void* active_reqs[2];\n  /* Internal flag to signal loop stop. */\n  unsigned int stop_flag;\n  UV_LOOP_PRIVATE_FIELDS\n};\n\n\n/* Don't export the private CPP symbols. */\n#undef UV_HANDLE_TYPE_PRIVATE\n#undef UV_REQ_TYPE_PRIVATE\n#undef UV_REQ_PRIVATE_FIELDS\n#undef UV_STREAM_PRIVATE_FIELDS\n#undef UV_TCP_PRIVATE_FIELDS\n#undef UV_PREPARE_PRIVATE_FIELDS\n#undef UV_CHECK_PRIVATE_FIELDS\n#undef UV_IDLE_PRIVATE_FIELDS\n#undef UV_ASYNC_PRIVATE_FIELDS\n#undef UV_TIMER_PRIVATE_FIELDS\n#undef UV_GETADDRINFO_PRIVATE_FIELDS\n#undef UV_GETNAMEINFO_PRIVATE_FIELDS\n#undef UV_FS_REQ_PRIVATE_FIELDS\n#undef UV_WORK_PRIVATE_FIELDS\n#undef UV_FS_EVENT_PRIVATE_FIELDS\n#undef UV_SIGNAL_PRIVATE_FIELDS\n#undef UV_LOOP_PRIVATE_FIELDS\n#undef UV_LOOP_PRIVATE_PLATFORM_FIELDS\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* UV_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-libuv-1.10.0-tvkoat5vslbctz2afzq2jzqjvgrpibgh/spack-src/include/uv-unix.h": "/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\n#ifndef UV_UNIX_H\n#define UV_UNIX_H\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <dirent.h>\n\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <netinet/tcp.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n\n#include <termios.h>\n#include <pwd.h>\n\n#include <semaphore.h>\n#include <pthread.h>\n#include <signal.h>\n\n#include \"uv-threadpool.h\"\n\n#if defined(__linux__)\n# include \"uv-linux.h\"\n#elif defined(_AIX)\n# include \"uv-aix.h\"\n#elif defined(__sun)\n# include \"uv-sunos.h\"\n#elif defined(__APPLE__)\n# include \"uv-darwin.h\"\n#elif defined(__DragonFly__)       || \\\n      defined(__FreeBSD__)         || \\\n      defined(__FreeBSD_kernel__)  || \\\n      defined(__OpenBSD__)         || \\\n      defined(__NetBSD__)\n# include \"uv-bsd.h\"\n#endif\n\n#ifndef PTHREAD_BARRIER_SERIAL_THREAD\n# include \"pthread-barrier.h\"\n#endif\n\n#ifndef NI_MAXHOST\n# define NI_MAXHOST 1025\n#endif\n\n#ifndef NI_MAXSERV\n# define NI_MAXSERV 32\n#endif\n\n#ifndef UV_IO_PRIVATE_PLATFORM_FIELDS\n# define UV_IO_PRIVATE_PLATFORM_FIELDS /* empty */\n#endif\n\nstruct uv__io_s;\nstruct uv__async;\nstruct uv_loop_s;\n\ntypedef void (*uv__io_cb)(struct uv_loop_s* loop,\n                          struct uv__io_s* w,\n                          unsigned int events);\ntypedef struct uv__io_s uv__io_t;\n\nstruct uv__io_s {\n  uv__io_cb cb;\n  void* pending_queue[2];\n  void* watcher_queue[2];\n  unsigned int pevents; /* Pending event mask i.e. mask at next tick. */\n  unsigned int events;  /* Current event mask. */\n  int fd;\n  UV_IO_PRIVATE_PLATFORM_FIELDS\n};\n\ntypedef void (*uv__async_cb)(struct uv_loop_s* loop,\n                             struct uv__async* w,\n                             unsigned int nevents);\n\nstruct uv__async {\n  uv__async_cb cb;\n  uv__io_t io_watcher;\n  int wfd;\n};\n\n#ifndef UV_PLATFORM_SEM_T\n# define UV_PLATFORM_SEM_T sem_t\n#endif\n\n#ifndef UV_PLATFORM_LOOP_FIELDS\n# define UV_PLATFORM_LOOP_FIELDS /* empty */\n#endif\n\n#ifndef UV_PLATFORM_FS_EVENT_FIELDS\n# define UV_PLATFORM_FS_EVENT_FIELDS /* empty */\n#endif\n\n#ifndef UV_STREAM_PRIVATE_PLATFORM_FIELDS\n# define UV_STREAM_PRIVATE_PLATFORM_FIELDS /* empty */\n#endif\n\n/* Note: May be cast to struct iovec. See writev(2). */\ntypedef struct uv_buf_t {\n  char* base;\n  size_t len;\n} uv_buf_t;\n\ntypedef int uv_file;\ntypedef int uv_os_sock_t;\ntypedef int uv_os_fd_t;\n\n#define UV_ONCE_INIT PTHREAD_ONCE_INIT\n\ntypedef pthread_once_t uv_once_t;\ntypedef pthread_t uv_thread_t;\ntypedef pthread_mutex_t uv_mutex_t;\ntypedef pthread_rwlock_t uv_rwlock_t;\ntypedef UV_PLATFORM_SEM_T uv_sem_t;\ntypedef pthread_cond_t uv_cond_t;\ntypedef pthread_key_t uv_key_t;\ntypedef pthread_barrier_t uv_barrier_t;\n\n\n/* Platform-specific definitions for uv_spawn support. */\ntypedef gid_t uv_gid_t;\ntypedef uid_t uv_uid_t;\n\ntypedef struct dirent uv__dirent_t;\n\n#if defined(DT_UNKNOWN)\n# define HAVE_DIRENT_TYPES\n# if defined(DT_REG)\n#  define UV__DT_FILE DT_REG\n# else\n#  define UV__DT_FILE -1\n# endif\n# if defined(DT_DIR)\n#  define UV__DT_DIR DT_DIR\n# else\n#  define UV__DT_DIR -2\n# endif\n# if defined(DT_LNK)\n#  define UV__DT_LINK DT_LNK\n# else\n#  define UV__DT_LINK -3\n# endif\n# if defined(DT_FIFO)\n#  define UV__DT_FIFO DT_FIFO\n# else\n#  define UV__DT_FIFO -4\n# endif\n# if defined(DT_SOCK)\n#  define UV__DT_SOCKET DT_SOCK\n# else\n#  define UV__DT_SOCKET -5\n# endif\n# if defined(DT_CHR)\n#  define UV__DT_CHAR DT_CHR\n# else\n#  define UV__DT_CHAR -6\n# endif\n# if defined(DT_BLK)\n#  define UV__DT_BLOCK DT_BLK\n# else\n#  define UV__DT_BLOCK -7\n# endif\n#endif\n\n/* Platform-specific definitions for uv_dlopen support. */\n#define UV_DYNAMIC /* empty */\n\ntypedef struct {\n  void* handle;\n  char* errmsg;\n} uv_lib_t;\n\n#define UV_LOOP_PRIVATE_FIELDS                                                \\\n  unsigned long flags;                                                        \\\n  int backend_fd;                                                             \\\n  void* pending_queue[2];                                                     \\\n  void* watcher_queue[2];                                                     \\\n  uv__io_t** watchers;                                                        \\\n  unsigned int nwatchers;                                                     \\\n  unsigned int nfds;                                                          \\\n  void* wq[2];                                                                \\\n  uv_mutex_t wq_mutex;                                                        \\\n  uv_async_t wq_async;                                                        \\\n  uv_rwlock_t cloexec_lock;                                                   \\\n  uv_handle_t* closing_handles;                                               \\\n  void* process_handles[2];                                                   \\\n  void* prepare_handles[2];                                                   \\\n  void* check_handles[2];                                                     \\\n  void* idle_handles[2];                                                      \\\n  void* async_handles[2];                                                     \\\n  struct uv__async async_watcher;                                             \\\n  struct {                                                                    \\\n    void* min;                                                                \\\n    unsigned int nelts;                                                       \\\n  } timer_heap;                                                               \\\n  uint64_t timer_counter;                                                     \\\n  uint64_t time;                                                              \\\n  int signal_pipefd[2];                                                       \\\n  uv__io_t signal_io_watcher;                                                 \\\n  uv_signal_t child_watcher;                                                  \\\n  int emfile_fd;                                                              \\\n  UV_PLATFORM_LOOP_FIELDS                                                     \\\n\n#define UV_REQ_TYPE_PRIVATE /* empty */\n\n#define UV_REQ_PRIVATE_FIELDS  /* empty */\n\n#define UV_PRIVATE_REQ_TYPES /* empty */\n\n#define UV_WRITE_PRIVATE_FIELDS                                               \\\n  void* queue[2];                                                             \\\n  unsigned int write_index;                                                   \\\n  uv_buf_t* bufs;                                                             \\\n  unsigned int nbufs;                                                         \\\n  int error;                                                                  \\\n  uv_buf_t bufsml[4];                                                         \\\n\n#define UV_CONNECT_PRIVATE_FIELDS                                             \\\n  void* queue[2];                                                             \\\n\n#define UV_SHUTDOWN_PRIVATE_FIELDS /* empty */\n\n#define UV_UDP_SEND_PRIVATE_FIELDS                                            \\\n  void* queue[2];                                                             \\\n  struct sockaddr_storage addr;                                               \\\n  unsigned int nbufs;                                                         \\\n  uv_buf_t* bufs;                                                             \\\n  ssize_t status;                                                             \\\n  uv_udp_send_cb send_cb;                                                     \\\n  uv_buf_t bufsml[4];                                                         \\\n\n#define UV_HANDLE_PRIVATE_FIELDS                                              \\\n  uv_handle_t* next_closing;                                                  \\\n  unsigned int flags;                                                         \\\n\n#define UV_STREAM_PRIVATE_FIELDS                                              \\\n  uv_connect_t *connect_req;                                                  \\\n  uv_shutdown_t *shutdown_req;                                                \\\n  uv__io_t io_watcher;                                                        \\\n  void* write_queue[2];                                                       \\\n  void* write_completed_queue[2];                                             \\\n  uv_connection_cb connection_cb;                                             \\\n  int delayed_error;                                                          \\\n  int accepted_fd;                                                            \\\n  void* queued_fds;                                                           \\\n  UV_STREAM_PRIVATE_PLATFORM_FIELDS                                           \\\n\n#define UV_TCP_PRIVATE_FIELDS /* empty */\n\n#define UV_UDP_PRIVATE_FIELDS                                                 \\\n  uv_alloc_cb alloc_cb;                                                       \\\n  uv_udp_recv_cb recv_cb;                                                     \\\n  uv__io_t io_watcher;                                                        \\\n  void* write_queue[2];                                                       \\\n  void* write_completed_queue[2];                                             \\\n\n#define UV_PIPE_PRIVATE_FIELDS                                                \\\n  const char* pipe_fname; /* strdup'ed */\n\n#define UV_POLL_PRIVATE_FIELDS                                                \\\n  uv__io_t io_watcher;\n\n#define UV_PREPARE_PRIVATE_FIELDS                                             \\\n  uv_prepare_cb prepare_cb;                                                   \\\n  void* queue[2];                                                             \\\n\n#define UV_CHECK_PRIVATE_FIELDS                                               \\\n  uv_check_cb check_cb;                                                       \\\n  void* queue[2];                                                             \\\n\n#define UV_IDLE_PRIVATE_FIELDS                                                \\\n  uv_idle_cb idle_cb;                                                         \\\n  void* queue[2];                                                             \\\n\n#define UV_ASYNC_PRIVATE_FIELDS                                               \\\n  uv_async_cb async_cb;                                                       \\\n  void* queue[2];                                                             \\\n  int pending;                                                                \\\n\n#define UV_TIMER_PRIVATE_FIELDS                                               \\\n  uv_timer_cb timer_cb;                                                       \\\n  void* heap_node[3];                                                         \\\n  uint64_t timeout;                                                           \\\n  uint64_t repeat;                                                            \\\n  uint64_t start_id;\n\n#define UV_GETADDRINFO_PRIVATE_FIELDS                                         \\\n  struct uv__work work_req;                                                   \\\n  uv_getaddrinfo_cb cb;                                                       \\\n  struct addrinfo* hints;                                                     \\\n  char* hostname;                                                             \\\n  char* service;                                                              \\\n  struct addrinfo* addrinfo;                                                  \\\n  int retcode;\n\n#define UV_GETNAMEINFO_PRIVATE_FIELDS                                         \\\n  struct uv__work work_req;                                                   \\\n  uv_getnameinfo_cb getnameinfo_cb;                                           \\\n  struct sockaddr_storage storage;                                            \\\n  int flags;                                                                  \\\n  char host[NI_MAXHOST];                                                      \\\n  char service[NI_MAXSERV];                                                   \\\n  int retcode;\n\n#define UV_PROCESS_PRIVATE_FIELDS                                             \\\n  void* queue[2];                                                             \\\n  int status;                                                                 \\\n\n#define UV_FS_PRIVATE_FIELDS                                                  \\\n  const char *new_path;                                                       \\\n  uv_file file;                                                               \\\n  int flags;                                                                  \\\n  mode_t mode;                                                                \\\n  unsigned int nbufs;                                                         \\\n  uv_buf_t* bufs;                                                             \\\n  off_t off;                                                                  \\\n  uv_uid_t uid;                                                               \\\n  uv_gid_t gid;                                                               \\\n  double atime;                                                               \\\n  double mtime;                                                               \\\n  struct uv__work work_req;                                                   \\\n  uv_buf_t bufsml[4];                                                         \\\n\n#define UV_WORK_PRIVATE_FIELDS                                                \\\n  struct uv__work work_req;\n\n#define UV_TTY_PRIVATE_FIELDS                                                 \\\n  struct termios orig_termios;                                                \\\n  int mode;\n\n#define UV_SIGNAL_PRIVATE_FIELDS                                              \\\n  /* RB_ENTRY(uv_signal_s) tree_entry; */                                     \\\n  struct {                                                                    \\\n    struct uv_signal_s* rbe_left;                                             \\\n    struct uv_signal_s* rbe_right;                                            \\\n    struct uv_signal_s* rbe_parent;                                           \\\n    int rbe_color;                                                            \\\n  } tree_entry;                                                               \\\n  /* Use two counters here so we don have to fiddle with atomics. */          \\\n  unsigned int caught_signals;                                                \\\n  unsigned int dispatched_signals;\n\n#define UV_FS_EVENT_PRIVATE_FIELDS                                            \\\n  uv_fs_event_cb cb;                                                          \\\n  UV_PLATFORM_FS_EVENT_FIELDS                                                 \\\n\n#endif /* UV_UNIX_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-libuv-1.10.0-tvkoat5vslbctz2afzq2jzqjvgrpibgh/spack-src/test/test-dlerror.c": "/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\n#include \"uv.h\"\n#include \"task.h\"\n#include <string.h>\n\n\nTEST_IMPL(dlerror) {\n  const char* path = \"test/fixtures/load_error.node\";\n  const char* dlerror_no_error = \"no error\";\n  const char* msg;\n  uv_lib_t lib;\n  int r;\n\n  lib.errmsg = NULL;\n  lib.handle = NULL;\n  msg = uv_dlerror(&lib);\n  ASSERT(msg != NULL);\n  ASSERT(strstr(msg, dlerror_no_error) != NULL);\n\n  r = uv_dlopen(path, &lib);\n  ASSERT(r == -1);\n\n  msg = uv_dlerror(&lib);\n  ASSERT(msg != NULL);\n  ASSERT(strstr(msg, dlerror_no_error) == NULL);\n\n  /* Should return the same error twice in a row. */\n  msg = uv_dlerror(&lib);\n  ASSERT(msg != NULL);\n  ASSERT(strstr(msg, dlerror_no_error) == NULL);\n\n  uv_dlclose(&lib);\n\n  return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-libuv-1.10.0-tvkoat5vslbctz2afzq2jzqjvgrpibgh/spack-src/docs/src/dll.rst": "\n.. _dll:\n\nShared library handling\n=======================\n\nlibuv provides cross platform utilities for loading shared libraries and\nretrieving symbols from them, using the following API.\n\n\nData types\n----------\n\n.. c:type:: uv_lib_t\n\n    Shared library data type.\n\n\nPublic members\n^^^^^^^^^^^^^^\n\nN/A\n\n\nAPI\n---\n\n.. c:function:: int uv_dlopen(const char* filename, uv_lib_t* lib)\n\n    Opens a shared library. The filename is in utf-8. Returns 0 on success and\n    -1 on error. Call :c:func:`uv_dlerror` to get the error message.\n\n.. c:function:: void uv_dlclose(uv_lib_t* lib)\n\n    Close the shared library.\n\n.. c:function:: int uv_dlsym(uv_lib_t* lib, const char* name, void** ptr)\n\n    Retrieves a data pointer from a dynamic library. It is legal for a symbol\n    to map to NULL. Returns 0 on success and -1 if the symbol was not found.\n\n.. c:function:: const char* uv_dlerror(const uv_lib_t* lib)\n\n    Returns the last uv_dlopen() or uv_dlsym() error message.\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-libuv-1.10.0-tvkoat5vslbctz2afzq2jzqjvgrpibgh/spack-src/img/banner.png",
        "/tmp/vanessa/spack-stage/spack-stage-libuv-1.10.0-tvkoat5vslbctz2afzq2jzqjvgrpibgh/spack-src/docs/src/static/architecture.png",
        "/tmp/vanessa/spack-stage/spack-stage-libuv-1.10.0-tvkoat5vslbctz2afzq2jzqjvgrpibgh/spack-src/docs/src/static/loop_iteration.png",
        "/tmp/vanessa/spack-stage/spack-stage-libuv-1.10.0-tvkoat5vslbctz2afzq2jzqjvgrpibgh/spack-src/docs/src/static/logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-libuv-1.10.0-tvkoat5vslbctz2afzq2jzqjvgrpibgh/spack-src/docs/src/static/favicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-libuv-1.10.0-tvkoat5vslbctz2afzq2jzqjvgrpibgh/spack-src/docs/src/static/diagrams.key/preview-web.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-libuv-1.10.0-tvkoat5vslbctz2afzq2jzqjvgrpibgh/spack-src/docs/src/static/diagrams.key/Index.zip",
        "/tmp/vanessa/spack-stage/spack-stage-libuv-1.10.0-tvkoat5vslbctz2afzq2jzqjvgrpibgh/spack-src/docs/src/static/diagrams.key/preview.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-libuv-1.10.0-tvkoat5vslbctz2afzq2jzqjvgrpibgh/spack-src/docs/src/static/diagrams.key/preview-micro.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-libuv-1.10.0-tvkoat5vslbctz2afzq2jzqjvgrpibgh/spack-src/docs/src/static/diagrams.key/Metadata/Properties.plist",
        "/tmp/vanessa/spack-stage/spack-stage-libuv-1.10.0-tvkoat5vslbctz2afzq2jzqjvgrpibgh/spack-src/docs/src/static/diagrams.key/Data/st0-311.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-libuv-1.10.0-tvkoat5vslbctz2afzq2jzqjvgrpibgh/spack-src/docs/src/static/diagrams.key/Data/st1-475.jpg"
    ],
    "total_files": 333
}