{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-henson-master-mt4pvbwo3sc6hu4gktcdjfn34gp7hwmf/spack-src/README.md": "# Henson\n\n## Contents\n\n  * [Example](#example)\n  * [Motivation](#motivation)\n  * [Code](#code)\n    - [Headers](#headers)\n    - [MPI](#mpi)\n    - [Control Transfer](#control-transfer)\n    - [Data Exchange](#data-exchange)\n    - [Execution Groups][]\n  * [HWL][]\n  * [Henson Invocation](#henson-invocation)\n  * [Compiling and Linking](#compiling-and-linking)\n\n[Execution Groups]:   #execution-groups\n[HWL]:                #hwl\n\n## Example\n\nSee [simulation.c][] and [analysis.cpp][] in [examples/simple](examples/simple) for sample code.\n\n[simulation.c]:     examples/simple/simulation.c\n[analysis.cpp]:     examples/simple/analysis.cpp\n\n[ChaiScript example](examples/simple/simple.chai):\n```\nmpirun -n 4 henson-chai simple.chai\n\n# simple.chai\n\nvar procmap = ProcMap()\n\nvar sim = load(\"./simulation 1000\", procmap)\nvar ana = load(\"./analysis\", procmap)\n\nwhile(sim.proceed())\n{\n    ana.proceed()\n}\n```\n\n[HWL example](examples/simple/simple.hwl):\n```\nmpirun -n 4 henson-hwl simple.hwl\n\n# simple.hwl\n\nsim = ./simulation 1000\nana = ./analysis\n\nworld while sim:\n    sim\n    ana\n```\n\nOther examples:\n\n  * [examples/intercomm](examples/intercomm) illustrates multiple execution groups;\n  * [examples/async](examples/async) does the same, but with asynchronous data exchange.\n\n## Motivation\n\nTo avoid IO overhead, analysis codes need to access simulation data, while the\nsimulation is running, without saving the data to disk. The goal is to let\nmultiple independent executables share memory (e.g., exchange arrays without\ncopying their contents) without modifying their memory management systems. We\nwould also like to control the execution flow, for example, switching between\nsimulation and analysis after every step of the simulation.\n\n**Shared address space.**\nIf the executables are built as position-independent code, then their `main` routines\ncan be loaded using the [dynamic loading](https://en.wikipedia.org/wiki/Dynamic_loading) facilities `dlopen` and `dlsym`:\n\n```{.cpp}\ntypedef     int  (*MainType)(int argc, char *argv[]);\n\nvoid*       lib      = dlopen(fn.c_str(), RTLD_LAZY);\nMainType    lib_main = (MainType) dlsym(lib, \"main\");\n```\nWe can subsequently call `main` routines from a controlling process, in the\nappropriate order. Since all the executables get loaded into the same address\nspace, the data can be exchanged between them by simply passing pointers around\n\u2014 no copying or special tricks are required. (Achieving the same zero-copy\nbetween separate processes is much more complicated.)\n\n**Coroutines.**\nHow can we transfer control from one `main` to another?\nA simulation may want to stop after every time-step,\ntransfer control to the analysis code, but then resume where it left off\nwithout losing its state. Similarly, analysis may not be a single executable,\nbut a chain (or a DAG) of different executables that transfer control to each\nother and resume where they left off when the execution returns.\n\nA convenient way to support such a cooperative multitasking regime is via\n[coroutines](https://en.wikipedia.org/wiki/Coroutine).\nExecutables call `henson_yield()` when they want to relinquish control back to\n`henson`. When not running under `henson`, this\nroutine does nothing and returns immediately.\n\n\n## Code\n\n### Headers\n\n`henson`'s main interface is in C to make it easy to use from C simulation and\nanalysis routines. Additionally, it provides some C++ helper functions for\nmoving data across coroutines.\n\n```{.cpp}\n#include <henson/context.h>\n#include <henson/data.h>\n#include <henson/data.hpp>      // C++ functions\n```\n\n### MPI\n\nSince all executables become part of the main `henson` process, MPI must be\ninitialized and finalized only once. `henson` takes care of the initialization,\nso, when running under it, coroutines cannot initialize MPI themselves.\n`libhenson`, in the default configuration, includes MPI wrappers (built on\nPMPI interface) that are only active when the puppet is running under `henson`.\nThe wrappers disable initialization and finalization. They also replace\n`MPI_COMM_WORLD` by the result of `henson_get_world()`, which returns the MPI\ncommunicator restricted to the puppet's execution group.\nSee [execution groups][Execution Groups] for more details.\n\nIf the wrappers are disabled, the user must avoid initialization/finalization\nmanually and explicitly request the correct communicator using\n`henson_get_world()`.\n\n### Control Transfer\n\nA coroutine can transfer control back to `henson` by calling `henson_yield()`.\n`henson` in turn decides where to continue execution next. `henson` cycles\nthrough all coroutines in an [execution group][Execution Groups] in order until\nthe controlling coroutine specified in the `while`-clause terminates. Once this happens, every\nremaining coroutine in the group loop gets called once. A coroutine may check\nif its execution group is about to stop (i.e., if a controlling coroutine has\nindicated that it's done) by calling `henson_stop()`.\n\n### Data Exchange\n\nCoroutines can exchange data by posting it to a global namespace. Several\nhelper functions allow exchanging specific types of data:\n\n  * `henson_{save,load}_array(name, address, type, count, stride)`\n  * `henson_{save,load}_pointer(name, ptr)`\n  * `henson_{save,load}_size_t(name, size)`\n  * `henson_{save,load}_int(name, x)`\n  * `henson_{save,load}_float(name, x)`\n  * `henson_{save,load}_double(name, x)`\n\nIn C++, there are additional functions:\n\n  * `henson::save(name, x)`\n  * `template<class T> T* henson::load(name)`\n  * `henson::exists(name)`\n\nSee [include/henson/data.h](include/henson/data.h) and\n[include/henson/data.hpp](include/henson/data.hpp)\nfor more details.\n\n#### Producer\n\n```{.c}\nfor (/* every timestep */)\n{\n    // perform some computation\n\n    henson_save_array(...);\n    henson_yield();             // return control back to henson\n}\n```\n\n#### Consumer\n\nProcess every time step:\n```{.c}\nwhile(1)\n{\n    henson_load_array(...);\n\n    // process the data\n    // if there is any output to pass to other analysis routines downstream,\n    // call an appropriate henson_save_...(...)\n\n    henson_yield();             // return control back to henson\n}\n\n```\n\nOr process a single snapshot:\n```{.c}\nfloat* data;\nsize_t size;\nif (!henson_active())\n    // load data from file\nelse\n{\n    henson_load_array(\"data\", &data, ...);\n    henson_load_size_t(\"size\", &size);\n}\n\n// process the data\n```\nNote that the non-controlling coroutine will be restarted over and over again\nas long the controlling coroutine is running. So if the producer generates data\nover multiple time-steps, it's fine to supply a consumer that processes only\na single snapshot; it will be restarted automatically. See [HWL][].\n\n\n### Execution Groups\n\nDifferent sets of processors may run through different coroutine loops. For\nexample, the simulation and analysis may run on different processes;\nthey could switch contexts with additional coroutines that exchange the data\nbetween the groups. The user may specify the different execution groups in the\nscript supplied to `henson`, specifying the number of processors to dedicate to\neach group on the command-line. (If no group sizes are specified, the processes\nare split evenly between the groups.)\n[examples/intercomm/intercomm.hwl](examples/intercomm/intercomm.hwl) implements\nsuch a pattern. Instead of switching directly to [analysis.cpp][],\n[simulation.c][] switches to [send.cpp][], which sends its data over MPI to\n[receive.cpp][] on a different set of processes; [receive.cpp][] in turn\nswitches to [analysis.cpp][].\n\n[send.cpp]:     tools/send.cpp\n[receive.cpp]:  tools/receive.cpp\n\n`henson_get_world()` returns the communicator restricted to each execution\ngroup. In the default configuration, it's not necessary to call this function\ndirectly because the MPI wrappers built into `henson` will replace any instance\nof `MPI_COMM_WORLD` with the result of this function. To communicate across\ngroups, [send.cpp][] and [receive.cpp][] use `henson_get_intercomm(group_name)`\nto get the appropriate MPI inter-communicator.\n\nSection [HWL][] describes how to specify execution groups in the scripts\nsupplied to `henson`.\n\n## HWL\n\nThe following annotated example\n(original in [intercomm.hwl](examples/intercomm/intercomm.hwl))\nillustrates the syntax of the scripts supplied to henson.\n(A simpler example is [simple.hwl](examples/simple/simple.hwl).)\n\nFirst, the script specifies the command lines to run and assigns them names.\nThese commands become the coroutines. Command lines may contain variables (with\ndefaults in parentheses); the variable values can be supplied to `henson` on\nits command line.\n```\nsim = ../simple/simulation $size(250)\nsnd = ../../tools/send      consumer t:int data:array\nrcv = ../../tools/receive   producer t:int data:array\nana = ../simple/analysis\n```\n\nNext, the script specifies two execution groups, `producer` and `consumer`. The\nformer cycles through coroutines `sim` and `snd`; the latter cycles through\n`rcv` and `ana`.\n```\nproducer while sim:\n\tsim\n\tsnd\n\nconsumer while rcv:\n\trcv\n\tana\n```\n\nThe script specifies, via the `while`-clause, that `sim` and `rcv` control execution. I.e.,\n`producer` group will stop when `sim` stops. `consumer` group stops when `rcv`\ndoes. Notice that for `rcv` to find out that no more data will arrive, `snd`\nneeds to send it the appropriate message. Accordingly, [send.cpp][] checks whether\n`producer` group is stopping by calling `henson_stop()`, and sends the stop\nmessage when this happens.\n\n## Henson Invocation\n\n`henson` accepts the following command-line options. The user can specify on\nthe command line how many processors to use for each execution group (`-p`) and\nvariable values to use inside HWL scripts.\n\n```\nUsage: ./henson SCRIPT [-p group=SIZE]* [variable=value]*\n\nExecute SCRIPT. procs are the names of execution groups in the script.\nLeftover processors get split evenly among the execution groups in the SCRIPT\nbut not specified in the procs list.\n\nOptions:\n   -p, --procs SEQUENCE     number of processors to use for a control group [default: ()]\n   -l, --log STRING         log level to use [default: info]\n   -s, --show-sizes         show group sizes\n   -v, --verbose            verbose output\n   -t, --show-times         show time spent in each puppet\n       --every-iteration    report times at every iteration\n   -h, --help               show help\n```\n\n\n## Compiling and Linking\n\nBy default, Henson uses [libcoro](http://software.schmorp.de/pkg/libcoro.html)\nto switch contexts between the coroutines; it's included in the source.\nHenson optionally depends on [Boost](http://www.boost.org) `>=1.58`,\nspecifically, the Boost.Context library, which can be used instead of `libcoro`.\n\nYou can build Henson library, executable, and examples using CMake:\n```\ncmake .../path/to/henson\nmake\n```\n\nCMake accepts the following options:\n\n  - `-Duse_boost=on` to switch from `libcoro` to Boost.Context\n  - `-Dregenerate-wrapper=on` to regenerate MPI wrappers for the specific implementation you are using (requires Python)\n  - `-Dpython=off` to disable building Python bindings\n  - `-Dmpi-wrappers=off` to not include MPI wrappers into `libhenson`\n\nWhen building your own executables, it's important to pass certain flags to the\ncompiler and to the linker. Compiler needs to prepare position-independent code;\nfor executables, GCC and Clang need option `-fPIE` to do so.\n(In CMake, this option is added automatically when\n`CMAKE_POSITION_INDEPENDENT_CODE` is `on`.)\n\nWe need to make sure the linker exposes all symbols that `henson` needs. Under\nMac OS X, this seems to happen automatically, but under Linux we need\nadditional flags. At a minimum we need to add `-pie -Wl,--export-dynamic`.\nSometimes we have to add `-Wl,-u,henson_set_contexts,-u,henson_set_namemap` to\nforce the linker to export functions even if they are not called within the\nexecutable itself.\n\nIn general, getting the linker flags right for the executables is the most\ncomplicated part of using Henson.\n",
        "/tmp/vanessa/spack-stage/spack-stage-henson-master-mt4pvbwo3sc6hu4gktcdjfn34gp7hwmf/spack-src/include/chaiscript/language/chaiscript_engine.hpp": "// This file is distributed under the BSD License.\n// See \"license.txt\" for details.\n// Copyright 2009-2012, Jonathan Turner (jonathan@emptycrate.com)\n// Copyright 2009-2016, Jason Turner (jason@emptycrate.com)\n// http://www.chaiscript.com\n\n#ifndef CHAISCRIPT_ENGINE_HPP_\n#define CHAISCRIPT_ENGINE_HPP_\n\n#include <cassert>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <map>\n#include <memory>\n#include <mutex>\n#include <set>\n#include <stdexcept>\n#include <vector>\n\n#include \"../chaiscript_defines.hpp\"\n#include \"../chaiscript_threading.hpp\"\n#include \"../dispatchkit/boxed_cast_helper.hpp\"\n#include \"../dispatchkit/boxed_value.hpp\"\n#include \"../dispatchkit/dispatchkit.hpp\"\n#include \"../dispatchkit/type_conversions.hpp\"\n#include \"../dispatchkit/proxy_functions.hpp\"\n#include \"chaiscript_common.hpp\"\n\n#if defined(__linux__) || defined(__unix__) || defined(__APPLE__) || defined(__HAIKU__)\n#include <unistd.h>\n#endif\n\n#if defined(_POSIX_VERSION) && !defined(__CYGWIN__) \n#include <dlfcn.h>\n#else\n#ifdef CHAISCRIPT_WINDOWS\n#define VC_EXTRA_LEAN\n#if !defined(WIN32_LEAN_AND_MEAN)\n#define WIN32_LEAN_AND_MEAN\n#endif\n#include <windows.h>\n#endif\n#endif\n\n\n#include \"../dispatchkit/exception_specification.hpp\"\n#include \"chaiscript_parser.hpp\"\n\nnamespace chaiscript\n{\n  namespace exception\n  {\n    /// \\brief Thrown if an error occurs while attempting to load a binary module\n    struct load_module_error : std::runtime_error\n    {\n      load_module_error(const std::string &t_reason) CHAISCRIPT_NOEXCEPT\n        : std::runtime_error(t_reason)\n      {\n      }\n\n      load_module_error(const load_module_error &) = default;\n      virtual ~load_module_error() CHAISCRIPT_NOEXCEPT {}\n    };\n  }\n\n  namespace detail\n  {\n#if defined(_POSIX_VERSION) && !defined(__CYGWIN__) \n    struct Loadable_Module\n    {\n      struct DLModule\n      {\n        DLModule(const std::string &t_filename)\n          : m_data(dlopen(t_filename.c_str(), RTLD_NOW))\n        {\n          if (!m_data)\n          {\n            throw chaiscript::exception::load_module_error(dlerror());\n          }\n        }\n\n        DLModule(const DLModule &); // Explicitly unimplemented copy constructor\n        DLModule &operator=(const DLModule &); // Explicitly unimplemented assignment operator\n\n        ~DLModule()\n        {\n          dlclose(m_data);\n        }\n\n        void *m_data;\n      };\n\n      template<typename T>\n        struct DLSym\n        {\n          DLSym(DLModule &t_mod, const std::string &t_symbol)\n            : m_symbol(cast_symbol(dlsym(t_mod.m_data, t_symbol.c_str())))\n          {\n            if (!m_symbol)\n            {\n              throw chaiscript::exception::load_module_error(dlerror());\n            }\n          }\n\n          static T cast_symbol(void *p)\n          {\n            union cast_union\n            {\n              T func_ptr;\n              void *in_ptr;\n            };\n\n            cast_union c;\n            c.in_ptr = p;\n            return c.func_ptr;\n          }\n\n          T m_symbol;\n        };\n\n      Loadable_Module(const std::string &t_module_name, const std::string &t_filename)\n        : m_dlmodule(t_filename), m_func(m_dlmodule, \"create_chaiscript_module_\" + t_module_name),\n        m_moduleptr(m_func.m_symbol())\n      {\n      }\n\n      DLModule m_dlmodule;\n      DLSym<Create_Module_Func> m_func;\n      ModulePtr m_moduleptr;\n    };\n#else\n\n#ifdef WIN32\n\n\n    struct Loadable_Module\n    {\n      template<typename T>\n        static std::wstring to_wstring(const T &t_str) \n        {\n          return std::wstring(t_str.begin(), t_str.end());\n        }\n\n      template<typename T>\n        static std::string to_string(const T &t_str)\n        {\n          return std::string(t_str.begin(), t_str.end());\n        }\n\n#if defined(_UNICODE) || defined(UNICODE)\n        template<typename T>\n        static std::wstring to_proper_string(const T &t_str)\n        {\n          return to_wstring(t_str);\n        }\n#else\n      template<typename T>\n        static std::string to_proper_string(const T &t_str)\n        {\n          return to_string(t_str);\n        }\n#endif\n\n      static std::string get_error_message(DWORD t_err)\n      {\n        typedef LPTSTR StringType;\n\n#if defined(_UNICODE) || defined(UNICODE)\n        std::wstring retval = L\"Unknown Error\";\n#else\n        std::string retval = \"Unknown Error\";\n#endif\n        StringType lpMsgBuf = nullptr;\n\n        if (FormatMessage(\n            FORMAT_MESSAGE_ALLOCATE_BUFFER | \n            FORMAT_MESSAGE_FROM_SYSTEM |\n            FORMAT_MESSAGE_IGNORE_INSERTS,\n            nullptr,\n            t_err,\n            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n            reinterpret_cast<StringType>(&lpMsgBuf),\n            0, nullptr ) != 0 && lpMsgBuf)\n        {\n          retval = lpMsgBuf;\n          LocalFree(lpMsgBuf);\n        }\n\n        return to_string(retval);\n      }\n\n      struct DLModule\n      {\n        DLModule(const std::string &t_filename)\n          : m_data(LoadLibrary(to_proper_string(t_filename).c_str()))\n        {\n          if (!m_data)\n          {\n            throw chaiscript::exception::load_module_error(get_error_message(GetLastError()));\n          }\n        }\n\n        ~DLModule()\n        {\n          FreeLibrary(m_data);\n        }\n\n        HMODULE m_data;\n      };\n\n      template<typename T>\n        struct DLSym\n        {\n          DLSym(DLModule &t_mod, const std::string &t_symbol)\n            : m_symbol(reinterpret_cast<T>(GetProcAddress(t_mod.m_data, t_symbol.c_str())))\n          {\n            if (!m_symbol)\n            {\n              throw chaiscript::exception::load_module_error(get_error_message(GetLastError()));\n            }\n          }\n\n          T m_symbol;\n        };\n\n      Loadable_Module(const std::string &t_module_name, const std::string &t_filename)\n        : m_dlmodule(t_filename), m_func(m_dlmodule, \"create_chaiscript_module_\" + t_module_name),\n        m_moduleptr(m_func.m_symbol())\n      {\n      }\n\n      DLModule m_dlmodule;\n      DLSym<Create_Module_Func> m_func;\n      ModulePtr m_moduleptr;\n    };\n\n#else\n    struct Loadable_Module\n    {\n      Loadable_Module(const std::string &, const std::string &)\n      {\n        throw chaiscript::exception::load_module_error(\"Loadable module support not available for your platform\");\n      }\n\n      ModulePtr m_moduleptr;\n    };\n#endif\n#endif\n\n    typedef std::shared_ptr<Loadable_Module> Loadable_Module_Ptr;\n  }\n\n\n  /// \\brief The main object that the ChaiScript user will use.\n  class ChaiScript {\n\n    mutable chaiscript::detail::threading::shared_mutex m_mutex;\n    mutable chaiscript::detail::threading::recursive_mutex m_use_mutex;\n\n    std::set<std::string> m_used_files;\n    std::map<std::string, detail::Loadable_Module_Ptr> m_loaded_modules;\n    std::set<std::string> m_active_loaded_modules;\n\n    std::vector<std::string> m_module_paths;\n    std::vector<std::string> m_use_paths;\n\n    chaiscript::detail::Dispatch_Engine m_engine;\n\n    /// Evaluates the given string in by parsing it and running the results through the evaluator\n    Boxed_Value do_eval(const std::string &t_input, const std::string &t_filename = \"__EVAL__\", bool /* t_internal*/  = false) \n    {\n      try {\n        parser::ChaiScript_Parser parser;\n        if (parser.parse(t_input, t_filename)) {\n          //parser.show_match_stack();\n          return parser.optimized_ast()->eval(m_engine);\n        } else {\n          return Boxed_Value();\n        }\n      }\n      catch (chaiscript::eval::detail::Return_Value &rv) {\n        return rv.retval;\n      }\n    }\n\n\n\n\n\n    /// Evaluates the given file and looks in the 'use' paths\n    const Boxed_Value internal_eval_file(const std::string &t_filename) {\n      for (const auto &path : m_use_paths)\n      {\n        try {\n          const auto appendedpath = path + t_filename;\n          return do_eval(load_file(appendedpath), appendedpath, true);\n        } catch (const exception::file_not_found_error &) {\n          // failed to load, try the next path\n        } catch (const exception::eval_error &t_ee) {\n          throw Boxed_Value(t_ee);\n        }\n      }\n\n      // failed to load by any name\n      throw exception::file_not_found_error(t_filename);\n\n    }\n\n\n\n    /// Evaluates the given string, used during eval() inside of a script\n    const Boxed_Value internal_eval(const std::string &t_e) {\n      try {\n        return do_eval(t_e, \"__EVAL__\", true);\n      } catch (const exception::eval_error &t_ee) {\n        throw Boxed_Value(t_ee);\n      }\n    }\n\n    /// Returns the current evaluation m_engine\n    chaiscript::detail::Dispatch_Engine &get_eval_engine() {\n      return m_engine;\n    }\n\n    /// Builds all the requirements for ChaiScript, including its evaluator and a run of its prelude.\n    void build_eval_system(const ModulePtr &t_lib) {\n      m_engine.add_reserved_word(\"def\");\n      m_engine.add_reserved_word(\"fun\");\n      m_engine.add_reserved_word(\"while\");\n      m_engine.add_reserved_word(\"for\");\n      m_engine.add_reserved_word(\"if\");\n      m_engine.add_reserved_word(\"else\");\n      m_engine.add_reserved_word(\"&&\");\n      m_engine.add_reserved_word(\"||\");\n      m_engine.add_reserved_word(\",\");\n      m_engine.add_reserved_word(\"auto\");\n      m_engine.add_reserved_word(\"return\");\n      m_engine.add_reserved_word(\"break\");\n      m_engine.add_reserved_word(\"true\");\n      m_engine.add_reserved_word(\"false\");\n      m_engine.add_reserved_word(\"class\");\n      m_engine.add_reserved_word(\"attr\");\n      m_engine.add_reserved_word(\"var\");\n      m_engine.add_reserved_word(\"global\");\n      m_engine.add_reserved_word(\"GLOBAL\");\n      m_engine.add_reserved_word(\"_\");\n\n      if (t_lib)\n      {\n        add(t_lib);\n      }\n\n      m_engine.add(fun([this](){ m_engine.dump_system(); }), \"dump_system\");\n      m_engine.add(fun([this](const Boxed_Value &t_bv){ m_engine.dump_object(t_bv); }), \"dump_object\");\n      m_engine.add(fun([this](const Boxed_Value &t_bv, const std::string &t_type){ return m_engine.is_type(t_bv, t_type); }), \"is_type\");\n      m_engine.add(fun([this](const Boxed_Value &t_bv){ return m_engine.type_name(t_bv); }), \"type_name\");\n      m_engine.add(fun([this](const std::string &t_f){ return m_engine.function_exists(t_f); }), \"function_exists\");\n      m_engine.add(fun([this](){ return m_engine.get_function_objects(); }), \"get_functions\");\n      m_engine.add(fun([this](){ return m_engine.get_scripting_objects(); }), \"get_objects\");\n\n      m_engine.add(\n          dispatch::make_dynamic_proxy_function(\n              [this](const std::vector<Boxed_Value> &t_params) {\n                return m_engine.call_exists(t_params);\n              })\n          , \"call_exists\");\n\n//      m_engine.add(fun<Boxed_Value (const dispatch::Proxy_Function_Base *, const std::vector<Boxed_Value> &)>(std::bind(&chaiscript::dispatch::Proxy_Function_Base::operator(), std::placeholders::_1, std::placeholders::_2, std::ref(m_engine.conversions()))), \"call\");\n//\n//\n\n      m_engine.add(fun(\n            [=](const dispatch::Proxy_Function_Base &t_fun, const std::vector<Boxed_Value> &t_params) -> Boxed_Value {\n              Type_Conversions_State s(this->m_engine.conversions(), this->m_engine.conversions().conversion_saves());\n              return t_fun(t_params, s);\n            }), \"call\");\n\n\n      m_engine.add(fun([this](const Type_Info &t_ti){ return m_engine.get_type_name(t_ti); }), \"name\");\n\n      m_engine.add(fun([this](const std::string &t_type_name, bool t_throw){ return m_engine.get_type(t_type_name, t_throw); }), \"type\");\n      m_engine.add(fun([this](const std::string &t_type_name){ return m_engine.get_type(t_type_name, true); }), \"type\");\n\n      m_engine.add(fun(\n            [=](const Type_Info &t_from, const Type_Info &t_to, const std::function<Boxed_Value (const Boxed_Value &)> &t_func) {\n              m_engine.add(chaiscript::type_conversion(t_from, t_to, t_func));\n            }\n          ), \"add_type_conversion\");\n\n\n\n      m_engine.add(fun([this](const std::string &t_module, const std::string &t_file){ return load_module(t_module, t_file); }), \"load_module\");\n      m_engine.add(fun([this](const std::string &t_module){ return load_module(t_module); }), \"load_module\");\n\n      m_engine.add(fun([this](const std::string &t_file){ return use(t_file); }), \"use\");\n      m_engine.add(fun([this](const std::string &t_file){ return internal_eval_file(t_file); }), \"eval_file\");\n      m_engine.add(fun([this](const std::string &t_str){ return internal_eval(t_str); }), \"eval\");\n      m_engine.add(fun([this](const AST_NodePtr &t_ast){ return eval(t_ast); }), \"eval\");\n      m_engine.add(fun(&parse), \"parse\");\n\n      m_engine.add(fun(&ChaiScript::version_major), \"version_major\");\n      m_engine.add(fun(&ChaiScript::version_minor), \"version_minor\");\n      m_engine.add(fun(&ChaiScript::version_patch), \"version_patch\");\n      m_engine.add(fun(&ChaiScript::version), \"version\");\n      m_engine.add(fun(&ChaiScript::compiler_version), \"compiler_version\");\n      m_engine.add(fun(&ChaiScript::compiler_name), \"compiler_name\");\n      m_engine.add(fun(&ChaiScript::compiler_id), \"compiler_id\");\n      m_engine.add(fun(&ChaiScript::debug_build), \"debug_build\");\n\n      m_engine.add(fun([this](const Boxed_Value &t_bv, const std::string &t_name){ add_global_const(t_bv, t_name); }), \"add_global_const\");\n      m_engine.add(fun([this](const Boxed_Value &t_bv, const std::string &t_name){ add_global(t_bv, t_name); }), \"add_global\");\n      m_engine.add(fun([this](const Boxed_Value &t_bv, const std::string &t_name){ set_global(t_bv, t_name); }), \"set_global\");\n    }\n\n\n    /// Helper function for loading a file\n    static std::string load_file(const std::string &t_filename) {\n      std::ifstream infile(t_filename.c_str(), std::ios::in | std::ios::ate | std::ios::binary );\n\n      if (!infile.is_open()) {\n        throw chaiscript::exception::file_not_found_error(t_filename);\n      }\n\n      const auto size = infile.tellg();\n      infile.seekg(0, std::ios::beg);\n\n      assert(size >= 0);\n\n      if (size == std::streampos(0))\n      {\n        return std::string();\n      } else {\n        std::vector<char> v(static_cast<size_t>(size));\n        infile.read(&v[0], size);\n        return std::string(v.begin(), v.end());\n      }\n    }\n\n  public:\n    /// \\brief Constructor for ChaiScript\n    /// \\param[in] t_lib Standard library to apply to this ChaiScript instance\n    /// \\param[in] t_modulepaths Vector of paths to search when attempting to load a binary module\n    /// \\param[in] t_usepaths Vector of paths to search when attempting to \"use\" an included ChaiScript file\n    ChaiScript(const ModulePtr &t_lib,\n               std::vector<std::string> t_modulepaths = std::vector<std::string>(),\n                      std::vector<std::string> t_usepaths = std::vector<std::string>())\n      : m_module_paths(std::move(t_modulepaths)), m_use_paths(std::move(t_usepaths))\n    {\n      if (m_module_paths.empty())\n      {\n        m_module_paths.push_back(\"\");\n      }\n\n      if (m_use_paths.empty())\n      {\n        m_use_paths.push_back(\"\");\n      }\n\n      build_eval_system(t_lib);\n    }\n\n    /// \\brief Constructor for ChaiScript.\n    /// \n    /// This version of the ChaiScript constructor attempts to find the stdlib module to load\n    /// at runtime generates an error if it cannot be found.\n    ///\n    /// \\param[in] t_modulepaths Vector of paths to search when attempting to load a binary module\n    /// \\param[in] t_usepaths Vector of paths to search when attempting to \"use\" an included ChaiScript file\n    ChaiScript( std::vector<std::string> t_modulepaths = std::vector<std::string>(),\n                      std::vector<std::string> t_usepaths = std::vector<std::string>())\n      : m_module_paths(std::move(t_modulepaths)), m_use_paths(std::move(t_usepaths))\n    {\n      if (m_module_paths.empty())\n      {\n        m_module_paths.push_back(\"\");\n      }\n\n      if (m_use_paths.empty())\n      {\n        m_use_paths.push_back(\"\");\n      }\n\n#if defined(_POSIX_VERSION) && !defined(__CYGWIN__) \n      // If on Unix, add the path of the current executable to the module search path\n      // as windows would do\n\n      union cast_union\n      {\n        Boxed_Value (ChaiScript::*in_ptr)(const std::string&);\n        void *out_ptr;\n      };\n\n      Dl_info rInfo; \n      memset( &rInfo, 0, sizeof(rInfo) ); \n      cast_union u;\n      u.in_ptr = &ChaiScript::use;\n      if ( dladdr(static_cast<void*>(u.out_ptr), &rInfo) && rInfo.dli_fname ) { \n        std::string dllpath(rInfo.dli_fname);\n        const size_t lastslash = dllpath.rfind('/');\n        if (lastslash != std::string::npos)\n        {\n          dllpath.erase(lastslash);\n        }\n\n        // Let's see if this is a link that we should expand\n        std::vector<char> buf(2048);\n        const size_t pathlen = readlink(dllpath.c_str(), &buf.front(), buf.size());\n        if (pathlen > 0 && pathlen < buf.size())\n        {\n          dllpath = std::string(&buf.front(), pathlen);\n        }\n\n        m_module_paths.insert(m_module_paths.begin(), dllpath+\"/\");\n      }\n#endif\n\n\n      // attempt to load the stdlib\n      load_module(\"chaiscript_stdlib-\" + version());\n\n      build_eval_system(ModulePtr());\n    }\n\n\n    const Boxed_Value eval(const AST_NodePtr &t_ast)\n    {\n      try {\n        return t_ast->eval(m_engine);\n      } catch (const exception::eval_error &t_ee) {\n        throw Boxed_Value(t_ee);\n      }\n    }\n\n    static AST_NodePtr parse(const std::string &t_input)\n    {\n      parser::ChaiScript_Parser parser;\n      if (parser.parse(t_input, \"PARSE\")) {\n        //parser.show_match_stack();\n        return parser.optimized_ast();\n      } else {\n        throw chaiscript::exception::eval_error(\"Unknown error while parsing\");\n      }\n    }\n\n\n    static int version_major()\n    {\n      return chaiscript::version_major;\n    }\n\n    static int version_minor()\n    {\n      return chaiscript::version_minor;\n    }\n\n    static int version_patch()\n    {\n      return chaiscript::version_patch;\n    }\n\n    static std::string version()\n    {\n      return std::to_string(version_major()) + '.' + std::to_string(version_minor()) + '.' + std::to_string(version_patch());\n    }\n\n    static std::string compiler_id()\n    {\n      return compiler_name() + '-' + compiler_version();\n    }\n\n    static std::string build_id()\n    {\n      return compiler_id() + (debug_build()?\"-Debug\":\"-Release\");\n    }\n\n    static std::string compiler_version()\n    {\n      return chaiscript::compiler_version;\n    }\n\n    static std::string compiler_name()\n    {\n      return chaiscript::compiler_name;\n    }\n\n    static bool debug_build()\n    {\n      return chaiscript::debug_build;\n    }\n\n\n\n    std::string get_type_name(const Type_Info &ti) const\n    {\n      return m_engine.get_type_name(ti);\n    }\n\n    template<typename T>\n    std::string get_type_name() const\n    {\n      return get_type_name(user_type<T>());\n    }\n\n\n    /// \\brief Loads and parses a file. If the file is already, it is not reloaded\n    /// The use paths specified at ChaiScript construction time are searched for the \n    /// requested file.\n    ///\n    /// \\param[in] t_filename Filename to load and evaluate\n    Boxed_Value use(const std::string &t_filename)\n    {\n      for (const auto &path : m_use_paths)\n      {\n        try {\n          const auto appendedpath = path + t_filename;\n\n          chaiscript::detail::threading::unique_lock<chaiscript::detail::threading::recursive_mutex> l(m_use_mutex);\n          chaiscript::detail::threading::unique_lock<chaiscript::detail::threading::shared_mutex> l2(m_mutex);\n\n          Boxed_Value retval;\n\n          if (m_used_files.count(appendedpath) == 0)\n          {\n            l2.unlock();\n            retval = eval_file(appendedpath);\n            l2.lock();\n            m_used_files.insert(appendedpath);\n          }\n\n          return retval; // return, we loaded it, or it was already loaded\n        } catch (const exception::file_not_found_error &) {\n          // failed to load, try the next path\n        }\n      }\n\n      // failed to load by any name\n      throw exception::file_not_found_error(t_filename);\n    }\n\n    /// \\brief Adds a constant object that is available in all contexts and to all threads\n    /// \\param[in] t_bv Boxed_Value to add as a global\n    /// \\param[in] t_name Name of the value to add\n    /// \\throw chaiscript::exception::global_non_const If t_bv is not a constant object\n    /// \\sa Boxed_Value::is_const\n    ChaiScript &add_global_const(const Boxed_Value &t_bv, const std::string &t_name)\n    {\n      m_engine.add_global_const(t_bv, t_name);\n      return *this;\n    }\n\n    /// \\brief Adds a mutable object that is available in all contexts and to all threads\n    /// \\param[in] t_bv Boxed_Value to add as a global\n    /// \\param[in] t_name Name of the value to add\n    /// \\warning The user is responsible for making sure the object is thread-safe if necessary\n    ///          ChaiScript is thread-safe but provides no threading locking mechanism to the script\n    ChaiScript &add_global(const Boxed_Value &t_bv, const std::string &t_name)\n    {\n      m_engine.add_global(t_bv, t_name);\n      return *this;\n    }\n\n    ChaiScript &set_global(const Boxed_Value &t_bv, const std::string &t_name)\n    {\n      m_engine.set_global(t_bv, t_name);\n      return *this;\n    }\n\n    /// \\brief Represents the current state of the ChaiScript system. State and be saved and restored\n    /// \\warning State object does not contain the user defined type conversions of the engine. They\n    ///          are left out due to performance considerations involved in tracking the state\n    /// \\sa ChaiScript::get_state\n    /// \\sa ChaiScript::set_state\n    struct State\n    {\n      std::set<std::string> used_files;\n      chaiscript::detail::Dispatch_Engine::State engine_state;\n      std::set<std::string> active_loaded_modules;\n    };\n\n    /// \\brief Returns a state object that represents the current state of the global system\n    ///\n    /// The global system includes the reserved words, global const objects, functions and types.\n    /// local variables are thread specific and not included.\n    ///\n    /// \\return Current state of the global system\n    ///\n    /// \\b Example:\n    ///\n    /// \\code\n    /// chaiscript::ChaiScript chai;\n    /// chaiscript::ChaiScript::State s = chai.get_state(); // represents bootstrapped initial state\n    /// \\endcode\n    State get_state() const\n    {\n      chaiscript::detail::threading::lock_guard<chaiscript::detail::threading::recursive_mutex> l(m_use_mutex);\n      chaiscript::detail::threading::shared_lock<chaiscript::detail::threading::shared_mutex> l2(m_mutex);\n\n      State s;\n      s.used_files = m_used_files;\n      s.engine_state = m_engine.get_state();\n      s.active_loaded_modules = m_active_loaded_modules;\n      return s;\n    }\n\n    /// \\brief Sets the state of the system\n    ///\n    /// The global system includes the reserved words, global objects, functions and types.\n    /// local variables are thread specific and not included.\n    ///\n    /// \\param[in] t_state New state to set\n    ///\n    /// \\b Example:\n    /// \\code\n    /// chaiscript::ChaiScript chai;\n    /// chaiscript::ChaiScript::State s = chai.get_state(); // get initial state\n    /// chai.add(chaiscript::fun(&somefunction), \"somefunction\");\n    /// chai.set_state(s); // restore initial state, which does not have the recently added \"somefunction\"\n    /// \\endcode\n    void set_state(const State &t_state)\n    {\n      chaiscript::detail::threading::lock_guard<chaiscript::detail::threading::recursive_mutex> l(m_use_mutex);\n      chaiscript::detail::threading::shared_lock<chaiscript::detail::threading::shared_mutex> l2(m_mutex);\n\n      m_used_files = t_state.used_files;\n      m_active_loaded_modules = t_state.active_loaded_modules;\n      m_engine.set_state(t_state.engine_state);\n    }\n\n    /// \\returns All values in the local thread state, added through the add() function\n    std::map<std::string, Boxed_Value> get_locals() const\n    {\n      return m_engine.get_locals();\n    }\n\n    /// \\brief Sets all of the locals for the current thread state.\n    ///\n    /// \\param[in] t_locals The map<name, value> set of variables to replace the current state with\n    ///\n    /// Any existing locals are removed and the given set of variables is added\n    void set_locals(const std::map<std::string, Boxed_Value> &t_locals)\n    {\n      m_engine.set_locals(t_locals);\n    }\n\n    /// \\brief Adds a type, function or object to ChaiScript. Objects are added to the local thread state.\n    /// \\param[in] t_t Item to add\n    /// \\param[in] t_name Name of item to add\n    /// \\returns Reference to current ChaiScript object\n    /// \n    /// \\b Examples:\n    /// \\code\n    /// chaiscript::ChaiScript chai;\n    /// chai.add(chaiscript::user_type<MyClass>(), \"MyClass\"); // Add explicit type info (not strictly necessary)\n    /// chai.add(chaiscript::fun(&MyClass::function), \"function\"); // Add a class method\n    /// MyClass obj;\n    /// chai.add(chaiscript::var(&obj), \"obj\"); // Add a pointer to a locally defined object\n    /// \\endcode\n    ///\n    /// \\sa \\ref adding_items\n    template<typename T>\n    ChaiScript &add(const T &t_t, const std::string &t_name)\n    {\n      m_engine.add(t_t, t_name);\n      return *this;\n    }\n\n    /// \\brief Add a new conversion for upcasting to a base class\n    /// \\sa chaiscript::base_class\n    /// \\param[in] d Base class / parent class \n    ///\n    /// \\b Example:\n    /// \\code\n    /// chaiscript::ChaiScript chai;\n    /// chai.add(chaiscript::base_class<std::runtime_error, chaiscript::dispatch_error>());\n    /// \\endcode\n    ChaiScript &add(const Type_Conversion &d)\n    {\n      m_engine.add(d);\n      return *this;\n    }\n\n    /// \\brief Adds all elements of a module to ChaiScript runtime\n    /// \\param[in] t_p The module to add.\n    /// \\sa chaiscript::Module\n    ChaiScript &add(const ModulePtr &t_p)\n    {\n      t_p->apply(*this, this->get_eval_engine());\n      return *this;\n    }\n\n    /// \\brief Load a binary module from a dynamic library. Works on platforms that support\n    ///        dynamic libraries.\n    /// \\param[in] t_module_name Name of the module to load\n    ///\n    /// The module is searched for in the registered module path folders (chaiscript::ChaiScript::ChaiScript)\n    /// and with standard prefixes and postfixes: (\"lib\"|\"\")\\<t_module_name\\>(\".dll\"|\".so\"|\".bundle\"|\"\").\n    ///\n    /// Once the file is located, the system looks for the symbol \"create_chaiscript_module_\\<t_module_name\\>\".\n    /// If no file can be found matching the search criteria and containing the appropriate entry point \n    /// (the symbol mentioned above), an exception is thrown.\n    ///\n    /// \\throw chaiscript::exception::load_module_error In the event that no matching module can be found.\n    std::string load_module(const std::string &t_module_name)\n    {\n      std::vector<exception::load_module_error> errors;\n      std::string version_stripped_name = t_module_name;\n      size_t version_pos = version_stripped_name.find(\"-\"+version());\n      if (version_pos != std::string::npos)\n      {\n        version_stripped_name.erase(version_pos);\n      }\n\n      std::vector<std::string> prefixes{\"lib\", \"cyg\", \"\"};\n\n      std::vector<std::string> postfixes{\".dll\", \".so\", \".bundle\", \"\"};\n\n      for (auto & elem : m_module_paths)\n      {\n        for (auto & prefix : prefixes)\n        {\n          for (auto & postfix : postfixes)\n          {\n            try {\n              const auto name = elem + prefix + t_module_name + postfix;\n              // std::cerr << \"trying location: \" << name << '\\n';\n              load_module(version_stripped_name, name);\n              return name;\n            } catch (const chaiscript::exception::load_module_error &e) {\n              // std::cerr << \"error: \" << e.what() << '\\n';\n              errors.push_back(e);\n              // Try next set\n            }\n          }\n        }\n      }\n\n      std::string errstring;\n\n      for (std::vector<exception::load_module_error>::const_iterator itr = errors.begin();\n           itr != errors.end();\n           ++itr)\n      {\n        if (!errstring.empty())\n        {\n          errstring += \"; \";\n        }\n\n        errstring += itr->what();\n      }\n\n      throw chaiscript::exception::load_module_error(\"Unable to find module: \" + t_module_name + \" Errors: \" + errstring);\n    }\n\n    /// \\brief Load a binary module from a dynamic library. Works on platforms that support\n    ///        dynamic libraries.\n    ///\n    /// \\param[in] t_module_name Module name to load\n    /// \\param[in] t_filename Ignore normal filename search process and use specific filename\n    ///\n    /// \\sa ChaiScript::load_module(const std::string &t_module_name)\n    void load_module(const std::string &t_module_name, const std::string &t_filename)\n    {\n      chaiscript::detail::threading::lock_guard<chaiscript::detail::threading::recursive_mutex> l(m_use_mutex);\n\n      if (m_loaded_modules.count(t_module_name) == 0)\n      {\n        detail::Loadable_Module_Ptr lm(new detail::Loadable_Module(t_module_name, t_filename));\n        m_loaded_modules[t_module_name] = lm;\n        m_active_loaded_modules.insert(t_module_name);\n        add(lm->m_moduleptr);\n      } else if (m_active_loaded_modules.count(t_module_name) == 0) {\n        m_active_loaded_modules.insert(t_module_name);\n        add(m_loaded_modules[t_module_name]->m_moduleptr);\n      } \n    }\n\n\n    /// \\brief Evaluates a string. Equivalent to ChaiScript::eval.\n    ///\n    /// \\param[in] t_script Script to execute\n    /// \\param[in] t_handler Optional Exception_Handler used for automatic unboxing of script thrown exceptions\n    ///\n    /// \\return result of the script execution\n    /// \n    /// \\throw chaiscript::exception::eval_error In the case that evaluation fails.\n    Boxed_Value operator()(const std::string &t_script, const Exception_Handler &t_handler = Exception_Handler())\n    {\n      try {\n        return do_eval(t_script);\n      } catch (Boxed_Value &bv) {\n        if (t_handler) {\n          t_handler->handle(bv, m_engine);\n        }\n        throw;\n      }\n    }\n\n    /// \\brief Evaluates a string and returns a typesafe result.\n    ///\n    /// \\tparam T Type to extract from the result value of the script execution\n    /// \\param[in] t_input Script to execute\n    /// \\param[in] t_handler Optional Exception_Handler used for automatic unboxing of script thrown exceptions\n    /// \\param[in] t_filename Optional filename to report to the user for where the error occured. Useful\n    ///                       in special cases where you are loading a file internally instead of using eval_file\n    ///\n    /// \\return result of the script execution\n    /// \n    /// \\throw chaiscript::exception::eval_error In the case that evaluation fails.\n    /// \\throw chaiscript::exception::bad_boxed_cast In the case that evaluation succeeds but the result value cannot be converted\n    ///        to the requested type.\n    template<typename T>\n    T eval(const std::string &t_input, const Exception_Handler &t_handler = Exception_Handler(), const std::string &t_filename=\"__EVAL__\")\n    {\n      try {\n        return m_engine.boxed_cast<T>(do_eval(t_input, t_filename));\n      } catch (Boxed_Value &bv) {\n        if (t_handler) {\n          t_handler->handle(bv, m_engine);\n        }\n        throw;\n      }\n    }\n\n    /// \\brief casts an object while applying any Dynamic_Conversion available\n    template<typename Type>\n      typename detail::Cast_Helper<Type>::Result_Type boxed_cast(const Boxed_Value &bv) const\n      {\n        return m_engine.boxed_cast<Type>(bv);\n      }\n \n\n    /// \\brief Evaluates a string.\n    ///\n    /// \\param[in] t_input Script to execute\n    /// \\param[in] t_handler Optional Exception_Handler used for automatic unboxing of script thrown exceptions\n    /// \\param[in] t_filename Optional filename to report to the user for where the error occurred. Useful\n    ///                       in special cases where you are loading a file internally instead of using eval_file\n    ///\n    /// \\return result of the script execution\n    /// \n    /// \\throw exception::eval_error In the case that evaluation fails.\n    Boxed_Value eval(const std::string &t_input, const Exception_Handler &t_handler = Exception_Handler(), const std::string &t_filename=\"__EVAL__\")\n    {\n      try {\n        return do_eval(t_input, t_filename);\n      } catch (Boxed_Value &bv) {\n        if (t_handler) {\n          t_handler->handle(bv, m_engine);\n        }\n        throw;\n      }\n    }\n\n    /// \\brief Loads the file specified by filename, evaluates it, and returns the result.\n    /// \\param[in] t_filename File to load and parse.\n    /// \\param[in] t_handler Optional Exception_Handler used for automatic unboxing of script thrown exceptions\n    /// \\return result of the script execution\n    /// \\throw chaiscript::exception::eval_error In the case that evaluation fails.\n    Boxed_Value eval_file(const std::string &t_filename, const Exception_Handler &t_handler = Exception_Handler()) {\n      try {\n        return do_eval(load_file(t_filename), t_filename);\n      } catch (Boxed_Value &bv) {\n        if (t_handler) {\n          t_handler->handle(bv, m_engine);\n        }\n        throw;\n      }\n    }\n\n    /// \\brief Loads the file specified by filename, evaluates it, and returns the type safe result.\n    /// \\tparam T Type to extract from the result value of the script execution\n    /// \\param[in] t_filename File to load and parse.\n    /// \\param[in] t_handler Optional Exception_Handler used for automatic unboxing of script thrown exceptions\n    /// \\return result of the script execution\n    /// \\throw chaiscript::exception::eval_error In the case that evaluation fails.\n    /// \\throw chaiscript::exception::bad_boxed_cast In the case that evaluation succeeds but the result value cannot be converted\n    ///        to the requested type.\n    template<typename T>\n    T eval_file(const std::string &t_filename, const Exception_Handler &t_handler = Exception_Handler()) {\n      try {\n        return m_engine.boxed_cast<T>(do_eval(load_file(t_filename), t_filename));\n      } catch (Boxed_Value &bv) {\n        if (t_handler) {\n          t_handler->handle(bv, m_engine);\n        }\n        throw;\n      }\n    }\n  };\n\n}\n#endif /* CHAISCRIPT_ENGINE_HPP_ */\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-henson-master-mt4pvbwo3sc6hu4gktcdjfn34gp7hwmf/spack-src/include/henson/puppet.hpp": "#ifndef HENSON_PUPPET_HPP\n#define HENSON_PUPPET_HPP\n\n#include <vector>\n#include <stdexcept>\n#include <iostream>\n#include <fstream>\n#include <cstring>\n#include <memory>\n\n#include <unistd.h>\n#include <errno.h>\n#include <dlfcn.h>\n\n#include <mpi.h>\n\n#include <fmt/format.h>\n#include <henson/data.hpp>\n#include <henson/procs.hpp>\n\n#include \"coroutine.hpp\"\n\nnamespace henson\n{\nstruct Puppet: public Coroutine<Puppet>\n{\n    using Parent = Coroutine<Puppet>;\n\n    typedef             int  (*MainType)(int argc, char *argv[]);\n    typedef             void (*SetContextType)(void* parent, void* local);\n    typedef             void (*SetWorldType)(MPI_Comm world);\n    typedef             void (*SetNameMapType)(void* namemap);\n    typedef             void (*SetProcMapType)(void* procmap);\n    typedef             void (*SetStopType)(int* stop);\n\n                        Puppet(const std::string& fn, int argc, char** argv, ProcMap* procmap, NameMap* namemap):\n                            Parent(fn),\n                            filename_(fn),\n                            argc_(argc), argv_(argc_)\n                        {\n                            for (int i = 0; i < argc_; ++i)\n                            {\n                                argv_[i] = new char[strlen(argv[i]) + 1];\n                                strcpy(argv_[i], argv[i]);\n                            }\n\n                            load(procmap, namemap);\n                        }\n\n                        Puppet(const std::string& fn, const std::vector<std::string>& args, ProcMap* procmap, NameMap* namemap):\n                            Parent(fn),\n                            filename_(fn),\n                            argc_(args.size()), argv_(argc_)\n                        {\n                            for (int i = 0; i < argc_; ++i)\n                            {\n                                argv_[i] = new char[strlen(args[i].c_str()) + 1];\n                                strcpy(argv_[i], args[i].c_str());\n                            }\n\n                            load(procmap, namemap);\n                        }\n\n    void                load(ProcMap* procmap, NameMap* namemap)\n                        {\n                            void* lib = dlopen(filename_.c_str(), RTLD_LAZY);\n                            lib_ = lib;\n                            if (lib == NULL)\n                                throw std::runtime_error(fmt::format(\"Could not load {}\\n{}\\n\", filename_, dlerror()));\n\n                            main_ = get_function<MainType>(lib, \"main\");\n\n                            get_function<SetContextType>(lib, \"henson_set_contexts\")(&from_, &to_);\n                            get_function<SetProcMapType>(lib, \"henson_set_procmap\")(procmap);\n                            get_function<SetStopType>   (lib, \"henson_set_stop\")(&stop_);\n\n                            try\n                            {\n                                get_function<SetNameMapType>(lib, \"henson_set_namemap\")(namemap);\n                            } catch(std::runtime_error& e)\n                            {\n                                // it's a weird situation, but possible if the puppet doesn't need to get any data in or out\n                                // (the linker may choose not to pull src/data.cpp and so henson_set_namemap will be missing)\n                                log_->warn(\"{} | Reasonable only if {} doesn't need to exchange any data\", e.what(), filename_);\n                            }\n                        }\n\n                        ~Puppet()\n                        {\n                            if(running_)\n                            {\n                                signal_stop();\n                                proceed();\n                            }\n\n                            for (char* a : argv_)\n                                delete[] a;\n\n                            dlclose(lib_);\n                        }\n\n    static void         exec(void* self_)\n    {\n        Puppet* self = (Puppet*) self_;\n\n        while(true)\n        {\n            self->running_ = true;\n            self->start_time_ = get_time();\n            self->result_ = self->main_(self->argc_,&self->argv_[0]);\n            self->running_ = false;\n            self->yield();      // the time for the final portion will get recorded thanks to this call\n        }\n    }\n\n    template<class T>\n    T                   get_function(void* lib, const char* name)\n    {\n        T f = (T) dlsym(lib, name);\n        if (f == NULL)\n            throw std::runtime_error(fmt::format(\"Could not load {}() in {}\\n{}\\n\", name, filename_, dlerror()));\n        return f;\n    }\n\n    std::string         filename_;\n    int                 argc_;\n    std::vector<char*>  argv_;\n\n    MainType            main_;\n    void*               lib_;\n};\n\n\n}\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-henson-master-mt4pvbwo3sc6hu4gktcdjfn34gp7hwmf/spack-src/ext/pybind11/include/pybind11/detail/internals.h": "/*\n    pybind11/detail/internals.h: Internal data structure and related functions\n\n    Copyright (c) 2017 Wenzel Jakob <wenzel.jakob@epfl.ch>\n\n    All rights reserved. Use of this source code is governed by a\n    BSD-style license that can be found in the LICENSE file.\n*/\n\n#pragma once\n\n#include \"../pytypes.h\"\n\nNAMESPACE_BEGIN(PYBIND11_NAMESPACE)\nNAMESPACE_BEGIN(detail)\n// Forward declarations\ninline PyTypeObject *make_static_property_type();\ninline PyTypeObject *make_default_metaclass();\ninline PyObject *make_object_base_type(PyTypeObject *metaclass);\n\n// The old Python Thread Local Storage (TLS) API is deprecated in Python 3.7 in favor of the new\n// Thread Specific Storage (TSS) API.\n#if PY_VERSION_HEX >= 0x03070000\n#    define PYBIND11_TLS_KEY_INIT(var) Py_tss_t *var = nullptr\n#    define PYBIND11_TLS_GET_VALUE(key) PyThread_tss_get((key))\n#    define PYBIND11_TLS_REPLACE_VALUE(key, value) PyThread_tss_set((key), (value))\n#    define PYBIND11_TLS_DELETE_VALUE(key) PyThread_tss_set((key), nullptr)\n#    define PYBIND11_TLS_FREE(key) PyThread_tss_free(key)\n#else\n    // Usually an int but a long on Cygwin64 with Python 3.x\n#    define PYBIND11_TLS_KEY_INIT(var) decltype(PyThread_create_key()) var = 0\n#    define PYBIND11_TLS_GET_VALUE(key) PyThread_get_key_value((key))\n#    if PY_MAJOR_VERSION < 3\n#        define PYBIND11_TLS_DELETE_VALUE(key)                               \\\n             PyThread_delete_key_value(key)\n#        define PYBIND11_TLS_REPLACE_VALUE(key, value)                       \\\n             do {                                                            \\\n                 PyThread_delete_key_value((key));                           \\\n                 PyThread_set_key_value((key), (value));                     \\\n             } while (false)\n#    else\n#        define PYBIND11_TLS_DELETE_VALUE(key)                               \\\n             PyThread_set_key_value((key), nullptr)\n#        define PYBIND11_TLS_REPLACE_VALUE(key, value)                       \\\n             PyThread_set_key_value((key), (value))\n#    endif\n#    define PYBIND11_TLS_FREE(key) (void)key\n#endif\n\n// Python loads modules by default with dlopen with the RTLD_LOCAL flag; under libc++ and possibly\n// other STLs, this means `typeid(A)` from one module won't equal `typeid(A)` from another module\n// even when `A` is the same, non-hidden-visibility type (e.g. from a common include).  Under\n// libstdc++, this doesn't happen: equality and the type_index hash are based on the type name,\n// which works.  If not under a known-good stl, provide our own name-based hash and equality\n// functions that use the type name.\n#if defined(__GLIBCXX__)\ninline bool same_type(const std::type_info &lhs, const std::type_info &rhs) { return lhs == rhs; }\nusing type_hash = std::hash<std::type_index>;\nusing type_equal_to = std::equal_to<std::type_index>;\n#else\ninline bool same_type(const std::type_info &lhs, const std::type_info &rhs) {\n    return lhs.name() == rhs.name() || std::strcmp(lhs.name(), rhs.name()) == 0;\n}\n\nstruct type_hash {\n    size_t operator()(const std::type_index &t) const {\n        size_t hash = 5381;\n        const char *ptr = t.name();\n        while (auto c = static_cast<unsigned char>(*ptr++))\n            hash = (hash * 33) ^ c;\n        return hash;\n    }\n};\n\nstruct type_equal_to {\n    bool operator()(const std::type_index &lhs, const std::type_index &rhs) const {\n        return lhs.name() == rhs.name() || std::strcmp(lhs.name(), rhs.name()) == 0;\n    }\n};\n#endif\n\ntemplate <typename value_type>\nusing type_map = std::unordered_map<std::type_index, value_type, type_hash, type_equal_to>;\n\nstruct overload_hash {\n    inline size_t operator()(const std::pair<const PyObject *, const char *>& v) const {\n        size_t value = std::hash<const void *>()(v.first);\n        value ^= std::hash<const void *>()(v.second)  + 0x9e3779b9 + (value<<6) + (value>>2);\n        return value;\n    }\n};\n\n/// Internal data structure used to track registered instances and types.\n/// Whenever binary incompatible changes are made to this structure,\n/// `PYBIND11_INTERNALS_VERSION` must be incremented.\nstruct internals {\n    type_map<type_info *> registered_types_cpp; // std::type_index -> pybind11's type information\n    std::unordered_map<PyTypeObject *, std::vector<type_info *>> registered_types_py; // PyTypeObject* -> base type_info(s)\n    std::unordered_multimap<const void *, instance*> registered_instances; // void * -> instance*\n    std::unordered_set<std::pair<const PyObject *, const char *>, overload_hash> inactive_overload_cache;\n    type_map<std::vector<bool (*)(PyObject *, void *&)>> direct_conversions;\n    std::unordered_map<const PyObject *, std::vector<PyObject *>> patients;\n    std::forward_list<void (*) (std::exception_ptr)> registered_exception_translators;\n    std::unordered_map<std::string, void *> shared_data; // Custom data to be shared across extensions\n    std::vector<PyObject *> loader_patient_stack; // Used by `loader_life_support`\n    std::forward_list<std::string> static_strings; // Stores the std::strings backing detail::c_str()\n    PyTypeObject *static_property_type;\n    PyTypeObject *default_metaclass;\n    PyObject *instance_base;\n#if defined(WITH_THREAD)\n    PYBIND11_TLS_KEY_INIT(tstate);\n    PyInterpreterState *istate = nullptr;\n    ~internals() {\n        // This destructor is called *after* Py_Finalize() in finalize_interpreter().\n        // That *SHOULD BE* fine. The following details what happens whe PyThread_tss_free is called.\n        // PYBIND11_TLS_FREE is PyThread_tss_free on python 3.7+. On older python, it does nothing.\n        // PyThread_tss_free calls PyThread_tss_delete and PyMem_RawFree.\n        // PyThread_tss_delete just calls TlsFree (on Windows) or pthread_key_delete (on *NIX). Neither\n        // of those have anything to do with CPython internals.\n        // PyMem_RawFree *requires* that the `tstate` be allocated with the CPython allocator.\n        PYBIND11_TLS_FREE(tstate);\n    }\n#endif\n};\n\n/// Additional type information which does not fit into the PyTypeObject.\n/// Changes to this struct also require bumping `PYBIND11_INTERNALS_VERSION`.\nstruct type_info {\n    PyTypeObject *type;\n    const std::type_info *cpptype;\n    size_t type_size, type_align, holder_size_in_ptrs;\n    void *(*operator_new)(size_t);\n    void (*init_instance)(instance *, const void *);\n    void (*dealloc)(value_and_holder &v_h);\n    std::vector<PyObject *(*)(PyObject *, PyTypeObject *)> implicit_conversions;\n    std::vector<std::pair<const std::type_info *, void *(*)(void *)>> implicit_casts;\n    std::vector<bool (*)(PyObject *, void *&)> *direct_conversions;\n    buffer_info *(*get_buffer)(PyObject *, void *) = nullptr;\n    void *get_buffer_data = nullptr;\n    void *(*module_local_load)(PyObject *, const type_info *) = nullptr;\n    /* A simple type never occurs as a (direct or indirect) parent\n     * of a class that makes use of multiple inheritance */\n    bool simple_type : 1;\n    /* True if there is no multiple inheritance in this type's inheritance tree */\n    bool simple_ancestors : 1;\n    /* for base vs derived holder_type checks */\n    bool default_holder : 1;\n    /* true if this is a type registered with py::module_local */\n    bool module_local : 1;\n};\n\n/// Tracks the `internals` and `type_info` ABI version independent of the main library version\n#define PYBIND11_INTERNALS_VERSION 4\n\n/// On MSVC, debug and release builds are not ABI-compatible!\n#if defined(_MSC_VER) && defined(_DEBUG)\n#   define PYBIND11_BUILD_TYPE \"_debug\"\n#else\n#   define PYBIND11_BUILD_TYPE \"\"\n#endif\n\n/// Let's assume that different compilers are ABI-incompatible.\n#if defined(_MSC_VER)\n#   define PYBIND11_COMPILER_TYPE \"_msvc\"\n#elif defined(__INTEL_COMPILER)\n#   define PYBIND11_COMPILER_TYPE \"_icc\"\n#elif defined(__clang__)\n#   define PYBIND11_COMPILER_TYPE \"_clang\"\n#elif defined(__PGI)\n#   define PYBIND11_COMPILER_TYPE \"_pgi\"\n#elif defined(__MINGW32__)\n#   define PYBIND11_COMPILER_TYPE \"_mingw\"\n#elif defined(__CYGWIN__)\n#   define PYBIND11_COMPILER_TYPE \"_gcc_cygwin\"\n#elif defined(__GNUC__)\n#   define PYBIND11_COMPILER_TYPE \"_gcc\"\n#else\n#   define PYBIND11_COMPILER_TYPE \"_unknown\"\n#endif\n\n#if defined(_LIBCPP_VERSION)\n#  define PYBIND11_STDLIB \"_libcpp\"\n#elif defined(__GLIBCXX__) || defined(__GLIBCPP__)\n#  define PYBIND11_STDLIB \"_libstdcpp\"\n#else\n#  define PYBIND11_STDLIB \"\"\n#endif\n\n/// On Linux/OSX, changes in __GXX_ABI_VERSION__ indicate ABI incompatibility.\n#if defined(__GXX_ABI_VERSION)\n#  define PYBIND11_BUILD_ABI \"_cxxabi\" PYBIND11_TOSTRING(__GXX_ABI_VERSION)\n#else\n#  define PYBIND11_BUILD_ABI \"\"\n#endif\n\n#if defined(WITH_THREAD)\n#  define PYBIND11_INTERNALS_KIND \"\"\n#else\n#  define PYBIND11_INTERNALS_KIND \"_without_thread\"\n#endif\n\n#define PYBIND11_INTERNALS_ID \"__pybind11_internals_v\" \\\n    PYBIND11_TOSTRING(PYBIND11_INTERNALS_VERSION) PYBIND11_INTERNALS_KIND PYBIND11_COMPILER_TYPE PYBIND11_STDLIB PYBIND11_BUILD_ABI PYBIND11_BUILD_TYPE \"__\"\n\n#define PYBIND11_MODULE_LOCAL_ID \"__pybind11_module_local_v\" \\\n    PYBIND11_TOSTRING(PYBIND11_INTERNALS_VERSION) PYBIND11_INTERNALS_KIND PYBIND11_COMPILER_TYPE PYBIND11_STDLIB PYBIND11_BUILD_ABI PYBIND11_BUILD_TYPE \"__\"\n\n/// Each module locally stores a pointer to the `internals` data. The data\n/// itself is shared among modules with the same `PYBIND11_INTERNALS_ID`.\ninline internals **&get_internals_pp() {\n    static internals **internals_pp = nullptr;\n    return internals_pp;\n}\n\ninline void translate_exception(std::exception_ptr p) {\n    try {\n        if (p) std::rethrow_exception(p);\n    } catch (error_already_set &e)           { e.restore();                                    return;\n    } catch (const builtin_exception &e)     { e.set_error();                                  return;\n    } catch (const std::bad_alloc &e)        { PyErr_SetString(PyExc_MemoryError,   e.what()); return;\n    } catch (const std::domain_error &e)     { PyErr_SetString(PyExc_ValueError,    e.what()); return;\n    } catch (const std::invalid_argument &e) { PyErr_SetString(PyExc_ValueError,    e.what()); return;\n    } catch (const std::length_error &e)     { PyErr_SetString(PyExc_ValueError,    e.what()); return;\n    } catch (const std::out_of_range &e)     { PyErr_SetString(PyExc_IndexError,    e.what()); return;\n    } catch (const std::range_error &e)      { PyErr_SetString(PyExc_ValueError,    e.what()); return;\n    } catch (const std::overflow_error &e)   { PyErr_SetString(PyExc_OverflowError, e.what()); return;\n    } catch (const std::exception &e)        { PyErr_SetString(PyExc_RuntimeError,  e.what()); return;\n    } catch (...) {\n        PyErr_SetString(PyExc_RuntimeError, \"Caught an unknown exception!\");\n        return;\n    }\n}\n\n#if !defined(__GLIBCXX__)\ninline void translate_local_exception(std::exception_ptr p) {\n    try {\n        if (p) std::rethrow_exception(p);\n    } catch (error_already_set &e)       { e.restore();   return;\n    } catch (const builtin_exception &e) { e.set_error(); return;\n    }\n}\n#endif\n\n/// Return a reference to the current `internals` data\nPYBIND11_NOINLINE inline internals &get_internals() {\n    auto **&internals_pp = get_internals_pp();\n    if (internals_pp && *internals_pp)\n        return **internals_pp;\n\n    // Ensure that the GIL is held since we will need to make Python calls.\n    // Cannot use py::gil_scoped_acquire here since that constructor calls get_internals.\n    struct gil_scoped_acquire_local {\n        gil_scoped_acquire_local() : state (PyGILState_Ensure()) {}\n        ~gil_scoped_acquire_local() { PyGILState_Release(state); }\n        const PyGILState_STATE state;\n    } gil;\n\n    constexpr auto *id = PYBIND11_INTERNALS_ID;\n    auto builtins = handle(PyEval_GetBuiltins());\n    if (builtins.contains(id) && isinstance<capsule>(builtins[id])) {\n        internals_pp = static_cast<internals **>(capsule(builtins[id]));\n\n        // We loaded builtins through python's builtins, which means that our `error_already_set`\n        // and `builtin_exception` may be different local classes than the ones set up in the\n        // initial exception translator, below, so add another for our local exception classes.\n        //\n        // libstdc++ doesn't require this (types there are identified only by name)\n#if !defined(__GLIBCXX__)\n        (*internals_pp)->registered_exception_translators.push_front(&translate_local_exception);\n#endif\n    } else {\n        if (!internals_pp) internals_pp = new internals*();\n        auto *&internals_ptr = *internals_pp;\n        internals_ptr = new internals();\n#if defined(WITH_THREAD)\n        PyEval_InitThreads();\n        PyThreadState *tstate = PyThreadState_Get();\n        #if PY_VERSION_HEX >= 0x03070000\n            internals_ptr->tstate = PyThread_tss_alloc();\n            if (!internals_ptr->tstate || PyThread_tss_create(internals_ptr->tstate))\n                pybind11_fail(\"get_internals: could not successfully initialize the TSS key!\");\n            PyThread_tss_set(internals_ptr->tstate, tstate);\n        #else\n            internals_ptr->tstate = PyThread_create_key();\n            if (internals_ptr->tstate == -1)\n                pybind11_fail(\"get_internals: could not successfully initialize the TLS key!\");\n            PyThread_set_key_value(internals_ptr->tstate, tstate);\n        #endif\n        internals_ptr->istate = tstate->interp;\n#endif\n        builtins[id] = capsule(internals_pp);\n        internals_ptr->registered_exception_translators.push_front(&translate_exception);\n        internals_ptr->static_property_type = make_static_property_type();\n        internals_ptr->default_metaclass = make_default_metaclass();\n        internals_ptr->instance_base = make_object_base_type(internals_ptr->default_metaclass);\n    }\n    return **internals_pp;\n}\n\n/// Works like `internals.registered_types_cpp`, but for module-local registered types:\ninline type_map<type_info *> &registered_local_types_cpp() {\n    static type_map<type_info *> locals{};\n    return locals;\n}\n\n/// Constructs a std::string with the given arguments, stores it in `internals`, and returns its\n/// `c_str()`.  Such strings objects have a long storage duration -- the internal strings are only\n/// cleared when the program exits or after interpreter shutdown (when embedding), and so are\n/// suitable for c-style strings needed by Python internals (such as PyTypeObject's tp_name).\ntemplate <typename... Args>\nconst char *c_str(Args &&...args) {\n    auto &strings = get_internals().static_strings;\n    strings.emplace_front(std::forward<Args>(args)...);\n    return strings.front().c_str();\n}\n\nNAMESPACE_END(detail)\n\n/// Returns a named pointer that is shared among all extension modules (using the same\n/// pybind11 version) running in the current interpreter. Names starting with underscores\n/// are reserved for internal usage. Returns `nullptr` if no matching entry was found.\ninline PYBIND11_NOINLINE void *get_shared_data(const std::string &name) {\n    auto &internals = detail::get_internals();\n    auto it = internals.shared_data.find(name);\n    return it != internals.shared_data.end() ? it->second : nullptr;\n}\n\n/// Set the shared data that can be later recovered by `get_shared_data()`.\ninline PYBIND11_NOINLINE void *set_shared_data(const std::string &name, void *data) {\n    detail::get_internals().shared_data[name] = data;\n    return data;\n}\n\n/// Returns a typed reference to a shared data entry (by using `get_shared_data()`) if\n/// such entry exists. Otherwise, a new object of default-constructible type `T` is\n/// added to the shared data under the given name and a reference to it is returned.\ntemplate<typename T>\nT &get_or_create_shared_data(const std::string &name) {\n    auto &internals = detail::get_internals();\n    auto it = internals.shared_data.find(name);\n    T *ptr = (T *) (it != internals.shared_data.end() ? it->second : nullptr);\n    if (!ptr) {\n        ptr = new T();\n        internals.shared_data[name] = ptr;\n    }\n    return *ptr;\n}\n\nNAMESPACE_END(PYBIND11_NAMESPACE)\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-henson-master-mt4pvbwo3sc6hu4gktcdjfn34gp7hwmf/spack-src/.git/objects/pack/pack-32d11645d711058f9055c7e599edd00381e03b09.idx",
        "/tmp/vanessa/spack-stage/spack-stage-henson-master-mt4pvbwo3sc6hu4gktcdjfn34gp7hwmf/spack-src/.git/objects/pack/pack-32d11645d711058f9055c7e599edd00381e03b09.pack"
    ],
    "total_files": 237
}